head	1.31;
access;
symbols
	OPENBSD_6_1_BASE:1.31
	OPENBSD_6_0:1.29.0.4
	OPENBSD_6_0_BASE:1.29
	OPENBSD_5_9:1.29.0.2
	OPENBSD_5_9_BASE:1.29
	OPENBSD_5_8:1.28.0.4
	OPENBSD_5_8_BASE:1.28
	OPENBSD_5_7:1.28.0.2
	OPENBSD_5_7_BASE:1.28
	OPENBSD_5_6:1.26.0.2
	OPENBSD_5_6_BASE:1.26
	OPENBSD_5_5:1.24.0.2
	OPENBSD_5_5_BASE:1.24
	OPENBSD_5_4:1.21.0.2
	OPENBSD_5_4_BASE:1.21
	OPENBSD_5_3:1.19.0.2
	OPENBSD_5_3_BASE:1.19
	OPENBSD_5_2:1.18.0.2
	OPENBSD_5_2_BASE:1.18
	OPENBSD_5_1_BASE:1.16
	OPENBSD_5_1:1.16.0.2
	OPENBSD_5_0:1.14.0.2
	OPENBSD_5_0_BASE:1.14
	OPENBSD_4_9:1.13.0.2
	OPENBSD_4_9_BASE:1.13
	OPENBSD_4_8:1.10.0.4
	OPENBSD_4_8_BASE:1.10
	OPENBSD_4_7:1.8.0.2
	OPENBSD_4_7_BASE:1.8
	OPENBSD_4_6:1.5.0.2
	OPENBSD_4_6_BASE:1.5
	OPENBSD_4_5:1.3.0.2
	OPENBSD_4_5_BASE:1.3
	OPENBSD_4_4:1.2.0.2
	OPENBSD_4_4_BASE:1.2
	OPENBSD_4_3_BASE:1.1.1.4
	OPENBSD_4_3:1.1.1.4.0.2
	v232:1.1.1.4
	v229:1.1.1.3
	OPENBSD_4_2:1.1.1.2.0.2
	OPENBSD_4_2_BASE:1.1.1.2
	v225:1.1.1.2
	v216:1.1.1.1
	xterm:1.1.1;
locks; strict;
comment	@ * @;


1.31
date	2016.11.03.14.25.06;	author matthieu;	state Exp;
branches;
next	1.30;
commitid	f4xcYrkdKFtVElPL;

1.30
date	2016.08.07.21.27.36;	author matthieu;	state Exp;
branches;
next	1.29;
commitid	psxxjI5z4Vpv2LL4;

1.29
date	2015.09.05.14.11.46;	author matthieu;	state Exp;
branches;
next	1.28;
commitid	YVUODLQ4QcYTuGkb;

1.28
date	2015.01.18.20.24.40;	author matthieu;	state Exp;
branches;
next	1.27;
commitid	PDdlFuihcMifzxwp;

1.27
date	2014.12.18.20.16.55;	author matthieu;	state Exp;
branches;
next	1.26;
commitid	pCMhkpVdt9Oe52hU;

1.26
date	2014.07.14.08.30.11;	author matthieu;	state Exp;
branches;
next	1.25;
commitid	EnwNNUjlkdrocnMa;

1.25
date	2014.05.09.19.56.40;	author matthieu;	state Exp;
branches;
next	1.24;

1.24
date	2014.02.14.19.40.03;	author matthieu;	state Exp;
branches;
next	1.23;

1.23
date	2014.01.02.15.14.50;	author matthieu;	state Exp;
branches;
next	1.22;

1.22
date	2013.08.26.20.06.13;	author matthieu;	state Exp;
branches;
next	1.21;

1.21
date	2013.06.02.19.55.50;	author matthieu;	state Exp;
branches;
next	1.20;

1.20
date	2013.03.09.14.45.38;	author matthieu;	state Exp;
branches;
next	1.19;

1.19
date	2013.01.04.16.40.18;	author matthieu;	state Exp;
branches;
next	1.18;

1.18
date	2012.06.07.20.20.23;	author matthieu;	state Exp;
branches;
next	1.17;

1.17
date	2012.04.14.09.02.46;	author matthieu;	state Exp;
branches;
next	1.16;

1.16
date	2011.11.16.21.14.25;	author matthieu;	state Exp;
branches;
next	1.15;

1.15
date	2011.09.17.11.51.57;	author matthieu;	state Exp;
branches;
next	1.14;

1.14
date	2011.03.07.20.41.27;	author matthieu;	state Exp;
branches;
next	1.13;

1.13
date	2010.10.23.19.14.52;	author matthieu;	state Exp;
branches;
next	1.12;

1.12
date	2010.10.05.19.37.23;	author matthieu;	state Exp;
branches;
next	1.11;

1.11
date	2010.08.22.13.38.11;	author matthieu;	state Exp;
branches;
next	1.10;

1.10
date	2010.05.08.12.20.46;	author matthieu;	state Exp;
branches;
next	1.9;

1.9
date	2010.03.25.22.03.51;	author matthieu;	state Exp;
branches;
next	1.8;

1.8
date	2009.10.31.14.11.57;	author matthieu;	state Exp;
branches;
next	1.7;

1.7
date	2009.09.19.00.03.36;	author sthen;	state Exp;
branches;
next	1.6;

1.6
date	2009.09.05.15.58.09;	author matthieu;	state Exp;
branches;
next	1.5;

1.5
date	2009.04.04.15.10.44;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2009.03.09.22.13.04;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2009.01.06.20.10.21;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2008.03.19.21.15.46;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.26.11.11.44;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.11.26.11.11.44;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2007.06.15.19.30.37;	author matthieu;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2007.08.25.18.54.11;	author matthieu;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2008.02.16.09.35.18;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.31
log
@Update to xterm 327
@
text
@/* $XTermId: util.c,v 1.693 2016/10/07 00:41:38 tom Exp $ */

/*
 * Copyright 1999-2015,2016 by Thomas E. Dickey
 *
 *                         All Rights Reserved
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 *
 * The above copyright notice and this permission notice shall be included
 * in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
 * IN NO EVENT SHALL THE ABOVE LISTED COPYRIGHT HOLDER(S) BE LIABLE FOR ANY
 * CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
 * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
 * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 *
 * Except as contained in this notice, the name(s) of the above copyright
 * holders shall not be used in advertising or otherwise to promote the
 * sale, use or other dealings in this Software without prior written
 * authorization.
 *
 *
 * Copyright 1987 by Digital Equipment Corporation, Maynard, Massachusetts.
 *
 *                         All Rights Reserved
 *
 * Permission to use, copy, modify, and distribute this software and its
 * documentation for any purpose and without fee is hereby granted,
 * provided that the above copyright notice appear in all copies and that
 * both that copyright notice and this permission notice appear in
 * supporting documentation, and that the name of Digital Equipment
 * Corporation not be used in advertising or publicity pertaining to
 * distribution of the software without specific, written prior permission.
 *
 *
 * DIGITAL DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING
 * ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL
 * DIGITAL BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR
 * ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
 * WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
 * ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
 * SOFTWARE.
 */

/* util.c */

#include <xterm.h>

#include <data.h>
#include <error.h>
#include <menu.h>
#include <fontutils.h>
#include <xstrings.h>

#include <stdio.h>
#include <string.h>
#include <ctype.h>
#include <assert.h>

#if OPT_WIDE_CHARS
#if defined(HAVE_WCHAR_H) && defined(HAVE_WCWIDTH)
#include <wchar.h>
#endif
#include <wcwidth.h>
#endif

#ifdef HAVE_X11_EXTENSIONS_XINERAMA_H
#include <X11/extensions/Xinerama.h>
#endif /* HAVE_X11_EXTENSIONS_XINERAMA_H */

#include <graphics.h>

static int handle_translated_exposure(XtermWidget xw,
				      int rect_x,
				      int rect_y,
				      int rect_width,
				      int rect_height);
static void ClearLeft(XtermWidget xw);
static void CopyWait(XtermWidget xw);
static void horizontal_copy_area(XtermWidget xw,
				 int firstchar,
				 int nchars,
				 int amount);
static void vertical_copy_area(XtermWidget xw,
			       int firstline,
			       int nlines,
			       int amount,
			       int left,
			       int right);

#if OPT_WIDE_CHARS
unsigned first_widechar;
int (*my_wcwidth) (wchar_t);
#endif

#if OPT_WIDE_CHARS
/*
 * We will modify the 'n' cells beginning at the current position.
 * Some of those cells may be part of multi-column characters, including
 * carryover from the left.  Find the limits of the multi-column characters
 * that we should fill with blanks, return true if filling is needed.
 */
int
DamagedCells(TScreen *screen, unsigned n, int *klp, int *krp, int row, int col)
{
    CLineData *ld = getLineData(screen, row);
    int result = False;

    assert(ld);
    if (col < (int) ld->lineSize) {
	int nn = (int) n;
	int kl = col;
	int kr = col + nn;

	if (kr >= (int) ld->lineSize) {
	    nn = (ld->lineSize - col - 1);
	    kr = col + nn;
	}

	if (nn > 0) {
	    assert(kl < (int) ld->lineSize);
	    if (ld->charData[kl] == HIDDEN_CHAR) {
		while (kl > 0) {
		    if (ld->charData[--kl] != HIDDEN_CHAR) {
			break;
		    }
		}
	    } else {
		kl = col + 1;
	    }

	    assert(kr < (int) ld->lineSize);
	    if (ld->charData[kr] == HIDDEN_CHAR) {
		while (kr < screen->max_col) {
		    assert((kr + 1) < (int) ld->lineSize);
		    if (ld->charData[++kr] != HIDDEN_CHAR) {
			--kr;
			break;
		    }
		}
	    } else {
		kr = col - 1;
	    }

	    if (klp)
		*klp = kl;
	    if (krp)
		*krp = kr;
	    result = (kr >= kl);
	}
    }

    return result;
}

int
DamagedCurCells(TScreen *screen, unsigned n, int *klp, int *krp)
{
    return DamagedCells(screen, n, klp, krp, screen->cur_row, screen->cur_col);
}
#endif /* OPT_WIDE_CHARS */

/*
 * These routines are used for the jump scroll feature
 */
void
FlushScroll(XtermWidget xw)
{
    TScreen *screen = TScreenOf(xw);
    int i;
    int shift = INX2ROW(screen, 0);
    int bot = screen->max_row - shift;
    int refreshtop;
    int refreshheight;
    int scrolltop;
    int scrollheight;
    int left = ScrnLeftMargin(xw);
    int right = ScrnRightMargin(xw);
    Boolean full_lines = (Boolean) ((left == 0) && (right == screen->max_col));

    if (screen->cursor_state)
	HideCursor();

    TRACE(("FlushScroll %s-lines scroll:%d refresh %d\n",
	   full_lines ? "full" : "partial",
	   screen->scroll_amt,
	   screen->refresh_amt));

    if (screen->scroll_amt > 0) {
	/*
	 * Lines will be scrolled "up".
	 */
	refreshheight = screen->refresh_amt;
	scrollheight = screen->bot_marg - screen->top_marg - refreshheight + 1;
	refreshtop = screen->bot_marg - refreshheight + 1 + shift;
	i = screen->max_row - screen->scroll_amt + 1;
	if (refreshtop > i) {
	    refreshtop = i;
	}

	/*
	 * If this is the normal (not alternate) screen, and the top margin is
	 * at the top of the screen, then we will shift full lines scrolled out
	 * of the scrolling region into the saved-lines.
	 */
	if (screen->scrollWidget
	    && !screen->whichBuf
	    && full_lines
	    && screen->top_marg == 0) {
	    scrolltop = 0;
	    scrollheight += shift;
	    if (scrollheight > i)
		scrollheight = i;
	    i = screen->bot_marg - bot;
	    if (i > 0) {
		refreshheight -= i;
		if (refreshheight < screen->scroll_amt) {
		    refreshheight = screen->scroll_amt;
		}
	    }
	    i = screen->savedlines;
	    if (i < screen->savelines) {
		i += screen->scroll_amt;
		if (i > screen->savelines) {
		    i = screen->savelines;
		}
		screen->savedlines = i;
		ScrollBarDrawThumb(screen->scrollWidget);
	    }
	} else {
	    scrolltop = screen->top_marg + shift;
	    i = bot - (screen->bot_marg - screen->refresh_amt + screen->scroll_amt);
	    if (i > 0) {
		if (bot < screen->bot_marg) {
		    refreshheight = screen->scroll_amt + i;
		}
	    } else {
		scrollheight += i;
		refreshheight = screen->scroll_amt;
		i = screen->top_marg + screen->scroll_amt - 1 - bot;
		if (i > 0) {
		    refreshtop += i;
		    refreshheight -= i;
		}
	    }
	}
    } else {
	/*
	 * Lines will be scrolled "down".
	 */
	refreshheight = -screen->refresh_amt;
	scrollheight = screen->bot_marg - screen->top_marg - refreshheight + 1;
	refreshtop = screen->top_marg + shift;
	scrolltop = refreshtop + refreshheight;
	i = screen->bot_marg - bot;
	if (i > 0) {
	    scrollheight -= i;
	}
	i = screen->top_marg + refreshheight - 1 - bot;
	if (i > 0) {
	    refreshheight -= i;
	}
    }

    vertical_copy_area(xw,
		       scrolltop + screen->scroll_amt,
		       scrollheight,
		       screen->scroll_amt,
		       left,
		       right);
    ScrollSelection(screen, -(screen->scroll_amt), False);
    screen->scroll_amt = 0;
    screen->refresh_amt = 0;

    if (refreshheight > 0) {
	ClearCurBackground(xw,
			   refreshtop,
			   left,
			   (unsigned) refreshheight,
			   (unsigned) (right + 1 - left),
			   (unsigned) FontWidth(screen));
	ScrnRefresh(xw,
		    refreshtop,
		    0,
		    refreshheight,
		    MaxCols(screen),
		    False);
    }
    return;
}

/*
 * Returns true if there are lines off-screen due to scrolling which should
 * include the current line.  If false, the line is visible and we should
 * paint it now rather than waiting for the line to become visible.
 */
static Bool
AddToRefresh(XtermWidget xw)
{
    TScreen *screen = TScreenOf(xw);
    int amount = screen->refresh_amt;
    int row = screen->cur_row;
    Bool result;

    if (amount == 0) {
	result = False;
    } else if (amount > 0) {
	int bottom;

	if (row == (bottom = screen->bot_marg) - amount) {
	    screen->refresh_amt++;
	    result = True;
	} else {
	    result = (row >= bottom - amount + 1 && row <= bottom);
	}
    } else {
	int top;

	amount = -amount;
	if (row == (top = screen->top_marg) + amount) {
	    screen->refresh_amt--;
	    result = True;
	} else {
	    result = (row <= top + amount - 1 && row >= top);
	}
    }

    /*
     * If this line is visible, and there are scrolled-off lines, flush out
     * those which are now visible.
     */
    if (!result && screen->scroll_amt)
	FlushScroll(xw);

    return result;
}

/*
 * Returns true if the current row is in the visible area (it should be for
 * screen operations) and incidentally flush the scrolled-in lines which
 * have newly become visible.
 */
static Bool
AddToVisible(XtermWidget xw)
{
    TScreen *screen = TScreenOf(xw);
    Bool result = False;

    if (INX2ROW(screen, screen->cur_row) <= screen->max_row) {
	if (!AddToRefresh(xw)) {
	    result = True;
	}
    }
    return result;
}

/*
 * If we're scrolling, leave the selection intact if possible.
 * If it will bump into one of the extremes of the saved-lines, truncate that.
 * If the selection is not entirely contained within the margins and not
 * entirely outside the margins, clear it.
 */
static void
adjustHiliteOnFwdScroll(XtermWidget xw, int amount, Bool all_lines)
{
    TScreen *screen = TScreenOf(xw);
    int lo_row = (all_lines
		  ? (screen->bot_marg - screen->savelines)
		  : screen->top_marg);
    int hi_row = screen->bot_marg;
    int left = ScrnLeftMargin(xw);
    int right = ScrnRightMargin(xw);

    TRACE2(("adjustSelection FWD %s by %d (%s)\n",
	    screen->whichBuf ? "alternate" : "normal",
	    amount,
	    all_lines ? "all" : "visible"));
    TRACE2(("  before highlite %d.%d .. %d.%d\n",
	    screen->startH.row,
	    screen->startH.col,
	    screen->endH.row,
	    screen->endH.col));
    TRACE2(("  margins %d..%d\n", screen->top_marg, screen->bot_marg));
    TRACE2(("  limits  %d..%d\n", lo_row, hi_row));

    if ((left > 0 || right < screen->max_col) &&
	((screen->startH.row >= lo_row &&
	  screen->startH.row - amount <= hi_row) ||
	 (screen->endH.row >= lo_row &&
	  screen->endH.row - amount <= hi_row))) {
	/*
	 * This could be improved slightly by excluding the special case where
	 * the selection is on a single line outside left/right margins.
	 */
	TRACE2(("deselect because selection overlaps with scrolled partial-line\n"));
	ScrnDisownSelection(xw);
    } else if (screen->startH.row >= lo_row
	       && screen->startH.row - amount < lo_row) {
	/* truncate the selection because its start would move out of region */
	if (lo_row + amount <= screen->endH.row) {
	    TRACE2(("truncate selection by changing start %d.%d to %d.%d\n",
		    screen->startH.row,
		    screen->startH.col,
		    lo_row + amount,
		    0));
	    screen->startH.row = lo_row + amount;
	    screen->startH.col = 0;
	} else {
	    TRACE2(("deselect because %d.%d .. %d.%d shifted %d is outside margins %d..%d\n",
		    screen->startH.row,
		    screen->startH.col,
		    screen->endH.row,
		    screen->endH.col,
		    -amount,
		    lo_row,
		    hi_row));
	    ScrnDisownSelection(xw);
	}
    } else if (screen->startH.row <= hi_row && screen->endH.row > hi_row) {
	TRACE2(("deselect because selection straddles top-margin\n"));
	ScrnDisownSelection(xw);
    } else if (screen->startH.row < lo_row && screen->endH.row > lo_row) {
	TRACE2(("deselect because selection straddles bottom-margin\n"));
	ScrnDisownSelection(xw);
    }

    TRACE2(("  after highlite %d.%d .. %d.%d\n",
	    screen->startH.row,
	    screen->startH.col,
	    screen->endH.row,
	    screen->endH.col));
}

/*
 * This is the same as adjustHiliteOnFwdScroll(), but reversed.  In this case,
 * only the visible lines are affected.
 */
static void
adjustHiliteOnBakScroll(XtermWidget xw, int amount)
{
    TScreen *screen = TScreenOf(xw);
    int lo_row = screen->top_marg;
    int hi_row = screen->bot_marg;

    TRACE2(("adjustSelection BAK %s by %d (%s)\n",
	    screen->whichBuf ? "alternate" : "normal",
	    amount,
	    "visible"));
    TRACE2(("  before highlite %d.%d .. %d.%d\n",
	    screen->startH.row,
	    screen->startH.col,
	    screen->endH.row,
	    screen->endH.col));
    TRACE2(("  margins %d..%d\n", screen->top_marg, screen->bot_marg));

    if (screen->endH.row >= hi_row
	&& screen->endH.row + amount > hi_row) {
	/* truncate the selection because its start would move out of region */
	if (hi_row - amount >= screen->startH.row) {
	    TRACE2(("truncate selection by changing start %d.%d to %d.%d\n",
		    screen->startH.row,
		    screen->startH.col,
		    hi_row - amount,
		    0));
	    screen->endH.row = hi_row - amount;
	    screen->endH.col = 0;
	} else {
	    TRACE2(("deselect because %d.%d .. %d.%d shifted %d is outside margins %d..%d\n",
		    screen->startH.row,
		    screen->startH.col,
		    screen->endH.row,
		    screen->endH.col,
		    amount,
		    lo_row,
		    hi_row));
	    ScrnDisownSelection(xw);
	}
    } else if (screen->endH.row >= lo_row && screen->startH.row < lo_row) {
	ScrnDisownSelection(xw);
    } else if (screen->endH.row > hi_row && screen->startH.row > hi_row) {
	ScrnDisownSelection(xw);
    }

    TRACE2(("  after highlite %d.%d .. %d.%d\n",
	    screen->startH.row,
	    screen->startH.col,
	    screen->endH.row,
	    screen->endH.col));
}

/*
 * Move cells in LineData's on the current screen to simulate scrolling by the
 * given amount of lines.
 */
static void
scrollInMargins(XtermWidget xw, int amount, int top)
{
    TScreen *screen = TScreenOf(xw);
    LineData *src;
    LineData *dst;
    int row;
    int left = ScrnLeftMargin(xw);
    int right = ScrnRightMargin(xw);
    int length = right + 1 - left;

    if (amount > 0) {
	for (row = top; row <= screen->bot_marg - amount; ++row) {
	    if ((src = getLineData(screen, row + amount)) != 0
		&& (dst = getLineData(screen, row)) != 0) {
		CopyCells(screen, src, dst, left, length);
	    }
	}
	while (row <= screen->bot_marg) {
	    ClearCells(xw, 0, (unsigned) length, row, left);
	    ++row;
	}
    } else if (amount < 0) {
	for (row = screen->bot_marg; row >= top - amount; --row) {
	    if ((src = getLineData(screen, row + amount)) != 0
		&& (dst = getLineData(screen, row)) != 0) {
		CopyCells(screen, src, dst, left, length);
	    }
	}
	while (row >= top) {
	    ClearCells(xw, 0, (unsigned) length, row, left);
	    --row;
	}
    }
}

/*
 * scrolls the screen by amount lines, erases bottom, doesn't alter
 * cursor position (i.e. cursor moves down amount relative to text).
 * All done within the scrolling region, of course.
 * requires: amount > 0
 */
void
xtermScroll(XtermWidget xw, int amount)
{
    TScreen *screen = TScreenOf(xw);
    int i;
    int refreshtop = 0;
    int refreshheight;
    int left = ScrnLeftMargin(xw);
    int right = ScrnRightMargin(xw);
    Boolean scroll_all_lines = (Boolean) (screen->scrollWidget
					  && !screen->whichBuf
					  && screen->top_marg == 0);

    TRACE(("xtermScroll count=%d\n", amount));

    screen->cursor_busy += 1;
    screen->cursor_moved = True;

    if (screen->cursor_state)
	HideCursor();

    i = screen->bot_marg - screen->top_marg + 1;
    if (amount > i)
	amount = i;

#if OPT_SCROLL_LOCK
    if (screen->allowScrollLock && screen->scroll_lock) {
	refreshheight = 0;
	screen->scroll_amt = 0;
	screen->refresh_amt = 0;
	if (--(screen->topline) < -screen->savelines) {
	    screen->topline = -screen->savelines;
	    screen->scroll_dirty = True;
	}
	if (++(screen->savedlines) > screen->savelines) {
	    screen->savedlines = screen->savelines;
	}
    } else
#endif
    {
	if (ScrnHaveSelection(screen))
	    adjustHiliteOnFwdScroll(xw, amount, scroll_all_lines);

	if (screen->jumpscroll) {
	    if (screen->scroll_amt > 0) {
		if (!screen->fastscroll) {
		    if (screen->refresh_amt + amount > i)
			FlushScroll(xw);
		}
		screen->scroll_amt += amount;
		screen->refresh_amt += amount;
	    } else {
		if (!screen->fastscroll) {
		    if (screen->scroll_amt < 0)
			FlushScroll(xw);
		}
		screen->scroll_amt = amount;
		screen->refresh_amt = amount;
	    }
	    refreshheight = 0;
	} else {
	    int scrolltop;
	    int scrollheight;
	    int shift;
	    int bot;

	    ScrollSelection(screen, -(amount), False);
	    if (amount == i) {
		ClearScreen(xw);
		screen->cursor_busy -= 1;
		return;
	    }

	    shift = INX2ROW(screen, 0);
	    bot = screen->max_row - shift;
	    scrollheight = i - amount;
	    refreshheight = amount;

	    if ((refreshtop = screen->bot_marg - refreshheight + 1 + shift) >
		(i = screen->max_row - refreshheight + 1))
		refreshtop = i;

	    if (scroll_all_lines) {
		scrolltop = 0;
		if ((scrollheight += shift) > i)
		    scrollheight = i;
		if ((i = screen->savedlines) < screen->savelines) {
		    if ((i += amount) > screen->savelines)
			i = screen->savelines;
		    screen->savedlines = i;
		    ScrollBarDrawThumb(screen->scrollWidget);
		}
	    } else {
		scrolltop = screen->top_marg + shift;
		if ((i = screen->bot_marg - bot) > 0) {
		    scrollheight -= i;
		    if ((i = screen->top_marg + amount - 1 - bot) >= 0) {
			refreshtop += i;
			refreshheight -= i;
		    }
		}
	    }

	    if (screen->multiscroll && amount == 1 &&
		screen->topline == 0 && screen->top_marg == 0 &&
		screen->bot_marg == screen->max_row) {
		if (screen->incopy < 0 && screen->scrolls == 0)
		    CopyWait(xw);
		screen->scrolls++;
	    }

	    vertical_copy_area(xw,
			       scrolltop + amount,
			       scrollheight,
			       amount,
			       left,
			       right);

	    if (refreshheight > 0) {
		ClearCurBackground(xw,
				   refreshtop,
				   left,
				   (unsigned) refreshheight,
				   (unsigned) (right + 1 - left),
				   (unsigned) FontWidth(screen));
		if (refreshheight > shift)
		    refreshheight = shift;
	    }
	}
    }

    if (amount > 0) {
	if (left > 0 || right < screen->max_col) {
	    scrollInMargins(xw, amount, screen->top_marg);
	} else if (scroll_all_lines) {
	    ScrnDeleteLine(xw,
			   screen->saveBuf_index,
			   screen->bot_marg + screen->savelines,
			   0,
			   (unsigned) amount);
	} else {
	    ScrnDeleteLine(xw,
			   screen->visbuf,
			   screen->bot_marg,
			   screen->top_marg,
			   (unsigned) amount);
	}
    }

    scroll_displayed_graphics(xw, amount);

    if (refreshheight > 0) {
	ScrnRefresh(xw,
		    refreshtop,
		    left,
		    refreshheight,
		    right + 1 - left,
		    False);
    }

    screen->cursor_busy -= 1;
    return;
}

/*
 * This is from ISO 6429, not found in any of DEC's terminals.
 */
void
xtermScrollLR(XtermWidget xw, int amount, Bool toLeft)
{
    if (amount > 0) {
	xtermColScroll(xw, amount, toLeft, 0);
    }
}

/*
 * Implement DECBI/DECFI (back/forward column index)
 */
void
xtermColIndex(XtermWidget xw, Bool toLeft)
{
    TScreen *screen = TScreenOf(xw);
    int margin;

    if (toLeft) {
	margin = ScrnLeftMargin(xw);
	if (screen->cur_col > margin) {
	    CursorBack(xw, 1);
	} else if (screen->cur_col == margin) {
	    xtermColScroll(xw, 1, False, screen->cur_col);
	}
    } else {
	margin = ScrnRightMargin(xw);
	if (screen->cur_col < margin) {
	    CursorForward(xw, 1);
	} else if (screen->cur_col == margin) {
	    xtermColScroll(xw, 1, True, ScrnLeftMargin(xw));
	}
    }
}

/*
 * Implement DECDC/DECIC (delete/insert column)
 */
void
xtermColScroll(XtermWidget xw, int amount, Bool toLeft, int at_col)
{
    TScreen *screen = TScreenOf(xw);

    if (amount > 0) {
	int min_row;
	int max_row;

	if (ScrnHaveRowMargins(screen)) {
	    min_row = screen->top_marg;
	    max_row = screen->bot_marg;
	} else {
	    min_row = 0;
	    max_row = screen->max_row;
	}

	if (screen->cur_row >= min_row
	    && screen->cur_row <= max_row
	    && screen->cur_col >= screen->lft_marg
	    && screen->cur_col <= screen->rgt_marg) {
	    int save_row = screen->cur_row;
	    int save_col = screen->cur_col;
	    int row;

	    screen->cur_col = at_col;
	    if (toLeft) {
		for (row = min_row; row <= max_row; row++) {
		    screen->cur_row = row;
		    ScrnDeleteChar(xw, (unsigned) amount);
		}
	    } else {
		for (row = min_row; row <= max_row; row++) {
		    screen->cur_row = row;
		    ScrnInsertChar(xw, (unsigned) amount);
		}
	    }
	    screen->cur_row = save_row;
	    screen->cur_col = save_col;
	    xtermRepaint(xw);
	}
    }
}

/*
 * Reverse scrolls the screen by amount lines, erases top, doesn't alter
 * cursor position (i.e. cursor moves up amount relative to text).
 * All done within the scrolling region, of course.
 * Requires: amount > 0
 */
void
RevScroll(XtermWidget xw, int amount)
{
    TScreen *screen = TScreenOf(xw);
    int i = screen->bot_marg - screen->top_marg + 1;
    int left = ScrnLeftMargin(xw);
    int right = ScrnRightMargin(xw);

    TRACE(("RevScroll count=%d\n", amount));

    screen->cursor_busy += 1;
    screen->cursor_moved = True;

    if (screen->cursor_state)
	HideCursor();

    if (amount > i)
	amount = i;

    if (ScrnHaveSelection(screen))
	adjustHiliteOnBakScroll(xw, amount);

    if (screen->jumpscroll) {
	if (screen->scroll_amt < 0) {
	    if (-screen->refresh_amt + amount > i)
		FlushScroll(xw);
	    screen->scroll_amt -= amount;
	    screen->refresh_amt -= amount;
	} else {
	    if (screen->scroll_amt > 0)
		FlushScroll(xw);
	    screen->scroll_amt = -amount;
	    screen->refresh_amt = -amount;
	}
    } else {
	int shift = INX2ROW(screen, 0);
	int bot = screen->max_row - shift;
	int refreshheight = amount;
	int refreshtop = screen->top_marg + shift;
	int scrollheight = (screen->bot_marg
			    - screen->top_marg - refreshheight + 1);
	int scrolltop = refreshtop + refreshheight;

	if ((i = screen->bot_marg - bot) > 0)
	    scrollheight -= i;
	if ((i = screen->top_marg + refreshheight - 1 - bot) > 0)
	    refreshheight -= i;

	if (screen->multiscroll && amount == 1 &&
	    screen->topline == 0 && screen->top_marg == 0 &&
	    screen->bot_marg == screen->max_row) {
	    if (screen->incopy < 0 && screen->scrolls == 0)
		CopyWait(xw);
	    screen->scrolls++;
	}

	vertical_copy_area(xw,
			   scrolltop - amount,
			   scrollheight,
			   -amount,
			   left,
			   right);

	if (refreshheight > 0) {
	    ClearCurBackground(xw,
			       refreshtop,
			       left,
			       (unsigned) refreshheight,
			       (unsigned) (right + 1 - left),
			       (unsigned) FontWidth(screen));
	}
    }
    if (amount > 0) {
	if (left > 0 || right < screen->max_col) {
	    scrollInMargins(xw, -amount, screen->top_marg);
	} else {
	    ScrnInsertLine(xw,
			   screen->visbuf,
			   screen->bot_marg,
			   screen->top_marg,
			   (unsigned) amount);
	}
    }
    screen->cursor_busy -= 1;
    return;
}

#if OPT_ZICONBEEP
void
initZIconBeep(void)
{
    if (resource.zIconBeep > 100 || resource.zIconBeep < -100) {
	resource.zIconBeep = 0;	/* was 100, but I prefer to defaulting off. */
	xtermWarning("a number between -100 and 100 is required for zIconBeep.  0 used by default\n");
    }
}

static char *
getIconName(void)
{
    static char *icon_name;
    static Arg args[] =
    {
	{XtNiconName, (XtArgVal) & icon_name}
    };

    icon_name = NULL;
    XtGetValues(toplevel, args, XtNumber(args));
    return icon_name;
}

static void
setZIconBeep(XtermWidget xw)
{
    TScreen *screen = TScreenOf(xw);

    /* Flag icon name with "***"  on window output when iconified.
     */
    if (resource.zIconBeep && mapstate == IsUnmapped && !screen->zIconBeep_flagged) {
	char *icon_name = getIconName();
	if (icon_name != NULL) {
	    screen->zIconBeep_flagged = True;
	    ChangeIconName(xw, icon_name);
	}
	xtermBell(xw, XkbBI_Info, 0);
    }
    mapstate = -1;
}

/*
 * If warning should be given then give it
 */
Boolean
showZIconBeep(XtermWidget xw, char *name)
{
    Boolean code = False;

    if (resource.zIconBeep && TScreenOf(xw)->zIconBeep_flagged) {
	char *format = resource.zIconFormat;
	char *newname = CastMallocN(char, strlen(name) + strlen(format) + 1);
	if (!newname) {
	    xtermWarning("malloc failed in showZIconBeep\n");
	} else {
	    char *marker = strstr(format, "%s");
	    char *result = newname;
	    if (marker != 0) {
		size_t skip = (size_t) (marker - format);
		if (skip) {
		    strncpy(result, format, skip);
		    result += skip;
		}
		strcpy(result, name);
		strcat(result, marker + 2);
	    } else {
		strcpy(result, format);
		strcat(result, name);
	    }
	    ChangeGroup(xw, XtNiconName, newname);
	    free(newname);
	}
	code = True;
    }
    return code;
}

/*
 * Restore the icon name, resetting the state for zIconBeep.
 */
void
resetZIconBeep(XtermWidget xw)
{
    TScreen *screen = TScreenOf(xw);

    if (screen->zIconBeep_flagged) {
	char *icon_name = getIconName();
	screen->zIconBeep_flagged = False;
	if (icon_name != NULL) {
	    char *buf = CastMallocN(char, strlen(icon_name));
	    if (buf == NULL) {
		screen->zIconBeep_flagged = True;
	    } else {
		char *format = resource.zIconFormat;
		char *marker = strstr(format, "%s");
		Boolean found = False;

		if (marker != 0) {
		    if (marker == format
			|| !strncmp(icon_name, format, (size_t) (marker - format))) {
			found = True;
			strcpy(buf, icon_name + (marker - format));
			marker += 2;
			if (*marker != '\0') {
			    size_t len_m = strlen(marker);
			    size_t len_b = strlen(buf);
			    if (len_m < len_b
				&& !strcmp(buf + len_b - len_m, marker)) {
				buf[len_b - len_m] = '\0';
			    }
			}
		    }
		} else if (!strncmp(icon_name, format, strlen(format))) {
		    strcpy(buf, icon_name + strlen(format));
		    found = True;
		}
		if (found)
		    ChangeIconName(xw, buf);
		free(buf);
	    }
	}
    }
}
#else
#define setZIconBeep(xw)	/* nothing */
#endif /* OPT_ZICONBEEP */

/*
 * write a string str of length len onto the screen at
 * the current cursor position.  update cursor position.
 */
void
WriteText(XtermWidget xw, IChar *str, Cardinal len)
{
    TScreen *screen = TScreenOf(xw);
    CLineData *ld = 0;
    unsigned attr_flags = xw->flags;
    CellColor fg_bg = makeColorPair(xw->cur_foreground, xw->cur_background);
    unsigned cells = visual_width(str, len);
    GC currentGC;

    TRACE(("WriteText %d (%2d,%2d) %3d:%s\n",
	   screen->topline,
	   screen->cur_row,
	   screen->cur_col,
	   len, visibleIChars(str, len)));

    if (cells + (unsigned) screen->cur_col > (unsigned) MaxCols(screen)) {
	cells = (unsigned) (MaxCols(screen) - screen->cur_col);
    }

    if (ScrnHaveSelection(screen)
	&& ScrnIsRowInSelection(screen, INX2ROW(screen, screen->cur_row))) {
	ScrnDisownSelection(xw);
    }

    /* if we are in insert-mode, reserve space for the new cells */
    if (attr_flags & INSERT) {
	InsertChar(xw, cells);
    }

    if (AddToVisible(xw)
	&& ((ld = getLineData(screen, screen->cur_row))) != 0) {
	unsigned test;

	if (screen->cursor_state)
	    HideCursor();

	/*
	 * If we overwrite part of a multi-column character, fill the rest
	 * of it with blanks.
	 */
	if_OPT_WIDE_CHARS(screen, {
	    int kl;
	    int kr;
	    if (DamagedCurCells(screen, cells, &kl, &kr))
		ClearInLine(xw, screen->cur_row, kl, (unsigned) (kr - kl + 1));
	});

	if (attr_flags & INVISIBLE) {
	    Cardinal n;
	    for (n = 0; n < cells; ++n)
		str[n] = ' ';
	}

	TRACE(("WriteText calling drawXtermText (%d) (%d,%d)\n",
	       LineCharSet(screen, ld),
	       screen->cur_col,
	       screen->cur_row));

	test = attr_flags;
#if OPT_ISO_COLORS
	{
	    int fg;
	    if (screen->colorAttrMode) {
		fg = MapToColorMode(xw->cur_foreground, screen, attr_flags);
	    } else {
		fg = xw->cur_foreground;
	    }
	    checkVeryBoldColors(test, fg);
	}
#endif

	/* make sure that the correct GC is current */
	currentGC = updatedXtermGC(xw, attr_flags, fg_bg, False);

	drawXtermText(xw,
		      test & DRAWX_MASK,
		      0,
		      currentGC,
		      LineCursorX(screen, ld, screen->cur_col),
		      CursorY(screen, screen->cur_row),
		      LineCharSet(screen, ld),
		      str, len, 0);

	resetXtermGC(xw, attr_flags, False);
    }

    ScrnWriteText(xw, str, attr_flags, fg_bg, len);
    CursorForward(xw, (int) cells);
    setZIconBeep(xw);
    return;
}

/*
 * If cursor not in scrolling region, returns.  Else,
 * inserts n blank lines at the cursor's position.  Lines above the
 * bottom margin are lost.
 */
void
InsertLine(XtermWidget xw, int n)
{
    TScreen *screen = TScreenOf(xw);
    int i;
    int left = ScrnLeftMargin(xw);
    int right = ScrnRightMargin(xw);

    if (!ScrnIsRowInMargins(screen, screen->cur_row)
	|| screen->cur_col < left
	|| screen->cur_col > right)
	return;

    TRACE(("InsertLine count=%d\n", n));

    if (screen->cursor_state)
	HideCursor();

    if (ScrnHaveSelection(screen)
	&& ScrnAreRowsInSelection(screen,
				  INX2ROW(screen, screen->top_marg),
				  INX2ROW(screen, screen->cur_row - 1))
	&& ScrnAreRowsInSelection(screen,
				  INX2ROW(screen, screen->cur_row),
				  INX2ROW(screen, screen->bot_marg))) {
	ScrnDisownSelection(xw);
    }

    ResetWrap(screen);
    if (n > (i = screen->bot_marg - screen->cur_row + 1))
	n = i;
    if (screen->jumpscroll) {
	if (screen->scroll_amt <= 0 &&
	    screen->cur_row <= -screen->refresh_amt) {
	    if (-screen->refresh_amt + n > MaxRows(screen))
		FlushScroll(xw);
	    screen->scroll_amt -= n;
	    screen->refresh_amt -= n;
	} else {
	    if (screen->scroll_amt)
		FlushScroll(xw);
	}
    }
    if (!screen->scroll_amt) {
	int shift = INX2ROW(screen, 0);
	int bot = screen->max_row - shift;
	int refreshheight = n;
	int refreshtop = screen->cur_row + shift;
	int scrolltop = refreshtop + refreshheight;
	int scrollheight = (screen->bot_marg
			    - screen->cur_row - refreshheight + 1);

	if ((i = screen->bot_marg - bot) > 0)
	    scrollheight -= i;
	if ((i = screen->cur_row + refreshheight - 1 - bot) > 0)
	    refreshheight -= i;
	vertical_copy_area(xw, scrolltop - n, scrollheight, -n, left, right);
	if (refreshheight > 0) {
	    ClearCurBackground(xw,
			       refreshtop,
			       left,
			       (unsigned) refreshheight,
			       (unsigned) (right + 1 - left),
			       (unsigned) FontWidth(screen));
	}
    }
    if (n > 0) {
	if (left > 0 || right < screen->max_col) {
	    scrollInMargins(xw, -n, screen->cur_row);
	} else {
	    ScrnInsertLine(xw,
			   screen->visbuf,
			   screen->bot_marg,
			   screen->cur_row,
			   (unsigned) n);
	}
    }
}

/*
 * If cursor not in scrolling region, returns.  Else, deletes n lines
 * at the cursor's position, lines added at bottom margin are blank.
 */
void
DeleteLine(XtermWidget xw, int n)
{
    TScreen *screen = TScreenOf(xw);
    int i;
    int left = ScrnLeftMargin(xw);
    int right = ScrnRightMargin(xw);
    Boolean scroll_all_lines = (Boolean) (screen->scrollWidget
					  && !screen->whichBuf
					  && screen->cur_row == 0);

    if (!ScrnIsRowInMargins(screen, screen->cur_row) ||
	!ScrnIsColInMargins(screen, screen->cur_col))
	return;

    TRACE(("DeleteLine count=%d\n", n));

    if (screen->cursor_state)
	HideCursor();

    if (n > (i = screen->bot_marg - screen->cur_row + 1)) {
	n = i;
    }
    if (ScrnHaveSelection(screen)
	&& ScrnAreRowsInSelection(screen,
				  INX2ROW(screen, screen->cur_row),
				  INX2ROW(screen, screen->cur_row + n - 1))) {
	ScrnDisownSelection(xw);
    }

    ResetWrap(screen);
    if (screen->jumpscroll) {
	if (screen->scroll_amt >= 0 && screen->cur_row == screen->top_marg) {
	    if (screen->refresh_amt + n > MaxRows(screen))
		FlushScroll(xw);
	    screen->scroll_amt += n;
	    screen->refresh_amt += n;
	} else {
	    if (screen->scroll_amt)
		FlushScroll(xw);
	}
    }

    /* adjust screen->buf */
    if (n > 0) {
	if (left > 0 || right < screen->max_col) {
	    scrollInMargins(xw, n, screen->cur_row);
	} else if (scroll_all_lines) {
	    ScrnDeleteLine(xw,
			   screen->saveBuf_index,
			   screen->bot_marg + screen->savelines,
			   0,
			   (unsigned) n);
	} else {
	    ScrnDeleteLine(xw,
			   screen->visbuf,
			   screen->bot_marg,
			   screen->cur_row,
			   (unsigned) n);
	}
    }

    /* repaint the screen, as needed */
    if (!screen->scroll_amt) {
	int shift = INX2ROW(screen, 0);
	int bot = screen->max_row - shift;
	int refreshtop;
	int refreshheight = n;
	int scrolltop;
	int scrollheight = i - n;

	if ((refreshtop = screen->bot_marg - refreshheight + 1 + shift) >
	    (i = screen->max_row - refreshheight + 1))
	    refreshtop = i;
	if (scroll_all_lines) {
	    scrolltop = 0;
	    if ((scrollheight += shift) > i)
		scrollheight = i;
	    if ((i = screen->savedlines) < screen->savelines) {
		if ((i += n) > screen->savelines)
		    i = screen->savelines;
		screen->savedlines = i;
		ScrollBarDrawThumb(screen->scrollWidget);
	    }
	} else {
	    scrolltop = screen->cur_row + shift;
	    if ((i = screen->bot_marg - bot) > 0) {
		scrollheight -= i;
		if ((i = screen->cur_row + n - 1 - bot) >= 0) {
		    refreshheight -= i;
		}
	    }
	}
	vertical_copy_area(xw, scrolltop + n, scrollheight, n, left, right);
	if (shift > 0 && refreshheight > 0) {
	    int rows = refreshheight;
	    if (rows > shift)
		rows = shift;
	    ScrnUpdate(xw, refreshtop, 0, rows, MaxCols(screen), True);
	    refreshtop += shift;
	    refreshheight -= shift;
	}
	if (refreshheight > 0) {
	    ClearCurBackground(xw,
			       refreshtop,
			       left,
			       (unsigned) refreshheight,
			       (unsigned) (right + 1 - left),
			       (unsigned) FontWidth(screen));
	}
    }
}

/*
 * Insert n blanks at the cursor's position, no wraparound
 */
void
InsertChar(XtermWidget xw, unsigned n)
{
    TScreen *screen = TScreenOf(xw);
    CLineData *ld;
    unsigned limit;
    int row = INX2ROW(screen, screen->cur_row);
    int left = ScrnLeftMargin(xw);
    int right = ScrnRightMargin(xw);

    if (screen->cursor_state)
	HideCursor();

    TRACE(("InsertChar count=%d\n", n));

    if (ScrnHaveSelection(screen)
	&& ScrnIsRowInSelection(screen, row)) {
	ScrnDisownSelection(xw);
    }
    ResetWrap(screen);

    limit = (unsigned) (right + 1 - screen->cur_col);

    if (n > limit)
	n = limit;

    if (screen->cur_col < left || screen->cur_col > right) {
	n = 0;
    } else if (AddToVisible(xw)
	       && (ld = getLineData(screen, screen->cur_row)) != 0) {
	int col = right + 1 - (int) n;

	/*
	 * If we shift part of a multi-column character, fill the rest
	 * of it with blanks.  Do similar repair for the text which will
	 * be shifted into the right-margin.
	 */
	if_OPT_WIDE_CHARS(screen, {
	    int kl;
	    int kr = screen->cur_col;
	    if (DamagedCurCells(screen, n, &kl, (int *) 0) && kr > kl) {
		ClearInLine(xw, screen->cur_row, kl, (unsigned) (kr - kl + 1));
	    }
	    kr = screen->max_col - (int) n + 1;
	    if (DamagedCells(screen, n, &kl, (int *) 0,
			     screen->cur_row,
			     kr) && kr > kl) {
		ClearInLine(xw, screen->cur_row, kl, (unsigned) (kr - kl + 1));
	    }
	});

#if OPT_DEC_CHRSET
	if (CSET_DOUBLE(GetLineDblCS(ld))) {
	    col = MaxCols(screen) / 2 - (int) n;
	}
#endif
	/*
	 * prevent InsertChar from shifting the end of a line over
	 * if it is being appended to
	 */
	if (non_blank_line(screen, screen->cur_row,
			   screen->cur_col, MaxCols(screen))) {
	    horizontal_copy_area(xw, screen->cur_col,
				 col - screen->cur_col,
				 (int) n);
	}

	ClearCurBackground(xw,
			   INX2ROW(screen, screen->cur_row),
			   screen->cur_col,
			   1U,
			   n,
			   (unsigned) LineFontWidth(screen, ld));
    }
    if (n != 0) {
	/* adjust screen->buf */
	ScrnInsertChar(xw, n);
    }
}

/*
 * Deletes n chars at the cursor's position, no wraparound.
 */
void
DeleteChar(XtermWidget xw, unsigned n)
{
    TScreen *screen = TScreenOf(xw);
    CLineData *ld;
    unsigned limit;
    int row = INX2ROW(screen, screen->cur_row);
    int right = ScrnRightMargin(xw);

    if (screen->cursor_state)
	HideCursor();

    if (!ScrnIsColInMargins(screen, screen->cur_col))
	return;

    TRACE(("DeleteChar count=%d\n", n));

    if (ScrnHaveSelection(screen)
	&& ScrnIsRowInSelection(screen, row)) {
	ScrnDisownSelection(xw);
    }
    ResetWrap(screen);

    limit = (unsigned) (right + 1 - screen->cur_col);

    if (n > limit)
	n = limit;

    if (AddToVisible(xw)
	&& (ld = getLineData(screen, screen->cur_row)) != 0) {
	int col = right + 1 - (int) n;

	/*
	 * If we delete part of a multi-column character, fill the rest
	 * of it with blanks.
	 */
	if_OPT_WIDE_CHARS(screen, {
	    int kl;
	    int kr;
	    if (DamagedCurCells(screen, n, &kl, &kr))
		ClearInLine(xw, screen->cur_row, kl, (unsigned) (kr - kl + 1));
	});

#if OPT_DEC_CHRSET
	if (CSET_DOUBLE(GetLineDblCS(ld))) {
	    col = MaxCols(screen) / 2 - (int) n;
	}
#endif
	horizontal_copy_area(xw,
			     (screen->cur_col + (int) n),
			     col - screen->cur_col,
			     -((int) n));

	ClearCurBackground(xw,
			   INX2ROW(screen, screen->cur_row),
			   col,
			   1U,
			   n,
			   (unsigned) LineFontWidth(screen, ld));
    }
    if (n != 0) {
	/* adjust screen->buf */
	ScrnDeleteChar(xw, n);
    }
}

/*
 * Clear from cursor position to beginning of display, inclusive.
 */
static void
ClearAbove(XtermWidget xw)
{
    TScreen *screen = TScreenOf(xw);

    if (screen->protected_mode != OFF_PROTECT) {
	int row;
	unsigned len = (unsigned) MaxCols(screen);

	assert(screen->max_col >= 0);
	for (row = 0; row < screen->cur_row; row++)
	    ClearInLine(xw, row, 0, len);
	ClearInLine(xw, screen->cur_row, 0, (unsigned) screen->cur_col);
    } else {
	int top;

	if (screen->cursor_state)
	    HideCursor();
	if ((top = INX2ROW(screen, 0)) <= screen->max_row) {
	    int height;

	    if (screen->scroll_amt)
		FlushScroll(xw);
	    if ((height = screen->cur_row + top) > screen->max_row)
		height = screen->max_row + 1;
	    if ((height -= top) > 0) {
		chararea_clear_displayed_graphics(screen,
						  0,
						  top,
						  MaxCols(screen),
						  height);

		ClearCurBackground(xw,
				   top,
				   0,
				   (unsigned) height,
				   (unsigned) MaxCols(screen),
				   (unsigned) FontWidth(screen));
	    }
	}
	ClearBufRows(xw, 0, screen->cur_row - 1);
    }

    ClearLeft(xw);
}

/*
 * Clear from cursor position to end of display, inclusive.
 */
static void
ClearBelow(XtermWidget xw)
{
    TScreen *screen = TScreenOf(xw);

    ClearRight(xw, -1);

    if (screen->protected_mode != OFF_PROTECT) {
	int row;
	unsigned len = (unsigned) MaxCols(screen);

	assert(screen->max_col >= 0);
	for (row = screen->cur_row + 1; row <= screen->max_row; row++)
	    ClearInLine(xw, row, 0, len);
    } else {
	int top;

	if ((top = INX2ROW(screen, screen->cur_row)) <= screen->max_row) {
	    if (screen->scroll_amt)
		FlushScroll(xw);
	    if (++top <= screen->max_row) {
		chararea_clear_displayed_graphics(screen,
						  0,
						  top,
						  MaxCols(screen),
						  (screen->max_row - top + 1));
		ClearCurBackground(xw,
				   top,
				   0,
				   (unsigned) (screen->max_row - top + 1),
				   (unsigned) MaxCols(screen),
				   (unsigned) FontWidth(screen));
	    }
	}
	ClearBufRows(xw, screen->cur_row + 1, screen->max_row);
    }
}

/*
 * Clear the given row, for the given range of columns, returning 1 if no
 * protected characters were found, 0 otherwise.
 */
static int
ClearInLine2(XtermWidget xw, int flags, int row, int col, unsigned len)
{
    TScreen *screen = TScreenOf(xw);
    CLineData *ld;
    int rc = 1;

    TRACE(("ClearInLine(row=%d, col=%d, len=%d) vs %d..%d\n",
	   row, col, len,
	   screen->startH.row,
	   screen->startH.col));

    if (ScrnHaveSelection(screen)
	&& ScrnIsRowInSelection(screen, row)) {
	ScrnDisownSelection(xw);
    }

    if (col + (int) len >= MaxCols(screen)) {
	len = (unsigned) (MaxCols(screen) - col);
    }

    /* If we've marked protected text on the screen, we'll have to
     * check each time we do an erase.
     */
    if (screen->protected_mode != OFF_PROTECT) {
	unsigned n;
	IAttr *attrs = getLineData(screen, row)->attribs + col;
	int saved_mode = screen->protected_mode;
	Bool done;

	/* disable this branch during recursion */
	screen->protected_mode = OFF_PROTECT;

	do {
	    done = True;
	    for (n = 0; n < len; n++) {
		if (attrs[n] & PROTECTED) {
		    rc = 0;	/* found a protected segment */
		    if (n != 0) {
			ClearInLine(xw, row, col, n);
		    }
		    while ((n < len)
			   && (attrs[n] & PROTECTED)) {
			n++;
		    }
		    done = False;
		    break;
		}
	    }
	    /* setup for another segment, past the protected text */
	    if (!done) {
		attrs += n;
		col += (int) n;
		len -= n;
	    }
	} while (!done);

	screen->protected_mode = saved_mode;
	if ((int) len <= 0) {
	    return 0;
	}
    }
    /* fall through to the final non-protected segment */

    if (screen->cursor_state)
	HideCursor();
    ResetWrap(screen);

    if (AddToVisible(xw)
	&& (ld = getLineData(screen, row)) != 0) {

	ClearCurBackground(xw,
			   INX2ROW(screen, row),
			   col,
			   1U,
			   len,
			   (unsigned) LineFontWidth(screen, ld));
    }

    if (len != 0) {
	ClearCells(xw, flags, len, row, col);
    }

    return rc;
}

int
ClearInLine(XtermWidget xw, int row, int col, unsigned len)
{
    TScreen *screen = TScreenOf(xw);
    int flags = 0;

    /*
     * If we're clearing to the end of the line, we won't count this as
     * "drawn" characters.  We'll only do cut/paste on "drawn" characters,
     * so this has the effect of suppressing trailing blanks from a
     * selection.
     */
    if (col + (int) len < MaxCols(screen)) {
	flags |= CHARDRAWN;
    }
    return ClearInLine2(xw, flags, row, col, len);
}

/*
 * Clear the next n characters on the cursor's line, including the cursor's
 * position.
 */
void
ClearRight(XtermWidget xw, int n)
{
    TScreen *screen = TScreenOf(xw);
    LineData *ld;
    unsigned len = (unsigned) (MaxCols(screen) - screen->cur_col);

    assert(screen->max_col >= 0);
    assert(screen->max_col >= screen->cur_col);

    if (n < 0)			/* the remainder of the line */
	n = MaxCols(screen);
    if (n == 0)			/* default for 'ECH' */
	n = 1;

    if (len > (unsigned) n)
	len = (unsigned) n;

    ld = getLineData(screen, screen->cur_row);
    if (AddToVisible(xw)) {
	if_OPT_WIDE_CHARS(screen, {
	    int col = screen->cur_col;
	    int row = screen->cur_row;
	    int kl;
	    int kr;
	    if (DamagedCurCells(screen, len, &kl, &kr) && kr >= kl) {
		int xx = col;
		if (kl < xx) {
		    ClearInLine2(xw, 0, row, kl, (unsigned) (xx - kl));
		}
		xx = col + (int) len - 1;
		if (kr > xx) {
		    ClearInLine2(xw, 0, row, xx + 1, (unsigned) (kr - xx));
		}
	    }
	});
	(void) ClearInLine(xw, screen->cur_row, screen->cur_col, len);
    } else {
	ScrnClearCells(xw, screen->cur_row, screen->cur_col, len);
    }

    /* with the right part cleared, we can't be wrapping */
    LineClrWrapped(ld);
    if (screen->show_wrap_marks) {
	ShowWrapMarks(xw, screen->cur_row, ld);
    }
    ResetWrap(screen);
}

/*
 * Clear first part of cursor's line, inclusive.
 */
static void
ClearLeft(XtermWidget xw)
{
    TScreen *screen = TScreenOf(xw);
    unsigned len = (unsigned) screen->cur_col + 1;

    assert(screen->cur_col >= 0);
    if (AddToVisible(xw)) {
	if_OPT_WIDE_CHARS(screen, {
	    int row = screen->cur_row;
	    int kl;
	    int kr;
	    if (DamagedCurCells(screen, 1, &kl, &kr) && kr >= kl) {
		ClearInLine2(xw, 0, row, kl, (unsigned) (kr - kl + 1));
	    }
	});
	(void) ClearInLine(xw, screen->cur_row, 0, len);
    } else {
	ScrnClearCells(xw, screen->cur_row, 0, len);
    }
}

/*
 * Erase the cursor's line.
 */
static void
ClearLine(XtermWidget xw)
{
    TScreen *screen = TScreenOf(xw);
    unsigned len = (unsigned) MaxCols(screen);

    assert(screen->max_col >= 0);
    (void) ClearInLine(xw, screen->cur_row, 0, len);
}

void
ClearScreen(XtermWidget xw)
{
    TScreen *screen = TScreenOf(xw);
    int top;

    TRACE(("ClearScreen\n"));

    if (screen->cursor_state)
	HideCursor();

    ScrnDisownSelection(xw);
    ResetWrap(screen);
    if ((top = INX2ROW(screen, 0)) <= screen->max_row) {
	if (screen->scroll_amt)
	    FlushScroll(xw);
	chararea_clear_displayed_graphics(screen,
					  0,
					  top,
					  MaxCols(screen),
					  (screen->max_row - top + 1));
	ClearCurBackground(xw,
			   top,
			   0,
			   (unsigned) (screen->max_row - top + 1),
			   (unsigned) MaxCols(screen),
			   (unsigned) FontWidth(screen));
    }
    ClearBufRows(xw, 0, screen->max_row);
}

/*
 * If we've written protected text DEC-style, and are issuing a non-DEC
 * erase, temporarily reset the protected_mode flag so that the erase will
 * ignore the protected flags.
 */
void
do_erase_line(XtermWidget xw, int param, int mode)
{
    TScreen *screen = TScreenOf(xw);
    int saved_mode = screen->protected_mode;

    if (saved_mode == DEC_PROTECT
	&& saved_mode != mode) {
	screen->protected_mode = OFF_PROTECT;
    }

    switch (param) {
    case -1:			/* DEFAULT */
    case 0:
	ClearRight(xw, -1);
	break;
    case 1:
	ClearLeft(xw);
	break;
    case 2:
	ClearLine(xw);
	break;
    }
    screen->protected_mode = saved_mode;
}

/*
 * Just like 'do_erase_line()', except that this intercepts ED controls.  If we
 * clear the whole screen, we'll get the return-value from ClearInLine, and
 * find if there were any protected characters left.  If not, reset the
 * protected mode flag in the screen data (it's slower).
 */
void
do_erase_display(XtermWidget xw, int param, int mode)
{
    TScreen *screen = TScreenOf(xw);
    int saved_mode = screen->protected_mode;

    if (saved_mode == DEC_PROTECT
	&& saved_mode != mode)
	screen->protected_mode = OFF_PROTECT;

    switch (param) {
    case -1:			/* DEFAULT */
    case 0:
	if (screen->cur_row == 0
	    && screen->cur_col == 0) {
	    screen->protected_mode = saved_mode;
	    do_erase_display(xw, 2, mode);
	    saved_mode = screen->protected_mode;
	} else
	    ClearBelow(xw);
	break;

    case 1:
	if (screen->cur_row == screen->max_row
	    && screen->cur_col == screen->max_col) {
	    screen->protected_mode = saved_mode;
	    do_erase_display(xw, 2, mode);
	    saved_mode = screen->protected_mode;
	} else
	    ClearAbove(xw);
	break;

    case 2:
	/*
	 * We use 'ClearScreen()' throughout the remainder of the
	 * program for places where we don't care if the characters are
	 * protected or not.  So we modify the logic around this call
	 * on 'ClearScreen()' to handle protected characters.
	 */
	if (screen->protected_mode != OFF_PROTECT) {
	    int row;
	    int rc = 1;
	    unsigned len = (unsigned) MaxCols(screen);

	    assert(screen->max_col >= 0);
	    for (row = 0; row <= screen->max_row; row++)
		rc &= ClearInLine(xw, row, 0, len);
	    if (rc != 0)
		saved_mode = OFF_PROTECT;
	} else {
	    ClearScreen(xw);
	}
	break;

    case 3:
	/* xterm addition - erase saved lines. */
	screen->savedlines = 0;
	ScrollBarDrawThumb(screen->scrollWidget);
	break;
    }
    screen->protected_mode = saved_mode;
}

static Boolean
screen_has_data(XtermWidget xw)
{
    TScreen *screen = TScreenOf(xw);
    Boolean result = False;
    int row;

    for (row = 0; row < screen->max_row; ++row) {
	CLineData *ld;

	if ((ld = getLineData(screen, row)) != 0) {
	    int col;

	    for (col = 0; col < screen->max_col; ++col) {
		if (ld->attribs[col] & CHARDRAWN) {
		    result = True;
		    break;
		}
	    }
	}
	if (result)
	    break;
    }
    return result;
}

/*
 * Like tiXtraScroll, perform a scroll up of the page contents.  In this case,
 * it happens for the special case when erasing the whole display starting from
 * the upper-left corner of the screen.
 */
void
do_cd_xtra_scroll(XtermWidget xw)
{
    TScreen *screen = TScreenOf(xw);

    if (xw->misc.cdXtraScroll
	&& screen->cur_col == 0
	&& screen->cur_row == 0
	&& screen_has_data(xw)) {
	xtermScroll(xw, screen->max_row);
    }
}

/*
 * Scroll the page up (saving it).  This is called when doing terminal
 * initialization (ti) or exiting from that (te).
 */
void
do_ti_xtra_scroll(XtermWidget xw)
{
    TScreen *screen = TScreenOf(xw);

    if (xw->misc.tiXtraScroll) {
	xtermScroll(xw, screen->max_row);
    }
}

static void
CopyWait(XtermWidget xw)
{
#if OPT_DOUBLE_BUFFER
    (void) xw;
#else /* !OPT_DOUBLE_BUFFER */
    TScreen *screen = TScreenOf(xw);
    XEvent reply;
    XEvent *rep = &reply;

    for (;;) {
	XWindowEvent(screen->display, VWindow(screen), ExposureMask, &reply);
	switch (reply.type) {
	case Expose:
	    HandleExposure(xw, &reply);
	    break;
	case NoExpose:
	case GraphicsExpose:
	    if (screen->incopy <= 0) {
		screen->incopy = 1;
		if (screen->scrolls > 0)
		    screen->scrolls--;
	    }
	    if (reply.type == GraphicsExpose)
		HandleExposure(xw, &reply);

	    if ((reply.type == NoExpose) ||
		((XExposeEvent *) rep)->count == 0) {
		if (screen->incopy <= 0 && screen->scrolls > 0)
		    screen->scrolls--;
		if (screen->scrolls == 0) {
		    screen->incopy = 0;
		    return;
		}
		screen->incopy = -1;
	    }
	    break;
	}
    }
#endif /* OPT_DOUBLE_BUFFER */
}

/*
 * used by vertical_copy_area and and horizontal_copy_area
 */
static void
copy_area(XtermWidget xw,
	  int src_x,
	  int src_y,
	  unsigned width,
	  unsigned height,
	  int dest_x,
	  int dest_y)
{
    TScreen *screen = TScreenOf(xw);

    if (width != 0 && height != 0) {
	/* wait for previous CopyArea to complete unless
	   multiscroll is enabled and active */
	if (screen->incopy && screen->scrolls == 0)
	    CopyWait(xw);
	screen->incopy = -1;

	/* save for translating Expose events */
	screen->copy_src_x = src_x;
	screen->copy_src_y = src_y;
	screen->copy_width = width;
	screen->copy_height = height;
	screen->copy_dest_x = dest_x;
	screen->copy_dest_y = dest_y;

	XCopyArea(screen->display,
		  VDrawable(screen), VDrawable(screen),
		  NormalGC(xw, screen),
		  src_x, src_y, width, height, dest_x, dest_y);
    }
}

/*
 * use when inserting or deleting characters on the current line
 */
static void
horizontal_copy_area(XtermWidget xw,
		     int firstchar,	/* char pos on screen to start copying at */
		     int nchars,
		     int amount)	/* number of characters to move right */
{
    TScreen *screen = TScreenOf(xw);
    CLineData *ld;

    if ((ld = getLineData(screen, screen->cur_row)) != 0) {
	int src_x = LineCursorX(screen, ld, firstchar);
	int src_y = CursorY(screen, screen->cur_row);

	copy_area(xw, src_x, src_y,
		  (unsigned) (nchars * LineFontWidth(screen, ld)),
		  (unsigned) FontHeight(screen),
		  src_x + amount * LineFontWidth(screen, ld), src_y);
    }
}

/*
 * use when inserting or deleting lines from the screen
 */
static void
vertical_copy_area(XtermWidget xw,
		   int firstline,	/* line on screen to start copying at */
		   int nlines,
		   int amount,	/* number of lines to move up (neg=down) */
		   int left,
		   int right)
{
    TScreen *screen = TScreenOf(xw);

    TRACE(("vertical_copy_area - firstline=%d nlines=%d left=%d right=%d amount=%d\n",
	   firstline, nlines, left, right, amount));

    if (nlines > 0) {
	int src_x = CursorX(screen, left);
	int src_y = firstline * FontHeight(screen) + screen->border;
	unsigned int w = (unsigned) ((right + 1 - left) * FontWidth(screen));
	unsigned int h = (unsigned) (nlines * FontHeight(screen));
	int dst_x = src_x;
	int dst_y = src_y - amount * FontHeight(screen);

	copy_area(xw, src_x, src_y, w, h, dst_x, dst_y);

	if (screen->show_wrap_marks) {
	    int row;

	    for (row = firstline; row < firstline + nlines; ++row) {
		CLineData *ld;

		if ((ld = getLineData(screen, row)) != 0) {
		    ShowWrapMarks(xw, row, ld);
		}
	    }
	}
    }
}

/*
 * use when scrolling the entire screen
 */
void
scrolling_copy_area(XtermWidget xw,
		    int firstline,	/* line on screen to start copying at */
		    int nlines,
		    int amount)	/* number of lines to move up (neg=down) */
{

    if (nlines > 0) {
	vertical_copy_area(xw, firstline, nlines, amount, 0, TScreenOf(xw)->max_col);
    }
}

/*
 * Handler for Expose events on the VT widget.
 * Returns 1 iff the area where the cursor was got refreshed.
 */
int
HandleExposure(XtermWidget xw, XEvent *event)
{
    TScreen *screen = TScreenOf(xw);
    XExposeEvent *reply = (XExposeEvent *) event;

#ifndef NO_ACTIVE_ICON
    if (reply->window == screen->iconVwin.window) {
	WhichVWin(screen) = &screen->iconVwin;
	TRACE(("HandleExposure - icon\n"));
    } else {
	WhichVWin(screen) = &screen->fullVwin;
	TRACE(("HandleExposure - normal\n"));
    }
    TRACE((" event %d,%d %dx%d\n",
	   reply->y,
	   reply->x,
	   reply->height,
	   reply->width));
#endif /* NO_ACTIVE_ICON */

    /* if not doing CopyArea or if this is a GraphicsExpose, don't translate */
    if (!screen->incopy || event->type != Expose)
	return handle_translated_exposure(xw, reply->x, reply->y,
					  reply->width,
					  reply->height);
    else {
	/* compute intersection of area being copied with
	   area being exposed. */
	int both_x1 = Max(screen->copy_src_x, reply->x);
	int both_y1 = Max(screen->copy_src_y, reply->y);
	int both_x2 = Min(screen->copy_src_x + (int) screen->copy_width,
			  (reply->x + (int) reply->width));
	int both_y2 = Min(screen->copy_src_y + (int) screen->copy_height,
			  (reply->y + (int) reply->height));
	int value = 0;

	/* was anything copied affected? */
	if (both_x2 > both_x1 && both_y2 > both_y1) {
	    /* do the copied area */
	    value = handle_translated_exposure
		(xw, reply->x + screen->copy_dest_x - screen->copy_src_x,
		 reply->y + screen->copy_dest_y - screen->copy_src_y,
		 reply->width, reply->height);
	}
	/* was anything not copied affected? */
	if (reply->x < both_x1 || reply->y < both_y1
	    || reply->x + reply->width > both_x2
	    || reply->y + reply->height > both_y2)
	    value = handle_translated_exposure(xw, reply->x, reply->y,
					       reply->width, reply->height);

	return value;
    }
}

static void
set_background(XtermWidget xw, int color GCC_UNUSED)
{
    TScreen *screen = TScreenOf(xw);
    Pixel c = getXtermBackground(xw, xw->flags, color);

    TRACE(("set_background(%d) %#lx\n", color, c));
    XSetWindowBackground(screen->display, VShellWindow(xw), c);
    XSetWindowBackground(screen->display, VWindow(screen), c);
}

/*
 * Called by the ExposeHandler to do the actual repaint after the coordinates
 * have been translated to allow for any CopyArea in progress.
 * The rectangle passed in is pixel coordinates.
 */
static int
handle_translated_exposure(XtermWidget xw,
			   int rect_x,
			   int rect_y,
			   int rect_width,
			   int rect_height)
{
    TScreen *screen = TScreenOf(xw);
    int toprow, leftcol, nrows, ncols;
    int x0, x1;
    int y0, y1;
    int result = 0;

    TRACE(("handle_translated_exposure at %d,%d size %dx%d\n",
	   rect_y, rect_x, rect_height, rect_width));

    x0 = (rect_x - OriginX(screen));
    x1 = (x0 + rect_width);

    y0 = (rect_y - OriginY(screen));
    y1 = (y0 + rect_height);

    if ((x0 < 0 ||
	 y0 < 0 ||
	 x1 > Width(screen) ||
	 y1 > Height(screen))) {
	set_background(xw, -1);
#if OPT_DOUBLE_BUFFER
	XFillRectangle(screen->display, VDrawable(screen),
		       ReverseGC(xw, screen),
		       rect_x,
		       rect_y,
		       (unsigned) rect_width,
		       (unsigned) rect_height);
#else
	XClearArea(screen->display, VWindow(screen),
		   rect_x,
		   rect_y,
		   (unsigned) rect_width,
		   (unsigned) rect_height, False);
#endif
    }
    toprow = y0 / FontHeight(screen);
    if (toprow < 0)
	toprow = 0;

    leftcol = x0 / FontWidth(screen);
    if (leftcol < 0)
	leftcol = 0;

    nrows = (y1 - 1) / FontHeight(screen) - toprow + 1;
    ncols = (x1 - 1) / FontWidth(screen) - leftcol + 1;
    toprow -= screen->scrolls;
    if (toprow < 0) {
	nrows += toprow;
	toprow = 0;
    }
    if (toprow + nrows > MaxRows(screen))
	nrows = MaxRows(screen) - toprow;
    if (leftcol + ncols > MaxCols(screen))
	ncols = MaxCols(screen) - leftcol;

    if (nrows > 0 && ncols > 0) {
	ScrnRefresh(xw, toprow, leftcol, nrows, ncols, True);
	first_map_occurred();
	if (screen->cur_row >= toprow &&
	    screen->cur_row < toprow + nrows &&
	    screen->cur_col >= leftcol &&
	    screen->cur_col < leftcol + ncols) {
	    result = 1;
	}

    }
    TRACE(("...handle_translated_exposure %d\n", result));
    return (result);
}

/***====================================================================***/

void
GetColors(XtermWidget xw, ScrnColors * pColors)
{
    TScreen *screen = TScreenOf(xw);
    int n;

    pColors->which = 0;
    for (n = 0; n < NCOLORS; ++n) {
	SET_COLOR_VALUE(pColors, n, T_COLOR(screen, n));
    }
}

void
ChangeColors(XtermWidget xw, ScrnColors * pNew)
{
    Bool repaint = False;
    TScreen *screen = TScreenOf(xw);
    VTwin *win = WhichVWin(screen);

    TRACE(("ChangeColors\n"));

    if (COLOR_DEFINED(pNew, TEXT_CURSOR)) {
	T_COLOR(screen, TEXT_CURSOR) = COLOR_VALUE(pNew, TEXT_CURSOR);
	TRACE(("... TEXT_CURSOR: %#lx\n", T_COLOR(screen, TEXT_CURSOR)));
	/* no repaint needed */
    } else if ((T_COLOR(screen, TEXT_CURSOR) == T_COLOR(screen, TEXT_FG)) &&
	       (COLOR_DEFINED(pNew, TEXT_FG))) {
	if (T_COLOR(screen, TEXT_CURSOR) != COLOR_VALUE(pNew, TEXT_FG)) {
	    T_COLOR(screen, TEXT_CURSOR) = COLOR_VALUE(pNew, TEXT_FG);
	    TRACE(("... TEXT_CURSOR: %#lx\n", T_COLOR(screen, TEXT_CURSOR)));
	    if (screen->Vshow)
		repaint = True;
	}
    }

    if (COLOR_DEFINED(pNew, TEXT_FG)) {
	Pixel fg = COLOR_VALUE(pNew, TEXT_FG);
	T_COLOR(screen, TEXT_FG) = fg;
	TRACE(("... TEXT_FG: %#lx\n", T_COLOR(screen, TEXT_FG)));
	if (screen->Vshow) {
	    setCgsFore(xw, win, gcNorm, fg);
	    setCgsBack(xw, win, gcNormReverse, fg);
	    setCgsFore(xw, win, gcBold, fg);
	    setCgsBack(xw, win, gcBoldReverse, fg);
	    repaint = True;
	}
    }

    if (COLOR_DEFINED(pNew, TEXT_BG)) {
	Pixel bg = COLOR_VALUE(pNew, TEXT_BG);
	T_COLOR(screen, TEXT_BG) = bg;
	TRACE(("... TEXT_BG: %#lx\n", T_COLOR(screen, TEXT_BG)));
	if (screen->Vshow) {
	    setCgsBack(xw, win, gcNorm, bg);
	    setCgsFore(xw, win, gcNormReverse, bg);
	    setCgsBack(xw, win, gcBold, bg);
	    setCgsFore(xw, win, gcBoldReverse, bg);
	    set_background(xw, -1);
	    repaint = True;
	}
    }
#if OPT_HIGHLIGHT_COLOR
    if (COLOR_DEFINED(pNew, HIGHLIGHT_BG)) {
	if (T_COLOR(screen, HIGHLIGHT_BG) != COLOR_VALUE(pNew, HIGHLIGHT_BG)) {
	    T_COLOR(screen, HIGHLIGHT_BG) = COLOR_VALUE(pNew, HIGHLIGHT_BG);
	    TRACE(("... HIGHLIGHT_BG: %#lx\n", T_COLOR(screen, HIGHLIGHT_BG)));
	    if (screen->Vshow)
		repaint = True;
	}
    }
    if (COLOR_DEFINED(pNew, HIGHLIGHT_FG)) {
	if (T_COLOR(screen, HIGHLIGHT_FG) != COLOR_VALUE(pNew, HIGHLIGHT_FG)) {
	    T_COLOR(screen, HIGHLIGHT_FG) = COLOR_VALUE(pNew, HIGHLIGHT_FG);
	    TRACE(("... HIGHLIGHT_FG: %#lx\n", T_COLOR(screen, HIGHLIGHT_FG)));
	    if (screen->Vshow)
		repaint = True;
	}
    }
#endif

    if (COLOR_DEFINED(pNew, MOUSE_FG) || (COLOR_DEFINED(pNew, MOUSE_BG))) {
	if (COLOR_DEFINED(pNew, MOUSE_FG)) {
	    T_COLOR(screen, MOUSE_FG) = COLOR_VALUE(pNew, MOUSE_FG);
	    TRACE(("... MOUSE_FG: %#lx\n", T_COLOR(screen, MOUSE_FG)));
	}
	if (COLOR_DEFINED(pNew, MOUSE_BG)) {
	    T_COLOR(screen, MOUSE_BG) = COLOR_VALUE(pNew, MOUSE_BG);
	    TRACE(("... MOUSE_BG: %#lx\n", T_COLOR(screen, MOUSE_BG)));
	}

	if (screen->Vshow) {
	    recolor_cursor(screen,
			   screen->pointer_cursor,
			   T_COLOR(screen, MOUSE_FG),
			   T_COLOR(screen, MOUSE_BG));
	    XDefineCursor(screen->display, VWindow(screen),
			  screen->pointer_cursor);
	}
#if OPT_TEK4014
	if (TEK4014_SHOWN(xw)) {
	    TekScreen *tekscr = TekScreenOf(tekWidget);
	    Window tekwin = TWindow(tekscr);
	    if (tekwin) {
		recolor_cursor(screen,
			       tekscr->arrow,
			       T_COLOR(screen, MOUSE_FG),
			       T_COLOR(screen, MOUSE_BG));
		XDefineCursor(screen->display, tekwin, tekscr->arrow);
	    }
	}
#endif
	/* no repaint needed */
    }

    if (COLOR_DEFINED(pNew, TEXT_FG) ||
	COLOR_DEFINED(pNew, TEXT_BG) ||
	COLOR_DEFINED(pNew, TEXT_CURSOR)) {
	if (set_cursor_gcs(xw) && screen->Vshow) {
	    repaint = True;
	}
    }
#if OPT_TEK4014
    if (COLOR_DEFINED(pNew, TEK_FG) ||
	COLOR_DEFINED(pNew, TEK_BG)) {
	ChangeTekColors(tekWidget, screen, pNew);
	if (TEK4014_SHOWN(xw)) {
	    TekRepaint(tekWidget);
	}
    } else if (COLOR_DEFINED(pNew, TEK_CURSOR)) {
	ChangeTekColors(tekWidget, screen, pNew);
    }
#endif
    if (repaint)
	xtermRepaint(xw);
}

void
xtermClear(XtermWidget xw)
{
    TScreen *screen = TScreenOf(xw);

    TRACE(("xtermClear\n"));
#if OPT_DOUBLE_BUFFER
    XFillRectangle(screen->display, VDrawable(screen),
		   ReverseGC(xw, screen),
		   0, 0,
		   FullWidth(screen), FullHeight(screen));
#else
    XClearWindow(screen->display, VWindow(screen));
#endif
}

void
xtermRepaint(XtermWidget xw)
{
    TScreen *screen = TScreenOf(xw);

    TRACE(("xtermRepaint\n"));
    xtermClear(xw);
    ScrnRefresh(xw, 0, 0, MaxRows(screen), MaxCols(screen), True);
}

/***====================================================================***/

Boolean
isDefaultForeground(const char *name)
{
    return (Boolean) !x_strcasecmp(name, XtDefaultForeground);
}

Boolean
isDefaultBackground(const char *name)
{
    return (Boolean) !x_strcasecmp(name, XtDefaultBackground);
}

#if OPT_WIDE_CHARS
/*
 * Check for Unicode BIDI control characters, which may be miscategorized via
 * wcwidth() and iswprint() as zero-width printable characters.
 */
Boolean
isWideControl(unsigned ch)
{
    Boolean result;

    switch (ch) {
    case 0x200E:
    case 0x200F:
    case 0x202A:
    case 0x202B:
    case 0x202C:
    case 0x202D:
    case 0x202E:
	result = True;
	break;
    default:
	result = False;
	break;
    }
    return result;
}
#endif

/***====================================================================***/

typedef struct {
    Pixel fg;
    Pixel bg;
} ToSwap;

#if OPT_HIGHLIGHT_COLOR
#define hc_param ,Bool hilite_color
#define hc_value ,screen->hilite_color
#else
#define hc_param		/* nothing */
#define hc_value		/* nothing */
#endif

/*
 * Use this to swap the foreground/background color values in the resource
 * data, and to build up a list of the pairs which must be swapped in the
 * GC cache.
 */
static void
swapLocally(ToSwap * list, int *count, ColorRes * fg, ColorRes * bg hc_param)
{
    ColorRes tmp;
    Boolean found = False;

#if OPT_COLOR_RES
    Pixel fg_color = fg->value;
    Pixel bg_color = bg->value;
#else
    Pixel fg_color = *fg;
    Pixel bg_color = *bg;
#endif

#if OPT_HIGHLIGHT_COLOR
    if ((fg_color != bg_color) || !hilite_color)
#endif
    {
	int n;

	EXCHANGE(*fg, *bg, tmp);
	for (n = 0; n < *count; ++n) {
	    if ((list[n].fg == fg_color && list[n].bg == bg_color)
		|| (list[n].fg == bg_color && list[n].bg == fg_color)) {
		found = True;
		break;
	    }
	}
	if (!found) {
	    list[*count].fg = fg_color;
	    list[*count].bg = bg_color;
	    *count = *count + 1;
	    TRACE(("swapLocally fg %#lx, bg %#lx ->%d\n",
		   fg_color, bg_color, *count));
	}
    }
}

static void
reallySwapColors(XtermWidget xw, ToSwap * list, int count)
{
    int j, k;

    TRACE(("reallySwapColors\n"));
    for (j = 0; j < count; ++j) {
	for_each_text_gc(k) {
	    redoCgs(xw, list[j].fg, list[j].bg, (CgsEnum) k);
	}
    }
}

static void
swapVTwinGCs(XtermWidget xw, VTwin *win)
{
    swapCgs(xw, win, gcNorm, gcNormReverse);
    swapCgs(xw, win, gcBold, gcBoldReverse);
}

void
ReverseVideo(XtermWidget xw)
{
    TScreen *screen = TScreenOf(xw);
    ToSwap listToSwap[5];
    int numToSwap = 0;

    TRACE(("ReverseVideo\n"));

    /*
     * Swap SGR foreground and background colors.  By convention, these are
     * the colors assigned to "black" (SGR #0) and "white" (SGR #7).  Also,
     * SGR #8 and SGR #15 are the bold (or bright) versions of SGR #0 and
     * #7, respectively.
     *
     * We don't swap colors that happen to match the screen's foreground
     * and background because that tends to produce bizarre effects.
     */
#define swapAnyColor(name,a,b) swapLocally(listToSwap, &numToSwap, &(screen->name[a]), &(screen->name[b]) hc_value)
#define swapAColor(a,b) swapAnyColor(Acolors, a, b)
    if_OPT_ISO_COLORS(screen, {
	swapAColor(0, 7);
	swapAColor(8, 15);
    });

    if (T_COLOR(screen, TEXT_CURSOR) == T_COLOR(screen, TEXT_FG))
	T_COLOR(screen, TEXT_CURSOR) = T_COLOR(screen, TEXT_BG);

#define swapTColor(a,b) swapAnyColor(Tcolors, a, b)
    swapTColor(TEXT_FG, TEXT_BG);
    swapTColor(MOUSE_FG, MOUSE_BG);

    reallySwapColors(xw, listToSwap, numToSwap);

    swapVTwinGCs(xw, &(screen->fullVwin));
#ifndef NO_ACTIVE_ICON
    swapVTwinGCs(xw, &(screen->iconVwin));
#endif /* NO_ACTIVE_ICON */

    xw->misc.re_verse = (Boolean) !xw->misc.re_verse;

    if (XtIsRealized((Widget) xw)) {
	xtermDisplayCursor(xw);
    }
#if OPT_TEK4014
    if (TEK4014_SHOWN(xw)) {
	TekScreen *tekscr = TekScreenOf(tekWidget);
	Window tekwin = TWindow(tekscr);
	recolor_cursor(screen,
		       tekscr->arrow,
		       T_COLOR(screen, MOUSE_FG),
		       T_COLOR(screen, MOUSE_BG));
	XDefineCursor(screen->display, tekwin, tekscr->arrow);
    }
#endif

    if (screen->scrollWidget)
	ScrollBarReverseVideo(screen->scrollWidget);

    if (XtIsRealized((Widget) xw)) {
	set_background(xw, -1);
    }
#if OPT_TEK4014
    TekReverseVideo(tekWidget);
#endif
    if (XtIsRealized((Widget) xw)) {
	xtermRepaint(xw);
    }
#if OPT_TEK4014
    if (TEK4014_SHOWN(xw)) {
	TekRepaint(tekWidget);
    }
#endif
    ReverseOldColors(xw);
    set_cursor_gcs(xw);
    update_reversevideo();
    TRACE(("...ReverseVideo\n"));
}

void
recolor_cursor(TScreen *screen,
	       Cursor cursor,	/* X cursor ID to set */
	       unsigned long fg,	/* pixel indexes to look up */
	       unsigned long bg)	/* pixel indexes to look up */
{
    Display *dpy = screen->display;
    XColor colordefs[2];	/* 0 is foreground, 1 is background */

    colordefs[0].pixel = fg;
    colordefs[1].pixel = bg;
    XQueryColors(dpy, DefaultColormap(dpy, DefaultScreen(dpy)),
		 colordefs, 2);
    XRecolorCursor(dpy, cursor, colordefs, colordefs + 1);
    cleanup_colored_cursor();
    return;
}

#if OPT_RENDERFONT
#define XFT_CACHE_LIMIT ((unsigned)(~0) >> 1)
#define XFT_CACHE_SIZE  16
typedef struct {
    XftColor color;
    unsigned use;
} XftColorCache;

static int
compare_xft_color_cache(const void *a, const void *b)
{
    return (int) (((const XftColorCache *) a)->use -
		  ((const XftColorCache *) b)->use);
}

static XftColor *
getXftColor(XtermWidget xw, Pixel pixel)
{
    static XftColorCache cache[XFT_CACHE_SIZE + 1];
    static unsigned latest_use;
    int i;
    int oldest;
    unsigned oldest_use;
    XColor color;
    Boolean found = False;

    oldest_use = XFT_CACHE_LIMIT;
    oldest = 0;
    if (latest_use == XFT_CACHE_LIMIT) {
	latest_use = 0;
	qsort(cache, (size_t) XFT_CACHE_SIZE, sizeof(XftColorCache), compare_xft_color_cache);
	for (i = 0; i < XFT_CACHE_SIZE; i++) {
	    if (cache[i].use) {
		cache[i].use = ++latest_use;
	    }
	}
    }
    for (i = 0; i < XFT_CACHE_SIZE; i++) {
	if (cache[i].use) {
	    if (cache[i].color.pixel == pixel) {
		found = True;
		break;
	    }
	}
	if (cache[i].use < oldest_use) {
	    oldest_use = cache[i].use;
	    oldest = i;
	}
    }
    if (!found) {
	i = oldest;
	color.pixel = pixel;
	XQueryColor(TScreenOf(xw)->display, xw->core.colormap, &color);
	cache[i].color.color.red = color.red;
	cache[i].color.color.green = color.green;
	cache[i].color.color.blue = color.blue;
	cache[i].color.color.alpha = 0xffff;
	cache[i].color.pixel = pixel;
    }
    cache[i].use = ++latest_use;
    return &cache[i].color;
}

/*
 * The cell-width is related to, but not the same as the wide-character width.
 * We will only get useful values from wcwidth() for codes above 255.
 * Otherwise, interpret according to internal data.
 */
#if OPT_RENDERWIDE

#if OPT_C1_PRINT
#define XtermCellWidth(xw, ch) \
	(((ch) == 0 || (ch) == 127) \
	  ? 0 \
	  : (((ch) < 256) \
	      ? (((ch) >= 128 && (ch) < 160) \
	          ? (TScreenOf(xw)->c1_printable ? 1 : 0) \
	          : 1) \
	      : my_wcwidth(ch)))
#else
#define XtermCellWidth(xw, ch) \
	(((ch) == 0 || (ch) == 127) \
	  ? 0 \
	  : (((ch) < 256) \
	      ? 1 \
	      : my_wcwidth(ch)))
#endif

#endif /* OPT_RENDERWIDE */

#define XFT_FONT(name) screen->name.font

#if OPT_ISO_COLORS
#define UseBoldFont(screen) (!(screen)->colorBDMode || ((screen)->veryBoldColors & BOLD))
#else
#define UseBoldFont(screen) 1
#endif

#if OPT_RENDERWIDE
static XftFont *
getWideXftFont(XtermWidget xw,
	       unsigned attr_flags)
{
    TScreen *screen = TScreenOf(xw);
    int fontnum = screen->menu_font_number;
    XftFont *wfont;

#if OPT_WIDE_ATTRS
    if ((attr_flags & ATR_ITALIC)
#if OPT_ISO_COLORS
	&& !screen->colorITMode
#endif
	&& XFT_FONT(renderWideItal[fontnum])) {
	wfont = XFT_FONT(renderWideItal[fontnum]);
    } else
#endif
#if OPT_ISO_COLORS
	if ((attr_flags & UNDERLINE)
	    && !screen->colorULMode
	    && screen->italicULMode
	    && XFT_FONT(renderWideItal[fontnum])) {
	wfont = XFT_FONT(renderWideItal[fontnum]);
    } else
#endif
	if ((attr_flags & BOLDATTR(screen))
	    && UseBoldFont(screen)
	    && XFT_FONT(renderWideBold[fontnum])) {
	wfont = XFT_FONT(renderWideBold[fontnum]);
    } else {
	wfont = XFT_FONT(renderWideNorm[fontnum]);
    }
    return wfont;
}
#endif /* OPT_RENDERWIDE */

static XftFont *
getNormXftFont(XtermWidget xw,
	       unsigned attr_flags,
	       Bool *did_ul)
{
    TScreen *screen = TScreenOf(xw);
    int fontnum = screen->menu_font_number;
    XftFont *font;

#if OPT_WIDE_ATTRS
    if ((attr_flags & ATR_ITALIC)
#if OPT_ISO_COLORS
	&& !screen->colorITMode
#endif
	&& XFT_FONT(renderFontItal[fontnum])) {
	font = XFT_FONT(renderFontItal[fontnum]);
    } else
#endif
#if OPT_ISO_COLORS
	if ((attr_flags & UNDERLINE)
	    && !screen->colorULMode
	    && screen->italicULMode
	    && XFT_FONT(renderFontItal[fontnum])) {
	font = XFT_FONT(renderFontItal[fontnum]);
	*did_ul = True;
    } else
#endif
	if ((attr_flags & BOLDATTR(screen))
	    && UseBoldFont(screen)
	    && XFT_FONT(renderFontBold[fontnum])) {
	font = XFT_FONT(renderFontBold[fontnum]);
    } else {
	font = XFT_FONT(renderFontNorm[fontnum]);
    }
    return font;
}

#if OPT_RENDERWIDE
#define pickXftFont(width, nf, wf) ((width == 2 && wf != 0) ? wf : nf)
#else
#define pickXftFont(width, nf, wf) (nf)
#endif

/*
 * fontconfig/Xft combination prior to 2.2 has a problem with
 * CJK truetype 'double-width' (bi-width/monospace) fonts leading
 * to the 's p a c e d o u t' rendering. Consequently, we can't
 * rely on XftDrawString8/16 when one of those fonts is used.
 * Instead, we need to roll out our own using XftDrawCharSpec.
 * A patch in the same spirit (but in a rather different form)
 * was applied to gnome vte and gtk2 port of vim.
 * See http://bugzilla.mozilla.org/show_bug.cgi?id=196312
 */
static int
xtermXftDrawString(XtermWidget xw,
		   unsigned attr_flags GCC_UNUSED,
		   XftColor *color,
		   XftFont *font,
		   int x,
		   int y,
		   const IChar *text,
		   Cardinal len,
		   Bool really)
{
    TScreen *screen = TScreenOf(xw);
    int ncells = 0;

    if (len != 0) {
#if OPT_RENDERWIDE
	XftCharSpec *sbuf;
	XftFont *wfont = getWideXftFont(xw, attr_flags);
	Cardinal src, dst;
	XftFont *lastFont = 0;
	XftFont *currFont = 0;
	Cardinal start = 0;
	int charWidth;
	int fwidth = FontWidth(screen);

	BumpTypedBuffer(XftCharSpec, len);
	sbuf = BfBuf(XftCharSpec);

	for (src = dst = 0; src < len; src++) {
	    FcChar32 wc = *text++;

	    charWidth = XtermCellWidth(xw, (wchar_t) wc);
	    if (charWidth < 0)
		continue;

	    sbuf[dst].ucs4 = wc;
	    sbuf[dst].x = (short) (x + fwidth * ncells);
	    sbuf[dst].y = (short) (y);

	    currFont = pickXftFont(charWidth, font, wfont);
	    ncells += charWidth;

	    if (lastFont != currFont) {
		if ((lastFont != 0) && really) {
		    XftDrawCharSpec(screen->renderDraw,
				    color,
				    lastFont,
				    sbuf + start,
				    (int) (dst - start));
		}
		start = dst;
		lastFont = currFont;
	    }
	    ++dst;
	}
	if ((dst != start) && really) {
	    XftDrawCharSpec(screen->renderDraw,
			    color,
			    lastFont,
			    sbuf + start,
			    (int) (dst - start));
	}
#else /* !OPT_RENDERWIDE */
	if (really) {
	    XftChar8 *buffer;
	    int dst;

	    BumpTypedBuffer(XftChar8, len);
	    buffer = BfBuf(XftChar8);

	    for (dst = 0; dst < (int) len; ++dst)
		buffer[dst] = CharOf(text[dst]);

	    XftDrawString8(screen->renderDraw,
			   color,
			   font,
			   x, y, buffer, (int) len);
	}
	ncells = (int) len;
#endif
    }
    return ncells;
}
#define xtermXftWidth(xw, attr_flags, color, font, x, y, chars, len) \
   xtermXftDrawString(xw, attr_flags, color, font, x, y, chars, len, False)
#endif /* OPT_RENDERFONT */

#if OPT_WIDE_CHARS
/*
 * Map characters commonly "fixed" by groff back to their ASCII equivalents.
 * Also map other useful equivalents.
 */
unsigned
AsciiEquivs(unsigned ch)
{
    switch (ch) {
    case 0x2010:		/* groff "-" */
    case 0x2011:
    case 0x2012:
    case 0x2013:
    case 0x2014:
    case 0x2015:
    case 0x2212:		/* groff "\-" */
	ch = '-';
	break;
    case 0x2018:		/* groff "`" */
	ch = '`';
	break;
    case 0x2019:		/* groff ' */
	ch = '\'';
	break;
    case 0x201C:		/* groff lq */
    case 0x201D:		/* groff rq */
	ch = '"';
	break;
    case 0x2329:		/* groff ".URL" */
	ch = '<';
	break;
    case 0x232a:		/* groff ".URL" */
	ch = '>';
	break;
    default:
	if (ch >= 0xff01 && ch <= 0xff5e) {
	    /* "Fullwidth" codes (actually double-width) */
	    ch -= 0xff00;
	    ch += ANSI_SPA;
	    break;
	}
    }
    return ch;
}

/*
 * Actually this should be called "groff_workaround()" - for the places where
 * groff stomps on compatibility.  Still, if enough people get used to it,
 * this might someday become a quasi-standard.
 */
#if OPT_BOX_CHARS
static int
ucs_workaround(XtermWidget xw,
	       unsigned ch,
	       unsigned attr_flags,
	       unsigned draw_flags,
	       GC gc,
	       int x,
	       int y,
	       int chrset,
	       int on_wide)
{
    TScreen *screen = TScreenOf(xw);
    int fixed = False;

    if (screen->wide_chars && screen->utf8_mode && ch > 256) {
	IChar eqv = (IChar) AsciiEquivs(ch);

	if (eqv != (IChar) ch) {
	    int width = my_wcwidth((wchar_t) ch);

	    do {
		drawXtermText(xw,
			      attr_flags,
			      draw_flags,
			      gc,
			      x,
			      y,
			      chrset,
			      &eqv,
			      1,
			      on_wide);
		x += FontWidth(screen);
		eqv = '?';
	    } while (width-- > 1);

	    fixed = True;
	} else if (ch == HIDDEN_CHAR) {
	    fixed = True;
	}
    }
    return fixed;
}
#endif /* OPT_BOX_CHARS */
#endif /* OPT_WIDE_CHARS */

/*
 * Use this when the characters will not fill the cell area properly.  Fill the
 * area where we'll write the characters, otherwise we'll get gaps between
 * them, e.g., in the original background color.
 *
 * The cursor is a special case, because the XFillRectangle call only uses the
 * foreground, while we've set the cursor color in the background.  So we need
 * a special GC for that.
 */
static void
xtermFillCells(XtermWidget xw,
	       unsigned draw_flags,
	       GC gc,
	       int x,
	       int y,
	       Cardinal len)
{
    TScreen *screen = TScreenOf(xw);
    VTwin *currentWin = WhichVWin(screen);

    if (!(draw_flags & NOBACKGROUND)) {
	CgsEnum srcId = getCgsId(xw, currentWin, gc);
	CgsEnum dstId = gcMAX;
	Pixel fg = getCgsFore(xw, currentWin, gc);
	Pixel bg = getCgsBack(xw, currentWin, gc);

	switch (srcId) {
	case gcVTcursNormal:
	case gcVTcursReverse:
	    dstId = gcVTcursOutline;
	    break;
	case gcVTcursFilled:
	case gcVTcursOutline:
	    /* FIXME */
	    break;
	case gcNorm:
	    dstId = gcNormReverse;
	    break;
	case gcNormReverse:
	    dstId = gcNorm;
	    break;
	case gcBold:
	    dstId = gcBoldReverse;
	    break;
	case gcBoldReverse:
	    dstId = gcBold;
	    break;
#if OPT_BOX_CHARS
	case gcLine:
	case gcDots:
	    /* FIXME */
	    break;
#endif
#if OPT_DEC_CHRSET
	case gcCNorm:
	case gcCBold:
	    /* FIXME */
	    break;
#endif
#if OPT_WIDE_CHARS
	case gcWide:
	    dstId = gcWideReverse;
	    break;
	case gcWBold:
	    dstId = gcBoldReverse;
	    break;
	case gcWideReverse:
	case gcWBoldReverse:
	    /* FIXME */
	    break;
#endif
#if OPT_TEK4014
	case gcTKcurs:
	    /* FIXME */
	    break;
#endif
	case gcMAX:
	    break;
	}

	if (dstId != gcMAX) {
	    setCgsFore(xw, currentWin, dstId, bg);
	    setCgsBack(xw, currentWin, dstId, fg);

	    XFillRectangle(screen->display, VDrawable(screen),
			   getCgsGC(xw, currentWin, dstId),
			   x, y,
			   len * (Cardinal) FontWidth(screen),
			   (unsigned) FontHeight(screen));
	}
    }
}

#if OPT_TRACE
static void
xtermSetClipRectangles(Display *dpy,
		       GC gc,
		       int x,
		       int y,
		       XRectangle * rp,
		       Cardinal nr,
		       int order)
{
#if 0
    TScreen *screen = TScreenOf(term);
    Drawable draw = VDrawable(screen);

    XSetClipMask(dpy, gc, None);
    XDrawRectangle(screen->display, draw, gc,
		   x + rp->x - 1,
		   y + rp->y - 1,
		   rp->width,
		   rp->height);
#endif

    XSetClipRectangles(dpy, gc,
		       x, y, rp, (int) nr, order);
    TRACE(("clipping @@(%3d,%3d) (%3d,%3d)..(%3d,%3d)\n",
	   y, x,
	   rp->y, rp->x, rp->height, rp->width));
}

#else
#define xtermSetClipRectangles(dpy, gc, x, y, rp, nr, order) \
	    XSetClipRectangles(dpy, gc, x, y, rp, (int) nr, order)
#endif

#if OPT_CLIP_BOLD
/*
 * This special case is a couple of percent slower, but avoids a lot of pixel
 * trash in rxcurses' hanoi.cmd demo (e.g., 10x20 font).
 */
#define beginClipping(screen,gc,pwidth,plength) \
	    if (screen->use_clipping && (pwidth > 2)) { \
		XRectangle clip; \
		int clip_x = x; \
		int clip_y = y - FontHeight(screen) + FontDescent(screen); \
		clip.x = 0; \
		clip.y = 0; \
		clip.height = (unsigned short) FontHeight(screen); \
		clip.width = (unsigned short) (pwidth * plength); \
		xtermSetClipRectangles(screen->display, gc, \
				       clip_x, clip_y, \
				       &clip, 1, Unsorted); \
	    }
#define endClipping(screen,gc) \
	    XSetClipMask(screen->display, gc, None)
#else
#define beginClipping(screen,gc,pwidth,plength)		/* nothing */
#define endClipping(screen,gc)	/* nothing */
#endif /* OPT_CLIP_BOLD */

#if OPT_CLIP_BOLD && OPT_RENDERFONT && defined(HAVE_XFTDRAWSETCLIP) && defined(HAVE_XFTDRAWSETCLIPRECTANGLES)
#define beginXftClipping(screen,px,py,plength) \
	    if (screen->use_clipping && (FontWidth(screen) > 2)) { \
		XRectangle clip; \
		double adds = (screen->scale_height - 1.0) * FontHeight(screen); \
		int height = dimRound(adds + FontHeight(screen)); \
		int descnt = dimRound(adds / 2.0) + FontDescent(screen); \
		int clip_x = px; \
		int clip_y = py - height + descnt; \
		clip.x = 0; \
		clip.y = 0; \
		clip.height = (unsigned short) height; \
		clip.width = (unsigned short) (FontWidth(screen) * plength); \
		XftDrawSetClipRectangles (screen->renderDraw, \
					  clip_x, clip_y, \
					  &clip, 1); \
	    }
#define endXftClipping(screen) \
	    XftDrawSetClip (screen->renderDraw, 0)
#else
#define beginXftClipping(screen,px,py,plength)	/* nothing */
#define endXftClipping(screen)	/* nothing */
#endif /* OPT_CLIP_BOLD */

#if OPT_RENDERFONT
static int
drawClippedXftString(XtermWidget xw,
		     unsigned attr_flags,
		     XftFont *font,
		     XftColor *fg_color,
		     int x,
		     int y,
		     const IChar *text,
		     Cardinal len)
{
    int ncells = xtermXftWidth(xw, attr_flags,
			       fg_color,
			       font, x, y,
			       text,
			       len);
    TScreen *screen = TScreenOf(xw);

    beginXftClipping(screen, x, y, ncells);
    xtermXftDrawString(xw, attr_flags,
		       fg_color,
		       font, x, y,
		       text,
		       len,
		       True);
    endXftClipping(screen);
    return ncells;
}
#endif

#ifndef NO_ACTIVE_ICON
#define WhichVFontData(screen,name) \
		(IsIcon(screen) ? &((screen)->fnt_icon) \
				: &((screen)->name))
#else
#define WhichVFontData(screen,name) \
				(&((screen)->name))
#endif

static int
drawUnderline(XtermWidget xw,
	      GC gc,
	      unsigned attr_flags,
	      unsigned underline_len,
	      int font_width,
	      int x,
	      int y,
	      Bool did_ul)
{
    TScreen *screen = TScreenOf(xw);

    if (screen->underline && !did_ul) {
	int repeat = 0;
	int descent = FontDescent(screen);
	int length = x + (int) underline_len * font_width - 1;

#if OPT_WIDE_ATTRS
	if ((attr_flags & ATR_STRIKEOUT)) {
	    int where = y - ((3 * FontAscent(screen)) / 8);
	    XDrawLine(screen->display, VDrawable(screen), gc,
		      x, where,
		      length,
		      where);
	}
	if ((attr_flags & ATR_DBL_UNDER)) {
	    repeat = 2;
	} else
#endif
	if ((attr_flags & UNDERLINE)) {
	    repeat = 1;
	}
	while (repeat-- > 0) {
	    if (descent-- > 1)
		y++;
	    XDrawLine(screen->display, VDrawable(screen), gc,
		      x, y,
		      length,
		      y);
	}
    }
    return y;
}

#if OPT_WIDE_ATTRS
/*
 * As a special case, we are currently allowing italic fonts to be inexact
 * matches for the normal font's size.  That introduces a problem:  either the
 * ascent or descent may be shorter, leaving a gap that has to be filled in. 
 * Or they may be larger, requiring clipping.  Check for both cases.
 */
static int
fixupItalics(XtermWidget xw,
	     unsigned draw_flags,
	     GC gc,
	     XTermFonts * curFont,
	     int y, int x,
	     int font_width,
	     Cardinal len)
{
    TScreen *screen = TScreenOf(xw);
    VTwin *cgsWin = WhichVWin(screen);
    XFontStruct *realFp = curFont->fs;
    XFontStruct *thisFp = getCgsFont(xw, cgsWin, gc)->fs;
    int need_clipping = 0;
    int need_filling = 0;

    if (thisFp->ascent > realFp->ascent)
	need_clipping = 1;
    else if (thisFp->ascent < realFp->ascent)
	need_filling = 1;

    if (thisFp->descent > realFp->descent)
	need_clipping = 1;
    else if (thisFp->descent < realFp->descent)
	need_filling = 1;

    if (need_clipping) {
	beginClipping(screen, gc, font_width, (int) len);
    }
    if (need_filling) {
	xtermFillCells(xw,
		       draw_flags,
		       gc,
		       x,
		       y - realFp->ascent,
		       len);
    }
    return need_clipping;
}
#endif

#define SetMissing() \
	TRACE(("%s@@%d: missing %d\n", __FILE__, __LINE__, missing)); \
	missing = 1

/*
 * Draws text with the specified combination of bold/underline.  The return
 * value is the updated x position.
 */
int
drawXtermText(XtermWidget xw,
	      unsigned attr_flags,
	      unsigned draw_flags,
	      GC gc,
	      int start_x,
	      int start_y,
	      int chrset,
	      const IChar *text,
	      Cardinal len,
	      int on_wide)
{
    int x = start_x, y = start_y;
    TScreen *screen = TScreenOf(xw);
    Cardinal real_length = len;
    Cardinal underline_len = 0;
    /* Intended width of the font to draw (as opposed to the actual width of
       the X font, and the width of the default font) */
    int font_width = ((draw_flags & DOUBLEWFONT) ? 2 : 1) * screen->fnt_wide;
    Bool did_ul = False;
    XTermFonts *curFont;
#if OPT_WIDE_ATTRS || OPT_WIDE_CHARS
    int need_clipping = 0;
#endif

#if OPT_WIDE_CHARS
    if (text == 0)
	return 0;
#endif
#if OPT_DEC_CHRSET
    if (CSET_DOUBLE(chrset)) {
	/* We could try drawing double-size characters in the icon, but
	 * given that the icon font is usually nil or nil2, there
	 * doesn't seem to be much point.
	 */
	int inx = 0;
	GC gc2 = ((!IsIcon(screen) && screen->font_doublesize)
		  ? xterm_DoubleGC(xw, (unsigned) chrset,
				   attr_flags,
				   draw_flags,
				   gc, &inx)
		  : 0);

	TRACE(("DRAWTEXT%c[%4d,%4d] (%d)%3d:%s\n",
	       screen->cursor_state == OFF ? ' ' : '*',
	       y, x, chrset, len,
	       visibleIChars(text, len)));

	if (gc2 != 0) {		/* draw actual double-sized characters */
	    XFontStruct *fs = screen->double_fonts[inx].fs;

#if OPT_RENDERFONT
	    if (!UsingRenderFont(xw))
#endif
	    {
		XRectangle rect, *rp = &rect;
		Cardinal nr = 1;

		font_width *= 2;
		draw_flags |= DOUBLEWFONT;

		rect.x = 0;
		rect.y = 0;
		rect.width = (unsigned short) ((int) len * font_width);
		rect.height = (unsigned short) (FontHeight(screen));

		TRACE(("drawing %s\n", visibleDblChrset((unsigned) chrset)));
		switch (chrset) {
		case CSET_DHL_TOP:
		    rect.y = (short) -(fs->ascent / 2);
		    y -= rect.y;
		    draw_flags |= DOUBLEHFONT;
		    break;
		case CSET_DHL_BOT:
		    rect.y = (short) (rect.height - (fs->ascent / 2));
		    y -= rect.y;
		    draw_flags |= DOUBLEHFONT;
		    break;
		default:
		    nr = 0;
		    break;
		}

		if (nr) {
		    xtermSetClipRectangles(screen->display, gc2,
					   x, y, rp, nr, YXBanded);
		    xtermFillCells(xw, draw_flags, gc, x, y + rect.y, len * 2);
		} else {
		    XSetClipMask(screen->display, gc2, None);
		}
	    }

	    /* Call ourselves recursively with the new gc */

	    /*
	     * If we're trying to use proportional font, or if the
	     * font server didn't give us what we asked for wrt
	     * width, position each character independently.
	     */
	    if (screen->fnt_prop
		|| (fs->min_bounds.width != fs->max_bounds.width)
		|| (fs->min_bounds.width != 2 * FontWidth(screen))) {
		/* It is hard to fall-through to the main
		   branch: in a lot of places the check
		   for the cached font info is for
		   normal/bold fonts only. */
		while (len--) {
		    x = drawXtermText(xw,
				      attr_flags,
				      draw_flags,
				      gc2,
				      x, y, 0,
				      text++,
				      1, on_wide);
		    x += FontWidth(screen);
		}
	    } else {
		x = drawXtermText(xw,
				  attr_flags,
				  draw_flags,
				  gc2,
				  x, y, 0,
				  text,
				  len, on_wide);
		x += (int) len *FontWidth(screen);
	    }

	    TRACE(("drawtext [%4d,%4d]\n", y, x));
	} else {		/* simulate double-sized characters */
	    unsigned need = 2 * len;
	    IChar *temp = TypeMallocN(IChar, need);

	    if (temp != 0) {
		unsigned n = 0;

		while (len--) {
		    temp[n++] = *text++;
		    temp[n++] = ' ';
		}
		x = drawXtermText(xw,
				  attr_flags,
				  draw_flags,
				  gc,
				  x, y,
				  0,
				  temp,
				  n,
				  on_wide);
		free(temp);
	    }
	}
	return x;
    }
#endif
#if OPT_RENDERFONT
    if (UsingRenderFont(xw)) {
	VTwin *currentWin = WhichVWin(screen);
	Display *dpy = screen->display;
	XftFont *font, *font0;
	XGCValues values;
#if OPT_RENDERWIDE
	XftFont *wfont, *wfont0;
#endif
	if (!screen->renderDraw) {
	    int scr;
	    Drawable draw = VDrawable(screen);
	    Visual *visual;

	    scr = DefaultScreen(dpy);
	    visual = DefaultVisual(dpy, scr);
	    screen->renderDraw = XftDrawCreate(dpy, draw, visual,
					       DefaultColormap(dpy, scr));
	}
#define IS_BOLD  (attr_flags & BOLDATTR(screen))
#define NOT_BOLD (attr_flags & ~BOLDATTR(screen))
	font = getNormXftFont(xw, attr_flags, &did_ul);
	font0 = IS_BOLD ? getNormXftFont(xw, NOT_BOLD, &did_ul) : font;
#if OPT_RENDERWIDE
	wfont = getWideXftFont(xw, attr_flags);
	wfont0 = IS_BOLD ? getWideXftFont(xw, NOT_BOLD) : wfont;
#endif
	values.foreground = getCgsFore(xw, currentWin, gc);
	values.background = getCgsBack(xw, currentWin, gc);

	if (!(draw_flags & NOBACKGROUND)) {
	    XftColor *bg_color = getXftColor(xw, values.background);
	    int ncells = xtermXftWidth(xw, attr_flags,
				       bg_color,
				       font, x, y,
				       text,
				       len);
	    XftDrawRect(screen->renderDraw,
			bg_color,
			x, y,
			(unsigned) (ncells * FontWidth(screen)),
			(unsigned) FontHeight(screen));
	}

	y += font->ascent;
#if OPT_BOX_CHARS
	{
	    /* adding code to substitute simulated line-drawing characters */
	    int last, first = 0;
	    Dimension old_wide, old_high = 0;
	    int curX = x;

	    for (last = 0; last < (int) len; last++) {
		Boolean replace = False;
		Boolean missing = False;
		unsigned ch = (unsigned) text[last];
		int filler = 0;
#if OPT_WIDE_CHARS
		int needed = my_wcwidth((wchar_t) ch);
		XftFont *currFont = pickXftFont(needed, font, wfont);

		if (xtermIsDecGraphic(ch)) {
		    /*
		     * Xft generally does not have the line-drawing characters
		     * in cells 1-31.  Assume this (we cannot inspect the
		     * picture easily...), and attempt to fill in from real
		     * line-drawing character in the font at the Unicode
		     * position.  Failing that, use our own box-characters.
		     */
		    if (screen->force_box_chars
			|| xtermXftMissing(xw, currFont, dec2ucs(ch))) {
			SetMissing();
		    } else {
			ch = dec2ucs(ch);
			replace = True;
		    }
		} else if (ch >= 256) {
		    /*
		     * If we're reading UTF-8 from the client, we may have a
		     * line-drawing character.  Translate it back to our
		     * box-code if Xft tells us that the glyph is missing.
		     */
		    if_OPT_WIDE_CHARS(screen, {
			unsigned part = ucs2dec(ch);
			if (xtermIsDecGraphic(part)) {
			    if (screen->force_box_chars
				|| xtermXftMissing(xw, currFont, ch)) {
				ch = part;
				SetMissing();
			    }
			} else if (xtermXftMissing(xw, currFont, ch)) {
			    XftFont *test = pickXftFont(needed, font0, wfont0);
			    if (!xtermXftMissing(xw, test, ch)) {
				currFont = test;
				replace = True;
				filler = needed - 1;
			    } else if ((part = AsciiEquivs(ch)) != ch) {
				filler = needed - 1;
				ch = part;
				replace = True;
			    } else if (ch != HIDDEN_CHAR) {
				SetMissing();
			    }
			}
		    });
		}
#else
		XftFont *currFont = font;
		if (xtermIsDecGraphic(ch)) {
		    /*
		     * Xft generally does not have the line-drawing characters
		     * in cells 1-31.  Check for this, and attempt to fill in
		     * from real line-drawing character in the font at the
		     * Unicode position.  Failing that, use our own
		     * box-characters.
		     */
		    if (xtermXftMissing(xw, currFont, ch)) {
			SetMissing();
		    }
		}
#endif

		/*
		 * If we now have one of our box-codes, draw it directly.
		 */
		if (missing || replace) {
		    /* line drawing character time */
		    if (last > first) {
			int nc = drawClippedXftString(xw,
						      attr_flags,
						      currFont,
						      getXftColor(xw, values.foreground),
						      curX,
						      y,
						      text + first,
						      (Cardinal) (last - first));
			curX += nc * FontWidth(screen);
			underline_len += (Cardinal) nc;
		    }
		    if (missing) {
			old_wide = screen->fnt_wide;
			old_high = screen->fnt_high;
			screen->fnt_wide = (Dimension) FontWidth(screen);
			screen->fnt_high = (Dimension) FontHeight(screen);
			xtermDrawBoxChar(xw, ch,
					 attr_flags,
					 draw_flags,
					 gc,
					 curX, y - FontAscent(screen), 1);
			curX += FontWidth(screen);
			underline_len += 1;
			screen->fnt_wide = old_wide;
			screen->fnt_high = old_high;
		    } else {
			IChar ch2 = (IChar) ch;
			int nc = drawClippedXftString(xw,
						      attr_flags,
						      currFont,
						      getXftColor(xw, values.foreground),
						      curX,
						      y,
						      &ch2,
						      1);
			curX += nc * FontWidth(screen);
			underline_len += (Cardinal) nc;
			if (filler) {
			    ch2 = ' ';
			    nc = drawClippedXftString(xw,
						      attr_flags,
						      currFont,
						      getXftColor(xw, values.foreground),
						      curX,
						      y,
						      &ch2,
						      1);
			    curX += nc * FontWidth(screen);
			    underline_len += (Cardinal) nc;
			}
		    }
		    first = last + 1;
		}
	    }
	    if (last > first) {
		underline_len += (Cardinal)
		    drawClippedXftString(xw,
					 attr_flags,
					 font,
					 getXftColor(xw, values.foreground),
					 curX,
					 y,
					 text + first,
					 (Cardinal) (last - first));
	    }
	}
#else
	{
	    underline_len += (Cardinal)
		drawClippedXftString(xw,
				     attr_flags,
				     font,
				     getXftColor(xw, values.foreground),
				     x,
				     y,
				     text,
				     len);
	}
#endif /* OPT_BOX_CHARS */

	(void) drawUnderline(xw,
			     gc,
			     attr_flags,
			     underline_len,
			     FontWidth(screen),
			     x,
			     y,
			     did_ul);

	x += (int) len *FontWidth(screen);

	return x;
    }
#endif /* OPT_RENDERFONT */
    curFont = ((attr_flags & BOLDATTR(screen))
	       ? WhichVFontData(screen, fnts[fBold])
	       : WhichVFontData(screen, fnts[fNorm]));
    /*
     * If we're asked to display a proportional font, do this with a fixed
     * pitch.  Yes, it's ugly.  But we cannot distinguish the use of xterm
     * as a dumb terminal vs its use as in fullscreen programs such as vi.
     * Hint: do not try to use a proportional font in the icon.
     */
    if (!IsIcon(screen) && !(draw_flags & CHARBYCHAR) && screen->fnt_prop) {
	int adj, width;

	while (len--) {
	    int cells = WideCells(*text);
#if OPT_BOX_CHARS
#if OPT_WIDE_CHARS
	    if (*text == HIDDEN_CHAR) {
		++text;
		continue;
	    } else
#endif
	    if (IsXtermMissingChar(screen, *text, curFont)) {
		adj = 0;
	    } else
#endif
	    {
		if_WIDE_OR_NARROW(screen, {
		    XChar2b temp[1];
		    temp[0].byte2 = LO_BYTE(*text);
		    temp[0].byte1 = HI_BYTE(*text);
		    width = XTextWidth16(curFont->fs, temp, 1);
		}
		, {
		    char temp[1];
		    temp[0] = (char) LO_BYTE(*text);
		    width = XTextWidth(curFont->fs, temp, 1);
		});
		adj = (FontWidth(screen) - width) / 2;
		if (adj < 0)
		    adj = 0;
	    }
	    xtermFillCells(xw, draw_flags, gc, x, y, (Cardinal) cells);
	    x = drawXtermText(xw,
			      attr_flags,
			      draw_flags | NOBACKGROUND | CHARBYCHAR,
			      gc, x + adj, y, chrset,
			      text++, 1, on_wide) - adj;
	}

	return x;
    }
#if OPT_BOX_CHARS
    /*
     * Draw some substitutions, if needed.  The font may not include the
     * line-drawing set, or it may be incomplete (in which case we'll draw an
     * empty space via xtermDrawBoxChar), or we may be told to force our
     * line-drawing.
     *
     * The empty space is a special case which can be overridden with the
     * showMissingGlyphs resource to produce an outline.  Not all fonts in
     * "modern" (sic) X provide an empty space; some use a thick outline or
     * something like the replacement character.  If you would rather not see
     * that, you can set assumeAllChars.
     */
    if (!IsIcon(screen)
	&& !(draw_flags & NOTRANSLATION)
	&& (!screen->fnt_boxes
	    || (FontIsIncomplete(curFont) && !screen->assume_all_chars)
	    || screen->force_box_chars)) {
	/*
	 * Fill in missing box-characters.  Find regions without missing
	 * characters, and draw them calling ourselves recursively.  Draw
	 * missing characters via xtermDrawBoxChar().
	 */
	int last, first = 0;
	Bool drewBoxes = False;

	for (last = 0; last < (int) len; last++) {
	    unsigned ch = (unsigned) text[last];
	    Bool isMissing;
	    int ch_width;
#if OPT_WIDE_CHARS

	    if (ch == HIDDEN_CHAR) {
		if (last > first) {
		    x = drawXtermText(xw,
				      attr_flags,
				      draw_flags | NOTRANSLATION,
				      gc,
				      x, y,
				      chrset, text + first,
				      (unsigned) (last - first), on_wide);
		}
		first = last + 1;
		drewBoxes = True;
		continue;
	    }
	    ch_width = my_wcwidth((wchar_t) ch);
	    isMissing =
		IsXtermMissingChar(screen, ch,
				   ((on_wide || ch_width > 1)
				    && okFont(NormalWFont(screen)))
				   ? WhichVFontData(screen, fnts[fWide])
				   : curFont);
#else
	    isMissing = IsXtermMissingChar(screen, ch, curFont);
	    ch_width = 1;
#endif
	    /*
	     * If the character is not missing, but we're in wide-character
	     * mode and the character happens to be a wide-character that
	     * corresponds to the line-drawing set, allow the forceBoxChars
	     * resource (or menu entry) to force it to display using our
	     * tables.
	     */
	    if_OPT_WIDE_CHARS(screen, {
		if (!isMissing
		    && TScreenOf(xw)->force_box_chars) {
		    if (ch > 255
			&& ucs2dec(ch) < 32) {
			ch = ucs2dec(ch);
			isMissing = True;
		    } else if (ch < 32) {
			isMissing = True;
		    }
		}
	    });

	    if (isMissing) {
		if (last > first) {
		    x = drawXtermText(xw,
				      attr_flags,
				      draw_flags | NOTRANSLATION,
				      gc,
				      x, y,
				      chrset, text + first,
				      (unsigned) (last - first), on_wide);
		}
#if OPT_WIDE_CHARS
		if (ch_width <= 0 && ch < 32)
		    ch_width = 1;	/* special case for line-drawing */
		else if (ch_width < 0)
		    ch_width = 1;	/* special case for combining char */
		if (!ucs_workaround(xw, ch,
				    attr_flags,
				    draw_flags,
				    gc, x, y, chrset, on_wide)) {
		    xtermDrawBoxChar(xw, ch,
				     attr_flags,
				     draw_flags,
				     gc, x, y, ch_width);
		}
#else
		xtermDrawBoxChar(xw, ch,
				 attr_flags,
				 draw_flags,
				 gc, x, y, ch_width);
#endif
		x += (ch_width * FontWidth(screen));
		first = last + 1;
		drewBoxes = True;
	    }
	}
	if (last <= first) {
	    return x;
	}
	text += first;
	len = (Cardinal) (last - first);
	draw_flags |= NOTRANSLATION;
	if (drewBoxes) {
	    return drawXtermText(xw,
				 attr_flags,
				 draw_flags,
				 gc,
				 x,
				 y,
				 chrset,
				 text,
				 len,
				 on_wide);
	}
    }
#endif /* OPT_BOX_CHARS */
    /*
     * Behave as if the font has (maybe Unicode-replacements for) drawing
     * characters in the range 1-31 (either we were not asked to ignore them,
     * or the caller made sure that there is none).
     */
#if OPT_WIDE_ATTRS
#define AttrFlags() attr_flags
#define DrawFlags() draw_flags
#else
#define AttrFlags() (attr_flags & DRAWX_MASK)
#define DrawFlags() (draw_flags & ~DRAWX_MASK)
#endif
    TRACE(("drawtext%c[%4d,%4d] {%#x,%#x} (%d) %d:%s\n",
	   screen->cursor_state == OFF ? ' ' : '*',
	   y, x,
	   AttrFlags(),
	   DrawFlags(),
	   chrset, len,
	   visibleIChars(text, len)));
    if (screen->scale_height != 1.0) {
	xtermFillCells(xw, draw_flags, gc, x, y, (Cardinal) len);
    }
    y += FontAscent(screen);

#if OPT_WIDE_CHARS

    if (screen->wide_chars || screen->unicode_font) {
	XChar2b *buffer;
	Bool needWide = False;
	int src, dst;
	Bool useBoldFont;
	int ascent_adjust = 0;

	BumpTypedBuffer(XChar2b, len);
	buffer = BfBuf(XChar2b);

	for (src = dst = 0; src < (int) len; src++) {
	    IChar ch = text[src];

	    if (ch == HIDDEN_CHAR)
		continue;

	    if (!needWide
		&& !IsIcon(screen)
		&& ((on_wide || my_wcwidth((wchar_t) ch) > 1)
		    && okFont(NormalWFont(screen)))) {
		needWide = True;
	    }

	    /*
	     * bitmap-fonts are limited to 16-bits.
	     */
#if OPT_WIDER_ICHAR
	    if (ch > 0xffff) {
		ch = UCS_REPL;
	    }
#endif
	    buffer[dst].byte2 = LO_BYTE(ch);
	    buffer[dst].byte1 = HI_BYTE(ch);
#if OPT_MINI_LUIT
#define UCS2SBUF(value)	buffer[dst].byte2 = LO_BYTE(value);\
	    		buffer[dst].byte1 = HI_BYTE(value)

#define Map2Sbuf(from,to) (text[src] == from) { UCS2SBUF(to); }

	    if (screen->latin9_mode && !screen->utf8_mode && text[src] < 256) {

		/* see http://www.cs.tut.fi/~jkorpela/latin9.html */
		/* *INDENT-OFF* */
		if Map2Sbuf(0xa4, 0x20ac)
		else if Map2Sbuf(0xa6, 0x0160)
		else if Map2Sbuf(0xa8, 0x0161)
		else if Map2Sbuf(0xb4, 0x017d)
		else if Map2Sbuf(0xb8, 0x017e)
		else if Map2Sbuf(0xbc, 0x0152)
		else if Map2Sbuf(0xbd, 0x0153)
		else if Map2Sbuf(0xbe, 0x0178)
		/* *INDENT-ON* */

	    }
	    if (screen->unicode_font
		&& (text[src] == ANSI_DEL ||
		    text[src] < ANSI_SPA)) {
		unsigned ni = dec2ucs((unsigned) ((text[src] == ANSI_DEL)
						  ? 0
						  : text[src]));
		UCS2SBUF(ni);
	    }
#endif /* OPT_MINI_LUIT */
	    ++dst;
	}

	/*
	 * Check for special case where the bold font lacks glyphs found in the
	 * normal font, and drop down to normal fonts with overstriking to help
	 * show the actual characters.
	 */
	useBoldFont = ((attr_flags & BOLDATTR(screen)) != 0);
	if (useBoldFont) {
	    XTermFonts *norm = 0;
	    XTermFonts *bold = 0;
	    Bool noBold, noNorm;

	    if (needWide && okFont(BoldWFont(screen))) {
		norm = WhichVFontData(screen, fnts[fWide]);
		bold = WhichVFontData(screen, fnts[fWBold]);
	    } else if (okFont(BoldFont(screen))) {
		norm = WhichVFontData(screen, fnts[fNorm]);
		bold = WhichVFontData(screen, fnts[fBold]);
	    } else {
		useBoldFont = False;
	    }

	    if (useBoldFont && FontIsIncomplete(bold)) {
		for (src = 0; src < (int) len; src++) {
		    IChar ch = text[src];

		    if (ch == HIDDEN_CHAR)
			continue;

		    noBold = IsXtermMissingChar(screen, ch, bold);
		    if (noBold) {
			noNorm = IsXtermMissingChar(screen, ch, norm);
			if (!noNorm) {
			    useBoldFont = False;
			    break;
			}
		    }
		}
	    }
	}

	/* FIXME This is probably wrong. But it works. */
	underline_len = len;

	/* Set the drawing font */
	if (!(draw_flags & (DOUBLEHFONT | DOUBLEWFONT))) {
	    VTwin *currentWin = WhichVWin(screen);
	    VTFontEnum fntId;
	    CgsEnum cgsId;
	    Pixel fg = getCgsFore(xw, currentWin, gc);
	    Pixel bg = getCgsBack(xw, currentWin, gc);

	    if (needWide
		&& useBoldFont
		&& okFont(BoldWFont(screen))) {
		fntId = fWBold;
		cgsId = gcWBold;
	    } else if (needWide) {
		fntId = fWide;
		cgsId = gcWide;
	    } else if (useBoldFont) {
		fntId = fBold;
		cgsId = gcBold;
	    } else {
		fntId = fNorm;
		cgsId = gcNorm;
	    }

	    setCgsFore(xw, currentWin, cgsId, fg);
	    setCgsBack(xw, currentWin, cgsId, bg);
	    gc = getCgsGC(xw, currentWin, cgsId);

#if OPT_WIDE_ATTRS
#if OPT_DEC_CHRSET
	    if (!(CSET_DOUBLE(chrset) || (draw_flags & DOUBLEWFONT)))
#endif
		need_clipping = fixupItalics(xw, draw_flags, gc,
					     getCgsFont(xw, currentWin, gc),
					     y, x, font_width, len);
#endif
	    if (fntId != fNorm) {
		XFontStruct *thisFp = WhichVFont(screen, fnts[fntId].fs);
		ascent_adjust = (thisFp->ascent
				 - NormalFont(screen)->ascent);
		if (thisFp->max_bounds.width ==
		    NormalFont(screen)->max_bounds.width * 2) {
		    underline_len = real_length = (Cardinal) (dst * 2);
		} else if (cgsId == gcWide || cgsId == gcWBold) {
		    underline_len = real_length = (Cardinal) (dst * 2);
		    xtermFillCells(xw,
				   draw_flags,
				   gc,
				   x,
				   y - thisFp->ascent,
				   real_length);
		}
	    }
	}

	if (draw_flags & NOBACKGROUND) {
	    XDrawString16(screen->display,
			  VDrawable(screen), gc,
			  x, y + ascent_adjust,
			  buffer, dst);
	} else {
	    XDrawImageString16(screen->display,
			       VDrawable(screen), gc,
			       x, y + ascent_adjust,
			       buffer, dst);
	}
#if OPT_WIDE_ATTRS
	if (need_clipping) {
	    endClipping(screen, gc);
	}
#endif

	if ((attr_flags & BOLDATTR(screen)) && (screen->enbolden || !useBoldFont)) {
	    beginClipping(screen, gc, (Cardinal) font_width, len);
	    XDrawString16(screen->display, VDrawable(screen), gc,
			  x + 1,
			  y + ascent_adjust,
			  buffer, dst);
	    endClipping(screen, gc);
	}

    } else
#endif /* OPT_WIDE_CHARS */
    {
	int length = (int) len;	/* X should have used unsigned */
#if OPT_WIDE_CHARS
	char *buffer;
	int dst;

	BumpTypedBuffer(char, len);
	buffer = BfBuf(char);

	for (dst = 0; dst < length; ++dst)
	    buffer[dst] = (char) LO_BYTE(text[dst]);
#else
	char *buffer = (char *) text;
#endif

#if OPT_WIDE_ATTRS
#if OPT_DEC_CHRSET
	if (!(CSET_DOUBLE(chrset) || (draw_flags & DOUBLEWFONT)))
#endif
	    need_clipping = fixupItalics(xw, draw_flags, gc, curFont,
					 y, x, font_width, len);
#endif

	if (draw_flags & NOBACKGROUND) {
	    XDrawString(screen->display, VDrawable(screen), gc,
			x, y, buffer, length);
	} else {
	    XDrawImageString(screen->display, VDrawable(screen), gc,
			     x, y, buffer, length);
	}

#if OPT_WIDE_ATTRS
	if (need_clipping) {
	    endClipping(screen, gc);
	}
#endif
	underline_len = (Cardinal) length;
	if ((attr_flags & BOLDATTR(screen)) && screen->enbolden) {
	    beginClipping(screen, gc, font_width, length);
	    XDrawString(screen->display, VDrawable(screen), gc,
			x + 1, y, buffer, length);
	    endClipping(screen, gc);
	}
    }

    (void) drawUnderline(xw,
			 gc,
			 attr_flags,
			 underline_len,
			 font_width,
			 x,
			 y,
			 did_ul);

    x += ((int) real_length) * FontWidth(screen);
    return x;
}

#if OPT_WIDE_CHARS
/*
 * Allocate buffer - workaround for wide-character interfaces.
 */
void
allocXtermChars(ScrnPtr *buffer, Cardinal length)
{
    if (*buffer == 0) {
	*buffer = (ScrnPtr) XtMalloc(length);
    } else {
	*buffer = (ScrnPtr) XtRealloc((char *) *buffer, length);
    }
}
#endif

/* set up size hints for window manager; min 1 char by 1 char */
void
xtermSizeHints(XtermWidget xw, int scrollbarWidth)
{
    TScreen *screen = TScreenOf(xw);

    TRACE(("xtermSizeHints\n"));
    TRACE(("   border    %d\n", xw->core.border_width));
    TRACE(("   scrollbar %d\n", scrollbarWidth));

    xw->hints.base_width = 2 * screen->border + scrollbarWidth;
    xw->hints.base_height = 2 * screen->border;

#if OPT_TOOLBAR
    TRACE(("   toolbar   %d\n", ToolbarHeight(xw)));

    xw->hints.base_height += ToolbarHeight(xw);
    xw->hints.base_height += BorderWidth(xw) * 2;
    xw->hints.base_width += BorderWidth(xw) * 2;
#endif

    xw->hints.width_inc = FontWidth(screen);
    xw->hints.height_inc = FontHeight(screen);
    xw->hints.min_width = xw->hints.base_width + xw->hints.width_inc;
    xw->hints.min_height = xw->hints.base_height + xw->hints.height_inc;

    xw->hints.width = MaxCols(screen) * FontWidth(screen) + xw->hints.min_width;
    xw->hints.height = MaxRows(screen) * FontHeight(screen) + xw->hints.min_height;

    xw->hints.flags |= (PSize | PBaseSize | PMinSize | PResizeInc);

    TRACE_HINTS(&(xw->hints));
}

void
getXtermSizeHints(XtermWidget xw)
{
    TScreen *screen = TScreenOf(xw);
    long supp;

    if (!XGetWMNormalHints(screen->display, VShellWindow(xw),
			   &xw->hints, &supp))
	memset(&xw->hints, 0, sizeof(xw->hints));
    TRACE_HINTS(&(xw->hints));
}

CgsEnum
whichXtermCgs(XtermWidget xw, unsigned attr_flags, Bool hilite)
{
    TScreen *screen = TScreenOf(xw);
    CgsEnum cgsId = gcMAX;

    if (ReverseOrHilite(screen, attr_flags, hilite)) {
	if (attr_flags & BOLDATTR(screen)) {
	    cgsId = gcBoldReverse;
	} else {
	    cgsId = gcNormReverse;
	}
    } else {
	if (attr_flags & BOLDATTR(screen)) {
	    cgsId = gcBold;
	} else {
	    cgsId = gcNorm;
	}
    }
    return cgsId;
}

/*
 * Returns a GC, selected according to the font (reverse/bold/normal) that is
 * required for the current position (implied).  The GC is updated with the
 * current screen foreground and background colors.
 */
GC
updatedXtermGC(XtermWidget xw, unsigned attr_flags, unsigned fg_bg, Bool hilite)
{
    TScreen *screen = TScreenOf(xw);
    VTwin *win = WhichVWin(screen);
    CgsEnum cgsId = whichXtermCgs(xw, attr_flags, hilite);
    unsigned my_fg = extract_fg(xw, fg_bg, attr_flags);
    unsigned my_bg = extract_bg(xw, fg_bg, attr_flags);
    Pixel fg_pix = getXtermForeground(xw, attr_flags, (int) my_fg);
    Pixel bg_pix = getXtermBackground(xw, attr_flags, (int) my_bg);
    Pixel xx_pix;
#if OPT_HIGHLIGHT_COLOR
    Pixel selbg_pix = T_COLOR(screen, HIGHLIGHT_BG);
    Pixel selfg_pix = T_COLOR(screen, HIGHLIGHT_FG);
    Boolean always = screen->hilite_color;
    Boolean use_selbg = (Boolean) (always ||
				   isNotForeground(xw, fg_pix, bg_pix, selbg_pix));
    Boolean use_selfg = (Boolean) (always &&
				   isNotBackground(xw, fg_pix, bg_pix, selfg_pix));
#endif

    (void) fg_bg;
    (void) my_bg;
    (void) my_fg;

    /*
     * Discard video attributes overridden by colorXXXMode's.
     */
    checkVeryBoldColors(attr_flags, my_fg);

    if (ReverseOrHilite(screen, attr_flags, hilite)) {
#if OPT_HIGHLIGHT_COLOR
	if (!screen->hilite_color) {
	    if (selbg_pix != T_COLOR(screen, TEXT_FG)
		&& selbg_pix != fg_pix
		&& selbg_pix != bg_pix
		&& selbg_pix != xw->dft_foreground) {
		bg_pix = fg_pix;
		fg_pix = selbg_pix;
	    }
	}
#endif
	EXCHANGE(fg_pix, bg_pix, xx_pix);
#if OPT_HIGHLIGHT_COLOR
	if (screen->hilite_color) {
	    if (screen->hilite_reverse) {
		if (use_selbg) {
		    if (use_selfg)
			bg_pix = fg_pix;
		    else
			fg_pix = bg_pix;
		}
		if (use_selbg)
		    bg_pix = selbg_pix;
		if (use_selfg)
		    fg_pix = selfg_pix;
	    }
	}
#endif
    }
#if OPT_HIGHLIGHT_COLOR
    if (!screen->hilite_color || !screen->hilite_reverse) {
	if (hilite && !screen->hilite_reverse) {
	    if (use_selbg)
		bg_pix = selbg_pix;
	    if (use_selfg)
		fg_pix = selfg_pix;
	}
    }
#endif

#if OPT_BLINK_TEXT
    if ((screen->blink_state == ON) &&
	(!screen->blink_as_bold) &&
	(attr_flags & BLINK)) {
	fg_pix = bg_pix;
    }
#endif

    setCgsFore(xw, win, cgsId, fg_pix);
    setCgsBack(xw, win, cgsId, bg_pix);
    return getCgsGC(xw, win, cgsId);
}

/*
 * Resets the foreground/background of the GC returned by 'updatedXtermGC()'
 * to the values that would be set in SGR_Foreground and SGR_Background. This
 * duplicates some logic, but only modifies 1/4 as many GC's.
 */
void
resetXtermGC(XtermWidget xw, unsigned attr_flags, Bool hilite)
{
    TScreen *screen = TScreenOf(xw);
    VTwin *win = WhichVWin(screen);
    CgsEnum cgsId = whichXtermCgs(xw, attr_flags, hilite);
    Pixel fg_pix = getXtermForeground(xw, attr_flags, xw->cur_foreground);
    Pixel bg_pix = getXtermBackground(xw, attr_flags, xw->cur_background);

    checkVeryBoldColors(attr_flags, xw->cur_foreground);

    if (ReverseOrHilite(screen, attr_flags, hilite)) {
	setCgsFore(xw, win, cgsId, bg_pix);
	setCgsBack(xw, win, cgsId, fg_pix);
    } else {
	setCgsFore(xw, win, cgsId, fg_pix);
	setCgsBack(xw, win, cgsId, bg_pix);
    }
}

#if OPT_ISO_COLORS
/*
 * Extract the foreground-color index from a color pair.
 * If we've got BOLD or UNDERLINE color-mode active, those will be used.
 */
unsigned
extract_fg(XtermWidget xw, unsigned color, unsigned attr_flags)
{
    unsigned fg = ExtractForeground(color);

    if (TScreenOf(xw)->colorAttrMode
	|| (fg == ExtractBackground(color))) {
	fg = MapToColorMode(fg, TScreenOf(xw), attr_flags);
    }
    return fg;
}

/*
 * Extract the background-color index from a color pair.
 * If we've got INVERSE color-mode active, that will be used.
 */
unsigned
extract_bg(XtermWidget xw, unsigned color, unsigned attr_flags)
{
    unsigned bg = ExtractBackground(color);

    if (TScreenOf(xw)->colorAttrMode
	|| (bg == ExtractForeground(color))) {
	if (TScreenOf(xw)->colorRVMode && (attr_flags & INVERSE))
	    bg = COLOR_RV;
    }
    return bg;
}

/*
 * Combine the current foreground and background into a single 8-bit number.
 * Note that we're storing the SGR foreground, since cur_foreground may be set
 * to COLOR_UL, COLOR_BD or COLOR_BL, which would make the code larger than 8
 * bits.
 *
 * This assumes that fg/bg are equal when we override with one of the special
 * attribute colors.
 */
CellColor
makeColorPair(int fg, int bg)
{
    unsigned my_bg = (bg >= 0) && (bg < NUM_ANSI_COLORS) ? (unsigned) bg : 0;
    unsigned my_fg = (fg >= 0) && (fg < NUM_ANSI_COLORS) ? (unsigned) fg : my_bg;

    return (CellColor) (my_fg | (my_bg << COLOR_BITS));
}

/*
 * Using the "current" SGR background, clear a rectangle.
 */
void
ClearCurBackground(XtermWidget xw,
		   int top,
		   int left,
		   unsigned height,
		   unsigned width,
		   unsigned fw)
{
    TScreen *screen = TScreenOf(xw);

    TRACE(("ClearCurBackground %d,%d %dx%d with %d\n",
	   top, left, height, width, xw->cur_background));

    assert((int) width > 0);
    assert((left + (int) width) <= screen->max_col + 1);
    assert((int) height <= screen->max_row + 1);

    if (VWindow(screen)) {
	set_background(xw, xw->cur_background);

#if OPT_DOUBLE_BUFFER
	XFillRectangle(screen->display, VDrawable(screen),
		       ReverseGC(xw, screen),
		       CursorX2(screen, left, fw),
		       CursorY(screen, top),
		       (width * fw),
		       (height * (unsigned) FontHeight(screen)));
#else
	XClearArea(screen->display, VWindow(screen),
		   CursorX2(screen, left, fw),
		   CursorY2(screen, top),
		   (width * fw),
		   (height * (unsigned) FontHeight(screen)),
		   False);
#endif

	set_background(xw, -1);
    }
}
#endif /* OPT_ISO_COLORS */

Pixel
getXtermBackground(XtermWidget xw, unsigned attr_flags, int color)
{
    Pixel result = T_COLOR(TScreenOf(xw), TEXT_BG);
#if OPT_ISO_COLORS
    if ((attr_flags & BG_COLOR) && (color >= 0 && color < MAXCOLORS)) {
	result = GET_COLOR_RES(xw, TScreenOf(xw)->Acolors[color]);
    }
#endif
    return result;
}

Pixel
getXtermForeground(XtermWidget xw, unsigned attr_flags, int color)
{
    Pixel result = T_COLOR(TScreenOf(xw), TEXT_FG);
#if OPT_ISO_COLORS
    if ((attr_flags & FG_COLOR) && (color >= 0 && color < MAXCOLORS)) {
	result = GET_COLOR_RES(xw, TScreenOf(xw)->Acolors[color]);
    }
#endif
#if OPT_WIDE_ATTRS
#define DIM_IT(n) work.n = (unsigned short) ((2 * work.n) / 3)
    if ((attr_flags & ATR_FAINT)) {
	static Pixel last_in;
	static Pixel last_out;
	if (result != last_in) {
	    XColor work;
	    work.pixel = result;
	    last_in = result;
	    if (XQueryColor(TScreenOf(xw)->display, xw->core.colormap, &work)) {
		DIM_IT(red);
		DIM_IT(green);
		DIM_IT(blue);
		if (allocateBestRGB(xw, &work)) {
		    result = work.pixel;
		}
	    }
	    last_out = result;
	} else {
	    result = last_out;
	}
    }
#endif
    return result;
}

/*
 * Returns a single base character for the given cell.
 */
unsigned
getXtermCell(TScreen *screen, int row, int col)
{
    CLineData *ld = getLineData(screen, row);

    return ((ld && (col < (int) ld->lineSize))
	    ? ld->charData[col]
	    : (unsigned) ' ');
}

/*
 * Sets a single base character for the given cell.
 */
void
putXtermCell(TScreen *screen, int row, int col, int ch)
{
    LineData *ld = getLineData(screen, row);

    if (ld && (col < (int) ld->lineSize)) {
	ld->charData[col] = (CharData) ch;
	if_OPT_WIDE_CHARS(screen, {
	    size_t off;
	    for_each_combData(off, ld) {
		ld->combData[off][col] = 0;
	    }
	});
    }
}

#if OPT_WIDE_CHARS
/*
 * Add a combining character for the given cell
 */
void
addXtermCombining(TScreen *screen, int row, int col, unsigned ch)
{
    if (ch != 0) {
	LineData *ld = getLineData(screen, row);
	size_t off;

	TRACE(("addXtermCombining %d,%d %#x (%d)\n",
	       row, col, ch, my_wcwidth((wchar_t) ch)));

	for_each_combData(off, ld) {
	    if (!ld->combData[off][col]) {
		ld->combData[off][col] = (CharData) ch;
		break;
	    }
	}
    }
}

unsigned
getXtermCombining(TScreen *screen, int row, int col, int off)
{
    CLineData *ld = getLineData(screen, row);
    return (ld->combSize ? ld->combData[off][col] : 0);
}
#endif

void
update_keyboard_type(void)
{
    update_delete_del();
    update_tcap_fkeys();
    update_old_fkeys();
    update_hp_fkeys();
    update_sco_fkeys();
    update_sun_fkeys();
    update_sun_kbd();
}

void
set_keyboard_type(XtermWidget xw, xtermKeyboardType type, Bool set)
{
    xtermKeyboardType save = xw->keyboard.type;

    TRACE(("set_keyboard_type(%s, %s) currently %s\n",
	   visibleKeyboardType(type),
	   BtoS(set),
	   visibleKeyboardType(xw->keyboard.type)));
    if (set) {
	xw->keyboard.type = type;
    } else {
	xw->keyboard.type = keyboardIsDefault;
    }

    if (save != xw->keyboard.type) {
	update_keyboard_type();
    }
}

void
toggle_keyboard_type(XtermWidget xw, xtermKeyboardType type)
{
    xtermKeyboardType save = xw->keyboard.type;

    TRACE(("toggle_keyboard_type(%s) currently %s\n",
	   visibleKeyboardType(type),
	   visibleKeyboardType(xw->keyboard.type)));
    if (xw->keyboard.type == type) {
	xw->keyboard.type = keyboardIsDefault;
    } else {
	xw->keyboard.type = type;
    }

    if (save != xw->keyboard.type) {
	update_keyboard_type();
    }
}

const char *
visibleKeyboardType(xtermKeyboardType type)
{
    const char *result = "?";
    switch (type) {
	CASETYPE(keyboardIsLegacy);	/* bogus vt220 codes for F1-F4, etc. */
	CASETYPE(keyboardIsDefault);
	CASETYPE(keyboardIsHP);
	CASETYPE(keyboardIsSCO);
	CASETYPE(keyboardIsSun);
	CASETYPE(keyboardIsTermcap);
	CASETYPE(keyboardIsVT220);
    }
    return result;
}

static void
init_keyboard_type(XtermWidget xw, xtermKeyboardType type, Bool set)
{
    TRACE(("init_keyboard_type(%s, %s) currently %s\n",
	   visibleKeyboardType(type),
	   BtoS(set),
	   visibleKeyboardType(xw->keyboard.type)));
    if (set) {
	/*
	 * Check for conflicts, e.g., if someone asked for both Sun and HP
	 * function keys.
	 */
	if (guard_keyboard_type) {
	    xtermWarning("Conflicting keyboard type option (%s/%s)\n",
			 visibleKeyboardType(xw->keyboard.type),
			 visibleKeyboardType(type));
	}
	xw->keyboard.type = type;
	guard_keyboard_type = True;
	update_keyboard_type();
    }
}

/*
 * If the keyboardType resource is set, use that, overriding the individual
 * boolean resources for different keyboard types.
 */
void
decode_keyboard_type(XtermWidget xw, XTERM_RESOURCE * rp)
{
#define DATA(n, t, f) { n, t, XtOffsetOf(XTERM_RESOURCE, f) }
#define FLAG(n) *(Boolean *)(((char *)rp) + table[n].offset)
    static struct {
	const char *name;
	xtermKeyboardType type;
	unsigned offset;
    } table[] = {
	DATA(NAME_OLD_KT, keyboardIsLegacy, oldKeyboard),
#if OPT_HP_FUNC_KEYS
	    DATA(NAME_HP_KT, keyboardIsHP, hpFunctionKeys),
#endif
#if OPT_SCO_FUNC_KEYS
	    DATA(NAME_SCO_KT, keyboardIsSCO, scoFunctionKeys),
#endif
#if OPT_SUN_FUNC_KEYS
	    DATA(NAME_SUN_KT, keyboardIsSun, sunFunctionKeys),
#endif
#if OPT_SUNPC_KBD
	    DATA(NAME_VT220_KT, keyboardIsVT220, sunKeyboard),
#endif
#if OPT_TCAP_FKEYS
	    DATA(NAME_TCAP_KT, keyboardIsTermcap, termcapKeys),
#endif
    };
    Cardinal n;
    TScreen *screen = TScreenOf(xw);

    TRACE(("decode_keyboard_type(%s)\n", rp->keyboardType));
    if (!x_strcasecmp(rp->keyboardType, "unknown")) {
	/*
	 * Let the individual resources comprise the keyboard-type.
	 */
	for (n = 0; n < XtNumber(table); ++n)
	    init_keyboard_type(xw, table[n].type, FLAG(n));
    } else if (!x_strcasecmp(rp->keyboardType, "default")) {
	/*
	 * Set the keyboard-type to the Sun/PC type, allowing modified
	 * function keys, etc.
	 */
	for (n = 0; n < XtNumber(table); ++n)
	    init_keyboard_type(xw, table[n].type, False);
    } else {
	Bool found = False;

	/*
	 * Special case: oldXtermFKeys should have been like the others.
	 */
	if (!x_strcasecmp(rp->keyboardType, NAME_OLD_KT)) {
	    TRACE(("special case, setting oldXtermFKeys\n"));
	    screen->old_fkeys = True;
	    screen->old_fkeys0 = True;
	}

	/*
	 * Choose an individual keyboard type.
	 */
	for (n = 0; n < XtNumber(table); ++n) {
	    if (!x_strcasecmp(rp->keyboardType, table[n].name + 1)) {
		FLAG(n) = True;
		found = True;
	    } else {
		FLAG(n) = False;
	    }
	    init_keyboard_type(xw, table[n].type, FLAG(n));
	}
	if (!found) {
	    xtermWarning("KeyboardType resource \"%s\" not found\n",
			 rp->keyboardType);
	}
    }
#undef DATA
#undef FLAG
}

#if OPT_WIDE_CHARS
#if defined(HAVE_WCHAR_H) && defined(HAVE_WCWIDTH)
/*
 * If xterm is running in a UTF-8 locale, it is still possible to encounter
 * old runtime configurations which yield incomplete or inaccurate data.
 */
static Bool
systemWcwidthOk(int samplesize, int samplepass)
{
    wchar_t n;
    int oops = 0;

    for (n = 21; n <= 25; ++n) {
	wchar_t code = (wchar_t) dec2ucs((unsigned) n);
	int system_code = wcwidth(code);
	int intern_code = mk_wcwidth(code);

	/*
	 * Solaris 10 wcwidth() returns "2" for all of the line-drawing (page
	 * 0x2500) and most of the geometric shapes (a few are excluded, just
	 * to make it more difficult to use).  Do a sanity check to avoid using
	 * it.
	 */
	if ((system_code < 0 && intern_code >= 1)
	    || (system_code >= 0 && intern_code != system_code)) {
	    TRACE(("systemWcwidthOk: broken system line-drawing wcwidth\n"));
	    oops += (samplepass + 1);
	    break;
	}
    }

    for (n = 0; n < (wchar_t) samplesize; ++n) {
	int system_code = wcwidth(n);
	int intern_code = mk_wcwidth(n);

	/*
	 * Since mk_wcwidth() is designed to check for nonspacing characters,
	 * and has rough range-checks for double-width characters, it will
	 * generally not detect cases where a code has not been assigned.
	 *
	 * Some experimentation with GNU libc suggests that up to 1/4 of the
	 * codes would differ, simply because the runtime library would have a
	 * table listing the unassigned codes, and return -1 for those.  If
	 * mk_wcwidth() has no information about a code, it returns 1.  On the
	 * other hand, if the runtime returns a positive number, the two should
	 * agree.
	 *
	 * The "up to" is measured for 4k, 8k, 16k of data.  With only 1k, the
	 * number of differences was only 77.  However, that is only one
	 * system, and this is only a sanity check to avoid using broken
	 * libraries.
	 */
	if ((system_code < 0 && intern_code >= 1)
	    || (system_code >= 0 && intern_code != system_code)) {
	    ++oops;
	}
    }
    TRACE(("systemWcwidthOk: %d/%d mismatches, allowed %d\n",
	   oops, samplesize, samplepass));
    return (oops <= samplepass);
}
#endif /* HAVE_WCWIDTH */

void
decode_wcwidth(XtermWidget xw)
{
    int mode = ((xw->misc.cjk_width ? 2 : 0)
		+ (xw->misc.mk_width ? 1 : 0)
		+ 1);

    switch (mode) {
    default:
#if defined(HAVE_WCHAR_H) && defined(HAVE_WCWIDTH)
	if (xtermEnvUTF8() &&
	    systemWcwidthOk(xw->misc.mk_samplesize, xw->misc.mk_samplepass)) {
	    my_wcwidth = wcwidth;
	    TRACE(("using system wcwidth() function\n"));
	    break;
	}
	/* FALLTHRU */
#endif
    case 2:
	my_wcwidth = &mk_wcwidth;
	TRACE(("using MK wcwidth() function\n"));
	break;
    case 3:
    case 4:
	my_wcwidth = &mk_wcwidth_cjk;
	TRACE(("using MK-CJK wcwidth() function\n"));
	break;
    }

    for (first_widechar = 128; first_widechar < 4500; ++first_widechar) {
	if (my_wcwidth((int) first_widechar) > 1) {
	    TRACE(("first_widechar %#x\n", first_widechar));
	    break;
	}
    }
}
#endif

/*
 * Extend a (normally) boolean resource value by checking for additional values
 * which will be mapped into true/false.
 */
int
extendedBoolean(const char *value, const FlagList * table, Cardinal limit)
{
    int result = -1;
    long check;
    char *next;
    Cardinal n;

    if ((x_strcasecmp(value, "true") == 0)
	|| (x_strcasecmp(value, "yes") == 0)
	|| (x_strcasecmp(value, "on") == 0)) {
	result = True;
    } else if ((x_strcasecmp(value, "false") == 0)
	       || (x_strcasecmp(value, "no") == 0)
	       || (x_strcasecmp(value, "off") == 0)) {
	result = False;
    } else if ((check = strtol(value, &next, 0)) >= 0 && FullS2L(value, next)) {
	if (check >= (long) (limit + 2))	/* 2 is past False=0, True=1 */
	    check = True;
	result = (int) check;
    } else {
	for (n = 0; n < limit; ++n) {
	    if (x_strcasecmp(value, table[n].name) == 0) {
		result = table[n].code;
		break;
	    }
	}
    }

    if (result < 0) {
	xtermWarning("Unrecognized keyword: %s\n", value);
	result = False;
    }

    TRACE(("extendedBoolean(%s) = %d\n", value, result));
    return result;
}

/*
 * Something like round() from math library, but round() is less widely-used
 * than xterm.  Also, there are no negative numbers to complicate this.
 */
int
dimRound(double value)
{
    int result = (int) value;
    if (result < value)
	++result;
    return result;
}

/*
 * Find the geometry of the specified Xinerama screen
 */
static void
find_xinerama_screen(Display *display, int screen, struct Xinerama_geometry *ret)
{
#ifdef HAVE_X11_EXTENSIONS_XINERAMA_H
    XineramaScreenInfo *screens;
    int nb_screens;

    if (screen == -1)		/* already inited */
	return;
    screens = XineramaQueryScreens(display, &nb_screens);
    if (screen >= nb_screens) {
	xtermWarning("Xinerama screen %d does not exist\n", screen);
	return;
    }
    if (screen == -2) {
	int ptr_x, ptr_y;
	int dummy_int, i;
	unsigned dummy_uint;
	Window dummy_win;
	if (nb_screens == 0)
	    return;
	XQueryPointer(display, DefaultRootWindow(display),
		      &dummy_win, &dummy_win,
		      &ptr_x, &ptr_y,
		      &dummy_int, &dummy_int, &dummy_uint);
	for (i = 0; i < nb_screens; i++) {
	    if ((ptr_x - screens[i].x_org) < screens[i].width &&
		(ptr_y - screens[i].y_org) < screens[i].height) {
		screen = i;
		break;
	    }
	}
	if (screen < 0) {
	    xtermWarning("Mouse not in any Xinerama screen, using 0\n");
	    screen = 0;
	}
    }
    ret->scr_x = screens[screen].x_org;
    ret->scr_y = screens[screen].y_org;
    ret->scr_w = screens[screen].width;
    ret->scr_h = screens[screen].height;
#else /* HAVE_X11_EXTENSIONS_XINERAMA_H */
    (void) display;
    (void) ret;
    if (screen > 0)
	xtermWarning("Xinerama support not enabled\n");
#endif /* HAVE_X11_EXTENSIONS_XINERAMA_H */
}

/*
 * Parse the screen code after the @@ in a geometry string.
 */
static void
parse_xinerama_screen(Display *display, const char *str, struct Xinerama_geometry *ret)
{
    int screen = -1;
    char *end;

    if (*str == 'g') {
	screen = -1;
	str++;
    } else if (*str == 'c') {
	screen = -2;
	str++;
    } else {
	long s = strtol(str, &end, 0);
	if (FullS2L(str, end) && ((int) s >= 0)) {
	    screen = (int) s;
	    str = end;
	}
    }
    if (*str) {
	xtermWarning("invalid Xinerama specification '%s'\n", str);
	return;
    }
    if (screen == -1)		/* already done */
	return;
    find_xinerama_screen(display, screen, ret);
}

/*
 * Parse a geometry string with extra Xinerama specification:
 * <w>x<h>+<x>+<y>@@<screen>.
 */
int
XParseXineramaGeometry(Display *display, char *parsestring, struct Xinerama_geometry *ret)
{
    char *at, buf[128];

    ret->scr_x = 0;
    ret->scr_y = 0;
    ret->scr_w = DisplayWidth(display, DefaultScreen(display));
    ret->scr_h = DisplayHeight(display, DefaultScreen(display));
    at = strchr(parsestring, '@@');
    if (at != NULL && (size_t) (at - parsestring) < sizeof(buf) - 1) {
	memcpy(buf, parsestring, (size_t) (at - parsestring));
	buf[at - parsestring] = 0;
	parsestring = buf;
	parse_xinerama_screen(display, at + 1, ret);
    }
    return XParseGeometry(parsestring, &ret->x, &ret->y, &ret->w, &ret->h);
}
@


1.30
log
@Update to xterm-325. Testing by krw@@, shadchin@@ and naddy@@. Thanks
@
text
@d1 1
a1 1
/* $XTermId: util.c,v 1.688 2016/06/03 08:58:37 tom Exp $ */
d3312 4
d3545 1
a3545 1
			missing = 1;
d3562 1
a3562 1
				missing = True;
d3574 2
d3591 1
a3591 1
			missing = 1;
d3765 5
a3769 4
	/* Fill in missing box-characters.
	   Find regions without missing characters, and draw
	   them calling ourselves recursively.  Draw missing
	   characters via xtermDrawBoxChar(). */
d3837 2
d4850 2
a4851 2
    } else if ((check = strtol(value, &next, 0)) >= 0 && *next == '\0') {
	if (check >= (long) limit)
d4954 1
a4954 1
	if (end > str && (int) s >= 0) {
@


1.29
log
@Update to xterm 320. Tested by jsg@@ Thanks.
@
text
@d1 1
a1 1
/* $XTermId: util.c,v 1.681 2015/04/10 08:31:02 tom Exp $ */
d4 1
a4 1
 * Copyright 1999-2014,2015 by Thomas E. Dickey
a551 2
    int shift;
    int bot;
a553 2
    int scrolltop;
    int scrollheight;
d608 5
a805 6
    int shift;
    int bot;
    int refreshtop;
    int refreshheight;
    int scrolltop;
    int scrollheight;
d836 8
a843 6
	shift = INX2ROW(screen, 0);
	bot = screen->max_row - shift;
	refreshheight = amount;
	scrollheight = screen->bot_marg - screen->top_marg - refreshheight + 1;
	refreshtop = screen->top_marg + shift;
	scrolltop = refreshtop + refreshheight;
a971 1
    char *icon_name;
d975 1
a976 1
	icon_name = getIconName();
a1024 2
    int fg;
    unsigned test;
d1052 2
d1081 8
a1088 4
	if (screen->colorAttrMode) {
	    fg = MapToColorMode(xw->cur_foreground, screen, attr_flags);
	} else {
	    fg = xw->cur_foreground;
a1089 1
	checkVeryBoldColors(test, fg);
a1122 6
    int shift;
    int bot;
    int refreshtop;
    int refreshheight;
    int scrolltop;
    int scrollheight;
d1162 8
a1169 6
	shift = INX2ROW(screen, 0);
	bot = screen->max_row - shift;
	refreshheight = n;
	scrollheight = screen->bot_marg - screen->cur_row - refreshheight + 1;
	refreshtop = screen->cur_row + shift;
	scrolltop = refreshtop + refreshheight;
a1205 6
    int shift;
    int bot;
    int refreshtop;
    int refreshheight;
    int scrolltop;
    int scrollheight;
d1265 7
a1271 4
	shift = INX2ROW(screen, 0);
	bot = screen->max_row - shift;
	scrollheight = i - n;
	refreshheight = n;
d1483 1
a1483 1
	int top, height;
d1488 2
a1692 1
	    int xx;
d1694 1
a1694 1
		xx = col;
d1891 1
a1891 2
    CLineData *ld;
    int row, col;
d1894 2
d1897 2
a2071 1
	    CLineData *ld;
d2073 1
d2075 2
a2482 1
    int n;
d2497 2
d2652 1
a2652 1
    static XftColorCache cache[XFT_CACHE_SIZE];
a3338 1
    int ascent_adjust = 0;
a3475 1
	int ncells;
d3502 5
a3506 5
	    ncells = xtermXftWidth(xw, attr_flags,
				   bg_color,
				   font, x, y,
				   text,
				   len);
a3526 1
		int nc;
d3596 8
a3603 8
			nc = drawClippedXftString(xw,
						  attr_flags,
						  currFont,
						  getXftColor(xw, values.foreground),
						  curX,
						  y,
						  text + first,
						  (Cardinal) (last - first));
d3623 8
a3630 8
			nc = drawClippedXftString(xw,
						  attr_flags,
						  currFont,
						  getXftColor(xw, values.foreground),
						  curX,
						  y,
						  &ch2,
						  1);
d3828 2
a3829 5
		/*
		 * One way or another, we will draw at least one cell.
		 */
		if (ch_width <= 0)
		    ch_width = 1;
d3901 1
d4545 1
a4545 1
    return ld->combData[off][col];
d4600 17
a4616 1
void
a4618 2
    static Bool wasSet = False;

d4624 8
a4631 3
	if (wasSet) {
	    xtermWarning("Conflicting keyboard type option (%u/%u)\n",
			 xw->keyboard.type, type);
d4634 1
a4634 1
	wasSet = True;
d4653 1
d4655 1
a4655 1
	DATA(NAME_HP_KT, keyboardIsHP, hpFunctionKeys),
d4671 1
d4689 9
@


1.28
log
@xterm 314. tested by naddy@@
@
text
@d1 1
a1 1
/* $XTermId: util.c,v 1.668 2014/12/18 09:27:49 tom Exp $ */
d4 1
a4 1
 * Copyright 1999-2013,2014 by Thomas E. Dickey
d66 1
d77 4
d116 1
a116 1
    LineData *ld = getLineData(screen, row);
d901 14
d923 1
a923 9
	static char *icon_name;
	static Arg args[] =
	{
	    {XtNiconName, (XtArgVal) & icon_name}
	};

	icon_name = NULL;
	XtGetValues(toplevel, args, XtNumber(args));

d975 1
a975 5
    static char *icon_name;
    static Arg args[] =
    {
	{XtNiconName, (XtArgVal) & icon_name}
    };
d980 1
a980 2
	icon_name = NULL;
	XtGetValues(toplevel, args, XtNumber(args));
d1223 2
a1224 3
    if (!ScrnIsRowInMargins(screen, screen->cur_row)
	|| screen->cur_col < left
	|| screen->cur_col > right)
a1414 1
    int left = ScrnLeftMargin(xw);
d1420 3
d1436 2
a1437 4
    if (screen->cur_col < left || screen->cur_col > right) {
	n = 0;
    } else if (AddToVisible(xw)
	       && (ld = getLineData(screen, screen->cur_row)) != 0) {
d1487 1
a1487 1
	for (row = 0; row <= screen->max_row; row++)
d1489 1
a3448 1
	    unsigned n = 0;
d3450 17
a3466 3
	    while (len--) {
		temp[n++] = *text++;
		temp[n++] = ' ';
a3467 10
	    x = drawXtermText(xw,
			      attr_flags,
			      draw_flags,
			      gc,
			      x, y,
			      0,
			      temp,
			      n,
			      on_wide);
	    free(temp);
d4850 106
@


1.27
log
@Update to xterm 313. Tested by shadchin@@
@
text
@d1 1
a1 1
/* $XTermId: util.c,v 1.665 2014/11/13 00:54:35 tom Exp $ */
d2738 3
d2775 3
@


1.26
log
@Update to xterm-309. Version 308 tested by several people including
naddy@@ who found a small regression, fixed in 309.
@
text
@d1 1
a1 1
/* $XTermId: util.c,v 1.660 2014/06/19 22:15:20 tom Exp $ */
d690 1
a690 1
    scroll_displayed_graphics(amount);
d1022 1
a1022 1
    LineData *ld = 0;
d1324 1
a1324 1
    LineData *ld;
d1407 1
a1407 1
    LineData *ld;
d1564 1
a1564 1
    LineData *ld;
d1892 1
a1892 1
    LineData *ld;
d1953 1
a1953 2
	XWindowEvent(screen->display, VWindow(screen),
		     ExposureMask, &reply);
d2030 1
a2030 1
    LineData *ld;
d2070 1
a2070 1
	    LineData *ld;
d2805 1
a2805 1
 * rely on XftDrawString8/16  when one of  those fonts is used.
d2818 1
a2818 1
		   IChar *text,
d3178 1
a3178 1
		     IChar *text,
d3313 1
a3313 1
	      IChar *text,
d4483 1
a4483 1
    LineData *ld = getLineData(screen, row);
d4535 1
a4535 1
    LineData *ld = getLineData(screen, row);
@


1.25
log
@Update to xterm 304. With help of shadchin@@

tested by ajacoutot@@ and shadchin@@
@
text
@d1 1
a1 1
/* $XTermId: util.c,v 1.624 2014/05/02 20:24:05 tom Exp $ */
d1025 1
a1025 1
    unsigned flags = xw->flags;
d1046 1
a1046 1
    if (flags & INSERT) {
d1066 1
a1066 1
	if (flags & INVISIBLE) {
d1077 1
a1077 1
	test = flags;
d1080 1
a1080 1
	    fg = MapToColorMode(xw->cur_foreground, screen, flags);
d1088 1
a1088 1
	currentGC = updatedXtermGC(xw, flags, fg_bg, False);
d1090 4
a1093 1
	drawXtermText(xw, test & DRAWX_MASK, currentGC,
d1099 1
a1099 1
	resetXtermGC(xw, flags, False);
d1102 1
a1102 1
    ScrnWriteText(xw, str, flags, fg_bg, len);
d1586 1
a1586 1
	Char *attrs = getLineData(screen, row)->attribs + col;
d2631 14
d2648 2
a2649 6
#define CACHE_SIZE  4
    static struct {
	XftColor color;
	int use;
    } cache[CACHE_SIZE];
    static int use;
d2651 2
a2652 1
    int oldest, oldestuse;
d2654 1
d2656 1
a2656 1
    oldestuse = 0x7fffffff;
d2658 10
a2667 1
    for (i = 0; i < CACHE_SIZE; i++) {
d2670 2
a2671 2
		cache[i].use = ++use;
		return &cache[i].color;
d2674 2
a2675 2
	if (cache[i].use < oldestuse) {
	    oldestuse = cache[i].use;
d2679 11
a2689 9
    i = oldest;
    color.pixel = pixel;
    XQueryColor(TScreenOf(xw)->display, xw->core.colormap, &color);
    cache[i].color.color.red = color.red;
    cache[i].color.color.green = color.green;
    cache[i].color.color.blue = color.blue;
    cache[i].color.color.alpha = 0xffff;
    cache[i].color.pixel = pixel;
    cache[i].use = ++use;
d2731 1
a2731 1
	       unsigned flags)
d2737 6
d2744 4
a2747 4
    if ((flags & UNDERLINE)
	&& !screen->colorULMode
	&& screen->italicULMode
	&& XFT_FONT(renderWideItal[fontnum])) {
d2751 1
a2751 1
	if ((flags & BOLDATTR(screen))
d2764 1
a2764 1
	       unsigned flags,
d2771 6
d2778 4
a2781 4
    if ((flags & UNDERLINE)
	&& !screen->colorULMode
	&& screen->italicULMode
	&& XFT_FONT(renderFontItal[fontnum])) {
d2786 1
a2786 1
	if ((flags & BOLDATTR(screen))
d2814 1
a2814 1
		   unsigned flags GCC_UNUSED,
d2829 1
a2829 1
	XftFont *wfont = getWideXftFont(xw, flags);
d2895 2
a2896 2
#define xtermXftWidth(xw, flags, color, font, x, y, chars, len) \
   xtermXftDrawString(xw, flags, color, font, x, y, chars, len, False)
d2953 2
a2954 1
	       unsigned flags,
d2972 2
a2973 1
			      flags,
d3006 1
a3006 1
	       unsigned flags,
d3015 1
a3015 1
    if (!(flags & NOBACKGROUND)) {
d3174 1
a3174 1
		     unsigned flags,
d3182 1
a3182 1
    int ncells = xtermXftWidth(xw, flags,
d3190 1
a3190 1
    xtermXftDrawString(xw, flags,
d3210 92
d3308 2
a3309 1
	      unsigned flags,
d3324 1
a3324 1
    int font_width = ((flags & DOUBLEWFONT) ? 2 : 1) * screen->fnt_wide;
d3327 4
d3344 4
a3347 1
		  ? xterm_DoubleGC(xw, (unsigned) chrset, flags, gc, &inx)
d3366 1
a3366 1
		flags |= DOUBLEWFONT;
d3378 1
a3378 1
		    flags |= DOUBLEHFONT;
d3383 1
a3383 1
		    flags |= DOUBLEHFONT;
d3393 1
d3414 4
a3417 1
		    x = drawXtermText(xw, flags, gc2,
d3424 4
a3427 1
		x = drawXtermText(xw, flags, gc2,
d3445 2
a3446 1
			      flags,
d3478 3
a3480 3
#define IS_BOLD  (flags & BOLDATTR(screen))
#define NOT_BOLD (flags & ~BOLDATTR(screen))
	font = getNormXftFont(xw, flags, &did_ul);
d3483 1
a3483 1
	wfont = getWideXftFont(xw, flags);
d3489 1
a3489 1
	if (!(flags & NOBACKGROUND)) {
d3491 1
a3491 1
	    ncells = xtermXftWidth(xw, flags,
d3587 1
a3587 1
						  flags,
d3602 4
a3605 1
			xtermDrawBoxChar(xw, ch, flags, gc,
d3614 1
a3614 1
						  flags,
d3626 1
a3626 1
						      flags,
d3643 1
a3643 1
					 flags,
d3656 1
a3656 1
				     flags,
d3666 8
a3673 8
	if ((flags & UNDERLINE) && screen->underline && !did_ul) {
	    if (FontDescent(screen) > 1)
		y++;
	    XDrawLine(screen->display, VDrawable(screen), gc,
		      x, y,
		      x + (int) underline_len * FontWidth(screen) - 1,
		      y);
	}
d3680 1
a3680 1
    curFont = ((flags & BOLDATTR(screen))
d3689 1
a3689 1
    if (!IsIcon(screen) && !(flags & CHARBYCHAR) && screen->fnt_prop) {
d3721 1
a3721 1
	    xtermFillCells(xw, flags, gc, x, y, (Cardinal) cells);
d3723 2
a3724 1
			      flags | NOBACKGROUND | CHARBYCHAR,
d3745 1
a3745 1
	&& !(flags & NOTRANSLATION)
d3764 4
a3767 1
		    x = drawXtermText(xw, flags | NOTRANSLATION, gc,
d3809 4
a3812 1
		    x = drawXtermText(xw, flags | NOTRANSLATION, gc,
d3823 8
a3830 2
		if (!ucs_workaround(xw, ch, flags, gc, x, y, chrset, on_wide)) {
		    xtermDrawBoxChar(xw, ch, flags, gc, x, y, ch_width);
d3833 4
a3836 1
		xtermDrawBoxChar(xw, ch, flags, gc, x, y, ch_width);
d3848 1
a3848 1
	flags |= NOTRANSLATION;
d3851 2
a3852 1
				 flags,
d3868 8
a3875 1
    TRACE(("drawtext%c[%4d,%4d] (%d) %d:%s\n",
d3877 4
a3880 1
	   y, x, chrset, len,
d3883 1
a3883 1
	xtermFillCells(xw, flags, gc, x, y, (Cardinal) len);
a3891 1
	int ascent_adjust = 0;
d3959 1
a3959 1
	useBoldFont = ((flags & BOLDATTR(screen)) != 0);
d3998 1
a3998 1
	if (!(flags & (DOUBLEHFONT | DOUBLEWFONT))) {
d4025 8
d4043 1
a4043 1
				   flags,
d4052 1
a4052 1
	if (flags & NOBACKGROUND) {
d4063 5
d4069 1
a4069 1
	if ((flags & BOLDATTR(screen)) && (screen->enbolden || !useBoldFont)) {
d4095 9
a4103 1
	if (flags & NOBACKGROUND) {
d4110 6
d4117 1
a4117 1
	if ((flags & BOLDATTR(screen)) && screen->enbolden) {
d4125 8
a4132 6
    if ((flags & UNDERLINE) && screen->underline && !did_ul) {
	if (FontDescent(screen) > 1)
	    y++;
	XDrawLine(screen->display, VDrawable(screen), gc,
		  x, y, (x + (int) underline_len * font_width - 1), y);
    }
d4134 1
a4134 1
    x += (int) real_length *FontWidth(screen);
d4199 22
d4227 1
a4227 1
updatedXtermGC(XtermWidget xw, unsigned flags, unsigned fg_bg, Bool hilite)
d4231 5
a4235 5
    CgsEnum cgsId = gcMAX;
    unsigned my_fg = extract_fg(xw, fg_bg, flags);
    unsigned my_bg = extract_bg(xw, fg_bg, flags);
    Pixel fg_pix = getXtermForeground(xw, flags, my_fg);
    Pixel bg_pix = getXtermBackground(xw, flags, my_bg);
d4254 1
a4254 8
    checkVeryBoldColors(flags, my_fg);

    if (ReverseOrHilite(screen, flags, hilite)) {
	if (flags & BOLDATTR(screen)) {
	    cgsId = gcBoldReverse;
	} else {
	    cgsId = gcNormReverse;
	}
d4256 1
a4284 6
    } else {
	if (flags & BOLDATTR(screen)) {
	    cgsId = gcBold;
	} else {
	    cgsId = gcNorm;
	}
d4298 3
a4300 1
    if ((screen->blink_state == ON) && (!screen->blink_as_bold) && (flags & BLINK)) {
d4316 1
a4316 1
resetXtermGC(XtermWidget xw, unsigned flags, Bool hilite)
d4320 3
a4322 5
    CgsEnum cgsId = gcMAX;
    Pixel fg_pix = getXtermForeground(xw, flags, xw->cur_foreground);
    Pixel bg_pix = getXtermBackground(xw, flags, xw->cur_background);

    checkVeryBoldColors(flags, xw->cur_foreground);
d4324 1
a4324 6
    if (ReverseOrHilite(screen, flags, hilite)) {
	if (flags & BOLDATTR(screen)) {
	    cgsId = gcBoldReverse;
	} else {
	    cgsId = gcNormReverse;
	}
d4326 1
a4328 1

a4329 6
	if (flags & BOLDATTR(screen)) {
	    cgsId = gcBold;
	} else {
	    cgsId = gcNorm;
	}

d4341 1
a4341 1
extract_fg(XtermWidget xw, unsigned color, unsigned flags)
d4347 1
a4347 1
	fg = MapToColorMode(fg, TScreenOf(xw), flags);
d4357 1
a4357 1
extract_bg(XtermWidget xw, unsigned color, unsigned flags)
d4363 1
a4363 1
	if (TScreenOf(xw)->colorRVMode && (flags & INVERSE))
d4430 47
@


1.24
log
@Update to xterm 301
@
text
@d1 1
a1 1
/* $XTermId: util.c,v 1.620 2014/01/15 02:02:14 tom Exp $ */
d1387 1
a1387 1
			   1,
d1456 1
a1456 1
			   1,
d1631 1
a1631 1
			   1,
d1759 2
d2099 1
a2099 1
HandleExposure(XtermWidget xw, XEvent * event)
d2524 1
a2524 1
swapVTwinGCs(XtermWidget xw, VTwin * win)
d2603 1
a2603 1
    ReverseOldColors();
d2777 2
a2778 2
		   XftColor * color,
		   XftFont * font,
d3135 2
a3136 2
		     XftFont * font,
		     XftColor * fg_color,
d3937 1
a3937 1
allocXtermChars(ScrnPtr * buffer, Cardinal length)
d4536 1
a4536 1
extendedBoolean(const char *value, FlagList * table, Cardinal limit)
@


1.23
log
@Update to xterm-300. Tested  by ajacoutot@@ and shadchin@@.
@
text
@d1 1
a1 1
/* $XTermId: util.c,v 1.619 2013/11/23 13:02:58 tom Exp $ */
d4 1
a4 1
 * Copyright 1999-2012,2013 by Thomas E. Dickey
d3312 1
a3312 1
	XftFont *font;
d3316 1
a3316 1
	XftFont *wfont;
d3328 2
d3331 1
d3334 1
d3400 11
a3410 5
			} else if (xtermXftMissing(xw, currFont, ch)
				   && (part = AsciiEquivs(ch)) != ch) {
			    filler = needed - 1;
			    ch = part;
			    replace = True;
d3415 1
d3424 1
a3424 1
		    if (xtermXftMissing(xw, font, ch)) {
d3438 1
a3438 1
						  font,
d3462 1
a3462 1
						  font,
d3474 1
a3474 1
						      font,
@


1.22
log
@Update to xterm 296. Sixel graphics disabled for now.
@
text
@d1 1
a1 1
/* $XTermId: util.c,v 1.606 2013/07/10 22:52:14 tom Exp $ */
d1034 1
a1034 1
	   len, visibleIChar(str, len)));
d2621 1
d2699 63
d2789 1
a2789 1
	XftFont *wfont;
a2794 1
	int fontnum = screen->menu_font_number;
a2796 16
#if OPT_ISO_COLORS
	if ((flags & UNDERLINE)
	    && !screen->colorULMode
	    && screen->italicULMode
	    && XFT_FONT(renderWideItal[fontnum])) {
	    wfont = XFT_FONT(renderWideItal[fontnum]);
	} else
#endif
	    if ((flags & BOLDATTR(screen))
		&& UseBoldFont(screen)
		&& XFT_FONT(renderWideBold[fontnum])) {
	    wfont = XFT_FONT(renderWideBold[fontnum]);
	} else {
	    wfont = XFT_FONT(renderWideNorm[fontnum]);
	}

d2811 1
a2811 1
	    currFont = (charWidth == 2 && wfont != 0) ? wfont : font;
d2909 1
d2950 2
a2951 1
#endif
d3191 1
d3231 1
a3231 1
		TRACE(("drawing %s\n", visibleChrsetName((unsigned) chrset)));
a3313 1
	int fontnum = screen->menu_font_number;
d3315 3
a3317 1

d3328 3
a3330 8
#if OPT_ISO_COLORS
	if ((flags & UNDERLINE)
	    && !screen->colorULMode
	    && screen->italicULMode
	    && XFT_FONT(renderFontItal[fontnum])) {
	    font = XFT_FONT(renderFontItal[fontnum]);
	    did_ul = True;
	} else
a3331 7
	    if ((flags & BOLDATTR(screen))
		&& UseBoldFont(screen)
		&& XFT_FONT(renderFontBold[fontnum])) {
	    font = XFT_FONT(renderFontBold[fontnum]);
	} else {
	    font = XFT_FONT(renderFontNorm[fontnum]);
	}
d3361 1
d3364 2
d3376 1
a3376 1
			|| xtermXftMissing(xw, font, dec2ucs(ch))) {
d3390 9
a3398 3
			if (xtermIsDecGraphic(part) &&
			    (screen->force_box_chars
			     || xtermXftMissing(xw, font, ch))) {
d3400 1
a3400 1
			    missing = True;
d3459 13
d3516 3
a3526 3
	XTermFonts *font = ((flags & BOLDATTR(screen))
			    ? WhichVFontData(screen, fnts[fBold])
			    : WhichVFontData(screen, fnts[fNorm]));
d3537 1
a3537 1
	    if (IsXtermMissingChar(screen, *text, font)) {
d3546 1
a3546 1
		    width = XTextWidth16(font->fs, temp, 1);
d3551 1
a3551 1
		    width = XTextWidth(font->fs, temp, 1);
d3567 12
a3578 1
    /* If the font is incomplete, draw some substitutions */
d3581 3
a3583 1
	&& (!screen->fnt_boxes || screen->force_box_chars)) {
a3587 3
	XTermFonts *font = ((flags & BOLDATTR(screen))
			    ? WhichVFontData(screen, fnts[fBold])
			    : WhichVFontData(screen, fnts[fNorm]));
d3614 1
a3614 1
				   : font);
d3616 1
a3616 1
	    isMissing = IsXtermMissingChar(screen, ch, font);
a3627 2
		    && ch > 255
		    && ucs2dec(ch) < 32
d3629 7
a3635 2
		    ch = ucs2dec(ch);
		    isMissing = True;
d3770 1
a3770 1
	if ((flags & BOLDATTR(screen)) != 0) {
d3815 9
a3823 12
	    if (needWide && okFont(BoldWFont(screen))) {
		if ((flags & BOLDATTR(screen)) != 0
		    && okFont(BoldWFont(screen))) {
		    fntId = fWBold;
		    cgsId = gcWBold;
		} else {
		    fntId = fWide;
		    cgsId = gcWide;
		}
	    } else if ((flags & BOLDATTR(screen)) != 0
		       && okFont(BoldFont(screen))
		       && useBoldFont) {
@


1.21
log
@Update to xterm 293. Tested by naddy@@ ajacoutot@@
@
text
@d1 1
a1 1
/* $XTermId: util.c,v 1.601 2013/05/09 01:00:59 tom Exp $ */
d76 2
d109 1
a109 1
DamagedCells(TScreen * screen, unsigned n, int *klp, int *krp, int row, int col)
d162 1
a162 1
DamagedCurCells(TScreen * screen, unsigned n, int *klp, int *krp)
d690 2
d1019 1
a1019 1
WriteText(XtermWidget xw, IChar * str, Cardinal len)
d1492 6
d1536 5
d1767 5
d2052 3
d2058 4
d2063 1
a2063 4
	copy_area(xw, src_x, src_y,
		  (unsigned) ((right + 1 - left) * FontWidth(screen)),
		  (unsigned) (nlines * FontHeight(screen)),
		  src_x, src_y - amount * FontHeight(screen));
d2105 1
a2105 1
	TRACE(("HandleExposure - icon"));
d2108 1
a2108 1
	TRACE(("HandleExposure - normal"));
d2414 1
a2414 1
    return (Boolean) ! x_strcasecmp(name, XtDefaultForeground);
d2420 1
a2420 1
    return (Boolean) ! x_strcasecmp(name, XtDefaultBackground);
d2567 1
a2567 1
    xw->misc.re_verse = (Boolean) ! xw->misc.re_verse;
d2608 1
a2608 1
recolor_cursor(TScreen * screen,
d2715 1
a2715 1
		   IChar * text,
d2999 1
a2999 1
xtermSetClipRectangles(Display * dpy,
d3088 1
a3088 1
		     IChar * text,
d3127 2
a3128 2
	      int x,
	      int y,
d3130 1
a3130 1
	      IChar * text,
d3134 1
d3449 4
a3452 1
	return x + (int) len *FontWidth(screen);
d3502 1
d3844 2
a3845 1
    return x + (int) real_length *FontWidth(screen);
d4146 1
a4146 1
getXtermCell(TScreen * screen, int row, int col)
d4159 1
a4159 1
putXtermCell(TScreen * screen, int row, int col, int ch)
d4179 1
a4179 1
addXtermCombining(TScreen * screen, int row, int col, unsigned ch)
d4198 1
a4198 1
getXtermCombining(TScreen * screen, int row, int col, int off)
@


1.20
log
@Update to xterm 291. Tested by many.
@
text
@d1 1
a1 1
/* $XTermId: util.c,v 1.600 2013/02/04 00:46:58 tom Exp $ */
a4119 1
    assert(ld && (col < (int) ld->lineSize));
a4132 1
    assert(ld && (col < (int) ld->lineSize));
@


1.19
log
@Update to xterm 287. tested by mpi@@ and krw@@.
@
text
@d1 1
a1 1
/* $XTermId: util.c,v 1.598 2012/10/05 00:26:28 tom Exp $ */
d4 1
a4 1
 * Copyright 1999-2011,2012 by Thomas E. Dickey
d3544 7
a3550 17
		if (ucs_workaround(xw, ch, flags, gc,
				   x, y,
				   chrset, on_wide)) {
		    /*
		     * if true, we drew at least one cell whether or not it is
		     * printable
		     */
		    if (ch_width <= 0)
			ch_width = 1;
		} else
#endif
		{
		    if (ch_width <= 0)
			ch_width = 1;
		    xtermDrawBoxChar(xw, ch, flags, gc,
				     x, y,
				     ch_width);
d3552 3
@


1.18
log
@Update to xterm 279. Tested by krw@@, mpi@@, shadchin@@.
@
text
@d1 1
a1 1
/* $XTermId: util.c,v 1.587 2012/05/10 11:06:37 tom Exp $ */
d1140 1
a1140 1
    screen->do_wrap = False;
d1230 1
a1230 1
    screen->do_wrap = False;
d1332 1
a1332 1
    screen->do_wrap = False;
d1381 1
a1381 1
			   screen->cur_row,
d1415 1
a1415 1
    screen->do_wrap = False;
d1450 1
a1450 1
			   screen->cur_row,
d1608 1
a1608 1
    screen->do_wrap = False;
d1614 1
a1614 1
			   row,
d1697 1
a1697 1
    screen->do_wrap = False;
d1748 1
a1748 1
    screen->do_wrap = False;
d1862 55
d1920 3
d1957 1
d1990 1
a1990 1
		  VWindow(screen), VWindow(screen),
d2171 8
d2184 1
d2365 6
d2372 1
d2855 1
a2855 1
	    int width = my_wcwidth((int) ch);
d2964 1
a2964 1
	    XFillRectangle(screen->display, VWindow(screen),
d2985 1
a2985 1
    Drawable draw = VWindow(screen);
d3244 1
a3244 1
	    Drawable draw = VWindow(screen);
d3419 1
a3419 1
	    XDrawLine(screen->display, VWindow(screen), gc,
d3508 1
a3508 1
	    ch_width = my_wcwidth((int) ch);
d3607 1
d3620 1
a3620 1
		&& ((on_wide || my_wcwidth((int) ch) > 1)
d3667 41
d3719 1
a3719 2
	    if (needWide
		&& (okFont(NormalWFont(screen)) || okFont(BoldWFont(screen)))) {
d3729 2
a3730 1
		       && okFont(BoldFont(screen))) {
d3763 1
a3763 1
			  VWindow(screen), gc,
d3768 1
a3768 1
			       VWindow(screen), gc,
d3773 1
a3773 1
	if ((flags & BOLDATTR(screen)) && screen->enbolden) {
d3775 1
a3775 1
	    XDrawString16(screen->display, VWindow(screen), gc,
d3800 1
a3800 1
	    XDrawString(screen->display, VWindow(screen), gc,
d3803 1
a3803 1
	    XDrawImageString(screen->display, VWindow(screen), gc,
d3809 1
a3809 1
	    XDrawString(screen->display, VWindow(screen), gc,
d3818 1
a3818 1
	XDrawLine(screen->display, VWindow(screen), gc,
d4098 8
d4108 1
a4108 1
		   CursorY(screen, top),
d4112 1
a4183 45
#ifdef HAVE_CONFIG_H
#ifdef USE_MY_MEMMOVE
void *
my_memmove(void *s1, void *s2, size_t n)
{
    if (n != 0) {
	char *p1 = (char *) s1;
	char *p2 = (char *) s2;

	if ((p1 + n > p2) && (p2 + n > p1)) {
	    static char *bfr;
	    static size_t length;
	    size_t j;
	    if (length < n) {
		length = (n * 3) / 2;
		bfr = ((bfr != 0)
		       ? TypeRealloc(char, length, bfr)
		       : TypeMallocN(char, length));
		if (bfr == NULL)
		    SysError(ERROR_MMALLOC);
	    }
	    for (j = 0; j < n; j++)
		bfr[j] = p2[j];
	    p2 = bfr;
	}
	while (n-- != 0)
	    p1[n] = p2[n];
    }
    return s1;
}
#endif /* USE_MY_MEMMOVE */

#ifndef HAVE_STRERROR
char *
my_strerror(int n)
{
    extern char *sys_errlist[];
    extern int sys_nerr;
    if (n > 0 && n < sys_nerr)
	return sys_errlist[n];
    return "?";
}
#endif
#endif

d4338 1
a4338 1
	int code = (int) dec2ucs((unsigned) n);
@


1.17
log
@Update to xterm 278. Tested by mpi@@, shadchin@@
@
text
@d1 1
a1 1
/* $XTermId: util.c,v 1.554 2011/12/30 21:56:42 tom Exp $ */
d4 1
a4 1
 * Copyright 1999-2010,2011 by Thomas E. Dickey
d90 3
a92 1
			       int amount);
d180 3
d186 6
d193 3
d197 4
a200 4
	scrollheight = screen->bot_marg - screen->top_marg -
	    refreshheight + 1;
	if ((refreshtop = screen->bot_marg - refreshheight + 1 + shift) >
	    (i = screen->max_row - screen->scroll_amt + 1))
d202 7
d211 1
d214 2
a215 1
	    if ((scrollheight += shift) > i)
d217 11
a227 6
	    if ((i = screen->bot_marg - bot) > 0 &&
		(refreshheight -= i) < screen->scroll_amt)
		refreshheight = screen->scroll_amt;
	    if ((i = screen->savedlines) < screen->savelines) {
		if ((i += screen->scroll_amt) >
		    screen->savelines)
d229 1
d235 3
a237 3
	    if ((i = bot - (screen->bot_marg - screen->refresh_amt +
			    screen->scroll_amt)) > 0) {
		if (bot < screen->bot_marg)
d239 1
d243 2
a244 2
		if ((i = screen->top_marg + screen->scroll_amt -
		     1 - bot) > 0) {
d251 3
d255 1
a255 2
	scrollheight = screen->bot_marg - screen->top_marg -
	    refreshheight + 1;
d258 2
a259 1
	if ((i = screen->bot_marg - bot) > 0)
d261 3
a263 1
	if ((i = screen->top_marg + refreshheight - 1 - bot) > 0)
d265 1
d267 7
a273 2
    scrolling_copy_area(xw, scrolltop + screen->scroll_amt,
			scrollheight, screen->scroll_amt);
d277 1
d280 11
a290 6
			   (int) refreshtop * FontHeight(screen) + screen->border,
			   (int) OriginX(screen),
			   (unsigned) (refreshheight * FontHeight(screen)),
			   (unsigned) Width(screen));
	ScrnRefresh(xw, refreshtop, 0, refreshheight,
		    MaxCols(screen), False);
d300 1
a300 1
int
d306 1
a306 1
    int result;
d309 1
a309 1
	result = 0;
d315 1
a315 1
	    result = 1;
d325 1
a325 1
	    result = 1;
d363 2
a364 1
 * If the selection is not contained within the scrolled region, clear it.
d374 2
d389 13
a401 2
    if (screen->startH.row >= lo_row
	&& screen->startH.row - amount < lo_row) {
d423 1
d426 1
d495 40
d544 1
a544 1
    int i = screen->bot_marg - screen->top_marg + 1;
d551 2
d565 1
d650 6
a655 1
	    scrolling_copy_area(xw, scrolltop + amount, scrollheight, amount);
d659 5
a663 4
				   (int) refreshtop * FontHeight(screen) + screen->border,
				   (int) OriginX(screen),
				   (unsigned) (refreshheight * FontHeight(screen)),
				   (unsigned) Width(screen));
d671 3
a673 1
	if (scroll_all_lines) {
d689 6
a694 2
	ScrnRefresh(xw, refreshtop, 0, refreshheight,
		    MaxCols(screen), False);
d719 1
d722 2
a723 1
	if (screen->cur_col) {
d725 2
a726 2
	} else {
	    xtermColScroll(xw, 1, False, 0);
d729 5
a733 4
	if (screen->cur_col < screen->max_col) {
	    CursorForward(screen, 1);
	} else {
	    xtermColScroll(xw, 1, True, 0);
d744 2
d747 18
a764 4
	TScreen *screen = TScreenOf(xw);
	int save_row = screen->cur_row;
	int save_col = screen->cur_col;
	int row;
d766 11
a776 10
	screen->cur_col = at_col;
	if (toLeft) {
	    for (row = 0; row <= screen->max_row; row++) {
		screen->cur_row = row;
		ScrnDeleteChar(xw, (unsigned) amount);
	    }
	} else {
	    for (row = 0; row <= screen->max_row; row++) {
		screen->cur_row = row;
		ScrnInsertChar(xw, (unsigned) amount);
d778 3
a781 3
	screen->cur_row = save_row;
	screen->cur_col = save_col;
	xtermRepaint(xw);
d802 2
d835 1
a835 2
	scrollheight = screen->bot_marg - screen->top_marg -
	    refreshheight + 1;
d851 6
a856 1
	scrolling_copy_area(xw, scrolltop - amount, scrollheight, -amount);
d860 5
a864 4
			       (int) refreshtop * FontHeight(screen) + screen->border,
			       (int) OriginX(screen),
			       (unsigned) (refreshheight * FontHeight(screen)),
			       (unsigned) Width(screen));
d868 9
a876 5
	ScrnInsertLine(xw,
		       screen->visbuf,
		       screen->bot_marg,
		       screen->top_marg,
		       (unsigned) amount);
d882 128
d1037 1
a1037 1
	&& ScrnIsLineInSelection(screen, INX2ROW(screen, screen->cur_row))) {
d1096 2
a1097 22
    CursorForward(screen, (int) cells);
#if OPT_ZICONBEEP
    /* Flag icon name with "***"  on window output when iconified.
     */
    if (resource.zIconBeep && mapstate == IsUnmapped && !screen->zIconBeep_flagged) {
	static char *icon_name;
	static Arg args[] =
	{
	    {XtNiconName, (XtArgVal) & icon_name}
	};

	icon_name = NULL;
	XtGetValues(toplevel, args, XtNumber(args));

	if (icon_name != NULL) {
	    screen->zIconBeep_flagged = True;
	    ChangeIconName(xw, icon_name);
	}
	xtermBell(xw, XkbBI_Info, 0);
    }
    mapstate = -1;
#endif /* OPT_ZICONBEEP */
d1117 2
d1120 3
a1122 1
    if (!ScrnIsLineInMargins(screen, screen->cur_row))
d1131 6
a1136 6
	&& ScrnAreLinesInSelection(screen,
				   INX2ROW(screen, screen->top_marg),
				   INX2ROW(screen, screen->cur_row - 1))
	&& ScrnAreLinesInSelection(screen,
				   INX2ROW(screen, screen->cur_row),
				   INX2ROW(screen, screen->bot_marg))) {
d1166 1
a1166 1
	vertical_copy_area(xw, scrolltop - n, scrollheight, -n);
d1169 5
a1173 4
			       (int) refreshtop * FontHeight(screen) + screen->border,
			       (int) OriginX(screen),
			       (unsigned) (refreshheight * FontHeight(screen)),
			       (unsigned) Width(screen));
d1177 9
a1185 5
	ScrnInsertLine(xw,
		       screen->visbuf,
		       screen->bot_marg,
		       screen->cur_row,
		       (unsigned) n);
d1204 2
d1210 3
a1212 1
    if (!ScrnIsLineInMargins(screen, screen->cur_row))
d1224 3
a1226 3
	&& ScrnAreLinesInSelection(screen,
				   INX2ROW(screen, screen->cur_row),
				   INX2ROW(screen, screen->cur_row + n - 1))) {
d1245 3
a1247 1
	if (scroll_all_lines)
d1253 1
a1253 1
	else
d1259 1
d1290 1
a1290 1
	vertical_copy_area(xw, scrolltop + n, scrollheight, n);
d1301 5
a1305 4
			       (int) refreshtop * FontHeight(screen) + screen->border,
			       (int) OriginX(screen),
			       (unsigned) (refreshheight * FontHeight(screen)),
			       (unsigned) Width(screen));
d1320 2
d1329 1
a1329 1
	&& ScrnIsLineInSelection(screen, row)) {
d1334 1
a1334 2
    assert(screen->cur_col <= screen->max_col);
    limit = (unsigned) (MaxCols(screen) - screen->cur_col);
d1339 5
a1343 4
    assert(n != 0);
    if (AddToVisible(xw)
	&& (ld = getLineData(screen, screen->cur_row)) != 0) {
	int col = MaxCols(screen) - (int) n;
d1381 9
a1389 4
			   CursorY(screen, screen->cur_row),
			   LineCursorX(screen, ld, screen->cur_col),
			   (unsigned) FontHeight(screen),
			   n * (unsigned) LineFontWidth(screen, ld));
a1390 2
    /* adjust screen->buf */
    ScrnInsertChar(xw, n);
d1403 2
d1412 1
a1412 1
	&& ScrnIsLineInSelection(screen, row)) {
d1417 1
a1417 2
    assert(screen->cur_col <= screen->max_col);
    limit = (unsigned) (MaxCols(screen) - screen->cur_col);
d1422 5
a1426 4
    assert(n != 0);
    if (AddToVisible(xw)
	&& (ld = getLineData(screen, screen->cur_row)) != 0) {
	int col = MaxCols(screen) - (int) n;
d1450 5
a1454 4
			   CursorY(screen, screen->cur_row),
			   LineCursorX(screen, ld, col),
			   (unsigned) FontHeight(screen),
			   n * (unsigned) LineFontWidth(screen, ld));
d1489 5
a1493 4
				   top * FontHeight(screen) + screen->border,
				   OriginX(screen),
				   (unsigned) (height * FontHeight(screen)),
				   (unsigned) (Width(screen)));
d1527 5
a1531 5
				   top * FontHeight(screen) + screen->border,
				   OriginX(screen),
				   (unsigned) ((screen->max_row - top + 1)
					       * FontHeight(screen)),
				   (unsigned) (Width(screen)));
d1555 1
a1555 1
	&& ScrnIsLineInSelection(screen, row)) {
d1614 5
a1618 4
			   CursorY(screen, row),
			   LineCursorX(screen, ld, col),
			   (unsigned) FontHeight(screen),
			   len * (unsigned) LineFontWidth(screen, ld));
d1753 5
a1757 5
			   top * FontHeight(screen) + screen->border,
			   OriginX(screen),
			   (unsigned) ((screen->max_row - top + 1)
				       * FontHeight(screen)),
			   (unsigned) Width(screen));
d1967 3
a1969 1
		   int amount)	/* number of lines to move up (neg=down) */
d1974 1
a1974 1
	int src_x = OriginX(screen);
d1978 1
a1978 1
		  (unsigned) Width(screen),
d1981 1
d2005 1
a2005 1
	vertical_copy_area(xw, firstline, nlines, amount);
d3966 2
a3967 1
		   unsigned width)
d3971 1
a3971 1
    TRACE(("ClearCurBackground(%d,%d,%d,%d) %d\n",
d3974 4
d3982 5
a3986 1
		   left, top, width, height, False);
d4048 7
@


1.16
log
@Update to xterm 276. Tested by ajacoutot@@, krw@@, naddy@@, shadchin@@.
@
text
@d1 1
a1 1
/* $XTermId: util.c,v 1.548 2011/10/09 22:10:45 tom Exp $ */
d116 1
a116 1
	if (kr >= ld->lineSize) {
d122 1
a122 1
	    assert(kl < ld->lineSize);
d584 64
d3862 2
a3863 2
	    fprintf(stderr, "Conflicting keyboard type option (%u/%u)\n",
		    xw->keyboard.type, type);
d3933 2
a3934 3
	    fprintf(stderr,
		    "KeyboardType resource \"%s\" not found\n",
		    rp->keyboardType);
d4076 1
a4076 1
	fprintf(stderr, "Unrecognized keyword: %s\n", value);
@


1.15
log
@Update to xterm-275. Tested by jasper@@.
@
text
@d1 1
a1 1
/* $XTermId: util.c,v 1.546 2011/08/31 00:10:07 tom Exp $ */
d2610 3
d2614 1
a2614 1
		int clip_y = py - FontHeight(screen) + FontDescent(screen); \
d2617 1
a2617 1
		clip.height = (unsigned short) (FontHeight(screen)); \
d4018 13
@


1.14
log
@Update to xterm version 269.
Tested and ok ajacoutot@@, jasper@@, krw@@, shadchin@@
@
text
@d1 1
a1 1
/* $XTermId: util.c,v 1.545 2011/02/17 00:28:45 tom Exp $ */
d3166 3
@


1.13
log
@Update to xterm version 264, Tested at least by krw@@, jasper@@, ajacoutot@@.
@
text
@d1 1
a1 1
/* $XTermId: util.c,v 1.541 2010/10/11 00:32:28 tom Exp $ */
d4 1
a4 1
 * Copyright 1999-2009,2010 by Thomas E. Dickey
d1253 1
a1253 1
	if (len <= 0) {
d1521 1
a1521 1
    while (1) {
d1725 1
a1725 1
    XSetWindowBackground(screen->display, VShellWindow, c);
d3406 1
a3406 1
    if (!XGetWMNormalHints(screen->display, XtWindow(SHELL_OF(xw)),
d3972 42
@


1.12
log
@Update to xterm 262.

tested by ajacoutot@@, jasper@@ and krw@@.
@
text
@d1 1
a1 1
/* $XTermId: util.c,v 1.539 2010/08/29 22:49:16 tom Exp $ */
d1346 3
d1631 9
@


1.11
log
@Update to xterm 261. Tested by krw@@, jcs@@.
@
text
@d1 1
a1 1
/* $XTermId: util.c,v 1.538 2010/06/15 08:17:36 tom Exp $ */
d1819 6
a1824 3
	T_COLOR(screen, TEXT_CURSOR) = COLOR_VALUE(pNew, TEXT_FG);
	TRACE(("... TEXT_CURSOR: %#lx\n", T_COLOR(screen, TEXT_CURSOR)));
	repaint = screen->Vshow;
d1855 6
a1860 3
	T_COLOR(screen, HIGHLIGHT_BG) = COLOR_VALUE(pNew, HIGHLIGHT_BG);
	TRACE(("... HIGHLIGHT_BG: %#lx\n", T_COLOR(screen, HIGHLIGHT_BG)));
	repaint = screen->Vshow;
d1863 6
a1868 3
	T_COLOR(screen, HIGHLIGHT_FG) = COLOR_VALUE(pNew, HIGHLIGHT_FG);
	TRACE(("... HIGHLIGHT_FG: %#lx\n", T_COLOR(screen, HIGHLIGHT_FG)));
	repaint = screen->Vshow;
d1909 3
a1911 1
	set_cursor_gcs(xw);
@


1.10
log
@Update to xterm 258. lightly tested by krw@@, thanks.
@
text
@d1 1
a1 1
/* $XTermId: util.c,v 1.534 2010/04/18 17:06:44 tom Exp $ */
d706 1
a706 1
	&& (ld = getLineData(screen, screen->cur_row)) != 0) {
d736 1
a736 3
	} else
#endif
	{
d740 1
d2220 5
d2270 1
a2270 3
#if OPT_ISO_COLORS
		&& !screen->colorBDMode
#endif
d2690 1
a2690 1
	    if (!xw->misc.render_font || IsIconWin(screen, WhichVWin(screen)))
d2810 1
a2810 3
#if OPT_ISO_COLORS
		&& !screen->colorBDMode
#endif
d3528 2
a3529 2
 * Extract the foreground-color index from a one-byte color pair.  If we've got
 * BOLD or UNDERLINE color-mode active, those will be used.
d3544 1
a3544 1
 * Extract the background-color index from a one-byte color pair.
@


1.9
log
@Update to xterm-255. Tested by stsp@@, oga@@.
@
text
@d1 1
a1 1
/* $XTermId: util.c,v 1.523 2010/01/03 23:56:24 tom Exp $ */
d93 1
d463 8
a470 18
    if (ScrnHaveSelection(screen))
	adjustHiliteOnFwdScroll(xw, amount, scroll_all_lines);

    if (screen->jumpscroll) {
	if (screen->scroll_amt > 0) {
	    if (!screen->fastscroll) {
		if (screen->refresh_amt + amount > i)
		    FlushScroll(xw);
	    }
	    screen->scroll_amt += amount;
	    screen->refresh_amt += amount;
	} else {
	    if (!screen->fastscroll) {
		if (screen->scroll_amt < 0)
		    FlushScroll(xw);
	    }
	    screen->scroll_amt = amount;
	    screen->refresh_amt = amount;
d472 2
a473 7
	refreshheight = 0;
    } else {
	ScrollSelection(screen, -(amount), False);
	if (amount == i) {
	    ClearScreen(xw);
	    screen->cursor_busy -= 1;
	    return;
d475 5
d481 52
a532 26
	shift = INX2ROW(screen, 0);
	bot = screen->max_row - shift;
	scrollheight = i - amount;
	refreshheight = amount;

	if ((refreshtop = screen->bot_marg - refreshheight + 1 + shift) >
	    (i = screen->max_row - refreshheight + 1))
	    refreshtop = i;

	if (scroll_all_lines) {
	    scrolltop = 0;
	    if ((scrollheight += shift) > i)
		scrollheight = i;
	    if ((i = screen->savedlines) < screen->savelines) {
		if ((i += amount) > screen->savelines)
		    i = screen->savelines;
		screen->savedlines = i;
		ScrollBarDrawThumb(screen->scrollWidget);
	    }
	} else {
	    scrolltop = screen->top_marg + shift;
	    if ((i = screen->bot_marg - bot) > 0) {
		scrollheight -= i;
		if ((i = screen->top_marg + amount - 1 - bot) >= 0) {
		    refreshtop += i;
		    refreshheight -= i;
a534 1
	}
d536 7
a542 7
	if (screen->multiscroll && amount == 1 &&
	    screen->topline == 0 && screen->top_marg == 0 &&
	    screen->bot_marg == screen->max_row) {
	    if (screen->incopy < 0 && screen->scrolls == 0)
		CopyWait(xw);
	    screen->scrolls++;
	}
d544 1
a544 1
	scrolling_copy_area(xw, scrolltop + amount, scrollheight, amount);
d546 9
a554 8
	if (refreshheight > 0) {
	    ClearCurBackground(xw,
			       (int) refreshtop * FontHeight(screen) + screen->border,
			       (int) OriginX(screen),
			       (unsigned) (refreshheight * FontHeight(screen)),
			       (unsigned) Width(screen));
	    if (refreshheight > shift)
		refreshheight = shift;
d685 2
a686 1
    TRACE(("WriteText (%2d,%2d) %3d:%s\n",
d733 1
d736 3
a738 1
	} else {
d2266 1
d2268 1
d3395 1
a3395 1
updatedXtermGC(XtermWidget xw, unsigned flags, CellColor fg_bg, Bool hilite)
d3532 1
a3532 1
extract_fg(XtermWidget xw, CellColor color, unsigned flags)
d3548 1
a3548 1
extract_bg(XtermWidget xw, CellColor color, unsigned flags)
d3913 1
a3913 1
decode_wcwidth(int mode, int samplesize, int samplepass)
d3915 4
d3922 2
a3923 1
	if (xtermEnvUTF8() && systemWcwidthOk(samplesize, samplepass)) {
a3928 3
#else
	(void) samplesize;
	(void) samplepass;
d3939 7
@


1.8
log
@Update to xterm 250
@
text
@d1 1
a1 1
/* $XTermId: util.c,v 1.504 2009/10/11 20:23:19 tom Exp $ */
d4 1
a4 1
 * Copyright 1999-2008,2009 by Thomas E. Dickey
d107 1
a107 2
    int kl = col;
    int kr = col + (int) n;
d109 21
a129 4
    if (ld->charData[kl] == HIDDEN_CHAR) {
	while (kl > 0) {
	    if (ld->charData[--kl] != HIDDEN_CHAR) {
		break;
d131 12
a142 9
	}
    } else {
	kl = col + 1;
    }
    if (ld->charData[kr] == HIDDEN_CHAR) {
	while (kr < screen->max_col) {
	    if (ld->charData[++kr] != HIDDEN_CHAR) {
		--kr;
		break;
d144 6
a150 2
    } else {
	kr = col - 1;
d152 2
a153 5
    if (klp)
	*klp = kl;
    if (krp)
	*krp = kr;
    return (kr >= kl);
d169 1
a169 1
    TScreen *screen = &(xw->screen);
d255 1
a255 1
    TScreen *screen = &(xw->screen);
d301 1
a301 1
    TScreen *screen = &(xw->screen);
d320 1
a320 1
    TScreen *screen = &(xw->screen);
d380 1
a380 1
    TScreen *screen = &(xw->screen);
d439 1
a439 1
    TScreen *screen = &(xw->screen);
d575 1
a575 1
    TScreen *screen = &(xw->screen);
d659 1
a659 1
    TScreen *screen = &(xw->screen);
d661 1
d715 6
a720 1
	checkVeryBoldColors(test, xw->cur_foreground);
d753 1
a753 1
	xtermBell(xw, resource.zIconBeep, XkbBI_Info);
d768 1
a768 1
    TScreen *screen = &(xw->screen);
d846 1
a846 1
    TScreen *screen = &(xw->screen);
d958 1
a958 1
    TScreen *screen = &(xw->screen);
d1036 1
a1036 1
    TScreen *screen = &(xw->screen);
d1102 1
a1102 1
    TScreen *screen = &(xw->screen);
d1141 1
a1141 1
    TScreen *screen = &(xw->screen);
d1178 1
a1178 1
    TScreen *screen = &(xw->screen);
d1233 1
a1233 1
	if (len <= 0)
d1235 1
d1263 1
a1263 1
    TScreen *screen = &(xw->screen);
d1285 1
a1285 1
    TScreen *screen = &(xw->screen);
d1335 1
a1335 1
    TScreen *screen = &(xw->screen);
d1337 1
a1338 1

d1360 1
a1360 1
    TScreen *screen = &(xw->screen);
d1370 1
a1370 1
    TScreen *screen = &(xw->screen);
d1399 1
a1399 1
    TScreen *screen = &(xw->screen);
d1431 1
a1431 1
    TScreen *screen = &(xw->screen);
d1494 1
a1494 1
    TScreen *screen = &(xw->screen);
d1542 1
a1542 1
    TScreen *screen = &(xw->screen);
d1575 1
a1575 1
    TScreen *screen = &(xw->screen);
d1598 1
a1598 1
    TScreen *screen = &(xw->screen);
d1633 1
a1633 1
    TScreen *screen = &(xw->screen);
d1689 1
a1689 1
    TScreen *screen = &(xw->screen);
d1709 1
a1709 1
    TScreen *screen = &(xw->screen);
d1775 1
a1775 1
    TScreen *screen = &xw->screen;
d1788 1
a1788 1
    TScreen *screen = &xw->screen;
d1863 1
a1863 1
	    TekScreen *tekscr = &(tekWidget->screen);
d1900 1
a1900 1
    TScreen *screen = &xw->screen;
d1909 1
a1909 1
    TScreen *screen = &xw->screen;
d2038 1
a2038 1
    TScreen *screen = &xw->screen;
d2081 1
a2081 1
	TekScreen *tekscr = &(tekWidget->screen);
d2161 1
a2161 1
    XQueryColor(xw->screen.display, xw->core.colormap, &color);
d2184 1
a2184 1
	          ? ((xw)->screen.c1_printable ? 1 : 0) \
d2221 1
a2221 1
    TScreen *screen = &(xw->screen);
d2238 1
d2245 1
d2374 1
a2374 1
    TScreen *screen = &(xw->screen);
d2423 1
a2423 1
    TScreen *screen = &(xw->screen);
d2510 1
a2510 1
    TScreen *screen = &(term->screen);
d2595 1
a2595 1
    TScreen *screen = &(xw->screen);
d2633 1
a2633 1
    TScreen *screen = &(xw->screen);
d2777 1
d2785 3
d3055 1
a3055 1
		    && xw->screen.force_box_chars) {
d3324 1
a3324 1
    TScreen *screen = &xw->screen;
d3357 1
a3357 1
    TScreen *screen = &xw->screen;
d3374 1
a3374 1
    TScreen *screen = &(xw->screen);
d3396 3
d3473 1
a3473 1
    TScreen *screen = &(xw->screen);
d3513 1
a3513 1
    if (xw->screen.colorAttrMode
d3515 1
a3515 6
	if (xw->screen.colorULMode && (flags & UNDERLINE))
	    fg = COLOR_UL;
	if (xw->screen.colorBDMode && (flags & BOLD))
	    fg = COLOR_BD;
	if (xw->screen.colorBLMode && (flags & BLINK))
	    fg = COLOR_BL;
d3529 1
a3529 1
    if (xw->screen.colorAttrMode
d3531 1
a3531 1
	if (xw->screen.colorRVMode && (flags & INVERSE))
d3565 1
a3565 1
    TScreen *screen = &(xw->screen);
d3589 4
a3592 1
    return ld->charData[col];
d3603 10
a3612 7
    ld->charData[col] = (CharData) ch;
    if_OPT_WIDE_CHARS(screen, {
	size_t off;
	for_each_combData(off, ld) {
	    ld->combData[off][col] = 0;
	}
    });
@


1.7
log
@Update to xterm 248, fixing several bugs including a regression with
copy-and-paste. Works for martynas@@, ok matthieu@@
@
text
@d1 1
a1 1
/* $XTermId: util.c,v 1.489 2009/09/10 09:22:43 tom Exp $ */
d652 4
d751 1
a751 1
    if (!ScrnIsLineInMargins(screen, INX2ROW(screen, screen->cur_row)))
d760 6
a765 1
	&& ScrnAreLinesInSelection(screen, screen->top_marg, screen->bot_marg)) {
d832 1
a832 1
    if (!ScrnIsLineInMargins(screen, INX2ROW(screen, screen->cur_row)))
d840 3
d844 3
a846 1
	&& ScrnAreLinesInSelection(screen, screen->top_marg, screen->bot_marg)) {
a850 2
    if (n > (i = screen->bot_marg - screen->cur_row + 1))
	n = i;
d862 18
a880 1

d908 8
a923 15
    /* adjust screen->buf */
    if (n > 0) {
	if (scroll_all_lines)
	    ScrnDeleteLine(xw,
			   screen->saveBuf_index,
			   screen->bot_marg + screen->savelines,
			   0,
			   (unsigned) n);
	else
	    ScrnDeleteLine(xw,
			   screen->visbuf,
			   screen->bot_marg,
			   screen->cur_row,
			   (unsigned) n);
    }
d1094 1
a1094 1
		height = screen->max_row;
d1106 1
a1106 2
    if (INX2ROW(screen, screen->cur_row) <= screen->max_row)
	ClearLeft(xw);
d2795 4
a2798 4
		     * in cells 1-31.  Check for this, and attempt to fill in
		     * from real line-drawing character in the font at the
		     * Unicode position.  Failing that, use our own
		     * box-characters.
d2800 6
a2805 8
		    if (xtermXftMissing(xw, font, ch)) {
			if (screen->force_box_chars
			    || xtermXftMissing(xw, font, dec2ucs(ch))) {
			    missing = 1;
			} else {
			    ch = dec2ucs(ch);
			    replace = True;
			}
d2807 1
a2807 1
		} else if (ch > 256) {
a2930 2
	xtermFillCells(xw, flags, gc, x, y, len);

d2932 1
d2934 6
a2940 5

		width = 1;
		if_OPT_WIDE_CHARS(screen, {
		    width = my_wcwidth((wchar_t) (*text)) * FontWidth(screen);
		});
d2957 2
d2960 1
@


1.6
log
@update to xterm 246. Has been in snapshots for some time.
@
text
@d1 1
a1 1
/* $XTermId: util.c,v 1.486 2009/08/15 00:40:38 tom Exp $ */
d106 1
d110 1
a110 1
    if (XTERM_CELL(row, kl) == HIDDEN_CHAR) {
d112 1
a112 1
	    if (XTERM_CELL(row, --kl) != HIDDEN_CHAR) {
d119 1
a119 1
    if (XTERM_CELL(row, kr) == HIDDEN_CHAR) {
d121 1
a121 1
	    if (XTERM_CELL(row, ++kr) != HIDDEN_CHAR) {
d3014 10
a3023 3
		if (!ucs_workaround(xw, ch, flags, gc,
				    x, y,
				    chrset, on_wide))
d3026 2
a3556 8
unsigned
getXtermCellComb(TScreen * screen, int row, int col, unsigned off)
{
    LineData *ld = getLineData(screen, row);

    return (unsigned) ld->combData[off][col];
}

@


1.5
log
@Update to xterm 243. tested by naddy@@.

Patch #243 - 2009/3/28

* revert change to default for allowTcapOps (request by Bram Moolenaar).
* reallocate result returned by xtermEnvLocale() to avoid reference to
freed memory after handling menuLocale resource.
* fix an old (X11R5) bug in tek4014 for switching fontsizes.
* add resource defaultString to make configurable the use of "#" when
pastes of UTF-8 text fail due to limitations in the current locale settings.
* make the set of selection target Atom's configurable by two new
resources eightBitSelectTypes and utf8SelectTypes, e.g., to use the TEXT
Atom in preference to UTF8_STRING (discussion with Stanislav Sedov
regarding koi8rxterm and the FreeBSD port).
* modify handling of TARGETS Atom by making it return exactly the set of
targets as those which xterm is currently providing.
* set MANPAGER and PAGER explicitly to /bin/cat in minstall.sh to work
around /etc/man.conf's with those variables already set (report by
Mar'yasin Semion).
* improve error-checking of tcap-query parser.
* add check for keyboard tcap), which ensures that terminal descriptions
containing the same string for shifted/unshifted keys will be seen by
tcap-query as only the unshifted key. (This would only happen with an
incorrect terminal description).
* fix conversion for input event-state to modifier-parameter which made
tcap-query feature not work with tcapFunctionKeys (keyboard type tcap).
* add "DEF_ALLOW_XXX" definitions to main.h to allow overriding the
default compiled-in values for "allowxxx" resources.
* remove check on bell-percentage added in patch #242, which disallowed
zero/negative values (Redhat Bugzilla #487829).
@
text
@d1 1
a1 1
/* $XTermId: util.c,v 1.421 2009/03/16 00:37:25 tom Exp $ */
d166 2
a167 1
	if (screen->scrollWidget && !screen->alternate
d306 1
a306 1
	    screen->alternate ? "alternate" : "normal",
d364 1
a364 1
	    screen->alternate ? "alternate" : "normal",
d427 1
a427 1
					  && !screen->alternate
d446 4
a449 2
	    if (screen->refresh_amt + amount > i)
		FlushScroll(xw);
d453 4
a456 2
	    if (screen->scroll_amt < 0)
		FlushScroll(xw);
d523 1
a523 1
			   screen->allbuf,
d526 1
a526 2
			   (unsigned) amount,
			   (unsigned) MaxCols(screen));
d532 1
a532 2
			   (unsigned) amount,
			   (unsigned) MaxCols(screen));
d625 1
a625 2
		       (unsigned) amount,
		       (unsigned) MaxCols(screen));
d639 1
a639 1
    ScrnPtr temp_str = 0;
d642 1
a642 1
    unsigned fg_bg = makeColorPair(xw->cur_foreground, xw->cur_background);
d646 1
a646 1
    TRACE(("WriteText (%2d,%2d) (%d) %3d:%s\n",
a648 1
	   curXtermChrSet(xw, screen->cur_row),
d661 2
a662 1
    if (AddToVisible(xw)) {
d683 2
a684 1
	TRACE(("WriteText calling drawXtermText (%d,%d)\n",
d694 5
a698 5
	drawXtermIChars(xw, test & DRAWX_MASK, currentGC,
			CurCursorX(screen, screen->cur_row, screen->cur_col),
			CursorY(screen, screen->cur_row),
			curXtermChrSet(xw, screen->cur_row),
			str, len, 0);
a725 2
    if (temp_str != 0)
	free(temp_str);
d769 4
a772 2
	} else if (screen->scroll_amt)
	    FlushScroll(xw);
d799 1
a799 2
		       (unsigned) n,
		       (unsigned) MaxCols(screen));
d818 3
d844 4
a847 2
	} else if (screen->scroll_amt)
	    FlushScroll(xw);
d858 1
a858 1
	if (screen->scrollWidget && !screen->alternate && screen->cur_row == 0) {
d888 1
a888 3
	if (screen->scrollWidget
	    && !screen->alternate
	    && screen->cur_row == 0)
d890 1
a890 1
			   screen->allbuf,
d893 1
a893 2
			   (unsigned) n,
			   (unsigned) MaxCols(screen));
d899 1
a899 2
			   (unsigned) n,
			   (unsigned) MaxCols(screen));
d910 1
d932 2
a933 1
    if (AddToVisible(xw)) {
d956 1
a956 1
	if (CSET_DOUBLE(SCRN_BUF_CSETS(screen, screen->cur_row)[0])) {
d973 1
a973 1
			   CurCursorX(screen, screen->cur_row, screen->cur_col),
d975 1
a975 1
			   n * (unsigned) CurFontWidth(screen, screen->cur_row));
d988 1
d1010 2
a1011 1
    if (AddToVisible(xw)) {
d1026 1
a1026 1
	if (CSET_DOUBLE(SCRN_BUF_CSETS(screen, screen->cur_row)[0])) {
d1037 1
a1037 1
			   CurCursorX(screen, screen->cur_row, col),
d1039 1
a1039 1
			   n * (unsigned) CurFontWidth(screen, screen->cur_row));
d1131 1
d1153 1
a1153 1
	Char *attrs = SCRN_BUF_ATTRS(screen, row) + col;
d1165 1
a1165 1
		    if (n != 0)
d1167 1
d1169 1
a1169 1
			   && (attrs[n] & PROTECTED))
d1171 1
d1194 3
a1196 1
    if (AddToVisible(xw)) {
d1199 1
a1199 1
			   CurCursorX(screen, row, col),
d1201 1
a1201 1
			   len * (unsigned) CurFontWidth(screen, row));
d1237 1
d1251 1
d1276 1
a1276 1
    ScrnClrWrapped(screen, screen->cur_row);
d1354 1
a1354 1
	&& saved_mode != mode)
d1356 1
d1527 5
a1531 2
    int src_x = CurCursorX(screen, screen->cur_row, firstchar);
    int src_y = CursorY(screen, screen->cur_row);
d1533 5
a1537 4
    copy_area(xw, src_x, src_y,
	      (unsigned) (nchars * CurFontWidth(screen, screen->cur_row)),
	      (unsigned) FontHeight(screen),
	      src_x + amount * CurFontWidth(screen, screen->cur_row), src_y);
d1690 1
a1690 1
    leftcol = x0 / CurFontWidth(screen, screen->cur_row);
a2127 4
static int
xtermCellWidth(XtermWidget xw, wchar_t ch)
{
    int result = 0;
a2128 4
    (void) xw;
    if (ch == 0 || ch == 127) {
	result = 0;
    } else if (ch < 256) {
d2130 15
a2144 3
	if (ch >= 128 && ch < 160) {
	    result = (xw->screen.c1_printable ? 1 : 0);
	} else
a2146 6
	    result = 1;		/* 1..31 are line-drawing characters */
    } else {
	result = my_wcwidth(ch);
    }
    return result;
}
d2149 2
d2168 1
a2168 1
		   PAIRED_CHARS(Char * text, Char * text2),
d2177 1
a2177 3
	static XftCharSpec *sbuf;
	static Cardinal slen = 0;

d2190 2
a2191 2
	    && screen->renderWideItal[fontnum]) {
	    wfont = screen->renderWideItal[fontnum];
d2195 2
a2196 2
		&& screen->renderWideBold[fontnum]) {
	    wfont = screen->renderWideBold[fontnum];
d2198 1
a2198 1
	    wfont = screen->renderWideNorm[fontnum];
d2201 2
a2202 5
	if (slen < len) {
	    slen = (len + 1) * 2;
	    sbuf = (XftCharSpec *) XtRealloc((char *) sbuf,
					     slen * sizeof(XftCharSpec));
	}
d2207 1
a2207 4
	    if (text2)
		wc |= (*text2++ << 8);

	    charWidth = xtermCellWidth(xw, (wchar_t) wc);
a2238 1
	PAIRED_CHARS((void) text, (void) text2);
d2240 9
d2252 1
a2252 1
			   x, y, (unsigned char *) text, len);
d2254 1
a2254 1
	ncells = len;
d2259 2
a2260 2
#define xtermXftWidth(xw, flags, color, font, x, y, paired_chars, len) \
   xtermXftDrawString(xw, flags, color, font, x, y, paired_chars, len, False)
a2262 3
#define DrawX(col) x + (col * (font_width))
#define DrawSegment(first,last) (void)drawXtermText(xw, flags|NOTRANSLATION, gc, DrawX(first), y, chrset, PAIRED_CHARS(text+first, text2+first), (unsigned)(last - first), on_wide)

d2327 1
a2327 1
	unsigned eqv = AsciiEquivs(ch);
d2329 1
a2329 1
	if (eqv != ch) {
a2330 5
	    Char text[2];
	    Char text2[2];

	    text[0] = (Char) eqv;
	    text2[0] = 0;
d2339 1
a2339 1
			      PAIRED_CHARS(text, text2),
d2343 1
a2343 1
		text[0] = '?';
d2471 1
a2471 1
		       x, y, rp, nr, order);
d2479 1
a2479 1
	    XSetClipRectangles(dpy, gc, x, y, rp, nr, order)
d2536 1
a2536 1
		     PAIRED_CHARS(Char * text, Char * text2),
d2542 1
a2542 1
			       PAIRED_CHARS(text, text2),
d2550 1
a2550 1
		       PAIRED_CHARS(text, text2),
d2558 9
d2578 1
a2578 1
	      PAIRED_CHARS(Char * text, Char * text2),
a2592 15
    /*
     * It's simpler to pass in a null pointer for text2 in places where
     * we only use codes through 255.  Fix text2 here so we can increment
     * it, etc.
     */
    if (text2 == 0) {
	static Char *dbuf;
	static unsigned dlen;
	if (dlen <= len) {
	    dlen = (len + 1) * 2;
	    dbuf = (Char *) XtRealloc((char *) dbuf, dlen);
	    memset(dbuf, 0, dlen);
	}
	text2 = dbuf;
    }
d2608 1
a2608 1
	       visibleChars(PAIRED_CHARS(text, text2), len)));
d2618 1
a2618 1
		int nr = 1;
d2628 1
a2628 1
		TRACE(("drawing %s\n", visibleChrsetName(chrset)));
d2670 1
a2670 1
				      PAIRED_CHARS(text++, text2++),
d2677 1
a2677 1
				  PAIRED_CHARS(text, text2),
a2683 3
#if OPT_WIDE_CHARS
	    Char *wide = 0;
#endif
d2685 1
a2685 1
	    Char *temp = TypeMallocN(Char, need);
d2687 1
a2687 3
	    if_OPT_WIDE_CHARS(screen, {
		wide = TypeMallocN(Char, need);
	    });
a2688 4
		if_OPT_WIDE_CHARS(screen, {
		    wide[n] = *text2++;
		    wide[n + 1] = 0;
		});
d2697 1
a2697 1
			      PAIRED_CHARS(temp, wide),
a2700 3
	    if_OPT_WIDE_CHARS(screen, {
		free(wide);
	    });
d2727 2
a2728 2
	    && screen->renderFontItal[fontnum]) {
	    font = screen->renderFontItal[fontnum];
d2733 2
a2734 2
		&& screen->renderFontBold[fontnum]) {
	    font = screen->renderFontBold[fontnum];
d2736 1
a2736 1
	    font = screen->renderFontNorm[fontnum];
d2746 1
a2746 1
				   PAIRED_CHARS(text, text2),
d2766 1
a2766 1
		unsigned ch = (unsigned) PACK_PAIR(text, text2, last);
a2767 1
		Char temp[2];
a2768 1
		Char temp2[2];
d2830 1
a2830 2
						  PAIRED_CHARS(text + first,
							       text2 + first),
d2847 1
a2847 4
			temp[0] = LO_BYTE(ch);
#if OPT_WIDE_CHARS
			temp2[0] = HI_BYTE(ch);
#endif
d2854 1
a2854 2
						  PAIRED_CHARS(temp,
							       temp2),
d2863 1
a2863 1
		underline_len +=
d2870 1
a2870 2
					 PAIRED_CHARS(text + first,
						      text2 + first),
d2876 1
a2876 1
	    underline_len +=
d2883 1
a2883 1
				     PAIRED_CHARS(text, text2),
d2907 3
a2909 3
	XFontStruct *fs = ((flags & BOLDATTR(screen))
			   ? BoldFont(screen)
			   : NormalFont(screen));
d2914 23
a2936 5
	    if_WIDE_OR_NARROW(screen, {
		XChar2b temp[1];
		temp[0].byte2 = *text;
		temp[0].byte1 = *text2;
		width = XTextWidth16(fs, temp, 1);
d2938 4
a2941 8
	    , {
		width = XTextWidth(fs, (char *) text, 1);
	    });
	    adj = (FontWidth(screen) - width) / 2;
	    (void) drawXtermText(xw, flags | NOBACKGROUND | CHARBYCHAR,
				 gc, x + adj, y, chrset,
				 PAIRED_CHARS(text++, text2++), 1, on_wide);
	    x += FontWidth(screen);
d2954 3
a2956 3
	XFontStruct *font = ((flags & BOLD)
			     ? BoldFont(screen)
			     : NormalFont(screen));
d2958 2
d2961 1
a2961 1
	    unsigned ch = (unsigned) PACK_PAIR(text, text2, last);
d2967 6
a2972 2
		if (last > first)
		    DrawSegment(first, last);
d2974 1
d2979 5
a2983 5
		xtermMissingChar(xw, ch,
				 ((on_wide || ch_width > 1)
				  && okFont(NormalWFont(screen)))
				 ? NormalWFont(screen)
				 : font);
d2985 1
a2985 1
	    isMissing = xtermMissingChar(xw, ch, font);
d3006 6
a3011 2
		if (last > first)
		    DrawSegment(first, last);
d3013 2
a3014 1
		if (!ucs_workaround(xw, ch, flags, gc, DrawX(last), y,
d3017 6
a3022 3
		    xtermDrawBoxChar(xw, ch, flags, gc, DrawX(last), y, ch_width);
		if (ch_width > 1)
		    x += (ch_width - 1) * FontWidth(screen);
d3024 1
d3028 1
a3028 1
	    return x + (int) real_length *FontWidth(screen);
a3030 3
#if OPT_WIDE_CHARS
	text2 += first;
#endif
d3033 1
a3033 1
	if (DrawX(first) != x) {
d3037 1
a3037 1
				 DrawX(first),
d3040 1
a3040 1
				 PAIRED_CHARS(text, text2),
d3054 1
a3054 1
	   visibleChars(PAIRED_CHARS(text, text2), len)));
d3058 1
d3060 1
d3065 2
a3066 6
	if (screen->draw_len < len) {
	    screen->draw_len = (len + 1) * 2;
	    screen->draw_buf = (XChar2b *) XtRealloc((char *) screen->draw_buf,
						     screen->draw_len *
						     sizeof(*screen->draw_buf));
	}
d3069 1
a3069 1
	    unsigned ch = (unsigned) PACK_PAIR(text, text2, src);
d3084 1
a3086 5
		screen->draw_buf[dst].byte2 = LO_BYTE(ch);
		screen->draw_buf[dst].byte1 = HI_BYTE(ch);
	    } else {
		screen->draw_buf[dst].byte2 = text[src];
		screen->draw_buf[dst].byte1 = text2[src];
d3088 3
d3092 2
a3093 2
#define UCS2SBUF(value)	screen->draw_buf[dst].byte2 = LO_BYTE(value);\
	    		screen->draw_buf[dst].byte1 = HI_BYTE(value)
d3097 1
a3097 1
	    if (screen->latin9_mode && !screen->utf8_mode && text2[src] == 0) {
a3112 1
		&& text2[src] == 0
d3180 1
a3180 1
			  screen->draw_buf, dst);
d3185 1
a3185 1
			       screen->draw_buf, dst);
d3193 1
a3193 1
			  screen->draw_buf, dst);
d3201 12
d3216 1
a3216 1
			x, y, (char *) text, length);
d3219 1
a3219 1
			     x, y, (char *) text, length);
d3225 1
a3225 1
			x + 1, y, (char *) text, length);
d3245 1
a3245 1
allocXtermChars(Char ** buffer, Cardinal length)
d3248 1
a3248 1
	*buffer = (Char *) XtMalloc(length);
d3250 1
a3250 1
	*buffer = (Char *) XtRealloc((char *) *buffer, length);
a3254 36
int
drawXtermIChars(XtermWidget xw,
		unsigned flags,
		GC gc,
		int x,
		int y,
		int chrset,
		IChar * text,
		Cardinal len,
		int on_wide)
{
    int rc = 0;
#if OPT_WIDE_CHARS
    static Char *text1 = 0;
    static Char *text2 = 0;
    static Cardinal used = 0;
    Cardinal n;

    if (text != 0) {
	if (len >= used) {
	    used = 1 + (2 * len);
	    allocXtermChars(&text1, used);
	    allocXtermChars(&text2, used);
	}
	for (n = 0; n < len; ++n) {
	    text1[n] = LO_BYTE(text[n]);
	    text2[n] = HI_BYTE(text[n]);
	}
	rc = drawXtermText(xw, flags, gc, x, y, chrset, text1, text2, len, on_wide);
    }
#else
    rc = drawXtermText(xw, flags, gc, x, y, chrset, text, len, on_wide);
#endif
    return rc;
}

d3297 1
a3297 1
	bzero(&xw->hints, sizeof(xw->hints));
d3307 1
a3307 1
updatedXtermGC(XtermWidget xw, unsigned flags, unsigned fg_bg, Bool hilite)
d3441 1
a3441 1
extract_fg(XtermWidget xw, unsigned color, unsigned flags)
d3462 1
a3462 1
extract_bg(XtermWidget xw, unsigned color, unsigned flags)
d3483 1
a3483 1
unsigned
d3488 2
a3489 5
#if OPT_EXT_COLORS
    return (my_fg << 8) | my_bg;
#else
    return (my_fg << 4) | my_bg;
#endif
d3519 1
a3519 1
 * Returns a single 8/16-bit number for the given cell
d3524 3
a3526 5
    unsigned ch = SCRN_BUF_CHARS(screen, row)[col];
    if_OPT_WIDE_CHARS(screen, {
	ch |= (SCRN_BUF_WIDEC(screen, row)[col] << 8);
    });
    return ch;
d3530 1
a3530 1
 * Sets a single 8/16-bit number for the given cell
d3535 3
a3537 1
    SCRN_BUF_CHARS(screen, row)[col] = LO_BYTE(ch);
d3539 3
a3541 4
	int off;
	SCRN_BUF_WIDEC(screen, row)[col] = HI_BYTE(ch);
	for (off = OFF_WIDEC + 1; off < MAX_PTRS; ++off) {
	    SCREEN_PTR(screen, row, off)[col] = 0;
d3548 1
a3548 1
getXtermCellComb(TScreen * screen, int row, int col, int off)
d3550 3
a3552 3
    return (unsigned) PACK_PAIR(SCREEN_PTR(screen, row, off),
				SCREEN_PTR(screen, row, off + 1),
				col);
d3562 2
a3563 1
	int off;
d3566 1
a3566 1
	       row, col, ch, my_wcwidth(ch)));
d3568 3
a3570 5
	for (off = OFF_FINAL; off < MAX_PTRS; off += 2) {
	    if (!SCREEN_PTR(screen, row, off + 0)[col]
		&& !SCREEN_PTR(screen, row, off + 1)[col]) {
		SCREEN_PTR(screen, row, off + 0)[col] = LO_BYTE(ch);
		SCREEN_PTR(screen, row, off + 1)[col] = HI_BYTE(ch);
d3580 2
a3581 2
char *
my_memmove(char *s1, char *s2, size_t n)
d3584 4
a3587 1
	if ((s1 + n > s2) && (s2 + n > s1)) {
d3600 2
a3601 2
		bfr[j] = s2[j];
	    s2 = bfr;
d3604 1
a3604 1
	    s1[n] = s2[n];
d3776 19
@


1.4
log
@Update to xterm 242. Tested by jsg@@.
@
text
@d1 1
a1 1
/* $XTermId: util.c,v 1.420 2009/02/13 23:38:26 tom Exp $ */
d3107 3
a3109 3
		int ni = dec2ucs((unsigned) ((text[src] == ANSI_DEL)
					     ? 0
					     : text[src]));
@


1.3
log
@xterm 238. includes fix for CVE-2008-2383.
@
text
@d1 1
a1 1
/* $XTermId: util.c,v 1.410 2008/12/30 16:43:46 tom Exp $ */
d4 1
a4 1
 * Copyright 1999-2007,2008 by Thomas E. Dickey
d107 1
a107 1
    int kr = col + n;
d217 1
a217 1
			   (unsigned) refreshheight * FontHeight(screen),
d425 3
a427 3
    Boolean scroll_all_lines = (screen->scrollWidget
				&& !screen->alternate
				&& screen->top_marg == 0);
d508 1
a508 1
			       (unsigned) refreshheight * FontHeight(screen),
d613 1
a613 1
			       (unsigned) refreshheight * FontHeight(screen),
d634 1
a634 1
WriteText(XtermWidget xw, PAIRED_CHARS(Char * str, Char * str2), Cardinal len)
d641 1
a641 1
    unsigned cells = visual_width(PAIRED_CHARS(str, str2), len);
d648 1
a648 1
	   len, visibleChars(PAIRED_CHARS(str, str2), len)));
d676 3
a678 11
	    if (cells > len) {
		str = temp_str = TypeMallocN(Char, cells);
		if (str == 0)
		    return;
	    }
	    len = cells;

	    memset(str, ' ', len);
	    if_OPT_WIDE_CHARS(screen, {
		str2 = 0;
	    });
d691 5
a695 5
	drawXtermText(xw, test & DRAWX_MASK, currentGC,
		      CurCursorX(screen, screen->cur_row, screen->cur_col),
		      CursorY(screen, screen->cur_row),
		      curXtermChrSet(xw, screen->cur_row),
		      PAIRED_CHARS(str, str2), len, 0);
d700 1
a700 1
    ScrnWriteText(xw, PAIRED_CHARS(str, str2), flags, fg_bg, len);
d717 1
a717 8
	    ChangeIconName(icon_name);
	}
	if (resource.zIconBeep > 0) {
#if defined(HAVE_XKB_BELL_EXT)
	    XkbBell(XtDisplay(toplevel), VShellWindow, resource.zIconBeep, XkbBI_Info);
#else
	    XBell(XtDisplay(toplevel), resource.zIconBeep);
#endif
d719 1
d787 1
a787 1
			       (unsigned) refreshheight * FontHeight(screen),
d875 1
a875 1
			       (unsigned) refreshheight * FontHeight(screen),
d922 1
a922 1
    limit = MaxCols(screen) - screen->cur_col;
d929 1
a929 1
	int col = MaxCols(screen) - n;
d942 1
a942 1
	    kr = screen->max_col - n + 1;
d952 1
a952 1
	    col = MaxCols(screen) / 2 - n;
d970 1
a970 1
			   n * CurFontWidth(screen, screen->cur_row));
d998 1
a998 1
    limit = MaxCols(screen) - screen->cur_col;
d1005 1
a1005 1
	int col = MaxCols(screen) - n;
d1020 1
a1020 1
	    col = MaxCols(screen) / 2 - n;
d1024 1
a1024 1
			     (int) (screen->cur_col + n),
d1032 1
a1032 1
			   n * CurFontWidth(screen, screen->cur_row));
d1050 1
a1050 1
	unsigned len = MaxCols(screen);
d1092 1
a1092 1
	unsigned len = MaxCols(screen);
d1137 1
a1137 1
	len = MaxCols(screen) - col;
d1169 1
a1169 1
		col += n;
d1189 1
a1189 1
			   len * CurFontWidth(screen, row));
d1225 1
a1225 1
    unsigned len = (MaxCols(screen) - screen->cur_col);
d1236 1
a1236 1
	len = n;
d1250 1
a1250 1
		xx = col + len - 1;
d1273 1
a1273 1
    unsigned len = screen->cur_col + 1;
d1298 1
a1298 1
    unsigned len = MaxCols(screen);
d1406 1
a1406 1
	    unsigned len = MaxCols(screen);
d1516 1
a1516 1
	      (unsigned) nchars * CurFontWidth(screen, screen->cur_row),
d1593 4
a1596 4
	int both_x2 = Min(screen->copy_src_x + screen->copy_width,
			  (unsigned) (reply->x + reply->width));
	int both_y2 = Min(screen->copy_src_y + screen->copy_height,
			  (unsigned) (reply->y + reply->height));
d1853 1
a1853 1
    return !x_strcasecmp(name, XtDefaultForeground);
d1859 1
a1859 1
    return !x_strcasecmp(name, XtDefaultBackground);
d2006 1
a2006 1
    xw->misc.re_verse = !xw->misc.re_verse;
d2201 2
a2202 2
	    sbuf[dst].x = x + fwidth * ncells;
	    sbuf[dst].y = y;
d2318 1
a2318 1
	    text[0] = eqv;
d2431 1
a2431 1
			   len * FontWidth(screen),
d2483 2
a2484 2
		clip.height = FontHeight(screen); \
		clip.width = pwidth * plength; \
d2504 2
a2505 2
		clip.height = FontHeight(screen); \
		clip.width = FontWidth(screen) * plength; \
d2620 2
a2621 2
		rect.width = len * font_width;
		rect.height = FontHeight(screen);
d2626 1
a2626 1
		    rect.y = -(fs->ascent / 2);
d2631 1
a2631 1
		    rect.y = rect.height - (fs->ascent / 2);
d2674 1
a2674 1
		x += len * FontWidth(screen);
d2773 1
a2773 1
		unsigned ch = PACK_PAIR(text, text2, last);
d2843 1
a2843 1
			underline_len += nc;
d2848 2
a2849 2
			screen->fnt_wide = FontWidth(screen);
			screen->fnt_high = FontHeight(screen);
d2871 1
a2871 1
			underline_len += nc;
d2911 1
a2911 1
	return x + len * FontWidth(screen);
d2960 1
a2960 1
	    unsigned ch = PACK_PAIR(text, text2, last);
d3013 1
a3013 1
	    return x + real_length * FontWidth(screen);
d3019 1
a3019 1
	len = last - first;
d3059 1
a3059 1
	    unsigned ch = PACK_PAIR(text, text2, src);
d3155 1
a3155 1
		    underline_len = real_length = dst * 2;
d3157 1
a3157 1
		    underline_len = real_length = dst * 2;
d3181 1
a3181 1
	    beginClipping(screen, gc, font_width, len);
d3192 1
a3192 1
	int length = len;	/* X should have used unsigned */
d3201 1
a3201 1
	underline_len = length;
d3214 17
a3230 1
		  x, y, (int) (x + underline_len * font_width - 1), y);
d3232 2
d3235 34
a3268 1
    return x + real_length * FontWidth(screen);
d3328 2
a3329 2
    int my_fg = extract_fg(xw, fg_bg, flags);
    int my_bg = extract_bg(xw, fg_bg, flags);
d3337 4
a3340 2
    Boolean use_selbg = always || isNotForeground(xw, fg_pix, bg_pix, selbg_pix);
    Boolean use_selfg = always && isNotBackground(xw, fg_pix, bg_pix, selfg_pix);
d3570 3
a3572 3
    return PACK_PAIR(SCREEN_PTR(screen, row, off),
		     SCREEN_PTR(screen, row, off + 1),
		     col);
@


1.2
log
@update to xterm 234. tested by merdely@@, 'looks ok' deraadt@@.
@
text
@d1 1
a1 1
/* $XTermId: util.c,v 1.407 2008/02/21 20:29:01 tom Exp $ */
d772 1
a772 1
    screen->do_wrap = 0;
d844 1
a844 1
    screen->do_wrap = 0;
d933 1
a933 1
    screen->do_wrap = 0;
d1009 1
a1009 1
    screen->do_wrap = 0;
d1196 1
a1196 1
    screen->do_wrap = 0;
d1277 1
d1328 1
a1328 1
    screen->do_wrap = 0;
a3600 13

int
char2lower(int ch)
{
    if (isascii(ch) && isupper(ch)) {	/* lowercasify */
#ifdef _tolower
	ch = _tolower(ch);
#else
	ch = tolower(ch);
#endif
    }
    return ch;
}
@


1.1
log
@Initial revision
@
text
@d1 1
a1 3
/* $XTermId: util.c,v 1.291 2006/07/23 22:06:00 tom Exp $ */

/* $XFree86: xc/programs/xterm/util.c,v 3.98 2006/06/19 00:36:52 dickey Exp $ */
d4 1
a4 1
 * Copyright 1999-2005,2006 by Thomas E. Dickey
a75 1
static int ClearInLine(XtermWidget xw, int row, int col, unsigned len);
d96 46
d225 5
d231 1
a231 1
AddToRefresh(TScreen * screen)
d233 1
d236 1
d239 1
a239 1
	return (0);
d245 3
a247 1
	    return (1);
a248 1
	return (row >= bottom - amount + 1 && row <= bottom);
d255 30
a284 1
	    return (1);
a285 1
	return (row <= top + amount - 1 && row >= top);
d287 1
d630 113
d942 21
a962 5
    if (row <= screen->max_row) {
	if (!AddToRefresh(screen)) {
	    int col = MaxCols(screen) - n;
	    if (screen->scroll_amt)
		FlushScroll(xw);
d965 3
a967 3
	    if (CSET_DOUBLE(SCRN_BUF_CSETS(screen, screen->cur_row)[0])) {
		col = MaxCols(screen) / 2 - n;
	    }
d969 10
a978 9
	    /*
	     * prevent InsertChar from shifting the end of a line over
	     * if it is being appended to
	     */
	    if (non_blank_line(screen, screen->cur_row,
			       screen->cur_col, MaxCols(screen)))
		horizontal_copy_area(xw, screen->cur_col,
				     col - screen->cur_col,
				     (int) n);
d980 5
a984 6
	    ClearCurBackground(xw,
			       CursorY(screen, screen->cur_row),
			       CurCursorX(screen, screen->cur_row, screen->cur_col),
			       (unsigned) FontHeight(screen),
			       n * CurFontWidth(screen, screen->cur_row));
	}
d1018 13
a1030 5
    if (row <= screen->max_row) {
	if (!AddToRefresh(screen)) {
	    int col = MaxCols(screen) - n;
	    if (screen->scroll_amt)
		FlushScroll(xw);
d1033 3
a1035 3
	    if (CSET_DOUBLE(SCRN_BUF_CSETS(screen, screen->cur_row)[0])) {
		col = MaxCols(screen) / 2 - n;
	    }
d1037 4
a1040 4
	    horizontal_copy_area(xw,
				 (int) (screen->cur_col + n),
				 col - screen->cur_col,
				 -((int) n));
d1042 5
a1046 6
	    ClearCurBackground(xw,
			       CursorY(screen, screen->cur_row),
			       CurCursorX(screen, screen->cur_row, col),
			       (unsigned) FontHeight(screen),
			       n * CurFontWidth(screen, screen->cur_row));
	}
d1048 1
a1048 1
    if (n > 0) {
d1050 1
a1050 1
	ScrnDeleteChar(xw, (unsigned) n);
d1135 1
a1135 1
ClearInLine(XtermWidget xw, int row, int col, unsigned len)
a1138 1
    int flags = TERM_COLOR_FLAGS(xw);
d1150 1
a1150 9
    /*
     * If we're clearing to the end of the line, we won't count this as
     * "drawn" characters.  We'll only do cut/paste on "drawn" characters,
     * so this has the effect of suppressing trailing blanks from a
     * selection.
     */
    if (col + (int) len < MaxCols(screen)) {
	flags |= CHARDRAWN;
    } else {
d1198 6
a1203 10
    if (INX2ROW(screen, row) <= screen->max_row) {
	if (!AddToRefresh(screen)) {
	    if (screen->scroll_amt)
		FlushScroll(xw);
	    ClearCurBackground(xw,
			       CursorY(screen, row),
			       CurCursorX(screen, row, col),
			       (unsigned) FontHeight(screen),
			       len * CurFontWidth(screen, row));
	}
d1207 1
a1207 23
	memset(SCRN_BUF_CHARS(screen, row) + col, ' ', len);
	memset(SCRN_BUF_ATTRS(screen, row) + col, flags, len);

	if_OPT_EXT_COLORS(screen, {
	    memset(SCRN_BUF_FGRND(screen, row) + col,
		   xw->sgr_foreground, len);
	    memset(SCRN_BUF_BGRND(screen, row) + col,
		   xw->cur_background, len);
	});
	if_OPT_ISO_TRADITIONAL_COLORS(screen, {
	    memset(SCRN_BUF_COLOR(screen, row) + col,
		   (int) xtermColorPair(xw), len);
	});
	if_OPT_DEC_CHRSET({
	    memset(SCRN_BUF_CSETS(screen, row) + col,
		   curXtermChrSet(xw, screen->cur_row), len);
	});
	if_OPT_WIDE_CHARS(screen, {
	    int off;
	    for (off = OFF_WIDEC; off < MAX_PTRS; ++off) {
		memset(SCREEN_PTR(screen, row, off) + col, 0, len);
	    }
	});
d1213 18
d1252 22
a1273 1
    (void) ClearInLine(xw, screen->cur_row, screen->cur_col, len);
d1289 13
a1301 1
    (void) ClearInLine(xw, screen->cur_row, 0, len);
d1510 1
a1510 1
		  NormalGC(screen),
d1631 11
d1658 1
d1669 11
d1701 2
a1702 4
	ScrnRefresh(xw, toprow, leftcol, nrows, ncols, False);
	if (waiting_for_initial_map) {
	    first_map_occurred();
	}
d1706 3
a1708 2
	    screen->cur_col < leftcol + ncols)
	    return (1);
d1711 2
a1712 1
    return (0);
d1734 1
a1734 3
#if OPT_TEK4014
    Window tek = TWindow(screen);
#endif
d1754 4
a1757 4
	    XSetForeground(screen->display, NormalGC(screen), fg);
	    XSetBackground(screen->display, ReverseGC(screen), fg);
	    XSetForeground(screen->display, NormalBoldGC(screen), fg);
	    XSetBackground(screen->display, ReverseBoldGC(screen), fg);
d1767 5
a1771 6
	    XSetBackground(screen->display, NormalGC(screen), bg);
	    XSetForeground(screen->display, ReverseGC(screen), bg);
	    XSetBackground(screen->display, NormalBoldGC(screen), bg);
	    XSetForeground(screen->display, ReverseBoldGC(screen), bg);
	    XSetWindowBackground(screen->display, VWindow(screen),
				 T_COLOR(screen, TEXT_BG));
d1781 5
d1798 8
a1805 11
	recolor_cursor(screen,
		       screen->pointer_cursor,
		       T_COLOR(screen, MOUSE_FG),
		       T_COLOR(screen, MOUSE_BG));
	recolor_cursor(screen,
		       screen->arrow,
		       T_COLOR(screen, MOUSE_FG),
		       T_COLOR(screen, MOUSE_BG));
	XDefineCursor(screen->display, VWindow(screen),
		      screen->pointer_cursor);

d1807 11
a1817 2
	if (tek)
	    XDefineCursor(screen->display, tek, screen->arrow);
d1830 3
a1832 4
	ChangeTekColors(screen, pNew);
	if (screen->Tshow) {
	    XClearWindow(screen->display, tek);
	    TekExpose((Widget) NULL, (XEvent *) NULL, (Region) NULL);
d1835 1
a1835 1
	ChangeTekColors(screen, pNew);
d1838 2
a1839 5
    if (repaint) {
	XClearWindow(screen->display, VWindow(screen));
	ScrnRefresh(xw, 0, 0, MaxRows(screen),
		    MaxCols(screen), False);
    }
d1843 1
a1843 1
ChangeAnsiColors(XtermWidget xw)
d1847 1
a1848 3
    ScrnRefresh(xw, 0, 0,
		MaxRows(screen),
		MaxCols(screen), False);
a1850 2
/***====================================================================***/

d1852 1
a1852 1
ReverseVideo(XtermWidget xw)
a1854 5
    GC tmpGC;
    Pixel tmp;
#if OPT_TEK4014
    Window tek = TWindow(screen);
#endif
d1856 4
a1859 1
    TRACE(("ReverseVideo\n"));
d1861 1
a1861 14
    /*
     * Swap SGR foreground and background colors.  By convention, these are
     * the colors assigned to "black" (SGR #0) and "white" (SGR #7).  Also,
     * SGR #8 and SGR #15 are the bold (or bright) versions of SGR #0 and
     * #7, respectively.
     *
     * We don't swap colors that happen to match the screen's foreground
     * and background because that tends to produce bizarre effects.
     */
    if_OPT_ISO_COLORS(screen, {
	ColorRes tmp2;
	EXCHANGE(screen->Acolors[0], screen->Acolors[7], tmp2);
	EXCHANGE(screen->Acolors[8], screen->Acolors[15], tmp2);
    });
d1863 5
a1867 18
    tmp = T_COLOR(screen, TEXT_BG);
    if (T_COLOR(screen, TEXT_CURSOR) == T_COLOR(screen, TEXT_FG))
	T_COLOR(screen, TEXT_CURSOR) = tmp;
    T_COLOR(screen, TEXT_BG) = T_COLOR(screen, TEXT_FG);
    T_COLOR(screen, TEXT_FG) = tmp;

    EXCHANGE(T_COLOR(screen, MOUSE_FG), T_COLOR(screen, MOUSE_BG), tmp);
    EXCHANGE(NormalGC(screen), ReverseGC(screen), tmpGC);
    EXCHANGE(NormalBoldGC(screen), ReverseBoldGC(screen), tmpGC);
#ifndef NO_ACTIVE_ICON
    tmpGC = screen->iconVwin.normalGC;
    screen->iconVwin.normalGC = screen->iconVwin.reverseGC;
    screen->iconVwin.reverseGC = tmpGC;

    tmpGC = screen->iconVwin.normalboldGC;
    screen->iconVwin.normalboldGC = screen->iconVwin.reverseboldGC;
    screen->iconVwin.reverseboldGC = tmpGC;
#endif /* NO_ACTIVE_ICON */
d1869 5
a1873 8
    recolor_cursor(screen,
		   screen->pointer_cursor,
		   T_COLOR(screen, MOUSE_FG),
		   T_COLOR(screen, MOUSE_BG));
    recolor_cursor(screen,
		   screen->arrow,
		   T_COLOR(screen, MOUSE_FG),
		   T_COLOR(screen, MOUSE_BG));
d1875 9
a1883 1
    xw->misc.re_verse = !xw->misc.re_verse;
d1885 13
a1897 2
    if (XtIsRealized((Widget) xw)) {
	XDefineCursor(screen->display, VWindow(screen), screen->pointer_cursor);
d1899 2
a1900 3
#if OPT_TEK4014
    if (tek)
	XDefineCursor(screen->display, tek, screen->arrow);
d1903 1
a1903 2
    if (screen->scrollWidget)
	ScrollBarReverseVideo(screen->scrollWidget);
d1905 4
a1908 3
    if (XtIsRealized((Widget) xw)) {
	XSetWindowBackground(screen->display, VWindow(screen),
			     T_COLOR(screen, TEXT_BG));
d1910 6
a1915 19
	/* the shell-window's background will be used in the first repainting
	 * on resizing
	 */
	XSetWindowBackground(screen->display, VShellWindow,
			     T_COLOR(screen, TEXT_BG));
    }
#if OPT_TEK4014
    TekReverseVideo(screen);
#endif
    if (XtIsRealized((Widget) xw)) {
	XClearWindow(screen->display, VWindow(screen));
	ScrnRefresh(xw, 0, 0, MaxRows(screen),
		    MaxCols(screen), False);
    }
#if OPT_TEK4014
    if (screen->Tshow) {
	XClearWindow(screen->display, tek);
	TekExpose((Widget) NULL, (XEvent *) NULL, (Region) NULL);
    }
d1917 141
a2057 5
    ReverseOldColors();
    set_cursor_gcs(xw);
    update_reversevideo();
    TRACE(("...ReverseVideo\n"));
}
d2078 1
a2078 1
getColor(XtermWidget xw, Pixel pixel)
d2117 29
d2155 2
a2156 2
static void
xtermXftDrawString(TScreen * screen,
d2163 2
a2164 3
		   int len,
		   int fwidth,
		   int *deltax)
d2166 4
d2171 11
a2181 11
    XftFont *wfont;
    int n;
    int ncells = 0;		/* # of 'half-width' charcells */
    static XftCharSpec *sbuf;
    static int slen = 0;
    XftFont *lastFont = 0;
    XftFont *currFont = 0;
    int start = 0;
    int charWidth;
    FcChar32 wc;
    int fontnum = screen->menu_font_number;
a2182 3
    if (len == 0 || !(*text || *text2)) {
	return;
    }
d2184 5
a2188 5
    if ((flags & UNDERLINE)
	&& screen->italicULMode
	&& screen->renderWideItal[fontnum]) {
	wfont = screen->renderWideItal[fontnum];
    } else
d2190 18
a2207 6
	if ((flags & BOLDATTR(screen))
	    && screen->renderWideBold[fontnum]) {
	wfont = screen->renderWideBold[fontnum];
    } else {
	wfont = screen->renderWideNorm[fontnum];
    }
d2209 3
a2211 5
    if ((int) slen < len) {
	slen = (len + 1) * 2;
	sbuf = (XftCharSpec *) XtRealloc((char *) sbuf,
					 slen * sizeof(XftCharSpec));
    }
d2213 3
a2215 28
    for (n = 0; n < len; n++) {
	if (text2)
	    wc = *text++ | (*text2++ << 8);
	else
	    wc = *text++;
	sbuf[n].ucs4 = wc;
	sbuf[n].x = x + fwidth * ncells;
	sbuf[n].y = y;
	charWidth = my_wcwidth((int) wc);
	currFont = (charWidth == 2 && wfont != 0) ? wfont : font;
	ncells += charWidth;
	if (lastFont != currFont) {
	    if (lastFont != 0) {
		XftDrawCharSpec(screen->renderDraw,
				color,
				lastFont,
				sbuf + start,
				n - start);
	    }
	    start = n;
	    lastFont = currFont;
	}
    }
    XftDrawCharSpec(screen->renderDraw,
		    color,
		    lastFont,
		    sbuf + start,
		    n - start);
d2217 2
a2218 3
    if (deltax)
	*deltax = ncells * fwidth;
#else
d2220 29
a2248 6
    XftDrawString8(screen->renderDraw,
		   color,
		   font,
		   x, y, (unsigned char *) text, len);
    if (deltax)
	*deltax = len * fwidth;
d2250 2
d2253 2
d2262 44
d2324 24
a2347 9
	switch (ch) {
	case 0x2010:		/* groff "-" */
	case 0x2011:
	case 0x2012:
	case 0x2013:
	case 0x2014:
	case 0x2015:
	case 0x2212:		/* groff "\-" */
	    ch = '-';
d2349 38
d2388 38
a2425 3
	case 0x2018:		/* groff "`" */
	    ch = '`';
	    fixed = True;
d2427 4
a2430 3
	case 0x2019:		/* groff ' */
	    ch = '\'';
	    fixed = True;
d2432 2
a2433 4
	case 0x201C:		/* groff lq */
	case 0x201D:		/* groff rq */
	    ch = '"';
	    fixed = True;
a2435 3
	if (fixed) {
	    Char text[2];
	    Char text2[2];
d2437 9
a2445 11
	    text[0] = ch;
	    text2[0] = 0;
	    drawXtermText(xw,
			  flags,
			  gc,
			  x,
			  y,
			  chrset,
			  PAIRED_CHARS(text, text2),
			  1,
			  on_wide);
a2447 1
    return fixed;
d2449 33
d2490 1
a2490 1
	    if (pwidth > 2) { \
d2498 3
a2500 3
		XSetClipRectangles(screen->display, gc, \
				   clip_x, clip_y, \
				   &clip, 1, Unsorted); \
d2509 51
d2576 2
a2577 2
    int real_length = len;
    int underline_len;
d2608 1
d2610 1
a2610 1
		  ? xterm_DoubleGC((unsigned) chrset, flags, gc)
d2613 1
a2613 1
	TRACE(("DRAWTEXT%c[%4d,%4d] (%d) %d:%.*s\n",
d2615 2
a2616 1
	       y, x, chrset, len, (int) len, text));
a2618 2
	    /* Update the last-used cache of double-sized fonts */
	    int inx = xterm_Double_index((unsigned) chrset, flags);
a2619 27
	    XRectangle rect, *rp = &rect;
	    int nr = 1;
	    int adjust;

	    font_width *= 2;
	    flags |= DOUBLEWFONT;

	    rect.x = 0;
	    rect.y = 0;
	    rect.width = len * font_width;
	    rect.height = FontHeight(screen);

	    switch (chrset) {
	    case CSET_DHL_TOP:
		rect.y = -(rect.height / 2);
		y -= rect.y;
		flags |= DOUBLEHFONT;
		break;
	    case CSET_DHL_BOT:
		rect.y = (rect.height / 2);
		y -= rect.y;
		flags |= DOUBLEHFONT;
		break;
	    default:
		nr = 0;
		break;
	    }
d2621 38
a2658 11
	    /*
	     * Though it is the right "size", a given bold font may
	     * be shifted up by a pixel or two.  Shift it back into
	     * the clipping rectangle.
	     */
	    if (nr != 0) {
		adjust = fs->ascent
		    + fs->descent
		    - (2 * FontHeight(screen));
		rect.y -= adjust;
		y += adjust;
a2660 6
	    if (nr)
		XSetClipRectangles(screen->display, gc2,
				   x, y, rp, nr, YXBanded);
	    else
		XSetClipMask(screen->display, gc2, None);

d2727 1
d2732 1
d2758 10
a2767 2
	XGetGCValues(dpy, gc, GCForeground | GCBackground, &values);
	if (!(flags & NOBACKGROUND))
d2769 1
a2769 1
			getColor(xw, values.background),
d2771 1
a2771 1
			len * FontWidth(screen),
d2773 1
d2777 1
a2777 1
	if (!screen->force_box_chars) {
d2784 55
a2838 2
		unsigned ch = text[last];
		int deltax = 0;
d2841 1
a2841 18
		 * If we're reading UTF-8 from the client, we may have a
		 * line-drawing character.  Translate it back to our box-code
		 * if it is really a line-drawing character (since the
		 * fonts used by Xft generally do not have correct glyphs),
		 * or if Xft can tell us that the glyph is really missing.
		 */
		if_OPT_WIDE_CHARS(screen, {
		    unsigned full = (ch | (text2[last] << 8));
		    unsigned part = ucs2dec(full);
		    if (xtermIsDecGraphic(part) &&
			(xtermIsLineDrawing(part)
			 || xtermXftMissing(xw, font, full)))
			ch = part;
		    else
			ch = full;
		});
		/*
		 * If we have one of our box-codes, draw it directly.
d2843 1
a2843 1
		if (xtermIsDecGraphic(ch)) {
d2846 39
a2884 9
			xtermXftDrawString(screen, flags,
					   getColor(xw, values.foreground),
					   font, curX, y,
					   PAIRED_CHARS(text + first,
							text2 + first),
					   last - first,
					   FontWidth(screen),
					   &deltax);
			curX += deltax;
a2885 9
		    old_wide = screen->fnt_wide;
		    old_high = screen->fnt_high;
		    screen->fnt_wide = FontWidth(screen);
		    screen->fnt_high = FontHeight(screen);
		    xtermDrawBoxChar(xw, ch, flags, gc,
				     curX, y - FontAscent(screen));
		    curX += FontWidth(screen);
		    screen->fnt_wide = old_wide;
		    screen->fnt_high = old_high;
d2890 10
a2899 7
		xtermXftDrawString(screen, flags,
				   getColor(xw, values.foreground),
				   font, curX, y,
				   PAIRED_CHARS(text + first, text2 + first),
				   last - first,
				   FontWidth(screen),
				   NULL);
d2901 2
a2902 2
	} else
#endif /* OPT_BOX_CHARS */
d2904 9
a2912 4
	    xtermXftDrawString(screen, flags,
			       getColor(xw, values.foreground),
			       font, x, y, PAIRED_CHARS(text, text2),
			       (int) len, FontWidth(screen), NULL);
d2914 1
d2921 1
a2921 1
		      x + (int) len * FontWidth(screen) - 1,
a2934 1
	GC fillGC = gc;		/* might be cursorGC */
d2939 1
a2939 22
#define GC_PAIRS(a,b) \
	if (gc == a) fillGC = b; \
	if (gc == b) fillGC = a

	/*
	 * Fill the area where we'll write the characters, otherwise
	 * we'll get gaps between them.  The cursor is a special case,
	 * because the XFillRectangle call only uses the foreground,
	 * while we've set the cursor color in the background.  So we
	 * need a special GC for that.
	 */
	if (gc == screen->cursorGC
	    || gc == screen->reversecursorGC)
	    fillGC = screen->fillCursorGC;
	GC_PAIRS(NormalGC(screen), ReverseGC(screen));
	GC_PAIRS(NormalBoldGC(screen), ReverseBoldGC(screen));

	if (!(flags & NOBACKGROUND))
	    XFillRectangle(screen->display, VWindow(screen), fillGC,
			   x, y,
			   len * FontWidth(screen),
			   (unsigned) FontHeight(screen));
d2942 9
a2950 1
	    width = XTextWidth(fs, (char *) text, 1);
d2973 1
a2973 1
	    unsigned ch = text[last];
d2975 1
d2977 14
a2990 8
	    if (text2 != 0)
		ch |= (text2[last] << 8);
	    isMissing = (ch != HIDDEN_CHAR)
		&& (xtermMissingChar(xw, ch,
				     ((on_wide || iswide((int) ch))
				      && screen->fnts[fWide])
				     ? screen->fnts[fWide]
				     : font));
d2993 1
d2995 17
d3019 3
a3021 1
		    xtermDrawBoxChar(xw, ch, flags, gc, DrawX(last), y);
d3050 1
a3050 2
     * or the caller made sure that there is none).  The only translation we do
     * in this branch is the removal of HIDDEN_CHAR (for the wide-char case).
d3060 1
d3062 2
a3063 6
	int n;
	unsigned ch = text[0] | (text2[0] << 8);
	int wideness = (!IsIcon(screen)
			&& ((on_wide || iswide((int) ch) != 0)
			    && (screen->fnts[fWide] != NULL)));
	unsigned char *endtext = text + len;
d3070 25
a3094 3
	for (n = 0; n < (int) len; n++) {
	    screen->draw_buf[n].byte2 = *text;
	    screen->draw_buf[n].byte1 = *text2;
d3096 6
a3101 4
#define UCS2SBUF(n,value)	screen->draw_buf[n].byte2 = (value & 0xff);\
	    			screen->draw_buf[n].byte1 = (value >> 8)
#define Map2Sbuf(n,from,to) (*text == from) { UCS2SBUF(n,to); }
	    if (screen->latin9_mode && !screen->utf8_mode && *text2 == 0) {
d3105 8
a3112 8
		if Map2Sbuf(n, 0xa4, 0x20ac)
		else if Map2Sbuf(n, 0xa6, 0x0160)
		else if Map2Sbuf(n, 0xa8, 0x0161)
		else if Map2Sbuf(n, 0xb4, 0x017d)
		else if Map2Sbuf(n, 0xb8, 0x017e)
		else if Map2Sbuf(n, 0xbc, 0x0152)
		else if Map2Sbuf(n, 0xbd, 0x0153)
		else if Map2Sbuf(n, 0xbe, 0x0178)
d3117 7
a3123 4
		&& *text2 == 0
		&& (*text == DEL || *text < 0x20)) {
		int ni = dec2ucs((unsigned) ((*text == DEL) ? 0 : *text));
		UCS2SBUF(n, ni);
d3126 1
a3126 12
	    text++;
	    text2++;
	    if (wideness) {
		/* filter out those pesky fake characters. */
		while (text < endtext
		       && *text == HIDDEN_HI
		       && *text2 == HIDDEN_LO) {
		    text++;
		    text2++;
		    len--;
		}
	    }
d3128 1
a3128 1
	/* This is probably wrong. But it works. */
d3132 21
a3152 10
	if (flags & (DOUBLEHFONT | DOUBLEWFONT)) {
	    ;			/* Do nothing: font is already set */
	} else if (wideness
		   && (screen->fnts[fWide]->fid || screen->fnts[fWBold]->fid)) {
	    underline_len = real_length = len * 2;
	    if ((flags & BOLDATTR(screen)) != 0
		&& screen->fnts[fWBold]->fid) {
		XSetFont(screen->display, gc, screen->fnts[fWBold]->fid);
		ascent_adjust = (screen->fnts[fWBold]->ascent
				 - NormalFont(screen)->ascent);
d3154 11
a3164 2
		XSetFont(screen->display, gc, screen->fnts[fWide]->fid);
		ascent_adjust = (screen->fnts[fWide]->ascent
d3166 12
a3178 6
	    /* fix ascent */
	} else if ((flags & BOLDATTR(screen)) != 0
		   && BoldFont(screen)->fid) {
	    XSetFont(screen->display, gc, BoldFont(screen)->fid);
	} else {
	    XSetFont(screen->display, gc, NormalFont(screen)->fid);
d3181 1
a3181 1
	if (flags & NOBACKGROUND)
d3185 2
a3186 2
			  screen->draw_buf, n);
	else
d3190 2
a3191 1
			       screen->draw_buf, n);
d3198 1
a3198 1
			  screen->draw_buf, n);
d3207 1
a3207 1
	if (flags & NOBACKGROUND)
d3210 1
a3210 1
	else
d3213 1
d3227 1
a3227 1
		  x, y, x + underline_len * font_width - 1, y);
d3267 12
d3288 2
d3296 5
a3300 1
    Pixel hi_pix = T_COLOR(screen, HIGHLIGHT_BG);
a3301 1
    GC gc;
d3310 5
a3314 4
	if (flags & BOLDATTR(screen))
	    gc = ReverseBoldGC(screen);
	else
	    gc = ReverseGC(screen);
d3317 25
a3341 6
	if (hi_pix != T_COLOR(screen, TEXT_FG)
	    && hi_pix != fg_pix
	    && hi_pix != bg_pix
	    && hi_pix != xw->dft_foreground) {
	    bg_pix = fg_pix;
	    fg_pix = hi_pix;
a3343 3
	xx_pix = bg_pix;
	bg_pix = fg_pix;
	fg_pix = xx_pix;
d3345 14
a3358 5
	if (flags & BOLDATTR(screen))
	    gc = NormalBoldGC(screen);
	else
	    gc = NormalGC(screen);

d3360 1
d3368 3
a3370 3
    XSetForeground(screen->display, gc, fg_pix);
    XSetBackground(screen->display, gc, bg_pix);
    return gc;
d3382 2
a3385 1
    GC gc;
d3390 5
a3394 4
	if (flags & BOLDATTR(screen))
	    gc = ReverseBoldGC(screen);
	else
	    gc = ReverseGC(screen);
d3396 2
a3397 2
	XSetForeground(screen->display, gc, bg_pix);
	XSetBackground(screen->display, gc, fg_pix);
d3400 5
a3404 4
	if (flags & BOLDATTR(screen))
	    gc = NormalBoldGC(screen);
	else
	    gc = NormalGC(screen);
d3406 2
a3407 2
	XSetForeground(screen->display, gc, fg_pix);
	XSetBackground(screen->display, gc, bg_pix);
d3483 11
a3493 10
    XSetWindowBackground(screen->display,
			 VWindow(screen),
			 getXtermBackground(xw, xw->flags, xw->cur_background));

    XClearArea(screen->display, VWindow(screen),
	       left, top, width, height, False);

    XSetWindowBackground(screen->display,
			 VWindow(screen),
			 getXtermBackground(xw, xw->flags, MAXCOLORS));
d3516 1
a3516 1
    SCRN_BUF_CHARS(screen, row)[col] = ch;
d3519 1
a3519 1
	SCRN_BUF_WIDEC(screen, row)[col] = (ch >> 8);
d3530 3
a3532 3
    unsigned ch = SCREEN_PTR(screen, row, off)[col];
    ch |= (SCREEN_PTR(screen, row, off + 1)[col] << 8);
    return ch;
d3543 4
d3550 2
a3551 2
		SCREEN_PTR(screen, row, off + 0)[col] = ch & 0xff;
		SCREEN_PTR(screen, row, off + 1)[col] = ch >> 8;
d3618 1
d3711 3
d3763 1
a3763 1
systemWcwidthOk(void)
a3766 1
    int last = 1024;
d3768 1
a3768 1
    for (n = 0; n < last; ++n) {
d3794 3
a3796 2
    TRACE(("systemWcwidthOk: %d/%d mismatches\n", oops, last));
    return (oops < (last / 4));
d3801 1
a3801 1
decode_wcwidth(int mode)
d3806 1
a3806 1
	if (xtermEnvUTF8() && systemWcwidthOk()) {
d3812 4
a3816 1
#endif
@


1.1.1.1
log
@Importing xterm 216
@
text
@@


1.1.1.2
log
@import xterm 225
@
text
@d1 1
a1 1
/* $XTermId: util.c,v 1.351 2007/03/21 22:04:14 tom Exp $ */
d6 1
a6 1
 * Copyright 1999-2006,2007 by Thomas E. Dickey
d1278 1
a1278 1
		  NormalGC(xw, screen),
a1398 11
static void
set_background(XtermWidget xw, int color GCC_UNUSED)
{
    TScreen *screen = &(xw->screen);
    Pixel c = getXtermBackground(xw, xw->flags, color);

    TRACE(("set_background(%d) %#lx\n", color, c));
    XSetWindowBackground(screen->display, VShellWindow, c);
    XSetWindowBackground(screen->display, VWindow(screen), c);
}

a1414 1
    int result = 0;
a1424 11
    if ((x0 < 0 ||
	 y0 < 0 ||
	 x1 > Width(screen) ||
	 y1 > Height(screen))) {
	set_background(xw, -1);
	XClearArea(screen->display, VWindow(screen),
		   rect_x,
		   rect_y,
		   rect_width,
		   rect_height, False);
    }
d1446 2
a1447 2
	ScrnRefresh(xw, toprow, leftcol, nrows, ncols, True);
	if (resource.wait_for_map) {
d1453 2
a1454 3
	    screen->cur_col < leftcol + ncols) {
	    result = 1;
	}
d1457 1
a1457 2
    TRACE(("...handle_translated_exposure %d\n", result));
    return (result);
d1479 3
a1481 1
    VTwin *win = WhichVWin(screen);
d1501 4
a1504 4
	    setCgsFore(xw, win, gcNorm, fg);
	    setCgsBack(xw, win, gcNormReverse, fg);
	    setCgsFore(xw, win, gcBold, fg);
	    setCgsBack(xw, win, gcBoldReverse, fg);
d1514 6
a1519 5
	    setCgsBack(xw, win, gcNorm, bg);
	    setCgsFore(xw, win, gcNormReverse, bg);
	    setCgsBack(xw, win, gcBold, bg);
	    setCgsFore(xw, win, gcBoldReverse, bg);
	    set_background(xw, -1);
a1528 5
    if (COLOR_DEFINED(pNew, HIGHLIGHT_FG)) {
	T_COLOR(screen, HIGHLIGHT_FG) = COLOR_VALUE(pNew, HIGHLIGHT_FG);
	TRACE(("... HIGHLIGHT_FG: %#lx\n", T_COLOR(screen, HIGHLIGHT_FG)));
	repaint = screen->Vshow;
    }
d1541 11
a1551 8
	if (screen->Vshow) {
	    recolor_cursor(screen,
			   screen->pointer_cursor,
			   T_COLOR(screen, MOUSE_FG),
			   T_COLOR(screen, MOUSE_BG));
	    XDefineCursor(screen->display, VWindow(screen),
			  screen->pointer_cursor);
	}
d1553 2
a1554 11
	if (TEK4014_SHOWN(xw)) {
	    TekScreen *tekscr = &(tekWidget->screen);
	    Window tekwin = TWindow(tekscr);
	    if (tekwin) {
		recolor_cursor(screen,
			       tekscr->arrow,
			       T_COLOR(screen, MOUSE_FG),
			       T_COLOR(screen, MOUSE_BG));
		XDefineCursor(screen->display, tekwin, tekscr->arrow);
	    }
	}
d1567 4
a1570 3
	ChangeTekColors(tekWidget, screen, pNew);
	if (TEK4014_SHOWN(xw)) {
	    TekRepaint(tekWidget);
d1573 1
a1573 1
	ChangeTekColors(tekWidget, screen, pNew);
d1576 5
a1580 2
    if (repaint)
	xtermRepaint(xw);
d1584 1
a1584 1
xtermClear(XtermWidget xw)
a1587 1
    TRACE(("xtermClear\n"));
d1589 3
a1591 10
}

void
xtermRepaint(XtermWidget xw)
{
    TScreen *screen = &xw->screen;

    TRACE(("xtermRepaint\n"));
    xtermClear(xw);
    ScrnRefresh(xw, 0, 0, MaxRows(screen), MaxCols(screen), True);
a1595 54
typedef struct {
    Pixel fg;
    Pixel bg;
} ToSwap;

static void
swapLocally(ToSwap * list, int *count, ColorRes * fg, ColorRes * bg)
{
    ColorRes tmp;
    int n;
    Boolean found = False;

#if OPT_COLOR_RES
    Pixel fg_color = fg->value;
    Pixel bg_color = bg->value;
#else
    Pixel fg_color = *fg;
    Pixel bg_color = *bg;
#endif

    EXCHANGE(*fg, *bg, tmp);
    for (n = 0; n < *count; ++n) {
	if ((list[n].fg == fg_color && list[n].bg == bg_color)
	    || (list[n].fg == bg_color && list[n].bg == fg_color)) {
	    found = True;
	    break;
	}
    }
    if (!found) {
	list[*count].fg = fg_color;
	list[*count].bg = bg_color;
	*count = *count + 1;
    }
}

static void
reallySwapColors(XtermWidget xw, ToSwap * list, int count)
{
    int j, k;

    for (j = 0; j < count; ++j) {
	for_each_text_gc(k) {
	    redoCgs(xw, list[j].fg, list[j].bg, (CgsEnum) k);
	}
    }
}

static void
swapVTwinGCs(XtermWidget xw, VTwin * win)
{
    swapCgs(xw, win, gcNorm, gcNormReverse);
    swapCgs(xw, win, gcBold, gcBoldReverse);
}

d1600 5
a1604 2
    ToSwap listToSwap[5];
    int numToSwap = 0;
a1616 2
#define swapAnyColor(name,a,b) swapLocally(listToSwap, &numToSwap, &(screen->name[a]), &(screen->name[b]))
#define swapAColor(a,b) swapAnyColor(Acolors, a, b)
d1618 3
a1620 2
	swapAColor(0, 7);
	swapAColor(8, 15);
d1623 9
a1631 7
#define swapTColor(a,b) swapAnyColor(Tcolors, a, b)
    swapTColor(TEXT_FG, TEXT_BG);
    swapTColor(MOUSE_FG, MOUSE_BG);

    reallySwapColors(xw, listToSwap, numToSwap);

    swapVTwinGCs(xw, &(screen->fullVwin));
d1633 7
a1639 1
    swapVTwinGCs(xw, &(screen->iconVwin));
d1642 9
d1654 1
a1654 7
	if (screen->Vshow) {
	    recolor_cursor(screen,
			   screen->pointer_cursor,
			   T_COLOR(screen, MOUSE_FG),
			   T_COLOR(screen, MOUSE_BG));
	    XDefineCursor(screen->display, VWindow(screen), screen->pointer_cursor);
	}
d1657 2
a1658 9
    if (TEK4014_SHOWN(xw)) {
	TekScreen *tekscr = &(tekWidget->screen);
	Window tekwin = TWindow(tekscr);
	recolor_cursor(screen,
		       tekscr->arrow,
		       T_COLOR(screen, MOUSE_FG),
		       T_COLOR(screen, MOUSE_BG));
	XDefineCursor(screen->display, tekwin, tekscr->arrow);
    }
d1665 8
a1672 1
	set_background(xw, -1);
d1675 1
a1675 1
    TekReverseVideo(tekWidget);
d1678 3
a1680 1
	xtermRepaint(xw);
d1683 3
a1685 2
    if (TEK4014_SHOWN(xw)) {
	TekRepaint(tekWidget);
d1713 1
a1713 1
getXftColor(XtermWidget xw, Pixel pixel)
a1751 29
 * The cell-width is related to, but not the same as the wide-character width.
 * We will only get useful values from wcwidth() for codes above 255.
 * Otherwise, interpret according to internal data.
 */
#if OPT_RENDERWIDE
static int
xtermCellWidth(XtermWidget xw, wchar_t ch)
{
    int result = 0;

    (void) xw;
    if (ch == 0 || ch == 127) {
	result = 0;
    } else if (ch < 256) {
#if OPT_C1_PRINT
	if (ch >= 128 && ch < 160) {
	    result = (xw->screen.c1_printable ? 1 : 0);
	} else
#endif

	    result = 1;		/* 1..31 are line-drawing characters */
    } else {
	result = my_wcwidth(ch);
    }
    return result;
}
#endif /* OPT_RENDERWIDE */

/*
d1761 2
a1762 2
static int
xtermXftDrawString(XtermWidget xw,
d1770 2
a1771 1
		   Bool really)
a1772 4
    TScreen *screen = &(xw->screen);
    int ncells = 0;

    if (len != 0) {
d1774 11
a1784 11
	static XftCharSpec *sbuf;
	static int slen = 0;

	XftFont *wfont;
	int src, dst;
	XftFont *lastFont = 0;
	XftFont *currFont = 0;
	int start = 0;
	int charWidth;
	int fontnum = screen->menu_font_number;
	int fwidth = FontWidth(screen);
d1786 3
d1790 5
a1794 5
	if ((flags & UNDERLINE)
	    && screen->italicULMode
	    && screen->renderWideItal[fontnum]) {
	    wfont = screen->renderWideItal[fontnum];
	} else
d1796 6
a1801 6
	    if ((flags & BOLDATTR(screen))
		&& screen->renderWideBold[fontnum]) {
	    wfont = screen->renderWideBold[fontnum];
	} else {
	    wfont = screen->renderWideNorm[fontnum];
	}
d1803 5
a1807 5
	if ((int) slen < len) {
	    slen = (len + 1) * 2;
	    sbuf = (XftCharSpec *) XtRealloc((char *) sbuf,
					     slen * sizeof(XftCharSpec));
	}
d1809 28
a1836 2
	for (src = dst = 0; src < len; src++) {
	    FcChar32 wc = *text++;
d1838 3
a1840 10
	    if (text2)
		wc |= (*text2++ << 8);

	    charWidth = xtermCellWidth(xw, wc);
	    if (charWidth < 0)
		continue;

	    sbuf[dst].ucs4 = wc;
	    sbuf[dst].x = x + fwidth * ncells;
	    sbuf[dst].y = y;
d1842 6
a1847 32
	    currFont = (charWidth == 2 && wfont != 0) ? wfont : font;
	    ncells += charWidth;

	    if (lastFont != currFont) {
		if ((lastFont != 0) && really) {
		    XftDrawCharSpec(screen->renderDraw,
				    color,
				    lastFont,
				    sbuf + start,
				    dst - start);
		}
		start = dst;
		lastFont = currFont;
	    }
	    ++dst;
	}
	if ((dst != start) && really) {
	    XftDrawCharSpec(screen->renderDraw,
			    color,
			    lastFont,
			    sbuf + start,
			    dst - start);
	}
#else /* !OPT_RENDERWIDE */
	PAIRED_CHARS((void) text, (void) text2);
	if (really) {
	    XftDrawString8(screen->renderDraw,
			   color,
			   font,
			   x, y, (unsigned char *) text, len);
	}
	ncells = len;
a1848 2
    }
    return ncells;
a1856 38
 * Map characters commonly "fixed" by groff back to their ASCII equivalents.
 * Also map other useful equivalents.
 */
unsigned
AsciiEquivs(unsigned ch)
{
    switch (ch) {
    case 0x2010:		/* groff "-" */
    case 0x2011:
    case 0x2012:
    case 0x2013:
    case 0x2014:
    case 0x2015:
    case 0x2212:		/* groff "\-" */
	ch = '-';
	break;
    case 0x2018:		/* groff "`" */
	ch = '`';
	break;
    case 0x2019:		/* groff ' */
	ch = '\'';
	break;
    case 0x201C:		/* groff lq */
    case 0x201D:		/* groff rq */
	ch = '"';
	break;
    default:
	if (ch >= 0xff01 && ch <= 0xff5e) {
	    /* "Fullwidth" codes (actually double-width) */
	    ch -= 0xff00;
	    ch += ANSI_SPA;
	    break;
	}
    }
    return ch;
}

/*
d1875 26
a1900 3
	unsigned eqv = AsciiEquivs(ch);

	if (eqv != ch) {
d1904 1
a1904 1
	    text[0] = eqv;
a1920 93
/*
 * Use this when the characters will not fill the cell area properly.  Fill the
 * area where we'll write the characters, otherwise we'll get gaps between
 * them, e.g., in the original background color.
 *
 * The cursor is a special case, because the XFillRectangle call only uses the
 * foreground, while we've set the cursor color in the background.  So we need
 * a special GC for that.
 */
static void
xtermFillCells(XtermWidget xw,
	       unsigned flags,
	       GC gc,
	       int x,
	       int y,
	       Cardinal len)
{
    TScreen *screen = &(xw->screen);
    VTwin *currentWin = WhichVWin(screen);

    if (!(flags & NOBACKGROUND)) {
	CgsEnum srcId = getCgsId(xw, currentWin, gc);
	CgsEnum dstId = gcMAX;
	Pixel fg = getCgsFore(xw, currentWin, gc);
	Pixel bg = getCgsBack(xw, currentWin, gc);

	switch (srcId) {
	case gcVTcursNormal:
	case gcVTcursReverse:
	    dstId = gcVTcursOutline;
	    break;
	case gcVTcursFilled:
	case gcVTcursOutline:
	    /* FIXME */
	    break;
	case gcNorm:
	    dstId = gcNormReverse;
	    break;
	case gcNormReverse:
	    dstId = gcNorm;
	    break;
	case gcBold:
	    dstId = gcBoldReverse;
	    break;
	case gcBoldReverse:
	    dstId = gcBold;
	    break;
#if OPT_BOX_CHARS
	case gcLine:
	case gcDots:
	    /* FIXME */
	    break;
#endif
#if OPT_DEC_CHRSET
	case gcCNorm:
	case gcCBold:
	    /* FIXME */
	    break;
#endif
#if OPT_WIDE_CHARS
	case gcWide:
	    dstId = gcWideReverse;
	    break;
	case gcWBold:
	    dstId = gcBoldReverse;
	    break;
	case gcWideReverse:
	case gcWBoldReverse:
	    /* FIXME */
	    break;
#endif
#if OPT_TEK4014
	case gcTKcurs:
	    /* FIXME */
	    break;
#endif
	case gcMAX:
	    break;
	}

	if (dstId != gcMAX) {
	    setCgsFore(xw, currentWin, dstId, bg);
	    setCgsBack(xw, currentWin, dstId, fg);

	    XFillRectangle(screen->display, VWindow(screen),
			   getCgsGC(xw, currentWin, dstId),
			   x, y,
			   len * FontWidth(screen),
			   (unsigned) FontHeight(screen));
	}
    }
}

d1927 1
a1927 1
	    if (screen->use_clipping && (pwidth > 2)) { \
a1945 21
#if OPT_CLIP_BOLD && OPT_RENDERFONT && defined(HAVE_XFTDRAWSETCLIP) && defined(HAVE_XFTDRAWSETCLIPRECTANGLES)
#define beginXftClipping(screen,px,py,plength) \
	    if (screen->use_clipping && (FontWidth(screen) > 2)) { \
		XRectangle clip; \
		int clip_x = px; \
		int clip_y = py - FontHeight(screen) + FontDescent(screen); \
		clip.x = 0; \
		clip.y = 0; \
		clip.height = FontHeight(screen); \
		clip.width = FontWidth(screen) * plength; \
		XftDrawSetClipRectangles (screen->renderDraw, \
					  clip_x, clip_y, \
					  &clip, 1); \
	    }
#define endXftClipping(screen) \
	    XftDrawSetClip (screen->renderDraw, 0)
#else
#define beginXftClipping(screen,px,py,plength)	/* nothing */
#define endXftClipping(screen)	/* nothing */
#endif /* OPT_CLIP_BOLD */

d1995 1
a1995 1
		  ? xterm_DoubleGC(xw, (unsigned) chrset, flags, gc)
d2004 1
a2004 1
	    int inx = xterm_Double_index(xw, (unsigned) chrset, flags);
a2118 1
	VTwin *currentWin = WhichVWin(screen);
a2122 1
	int ncells;
d2148 2
a2149 11
	values.foreground = getCgsFore(xw, currentWin, gc);
	values.background = getCgsBack(xw, currentWin, gc);

	if (!(flags & NOBACKGROUND)) {
	    XftColor *bg_color = getXftColor(xw, values.background);
	    ncells = xtermXftDrawString(xw, flags,
					bg_color,
					font, x, y,
					PAIRED_CHARS(text, text2),
					len,
					False);
d2151 1
a2151 1
			bg_color,
d2153 1
a2153 1
			ncells * FontWidth(screen),
a2154 1
	}
d2166 1
d2191 9
a2199 8
			ncells = xtermXftDrawString(xw, flags,
						    getXftColor(xw, values.foreground),
						    font, curX, y,
						    PAIRED_CHARS(text + first,
								 text2 + first),
						    last - first,
						    True);
			curX += ncells * FontWidth(screen);
d2214 2
a2215 3
		beginXftClipping(screen, curX, y, len);
		xtermXftDrawString(xw, flags,
				   getXftColor(xw, values.foreground),
d2219 2
a2220 2
				   True);
		endXftClipping(screen);
d2225 4
a2228 8
	    beginXftClipping(screen, x, y, len);
	    xtermXftDrawString(xw, flags,
			       getXftColor(xw, values.foreground),
			       font, x, y,
			       PAIRED_CHARS(text, text2),
			       (int) len,
			       True);
	    endXftClipping(screen);
d2250 1
d2255 22
a2276 1
	xtermFillCells(xw, flags, gc, x, y, len);
d2310 2
a2311 2
				      && okFont(NormalWFont(screen)))
				     ? NormalWFont(screen)
d2368 1
a2368 1
			    && okFont(NormalWFont(screen))));
d2400 2
a2401 2
		&& (*text == ANSI_DEL || *text < ANSI_SPA)) {
		int ni = dec2ucs((unsigned) ((*text == ANSI_DEL) ? 0 : *text));
d2422 10
a2431 21
	if (!(flags & (DOUBLEHFONT | DOUBLEWFONT))) {
	    VTwin *currentWin = WhichVWin(screen);
	    VTFontEnum fntId;
	    CgsEnum cgsId;
	    Pixel fg = getCgsFore(xw, currentWin, gc);
	    Pixel bg = getCgsBack(xw, currentWin, gc);

	    if (wideness
		&& (okFont(NormalWFont(screen)) || okFont(BoldWFont(screen)))) {
		if ((flags & BOLDATTR(screen)) != 0
		    && okFont(BoldWFont(screen))) {
		    fntId = fWBold;
		    cgsId = gcWBold;
		} else {
		    fntId = fWide;
		    cgsId = gcWide;
		}
	    } else if ((flags & BOLDATTR(screen)) != 0
		       && okFont(BoldFont(screen))) {
		fntId = fBold;
		cgsId = gcBold;
d2433 2
a2434 11
		fntId = fNorm;
		cgsId = gcNorm;
	    }

	    setCgsFore(xw, currentWin, cgsId, fg);
	    setCgsBack(xw, currentWin, cgsId, bg);
	    gc = getCgsGC(xw, currentWin, cgsId);

	    if (fntId != fNorm) {
		XFontStruct *thisFp = WhichVFont(screen, fnts[fntId]);
		ascent_adjust = (thisFp->ascent
a2435 12
		if (thisFp->max_bounds.width ==
		    NormalFont(screen)->max_bounds.width * 2) {
		    underline_len = real_length = len * 2;
		} else if (cgsId == gcWide || cgsId == gcWBold) {
		    underline_len = real_length = len * 2;
		    xtermFillCells(xw,
				   flags,
				   gc,
				   x,
				   y - thisFp->ascent,
				   real_length);
		}
d2437 6
d2445 1
a2445 1
	if (flags & NOBACKGROUND) {
d2450 1
a2450 1
	} else {
a2454 1
	}
d2470 1
a2470 1
	if (flags & NOBACKGROUND) {
d2473 1
a2473 1
	} else {
a2475 1
	}
a2528 12
void
getXtermSizeHints(XtermWidget xw)
{
    TScreen *screen = &xw->screen;
    long supp;

    if (!XGetWMNormalHints(screen->display, XtWindow(SHELL_OF(xw)),
			   &xw->hints, &supp))
	bzero(&xw->hints, sizeof(xw->hints));
    TRACE_HINTS(&(xw->hints));
}

a2537 2
    VTwin *win = WhichVWin(screen);
    CgsEnum cgsId = gcMAX;
d2544 1
a2544 2
    Pixel selbg_pix = T_COLOR(screen, HIGHLIGHT_BG);
    Pixel selfg_pix = T_COLOR(screen, HIGHLIGHT_FG);
d2546 1
d2554 6
d2561 7
a2567 9
    if (hilite) {
	Bool use_selbg = isNotForeground(xw, fg_pix, bg_pix, selbg_pix);
	Bool use_selfg = isNotBackground(xw, fg_pix, bg_pix, selfg_pix);

	if (use_selbg)
	    fg_pix = selbg_pix;
	if (use_selfg)
	    bg_pix = selfg_pix;
    }
d2569 8
a2577 13
    if (ReverseOrHilite(screen, flags, hilite)) {
	if (flags & BOLDATTR(screen)) {
	    cgsId = gcBoldReverse;
	} else {
	    cgsId = gcNormReverse;
	}
	EXCHANGE(fg_pix, bg_pix, xx_pix);
    } else {
	if (flags & BOLDATTR(screen)) {
	    cgsId = gcBold;
	} else {
	    cgsId = gcNorm;
	}
d2586 3
a2588 3
    setCgsFore(xw, win, cgsId, fg_pix);
    setCgsBack(xw, win, cgsId, bg_pix);
    return getCgsGC(xw, win, cgsId);
a2599 2
    VTwin *win = WhichVWin(screen);
    CgsEnum cgsId = gcMAX;
d2602 1
d2607 4
a2610 5
	if (flags & BOLDATTR(screen)) {
	    cgsId = gcBoldReverse;
	} else {
	    cgsId = gcNormReverse;
	}
d2612 2
a2613 2
	setCgsFore(xw, win, cgsId, bg_pix);
	setCgsBack(xw, win, cgsId, fg_pix);
d2616 4
a2619 5
	if (flags & BOLDATTR(screen)) {
	    cgsId = gcBold;
	} else {
	    cgsId = gcNorm;
	}
d2621 2
a2622 2
	setCgsFore(xw, win, cgsId, fg_pix);
	setCgsBack(xw, win, cgsId, bg_pix);
d2698 10
a2707 11
    TRACE(("ClearCurBackground(%d,%d,%d,%d) %d\n",
	   top, left, height, width, xw->cur_background));

    if (VWindow(screen)) {
	set_background(xw, xw->cur_background);

	XClearArea(screen->display, VWindow(screen),
		   left, top, width, height, False);

	set_background(xw, -1);
    }
a2827 1
    update_tcap_fkeys();
a2918 3
#endif
#if OPT_TCAP_FKEYS
	    DATA(NAME_TCAP_KT, keyboardIsTermcap, termcapKeys),
@


1.1.1.3
log
@import xterm 229
@
text
@d1 3
a3 1
/* $XTermId: util.c,v 1.385 2007/07/22 20:43:06 tom Exp $ */
d78 1
a98 46
#if OPT_WIDE_CHARS
/*
 * We will modify the 'n' cells beginning at the current position.
 * Some of those cells may be part of multi-column characters, including
 * carryover from the left.  Find the limits of the multi-column characters
 * that we should fill with blanks, return true if filling is needed.
 */
int
DamagedCells(TScreen * screen, unsigned n, int *klp, int *krp, int row, int col)
{
    int kl = col;
    int kr = col + n;

    if (XTERM_CELL(row, kl) == HIDDEN_CHAR) {
	while (kl > 0) {
	    if (XTERM_CELL(row, --kl) != HIDDEN_CHAR) {
		break;
	    }
	}
    } else {
	kl = col + 1;
    }
    if (XTERM_CELL(row, kr) == HIDDEN_CHAR) {
	while (kr < screen->max_col) {
	    if (XTERM_CELL(row, ++kr) != HIDDEN_CHAR) {
		--kr;
		break;
	    }
	}
    } else {
	kr = col - 1;
    }
    if (klp)
	*klp = kl;
    if (krp)
	*krp = kr;
    return (kr >= kl);
}

int
DamagedCurCells(TScreen * screen, unsigned n, int *klp, int *krp)
{
    return DamagedCells(screen, n, klp, krp, screen->cur_row, screen->cur_col);
}
#endif /* OPT_WIDE_CHARS */

a181 5
/*
 * Returns true if there are lines off-screen due to scrolling which should
 * include the current line.  If false, the line is visible and we should
 * paint it now rather than waiting for the line to become visible.
 */
d183 1
a183 1
AddToRefresh(XtermWidget xw)
a184 1
    TScreen *screen = &(xw->screen);
a186 1
    int result;
d189 1
a189 1
	result = 0;
d195 1
a195 3
	    result = 1;
	} else {
	    result = (row >= bottom - amount + 1 && row <= bottom);
d197 1
d204 1
a204 30
	    result = 1;
	} else {
	    result = (row <= top + amount - 1 && row >= top);
	}
    }

    /*
     * If this line is visible, and there are scrolled-off lines, flush out
     * those which are now visible.
     */
    if (!result && screen->scroll_amt)
	FlushScroll(xw);

    return result;
}

/*
 * Returns true if the current row is in the visible area (it should be for
 * screen operations) and incidentally flush the scrolled-in lines which
 * have newly become visible.
 */
static Bool
AddToVisible(XtermWidget xw)
{
    TScreen *screen = &(xw->screen);
    Bool result = False;

    if (INX2ROW(screen, screen->cur_row) <= screen->max_row) {
	if (!AddToRefresh(xw)) {
	    result = True;
d206 1
a207 1
    return result;
a549 113
 * write a string str of length len onto the screen at
 * the current cursor position.  update cursor position.
 */
void
WriteText(XtermWidget xw, PAIRED_CHARS(Char * str, Char * str2), Cardinal len)
{
    TScreen *screen = &(xw->screen);
    ScrnPtr temp_str = 0;
    unsigned test;
    unsigned flags = xw->flags;
    unsigned fg_bg = makeColorPair(xw->cur_foreground, xw->cur_background);
    unsigned cells = visual_width(PAIRED_CHARS(str, str2), len);
    GC currentGC;

    TRACE(("WriteText (%2d,%2d) (%d) %3d:%s\n",
	   screen->cur_row,
	   screen->cur_col,
	   curXtermChrSet(xw, screen->cur_row),
	   len, visibleChars(PAIRED_CHARS(str, str2), len)));

    if (ScrnHaveSelection(screen)
	&& ScrnIsLineInSelection(screen, INX2ROW(screen, screen->cur_row))) {
	ScrnDisownSelection(xw);
    }

    /* if we are in insert-mode, reserve space for the new cells */
    if (flags & INSERT) {
	InsertChar(xw, cells);
    }

    if (AddToVisible(xw)) {
	if (screen->cursor_state)
	    HideCursor();

	/*
	 * If we overwrite part of a multi-column character, fill the rest
	 * of it with blanks.
	 */
	if_OPT_WIDE_CHARS(screen, {
	    int kl;
	    int kr;
	    if (DamagedCurCells(screen, cells, &kl, &kr))
		ClearInLine(xw, screen->cur_row, kl, (unsigned) (kr - kl + 1));
	});

	if (flags & INVISIBLE) {
	    if (cells > len) {
		str = temp_str = TypeMallocN(Char, cells);
		if (str == 0)
		    return;
	    }
	    len = cells;

	    memset(str, ' ', len);
	    if_OPT_WIDE_CHARS(screen, {
		str2 = 0;
	    });
	}

	TRACE(("WriteText calling drawXtermText (%d,%d)\n",
	       screen->cur_col,
	       screen->cur_row));

	test = flags;
	checkVeryBoldColors(test, xw->cur_foreground);

	/* make sure that the correct GC is current */
	currentGC = updatedXtermGC(xw, flags, fg_bg, False);

	drawXtermText(xw, test & DRAWX_MASK, currentGC,
		      CurCursorX(screen, screen->cur_row, screen->cur_col),
		      CursorY(screen, screen->cur_row),
		      curXtermChrSet(xw, screen->cur_row),
		      PAIRED_CHARS(str, str2), len, 0);

	resetXtermGC(xw, flags, False);
    }

    ScrnWriteText(xw, PAIRED_CHARS(str, str2), flags, fg_bg, len);
    CursorForward(screen, (int) cells);
#if OPT_ZICONBEEP
    /* Flag icon name with "***"  on window output when iconified.
     */
    if (resource.zIconBeep && mapstate == IsUnmapped && !screen->zIconBeep_flagged) {
	static char *icon_name;
	static Arg args[] =
	{
	    {XtNiconName, (XtArgVal) & icon_name}
	};

	icon_name = NULL;
	XtGetValues(toplevel, args, XtNumber(args));

	if (icon_name != NULL) {
	    screen->zIconBeep_flagged = True;
	    ChangeIconName(icon_name);
	}
	if (resource.zIconBeep > 0) {
#if defined(HAVE_XKB_BELL_EXT)
	    XkbBell(XtDisplay(toplevel), VShellWindow, resource.zIconBeep, XkbBI_Info);
#else
	    XBell(XtDisplay(toplevel), resource.zIconBeep);
#endif
	}
    }
    mapstate = -1;
#endif /* OPT_ZICONBEEP */
    if (temp_str != 0)
	free(temp_str);
    return;
}

/*
d749 5
a753 2
    if (AddToVisible(xw)) {
	int col = MaxCols(screen) - n;
d755 3
a757 16
	/*
	 * If we shift part of a multi-column character, fill the rest
	 * of it with blanks.  Do similar repair for the text which will
	 * be shifted into the right-margin.
	 */
	if_OPT_WIDE_CHARS(screen, {
	    int kl;
	    int kr = screen->cur_col;
	    if (DamagedCurCells(screen, n, &kl, (int *) 0) && kr > kl) {
		ClearInLine(xw, screen->cur_row, kl, (unsigned) (kr - kl + 1));
	    }
	    kr = screen->max_col - n + 1;
	    if (DamagedCells(screen, n, &kl, (int *) 0,
			     screen->cur_row,
			     kr) && kr > kl) {
		ClearInLine(xw, screen->cur_row, kl, (unsigned) (kr - kl + 1));
d759 10
a768 1
	});
d770 5
a774 14
#if OPT_DEC_CHRSET
	if (CSET_DOUBLE(SCRN_BUF_CSETS(screen, screen->cur_row)[0])) {
	    col = MaxCols(screen) / 2 - n;
	}
#endif
	/*
	 * prevent InsertChar from shifting the end of a line over
	 * if it is being appended to
	 */
	if (non_blank_line(screen, screen->cur_row,
			   screen->cur_col, MaxCols(screen))) {
	    horizontal_copy_area(xw, screen->cur_col,
				 col - screen->cur_col,
				 (int) n);
a775 6

	ClearCurBackground(xw,
			   CursorY(screen, screen->cur_row),
			   CurCursorX(screen, screen->cur_row, screen->cur_col),
			   (unsigned) FontHeight(screen),
			   n * CurFontWidth(screen, screen->cur_row));
d809 5
a813 13
    if (AddToVisible(xw)) {
	int col = MaxCols(screen) - n;

	/*
	 * If we delete part of a multi-column character, fill the rest
	 * of it with blanks.
	 */
	if_OPT_WIDE_CHARS(screen, {
	    int kl;
	    int kr;
	    if (DamagedCurCells(screen, n, &kl, &kr))
		ClearInLine(xw, screen->cur_row, kl, (unsigned) (kr - kl + 1));
	});
d816 3
a818 3
	if (CSET_DOUBLE(SCRN_BUF_CSETS(screen, screen->cur_row)[0])) {
	    col = MaxCols(screen) / 2 - n;
	}
d820 4
a823 4
	horizontal_copy_area(xw,
			     (int) (screen->cur_col + n),
			     col - screen->cur_col,
			     -((int) n));
d825 6
a830 5
	ClearCurBackground(xw,
			   CursorY(screen, screen->cur_row),
			   CurCursorX(screen, screen->cur_row, col),
			   (unsigned) FontHeight(screen),
			   n * CurFontWidth(screen, screen->cur_row));
d832 1
a832 1
    if (n != 0) {
d834 1
a834 1
	ScrnDeleteChar(xw, n);
d919 1
a919 1
ClearInLine2(XtermWidget xw, int flags, int row, int col, unsigned len)
d923 1
d935 9
a943 1
    if (col + (int) len >= MaxCols(screen)) {
d991 10
a1000 6
    if (AddToVisible(xw)) {
	ClearCurBackground(xw,
			   CursorY(screen, row),
			   CurCursorX(screen, row, col),
			   (unsigned) FontHeight(screen),
			   len * CurFontWidth(screen, row));
d1004 23
a1026 1
	ClearCells(xw, flags, len, row, col);
a1031 18
int
ClearInLine(XtermWidget xw, int row, int col, unsigned len)
{
    TScreen *screen = &(xw->screen);
    int flags = 0;

    /*
     * If we're clearing to the end of the line, we won't count this as
     * "drawn" characters.  We'll only do cut/paste on "drawn" characters,
     * so this has the effect of suppressing trailing blanks from a
     * selection.
     */
    if (col + (int) len < MaxCols(screen)) {
	flags |= CHARDRAWN;
    }
    return ClearInLine2(xw, flags, row, col, len);
}

d1053 1
a1053 22
    if (AddToVisible(xw)) {
	if_OPT_WIDE_CHARS(screen, {
	    int col = screen->cur_col;
	    int row = screen->cur_row;
	    int kl;
	    int kr;
	    int xx;
	    if (DamagedCurCells(screen, len, &kl, &kr) && kr >= kl) {
		xx = col;
		if (kl < xx) {
		    ClearInLine2(xw, 0, row, kl, (unsigned) (xx - kl));
		}
		xx = col + len - 1;
		if (kr > xx) {
		    ClearInLine2(xw, 0, row, xx + 1, (unsigned) (kr - xx));
		}
	    }
	});
	(void) ClearInLine(xw, screen->cur_row, screen->cur_col, len);
    } else {
	ScrnClearCells(xw, screen->cur_row, screen->cur_col, len);
    }
d1069 1
a1069 13
    if (AddToVisible(xw)) {
	if_OPT_WIDE_CHARS(screen, {
	    int row = screen->cur_row;
	    int kl;
	    int kr;
	    if (DamagedCurCells(screen, 1, &kl, &kr) && kr >= kl) {
		ClearInLine2(xw, 0, row, kl, (unsigned) (kr - kl + 1));
	    }
	});
	(void) ClearInLine(xw, screen->cur_row, 0, len);
    } else {
	ScrnClearCells(xw, screen->cur_row, 0, len);
    }
d1445 2
a1446 2
		   (unsigned) rect_width,
		   (unsigned) rect_height, False);
d1470 3
a1472 1
	first_map_occurred();
a1637 5
/*
 * Use this to swap the foreground/background color values in the resource
 * data, and to build up a list of the pairs which must be swapped in the
 * GC cache.
 */
d1653 6
a1658 15
    if (fg_color != bg_color) {
	EXCHANGE(*fg, *bg, tmp);
	for (n = 0; n < *count; ++n) {
	    if ((list[n].fg == fg_color && list[n].bg == bg_color)
		|| (list[n].fg == bg_color && list[n].bg == fg_color)) {
		found = True;
		break;
	    }
	}
	if (!found) {
	    list[*count].fg = fg_color;
	    list[*count].bg = bg_color;
	    *count = *count + 1;
	    TRACE(("swapLocally fg %#lx, bg %#lx ->%d\n", fg_color,
		   bg_color, *count));
d1660 5
a1672 1
    TRACE(("reallySwapColors\n"));
a1711 3
    if (T_COLOR(screen, TEXT_CURSOR) == T_COLOR(screen, TEXT_FG))
	T_COLOR(screen, TEXT_CURSOR) = T_COLOR(screen, TEXT_BG);

d1873 1
a1873 1
		   Cardinal len,
d1882 1
a1882 1
	static Cardinal slen = 0;
d1885 1
a1885 1
	Cardinal src, dst;
d1888 1
a1888 1
	Cardinal start = 0;
d1907 1
a1907 1
	if (slen < len) {
d1919 1
a1919 1
	    charWidth = xtermCellWidth(xw, (wchar_t) wc);
d1936 1
a1936 1
				    (int) (dst - start));
d1948 1
a1948 1
			    (int) (dst - start));
a1962 2
#define xtermXftWidth(xw, flags, color, font, x, y, paired_chars, len) \
   xtermXftDrawString(xw, flags, color, font, x, y, paired_chars, len, False)
a1995 6
    case 0x2329:		/* groff ".URL" */
	ch = '<';
	break;
    case 0x232a:		/* groff ".URL" */
	ch = '>';
	break;
a2042 3
	    fixed = True;
	} else if (ch == HIDDEN_CHAR) {
	    fixed = True;
a2187 30
#if OPT_RENDERFONT
static int
drawClippedXftString(XtermWidget xw,
		     unsigned flags,
		     XftFont * font,
		     XftColor * fg_color,
		     int x,
		     int y,
		     PAIRED_CHARS(Char * text, Char * text2),
		     Cardinal len)
{
    int ncells = xtermXftWidth(xw, flags,
			       fg_color,
			       font, x, y,
			       PAIRED_CHARS(text, text2),
			       len);
    TScreen *screen = &(xw->screen);

    beginXftClipping(screen, x, y, ncells);
    xtermXftDrawString(xw, flags,
		       fg_color,
		       font, x, y,
		       PAIRED_CHARS(text, text2),
		       len,
		       True);
    endXftClipping(screen);
    return ncells;
}
#endif

d2204 2
a2205 2
    Cardinal real_length = len;
    Cardinal underline_len = 0;
d2240 1
a2240 1
	TRACE(("DRAWTEXT%c[%4d,%4d] (%d) %d:%s\n",
d2242 1
a2242 2
	       y, x, chrset, len,
	       visibleChars(PAIRED_CHARS(text, text2), len)));
d2397 6
a2402 5
	    ncells = xtermXftWidth(xw, flags,
				   bg_color,
				   font, x, y,
				   PAIRED_CHARS(text, text2),
				   len);
d2406 1
a2406 1
			(unsigned) (ncells * FontWidth(screen)),
d2444 8
a2451 11
			int nc = drawClippedXftString(xw,
						      flags,
						      font,
						      getXftColor(xw, values.foreground),
						      curX,
						      y,
						      PAIRED_CHARS(text + first,
								   text2 + first),
						      (Cardinal) (last - first));
			curX += nc * FontWidth(screen);
			underline_len += nc;
a2459 1
		    underline_len += 1;
d2466 8
a2473 10
		underline_len +=
		    drawClippedXftString(xw,
					 flags,
					 font,
					 getXftColor(xw, values.foreground),
					 curX,
					 y,
					 PAIRED_CHARS(text + first,
						      text2 + first),
					 (Cardinal) (last - first));
d2478 8
a2485 9
	    underline_len +=
		drawClippedXftString(xw,
				     flags,
				     font,
				     getXftColor(xw, values.foreground),
				     x,
				     y,
				     PAIRED_CHARS(text, text2),
				     len);
d2493 1
a2493 1
		      x + (int) underline_len * FontWidth(screen) - 1,
d2542 6
a2547 12
	    if (ch == HIDDEN_CHAR) {
		if (last > first)
		    DrawSegment(first, last);
		first = last + 1;
		continue;
	    }
	    isMissing =
		xtermMissingChar(xw, ch,
				 ((on_wide || my_wcwidth((int) ch) > 1)
				  && okFont(NormalWFont(screen)))
				 ? NormalWFont(screen)
				 : font);
d2587 2
a2588 1
     * or the caller made sure that there is none).
a2597 1
	Bool needWide = False;
d2599 6
a2604 2
	int src, dst;

d2611 3
a2613 16

	for (src = dst = 0; src < (int) len; src++) {
	    unsigned ch = text[src] | (text2[src] << 8);

	    if (ch == HIDDEN_CHAR)
		continue;

	    if (!needWide
		&& !IsIcon(screen)
		&& ((on_wide || my_wcwidth((int) ch) > 1)
		    && okFont(NormalWFont(screen)))) {
		needWide = True;
	    }

	    screen->draw_buf[dst].byte2 = text[src];
	    screen->draw_buf[dst].byte1 = text2[src];
d2615 4
a2618 6
#define UCS2SBUF(value)	screen->draw_buf[dst].byte2 = (value & 0xff);\
	    		screen->draw_buf[dst].byte1 = (value >> 8)

#define Map2Sbuf(from,to) (text[src] == from) { UCS2SBUF(to); }

	    if (screen->latin9_mode && !screen->utf8_mode && text2[src] == 0) {
d2622 8
a2629 8
		if Map2Sbuf(0xa4, 0x20ac)
		else if Map2Sbuf(0xa6, 0x0160)
		else if Map2Sbuf(0xa8, 0x0161)
		else if Map2Sbuf(0xb4, 0x017d)
		else if Map2Sbuf(0xb8, 0x017e)
		else if Map2Sbuf(0xbc, 0x0152)
		else if Map2Sbuf(0xbd, 0x0153)
		else if Map2Sbuf(0xbe, 0x0178)
d2634 4
a2637 7
		&& text2[src] == 0
		&& (text[src] == ANSI_DEL ||
		    text[src] < ANSI_SPA)) {
		int ni = dec2ucs((unsigned) ((text[src] == ANSI_DEL)
					     ? 0
					     : text[src]));
		UCS2SBUF(ni);
d2640 12
a2651 1
	    ++dst;
d2653 1
a2653 1
	/* FIXME This is probably wrong. But it works. */
d2664 1
a2664 1
	    if (needWide
d2693 1
a2693 1
		    underline_len = real_length = dst * 2;
d2695 1
a2695 1
		    underline_len = real_length = dst * 2;
d2710 1
a2710 1
			  screen->draw_buf, dst);
d2715 1
a2715 1
			       screen->draw_buf, dst);
d2723 1
a2723 1
			  screen->draw_buf, dst);
d2752 1
a2752 1
		  x, y, (int) (x + underline_len * font_width - 1), y);
a2822 2
    Boolean use_selbg = isNotForeground(xw, fg_pix, bg_pix, selbg_pix);
    Boolean use_selfg = isNotBackground(xw, fg_pix, bg_pix, selfg_pix);
d2831 12
a2848 1

a2849 14
#if OPT_HIGHLIGHT_COLOR
	if (screen->hilite_reverse) {
	    if (use_selbg) {
		if (use_selfg)
		    bg_pix = fg_pix;
		else
		    fg_pix = bg_pix;
	    }
	    if (use_selbg)
		bg_pix = selbg_pix;
	    if (use_selfg)
		fg_pix = selfg_pix;
	}
#endif
a2856 8
#if OPT_HIGHLIGHT_COLOR
    if (hilite && !screen->hilite_reverse) {
	if (use_selbg)
	    bg_pix = selbg_pix;
	if (use_selfg)
	    fg_pix = selfg_pix;
    }
#endif
d3255 1
a3255 1
systemWcwidthOk(int samplesize, int samplepass)
d3259 1
d3261 1
a3261 1
    for (n = 0; n < (wchar_t) samplesize; ++n) {
d3287 2
a3288 3
    TRACE(("systemWcwidthOk: %d/%d mismatches, allowed %d\n",
	   oops, samplesize, samplepass));
    return (oops <= samplepass);
d3293 1
a3293 1
decode_wcwidth(int mode, int samplesize, int samplepass)
d3298 1
a3298 1
	if (xtermEnvUTF8() && systemWcwidthOk(samplesize, samplepass)) {
d3304 1
a3304 3
#else
	(void) samplesize;
	(void) samplepass;
a3305 1
    case 2:
@


1.1.1.4
log
@Import xterm version 232. tested by many.
@
text
@d1 1
a1 1
/* $XTermId: util.c,v 1.406 2008/01/20 14:19:15 tom Exp $ */
d4 1
a4 1
 * Copyright 1999-2007,2008 by Thomas E. Dickey
a1862 42
Boolean
isDefaultForeground(const char *name)
{
    return !x_strcasecmp(name, XtDefaultForeground);
}

Boolean
isDefaultBackground(const char *name)
{
    return !x_strcasecmp(name, XtDefaultBackground);
}

#if OPT_WIDE_CHARS
/*
 * Check for Unicode BIDI control characters, which may be miscategorized via
 * wcwidth() and iswprint() as zero-width printable characters.
 */
Boolean
isWideControl(unsigned ch)
{
    Boolean result;

    switch (ch) {
    case 0x200E:
    case 0x200F:
    case 0x202A:
    case 0x202B:
    case 0x202C:
    case 0x202D:
    case 0x202E:
	result = True;
	break;
    default:
	result = False;
	break;
    }
    return result;
}
#endif

/***====================================================================***/

a1867 8
#if OPT_HIGHLIGHT_COLOR
#define hc_param ,Bool hilite_color
#define hc_value ,screen->hilite_color
#else
#define hc_param		/* nothing */
#define hc_value		/* nothing */
#endif

d1874 1
a1874 1
swapLocally(ToSwap * list, int *count, ColorRes * fg, ColorRes * bg hc_param)
d1888 1
a1888 4
#if OPT_HIGHLIGHT_COLOR
    if ((fg_color != bg_color) || !hilite_color)
#endif
    {
d1901 2
a1902 2
	    TRACE(("swapLocally fg %#lx, bg %#lx ->%d\n",
		   fg_color, bg_color, *count));
d1945 1
a1945 1
#define swapAnyColor(name,a,b) swapLocally(listToSwap, &numToSwap, &(screen->name[a]), &(screen->name[b]) hc_value)
d1969 7
a1975 1
	xtermDisplayCursor(xw);
a2279 1
	    int width = my_wcwidth((int) ch);
d2285 9
a2293 15

	    do {
		drawXtermText(xw,
			      flags,
			      gc,
			      x,
			      y,
			      chrset,
			      PAIRED_CHARS(text, text2),
			      1,
			      on_wide);
		x += FontWidth(screen);
		text[0] = '?';
	    } while (width-- > 1);

a2395 34
#if OPT_TRACE
static void
xtermSetClipRectangles(Display * dpy,
		       GC gc,
		       int x,
		       int y,
		       XRectangle * rp,
		       Cardinal nr,
		       int order)
{
#if 0
    TScreen *screen = &(term->screen);
    Drawable draw = VWindow(screen);

    XSetClipMask(dpy, gc, None);
    XDrawRectangle(screen->display, draw, gc,
		   x + rp->x - 1,
		   y + rp->y - 1,
		   rp->width,
		   rp->height);
#endif

    XSetClipRectangles(dpy, gc,
		       x, y, rp, nr, order);
    TRACE(("clipping @@(%3d,%3d) (%3d,%3d)..(%3d,%3d)\n",
	   y, x,
	   rp->y, rp->x, rp->height, rp->width));
}

#else
#define xtermSetClipRectangles(dpy, gc, x, y, rp, nr, order) \
	    XSetClipRectangles(dpy, gc, x, y, rp, nr, order)
#endif

d2410 3
a2412 3
		xtermSetClipRectangles(screen->display, gc, \
				       clip_x, clip_y, \
				       &clip, 1, Unsorted); \
a2519 1
	int inx = 0;
d2521 1
a2521 1
		  ? xterm_DoubleGC(xw, (unsigned) chrset, flags, gc, &inx)
d2524 1
a2524 1
	TRACE(("DRAWTEXT%c[%4d,%4d] (%d)%3d:%s\n",
d2530 2
d2533 27
d2561 12
a2572 31
#if OPT_RENDERFONT
	    if (!xw->misc.render_font || IsIconWin(screen, WhichVWin(screen)))
#endif
	    {
		XRectangle rect, *rp = &rect;
		int nr = 1;

		font_width *= 2;
		flags |= DOUBLEWFONT;

		rect.x = 0;
		rect.y = 0;
		rect.width = len * font_width;
		rect.height = FontHeight(screen);

		TRACE(("drawing %s\n", visibleChrsetName(chrset)));
		switch (chrset) {
		case CSET_DHL_TOP:
		    rect.y = -(fs->ascent / 2);
		    y -= rect.y;
		    flags |= DOUBLEHFONT;
		    break;
		case CSET_DHL_BOT:
		    rect.y = rect.height - (fs->ascent / 2);
		    y -= rect.y;
		    flags |= DOUBLEHFONT;
		    break;
		default:
		    nr = 0;
		    break;
		}
d2574 5
a2578 7
		if (nr) {
		    xtermSetClipRectangles(screen->display, gc2,
					   x, y, rp, nr, YXBanded);
		} else {
		    XSetClipMask(screen->display, gc2, None);
		}
	    }
d2696 1
a2696 1
	{
d2703 1
a2703 55
		Boolean replace = False;
		Boolean missing = False;
		unsigned ch = PACK_PAIR(text, text2, last);
		int nc;
		Char temp[2];
#if OPT_WIDE_CHARS
		Char temp2[2];

		if (xtermIsDecGraphic(ch)) {
		    /*
		     * Xft generally does not have the line-drawing characters
		     * in cells 1-31.  Check for this, and attempt to fill in
		     * from real line-drawing character in the font at the
		     * Unicode position.  Failing that, use our own
		     * box-characters.
		     */
		    if (xtermXftMissing(xw, font, ch)) {
			if (screen->force_box_chars
			    || xtermXftMissing(xw, font, dec2ucs(ch))) {
			    missing = 1;
			} else {
			    ch = dec2ucs(ch);
			    replace = True;
			}
		    }
		} else if (ch > 256) {
		    /*
		     * If we're reading UTF-8 from the client, we may have a
		     * line-drawing character.  Translate it back to our
		     * box-code if Xft tells us that the glyph is missing.
		     */
		    if_OPT_WIDE_CHARS(screen, {
			unsigned part = ucs2dec(ch);
			if (xtermIsDecGraphic(part) &&
			    (screen->force_box_chars
			     || xtermXftMissing(xw, font, ch))) {
			    ch = part;
			    missing = True;
			}
		    });
		}
#else
		if (xtermIsDecGraphic(ch)) {
		    /*
		     * Xft generally does not have the line-drawing characters
		     * in cells 1-31.  Check for this, and attempt to fill in
		     * from real line-drawing character in the font at the
		     * Unicode position.  Failing that, use our own
		     * box-characters.
		     */
		    if (xtermXftMissing(xw, font, ch)) {
			missing = 1;
		    }
		}
#endif
d2706 18
a2723 1
		 * If we now have one of our box-codes, draw it directly.
d2725 1
a2725 1
		if (missing || replace) {
d2728 9
a2736 37
			nc = drawClippedXftString(xw,
						  flags,
						  font,
						  getXftColor(xw, values.foreground),
						  curX,
						  y,
						  PAIRED_CHARS(text + first,
							       text2 + first),
						  (Cardinal) (last - first));
			curX += nc * FontWidth(screen);
			underline_len += nc;
		    }
		    if (missing) {
			old_wide = screen->fnt_wide;
			old_high = screen->fnt_high;
			screen->fnt_wide = FontWidth(screen);
			screen->fnt_high = FontHeight(screen);
			xtermDrawBoxChar(xw, ch, flags, gc,
					 curX, y - FontAscent(screen), 1);
			curX += FontWidth(screen);
			underline_len += 1;
			screen->fnt_wide = old_wide;
			screen->fnt_high = old_high;
		    } else {
			temp[0] = ch;
#if OPT_WIDE_CHARS
			temp2[0] = (ch >> 8);
#endif
			nc = drawClippedXftString(xw,
						  flags,
						  font,
						  getXftColor(xw, values.foreground),
						  curX,
						  y,
						  PAIRED_CHARS(temp,
							       temp2),
						  1);
d2740 10
d2765 2
a2766 2
	}
#else
a2777 1
#endif /* OPT_BOX_CHARS */
d2805 1
a2805 9
	    if_WIDE_OR_NARROW(screen, {
		XChar2b temp[1];
		temp[0].byte2 = *text;
		temp[0].byte1 = *text2;
		width = XTextWidth16(fs, temp, 1);
	    }
	    , {
		width = XTextWidth(fs, (char *) text, 1);
	    });
d2828 1
a2828 1
	    unsigned ch = PACK_PAIR(text, text2, last);
a2829 1
	    int ch_width;
d2831 2
a2832 1

a2838 1
	    ch_width = my_wcwidth((int) ch);
d2841 1
a2841 1
				 ((on_wide || ch_width > 1)
a2846 1
	    ch_width = 1;
a2847 17
	    /*
	     * If the character is not missing, but we're in wide-character
	     * mode and the character happens to be a wide-character that
	     * corresponds to the line-drawing set, allow the forceBoxChars
	     * resource (or menu entry) to force it to display using our
	     * tables.
	     */
	    if_OPT_WIDE_CHARS(screen, {
		if (!isMissing
		    && ch > 255
		    && ucs2dec(ch) < 32
		    && xw->screen.force_box_chars) {
		    ch = ucs2dec(ch);
		    isMissing = True;
		}
	    });

d2855 1
a2855 3
		    xtermDrawBoxChar(xw, ch, flags, gc, DrawX(last), y, ch_width);
		if (ch_width > 1)
		    x += (ch_width - 1) * FontWidth(screen);
d2906 1
a2906 1
	    unsigned ch = PACK_PAIR(text, text2, src);
d2988 1
a2988 1
		XFontStruct *thisFp = WhichVFont(screen, fnts[fntId].fs);
d3123 2
a3124 3
    Boolean always = screen->hilite_color;
    Boolean use_selbg = always || isNotForeground(xw, fg_pix, bg_pix, selbg_pix);
    Boolean use_selfg = always && isNotBackground(xw, fg_pix, bg_pix, selfg_pix);
a3139 11
#if OPT_HIGHLIGHT_COLOR
	if (!screen->hilite_color) {
	    if (selbg_pix != T_COLOR(screen, TEXT_FG)
		&& selbg_pix != fg_pix
		&& selbg_pix != bg_pix
		&& selbg_pix != xw->dft_foreground) {
		bg_pix = fg_pix;
		fg_pix = selbg_pix;
	    }
	}
#endif
d3142 2
a3143 10
	if (screen->hilite_color) {
	    if (screen->hilite_reverse) {
		if (use_selbg) {
		    if (use_selfg)
			bg_pix = fg_pix;
		    else
			fg_pix = bg_pix;
		}
		if (use_selbg)
		    bg_pix = selbg_pix;
d3145 3
a3147 1
		    fg_pix = selfg_pix;
d3149 4
d3163 5
a3167 7
    if (!screen->hilite_color || !screen->hilite_reverse) {
	if (hilite && !screen->hilite_reverse) {
	    if (use_selbg)
		bg_pix = selbg_pix;
	    if (use_selfg)
		fg_pix = selfg_pix;
	}
d3339 3
a3341 3
    return PACK_PAIR(SCREEN_PTR(screen, row, off),
		     SCREEN_PTR(screen, row, off + 1),
		     col);
a3351 4

	TRACE(("addXtermCombining %d,%d %#x (%d)\n",
	       row, col, ch, my_wcwidth(ch)));

@


