head	1.36;
access;
symbols
	OPENBSD_6_0:1.34.0.4
	OPENBSD_6_0_BASE:1.34
	OPENBSD_5_9:1.34.0.2
	OPENBSD_5_9_BASE:1.34
	OPENBSD_5_8:1.33.0.4
	OPENBSD_5_8_BASE:1.33
	OPENBSD_5_7:1.33.0.2
	OPENBSD_5_7_BASE:1.33
	OPENBSD_5_6:1.30.0.2
	OPENBSD_5_6_BASE:1.30
	OPENBSD_5_5:1.28.0.2
	OPENBSD_5_5_BASE:1.28
	OPENBSD_5_4:1.24.0.2
	OPENBSD_5_4_BASE:1.24
	OPENBSD_5_3:1.22.0.2
	OPENBSD_5_3_BASE:1.22
	OPENBSD_5_2:1.21.0.2
	OPENBSD_5_2_BASE:1.21
	OPENBSD_5_1_BASE:1.19
	OPENBSD_5_1:1.19.0.2
	OPENBSD_5_0:1.15.0.2
	OPENBSD_5_0_BASE:1.15
	OPENBSD_4_9:1.13.0.2
	OPENBSD_4_9_BASE:1.13
	OPENBSD_4_8:1.9.0.4
	OPENBSD_4_8_BASE:1.9
	OPENBSD_4_7:1.7.0.2
	OPENBSD_4_7_BASE:1.7
	OPENBSD_4_6:1.5.0.2
	OPENBSD_4_6_BASE:1.5
	OPENBSD_4_5:1.3.0.2
	OPENBSD_4_5_BASE:1.3
	OPENBSD_4_4:1.1.1.4.0.4
	OPENBSD_4_4_BASE:1.1.1.4
	OPENBSD_4_3_BASE:1.1.1.4
	OPENBSD_4_3:1.1.1.4.0.2
	v232:1.1.1.4
	v229:1.1.1.3
	OPENBSD_4_2:1.1.1.2.0.2
	OPENBSD_4_2_BASE:1.1.1.2
	v225:1.1.1.2
	v216:1.1.1.1
	xterm:1.1.1;
locks; strict;
comment	@ * @;


1.36
date	2016.11.03.14.25.06;	author matthieu;	state Exp;
branches;
next	1.35;
commitid	f4xcYrkdKFtVElPL;

1.35
date	2016.08.07.21.27.36;	author matthieu;	state Exp;
branches;
next	1.34;
commitid	psxxjI5z4Vpv2LL4;

1.34
date	2015.09.05.14.11.46;	author matthieu;	state Exp;
branches;
next	1.33;
commitid	YVUODLQ4QcYTuGkb;

1.33
date	2015.01.18.20.24.40;	author matthieu;	state Exp;
branches;
next	1.32;
commitid	PDdlFuihcMifzxwp;

1.32
date	2014.12.18.20.16.55;	author matthieu;	state Exp;
branches;
next	1.31;
commitid	pCMhkpVdt9Oe52hU;

1.31
date	2014.10.05.16.39.19;	author matthieu;	state Exp;
branches;
next	1.30;
commitid	0wVJ6bWh03LWbUdn;

1.30
date	2014.07.14.08.30.11;	author matthieu;	state Exp;
branches;
next	1.29;
commitid	EnwNNUjlkdrocnMa;

1.29
date	2014.05.09.19.56.40;	author matthieu;	state Exp;
branches;
next	1.28;

1.28
date	2014.02.14.19.40.03;	author matthieu;	state Exp;
branches;
next	1.27;

1.27
date	2014.01.02.15.15.51;	author matthieu;	state Exp;
branches;
next	1.26;

1.26
date	2014.01.02.15.14.50;	author matthieu;	state Exp;
branches;
next	1.25;

1.25
date	2013.08.26.20.06.12;	author matthieu;	state Exp;
branches;
next	1.24;

1.24
date	2013.06.02.19.55.50;	author matthieu;	state Exp;
branches;
next	1.23;

1.23
date	2013.03.09.14.45.38;	author matthieu;	state Exp;
branches;
next	1.22;

1.22
date	2013.01.04.16.40.18;	author matthieu;	state Exp;
branches;
next	1.21;

1.21
date	2012.06.07.20.20.23;	author matthieu;	state Exp;
branches;
next	1.20;

1.20
date	2012.04.14.09.02.46;	author matthieu;	state Exp;
branches;
next	1.19;

1.19
date	2011.11.16.21.14.25;	author matthieu;	state Exp;
branches;
next	1.18;

1.18
date	2011.09.17.11.51.57;	author matthieu;	state Exp;
branches;
next	1.17;

1.17
date	2011.08.28.17.40.55;	author matthieu;	state Exp;
branches;
next	1.16;

1.16
date	2011.08.18.19.47.42;	author matthieu;	state Exp;
branches;
next	1.15;

1.15
date	2011.06.07.19.21.06;	author matthieu;	state Exp;
branches;
next	1.14;

1.14
date	2011.03.07.20.41.27;	author matthieu;	state Exp;
branches;
next	1.13;

1.13
date	2010.11.29.20.10.09;	author matthieu;	state Exp;
branches;
next	1.12;

1.12
date	2010.10.23.19.14.52;	author matthieu;	state Exp;
branches;
next	1.11;

1.11
date	2010.10.05.19.37.23;	author matthieu;	state Exp;
branches;
next	1.10;

1.10
date	2010.08.22.13.38.11;	author matthieu;	state Exp;
branches;
next	1.9;

1.9
date	2010.05.08.12.20.46;	author matthieu;	state Exp;
branches;
next	1.8;

1.8
date	2010.03.25.22.03.51;	author matthieu;	state Exp;
branches;
next	1.7;

1.7
date	2009.10.31.14.11.57;	author matthieu;	state Exp;
branches;
next	1.6;

1.6
date	2009.09.05.15.58.09;	author matthieu;	state Exp;
branches;
next	1.5;

1.5
date	2009.04.04.15.10.44;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2009.03.09.22.13.04;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2009.01.06.20.10.20;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2008.08.25.18.05.57;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.26.11.11.38;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.11.26.11.11.38;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2007.06.15.19.30.29;	author matthieu;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2007.08.25.18.54.02;	author matthieu;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2008.02.16.09.35.09;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.36
log
@Update to xterm 327
@
text
@/* $XTermId: misc.c,v 1.743 2016/10/07 00:41:14 tom Exp $ */

/*
 * Copyright 1999-2015,2016 by Thomas E. Dickey
 *
 *                         All Rights Reserved
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 *
 * The above copyright notice and this permission notice shall be included
 * in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
 * IN NO EVENT SHALL THE ABOVE LISTED COPYRIGHT HOLDER(S) BE LIABLE FOR ANY
 * CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
 * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
 * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 *
 * Except as contained in this notice, the name(s) of the above copyright
 * holders shall not be used in advertising or otherwise to promote the
 * sale, use or other dealings in this Software without prior written
 * authorization.
 *
 *
 * Copyright 1987 by Digital Equipment Corporation, Maynard, Massachusetts.
 *
 *                         All Rights Reserved
 *
 * Permission to use, copy, modify, and distribute this software and its
 * documentation for any purpose and without fee is hereby granted,
 * provided that the above copyright notice appear in all copies and that
 * both that copyright notice and this permission notice appear in
 * supporting documentation, and that the name of Digital Equipment
 * Corporation not be used in advertising or publicity pertaining to
 * distribution of the software without specific, written prior permission.
 *
 *
 * DIGITAL DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING
 * ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL
 * DIGITAL BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR
 * ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
 * WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
 * ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
 * SOFTWARE.
 */

#include <version.h>
#include <main.h>
#include <xterm.h>

#include <sys/stat.h>
#include <stdio.h>
#include <stdarg.h>
#include <signal.h>
#include <ctype.h>
#include <pwd.h>
#include <sys/wait.h>

#include <X11/keysym.h>
#include <X11/Xatom.h>
#include <X11/cursorfont.h>
#include <X11/Xlocale.h>

#include <X11/Xmu/Error.h>
#include <X11/Xmu/SysUtil.h>
#include <X11/Xmu/WinUtil.h>
#include <X11/Xmu/Xmu.h>
#if HAVE_X11_SUNKEYSYM_H
#include <X11/Sunkeysym.h>
#endif

#ifdef HAVE_LIBXPM
#include <X11/xpm.h>
#endif

#ifdef HAVE_LANGINFO_CODESET
#include <langinfo.h>
#endif

#include <xutf8.h>

#include <data.h>
#include <error.h>
#include <menu.h>
#include <fontutils.h>
#include <xstrings.h>
#include <xtermcap.h>
#include <VTparse.h>
#include <graphics.h>
#include <graphics_regis.h>
#include <graphics_sixel.h>

#include <assert.h>

#if (XtSpecificationRelease < 6)
#ifndef X_GETTIMEOFDAY
#define X_GETTIMEOFDAY(t) gettimeofday(t,(struct timezone *)0)
#endif
#endif

#ifdef VMS
#define XTERM_VMS_LOGFILE "SYS$SCRATCH:XTERM_LOG.TXT"
#ifdef ALLOWLOGFILEEXEC
#undef ALLOWLOGFILEEXEC
#endif
#endif /* VMS */

#if OPT_TEK4014
#define OUR_EVENT(event,Type) \
		(event.type == Type && \
		  (event.xcrossing.window == XtWindow(XtParent(xw)) || \
		    (tekWidget && \
		     event.xcrossing.window == XtWindow(XtParent(tekWidget)))))
#else
#define OUR_EVENT(event,Type) \
		(event.type == Type && \
		   (event.xcrossing.window == XtWindow(XtParent(xw))))
#endif

static Boolean xtermAllocColor(XtermWidget, XColor *, const char *);
static Cursor make_hidden_cursor(XtermWidget);

static char emptyString[] = "";

#if OPT_EXEC_XTERM
/* Like readlink(2), but returns a malloc()ed buffer, or NULL on
   error; adapted from libc docs */
static char *
Readlink(const char *filename)
{
    char *buf = NULL;
    size_t size = 100;

    for (;;) {
	int n;
	char *tmp = TypeRealloc(char, size, buf);
	if (tmp == NULL) {
	    free(buf);
	    return NULL;
	}
	buf = tmp;
	memset(buf, 0, size);

	n = (int) readlink(filename, buf, size);
	if (n < 0) {
	    free(buf);
	    return NULL;
	}

	if ((unsigned) n < size) {
	    return buf;
	}

	size *= 2;
    }
}
#endif /* OPT_EXEC_XTERM */

static void
Sleep(int msec)
{
    static struct timeval select_timeout;

    select_timeout.tv_sec = 0;
    select_timeout.tv_usec = msec * 1000;
    select(0, 0, 0, 0, &select_timeout);
}

static void
selectwindow(XtermWidget xw, int flag)
{
    TScreen *screen = TScreenOf(xw);

    TRACE(("selectwindow(%d) flag=%d\n", screen->select, flag));

#if OPT_TEK4014
    if (TEK4014_ACTIVE(xw)) {
	if (!Ttoggled)
	    TCursorToggle(tekWidget, TOGGLE);
	screen->select |= flag;
	if (!Ttoggled)
	    TCursorToggle(tekWidget, TOGGLE);
    } else
#endif
    {
#if OPT_I18N_SUPPORT && OPT_INPUT_METHOD
	TInput *input = lookupTInput(xw, (Widget) xw);
	if (input && input->xic)
	    XSetICFocus(input->xic);
#endif

	if (screen->cursor_state && CursorMoved(screen))
	    HideCursor();
	screen->select |= flag;
	if (screen->cursor_state)
	    ShowCursor();
    }
    GetScrollLock(screen);
}

static void
unselectwindow(XtermWidget xw, int flag)
{
    TScreen *screen = TScreenOf(xw);

    TRACE(("unselectwindow(%d) flag=%d\n", screen->select, flag));

    if (screen->hide_pointer && screen->pointer_mode < pFocused) {
	screen->hide_pointer = False;
	xtermDisplayCursor(xw);
    }

    if (!screen->always_highlight) {
#if OPT_TEK4014
	if (TEK4014_ACTIVE(xw)) {
	    if (!Ttoggled)
		TCursorToggle(tekWidget, TOGGLE);
	    screen->select &= ~flag;
	    if (!Ttoggled)
		TCursorToggle(tekWidget, TOGGLE);
	} else
#endif
	{
#if OPT_I18N_SUPPORT && OPT_INPUT_METHOD
	    TInput *input = lookupTInput(xw, (Widget) xw);
	    if (input && input->xic)
		XUnsetICFocus(input->xic);
#endif

	    screen->select &= ~flag;
	    if (screen->cursor_state && CursorMoved(screen))
		HideCursor();
	    if (screen->cursor_state)
		ShowCursor();
	}
    }
}

static void
DoSpecialEnterNotify(XtermWidget xw, XEnterWindowEvent *ev)
{
    TScreen *screen = TScreenOf(xw);

    TRACE(("DoSpecialEnterNotify(%d)\n", screen->select));
    TRACE_FOCUS(xw, ev);
    if (((ev->detail) != NotifyInferior) &&
	ev->focus &&
	!(screen->select & FOCUS))
	selectwindow(xw, INWINDOW);
}

static void
DoSpecialLeaveNotify(XtermWidget xw, XEnterWindowEvent *ev)
{
    TScreen *screen = TScreenOf(xw);

    TRACE(("DoSpecialLeaveNotify(%d)\n", screen->select));
    TRACE_FOCUS(xw, ev);
    if (((ev->detail) != NotifyInferior) &&
	ev->focus &&
	!(screen->select & FOCUS))
	unselectwindow(xw, INWINDOW);
}

#ifndef XUrgencyHint
#define XUrgencyHint (1L << 8)	/* X11R5 does not define */
#endif

static void
setXUrgency(XtermWidget xw, Bool enable)
{
    TScreen *screen = TScreenOf(xw);

    if (screen->bellIsUrgent) {
	XWMHints *h = XGetWMHints(screen->display, VShellWindow(xw));
	if (h != 0) {
	    if (enable && !(screen->select & FOCUS)) {
		h->flags |= XUrgencyHint;
	    } else {
		h->flags &= ~XUrgencyHint;
	    }
	    XSetWMHints(screen->display, VShellWindow(xw), h);
	}
    }
}

void
do_xevents(void)
{
    TScreen *screen = TScreenOf(term);

    if (xtermAppPending()
	||
#if defined(VMS) || defined(__VMS)
	screen->display->qlen > 0
#else
	GetBytesAvailable(ConnectionNumber(screen->display)) > 0
#endif
	)
	xevents();
}

void
xtermDisplayCursor(XtermWidget xw)
{
    TScreen *screen = TScreenOf(xw);

    if (screen->Vshow) {
	if (screen->hide_pointer) {
	    TRACE(("Display hidden_cursor\n"));
	    XDefineCursor(screen->display, VWindow(screen), screen->hidden_cursor);
	} else {
	    TRACE(("Display pointer_cursor\n"));
	    recolor_cursor(screen,
			   screen->pointer_cursor,
			   T_COLOR(screen, MOUSE_FG),
			   T_COLOR(screen, MOUSE_BG));
	    XDefineCursor(screen->display, VWindow(screen), screen->pointer_cursor);
	}
    }
}

void
xtermShowPointer(XtermWidget xw, Bool enable)
{
    static int tried = -1;
    TScreen *screen = TScreenOf(xw);

#if OPT_TEK4014
    if (TEK4014_SHOWN(xw))
	enable = True;
#endif

    /*
     * Whether we actually hide the pointer depends on the pointer-mode and
     * the mouse-mode:
     */
    if (!enable) {
	switch (screen->pointer_mode) {
	case pNever:
	    enable = True;
	    break;
	case pNoMouse:
	    if (screen->send_mouse_pos != MOUSE_OFF)
		enable = True;
	    break;
	case pAlways:
	case pFocused:
	    break;
	}
    }

    if (enable) {
	if (screen->hide_pointer) {
	    screen->hide_pointer = False;
	    xtermDisplayCursor(xw);
	    switch (screen->send_mouse_pos) {
	    case ANY_EVENT_MOUSE:
		break;
	    default:
		MotionOff(screen, xw);
		break;
	    }
	}
    } else if (!(screen->hide_pointer) && (tried <= 0)) {
	if (screen->hidden_cursor == 0) {
	    screen->hidden_cursor = make_hidden_cursor(xw);
	}
	if (screen->hidden_cursor == 0) {
	    tried = 1;
	} else {
	    tried = 0;
	    screen->hide_pointer = True;
	    xtermDisplayCursor(xw);
	    MotionOn(screen, xw);
	}
    }
}

#if OPT_TRACE
static void
TraceExposeEvent(XEvent *arg)
{
    XExposeEvent *event = (XExposeEvent *) arg;

    TRACE(("pending Expose %ld %d: %d,%d %dx%d %#lx\n",
	   event->serial,
	   event->count,
	   event->y,
	   event->x,
	   event->height,
	   event->width,
	   event->window));
}

#else
#define TraceExposeEvent(event)	/* nothing */
#endif

/* true if p contains q */
#define ExposeContains(p,q) \
	    ((p)->y <= (q)->y \
	  && (p)->x <= (q)->x \
	  && ((p)->y + (p)->height) >= ((q)->y + (q)->height) \
	  && ((p)->x + (p)->width) >= ((q)->x + (q)->width))

static XtInputMask
mergeExposeEvents(XEvent *target)
{
    XEvent next_event;
    XExposeEvent *p;

    TRACE(("pending Expose...?\n"));
    TraceExposeEvent(target);
    XtAppNextEvent(app_con, target);
    p = (XExposeEvent *) target;

    while (XtAppPending(app_con)
	   && XtAppPeekEvent(app_con, &next_event)
	   && next_event.type == Expose) {
	Boolean merge_this = False;
	XExposeEvent *q;

	TraceExposeEvent(&next_event);
	q = (XExposeEvent *) (&next_event);
	XtAppNextEvent(app_con, &next_event);

	/*
	 * If either window is contained within the other, merge the events.
	 * The traces show that there are also cases where a full repaint of
	 * a window is broken into 3 or more rectangles, which do not arrive
	 * in the same instant.  We could merge those if xterm were modified
	 * to skim several events ahead.
	 */
	if (p->window == q->window) {
	    if (ExposeContains(p, q)) {
		TRACE(("pending Expose...merged forward\n"));
		merge_this = True;
		next_event = *target;
	    } else if (ExposeContains(q, p)) {
		TRACE(("pending Expose...merged backward\n"));
		merge_this = True;
	    }
	}
	if (!merge_this) {
	    XtDispatchEvent(target);
	}
	*target = next_event;
    }
    XtDispatchEvent(target);
    return XtAppPending(app_con);
}

#if OPT_TRACE
static void
TraceConfigureEvent(XEvent *arg)
{
    XConfigureEvent *event = (XConfigureEvent *) arg;

    TRACE(("pending Configure %ld %d,%d %dx%d %#lx\n",
	   event->serial,
	   event->y,
	   event->x,
	   event->height,
	   event->width,
	   event->window));
}

#else
#define TraceConfigureEvent(event)	/* nothing */
#endif

/*
 * On entry, we have peeked at the event queue and see a configure-notify
 * event.  Remove that from the queue so we can look further.
 *
 * Then, as long as there is a configure-notify event in the queue, remove
 * that.  If the adjacent events are for different windows, process the older
 * event and update the event used for comparing windows.  If they are for the
 * same window, only the newer event is of interest.
 *
 * Finally, process the (remaining) configure-notify event.
 */
static XtInputMask
mergeConfigureEvents(XEvent *target)
{
    XEvent next_event;
    XConfigureEvent *p;

    XtAppNextEvent(app_con, target);
    p = (XConfigureEvent *) target;

    TRACE(("pending Configure...?%s\n", XtAppPending(app_con) ? "yes" : "no"));
    TraceConfigureEvent(target);

    if (XtAppPending(app_con)
	&& XtAppPeekEvent(app_con, &next_event)
	&& next_event.type == ConfigureNotify) {
	Boolean merge_this = False;
	XConfigureEvent *q;

	TraceConfigureEvent(&next_event);
	XtAppNextEvent(app_con, &next_event);
	q = (XConfigureEvent *) (&next_event);

	if (p->window == q->window) {
	    TRACE(("pending Configure...merged\n"));
	    merge_this = True;
	}
	if (!merge_this) {
	    TRACE(("pending Configure...skipped\n"));
	    XtDispatchEvent(target);
	}
	*target = next_event;
    }
    XtDispatchEvent(target);
    return XtAppPending(app_con);
}

/*
 * Filter redundant Expose- and ConfigureNotify-events.  This is limited to
 * adjacent events because there could be other event-loop processing.  Absent
 * that limitation, it might be possible to scan ahead to find when the screen
 * would be completely updated, skipping unnecessary re-repainting before that
 * point.
 *
 * Note: all cases should allow doing XtAppNextEvent if result is true.
 */
XtInputMask
xtermAppPending(void)
{
    XtInputMask result = XtAppPending(app_con);
    XEvent this_event;
    Boolean found = False;

    while (result && XtAppPeekEvent(app_con, &this_event)) {
	found = True;
	if (this_event.type == Expose) {
	    result = mergeExposeEvents(&this_event);
	    TRACE(("got merged expose events\n"));
	} else if (this_event.type == ConfigureNotify) {
	    result = mergeConfigureEvents(&this_event);
	    TRACE(("got merged configure notify events\n"));
	} else {
	    TRACE(("pending %s\n", visibleEventType(this_event.type)));
	    break;
	}
    }

    /*
     * With NetBSD, closing a shell results in closing the X input event
     * stream, which interferes with the "-hold" option.  Wait a short time in
     * this case, to avoid max'ing the CPU.
     */
    if (hold_screen && caught_intr && !found) {
	Sleep(10);
    }
    return result;
}

void
xevents(void)
{
    XtermWidget xw = term;
    TScreen *screen = TScreenOf(xw);
    XEvent event;
    XtInputMask input_mask;

    if (need_cleanup)
	NormalExit();

    if (screen->scroll_amt)
	FlushScroll(xw);
    /*
     * process timeouts, relying on the fact that XtAppProcessEvent
     * will process the timeout and return without blockng on the
     * XEvent queue.  Other sources i.e., the pty are handled elsewhere
     * with select().
     */
    while ((input_mask = xtermAppPending()) != 0) {
	if (input_mask & XtIMTimer)
	    XtAppProcessEvent(app_con, (XtInputMask) XtIMTimer);
#if OPT_SESSION_MGT
	/*
	 * Session management events are alternative input events. Deal with
	 * them in the same way.
	 */
	else if (input_mask & XtIMAlternateInput)
	    XtAppProcessEvent(app_con, (XtInputMask) XtIMAlternateInput);
#endif
	else
	    break;
    }

    /*
     * If there's no XEvents, don't wait around...
     */
    if ((input_mask & XtIMXEvent) != XtIMXEvent)
	return;
    do {
	/*
	 * This check makes xterm hang when in mouse hilite tracking mode.
	 * We simply ignore all events except for those not passed down to
	 * this function, e.g., those handled in in_put().
	 */
	if (screen->waitingForTrackInfo) {
	    Sleep(10);
	    return;
	}
	XtAppNextEvent(app_con, &event);
	/*
	 * Hack to get around problems with the toolkit throwing away
	 * eventing during the exclusive grab of the menu popup.  By
	 * looking at the event ourselves we make sure that we can
	 * do the right thing.
	 */
	if (OUR_EVENT(event, EnterNotify)) {
	    DoSpecialEnterNotify(xw, &event.xcrossing);
	} else if (OUR_EVENT(event, LeaveNotify)) {
	    DoSpecialLeaveNotify(xw, &event.xcrossing);
	} else if ((screen->send_mouse_pos == ANY_EVENT_MOUSE
#if OPT_DEC_LOCATOR
		    || screen->send_mouse_pos == DEC_LOCATOR
#endif /* OPT_DEC_LOCATOR */
		   )
		   && event.xany.type == MotionNotify
		   && event.xcrossing.window == XtWindow(xw)) {
	    SendMousePosition(xw, &event);
	    xtermShowPointer(xw, True);
	    continue;
	}

	/*
	 * If the event is interesting (and not a keyboard event), turn the
	 * mouse pointer back on.
	 */
	if (screen->hide_pointer) {
	    if (screen->pointer_mode >= pFocused) {
		switch (event.xany.type) {
		case MotionNotify:
		    xtermShowPointer(xw, True);
		    break;
		}
	    } else {
		switch (event.xany.type) {
		case KeyPress:
		case KeyRelease:
		case ButtonPress:
		case ButtonRelease:
		    /* also these... */
		case Expose:
		case GraphicsExpose:
		case NoExpose:
		case PropertyNotify:
		case ClientMessage:
		    break;
		default:
		    xtermShowPointer(xw, True);
		    break;
		}
	    }
	}

	if (!event.xany.send_event ||
	    screen->allowSendEvents ||
	    ((event.xany.type != KeyPress) &&
	     (event.xany.type != KeyRelease) &&
	     (event.xany.type != ButtonPress) &&
	     (event.xany.type != ButtonRelease))) {

	    XtDispatchEvent(&event);
	}
    } while (xtermAppPending() & XtIMXEvent);
}

static Cursor
make_hidden_cursor(XtermWidget xw)
{
    TScreen *screen = TScreenOf(xw);
    Cursor c;
    Display *dpy = screen->display;
    XFontStruct *fn;

    static XColor dummy;

    /*
     * Prefer nil2 (which is normally available) to "fixed" (which is supposed
     * to be "always" available), since it's a smaller glyph in case the
     * server insists on drawing _something_.
     */
    TRACE(("Ask for nil2 font\n"));
    if ((fn = XLoadQueryFont(dpy, "nil2")) == 0) {
	TRACE(("...Ask for fixed font\n"));
	fn = XLoadQueryFont(dpy, DEFFONT);
    }

    if (fn != 0) {
	/* a space character seems to work as a cursor (dots are not needed) */
	c = XCreateGlyphCursor(dpy, fn->fid, fn->fid, 'X', ' ', &dummy, &dummy);
	XFreeFont(dpy, fn);
    } else {
	c = 0;
    }
    TRACE(("XCreateGlyphCursor ->%#lx\n", c));
    return (c);
}

/*
 * Xlib uses Xcursor to customize cursor coloring, which interferes with
 * xterm's pointerColor resource.  Work around this by providing our own
 * default theme.  Testing seems to show that we only have to provide this
 * until the window is initialized.
 */
void
init_colored_cursor(Display *dpy)
{
#ifdef HAVE_LIB_XCURSOR
    static const char theme[] = "index.theme";
    static const char pattern[] = "xtermXXXXXXXX";
    char *env = getenv("XCURSOR_THEME");

    xterm_cursor_theme = 0;
    /*
     * The environment variable overrides a (possible) resource Xcursor.theme
     */
    if (IsEmpty(env)) {
	env = XGetDefault(dpy, "Xcursor", "theme");
    }
    /*
     * If neither found, provide our own default theme.
     */
    if (IsEmpty(env)) {
	const char *tmp_dir;
	char *filename;
	size_t needed;

	if ((tmp_dir = getenv("TMPDIR")) == 0) {
	    tmp_dir = P_tmpdir;
	}
	needed = strlen(tmp_dir) + 4 + strlen(theme) + strlen(pattern);
	if ((filename = malloc(needed)) != 0) {
	    sprintf(filename, "%s/%s", tmp_dir, pattern);

#ifdef HAVE_MKDTEMP
	    xterm_cursor_theme = mkdtemp(filename);
#else
	    if (mktemp(filename) != 0
		&& mkdir(filename, 0700) == 0) {
		xterm_cursor_theme = filename;
	    }
#endif
	    /*
	     * Actually, Xcursor does what _we_ want just by steering its
	     * search path away from home.  We are setting up the complete
	     * theme just in case the library ever acquires a maintainer.
	     */
	    if (xterm_cursor_theme != 0) {
		char *leaf = xterm_cursor_theme + strlen(xterm_cursor_theme);
		FILE *fp;

		strcat(leaf, "/");
		strcat(leaf, theme);
		if ((fp = fopen(xterm_cursor_theme, "w")) != 0) {
		    fprintf(fp, "[Icon Theme]\n");
		    fclose(fp);
		    *leaf = '\0';
		    xtermSetenv("XCURSOR_PATH", xterm_cursor_theme);
		    *leaf = '/';
		}
		atexit(cleanup_colored_cursor);
	    }
	}
    }
#else
    (void) dpy;
#endif /* HAVE_LIB_XCURSOR */
}

/*
 * Once done, discard the file and directory holding it.
 */
void
cleanup_colored_cursor(void)
{
#ifdef HAVE_LIB_XCURSOR
    if (xterm_cursor_theme != 0) {
	char *my_path = getenv("XCURSOR_PATH");
	struct stat sb;
	if (!IsEmpty(my_path)
	    && stat(my_path, &sb) == 0
	    && (sb.st_mode & S_IFMT) == S_IFDIR) {
	    unlink(xterm_cursor_theme);
	    rmdir(my_path);
	    free(xterm_cursor_theme);
	    xterm_cursor_theme = 0;
	}
    }
#endif /* HAVE_LIB_XCURSOR */
}

Cursor
make_colored_cursor(unsigned cursorindex,	/* index into font */
		    unsigned long fg,	/* pixel value */
		    unsigned long bg)	/* pixel value */
{
    TScreen *screen = TScreenOf(term);
    Cursor c;
    Display *dpy = screen->display;

    c = XCreateFontCursor(dpy, cursorindex);
    if (c != None) {
	recolor_cursor(screen, c, fg, bg);
    }
    return (c);
}

/* ARGSUSED */
void
HandleKeyPressed(Widget w GCC_UNUSED,
		 XEvent *event,
		 String *params GCC_UNUSED,
		 Cardinal *nparams GCC_UNUSED)
{
    TRACE(("Handle insert-seven-bit for %p\n", (void *) w));
    Input(term, &event->xkey, False);
}

/* ARGSUSED */
void
HandleEightBitKeyPressed(Widget w GCC_UNUSED,
			 XEvent *event,
			 String *params GCC_UNUSED,
			 Cardinal *nparams GCC_UNUSED)
{
    TRACE(("Handle insert-eight-bit for %p\n", (void *) w));
    Input(term, &event->xkey, True);
}

/* ARGSUSED */
void
HandleStringEvent(Widget w GCC_UNUSED,
		  XEvent *event GCC_UNUSED,
		  String *params,
		  Cardinal *nparams)
{

    if (*nparams != 1)
	return;

    if ((*params)[0] == '0' && (*params)[1] == 'x' && (*params)[2] != '\0') {
	const char *abcdef = "ABCDEF";
	const char *xxxxxx;
	Char c;
	UString p;
	unsigned value = 0;

	for (p = (UString) (*params + 2); (c = CharOf(x_toupper(*p))) !=
	     '\0'; p++) {
	    value *= 16;
	    if (c >= '0' && c <= '9')
		value += (unsigned) (c - '0');
	    else if ((xxxxxx = (strchr) (abcdef, c)) != 0)
		value += (unsigned) (xxxxxx - abcdef) + 10;
	    else
		break;
	}
	if (c == '\0') {
	    Char hexval[2];
	    hexval[0] = (Char) value;
	    hexval[1] = 0;
	    StringInput(term, hexval, (size_t) 1);
	}
    } else {
	StringInput(term, (const Char *) *params, strlen(*params));
    }
}

#if OPT_EXEC_XTERM

#ifndef PROCFS_ROOT
#define PROCFS_ROOT "/proc"
#endif

/*
 * Determine the current working directory of the child so that we can
 * spawn a new terminal in the same directory.
 *
 * If we cannot get the CWD of the child, just use our own.
 */
char *
ProcGetCWD(pid_t pid)
{
    char *child_cwd = NULL;

    if (pid) {
	char child_cwd_link[sizeof(PROCFS_ROOT) + 80];
	sprintf(child_cwd_link, PROCFS_ROOT "/%lu/cwd", (unsigned long) pid);
	child_cwd = Readlink(child_cwd_link);
    }
    return child_cwd;
}

/* ARGSUSED */
void
HandleSpawnTerminal(Widget w GCC_UNUSED,
		    XEvent *event GCC_UNUSED,
		    String *params,
		    Cardinal *nparams)
{
    TScreen *screen = TScreenOf(term);
    char *child_cwd = NULL;
    char *child_exe;
    pid_t pid;

    /*
     * Try to find the actual program which is running in the child process.
     * This works for Linux.  If we cannot find the program, fall back to the
     * xterm program (which is usually adequate).  Give up if we are given only
     * a relative path to xterm, since that would not always match $PATH.
     */
    child_exe = Readlink(PROCFS_ROOT "/self/exe");
    if (!child_exe) {
	if (strncmp(ProgramName, "./", (size_t) 2)
	    && strncmp(ProgramName, "../", (size_t) 3)) {
	    child_exe = xtermFindShell(ProgramName, True);
	} else {
	    xtermWarning("Cannot exec-xterm given \"%s\"\n", ProgramName);
	}
	if (child_exe == 0)
	    return;
    }

    child_cwd = ProcGetCWD(screen->pid);

    /* The reaper will take care of cleaning up the child */
    pid = fork();
    if (pid == -1) {
	xtermWarning("Could not fork: %s\n", SysErrorMsg(errno));
    } else if (!pid) {
	/* We are the child */
	if (child_cwd) {
	    IGNORE_RC(chdir(child_cwd));	/* We don't care if this fails */
	}

	if (setuid(screen->uid) == -1
	    || setgid(screen->gid) == -1) {
	    xtermWarning("Cannot reset uid/gid\n");
	} else {
	    unsigned myargc = *nparams + 1;
	    char **myargv = TypeMallocN(char *, myargc + 1);

	    if (myargv != 0) {
		unsigned n = 0;

		myargv[n++] = child_exe;

		while (n < myargc) {
		    myargv[n++] = (char *) *params++;
		}

		myargv[n] = 0;
		execv(child_exe, myargv);
	    }

	    /* If we get here, we've failed */
	    xtermWarning("exec of '%s': %s\n", child_exe, SysErrorMsg(errno));
	}
	_exit(0);
    }

    /* We are the parent; clean up */
    if (child_cwd)
	free(child_cwd);
    free(child_exe);
}
#endif /* OPT_EXEC_XTERM */

/*
 * Rather than sending characters to the host, put them directly into our
 * input queue.  That lets a user have access to any of the control sequences
 * for a key binding.  This is the equivalent of local function key support.
 *
 * NOTE:  This code does not support the hexadecimal kludge used in
 * HandleStringEvent because it prevents us from sending an arbitrary string
 * (but it appears in a lot of examples - so we are stuck with it).  The
 * standard string converter does recognize "\" for newline ("\n") and for
 * octal constants (e.g., "\007" for BEL).  So we assume the user can make do
 * without a specialized converter.  (Don't try to use \000, though).
 */
/* ARGSUSED */
void
HandleInterpret(Widget w GCC_UNUSED,
		XEvent *event GCC_UNUSED,
		String *params,
		Cardinal *param_count)
{
    if (*param_count == 1) {
	const char *value = params[0];
	int need = (int) strlen(value);
	int used = (int) (VTbuffer->next - VTbuffer->buffer);
	int have = (int) (VTbuffer->last - VTbuffer->buffer);

	if (have - used + need < BUF_SIZE) {

	    fillPtyData(term, VTbuffer, value, (int) strlen(value));

	    TRACE(("Interpret %s\n", value));
	    VTbuffer->update++;
	}
    }
}

/*ARGSUSED*/
void
HandleEnterWindow(Widget w GCC_UNUSED,
		  XtPointer eventdata GCC_UNUSED,
		  XEvent *event GCC_UNUSED,
		  Boolean *cont GCC_UNUSED)
{
    /* NOP since we handled it above */
    TRACE(("HandleEnterWindow ignored\n"));
    TRACE_FOCUS(w, event);
}

/*ARGSUSED*/
void
HandleLeaveWindow(Widget w GCC_UNUSED,
		  XtPointer eventdata GCC_UNUSED,
		  XEvent *event GCC_UNUSED,
		  Boolean *cont GCC_UNUSED)
{
    /* NOP since we handled it above */
    TRACE(("HandleLeaveWindow ignored\n"));
    TRACE_FOCUS(w, event);
}

/*ARGSUSED*/
void
HandleFocusChange(Widget w GCC_UNUSED,
		  XtPointer eventdata GCC_UNUSED,
		  XEvent *ev,
		  Boolean *cont GCC_UNUSED)
{
    XFocusChangeEvent *event = (XFocusChangeEvent *) ev;
    XtermWidget xw = term;
    TScreen *screen = TScreenOf(xw);

    TRACE(("HandleFocusChange type=%s, mode=%s, detail=%s\n",
	   visibleEventType(event->type),
	   visibleNotifyMode(event->mode),
	   visibleNotifyDetail(event->detail)));
    TRACE_FOCUS(xw, event);

    if (screen->quiet_grab
	&& (event->mode == NotifyGrab || event->mode == NotifyUngrab)) {
	/* EMPTY */ ;
    } else if (event->type == FocusIn) {
	if (event->detail != NotifyPointer) {
	    setXUrgency(xw, False);
	}

	/*
	 * NotifyNonlinear only happens (on FocusIn) if the pointer was not in
	 * one of our windows.  Use this to reset a case where one xterm is
	 * partly obscuring another, and X gets (us) confused about whether the
	 * pointer was in the window.  In particular, this can happen if the
	 * user is resizing the obscuring window, causing some events to not be
	 * delivered to the obscured window.
	 */
	if (event->detail == NotifyNonlinear
	    && (screen->select & INWINDOW) != 0) {
	    unselectwindow(xw, INWINDOW);
	}
	selectwindow(xw,
		     ((event->detail == NotifyPointer)
		      ? INWINDOW
		      : FOCUS));
	SendFocusButton(xw, event);
    } else {
#if OPT_FOCUS_EVENT
	if (event->type == FocusOut) {
	    SendFocusButton(xw, event);
	}
#endif
	/*
	 * XGrabKeyboard() will generate NotifyGrab event that we want to
	 * ignore.
	 */
	if (event->mode != NotifyGrab) {
	    unselectwindow(xw,
			   ((event->detail == NotifyPointer)
			    ? INWINDOW
			    : FOCUS));
	}
	if (screen->grabbedKbd && (event->mode == NotifyUngrab)) {
	    Bell(xw, XkbBI_Info, 100);
	    ReverseVideo(xw);
	    screen->grabbedKbd = False;
	    update_securekbd();
	}
    }
}

static long lastBellTime;	/* in milliseconds */

#if defined(HAVE_XKB_BELL_EXT)
static Atom
AtomBell(XtermWidget xw, int which)
{
#define DATA(name) { XkbBI_##name, XkbBN_##name }
    static struct {
	int value;
	const char *name;
    } table[] = {
	DATA(Info),
	    DATA(MarginBell),
	    DATA(MinorError),
	    DATA(TerminalBell)
    };
    Cardinal n;
    Atom result = None;

    for (n = 0; n < XtNumber(table); ++n) {
	if (table[n].value == which) {
	    result = XInternAtom(XtDisplay(xw), table[n].name, False);
	    break;
	}
    }
    return result;
}
#endif

void
xtermBell(XtermWidget xw, int which, int percent)
{
    TScreen *screen = TScreenOf(xw);
#if defined(HAVE_XKB_BELL_EXT)
    Atom tony = AtomBell(xw, which);
#endif

    switch (which) {
    case XkbBI_Info:
    case XkbBI_MinorError:
    case XkbBI_MajorError:
    case XkbBI_TerminalBell:
	switch (screen->warningVolume) {
	case bvOff:
	    percent = -100;
	    break;
	case bvLow:
	    break;
	case bvHigh:
	    percent = 100;
	    break;
	}
	break;
    case XkbBI_MarginBell:
	switch (screen->marginVolume) {
	case bvOff:
	    percent = -100;
	    break;
	case bvLow:
	    break;
	case bvHigh:
	    percent = 100;
	    break;
	}
	break;
    default:
	break;
    }

#if defined(HAVE_XKB_BELL_EXT)
    if (tony != None) {
	XkbBell(screen->display, VShellWindow(xw), percent, tony);
    } else
#endif
	XBell(screen->display, percent);
}

void
Bell(XtermWidget xw, int which, int percent)
{
    TScreen *screen = TScreenOf(xw);
    struct timeval curtime;

    TRACE(("BELL %d %d%%\n", which, percent));
    if (!XtIsRealized((Widget) xw)) {
	return;
    }

    setXUrgency(xw, True);

    /* has enough time gone by that we are allowed to ring
       the bell again? */
    if (screen->bellSuppressTime) {
	long now_msecs;

	if (screen->bellInProgress) {
	    do_xevents();
	    if (screen->bellInProgress) {	/* even after new events? */
		return;
	    }
	}
	X_GETTIMEOFDAY(&curtime);
	now_msecs = 1000 * curtime.tv_sec + curtime.tv_usec / 1000;
	if (lastBellTime != 0 && now_msecs - lastBellTime >= 0 &&
	    now_msecs - lastBellTime < screen->bellSuppressTime) {
	    return;
	}
	lastBellTime = now_msecs;
    }

    if (screen->visualbell) {
	VisualBell();
    } else {
	xtermBell(xw, which, percent);
    }

    if (screen->poponbell)
	XRaiseWindow(screen->display, VShellWindow(xw));

    if (screen->bellSuppressTime) {
	/* now we change a property and wait for the notify event to come
	   back.  If the server is suspending operations while the bell
	   is being emitted (problematic for audio bell), this lets us
	   know when the previous bell has finished */
	Widget w = CURRENT_EMU();
	XChangeProperty(XtDisplay(w), XtWindow(w),
			XA_NOTICE, XA_NOTICE, 8, PropModeAppend, NULL, 0);
	screen->bellInProgress = True;
    }
}

#define VB_DELAY screen->visualBellDelay

static void
flashWindow(TScreen *screen, Window window, GC visualGC, unsigned width, unsigned height)
{
    int y = 0;
    int x = 0;

    if (screen->flash_line) {
	y = CursorY(screen, screen->cur_row);
	height = (unsigned) FontHeight(screen);
    }
    XFillRectangle(screen->display, window, visualGC, x, y, width, height);
    XFlush(screen->display);
    Sleep(VB_DELAY);
    XFillRectangle(screen->display, window, visualGC, x, y, width, height);
}

void
VisualBell(void)
{
    TScreen *screen = TScreenOf(term);

    if (VB_DELAY > 0) {
	Pixel xorPixel = (T_COLOR(screen, TEXT_FG) ^
			  T_COLOR(screen, TEXT_BG));
	XGCValues gcval;
	GC visualGC;

	gcval.function = GXxor;
	gcval.foreground = xorPixel;
	visualGC = XtGetGC((Widget) term, GCFunction + GCForeground, &gcval);
#if OPT_TEK4014
	if (TEK4014_ACTIVE(term)) {
	    TekScreen *tekscr = TekScreenOf(tekWidget);
	    flashWindow(screen, TWindow(tekscr), visualGC,
			TFullWidth(tekscr),
			TFullHeight(tekscr));
	} else
#endif
	{
	    flashWindow(screen, VWindow(screen), visualGC,
			FullWidth(screen),
			FullHeight(screen));
	}
	XtReleaseGC((Widget) term, visualGC);
    }
}

/* ARGSUSED */
void
HandleBellPropertyChange(Widget w GCC_UNUSED,
			 XtPointer data GCC_UNUSED,
			 XEvent *ev,
			 Boolean *more GCC_UNUSED)
{
    TScreen *screen = TScreenOf(term);

    if (ev->xproperty.atom == XA_NOTICE) {
	screen->bellInProgress = False;
    }
}

void
xtermWarning(const char *fmt,...)
{
    int save_err = errno;
    va_list ap;

    TRACE(("xtermWarning fmt='%s'\n", fmt));
    fprintf(stderr, "%s: ", ProgramName);
    va_start(ap, fmt);
    vfprintf(stderr, fmt, ap);
    (void) fflush(stderr);

    va_end(ap);
    errno = save_err;
}

void
xtermPerror(const char *fmt,...)
{
    int save_err = errno;
    char *msg = strerror(errno);
    va_list ap;

    TRACE(("xtermPerror fmt='%s', msg='%s'\n", fmt, NonNull(msg)));
    fprintf(stderr, "%s: ", ProgramName);
    va_start(ap, fmt);
    vfprintf(stderr, fmt, ap);
    fprintf(stderr, ": %s\n", msg);
    (void) fflush(stderr);

    va_end(ap);
    errno = save_err;
}

Window
WMFrameWindow(XtermWidget xw)
{
    Window win_root, win_current, *children;
    Window win_parent = 0;
    unsigned int nchildren;

    win_current = XtWindow(xw);

    /* find the parent which is child of root */
    do {
	if (win_parent)
	    win_current = win_parent;
	XQueryTree(TScreenOf(xw)->display,
		   win_current,
		   &win_root,
		   &win_parent,
		   &children,
		   &nchildren);
	XFree(children);
    } while (win_root != win_parent);

    return win_current;
}

#if OPT_DABBREV
/*
 * The following code implements `dynamic abbreviation' expansion a la
 * Emacs.  It looks in the preceding visible screen and its scrollback
 * to find expansions of a typed word.  It compares consecutive
 * expansions and ignores one of them if they are identical.
 * (Tomasz J. Cholewo, t.cholewo@@ieee.org)
 */

#define IS_WORD_CONSTITUENT(x) ((x) != ' ' && (x) != '\0')

static int
dabbrev_prev_char(TScreen *screen, CELL *cell, LineData **ld)
{
    int result = -1;
    int firstLine = -(screen->savedlines);

    *ld = getLineData(screen, cell->row);
    while (cell->row >= firstLine) {
	if (--(cell->col) >= 0) {
	    result = (int) (*ld)->charData[cell->col];
	    break;
	}
	if (--(cell->row) < firstLine)
	    break;		/* ...there is no previous line */
	*ld = getLineData(screen, cell->row);
	cell->col = MaxCols(screen);
	if (!LineTstWrapped(*ld)) {
	    result = ' ';	/* treat lines as separate */
	    break;
	}
    }
    return result;
}

static char *
dabbrev_prev_word(XtermWidget xw, CELL *cell, LineData **ld)
{
    TScreen *screen = TScreenOf(xw);
    char *abword;
    int c;
    char *ab_end = (xw->work.dabbrev_data + MAX_DABBREV - 1);
    char *result = 0;

    abword = ab_end;
    *abword = '\0';		/* end of string marker */

    while ((c = dabbrev_prev_char(screen, cell, ld)) >= 0 &&
	   IS_WORD_CONSTITUENT(c)) {
	if (abword > xw->work.dabbrev_data)	/* store only the last chars */
	    *(--abword) = (char) c;
    }

    if (c >= 0) {
	result = abword;
    } else if (abword != ab_end) {
	result = abword;
    }

    if (result != 0) {
	while ((c = dabbrev_prev_char(screen, cell, ld)) >= 0 &&
	       !IS_WORD_CONSTITUENT(c)) {
	    ;			/* skip preceding spaces */
	}
	(cell->col)++;		/* can be | > screen->max_col| */
    }
    return result;
}

static int
dabbrev_expand(XtermWidget xw)
{
    TScreen *screen = TScreenOf(xw);
    int pty = screen->respond;	/* file descriptor of pty */

    static CELL cell;
    static char *dabbrev_hint = 0, *lastexpansion = 0;
    static unsigned int expansions;

    char *expansion;
    size_t hint_len;
    int result = 0;
    LineData *ld;

    if (!screen->dabbrev_working) {	/* initialize */
	expansions = 0;
	cell.col = screen->cur_col;
	cell.row = screen->cur_row;

	if (dabbrev_hint != 0)
	    free(dabbrev_hint);

	if ((dabbrev_hint = dabbrev_prev_word(xw, &cell, &ld)) != 0) {

	    if (lastexpansion != 0)
		free(lastexpansion);

	    if ((lastexpansion = strdup(dabbrev_hint)) != 0) {

		/* make own copy */
		if ((dabbrev_hint = strdup(dabbrev_hint)) != 0) {
		    screen->dabbrev_working = True;
		    /* we are in the middle of dabbrev process */
		}
	    } else {
		return result;
	    }
	} else {
	    return result;
	}
	if (!screen->dabbrev_working) {
	    if (lastexpansion != 0) {
		free(lastexpansion);
		lastexpansion = 0;
	    }
	    return result;
	}
    }

    if (dabbrev_hint == 0)
	return result;

    hint_len = strlen(dabbrev_hint);
    for (;;) {
	if ((expansion = dabbrev_prev_word(xw, &cell, &ld)) == 0) {
	    if (expansions >= 2) {
		expansions = 0;
		cell.col = screen->cur_col;
		cell.row = screen->cur_row;
		continue;
	    }
	    break;
	}
	if (!strncmp(dabbrev_hint, expansion, hint_len) &&	/* empty hint matches everything */
	    strlen(expansion) > hint_len &&	/* trivial expansion disallowed */
	    strcmp(expansion, lastexpansion))	/* different from previous */
	    break;
    }

    if (expansion != 0) {
	Char *copybuffer;
	size_t del_cnt = strlen(lastexpansion) - hint_len;
	size_t buf_cnt = del_cnt + strlen(expansion) - hint_len;

	if ((copybuffer = TypeMallocN(Char, buf_cnt)) != 0) {
	    /* delete previous expansion */
	    memset(copybuffer, screen->dabbrev_erase_char, del_cnt);
	    memmove(copybuffer + del_cnt,
		    expansion + hint_len,
		    strlen(expansion) - hint_len);
	    v_write(pty, copybuffer, (unsigned) buf_cnt);
	    /* v_write() just reset our flag */
	    screen->dabbrev_working = True;
	    free(copybuffer);

	    free(lastexpansion);

	    if ((lastexpansion = strdup(expansion)) != 0) {
		result = 1;
		expansions++;
	    }
	}
    }

    return result;
}

/*ARGSUSED*/
void
HandleDabbrevExpand(Widget w,
		    XEvent *event GCC_UNUSED,
		    String *params GCC_UNUSED,
		    Cardinal *nparams GCC_UNUSED)
{
    XtermWidget xw;

    TRACE(("Handle dabbrev-expand for %p\n", (void *) w));
    if ((xw = getXtermWidget(w)) != 0) {
	if (!dabbrev_expand(xw))
	    Bell(xw, XkbBI_TerminalBell, 0);
    }
}
#endif /* OPT_DABBREV */

#if OPT_MAXIMIZE
/*ARGSUSED*/
void
HandleDeIconify(Widget w,
		XEvent *event GCC_UNUSED,
		String *params GCC_UNUSED,
		Cardinal *nparams GCC_UNUSED)
{
    XtermWidget xw;

    if ((xw = getXtermWidget(w)) != 0) {
	TScreen *screen = TScreenOf(xw);
	XMapWindow(screen->display, VShellWindow(xw));
    }
}

/*ARGSUSED*/
void
HandleIconify(Widget w,
	      XEvent *event GCC_UNUSED,
	      String *params GCC_UNUSED,
	      Cardinal *nparams GCC_UNUSED)
{
    XtermWidget xw;

    if ((xw = getXtermWidget(w)) != 0) {
	TScreen *screen = TScreenOf(xw);
	XIconifyWindow(screen->display,
		       VShellWindow(xw),
		       DefaultScreen(screen->display));
    }
}

int
QueryMaximize(XtermWidget xw, unsigned *width, unsigned *height)
{
    TScreen *screen = TScreenOf(xw);
    XSizeHints hints;
    long supp = 0;
    Window root_win;
    int root_x = -1;		/* saved co-ordinates */
    int root_y = -1;
    unsigned root_border;
    unsigned root_depth;
    int code;

    if (XGetGeometry(screen->display,
		     RootWindowOfScreen(XtScreen(xw)),
		     &root_win,
		     &root_x,
		     &root_y,
		     width,
		     height,
		     &root_border,
		     &root_depth)) {
	TRACE(("QueryMaximize: XGetGeometry position %d,%d size %d,%d border %d\n",
	       root_x,
	       root_y,
	       *width,
	       *height,
	       root_border));

	*width -= (root_border * 2);
	*height -= (root_border * 2);

	hints.flags = PMaxSize;
	if (XGetWMNormalHints(screen->display,
			      VShellWindow(xw),
			      &hints,
			      &supp)
	    && (hints.flags & PMaxSize) != 0) {

	    TRACE(("QueryMaximize: WM hints max_w %#x max_h %#x\n",
		   hints.max_width,
		   hints.max_height));

	    if ((unsigned) hints.max_width < *width)
		*width = (unsigned) hints.max_width;
	    if ((unsigned) hints.max_height < *height)
		*height = (unsigned) hints.max_height;
	}
	code = 1;
    } else {
	*width = 0;
	*height = 0;
	code = 0;
    }
    return code;
}

void
RequestMaximize(XtermWidget xw, int maximize)
{
    TScreen *screen = TScreenOf(xw);
    XWindowAttributes wm_attrs, vshell_attrs;
    unsigned root_width, root_height;
    Boolean success = False;

    TRACE(("RequestMaximize %d:%s\n",
	   maximize,
	   (maximize
	    ? "maximize"
	    : "restore")));

    /*
     * Before any maximize, ensure that we can capture the current screensize
     * as well as the estimated root-window size.
     */
    if (maximize
	&& QueryMaximize(xw, &root_width, &root_height)
	&& xtermGetWinAttrs(screen->display,
			    WMFrameWindow(xw),
			    &wm_attrs)
	&& xtermGetWinAttrs(screen->display,
			    VShellWindow(xw),
			    &vshell_attrs)) {

	if (screen->restore_data != True
	    || screen->restore_width != root_width
	    || screen->restore_height != root_height) {
	    screen->restore_data = True;
	    screen->restore_x = wm_attrs.x + wm_attrs.border_width;
	    screen->restore_y = wm_attrs.y + wm_attrs.border_width;
	    screen->restore_width = (unsigned) vshell_attrs.width;
	    screen->restore_height = (unsigned) vshell_attrs.height;
	    TRACE(("RequestMaximize: save window position %d,%d size %d,%d\n",
		   screen->restore_x,
		   screen->restore_y,
		   screen->restore_width,
		   screen->restore_height));
	}

	/* subtract wm decoration dimensions */
	root_width -= (unsigned) ((wm_attrs.width - vshell_attrs.width)
				  + (wm_attrs.border_width * 2));
	root_height -= (unsigned) ((wm_attrs.height - vshell_attrs.height)
				   + (wm_attrs.border_width * 2));
	success = True;
    } else if (screen->restore_data) {
	success = True;
	maximize = 0;
    }

    if (success) {
	switch (maximize) {
	case 3:
	    FullScreen(xw, 3);	/* depends on EWMH */
	    break;
	case 2:
	    FullScreen(xw, 2);	/* depends on EWMH */
	    break;
	case 1:
	    FullScreen(xw, 0);	/* overrides any EWMH hint */
	    XMoveResizeWindow(screen->display, VShellWindow(xw),
			      0 + wm_attrs.border_width,	/* x */
			      0 + wm_attrs.border_width,	/* y */
			      root_width,
			      root_height);
	    break;

	default:
	    FullScreen(xw, 0);	/* reset any EWMH hint */
	    if (screen->restore_data) {
		screen->restore_data = False;

		TRACE(("HandleRestoreSize: position %d,%d size %d,%d\n",
		       screen->restore_x,
		       screen->restore_y,
		       screen->restore_width,
		       screen->restore_height));

		XMoveResizeWindow(screen->display,
				  VShellWindow(xw),
				  screen->restore_x,
				  screen->restore_y,
				  screen->restore_width,
				  screen->restore_height);
	    }
	    break;
	}
    }
}

/*ARGSUSED*/
void
HandleMaximize(Widget w,
	       XEvent *event GCC_UNUSED,
	       String *params GCC_UNUSED,
	       Cardinal *nparams GCC_UNUSED)
{
    XtermWidget xw;

    if ((xw = getXtermWidget(w)) != 0) {
	RequestMaximize(xw, 1);
    }
}

/*ARGSUSED*/
void
HandleRestoreSize(Widget w,
		  XEvent *event GCC_UNUSED,
		  String *params GCC_UNUSED,
		  Cardinal *nparams GCC_UNUSED)
{
    XtermWidget xw;

    if ((xw = getXtermWidget(w)) != 0) {
	RequestMaximize(xw, 0);
    }
}
#endif /* OPT_MAXIMIZE */

void
Redraw(void)
{
    TScreen *screen = TScreenOf(term);
    XExposeEvent event;

    TRACE(("Redraw\n"));

    event.type = Expose;
    event.display = screen->display;
    event.x = 0;
    event.y = 0;
    event.count = 0;

    if (VWindow(screen)) {
	event.window = VWindow(screen);
	event.width = term->core.width;
	event.height = term->core.height;
	(*term->core.widget_class->core_class.expose) ((Widget) term,
						       (XEvent *) &event,
						       NULL);
	if (ScrollbarWidth(screen)) {
	    (screen->scrollWidget->core.widget_class->core_class.expose)
		(screen->scrollWidget, (XEvent *) &event, NULL);
	}
    }
#if OPT_TEK4014
    if (TEK4014_SHOWN(term)) {
	TekScreen *tekscr = TekScreenOf(tekWidget);
	event.window = TWindow(tekscr);
	event.width = tekWidget->core.width;
	event.height = tekWidget->core.height;
	TekExpose((Widget) tekWidget, (XEvent *) &event, NULL);
    }
#endif
}

#ifdef VMS
#define TIMESTAMP_FMT "%s%d-%02d-%02d-%02d-%02d-%02d"
#else
#define TIMESTAMP_FMT "%s%d-%02d-%02d.%02d:%02d:%02d"
#endif

void
timestamp_filename(char *dst, const char *src)
{
    time_t tstamp;
    struct tm *tstruct;

    tstamp = time((time_t *) 0);
    tstruct = localtime(&tstamp);
    sprintf(dst, TIMESTAMP_FMT,
	    src,
	    (int) tstruct->tm_year + 1900,
	    tstruct->tm_mon + 1,
	    tstruct->tm_mday,
	    tstruct->tm_hour,
	    tstruct->tm_min,
	    tstruct->tm_sec);
}

int
open_userfile(uid_t uid, gid_t gid, char *path, Bool append)
{
    int fd;
    struct stat sb;

#ifdef VMS
    if ((fd = open(path, O_WRONLY | O_CREAT | O_TRUNC, 0644)) < 0) {
	int the_error = errno;
	xtermWarning("cannot open %s: %d:%s\n",
		     path,
		     the_error,
		     SysErrorMsg(the_error));
	return -1;
    }
    chown(path, uid, gid);
#else
    if ((access(path, F_OK) != 0 && (errno != ENOENT))
	|| (creat_as(uid, gid, append, path, 0644) <= 0)
	|| ((fd = open(path, O_WRONLY | O_APPEND)) < 0)) {
	int the_error = errno;
	xtermWarning("cannot open %s: %d:%s\n",
		     path,
		     the_error,
		     SysErrorMsg(the_error));
	return -1;
    }
#endif

    /*
     * Doublecheck that the user really owns the file that we've opened before
     * we do any damage, and that it is not world-writable.
     */
    if (fstat(fd, &sb) < 0
	|| sb.st_uid != uid
	|| (sb.st_mode & 022) != 0) {
	xtermWarning("you do not own %s\n", path);
	close(fd);
	return -1;
    }
    return fd;
}

#ifndef VMS
/*
 * Create a file only if we could with the permissions of the real user id.
 * We could emulate this with careful use of access() and following
 * symbolic links, but that is messy and has race conditions.
 * Forking is messy, too, but we can't count on setreuid() or saved set-uids
 * being available.
 *
 * Note: When called for user logging, we have ensured that the real and
 * effective user ids are the same, so this remains as a convenience function
 * for the debug logs.
 *
 * Returns
 *	 1 if we can proceed to open the file in relative safety,
 *	-1 on error, e.g., cannot fork
 *	 0 otherwise.
 */
int
creat_as(uid_t uid, gid_t gid, Bool append, char *pathname, unsigned mode)
{
    int fd;
    pid_t pid;
    int retval = 0;
    int childstat = 0;
#ifndef HAVE_WAITPID
    int waited;
    void (*chldfunc) (int);

    chldfunc = signal(SIGCHLD, SIG_DFL);
#endif /* HAVE_WAITPID */

    TRACE(("creat_as(uid=%d/%d, gid=%d/%d, append=%d, pathname=%s, mode=%#o)\n",
	   (int) uid, (int) geteuid(),
	   (int) gid, (int) getegid(),
	   append,
	   pathname,
	   mode));

    if (uid == geteuid() && gid == getegid()) {
	fd = open(pathname,
		  O_WRONLY | O_CREAT | (append ? O_APPEND : O_EXCL),
		  mode);
	if (fd >= 0)
	    close(fd);
	return (fd >= 0);
    }

    pid = fork();
    switch (pid) {
    case 0:			/* child */
	if (setgid(gid) == -1
	    || setuid(uid) == -1) {
	    /* we cannot report an error here via stderr, just quit */
	    retval = 1;
	} else {
	    fd = open(pathname,
		      O_WRONLY | O_CREAT | (append ? O_APPEND : O_EXCL),
		      mode);
	    if (fd >= 0) {
		close(fd);
		retval = 0;
	    } else {
		retval = 1;
	    }
	}
	_exit(retval);
	/* NOTREACHED */
    case -1:			/* error */
	return retval;
    default:			/* parent */
#ifdef HAVE_WAITPID
	while (waitpid(pid, &childstat, 0) < 0) {
#ifdef EINTR
	    if (errno == EINTR)
		continue;
#endif /* EINTR */
#ifdef ERESTARTSYS
	    if (errno == ERESTARTSYS)
		continue;
#endif /* ERESTARTSYS */
	    break;
	}
#else /* HAVE_WAITPID */
	waited = wait(&childstat);
	signal(SIGCHLD, chldfunc);
	/*
	   Since we had the signal handler uninstalled for a while,
	   we might have missed the termination of our screen child.
	   If we can check for this possibility without hanging, do so.
	 */
	do
	    if (waited == TScreenOf(term)->pid)
		NormalExit();
	while ((waited = nonblocking_wait()) > 0) ;
#endif /* HAVE_WAITPID */
#ifndef WIFEXITED
#define WIFEXITED(status) ((status & 0xff) != 0)
#endif
	if (WIFEXITED(childstat))
	    retval = 1;
	return retval;
    }
}
#endif /* !VMS */

int
xtermResetIds(TScreen *screen)
{
    int result = 0;
    if (setgid(screen->gid) == -1) {
	xtermWarning("unable to reset group-id\n");
	result = -1;
    }
    if (setuid(screen->uid) == -1) {
	xtermWarning("unable to reset user-id\n");
	result = -1;
    }
    return result;
}

#ifdef ALLOWLOGGING

/*
 * Logging is a security hole, since it allows a setuid program to write
 * arbitrary data to an arbitrary file.  So it is disabled by default.
 */

#ifdef ALLOWLOGFILEEXEC
static void
logpipe(int sig GCC_UNUSED)
{
    XtermWidget xw = term;
    TScreen *screen = TScreenOf(xw);

    DEBUG_MSG("handle:logpipe\n");
#ifdef SYSV
    (void) signal(SIGPIPE, SIG_IGN);
#endif /* SYSV */
    if (screen->logging)
	CloseLog(xw);
}
#endif /* ALLOWLOGFILEEXEC */

void
StartLog(XtermWidget xw)
{
    static char *log_default;
    TScreen *screen = TScreenOf(xw);

    if (screen->logging || (screen->inhibit & I_LOG))
	return;
#ifdef VMS			/* file name is fixed in VMS variant */
    screen->logfd = open(XTERM_VMS_LOGFILE,
			 O_CREAT | O_TRUNC | O_APPEND | O_RDWR,
			 0640);
    if (screen->logfd < 0)
	return;			/* open failed */
#else /*VMS */
    if (screen->logfile == NULL || *screen->logfile == 0) {
	if (screen->logfile)
	    free(screen->logfile);
	if (log_default == NULL) {
#if defined(HAVE_GETHOSTNAME) && defined(HAVE_STRFTIME)
	    const char form[] = "Xterm.log.%s%s.%d";
	    char where[255 + 1];	/* Internet standard limit (RFC 1035):
					   ``To simplify implementations, the
					   total length of a domain name (i.e.,
					   label octets and label length
					   octets) is restricted to 255 octets
					   or less.'' */
	    char when[LEN_TIMESTAMP];
	    char formatted[sizeof(form) + sizeof(where) + sizeof(when) + 9];
	    time_t now;
	    struct tm *ltm;

	    now = time((time_t *) 0);
	    ltm = (struct tm *) localtime(&now);
	    if ((gethostname(where, sizeof(where)) == 0) &&
		(strftime(when, sizeof(when), FMT_TIMESTAMP, ltm) > 0)) {
		(void) sprintf(formatted, form, where, when, (int) getpid());
	    } else {
		return;
	    }
	    if ((log_default = x_strdup(formatted)) == NULL) {
		return;
	    }
#else
	    static const char log_def_name[] = "XtermLog.XXXXXX";
	    if ((log_default = x_strdup(log_def_name)) == NULL) {
		return;
	    }
	    mktemp(log_default);
#endif
	}
	if ((screen->logfile = x_strdup(log_default)) == 0)
	    return;
    }
    if (*screen->logfile == '|') {	/* exec command */
#ifdef ALLOWLOGFILEEXEC
	/*
	 * Warning, enabling this "feature" allows arbitrary programs
	 * to be run.  If ALLOWLOGFILECHANGES is enabled, this can be
	 * done through escape sequences....  You have been warned.
	 */
	int pid;
	int p[2];
	static char *shell;
	struct passwd pw;

	if ((shell = x_getenv("SHELL")) == NULL) {

	    if (x_getpwuid(screen->uid, &pw)) {
		char *name = x_getlogin(screen->uid, &pw);
		if (*(pw.pw_shell)) {
		    shell = pw.pw_shell;
		}
		free(name);
	    }
	}

	if (shell == 0) {
	    static char dummy[] = "/bin/sh";
	    shell = dummy;
	}

	if (access(shell, X_OK) != 0) {
	    xtermPerror("Can't execute `%s'\n", shell);
	    return;
	}

	if (pipe(p) < 0) {
	    xtermPerror("Can't make a pipe connection\n");
	    return;
	} else if ((pid = fork()) < 0) {
	    xtermPerror("Can't fork...\n");
	    return;
	}
	if (pid == 0) {		/* child */
	    /*
	     * Close our output (we won't be talking back to the
	     * parent), and redirect our child's output to the
	     * original stderr.
	     */
	    close(p[1]);
	    dup2(p[0], 0);
	    close(p[0]);
	    dup2(fileno(stderr), 1);
	    dup2(fileno(stderr), 2);

	    close(fileno(stderr));
	    close(ConnectionNumber(screen->display));
	    close(screen->respond);

	    signal(SIGHUP, SIG_DFL);
	    signal(SIGCHLD, SIG_DFL);

	    /* (this is redundant) */
	    if (xtermResetIds(screen) < 0)
		exit(ERROR_SETUID);

	    if (access(shell, X_OK) == 0) {
		execl(shell, shell, "-c", &screen->logfile[1], (void *) 0);
		xtermWarning("Can't exec `%s'\n", &screen->logfile[1]);
	    } else {
		xtermWarning("Can't execute `%s'\n", shell);
	    }
	    exit(ERROR_LOGEXEC);
	}
	close(p[0]);
	screen->logfd = p[1];
	signal(SIGPIPE, logpipe);
#else
	Bell(xw, XkbBI_Info, 0);
	Bell(xw, XkbBI_Info, 0);
	return;
#endif
    } else {
	if ((screen->logfd = open_userfile(screen->uid,
					   screen->gid,
					   screen->logfile,
					   (log_default != 0))) < 0)
	    return;
    }
#endif /*VMS */
    screen->logstart = VTbuffer->next;
    screen->logging = True;
    update_logging();
}

void
CloseLog(XtermWidget xw)
{
    TScreen *screen = TScreenOf(xw);

    if (!screen->logging || (screen->inhibit & I_LOG))
	return;
    FlushLog(xw);
    close(screen->logfd);
    screen->logging = False;
    update_logging();
}

void
FlushLog(XtermWidget xw)
{
    TScreen *screen = TScreenOf(xw);

    if (screen->logging && !(screen->inhibit & I_LOG)) {
	Char *cp;
	int i;

#ifdef VMS			/* avoid logging output loops which otherwise occur sometimes
				   when there is no output and cp/screen->logstart are 1 apart */
	if (!tt_new_output)
	    return;
	tt_new_output = False;
#endif /* VMS */
	cp = VTbuffer->next;
	if (screen->logstart != 0
	    && (i = (int) (cp - screen->logstart)) > 0) {
	    IGNORE_RC(write(screen->logfd, screen->logstart, (size_t) i));
	}
	screen->logstart = VTbuffer->next;
    }
}

#endif /* ALLOWLOGGING */

/***====================================================================***/

int
getVisualInfo(XtermWidget xw)
{
#define MYFMT "getVisualInfo \
depth %d, \
type %d (%s), \
size %d \
rgb masks (%04lx/%04lx/%04lx)\n"
#define MYARG \
       vi->depth,\
       vi->class,\
       ((vi->class & 1) ? "dynamic" : "static"),\
       vi->colormap_size,\
       vi->red_mask,\
       vi->green_mask,\
       vi->blue_mask

    TScreen *screen = TScreenOf(xw);
    Display *dpy = screen->display;
    XVisualInfo myTemplate;

    if (xw->visInfo == 0 && xw->numVisuals == 0) {
	myTemplate.visualid = XVisualIDFromVisual(DefaultVisual(dpy,
								XDefaultScreen(dpy)));
	xw->visInfo = XGetVisualInfo(dpy, (long) VisualIDMask,
				     &myTemplate, &xw->numVisuals);

	if ((xw->visInfo != 0) && (xw->numVisuals > 0)) {
	    XVisualInfo *vi = xw->visInfo;
	    if (resource.reportColors) {
		printf(MYFMT, MYARG);
	    }
	    TRACE((MYFMT, MYARG));
	}
    }
    return (xw->visInfo != 0) && (xw->numVisuals > 0);
#undef MYFMT
#undef MYARG
}

#if OPT_ISO_COLORS
static void
ReportAnsiColorRequest(XtermWidget xw, int colornum, int final)
{
    if (AllowColorOps(xw, ecGetAnsiColor)) {
	XColor color;
	Colormap cmap = xw->core.colormap;
	char buffer[80];

	TRACE(("ReportAnsiColorRequest %d\n", colornum));
	color.pixel = GET_COLOR_RES(xw, TScreenOf(xw)->Acolors[colornum]);
	XQueryColor(TScreenOf(xw)->display, cmap, &color);
	sprintf(buffer, "4;%d;rgb:%04x/%04x/%04x",
		colornum,
		color.red,
		color.green,
		color.blue);
	unparseputc1(xw, ANSI_OSC);
	unparseputs(xw, buffer);
	unparseputc1(xw, final);
	unparse_end(xw);
    }
}

static void
getColormapInfo(XtermWidget xw, unsigned *typep, unsigned *sizep)
{
    if (getVisualInfo(xw)) {
	*typep = (unsigned) xw->visInfo->class;
	*sizep = (unsigned) xw->visInfo->colormap_size;
    } else {
	*typep = 0;
	*sizep = 0;
    }
}

#define MAX_COLORTABLE 4096

/*
 * Make only one call to XQueryColors(), since it can be slow.
 */
static Boolean
loadColorTable(XtermWidget xw, unsigned length)
{
    Colormap cmap = xw->core.colormap;
    TScreen *screen = TScreenOf(xw);
    Boolean result = (screen->cmap_data != 0);

    if (!result
	&& length != 0
	&& length < MAX_COLORTABLE) {
	screen->cmap_data = TypeMallocN(XColor, (size_t) length);

	if (screen->cmap_data != 0) {
	    unsigned i;

	    screen->cmap_size = length;

	    for (i = 0; i < screen->cmap_size; i++) {
		screen->cmap_data[i].pixel = (unsigned long) i;
	    }
	    result = (Boolean) (XQueryColors(screen->display,
					     cmap,
					     screen->cmap_data,
					     (int) screen->cmap_size) != 0);
	}
    }
    return result;
}

/*
 * Find closest color for "def" in "cmap".
 * Set "def" to the resulting color.
 *
 * Based on Monish Shah's "find_closest_color()" for Vim 6.0,
 * modified with ideas from David Tong's "noflash" library.
 * The code from Vim in turn was derived from FindClosestColor() in Tcl/Tk.
 *
 * Return False if not able to find or allocate a color.
 */
static Boolean
allocateClosestRGB(XtermWidget xw, Colormap cmap, XColor *def)
{
    TScreen *screen = TScreenOf(xw);
    Boolean result = False;
    unsigned cmap_type;
    unsigned cmap_size;

    getColormapInfo(xw, &cmap_type, &cmap_size);

    if ((cmap_type & 1) != 0) {

	if (loadColorTable(xw, cmap_size)) {
	    char *tried = TypeCallocN(char, (size_t) cmap_size);

	    if (tried != 0) {
		unsigned attempts;

		/*
		 * Try (possibly each entry in the color map) to find the best
		 * approximation to the requested color.
		 */
		for (attempts = 0; attempts < cmap_size; attempts++) {
		    Boolean first = True;
		    double bestRGB = 0.0;
		    unsigned bestInx = 0;
		    unsigned i;

		    for (i = 0; i < cmap_size; i++) {
			if (!tried[bestInx]) {
			    double diff, thisRGB = 0.0;

			    /*
			     * Look for the best match based on luminance.
			     * Measure this by the least-squares difference of
			     * the weighted R/G/B components from the color map
			     * versus the requested color.  Use the Y (luma)
			     * component of the YIQ color space model for
			     * weights that correspond to the luminance.
			     */
#define AddColorWeight(weight, color) \
			    diff = weight * (int) ((def->color) - screen->cmap_data[i].color); \
			    thisRGB += diff * diff

			    AddColorWeight(0.30, red);
			    AddColorWeight(0.61, green);
			    AddColorWeight(0.11, blue);

			    if (first || (thisRGB < bestRGB)) {
				first = False;
				bestInx = i;
				bestRGB = thisRGB;
			    }
			}
		    }
		    if (XAllocColor(screen->display, cmap,
				    &screen->cmap_data[bestInx]) != 0) {
			*def = screen->cmap_data[bestInx];
			TRACE(("...closest %x/%x/%x\n", def->red,
			       def->green, def->blue));
			result = True;
			break;
		    }
		    /*
		     * It failed - either the color map entry was readonly, or
		     * another client has allocated the entry.  Mark the entry
		     * so we will ignore it
		     */
		    tried[bestInx] = True;
		}
		free(tried);
	    }
	}
    }
    return result;
}

#ifndef ULONG_MAX
#define ULONG_MAX (unsigned long)(~(0L))
#endif

#define CheckColor(result, value) \
	    result = 0; \
	    if (value.red) \
		result |= 1; \
	    if (value.green) \
		result |= 2; \
	    if (value.blue) \
		result |= 4

#define SelectColor(state, value, result) \
	switch (state) { \
	default: \
	case 1: \
	    result = value.red; \
	    break; \
	case 2: \
	    result = value.green; \
	    break; \
	case 4: \
	    result = value.blue; \
	    break; \
	}

/*
 * Check if the color map consists of values in exactly one of the red, green
 * or blue columns.  If it is not, we do not know how to use it for the exact
 * match.
 */
static int
simpleColors(XColor *colortable, unsigned length)
{
    unsigned n;
    int state = 0;
    int check;

    for (n = 0; n < length; ++n) {
	if (state > 0) {
	    CheckColor(check, colortable[n]);
	    if (check > 0 && check != state) {
		state = 0;
		break;
	    }
	} else {
	    CheckColor(state, colortable[n]);
	}
    }
    switch (state) {
    case 1:
    case 2:
    case 4:
	break;
    default:
	state = 0;
	break;
    }
    return state;
}

/*
 * Shift the mask left or right to put its most significant bit at the 16-bit
 * mark.
 */
static unsigned
normalizeMask(unsigned mask)
{
    while (mask < 0x8000) {
	mask <<= 1;
    }
    while (mask >= 0x10000) {
	mask >>= 1;
    }
    return mask;
}

static unsigned
searchColors(XColor *colortable, unsigned mask, unsigned length, unsigned
	     color, int state)
{
    unsigned result = 0;
    unsigned n;
    unsigned long best = ULONG_MAX;
    unsigned value;

    mask = normalizeMask(mask);
    for (n = 0; n < length; ++n) {
	unsigned long diff;

	SelectColor(state, colortable[n], value);
	diff = ((color & mask) - (value & mask));
	diff *= diff;
	if (diff < best) {
#if 0
	    TRACE(("...%d:looking for %x, found %x/%x/%x (%lx)\n",
		   n, color,
		   colortable[n].red,
		   colortable[n].green,
		   colortable[n].blue,
		   diff));
#endif
	    result = n;
	    best = diff;
	}
    }
    SelectColor(state, colortable[result], value);
    return value;
}

/*
 * This is a workaround for a longstanding defect in the X libraries.
 *
 * According to
 * http://www.unix.com/man-page/all/3x/XAllocColoA/
 *
 *     XAllocColor() acts differently on static and dynamic visuals.  On Pseu-
 *     doColor, DirectColor, and GrayScale  visuals,  XAllocColor()  fails  if
 *     there  are  no  unallocated  colorcells and no allocated read-only cell
 *     exactly matches the requested RGB values.  On  StaticColor,  TrueColor,
 *     and  StaticGray  visuals,  XAllocColor() returns the closest RGB values
 *     available in the colormap.  The colorcell_in_out structure returns  the
 *     actual RGB values allocated.
 *
 * That is, XAllocColor() should suffice unless the color map is full.  In that
 * case, allocateClosestRGB() is useful for the dynamic display classes such as
 * PseudoColor.  It is not useful for TrueColor, since XQueryColors() does not
 * return regular RGB triples (unless a different scheme was used for
 * specifying the pixel values); only the blue value is filled in.  However, it
 * is filled in with the colors that the server supports.
 *
 * Also (the reason for this function), XAllocColor() does not really work as
 * described.  For some TrueColor configurations it merely returns a close
 * approximation, but not the closest.
 */
static Boolean
allocateExactRGB(XtermWidget xw, Colormap cmap, XColor *def)
{
    XColor save = *def;
    TScreen *screen = TScreenOf(xw);
    Boolean result = (Boolean) (XAllocColor(screen->display, cmap, def) != 0);

    /*
     * If this is a statically allocated display with too many items to store
     * in our array, i.e., TrueColor, see if we can improve on the result by
     * using the color values actually supported by the server.
     */
    if (result) {
	unsigned cmap_type;
	unsigned cmap_size;

	getColormapInfo(xw, &cmap_type, &cmap_size);

	if (cmap_type == TrueColor) {
	    XColor temp = *def;
	    int state;

	    if (loadColorTable(xw, cmap_size)
		&& (state = simpleColors(screen->cmap_data, cmap_size)) > 0) {
#define SearchColors(which) \
	temp.which = (unsigned short) searchColors(screen->cmap_data, \
						   (unsigned) xw->visInfo->which##_mask,\
						   cmap_size, \
						   save.which, \
						   state)
		SearchColors(red);
		SearchColors(green);
		SearchColors(blue);
		if (XAllocColor(screen->display, cmap, &temp) != 0) {
#if OPT_TRACE
		    if (temp.red != save.red
			|| temp.green != save.green
			|| temp.blue != save.blue) {
			TRACE(("...improved %x/%x/%x ->%x/%x/%x\n",
			       save.red, save.green, save.blue,
			       temp.red, temp.green, temp.blue));
		    } else {
			TRACE(("...no improvement for %x/%x/%x\n",
			       save.red, save.green, save.blue));
		    }
#endif
		    *def = temp;
		}
	    }
	}
    }

    return result;
}

/*
 * Allocate a color for the "ANSI" colors.  That actually includes colors up
 * to 256.
 *
 * Returns
 *	-1 on error
 *	0 on no change
 *	1 if a new color was allocated.
 */
static int
AllocateAnsiColor(XtermWidget xw,
		  ColorRes * res,
		  const char *spec)
{
    int result;
    XColor def;

    if (xtermAllocColor(xw, &def, spec)) {
	if (
#if OPT_COLOR_RES
	       res->mode == True &&
#endif
	       EQL_COLOR_RES(res, def.pixel)) {
	    result = 0;
	} else {
	    result = 1;
	    SET_COLOR_RES(res, def.pixel);
	    res->red = def.red;
	    res->green = def.green;
	    res->blue = def.blue;
	    TRACE(("AllocateAnsiColor[%d] %s (rgb:%04x/%04x/%04x, pixel 0x%06lx)\n",
		   (int) (res - TScreenOf(xw)->Acolors), spec,
		   def.red,
		   def.green,
		   def.blue,
		   def.pixel));
#if OPT_COLOR_RES
	    if (!res->mode)
		result = 0;
	    res->mode = True;
#endif
	}
    } else {
	TRACE(("AllocateAnsiColor %s (failed)\n", spec));
	result = -1;
    }
    return (result);
}

#if OPT_COLOR_RES
Pixel
xtermGetColorRes(XtermWidget xw, ColorRes * res)
{
    Pixel result = 0;

    if (res->mode) {
	result = res->value;
    } else {
	TRACE(("xtermGetColorRes for Acolors[%d]\n",
	       (int) (res - TScreenOf(xw)->Acolors)));

	if (res >= TScreenOf(xw)->Acolors) {
	    assert(res - TScreenOf(xw)->Acolors < MAXCOLORS);

	    if (AllocateAnsiColor(xw, res, res->resource) < 0) {
		res->value = TScreenOf(xw)->Tcolors[TEXT_FG].value;
		res->mode = -True;
		xtermWarning("Cannot allocate color \"%s\"\n",
			     NonNull(res->resource));
	    }
	    result = res->value;
	} else {
	    result = 0;
	}
    }
    return result;
}
#endif

static int
ChangeOneAnsiColor(XtermWidget xw, int color, const char *name)
{
    int code;

    if (color < 0 || color >= MAXCOLORS) {
	code = -1;
    } else {
	ColorRes *res = &(TScreenOf(xw)->Acolors[color]);

	TRACE(("ChangeAnsiColor for Acolors[%d]\n", color));
	code = AllocateAnsiColor(xw, res, name);
    }
    return code;
}

/*
 * Set or query entries in the Acolors[] array by parsing pairs of color/name
 * values from the given buffer.
 *
 * The color can be any legal index into Acolors[], which consists of the
 * 16/88/256 "ANSI" colors, followed by special color values for the various
 * colorXX resources.  The indices for the special color values are not
 * simple to work with, so an alternative is to use the calls which pass in
 * 'first' set to the beginning of those indices.
 *
 * If the name is "?", report to the host the current value for the color.
 */
static Bool
ChangeAnsiColorRequest(XtermWidget xw,
		       char *buf,
		       int first,
		       int final)
{
    int repaint = False;
    int code;
    int last = (MAXCOLORS - first);

    TRACE(("ChangeAnsiColorRequest string='%s'\n", buf));

    while (buf && *buf) {
	int color;
	char *name = strchr(buf, ';');

	if (name == NULL)
	    break;
	*name = '\0';
	name++;
	color = atoi(buf);
	if (color < 0 || color >= last)
	    break;		/* quit on any error */
	buf = strchr(name, ';');
	if (buf) {
	    *buf = '\0';
	    buf++;
	}
	if (!strcmp(name, "?")) {
	    ReportAnsiColorRequest(xw, color + first, final);
	} else {
	    code = ChangeOneAnsiColor(xw, color + first, name);
	    if (code < 0) {
		/* stop on any error */
		break;
	    } else if (code > 0) {
		repaint = True;
	    }
	    /* FIXME:  free old color somehow?  We aren't for the other color
	     * change style (dynamic colors).
	     */
	}
    }

    return (repaint);
}

static Bool
ResetOneAnsiColor(XtermWidget xw, int color, int start)
{
    Bool repaint = False;
    int last = MAXCOLORS - start;

    if (color >= 0 && color < last) {
	ColorRes *res = &(TScreenOf(xw)->Acolors[color + start]);

	if (res->mode) {
	    /* a color has been allocated for this slot - test further... */
	    if (ChangeOneAnsiColor(xw, color + start, res->resource) > 0) {
		repaint = True;
	    }
	}
    }
    return repaint;
}

int
ResetAnsiColorRequest(XtermWidget xw, char *buf, int start)
{
    int repaint = 0;
    int color;

    TRACE(("ResetAnsiColorRequest(%s)\n", buf));
    if (*buf != '\0') {
	/* reset specific colors */
	while (!IsEmpty(buf)) {
	    char *next;

	    color = (int) (strtol) (buf, &next, 10);
	    if (!PartS2L(buf, next) || (color < 0))
		break;		/* no number at all */
	    if (next != 0) {
		if (strchr(";", *next) == 0)
		    break;	/* unexpected delimiter */
		++next;
	    }

	    if (ResetOneAnsiColor(xw, color, start)) {
		++repaint;
	    }
	    buf = next;
	}
    } else {
	TRACE(("...resetting all %d colors\n", MAXCOLORS));
	for (color = 0; color < MAXCOLORS; ++color) {
	    if (ResetOneAnsiColor(xw, color, start)) {
		++repaint;
	    }
	}
    }
    TRACE(("...ResetAnsiColorRequest ->%d\n", repaint));
    return repaint;
}
#else
#define allocateClosestRGB(xw, cmap, def) 0
#define allocateExactRGB(xw, cmap, def) XAllocColor(TScreenOf(xw)->display, cmap, def)
#endif /* OPT_ISO_COLORS */

Boolean
allocateBestRGB(XtermWidget xw, XColor *def)
{
    Colormap cmap = xw->core.colormap;

    return allocateExactRGB(xw, cmap, def) || allocateClosestRGB(xw, cmap, def);
}

static Boolean
xtermAllocColor(XtermWidget xw, XColor *def, const char *spec)
{
    Boolean result = False;
    TScreen *screen = TScreenOf(xw);
    Colormap cmap = xw->core.colormap;

    if (XParseColor(screen->display, cmap, spec, def)) {
	XColor save_def = *def;
	if (resource.reportColors) {
	    printf("color  %04x/%04x/%04x = \"%s\"\n",
		   def->red, def->green, def->blue,
		   spec);
	}
	if (allocateBestRGB(xw, def)) {
	    if (resource.reportColors) {
		if (def->red != save_def.red ||
		    def->green != save_def.green ||
		    def->blue != save_def.blue) {
		    printf("color  %04x/%04x/%04x ~ \"%s\"\n",
			   def->red, def->green, def->blue,
			   spec);
		}
	    }
	    TRACE(("xtermAllocColor -> %x/%x/%x\n",
		   def->red, def->green, def->blue));
	    result = True;
	}
    }
    return result;
}

/*
 * This provides an approximation (the closest color from xterm's palette)
 * rather than the "exact" color (whatever the display could provide, actually)
 * because of the context in which it is used.
 */
#define ColorDiff(given,cache) ((long) ((cache) >> 8) - (long) (given))
int
xtermClosestColor(XtermWidget xw, int find_red, int find_green, int find_blue)
{
    int result = -1;
#if OPT_COLOR_RES && OPT_ISO_COLORS
    int n;
    int best_index = -1;
    unsigned long best_value = 0;
    unsigned long this_value;
    long diff_red, diff_green, diff_blue;

    TRACE(("xtermClosestColor(%x/%x/%x)\n", find_red, find_green, find_blue));

    for (n = NUM_ANSI_COLORS - 1; n >= 0; --n) {
	ColorRes *res = &(TScreenOf(xw)->Acolors[n]);

	/* ensure that we have a value for each of the colors */
	if (!res->mode) {
	    (void) AllocateAnsiColor(xw, res, res->resource);
	}

	/* find the closest match */
	if (res->mode == True) {
	    TRACE2(("...lookup %lx -> %x/%x/%x\n",
		    res->value, res->red, res->green, res->blue));
	    diff_red = ColorDiff(find_red, res->red);
	    diff_green = ColorDiff(find_green, res->green);
	    diff_blue = ColorDiff(find_blue, res->blue);
	    this_value = (unsigned long) ((diff_red * diff_red)
					  + (diff_green * diff_green)
					  + (diff_blue * diff_blue));
	    if (best_index < 0 || this_value < best_value) {
		best_index = n;
		best_value = this_value;
	    }
	}
    }
    TRACE(("...best match at %d with diff %lx\n", best_index, best_value));
    result = best_index;
#else
    (void) xw;
    (void) find_red;
    (void) find_green;
    (void) find_blue;
#endif
    return result;
}

#if OPT_PASTE64
static void
ManipulateSelectionData(XtermWidget xw, TScreen *screen, char *buf, int final)
{
#define PDATA(a,b) { a, #b }
    static struct {
	char given;
	String result;
    } table[] = {
	PDATA('s', SELECT),
	    PDATA('p', PRIMARY),
	    PDATA('c', CLIPBOARD),
	    PDATA('0', CUT_BUFFER0),
	    PDATA('1', CUT_BUFFER1),
	    PDATA('2', CUT_BUFFER2),
	    PDATA('3', CUT_BUFFER3),
	    PDATA('4', CUT_BUFFER4),
	    PDATA('5', CUT_BUFFER5),
	    PDATA('6', CUT_BUFFER6),
	    PDATA('7', CUT_BUFFER7),
    };

    const char *base = buf;
    Cardinal j, n = 0;

    TRACE(("Manipulate selection data\n"));

    while (*buf != ';' && *buf != '\0') {
	++buf;
    }

    if (*buf == ';') {
	char *used;

	*buf++ = '\0';

	if (*base == '\0')
	    base = "s0";

	if ((used = x_strdup(base)) != 0) {
	    String *select_args;

	    if ((select_args = TypeCallocN(String, 2 + strlen(base))) != 0) {
		while (*base != '\0') {
		    for (j = 0; j < XtNumber(table); ++j) {
			if (*base == table[j].given) {
			    used[n] = *base;
			    select_args[n++] = table[j].result;
			    TRACE(("atom[%d] %s\n", n, table[j].result));
			    break;
			}
		    }
		    ++base;
		}
		used[n] = 0;

		if (!strcmp(buf, "?")) {
		    if (AllowWindowOps(xw, ewGetSelection)) {
			TRACE(("Getting selection\n"));
			unparseputc1(xw, ANSI_OSC);
			unparseputs(xw, "52");
			unparseputc(xw, ';');

			unparseputs(xw, used);
			unparseputc(xw, ';');

			/* Tell xtermGetSelection data is base64 encoded */
			screen->base64_paste = n;
			screen->base64_final = final;

			/* terminator will be written in this call */
			xtermGetSelection((Widget) xw,
					  XtLastTimestampProcessed(TScreenOf(xw)->display),
					  select_args, n,
					  NULL);
			/*
			 * select_args is used via SelectionReceived, cannot
			 * free it here.
			 */
		    } else {
			free(select_args);
		    }
		} else {
		    if (AllowWindowOps(xw, ewSetSelection)) {
			TRACE(("Setting selection with %s\n", buf));
			ClearSelectionBuffer(screen);
			while (*buf != '\0')
			    AppendToSelectionBuffer(screen, CharOf(*buf++));
			CompleteSelection(xw, select_args, n);
		    }
		    free(select_args);
		}
	    }
	    free(used);
	}
    }
}
#endif /* OPT_PASTE64 */

/***====================================================================***/

#define IsSetUtf8Title(xw) (IsTitleMode(xw, tmSetUtf8) || (xw->screen.utf8_title))

static Bool
xtermIsPrintable(XtermWidget xw, Char **bufp, Char *last)
{
    TScreen *screen = TScreenOf(xw);
    Bool result = False;
    Char *cp = *bufp;
    Char *next = cp;

    (void) screen;
    (void) last;

#if OPT_WIDE_CHARS
    if (xtermEnvUTF8() && IsSetUtf8Title(xw)) {
	PtyData data;

	if (decodeUtf8(screen, fakePtyData(&data, cp, last))) {
	    if (data.utf_data != UCS_REPL
		&& (data.utf_data >= 128 ||
		    ansi_table[data.utf_data] == CASE_PRINT)) {
		next += (data.utf_size - 1);
		result = True;
	    } else {
		result = False;
	    }
	} else {
	    result = False;
	}
    } else
#endif
#if OPT_C1_PRINT
	if (screen->c1_printable
	    && (*cp >= 128 && *cp < 160)) {
	result = True;
    } else
#endif
    if (ansi_table[*cp] == CASE_PRINT) {
	result = True;
    }
    *bufp = next;
    return result;
}

/***====================================================================***/

/*
 * Enum corresponding to the actual OSC codes rather than the internal
 * array indices.  Compare with TermColors.
 */
typedef enum {
    OSC_TEXT_FG = 10
    ,OSC_TEXT_BG
    ,OSC_TEXT_CURSOR
    ,OSC_MOUSE_FG
    ,OSC_MOUSE_BG
#if OPT_TEK4014
    ,OSC_TEK_FG = 15
    ,OSC_TEK_BG
#endif
#if OPT_HIGHLIGHT_COLOR
    ,OSC_HIGHLIGHT_BG = 17
#endif
#if OPT_TEK4014
    ,OSC_TEK_CURSOR = 18
#endif
#if OPT_HIGHLIGHT_COLOR
    ,OSC_HIGHLIGHT_FG = 19
#endif
    ,OSC_NCOLORS
} OscTextColors;

/*
 * Map codes to OSC controls that can reset colors.
 */
#define OSC_RESET 100
#define OSC_Reset(code) (code) + OSC_RESET

static Bool
GetOldColors(XtermWidget xw)
{
    if (xw->work.oldColors == NULL) {
	int i;

	xw->work.oldColors = TypeXtMalloc(ScrnColors);
	if (xw->work.oldColors == NULL) {
	    xtermWarning("allocation failure in GetOldColors\n");
	    return (False);
	}
	xw->work.oldColors->which = 0;
	for (i = 0; i < NCOLORS; i++) {
	    xw->work.oldColors->colors[i] = 0;
	    xw->work.oldColors->names[i] = NULL;
	}
	GetColors(xw, xw->work.oldColors);
    }
    return (True);
}

static int
oppositeColor(int n)
{
    switch (n) {
    case TEXT_FG:
	n = TEXT_BG;
	break;
    case TEXT_BG:
	n = TEXT_FG;
	break;
    case MOUSE_FG:
	n = MOUSE_BG;
	break;
    case MOUSE_BG:
	n = MOUSE_FG;
	break;
#if OPT_TEK4014
    case TEK_FG:
	n = TEK_BG;
	break;
    case TEK_BG:
	n = TEK_FG;
	break;
#endif
#if OPT_HIGHLIGHT_COLOR
    case HIGHLIGHT_FG:
	n = HIGHLIGHT_BG;
	break;
    case HIGHLIGHT_BG:
	n = HIGHLIGHT_FG;
	break;
#endif
    default:
	break;
    }
    return n;
}

static void
ReportColorRequest(XtermWidget xw, int ndx, int final)
{
    if (AllowColorOps(xw, ecGetColor)) {
	XColor color;
	Colormap cmap = xw->core.colormap;
	char buffer[80];

	/*
	 * ChangeColorsRequest() has "always" chosen the opposite color when
	 * reverse-video is set.  Report this as the original color index, but
	 * reporting the opposite color which would be used.
	 */
	int i = (xw->misc.re_verse) ? oppositeColor(ndx) : ndx;

	GetOldColors(xw);
	color.pixel = xw->work.oldColors->colors[ndx];
	XQueryColor(TScreenOf(xw)->display, cmap, &color);
	sprintf(buffer, "%d;rgb:%04x/%04x/%04x", i + 10,
		color.red,
		color.green,
		color.blue);
	TRACE(("ReportColorRequest #%d: 0x%06lx as %s\n",
	       ndx, xw->work.oldColors->colors[ndx], buffer));
	unparseputc1(xw, ANSI_OSC);
	unparseputs(xw, buffer);
	unparseputc1(xw, final);
	unparse_end(xw);
    }
}

static Bool
UpdateOldColors(XtermWidget xw GCC_UNUSED, ScrnColors * pNew)
{
    int i;

    /* if we were going to free old colors, this would be the place to
     * do it.   I've decided not to (for now), because it seems likely
     * that we'd have a small set of colors we use over and over, and that
     * we could save some overhead this way.   The only case in which this
     * (clearly) fails is if someone is trying a boatload of colors, in
     * which case they can restart xterm
     */
    for (i = 0; i < NCOLORS; i++) {
	if (COLOR_DEFINED(pNew, i)) {
	    if (xw->work.oldColors->names[i] != NULL) {
		XtFree(xw->work.oldColors->names[i]);
		xw->work.oldColors->names[i] = NULL;
	    }
	    if (pNew->names[i]) {
		xw->work.oldColors->names[i] = pNew->names[i];
	    }
	    xw->work.oldColors->colors[i] = pNew->colors[i];
	}
    }
    return (True);
}

/*
 * OSC codes are constant, but the indices for the color arrays depend on how
 * xterm is compiled.
 */
static int
OscToColorIndex(OscTextColors mode)
{
    int result = 0;

#define CASE(name) case OSC_##name: result = name; break
    switch (mode) {
	CASE(TEXT_FG);
	CASE(TEXT_BG);
	CASE(TEXT_CURSOR);
	CASE(MOUSE_FG);
	CASE(MOUSE_BG);
#if OPT_TEK4014
	CASE(TEK_FG);
	CASE(TEK_BG);
#endif
#if OPT_HIGHLIGHT_COLOR
	CASE(HIGHLIGHT_BG);
	CASE(HIGHLIGHT_FG);
#endif
#if OPT_TEK4014
	CASE(TEK_CURSOR);
#endif
    case OSC_NCOLORS:
	break;
    }
    return result;
}

static Bool
ChangeColorsRequest(XtermWidget xw,
		    int start,
		    char *names,
		    int final)
{
    Bool result = False;
    ScrnColors newColors;

    TRACE(("ChangeColorsRequest start=%d, names='%s'\n", start, names));

    if (GetOldColors(xw)) {
	int i;

	newColors.which = 0;
	for (i = 0; i < NCOLORS; i++) {
	    newColors.names[i] = NULL;
	}
	for (i = start; i < OSC_NCOLORS; i++) {
	    int ndx = OscToColorIndex((OscTextColors) i);
	    if (xw->misc.re_verse)
		ndx = oppositeColor(ndx);

	    if (IsEmpty(names)) {
		newColors.names[ndx] = NULL;
	    } else {
		char *thisName = ((names[0] == ';') ? NULL : names);

		names = strchr(names, ';');
		if (names != NULL) {
		    *names++ = '\0';
		}
		if (thisName != 0) {
		    if (!strcmp(thisName, "?")) {
			ReportColorRequest(xw, ndx, final);
		    } else if (!xw->work.oldColors->names[ndx]
			       || strcmp(thisName, xw->work.oldColors->names[ndx])) {
			AllocateTermColor(xw, &newColors, ndx, thisName, False);
		    }
		}
	    }
	}

	if (newColors.which != 0) {
	    ChangeColors(xw, &newColors);
	    UpdateOldColors(xw, &newColors);
	}
	result = True;
    }
    return result;
}

static Bool
ResetColorsRequest(XtermWidget xw,
		   int code)
{
    Bool result = False;

    TRACE(("ResetColorsRequest code=%d\n", code));

#if OPT_COLOR_RES
    if (GetOldColors(xw)) {
	ScrnColors newColors;
	const char *thisName;
	int ndx = OscToColorIndex((OscTextColors) (code - OSC_RESET));

	if (xw->misc.re_verse)
	    ndx = oppositeColor(ndx);

	thisName = xw->screen.Tcolors[ndx].resource;

	newColors.which = 0;
	newColors.names[ndx] = NULL;

	if (thisName != 0
	    && xw->work.oldColors->names[ndx] != 0
	    && strcmp(thisName, xw->work.oldColors->names[ndx])) {
	    AllocateTermColor(xw, &newColors, ndx, thisName, False);

	    if (newColors.which != 0) {
		ChangeColors(xw, &newColors);
		UpdateOldColors(xw, &newColors);
	    }
	}
	result = True;
    }
#endif
    return result;
}

#if OPT_SHIFT_FONTS
/*
 * Initially, 'source' points to '#' or '?'.
 *
 * Look for an optional sign and optional number.  If those are found, lookup
 * the corresponding menu font entry.
 */
static int
ParseShiftedFont(XtermWidget xw, String source, String *target)
{
    TScreen *screen = TScreenOf(xw);
    int num = screen->menu_font_number;
    int rel = 0;

    if (*++source == '+') {
	rel = 1;
	source++;
    } else if (*source == '-') {
	rel = -1;
	source++;
    }

    if (isdigit(CharOf(*source))) {
	int val = atoi(source);
	if (rel > 0)
	    rel = val;
	else if (rel < 0)
	    rel = -val;
	else
	    num = val;
    }

    if (rel != 0) {
	num = lookupRelativeFontSize(xw,
				     screen->menu_font_number, rel);

    }
    TRACE(("ParseShiftedFont(%s) ->%d (%s)\n", *target, num, source));
    *target = source;
    return num;
}

static void
QueryFontRequest(XtermWidget xw, String buf, int final)
{
    if (AllowFontOps(xw, efGetFont)) {
	TScreen *screen = TScreenOf(xw);
	Bool success = True;
	int num;
	String base = buf + 1;
	const char *name = 0;

	num = ParseShiftedFont(xw, buf, &buf);
	if (num < 0
	    || num > fontMenu_lastBuiltin) {
	    Bell(xw, XkbBI_MinorError, 0);
	    success = False;
	} else {
#if OPT_RENDERFONT
	    if (UsingRenderFont(xw)) {
		name = getFaceName(xw, False);
	    } else
#endif
	    if ((name = screen->MenuFontName(num)) == 0) {
		success = False;
	    }
	}

	unparseputc1(xw, ANSI_OSC);
	unparseputs(xw, "50");

	if (success) {
	    unparseputc(xw, ';');
	    if (buf >= base) {
		/* identify the font-entry, unless it is the current one */
		if (*buf != '\0') {
		    char temp[10];

		    unparseputc(xw, '#');
		    sprintf(temp, "%d", num);
		    unparseputs(xw, temp);
		    if (*name != '\0')
			unparseputc(xw, ' ');
		}
	    }
	    unparseputs(xw, name);
	}

	unparseputc1(xw, final);
	unparse_end(xw);
    }
}

static void
ChangeFontRequest(XtermWidget xw, String buf)
{
    if (AllowFontOps(xw, efSetFont)) {
	TScreen *screen = TScreenOf(xw);
	Bool success = True;
	int num;
	VTFontNames fonts;
	char *name;

	/*
	 * If the font specification is a "#", followed by an optional sign and
	 * optional number, lookup the corresponding menu font entry.
	 *
	 * Further, if the "#", etc., is followed by a font name, use that
	 * to load the font entry.
	 */
	if (*buf == '#') {
	    num = ParseShiftedFont(xw, buf, &buf);

	    if (num < 0
		|| num > fontMenu_lastBuiltin) {
		Bell(xw, XkbBI_MinorError, 0);
		success = False;
	    } else {
		/*
		 * Skip past the optional number, and any whitespace to look
		 * for a font specification within the control.
		 */
		while (isdigit(CharOf(*buf))) {
		    ++buf;
		}
		while (isspace(CharOf(*buf))) {
		    ++buf;
		}
#if OPT_RENDERFONT
		if (UsingRenderFont(xw)) {
		    /* EMPTY */
		    /* there is only one font entry to load */
		    ;
		} else
#endif
		{
		    /*
		     * Normally there is no font specified in the control.
		     * But if there is, simply overwrite the font entry.
		     */
		    if (*buf == '\0') {
			if ((buf = screen->MenuFontName(num)) == 0) {
			    success = False;
			}
		    }
		}
	    }
	} else {
	    num = screen->menu_font_number;
	}
	name = x_strtrim(buf);
	if (screen->EscapeFontName()) {
	    FREE_STRING(screen->EscapeFontName());
	    screen->EscapeFontName() = 0;
	}
	if (success && !IsEmpty(name)) {
#if OPT_RENDERFONT
	    if (UsingRenderFont(xw)) {
		setFaceName(xw, name);
		xtermUpdateFontInfo(xw, True);
	    } else
#endif
	    {
		memset(&fonts, 0, sizeof(fonts));
		fonts.f_n = name;
		SetVTFont(xw, num, True, &fonts);
		if (num == screen->menu_font_number &&
		    num != fontMenu_fontescape) {
		    screen->EscapeFontName() = x_strdup(name);
		}
	    }
	} else {
	    Bell(xw, XkbBI_MinorError, 0);
	}
	update_font_escape();
	free(name);
    }
}
#endif /* OPT_SHIFT_FONTS */

/***====================================================================***/

void
do_osc(XtermWidget xw, Char *oscbuf, size_t len, int final)
{
    TScreen *screen = TScreenOf(xw);
    int mode;
    Char *cp;
    int state = 0;
    char *buf = 0;
    char temp[2];
#if OPT_ISO_COLORS
    int ansi_colors = 0;
#endif
    Bool need_data = True;
    Bool optional_data = False;

    TRACE(("do_osc %s\n", oscbuf));

    (void) screen;

    /*
     * Lines should be of the form <OSC> number ; string <ST>, however
     * older xterms can accept <BEL> as a final character.  We will respond
     * with the same final character as the application sends to make this
     * work better with shell scripts, which may have trouble reading an
     * <ESC><backslash>, which is the 7-bit equivalent to <ST>.
     */
    mode = 0;
    for (cp = oscbuf; *cp != '\0'; cp++) {
	switch (state) {
	case 0:
	    if (isdigit(*cp)) {
		mode = 10 * mode + (*cp - '0');
		if (mode > 65535) {
		    TRACE(("do_osc found unknown mode %d\n", mode));
		    return;
		}
		break;
	    }
	    /* FALLTHRU */
	case 1:
	    if (*cp != ';') {
		TRACE(("do_osc did not find semicolon offset %d\n",
		       (int) (cp - oscbuf)));
		return;
	    }
	    state = 2;
	    break;
	case 2:
	    buf = (char *) cp;
	    state = 3;
	    /* FALLTHRU */
	default:
	    if (!xtermIsPrintable(xw, &cp, oscbuf + len)) {
		switch (mode) {
		case 0:
		case 1:
		case 2:
		    break;
		default:
		    TRACE(("do_osc found nonprinting char %02X offset %d\n",
			   CharOf(*cp),
			   (int) (cp - oscbuf)));
		    return;
		}
	    }
	}
    }

    /*
     * Check if the palette changed and there are no more immediate changes
     * that could be deferred to the next repaint.
     */
    if (xw->misc.palette_changed) {
	switch (mode) {
	case 3:		/* change X property */
	case 30:		/* Konsole (unused) */
	case 31:		/* Konsole (unused) */
	case 50:		/* font operations */
	case 51:		/* Emacs (unused) */
#if OPT_PASTE64
	case 52:		/* selection data */
#endif
	    TRACE(("forced repaint after palette changed\n"));
	    xw->misc.palette_changed = False;
	    xtermRepaint(xw);
	    break;
	}
    }

    /*
     * Most OSC controls other than resets require data.  Handle the others as
     * a special case.
     */
    switch (mode) {
    case 50:
#if OPT_ISO_COLORS
    case OSC_Reset(4):
    case OSC_Reset(5):
	need_data = False;
	optional_data = True;
	break;
    case OSC_Reset(OSC_TEXT_FG):
    case OSC_Reset(OSC_TEXT_BG):
    case OSC_Reset(OSC_TEXT_CURSOR):
    case OSC_Reset(OSC_MOUSE_FG):
    case OSC_Reset(OSC_MOUSE_BG):
#if OPT_HIGHLIGHT_COLOR
    case OSC_Reset(OSC_HIGHLIGHT_BG):
    case OSC_Reset(OSC_HIGHLIGHT_FG):
#endif
#if OPT_TEK4014
    case OSC_Reset(OSC_TEK_FG):
    case OSC_Reset(OSC_TEK_BG):
    case OSC_Reset(OSC_TEK_CURSOR):
#endif
	need_data = False;
	break;
#endif
    default:
	break;
    }

    /*
     * Check if we have data when we want, and not when we do not want it.
     * Either way, that is a malformed control sequence, and will be ignored.
     */
    if (IsEmpty(buf)) {
	if (need_data) {
	    TRACE(("do_osc found no data\n"));
	    return;
	}
	temp[0] = '\0';
	buf = temp;
    } else if (!need_data && !optional_data) {
	TRACE(("do_osc found unwanted data\n"));
	return;
    }

    switch (mode) {
    case 0:			/* new icon name and title */
	ChangeIconName(xw, buf);
	ChangeTitle(xw, buf);
	break;

    case 1:			/* new icon name only */
	ChangeIconName(xw, buf);
	break;

    case 2:			/* new title only */
	ChangeTitle(xw, buf);
	break;

    case 3:			/* change X property */
	if (AllowWindowOps(xw, ewSetXprop))
	    ChangeXprop(buf);
	break;
#if OPT_ISO_COLORS
    case 5:
	ansi_colors = NUM_ANSI_COLORS;
	/* FALLTHRU */
    case 4:
	if (ChangeAnsiColorRequest(xw, buf, ansi_colors, final))
	    xw->misc.palette_changed = True;
	break;
    case 6:
	/* FALLTHRU */
    case OSC_Reset(6):
	TRACE(("parse colorXXMode:%s\n", buf));
	while (*buf != '\0') {
	    long which = 0;
	    long value = 0;
	    char *next;
	    if (*buf == ';') {
		++buf;
	    } else {
		which = strtol(buf, &next, 10);
		if (!PartS2L(buf, next) || (which < 0))
		    break;
		buf = next;
		if (*buf == ';')
		    ++buf;
	    }
	    if (*buf == ';') {
		++buf;
	    } else {
		value = strtol(buf, &next, 10);
		if (!PartS2L(buf, next) || (which < 0))
		    break;
		buf = next;
		if (*buf == ';')
		    ++buf;
	    }
	    TRACE(("updating colorXXMode which=%ld, value=%ld\n", which, value));
	    switch (which) {
	    case 0:
		screen->colorBDMode = (value != 0);
		break;
	    case 1:
		screen->colorULMode = (value != 0);
		break;
	    case 2:
		screen->colorBLMode = (value != 0);
		break;
	    case 3:
		screen->colorRVMode = (value != 0);
		break;
#if OPT_WIDE_ATTRS
	    case 4:
		screen->colorITMode = (value != 0);
		break;
#endif
	    default:
		TRACE(("...unknown colorXXMode\n"));
		break;
	    }
	}
	break;
    case OSC_Reset(5):
	ansi_colors = NUM_ANSI_COLORS;
	/* FALLTHRU */
    case OSC_Reset(4):
	if (ResetAnsiColorRequest(xw, buf, ansi_colors))
	    xw->misc.palette_changed = True;
	break;
#endif
    case OSC_TEXT_FG:
    case OSC_TEXT_BG:
    case OSC_TEXT_CURSOR:
    case OSC_MOUSE_FG:
    case OSC_MOUSE_BG:
#if OPT_HIGHLIGHT_COLOR
    case OSC_HIGHLIGHT_BG:
    case OSC_HIGHLIGHT_FG:
#endif
#if OPT_TEK4014
    case OSC_TEK_FG:
    case OSC_TEK_BG:
    case OSC_TEK_CURSOR:
#endif
	if (xw->misc.dynamicColors) {
	    ChangeColorsRequest(xw, mode, buf, final);
	}
	break;
    case OSC_Reset(OSC_TEXT_FG):
    case OSC_Reset(OSC_TEXT_BG):
    case OSC_Reset(OSC_TEXT_CURSOR):
    case OSC_Reset(OSC_MOUSE_FG):
    case OSC_Reset(OSC_MOUSE_BG):
#if OPT_HIGHLIGHT_COLOR
    case OSC_Reset(OSC_HIGHLIGHT_BG):
    case OSC_Reset(OSC_HIGHLIGHT_FG):
#endif
#if OPT_TEK4014
    case OSC_Reset(OSC_TEK_FG):
    case OSC_Reset(OSC_TEK_BG):
    case OSC_Reset(OSC_TEK_CURSOR):
#endif
	if (xw->misc.dynamicColors) {
	    ResetColorsRequest(xw, mode);
	}
	break;

    case 30:
    case 31:
	/* reserved for Konsole (Stephan Binner <Stephan.Binner@@gmx.de>) */
	break;

#ifdef ALLOWLOGGING
    case 46:			/* new log file */
#ifdef ALLOWLOGFILECHANGES
	/*
	 * Warning, enabling this feature allows people to overwrite
	 * arbitrary files accessible to the person running xterm.
	 */
	if (strcmp(buf, "?")) {
	    char *bp;
	    if ((bp = CastMallocN(char, strlen(buf))) != NULL) {
		strcpy(bp, buf);
		if (screen->logfile)
		    free(screen->logfile);
		screen->logfile = bp;
		break;
	    }
	}
#endif
	Bell(xw, XkbBI_Info, 0);
	Bell(xw, XkbBI_Info, 0);
	break;
#endif /* ALLOWLOGGING */

    case 50:
#if OPT_SHIFT_FONTS
	if (*buf == '?') {
	    QueryFontRequest(xw, buf, final);
	} else if (xw->misc.shift_fonts) {
	    ChangeFontRequest(xw, buf);
	}
#endif /* OPT_SHIFT_FONTS */
	break;
    case 51:
	/* reserved for Emacs shell (Rob Mayoff <mayoff@@dqd.com>) */
	break;

#if OPT_PASTE64
    case 52:
	ManipulateSelectionData(xw, screen, buf, final);
	break;
#endif
	/*
	 * One could write code to send back the display and host names,
	 * but that could potentially open a fairly nasty security hole.
	 */
    default:
	TRACE(("do_osc - unrecognized code\n"));
	break;
    }
    unparse_end(xw);
}

/*
 * Parse one nibble of a hex byte from the OSC string.  We have removed the
 * string-terminator (replacing it with a null), so the only other delimiter
 * that is expected is semicolon.  Ignore other characters (Ray Neuman says
 * "real" terminals accept commas in the string definitions).
 */
static int
udk_value(const char **cp)
{
    int result = -1;

    for (;;) {
	int c;

	if ((c = **cp) != '\0')
	    *cp = *cp + 1;
	if (c == ';' || c == '\0')
	    break;
	if ((result = x_hex2int(c)) >= 0)
	    break;
    }

    return result;
}

void
reset_decudk(XtermWidget xw)
{
    int n;
    for (n = 0; n < MAX_UDK; n++) {
	if (xw->work.user_keys[n].str != 0) {
	    free(xw->work.user_keys[n].str);
	    xw->work.user_keys[n].str = 0;
	    xw->work.user_keys[n].len = 0;
	}
    }
}

/*
 * Parse the data for DECUDK (user-defined keys).
 */
static void
parse_decudk(XtermWidget xw, const char *cp)
{
    while (*cp) {
	const char *base = cp;
	char *str = CastMallocN(char, strlen(cp) + 2);
	unsigned key = 0;
	int len = 0;

	if (str == NULL)
	    break;

	while (isdigit(CharOf(*cp)))
	    key = (key * 10) + (unsigned) (*cp++ - '0');

	if (*cp == '/') {
	    int lo, hi;

	    cp++;
	    while ((hi = udk_value(&cp)) >= 0
		   && (lo = udk_value(&cp)) >= 0) {
		str[len++] = (char) ((hi << 4) | lo);
	    }
	}
	if (len > 0 && key < MAX_UDK) {
	    str[len] = '\0';
	    if (xw->work.user_keys[key].str != 0)
		free(xw->work.user_keys[key].str);
	    xw->work.user_keys[key].str = str;
	    xw->work.user_keys[key].len = len;
	} else {
	    free(str);
	}
	if (*cp == ';')
	    cp++;
	if (cp == base)		/* badly-formed sequence - bail out */
	    break;
    }
}

/*
 * Parse numeric parameters.  Normally we use a state machine to simplify
 * interspersing with control characters, but have the string already.
 */
static void
parse_ansi_params(ANSI *params, const char **string)
{
    const char *cp = *string;
    ParmType nparam = 0;
    int last_empty = 1;

    memset(params, 0, sizeof(*params));
    while (*cp != '\0') {
	Char ch = CharOf(*cp++);

	if (isdigit(ch)) {
	    last_empty = 0;
	    if (nparam < NPARAM) {
		params->a_param[nparam] =
		    (ParmType) ((params->a_param[nparam] * 10)
				+ (ch - '0'));
	    }
	} else if (ch == ';') {
	    last_empty = 1;
	    nparam++;
	} else if (ch < 32) {
	    /* EMPTY */ ;
	} else {
	    /* should be 0x30 to 0x7e */
	    params->a_final = ch;
	    break;
	}
    }

    *string = cp;
    if (!last_empty)
	nparam++;
    if (nparam > NPARAM)
	params->a_nparam = NPARAM;
    else
	params->a_nparam = nparam;
}

#if OPT_TRACE
#define SOFT_WIDE 10
#define SOFT_HIGH 20

static void
parse_decdld(ANSI *params, const char *string)
{
    char DscsName[8];
    int len;
    int Pfn = params->a_param[0];
    int Pcn = params->a_param[1];
    int Pe = params->a_param[2];
    int Pcmw = params->a_param[3];
    int Pw = params->a_param[4];
    int Pt = params->a_param[5];
    int Pcmh = params->a_param[6];
    int Pcss = params->a_param[7];

    int start_char = Pcn + 0x20;
    int char_wide = ((Pcmw == 0)
		     ? (Pcss ? 6 : 10)
		     : (Pcmw > 4
			? Pcmw
			: (Pcmw + 3)));
    int char_high = ((Pcmh == 0)
		     ? ((Pcmw >= 2 && Pcmw <= 4)
			? 10
			: 20)
		     : Pcmh);
    Char ch;
    Char bits[SOFT_HIGH][SOFT_WIDE];
    Bool first = True;
    Bool prior = False;
    int row = 0, col = 0;

    TRACE(("Parsing DECDLD\n"));
    TRACE(("  font number   %d\n", Pfn));
    TRACE(("  starting char %d\n", Pcn));
    TRACE(("  erase control %d\n", Pe));
    TRACE(("  char-width    %d\n", Pcmw));
    TRACE(("  font-width    %d\n", Pw));
    TRACE(("  text/full     %d\n", Pt));
    TRACE(("  char-height   %d\n", Pcmh));
    TRACE(("  charset-size  %d\n", Pcss));

    if (Pfn > 1
	|| Pcn > 95
	|| Pe > 2
	|| Pcmw > 10
	|| Pcmw == 1
	|| Pt > 2
	|| Pcmh > 20
	|| Pcss > 1
	|| char_wide > SOFT_WIDE
	|| char_high > SOFT_HIGH) {
	TRACE(("DECDLD illegal parameter\n"));
	return;
    }

    len = 0;
    while (*string != '\0') {
	ch = CharOf(*string++);
	if (ch >= ANSI_SPA && ch <= 0x2f) {
	    if (len < 2)
		DscsName[len++] = (char) ch;
	} else if (ch >= 0x30 && ch <= 0x7e) {
	    DscsName[len++] = (char) ch;
	    break;
	}
    }
    DscsName[len] = 0;
    TRACE(("  Dscs name     '%s'\n", DscsName));

    TRACE(("  character matrix %dx%d\n", char_high, char_wide));
    while (*string != '\0') {
	if (first) {
	    TRACE(("Char %d:\n", start_char));
	    if (prior) {
		for (row = 0; row < char_high; ++row) {
		    TRACE(("%.*s\n", char_wide, bits[row]));
		}
	    }
	    prior = False;
	    first = False;
	    for (row = 0; row < char_high; ++row) {
		for (col = 0; col < char_wide; ++col) {
		    bits[row][col] = '.';
		}
	    }
	    row = col = 0;
	}
	ch = CharOf(*string++);
	if (ch >= 0x3f && ch <= 0x7e) {
	    int n;

	    ch = CharOf(ch - 0x3f);
	    for (n = 0; n < 6; ++n) {
		bits[row + n][col] = CharOf((ch & (1 << n)) ? '*' : '.');
	    }
	    col += 1;
	    prior = True;
	} else if (ch == '/') {
	    row += 6;
	    col = 0;
	} else if (ch == ';') {
	    first = True;
	    ++start_char;
	}
    }
}
#else
#define parse_decdld(p,q)	/* nothing */
#endif

void
do_dcs(XtermWidget xw, Char *dcsbuf, size_t dcslen)
{
    TScreen *screen = TScreenOf(xw);
    char reply[BUFSIZ];
    const char *cp = (const char *) dcsbuf;
    Bool okay;
    ANSI params;

    TRACE(("do_dcs(%s:%lu)\n", (char *) dcsbuf, (unsigned long) dcslen));

    if (dcslen != strlen(cp))
	/* shouldn't have nulls in the string */
	return;

    switch (*cp) {		/* intermediate character, or parameter */
    case '$':			/* DECRQSS */
	okay = True;

	cp++;
	if (*cp++ == 'q') {
	    if (!strcmp(cp, "\"q")) {	/* DECSCA */
		sprintf(reply, "%d%s",
			(screen->protected_mode == DEC_PROTECT)
			&& (xw->flags & PROTECTED) ? 1 : 0,
			cp);
	    } else if (!strcmp(cp, "\"p")) {	/* DECSCL */
		if (screen->vtXX_level < 2) {
		    /* actually none of DECRQSS is valid for vt100's */
		    break;
		}
		sprintf(reply, "%d%s%s",
			(screen->vtXX_level ?
			 screen->vtXX_level : 1) + 60,
			(screen->vtXX_level >= 2)
			? (screen->control_eight_bits
			   ? ";0" : ";1")
			: "",
			cp);
	    } else if (!strcmp(cp, "r")) {	/* DECSTBM */
		sprintf(reply, "%d;%dr",
			screen->top_marg + 1,
			screen->bot_marg + 1);
	    } else if (!strcmp(cp, "s")) {	/* DECSLRM */
		if (screen->vtXX_level >= 4) {	/* VT420 */
		    sprintf(reply, "%d;%ds",
			    screen->lft_marg + 1,
			    screen->rgt_marg + 1);
		} else {
		    okay = False;
		}
	    } else if (!strcmp(cp, "m")) {	/* SGR */
		strcpy(reply, "0");
		if (xw->flags & BOLD)
		    strcat(reply, ";1");
		if (xw->flags & UNDERLINE)
		    strcat(reply, ";4");
		if (xw->flags & BLINK)
		    strcat(reply, ";5");
		if (xw->flags & INVERSE)
		    strcat(reply, ";7");
		if (xw->flags & INVISIBLE)
		    strcat(reply, ";8");
#if OPT_256_COLORS || OPT_88_COLORS
		if_OPT_ISO_COLORS(screen, {
		    if (xw->flags & FG_COLOR) {
			if (xw->cur_foreground >= 16)
			    sprintf(reply + strlen(reply),
				    ";38;5;%d", xw->cur_foreground);
			else
			    sprintf(reply + strlen(reply),
				    ";%d%d",
				    xw->cur_foreground >= 8 ? 9 : 3,
				    xw->cur_foreground >= 8 ?
				    xw->cur_foreground - 8 :
				    xw->cur_foreground);
		    }
		    if (xw->flags & BG_COLOR) {
			if (xw->cur_background >= 16)
			    sprintf(reply + strlen(reply),
				    ";48;5;%d", xw->cur_foreground);
			else
			    sprintf(reply + strlen(reply),
				    ";%d%d",
				    xw->cur_background >= 8 ? 10 : 4,
				    xw->cur_background >= 8 ?
				    xw->cur_background - 8 :
				    xw->cur_background);
		    }
		});
#elif OPT_ISO_COLORS
		if_OPT_ISO_COLORS(screen, {
		    if (xw->flags & FG_COLOR)
			sprintf(reply + strlen(reply),
				";%d%d",
				xw->cur_foreground >= 8 ? 9 : 3,
				xw->cur_foreground >= 8 ?
				xw->cur_foreground - 8 :
				xw->cur_foreground);
		    if (xw->flags & BG_COLOR)
			sprintf(reply + strlen(reply),
				";%d%d",
				xw->cur_background >= 8 ? 10 : 4,
				xw->cur_background >= 8 ?
				xw->cur_background - 8 :
				xw->cur_background);
		});
#endif
		strcat(reply, "m");
	    } else if (!strcmp(cp, " q")) {	/* DECSCUSR */
		int code = STEADY_BLOCK;
		if (isCursorUnderline(screen))
		    code = STEADY_UNDERLINE;
		else if (isCursorBar(screen))
		    code = STEADY_BAR;
#if OPT_BLINK_CURS
		if (screen->cursor_blink_esc != 0)
		    code -= 1;
#endif
		sprintf(reply, "%d%s", code, cp);
	    } else
		okay = False;

	    if (okay) {
		unparseputc1(xw, ANSI_DCS);
		unparseputc(xw, '1');
		unparseputc(xw, '$');
		unparseputc(xw, 'r');
		cp = reply;
		unparseputs(xw, cp);
		unparseputc1(xw, ANSI_ST);
	    } else {
		unparseputc(xw, ANSI_CAN);
	    }
	} else {
	    unparseputc(xw, ANSI_CAN);
	}
	break;
#if OPT_TCAP_QUERY
    case '+':
	cp++;
	switch (*cp) {
	case 'p':
	    if (AllowTcapOps(xw, etSetTcap)) {
		set_termcap(xw, cp + 1);
	    }
	    break;
	case 'q':
	    if (AllowTcapOps(xw, etGetTcap)) {
		Bool fkey;
		unsigned state;
		int code;
		const char *tmp;
		const char *parsed = ++cp;

		code = xtermcapKeycode(xw, &parsed, &state, &fkey);

		unparseputc1(xw, ANSI_DCS);

		unparseputc(xw, code >= 0 ? '1' : '0');

		unparseputc(xw, '+');
		unparseputc(xw, 'r');

		while (*cp != 0 && (code >= -1)) {
		    if (cp == parsed)
			break;	/* no data found, error */

		    for (tmp = cp; tmp != parsed; ++tmp)
			unparseputc(xw, *tmp);

		    if (code >= 0) {
			unparseputc(xw, '=');
			screen->tc_query_code = code;
			screen->tc_query_fkey = fkey;
#if OPT_ISO_COLORS
			/* XK_COLORS is a fake code for the "Co" entry (maximum
			 * number of colors) */
			if (code == XK_COLORS) {
			    unparseputn(xw, NUM_ANSI_COLORS);
			} else
#endif
			if (code == XK_TCAPNAME) {
			    unparseputs(xw, resource.term_name);
			} else {
			    XKeyEvent event;
			    event.state = state;
			    Input(xw, &event, False);
			}
			screen->tc_query_code = -1;
		    } else {
			break;	/* no match found, error */
		    }

		    cp = parsed;
		    if (*parsed == ';') {
			unparseputc(xw, *parsed++);
			cp = parsed;
			code = xtermcapKeycode(xw, &parsed, &state, &fkey);
		    }
		}
		unparseputc1(xw, ANSI_ST);
	    }
	    break;
	}
	break;
#endif
    default:
	if (screen->terminal_id == 125 ||
	    screen->vtXX_level >= 2) {	/* VT220 */
	    parse_ansi_params(&params, &cp);
	    switch (params.a_final) {
	    case 'p':
#if OPT_REGIS_GRAPHICS
		if (screen->terminal_id == 125 ||
		    screen->terminal_id == 240 ||
		    screen->terminal_id == 241 ||
		    screen->terminal_id == 330 ||
		    screen->terminal_id == 340) {
		    parse_regis(xw, &params, cp);
		}
#else
		TRACE(("ignoring ReGIS graphic (compilation flag not enabled)\n"));
#endif
		break;
	    case 'q':
#if OPT_SIXEL_GRAPHICS
		if (screen->terminal_id == 125 ||
		    screen->terminal_id == 240 ||
		    screen->terminal_id == 241 ||
		    screen->terminal_id == 330 ||
		    screen->terminal_id == 340 ||
		    screen->terminal_id == 382) {
		    (void) parse_sixel(xw, &params, cp);
		}
#else
		TRACE(("ignoring sixel graphic (compilation flag not enabled)\n"));
#endif
		break;
	    case '|':		/* DECUDK */
		if (screen->vtXX_level >= 2) {	/* VT220 */
		    if (params.a_param[0] == 0)
			reset_decudk(xw);
		    parse_decudk(xw, cp);
		}
		break;
	    case L_CURL:	/* DECDLD */
		if (screen->vtXX_level >= 2) {	/* VT220 */
		    parse_decdld(&params, cp);
		}
		break;
	    }
	}
	break;
    }
    unparse_end(xw);
}

#if OPT_DEC_RECTOPS
enum {
    mdUnknown = 0,
    mdMaybeSet = 1,
    mdMaybeReset = 2,
    mdAlwaysSet = 3,
    mdAlwaysReset = 4
};

#define MdBool(bool)      ((bool) ? mdMaybeSet : mdMaybeReset)
#define MdFlag(mode,flag) MdBool((mode) & (flag))

/*
 * Reply is the same format as the query, with pair of mode/value:
 * 0 - not recognized
 * 1 - set
 * 2 - reset
 * 3 - permanently set
 * 4 - permanently reset
 * Only one mode can be reported at a time.
 */
void
do_rpm(XtermWidget xw, int nparams, int *params)
{
    ANSI reply;
    int count = 0;

    TRACE(("do_rpm %d:%d\n", nparams, params[0]));
    memset(&reply, 0, sizeof(reply));

    if (nparams >= 1) {
	int result = 0;

	switch (params[0]) {
	case 1:		/* GATM */
	    result = mdAlwaysReset;
	    break;
	case 2:
	    result = MdFlag(xw->keyboard.flags, MODE_KAM);
	    break;
	case 3:		/* CRM */
	    result = mdMaybeReset;
	    break;
	case 4:
	    result = MdFlag(xw->flags, INSERT);
	    break;
	case 5:		/* SRTM */
	case 7:		/* VEM */
	case 10:		/* HEM */
	case 11:		/* PUM */
	    result = mdAlwaysReset;
	    break;
	case 12:
	    result = MdFlag(xw->keyboard.flags, MODE_SRM);
	    break;
	case 13:		/* FEAM */
	case 14:		/* FETM */
	case 15:		/* MATM */
	case 16:		/* TTM */
	case 17:		/* SATM */
	case 18:		/* TSM */
	case 19:		/* EBM */
	    result = mdAlwaysReset;
	    break;
	case 20:
	    result = MdFlag(xw->flags, LINEFEED);
	    break;
	}
	reply.a_param[count++] = (ParmType) params[0];
	reply.a_param[count++] = (ParmType) result;
    }
    reply.a_type = ANSI_CSI;
    reply.a_nparam = (ParmType) count;
    reply.a_inters = '$';
    reply.a_final = 'y';
    unparseseq(xw, &reply);
}

void
do_decrpm(XtermWidget xw, int nparams, int *params)
{
    ANSI reply;
    int count = 0;

    TRACE(("do_decrpm %d:%d\n", nparams, params[0]));
    memset(&reply, 0, sizeof(reply));

    if (nparams >= 1) {
	TScreen *screen = TScreenOf(xw);
	int result = 0;

	switch (params[0]) {
	case srm_DECCKM:
	    result = MdFlag(xw->keyboard.flags, MODE_DECCKM);
	    break;
	case srm_DECANM:	/* ANSI/VT52 mode      */
#if OPT_VT52_MODE
	    result = MdBool(screen->vtXX_level >= 1);
#else
	    result = mdMaybeSet;
#endif
	    break;
	case srm_DECCOLM:
	    result = MdFlag(xw->flags, IN132COLUMNS);
	    break;
	case srm_DECSCLM:	/* (slow scroll)        */
	    result = MdFlag(xw->flags, SMOOTHSCROLL);
	    break;
	case srm_DECSCNM:
	    result = MdFlag(xw->flags, REVERSE_VIDEO);
	    break;
	case srm_DECOM:
	    result = MdFlag(xw->flags, ORIGIN);
	    break;
	case srm_DECAWM:
	    result = MdFlag(xw->flags, WRAPAROUND);
	    break;
	case srm_DECARM:
	    result = mdAlwaysReset;
	    break;
	case srm_X10_MOUSE:	/* X10 mouse                    */
	    result = MdBool(screen->send_mouse_pos == X10_MOUSE);
	    break;
#if OPT_TOOLBAR
	case srm_RXVT_TOOLBAR:
	    result = MdBool(resource.toolBar);
	    break;
#endif
#if OPT_BLINK_CURS
	case srm_ATT610_BLINK:	/* att610: Start/stop blinking cursor */
	    result = MdBool(screen->cursor_blink_res);
	    break;
#endif
	case srm_DECPFF:	/* print form feed */
	    result = MdBool(PrinterOf(screen).printer_formfeed);
	    break;
	case srm_DECPEX:	/* print extent */
	    result = MdBool(PrinterOf(screen).printer_extent);
	    break;
	case srm_DECTCEM:	/* Show/hide cursor (VT200) */
	    result = MdBool(screen->cursor_set);
	    break;
	case srm_RXVT_SCROLLBAR:
	    result = MdBool(screen->fullVwin.sb_info.width != OFF);
	    break;
#if OPT_SHIFT_FONTS
	case srm_RXVT_FONTSIZE:
	    result = MdBool(xw->misc.shift_fonts);
	    break;
#endif
#if OPT_TEK4014
	case srm_DECTEK:
	    result = MdBool(TEK4014_ACTIVE(xw));
	    break;
#endif
	case srm_132COLS:
	    result = MdBool(screen->c132);
	    break;
	case srm_CURSES_HACK:
	    result = MdBool(screen->curses);
	    break;
	case srm_DECNRCM:	/* national charset (VT220) */
	    result = MdFlag(xw->flags, NATIONAL);
	    break;
	case srm_MARGIN_BELL:	/* margin bell                  */
	    result = MdBool(screen->marginbell);
	    break;
	case srm_REVERSEWRAP:	/* reverse wraparound   */
	    result = MdFlag(xw->flags, REVERSEWRAP);
	    break;
#ifdef ALLOWLOGGING
	case srm_ALLOWLOGGING:	/* logging              */
#ifdef ALLOWLOGFILEONOFF
	    result = MdBool(screen->logging);
#endif /* ALLOWLOGFILEONOFF */
	    break;
#endif
	case srm_OPT_ALTBUF_CURSOR:	/* alternate buffer & cursor */
	    /* FALLTHRU */
	case srm_OPT_ALTBUF:
	    /* FALLTHRU */
	case srm_ALTBUF:
	    result = MdBool(screen->whichBuf);
	    break;
	case srm_DECNKM:
	    result = MdFlag(xw->keyboard.flags, MODE_DECKPAM);
	    break;
	case srm_DECBKM:
	    result = MdFlag(xw->keyboard.flags, MODE_DECBKM);
	    break;
	case srm_DECLRMM:
	    result = MdFlag(xw->flags, LEFT_RIGHT);
	    break;
#if OPT_SIXEL_GRAPHICS
	case srm_DECSDM:
	    result = MdFlag(xw->keyboard.flags, MODE_DECSDM);
	    break;
#endif
	case srm_DECNCSM:
	    result = MdFlag(xw->flags, NOCLEAR_COLM);
	    break;
	case srm_VT200_MOUSE:	/* xterm bogus sequence         */
	    result = MdBool(screen->send_mouse_pos == VT200_MOUSE);
	    break;
	case srm_VT200_HIGHLIGHT_MOUSE:	/* xterm sequence w/hilite tracking */
	    result = MdBool(screen->send_mouse_pos == VT200_HIGHLIGHT_MOUSE);
	    break;
	case srm_BTN_EVENT_MOUSE:
	    result = MdBool(screen->send_mouse_pos == BTN_EVENT_MOUSE);
	    break;
	case srm_ANY_EVENT_MOUSE:
	    result = MdBool(screen->send_mouse_pos == ANY_EVENT_MOUSE);
	    break;
#if OPT_FOCUS_EVENT
	case srm_FOCUS_EVENT_MOUSE:
	    result = MdBool(screen->send_focus_pos);
	    break;
#endif
	case srm_EXT_MODE_MOUSE:
	    /* FALLTHRU */
	case srm_SGR_EXT_MODE_MOUSE:
	    /* FALLTHRU */
	case srm_URXVT_EXT_MODE_MOUSE:
	    result = MdBool(screen->extend_coords == params[0]);
	    break;
	case srm_ALTERNATE_SCROLL:
	    result = MdBool(screen->alternateScroll);
	    break;
	case srm_RXVT_SCROLL_TTY_OUTPUT:
	    result = MdBool(screen->scrollttyoutput);
	    break;
	case srm_RXVT_SCROLL_TTY_KEYPRESS:
	    result = MdBool(screen->scrollkey);
	    break;
	case srm_EIGHT_BIT_META:
	    result = MdBool(screen->eight_bit_meta);
	    break;
#if OPT_NUM_LOCK
	case srm_REAL_NUMLOCK:
	    result = MdBool(xw->misc.real_NumLock);
	    break;
	case srm_META_SENDS_ESC:
	    result = MdBool(screen->meta_sends_esc);
	    break;
#endif
	case srm_DELETE_IS_DEL:
	    result = MdBool(screen->delete_is_del);
	    break;
#if OPT_NUM_LOCK
	case srm_ALT_SENDS_ESC:
	    result = MdBool(screen->alt_sends_esc);
	    break;
#endif
	case srm_KEEP_SELECTION:
	    result = MdBool(screen->keepSelection);
	    break;
	case srm_SELECT_TO_CLIPBOARD:
	    result = MdBool(screen->selectToClipboard);
	    break;
	case srm_BELL_IS_URGENT:
	    result = MdBool(screen->bellIsUrgent);
	    break;
	case srm_POP_ON_BELL:
	    result = MdBool(screen->poponbell);
	    break;
	case srm_TITE_INHIBIT:
	    result = MdBool(screen->sc[screen->whichBuf].saved);
	    break;
#if OPT_TCAP_FKEYS
	case srm_TCAP_FKEYS:
	    result = MdBool(xw->keyboard.type == keyboardIsTermcap);
	    break;
#endif
#if OPT_SUN_FUNC_KEYS
	case srm_SUN_FKEYS:
	    result = MdBool(xw->keyboard.type == keyboardIsSun);
	    break;
#endif
#if OPT_HP_FUNC_KEYS
	case srm_HP_FKEYS:
	    result = MdBool(xw->keyboard.type == keyboardIsHP);
	    break;
#endif
#if OPT_SCO_FUNC_KEYS
	case srm_SCO_FKEYS:
	    result = MdBool(xw->keyboard.type == keyboardIsSCO);
	    break;
#endif
	case srm_LEGACY_FKEYS:
	    result = MdBool(xw->keyboard.type == keyboardIsLegacy);
	    break;
#if OPT_SUNPC_KBD
	case srm_VT220_FKEYS:
	    result = MdBool(xw->keyboard.type == keyboardIsVT220);
	    break;
#endif
#if OPT_READLINE
	case srm_BUTTON1_MOVE_POINT:
	    result = MdBool(screen->click1_moves);
	    break;
	case srm_BUTTON2_MOVE_POINT:
	    result = MdBool(screen->paste_moves);
	    break;
	case srm_DBUTTON3_DELETE:
	    result = MdBool(screen->dclick3_deletes);
	    break;
	case srm_PASTE_IN_BRACKET:
	    result = MdBool(screen->paste_brackets);
	    break;
	case srm_PASTE_QUOTE:
	    result = MdBool(screen->paste_quotes);
	    break;
	case srm_PASTE_LITERAL_NL:
	    result = MdBool(screen->paste_literal_nl);
	    break;
#endif /* OPT_READLINE */
#if OPT_SIXEL_GRAPHICS
	case srm_PRIVATE_COLOR_REGISTERS:
	    result = MdBool(screen->privatecolorregisters);
	    break;
#endif
#if OPT_SIXEL_GRAPHICS
	case srm_SIXEL_SCROLLS_RIGHT:
	    result = MdBool(screen->sixel_scrolls_right);
	    break;
#endif
	default:
	    TRACE(("DATA_ERROR: requested report for unknown private mode %d\n",
		   params[0]));
	}
	reply.a_param[count++] = (ParmType) params[0];
	reply.a_param[count++] = (ParmType) result;
    }
    reply.a_type = ANSI_CSI;
    reply.a_pintro = '?';
    reply.a_nparam = (ParmType) count;
    reply.a_inters = '$';
    reply.a_final = 'y';
    unparseseq(xw, &reply);
}
#endif /* OPT_DEC_RECTOPS */

char *
udk_lookup(XtermWidget xw, int keycode, int *len)
{
    if (keycode >= 0 && keycode < MAX_UDK) {
	*len = xw->work.user_keys[keycode].len;
	return xw->work.user_keys[keycode].str;
    }
    return 0;
}

#ifdef HAVE_LIBXPM

#ifndef PIXMAP_ROOTDIR
#define PIXMAP_ROOTDIR "/usr/share/pixmaps/"
#endif

typedef struct {
    const char *name;
    const char *const *data;
} XPM_DATA;

static char *
x_find_icon(char **work, int *state, const char *suffix)
{
    const char *filename = resource.icon_hint;
    const char *prefix = PIXMAP_ROOTDIR;
    const char *larger = "_48x48";
    char *result = 0;

    if (*state >= 0) {
	if ((*state & 1) == 0)
	    suffix = "";
	if ((*state & 2) == 0)
	    larger = "";
	if ((*state & 4) == 0) {
	    prefix = "";
	} else if (!strncmp(filename, "/", (size_t) 1) ||
		   !strncmp(filename, "./", (size_t) 2) ||
		   !strncmp(filename, "../", (size_t) 3)) {
	    *state = -1;
	} else if (*state >= 8) {
	    *state = -1;
	}
    }

    if (*state >= 0) {
	size_t length;

	if (*work) {
	    free(*work);
	    *work = 0;
	}
	length = 3 + strlen(prefix) + strlen(filename) + strlen(larger) +
	    strlen(suffix);
	if ((result = malloc(length)) != 0) {
	    sprintf(result, "%s%s%s%s", prefix, filename, larger, suffix);
	    *work = result;
	}
	*state += 1;
	TRACE(("x_find_icon %d:%s\n", *state, result));
    }
    return result;
}

#if OPT_BUILTIN_XPMS
static const XPM_DATA *
BuiltInXPM(const XPM_DATA * table, Cardinal length)
{
    const char *find = resource.icon_hint;
    const XPM_DATA *result = 0;
    if (!IsEmpty(find)) {
	Cardinal n;
	for (n = 0; n < length; ++n) {
	    if (!x_strcasecmp(find, table[n].name)) {
		result = table + n;
		break;
	    }
	}

	/*
	 * As a fallback, check if the icon name matches without the lengths,
	 * which are all _HHxWW format.
	 */
	if (result == 0) {
	    const char *base = table[0].name;
	    const char *last = strchr(base, '_');
	    if (last != 0
		&& !x_strncasecmp(find, base, (unsigned) (last - base))) {
		result = table + length - 1;
	    }
	}
    }
    return result;
}
#endif /* OPT_BUILTIN_XPMS */

typedef enum {
    eHintDefault = 0		/* use the largest builtin-icon */
    ,eHintNone
    ,eHintSearch
} ICON_HINT;

static ICON_HINT
which_icon_hint(void)
{
    ICON_HINT result = eHintDefault;
    if (!IsEmpty(resource.icon_hint)) {
	if (!x_strcasecmp(resource.icon_hint, "none")) {
	    result = eHintNone;
	} else {
	    result = eHintSearch;
	}
    }
    return result;
}
#endif /* HAVE_LIBXPM */

int
getVisualDepth(XtermWidget xw)
{
    int result = 0;

    if (getVisualInfo(xw)) {
	result = xw->visInfo->depth;
    }
    return result;
}

/*
 * WM_ICON_SIZE should be honored if possible.
 */
void
xtermLoadIcon(XtermWidget xw)
{
#ifdef HAVE_LIBXPM
    Display *dpy = XtDisplay(xw);
    Pixmap myIcon = 0;
    Pixmap myMask = 0;
    char *workname = 0;
    ICON_HINT hint = which_icon_hint();
#include <builtin_icons.h>

    TRACE(("xtermLoadIcon %p:%s\n", (void *) xw, NonNull(resource.icon_hint)));

    if (hint == eHintSearch) {
	int state = 0;
	while (x_find_icon(&workname, &state, ".xpm") != 0) {
	    Pixmap resIcon = 0;
	    Pixmap shapemask = 0;
	    XpmAttributes attributes;

	    attributes.depth = (unsigned) getVisualDepth(xw);
	    attributes.valuemask = XpmDepth;

	    if (XpmReadFileToPixmap(dpy,
				    DefaultRootWindow(dpy),
				    workname,
				    &resIcon,
				    &shapemask,
				    &attributes) == XpmSuccess) {
		myIcon = resIcon;
		myMask = shapemask;
		TRACE(("...success\n"));
		break;
	    }
	}
    }

    /*
     * If no external file was found, look for the name in the built-in table.
     * If that fails, just use the biggest mini-icon.
     */
    if (myIcon == 0 && hint != eHintNone) {
	char **data;
#if OPT_BUILTIN_XPMS
	const XPM_DATA *myData = 0;
	myData = BuiltInXPM(mini_xterm_xpms, XtNumber(mini_xterm_xpms));
	if (myData == 0)
	    myData = BuiltInXPM(filled_xterm_xpms, XtNumber(filled_xterm_xpms));
	if (myData == 0)
	    myData = BuiltInXPM(xterm_color_xpms, XtNumber(xterm_color_xpms));
	if (myData == 0)
	    myData = BuiltInXPM(xterm_xpms, XtNumber(xterm_xpms));
	if (myData == 0)
	    myData = &mini_xterm_xpms[XtNumber(mini_xterm_xpms) - 1];
	data = (char **) myData->data;
#else
	data = (char **) &mini_xterm_48x48_xpm;
#endif
	if (XpmCreatePixmapFromData(dpy,
				    DefaultRootWindow(dpy),
				    data,
				    &myIcon, &myMask, 0) != 0) {
	    myIcon = 0;
	    myMask = 0;
	}
    }

    if (myIcon != 0) {
	XWMHints *hints = XGetWMHints(dpy, VShellWindow(xw));
	if (!hints)
	    hints = XAllocWMHints();

	if (hints) {
	    hints->flags |= IconPixmapHint;
	    hints->icon_pixmap = myIcon;
	    if (myMask) {
		hints->flags |= IconMaskHint;
		hints->icon_mask = myMask;
	    }

	    XSetWMHints(dpy, VShellWindow(xw), hints);
	    XFree(hints);
	    TRACE(("...loaded icon\n"));
	}
    }

    if (workname != 0)
	free(workname);

#else
    (void) xw;
#endif
}

void
ChangeGroup(XtermWidget xw, const char *attribute, char *value)
{
#if OPT_WIDE_CHARS
    static Char *converted;	/* NO_LEAKS */
#endif

    Arg args[1];
    Boolean changed = True;
    Widget w = CURRENT_EMU();
    Widget top = SHELL_OF(w);

    char *my_attr;
    char *name;
    size_t limit;
    Char *c1;
    Char *cp;

    if (!AllowTitleOps(xw))
	return;

    if (value == 0)
	value = emptyString;
    if (IsTitleMode(xw, tmSetBase16)) {
	const char *temp;
	char *test;

	value = x_decode_hex(value, &temp);
	if (*temp != '\0') {
	    free(value);
	    return;
	}
	for (test = value; *test != '\0'; ++test) {
	    if (CharOf(*test) < 32) {
		*test = '\0';
		break;
	    }
	}
    }

    c1 = (Char *) value;
    name = value;
    limit = strlen(name);
    my_attr = x_strdup(attribute);

    TRACE(("ChangeGroup(attribute=%s, value=%s)\n", my_attr, name));

    /*
     * Ignore titles that are too long to be plausible requests.
     */
    if (limit > 0 && limit < 1024) {

	/*
	 * After all decoding, overwrite nonprintable characters with '?'.
	 */
	for (cp = c1; *cp != 0; ++cp) {
	    Char *c2 = cp;
	    if (!xtermIsPrintable(xw, &cp, c1 + limit)) {
		memset(c2, '?', (size_t) (cp + 1 - c2));
	    }
	}

#if OPT_WIDE_CHARS
	/*
	 * If we're running in UTF-8 mode, and have not been told that the
	 * title string is in UTF-8, it is likely that non-ASCII text in the
	 * string will be rejected because it is not printable in the current
	 * locale.  So we convert it to UTF-8, allowing the X library to
	 * convert it back.
	 */
	if (xtermEnvUTF8() && !IsSetUtf8Title(xw)) {
	    int n;

	    for (n = 0; name[n] != '\0'; ++n) {
		if (CharOf(name[n]) > 127) {
		    if (converted != 0)
			free(converted);
		    if ((converted = TypeMallocN(Char, 1 + (6 * limit))) != 0) {
			Char *temp = converted;
			while (*name != 0) {
			    temp = convertToUTF8(temp, CharOf(*name));
			    ++name;
			}
			*temp = 0;
			name = (char *) converted;
			TRACE(("...converted{%s}\n", name));
		    }
		    break;
		}
	    }
	}
#endif

#if OPT_SAME_NAME
	/* If the attribute isn't going to change, then don't bother... */

	if (resource.sameName) {
	    char *buf = 0;
	    XtSetArg(args[0], my_attr, &buf);
	    XtGetValues(top, args, 1);
	    TRACE(("...comparing{%s}\n", buf));
	    if (buf != 0 && strcmp(name, buf) == 0)
		changed = False;
	}
#endif /* OPT_SAME_NAME */

	if (changed) {
	    TRACE(("...updating %s\n", my_attr));
	    TRACE(("...value is %s\n", name));
	    XtSetArg(args[0], my_attr, name);
	    XtSetValues(top, args, 1);

#if OPT_WIDE_CHARS
	    if (xtermEnvUTF8()) {
		Display *dpy = XtDisplay(xw);
		Atom my_atom;

		const char *propname = (!strcmp(my_attr, XtNtitle)
					? "_NET_WM_NAME"
					: "_NET_WM_ICON_NAME");
		if ((my_atom = XInternAtom(dpy, propname, False)) != None) {
		    if (IsSetUtf8Title(xw)) {
			TRACE(("...updating %s\n", propname));
			TRACE(("...value is %s\n", value));
			XChangeProperty(dpy, VShellWindow(xw), my_atom,
					XA_UTF8_STRING(dpy), 8,
					PropModeReplace,
					(Char *) value,
					(int) strlen(value));
		    } else {
			TRACE(("...deleting %s\n", propname));
			XDeleteProperty(dpy, VShellWindow(xw), my_atom);
		    }
		}
	    }
#endif
	}
    }
    if (IsTitleMode(xw, tmSetBase16) && (value != emptyString)) {
	free(value);
    }
    free(my_attr);

    return;
}

void
ChangeIconName(XtermWidget xw, char *name)
{
    if (name == 0) {
	name = emptyString;
    }
    if (!showZIconBeep(xw, name))
	ChangeGroup(xw, XtNiconName, name);
}

void
ChangeTitle(XtermWidget xw, char *name)
{
    ChangeGroup(xw, XtNtitle, name);
}

#define Strlen(s) strlen((const char *)(s))

void
ChangeXprop(char *buf)
{
    Display *dpy = XtDisplay(toplevel);
    Window w = XtWindow(toplevel);
    XTextProperty text_prop;
    Atom aprop;
    Char *pchEndPropName = (Char *) strchr(buf, '=');

    if (pchEndPropName)
	*pchEndPropName = '\0';
    aprop = XInternAtom(dpy, buf, False);
    if (pchEndPropName == NULL) {
	/* no "=value" given, so delete the property */
	XDeleteProperty(dpy, w, aprop);
    } else {
	text_prop.value = pchEndPropName + 1;
	text_prop.encoding = XA_STRING;
	text_prop.format = 8;
	text_prop.nitems = Strlen(text_prop.value);
	XSetTextProperty(dpy, w, &text_prop, aprop);
    }
}

/***====================================================================***/

/*
 * This is part of ReverseVideo().  It reverses the data stored for the old
 * "dynamic" colors that might have been retrieved using OSC 10-18.
 */
void
ReverseOldColors(XtermWidget xw)
{
    ScrnColors *pOld = xw->work.oldColors;
    Pixel tmpPix;
    char *tmpName;

    if (pOld) {
	/* change text cursor, if necesary */
	if (pOld->colors[TEXT_CURSOR] == pOld->colors[TEXT_FG]) {
	    pOld->colors[TEXT_CURSOR] = pOld->colors[TEXT_BG];
	    if (pOld->names[TEXT_CURSOR]) {
		XtFree(xw->work.oldColors->names[TEXT_CURSOR]);
		pOld->names[TEXT_CURSOR] = NULL;
	    }
	    if (pOld->names[TEXT_BG]) {
		if ((tmpName = x_strdup(pOld->names[TEXT_BG])) != 0) {
		    pOld->names[TEXT_CURSOR] = tmpName;
		}
	    }
	}

	EXCHANGE(pOld->colors[TEXT_FG], pOld->colors[TEXT_BG], tmpPix);
	EXCHANGE(pOld->names[TEXT_FG], pOld->names[TEXT_BG], tmpName);

	EXCHANGE(pOld->colors[MOUSE_FG], pOld->colors[MOUSE_BG], tmpPix);
	EXCHANGE(pOld->names[MOUSE_FG], pOld->names[MOUSE_BG], tmpName);

#if OPT_TEK4014
	EXCHANGE(pOld->colors[TEK_FG], pOld->colors[TEK_BG], tmpPix);
	EXCHANGE(pOld->names[TEK_FG], pOld->names[TEK_BG], tmpName);
#endif
    }
    return;
}

Bool
AllocateTermColor(XtermWidget xw,
		  ScrnColors * pNew,
		  int ndx,
		  const char *name,
		  Bool always)
{
    Bool result = False;

    if (always || AllowColorOps(xw, ecSetColor)) {
	XColor def;
	char *newName;

	result = True;
	if (!x_strcasecmp(name, XtDefaultForeground)) {
	    def.pixel = xw->old_foreground;
	} else if (!x_strcasecmp(name, XtDefaultBackground)) {
	    def.pixel = xw->old_background;
	} else if (!xtermAllocColor(xw, &def, name)) {
	    result = False;
	}

	if (result
	    && (newName = x_strdup(name)) != 0) {
	    if (COLOR_DEFINED(pNew, ndx)) {
		free(pNew->names[ndx]);
	    }
	    SET_COLOR_VALUE(pNew, ndx, def.pixel);
	    SET_COLOR_NAME(pNew, ndx, newName);
	    TRACE(("AllocateTermColor #%d: %s (pixel 0x%06lx)\n",
		   ndx, newName, def.pixel));
	} else {
	    TRACE(("AllocateTermColor #%d: %s (failed)\n", ndx, name));
	    result = False;
	}
    }
    return result;
}
/***====================================================================***/

/* ARGSUSED */
void
Panic(const char *s GCC_UNUSED, int a GCC_UNUSED)
{
    if_DEBUG({
	xtermWarning(s, a);
    });
}

const char *
SysErrorMsg(int code)
{
    static const char unknown[] = "unknown error";
    char *s = strerror(code);
    return s ? s : unknown;
}

const char *
SysReasonMsg(int code)
{
    /* *INDENT-OFF* */
    static const struct {
	int code;
	const char *name;
    } table[] = {
	{ ERROR_FIONBIO,	"main:  ioctl() failed on FIONBIO" },
	{ ERROR_F_GETFL,	"main: ioctl() failed on F_GETFL" },
	{ ERROR_F_SETFL,	"main: ioctl() failed on F_SETFL", },
	{ ERROR_OPDEVTTY,	"spawn: open() failed on /dev/tty", },
	{ ERROR_TIOCGETP,	"spawn: ioctl() failed on TIOCGETP", },
	{ ERROR_PTSNAME,	"spawn: ptsname() failed", },
	{ ERROR_OPPTSNAME,	"spawn: open() failed on ptsname", },
	{ ERROR_PTEM,		"spawn: ioctl() failed on I_PUSH/\"ptem\"" },
	{ ERROR_CONSEM,		"spawn: ioctl() failed on I_PUSH/\"consem\"" },
	{ ERROR_LDTERM,		"spawn: ioctl() failed on I_PUSH/\"ldterm\"" },
	{ ERROR_TTCOMPAT,	"spawn: ioctl() failed on I_PUSH/\"ttcompat\"" },
	{ ERROR_TIOCSETP,	"spawn: ioctl() failed on TIOCSETP" },
	{ ERROR_TIOCSETC,	"spawn: ioctl() failed on TIOCSETC" },
	{ ERROR_TIOCSETD,	"spawn: ioctl() failed on TIOCSETD" },
	{ ERROR_TIOCSLTC,	"spawn: ioctl() failed on TIOCSLTC" },
	{ ERROR_TIOCLSET,	"spawn: ioctl() failed on TIOCLSET" },
	{ ERROR_INIGROUPS,	"spawn: initgroups() failed" },
	{ ERROR_FORK,		"spawn: fork() failed" },
	{ ERROR_EXEC,		"spawn: exec() failed" },
	{ ERROR_PTYS,		"get_pty: not enough ptys" },
	{ ERROR_PTY_EXEC,	"waiting for initial map" },
	{ ERROR_SETUID,		"spawn: setuid() failed" },
	{ ERROR_INIT,		"spawn: can't initialize window" },
	{ ERROR_TIOCKSET,	"spawn: ioctl() failed on TIOCKSET" },
	{ ERROR_TIOCKSETC,	"spawn: ioctl() failed on TIOCKSETC" },
	{ ERROR_LUMALLOC,	"luit: command-line malloc failed" },
	{ ERROR_SELECT,		"in_put: select() failed" },
	{ ERROR_VINIT,		"VTInit: can't initialize window" },
	{ ERROR_KMMALLOC1,	"HandleKeymapChange: malloc failed" },
	{ ERROR_TSELECT,	"Tinput: select() failed" },
	{ ERROR_TINIT,		"TekInit: can't initialize window" },
	{ ERROR_BMALLOC2,	"SaltTextAway: malloc() failed" },
	{ ERROR_LOGEXEC,	"StartLog: exec() failed" },
	{ ERROR_XERROR,		"xerror: XError event" },
	{ ERROR_XIOERROR,	"xioerror: X I/O error" },
	{ ERROR_SCALLOC,	"Alloc: calloc() failed on base" },
	{ ERROR_SCALLOC2,	"Alloc: calloc() failed on rows" },
	{ ERROR_SAVE_PTR,	"ScrnPointers: malloc/realloc() failed" },
    };
    /* *INDENT-ON* */

    Cardinal n;
    const char *result = "?";

    for (n = 0; n < XtNumber(table); ++n) {
	if (code == table[n].code) {
	    result = table[n].name;
	    break;
	}
    }
    return result;
}

void
SysError(int code)
{
    int oerrno = errno;

    fprintf(stderr, "%s: Error %d, errno %d: ", ProgramName, code, oerrno);
    fprintf(stderr, "%s\n", SysErrorMsg(oerrno));
    fprintf(stderr, "Reason: %s\n", SysReasonMsg(code));

    Cleanup(code);
}

void
NormalExit(void)
{
    static Bool cleaning;

    /*
     * Process "-hold" and session cleanup only for a normal exit.
     */
    if (cleaning) {
	hold_screen = 0;
	return;
    }

    cleaning = True;
    need_cleanup = False;

    if (hold_screen) {
	hold_screen = 2;
	while (hold_screen) {
	    xevents();
	    Sleep(10);
	}
    }
#if OPT_SESSION_MGT
    if (resource.sessionMgt) {
	XtVaSetValues(toplevel,
		      XtNjoinSession, False,
		      (void *) 0);
    }
#endif
    Cleanup(0);
}

/*
 * cleanup by sending SIGHUP to client processes
 */
void
Cleanup(int code)
{
    TScreen *screen = TScreenOf(term);

    TRACE(("Cleanup %d\n", code));

    if (screen->pid > 1) {
	(void) kill_process_group(screen->pid, SIGHUP);
    }
    Exit(code);
}

#ifndef S_IXOTH
#define S_IXOTH 1
#endif

Boolean
validProgram(const char *pathname)
{
    Boolean result = False;
    struct stat sb;

    if (!IsEmpty(pathname)
	&& *pathname == '/'
	&& strstr(pathname, "/..") == 0
	&& stat(pathname, &sb) == 0
	&& (sb.st_mode & S_IFMT) == S_IFREG
	&& (sb.st_mode & S_IXOTH) != 0) {
	result = True;
    }
    return result;
}

#ifndef VMS
#ifndef PATH_MAX
#define PATH_MAX 512		/* ... is not defined consistently in Xos.h */
#endif
char *
xtermFindShell(char *leaf, Bool warning)
{
    char *s0;
    char *s;
    char *d;
    char *tmp;
    char *result = leaf;
    Bool allocated = False;

    TRACE(("xtermFindShell(%s)\n", leaf));

    if (!strncmp("./", result, (size_t) 2)
	|| !strncmp("../", result, (size_t) 3)) {
	size_t need = PATH_MAX;
	size_t used = strlen(result) + 2;
	char *buffer = malloc(used + need);
	if (buffer != 0) {
	    if (getcwd(buffer, need) != 0) {
		sprintf(buffer + strlen(buffer), "/%s", result);
		result = buffer;
		allocated = True;
	    } else {
		free(buffer);
	    }
	}
    } else if (*result != '\0' && strchr("+/-", *result) == 0) {
	/* find it in $PATH */
	if ((s = s0 = x_getenv("PATH")) != 0) {
	    if ((tmp = TypeMallocN(char, strlen(leaf) + strlen(s) + 2)) != 0) {
		Bool found = False;
		while (*s != '\0') {
		    strcpy(tmp, s);
		    for (d = tmp;; ++d) {
			if (*d == ':' || *d == '\0') {
			    int skip = (*d != '\0');
			    *d = '/';
			    strcpy(d + 1, leaf);
			    if (skip)
				++d;
			    s += (d - tmp);
			    if (validProgram(tmp)) {
				result = x_strdup(tmp);
				found = True;
				allocated = True;
			    }
			    break;
			}
		    }
		    if (found)
			break;
		}
		free(tmp);
	    }
	    free(s0);
	}
    }
    TRACE(("...xtermFindShell(%s)\n", result));
    if (!validProgram(result)) {
	if (warning)
	    xtermWarning("No absolute path found for shell: %s\n", result);
	if (allocated)
	    free(result);
	result = 0;
    }
    /* be consistent, so that caller can always free the result */
    if (result != 0 && !allocated)
	result = x_strdup(result);
    return result;
}
#endif /* VMS */

#define ENV_HUNK(n)	(unsigned) ((((n) + 1) | 31) + 1)

/*
 * If we do not have unsetenv(), make consistent updates for environ[].
 * This could happen on some older machines due to the uneven standardization
 * process for the two functions.
 *
 * That is, putenv() makes a copy of environ, and some implementations do not
 * update the environ pointer, so the fallback when unsetenv() is missing would
 * not work as intended.  Likewise, the reverse could be true, i.e., unsetenv
 * could copy environ.
 */
#if defined(HAVE_PUTENV) && !defined(HAVE_UNSETENV)
#undef HAVE_PUTENV
#elif !defined(HAVE_PUTENV) && defined(HAVE_UNSETENV)
#undef HAVE_UNSETENV
#endif

/*
 * copy the environment before Setenv'ing.
 */
void
xtermCopyEnv(char **oldenv)
{
#ifdef HAVE_PUTENV
    (void) oldenv;
#else
    unsigned size;
    char **newenv;

    for (size = 0; oldenv[size] != NULL; size++) {
	;
    }

    newenv = TypeCallocN(char *, ENV_HUNK(size));
    memmove(newenv, oldenv, size * sizeof(char *));
    environ = newenv;
#endif
}

#if !defined(HAVE_PUTENV) || !defined(HAVE_UNSETENV)
static int
findEnv(const char *var, int *lengthp)
{
    char *test;
    int envindex = 0;
    size_t len = strlen(var);
    int found = -1;

    TRACE(("findEnv(%s=..)\n", var));

    while ((test = environ[envindex]) != NULL) {
	if (strncmp(test, var, len) == 0 && test[len] == '=') {
	    found = envindex;
	    break;
	}
	envindex++;
    }
    *lengthp = envindex;
    return found;
}
#endif

/*
 * sets the value of var to be arg in the Unix 4.2 BSD environment env.
 * Var should end with '=' (bindings are of the form "var=value").
 * This procedure assumes the memory for the first level of environ
 * was allocated using calloc, with enough extra room at the end so not
 * to have to do a realloc().
 */
void
xtermSetenv(const char *var, const char *value)
{
    if (value != 0) {
#ifdef HAVE_PUTENV
	char *both = malloc(2 + strlen(var) + strlen(value));
	TRACE(("xtermSetenv(%s=%s)\n", var, value));
	if (both) {
	    sprintf(both, "%s=%s", var, value);
	    putenv(both);
	}
#else
	size_t len = strlen(var);
	int envindex;
	int found = findEnv(var, &envindex);

	TRACE(("xtermSetenv(%s=%s)\n", var, value));

	if (found < 0) {
	    unsigned need = ENV_HUNK(envindex + 1);
	    unsigned have = ENV_HUNK(envindex);

	    if (need > have) {
		char **newenv;
		newenv = TypeMallocN(char *, need);
		if (newenv == 0) {
		    xtermWarning("Cannot increase environment\n");
		    return;
		}
		memmove(newenv, environ, have * sizeof(*newenv));
		free(environ);
		environ = newenv;
	    }

	    found = envindex;
	    environ[found + 1] = NULL;
	    environ = environ;
	}

	environ[found] = CastMallocN(char, 1 + len + strlen(value));
	if (environ[found] == 0) {
	    xtermWarning("Cannot allocate environment %s\n", var);
	    return;
	}
	sprintf(environ[found], "%s=%s", var, value);
#endif
    }
}

void
xtermUnsetenv(const char *var)
{
    TRACE(("xtermUnsetenv(%s)\n", var));
#ifdef HAVE_UNSETENV
    unsetenv(var);
#else
    {
	int ignore;
	int item = findEnv(var, &ignore);
	if (item >= 0) {
	    while ((environ[item] = environ[item + 1]) != 0) {
		++item;
	    }
	}
    }
#endif
}

/*ARGSUSED*/
int
xerror(Display *d, XErrorEvent *ev)
{
    xtermWarning("warning, error event received:\n");
    (void) XmuPrintDefaultErrorMessage(d, ev, stderr);
    Exit(ERROR_XERROR);
    return 0;			/* appease the compiler */
}

void
ice_error(IceConn iceConn)
{
    (void) iceConn;

    xtermWarning("ICE IO error handler doing an exit(), pid = %ld, errno = %d\n",
		 (long) getpid(), errno);

    Exit(ERROR_ICEERROR);
}

/*ARGSUSED*/
int
xioerror(Display *dpy)
{
    int the_error = errno;

    xtermWarning("fatal IO error %d (%s) or KillClient on X server \"%s\"\r\n",
		 the_error, SysErrorMsg(the_error),
		 DisplayString(dpy));

    Exit(ERROR_XIOERROR);
    return 0;			/* appease the compiler */
}

void
xt_error(String message)
{
    xtermWarning("Xt error: %s\n", message);

    /*
     * Check for the obvious - Xt does a poor job of reporting this.
     */
    if (x_getenv("DISPLAY") == 0) {
	xtermWarning("DISPLAY is not set\n");
    }
    exit(1);
}

int
XStrCmp(char *s1, char *s2)
{
    if (s1 && s2)
	return (strcmp(s1, s2));
    if (s1 && *s1)
	return (1);
    if (s2 && *s2)
	return (-1);
    return (0);
}

#if OPT_TEK4014
static void
withdraw_window(Display *dpy, Window w, int scr)
{
    TRACE(("withdraw_window %#lx\n", (long) w));
    (void) XmuUpdateMapHints(dpy, w, NULL);
    XWithdrawWindow(dpy, w, scr);
    return;
}
#endif

void
set_vt_visibility(Bool on)
{
    XtermWidget xw = term;
    TScreen *screen = TScreenOf(xw);

    TRACE(("set_vt_visibility(%d)\n", on));
    if (on) {
	if (!screen->Vshow && xw) {
	    VTInit(xw);
	    XtMapWidget(XtParent(xw));
#if OPT_TOOLBAR
	    /* we need both of these during initialization */
	    XtMapWidget(SHELL_OF(xw));
	    ShowToolbar(resource.toolBar);
#endif
	    screen->Vshow = True;
	}
    }
#if OPT_TEK4014
    else {
	if (screen->Vshow && xw) {
	    withdraw_window(XtDisplay(xw),
			    VShellWindow(xw),
			    XScreenNumberOfScreen(XtScreen(xw)));
	    screen->Vshow = False;
	}
    }
    set_vthide_sensitivity();
    set_tekhide_sensitivity();
    update_vttekmode();
    update_tekshow();
    update_vtshow();
#endif
    return;
}

#if OPT_TEK4014
void
set_tek_visibility(Bool on)
{
    TRACE(("set_tek_visibility(%d)\n", on));

    if (on) {
	if (!TEK4014_SHOWN(term)) {
	    if (tekWidget == 0) {
		TekInit();	/* will exit on failure */
	    }
	    if (tekWidget != 0) {
		Widget tekParent = SHELL_OF(tekWidget);
		XtRealizeWidget(tekParent);
		XtMapWidget(XtParent(tekWidget));
#if OPT_TOOLBAR
		/* we need both of these during initialization */
		XtMapWidget(tekParent);
		XtMapWidget(tekWidget);
#endif
		XtOverrideTranslations(tekParent,
				       XtParseTranslationTable
				       ("<Message>WM_PROTOCOLS: DeleteWindow()"));
		(void) XSetWMProtocols(XtDisplay(tekParent),
				       XtWindow(tekParent),
				       &wm_delete_window, 1);
		TEK4014_SHOWN(term) = True;
	    }
	}
    } else {
	if (TEK4014_SHOWN(term) && tekWidget) {
	    withdraw_window(XtDisplay(tekWidget),
			    TShellWindow,
			    XScreenNumberOfScreen(XtScreen(tekWidget)));
	    TEK4014_SHOWN(term) = False;
	}
    }
    set_tekhide_sensitivity();
    set_vthide_sensitivity();
    update_vtshow();
    update_tekshow();
    update_vttekmode();
    return;
}

void
end_tek_mode(void)
{
    XtermWidget xw = term;

    if (TEK4014_ACTIVE(xw)) {
	FlushLog(xw);
	longjmp(Tekend, 1);
    }
    return;
}

void
end_vt_mode(void)
{
    XtermWidget xw = term;

    if (!TEK4014_ACTIVE(xw)) {
	FlushLog(xw);
	TEK4014_ACTIVE(xw) = True;
	longjmp(VTend, 1);
    }
    return;
}

void
switch_modes(Bool tovt)		/* if true, then become vt mode */
{
    if (tovt) {
	if (tekRefreshList)
	    TekRefresh(tekWidget);
	end_tek_mode();		/* WARNING: this does a longjmp... */
    } else {
	end_vt_mode();		/* WARNING: this does a longjmp... */
    }
}

void
hide_vt_window(void)
{
    set_vt_visibility(False);
    if (!TEK4014_ACTIVE(term))
	switch_modes(False);	/* switch to tek mode */
}

void
hide_tek_window(void)
{
    set_tek_visibility(False);
    tekRefreshList = (TekLink *) 0;
    if (TEK4014_ACTIVE(term))
	switch_modes(True);	/* does longjmp to vt mode */
}
#endif /* OPT_TEK4014 */

static const char *
skip_punct(const char *s)
{
    while (*s == '-' || *s == '/' || *s == '+' || *s == '#' || *s == '%') {
	++s;
    }
    return s;
}

static int
cmp_options(const void *a, const void *b)
{
    const char *s1 = skip_punct(((const OptionHelp *) a)->opt);
    const char *s2 = skip_punct(((const OptionHelp *) b)->opt);
    return strcmp(s1, s2);
}

static int
cmp_resources(const void *a, const void *b)
{
    return strcmp(((const XrmOptionDescRec *) a)->option,
		  ((const XrmOptionDescRec *) b)->option);
}

XrmOptionDescRec *
sortedOptDescs(XrmOptionDescRec * descs, Cardinal res_count)
{
    static XrmOptionDescRec *res_array = 0;

#ifdef NO_LEAKS
    if (descs == 0) {
	if (res_array != 0) {
	    free(res_array);
	    res_array = 0;
	}
    } else
#endif
    if (res_array == 0) {
	Cardinal j;

	/* make a sorted index to 'resources' */
	res_array = TypeCallocN(XrmOptionDescRec, res_count);
	if (res_array != 0) {
	    for (j = 0; j < res_count; j++)
		res_array[j] = descs[j];
	    qsort(res_array, (size_t) res_count, sizeof(*res_array), cmp_resources);
	}
    }
    return res_array;
}

/*
 * The first time this is called, construct sorted index to the main program's
 * list of options, taking into account the on/off options which will be
 * compressed into one token.  It's a lot simpler to do it this way than
 * maintain the list in sorted form with lots of ifdef's.
 */
OptionHelp *
sortedOpts(OptionHelp * options, XrmOptionDescRec * descs, Cardinal numDescs)
{
    static OptionHelp *opt_array = 0;

#ifdef NO_LEAKS
    if (descs == 0 && opt_array != 0) {
	sortedOptDescs(descs, numDescs);
	free(opt_array);
	opt_array = 0;
	return 0;
    } else if (options == 0 || descs == 0) {
	return 0;
    }
#endif

    if (opt_array == 0) {
	size_t opt_count, j;
#if OPT_TRACE
	Cardinal k;
	XrmOptionDescRec *res_array = sortedOptDescs(descs, numDescs);
	int code;
	const char *mesg;
#else
	(void) descs;
	(void) numDescs;
#endif

	/* count 'options' and make a sorted index to it */
	for (opt_count = 0; options[opt_count].opt != 0; ++opt_count) {
	    ;
	}
	opt_array = TypeCallocN(OptionHelp, opt_count + 1);
	for (j = 0; j < opt_count; j++)
	    opt_array[j] = options[j];
	qsort(opt_array, opt_count, sizeof(OptionHelp), cmp_options);

	/* supply the "turn on/off" strings if needed */
#if OPT_TRACE
	for (j = 0; j < opt_count; j++) {
	    if (!strncmp(opt_array[j].opt, "-/+", (size_t) 3)) {
		char temp[80];
		const char *name = opt_array[j].opt + 3;
		for (k = 0; k < numDescs; ++k) {
		    const char *value = res_array[k].value;
		    if (res_array[k].option[0] == '-') {
			code = -1;
		    } else if (res_array[k].option[0] == '+') {
			code = 1;
		    } else {
			code = 0;
		    }
		    sprintf(temp, "%.*s",
			    (int) sizeof(temp) - 2,
			    opt_array[j].desc);
		    if (x_strindex(temp, "inhibit") != 0)
			code = -code;
		    if (code != 0
			&& res_array[k].value != 0
			&& !strcmp(name, res_array[k].option + 1)) {
			if (((code < 0) && !strcmp(value, "on"))
			    || ((code > 0) && !strcmp(value, "off"))
			    || ((code > 0) && !strcmp(value, "0"))) {
			    mesg = "turn on/off";
			} else {
			    mesg = "turn off/on";
			}
			if (strncmp(mesg, opt_array[j].desc, strlen(mesg))) {
			    if (strncmp(opt_array[j].desc, "turn ", (size_t) 5)) {
				char *s = CastMallocN(char,
						      strlen(mesg)
						      + 1
						      + strlen(opt_array[j].desc));
				if (s != 0) {
				    sprintf(s, "%s %s", mesg, opt_array[j].desc);
				    opt_array[j].desc = s;
				}
			    } else {
				TRACE(("OOPS "));
			    }
			}
			TRACE(("%s: %s %s: %s (%s)\n",
			       mesg,
			       res_array[k].option,
			       res_array[k].value,
			       opt_array[j].opt,
			       opt_array[j].desc));
			break;
		    }
		}
	    }
	}
#endif
    }
    return opt_array;
}

/*
 * Report the character-type locale that xterm was started in.
 */
String
xtermEnvLocale(void)
{
    static String result;

    if (result == 0) {
	if ((result = x_nonempty(setlocale(LC_CTYPE, 0))) == 0) {
	    result = x_strdup("C");
	} else {
	    result = x_strdup(result);
	}
	TRACE(("xtermEnvLocale ->%s\n", result));
    }
    return result;
}

char *
xtermEnvEncoding(void)
{
    static char *result;

    if (result == 0) {
#ifdef HAVE_LANGINFO_CODESET
	result = nl_langinfo(CODESET);
#else
	char *locale = xtermEnvLocale();
	if (!strcmp(locale, "C") || !strcmp(locale, "POSIX")) {
	    result = "ASCII";
	} else {
	    result = "ISO-8859-1";
	}
#endif
	TRACE(("xtermEnvEncoding ->%s\n", result));
    }
    return result;
}

#if OPT_WIDE_CHARS
/*
 * Tell whether xterm was started in a locale that uses UTF-8 encoding for
 * characters.  That environment is inherited by subprocesses and used in
 * various library calls.
 */
Bool
xtermEnvUTF8(void)
{
    static Bool init = False;
    static Bool result = False;

    if (!init) {
	init = True;
#ifdef HAVE_LANGINFO_CODESET
	result = (strcmp(xtermEnvEncoding(), "UTF-8") == 0);
#else
	{
	    char *locale = x_strdup(xtermEnvLocale());
	    int n;
	    for (n = 0; locale[n] != 0; ++n) {
		locale[n] = x_toupper(locale[n]);
	    }
	    if (strstr(locale, "UTF-8") != 0)
		result = True;
	    else if (strstr(locale, "UTF8") != 0)
		result = True;
	    free(locale);
	}
#endif
	TRACE(("xtermEnvUTF8 ->%s\n", BtoS(result)));
    }
    return result;
}
#endif /* OPT_WIDE_CHARS */

/*
 * Check if the current widget, or any parent, is the VT100 "xterm" widget.
 */
XtermWidget
getXtermWidget(Widget w)
{
    XtermWidget xw;

    if (w == 0) {
	xw = (XtermWidget) CURRENT_EMU();
	if (!IsXtermWidget(xw)) {
	    xw = 0;
	}
    } else if (IsXtermWidget(w)) {
	xw = (XtermWidget) w;
    } else {
	xw = getXtermWidget(XtParent(w));
    }
    TRACE2(("getXtermWidget %p -> %p\n", w, xw));
    return xw;
}

#if OPT_SESSION_MGT
static void
die_callback(Widget w GCC_UNUSED,
	     XtPointer client_data GCC_UNUSED,
	     XtPointer call_data GCC_UNUSED)
{
    NormalExit();
}

static void
save_callback(Widget w GCC_UNUSED,
	      XtPointer client_data GCC_UNUSED,
	      XtPointer call_data)
{
    XtCheckpointToken token = (XtCheckpointToken) call_data;
    /* we have nothing to save */
    token->save_success = True;
}

static void
icewatch(IceConn iceConn,
	 IcePointer clientData GCC_UNUSED,
	 Bool opening,
	 IcePointer * watchData GCC_UNUSED)
{
    if (opening) {
	ice_fd = IceConnectionNumber(iceConn);
	TRACE(("got IceConnectionNumber %d\n", ice_fd));
    } else {
	ice_fd = -1;
	TRACE(("reset IceConnectionNumber\n"));
    }
}

void
xtermOpenSession(void)
{
    if (resource.sessionMgt) {
	TRACE(("Enabling session-management callbacks\n"));
	XtAddCallback(toplevel, XtNdieCallback, die_callback, NULL);
	XtAddCallback(toplevel, XtNsaveCallback, save_callback, NULL);
    }
}

void
xtermCloseSession(void)
{
    IceRemoveConnectionWatch(icewatch, NULL);
}
#endif /* OPT_SESSION_MGT */

Widget
xtermOpenApplication(XtAppContext * app_context_return,
		     String my_class,
		     XrmOptionDescRec * options,
		     Cardinal num_options,
		     int *argc_in_out,
		     String *argv_in_out,
		     String *fallback_resources,
		     WidgetClass widget_class,
		     ArgList args,
		     Cardinal num_args)
{
    Widget result;

    XtSetErrorHandler(xt_error);
#if OPT_SESSION_MGT
    result = XtOpenApplication(app_context_return,
			       my_class,
			       options,
			       num_options,
			       argc_in_out,
			       argv_in_out,
			       fallback_resources,
			       widget_class,
			       args,
			       num_args);
    IceAddConnectionWatch(icewatch, NULL);
#else
    (void) widget_class;
    (void) args;
    (void) num_args;
    result = XtAppInitialize(app_context_return,
			     my_class,
			     options,
			     num_options,
			     argc_in_out,
			     argv_in_out,
			     fallback_resources,
			     NULL, 0);
#endif /* OPT_SESSION_MGT */
    init_colored_cursor(XtDisplay(result));

    XtSetErrorHandler((XtErrorHandler) 0);

    return result;
}

static int x11_errors;

static int
catch_x11_error(Display *display, XErrorEvent *error_event)
{
    (void) display;
    (void) error_event;
    ++x11_errors;
    return 0;
}

Boolean
xtermGetWinAttrs(Display *dpy, Window win, XWindowAttributes * attrs)
{
    Boolean result = False;
    Status code;

    memset(attrs, 0, sizeof(*attrs));
    if (win != None) {
	XErrorHandler save = XSetErrorHandler(catch_x11_error);
	x11_errors = 0;
	code = XGetWindowAttributes(dpy, win, attrs);
	XSetErrorHandler(save);
	result = (Boolean) ((code != 0) && !x11_errors);
	if (result) {
	    TRACE_WIN_ATTRS(attrs);
	} else {
	    xtermWarning("invalid window-id %ld\n", (long) win);
	}
    }
    return result;
}

Boolean
xtermGetWinProp(Display *display,
		Window win,
		Atom property,
		long long_offset,
		long long_length,
		Atom req_type,
		Atom *actual_type_return,
		int *actual_format_return,
		unsigned long *nitems_return,
		unsigned long *bytes_after_return,
		unsigned char **prop_return)
{
    Boolean result = True;

    if (win != None) {
	XErrorHandler save = XSetErrorHandler(catch_x11_error);
	x11_errors = 0;
	if (XGetWindowProperty(display,
			       win,
			       property,
			       long_offset,
			       long_length,
			       False,
			       req_type,
			       actual_type_return,
			       actual_format_return,
			       nitems_return,
			       bytes_after_return,
			       prop_return) == Success
	    && x11_errors == 0) {
	    result = True;
	}
	XSetErrorHandler(save);
    }
    return result;
}

void
xtermEmbedWindow(Window winToEmbedInto)
{
    Display *dpy = XtDisplay(toplevel);
    XWindowAttributes attrs;

    TRACE(("checking winToEmbedInto %#lx\n", winToEmbedInto));
    if (xtermGetWinAttrs(dpy, winToEmbedInto, &attrs)) {
	XtermWidget xw = term;
	TScreen *screen = TScreenOf(xw);

	XtRealizeWidget(toplevel);

	TRACE(("...reparenting toplevel %#lx into %#lx\n",
	       XtWindow(toplevel),
	       winToEmbedInto));
	XReparentWindow(dpy,
			XtWindow(toplevel),
			winToEmbedInto, 0, 0);

	screen->embed_high = (Dimension) attrs.height;
	screen->embed_wide = (Dimension) attrs.width;
    }
}

void
free_string(String value)
{
    free((void *) value);
}
@


1.35
log
@Update to xterm-325. Testing by krw@@, shadchin@@ and naddy@@. Thanks
@
text
@d1 1
a1 1
/* $XTermId: misc.c,v 1.741 2016/06/01 09:21:56 tom Exp $ */
d660 1
d2769 1
a2769 1
	    if ((next == buf) || (color < 0))
d3669 1
a3669 1
		if (next == 0)
d3679 1
a3679 1
		if (next == 0)
@


1.34
log
@Update to xterm 320. Tested by jsg@@ Thanks.
@
text
@d1 1
a1 1
/* $XTermId: misc.c,v 1.728 2015/08/19 00:54:21 tom Exp $ */
d4 1
a4 1
 * Copyright 1999-2014,2015 by Thomas E. Dickey
a140 1
    int n;
d143 7
a149 1
	buf = TypeRealloc(char, size, buf);
d419 1
a419 1
    XExposeEvent *p, *q;
d430 1
d496 1
a496 1
    XConfigureEvent *p, *q;
d508 1
d542 1
d545 1
d557 9
a726 2
    const char *tmp_dir;
    char *filename;
a727 2
    size_t needed;
    FILE *fp;
d740 4
d766 2
d891 19
d940 1
a940 11
    /*
     * Determine the current working directory of the child so that we can
     * spawn a new terminal in the same directory.
     *
     * If we cannot get the CWD of the child, just use our own.
     */
    if (screen->pid) {
	char child_cwd_link[sizeof(PROCFS_ROOT) + 80];
	sprintf(child_cwd_link, PROCFS_ROOT "/%lu/cwd", (unsigned long) screen->pid);
	child_cwd = Readlink(child_cwd_link);
    }
a1192 1
    long now_msecs;
d1204 2
a1443 1
    Char *copybuffer;
a1444 2
    size_t del_cnt;
    size_t buf_cnt;
d1504 3
a1506 2
	del_cnt = strlen(lastexpansion) - hint_len;
	buf_cnt = del_cnt + strlen(expansion) - hint_len;
d2027 2
a2028 2
	    char log_def_name[512];	/* see sprintf below */
	    char hostname[255 + 1];	/* Internet standard limit (RFC 1035):
d2034 2
a2035 1
	    char yyyy_mm_dd_hh_mm_ss[4 + 5 * (1 + 2) + 1];
d2041 5
a2045 6
	    if ((gethostname(hostname, sizeof(hostname)) == 0) &&
		(strftime(yyyy_mm_dd_hh_mm_ss,
			  sizeof(yyyy_mm_dd_hh_mm_ss),
			  "%Y.%m.%d.%H.%M.%S", ltm) > 0)) {
		(void) sprintf(log_def_name, "Xterm.log.%.255s.%.20s.%d",
			       hostname, yyyy_mm_dd_hh_mm_ss, (int) getpid());
d2047 1
a2047 1
	    if ((log_default = x_strdup(log_def_name)) == NULL)
d2049 1
d2052 1
a2052 1
	    if ((log_default = x_strdup(log_def_name)) == NULL)
d2054 1
a2054 1

a2279 1
    unsigned i;
d2286 1
d2288 2
a2318 4
    char *tried;
    double diff, thisRGB, bestRGB;
    unsigned attempts;
    unsigned bestInx;
a2320 1
    unsigned i;
d2327 1
a2328 1
	    tried = TypeCallocN(char, (size_t) cmap_size);
d2330 1
d2338 3
a2341 2
		    bestRGB = 0.0;
		    bestInx = 0;
d2344 2
d2356 1
a2356 1
			    thisRGB = diff * diff
a2475 1
    unsigned long diff;
d2480 2
a2541 1
	int state;
d2547 1
a2694 2
    char *name;
    int color;
d2702 3
a2704 1
	name = strchr(buf, ';');
d2767 1
a2767 1
	    color = (int) strtol(buf, &next, 10);
a2913 1
    char *used;
a2914 1
    String *select_args;
d2923 2
d2931 2
a3072 1
    int i;
d3074 2
a3226 1
    char *thisName;
a3227 1
    int i, ndx;
d3232 2
d3239 1
a3239 1
	    ndx = OscToColorIndex((OscTextColors) i);
d3246 2
a3247 4
		if (names[0] == ';')
		    thisName = NULL;
		else
		    thisName = names;
a3276 5
#if OPT_COLOR_RES
    const char *thisName;
    ScrnColors newColors;
    int ndx;
#endif
d3282 4
a3285 1
	ndx = OscToColorIndex((OscTextColors) (code - OSC_RESET));
a3360 1
	char temp[10];
d3386 2
d3766 9
a3774 7
	if (strcmp(buf, "?")
	    && (cp = CastMallocN(char, strlen(buf)) != NULL)) {
	    strcpy(cp, buf);
	    if (screen->logfile)
		free(screen->logfile);
	    screen->logfile = cp;
	    break;
a3820 1
    int c;
d3823 2
a3858 1
	int lo, hi;
d3866 1
d3868 2
d4097 2
d4282 1
a4282 1
		    parse_sixel(xw, &params, cp);
a4331 1
    int result = 0;
d4336 1
d4338 2
a4388 1
    int result = 0;
d4393 1
d4396 1
a4676 1
    size_t length;
d4695 2
d5012 1
a5012 1
    if (IsTitleMode(xw, tmSetBase16)) {
@


1.33
log
@xterm 314. tested by naddy@@
@
text
@d1 1
a1 1
/* $XTermId: misc.c,v 1.719 2014/12/28 22:17:58 tom Exp $ */
d4 1
a4 1
 * Copyright 1999-2013,2014 by Thomas E. Dickey
d704 1
a704 1
init_colored_cursor(void)
d707 2
a708 2
    const char *theme = "index.theme";
    const char *pattern = "xtermXXXXXXXX";
d716 9
d761 2
a928 1
	    unsigned n = 0;
d930 2
a931 1
	    myargv[n++] = child_exe;
d933 8
a940 2
	    while (n < myargc) {
		myargv[n++] = (char *) *params++;
a942 3
	    myargv[n] = 0;
	    execv(child_exe, myargv);

d2022 1
a2022 1
	    const char *log_def_name = "XtermLog.XXXXXX";
d3626 2
d4127 1
a4127 1
		if (screen->cursor_blink_esc == 0)
d4257 1
a4257 1
	    case '{':		/* DECDLD (no '}' case though) */
d4792 1
a4792 1
	data = (char **) myData->data,
d5114 1
a5114 1
    static char unknown[] = "unknown error";
d6028 2
@


1.32
log
@Update to xterm 313. Tested by shadchin@@
@
text
@d1 1
a1 1
/* $XTermId: misc.c,v 1.715 2014/10/29 00:54:25 tom Exp $ */
d2919 6
d2934 1
a2935 1
		free(select_args);
d3611 51
d3811 3
@


1.31
log
@Update to xterm 311. ok shadchin@@
@
text
@d1 1
a1 1
/* $XTermId: misc.c,v 1.714 2014/09/03 23:59:25 tom Exp $ */
a1020 7
    } else if ((event->type == FocusIn || event->type == FocusOut)
	       && event->detail == NotifyPointer) {
	/*
	 * NotifyPointer is sent to the window where the pointer is, and is
	 * in addition to events sent to the old/new focus-windows.
	 */
	/* EMPTY */ ;
d1022 3
a1024 1
	setXUrgency(xw, False);
@


1.30
log
@Update to xterm-309. Version 308 tested by several people including
naddy@@ who found a small regression, fixed in 309.
@
text
@d1 1
a1 1
/* $XTermId: misc.c,v 1.712 2014/05/26 14:45:58 tom Exp $ */
d3415 4
d3430 4
d3438 1
d3540 1
d6056 6
@


1.29
log
@Update to xterm 304. With help of shadchin@@

tested by ajacoutot@@ and shadchin@@
@
text
@d1 1
a1 1
/* $XTermId: misc.c,v 1.711 2014/04/25 23:27:45 tom Exp $ */
d243 1
a243 1
DoSpecialEnterNotify(XtermWidget xw, XEnterWindowEvent * ev)
d256 1
a256 1
DoSpecialLeaveNotify(XtermWidget xw, XEnterWindowEvent * ev)
d385 1
a385 1
TraceExposeEvent(XEvent * arg)
d411 1
a411 1
mergeExposeEvents(XEvent * target)
d458 1
a458 1
TraceConfigureEvent(XEvent * arg)
d487 1
a487 1
mergeConfigureEvents(XEvent * target)
d796 1
a796 1
		 XEvent * event,
d807 1
a807 1
			 XEvent * event,
d818 1
a818 1
		  XEvent * event GCC_UNUSED,
d863 1
a863 1
		    XEvent * event GCC_UNUSED,
d957 1
a957 1
		XEvent * event GCC_UNUSED,
d981 1
a981 1
		  XEvent * event GCC_UNUSED,
d993 1
a993 1
		  XEvent * event GCC_UNUSED,
d1005 1
a1005 1
		  XEvent * ev,
d1256 1
a1256 1
			 XEvent * ev,
d1497 1
a1497 1
		    XEvent * event GCC_UNUSED,
d1515 1
a1515 1
		XEvent * event GCC_UNUSED,
d1530 1
a1530 1
	      XEvent * event GCC_UNUSED,
d1697 1
a1697 1
	       XEvent * event GCC_UNUSED,
d1711 1
a1711 1
		  XEvent * event GCC_UNUSED,
d1742 1
a1742 1
						       (XEvent *) & event,
d1746 1
a1746 1
		(screen->scrollWidget, (XEvent *) & event, NULL);
d1755 1
a1755 1
	TekExpose((Widget) tekWidget, (XEvent *) & event, NULL);
d2275 1
a2275 1
allocateClosestRGB(XtermWidget xw, Colormap cmap, XColor * def)
d2385 1
a2385 1
simpleColors(XColor * colortable, unsigned length)
d2431 1
a2431 1
searchColors(XColor * colortable, unsigned mask, unsigned length, unsigned
d2488 1
a2488 1
allocateExactRGB(XtermWidget xw, Colormap cmap, XColor * def)
d2758 1
a2758 1
allocateBestRGB(XtermWidget xw, XColor * def)
d2766 1
a2766 1
xtermAllocColor(XtermWidget xw, XColor * def, const char *spec)
d2961 1
a2961 1
	if (decodeUtf8(fakePtyData(&data, cp, last))) {
d5397 1
a5397 1
xerror(Display *d, XErrorEvent * ev)
d5955 1
a5955 1
catch_x11_error(Display *display, XErrorEvent * error_event)
d5992 1
a5992 1
		Atom * actual_type_return,
@


1.28
log
@Update to xterm 301
@
text
@d1 1
a1 1
/* $XTermId: misc.c,v 1.686 2014/01/19 16:12:25 Egmont.Koblinger Exp $ */
d98 2
a1334 1
#define MAXWLEN 1024		/* maximum word length as in tcsh */
d1361 1
a1361 1
dabbrev_prev_word(TScreen *screen, CELL *cell, LineData **ld)
d1363 1
a1363 2
    static char ab[MAXWLEN];

d1366 1
a1366 1
    char *ab_end = (ab + MAXWLEN - 1);
d1374 1
a1374 1
	if (abword > ab)	/* store only |MAXWLEN| last chars */
d1395 1
a1395 1
dabbrev_expand(TScreen *screen)
d1397 1
d1420 1
a1420 1
	if ((dabbrev_hint = dabbrev_prev_word(screen, &cell, &ld)) != 0) {
d1452 1
a1452 1
	if ((expansion = dabbrev_prev_word(screen, &cell, &ld)) == 0) {
d1505 1
a1505 2
	TScreen *screen = TScreenOf(xw);
	if (!dabbrev_expand(screen))
d2156 40
d2221 1
a2221 1
getColormapInfo(Display *display, unsigned *typep, unsigned *sizep)
d2223 7
a2229 14
    int numFound;
    XVisualInfo myTemplate, *visInfoPtr;

    myTemplate.visualid = XVisualIDFromVisual(DefaultVisual(display,
							    XDefaultScreen(display)));
    visInfoPtr = XGetVisualInfo(display, (long) VisualIDMask,
				&myTemplate, &numFound);
    *typep = (numFound >= 1) ? (unsigned) visInfoPtr->class : 0;
    *sizep = (numFound >= 1) ? (unsigned) visInfoPtr->colormap_size : 0;

    XFree((char *) visInfoPtr);

    TRACE(("getColormapInfo type %d (%s), size %d\n",
	   *typep, ((*typep & 1) ? "dynamic" : "static"), *sizep));
d2243 1
a2243 1
    Boolean result = False;
d2245 1
a2245 1
    if (screen->cmap_data == 0
a2271 7
 * These provide some introduction:
 *	http://en.wikipedia.org/wiki/YIQ
 *		for an introduction to YIQ weights.
 *	http://en.wikipedia.org/wiki/Luminance_(video)
 *		for a discussion of luma.
 *	http://en.wikipedia.org/wiki/YUV
 *
d2287 1
a2287 1
    getColormapInfo(screen->display, &cmap_type, &cmap_size);
d2388 1
a2388 1
    int state = -1;
a2391 5
	if (state == -1) {
	    CheckColor(state, colortable[n]);
	    if (state == 0)
		state = -1;
	}
d2398 2
d2414 16
d2431 2
a2432 1
searchColors(XColor * colortable, unsigned length, unsigned color, int state)
d2440 1
d2443 1
a2443 1
	diff = (color - value);
d2477 1
a2477 1
 * case, allocateClosesRGB() is useful for the dynamic display classes such as
d2495 3
a2497 3
     * If this is a statically allocated display, e.g., TrueColor, see if we
     * can improve on the result by using the color values actually supported
     * by the server.
d2504 1
a2504 1
	getColormapInfo(screen->display, &cmap_type, &cmap_size);
d2506 1
a2506 1
	if ((cmap_type & 1) == 0) {
d2511 6
a2516 1
#define SearchColors(which) temp.which = (unsigned short) searchColors(screen->cmap_data, cmap_size, save.which, state)
d2772 21
a2792 5
    if (XParseColor(screen->display, cmap, spec, def)
	&& allocateBestRGB(xw, def)) {
	TRACE(("xtermAllocColor -> %x/%x/%x\n",
	       def->red, def->green, def->blue));
	result = True;
a3021 2
static ScrnColors *pOldColors = NULL;

d3026 3
a3028 3
    if (pOldColors == NULL) {
	pOldColors = TypeXtMalloc(ScrnColors);
	if (pOldColors == NULL) {
d3032 1
a3032 1
	pOldColors->which = 0;
d3034 2
a3035 2
	    pOldColors->colors[i] = 0;
	    pOldColors->names[i] = NULL;
d3037 1
a3037 1
	GetColors(xw, pOldColors);
d3096 1
a3096 1
	color.pixel = pOldColors->colors[ndx];
d3103 1
a3103 1
	       ndx, pOldColors->colors[ndx], buffer));
d3125 3
a3127 3
	    if (pOldColors->names[i] != NULL) {
		XtFree(pOldColors->names[i]);
		pOldColors->names[i] = NULL;
d3130 1
a3130 1
		pOldColors->names[i] = pNew->names[i];
d3132 1
a3132 1
	    pOldColors->colors[i] = pNew->colors[i];
d3205 7
a3211 6
		if (thisName != 0 && !strcmp(thisName, "?")) {
		    ReportColorRequest(xw, ndx, final);
		} else if (!pOldColors->names[ndx]
			   || (thisName
			       && strcmp(thisName, pOldColors->names[ndx]))) {
		    AllocateTermColor(xw, &newColors, ndx, thisName, False);
d3230 1
d3234 1
d3250 2
a3251 2
	    && pOldColors->names[ndx] != 0
	    && strcmp(thisName, pOldColors->names[ndx])) {
a3699 10
#ifdef SunXK_F36
#define MAX_UDK 37
#else
#define MAX_UDK 35
#endif
static struct {
    char *str;
    int len;
} user_keys[MAX_UDK];

d3725 1
a3725 1
reset_decudk(void)
d3729 4
a3732 4
	if (user_keys[n].str != 0) {
	    free(user_keys[n].str);
	    user_keys[n].str = 0;
	    user_keys[n].len = 0;
d3741 1
a3741 1
parse_decudk(const char *cp)
d3761 4
a3764 4
	    if (user_keys[key].str != 0)
		free(user_keys[key].str);
	    user_keys[key].str = str;
	    user_keys[key].len = len;
a4141 1
#if OPT_SIXEL_GRAPHICS
d4143 1
d4151 3
d4156 1
d4161 2
a4162 1
		    screen->terminal_id == 340) {
d4165 3
a4168 1
#endif
d4170 5
a4174 3
		if (params.a_param[0] == 0)
		    reset_decudk();
		parse_decudk(cp);
d4177 3
a4179 1
		parse_decdld(&params, cp);
d4501 13
d4528 1
a4528 1
udk_lookup(int keycode, int *len)
d4531 2
a4532 2
	*len = user_keys[keycode].len;
	return user_keys[keycode].str;
a4645 3
    Display *display = TScreenOf(xw)->display;
    XVisualInfo myTemplate, *visInfoPtr;
    int numFound;
d4648 2
a4649 9
    myTemplate.visualid = XVisualIDFromVisual(DefaultVisual(display,
							    XDefaultScreen(display)));
    visInfoPtr = XGetVisualInfo(display, (long) VisualIDMask,
				&myTemplate, &numFound);
    if (visInfoPtr != 0) {
	if (numFound != 0) {
	    result = visInfoPtr->depth;
	}
	XFree(visInfoPtr);
d4666 1
a4666 8
#if OPT_BUILTIN_XPMS
#include <icons/mini.xterm.xpms>
#include <icons/filled-xterm.xpms>
#include <icons/xterm.xpms>
#include <icons/xterm-color.xpms>
#else
#include <icons/mini.xterm_48x48.xpm>
#endif
d4946 1
a4946 1
ReverseOldColors(void)
d4948 1
a4948 1
    ScrnColors *pOld = pOldColors;
d4957 1
a4957 1
		XtFree(pOldColors->names[TEXT_CURSOR]);
d5160 21
d5226 1
a5226 3
			    if (*tmp == '/'
				&& strstr(tmp, "..") == 0
				&& access(tmp, X_OK) == 0) {
d5243 1
a5243 3
    if (*result != '/'
	|| strstr(result, "..") != 0
	|| access(result, X_OK) != 0) {
d5935 3
@


1.27
log
@Don't play with libxcursor if XCURSOR_THEM is defined.
@
text
@d1 1
a1 1
/* $XTermId: misc.c,v 1.682 2013/12/03 23:24:48 tom Exp $ */
d4 1
a4 1
 * Copyright 1999-2012,2013 by Thomas E. Dickey
d709 1
a712 3
    if (getenv("XCURSOR_THEME") != NULL)
        return;

d714 7
a720 5
    if ((tmp_dir = getenv("TMPDIR")) == 0)
	tmp_dir = P_tmpdir;
    needed = strlen(tmp_dir) + 4 + strlen(theme) + strlen(pattern);
    if ((filename = malloc(needed)) != 0) {
	sprintf(filename, "%s/%s", tmp_dir, pattern);
d723 1
a723 1
	xterm_cursor_theme = mkdtemp(filename);
d725 4
a728 4
	if (mktemp(filename) != 0
	    && mkdir(filename, 0700) == 0) {
	    xterm_cursor_theme = filename;
	}
d730 17
a746 15
	/*
	 * Actually, Xcursor does what _we_ want just by steering its search
	 * path away from home.  We are setting up the complete theme just in
	 * case the library ever acquires a maintainer.
	 */
	if (xterm_cursor_theme != 0) {
	    char *leaf = xterm_cursor_theme + strlen(xterm_cursor_theme);
	    strcat(leaf, "/");
	    strcat(leaf, theme);
	    if ((fp = fopen(xterm_cursor_theme, "w")) != 0) {
		fprintf(fp, "[Icon Theme]\n");
		fclose(fp);
		*leaf = '\0';
		xtermSetenv("XCURSOR_PATH", xterm_cursor_theme);
		*leaf = '/';
a747 1
	    atexit(cleanup_colored_cursor);
d1270 1
d1287 1
d3387 1
d3471 3
d3506 2
a3507 2
    } else if (!need_data) {
	TRACE(("do_osc found found unwanted data\n"));
@


1.26
log
@Update to xterm-300. Tested  by ajacoutot@@ and shadchin@@.
@
text
@d712 3
@


1.25
log
@Update to xterm 296. Sixel graphics disabled for now.
@
text
@d1 1
a1 1
/* $XTermId: misc.c,v 1.670 2013/06/23 22:11:54 tom Exp $ */
d695 76
d791 1
a791 1
		 String * params GCC_UNUSED,
d802 1
a802 1
			 String * params GCC_UNUSED,
d813 1
a813 1
		  String * params,
d832 1
a832 1
	    else if ((xxxxxx = strchr(abcdef, c)) != 0)
d858 1
a858 1
		    String * params,
d952 1
a952 1
		String * params,
d976 1
a976 1
		  Boolean * cont GCC_UNUSED)
d988 1
a988 1
		  Boolean * cont GCC_UNUSED)
d1000 1
a1000 1
		  Boolean * cont GCC_UNUSED)
d1200 1
a1200 1
flashWindow(TScreen * screen, Window window, GC visualGC, unsigned width, unsigned height)
d1251 1
a1251 1
			 Boolean * more GCC_UNUSED)
d1330 1
a1330 1
dabbrev_prev_char(TScreen * screen, CELL * cell, LineData ** ld)
d1354 1
a1354 1
dabbrev_prev_word(TScreen * screen, CELL * cell, LineData ** ld)
d1389 1
a1389 1
dabbrev_expand(TScreen * screen)
d1491 1
a1491 1
		    String * params GCC_UNUSED,
d1510 1
a1510 1
		String * params GCC_UNUSED,
d1525 1
a1525 1
	      String * params GCC_UNUSED,
d1692 1
a1692 1
	       String * params GCC_UNUSED,
d1706 1
a1706 1
		  String * params GCC_UNUSED,
d1927 1
a1927 1
xtermResetIds(TScreen * screen)
d2175 1
a2175 1
getColormapInfo(Display * display, unsigned *typep, unsigned *sizep)
d2785 1
a2785 1
ManipulateSelectionData(XtermWidget xw, TScreen * screen, char *buf, int final)
d2853 1
a2853 1
					  (Time) 0,
d2879 1
a2879 1
xtermIsPrintable(XtermWidget xw, Char ** bufp, Char * last)
d3204 1
a3204 1
ParseShiftedFont(XtermWidget xw, String source, String * target)
d3369 1
a3369 1
do_osc(XtermWidget xw, Char * oscbuf, size_t len, int final)
d3717 1
a3717 1
parse_ansi_params(ANSI * params, const char **string)
d3760 1
a3760 1
parse_decdld(ANSI * params, const char *string)
d3870 1
a3870 1
do_dcs(XtermWidget xw, Char * dcsbuf, size_t dcslen)
d5310 1
a5310 1
xerror(Display * d, XErrorEvent * ev)
d5331 1
a5331 1
xioerror(Display * dpy)
d5371 1
a5371 1
withdraw_window(Display * dpy, Window w, int scr)
d5728 12
a5739 1
	result = (strstr(xtermEnvLocale(), "UTF-8") != NULL);
d5826 2
a5827 2
		     String * argv_in_out,
		     String * fallback_resources,
d5865 1
a5865 1
catch_x11_error(Display * display, XErrorEvent * error_event)
d5874 1
a5874 1
xtermGetWinAttrs(Display * dpy, Window win, XWindowAttributes * attrs)
d5896 1
a5896 1
xtermGetWinProp(Display * display,
@


1.24
log
@Update to xterm 293. Tested by naddy@@ ajacoutot@@
@
text
@d1 1
a1 1
/* $XTermId: misc.c,v 1.660 2013/05/26 21:16:20 tom Exp $ */
a93 1
#include <xcharmouse.h>
d97 1
d537 1
d540 1
d2629 8
d2645 1
a2645 2
	&& (allocateExactRGB(xw, cmap, def)
	    || allocateClosestRGB(xw, cmap, def))) {
d3636 43
a3792 34
/*
 * Parse numeric parameters.  Normally we use a state machine to simplify
 * interspersing with control characters, but have the string already.
 */
static void
parse_ansi_params(ANSI * params, const char **string)
{
    const char *cp = *string;
    ParmType nparam = 0;

    memset(params, 0, sizeof(*params));
    while (*cp != '\0') {
	Char ch = CharOf(*cp++);

	if (isdigit(ch)) {
	    if (nparam < NPARAM) {
		params->a_param[nparam] =
		    (ParmType) ((params->a_param[nparam] * 10)
				+ (ch - '0'));
	    }
	} else if (ch == ';') {
	    if (++nparam < NPARAM)
		params->a_nparam = nparam;
	} else if (ch < 32) {
	    /* EMPTY */ ;
	} else {
	    /* should be 0x30 to 0x7e */
	    params->a_final = ch;
	    break;
	}
    }
    *string = cp;
}

d3999 2
a4000 1
	if (screen->vtXX_level >= 2) {	/* VT220 */
d4003 20
d4127 1
a4127 1
	case 1:		/* DECCKM                       */
d4130 1
a4130 1
	case 2:		/* DECANM - ANSI/VT52 mode      */
d4137 1
a4137 1
	case 3:		/* DECCOLM                      */
d4140 1
a4140 1
	case 4:		/* DECSCLM (slow scroll)        */
d4143 1
a4143 1
	case 5:		/* DECSCNM                      */
d4146 1
a4146 1
	case 6:		/* DECOM                        */
d4149 1
a4149 1
	case 7:		/* DECAWM                       */
d4152 1
a4152 1
	case 8:		/* DECARM                       */
d4155 1
a4155 1
	case SET_X10_MOUSE:	/* X10 mouse                    */
d4159 1
a4159 1
	case 10:		/* rxvt */
d4164 1
a4164 1
	case 12:		/* att610: Start/stop blinking cursor */
d4168 1
a4168 1
	case 18:		/* DECPFF: print form feed */
d4171 1
a4171 1
	case 19:		/* DECPEX: print extent */
d4174 1
a4174 1
	case 25:		/* DECTCEM: Show/hide cursor (VT200) */
d4177 1
a4177 1
	case 30:		/* rxvt */
d4181 1
a4181 1
	case 35:		/* rxvt */
d4186 1
a4186 1
	case 38:		/* DECTEK                       */
d4190 1
a4190 1
	case 40:		/* 132 column mode              */
d4193 1
a4193 1
	case 41:		/* curses hack                  */
d4196 1
a4196 1
	case 42:		/* DECNRCM national charset (VT220) */
d4199 1
a4199 1
	case 44:		/* margin bell                  */
d4202 1
a4202 1
	case 45:		/* reverse wraparound   */
d4206 1
a4206 1
	case 46:		/* logging              */
d4212 1
a4212 1
	case 1049:		/* alternate buffer & cursor */
d4214 1
a4214 1
	case 1047:
d4216 1
a4216 1
	case 47:		/* alternate buffer */
d4219 1
a4219 1
	case 66:		/* DECNKM */
d4222 1
a4222 1
	case 67:		/* DECBKM */
d4225 1
a4225 1
	case 69:		/* DECLRMM */
d4228 6
a4233 1
	case 95:		/* DECNCSM */
d4236 1
a4236 1
	case SET_VT200_MOUSE:	/* xterm bogus sequence         */
d4239 1
a4239 1
	case SET_VT200_HIGHLIGHT_MOUSE:	/* xterm sequence w/hilite tracking */
d4242 1
a4242 1
	case SET_BTN_EVENT_MOUSE:
d4245 1
a4245 1
	case SET_ANY_EVENT_MOUSE:
d4249 1
a4249 1
	case SET_FOCUS_EVENT_MOUSE:
d4253 1
a4253 1
	case SET_EXT_MODE_MOUSE:
d4255 1
a4255 1
	case SET_SGR_EXT_MODE_MOUSE:
d4257 1
a4257 1
	case SET_URXVT_EXT_MODE_MOUSE:
d4260 1
a4260 1
	case SET_ALTERNATE_SCROLL:
d4263 1
a4263 1
	case 1010:		/* rxvt */
d4266 1
a4266 1
	case 1011:		/* rxvt */
d4269 1
a4269 1
	case 1034:
d4273 1
a4273 1
	case 1035:
d4276 1
a4276 1
	case 1036:
d4280 1
a4280 1
	case 1037:
d4284 1
a4284 1
	case 1039:
d4288 1
a4288 1
	case 1040:
d4291 1
a4291 1
	case 1041:
d4294 1
a4294 1
	case 1042:
d4297 1
a4297 1
	case 1043:
d4300 1
a4300 1
	case 1048:
d4304 1
a4304 1
	case 1050:
d4309 1
a4309 1
	case 1051:
d4314 1
a4314 1
	case 1052:
d4319 1
a4319 1
	case 1053:
d4323 1
a4323 1
	case 1060:
d4327 1
a4327 1
	case 1061:
d4332 1
a4332 1
	case SET_BUTTON1_MOVE_POINT:
d4335 1
a4335 1
	case SET_BUTTON2_MOVE_POINT:
d4338 1
a4338 1
	case SET_DBUTTON3_DELETE:
d4341 1
a4341 1
	case SET_PASTE_IN_BRACKET:
d4344 1
a4344 1
	case SET_PASTE_QUOTE:
d4347 1
a4347 1
	case SET_PASTE_LITERAL_NL:
@


1.23
log
@Update to xterm 291. Tested by many.
@
text
@d1 1
a1 1
/* $XTermId: misc.c,v 1.658 2013/02/03 23:18:38 tom Exp $ */
d1877 1
d4835 1
a4835 2
#ifdef DEBUG
    if (debug) {
d4837 1
a4837 2
    }
#endif /* DEBUG */
@


1.22
log
@Update to xterm 287. tested by mpi@@ and krw@@.
@
text
@d1 1
a1 1
/* $XTermId: misc.c,v 1.631 2012/11/25 16:05:51 tom Exp $ */
d4 1
a4 1
 * Copyright 1999-2011,2012 by Thomas E. Dickey
d129 2
d556 1
a556 1
	Cleanup(0);
a848 6
    } else {
	/* We are the parent; clean up */
	if (child_cwd)
	    free(child_cwd);
	if (child_exe)
	    free(child_exe);
d850 5
d1567 1
d1769 1
a1769 1
    SIGNAL_T(*chldfunc) (int);
d1835 1
a1835 1
		Cleanup(0);
d1871 1
a1871 1
static SIGNAL_T
d1950 26
a1975 1
	if (pipe(p) < 0 || (pid = fork()) < 0)
d1977 1
a1993 15
	    if ((shell = x_getenv("SHELL")) == NULL) {

		if (x_getpwuid(screen->uid, &pw)) {
		    x_getlogin(screen->uid, &pw);
		    if (*(pw.pw_shell)) {
			shell = pw.pw_shell;
		    }
		}
	    }

	    if (shell == 0) {
		static char dummy[] = "/bin/sh";
		shell = dummy;
	    }

d2001 6
a2006 3
	    execl(shell, shell, "-c", &screen->logfile[1], (void *) 0);

	    xtermWarning("Can't exec `%s'\n", &screen->logfile[1]);
d2720 1
a2720 1
    char *used = x_strdup(base);
d2722 1
a2722 1
    String *select_args = 0;
d2735 13
a2747 9
	if ((select_args = TypeCallocN(String, 1 + strlen(base))) == 0)
	    return;
	while (*base != '\0') {
	    for (j = 0; j < XtNumber(table); ++j) {
		if (*base == table[j].given) {
		    used[n] = *base;
		    select_args[n++] = table[j].result;
		    TRACE(("atom[%d] %s\n", n, table[j].result));
		    break;
d2749 1
a2749 4
	    }
	    ++base;
	}
	used[n] = 0;
d2751 30
a2780 24
	if (!strcmp(buf, "?")) {
	    if (AllowWindowOps(xw, ewGetSelection)) {
		TRACE(("Getting selection\n"));
		unparseputc1(xw, ANSI_OSC);
		unparseputs(xw, "52");
		unparseputc(xw, ';');

		unparseputs(xw, used);
		unparseputc(xw, ';');

		/* Tell xtermGetSelection data is base64 encoded */
		screen->base64_paste = n;
		screen->base64_final = final;

		/* terminator will be written in this call */
		xtermGetSelection((Widget) xw, (Time) 0, select_args, n, NULL);
	    }
	} else {
	    if (AllowWindowOps(xw, ewSetSelection)) {
		TRACE(("Setting selection with %s\n", buf));
		ClearSelectionBuffer(screen);
		while (*buf != '\0')
		    AppendToSelectionBuffer(screen, CharOf(*buf++));
		CompleteSelection(xw, select_args, n);
d2782 1
d3596 1
a3596 1
	char *str = CastMallocN(char, strlen(cp) + 1);
d3611 1
d3651 1
a3651 1
		     ? ((Pcmw >= 2 || Pcmw <= 4)
d3897 1
a3897 1
		unparseputc(xw, okay ? '1' : '0');
a4565 1
    static char empty[1];
d4582 1
a4582 1
	value = empty;
d4588 2
a4589 1
	if (*temp != '\0')
d4591 1
d4697 5
a4702 6
	free(my_attr);

	if (IsTitleMode(xw, tmSetBase16))
	    free(value);

    }
d4710 1
a4710 2
	static char dummy[] = "";
	name = dummy;
a4921 3
/*
 * cleanup by sending SIGHUP to client processes
 */
d4923 1
a4923 1
Cleanup(int code)
a4925 1
    TScreen *screen = TScreenOf(term);
d4930 4
a4933 5
    if (code == 0) {
	if (cleaning) {
	    hold_screen = 0;
	    return;
	}
d4935 2
a4936 2
	cleaning = True;
	need_cleanup = False;
d4938 5
a4942 8
	TRACE(("Cleanup %d\n", code));

	if (hold_screen) {
	    hold_screen = 2;
	    while (hold_screen) {
		xevents();
		Sleep(10);
	    }
d4944 1
d4946 5
a4950 5
	if (resource.sessionMgt) {
	    XtVaSetValues(toplevel,
			  XtNjoinSession, False,
			  (void *) 0);
	}
d4952 12
a4963 1
    }
d4978 1
d4983 1
d4996 1
d5003 1
a5003 1
	if ((s = x_getenv("PATH")) != 0) {
d5021 1
a5024 2
			if (found)
			    break;
d5031 1
d5040 2
d5044 3
d5507 3
a5509 1
		    strcpy(temp, opt_array[j].desc);
a5617 39
 * Returns the version-string used in the "-v' message as well as a few other
 * places.  It is derived (when possible) from the __vendorversion__ symbol
 * that some newer imake configurations define.
 */
char *
xtermVersion(void)
{
    static char vendor_version[] = __vendorversion__;
    static char *result;

    if (result == 0) {
	char *vendor = vendor_version;
	char first[BUFSIZ];
	char second[BUFSIZ];

	result = CastMallocN(char, strlen(vendor) + 9);
	if (result == 0)
	    result = vendor;
	else {
	    /* some vendors leave trash in this string */
	    for (;;) {
		if (!strncmp(vendor, "Version ", (size_t) 8))
		    vendor += 8;
		else if (isspace(CharOf(*vendor)))
		    ++vendor;
		else
		    break;
	    }
	    if (strlen(vendor) < BUFSIZ &&
		sscanf(vendor, "%[0-9.] %[A-Za-z_0-9.]", first, second) == 2)
		sprintf(result, "%s %s(%d)", second, first, XTERM_PATCH);
	    else
		sprintf(result, "%s(%d)", vendor, XTERM_PATCH);
	}
    }
    return result;
}

/*
d5645 1
a5645 1
    Cleanup(0);
@


1.21
log
@Update to xterm 279. Tested by krw@@, mpi@@, shadchin@@.
@
text
@d1 1
a1 1
/* $XTermId: misc.c,v 1.588 2012/05/07 23:35:34 tom Exp $ */
d80 4
d187 1
a187 1
	if (input->xic)
d207 1
a207 1
    if (screen->hide_pointer) {
d225 1
a225 1
	    if (input->xic)
d347 1
d622 22
a643 14
	    switch (event.xany.type) {
	    case KeyPress:
	    case KeyRelease:
	    case ButtonPress:
	    case ButtonRelease:
		/* also these... */
	    case Expose:
	    case NoExpose:
	    case PropertyNotify:
	    case ClientMessage:
		break;
	    default:
		xtermShowPointer(xw, True);
		break;
d837 1
a837 1
		myargv[n++] = *params++;
d927 1
a927 1
    TRACE(("HandleFocusChange type=%s, mode=%d, detail=%d\n",
d929 2
a930 2
	   event->mode,
	   event->detail));
d936 7
d1184 1
d1193 1
d1199 1
d1210 1
d1470 1
d1507 5
a1511 1
	return 1;
d1513 1
a1513 1
    return 0;
d1522 1
d1524 5
a1528 1
    TRACE(("RequestMaximize %s\n", maximize ? "maximize" : "restore"));
d1530 12
a1541 3
    if (maximize) {

	if (QueryMaximize(xw, &root_width, &root_height)) {
d1543 9
a1551 42
	    if (XGetWindowAttributes(screen->display,
				     WMFrameWindow(xw),
				     &wm_attrs)) {

		if (XGetWindowAttributes(screen->display,
					 VShellWindow(xw),
					 &vshell_attrs)) {

		    if (screen->restore_data != True
			|| screen->restore_width != root_width
			|| screen->restore_height != root_height) {
			screen->restore_data = True;
			screen->restore_x = wm_attrs.x + wm_attrs.border_width;
			screen->restore_y = wm_attrs.y + wm_attrs.border_width;
			screen->restore_width = (unsigned) vshell_attrs.width;
			screen->restore_height = (unsigned) vshell_attrs.height;
			TRACE(("HandleMaximize: save window position %d,%d size %d,%d\n",
			       screen->restore_x,
			       screen->restore_y,
			       screen->restore_width,
			       screen->restore_height));
		    }

		    /* subtract wm decoration dimensions */
		    root_width -=
			(unsigned) ((wm_attrs.width - vshell_attrs.width)
				    + (wm_attrs.border_width * 2));
		    root_height -=
			(unsigned) ((wm_attrs.height - vshell_attrs.height)
				    + (wm_attrs.border_width * 2));

		    XMoveResizeWindow(screen->display, VShellWindow(xw),
				      0 + wm_attrs.border_width,	/* x */
				      0 + wm_attrs.border_width,	/* y */
				      root_width,
				      root_height);
		}
	    }
	}
    } else {
	if (screen->restore_data) {
	    TRACE(("HandleRestoreSize: position %d,%d size %d,%d\n",
d1556 28
a1583 1
	    screen->restore_data = False;
d1585 19
a1603 6
	    XMoveResizeWindow(screen->display,
			      VShellWindow(xw),
			      screen->restore_x,
			      screen->restore_y,
			      screen->restore_width,
			      screen->restore_height);
d2422 9
a2430 2
	    TRACE(("AllocateAnsiColor[%d] %s (pixel 0x%06lx)\n",
		   (int) (res - TScreenOf(xw)->Acolors), spec, def.pixel));
d2627 54
d3326 21
d3415 1
a3415 1
	    xtermRepaint(xw);
d3422 1
a3422 1
	    xtermRepaint(xw);
d3793 1
a3793 1
		if (screen->terminal_id >= 400) {	/* VT420 */
d3857 5
a3861 3
		int code = 0;
		if (screen->cursor_underline != 0)
		    code |= 2;
d3864 1
a3864 1
		    code |= 1;
d3866 1
a3866 1
		sprintf(reply, "%d%s", code + 1, cp);
d3955 1
a3955 1
	if (screen->terminal_id >= 200) {	/* VT220 */
d4067 1
a4067 1
	    result = MdBool(screen->terminal_id >= 100);
d4190 3
d4304 231
a4870 1
	{ ERROR_MMALLOC,	"my_memmove: malloc/realloc failed" },
d5744 2
a5745 2
static Boolean
validWindow(Display * dpy, Window win, XWindowAttributes * attrs)
d5750 1
d5766 38
d5811 1
a5811 1
    if (validWindow(dpy, winToEmbedInto, &attrs)) {
@


1.20
log
@Update to xterm 278. Tested by mpi@@, shadchin@@
@
text
@d1 1
a1 1
/* $XTermId: misc.c,v 1.576 2012/01/07 01:57:52 tom Exp $ */
d4 1
a4 1
 * Copyright 1999-2010,2011 by Thomas E. Dickey
d2179 63
a2241 2
static unsigned short
searchColortable(XColor * colortable, unsigned length, unsigned color)
d2247 1
d2250 2
a2251 1
	diff = (color - colortable[n].blue);
d2266 2
a2267 1
    return colortable[result].blue;
d2310 1
d2317 6
a2322 8
	    if (loadColorTable(xw, cmap_size)) {
		/*
		 * Note: the query will return only a value in the ".blue"
		 * member, leaving ".red" and ".green" as zeros.
		 */
		temp.red = searchColortable(screen->cmap_data, cmap_size, save.red);
		temp.green = searchColortable(screen->cmap_data, cmap_size, save.green);
		temp.blue = searchColortable(screen->cmap_data, cmap_size, save.blue);
d2331 3
d3644 4
d3660 6
d3726 1
a3726 1
		if (screen->cursor_underline)
d3729 1
a3729 1
		if (screen->cursor_blink)
d3849 1
a3849 1
#define MdFlag(mode,flag) MdBool(xw->keyboard.flags & MODE_KAM)
d4026 6
d4167 1
a4167 1
static void
d4320 1
a4320 13
#if OPT_ZICONBEEP		/* If warning should be given then give it */
    if (resource.zIconBeep && TScreenOf(xw)->zIconBeep_flagged) {
	char *newname = CastMallocN(char, strlen(name) + 4);
	if (!newname) {
	    xtermWarning("malloc failed in ChangeIconName\n");
	    return;
	}
	strcpy(newname, "*** ");
	strcat(newname, name);
	ChangeGroup(xw, XtNiconName, newname);
	free(newname);
    } else
#endif /* OPT_ZICONBEEP */
@


1.19
log
@Update to xterm 276. Tested by ajacoutot@@, krw@@, naddy@@, shadchin@@.
@
text
@d1 1
a1 1
/* $XTermId: misc.c,v 1.550 2011/10/09 14:13:41 tom Exp $ */
d61 1
d122 1
d165 1
a165 1
selectwindow(TScreen * screen, int flag)
d167 2
d172 1
a172 1
    if (TEK4014_ACTIVE(term)) {
d181 5
a185 2
	if (screen->xic)
	    XSetICFocus(screen->xic);
d197 1
a197 1
unselectwindow(TScreen * screen, int flag)
d199 2
d205 1
a205 1
	xtermDisplayCursor(term);
d210 1
a210 1
	if (TEK4014_ACTIVE(term)) {
d219 5
a223 2
	    if (screen->xic)
		XUnsetICFocus(screen->xic);
d244 1
a244 1
	selectwindow(screen, INWINDOW);
d257 1
a257 1
	unselectwindow(screen, INWINDOW);
d785 1
a785 1
	    fprintf(stderr, "Cannot exec-xterm given %s\n", ProgramName);
d806 1
a806 1
	fprintf(stderr, "Could not fork: %s\n", SysErrorMsg(errno));
d815 1
a815 1
	    fprintf(stderr, "Cannot reset uid/gid\n");
d831 1
a831 1
	    fprintf(stderr, "exec of '%s': %s\n", child_exe, SysErrorMsg(errno));
d936 1
a936 1
	    unselectwindow(screen, INWINDOW);
d938 1
a938 1
	selectwindow(screen,
d954 1
a954 1
	    unselectwindow(screen,
d1103 8
a1110 1
    XFillRectangle(screen->display, window, visualGC, 0, 0, width, height);
d1113 1
a1113 1
    XFillRectangle(screen->display, window, visualGC, 0, 0, width, height);
d1161 28
d1640 1
a1640 1
	    tstruct->tm_year + 1900,
d1657 4
a1660 5
	fprintf(stderr, "%s: cannot open %s: %d:%s\n",
		ProgramName,
		path,
		the_error,
		SysErrorMsg(the_error));
d1669 4
a1672 5
	fprintf(stderr, "%s: cannot open %s: %d:%s\n",
		ProgramName,
		path,
		the_error,
		SysErrorMsg(the_error));
d1684 1
a1684 1
	fprintf(stderr, "%s: you do not own %s\n", ProgramName, path);
d1801 1
a1801 1
	fprintf(stderr, "%s: unable to reset group-id\n", ProgramName);
d1805 1
a1805 1
	fprintf(stderr, "%s: unable to reset user-id\n", ProgramName);
d1940 1
a1940 3
	    fprintf(stderr, "%s: Can't exec `%s'\n",
		    ProgramName,
		    &screen->logfile[1]);
d2029 2
a2030 2
static unsigned
getColormapSize(Display * display)
a2031 1
    unsigned result;
d2039 2
a2040 1
    result = (numFound >= 1) ? (unsigned) visInfoPtr->colormap_size : 0;
d2043 34
d2098 1
a2098 1
find_closest_color(Display * dpy, Colormap cmap, XColor * def)
d2100 1
a2101 1
    XColor *colortable;
d2106 1
d2110 1
a2110 2
    cmap_size = getColormapSize(dpy);
    if (cmap_size != 0) {
d2112 3
a2114 2
	colortable = TypeMallocN(XColor, (size_t) cmap_size);
	if (colortable != 0) {
a2118 5
		for (i = 0; i < cmap_size; i++) {
		    colortable[i].pixel = (unsigned long) i;
		}
		XQueryColors(dpy, cmap, colortable, (int) cmap_size);

d2139 1
a2139 1
			    diff = weight * (int) ((def->color) - colortable[i].color); \
d2153 5
a2157 2
		    if (XAllocColor(dpy, cmap, &colortable[bestInx]) != 0) {
			*def = colortable[bestInx];
a2169 1
	    free(colortable);
d2175 104
a2294 2
    TScreen *screen = TScreenOf(xw);
    Colormap cmap = xw->core.colormap;
d2296 1
a2296 3
    if (XParseColor(screen->display, cmap, spec, &def)
	&& (XAllocColor(screen->display, cmap, &def)
	    || find_closest_color(screen->display, cmap, &def))) {
d2307 1
a2307 1
		   (int) (res - screen->Acolors), spec, def.pixel));
d2339 2
a2340 4
		fprintf(stderr,
			"%s: Cannot allocate color \"%s\"\n",
			ProgramName,
			NonNull(res->resource));
d2483 2
a2484 1
#define find_closest_color(display, cmap, def) 0
d2487 17
d2676 1
a2676 1
	    fprintf(stderr, "allocation failure in GetOldColors\n");
d3968 5
a3972 1
	    result = MdBool(screen->ext_mode_mouse);
d3981 1
a3981 1
	    result = MdBool(screen->input_eight_bits);
d4242 1
a4242 1
	    fprintf(stderr, "malloc failed in ChangeIconName\n");
a4338 2
	TScreen *screen = TScreenOf(xw);
	Colormap cmap = xw->core.colormap;
d4346 1
a4346 5
	} else if (XParseColor(screen->display, cmap, name, &def)
		   && (XAllocColor(screen->display, cmap, &def)
		       || find_closest_color(screen->display, cmap, &def))) {
	    ;			/*empty */
	} else {
d4374 1
a4374 4
	fprintf(stderr, "%s: PANIC!\t", ProgramName);
	fprintf(stderr, s, a);
	fputs("\r\n", stderr);
	fflush(stderr);
d4495 1
a4495 1
			  NULL);
d4571 1
a4571 1
	    fprintf(stderr, "No absolute path found for shell: %s\n", result);
d4674 1
a4674 1
		    fprintf(stderr, "Cannot increase environment\n");
d4689 1
a4689 1
	    fprintf(stderr, "Cannot allocate environment %s\n", var);
d4720 1
a4720 1
    fprintf(stderr, "%s:  warning, error event received:\n", ProgramName);
d4731 2
a4732 3
    fprintf(stderr,
	    "%s:  ICE IO error handler doing an exit(), pid = %ld, errno = %d\n",
	    ProgramName, (long) getpid(), errno);
d4743 3
a4745 4
    (void) fprintf(stderr,
		   "%s:  fatal IO error %d (%s) or KillClient on X server \"%s\"\r\n",
		   ProgramName, the_error, SysErrorMsg(the_error),
		   DisplayString(dpy));
d4754 1
a4754 1
    (void) fprintf(stderr, "%s Xt error: %s\n", ProgramName, message);
d4760 1
a4760 1
	fprintf(stderr, "%s:  DISPLAY is not set\n", ProgramName);
d5322 1
a5322 2
	    fprintf(stderr, "%s: invalid window-id %ld\n",
		    ProgramName, (long) win);
@


1.18
log
@Update to xterm-275. Tested by jasper@@.
@
text
@d1 1
a1 1
/* $XTermId: misc.c,v 1.548 2011/09/11 20:18:45 tom Exp $ */
d4321 3
d4333 15
a4347 1
    if (*result != '\0' && strchr("+/-", *result) == 0) {
@


1.17
log
@Update to xterm 273. Tested by marco@@, jasper@@.
@
text
@d1 1
a1 1
/* $XTermId: misc.c,v 1.539 2011/08/23 01:03:18 tom Exp $ */
d275 1
a275 1
    if (XtAppPending(app_con)
d362 166
d547 1
a547 1
    while ((input_mask = XtAppPending(app_con)) != 0) {
d631 1
a631 1
    } while (XtAppPending(app_con) & XtIMXEvent);
a1791 3
#ifdef ALLOWLOGFILEEXEC
    char *cp;
#endif /* ALLOWLOGFILEEXEC */
d1851 1
a1851 1
	struct passwd *pw;
d1871 11
a1881 4
	    if ((((cp = x_getenv("SHELL")) == NULL)
		 && ((pw = getpwuid(screen->uid)) == NULL
		     || *(cp = pw->pw_shell) == 0))
		|| (shell = CastMallocN(char, strlen(cp))) == 0) {
a1883 2
	    } else {
		strcpy(shell, cp);
d3461 1
d3464 1
d4378 16
d4399 3
d4412 1
d4415 23
d4449 8
a4456 2
	char *test;
	int envindex = 0;
d4458 2
a4459 1
	int found = -1;
a4462 8
	while ((test = environ[envindex]) != NULL) {
	    if (strncmp(test, var, len) == 0 && test[len] == '=') {
		found = envindex;
		break;
	    }
	    envindex++;
	}

d4490 1
d4494 19
d4879 1
a4879 1
char *
d4882 1
a4882 1
    static char *result;
d5081 1
a5081 1
    result = XtAppInitialize(app_conp,
d5083 4
a5086 3
			     optionDescList,
			     XtNumber(optionDescList),
			     &argc, argv,
@


1.16
log
@Update to xterm 271. Tested by shadchin@@ and ajacoutot@@
@
text
@d1 1
a1 1
/* $XTermId: misc.c,v 1.530 2011/07/11 00:16:41 tom Exp $ */
d4768 150
@


1.15
log
@Update to xterm 270. Tested by ajacoutot@@, shadchin@@, krw@@ and jasper@@
@
text
@d1 1
a1 1
/* $XTermId: misc.c,v 1.521 2011/04/17 19:04:06 tom Exp $ */
d1498 1
a1498 1
creat_as(uid_t uid, gid_t gid, Bool append, char *pathname, int mode)
d1963 1
a1963 1
	    TRACE(("AllocateAnsiColor[%d] %s (pixel %#lx)\n",
d2390 1
a2390 1
	TRACE(("ReportColors %d: %#lx as %s\n",
d2738 2
d3289 7
d3533 1
a3533 1
	    result = MdBool(screen->printer_formfeed);
d3536 1
a3536 1
	    result = MdBool(screen->printer_extent);
d3895 1
a3895 1
#define Strlen(s) strlen((char *)(s))
d3978 14
a3991 3
	if (XParseColor(screen->display, cmap, name, &def)
	    && (XAllocColor(screen->display, cmap, &def)
		|| find_closest_color(screen->display, cmap, &def))
d3993 1
a3993 1
	    if (COLOR_DEFINED(pNew, ndx))
d3995 1
d3998 2
a3999 2
	    TRACE(("AllocateTermColor #%d: %s (pixel %#lx)\n", ndx, newName, def.pixel));
	    result = True;
d4002 1
d4589 1
a4589 1
	    if (!strncmp(opt_array[j].opt, "-/+", 3)) {
d4615 1
a4615 1
			    if (strncmp(opt_array[j].desc, "turn ", 5)) {
@


1.14
log
@Update to xterm version 269.
Tested and ok ajacoutot@@, jasper@@, krw@@, shadchin@@
@
text
@d1 1
a1 1
/* $XTermId: misc.c,v 1.520 2011/02/13 21:03:21 tom Exp $ */
d4267 12
@


1.13
log
@Update to xterm 267. Tested by shadchin@@, jasper@@, ajacoutot@@.
@
text
@d1 1
a1 1
/* $XTermId: misc.c,v 1.511 2010/11/10 00:56:29 tom Exp $ */
d4 1
a4 1
 * Copyright 1999-2009,2010 by Thomas E. Dickey
d253 1
a253 1
setXUrgency(TScreen * screen, Bool enable)
d255 2
d258 1
a258 1
	XWMHints *h = XGetWMHints(screen->display, VShellWindow);
d260 1
a260 1
	    if (enable) {
d265 1
a265 1
	    XSetWMHints(screen->display, VShellWindow, h);
d744 1
a744 1
	;
d746 1
a746 1
	setXUrgency(screen, False);
d861 1
a861 1
	XkbBell(screen->display, VShellWindow, percent, tony);
d879 1
a879 1
    setXUrgency(screen, True);
d906 1
a906 1
	XRaiseWindow(screen->display, VShellWindow);
d977 1
a977 1
WMFrameWindow(XtermWidget termw)
d983 1
a983 1
    win_current = XtWindow(termw);
d989 1
a989 1
	XQueryTree(TScreenOf(termw)->display,
d1201 1
a1201 1
	XMapWindow(screen->display, VShellWindow);
d1217 1
a1217 1
		       VShellWindow,
d1223 1
a1223 1
QueryMaximize(XtermWidget termw, unsigned *width, unsigned *height)
d1225 1
a1225 1
    TScreen *screen = TScreenOf(termw);
d1235 1
a1235 1
		     RootWindowOfScreen(XtScreen(termw)),
d1255 1
a1255 1
			      VShellWindow,
d1275 1
a1275 1
RequestMaximize(XtermWidget termw, int maximize)
d1277 1
a1277 1
    TScreen *screen = TScreenOf(termw);
d1285 1
a1285 1
	if (QueryMaximize(termw, &root_width, &root_height)) {
d1288 1
a1288 1
				     WMFrameWindow(termw),
d1292 1
a1292 1
					 VShellWindow,
d1318 1
a1318 1
		    XMoveResizeWindow(screen->display, VShellWindow,
d1336 1
a1336 1
			      VShellWindow,
d1445 1
a1445 1
		xterm_name,
d1458 1
a1458 1
		xterm_name,
d1473 1
a1473 1
	fprintf(stderr, "%s: you do not own %s\n", xterm_name, path);
d1727 2
a1728 1
	    fprintf(stderr, "%s: Can't exec `%s'\n", xterm_name,
d1998 1
a1998 1
			xterm_name,
d2315 1
a2315 1
	pOldColors = (ScrnColors *) XtMalloc((Cardinal) sizeof(ScrnColors));
d2679 3
a2681 1
		    ;		/* there is only one font entry to load */
d3180 1
a3180 1
	    ;
d3350 1
a3350 1
			    unparseputs(xw, xterm_name);
d3834 1
a3834 1
			XChangeProperty(dpy, VShellWindow, my_atom,
d3841 1
a3841 1
			XDeleteProperty(dpy, VShellWindow, my_atom);
d3993 1
a3993 1
	fprintf(stderr, "%s: PANIC!\t", xterm_name);
d4076 1
a4076 1
    fprintf(stderr, "%s: Error %d, errno %d: ", xterm_name, code, oerrno);
d4263 1
a4263 1
    fprintf(stderr, "%s:  warning, error event received:\n", xterm_name);
d4277 1
a4277 1
		   xterm_name, the_error, SysErrorMsg(the_error),
d4324 2
a4325 1
    TScreen *screen = TScreenOf(term);
d4329 3
a4331 3
	if (!screen->Vshow && term) {
	    VTInit(term);
	    XtMapWidget(XtParent(term));
d4334 1
a4334 1
	    XtMapWidget(SHELL_OF(term));
d4342 4
a4345 4
	if (screen->Vshow && term) {
	    withdraw_window(XtDisplay(term),
			    VShellWindow,
			    XScreenNumberOfScreen(XtScreen(term)));
d4556 1
d4567 2
a4568 1
		    if (x_strindex(opt_array[j].desc, "inhibit") != 0)
@


1.12
log
@Update to xterm version 264, Tested at least by krw@@, jasper@@, ajacoutot@@.
@
text
@d1 1
a1 1
/* $XTermId: misc.c,v 1.510 2010/10/11 08:33:33 tom Exp $ */
d1994 1
a1994 1
			"%s: Cannot allocate color %s\n",
@


1.11
log
@Update to xterm 262.

tested by ajacoutot@@, jasper@@ and krw@@.
@
text
@d1 1
a1 1
/* $XTermId: misc.c,v 1.507 2010/08/30 08:26:45 tom Exp $ */
d428 1
d432 22
a460 22
	    /*
	     * If the event is interesting (and not a keyboard event), turn the
	     * mouse pointer back on.
	     */
	    if (screen->hide_pointer) {
		switch (event.xany.type) {
		case KeyPress:
		case KeyRelease:
		case ButtonPress:
		case ButtonRelease:
		    /* also these... */
		case Expose:
		case NoExpose:
		case PropertyNotify:
		case ClientMessage:
		    break;
		default:
		    xtermShowPointer(xw, True);
		    break;
		}
	    }

d2555 1
a2555 1
ParseShiftedFont(XtermWidget xw, char *source, char **target)
d2590 1
a2590 1
QueryFontRequest(XtermWidget xw, char *buf, int final)
d2596 1
a2596 1
	char *base = buf + 1;
d2640 1
a2640 1
ChangeFontRequest(XtermWidget xw, char *buf)
d3454 2
a3455 2
	reply.a_param[count++] = params[0];
	reply.a_param[count++] = result;
d3458 1
a3458 1
    reply.a_nparam = count;
d3684 2
a3685 2
	reply.a_param[count++] = params[0];
	reply.a_param[count++] = result;
d3689 1
a3689 1
    reply.a_nparam = count;
@


1.10
log
@Update to xterm 261. Tested by krw@@, jcs@@.
@
text
@d1 1
a1 1
/* $XTermId: misc.c,v 1.503 2010/06/20 21:33:49 tom Exp $ */
d3386 308
@


1.9
log
@Update to xterm 258. lightly tested by krw@@, thanks.
@
text
@d1 1
a1 1
/* $XTermId: misc.c,v 1.493 2010/04/18 17:51:44 tom Exp $ */
d130 1
a130 1
    unsigned size = 100;
d376 1
a376 1
     * XEvent queue.  Other sources i.e. the pty are handled elsewhere
d379 3
a381 2
    while ((input_mask = XtAppPending(app_con)) & XtIMTimer)
	XtAppProcessEvent(app_con, XtIMTimer);
d383 6
a388 6
    /*
     * Session management events are alternative input events. Deal with
     * them in the same way.
     */
    while ((input_mask = XtAppPending(app_con)) & XtIMAlternateInput)
	XtAppProcessEvent(app_con, XtIMAlternateInput);
d390 3
d452 1
d462 1
a462 1
    } while ((input_mask = XtAppPending(app_con)) & XtIMXEvent);
d570 1
a570 1
	StringInput(term, (Char *) * params, strlen(*params));
d600 2
a601 2
	if (strncmp(ProgramName, "./", 2)
	    && strncmp(ProgramName, "../", 3)) {
d683 1
a683 1
	char *value = params[0];
d690 1
a690 1
	    fillPtyData(TScreenOf(term), VTbuffer, value, (int) strlen(value));
d779 1
a779 1
	    Bell(XkbBI_Info, 100);
d865 1
a865 1
Bell(int which, int percent)
a866 1
    XtermWidget xw = term;
d1106 2
d1109 2
a1118 1
    } else {
d1121 3
d1181 1
a1181 1
	    Bell(XkbBI_TerminalBell, 0);
d1608 2
a1609 1
    TScreen *screen = TScreenOf(term);
d1615 1
a1615 1
	CloseLog(screen);
d1620 1
a1620 1
StartLog(TScreen * screen)
d1626 1
d1732 2
a1733 2
	Bell(XkbBI_Info, 0);
	Bell(XkbBI_Info, 0);
d1750 1
a1750 1
CloseLog(TScreen * screen)
d1752 2
d1756 1
a1756 1
    FlushLog(screen);
d1763 1
a1763 1
FlushLog(TScreen * screen)
d1765 2
d1940 1
a1940 1
		  char *spec)
d2007 1
a2007 1
ChangeOneAnsiColor(XtermWidget xw, int color, char *name)
d2209 1
a2209 1
		xtermGetSelection((Widget) xw, 0, select_args, n, NULL);
d2513 1
a2513 1
    char *thisName;
d2596 1
a2596 1
	char *name = 0;
d2602 1
a2602 1
	    Bell(XkbBI_MinorError, 0);
d2660 1
a2660 1
		Bell(XkbBI_MinorError, 0);
d2707 1
a2707 1
	    Bell(XkbBI_MinorError, 0);
d2918 2
a2919 2
	Bell(XkbBI_Info, 0);
	Bell(XkbBI_Info, 0);
d3493 1
a3493 1
	    char *buf;
d3497 1
a3497 1
	    if (strcmp(name, buf) == 0)
a3727 1
	{ ERROR_SPREALLOC,	"spawn: realloc of ttydev failed" },
d3803 1
a3803 1
			  (XtPointer *) 0);
d4050 8
a4057 4
	if (!TEK4014_SHOWN(term) && (tekWidget || TekInit())) {
	    Widget tekParent = SHELL_OF(tekWidget);
	    XtRealizeWidget(tekParent);
	    XtMapWidget(XtParent(tekWidget));
d4059 12
a4070 11
	    /* we need both of these during initialization */
	    XtMapWidget(tekParent);
	    XtMapWidget(tekWidget);
#endif
	    XtOverrideTranslations(tekParent,
				   XtParseTranslationTable
				   ("<Message>WM_PROTOCOLS: DeleteWindow()"));
	    (void) XSetWMProtocols(XtDisplay(tekParent),
				   XtWindow(tekParent),
				   &wm_delete_window, 1);
	    TEK4014_SHOWN(term) = True;
d4091 4
a4094 2
    if (TEK4014_ACTIVE(term)) {
	FlushLog(TScreenOf(term));
d4103 5
a4107 3
    if (!TEK4014_ACTIVE(term)) {
	FlushLog(TScreenOf(term));
	TEK4014_ACTIVE(term) = True;
d4173 5
a4177 3
    if (descs == 0 && res_array != 0) {
	free(res_array);
	res_array = 0;
d4185 5
a4189 3
	for (j = 0; j < res_count; j++)
	    res_array[j] = descs[j];
	qsort(res_array, (size_t) res_count, sizeof(*res_array), cmp_resources);
d4241 1
a4241 1
		char *name = opt_array[j].opt + 3;
d4243 1
a4243 1
		    char *value = res_array[k].value;
d4366 1
d4368 1
d4370 1
a4370 1
	char *vendor = __vendorversion__;
@


1.8
log
@Update to xterm-255. Tested by stsp@@, oga@@.
@
text
@d1 1
a1 1
/* $XTermId: misc.c,v 1.482 2010/01/21 09:34:58 tom Exp $ */
a3 1
 *
d6 1
a6 1
 *                        All Rights Reserved
d137 1
a137 1
	n = readlink(filename, buf, size);
d186 1
d680 2
a681 2
	int used = VTbuffer->next - VTbuffer->buffer;
	int have = VTbuffer->last - VTbuffer->buffer;
d803 1
a803 1
	    result = XInternAtom(XtDisplay(xw), table[n].name, True);
d1077 2
a1078 2
    unsigned del_cnt;
    unsigned buf_cnt;
d1141 1
a1141 1
	    v_write(pty, copybuffer, buf_cnt);
d1763 2
a1764 2
	    && (i = cp - screen->logstart) > 0) {
	    IGNORE_RC(write(screen->logfd, screen->logstart, (unsigned) i));
d1944 1
a1944 1
		   (res - screen->Acolors), spec, def.pixel));
d1968 1
a1968 1
	       res - TScreenOf(xw)->Acolors));
d2096 2
a2097 2
	    color = strtol(buf, &next, 10);
	    if (next == buf)
d2295 1
a2295 1
	pOldColors = (ScrnColors *) XtMalloc(sizeof(ScrnColors));
d2478 1
a2478 1
		    AllocateTermColor(xw, &newColors, ndx, thisName);
d2517 1
a2517 1
	    AllocateTermColor(xw, &newColors, ndx, thisName);
d2701 1
a2701 1
do_osc(XtermWidget xw, Char * oscbuf, unsigned len GCC_UNUSED, int final)
d2738 2
a2739 1
		TRACE(("do_osc did not find semicolon offset %d\n", cp - oscbuf));
d2758 1
a2758 1
			   cp - oscbuf));
d3177 1
a3177 1
    TRACE(("do_dcs(%s:%d)\n", (char *) dcsbuf, dcslen));
d3396 1
a3396 1
    unsigned limit;
d3628 2
a3629 1
		  const char *name)
d3633 1
a3633 1
    if (AllowColorOps(xw, ecSetColor)) {
d4161 1
a4161 1
	qsort(res_array, res_count, sizeof(*res_array), cmp_resources);
d4189 1
a4189 1
	Cardinal opt_count, j;
d4350 1
a4350 1
		if (!strncmp(vendor, "Version ", 8))
@


1.7
log
@Update to xterm 250
@
text
@d1 1
a1 1
/* $XTermId: misc.c,v 1.428 2009/10/12 00:44:44 tom Exp $ */
d5 1
a5 1
 * Copyright 1999-2008,2009 by Thomas E. Dickey
d228 5
a232 7
#ifdef ACTIVEWINDOWINPUTONLY
    if (ev->window == XtWindow(XtParent(CURRENT_EMU())))
#endif
	if (((ev->detail) != NotifyInferior) &&
	    ev->focus &&
	    !(screen->select & FOCUS))
	    selectwindow(screen, INWINDOW);
d241 5
a245 7
#ifdef ACTIVEWINDOWINPUTONLY
    if (ev->window == XtWindow(XtParent(CURRENT_EMU())))
#endif
	if (((ev->detail) != NotifyInferior) &&
	    ev->focus &&
	    !(screen->select & FOCUS))
	    unselectwindow(screen, INWINDOW);
d516 1
a516 4
#ifdef ACTIVEWINDOWINPUTONLY
    if (w == CURRENT_EMU())
#endif
	Input(term, &event->xkey, False);
d527 1
a527 4
#ifdef ACTIVEWINDOWINPUTONLY
    if (w == CURRENT_EMU())
#endif
	Input(term, &event->xkey, True);
a536 4
#ifdef ACTIVEWINDOWINPUTONLY
    if (w != CURRENT_EMU())
	return;
#endif
d544 2
a545 1
	Char c, *p;
d548 1
a548 1
	for (p = (Char *) (*params + 2); (c = CharOf(x_toupper(*p))) !=
d582 1
a582 1
    TScreen *screen = &term->screen;
d702 1
d714 1
d732 1
d817 35
d860 1
a860 1
Bell(int which GCC_UNUSED, int percent)
d940 1
a940 1
	    TekScreen *tekscr = &(tekWidget->screen);
d982 1
a982 1
	XQueryTree((&termw->screen)->display,
d1169 1
a1169 1
	TScreen *screen = &xw->screen;
d1212 1
a1212 1
    TScreen *screen = &termw->screen;
d1264 1
a1264 1
    TScreen *screen = &termw->screen;
d1268 2
d1389 1
a1389 1
	TekScreen *tekscr = &(tekWidget->screen);
d1558 1
a1558 1
	    if (waited == term->screen.pid)
d1778 18
a1795 16
    XColor color;
    Colormap cmap = xw->core.colormap;
    char buffer[80];

    TRACE(("ReportAnsiColorRequest %d\n", colornum));
    color.pixel = GET_COLOR_RES(xw->screen.Acolors[colornum]);
    XQueryColor(xw->screen.display, cmap, &color);
    sprintf(buffer, "4;%d;rgb:%04x/%04x/%04x",
	    colornum,
	    color.red,
	    color.green,
	    color.blue);
    unparseputc1(xw, ANSI_OSC);
    unparseputs(xw, buffer);
    unparseputc1(xw, final);
    unparse_end(xw);
d1928 1
a1928 1
    TScreen *screen = &xw->screen;
d1960 1
a1960 1
xtermGetColorRes(ColorRes * res)
d1968 1
a1968 1
	       res - term->screen.Acolors));
d1970 2
a1971 2
	if (res >= term->screen.Acolors) {
	    assert(res - term->screen.Acolors < MAXCOLORS);
d1973 2
a1974 2
	    if (AllocateAnsiColor(term, res, res->resource) < 0) {
		res->value = term->screen.Tcolors[TEXT_FG].value;
d1990 28
d2021 1
d2028 1
d2039 2
a2040 2
	if (color < 0 || color >= NUM_ANSI_COLORS)
	    break;
d2046 4
a2049 5
	if (!strcmp(name, "?"))
	    ReportAnsiColorRequest(xw, color, final);
	else {
	    TRACE(("ChangeAnsiColor for Acolors[%d]\n", color));
	    code = AllocateAnsiColor(xw, &(xw->screen.Acolors[color]), name);
a2060 2
    if (repaint)
	xtermRepaint(xw);
d2064 57
d2132 1
a2132 1
	char *result;
d2150 1
a2150 1
    char **select_args = 0;
d2179 5
a2183 4
	    TRACE(("Getting selection\n"));
	    unparseputc1(xw, ANSI_OSC);
	    unparseputs(xw, "52");
	    unparseputc(xw, ';');
d2185 2
a2186 2
	    unparseputs(xw, used);
	    unparseputc(xw, ';');
d2188 3
a2190 3
	    /* Tell xtermGetSelection data is base64 encoded */
	    screen->base64_paste = n;
	    screen->base64_final = final;
d2192 3
a2194 2
	    /* terminator will be written in this call */
	    xtermGetSelection((Widget) xw, 0, select_args, n, NULL);
d2196 7
a2202 5
	    TRACE(("Setting selection with %s\n", buf));
	    ClearSelectionBuffer(screen);
	    while (*buf != '\0')
		AppendToSelectionBuffer(screen, CharOf(*buf++));
	    CompleteSelection(xw, select_args, n);
d2210 2
d2213 1
a2213 1
xtermIsPrintable(TScreen * screen, Char ** bufp, Char * last)
d2215 1
d2224 1
a2224 1
    if (xtermEnvUTF8() && screen->utf8_title) {
d2258 1
a2258 1
 * array indices.
d2282 6
d2351 4
a2354 3
    XColor color;
    Colormap cmap = xw->core.colormap;
    char buffer[80];
d2356 6
a2361 6
    /*
     * ChangeColorsRequest() has "always" chosen the opposite color when
     * reverse-video is set.  Report this as the original color index, but
     * reporting the opposite color which would be used.
     */
    int i = (xw->misc.re_verse) ? oppositeColor(ndx) : ndx;
d2363 14
a2376 12
    GetOldColors(xw);
    color.pixel = pOldColors->colors[ndx];
    XQueryColor(xw->screen.display, cmap, &color);
    sprintf(buffer, "%d;rgb:%04x/%04x/%04x", i + 10,
	    color.red,
	    color.green,
	    color.blue);
    TRACE(("ReportColors %d: %#lx as %s\n", ndx, pOldColors->colors[ndx], buffer));
    unparseputc1(xw, ANSI_OSC);
    unparseputs(xw, buffer);
    unparseputc1(xw, final);
    unparse_end(xw);
d2462 1
a2462 1
	    if ((names == NULL) || (names[0] == '\0')) {
d2492 206
d2703 1
a2703 1
    TScreen *screen = &(xw->screen);
d2708 5
d2748 1
a2748 1
	    if (!xtermIsPrintable(screen, &cp, oscbuf + len)) {
d2763 43
a2805 2
    if (buf == 0) {
	TRACE(("do_osc found no data\n"));
d2824 1
a2824 1
	if (AllowWindowOps(xw))
d2828 3
d2832 9
a2840 1
	ChangeAnsiColorRequest(xw, buf, final);
d2850 1
d2857 1
a2857 1
	if (xw->misc.dynamicColors)
d2859 19
d2892 1
a2892 2
	if (buf != 0
	    && strcmp(buf, "?")
d2908 4
a2911 64
	if (!AllowFontOps(xw) && xw->misc.shift_fonts) {
	    ;			/* disabled via resource or control-sequence */
	} else if (buf != 0 && !strcmp(buf, "?")) {
	    int num = screen->menu_font_number;

	    unparseputc1(xw, ANSI_OSC);
	    unparseputs(xw, "50");

	    if ((buf = screen->MenuFontName(num)) != 0) {
		unparseputc(xw, ';');
		unparseputs(xw, buf);
	    }
	    unparseputc1(xw, final);
	    unparse_end(xw);
	} else if (buf != 0) {
	    int num = screen->menu_font_number;
	    VTFontNames fonts;

	    memset(&fonts, 0, sizeof(fonts));

	    /*
	     * If the font specification is a "#", followed by an
	     * optional sign and optional number, lookup the
	     * corresponding menu font entry.
	     */
	    if (*buf == '#') {
		int rel = 0;

		if (*++buf == '+') {
		    rel = 1;
		    buf++;
		} else if (*buf == '-') {
		    rel = -1;
		    buf++;
		}

		if (isdigit(CharOf(*buf))) {
		    int val = atoi(buf);
		    if (rel > 0)
			rel = val;
		    else if (rel < 0)
			rel = -val;
		    else
			num = val;
		} else if (rel == 0) {
		    num = 0;
		}

		if (rel != 0) {
		    num = lookupRelativeFontSize(xw,
						 screen->menu_font_number, rel);

		}
		if (num < 0
		    || num > fontMenu_lastBuiltin
		    || (buf = screen->MenuFontName(num)) == 0) {
		    Bell(XkbBI_MinorError, 0);
		    break;
		}
	    } else {
		num = fontMenu_fontescape;
	    }
	    fonts.f_n = buf;
	    SetVTFont(xw, num, True, &fonts);
d2921 1
a2921 2
	if (AllowWindowOps(xw))
	    ManipulateSelectionData(xw, screen, buf, final);
d2928 3
d2952 1
a2952 1
udk_value(char **cp)
d2954 1
d2961 3
a2963 7
	    return -1;
	if (c >= '0' && c <= '9')
	    return c - '0';
	if (c >= 'A' && c <= 'F')
	    return c - 'A' + 10;
	if (c >= 'a' && c <= 'f')
	    return c - 'a' + 10;
d2965 2
d2986 1
a2986 1
parse_decudk(char *cp)
d2989 1
a2989 1
	char *base = cp;
d3024 1
a3024 1
parse_decdld(ANSI * params, char *string)
d3138 1
a3138 1
parse_ansi_params(ANSI * params, char **string)
d3140 1
a3140 1
    char *cp = *string;
d3170 1
a3170 1
    TScreen *screen = &xw->screen;
d3172 1
a3172 1
    char *cp = (char *) dcsbuf;
d3285 13
a3297 6
	if ((*cp == 'q') && AllowTcapOps(xw)) {
	    Bool fkey;
	    unsigned state;
	    int code;
	    char *tmp;
	    char *parsed = ++cp;
d3299 1
a3299 1
	    code = xtermcapKeycode(xw, &parsed, &state, &fkey);
d3301 1
a3301 1
	    unparseputc1(xw, ANSI_DCS);
d3303 1
a3303 1
	    unparseputc(xw, code >= 0 ? '1' : '0');
d3305 2
a3306 9
	    unparseputc(xw, '+');
	    unparseputc(xw, 'r');

	    while (*cp != 0 && (code >= -1)) {
		if (cp == parsed)
		    break;	/* no data found, error */

		for (tmp = cp; tmp != parsed; ++tmp)
		    unparseputc(xw, *tmp);
d3308 11
a3318 4
		if (code >= 0) {
		    unparseputc(xw, '=');
		    screen->tc_query_code = code;
		    screen->tc_query_fkey = fkey;
d3320 16
a3335 10
		    /* XK_COLORS is a fake code for the "Co" entry (maximum
		     * number of colors) */
		    if (code == XK_COLORS) {
			unparseputn(xw, NUM_ANSI_COLORS);
		    } else
#endif
		    {
			XKeyEvent event;
			event.state = state;
			Input(xw, &event, False);
a3336 4
		    screen->tc_query_code = -1;
		} else {
		    break;	/* no match found, error */
		}
a3337 3
		cp = parsed;
		if (*parsed == ';') {
		    unparseputc(xw, *parsed++);
d3339 5
a3343 1
		    code = xtermcapKeycode(xw, &parsed, &state, &fkey);
d3345 1
d3347 1
a3347 1
	    unparseputc1(xw, ANSI_ST);
d3389 1
a3389 4
    char *my_attr = x_strdup(attribute);
    char *original = (value != 0) ? value : empty;
    char *name = original;
    TScreen *screen = TScreenOf(xw);
d3392 5
a3396 2
    unsigned limit = strlen(name);
    Char *c1 = (Char *) original;
a3398 2
    TRACE(("ChangeGroup(attribute=%s, value=%s)\n", my_attr, name));

d3402 24
d3429 1
a3429 2
    if (limit >= 1024)
	return;
d3431 8
a3438 4
    for (cp = c1; *cp != 0; ++cp) {
	Char *c2 = cp;
	if (!xtermIsPrintable(screen, &cp, c1 + limit)) {
	    memset(c2, '?', (size_t) (cp + 1 - c2));
a3439 1
    }
d3442 9
a3450 9
    /*
     * Title strings are limited to ISO-8859-1, which is consistent with the
     * printable data in sos_table.  However, if we're running in UTF-8 mode,
     * it is likely that non-ASCII text in the string will be rejected because
     * it is not printable in the current locale.  So we convert it to UTF-8,
     * allowing the X library to convert it back.
     */
    if (xtermEnvUTF8() && !screen->utf8_title) {
	int n;
d3452 13
a3464 9
	for (n = 0; name[n] != '\0'; ++n) {
	    if (CharOf(name[n]) > 127) {
		if (converted != 0)
		    free(converted);
		if ((converted = TypeMallocN(Char, 1 + (5 * limit))) != 0) {
		    Char *temp = converted;
		    while (*name != 0) {
			temp = convertToUTF8(temp, CharOf(*name));
			++name;
d3466 1
a3466 3
		    *temp = 0;
		    name = (char *) converted;
		    TRACE(("...converted{%s}\n", name));
a3467 1
		break;
a3469 1
    }
d3473 1
a3473 1
    /* If the attribute isn't going to change, then don't bother... */
d3475 8
a3482 8
    if (resource.sameName) {
	char *buf;
	XtSetArg(args[0], my_attr, &buf);
	XtGetValues(top, args, 1);
	TRACE(("...comparing{%s}\n", buf));
	if (strcmp(name, buf) == 0)
	    return;
    }
d3485 5
a3489 4
    TRACE(("...updating %s\n", my_attr));
    TRACE(("...value is %s\n", name));
    XtSetArg(args[0], my_attr, name);
    XtSetValues(top, args, 1);
d3492 21
a3512 18
    if (xtermEnvUTF8()) {
	Display *dpy = XtDisplay(xw);
	Atom my_atom;

	const char *propname = (!strcmp(my_attr, XtNtitle)
				? "_NET_WM_NAME"
				: "_NET_WM_ICON_NAME");
	if ((my_atom = XInternAtom(dpy, propname, False)) != None) {
	    if (screen->utf8_title) {	/* FIXME - redundant? */
		TRACE(("...updating %s\n", propname));
		TRACE(("...value is %s\n", original));
		XChangeProperty(dpy, VShellWindow,
				my_atom, XA_UTF8_STRING(dpy), 8,
				PropModeReplace,
				(Char *) original, (int) strlen(original));
	    } else {
		TRACE(("...deleting %s\n", propname));
		XDeleteProperty(dpy, VShellWindow, my_atom);
d3514 1
d3516 6
d3523 1
a3523 2
#endif
    free(my_attr);
d3534 1
a3534 1
    if (resource.zIconBeep && xw->screen.zIconBeep_flagged) {
d3629 7
a3635 4
    XColor def;
    TScreen *screen = &xw->screen;
    Colormap cmap = xw->core.colormap;
    char *newName;
d3637 13
a3649 10
    if (XParseColor(screen->display, cmap, name, &def)
	&& (XAllocColor(screen->display, cmap, &def)
	    || find_closest_color(screen->display, cmap, &def))
	&& (newName = x_strdup(name)) != 0) {
	if (COLOR_DEFINED(pNew, ndx))
	    free(pNew->names[ndx]);
	SET_COLOR_VALUE(pNew, ndx, def.pixel);
	SET_COLOR_NAME(pNew, ndx, newName);
	TRACE(("AllocateTermColor #%d: %s (pixel %#lx)\n", ndx, newName, def.pixel));
	return (True);
d3651 1
a3651 2
    TRACE(("AllocateTermColor #%d: %s (failed)\n", ndx, name));
    return (False);
d4070 1
a4070 1
	FlushLog(&(term->screen));
d4080 1
a4080 1
	FlushLog(&(term->screen));
@


1.6
log
@update to xterm 246. Has been in snapshots for some time.
@
text
@d1 1
a1 1
/* $XTermId: misc.c,v 1.425 2009/08/07 23:18:31 tom Exp $ */
d519 1
a519 1
    TRACE(("Handle insert-seven-bit for %p\n", w));
d533 1
a533 1
    TRACE(("Handle insert-eight-bit for %p\n", w));
d637 1
a637 1
	    chdir(child_cwd);	/* We don't care if this fails */
d1142 1
a1142 1
    TRACE(("Handle dabbrev-expand for %p\n", w));
d1670 2
a1671 1
		shell = "/bin/sh";
d1737 1
a1737 1
	    write(screen->logfd, (char *) screen->logstart, (unsigned) i);
d2034 1
a2034 1
    char *base = buf;
d3018 1
a3018 1
ChangeGroup(XtermWidget xw, String attribute, char *value)
d3026 1
d3036 1
a3036 1
    TRACE(("ChangeGroup(attribute=%s, value=%s)\n", attribute, name));
d3090 1
a3090 1
	XtSetArg(args[0], attribute, &buf);
d3098 1
a3098 1
    TRACE(("...updating %s\n", attribute));
d3100 1
a3100 1
    XtSetArg(args[0], attribute, name);
d3108 1
a3108 1
	const char *propname = (!strcmp(attribute, XtNtitle)
d3126 1
d3132 4
a3135 2
    if (name == 0)
	name = "";
d3255 1
a3255 1
Panic(char *s GCC_UNUSED, int a GCC_UNUSED)
d3478 1
a3478 1
xtermSetenv(char *var, char *value)
d3790 1
a3790 1
	char *mesg;
d3871 3
a3873 1
	    result = "C";
a3874 1
	result = x_strdup(result);
@


1.5
log
@Update to xterm 243. tested by naddy@@.

Patch #243 - 2009/3/28

* revert change to default for allowTcapOps (request by Bram Moolenaar).
* reallocate result returned by xtermEnvLocale() to avoid reference to
freed memory after handling menuLocale resource.
* fix an old (X11R5) bug in tek4014 for switching fontsizes.
* add resource defaultString to make configurable the use of "#" when
pastes of UTF-8 text fail due to limitations in the current locale settings.
* make the set of selection target Atom's configurable by two new
resources eightBitSelectTypes and utf8SelectTypes, e.g., to use the TEXT
Atom in preference to UTF8_STRING (discussion with Stanislav Sedov
regarding koi8rxterm and the FreeBSD port).
* modify handling of TARGETS Atom by making it return exactly the set of
targets as those which xterm is currently providing.
* set MANPAGER and PAGER explicitly to /bin/cat in minstall.sh to work
around /etc/man.conf's with those variables already set (report by
Mar'yasin Semion).
* improve error-checking of tcap-query parser.
* add check for keyboard tcap), which ensures that terminal descriptions
containing the same string for shifted/unshifted keys will be seen by
tcap-query as only the unshifted key. (This would only happen with an
incorrect terminal description).
* fix conversion for input event-state to modifier-parameter which made
tcap-query feature not work with tcapFunctionKeys (keyboard type tcap).
* add "DEF_ALLOW_XXX" definitions to main.h to allow overriding the
default compiled-in values for "allowxxx" resources.
* remove check on bell-percentage added in patch #242, which disallowed
zero/negative values (Redhat Bugzilla #487829).
@
text
@d1 1
a1 1
/* $XTermId: misc.c,v 1.410 2009/03/28 17:33:52 tom Exp $ */
d575 1
a575 1
	    StringInput(term, hexval, 1);
d982 1
a982 1
dabbrev_prev_char(int *xp, int *yp, TScreen * screen)
d984 2
a985 1
    Char *linep;
d987 4
a990 5
    while (*yp >= 0) {
	linep = BUF_CHARS(screen->allbuf, *yp);
	if (--*xp >= 0)
	    return linep[*xp];
	if (--*yp < 0)		/* go to previous line */
d992 9
a1000 3
	*xp = MaxCols(screen);
	if (!((long) BUF_FLAGS(screen->allbuf, *yp) & LINEWRAPPED))
	    return ' ';		/* treat lines as separate */
d1002 1
a1002 1
    return -1;
d1006 1
a1006 1
dabbrev_prev_word(int *xp, int *yp, TScreen * screen)
d1009 1
d1012 2
d1015 1
a1015 1
    abword = ab + MAXWLEN - 1;
d1018 2
a1019 2
    while ((c = dabbrev_prev_char(xp, yp, screen)) >= 0 &&
	   IS_WORD_CONSTITUENT(c))
a1021 5
    if (c < 0) {
	if (abword < ab + MAXWLEN - 1)
	    return abword;
	else
	    return 0;
d1024 14
a1037 4
    while ((c = dabbrev_prev_char(xp, yp, screen)) >= 0 &&
	   !IS_WORD_CONSTITUENT(c)) ;	/* skip preceding spaces */
    (*xp)++;			/* can be | > screen->max_col| */
    return abword;
d1045 1
a1045 1
    static int x, y;
d1054 2
d1059 12
a1070 2
	x = screen->cur_col;
	y = screen->cur_row + screen->savelines;
d1072 13
a1084 10
	free(dabbrev_hint);	/* free(NULL) is OK */
	dabbrev_hint = dabbrev_prev_word(&x, &y, screen);
	if (!dabbrev_hint)
	    return 0;		/* no preceding word? */
	free(lastexpansion);
	if (!(lastexpansion = strdup(dabbrev_hint)))	/* make own copy */
	    return 0;
	if (!(dabbrev_hint = strdup(dabbrev_hint))) {
	    free(lastexpansion);
	    return 0;
d1086 1
a1086 1
	screen->dabbrev_working = 1;	/* we are in the middle of dabbrev process */
d1091 1
a1091 1
	if (!(expansion = dabbrev_prev_word(&x, &y, screen))) {
d1094 2
a1095 2
		x = screen->cur_col;
		y = screen->cur_row + screen->savelines;
a1104 2
    if (!expansion)		/* no expansion found */
	return 0;
d1106 25
a1130 18
    del_cnt = strlen(lastexpansion) - hint_len;
    buf_cnt = del_cnt + strlen(expansion) - hint_len;
    if (!(copybuffer = TypeMallocN(Char, buf_cnt)))
	return 0;
    memset(copybuffer, screen->dabbrev_erase_char, del_cnt);	/* delete previous expansion */
    memmove(copybuffer + del_cnt,
	    expansion + hint_len,
	    strlen(expansion) - hint_len);
    v_write(pty, copybuffer, buf_cnt);
    screen->dabbrev_working = 1;	/* v_write() just set it to 1 */
    free(copybuffer);

    free(lastexpansion);
    lastexpansion = strdup(expansion);
    if (!lastexpansion)
	return 0;
    expansions++;
    return 1;
d1817 1
a1817 1
	colortable = TypeMallocN(XColor, cmap_size);
d1820 1
a1820 1
	    tried = TypeCallocN(char, cmap_size);
d2730 1
a2730 1
		DscsName[len++] = ch;
d2732 1
a2732 1
	    DscsName[len++] = ch;
d2761 1
a2761 1
	    ch -= 0x3f;
d2763 1
a2763 1
		bits[row + n][col] = (ch & (1 << n)) ? '*' : '.';
d2796 3
a2798 2
		params->a_param[nparam] *= 10;
		params->a_param[nparam] += (ch - '0');
d2865 2
a2866 1
		if_OPT_EXT_COLORS(screen, {
d2892 2
a2893 1
		if_OPT_ISO_TRADITIONAL_COLORS(screen, {
d2909 1
d3048 1
a3048 1
	    memset(c2, '?', (unsigned) (cp + 1 - c2));
a3315 2
	{ ERROR_SREALLOC,	"ScreenResize: realloc() failed on alt base" },
	{ ERROR_RESIZE,		"ScreenResize: malloc() or realloc() failed" },
a3316 2
	{ ERROR_SBRALLOC,	"ScrollBarOn: realloc() failed on base" },
	{ ERROR_SBRALLOC2,	"ScrollBarOn: realloc() failed on rows" },
d3591 1
a3591 1
	    VTInit();
@


1.4
log
@Update to xterm 242. Tested by jsg@@.
@
text
@d1 1
a1 1
/* $XTermId: misc.c,v 1.405 2009/02/13 23:39:29 tom Exp $ */
d824 1
a824 2
    if (percent > 0) {
	TScreen *screen = TScreenOf(xw);
d826 4
a829 4
	Atom tony = AtomBell(xw, which);
	if (tony != None) {
	    XkbBell(screen->display, VShellWindow, percent, tony);
	} else
d831 1
a831 2
	    XBell(screen->display, percent);
    }
d2901 2
a2904 2
	    code = xtermcapKeycode(xw, &parsed, &state, &fkey);

d2910 1
a2910 1
	    while (*cp != 0) {
a2927 8
#if OPT_TCAP_FKEYS
			/*
			 * First ensure that we handle the extended cursor- and
			 * editing-keypad keys.
			 */
			if ((code <= XK_Fn(MAX_FKEY))
			    || xtermcapString(xw, CodeToXkey(code), 0) == 0)
#endif
d3834 1
d3941 1
a3941 1
    TRACE(("getXtermWidget %p -> %p\n", w, xw));
@


1.3
log
@xterm 238. includes fix for CVE-2008-2383.
@
text
@d1 1
a1 1
/* $XTermId: misc.c,v 1.391 2008/12/30 17:44:50 tom Exp $ */
d5 1
a5 1
 * Copyright 1999-2007,2008 by Thomas E. Dickey
d57 1
d477 1
a477 1
     * server insists on drawing _somethng_.
d482 1
a482 1
	fn = XLoadQueryFont(dpy, "fixed");
d519 1
a519 1
    TRACE(("Handle 7bit-key\n"));
d533 1
a533 1
    TRACE(("Handle 8bit-key\n"));
d692 1
a692 1
	int need = strlen(value);
d794 42
d837 1
a837 1
Bell(Atom which GCC_UNUSED, int percent)
d839 2
a840 1
    TScreen *screen = TScreenOf(term);
d844 2
a845 2
    TRACE(("BELL %ld %d%%\n", (long) which, percent));
    if (!XtIsRealized((Widget) term)) {
d872 1
a872 5
#if defined(HAVE_XKB_BELL_EXT)
	XkbBell(screen->display, VShellWindow, percent, which);
#else
	XBell(screen->display, percent);
#endif
d1014 1
a1014 1
	    *(--abword) = c;
d1103 1
a1103 1
HandleDabbrevExpand(Widget gw,
d1108 5
a1112 3
    if (IsXtermWidget(gw)) {
	XtermWidget w = (XtermWidget) gw;
	TScreen *screen = &w->screen;
d1122 1
a1122 1
HandleDeIconify(Widget gw,
d1127 4
a1130 2
    if (IsXtermWidget(gw)) {
	TScreen *screen = TScreenOf((XtermWidget) gw);
d1137 1
a1137 1
HandleIconify(Widget gw,
d1142 4
a1145 2
    if (IsXtermWidget(gw)) {
	TScreen *screen = TScreenOf((XtermWidget) gw);
d1195 1
a1195 1
		*width = hints.max_width;
d1197 1
a1197 1
		*height = hints.max_height;
d1229 2
a1230 2
			screen->restore_width = vshell_attrs.width;
			screen->restore_height = vshell_attrs.height;
d1239 5
a1243 3
		    root_width -= ((wm_attrs.width - vshell_attrs.width)
				   + (wm_attrs.border_width * 2));
		    root_height -= ((wm_attrs.height - vshell_attrs.height)
d1275 1
a1275 1
HandleMaximize(Widget gw,
d1280 4
a1283 2
    if (IsXtermWidget(gw)) {
	RequestMaximize((XtermWidget) gw, 1);
d1289 1
a1289 1
HandleRestoreSize(Widget gw,
d1294 4
a1297 2
    if (IsXtermWidget(gw)) {
	RequestMaximize((XtermWidget) gw, 0);
d2397 2
a2398 2
	ChangeIconName(buf);
	ChangeTitle(buf);
d2402 1
a2402 1
	ChangeIconName(buf);
d2406 1
a2406 1
	ChangeTitle(buf);
d2410 1
a2410 1
	if (screen->allowWindowOps)
d2464 1
a2464 1
	if (!screen->allowFontOps && xw->misc.shift_fonts) {
d2537 1
a2537 1
	if (screen->allowWindowOps)
d2756 1
a2756 1
    short nparam = 0;
d2896 1
a2896 1
	if ((*cp == 'q') && screen->allowTcapOps) {
d2989 1
a2989 1
ChangeGroup(String attribute, char *value)
d2999 1
a2999 1
    TScreen *screen = TScreenOf(term);
d3008 1
a3008 1
    if (!screen->allowTitleOps)
d3075 1
a3075 1
	Display *dpy = XtDisplay(term);
d3099 1
a3099 1
ChangeIconName(char *name)
d3104 1
a3104 1
    if (resource.zIconBeep && term->screen.zIconBeep_flagged) {
d3112 1
a3112 1
	ChangeGroup(XtNiconName, newname);
d3116 1
a3116 1
	ChangeGroup(XtNiconName, name);
d3120 1
a3120 1
ChangeTitle(char *name)
d3122 1
a3122 1
    ChangeGroup(XtNtitle, name);
d3930 22
@


1.2
log
@xterm-236. Tested by form@@ and simon@@.
@
text
@d1 1
a1 1
/* $XTermId: misc.c,v 1.384 2008/07/27 15:38:05 tom Exp $ */
d555 2
d558 5
a562 6
	Char hexval[2];
	hexval[0] = hexval[1] = 0;
	for (p = (Char *) (*params + 2); (c = *p); p++) {
	    hexval[0] *= 16;
	    if (isupper(c))
		c = tolower(c);
d564 3
a566 3
		hexval[0] += c - '0';
	    else if (c >= 'a' && c <= 'f')
		hexval[0] += c - 'a' + 10;
d570 4
a573 1
	if (c == '\0')
d575 1
d643 1
a643 1
	    int myargc = *nparams + 1;
d645 1
a645 1
	    int n = 0;
d1684 1
a1684 1
static int
d1687 1
a1687 1
    int result;
d1695 1
a1695 1
    result = (numFound >= 1) ? visInfoPtr->colormap_size : 0;
d2338 2
a2339 1
    if (buf == 0)
d2341 1
d2358 2
a2359 1
	ChangeXprop(buf);
d2412 3
a2414 1
	if (buf != 0 && !strcmp(buf, "?")) {
d2485 1
a2485 1
	if (screen->allowWindowOps && (buf != 0))
d2559 1
a2559 1
	    key = (key * 10) + (*cp++ - '0');
d2564 1
a2564 1
		str[len++] = (hi << 4) | lo;
d2826 5
a2830 5
	    unparseputc1(xw, ANSI_DCS);
	    unparseputc(xw, okay ? '1' : '0');
	    unparseputc(xw, '$');
	    unparseputc(xw, 'r');
	    if (okay)
d2832 5
a2836 2
	    unparseputs(xw, cp);
	    unparseputc1(xw, ANSI_ST);
d2844 1
a2844 1
	if (*cp == 'q') {
d2908 12
a2919 10
	parse_ansi_params(&params, &cp);
	switch (params.a_final) {
	case '|':		/* DECUDK */
	    if (params.a_param[0] == 0)
		reset_decudk();
	    parse_decudk(cp);
	    break;
	case '{':		/* DECDLD (no '}' case though) */
	    parse_decdld(&params, cp);
	    break;
d3369 1
a3369 1
#define ENV_HUNK(n)	((((n) + 1) | 31) + 1)
@


1.1
log
@Initial revision
@
text
@d1 1
a1 3
/* $XTermId: misc.c,v 1.314 2006/08/03 23:54:32 tom Exp $ */

/* $XFree86: xc/programs/xterm/misc.c,v 3.107 2006/06/19 00:36:51 dickey Exp $ */
d5 1
a5 1
 * Copyright 1999-2005,2006 by Thomas E. Dickey
d66 1
d69 1
d91 1
d112 1
a112 1
		  (event.xcrossing.window == XtWindow(XtParent(term)) || \
d118 135
a252 1
		   (event.xcrossing.window == XtWindow(XtParent(term))))
d255 15
a269 7
static Bool ChangeColorsRequest(XtermWidget xw, int start, char
				*names, int final);
static void DoSpecialEnterNotify(XEnterWindowEvent * ev);
static void DoSpecialLeaveNotify(XEnterWindowEvent * ev);
static void selectwindow(TScreen * screen, int flag);
static void unselectwindow(TScreen * screen, int flag);
static void Sleep(int msec);
d274 1
a274 1
    TScreen *screen = &term->screen;
d288 76
d366 2
a369 1
    TScreen *screen = &term->screen;
d375 1
a375 1
	FlushScroll(term);
d404 1
a404 1
	if (waitingForTrackInfo) {
d415 5
a419 5
	if (OUR_EVENT(event, EnterNotify))
	    DoSpecialEnterNotify(&event.xcrossing);
	else if (OUR_EVENT(event, LeaveNotify))
	    DoSpecialLeaveNotify(&event.xcrossing);
	else if ((screen->send_mouse_pos == ANY_EVENT_MOUSE
d421 1
a421 1
		  || screen->send_mouse_pos == DEC_LOCATOR
d423 4
a426 4
		 )
		 && event.xany.type == MotionNotify
		 && event.xcrossing.window == XtWindow(term)) {
	    SendMousePosition(term, &event);
d435 23
a457 1
	     (event.xany.type != ButtonRelease)))
d459 1
d463 32
d500 1
a500 1
    TScreen *screen = &term->screen;
d505 3
a507 4
    if (c == (Cursor) 0)
	return (c);

    recolor_cursor(screen, c, fg, bg);
d520 1
a520 1
    if (w == CURRENT_EMU(&(term->screen)))
d534 1
a534 1
    if (w == CURRENT_EMU(&(term->screen)))
d547 1
a547 1
    if (w != CURRENT_EMU(&(term->screen)))
d576 89
d692 1
a692 1
	    fillPtyData(&term->screen, VTbuffer, value, (int) strlen(value));
a699 15
static void
DoSpecialEnterNotify(XEnterWindowEvent * ev)
{
    TScreen *screen = &term->screen;

    TRACE(("DoSpecialEnterNotify(%d)\n", screen->select));
#ifdef ACTIVEWINDOWINPUTONLY
    if (ev->window == XtWindow(XtParent(CURRENT_EMU(screen))))
#endif
	if (((ev->detail) != NotifyInferior) &&
	    ev->focus &&
	    !(screen->select & FOCUS))
	    selectwindow(screen, INWINDOW);
}

a710 15
static void
DoSpecialLeaveNotify(XEnterWindowEvent * ev)
{
    TScreen *screen = &term->screen;

    TRACE(("DoSpecialLeaveNotify(%d)\n", screen->select));
#ifdef ACTIVEWINDOWINPUTONLY
    if (ev->window == XtWindow(XtParent(CURRENT_EMU(screen))))
#endif
	if (((ev->detail) != NotifyInferior) &&
	    ev->focus &&
	    !(screen->select & FOCUS))
	    unselectwindow(screen, INWINDOW);
}

d730 2
a731 1
    TScreen *screen = &term->screen;
d733 2
a734 2
    TRACE(("HandleFocusChange type=%d, mode=%d, detail=%d\n",
	   event->type,
d738 6
a743 1
    if (event->type == FocusIn) {
d760 1
d762 5
d768 2
a769 2
	 * XGrabKeyboard() will generate FocusOut/NotifyGrab event that we want
	 * to ignore.
d779 1
a779 1
	    ReverseVideo(term);
d786 4
a789 2
static void
selectwindow(TScreen * screen, int flag)
d791 3
a793 1
    TRACE(("selectwindow(%d) flag=%d\n", screen->select, flag));
d795 2
a796 19
#if OPT_TEK4014
    if (screen->TekEmu) {
	if (!Ttoggled)
	    TCursorToggle(TOGGLE);
	screen->select |= flag;
	if (!Ttoggled)
	    TCursorToggle(TOGGLE);
	return;
    } else
#endif
    {
	if (screen->xic)
	    XSetICFocus(screen->xic);

	if (screen->cursor_state && CursorMoved(screen))
	    HideCursor();
	screen->select |= flag;
	if (screen->cursor_state)
	    ShowCursor();
a798 1
}
d800 1
a800 4
static void
unselectwindow(TScreen * screen, int flag)
{
    TRACE(("unselectwindow(%d) flag=%d\n", screen->select, flag));
d802 1
a802 38
    if (screen->always_highlight)
	return;

#if OPT_TEK4014
    if (screen->TekEmu) {
	if (!Ttoggled)
	    TCursorToggle(TOGGLE);
	screen->select &= ~flag;
	if (!Ttoggled)
	    TCursorToggle(TOGGLE);
    } else
#endif
    {
	if (screen->xic)
	    XUnsetICFocus(screen->xic);
	screen->select &= ~flag;
	if (screen->cursor_state && CursorMoved(screen))
	    HideCursor();
	if (screen->cursor_state)
	    ShowCursor();
    }
}

static long lastBellTime;	/* in milliseconds */

void
Bell(Atom which GCC_UNUSED, int percent)
{
    TScreen *screen = &term->screen;
    struct timeval curtime;
    long now_msecs;

    TRACE(("BELL %ld %d%%\n", (long) which, percent));
    if (!XtIsRealized((Widget) term)) {
	return;
    }

    /* has enough time gone by that we are allowed to ring
d838 1
a838 1
	Widget w = CURRENT_EMU(screen);
d859 1
a859 1
    TScreen *screen = &term->screen;
d871 5
a875 4
	if (screen->TekEmu) {
	    flashWindow(screen, TWindow(screen), visualGC,
			TFullWidth(screen),
			TFullHeight(screen));
d894 1
a894 1
    TScreen *screen = &term->screen;
d990 1
a994 1
    unsigned i;
d999 1
d1018 10
a1027 1
    while ((expansion = dabbrev_prev_word(&x, &y, screen))) {
d1040 1
a1040 3
    for (i = 0; i < del_cnt; i++) {	/* delete previous expansion */
	copybuffer[i] = screen->dabbrev_erase_char;
    }
d1052 1
d1063 6
a1068 4
    XtermWidget w = (XtermWidget) gw;
    TScreen *screen = &w->screen;
    if (!dabbrev_expand(screen))
	Bell(XkbBI_TerminalBell, 0);
d1081 1
a1081 1
	TScreen *screen = &((XtermWidget) gw)->screen;
d1094 1
a1094 1
	TScreen *screen = &((XtermWidget) gw)->screen;
d1248 1
a1248 1
    TScreen *screen = &term->screen;
d1251 2
d1272 3
a1274 2
    if (TWindow(screen) && screen->Tshow) {
	event.window = TWindow(screen);
d1383 2
a1384 2
	   uid, geteuid(),
	   gid, getegid(),
d1482 1
a1482 1
    TScreen *screen = &term->screen;
d1532 1
a1532 1
			       hostname, yyyy_mm_dd_hh_mm_ss, getpid());
d1577 1
a1577 1
	    if ((((cp = getenv("SHELL")) == NULL || *cp == 0)
d1673 1
a1673 1
    unparseputc1(xw, OSC);
a1678 7
/*
* Find closest color for "def" in "cmap".
* Set "def" to the resulting color.
* Based on Monish Shah's "find_closest_color()" for Vim 6.0,
* modified with ideas from David Tong's "noflash" library.
* Return False if not able to find or allocate a color.
*/
d1680 1
a1680 1
find_closest_color(Display * display, Colormap cmap, XColor * def)
d1682 2
a1683 3
    double tmp, distance, closestDistance;
    int closest, numFound;
    XColor *colortable;
a1684 4
    char *found;
    unsigned i;
    unsigned cmap_size;
    unsigned attempts;
d1690 1
a1690 4
    if (numFound < 1) {
	/* FindClosestColor couldn't lookup visual */
	return False;
    }
a1691 1
    cmap_size = visInfoPtr->colormap_size;
d1693 40
a1732 9
    colortable = TypeMallocN(XColor, cmap_size);
    if (!colortable) {
	return False;		/* out of memory */
    }
    found = TypeCallocN(char, cmap_size);
    if (!found) {
	free(colortable);
	return False;		/* out of memory */
    }
d1734 4
a1737 4
    for (i = 0; i < cmap_size; i++) {
	colortable[i].pixel = (unsigned long) i;
    }
    XQueryColors(display, cmap, colortable, (int) cmap_size);
a1738 12
    /*
     * Find the color that best approximates the desired one, then
     * try to allocate that color.  If that fails, it must mean that
     * the color was read-write (so we can't use it, since its owner
     * might change it) or else it was already freed.  Try again,
     * over and over again, until something succeeds.
     */
    for (attempts = 0; attempts < cmap_size; attempts++) {
	closestDistance = 1e30;
	closest = 0;
	for (i = 0; i < cmap_size; i++) {
	    if (!found[closest]) {
d1740 2
a1741 3
		 * Use Euclidean distance in RGB space, weighted by Y (of YIQ)
		 * as the objective function;  this accounts for differences
		 * in the color sensitivity of the eye.
d1743 41
a1783 9
		tmp = .30 * (((int) def->red) - (int) colortable[i].red);
		distance = tmp * tmp;
		tmp = .61 * (((int) def->green) - (int) colortable[i].green);
		distance += tmp * tmp;
		tmp = .11 * (((int) def->blue) - (int) colortable[i].blue);
		distance += tmp * tmp;
		if (distance < closestDistance) {
		    closest = i;
		    closestDistance = distance;
d1785 1
d1787 1
a1788 13
	if (XAllocColor(display, cmap, &colortable[closest]) != 0) {
	    *def = colortable[closest];
	    break;
	}
	found[closest] = True;	/* Don't look at this entry again */
    }

    free(colortable);
    free(found);
    if (attempts < cmap_size) {
	return True;		/* Got a closest matching color */
    } else {
	return False;		/* Couldn't allocate a near match */
d1790 1
d1793 10
a1802 1
static Bool
d1807 1
d1815 11
a1825 3
	SET_COLOR_RES(res, def.pixel);
	TRACE(("AllocateAnsiColor[%d] %s (pixel %#lx)\n",
	       (res - screen->Acolors), spec, def.pixel));
d1827 3
a1829 1
	res->mode = True;
d1831 4
a1834 1
	return (True);
d1836 1
a1836 2
    TRACE(("AllocateAnsiColor %s (failed)\n", spec));
    return (False);
d1854 1
a1854 1
	    if (!AllocateAnsiColor(term, res, res->resource)) {
d1878 2
a1879 1
    int r = False;
d1901 3
a1903 1
	    if (!AllocateAnsiColor(xw, &(xw->screen.Acolors[color]), name))
d1905 3
a1910 1
	    r = True;
d1913 4
a1916 3
    if (r)
	ChangeAnsiColors(xw);
    return (r);
d1955 287
a2241 2
    if (*buf == ';') {
	*buf++ = '\0';
d2243 17
a2259 11
	if (*base == '\0')
	    base = "s0";
	if ((select_args = TypeCallocN(String, 1 + strlen(base))) == 0)
	    return;
	while (*base != '\0') {
	    for (j = 0; j < XtNumber(table); ++j) {
		if (*base == table[j].given) {
		    used[n] = *base;
		    select_args[n++] = table[j].result;
		    TRACE(("atom[%d] %s\n", n, table[j].result));
		    break;
a2261 1
	    ++base;
a2262 7
	used[n] = 0;

	if (!strcmp(buf, "?")) {
	    TRACE(("Getting selection\n"));
	    unparseputc1(xw, OSC);
	    unparseputs(xw, "52");
	    unparseputc(xw, ';');
d2264 3
a2266 15
	    unparseputs(xw, used);
	    unparseputc(xw, ';');

	    /* Tell xtermGetSelection data is base64 encoded */
	    screen->base64_paste = n;
	    screen->base64_final = final;

	    /* terminator will be written in this call */
	    xtermGetSelection((Widget) xw, 0, select_args, n, NULL);
	} else {
	    TRACE(("Setting selection with %s\n", buf));
	    ClearSelectionBuffer(screen);
	    while (*buf != '\0')
		AppendToSelectionBuffer(screen, CharOf(*buf++));
	    CompleteSelection(xw, select_args, n);
d2268 1
d2270 1
a2271 1
#endif /* OPT_PASTE64 */
d2318 1
a2318 1
	    if (ansi_table[CharOf(*cp)] != CASE_PRINT) {
d2323 1
a2323 8
#if OPT_WIDE_CHARS
		    /*
		     * If we're running with UTF-8, it is possible for title
		     * strings to contain "nonprinting" text.
		     */
		    if (xtermEnvUTF8())
#endif
			break;
d2338 2
a2339 2
	Changename(buf);
	Changetitle(buf);
d2343 1
a2343 1
	Changename(buf);
d2347 1
a2347 1
	Changetitle(buf);
d2358 5
a2362 5
    case 10 + TEXT_FG:
    case 10 + TEXT_BG:
    case 10 + TEXT_CURSOR:
    case 10 + MOUSE_FG:
    case 10 + MOUSE_BG:
d2364 1
a2364 1
    case 10 + HIGHLIGHT_BG:
d2367 3
a2369 3
    case 10 + TEK_FG:
    case 10 + TEK_BG:
    case 10 + TEK_CURSOR:
d2372 1
a2372 1
	    ChangeColorsRequest(xw, mode - 10, buf, final);
d2403 1
d2407 1
a2407 1
	    unparseputc1(xw, OSC);
d2417 1
a2427 1
		int num = screen->menu_font_number;
d2450 2
a2451 2
		if (rel != 0)
		    num = lookupRelativeFontSize(screen,
d2454 1
d2461 2
d2465 1
a2465 1
	    SetVTFont(xw, fontMenu_fontescape, True, &fonts);
d2467 1
d2634 1
a2634 1
	if (ch >= 0x20 && ch <= 0x2f) {
d2816 1
a2816 1
	    unparseputc1(xw, DCS);
d2823 1
a2823 1
	    unparseputc1(xw, ST);
d2825 1
a2825 1
	    unparseputc(xw, CAN);
d2838 1
a2838 1
	    unparseputc1(xw, DCS);
d2858 1
d2863 11
a2873 1
		    } else {
d2890 1
a2890 1
	    unparseputc1(xw, ST);
d2927 2
d2930 1
a2930 1
    char *original = (value != 0) ? value : "";
d2932 2
a2933 2
    TScreen *screen = &term->screen;
    Widget w = CURRENT_EMU(screen);
d2936 2
d2941 2
a2942 1
    (void) screen;
d2950 7
d2991 1
a2991 1
    if (sameName) {
d3002 1
d3010 4
a3013 3
	char *propname = (!strcmp(attribute, XtNtitle)
			  ? "_NET_WM_NAME"
			  : "_NET_WM_ICON_NAME");
d3015 1
a3015 1
	    if (screen->utf8_title) {
d3017 1
d3032 1
a3032 1
Changename(char *name)
d3037 1
a3037 1
    if (zIconBeep && zIconBeep_flagged) {
d3040 1
a3040 1
	    fprintf(stderr, "malloc failed in Changename\n");
d3053 1
a3053 1
Changetitle(char *name)
a3085 107
static ScrnColors *pOldColors = NULL;

static Bool
GetOldColors(XtermWidget xw)
{
    int i;
    if (pOldColors == NULL) {
	pOldColors = (ScrnColors *) XtMalloc(sizeof(ScrnColors));
	if (pOldColors == NULL) {
	    fprintf(stderr, "allocation failure in GetOldColors\n");
	    return (False);
	}
	pOldColors->which = 0;
	for (i = 0; i < NCOLORS; i++) {
	    pOldColors->colors[i] = 0;
	    pOldColors->names[i] = NULL;
	}
	GetColors(xw, pOldColors);
    }
    return (True);
}

static int
oppositeColor(int n)
{
    switch (n) {
    case TEXT_FG:
	n = TEXT_BG;
	break;
    case TEXT_BG:
	n = TEXT_FG;
	break;
    case MOUSE_FG:
	n = MOUSE_BG;
	break;
    case MOUSE_BG:
	n = MOUSE_FG;
	break;
#if OPT_TEK4014
    case TEK_FG:
	n = TEK_BG;
	break;
    case TEK_BG:
	n = TEK_FG;
	break;
#endif
    default:
	break;
    }
    return n;
}

static void
ReportColorRequest(XtermWidget xw, int ndx, int final)
{
    XColor color;
    Colormap cmap = xw->core.colormap;
    char buffer[80];

    /*
     * ChangeColorsRequest() has "always" chosen the opposite color when
     * reverse-video is set.  Report this as the original color index, but
     * reporting the opposite color which would be used.
     */
    int i = (xw->misc.re_verse) ? oppositeColor(ndx) : ndx;

    GetOldColors(xw);
    color.pixel = pOldColors->colors[ndx];
    XQueryColor(xw->screen.display, cmap, &color);
    sprintf(buffer, "%d;rgb:%04x/%04x/%04x", i + 10,
	    color.red,
	    color.green,
	    color.blue);
    TRACE(("ReportColors %d: %#lx as %s\n", ndx, pOldColors->colors[ndx], buffer));
    unparseputc1(xw, OSC);
    unparseputs(xw, buffer);
    unparseputc1(xw, final);
    unparse_end(xw);
}

static Bool
UpdateOldColors(XtermWidget xw GCC_UNUSED, ScrnColors * pNew)
{
    int i;

    /* if we were going to free old colors, this would be the place to
     * do it.   I've decided not to (for now), because it seems likely
     * that we'd have a small set of colors we use over and over, and that
     * we could save some overhead this way.   The only case in which this
     * (clearly) fails is if someone is trying a boatload of colors, in
     * which case they can restart xterm
     */
    for (i = 0; i < NCOLORS; i++) {
	if (COLOR_DEFINED(pNew, i)) {
	    if (pOldColors->names[i] != NULL) {
		XtFree(pOldColors->names[i]);
		pOldColors->names[i] = NULL;
	    }
	    if (pNew->names[i]) {
		pOldColors->names[i] = pNew->names[i];
	    }
	    pOldColors->colors[i] = pNew->colors[i];
	}
    }
    return (True);
}

a3150 56

static Bool
ChangeColorsRequest(XtermWidget xw,
		    int start,
		    char *names,
		    int final)
{
    char *thisName;
    ScrnColors newColors;
    int i, ndx;

    TRACE(("ChangeColorsRequest start=%d, names='%s'\n", start, names));

    if ((pOldColors == NULL)
	&& (!GetOldColors(xw))) {
	return (False);
    }
    newColors.which = 0;
    for (i = 0; i < NCOLORS; i++) {
	newColors.names[i] = NULL;
    }
    for (i = start; i < NCOLORS; i++) {
	if (xw->misc.re_verse)
	    ndx = oppositeColor(i);
	else
	    ndx = i;
	if ((names == NULL) || (names[0] == '\0')) {
	    newColors.names[ndx] = NULL;
	} else {
	    if (names[0] == ';')
		thisName = NULL;
	    else
		thisName = names;
	    names = strchr(names, ';');
	    if (names != NULL) {
		*names = '\0';
		names++;
	    }
	    if (thisName != 0 && !strcmp(thisName, "?"))
		ReportColorRequest(xw, ndx, final);
	    else if (!pOldColors->names[ndx]
		     || (thisName
			 && strcmp(thisName, pOldColors->names[ndx]))) {
		AllocateTermColor(xw, &newColors, ndx, thisName);
	    }
	}
    }

    if (newColors.which == 0)
	return (True);

    ChangeColors(xw, &newColors);
    UpdateOldColors(xw, &newColors);
    return (True);
}

a3152 1
#ifndef DEBUG
a3153 1
#endif
d3167 2
a3168 2
char *
SysErrorMsg(int n)
d3171 1
a3171 1
    char *s = strerror(n);
d3175 2
a3176 2
void
SysError(int i)
d3178 49
a3226 63
    static const char *table[] =
    {
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
	,"main: ioctl() failed on FIONBIO"	/* 11 */
	,"main: ioctl() failed on F_GETFL"	/* 12 */
	,"main: ioctl() failed on F_SETFL"	/* 13 */
	,"spawn: open() failed on /dev/tty"	/* 14 */
	,"spawn: ioctl() failed on TIOCGETP"	/* 15 */
	,0
	,"spawn: ptsname() failed"	/* 17 */
	,"spawn: open() failed on ptsname"	/* 18 */
	,"spawn: ioctl() failed on I_PUSH/\"ptem\""	/* 19 */
	,"spawn: ioctl() failed on I_PUSH/\"consem\""	/* 20 */
	,"spawn: ioctl() failed on I_PUSH/\"ldterm\""	/* 21 */
	,"spawn: ioctl() failed on I_PUSH/\"ttcompat\""		/* 22 */
	,"spawn: ioctl() failed on TIOCSETP"	/* 23 */
	,"spawn: ioctl() failed on TIOCSETC"	/* 24 */
	,"spawn: ioctl() failed on TIOCSETD"	/* 25 */
	,"spawn: ioctl() failed on TIOCSLTC"	/* 26 */
	,"spawn: ioctl() failed on TIOCLSET"	/* 27 */
	,"spawn: initgroups() failed"	/* 28 */
	,"spawn: fork() failed"	/* 29 */
	,"spawn: exec() failed"	/* 30 */
	,0
	,"get_pty: not enough ptys"	/* 32 */
	,0
	,"waiting for initial map"	/* 34 */
	,"spawn: setuid() failed"	/* 35 */
	,"spawn: can't initialize window"	/* 36 */
	,0, 0, 0, 0, 0, 0, 0, 0, 0
	,"spawn: ioctl() failed on TIOCKSET"	/* 46 */
	,"spawn: ioctl() failed on TIOCKSETC"	/* 47 */
	,"spawn: realloc of ttydev failed"	/* 48 */
	,"luit: command-line malloc failed"	/* 49 */
	,"in_put: select() failed"	/* 50 */
	,0, 0, 0
	,"VTInit: can't initialize window"	/* 54 */
	,0, 0
	,"HandleKeymapChange: malloc failed"	/* 57 */
	,0, 0
	,"Tinput: select() failed"	/* 60 */
	,0, 0, 0
	,"TekInit: can't initialize window"	/* 64 */
	,0, 0, 0, 0, 0, 0
	,"SaltTextAway: malloc() failed"	/* 71 */
	,0, 0, 0, 0, 0, 0, 0, 0
	,"StartLog: exec() failed"	/* 80 */
	,0, 0
	,"xerror: XError event"	/* 83 */
	,"xioerror: X I/O error"	/* 84 */
	,0, 0, 0, 0, 0
	,"Alloc: calloc() failed on base"	/* 90 */
	,"Alloc: calloc() failed on rows"	/* 91 */
	,"ScreenResize: realloc() failed on alt base"	/* 92 */
	,0, 0, 0
	,"ScreenResize: malloc() or realloc() failed"	/* 96 */
	,0, 0, 0, 0, 0
	,"ScrnPointers: malloc/realloc() failed"	/* 102 */
	,0, 0, 0, 0, 0, 0, 0
	,"ScrollBarOn: realloc() failed on base"	/* 110 */
	,"ScrollBarOn: realloc() failed on rows"	/* 111 */
	,0, 0, 0, 0, 0, 0, 0, 0, 0
	,"my_memmove: malloc/realloc failed"	/* 121 */
d3228 1
a3228 1
    int oerrno;
d3230 8
a3237 5
    oerrno = errno;
    fprintf(stderr, "%s: Error %d, errno %d: ", xterm_name, i, oerrno);
    fprintf(stderr, "%s\n", SysErrorMsg(oerrno));
    if ((Cardinal) i < XtNumber(table) && table[i] != 0) {
	fprintf(stderr, "Reason: %s\n", table[i]);
d3239 1
a3239 1
    Cleanup(i);
d3242 2
a3243 2
static void
Sleep(int msec)
d3245 5
a3249 1
    static struct timeval select_timeout;
d3251 1
a3251 3
    select_timeout.tv_sec = 0;
    select_timeout.tv_usec = msec * 1000;
    select(0, 0, 0, 0, &select_timeout);
d3261 1
a3261 1
    TScreen *screen = &term->screen;
d3273 1
a3273 1
	need_cleanup = FALSE;
d3311 2
a3312 2
	if ((s = getenv("PATH")) != 0) {
	    if ((tmp = TypeMallocN(char, strlen(leaf) + strlen(s) + 1)) != 0) {
d3354 20
d3385 1
d3388 1
d3390 1
a3390 1
	TRACE(("xtermSetenv(var=%s, value=%s)\n", var, value));
d3392 4
a3395 7
	while (environ[envindex] != NULL) {
	    if (strncmp(environ[envindex], var, len) == 0) {
		/* found it */
		environ[envindex] = CastMallocN(char, len + strlen(value));
		strcpy(environ[envindex], var);
		strcat(environ[envindex], value);
		return;
d3400 20
a3419 1
	TRACE(("...expanding env to %d\n", envindex + 1));
d3421 6
a3426 4
	environ[envindex] = CastMallocN(char, len + strlen(value));
	(void) strcpy(environ[envindex], var);
	strcat(environ[envindex], value);
	environ[++envindex] = NULL;
a3457 2
    char *ptr;

d3463 1
a3463 1
    if ((ptr = getenv("DISPLAY")) == 0 || *x_strtrim(ptr) == '\0') {
d3495 1
a3495 1
    TScreen *screen = &term->screen;
d3532 1
a3532 1
    TScreen *screen = &term->screen;
a3533 1
    TRACE(("set_tek_visibility(%d)\n", on));
d3535 1
a3535 1
	if (!screen->Tshow && (tekWidget || TekInit())) {
d3550 1
a3550 1
	    screen->Tshow = True;
d3553 1
a3553 1
	if (screen->Tshow && tekWidget) {
d3557 1
a3557 1
	    screen->Tshow = False;
d3571 2
a3572 4
    TScreen *screen = &term->screen;

    if (screen->TekEmu) {
	FlushLog(screen);
d3581 3
a3583 5
    TScreen *screen = &term->screen;

    if (!screen->TekEmu) {
	FlushLog(screen);
	screen->TekEmu = True;
d3593 2
a3594 2
	if (TekRefresh)
	    dorefresh();
a3603 2
    TScreen *screen = &term->screen;

d3605 1
a3605 1
    if (!screen->TekEmu)
a3611 2
    TScreen *screen = &term->screen;

d3613 2
a3614 2
    TekRefresh = (TekLink *) 0;
    if (screen->TekEmu)
d3682 4
a3685 1
    } else if (options != 0 && descs != 0)
d3687 1
d3766 1
a3766 1
 * Report the locale that xterm was started in.
d3774 3
a3776 4
	if ((result = getenv("LC_ALL")) == 0 || *result == '\0')
	    if ((result = getenv("LC_CTYPE")) == 0 || *result == '\0')
		if ((result = getenv("LANG")) == 0 || *result == '\0')
		    result = "";
d3792 1
a3792 1
	if (*locale == 0 || !strcmp(locale, "C") || !strcmp(locale, "POSIX")) {
@


1.1.1.1
log
@Importing xterm 216
@
text
@@


1.1.1.2
log
@import xterm 225
@
text
@d1 1
a1 1
/* $XTermId: misc.c,v 1.359 2007/03/21 22:13:32 tom Exp $ */
d7 1
a7 1
 * Copyright 1999-2006,2007 by Thomas E. Dickey
a90 1
#include <xtermcap.h>
d120 7
a126 142
#if OPT_EXEC_XTERM
/* Like readlink(2), but returns a malloc()ed buffer, or NULL on
   error; adapted from libc docs */
static char *
Readlink(const char *filename)
{
    char *buf = NULL;
    int size = 100;
    int n;

    for (;;) {
	buf = realloc(buf, size);
	memset(buf, 0, size);

	n = readlink(filename, buf, size);
	if (n < 0) {
	    free(buf);
	    return NULL;
	}

	if (n < size) {
	    return buf;
	}

	size *= 2;
    }
}
#endif /* OPT_EXEC_XTERM */

static void
Sleep(int msec)
{
    static struct timeval select_timeout;

    select_timeout.tv_sec = 0;
    select_timeout.tv_usec = msec * 1000;
    select(0, 0, 0, 0, &select_timeout);
}

static void
selectwindow(TScreen * screen, int flag)
{
    TRACE(("selectwindow(%d) flag=%d\n", screen->select, flag));

#if OPT_TEK4014
    if (TEK4014_ACTIVE(term)) {
	if (!Ttoggled)
	    TCursorToggle(tekWidget, TOGGLE);
	screen->select |= flag;
	if (!Ttoggled)
	    TCursorToggle(tekWidget, TOGGLE);
    } else
#endif
    {
	if (screen->xic)
	    XSetICFocus(screen->xic);

	if (screen->cursor_state && CursorMoved(screen))
	    HideCursor();
	screen->select |= flag;
	if (screen->cursor_state)
	    ShowCursor();
    }
}

static void
unselectwindow(TScreen * screen, int flag)
{
    TRACE(("unselectwindow(%d) flag=%d\n", screen->select, flag));

    if (!screen->always_highlight) {
#if OPT_TEK4014
	if (TEK4014_ACTIVE(term)) {
	    if (!Ttoggled)
		TCursorToggle(tekWidget, TOGGLE);
	    screen->select &= ~flag;
	    if (!Ttoggled)
		TCursorToggle(tekWidget, TOGGLE);
	} else
#endif
	{
	    if (screen->xic)
		XUnsetICFocus(screen->xic);

	    screen->select &= ~flag;
	    if (screen->cursor_state && CursorMoved(screen))
		HideCursor();
	    if (screen->cursor_state)
		ShowCursor();
	}
    }
}

static void
DoSpecialEnterNotify(XtermWidget xw, XEnterWindowEvent * ev)
{
    TScreen *screen = TScreenOf(xw);

    TRACE(("DoSpecialEnterNotify(%d)\n", screen->select));
#ifdef ACTIVEWINDOWINPUTONLY
    if (ev->window == XtWindow(XtParent(CURRENT_EMU())))
#endif
	if (((ev->detail) != NotifyInferior) &&
	    ev->focus &&
	    !(screen->select & FOCUS))
	    selectwindow(screen, INWINDOW);
}

static void
DoSpecialLeaveNotify(XtermWidget xw, XEnterWindowEvent * ev)
{
    TScreen *screen = TScreenOf(xw);

    TRACE(("DoSpecialLeaveNotify(%d)\n", screen->select));
#ifdef ACTIVEWINDOWINPUTONLY
    if (ev->window == XtWindow(XtParent(CURRENT_EMU())))
#endif
	if (((ev->detail) != NotifyInferior) &&
	    ev->focus &&
	    !(screen->select & FOCUS))
	    unselectwindow(screen, INWINDOW);
}

#ifndef XUrgencyHint
#define XUrgencyHint (1L << 8)	/* X11R5 does not define */
#endif

static void
setXUrgency(TScreen * screen, Boolean enable)
{
    if (screen->bellIsUrgent) {
	XWMHints *h = XGetWMHints(screen->display, VShellWindow);
	if (h != 0) {
	    if (enable) {
		h->flags |= XUrgencyHint;
	    } else {
		h->flags &= ~XUrgencyHint;
	    }
	    XSetWMHints(screen->display, VShellWindow, h);
	}
    }
}
d131 1
a131 1
    TScreen *screen = TScreenOf(term);
a146 2
    XtermWidget xw = term;
    TScreen *screen = TScreenOf(xw);
d149 1
d155 1
a155 1
	FlushScroll(xw);
d184 1
a184 1
	if (screen->waitingForTrackInfo) {
d195 5
a199 5
	if (OUR_EVENT(event, EnterNotify)) {
	    DoSpecialEnterNotify(xw, &event.xcrossing);
	} else if (OUR_EVENT(event, LeaveNotify)) {
	    DoSpecialLeaveNotify(xw, &event.xcrossing);
	} else if ((screen->send_mouse_pos == ANY_EVENT_MOUSE
d201 1
a201 1
		    || screen->send_mouse_pos == DEC_LOCATOR
d203 4
a206 4
		   )
		   && event.xany.type == MotionNotify
		   && event.xcrossing.window == XtWindow(xw)) {
	    SendMousePosition(xw, &event);
d225 1
a225 1
    TScreen *screen = TScreenOf(term);
d230 4
a233 3
    if (c != None) {
	recolor_cursor(screen, c, fg, bg);
    }
d246 1
a246 1
    if (w == CURRENT_EMU())
d260 1
a260 1
    if (w == CURRENT_EMU())
d273 1
a273 1
    if (w != CURRENT_EMU())
a301 93
#if OPT_EXEC_XTERM

#ifndef PROCFS_ROOT
#define PROCFS_ROOT "/proc"
#endif

/* ARGSUSED */
void
HandleSpawnTerminal(Widget w GCC_UNUSED,
		    XEvent * event GCC_UNUSED,
		    String * params,
		    Cardinal *nparams)
{
    TScreen *screen = &term->screen;
    char *child_cwd = NULL;
    char *child_exe;
    pid_t pid;

    /*
     * Try to find the actual program which is running in the child process. 
     * This works for Linux.  If we cannot find the program, fall back to the
     * xterm program (which is usually adequate).  Give up if we are given only
     * a relative path to xterm, since that would not always match $PATH.
     */
    child_exe = Readlink(PROCFS_ROOT "/self/exe");
    if (!child_exe) {
	if (strncmp(ProgramName, "./", 2)
	    && strncmp(ProgramName, "../", 3)) {
	    child_exe = xtermFindShell(ProgramName, True);
	} else {
	    fprintf(stderr, "Cannot exec-xterm given %s\n", ProgramName);
	}
	if (child_exe == 0)
	    return;
    }

    /*
     * Determine the current working directory of the child so that we can
     * spawn a new terminal in the same directory.
     *
     * If we cannot get the CWD of the child, just use our own.
     */
    if (screen->pid) {
	char child_cwd_link[sizeof(PROCFS_ROOT) + 80];
	sprintf(child_cwd_link, PROCFS_ROOT "/%lu/cwd", (unsigned long) screen->pid);
	child_cwd = Readlink(child_cwd_link);
    }

    /* The reaper will take care of cleaning up the child */
    pid = fork();
    if (pid == -1) {
	fprintf(stderr, "Could not fork: %s\n", SysErrorMsg(errno));
    } else if (!pid) {
	/* We are the child */
	if (child_cwd) {
	    chdir(child_cwd);	/* We don't care if this fails */
	}

	if (setuid(screen->uid) == -1
	    || setgid(screen->gid) == -1) {
	    fprintf(stderr, "Cannot reset uid/gid\n");
	} else {
	    if (nparams != 0) {
		int myargc = *nparams + 1;
		char **myargv = TypeMallocN(char *, myargc + 1);
		if (myargv != 0) {
		    int n = 0;
		    myargv[n++] = child_exe;
		    while (n <= myargc) {
			myargv[n] = params[n - 1];
			++n;
		    }
		    myargv[n] = 0;
		    execv(child_exe, myargv);
		}
	    } else {
		execl(child_exe, child_exe, NULL);
	    }

	    /* If we get here, we've failed */
	    fprintf(stderr, "exec of '%s': %s\n", child_exe, SysErrorMsg(errno));
	}
	_exit(0);
    } else {
	/* We are the parent; clean up */
	if (child_cwd)
	    free(child_cwd);
	if (child_exe)
	    free(child_exe);
    }
}
#endif /* OPT_EXEC_XTERM */

d329 1
a329 1
	    fillPtyData(TScreenOf(term), VTbuffer, value, (int) strlen(value));
d337 15
d363 15
d397 1
a397 2
    XtermWidget xw = term;
    TScreen *screen = TScreenOf(xw);
d399 2
a400 2
    TRACE(("HandleFocusChange type=%s, mode=%d, detail=%d\n",
	   visibleEventType(event->type),
a404 2
	setXUrgency(screen, False);

a420 1
	SendFocusButton(xw, event);
a421 5
#if OPT_FOCUS_EVENT
	if (event->type == FocusOut) {
	    SendFocusButton(xw, event);
	}
#endif
d423 2
a424 2
	 * XGrabKeyboard() will generate NotifyGrab event that we want to
	 * ignore.
d434 1
a434 1
	    ReverseVideo(xw);
d441 56
d502 1
a502 1
    TScreen *screen = TScreenOf(term);
a510 2
    setXUrgency(screen, True);

d547 1
a547 1
	Widget w = CURRENT_EMU();
d568 1
a568 1
    TScreen *screen = TScreenOf(term);
d580 4
a583 5
	if (TEK4014_ACTIVE(term)) {
	    TekScreen *tekscr = &(tekWidget->screen);
	    flashWindow(screen, TWindow(tekscr), visualGC,
			TFullWidth(tekscr),
			TFullHeight(tekscr));
d602 1
a602 1
    TScreen *screen = TScreenOf(term);
a697 1
    static unsigned int expansions;
d702 1
a706 1
	expansions = 0;
d725 1
a725 10
    for (;;) {
	if (!(expansion = dabbrev_prev_word(&x, &y, screen))) {
	    if (expansions >= 2) {
		expansions = 0;
		x = screen->cur_col;
		y = screen->cur_row + screen->savelines;
		continue;
	    }
	    break;
	}
d738 3
a740 1
    memset(copybuffer, screen->dabbrev_erase_char, del_cnt);	/* delete previous expansion */
a751 1
    expansions++;
d762 4
a765 6
    if (IsXtermWidget(gw)) {
	XtermWidget w = (XtermWidget) gw;
	TScreen *screen = &w->screen;
	if (!dabbrev_expand(screen))
	    Bell(XkbBI_TerminalBell, 0);
    }
d778 1
a778 1
	TScreen *screen = TScreenOf((XtermWidget) gw);
d791 1
a791 1
	TScreen *screen = TScreenOf((XtermWidget) gw);
d945 1
a945 1
    TScreen *screen = TScreenOf(term);
d967 2
a968 3
    if (TEK4014_SHOWN(term)) {
	TekScreen *tekscr = &(tekWidget->screen);
	event.window = TWindow(tekscr);
d1077 2
a1078 2
	   (int) uid, (int) geteuid(),
	   (int) gid, (int) getegid(),
d1176 1
a1176 1
    TScreen *screen = TScreenOf(term);
d1226 1
a1226 1
			       hostname, yyyy_mm_dd_hh_mm_ss, (int) getpid());
d1367 1
a1367 1
    unparseputc1(xw, ANSI_OSC);
d1373 7
d1381 1
a1381 1
getColormapSize(Display * display)
d1383 3
a1385 2
    int result;
    int numFound;
d1387 4
d1396 4
a1399 1
    result = (numFound >= 1) ? visInfoPtr->colormap_size : 0;
d1401 1
d1403 9
a1411 2
    return result;
}
d1413 4
a1416 42
/*
 * Find closest color for "def" in "cmap".
 * Set "def" to the resulting color.
 *
 * Based on Monish Shah's "find_closest_color()" for Vim 6.0,
 * modified with ideas from David Tong's "noflash" library.
 * The code from Vim in turn was derived from FindClosestColor() in Tcl/Tk.
 *
 * These provide some introduction:
 *	http://en.wikipedia.org/wiki/YIQ
 *		for an introduction to YIQ weights.
 *	http://en.wikipedia.org/wiki/Luminance_(video)
 *		for a discussion of luma.
 *	http://en.wikipedia.org/wiki/YUV
 *
 * Return False if not able to find or allocate a color.
 */
static Boolean
find_closest_color(Display * dpy, Colormap cmap, XColor * def)
{
    Boolean result = False;
    XColor *colortable;
    char *tried;
    double diff, thisRGB, bestRGB;
    unsigned attempts;
    unsigned bestInx;
    unsigned cmap_size;
    unsigned i;

    cmap_size = getColormapSize(dpy);
    if (cmap_size != 0) {

	colortable = TypeMallocN(XColor, cmap_size);
	if (colortable != 0) {

	    tried = TypeCallocN(char, cmap_size);
	    if (tried != 0) {

		for (i = 0; i < cmap_size; i++) {
		    colortable[i].pixel = (unsigned long) i;
		}
		XQueryColors(dpy, cmap, colortable, (int) cmap_size);
d1418 12
d1431 3
a1433 2
		 * Try (possibly each entry in the color map) to find the best
		 * approximation to the requested color.
d1435 9
a1443 41
		for (attempts = 0; attempts < cmap_size; attempts++) {
		    Boolean first = True;

		    bestRGB = 0.0;
		    bestInx = 0;
		    for (i = 0; i < cmap_size; i++) {
			if (!tried[bestInx]) {
			    /*
			     * Look for the best match based on luminance. 
			     * Measure this by the least-squares difference of
			     * the weighted R/G/B components from the color map
			     * versus the requested color.  Use the Y (luma)
			     * component of the YIQ color space model for
			     * weights that correspond to the luminance.
			     */
#define AddColorWeight(weight, color) \
			    diff = weight * (int) ((def->color) - colortable[i].color); \
			    thisRGB = diff * diff

			    AddColorWeight(0.30, red);
			    AddColorWeight(0.61, green);
			    AddColorWeight(0.11, blue);

			    if (first || (thisRGB < bestRGB)) {
				first = False;
				bestInx = i;
				bestRGB = thisRGB;
			    }
			}
		    }
		    if (XAllocColor(dpy, cmap, &colortable[bestInx]) != 0) {
			*def = colortable[bestInx];
			result = True;
			break;
		    }
		    /*
		     * It failed - either the color map entry was readonly, or
		     * another client has allocated the entry.  Mark the entry
		     * so we will ignore it
		     */
		    tried[bestInx] = True;
a1444 1
		free(tried);
a1445 1
	    free(colortable);
d1447 13
a1460 1
    return result;
d1463 1
a1463 10
/*
 * Allocate a color for the "ANSI" colors.  That actually includes colors up
 * to 256.
 *
 * Returns
 *	-1 on error
 *	0 on no change
 *	1 if a new color was allocated.
 */
static int
a1467 1
    int result;
d1475 3
a1477 1
	if (
d1479 1
a1479 1
	       res->mode == True &&
d1481 1
a1481 16
	       EQL_COLOR_RES(res, def.pixel)) {
	    result = 0;
	} else {
	    result = 1;
	    SET_COLOR_RES(res, def.pixel);
	    TRACE(("AllocateAnsiColor[%d] %s (pixel %#lx)\n",
		   (res - screen->Acolors), spec, def.pixel));
#if OPT_COLOR_RES
	    if (!res->mode)
		result = 0;
	    res->mode = True;
#endif
	}
    } else {
	TRACE(("AllocateAnsiColor %s (failed)\n", spec));
	result = -1;
d1483 2
a1484 1
    return (result);
d1502 1
a1502 1
	    if (AllocateAnsiColor(term, res, res->resource) < 0) {
d1526 1
a1526 2
    int repaint = False;
    int code;
d1548 1
a1548 3
	    code = AllocateAnsiColor(xw, &(xw->screen.Acolors[color]), name);
	    if (code < 0) {
		/* stop on any error */
a1549 3
	    } else if (code > 0) {
		repaint = True;
	    }
d1553 1
d1556 3
a1558 4
    if (repaint)
	xtermRepaint(xw);

    return (repaint);
d1591 1
a1591 248
    TRACE(("Manipulate selection data\n"));

    while (*buf != ';' && *buf != '\0') {
	++buf;
    }

    if (*buf == ';') {
	*buf++ = '\0';

	if (*base == '\0')
	    base = "s0";
	if ((select_args = TypeCallocN(String, 1 + strlen(base))) == 0)
	    return;
	while (*base != '\0') {
	    for (j = 0; j < XtNumber(table); ++j) {
		if (*base == table[j].given) {
		    used[n] = *base;
		    select_args[n++] = table[j].result;
		    TRACE(("atom[%d] %s\n", n, table[j].result));
		    break;
		}
	    }
	    ++base;
	}
	used[n] = 0;

	if (!strcmp(buf, "?")) {
	    TRACE(("Getting selection\n"));
	    unparseputc1(xw, ANSI_OSC);
	    unparseputs(xw, "52");
	    unparseputc(xw, ';');

	    unparseputs(xw, used);
	    unparseputc(xw, ';');

	    /* Tell xtermGetSelection data is base64 encoded */
	    screen->base64_paste = n;
	    screen->base64_final = final;

	    /* terminator will be written in this call */
	    xtermGetSelection((Widget) xw, 0, select_args, n, NULL);
	} else {
	    TRACE(("Setting selection with %s\n", buf));
	    ClearSelectionBuffer(screen);
	    while (*buf != '\0')
		AppendToSelectionBuffer(screen, CharOf(*buf++));
	    CompleteSelection(xw, select_args, n);
	}
    }
}
#endif /* OPT_PASTE64 */

/***====================================================================***/

static Bool
xtermIsPrintable(TScreen * screen, Char ** bufp, Char * last)
{
    Bool result = False;
    Char *cp = *bufp;
    Char *next = cp;

    (void) screen;
    (void) last;

#if OPT_WIDE_CHARS
    if (xtermEnvUTF8() && screen->utf8_title) {
	PtyData data;
	Boolean controls = True;

	if (decodeUtf8(fakePtyData(&data, cp, last))) {
	    if (data.utf_data != UCS_REPL
		&& (data.utf_data >= 128 ||
		    ansi_table[data.utf_data] == CASE_PRINT)) {
		controls = False;
		next += (data.utf_size - 1);
		result = True;
	    } else {
		result = False;
	    }
	} else {
	    result = False;
	}
    } else
#endif
#if OPT_C1_PRINT
	if (screen->c1_printable
	    && (*cp >= 128 && *cp < 160)) {
	result = True;
    } else
#endif
    if (ansi_table[*cp] == CASE_PRINT) {
	result = True;
    }
    *bufp = next;
    return result;
}

/***====================================================================***/

/*
 * Enum corresponding to the actual OSC codes rather than the internal
 * array indices.
 */
typedef enum {
    OSC_TEXT_FG = 10
    ,OSC_TEXT_BG
    ,OSC_TEXT_CURSOR
    ,OSC_MOUSE_FG
    ,OSC_MOUSE_BG
#if OPT_TEK4014
    ,OSC_TEK_FG = 15
    ,OSC_TEK_BG
#endif
#if OPT_HIGHLIGHT_COLOR
    ,OSC_HIGHLIGHT_BG = 17
#endif
#if OPT_TEK4014
    ,OSC_TEK_CURSOR = 18
#endif
#if OPT_HIGHLIGHT_COLOR
    ,OSC_HIGHLIGHT_FG = 19
#endif
    ,OSC_NCOLORS
} OscTextColors;

static ScrnColors *pOldColors = NULL;

static Bool
GetOldColors(XtermWidget xw)
{
    int i;
    if (pOldColors == NULL) {
	pOldColors = (ScrnColors *) XtMalloc(sizeof(ScrnColors));
	if (pOldColors == NULL) {
	    fprintf(stderr, "allocation failure in GetOldColors\n");
	    return (False);
	}
	pOldColors->which = 0;
	for (i = 0; i < NCOLORS; i++) {
	    pOldColors->colors[i] = 0;
	    pOldColors->names[i] = NULL;
	}
	GetColors(xw, pOldColors);
    }
    return (True);
}

static int
oppositeColor(int n)
{
    switch (n) {
    case TEXT_FG:
	n = TEXT_BG;
	break;
    case TEXT_BG:
	n = TEXT_FG;
	break;
    case MOUSE_FG:
	n = MOUSE_BG;
	break;
    case MOUSE_BG:
	n = MOUSE_FG;
	break;
#if OPT_TEK4014
    case TEK_FG:
	n = TEK_BG;
	break;
    case TEK_BG:
	n = TEK_FG;
	break;
#endif
#if OPT_HIGHLIGHT_COLOR
    case HIGHLIGHT_FG:
	n = HIGHLIGHT_BG;
	break;
    case HIGHLIGHT_BG:
	n = HIGHLIGHT_FG;
	break;
#endif
    default:
	break;
    }
    return n;
}

static void
ReportColorRequest(XtermWidget xw, int ndx, int final)
{
    XColor color;
    Colormap cmap = xw->core.colormap;
    char buffer[80];

    /*
     * ChangeColorsRequest() has "always" chosen the opposite color when
     * reverse-video is set.  Report this as the original color index, but
     * reporting the opposite color which would be used.
     */
    int i = (xw->misc.re_verse) ? oppositeColor(ndx) : ndx;

    GetOldColors(xw);
    color.pixel = pOldColors->colors[ndx];
    XQueryColor(xw->screen.display, cmap, &color);
    sprintf(buffer, "%d;rgb:%04x/%04x/%04x", i + 10,
	    color.red,
	    color.green,
	    color.blue);
    TRACE(("ReportColors %d: %#lx as %s\n", ndx, pOldColors->colors[ndx], buffer));
    unparseputc1(xw, ANSI_OSC);
    unparseputs(xw, buffer);
    unparseputc1(xw, final);
    unparse_end(xw);
}

static Bool
UpdateOldColors(XtermWidget xw GCC_UNUSED, ScrnColors * pNew)
{
    int i;

    /* if we were going to free old colors, this would be the place to
     * do it.   I've decided not to (for now), because it seems likely
     * that we'd have a small set of colors we use over and over, and that
     * we could save some overhead this way.   The only case in which this
     * (clearly) fails is if someone is trying a boatload of colors, in
     * which case they can restart xterm
     */
    for (i = 0; i < NCOLORS; i++) {
	if (COLOR_DEFINED(pNew, i)) {
	    if (pOldColors->names[i] != NULL) {
		XtFree(pOldColors->names[i]);
		pOldColors->names[i] = NULL;
	    }
	    if (pNew->names[i]) {
		pOldColors->names[i] = pNew->names[i];
	    }
	    pOldColors->colors[i] = pNew->colors[i];
	}
    }
    return (True);
}

/*
 * OSC codes are constant, but the indices for the color arrays depend on how
 * xterm is compiled.
 */
static int
OscToColorIndex(OscTextColors mode)
{
    int result = 0;
d1593 2
a1594 20
#define CASE(name) case OSC_##name: result = name; break
    switch (mode) {
	CASE(TEXT_FG);
	CASE(TEXT_BG);
	CASE(TEXT_CURSOR);
	CASE(MOUSE_FG);
	CASE(MOUSE_BG);
#if OPT_TEK4014
	CASE(TEK_FG);
	CASE(TEK_BG);
#endif
#if OPT_HIGHLIGHT_COLOR
	CASE(HIGHLIGHT_BG);
	CASE(HIGHLIGHT_FG);
#endif
#if OPT_TEK4014
	CASE(TEK_CURSOR);
#endif
    case OSC_NCOLORS:
	break;
a1595 2
    return result;
}
d1597 2
a1598 10
static Bool
ChangeColorsRequest(XtermWidget xw,
		    int start,
		    char *names,
		    int final)
{
    Bool result = False;
    char *thisName;
    ScrnColors newColors;
    int i, ndx;
d1600 11
a1610 29
    TRACE(("ChangeColorsRequest start=%d, names='%s'\n", start, names));

    if (GetOldColors(xw)) {
	newColors.which = 0;
	for (i = 0; i < NCOLORS; i++) {
	    newColors.names[i] = NULL;
	}
	for (i = start; i < OSC_NCOLORS; i++) {
	    ndx = OscToColorIndex((OscTextColors) i);
	    if (xw->misc.re_verse)
		ndx = oppositeColor(ndx);

	    if ((names == NULL) || (names[0] == '\0')) {
		newColors.names[ndx] = NULL;
	    } else {
		if (names[0] == ';')
		    thisName = NULL;
		else
		    thisName = names;
		names = strchr(names, ';');
		if (names != NULL) {
		    *names++ = '\0';
		}
		if (thisName != 0 && !strcmp(thisName, "?")) {
		    ReportColorRequest(xw, ndx, final);
		} else if (!pOldColors->names[ndx]
			   || (thisName
			       && strcmp(thisName, pOldColors->names[ndx]))) {
		    AllocateTermColor(xw, &newColors, ndx, thisName);
d1613 1
d1615 14
d1630 8
a1637 3
	if (newColors.which != 0) {
	    ChangeColors(xw, &newColors);
	    UpdateOldColors(xw, &newColors);
a1638 1
	result = True;
a1639 1
    return result;
d1641 1
d1650 1
a1650 1
    Char *cp, *c2;
d1688 1
a1688 2
	    c2 = cp;
	    if (!xtermIsPrintable(screen, &cp, oscbuf + len)) {
d1693 8
a1700 1
		    break;
d1715 2
a1716 2
	ChangeIconName(buf);
	ChangeTitle(buf);
d1720 1
a1720 1
	ChangeIconName(buf);
d1724 1
a1724 1
	ChangeTitle(buf);
d1735 5
a1739 5
    case OSC_TEXT_FG:
    case OSC_TEXT_BG:
    case OSC_TEXT_CURSOR:
    case OSC_MOUSE_FG:
    case OSC_MOUSE_BG:
d1741 1
a1741 1
    case OSC_HIGHLIGHT_BG:
d1744 3
a1746 3
    case OSC_TEK_FG:
    case OSC_TEK_BG:
    case OSC_TEK_CURSOR:
d1749 1
a1749 1
	    ChangeColorsRequest(xw, mode, buf, final);
a1779 1
#if OPT_SHIFT_FONTS
d1783 1
a1783 1
	    unparseputc1(xw, ANSI_OSC);
a1792 1
	    int num = screen->menu_font_number;
d1803 1
d1826 2
a1827 2
		if (rel != 0) {
		    num = lookupRelativeFontSize(xw,
a1829 1
		}
a1835 2
	    } else {
		num = fontMenu_fontescape;
d1838 1
a1838 1
	    SetVTFont(xw, num, True, &fonts);
a1839 1
#endif /* OPT_SHIFT_FONTS */
d2006 1
a2006 1
	if (ch >= ANSI_SPA && ch <= 0x2f) {
d2188 1
a2188 1
	    unparseputc1(xw, ANSI_DCS);
d2195 1
a2195 1
	    unparseputc1(xw, ANSI_ST);
d2197 1
a2197 1
	    unparseputc(xw, ANSI_CAN);
d2210 1
a2210 1
	    unparseputc1(xw, ANSI_DCS);
a2229 1
#if OPT_ISO_COLORS
d2234 1
a2234 3
		    } else
#endif
		    {
d2251 1
a2251 1
	    unparseputc1(xw, ANSI_ST);
d2291 2
a2292 2
    TScreen *screen = TScreenOf(term);
    Widget w = CURRENT_EMU();
a2294 2
    Char *c1 = (Char *) original;
    Char *cp;
a2305 7
    for (cp = c1; *cp != 0; ++cp) {
	Char *c2 = cp;
	if (!xtermIsPrintable(screen, &cp, c1 + limit)) {
	    memset(c2, '?', cp + 1 - c2);
	}
    }

d2340 1
a2340 1
    if (resource.sameName) {
a2350 1
    TRACE(("...value is %s\n", name));
a2357 1

d2362 1
a2362 1
	    if (screen->utf8_title) {	/* FIXME - redundant? */
a2363 1
		TRACE(("...value is %s\n", original));
d2378 1
a2378 1
ChangeIconName(char *name)
d2383 1
a2383 1
    if (resource.zIconBeep && term->screen.zIconBeep_flagged) {
d2386 1
a2386 1
	    fprintf(stderr, "malloc failed in ChangeIconName\n");
d2399 1
a2399 1
ChangeTitle(char *name)
d2432 107
d2604 56
d2662 1
d2664 1
d2764 10
d2781 1
a2781 1
    TScreen *screen = TScreenOf(term);
d2793 1
a2793 1
	need_cleanup = False;
d2977 1
a2977 1
    TScreen *screen = TScreenOf(term);
d3014 2
a3016 1

d3018 1
a3018 1
	if (!TEK4014_SHOWN(term) && (tekWidget || TekInit())) {
d3033 1
a3033 1
	    TEK4014_SHOWN(term) = True;
d3036 1
a3036 1
	if (TEK4014_SHOWN(term) && tekWidget) {
d3040 1
a3040 1
	    TEK4014_SHOWN(term) = False;
d3054 4
a3057 2
    if (TEK4014_ACTIVE(term)) {
	FlushLog(&(term->screen));
d3066 5
a3070 3
    if (!TEK4014_ACTIVE(term)) {
	FlushLog(&(term->screen));
	TEK4014_ACTIVE(term) = True;
d3080 2
a3081 2
	if (tekRefreshList)
	    TekRefresh(tekWidget);
d3091 2
d3094 1
a3094 1
    if (!TEK4014_ACTIVE(term))
d3101 2
d3104 2
a3105 2
    tekRefreshList = (TekLink *) 0;
    if (TEK4014_ACTIVE(term))
d3173 1
a3173 4
	return 0;
    } else if (options == 0 || descs == 0) {
	return 0;
    }
a3174 1

@


1.1.1.3
log
@import xterm 229
@
text
@d1 3
a3 1
/* $XTermId: misc.c,v 1.370 2007/07/22 20:34:04 tom Exp $ */
a69 1
#include <X11/Xlocale.h>
d128 1
a128 1
    unsigned size = 100;
d141 1
a141 1
	if ((unsigned) n < size) {
d249 1
a249 1
setXUrgency(TScreen * screen, Bool enable)
d500 15
a514 8
	    int myargc = *nparams + 1;
	    char **myargv = TypeMallocN(char *, myargc + 1);
	    int n = 0;

	    myargv[n++] = child_exe;

	    while (n < myargc) {
		myargv[n++] = *params++;
a516 3
	    myargv[n] = 0;
	    execv(child_exe, myargv);

d1438 1
a1438 1
	    if ((((cp = x_getenv("SHELL")) == NULL)
d1877 1
d1883 1
d2143 1
a2143 1
    Char *cp;
d2181 1
d2795 1
a2795 2
    if (!screen->allowTitleOps)
	return;
d2806 1
a2806 1
	    memset(c2, '?', (unsigned) (cp + 1 - c2));
d3020 2
a3021 2
const char *
SysErrorMsg(int code)
d3024 1
a3024 1
    char *s = strerror(code);
d3028 2
a3029 2
const char *
SysReasonMsg(int code)
d3031 63
a3093 49
    /* *INDENT-OFF* */
    static const struct {
	int code;
	const char *name;
    } table[] = {
	{ ERROR_FIONBIO,	"main:  ioctl() failed on FIONBIO" },
	{ ERROR_F_GETFL,	"main: ioctl() failed on F_GETFL" },
	{ ERROR_F_SETFL,	"main: ioctl() failed on F_SETFL", },
	{ ERROR_OPDEVTTY,	"spawn: open() failed on /dev/tty", },
	{ ERROR_TIOCGETP,	"spawn: ioctl() failed on TIOCGETP", },
	{ ERROR_PTSNAME,	"spawn: ptsname() failed", },
	{ ERROR_OPPTSNAME,	"spawn: open() failed on ptsname", },
	{ ERROR_PTEM,		"spawn: ioctl() failed on I_PUSH/\"ptem\"" },
	{ ERROR_CONSEM,		"spawn: ioctl() failed on I_PUSH/\"consem\"" },
	{ ERROR_LDTERM,		"spawn: ioctl() failed on I_PUSH/\"ldterm\"" },
	{ ERROR_TTCOMPAT,	"spawn: ioctl() failed on I_PUSH/\"ttcompat\"" },
	{ ERROR_TIOCSETP,	"spawn: ioctl() failed on TIOCSETP" },
	{ ERROR_TIOCSETC,	"spawn: ioctl() failed on TIOCSETC" },
	{ ERROR_TIOCSETD,	"spawn: ioctl() failed on TIOCSETD" },
	{ ERROR_TIOCSLTC,	"spawn: ioctl() failed on TIOCSLTC" },
	{ ERROR_TIOCLSET,	"spawn: ioctl() failed on TIOCLSET" },
	{ ERROR_INIGROUPS,	"spawn: initgroups() failed" },
	{ ERROR_FORK,		"spawn: fork() failed" },
	{ ERROR_EXEC,		"spawn: exec() failed" },
	{ ERROR_PTYS,		"get_pty: not enough ptys" },
	{ ERROR_PTY_EXEC,	"waiting for initial map" },
	{ ERROR_SETUID,		"spawn: setuid() failed" },
	{ ERROR_INIT,		"spawn: can't initialize window" },
	{ ERROR_TIOCKSET,	"spawn: ioctl() failed on TIOCKSET" },
	{ ERROR_TIOCKSETC,	"spawn: ioctl() failed on TIOCKSETC" },
	{ ERROR_SPREALLOC,	"spawn: realloc of ttydev failed" },
	{ ERROR_LUMALLOC,	"luit: command-line malloc failed" },
	{ ERROR_SELECT,		"in_put: select() failed" },
	{ ERROR_VINIT,		"VTInit: can't initialize window" },
	{ ERROR_KMMALLOC1,	"HandleKeymapChange: malloc failed" },
	{ ERROR_TSELECT,	"Tinput: select() failed" },
	{ ERROR_TINIT,		"TekInit: can't initialize window" },
	{ ERROR_BMALLOC2,	"SaltTextAway: malloc() failed" },
	{ ERROR_LOGEXEC,	"StartLog: exec() failed" },
	{ ERROR_XERROR,		"xerror: XError event" },
	{ ERROR_XIOERROR,	"xioerror: X I/O error" },
	{ ERROR_SCALLOC,	"Alloc: calloc() failed on base" },
	{ ERROR_SCALLOC2,	"Alloc: calloc() failed on rows" },
	{ ERROR_SREALLOC,	"ScreenResize: realloc() failed on alt base" },
	{ ERROR_RESIZE,		"ScreenResize: malloc() or realloc() failed" },
	{ ERROR_SAVE_PTR,	"ScrnPointers: malloc/realloc() failed" },
	{ ERROR_SBRALLOC,	"ScrollBarOn: realloc() failed on base" },
	{ ERROR_SBRALLOC2,	"ScrollBarOn: realloc() failed on rows" },
	{ ERROR_MMALLOC,	"my_memmove: malloc/realloc failed" },
d3095 1
a3095 1
    /* *INDENT-ON* */
d3097 5
a3101 8
    Cardinal n;
    const char *result = "?";

    for (n = 0; n < XtNumber(table); ++n) {
	if (code == table[n].code) {
	    result = table[n].name;
	    break;
	}
d3103 1
a3103 13
    return result;
}

void
SysError(int code)
{
    int oerrno = errno;

    fprintf(stderr, "%s: Error %d, errno %d: ", xterm_name, code, oerrno);
    fprintf(stderr, "%s\n", SysErrorMsg(oerrno));
    fprintf(stderr, "Reason: %s\n", SysReasonMsg(code));

    Cleanup(code);
d3163 1
a3163 1
	if ((s = x_getenv("PATH")) != 0) {
a3205 20
#define ENV_HUNK(n)	((((n) + 1) | 31) + 1)

/*
 * copy the environment before Setenv'ing.
 */
void
xtermCopyEnv(char **oldenv)
{
    unsigned size;
    char **newenv;

    for (size = 0; oldenv[size] != NULL; size++) {
	;
    }

    newenv = TypeCallocN(char *, ENV_HUNK(size));
    memmove(newenv, oldenv, size * sizeof(char *));
    environ = newenv;
}

a3216 1
	char *test;
a3218 1
	int found = -1;
d3220 1
a3220 1
	TRACE(("xtermSetenv(%s=%s)\n", var, value));
d3222 7
a3228 4
	while ((test = environ[envindex]) != NULL) {
	    if (strncmp(test, var, len) == 0 && test[len] == '=') {
		found = envindex;
		break;
d3233 1
a3233 20
	if (found < 0) {
	    unsigned need = ENV_HUNK(envindex + 1);
	    unsigned have = ENV_HUNK(envindex);

	    if (need > have) {
		char **newenv;
		newenv = TypeMallocN(char *, need);
		if (newenv == 0) {
		    fprintf(stderr, "Cannot increase environment\n");
		    return;
		}
		memmove(newenv, environ, have * sizeof(*newenv));
		free(environ);
		environ = newenv;
	    }

	    found = envindex;
	    environ[found + 1] = NULL;
	    environ = environ;
	}
d3235 4
a3238 6
	environ[found] = CastMallocN(char, 1 + len + strlen(value));
	if (environ[found] == 0) {
	    fprintf(stderr, "Cannot allocate environment %s\n", var);
	    return;
	}
	sprintf(environ[found], "%s=%s", var, value);
d3270 2
d3277 1
a3277 1
    if (x_getenv("DISPLAY") == 0) {
d3580 1
a3580 1
 * Report the character-type locale that xterm was started in.
d3588 4
a3591 3
	if ((result = x_nonempty(setlocale(LC_CTYPE, 0))) == 0) {
	    result = "C";
	}
d3607 1
a3607 1
	if (!strcmp(locale, "C") || !strcmp(locale, "POSIX")) {
@


1.1.1.4
log
@Import xterm version 232. tested by many.
@
text
@d1 1
a1 1
/* $XTermId: misc.c,v 1.382 2008/01/27 15:37:18 tom Exp $ */
d5 1
a5 1
 * Copyright 1999-2007,2008 by Thomas E. Dickey
a65 1
#include <X11/keysym.h>
d111 1
a111 1
		  (event.xcrossing.window == XtWindow(XtParent(xw)) || \
d117 1
a117 1
		   (event.xcrossing.window == XtWindow(XtParent(xw))))
a119 2
static Cursor make_hidden_cursor(XtermWidget);

d131 1
a131 1
	buf = TypeRealloc(char, size, buf);
a279 76
xtermDisplayCursor(XtermWidget xw)
{
    TScreen *screen = TScreenOf(xw);

    if (screen->Vshow) {
	if (screen->hide_pointer) {
	    TRACE(("Display hidden_cursor\n"));
	    XDefineCursor(screen->display, VWindow(screen), screen->hidden_cursor);
	} else {
	    TRACE(("Display pointer_cursor\n"));
	    recolor_cursor(screen,
			   screen->pointer_cursor,
			   T_COLOR(screen, MOUSE_FG),
			   T_COLOR(screen, MOUSE_BG));
	    XDefineCursor(screen->display, VWindow(screen), screen->pointer_cursor);
	}
    }
}

void
xtermShowPointer(XtermWidget xw, Bool enable)
{
    static int tried = -1;
    TScreen *screen = TScreenOf(xw);

#if OPT_TEK4014
    if (TEK4014_SHOWN(xw))
	enable = True;
#endif

    /*
     * Whether we actually hide the pointer depends on the pointer-mode and
     * the mouse-mode:
     */
    if (!enable) {
	switch (screen->pointer_mode) {
	case pNever:
	    enable = True;
	    break;
	case pNoMouse:
	    if (screen->send_mouse_pos != MOUSE_OFF)
		enable = True;
	    break;
	case pAlways:
	    break;
	}
    }

    if (enable) {
	if (screen->hide_pointer) {
	    screen->hide_pointer = False;
	    xtermDisplayCursor(xw);
	    switch (screen->send_mouse_pos) {
	    case ANY_EVENT_MOUSE:
		break;
	    default:
		MotionOff(screen, xw);
		break;
	    }
	}
    } else if (!(screen->hide_pointer) && (tried <= 0)) {
	if (screen->hidden_cursor == 0) {
	    screen->hidden_cursor = make_hidden_cursor(xw);
	}
	if (screen->hidden_cursor == 0) {
	    tried = 1;
	} else {
	    tried = 0;
	    screen->hide_pointer = True;
	    xtermDisplayCursor(xw);
	    MotionOn(screen, xw);
	}
    }
}

void
d351 1
a351 23
	     (event.xany.type != ButtonRelease))) {

	    /*
	     * If the event is interesting (and not a keyboard event), turn the
	     * mouse pointer back on.
	     */
	    if (screen->hide_pointer) {
		switch (event.xany.type) {
		case KeyPress:
		case KeyRelease:
		case ButtonPress:
		case ButtonRelease:
		    /* also these... */
		case Expose:
		case NoExpose:
		case PropertyNotify:
		    break;
		default:
		    xtermShowPointer(xw, True);
		    break;
		}
	    }

a352 1
	}
a355 32
static Cursor
make_hidden_cursor(XtermWidget xw)
{
    TScreen *screen = TScreenOf(xw);
    Cursor c;
    Display *dpy = screen->display;
    XFontStruct *fn;

    static XColor dummy;

    /*
     * Prefer nil2 (which is normally available) to "fixed" (which is supposed
     * to be "always" available), since it's a smaller glyph in case the
     * server insists on drawing _somethng_.
     */
    TRACE(("Ask for nil2 font\n"));
    if ((fn = XLoadQueryFont(dpy, "nil2")) == 0) {
	TRACE(("...Ask for fixed font\n"));
	fn = XLoadQueryFont(dpy, "fixed");
    }

    if (fn != 0) {
	/* a space character seems to work as a cursor (dots are not needed) */
	c = XCreateGlyphCursor(dpy, fn->fid, fn->fid, 'X', ' ', &dummy, &dummy);
	XFreeFont(dpy, fn);
    } else {
	c = 0;
    }
    TRACE(("XCreateGlyphCursor ->%#lx\n", c));
    return (c);
}

d456 1
a456 1
     * Try to find the actual program which is running in the child process.
d599 1
a599 4
    if (screen->quiet_grab
	&& (event->mode == NotifyGrab || event->mode == NotifyUngrab)) {
	;
    } else if (event->type == FocusIn) {
a1108 2
    TRACE(("Redraw\n"));

d1607 1
a1607 1
			     * Look for the best match based on luminance.
a2720 8
#if OPT_TCAP_FKEYS
			/*
			 * First ensure that we handle the extended cursor- and
			 * editing-keypad keys.
			 */
			if ((code <= XK_Fn(MAX_FKEY))
			    || xtermcapString(xw, CodeToXkey(code), 0) == 0)
#endif
a2774 2
    static char empty[1];

d2776 1
a2776 1
    char *original = (value != 0) ? value : empty;
d2857 3
a2859 3
	const char *propname = (!strcmp(attribute, XtNtitle)
				? "_NET_WM_NAME"
				: "_NET_WM_ICON_NAME");
@


