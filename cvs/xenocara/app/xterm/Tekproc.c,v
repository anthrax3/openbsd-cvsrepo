head	1.25;
access;
symbols
	OPENBSD_6_2:1.25.0.2
	OPENBSD_6_2_BASE:1.25
	OPENBSD_6_1:1.24.0.2
	OPENBSD_6_1_BASE:1.24
	OPENBSD_6_0:1.23.0.10
	OPENBSD_6_0_BASE:1.23
	OPENBSD_5_9:1.23.0.8
	OPENBSD_5_9_BASE:1.23
	OPENBSD_5_8:1.23.0.6
	OPENBSD_5_8_BASE:1.23
	OPENBSD_5_7:1.23.0.4
	OPENBSD_5_7_BASE:1.23
	OPENBSD_5_6:1.23.0.2
	OPENBSD_5_6_BASE:1.23
	OPENBSD_5_5:1.21.0.2
	OPENBSD_5_5_BASE:1.21
	OPENBSD_5_4:1.20.0.4
	OPENBSD_5_4_BASE:1.20
	OPENBSD_5_3:1.20.0.2
	OPENBSD_5_3_BASE:1.20
	OPENBSD_5_2:1.19.0.2
	OPENBSD_5_2_BASE:1.19
	OPENBSD_5_1_BASE:1.18
	OPENBSD_5_1:1.18.0.2
	OPENBSD_5_0:1.16.0.2
	OPENBSD_5_0_BASE:1.16
	OPENBSD_4_9:1.15.0.2
	OPENBSD_4_9_BASE:1.15
	OPENBSD_4_8:1.13.0.4
	OPENBSD_4_8_BASE:1.13
	OPENBSD_4_7:1.11.0.2
	OPENBSD_4_7_BASE:1.11
	OPENBSD_4_6:1.9.0.2
	OPENBSD_4_6_BASE:1.9
	OPENBSD_4_5:1.7.0.2
	OPENBSD_4_5_BASE:1.7
	OPENBSD_4_4:1.6.0.2
	OPENBSD_4_4_BASE:1.6
	OPENBSD_4_3_BASE:1.5
	OPENBSD_4_3:1.5.0.2
	v232:1.1.1.4
	v229:1.1.1.3
	OPENBSD_4_2:1.3.0.2
	OPENBSD_4_2_BASE:1.3
	v225:1.1.1.2
	v216:1.1.1.1
	xterm:1.1.1;
locks; strict;
comment	@ * @;


1.25
date	2017.07.15.19.20.51;	author matthieu;	state Exp;
branches;
next	1.24;
commitid	b9xPQ49d1NNt4zlu;

1.24
date	2016.08.07.21.27.36;	author matthieu;	state Exp;
branches;
next	1.23;
commitid	psxxjI5z4Vpv2LL4;

1.23
date	2014.07.14.08.30.10;	author matthieu;	state Exp;
branches;
next	1.22;
commitid	EnwNNUjlkdrocnMa;

1.22
date	2014.05.09.19.56.40;	author matthieu;	state Exp;
branches;
next	1.21;

1.21
date	2014.01.02.15.14.50;	author matthieu;	state Exp;
branches;
next	1.20;

1.20
date	2013.01.04.16.40.18;	author matthieu;	state Exp;
branches;
next	1.19;

1.19
date	2012.04.14.09.02.46;	author matthieu;	state Exp;
branches;
next	1.18;

1.18
date	2011.09.17.11.51.57;	author matthieu;	state Exp;
branches;
next	1.17;

1.17
date	2011.08.18.19.47.42;	author matthieu;	state Exp;
branches;
next	1.16;

1.16
date	2011.03.07.20.41.27;	author matthieu;	state Exp;
branches;
next	1.15;

1.15
date	2010.10.23.19.14.52;	author matthieu;	state Exp;
branches;
next	1.14;

1.14
date	2010.08.22.13.38.11;	author matthieu;	state Exp;
branches;
next	1.13;

1.13
date	2010.05.08.12.20.46;	author matthieu;	state Exp;
branches;
next	1.12;

1.12
date	2010.03.25.22.03.51;	author matthieu;	state Exp;
branches;
next	1.11;

1.11
date	2009.10.31.14.11.57;	author matthieu;	state Exp;
branches;
next	1.10;

1.10
date	2009.09.05.15.58.09;	author matthieu;	state Exp;
branches;
next	1.9;

1.9
date	2009.04.04.15.10.44;	author matthieu;	state Exp;
branches;
next	1.8;

1.8
date	2009.03.09.22.13.04;	author matthieu;	state Exp;
branches;
next	1.7;

1.7
date	2008.08.25.18.05.56;	author matthieu;	state Exp;
branches;
next	1.6;

1.6
date	2008.03.19.21.15.46;	author matthieu;	state Exp;
branches;
next	1.5;

1.5
date	2008.02.16.09.40.00;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2007.08.25.18.58.42;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2007.06.15.19.34.50;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2006.11.26.15.48.06;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.26.11.11.15;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.11.26.11.11.15;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2007.06.15.19.29.58;	author matthieu;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2007.08.25.18.53.30;	author matthieu;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2008.02.16.09.35.14;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.25
log
@Update to xterm 330
@
text
@/* $XTermId: Tekproc.c,v 1.228 2017/05/29 23:19:34 tom Exp $ */

/*
 * Copyright 2001-2016,2017 by Thomas E. Dickey
 *
 *                         All Rights Reserved
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 *
 * The above copyright notice and this permission notice shall be included
 * in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
 * IN NO EVENT SHALL THE ABOVE LISTED COPYRIGHT HOLDER(S) BE LIABLE FOR ANY
 * CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
 * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
 * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 *
 * Except as contained in this notice, the name(s) of the above copyright
 * holders shall not be used in advertising or otherwise to promote the
 * sale, use or other dealings in this Software without prior written
 * authorization.
 *
 * Copyright 1988  The Open Group
 *
 * Permission to use, copy, modify, distribute, and sell this software and its
 * documentation for any purpose is hereby granted without fee, provided that
 * the above copyright notice appear in all copies and that both that
 * copyright notice and this permission notice appear in supporting
 * documentation.
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
 * OPEN GROUP BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
 * AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 *
 * Except as contained in this notice, the name of The Open Group shall not be
 * used in advertising or otherwise to promote the sale, use or other dealings
 * in this Software without prior written authorization from The Open Group.
 *
 * Copyright 1987 by Digital Equipment Corporation, Maynard, Massachusetts.
 *
 *                         All Rights Reserved
 *
 * Permission to use, copy, modify, and distribute this software and its
 * documentation for any purpose and without fee is hereby granted,
 * provided that the above copyright notice appear in all copies and that
 * both that copyright notice and this permission notice appear in
 * supporting documentation, and that the name of Digital Equipment
 * Corporation not be used in advertising or publicity pertaining to
 * distribution of the software without specific, written prior permission.
 *
 *
 * DIGITAL DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING
 * ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL
 * DIGITAL BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR
 * ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
 * WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
 * ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
 * SOFTWARE.
 */

/* Tekproc.c */

#define RES_OFFSET(field)	XtOffsetOf(TekWidgetRec, field)

#include <xterm.h>

#include <X11/Xatom.h>
#include <X11/Xutil.h>
#include <X11/cursorfont.h>
#include <X11/Xmu/CharSet.h>

#if OPT_TOOLBAR

#if defined(HAVE_LIB_XAW)
#include <X11/Xaw/Form.h>
#elif defined(HAVE_LIB_XAW3D)
#include <X11/Xaw3d/Form.h>
#elif defined(HAVE_LIB_XAW3DXFT)
#include <X11/Xaw3dxft/Form.h>
#elif defined(HAVE_LIB_NEXTAW)
#include <X11/neXtaw/Form.h>
#elif defined(HAVE_LIB_XAWPLUS)
#include <X11/XawPlus/Form.h>
#endif

#endif /* OPT_TOOLBAR */

#include <assert.h>
#include <stdio.h>
#include <ctype.h>
#include <signal.h>

#include <Tekparse.h>
#include <data.h>
#include <error.h>
#include <menu.h>
#include <xstrings.h>

#define DefaultGCID(tw) \
	XGContextFromGC(DefaultGC(XtDisplay(tw), \
			DefaultScreen(XtDisplay(tw))))

/* Tek defines */

#define MY_CLASS "Tek4014"
#define MY_NAME  "tek4014"

#define	SOLIDLINE	0
#define	DOTTEDLINE	1
#define	DOTDASHEDLINE	2
#define	SHORTDASHEDLINE	3
#define	LONGDASHEDLINE	4

#define	EAST		001
#define	WEST		002
#define	NORTH		004
#define	SOUTH		010

#define	LINEMASK	07
#define	MARGIN1		0
#define	MARGIN2		1
#define MAX_PTS		150
#define MAX_VTX		300
#define	PENDOWN		1
#define	PENUP		0
#define	TEKBOTTOMPAD	23
#define	TEKDEFHEIGHT	565
#define	TEKDEFWIDTH	750
#define	TEKHEIGHT	3072
#define	TEKHOME		( (TekChar[tekscr->page.fontsize].nlines - 1) \
			 * TekChar[tekscr->page.fontsize].vsize)
#define	TEKMINHEIGHT	452
#define	TEKMINWIDTH	600
#define	TEKTOPPAD	34
#define	TEKWIDTH	4096

#define	FULL_HEIGHT	(TEKHEIGHT + TEKTOPPAD + TEKBOTTOMPAD)

#define	BottomY(y)	(TEKHEIGHT + TEKTOPPAD - (y))
#define	BorderOf(tw)	(TScreenOf((tw)->vt)->border)
#define	ScaleOf(tw)	TekScale(TekScreenOf(tw))
#define	ScaledX(tw,x)	(((x) * ScaleOf(tw)) + BorderOf(tw))
#define	ScaledY(tw,y)	((BottomY(y) * ScaleOf(tw)) + BorderOf(tw))

#define	TekMove(tw,x,y)	tekscr->cur_X = x; tekscr->cur_Y = y
#define	input()		Tinput(tw)
#define	unput(c)	*Tpushback++ = (Char) c
/* *INDENT-OFF* */
static const struct Tek_Char {
    int hsize;			/* in Tek units */
    int vsize;			/* in Tek units */
    int charsperline;
    int nlines;
} TekChar[TEKNUMFONTS] = {
    {56, 88, 74, 35},		/* large */
    {51, 82, 81, 38},		/* #2 */
    {34, 53, 121, 58},		/* #3 */
    {31, 48, 133, 64},		/* small */
};
/* *INDENT-ON* */

static Cursor GINcursor;
static XSegment *line_pt;
static int nplot;
static TekLink Tek0;
static jmp_buf Tekjump;
static TekLink *TekRecord;
static XSegment *Tline;

static Const int *curstate = Talptable;
static Const int *Tparsestate = Talptable;

static char defaultTranslations[] = "\
                ~Meta<KeyPress>: insert-seven-bit() \n\
                 Meta<KeyPress>: insert-eight-bit() \n\
               !Ctrl <Btn1Down>: popup-menu(mainMenu) \n\
          !Lock Ctrl <Btn1Down>: popup-menu(mainMenu) \n\
!Lock Ctrl @@Num_Lock <Btn1Down>: popup-menu(mainMenu) \n\
     !Ctrl @@Num_Lock <Btn1Down>: popup-menu(mainMenu) \n\
               !Ctrl <Btn2Down>: popup-menu(tekMenu) \n\
          !Lock Ctrl <Btn2Down>: popup-menu(tekMenu) \n\
!Lock Ctrl @@Num_Lock <Btn2Down>: popup-menu(tekMenu) \n\
     !Ctrl @@Num_Lock <Btn2Down>: popup-menu(tekMenu) \n\
          Shift ~Meta<Btn1Down>: gin-press(L) \n\
                ~Meta<Btn1Down>: gin-press(l) \n\
          Shift ~Meta<Btn2Down>: gin-press(M) \n\
                ~Meta<Btn2Down>: gin-press(m) \n\
          Shift ~Meta<Btn3Down>: gin-press(R) \n\
                ~Meta<Btn3Down>: gin-press(r)";
/* *INDENT-OFF* */
static XtActionsRec actionsList[] = {
    { "string",			HandleStringEvent },
    { "insert",			HandleKeyPressed },	/* alias for insert-seven-bit */
    { "insert-seven-bit",	HandleKeyPressed },
    { "insert-eight-bit",	HandleEightBitKeyPressed },
    { "gin-press",		HandleGINInput },
    { "secure",			HandleSecure },
    { "create-menu",		HandleCreateMenu },
    { "popup-menu",		HandlePopupMenu },
    /* menu actions */
    { "allow-send-events",	HandleAllowSends },
    { "set-visual-bell",	HandleSetVisualBell },
#ifdef ALLOWLOGGING
    { "set-logging",		HandleLogging },
#endif
    { "redraw",			HandleRedraw },
    { "send-signal",		HandleSendSignal },
    { "quit",			HandleQuit },
    { "set-scrollbar",		HandleScrollbar },
    { "set-jumpscroll",		HandleJumpscroll },
    { "set-reverse-video",	HandleReverseVideo },
    { "set-autowrap",		HandleAutoWrap },
    { "set-reversewrap",	HandleReverseWrap },
    { "set-autolinefeed",	HandleAutoLineFeed },
    { "set-appcursor",		HandleAppCursor },
    { "set-appkeypad",		HandleAppKeypad },
    { "set-scroll-on-key",	HandleScrollKey },
    { "set-scroll-on-tty-output", HandleScrollTtyOutput },
    { "set-allow132",		HandleAllow132 },
    { "set-cursesemul",		HandleCursesEmul },
    { "set-marginbell",		HandleMarginBell },
    { "set-altscreen",		HandleAltScreen },
    { "soft-reset",		HandleSoftReset },
    { "hard-reset",		HandleHardReset },
    { "set-terminal-type",	HandleSetTerminalType },
    { "set-visibility",		HandleVisibility },
    { "set-tek-text",		HandleSetTekText },
    { "tek-page",		HandleTekPage },
    { "tek-reset",		HandleTekReset },
    { "tek-copy",		HandleTekCopy },
#if OPT_TOOLBAR
    { "set-toolbar",		HandleToolbar },
#endif
};
/* *INDENT-ON* */

static Dimension defOne = 1;

#define GIN_TERM_NONE_STR	"none"
#define GIN_TERM_CR_STR		"CRonly"
#define GIN_TERM_EOT_STR	"CR&EOT"

#define GIN_TERM_NONE	0
#define GIN_TERM_CR	1
#define GIN_TERM_EOT	2

#ifdef VMS
#define DFT_FONT_SMALL "FIXED"
#else
#define DFT_FONT_SMALL "6x10"
#endif

static XtResource resources[] =
{
    {XtNwidth, XtCWidth, XtRDimension, sizeof(Dimension),
     XtOffsetOf(CoreRec, core.width), XtRDimension, (caddr_t) & defOne},
    {XtNheight, XtCHeight, XtRDimension, sizeof(Dimension),
     XtOffsetOf(CoreRec, core.height), XtRDimension, (caddr_t) & defOne},
    Fres("fontLarge", XtCFont, tek.Tfont[TEK_FONT_LARGE], "9x15"),
    Fres("font2", XtCFont, tek.Tfont[TEK_FONT_2], "6x13"),
    Fres("font3", XtCFont, tek.Tfont[TEK_FONT_3], "8x13"),
    Fres("fontSmall", XtCFont, tek.Tfont[TEK_FONT_SMALL], DFT_FONT_SMALL),
    Sres(XtNinitialFont, XtCInitialFont, tek.initial_font, "large"),
    Sres("ginTerminator", "GinTerminator", tek.gin_terminator_str, GIN_TERM_NONE_STR),
#if OPT_TOOLBAR
    Wres(XtNmenuBar, XtCMenuBar, tek.tb_info.menu_bar, 0),
    Ires(XtNmenuHeight, XtCMenuHeight, tek.tb_info.menu_height, 25),
#endif
};

static IChar Tinput(TekWidget /* tw */ );
static int getpoint(TekWidget /* tw */ );
static void TCursorBack(TekWidget /* tw */ );
static void TCursorDown(TekWidget /* tw */ );
static void TCursorForward(TekWidget /* tw */ );
static void TCursorUp(TekWidget /* tw */ );
static void TekBackground(TekWidget /* tw */ ,
			  TScreen * /* screen */ );
static void TekResize(Widget /* w */ );
static void TekDraw(TekWidget /* tw */ ,
		    int /* x */ ,
		    int /* y */ );
static void TekEnq(TekWidget /* tw */ ,
		   unsigned /* status */ ,
		   int /* x */ ,
		   int /* y */ );
static void TekFlush(TekWidget /* tw */ );
static void TekInitialize(Widget /* request */ ,
			  Widget /* wnew */ ,
			  ArgList /* args */ ,
			  Cardinal * /* num_args */ );
static void TekPage(TekWidget /* tw */ );
static void TekRealize(Widget /* gw */ ,
		       XtValueMask * /* valuemaskp */ ,
		       XSetWindowAttributes * /* values */ );

static WidgetClassRec tekClassRec =
{
    {
/* core_class fields */
	(WidgetClass) & widgetClassRec,		/* superclass     */
	MY_CLASS,		/* class_name                   */
	sizeof(TekWidgetRec),	/* widget_size                  */
	NULL,			/* class_initialize             */
	NULL,			/* class_part_initialize        */
	False,			/* class_inited                 */
	TekInitialize,		/* initialize                   */
	NULL,			/* initialize_hook              */
	TekRealize,		/* realize                      */
	actionsList,		/* actions                      */
	XtNumber(actionsList),	/* num_actions                  */
	resources,		/* resources                    */
	XtNumber(resources),	/* num_resources                */
	NULLQUARK,		/* xrm_class                    */
	True,			/* compress_motion              */
	True,			/* compress_exposure            */
	True,			/* compress_enterleave          */
	False,			/* visible_interest             */
	NULL,			/* destroy                      */
	TekResize,		/* resize                       */
	TekExpose,		/* expose                       */
	NULL,			/* set_values                   */
	NULL,			/* set_values_hook              */
	XtInheritSetValuesAlmost,	/* set_values_almost    */
	NULL,			/* get_values_hook              */
	NULL,			/* accept_focus                 */
	XtVersion,		/* version                      */
	NULL,			/* callback_offsets             */
	defaultTranslations,	/* tm_table                     */
	XtInheritQueryGeometry,	/* query_geometry               */
	XtInheritDisplayAccelerator,	/* display_accelerator  */
	NULL			/* extension                    */
    }
};
WidgetClass tekWidgetClass = (WidgetClass) & tekClassRec;

static Bool Tfailed = False;

/*
 * TekInit/TekRun are called after the VT100 widget has been initialized, but
 * may be before VT100 is realized, depending upon whether Tek4014 is the
 * first window to be shown.
 */
int
TekInit(void)
{
    Widget form_top, menu_top;
    Dimension menu_high;

    if (!Tfailed
	&& tekWidget == 0) {
	Cardinal nargs = 0;
	Arg myArgs[3];
	Boolean iconic = 0;

	TRACE(("TekInit\n"));
	XtSetArg(myArgs[nargs], XtNiconic, &iconic);
	++nargs;
	XtGetValues(toplevel, myArgs, nargs);

	nargs = 0;
	XtSetArg(myArgs[nargs], XtNiconic, iconic);
	++nargs;
	XtSetArg(myArgs[nargs], XtNallowShellResize, True);
	++nargs;
	XtSetArg(myArgs[nargs], XtNinput, True);
	++nargs;

	/* this causes the Initialize method to be called */
	tekshellwidget =
	    XtCreatePopupShell("tektronix", topLevelShellWidgetClass,
			       toplevel, myArgs, nargs);

	SetupMenus(tekshellwidget, &form_top, &menu_top, &menu_high);

	/* this causes the Realize method to be called */
	tekWidget = (TekWidget)
	    XtVaCreateManagedWidget(MY_NAME,
				    tekWidgetClass, form_top,
#if OPT_TOOLBAR
				    XtNmenuBar, menu_top,
				    XtNresizable, True,
				    XtNfromVert, menu_top,
				    XtNtop, XawChainTop,
				    XtNleft, XawChainLeft,
				    XtNright, XawChainRight,
				    XtNbottom, XawChainBottom,
				    XtNmenuHeight, menu_high,
#endif
				    (XtPointer) 0);
#if OPT_TOOLBAR
	ShowToolbar(resource.toolBar);
#endif
    }
    return (!Tfailed);
}

/*
 * If we haven't allocated the PtyData struct, do so.
 */
static int
TekPtyData(void)
{
    if (Tpushb == 0 && !Tfailed) {
	if ((Tpushb = TypeMallocN(Char, 10)) == NULL
	    || (Tline = TypeMallocN(XSegment, MAX_VTX)) == NULL) {
	    xtermWarning("Not enough core for Tek mode\n");
	    if (Tpushb)
		free(Tpushb);
	    Tfailed = True;
	}
    }
    return (Tfailed ? 0 : 1);
}

static void
Tekparse(TekWidget tw)
{
    TekScreen *tekscr = TekScreenOf(tw);
    TScreen *screen = TScreenOf(tw->vt);
    int x, y;
    IChar ch;
    int nextstate;

    for (;;) {
	IChar c = input();
	/*
	 * The parsing tables all have 256 entries.  If we're supporting
	 * wide characters, we handle them by treating them the same as
	 * printing characters.
	 */
#if OPT_WIDE_CHARS
	if (c > 255) {
	    nextstate = (Tparsestate == Talptable)
		? CASE_PRINT
		: CASE_IGNORE;
	} else
#endif
	    nextstate = Tparsestate[c];
	TRACE(("Tekparse %04X -> %d\n", c, nextstate));

	switch (nextstate) {
	case CASE_REPORT:
	    TRACE(("case: report address\n"));
	    if (tekscr->TekGIN) {
		TekGINoff(tw);
		TekEnqMouse(tw, 0);
	    } else {
		c = 064;	/* has hard copy unit */
		if (tekscr->margin == MARGIN2)
		    c |= 02;
		TekEnq(tw, c, tekscr->cur_X, tekscr->cur_Y);
	    }
	    TekRecord->ptr[-1] = ANSI_NAK;	/* remove from recording */
	    Tparsestate = curstate;
	    break;

	case CASE_VT_MODE:
	    TRACE(("case: special return to vt102 mode\n"));
	    Tparsestate = curstate;
	    TekRecord->ptr[-1] = ANSI_NAK;	/* remove from recording */
	    FlushLog(tw->vt);
	    return;

	case CASE_SPT_STATE:
	    TRACE(("case: Enter Special Point Plot mode\n"));
	    if (tekscr->TekGIN)
		TekGINoff(tw);
	    Tparsestate = curstate = Tspttable;
	    break;

	case CASE_GIN:
	    TRACE(("case: Do Tek GIN mode\n"));
	    tekscr->TekGIN = &TekRecord->ptr[-1];
	    /* Set cross-hair cursor raster array */
	    if ((GINcursor =
		 make_colored_cursor(XC_tcross,
				     T_COLOR(screen, MOUSE_FG),
				     T_COLOR(screen, MOUSE_BG))) != 0) {
		XDefineCursor(XtDisplay(tw), TWindow(tekscr),
			      GINcursor);
	    }
	    Tparsestate = Tbyptable;	/* Bypass mode */
	    break;

	case CASE_BEL:
	    TRACE(("case: BEL\n"));
	    if (tekscr->TekGIN)
		TekGINoff(tw);
	    if (!tekRefreshList)
		Bell(tw->vt, XkbBI_TerminalBell, 0);
	    Tparsestate = curstate;	/* clear bypass condition */
	    break;

	case CASE_BS:
	    TRACE(("case: BS\n"));
	    if (tekscr->TekGIN)
		TekGINoff(tw);
	    Tparsestate = curstate;	/* clear bypass condition */
	    TCursorBack(tw);
	    break;

	case CASE_PT_STATE:
	    TRACE(("case: Enter Tek Point Plot mode\n"));
	    if (tekscr->TekGIN)
		TekGINoff(tw);
	    Tparsestate = curstate = Tpttable;
	    break;

	case CASE_PLT_STATE:
	    TRACE(("case: Enter Tek Plot mode\n"));
	    if (tekscr->TekGIN)
		TekGINoff(tw);
	    Tparsestate = curstate = Tplttable;
	    if ((c = input()) == ANSI_BEL)
		tekscr->pen = PENDOWN;
	    else {
		unput(c);
		tekscr->pen = PENUP;
	    }
	    break;

	case CASE_TAB:
	    TRACE(("case: HT\n"));
	    if (tekscr->TekGIN)
		TekGINoff(tw);
	    Tparsestate = curstate;	/* clear bypass condition */
	    TCursorForward(tw);
	    break;

	case CASE_IPL_STATE:
	    TRACE(("case: Enter Tek Incremental Plot mode\n"));
	    if (tekscr->TekGIN)
		TekGINoff(tw);
	    Tparsestate = curstate = Tipltable;
	    break;

	case CASE_ALP_STATE:
	    TRACE(("case: Enter Tek Alpha mode from any other mode\n"));
	    if (tekscr->TekGIN)
		TekGINoff(tw);
	    /* if in one of graphics states, move alpha cursor */
	    if (nplot > 0)	/* flush line VTbuffer */
		TekFlush(tw);
	    Tparsestate = curstate = Talptable;
	    break;

	case CASE_UP:
	    TRACE(("case: cursor up\n"));
	    if (tekscr->TekGIN)
		TekGINoff(tw);
	    Tparsestate = curstate;	/* clear bypass condition */
	    TCursorUp(tw);
	    break;

	case CASE_COPY:
	    TRACE(("case: make copy\n"));
	    if (tekscr->TekGIN)
		TekGINoff(tw);
	    TekCopy(tw);
	    TekRecord->ptr[-1] = ANSI_NAK;	/* remove from recording */
	    Tparsestate = curstate;	/* clear bypass condition */
	    break;

	case CASE_PAGE:
	    TRACE(("case: Page Function\n"));
	    if (tekscr->TekGIN)
		TekGINoff(tw);
	    TekPage(tw);	/* clear bypass condition */
	    break;

	case CASE_BES_STATE:
	    TRACE(("case: Byp: an escape char\n"));
	    Tparsestate = Tbestable;
	    break;

	case CASE_BYP_STATE:
	    TRACE(("case: set bypass condition\n"));
	    Tparsestate = Tbyptable;
	    break;

	case CASE_IGNORE:
	    TRACE(("case: Esc: totally ignore CR, ESC, LF, ~\n"));
	    break;

	case CASE_ASCII:
	    TRACE(("case: Select ASCII char set\n"));
	    /* ignore for now */
	    Tparsestate = curstate;
	    break;

	case CASE_APL:
	    TRACE(("case: Select APL char set\n"));
	    /* ignore for now */
	    Tparsestate = curstate;
	    break;

	case CASE_CHAR_SIZE:
	    TRACE(("case: character size selector\n"));
	    TekSetFontSize(tw, False, (int) (c & 03));
	    Tparsestate = curstate;
	    break;

	case CASE_BEAM_VEC:
	    TRACE(("case: beam and vector selector\n"));
	    /* only line types */
	    c = (IChar) (c & LINEMASK);
	    if (c != tekscr->cur.linetype) {
		if (nplot > 0)
		    TekFlush(tw);
		if (c <= TEKNUMLINES)
		    tekscr->cur.linetype = c;
	    }
	    Tparsestate = curstate;
	    break;

	case CASE_CURSTATE:
	    Tparsestate = curstate;
	    break;

	case CASE_PENUP:
	    TRACE(("case: Ipl: penup\n"));
	    tekscr->pen = PENUP;
	    break;

	case CASE_PENDOWN:
	    TRACE(("case: Ipl: pendown\n"));
	    tekscr->pen = PENDOWN;
	    break;

	case CASE_IPL_POINT:
	    TRACE(("case: Ipl: point\n"));
	    x = tekscr->cur_X;
	    y = tekscr->cur_Y;
	    if (c & NORTH)
		y++;
	    else if (c & SOUTH)
		y--;
	    if (c & EAST)
		x++;
	    else if (c & WEST)
		x--;
	    if (tekscr->pen == PENDOWN)
		TekDraw(tw, x, y);
	    else
		TekMove(tw, x, y);
	    break;

	case CASE_PLT_VEC:
	    TRACE(("case: Plt: vector\n"));
	    unput(c);
	    if (getpoint(tw)) {
		if (tekscr->pen == PENDOWN) {
		    TekDraw(tw, tekscr->cur.x, tekscr->cur.y);
		} else {
		    TekMove(tw, tekscr->cur.x, tekscr->cur.y);
		}
		tekscr->pen = PENDOWN;
	    }
	    break;

	case CASE_PT_POINT:
	    TRACE(("case: Pt: point\n"));
	    unput(c);
	    if (getpoint(tw)) {
		TekMove(tw, tekscr->cur.x, tekscr->cur.y);
		TekDraw(tw, tekscr->cur.x, tekscr->cur.y);
	    }
	    break;

	case CASE_SPT_POINT:
	    TRACE(("case: Spt: point\n"));
	    /* ignore intensity character in c */
	    if (getpoint(tw)) {
		TekMove(tw, tekscr->cur.x, tekscr->cur.y);
		TekDraw(tw, tekscr->cur.x, tekscr->cur.y);
	    }
	    break;

	case CASE_CR:
	    TRACE(("case: CR\n"));
	    if (tekscr->TekGIN)
		TekGINoff(tw);
	    if (nplot > 0)	/* flush line VTbuffer */
		TekFlush(tw);
	    tekscr->cur_X = tekscr->margin == MARGIN1 ? 0 :
		TEKWIDTH / 2;
	    Tparsestate = curstate = Talptable;
	    break;

	case CASE_ESC_STATE:
	    TRACE(("case: ESC\n"));
	    Tparsestate = Tesctable;
	    break;

	case CASE_LF:
	    TRACE(("case: LF\n"));
	    if (tekscr->TekGIN)
		TekGINoff(tw);
	    TCursorDown(tw);
	    if (!tekRefreshList)
		do_xevents();
	    break;

	case CASE_SP:
	    TRACE(("case: SP\n"));
	    TCursorForward(tw);
	    break;

	case CASE_PRINT:
	    TRACE(("case: printable character\n"));
	    ch = c;
	    x = (int) ScaledX(tw, tekscr->cur_X);
	    y = (int) ScaledY(tw, tekscr->cur_Y);

#if OPT_WIDE_CHARS
	    if (screen->wide_chars
		&& (ch > 255)) {
		XChar2b sbuf;
		sbuf.byte2 = LO_BYTE(ch);
		sbuf.byte1 = HI_BYTE(ch);
		XDrawImageString16(XtDisplay(tw),
				   TWindow(tekscr),
				   tekscr->TnormalGC,
				   x,
				   y,
				   &sbuf,
				   1);
	    } else
#endif
	    {
		char ch2 = (char) ch;
		XDrawString(XtDisplay(tw),
			    TWindow(tekscr),
			    tekscr->TnormalGC,
			    x,
			    y,
			    &ch2,
			    1);
	    }
	    TCursorForward(tw);
	    break;
	case CASE_OSC:
	    /* FIXME:  someone should disentangle the input queues
	     * of this code so that it can be state-driven.
	     */
	    TRACE(("case: do osc escape\n"));
	    {
		/*
		 * do_osc() can call TekExpose(), which calls TekRefresh(),
		 * and sends us recurring here - don't do that...
		 */
		static int nested;

		Char buf2[512];
		IChar c2;
		size_t len = 0;
		while ((c2 = input()) != ANSI_BEL) {
		    if (!isprint((int) (c2 & 0x7f))
			|| len + 2 >= (int) sizeof(buf2))
			break;
		    buf2[len++] = (Char) c2;
		}
		buf2[len] = 0;
		if (!nested++) {
		    if (c2 == ANSI_BEL)
			do_osc(tw->vt, buf2, len, ANSI_BEL);
		}
		--nested;
	    }
	    Tparsestate = curstate;
	    break;
	}
    }
}

static int rcnt;
static char *rptr;
static PtySelect Tselect_mask;

static IChar
Tinput(TekWidget tw)
{
    TekScreen *tekscr = TekScreenOf(tw);
    TScreen *screen = TScreenOf(tw->vt);
    TekLink *tek;

    if (Tpushback > Tpushb)
	return (*--Tpushback);
    if (tekRefreshList) {
	if (rcnt-- > 0)
	    return (IChar) (*rptr++);
	if ((tek = tekRefreshList->next) != 0) {
	    tekRefreshList = tek;
	    rptr = tek->data;
	    rcnt = tek->count - 1;
	    TekSetFontSize(tw, False, tek->fontsize);
	    return (IChar) (*rptr++);
	}
	tekRefreshList = (TekLink *) 0;
	longjmp(Tekjump, 1);
    }
  again:
    if (VTbuffer->next >= VTbuffer->last) {
	int update = VTbuffer->update;

	if (nplot > 0)		/* flush line */
	    TekFlush(tw);
#ifdef VMS
	Tselect_mask = pty_mask;	/* force a read */
#else /* VMS */
	XFD_COPYSET(&pty_mask, &Tselect_mask);
#endif /* VMS */
	for (;;) {
#ifdef CRAY
	    struct timeval crocktimeout;
	    crocktimeout.tv_sec = 0;
	    crocktimeout.tv_usec = 0;
	    (void) Select(max_plus1,
			  &Tselect_mask, NULL, NULL,
			  &crocktimeout);
#endif
	    if (readPtyData(tw->vt, &Tselect_mask, VTbuffer)) {
		break;
	    }
	    if (Ttoggled && curstate == Talptable) {
		TCursorToggle(tw, TOGGLE);
		Ttoggled = False;
	    }
	    if (xtermAppPending() & XtIMXEvent) {
#ifdef VMS
		Tselect_mask = X_mask;
#else /* VMS */
		XFD_COPYSET(&X_mask, &Tselect_mask);
#endif /* VMS */
	    } else {
		XFlush(XtDisplay(tw));
#ifdef VMS
		Tselect_mask = Select_mask;

#else /* VMS */
		XFD_COPYSET(&Select_mask, &Tselect_mask);
		if (need_cleanup)
		    Cleanup(0);
		if (Select(max_plus1, &Tselect_mask, NULL, NULL, NULL) < 0) {
		    if (errno != EINTR)
			SysError(ERROR_TSELECT);
		    continue;
		}
#endif /* VMS */
	    }
#ifdef VMS
	    if (Tselect_mask & X_mask) {
		xevents();
		if (VTbuffer->update != update)
		    goto again;
	    }
#else /* VMS */
	    if (FD_ISSET(ConnectionNumber(XtDisplay(tw)), &Tselect_mask)) {
		xevents();
		if (VTbuffer->update != update)
		    goto again;
	    }
#endif /* VMS */
	}
	if (!Ttoggled && curstate == Talptable) {
	    TCursorToggle(tw, TOGGLE);
	    Ttoggled = True;
	}
    }
    tek = TekRecord;
    if (tek->count >= TEK_LINK_BLOCK_SIZE
	|| tek->fontsize != tekscr->cur.fontsize) {
	if ((TekRecord = tek->next = CastMalloc(TekLink)) == 0) {
	    Panic("Tinput: malloc error (%d)\n", errno);
	} else {
	    tek = tek->next;
	    tek->next = (TekLink *) 0;
	    tek->fontsize = (unsigned short) tekscr->cur.fontsize;
	    tek->count = 0;
	    tek->ptr = tek->data;
	}
    }
    tek->count++;

    (void) morePtyData(screen, VTbuffer);
    return (IChar) (*tek->ptr++ = (char) nextPtyData(screen, VTbuffer));
}

static void
TekClear(TekWidget tw)
{
    TekScreen *tekscr = TekScreenOf(tw);

    TRACE(("TekClear\n"));
    nplot = 0;
    line_pt = Tline;
    if (TWindow(tekscr))
	XClearWindow(XtDisplay(tw), TWindow(tekscr));
}

void
TekSetWinSize(TekWidget tw)
{
    if (TEK4014_ACTIVE(tw->vt)) {
	TekScreen *tekscr = TekScreenOf(tw);
	const struct Tek_Char *t = &TekChar[tekscr->cur.fontsize];
	int rows = THeight(tekscr) / (int) (ScaleOf(tw) * t->vsize);
	int cols = TWidth(tekscr) / (int) (ScaleOf(tw) * t->hsize);

	update_winsize(TScreenOf(tw->vt)->respond,
		       rows, cols,
		       TFullHeight(tekscr),
		       TFullWidth(tekscr));
    }
}

static void
compute_sizes(TekWidget tw)
{
    TekScreen *tekscr = TekScreenOf(tw);
    int border = 2 * BorderOf(tw);
    double d;
#if OPT_TRACE
    const struct Tek_Char *t = &TekChar[tekscr->cur.fontsize];
    const XFontStruct *fs = tw->tek.Tfont[tekscr->cur.fontsize];
#endif

    /* *INDENT-EQLS* */
    TWidth(tekscr)  = tw->core.width - border;
    THeight(tekscr) = tw->core.height - border;
    ScaleOf(tw)     = (double) TWidth(tekscr) / TEKWIDTH;

    if ((d = (double) THeight(tekscr) / FULL_HEIGHT) < ScaleOf(tw))
	ScaleOf(tw) = d;

    TFullWidth(tekscr) = tw->core.width;
    TFullHeight(tekscr) = tw->core.height;

    TRACE(("%s size %dx%d full %dx%d scale %.2f\n", MY_NAME,
	   THeight(tekscr), TWidth(tekscr),
	   TFullHeight(tekscr), TFullWidth(tekscr),
	   ScaleOf(tw)));

    /* The tek4014 fonts always look odd since their spacing is overridden to
     * get the "same" size as a real Tektronix terminal.  TrueType fonts for
     * these small sizes would be no better...
     */
    TRACE(("unscaled font %dx%d\n", t->vsize, t->hsize));
    TRACE(("scaled   font %.1fx%.1f\n", d * t->vsize, d * t->hsize));
    TRACE(("actual   font %dx%d\n",
	   fs->max_bounds.ascent + fs->max_bounds.descent,
	   fs->max_bounds.width));

    TekSetWinSize(tw);
}

static void
TekResize(Widget w)
{
    TekWidget tw = getTekWidget(w);
    if (tw != 0) {

	TRACE(("TekResize {{\n"));
	TekClear(tw);

	compute_sizes(tw);

	TRACE(("}} TekResize\n"));
    }
}

/*ARGSUSED*/
void
TekExpose(Widget w,
	  XEvent *event GCC_UNUSED,
	  Region region GCC_UNUSED)
{
    TekWidget tw = getTekWidget(w);
    if (tw != 0) {
	TekScreen *tekscr = TekScreenOf(tw);

	TRACE(("TekExpose {{\n"));

#ifdef lint
	region = region;
#endif
	if (!Ttoggled)
	    TCursorToggle(tw, CLEAR);
	Ttoggled = True;
	Tpushback = Tpushb;
	tekscr->cur_X = 0;
	tekscr->cur_Y = TEKHOME;
	tekscr->cur = tekscr->page;
	TekSetFontSize(tw, False, tekscr->cur.fontsize);
	tekscr->margin = MARGIN1;
	if (tekscr->TekGIN) {
	    tekscr->TekGIN = NULL;
	    TekGINoff(tw);
	}
	tekRefreshList = &Tek0;
	rptr = tekRefreshList->data;
	rcnt = tekRefreshList->count;
	Tparsestate = curstate = Talptable;
	TRACE(("TekExpose resets data to replay %d bytes\n", rcnt));
	first_map_occurred();
	if (!tekscr->waitrefresh)
	    TekRefresh(tw);
	TRACE(("}} TekExpose\n"));
    }
}

void
TekRefresh(TekWidget tw)
{
    if (tw != 0) {
	TScreen *screen = TScreenOf(tw->vt);
	TekScreen *tekscr = TekScreenOf(tw);
	static Cursor wait_cursor = None;

	if (wait_cursor == None)
	    wait_cursor = make_colored_cursor(XC_watch,
					      T_COLOR(screen, MOUSE_FG),
					      T_COLOR(screen, MOUSE_BG));
	XDefineCursor(XtDisplay(tw), TWindow(tekscr), wait_cursor);
	XFlush(XtDisplay(tw));
	if (!setjmp(Tekjump))
	    Tekparse(tw);
	XDefineCursor(XtDisplay(tw), TWindow(tekscr),
		      (tekscr->TekGIN && GINcursor) ? GINcursor : tekscr->arrow);
    }
}

void
TekRepaint(TekWidget tw)
{
    TRACE(("TekRepaint\n"));
    TekClear(tw);
    TekExpose((Widget) tw, (XEvent *) NULL, (Region) NULL);
}

static void
TekPage(TekWidget tw)
{
    TekScreen *tekscr = TekScreenOf(tw);
    TekLink *tek;

    TRACE(("TekPage\n"));
    TekClear(tw);
    tekscr->cur_X = 0;
    tekscr->cur_Y = TEKHOME;
    tekscr->margin = MARGIN1;
    tekscr->page = tekscr->cur;
    if (tekscr->TekGIN)
	TekGINoff(tw);
    tek = TekRecord = &Tek0;
    tek->fontsize = (unsigned short) tekscr->cur.fontsize;
    tek->count = 0;
    tek->ptr = tek->data;
    tek = tek->next;
    if (tek)
	do {
	    TekLink *tek2 = tek->next;

	    free(tek);
	    tek = tek2;
	} while (tek);
    TekRecord->next = (TekLink *) 0;
    tekRefreshList = (TekLink *) 0;
    Ttoggled = True;
    Tparsestate = curstate = Talptable;		/* Tek Alpha mode */
}

#define	EXTRABITS	017
#define	FIVEBITS	037
#define	HIBITS		(FIVEBITS << SHIFTHI)
#define	LOBITS		(FIVEBITS << SHIFTLO)
#define	SHIFTHI		7
#define	SHIFTLO		2
#define	TWOBITS		03

static int
getpoint(TekWidget tw)
{
    int x, y, e, lo_y = 0;
    TekScreen *tekscr = TekScreenOf(tw);

    x = tekscr->cur.x;
    y = tekscr->cur.y;

    for (;;) {
	int c;

	if ((c = (int) input()) < ' ') {	/* control character */
	    unput(c);
	    return (0);
	}
	if (c < '@@') {		/* Hi X or Hi Y */
	    if (lo_y) {		/* seen a Lo Y, so this must be Hi X */
		x &= ~HIBITS;
		x |= (c & FIVEBITS) << SHIFTHI;
		continue;
	    }
	    /* else Hi Y */
	    y &= ~HIBITS;
	    y |= (c & FIVEBITS) << SHIFTHI;
	    continue;
	}
	if (c < '`') {		/* Lo X */
	    x &= ~LOBITS;
	    x |= (c & FIVEBITS) << SHIFTLO;
	    tekscr->cur.x = x;
	    tekscr->cur.y = y;
	    return (1);		/* OK */
	}
	/* else Lo Y */
	if (lo_y) {		/* seen a Lo Y, so other must be extra bits */
	    e = (y >> SHIFTLO) & EXTRABITS;
	    x &= ~TWOBITS;
	    x |= e & TWOBITS;
	    y &= ~TWOBITS;
	    y |= (e >> SHIFTLO) & TWOBITS;
	}
	y &= ~LOBITS;
	y |= (c & FIVEBITS) << SHIFTLO;
	lo_y++;
    }
}

static void
TCursorBack(TekWidget tw)
{
    TekScreen *tekscr = TekScreenOf(tw);
    const struct Tek_Char *t;
    int x = (tekscr->cur_X -= (t = &TekChar[tekscr->cur.fontsize])->hsize);

    if (((tekscr->margin == MARGIN1) && (x < 0))
	|| ((tekscr->margin == MARGIN2) && (x < TEKWIDTH / 2))) {
	int l = ((tekscr->cur_Y + (t->vsize - 1)) / t->vsize + 1);
	if (l >= t->nlines) {
	    tekscr->margin = !tekscr->margin;
	    l = 0;
	}
	tekscr->cur_Y = l * t->vsize;
	tekscr->cur_X = (t->charsperline - 1) * t->hsize;
    }
}

static void
TCursorForward(TekWidget tw)
{
    TekScreen *tekscr = TekScreenOf(tw);
    const struct Tek_Char *t = &TekChar[tekscr->cur.fontsize];

    if ((tekscr->cur_X += t->hsize) > TEKWIDTH) {
	int l = (tekscr->cur_Y / t->vsize - 1);
	if (l < 0) {
	    tekscr->margin = !tekscr->margin;
	    l = t->nlines - 1;
	}
	tekscr->cur_Y = l * t->vsize;
	tekscr->cur_X = tekscr->margin == MARGIN1 ? 0 : TEKWIDTH / 2;
    }
}

static void
TCursorUp(TekWidget tw)
{
    TekScreen *tekscr = TekScreenOf(tw);
    const struct Tek_Char *t;
    int l;

    t = &TekChar[tekscr->cur.fontsize];

    if ((l = (tekscr->cur_Y + (t->vsize - 1)) / t->vsize + 1) >= t->nlines) {
	l = 0;
	if ((tekscr->margin = !tekscr->margin) != MARGIN1) {
	    if (tekscr->cur_X < TEKWIDTH / 2)
		tekscr->cur_X += TEKWIDTH / 2;
	} else if (tekscr->cur_X >= TEKWIDTH / 2)
	    tekscr->cur_X -= TEKWIDTH / 2;
    }
    tekscr->cur_Y = l * t->vsize;
}

static void
TCursorDown(TekWidget tw)
{
    TekScreen *tekscr = TekScreenOf(tw);
    const struct Tek_Char *t;
    int l;

    t = &TekChar[tekscr->cur.fontsize];

    if ((l = tekscr->cur_Y / t->vsize - 1) < 0) {
	l = t->nlines - 1;
	if ((tekscr->margin = !tekscr->margin) != MARGIN1) {
	    if (tekscr->cur_X < TEKWIDTH / 2)
		tekscr->cur_X += TEKWIDTH / 2;
	} else if (tekscr->cur_X >= TEKWIDTH / 2)
	    tekscr->cur_X -= TEKWIDTH / 2;
    }
    tekscr->cur_Y = l * t->vsize;
}

static void
AddToDraw(TekWidget tw, int x1, int y1, int x2, int y2)
{
    XSegment *lp;

    TRACE(("AddToDraw (%d,%d) (%d,%d)\n", x1, y1, x2, y2));
    if (nplot >= MAX_PTS) {
	TekFlush(tw);
    }
    lp = line_pt++;
    lp->x1 = (short) ScaledX(tw, x1);
    lp->y1 = (short) ScaledY(tw, y1);
    lp->x2 = (short) ScaledX(tw, x2);
    lp->y2 = (short) ScaledY(tw, y2);
    nplot++;
    TRACE(("...AddToDraw %d points\n", nplot));
}

static void
TekDraw(TekWidget tw, int x, int y)
{
    TekScreen *tekscr = TekScreenOf(tw);

    if (nplot == 0 || T_lastx != tekscr->cur_X || T_lasty != tekscr->cur_Y) {
	/*
	 * We flush on each unconnected line segment if the line
	 * type is not solid.  This solves a bug in X when drawing
	 * points while the line type is not solid.
	 */
	if (nplot > 0 && tekscr->cur.linetype != SOLIDLINE)
	    TekFlush(tw);
    }
    AddToDraw(tw, tekscr->cur_X, tekscr->cur_Y, x, y);
    T_lastx = tekscr->cur_X = x;
    T_lasty = tekscr->cur_Y = y;
}

static void
TekFlush(TekWidget tw)
{
    TekScreen *tekscr = TekScreenOf(tw);

    TRACE(("TekFlush\n"));
    XDrawSegments(XtDisplay(tw), TWindow(tekscr),
		  ((tekscr->cur.linetype == SOLIDLINE)
		   ? tekscr->TnormalGC
		   : tekscr->linepat[tekscr->cur.linetype - 1]),
		  Tline, nplot);
    nplot = 0;
    line_pt = Tline;
}

void
TekGINoff(TekWidget tw)
{
    TekScreen *tekscr = TekScreenOf(tw);

    TRACE(("TekGINoff\n"));
    XDefineCursor(XtDisplay(tw), TWindow(tekscr), tekscr->arrow);
    if (GINcursor)
	XFreeCursor(XtDisplay(tw), GINcursor);
    if (tekscr->TekGIN) {
	*tekscr->TekGIN = ANSI_CAN;	/* modify recording */
	tekscr->TekGIN = NULL;
    }
}

void
TekEnqMouse(TekWidget tw, int c)	/* character pressed */
{
    TekScreen *tekscr = TekScreenOf(tw);
    int mousex, mousey, rootx, rooty;
    unsigned int mask;		/* XQueryPointer */
    Window root, subw;

    TRACE(("TekEnqMouse\n"));
    XQueryPointer(
		     XtDisplay(tw), TWindow(tekscr),
		     &root, &subw,
		     &rootx, &rooty,
		     &mousex, &mousey,
		     &mask);
    if ((mousex = (int) ((mousex - BorderOf(tw)) / ScaleOf(tw))) < 0)
	mousex = 0;
    else if (mousex >= TEKWIDTH)
	mousex = TEKWIDTH - 1;
    if ((mousey = (int) BottomY((mousey - BorderOf(tw)) / ScaleOf(tw))) < 0)
	mousey = 0;
    else if (mousey >= TEKHEIGHT)
	mousey = TEKHEIGHT - 1;
    TekEnq(tw, (unsigned) c, mousex, mousey);
}

static void
TekEnq(TekWidget tw,
       unsigned status,
       int x,
       int y)
{
    TScreen *screen = TScreenOf(tw->vt);
    TekScreen *tekscr = TekScreenOf(tw);
    Char cplot[7];
    int len = 5;
    int adj = (status != 0) ? 0 : 1;

    TRACE(("TekEnq\n"));
    cplot[0] = (Char) status;
    /* Translate x and y to Tektronix code */
    cplot[1] = (Char) (040 | ((x >> SHIFTHI) & FIVEBITS));
    cplot[2] = (Char) (040 | ((x >> SHIFTLO) & FIVEBITS));
    cplot[3] = (Char) (040 | ((y >> SHIFTHI) & FIVEBITS));
    cplot[4] = (Char) (040 | ((y >> SHIFTLO) & FIVEBITS));

    if (tekscr->gin_terminator != GIN_TERM_NONE)
	cplot[len++] = '\r';
    if (tekscr->gin_terminator == GIN_TERM_EOT)
	cplot[len++] = '\004';
#ifdef VMS
    tt_write(cplot + adj, len - adj);
#else /* VMS */
    v_write(screen->respond, cplot + adj, (unsigned) (len - adj));
#endif /* VMS */
}

void
TekRun(void)
{
    XtermWidget xw = term;

    assert(xw != 0);
    if (tekWidget == 0) {
	TekInit();
    }
    if (tekWidget != 0) {
	TRACE(("TekRun ...\n"));

	if (!TEK4014_SHOWN(xw)) {
	    set_tek_visibility(True);
	}
	update_vttekmode();
	update_vtshow();
	update_tekshow();
	set_tekhide_sensitivity();

	Tpushback = Tpushb;
	Ttoggled = True;
	if (!setjmp(Tekend))
	    Tekparse(tekWidget);
	if (!Ttoggled) {
	    TCursorToggle(tekWidget, TOGGLE);
	    Ttoggled = True;
	}
	TEK4014_ACTIVE(xw) = False;
    } else {
	TEK4014_ACTIVE(xw) = False;
	if (VWindow(TScreenOf(xw)) == 0) {
	    Exit(ERROR_TINIT);
	}
    }
}

#define DOTTED_LENGTH 2
#define DOT_DASHED_LENGTH 4
#define SHORT_DASHED_LENGTH 2
#define LONG_DASHED_LENGTH 2

static const int dash_length[TEKNUMLINES] =
{
    DOTTED_LENGTH,
    DOT_DASHED_LENGTH,
    SHORT_DASHED_LENGTH,
    LONG_DASHED_LENGTH,
};

static _Xconst char dotted[DOTTED_LENGTH] =
{3, 1};
static _Xconst char dot_dashed[DOT_DASHED_LENGTH] =
{3, 4, 3, 1};
static _Xconst char short_dashed[SHORT_DASHED_LENGTH] =
{4, 4};
static _Xconst char long_dashed[LONG_DASHED_LENGTH] =
{4, 7};

static _Xconst char *dashes[TEKNUMLINES] =
{
    dotted,
    dot_dashed,
    short_dashed,
    long_dashed,
};

/*
 * The following functions are called to initialize and realize the tekWidget
 */
static void
TekInitialize(Widget wrequest,
	      Widget new_arg,
	      ArgList args GCC_UNUSED,
	      Cardinal *num_args GCC_UNUSED)
{
    XtermWidget xw = term;
    TScreen *vtscr = TScreenOf(xw);

    TekWidget request = (TekWidget) wrequest;
    TekWidget wnew = (TekWidget) new_arg;

    Widget tekparent = SHELL_OF(wnew);
    TekScreen *tekscr = TekScreenOf((TekWidget) wnew);

    int i;
    int border;
    int pr;
    int winX, winY;
    unsigned min_width, min_height;
    unsigned width, height;
    char Tdefault[32];

    (void) args;
    (void) num_args;

    TRACE(("TekInitialize {{\n"));
    memset(tekscr, 0, sizeof(*tekscr));

    /*
     * Eliminate 'term' as global from other functions.
     */
    wnew->vt = xw;
    border = 2 * BorderOf(wnew);
    TRACE(("... border*2: %d\n", border));

    /* look for focus related events on the shell, because we need
     * to care about the shell's border being part of our focus.
     */
    XtAddEventHandler(tekparent, EnterWindowMask, False,
		      HandleEnterWindow, (Opaque) 0);
    XtAddEventHandler(tekparent, LeaveWindowMask, False,
		      HandleLeaveWindow, (Opaque) 0);
    XtAddEventHandler(tekparent, FocusChangeMask, False,
		      HandleFocusChange, (Opaque) 0);
    XtAddEventHandler(new_arg, PropertyChangeMask, False,
		      HandleBellPropertyChange, (Opaque) 0);

#ifndef NO_ACTIVE_ICON
    tekscr->whichTwin = &(tekscr->fullTwin);
#endif /* NO_ACTIVE_ICON */

    init_Sres(tek.initial_font);
    init_Sres(tek.gin_terminator_str);
#if OPT_TOOLBAR
    init_Ires(tek.tb_info.menu_height);
    wnew->tek.tb_info.menu_bar = request->tek.tb_info.menu_bar;
#endif

    BorderPixel(wnew) = BorderPixel(xw);

    tekscr->arrow = make_colored_cursor(XC_left_ptr,
					T_COLOR(vtscr, MOUSE_FG),
					T_COLOR(vtscr, MOUSE_BG));

    for (i = 0; i < TEKNUMFONTS; i++) {
	if (!wnew->tek.Tfont[i]) {
	    wnew->tek.Tfont[i] = XQueryFont(XtDisplay(wnew), DefaultGCID(wnew));
	}
	if (wnew->tek.Tfont[i]) {
	    TRACE(("Tfont[%d] %dx%d\n",
		   i,
		   wnew->tek.Tfont[i]->max_bounds.width,
		   wnew->tek.Tfont[i]->ascent +
		   wnew->tek.Tfont[i]->descent));
	    wnew->tek.tobaseline[i] = wnew->tek.Tfont[i]->ascent;
	} else {
	    TRACE(("Tfont[%d] disabled\n", i));
	    SetItemSensitivity(tekMenuEntries[i].widget, False);
	}
    }

    if (xw->misc.T_geometry == NULL) {
	int def_width, def_height;

	if (xw->misc.tekSmall) {
	    def_width = TEKMINWIDTH;
	    def_height = TEKMINHEIGHT;
	} else {
	    def_width = TEKDEFWIDTH;
	    def_height = TEKDEFHEIGHT;
	}
	sprintf(Tdefault, "=%dx%d", def_width + border, def_height + border);
	xw->misc.T_geometry = Tdefault;
    }

    winX = 1;
    winY = 1;
    width = (unsigned) (TEKDEFWIDTH + border);
    height = (unsigned) (TEKDEFHEIGHT + border);
    min_width = (unsigned) (TEKMINWIDTH + border);
    min_height = (unsigned) (TEKMINHEIGHT + border);

    TRACE(("parsing T_geometry %s\n", NonNull(xw->misc.T_geometry)));
    pr = XParseGeometry(xw->misc.T_geometry,
			&winX,
			&winY,
			&width,
			&height);

    /* window-manager hints will do this anyway... */
    if (height < min_height) {
	TRACE(("... override height from %d to %d\n", height, min_height));
	height = min_height;
    }
    if (width < min_width) {
	TRACE(("... override width from %d to %d\n", width, min_width));
	width = min_width;
    }

    TRACE(("... position %d,%d size %dx%d\n", winY, winX, height, width));
    if ((pr & XValue) && (pr & XNegative)) {
	winX += DisplayWidth(XtDisplay(wnew), DefaultScreen(XtDisplay(wnew)))
	    - (int) width - (BorderWidth(SHELL_OF(xw)) * 2);
    }
    if ((pr & YValue) && (pr & YNegative)) {
	winY += DisplayHeight(XtDisplay(wnew), DefaultScreen(XtDisplay(wnew)))
	    - (int) height - (BorderWidth(SHELL_OF(xw)) * 2);
    }

    /* set up size hints */

    /* *INDENT-EQLS* */
    wnew->hints.min_width  = (int) min_width;
    wnew->hints.min_height = (int) min_height;
    wnew->hints.width_inc  = 1;
    wnew->hints.height_inc = 1;
    wnew->hints.flags      = PMinSize | PResizeInc;
    wnew->hints.x          = winX;
    wnew->hints.y          = winY;

    if ((XValue & pr) || (YValue & pr)) {
	wnew->hints.flags |= USSize | USPosition;
	wnew->hints.flags |= PWinGravity;
	switch (pr & (XNegative | YNegative)) {
	case 0:
	    wnew->hints.win_gravity = NorthWestGravity;
	    break;
	case XNegative:
	    wnew->hints.win_gravity = NorthEastGravity;
	    break;
	case YNegative:
	    wnew->hints.win_gravity = SouthWestGravity;
	    break;
	default:
	    wnew->hints.win_gravity = SouthEastGravity;
	    break;
	}
    } else {
	/* set a default size, but do *not* set position */
	wnew->hints.flags |= PSize;
    }
    wnew->hints.width = (int) width;
    wnew->hints.height = (int) height;
    if ((WidthValue & pr) || (HeightValue & pr))
	wnew->hints.flags |= USSize;
    else
	wnew->hints.flags |= PSize;

    tekscr->cur.fontsize = TEK_FONT_LARGE;
    if (wnew->tek.initial_font) {
	int result = TekGetFontSize(wnew->tek.initial_font);
	if (result >= 0)
	    tekscr->cur.fontsize = result;
    }
    TRACE(("Tek cur.fontsize=%d\n", tekscr->cur.fontsize));

#define TestGIN(s) XmuCompareISOLatin1(wnew->tek.gin_terminator_str, s)

    if (TestGIN(GIN_TERM_NONE_STR) == 0)
	tekscr->gin_terminator = GIN_TERM_NONE;
    else if (TestGIN(GIN_TERM_CR_STR) == 0)
	tekscr->gin_terminator = GIN_TERM_CR;
    else if (TestGIN(GIN_TERM_EOT_STR) == 0)
	tekscr->gin_terminator = GIN_TERM_EOT;
    else
	xtermWarning("illegal GIN terminator setting \"%s\"\n",
		     wnew->tek.gin_terminator_str);
    TRACE(("Tek gin_terminator=%d\n", tekscr->gin_terminator));

    TRACE(("}} TekInitialize\n"));
}

static void
TekRealize(Widget gw,
	   XtValueMask * valuemaskp,
	   XSetWindowAttributes * values)
{
    TekWidget tw = (TekWidget) gw;
    TekScreen *tekscr = TekScreenOf(tw);
    TScreen *vtscr = TScreenOf(tw->vt);

    int i;
    TekLink *tek;
    XGCValues gcv;
    unsigned width, height;
    unsigned long TEKgcFontMask;

    TRACE(("TekRealize {{\n"));

    if (!TekPtyData())
	return;

    /* use values from TekInitialize... */
    height = (unsigned) tw->hints.height;
    width = (unsigned) tw->hints.width;

    (void) REQ_RESIZE((Widget) tw,
		      (Dimension) width, (Dimension) height,
		      &tw->core.width, &tw->core.height);

    /* XXX This is bogus.  We are parsing geometries too late.  This
     * is information that the shell widget ought to have before we get
     * realized, so that it can do the right thing.
     */
    if (tw->hints.flags & USPosition)
	XMoveWindow(XtDisplay(tw), TShellWindow, tw->hints.x, tw->hints.y);

    XSetWMNormalHints(XtDisplay(tw), TShellWindow, &tw->hints);
    XFlush(XtDisplay(tw));	/* get it out to window manager */

    values->win_gravity = NorthWestGravity;
    values->background_pixel = T_COLOR(vtscr, TEK_BG);

    XtWindow(tw) = TWindow(tekscr) =
	XCreateWindow(XtDisplay(tw),
		      VShellWindow(tw),
		      tw->core.x, tw->core.y,
		      tw->core.width, tw->core.height,
		      BorderWidth(tw),
		      (int) tw->core.depth,
		      InputOutput, CopyFromParent,
		      ((*valuemaskp) | CWBackPixel | CWWinGravity),
		      values);

    compute_sizes(tw);

    gcv.graphics_exposures = True;	/* default */
    gcv.font = tw->tek.Tfont[tekscr->cur.fontsize]->fid;
    gcv.foreground = T_COLOR(vtscr, TEK_FG);
    gcv.background = T_COLOR(vtscr, TEK_BG);

    /* if font wasn't successfully opened, then gcv.font will contain
       the Default GC's ID, meaning that we must use the server default font.
     */
    TEKgcFontMask = (unsigned long) ((gcv.font == DefaultGCID(tw))
				     ? 0
				     : GCFont);
    tekscr->TnormalGC = XCreateGC(XtDisplay(tw), TWindow(tekscr),
				  (TEKgcFontMask | GCGraphicsExposures |
				   GCForeground | GCBackground),
				  &gcv);

    gcv.function = GXinvert;
    gcv.plane_mask = (T_COLOR(vtscr, TEK_BG) ^
		      T_COLOR(vtscr, TEK_CURSOR));
    gcv.join_style = JoinMiter;	/* default */
    gcv.line_width = 1;
    tekscr->TcursorGC = XCreateGC(XtDisplay(tw), TWindow(tekscr),
				  (GCFunction | GCPlaneMask), &gcv);

    gcv.foreground = T_COLOR(vtscr, TEK_FG);
    gcv.line_style = LineOnOffDash;
    gcv.line_width = 0;
    for (i = 0; i < TEKNUMLINES; i++) {
	tekscr->linepat[i] = XCreateGC(XtDisplay(tw), TWindow(tekscr),
				       (GCForeground | GCLineStyle), &gcv);
	XSetDashes(XtDisplay(tw), tekscr->linepat[i], 0,
		   dashes[i], dash_length[i]);
    }

    TekBackground(tw, vtscr);

    tekscr->margin = MARGIN1;	/* Margin 1             */
    tekscr->TekGIN = False;	/* GIN off              */

    XDefineCursor(XtDisplay(tw), TWindow(tekscr), tekscr->arrow);

    {				/* there's gotta be a better way... */
	static Arg args[] =
	{
	    {XtNtitle, (XtArgVal) NULL},
	    {XtNiconName, (XtArgVal) NULL},
	};
	char *icon_name, *title, *tek_icon_name, *tek_title;

	args[0].value = (XtArgVal) & icon_name;
	args[1].value = (XtArgVal) & title;
	XtGetValues(SHELL_OF(tw), args, 2);
	TRACE(("TekShell title='%s', iconName='%s'\n", title, icon_name));
	tek_icon_name = XtMalloc((Cardinal) strlen(icon_name) + 7);
	strcpy(tek_icon_name, icon_name);
	strcat(tek_icon_name, "(Tek)");
	tek_title = XtMalloc((Cardinal) strlen(title) + 7);
	strcpy(tek_title, title);
	strcat(tek_title, "(Tek)");
	args[0].value = (XtArgVal) tek_icon_name;
	args[1].value = (XtArgVal) tek_title;
	TRACE(("Tek title='%s', iconName='%s'\n", tek_title, tek_icon_name));
	XtSetValues(SHELL_OF(tw), args, 2);
	XtFree(tek_icon_name);
	XtFree(tek_title);
    }

    /* *INDENT-EQLS* */
    tek           = TekRecord = &Tek0;
    tek->next     = (TekLink *) 0;
    tek->fontsize = (unsigned short) tekscr->cur.fontsize;
    tek->count    = 0;
    tek->ptr      = tek->data;
    Tpushback     = Tpushb;
    tekscr->cur_X = 0;
    tekscr->cur_Y = TEKHOME;
    line_pt       = Tline;
    Ttoggled      = True;
    tekscr->page  = tekscr->cur;

    TRACE(("}} TekRealize\n"));
}

int
TekGetFontSize(const char *param)
{
    int result;

    if (XmuCompareISOLatin1(param, "l") == 0 ||
	XmuCompareISOLatin1(param, "large") == 0)
	result = TEK_FONT_LARGE;
    else if (XmuCompareISOLatin1(param, "2") == 0 ||
	     XmuCompareISOLatin1(param, "two") == 0)
	result = TEK_FONT_2;
    else if (XmuCompareISOLatin1(param, "3") == 0 ||
	     XmuCompareISOLatin1(param, "three") == 0)
	result = TEK_FONT_3;
    else if (XmuCompareISOLatin1(param, "s") == 0 ||
	     XmuCompareISOLatin1(param, "small") == 0)
	result = TEK_FONT_SMALL;
    else
	result = -1;

    return result;
}

void
TekSetFontSize(TekWidget tw, Bool fromMenu, int newitem)
{
    if (tw != 0) {
	TekScreen *tekscr = TekScreenOf(tw);
	int oldsize = tekscr->cur.fontsize;
	int newsize = MI2FS(newitem);
	Font fid;

	TRACE(("TekSetFontSize(%d) size %d ->%d\n", newitem, oldsize, newsize));
	if (newsize < 0 || newsize >= TEKNUMFONTS) {
	    Bell(tw->vt, XkbBI_MinorError, 0);
	} else if (oldsize != newsize) {
	    if (!Ttoggled)
		TCursorToggle(tw, TOGGLE);
	    set_tekfont_menu_item(oldsize, False);

	    tekscr->cur.fontsize = newsize;
	    TekSetWinSize(tw);
	    if (fromMenu)
		tekscr->page.fontsize = newsize;

	    fid = tw->tek.Tfont[newsize]->fid;
	    if (fid == DefaultGCID(tw)) {
		/* we didn't succeed in opening a real font
		   for this size.  Instead, use server default. */
		XCopyGC(XtDisplay(tw),
			DefaultGC(XtDisplay(tw), DefaultScreen(XtDisplay(tw))),
			GCFont, tekscr->TnormalGC);
	    } else {
		XSetFont(XtDisplay(tw), tekscr->TnormalGC, fid);
	    }

	    set_tekfont_menu_item(newsize, True);
	    if (!Ttoggled)
		TCursorToggle(tw, TOGGLE);

	    if (fromMenu) {
		/* we'll get an exposure event after changing fontsize, so we
		 * have to clear the screen to avoid painting over the previous
		 * text.
		 */
		TekClear(tw);
	    }
	}
    }
}

void
ChangeTekColors(TekWidget tw, TScreen *screen, ScrnColors * pNew)
{
    TekScreen *tekscr = TekScreenOf(tw);
    XGCValues gcv;

    if (COLOR_DEFINED(pNew, TEK_FG)) {
	T_COLOR(screen, TEK_FG) = COLOR_VALUE(pNew, TEK_FG);
	TRACE(("... TEK_FG: %#lx\n", T_COLOR(screen, TEK_FG)));
    }
    if (COLOR_DEFINED(pNew, TEK_BG)) {
	T_COLOR(screen, TEK_BG) = COLOR_VALUE(pNew, TEK_BG);
	TRACE(("... TEK_BG: %#lx\n", T_COLOR(screen, TEK_BG)));
    }
    if (COLOR_DEFINED(pNew, TEK_CURSOR)) {
	T_COLOR(screen, TEK_CURSOR) = COLOR_VALUE(pNew, TEK_CURSOR);
	TRACE(("... TEK_CURSOR: %#lx\n", T_COLOR(screen, TEK_CURSOR)));
    } else {
	T_COLOR(screen, TEK_CURSOR) = T_COLOR(screen, TEK_FG);
	TRACE(("... TEK_CURSOR: %#lx\n", T_COLOR(screen, TEK_CURSOR)));
    }

    if (tw) {
	int i;

	XSetForeground(XtDisplay(tw), tekscr->TnormalGC,
		       T_COLOR(screen, TEK_FG));
	XSetBackground(XtDisplay(tw), tekscr->TnormalGC,
		       T_COLOR(screen, TEK_BG));
	if (BorderPixel(tw) == T_COLOR(screen, TEK_BG)) {
	    BorderPixel(tw) = T_COLOR(screen, TEK_FG);
	    BorderPixel(XtParent(tw)) = T_COLOR(screen, TEK_FG);
	    if (XtWindow(XtParent(tw)))
		XSetWindowBorder(XtDisplay(tw),
				 XtWindow(XtParent(tw)),
				 BorderPixel(tw));
	}

	for (i = 0; i < TEKNUMLINES; i++) {
	    XSetForeground(XtDisplay(tw), tekscr->linepat[i],
			   T_COLOR(screen, TEK_FG));
	}

	gcv.plane_mask = (T_COLOR(screen, TEK_BG) ^
			  T_COLOR(screen, TEK_CURSOR));
	XChangeGC(XtDisplay(tw), tekscr->TcursorGC, GCPlaneMask, &gcv);
	TekBackground(tw, screen);
    }
    return;
}

void
TekReverseVideo(XtermWidget xw, TekWidget tw)
{
    TScreen *screen = TScreenOf(xw);
    TekScreen *tekscr = TekScreenOf(tw);
    Pixel tmp;
    XGCValues gcv;

    EXCHANGE(T_COLOR(screen, TEK_FG), T_COLOR(screen, TEK_BG), tmp);

    T_COLOR(screen, TEK_CURSOR) = T_COLOR(screen, TEK_FG);

    if (tw) {
	int i;

	XSetForeground(XtDisplay(tw), tekscr->TnormalGC, T_COLOR(screen, TEK_FG));
	XSetBackground(XtDisplay(tw), tekscr->TnormalGC, T_COLOR(screen, TEK_BG));

	if (BorderPixel(tw) == T_COLOR(screen, TEK_BG)) {
	    BorderPixel(tw) = T_COLOR(screen, TEK_FG);
	    BorderPixel(XtParent(tw)) = T_COLOR(screen, TEK_FG);
	    if (XtWindow(XtParent(tw)))
		XSetWindowBorder(XtDisplay(tw),
				 XtWindow(XtParent(tw)),
				 BorderPixel(tw));
	}

	for (i = 0; i < TEKNUMLINES; i++) {
	    XSetForeground(XtDisplay(tw), tekscr->linepat[i],
			   T_COLOR(screen, TEK_FG));
	}

	gcv.plane_mask = (T_COLOR(screen, TEK_BG) ^
			  T_COLOR(screen, TEK_CURSOR));
	XChangeGC(XtDisplay(tw), tekscr->TcursorGC, GCPlaneMask, &gcv);
	TekBackground(tw, screen);
    }
}

static void
TekBackground(TekWidget tw, TScreen *screen)
{
    TekScreen *tekscr = TekScreenOf(tw);

    if (TWindow(tekscr))
	XSetWindowBackground(XtDisplay(tw), TWindow(tekscr),
			     T_COLOR(screen, TEK_BG));
}

/*
 * Toggles cursor on or off at cursor position in screen.
 */
void
TCursorToggle(TekWidget tw, int toggle)		/* TOGGLE or CLEAR */
{
    TekScreen *tekscr = TekScreenOf(tw);
    TScreen *screen = TScreenOf(tw->vt);
    int c, x, y;
    unsigned int cellwidth, cellheight;

    if (!TEK4014_SHOWN(tw->vt))
	return;

    TRACE(("TCursorToggle %s\n", (toggle == TOGGLE) ? "toggle" : "clear"));
    c = tekscr->cur.fontsize;
    cellwidth = (unsigned) tw->tek.Tfont[c]->max_bounds.width;
    cellheight = (unsigned) (tw->tek.Tfont[c]->ascent +
			     tw->tek.Tfont[c]->descent);

    x = (int) ScaledX(tw, tekscr->cur_X);
    y = (int) ScaledY(tw, tekscr->cur_Y) - tw->tek.tobaseline[c];

    if (toggle == TOGGLE) {
	if (screen->select || screen->always_highlight)
	    XFillRectangle(XtDisplay(tw), TWindow(tekscr),
			   tekscr->TcursorGC, x, y,
			   cellwidth, cellheight);
	else {			/* fix to use different GC! */
	    XDrawRectangle(XtDisplay(tw), TWindow(tekscr),
			   tekscr->TcursorGC, x, y,
			   cellwidth - 1, cellheight - 1);
	}
    } else {
	/* Clear the entire rectangle, even though we may only
	 * have drawn an outline.  This fits with our refresh
	 * scheme of redrawing the entire window on any expose
	 * event and is easier than trying to figure out exactly
	 * which part of the cursor needs to be erased.
	 */
	XClearArea(XtDisplay(tw), TWindow(tekscr), x, y,
		   cellwidth, cellheight, False);
    }
}

void
TekSimulatePageButton(TekWidget tw, Bool reset)
{
    if (tw != 0) {
	TekScreen *tekscr = TekScreenOf(tw);

	if (reset) {
	    memset(&tekscr->cur, 0, sizeof tekscr->cur);
	}
	tekRefreshList = (TekLink *) 0;
	TekPage(tw);
	tekscr->cur_X = 0;
	tekscr->cur_Y = TEKHOME;
    }
}

/* write copy of screen to a file */

void
TekCopy(TekWidget tw)
{
    if (tw != 0) {
	TekScreen *tekscr = TekScreenOf(tw);
	TScreen *screen = TScreenOf(tw->vt);

	TekLink *Tp;
	char buf[TIMESTAMP_LEN + 10];
	int tekcopyfd;

	timestamp_filename(buf, "COPY");
	if (access(buf, F_OK) >= 0
	    && access(buf, W_OK) < 0) {
	    Bell(tw->vt, XkbBI_MinorError, 0);
	    return;
	}
#ifndef VMS
	if (access(".", W_OK) < 0) {	/* can't write in directory */
	    Bell(tw->vt, XkbBI_MinorError, 0);
	    return;
	}
#endif

	tekcopyfd = open_userfile(screen->uid, screen->gid, buf, False);
	if (tekcopyfd >= 0) {
	    char initbuf[5];

	    sprintf(initbuf, "%c%c%c%c",
		    ANSI_ESC, (char) (tekscr->page.fontsize + '8'),
		    ANSI_ESC, (char) (tekscr->page.linetype + '`'));
	    IGNORE_RC(write(tekcopyfd, initbuf, (size_t) 4));
	    Tp = &Tek0;
	    do {
		IGNORE_RC(write(tekcopyfd, Tp->data, (size_t) Tp->count));
		Tp = Tp->next;
	    } while (Tp);
	    close(tekcopyfd);
	}
    }
}

/*ARGSUSED*/
void
HandleGINInput(Widget w,
	       XEvent *event GCC_UNUSED,
	       String *param_list,
	       Cardinal *nparamsp)
{
    TekWidget tw = getTekWidget(w);

    if (tw != 0) {
	TekScreen *tekscr = TekScreenOf(tw);

	if (tekscr->TekGIN && *nparamsp == 1) {
	    int c = param_list[0][0];
	    switch (c) {
	    case 'l':
	    case 'm':
	    case 'r':
	    case 'L':
	    case 'M':
	    case 'R':
		break;
	    default:
		Bell(tw->vt, XkbBI_MinorError, 0);	/* let them know they goofed */
		c = 'l';	/* provide a default */
	    }
	    TekEnqMouse(tw, c | 0x80);
	    TekGINoff(tw);
	} else {
	    Bell(tw->vt, XkbBI_MinorError, 0);
	}
    }
}

/*
 * Check if the current widget, or any parent, is the VT100 "xterm" widget.
 */
TekWidget
getTekWidget(Widget w)
{
    TekWidget tw;

    if (w == 0) {
	tw = (TekWidget) CURRENT_EMU();
	if (!IsTekWidget(tw)) {
	    tw = 0;
	}
    } else if (IsTekWidget(w)) {
	tw = (TekWidget) w;
    } else {
	tw = getTekWidget(XtParent(w));
    }
    TRACE2(("getTekWidget %p -> %p\n", w, tw));
    return tw;
}
@


1.24
log
@Update to xterm-325. Testing by krw@@, shadchin@@ and naddy@@. Thanks
@
text
@d1 1
a1 1
/* $XTermId: Tekproc.c,v 1.199 2016/05/16 09:14:46 tom Exp $ */
d4 1
a4 1
 * Copyright 2001-2014,2016 by Thomas E. Dickey
d114 3
a116 1
#define DefaultGCID XGContextFromGC(DefaultGC(XtDisplay(tw), DefaultScreen(XtDisplay(tw))))
d120 5
d126 8
a133 2
#define	DOTTEDLINE	1
#define	EAST		01
a134 1
#define	LONGDASHEDLINE	4
a138 1
#define	NORTH		04
a140 3
#define	SHORTDASHEDLINE	3
#define	SOLIDLINE	0
#define	SOUTH		010
d151 8
a158 1
#define	WEST		02
d294 1
a294 1
static void TekConfigure(Widget /* w */ );
d317 1
a317 1
	"Tek4014",		/* class_name                   */
d335 1
a335 1
	TekConfigure,		/* resize                       */
d354 5
d393 1
a393 1
	    XtVaCreateManagedWidget("tek4014",
d416 1
a416 1
int
d419 1
a419 1
    if (Tpushb == 0) {
a425 1
	    return 0;
d428 1
a428 1
    return 1;
a433 2
    XtermWidget xw = term;
    TScreen *screen = TScreenOf(xw);
d435 1
d477 1
a477 1
	    FlushLog(xw);
d506 1
a506 1
		Bell(xw, XkbBI_TerminalBell, 0);
d728 2
a729 4
	    x = (int) (tekscr->cur_X * TekScale(tekscr))
		+ screen->border;
	    y = (int) ((TEKHEIGHT + TEKTOPPAD - tekscr->cur_Y) * TekScale(tekscr))
		+ screen->border;
d782 1
a782 1
			do_osc(xw, buf2, len, ANSI_BEL);
a798 1
    XtermWidget xw = term;
d800 1
a800 1
    TScreen *screen = TScreenOf(xw);
d838 1
a838 1
	    if (readPtyData(xw, &Tselect_mask, VTbuffer)) {
d917 16
a932 1
/* this should become the Tek Widget's Resize proc */
d934 41
a974 1
TekConfigure(Widget w)
a977 5
	XtermWidget xw = term;
	TekScreen *tekscr = TekScreenOf(tw);
	TScreen *screen = TScreenOf(xw);
	int border = 2 * screen->border;
	double d;
d979 1
a979 1
	TRACE(("TekConfigure\n"));
d981 4
a984 8
	TWidth(tekscr) = w->core.width - border;
	THeight(tekscr) = w->core.height - border;
	TekScale(tekscr) = (double) TWidth(tekscr) / TEKWIDTH;
	if ((d = (double) THeight(tekscr) / (TEKHEIGHT + TEKTOPPAD + TEKBOTTOMPAD))
	    < TekScale(tekscr))
	    TekScale(tekscr) = d;
	TFullWidth(tekscr) = w->core.width;
	TFullHeight(tekscr) = w->core.height;
d1032 1
a1032 2
	XtermWidget xw = term;
	TScreen *screen = TScreenOf(xw);
a1223 3
    XtermWidget xw = term;
    TScreen *screen = TScreenOf(xw);
    TekScreen *tekscr = TekScreenOf(tw);
d1231 4
a1234 6
    lp->x1 = (short) (x1 * TekScale(tekscr) + screen->border);
    lp->y1 = (short) ((TEKHEIGHT + TEKTOPPAD - y1) * TekScale(tekscr) +
		      screen->border);
    lp->x2 = (short) (x2 * TekScale(tekscr) + screen->border);
    lp->y2 = (short) ((TEKHEIGHT + TEKTOPPAD - y2) * TekScale(tekscr) +
		      screen->border);
a1290 2
    XtermWidget xw = term;
    TScreen *screen = TScreenOf(xw);
d1303 1
a1303 1
    if ((mousex = (int) ((mousex - screen->border) / TekScale(tekscr))) < 0)
d1307 1
a1307 2
    if ((mousey = (int) (TEKHEIGHT + TEKTOPPAD - (mousey - screen->border) /
			 TekScale(tekscr))) < 0)
d1320 1
a1320 2
    XtermWidget xw = term;
    TScreen *screen = TScreenOf(xw);
d1413 1
a1413 1
 * The following is called to create the tekWidget
a1414 1

d1421 3
d1426 1
d1428 15
a1442 4
#ifndef NO_ACTIVE_ICON
    TekScreen *screen = TekScreenOf((TekWidget) wnew);
#endif
    int n;
d1444 6
a1449 1
    TRACE(("TekInitialize\n"));
d1464 1
a1464 1
    screen->whichTwin = &(screen->fullTwin);
a1466 4
    for (n = 0; n < TEKNUMFONTS; ++n) {
	wnew->tek.Tfont[n] = request->tek.Tfont[n];
    }

a1472 1
}
d1474 1
a1474 28
static void
TekRealize(Widget gw,
	   XtValueMask * valuemaskp,
	   XSetWindowAttributes * values)
{
    XtermWidget xw = term;
    TScreen *screen = TScreenOf(xw);
    TekWidget tw = (TekWidget) gw;
    TekScreen *tekscr = TekScreenOf(tw);
    int i;
    TekLink *tek;
    double d;
    int border = 2 * screen->border;
    int pr;
    XGCValues gcv;
    int winX, winY;
    unsigned width, height;
    char Tdefault[32];
    unsigned long TEKgcFontMask;

    TRACE(("TekRealize\n"));
    memset(tekscr, 0, sizeof(*tekscr));

#ifndef NO_ACTIVE_ICON
    tekscr->whichTwin = &tekscr->fullTwin;
#endif /* NO_ACTIVE_ICON */

    BorderPixel(tw) = BorderPixel(xw);
d1477 2
a1478 2
					T_COLOR(screen, MOUSE_FG),
					T_COLOR(screen, MOUSE_BG));
d1481 13
a1493 2
	if (!tw->tek.Tfont[i]) {
	    tw->tek.Tfont[i] = XQueryFont(XtDisplay(tw), DefaultGCID);
a1494 6
	TRACE(("Tfont[%d] %dx%d\n",
	       i,
	       tw->tek.Tfont[i]->ascent +
	       tw->tek.Tfont[i]->descent,
	       tw->tek.Tfont[i]->max_bounds.width));
	tw->tek.tobaseline[i] = tw->tek.Tfont[i]->ascent;
a1496 3
    if (!TekPtyData())
	return;

d1498 1
a1498 1
	int defwidth, defheight;
d1501 2
a1502 2
	    defwidth = TEKMINWIDTH;
	    defheight = TEKMINHEIGHT;
d1504 2
a1505 2
	    defwidth = TEKDEFWIDTH;
	    defheight = TEKDEFHEIGHT;
d1507 1
a1507 1
	sprintf(Tdefault, "=%dx%d", defwidth + border, defheight + border);
d1515 2
d1524 11
d1536 2
a1537 2
    if ((pr & XValue) && (pr & XNegative))
	winX += DisplayWidth(XtDisplay(tw), DefaultScreen(XtDisplay(tw)))
d1539 3
a1541 2
    if ((pr & YValue) && (pr & YNegative))
	winY += DisplayHeight(XtDisplay(tw), DefaultScreen(XtDisplay(tw)))
d1543 1
d1546 10
a1555 7
    tw->hints.min_width = TEKMINWIDTH + border;
    tw->hints.min_height = TEKMINHEIGHT + border;
    tw->hints.width_inc = 1;
    tw->hints.height_inc = 1;
    tw->hints.flags = PMinSize | PResizeInc;
    tw->hints.x = winX;
    tw->hints.y = winY;
d1557 2
a1558 2
	tw->hints.flags |= USSize | USPosition;
	tw->hints.flags |= PWinGravity;
d1561 1
a1561 1
	    tw->hints.win_gravity = NorthWestGravity;
d1564 1
a1564 1
	    tw->hints.win_gravity = NorthEastGravity;
d1567 1
a1567 1
	    tw->hints.win_gravity = SouthWestGravity;
d1570 1
a1570 1
	    tw->hints.win_gravity = SouthEastGravity;
d1575 1
a1575 1
	tw->hints.flags |= PSize;
d1577 2
a1578 2
    tw->hints.width = (int) width;
    tw->hints.height = (int) height;
d1580 1
a1580 1
	tw->hints.flags |= USSize;
d1582 49
a1630 1
	tw->hints.flags |= PSize;
d1647 1
a1647 1
    values->background_pixel = T_COLOR(screen, TEK_BG);
d1660 1
a1660 26
    TFullWidth(tekscr) = (Dimension) width;
    TFullHeight(tekscr) = (Dimension) height;
    TWidth(tekscr) = (int) width - border;
    THeight(tekscr) = (int) height - border;
    TekScale(tekscr) = (double) TWidth(tekscr) / TEKWIDTH;
    if ((d = (double) THeight(tekscr) / (TEKHEIGHT + TEKTOPPAD +
					 TEKBOTTOMPAD)) < TekScale(tekscr))
	TekScale(tekscr) = d;

    tekscr->cur.fontsize = TEK_FONT_LARGE;
    if (tw->tek.initial_font) {
	int result = TekGetFontSize(tw->tek.initial_font);
	if (result >= 0)
	    tekscr->cur.fontsize = result;
    }
#define TestGIN(s) XmuCompareISOLatin1(tw->tek.gin_terminator_str, s)

    if (TestGIN(GIN_TERM_NONE_STR) == 0)
	tekscr->gin_terminator = GIN_TERM_NONE;
    else if (TestGIN(GIN_TERM_CR_STR) == 0)
	tekscr->gin_terminator = GIN_TERM_CR;
    else if (TestGIN(GIN_TERM_EOT_STR) == 0)
	tekscr->gin_terminator = GIN_TERM_EOT;
    else
	xtermWarning("illegal GIN terminator setting \"%s\"\n",
		     tw->tek.gin_terminator_str);
d1664 2
a1665 2
    gcv.foreground = T_COLOR(screen, TEK_FG);
    gcv.background = T_COLOR(screen, TEK_BG);
d1670 3
a1672 1
    TEKgcFontMask = (unsigned long) ((gcv.font == DefaultGCID) ? 0 : GCFont);
d1679 2
a1680 2
    gcv.plane_mask = (T_COLOR(screen, TEK_BG) ^
		      T_COLOR(screen, TEK_CURSOR));
d1686 1
a1686 1
    gcv.foreground = T_COLOR(screen, TEK_FG);
d1696 1
a1696 1
    TekBackground(tw, screen);
d1714 1
d1723 1
d1729 3
a1731 2
    tek = TekRecord = &Tek0;
    tek->next = (TekLink *) 0;
d1733 3
a1735 3
    tek->count = 0;
    tek->ptr = tek->data;
    Tpushback = Tpushb;
d1738 5
a1742 4
    line_pt = Tline;
    Ttoggled = True;
    tekscr->page = tekscr->cur;
    return;
a1771 1
	XtermWidget xw = term;
d1779 1
a1779 1
	    Bell(xw, XkbBI_MinorError, 0);
d1786 1
d1791 1
a1791 1
	    if (fid == DefaultGCID) {
d1868 1
a1868 1
TekReverseVideo(TekWidget tw)
a1869 1
    XtermWidget xw = term;
a1921 1
    XtermWidget xw = term;
d1923 1
a1923 1
    TScreen *screen = TScreenOf(xw);
d1927 1
a1927 1
    if (!TEK4014_SHOWN(xw))
d1936 2
a1937 3
    x = (int) ((tekscr->cur_X * TekScale(tekscr)) + screen->border);
    y = (int) (((TEKHEIGHT + TEKTOPPAD - tekscr->cur_Y) * TekScale(tekscr))
	       + screen->border - tw->tek.tobaseline[c]);
a1982 1
	XtermWidget xw = term;
d1984 1
a1984 1
	TScreen *screen = TScreenOf(xw);
d1993 1
a1993 1
	    Bell(xw, XkbBI_MinorError, 0);
d1998 1
a1998 1
	    Bell(xw, XkbBI_MinorError, 0);
a2027 1
    XtermWidget xw = term;
d2044 1
a2044 1
		Bell(xw, XkbBI_MinorError, 0);	/* let them know they goofed */
d2050 1
a2050 1
	    Bell(xw, XkbBI_MinorError, 0);
d2061 1
a2061 1
    TekWidget xw;
d2064 3
a2066 3
	xw = (TekWidget) CURRENT_EMU();
	if (!IsTekWidget(xw)) {
	    xw = 0;
d2069 1
a2069 1
	xw = (TekWidget) w;
d2071 1
a2071 1
	xw = getTekWidget(XtParent(w));
d2073 2
a2074 2
    TRACE2(("getTekWidget %p -> %p\n", w, xw));
    return xw;
@


1.23
log
@Update to xterm-309. Version 308 tested by several people including
naddy@@ who found a small regression, fixed in 309.
@
text
@d1 1
a1 1
/* $XTermId: Tekproc.c,v 1.198 2014/07/12 22:55:02 tom Exp $ */
d4 1
a4 1
 * Copyright 2001-2012,2014 by Thomas E. Dickey
a418 1
    IChar c = 0;
d423 1
a423 1
	c = input();
d1040 1
a1040 1
    int c, x, y, e, lo_y = 0;
d1045 1
d1047 2
d1090 1
a1090 5
    int x, l;

    x = (tekscr->cur_X -=
	 (t = &TekChar[tekscr->cur.fontsize])->hsize
	);
d1094 2
a1095 2
	if ((l = (tekscr->cur_Y + (t->vsize - 1)) / t->vsize + 1) >=
	    t->nlines) {
d1108 1
a1108 2
    const struct Tek_Char *t;
    int l;
d1110 3
a1112 5
    if ((tekscr->cur_X +=
	 (t = &TekChar[tekscr->cur.fontsize])->hsize
	) > TEKWIDTH
	) {
	if ((l = tekscr->cur_Y / t->vsize - 1) < 0) {
a1732 1
    int i;
d1752 2
a1785 1
    int i;
d1794 2
a1904 1
	char initbuf[5];
d1922 2
@


1.22
log
@Update to xterm 304. With help of shadchin@@

tested by ajacoutot@@ and shadchin@@
@
text
@d1 1
a1 1
/* $XTermId: Tekproc.c,v 1.196 2014/04/12 00:55:22 tom Exp $ */
d93 2
d931 1
a931 1
	  XEvent * event GCC_UNUSED,
d1943 1
a1943 1
	       XEvent * event GCC_UNUSED,
@


1.21
log
@Update to xterm-300. Tested  by ajacoutot@@ and shadchin@@.
@
text
@d1 1
a1 1
/* $XTermId: Tekproc.c,v 1.194 2012/09/07 09:08:44 tom Exp $ */
d4 1
a4 1
 * Copyright 2001-2011,2012 by Thomas E. Dickey
d147 1
a147 1
static struct Tek_Char {
d190 2
a191 2
    { "string",	HandleStringEvent },
    { "insert",	HandleKeyPressed },	/* alias for insert-seven-bit */
d1085 1
a1085 1
    struct Tek_Char *t;
d1108 1
a1108 1
    struct Tek_Char *t;
d1128 1
a1128 1
    struct Tek_Char *t;
d1148 1
a1148 1
    struct Tek_Char *t;
d1339 1
a1339 1
static int dash_length[TEKNUMLINES] =
d1347 1
a1347 1
static unsigned char dotted[DOTTED_LENGTH] =
d1349 1
a1349 1
static unsigned char dot_dashed[DOT_DASHED_LENGTH] =
d1351 1
a1351 1
static unsigned char short_dashed[SHORT_DASHED_LENGTH] =
d1353 1
a1353 1
static unsigned char long_dashed[LONG_DASHED_LENGTH] =
d1356 1
a1356 1
static unsigned char *dashes[TEKNUMLINES] =
d1613 1
a1613 1
		   (char *) dashes[i], dash_length[i]);
d1733 1
a1733 1
ChangeTekColors(TekWidget tw, TScreen * screen, ScrnColors * pNew)
d1822 1
a1822 1
TekBackground(TekWidget tw, TScreen * screen)
d1942 1
a1942 1
	       String * param_list,
@


1.20
log
@Update to xterm 287. tested by mpi@@ and krw@@.
@
text
@d1 1
a1 1
/* $XTermId: Tekproc.c,v 1.193 2012/09/07 09:08:44 tom Exp $ */
d4 1
a4 1
 * Copyright 2001-2010,2011 by Thomas E. Dickey
@


1.19
log
@Update to xterm 278. Tested by mpi@@, shadchin@@
@
text
@d1 1
a1 1
/* $XTermId: Tekproc.c,v 1.191 2011/12/27 10:19:51 tom Exp $ */
d894 3
d913 1
d1002 1
@


1.18
log
@Update to xterm-275. Tested by jasper@@.
@
text
@d1 1
a1 1
/* $XTermId: Tekproc.c,v 1.190 2011/09/03 12:13:42 tom Exp $ */
d400 1
a400 1
	    fprintf(stderr, "%s: Not enough core for Tek mode\n", ProgramName);
d1576 2
a1577 2
	fprintf(stderr, "%s: illegal GIN terminator setting \"%s\"\n",
		ProgramName, tw->tek.gin_terminator_str);
@


1.17
log
@Update to xterm 271. Tested by shadchin@@ and ajacoutot@@
@
text
@d1 1
a1 1
/* $XTermId: Tekproc.c,v 1.189 2011/07/10 22:19:32 tom Exp $ */
d829 1
a829 1
	    if (XtAppPending(app_con) & XtIMXEvent) {
@


1.16
log
@Update to xterm version 269.
Tested and ok ajacoutot@@, jasper@@, krw@@, shadchin@@
@
text
@d1 1
a1 1
/* $XTermId: Tekproc.c,v 1.188 2011/02/20 00:55:33 tom Exp $ */
d1900 1
a1900 1
	char buf[32];
@


1.15
log
@Update to xterm version 264, Tested at least by krw@@, jasper@@, ajacoutot@@.
@
text
@d1 1
a1 1
/* $XTermId: Tekproc.c,v 1.184 2010/10/14 08:07:03 tom Exp $ */
d4 1
a4 2
 *
 * Copyright 2001-2009,2010 by Thomas E. Dickey
d400 1
a400 1
	    fprintf(stderr, "%s: Not enough core for Tek mode\n", xterm_name);
d603 2
a604 1
	    if ((c &= LINEMASK) != tekscr->cur.linetype) {
d1543 1
a1543 1
		      XtWindow(SHELL_OF(tw)),
d1577 1
a1577 1
		xterm_name, tw->tek.gin_terminator_str);
@


1.14
log
@Update to xterm 261. Tested by krw@@, jcs@@.
@
text
@d1 1
a1 1
/* $XTermId: Tekproc.c,v 1.182 2010/06/20 21:34:37 tom Exp $ */
d111 1
d1364 2
a1365 2
TekInitialize(Widget request GCC_UNUSED,
	      Widget wnew GCC_UNUSED,
d1369 2
d1375 1
d1388 1
a1388 1
    XtAddEventHandler(wnew, PropertyChangeMask, False,
d1395 10
@


1.13
log
@Update to xterm 258. lightly tested by krw@@, thanks.
@
text
@d1 1
a1 1
/* $XTermId: Tekproc.c,v 1.176 2010/04/18 16:22:54 tom Exp $ */
d4 51
a54 55
 * Warning, there be crufty dragons here.
 */

/*

Copyright 2001-2008,2009 by Thomas E. Dickey

                        All Rights Reserved

Permission is hereby granted, free of charge, to any person obtaining a
copy of this software and associated documentation files (the
"Software"), to deal in the Software without restriction, including
without limitation the rights to use, copy, modify, merge, publish,
distribute, sublicense, and/or sell copies of the Software, and to
permit persons to whom the Software is furnished to do so, subject to
the following conditions:

The above copyright notice and this permission notice shall be included
in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
IN NO EVENT SHALL THE ABOVE LISTED COPYRIGHT HOLDER(S) BE LIABLE FOR ANY
CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

Except as contained in this notice, the name(s) of the above copyright
holders shall not be used in advertising or otherwise to promote the
sale, use or other dealings in this Software without prior written
authorization.

Copyright 1988  The Open Group

Permission to use, copy, modify, distribute, and sell this software and its
documentation for any purpose is hereby granted without fee, provided that
the above copyright notice appear in all copies and that both that
copyright notice and this permission notice appear in supporting
documentation.

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
OPEN GROUP BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

Except as contained in this notice, the name of The Open Group shall not be
used in advertising or otherwise to promote the sale, use or other dealings
in this Software without prior written authorization from The Open Group.

d102 1
d413 2
a414 1
    TScreen *screen = TScreenOf(term);
d458 1
a458 1
	    FlushLog(TScreenOf(term));
d487 1
a487 1
		Bell(XkbBI_TerminalBell, 0);
a707 1
	    c = (IChar) tekscr->cur.fontsize;
d764 1
a764 1
			do_osc(term, buf2, len, ANSI_BEL);
d781 1
d783 1
a783 1
    TScreen *screen = TScreenOf(term);
d821 1
a821 1
	    if (readPtyData(screen, &Tselect_mask, VTbuffer)) {
d872 1
a872 1
	if ((TekRecord = tek->next = CastMalloc(TekLink)) == 0)
d874 7
a880 5
	tek = tek->next;
	tek->next = (TekLink *) 0;
	tek->fontsize = (unsigned short) tekscr->cur.fontsize;
	tek->count = 0;
	tek->ptr = tek->data;
d903 1
d905 1
a905 1
	TScreen *screen = TScreenOf(term);
d965 2
a967 1
	TScreen *screen = TScreenOf(term);
d1161 2
a1163 1
    TScreen *screen = TScreenOf(term);
d1233 2
a1235 1
    TScreen *screen = TScreenOf(term);
d1265 2
a1267 1
    TScreen *screen = TScreenOf(term);
d1294 3
d1303 1
a1303 1
	if (!TEK4014_SHOWN(term)) {
d1319 1
a1319 1
	TEK4014_ACTIVE(term) = False;
d1321 2
a1322 2
	TEK4014_ACTIVE(term) = False;
	if (VWindow(TScreenOf(term)) == 0) {
d1398 2
a1401 1
    TScreen *screen = TScreenOf(term);
d1420 1
a1420 1
    BorderPixel(tw) = BorderPixel(term);
d1441 1
a1441 1
    if (term->misc.T_geometry == NULL) {
d1444 1
a1444 1
	if (term->misc.tekSmall) {
d1452 1
a1452 1
	term->misc.T_geometry = Tdefault;
d1460 2
a1461 2
    TRACE(("parsing T_geometry %s\n", NonNull(term->misc.T_geometry)));
    pr = XParseGeometry(term->misc.T_geometry,
d1469 1
a1469 1
	    - (int) width - (BorderWidth(SHELL_OF(term)) * 2);
d1472 1
a1472 1
	    - (int) height - (BorderWidth(SHELL_OF(term)) * 2);
d1669 1
d1677 1
a1677 1
	    Bell(XkbBI_MinorError, 0);
d1766 2
a1767 1
    TScreen *screen = TScreenOf(term);
d1818 1
d1820 1
a1820 1
    TScreen *screen = TScreenOf(term);
d1824 1
a1824 1
    if (!TEK4014_SHOWN(term))
d1881 1
d1883 1
a1883 1
	TScreen *screen = TScreenOf(term);
d1893 1
a1893 1
	    Bell(XkbBI_MinorError, 0);
d1898 1
a1898 1
	    Bell(XkbBI_MinorError, 0);
d1926 1
d1928 1
d1943 1
a1943 1
		Bell(XkbBI_MinorError, 0);	/* let them know they goofed */
d1949 1
a1949 1
	    Bell(XkbBI_MinorError, 0);
@


1.12
log
@Update to xterm-255. Tested by stsp@@, oga@@.
@
text
@d1 1
a1 1
/* $XTermId: Tekproc.c,v 1.175 2009/12/09 23:25:34 Jochen.Voss Exp $ */
d757 1
a757 1
		unsigned len = 0;
@


1.11
log
@Update to xterm 250
@
text
@d1 1
a1 1
/* $XTermId: Tekproc.c,v 1.173 2009/10/12 00:31:59 tom Exp $ */
d460 1
a460 1
	    FlushLog(&(term->screen));
d1314 1
a1314 1
	if (VWindow(&(term->screen)) == 0) {
d1361 3
d1380 1
a1380 1
    ((TekWidget) wnew)->screen.whichTwin = &((TekWidget) wnew)->screen.fullTwin;
d1405 1
a1405 1
    memset(tekscr, 0, sizeof(tekscr));
@


1.10
log
@update to xterm 246. Has been in snapshots for some time.
@
text
@d1 1
a1 1
/* $XTermId: Tekproc.c,v 1.172 2009/08/09 17:22:34 tom Exp $ */
d1892 1
a1892 1
	    write(tekcopyfd, initbuf, (size_t) 4);
d1895 1
a1895 1
		write(tekcopyfd, Tp->data, (size_t) Tp->count);
@


1.9
log
@Update to xterm 243. tested by naddy@@.

Patch #243 - 2009/3/28

* revert change to default for allowTcapOps (request by Bram Moolenaar).
* reallocate result returned by xtermEnvLocale() to avoid reference to
freed memory after handling menuLocale resource.
* fix an old (X11R5) bug in tek4014 for switching fontsizes.
* add resource defaultString to make configurable the use of "#" when
pastes of UTF-8 text fail due to limitations in the current locale settings.
* make the set of selection target Atom's configurable by two new
resources eightBitSelectTypes and utf8SelectTypes, e.g., to use the TEXT
Atom in preference to UTF8_STRING (discussion with Stanislav Sedov
regarding koi8rxterm and the FreeBSD port).
* modify handling of TARGETS Atom by making it return exactly the set of
targets as those which xterm is currently providing.
* set MANPAGER and PAGER explicitly to /bin/cat in minstall.sh to work
around /etc/man.conf's with those variables already set (report by
Mar'yasin Semion).
* improve error-checking of tcap-query parser.
* add check for keyboard tcap), which ensures that terminal descriptions
containing the same string for shifted/unshifted keys will be seen by
tcap-query as only the unshifted key. (This would only happen with an
incorrect terminal description).
* fix conversion for input event-state to modifier-parameter which made
tcap-query feature not work with tcapFunctionKeys (keyboard type tcap).
* add "DEF_ALLOW_XXX" definitions to main.h to allow overriding the
default compiled-in values for "allowxxx" resources.
* remove check on bell-percentage added in patch #242, which disallowed
zero/negative values (Redhat Bugzilla #487829).
@
text
@d1 1
a1 1
/* $XTermId: Tekproc.c,v 1.167 2009/03/28 17:03:35 tom Exp $ */
a5 1
/* $XFree86: xc/programs/xterm/Tekproc.c,v 3.57 2006/02/13 01:14:57 dickey Exp $ */
d598 1
a598 1
	    TekSetFontSize(tw, (int) (c & 03));
d797 1
a797 1
	    TekSetFontSize(tw, tek->fontsize);
d942 1
a942 1
	TekSetFontSize(tw, tekscr->cur.fontsize);
d1396 2
a1397 1
    int winX, winY, width, height;
d1399 1
a1399 1
    unsigned TEKgcFontMask;
d1445 2
a1446 2
    width = TEKDEFWIDTH + border;
    height = TEKDEFHEIGHT + border;
d1452 2
a1453 2
			(unsigned int *) &width,
			(unsigned int *) &height);
d1457 1
a1457 1
	    - width - (BorderWidth(SHELL_OF(term)) * 2);
d1460 1
a1460 1
	    - height - (BorderWidth(SHELL_OF(term)) * 2);
d1491 2
a1492 2
    tw->hints.width = width;
    tw->hints.height = height;
d1499 1
a1499 1
		      width, height,
d1528 2
a1529 2
    TWidth(tekscr) = width - border;
    THeight(tekscr) = height - border;
d1561 1
a1561 1
    TEKgcFontMask = (gcv.font == DefaultGCID) ? 0 : GCFont;
d1654 1
a1654 1
TekSetFontSize(TekWidget tw, int newitem)
d1671 2
a1672 1
	    tekscr->page.fontsize = newsize;
d1689 7
a1695 5
	    /* we'll get an exposure event after changing fontsize, so we
	     * have to clear the screen to avoid painting over the previous
	     * text.
	     */
	    TekClear(tw);
d1851 1
a1851 1
	    bzero((char *) &tekscr->cur, sizeof tekscr->cur);
d1892 1
a1892 1
	    write(tekcopyfd, initbuf, 4);
d1895 1
a1895 1
		write(tekcopyfd, Tp->data, Tp->count);
@


1.8
log
@Update to xterm 242. Tested by jsg@@.
@
text
@d1 1
a1 1
/* $XTermId: Tekproc.c,v 1.163 2009/02/13 20:01:21 tom Exp $ */
d902 2
a903 2
    if (IsTekWidget(w)) {
	TekWidget tw = (TekWidget) w;
d927 2
a928 2
    if (IsTekWidget(w)) {
	TekWidget tw = (TekWidget) w;
d931 1
a931 1
	TRACE(("TekExpose\n"));
a941 1
	TekSetFontSize(tw, tekscr->page.fontsize);
d943 1
d957 1
d985 1
d1662 1
a1662 1
	TRACE(("TekSetFontSize(%d)\n", newitem));
d1670 3
a1683 1
	    tekscr->cur.fontsize = newsize;
d1687 6
d1809 1
d1907 2
a1908 2
    if (IsTekWidget(w)) {
	TekWidget tw = (TekWidget) w;
d1931 22
@


1.7
log
@xterm-236. Tested by form@@ and simon@@.
@
text
@d1 1
a1 1
/* $XTermId: Tekproc.c,v 1.160 2008/06/03 20:55:56 tom Exp $ */
d10 1
a10 1
Copyright 2001-2007,2008 by Thomas E. Dickey
d149 1
a149 1
#define	unput(c)	*Tpushback++ = c
d711 1
a711 1
	    c = tekscr->cur.fontsize;
d760 1
a760 1
		    if (!isprint(c2 & 0x7f)
d763 1
a763 1
		    buf2[len++] = c2;
d793 1
a793 1
	    return (*rptr++);
d799 1
a799 1
	    return (*rptr++);
d879 1
a879 1
	tek->fontsize = tekscr->cur.fontsize;
d886 1
a886 1
    return (*tek->ptr++ = nextPtyData(screen, VTbuffer));
d1002 1
a1002 1
    tek->fontsize = tekscr->cur.fontsize;
d1036 1
a1036 1
	if ((c = input()) < ' ') {	/* control character */
d1167 6
a1172 6
    lp->x1 = x1 = (int) (x1 * TekScale(tekscr) + screen->border);
    lp->y1 = y1 = (int) ((TEKHEIGHT + TEKTOPPAD - y1) * TekScale(tekscr) +
			 screen->border);
    lp->x2 = x2 = (int) (x2 * TekScale(tekscr) + screen->border);
    lp->y2 = y2 = (int) ((TEKHEIGHT + TEKTOPPAD - y2) * TekScale(tekscr) +
			 screen->border);
d1267 1
a1267 1
    cplot[0] = status;
d1269 4
a1272 4
    cplot[1] = 040 | ((x >> SHIFTHI) & FIVEBITS);
    cplot[2] = 040 | ((x >> SHIFTLO) & FIVEBITS);
    cplot[3] = 040 | ((y >> SHIFTHI) & FIVEBITS);
    cplot[4] = 040 | ((y >> SHIFTLO) & FIVEBITS);
d1524 2
a1525 2
    TFullWidth(tekscr) = width;
    TFullHeight(tekscr) = height;
d1601 1
a1601 1
	tek_icon_name = XtMalloc(strlen(icon_name) + 7);
d1604 1
a1604 1
	tek_title = XtMalloc(strlen(title) + 7);
d1616 1
a1616 1
    tek->fontsize = tekscr->cur.fontsize;
d1743 1
d1746 1
a1746 1
    EXCHANGE(T_COLOR(screen, TEK_FG), T_COLOR(screen, TEK_BG), i);
@


1.6
log
@update to xterm 234. tested by merdely@@, 'looks ok' deraadt@@.
@
text
@d1 1
a1 1
/* $XTermId: Tekproc.c,v 1.159 2008/02/21 20:21:51 tom Exp $ */
d1496 3
a1498 5
    TRACE(("make resize request %dx%d\n", height, width));
    (void) XtMakeResizeRequest((Widget) tw,
			       width, height,
			       &tw->core.width, &tw->core.height);
    TRACE(("...made resize request %dx%d\n", tw->core.height, tw->core.width));
@


1.5
log
@Merge xterm 232.
New local change: default value for pointerMode is 0.
@
text
@d1 1
a1 1
/* $XTermId: Tekproc.c,v 1.158 2008/01/26 01:21:10 tom Exp $ */
d721 2
a722 2
		sbuf.byte2 = CharOf(ch);
		sbuf.byte1 = CharOf(ch >> 8);
@


1.4
log
@update to xterm 229. Tested on various architectures by aanriot@@
@
text
@d1 1
a1 1
/* $XTermId: Tekproc.c,v 1.157 2007/07/10 19:53:11 tom Exp $ */
d10 1
a10 1
Copyright 2001-2006,2007 by Thomas E. Dickey
d732 2
d739 1
a739 1
			    (char *) &ch,
d741 1
@


1.3
log
@Merge xterm version 225
@
text
@d1 1
a1 1
/* $XTermId: Tekproc.c,v 1.155 2007/03/19 23:51:52 tom Exp $ */
d951 1
a951 2
	if (resource.wait_for_map)
	    first_map_occurred();
d960 4
a963 3
    TekScreen *tekscr = TekScreenOf(tw);
    TScreen *screen = TScreenOf(term);
    static Cursor wait_cursor = None;
d965 11
a975 10
    if (wait_cursor == None)
	wait_cursor = make_colored_cursor(XC_watch,
					  T_COLOR(screen, MOUSE_FG),
					  T_COLOR(screen, MOUSE_BG));
    XDefineCursor(XtDisplay(tw), TWindow(tekscr), wait_cursor);
    XFlush(XtDisplay(tw));
    if (!setjmp(Tekjump))
	Tekparse(tw);
    XDefineCursor(XtDisplay(tw), TWindow(tekscr),
		  (tekscr->TekGIN && GINcursor) ? GINcursor : tekscr->arrow);
d1849 3
a1851 2
    TekScreen *tekscr = TekScreenOf(tw);
    TScreen *screen = TScreenOf(term);
d1853 11
a1863 11
    TekLink *Tp;
    char buf[32];
    char initbuf[5];
    int tekcopyfd;

    timestamp_filename(buf, "COPY");
    if (access(buf, F_OK) >= 0
	&& access(buf, W_OK) < 0) {
	Bell(XkbBI_MinorError, 0);
	return;
    }
d1865 4
a1868 4
    if (access(".", W_OK) < 0) {	/* can't write in directory */
	Bell(XkbBI_MinorError, 0);
	return;
    }
d1871 13
a1883 11
    if ((tekcopyfd = open_userfile(screen->uid, screen->gid, buf, False)) >= 0) {
	sprintf(initbuf, "%c%c%c%c",
		ANSI_ESC, (char) (tekscr->page.fontsize + '8'),
		ANSI_ESC, (char) (tekscr->page.linetype + '`'));
	write(tekcopyfd, initbuf, 4);
	Tp = &Tek0;
	do {
	    write(tekcopyfd, Tp->data, Tp->count);
	    Tp = Tp->next;
	} while (Tp);
	close(tekcopyfd);
@


1.2
log
@OpenBSD local changes
@
text
@d1 1
a1 1
/* $XTermId: Tekproc.c,v 1.138 2006/07/23 16:44:28 tom Exp $ */
d10 1
a10 1
Copyright 2001-2005,2006 by Thomas E. Dickey
d116 1
a116 1
#define DefaultGCID XGContextFromGC(DefaultGC(screen->display, DefaultScreen(screen->display)))
d139 2
a140 2
#define	TEKHOME		((TekChar[screen->page.fontsize].nlines - 1)\
			 * TekChar[screen->page.fontsize].vsize)
d147 2
a148 2
#define	TekMove(x,y)	screen->cur_X = x; screen->cur_Y = y
#define	input()		Tinput()
d265 1
a265 1
    Sres("initialFont", "InitialFont", tek.initial_font, "large"),
d273 25
a297 19
static IChar Tinput(void);
static int getpoint(void);
static void TCursorBack(void);
static void TCursorDown(void);
static void TCursorForward(void);
static void TCursorUp(void);
static void TekBackground(TScreen * screen);
static void TekConfigure(Widget w);
static void TekDraw(int x, int y);
static void TekEnq(unsigned status, int x, int y);
static void TekFlush(void);
static void TekInitialize(Widget request,
			  Widget wnew,
			  ArgList args,
			  Cardinal *num_args);
static void TekPage(void);
static void TekRealize(Widget gw,
		       XtValueMask * valuemaskp,
		       XSetWindowAttributes * values);
d337 1
a337 1
#define tekWidgetClass ((WidgetClass)&tekClassRec)
d349 3
d354 12
d369 1
a369 2
			       toplevel, ourTopLevelShellArgs,
			       number_ourTopLevelShellArgs);
d415 1
a415 1
Tekparse(void)
d417 2
a418 1
    TScreen *screen = &term->screen;
d444 3
a446 3
	    if (screen->TekGIN) {
		TekGINoff();
		TekEnqMouse(0);
d449 1
a449 1
		if (screen->margin == MARGIN2)
d451 1
a451 1
		TekEnq(c, screen->cur_X, screen->cur_Y);
d453 1
a453 1
	    TekRecord->ptr[-1] = NAK;	/* remove from recording */
d460 2
a461 2
	    TekRecord->ptr[-1] = NAK;	/* remove from recording */
	    FlushLog(screen);
d466 2
a467 2
	    if (screen->TekGIN)
		TekGINoff();
d473 1
a473 1
	    screen->TekGIN = &TekRecord->ptr[-1];
d479 1
a479 1
		XDefineCursor(screen->display, TWindow(screen),
d487 3
a489 3
	    if (screen->TekGIN)
		TekGINoff();
	    if (!TekRefresh)
d496 2
a497 2
	    if (screen->TekGIN)
		TekGINoff();
d499 1
a499 1
	    TCursorBack();
d504 2
a505 2
	    if (screen->TekGIN)
		TekGINoff();
d511 2
a512 2
	    if (screen->TekGIN)
		TekGINoff();
d514 2
a515 2
	    if ((c = input()) == BEL)
		screen->pen = PENDOWN;
d518 1
a518 1
		screen->pen = PENUP;
d524 2
a525 2
	    if (screen->TekGIN)
		TekGINoff();
d527 1
a527 1
	    TCursorForward();
d532 2
a533 2
	    if (screen->TekGIN)
		TekGINoff();
d539 2
a540 2
	    if (screen->TekGIN)
		TekGINoff();
d543 1
a543 1
		TekFlush();
d549 2
a550 2
	    if (screen->TekGIN)
		TekGINoff();
d552 1
a552 1
	    TCursorUp();
d557 4
a560 4
	    if (screen->TekGIN)
		TekGINoff();
	    TekCopy();
	    TekRecord->ptr[-1] = NAK;	/* remove from recording */
d566 3
a568 3
	    if (screen->TekGIN)
		TekGINoff();
	    TekPage();		/* clear bypass condition */
d599 1
a599 1
	    TekSetFontSize((int) (c & 03));
d606 1
a606 1
	    if ((c &= LINEMASK) != screen->cur.linetype) {
d608 1
a608 1
		    TekFlush();
d610 1
a610 1
		    screen->cur.linetype = c;
d621 1
a621 1
	    screen->pen = PENUP;
d626 1
a626 1
	    screen->pen = PENDOWN;
d631 2
a632 2
	    x = screen->cur_X;
	    y = screen->cur_Y;
d641 2
a642 2
	    if (screen->pen == PENDOWN)
		TekDraw(x, y);
d644 1
a644 1
		TekMove(x, y);
d650 3
a652 3
	    if (getpoint()) {
		if (screen->pen == PENDOWN) {
		    TekDraw(screen->cur.x, screen->cur.y);
d654 1
a654 1
		    TekMove(screen->cur.x, screen->cur.y);
d656 1
a656 1
		screen->pen = PENDOWN;
d663 3
a665 3
	    if (getpoint()) {
		TekMove(screen->cur.x, screen->cur.y);
		TekDraw(screen->cur.x, screen->cur.y);
d672 3
a674 3
	    if (getpoint()) {
		TekMove(screen->cur.x, screen->cur.y);
		TekDraw(screen->cur.x, screen->cur.y);
d680 2
a681 2
	    if (screen->TekGIN)
		TekGINoff();
d683 2
a684 2
		TekFlush();
	    screen->cur_X = screen->margin == MARGIN1 ? 0 :
d696 4
a699 4
	    if (screen->TekGIN)
		TekGINoff();
	    TCursorDown();
	    if (!TekRefresh)
d705 1
a705 1
	    TCursorForward();
d711 2
a712 2
	    c = screen->cur.fontsize;
	    x = (int) (screen->cur_X * TekScale(screen))
d714 1
a714 1
	    y = (int) ((TEKHEIGHT + TEKTOPPAD - screen->cur_Y) * TekScale(screen))
d723 3
a725 3
		XDrawImageString16(screen->display,
				   TWindow(screen),
				   screen->TnormalGC,
d732 3
a734 3
		XDrawString(screen->display,
			    TWindow(screen),
			    screen->TnormalGC,
d739 1
a739 1
	    TCursorForward();
d748 1
a748 1
		 * do_osc() can call TekExpose(), which calls dorefresh(),
d756 1
a756 1
		while ((c2 = input()) != BEL) {
d764 2
a765 2
		    if (c2 == BEL)
			do_osc(term, buf2, len, BEL);
d780 1
a780 1
Tinput(void)
d782 2
a783 1
    TScreen *screen = &term->screen;
d788 1
a788 1
    if (TekRefresh) {
d791 2
a792 2
	if ((tek = TekRefresh->next) != 0) {
	    TekRefresh = tek;
d795 1
a795 1
	    TekSetFontSize(tek->fontsize);
d798 1
a798 1
	TekRefresh = (TekLink *) 0;
d806 1
a806 1
	    TekFlush();
d825 1
a825 1
		TCursorToggle(TOGGLE);
d835 1
a835 1
		XFlush(screen->display);
d857 1
a857 1
	    if (FD_ISSET(ConnectionNumber(screen->display), &Tselect_mask)) {
d865 1
a865 1
	    TCursorToggle(TOGGLE);
d871 1
a871 1
	|| tek->fontsize != screen->cur.fontsize) {
d876 1
a876 1
	tek->fontsize = screen->cur.fontsize;
d886 9
d899 17
a915 14
    TScreen *screen = &term->screen;
    int border = 2 * screen->border;
    double d;

    if (TWindow(screen))
	XClearWindow(screen->display, TWindow(screen));
    TWidth(screen) = w->core.width - border;
    THeight(screen) = w->core.height - border;
    TekScale(screen) = (double) TWidth(screen) / TEKWIDTH;
    if ((d = (double) THeight(screen) / (TEKHEIGHT + TEKTOPPAD + TEKBOTTOMPAD))
	< TekScale(screen))
	TekScale(screen) = d;
    TFullWidth(screen) = w->core.width;
    TFullHeight(screen) = w->core.height;
d920 1
a920 1
TekExpose(Widget w GCC_UNUSED,
d924 3
a926 1
    TScreen *screen = &term->screen;
d928 1
a928 1
    TRACE(("TekExpose\n"));
d931 1
a931 1
    region = region;
d933 23
a955 22
    if (!Ttoggled)
	TCursorToggle(CLEAR);
    Ttoggled = True;
    Tpushback = Tpushb;
    screen->cur_X = 0;
    screen->cur_Y = TEKHOME;
    TekSetFontSize(screen->page.fontsize);
    screen->cur = screen->page;
    screen->margin = MARGIN1;
    if (screen->TekGIN) {
	screen->TekGIN = NULL;
	TekGINoff();
    }
    TekRefresh = &Tek0;
    rptr = TekRefresh->data;
    rcnt = TekRefresh->count;
    Tparsestate = curstate = Talptable;
    TRACE(("TekExpose resets data to replay %d bytes\n", rcnt));
    if (waiting_for_initial_map)
	first_map_occurred();
    if (!screen->waitrefresh)
	dorefresh();
d959 1
a959 1
dorefresh(void)
d961 2
a962 1
    TScreen *screen = &term->screen;
d969 2
a970 2
    XDefineCursor(screen->display, TWindow(screen), wait_cursor);
    XFlush(screen->display);
d972 10
a981 3
	Tekparse();
    XDefineCursor(screen->display, TWindow(screen),
		  (screen->TekGIN && GINcursor) ? GINcursor : screen->arrow);
d985 1
a985 1
TekPage(void)
d987 1
a987 1
    TScreen *screen = &term->screen;
d990 7
a996 7
    XClearWindow(screen->display, TWindow(screen));
    screen->cur_X = 0;
    screen->cur_Y = TEKHOME;
    screen->margin = MARGIN1;
    screen->page = screen->cur;
    if (screen->TekGIN)
	TekGINoff();
d998 1
a998 1
    tek->fontsize = screen->cur.fontsize;
d1010 1
a1010 1
    TekRefresh = (TekLink *) 0;
d1024 1
a1024 1
getpoint(void)
d1027 1
a1027 1
    TScreen *screen = &term->screen;
d1029 2
a1030 2
    x = screen->cur.x;
    y = screen->cur.y;
d1050 2
a1051 2
	    screen->cur.x = x;
	    screen->cur.y = y;
d1069 1
a1069 1
TCursorBack(void)
d1071 1
a1071 1
    TScreen *screen = &term->screen;
d1075 2
a1076 2
    x = (screen->cur_X -=
	 (t = &TekChar[screen->cur.fontsize])->hsize
d1079 3
a1081 3
    if (((screen->margin == MARGIN1) && (x < 0))
	|| ((screen->margin == MARGIN2) && (x < TEKWIDTH / 2))) {
	if ((l = (screen->cur_Y + (t->vsize - 1)) / t->vsize + 1) >=
d1083 1
a1083 1
	    screen->margin = !screen->margin;
d1086 2
a1087 2
	screen->cur_Y = l * t->vsize;
	screen->cur_X = (t->charsperline - 1) * t->hsize;
d1092 1
a1092 1
TCursorForward(void)
d1094 1
a1094 1
    TScreen *screen = &term->screen;
d1098 2
a1099 2
    if ((screen->cur_X +=
	 (t = &TekChar[screen->cur.fontsize])->hsize
d1102 2
a1103 2
	if ((l = screen->cur_Y / t->vsize - 1) < 0) {
	    screen->margin = !screen->margin;
d1106 2
a1107 2
	screen->cur_Y = l * t->vsize;
	screen->cur_X = screen->margin == MARGIN1 ? 0 : TEKWIDTH / 2;
d1112 1
a1112 1
TCursorUp(void)
d1114 1
a1114 1
    TScreen *screen = &term->screen;
d1118 1
a1118 1
    t = &TekChar[screen->cur.fontsize];
d1120 1
a1120 1
    if ((l = (screen->cur_Y + (t->vsize - 1)) / t->vsize + 1) >= t->nlines) {
d1122 5
a1126 5
	if ((screen->margin = !screen->margin) != MARGIN1) {
	    if (screen->cur_X < TEKWIDTH / 2)
		screen->cur_X += TEKWIDTH / 2;
	} else if (screen->cur_X >= TEKWIDTH / 2)
	    screen->cur_X -= TEKWIDTH / 2;
d1128 1
a1128 1
    screen->cur_Y = l * t->vsize;
d1132 1
a1132 1
TCursorDown(void)
d1134 1
a1134 1
    TScreen *screen = &term->screen;
d1138 1
a1138 1
    t = &TekChar[screen->cur.fontsize];
d1140 1
a1140 1
    if ((l = screen->cur_Y / t->vsize - 1) < 0) {
d1142 5
a1146 5
	if ((screen->margin = !screen->margin) != MARGIN1) {
	    if (screen->cur_X < TEKWIDTH / 2)
		screen->cur_X += TEKWIDTH / 2;
	} else if (screen->cur_X >= TEKWIDTH / 2)
	    screen->cur_X -= TEKWIDTH / 2;
d1148 1
a1148 1
    screen->cur_Y = l * t->vsize;
d1152 1
a1152 1
AddToDraw(int x1, int y1, int x2, int y2)
d1154 2
a1155 1
    TScreen *screen = &term->screen;
d1160 1
a1160 1
	TekFlush();
d1163 2
a1164 2
    lp->x1 = x1 = (int) (x1 * TekScale(screen) + screen->border);
    lp->y1 = y1 = (int) ((TEKHEIGHT + TEKTOPPAD - y1) * TekScale(screen) +
d1166 2
a1167 2
    lp->x2 = x2 = (int) (x2 * TekScale(screen) + screen->border);
    lp->y2 = y2 = (int) ((TEKHEIGHT + TEKTOPPAD - y2) * TekScale(screen) +
d1174 1
a1174 1
TekDraw(int x, int y)
d1176 1
a1176 1
    TScreen *screen = &term->screen;
d1178 1
a1178 1
    if (nplot == 0 || T_lastx != screen->cur_X || T_lasty != screen->cur_Y) {
d1184 2
a1185 2
	if (nplot > 0 && screen->cur.linetype != SOLIDLINE)
	    TekFlush();
d1187 3
a1189 3
    AddToDraw(screen->cur_X, screen->cur_Y, x, y);
    T_lastx = screen->cur_X = x;
    T_lasty = screen->cur_Y = y;
d1193 1
a1193 1
TekFlush(void)
d1195 1
a1195 1
    TScreen *screen = &term->screen;
d1198 4
a1201 3
    XDrawSegments(screen->display, TWindow(screen),
		  ((screen->cur.linetype == SOLIDLINE) ? screen->TnormalGC :
		   screen->linepat[screen->cur.linetype - 1]),
d1208 1
a1208 1
TekGINoff(void)
d1210 1
a1210 1
    TScreen *screen = &term->screen;
d1213 1
a1213 1
    XDefineCursor(screen->display, TWindow(screen), screen->arrow);
d1215 4
a1218 4
	XFreeCursor(screen->display, GINcursor);
    if (screen->TekGIN) {
	*screen->TekGIN = CAN;	/* modify recording */
	screen->TekGIN = NULL;
d1223 1
a1223 1
TekEnqMouse(int c)		/* character pressed */
d1225 2
a1226 1
    TScreen *screen = &term->screen;
d1233 1
a1233 1
		     screen->display, TWindow(screen),
d1238 1
a1238 1
    if ((mousex = (int) ((mousex - screen->border) / TekScale(screen))) < 0)
d1243 1
a1243 1
			 TekScale(screen))) < 0)
d1247 1
a1247 1
    TekEnq((unsigned) c, mousex, mousey);
d1251 2
a1252 1
TekEnq(unsigned status,
d1256 2
a1257 1
    TScreen *screen = &term->screen;
d1270 1
a1270 1
    if (screen->gin_terminator != GIN_TERM_NONE)
d1272 1
a1272 1
    if (screen->gin_terminator == GIN_TERM_EOT)
d1284 5
a1288 1
    TScreen *screen = &term->screen;
d1290 2
a1291 6
    TRACE(("TekRun ...\n"));

    if (!TWindow(screen) && !TekInit()) {
	if (VWindow(screen)) {
	    screen->TekEmu = False;
	    return;
d1293 4
a1296 9
	Exit(ERROR_TINIT);
    }
    if (!screen->Tshow) {
	set_tek_visibility(True);
    }
    update_vttekmode();
    update_vtshow();
    update_tekshow();
    set_tekhide_sensitivity();
d1298 1
a1298 6
    Tpushback = Tpushb;
    Ttoggled = True;
    if (!setjmp(Tekend))
	Tekparse();
    if (!Ttoggled) {
	TCursorToggle(TOGGLE);
d1300 12
a1312 1
    screen->TekEmu = False;
d1368 1
a1368 1
    XtAddEventHandler((Widget) wnew, PropertyChangeMask, False,
d1370 5
d1383 2
a1384 1
    TScreen *screen = &term->screen;
d1396 1
d1399 1
a1399 1
    term->screen.whichTwin = &term->screen.fullTwin;
d1404 4
d1410 1
a1410 1
	    tw->tek.Tfont[i] = XQueryFont(screen->display, DefaultGCID);
d1450 1
a1450 1
	winX += DisplayWidth(screen->display, DefaultScreen(screen->display))
d1453 1
a1453 1
	winY += DisplayHeight(screen->display, DefaultScreen(screen->display))
d1511 2
a1512 2
    XtWindow(tw) = TWindow(screen) =
	XCreateWindow(screen->display,
d1522 8
a1529 8
    TFullWidth(screen) = width;
    TFullHeight(screen) = height;
    TWidth(screen) = width - border;
    THeight(screen) = height - border;
    TekScale(screen) = (double) TWidth(screen) / TEKWIDTH;
    if ((d = (double) THeight(screen) / (TEKHEIGHT + TEKTOPPAD +
					 TEKBOTTOMPAD)) < TekScale(screen))
	TekScale(screen) = d;
d1531 1
a1531 1
    screen->cur.fontsize = TEK_FONT_LARGE;
d1533 3
a1535 12
	char *s = tw->tek.initial_font;

	if (XmuCompareISOLatin1(s, "large") == 0)
	    screen->cur.fontsize = TEK_FONT_LARGE;
	else if (XmuCompareISOLatin1(s, "2") == 0 ||
		 XmuCompareISOLatin1(s, "two") == 0)
	    screen->cur.fontsize = TEK_FONT_2;
	else if (XmuCompareISOLatin1(s, "3") == 0 ||
		 XmuCompareISOLatin1(s, "three") == 0)
	    screen->cur.fontsize = TEK_FONT_3;
	else if (XmuCompareISOLatin1(s, "small") == 0)
	    screen->cur.fontsize = TEK_FONT_SMALL;
d1540 1
a1540 1
	screen->gin_terminator = GIN_TERM_NONE;
d1542 1
a1542 1
	screen->gin_terminator = GIN_TERM_CR;
d1544 1
a1544 1
	screen->gin_terminator = GIN_TERM_EOT;
d1550 1
a1550 1
    gcv.font = tw->tek.Tfont[screen->cur.fontsize]->fid;
d1558 1
a1558 1
    screen->TnormalGC = XCreateGC(screen->display, TWindow(screen),
d1568 1
a1568 1
    screen->TcursorGC = XCreateGC(screen->display, TWindow(screen),
d1575 1
a1575 1
	screen->linepat[i] = XCreateGC(screen->display, TWindow(screen),
d1577 1
a1577 1
	XSetDashes(screen->display, screen->linepat[i], 0,
d1581 1
a1581 1
    TekBackground(screen);
d1583 2
a1584 2
    screen->margin = MARGIN1;	/* Margin 1             */
    screen->TekGIN = False;	/* GIN off              */
d1586 1
a1586 1
    XDefineCursor(screen->display, TWindow(screen), screen->pointer_cursor);
d1614 1
a1614 1
    tek->fontsize = screen->cur.fontsize;
d1618 2
a1619 2
    screen->cur_X = 0;
    screen->cur_Y = TEKHOME;
d1622 1
a1622 1
    screen->page = screen->cur;
d1626 2
a1627 2
void
TekSetFontSize(int newitem)
d1629 1
a1629 4
    TScreen *screen = &term->screen;
    int oldsize = screen->cur.fontsize;
    int newsize = MI2FS(newitem);
    Font fid;
d1631 14
a1644 1
    TRACE(("TekSetFontSize(%d)\n", newitem));
d1646 30
a1675 15
    if (!tekWidget || oldsize == newsize)
	return;
    if (!Ttoggled)
	TCursorToggle(TOGGLE);
    set_tekfont_menu_item(oldsize, False);

    fid = tekWidget->tek.Tfont[newsize]->fid;
    if (fid == DefaultGCID)
	/* we didn't succeed in opening a real font
	   for this size.  Instead, use server default. */
	XCopyGC(screen->display,
		DefaultGC(screen->display, DefaultScreen(screen->display)),
		GCFont, screen->TnormalGC);
    else
	XSetFont(screen->display, screen->TnormalGC, fid);
d1677 6
a1682 4
    screen->cur.fontsize = newsize;
    set_tekfont_menu_item(newsize, True);
    if (!Ttoggled)
	TCursorToggle(TOGGLE);
d1686 1
a1686 1
ChangeTekColors(TScreen * screen, ScrnColors * pNew)
d1688 1
d1708 2
a1709 2
    if (tekWidget) {
	XSetForeground(screen->display, screen->TnormalGC,
d1711 1
a1711 1
	XSetBackground(screen->display, screen->TnormalGC,
d1713 7
a1719 7
	if (BorderPixel(tekWidget) == T_COLOR(screen, TEK_BG)) {
	    BorderPixel(tekWidget) = T_COLOR(screen, TEK_FG);
	    BorderPixel(XtParent(tekWidget)) = T_COLOR(screen, TEK_FG);
	    if (XtWindow(XtParent(tekWidget)))
		XSetWindowBorder(screen->display,
				 XtWindow(XtParent(tekWidget)),
				 BorderPixel(tekWidget));
d1723 1
a1723 1
	    XSetForeground(screen->display, screen->linepat[i],
d1729 2
a1730 2
	XChangeGC(screen->display, screen->TcursorGC, GCPlaneMask, &gcv);
	TekBackground(screen);
d1736 1
a1736 1
TekReverseVideo(TScreen * screen)
d1738 2
d1747 11
a1757 11
    if (tekWidget) {
	XSetForeground(screen->display, screen->TnormalGC, T_COLOR(screen, TEK_FG));
	XSetBackground(screen->display, screen->TnormalGC, T_COLOR(screen, TEK_BG));

	if (BorderPixel(tekWidget) == T_COLOR(screen, TEK_BG)) {
	    BorderPixel(tekWidget) = T_COLOR(screen, TEK_FG);
	    BorderPixel(XtParent(tekWidget)) = T_COLOR(screen, TEK_FG);
	    if (XtWindow(XtParent(tekWidget)))
		XSetWindowBorder(screen->display,
				 XtWindow(XtParent(tekWidget)),
				 BorderPixel(tekWidget));
d1761 1
a1761 1
	    XSetForeground(screen->display, screen->linepat[i],
d1767 2
a1768 2
	XChangeGC(screen->display, screen->TcursorGC, GCPlaneMask, &gcv);
	TekBackground(screen);
d1773 1
a1773 1
TekBackground(TScreen * screen)
d1775 4
a1778 2
    if (TWindow(screen))
	XSetWindowBackground(screen->display, TWindow(screen),
d1786 1
a1786 1
TCursorToggle(int toggle)	/* TOGGLE or CLEAR */
d1788 2
a1789 1
    TScreen *screen = &term->screen;
d1793 1
a1793 1
    if (!screen->Tshow)
d1796 8
a1803 8
    c = screen->cur.fontsize;
    cellwidth = (unsigned) tekWidget->tek.Tfont[c]->max_bounds.width;
    cellheight = (unsigned) (tekWidget->tek.Tfont[c]->ascent +
			     tekWidget->tek.Tfont[c]->descent);

    x = (int) ((screen->cur_X * TekScale(screen)) + screen->border);
    y = (int) (((TEKHEIGHT + TEKTOPPAD - screen->cur_Y) * TekScale(screen))
	       + screen->border - tekWidget->tek.tobaseline[c]);
d1807 2
a1808 2
	    XFillRectangle(screen->display, TWindow(screen),
			   screen->TcursorGC, x, y,
d1811 2
a1812 2
	    XDrawRectangle(screen->display, TWindow(screen),
			   screen->TcursorGC, x, y,
d1822 1
a1822 1
	XClearArea(screen->display, TWindow(screen), x, y,
d1828 1
a1828 1
TekSimulatePageButton(Bool reset)
d1830 2
a1831 1
    TScreen *screen = &term->screen;
d1833 7
a1839 4
    if (!tekWidget)
	return;
    if (reset) {
	bzero((char *) &screen->cur, sizeof screen->cur);
a1840 4
    TekRefresh = (TekLink *) 0;
    TekPage();
    screen->cur_X = 0;
    screen->cur_Y = TEKHOME;
d1846 1
a1846 1
TekCopy(void)
d1848 2
a1849 1
    TScreen *screen = &term->screen;
d1871 2
a1872 2
		ESC, (char) (screen->page.fontsize + '8'),
		ESC, (char) (screen->page.linetype + '`'));
d1880 33
@


1.1
log
@Initial revision
@
text
@d819 2
@


1.1.1.1
log
@Importing xterm 216
@
text
@@


1.1.1.2
log
@import xterm 225
@
text
@d1 1
a1 1
/* $XTermId: Tekproc.c,v 1.155 2007/03/19 23:51:52 tom Exp $ */
d10 1
a10 1
Copyright 2001-2006,2007 by Thomas E. Dickey
d116 1
a116 1
#define DefaultGCID XGContextFromGC(DefaultGC(XtDisplay(tw), DefaultScreen(XtDisplay(tw))))
d139 2
a140 2
#define	TEKHOME		( (TekChar[tekscr->page.fontsize].nlines - 1) \
			 * TekChar[tekscr->page.fontsize].vsize)
d147 2
a148 2
#define	TekMove(tw,x,y)	tekscr->cur_X = x; tekscr->cur_Y = y
#define	input()		Tinput(tw)
d265 1
a265 1
    Sres(XtNinitialFont, XtCInitialFont, tek.initial_font, "large"),
d273 19
a291 25
static IChar Tinput(TekWidget /* tw */ );
static int getpoint(TekWidget /* tw */ );
static void TCursorBack(TekWidget /* tw */ );
static void TCursorDown(TekWidget /* tw */ );
static void TCursorForward(TekWidget /* tw */ );
static void TCursorUp(TekWidget /* tw */ );
static void TekBackground(TekWidget /* tw */ ,
			  TScreen * /* screen */ );
static void TekConfigure(Widget /* w */ );
static void TekDraw(TekWidget /* tw */ ,
		    int /* x */ ,
		    int /* y */ );
static void TekEnq(TekWidget /* tw */ ,
		   unsigned /* status */ ,
		   int /* x */ ,
		   int /* y */ );
static void TekFlush(TekWidget /* tw */ );
static void TekInitialize(Widget /* request */ ,
			  Widget /* wnew */ ,
			  ArgList /* args */ ,
			  Cardinal * /* num_args */ );
static void TekPage(TekWidget /* tw */ );
static void TekRealize(Widget /* gw */ ,
		       XtValueMask * /* valuemaskp */ ,
		       XSetWindowAttributes * /* values */ );
d331 1
a331 1
WidgetClass tekWidgetClass = (WidgetClass) & tekClassRec;
a342 3
	Cardinal nargs = 0;
	Arg myArgs[3];
	Boolean iconic = 0;
a344 12
	XtSetArg(myArgs[nargs], XtNiconic, &iconic);
	++nargs;
	XtGetValues(toplevel, myArgs, nargs);

	nargs = 0;
	XtSetArg(myArgs[nargs], XtNiconic, iconic);
	++nargs;
	XtSetArg(myArgs[nargs], XtNallowShellResize, True);
	++nargs;
	XtSetArg(myArgs[nargs], XtNinput, True);
	++nargs;

d348 2
a349 1
			       toplevel, myArgs, nargs);
d395 1
a395 1
Tekparse(TekWidget tw)
d397 1
a397 2
    TScreen *screen = TScreenOf(term);
    TekScreen *tekscr = TekScreenOf(tw);
d423 3
a425 3
	    if (tekscr->TekGIN) {
		TekGINoff(tw);
		TekEnqMouse(tw, 0);
d428 1
a428 1
		if (tekscr->margin == MARGIN2)
d430 1
a430 1
		TekEnq(tw, c, tekscr->cur_X, tekscr->cur_Y);
d432 1
a432 1
	    TekRecord->ptr[-1] = ANSI_NAK;	/* remove from recording */
d439 2
a440 2
	    TekRecord->ptr[-1] = ANSI_NAK;	/* remove from recording */
	    FlushLog(&(term->screen));
d445 2
a446 2
	    if (tekscr->TekGIN)
		TekGINoff(tw);
d452 1
a452 1
	    tekscr->TekGIN = &TekRecord->ptr[-1];
d458 1
a458 1
		XDefineCursor(XtDisplay(tw), TWindow(tekscr),
d466 3
a468 3
	    if (tekscr->TekGIN)
		TekGINoff(tw);
	    if (!tekRefreshList)
d475 2
a476 2
	    if (tekscr->TekGIN)
		TekGINoff(tw);
d478 1
a478 1
	    TCursorBack(tw);
d483 2
a484 2
	    if (tekscr->TekGIN)
		TekGINoff(tw);
d490 2
a491 2
	    if (tekscr->TekGIN)
		TekGINoff(tw);
d493 2
a494 2
	    if ((c = input()) == ANSI_BEL)
		tekscr->pen = PENDOWN;
d497 1
a497 1
		tekscr->pen = PENUP;
d503 2
a504 2
	    if (tekscr->TekGIN)
		TekGINoff(tw);
d506 1
a506 1
	    TCursorForward(tw);
d511 2
a512 2
	    if (tekscr->TekGIN)
		TekGINoff(tw);
d518 2
a519 2
	    if (tekscr->TekGIN)
		TekGINoff(tw);
d522 1
a522 1
		TekFlush(tw);
d528 2
a529 2
	    if (tekscr->TekGIN)
		TekGINoff(tw);
d531 1
a531 1
	    TCursorUp(tw);
d536 4
a539 4
	    if (tekscr->TekGIN)
		TekGINoff(tw);
	    TekCopy(tw);
	    TekRecord->ptr[-1] = ANSI_NAK;	/* remove from recording */
d545 3
a547 3
	    if (tekscr->TekGIN)
		TekGINoff(tw);
	    TekPage(tw);	/* clear bypass condition */
d578 1
a578 1
	    TekSetFontSize(tw, (int) (c & 03));
d585 1
a585 1
	    if ((c &= LINEMASK) != tekscr->cur.linetype) {
d587 1
a587 1
		    TekFlush(tw);
d589 1
a589 1
		    tekscr->cur.linetype = c;
d600 1
a600 1
	    tekscr->pen = PENUP;
d605 1
a605 1
	    tekscr->pen = PENDOWN;
d610 2
a611 2
	    x = tekscr->cur_X;
	    y = tekscr->cur_Y;
d620 2
a621 2
	    if (tekscr->pen == PENDOWN)
		TekDraw(tw, x, y);
d623 1
a623 1
		TekMove(tw, x, y);
d629 3
a631 3
	    if (getpoint(tw)) {
		if (tekscr->pen == PENDOWN) {
		    TekDraw(tw, tekscr->cur.x, tekscr->cur.y);
d633 1
a633 1
		    TekMove(tw, tekscr->cur.x, tekscr->cur.y);
d635 1
a635 1
		tekscr->pen = PENDOWN;
d642 3
a644 3
	    if (getpoint(tw)) {
		TekMove(tw, tekscr->cur.x, tekscr->cur.y);
		TekDraw(tw, tekscr->cur.x, tekscr->cur.y);
d651 3
a653 3
	    if (getpoint(tw)) {
		TekMove(tw, tekscr->cur.x, tekscr->cur.y);
		TekDraw(tw, tekscr->cur.x, tekscr->cur.y);
d659 2
a660 2
	    if (tekscr->TekGIN)
		TekGINoff(tw);
d662 2
a663 2
		TekFlush(tw);
	    tekscr->cur_X = tekscr->margin == MARGIN1 ? 0 :
d675 4
a678 4
	    if (tekscr->TekGIN)
		TekGINoff(tw);
	    TCursorDown(tw);
	    if (!tekRefreshList)
d684 1
a684 1
	    TCursorForward(tw);
d690 2
a691 2
	    c = tekscr->cur.fontsize;
	    x = (int) (tekscr->cur_X * TekScale(tekscr))
d693 1
a693 1
	    y = (int) ((TEKHEIGHT + TEKTOPPAD - tekscr->cur_Y) * TekScale(tekscr))
d702 3
a704 3
		XDrawImageString16(XtDisplay(tw),
				   TWindow(tekscr),
				   tekscr->TnormalGC,
d711 3
a713 3
		XDrawString(XtDisplay(tw),
			    TWindow(tekscr),
			    tekscr->TnormalGC,
d718 1
a718 1
	    TCursorForward(tw);
d727 1
a727 1
		 * do_osc() can call TekExpose(), which calls TekRefresh(),
d735 1
a735 1
		while ((c2 = input()) != ANSI_BEL) {
d743 2
a744 2
		    if (c2 == ANSI_BEL)
			do_osc(term, buf2, len, ANSI_BEL);
d759 1
a759 1
Tinput(TekWidget tw)
d761 1
a761 2
    TekScreen *tekscr = TekScreenOf(tw);
    TScreen *screen = TScreenOf(term);
d766 1
a766 1
    if (tekRefreshList) {
d769 2
a770 2
	if ((tek = tekRefreshList->next) != 0) {
	    tekRefreshList = tek;
d773 1
a773 1
	    TekSetFontSize(tw, tek->fontsize);
d776 1
a776 1
	tekRefreshList = (TekLink *) 0;
d784 1
a784 1
	    TekFlush(tw);
d803 1
a803 1
		TCursorToggle(tw, TOGGLE);
d813 1
a813 1
		XFlush(XtDisplay(tw));
d833 1
a833 1
	    if (FD_ISSET(ConnectionNumber(XtDisplay(tw)), &Tselect_mask)) {
d841 1
a841 1
	    TCursorToggle(tw, TOGGLE);
d847 1
a847 1
	|| tek->fontsize != tekscr->cur.fontsize) {
d852 1
a852 1
	tek->fontsize = tekscr->cur.fontsize;
a861 9
static void
TekClear(TekWidget tw)
{
    TekScreen *tekscr = TekScreenOf(tw);

    if (TWindow(tekscr))
	XClearWindow(XtDisplay(tw), TWindow(tekscr));
}

d866 14
a879 17
    if (IsTekWidget(w)) {
	TekWidget tw = (TekWidget) w;
	TekScreen *tekscr = TekScreenOf(tw);
	TScreen *screen = TScreenOf(term);
	int border = 2 * screen->border;
	double d;

	TekClear(tw);
	TWidth(tekscr) = w->core.width - border;
	THeight(tekscr) = w->core.height - border;
	TekScale(tekscr) = (double) TWidth(tekscr) / TEKWIDTH;
	if ((d = (double) THeight(tekscr) / (TEKHEIGHT + TEKTOPPAD + TEKBOTTOMPAD))
	    < TekScale(tekscr))
	    TekScale(tekscr) = d;
	TFullWidth(tekscr) = w->core.width;
	TFullHeight(tekscr) = w->core.height;
    }
d884 1
a884 1
TekExpose(Widget w,
d888 1
a888 3
    if (IsTekWidget(w)) {
	TekWidget tw = (TekWidget) w;
	TekScreen *tekscr = TekScreenOf(tw);
d890 1
a890 1
	TRACE(("TekExpose\n"));
d893 1
a893 1
	region = region;
d895 22
a916 23
	if (!Ttoggled)
	    TCursorToggle(tw, CLEAR);
	Ttoggled = True;
	Tpushback = Tpushb;
	tekscr->cur_X = 0;
	tekscr->cur_Y = TEKHOME;
	TekSetFontSize(tw, tekscr->page.fontsize);
	tekscr->cur = tekscr->page;
	tekscr->margin = MARGIN1;
	if (tekscr->TekGIN) {
	    tekscr->TekGIN = NULL;
	    TekGINoff(tw);
	}
	tekRefreshList = &Tek0;
	rptr = tekRefreshList->data;
	rcnt = tekRefreshList->count;
	Tparsestate = curstate = Talptable;
	TRACE(("TekExpose resets data to replay %d bytes\n", rcnt));
	if (resource.wait_for_map)
	    first_map_occurred();
	if (!tekscr->waitrefresh)
	    TekRefresh(tw);
    }
d920 1
a920 1
TekRefresh(TekWidget tw)
d922 1
a922 2
    TekScreen *tekscr = TekScreenOf(tw);
    TScreen *screen = TScreenOf(term);
d929 2
a930 2
    XDefineCursor(XtDisplay(tw), TWindow(tekscr), wait_cursor);
    XFlush(XtDisplay(tw));
d932 3
a934 10
	Tekparse(tw);
    XDefineCursor(XtDisplay(tw), TWindow(tekscr),
		  (tekscr->TekGIN && GINcursor) ? GINcursor : tekscr->arrow);
}

void
TekRepaint(TekWidget tw)
{
    TekClear(tw);
    TekExpose((Widget) tw, (XEvent *) NULL, (Region) NULL);
d938 1
a938 1
TekPage(TekWidget tw)
d940 1
a940 1
    TekScreen *tekscr = TekScreenOf(tw);
d943 7
a949 7
    TekClear(tw);
    tekscr->cur_X = 0;
    tekscr->cur_Y = TEKHOME;
    tekscr->margin = MARGIN1;
    tekscr->page = tekscr->cur;
    if (tekscr->TekGIN)
	TekGINoff(tw);
d951 1
a951 1
    tek->fontsize = tekscr->cur.fontsize;
d963 1
a963 1
    tekRefreshList = (TekLink *) 0;
d977 1
a977 1
getpoint(TekWidget tw)
d980 1
a980 1
    TekScreen *tekscr = TekScreenOf(tw);
d982 2
a983 2
    x = tekscr->cur.x;
    y = tekscr->cur.y;
d1003 2
a1004 2
	    tekscr->cur.x = x;
	    tekscr->cur.y = y;
d1022 1
a1022 1
TCursorBack(TekWidget tw)
d1024 1
a1024 1
    TekScreen *tekscr = TekScreenOf(tw);
d1028 2
a1029 2
    x = (tekscr->cur_X -=
	 (t = &TekChar[tekscr->cur.fontsize])->hsize
d1032 3
a1034 3
    if (((tekscr->margin == MARGIN1) && (x < 0))
	|| ((tekscr->margin == MARGIN2) && (x < TEKWIDTH / 2))) {
	if ((l = (tekscr->cur_Y + (t->vsize - 1)) / t->vsize + 1) >=
d1036 1
a1036 1
	    tekscr->margin = !tekscr->margin;
d1039 2
a1040 2
	tekscr->cur_Y = l * t->vsize;
	tekscr->cur_X = (t->charsperline - 1) * t->hsize;
d1045 1
a1045 1
TCursorForward(TekWidget tw)
d1047 1
a1047 1
    TekScreen *tekscr = TekScreenOf(tw);
d1051 2
a1052 2
    if ((tekscr->cur_X +=
	 (t = &TekChar[tekscr->cur.fontsize])->hsize
d1055 2
a1056 2
	if ((l = tekscr->cur_Y / t->vsize - 1) < 0) {
	    tekscr->margin = !tekscr->margin;
d1059 2
a1060 2
	tekscr->cur_Y = l * t->vsize;
	tekscr->cur_X = tekscr->margin == MARGIN1 ? 0 : TEKWIDTH / 2;
d1065 1
a1065 1
TCursorUp(TekWidget tw)
d1067 1
a1067 1
    TekScreen *tekscr = TekScreenOf(tw);
d1071 1
a1071 1
    t = &TekChar[tekscr->cur.fontsize];
d1073 1
a1073 1
    if ((l = (tekscr->cur_Y + (t->vsize - 1)) / t->vsize + 1) >= t->nlines) {
d1075 5
a1079 5
	if ((tekscr->margin = !tekscr->margin) != MARGIN1) {
	    if (tekscr->cur_X < TEKWIDTH / 2)
		tekscr->cur_X += TEKWIDTH / 2;
	} else if (tekscr->cur_X >= TEKWIDTH / 2)
	    tekscr->cur_X -= TEKWIDTH / 2;
d1081 1
a1081 1
    tekscr->cur_Y = l * t->vsize;
d1085 1
a1085 1
TCursorDown(TekWidget tw)
d1087 1
a1087 1
    TekScreen *tekscr = TekScreenOf(tw);
d1091 1
a1091 1
    t = &TekChar[tekscr->cur.fontsize];
d1093 1
a1093 1
    if ((l = tekscr->cur_Y / t->vsize - 1) < 0) {
d1095 5
a1099 5
	if ((tekscr->margin = !tekscr->margin) != MARGIN1) {
	    if (tekscr->cur_X < TEKWIDTH / 2)
		tekscr->cur_X += TEKWIDTH / 2;
	} else if (tekscr->cur_X >= TEKWIDTH / 2)
	    tekscr->cur_X -= TEKWIDTH / 2;
d1101 1
a1101 1
    tekscr->cur_Y = l * t->vsize;
d1105 1
a1105 1
AddToDraw(TekWidget tw, int x1, int y1, int x2, int y2)
d1107 1
a1107 2
    TekScreen *tekscr = TekScreenOf(tw);
    TScreen *screen = TScreenOf(term);
d1112 1
a1112 1
	TekFlush(tw);
d1115 2
a1116 2
    lp->x1 = x1 = (int) (x1 * TekScale(tekscr) + screen->border);
    lp->y1 = y1 = (int) ((TEKHEIGHT + TEKTOPPAD - y1) * TekScale(tekscr) +
d1118 2
a1119 2
    lp->x2 = x2 = (int) (x2 * TekScale(tekscr) + screen->border);
    lp->y2 = y2 = (int) ((TEKHEIGHT + TEKTOPPAD - y2) * TekScale(tekscr) +
d1126 1
a1126 1
TekDraw(TekWidget tw, int x, int y)
d1128 1
a1128 1
    TekScreen *tekscr = TekScreenOf(tw);
d1130 1
a1130 1
    if (nplot == 0 || T_lastx != tekscr->cur_X || T_lasty != tekscr->cur_Y) {
d1136 2
a1137 2
	if (nplot > 0 && tekscr->cur.linetype != SOLIDLINE)
	    TekFlush(tw);
d1139 3
a1141 3
    AddToDraw(tw, tekscr->cur_X, tekscr->cur_Y, x, y);
    T_lastx = tekscr->cur_X = x;
    T_lasty = tekscr->cur_Y = y;
d1145 1
a1145 1
TekFlush(TekWidget tw)
d1147 1
a1147 1
    TekScreen *tekscr = TekScreenOf(tw);
d1150 3
a1152 4
    XDrawSegments(XtDisplay(tw), TWindow(tekscr),
		  ((tekscr->cur.linetype == SOLIDLINE)
		   ? tekscr->TnormalGC
		   : tekscr->linepat[tekscr->cur.linetype - 1]),
d1159 1
a1159 1
TekGINoff(TekWidget tw)
d1161 1
a1161 1
    TekScreen *tekscr = TekScreenOf(tw);
d1164 1
a1164 1
    XDefineCursor(XtDisplay(tw), TWindow(tekscr), tekscr->arrow);
d1166 4
a1169 4
	XFreeCursor(XtDisplay(tw), GINcursor);
    if (tekscr->TekGIN) {
	*tekscr->TekGIN = ANSI_CAN;	/* modify recording */
	tekscr->TekGIN = NULL;
d1174 1
a1174 1
TekEnqMouse(TekWidget tw, int c)	/* character pressed */
d1176 1
a1176 2
    TekScreen *tekscr = TekScreenOf(tw);
    TScreen *screen = TScreenOf(term);
d1183 1
a1183 1
		     XtDisplay(tw), TWindow(tekscr),
d1188 1
a1188 1
    if ((mousex = (int) ((mousex - screen->border) / TekScale(tekscr))) < 0)
d1193 1
a1193 1
			 TekScale(tekscr))) < 0)
d1197 1
a1197 1
    TekEnq(tw, (unsigned) c, mousex, mousey);
d1201 1
a1201 2
TekEnq(TekWidget tw,
       unsigned status,
d1205 1
a1205 2
    TekScreen *tekscr = TekScreenOf(tw);
    TScreen *screen = TScreenOf(term);
d1218 1
a1218 1
    if (tekscr->gin_terminator != GIN_TERM_NONE)
d1220 1
a1220 1
    if (tekscr->gin_terminator == GIN_TERM_EOT)
d1232 3
a1234 5
    if (tekWidget == 0) {
	TekInit();
    }
    if (tekWidget != 0) {
	TRACE(("TekRun ...\n"));
d1236 4
a1239 2
	if (!TEK4014_SHOWN(term)) {
	    set_tek_visibility(True);
d1241 9
a1249 4
	update_vttekmode();
	update_vtshow();
	update_tekshow();
	set_tekhide_sensitivity();
d1251 6
a1256 1
	Tpushback = Tpushb;
a1257 12
	if (!setjmp(Tekend))
	    Tekparse(tekWidget);
	if (!Ttoggled) {
	    TCursorToggle(tekWidget, TOGGLE);
	    Ttoggled = True;
	}
	TEK4014_ACTIVE(term) = False;
    } else {
	TEK4014_ACTIVE(term) = False;
	if (VWindow(&(term->screen)) == 0) {
	    Exit(ERROR_TINIT);
	}
d1259 1
d1315 1
a1315 1
    XtAddEventHandler(wnew, PropertyChangeMask, False,
a1316 5

#ifndef NO_ACTIVE_ICON
    ((TekWidget) wnew)->screen.whichTwin = &((TekWidget) wnew)->screen.fullTwin;
#endif /* NO_ACTIVE_ICON */

d1325 1
a1325 2
    TekScreen *tekscr = TekScreenOf(tw);
    TScreen *screen = TScreenOf(term);
a1336 1
    memset(tekscr, 0, sizeof(tekscr));
d1339 1
a1339 1
    tekscr->whichTwin = &tekscr->fullTwin;
a1343 4
    tekscr->arrow = make_colored_cursor(XC_left_ptr,
					T_COLOR(screen, MOUSE_FG),
					T_COLOR(screen, MOUSE_BG));

d1346 1
a1346 1
	    tw->tek.Tfont[i] = XQueryFont(XtDisplay(tw), DefaultGCID);
d1386 1
a1386 1
	winX += DisplayWidth(XtDisplay(tw), DefaultScreen(XtDisplay(tw)))
d1389 1
a1389 1
	winY += DisplayHeight(XtDisplay(tw), DefaultScreen(XtDisplay(tw)))
d1447 2
a1448 2
    XtWindow(tw) = TWindow(tekscr) =
	XCreateWindow(XtDisplay(tw),
d1458 8
a1465 8
    TFullWidth(tekscr) = width;
    TFullHeight(tekscr) = height;
    TWidth(tekscr) = width - border;
    THeight(tekscr) = height - border;
    TekScale(tekscr) = (double) TWidth(tekscr) / TEKWIDTH;
    if ((d = (double) THeight(tekscr) / (TEKHEIGHT + TEKTOPPAD +
					 TEKBOTTOMPAD)) < TekScale(tekscr))
	TekScale(tekscr) = d;
d1467 1
a1467 1
    tekscr->cur.fontsize = TEK_FONT_LARGE;
d1469 12
a1480 3
	int result = TekGetFontSize(tw->tek.initial_font);
	if (result >= 0)
	    tekscr->cur.fontsize = result;
d1485 1
a1485 1
	tekscr->gin_terminator = GIN_TERM_NONE;
d1487 1
a1487 1
	tekscr->gin_terminator = GIN_TERM_CR;
d1489 1
a1489 1
	tekscr->gin_terminator = GIN_TERM_EOT;
d1495 1
a1495 1
    gcv.font = tw->tek.Tfont[tekscr->cur.fontsize]->fid;
d1503 1
a1503 1
    tekscr->TnormalGC = XCreateGC(XtDisplay(tw), TWindow(tekscr),
d1513 1
a1513 1
    tekscr->TcursorGC = XCreateGC(XtDisplay(tw), TWindow(tekscr),
d1520 1
a1520 1
	tekscr->linepat[i] = XCreateGC(XtDisplay(tw), TWindow(tekscr),
d1522 1
a1522 1
	XSetDashes(XtDisplay(tw), tekscr->linepat[i], 0,
d1526 1
a1526 1
    TekBackground(tw, screen);
d1528 2
a1529 2
    tekscr->margin = MARGIN1;	/* Margin 1             */
    tekscr->TekGIN = False;	/* GIN off              */
d1531 1
a1531 1
    XDefineCursor(XtDisplay(tw), TWindow(tekscr), tekscr->arrow);
d1559 1
a1559 1
    tek->fontsize = tekscr->cur.fontsize;
d1563 2
a1564 2
    tekscr->cur_X = 0;
    tekscr->cur_Y = TEKHOME;
d1567 1
a1567 1
    tekscr->page = tekscr->cur;
d1571 2
a1572 2
int
TekGetFontSize(const char *param)
d1574 6
a1579 1
    int result;
d1581 13
a1593 12
    if (XmuCompareISOLatin1(param, "l") == 0 ||
	XmuCompareISOLatin1(param, "large") == 0)
	result = TEK_FONT_LARGE;
    else if (XmuCompareISOLatin1(param, "2") == 0 ||
	     XmuCompareISOLatin1(param, "two") == 0)
	result = TEK_FONT_2;
    else if (XmuCompareISOLatin1(param, "3") == 0 ||
	     XmuCompareISOLatin1(param, "three") == 0)
	result = TEK_FONT_3;
    else if (XmuCompareISOLatin1(param, "s") == 0 ||
	     XmuCompareISOLatin1(param, "small") == 0)
	result = TEK_FONT_SMALL;
d1595 1
a1595 32
	result = -1;

    return result;
}

void
TekSetFontSize(TekWidget tw, int newitem)
{
    if (tw != 0) {
	TekScreen *tekscr = TekScreenOf(tw);
	int oldsize = tekscr->cur.fontsize;
	int newsize = MI2FS(newitem);
	Font fid;

	TRACE(("TekSetFontSize(%d)\n", newitem));
	if (newsize < 0 || newsize >= TEKNUMFONTS) {
	    Bell(XkbBI_MinorError, 0);
	} else if (oldsize != newsize) {
	    if (!Ttoggled)
		TCursorToggle(tw, TOGGLE);
	    set_tekfont_menu_item(oldsize, False);

	    fid = tw->tek.Tfont[newsize]->fid;
	    if (fid == DefaultGCID) {
		/* we didn't succeed in opening a real font
		   for this size.  Instead, use server default. */
		XCopyGC(XtDisplay(tw),
			DefaultGC(XtDisplay(tw), DefaultScreen(XtDisplay(tw))),
			GCFont, tekscr->TnormalGC);
	    } else {
		XSetFont(XtDisplay(tw), tekscr->TnormalGC, fid);
	    }
d1597 4
a1600 6
	    tekscr->cur.fontsize = newsize;
	    set_tekfont_menu_item(newsize, True);
	    if (!Ttoggled)
		TCursorToggle(tw, TOGGLE);
	}
    }
d1604 1
a1604 1
ChangeTekColors(TekWidget tw, TScreen * screen, ScrnColors * pNew)
a1605 1
    TekScreen *tekscr = TekScreenOf(tw);
d1625 2
a1626 2
    if (tw) {
	XSetForeground(XtDisplay(tw), tekscr->TnormalGC,
d1628 1
a1628 1
	XSetBackground(XtDisplay(tw), tekscr->TnormalGC,
d1630 7
a1636 7
	if (BorderPixel(tw) == T_COLOR(screen, TEK_BG)) {
	    BorderPixel(tw) = T_COLOR(screen, TEK_FG);
	    BorderPixel(XtParent(tw)) = T_COLOR(screen, TEK_FG);
	    if (XtWindow(XtParent(tw)))
		XSetWindowBorder(XtDisplay(tw),
				 XtWindow(XtParent(tw)),
				 BorderPixel(tw));
d1640 1
a1640 1
	    XSetForeground(XtDisplay(tw), tekscr->linepat[i],
d1646 2
a1647 2
	XChangeGC(XtDisplay(tw), tekscr->TcursorGC, GCPlaneMask, &gcv);
	TekBackground(tw, screen);
d1653 1
a1653 1
TekReverseVideo(TekWidget tw)
a1654 2
    TScreen *screen = TScreenOf(term);
    TekScreen *tekscr = TekScreenOf(tw);
d1662 11
a1672 11
    if (tw) {
	XSetForeground(XtDisplay(tw), tekscr->TnormalGC, T_COLOR(screen, TEK_FG));
	XSetBackground(XtDisplay(tw), tekscr->TnormalGC, T_COLOR(screen, TEK_BG));

	if (BorderPixel(tw) == T_COLOR(screen, TEK_BG)) {
	    BorderPixel(tw) = T_COLOR(screen, TEK_FG);
	    BorderPixel(XtParent(tw)) = T_COLOR(screen, TEK_FG);
	    if (XtWindow(XtParent(tw)))
		XSetWindowBorder(XtDisplay(tw),
				 XtWindow(XtParent(tw)),
				 BorderPixel(tw));
d1676 1
a1676 1
	    XSetForeground(XtDisplay(tw), tekscr->linepat[i],
d1682 2
a1683 2
	XChangeGC(XtDisplay(tw), tekscr->TcursorGC, GCPlaneMask, &gcv);
	TekBackground(tw, screen);
d1688 1
a1688 1
TekBackground(TekWidget tw, TScreen * screen)
d1690 2
a1691 4
    TekScreen *tekscr = TekScreenOf(tw);

    if (TWindow(tekscr))
	XSetWindowBackground(XtDisplay(tw), TWindow(tekscr),
d1699 1
a1699 1
TCursorToggle(TekWidget tw, int toggle)		/* TOGGLE or CLEAR */
d1701 1
a1701 2
    TekScreen *tekscr = TekScreenOf(tw);
    TScreen *screen = TScreenOf(term);
d1705 1
a1705 1
    if (!TEK4014_SHOWN(term))
d1708 8
a1715 8
    c = tekscr->cur.fontsize;
    cellwidth = (unsigned) tw->tek.Tfont[c]->max_bounds.width;
    cellheight = (unsigned) (tw->tek.Tfont[c]->ascent +
			     tw->tek.Tfont[c]->descent);

    x = (int) ((tekscr->cur_X * TekScale(tekscr)) + screen->border);
    y = (int) (((TEKHEIGHT + TEKTOPPAD - tekscr->cur_Y) * TekScale(tekscr))
	       + screen->border - tw->tek.tobaseline[c]);
d1719 2
a1720 2
	    XFillRectangle(XtDisplay(tw), TWindow(tekscr),
			   tekscr->TcursorGC, x, y,
d1723 2
a1724 2
	    XDrawRectangle(XtDisplay(tw), TWindow(tekscr),
			   tekscr->TcursorGC, x, y,
d1734 1
a1734 1
	XClearArea(XtDisplay(tw), TWindow(tekscr), x, y,
d1740 1
a1740 1
TekSimulatePageButton(TekWidget tw, Bool reset)
d1742 1
a1742 2
    if (tw != 0) {
	TekScreen *tekscr = TekScreenOf(tw);
d1744 4
a1747 7
	if (reset) {
	    bzero((char *) &tekscr->cur, sizeof tekscr->cur);
	}
	tekRefreshList = (TekLink *) 0;
	TekPage(tw);
	tekscr->cur_X = 0;
	tekscr->cur_Y = TEKHOME;
d1749 4
d1758 1
a1758 1
TekCopy(TekWidget tw)
d1760 1
a1760 2
    TekScreen *tekscr = TekScreenOf(tw);
    TScreen *screen = TScreenOf(term);
d1782 2
a1783 2
		ANSI_ESC, (char) (tekscr->page.fontsize + '8'),
		ANSI_ESC, (char) (tekscr->page.linetype + '`'));
a1790 33
    }
}

/*ARGSUSED*/
void
HandleGINInput(Widget w,
	       XEvent * event GCC_UNUSED,
	       String * param_list,
	       Cardinal *nparamsp)
{
    if (IsTekWidget(w)) {
	TekWidget tw = (TekWidget) w;
	TekScreen *tekscr = TekScreenOf(tw);

	if (tekscr->TekGIN && *nparamsp == 1) {
	    int c = param_list[0][0];
	    switch (c) {
	    case 'l':
	    case 'm':
	    case 'r':
	    case 'L':
	    case 'M':
	    case 'R':
		break;
	    default:
		Bell(XkbBI_MinorError, 0);	/* let them know they goofed */
		c = 'l';	/* provide a default */
	    }
	    TekEnqMouse(tw, c | 0x80);
	    TekGINoff(tw);
	} else {
	    Bell(XkbBI_MinorError, 0);
	}
@


1.1.1.3
log
@import xterm 229
@
text
@d1 1
a1 1
/* $XTermId: Tekproc.c,v 1.157 2007/07/10 19:53:11 tom Exp $ */
d949 2
a950 1
	first_map_occurred();
d959 3
a961 4
    if (tw != 0) {
	TekScreen *tekscr = TekScreenOf(tw);
	TScreen *screen = TScreenOf(term);
	static Cursor wait_cursor = None;
d963 10
a972 11
	if (wait_cursor == None)
	    wait_cursor = make_colored_cursor(XC_watch,
					      T_COLOR(screen, MOUSE_FG),
					      T_COLOR(screen, MOUSE_BG));
	XDefineCursor(XtDisplay(tw), TWindow(tekscr), wait_cursor);
	XFlush(XtDisplay(tw));
	if (!setjmp(Tekjump))
	    Tekparse(tw);
	XDefineCursor(XtDisplay(tw), TWindow(tekscr),
		      (tekscr->TekGIN && GINcursor) ? GINcursor : tekscr->arrow);
    }
d1846 2
a1847 3
    if (tw != 0) {
	TekScreen *tekscr = TekScreenOf(tw);
	TScreen *screen = TScreenOf(term);
d1849 11
a1859 11
	TekLink *Tp;
	char buf[32];
	char initbuf[5];
	int tekcopyfd;

	timestamp_filename(buf, "COPY");
	if (access(buf, F_OK) >= 0
	    && access(buf, W_OK) < 0) {
	    Bell(XkbBI_MinorError, 0);
	    return;
	}
d1861 4
a1864 4
	if (access(".", W_OK) < 0) {	/* can't write in directory */
	    Bell(XkbBI_MinorError, 0);
	    return;
	}
d1867 11
a1877 13
	tekcopyfd = open_userfile(screen->uid, screen->gid, buf, False);
	if (tekcopyfd >= 0) {
	    sprintf(initbuf, "%c%c%c%c",
		    ANSI_ESC, (char) (tekscr->page.fontsize + '8'),
		    ANSI_ESC, (char) (tekscr->page.linetype + '`'));
	    write(tekcopyfd, initbuf, 4);
	    Tp = &Tek0;
	    do {
		write(tekcopyfd, Tp->data, Tp->count);
		Tp = Tp->next;
	    } while (Tp);
	    close(tekcopyfd);
	}
@


1.1.1.4
log
@Import xterm version 232. tested by many.
@
text
@d1 1
a1 1
/* $XTermId: Tekproc.c,v 1.158 2008/01/26 01:21:10 tom Exp $ */
d10 1
a10 1
Copyright 2001-2007,2008 by Thomas E. Dickey
a731 2
	    {
		char ch2 = (char) ch;
d737 1
a737 1
			    &ch2,
a738 1
	    }
@


