head	1.26;
access;
symbols
	OPENBSD_6_1:1.26.0.2
	OPENBSD_6_1_BASE:1.26
	OPENBSD_6_0:1.24.0.4
	OPENBSD_6_0_BASE:1.24
	OPENBSD_5_9:1.24.0.2
	OPENBSD_5_9_BASE:1.24
	OPENBSD_5_8:1.23.0.4
	OPENBSD_5_8_BASE:1.23
	OPENBSD_5_7:1.23.0.2
	OPENBSD_5_7_BASE:1.23
	OPENBSD_5_6:1.21.0.2
	OPENBSD_5_6_BASE:1.21
	OPENBSD_5_5:1.20.0.2
	OPENBSD_5_5_BASE:1.20
	OPENBSD_5_4:1.19.0.2
	OPENBSD_5_4_BASE:1.19
	OPENBSD_5_3:1.17.0.2
	OPENBSD_5_3_BASE:1.17
	OPENBSD_5_2:1.16.0.2
	OPENBSD_5_2_BASE:1.16
	OPENBSD_5_1_BASE:1.14
	OPENBSD_5_1:1.14.0.2
	OPENBSD_5_0:1.10.0.2
	OPENBSD_5_0_BASE:1.10
	OPENBSD_4_9:1.8.0.2
	OPENBSD_4_9_BASE:1.8
	OPENBSD_4_8:1.7.0.4
	OPENBSD_4_8_BASE:1.7
	OPENBSD_4_7:1.5.0.2
	OPENBSD_4_7_BASE:1.5
	OPENBSD_4_6:1.3.0.2
	OPENBSD_4_6_BASE:1.3
	OPENBSD_4_5:1.2.0.2
	OPENBSD_4_5_BASE:1.2
	OPENBSD_4_4:1.1.1.4.0.4
	OPENBSD_4_4_BASE:1.1.1.4
	OPENBSD_4_3_BASE:1.1.1.4
	OPENBSD_4_3:1.1.1.4.0.2
	v232:1.1.1.4
	v229:1.1.1.3
	OPENBSD_4_2:1.1.1.2.0.2
	OPENBSD_4_2_BASE:1.1.1.2
	v225:1.1.1.2
	v216:1.1.1.1
	xterm:1.1.1;
locks; strict;
comment	@ * @;


1.26
date	2016.11.03.14.25.06;	author matthieu;	state Exp;
branches;
next	1.25;
commitid	f4xcYrkdKFtVElPL;

1.25
date	2016.08.07.21.27.36;	author matthieu;	state Exp;
branches;
next	1.24;
commitid	psxxjI5z4Vpv2LL4;

1.24
date	2015.09.05.14.11.46;	author matthieu;	state Exp;
branches;
next	1.23;
commitid	YVUODLQ4QcYTuGkb;

1.23
date	2015.01.18.20.24.40;	author matthieu;	state Exp;
branches;
next	1.22;
commitid	PDdlFuihcMifzxwp;

1.22
date	2014.12.18.20.16.55;	author matthieu;	state Exp;
branches;
next	1.21;
commitid	pCMhkpVdt9Oe52hU;

1.21
date	2014.05.09.19.56.40;	author matthieu;	state Exp;
branches;
next	1.20;

1.20
date	2014.01.02.15.14.50;	author matthieu;	state Exp;
branches;
next	1.19;

1.19
date	2013.06.02.19.55.50;	author matthieu;	state Exp;
branches;
next	1.18;

1.18
date	2013.03.09.14.45.38;	author matthieu;	state Exp;
branches;
next	1.17;

1.17
date	2013.01.04.16.40.18;	author matthieu;	state Exp;
branches;
next	1.16;

1.16
date	2012.06.07.20.20.23;	author matthieu;	state Exp;
branches;
next	1.15;

1.15
date	2012.04.14.09.02.46;	author matthieu;	state Exp;
branches;
next	1.14;

1.14
date	2011.11.16.21.14.25;	author matthieu;	state Exp;
branches;
next	1.13;

1.13
date	2011.09.17.11.51.57;	author matthieu;	state Exp;
branches;
next	1.12;

1.12
date	2011.08.28.17.40.55;	author matthieu;	state Exp;
branches;
next	1.11;

1.11
date	2011.08.18.19.47.42;	author matthieu;	state Exp;
branches;
next	1.10;

1.10
date	2011.06.07.19.21.06;	author matthieu;	state Exp;
branches;
next	1.9;

1.9
date	2011.03.07.20.41.27;	author matthieu;	state Exp;
branches;
next	1.8;

1.8
date	2010.08.22.13.38.11;	author matthieu;	state Exp;
branches;
next	1.7;

1.7
date	2010.05.08.12.20.46;	author matthieu;	state Exp;
branches;
next	1.6;

1.6
date	2010.03.25.22.03.51;	author matthieu;	state Exp;
branches;
next	1.5;

1.5
date	2009.10.31.14.11.57;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2009.09.05.15.58.09;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2009.04.04.15.10.44;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2008.08.25.18.05.57;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.26.11.11.43;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.11.26.11.11.43;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2007.06.15.19.30.35;	author matthieu;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2007.08.25.18.54.09;	author matthieu;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2008.02.16.09.35.16;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.26
log
@Update to xterm 327
@
text
@/* $XTermId: trace.c,v 1.166 2016/10/05 09:16:01 tom Exp $ */

/*
 * Copyright 1997-2015,2016 by Thomas E. Dickey
 *
 *                         All Rights Reserved
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 *
 * The above copyright notice and this permission notice shall be included
 * in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
 * IN NO EVENT SHALL THE ABOVE LISTED COPYRIGHT HOLDER(S) BE LIABLE FOR ANY
 * CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
 * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
 * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 *
 * Except as contained in this notice, the name(s) of the above copyright
 * holders shall not be used in advertising or otherwise to promote the
 * sale, use or other dealings in this Software without prior written
 * authorization.
 */

/*
 * debugging support via TRACE macro.
 */

#include <xterm.h>		/* for definition of GCC_UNUSED */
#include <version.h>

#if OPT_TRACE

#include <data.h>
#include <trace.h>

#include <time.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <stdio.h>
#include <stdarg.h>
#include <assert.h>

#include <X11/Xatom.h>
#include <X11/Xmu/Atoms.h>

#ifdef HAVE_X11_TRANSLATEI_H
#include <X11/ConvertI.h>
#include <X11/TranslateI.h>
#else
#ifdef __cplusplus
extern "C" {
#endif

    extern String _XtPrintXlations(Widget w,
				   XtTranslations xlations,
				   Widget accelWidget,
				   _XtBoolean includeRHS);
#ifdef __cplusplus
}
#endif
#endif
const char *trace_who = "parent";

static FILE *trace_fp;

void
Trace(const char *fmt,...)
{
    static const char *trace_out;
    va_list ap;

    if (trace_fp != 0
	&& trace_who != trace_out) {
	fclose(trace_fp);
	trace_fp = 0;
    }
    trace_out = trace_who;

    if (!trace_fp) {
	unsigned oldmask = (unsigned) umask(077);
	char name[BUFSIZ];
#if 0				/* usually I do not want unique names */
	int unique;
	for (unique = 0;; ++unique) {
	    if (unique)
		sprintf(name, "Trace-%s.out-%d", trace_who, unique);
	    else
		sprintf(name, "Trace-%s.out", trace_who);
	    if ((trace_fp = fopen(name, "r")) == 0) {
		break;
	    }
	    fclose(trace_fp);
	}
#else
	sprintf(name, "Trace-%s.out", trace_who);
#endif
	trace_fp = fopen(name, "w");
	/*
	 * Try to put the trace-file in user's home-directory if the current
	 * directory is not writable.
	 */
	if (trace_fp == 0) {
	    char *home = getenv("HOME");
	    if (home != 0) {
		sprintf(name, "%.*s/Trace-%.8s.out",
			(BUFSIZ - 21), home,
			trace_who);
		trace_fp = fopen(name, "w");
	    }
	}
	if (trace_fp != 0) {
	    fprintf(trace_fp, "%s\n", xtermVersion());
	    TraceIds(NULL, 0);
	}
	if (!trace_fp) {
	    xtermWarning("Cannot open \"%s\"\n", name);
	    exit(EXIT_FAILURE);
	}
	(void) umask(oldmask);
    }

    va_start(ap, fmt);
    vfprintf(trace_fp, fmt, ap);
    (void) fflush(trace_fp);
    va_end(ap);
}

void
TraceClose(void)
{
    if (trace_fp != 0) {
	(void) fclose(trace_fp);
	(void) fflush(stdout);
	(void) fflush(stderr);
	(void) visibleChars(NULL, 0);
	(void) visibleIChars(NULL, 0);
	trace_fp = 0;
    }
}

void
TraceIds(const char *fname, int lnum)
{
    Trace("process %d ", (int) getpid());
#ifdef HAVE_UNISTD_H
    Trace("real (%u/%u) effective (%u/%u)",
	  (unsigned) getuid(), (unsigned) getgid(),
	  (unsigned) geteuid(), (unsigned) getegid());
#endif
    if (fname != 0) {
	Trace(" (%s@@%d)\n", fname, lnum);
    } else {
	time_t now = time((time_t *) 0);
	Trace("-- %s", ctime(&now));
    }
}

void
TraceTime(const char *fname, int lnum)
{
    time_t now;
    if (fname != 0) {
	Trace("datetime (%s@@%d) ", fname, lnum);
    }
    now = time((time_t *) 0);
    Trace("-- %s", ctime(&now));
}

static void
formatAscii(char *dst, unsigned value)
{
    switch (value) {
    case '\\':
	sprintf(dst, "\\\\");
	break;
    case '\b':
	sprintf(dst, "\\b");
	break;
    case '\n':
	sprintf(dst, "\\n");
	break;
    case '\r':
	sprintf(dst, "\\r");
	break;
    case '\t':
	sprintf(dst, "\\t");
	break;
    default:
	if (E2A(value) < 32 || (E2A(value) >= 127 && E2A(value) < 160))
	    sprintf(dst, "\\%03o", value & 0xff);
	else
	    sprintf(dst, "%c", CharOf(value));
	break;
    }
}

#if OPT_DEC_CHRSET

const char *
visibleDblChrset(unsigned chrset)
{
    const char *result = "?";
    switch (chrset) {
    case CSET_SWL:
	result = "CSET_SWL";
	break;
    case CSET_DHL_TOP:
	result = "CSET_DHL_TOP";
	break;
    case CSET_DHL_BOT:
	result = "CSET_DHL_BOT";
	break;
    case CSET_DWL:
	result = "CSET_DWL";
	break;
    }
    return result;
}
#endif

const char *
visibleScsCode(int chrset)
{
#define MAP(to,from) case from: result = to; break
    const char *result = "<ERR>";
    switch ((DECNRCM_codes) chrset) {
	MAP("B", nrc_ASCII);
	MAP("A", nrc_British);
	MAP("A", nrc_British_Latin_1);
	MAP("&4", nrc_Cyrillic);
	MAP("0", nrc_DEC_Spec_Graphic);
	MAP("1", nrc_DEC_Alt_Chars);
	MAP("2", nrc_DEC_Alt_Graphics);
	MAP("<", nrc_DEC_Supp);
	MAP("%5", nrc_DEC_Supp_Graphic);
	MAP(">", nrc_DEC_Technical);
	MAP("4", nrc_Dutch);
	MAP("5", nrc_Finnish);
	MAP("C", nrc_Finnish2);
	MAP("R", nrc_French);
	MAP("f", nrc_French2);
	MAP("Q", nrc_French_Canadian);
	MAP("9", nrc_French_Canadian2);
	MAP("K", nrc_German);
	MAP("\"?", nrc_Greek);
	MAP("F", nrc_Greek_Supp);
	MAP("\"4", nrc_Hebrew);
	MAP("%=", nrc_Hebrew2);
	MAP("H", nrc_Hebrew_Supp);
	MAP("Y", nrc_Italian);
	MAP("M", nrc_Latin_5_Supp);
	MAP("L", nrc_Latin_Cyrillic);
	MAP("`", nrc_Norwegian_Danish);
	MAP("E", nrc_Norwegian_Danish2);
	MAP("6", nrc_Norwegian_Danish3);
	MAP("%6", nrc_Portugese);
	MAP("&5", nrc_Russian);
	MAP("%3", nrc_SCS_NRCS);
	MAP("Z", nrc_Spanish);
	MAP("7", nrc_Swedish);
	MAP("H", nrc_Swedish2);
	MAP("=", nrc_Swiss);
	MAP("%0", nrc_Turkish);
	MAP("%2", nrc_Turkish2);
	MAP("<UNK>", nrc_Unknown);
    }
#undef MAP
    return result;
}

const char *
visibleChars(const Char *buf, unsigned len)
{
    static char *result;
    static unsigned used;

    if (buf != 0) {
	unsigned limit = ((len + 1) * 8) + 1;

	if (limit > used) {
	    used = limit;
	    result = XtRealloc(result, used);
	}
	if (result != 0) {
	    char *dst = result;
	    *dst = '\0';
	    while (len--) {
		unsigned value = *buf++;
		formatAscii(dst, value);
		dst += strlen(dst);
	    }
	}
    } else if (result != 0) {
	free(result);
	result = 0;
	used = 0;
    }
    return NonNull(result);
}

const char *
visibleIChars(const IChar *buf, unsigned len)
{
    static char *result;
    static unsigned used;

    if (buf != 0) {
	unsigned limit = ((len + 1) * 8) + 1;

	if (limit > used) {
	    used = limit;
	    result = XtRealloc(result, used);
	}
	if (result != 0) {
	    char *dst = result;
	    *dst = '\0';
	    while (len--) {
		unsigned value = *buf++;
#if OPT_WIDE_CHARS
		if (value > 255)
		    sprintf(dst, "\\u+%04X", value);
		else
#endif
		    formatAscii(dst, value);
		dst += strlen(dst);
	    }
	}
    } else if (result != 0) {
	free(result);
	result = 0;
	used = 0;
    }
    return NonNull(result);
}

const char *
visibleUChar(unsigned chr)
{
    IChar buf[1];
    buf[0] = chr;
    return visibleIChars(buf, 1);
}

const char *
visibleEventType(int type)
{
    const char *result = "?";
    switch (type) {
	CASETYPE(KeyPress);
	CASETYPE(KeyRelease);
	CASETYPE(ButtonPress);
	CASETYPE(ButtonRelease);
	CASETYPE(MotionNotify);
	CASETYPE(EnterNotify);
	CASETYPE(LeaveNotify);
	CASETYPE(FocusIn);
	CASETYPE(FocusOut);
	CASETYPE(KeymapNotify);
	CASETYPE(Expose);
	CASETYPE(GraphicsExpose);
	CASETYPE(NoExpose);
	CASETYPE(VisibilityNotify);
	CASETYPE(CreateNotify);
	CASETYPE(DestroyNotify);
	CASETYPE(UnmapNotify);
	CASETYPE(MapNotify);
	CASETYPE(MapRequest);
	CASETYPE(ReparentNotify);
	CASETYPE(ConfigureNotify);
	CASETYPE(ConfigureRequest);
	CASETYPE(GravityNotify);
	CASETYPE(ResizeRequest);
	CASETYPE(CirculateNotify);
	CASETYPE(CirculateRequest);
	CASETYPE(PropertyNotify);
	CASETYPE(SelectionClear);
	CASETYPE(SelectionRequest);
	CASETYPE(SelectionNotify);
	CASETYPE(ColormapNotify);
	CASETYPE(ClientMessage);
	CASETYPE(MappingNotify);
    }
    return result;
}

const char *
visibleNotifyMode(int code)
{
    const char *result = "?";
    switch (code) {
	CASETYPE(NotifyNormal);
	CASETYPE(NotifyGrab);
	CASETYPE(NotifyUngrab);
	CASETYPE(NotifyWhileGrabbed);
    }
    return result;
}

const char *
visibleNotifyDetail(int code)
{
    const char *result = "?";
    switch (code) {
	CASETYPE(NotifyAncestor);
	CASETYPE(NotifyVirtual);
	CASETYPE(NotifyInferior);
	CASETYPE(NotifyNonlinear);
	CASETYPE(NotifyNonlinearVirtual);
	CASETYPE(NotifyPointer);
	CASETYPE(NotifyPointerRoot);
	CASETYPE(NotifyDetailNone);
    }
    return result;
}

const char *
visibleSelectionTarget(Display *d, Atom a)
{
    const char *result = "?";

    if (a == XA_STRING) {
	result = "XA_STRING";
    } else if (a == XA_TEXT(d)) {
	result = "XA_TEXT()";
    } else if (a == XA_COMPOUND_TEXT(d)) {
	result = "XA_COMPOUND_TEXT()";
    } else if (a == XA_UTF8_STRING(d)) {
	result = "XA_UTF8_STRING()";
    } else if (a == XA_TARGETS(d)) {
	result = "XA_TARGETS()";
    }

    return result;
}

const char *
visibleTekparse(int code)
{
    static const struct {
	int code;
	const char *name;
    } table[] = {
#include "Tekparse.cin"
    };
    const char *result = "?";
    Cardinal n;
    for (n = 0; n < XtNumber(table); ++n) {
	if (table[n].code == code) {
	    result = table[n].name;
	    break;
	}
    }
    return result;
}

const char *
visibleVTparse(int code)
{
    static const struct {
	int code;
	const char *name;
    } table[] = {
#include "VTparse.cin"
    };
    const char *result = "?";
    Cardinal n;
    for (n = 0; n < XtNumber(table); ++n) {
	if (table[n].code == code) {
	    result = table[n].name;
	    break;
	}
    }
    return result;
}

const char *
visibleXError(int code)
{
    static char temp[80];
    const char *result = "?";
    switch (code) {
	CASETYPE(Success);
	CASETYPE(BadRequest);
	CASETYPE(BadValue);
	CASETYPE(BadWindow);
	CASETYPE(BadPixmap);
	CASETYPE(BadAtom);
	CASETYPE(BadCursor);
	CASETYPE(BadFont);
	CASETYPE(BadMatch);
	CASETYPE(BadDrawable);
	CASETYPE(BadAccess);
	CASETYPE(BadAlloc);
	CASETYPE(BadColor);
	CASETYPE(BadGC);
	CASETYPE(BadIDChoice);
	CASETYPE(BadName);
	CASETYPE(BadLength);
	CASETYPE(BadImplementation);
    default:
	sprintf(temp, "%d", code);
	result = temp;
	break;
    }
    return result;
}

#if OPT_TRACE_FLAGS
#define isScrnFlag(flag) ((flag) == LINEWRAPPED)

static char *
ScrnText(LineData *ld)
{
    return visibleIChars(ld->charData, ld->lineSize);
}

#define SHOW_BAD_LINE(name, ld) \
	Trace("OOPS " #name " bad row\n")

#define SHOW_SCRN_FLAG(name,code) \
	Trace(#name " %s:%s\n", \
	      code ? "*" : "", \
	      ScrnText(ld))

void
LineClrFlag(LineData *ld, int flag)
{
    if (ld == 0) {
	SHOW_BAD_LINE(LineClrFlag, ld);
	assert(0);
    } else if (isScrnFlag(flag)) {
	SHOW_SCRN_FLAG(LineClrFlag, 0);
    }

    LineFlags(ld) &= ~flag;
}

void
LineSetFlag(LineData *ld, int flag)
{
    if (ld == 0) {
	SHOW_BAD_LINE(LineSetFlag, ld);
	assert(0);
    } else if (isScrnFlag(flag)) {
	SHOW_SCRN_FLAG(LineSetFlag, 1);
    }

    LineFlags(ld) |= flag;
}

int
LineTstFlag(LineData ld, int flag)
{
    int code = 0;
    if (ld == 0) {
	SHOW_BAD_LINE(LineTstFlag, ld);
    } else {
	code = LineFlags(ld);

	if (isScrnFlag(flag)) {
	    SHOW_SCRN_FLAG(LineTstFlag, code);
	}
    }
    return code;
}
#endif /* OPT_TRACE_FLAGS */

/*
 * Trace the normal or alternate screen, showing color values up to 16, e.g.,
 * for debugging with vttest.
 */
void
TraceScreen(XtermWidget xw, int whichBuf)
{
    TScreen *screen = TScreenOf(xw);

    if (screen->editBuf_index[whichBuf]) {
	int row;

	TRACE(("TraceScreen %d:\n", whichBuf));
	for (row = 0; row <= screen->max_row; ++row) {
	    LineData *ld = getLineData(screen, row);

	    TRACE((" %3d:", row));
	    if (ld != 0) {
		int col;

		for (col = 0; col < ld->lineSize; ++col) {
		    int ch = (int) ld->charData[col];
		    if (ch < ' ')
			ch = ' ';
		    if (ch >= 127)
			ch = '#';
		    TRACE(("%c", ch));
		}
		TRACE((":\n"));

		TRACE(("  xx:"));
		for (col = 0; col < ld->lineSize; ++col) {
		    unsigned attrs = ld->attribs[col];
		    char ch;
		    if (attrs & PROTECTED) {
			ch = '*';
		    } else if (attrs & BLINK) {
			ch = 'B';
		    } else if (attrs & CHARDRAWN) {
			ch = '+';
		    } else {
			ch = ' ';
		    }
		    TRACE(("%c", ch));
		}
		TRACE((":\n"));

#if 0
		TRACE(("  fg:"));
		for (col = 0; col < ld->lineSize; ++col) {
		    unsigned fg = extract_fg(xw, ld->color[col], ld->attribs[col]);
		    if (fg > 15)
			fg = 15;
		    TRACE(("%1x", fg));
		}
		TRACE((":\n"));

		TRACE(("  bg:"));
		for (col = 0; col < ld->lineSize; ++col) {
		    unsigned bg = extract_bg(xw, ld->color[col], ld->attribs[col]);
		    if (bg > 15)
			bg = 15;
		    TRACE(("%1x", bg));
		}
		TRACE((":\n"));
#endif
	    } else {
		TRACE(("null lineData\n"));
	    }
	}
    } else {
	TRACE(("TraceScreen %d is nil\n", whichBuf));
    }
}

void
TraceFocus(Widget w, XEvent *ev)
{
    TRACE(("trace_focus event type %d:%s\n",
	   ev->type, visibleEventType(ev->type)));
    switch (ev->type) {
    case FocusIn:
    case FocusOut:
	{
	    XFocusChangeEvent *event = (XFocusChangeEvent *) ev;
	    TRACE(("\tdetail: %s\n", visibleNotifyDetail(event->detail)));
	    TRACE(("\tmode:   %s\n", visibleNotifyMode(event->mode)));
	    TRACE(("\twindow: %#lx\n", event->window));
	}
	break;
    case EnterNotify:
    case LeaveNotify:
	{
	    XCrossingEvent *event = (XCrossingEvent *) ev;
	    TRACE(("\tdetail:    %s\n", visibleNotifyDetail(event->detail)));
	    TRACE(("\tmode:      %s\n", visibleNotifyMode(event->mode)));
	    TRACE(("\twindow:    %#lx\n", event->window));
	    TRACE(("\tfocus:     %d\n", event->focus));
	    TRACE(("\troot:      %#lx\n", event->root));
	    TRACE(("\tsubwindow: %#lx\n", event->subwindow));
	}
	break;
    }
    while (w != 0) {
	TRACE(("w %p -> %#lx\n", (void *) w, XtWindow(w)));
	w = XtParent(w);
    }
}

void
TraceSizeHints(XSizeHints * hints)
{
    TRACE(("size hints:\n"));
    if (hints->flags & (USPosition | PPosition))
	TRACE(("   position   %d,%d%s%s\n", hints->y, hints->x,
	       (hints->flags & USPosition) ? " user" : "",
	       (hints->flags & PPosition) ? " prog" : ""));
    if (hints->flags & (USSize | PSize))
	TRACE(("   size       %d,%d%s%s\n", hints->height, hints->width,
	       (hints->flags & USSize) ? " user" : "",
	       (hints->flags & PSize) ? " prog" : ""));
    if (hints->flags & PMinSize)
	TRACE(("   min        %d,%d\n", hints->min_height, hints->min_width));
    if (hints->flags & PMaxSize)
	TRACE(("   max        %d,%d\n", hints->max_height, hints->max_width));
    if (hints->flags & PResizeInc)
	TRACE(("   inc        %d,%d\n", hints->height_inc, hints->width_inc));
    else
	TRACE(("   inc        NONE!\n"));
    if (hints->flags & PAspect)
	TRACE(("   min aspect %d/%d\n", hints->min_aspect.y, hints->min_aspect.y));
    if (hints->flags & PAspect)
	TRACE(("   max aspect %d/%d\n", hints->max_aspect.y, hints->max_aspect.y));
    if (hints->flags & PBaseSize)
	TRACE(("   base       %d,%d\n", hints->base_height, hints->base_width));
    if (hints->flags & PWinGravity)
	TRACE(("   gravity    %d\n", hints->win_gravity));
}

static void
TraceEventMask(const char *tag, long mask)
{
#define DATA(name) { name##Mask, #name }
    /* *INDENT-OFF* */
    static struct {
	long mask;
	const char *name;
    } table[] = {
	DATA(KeyPress),
	DATA(KeyRelease),
	DATA(ButtonPress),
	DATA(ButtonRelease),
	DATA(EnterWindow),
	DATA(LeaveWindow),
	DATA(PointerMotion),
	DATA(PointerMotionHint),
	DATA(Button1Motion),
	DATA(Button2Motion),
	DATA(Button3Motion),
	DATA(Button4Motion),
	DATA(Button5Motion),
	DATA(ButtonMotion),
	DATA(KeymapState),
	DATA(Exposure),
	DATA(VisibilityChange),
	DATA(StructureNotify),
	DATA(ResizeRedirect),
	DATA(SubstructureNotify),
	DATA(SubstructureRedirect),
	DATA(FocusChange),
	DATA(PropertyChange),
	DATA(ColormapChange),
	DATA(OwnerGrabButton),
    };
#undef DATA
    Cardinal n;
    /* *INDENT-ON* */

    for (n = 0; n < XtNumber(table); ++n) {
	if (table[n].mask & mask) {
	    TRACE(("%s %s\n", tag, table[n].name));
	}
    }
}

void
TraceWindowAttributes(XWindowAttributes * attrs)
{
    TRACE(("window attributes:\n"));
    TRACE(("   position     %d,%d\n", attrs->y, attrs->x));
    TRACE(("   size         %dx%d\n", attrs->height, attrs->width));
    TRACE(("   border       %d\n", attrs->border_width));
    TRACE(("   depth        %d\n", attrs->depth));
    TRACE(("   bit_gravity  %d\n", attrs->bit_gravity));
    TRACE(("   win_gravity  %d\n", attrs->win_gravity));
    TRACE(("   root         %#lx\n", (long) attrs->root));
    TRACE(("   class        %s\n", ((attrs->class == InputOutput)
				    ? "InputOutput"
				    : ((attrs->class == InputOnly)
				       ? "InputOnly"
				       : "unknown"))));
    TRACE(("   map_state    %s\n", ((attrs->map_state == IsUnmapped)
				    ? "IsUnmapped"
				    : ((attrs->map_state == IsUnviewable)
				       ? "IsUnviewable"
				       : ((attrs->map_state == IsViewable)
					  ? "IsViewable"
					  : "unknown")))));
    TRACE(("   all_events\n"));
    TraceEventMask("        ", attrs->all_event_masks);
    TRACE(("   your_events\n"));
    TraceEventMask("        ", attrs->your_event_mask);
    TRACE(("   no_propagate\n"));
    TraceEventMask("        ", attrs->do_not_propagate_mask);
}

void
TraceWMSizeHints(XtermWidget xw)
{
    XSizeHints sizehints = xw->hints;

    getXtermSizeHints(xw);
    TraceSizeHints(&xw->hints);
    xw->hints = sizehints;
}

/*
 * Some calls to XGetAtom() will fail, and we don't want to stop.  So we use
 * our own error-handler.
 */
/* ARGSUSED */
static int
no_error(Display *dpy GCC_UNUSED, XErrorEvent *event GCC_UNUSED)
{
    return 1;
}

const char *
ModifierName(unsigned modifier)
{
    const char *s = "";
    if (modifier & ShiftMask)
	s = " Shift";
    else if (modifier & LockMask)
	s = " Lock";
    else if (modifier & ControlMask)
	s = " Control";
    else if (modifier & Mod1Mask)
	s = " Mod1";
    else if (modifier & Mod2Mask)
	s = " Mod2";
    else if (modifier & Mod3Mask)
	s = " Mod3";
    else if (modifier & Mod4Mask)
	s = " Mod4";
    else if (modifier & Mod5Mask)
	s = " Mod5";
    return s;
}

void
TraceTranslations(const char *name, Widget w)
{
    String result;
    XErrorHandler save = XSetErrorHandler(no_error);
    XtTranslations xlations;
    Widget xcelerat;

    TRACE(("TraceTranslations for %s (widget %#lx) {{\n", name, (long) w));
    if (w) {
	XtVaGetValues(w,
		      XtNtranslations, &xlations,
		      XtNaccelerators, &xcelerat,
		      (XtPointer) 0);
	TRACE(("... xlations %#08lx\n", (long) xlations));
	TRACE(("... xcelerat %#08lx\n", (long) xcelerat));
	result = _XtPrintXlations(w, xlations, xcelerat, True);
	TRACE(("%s\n", NonNull(result)));
	if (result)
	    XFree((char *) result);
    } else {
	TRACE(("none (widget is null)\n"));
    }
    TRACE(("}}\n"));
    XSetErrorHandler(save);
}

XtGeometryResult
TraceResizeRequest(const char *fn, int ln, Widget w,
		   unsigned reqwide,
		   unsigned reqhigh,
		   Dimension *gotwide,
		   Dimension *gothigh)
{
    XtGeometryResult rc;

    TRACE(("%s@@%d ResizeRequest %ux%u\n", fn, ln, reqhigh, reqwide));
    rc = XtMakeResizeRequest((Widget) w,
			     (Dimension) reqwide,
			     (Dimension) reqhigh,
			     gotwide, gothigh);
    TRACE(("... ResizeRequest -> "));
    if (gothigh && gotwide)
	TRACE(("%dx%d ", *gothigh, *gotwide));
    TRACE(("(%d)\n", rc));
    return rc;
}

#define XRES_S(name) Trace(#name " = %s\n", NonNull(resp->name))
#define XRES_B(name) Trace(#name " = %s\n", MtoS(resp->name))
#define XRES_I(name) Trace(#name " = %d\n", resp->name)

void
TraceXtermResources(void)
{
    XTERM_RESOURCE *resp = &resource;

    Trace("XTERM_RESOURCE settings:\n");
    XRES_S(icon_geometry);
    XRES_S(title);
    XRES_S(icon_hint);
    XRES_S(icon_name);
    XRES_S(term_name);
    XRES_S(tty_modes);
    XRES_I(minBufSize);
    XRES_I(maxBufSize);
    XRES_B(hold_screen);
    XRES_B(utmpInhibit);
    XRES_B(utmpDisplayId);
    XRES_B(messages);
    XRES_S(menuLocale);
    XRES_S(omitTranslation);
    XRES_S(keyboardType);
#if OPT_PRINT_ON_EXIT
    XRES_I(printModeNow);
    XRES_I(printModeOnXError);
    XRES_I(printOptsNow);
    XRES_I(printOptsOnXError);
    XRES_S(printFileNow);
    XRES_S(printFileOnXError);
#endif
#if OPT_SUNPC_KBD
    XRES_B(sunKeyboard);
#endif
#if OPT_HP_FUNC_KEYS
    XRES_B(hpFunctionKeys);
#endif
#if OPT_SCO_FUNC_KEYS
    XRES_B(scoFunctionKeys);
#endif
#if OPT_SUN_FUNC_KEYS
    XRES_B(sunFunctionKeys);
#endif
#if OPT_INITIAL_ERASE
    XRES_B(ptyInitialErase);
    XRES_B(backarrow_is_erase);
#endif
    XRES_B(useInsertMode);
#if OPT_ZICONBEEP
    XRES_I(zIconBeep);
    XRES_S(zIconFormat);
#endif
#if OPT_PTY_HANDSHAKE
    XRES_B(wait_for_map);
    XRES_B(ptyHandshake);
    XRES_B(ptySttySize);
#endif
#if OPT_REPORT_COLORS
    XRES_B(reportColors);
#endif
#if OPT_REPORT_FONTS
    XRES_B(reportFonts);
#endif
#if OPT_SAME_NAME
    XRES_B(sameName);
#endif
#if OPT_SESSION_MGT
    XRES_B(sessionMgt);
#endif
#if OPT_TOOLBAR
    XRES_B(toolBar);
#endif
#if OPT_MAXIMIZE
    XRES_B(maximized);
    XRES_S(fullscreen_s);
#endif
}

void
TraceArgv(const char *tag, char **argv)
{
    int n = 0;

    TRACE(("%s:\n", tag));
    while (*argv != 0) {
	TRACE(("  %d:%s\n", n++, *argv++));
    }
}

static char *
parse_option(char *dst, String src, int first)
{
    char *s;

    if (!strncmp(src, "-/+", (size_t) 3)) {
	dst[0] = (char) first;
	strcpy(dst + 1, src + 3);
    } else {
	strcpy(dst, src);
    }
    for (s = dst; *s != '\0'; s++) {
	if (*s == '#' || *s == '%' || *s == 'S') {
	    s[1] = '\0';
	} else if (*s == ' ') {
	    *s = '\0';
	    break;
	}
    }
    return dst;
}

static Bool
same_option(OptionHelp * opt, XrmOptionDescRec * res)
{
    char temp[BUFSIZ];
    return !strcmp(parse_option(temp, opt->opt, res->option[0]), res->option);
}

static Bool
standard_option(String opt)
{
    static const char *table[] =
    {
	"+rv",
	"+synchronous",
	"-background",
	"-bd",
	"-bg",
	"-bordercolor",
	"-borderwidth",
	"-bw",
	"-display",
	"-fg",
	"-fn",
	"-font",
	"-foreground",
	"-geometry",
	"-iconic",
	"-name",
	"-reverse",
	"-rv",
	"-selectionTimeout",
	"-synchronous",
	"-title",
	"-xnllanguage",
	"-xrm",
	"-xtsessionID",
    };
    Cardinal n;
    char temp[BUFSIZ];

    opt = parse_option(temp, opt, '-');
    for (n = 0; n < XtNumber(table); n++) {
	if (!strcmp(opt, table[n]))
	    return True;
    }
    return False;
}

/*
 * Analyse the options/help messages for inconsistencies.
 */
void
TraceOptions(OptionHelp * options, XrmOptionDescRec * resources, Cardinal res_count)
{
    OptionHelp *opt_array = sortedOpts(options, resources, res_count);
    size_t j, k;
    XrmOptionDescRec *res_array = sortedOptDescs(resources, res_count);
    Bool first, found;

    TRACE(("Checking options-tables for inconsistencies:\n"));

#if 0
    TRACE(("Options listed in help-message:\n"));
    for (j = 0; options[j].opt != 0; j++)
	TRACE(("%5d %-28s %s\n", j, opt_array[j].opt, opt_array[j].desc));
    TRACE(("Options listed in resource-table:\n"));
    for (j = 0; j < res_count; j++)
	TRACE(("%5d %-28s %s\n", j, res_array[j].option, res_array[j].specifier));
#endif

    /* list all options[] not found in resources[] */
    for (j = 0, first = True; options[j].opt != 0; j++) {
	found = False;
	for (k = 0; k < res_count; k++) {
	    if (same_option(&opt_array[j], &res_array[k])) {
		found = True;
		break;
	    }
	}
	if (!found) {
	    if (first) {
		TRACE(("Options listed in help, not found in resource list:\n"));
		first = False;
	    }
	    TRACE(("  %-28s%s\n", opt_array[j].opt,
		   standard_option(opt_array[j].opt) ? " (standard)" : ""));
	}
    }

    /* list all resources[] not found in options[] */
    for (j = 0, first = True; j < res_count; j++) {
	found = False;
	for (k = 0; options[k].opt != 0; k++) {
	    if (same_option(&opt_array[k], &res_array[j])) {
		found = True;
		break;
	    }
	}
	if (!found) {
	    if (first) {
		TRACE(("Resource list items not found in options-help:\n"));
		first = False;
	    }
	    TRACE(("  %s\n", res_array[j].option));
	}
    }

    TRACE(("Resource list items that will be ignored by XtOpenApplication:\n"));
    for (j = 0; j < res_count; j++) {
	switch (res_array[j].argKind) {
	case XrmoptionSkipArg:
	    TRACE(("  %-28s {param}\n", res_array[j].option));
	    break;
	case XrmoptionSkipNArgs:
	    TRACE(("  %-28s {%ld params}\n", res_array[j].option, (long)
		   res_array[j].value));
	    break;
	case XrmoptionSkipLine:
	    TRACE(("  %-28s {remainder of line}\n", res_array[j].option));
	    break;
	case XrmoptionIsArg:
	case XrmoptionNoArg:
	case XrmoptionResArg:
	case XrmoptionSepArg:
	case XrmoptionStickyArg:
	default:
	    break;
	}
    }
}
#else
extern void empty_trace(void);
void
empty_trace(void)
{
}
#endif
@


1.25
log
@Update to xterm-325. Testing by krw@@, shadchin@@ and naddy@@. Thanks
@
text
@d1 1
a1 1
/* $XTermId: trace.c,v 1.165 2016/05/31 00:48:42 tom Exp $ */
d444 40
@


1.24
log
@Update to xterm 320. Tested by jsg@@ Thanks.
@
text
@d1 1
a1 1
/* $XTermId: trace.c,v 1.159 2015/03/02 02:00:48 tom Exp $ */
d4 1
a4 1
 * Copyright 1997-2014,2015 by Thomas E. Dickey
d58 1
d282 1
a282 1
char *
a289 1
	char *dst;
d296 1
a296 1
	    dst = result;
d312 1
a312 1
char *
a319 1
	char *dst;
d326 1
a326 1
	    dst = result;
d347 1
a347 1
char *
a354 18
#define CASETYPE(name) case name: result = #name; break

const char *
visibleKeyboardType(xtermKeyboardType type)
{
    const char *result = "?";
    switch (type) {
	CASETYPE(keyboardIsLegacy);	/* bogus vt220 codes for F1-F4, etc. */
	CASETYPE(keyboardIsDefault);
	CASETYPE(keyboardIsHP);
	CASETYPE(keyboardIsSCO);
	CASETYPE(keyboardIsSun);
	CASETYPE(keyboardIsTermcap);
	CASETYPE(keyboardIsVT220);
    }
    return result;
}

a546 1
    int row, col;
d549 2
d554 1
d557 2
d654 2
a655 2
	       hints->flags & USPosition ? " user" : "",
	       hints->flags & PPosition ? " prog" : ""));
d658 2
a659 2
	       hints->flags & USSize ? " user" : "",
	       hints->flags & PSize ? " prog" : ""));
@


1.23
log
@xterm 314. tested by naddy@@
@
text
@d1 1
a1 1
/* $XTermId: trace.c,v 1.157 2014/12/25 22:01:07 tom Exp $ */
d4 1
a4 1
 * Copyright 1997-2013,2014 by Thomas E. Dickey
d863 1
a863 1
#define XRES_B(name) Trace(#name " = %s\n", BtoS(resp->name))
@


1.22
log
@Update to xterm 313. Tested by shadchin@@
@
text
@d1 1
a1 1
/* $XTermId: trace.c,v 1.156 2014/11/13 01:03:02 tom Exp $ */
d309 1
a309 1
    return result;
d345 1
a345 1
    return result;
@


1.21
log
@Update to xterm 304. With help of shadchin@@

tested by ajacoutot@@ and shadchin@@
@
text
@d1 1
a1 1
/* $XTermId: trace.c,v 1.155 2014/04/25 21:30:23 Ross.Combs Exp $ */
d313 1
a313 1
visibleIChars(IChar *buf, unsigned len)
d630 1
a630 1
TraceFocus(Widget w, XEvent * ev)
d786 1
a786 1
no_error(Display *dpy GCC_UNUSED, XErrorEvent * event GCC_UNUSED)
@


1.20
log
@Update to xterm-300. Tested  by ajacoutot@@ and shadchin@@.
@
text
@d1 1
a1 1
/* $XTermId: trace.c,v 1.153 2013/11/26 22:41:44 tom Exp $ */
d4 1
a4 1
 * Copyright 1997-2012,2013 by Thomas E. Dickey
d49 1
d90 1
a90 1
	unsigned oldmask = umask(077);
d920 3
@


1.19
log
@Update to xterm 293. Tested by naddy@@ ajacoutot@@
@
text
@d1 1
a1 1
/* $XTermId: trace.c,v 1.146 2013/04/21 00:37:00 tom Exp $ */
d107 13
a145 1
	(void) visibleIChar(NULL, 0);
d199 1
a199 1
	    sprintf(dst, "\\%03o", value);
d209 1
a209 1
visibleChrsetName(unsigned chrset)
d230 50
d281 1
a281 1
visibleChars(const Char * buf, unsigned len)
d312 1
a312 1
visibleIChars(IChar * buf, unsigned len)
d348 1
a348 1
visibleIChar(IChar * buf, unsigned len)
d350 3
a352 30
    static char *result;
    static unsigned used;

    if (buf != 0) {
	unsigned limit = ((len + 1) * 8) + 1;
	char *dst;

	if (limit > used) {
	    used = limit;
	    result = XtRealloc(result, used);
	}
	if (result != 0) {
	    dst = result;
	    while (len--) {
		unsigned value = *buf++;
#if OPT_WIDE_CHARS
		if (value > 255)
		    sprintf(dst, "\\u+%04X", value);
		else
#endif
		    formatAscii(dst, value);
		dst += strlen(dst);
	    }
	}
    } else if (result != 0) {
	free(result);
	result = 0;
	used = 0;
    }
    return result;
d446 1
a446 1
visibleSelectionTarget(Display * d, Atom a)
d501 1
a501 1
ScrnText(LineData * ld)
d515 1
a515 1
LineClrFlag(LineData * ld, int flag)
d528 1
a528 1
LineSetFlag(LineData * ld, int flag)
d785 1
a785 1
no_error(Display * dpy GCC_UNUSED, XErrorEvent * event GCC_UNUSED)
d844 2
a845 2
		   Dimension * gotwide,
		   Dimension * gothigh)
d919 3
@


1.18
log
@Update to xterm 291. Tested by many.
@
text
@d1 1
a1 1
/* $XTermId: trace.c,v 1.145 2013/02/06 09:51:17 tom Exp $ */
d89 1
d115 1
@


1.17
log
@Update to xterm 287. tested by mpi@@ and krw@@.
@
text
@d1 1
a1 1
/* $XTermId: trace.c,v 1.142 2012/11/22 20:19:54 tom Exp $ */
d4 1
a4 1
 * Copyright 1997-2011,2012 by Thomas E. Dickey
d38 1
d751 23
@


1.16
log
@Update to xterm 279. Tested by krw@@, mpi@@, shadchin@@.
@
text
@d1 1
a1 1
/* $XTermId: trace.c,v 1.140 2012/05/06 18:01:58 tom Exp $ */
d378 13
d601 1
a601 1
	    TRACE(("\tmode:   %d\n", event->mode));
d610 1
a610 1
	    TRACE(("\tmode:      %d\n", event->mode));
d812 1
@


1.15
log
@Update to xterm 278. Tested by mpi@@, shadchin@@
@
text
@d1 1
a1 1
/* $XTermId: trace.c,v 1.133 2011/12/27 10:10:53 tom Exp $ */
d4 1
a4 1
 * Copyright 1997-2010,2011 by Thomas E. Dickey
d506 71
d838 1
@


1.14
log
@Update to xterm 276. Tested by ajacoutot@@, krw@@, naddy@@, shadchin@@.
@
text
@d1 1
a1 1
/* $XTermId: trace.c,v 1.132 2011/10/07 09:40:46 tom Exp $ */
d110 1
a110 1
	    fprintf(stderr, "Cannot open \"%s\"\n", name);
@


1.13
log
@Update to xterm-275. Tested by jasper@@.
@
text
@d1 1
a1 1
/* $XTermId: trace.c,v 1.131 2011/09/11 14:59:35 tom Exp $ */
d109 4
a113 2
    if (!trace_fp)
	abort();
@


1.12
log
@Update to xterm 273. Tested by marco@@, jasper@@.
@
text
@d1 1
a1 1
/* $XTermId: trace.c,v 1.129 2011/08/22 09:56:16 tom Exp $ */
d5 1
a5 1
 * 
d7 1
a7 1
 * 
a30 1
 * 
d148 11
@


1.11
log
@Update to xterm 271. Tested by shadchin@@ and ajacoutot@@
@
text
@d1 1
a1 1
/* $XTermId: trace.c,v 1.125 2011/07/12 09:31:05 tom Exp $ */
d558 77
d683 1
a683 1
int
d690 1
a690 1
    int rc;
d693 4
a696 1
    rc = XtMakeResizeRequest((Widget) w, reqwide, reqhigh, gotwide, gothigh);
@


1.10
log
@Update to xterm 270. Tested by ajacoutot@@, shadchin@@, krw@@ and jasper@@
@
text
@d1 1
a1 1
/* $XTermId: trace.c,v 1.122 2011/04/17 19:21:11 tom Exp $ */
d516 1
d608 2
a609 2
		   Dimension reqwide,
		   Dimension reqhigh,
d615 1
a615 1
    TRACE(("%s@@%d ResizeRequest %dx%d\n", fn, ln, reqhigh, reqwide));
d639 2
d645 3
d649 1
d651 3
@


1.9
log
@Update to xterm version 269.
Tested and ok ajacoutot@@, jasper@@, krw@@, shadchin@@
@
text
@d1 1
a1 1
/* $XTermId: trace.c,v 1.121 2011/02/17 00:34:47 tom Exp $ */
d642 4
@


1.8
log
@Update to xterm 261. Tested by krw@@, jcs@@.
@
text
@d1 1
a1 1
/* $XTermId: trace.c,v 1.115 2010/06/15 22:40:28 tom Exp $ */
d4 1
a4 2
 * 
 * Copyright 1997-2009,2010 by Thomas E. Dickey
d39 3
d305 1
a305 1
#define CASETYPE(name) case name: result = #name; break;
d571 1
a632 1
    XRES_S(xterm_name);
d673 7
d698 1
a698 1
    if (!strncmp(src, "-/+", 3)) {
d845 7
@


1.7
log
@Update to xterm 258. lightly tested by krw@@, thanks.
@
text
@d1 1
a1 1
/* $XTermId: trace.c,v 1.112 2010/04/15 21:45:37 tom Exp $ */
d71 2
a75 1
    static FILE *fp;
d79 1
a79 1
    if (fp != 0
d81 2
a82 2
	fclose(fp);
	fp = 0;
d86 1
a86 1
    if (!fp) {
d95 1
a95 1
	    if ((fp = fopen(name, "r")) == 0) {
d98 1
a98 1
	    fclose(fp);
d103 3
a105 3
	fp = fopen(name, "w");
	if (fp != 0) {
	    fprintf(fp, "%s\n", xtermVersion());
d109 1
a109 1
    if (!fp)
d113 10
a122 5
    if (fmt != 0) {
	vfprintf(fp, fmt, ap);
	(void) fflush(fp);
    } else {
	(void) fclose(fp);
d128 1
a129 1
    va_end(ap);
d202 1
a202 1
visibleChars(Char * buf, unsigned len)
d215 8
a222 6
	dst = result;
	*dst = '\0';
	while (len--) {
	    unsigned value = *buf++;
	    formatAscii(dst, value);
	    dst += strlen(dst);
d246 5
a250 4
	dst = result;
	*dst = '\0';
	while (len--) {
	    unsigned value = *buf++;
d252 3
a254 3
	    if (value > 255)
		sprintf(dst, "\\u+%04X", value);
	    else
d256 3
a258 2
		formatAscii(dst, value);
	    dst += strlen(dst);
d282 4
a285 3
	dst = result;
	while (len--) {
	    unsigned value = *buf++;
d287 3
a289 3
	    if (value > 255)
		sprintf(dst, "\\u+%04X", value);
	    else
d291 3
a293 2
		formatAscii(dst, value);
	    dst += strlen(dst);
@


1.6
log
@Update to xterm-255. Tested by stsp@@, oga@@.
@
text
@d1 1
a1 1
/* $XTermId: trace.c,v 1.110 2009/12/10 09:36:28 tom Exp $ */
d5 1
a5 1
 * Copyright 1997-2008,2009 by Thomas E. Dickey
d571 1
a571 1
    TRACE(("TraceTranslations for %s (widget %#lx)\n", name, (long) w));
d586 1
@


1.5
log
@Update to xterm 250
@
text
@d1 1
a1 1
/* $XTermId: trace.c,v 1.104 2009/10/12 00:08:00 tom Exp $ */
d3 31
a33 24
/************************************************************

Copyright 1997-2008,2009 by Thomas E. Dickey

                        All Rights Reserved

Permission to use, copy, modify, and distribute this software and its
documentation for any purpose and without fee is hereby granted,
provided that the above copyright notice appear in all copies and that
both that copyright notice and this permission notice appear in
supporting documentation, and that the name of the above listed
copyright holder(s) not be used in advertising or publicity pertaining
to distribution of the software without specific, written prior
permission.

THE ABOVE LISTED COPYRIGHT HOLDER(S) DISCLAIM ALL WARRANTIES WITH REGARD
TO THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS, IN NO EVENT SHALL THE ABOVE LISTED COPYRIGHT HOLDER(S) BE
LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

********************************************************/
d352 17
d481 33
d580 1
a580 1
	TRACE(("%s\n", result != 0 ? result : "(null)"));
d582 1
a582 1
	    XFree(result);
d672 1
a672 1
parse_option(char *dst, char *src, int first)
d701 1
a701 1
standard_option(char *opt)
@


1.4
log
@update to xterm 246. Has been in snapshots for some time.
@
text
@d1 1
a1 1
/* $XTermId: trace.c,v 1.102 2009/07/03 13:57:08 tom Exp $ */
d62 1
a62 1
char *trace_who = "parent";
d68 1
a68 1
    static char *trace_out;
d258 1
a258 1
	unsigned limit = ((len + 1) * 6) + 1;
@


1.3
log
@Update to xterm 243. tested by naddy@@.

Patch #243 - 2009/3/28

* revert change to default for allowTcapOps (request by Bram Moolenaar).
* reallocate result returned by xtermEnvLocale() to avoid reference to
freed memory after handling menuLocale resource.
* fix an old (X11R5) bug in tek4014 for switching fontsizes.
* add resource defaultString to make configurable the use of "#" when
pastes of UTF-8 text fail due to limitations in the current locale settings.
* make the set of selection target Atom's configurable by two new
resources eightBitSelectTypes and utf8SelectTypes, e.g., to use the TEXT
Atom in preference to UTF8_STRING (discussion with Stanislav Sedov
regarding koi8rxterm and the FreeBSD port).
* modify handling of TARGETS Atom by making it return exactly the set of
targets as those which xterm is currently providing.
* set MANPAGER and PAGER explicitly to /bin/cat in minstall.sh to work
around /etc/man.conf's with those variables already set (report by
Mar'yasin Semion).
* improve error-checking of tcap-query parser.
* add check for keyboard tcap), which ensures that terminal descriptions
containing the same string for shifted/unshifted keys will be seen by
tcap-query as only the unshifted key. (This would only happen with an
incorrect terminal description).
* fix conversion for input event-state to modifier-parameter which made
tcap-query feature not work with tcapFunctionKeys (keyboard type tcap).
* add "DEF_ALLOW_XXX" definitions to main.h to allow overriding the
default compiled-in values for "allowxxx" resources.
* remove check on bell-percentage added in patch #242, which disallowed
zero/negative values (Redhat Bugzilla #487829).
@
text
@d1 1
a1 1
/* $XTermId: trace.c,v 1.87 2009/03/23 20:08:03 tom Exp $ */
d112 3
d167 1
a167 1
visibleChrsetName(int chrset)
d189 1
a189 1
visibleChars(PAIRED_CHARS(Char * buf, Char * buf2), unsigned len)
a192 2
    unsigned limit = ((len + 1) * 8) + 1;
    char *dst;
d194 41
a234 8
    if (limit > used) {
	used = limit;
	result = XtRealloc(result, used);
    }
    dst = result;
    *dst = '\0';
    while (len--) {
	unsigned value = *buf++;
d236 6
a241 3
	if (buf2 != 0) {
	    value |= (*buf2 << 8);
	    buf2++;
d243 4
a246 6
	if (value > 255)
	    sprintf(dst, "\\u+%04X", value);
	else
#endif
	    formatAscii(dst, value);
	dst += strlen(dst);
a255 2
    unsigned limit = ((len + 1) * 6) + 1;
    char *dst;
d257 11
a267 7
    if (limit > used) {
	used = limit;
	result = XtRealloc(result, used);
    }
    dst = result;
    while (len--) {
	unsigned value = *buf++;
d269 3
a271 3
	if (value > 255)
	    sprintf(dst, "\\u+%04X", value);
	else
d273 7
a279 2
	    formatAscii(dst, value);
	dst += strlen(dst);
d400 1
a400 1
ScrnText(TScreen * screen, int row)
d402 2
a403 23
    Char *chars = SCRN_BUF_CHARS(screen, row);
#if OPT_WIDE_CHARS
    Char *widec = 0;
#endif

    if_OPT_WIDE_CHARS(screen, {
	widec = SCRN_BUF_WIDEC(screen, row);
    });
    return visibleChars(PAIRED_CHARS(chars, widec), screen->max_col + 1);
}

#if OPT_TRACE_FLAGS > 1
#define DETAILED_FLAGS(name) \
    Trace("TEST " #name " %d [%d..%d] top %d chars %p (%d)\n", \
    	  row, \
	  -screen->savedlines, \
	  screen->max_row, \
	  screen->topline, \
	  SCRN_BUF_CHARS(screen, row), \
	  (&(SCRN_BUF_FLAGS(screen, row)) - screen->visbuf) / MAX_PTRS)
#else
#define DETAILED_FLAGS(name)	/* nothing */
#endif
d405 2
a406 3
#define SHOW_BAD_ROW(name, screen, row) \
	Trace("OOPS " #name " bad row %d [%d..%d]\n", \
	      row, -(screen->savedlines), screen->max_row)
d409 1
a409 3
	Trace(#name " {%d, top=%d, saved=%d}%05d%s:%s\n", \
	      row, screen->topline, screen->savedlines, \
	      ROW2ABS(screen, row), \
d411 1
a411 1
	      ScrnText(screen, row))
d414 1
a414 1
ScrnClrFlag(TScreen * screen, int row, int flag)
d416 2
a417 3
    DETAILED_FLAGS(ScrnClrFlag);
    if (!okScrnRow(screen, row)) {
	SHOW_BAD_ROW(ScrnClrFlag, screen, row);
d420 1
a420 1
	SHOW_SCRN_FLAG(ScrnClrFlag, 0);
d423 1
a423 2
    SCRN_BUF_FLAGS(screen, row) =
	(Char *) ((long) SCRN_BUF_FLAGS(screen, row) & ~(flag));
d427 1
a427 1
ScrnSetFlag(TScreen * screen, int row, int flag)
d429 2
a430 3
    DETAILED_FLAGS(ScrnSetFlag);
    if (!okScrnRow(screen, row)) {
	SHOW_BAD_ROW(ScrnSetFlag, screen, row);
d433 1
a433 1
	SHOW_SCRN_FLAG(ScrnSetFlag, 1);
d436 1
a436 2
    SCRN_BUF_FLAGS(screen, row) =
	(Char *) (((long) SCRN_BUF_FLAGS(screen, row) | (flag)));
d440 1
a440 1
ScrnTstFlag(TScreen * screen, int row, int flag)
d443 2
a444 2
    if (!okScrnRow(screen, row)) {
	SHOW_BAD_ROW(ScrnTstFlag, screen, row);
d446 1
a446 1
	code = ((long) SCRN_BUF_FLAGS(screen, row) & (flag)) != 0;
d448 2
a449 6
	DETAILED_FLAGS(ScrnTstFlag);
	if (!okScrnRow(screen, row)) {
	    SHOW_BAD_ROW(ScrnSetFlag, screen, row);
	    assert(0);
	} else if (isScrnFlag(flag)) {
	    SHOW_SCRN_FLAG(ScrnTstFlag, code);
d620 1
a620 1
	dst[0] = first;
@


1.2
log
@xterm-236. Tested by form@@ and simon@@.
@
text
@d1 1
a1 1
/* $XTermId: trace.c,v 1.85 2008/06/03 20:52:34 tom Exp $ */
d5 1
a5 1
Copyright 1997-2007,2008 by Thomas E. Dickey
d44 3
d299 20
@


1.1
log
@Initial revision
@
text
@d1 1
a1 5
/* $XTermId: trace.c,v 1.67 2006/07/15 12:00:58 tom Exp $ */

/*
 * $XFree86: xc/programs/xterm/trace.c,v 3.23 2005/09/18 23:48:13 dickey Exp $
 */
d5 1
a5 1
Copyright 1997-2005,2006 by Thomas E. Dickey
d42 1
d62 1
a62 1
Trace(char *fmt,...)
d116 1
a116 1
    Trace("process %d ", getpid());
d130 52
d207 1
a207 4
	if (E2A(value) < 32 || (E2A(value) >= 127 && E2A(value) < 160))
	    sprintf(dst, "\\%03o", value);
	else
	    sprintf(dst, "%c", CharOf(value));
d233 1
a233 4
	if (E2A(value) < 32 || (E2A(value) >= 127 && E2A(value) < 160))
	    sprintf(dst, "\\%03o", value);
	else
	    sprintf(dst, "%c", CharOf(value));
d251 1
d257 166
d441 2
d456 1
a456 2
    XSizeHints sizehints;
    long supp = 0;
d458 3
a460 5
    bzero(&sizehints, sizeof(sizehints));
    if (!XGetWMNormalHints(xw->screen.display, XtWindow(SHELL_OF(xw)),
			   &sizehints, &supp))
	bzero(&sizehints, sizeof(sizehints));
    TraceSizeHints(&sizehints);
d499 18
a552 1
    XRES_B(wait_for_map);
d558 1
d560 1
d723 5
@


1.1.1.1
log
@Importing xterm 216
@
text
@@


1.1.1.2
log
@import xterm 225
@
text
@d1 1
a1 1
/* $XTermId: trace.c,v 1.72 2007/03/17 15:45:12 tom Exp $ */
d9 1
a9 1
Copyright 1997-2006,2007 by Thomas E. Dickey
d119 1
a119 1
    Trace("process %d ", (int) getpid());
a207 1
	CASETYPE(keyboardIsTermcap);
a212 74
const char *
visibleEventType(int type)
{
    const char *result = "?";
    switch (type) {
	CASETYPE(KeyPress);
	CASETYPE(KeyRelease);
	CASETYPE(ButtonPress);
	CASETYPE(ButtonRelease);
	CASETYPE(MotionNotify);
	CASETYPE(EnterNotify);
	CASETYPE(LeaveNotify);
	CASETYPE(FocusIn);
	CASETYPE(FocusOut);
	CASETYPE(KeymapNotify);
	CASETYPE(Expose);
	CASETYPE(GraphicsExpose);
	CASETYPE(NoExpose);
	CASETYPE(VisibilityNotify);
	CASETYPE(CreateNotify);
	CASETYPE(DestroyNotify);
	CASETYPE(UnmapNotify);
	CASETYPE(MapNotify);
	CASETYPE(MapRequest);
	CASETYPE(ReparentNotify);
	CASETYPE(ConfigureNotify);
	CASETYPE(ConfigureRequest);
	CASETYPE(GravityNotify);
	CASETYPE(ResizeRequest);
	CASETYPE(CirculateNotify);
	CASETYPE(CirculateRequest);
	CASETYPE(PropertyNotify);
	CASETYPE(SelectionClear);
	CASETYPE(SelectionRequest);
	CASETYPE(SelectionNotify);
	CASETYPE(ColormapNotify);
	CASETYPE(ClientMessage);
	CASETYPE(MappingNotify);
    }
    return result;
}

const char *
visibleXError(int code)
{
    static char temp[80];
    const char *result = "?";
    switch (code) {
	CASETYPE(Success);
	CASETYPE(BadRequest);
	CASETYPE(BadValue);
	CASETYPE(BadWindow);
	CASETYPE(BadPixmap);
	CASETYPE(BadAtom);
	CASETYPE(BadCursor);
	CASETYPE(BadFont);
	CASETYPE(BadMatch);
	CASETYPE(BadDrawable);
	CASETYPE(BadAccess);
	CASETYPE(BadAlloc);
	CASETYPE(BadColor);
	CASETYPE(BadGC);
	CASETYPE(BadIDChoice);
	CASETYPE(BadName);
	CASETYPE(BadLength);
	CASETYPE(BadImplementation);
    default:
	sprintf(temp, "%d", code);
	result = temp;
	break;
    }
    return result;
}

d244 2
a245 1
    XSizeHints sizehints = xw->hints;
d247 5
a251 3
    getXtermSizeHints(xw);
    TraceSizeHints(&xw->hints);
    xw->hints = sizehints;
@


1.1.1.3
log
@import xterm 229
@
text
@d1 1
a1 1
/* $XTermId: trace.c,v 1.81 2007/07/22 16:27:25 tom Exp $ */
a45 1
#include <assert.h>
a132 28
static void
formatAscii(char *dst, unsigned value)
{
    switch (value) {
    case '\\':
	sprintf(dst, "\\\\");
	break;
    case '\b':
	sprintf(dst, "\\b");
	break;
    case '\n':
	sprintf(dst, "\\n");
	break;
    case '\r':
	sprintf(dst, "\\r");
	break;
    case '\t':
	sprintf(dst, "\\t");
	break;
    default:
	if (E2A(value) < 32 || (E2A(value) >= 127 && E2A(value) < 160))
	    sprintf(dst, "\\%03o", value);
	else
	    sprintf(dst, "%c", CharOf(value));
	break;
    }
}

d158 4
a161 1
	    formatAscii(dst, value);
d187 4
a190 1
	    formatAscii(dst, value);
a287 92
#if OPT_TRACE_FLAGS
#define isScrnFlag(flag) ((flag) == LINEWRAPPED)

static char *
ScrnText(TScreen * screen, int row)
{
    Char *chars = SCRN_BUF_CHARS(screen, row);
#if OPT_WIDE_CHARS
    Char *widec = 0;
#endif

    if_OPT_WIDE_CHARS(screen, {
	widec = SCRN_BUF_WIDEC(screen, row);
    });
    return visibleChars(PAIRED_CHARS(chars, widec), screen->max_col + 1);
}

#if OPT_TRACE_FLAGS > 1
#define DETAILED_FLAGS(name) \
    Trace("TEST " #name " %d [%d..%d] top %d chars %p (%d)\n", \
    	  row, \
	  -screen->savedlines, \
	  screen->max_row, \
	  screen->topline, \
	  SCRN_BUF_CHARS(screen, row), \
	  (&(SCRN_BUF_FLAGS(screen, row)) - screen->visbuf) / MAX_PTRS)
#else
#define DETAILED_FLAGS(name)	/* nothing */
#endif

#define SHOW_BAD_ROW(name, screen, row) \
	Trace("OOPS " #name " bad row %d [%d..%d]\n", \
	      row, -(screen->savedlines), screen->max_row)

#define SHOW_SCRN_FLAG(name,code) \
	Trace(#name " {%d, top=%d, saved=%d}%05d%s:%s\n", \
	      row, screen->topline, screen->savedlines, \
	      ROW2ABS(screen, row), \
	      code ? "*" : "", \
	      ScrnText(screen, row))

void
ScrnClrFlag(TScreen * screen, int row, int flag)
{
    DETAILED_FLAGS(ScrnClrFlag);
    if (!okScrnRow(screen, row)) {
	SHOW_BAD_ROW(ScrnClrFlag, screen, row);
	assert(0);
    } else if (isScrnFlag(flag)) {
	SHOW_SCRN_FLAG(ScrnClrFlag, 0);
    }

    SCRN_BUF_FLAGS(screen, row) =
	(Char *) ((long) SCRN_BUF_FLAGS(screen, row) & ~(flag));
}

void
ScrnSetFlag(TScreen * screen, int row, int flag)
{
    DETAILED_FLAGS(ScrnSetFlag);
    if (!okScrnRow(screen, row)) {
	SHOW_BAD_ROW(ScrnSetFlag, screen, row);
	assert(0);
    } else if (isScrnFlag(flag)) {
	SHOW_SCRN_FLAG(ScrnSetFlag, 1);
    }

    SCRN_BUF_FLAGS(screen, row) =
	(Char *) (((long) SCRN_BUF_FLAGS(screen, row) | (flag)));
}

int
ScrnTstFlag(TScreen * screen, int row, int flag)
{
    int code = 0;
    if (!okScrnRow(screen, row)) {
	SHOW_BAD_ROW(ScrnTstFlag, screen, row);
    } else {
	code = ((long) SCRN_BUF_FLAGS(screen, row) & (flag)) != 0;

	DETAILED_FLAGS(ScrnTstFlag);
	if (!okScrnRow(screen, row)) {
	    SHOW_BAD_ROW(ScrnSetFlag, screen, row);
	    assert(0);
	} else if (isScrnFlag(flag)) {
	    SHOW_SCRN_FLAG(ScrnTstFlag, code);
	}
    }
    return code;
}
#endif /* OPT_TRACE_FLAGS */

d398 1
a403 1
    XRES_B(wait_for_map);
a404 1
    XRES_B(ptySttySize);
a566 5
	case XrmoptionIsArg:
	case XrmoptionNoArg:
	case XrmoptionResArg:
	case XrmoptionSepArg:
	case XrmoptionStickyArg:
@


1.1.1.4
log
@Import xterm version 232. tested by many.
@
text
@d1 5
a5 1
/* $XTermId: trace.c,v 1.83 2007/12/31 20:58:29 tom Exp $ */
d66 1
a66 1
Trace(const char *fmt,...)
a160 24

#if OPT_DEC_CHRSET

const char *
visibleChrsetName(int chrset)
{
    const char *result = "?";
    switch (chrset) {
    case CSET_SWL:
	result = "CSET_SWL";
	break;
    case CSET_DHL_TOP:
	result = "CSET_DHL_TOP";
	break;
    case CSET_DHL_BOT:
	result = "CSET_DHL_BOT";
	break;
    case CSET_DWL:
	result = "CSET_DWL";
	break;
    }
    return result;
}
#endif
@


