head	1.18;
access;
symbols
	OPENBSD_6_1_BASE:1.18
	OPENBSD_6_0:1.17.0.10
	OPENBSD_6_0_BASE:1.17
	OPENBSD_5_9:1.17.0.8
	OPENBSD_5_9_BASE:1.17
	OPENBSD_5_8:1.17.0.6
	OPENBSD_5_8_BASE:1.17
	OPENBSD_5_7:1.17.0.4
	OPENBSD_5_7_BASE:1.17
	OPENBSD_5_6:1.17.0.2
	OPENBSD_5_6_BASE:1.17
	OPENBSD_5_5:1.16.0.4
	OPENBSD_5_5_BASE:1.16
	OPENBSD_5_4:1.16.0.2
	OPENBSD_5_4_BASE:1.16
	OPENBSD_5_3:1.14.0.2
	OPENBSD_5_3_BASE:1.14
	OPENBSD_5_2:1.13.0.4
	OPENBSD_5_2_BASE:1.13
	OPENBSD_5_1_BASE:1.13
	OPENBSD_5_1:1.13.0.2
	OPENBSD_5_0:1.11.0.2
	OPENBSD_5_0_BASE:1.11
	OPENBSD_4_9:1.9.0.2
	OPENBSD_4_9_BASE:1.9
	OPENBSD_4_8:1.8.0.4
	OPENBSD_4_8_BASE:1.8
	OPENBSD_4_7:1.6.0.2
	OPENBSD_4_7_BASE:1.6
	OPENBSD_4_6:1.2.0.4
	OPENBSD_4_6_BASE:1.2
	OPENBSD_4_5:1.2.0.2
	OPENBSD_4_5_BASE:1.2
	OPENBSD_4_4:1.1.1.2.0.6
	OPENBSD_4_4_BASE:1.1.1.2
	OPENBSD_4_3_BASE:1.1.1.2
	OPENBSD_4_3:1.1.1.2.0.4
	v232:1.1.1.2
	v229:1.1.1.2
	OPENBSD_4_2:1.1.1.2.0.2
	OPENBSD_4_2_BASE:1.1.1.2
	v225:1.1.1.2
	v216:1.1.1.1
	xterm:1.1.1;
locks; strict;
comment	@ * @;


1.18
date	2016.08.07.21.27.36;	author matthieu;	state Exp;
branches;
next	1.17;
commitid	psxxjI5z4Vpv2LL4;

1.17
date	2014.07.14.08.30.11;	author matthieu;	state Exp;
branches;
next	1.16;
commitid	EnwNNUjlkdrocnMa;

1.16
date	2013.06.02.19.55.50;	author matthieu;	state Exp;
branches;
next	1.15;

1.15
date	2013.03.09.14.45.38;	author matthieu;	state Exp;
branches;
next	1.14;

1.14
date	2013.01.04.16.40.18;	author matthieu;	state Exp;
branches;
next	1.13;

1.13
date	2011.09.17.11.51.57;	author matthieu;	state Exp;
branches;
next	1.12;

1.12
date	2011.08.18.19.47.42;	author matthieu;	state Exp;
branches;
next	1.11;

1.11
date	2011.06.07.19.21.06;	author matthieu;	state Exp;
branches;
next	1.10;

1.10
date	2011.03.07.20.41.27;	author matthieu;	state Exp;
branches;
next	1.9;

1.9
date	2010.08.22.13.38.11;	author matthieu;	state Exp;
branches;
next	1.8;

1.8
date	2010.05.08.12.20.46;	author matthieu;	state Exp;
branches;
next	1.7;

1.7
date	2010.03.25.22.03.51;	author matthieu;	state Exp;
branches;
next	1.6;

1.6
date	2009.10.31.14.11.57;	author matthieu;	state Exp;
branches;
next	1.5;

1.5
date	2009.09.19.00.03.36;	author sthen;	state Exp;
branches;
next	1.4;

1.4
date	2009.09.05.16.06.57;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2009.09.05.15.58.09;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2009.01.10.18.08.42;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.26.11.11.40;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.11.26.11.11.40;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2007.06.15.19.30.31;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.18
log
@Update to xterm-325. Testing by krw@@, shadchin@@ and naddy@@. Thanks
@
text
@/* $XTermId: print.c,v 1.155 2016/05/22 16:31:59 tom Exp $ */

/*
 * Copyright 1997-2014,2016 by Thomas E. Dickey
 *
 *                         All Rights Reserved
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 *
 * The above copyright notice and this permission notice shall be included
 * in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
 * IN NO EVENT SHALL THE ABOVE LISTED COPYRIGHT HOLDER(S) BE LIABLE FOR ANY
 * CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
 * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
 * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 *
 * Except as contained in this notice, the name(s) of the above copyright
 * holders shall not be used in advertising or otherwise to promote the
 * sale, use or other dealings in this Software without prior written
 * authorization.
 */

#include <xterm.h>
#include <data.h>
#include <menu.h>
#include <error.h>
#include <xstrings.h>

#include <stdio.h>
#include <sys/stat.h>

#undef  CTRL
#define	CTRL(c)	((c) & 0x1f)

#define SHIFT_IN  '\017'
#define SHIFT_OUT '\016'

#define CSET_IN   'A'
#define CSET_OUT  '0'

#define isForm(c)      ((c) == '\r' || (c) == '\n' || (c) == '\f')
#define Strlen(a)      strlen((const char *)a)
#define Strcmp(a,b)    strcmp((const char *)a,(const char *)b)
#define Strncmp(a,b,c) strncmp((const char *)a,(const char *)b,c)

#define SPS PrinterOf(screen)

#ifdef VMS
#define VMS_TEMP_PRINT_FILE "sys$scratch:xterm_print.txt"
#endif

static void charToPrinter(XtermWidget /* xw */ ,
			  unsigned /* chr */ );
static void printLine(XtermWidget /* xw */ ,
		      int /* row */ ,
		      unsigned /* chr */ ,
		      PrinterFlags * /* p */ );
static void send_CharSet(XtermWidget /* xw */ ,
			 LineData * /* ld */ );
static void send_SGR(XtermWidget /* xw */ ,
		     unsigned /* attr */ ,
		     unsigned /* fg */ ,
		     unsigned /* bg */ );
static void stringToPrinter(XtermWidget /* xw */ ,
			    const char * /*str */ );

static void
closePrinter(XtermWidget xw GCC_UNUSED)
{
    if (xtermHasPrinter(xw) != 0) {
	TScreen *screen = TScreenOf(xw);
#ifdef VMS
	char pcommand[256];
	(void) sprintf(pcommand, "%s %s;",
		       SPS.printer_command,
		       VMS_TEMP_PRINT_FILE);
#endif

	if (SPS.fp != 0) {
	    DEBUG_MSG("closePrinter\n");
	    pclose(SPS.fp);
	    TRACE(("closed printer, waiting...\n"));
#ifdef VMS			/* This is a quick hack, really should use
				   spawn and check status or system services
				   and go straight to the queue */
	    (void) system(pcommand);
#else /* VMS */
	    while (nonblocking_wait() > 0) {
		;
	    }
#endif /* VMS */
	    SPS.fp = 0;
	    SPS.isOpen = False;
	    TRACE(("closed printer\n"));
	    DEBUG_MSG("...closePrinter (done)\n");
	}
    }
}

static void
printCursorLine(XtermWidget xw)
{
    TScreen *screen = TScreenOf(xw);

    TRACE(("printCursorLine\n"));
    printLine(xw, screen->cur_row, '\n', getPrinterFlags(xw, NULL, 0));
}

#define NO_COLOR	((unsigned)-1)

/*
 * DEC's manual doesn't document whether trailing blanks are removed, or what
 * happens with a line that is entirely blank.  This function prints the
 * characters that xterm would allow as a selection (which may include blanks).
 */
static void
printLine(XtermWidget xw, int row, unsigned chr, PrinterFlags *p)
{
    TScreen *screen = TScreenOf(xw);
    int inx = ROW2INX(screen, row);
    LineData *ld;
    int last = MaxCols(screen);
#if OPT_ISO_COLORS && OPT_PRINT_COLORS
#define ColorOf(ld,col) (ld->color[col])
#endif
    unsigned fg = NO_COLOR, last_fg = NO_COLOR;
    unsigned bg = NO_COLOR, last_bg = NO_COLOR;

    ld = getLineData(screen, inx);
    if (ld == 0)
	return;

    TRACE(("printLine(row=%d/%d, top=%d:%d, chr=%d):%s\n",
	   row, ROW2INX(screen, row), screen->topline, screen->max_row, chr,
	   visibleIChars(ld->charData, (unsigned) last)));

    while (last > 0) {
	if ((ld->attribs[last - 1] & CHARDRAWN) == 0)
	    last--;
	else
	    break;
    }

    if (last) {
	int col;
	int cs = CSET_IN;
	int last_cs = CSET_IN;

	if (p->print_attributes) {
	    send_CharSet(xw, ld);
	    send_SGR(xw, 0, NO_COLOR, NO_COLOR);
	}
	for (col = 0; col < last; col++) {
	    IAttr attr = 0;
	    unsigned ch = ld->charData[col];
#if OPT_PRINT_COLORS
	    if (screen->colorMode) {
		if (p->print_attributes > 1) {
		    fg = (ld->attribs[col] & FG_COLOR)
			? extract_fg(xw, ColorOf(ld, col), ld->attribs[col])
			: NO_COLOR;
		    bg = (ld->attribs[col] & BG_COLOR)
			? extract_bg(xw, ColorOf(ld, col), ld->attribs[col])
			: NO_COLOR;
		}
	    }
#endif
	    if ((((ld->attribs[col] & SGR_MASK) != attr)
#if OPT_PRINT_COLORS
		 || (last_fg != fg) || (last_bg != bg)
#endif
		)
		&& ch) {
		attr = ld->attribs[col] & SGR_MASK;
#if OPT_PRINT_COLORS
		last_fg = fg;
		last_bg = bg;
#endif
		if (p->print_attributes)
		    send_SGR(xw, attr, fg, bg);
	    }

	    if (ch == 0)
		ch = ' ';

#if OPT_WIDE_CHARS
	    if (screen->utf8_mode)
		cs = CSET_IN;
	    else
#endif
		cs = (ch >= ' ' && ch != ANSI_DEL) ? CSET_IN : CSET_OUT;
	    if (last_cs != cs) {
		if (p->print_attributes) {
		    charToPrinter(xw,
				  (unsigned) ((cs == CSET_OUT)
					      ? SHIFT_OUT
					      : SHIFT_IN));
		}
		last_cs = cs;
	    }

	    /* FIXME:  we shouldn't have to map back from the
	     * alternate character set, except that the
	     * corresponding charset information is not encoded
	     * into the CSETS array.
	     */
	    charToPrinter(xw,
			  ((cs == CSET_OUT)
			   ? (ch == ANSI_DEL ? 0x5f : (ch + 0x5f))
			   : ch));
	    if_OPT_WIDE_CHARS(screen, {
		size_t off;
		for_each_combData(off, ld) {
		    ch = ld->combData[off][col];
		    if (ch == 0)
			break;
		    charToPrinter(xw, ch);
		}
	    });
	}
	if (p->print_attributes) {
	    send_SGR(xw, 0, NO_COLOR, NO_COLOR);
	    if (cs != CSET_IN)
		charToPrinter(xw, SHIFT_IN);
	}
    }

    /* finish line (protocol for attributes needs a CR */
    if (p->print_attributes)
	charToPrinter(xw, '\r');

    if (chr && !(p->printer_newline)) {
	if (LineTstWrapped(ld))
	    chr = '\0';
    }

    if (chr)
	charToPrinter(xw, chr);

    return;
}

#define PrintNewLine() (unsigned) (((top < bot) || p->printer_newline) ? '\n' : '\0')

static void
printLines(XtermWidget xw, int top, int bot, PrinterFlags *p)
{
    TRACE(("printLines, rows %d..%d\n", top, bot));
    while (top <= bot) {
	printLine(xw, top, PrintNewLine(), p);
	++top;
    }
}

void
xtermPrintScreen(XtermWidget xw, Bool use_DECPEX, PrinterFlags *p)
{
    if (XtIsRealized((Widget) xw)) {
	TScreen *screen = TScreenOf(xw);
	Bool extent = (use_DECPEX && p->printer_extent);
	Boolean was_open = SPS.isOpen;

	printLines(xw,
		   extent ? 0 : screen->top_marg,
		   extent ? screen->max_row : screen->bot_marg,
		   p);
	if (p->printer_formfeed)
	    charToPrinter(xw, '\f');

	if (!was_open || SPS.printer_autoclose) {
	    closePrinter(xw);
	}
    } else {
	Bell(xw, XkbBI_MinorError, 0);
    }
}

/*
 * If p->print_everything is zero, use this behavior:
 * If the alternate screen is active, we'll print only that.  Otherwise, print
 * the normal screen plus all scrolled-back lines.  The distinction is made
 * because the normal screen's buffer is part of the overall scrollback buffer.
 *
 * Otherwise, decode bits:
 *	1 = current screen
 *	2 = normal screen
 *	4 = alternate screen
 *	8 = saved lines
 */
void
xtermPrintEverything(XtermWidget xw, PrinterFlags *p)
{
    TScreen *screen = TScreenOf(xw);
    Boolean was_open = SPS.isOpen;
    int save_which = screen->whichBuf;

    DEBUG_MSG("xtermPrintEverything\n");

    if (p->print_everything) {
	int done_which = 0;

	if (p->print_everything & 8) {
	    printLines(xw, -screen->savedlines, -(screen->topline + 1), p);
	}
	if (p->print_everything & 4) {
	    screen->whichBuf = 1;
	    done_which |= 2;
	    printLines(xw, 0, screen->max_row, p);
	    screen->whichBuf = save_which;
	}
	if (p->print_everything & 2) {
	    screen->whichBuf = 0;
	    done_which |= 1;
	    printLines(xw, 0, screen->max_row, p);
	    screen->whichBuf = save_which;
	}
	if (p->print_everything & 1) {
	    if (!(done_which & (1 << screen->whichBuf))) {
		printLines(xw, 0, screen->max_row, p);
	    }
	}
    } else {
	int top = 0;
	int bot = screen->max_row;
	if (!screen->whichBuf) {
	    top = -screen->savedlines - screen->topline;
	    bot -= screen->topline;
	}
	printLines(xw, top, bot, p);
    }
    if (p->printer_formfeed)
	charToPrinter(xw, '\f');

    if (!was_open || SPS.printer_autoclose) {
	closePrinter(xw);
    }
}

static void
send_CharSet(XtermWidget xw, LineData *ld)
{
#if OPT_DEC_CHRSET
    const char *msg = 0;

    switch (GetLineDblCS(ld)) {
    case CSET_SWL:
	msg = "\033#5";
	break;
    case CSET_DHL_TOP:
	msg = "\033#3";
	break;
    case CSET_DHL_BOT:
	msg = "\033#4";
	break;
    case CSET_DWL:
	msg = "\033#6";
	break;
    }
    if (msg != 0)
	stringToPrinter(xw, msg);
#else
    (void) xw;
    (void) ld;
#endif /* OPT_DEC_CHRSET */
}

static void
send_SGR(XtermWidget xw, unsigned attr, unsigned fg, unsigned bg)
{
    char msg[80];

    strcpy(msg, "\033[0");
    if (attr & BOLD)
	strcat(msg, ";1");
#if OPT_WIDE_ATTRS
    if (attr & ATR_FAINT)
	strcat(msg, ";2");
    if (attr & ATR_ITALIC)
	strcat(msg, ";3");
#endif
    if (attr & UNDERLINE)
	strcat(msg, ";4");	/* typo? DEC documents this as '2' */
    if (attr & BLINK)
	strcat(msg, ";5");
    if (attr & INVERSE)		/* typo? DEC documents this as invisible */
	strcat(msg, ";7");
#if OPT_PRINT_COLORS
    if (bg != NO_COLOR) {
	sprintf(msg + strlen(msg), ";%u", (bg < 8) ? (40 + bg) : (92 + bg));
    }
    if (fg != NO_COLOR) {
#if OPT_PC_COLORS
	if (TScreenOf(xw)->boldColors
	    && fg > 8
	    && (attr & BOLD) != 0)
	    fg -= 8;
#endif
	sprintf(msg + strlen(msg), ";%u", (fg < 8) ? (30 + fg) : (82 + fg));
    }
#else
    (void) bg;
    (void) fg;
#endif
    strcat(msg, "m");
    stringToPrinter(xw, msg);
}

/*
 * This implementation only knows how to write to a pipe.
 */
static void
charToPrinter(XtermWidget xw, unsigned chr)
{
    TScreen *screen = TScreenOf(xw);

    if (!SPS.isOpen && xtermHasPrinter(xw)) {
	switch (SPS.toFile) {
	    /*
	     * write to a pipe.
	     */
	case False:
#ifdef VMS
	    /*
	     * This implementation only knows how to write to a file.  When the
	     * file is closed the print command executes.  Print command must
	     * be of the form:
	     *   print/que=name/delete [/otherflags].
	     */
	    SPS.fp = fopen(VMS_TEMP_PRINT_FILE, "w");
#else
	    {
		int my_pipe[2];
		pid_t my_pid;

		if (pipe(my_pipe))
		    SysError(ERROR_FORK);
		if ((my_pid = fork()) < 0)
		    SysError(ERROR_FORK);

		if (my_pid == 0) {
		    DEBUG_MSG("charToPrinter: subprocess for printer\n");
		    TRACE_CLOSE();
		    close(my_pipe[1]);	/* printer is silent */
		    close(screen->respond);

		    close(fileno(stdout));
		    dup2(fileno(stderr), 1);

		    if (fileno(stderr) != 2) {
			dup2(fileno(stderr), 2);
			close(fileno(stderr));
		    }

		    /* don't want privileges! */
		    if (xtermResetIds(screen) < 0)
			exit(1);

		    SPS.fp = popen(SPS.printer_command, "w");
		    if (SPS.fp != 0) {
			FILE *input;
			DEBUG_MSG("charToPrinter: opened pipe to printer\n");
			input = fdopen(my_pipe[0], "r");
			clearerr(input);

			for (;;) {
			    int c;

			    if (ferror(input)) {
				DEBUG_MSG("charToPrinter: break on ferror\n");
				break;
			    } else if (feof(input)) {
				DEBUG_MSG("charToPrinter: break on feof\n");
				break;
			    } else if ((c = fgetc(input)) == EOF) {
				DEBUG_MSG("charToPrinter: break on EOF\n");
				break;
			    }
			    fputc(c, SPS.fp);
			    if (isForm(c))
				fflush(SPS.fp);
			}

			DEBUG_MSG("charToPrinter: calling pclose\n");
			pclose(SPS.fp);
		    }
		    exit(0);
		} else {
		    close(my_pipe[0]);	/* won't read from printer */
		    if ((SPS.fp = fdopen(my_pipe[1], "w")) != 0) {
			DEBUG_MSG("charToPrinter: opened printer in parent\n");
			TRACE(("opened printer from pid %d/%d\n",
			       (int) getpid(), (int) my_pid));
		    } else {
			TRACE(("failed to open printer:%s\n", strerror(errno)));
			DEBUG_MSG("charToPrinter: could not open in parent\n");
		    }
		}
	    }
#endif
	    break;
	case True:
	    TRACE(("opening \"%s\" as printer output\n", SPS.printer_command));
	    SPS.fp = fopen(SPS.printer_command, "w");
	    break;
	}
	SPS.isOpen = True;
    }
    if (SPS.fp != 0) {
#if OPT_WIDE_CHARS
	if (chr > 127) {
	    Char temp[10];
	    *convertToUTF8(temp, chr) = 0;
	    fputs((char *) temp, SPS.fp);
	} else
#endif
	    fputc((int) chr, SPS.fp);
	if (isForm(chr))
	    fflush(SPS.fp);
    }
}

static void
stringToPrinter(XtermWidget xw, const char *str)
{
    while (*str)
	charToPrinter(xw, CharOf(*str++));
}

/*
 * This module implements the MC (Media Copy) and related printing control
 * sequences for VTxxx emulation.  This is based on the description in the
 * VT330/VT340 Programmer Reference Manual EK-VT3XX-TP-001 (Digital Equipment
 * Corp., March 1987).
 */
void
xtermMediaControl(XtermWidget xw, int param, int private_seq)
{
    TRACE(("MediaCopy param=%d, private=%d\n", param, private_seq));

    if (private_seq) {
	switch (param) {
	case 1:
	    printCursorLine(xw);
	    break;
	case 4:
	    setPrinterControlMode(xw, 0);
	    break;
	case 5:
	    setPrinterControlMode(xw, 1);
	    break;
	case 10:		/* VT320 */
	    xtermPrintScreen(xw, False, getPrinterFlags(xw, NULL, 0));
	    break;
	case 11:		/* VT320 */
	    xtermPrintEverything(xw, getPrinterFlags(xw, NULL, 0));
	    break;
	}
    } else {
	switch (param) {
	case -1:
	case 0:
	    xtermPrintScreen(xw, True, getPrinterFlags(xw, NULL, 0));
	    break;
	case 4:
	    setPrinterControlMode(xw, 0);
	    break;
	case 5:
	    setPrinterControlMode(xw, 2);
	    break;
#if OPT_SCREEN_DUMPS
	case 10:
	    xtermDumpHtml(xw);
	    break;
	case 11:
	    xtermDumpSvg(xw);
	    break;
#endif
	}
    }
}

/*
 * When in autoprint mode, the printer prints a line from the screen when you
 * move the cursor off that line with an LF, FF, or VT character, or an
 * autowrap occurs.  The printed line ends with a CR and the character (LF, FF
 * or VT) that moved the cursor off the previous line.
 */
void
xtermAutoPrint(XtermWidget xw, unsigned chr)
{
    TScreen *screen = TScreenOf(xw);

    if (SPS.printer_controlmode == 1) {
	TRACE(("AutoPrint %d\n", chr));
	printLine(xw, screen->cursorp.row, chr, getPrinterFlags(xw, NULL, 0));
	if (SPS.fp != 0)
	    fflush(SPS.fp);
    }
}

/*
 * When in printer controller mode, the terminal sends received characters to
 * the printer without displaying them on the screen. The terminal sends all
 * characters and control sequences to the printer, except NUL, XON, XOFF, and
 * the printer controller sequences.
 *
 * This function eats characters, returning 0 as long as it must buffer or
 * divert to the printer.  We're only invoked here when in printer controller
 * mode, and handle the exit from that mode.
 */
#define LB '['

int
xtermPrinterControl(XtermWidget xw, int chr)
{
    TScreen *screen = TScreenOf(xw);
    /* *INDENT-OFF* */
    static const struct {
	const Char seq[5];
	int active;
    } tbl[] = {
	{ { ANSI_CSI, '5', 'i'      }, 2 },
	{ { ANSI_CSI, '4', 'i'      }, 0 },
	{ { ANSI_ESC, LB,  '5', 'i' }, 2 },
	{ { ANSI_ESC, LB,  '4', 'i' }, 0 },
    };
    /* *INDENT-ON* */

    static Char bfr[10];
    static size_t length;
    size_t n;

    TRACE(("In printer:%04X\n", chr));

    switch (chr) {
    case 0:
    case CTRL('Q'):
    case CTRL('S'):
	return 0;		/* ignored by application */

    case ANSI_CSI:
    case ANSI_ESC:
    case '[':
    case '4':
    case '5':
    case 'i':
	bfr[length++] = CharOf(chr);
	for (n = 0; n < sizeof(tbl) / sizeof(tbl[0]); n++) {
	    size_t len = Strlen(tbl[n].seq);

	    if (length == len
		&& Strcmp(bfr, tbl[n].seq) == 0) {
		setPrinterControlMode(xw, tbl[n].active);
		if (SPS.printer_autoclose
		    && SPS.printer_controlmode == 0)
		    closePrinter(xw);
		length = 0;
		return 0;
	    } else if (len > length
		       && Strncmp(bfr, tbl[n].seq, length) == 0) {
		return 0;
	    }
	}
	length--;

	/* FALLTHRU */

    default:
	for (n = 0; n < length; n++)
	    charToPrinter(xw, bfr[n]);
	bfr[0] = CharOf(chr);
	length = 1;
	return 0;
    }
}

/*
 * If there is no printer command, we will ignore printer controls.
 *
 * If we do have a printer command, we still have to verify that it will
 * (perhaps) work if we pass it to popen().  At a minimum, the program
 * must exist and be executable.  If not, warn and disable the feature.
 */
Bool
xtermHasPrinter(XtermWidget xw)
{
    TScreen *screen = TScreenOf(xw);
    Bool result = SPS.printer_checked;

    if (strlen(SPS.printer_command) != 0 && !result) {
	char **argv = x_splitargs(SPS.printer_command);
	if (argv) {
	    if (argv[0]) {
		char *myShell = xtermFindShell(argv[0], False);
		if (myShell == 0) {
		    xtermWarning("No program found for printerCommand: %s\n", SPS.printer_command);
		    SPS.printer_command = x_strdup("");
		} else {
		    free(myShell);
		    SPS.printer_checked = True;
		    result = True;
		}
	    }
	    x_freeargs(argv);
	}
	TRACE(("xtermHasPrinter:%d\n", result));
    }

    return result;
}

#define showPrinterControlMode(mode) \
		(((mode) == 0) \
		 ? "normal" \
		 : ((mode) == 1 \
		    ? "autoprint" \
		    : "printer controller"))

void
setPrinterControlMode(XtermWidget xw, int mode)
{
    TScreen *screen = TScreenOf(xw);

    if (xtermHasPrinter(xw)
	&& SPS.printer_controlmode != mode) {
	TRACE(("%s %s mode\n",
	       (mode
		? "set"
		: "reset"),
	       (mode
		? showPrinterControlMode(mode)
		: showPrinterControlMode(SPS.printer_controlmode))));
	SPS.printer_controlmode = mode;
	update_print_redir();
    }
}

PrinterFlags *
getPrinterFlags(XtermWidget xw, String *params, Cardinal *param_count)
{
    /* *INDENT-OFF* */
    static const struct {
	const char *name;
	unsigned    offset;
	int	    value;
    } table[] = {
	{ "noFormFeed", XtOffsetOf(PrinterFlags, printer_formfeed), 0 },
	{ "FormFeed",	XtOffsetOf(PrinterFlags, printer_formfeed), 1 },
	{ "noNewLine",	XtOffsetOf(PrinterFlags, printer_newline),  0 },
	{ "NewLine",	XtOffsetOf(PrinterFlags, printer_newline),  1 },
	{ "noAttrs",	XtOffsetOf(PrinterFlags, print_attributes), 0 },
	{ "monoAttrs",	XtOffsetOf(PrinterFlags, print_attributes), 1 },
	{ "colorAttrs", XtOffsetOf(PrinterFlags, print_attributes), 2 },
    };
    /* *INDENT-ON* */

    TScreen *screen = TScreenOf(xw);
    PrinterFlags *result = &(screen->printer_flags);

    TRACE(("getPrinterFlags %d params\n", param_count ? *param_count : 0));

    result->printer_extent = SPS.printer_extent;
    result->printer_formfeed = SPS.printer_formfeed;
    result->printer_newline = SPS.printer_newline;
    result->print_attributes = SPS.print_attributes;
    result->print_everything = SPS.print_everything;

    if (param_count != 0 && *param_count != 0) {
	Cardinal j;
	unsigned k;
	for (j = 0; j < *param_count; ++j) {
	    TRACE(("param%d:%s\n", j, params[j]));
	    for (k = 0; k < XtNumber(table); ++k) {
		if (!x_strcasecmp(params[j], table[k].name)) {
		    int *ptr = (int *) (void *) ((char *) result + table[k].offset);
		    TRACE(("...PrinterFlags(%s) %d->%d\n",
			   table[k].name,
			   *ptr,
			   table[k].value));
		    *ptr = table[k].value;
		    break;
		}
	    }
	}
    }

    return result;
}

/*
 * Print a timestamped copy of everything.
 */
void
xtermPrintImmediately(XtermWidget xw, String filename, int opts, int attrs)
{
    TScreen *screen = TScreenOf(xw);
    PrinterState save_state = screen->printer_state;
    char *my_filename = malloc(TIMESTAMP_LEN + strlen(filename));

    if (my_filename != 0) {
	unsigned save_umask = umask(0177);

	timestamp_filename(my_filename, filename);
	SPS.fp = 0;
	SPS.isOpen = False;
	SPS.toFile = True;
	SPS.printer_command = my_filename;
	SPS.printer_autoclose = True;
	SPS.printer_formfeed = False;
	SPS.printer_newline = True;
	SPS.print_attributes = attrs;
	SPS.print_everything = opts;
	xtermPrintEverything(xw, getPrinterFlags(xw, NULL, 0));

	umask(save_umask);
	screen->printer_state = save_state;
    }
}

void
xtermPrintOnXError(XtermWidget xw, int n)
{
#if OPT_PRINT_ON_EXIT
    /*
     * The user may have requested that the contents of the screen will be
     * written to a file if an X error occurs.
     */
    if (TScreenOf(xw)->write_error && !IsEmpty(resource.printFileOnXError)) {
	Boolean printIt = False;

	switch (n) {
	case ERROR_XERROR:
	    /* FALLTHRU */
	case ERROR_XIOERROR:
	    /* FALLTHRU */
	case ERROR_ICEERROR:
	    printIt = True;
	    break;
	}

	if (printIt) {
	    xtermPrintImmediately(xw,
				  resource.printFileOnXError,
				  resource.printOptsOnXError,
				  resource.printModeOnXError);
	}
    }
#else
    (void) xw;
    (void) n;
#endif
}
@


1.17
log
@Update to xterm-309. Version 308 tested by several people including
naddy@@ who found a small regression, fixed in 309.
@
text
@d1 1
a1 1
/* $XTermId: print.c,v 1.152 2014/06/13 00:36:51 tom Exp $ */
d4 1
a4 1
 * Copyright 1997-2013,2014 by Thomas E. Dickey
a131 2
    IAttr attr = 0;
    unsigned ch;
a132 1
    int col;
a137 2
    int cs = CSET_IN;
    int last_cs = CSET_IN;
d153 1
d155 4
d164 2
a165 1
	    ch = ld->charData[col];
a305 1
    int done_which = 0;
d308 1
d310 2
a441 1
		FILE *input;
a442 1
		int c;
d470 1
d474 1
d476 2
d492 1
d580 8
@


1.16
log
@Update to xterm 293. Tested by naddy@@ ajacoutot@@
@
text
@d1 1
a1 1
/* $XTermId: print.c,v 1.150 2013/05/27 00:55:47 tom Exp $ */
d4 1
a4 1
 * Copyright 1997-2012,2013 by Thomas E. Dickey
d127 1
a127 1
printLine(XtermWidget xw, int row, unsigned chr, PrinterFlags * p)
d132 1
a132 1
    Char attr = 0;
d183 1
a183 1
		attr = CharOf(ld->attribs[col] & SGR_MASK);
d255 1
a255 1
printLines(XtermWidget xw, int top, int bot, PrinterFlags * p)
d265 1
a265 1
xtermPrintScreen(XtermWidget xw, Bool use_DECPEX, PrinterFlags * p)
d300 1
a300 1
xtermPrintEverything(XtermWidget xw, PrinterFlags * p)
d347 1
a347 1
send_CharSet(XtermWidget xw, LineData * ld)
d382 6
d735 1
a735 1
getPrinterFlags(XtermWidget xw, String * params, Cardinal *param_count)
@


1.15
log
@Update to xterm 291. Tested by many.
@
text
@d1 1
a1 1
/* $XTermId: print.c,v 1.149 2012/12/31 13:58:16 tom Exp $ */
d4 1
a4 1
 * Copyright 1997-2011,2012 by Thomas E. Dickey
d90 1
d98 3
a100 1
	    while (nonblocking_wait() > 0) ;
d105 1
d307 1
d444 1
a445 1
		    (void) signal(SIGCHLD, SIG_DFL);	/* no reapchild! */
d463 1
d466 6
a471 2
			while (!ferror(input) && !feof(input)) {
			    if ((c = fgetc(input)) == EOF)
d473 4
d481 1
d487 8
a494 3
		    SPS.fp = fdopen(my_pipe[1], "w");
		    TRACE(("opened printer from pid %d/%d\n",
			   (int) getpid(), (int) my_pid));
@


1.14
log
@Update to xterm 287. tested by mpi@@ and krw@@.
@
text
@d1 1
a1 1
/* $XTermId: print.c,v 1.147 2012/10/29 10:41:53 tom Exp $ */
d662 11
a672 7
	if (argv && argv[0]) {
	    if (xtermFindShell(argv[0], False) == 0) {
		xtermWarning("No program found for printerCommand: %s\n", SPS.printer_command);
		SPS.printer_command = x_strdup("");
	    } else {
		SPS.printer_checked = True;
		result = True;
d674 1
@


1.13
log
@Update to xterm-275. Tested by jasper@@.
@
text
@d1 1
a1 1
/* $XTermId: print.c,v 1.139 2011/09/11 14:59:36 tom Exp $ */
d4 1
a4 1
 * Copyright 1997-2010,2011 by Thomas E. Dickey
d77 1
a77 1
void
d90 1
a90 1
	    fclose(SPS.fp);
d97 1
a97 1
	    while (nonblocking_wait() > 0)
a98 1
		;
d440 1
d457 11
a467 5
		    input = fdopen(my_pipe[0], "r");
		    while ((c = fgetc(input)) != EOF) {
			fputc(c, SPS.fp);
			if (isForm(c))
			    fflush(SPS.fp);
a468 1
		    pclose(SPS.fp);
d649 4
d658 15
d674 1
a674 1
    return (strlen(SPS.printer_command) != 0);
@


1.12
log
@Update to xterm 271. Tested by shadchin@@ and ajacoutot@@
@
text
@d1 1
a1 1
/* $XTermId: print.c,v 1.138 2011/07/14 23:49:10 tom Exp $ */
d3 29
a31 31
/************************************************************

Copyright 1997-2010,2011 by Thomas E. Dickey

                        All Rights Reserved

Permission is hereby granted, free of charge, to any person obtaining a
copy of this software and associated documentation files (the
"Software"), to deal in the Software without restriction, including
without limitation the rights to use, copy, modify, merge, publish,
distribute, sublicense, and/or sell copies of the Software, and to
permit persons to whom the Software is furnished to do so, subject to
the following conditions:

The above copyright notice and this permission notice shall be included
in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
IN NO EVENT SHALL THE ABOVE LISTED COPYRIGHT HOLDER(S) BE LIABLE FOR ANY
CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

Except as contained in this notice, the name(s) of the above copyright
holders shall not be used in advertising or otherwise to promote the
sale, use or other dealings in this Software without prior written
authorization.

********************************************************/
@


1.11
log
@Update to xterm 270. Tested by ajacoutot@@, shadchin@@, krw@@ and jasper@@
@
text
@d1 1
a1 1
/* $XTermId: print.c,v 1.123 2011/04/17 19:45:14 tom Exp $ */
d42 1
d54 5
a58 3
#define Strlen(a)      strlen((char *)a)
#define Strcmp(a,b)    strcmp((char *)a,(char *)b)
#define Strncmp(a,b,c) strncmp((char *)a,(char *)b,c)
a78 4
static FILE *Printer;
static pid_t Printer_pid;
static int initialized;

d83 1
a84 2
	TScreen *screen = TScreenOf(xw);

d87 1
a87 1
		       screen->printer_command,
d91 2
a92 2
	if (Printer != 0) {
	    fclose(Printer);
d102 2
a103 2
	    Printer = 0;
	    initialized = 0;
d253 10
d269 6
a274 10
	int top = extent ? 0 : screen->top_marg;
	int bot = extent ? screen->max_row : screen->bot_marg;
	int was_open = initialized;

	TRACE(("xtermPrintScreen, rows %d..%d\n", top, bot));

	while (top <= bot) {
	    printLine(xw, top, PrintNewLine(), p);
	    ++top;
	}
d278 1
a278 1
	if (!was_open || screen->printer_autoclose) {
d287 1
d291 6
d302 33
a334 13
    int top = 0;
    int bot = screen->max_row;
    int was_open = initialized;

    if (!screen->whichBuf) {
	top = -screen->savedlines - screen->topline;
	bot -= screen->topline;
    }

    TRACE(("xtermPrintEverything, rows %d..%d\n", top, bot));
    while (top <= bot) {
	printLine(xw, top, PrintNewLine(), p);
	++top;
d339 1
a339 1
    if (!was_open || screen->printer_autoclose) {
d376 1
d415 2
a416 2
    if (!initialized && xtermHasPrinter(xw)) {
	switch (screen->printToFile) {
d428 1
a428 1
	    Printer = fopen(VMS_TEMP_PRINT_FILE, "w");
d434 1
d438 1
a438 1
		if ((Printer_pid = fork()) < 0)
d441 1
a441 1
		if (Printer_pid == 0) {
d458 1
a458 1
		    Printer = popen(screen->printer_command, "w");
d461 1
a461 1
			fputc(c, Printer);
d463 1
a463 1
			    fflush(Printer);
d465 1
a465 1
		    pclose(Printer);
d469 1
a469 1
		    Printer = fdopen(my_pipe[1], "w");
d471 1
a471 1
			   (int) getpid(), (int) Printer_pid));
d477 2
a478 1
	    Printer = fopen(screen->printer_command, "w");
d481 1
a481 1
	initialized++;
d483 1
a483 1
    if (Printer != 0) {
d488 1
a488 1
	    fputs((char *) temp, Printer);
d491 1
a491 1
	    fputc((int) chr, Printer);
d493 1
a493 1
	    fflush(Printer);
d560 1
a560 1
    if (screen->printer_controlmode == 1) {
d563 2
a564 2
	if (Printer != 0)
	    fflush(Printer);
d585 2
a586 2
    static struct {
	Char seq[5];
d621 2
a622 2
		if (screen->printer_autoclose
		    && screen->printer_controlmode == 0)
d652 1
a652 1
    return (strlen(screen->printer_command) != 0);
d668 1
a668 1
	&& screen->printer_controlmode != mode) {
d675 2
a676 2
		: showPrinterControlMode(screen->printer_controlmode))));
	screen->printer_controlmode = mode;
d705 5
a709 4
    result->printer_extent = screen->printer_extent;
    result->printer_formfeed = screen->printer_formfeed;
    result->printer_newline = screen->printer_newline;
    result->print_attributes = screen->print_attributes;
d731 64
@


1.10
log
@Update to xterm version 269.
Tested and ok ajacoutot@@, jasper@@, krw@@, shadchin@@
@
text
@d1 1
a1 1
/* $XTermId: print.c,v 1.121 2011/02/09 10:11:44 tom Exp $ */
d80 1
a80 1
static void
d384 13
a396 8
#if defined(VMS)
	/*
	 * This implementation only knows how to write to a file.  When the
	 * file is closed the print command executes.  Print command must be of
	 * the form:
	 *   print/que=name/delete [/otherflags].
	 */
	Printer = fopen(VMS_TEMP_PRINT_FILE, "w");
d398 42
a439 23
	/*
	 * This implementation only knows how to write to a pipe.
	 */
	FILE *input;
	int my_pipe[2];
	int c;

	if (pipe(my_pipe))
	    SysError(ERROR_FORK);
	if ((Printer_pid = fork()) < 0)
	    SysError(ERROR_FORK);

	if (Printer_pid == 0) {
	    TRACE_CLOSE();
	    close(my_pipe[1]);	/* printer is silent */
	    close(screen->respond);

	    close(fileno(stdout));
	    dup2(fileno(stderr), 1);

	    if (fileno(stderr) != 2) {
		dup2(fileno(stderr), 2);
		close(fileno(stderr));
d441 5
a445 19

	    /* don't want privileges! */
	    if (xtermResetIds(screen) < 0)
		exit(1);

	    Printer = popen(screen->printer_command, "w");
	    input = fdopen(my_pipe[0], "r");
	    while ((c = fgetc(input)) != EOF) {
		fputc(c, Printer);
		if (isForm(c))
		    fflush(Printer);
	    }
	    pclose(Printer);
	    exit(0);
	} else {
	    close(my_pipe[0]);	/* won't read from printer */
	    Printer = fdopen(my_pipe[1], "w");
	    TRACE(("opened printer from pid %d/%d\n",
		   (int) getpid(), (int) Printer_pid));
a446 1
#endif
@


1.9
log
@Update to xterm 261. Tested by krw@@, jcs@@.
@
text
@d1 1
a1 1
/* $XTermId: print.c,v 1.119 2010/06/13 17:46:27 tom Exp $ */
d5 1
a5 1
Copyright 1997-2009,2010 by Thomas E. Dickey
a137 1
    CellColor *fb = 0;
a152 3
    if_OPT_ISO_COLORS(screen, {
	fb = ld->color;
    });
d674 1
a674 1
		    int *ptr = (int *) ((char *) result + table[k].offset);
@


1.8
log
@Update to xterm 258. lightly tested by krw@@, thanks.
@
text
@d1 1
a1 1
/* $XTermId: print.c,v 1.116 2010/04/05 00:11:13 tom Exp $ */
d189 1
d192 1
d282 1
a282 1
	Bell(XkbBI_MinorError, 0);
d410 1
a410 1
	    TRACE(((char *) 0));
@


1.7
log
@Update to xterm-255. Tested by stsp@@, oga@@.
@
text
@d1 1
a1 1
/* $XTermId: print.c,v 1.115 2009/12/10 09:44:39 tom Exp $ */
d5 1
a5 1
Copyright 1997-2007,2009 by Thomas E. Dickey
d437 1
a437 1
		   (int) getpid(), Printer_pid));
@


1.6
log
@Update to xterm 250
@
text
@d1 1
a1 1
/* $XTermId: print.c,v 1.110 2009/10/12 00:04:19 tom Exp $ */
d39 1
d65 2
a66 1
		      unsigned /* chr */ );
d117 1
a117 1
    printLine(xw, screen->cur_row, '\n');
d128 1
a128 1
printLine(XtermWidget xw, int row, unsigned chr)
d147 3
d164 1
a164 1
	if (screen->print_attributes) {
d172 1
a172 1
		if (screen->print_attributes > 1) {
d191 1
a191 1
		if (screen->print_attributes)
d205 1
a205 1
		if (screen->print_attributes) {
d233 1
a233 1
	if (screen->print_attributes) {
d239 3
a241 1
    if (screen->print_attributes)
d243 8
a250 1
    charToPrinter(xw, chr);
d255 2
d258 1
a258 1
xtermPrintScreen(XtermWidget xw, Bool use_DECPEX)
d262 1
a262 1
	Bool extent = (use_DECPEX && screen->printer_extent);
d269 5
a273 3
	while (top <= bot)
	    printLine(xw, top++, '\n');
	if (screen->printer_formfeed)
d290 1
a290 1
xtermPrintEverything(XtermWidget xw)
d303 5
a307 3
    while (top <= bot)
	printLine(xw, top++, '\n');
    if (screen->printer_formfeed)
d362 1
a362 1
	if (xw->screen.boldColors
d486 1
a486 1
	    xtermPrintScreen(xw, False);
d489 1
a489 1
	    xtermPrintEverything(xw);
d496 1
a496 1
	    xtermPrintScreen(xw, True);
d521 1
a521 1
	printLine(xw, screen->cursorp.row, chr);
d624 2
d627 1
a627 1
	&& xw->screen.printer_controlmode != mode) {
d634 2
a635 2
		: showPrinterControlMode(xw->screen.printer_controlmode))));
	xw->screen.printer_controlmode = mode;
d638 51
@


1.5
log
@Update to xterm 248, fixing several bugs including a regression with
copy-and-paste. Works for martynas@@, ok matthieu@@
@
text
@d1 1
a1 1
/* $XTermId: print.c,v 1.109 2009/09/10 09:06:30 tom Exp $ */
d72 1
a72 1
			    char * /*str */ );
d299 1
a299 1
    char *msg = 0;
d437 1
a437 1
stringToPrinter(XtermWidget xw, char *str)
@


1.4
log
@update to xterm 247, a small bug fix over version 246.
@
text
@d1 1
a1 1
/* $XTermId: print.c,v 1.107 2009/08/31 00:37:04 tom Exp $ */
a164 3
	    if_OPT_WIDE_CHARS(screen, {
		ch = XTERM_CELL(row, col);
	    });
d221 1
a221 1
		    ch = XTERM_CELLC(row, col, off);
@


1.3
log
@update to xterm 246. Has been in snapshots for some time.
@
text
@d1 1
a1 1
/* $XTermId: print.c,v 1.105 2009/08/07 00:25:10 tom Exp $ */
d282 4
a285 2
    if (!screen->whichBuf)
	top = -screen->savedlines;
@


1.2
log
@xterm 239

correct a cast in input.c, which broke translation of numeric
keypad codes to pageup, pagedown, etc., on 64-bit platform (Debian
#511138, report by Larry Doolittle).
@
text
@d1 1
a1 5
/* $XTermId: print.c,v 1.81 2009/01/09 01:43:01 tom Exp $ */

/*
 * $XFree86: xc/programs/xterm/print.c,v 1.24 2006/06/19 00:36:51 dickey Exp $
 */
d60 13
a72 5
static void charToPrinter(unsigned chr);
static void printLine(int row, unsigned chr);
static void send_CharSet(int row);
static void send_SGR(unsigned attr, unsigned fg, unsigned bg);
static void stringToPrinter(char *str);
d79 1
a79 1
closePrinter(void)
d81 1
a81 1
    if (xtermHasPrinter() != 0) {
d83 1
a83 1
	TScreen *screen = TScreenOf(term);
d110 1
a110 1
printCursorLine(void)
d112 1
a112 1
    TScreen *screen = TScreenOf(term);
d115 1
a115 1
    printLine(screen->cur_row, '\n');
d126 1
a126 1
printLine(int row, unsigned chr)
d128 1
a128 1
    TScreen *screen = TScreenOf(term);
d130 1
a130 2
    Char *c = SCRN_BUF_CHARS(screen, inx);
    Char *a = SCRN_BUF_ATTRS(screen, inx);
d136 2
a137 8
#if OPT_EXT_COLORS
    Char *fbf = 0;
    Char *fbb = 0;
#define ColorOf(col) (unsigned)((fbf[col] << 8) | fbb[col])
#else
    Char *fb = 0;
#define ColorOf(col) (fb[col])
#endif
d144 1
d147 4
a150 12
	   visibleChars(PAIRED_CHARS(c,
				     (screen->utf8_mode
				      ? SCRN_BUF_WIDEC(screen, inx)
				      : 0)),
			(unsigned) last)));

    if_OPT_EXT_COLORS(screen, {
	fbf = SCRN_BUF_FGRND(screen, inx);
	fbb = SCRN_BUF_BGRND(screen, inx);
    });
    if_OPT_ISO_TRADITIONAL_COLORS(screen, {
	fb = SCRN_BUF_COLOR(screen, inx);
d153 1
a153 1
	if ((a[last - 1] & CHARDRAWN) == 0)
d160 2
a161 2
	    send_CharSet(row);
	    send_SGR(0, NO_COLOR, NO_COLOR);
d164 1
a164 1
	    ch = c[col];
d171 2
a172 2
		    fg = (a[col] & FG_COLOR)
			? extract_fg(term, ColorOf(col), a[col])
d174 2
a175 2
		    bg = (a[col] & BG_COLOR)
			? extract_bg(term, ColorOf(col), a[col])
d180 1
a180 1
	    if ((((a[col] & SGR_MASK) != attr)
d186 1
a186 1
		attr = CharOf(a[col] & SGR_MASK);
d190 1
a190 1
		    send_SGR(attr, fg, bg);
d204 2
a205 1
		    charToPrinter((unsigned) ((cs == CSET_OUT)
d217 2
a218 1
	    charToPrinter(((cs == CSET_OUT)
d222 4
a225 3
		int off;
		for (off = OFF_FINAL; off < MAX_PTRS; off += 2) {
		    if ((ch = XTERM_CELLC(row, col, off)) == 0)
d227 1
a227 1
		    charToPrinter(ch);
d232 1
a232 1
	    send_SGR(0, NO_COLOR, NO_COLOR);
d234 1
a234 1
		charToPrinter(SHIFT_IN);
d238 4
a241 2
	charToPrinter('\r');
    charToPrinter(chr);
d245 1
a245 1
xtermPrintScreen(Bool use_DECPEX)
d247 2
a248 2
    if (XtIsRealized((Widget) term)) {
	TScreen *screen = TScreenOf(term);
d257 1
a257 1
	    printLine(top++, '\n');
d259 1
a259 1
	    charToPrinter('\f');
d262 1
a262 1
	    closePrinter();
d274 2
a275 2
static void
xtermPrintEverything(void)
d277 1
a277 1
    TScreen *screen = TScreenOf(term);
d282 1
a282 1
    if (!screen->altbuf)
d287 1
a287 1
	printLine(top++, '\n');
d289 1
a289 1
	charToPrinter('\f');
d292 1
a292 1
	closePrinter();
d297 1
a297 1
send_CharSet(int row)
a299 1
    TScreen *screen = TScreenOf(term);
d302 1
a302 1
    switch (SCRN_BUF_CSETS(screen, row)[0]) {
d317 1
a317 1
	stringToPrinter(msg);
d319 2
a320 1
    (void) row;
d325 1
a325 1
send_SGR(unsigned attr, unsigned fg, unsigned bg)
d343 1
a343 1
	if (term->screen.boldColors
d355 1
a355 1
    stringToPrinter(msg);
d362 1
a362 1
charToPrinter(unsigned chr)
d364 1
a364 1
    TScreen *screen = TScreenOf(term);
d366 1
a366 1
    if (!initialized && xtermHasPrinter()) {
d438 1
a438 1
stringToPrinter(char *str)
d441 1
a441 1
	charToPrinter(CharOf(*str++));
d451 1
a451 1
xtermMediaControl(int param, int private_seq)
d458 1
a458 1
	    printCursorLine();
d461 1
a461 1
	    setPrinterControlMode(0);
d464 1
a464 1
	    setPrinterControlMode(1);
d467 1
a467 1
	    xtermPrintScreen(False);
d470 1
a470 1
	    xtermPrintEverything();
d477 1
a477 1
	    xtermPrintScreen(True);
d480 1
a480 1
	    setPrinterControlMode(0);
d483 1
a483 1
	    setPrinterControlMode(2);
d496 1
a496 1
xtermAutoPrint(unsigned chr)
d498 1
a498 1
    TScreen *screen = TScreenOf(term);
d502 1
a502 1
	printLine(screen->cursorp.row, chr);
d521 1
a521 1
xtermPrinterControl(int chr)
d523 1
a523 1
    TScreen *screen = TScreenOf(term);
d560 1
a560 1
		setPrinterControlMode(tbl[n].active);
d563 1
a563 1
		    closePrinter();
d577 1
a577 1
	    charToPrinter(bfr[n]);
d588 1
a588 1
xtermHasPrinter(void)
d590 1
a590 1
    TScreen *screen = TScreenOf(term);
d603 1
a603 1
setPrinterControlMode(int mode)
d605 2
a606 2
    if (xtermHasPrinter()
	&& term->screen.printer_controlmode != mode) {
d613 2
a614 2
		: showPrinterControlMode(term->screen.printer_controlmode))));
	term->screen.printer_controlmode = mode;
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/* $XTermId: print.c,v 1.77 2006/07/23 22:06:23 tom Exp $ */
d9 1
a9 1
Copyright 1997-2005,2006 by Thomas E. Dickey
d79 1
a79 1
	TScreen *screen = &term->screen;
d108 1
a108 1
    TScreen *screen = &term->screen;
d124 1
a124 1
    TScreen *screen = &term->screen;
d196 1
a196 1
		attr = (a[col] & SGR_MASK);
d211 1
a211 1
		cs = (ch >= ' ' && ch != DEL) ? CSET_IN : CSET_OUT;
d227 1
a227 1
			   ? (ch == DEL ? 0x5f : (ch + 0x5f))
d253 1
a253 1
	TScreen *screen = &term->screen;
d282 1
a282 1
    TScreen *screen = &term->screen;
d305 1
a305 1
    TScreen *screen = &term->screen;
d369 1
a369 1
    TScreen *screen = &term->screen;
d503 1
a503 1
    TScreen *screen = &term->screen;
d528 1
a528 1
    TScreen *screen = &term->screen;
d534 4
a537 4
	{ { CSI, '5', 'i'      }, 2 },
	{ { CSI, '4', 'i'      }, 0 },
	{ { ESC, LB,  '5', 'i' }, 2 },
	{ { ESC, LB,  '4', 'i' }, 0 },
d553 2
a554 2
    case CSI:
    case ESC:
d559 1
a559 1
	bfr[length++] = chr;
d583 1
a583 1
	bfr[0] = chr;
d595 1
a595 1
    TScreen *screen = &term->screen;
@


1.1.1.1
log
@Importing xterm 216
@
text
@@


1.1.1.2
log
@import xterm 225
@
text
@d1 1
a1 1
/* $XTermId: print.c,v 1.80 2007/03/19 23:49:51 tom Exp $ */
d9 1
a9 1
Copyright 1997-2006,2007 by Thomas E. Dickey
d79 1
a79 1
	TScreen *screen = TScreenOf(term);
d108 1
a108 1
    TScreen *screen = TScreenOf(term);
d124 1
a124 1
    TScreen *screen = TScreenOf(term);
d211 1
a211 1
		cs = (ch >= ' ' && ch != ANSI_DEL) ? CSET_IN : CSET_OUT;
d227 1
a227 1
			   ? (ch == ANSI_DEL ? 0x5f : (ch + 0x5f))
d253 1
a253 1
	TScreen *screen = TScreenOf(term);
d282 1
a282 1
    TScreen *screen = TScreenOf(term);
d305 1
a305 1
    TScreen *screen = TScreenOf(term);
d369 1
a369 1
    TScreen *screen = TScreenOf(term);
d503 1
a503 1
    TScreen *screen = TScreenOf(term);
d528 1
a528 1
    TScreen *screen = TScreenOf(term);
d534 4
a537 4
	{ { ANSI_CSI, '5', 'i'      }, 2 },
	{ { ANSI_CSI, '4', 'i'      }, 0 },
	{ { ANSI_ESC, LB,  '5', 'i' }, 2 },
	{ { ANSI_ESC, LB,  '4', 'i' }, 0 },
d553 2
a554 2
    case ANSI_CSI:
    case ANSI_ESC:
d595 1
a595 1
    TScreen *screen = TScreenOf(term);
@

