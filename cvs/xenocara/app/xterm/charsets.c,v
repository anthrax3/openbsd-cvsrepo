head	1.5;
access;
symbols
	OPENBSD_6_0:1.5.0.12
	OPENBSD_6_0_BASE:1.5
	OPENBSD_5_9:1.5.0.10
	OPENBSD_5_9_BASE:1.5
	OPENBSD_5_8:1.5.0.8
	OPENBSD_5_8_BASE:1.5
	OPENBSD_5_7:1.5.0.6
	OPENBSD_5_7_BASE:1.5
	OPENBSD_5_6:1.5.0.4
	OPENBSD_5_6_BASE:1.5
	OPENBSD_5_5:1.5.0.2
	OPENBSD_5_5_BASE:1.5
	OPENBSD_5_4:1.4.0.8
	OPENBSD_5_4_BASE:1.4
	OPENBSD_5_3:1.4.0.6
	OPENBSD_5_3_BASE:1.4
	OPENBSD_5_2:1.4.0.4
	OPENBSD_5_2_BASE:1.4
	OPENBSD_5_1_BASE:1.4
	OPENBSD_5_1:1.4.0.2
	OPENBSD_5_0:1.3.0.10
	OPENBSD_5_0_BASE:1.3
	OPENBSD_4_9:1.3.0.6
	OPENBSD_4_9_BASE:1.3
	OPENBSD_4_8:1.3.0.8
	OPENBSD_4_8_BASE:1.3
	OPENBSD_4_7:1.3.0.4
	OPENBSD_4_7_BASE:1.3
	OPENBSD_4_6:1.3.0.2
	OPENBSD_4_6_BASE:1.3
	OPENBSD_4_5:1.2.0.2
	OPENBSD_4_5_BASE:1.2
	OPENBSD_4_4:1.1.1.2.0.6
	OPENBSD_4_4_BASE:1.1.1.2
	OPENBSD_4_3_BASE:1.1.1.2
	OPENBSD_4_3:1.1.1.2.0.4
	v232:1.1.1.2
	v229:1.1.1.2
	OPENBSD_4_2:1.1.1.2.0.2
	OPENBSD_4_2_BASE:1.1.1.2
	v225:1.1.1.2
	v216:1.1.1.1
	xterm:1.1.1;
locks; strict;
comment	@ * @;


1.5
date	2014.01.02.15.14.50;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2011.09.17.11.51.57;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2009.03.09.22.13.04;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2008.08.25.18.05.57;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.26.11.11.23;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.11.26.11.11.23;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2007.06.15.19.30.09;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.5
log
@Update to xterm-300. Tested  by ajacoutot@@ and shadchin@@.
@
text
@/* $XTermId: charsets.c,v 1.67 2013/12/01 16:38:13 tom Exp $ */

/*
 * Copyright 1998-2011,2013 by Thomas E. Dickey
 *
 *                         All Rights Reserved
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 *
 * The above copyright notice and this permission notice shall be included
 * in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
 * IN NO EVENT SHALL THE ABOVE LISTED COPYRIGHT HOLDER(S) BE LIABLE FOR ANY
 * CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
 * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
 * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 *
 * Except as contained in this notice, the name(s) of the above copyright
 * holders shall not be used in advertising or otherwise to promote the
 * sale, use or other dealings in this Software without prior written
 * authorization.
 *
 */

#include <xterm.h>
#include <data.h>
#include <fontutils.h>

#include <X11/keysym.h>

/*
 * This module performs translation as needed to support the DEC VT220 national
 * replacement character sets.  We assume that xterm's font is based on the ISO
 * 8859-1 (Latin 1) character set, which is almost the same as the DEC
 * multinational character set.  Glyph positions 0-31 have to be the DEC
 * graphic characters, though.
 *
 * References:
 *	"VT220 Programmer Pocket Guide" EK-VT220-HR-002 (2nd ed., 1984), which
 *		contains character charts for the national character sets.
 *	"VT330/VT340 Programmer Reference Manual Volume 1: Text Programming"
 *		EK-VT3XX-TP-001 (1st ed, 1987), which contains a table (2-1)
 *		listing the glyphs which are mapped from the multinational
 *		character set to the national character set.
 *
 * The latter reference, though easier to read, has a few errors and omissions.
 */

#define map_NRCS_Dutch(code) \
	switch (code) { \
	    MAP(0x23, XK_sterling); \
	    MAP(0x40, XK_threequarters); \
	    UNI(0x5b, 0x0133); /* ij ligature */ \
	    MAP(0x5c, XK_onehalf); \
	    MAP(0x5d, XK_bar); \
	    MAP(0x7b, XK_diaeresis); \
	    UNI(0x7c, 0x0192); /* florin */ \
	    MAP(0x7d, XK_onequarter); \
	    MAP(0x7e, XK_acute); \
	}

#define map_NRCS_Finnish(code) \
	switch (code) { \
	    MAP(0x5b, XK_Adiaeresis); \
	    MAP(0x5c, XK_Odiaeresis); \
	    MAP(0x5d, XK_Aring); \
	    MAP(0x5e, XK_Udiaeresis); \
	    MAP(0x60, XK_eacute); \
	    MAP(0x7b, XK_adiaeresis); \
	    MAP(0x7c, XK_odiaeresis); \
	    MAP(0x7d, XK_aring); \
	    MAP(0x7e, XK_udiaeresis); \
	}

#define map_NRCS_French(code) \
	switch (code) { \
	    MAP(0x23, XK_sterling); \
	    MAP(0x40, XK_agrave); \
	    MAP(0x5b, XK_degree); \
	    MAP(0x5c, XK_ccedilla); \
	    MAP(0x5d, XK_section); \
	    MAP(0x7b, XK_eacute); \
	    MAP(0x7c, XK_ugrave); \
	    MAP(0x7d, XK_egrave); \
	    MAP(0x7e, XK_diaeresis); \
	}

#define map_NRCS_French_Canadian(code) \
	switch (code) { \
	    MAP(0x40, XK_agrave); \
	    MAP(0x5b, XK_acircumflex); \
	    MAP(0x5c, XK_ccedilla); \
	    MAP(0x5d, XK_ecircumflex); \
	    MAP(0x5e, XK_icircumflex); \
	    MAP(0x60, XK_ocircumflex); \
	    MAP(0x7b, XK_eacute); \
	    MAP(0x7c, XK_ugrave); \
	    MAP(0x7d, XK_egrave); \
	    MAP(0x7e, XK_ucircumflex); \
	}

#define map_NRCS_German(code) \
	switch (code) { \
	    MAP(0x40, XK_section); \
	    MAP(0x5b, XK_Adiaeresis); \
	    MAP(0x5c, XK_Odiaeresis); \
	    MAP(0x5d, XK_Udiaeresis); \
	    MAP(0x7b, XK_adiaeresis); \
	    MAP(0x7c, XK_odiaeresis); \
	    MAP(0x7d, XK_udiaeresis); \
	    MAP(0x7e, XK_ssharp); \
	}

#define map_NRCS_Italian(code) \
	switch (code) { \
	    MAP(0x23, XK_sterling); \
	    MAP(0x40, XK_section); \
	    MAP(0x5b, XK_degree); \
	    MAP(0x5c, XK_ccedilla); \
	    MAP(0x5d, XK_eacute); \
	    MAP(0x60, XK_ugrave); \
	    MAP(0x7b, XK_agrave); \
	    MAP(0x7c, XK_ograve); \
	    MAP(0x7d, XK_egrave); \
	    MAP(0x7e, XK_igrave); \
	}

#define map_NRCS_Norwegian_Danish(code) \
	switch (code) { \
	    MAP(0x40, XK_Adiaeresis); \
	    MAP(0x5b, XK_AE); \
	    MAP(0x5c, XK_Ooblique); \
	    MAP(0x5d, XK_Aring); \
	    MAP(0x5e, XK_Udiaeresis); \
	    MAP(0x60, XK_adiaeresis); \
	    MAP(0x7b, XK_ae); \
	    MAP(0x7c, XK_oslash); \
	    MAP(0x7d, XK_aring); \
	    MAP(0x7e, XK_udiaeresis); \
	}

#define map_NRCS_Portuguese(code) \
	switch (code) { \
	    MAP(0x5b, XK_Atilde); \
	    MAP(0x5c, XK_Ccedilla); \
	    MAP(0x5d, XK_Otilde); \
	    MAP(0x7b, XK_atilde); \
	    MAP(0x7c, XK_ccedilla); \
	    MAP(0x7d, XK_otilde); \
	}

#define map_NRCS_Spanish(code) \
	switch (code) { \
	    MAP(0x23, XK_sterling); \
	    MAP(0x40, XK_section); \
	    MAP(0x5b, XK_exclamdown); \
	    MAP(0x5c, XK_Ntilde); \
	    MAP(0x5d, XK_questiondown); \
	    MAP(0x7b, XK_degree); \
	    MAP(0x7c, XK_ntilde); \
	    MAP(0x7d, XK_ccedilla); \
	}

#define map_NRCS_Swedish(code) \
	switch (code) { \
	    MAP(0x40, XK_Eacute); \
	    MAP(0x5b, XK_Adiaeresis); \
	    MAP(0x5c, XK_Odiaeresis); \
	    MAP(0x5d, XK_Aring); \
	    MAP(0x5e, XK_Udiaeresis); \
	    MAP(0x60, XK_eacute); \
	    MAP(0x7b, XK_adiaeresis); \
	    MAP(0x7c, XK_odiaeresis); \
	    MAP(0x7d, XK_aring); \
	    MAP(0x7e, XK_udiaeresis); \
	}

#define map_NRCS_Swiss(code) \
	switch (code) { \
	    MAP(0x23, XK_ugrave); \
	    MAP(0x40, XK_agrave); \
	    MAP(0x5b, XK_eacute); \
	    MAP(0x5c, XK_ccedilla); \
	    MAP(0x5d, XK_ecircumflex); \
	    MAP(0x5e, XK_icircumflex); \
	    MAP(0x5f, XK_egrave); \
	    MAP(0x60, XK_ocircumflex); \
	    MAP(0x7b, XK_adiaeresis); \
	    MAP(0x7c, XK_odiaeresis); \
	    MAP(0x7d, XK_udiaeresis); \
	    MAP(0x7e, XK_ucircumflex); \
	}

/*
 * Unlike NRCS, which splices a few characters onto ASCII, the supplementary
 * character sets are complete, normally mapped to GR.  Most of these mappings
 * rely upon glyphs not found in ISO-8859-1.  We can display most of those
 * using Unicode, thereby supporting specialized applications that use SCS
 * with luit, subject to the limitation that select/paste will give meaningless
 * results in terms of the application which uses these mappings.
 *
 * Since the VT320, etc, use only 8-bit encodings, there is no plausible
 * argument to be made that these mappings "use" UTF-8, even though there is
 * a hidden step in the terminal emulator which relies upon UTF-8.
 */
#define map_SCS_DEC_Supp(code,dft) \
	switch (code) { \
	    XXX(0x24, 0x2e2e); \
	    XXX(0x26, 0x2e2e); \
	    XXX(0x2c, 0x2e2e); \
	    XXX(0x2d, 0x2e2e); \
	    XXX(0x2e, 0x2e2e); \
	    XXX(0x2f, 0x2e2e); \
	    XXX(0x34, 0x2e2e); \
	    XXX(0x38, 0x2e2e); \
	    XXX(0x3e, 0x2e2e); \
	    UNI(0x47, 0x2426); \
	    MAP(0x48, 0xc7); \
	    MAP(0x49, 0xc8); \
	    MAP(0x4a, 0xc9); \
	    MAP(0x4b, 0xca); \
	    MAP(0x4c, 0xcb); \
	    MAP(0x4d, 0xcc); \
	    MAP(0x4e, 0xcd); \
	    MAP(0x4f, 0xce); \
	    XXX(0x50, 0x2e2e); \
	    UNI(0x57, 0x0152); \
	    XXX(0x5e, 0x2e2e); \
	    XXX(0x70, 0x2e2e); \
	    UNI(0x77, 0x0153); \
	    MAP(0x7d, 0xff); \
	    XXX(0x7e, 0x2e2e); \
	    default: dft; break; \
	}

#define map_SCS_DEC_Supp_Graphic(code,dft) \
	switch (code) { \
	    XXX(0x24, 0x2e2e); \
	    XXX(0x26, 0x2e2e); \
	    XXX(0x2c, 0x2e2e); \
	    XXX(0x2d, 0x2e2e); \
	    XXX(0x2e, 0x2e2e); \
	    XXX(0x2f, 0x2e2e); \
	    XXX(0x34, 0x2e2e); \
	    XXX(0x38, 0x2e2e); \
	    XXX(0x3e, 0x2e2e); \
	    XXX(0x50, 0x2e2e); \
	    UNI(0x57, 0x0152); \
	    XXX(0x5e, 0x2e2e); \
	    XXX(0x70, 0x2e2e); \
	    UNI(0x77, 0x0153); \
	    MAP(0x7d, 0xff); \
	    XXX(0x7e, 0x2e2e); \
	    XXX(0x7f, 0x2e2e); \
	    default: dft; break; \
	}

	/* derived from http://www.vt100.net/charsets/technical.html */
#if OPT_WIDE_CHARS
#define map_SCS_DEC_Technical(code) \
	switch (code) { \
	    UNI(0x21, 0x23b7);	/* RADICAL SYMBOL BOTTOM Centred left to right, so that it joins up with 02/02 */ \
	    UNI(0x22, 0x250c);	/* BOX DRAWINGS LIGHT DOWN AND RIGHT */ \
	    UNI(0x23, 0x2500);	/* BOX DRAWINGS LIGHT HORIZONTAL */ \
	    UNI(0x24, 0x2320);	/* TOP HALF INTEGRAL with the proviso that the stem is vertical, to join with 02/06 */ \
	    UNI(0x25, 0x2321);	/* BOTTOM HALF INTEGRAL with the proviso above. */ \
	    UNI(0x26, 0x2502);	/* BOX DRAWINGS LIGHT VERTICAL */ \
	    UNI(0x27, 0x23a1);	/* LEFT SQUARE BRACKET UPPER CORNER Joins vertically to 02/06, 02/08. Doesn't join to its right. */ \
	    UNI(0x28, 0x23a3);	/* LEFT SQUARE BRACKET LOWER CORNER Joins vertically to 02/06, 02/07. Doesn't join to its right. */ \
	    UNI(0x29, 0x23a4);	/* RIGHT SQUARE BRACKET UPPER CORNER Joins vertically to 026, 02a. Doesn't join to its left. */ \
	    UNI(0x2a, 0x23a6);	/* RIGHT SQUARE BRACKET LOWER CORNER Joins vertically to 026, 029. Doesn't join to its left. */ \
	    UNI(0x2b, 0x239b);	/* LEFT PARENTHESIS UPPER HOOK Joins vertically to 026, 02c, 02/15. Doesn't join to its right. */ \
	    UNI(0x2c, 0x239d);	/* LEFT PARENTHESIS LOWER HOOK Joins vertically to 026, 02b, 02/15. Doesn't join to its right. */ \
	    UNI(0x2d, 0x239e);	/* RIGHT PARENTHESIS UPPER HOOK Joins vertically to 026, 02e, 03/00. Doesn't join to its left. */ \
	    UNI(0x2e, 0x23a0);	/* RIGHT PARENTHESIS LOWER HOOK Joins vertically to 026, 02d, 03/00. Doesn't join to its left. */ \
	    UNI(0x2f, 0x23a8);	/* LEFT CURLY BRACKET MIDDLE PIECE Joins vertically to 026, 02b, 02c. */ \
	    UNI(0x30, 0x23ac);	/* RIGHT CURLY BRACKET MIDDLE PIECE Joins vertically to 02/06, 02d, 02e. */ \
	    XXX(0x31, 0x2426);	/* Top Left Sigma. Joins to right with 02/03, 03/05. Joins diagonally below right with 03/03, 03/07. */ \
	    XXX(0x32, 0x2426);	/* Bottom Left Sigma. Joins to right with 02/03, 03/06. Joins diagonally above right with 03/04, 03/07. */ \
	    XXX(0x33, 0x2426);	/* Top Diagonal Sigma. Line for joining 03/01 to 03/04 or 03/07. */ \
	    XXX(0x34, 0x2426);	/* Bottom Diagonal Sigma. Line for joining 03/02 to 03/03 or 03/07. */ \
	    XXX(0x35, 0x2426);	/* Top Right Sigma. Joins to left with 02/03, 03/01. */ \
	    XXX(0x36, 0x2426);	/* Bottom Right Sigma. Joins to left with 02/03, 03/02. */ \
	    XXX(0x37, 0x2426);	/* Middle Sigma. Joins diagonally with 03/01, 03/02, 03/03, 03/04. */ \
	    XXX(0x38, 0x2426);	/* undefined */ \
	    XXX(0x39, 0x2426);	/* undefined */ \
	    XXX(0x3a, 0x2426);	/* undefined */ \
	    XXX(0x3b, 0x2426);	/* undefined */ \
	    UNI(0x3c, 0x2264);	/* LESS-THAN OR EQUAL TO */ \
	    UNI(0x3d, 0x2260);	/* NOT EQUAL TO */ \
	    UNI(0x3e, 0x2265);	/* GREATER-THAN OR EQUAL TO */ \
	    UNI(0x3f, 0x222B);	/* INTEGRAL */ \
	    UNI(0x40, 0x2234);	/* THEREFORE */ \
	    UNI(0x41, 0x221d);	/* PROPORTIONAL TO */ \
	    UNI(0x42, 0x221e);	/* INFINITY */ \
	    UNI(0x43, 0x00f7);	/* DIVISION SIGN */ \
	    UNI(0x44, 0x039a);	/* GREEK CAPITAL DELTA */ \
	    UNI(0x45, 0x2207);	/* NABLA */ \
	    UNI(0x46, 0x03a6);	/* GREEK CAPITAL LETTER PHI */ \
	    UNI(0x47, 0x0393);	/* GREEK CAPITAL LETTER GAMMA */ \
	    UNI(0x48, 0x223c);	/* TILDE OPERATOR */ \
	    UNI(0x49, 0x2243);	/* ASYMPTOTICALLY EQUAL TO */ \
	    UNI(0x4a, 0x0398);	/* GREEK CAPITAL LETTER THETA */ \
	    UNI(0x4b, 0x00d7);	/* MULTIPLICATION SIGN */ \
	    UNI(0x4c, 0x039b);	/* GREEK CAPITAL LETTER LAMDA */ \
	    UNI(0x4d, 0x21d4);	/* LEFT RIGHT DOUBLE ARROW */ \
	    UNI(0x4e, 0x21d2);	/* RIGHTWARDS DOUBLE ARROW */ \
	    UNI(0x4f, 0x2261);	/* IDENTICAL TO */ \
	    UNI(0x50, 0x03a0);	/* GREEK CAPITAL LETTER PI */ \
	    UNI(0x51, 0x03a8);	/* GREEK CAPITAL LETTER PSI */ \
	    UNI(0x52, 0x2426);	/* undefined */ \
	    UNI(0x53, 0x03a3);	/* GREEK CAPITAL LETTER SIGMA */ \
	    XXX(0x54, 0x2426);	/* undefined */ \
	    XXX(0x55, 0x2426);	/* undefined */ \
	    UNI(0x56, 0x221a);	/* SQUARE ROOT */ \
	    UNI(0x57, 0x03a9);	/* GREEK CAPITAL LETTER OMEGA */ \
	    UNI(0x58, 0x039e);	/* GREEK CAPITAL LETTER XI */ \
	    UNI(0x59, 0x03a5);	/* GREEK CAPITAL LETTER UPSILON */ \
	    UNI(0x5a, 0x2282);	/* SUBSET OF */ \
	    UNI(0x5b, 0x2283);	/* SUPERSET OF */ \
	    UNI(0x5c, 0x2229);	/* INTERSECTION */ \
	    UNI(0x5d, 0x222a);	/* UNION */ \
	    UNI(0x5e, 0x2227);	/* LOGICAL AND */ \
	    UNI(0x5f, 0x2228);	/* LOGICAL OR */ \
	    UNI(0x60, 0x00ac);	/* NOT SIGN */ \
	    UNI(0x61, 0x03b1);	/* GREEK SMALL LETTER ALPHA */ \
	    UNI(0x62, 0x03b2);	/* GREEK SMALL LETTER BETA */ \
	    UNI(0x63, 0x03c7);	/* GREEK SMALL LETTER CHI */ \
	    UNI(0x64, 0x03b4);	/* GREEK SMALL LETTER DELTA */ \
	    UNI(0x65, 0x03b5);	/* GREEK SMALL LETTER EPSILON */ \
	    UNI(0x66, 0x03c6);	/* GREEK SMALL LETTER PHI */ \
	    UNI(0x67, 0x03b3);	/* GREEK SMALL LETTER GAMMA */ \
	    UNI(0x68, 0x03b7);	/* GREEK SMALL LETTER ETA */ \
	    UNI(0x69, 0x03b9);	/* GREEK SMALL LETTER IOTA */ \
	    UNI(0x6a, 0x03b8);	/* GREEK SMALL LETTER THETA */ \
	    UNI(0x6b, 0x03ba);	/* GREEK SMALL LETTER KAPPA */ \
	    UNI(0x6c, 0x03bb);	/* GREEK SMALL LETTER LAMDA */ \
	    XXX(0x6d, 0x2426);	/* undefined */ \
	    UNI(0x6e, 0x03bd);	/* GREEK SMALL LETTER NU */ \
	    UNI(0x6f, 0x2202);	/* PARTIAL DIFFERENTIAL */ \
	    UNI(0x70, 0x03c0);	/* GREEK SMALL LETTER PI */ \
	    UNI(0x71, 0x03c8);	/* GREEK SMALL LETTER PSI */ \
	    UNI(0x72, 0x03c1);	/* GREEK SMALL LETTER RHO */ \
	    UNI(0x73, 0x03c3);	/* GREEK SMALL LETTER SIGMA */ \
	    UNI(0x74, 0x03c4);	/* GREEK SMALL LETTER TAU */ \
	    XXX(0x75, 0x2426);	/* undefined */ \
	    UNI(0x76, 0x0192);	/* LATIN SMALL LETTER F WITH HOOK Probably chosen for its meaning of "function" */ \
	    UNI(0x77, 0x03c9);	/* GREEK SMALL LETTER OMEGA */ \
	    UNI(0x78, 0x03bE);	/* GREEK SMALL LETTER XI */ \
	    UNI(0x79, 0x03c5);	/* GREEK SMALL LETTER UPSILON */ \
	    UNI(0x7a, 0x03b6);	/* GREEK SMALL LETTER ZETA */ \
	    UNI(0x7b, 0x2190);	/* LEFTWARDS ARROW */ \
	    UNI(0x7c, 0x2191);	/* UPWARDS ARROW */ \
	    UNI(0x7d, 0x2192);	/* RIGHTWARDS ARROW */ \
	    UNI(0x7e, 0x2193);	/* DOWNWARDS ARROW */ \
	}
#else
#define map_SCS_DEC_Technical(code)	/* nothing */
#endif /* OPT_WIDE_CHARS */

/*
 * Translate an input keysym to the corresponding NRC keysym.
 */
unsigned
xtermCharSetIn(TScreen *screen, unsigned code, int charset)
{
#define MAP(to, from) case from: code = to; break

#if OPT_WIDE_CHARS
#define UNI(to, from) case from: if (screen->utf8_nrc_mode) code = to; break
#else
#define UNI(to, from) case from: break
#endif

#define XXX(to, from)		/* no defined mapping to 0..255 */

    TRACE(("CHARSET-IN GL=%s(G%d) GR=%s(G%d) SS%d\n\t%s\n",
	   visibleScsCode(screen->gsets[screen->curgl]), screen->curgl,
	   visibleScsCode(screen->gsets[screen->curgr]), screen->curgr,
	   screen->curss,
	   visibleUChar(code)));

    switch (charset) {
    case nrc_British:		/* United Kingdom set (or Latin 1)      */
	if (code == XK_sterling)
	    code = 0x23;
	code &= 0x7f;
	break;

#if OPT_XMC_GLITCH
    case nrc_Unknown:
#endif
    case nrc_DEC_Alt_Chars:
    case nrc_DEC_Alt_Graphics:
    case nrc_ASCII:
	break;

    case nrc_DEC_Spec_Graphic:
	break;

    case nrc_DEC_Supp:
	map_SCS_DEC_Supp(code, code &= 0x7f);
	break;

    case nrc_DEC_Supp_Graphic:
	map_SCS_DEC_Supp_Graphic(code, code |= 0x80);
	break;

    case nrc_DEC_Technical:
	map_SCS_DEC_Technical(code);
	break;

    case nrc_Dutch:
	map_NRCS_Dutch(code);
	break;

    case nrc_Finnish:
    case nrc_Finnish2:
	map_NRCS_Finnish(code);
	break;

    case nrc_French:
    case nrc_French2:
	map_NRCS_French(code);
	break;

    case nrc_French_Canadian:
	map_NRCS_French_Canadian(code);
	break;

    case nrc_German:
	map_NRCS_German(code);
	break;

    case nrc_Hebrew:
    case nrc_Hebrew2:
	/* FIXME */
	break;

    case nrc_Italian:
	map_NRCS_Italian(code);
	break;

    case nrc_Norwegian_Danish:
    case nrc_Norwegian_Danish2:
    case nrc_Norwegian_Danish3:
	map_NRCS_Norwegian_Danish(code);
	break;

    case nrc_Portugese:
	map_NRCS_Portuguese(code);
	break;

    case nrc_SCS_NRCS:		/* vt5xx - probably Serbo/Croatian */
	/* FIXME */
	break;

    case nrc_Spanish:
	map_NRCS_Spanish(code);
	break;

    case nrc_Swedish2:
    case nrc_Swedish:
	map_NRCS_Swedish(code);
	break;

    case nrc_Swiss:
	map_NRCS_Swiss(code);
	break;

    case nrc_Turkish:
    case nrc_Turkish2:
	/* FIXME */
	break;

    default:			/* any character sets we don't recognize */
	break;
    }
    code &= 0x7f;		/* NRC in any case is 7-bit */
    TRACE(("->\t%s\n",
	   visibleUChar(code)));
    return code;
#undef MAP
#undef UNI
#undef XXX
}

/*
 * Translate a string to the display form.  This assumes the font has the
 * DEC graphic characters in cells 0-31, and otherwise is ISO-8859-1.
 */
int
xtermCharSetOut(XtermWidget xw, IChar *buf, IChar *ptr, int leftset)
{
    IChar *s;
    TScreen *screen = TScreenOf(xw);
    int count = 0;
    int rightset = screen->gsets[(int) (screen->curgr)];

#define MAP(from, to) case from: chr = to; break

#if OPT_WIDE_CHARS
#define UNI(from, to) case from: if (screen->utf8_nrc_mode) chr = to; break
#define XXX(from, to) UNI(from, to)
#else
#define UNI(old, new) chr = old; break
#define XXX(from, to)		/* nothing */
#endif

    TRACE(("CHARSET-OUT GL=%s(G%d) GR=%s(G%d) SS%d\n\t%s\n",
	   visibleScsCode(leftset), screen->curgl,
	   visibleScsCode(rightset), screen->curgr,
	   screen->curss,
	   visibleIChars(buf, (unsigned) (ptr - buf))));

    for (s = buf; s < ptr; ++s) {
	int eight = CharOf(E2A(*s));
	int seven = eight & 0x7f;
	int cs = (eight >= 128) ? rightset : leftset;
	int chr = eight;

	count++;
#if OPT_WIDE_CHARS
	/*
	 * This is only partly right - prevent inadvertant remapping of
	 * the replacement character and other non-8bit codes into bogus
	 * 8bit codes.
	 */
	if (screen->utf8_mode || screen->utf8_nrc_mode) {
	    if (*s > 255)
		continue;
	}
#endif
	if (*s < 32)
	    continue;

	switch (cs) {
	case nrc_British_Latin_1:
	    /* FALLTHRU */
	case nrc_British:	/* United Kingdom set (or Latin 1)      */
	    if ((xw->flags & NATIONAL)
		|| (screen->vtXX_level <= 1)) {
		if ((xw->flags & NATIONAL)) {
		    chr = seven;
		}
		if (chr == 0x23) {
		    chr = XTERM_POUND;
#if OPT_WIDE_CHARS
		    if (screen->utf8_nrc_mode) {
			chr = 0xa3;
		    }
#endif
		}
	    } else {
		chr = (seven | 0x80);
	    }
	    break;

#if OPT_XMC_GLITCH
	case nrc_Unknown:
#endif
	case nrc_DEC_Alt_Chars:
	case nrc_DEC_Alt_Graphics:
	case nrc_ASCII:
	    break;

	case nrc_DEC_Spec_Graphic:
	    if (seven > 0x5f && seven <= 0x7e) {
#if OPT_WIDE_CHARS
		if (screen->utf8_mode || screen->utf8_nrc_mode)
		    chr = (int) dec2ucs((unsigned) (seven - 0x5f));
		else
#endif
		    chr = seven - 0x5f;
	    } else {
		chr = seven;
	    }
	    break;

	case nrc_DEC_Supp:
	    map_SCS_DEC_Supp(chr = seven, chr |= 0x80);
	    break;

	case nrc_DEC_Supp_Graphic:
	    map_SCS_DEC_Supp_Graphic(chr = seven, chr |= 0x80);
	    break;

	case nrc_DEC_Technical:
	    map_SCS_DEC_Technical(chr = seven);
	    break;

	case nrc_Dutch:
	    map_NRCS_Dutch(chr = seven);
	    break;

	case nrc_Finnish:
	case nrc_Finnish2:
	    map_NRCS_Finnish(chr = seven);
	    break;

	case nrc_French:
	case nrc_French2:
	    map_NRCS_French(chr = seven);
	    break;

	case nrc_French_Canadian:
	case nrc_French_Canadian2:
	    map_NRCS_French_Canadian(chr = seven);
	    break;

	case nrc_German:
	    map_NRCS_German(chr = seven);
	    break;

	case nrc_Hebrew:
	case nrc_Hebrew2:
	    /* FIXME */
	    break;

	case nrc_Italian:
	    map_NRCS_Italian(chr = seven);
	    break;

	case nrc_Norwegian_Danish:
	case nrc_Norwegian_Danish2:
	case nrc_Norwegian_Danish3:
	    map_NRCS_Norwegian_Danish(chr = seven);
	    break;

	case nrc_Portugese:
	    map_NRCS_Portuguese(chr = seven);
	    break;

	case nrc_SCS_NRCS:	/* vt5xx - probably Serbo/Croatian */
	    /* FIXME */
	    break;

	case nrc_Spanish:
	    map_NRCS_Spanish(chr = seven);
	    break;

	case nrc_Swedish2:
	case nrc_Swedish:
	    map_NRCS_Swedish(chr = seven);
	    break;

	case nrc_Swiss:
	    map_NRCS_Swiss(chr = seven);
	    break;

	case nrc_Turkish:
	case nrc_Turkish2:
	    /* FIXME */
	    break;

	default:		/* any character sets we don't recognize */
	    count--;
	    break;
	}
	/*
	 * The state machine already treated DEL as a nonprinting and
	 * nonspacing character.  If we have DEL now, simply render
	 * it as a blank.
	 */
	if (chr == ANSI_DEL)
	    chr = ' ';
	*s = (IChar) A2E(chr);
    }
    TRACE(("%d\t%s\n",
	   count,
	   visibleIChars(buf, (unsigned) (ptr - buf))));
    return count;
#undef MAP
#undef UNI
#undef XXX
}
@


1.4
log
@Update to xterm-275. Tested by jasper@@.
@
text
@d1 1
a1 1
/* $XTermId: charsets.c,v 1.42 2011/09/11 14:40:17 tom Exp $ */
d4 1
a4 1
 * Copyright 1998-2009,2011 by Thomas E. Dickey
d58 312
d374 1
a374 1
xtermCharSetIn(unsigned code, int charset)
d378 4
a381 10
    if (code >= 128 && code < 256) {
	switch (charset) {
	case 'A':		/* United Kingdom set (or Latin 1)      */
	    if (code == XK_sterling)
		code = 0x23;
	    code &= 0x7f;
	    break;

#if OPT_XMC_GLITCH
	case '?':
a382 21
	case '1':		/* Alternate Character ROM standard characters */
	case '2':		/* Alternate Character ROM special graphics */
	case 'B':		/* ASCII set                            */
	    break;

	case '0':		/* special graphics (line drawing)      */
	    break;

	case '4':		/* Dutch */
	    switch (code) {
		MAP(0x23, XK_sterling);
		MAP(0x40, XK_threequarters);
		MAP(0x5b, XK_ydiaeresis);
		MAP(0x5c, XK_onehalf);
		MAP(0x5d, XK_bar);	/* glyph is not ISO-8859-1 */
		MAP(0x7b, XK_diaeresis);
		MAP(0x7c, XK_f);	/* glyph is not ISO-8859-1 */
		MAP(0x7d, XK_onequarter);
		MAP(0x7e, XK_acute);
	    }
	    break;
d384 1
a384 14
	case 'C':
	case '5':		/* Finnish */
	    switch (code) {
		MAP(0x5b, XK_Adiaeresis);
		MAP(0x5c, XK_Odiaeresis);
		MAP(0x5d, XK_Aring);
		MAP(0x5e, XK_Udiaeresis);
		MAP(0x60, XK_eacute);
		MAP(0x7b, XK_adiaeresis);
		MAP(0x7c, XK_odiaeresis);
		MAP(0x7d, XK_aring);
		MAP(0x7e, XK_udiaeresis);
	    }
	    break;
d386 5
a390 13
	case 'R':		/* French */
	    switch (code) {
		MAP(0x23, XK_sterling);
		MAP(0x40, XK_agrave);
		MAP(0x5b, XK_degree);
		MAP(0x5c, XK_ccedilla);
		MAP(0x5d, XK_section);
		MAP(0x7b, XK_eacute);
		MAP(0x7c, XK_ugrave);
		MAP(0x7d, XK_egrave);
		MAP(0x7e, XK_diaeresis);
	    }
	    break;
d392 6
a397 14
	case 'Q':		/* French Canadian */
	    switch (code) {
		MAP(0x40, XK_agrave);
		MAP(0x5b, XK_acircumflex);
		MAP(0x5c, XK_ccedilla);
		MAP(0x5d, XK_ecircumflex);
		MAP(0x5e, XK_icircumflex);
		MAP(0x60, XK_ocircumflex);
		MAP(0x7b, XK_eacute);
		MAP(0x7c, XK_ugrave);
		MAP(0x7d, XK_egrave);
		MAP(0x7e, XK_ucircumflex);
	    }
	    break;
d399 85
a483 12
	case 'K':		/* German */
	    switch (code) {
		MAP(0x40, XK_section);
		MAP(0x5b, XK_Adiaeresis);
		MAP(0x5c, XK_Odiaeresis);
		MAP(0x5d, XK_Udiaeresis);
		MAP(0x7b, XK_adiaeresis);
		MAP(0x7c, XK_odiaeresis);
		MAP(0x7d, XK_udiaeresis);
		MAP(0x7e, XK_ssharp);
	    }
	    break;
d485 2
a486 81
	case 'Y':		/* Italian */
	    switch (code) {
		MAP(0x23, XK_sterling);
		MAP(0x40, XK_section);
		MAP(0x5b, XK_degree);
		MAP(0x5c, XK_ccedilla);
		MAP(0x5d, XK_eacute);
		MAP(0x60, XK_ugrave);
		MAP(0x7b, XK_agrave);
		MAP(0x7c, XK_ograve);
		MAP(0x7d, XK_egrave);
		MAP(0x7e, XK_igrave);
	    }
	    break;

	case 'E':
	case '6':		/* Norwegian/Danish */
	    switch (code) {
		MAP(0x40, XK_Adiaeresis);
		MAP(0x5b, XK_AE);
		MAP(0x5c, XK_Ooblique);
		MAP(0x5d, XK_Aring);
		MAP(0x5e, XK_Udiaeresis);
		MAP(0x60, XK_adiaeresis);
		MAP(0x7b, XK_ae);
		MAP(0x7c, XK_oslash);
		MAP(0x7d, XK_aring);
		MAP(0x7e, XK_udiaeresis);
	    }
	    break;

	case 'Z':		/* Spanish */
	    switch (code) {
		MAP(0x23, XK_sterling);
		MAP(0x40, XK_section);
		MAP(0x5b, XK_exclamdown);
		MAP(0x5c, XK_Ntilde);
		MAP(0x5d, XK_questiondown);
		MAP(0x7b, XK_degree);
		MAP(0x7c, XK_ntilde);
		MAP(0x7d, XK_ccedilla);
	    }
	    break;

	case 'H':
	case '7':		/* Swedish */
	    switch (code) {
		MAP(0x40, XK_Eacute);
		MAP(0x5b, XK_Adiaeresis);
		MAP(0x5c, XK_Odiaeresis);
		MAP(0x5d, XK_Aring);
		MAP(0x5e, XK_Udiaeresis);
		MAP(0x60, XK_eacute);
		MAP(0x7b, XK_adiaeresis);
		MAP(0x7c, XK_odiaeresis);
		MAP(0x7d, XK_aring);
		MAP(0x7e, XK_udiaeresis);
	    }
	    break;

	case '=':		/* Swiss */
	    switch (code) {
		MAP(0x23, XK_ugrave);
		MAP(0x40, XK_agrave);
		MAP(0x5b, XK_eacute);
		MAP(0x5c, XK_ccedilla);
		MAP(0x5d, XK_ecircumflex);
		MAP(0x5e, XK_icircumflex);
		MAP(0x5f, XK_egrave);
		MAP(0x60, XK_ocircumflex);
		MAP(0x7b, XK_adiaeresis);
		MAP(0x7c, XK_odiaeresis);
		MAP(0x7d, XK_udiaeresis);
		MAP(0x7e, XK_ucircumflex);
	    }
	    break;

	default:		/* any character sets we don't recognize */
	    break;
	}
	code &= 0x7f;		/* NRC in any case is 7-bit */
d488 3
d493 2
d502 1
a502 1
xtermCharSetOut(XtermWidget xw, IChar * buf, IChar * ptr, int leftset)
d511 11
a521 3
    TRACE(("CHARSET GL=%c(G%d) GR=%c(G%d) SS%d\n\t%s\n",
	   leftset, screen->curgl,
	   rightset, screen->curgr,
d523 1
a523 1
	   visibleIChar(buf, (unsigned) (ptr - buf))));
d538 1
a538 1
	if (screen->utf8_mode) {
d543 3
d547 3
a549 1
	case 'A':		/* United Kingdom set (or Latin 1)      */
d552 3
d556 1
d558 3
a560 5
		    chr = (screen->utf8_mode
			   ? 0xa3
			   : XTERM_POUND);
#else
		    chr = XTERM_POUND;
d569 1
a569 1
	case '?':
d571 3
a573 3
	case '1':		/* Alternate Character ROM standard characters */
	case '2':		/* Alternate Character ROM special graphics */
	case 'B':		/* ASCII set                            */
d576 1
a576 1
	case '0':		/* special graphics (line drawing)      */
d579 1
a579 1
		if (screen->utf8_mode)
d589 33
a621 12
	case '4':		/* Dutch */
	    switch (chr = seven) {
		MAP(0x23, XK_sterling);
		MAP(0x40, XK_threequarters);
		MAP(0x5b, XK_ydiaeresis);
		MAP(0x5c, XK_onehalf);
		MAP(0x5d, XK_bar);
		MAP(0x7b, XK_diaeresis);
		MAP(0x7c, XK_f);
		MAP(0x7d, XK_onequarter);
		MAP(0x7e, XK_acute);
	    }
d624 3
a626 13
	case 'C':
	case '5':		/* Finnish */
	    switch (chr = seven) {
		MAP(0x5b, XK_Adiaeresis);
		MAP(0x5c, XK_Odiaeresis);
		MAP(0x5d, XK_Aring);
		MAP(0x5e, XK_Udiaeresis);
		MAP(0x60, XK_eacute);
		MAP(0x7b, XK_adiaeresis);
		MAP(0x7c, XK_odiaeresis);
		MAP(0x7d, XK_aring);
		MAP(0x7e, XK_udiaeresis);
	    }
d629 2
a630 12
	case 'R':		/* French */
	    switch (chr = seven) {
		MAP(0x23, XK_sterling);
		MAP(0x40, XK_agrave);
		MAP(0x5b, XK_degree);
		MAP(0x5c, XK_ccedilla);
		MAP(0x5d, XK_section);
		MAP(0x7b, XK_eacute);
		MAP(0x7c, XK_ugrave);
		MAP(0x7d, XK_egrave);
		MAP(0x7e, XK_diaeresis);
	    }
d633 4
a636 13
	case 'Q':		/* French Canadian */
	    switch (chr = seven) {
		MAP(0x40, XK_agrave);
		MAP(0x5b, XK_acircumflex);
		MAP(0x5c, XK_ccedilla);
		MAP(0x5d, XK_ecircumflex);
		MAP(0x5e, XK_icircumflex);
		MAP(0x60, XK_ocircumflex);
		MAP(0x7b, XK_eacute);
		MAP(0x7c, XK_ugrave);
		MAP(0x7d, XK_egrave);
		MAP(0x7e, XK_ucircumflex);
	    }
d639 2
a640 11
	case 'K':		/* German */
	    switch (chr = seven) {
		MAP(0x40, XK_section);
		MAP(0x5b, XK_Adiaeresis);
		MAP(0x5c, XK_Odiaeresis);
		MAP(0x5d, XK_Udiaeresis);
		MAP(0x7b, XK_adiaeresis);
		MAP(0x7c, XK_odiaeresis);
		MAP(0x7d, XK_udiaeresis);
		MAP(0x7e, XK_ssharp);
	    }
d643 2
a644 13
	case 'Y':		/* Italian */
	    switch (chr = seven) {
		MAP(0x23, XK_sterling);
		MAP(0x40, XK_section);
		MAP(0x5b, XK_degree);
		MAP(0x5c, XK_ccedilla);
		MAP(0x5d, XK_eacute);
		MAP(0x60, XK_ugrave);
		MAP(0x7b, XK_agrave);
		MAP(0x7c, XK_ograve);
		MAP(0x7d, XK_egrave);
		MAP(0x7e, XK_igrave);
	    }
d647 2
a648 14
	case 'E':
	case '6':		/* Norwegian/Danish */
	    switch (chr = seven) {
		MAP(0x40, XK_Adiaeresis);
		MAP(0x5b, XK_AE);
		MAP(0x5c, XK_Ooblique);
		MAP(0x5d, XK_Aring);
		MAP(0x5e, XK_Udiaeresis);
		MAP(0x60, XK_adiaeresis);
		MAP(0x7b, XK_ae);
		MAP(0x7c, XK_oslash);
		MAP(0x7d, XK_aring);
		MAP(0x7e, XK_udiaeresis);
	    }
d651 3
a653 11
	case 'Z':		/* Spanish */
	    switch (chr = seven) {
		MAP(0x23, XK_sterling);
		MAP(0x40, XK_section);
		MAP(0x5b, XK_exclamdown);
		MAP(0x5c, XK_Ntilde);
		MAP(0x5d, XK_questiondown);
		MAP(0x7b, XK_degree);
		MAP(0x7c, XK_ntilde);
		MAP(0x7d, XK_ccedilla);
	    }
d656 2
a657 14
	case 'H':
	case '7':		/* Swedish */
	    switch (chr = seven) {
		MAP(0x40, XK_Eacute);
		MAP(0x5b, XK_Adiaeresis);
		MAP(0x5c, XK_Odiaeresis);
		MAP(0x5d, XK_Aring);
		MAP(0x5e, XK_Udiaeresis);
		MAP(0x60, XK_eacute);
		MAP(0x7b, XK_adiaeresis);
		MAP(0x7c, XK_odiaeresis);
		MAP(0x7d, XK_aring);
		MAP(0x7e, XK_udiaeresis);
	    }
d660 3
a662 15
	case '=':		/* Swiss */
	    switch (chr = seven) {
		MAP(0x23, XK_ugrave);
		MAP(0x40, XK_agrave);
		MAP(0x5b, XK_eacute);
		MAP(0x5c, XK_ccedilla);
		MAP(0x5d, XK_ecircumflex);
		MAP(0x5e, XK_icircumflex);
		MAP(0x5f, XK_egrave);
		MAP(0x60, XK_ocircumflex);
		MAP(0x7b, XK_adiaeresis);
		MAP(0x7c, XK_odiaeresis);
		MAP(0x7d, XK_udiaeresis);
		MAP(0x7e, XK_ucircumflex);
	    }
d680 1
a680 1
	   visibleIChar(buf, (unsigned) (ptr - buf))));
d683 2
@


1.3
log
@Update to xterm 242. Tested by jsg@@.
@
text
@d1 1
a1 1
/* $XTermId: charsets.c,v 1.41 2009/01/25 23:39:12 tom Exp $ */
d3 30
a32 31
/************************************************************

Copyright 1998-2008,2009 by Thomas E. Dickey

                        All Rights Reserved

Permission is hereby granted, free of charge, to any person obtaining a
copy of this software and associated documentation files (the
"Software"), to deal in the Software without restriction, including
without limitation the rights to use, copy, modify, merge, publish,
distribute, sublicense, and/or sell copies of the Software, and to
permit persons to whom the Software is furnished to do so, subject to
the following conditions:

The above copyright notice and this permission notice shall be included
in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. 
IN NO EVENT SHALL THE ABOVE LISTED COPYRIGHT HOLDER(S) BE LIABLE FOR ANY
CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

Except as contained in this notice, the name(s) of the above copyright
holders shall not be used in advertising or otherwise to promote the
sale, use or other dealings in this Software without prior written
authorization.

********************************************************/
@


1.2
log
@xterm-236. Tested by form@@ and simon@@.
@
text
@d1 1
a1 1
/* $XTermId: charsets.c,v 1.40 2008/05/26 22:49:57 tom Exp $ */
d5 1
a5 1
Copyright 1998-2007,2008 by Thomas E. Dickey
d311 1
a311 1
		    chr = dec2ucs((unsigned) (seven - 0x5f));
d479 1
a479 1
	*s = A2E(chr);
@


1.1
log
@Initial revision
@
text
@d1 1
a1 5
/* $XTermId: charsets.c,v 1.33 2006/07/02 17:28:50 tom Exp $ */

/*
 * $XFree86: xc/programs/xterm/charsets.c,v 1.12 2005/01/14 01:50:02 dickey Exp $
 */
d5 1
a5 1
Copyright 1998-2005,2006 by Thomas E. Dickey
d62 2
a63 1
unsigned xtermCharSetIn(unsigned code, int charset)
d65 9
a73 7
	if (code >= 128 && code < 256) {
		switch (charset) {
		case 'A':	/* United Kingdom set (or Latin 1)	*/
			if (code == XK_sterling)
				code = 0x23;
			code &= 0x7f;
			break;
d76 1
a76 1
		case '?':
d78 155
a232 155
		case '1':	/* Alternate Character ROM standard characters */
		case '2':	/* Alternate Character ROM special graphics */
		case 'B':	/* ASCII set				*/
			break;

		case '0':	/* special graphics (line drawing)	*/
			break;

		case '4':	/* Dutch */
			switch (code) {
			case XK_sterling:	code = 0x23;	break;
			case XK_threequarters:	code = 0x40;	break;
			case XK_ydiaeresis:	code = 0x5b;	break;
			case XK_onehalf:	code = 0x5c;	break;
	/* N/A		case XK_bar:		code = 0x5d;	break; */
			case XK_diaeresis:	code = 0x7b;	break;
	/* N/A		case XK_f:		code = 0x7c;	break; */
			case XK_onequarter:	code = 0x7d;	break;
			case XK_acute:		code = 0x7e;	break;
			}
			break;

		case 'C':
		case '5':	/* Finnish */
			switch (code) {
			case XK_Adiaeresis:	code = 0x5b;	break;
			case XK_Odiaeresis:	code = 0x5c;	break;
			case XK_Aring:		code = 0x5d;	break;
			case XK_Udiaeresis:	code = 0x5e;	break;
			case XK_eacute:		code = 0x60;	break;
			case XK_adiaeresis:	code = 0x7b;	break;
			case XK_odiaeresis:	code = 0x7c;	break;
			case XK_aring:		code = 0x7d;	break;
			case XK_udiaeresis:	code = 0x7e;	break;
			}
			break;

		case 'R':	/* French */
			switch (code) {
			case XK_sterling:	code = 0x23;	break;
			case XK_agrave:		code = 0x40;	break;
			case XK_degree:		code = 0x5b;	break;
			case XK_ccedilla:	code = 0x5c;	break;
			case XK_section:	code = 0x5d;	break;
			case XK_eacute:		code = 0x7b;	break;
			case XK_ugrave:		code = 0x7c;	break;
			case XK_egrave:		code = 0x7d;	break;
			case XK_diaeresis:	code = 0x7e;	break;
			}
			break;

		case 'Q':	/* French Canadian */
			switch (code) {
			case XK_agrave:		code = 0x40;	break;
			case XK_acircumflex:	code = 0x5b;	break;
			case XK_ccedilla:	code = 0x5c;	break;
			case XK_ecircumflex:	code = 0x5d;	break;
			case XK_icircumflex:	code = 0x5e;	break;
			case XK_ocircumflex:	code = 0x60;	break;
			case XK_eacute:		code = 0x7b;	break;
			case XK_ugrave:		code = 0x7c;	break;
			case XK_egrave:		code = 0x7d;	break;
			case XK_ucircumflex:	code = 0x7e;	break;
			}
			break;

		case 'K':	/* German */
			switch (code) {
			case XK_section:	code = 0x40;	break;
			case XK_Adiaeresis:	code = 0x5b;	break;
			case XK_Odiaeresis:	code = 0x5c;	break;
			case XK_Udiaeresis:	code = 0x5d;	break;
			case XK_adiaeresis:	code = 0x7b;	break;
			case XK_odiaeresis:	code = 0x7c;	break;
			case XK_udiaeresis:	code = 0x7d;	break;
			case XK_ssharp:		code = 0x7e;	break;
			}
			break;

		case 'Y':	/* Italian */
			switch (code) {
			case XK_sterling:	code = 0x23;	break;
			case XK_section:	code = 0x40;	break;
			case XK_degree:		code = 0x5b;	break;
			case XK_ccedilla:	code = 0x5c;	break;
			case XK_eacute:		code = 0x5d;	break;
			case XK_ugrave:		code = 0x60;	break;
			case XK_agrave:		code = 0x7b;	break;
			case XK_ograve:		code = 0x7c;	break;
			case XK_egrave:		code = 0x7d;	break;
			case XK_igrave:		code = 0x7e;	break;
			}
			break;

		case 'E':
		case '6':	/* Norwegian/Danish */
			switch (code) {
			case XK_Adiaeresis:	code = 0x40;	break;
			case XK_AE:		code = 0x5b;	break;
			case XK_Ooblique:	code = 0x5c;	break;
			case XK_Aring:		code = 0x5d;	break;
			case XK_Udiaeresis:	code = 0x5e;	break;
			case XK_adiaeresis:	code = 0x60;	break;
			case XK_ae:		code = 0x7b;	break;
			case XK_oslash:		code = 0x7c;	break;
			case XK_aring:		code = 0x7d;	break;
			case XK_udiaeresis:	code = 0x7e;	break;
			}
			break;

		case 'Z':	/* Spanish */
			switch (code) {
			case XK_sterling:	code = 0x23;	break;
			case XK_section:	code = 0x40;	break;
			case XK_exclamdown:	code = 0x5b;	break;
			case XK_Ntilde:		code = 0x5c;	break;
			case XK_questiondown:	code = 0x5d;	break;
			case XK_degree:		code = 0x7b;	break;
			case XK_ntilde:		code = 0x7c;	break;
			case XK_ccedilla:	code = 0x7d;	break;
			}
			break;

		case 'H':
		case '7':	/* Swedish */
			switch (code) {
			case XK_Eacute:		code = 0x40;	break;
			case XK_Adiaeresis:	code = 0x5b;	break;
			case XK_Odiaeresis:	code = 0x5c;	break;
			case XK_Aring:		code = 0x5d;	break;
			case XK_Udiaeresis:	code = 0x5e;	break;
			case XK_eacute:		code = 0x60;	break;
			case XK_adiaeresis:	code = 0x7b;	break;
			case XK_odiaeresis:	code = 0x7c;	break;
			case XK_aring:		code = 0x7d;	break;
			case XK_udiaeresis:	code = 0x7e;	break;
			}
			break;

		case '=':	/* Swiss */
			switch (code) {
			case XK_ugrave:		code = 0x23;	break;
			case XK_agrave:		code = 0x40;	break;
			case XK_eacute:		code = 0x5b;	break;
			case XK_ccedilla:	code = 0x5c;	break;
			case XK_ecircumflex:	code = 0x5d;	break;
			case XK_icircumflex:	code = 0x5e;	break;
			case XK_egrave:		code = 0x5f;	break;
			case XK_ocircumflex:	code = 0x60;	break;
			case XK_adiaeresis:	code = 0x7b;	break;
			case XK_odiaeresis:	code = 0x7c;	break;
			case XK_udiaeresis:	code = 0x7d;	break;
			case XK_ucircumflex:	code = 0x7e;	break;
			}
			break;
d234 2
a235 4
		default:	/* any character sets we don't recognize*/
			break;
		}
		code &= 0x7f;	/* NRC in any case is 7-bit */
d237 4
a240 1
	return code;
d247 2
a248 1
int xtermCharSetOut(IChar *buf, IChar *ptr, int leftset)
d250 48
a297 28
	IChar *s;
	register TScreen *screen = &term->screen;
	int count = 0;
	int rightset = screen->gsets[(int)(screen->curgr)];

	TRACE(("CHARSET GL=%c(G%d) GR=%c(G%d) SS%d:%s\n",
		leftset,  screen->curgl,
		rightset, screen->curgr,
		screen->curss,
		visibleIChar(buf, (unsigned)(ptr - buf))));

	for (s = buf; s < ptr; ++s) {
		int eight = CharOf(E2A(*s));
		int seven = eight & 0x7f;
		int cs = (eight >= 128) ? rightset : leftset;
		int chr = eight;

		count++;
		switch (cs) {
		case 'A':	/* United Kingdom set (or Latin 1)	*/
			if ((term->flags & NATIONAL)
			 || (screen->vtXX_level <= 1)) {
				if (chr == 0x23)
					chr = XPOUND;	/* UK pound sign*/
			} else {
				chr = (seven | 0x80);
			}
			break;
d300 1
a300 1
		case '?':
d302 4
a305 4
		case '1':	/* Alternate Character ROM standard characters */
		case '2':	/* Alternate Character ROM special graphics */
		case 'B':	/* ASCII set				*/
			break;
d307 2
a308 2
		case '0':	/* special graphics (line drawing)	*/
			if (seven > 0x5f && seven <= 0x7e) {
d310 3
a312 3
			    if (screen->utf8_mode)
				chr = dec2ucs((unsigned)(seven - 0x5f));
			    else
d314 157
a470 166
				chr = seven - 0x5f;
			} else {
			    chr = seven;
			}
			break;

		case '4':	/* Dutch */
			switch (chr = seven) {
			case 0x23:	chr = XK_sterling;	break;
			case 0x40:	chr = XK_threequarters;	break;
			case 0x5b:	chr = XK_ydiaeresis;	break;
			case 0x5c:	chr = XK_onehalf;	break;
			case 0x5d:	chr = XK_bar;		break;
			case 0x7b:	chr = XK_diaeresis;	break;
			case 0x7c:	chr = XK_f;		break;
			case 0x7d:	chr = XK_onequarter;	break;
			case 0x7e:	chr = XK_acute;		break;
			}
			break;

		case 'C':
		case '5':	/* Finnish */
			switch (chr = seven) {
			case 0x5b:	chr = XK_Adiaeresis;	break;
			case 0x5c:	chr = XK_Odiaeresis;	break;
			case 0x5d:	chr = XK_Aring;		break;
			case 0x5e:	chr = XK_Udiaeresis;	break;
			case 0x60:	chr = XK_eacute;	break;
			case 0x7b:	chr = XK_adiaeresis;	break;
			case 0x7c:	chr = XK_odiaeresis;	break;
			case 0x7d:	chr = XK_aring;		break;
			case 0x7e:	chr = XK_udiaeresis;	break;
			}
			break;

		case 'R':	/* French */
			switch (chr = seven) {
			case 0x23:	chr = XK_sterling;	break;
			case 0x40:	chr = XK_agrave;	break;
			case 0x5b:	chr = XK_degree;	break;
			case 0x5c:	chr = XK_ccedilla;	break;
			case 0x5d:	chr = XK_section;	break;
			case 0x7b:	chr = XK_eacute;	break;
			case 0x7c:	chr = XK_ugrave;	break;
			case 0x7d:	chr = XK_egrave;	break;
			case 0x7e:	chr = XK_diaeresis;	break;
			}
			break;

		case 'Q':	/* French Canadian */
			switch (chr = seven) {
			case 0x40:	chr = XK_agrave;	break;
			case 0x5b:	chr = XK_acircumflex;	break;
			case 0x5c:	chr = XK_ccedilla;	break;
			case 0x5d:	chr = XK_ecircumflex;	break;
			case 0x5e:	chr = XK_icircumflex;	break;
			case 0x60:	chr = XK_ocircumflex;	break;
			case 0x7b:	chr = XK_eacute;	break;
			case 0x7c:	chr = XK_ugrave;	break;
			case 0x7d:	chr = XK_egrave;	break;
			case 0x7e:	chr = XK_ucircumflex;	break;
			}
			break;

		case 'K':	/* German */
			switch (chr = seven) {
			case 0x40:	chr = XK_section;	break;
			case 0x5b:	chr = XK_Adiaeresis;	break;
			case 0x5c:	chr = XK_Odiaeresis;	break;
			case 0x5d:	chr = XK_Udiaeresis;	break;
			case 0x7b:	chr = XK_adiaeresis;	break;
			case 0x7c:	chr = XK_odiaeresis;	break;
			case 0x7d:	chr = XK_udiaeresis;	break;
			case 0x7e:	chr = XK_ssharp;	break;
			}
			break;

		case 'Y':	/* Italian */
			switch (chr = seven) {
			case 0x23:	chr = XK_sterling;	break;
			case 0x40:	chr = XK_section;	break;
			case 0x5b:	chr = XK_degree;	break;
			case 0x5c:	chr = XK_ccedilla;	break;
			case 0x5d:	chr = XK_eacute;	break;
			case 0x60:	chr = XK_ugrave;	break;
			case 0x7b:	chr = XK_agrave;	break;
			case 0x7c:	chr = XK_ograve;	break;
			case 0x7d:	chr = XK_egrave;	break;
			case 0x7e:	chr = XK_igrave;	break;
			}
			break;

		case 'E':
		case '6':	/* Norwegian/Danish */
			switch (chr = seven) {
			case 0x40:	chr = XK_Adiaeresis;	break;
			case 0x5b:	chr = XK_AE;		break;
			case 0x5c:	chr = XK_Ooblique;	break;
			case 0x5d:	chr = XK_Aring;		break;
			case 0x5e:	chr = XK_Udiaeresis;	break;
			case 0x60:	chr = XK_adiaeresis;	break;
			case 0x7b:	chr = XK_ae;		break;
			case 0x7c:	chr = XK_oslash;	break;
			case 0x7d:	chr = XK_aring;		break;
			case 0x7e:	chr = XK_udiaeresis;	break;
			}
			break;

		case 'Z':	/* Spanish */
			switch (chr = seven) {
			case 0x23:	chr = XK_sterling;	break;
			case 0x40:	chr = XK_section;	break;
			case 0x5b:	chr = XK_exclamdown;	break;
			case 0x5c:	chr = XK_Ntilde;	break;
			case 0x5d:	chr = XK_questiondown;	break;
			case 0x7b:	chr = XK_degree;	break;
			case 0x7c:	chr = XK_ntilde;	break;
			case 0x7d:	chr = XK_ccedilla;	break;
			}
			break;

		case 'H':
		case '7':	/* Swedish */
			switch (chr = seven) {
			case 0x40:	chr = XK_Eacute;	break;
			case 0x5b:	chr = XK_Adiaeresis;	break;
			case 0x5c:	chr = XK_Odiaeresis;	break;
			case 0x5d:	chr = XK_Aring;		break;
			case 0x5e:	chr = XK_Udiaeresis;	break;
			case 0x60:	chr = XK_eacute;	break;
			case 0x7b:	chr = XK_adiaeresis;	break;
			case 0x7c:	chr = XK_odiaeresis;	break;
			case 0x7d:	chr = XK_aring;		break;
			case 0x7e:	chr = XK_udiaeresis;	break;
			}
			break;

		case '=':	/* Swiss */
			switch (chr = seven) {
			case 0x23:	chr = XK_ugrave;	break;
			case 0x40:	chr = XK_agrave;	break;
			case 0x5b:	chr = XK_eacute;	break;
			case 0x5c:	chr = XK_ccedilla;	break;
			case 0x5d:	chr = XK_ecircumflex;	break;
			case 0x5e:	chr = XK_icircumflex;	break;
			case 0x5f:	chr = XK_egrave;	break;
			case 0x60:	chr = XK_ocircumflex;	break;
			case 0x7b:	chr = XK_adiaeresis;	break;
			case 0x7c:	chr = XK_odiaeresis;	break;
			case 0x7d:	chr = XK_udiaeresis;	break;
			case 0x7e:	chr = XK_ucircumflex;	break;
			}
			break;

		default:	/* any character sets we don't recognize*/
			count --;
			break;
		}
		/*
		 * The state machine already treated DEL as a nonprinting and
		 * nonspacing character.  If we have DEL now, simply render
		 * it as a blank.
		 */
		if (chr == DEL)
		    chr = ' ';
		*s = A2E(chr);
d472 14
a485 1
	return count;
@


1.1.1.1
log
@Importing xterm 216
@
text
@@


1.1.1.2
log
@import xterm 225
@
text
@d1 1
a1 1
/* $XTermId: charsets.c,v 1.36 2007/03/19 23:47:00 tom Exp $ */
d9 1
a9 1
Copyright 1998-2006,2007 by Thomas E. Dickey
d250 1
a250 1
	register TScreen *screen = TScreenOf(term);
d271 2
a272 3
				if (chr == 0x23) {
					chr = XTERM_POUND;	/* UK pound sign*/
				}
d456 1
a456 1
		if (chr == ANSI_DEL)
@

