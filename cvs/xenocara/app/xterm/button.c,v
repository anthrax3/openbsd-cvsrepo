head	1.35;
access;
symbols
	OPENBSD_6_1:1.35.0.2
	OPENBSD_6_1_BASE:1.35
	OPENBSD_6_0:1.34.0.4
	OPENBSD_6_0_BASE:1.34
	OPENBSD_5_9:1.34.0.2
	OPENBSD_5_9_BASE:1.34
	OPENBSD_5_8:1.32.0.4
	OPENBSD_5_8_BASE:1.32
	OPENBSD_5_7:1.32.0.2
	OPENBSD_5_7_BASE:1.32
	OPENBSD_5_6:1.28.0.2
	OPENBSD_5_6_BASE:1.28
	OPENBSD_5_5:1.26.0.2
	OPENBSD_5_5_BASE:1.26
	OPENBSD_5_4:1.24.0.2
	OPENBSD_5_4_BASE:1.24
	OPENBSD_5_3:1.22.0.2
	OPENBSD_5_3_BASE:1.22
	OPENBSD_5_2:1.21.0.2
	OPENBSD_5_2_BASE:1.21
	OPENBSD_5_1_BASE:1.19
	OPENBSD_5_1:1.19.0.2
	OPENBSD_5_0:1.17.0.2
	OPENBSD_5_0_BASE:1.17
	OPENBSD_4_9:1.16.0.2
	OPENBSD_4_9_BASE:1.16
	OPENBSD_4_8:1.12.0.4
	OPENBSD_4_8_BASE:1.12
	OPENBSD_4_7:1.10.0.2
	OPENBSD_4_7_BASE:1.10
	OPENBSD_4_6:1.7.0.2
	OPENBSD_4_6_BASE:1.7
	OPENBSD_4_5:1.5.0.2
	OPENBSD_4_5_BASE:1.5
	OPENBSD_4_4:1.2.0.2
	OPENBSD_4_4_BASE:1.2
	OPENBSD_4_3_BASE:1.1.1.4
	OPENBSD_4_3:1.1.1.4.0.2
	v232:1.1.1.4
	v229:1.1.1.3
	OPENBSD_4_2:1.1.1.2.0.2
	OPENBSD_4_2_BASE:1.1.1.2
	v225:1.1.1.2
	v216:1.1.1.1
	xterm:1.1.1;
locks; strict;
comment	@ * @;


1.35
date	2016.08.07.21.27.36;	author matthieu;	state Exp;
branches;
next	1.34;
commitid	psxxjI5z4Vpv2LL4;

1.34
date	2016.01.13.20.40.08;	author matthieu;	state Exp;
branches;
next	1.33;
commitid	by9Wu4LDAgU65dBU;

1.33
date	2015.09.05.14.11.45;	author matthieu;	state Exp;
branches;
next	1.32;
commitid	YVUODLQ4QcYTuGkb;

1.32
date	2015.01.18.20.24.39;	author matthieu;	state Exp;
branches;
next	1.31;
commitid	PDdlFuihcMifzxwp;

1.31
date	2014.12.18.20.16.55;	author matthieu;	state Exp;
branches;
next	1.30;
commitid	pCMhkpVdt9Oe52hU;

1.30
date	2014.11.02.10.29.03;	author matthieu;	state Exp;
branches;
next	1.29;
commitid	j3MNODFiitGCbwUd;

1.29
date	2014.10.05.16.39.19;	author matthieu;	state Exp;
branches;
next	1.28;
commitid	0wVJ6bWh03LWbUdn;

1.28
date	2014.07.14.08.30.10;	author matthieu;	state Exp;
branches;
next	1.27;
commitid	EnwNNUjlkdrocnMa;

1.27
date	2014.05.09.19.56.40;	author matthieu;	state Exp;
branches;
next	1.26;

1.26
date	2014.01.02.15.14.50;	author matthieu;	state Exp;
branches;
next	1.25;

1.25
date	2013.08.26.20.06.10;	author matthieu;	state Exp;
branches;
next	1.24;

1.24
date	2013.06.02.19.55.50;	author matthieu;	state Exp;
branches;
next	1.23;

1.23
date	2013.03.09.14.45.38;	author matthieu;	state Exp;
branches;
next	1.22;

1.22
date	2013.01.04.16.40.18;	author matthieu;	state Exp;
branches;
next	1.21;

1.21
date	2012.06.07.20.20.23;	author matthieu;	state Exp;
branches;
next	1.20;

1.20
date	2012.04.14.09.02.46;	author matthieu;	state Exp;
branches;
next	1.19;

1.19
date	2011.08.28.17.40.55;	author matthieu;	state Exp;
branches;
next	1.18;

1.18
date	2011.08.18.19.47.42;	author matthieu;	state Exp;
branches;
next	1.17;

1.17
date	2011.03.07.20.41.27;	author matthieu;	state Exp;
branches;
next	1.16;

1.16
date	2010.11.29.20.10.09;	author matthieu;	state Exp;
branches;
next	1.15;

1.15
date	2010.10.23.19.14.52;	author matthieu;	state Exp;
branches;
next	1.14;

1.14
date	2010.10.05.19.37.23;	author matthieu;	state Exp;
branches;
next	1.13;

1.13
date	2010.08.22.13.38.11;	author matthieu;	state Exp;
branches;
next	1.12;

1.12
date	2010.05.08.12.20.46;	author matthieu;	state Exp;
branches;
next	1.11;

1.11
date	2010.03.25.22.03.51;	author matthieu;	state Exp;
branches;
next	1.10;

1.10
date	2009.10.31.14.11.57;	author matthieu;	state Exp;
branches;
next	1.9;

1.9
date	2009.09.19.00.03.36;	author sthen;	state Exp;
branches;
next	1.8;

1.8
date	2009.09.05.15.58.09;	author matthieu;	state Exp;
branches;
next	1.7;

1.7
date	2009.04.04.15.10.44;	author matthieu;	state Exp;
branches;
next	1.6;

1.6
date	2009.03.09.22.13.04;	author matthieu;	state Exp;
branches;
next	1.5;

1.5
date	2009.01.10.18.08.42;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2009.01.06.20.10.20;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2008.08.25.18.05.57;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2008.03.19.21.15.46;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.26.11.11.20;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.11.26.11.11.20;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2007.06.15.19.30.04;	author matthieu;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2007.08.25.18.53.37;	author matthieu;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2008.02.16.09.34.45;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.35
log
@Update to xterm-325. Testing by krw@@, shadchin@@ and naddy@@. Thanks
@
text
@/* $XTermId: button.c,v 1.505 2016/05/30 19:42:44 tom Exp $ */

/*
 * Copyright 1999-2015,2016 by Thomas E. Dickey
 *
 *                         All Rights Reserved
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 *
 * The above copyright notice and this permission notice shall be included
 * in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
 * IN NO EVENT SHALL THE ABOVE LISTED COPYRIGHT HOLDER(S) BE LIABLE FOR ANY
 * CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
 * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
 * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 *
 * Except as contained in this notice, the name(s) of the above copyright
 * holders shall not be used in advertising or otherwise to promote the
 * sale, use or other dealings in this Software without prior written
 * authorization.
 *
 *
 * Copyright 1987 by Digital Equipment Corporation, Maynard, Massachusetts.
 *
 *                         All Rights Reserved
 *
 * Permission to use, copy, modify, and distribute this software and its
 * documentation for any purpose and without fee is hereby granted,
 * provided that the above copyright notice appear in all copies and that
 * both that copyright notice and this permission notice appear in
 * supporting documentation, and that the name of Digital Equipment
 * Corporation not be used in advertising or publicity pertaining to
 * distribution of the software without specific, written prior permission.
 *
 *
 * DIGITAL DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING
 * ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL
 * DIGITAL BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR
 * ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
 * WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
 * ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
 * SOFTWARE.
 */

/*
button.c	Handles button events in the terminal emulator.
		does cut/paste operations, change modes via menu,
		passes button events through to some applications.
				J. Gettys.
*/

#include <xterm.h>

#include <stdio.h>
#include <ctype.h>
#include <assert.h>

#include <X11/Xatom.h>
#include <X11/Xmu/Atoms.h>
#include <X11/Xmu/StdSel.h>

#include <xutf8.h>
#include <fontutils.h>

#include <data.h>
#include <error.h>
#include <menu.h>
#include <charclass.h>
#include <xstrings.h>

#if OPT_SELECT_REGEX
#ifdef HAVE_PCREPOSIX_H
#include <pcreposix.h>
#else /* POSIX regex.h */
#include <sys/types.h>
#include <regex.h>
#endif
#endif

#if OPT_WIDE_CHARS
#include <ctype.h>
#include <wcwidth.h>
#else
#define CharacterClass(value) \
	charClass[value & ((sizeof(charClass)/sizeof(charClass[0]))-1)]
#endif

    /*
     * We'll generally map rows to indices when doing selection.
     * Simplify that with a macro.
     *
     * Note that ROW2INX() is safe to use with auto increment/decrement for
     * the row expression since that is evaluated once.
     */
#define GET_LINEDATA(screen, row) \
	getLineData(screen, ROW2INX(screen, row))

    /*
     * We reserve shift modifier for cut/paste operations.  In principle we
     * can pass through control and meta modifiers, but in practice, the
     * popup menu uses control, and the window manager is likely to use meta,
     * so those events are not delivered to SendMousePosition.
     */
#define OurModifiers (ShiftMask | ControlMask | Mod1Mask)
#define AllModifiers (ShiftMask | LockMask | ControlMask | Mod1Mask | \
		      Mod2Mask | Mod3Mask | Mod4Mask | Mod5Mask)

#define BtnModifiers(event) (event->state & OurModifiers)
#define KeyModifiers(event) (event->xbutton.state & OurModifiers)

#define IsBtnEvent(event) ((event)->type == ButtonPress || (event)->type == ButtonRelease)
#define IsKeyEvent(event) ((event)->type == KeyPress    || (event)->type == KeyRelease)

#define KeyState(x) (((int) ((x) & (ShiftMask|ControlMask))) \
			  + (((x) & Mod1Mask) ? 2 : 0))
    /* adds together the bits:
       shift key -> 1
       meta key  -> 2
       control key -> 4 */

#define	Coordinate(s,c)	((c)->row * MaxCols(s) + (c)->col)

static const CELL zeroCELL =
{0, 0};

#if OPT_DEC_LOCATOR
static Bool SendLocatorPosition(XtermWidget xw, XButtonEvent *event);
static void CheckLocatorPosition(XtermWidget xw, XButtonEvent *event);
#endif /* OPT_DEC_LOCATOR */

/* Multi-click handling */
#if OPT_READLINE
static Time lastButtonDownTime = 0;
static int ExtendingSelection = 0;
static Time lastButton3UpTime = 0;
static Time lastButton3DoubleDownTime = 0;
static CELL lastButton3;	/* At the release time */
#endif /* OPT_READLINE */

static Char *SaveText(TScreen *screen, int row, int scol, int ecol,
		      Char *lp, int *eol);
static int Length(TScreen *screen, int row, int scol, int ecol);
static void ComputeSelect(XtermWidget xw, CELL *startc, CELL *endc, Bool extend);
static void EditorButton(XtermWidget xw, XButtonEvent *event);
static void EndExtend(XtermWidget w, XEvent *event, String *params, Cardinal
		      num_params, Bool use_cursor_loc);
static void ExtendExtend(XtermWidget xw, const CELL *cell);
static void PointToCELL(TScreen *screen, int y, int x, CELL *cell);
static void ReHiliteText(XtermWidget xw, CELL *first, CELL *last);
static void SaltTextAway(XtermWidget xw, CELL *cellc, CELL *cell);
static void SelectSet(XtermWidget xw, XEvent *event, String *params, Cardinal num_params);
static void SelectionReceived PROTO_XT_SEL_CB_ARGS;
static void StartSelect(XtermWidget xw, const CELL *cell);
static void TrackDown(XtermWidget xw, XButtonEvent *event);
static void TrackText(XtermWidget xw, const CELL *first, const CELL *last);
static void _OwnSelection(XtermWidget xw, String *selections, Cardinal count);
static void do_select_end(XtermWidget xw, XEvent *event, String *params,
			  Cardinal *num_params, Bool use_cursor_loc);

#define MOUSE_LIMIT (255 - 32)

/* Send SET_EXT_SIZE_MOUSE to enable offsets up to EXT_MOUSE_LIMIT */
#define EXT_MOUSE_LIMIT (2047 - 32)
#define EXT_MOUSE_START (127 - 32)

static int
MouseLimit(TScreen *screen)
{
    int mouse_limit;

    switch (screen->extend_coords) {
    default:
	mouse_limit = MOUSE_LIMIT;
	break;
    case SET_EXT_MODE_MOUSE:
	mouse_limit = EXT_MOUSE_LIMIT;
	break;
    case SET_SGR_EXT_MODE_MOUSE:
    case SET_URXVT_EXT_MODE_MOUSE:
	mouse_limit = -1;
	break;
    }
    return mouse_limit;
}

static unsigned
EmitMousePosition(TScreen *screen, Char line[], unsigned count, int value)
{
    int mouse_limit = MouseLimit(screen);

    /*
     * Add pointer position to key sequence
     *
     * In extended mode we encode large positions as two-byte UTF-8.
     *
     * NOTE: historically, it was possible to emit 256, which became
     * zero by truncation to 8 bits. While this was arguably a bug,
     * it's also somewhat useful as a past-end marker. We preserve
     * this behavior for both normal and extended mouse modes.
     */
    switch (screen->extend_coords) {
    default:
	if (value == mouse_limit) {
	    line[count++] = CharOf(0);
	} else {
	    line[count++] = CharOf(' ' + value + 1);
	}
	break;
    case SET_EXT_MODE_MOUSE:
	if (value == mouse_limit) {
	    line[count++] = CharOf(0);
	} else if (value < EXT_MOUSE_START) {
	    line[count++] = CharOf(' ' + value + 1);
	} else {
	    value += ' ' + 1;
	    line[count++] = CharOf(0xC0 + (value >> 6));
	    line[count++] = CharOf(0x80 + (value & 0x3F));
	}
	break;
    case SET_SGR_EXT_MODE_MOUSE:
	/* FALLTHRU */
    case SET_URXVT_EXT_MODE_MOUSE:
	count += (unsigned) sprintf((char *) line + count, "%d", value + 1);
	break;
    }
    return count;
}

static unsigned
EmitMousePositionSeparator(TScreen *screen, Char line[], unsigned count)
{
    switch (screen->extend_coords) {
    case SET_SGR_EXT_MODE_MOUSE:
    case SET_URXVT_EXT_MODE_MOUSE:
	line[count++] = ';';
	break;
    }
    return count;
}

Bool
SendMousePosition(XtermWidget xw, XEvent *event)
{
    TScreen *screen = TScreenOf(xw);
    XButtonEvent *my_event = (XButtonEvent *) event;
    Bool result = False;

    switch (screen->send_mouse_pos) {
    case MOUSE_OFF:
	/* If send_mouse_pos mode isn't on, we shouldn't be here */
	break;

    case BTN_EVENT_MOUSE:
    case ANY_EVENT_MOUSE:
	if (KeyModifiers(event) == 0 || KeyModifiers(event) == ControlMask) {
	    /* xterm extension for motion reporting. June 1998 */
	    /* EditorButton() will distinguish between the modes */
	    switch (event->type) {
	    case MotionNotify:
		my_event->button = 0;
		/* FALLTHRU */
	    case ButtonPress:
		/* FALLTHRU */
	    case ButtonRelease:
		EditorButton(xw, my_event);
		result = True;
		break;
	    }
	}
	break;

    default:
	/* Make sure the event is an appropriate type */
	if (IsBtnEvent(event)) {
	    switch (screen->send_mouse_pos) {
	    case X10_MOUSE:	/* X10 compatibility sequences */

		if (BtnModifiers(my_event) == 0) {
		    if (my_event->type == ButtonPress)
			EditorButton(xw, my_event);
		    result = True;
		}
		break;

	    case VT200_HIGHLIGHT_MOUSE:	/* DEC vt200 hilite tracking */
		if (my_event->type == ButtonPress &&
		    BtnModifiers(my_event) == 0 &&
		    my_event->button == Button1) {
		    TrackDown(xw, my_event);
		    result = True;
		} else if (BtnModifiers(my_event) == 0
			   || BtnModifiers(my_event) == ControlMask) {
		    EditorButton(xw, my_event);
		    result = True;
		}
		break;

	    case VT200_MOUSE:	/* DEC vt200 compatible */
		if (BtnModifiers(my_event) == 0
		    || BtnModifiers(my_event) == ControlMask) {
		    EditorButton(xw, my_event);
		    result = True;
		}
		break;

#if OPT_DEC_LOCATOR
	    case DEC_LOCATOR:
		result = SendLocatorPosition(xw, my_event);
		break;
#endif /* OPT_DEC_LOCATOR */
	    }
	}
    }
    return result;
}

#if OPT_DEC_LOCATOR

#define	LocatorCoords( row, col, x, y, oor )			\
    if( screen->locator_pixels ) {				\
	(oor)=False; (row) = (y)+1; (col) = (x)+1;		\
	/* Limit to screen dimensions */			\
	if ((row) < 1) (row) = 1,(oor)=True;			\
	else if ((row) > screen->border*2+Height(screen))	\
	    (row) = screen->border*2+Height(screen),(oor)=True;	\
	if ((col) < 1) (col) = 1,(oor)=True;			\
	else if ((col) > OriginX(screen)*2+Width(screen))	\
	    (col) = OriginX(screen)*2+Width(screen),(oor)=True;	\
    } else {							\
	(oor)=False;						\
	/* Compute character position of mouse pointer */	\
	(row) = ((y) - screen->border) / FontHeight(screen);	\
	(col) = ((x) - OriginX(screen)) / FontWidth(screen);	\
	/* Limit to screen dimensions */			\
	if ((row) < 0) (row) = 0,(oor)=True;			\
	else if ((row) > screen->max_row)			\
	    (row) = screen->max_row,(oor)=True;			\
	if ((col) < 0) (col) = 0,(oor)=True;			\
	else if ((col) > screen->max_col)			\
	    (col) = screen->max_col,(oor)=True;			\
	(row)++; (col)++;					\
    }

static Bool
SendLocatorPosition(XtermWidget xw, XButtonEvent *event)
{
    ANSI reply;
    TScreen *screen = TScreenOf(xw);
    int row, col;
    Bool oor;
    int button;
    unsigned state;

    /* Make sure the event is an appropriate type */
    if ((!IsBtnEvent(event) &&
	 !screen->loc_filter) ||
	(BtnModifiers(event) != 0 && BtnModifiers(event) != ControlMask))
	return (False);

    if ((event->type == ButtonPress &&
	 !(screen->locator_events & LOC_BTNS_DN)) ||
	(event->type == ButtonRelease &&
	 !(screen->locator_events & LOC_BTNS_UP)))
	return (True);

    if (event->type == MotionNotify) {
	CheckLocatorPosition(xw, event);
	return (True);
    }

    /* get button # */
    button = (int) event->button - 1;

    LocatorCoords(row, col, event->x, event->y, oor);

    /*
     * DECterm mouse:
     *
     * ESCAPE '[' event ; mask ; row ; column '&' 'w'
     */
    memset(&reply, 0, sizeof(reply));
    reply.a_type = ANSI_CSI;

    if (oor) {
	reply.a_nparam = 1;
	reply.a_param[0] = 0;	/* Event - 0 = locator unavailable */
	reply.a_inters = '&';
	reply.a_final = 'w';
	unparseseq(xw, &reply);

	if (screen->locator_reset) {
	    MotionOff(screen, xw);
	    screen->send_mouse_pos = MOUSE_OFF;
	}
	return (True);
    }

    /*
     * event:
     *        1       no buttons
     *        2       left button down
     *        3       left button up
     *        4       middle button down
     *        5       middle button up
     *        6       right button down
     *        7       right button up
     *        8       M4 down
     *        9       M4 up
     */
    reply.a_nparam = 4;
    switch (event->type) {
    case ButtonPress:
	reply.a_param[0] = (ParmType) (2 + (button << 1));
	break;
    case ButtonRelease:
	reply.a_param[0] = (ParmType) (3 + (button << 1));
	break;
    default:
	return (True);
    }
    /*
     * mask:
     * bit 7   bit 6   bit 5   bit 4   bit 3   bit 2       bit 1         bit 0
     *                                 M4 down left down   middle down   right down
     *
     * Notice that Button1 (left) and Button3 (right) are swapped in the mask.
     * Also, mask should be the state after the button press/release,
     * X provides the state not including the button press/release.
     */
    state = (event->state
	     & (Button1Mask | Button2Mask | Button3Mask | Button4Mask)) >> 8;
    /* update mask to "after" state */
    state ^= ((unsigned) (1 << button));
    /* swap Button1 & Button3 */
    state = ((state & (unsigned) ~(4 | 1))
	     | ((state & 1) ? 4 : 0)
	     | ((state & 4) ? 1 : 0));

    reply.a_param[1] = (ParmType) state;
    reply.a_param[2] = (ParmType) row;
    reply.a_param[3] = (ParmType) col;
    reply.a_inters = '&';
    reply.a_final = 'w';

    unparseseq(xw, &reply);

    if (screen->locator_reset) {
	MotionOff(screen, xw);
	screen->send_mouse_pos = MOUSE_OFF;
    }

    /*
     * DECterm turns the Locator off if a button is pressed while a filter rectangle
     * is active. This might be a bug, but I don't know, so I'll emulate it anyways.
     */
    if (screen->loc_filter) {
	screen->send_mouse_pos = MOUSE_OFF;
	screen->loc_filter = False;
	screen->locator_events = 0;
	MotionOff(screen, xw);
    }

    return (True);
}

/*
 * mask:
 * bit 7   bit 6   bit 5   bit 4   bit 3   bit 2       bit 1         bit 0
 *                                 M4 down left down   middle down   right down
 *
 * Button1 (left) and Button3 (right) are swapped in the mask relative to X.
 */
#define	ButtonState(state, mask)	\
{ (state) = (int) (((mask) & (Button1Mask | Button2Mask | Button3Mask | Button4Mask)) >> 8);	\
  /* swap Button1 & Button3 */								\
  (state) = ((state) & ~(4|1)) | (((state)&1)?4:0) | (((state)&4)?1:0);			\
}

void
GetLocatorPosition(XtermWidget xw)
{
    ANSI reply;
    TScreen *screen = TScreenOf(xw);
    Window root, child;
    int rx, ry, x, y;
    unsigned int mask;
    int row = 0, col = 0;
    Bool oor = False;
    Bool ret = False;
    int state;

    /*
     * DECterm turns the Locator off if the position is requested while a filter rectangle
     * is active.  This might be a bug, but I don't know, so I'll emulate it anyways.
     */
    if (screen->loc_filter) {
	screen->send_mouse_pos = MOUSE_OFF;
	screen->loc_filter = False;
	screen->locator_events = 0;
	MotionOff(screen, xw);
    }

    memset(&reply, 0, sizeof(reply));
    reply.a_type = ANSI_CSI;

    if (screen->send_mouse_pos == DEC_LOCATOR) {
	ret = XQueryPointer(screen->display, VWindow(screen), &root,
			    &child, &rx, &ry, &x, &y, &mask);
	if (ret) {
	    LocatorCoords(row, col, x, y, oor);
	}
    }
    if (ret == False || oor) {
	reply.a_nparam = 1;
	reply.a_param[0] = 0;	/* Event - 0 = locator unavailable */
	reply.a_inters = '&';
	reply.a_final = 'w';
	unparseseq(xw, &reply);

	if (screen->locator_reset) {
	    MotionOff(screen, xw);
	    screen->send_mouse_pos = MOUSE_OFF;
	}
	return;
    }

    ButtonState(state, mask);

    reply.a_nparam = 4;
    reply.a_param[0] = 1;	/* Event - 1 = response to locator request */
    reply.a_param[1] = (ParmType) state;
    reply.a_param[2] = (ParmType) row;
    reply.a_param[3] = (ParmType) col;
    reply.a_inters = '&';
    reply.a_final = 'w';
    unparseseq(xw, &reply);

    if (screen->locator_reset) {
	MotionOff(screen, xw);
	screen->send_mouse_pos = MOUSE_OFF;
    }
}

void
InitLocatorFilter(XtermWidget xw)
{
    ANSI reply;
    TScreen *screen = TScreenOf(xw);
    Window root, child;
    int rx, ry, x, y;
    unsigned int mask;
    int row = 0, col = 0;
    Bool oor = 0;
    Bool ret;

    ret = XQueryPointer(screen->display, VWindow(screen),
			&root, &child, &rx, &ry, &x, &y, &mask);
    if (ret) {
	LocatorCoords(row, col, x, y, oor);
    }
    if (ret == False || oor) {
	/* Locator is unavailable */

	if (screen->loc_filter_top != LOC_FILTER_POS ||
	    screen->loc_filter_left != LOC_FILTER_POS ||
	    screen->loc_filter_bottom != LOC_FILTER_POS ||
	    screen->loc_filter_right != LOC_FILTER_POS) {
	    /*
	     * If any explicit coordinates were received,
	     * report immediately with no coordinates.
	     */
	    memset(&reply, 0, sizeof(reply));
	    reply.a_type = ANSI_CSI;
	    reply.a_nparam = 1;
	    reply.a_param[0] = 0;	/* Event - 0 = locator unavailable */
	    reply.a_inters = '&';
	    reply.a_final = 'w';
	    unparseseq(xw, &reply);

	    if (screen->locator_reset) {
		MotionOff(screen, xw);
		screen->send_mouse_pos = MOUSE_OFF;
	    }
	} else {
	    /*
	     * No explicit coordinates were received, and the pointer is
	     * unavailable.  Report when the pointer re-enters the window.
	     */
	    screen->loc_filter = True;
	    MotionOn(screen, xw);
	}
	return;
    }

    /*
     * Adjust rectangle coordinates:
     *  1. Replace "LOC_FILTER_POS" with current coordinates
     *  2. Limit coordinates to screen size
     *  3. make sure top and left are less than bottom and right, resp.
     */
    if (screen->locator_pixels) {
	rx = OriginX(screen) * 2 + Width(screen);
	ry = screen->border * 2 + Height(screen);
    } else {
	rx = screen->max_col;
	ry = screen->max_row;
    }

#define	Adjust( coord, def, max )				\
	if( (coord) == LOC_FILTER_POS )	(coord) = (def);	\
	else if ((coord) < 1)		(coord) = 1;		\
	else if ((coord) > (max))	(coord) = (max)

    Adjust(screen->loc_filter_top, row, ry);
    Adjust(screen->loc_filter_left, col, rx);
    Adjust(screen->loc_filter_bottom, row, ry);
    Adjust(screen->loc_filter_right, col, rx);

    if (screen->loc_filter_top > screen->loc_filter_bottom) {
	ry = screen->loc_filter_top;
	screen->loc_filter_top = screen->loc_filter_bottom;
	screen->loc_filter_bottom = ry;
    }

    if (screen->loc_filter_left > screen->loc_filter_right) {
	rx = screen->loc_filter_left;
	screen->loc_filter_left = screen->loc_filter_right;
	screen->loc_filter_right = rx;
    }

    if ((col < screen->loc_filter_left) ||
	(col > screen->loc_filter_right) ||
	(row < screen->loc_filter_top) ||
	(row > screen->loc_filter_bottom)) {
	int state;

	/* Pointer is already outside the rectangle - report immediately */
	ButtonState(state, mask);

	memset(&reply, 0, sizeof(reply));
	reply.a_type = ANSI_CSI;
	reply.a_nparam = 4;
	reply.a_param[0] = 10;	/* Event - 10 = locator outside filter */
	reply.a_param[1] = (ParmType) state;
	reply.a_param[2] = (ParmType) row;
	reply.a_param[3] = (ParmType) col;
	reply.a_inters = '&';
	reply.a_final = 'w';
	unparseseq(xw, &reply);

	if (screen->locator_reset) {
	    MotionOff(screen, xw);
	    screen->send_mouse_pos = MOUSE_OFF;
	}
	return;
    }

    /*
     * Rectangle is set up.  Allow pointer tracking
     * to detect if the mouse leaves the rectangle.
     */
    screen->loc_filter = True;
    MotionOn(screen, xw);
}

static void
CheckLocatorPosition(XtermWidget xw, XButtonEvent *event)
{
    ANSI reply;
    TScreen *screen = TScreenOf(xw);
    int row, col;
    Bool oor;

    LocatorCoords(row, col, event->x, event->y, oor);

    /*
     * Send report if the pointer left the filter rectangle, if
     * the pointer left the window, or if the filter rectangle
     * had no coordinates and the pointer re-entered the window.
     */
    if (oor || (screen->loc_filter_top == LOC_FILTER_POS) ||
	(col < screen->loc_filter_left) ||
	(col > screen->loc_filter_right) ||
	(row < screen->loc_filter_top) ||
	(row > screen->loc_filter_bottom)) {
	/* Filter triggered - disable it */
	screen->loc_filter = False;
	MotionOff(screen, xw);

	memset(&reply, 0, sizeof(reply));
	reply.a_type = ANSI_CSI;
	if (oor) {
	    reply.a_nparam = 1;
	    reply.a_param[0] = 0;	/* Event - 0 = locator unavailable */
	} else {
	    int state;

	    ButtonState(state, event->state);

	    reply.a_nparam = 4;
	    reply.a_param[0] = 10;	/* Event - 10 = locator outside filter */
	    reply.a_param[1] = (ParmType) state;
	    reply.a_param[2] = (ParmType) row;
	    reply.a_param[3] = (ParmType) col;
	}

	reply.a_inters = '&';
	reply.a_final = 'w';
	unparseseq(xw, &reply);

	if (screen->locator_reset) {
	    MotionOff(screen, xw);
	    screen->send_mouse_pos = MOUSE_OFF;
	}
    }
}
#endif /* OPT_DEC_LOCATOR */

#if OPT_READLINE
static int
isClick1_clean(TScreen *screen, XButtonEvent *event)
{
    int delta;

    if (!IsBtnEvent(event)
    /* Disable on Shift-Click-1, including the application-mouse modes */
	|| (BtnModifiers(event) & ShiftMask)
	|| (screen->send_mouse_pos != MOUSE_OFF)	/* Kinda duplicate... */
	||ExtendingSelection)	/* Was moved */
	return 0;

    if (event->type != ButtonRelease)
	return 0;

    if (lastButtonDownTime == (Time) 0) {
	/* first time or once in a blue moon */
	delta = screen->multiClickTime + 1;
    } else if (event->time > lastButtonDownTime) {
	/* most of the time */
	delta = (int) (event->time - lastButtonDownTime);
    } else {
	/* time has rolled over since lastButtonUpTime */
	delta = (int) ((((Time) ~ 0) - lastButtonDownTime) + event->time);
    }

    return delta <= screen->multiClickTime;
}

static int
isDoubleClick3(TScreen *screen, XButtonEvent *event)
{
    int delta;

    if (event->type != ButtonRelease
	|| (BtnModifiers(event) & ShiftMask)
	|| event->button != Button3) {
	lastButton3UpTime = 0;	/* Disable the cached info */
	return 0;
    }
    /* Process Btn3Release. */
    if (lastButton3DoubleDownTime == (Time) 0) {
	/* No previous click or once in a blue moon */
	delta = screen->multiClickTime + 1;
    } else if (event->time > lastButton3DoubleDownTime) {
	/* most of the time */
	delta = (int) (event->time - lastButton3DoubleDownTime);
    } else {
	/* time has rolled over since lastButton3DoubleDownTime */
	delta = (int) ((((Time) ~ 0) - lastButton3DoubleDownTime) + event->time);
    }
    if (delta <= screen->multiClickTime) {
	/* Double click */
	CELL cell;

	/* Cannot check ExtendingSelection, since mouse-3 always sets it */
	PointToCELL(screen, event->y, event->x, &cell);
	if (isSameCELL(&cell, &lastButton3)) {
	    lastButton3DoubleDownTime = 0;	/* Disable the third click */
	    return 1;
	}
    }
    /* Not a double click, memorize for future check. */
    lastButton3UpTime = event->time;
    PointToCELL(screen, event->y, event->x, &lastButton3);
    return 0;
}

static int
CheckSecondPress3(TScreen *screen, XEvent *event)
{
    int delta;

    if (event->type != ButtonPress
	|| (KeyModifiers(event) & ShiftMask)
	|| event->xbutton.button != Button3) {
	lastButton3DoubleDownTime = 0;	/* Disable the cached info */
	return 0;
    }
    /* Process Btn3Press. */
    if (lastButton3UpTime == (Time) 0) {
	/* No previous click or once in a blue moon */
	delta = screen->multiClickTime + 1;
    } else if (event->xbutton.time > lastButton3UpTime) {
	/* most of the time */
	delta = (int) (event->xbutton.time - lastButton3UpTime);
    } else {
	/* time has rolled over since lastButton3UpTime */
	delta = (int) ((((Time) ~ 0) - lastButton3UpTime) + event->xbutton.time);
    }
    if (delta <= screen->multiClickTime) {
	CELL cell;

	PointToCELL(screen, event->xbutton.y, event->xbutton.x, &cell);
	if (isSameCELL(&cell, &lastButton3)) {
	    /* A candidate for a double-click */
	    lastButton3DoubleDownTime = event->xbutton.time;
	    PointToCELL(screen, event->xbutton.y, event->xbutton.x, &lastButton3);
	    return 1;
	}
	lastButton3UpTime = 0;	/* Disable the info about the previous click */
    }
    /* Either too long, or moved, disable. */
    lastButton3DoubleDownTime = 0;
    return 0;
}

static int
rowOnCurrentLine(TScreen *screen,
		 int line,
		 int *deltap)	/* must be XButtonEvent */
{
    int result = 1;

    *deltap = 0;

    if (line != screen->cur_row) {
	int l1, l2;

	if (line < screen->cur_row)
	    l1 = line, l2 = screen->cur_row;
	else
	    l2 = line, l1 = screen->cur_row;
	l1--;
	while (++l1 < l2) {
	    LineData *ld = GET_LINEDATA(screen, l1);
	    if (!LineTstWrapped(ld)) {
		result = 0;
		break;
	    }
	}
	if (result) {
	    /* Everything is on one "wrapped line" now */
	    *deltap = line - screen->cur_row;
	}
    }
    return result;
}

static int
eventRow(TScreen *screen, XEvent *event)	/* must be XButtonEvent */
{
    return (event->xbutton.y - screen->border) / FontHeight(screen);
}

static int
eventColBetween(TScreen *screen, XEvent *event)		/* must be XButtonEvent */
{
    /* Correct by half a width - we are acting on a boundary, not on a cell. */
    return ((event->xbutton.x - OriginX(screen) + (FontWidth(screen) - 1) / 2)
	    / FontWidth(screen));
}

static int
ReadLineMovePoint(TScreen *screen, int col, int ldelta)
{
    Char line[6];
    unsigned count = 0;

    col += ldelta * MaxCols(screen) - screen->cur_col;
    if (col == 0)
	return 0;
    if (screen->control_eight_bits) {
	line[count++] = ANSI_CSI;
    } else {
	line[count++] = ANSI_ESC;
	line[count++] = '[';	/* XXX maybe sometimes O is better? */
    }
    line[count] = CharOf(col > 0 ? 'C' : 'D');
    if (col < 0)
	col = -col;
    while (col--)
	v_write(screen->respond, line, 3);
    return 1;
}

static int
ReadLineDelete(TScreen *screen, CELL *cell1, CELL *cell2)
{
    int del;

    del = (cell2->col - cell1->col) + ((cell2->row - cell1->row) * MaxCols(screen));
    if (del <= 0)		/* Just in case... */
	return 0;
    while (del--)
	v_write(screen->respond, (const Char *) "\177", 1);
    return 1;
}

static void
readlineExtend(TScreen *screen, XEvent *event)
{
    int ldelta1, ldelta2;

    if (IsBtnEvent(event)) {
	XButtonEvent *my_event = (XButtonEvent *) event;
	if (isClick1_clean(screen, my_event)
	    && SCREEN_FLAG(screen, click1_moves)
	    && rowOnCurrentLine(screen, eventRow(screen, event), &ldelta1)) {
	    ReadLineMovePoint(screen, eventColBetween(screen, event), ldelta1);
	}
	if (isDoubleClick3(screen, my_event)
	    && SCREEN_FLAG(screen, dclick3_deletes)
	    && rowOnCurrentLine(screen, screen->startSel.row, &ldelta1)
	    && rowOnCurrentLine(screen, screen->endSel.row, &ldelta2)) {
	    ReadLineMovePoint(screen, screen->endSel.col, ldelta2);
	    ReadLineDelete(screen, &screen->startSel, &(screen->endSel));
	}
    }
}

#endif /* OPT_READLINE */

/* ^XM-G<line+' '><col+' '> */
void
DiredButton(Widget w,
	    XEvent *event,	/* must be XButtonEvent */
	    String *params GCC_UNUSED,	/* selections */
	    Cardinal *num_params GCC_UNUSED)
{
    XtermWidget xw;

    if ((xw = getXtermWidget(w)) != 0) {
	TScreen *screen = TScreenOf(xw);

	if (IsBtnEvent(event)
	    && (event->xbutton.y >= screen->border)
	    && (event->xbutton.x >= OriginX(screen))) {
	    Char Line[6];
	    unsigned line, col;

	    line = (unsigned) ((event->xbutton.y - screen->border)
			       / FontHeight(screen));
	    col = (unsigned) ((event->xbutton.x - OriginX(screen))
			      / FontWidth(screen));
	    Line[0] = CONTROL('X');
	    Line[1] = ANSI_ESC;
	    Line[2] = 'G';
	    Line[3] = CharOf(' ' + col);
	    Line[4] = CharOf(' ' + line);
	    v_write(screen->respond, Line, 5);
	}
    }
}

#if OPT_READLINE
void
ReadLineButton(Widget w,
	       XEvent *event,	/* must be XButtonEvent */
	       String *params GCC_UNUSED,	/* selections */
	       Cardinal *num_params GCC_UNUSED)
{
    XtermWidget xw;

    if ((xw = getXtermWidget(w)) != 0) {
	TScreen *screen = TScreenOf(xw);
	Char Line[6];
	int line, col, ldelta = 0;

	if (!IsBtnEvent(event)
	    || (screen->send_mouse_pos != MOUSE_OFF) || ExtendingSelection)
	    goto finish;
	if (event->type == ButtonRelease) {
	    int delta;

	    if (lastButtonDownTime == (Time) 0) {
		/* first time and once in a blue moon */
		delta = screen->multiClickTime + 1;
	    } else if (event->xbutton.time > lastButtonDownTime) {
		/* most of the time */
		delta = (int) (event->xbutton.time - lastButtonDownTime);
	    } else {
		/* time has rolled over since lastButtonUpTime */
		delta = (int) ((((Time) ~ 0) - lastButtonDownTime) + event->xbutton.time);
	    }
	    if (delta > screen->multiClickTime)
		goto finish;	/* All this work for this... */
	}
	line = (event->xbutton.y - screen->border) / FontHeight(screen);
	if (!rowOnCurrentLine(screen, line, &ldelta))
	    goto finish;
	/* Correct by half a width - we are acting on a boundary, not on a cell. */
	col = (event->xbutton.x - OriginX(screen) + (FontWidth(screen) - 1)
	       / 2)
	    / FontWidth(screen) - screen->cur_col + ldelta * MaxCols(screen);
	if (col == 0)
	    goto finish;
	Line[0] = ANSI_ESC;
	/* XXX: sometimes it is better to send '['? */
	Line[1] = 'O';
	Line[2] = CharOf(col > 0 ? 'C' : 'D');
	if (col < 0)
	    col = -col;
	while (col--)
	    v_write(screen->respond, Line, 3);
      finish:
	if (event->type == ButtonRelease)
	    do_select_end(xw, event, params, num_params, False);
    }
}
#endif /* OPT_READLINE */

/* repeats <ESC>n or <ESC>p */
void
ViButton(Widget w,
	 XEvent *event,		/* must be XButtonEvent */
	 String *params GCC_UNUSED,	/* selections */
	 Cardinal *num_params GCC_UNUSED)
{
    XtermWidget xw;

    if ((xw = getXtermWidget(w)) != 0) {
	TScreen *screen = TScreenOf(xw);
	int pty = screen->respond;

	if (IsBtnEvent(event)) {
	    int line;

	    line = screen->cur_row -
		((event->xbutton.y - screen->border) / FontHeight(screen));

	    if (line != 0) {
		Char Line[6];

		Line[0] = ANSI_ESC;	/* force an exit from insert-mode */
		v_write(pty, Line, 1);

		if (line < 0) {
		    line = -line;
		    Line[0] = CONTROL('n');
		} else {
		    Line[0] = CONTROL('p');
		}
		while (--line >= 0)
		    v_write(pty, Line, 1);
	    }
	}
    }
}

/*
 * This function handles button-motion events
 */
/*ARGSUSED*/
void
HandleSelectExtend(Widget w,
		   XEvent *event,	/* must be XMotionEvent */
		   String *params GCC_UNUSED,
		   Cardinal *num_params GCC_UNUSED)
{
    XtermWidget xw;

    if ((xw = getXtermWidget(w)) != 0) {
	TScreen *screen = TScreenOf(xw);
	CELL cell;

	TRACE(("HandleSelectExtend @@%ld\n", event->xmotion.time));

	screen->selection_time = event->xmotion.time;
	switch (screen->eventMode) {
	    /* If not in one of the DEC mouse-reporting modes */
	case LEFTEXTENSION:
	case RIGHTEXTENSION:
	    PointToCELL(screen, event->xmotion.y, event->xmotion.x, &cell);
	    ExtendExtend(xw, &cell);
	    break;

	    /* If in motion reporting mode, send mouse position to
	       character process as a key sequence \E[M... */
	case NORMAL:
	    /* will get here if send_mouse_pos != MOUSE_OFF */
	    if (screen->send_mouse_pos == BTN_EVENT_MOUSE
		|| screen->send_mouse_pos == ANY_EVENT_MOUSE) {
		(void) SendMousePosition(xw, event);
	    }
	    break;
	}
    }
}

void
HandleKeyboardSelectExtend(Widget w,
			   XEvent *event GCC_UNUSED,	/* must be XButtonEvent */
			   String *params GCC_UNUSED,
			   Cardinal *num_params GCC_UNUSED)
{
    XtermWidget xw;

    if ((xw = getXtermWidget(w)) != 0) {
	TScreen *screen = TScreenOf(xw);

	TRACE(("HandleKeyboardSelectExtend\n"));
	ExtendExtend(xw, &screen->cursorp);
    }
}

static void
do_select_end(XtermWidget xw,
	      XEvent *event,	/* must be XButtonEvent */
	      String *params,	/* selections */
	      Cardinal *num_params,
	      Bool use_cursor_loc)
{
    TScreen *screen = TScreenOf(xw);

    screen->selection_time = event->xbutton.time;
    TRACE(("do_select_end @@%ld\n", screen->selection_time));
    switch (screen->eventMode) {
    case NORMAL:
	(void) SendMousePosition(xw, event);
	break;
    case LEFTEXTENSION:
    case RIGHTEXTENSION:
	EndExtend(xw, event, params, *num_params, use_cursor_loc);
#if OPT_READLINE
	readlineExtend(screen, event);
#endif /* OPT_READLINE */
	break;
    }
}

void
HandleSelectEnd(Widget w,
		XEvent *event,	/* must be XButtonEvent */
		String *params,	/* selections */
		Cardinal *num_params)
{
    XtermWidget xw;

    if ((xw = getXtermWidget(w)) != 0) {
	TRACE(("HandleSelectEnd\n"));
	do_select_end(xw, event, params, num_params, False);
    }
}

void
HandleKeyboardSelectEnd(Widget w,
			XEvent *event,	/* must be XButtonEvent */
			String *params,		/* selections */
			Cardinal *num_params)
{
    XtermWidget xw;

    if ((xw = getXtermWidget(w)) != 0) {
	TRACE(("HandleKeyboardSelectEnd\n"));
	do_select_end(xw, event, params, num_params, True);
    }
}

/*
 * Copy the selection data to the given target(s).
 */
void
HandleCopySelection(Widget w,
		    XEvent *event,
		    String *params,	/* list of targets */
		    Cardinal *num_params)
{
    XtermWidget xw;

    if ((xw = getXtermWidget(w)) != 0) {
	TRACE(("HandleCopySelection\n"));
	SelectSet(xw, event, params, *num_params);
    }
}

struct _SelectionList {
    String *params;
    Cardinal count;
    Atom *targets;
    Time time;
};

static unsigned
DECtoASCII(unsigned ch)
{
    if (xtermIsDecGraphic(ch)) {
	ch = CharOf("###########+++++##-##++++|######"[ch]);
	/*           01234567890123456789012345678901 */
    }
    return ch;
}

#if OPT_WIDE_CHARS
static Cardinal
addXtermChar(Char **buffer, Cardinal *used, Cardinal offset, unsigned value)
{
    if (offset + 1 >= *used) {
	*used = 1 + (2 * (offset + 1));
	allocXtermChars(buffer, *used);
    }
    (*buffer)[offset++] = (Char) value;
    return offset;
}
#define AddChar(buffer, used, offset, value) \
	offset = addXtermChar(buffer, used, offset, (unsigned) value)

/*
 * Convert a UTF-8 string to Latin-1, replacing non Latin-1 characters by `#',
 * or ASCII/Latin-1 equivalents for special cases.
 */
static Char *
UTF8toLatin1(TScreen *screen, Char *s, unsigned long len, unsigned long *result)
{
    static Char *buffer;
    static Cardinal used;

    Cardinal offset = 0;

    if (len != 0) {
	PtyData data;

	fakePtyData(&data, s, s + len);
	while (decodeUtf8(screen, &data)) {
	    Bool fails = False;
	    Bool extra = False;
	    IChar value = skipPtyData(&data);
	    if (value == UCS_REPL) {
		fails = True;
	    } else if (value < 256) {
		AddChar(&buffer, &used, offset, CharOf(value));
	    } else {
		unsigned eqv = ucs2dec(value);
		if (xtermIsDecGraphic(eqv)) {
		    AddChar(&buffer, &used, offset, DECtoASCII(eqv));
		} else {
		    eqv = AsciiEquivs(value);
		    if (eqv == value) {
			fails = True;
		    } else {
			AddChar(&buffer, &used, offset, eqv);
		    }
		    if (isWide((wchar_t) value))
			extra = True;
		}
	    }

	    /*
	     * If we're not able to plug in a single-byte result, insert the
	     * defaultString (which normally is a single "#", but could be
	     * whatever the user wants).
	     */
	    if (fails) {
		const Char *p;

		for (p = (const Char *) screen->default_string; *p != '\0'; ++p) {
		    AddChar(&buffer, &used, offset, *p);
		}
	    }
	    if (extra)
		AddChar(&buffer, &used, offset, ' ');
	}
	AddChar(&buffer, &used, offset, '\0');
	*result = (unsigned long) (offset - 1);
    } else {
	*result = 0;
    }
    return buffer;
}

int
xtermUtf8ToTextList(XtermWidget xw,
		    XTextProperty * text_prop,
		    char ***text_list,
		    int *text_list_count)
{
    TScreen *screen = TScreenOf(xw);
    Display *dpy = screen->display;
    int rc = -1;

    if (text_prop->format == 8
	&& (rc = Xutf8TextPropertyToTextList(dpy, text_prop,
					     text_list,
					     text_list_count)) >= 0) {
	if (*text_list != NULL && *text_list_count != 0) {
	    int i;
	    Char *data;
	    char **new_text_list, *tmp;
	    unsigned long size, new_size;

	    TRACE(("xtermUtf8ToTextList size %d\n", *text_list_count));

	    /*
	     * XLib StringList actually uses only two pointers, one for the
	     * list itself, and one for the data.  Pointer to the data is the
	     * first element of the list, the rest (if any) list elements point
	     * to the same memory block as the first element
	     */
	    new_size = 0;
	    for (i = 0; i < *text_list_count; ++i) {
		data = (Char *) (*text_list)[i];
		size = strlen((*text_list)[i]) + 1;
		(void) UTF8toLatin1(screen, data, size, &size);
		new_size += size + 1;
	    }
	    new_text_list = TypeXtMallocN(char *, *text_list_count);
	    new_text_list[0] = tmp = XtMalloc((Cardinal) new_size);
	    for (i = 0; i < (*text_list_count); ++i) {
		data = (Char *) (*text_list)[i];
		size = strlen((*text_list)[i]) + 1;
		if ((data = UTF8toLatin1(screen, data, size, &size)) != 0) {
		    memcpy(tmp, data, size + 1);
		    new_text_list[i] = tmp;
		    tmp += size + 1;
		}
	    }
	    XFreeStringList((*text_list));
	    *text_list = new_text_list;
	} else {
	    rc = -1;
	}
    }
    return rc;
}
#endif /* OPT_WIDE_CHARS */

static char *
parseItem(char *value, char *nextc)
{
    char *nextp = value;
    while (*nextp != '\0' && *nextp != ',') {
	*nextp = x_toupper(*nextp);
	++nextp;
    }
    *nextc = *nextp;
    *nextp = '\0';

    return nextp;
}

/*
 * All of the wanted strings are unique in the first character, so we can
 * use simple abbreviations.
 */
static Bool
sameItem(const char *actual, const char *wanted)
{
    Bool result = False;
    size_t have = strlen(actual);
    size_t need = strlen(wanted);

    if (have != 0 && have <= need) {
	if (!strncmp(actual, wanted, have)) {
	    TRACE(("...matched \"%s\"\n", wanted));
	    result = True;
	}
    }

    return result;
}

/*
 * Handle the eightBitSelectTypes or utf8SelectTypes resource values.
 */
static Bool
overrideTargets(Widget w, String value, Atom **resultp)
{
    Bool override = False;
    XtermWidget xw;

    if ((xw = getXtermWidget(w)) != 0) {
	TScreen *screen = TScreenOf(xw);

	if (!IsEmpty(value)) {
	    char *copied = x_strdup(value);
	    if (copied != 0) {
		Atom *result = 0;
		Cardinal count = 1;
		int n;

		TRACE(("decoding SelectTypes \"%s\"\n", value));
		for (n = 0; copied[n] != '\0'; ++n) {
		    if (copied[n] == ',')
			++count;
		}
		result = TypeXtMallocN(Atom, (2 * count) + 1);
		if (result == NULL) {
		    TRACE(("Couldn't allocate selection types\n"));
		} else {
		    char nextc = '?';
		    char *listp = (char *) copied;
		    count = 0;
		    do {
			char *nextp = parseItem(listp, &nextc);
			char *item = x_strtrim(listp);
			size_t len = (item ? strlen(item) : 0);

			if (len == 0) {
			    /* EMPTY */ ;
			}
#if OPT_WIDE_CHARS
			else if (sameItem(item, "UTF8")) {
			    result[count++] = XA_UTF8_STRING(XtDisplay(w));
			}
#endif
			else if (sameItem(item, "I18N")) {
			    if (screen->i18nSelections) {
				result[count++] = XA_TEXT(XtDisplay(w));
				result[count++] = XA_COMPOUND_TEXT(XtDisplay(w));
			    }
			} else if (sameItem(item, "TEXT")) {
			    result[count++] = XA_TEXT(XtDisplay(w));
			} else if (sameItem(item, "COMPOUND_TEXT")) {
			    result[count++] = XA_COMPOUND_TEXT(XtDisplay(w));
			} else if (sameItem(item, "STRING")) {
			    result[count++] = XA_STRING;
			}
			*nextp++ = nextc;
			listp = nextp;
			free(item);
		    } while (nextc != '\0');
		    if (count) {
			result[count] = None;
			override = True;
			*resultp = result;
		    } else {
			XtFree((char *) result);
		    }
		}
		free(copied);
	    } else {
		TRACE(("Couldn't allocate copy of selection types\n"));
	    }
	}
    }
    return override;
}

#if OPT_WIDE_CHARS
static Atom *
allocUtf8Targets(Widget w, TScreen *screen)
{
    Atom **resultp = &(screen->selection_targets_utf8);

    if (*resultp == 0) {
	Atom *result;

	if (!overrideTargets(w, screen->utf8_select_types, &result)) {
	    result = TypeXtMallocN(Atom, 5);
	    if (result == NULL) {
		TRACE(("Couldn't allocate utf-8 selection targets\n"));
	    } else {
		int n = 0;

		if (XSupportsLocale()) {
		    result[n++] = XA_UTF8_STRING(XtDisplay(w));
#ifdef X_HAVE_UTF8_STRING
		    if (screen->i18nSelections) {
			result[n++] = XA_TEXT(XtDisplay(w));
			result[n++] = XA_COMPOUND_TEXT(XtDisplay(w));
		    }
#endif
		}
		result[n++] = XA_STRING;
		result[n] = None;
	    }
	}

	*resultp = result;
    }

    return *resultp;
}
#endif

static Atom *
alloc8bitTargets(Widget w, TScreen *screen)
{
    Atom **resultp = &(screen->selection_targets_8bit);

    if (*resultp == 0) {
	Atom *result = 0;

	if (!overrideTargets(w, screen->eightbit_select_types, &result)) {
	    result = TypeXtMallocN(Atom, 5);
	    if (result == NULL) {
		TRACE(("Couldn't allocate 8bit selection targets\n"));
	    } else {
		int n = 0;

		if (XSupportsLocale()) {
#ifdef X_HAVE_UTF8_STRING
		    result[n++] = XA_UTF8_STRING(XtDisplay(w));
#endif
		    if (screen->i18nSelections) {
			result[n++] = XA_TEXT(XtDisplay(w));
			result[n++] = XA_COMPOUND_TEXT(XtDisplay(w));
		    }
		}
		result[n++] = XA_STRING;
		result[n] = None;
	    }
	}

	*resultp = result;
    }

    return *resultp;
}

static Atom *
_SelectionTargets(Widget w)
{
    Atom *result;
    XtermWidget xw;

    if ((xw = getXtermWidget(w)) == 0) {
	result = NULL;
    } else {
	TScreen *screen = TScreenOf(xw);

#if OPT_WIDE_CHARS
	if (screen->wide_chars) {
	    result = allocUtf8Targets(w, screen);
	} else
#endif
	{
	    /* not screen->wide_chars */
	    result = alloc8bitTargets(w, screen);
	}
    }

    return result;
}

#define isSELECT(value) (!strcmp(value, "SELECT"))

static void
UnmapSelections(XtermWidget xw)
{
    TScreen *screen = TScreenOf(xw);
    Cardinal n;

    if (screen->mappedSelect) {
	for (n = 0; screen->mappedSelect[n] != 0; ++n)
	    free((void *) screen->mappedSelect[n]);
	free(screen->mappedSelect);
	screen->mappedSelect = 0;
    }
}

/*
 * xterm generally uses the primary selection.  Some applications prefer
 * (or are limited to) the clipboard.  Since the translations resource is
 * complicated, users seldom change the way it affects selection.  But it
 * is simple to remap the choice between primary and clipboard before the
 * call to XmuInternStrings().
 */
static String *
MapSelections(XtermWidget xw, String *params, Cardinal num_params)
{
    String *result = params;

    if (num_params > 0) {
	Cardinal j;
	Boolean map = False;

	for (j = 0; j < num_params; ++j) {
	    TRACE(("param[%d]:%s\n", j, params[j]));
	    if (isSELECT(params[j])) {
		map = True;
		break;
	    }
	}
	if (map) {
	    TScreen *screen = TScreenOf(xw);
	    const char *mapTo = (screen->selectToClipboard
				 ? "CLIPBOARD"
				 : "PRIMARY");

	    UnmapSelections(xw);
	    if ((result = TypeMallocN(String, num_params + 1)) != 0) {
		result[num_params] = 0;
		for (j = 0; j < num_params; ++j) {
		    result[j] = x_strdup((isSELECT(params[j])
					  ? mapTo
					  : params[j]));
		    if (result[j] == 0) {
			UnmapSelections(xw);
			while (j != 0) {
			    free((void *) result[--j]);
			}
			free(result);
			result = 0;
			break;
		    }
		}
		screen->mappedSelect = result;
	    }
	}
    }
    return result;
}

/*
 * Lookup the cut-buffer number, which will be in the range 0-7.
 * If it is not a cut-buffer, it is the primary selection (-1).
 */
static int
CutBuffer(Atom code)
{
    int cutbuffer;
    switch ((unsigned) code) {
    case XA_CUT_BUFFER0:
	cutbuffer = 0;
	break;
    case XA_CUT_BUFFER1:
	cutbuffer = 1;
	break;
    case XA_CUT_BUFFER2:
	cutbuffer = 2;
	break;
    case XA_CUT_BUFFER3:
	cutbuffer = 3;
	break;
    case XA_CUT_BUFFER4:
	cutbuffer = 4;
	break;
    case XA_CUT_BUFFER5:
	cutbuffer = 5;
	break;
    case XA_CUT_BUFFER6:
	cutbuffer = 6;
	break;
    case XA_CUT_BUFFER7:
	cutbuffer = 7;
	break;
    default:
	cutbuffer = -1;
	break;
    }
    TRACE(("CutBuffer(%d) = %d\n", (int) code, cutbuffer));
    return cutbuffer;
}

#if OPT_PASTE64
static void
FinishPaste64(XtermWidget xw)
{
    TScreen *screen = TScreenOf(xw);

    TRACE(("FinishPaste64(%d)\n", screen->base64_paste));
    if (screen->base64_paste) {
	screen->base64_paste = 0;
	unparseputc1(xw, screen->base64_final);
	unparse_end(xw);
    }
}
#endif

#if !OPT_PASTE64
static
#endif
void
xtermGetSelection(Widget w,
		  Time ev_time,
		  String *params,	/* selections in precedence order */
		  Cardinal num_params,
		  Atom *targets)
{
    Atom selection;
    int cutbuffer;
    Atom target;

    XtermWidget xw;

    if (num_params == 0)
	return;
    if ((xw = getXtermWidget(w)) == 0)
	return;

    TRACE(("xtermGetSelection num_params %d @@%ld\n", num_params, ev_time));
    params = MapSelections(xw, params, num_params);

    XmuInternStrings(XtDisplay(w), params, (Cardinal) 1, &selection);
    cutbuffer = CutBuffer(selection);

    TRACE(("Cutbuffer: %d, target: %s\n", cutbuffer,
	   (targets
	    ? visibleSelectionTarget(XtDisplay(w), targets[0])
	    : "None")));

    if (cutbuffer >= 0) {
	int inbytes;
	unsigned long nbytes;
	int fmt8 = 8;
	Atom type = XA_STRING;
	char *line;

	/* 'line' is freed in SelectionReceived */
	line = XFetchBuffer(XtDisplay(w), &inbytes, cutbuffer);
	nbytes = (unsigned long) inbytes;

	if (nbytes > 0) {
	    SelectionReceived(w, NULL, &selection, &type, (XtPointer) line,
			      &nbytes, &fmt8);
	} else if (num_params > 1) {
	    xtermGetSelection(w, ev_time, params + 1, num_params - 1, NULL);
	}
#if OPT_PASTE64
	else {
	    FinishPaste64(xw);
	}
#endif
    } else {

	if (targets == NULL || targets[0] == None) {
	    targets = _SelectionTargets(w);
	}

	if (targets != 0) {
	    struct _SelectionList *list;

	    target = targets[0];

	    if (targets[1] == None) {	/* last target in list */
		params++;
		num_params--;
		targets = _SelectionTargets(w);
	    } else {
		targets = &(targets[1]);
	    }

	    if (num_params) {
		/* 'list' is freed in SelectionReceived */
		list = TypeXtMalloc(struct _SelectionList);
		if (list != 0) {
		    list->params = params;
		    list->count = num_params;
		    list->targets = targets;
		    list->time = ev_time;
		}
	    } else {
		list = NULL;
	    }

	    XtGetSelectionValue(w, selection,
				target,
				SelectionReceived,
				(XtPointer) list, ev_time);
	}
    }
}

#if OPT_TRACE && OPT_WIDE_CHARS
static void
GettingSelection(Display *dpy, Atom type, Char *line, unsigned long len)
{
    Char *cp;
    char *name;

    name = XGetAtomName(dpy, type);

    TRACE(("Getting %s (type=%ld, length=%ld)\n", name, (long int) type, len));
    for (cp = line; cp < line + len; cp++) {
	TRACE(("[%d:%lu]", (int) (cp + 1 - line), len));
	if (isprint(*cp)) {
	    TRACE(("%c\n", *cp));
	} else {
	    TRACE(("\\x%02x\n", *cp));
	}
    }
}
#else
#define GettingSelection(dpy,type,line,len)	/* nothing */
#endif

#ifdef VMS
#  define tty_vwrite(pty,lag,l)		tt_write(lag,l)
#else /* !( VMS ) */
#  define tty_vwrite(pty,lag,l)		v_write(pty,lag,l)
#endif /* defined VMS */

#if OPT_PASTE64
/* Return base64 code character given 6-bit number */
static const char base64_code[] = "\
ABCDEFGHIJKLMNOPQRSTUVWXYZ\
abcdefghijklmnopqrstuvwxyz\
0123456789+/";
static void
base64_flush(TScreen *screen)
{
    Char x;

    TRACE(("base64_flush count %d, pad %d (%d)\n",
	   screen->base64_count,
	   screen->base64_pad,
	   screen->base64_pad & 3));

    switch (screen->base64_count) {
    case 0:
	break;
    case 2:
	x = CharOf(base64_code[screen->base64_accu << 4]);
	tty_vwrite(screen->respond, &x, 1);
	break;
    case 4:
	x = CharOf(base64_code[screen->base64_accu << 2]);
	tty_vwrite(screen->respond, &x, 1);
	break;
    }
    if (screen->base64_pad & 3) {
	tty_vwrite(screen->respond,
		   (const Char *) "===",
		   (unsigned) (3 - (screen->base64_pad & 3)));
    }
    screen->base64_count = 0;
    screen->base64_accu = 0;
    screen->base64_pad = 0;
}
#endif /* OPT_PASTE64 */

/*
 * Translate ISO-8859-1 or UTF-8 data to NRCS.
 */
static void
ToNational(TScreen *screen, Char *buffer, unsigned *length)
{
    int gsetL = screen->gsets[screen->curgl];
    int gsetR = screen->gsets[screen->curgr];

#if OPT_WIDE_CHARS
    if ((screen->utf8_nrc_mode | screen->utf8_mode) != uFalse) {
	Char *p;
	PtyData *data = TypeXtMallocX(PtyData, *length);

	memset(data, 0, sizeof(*data));
	data->next = data->buffer;
	data->last = data->buffer + *length;
	memcpy(data->buffer, buffer, (size_t) *length);
	p = buffer;
	while (data->next < data->last) {
	    unsigned chr, out, gl, gr;

	    if (!decodeUtf8(screen, data)) {
		data->utf_size = 1;
		data->utf_data = data->next[0];
	    }
	    data->next += data->utf_size;
	    chr = data->utf_data;
	    out = chr;
	    if ((gl = xtermCharSetIn(screen, chr, gsetL)) != chr) {
		out = gl;
	    } else if ((gr = xtermCharSetIn(screen, chr, gsetR)) != chr) {
		out = gr;
	    }
	    *p++ = (Char) ((out < 256) ? out : ' ');
	}
	*length = (unsigned) (p - buffer);
	free(data);
    } else
#endif
    {
	Char *p;

	for (p = buffer; (int) (p - buffer) < (int) *length; ++p) {
	    unsigned gl, gr;
	    unsigned chr = *p;
	    unsigned out = chr;
	    if ((gl = xtermCharSetIn(screen, chr, gsetL)) != chr) {
		out = gl;
	    } else if ((gr = xtermCharSetIn(screen, chr, gsetR)) != chr) {
		out = gr;
	    }
	    *p = (Char) out;
	}
    }
}

static void
_qWriteSelectionData(XtermWidget xw, Char *lag, unsigned length)
{
    TScreen *screen = TScreenOf(xw);

    /*
     * If we are pasting into a window which is using NRCS, we want to map
     * the text from the normal encoding (ISO-8859-1 or UTF-8) into the coding
     * that an application would use to write characters with NRCS.
     *
     * TODO: handle conversion from UTF-8, and adjust length.  This can be done
     * in the same buffer because the target is always 8-bit.
     */
    if ((xw->flags & NATIONAL) && (length != 0)) {
	ToNational(screen, lag, &length);
    }
#if OPT_PASTE64
    if (screen->base64_paste) {
	/* Send data as base64 */
	Char *p = lag;
	Char buf[64];
	unsigned x = 0;

	TRACE(("convert to base64 %d:%s\n", length, visibleChars(p, length)));

	/*
	 * Handle the case where the selection is from _this_ xterm, which
	 * puts part of the reply in the buffer before the selection callback
	 * happens.
	 */
	if (screen->base64_paste && screen->unparse_len) {
	    unparse_end(xw);
	}
	while (length--) {
	    switch (screen->base64_count) {
	    case 0:
		buf[x++] = CharOf(base64_code[*p >> 2]);
		screen->base64_accu = (unsigned) (*p & 0x3);
		screen->base64_count = 2;
		++p;
		break;
	    case 2:
		buf[x++] = CharOf(base64_code[(screen->base64_accu << 4) +
					      (*p >> 4)]);
		screen->base64_accu = (unsigned) (*p & 0xF);
		screen->base64_count = 4;
		++p;
		break;
	    case 4:
		buf[x++] = CharOf(base64_code[(screen->base64_accu << 2) +
					      (*p >> 6)]);
		buf[x++] = CharOf(base64_code[*p & 0x3F]);
		screen->base64_accu = 0;
		screen->base64_count = 0;
		++p;
		break;
	    }
	    if (x >= 63) {
		/* Write 63 or 64 characters */
		screen->base64_pad += x;
		TRACE(("writing base64 interim %s\n", visibleChars(buf, x)));
		tty_vwrite(screen->respond, buf, x);
		x = 0;
	    }
	}
	if (x != 0) {
	    screen->base64_pad += x;
	    TRACE(("writing base64 finish %s\n", visibleChars(buf, x)));
	    tty_vwrite(screen->respond, buf, x);
	}
    } else
#endif /* OPT_PASTE64 */
#if OPT_READLINE
    if (SCREEN_FLAG(screen, paste_quotes)) {
	while (length--) {
	    tty_vwrite(screen->respond, (const Char *) "\026", 1);	/* Control-V */
	    tty_vwrite(screen->respond, lag++, 1);
	}
    } else
#endif
    {
	TRACE(("writing base64 padding %s\n", visibleChars(lag, length)));
	tty_vwrite(screen->respond, lag, length);
    }
}

static void
_WriteSelectionData(XtermWidget xw, Char *line, size_t length)
{
    /* Write data to pty a line at a time. */
    /* Doing this one line at a time may no longer be necessary
       because v_write has been re-written. */

#if OPT_PASTE64
    TScreen *screen = TScreenOf(xw);
#endif
    Char *lag, *end;

    /* in the VMS version, if tt_pasting isn't set to True then qio
       reads aren't blocked and an infinite loop is entered, where the
       pasted text shows up as new input, goes in again, shows up
       again, ad nauseum. */
#ifdef VMS
    tt_pasting = True;
#endif

    end = &line[length];
    lag = line;

#if OPT_PASTE64
    if (screen->base64_paste) {
	_qWriteSelectionData(xw, lag, (unsigned) (end - lag));
	base64_flush(screen);
    } else
#endif
    {
	if (!SCREEN_FLAG(screen, paste_literal_nl)) {
	    Char *cp;
	    for (cp = line; cp != end; cp++) {
		if (*cp == '\n') {
		    *cp = '\r';
		    _qWriteSelectionData(xw, lag, (unsigned) (cp - lag + 1));
		    lag = cp + 1;
		}
	    }
	}

	if (lag != end) {
	    _qWriteSelectionData(xw, lag, (unsigned) (end - lag));
	}
    }
#ifdef VMS
    tt_pasting = False;
    tt_start_read();		/* reenable reads or a character may be lost */
#endif
}

#if OPT_READLINE
static void
_WriteKey(TScreen *screen, const Char *in)
{
    Char line[16];
    unsigned count = 0;
    size_t length = strlen((const char *) in);

    if (screen->control_eight_bits) {
	line[count++] = ANSI_CSI;
    } else {
	line[count++] = ANSI_ESC;
	line[count++] = '[';
    }
    while (length--)
	line[count++] = *in++;
    line[count++] = '~';
    tty_vwrite(screen->respond, line, count);
}
#endif /* OPT_READLINE */

/*
 * Unless enabled by the user, strip control characters other than formatting.
 */
static size_t
removeControls(XtermWidget xw, char *value)
{
    TScreen *screen = TScreenOf(xw);
    size_t dst = 0;

    if (screen->allowPasteControls) {
	dst = strlen(value);
    } else {
	size_t src = 0;
	while ((value[dst] = value[src]) != '\0') {
	    int ch = CharOf(value[src++]);
	    if (ch < 32) {
		switch (ch) {
		case '\b':
		case '\t':
		case '\n':
		case '\r':
		    ++dst;
		    break;
		default:
		    continue;
		}
	    }
#if OPT_WIDE_CHARS
	    else if (screen->utf8_inparse || screen->utf8_nrc_mode)
		++dst;
#endif
#if OPT_C1_PRINT || OPT_WIDE_CHARS
	    else if (screen->c1_printable)
		++dst;
#endif
	    else if (ch >= 128 && ch < 160)
		continue;
	    else
		++dst;
	}
    }
    return dst;
}

/* SelectionReceived: stuff received selection text into pty */

/* ARGSUSED */
static void
SelectionReceived(Widget w,
		  XtPointer client_data,
		  Atom *selection GCC_UNUSED,
		  Atom *type,
		  XtPointer value,
		  unsigned long *length,
		  int *format)
{
    char **text_list = NULL;
    int text_list_count = 0;
    XTextProperty text_prop;
    TScreen *screen;
    Display *dpy;
#if OPT_TRACE && OPT_WIDE_CHARS
    Char *line = (Char *) value;
#endif

    XtermWidget xw;

    if ((xw = getXtermWidget(w)) == 0)
	return;

    screen = TScreenOf(xw);
    dpy = XtDisplay(w);

    if (*type == 0		/*XT_CONVERT_FAIL */
	|| *length == 0
	|| value == NULL) {
	TRACE(("...no data to convert\n"));
	goto fail;
    }

    text_prop.value = (unsigned char *) value;
    text_prop.encoding = *type;
    text_prop.format = *format;
    text_prop.nitems = *length;

    TRACE(("SelectionReceived %s %s format %d, nitems %ld\n",
	   XGetAtomName(screen->display, *selection),
	   visibleSelectionTarget(dpy, text_prop.encoding),
	   text_prop.format,
	   text_prop.nitems));

#if OPT_WIDE_CHARS
    if (XSupportsLocale() && screen->wide_chars) {
	if (*type == XA_UTF8_STRING(dpy) ||
	    *type == XA_STRING ||
	    *type == XA_COMPOUND_TEXT(dpy)) {
	    GettingSelection(dpy, *type, line, *length);
	    if (Xutf8TextPropertyToTextList(dpy, &text_prop,
					    &text_list,
					    &text_list_count) < 0) {
		TRACE(("default Xutf8 Conversion failed\n"));
		text_list = NULL;
	    }
	}
    } else
#endif /* OPT_WIDE_CHARS */
    {
	/* Convert the selection to locale's multibyte encoding. */

	if (*type == XA_UTF8_STRING(dpy) ||
	    *type == XA_STRING ||
	    *type == XA_COMPOUND_TEXT(dpy)) {
	    Status rc;

	    GettingSelection(dpy, *type, line, *length);

#if OPT_WIDE_CHARS
	    if (*type == XA_UTF8_STRING(dpy) &&
		!(screen->wide_chars || screen->c1_printable)) {
		rc = xtermUtf8ToTextList(xw, &text_prop,
					 &text_list, &text_list_count);
	    } else
#endif
	    if (*type == XA_STRING && (!XSupportsLocale() || screen->brokenSelections)) {
		rc = XTextPropertyToStringList(&text_prop,
					       &text_list, &text_list_count);
	    } else {
		rc = XmbTextPropertyToTextList(dpy, &text_prop,
					       &text_list,
					       &text_list_count);
	    }
	    if (rc < 0) {
		TRACE(("Conversion failed\n"));
		text_list = NULL;
	    }
	}
    }

    if (text_list != NULL && text_list_count != 0) {
	int i;

#if OPT_PASTE64
	if (screen->base64_paste) {
	    /* EMPTY */ ;
	} else
#endif
#if OPT_READLINE
	if (SCREEN_FLAG(screen, paste_brackets)) {
	    _WriteKey(screen, (const Char *) "200");
	}
#endif
	for (i = 0; i < text_list_count; i++) {
	    size_t len = removeControls(xw, text_list[i]);

	    if (screen->selectToBuffer) {
		InternalSelect *mydata = &(screen->internal_select);
		size_t have = (mydata->buffer
			       ? strlen(mydata->buffer)
			       : 0);
		size_t need = have + len + 1;
		char *buffer = realloc(mydata->buffer, need);

		screen->selectToBuffer = False;
#if OPT_PASTE64
		screen->base64_paste = mydata->base64_paste;
#endif
#if OPT_READLINE
		screen->paste_brackets = mydata->paste_brackets;
#endif
		if (buffer != 0) {
		    strcpy(buffer + have, text_list[i]);
		    mydata->buffer = buffer;
		}
		TRACE(("FormatSelect %d.%d .. %d.%d %s\n",
		       screen->startSel.row,
		       screen->startSel.col,
		       screen->endSel.row,
		       screen->endSel.col,
		       mydata->buffer));
		mydata->format_select(w, mydata->format, mydata->buffer,
				      &(screen->startSel),
				      &(screen->endSel));

		free(mydata->format);
		free(mydata->buffer);
		memset(mydata, 0, sizeof(*mydata));
	    } else {
		_WriteSelectionData(xw, (Char *) text_list[i], len);
	    }
	}
#if OPT_PASTE64
	if (screen->base64_paste) {
	    FinishPaste64(xw);
	} else
#endif
#if OPT_READLINE
	if (SCREEN_FLAG(screen, paste_brackets)) {
	    _WriteKey(screen, (const Char *) "201");
	}
#endif
	XFreeStringList(text_list);
    } else {
	TRACE(("...empty text-list\n"));
	goto fail;
    }

    XtFree((char *) client_data);
    XtFree((char *) value);

    return;

  fail:
    if (client_data != 0) {
	struct _SelectionList *list = (struct _SelectionList *) client_data;

	TRACE(("SelectionReceived ->xtermGetSelection\n"));
	xtermGetSelection(w, list->time,
			  list->params, list->count, list->targets);
	XtFree((char *) client_data);
#if OPT_PASTE64
    } else {
	FinishPaste64(xw);
#endif
    }
    return;
}

void
HandleInsertSelection(Widget w,
		      XEvent *event,	/* assumed to be XButtonEvent* */
		      String *params,	/* selections in precedence order */
		      Cardinal *num_params)
{
    XtermWidget xw;

    if ((xw = getXtermWidget(w)) != 0) {
	TRACE(("HandleInsertSelection\n"));
	if (!SendMousePosition(xw, event)) {
#if OPT_READLINE
	    int ldelta;
	    TScreen *screen = TScreenOf(xw);
	    if (IsBtnEvent(event)
	    /* Disable on Shift-mouse, including the application-mouse modes */
		&& !(KeyModifiers(event) & ShiftMask)
		&& (screen->send_mouse_pos == MOUSE_OFF)
		&& SCREEN_FLAG(screen, paste_moves)
		&& rowOnCurrentLine(screen, eventRow(screen, event), &ldelta))
		ReadLineMovePoint(screen, eventColBetween(screen, event), ldelta);
#endif /* OPT_READLINE */

	    xtermGetSelection(w, event->xbutton.time, params, *num_params, NULL);
	}
    }
}

static SelectUnit
EvalSelectUnit(XtermWidget xw,
	       Time buttonDownTime,
	       SelectUnit defaultUnit,
	       unsigned int button)
{
    TScreen *screen = TScreenOf(xw);
    SelectUnit result;
    int delta;

    if (button != screen->lastButton) {
	delta = screen->multiClickTime + 1;
    } else if (screen->lastButtonUpTime == (Time) 0) {
	/* first time and once in a blue moon */
	delta = screen->multiClickTime + 1;
    } else if (buttonDownTime > screen->lastButtonUpTime) {
	/* most of the time */
	delta = (int) (buttonDownTime - screen->lastButtonUpTime);
    } else {
	/* time has rolled over since lastButtonUpTime */
	delta = (int) ((((Time) ~ 0) - screen->lastButtonUpTime) + buttonDownTime);
    }

    if (delta > screen->multiClickTime) {
	screen->numberOfClicks = 1;
	result = defaultUnit;
    } else {
	result = screen->selectMap[screen->numberOfClicks % screen->maxClicks];
	screen->numberOfClicks += 1;
    }
    TRACE(("EvalSelectUnit(%d) = %d\n", screen->numberOfClicks, result));
    return result;
}

static void
do_select_start(XtermWidget xw,
		XEvent *event,	/* must be XButtonEvent* */
		CELL *cell)
{
    TScreen *screen = TScreenOf(xw);

    if (SendMousePosition(xw, event))
	return;
    screen->selectUnit = EvalSelectUnit(xw,
					event->xbutton.time,
					Select_CHAR,
					event->xbutton.button);
    screen->replyToEmacs = False;

#if OPT_READLINE
    lastButtonDownTime = event->xbutton.time;
#endif

    StartSelect(xw, cell);
}

/* ARGSUSED */
void
HandleSelectStart(Widget w,
		  XEvent *event,	/* must be XButtonEvent* */
		  String *params GCC_UNUSED,
		  Cardinal *num_params GCC_UNUSED)
{
    XtermWidget xw;

    if ((xw = getXtermWidget(w)) != 0) {
	TScreen *screen = TScreenOf(xw);
	CELL cell;

	TRACE(("HandleSelectStart\n"));
	screen->firstValidRow = 0;
	screen->lastValidRow = screen->max_row;
	PointToCELL(screen, event->xbutton.y, event->xbutton.x, &cell);

#if OPT_READLINE
	ExtendingSelection = 0;
#endif

	do_select_start(xw, event, &cell);
    }
}

/* ARGSUSED */
void
HandleKeyboardSelectStart(Widget w,
			  XEvent *event,	/* must be XButtonEvent* */
			  String *params GCC_UNUSED,
			  Cardinal *num_params GCC_UNUSED)
{
    XtermWidget xw;

    if ((xw = getXtermWidget(w)) != 0) {
	TScreen *screen = TScreenOf(xw);

	TRACE(("HandleKeyboardSelectStart\n"));
	do_select_start(xw, event, &screen->cursorp);
    }
}

static void
TrackDown(XtermWidget xw, XButtonEvent *event)
{
    TScreen *screen = TScreenOf(xw);
    CELL cell;

    screen->selectUnit = EvalSelectUnit(xw,
					event->time,
					Select_CHAR,
					event->button);
    if (screen->numberOfClicks > 1) {
	PointToCELL(screen, event->y, event->x, &cell);
	screen->replyToEmacs = True;
	StartSelect(xw, &cell);
    } else {
	screen->waitingForTrackInfo = True;
	EditorButton(xw, event);
    }
}

#define boundsCheck(x)	if (x < 0) \
			    x = 0; \
			else if (x >= screen->max_row) \
			    x = screen->max_row

void
TrackMouse(XtermWidget xw,
	   int func,
	   CELL *start,
	   int firstrow,
	   int lastrow)
{
    TScreen *screen = TScreenOf(xw);

    if (screen->waitingForTrackInfo) {	/* if Timed, ignore */
	screen->waitingForTrackInfo = False;

	if (func != 0) {
	    CELL first = *start;

	    boundsCheck(first.row);
	    boundsCheck(firstrow);
	    boundsCheck(lastrow);
	    screen->firstValidRow = firstrow;
	    screen->lastValidRow = lastrow;
	    screen->replyToEmacs = True;
	    StartSelect(xw, &first);
	}
    }
}

static void
StartSelect(XtermWidget xw, const CELL *cell)
{
    TScreen *screen = TScreenOf(xw);

    TRACE(("StartSelect row=%d, col=%d\n", cell->row, cell->col));
    if (screen->cursor_state)
	HideCursor();
    if (screen->numberOfClicks == 1) {
	/* set start of selection */
	screen->rawPos = *cell;
    }
    /* else use old values in rawPos */
    screen->saveStartR = screen->startExt = screen->rawPos;
    screen->saveEndR = screen->endExt = screen->rawPos;
    if (Coordinate(screen, cell) < Coordinate(screen, &(screen->rawPos))) {
	screen->eventMode = LEFTEXTENSION;
	screen->startExt = *cell;
    } else {
	screen->eventMode = RIGHTEXTENSION;
	screen->endExt = *cell;
    }
    ComputeSelect(xw, &(screen->startExt), &(screen->endExt), False);
}

static void
EndExtend(XtermWidget xw,
	  XEvent *event,	/* must be XButtonEvent */
	  String *params,	/* selections */
	  Cardinal num_params,
	  Bool use_cursor_loc)
{
    CELL cell;
    TScreen *screen = TScreenOf(xw);

    if (use_cursor_loc) {
	cell = screen->cursorp;
    } else {
	PointToCELL(screen, event->xbutton.y, event->xbutton.x, &cell);
    }
    ExtendExtend(xw, &cell);

    screen->lastButtonUpTime = event->xbutton.time;
    screen->lastButton = event->xbutton.button;

    if (!isSameCELL(&(screen->startSel), &(screen->endSel))) {
	if (screen->replyToEmacs) {
	    Char line[64];
	    unsigned count = 0;

	    if (screen->control_eight_bits) {
		line[count++] = ANSI_CSI;
	    } else {
		line[count++] = ANSI_ESC;
		line[count++] = '[';
	    }
	    if (isSameCELL(&(screen->rawPos), &(screen->startSel))
		&& isSameCELL(&cell, &(screen->endSel))) {
		/* Use short-form emacs select */

		switch (screen->extend_coords) {
		case 0:
		case SET_EXT_MODE_MOUSE:
		    line[count++] = 't';
		    break;
		case SET_SGR_EXT_MODE_MOUSE:
		    line[count++] = '<';
		    break;
		}

		count = EmitMousePosition(screen, line, count, screen->endSel.col);
		count = EmitMousePositionSeparator(screen, line, count);
		count = EmitMousePosition(screen, line, count, screen->endSel.row);

		switch (screen->extend_coords) {
		case SET_SGR_EXT_MODE_MOUSE:
		case SET_URXVT_EXT_MODE_MOUSE:
		    line[count++] = 't';
		    break;
		}
	    } else {
		/* long-form, specify everything */

		switch (screen->extend_coords) {
		case 0:
		case SET_EXT_MODE_MOUSE:
		    line[count++] = 'T';
		    break;
		case SET_SGR_EXT_MODE_MOUSE:
		    line[count++] = '<';
		    break;
		}

		count = EmitMousePosition(screen, line, count, screen->startSel.col);
		count = EmitMousePositionSeparator(screen, line, count);
		count = EmitMousePosition(screen, line, count, screen->startSel.row);
		count = EmitMousePositionSeparator(screen, line, count);
		count = EmitMousePosition(screen, line, count, screen->endSel.col);
		count = EmitMousePositionSeparator(screen, line, count);
		count = EmitMousePosition(screen, line, count, screen->endSel.row);
		count = EmitMousePositionSeparator(screen, line, count);
		count = EmitMousePosition(screen, line, count, cell.col);
		count = EmitMousePositionSeparator(screen, line, count);
		count = EmitMousePosition(screen, line, count, cell.row);

		switch (screen->extend_coords) {
		case SET_SGR_EXT_MODE_MOUSE:
		case SET_URXVT_EXT_MODE_MOUSE:
		    line[count++] = 'T';
		    break;
		}
	    }
	    v_write(screen->respond, line, count);
	    TrackText(xw, &zeroCELL, &zeroCELL);
	}
    }
    SelectSet(xw, event, params, num_params);
    screen->eventMode = NORMAL;
}

void
HandleSelectSet(Widget w,
		XEvent *event,
		String *params,
		Cardinal *num_params)
{
    XtermWidget xw;

    if ((xw = getXtermWidget(w)) != 0) {
	TRACE(("HandleSelectSet\n"));
	SelectSet(xw, event, params, *num_params);
    }
}

/* ARGSUSED */
static void
SelectSet(XtermWidget xw,
	  XEvent *event GCC_UNUSED,
	  String *params,
	  Cardinal num_params)
{
    TScreen *screen = TScreenOf(xw);

    TRACE(("SelectSet\n"));
    /* Only do select stuff if non-null select */
    if (!isSameCELL(&(screen->startSel), &(screen->endSel))) {
	SaltTextAway(xw, &(screen->startSel), &(screen->endSel));
	_OwnSelection(xw, params, num_params);
    } else {
	ScrnDisownSelection(xw);
    }
}

#define Abs(x)		((x) < 0 ? -(x) : (x))

/* ARGSUSED */
static void
do_start_extend(XtermWidget xw,
		XEvent *event,	/* must be XButtonEvent* */
		String *params GCC_UNUSED,
		Cardinal *num_params GCC_UNUSED,
		Bool use_cursor_loc)
{
    TScreen *screen = TScreenOf(xw);
    int coord;
    CELL cell;

    if (SendMousePosition(xw, event))
	return;

    screen->firstValidRow = 0;
    screen->lastValidRow = screen->max_row;
#if OPT_READLINE
    if ((KeyModifiers(event) & ShiftMask)
	|| event->xbutton.button != Button3
	|| !(SCREEN_FLAG(screen, dclick3_deletes)))
#endif
	screen->selectUnit = EvalSelectUnit(xw,
					    event->xbutton.time,
					    screen->selectUnit,
					    event->xbutton.button);
    screen->replyToEmacs = False;

#if OPT_READLINE
    CheckSecondPress3(screen, event);
#endif

    if (screen->numberOfClicks == 1
	|| (SCREEN_FLAG(screen, dclick3_deletes)	/* Dclick special */
	    &&!(KeyModifiers(event) & ShiftMask))) {
	/* Save existing selection so we can reestablish it if the guy
	   extends past the other end of the selection */
	screen->saveStartR = screen->startExt = screen->startRaw;
	screen->saveEndR = screen->endExt = screen->endRaw;
    } else {
	/* He just needed the selection mode changed, use old values. */
	screen->startExt = screen->startRaw = screen->saveStartR;
	screen->endExt = screen->endRaw = screen->saveEndR;
    }
    if (use_cursor_loc) {
	cell = screen->cursorp;
    } else {
	PointToCELL(screen, event->xbutton.y, event->xbutton.x, &cell);
    }
    coord = Coordinate(screen, &cell);

    if (Abs(coord - Coordinate(screen, &(screen->startSel)))
	< Abs(coord - Coordinate(screen, &(screen->endSel)))
	|| coord < Coordinate(screen, &(screen->startSel))) {
	/* point is close to left side of selection */
	screen->eventMode = LEFTEXTENSION;
	screen->startExt = cell;
    } else {
	/* point is close to left side of selection */
	screen->eventMode = RIGHTEXTENSION;
	screen->endExt = cell;
    }
    ComputeSelect(xw, &(screen->startExt), &(screen->endExt), True);

#if OPT_READLINE
    if (!isSameCELL(&(screen->startSel), &(screen->endSel)))
	ExtendingSelection = 1;
#endif
}

static void
ExtendExtend(XtermWidget xw, const CELL *cell)
{
    TScreen *screen = TScreenOf(xw);
    int coord = Coordinate(screen, cell);

    TRACE(("ExtendExtend row=%d, col=%d\n", cell->row, cell->col));
    if (screen->eventMode == LEFTEXTENSION
	&& ((coord + (screen->selectUnit != Select_CHAR))
	    > Coordinate(screen, &(screen->endSel)))) {
	/* Whoops, he's changed his mind.  Do RIGHTEXTENSION */
	screen->eventMode = RIGHTEXTENSION;
	screen->startExt = screen->saveStartR;
    } else if (screen->eventMode == RIGHTEXTENSION
	       && coord < Coordinate(screen, &(screen->startSel))) {
	/* Whoops, he's changed his mind.  Do LEFTEXTENSION */
	screen->eventMode = LEFTEXTENSION;
	screen->endExt = screen->saveEndR;
    }
    if (screen->eventMode == LEFTEXTENSION) {
	screen->startExt = *cell;
    } else {
	screen->endExt = *cell;
    }
    ComputeSelect(xw, &(screen->startExt), &(screen->endExt), False);

#if OPT_READLINE
    if (!isSameCELL(&(screen->startSel), &(screen->endSel)))
	ExtendingSelection = 1;
#endif
}

void
HandleStartExtend(Widget w,
		  XEvent *event,	/* must be XButtonEvent* */
		  String *params,	/* unused */
		  Cardinal *num_params)		/* unused */
{
    XtermWidget xw;

    if ((xw = getXtermWidget(w)) != 0) {
	TRACE(("HandleStartExtend\n"));
	do_start_extend(xw, event, params, num_params, False);
    }
}

void
HandleKeyboardStartExtend(Widget w,
			  XEvent *event,	/* must be XButtonEvent* */
			  String *params,	/* unused */
			  Cardinal *num_params)		/* unused */
{
    XtermWidget xw;

    if ((xw = getXtermWidget(w)) != 0) {
	TRACE(("HandleKeyboardStartExtend\n"));
	do_start_extend(xw, event, params, num_params, True);
    }
}

void
ScrollSelection(TScreen *screen, int amount, Bool always)
{
    int minrow = INX2ROW(screen, -screen->savedlines);
    int maxrow = INX2ROW(screen, screen->max_row);
    int maxcol = screen->max_col;

#define scroll_update_one(cell) \
	(cell)->row += amount; \
	if ((cell)->row < minrow) { \
	    (cell)->row = minrow; \
	    (cell)->col = 0; \
	} \
	if ((cell)->row > maxrow) { \
	    (cell)->row = maxrow; \
	    (cell)->col = maxcol; \
	}

    scroll_update_one(&(screen->startRaw));
    scroll_update_one(&(screen->endRaw));
    scroll_update_one(&(screen->startSel));
    scroll_update_one(&(screen->endSel));

    scroll_update_one(&(screen->rawPos));

    /*
     * If we are told to scroll the selection but it lies outside the scrolling
     * margins, then that could cause the selection to move (bad).  It is not
     * simple to fix, because this function is called both for the scrollbar
     * actions as well as application scrolling.  The 'always' flag is set in
     * the former case.  The rest of the logic handles the latter.
     */
    if (ScrnHaveSelection(screen)) {
	int adjust;

	adjust = ROW2INX(screen, screen->startH.row);
	if (always
	    || !ScrnHaveRowMargins(screen)
	    || ScrnIsRowInMargins(screen, adjust)) {
	    scroll_update_one(&screen->startH);
	}
	adjust = ROW2INX(screen, screen->endH.row);
	if (always
	    || !ScrnHaveRowMargins(screen)
	    || ScrnIsRowInMargins(screen, adjust)) {
	    scroll_update_one(&screen->endH);
	}
    }

    screen->startHCoord = Coordinate(screen, &screen->startH);
    screen->endHCoord = Coordinate(screen, &screen->endH);
}

/*ARGSUSED*/
void
ResizeSelection(TScreen *screen GCC_UNUSED, int rows, int cols)
{
    rows--;			/* decr to get 0-max */
    cols--;

    if (screen->startRaw.row > rows)
	screen->startRaw.row = rows;
    if (screen->startSel.row > rows)
	screen->startSel.row = rows;
    if (screen->endRaw.row > rows)
	screen->endRaw.row = rows;
    if (screen->endSel.row > rows)
	screen->endSel.row = rows;
    if (screen->rawPos.row > rows)
	screen->rawPos.row = rows;

    if (screen->startRaw.col > cols)
	screen->startRaw.col = cols;
    if (screen->startSel.col > cols)
	screen->startSel.col = cols;
    if (screen->endRaw.col > cols)
	screen->endRaw.col = cols;
    if (screen->endSel.col > cols)
	screen->endSel.col = cols;
    if (screen->rawPos.col > cols)
	screen->rawPos.col = cols;
}

#if OPT_WIDE_CHARS
Bool
iswide(int i)
{
    return (i == HIDDEN_CHAR) || (WideCells(i) == 2);
}

#define isWideCell(row, col) iswide((int)XTERM_CELL(row, col))
#endif

static void
PointToCELL(TScreen *screen,
	    int y,
	    int x,
	    CELL *cell)
/* Convert pixel coordinates to character coordinates.
   Rows are clipped between firstValidRow and lastValidRow.
   Columns are clipped between to be 0 or greater, but are not clipped to some
       maximum value. */
{
    cell->row = (y - screen->border) / FontHeight(screen);
    if (cell->row < screen->firstValidRow)
	cell->row = screen->firstValidRow;
    else if (cell->row > screen->lastValidRow)
	cell->row = screen->lastValidRow;
    cell->col = (x - OriginX(screen)) / FontWidth(screen);
    if (cell->col < 0)
	cell->col = 0;
    else if (cell->col > MaxCols(screen)) {
	cell->col = MaxCols(screen);
    }
#if OPT_WIDE_CHARS
    /*
     * If we got a click on the right half of a doublewidth character,
     * pretend it happened on the left half.
     */
    if (cell->col > 0
	&& isWideCell(cell->row, cell->col - 1)
	&& (XTERM_CELL(cell->row, cell->col) == HIDDEN_CHAR)) {
	cell->col -= 1;
    }
#endif
}

/*
 * Find the last column at which text was drawn on the given row.
 */
static int
LastTextCol(TScreen *screen, CLineData *ld, int row)
{
    int i = -1;

    if (ld != 0) {
	if (okScrnRow(screen, row)) {
	    const IAttr *ch;
	    for (i = screen->max_col,
		 ch = ld->attribs + i;
		 i >= 0 && !(*ch & CHARDRAWN);
		 ch--, i--) {
		;
	    }
#if OPT_DEC_CHRSET
	    if (CSET_DOUBLE(GetLineDblCS(ld))) {
		i *= 2;
	    }
#endif
	}
    }
    return (i);
}

#if !OPT_WIDE_CHARS
/*
** double click table for cut and paste in 8 bits
**
** This table is divided in four parts :
**
**	- control characters	[0,0x1f] U [0x80,0x9f]
**	- separators		[0x20,0x3f] U [0xa0,0xb9]
**	- binding characters	[0x40,0x7f] U [0xc0,0xff]
**	- exceptions
*/
/* *INDENT-OFF* */
static int charClass[256] =
{
/* NUL  SOH  STX  ETX  EOT  ENQ  ACK  BEL */
    32,  1,    1,   1,   1,   1,   1,   1,
/*  BS   HT   NL   VT   FF   CR   SO   SI */
     1,  32,   1,   1,   1,   1,   1,   1,
/* DLE  DC1  DC2  DC3  DC4  NAK  SYN  ETB */
     1,   1,   1,   1,   1,   1,   1,   1,
/* CAN   EM  SUB  ESC   FS   GS   RS   US */
     1,   1,   1,   1,   1,   1,   1,   1,
/*  SP    !    "    #    $    %    &    ' */
    32,  33,  34,  35,  36,  37,  38,  39,
/*   (    )    *    +    ,    -    .    / */
    40,  41,  42,  43,  44,  45,  46,  47,
/*   0    1    2    3    4    5    6    7 */
    48,  48,  48,  48,  48,  48,  48,  48,
/*   8    9    :    ;    <    =    >    ? */
    48,  48,  58,  59,  60,  61,  62,  63,
/*   @@    A    B    C    D    E    F    G */
    64,  48,  48,  48,  48,  48,  48,  48,
/*   H    I    J    K    L    M    N    O */
    48,  48,  48,  48,  48,  48,  48,  48,
/*   P    Q    R    S    T    U    V    W */
    48,  48,  48,  48,  48,  48,  48,  48,
/*   X    Y    Z    [    \    ]    ^    _ */
    48,  48,  48,  91,  92,  93,  94,  48,
/*   `    a    b    c    d    e    f    g */
    96,  48,  48,  48,  48,  48,  48,  48,
/*   h    i    j    k    l    m    n    o */
    48,  48,  48,  48,  48,  48,  48,  48,
/*   p    q    r    s    t    u    v    w */
    48,  48,  48,  48,  48,  48,  48,  48,
/*   x    y    z    {    |    }    ~  DEL */
    48,  48,  48, 123, 124, 125, 126,   1,
/* x80  x81  x82  x83  IND  NEL  SSA  ESA */
    1,    1,   1,   1,   1,   1,   1,   1,
/* HTS  HTJ  VTS  PLD  PLU   RI  SS2  SS3 */
    1,    1,   1,   1,   1,   1,   1,   1,
/* DCS  PU1  PU2  STS  CCH   MW  SPA  EPA */
    1,    1,   1,   1,   1,   1,   1,   1,
/* x98  x99  x9A  CSI   ST  OSC   PM  APC */
    1,    1,   1,   1,   1,   1,   1,   1,
/*   -    i   c/    L   ox   Y-    |   So */
    160, 161, 162, 163, 164, 165, 166, 167,
/*  ..   c0   ip   <<    _        R0    - */
    168, 169, 170, 171, 172, 173, 174, 175,
/*   o   +-    2    3    '    u   q|    . */
    176, 177, 178, 179, 180, 181, 182, 183,
/*   ,    1    2   >>  1/4  1/2  3/4    ? */
    184, 185, 186, 187, 188, 189, 190, 191,
/*  A`   A'   A^   A~   A:   Ao   AE   C, */
     48,  48,  48,  48,  48,  48,  48,  48,
/*  E`   E'   E^   E:   I`   I'   I^   I: */
     48,  48,  48,  48,  48,  48,  48,  48,
/*  D-   N~   O`   O'   O^   O~   O:    X */
     48,  48,  48,  48,  48,  48,  48, 215,
/*  O/   U`   U'   U^   U:   Y'    P    B */
     48,  48,  48,  48,  48,  48,  48,  48,
/*  a`   a'   a^   a~   a:   ao   ae   c, */
     48,  48,  48,  48,  48,  48,  48,  48,
/*  e`   e'   e^   e:    i`  i'   i^   i: */
     48,  48,  48,  48,  48,  48,  48,  48,
/*   d   n~   o`   o'   o^   o~   o:   -: */
     48,  48,  48,  48,  48,  48,  48, 247,
/*  o/   u`   u'   u^   u:   y'    P   y: */
     48,  48,  48,  48,  48,  48,  48,  48};
/* *INDENT-ON* */

int
SetCharacterClassRange(int low,	/* in range of [0..255] */
		       int high,
		       int value)	/* arbitrary */
{

    if (low < 0 || high > 255 || high < low)
	return (-1);

    for (; low <= high; low++)
	charClass[low] = value;

    return (0);
}
#endif

static int
class_of(LineData *ld, CELL *cell)
{
    CELL temp = *cell;
    int result = 0;

#if OPT_DEC_CHRSET
    if (CSET_DOUBLE(GetLineDblCS(ld))) {
	temp.col /= 2;
    }
#endif
    if (temp.col < (int) ld->lineSize)
	result = CharacterClass((int) (ld->charData[temp.col]));
    return result;
}

#if OPT_WIDE_CHARS
#define CClassSelects(name, cclass) \
	 (CClassOf(name) == cclass \
	 || XTERM_CELL(screen->name.row, screen->name.col) == HIDDEN_CHAR)
#else
#define CClassSelects(name, cclass) \
	 (class_of(ld.name, &((screen->name))) == cclass)
#endif

#define CClassOf(name) class_of(ld.name, &((screen->name)))

/*
 * If the given column is past the end of text on the given row, bump to the
 * beginning of the next line.
 */
static Boolean
okPosition(TScreen *screen,
	   LineData **ld,
	   CELL *cell)
{
    Boolean result = True;

    if (cell->row > screen->max_row) {
	result = False;
    } else if (cell->col > (LastTextCol(screen, *ld, cell->row) + 1)) {
	if (cell->row < screen->max_row) {
	    cell->col = 0;
	    *ld = GET_LINEDATA(screen, ++cell->row);
	    result = False;
	}
    }
    return result;
}

static void
trimLastLine(TScreen *screen,
	     LineData **ld,
	     CELL *last)
{
    if (screen->cutNewline && last->row < screen->max_row) {
	last->col = 0;
	*ld = GET_LINEDATA(screen, ++last->row);
    } else {
	last->col = LastTextCol(screen, *ld, last->row) + 1;
    }
}

#if OPT_SELECT_REGEX
/*
 * Returns the first row of a wrapped line.
 */
static int
firstRowOfLine(TScreen *screen, int row, Bool visible)
{
    LineData *ld = 0;
    int limit = visible ? 0 : -screen->savedlines;

    while (row > limit &&
	   (ld = GET_LINEDATA(screen, row - 1)) != 0 &&
	   LineTstWrapped(ld)) {
	--row;
    }
    return row;
}

/*
 * Returns the last row of a wrapped line.
 */
static int
lastRowOfLine(TScreen *screen, int row)
{
    LineData *ld;

    while (row < screen->max_row &&
	   (ld = GET_LINEDATA(screen, row)) != 0 &&
	   LineTstWrapped(ld)) {
	++row;
    }
    return row;
}

/*
 * Returns the number of cells on the range of rows.
 */
static unsigned
lengthOfLines(TScreen *screen, int firstRow, int lastRow)
{
    unsigned length = 0;
    int n;

    for (n = firstRow; n <= lastRow; ++n) {
	LineData *ld = GET_LINEDATA(screen, n);
	int value = LastTextCol(screen, ld, n);
	if (value >= 0)
	    length += (unsigned) (value + 1);
    }
    return length;
}

/*
 * Make a copy of the wrapped-line which corresponds to the given row as a
 * string of bytes.  Construct an index for the columns from the beginning of
 * the line.
 */
static char *
make_indexed_text(TScreen *screen, int row, unsigned length, int *indexed)
{
    Char *result = 0;
    size_t need = (length + 1);

    /*
     * Get a quick upper bound to the number of bytes needed, if the whole
     * string were UTF-8.
     */
    if_OPT_WIDE_CHARS(screen, {
	need *= ((screen->lineExtra + 1) * 6);
    });

    if ((result = TypeCallocN(Char, need + 1)) != 0) {
	LineData *ld = GET_LINEDATA(screen, row);
	unsigned used = 0;
	Char *last = result;

	do {
	    int col = 0;
	    int limit = LastTextCol(screen, ld, row);

	    while (col <= limit) {
		Char *next = last;
		unsigned data = ld->charData[col];

		assert(col < (int) ld->lineSize);
		/* some internal points may not be drawn */
		if (data == 0)
		    data = ' ';

		if_WIDE_OR_NARROW(screen, {
		    next = convertToUTF8(last, data);
		}
		, {
		    *next++ = CharOf(data);
		});

		if_OPT_WIDE_CHARS(screen, {
		    size_t off;
		    for_each_combData(off, ld) {
			data = ld->combData[off][col];
			if (data == 0)
			    break;
			next = convertToUTF8(next, data);
		    }
		});

		indexed[used] = (int) (last - result);
		*next = 0;
		/* TRACE(("index[%d.%d] %d:%s\n", row, used, indexed[used], last)); */
		last = next;
		++used;
		++col;
		indexed[used] = (int) (next - result);
	    }
	} while (used < length &&
		 LineTstWrapped(ld) &&
		 (ld = GET_LINEDATA(screen, ++row)) != 0 &&
		 row < screen->max_row);
    }
    /* TRACE(("result:%s\n", result)); */
    return (char *) result;
}

/*
 * Find the column given an offset into the character string by using the
 * index constructed in make_indexed_text().
 */
static int
indexToCol(int *indexed, int len, int off)
{
    int col = 0;
    while (indexed[col] < len) {
	if (indexed[col] >= off)
	    break;
	++col;
    }
    return col;
}

/*
 * Given a row number, and a column offset from that (which may be wrapped),
 * set the cell to the actual row/column values.
 */
static void
columnToCell(TScreen *screen, int row, int col, CELL *cell)
{
    while (row < screen->max_row) {
	CLineData *ld = GET_LINEDATA(screen, row);
	int last = LastTextCol(screen, ld, row);

	/* TRACE(("last(%d) = %d, have %d\n", row, last, col)); */
	if (col <= last) {
	    break;
	}
	/*
	 * Stop if the current row does not wrap (does not continue the current
	 * line).
	 */
	if (!LineTstWrapped(ld)) {
	    col = last + 1;
	    break;
	}
	col -= (last + 1);
	++row;
    }
    if (col < 0)
	col = 0;
    cell->row = row;
    cell->col = col;
}

/*
 * Given a cell, find the corresponding column offset.
 */
static int
cellToColumn(TScreen *screen, CELL *cell)
{
    CLineData *ld = 0;
    int col = cell->col;
    int row = firstRowOfLine(screen, cell->row, False);
    while (row < cell->row) {
	ld = GET_LINEDATA(screen, row);
	col += LastTextCol(screen, ld, row++);
    }
#if OPT_DEC_CHRSET
    if (ld == 0)
	ld = GET_LINEDATA(screen, row);
    if (CSET_DOUBLE(GetLineDblCS(ld)))
	col /= 2;
#endif
    return col;
}

static void
do_select_regex(TScreen *screen, CELL *startc, CELL *endc)
{
    LineData *ld = GET_LINEDATA(screen, startc->row);
    int inx = ((screen->numberOfClicks - 1) % screen->maxClicks);
    char *expr = screen->selectExpr[inx];
    regex_t preg;
    regmatch_t match;

    TRACE(("Select_REGEX[%d]:%s\n", inx, NonNull(expr)));
    if (okPosition(screen, &ld, startc) && expr != 0) {
	if (regcomp(&preg, expr, REG_EXTENDED) == 0) {
	    int firstRow = firstRowOfLine(screen, startc->row, True);
	    int lastRow = lastRowOfLine(screen, firstRow);
	    unsigned size = lengthOfLines(screen, firstRow, lastRow);
	    int actual = cellToColumn(screen, startc);
	    int *indexed;

	    TRACE(("regcomp ok rows %d..%d bytes %d\n",
		   firstRow, lastRow, size));

	    if ((indexed = TypeCallocN(int, size + 1)) != 0) {
		char *search;
		if ((search = make_indexed_text(screen,
						firstRow,
						size,
						indexed)) != 0) {
		    int len = (int) strlen(search);
		    int col;
		    int best_col = -1;
		    int best_len = -1;

		    for (col = 0; indexed[col] < len; ++col) {
			if (regexec(&preg,
				    search + indexed[col],
				    (size_t) 1, &match, 0) == 0) {
			    int start_inx = (int) (match.rm_so + indexed[col]);
			    int finis_inx = (int) (match.rm_eo + indexed[col]);
			    int start_col = indexToCol(indexed, len, start_inx);
			    int finis_col = indexToCol(indexed, len, finis_inx);

			    if (start_col <= actual &&
				actual < finis_col) {
				int test = finis_col - start_col;
				if (best_len < test) {
				    best_len = test;
				    best_col = start_col;
				    TRACE(("match column %d len %d\n",
					   best_col,
					   best_len));
				}
			    }
			}
		    }
		    if (best_col >= 0) {
			int best_nxt = best_col + best_len;
			columnToCell(screen, firstRow, best_col, startc);
			columnToCell(screen, firstRow, best_nxt, endc);
			TRACE(("search::%s\n", search));
			TRACE(("indexed:%d..%d -> %d..%d\n",
			       best_col, best_nxt,
			       indexed[best_col],
			       indexed[best_nxt]));
			TRACE(("matched:%d:%s\n",
			       indexed[best_nxt] + 1 -
			       indexed[best_col],
			       visibleChars((Char *) (search + indexed[best_col]),
					    (unsigned) (indexed[best_nxt] +
							1 -
							indexed[best_col]))));
		    }
		    free(search);
		}
		free(indexed);
#if OPT_DEC_CHRSET
		if ((ld = GET_LINEDATA(screen, startc->row)) != 0) {
		    if (CSET_DOUBLE(GetLineDblCS(ld)))
			startc->col *= 2;
		}
		if ((ld = GET_LINEDATA(screen, endc->row)) != 0) {
		    if (CSET_DOUBLE(GetLineDblCS(ld)))
			endc->col *= 2;
		}
#endif
	    }
	    regfree(&preg);
	}
    }
}
#endif /* OPT_SELECT_REGEX */

#define InitRow(name) \
	ld.name = GET_LINEDATA(screen, screen->name.row)

#define NextRow(name) \
	ld.name = GET_LINEDATA(screen, ++screen->name.row)

#define PrevRow(name) \
	ld.name = GET_LINEDATA(screen, --screen->name.row)

#define MoreRows(name) \
	(screen->name.row < screen->max_row)

#define isPrevWrapped(name) \
	(screen->name.row > 0 \
	   && (ltmp = GET_LINEDATA(screen, screen->name.row - 1)) != 0 \
	   && LineTstWrapped(ltmp))

/*
 * sets startSel endSel
 * ensuring that they have legal values
 */
static void
ComputeSelect(XtermWidget xw,
	      CELL *startc,
	      CELL *endc,
	      Bool extend)
{
    TScreen *screen = TScreenOf(xw);

    int cclass;
    CELL first = *startc;
    CELL last = *endc;
    Boolean ignored = False;

    struct {
	LineData *startSel;
	LineData *endSel;
    } ld;
    LineData *ltmp;

    TRACE(("ComputeSelect(startRow=%d, startCol=%d, endRow=%d, endCol=%d, %sextend)\n",
	   first.row, first.col,
	   last.row, last.col,
	   extend ? "" : "no"));

#if OPT_WIDE_CHARS
    if (first.col > 1
	&& isWideCell(first.row, first.col - 1)
	&& XTERM_CELL(first.row, first.col - 0) == HIDDEN_CHAR) {
	TRACE(("Adjusting start. Changing downwards from %i.\n", first.col));
	first.col -= 1;
	if (last.col == (first.col + 1))
	    last.col--;
    }

    if (last.col > 1
	&& isWideCell(last.row, last.col - 1)
	&& XTERM_CELL(last.row, last.col) == HIDDEN_CHAR) {
	last.col += 1;
    }
#endif

    if (Coordinate(screen, &first) <= Coordinate(screen, &last)) {
	screen->startSel = screen->startRaw = first;
	screen->endSel = screen->endRaw = last;
    } else {			/* Swap them */
	screen->startSel = screen->startRaw = last;
	screen->endSel = screen->endRaw = first;
    }

    InitRow(startSel);
    InitRow(endSel);

    switch (screen->selectUnit) {
    case Select_CHAR:
	(void) okPosition(screen, &(ld.startSel), &(screen->startSel));
	(void) okPosition(screen, &(ld.endSel), &(screen->endSel));
	break;

    case Select_WORD:
	TRACE(("Select_WORD\n"));
	if (okPosition(screen, &(ld.startSel), &(screen->startSel))) {
	    cclass = CClassOf(startSel);
	    do {
		--screen->startSel.col;
		if (screen->startSel.col < 0
		    && isPrevWrapped(startSel)) {
		    PrevRow(startSel);
		    screen->startSel.col = LastTextCol(screen, ld.startSel, screen->startSel.row);
		}
	    } while (screen->startSel.col >= 0
		     && CClassSelects(startSel, cclass));
	    ++screen->startSel.col;
	}
#if OPT_WIDE_CHARS
	if (screen->startSel.col
	    && XTERM_CELL(screen->startSel.row,
			  screen->startSel.col) == HIDDEN_CHAR)
	    screen->startSel.col++;
#endif

	if (okPosition(screen, &(ld.endSel), &(screen->endSel))) {
	    int length = LastTextCol(screen, ld.endSel, screen->endSel.row);
	    cclass = CClassOf(endSel);
	    do {
		++screen->endSel.col;
		if (screen->endSel.col > length
		    && LineTstWrapped(ld.endSel)) {
		    if (!MoreRows(endSel))
			break;
		    screen->endSel.col = 0;
		    NextRow(endSel);
		    length = LastTextCol(screen, ld.endSel, screen->endSel.row);
		}
	    } while (screen->endSel.col <= length
		     && CClassSelects(endSel, cclass));
	    /* Word-select selects if pointing to any char in "word",
	     * especially note that it includes the last character in a word.
	     * So we do no --endSel.col and do special eol handling.
	     */
	    if (screen->endSel.col > length + 1
		&& MoreRows(endSel)) {
		screen->endSel.col = 0;
		NextRow(endSel);
	    }
	}
#if OPT_WIDE_CHARS
	if (screen->endSel.col
	    && XTERM_CELL(screen->endSel.row,
			  screen->endSel.col) == HIDDEN_CHAR)
	    screen->endSel.col++;
#endif

	screen->saveStartW = screen->startSel;
	break;

    case Select_LINE:
	TRACE(("Select_LINE\n"));
	while (LineTstWrapped(ld.endSel)
	       && MoreRows(endSel)) {
	    NextRow(endSel);
	}
	if (screen->cutToBeginningOfLine
	    || screen->startSel.row < screen->saveStartW.row) {
	    screen->startSel.col = 0;
	    while (isPrevWrapped(startSel)) {
		PrevRow(startSel);
	    }
	} else if (!extend) {
	    if ((first.row < screen->saveStartW.row)
		|| (isSameRow(&first, &(screen->saveStartW))
		    && first.col < screen->saveStartW.col)) {
		screen->startSel.col = 0;
		while (isPrevWrapped(startSel)) {
		    PrevRow(startSel);
		}
	    } else {
		screen->startSel = screen->saveStartW;
	    }
	}
	trimLastLine(screen, &(ld.endSel), &(screen->endSel));
	break;

    case Select_GROUP:		/* paragraph */
	TRACE(("Select_GROUP\n"));
	if (okPosition(screen, &(ld.startSel), &(screen->startSel))) {
	    /* scan backward for beginning of group */
	    while (screen->startSel.row > 0 &&
		   (LastTextCol(screen, ld.startSel, screen->startSel.row -
				1) > 0 ||
		    isPrevWrapped(startSel))) {
		PrevRow(startSel);
	    }
	    screen->startSel.col = 0;
	    /* scan forward for end of group */
	    while (MoreRows(endSel) &&
		   (LastTextCol(screen, ld.endSel, screen->endSel.row + 1) >
		    0 ||
		    LineTstWrapped(ld.endSel))) {
		NextRow(endSel);
	    }
	    trimLastLine(screen, &(ld.endSel), &(screen->endSel));
	}
	break;

    case Select_PAGE:		/* everything one can see */
	TRACE(("Select_PAGE\n"));
	screen->startSel.row = 0;
	screen->startSel.col = 0;
	screen->endSel.row = MaxRows(screen);
	screen->endSel.col = 0;
	break;

    case Select_ALL:		/* counts scrollback if in normal screen */
	TRACE(("Select_ALL\n"));
	screen->startSel.row = -screen->savedlines;
	screen->startSel.col = 0;
	screen->endSel.row = MaxRows(screen);
	screen->endSel.col = 0;
	break;

#if OPT_SELECT_REGEX
    case Select_REGEX:
	do_select_regex(screen, &(screen->startSel), &(screen->endSel));
	break;
#endif

    case NSELECTUNITS:		/* always ignore */
	ignored = True;
	break;
    }

    if (!ignored) {
	/* check boundaries */
	ScrollSelection(screen, 0, False);
	TrackText(xw, &(screen->startSel), &(screen->endSel));
    }

    return;
}

/* Guaranteed (first.row, first.col) <= (last.row, last.col) */
static void
TrackText(XtermWidget xw,
	  const CELL *firstp,
	  const CELL *lastp)
{
    TScreen *screen = TScreenOf(xw);
    int from, to;
    CELL old_start, old_end;
    CELL first = *firstp;
    CELL last = *lastp;

    TRACE(("TrackText(first=%d,%d, last=%d,%d)\n",
	   first.row, first.col, last.row, last.col));

    old_start = screen->startH;
    old_end = screen->endH;
    TRACE(("...previous(first=%d,%d, last=%d,%d)\n",
	   old_start.row, old_start.col,
	   old_end.row, old_end.col));
    if (isSameCELL(&first, &old_start) &&
	isSameCELL(&last, &old_end)) {
	return;
    }

    screen->startH = first;
    screen->endH = last;
    from = Coordinate(screen, &screen->startH);
    to = Coordinate(screen, &screen->endH);
    if (to <= screen->startHCoord || from > screen->endHCoord) {
	/* No overlap whatsoever between old and new hilite */
	ReHiliteText(xw, &old_start, &old_end);
	ReHiliteText(xw, &first, &last);
    } else {
	if (from < screen->startHCoord) {
	    /* Extend left end */
	    ReHiliteText(xw, &first, &old_start);
	} else if (from > screen->startHCoord) {
	    /* Shorten left end */
	    ReHiliteText(xw, &old_start, &first);
	}
	if (to > screen->endHCoord) {
	    /* Extend right end */
	    ReHiliteText(xw, &old_end, &last);
	} else if (to < screen->endHCoord) {
	    /* Shorten right end */
	    ReHiliteText(xw, &last, &old_end);
	}
    }
    screen->startHCoord = from;
    screen->endHCoord = to;
}

/* Guaranteed that (first->row, first->col) <= (last->row, last->col) */
static void
ReHiliteText(XtermWidget xw,
	     CELL *firstp,
	     CELL *lastp)
{
    TScreen *screen = TScreenOf(xw);
    CELL first = *firstp;
    CELL last = *lastp;

    TRACE(("ReHiliteText from %d.%d to %d.%d\n",
	   first.row, first.col, last.row, last.col));

    if (first.row < 0)
	first.row = first.col = 0;
    else if (first.row > screen->max_row)
	return;			/* nothing to do, since last.row >= first.row */

    if (last.row < 0)
	return;			/* nothing to do, since first.row <= last.row */
    else if (last.row > screen->max_row) {
	last.row = screen->max_row;
	last.col = MaxCols(screen);
    }
    if (isSameCELL(&first, &last))
	return;

    if (!isSameRow(&first, &last)) {	/* do multiple rows */
	int i;
	if ((i = screen->max_col - first.col + 1) > 0) {	/* first row */
	    ScrnRefresh(xw, first.row, first.col, 1, i, True);
	}
	if ((i = last.row - first.row - 1) > 0) {	/* middle rows */
	    ScrnRefresh(xw, first.row + 1, 0, i, MaxCols(screen), True);
	}
	if (last.col > 0 && last.row <= screen->max_row) {	/* last row */
	    ScrnRefresh(xw, last.row, 0, 1, last.col, True);
	}
    } else {			/* do single row */
	ScrnRefresh(xw, first.row, first.col, 1, last.col - first.col, True);
    }
}

/*
 * Guaranteed that (cellc->row, cellc->col) <= (cell->row, cell->col), and that both points are valid
 * (may have cell->row = screen->max_row+1, cell->col = 0).
 */
static void
SaltTextAway(XtermWidget xw,
	     CELL *cellc,
	     CELL *cell)
{
    TScreen *screen = TScreenOf(xw);
    int i, j = 0;
    int eol;
    Char *line;
    Char *lp;
    CELL first = *cellc;
    CELL last = *cell;

    if (isSameRow(&first, &last) && first.col > last.col) {
	int tmp;
	EXCHANGE(first.col, last.col, tmp);
    }

    --last.col;
    /* first we need to know how long the string is before we can save it */

    if (isSameRow(&last, &first)) {
	j = Length(screen, first.row, first.col, last.col);
    } else {			/* two cases, cut is on same line, cut spans multiple lines */
	j += Length(screen, first.row, first.col, screen->max_col) + 1;
	for (i = first.row + 1; i < last.row; i++)
	    j += Length(screen, i, 0, screen->max_col) + 1;
	if (last.col >= 0)
	    j += Length(screen, last.row, 0, last.col);
    }

    /* UTF-8 may require more space */
    if_OPT_WIDE_CHARS(screen, {
	j *= 4;
    });

    /* now get some memory to save it in */

    if (screen->selection_size <= j) {
	if ((line = (Char *) malloc((size_t) j + 1)) == 0)
	    SysError(ERROR_BMALLOC2);
	XtFree((char *) screen->selection_data);
	screen->selection_data = line;
	screen->selection_size = j + 1;
    } else {
	line = screen->selection_data;
    }

    if ((line == 0)
	|| (j < 0))
	return;

    line[j] = '\0';		/* make sure it is null terminated */
    lp = line;			/* lp points to where to save the text */
    if (isSameRow(&last, &first)) {
	lp = SaveText(screen, last.row, first.col, last.col, lp, &eol);
    } else {
	lp = SaveText(screen, first.row, first.col, screen->max_col, lp, &eol);
	if (eol)
	    *lp++ = '\n';	/* put in newline at end of line */
	for (i = first.row + 1; i < last.row; i++) {
	    lp = SaveText(screen, i, 0, screen->max_col, lp, &eol);
	    if (eol)
		*lp++ = '\n';
	}
	if (last.col >= 0)
	    lp = SaveText(screen, last.row, 0, last.col, lp, &eol);
    }
    *lp = '\0';			/* make sure we have end marked */

    TRACE(("Salted TEXT:%d:%s\n", (int) (lp - line),
	   visibleChars(line, (unsigned) (lp - line))));

    screen->selection_length = (unsigned long) (lp - line);
}

#if OPT_PASTE64
void
ClearSelectionBuffer(TScreen *screen)
{
    screen->selection_length = 0;
    screen->base64_count = 0;
}

static void
AppendStrToSelectionBuffer(TScreen *screen, Char *text, size_t len)
{
    if (len != 0) {
	int j = (int) (screen->selection_length + len);		/* New length */
	int k = j + (j >> 2) + 80;	/* New size if we grow buffer: grow by ~50% */
	if (j + 1 >= screen->selection_size) {
	    if (!screen->selection_length) {
		/* New buffer */
		Char *line;
		if ((line = (Char *) malloc((size_t) k)) == 0)
		    SysError(ERROR_BMALLOC2);
		XtFree((char *) screen->selection_data);
		screen->selection_data = line;
	    } else {
		/* Realloc buffer */
		screen->selection_data = (Char *)
		    realloc(screen->selection_data,
			    (size_t) k);
		if (screen->selection_data == 0)
		    SysError(ERROR_BMALLOC2);
	    }
	    screen->selection_size = k;
	}
	if (screen->selection_data != 0) {
	    memcpy(screen->selection_data + screen->selection_length, text, len);
	    screen->selection_length += len;
	    screen->selection_data[screen->selection_length] = 0;
	}
    }
}

void
AppendToSelectionBuffer(TScreen *screen, unsigned c)
{
    unsigned six;
    Char ch;

    /* Decode base64 character */
    if (c >= 'A' && c <= 'Z')
	six = c - 'A';
    else if (c >= 'a' && c <= 'z')
	six = c - 'a' + 26;
    else if (c >= '0' && c <= '9')
	six = c - '0' + 52;
    else if (c == '+')
	six = 62;
    else if (c == '/')
	six = 63;
    else
	return;

    /* Accumulate bytes */
    switch (screen->base64_count) {
    case 0:
	screen->base64_accu = six;
	screen->base64_count = 6;
	break;

    case 2:
	ch = CharOf((screen->base64_accu << 6) + six);
	screen->base64_count = 0;
	AppendStrToSelectionBuffer(screen, &ch, (size_t) 1);
	break;

    case 4:
	ch = CharOf((screen->base64_accu << 4) + (six >> 2));
	screen->base64_accu = (six & 0x3);
	screen->base64_count = 2;
	AppendStrToSelectionBuffer(screen, &ch, (size_t) 1);
	break;

    case 6:
	ch = CharOf((screen->base64_accu << 2) + (six >> 4));
	screen->base64_accu = (six & 0xF);
	screen->base64_count = 4;
	AppendStrToSelectionBuffer(screen, &ch, (size_t) 1);
	break;
    }
}

void
CompleteSelection(XtermWidget xw, String *args, Cardinal len)
{
    TScreen *screen = TScreenOf(xw);

    screen->base64_count = 0;
    screen->base64_accu = 0;
    _OwnSelection(xw, args, len);
}
#endif /* OPT_PASTE64 */

static Bool
_ConvertSelectionHelper(Widget w,
			Atom *type,
			XtPointer *value,
			unsigned long *length,
			Char *data,
			unsigned long remaining,
			int *format,
			int (*conversion_function) (Display *,
						    char **, int,
						    XICCEncodingStyle,
						    XTextProperty *),
			XICCEncodingStyle conversion_style)
{
    XtermWidget xw;

    *value = 0;
    *length = 0;
    *type = 0;
    *format = 0;

    if ((xw = getXtermWidget(w)) != 0) {
	TScreen *screen = TScreenOf(xw);
	Display *dpy = XtDisplay(w);
	XTextProperty textprop;
	int out_n = 0;
	char *result = 0;
	char *the_data = (char *) data;
	char *the_next;

	TRACE(("converting %ld:'%s'\n",
	       (long) screen->selection_length,
	       visibleChars(screen->selection_data, (unsigned) screen->selection_length)));
	/*
	 * For most selections, we can convert in one pass.  It is possible
	 * that some applications contain embedded nulls, e.g., using xterm's
	 * paste64 feature.  For those cases, we will build up the result in
	 * parts.
	 */
	if (memchr(the_data, 0, screen->selection_length) != 0) {
	    TRACE(("selection contains embedded nulls\n"));
	    result = calloc(screen->selection_length + 1, sizeof(char));
	}

      next_try:
	memset(&textprop, 0, sizeof(textprop));
	if (conversion_function(dpy, &the_data, 1,
				conversion_style,
				&textprop) >= Success) {
	    if ((result != 0)
		&& (textprop.value != 0)
		&& (textprop.format == 8)) {
		char *text_values = (char *) textprop.value;
		unsigned long in_n;

		if (out_n == 0) {
		    *value = result;
		    *type = textprop.encoding;
		    *format = textprop.format;
		}
		for (in_n = 0; in_n < textprop.nitems; ++in_n) {
		    result[out_n++] = text_values[in_n];
		}
		*length += textprop.nitems;
		if ((the_next = memchr(the_data, 0, remaining)) != 0) {
		    unsigned long this_was = (unsigned long) (the_next - the_data);
		    this_was++;
		    the_data += this_was;
		    remaining -= this_was;
		    result[out_n++] = 0;
		    *length += 1;
		    if (remaining)
			goto next_try;
		}
		return True;
	    } else {
		free(result);
		*value = (XtPointer) textprop.value;
		*length = textprop.nitems;
		*type = textprop.encoding;
		*format = textprop.format;
		return True;
	    }
	}
	free(result);
    }
    return False;
}

static Boolean
SaveConvertedLength(XtPointer *target, unsigned long source)
{
    Boolean result = False;

    *target = XtMalloc(4);
    if (*target != 0) {
	result = True;
	if (sizeof(unsigned long) == 4) {
	    *(unsigned long *) *target = source;
	} else if (sizeof(unsigned) == 4) {
	    *(unsigned *) *target = (unsigned) source;
	} else if (sizeof(unsigned short) == 4) {
	    *(unsigned short *) *target = (unsigned short) source;
	} else {
	    /* FIXME - does this depend on byte-order? */
	    unsigned long temp = source;
	    memcpy((char *) *target,
		   ((char *) &temp) + sizeof(temp) - 4,
		   (size_t) 4);
	}
    }
    return result;
}

#define keepClipboard(atom) ((screen->keepClipboard) && \
	 (atom == XInternAtom(screen->display, "CLIPBOARD", False)))

static Boolean
ConvertSelection(Widget w,
		 Atom *selection,
		 Atom *target,
		 Atom *type,
		 XtPointer *value,
		 unsigned long *length,
		 int *format)
{
    Display *dpy = XtDisplay(w);
    TScreen *screen;
    Bool result = False;

    Char *data;
    unsigned long data_length;

    XtermWidget xw;

    if ((xw = getXtermWidget(w)) == 0)
	return False;

    screen = TScreenOf(xw);

    TRACE(("ConvertSelection %s\n",
	   visibleSelectionTarget(dpy, *target)));

    if (keepClipboard(*selection)) {
	TRACE(("asked for clipboard\n"));
	data = screen->clipboard_data;
	data_length = screen->clipboard_size;
    } else {
	TRACE(("asked for selection\n"));
	data = screen->selection_data;
	data_length = screen->selection_length;
    }

    if (data == NULL) {
	TRACE(("...FIXME: no selection_data\n"));
	return False;		/* can this happen? */
    }

    if (*target == XA_TARGETS(dpy)) {
	Atom *targetP;
	XPointer std_return = 0;
	unsigned long std_length;

	if (XmuConvertStandardSelection(w, screen->selection_time, selection,
					target, type, &std_return,
					&std_length, format)) {
	    Atom *my_targets = _SelectionTargets(w);
	    Atom *allocP;
	    Atom *std_targets;

	    TRACE(("XmuConvertStandardSelection - success\n"));
	    std_targets = (Atom *) (void *) (std_return);
	    *length = std_length + 6;

	    targetP = TypeXtMallocN(Atom, *length);
	    allocP = targetP;

	    *value = (XtPointer) targetP;

	    if (my_targets != 0) {
		while (*my_targets != None) {
		    *targetP++ = *my_targets++;
		}
	    }
	    *targetP++ = XA_LENGTH(dpy);
	    *targetP++ = XA_LIST_LENGTH(dpy);

	    *length = std_length + (unsigned long) (targetP - allocP);

	    memcpy(targetP, std_targets, sizeof(Atom) * std_length);
	    XtFree((char *) std_targets);
	    *type = XA_ATOM;
	    *format = 32;
	    result = True;
	} else {
	    TRACE(("XmuConvertStandardSelection - failed\n"));
	}
    }
#if OPT_WIDE_CHARS
    else if (screen->wide_chars && *target == XA_STRING) {
	result =
	    _ConvertSelectionHelper(w,
				    type, value, length, data,
				    data_length, format,
				    Xutf8TextListToTextProperty,
				    XStringStyle);
	TRACE(("...Xutf8TextListToTextProperty:%d\n", result));
    } else if (screen->wide_chars && *target == XA_UTF8_STRING(dpy)) {
	result =
	    _ConvertSelectionHelper(w,
				    type, value, length, data,
				    data_length, format,
				    Xutf8TextListToTextProperty,
				    XUTF8StringStyle);
	TRACE(("...Xutf8TextListToTextProperty:%d\n", result));
    } else if (screen->wide_chars && *target == XA_TEXT(dpy)) {
	result =
	    _ConvertSelectionHelper(w,
				    type, value, length, data,
				    data_length, format,
				    Xutf8TextListToTextProperty,
				    XStdICCTextStyle);
	TRACE(("...Xutf8TextListToTextProperty:%d\n", result));
    } else if (screen->wide_chars && *target == XA_COMPOUND_TEXT(dpy)) {
	result =
	    _ConvertSelectionHelper(w,
				    type, value, length, data,
				    data_length, format,
				    Xutf8TextListToTextProperty,
				    XCompoundTextStyle);
	TRACE(("...Xutf8TextListToTextProperty:%d\n", result));
    }
#endif

    else if (*target == XA_STRING) {	/* not wide_chars */
	/* We can only reach this point if the selection requestor
	   requested STRING before any of TEXT, COMPOUND_TEXT or
	   UTF8_STRING.  We therefore assume that the requestor is not
	   properly internationalised, and dump raw eight-bit data
	   with no conversion into the selection.  Yes, this breaks
	   the ICCCM in non-Latin-1 locales. */
	*type = XA_STRING;
	*value = (XtPointer) screen->selection_data;
	*length = screen->selection_length;
	*format = 8;
	result = True;
	TRACE(("...raw 8-bit data:%d\n", result));
    } else if (*target == XA_TEXT(dpy)) {	/* not wide_chars */
	result =
	    _ConvertSelectionHelper(w,
				    type, value, length, data,
				    data_length, format,
				    XmbTextListToTextProperty,
				    XStdICCTextStyle);
	TRACE(("...XmbTextListToTextProperty(StdICC):%d\n", result));
    } else if (*target == XA_COMPOUND_TEXT(dpy)) {	/* not wide_chars */
	result =
	    _ConvertSelectionHelper(w,
				    type, value, length, data,
				    data_length, format,
				    XmbTextListToTextProperty,
				    XCompoundTextStyle);
	TRACE(("...XmbTextListToTextProperty(Compound):%d\n", result));
    }
#ifdef X_HAVE_UTF8_STRING
    else if (*target == XA_UTF8_STRING(dpy)) {	/* not wide_chars */
	result =
	    _ConvertSelectionHelper(w,
				    type, value, length, data,
				    data_length, format,
				    XmbTextListToTextProperty,
				    XUTF8StringStyle);
	TRACE(("...XmbTextListToTextProperty(UTF8):%d\n", result));
    }
#endif
    else if (*target == XA_LIST_LENGTH(dpy)) {
	result = SaveConvertedLength(value, (unsigned long) 1);
	*type = XA_INTEGER;
	*length = 1;
	*format = 32;
	TRACE(("...list of values:%d\n", result));
    } else if (*target == XA_LENGTH(dpy)) {
	/* This value is wrong if we have UTF-8 text */
	result = SaveConvertedLength(value, screen->selection_length);
	*type = XA_INTEGER;
	*length = 1;
	*format = 32;
	TRACE(("...list of values:%d\n", result));
    } else if (XmuConvertStandardSelection(w,
					   screen->selection_time, selection,
					   target, type, (XPointer *) value,
					   length, format)) {
	result = True;
	TRACE(("...XmuConvertStandardSelection:%d\n", result));
    }

    /* else */
    return (Boolean) result;
}

static void
LoseSelection(Widget w, Atom *selection)
{
    TScreen *screen;
    Atom *atomP;
    Cardinal i;

    XtermWidget xw;

    if ((xw = getXtermWidget(w)) == 0)
	return;

    screen = TScreenOf(xw);
    TRACE(("LoseSelection %s\n", XGetAtomName(screen->display, *selection)));

    for (i = 0, atomP = screen->selection_atoms;
	 i < screen->selection_count; i++, atomP++) {
	if (*selection == *atomP)
	    *atomP = (Atom) 0;
	if (CutBuffer(*atomP) >= 0) {
	    *atomP = (Atom) 0;
	}
    }

    for (i = screen->selection_count; i; i--) {
	if (screen->selection_atoms[i - 1] != 0)
	    break;
    }
    screen->selection_count = i;

    for (i = 0, atomP = screen->selection_atoms;
	 i < screen->selection_count; i++, atomP++) {
	if (*atomP == (Atom) 0) {
	    *atomP = screen->selection_atoms[--screen->selection_count];
	}
    }

    if (screen->selection_count == 0)
	TrackText(xw, &zeroCELL, &zeroCELL);
}

/* ARGSUSED */
static void
SelectionDone(Widget w GCC_UNUSED,
	      Atom *selection GCC_UNUSED,
	      Atom *target GCC_UNUSED)
{
    /* empty proc so Intrinsics know we want to keep storage */
    TRACE(("SelectionDone\n"));
}

static void
_OwnSelection(XtermWidget xw,
	      String *selections,
	      Cardinal count)
{
    TScreen *screen = TScreenOf(xw);
    Atom *atoms = screen->selection_atoms;
    Cardinal i;
    Bool have_selection = False;

    if (count == 0)
	return;

    TRACE(("_OwnSelection count %d, length %ld value %s\n", count,
	   screen->selection_length,
	   visibleChars(screen->selection_data, (unsigned) screen->selection_length)));
    selections = MapSelections(xw, selections, count);

    if (count > screen->sel_atoms_size) {
	XtFree((char *) atoms);
	atoms = TypeXtMallocN(Atom, count);
	screen->selection_atoms = atoms;
	screen->sel_atoms_size = count;
    }
    XmuInternStrings(XtDisplay((Widget) xw), selections, count, atoms);
    for (i = 0; i < count; i++) {
	int cutbuffer = CutBuffer(atoms[i]);
	if (cutbuffer >= 0) {
	    unsigned long limit =
	    (unsigned long) (4 * XMaxRequestSize(XtDisplay((Widget) xw)) - 32);
	    if (screen->selection_length > limit) {
		TRACE(("selection too big (%lu bytes), not storing in CUT_BUFFER%d\n",
		       screen->selection_length, cutbuffer));
		xtermWarning("selection too big (%lu bytes), not storing in CUT_BUFFER%d\n",
			     screen->selection_length, cutbuffer);
	    } else {
		/* This used to just use the UTF-8 data, which was totally
		 * broken as not even the corresponding paste code in xterm
		 * understood this!  So now it converts to Latin1 first.
		 *   Robert Brady, 2000-09-05
		 */
		unsigned long length = screen->selection_length;
		Char *data = screen->selection_data;
		if_OPT_WIDE_CHARS((screen), {
		    data = UTF8toLatin1(screen, data, length, &length);
		});
		TRACE(("XStoreBuffer(%d)\n", cutbuffer));
		XStoreBuffer(XtDisplay((Widget) xw),
			     (char *) data,
			     (int) length,
			     cutbuffer);
	    }
	} else if (keepClipboard(atoms[i])) {
	    Char *buf;
	    TRACE(("saving selection to clipboard buffer\n"));
	    if ((buf = (Char *) malloc((size_t) screen->selection_length))
		== 0)
		SysError(ERROR_BMALLOC2);

	    XtFree((char *) screen->clipboard_data);
	    memcpy(buf, screen->selection_data, screen->selection_length);
	    screen->clipboard_data = buf;
	    screen->clipboard_size = screen->selection_length;
	} else if (screen->selection_length == 0) {
	    XtDisownSelection((Widget) xw, atoms[i], screen->selection_time);
	} else if (!screen->replyToEmacs) {
	    have_selection |=
		XtOwnSelection((Widget) xw, atoms[i],
			       screen->selection_time,
			       ConvertSelection, LoseSelection, SelectionDone);
	}
    }
    if (!screen->replyToEmacs)
	screen->selection_count = count;
    if (!have_selection)
	TrackText(xw, &zeroCELL, &zeroCELL);
}

static void
ResetSelectionState(TScreen *screen)
{
    screen->selection_count = 0;
    screen->startH = zeroCELL;
    screen->endH = zeroCELL;
}

void
DisownSelection(XtermWidget xw)
{
    TScreen *screen = TScreenOf(xw);
    Atom *atoms = screen->selection_atoms;
    Cardinal count = screen->selection_count;
    Cardinal i;

    TRACE(("DisownSelection count %d, start %d.%d, end %d.%d\n",
	   count,
	   screen->startH.row,
	   screen->startH.col,
	   screen->endH.row,
	   screen->endH.col));

    for (i = 0; i < count; i++) {
	int cutbuffer = CutBuffer(atoms[i]);
	if (cutbuffer < 0) {
	    XtDisownSelection((Widget) xw, atoms[i],
			      screen->selection_time);
	}
    }
    /*
     * If none of the callbacks via XtDisownSelection() reset highlighting
     * do it now.
     */
    if (ScrnHaveSelection(screen)) {
	/* save data which will be reset */
	CELL first = screen->startH;
	CELL last = screen->endH;

	ResetSelectionState(screen);
	ReHiliteText(xw, &first, &last);
    } else {
	ResetSelectionState(screen);
    }
}

void
UnhiliteSelection(XtermWidget xw)
{
    TScreen *screen = TScreenOf(xw);

    if (ScrnHaveSelection(screen)) {
	CELL first = screen->startH;
	CELL last = screen->endH;

	screen->startH = zeroCELL;
	screen->endH = zeroCELL;
	ReHiliteText(xw, &first, &last);
    }
}

/* returns number of chars in line from scol to ecol out */
/* ARGSUSED */
static int
Length(TScreen *screen,
       int row,
       int scol,
       int ecol)
{
    CLineData *ld = GET_LINEDATA(screen, row);
    const int lastcol = LastTextCol(screen, ld, row);

    if (ecol > lastcol)
	ecol = lastcol;
    return (ecol - scol + 1);
}

/* copies text into line, preallocated */
static Char *
SaveText(TScreen *screen,
	 int row,
	 int scol,
	 int ecol,
	 Char *lp,		/* pointer to where to put the text */
	 int *eol)
{
    LineData *ld;
    int i = 0;
    Char *result = lp;
#if OPT_WIDE_CHARS
    unsigned previous = 0;
#endif

    ld = GET_LINEDATA(screen, row);
    i = Length(screen, row, scol, ecol);
    ecol = scol + i;
#if OPT_DEC_CHRSET
    if (CSET_DOUBLE(GetLineDblCS(ld))) {
	scol = (scol + 0) / 2;
	ecol = (ecol + 1) / 2;
    }
#endif
    *eol = !LineTstWrapped(ld);
    for (i = scol; i < ecol; i++) {
	unsigned c;
	assert(i < (int) ld->lineSize);
	c = E2A(ld->charData[i]);
#if OPT_WIDE_CHARS
	/* We want to strip out every occurrence of HIDDEN_CHAR AFTER a
	 * wide character.
	 */
	if (c == HIDDEN_CHAR) {
	    if (isWide((int) previous)) {
		previous = c;
		/* Combining characters attached to double-width characters
		   are in memory attached to the HIDDEN_CHAR */
		if_OPT_WIDE_CHARS(screen, {
		    if ((screen->utf8_nrc_mode | screen->utf8_mode) != uFalse) {
			size_t off;
			for_each_combData(off, ld) {
			    unsigned ch = ld->combData[off][i];
			    if (ch == 0)
				break;
			    lp = convertToUTF8(lp, ch);
			}
		    }
		});
		continue;
	    } else {
		c = ' ';	/* should not happen, but just in case... */
	    }
	}
	previous = c;
	if ((screen->utf8_nrc_mode | screen->utf8_mode) != uFalse) {
	    lp = convertToUTF8(lp, (c != 0) ? c : ' ');
	    if_OPT_WIDE_CHARS(screen, {
		size_t off;
		for_each_combData(off, ld) {
		    unsigned ch = ld->combData[off][i];
		    if (ch == 0)
			break;
		    lp = convertToUTF8(lp, ch);
		}
	    });
	} else
#endif
	{
	    if (c == 0) {
		c = E2A(' ');
	    } else if (c < E2A(' ')) {
		c = DECtoASCII(c);
	    } else if (c == 0x7f) {
		c = 0x5f;
	    }
	    *lp++ = CharOf(A2E(c));
	}
	if (c != E2A(' '))
	    result = lp;
    }

    /*
     * If requested, trim trailing blanks from selected lines.  Do not do this
     * if the line is wrapped.
     */
    if (!*eol || !screen->trim_selection)
	result = lp;

    return (result);
}

/* 32 + following 7-bit word:

   1:0  Button no: 0, 1, 2.  3=release.
     2  shift
     3  meta
     4  ctrl
     5  set for motion notify
     6  set for wheel
*/

/* Position: 32 - 255. */
static int
BtnCode(XButtonEvent *event, int button)
{
    int result = (int) (32 + (KeyState(event->state) << 2));

    if (event->type == MotionNotify)
	result += 32;

    if (button < 0 || button > 5) {
	result += 3;
    } else {
	if (button > 3)
	    result += (64 - 4);
	result += button;
    }
    TRACE(("BtnCode button %d, %s state " FMT_MODIFIER_NAMES " ->%#x\n",
	   button,
	   visibleEventType(event->type),
	   ARG_MODIFIER_NAMES(event->state),
	   result));
    return result;
}

static unsigned
EmitButtonCode(TScreen *screen,
	       Char *line,
	       unsigned count,
	       XButtonEvent *event,
	       int button)
{
    int value;

    if (screen->send_mouse_pos == X10_MOUSE) {
	value = CharOf(' ' + button);
    } else {
	value = BtnCode(event, button);
    }

    switch (screen->extend_coords) {
    default:
	line[count++] = CharOf(value);
	break;
    case SET_SGR_EXT_MODE_MOUSE:
	value -= 32;		/* encoding starts at zero */
	/* FALLTHRU */
    case SET_URXVT_EXT_MODE_MOUSE:
	count += (unsigned) sprintf((char *) line + count, "%d", value);
	break;
    case SET_EXT_MODE_MOUSE:
	if (value < 128) {
	    line[count++] = CharOf(value);
	} else {
	    line[count++] = CharOf(0xC0 + (value >> 6));
	    line[count++] = CharOf(0x80 + (value & 0x3F));
	}
	break;
    }
    return count;
}

static int
FirstBitN(int bits)
{
    int result = -1;
    if (bits > 0) {
	result = 0;
	while (!(bits & 1)) {
	    bits /= 2;
	    ++result;
	}
    }
    return result;
}

#define ButtonBit(button) ((button >= 0) ? (1 << (button)) : 0)

#define EMIT_BUTTON(button) EmitButtonCode(screen, line, count, event, button)

static void
EditorButton(XtermWidget xw, XButtonEvent *event)
{
    TScreen *screen = TScreenOf(xw);
    int pty = screen->respond;
    int mouse_limit = MouseLimit(screen);
    Char line[32];
    Char final = 'M';
    int row, col;
    int button;
    unsigned count = 0;
    Boolean changed = True;

    /* If button event, get button # adjusted for DEC compatibility */
    button = (int) (event->button - 1);
    if (button >= 3)
	button++;

    /* Compute character position of mouse pointer */
    row = (event->y - screen->border) / FontHeight(screen);
    col = (event->x - OriginX(screen)) / FontWidth(screen);

    /* Limit to screen dimensions */
    if (row < 0)
	row = 0;
    else if (row > screen->max_row)
	row = screen->max_row;

    if (col < 0)
	col = 0;
    else if (col > screen->max_col)
	col = screen->max_col;

    if (mouse_limit > 0) {
	/* Limit to representable mouse dimensions */
	if (row > mouse_limit)
	    row = mouse_limit;
	if (col > mouse_limit)
	    col = mouse_limit;
    }

    /* Build key sequence starting with \E[M */
    if (screen->control_eight_bits) {
	line[count++] = ANSI_CSI;
    } else {
	line[count++] = ANSI_ESC;
	line[count++] = '[';
    }
    switch (screen->extend_coords) {
    case 0:
    case SET_EXT_MODE_MOUSE:
#if OPT_SCO_FUNC_KEYS
	if (xw->keyboard.type == keyboardIsSCO) {
	    /*
	     * SCO function key F1 is \E[M, which would conflict with xterm's
	     * normal kmous.
	     */
	    line[count++] = '>';
	}
#endif
	line[count++] = final;
	break;
    case SET_SGR_EXT_MODE_MOUSE:
	line[count++] = '<';
	break;
    }

    /* Add event code to key sequence */
    if (screen->send_mouse_pos == X10_MOUSE) {
	count = EMIT_BUTTON(button);
    } else {
	/* Button-Motion events */
	switch (event->type) {
	case ButtonPress:
	    screen->mouse_button |= ButtonBit(button);
	    count = EMIT_BUTTON(button);
	    break;
	case ButtonRelease:
	    /*
	     * Wheel mouse interface generates release-events for buttons
	     * 4 and 5, coded here as 3 and 4 respectively.  We change the
	     * release for buttons 1..3 to a -1, which will be later mapped
	     * into a "0" (some button was released).
	     */
	    screen->mouse_button &= ~ButtonBit(button);
	    if (button < 3) {
		switch (screen->extend_coords) {
		case SET_SGR_EXT_MODE_MOUSE:
		    final = 'm';
		    break;
		default:
		    button = -1;
		    break;
		}
	    }
	    count = EMIT_BUTTON(button);
	    break;
	case MotionNotify:
	    /* BTN_EVENT_MOUSE and ANY_EVENT_MOUSE modes send motion
	     * events only if character cell has changed.
	     */
	    if ((row == screen->mouse_row)
		&& (col == screen->mouse_col)) {
		changed = False;
	    } else {
		count = EMIT_BUTTON(FirstBitN(screen->mouse_button));
	    }
	    break;
	default:
	    changed = False;
	    break;
	}
    }

    if (changed) {
	screen->mouse_row = row;
	screen->mouse_col = col;

	TRACE(("mouse at %d,%d button+mask = %#x\n", row, col, line[count - 1]));

	/* Add pointer position to key sequence */
	count = EmitMousePositionSeparator(screen, line, count);
	count = EmitMousePosition(screen, line, count, col);
	count = EmitMousePositionSeparator(screen, line, count);
	count = EmitMousePosition(screen, line, count, row);

	switch (screen->extend_coords) {
	case SET_SGR_EXT_MODE_MOUSE:
	case SET_URXVT_EXT_MODE_MOUSE:
	    line[count++] = final;
	    break;
	}

	/* Transmit key sequence to process running under xterm */
	v_write(pty, line, count);
    }
    return;
}

#if OPT_FOCUS_EVENT
void
SendFocusButton(XtermWidget xw, XFocusChangeEvent *event)
{
    TScreen *screen = TScreenOf(xw);

    if (screen->send_focus_pos) {
	ANSI reply;

	memset(&reply, 0, sizeof(reply));
	reply.a_type = ANSI_CSI;

#if OPT_SCO_FUNC_KEYS
	if (xw->keyboard.type == keyboardIsSCO) {
	    reply.a_pintro = '>';
	}
#endif
	reply.a_final = CharOf((event->type == FocusIn) ? 'I' : 'O');
	unparseseq(xw, &reply);
    }
    return;
}
#endif /* OPT_FOCUS_EVENT */

#if OPT_SELECTION_OPS
/*
 * Get the event-time, needed to process selections.
 */
static Time
getEventTime(XEvent *event)
{
    Time result;

    if (IsBtnEvent(event)) {
	result = ((XButtonEvent *) event)->time;
    } else if (IsKeyEvent(event)) {
	result = ((XKeyEvent *) event)->time;
    } else {
	result = 0;
    }

    return result;
}

/* obtain the selection string, passing the endpoints to caller's parameters */
static void
doSelectionFormat(XtermWidget xw,
		  Widget w,
		  XEvent *event,
		  String *params,
		  Cardinal *num_params,
		  FormatSelect format_select)
{
    TScreen *screen = TScreenOf(xw);
    InternalSelect *mydata = &(screen->internal_select);

    memset(mydata, 0, sizeof(*mydata));
    mydata->format = x_strdup(params[0]);
    mydata->format_select = format_select;

    /* override flags so that SelectionReceived only updates a buffer */
#if OPT_PASTE64
    mydata->base64_paste = screen->base64_paste;
    screen->base64_paste = 0;
#endif
#if OPT_READLINE
    mydata->paste_brackets = screen->paste_brackets;
    SCREEN_FLAG_unset(screen, paste_brackets);
#endif

    screen->selectToBuffer = True;
    xtermGetSelection(w, getEventTime(event), params + 1, *num_params - 1, NULL);
}

/* obtain data from the screen, passing the endpoints to caller's parameters */
static char *
getDataFromScreen(XtermWidget xw, String method, CELL *start, CELL *finish)
{
    TScreen *screen = TScreenOf(xw);

    CELL save_old_start = screen->startH;
    CELL save_old_end = screen->endH;

    CELL save_startSel = screen->startSel;
    CELL save_startRaw = screen->startRaw;
    CELL save_finishSel = screen->endSel;
    CELL save_finishRaw = screen->endRaw;

    int save_firstValidRow = screen->firstValidRow;
    int save_lastValidRow = screen->lastValidRow;

    const Cardinal noClick = 0;
    int save_numberOfClicks = screen->numberOfClicks;

    SelectUnit saveUnits = screen->selectUnit;
    SelectUnit saveMap = screen->selectMap[noClick];
#if OPT_SELECT_REGEX
    char *saveExpr = screen->selectExpr[noClick];
#endif

    Char *save_selection_data = screen->selection_data;
    int save_selection_size = screen->selection_size;
    unsigned long save_selection_length = screen->selection_length;

    char *result = 0;

    TRACE(("getDataFromScreen %s\n", method));

    screen->selection_data = 0;
    screen->selection_size = 0;
    screen->selection_length = 0;

    screen->numberOfClicks = 1;
    lookupSelectUnit(xw, noClick, method);
    screen->selectUnit = screen->selectMap[noClick];

    memset(start, 0, sizeof(*start));
    start->row = screen->cur_row;
    start->col = screen->cur_col;
    finish->row = screen->cur_row;
    finish->col = screen->max_col;

    ComputeSelect(xw, start, finish, False);
    SaltTextAway(xw, &(screen->startSel), &(screen->endSel));

    if (screen->selection_length && screen->selection_data) {
	TRACE(("...getDataFromScreen selection_data %.*s\n",
	       (int) screen->selection_length,
	       screen->selection_data));
	result = malloc(screen->selection_length + 1);
	if (result) {
	    memcpy(result, screen->selection_data, screen->selection_length);
	    result[screen->selection_length] = 0;
	}
	free(screen->selection_data);
    }

    TRACE(("...getDataFromScreen restoring previous selection\n"));

    screen->startSel = save_startSel;
    screen->startRaw = save_startRaw;
    screen->endSel = save_finishSel;
    screen->endRaw = save_finishRaw;

    screen->firstValidRow = save_firstValidRow;
    screen->lastValidRow = save_lastValidRow;

    screen->numberOfClicks = save_numberOfClicks;
    screen->selectUnit = saveUnits;
    screen->selectMap[noClick] = saveMap;
#if OPT_SELECT_REGEX
    screen->selectExpr[noClick] = saveExpr;
#endif

    screen->selection_data = save_selection_data;
    screen->selection_size = save_selection_size;
    screen->selection_length = save_selection_length;

    TrackText(xw, &save_old_start, &save_old_end);

    TRACE(("...getDataFromScreen done\n"));
    return result;
}

/*
 * Split-up the format before substituting data, to avoid quoting issues.
 * The resource mechanism has a limited ability to handle escapes.  We take
 * the result as if it were an sh-type string and parse it into a regular
 * argv array.
 */
static char **
tokenizeFormat(String format)
{
    char **result = 0;
    int argc;

    format = x_skip_blanks(format);
    if (*format != '\0') {
	char *blob = x_strdup(format);
	int pass;

	for (pass = 0; pass < 2; ++pass) {
	    int used = 0;
	    int first = 1;
	    int escaped = 0;
	    int squoted = 0;
	    int dquoted = 0;
	    int n;

	    argc = 0;
	    for (n = 0; format[n] != '\0'; ++n) {
		if (escaped) {
		    blob[used++] = format[n];
		    escaped = 0;
		} else if (format[n] == '"') {
		    if (!squoted) {
			if (!dquoted)
			    blob[used++] = format[n];
			dquoted = !dquoted;
		    }
		} else if (format[n] == '\'') {
		    if (!dquoted) {
			if (!squoted)
			    blob[used++] = format[n];
			squoted = !squoted;
		    }
		} else if (format[n] == '\\') {
		    blob[used++] = format[n];
		    escaped = 1;
		} else {
		    if (first) {
			first = 0;
			if (pass) {
			    result[argc] = &blob[n];
			}
			++argc;
		    }
		    if (isspace((Char) format[n])) {
			first = !isspace((Char) format[n + 1]);
			if (squoted || dquoted) {
			    blob[used++] = format[n];
			} else if (first) {
			    blob[used++] = '\0';
			}
		    } else {
			blob[used++] = format[n];
		    }
		}
	    }
	    blob[used] = '\0';
	    assert(strlen(blob) <= strlen(format));
	    if (!pass) {
		result = TypeCallocN(char *, argc + 1);
		if (result == 0) {
		    free(blob);
		    break;
		}
	    }
	}
    }
#if OPT_TRACE
    if (result) {
	TRACE(("tokenizeFormat %s\n", format));
	for (argc = 0; result[argc]; ++argc) {
	    TRACE(("argv[%d] = %s\n", argc, result[argc]));
	}
    }
#endif

    return result;
}

static void
formatVideoAttrs(XtermWidget xw, char *buffer, CELL *cell)
{
    TScreen *screen = TScreenOf(xw);
    LineData *ld = GET_LINEDATA(screen, cell->row);

    *buffer = '\0';
    if (ld != 0 && cell->col < (int) ld->lineSize) {
	IAttr attribs = ld->attribs[cell->col];
	const char *delim = "";

	if (attribs & INVERSE) {
	    buffer += sprintf(buffer, "7");
	    delim = ";";
	}
	if (attribs & UNDERLINE) {
	    buffer += sprintf(buffer, "%s4", delim);
	    delim = ";";
	}
	if (attribs & BOLD) {
	    buffer += sprintf(buffer, "%s1", delim);
	    delim = ";";
	}
	if (attribs & BLINK) {
	    buffer += sprintf(buffer, "%s5", delim);
	    delim = ";";
	}
#if OPT_ISO_COLORS
	if (attribs & FG_COLOR) {
	    unsigned fg = extract_fg(xw, ld->color[cell->col], attribs);
	    if (fg < 8) {
		fg += 30;
	    } else if (fg < 16) {
		fg += 90;
	    } else {
		buffer += sprintf(buffer, "%s38;5", delim);
		delim = ";";
	    }
	    buffer += sprintf(buffer, "%s%u", delim, fg);
	    delim = ";";
	}
	if (attribs & BG_COLOR) {
	    unsigned bg = extract_bg(xw, ld->color[cell->col], attribs);
	    if (bg < 8) {
		bg += 40;
	    } else if (bg < 16) {
		bg += 100;
	    } else {
		buffer += sprintf(buffer, "%s48;5", delim);
		delim = ";";
	    }
	    (void) sprintf(buffer, "%s%u", delim, bg);
	}
#endif
    }
}

static char *
formatStrlen(char *target, char *source, int freeit)
{
    if (source != 0) {
	sprintf(target, "%u", (unsigned) strlen(source));
	if (freeit) {
	    free(source);
	}
    } else {
	strcpy(target, "0");
    }
    return target;
}

/* substitute data into format, reallocating the result */
static char *
expandFormat(XtermWidget xw,
	     const char *format,
	     char *data,
	     CELL *start,
	     CELL *finish)
{
    char *result = 0;
    if (!IsEmpty(format)) {
	static char empty[1];
	int pass;
	int n;
	char numbers[80];

	if (data == 0)
	    data = empty;

	for (pass = 0; pass < 2; ++pass) {
	    size_t need = 0;

	    for (n = 0; format[n] != '\0'; ++n) {

		if (format[n] == '%') {
		    char *value = 0;

		    switch (format[++n]) {
		    case '%':
			if (pass) {
			    result[need] = format[n];
			}
			++need;
			break;
		    case 'P':
			sprintf(numbers, "%d;%d",
				TScreenOf(xw)->topline + start->row + 1,
				start->col + 1);
			value = numbers;
			break;
		    case 'p':
			sprintf(numbers, "%d;%d",
				TScreenOf(xw)->topline + finish->row + 1,
				finish->col + 1);
			value = numbers;
			break;
		    case 'R':
			value = formatStrlen(numbers, x_strrtrim(data), 1);
			break;
		    case 'r':
			value = x_strrtrim(data);
			break;
		    case 'S':
			value = formatStrlen(numbers, data, 0);
			break;
		    case 's':
			value = data;
			break;
		    case 'T':
			value = formatStrlen(numbers, x_strtrim(data), 1);
			break;
		    case 't':
			value = x_strtrim(data);
			break;
		    case 'V':
			formatVideoAttrs(xw, numbers, start);
			value = numbers;
			break;
		    case 'v':
			formatVideoAttrs(xw, numbers, finish);
			value = numbers;
			break;
		    default:
			if (pass) {
			    result[need] = format[n];
			}
			--n;
			++need;
			break;
		    }
		    if (value != 0) {
			if (pass) {
			    strcpy(result + need, value);
			}
			need += strlen(value);
			if (value != numbers && value != data) {
			    free(value);
			}
		    }
		} else {
		    if (pass) {
			result[need] = format[n];
		    }
		    ++need;
		}
	    }
	    if (pass) {
		result[need] = '\0';
	    } else {
		++need;
		result = malloc(need);
		if (result == 0) {
		    break;
		}
	    }
	}
    }
    TRACE(("expandFormat(%s) = %s\n", NonNull(format), NonNull(result)));
    return result;
}

/* execute the command after forking.  The main process frees its data */
static void
executeCommand(pid_t pid, char **argv)
{
    (void) pid;
    if (argv != 0 && argv[0] != 0) {
	char *child_cwd = ProcGetCWD(pid);

	if (fork() == 0) {
	    if (child_cwd) {
		IGNORE_RC(chdir(child_cwd));	/* We don't care if this fails */
	    }
	    execvp(argv[0], argv);
	    exit(EXIT_FAILURE);
	}
    }
}

static void
freeArgv(char *blob, char **argv)
{
    if (blob) {
	free(blob);
	if (argv) {
	    int n;
	    for (n = 0; argv[n]; ++n)
		free(argv[n]);
	    free(argv);
	}
    }
}

static void
reallyExecFormatted(Widget w, char *format, char *data, CELL *start, CELL *finish)
{
    XtermWidget xw;

    if ((xw = getXtermWidget(w)) != 0) {
	char **argv;

	if ((argv = tokenizeFormat(format)) != 0) {
	    char *blob = argv[0];
	    int argc;

	    for (argc = 0; argv[argc] != 0; ++argc) {
		argv[argc] = expandFormat(xw, argv[argc], data, start, finish);
	    }
	    executeCommand(TScreenOf(xw)->pid, argv);
	    freeArgv(blob, argv);
	}
    }
}

void
HandleExecFormatted(Widget w,
		    XEvent *event,
		    String *params,	/* selections */
		    Cardinal *num_params)
{
    XtermWidget xw;

    TRACE(("HandleExecFormatted(%d)\n", *num_params));
    if ((xw = getXtermWidget(w)) != 0 &&
	(*num_params > 1)) {
	doSelectionFormat(xw, w, event, params, num_params, reallyExecFormatted);
    }
}

void
HandleExecSelectable(Widget w,
		     XEvent *event GCC_UNUSED,
		     String *params,	/* selections */
		     Cardinal *num_params)
{
    XtermWidget xw;

    if ((xw = getXtermWidget(w)) != 0) {
	TRACE(("HandleExecSelectable(%d)\n", *num_params));

	if (*num_params == 2) {
	    CELL start, finish;
	    char *data;
	    char **argv;

	    data = getDataFromScreen(xw, params[1], &start, &finish);
	    if (data != 0) {
		if ((argv = tokenizeFormat(params[0])) != 0) {
		    char *blob = argv[0];
		    int argc;

		    for (argc = 0; argv[argc] != 0; ++argc) {
			argv[argc] = expandFormat(xw, argv[argc], data,
						  &start, &finish);
		    }
		    executeCommand(TScreenOf(xw)->pid, argv);
		    freeArgv(blob, argv);
		}
		free(data);
	    }
	}
    }
}

static void
reallyInsertFormatted(Widget w, char *format, char *data, CELL *start, CELL *finish)
{
    XtermWidget xw;

    if ((xw = getXtermWidget(w)) != 0) {
	char *exps;

	if ((exps = expandFormat(xw, format, data, start, finish)) != 0) {
	    unparseputs(xw, exps);
	    unparse_end(xw);
	    free(exps);
	}
    }
}

void
HandleInsertFormatted(Widget w,
		      XEvent *event,
		      String *params,	/* selections */
		      Cardinal *num_params)
{
    XtermWidget xw;

    TRACE(("HandleInsertFormatted(%d)\n", *num_params));
    if ((xw = getXtermWidget(w)) != 0 &&
	(*num_params > 1)) {
	doSelectionFormat(xw, w, event, params, num_params, reallyInsertFormatted);
    }
}

void
HandleInsertSelectable(Widget w,
		       XEvent *event GCC_UNUSED,
		       String *params,	/* selections */
		       Cardinal *num_params)
{
    XtermWidget xw;

    if ((xw = getXtermWidget(w)) != 0) {
	TRACE(("HandleInsertSelectable(%d)\n", *num_params));

	if (*num_params == 2) {
	    CELL start, finish;
	    char *data;
	    char *temp = x_strdup(params[0]);

	    data = getDataFromScreen(xw, params[1], &start, &finish);
	    if (data != 0) {
		char *exps = expandFormat(xw, temp, data, &start, &finish);
		if (exps != 0) {
		    unparseputs(xw, exps);
		    unparse_end(xw);
		    free(exps);
		}
		free(data);
	    }
	    free(temp);
	}
    }
}
#endif /* OPT_SELECTION_OPS */
@


1.34
log
@Update to xterm 322. Tested by shadchin@@ and jsg@@. Thanks.
@
text
@d1 1
a1 1
/* $XTermId: button.c,v 1.498 2015/12/31 11:26:38 tom Exp $ */
d4 1
a4 1
 * Copyright 1999-2014,2015 by Thomas E. Dickey
a564 1
    int state;
d645 2
a682 1
    int state;
d706 2
a842 1
    int l1, l2;
d845 1
d847 2
a953 2
	Char Line[6];
	unsigned line, col;
d958 3
a1043 2
	Char Line[6];
	int line;
d1046 1
d1050 1
d1052 2
a1238 2
    const Char *p;

d1273 2
a1533 1
    TScreen *screen;
d1539 1
a1539 1
	screen = TScreenOf(xw);
a1734 1
	struct _SelectionList *list;
d1741 2
a1849 2
    unsigned chr, out, gl, gr;
    Char *p;
d1853 1
d1862 2
d1883 2
d1886 3
a1888 2
	    chr = *p;
	    out = chr;
d1992 1
d1994 1
a2064 1
    size_t src = 0;
d2069 1
d2114 1
a2114 1
    int text_list_count;
a2494 1
    unsigned count;
a2495 1
    Char line[64];
d2503 1
d2506 1
d2509 3
a2511 1
	    count = 0;
a2880 1
    const IAttr *ch;
d2884 1
a3260 2
    char *search;
    int *indexed;
d3269 1
d3275 1
a3372 1
    int length;
d3446 1
a3446 1
	    length = LastTextCol(screen, ld.endSel, screen->endSel.row);
a3624 1
    int i;
d3646 1
a3672 1
    int tmp;
d3679 1
a3999 1
	Atom *allocP;
a4000 1
	Atom *std_targets;
d4008 2
d4247 2
a4248 1
	    if ((buf = (Char *) malloc((size_t) screen->selection_length)) == 0)
a4357 1
    unsigned c;
d4374 1
a4387 1
			unsigned ch;
d4390 1
a4390 1
			    ch = ld->combData[off][i];
a4405 1
		unsigned ch;
d4408 1
a4408 1
		    ch = ld->combData[off][i];
a4841 1
    int pass;
a4842 1
    int n;
d4847 1
d4855 1
a5012 1
		char *value = 0;
d5015 2
d5103 1
a5103 1
executeCommand(char **argv)
d5105 1
d5107 2
d5110 3
a5121 2
    int n;

d5125 1
a5139 2
	char *blob;
	int argc;
d5142 3
a5144 1
	    blob = argv[0];
d5148 1
a5148 1
	    executeCommand(argv);
a5183 2
	    char *blob;
	    int argc;
d5188 3
a5190 1
		    blob = argv[0];
d5195 1
a5195 1
		    executeCommand(argv);
a5249 1
	    char *exps;
d5253 1
a5253 1
		exps = expandFormat(xw, temp, data, &start, &finish);
@


1.33
log
@Update to xterm 320. Tested by jsg@@ Thanks.
@
text
@d1 1
a1 1
/* $XTermId: button.c,v 1.494 2015/08/27 23:47:56 tom Exp $ */
d3832 2
a3852 1
	unsigned long remaining = screen->selection_length;
d3854 1
a3854 1
	char *the_data = (char *) screen->selection_data;
d3941 3
d3957 3
d3970 11
a3980 1
    if (screen->selection_data == NULL) {
d4029 2
a4030 1
				    type, value, length, format,
d4037 2
a4038 1
				    type, value, length, format,
d4045 2
a4046 1
				    type, value, length, format,
d4053 2
a4054 1
				    type, value, length, format,
d4077 2
a4078 1
				    type, value, length, format,
d4085 2
a4086 1
				    type, value, length, format,
d4095 2
a4096 1
				    type, value, length, format,
d4230 10
@


1.32
log
@xterm 314. tested by naddy@@
@
text
@d1 1
a1 1
/* $XTermId: button.c,v 1.491 2014/12/28 22:15:03 tom Exp $ */
d4 1
a4 1
 * Copyright 1999-2013,2014 by Thomas E. Dickey
d3856 3
a3858 2
	TRACE(("converting %ld:'%s'\n", screen->selection_length,
	       visibleChars(screen->selection_data, screen->selection_length)));
d4169 1
a4169 1
	   visibleChars(screen->selection_data, screen->selection_length)));
d4930 14
d4988 6
d4995 1
a4995 2
			sprintf(numbers, "%u", (unsigned) strlen(data));
			value = numbers;
d5001 1
a5001 7
			if ((value = x_strtrim(data)) != 0) {
			    sprintf(numbers, "%u", (unsigned) strlen(value));
			    free(value);
			} else {
			    strcpy(numbers, "0");
			}
			value = numbers;
@


1.31
log
@Update to xterm 313. Tested by shadchin@@
@
text
@d1 1
a1 1
/* $XTermId: button.c,v 1.484 2014/11/13 01:00:26 tom Exp $ */
d1776 1
a1776 1
    TRACE(("Getting %s (%ld)\n", name, (long int) type));
d1806 6
d1824 1
a1824 1
    if (screen->base64_pad & 3)
d1827 2
a1828 1
		   (unsigned) (4 - (screen->base64_pad & 3)));
d1911 2
d1948 1
d1955 1
d1968 2
d1971 1
d2119 2
a2120 1
	|| value == NULL)
d2122 1
d2129 2
a2130 1
    TRACE(("SelectionReceived %s format %d, nitems %ld\n",
d2245 2
a2246 1
    } else
d2248 1
d3841 5
d3850 3
d3854 1
d3856 15
d3874 34
a3907 5
	    *value = (XtPointer) textprop.value;
	    *length = textprop.nitems;
	    *type = textprop.encoding;
	    *format = textprop.format;
	    return True;
d3909 1
a3958 3
    if (screen->selection_data == NULL)
	return False;		/* can this happen? */

d3962 5
d4115 2
d4150 1
a4164 2
    if (screen->selection_length == 0)
	return;
d4166 3
a4168 1
    TRACE(("_OwnSelection count %d\n", count));
d4205 2
@


1.30
log
@Update to xterm 312
@
text
@d1 1
a1 1
/* $XTermId: button.c,v 1.482 2014/09/26 23:58:14 tom Exp $ */
d2844 1
a2844 1
LastTextCol(TScreen *screen, LineData *ld, int row)
d2847 1
a2847 1
    IAttr *ch;
d3173 1
a3173 1
	LineData *ld = GET_LINEDATA(screen, row);
d3203 1
a3203 1
    LineData *ld = 0;
d4209 2
a4210 2
    LineData *ld = GET_LINEDATA(screen, row);
    int lastcol = LastTextCol(screen, ld, row);
@


1.29
log
@Update to xterm 311. ok shadchin@@
@
text
@d1 1
a1 1
/* $XTermId: button.c,v 1.481 2014/09/18 00:17:35 tom Exp $ */
d3260 1
a3260 1
			    if (start_col >= actual &&
@


1.28
log
@Update to xterm-309. Version 308 tested by several people including
naddy@@ who found a small regression, fixed in 309.
@
text
@d1 1
a1 1
/* $XTermId: button.c,v 1.473 2014/05/26 17:12:51 tom Exp $ */
d2180 1
d2182 3
a2184 2
		size_t have = (screen->internal_select
			       ? strlen(screen->internal_select)
d2187 9
a2195 1
		char *buffer = realloc(screen->internal_select, need);
d2198 1
a2198 1
		    screen->internal_select = buffer;
d2200 13
d3230 1
a3230 1
    TRACE(("Select_REGEX:%s\n", NonNull(expr)));
d3260 1
a3260 1
			    if (start_col <= actual &&
d4585 7
a4591 7
static char *
getSelectionString(XtermWidget xw,
		   Widget w,
		   XEvent *event,
		   String *params,
		   Cardinal *num_params,
		   CELL *start, CELL *finish)
d4594 5
a4598 6
#if OPT_PASTE64
    int base64_paste = (int) screen->base64_paste;
#endif
#if OPT_READLINE
    int paste_brackets = (int) SCREEN_FLAG(screen, paste_brackets);
#endif
d4602 1
d4606 1
a4610 1
    screen->internal_select = 0;
a4611 20
    screen->selectToBuffer = False;

    if (screen->internal_select != 0) {
	TRACE(("getSelectionString %d:%s\n",
	       (int) strlen(screen->internal_select),
	       screen->internal_select));
	*start = screen->startSel;
	*finish = screen->endSel;
    } else {
	memset(start, 0, sizeof(*start));
	memset(finish, 0, sizeof(*finish));
    }
#if OPT_PASTE64
    screen->base64_paste = (Cardinal) base64_paste;
#endif
#if OPT_READLINE
    if (paste_brackets)
	SCREEN_FLAG_set(screen, paste_brackets);
#endif
    return screen->internal_select;
d4631 3
d4635 1
a4635 1
    SelectUnit saveMap = screen->selectMap[0];
d4637 1
a4637 1
    char *saveExpr = screen->selectExpr[0];
d4652 3
a4654 2
    lookupSelectUnit(xw, 0, method);
    screen->selectUnit = screen->selectMap[0];
d4659 2
a4660 1
    *finish = *start;
d4687 1
d4689 1
a4689 1
    screen->selectMap[0] = saveMap;
d4691 1
a4691 1
    screen->selectExpr[0] = saveExpr;
d4986 21
d5009 1
a5009 1
		    XEvent *event GCC_UNUSED,
d5015 4
a5018 21
    if ((xw = getXtermWidget(w)) != 0) {
	TRACE(("HandleExecFormatted(%d)\n", *num_params));

	if (*num_params > 1) {
	    CELL start, finish;
	    char *data;
	    char **argv;
	    char *blob;
	    int argc;

	    data = getSelectionString(xw, w, event, params, num_params,
				      &start, &finish);
	    if ((argv = tokenizeFormat(params[0])) != 0) {
		blob = argv[0];
		for (argc = 0; argv[argc] != 0; ++argc) {
		    argv[argc] = expandFormat(xw, argv[argc], data, &start, &finish);
		}
		executeCommand(argv);
		freeArgv(blob, argv);
	    }
	}
d5057 16
d5075 1
a5075 1
		      XEvent *event GCC_UNUSED,
d5081 4
a5084 18
    if ((xw = getXtermWidget(w)) != 0) {
	TRACE(("HandleInsertFormatted(%d)\n", *num_params));

	if (*num_params > 1) {
	    CELL start, finish;
	    char *data;
	    char *temp = x_strdup(params[0]);
	    char *exps;

	    data = getSelectionString(xw, w, event, params, num_params,
				      &start, &finish);
	    if ((exps = expandFormat(xw, temp, data, &start, &finish)) != 0) {
		unparseputs(xw, exps);
		free(exps);
	    }
	    free(data);
	    free(temp);
	}
d5110 1
@


1.27
log
@Update to xterm 304. With help of shadchin@@

tested by ajacoutot@@ and shadchin@@
@
text
@d1 1
a1 1
/* $XTermId: button.c,v 1.467 2014/04/22 00:50:10 tom Exp $ */
d1238 1
a1238 1
	while (decodeUtf8(&data)) {
d1849 1
a1849 1
	    if (!decodeUtf8(data)) {
d2824 1
a2824 1
    Char *ch;
d3232 2
a3233 2
			    int start_inx = match.rm_so + indexed[col];
			    int finis_inx = match.rm_eo + indexed[col];
d4089 1
a4089 1
		 * broken as not even the corresponding paste code in Xterm
d4228 15
a4242 13
	if (c == HIDDEN_CHAR && isWide((int) previous)) {
	    previous = c;
	    /* Combining characters attached to double-width characters
	       are in memory attached to the HIDDEN_CHAR */
	    if_OPT_WIDE_CHARS(screen, {
		if ((screen->utf8_nrc_mode | screen->utf8_mode) != uFalse) {
		    unsigned ch;
		    size_t off;
		    for_each_combData(off, ld) {
			ch = ld->combData[off][i];
			if (ch == 0)
			    break;
			lp = convertToUTF8(lp, ch);
d4244 5
a4248 3
		}
	    });
	    continue;
d4791 1
a4791 1
	Char attribs = ld->attribs[cell->col];
@


1.26
log
@Update to xterm-300. Tested  by ajacoutot@@ and shadchin@@.
@
text
@d1 1
a1 1
/* $XTermId: button.c,v 1.465 2013/11/27 00:43:43 tom Exp $ */
d4 1
a4 1
 * Copyright 1999-2012,2013 by Thomas E. Dickey
d137 2
a138 2
static Bool SendLocatorPosition(XtermWidget xw, XButtonEvent * event);
static void CheckLocatorPosition(XtermWidget xw, XButtonEvent * event);
d154 2
a155 2
static void EditorButton(XtermWidget xw, XButtonEvent * event);
static void EndExtend(XtermWidget w, XEvent * event, String *params, Cardinal
d161 1
a161 1
static void SelectSet(XtermWidget xw, XEvent * event, String *params, Cardinal num_params);
d164 1
a164 1
static void TrackDown(XtermWidget xw, XButtonEvent * event);
d167 1
a167 1
static void do_select_end(XtermWidget xw, XEvent * event, String *params,
d252 1
a252 1
SendMousePosition(XtermWidget xw, XEvent * event)
d355 1
a355 1
SendLocatorPosition(XtermWidget xw, XButtonEvent * event)
d676 1
a676 1
CheckLocatorPosition(XtermWidget xw, XButtonEvent * event)
d729 1
a729 1
isClick1_clean(TScreen *screen, XButtonEvent * event)
d758 1
a758 1
isDoubleClick3(TScreen *screen, XButtonEvent * event)
d797 1
a797 1
CheckSecondPress3(TScreen *screen, XEvent * event)
d866 1
a866 1
eventRow(TScreen *screen, XEvent * event)	/* must be XButtonEvent */
d872 1
a872 1
eventColBetween(TScreen *screen, XEvent * event)	/* must be XButtonEvent */
d916 1
a916 1
readlineExtend(TScreen *screen, XEvent * event)
d942 1
a942 1
	    XEvent * event,	/* must be XButtonEvent */
d973 1
a973 1
	       XEvent * event,	/* must be XButtonEvent */
d1030 1
a1030 1
	 XEvent * event,	/* must be XButtonEvent */
d1069 1
a1069 1
		   XEvent * event,	/* must be XMotionEvent */
d1105 1
a1105 1
			   XEvent * event GCC_UNUSED,	/* must be XButtonEvent */
d1121 1
a1121 1
	      XEvent * event,	/* must be XButtonEvent */
d1146 1
a1146 1
		XEvent * event,	/* must be XButtonEvent */
d1160 1
a1160 1
			XEvent * event,		/* must be XButtonEvent */
d1177 1
a1177 1
		    XEvent * event,
d1378 1
a1378 1
overrideTargets(Widget w, String value, Atom ** resultp)
d1682 1
a1682 1
		  Atom * targets)
d2080 2
a2081 2
		  Atom * selection GCC_UNUSED,
		  Atom * type,
d2231 1
a2231 1
		      XEvent * event,	/* assumed to be XButtonEvent* */
d2293 1
a2293 1
		XEvent * event,	/* must be XButtonEvent* */
d2316 1
a2316 1
		  XEvent * event,	/* must be XButtonEvent* */
d2342 1
a2342 1
			  XEvent * event,	/* must be XButtonEvent* */
d2357 1
a2357 1
TrackDown(XtermWidget xw, XButtonEvent * event)
d2434 1
a2434 1
	  XEvent * event,	/* must be XButtonEvent */
d2527 1
a2527 1
		XEvent * event,
d2542 1
a2542 1
	  XEvent * event GCC_UNUSED,
d2563 1
a2563 1
		XEvent * event,	/* must be XButtonEvent* */
d2664 1
a2664 1
		  XEvent * event,	/* must be XButtonEvent* */
d2678 1
a2678 1
			  XEvent * event,	/* must be XButtonEvent* */
d3787 1
a3787 1
			Atom * type,
d3845 3
a3847 3
		 Atom * selection,
		 Atom * target,
		 Atom * type,
d4005 1
a4005 1
LoseSelection(Widget w, Atom * selection)
d4046 2
a4047 2
	      Atom * selection GCC_UNUSED,
	      Atom * target GCC_UNUSED)
d4297 1
a4297 1
BtnCode(XButtonEvent * event, int button)
d4323 1
a4323 1
	       XButtonEvent * event,
d4375 1
a4375 1
EditorButton(XtermWidget xw, XButtonEvent * event)
d4515 1
a4515 1
SendFocusButton(XtermWidget xw, XFocusChangeEvent * event)
d4542 1
a4542 1
getEventTime(XEvent * event)
d4561 1
a4561 1
		   XEvent * event,
d4975 1
a4975 1
		    XEvent * event GCC_UNUSED,
d5007 1
a5007 1
		     XEvent * event GCC_UNUSED,
a5032 1
		    free(data);
d5034 1
d5042 1
a5042 1
		      XEvent * event GCC_UNUSED,
d5071 1
a5071 1
		       XEvent * event GCC_UNUSED,
@


1.25
log
@Update to xterm 296. Sixel graphics disabled for now.
@
text
@d1 1
a1 1
/* $XTermId: button.c,v 1.458 2013/07/01 00:50:20 tom Exp $ */
d150 4
a153 4
static Char *SaveText(TScreen * screen, int row, int scol, int ecol,
		      Char * lp, int *eol);
static int Length(TScreen * screen, int row, int scol, int ecol);
static void ComputeSelect(XtermWidget xw, CELL * startc, CELL * endc, Bool extend);
d155 1
a155 1
static void EndExtend(XtermWidget w, XEvent * event, String * params, Cardinal
d157 5
a161 5
static void ExtendExtend(XtermWidget xw, const CELL * cell);
static void PointToCELL(TScreen * screen, int y, int x, CELL * cell);
static void ReHiliteText(XtermWidget xw, CELL * first, CELL * last);
static void SaltTextAway(XtermWidget xw, CELL * cellc, CELL * cell);
static void SelectSet(XtermWidget xw, XEvent * event, String * params, Cardinal num_params);
d163 1
a163 1
static void StartSelect(XtermWidget xw, const CELL * cell);
d165 3
a167 3
static void TrackText(XtermWidget xw, const CELL * first, const CELL * last);
static void _OwnSelection(XtermWidget xw, String * selections, Cardinal count);
static void do_select_end(XtermWidget xw, XEvent * event, String * params,
d177 1
a177 1
MouseLimit(TScreen * screen)
d197 1
a197 1
EmitMousePosition(TScreen * screen, Char line[], unsigned count, int value)
d240 1
a240 1
EmitMousePositionSeparator(TScreen * screen, Char line[], unsigned count)
d729 1
a729 1
isClick1_clean(TScreen * screen, XButtonEvent * event)
d758 1
a758 1
isDoubleClick3(TScreen * screen, XButtonEvent * event)
d797 1
a797 1
CheckSecondPress3(TScreen * screen, XEvent * event)
d836 1
a836 1
rowOnCurrentLine(TScreen * screen,
d866 1
a866 1
eventRow(TScreen * screen, XEvent * event)	/* must be XButtonEvent */
d872 1
a872 1
eventColBetween(TScreen * screen, XEvent * event)	/* must be XButtonEvent */
d880 1
a880 1
ReadLineMovePoint(TScreen * screen, int col, int ldelta)
d903 1
a903 1
ReadLineDelete(TScreen * screen, CELL * cell1, CELL * cell2)
d916 1
a916 1
readlineExtend(TScreen * screen, XEvent * event)
d943 1
a943 1
	    String * params GCC_UNUSED,		/* selections */
d974 1
a974 1
	       String * params GCC_UNUSED,	/* selections */
d1031 1
a1031 1
	 String * params GCC_UNUSED,	/* selections */
d1070 1
a1070 1
		   String * params GCC_UNUSED,
d1079 1
a1079 1
	TRACE(("HandleSelectExtend\n"));
d1106 1
a1106 1
			   String * params GCC_UNUSED,
d1122 1
a1122 1
	      String * params,	/* selections */
d1129 1
d1147 1
a1147 1
		String * params,	/* selections */
d1161 1
a1161 1
			String * params,	/* selections */
d1178 1
a1178 1
		    String * params,	/* list of targets */
d1208 1
a1208 1
addXtermChar(Char ** buffer, Cardinal *used, Cardinal offset, unsigned value)
d1225 1
a1225 1
UTF8toLatin1(TScreen * screen, Char * s, unsigned long len, unsigned long *result)
d1453 1
a1453 1
allocUtf8Targets(Widget w, TScreen * screen)
d1489 1
a1489 1
alloc8bitTargets(Widget w, TScreen * screen)
d1573 1
a1573 1
MapSelections(XtermWidget xw, String * params, Cardinal num_params)
d1680 1
a1680 1
		  String * params,	/* selections in precedence order */
d1695 1
a1695 1
    TRACE(("xtermGetSelection num_params %d\n", num_params));
d1769 1
a1769 1
GettingSelection(Display * dpy, Atom type, Char * line, unsigned long len)
d1803 1
a1803 1
base64_flush(TScreen * screen)
d1828 3
d1832 51
a1882 1
_qWriteSelectionData(XtermWidget xw, Char * lag, unsigned length)
d1886 11
d1961 1
a1961 1
_WriteSelectionData(XtermWidget xw, Char * line, size_t length)
d2011 1
a2011 1
_WriteKey(TScreen * screen, const Char * in)
d2058 1
a2058 1
	    else if (screen->utf8_inparse)
d2232 1
a2232 1
		      String * params,	/* selections in precedence order */
d2294 1
a2294 1
		CELL * cell)
d2317 1
a2317 1
		  String * params GCC_UNUSED,
d2343 1
a2343 1
			  String * params GCC_UNUSED,
d2384 1
a2384 1
	   CELL * start,
d2408 1
a2408 1
StartSelect(XtermWidget xw, const CELL * cell)
d2435 1
a2435 1
	  String * params,	/* selections */
d2528 1
a2528 1
		String * params,
d2543 1
a2543 1
	  String * params,
d2564 1
a2564 1
		String * params GCC_UNUSED,
d2631 1
a2631 1
ExtendExtend(XtermWidget xw, const CELL * cell)
d2665 1
a2665 1
		  String * params,	/* unused */
d2679 1
a2679 1
			  String * params,	/* unused */
d2691 1
a2691 1
ScrollSelection(TScreen * screen, int amount, Bool always)
d2745 1
a2745 1
ResizeSelection(TScreen * screen GCC_UNUSED, int rows, int cols)
d2784 1
a2784 1
PointToCELL(TScreen * screen,
d2787 1
a2787 1
	    CELL * cell)
d2821 1
a2821 1
LastTextCol(TScreen * screen, LineData * ld, int row)
d2941 1
a2941 1
class_of(LineData * ld, CELL * cell)
d2972 3
a2974 3
okPosition(TScreen * screen,
	   LineData ** ld,
	   CELL * cell)
d2991 3
a2993 3
trimLastLine(TScreen * screen,
	     LineData ** ld,
	     CELL * last)
d3008 1
a3008 1
firstRowOfLine(TScreen * screen, int row, Bool visible)
d3025 1
a3025 1
lastRowOfLine(TScreen * screen, int row)
d3041 1
a3041 1
lengthOfLines(TScreen * screen, int firstRow, int lastRow)
d3061 1
a3061 1
make_indexed_text(TScreen * screen, int row, unsigned length, int *indexed)
d3147 1
a3147 1
columnToCell(TScreen * screen, int row, int col, CELL * cell)
d3178 1
a3178 1
cellToColumn(TScreen * screen, CELL * cell)
d3197 1
a3197 1
do_select_regex(TScreen * screen, CELL * startc, CELL * endc)
d3310 2
a3311 2
	      CELL * startc,
	      CELL * endc,
d3512 2
a3513 2
	  const CELL * firstp,
	  const CELL * lastp)
d3565 2
a3566 2
	     CELL * firstp,
	     CELL * lastp)
d3611 2
a3612 2
	     CELL * cellc,
	     CELL * cell)
d3687 1
a3687 1
ClearSelectionBuffer(TScreen * screen)
d3694 1
a3694 1
AppendStrToSelectionBuffer(TScreen * screen, Char * text, size_t len)
d3726 1
a3726 1
AppendToSelectionBuffer(TScreen * screen, unsigned c)
d3775 1
a3775 1
CompleteSelection(XtermWidget xw, String * args, Cardinal len)
d4054 1
a4054 1
	      String * selections,
d4118 1
a4118 1
ResetSelectionState(TScreen * screen)
d4181 1
a4181 1
Length(TScreen * screen,
d4196 1
a4196 1
SaveText(TScreen * screen,
d4200 1
a4200 1
	 Char * lp,		/* pointer to where to put the text */
d4233 1
a4233 1
		if (screen->utf8_mode != uFalse) {
d4247 1
a4247 1
	if (screen->utf8_mode != uFalse) {
d4320 2
a4321 2
EmitButtonCode(TScreen * screen,
	       Char * line,
d4562 1
a4562 1
		   String * params,
d4564 1
a4564 1
		   CELL * start, CELL * finish)
d4609 1
a4609 1
getDataFromScreen(XtermWidget xw, String method, CELL * start, CELL * finish)
d4780 1
a4780 1
formatVideoAttrs(XtermWidget xw, char *buffer, CELL * cell)
d4841 2
a4842 2
	     CELL * start,
	     CELL * finish)
d4976 1
a4976 1
		    String * params,	/* selections */
d5008 1
a5008 1
		     String * params,	/* selections */
d5043 1
a5043 1
		      String * params,	/* selections */
d5072 1
a5072 1
		       String * params,		/* selections */
@


1.24
log
@Update to xterm 293. Tested by naddy@@ ajacoutot@@
@
text
@d1 1
a1 1
/* $XTermId: button.c,v 1.456 2013/05/12 22:16:26 tom Exp $ */
a77 1
#include <xcharmouse.h>
a3346 7
	    }
	    /* Clicking on right edge will make endSel.col == screen->max_col,
	     * so clamp it. Otherwise XTERM_CELL and friends will fail assertion
	     */
	    if (screen->endSel.col > screen->max_col) {
		screen->endSel.col = screen->max_col;
		TRACE(("Select_WORD endSel.col clamped to %d\n", screen->endSel.col));
@


1.23
log
@Update to xterm 291. Tested by many.
@
text
@d1 1
a1 1
/* $XTermId: button.c,v 1.451 2013/02/06 09:56:15 tom Exp $ */
d1655 1
d1717 1
a1717 1
	if (nbytes > 0)
d1720 1
a1720 1
	else if (num_params > 1) {
a1727 1
	return;
d1966 44
d2115 1
a2115 1
	    size_t len = strlen(text_list[i]);
d2880 1
d2887 3
a2889 3

    assert(temp.col < (int) ld->lineSize);
    return CharacterClass((int) (ld->charData[temp.col]));
d3348 7
@


1.22
log
@Update to xterm 287. tested by mpi@@ and krw@@.
@
text
@d1 1
a1 1
/* $XTermId: button.c,v 1.435 2012/11/20 01:15:57 tom Exp $ */
d4 1
a4 1
 * Copyright 1999-2011,2012 by Thomas E. Dickey
d1323 5
a1327 4
		data = UTF8toLatin1(screen, data, size, &size);
		memcpy(tmp, data, size + 1);
		new_text_list[i] = tmp;
		tmp += size + 1;
a1348 1
    x_strtrim(value);
d1407 2
a1408 1
			size_t len = strlen(listp);
d1414 1
a1414 1
			else if (sameItem(listp, "UTF8")) {
d1418 1
a1418 1
			else if (sameItem(listp, "I18N")) {
d1423 1
a1423 1
			} else if (sameItem(listp, "TEXT")) {
d1425 1
a1425 1
			} else if (sameItem(listp, "COMPOUND_TEXT")) {
d1427 1
a1427 1
			} else if (sameItem(listp, "STRING")) {
d1432 1
d1442 1
d1603 4
d3781 4
a3784 2
	    while (*my_targets != None) {
		*targetP++ = *my_targets++;
d4192 3
a4199 2
	if (event->type == MotionNotify)
	    result += 32;
d4202 5
d4247 16
d4339 1
a4339 1
	    screen->mouse_button = button;
d4349 1
a4359 1
	    screen->mouse_button = button;
d4370 1
a4370 1
		count = EMIT_BUTTON(screen->mouse_button);
d4536 1
d4652 1
d4841 5
a4845 3
    if (fork() == 0) {
	execvp(argv[0], argv);
	exit(EXIT_FAILURE);
d4884 7
a4890 4
	    argv = tokenizeFormat(params[0]);
	    blob = argv[0];
	    for (argc = 0; argv[argc] != 0; ++argc) {
		argv[argc] = expandFormat(xw, argv[argc], data, &start, &finish);
a4891 2
	    executeCommand(argv);
	    freeArgv(blob, argv);
d4915 11
a4925 4
	    argv = tokenizeFormat(params[0]);
	    blob = argv[0];
	    for (argc = 0; argv[argc] != 0; ++argc) {
		argv[argc] = expandFormat(xw, argv[argc], data, &start, &finish);
a4926 3
	    executeCommand(argv);
	    freeArgv(blob, argv);
	    free(data);
d4946 1
d4950 4
a4953 2
	    temp = expandFormat(xw, temp, data, &start, &finish);
	    unparseputs(xw, temp);
d4975 1
d4978 8
a4985 3
	    temp = expandFormat(xw, temp, data, &start, &finish);
	    unparseputs(xw, temp);
	    free(data);
@


1.21
log
@Update to xterm 279. Tested by krw@@, mpi@@, shadchin@@.
@
text
@d1 1
a1 1
/* $XTermId: button.c,v 1.434 2012/05/10 11:06:10 tom Exp $ */
d1822 1
a1822 1
_qWriteSelectionData(TScreen * screen, Char * lag, unsigned length)
d1824 2
d1832 9
d1890 1
a1890 1
_WriteSelectionData(TScreen * screen, Char * line, size_t length)
d1896 1
d1912 1
a1912 1
	_qWriteSelectionData(screen, lag, (unsigned) (end - lag));
d1922 1
a1922 1
		    _qWriteSelectionData(screen, lag, (unsigned) (cp - lag + 1));
d1929 1
a1929 1
	    _qWriteSelectionData(screen, lag, (unsigned) (end - lag));
d2076 1
a2076 1
		_WriteSelectionData(screen, (Char *) text_list[i], len);
@


1.20
log
@Update to xterm 278. Tested by mpi@@, shadchin@@
@
text
@d1 1
a1 1
/* $XTermId: button.c,v 1.430 2012/01/07 02:00:35 tom Exp $ */
d4 1
a4 1
 * Copyright 1999-2010,2011 by Thomas E. Dickey
d2600 2
a2601 2
	    || !ScrnHaveLineMargins(screen)
	    || ScrnIsLineInMargins(screen, adjust)) {
d2606 2
a2607 2
	    || !ScrnHaveLineMargins(screen)
	    || ScrnIsLineInMargins(screen, adjust)) {
d2733 1
a2733 1
/*  BS   HT   NL   VT   NP   CR   SO   SI */
d4676 1
a4676 2
	    buffer += sprintf(buffer, "%s%u", delim, bg);
	    delim = ";";
@


1.19
log
@Update to xterm 273. Tested by marco@@, jasper@@.
@
text
@d1 1
a1 1
/* $XTermId: button.c,v 1.399 2011/08/19 00:09:26 Marco.Peereboom Exp $ */
d65 1
d123 1
d161 1
a161 2
static void SaltTextAway(XtermWidget xw, CELL * cellc, CELL * cell,
			 String * params, Cardinal num_params);
d177 20
d200 1
a200 3
    int mouse_limit = (screen->ext_mode_mouse
		       ? EXT_MOUSE_LIMIT
		       : MOUSE_LIMIT);
d212 36
a247 8
    if (value == mouse_limit) {
	line[count++] = CharOf(0);
    } else if (!screen->ext_mode_mouse || value < EXT_MOUSE_START) {
	line[count++] = CharOf(' ' + value + 1);
    } else {
	value += ' ' + 1;
	line[count++] = CharOf(0xC0 + (value >> 6));
	line[count++] = CharOf(0x80 + (value & 0x3F));
d1080 2
d1114 2
d1153 1
d1167 1
d1184 1
d2053 13
a2065 1
	    _WriteSelectionData(screen, (Char *) text_list[i], len);
d2111 1
d2199 1
d2223 2
d2315 1
a2315 1
    Char line[20];
d2337 11
a2347 1
		line[count++] = 't';
d2349 1
d2351 7
d2360 11
a2370 1
		line[count++] = 'T';
d2372 1
d2374 1
d2376 1
d2378 1
d2380 1
d2382 7
d2407 1
d2424 2
a2425 1
	SaltTextAway(xw, &(screen->startSel), &(screen->endSel), params, num_params);
d2544 1
d2558 1
d2824 1
a2824 1
    assert(temp.col < ld->lineSize);
d2959 1
a2959 1
		assert(col < ld->lineSize);
d3398 3
d3402 1
a3402 1
	isSameCELL(&last, &old_end))
d3404 2
d3484 1
a3484 3
	     CELL * cell,
	     String * params,	/* selections */
	     Cardinal num_params)
a3554 1
    _OwnSelection(xw, params, num_params);
d3955 2
a3956 3
		fprintf(stderr,
			"%s: selection too big (%lu bytes), not storing in CUT_BUFFER%d\n",
			ProgramName, screen->selection_length, cutbuffer);
d4092 1
a4092 1
	assert(i < ld->lineSize);
d4184 5
a4188 1
EmitButtonCode(TScreen * screen, Char * line, unsigned count, XButtonEvent * event)
d4190 7
a4196 1
    int value = BtnCode(event, screen->mouse_button);
d4198 2
a4199 1
    if (!screen->ext_mode_mouse || value < 128) {
d4201 15
a4215 3
    } else {
	line[count++] = CharOf(0xC0 + (value >> 6));
	line[count++] = CharOf(0x80 + (value & 0x3F));
d4220 2
d4227 3
a4229 2
    int mouse_limit = screen->ext_mode_mouse ? EXT_MOUSE_LIMIT : MOUSE_LIMIT;
    Char line[10];
d4255 7
a4261 5
    /* Limit to representable mouse dimensions */
    if (row > mouse_limit)
	row = mouse_limit;
    if (col > mouse_limit)
	col = mouse_limit;
d4270 3
d4274 13
a4286 6
    if (xw->keyboard.type == keyboardIsSCO) {
	/*
	 * SCO function key F1 is \E[M, which would conflict with xterm's
	 * normal kmous.
	 */
	line[count++] = '>';
a4287 2
#endif
    line[count++] = 'M';
d4291 1
a4291 1
	line[count++] = CharOf(' ' + button);
d4297 1
a4297 1
	    count = EmitButtonCode(screen, line, count, event);
d4303 2
a4304 1
	     * release for buttons 1..3 to a -1.
d4306 10
a4315 2
	    if (button < 3)
		button = -1;
d4317 1
a4317 1
	    count = EmitButtonCode(screen, line, count, event);
d4327 1
a4327 1
		count = EmitButtonCode(screen, line, count, event);
d4343 1
d4345 1
d4348 7
d4384 547
@


1.18
log
@Update to xterm 271. Tested by shadchin@@ and ajacoutot@@
@
text
@d1 1
a1 1
/* $XTermId: button.c,v 1.398 2011/07/04 21:49:39 tom Exp $ */
d2315 1
a2315 1
	DisownSelection(xw);
@


1.17
log
@Update to xterm version 269.
Tested and ok ajacoutot@@, jasper@@, krw@@, shadchin@@
@
text
@d1 1
a1 1
/* $XTermId: button.c,v 1.397 2011/02/13 20:09:31 tom Exp $ */
d1410 2
a1411 1
		result[n++] = XA_UTF8_STRING(XtDisplay(w));
d1413 5
a1417 3
		if (screen->i18nSelections) {
		    result[n++] = XA_TEXT(XtDisplay(w));
		    result[n++] = XA_COMPOUND_TEXT(XtDisplay(w));
a1418 1
#endif
d1446 1
d1448 1
a1448 1
		result[n++] = XA_UTF8_STRING(XtDisplay(w));
d1450 4
a1453 3
		if (screen->i18nSelections) {
		    result[n++] = XA_TEXT(XtDisplay(w));
		    result[n++] = XA_COMPOUND_TEXT(XtDisplay(w));
d1938 1
a1938 1
    if (screen->wide_chars) {
d1946 1
a1946 1
		TRACE(("Conversion failed\n"));
d1969 1
a1969 1
	    if (*type == XA_STRING && screen->brokenSelections) {
@


1.16
log
@Update to xterm 267. Tested by shadchin@@, jasper@@, ajacoutot@@.
@
text
@d1 1
a1 1
/* $XTermId: button.c,v 1.391 2010/11/11 11:50:13 tom Exp $ */
d4 1
a4 1
 * Copyright 1999-2009,2010 by Thomas E. Dickey
d1264 1
a1264 2
	    new_text_list =
		(char **) XtMalloc((Cardinal) sizeof(char *) * (unsigned) *text_list_count);
d1344 1
a1344 2
		result = (Atom *) XtMalloc(((2 * count) + 1)
					   * (Cardinal) sizeof(Atom));
d1356 1
a1356 1
			    ;
d1404 1
a1404 1
	    result = (Atom *) XtMalloc((Cardinal) (5 * sizeof(Atom)));
d1438 1
a1438 1
	    result = (Atom *) XtMalloc((Cardinal) (5 * sizeof(Atom)));
d1683 1
a1683 1
		list = XtNew(struct _SelectionList);
d1985 1
a1985 1
	    ;
d3634 1
a3634 1
	    std_targets = (Atom *) (std_return);
d3637 1
a3637 1
	    targetP = (Atom *) XtMalloc((Cardinal) (sizeof(Atom) * (*length)));
d3822 1
a3822 1
	atoms = (Atom *) XtMalloc((Cardinal) (count * sizeof(Atom)));
d3837 1
a3837 1
			xterm_name, screen->selection_length, cutbuffer);
d4047 1
a4047 2

static Char
d4061 15
a4075 1
    return CharOf(result);
d4141 2
a4142 1
	    line[count++] = BtnCode(event, screen->mouse_button = button);
d4152 2
a4153 1
	    line[count++] = BtnCode(event, screen->mouse_button = button);
d4163 1
a4163 1
		line[count++] = BtnCode(event, screen->mouse_button);
@


1.15
log
@Update to xterm version 264, Tested at least by krw@@, jasper@@, ajacoutot@@.
@
text
@d1 1
a1 1
/* $XTermId: button.c,v 1.389 2010/10/13 09:37:08 tom Exp $ */
d183 4
a186 3
    /* Add pointer position to key sequence

     * In extended mode we encode large positions as two-byte UTF-8 
d215 1
a215 1
	return False;
d219 14
a232 12
	/* xterm extension for motion reporting. June 1998 */
	/* EditorButton() will distinguish between the modes */
	switch (event->type) {
	case MotionNotify:
	    my_event->button = 0;
	    /* FALLTHRU */
	case ButtonPress:
	    /* FALLTHRU */
	case ButtonRelease:
	    EditorButton(xw, my_event);
	    result = True;
	    break;
a238 1

a319 1

d1120 1
a1120 3
 * Like "select-end" (optionally copies the selection to the given targets),
 * but also sets the modes so that releasing the mouse button or moving the
 * mouse does not alter the selection.
a1121 34
static void
do_select_stop(XtermWidget xw,
	       XEvent * event,	/* must be XButtonEvent */
	       String * params,	/* selections */
	       Cardinal *num_params,
	       Bool use_cursor_loc)
{
    TScreen *screen = TScreenOf(xw);

    screen->selection_time = event->xbutton.time;
    switch (screen->eventMode) {
    case NORMAL:
	(void) SendMousePosition(xw, event);
	break;
    case LEFTEXTENSION:
    case RIGHTEXTENSION:
	EndExtend(xw, event, params, *num_params, use_cursor_loc);
	break;
    }
}

void
HandleSelectStop(Widget w,
		 XEvent * event,	/* must be XButtonEvent */
		 String * params,	/* selections */
		 Cardinal *num_params)
{
    XtermWidget xw;

    if ((xw = getXtermWidget(w)) != 0) {
	do_select_stop(xw, event, params, num_params, False);
    }
}

d1123 4
a1126 4
HandleKeyboardSelectStop(Widget w,
			 XEvent * event,	/* must be XButtonEvent */
			 String * params,	/* selections */
			 Cardinal *num_params)
d1131 1
a1131 1
	do_select_stop(xw, event, params, num_params, True);
@


1.14
log
@Update to xterm 262.

tested by ajacoutot@@, jasper@@ and krw@@.
@
text
@d1 1
a1 1
/* $XTermId: button.c,v 1.381 2010/08/23 23:25:57 tom Exp $ */
d118 4
a121 1
#define KeyModifiers (event->xbutton.state & OurModifiers)
d136 2
a137 2
static Bool SendLocatorPosition(XtermWidget xw, XEvent * event);
static void CheckLocatorPosition(XtermWidget xw, XEvent * event);
d208 2
d211 3
a213 2
    /* If send_mouse_pos mode isn't on, we shouldn't be here */
    if (screen->send_mouse_pos == MOUSE_OFF)
d216 16
a231 5
#if OPT_DEC_LOCATOR
    if (screen->send_mouse_pos == DEC_LOCATOR) {
	return (SendLocatorPosition(xw, event));
    }
#endif /* OPT_DEC_LOCATOR */
d233 3
a235 6
    /* Make sure the event is an appropriate type */
    if ((screen->send_mouse_pos != BTN_EVENT_MOUSE)
	&& (screen->send_mouse_pos != ANY_EVENT_MOUSE)
	&& event->type != ButtonPress
	&& event->type != ButtonRelease)
	return False;
d237 2
a238 2
    switch (screen->send_mouse_pos) {
    case X10_MOUSE:		/* X10 compatibility sequences */
d240 6
a245 6
	if (KeyModifiers == 0) {
	    if (event->type == ButtonPress)
		EditorButton(xw, (XButtonEvent *) event);
	    return True;
	}
	return False;
d247 12
a258 12
    case VT200_HIGHLIGHT_MOUSE:	/* DEC vt200 hilite tracking */
	if (event->type == ButtonPress &&
	    KeyModifiers == 0 &&
	    event->xbutton.button == Button1) {
	    TrackDown(xw, (XButtonEvent *) event);
	    return True;
	}
	if (KeyModifiers == 0 || KeyModifiers == ControlMask) {
	    EditorButton(xw, (XButtonEvent *) event);
	    return True;
	}
	return False;
d260 7
a266 1
    case VT200_MOUSE:		/* DEC vt200 compatible */
d268 5
a272 7
	/* xterm extension for motion reporting. June 1998 */
	/* EditorButton() will distinguish between the modes */
    case BTN_EVENT_MOUSE:
    case ANY_EVENT_MOUSE:
	if (KeyModifiers == 0 || KeyModifiers == ControlMask) {
	    if (event->type == MotionNotify) {
		((XButtonEvent *) event)->button = 0;
a273 2
	    EditorButton(xw, (XButtonEvent *) event);
	    return True;
a274 4
	return False;

    default:
	return False;
d276 1
d307 1
a307 1
SendLocatorPosition(XtermWidget xw, XEvent * event)
d317 2
a318 2
    if ((event->type != ButtonPress &&
	 event->type != ButtonRelease &&
d320 1
a320 1
	(KeyModifiers != 0 && KeyModifiers != ControlMask))
d335 1
a335 1
    button = (int) event->xbutton.button - 1;
d337 1
a337 1
    LocatorCoords(row, col, event->xbutton.x, event->xbutton.y, oor);
d393 1
a393 1
    state = (event->xbutton.state
d629 1
a629 1
CheckLocatorPosition(XtermWidget xw, XEvent * event)
d637 1
a637 1
    LocatorCoords(row, col, event->xbutton.x, event->xbutton.y, oor);
d659 1
a659 1
	    ButtonState(state, event->xbutton.state);
d682 1
a682 1
isClick1_clean(TScreen * screen, XEvent * event)
d686 1
a686 1
    if (!(event->type == ButtonPress || event->type == ButtonRelease)
d688 1
a688 1
	|| (KeyModifiers & ShiftMask)
d699 1
a699 1
    } else if (event->xbutton.time > lastButtonDownTime) {
d701 1
a701 1
	delta = (int) (event->xbutton.time - lastButtonDownTime);
d704 1
a704 1
	delta = (int) ((((Time) ~ 0) - lastButtonDownTime) + event->xbutton.time);
d711 1
a711 1
isDoubleClick3(TScreen * screen, XEvent * event)
d716 2
a717 2
	|| (KeyModifiers & ShiftMask)
	|| event->xbutton.button != Button3) {
d725 1
a725 1
    } else if (event->xbutton.time > lastButton3DoubleDownTime) {
d727 1
a727 1
	delta = (int) (event->xbutton.time - lastButton3DoubleDownTime);
d730 1
a730 1
	delta = (int) ((((Time) ~ 0) - lastButton3DoubleDownTime) + event->xbutton.time);
d737 1
a737 1
	PointToCELL(screen, event->xbutton.y, event->xbutton.x, &cell);
d744 2
a745 2
    lastButton3UpTime = event->xbutton.time;
    PointToCELL(screen, event->xbutton.y, event->xbutton.x, &lastButton3);
d755 1
a755 1
	|| (KeyModifiers & ShiftMask)
d864 1
a864 1
	v_write(screen->respond, (Char *) "\177", 1);
d867 23
d906 1
a906 1
	if ((event->type == ButtonPress || event->type == ButtonRelease)
d937 1
a937 1
	if (!(event->type == ButtonPress || event->type == ButtonRelease)
d995 1
a995 1
	if (event->type == ButtonPress || event->type == ButtonRelease) {
a1074 3
#if OPT_READLINE
    int ldelta1, ldelta2;
#endif
d1086 1
a1086 12
	if (isClick1_clean(screen, event)
	    && SCREEN_FLAG(screen, click1_moves)
	    && rowOnCurrentLine(screen, eventRow(screen, event), &ldelta1)) {
	    ReadLineMovePoint(screen, eventColBetween(screen, event), ldelta1);
	}
	if (isDoubleClick3(screen, event)
	    && SCREEN_FLAG(screen, dclick3_deletes)
	    && rowOnCurrentLine(screen, screen->startSel.row, &ldelta1)
	    && rowOnCurrentLine(screen, screen->endSel.row, &ldelta2)) {
	    ReadLineMovePoint(screen, screen->endSel.col, ldelta2);
	    ReadLineDelete(screen, &screen->startSel, &(screen->endSel));
	}
d1118 52
d1213 1
a1213 1
    Char *p;
d1249 1
a1249 1
		for (p = (Char *) screen->default_string; *p != '\0'; ++p) {
d1369 1
a1369 1
	    String copied = x_strdup(value);
d1792 1
a1792 1
		   (Char *) "===",
d1849 1
a1849 1
	    tty_vwrite(screen->respond, (Char *) "\026", 1);	/* Control-V */
d1907 1
a1907 1
_WriteKey(TScreen * screen, Char * in)
d1911 1
a1911 1
    size_t length = strlen((char *) in);
d2027 1
a2027 1
	    _WriteKey(screen, (Char *) "200");
d2041 1
a2041 1
	    _WriteKey(screen, (Char *) "201");
d2082 1
a2082 1
	    if ((event->type == ButtonPress || event->type == ButtonRelease)
d2084 1
a2084 1
		&& !(KeyModifiers & ShiftMask)
d2208 1
a2208 1
	EditorButton(xw, (XButtonEvent *) event);
d2372 1
a2372 1
    if ((KeyModifiers & ShiftMask)
d2388 1
a2388 1
	    &&!(KeyModifiers & ShiftMask))) {
@


1.13
log
@Update to xterm 261. Tested by krw@@, jcs@@.
@
text
@d1 1
a1 1
/* $XTermId: button.c,v 1.377 2010/06/04 09:27:07 tom Exp $ */
d167 34
d2204 1
a2204 1
    Char line[9];
d2227 2
a2228 2
		line[count++] = CharOf(' ' + screen->endSel.col + 1);
		line[count++] = CharOf(' ' + screen->endSel.row + 1);
d2232 6
a2237 6
		line[count++] = CharOf(' ' + screen->startSel.col + 1);
		line[count++] = CharOf(' ' + screen->startSel.row + 1);
		line[count++] = CharOf(' ' + screen->endSel.col + 1);
		line[count++] = CharOf(' ' + screen->endSel.row + 1);
		line[count++] = CharOf(' ' + cell.col + 1);
		line[count++] = CharOf(' ' + cell.row + 1);
a4027 2
#define MOUSE_LIMIT (255 - 32)

d4033 2
a4034 1
    Char line[6];
a4053 2
    else if (row > MOUSE_LIMIT)
	row = MOUSE_LIMIT;
d4059 6
a4064 2
    else if (col > MOUSE_LIMIT)
	col = MOUSE_LIMIT;
d4124 2
d4127 2
a4128 5
	line[count++] = CharOf(' ' + col + 1);
	line[count++] = CharOf(' ' + row + 1);

	TRACE(("mouse at %d,%d button+mask = %#x\n", row, col,
	       (screen->control_eight_bits) ? line[2] : line[3]));
@


1.12
log
@Update to xterm 258. lightly tested by krw@@, thanks.
@
text
@d1 1
a1 1
/* $XTermId: button.c,v 1.375 2010/04/18 17:48:58 tom Exp $ */
d800 1
a800 1
    line[count++] = CharOf(col > 0 ? 'C' : 'D');
d1188 1
a1188 1
		data = UTF8toLatin1(screen, data, size, &size);
d3398 5
a3402 3
	memcpy(screen->selection_data + screen->selection_length, text, len);
	screen->selection_length += len;
	screen->selection_data[screen->selection_length] = 0;
@


1.11
log
@Update to xterm-255. Tested by stsp@@, oga@@.
@
text
@d1 1
a1 1
/* $XTermId: button.c,v 1.364 2010/01/04 23:13:01 tom Exp $ */
d4 1
a4 1
 * Copyright 1999-2008,2009 by Thomas E. Dickey
d349 1
a349 1
    state ^= 1 << button;
d839 4
a842 4
	    line = ((unsigned) (event->xbutton.y - screen->border)
		    / FontHeight(screen));
	    col = ((unsigned) (event->xbutton.x - OriginX(screen))
		   / FontWidth(screen));
d1078 15
a1096 1
#if OPT_WIDE_CHARS
d1098 1
a1098 1
UTF8toLatin1(TScreen * screen, Char * s, unsigned len, unsigned long *result)
d1103 1
a1103 1
    Char *p, *q;
d1105 1
a1105 4
    if (len > used) {
	used = 1 + (2 * len);
	allocXtermChars(&buffer, used);
    }
d1107 1
a1107 1
    if (buffer != 0) {
a1109 1
	q = buffer;
d1118 1
a1118 1
		*q++ = CharOf(value);
d1122 1
a1122 1
		    *q++ = (Char) DECtoASCII(eqv);
d1128 1
a1128 1
			*q++ = (Char) eqv;
d1142 1
a1142 6
		    len = (unsigned) (3 + q - buffer);
		    if (len >= used) {
			used = 1 + (2 * len);
			allocXtermChars(&buffer, used);
		    }
		    *q++ = *p;
d1146 1
a1146 1
		*q++ = ' ';
d1148 2
a1149 2
	*q = 0;
	*result = (unsigned long) (q - buffer);
d1192 2
a1193 2
		(char **) XtMalloc(sizeof(char *) * (unsigned) *text_list_count);
	    new_text_list[0] = tmp = XtMalloc(new_size);
d1272 2
a1273 1
		result = (Atom *) XtMalloc(((2 * count) + 1) * sizeof(Atom));
d1278 1
a1278 1
		    char *listp = copied;
d1427 1
a1427 1
	    free(screen->mappedSelect[n]);
d1487 1
a1487 1
CutBuffer(unsigned code)
d1490 1
a1490 1
    switch (code) {
d1553 2
d1750 1
a1750 1
_WriteSelectionData(TScreen * screen, Char * line, unsigned length)
d1803 1
a1803 1
    unsigned length = strlen((char *) in);
d1923 1
a1923 1
	    unsigned len = strlen(text_list[i]);
d2507 1
a2507 1
    int i;
d2510 8
a2517 7
    if (okScrnRow(screen, row)) {
	for (i = screen->max_col,
	     ch = ld->attribs + i;
	     i >= 0 && !(*ch & CHARDRAWN);
	     ch--, i--) {
	    ;
	}
d2519 4
a2522 2
	if (CSET_DOUBLE(GetLineDblCS(ld))) {
	    i *= 2;
a2523 3
#endif
    } else {
	i = -1;
d2747 1
a2747 1
    unsigned need = (length + 1);
d2792 1
a2792 1
		indexed[used] = last - result;
d2798 1
a2798 1
		indexed[used] = next - result;
d2914 1
a2914 1
				    1, &match, 0) == 0) {
d3328 1
a3328 1
	if ((line = (Char *) malloc((unsigned) j + 1)) == 0)
d3375 1
a3375 1
AppendStrToSelectionBuffer(TScreen * screen, Char * text, unsigned len)
d3384 1
a3384 1
		if ((line = (Char *) malloc((unsigned) k)) == 0)
d3392 1
a3392 1
			    (unsigned) k);
d3434 1
a3434 1
	AppendStrToSelectionBuffer(screen, &ch, 1);
d3441 1
a3441 1
	AppendStrToSelectionBuffer(screen, &ch, 1);
d3448 1
a3448 1
	AppendStrToSelectionBuffer(screen, &ch, 1);
d3508 1
a3508 1
	    *(unsigned *) *target = source;
d3514 3
a3516 1
	    memcpy((char *) *target, ((char *) &temp) + sizeof(temp) - 4, 4);
d3657 1
a3657 1
	result = SaveConvertedLength(value, 1);
d3739 2
@


1.10
log
@Update to xterm 250
@
text
@d1 1
a1 1
/* $XTermId: button.c,v 1.356 2009/10/10 23:37:27 tom Exp $ */
d65 1
d1150 55
d1255 1
a1255 1
	if (value != 0 && *value != '\0') {
d1882 2
a1883 35
		rc = Xutf8TextPropertyToTextList(dpy, &text_prop,
						 &text_list, &text_list_count);
		if (text_list != NULL && text_list_count != 0) {
		    int i;
		    Char *data;
		    char **new_text_list, *tmp;
		    unsigned long size, new_size;
		    /* XLib StringList actually uses only two
		     * pointers, one for the list itself, and one for
		     * the data. Pointer to the data is the first
		     * element of the list, the rest (if any) list
		     * elements point to the same memory block as the
		     * first element
		     */
		    new_size = 0;
		    for (i = 0; i < text_list_count; ++i) {
			data = (Char *) text_list[i];
			size = strlen(text_list[i]) + 1;
			data = UTF8toLatin1(screen, data, size, &size);
			new_size += size + 1;
		    }
		    new_text_list =
			(char **) XtMalloc(sizeof(char *) * (unsigned) text_list_count);
		    new_text_list[0] = tmp = XtMalloc(new_size);
		    for (i = 0; i < text_list_count; ++i) {
			data = (Char *) text_list[i];
			size = strlen(text_list[i]) + 1;
			data = UTF8toLatin1(screen, data, size, &size);
			memcpy(tmp, data, size + 1);
			new_text_list[i] = tmp;
			tmp += size + 1;
		    }
		    XFreeStringList(text_list);
		    text_list = new_text_list;
		}
d1991 1
a1991 1
	delta = xw->screen.multiClickTime + 1;
d2627 1
d2656 5
a2660 3
	cell->col = 0;
	*ld = GET_LINEDATA(screen, ++cell->row);
	result = False;
d2762 1
d2971 3
d3012 1
a3012 1
	fprintf(stderr, "Adjusting start. Changing downwards from %i.\n", first.col);
d3071 2
d3083 2
a3084 1
	    if (screen->endSel.col > length + 1) {
d3101 2
a3102 1
	while (LineTstWrapped(ld.endSel)) {
d3138 1
a3138 1
	    while (screen->endSel.row < screen->max_row &&
d3152 1
a3152 1
	screen->endSel.row = screen->max_row + 1;
d3160 1
a3160 1
	screen->endSel.row = screen->max_row + 1;
d3446 1
a3446 1
CompleteSelection(XtermWidget xw, char **args, Cardinal len)
d3748 2
d3888 1
@


1.9
log
@Update to xterm 248, fixing several bugs including a regression with
copy-and-paste. Works for martynas@@, ok matthieu@@
@
text
@d1 1
a1 1
/* $XTermId: button.c,v 1.352 2009/09/11 09:13:53 tom Exp $ */
d2430 1
a2430 1
    return (i == HIDDEN_CHAR) || ((i >= FIRST_WIDECHAR) && my_wcwidth(i) == 2);
d2627 5
a2631 1
    if (cell->col > (LastTextCol(screen, *ld, cell->row) + 1)) {
d2634 1
a2634 1
	return False;
d2636 1
a2636 1
    return True;
d2644 1
a2644 1
    if (screen->cutNewline) {
@


1.8
log
@update to xterm 246. Has been in snapshots for some time.
@
text
@d1 1
a1 1
/* $XTermId: button.c,v 1.349 2009/08/07 23:24:10 tom Exp $ */
a2592 1
#if OPT_WIDE_CHARS
d2594 1
a2594 1
class_of(TScreen * screen, LineData * ld, CELL * cell)
a2596 1
    int value;
d2604 1
a2604 2
    value = (int) XTERM_CELL(temp.row, temp.col);
    return CharacterClass(value);
d2606 2
a2611 1
#define class_of(screen, ld, cell) charClass[XTERM_CELL((cell)->row, (cell)->col)]
d2613 1
a2613 1
	 (class_of(screen, ld.name, &((screen->name))) == cclass)
d2616 1
a2616 1
#define CClassOf(name) class_of(screen, ld.name, &((screen->name)))
d2730 1
a2730 1
		unsigned data = XTERM_CELL(row, col);
d2746 1
a2746 1
			data = XTERM_CELLC(row, col, off);
d3848 1
a3848 1
	c = E2A(XTERM_CELL(row, i));
d3862 1
a3862 1
			ch = XTERM_CELLC(row, i, off);
d3878 1
a3878 1
		    ch = XTERM_CELLC(row, i, off);
@


1.7
log
@Update to xterm 243. tested by naddy@@.

Patch #243 - 2009/3/28

* revert change to default for allowTcapOps (request by Bram Moolenaar).
* reallocate result returned by xtermEnvLocale() to avoid reference to
freed memory after handling menuLocale resource.
* fix an old (X11R5) bug in tek4014 for switching fontsizes.
* add resource defaultString to make configurable the use of "#" when
pastes of UTF-8 text fail due to limitations in the current locale settings.
* make the set of selection target Atom's configurable by two new
resources eightBitSelectTypes and utf8SelectTypes, e.g., to use the TEXT
Atom in preference to UTF8_STRING (discussion with Stanislav Sedov
regarding koi8rxterm and the FreeBSD port).
* modify handling of TARGETS Atom by making it return exactly the set of
targets as those which xterm is currently providing.
* set MANPAGER and PAGER explicitly to /bin/cat in minstall.sh to work
around /etc/man.conf's with those variables already set (report by
Mar'yasin Semion).
* improve error-checking of tcap-query parser.
* add check for keyboard tcap), which ensures that terminal descriptions
containing the same string for shifted/unshifted keys will be seen by
tcap-query as only the unshifted key. (This would only happen with an
incorrect terminal description).
* fix conversion for input event-state to modifier-parameter which made
tcap-query feature not work with tcapFunctionKeys (keyboard type tcap).
* add "DEF_ALLOW_XXX" definitions to main.h to allow overriding the
default compiled-in values for "allowxxx" resources.
* remove check on bell-percentage added in patch #242, which disallowed
zero/negative values (Redhat Bugzilla #487829).
@
text
@d1 1
a1 1
/* $XTermId: button.c,v 1.320 2009/03/27 00:00:56 tom Exp $ */
d97 16
a112 6
      /*
       * We reserve shift modifier for cut/paste operations.  In principle we
       * can pass through control and meta modifiers, but in practice, the
       * popup menu uses control, and the window manager is likely to use meta,
       * so those events are not delivered to SendMousePosition.
       */
d745 1
d749 19
a767 14
    if (line == screen->cur_row)
	return 1;

    if (line < screen->cur_row)
	l1 = line, l2 = screen->cur_row;
    else
	l2 = line, l1 = screen->cur_row;
    l1--;
    while (++l1 < l2)
	if (!ScrnTstWrapped(screen, l1))
	    return 0;
    /* Everything is on one "wrapped line" now */
    *deltap = line - screen->cur_row;
    return 1;
d886 2
a887 14
	if (line != screen->cur_row) {
	    int l1, l2;

	    if (line < screen->cur_row)
		l1 = line, l2 = screen->cur_row;
	    else
		l2 = line, l1 = screen->cur_row;
	    l1--;
	    while (++l1 < l2)
		if (!ScrnTstWrapped(screen, l1))
		    goto finish;
	    /* Everything is on one "wrapped line" now */
	    ldelta = line - screen->cur_row;
	}
d1271 1
a1271 1
	    result = (Atom *) XtMalloc(5 * sizeof(Atom));
d1305 1
a1305 1
	    result = (Atom *) XtMalloc(5 * sizeof(Atom));
d1578 1
a1578 1
	TRACE(("[%d:%lu]", cp + 1 - line, len));
d2474 1
a2474 1
LastTextCol(TScreen * screen, int row)
a2475 1
    int inx = ROW2INX(screen, row);
d2479 1
a2479 1
    if (inx + screen->savedlines >= 0) {
d2481 1
a2481 1
	     ch = SCRN_BUF_ATTRS(screen, inx) + i;
d2483 3
a2485 1
	     ch--, i--) ;
d2487 1
a2487 1
	if (CSET_DOUBLE(SCRN_BUF_CSETS(screen, inx)[0])) {
d2595 1
a2595 1
class_of(TScreen * screen, CELL * cell)
d2601 1
a2601 1
    if (CSET_DOUBLE(SCRN_BUF_CSETS(screen, ROW2INX(screen, temp.row))[0])) {
a2606 3
    if_OPT_WIDE_CHARS(screen, {
	return CharacterClass(value);
    });
d2609 3
a2611 3
#define ClassSelects(screen, cell, cclass) \
	 (class_of(screen, cell) == cclass \
	 || XTERM_CELL((cell)->row, (cell)->col) == HIDDEN_CHAR)
d2613 3
a2615 3
#define class_of(screen, cell) charClass[XTERM_CELL((cell)->row, (cell)->col)]
#define ClassSelects(screen, cell, cclass) \
	 (class_of(screen, (cell)) == cclass)
d2618 2
d2626 1
d2629 1
a2629 1
    if (cell->col > (LastTextCol(screen, cell->row) + 1)) {
d2631 1
a2631 1
	cell->row += 1;
d2638 3
a2640 1
trimLastLine(TScreen * screen, CELL * last)
d2644 1
a2644 1
	++last->row;
d2646 1
a2646 1
	last->col = LastTextCol(screen, last->row) + 1;
d2657 1
d2661 2
a2662 1
	   ScrnTstWrapped(screen, row - 1))
d2664 1
d2674 2
d2677 2
a2678 1
	   ScrnTstWrapped(screen, row))
d2680 1
d2694 2
a2695 1
	int value = LastTextCol(screen, n);
d2718 1
a2718 1
	need *= (unsigned) (MAX_PTRS * 6);
d2722 1
d2728 1
a2728 1
	    int limit = LastTextCol(screen, row);
d2746 4
a2749 3
		    int off;
		    for (off = OFF_FINAL; off < MAX_PTRS; off += 2) {
			if ((data = XTERM_CELLC(row, col, off)) == 0)
d2764 3
a2766 2
		 ScrnTstWrapped(screen, row) &&
		 ++row < screen->max_row);
d2796 2
a2797 1
	int last = LastTextCol(screen, row);
d2807 1
a2807 1
	if (!ScrnTstWrapped(screen, row)) {
d2826 1
d2830 2
a2831 1
	col += LastTextCol(screen, row++);
d2833 6
d2845 1
d2854 1
a2854 1
    if (okPosition(screen, startc) && expr != 0) {
d2908 1
a2908 3
			       visibleChars(PAIRED_CHARS((Char *) (search +
								   indexed[best_col]),
							 0),
d2916 10
d2933 14
d2958 1
d2963 7
d3001 3
d3006 2
a3007 2
	(void) okPosition(screen, &(screen->startSel));
	(void) okPosition(screen, &(screen->endSel));
d3012 2
a3013 2
	if (okPosition(screen, &(screen->startSel))) {
	    cclass = class_of(screen, &(screen->startSel));
d3016 4
a3019 5
		if (screen->startSel.row > 0
		    && screen->startSel.col < 0
		    && ScrnTstWrapped(screen, screen->startSel.row - 1)) {
		    --screen->startSel.row;
		    screen->startSel.col = LastTextCol(screen, screen->startSel.row);
d3022 1
a3022 1
		     && ClassSelects(screen, &(screen->startSel), cclass));
d3032 3
a3034 3
	if (okPosition(screen, &(screen->endSel))) {
	    length = LastTextCol(screen, screen->endSel.row);
	    cclass = class_of(screen, &(screen->endSel));
d3038 1
a3038 1
		    && ScrnTstWrapped(screen, screen->endSel.row)) {
d3040 2
a3041 2
		    ++screen->endSel.row;
		    length = LastTextCol(screen, screen->endSel.row);
d3044 1
a3044 1
		     && ClassSelects(screen, &(screen->endSel), cclass));
d3051 1
a3051 1
		++screen->endSel.row;
d3066 2
a3067 2
	while (ScrnTstWrapped(screen, screen->endSel.row)) {
	    ++screen->endSel.row;
d3072 2
a3073 3
	    while (screen->startSel.row > 0
		   && ScrnTstWrapped(screen, screen->startSel.row - 1)) {
		--screen->startSel.row;
d3080 2
a3081 3
		while (screen->startSel.row > 0
		       && ScrnTstWrapped(screen, screen->startSel.row - 1)) {
		    --screen->startSel.row;
d3087 1
a3087 1
	trimLastLine(screen, &(screen->endSel));
d3092 1
a3092 1
	if (okPosition(screen, &(screen->startSel))) {
d3095 4
a3098 3
		   (LastTextCol(screen, screen->startSel.row - 1) > 0 ||
		    ScrnTstWrapped(screen, screen->startSel.row - 1))) {
		--screen->startSel.row;
d3103 4
a3106 3
		   (LastTextCol(screen, screen->endSel.row + 1) > 0 ||
		    ScrnTstWrapped(screen, screen->endSel.row))) {
		++screen->endSel.row;
d3108 1
a3108 1
	    trimLastLine(screen, &(screen->endSel));
d3135 2
a3136 1
	return;
d3139 5
a3143 2
    /* check boundaries */
    ScrollSelection(screen, 0, False);
a3144 1
    TrackText(xw, &(screen->startSel), &(screen->endSel));
d3315 2
a3316 2
    TRACE(("Salted TEXT:%d:%s\n", lp - line,
	   visibleChars(PAIRED_CHARS(line, 0), (unsigned) (lp - line))));
d3518 1
a3518 1
	    targetP = (Atom *) XtMalloc(sizeof(Atom) * (*length));
d3701 1
a3701 1
	atoms = (Atom *) XtMalloc(count * sizeof(Atom));
d3809 1
a3809 1
Length(TScreen * screen GCC_UNUSED,
d3814 2
a3815 1
    int lastcol = LastTextCol(screen, row);
d3831 1
d3839 1
d3843 1
a3843 1
    if (CSET_DOUBLE(SCRN_BUF_CSETS(screen, ROW2INX(screen, row))[0])) {
d3848 1
a3848 1
    *eol = !ScrnTstWrapped(screen, row);
d3862 4
a3865 3
		    int off;
		    for (off = OFF_FINAL; off < MAX_PTRS; off += 2) {
			if ((ch = XTERM_CELLC(row, i, off)) == 0)
d3878 4
a3881 3
		int off;
		for (off = OFF_FINAL; off < MAX_PTRS; off += 2) {
		    if ((ch = XTERM_CELLC(row, i, off)) == 0)
@


1.6
log
@Update to xterm 242. Tested by jsg@@.
@
text
@d1 1
a1 1
/* $XTermId: button.c,v 1.306 2009/02/13 21:09:08 tom Exp $ */
d1079 1
a1079 1
UTF8toLatin1(Char * s, unsigned len, unsigned long *result)
d1084 1
a1084 1
    Char *q;
d1097 2
d1101 1
a1101 1
		*q++ = '#';
d1110 5
a1114 3
		    if (eqv == value)
			eqv = '#';
		    *q++ = (Char) eqv;
d1116 17
a1132 1
			*q++ = ' ';
d1135 2
d1147 21
a1167 2
static Atom *
_SelectionTargets(Widget w)
d1169 13
a1181 3
    static Atom *eightBitSelectionTargets = NULL;
    TScreen *screen;
    int n;
d1183 7
d1192 25
a1216 2
    if ((xw = getXtermWidget(w)) == 0)
	return NULL;
d1218 38
a1255 1
    screen = TScreenOf(xw);
d1258 14
a1271 2
    if (screen->wide_chars) {
	static Atom *utf8SelectionTargets = NULL;
d1273 1
a1273 8
	if (utf8SelectionTargets == NULL) {
	    utf8SelectionTargets = (Atom *) XtMalloc(5 * sizeof(Atom));
	    if (utf8SelectionTargets == NULL) {
		TRACE(("Couldn't allocate utf8SelectionTargets\n"));
		return NULL;
	    }
	    n = 0;
	    utf8SelectionTargets[n++] = XA_UTF8_STRING(XtDisplay(w));
d1275 7
a1281 3
	    if (screen->i18nSelections) {
		utf8SelectionTargets[n++] = XA_TEXT(XtDisplay(w));
		utf8SelectionTargets[n++] = XA_COMPOUND_TEXT(XtDisplay(w));
a1282 3
#endif
	    utf8SelectionTargets[n++] = XA_STRING;
	    utf8SelectionTargets[n] = None;
d1284 2
a1285 1
	return utf8SelectionTargets;
d1287 3
d1292 25
a1316 6
    /* not screen->wide_chars */
    if (eightBitSelectionTargets == NULL) {
	eightBitSelectionTargets = (Atom *) XtMalloc(5 * sizeof(Atom));
	if (eightBitSelectionTargets == NULL) {
	    TRACE(("Couldn't allocate eightBitSelectionTargets\n"));
	    return NULL;
d1318 23
a1340 3
	n = 0;
#ifdef X_HAVE_UTF8_STRING
	eightBitSelectionTargets[n++] = XA_UTF8_STRING(XtDisplay(w));
d1342 3
a1344 3
	if (screen->i18nSelections) {
	    eightBitSelectionTargets[n++] = XA_TEXT(XtDisplay(w));
	    eightBitSelectionTargets[n++] = XA_COMPOUND_TEXT(XtDisplay(w));
a1345 2
	eightBitSelectionTargets[n++] = XA_STRING;
	eightBitSelectionTargets[n] = None;
d1347 2
a1348 1
    return eightBitSelectionTargets;
d1490 1
a1490 1
    TRACE(("xtermGetSelection\n"));
d1496 4
a1499 2
    TRACE(("Cutbuffer: %d, target: %lu\n", cutbuffer,
	   targets ? (unsigned long) targets[0] : 0));
d1789 5
d1840 1
a1840 1
			data = UTF8toLatin1(data, size, &size);
d1849 1
a1849 1
			data = UTF8toLatin1(data, size, &size);
d1913 2
d3190 1
d3197 1
a3197 3
	int tmp = first.col;
	first.col = last.col;
	last.col = tmp;
d3436 3
a3445 1
	TRACE(("ConvertSelection XA_TARGETS(dpy)\n"));
d3449 3
d3460 3
a3462 12
	    *targetP++ = XA_STRING;
	    *targetP++ = XA_TEXT(dpy);
#ifdef X_HAVE_UTF8_STRING
	    *targetP++ = XA_COMPOUND_TEXT(dpy);
	    *targetP++ = XA_UTF8_STRING(dpy);
#else
	    *targetP = XA_COMPOUND_TEXT(dpy);
	    if_OPT_WIDE_CHARS(screen, {
		*targetP = XA_UTF8_STRING(dpy);
	    });
	    targetP++;
#endif
d3473 2
a3478 1
	TRACE(("ConvertSelection XA_STRING - wide\n"));
d3484 1
a3485 1
	TRACE(("ConvertSelection XA_UTF8_STRING(dpy) - wide\n"));
d3491 1
a3492 1
	TRACE(("ConvertSelection XA_TEXT(dpy) - wide\n"));
d3498 1
a3499 1
	TRACE(("ConvertSelection XA_COMPOUND_TEXT(dpy) - wide\n"));
d3505 1
a3515 1
	TRACE(("ConvertSelection XA_STRING\n"));
d3521 1
a3522 1
	TRACE(("ConvertSelection XA_TEXT(dpy)\n"));
d3528 1
a3529 1
	TRACE(("ConvertSelection XA_COMPOUND_TEXT(dpy)\n"));
d3535 1
a3538 1
	TRACE(("ConvertSelection XA_UTF8_STRING(dpy)\n"));
d3544 1
a3547 1
	TRACE(("ConvertSelection XA_LIST_LENGTH(dpy)\n"));
d3552 1
a3553 1
	TRACE(("ConvertSelection XA_LENGTH(dpy)\n"));
d3559 1
a3563 1
	TRACE(("ConvertSelection XmuConvertStandardSelection\n"));
d3565 1
d3633 1
a3633 1
    TRACE(("_OwnSelection\n"));
d3661 1
a3661 1
		    data = UTF8toLatin1(data, length, &length);
@


1.5
log
@xterm 239

correct a cast in input.c, which broke translation of numeric
keypad codes to pageup, pagedown, etc., on 64-bit platform (Debian
#511138, report by Larry Doolittle).
@
text
@d1 1
a1 1
/* $XTermId: button.c,v 1.298 2009/01/09 01:29:52 tom Exp $ */
d159 1
a159 1
    TScreen *screen = &(xw->screen);
d252 1
a252 1
    TScreen *screen = &(xw->screen);
d340 3
a342 1
    state = (state & ~(4 | 1)) | ((state & 1) ? 4 : 0) | ((state & 4) ? 1 : 0);
d388 1
a388 1
    TScreen *screen = &xw->screen;
d453 1
a453 1
    TScreen *screen = &xw->screen;
d574 1
a574 1
    TScreen *screen = &(xw->screen);
d812 4
a815 3
    if (IsXtermWidget(w)) {
	XtermWidget xw = (XtermWidget) w;
	TScreen *screen = &(xw->screen);
d843 4
a846 3
    if (IsXtermWidget(w)) {
	XtermWidget xw = (XtermWidget) w;
	TScreen *screen = &(xw->screen);
d912 4
a915 3
    if (IsXtermWidget(w)) {
	XtermWidget xw = (XtermWidget) w;
	TScreen *screen = &(xw->screen);
d951 4
a954 3
    if (IsXtermWidget(w)) {
	XtermWidget xw = (XtermWidget) w;
	TScreen *screen = &(xw->screen);
d985 4
a988 3
    if (IsXtermWidget(w)) {
	XtermWidget xw = (XtermWidget) w;
	TScreen *screen = &xw->screen;
d1003 1
a1003 1
    TScreen *screen = &xw->screen;
d1037 5
a1041 2
    if (IsXtermWidget(w))
	do_select_end((XtermWidget) w, event, params, num_params, False);
d1050 5
a1054 2
    if (IsXtermWidget(w))
	do_select_end((XtermWidget) w, event, params, num_params, True);
d1082 1
a1082 1
    static size_t used;
d1086 3
a1088 4
    if (used == 0) {
	buffer = (Char *) XtMalloc(1 + (used = len));
    } else if (len > used) {
	buffer = (Char *) XtRealloc((char *) buffer, 1 + (used = len));
d1111 1
a1111 1
		    if (iswide((wchar_t) value))
d1132 3
a1134 1
    if (!IsXtermWidget(w))
d1137 1
a1137 1
    screen = TScreenOf((XtermWidget) w);
d1190 1
a1190 1
    TScreen *screen = &(xw->screen);
d1225 2
a1226 1
	    const char *mapTo = (xw->screen.selectToClipboard
d1243 1
a1243 1
		xw->screen.mappedSelect = result;
d1294 6
a1299 4
    TRACE(("FinishPaste64(%d)\n", xw->screen.base64_paste));
    if (xw->screen.base64_paste) {
	xw->screen.base64_paste = 0;
	unparseputc1(xw, xw->screen.base64_final);
d1319 3
a1321 1
    if (!IsXtermWidget(w))
d1325 1
a1325 1
    params = MapSelections((XtermWidget) w, params, num_params);
d1352 1
a1352 1
	    FinishPaste64((XtermWidget) w);
d1603 3
a1605 1
    if (!IsXtermWidget(w))
d1607 2
a1608 1
    screen = TScreenOf((XtermWidget) w);
d1720 1
a1720 1
	    FinishPaste64((XtermWidget) w);
d1745 1
a1745 1
	FinishPaste64((XtermWidget) w);
d1757 1
a1757 2
    if (IsXtermWidget(w)) {
	XtermWidget xw = (XtermWidget) w;
d1759 1
d1763 1
a1763 1
	    TScreen *screen = &(xw->screen);
d1779 1
a1779 1
EvalSelectUnit(TScreen * screen,
d1784 1
d1789 1
a1789 1
	delta = term->screen.multiClickTime + 1;
d1817 1
a1817 1
    TScreen *screen = &(xw->screen);
d1821 1
a1821 1
    screen->selectUnit = EvalSelectUnit(screen,
d1841 4
a1844 3
    if (IsXtermWidget(w)) {
	XtermWidget xw = (XtermWidget) w;
	TScreen *screen = &(xw->screen);
d1866 4
a1869 3
    if (IsXtermWidget(w)) {
	XtermWidget xw = (XtermWidget) w;
	TScreen *screen = &(xw->screen);
d1877 1
a1877 1
    TScreen *screen = &(xw->screen);
d1880 1
a1880 1
    screen->selectUnit = EvalSelectUnit(screen,
d1906 1
a1906 1
    TScreen *screen = &(xw->screen);
d1928 1
a1928 1
    TScreen *screen = &(xw->screen);
d1959 1
a1959 1
    TScreen *screen = &xw->screen;
d2009 4
a2012 2
    if (IsXtermWidget(w)) {
	SelectSet((XtermWidget) w, event, params, *num_params);
d2023 1
a2023 1
    TScreen *screen = &(xw->screen);
d2044 1
a2044 1
    TScreen *screen = &(xw->screen);
a2047 3
    if (!IsXtermWidget(xw))
	return;

d2058 1
a2058 1
	screen->selectUnit = EvalSelectUnit(screen,
d2109 1
a2109 1
    TScreen *screen = &(xw->screen);
d2144 5
a2148 2
    if (IsXtermWidget(w))
	do_start_extend((XtermWidget) w, event, params, num_params, False);
d2157 5
a2161 2
    if (IsXtermWidget(w))
	do_start_extend((XtermWidget) w, event, params, num_params, True);
d2251 1
a2251 1
    return (i == HIDDEN_CHAR) || (my_wcwidth(i) == 2);
d2732 1
a2732 1
    TScreen *screen = &(xw->screen);
d2916 1
a2916 1
    TScreen *screen = &(xw->screen);
d2964 1
a2964 1
    TScreen *screen = &(xw->screen);
d3012 1
a3012 1
    TScreen *screen = &(xw->screen);
d3175 4
a3178 2
    xw->screen.base64_count = 0;
    xw->screen.base64_accu = 0;
d3195 4
a3198 1
    if (IsXtermWidget(w)) {
a3199 1
	TScreen *screen = TScreenOf((XtermWidget) w);
d3252 3
a3254 1
    if (!IsXtermWidget(w))
d3257 1
a3257 1
    screen = TScreenOf((XtermWidget) w);
d3407 3
a3409 1
    if (!IsXtermWidget(w))
d3412 1
a3412 1
    screen = TScreenOf((XtermWidget) w);
d3436 1
a3436 1
	TrackText((XtermWidget) w, &zeroCELL, &zeroCELL);
d3453 1
a3453 1
    TScreen *screen = &(xw->screen);
d3478 1
a3478 1
			"%s: selection too big (%ld bytes), not storing in CUT_BUFFER%d\n",
d3521 1
a3521 1
    TScreen *screen = &(xw->screen);
d3559 1
a3559 1
    TScreen *screen = &(xw->screen);
d3617 1
a3617 1
	if (c == HIDDEN_CHAR && iswide((int) previous)) {
d3706 1
a3706 1
    TScreen *screen = &(xw->screen);
d3813 1
a3813 1
    TScreen *screen = &(xw->screen);
@


1.4
log
@xterm 238. includes fix for CVE-2008-2383.
@
text
@d1 1
a1 1
/* $XTermId: button.c,v 1.297 2008/10/05 23:32:52 tom Exp $ */
d4 1
a4 1
 * Copyright 1999-2007,2008 by Thomas E. Dickey
d337 4
a340 2
    state ^= 1 << button;	/* update mask to "after" state */
    state = (state & ~(4 | 1)) | ((state & 1) ? 4 : 0) | ((state & 4) ? 1 : 0);		/* swap Button1 & Button3 */
@


1.3
log
@xterm-236. Tested by form@@ and simon@@.
@
text
@d1 1
a1 1
/* $XTermId: button.c,v 1.288 2008/07/27 19:36:37 tom Exp $ */
d109 2
a110 1
#define KeyState(x) (((x) & (ShiftMask|ControlMask)) + (((x) & Mod1Mask) ? 2 : 0))
d208 3
d256 1
a256 1
    int state;
d318 1
a318 1
	reply.a_param[0] = 2 + (button << 1);
d321 1
a321 1
	reply.a_param[0] = 3 + (button << 1);
d340 3
a342 3
    reply.a_param[1] = state;
    reply.a_param[2] = row;
    reply.a_param[3] = col;
d432 3
a434 3
    reply.a_param[1] = state;
    reply.a_param[2] = row;
    reply.a_param[3] = col;
d544 3
a546 3
	reply.a_param[1] = state;
	reply.a_param[2] = row;
	reply.a_param[3] = col;
d601 3
a603 3
	    reply.a_param[1] = state;
	    reply.a_param[2] = row;
	    reply.a_param[3] = col;
d814 7
a820 3
	if (event->type == ButtonPress || event->type == ButtonRelease) {
	    line = (event->xbutton.y - screen->border) / FontHeight(screen);
	    col = (event->xbutton.x - OriginX(screen)) / FontWidth(screen);
d1091 1
a1091 1
		    *q++ = DECtoASCII(eqv);
d1096 1
a1096 1
		    *q++ = eqv;
d1103 1
a1103 1
	*result = q - buffer;
d1448 1
a1448 1
		screen->base64_accu = (*p & 0x3);
d1453 3
a1455 2
		buf[x++] = CharOf(base64_code[(screen->base64_accu << 4) + (*p >> 4)]);
		screen->base64_accu = (*p & 0xF);
d1460 2
a1461 1
		buf[x++] = CharOf(base64_code[(screen->base64_accu << 2) + (*p >> 6)]);
d1493 1
a1493 1
_WriteSelectionData(TScreen * screen, Char * line, int length)
d1647 1
a1647 1
			(char **) XtMalloc(sizeof(char *) * text_list_count);
d1691 1
a1691 1
	    int len = strlen(text_list[i]);
d2634 1
a2634 1
		    int len = strlen(search);
d3049 1
a3049 1
    screen->selection_length = (lp - line);
d3065 1
a3065 1
	int j = screen->selection_length + len;		/* New length */
d3094 1
a3094 1
    int six;
d3181 23
d3258 1
a3258 1
	    *length = std_length + (targetP - allocP);
d3339 1
a3339 7
	*value = XtMalloc(4);
	if (sizeof(long) == 4)
	     *(long *) *value = 1;
	else {
	    long temp = 1;
	    memcpy((char *) *value, ((char *) &temp) + sizeof(long) - 4, 4);
	}
a3342 1
	result = True;
d3346 1
a3346 7
	*value = XtMalloc(4);
	if (sizeof(long) == 4) {
	    *(long *) *value = screen->selection_length;
	} else {
	    long temp = screen->selection_length;
	    memcpy((char *) *value, ((char *) &temp) + sizeof(long) - 4, 4);
	}
a3349 1
	result = True;
d3359 1
a3359 1
    return result;
d3418 1
a3418 1
    if (screen->selection_length < 0)
d3434 3
a3436 2
	    if (screen->selection_length >
		4 * XMaxRequestSize(XtDisplay((Widget) xw)) - 32) {
d3438 1
a3438 1
			"%s: selection too big (%d bytes), not storing in CUT_BUFFER%d\n",
d3559 1
a3559 1
    int previous = 0;
d3577 1
a3577 1
	if (c == HIDDEN_CHAR && iswide(previous)) {
d3647 1
a3647 1
    int result = 32 + (KeyState(event->state) << 2);
d3675 1
a3675 1
    button = event->button - 1;
@


1.2
log
@update to xterm 234. tested by merdely@@, 'looks ok' deraadt@@.
@
text
@d1 1
a1 1
/* $XTermId: button.c,v 1.285 2008/02/24 19:42:02 tom Exp $ */
d273 1
a273 1
    button = event->xbutton.button - 1;
d371 1
a371 1
{ (state) = ((mask) & (Button1Mask | Button2Mask | Button3Mask | Button4Mask)) >> 8;	\
d635 1
a635 1
	delta = event->xbutton.time - lastButtonDownTime;
d638 1
a638 1
	delta = (((Time) ~ 0) - lastButtonDownTime) + event->xbutton.time;
d661 1
a661 1
	delta = event->xbutton.time - lastButton3DoubleDownTime;
d664 1
a664 1
	delta = (((Time) ~ 0) - lastButton3DoubleDownTime) + event->xbutton.time;
d700 1
a700 1
	delta = event->xbutton.time - lastButton3UpTime;
d703 1
a703 1
	delta = (((Time) ~ 0) - lastButton3UpTime) + event->xbutton.time;
d775 1
a775 1
    line[count++] = (col > 0 ? 'C' : 'D');
d816 2
a817 2
	    Line[3] = ' ' + col;
	    Line[4] = ' ' + line;
d847 1
a847 1
		delta = event->xbutton.time - lastButtonDownTime;
d850 1
a850 1
		delta = (((Time) ~ 0) - lastButtonDownTime) + event->xbutton.time;
d879 1
a879 1
	Line[2] = (col > 0 ? 'C' : 'D');
d1045 2
a1046 2
	ch = "###########+++++##-##++++|######"[ch];
	/*    01234567890123456789012345678901 */
d1079 1
a1079 1
		*q++ = value;
d1409 1
a1409 1
	x = base64_code[screen->base64_accu << 4];
d1413 1
a1413 1
	x = base64_code[screen->base64_accu << 2];
d1439 1
a1439 1
		buf[x++] = base64_code[*p >> 2];
d1445 1
a1445 1
		buf[x++] = base64_code[(screen->base64_accu << 4) + (*p >> 4)];
d1451 2
a1452 2
		buf[x++] = base64_code[(screen->base64_accu << 2) + (*p >> 6)];
		buf[x++] = base64_code[*p & 0x3F];
d1620 10
a1629 1
		    unsigned long size;
d1632 1
a1632 1
			size = strlen(text_list[i]);
d1634 1
a1634 3
			XFree(text_list[i]);
			text_list[i] = XtMalloc(size + 1);
			memcpy(text_list[i], data, size + 1);
d1636 13
d1760 1
a1760 1
	delta = buttonDownTime - screen->lastButtonUpTime;
d1763 1
a1763 1
	delta = (((Time) ~ 0) - screen->lastButtonUpTime) + buttonDownTime;
d1946 2
a1947 2
		line[count++] = ' ' + screen->endSel.col + 1;
		line[count++] = ' ' + screen->endSel.row + 1;
d1951 6
a1956 6
		line[count++] = ' ' + screen->startSel.col + 1;
		line[count++] = ' ' + screen->startSel.row + 1;
		line[count++] = ' ' + screen->endSel.col + 1;
		line[count++] = ' ' + screen->endSel.row + 1;
		line[count++] = ' ' + cell.col + 1;
		line[count++] = ' ' + cell.row + 1;
d2384 1
a2384 1
    value = XTERM_CELL(temp.row, temp.col);
d2465 1
a2465 1
	    length += (value + 1);
d2486 1
a2486 1
	need *= (MAX_PTRS * 6);
d3109 1
a3109 1
	ch = (screen->base64_accu << 6) + six;
d3115 1
a3115 1
	ch = (screen->base64_accu << 4) + (six >> 2);
d3122 1
a3122 1
	ch = (screen->base64_accu << 2) + (six >> 4);
d3596 1
a3596 1
	    *lp++ = A2E(c);
d3624 1
a3624 1
static int
d3638 1
a3638 1
    return result;
d3698 1
a3698 1
	line[count++] = ' ' + button;
d3737 2
a3738 2
	line[count++] = ' ' + col + 1;
	line[count++] = ' ' + row + 1;
d3766 1
a3766 1
	reply.a_final = (event->type == FocusIn) ? 'I' : 'O';
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/* $XTermId: button.c,v 1.252 2006/07/23 18:37:20 tom Exp $ */
d4 1
a4 1
 * Copyright 1999-2005,2006 by Thomas E. Dickey
a53 1
/* $XFree86: xc/programs/xterm/button.c,v 3.88 2006/06/19 00:36:50 dickey Exp $ */
d71 1
d283 1
a283 1
    reply.a_type = CSI;
d401 1
a401 1
    reply.a_type = CSI;
d471 1
a471 1
	    reply.a_type = CSI;
d537 1
a537 1
	reply.a_type = CSI;
d588 1
a588 1
	reply.a_type = CSI;
d770 1
a770 1
	line[count++] = CSI;
d772 1
a772 1
	line[count++] = ESC;
d814 1
a814 1
	    Line[1] = ESC;
d876 1
a876 1
	Line[0] = ESC;
d910 1
a910 1
		Line[0] = ESC;	/* force an exit from insert-mode */
d942 1
a942 1
	switch (eventMode) {
d985 1
a986 1
#endif
d988 2
a989 2
    xw->screen.selection_time = event->xbutton.time;
    switch (eventMode) {
d1041 9
d1051 2
a1052 1
 * Convert a UTF-8 string to Latin-1, replacing non Latin-1 characters by `#'.
a1060 1
    Char *p = s;
d1064 1
a1064 1
	buffer = (Char *) XtMalloc(used = len);
d1066 1
a1066 1
	buffer = (Char *) XtRealloc((char *) buffer, used = len);
a1067 1
    q = buffer;
d1069 2
a1070 2
    /* We're assuming that the xterm widget never contains Unicode
       control characters. */
d1072 21
a1092 15
    while (p < s + len) {
	if ((*p & 0x80) == 0) {
	    *q++ = *p++;
	} else if ((*p & 0x7C) == 0x40 && p < s + len - 1) {
	    *q++ = ((*p & 0x03) << 6) | (p[1] & 0x3F);
	    p += 2;
	} else if ((*p & 0x60) == 0x40) {
	    *q++ = '#';
	    p += 2;
	} else if ((*p & 0x50) == 0x40) {
	    *q++ = '#';
	    p += 3;
	} else {		/* this cannot happen */
	    *q++ = '#';
	    p++;
d1094 4
a1098 1
    *result = q - buffer;
d1113 1
a1113 1
    screen = &((XtermWidget) w)->screen;
d1201 3
a1203 3
	    String mapTo = (xw->screen.selectToClipboard
			    ? "CLIPBOARD"
			    : "PRIMARY");
d1539 1
a1539 1
	line[count++] = CSI;
d1541 1
a1541 1
	line[count++] = ESC;
d1574 1
a1574 1
    screen = &((XtermWidget) w)->screen;
d1589 1
a1589 1
	if (*type == XA_UTF8_STRING(XtDisplay(w)) ||
d1591 1
a1591 1
	    *type == XA_COMPOUND_TEXT(XtDisplay(w))) {
d1605 1
a1605 6
	/* There's no need to special-case UTF8_STRING.  If Xlib
	   doesn't know about it, we didn't request it.  If a broken
	   selection holder sends it anyhow, the conversion function
	   will fail. */

	if (*type == XA_UTF8_STRING(XtDisplay(w)) ||
d1607 1
a1607 1
	    *type == XA_COMPOUND_TEXT(XtDisplay(w))) {
d1609 1
d1611 21
d1725 4
a1728 1
EvalSelectUnit(TScreen * screen, Time buttonDownTime, SelectUnit defaultUnit)
d1733 3
a1735 1
    if (screen->lastButtonUpTime == (Time) 0) {
d1766 4
a1769 1
    screen->selectUnit = EvalSelectUnit(screen, event->xbutton.time, Select_CHAR);
d1823 4
a1826 1
    screen->selectUnit = EvalSelectUnit(screen, event->time, Select_CHAR);
d1832 1
a1832 1
	waitingForTrackInfo = True;
d1849 5
a1853 2
    if (waitingForTrackInfo) {	/* if Timed, ignore */
	waitingForTrackInfo = False;
a1854 1
	    TScreen *screen = &(xw->screen);
d1884 1
a1884 1
	eventMode = LEFTEXTENSION;
d1887 1
a1887 1
	eventMode = RIGHTEXTENSION;
d1912 1
d1917 1
a1917 1
		line[count++] = CSI;
d1919 1
a1919 1
		line[count++] = ESC;
d1943 1
a1943 1
    eventMode = NORMAL;
d2002 4
a2005 1
	screen->selectUnit = EvalSelectUnit(screen, event->xbutton.time, screen->selectUnit);
d2035 1
a2035 1
	eventMode = LEFTEXTENSION;
d2039 1
a2039 1
	eventMode = RIGHTEXTENSION;
d2057 1
a2057 1
    if (eventMode == LEFTEXTENSION
d2061 1
a2061 1
	eventMode = RIGHTEXTENSION;
d2063 1
a2063 1
    } else if (eventMode == RIGHTEXTENSION
d2066 1
a2066 1
	eventMode = LEFTEXTENSION;
d2069 1
a2069 1
    if (eventMode == LEFTEXTENSION) {
d2484 7
a2490 5
#if OPT_WIDE_CHARS
		next = convertToUTF8(last, data);
#else
		*next++ = CharOf(data);
#endif
d2547 8
d2581 2
a2582 1
    char *expr = screen->selectExpr[screen->numberOfClicks - 1];
d2632 1
d2634 1
a2634 1
			columnToCell(screen, firstRow, best_col + best_len, endc);
d2637 1
a2637 1
			       best_col, best_col + best_len,
d2639 3
a2641 3
			       indexed[best_col + best_len]));
			TRACE(("matched:%.*s\n",
			       indexed[best_col + best_len] + 1 -
d2643 6
a2648 1
			       search + indexed[best_col]));
d3016 3
a3018 1
    TRACE(("Salted TEXT:%d:%.*s\n", lp - line, lp - line, line));
d3132 2
a3133 2
	Display *d = XtDisplay(w);
	TScreen *screen = &((XtermWidget) w)->screen;
d3135 1
d3137 1
a3137 1
	if (conversion_function(d, (char **) &screen->selection_data, 1,
d3159 1
a3159 1
    Display *d = XtDisplay(w);
d3166 1
a3166 1
    screen = &((XtermWidget) w)->screen;
d3171 2
a3172 1
    if (*target == XA_TARGETS(d)) {
d3178 1
a3178 1
	TRACE(("ConvertSelection XA_TARGETS(d)\n"));
d3184 1
d3186 2
d3189 1
d3191 1
a3191 1
	    *targetP++ = XA_TEXT(d);
d3193 2
a3194 2
	    *targetP++ = XA_COMPOUND_TEXT(d);
	    *targetP++ = XA_UTF8_STRING(d);
d3196 1
a3196 1
	    *targetP = XA_COMPOUND_TEXT(d);
d3198 1
a3198 1
		*targetP = XA_UTF8_STRING(d);
d3202 5
a3206 2
	    *targetP++ = XA_LENGTH(d);
	    *targetP++ = XA_LIST_LENGTH(d);
d3222 2
a3223 2
    } else if (screen->wide_chars && *target == XA_UTF8_STRING(d)) {
	TRACE(("ConvertSelection XA_UTF8_STRING(d) - wide\n"));
d3229 2
a3230 2
    } else if (screen->wide_chars && *target == XA_TEXT(d)) {
	TRACE(("ConvertSelection XA_TEXT(d) - wide\n"));
d3236 2
a3237 2
    } else if (screen->wide_chars && *target == XA_COMPOUND_TEXT(d)) {
	TRACE(("ConvertSelection XA_COMPOUND_TEXT(d) - wide\n"));
d3259 2
a3260 2
    } else if (*target == XA_TEXT(d)) {		/* not wide_chars */
	TRACE(("ConvertSelection XA_TEXT(d)\n"));
d3266 2
a3267 2
    } else if (*target == XA_COMPOUND_TEXT(d)) {	/* not wide_chars */
	TRACE(("ConvertSelection XA_COMPOUND_TEXT(d)\n"));
d3275 2
a3276 2
    else if (*target == XA_UTF8_STRING(d)) {	/* not wide_chars */
	TRACE(("ConvertSelection XA_UTF8_STRING(d)\n"));
d3284 2
a3285 2
    else if (*target == XA_LIST_LENGTH(d)) {
	TRACE(("ConvertSelection XA_LIST_LENGTH(d)\n"));
d3297 2
a3298 2
    } else if (*target == XA_LENGTH(d)) {
	TRACE(("ConvertSelection XA_LENGTH(d)\n"));
d3333 1
a3333 1
    screen = &((XtermWidget) w)->screen;
d3476 15
d3543 1
a3543 1
		    int ch;
d3558 1
a3558 1
		int ch;
d3572 1
a3572 4
		if (c == XPOUND)
		    c = 0x23;	/* char on screen is pound sterling */
		else
		    c += 0x5f;	/* char is from DEC drawing set */
d3632 1
d3660 1
a3660 1
	line[count++] = CSI;
d3662 1
a3662 1
	line[count++] = ESC;
d3700 5
a3704 3
		&& (col == screen->mouse_col))
		return;
	    line[count++] = BtnCode(event, screen->mouse_button);
d3707 2
a3708 1
	    return;
d3712 7
a3718 2
    screen->mouse_row = row;
    screen->mouse_col = col;
d3720 2
a3721 3
    /* Add pointer position to key sequence */
    line[count++] = ' ' + col + 1;
    line[count++] = ' ' + row + 1;
d3723 4
a3726 5
    TRACE(("mouse at %d,%d button+mask = %#x\n", row, col,
	   (screen->control_eight_bits) ? line[2] : line[3]));

    /* Transmit key sequence to process running under xterm */
    v_write(pty, line, count);
d3729 1
a3729 2
/*ARGSUSED*/
#if OPT_TEK4014
d3731 13
a3743 18
HandleGINInput(Widget w GCC_UNUSED,
	       XEvent * event GCC_UNUSED,
	       String * param_list,
	       Cardinal *nparamsp)
{
    if (term->screen.TekGIN && *nparamsp == 1) {
	int c = param_list[0][0];
	switch (c) {
	case 'l':
	case 'm':
	case 'r':
	case 'L':
	case 'M':
	case 'R':
	    break;
	default:
	    Bell(XkbBI_MinorError, 0);	/* let them know they goofed */
	    c = 'l';		/* provide a default */
d3745 3
a3747 4
	TekEnqMouse(c | 0x80);
	TekGINoff();
    } else {
	Bell(XkbBI_MinorError, 0);
d3749 1
d3751 1
a3751 1
#endif /* OPT_TEK4014 */
@


1.1.1.1
log
@Importing xterm 216
@
text
@@


1.1.1.2
log
@import xterm 225
@
text
@d1 1
a1 1
/* $XTermId: button.c,v 1.272 2007/03/19 23:42:48 tom Exp $ */
d4 1
a4 1
 * Copyright 1999-2006,2007 by Thomas E. Dickey
a71 1
#include <fontutils.h>
d283 1
a283 1
    reply.a_type = ANSI_CSI;
d401 1
a401 1
    reply.a_type = ANSI_CSI;
d471 1
a471 1
	    reply.a_type = ANSI_CSI;
d537 1
a537 1
	reply.a_type = ANSI_CSI;
d588 1
a588 1
	reply.a_type = ANSI_CSI;
d770 1
a770 1
	line[count++] = ANSI_CSI;
d772 1
a772 1
	line[count++] = ANSI_ESC;
d814 1
a814 1
	    Line[1] = ANSI_ESC;
d876 1
a876 1
	Line[0] = ANSI_ESC;
d910 1
a910 1
		Line[0] = ANSI_ESC;	/* force an exit from insert-mode */
d942 1
a942 1
	switch (screen->eventMode) {
d985 1
a986 1
    TScreen *screen = &xw->screen;
d988 2
a989 2
    screen->selection_time = event->xbutton.time;
    switch (screen->eventMode) {
a1040 9
static int
DECtoASCII(int ch)
{
    if (ch < 32) {
	ch = "###########+++++##-##++++|######"[ch];
	/*    01234567890123456789012345678901 */
    }
    return ch;
}
d1042 1
a1042 2
 * Convert a UTF-8 string to Latin-1, replacing non Latin-1 characters by `#',
 * or ASCII/Latin-1 equivalents for special cases.
d1051 1
d1055 1
a1055 1
	buffer = (Char *) XtMalloc(1 + (used = len));
d1057 1
a1057 1
	buffer = (Char *) XtRealloc((char *) buffer, 1 + (used = len));
d1059 1
d1061 2
a1062 2
    if (buffer != 0) {
	PtyData data;
d1064 15
a1078 21
	q = buffer;
	fakePtyData(&data, s, s + len);
	while (decodeUtf8(&data)) {
	    IChar value = skipPtyData(&data);
	    if (value == UCS_REPL) {
		*q++ = '#';
	    } else if (value < 256) {
		*q++ = value;
	    } else {
		unsigned eqv = ucs2dec(value);
		if (eqv < 32) {
		    *q++ = DECtoASCII(eqv);
		} else {
		    eqv = AsciiEquivs(value);
		    if (eqv == value)
			eqv = '#';
		    *q++ = eqv;
		    if (iswide(value))
			*q++ = ' ';
		}
	    }
a1079 4
	*q = 0;
	*result = q - buffer;
    } else {
	*result = 0;
d1081 1
d1096 1
a1096 1
    screen = TScreenOf((XtermWidget) w);
d1522 1
a1522 1
	line[count++] = ANSI_CSI;
d1524 1
a1524 1
	line[count++] = ANSI_ESC;
d1557 1
a1557 1
    screen = TScreenOf((XtermWidget) w);
d1572 1
a1572 1
	if (*type == XA_UTF8_STRING(dpy) ||
d1574 1
a1574 1
	    *type == XA_COMPOUND_TEXT(dpy)) {
d1588 6
a1593 1
	if (*type == XA_UTF8_STRING(dpy) ||
d1595 1
a1595 1
	    *type == XA_COMPOUND_TEXT(dpy)) {
a1596 1

a1597 20

#if OPT_WIDE_CHARS
	    if (*type == XA_UTF8_STRING(dpy)) {
		rc = Xutf8TextPropertyToTextList(dpy, &text_prop,
						 &text_list, &text_list_count);
		if (text_list != NULL && text_list_count != 0) {
		    int i;
		    Char *data;
		    unsigned long size;
		    for (i = 0; i < text_list_count; ++i) {
			data = (Char *) text_list[i];
			size = strlen(text_list[i]);
			data = UTF8toLatin1(data, size, &size);
			XFree(text_list[i]);
			text_list[i] = XtMalloc(size + 1);
			memcpy(text_list[i], data, size + 1);
		    }
		}
	    } else
#endif
d1787 1
a1787 1
	screen->waitingForTrackInfo = True;
d1804 2
a1805 5
    TScreen *screen = &(xw->screen);

    if (screen->waitingForTrackInfo) {	/* if Timed, ignore */
	screen->waitingForTrackInfo = False;

d1807 1
d1837 1
a1837 1
	screen->eventMode = LEFTEXTENSION;
d1840 1
a1840 1
	screen->eventMode = RIGHTEXTENSION;
d1869 1
a1869 1
		line[count++] = ANSI_CSI;
d1871 1
a1871 1
		line[count++] = ANSI_ESC;
d1895 1
a1895 1
    screen->eventMode = NORMAL;
d1984 1
a1984 1
	screen->eventMode = LEFTEXTENSION;
d1988 1
a1988 1
	screen->eventMode = RIGHTEXTENSION;
d2006 1
a2006 1
    if (screen->eventMode == LEFTEXTENSION
d2010 1
a2010 1
	screen->eventMode = RIGHTEXTENSION;
d2012 1
a2012 1
    } else if (screen->eventMode == RIGHTEXTENSION
d2015 1
a2015 1
	screen->eventMode = LEFTEXTENSION;
d2018 1
a2018 1
    if (screen->eventMode == LEFTEXTENSION) {
a2493 8
	/*
	 * Stop if the current row does not wrap (does not continue the current
	 * line).
	 */
	if (!ScrnTstWrapped(screen, row)) {
	    col = last + 1;
	    break;
	}
d2520 1
a2520 2
    int inx = ((screen->numberOfClicks - 1) % screen->maxClicks);
    char *expr = screen->selectExpr[inx];
d3062 2
a3063 2
	Display *dpy = XtDisplay(w);
	TScreen *screen = TScreenOf((XtermWidget) w);
a3064 1
	char *the_data = (char *) screen->selection_data;
d3066 1
a3066 1
	if (conversion_function(dpy, &the_data, 1,
d3088 1
a3088 1
    Display *dpy = XtDisplay(w);
d3095 1
a3095 1
    screen = TScreenOf((XtermWidget) w);
d3100 1
a3100 1
    if (*target == XA_TARGETS(dpy)) {
d3106 1
a3106 1
	TRACE(("ConvertSelection XA_TARGETS(dpy)\n"));
d3115 1
a3115 1
	    *targetP++ = XA_TEXT(dpy);
d3117 2
a3118 2
	    *targetP++ = XA_COMPOUND_TEXT(dpy);
	    *targetP++ = XA_UTF8_STRING(dpy);
d3120 1
a3120 1
	    *targetP = XA_COMPOUND_TEXT(dpy);
d3122 1
a3122 1
		*targetP = XA_UTF8_STRING(dpy);
d3126 2
a3127 2
	    *targetP++ = XA_LENGTH(dpy);
	    *targetP++ = XA_LIST_LENGTH(dpy);
d3143 2
a3144 2
    } else if (screen->wide_chars && *target == XA_UTF8_STRING(dpy)) {
	TRACE(("ConvertSelection XA_UTF8_STRING(dpy) - wide\n"));
d3150 2
a3151 2
    } else if (screen->wide_chars && *target == XA_TEXT(dpy)) {
	TRACE(("ConvertSelection XA_TEXT(dpy) - wide\n"));
d3157 2
a3158 2
    } else if (screen->wide_chars && *target == XA_COMPOUND_TEXT(dpy)) {
	TRACE(("ConvertSelection XA_COMPOUND_TEXT(dpy) - wide\n"));
d3180 2
a3181 2
    } else if (*target == XA_TEXT(dpy)) {	/* not wide_chars */
	TRACE(("ConvertSelection XA_TEXT(dpy)\n"));
d3187 2
a3188 2
    } else if (*target == XA_COMPOUND_TEXT(dpy)) {	/* not wide_chars */
	TRACE(("ConvertSelection XA_COMPOUND_TEXT(dpy)\n"));
d3196 2
a3197 2
    else if (*target == XA_UTF8_STRING(dpy)) {	/* not wide_chars */
	TRACE(("ConvertSelection XA_UTF8_STRING(dpy)\n"));
d3205 2
a3206 2
    else if (*target == XA_LIST_LENGTH(dpy)) {
	TRACE(("ConvertSelection XA_LIST_LENGTH(dpy)\n"));
d3218 2
a3219 2
    } else if (*target == XA_LENGTH(dpy)) {
	TRACE(("ConvertSelection XA_LENGTH(dpy)\n"));
d3254 1
a3254 1
    screen = TScreenOf((XtermWidget) w);
d3478 4
a3481 1
		c = DECtoASCII(c);
a3540 1
    Boolean changed = True;
d3568 1
a3568 1
	line[count++] = ANSI_CSI;
d3570 1
a3570 1
	line[count++] = ANSI_ESC;
d3608 3
a3610 5
		&& (col == screen->mouse_col)) {
		changed = False;
	    } else {
		line[count++] = BtnCode(event, screen->mouse_button);
	    }
d3613 1
a3613 2
	    changed = False;
	    break;
d3617 2
a3618 7
    if (changed) {
	screen->mouse_row = row;
	screen->mouse_col = col;

	/* Add pointer position to key sequence */
	line[count++] = ' ' + col + 1;
	line[count++] = ' ' + row + 1;
d3620 3
a3622 2
	TRACE(("mouse at %d,%d button+mask = %#x\n", row, col,
	       (screen->control_eight_bits) ? line[2] : line[3]));
d3624 5
a3628 4
	/* Transmit key sequence to process running under xterm */
	v_write(pty, line, count);
    }
    return;
d3631 2
a3632 1
#if OPT_FOCUS_EVENT
d3634 18
a3651 13
SendFocusButton(XtermWidget xw, XFocusChangeEvent * event)
{
    TScreen *screen = &(xw->screen);

    if (screen->send_focus_pos) {
	ANSI reply;

	memset(&reply, 0, sizeof(reply));
	reply.a_type = ANSI_CSI;

#if OPT_SCO_FUNC_KEYS
	if (xw->keyboard.type == keyboardIsSCO) {
	    reply.a_pintro = '>';
d3653 4
a3656 3
#endif
	reply.a_final = (event->type == FocusIn) ? 'I' : 'O';
	unparseseq(xw, &reply);
a3657 1
    return;
d3659 1
a3659 1
#endif /* OPT_FOCUS_EVENT */
@


1.1.1.3
log
@import xterm 229
@
text
@d1 1
a1 1
/* $XTermId: button.c,v 1.277 2007/07/22 20:37:11 tom Exp $ */
d54 1
d1042 2
a1043 2
static unsigned
DECtoASCII(unsigned ch)
d1090 1
a1090 1
		    if (iswide((wchar_t) value))
d1614 1
a1614 2
	    if (*type == XA_UTF8_STRING(dpy) &&
		!(screen->wide_chars || screen->c1_printable)) {
a2614 1
			int best_nxt = best_col + best_len;
d2616 1
a2616 1
			columnToCell(screen, firstRow, best_nxt, endc);
d2619 1
a2619 1
			       best_col, best_nxt,
d2621 3
a2623 3
			       indexed[best_nxt]));
			TRACE(("matched:%d:%s\n",
			       indexed[best_nxt] + 1 -
d2625 1
a2625 6
			       visibleChars(PAIRED_CHARS((Char *) (search +
								   indexed[best_col]),
							 0),
					    (unsigned) (indexed[best_nxt] +
							1 -
							indexed[best_col]))));
d2993 1
a2993 3
    TRACE(("Salted TEXT:%d:%s\n", lp - line,
	   visibleChars(PAIRED_CHARS(line, 0), (unsigned) (lp - line))));

d3495 1
a3495 1
		    unsigned ch;
d3510 1
a3510 1
		unsigned ch;
@


1.1.1.4
log
@Import xterm version 232. tested by many.
@
text
@d1 1
a1 1
/* $XTermId: button.c,v 1.283 2008/01/07 22:56:37 tom Exp $ */
d1044 1
a1044 1
    if (xtermIsDecGraphic(ch)) {
d1082 1
a1082 1
		if (xtermIsDecGraphic(eqv)) {
d1201 3
a1203 3
	    const char *mapTo = (xw->screen.selectToClipboard
				 ? "CLIPBOARD"
				 : "PRIMARY");
d2469 5
a2473 7

		if_WIDE_OR_NARROW(screen, {
		    next = convertToUTF8(last, data);
		}
		, {
		    *next++ = CharOf(data);
		});
a3154 1
	Atom *allocP;
a3165 1

a3166 2
	    allocP = targetP;

a3167 1

a3181 3

	    *length = std_length + (targetP - allocP);

a3447 15
    }
}

void
UnhiliteSelection(XtermWidget xw)
{
    TScreen *screen = &(xw->screen);

    if (ScrnHaveSelection(screen)) {
	CELL first = screen->startH;
	CELL last = screen->endH;

	screen->startH = zeroCELL;
	screen->endH = zeroCELL;
	ReHiliteText(xw, &first, &last);
@


