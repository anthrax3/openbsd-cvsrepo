head	1.18;
access;
symbols
	OPENBSD_6_1_BASE:1.18
	OPENBSD_6_0:1.17.0.10
	OPENBSD_6_0_BASE:1.17
	OPENBSD_5_9:1.17.0.8
	OPENBSD_5_9_BASE:1.17
	OPENBSD_5_8:1.17.0.6
	OPENBSD_5_8_BASE:1.17
	OPENBSD_5_7:1.17.0.4
	OPENBSD_5_7_BASE:1.17
	OPENBSD_5_6:1.17.0.2
	OPENBSD_5_6_BASE:1.17
	OPENBSD_5_5:1.16.0.2
	OPENBSD_5_5_BASE:1.16
	OPENBSD_5_4:1.15.0.2
	OPENBSD_5_4_BASE:1.15
	OPENBSD_5_3:1.14.0.2
	OPENBSD_5_3_BASE:1.14
	OPENBSD_5_2:1.12.0.4
	OPENBSD_5_2_BASE:1.12
	OPENBSD_5_1_BASE:1.12
	OPENBSD_5_1:1.12.0.2
	OPENBSD_5_0:1.11.0.2
	OPENBSD_5_0_BASE:1.11
	OPENBSD_4_9:1.9.0.2
	OPENBSD_4_9_BASE:1.9
	OPENBSD_4_8:1.8.0.4
	OPENBSD_4_8_BASE:1.8
	OPENBSD_4_7:1.7.0.2
	OPENBSD_4_7_BASE:1.7
	OPENBSD_4_6:1.5.0.2
	OPENBSD_4_6_BASE:1.5
	OPENBSD_4_5:1.4.0.2
	OPENBSD_4_5_BASE:1.4
	OPENBSD_4_4:1.2.0.2
	OPENBSD_4_4_BASE:1.2
	OPENBSD_4_3_BASE:1.1.1.2
	OPENBSD_4_3:1.1.1.2.0.4
	v232:1.1.1.2
	v229:1.1.1.2
	OPENBSD_4_2:1.1.1.2.0.2
	OPENBSD_4_2_BASE:1.1.1.2
	v225:1.1.1.2
	v216:1.1.1.1
	xterm:1.1.1;
locks; strict;
comment	@ * @;


1.18
date	2016.08.07.21.27.36;	author matthieu;	state Exp;
branches;
next	1.17;
commitid	psxxjI5z4Vpv2LL4;

1.17
date	2014.07.14.08.30.11;	author matthieu;	state Exp;
branches;
next	1.16;
commitid	EnwNNUjlkdrocnMa;

1.16
date	2013.08.26.20.06.13;	author matthieu;	state Exp;
branches;
next	1.15;

1.15
date	2013.03.09.14.45.38;	author matthieu;	state Exp;
branches;
next	1.14;

1.14
date	2013.02.27.22.11.56;	author matthieu;	state Exp;
branches;
next	1.13;

1.13
date	2013.01.04.16.40.18;	author matthieu;	state Exp;
branches;
next	1.12;

1.12
date	2011.09.17.11.51.57;	author matthieu;	state Exp;
branches;
next	1.11;

1.11
date	2011.06.07.19.21.06;	author matthieu;	state Exp;
branches;
next	1.10;

1.10
date	2011.03.07.20.41.27;	author matthieu;	state Exp;
branches;
next	1.9;

1.9
date	2010.08.22.13.38.11;	author matthieu;	state Exp;
branches;
next	1.8;

1.8
date	2010.05.08.12.20.46;	author matthieu;	state Exp;
branches;
next	1.7;

1.7
date	2009.10.31.14.11.57;	author matthieu;	state Exp;
branches;
next	1.6;

1.6
date	2009.09.05.15.58.09;	author matthieu;	state Exp;
branches;
next	1.5;

1.5
date	2009.03.09.22.13.04;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2009.01.06.20.10.21;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2008.08.25.18.05.57;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2008.03.19.21.15.46;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.26.11.11.42;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.11.26.11.11.42;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2007.06.15.19.30.34;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.18
log
@Update to xterm-325. Testing by krw@@, shadchin@@ and naddy@@. Thanks
@
text
@/* $XTermId: scrollbar.c,v 1.200 2016/05/22 16:43:12 tom Exp $ */

/*
 * Copyright 2000-2014,2016 by Thomas E. Dickey
 *
 *                         All Rights Reserved
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 *
 * The above copyright notice and this permission notice shall be included
 * in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
 * IN NO EVENT SHALL THE ABOVE LISTED COPYRIGHT HOLDER(S) BE LIABLE FOR ANY
 * CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
 * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
 * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 *
 * Except as contained in this notice, the name(s) of the above copyright
 * holders shall not be used in advertising or otherwise to promote the
 * sale, use or other dealings in this Software without prior written
 * authorization.
 *
 *
 * Copyright 1987 by Digital Equipment Corporation, Maynard, Massachusetts.
 *
 *                         All Rights Reserved
 *
 * Permission to use, copy, modify, and distribute this software and its
 * documentation for any purpose and without fee is hereby granted,
 * provided that the above copyright notice appear in all copies and that
 * both that copyright notice and this permission notice appear in
 * supporting documentation, and that the name of Digital Equipment
 * Corporation not be used in advertising or publicity pertaining to
 * distribution of the software without specific, written prior permission.
 *
 *
 * DIGITAL DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING
 * ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL
 * DIGITAL BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR
 * ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
 * WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
 * ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
 * SOFTWARE.
 */

#include <xterm.h>

#include <X11/Xatom.h>

#if defined(HAVE_LIB_XAW)
#include <X11/Xaw/Scrollbar.h>
#elif defined(HAVE_LIB_XAW3D)
#include <X11/Xaw3d/Scrollbar.h>
#elif defined(HAVE_LIB_XAW3DXFT)
#include <X11/Xaw3dxft/Scrollbar.h>
#elif defined(HAVE_LIB_NEXTAW)
#include <X11/neXtaw/Scrollbar.h>
#elif defined(HAVE_LIB_XAWPLUS)
#include <X11/XawPlus/Scrollbar.h>
#endif

#if defined(HAVE_XKBQUERYEXTENSION)
#include <X11/extensions/XKB.h>
#include <X11/XKBlib.h>
#endif

#include <data.h>
#include <error.h>
#include <menu.h>
#include <xstrings.h>

/*
 * The scrollbar's border overlaps the border of the vt100 window.  If there
 * is no border for the vt100, there can be no border for the scrollbar.
 */
#define SCROLLBAR_BORDER(xw) (TScreenOf(xw)->scrollBarBorder)
#if OPT_TOOLBAR
#define ScrollBarBorder(xw) (BorderWidth(xw) ? SCROLLBAR_BORDER(xw) : 0)
#else
#define ScrollBarBorder(xw) SCROLLBAR_BORDER(xw)
#endif

/* Event handlers */

static void ScrollTextTo PROTO_XT_CALLBACK_ARGS;
static void ScrollTextUpDownBy PROTO_XT_CALLBACK_ARGS;

/* Resize the text window for a terminal screen, modifying the
 * appropriate WM_SIZE_HINTS and taking advantage of bit gravity.
 */
void
DoResizeScreen(XtermWidget xw)
{
    TScreen *screen = TScreenOf(xw);

    int border = 2 * screen->border;
    int min_wide = border + screen->fullVwin.sb_info.width;
    int min_high = border;
    XtGeometryResult geomreqresult;
    Dimension reqWidth, reqHeight, repWidth, repHeight;
#ifndef NO_ACTIVE_ICON
    VTwin *saveWin = WhichVWin(screen);

    /* all units here want to be in the normal font units */
    WhichVWin(screen) = &screen->fullVwin;
#endif /* NO_ACTIVE_ICON */

    /*
     * I'm going to try to explain, as I understand it, why we
     * have to do XGetWMNormalHints and XSetWMNormalHints here,
     * although I can't guarantee that I've got it right.
     *
     * In a correctly written toolkit program, the Shell widget
     * parses the user supplied geometry argument.  However,
     * because of the way xterm does things, the VT100 widget does
     * the parsing of the geometry option, not the Shell widget.
     * The result of this is that the Shell widget doesn't set the
     * correct window manager hints, and doesn't know that the
     * user has specified a geometry.
     *
     * The XtVaSetValues call below tells the Shell widget to
     * change its hints.  However, since it's confused about the
     * hints to begin with, it doesn't get them all right when it
     * does the SetValues -- it undoes some of what the VT100
     * widget did when it originally set the hints.
     *
     * To fix this, we do the following:
     *
     * 1. Get the sizehints directly from the window, going around
     *    the (confused) shell widget.
     * 2. Call XtVaSetValues to let the shell widget know which
     *    hints have changed.  Note that this may not even be
     *    necessary, since we're going to right ahead after that
     *    and set the hints ourselves, but it's good to put it
     *    here anyway, so that when we finally do fix the code so
     *    that the Shell does the right thing with hints, we
     *    already have the XtVaSetValues in place.
     * 3. We set the sizehints directly, this fixing up whatever
     *    damage was done by the Shell widget during the
     *    XtVaSetValues.
     *
     * Gross, huh?
     *
     * The correct fix is to redo VTRealize, VTInitialize and
     * VTSetValues so that font processing happens early enough to
     * give back responsibility for the size hints to the Shell.
     *
     * Someday, we hope to have time to do this.  Someday, we hope
     * to have time to completely rewrite xterm.
     */

    TRACE(("DoResizeScreen\n"));

#if 1				/* ndef nothack */
    /*
     * NOTE: the hints and the XtVaSetValues() must match.
     */
    TRACE(("%s@@%d -- ", __FILE__, __LINE__));
    TRACE_WM_HINTS(xw);
    getXtermSizeHints(xw);

    xtermSizeHints(xw, ScrollbarWidth(screen));

    /* These are obsolete, but old clients may use them */
    xw->hints.width = MaxCols(screen) * FontWidth(screen) + xw->hints.min_width;
    xw->hints.height = MaxRows(screen) * FontHeight(screen) + xw->hints.min_height;
#if OPT_MAXIMIZE
    /* assure single-increment resize for fullscreen */
    if (xw->work.ewmh[0].mode) {
	xw->hints.width_inc = 1;
	xw->hints.height_inc = 1;
    }
#endif /* OPT_MAXIMIZE */
#endif

    XSetWMNormalHints(screen->display, VShellWindow(xw), &xw->hints);

    reqWidth = (Dimension) (MaxCols(screen) * FontWidth(screen) + min_wide);
    reqHeight = (Dimension) (MaxRows(screen) * FontHeight(screen) + min_high);

#if OPT_MAXIMIZE
    /* compensate for fullscreen mode */
    if (xw->work.ewmh[0].mode) {
	Screen *xscreen = DefaultScreenOfDisplay(xw->screen.display);
	reqWidth = (Dimension) WidthOfScreen(xscreen);
	reqHeight = (Dimension) HeightOfScreen(xscreen);
	ScreenResize(xw, reqWidth, reqHeight, &xw->flags);
    }
#endif /* OPT_MAXIMIZE */

    TRACE(("...requesting screensize chars %dx%d, pixels %dx%d\n",
	   MaxRows(screen),
	   MaxCols(screen),
	   reqHeight, reqWidth));

    geomreqresult = REQ_RESIZE((Widget) xw, reqWidth, reqHeight,
			       &repWidth, &repHeight);

    if (geomreqresult == XtGeometryAlmost) {
	TRACE(("...almost, retry screensize %dx%d\n", repHeight, repWidth));
	geomreqresult = REQ_RESIZE((Widget) xw, repWidth,
				   repHeight, NULL, NULL);
    }

    if (geomreqresult != XtGeometryYes) {
	/* The resize wasn't successful, so we might need to adjust
	   our idea of how large the screen is. */
	TRACE(("...still no (%d) - resize the core-class\n", geomreqresult));
	xw->core.widget_class->core_class.resize((Widget) xw);
    }
#if 1				/* ndef nothack */
    /*
     * XtMakeResizeRequest() has the undesirable side-effect of clearing
     * the window manager's hints, even on a failed request.  This would
     * presumably be fixed if the shell did its own work.
     */
    if (xw->hints.flags
	&& repHeight
	&& repWidth) {
	xw->hints.height = repHeight;
	xw->hints.width = repWidth;
	TRACE_HINTS(&xw->hints);
	XSetWMNormalHints(screen->display, VShellWindow(xw), &xw->hints);
    }
#endif
    XSync(screen->display, False);	/* synchronize */
    if (xtermAppPending())
	xevents();

#ifndef NO_ACTIVE_ICON
    WhichVWin(screen) = saveWin;
#endif /* NO_ACTIVE_ICON */
}

static Widget
CreateScrollBar(XtermWidget xw, int x, int y, int height)
{
    Widget result;
    Arg args[6];

    XtSetArg(args[0], XtNx, x);
    XtSetArg(args[1], XtNy, y);
    XtSetArg(args[2], XtNheight, height);
    XtSetArg(args[3], XtNreverseVideo, xw->misc.re_verse);
    XtSetArg(args[4], XtNorientation, XtorientVertical);
    XtSetArg(args[5], XtNborderWidth, ScrollBarBorder(xw));

    result = XtCreateWidget("scrollbar", scrollbarWidgetClass,
			    (Widget) xw, args, XtNumber(args));
    XtAddCallback(result, XtNscrollProc, ScrollTextUpDownBy, 0);
    XtAddCallback(result, XtNjumpProc, ScrollTextTo, 0);
    return (result);
}

void
ScrollBarReverseVideo(Widget scrollWidget)
{
    XtermWidget xw = getXtermWidget(scrollWidget);

    if (xw != 0) {
	SbInfo *sb = &(TScreenOf(xw)->fullVwin.sb_info);
	Arg args[4];
	Cardinal nargs = XtNumber(args);

	/*
	 * Remember the scrollbar's original colors.
	 */
	if (sb->rv_cached == False) {
	    XtSetArg(args[0], XtNbackground, &(sb->bg));
	    XtSetArg(args[1], XtNforeground, &(sb->fg));
	    XtSetArg(args[2], XtNborderColor, &(sb->bdr));
	    XtSetArg(args[3], XtNborderPixmap, &(sb->bdpix));
	    XtGetValues(scrollWidget, args, nargs);
	    sb->rv_cached = True;
	    sb->rv_active = 0;
	}

	sb->rv_active = !(sb->rv_active);
	if (sb->rv_active) {
	    XtSetArg(args[0], XtNbackground, sb->fg);
	    XtSetArg(args[1], XtNforeground, sb->bg);
	} else {
	    XtSetArg(args[0], XtNbackground, sb->bg);
	    XtSetArg(args[1], XtNforeground, sb->fg);
	}
	nargs = 2;		/* don't set border_pixmap */
	if (sb->bdpix == XtUnspecifiedPixmap) {
	    /* if not pixmap then pixel */
	    if (sb->rv_active) {
		/* keep border visible */
		XtSetArg(args[2], XtNborderColor, args[1].value);
	    } else {
		XtSetArg(args[2], XtNborderColor, sb->bdr);
	    }
	    nargs = 3;
	}
	XtSetValues(scrollWidget, args, nargs);
    }
}

void
ScrollBarDrawThumb(Widget scrollWidget)
{
    XtermWidget xw = getXtermWidget(scrollWidget);

    if (xw != 0) {
	TScreen *screen = TScreenOf(xw);
	int thumbTop, thumbHeight, totalHeight;

	thumbTop = ROW2INX(screen, screen->savedlines);
	thumbHeight = MaxRows(screen);
	totalHeight = thumbHeight + screen->savedlines;

	XawScrollbarSetThumb(scrollWidget,
			     ((float) thumbTop) / (float) totalHeight,
			     ((float) thumbHeight) / (float) totalHeight);
    }
}

void
ResizeScrollBar(XtermWidget xw)
{
    TScreen *screen = TScreenOf(xw);

    if (screen->scrollWidget != 0) {
	int height = screen->fullVwin.height + screen->border * 2;
	int width = screen->scrollWidget->core.width;
	int ypos = -ScrollBarBorder(xw);
#ifdef SCROLLBAR_RIGHT
	int xpos = ((xw->misc.useRight)
		    ? (screen->fullVwin.fullwidth -
		       screen->scrollWidget->core.width -
		       BorderWidth(screen->scrollWidget))
		    : -ScrollBarBorder(xw));
#else
	int xpos = -ScrollBarBorder(xw);
#endif

	TRACE(("ResizeScrollBar at %d,%d %dx%d\n", ypos, xpos, height, width));

	XtConfigureWidget(
			     screen->scrollWidget,
			     (Position) xpos,
			     (Position) ypos,
			     (Dimension) width,
			     (Dimension) height,
			     BorderWidth(screen->scrollWidget));
	ScrollBarDrawThumb(screen->scrollWidget);
    }
}

void
WindowScroll(XtermWidget xw, int top, Bool always GCC_UNUSED)
{
    TScreen *screen = TScreenOf(xw);

#if OPT_SCROLL_LOCK
    if (screen->allowScrollLock && (screen->scroll_lock && !always)) {
	if (screen->scroll_dirty) {
	    screen->scroll_dirty = False;
	    ScrnRefresh(xw, 0, 0, MaxRows(screen), MaxCols(screen), False);
	}
    } else
#endif
    {
	int i;

	if (top < -screen->savedlines) {
	    top = -screen->savedlines;
	} else if (top > 0) {
	    top = 0;
	}

	if ((i = screen->topline - top) != 0) {
	    int lines;
	    int scrolltop, scrollheight, refreshtop;

	    if (screen->cursor_state)
		HideCursor();
	    lines = i > 0 ? i : -i;
	    if (lines > MaxRows(screen))
		lines = MaxRows(screen);
	    scrollheight = screen->max_row - lines + 1;
	    if (i > 0)
		refreshtop = scrolltop = 0;
	    else {
		scrolltop = lines;
		refreshtop = scrollheight;
	    }
	    scrolling_copy_area(xw, scrolltop, scrollheight, -i);
	    screen->topline = top;

	    ScrollSelection(screen, i, True);

#if OPT_DOUBLE_BUFFER
	    XFillRectangle(screen->display,
			   VDrawable(screen),
			   ReverseGC(xw, screen),
			   OriginX(screen),
			   OriginY(screen) + refreshtop * FontHeight(screen),
			   (unsigned) Width(screen),
			   (unsigned) (lines * FontHeight(screen)));
#else
	    XClearArea(screen->display,
		       VWindow(screen),
		       OriginX(screen),
		       OriginY(screen) + refreshtop * FontHeight(screen),
		       (unsigned) Width(screen),
		       (unsigned) (lines * FontHeight(screen)),
		       False);
#endif
	    ScrnRefresh(xw, refreshtop, 0, lines, MaxCols(screen), False);

#if OPT_BLINK_CURS || OPT_BLINK_TEXT
	    RestartBlinking(screen);
#endif
	}
    }
    ScrollBarDrawThumb(screen->scrollWidget);
}

#ifdef SCROLLBAR_RIGHT
/*
 * Adjust the scrollbar position if we're asked to turn on scrollbars for the
 * first time (or after resizing) after the xterm is already running.  That
 * makes the window grow after we've initially configured the scrollbar's
 * position.  (There must be a better way).
 */
void
updateRightScrollbar(XtermWidget xw)
{
    TScreen *screen = TScreenOf(xw);

    if (xw->misc.useRight
	&& screen->fullVwin.fullwidth < xw->core.width)
	XtVaSetValues(screen->scrollWidget,
		      XtNx, screen->fullVwin.fullwidth - BorderWidth(screen->scrollWidget),
		      (XtPointer) 0);
}
#endif

void
ScrollBarOn(XtermWidget xw, Bool init)
{
    TScreen *screen = TScreenOf(xw);

    if (screen->fullVwin.sb_info.width || IsIcon(screen))
	return;

    TRACE(("ScrollBarOn(init %s)\n", BtoS(init)));
    if (init) {			/* then create it only */
	if (screen->scrollWidget == 0) {
	    /* make it a dummy size and resize later */
	    screen->scrollWidget = CreateScrollBar(xw,
						   -ScrollBarBorder(xw),
						   -ScrollBarBorder(xw),
						   5);
	    if (screen->scrollWidget == NULL) {
		Bell(xw, XkbBI_MinorError, 0);
	    }
	}
    } else if (!screen->scrollWidget || !XtIsRealized((Widget) xw)) {
	Bell(xw, XkbBI_MinorError, 0);
	Bell(xw, XkbBI_MinorError, 0);
    } else {

	ResizeScrollBar(xw);
	xtermAddInput(screen->scrollWidget);
	XtRealizeWidget(screen->scrollWidget);
	TRACE_TRANS("scrollbar", screen->scrollWidget);

	screen->fullVwin.sb_info.rv_cached = False;

	screen->fullVwin.sb_info.width = (screen->scrollWidget->core.width
					  + BorderWidth(screen->scrollWidget));

	TRACE(("setting scrollbar width %d = %d + %d\n",
	       screen->fullVwin.sb_info.width,
	       screen->scrollWidget->core.width,
	       BorderWidth(screen->scrollWidget)));

	ScrollBarDrawThumb(screen->scrollWidget);
	DoResizeScreen(xw);

#ifdef SCROLLBAR_RIGHT
	updateRightScrollbar(xw);
#endif

	XtMapWidget(screen->scrollWidget);
	update_scrollbar();
	if (screen->visbuf) {
	    xtermClear(xw);
	    Redraw();
	}
    }
}

void
ScrollBarOff(XtermWidget xw)
{
    TScreen *screen = TScreenOf(xw);

    if (!screen->fullVwin.sb_info.width || IsIcon(screen))
	return;

    TRACE(("ScrollBarOff\n"));
    if (XtIsRealized((Widget) xw)) {
	XtUnmapWidget(screen->scrollWidget);
	screen->fullVwin.sb_info.width = 0;
	DoResizeScreen(xw);
	update_scrollbar();
	if (screen->visbuf) {
	    xtermClear(xw);
	    Redraw();
	}
    } else {
	Bell(xw, XkbBI_MinorError, 0);
    }
}

/*
 * Toggle the visibility of the scrollbars.
 */
void
ToggleScrollBar(XtermWidget xw)
{
    TScreen *screen = TScreenOf(xw);

    if (IsIcon(screen)) {
	Bell(xw, XkbBI_MinorError, 0);
    } else {
	TRACE(("ToggleScrollBar{{\n"));
	if (screen->fullVwin.sb_info.width) {
	    ScrollBarOff(xw);
	} else {
	    ScrollBarOn(xw, False);
	}
	update_scrollbar();
	TRACE(("...ToggleScrollBar}}\n"));
    }
}

/*ARGSUSED*/
static void
ScrollTextTo(
		Widget scrollbarWidget,
		XtPointer client_data GCC_UNUSED,
		XtPointer call_data)
{
    XtermWidget xw = getXtermWidget(scrollbarWidget);

    if (xw != 0) {
	float *topPercent = (float *) call_data;
	TScreen *screen = TScreenOf(xw);
	int thumbTop;		/* relative to first saved line */
	int newTopLine;

	/*
	 * screen->savedlines : Number of offscreen text lines,
	 * MaxRows(screen)    : Number of onscreen  text lines,
	 */
	thumbTop = (int) (*topPercent
			  * (float) (screen->savedlines + MaxRows(screen)));
	newTopLine = thumbTop - screen->savedlines;
	WindowScroll(xw, newTopLine, True);
    }
}

/*ARGSUSED*/
static void
ScrollTextUpDownBy(
		      Widget scrollbarWidget,
		      XtPointer client_data GCC_UNUSED,
		      XtPointer call_data)
{
    XtermWidget xw = getXtermWidget(scrollbarWidget);

    if (xw != 0) {
	long pixels = (long) call_data;

	TScreen *screen = TScreenOf(xw);
	int rowOnScreen, newTopLine;

	rowOnScreen = (int) (pixels / FontHeight(screen));
	if (rowOnScreen == 0) {
	    if (pixels < 0)
		rowOnScreen = -1;
	    else if (pixels > 0)
		rowOnScreen = 1;
	}
	newTopLine = ROW2INX(screen, rowOnScreen);
	WindowScroll(xw, newTopLine, True);
    }
}

/*
 * assume that b is alphabetic and allow plural
 */
static int
CompareWidths(const char *a, const char *b, int *modifier)
{
    int result;
    char ca, cb;

    *modifier = 0;
    if (!a || !b)
	return 0;

    for (;;) {
	ca = x_toupper(*a);
	cb = x_toupper(*b);
	if (ca != cb || ca == '\0')
	    break;		/* if not eq else both nul */
	a++, b++;
    }
    if (cb != '\0')
	return 0;

    if (ca == 'S')
	ca = *++a;

    switch (ca) {
    case '+':
    case '-':
	*modifier = (ca == '-' ? -1 : 1) * atoi(a + 1);
	result = 1;
	break;

    case '\0':
	result = 1;
	break;

    default:
	result = 0;
	break;
    }
    return result;
}

static long
params_to_pixels(TScreen *screen, String *params, Cardinal n)
{
    int mult = 1;
    const char *s;
    int modifier;

    switch (n > 2 ? 2 : n) {
    case 2:
	s = params[1];
	if (CompareWidths(s, "PAGE", &modifier)) {
	    mult = (MaxRows(screen) + modifier) * FontHeight(screen);
	} else if (CompareWidths(s, "HALFPAGE", &modifier)) {
	    mult = ((MaxRows(screen) + modifier) * FontHeight(screen)) / 2;
	} else if (CompareWidths(s, "PIXEL", &modifier)) {
	    mult = 1;
	} else {
	    /* else assume that it is Line */
	    mult = FontHeight(screen);
	}
	mult *= atoi(params[0]);
	TRACE(("params_to_pixels(%s,%s) = %d\n", params[0], params[1], mult));
	break;
    case 1:
	mult = atoi(params[0]) * FontHeight(screen);	/* lines */
	TRACE(("params_to_pixels(%s) = %d\n", params[0], mult));
	break;
    default:
	mult = screen->scrolllines * FontHeight(screen);
	TRACE(("params_to_pixels() = %d\n", mult));
	break;
    }
    return mult;
}

static long
AmountToScroll(Widget w, String *params, Cardinal nparams)
{
    long result = 0;
    XtermWidget xw;

    if ((xw = getXtermWidget(w)) != 0) {
	TScreen *screen = TScreenOf(xw);
	if (nparams <= 2
	    || screen->send_mouse_pos == MOUSE_OFF) {
	    result = params_to_pixels(screen, params, nparams);
	}
    }
    return result;
}

static void
AlternateScroll(Widget w, long amount)
{
    XtermWidget xw;
    TScreen *screen;

    if ((xw = getXtermWidget(w)) != 0 &&
	(screen = TScreenOf(xw)) != 0 &&
	screen->alternateScroll && screen->whichBuf) {
	ANSI reply;

	amount /= FontHeight(screen);
	memset(&reply, 0, sizeof(reply));
	reply.a_type = ((xw->keyboard.flags & MODE_DECCKM)
			? ANSI_SS3
			: ANSI_CSI);
	if (amount > 0) {
	    reply.a_final = 'B';
	} else {
	    amount = -amount;
	    reply.a_final = 'A';
	}
	while (amount-- > 0) {
	    unparseseq(xw, &reply);
	}
    } else {
	ScrollTextUpDownBy(w, (XtPointer) 0, (XtPointer) amount);
    }
}

/*ARGSUSED*/
void
HandleScrollForward(
		       Widget xw,
		       XEvent *event GCC_UNUSED,
		       String *params,
		       Cardinal *nparams)
{
    long amount;

    if ((amount = AmountToScroll(xw, params, *nparams)) != 0) {
	AlternateScroll(xw, amount);
    }
}

/*ARGSUSED*/
void
HandleScrollBack(
		    Widget xw,
		    XEvent *event GCC_UNUSED,
		    String *params,
		    Cardinal *nparams)
{
    long amount;

    if ((amount = -AmountToScroll(xw, params, *nparams)) != 0) {
	AlternateScroll(xw, amount);
    }
}

#if OPT_SCROLL_LOCK
#define SCROLL_LOCK_LED 3

#ifdef HAVE_XKBQUERYEXTENSION
/*
 * Check for Xkb on client and server.
 */
static int
have_xkb(Display *dpy)
{
    static int initialized = -1;

    if (initialized < 0) {
	int xkbmajor = XkbMajorVersion;
	int xkbminor = XkbMinorVersion;
	int xkbopcode, xkbevent, xkberror;

	initialized = 0;
	if (XkbLibraryVersion(&xkbmajor, &xkbminor)
	    && XkbQueryExtension(dpy,
				 &xkbopcode,
				 &xkbevent,
				 &xkberror,
				 &xkbmajor,
				 &xkbminor)) {
	    TRACE(("we have Xkb\n"));
	    initialized = 1;
#if OPT_TRACE
	    {
		XkbDescPtr xkb;
		unsigned int mask;

		xkb = XkbGetKeyboard(dpy, XkbAllComponentsMask, XkbUseCoreKbd);
		if (xkb != NULL) {
		    int n;

		    TRACE(("XkbGetKeyboard ok\n"));
		    for (n = 0; n < XkbNumVirtualMods; ++n) {
			if (xkb->names->vmods[n] != 0) {
			    char *modStr = XGetAtomName(xkb->dpy,
							xkb->names->vmods[n]);
			    if (modStr != 0) {
				XkbVirtualModsToReal(xkb,
						     (unsigned) (1 << n),
						     &mask);
				TRACE(("  name[%d] %s (%#x)\n", n, modStr, mask));
			    }
			}
		    }
		    XkbFreeKeyboard(xkb, 0, True);
		}
	    }
#endif
	}
    }
    return initialized;
}

static Boolean
getXkbLED(Display *dpy, const char *name, Boolean *result)
{
    Atom my_atom;
    Boolean success = False;
    Bool state;

    if (have_xkb(dpy)) {
	my_atom = XInternAtom(dpy, name, False);
	if ((my_atom != None) &&
	    XkbGetNamedIndicator(dpy, my_atom, NULL, &state, NULL, NULL)) {
	    *result = (Boolean) state;
	    success = True;
	}
    }

    return success;
}

/*
 * Use Xkb if we have it (still unreliable, but slightly better than hardcoded).
 */
static Boolean
showXkbLED(Display *dpy, const char *name, Bool enable)
{
    Atom my_atom;
    Boolean result = False;

    if (have_xkb(dpy)) {
	my_atom = XInternAtom(dpy, name, False);
	if ((my_atom != None) &&
	    XkbGetNamedIndicator(dpy, my_atom, NULL, NULL, NULL, NULL) &&
	    XkbSetNamedIndicator(dpy, my_atom, True, enable, False, NULL)) {
	    result = True;
	}
    }

    return result;
}
#endif

/*
 * xlsatoms agrees with this list.  However Num/Caps lock are generally
 * unusable due to special treatment in X.  They are used here for
 * completeness.
 */
static const char *led_table[] =
{
    "Num Lock",
    "Caps Lock",
    "Scroll Lock"
};

static Boolean
xtermGetLED(TScreen *screen, Cardinal led_number)
{
    Display *dpy = screen->display;
    Boolean result = False;

#ifdef HAVE_XKBQUERYEXTENSION
    if (!getXkbLED(dpy, led_table[led_number - 1], &result))
#endif
    {
	XKeyboardState state;
	unsigned long my_bit = (unsigned long) (1 << (led_number - 1));

	XGetKeyboardControl(dpy, &state);

	result = (Boolean) ((state.led_mask & my_bit) != 0);
    }

    TRACE(("xtermGetLED %d:%s\n", led_number, BtoS(result)));
    return result;
}

/*
 * Display the given LED, preferably independent of keyboard state.
 */
void
xtermShowLED(TScreen *screen, Cardinal led_number, Bool enable)
{
    TRACE(("xtermShowLED %d:%s\n", led_number, BtoS(enable)));
    if ((led_number >= 1) && (led_number <= XtNumber(led_table))) {
	Display *dpy = screen->display;

#ifdef HAVE_XKBQUERYEXTENSION
	if (!showXkbLED(dpy, led_table[led_number - 1], enable))
#endif
	{
	    XKeyboardState state;
	    XKeyboardControl values;
	    unsigned long use_mask;
	    unsigned long my_bit = (unsigned long) (1 << (led_number - 1));

	    XGetKeyboardControl(dpy, &state);
	    use_mask = state.led_mask;
	    if (enable) {
		use_mask |= my_bit;
	    } else {
		use_mask &= ~my_bit;
	    }

	    if (state.led_mask != use_mask) {
		values.led = (int) led_number;
		values.led_mode = enable;
		XChangeKeyboardControl(dpy, KBLed | KBLedMode, &values);
	    }
	}
    }
}

void
xtermClearLEDs(TScreen *screen)
{
    Display *dpy = screen->display;
    XKeyboardControl values;

    TRACE(("xtermClearLEDs\n"));
#ifdef HAVE_XKBQUERYEXTENSION
    ShowScrollLock(screen, False);
#endif
    memset(&values, 0, sizeof(values));
    XChangeKeyboardControl(dpy, KBLedMode, &values);
}

void
ShowScrollLock(TScreen *screen, Bool enable)
{
    xtermShowLED(screen, SCROLL_LOCK_LED, enable);
}

void
GetScrollLock(TScreen *screen)
{
    if (screen->allowScrollLock)
	screen->scroll_lock = xtermGetLED(screen, SCROLL_LOCK_LED);
}

void
SetScrollLock(TScreen *screen, Bool enable)
{
    if (screen->allowScrollLock) {
	if (screen->scroll_lock != enable) {
	    TRACE(("SetScrollLock %s\n", BtoS(enable)));
	    screen->scroll_lock = (Boolean) enable;
	    ShowScrollLock(screen, enable);
	}
    }
}

/* ARGSUSED */
void
HandleScrollLock(Widget w,
		 XEvent *event GCC_UNUSED,
		 String *params,
		 Cardinal *param_count)
{
    XtermWidget xw;

    if ((xw = getXtermWidget(w)) != 0) {
	TScreen *screen = TScreenOf(xw);

	if (screen->allowScrollLock) {

	    switch (decodeToggle(xw, params, *param_count)) {
	    case toggleOff:
		SetScrollLock(screen, False);
		break;
	    case toggleOn:
		SetScrollLock(screen, True);
		break;
	    case toggleAll:
		SetScrollLock(screen, !screen->scroll_lock);
		break;
	    }
	}
    }
}
#endif
@


1.17
log
@Update to xterm-309. Version 308 tested by several people including
naddy@@ who found a small regression, fixed in 309.
@
text
@d1 1
a1 1
/* $XTermId: scrollbar.c,v 1.199 2014/07/12 22:55:11 tom Exp $ */
d4 1
a4 1
 * Copyright 2000-2013,2014 by Thomas E. Dickey
a364 2
    int i, lines;
    int scrolltop, scrollheight, refreshtop;
d375 2
d384 2
a790 2
		int n;
		char *modStr;
d794 1
d799 2
a800 2
			    modStr = XGetAtomName(xkb->dpy,
						  xkb->names->vmods[n]);
@


1.16
log
@Update to xterm 296. Sixel graphics disabled for now.
@
text
@d1 1
a1 1
/* $XTermId: scrollbar.c,v 1.197 2013/06/23 21:55:39 tom Exp $ */
d4 1
a4 1
 * Copyright 2000-2012,2013 by Thomas E. Dickey
d63 2
d648 1
a648 1
params_to_pixels(TScreen * screen, String * params, Cardinal n)
d683 1
a683 1
AmountToScroll(Widget w, String * params, Cardinal nparams)
d732 2
a733 2
		       XEvent * event GCC_UNUSED,
		       String * params,
d747 2
a748 2
		    XEvent * event GCC_UNUSED,
		    String * params,
d766 1
a766 1
have_xkb(Display * dpy)
d818 1
a818 1
getXkbLED(Display * dpy, const char *name, Boolean * result)
d840 1
a840 1
showXkbLED(Display * dpy, const char *name, Bool enable)
d871 1
a871 1
xtermGetLED(TScreen * screen, Cardinal led_number)
d896 1
a896 1
xtermShowLED(TScreen * screen, Cardinal led_number, Bool enable)
d929 1
a929 1
xtermClearLEDs(TScreen * screen)
d943 1
a943 1
ShowScrollLock(TScreen * screen, Bool enable)
d949 1
a949 1
GetScrollLock(TScreen * screen)
d956 1
a956 1
SetScrollLock(TScreen * screen, Bool enable)
d970 2
a971 2
		 XEvent * event GCC_UNUSED,
		 String * params,
@


1.15
log
@Update to xterm 291. Tested by many.
@
text
@d1 1
a1 1
/* $XTermId: scrollbar.c,v 1.196 2013/02/26 23:36:05 tom Exp $ */
a76 1
#include <xcharmouse.h>
@


1.14
log
@Merge patch from Tom Dickey for a segfault that happens when using the
mouse wheel over the scrollbar. ok guenther@@ deraadt@@
@
text
@d710 3
a712 1
	reply.a_type = ANSI_CSI;
@


1.13
log
@Update to xterm 287. tested by mpi@@ and krw@@.
@
text
@d1 1
a1 1
/* $XTermId: scrollbar.c,v 1.193 2012/09/28 21:04:50 tom Exp $ */
d4 1
a4 1
 * Copyright 2000-2011,2012 by Thomas E. Dickey
d700 2
a701 2
    XtermWidget xw = (XtermWidget) w;
    TScreen *screen = TScreenOf(xw);
d703 3
a705 1
    if (screen->alternateScroll && screen->whichBuf) {
@


1.12
log
@Update to xterm-275. Tested by jasper@@.
@
text
@d1 1
a1 1
/* $XTermId: scrollbar.c,v 1.182 2011/09/03 12:13:42 tom Exp $ */
d4 1
a4 1
 * Copyright 2000-2010,2011 by Thomas E. Dickey
d69 1
a69 1
#if defined(HAVE_XKBQUERYEXTENSION) && defined(HAVE_X11_XKBLIB_H) && defined(HAVE_X11_EXTENSIONS_XKB_H)
a71 2
#else
#undef HAVE_XKBQUERYEXTENSION
d177 1
a177 1
    if (screen->fullscreen) {
d191 1
a191 1
    if (screen->fullscreen) {
d401 17
a417 8
	    XClearArea(
			  screen->display,
			  VWindow(screen),
			  OriginX(screen),
			  OriginY(screen) + refreshtop * FontHeight(screen),
			  (unsigned) Width(screen),
			  (unsigned) (lines * FontHeight(screen)),
			  False);
d667 1
d671 1
d675 1
d697 26
d734 1
a734 1
	ScrollTextUpDownBy(xw, (XtPointer) 0, (XtPointer) amount);
d749 1
a749 1
	ScrollTextUpDownBy(xw, (XtPointer) 0, (XtPointer) amount);
d955 1
d975 9
a983 5
	    /*
	     * The default action (used with KeyRelease event) is to cycle the
	     * state on/off.
	     */
	    if (*param_count == 0) {
d985 1
a985 7
		TRACE(("HandleScrollLock ->%d\n",
		       screen->scroll_lock));
	    } else {
		SetScrollLock(screen, atoi(params[0]));
		TRACE(("HandleScrollLock(%s) ->%d\n",
		       params[0],
		       screen->scroll_lock));
@


1.11
log
@Update to xterm 270. Tested by ajacoutot@@, shadchin@@, krw@@ and jasper@@
@
text
@d1 1
a1 1
/* $XTermId: scrollbar.c,v 1.181 2011/04/18 22:35:33 tom Exp $ */
d237 1
a237 1
    if (XtAppPending(app_con))
@


1.10
log
@Update to xterm version 269.
Tested and ok ajacoutot@@, jasper@@, krw@@, shadchin@@
@
text
@d1 1
a1 1
/* $XTermId: scrollbar.c,v 1.180 2011/02/17 00:50:23 tom Exp $ */
d289 7
a295 2
	XtSetArg(args[!(sb->rv_active)], XtNbackground, sb->bg);
	XtSetArg(args[(sb->rv_active)], XtNforeground, sb->fg);
@


1.9
log
@Update to xterm 261. Tested by krw@@, jcs@@.
@
text
@d1 1
a1 1
/* $XTermId: scrollbar.c,v 1.173 2010/06/15 22:47:34 tom Exp $ */
d4 1
a4 1
 * Copyright 2000-2009,2010 by Thomas E. Dickey
d177 7
d186 1
a186 1
    XSetWMNormalHints(screen->display, XtWindow(SHELL_OF(xw)), &xw->hints);
d191 10
d233 1
a233 1
	XSetWMNormalHints(screen->display, VShellWindow, &xw->hints);
d603 1
a603 1
    while (1) {
d920 1
@


1.8
log
@Update to xterm 258. lightly tested by krw@@, thanks.
@
text
@d1 1
a1 1
/* $XTermId: scrollbar.c,v 1.169 2010/04/21 00:19:04 tom Exp $ */
d303 2
a304 2
			     ((float) thumbTop) / totalHeight,
			     ((float) thumbHeight) / totalHeight);
d436 1
a436 1
		Bell(XkbBI_MinorError, 0);
d440 2
a441 2
	Bell(XkbBI_MinorError, 0);
	Bell(XkbBI_MinorError, 0);
d494 1
a494 1
	Bell(XkbBI_MinorError, 0);
d507 1
a507 1
	Bell(XkbBI_MinorError, 0);
d539 2
a540 1
	thumbTop = (int) (*topPercent * (screen->savedlines + MaxRows(screen)));
d621 1
a621 1
    char *s;
d738 3
a740 1
				XkbVirtualModsToReal(xkb, 1 << n, &mask);
d762 1
a762 1
	my_atom = XInternAtom(dpy, name, True);
d783 1
a783 1
	my_atom = XInternAtom(dpy, name, True);
d795 5
d872 3
@


1.7
log
@Update to xterm 250
@
text
@d1 1
a1 1
/* $XTermId: scrollbar.c,v 1.145 2009/10/12 21:56:35 tom Exp $ */
d4 1
a4 1
 * Copyright 2000-2008,2009 by Thomas E. Dickey
d69 7
d341 1
a341 1
WindowScroll(XtermWidget xw, int top)
d347 33
a379 8
    if (top < -screen->savedlines)
	top = -screen->savedlines;
    else if (top > 0)
	top = 0;
    if ((i = screen->topline - top) == 0) {
	ScrollBarDrawThumb(screen->scrollWidget);
	return;
    }
d381 9
a389 26
    if (screen->cursor_state)
	HideCursor();
    lines = i > 0 ? i : -i;
    if (lines > MaxRows(screen))
	lines = MaxRows(screen);
    scrollheight = screen->max_row - lines + 1;
    if (i > 0)
	refreshtop = scrolltop = 0;
    else {
	scrolltop = lines;
	refreshtop = scrollheight;
    }
    scrolling_copy_area(xw, scrolltop, scrollheight, -i);
    screen->topline = top;

    ScrollSelection(screen, i, True);

    XClearArea(
		  screen->display,
		  VWindow(screen),
		  OriginX(screen),
		  OriginY(screen) + refreshtop * FontHeight(screen),
		  (unsigned) Width(screen),
		  (unsigned) (lines * FontHeight(screen)),
		  False);
    ScrnRefresh(xw, refreshtop, 0, lines, MaxCols(screen), False);
a390 1
    ScrollBarDrawThumb(screen->scrollWidget);
d392 1
a392 1
    RestartBlinking(screen);
d394 3
d541 1
a541 1
	WindowScroll(xw, newTopLine);
d560 1
a560 1
	rowOnScreen = pixels / FontHeight(screen);
d568 1
a568 1
	WindowScroll(xw, newTopLine);
d693 229
@


1.6
log
@update to xterm 246. Has been in snapshots for some time.
@
text
@d1 1
a1 1
/* $XTermId: scrollbar.c,v 1.143 2009/08/09 17:23:47 tom Exp $ */
d377 3
d559 1
a559 1
CompareWidths(char *a, char *b, int *modifier)
@


1.5
log
@Update to xterm 242. Tested by jsg@@.
@
text
@d1 1
a1 3
/* $XTermId: scrollbar.c,v 1.139 2009/02/12 00:07:53 tom Exp $ */

/* $XFree86: xc/programs/xterm/scrollbar.c,v 3.48 2006/02/13 01:14:59 dickey Exp $ */
d400 1
a400 1
ScrollBarOn(XtermWidget xw, int init, int doalloc)
a402 1
    int i, j, k;
d407 1
a407 1
    TRACE(("ScrollBarOn\n"));
a423 25
	if (doalloc && screen->allbuf) {
	    /* FIXME: this is not integrated well with Allocate */
	    if ((screen->allbuf =
		 TypeRealloc(ScrnPtr,
			     (unsigned) (MAX_PTRS
					 * (screen->max_row + 2
					    + screen->savelines)),
			     screen->visbuf)) == NULL) {
		SysError(ERROR_SBRALLOC);
	    }
	    screen->visbuf = &screen->allbuf[MAX_PTRS * screen->savelines];
	    memmove((char *) screen->visbuf, (char *) screen->allbuf,
		    (unsigned) (MAX_PTRS * (screen->max_row + 2))
		    * sizeof(char *));
	    for (i = k = 0; i < screen->savelines; i++) {
		k += BUF_HEAD;
		for (j = BUF_HEAD; j < MAX_PTRS; j++) {
		    if ((screen->allbuf[k++] =
			 TypeCallocN(Char, (unsigned) MaxCols(screen))
			) == NULL)
			SysError(ERROR_SBRALLOC2);
		}
	    }
	}

d493 1
a493 1
	    ScrollBarOn(xw, False, False);
@


1.4
log
@xterm 238. includes fix for CVE-2008-2383.
@
text
@d1 1
a1 1
/* $XTermId: scrollbar.c,v 1.137 2008/12/30 15:40:13 tom Exp $ */
d6 1
a6 1
 * Copyright 2000-2007,2008 by Thomas E. Dickey
d81 1
a81 1
#define SCROLLBAR_BORDER(xw) ((xw)->screen.scrollBarBorder)
d99 1
a99 1
    TScreen *screen = &xw->screen;
d101 2
a102 2
    int border = 2 * xw->screen.border;
    int min_wide = border + xw->screen.fullVwin.sb_info.width;
d176 2
a177 2
    reqWidth = MaxCols(screen) * FontWidth(screen) + min_wide;
    reqHeight = MaxRows(screen) * FontHeight(screen) + min_high;
a222 19
static XtermWidget
xtermScroller(Widget xw)
{
    XtermWidget result = 0;

    if (xw != 0) {
	if (IsXtermWidget(xw)) {
	    result = (XtermWidget) xw;
	} else {
	    /*
	     * This may have been the scrollbar widget.  Try its parent, which
	     * would be the VT100 widget.
	     */
	    result = xtermScroller(XtParent(xw));
	}
    }
    return result;
}

d246 1
a246 1
    XtermWidget xw = xtermScroller(scrollWidget);
d249 1
a249 1
	SbInfo *sb = &(xw->screen.fullVwin.sb_info);
d287 1
a287 1
    XtermWidget xw = xtermScroller(scrollWidget);
d290 1
a290 1
	TScreen *screen = &xw->screen;
d306 1
a306 1
    TScreen *screen = &(xw->screen);
d326 4
a329 4
			     xpos,
			     ypos,
			     width,
			     height,
d338 1
a338 1
    TScreen *screen = &(xw->screen);
d374 1
a374 1
		  (unsigned) lines * FontHeight(screen),
d391 1
a391 1
    TScreen *screen = &xw->screen;
d404 1
a404 1
    TScreen *screen = &xw->screen;
d431 3
a433 1
			     MAX_PTRS * (screen->max_row + 2 + screen->savelines),
d439 2
a440 1
		    MAX_PTRS * (screen->max_row + 2) * sizeof(char *));
d486 1
a486 1
    TScreen *screen = &xw->screen;
d512 1
a512 1
    TScreen *screen = &xw->screen;
d535 1
a535 1
    XtermWidget xw = xtermScroller(scrollbarWidget);
d539 1
a539 1
	TScreen *screen = &xw->screen;
d560 1
a560 1
    XtermWidget xw = xtermScroller(scrollbarWidget);
d565 1
a565 1
	TScreen *screen = &xw->screen;
d657 1
a657 1
AmountToScroll(Widget xw, String * params, Cardinal nparams)
d659 8
a666 13
    if (xw != 0) {
	if (IsXtermWidget(xw)) {
	    TScreen *screen = TScreenOf((XtermWidget) xw);
	    if (nparams > 2
		&& screen->send_mouse_pos != MOUSE_OFF)
		return 0;
	    return params_to_pixels(screen, params, nparams);
	} else {
	    /*
	     * This may have been the scrollbar widget.  Try its parent, which
	     * would be the VT100 widget.
	     */
	    return AmountToScroll(XtParent(xw), params, nparams);
d669 1
a669 1
    return 0;
@


1.3
log
@xterm-236. Tested by form@@ and simon@@.
@
text
@d1 1
a1 1
/* $XTermId: scrollbar.c,v 1.136 2008/06/03 20:55:33 tom Exp $ */
d75 1
d597 1
a597 1
 * assume that b is lower case and allow plural
d600 1
a600 1
specialcmplowerwiths(char *a, char *b, int *modifier)
d602 1
d610 2
a611 2
	ca = char2lower(*a);
	cb = *b;
d619 1
a619 1
    if (ca == 's')
d626 2
a627 1
	return 1;
d630 2
a631 1
	return 1;
d634 2
a635 1
	return 0;
d637 1
d650 1
a650 1
	if (specialcmplowerwiths(s, "page", &modifier)) {
d652 1
a652 1
	} else if (specialcmplowerwiths(s, "halfpage", &modifier)) {
d654 1
a654 1
	} else if (specialcmplowerwiths(s, "pixel", &modifier)) {
@


1.2
log
@update to xterm 234. tested by merdely@@, 'looks ok' deraadt@@.
@
text
@d1 1
a1 1
/* $XTermId: scrollbar.c,v 1.134 2008/02/28 01:07:30 tom Exp $ */
d183 2
a184 6
    geomreqresult = XtMakeResizeRequest((Widget) xw, reqWidth, reqHeight,
					&repWidth, &repHeight);
    TRACE(("scrollbar.c XtMakeResizeRequest %dx%d -> %dx%d (status %d)\n",
	   reqHeight, reqWidth,
	   repHeight, repWidth,
	   geomreqresult));
d188 2
a189 2
	geomreqresult = XtMakeResizeRequest((Widget) xw, repWidth,
					    repHeight, NULL, NULL);
d326 4
a329 3
    int height = screen->fullVwin.height + screen->border * 2;
    int width = screen->scrollWidget->core.width;
    int ypos = -ScrollBarBorder(xw);
d331 5
a335 5
    int xpos = ((xw->misc.useRight)
		? (screen->fullVwin.fullwidth -
		   screen->scrollWidget->core.width -
		   BorderWidth(screen->scrollWidget))
		: -ScrollBarBorder(xw));
d337 1
a337 1
    int xpos = -ScrollBarBorder(xw);
d340 1
a340 1
    TRACE(("ResizeScrollBar at %d,%d %dx%d\n", ypos, xpos, height, width));
d342 9
a350 8
    XtConfigureWidget(
			 screen->scrollWidget,
			 xpos,
			 ypos,
			 width,
			 height,
			 BorderWidth(screen->scrollWidget));
    ScrollBarDrawThumb(screen->scrollWidget);
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/* $XTermId: scrollbar.c,v 1.124 2006/07/23 19:48:49 tom Exp $ */
d6 1
a6 1
 * Copyright 2000-2005,2006 by Thomas E. Dickey
a102 3
#if 1				/* ndef nothack */
    long supp;
#endif
d106 1
a106 1
    struct _vtwin *saveWin = WhichVWin(screen);
d164 1
a164 3
    if (!XGetWMNormalHints(screen->display, XtWindow(SHELL_OF(xw)),
			   &xw->hints, &supp))
	bzero(&xw->hints, sizeof(xw->hints));
d195 7
d217 1
a217 1
    XSync(screen->display, FALSE);	/* synchronize */
d226 19
d268 19
a286 3
    SbInfo *sb = &(term->screen.fullVwin.sb_info);
    Arg args[4];
    Cardinal nargs = XtNumber(args);
d288 13
a300 22
    /*
     * Remember the scrollbar's original colors.
     */
    if (sb->rv_cached == False) {
	XtSetArg(args[0], XtNbackground, &(sb->bg));
	XtSetArg(args[1], XtNforeground, &(sb->fg));
	XtSetArg(args[2], XtNborderColor, &(sb->bdr));
	XtSetArg(args[3], XtNborderPixmap, &(sb->bdpix));
	XtGetValues(scrollWidget, args, nargs);
	sb->rv_cached = True;
	sb->rv_active = 0;
    }

    sb->rv_active = !(sb->rv_active);
    XtSetArg(args[!(sb->rv_active)], XtNbackground, sb->bg);
    XtSetArg(args[(sb->rv_active)], XtNforeground, sb->fg);
    nargs = 2;			/* don't set border_pixmap */
    if (sb->bdpix == XtUnspecifiedPixmap) {	/* if not pixmap then pixel */
	if (sb->rv_active) {	/* keep border visible */
	    XtSetArg(args[2], XtNborderColor, args[1].value);
	} else {
	    XtSetArg(args[2], XtNborderColor, sb->bdr);
d302 1
a302 1
	nargs = 3;
a303 1
    XtSetValues(scrollWidget, args, nargs);
d309 1
a309 2
    TScreen *screen = &term->screen;
    int thumbTop, thumbHeight, totalHeight;
d311 12
a322 7
    thumbTop = ROW2INX(screen, screen->savedlines);
    thumbHeight = MaxRows(screen);
    totalHeight = thumbHeight + screen->savedlines;

    XawScrollbarSetThumb(scrollWidget,
			 ((float) thumbTop) / totalHeight,
			 ((float) thumbHeight) / totalHeight);
d356 1
a356 1
WindowScroll(TScreen * screen, int top)
d358 1
d383 1
a383 1
    scrolling_copy_area(term, scrolltop, scrollheight, -i);
d395 2
a396 2
		  FALSE);
    ScrnRefresh(term, refreshtop, 0, lines, MaxCols(screen), False);
d419 1
a420 1
#endif
d494 1
a494 1
	    XClearWindow(screen->display, XtWindow(xw));
d501 1
a501 1
ScrollBarOff(TScreen * screen)
d503 2
d509 1
a509 1
    if (XtIsRealized((Widget) term)) {
d512 1
a512 1
	DoResizeScreen(term);
d515 1
a515 1
	    XClearWindow(screen->display, XtWindow(term));
d527 1
a527 1
ToggleScrollBar(XtermWidget w)
d529 1
a529 1
    TScreen *screen = &w->screen;
d536 1
a536 1
	    ScrollBarOff(screen);
d538 1
a538 1
	    ScrollBarOn(w, FALSE, FALSE);
d548 1
a548 1
		Widget scrollbarWidget GCC_UNUSED,
d552 1
a552 4
    float *topPercent = (float *) call_data;
    TScreen *screen = &term->screen;
    int thumbTop;		/* relative to first saved line */
    int newTopLine;
d554 14
a567 7
    /*
     * screen->savedlines : Number of offscreen text lines,
     * MaxRows(screen)    : Number of onscreen  text lines,
     */
    thumbTop = (int) (*topPercent * (screen->savedlines + MaxRows(screen)));
    newTopLine = thumbTop - screen->savedlines;
    WindowScroll(screen, newTopLine);
d573 1
a573 1
		      Widget scrollbarWidget GCC_UNUSED,
d577 1
a577 1
    long pixels = (long) call_data;
d579 2
a580 2
    TScreen *screen = &term->screen;
    int rowOnScreen, newTopLine;
d582 12
a593 6
    rowOnScreen = pixels / FontHeight(screen);
    if (rowOnScreen == 0) {
	if (pixels < 0)
	    rowOnScreen = -1;
	else if (pixels > 0)
	    rowOnScreen = 1;
a594 2
    newTopLine = ROW2INX(screen, rowOnScreen);
    WindowScroll(screen, newTopLine);
d669 1
a669 1
AmountToScroll(Widget gw, String * params, Cardinal nparams)
d671 3
a673 3
    if (gw != 0) {
	if (IsXtermWidget(gw)) {
	    TScreen *screen = &((XtermWidget) gw)->screen;
d683 1
a683 1
	    return AmountToScroll(XtParent(gw), params, nparams);
d692 1
a692 1
		       Widget gw,
d699 2
a700 2
    if ((amount = AmountToScroll(gw, params, *nparams)) != 0) {
	ScrollTextUpDownBy(gw, (XtPointer) 0, (XtPointer) amount);
d707 1
a707 1
		    Widget gw,
d714 2
a715 2
    if ((amount = -AmountToScroll(gw, params, *nparams)) != 0) {
	ScrollTextUpDownBy(gw, (XtPointer) 0, (XtPointer) amount);
@


1.1.1.1
log
@Importing xterm 216
@
text
@@


1.1.1.2
log
@import xterm 225
@
text
@d1 1
a1 1
/* $XTermId: scrollbar.c,v 1.132 2007/02/11 14:49:56 tom Exp $ */
d6 1
a6 1
 * Copyright 2000-2006,2007 by Thomas E. Dickey
d103 3
d109 1
a109 1
    VTwin *saveWin = WhichVWin(screen);
d167 3
a169 1
    getXtermSizeHints(xw);
d215 1
a215 1
    XSync(screen->display, False);	/* synchronize */
a223 19
static XtermWidget
xtermScroller(Widget xw)
{
    XtermWidget result = 0;

    if (xw != 0) {
	if (IsXtermWidget(xw)) {
	    result = (XtermWidget) xw;
	} else {
	    /*
	     * This may have been the scrollbar widget.  Try its parent, which
	     * would be the VT100 widget.
	     */
	    result = xtermScroller(XtParent(xw));
	}
    }
    return result;
}

d247 3
a249 1
    XtermWidget xw = xtermScroller(scrollWidget);
d251 22
a272 16
    if (xw != 0) {
	SbInfo *sb = &(xw->screen.fullVwin.sb_info);
	Arg args[4];
	Cardinal nargs = XtNumber(args);

	/*
	 * Remember the scrollbar's original colors.
	 */
	if (sb->rv_cached == False) {
	    XtSetArg(args[0], XtNbackground, &(sb->bg));
	    XtSetArg(args[1], XtNforeground, &(sb->fg));
	    XtSetArg(args[2], XtNborderColor, &(sb->bdr));
	    XtSetArg(args[3], XtNborderPixmap, &(sb->bdpix));
	    XtGetValues(scrollWidget, args, nargs);
	    sb->rv_cached = True;
	    sb->rv_active = 0;
d274 1
a274 16

	sb->rv_active = !(sb->rv_active);
	XtSetArg(args[!(sb->rv_active)], XtNbackground, sb->bg);
	XtSetArg(args[(sb->rv_active)], XtNforeground, sb->fg);
	nargs = 2;		/* don't set border_pixmap */
	if (sb->bdpix == XtUnspecifiedPixmap) {
	    /* if not pixmap then pixel */
	    if (sb->rv_active) {
		/* keep border visible */
		XtSetArg(args[2], XtNborderColor, args[1].value);
	    } else {
		XtSetArg(args[2], XtNborderColor, sb->bdr);
	    }
	    nargs = 3;
	}
	XtSetValues(scrollWidget, args, nargs);
d276 1
d282 2
a283 1
    XtermWidget xw = xtermScroller(scrollWidget);
d285 7
a291 12
    if (xw != 0) {
	TScreen *screen = &xw->screen;
	int thumbTop, thumbHeight, totalHeight;

	thumbTop = ROW2INX(screen, screen->savedlines);
	thumbHeight = MaxRows(screen);
	totalHeight = thumbHeight + screen->savedlines;

	XawScrollbarSetThumb(scrollWidget,
			     ((float) thumbTop) / totalHeight,
			     ((float) thumbHeight) / totalHeight);
    }
d325 1
a325 1
WindowScroll(XtermWidget xw, int top)
a326 1
    TScreen *screen = &(xw->screen);
d351 1
a351 1
    scrolling_copy_area(xw, scrolltop, scrollheight, -i);
d363 2
a364 2
		  False);
    ScrnRefresh(xw, refreshtop, 0, lines, MaxCols(screen), False);
d387 1
a388 1

d462 1
a462 1
	    xtermClear(xw);
d469 1
a469 1
ScrollBarOff(XtermWidget xw)
a470 2
    TScreen *screen = &xw->screen;

d475 1
a475 1
    if (XtIsRealized((Widget) xw)) {
d478 1
a478 1
	DoResizeScreen(xw);
d481 1
a481 1
	    xtermClear(xw);
d493 1
a493 1
ToggleScrollBar(XtermWidget xw)
d495 1
a495 1
    TScreen *screen = &xw->screen;
d502 1
a502 1
	    ScrollBarOff(xw);
d504 1
a504 1
	    ScrollBarOn(xw, False, False);
d514 1
a514 1
		Widget scrollbarWidget,
d518 4
a521 1
    XtermWidget xw = xtermScroller(scrollbarWidget);
d523 7
a529 14
    if (xw != 0) {
	float *topPercent = (float *) call_data;
	TScreen *screen = &xw->screen;
	int thumbTop;		/* relative to first saved line */
	int newTopLine;

	/*
	 * screen->savedlines : Number of offscreen text lines,
	 * MaxRows(screen)    : Number of onscreen  text lines,
	 */
	thumbTop = (int) (*topPercent * (screen->savedlines + MaxRows(screen)));
	newTopLine = thumbTop - screen->savedlines;
	WindowScroll(xw, newTopLine);
    }
d535 1
a535 1
		      Widget scrollbarWidget,
d539 1
a539 1
    XtermWidget xw = xtermScroller(scrollbarWidget);
d541 2
a542 2
    if (xw != 0) {
	long pixels = (long) call_data;
d544 6
a549 12
	TScreen *screen = &xw->screen;
	int rowOnScreen, newTopLine;

	rowOnScreen = pixels / FontHeight(screen);
	if (rowOnScreen == 0) {
	    if (pixels < 0)
		rowOnScreen = -1;
	    else if (pixels > 0)
		rowOnScreen = 1;
	}
	newTopLine = ROW2INX(screen, rowOnScreen);
	WindowScroll(xw, newTopLine);
d551 2
d627 1
a627 1
AmountToScroll(Widget xw, String * params, Cardinal nparams)
d629 3
a631 3
    if (xw != 0) {
	if (IsXtermWidget(xw)) {
	    TScreen *screen = TScreenOf((XtermWidget) xw);
d641 1
a641 1
	    return AmountToScroll(XtParent(xw), params, nparams);
d650 1
a650 1
		       Widget xw,
d657 2
a658 2
    if ((amount = AmountToScroll(xw, params, *nparams)) != 0) {
	ScrollTextUpDownBy(xw, (XtPointer) 0, (XtPointer) amount);
d665 1
a665 1
		    Widget xw,
d672 2
a673 2
    if ((amount = -AmountToScroll(xw, params, *nparams)) != 0) {
	ScrollTextUpDownBy(xw, (XtPointer) 0, (XtPointer) amount);
@

