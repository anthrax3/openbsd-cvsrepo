head	1.24;
access;
symbols
	OPENBSD_6_1_BASE:1.24
	OPENBSD_6_0:1.24.0.4
	OPENBSD_6_0_BASE:1.24
	OPENBSD_5_9:1.24.0.2
	OPENBSD_5_9_BASE:1.24
	OPENBSD_5_8:1.23.0.4
	OPENBSD_5_8_BASE:1.23
	OPENBSD_5_7:1.23.0.2
	OPENBSD_5_7_BASE:1.23
	OPENBSD_5_6:1.21.0.2
	OPENBSD_5_6_BASE:1.21
	OPENBSD_5_5:1.19.0.2
	OPENBSD_5_5_BASE:1.19
	OPENBSD_5_4:1.17.0.2
	OPENBSD_5_4_BASE:1.17
	OPENBSD_5_3:1.15.0.2
	OPENBSD_5_3_BASE:1.15
	OPENBSD_5_2:1.14.0.2
	OPENBSD_5_2_BASE:1.14
	OPENBSD_5_1_BASE:1.12
	OPENBSD_5_1:1.12.0.4
	OPENBSD_5_0:1.12.0.2
	OPENBSD_5_0_BASE:1.12
	OPENBSD_4_9:1.10.0.2
	OPENBSD_4_9_BASE:1.10
	OPENBSD_4_8:1.8.0.4
	OPENBSD_4_8_BASE:1.8
	OPENBSD_4_7:1.6.0.2
	OPENBSD_4_7_BASE:1.6
	OPENBSD_4_6:1.3.0.2
	OPENBSD_4_6_BASE:1.3
	OPENBSD_4_5:1.2.0.2
	OPENBSD_4_5_BASE:1.2
	OPENBSD_4_4:1.1.1.4.0.4
	OPENBSD_4_4_BASE:1.1.1.4
	OPENBSD_4_3_BASE:1.1.1.4
	OPENBSD_4_3:1.1.1.4.0.2
	v232:1.1.1.4
	v229:1.1.1.3
	OPENBSD_4_2:1.1.1.2.0.2
	OPENBSD_4_2_BASE:1.1.1.2
	v225:1.1.1.2
	v216:1.1.1.1
	xterm:1.1.1;
locks; strict;
comment	@ * @;


1.24
date	2015.09.05.14.11.46;	author matthieu;	state Exp;
branches;
next	1.23;
commitid	YVUODLQ4QcYTuGkb;

1.23
date	2014.12.18.20.16.55;	author matthieu;	state Exp;
branches;
next	1.22;
commitid	pCMhkpVdt9Oe52hU;

1.22
date	2014.10.05.16.39.19;	author matthieu;	state Exp;
branches;
next	1.21;
commitid	0wVJ6bWh03LWbUdn;

1.21
date	2014.07.14.08.30.11;	author matthieu;	state Exp;
branches;
next	1.20;
commitid	EnwNNUjlkdrocnMa;

1.20
date	2014.05.09.19.56.40;	author matthieu;	state Exp;
branches;
next	1.19;

1.19
date	2014.01.02.15.14.50;	author matthieu;	state Exp;
branches;
next	1.18;

1.18
date	2013.08.26.20.06.13;	author matthieu;	state Exp;
branches;
next	1.17;

1.17
date	2013.06.02.19.55.50;	author matthieu;	state Exp;
branches;
next	1.16;

1.16
date	2013.03.09.14.45.38;	author matthieu;	state Exp;
branches;
next	1.15;

1.15
date	2013.01.04.16.40.18;	author matthieu;	state Exp;
branches;
next	1.14;

1.14
date	2012.06.07.20.20.23;	author matthieu;	state Exp;
branches;
next	1.13;

1.13
date	2012.04.14.09.02.46;	author matthieu;	state Exp;
branches;
next	1.12;

1.12
date	2011.06.07.19.21.06;	author matthieu;	state Exp;
branches;
next	1.11;

1.11
date	2011.03.07.20.41.27;	author matthieu;	state Exp;
branches;
next	1.10;

1.10
date	2010.10.23.19.14.52;	author matthieu;	state Exp;
branches;
next	1.9;

1.9
date	2010.08.22.13.38.11;	author matthieu;	state Exp;
branches;
next	1.8;

1.8
date	2010.05.08.12.20.46;	author matthieu;	state Exp;
branches;
next	1.7;

1.7
date	2010.03.25.22.03.51;	author matthieu;	state Exp;
branches;
next	1.6;

1.6
date	2009.10.31.14.11.57;	author matthieu;	state Exp;
branches;
next	1.5;

1.5
date	2009.09.05.16.06.57;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2009.09.05.15.58.09;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2009.03.09.22.13.04;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2008.08.25.18.05.57;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.26.11.11.42;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.11.26.11.11.42;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2007.06.15.19.30.33;	author matthieu;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2007.08.25.18.54.07;	author matthieu;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2008.02.16.09.35.13;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.24
log
@Update to xterm 320. Tested by jsg@@ Thanks.
@
text
@/* $XTermId: screen.c,v 1.512 2015/03/22 14:47:02 tom Exp $ */

/*
 * Copyright 1999-2014,2015 by Thomas E. Dickey
 *
 *                         All Rights Reserved
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 *
 * The above copyright notice and this permission notice shall be included
 * in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
 * IN NO EVENT SHALL THE ABOVE LISTED COPYRIGHT HOLDER(S) BE LIABLE FOR ANY
 * CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
 * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
 * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 *
 * Except as contained in this notice, the name(s) of the above copyright
 * holders shall not be used in advertising or otherwise to promote the
 * sale, use or other dealings in this Software without prior written
 * authorization.
 *
 *
 * Copyright 1987 by Digital Equipment Corporation, Maynard, Massachusetts.
 *
 *                         All Rights Reserved
 *
 * Permission to use, copy, modify, and distribute this software and its
 * documentation for any purpose and without fee is hereby granted,
 * provided that the above copyright notice appear in all copies and that
 * both that copyright notice and this permission notice appear in
 * supporting documentation, and that the name of Digital Equipment
 * Corporation not be used in advertising or publicity pertaining to
 * distribution of the software without specific, written prior permission.
 *
 *
 * DIGITAL DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING
 * ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL
 * DIGITAL BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR
 * ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
 * WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
 * ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
 * SOFTWARE.
 */

/* screen.c */

#include <stdio.h>
#include <xterm.h>
#include <error.h>
#include <data.h>
#include <xterm_io.h>

#include <X11/Xatom.h>

#if OPT_WIDE_ATTRS || OPT_WIDE_CHARS
#include <fontutils.h>
#endif

#include <menu.h>

#include <assert.h>
#include <signal.h>

#include <graphics.h>

#define inSaveBuf(screen, buf, inx) \
	((buf) == (screen)->saveBuf_index && \
	 ((inx) < (screen)->savelines || (screen)->savelines == 0))

#define getMinRow(screen) ((xw->flags & ORIGIN) ? (screen)->top_marg : 0)
#define getMaxRow(screen) ((xw->flags & ORIGIN) ? (screen)->bot_marg : (screen)->max_row)
#define getMinCol(screen) ((xw->flags & ORIGIN) ? (screen)->lft_marg : 0)
#define getMaxCol(screen) ((xw->flags & ORIGIN) ? (screen)->rgt_marg : (screen)->max_col)

#define MoveLineData(base, dst, src, len) \
	memmove(scrnHeadAddr(screen, base, (unsigned) (dst)), \
		scrnHeadAddr(screen, base, (unsigned) (src)), \
		(size_t) scrnHeadSize(screen, (unsigned) (len)))

#define SaveLineData(base, src, len) \
	(void) ScrnPointers(screen, len); \
	memcpy (screen->save_ptr, \
		scrnHeadAddr(screen, base, src), \
		(size_t) scrnHeadSize(screen, (unsigned) (len)))

#define RestoreLineData(base, dst, len) \
	memcpy (scrnHeadAddr(screen, base, dst), \
		screen->save_ptr, \
		(size_t) scrnHeadSize(screen, (unsigned) (len)))

#if OPT_SAVE_LINES
#define VisBuf(screen) screen->editBuf_index[screen->whichBuf]
#else
#define VisBuf(screen) scrnHeadAddr(screen, screen->saveBuf_index, (unsigned) savelines)
#endif

/*
 * ScrnPtr's can point to different types of data.
 */
#define SizeofScrnPtr(name) \
	(unsigned) sizeof(*((LineData *)0)->name)

/*
 * The pointers in LineData point into a block of text allocated as a single
 * chunk for the given number of rows.  Ensure that these pointers are aligned
 * at least to int-boundaries.
 */
#define AlignMask()      (sizeof(int) - 1)
#define IsAligned(value) (((unsigned long) (value) & AlignMask()) == 0)

#define AlignValue(value) \
		if (!IsAligned(value)) \
		    value = (value | (unsigned) AlignMask()) + 1

#define SetupScrnPtr(dst,src,type) \
		dst = (type *) (void *) src; \
		assert(IsAligned(dst)); \
		src += skipNcol##type

#define ScrnBufAddr(ptrs, offset)  (ScrnBuf)    ((void *) ((char *) (ptrs) + (offset)))
#define LineDataAddr(ptrs, offset) (LineData *) ((void *) ((char *) (ptrs) + (offset)))

#if OPT_TRACE > 1
static void
traceScrnBuf(const char *tag, TScreen *screen, ScrnBuf sb, unsigned len)
{
    unsigned j;

    TRACE(("traceScrnBuf %s\n", tag));
    for (j = 0; j < len; ++j) {
	LineData *src = (LineData *) scrnHeadAddr(screen, sb, j);
	TRACE(("%p %s%3d:%s\n",
	       src, ((int) j >= screen->savelines) ? "*" : " ",
	       j, visibleIChars(src->charData, src->lineSize)));
    }
    TRACE(("...traceScrnBuf %s\n", tag));
}

#define TRACE_SCRNBUF(tag, screen, sb, len) traceScrnBuf(tag, screen, sb, len)
#else
#define TRACE_SCRNBUF(tag, screen, sb, len)	/*nothing */
#endif

static unsigned
scrnHeadSize(TScreen *screen, unsigned count)
{
    unsigned result = SizeOfLineData;

    (void) screen;

#if OPT_WIDE_CHARS
    if (screen->wide_chars) {
	result += (unsigned) screen->lineExtra;
    }
#endif
    result *= count;

    return result;
}

ScrnBuf
scrnHeadAddr(TScreen *screen, ScrnBuf base, unsigned offset)
{
    unsigned size = scrnHeadSize(screen, offset);
    ScrnBuf result = ScrnBufAddr(base, size);

    assert((int) offset >= 0);

    return result;
}

/*
 * Given a block of data, build index to it in the 'base' parameter.
 */
void
setupLineData(TScreen *screen, ScrnBuf base, Char *data, unsigned nrow, unsigned ncol)
{
    unsigned i;
    unsigned offset = 0;
    unsigned jump = scrnHeadSize(screen, 1);
    LineData *ptr;
#if OPT_WIDE_CHARS
    unsigned j;
#endif
    /* these names are based on types */
    unsigned skipNcolIAttr;
    unsigned skipNcolCharData;
#if OPT_ISO_COLORS
    unsigned skipNcolCellColor;
#endif

    AlignValue(ncol);

    skipNcolIAttr = (ncol * SizeofScrnPtr(attribs));
    skipNcolCharData = (ncol * SizeofScrnPtr(charData));
#if OPT_ISO_COLORS
    skipNcolCellColor = (ncol * SizeofScrnPtr(color));
#endif

    for (i = 0; i < nrow; i++, offset += jump) {
	ptr = LineDataAddr(base, offset);

	ptr->lineSize = (Dimension) ncol;
	ptr->bufHead = 0;
#if OPT_DEC_CHRSET
	SetLineDblCS(ptr, 0);
#endif
	SetupScrnPtr(ptr->attribs, data, IAttr);
#if OPT_ISO_COLORS
	SetupScrnPtr(ptr->color, data, CellColor);
#endif
	SetupScrnPtr(ptr->charData, data, CharData);
#if OPT_WIDE_CHARS
	if (screen->wide_chars) {
	    unsigned extra = (unsigned) screen->max_combining;

	    ptr->combSize = (Char) extra;
	    for (j = 0; j < extra; ++j) {
		SetupScrnPtr(ptr->combData[j], data, CharData);
	    }
	}
#endif
    }
}

#define ExtractScrnData(name) \
		memcpy(dstPtrs->name, \
		       ((LineData *) srcPtrs)->name,\
		       dstCols * sizeof(dstPtrs->name[0])); \
		nextPtr += (srcCols * sizeof(dstPtrs->name[0]))

/*
 * As part of reallocating the screen buffer when resizing, extract from
 * the old copy of the screen buffer the data which will be used in the
 * new copy of the screen buffer.
 */
static void
extractScrnData(TScreen *screen,
		ScrnBuf dstPtrs,
		ScrnBuf srcPtrs,
		unsigned nrows,
		unsigned move_down)
{
    unsigned j;

    TRACE(("extractScrnData(nrows %d)\n", nrows));

    TRACE_SCRNBUF("extract from", screen, srcPtrs, nrows);
    for (j = 0; j < nrows; j++) {
	LineData *dst = (LineData *) scrnHeadAddr(screen,
						  dstPtrs, j + move_down);
	LineData *src = (LineData *) scrnHeadAddr(screen,
						  srcPtrs, j);
	copyLineData(dst, src);
    }
}

static ScrnPtr *
allocScrnHead(TScreen *screen, unsigned nrow)
{
    ScrnPtr *result;
    unsigned size = scrnHeadSize(screen, 1);

    result = (ScrnPtr *) calloc((size_t) nrow, (size_t) size);
    if (result == 0)
	SysError(ERROR_SCALLOC);

    TRACE(("allocScrnHead %d -> %d -> %p..%p\n", nrow, nrow * size,
	   (void *) result,
	   (char *) result + (nrow * size) - 1));
    return result;
}

/*
 * Return the size of a line's data.
 */
static unsigned
sizeofScrnRow(TScreen *screen, unsigned ncol)
{
    unsigned result;
    unsigned sizeAttribs;
#if OPT_ISO_COLORS
    unsigned sizeColors;
#endif

    (void) screen;

    result = (ncol * (unsigned) sizeof(CharData));
    AlignValue(result);

#if OPT_WIDE_CHARS
    if (screen->wide_chars) {
	result *= (unsigned) (1 + screen->max_combining);
    }
#endif

    sizeAttribs = (ncol * SizeofScrnPtr(attribs));
    AlignValue(sizeAttribs);
    result += sizeAttribs;

#if OPT_ISO_COLORS
    sizeColors = (ncol * SizeofScrnPtr(color));
    AlignValue(sizeColors);
    result += sizeColors;
#endif

    return result;
}

Char *
allocScrnData(TScreen *screen, unsigned nrow, unsigned ncol)
{
    Char *result;
    size_t length;

    AlignValue(ncol);
    length = ((nrow + 1) * sizeofScrnRow(screen, ncol));
    if (length == 0
	|| (result = (Char *) calloc(length, sizeof(Char))) == 0)
	  SysError(ERROR_SCALLOC2);

    TRACE(("allocScrnData %ux%u -> %lu -> %p..%p\n",
	   nrow, ncol, (unsigned long) length, result, result + length - 1));
    return result;
}

/*
 * Allocates memory for a 2-dimensional array of chars and returns a pointer
 * thereto.  Each line is formed from a set of char arrays, with an index
 * (i.e., the ScrnBuf type).  The first pointer in the index is reserved for
 * per-line flags, and does not point to data.
 *
 * After the per-line flags, we have a series of pointers to char arrays:  The
 * first one is the actual character array, the second one is the attributes,
 * the third is the foreground and background colors, and the fourth denotes
 * the character set.
 *
 * We store it all as pointers, because of alignment considerations.
 */
ScrnBuf
allocScrnBuf(XtermWidget xw, unsigned nrow, unsigned ncol, Char **addr)
{
    TScreen *screen = TScreenOf(xw);
    ScrnBuf base = 0;

    if (nrow != 0) {
	base = allocScrnHead(screen, nrow);
	*addr = allocScrnData(screen, nrow, ncol);

	setupLineData(screen, base, *addr, nrow, ncol);
    }

    TRACE(("allocScrnBuf %dx%d ->%p\n", nrow, ncol, (void *) base));
    return (base);
}

#if OPT_SAVE_LINES
/*
 * Copy line-data from the visible (edit) buffer to the save-lines buffer.
 */
static void
saveEditBufLines(TScreen *screen, ScrnBuf sb, unsigned n)
{
    unsigned j;

    TRACE(("...copying %d lines from editBuf to saveBuf\n", n));
#if OPT_FIFO_LINES
    (void) sb;
#endif
    for (j = 0; j < n; ++j) {
#if OPT_FIFO_LINES
	LineData *dst = addScrollback(screen);
#else
	unsigned k = (screen->savelines + j - n);
	LineData *dst = (LineData *) scrnHeadAddr(screen, sb, k);
#endif
	LineData *src = getLineData(screen, (int) j);
	copyLineData(dst, src);
    }
}

/*
 * Copy line-data from the save-lines buffer to the visible (edit) buffer.
 */
static void
unsaveEditBufLines(TScreen *screen, ScrnBuf sb, unsigned n)
{
    unsigned j;

    TRACE(("...copying %d lines from saveBuf to editBuf\n", n));
    for (j = 0; j < n; ++j) {
	int extra = (int) (n - j);
	LineData *dst = (LineData *) scrnHeadAddr(screen, sb, j);
#if OPT_FIFO_LINES
	CLineData *src;

	if (extra > screen->saved_fifo || extra > screen->savelines) {
	    TRACE(("...FIXME: must clear text!\n"));
	    continue;
	}
	src = getScrollback(screen, -extra);
#else
	unsigned k = (screen->savelines - extra);
	CLineData *src = CLineData *scrnHeadAddr(screen,
						 screen->saveBuf_index, k);
#endif
	copyLineData(dst, src);
    }
}
#endif

/*
 *  This is called when the screen is resized.
 *  Returns the number of lines the text was moved down (neg for up).
 *  (Return value only necessary with SouthWestGravity.)
 */
static int
Reallocate(XtermWidget xw,
	   ScrnBuf *sbuf,
	   Char **sbufaddr,
	   unsigned nrow,
	   unsigned ncol,
	   unsigned oldrow)
{
    TScreen *screen = TScreenOf(xw);
    ScrnBuf oldBufHead;
    ScrnBuf newBufHead;
    Char *newBufData;
    unsigned minrows;
    Char *oldBufData;
    int move_down = 0, move_up = 0;

    if (sbuf == NULL || *sbuf == NULL) {
	return 0;
    }

    oldBufData = *sbufaddr;

    TRACE(("Reallocate %dx%d -> %dx%d\n", oldrow, MaxCols(screen), nrow, ncol));

    /*
     * realloc sbuf, the pointers to all the lines.
     * If the screen shrinks, remove lines off the top of the buffer
     * if resizeGravity resource says to do so.
     */
    TRACE(("Check move_up, nrow %d vs oldrow %d (resizeGravity %s)\n",
	   nrow, oldrow,
	   BtoS(GravityIsSouthWest(xw))));
    if (GravityIsSouthWest(xw)) {
	if (nrow < oldrow) {
	    /* Remove lines off the top of the buffer if necessary. */
	    move_up = (int) (oldrow - nrow)
		- (TScreenOf(xw)->max_row - TScreenOf(xw)->cur_row);
	    if (move_up < 0)
		move_up = 0;
	    /* Overlapping move here! */
	    TRACE(("move_up %d\n", move_up));
	    if (move_up) {
		ScrnBuf dst = *sbuf;
		unsigned len = (unsigned) ((int) oldrow - move_up);

		TRACE_SCRNBUF("before move_up", screen, dst, oldrow);
		SaveLineData(dst, 0, (size_t) move_up);
		MoveLineData(dst, 0, (size_t) move_up, len);
		RestoreLineData(dst, len, (size_t) move_up);
		TRACE_SCRNBUF("after move_up", screen, dst, oldrow);
	    }
	}
    }
    oldBufHead = *sbuf;
    *sbuf = allocScrnHead(screen, (unsigned) nrow);
    newBufHead = *sbuf;

    /*
     * Create the new buffer space and copy old buffer contents there, line by
     * line.
     */
    newBufData = allocScrnData(screen, nrow, ncol);
    *sbufaddr = newBufData;

    minrows = (oldrow < nrow) ? oldrow : nrow;
    if (GravityIsSouthWest(xw)) {
	if (nrow > oldrow) {
	    /* move data down to bottom of expanded screen */
	    move_down = Min((int) (nrow - oldrow), TScreenOf(xw)->savedlines);
	}
    }

    setupLineData(screen, newBufHead, *sbufaddr, nrow, ncol);
    extractScrnData(screen, newBufHead, oldBufHead, minrows,
#if OPT_SAVE_LINES
		    0
#else
		    (unsigned) move_down
#endif
	);
    free(oldBufHead);

    /* Now free the old data */
    free(oldBufData);

    TRACE(("...Reallocate %dx%d ->%p\n", nrow, ncol, (void *) newBufHead));
    return move_down ? move_down : -move_up;	/* convert to rows */
}

#if OPT_WIDE_CHARS
/*
 * This function reallocates memory if changing the number of Buf offsets.
 * The code is based on Reallocate().
 */
static void
ReallocateBufOffsets(XtermWidget xw,
		     ScrnBuf *sbuf,
		     Char **sbufaddr,
		     unsigned nrow,
		     unsigned ncol)
{
    TScreen *screen = TScreenOf(xw);
    unsigned i;
    ScrnBuf newBufHead;
    Char *oldBufData;
    ScrnBuf oldBufHead;

    unsigned old_jump = scrnHeadSize(screen, 1);
    unsigned new_jump;
    unsigned new_ptrs = 1 + (unsigned) (screen->max_combining);
    unsigned dstCols = ncol;
    unsigned srcCols = ncol;
    LineData *dstPtrs;
    LineData *srcPtrs;
    Char *nextPtr;

    assert(nrow != 0);
    assert(ncol != 0);

    oldBufData = *sbufaddr;
    oldBufHead = *sbuf;

    /*
     * Allocate a new LineData array, retain the old one until we've copied
     * the data that it points to, as well as non-pointer data, e.g., bufHead.
     *
     * Turn on wide-chars temporarily when constructing pointers, since that is
     * used to decide whether to address the combData[] array, which affects
     * the length of the LineData structure.
     */
    screen->wide_chars = True;

    new_jump = scrnHeadSize(screen, 1);
    newBufHead = allocScrnHead(screen, nrow);
    *sbufaddr = allocScrnData(screen, nrow, ncol);
    setupLineData(screen, newBufHead, *sbufaddr, nrow, ncol);

    screen->wide_chars = False;

    nextPtr = *sbufaddr;

    srcPtrs = (LineData *) oldBufHead;
    dstPtrs = (LineData *) newBufHead;
    for (i = 0; i < nrow; i++) {
	dstPtrs->bufHead = srcPtrs->bufHead;
	ExtractScrnData(attribs);
#if OPT_ISO_COLORS
	ExtractScrnData(color);
#endif
	ExtractScrnData(charData);

	nextPtr += ncol * new_ptrs;
	srcPtrs = LineDataAddr(srcPtrs, old_jump);
	dstPtrs = LineDataAddr(dstPtrs, new_jump);
    }

    /* Now free the old data */
    free(oldBufData);
    free(oldBufHead);

    *sbuf = newBufHead;

    TRACE(("ReallocateBufOffsets %dx%d ->%p\n", nrow, ncol, *sbufaddr));
}

#if OPT_FIFO_LINES
/*
 * Allocate a new FIFO index.
 */
static void
ReallocateFifoIndex(XtermWidget xw)
{
    TScreen *screen = TScreenOf(xw);

    if (screen->savelines > 0 && screen->saveBuf_index != 0) {
	ScrnBuf newBufHead;
	LineData *dstPtrs;
	LineData *srcPtrs;
	unsigned i;
	unsigned old_jump = scrnHeadSize(screen, 1);
	unsigned new_jump;

	screen->wide_chars = True;
	newBufHead = allocScrnHead(screen, (unsigned) screen->savelines);
	new_jump = scrnHeadSize(screen, 1);

	srcPtrs = (LineData *) screen->saveBuf_index;
	dstPtrs = (LineData *) newBufHead;

	for (i = 0; i < (unsigned) screen->savelines; ++i) {
	    memcpy(dstPtrs, srcPtrs, SizeOfLineData);
	    srcPtrs = LineDataAddr(srcPtrs, old_jump);
	    dstPtrs = LineDataAddr(dstPtrs, new_jump);
	}

	screen->wide_chars = False;
	free(screen->saveBuf_index);
	screen->saveBuf_index = newBufHead;
    }
}
#endif

/*
 * This function dynamically adds support for wide-characters.
 */
void
ChangeToWide(XtermWidget xw)
{
    TScreen *screen = TScreenOf(xw);

    if (screen->wide_chars)
	return;

    TRACE(("ChangeToWide\n"));
    if (xtermLoadWideFonts(xw, True)) {
	int whichBuf = screen->whichBuf;

#if !OPT_FIFO_LINES || !OPT_SAVE_LINES
	int savelines = screen->scrollWidget ? screen->savelines : 0;

	if (savelines < 0)
	    savelines = 0;
#endif

	/*
	 * If we're displaying the alternate screen, switch the pointers back
	 * temporarily so ReallocateBufOffsets() will operate on the proper
	 * data in the alternate buffer.
	 */
	if (screen->whichBuf)
	    SwitchBufPtrs(screen, 0);

#if OPT_SAVE_LINES
#if OPT_FIFO_LINES
	ReallocateFifoIndex(xw);
#else
	ReallocateBufOffsets(xw,
			     &screen->saveBuf_index,
			     &screen->saveBuf_data,
			     (unsigned) savelines,
			     (unsigned) MaxCols(screen));
#endif
	if (screen->editBuf_index[0]) {
	    ReallocateBufOffsets(xw,
				 &screen->editBuf_index[0],
				 &screen->editBuf_data[0],
				 (unsigned) MaxRows(screen),
				 (unsigned) MaxCols(screen));
	}
#else
	ReallocateBufOffsets(xw,
			     &screen->saveBuf_index,
			     &screen->saveBuf_data,
			     (unsigned) (MaxRows(screen) + savelines),
			     (unsigned) MaxCols(screen));
#endif
	if (screen->editBuf_index[1]) {
	    ReallocateBufOffsets(xw,
				 &screen->editBuf_index[1],
				 &screen->editBuf_data[1],
				 (unsigned) MaxRows(screen),
				 (unsigned) MaxCols(screen));
	}

	screen->wide_chars = True;
	screen->visbuf = VisBuf(screen);

	/*
	 * Switch the pointers back before we start painting on the screen.
	 */
	if (whichBuf)
	    SwitchBufPtrs(screen, whichBuf);

	update_font_utf8_mode();
	SetVTFont(xw, screen->menu_font_number, True, NULL);
    }
    TRACE(("...ChangeToWide\n"));
}
#endif

/*
 * Copy cells, no side-effects.
 */
void
CopyCells(TScreen *screen, LineData *src, LineData *dst, int col, int len)
{
    if (len > 0) {
	int n;
	int last = col + len;

	for (n = col; n < last; ++n) {
	    dst->charData[n] = src->charData[n];
	    dst->attribs[n] = src->attribs[n];
	}

	if_OPT_ISO_COLORS(screen, {
	    for (n = col; n < last; ++n) {
		dst->color[n] = src->color[n];
	    }
	});
	if_OPT_WIDE_CHARS(screen, {
	    size_t off;
	    for (n = col; n < last; ++n) {
		for_each_combData(off, src) {
		    dst->combData[off][n] = src->combData[off][n];
		}
	    }
	});
    }
}

static void
FillIAttr(IAttr * target, unsigned source, size_t count)
{
    while (count-- != 0) {
	*target++ = (IAttr) source;
    }
}

/*
 * Clear cells, no side-effects.
 */
void
ClearCells(XtermWidget xw, int flags, unsigned len, int row, int col)
{
    if (len != 0) {
	TScreen *screen = TScreenOf(xw);
	LineData *ld;
	unsigned n;

	ld = getLineData(screen, row);

	flags = (int) ((unsigned) flags | TERM_COLOR_FLAGS(xw));

	for (n = 0; n < len; ++n)
	    ld->charData[(unsigned) col + n] = (CharData) ' ';

	FillIAttr(ld->attribs + col, (unsigned) flags, (size_t) len);

	if_OPT_ISO_COLORS(screen, {
	    CellColor p = xtermColorPair(xw);
	    for (n = 0; n < len; ++n) {
		ld->color[(unsigned) col + n] = p;
	    }
	});
	if_OPT_WIDE_CHARS(screen, {
	    size_t off;
	    for_each_combData(off, ld) {
		memset(ld->combData[off] + col, 0, (size_t) len * sizeof(CharData));
	    }
	});
    }
}

/*
 * Clear data in the screen-structure (no I/O).
 * Check for wide-character damage as well, clearing the damaged cells.
 */
void
ScrnClearCells(XtermWidget xw, int row, int col, unsigned len)
{
#if OPT_WIDE_CHARS
    TScreen *screen = TScreenOf(xw);
#endif
    int flags = 0;

    if_OPT_WIDE_CHARS(screen, {
	int kl;
	int kr;

	if (DamagedCells(screen, len, &kl, &kr, row, col)
	    && kr >= kl) {
	    ClearCells(xw, flags, (unsigned) (kr - kl + 1), row, kl);
	}
    });
    ClearCells(xw, flags, len, row, col);
}

/*
 * Disown the selection and repaint the area that is highlighted so it is no
 * longer highlighted.
 */
void
ScrnDisownSelection(XtermWidget xw)
{
    if (ScrnHaveSelection(TScreenOf(xw))) {
	if (TScreenOf(xw)->keepSelection) {
	    UnhiliteSelection(xw);
	} else {
	    DisownSelection(xw);
	}
    }
}

/*
 * Writes str into buf at screen's current row and column.  Characters are set
 * to match flags.
 */
void
ScrnWriteText(XtermWidget xw,
	      IChar *str,
	      unsigned flags,
	      unsigned cur_fg_bg,
	      unsigned length)
{
    TScreen *screen = TScreenOf(xw);
    LineData *ld;
    IAttr *attrs;
    int avail = MaxCols(screen) - screen->cur_col;
    IChar *chars;
#if OPT_WIDE_CHARS
    IChar starcol1;
#endif
    unsigned n;
    unsigned real_width = visual_width(str, length);

    (void) cur_fg_bg;		/* quiet compiler warnings when unused */

    if (real_width + (unsigned) screen->cur_col > (unsigned) MaxCols(screen)) {
	real_width = (unsigned) (MaxCols(screen) - screen->cur_col);
    }

    if (avail <= 0)
	return;
    if (length > (unsigned) avail)
	length = (unsigned) avail;
    if (length == 0 || real_width == 0)
	return;

    ld = getLineData(screen, screen->cur_row);

    chars = ld->charData + screen->cur_col;
    attrs = ld->attribs + screen->cur_col;

#if OPT_WIDE_CHARS
    starcol1 = *chars;
#endif

    /* write blanks if we're writing invisible text */
    for (n = 0; n < length; ++n) {
	if ((flags & INVISIBLE))
	    chars[n] = ' ';
	else
	    chars[n] = str[n];
    }

#if OPT_BLINK_TEXT
    if ((flags & BLINK) && !(screen->blink_as_bold)) {
	LineSetBlinked(ld);
    }
#endif

    if_OPT_WIDE_CHARS(screen, {

	if (real_width != length) {
	    IChar *char1 = chars;
	    if (screen->cur_col
		&& starcol1 == HIDDEN_CHAR
		&& isWide((int) char1[-1])) {
		char1[-1] = (CharData) ' ';
	    }
	    /* if we are overwriting the right hand half of a
	       wide character, make the other half vanish */
	    while (length) {
		int ch = (int) str[0];

		*char1++ = *str++;
		length--;

		if (isWide(ch)) {
		    *char1++ = (CharData) HIDDEN_CHAR;
		}
	    }

	    if (*char1 == HIDDEN_CHAR
		&& char1[-1] == HIDDEN_CHAR) {
		*char1 = (CharData) ' ';
	    }
	    /* if we are overwriting the left hand half of a
	       wide character, make the other half vanish */
	} else {
	    if (screen->cur_col
		&& starcol1 == HIDDEN_CHAR
		&& isWide((int) chars[-1])) {
		chars[-1] = (CharData) ' ';
	    }
	    /* if we are overwriting the right hand half of a
	       wide character, make the other half vanish */
	    if (chars[length] == HIDDEN_CHAR
		&& isWide((int) chars[length - 1])) {
		chars[length] = (CharData) ' ';
	    }
	}
    });

    flags &= ATTRIBUTES;
    flags |= CHARDRAWN;
    FillIAttr(attrs, flags, (size_t) real_width);

    if_OPT_WIDE_CHARS(screen, {
	size_t off;
	for_each_combData(off, ld) {
	    memset(ld->combData[off] + screen->cur_col,
		   0,
		   real_width * sizeof(CharData));
	}
    });
    if_OPT_ISO_COLORS(screen, {
	unsigned j;
	for (j = 0; j < real_width; ++j)
	    ld->color[screen->cur_col + (int) j] = (CellColor) cur_fg_bg;
    });

#if OPT_WIDE_CHARS
    screen->last_written_col = screen->cur_col + (int) real_width - 1;
    screen->last_written_row = screen->cur_row;
#endif

    TRACE(("text erasing cur_col=%d cur_row=%d real_width=%d\n",
	   screen->cur_col,
	   screen->cur_row,
	   real_width));
    chararea_clear_displayed_graphics(screen,
				      screen->cur_col,
				      screen->cur_row,
				      (int) real_width, 1);

    if_OPT_XMC_GLITCH(screen, {
	Resolve_XMC(xw);
    });

    return;
}

/*
 * Saves pointers to the n lines beginning at sb + where, and clears the lines
 */
static void
ScrnClearLines(XtermWidget xw, ScrnBuf sb, int where, unsigned n, unsigned size)
{
    TScreen *screen = TScreenOf(xw);
    ScrnPtr *base;
    unsigned jump = scrnHeadSize(screen, 1);
    unsigned i;
    LineData *work;
    unsigned flags = TERM_COLOR_FLAGS(xw);
#if OPT_ISO_COLORS
    unsigned j;
#endif

    TRACE(("ScrnClearLines(%s:where %d, n %d, size %d)\n",
	   (sb == screen->saveBuf_index) ? "save" : "edit",
	   where, n, size));

    assert((int) n > 0);
    assert(size != 0);

    /* save n lines at where */
    SaveLineData(sb, (unsigned) where, (size_t) n);

    /* clear contents of old rows */
    base = screen->save_ptr;
    for (i = 0; i < n; ++i) {
	work = (LineData *) base;
	work->bufHead = 0;
#if OPT_DEC_CHRSET
	SetLineDblCS(work, 0);
#endif

	memset(work->charData, 0, size * sizeof(CharData));
	if (TERM_COLOR_FLAGS(xw)) {
	    FillIAttr(work->attribs, flags, (size_t) size);
#if OPT_ISO_COLORS
	    {
		CellColor p = xtermColorPair(xw);
		for (j = 0; j < size; ++j) {
		    work->color[j] = p;
		}
	    }
#endif
	} else {
	    FillIAttr(work->attribs, 0, (size_t) size);
#if OPT_ISO_COLORS
	    memset(work->color, 0, size * sizeof(work->color[0]));
#endif
	}
#if OPT_WIDE_CHARS
	if (screen->wide_chars) {
	    size_t off;

	    for (off = 0; off < work->combSize; ++off) {
		memset(work->combData[off], 0, size * sizeof(CharData));
	    }
	}
#endif
	base = ScrnBufAddr(base, jump);
    }

    TRACE(("clear lines erasing where=%d screen->savelines=%d n=%d screen->max_col=%d\n",
	   where,
	   screen->savelines,
	   n,
	   screen->max_col));
    /* FIXME: this looks wrong -- rcombs */
    chararea_clear_displayed_graphics(screen,
				      where + screen->savelines,
				      0,
				      screen->max_col + 1,
				      (int) n);
}

/*
 * We're always ensured of having a visible buffer, but may not have saved
 * lines.  Check the pointer that's sure to work.
 */
#if OPT_SAVE_LINES
#define OkAllocBuf(screen) (screen->editBuf_index[0] != 0)
#else
#define OkAllocBuf(screen) (screen->saveBuf_index != 0)
#endif

void
ScrnAllocBuf(XtermWidget xw)
{
    TScreen *screen = TScreenOf(xw);

    if (!OkAllocBuf(screen)) {
	int nrows = MaxRows(screen);
#if !OPT_SAVE_LINES
	int savelines = screen->scrollWidget ? screen->savelines : 0;
#endif

	TRACE(("ScrnAllocBuf %dx%d (%d)\n",
	       nrows, MaxCols(screen), screen->savelines));

#if OPT_SAVE_LINES
	if (screen->savelines != 0) {
#if OPT_FIFO_LINES
	    /* for FIFO, we only need space for the index - addScrollback inits */
	    screen->saveBuf_index = allocScrnHead(screen,
						  (unsigned) (screen->savelines));
#else
	    screen->saveBuf_index = allocScrnBuf(xw,
						 (unsigned) screen->savelines,
						 (unsigned) MaxCols(screen),
						 &screen->saveBuf_data);
#endif
	} else {
	    screen->saveBuf_index = 0;
	}
	screen->editBuf_index[0] = allocScrnBuf(xw,
						(unsigned) nrows,
						(unsigned) MaxCols(screen),
						&screen->editBuf_data[0]);
#else /* !OPT_SAVE_LINES */
	screen->saveBuf_index = allocScrnBuf(xw,
					     (unsigned) (nrows + screen->savelines),
					     (unsigned) (MaxCols(screen)),
					     &screen->saveBuf_data);
#endif /* OPT_SAVE_LINES */
	screen->visbuf = VisBuf(screen);
    }
    return;
}

size_t
ScrnPointers(TScreen *screen, size_t len)
{
    size_t result = scrnHeadSize(screen, (unsigned) len);

    if (result > screen->save_len) {
	if (screen->save_len)
	    screen->save_ptr = (ScrnPtr *) realloc(screen->save_ptr, result);
	else
	    screen->save_ptr = (ScrnPtr *) malloc(result);
	screen->save_len = len;
	if (screen->save_ptr == 0)
	    SysError(ERROR_SAVE_PTR);
    }
    TRACE2(("ScrnPointers %ld ->%p\n", (long) len, screen->save_ptr));
    return result;
}

/*
 * Inserts n blank lines at sb + where, treating last as a bottom margin.
 */
void
ScrnInsertLine(XtermWidget xw, ScrnBuf sb, int last, int where, unsigned n)
{
    TScreen *screen = TScreenOf(xw);
    unsigned size = (unsigned) MaxCols(screen);

    TRACE(("ScrnInsertLine(last %d, where %d, n %d, size %d)\n",
	   last, where, n, size));

    if ((int) n > last)
	n = (unsigned) last;

    assert(where >= 0);
    assert(last >= where);

    assert((int) n > 0);
    assert(size != 0);

    /* save n lines at bottom */
    ScrnClearLines(xw, sb, (last -= (int) n - 1), n, size);

    /*
     * WARNING, overlapping copy operation.  Move down lines (pointers).
     *
     *   +----|---------|--------+
     *
     * is copied in the array to:
     *
     *   +--------|---------|----+
     */
    assert(last >= where);
    /*
     * This will never shift from the saveBuf to editBuf, so there is no need
     * to handle that case.
     */
    MoveLineData(sb,
		 (unsigned) (where + (int) n),
		 (unsigned) where,
		 (unsigned) (last - where));

    /* reuse storage for new lines at where */
    RestoreLineData(sb, (unsigned) where, n);
}

/*
 * Deletes n lines at sb + where, treating last as a bottom margin.
 */
void
ScrnDeleteLine(XtermWidget xw, ScrnBuf sb, int last, int where, unsigned n)
{
    TScreen *screen = TScreenOf(xw);
    unsigned size = (unsigned) MaxCols(screen);

    TRACE(("ScrnDeleteLine(%s:last %d, where %d, n %d, size %d)\n",
	   (sb == screen->saveBuf_index) ? "save" : "edit",
	   last, where, n, size));

    assert(where >= 0);
    assert(last >= where + (int) n - 1);

    assert((int) n > 0);
    assert(size != 0);

    /* move up lines */
    last -= ((int) n - 1);
#if OPT_SAVE_LINES
    if (inSaveBuf(screen, sb, where)) {
#if !OPT_FIFO_LINES
	int from = where + n;
#endif

	/* we shouldn't be editing the saveBuf, only scroll into it */
	assert(last >= screen->savelines);

	if (sb != 0) {
#if OPT_FIFO_LINES
	    /* copy lines from editBuf to saveBuf (allocating as we go...) */
	    saveEditBufLines(screen, sb, n);
#else
	    ScrnClearLines(xw, sb, where, n, size);

	    /* move the pointers within saveBuf */
	    TRACE(("...%smoving pointers in saveBuf (compare %d %d)\n",
		   ((screen->savelines > from)
		    ? ""
		    : "SKIP "),
		   screen->savelines,
		   from));
	    if (screen->savelines > from) {
		MoveLineData(sb,
			     (unsigned) where,
			     (unsigned) from,
			     (unsigned) (screen->savelines - from));
	    }

	    /* reuse storage in saveBuf */
	    TRACE(("...reuse %d lines storage in saveBuf\n", n));
	    RestoreLineData(sb, (unsigned) screen->savelines - n, n);

	    /* copy lines from editBuf to saveBuf (into the reused storage) */
	    saveEditBufLines(screen, sb, n);
#endif
	}

	/* adjust variables to fall-thru into changes only to editBuf */
	TRACE(("...adjusting variables, to work on editBuf alone\n"));
	last -= screen->savelines;
	where = 0;
	sb = screen->visbuf;
    }
#endif
    /*
     * Scroll the visible buffer (editBuf).
     */
    ScrnClearLines(xw, sb, where, n, size);

    MoveLineData(sb,
		 (unsigned) where,
		 (unsigned) (where + (int) n),
		 (size_t) (last - where));

    /* reuse storage for new bottom lines */
    RestoreLineData(sb, (unsigned) last, n);
}

/*
 * Inserts n blanks in screen at current row, col.  Size is the size of each
 * row.
 */
void
ScrnInsertChar(XtermWidget xw, unsigned n)
{
#define MemMove(data) \
    	for (j = last; j >= (col + (int) n); --j) \
	    data[j] = data[j - (int) n]

    TScreen *screen = TScreenOf(xw);
    int first = ScrnLeftMargin(xw);
    int last = ScrnRightMargin(xw);
    int row = screen->cur_row;
    int col = screen->cur_col;
    int j;
    LineData *ld;

    if (col < first || col > last) {
	TRACE(("ScrnInsertChar - col %d outside [%d..%d]\n", col, first, last));
	return;
    } else if (last < (col + (int) n)) {
	n = (unsigned) (last + 1 - col);
    }

    assert(screen->cur_col >= 0);
    assert(screen->cur_row >= 0);
    assert((int) n >= 0);
    assert((last + 1) >= (int) n);

    if_OPT_WIDE_CHARS(screen, {
	int xx = screen->cur_row;
	int kl;
	int kr = screen->cur_col;
	if (DamagedCells(screen, n, &kl, (int *) 0, xx, kr) && kr > kl) {
	    ClearCells(xw, 0, (unsigned) (kr - kl + 1), row, kl);
	}
	kr = last - (int) n + 1;
	if (DamagedCells(screen, n, &kl, (int *) 0, xx, kr) && kr > kl) {
	    ClearCells(xw, 0, (unsigned) (kr - kl + 1), row, kl);
	}
    });

    if ((ld = getLineData(screen, row)) != 0) {
	MemMove(ld->charData);
	MemMove(ld->attribs);

	if_OPT_ISO_COLORS(screen, {
	    MemMove(ld->color);
	});
	if_OPT_WIDE_CHARS(screen, {
	    size_t off;
	    for_each_combData(off, ld) {
		MemMove(ld->combData[off]);
	    }
	});
    }
    ClearCells(xw, CHARDRAWN, n, row, col);

#undef MemMove
}

/*
 * Deletes n characters at current row, col.
 */
void
ScrnDeleteChar(XtermWidget xw, unsigned n)
{
#define MemMove(data) \
    	for (j = col; j <= last - (int) n; ++j) \
	    data[j] = data[j + (int) n]

    TScreen *screen = TScreenOf(xw);
    int first = ScrnLeftMargin(xw);
    int last = ScrnRightMargin(xw) + 1;
    int row = screen->cur_row;
    int col = screen->cur_col;
    int j;
    LineData *ld;

    if (col < first || col > last) {
	TRACE(("ScrnDeleteChar - col %d outside [%d..%d]\n", col, first, last));
	return;
    } else if (last <= (col + (int) n)) {
	n = (unsigned) (last - col);
    }

    assert(screen->cur_col >= 0);
    assert(screen->cur_row >= 0);
    assert((int) n >= 0);
    assert(last >= (int) n);

    if_OPT_WIDE_CHARS(screen, {
	int kl;
	int kr;
	if (DamagedCells(screen, n, &kl, &kr,
			 screen->cur_row,
			 screen->cur_col))
	    ClearCells(xw, 0, (unsigned) (kr - kl + 1), row, kl);
    });

    if ((ld = getLineData(screen, row)) != 0) {
	MemMove(ld->charData);
	MemMove(ld->attribs);

	if_OPT_ISO_COLORS(screen, {
	    MemMove(ld->color);
	});
	if_OPT_WIDE_CHARS(screen, {
	    size_t off;
	    for_each_combData(off, ld) {
		MemMove(ld->combData[off]);
	    }
	});
	LineClrWrapped(ld);
	if (screen->show_wrap_marks) {
	    ShowWrapMarks(xw, row, ld);
	}
    }
    ClearCells(xw, 0, n, row, (last - (int) n));

#undef MemMove
}

/*
 * This is useful for debugging both xterm and applications that may manipulate
 * its line-wrapping state.
 */
void
ShowWrapMarks(XtermWidget xw, int row, CLineData *ld)
{
    TScreen *screen = TScreenOf(xw);
    Boolean set = (Boolean) LineTstWrapped(ld);
    CgsEnum cgsId = set ? gcVTcursFilled : gcVTcursReverse;
    VTwin *currentWin = WhichVWin(screen);
    int y = row * FontHeight(screen) + screen->border;
    int x = LineCursorX(screen, ld, screen->max_col + 1);

    TRACE2(("ShowWrapMarks %d:%s\n", row, BtoS(set)));

    XFillRectangle(screen->display, VDrawable(screen),
		   getCgsGC(xw, currentWin, cgsId),
		   x, y,
		   (unsigned) screen->border,
		   (unsigned) FontHeight(screen));
}

#if OPT_WIDE_ATTRS
static unsigned
refreshFontGCs(XtermWidget xw, unsigned new_attrs, unsigned old_attrs)
{
    TScreen *screen = TScreenOf(xw);

    if ((new_attrs & ATR_ITALIC) && !(old_attrs & ATR_ITALIC)) {
	xtermLoadItalics(xw);
	xtermUpdateFontGCs(xw, screen->ifnts);
    } else if (!(new_attrs & ATR_ITALIC) && (old_attrs & ATR_ITALIC)) {
	xtermUpdateFontGCs(xw, screen->fnts);
    }
    return new_attrs;
}
#endif

/*
 * Repaints the area enclosed by the parameters.
 * Requires: (toprow, leftcol), (toprow + nrows, leftcol + ncols) are
 *	     coordinates of characters in screen;
 *	     nrows and ncols positive.
 *	     all dimensions are based on single-characters.
 */
void
ScrnRefresh(XtermWidget xw,
	    int toprow,
	    int leftcol,
	    int nrows,
	    int ncols,
	    Bool force)		/* ... leading/trailing spaces */
{
    TScreen *screen = TScreenOf(xw);
    CLineData *ld;
    int y = toprow * FontHeight(screen) + screen->border;
    int row;
    int maxrow = toprow + nrows - 1;
    int scrollamt = screen->scroll_amt;
    unsigned gc_changes = 0;
#ifdef __CYGWIN__
    static char first_time = 1;
#endif
    static int recurse = 0;
#if OPT_WIDE_ATTRS
    unsigned old_attrs = xw->flags;
#endif

    TRACE(("ScrnRefresh top %d (%d,%d) - (%d,%d)%s {{\n",
	   screen->topline, toprow, leftcol,
	   nrows, ncols,
	   force ? " force" : ""));

    ++recurse;

    if (screen->cursorp.col >= leftcol
	&& screen->cursorp.col <= (leftcol + ncols - 1)
	&& screen->cursorp.row >= ROW2INX(screen, toprow)
	&& screen->cursorp.row <= ROW2INX(screen, maxrow))
	screen->cursor_state = OFF;

    for (row = toprow; row <= maxrow; y += FontHeight(screen), row++) {
#if OPT_ISO_COLORS
	CellColor *fb = 0;
#define ColorOf(col) (CellColor) (fb ? fb[col] : 0)
#endif
#if OPT_WIDE_CHARS
	int wideness = 0;
#endif
#define BLANK_CEL(cell) (chars[cell] == ' ')
	IChar *chars;
	const IAttr *attrs;
	int col = leftcol;
	int maxcol = leftcol + ncols - 1;
	int hi_col = maxcol;
	int lastind;
	unsigned flags;
	unsigned test;
	CellColor fg_bg = 0;
	unsigned fg = 0, bg = 0;
	int x;
	GC gc;
	Bool hilite;

	(void) fg;
	(void) bg;
#if !OPT_ISO_COLORS
	fg_bg = 0;
#endif

	if (row < screen->top_marg || row > screen->bot_marg)
	    lastind = row;
	else
	    lastind = row - scrollamt;

	if (lastind < 0 || lastind > screen->max_row)
	    continue;

	TRACE2(("ScrnRefresh row=%d lastind=%d ->%d\n",
		row, lastind, ROW2INX(screen, lastind)));

	if ((ld = getLineData(screen, ROW2INX(screen, lastind))) == 0
	    || ld->charData == 0
	    || ld->attribs == 0) {
	    break;
	}

	if (screen->show_wrap_marks) {
	    ShowWrapMarks(xw, lastind, ld);
	}

	if (maxcol >= (int) ld->lineSize) {
	    maxcol = ld->lineSize - 1;
	    hi_col = maxcol;
	}

	chars = ld->charData;
	attrs = ld->attribs;

	if_OPT_WIDE_CHARS(screen, {
	    /* This fixes an infinite recursion bug, that leads
	       to display anomalies. It seems to be related to
	       problems with the selection. */
	    if (recurse < 3) {
		/* adjust to redraw all of a widechar if we just wanted
		   to draw the right hand half */
		if (leftcol > 0 &&
		    chars[leftcol] == HIDDEN_CHAR &&
		    isWide((int) chars[leftcol - 1])) {
		    leftcol--;
		    ncols++;
		    col = leftcol;
		}
	    } else {
		xtermWarning("Unexpected recursion drawing hidden characters.\n");
	    }
	});

	if (row < screen->startH.row || row > screen->endH.row ||
	    (row == screen->startH.row && maxcol < screen->startH.col) ||
	    (row == screen->endH.row && col >= screen->endH.col)) {
#if OPT_DEC_CHRSET
	    /*
	     * Temporarily change dimensions to double-sized characters so
	     * we can reuse the recursion on this function.
	     */
	    if (CSET_DOUBLE(GetLineDblCS(ld))) {
		col /= 2;
		maxcol /= 2;
	    }
#endif
	    /*
	     * If row does not intersect selection; don't hilite blanks.
	     */
	    if (!force) {
		while (col <= maxcol && (attrs[col] & ~BOLD) == 0 &&
		       BLANK_CEL(col))
		    col++;

		while (col <= maxcol && (attrs[maxcol] & ~BOLD) == 0 &&
		       BLANK_CEL(maxcol))
		    maxcol--;
	    }
#if OPT_DEC_CHRSET
	    if (CSET_DOUBLE(GetLineDblCS(ld))) {
		col *= 2;
		maxcol *= 2;
	    }
#endif
	    hilite = False;
	} else {
	    /* row intersects selection; split into pieces of single type */
	    if (row == screen->startH.row && col < screen->startH.col) {
		ScrnRefresh(xw, row, col, 1, screen->startH.col - col,
			    force);
		col = screen->startH.col;
	    }
	    if (row == screen->endH.row && maxcol >= screen->endH.col) {
		ScrnRefresh(xw, row, screen->endH.col, 1,
			    maxcol - screen->endH.col + 1, force);
		maxcol = screen->endH.col - 1;
	    }

	    /*
	     * If we're highlighting because the user is doing cut/paste,
	     * trim the trailing blanks from the highlighted region so we're
	     * showing the actual extent of the text that'll be cut.  If
	     * we're selecting a blank line, we'll highlight one column
	     * anyway.
	     *
	     * We don't do this if the mouse-hilite mode is set because that
	     * would be too confusing.
	     *
	     * The default if the highlightSelection resource isn't set will
	     * highlight the whole width of the terminal, which is easy to
	     * see, but harder to use (because trailing blanks aren't as
	     * apparent).
	     */
	    if (screen->highlight_selection
		&& screen->send_mouse_pos != VT200_HIGHLIGHT_MOUSE) {
		hi_col = screen->max_col;
		while (hi_col > 0 && !(attrs[hi_col] & CHARDRAWN))
		    hi_col--;
	    }

	    /* remaining piece should be hilited */
	    hilite = True;
	}

	if (col > maxcol)
	    continue;

	/*
	 * Go back to double-sized character dimensions if the line has
	 * double-width characters.  Note that 'hi_col' is already in the
	 * right units.
	 */
	if_OPT_DEC_CHRSET({
	    if (CSET_DOUBLE(GetLineDblCS(ld))) {
		col /= 2;
		maxcol /= 2;
	    }
	});

	flags = attrs[col];

	if_OPT_WIDE_CHARS(screen, {
	    wideness = isWide((int) chars[col]);
	});

	if_OPT_ISO_COLORS(screen, {
	    fb = ld->color;
	    fg_bg = ColorOf(col);
	    fg = extract_fg(xw, fg_bg, flags);
	    bg = extract_bg(xw, fg_bg, flags);
	});

#if OPT_WIDE_ATTRS
	old_attrs = refreshFontGCs(xw, flags, old_attrs);
#endif
	gc = updatedXtermGC(xw, flags, fg_bg, hilite);
	gc_changes |= (flags & (FG_COLOR | BG_COLOR));

	x = LineCursorX(screen, ld, col);
	lastind = col;

	for (; col <= maxcol; col++) {
	    if ((attrs[col] != flags)
		|| (hilite && (col > hi_col))
#if OPT_ISO_COLORS
		|| ((flags & FG_COLOR)
		    && (extract_fg(xw, ColorOf(col), attrs[col]) != fg))
		|| ((flags & BG_COLOR)
		    && (extract_bg(xw, ColorOf(col), attrs[col]) != bg))
#endif
#if OPT_WIDE_CHARS
		|| (isWide((int) chars[col]) != wideness
		    && chars[col] != HIDDEN_CHAR)
#endif
		) {
		assert(col >= lastind);
		TRACE(("ScrnRefresh looping drawXtermText %d..%d:%s\n",
		       lastind, col,
		       visibleIChars((&chars[lastind]),
				     (unsigned) (col - lastind))));

		test = flags;
		checkVeryBoldColors(test, fg);

		x = drawXtermText(xw,
				  test & DRAWX_MASK,
				  0,
				  gc, x, y,
				  GetLineDblCS(ld),
				  &chars[lastind],
				  (unsigned) (col - lastind), 0);

		if_OPT_WIDE_CHARS(screen, {
		    int i;
		    size_t off;

		    for_each_combData(off, ld) {
			IChar *com_off = ld->combData[off];

			for (i = lastind; i < col; i++) {
			    int my_x = LineCursorX(screen, ld, i);
			    IChar base = chars[i];

			    if (isWide((int) base))
				my_x = LineCursorX(screen, ld, i - 1);

			    if (com_off[i] != 0)
				drawXtermText(xw,
					      (test & DRAWX_MASK),
					      NOBACKGROUND,
					      gc, my_x, y,
					      GetLineDblCS(ld),
					      com_off + i,
					      1, isWide((int) base));
			}
		    }
		});

		resetXtermGC(xw, flags, hilite);

		lastind = col;

		if (hilite && (col > hi_col))
		    hilite = False;

		flags = attrs[col];
		if_OPT_ISO_COLORS(screen, {
		    fg_bg = ColorOf(col);
		    fg = extract_fg(xw, fg_bg, flags);
		    bg = extract_bg(xw, fg_bg, flags);
		});
		if_OPT_WIDE_CHARS(screen, {
		    wideness = isWide((int) chars[col]);
		});

#if OPT_WIDE_ATTRS
		old_attrs = refreshFontGCs(xw, flags, old_attrs);
#endif
		gc = updatedXtermGC(xw, flags, fg_bg, hilite);
		gc_changes |= (flags & (FG_COLOR | BG_COLOR));
	    }

	    if (chars[col] == 0) {
		chars[col] = ' ';
	    }
	}

	assert(col >= lastind);
	TRACE(("ScrnRefresh calling drawXtermText %d..%d:%s\n",
	       lastind, col,
	       visibleIChars(&chars[lastind], (unsigned) (col - lastind))));

	test = flags;
	checkVeryBoldColors(test, fg);

	drawXtermText(xw,
		      test & DRAWX_MASK,
		      0,
		      gc, x, y,
		      GetLineDblCS(ld),
		      &chars[lastind],
		      (unsigned) (col - lastind), 0);

	if_OPT_WIDE_CHARS(screen, {
	    int i;
	    size_t off;

	    for_each_combData(off, ld) {
		IChar *com_off = ld->combData[off];

		for (i = lastind; i < col; i++) {
		    int my_x = LineCursorX(screen, ld, i);
		    int base = (int) chars[i];

		    if (isWide(base))
			my_x = LineCursorX(screen, ld, i - 1);

		    if (com_off[i] != 0)
			drawXtermText(xw,
				      (test & DRAWX_MASK),
				      NOBACKGROUND,
				      gc, my_x, y,
				      GetLineDblCS(ld),
				      com_off + i,
				      1, isWide(base));
		}
	    }
	});

	resetXtermGC(xw, flags, hilite);
    }

    refresh_displayed_graphics(xw, leftcol, toprow, ncols, nrows);

    /*
     * If we're in color mode, reset the various GC's to the current
     * screen foreground and background so that other functions (e.g.,
     * ClearRight) will get the correct colors.
     */
#if OPT_WIDE_ATTRS
    (void) refreshFontGCs(xw, xw->flags, old_attrs);
#endif
    if_OPT_ISO_COLORS(screen, {
	if (gc_changes & FG_COLOR)
	    SGR_Foreground(xw, xw->cur_foreground);
	if (gc_changes & BG_COLOR)
	    SGR_Background(xw, xw->cur_background);
    });

#if defined(__CYGWIN__) && defined(TIOCSWINSZ)
    if (first_time == 1) {
	TTYSIZE_STRUCT ts;

	first_time = 0;
	TTYSIZE_ROWS(ts) = nrows;
	TTYSIZE_COLS(ts) = ncols;
	ts.ws_xpixel = xw->core.width;
	ts.ws_ypixel = xw->core.height;
	SET_TTYSIZE(screen->respond, ts);
    }
#endif
    recurse--;

    TRACE(("...}} ScrnRefresh\n"));
    return;
}

/*
 * Call this wrapper to ScrnRefresh() when the data has changed.  If the
 * refresh region overlaps the selection, we will release the primary selection.
 */
void
ScrnUpdate(XtermWidget xw,
	   int toprow,
	   int leftcol,
	   int nrows,
	   int ncols,
	   Bool force)		/* ... leading/trailing spaces */
{
    TScreen *screen = TScreenOf(xw);

    if (ScrnHaveSelection(screen)
	&& (toprow <= screen->endH.row)
	&& (toprow + nrows - 1 >= screen->startH.row)) {
	ScrnDisownSelection(xw);
    }
    ScrnRefresh(xw, toprow, leftcol, nrows, ncols, force);
}

/*
 * Sets the rows first though last of the buffer of screen to spaces.
 * Requires first <= last; first, last are rows of screen->buf.
 */
void
ClearBufRows(XtermWidget xw,
	     int first,
	     int last)
{
    TScreen *screen = TScreenOf(xw);
    unsigned len = (unsigned) MaxCols(screen);
    int row;

    TRACE(("ClearBufRows %d..%d\n", first, last));
    for (row = first; row <= last; row++) {
	LineData *ld = getLineData(screen, row);
	if (ld != 0) {
	    if_OPT_DEC_CHRSET({
		/* clearing the whole row resets the doublesize characters */
		SetLineDblCS(ld, CSET_SWL);
	    });
	    LineClrWrapped(ld);
	    if (screen->show_wrap_marks) {
		ShowWrapMarks(xw, row, ld);
	    }
	    ClearCells(xw, 0, len, row, 0);
	}
    }
}

/*
  Resizes screen:
  1. If new window would have fractional characters, sets window size so as to
  discard fractional characters and returns -1.
  Minimum screen size is 1 X 1.
  Note that this causes another ExposeWindow event.
  2. Enlarges screen->buf if necessary.  New space is appended to the bottom
  and to the right
  3. Reduces  screen->buf if necessary.  Old space is removed from the bottom
  and from the right
  4. Cursor is positioned as closely to its former position as possible
  5. Sets screen->max_row and screen->max_col to reflect new size
  6. Maintains the inner border (and clears the border on the screen).
  7. Clears origin mode and sets scrolling region to be entire screen.
  8. Returns 0
  */
int
ScreenResize(XtermWidget xw,
	     int width,
	     int height,
	     unsigned *flags)
{
    TScreen *screen = TScreenOf(xw);
    int code, rows, cols;
    const int border = 2 * screen->border;
    int move_down_by = 0;
#ifdef TTYSIZE_STRUCT
    TTYSIZE_STRUCT ts;
#endif

    TRACE(("ScreenResize %dx%d border %d font %dx%d\n",
	   height, width, border,
	   FontHeight(screen), FontWidth(screen)));

    assert(width > 0);
    assert(height > 0);

    if (screen->is_running) {
	/* clear the right and bottom internal border because of NorthWest
	   gravity might have left junk on the right and bottom edges */
	if (width >= (int) FullWidth(screen)) {
#if OPT_DOUBLE_BUFFER
	    XFillRectangle(screen->display, VDrawable(screen),
			   ReverseGC(xw, screen),
			   FullWidth(screen), 0,
			   width - FullWidth(screen), height);
#else
	    XClearArea(screen->display, VDrawable(screen),
		       FullWidth(screen), 0,	/* right edge */
		       0, (unsigned) height,	/* from top to bottom */
		       False);
#endif
	}
	if (height >= (int) FullHeight(screen)) {
#if OPT_DOUBLE_BUFFER
	    XFillRectangle(screen->display, VDrawable(screen),
			   ReverseGC(xw, screen),
			   0, FullHeight(screen),
			   width, height - FullHeight(screen));
#else
	    XClearArea(screen->display, VDrawable(screen),
		       0, FullHeight(screen),	/* bottom */
		       (unsigned) width, 0,	/* all across the bottom */
		       False);
#endif
	}
    }

    TRACE(("...computing rows/cols: %.2f %.2f\n",
	   (double) (height - border) / FontHeight(screen),
	   (double) (width - border - ScrollbarWidth(screen)) / FontWidth(screen)));

    rows = (height - border) / FontHeight(screen);
    cols = (width - border - ScrollbarWidth(screen)) / FontWidth(screen);
    if (rows < 1)
	rows = 1;
    if (cols < 1)
	cols = 1;

    /* update buffers if the screen has changed size */
    if (MaxRows(screen) != rows || MaxCols(screen) != cols) {
#if !OPT_SAVE_LINES
	int whichBuf = 0;
#endif
	int delta_rows = rows - MaxRows(screen);
#if OPT_TRACE
	int delta_cols = cols - MaxCols(screen);
#endif

	TRACE(("...ScreenResize chars %dx%d delta %dx%d\n",
	       rows, cols, delta_rows, delta_cols));

	if (screen->is_running) {
#if !OPT_FIFO_LINES
	    int savelines = (screen->scrollWidget
			     ? screen->savelines
			     : 0);
#endif
	    if (screen->cursor_state)
		HideCursor();
#if OPT_SAVE_LINES
	    /*
	     * The non-visible buffer is simple, since we will not copy data
	     * to/from the saved-lines.  Do that first.
	     */
	    if (screen->editBuf_index[!screen->whichBuf]) {
		(void) Reallocate(xw,
				  &screen->editBuf_index[!screen->whichBuf],
				  &screen->editBuf_data[!screen->whichBuf],
				  (unsigned) rows,
				  (unsigned) cols,
				  (unsigned) MaxRows(screen));
	    }

	    /*
	     * The save-lines buffer may change width, but will not change its
	     * height.  Deal with the cases where we copy data to/from the
	     * saved-lines buffer.
	     */
	    if (GravityIsSouthWest(xw)
		&& delta_rows
		&& screen->saveBuf_index != 0) {

		if (delta_rows < 0) {
		    unsigned move_up = (unsigned) (-delta_rows);
		    ScrnBuf dst = screen->saveBuf_index;

#if OPT_FIFO_LINES
		    int amount = ((MaxRows(screen) - (int) move_up - 1)
				  - screen->cur_row);

		    if (amount < 0) {
			/* move line-data from visible-buffer to save-buffer */
			saveEditBufLines(screen, dst, (unsigned) -amount);
			move_down_by = amount;
		    } else {
			move_down_by = 0;
		    }
#else /* !OPT_FIFO_LINES */
		    int amount = screen->savelines - (int) move_up;

		    TRACE_SCRNBUF("before save", screen, dst, screen->savelines);

		    /* shift lines in save-buffer to make room */
		    TRACE(("...%smoving pointers in saveBuf (compare %d %d)\n",
			   (amount > 0
			    ? ""
			    : "SKIP "),
			   screen->savelines,
			   move_up));
		    if (amount > 0) {
			SaveLineData(dst, 0, move_up);

			MoveLineData(dst,
				     0,
				     move_up,
				     (unsigned) amount);

			TRACE(("...reuse %d lines storage in saveBuf\n", move_up));
			RestoreLineData(dst,
					(unsigned) amount,
					move_up);
			TRACE_SCRNBUF("restoresave", screen, dst, screen->savelines);
		    }

		    /* copy line-data from visible-buffer to save-buffer */
		    saveEditBufLines(screen, dst, move_up);

		    /* after data is copied, reallocate saved-lines */
		    (void) Reallocate(xw,
				      &screen->saveBuf_index,
				      &screen->saveBuf_data,
				      (unsigned) savelines,
				      (unsigned) cols,
				      (unsigned) savelines);
		    TRACE_SCRNBUF("reallocSAVE",
				  screen,
				  screen->saveBuf_index,
				  savelines);
#endif /* OPT_FIFO_LINES */

		    /* decrease size of visible-buffer */
		    (void) Reallocate(xw,
				      &screen->editBuf_index[screen->whichBuf],
				      &screen->editBuf_data[screen->whichBuf],
				      (unsigned) rows,
				      (unsigned) cols,
				      (unsigned) MaxRows(screen));
		    TRACE_SCRNBUF("reallocEDIT",
				  screen,
				  screen->editBuf_index[screen->whichBuf],
				  rows);
		} else {
		    unsigned move_down = (unsigned) delta_rows;
#if OPT_FIFO_LINES
		    long unsave_fifo;
#else
		    ScrnBuf src = screen->saveBuf_index;
#endif
		    ScrnBuf dst;
		    int amount;

		    if ((int) move_down > screen->savedlines) {
			move_down = (unsigned) screen->savedlines;
		    }
		    move_down_by = (int) move_down;
		    amount = rows - (int) move_down;

		    /* increase size of visible-buffer */
		    (void) Reallocate(xw,
				      &screen->editBuf_index[screen->whichBuf],
				      &screen->editBuf_data[screen->whichBuf],
				      (unsigned) rows,
				      (unsigned) cols,
				      (unsigned) MaxRows(screen));

		    dst = screen->editBuf_index[screen->whichBuf];
		    TRACE_SCRNBUF("reallocEDIT", screen, dst, rows);

		    TRACE(("...%smoving pointers in editBuf (compare %d %d)\n",
			   (amount > 0
			    ? ""
			    : "SKIP "),
			   rows,
			   move_down));
		    if (amount > 0) {
			/* shift lines in visible-buffer to make room */
			SaveLineData(dst, (unsigned) amount, (size_t) move_down);

			MoveLineData(dst,
				     move_down,
				     0,
				     (unsigned) amount);

			TRACE(("...reuse %d lines storage in editBuf\n", move_down));
			RestoreLineData(dst,
					0,
					move_down);

			TRACE_SCRNBUF("shifted", screen, dst, rows);
		    }

		    /* copy line-data from save-buffer to visible-buffer */
		    unsaveEditBufLines(screen, dst, move_down);
		    TRACE_SCRNBUF("copied", screen, dst, rows);

#if OPT_FIFO_LINES
		    unsave_fifo = (long) move_down;
		    if (screen->saved_fifo < (int) unsave_fifo)
			unsave_fifo = screen->saved_fifo;

		    /* free up storage in fifo from the copied lines */
		    while (unsave_fifo-- > 0) {
			deleteScrollback(screen);
		    }
#else
		    amount = (screen->savelines - (int) move_down);
		    TRACE(("...%smoving pointers in saveBuf (compare %d %d)\n",
			   (amount > 0
			    ? ""
			    : "SKIP "),
			   rows,
			   move_down));
		    if (amount > 0) {
			/* shift lines in save-buffer to account for copy */
			src = screen->saveBuf_index;
			SaveLineData(src, amount, move_down);

			MoveLineData(src,
				     move_down,
				     0,
				     (unsigned) amount);

			TRACE(("...reuse %d lines storage in saveBuf\n", move_down));
			RestoreLineData(src,
					0,
					move_down);
		    }
#endif

		    /* recover storage in save-buffer */
		}
	    } else {
#if !OPT_FIFO_LINES
		(void) Reallocate(xw,
				  &screen->saveBuf_index,
				  &screen->saveBuf_data,
				  (unsigned) savelines,
				  (unsigned) cols,
				  (unsigned) savelines);
#endif
		(void) Reallocate(xw,
				  &screen->editBuf_index[screen->whichBuf],
				  &screen->editBuf_data[screen->whichBuf],
				  (unsigned) rows,
				  (unsigned) cols,
				  (unsigned) MaxRows(screen));
	    }
#else /* !OPT_SAVE_LINES */
	    if (screen->whichBuf
		&& GravityIsSouthWest(xw)) {
		/* swap buffer pointers back to make this work */
		whichBuf = screen->whichBuf;
		SwitchBufPtrs(screen, 0);
	    } else {
		whichBuf = 0;
	    }
	    if (screen->editBuf_index[1])
		(void) Reallocate(xw,
				  &screen->editBuf_index[1],
				  &screen->editBuf_data[1],
				  (unsigned) rows,
				  (unsigned) cols,
				  (unsigned) MaxRows(screen));
	    move_down_by = Reallocate(xw,
				      &screen->saveBuf_index,
				      &screen->saveBuf_data,
				      (unsigned) (rows + savelines),
				      (unsigned) cols,
				      (unsigned) (MaxRows(screen) + savelines));
#endif /* OPT_SAVE_LINES */
	    screen->visbuf = VisBuf(screen);
	}

	AdjustSavedCursor(xw, move_down_by);
	set_max_row(screen, screen->max_row + delta_rows);
	set_max_col(screen, cols - 1);

	if (screen->is_running) {
	    if (GravityIsSouthWest(xw)) {
		screen->savedlines -= move_down_by;
		if (screen->savedlines < 0)
		    screen->savedlines = 0;
		if (screen->savedlines > screen->savelines)
		    screen->savedlines = screen->savelines;
		if (screen->topline < -screen->savedlines)
		    screen->topline = -screen->savedlines;
		set_cur_row(screen, screen->cur_row + move_down_by);
		screen->cursorp.row += move_down_by;
		ScrollSelection(screen, move_down_by, True);

#if !OPT_SAVE_LINES
		if (whichBuf)
		    SwitchBufPtrs(screen, whichBuf);	/* put the pointers back */
#endif
	    }
	}

	/* adjust scrolling region */
	set_tb_margins(screen, 0, screen->max_row);
	set_lr_margins(screen, 0, screen->max_col);
	UIntClr(*flags, ORIGIN);

	if (screen->cur_row > screen->max_row)
	    set_cur_row(screen, screen->max_row);
	if (screen->cur_col > screen->max_col)
	    set_cur_col(screen, screen->max_col);

	screen->fullVwin.height = height - border;
	screen->fullVwin.width = width - border - screen->fullVwin.sb_info.width;

	scroll_displayed_graphics(xw, -move_down_by);
    } else if (FullHeight(screen) == height && FullWidth(screen) == width)
	return (0);		/* nothing has changed at all */

    screen->fullVwin.fullheight = (Dimension) height;
    screen->fullVwin.fullwidth = (Dimension) width;

    ResizeScrollBar(xw);
    ResizeSelection(screen, rows, cols);

#ifndef NO_ACTIVE_ICON
    if (screen->iconVwin.window) {
	XWindowChanges changes;
	screen->iconVwin.width =
	    MaxCols(screen) * screen->iconVwin.f_width;

	screen->iconVwin.height =
	    MaxRows(screen) * screen->iconVwin.f_height;

	changes.width = screen->iconVwin.fullwidth =
	    (Dimension) ((unsigned) screen->iconVwin.width
			 + 2 * xw->misc.icon_border_width);

	changes.height = screen->iconVwin.fullheight =
	    (Dimension) ((unsigned) screen->iconVwin.height
			 + 2 * xw->misc.icon_border_width);

	changes.border_width = (int) xw->misc.icon_border_width;

	TRACE(("resizing icon window %dx%d\n", changes.height, changes.width));
	XConfigureWindow(XtDisplay(xw), screen->iconVwin.window,
			 CWWidth | CWHeight | CWBorderWidth, &changes);
    }
#endif /* NO_ACTIVE_ICON */

#ifdef TTYSIZE_STRUCT
    /* Set tty's idea of window size */
    TTYSIZE_ROWS(ts) = (ttySize_t) rows;
    TTYSIZE_COLS(ts) = (ttySize_t) cols;
#ifdef USE_STRUCT_WINSIZE
    ts.ws_xpixel = (ttySize_t) width;
    ts.ws_ypixel = (ttySize_t) height;
#endif
    code = SET_TTYSIZE(screen->respond, ts);
    TRACE(("return %d from SET_TTYSIZE %dx%d\n", code, rows, cols));
    (void) code;

#if defined(SIGWINCH) && defined(TIOCGPGRP)
    if (screen->pid > 1) {
	int pgrp;

	TRACE(("getting process-group\n"));
	if (ioctl(screen->respond, TIOCGPGRP, &pgrp) != -1) {
	    TRACE(("sending SIGWINCH to process group %d\n", pgrp));
	    kill_process_group(pgrp, SIGWINCH);
	}
    }
#endif /* SIGWINCH */

#else
    TRACE(("ScreenResize cannot do anything to pty\n"));
#endif /* TTYSIZE_STRUCT */
    return (0);
}

/*
 * Return true if any character cell starting at [row,col], for len-cells is
 * nonnull.
 */
Bool
non_blank_line(TScreen *screen,
	       int row,
	       int col,
	       int len)
{
    int i;
    Bool found = False;
    LineData *ld = getLineData(screen, row);

    if (ld != 0) {
	for (i = col; i < len; i++) {
	    if (ld->charData[i]) {
		found = True;
		break;
	    }
	}
    }
    return found;
}

/*
 * Limit/map rectangle parameters.
 */
#define minRectRow(screen) (getMinRow(screen) + 1)
#define minRectCol(screen) (getMinCol(screen) + 1)
#define maxRectRow(screen) (getMaxRow(screen) + 1)
#define maxRectCol(screen) (getMaxCol(screen) + 1)

static int
limitedParseRow(XtermWidget xw, int row)
{
    TScreen *screen = TScreenOf(xw);
    int min_row = minRectRow(screen);
    int max_row = maxRectRow(screen);

    if (xw->flags & ORIGIN)
	row += screen->top_marg;

    if (row < min_row)
	row = min_row;
    else if (row > max_row)
	row = max_row;

    return row;
}

static int
limitedParseCol(XtermWidget xw, int col)
{
    TScreen *screen = TScreenOf(xw);
    int min_col = minRectCol(screen);
    int max_col = maxRectCol(screen);

    if (xw->flags & ORIGIN)
	col += screen->lft_marg;

    if (col < min_col)
	col = min_col;
    else if (col > max_col)
	col = max_col;

    return col;
}

#define LimitedParse(num, func, dft) \
	func(xw, (nparams > num) ? params[num] : dft)

/*
 * Copy the rectangle boundaries into a struct, providing default values as
 * needed.
 */
void
xtermParseRect(XtermWidget xw, int nparams, int *params, XTermRect *target)
{
    TScreen *screen = TScreenOf(xw);

    memset(target, 0, sizeof(*target));
    target->top = LimitedParse(0, limitedParseRow, minRectRow(screen));
    target->left = LimitedParse(1, limitedParseCol, minRectCol(screen));
    target->bottom = LimitedParse(2, limitedParseRow, maxRectRow(screen));
    target->right = LimitedParse(3, limitedParseCol, maxRectCol(screen));
    TRACE(("parsed rectangle %d,%d %d,%d\n",
	   target->top,
	   target->left,
	   target->bottom,
	   target->right));
}

static Bool
validRect(XtermWidget xw, XTermRect *target)
{
    TScreen *screen = TScreenOf(xw);

    TRACE(("comparing against screensize %dx%d\n",
	   maxRectRow(screen),
	   maxRectCol(screen)));
    return (target != 0
	    && target->top >= minRectRow(screen)
	    && target->left >= minRectCol(screen)
	    && target->top <= target->bottom
	    && target->left <= target->right
	    && target->top <= maxRectRow(screen)
	    && target->right <= maxRectCol(screen));
}

/*
 * Fills a rectangle with the given 8-bit character and video-attributes.
 * Colors and double-size attribute are unmodified.
 */
void
ScrnFillRectangle(XtermWidget xw,
		  XTermRect *target,
		  int value,
		  unsigned flags,
		  Bool keepColors)
{
    TScreen *screen = TScreenOf(xw);

    TRACE(("filling rectangle with '%c' flags %#x\n", value, flags));
    if (validRect(xw, target)) {
	LineData *ld;
	unsigned left = (unsigned) (target->left - 1);
	unsigned size = (unsigned) (target->right - (int) left);
	unsigned attrs = flags;
	int row, col;

	(void) size;

	attrs &= ATTRIBUTES;
	attrs |= CHARDRAWN;
	for (row = target->bottom - 1; row >= (target->top - 1); row--) {
	    ld = getLineData(screen, row);

	    TRACE(("filling %d [%d..%d]\n", row, left, left + size));

	    /*
	     * Fill attributes, preserving colors.
	     */
	    for (col = (int) left; col < target->right; ++col) {
		unsigned temp = ld->attribs[col];

		if (!keepColors) {
		    UIntClr(temp, (FG_COLOR | BG_COLOR));
		}
		temp = attrs | (temp & (FG_COLOR | BG_COLOR)) | CHARDRAWN;
		ld->attribs[col] = (IAttr) temp;
#if OPT_ISO_COLORS
		if (attrs & (FG_COLOR | BG_COLOR)) {
		    if_OPT_ISO_COLORS(screen, {
			ld->color[col] = xtermColorPair(xw);
		    });
		}
#endif
	    }

	    for (col = (int) left; col < target->right; ++col)
		ld->charData[col] = (CharData) value;

	    if_OPT_WIDE_CHARS(screen, {
		size_t off;
		for_each_combData(off, ld) {
		    memset(ld->combData[off] + left, 0, size * sizeof(CharData));
		}
	    })
	}
	ScrnUpdate(xw,
		   target->top - 1,
		   target->left - 1,
		   (target->bottom - target->top) + 1,
		   (target->right - target->left) + 1,
		   False);
    }
}

#if OPT_DEC_RECTOPS
/*
 * Copies the source rectangle to the target location, including video
 * attributes.
 *
 * This implementation ignores page numbers.
 *
 * The reference manual does not indicate if it handles overlapping copy
 * properly - so we make a local copy of the source rectangle first, then apply
 * the target from that.
 */
void
ScrnCopyRectangle(XtermWidget xw, XTermRect *source, int nparam, int *params)
{
    TScreen *screen = TScreenOf(xw);

    TRACE(("copying rectangle\n"));

    if (nparam > 4)
	nparam = 4;

    if (validRect(xw, source)) {
	XTermRect target;
	xtermParseRect(xw,
		       ((nparam > 3) ? 2 : (nparam - 1)),
		       params,
		       &target);
	if (validRect(xw, &target)) {
	    Cardinal high = (Cardinal) (source->bottom - source->top) + 1;
	    Cardinal wide = (Cardinal) (source->right - source->left) + 1;
	    Cardinal size = (high * wide);
	    int row, col;
	    Cardinal j, k;
	    LineData *ld;

	    CellData *cells = newCellData(xw, size);

	    if (cells != 0) {

		TRACE(("OK - make copy %dx%d\n", high, wide));
		target.bottom = target.top + (int) (high - 1);
		target.right = target.left + (int) (wide - 1);

		for (row = source->top - 1; row < source->bottom; ++row) {
		    ld = getLineData(screen, row);
		    if (ld == 0)
			continue;
		    j = (Cardinal) (row - (source->top - 1));
		    for (col = source->left - 1; col < source->right; ++col) {
			k = (Cardinal) (col - (source->left - 1));
			saveCellData(screen, cells,
				     (j * wide) + k,
				     ld, col);
		    }
		}
		for (row = target.top - 1; row < target.bottom; ++row) {
		    ld = getLineData(screen, row);
		    if (ld == 0)
			continue;
		    j = (Cardinal) (row - (target.top - 1));
		    for (col = target.left - 1; col < target.right; ++col) {
			k = (Cardinal) (col - (target.left - 1));
			if (row >= getMinRow(screen)
			    && row <= getMaxRow(screen)
			    && col >= getMinCol(screen)
			    && col <= getMaxCol(screen)) {
			    if (j < high && k < wide) {
				restoreCellData(screen, cells,
						(j * wide) + k,
						ld, col);
			    } else {
				/* EMPTY */
				/* FIXME - clear the target cell? */
			    }
			    ld->attribs[col] |= CHARDRAWN;
			}
		    }
#if OPT_BLINK_TEXT
		    if (LineHasBlinking(screen, ld)) {
			LineSetBlinked(ld);
		    } else {
			LineClrBlinked(ld);
		    }
#endif
		}
		free(cells);

		ScrnUpdate(xw,
			   (target.top - 1),
			   (target.left - 1),
			   (target.bottom - target.top) + 1,
			   ((target.right - target.left) + 1),
			   False);
	    }
	}
    }
}

/*
 * Modifies the video-attributes only - so selection (not a video attribute) is
 * unaffected.  Colors and double-size flags are unaffected as well.
 *
 * FIXME: our representation for "invisible" does not work with this operation,
 * since the attribute byte is fully-allocated for other flags.  The logic
 * is shown for INVISIBLE because it's harmless, and useful in case the
 * CHARDRAWN or PROTECTED flags are reassigned.
 */
void
ScrnMarkRectangle(XtermWidget xw,
		  XTermRect *target,
		  Bool reverse,
		  int nparam,
		  int *params)
{
    TScreen *screen = TScreenOf(xw);
    Bool exact = (screen->cur_decsace == 2);

    TRACE(("%s %s\n",
	   reverse ? "reversing" : "marking",
	   (exact
	    ? "rectangle"
	    : "region")));

    if (validRect(xw, target)) {
	LineData *ld;
	int top = target->top - 1;
	int bottom = target->bottom - 1;
	int row, col;
	int n;

	for (row = top; row <= bottom; ++row) {
	    int left = ((exact || (row == top))
			? (target->left - 1)
			: getMinCol(screen));
	    int right = ((exact || (row == bottom))
			 ? (target->right - 1)
			 : getMaxCol(screen));

	    ld = getLineData(screen, row);

	    TRACE(("marking %d [%d..%d]\n", row, left, right));
	    for (col = left; col <= right; ++col) {
		unsigned flags = ld->attribs[col];

		for (n = 0; n < nparam; ++n) {
#if OPT_TRACE
		    if (row == top && col == left)
			TRACE(("attr param[%d] %d\n", n + 1, params[n]));
#endif
		    if (reverse) {
			switch (params[n]) {
			case 1:
			    flags ^= BOLD;
			    break;
			case 4:
			    flags ^= UNDERLINE;
			    break;
			case 5:
			    flags ^= BLINK;
			    break;
			case 7:
			    flags ^= INVERSE;
			    break;
			case 8:
			    flags ^= INVISIBLE;
			    break;
			}
		    } else {
			switch (params[n]) {
			case 0:
			    UIntClr(flags, SGR_MASK);
			    break;
			case 1:
			    flags |= BOLD;
			    break;
			case 4:
			    flags |= UNDERLINE;
			    break;
			case 5:
			    flags |= BLINK;
			    break;
			case 7:
			    flags |= INVERSE;
			    break;
			case 8:
			    flags |= INVISIBLE;
			    break;
			case 22:
			    UIntClr(flags, BOLD);
			    break;
			case 24:
			    UIntClr(flags, UNDERLINE);
			    break;
			case 25:
			    UIntClr(flags, BLINK);
			    break;
			case 27:
			    UIntClr(flags, INVERSE);
			    break;
			case 28:
			    UIntClr(flags, INVISIBLE);
			    break;
			}
		    }
		}
#if OPT_TRACE
		if (row == top && col == left)
		    TRACE(("first mask-change is %#x\n",
			   ld->attribs[col] ^ flags));
#endif
		ld->attribs[col] = (IAttr) flags;
	    }
	}
	ScrnRefresh(xw,
		    (target->top - 1),
		    (exact ? (target->left - 1) : getMinCol(screen)),
		    (target->bottom - target->top) + 1,
		    (exact
		     ? ((target->right - target->left) + 1)
		     : (getMaxCol(screen) - getMinCol(screen) + 1)),
		    False);
    }
}

/*
 * Resets characters to space, except where prohibited by DECSCA.  Video
 * attributes (including color) are untouched.
 */
void
ScrnWipeRectangle(XtermWidget xw,
		  XTermRect *target)
{
    TScreen *screen = TScreenOf(xw);

    TRACE(("wiping rectangle\n"));

    if (validRect(xw, target)) {
	LineData *ld;
	int top = target->top - 1;
	int bottom = target->bottom - 1;
	int row, col;

	for (row = top; row <= bottom; ++row) {
	    int left = (target->left - 1);
	    int right = (target->right - 1);

	    TRACE(("wiping %d [%d..%d]\n", row, left, right));

	    ld = getLineData(screen, row);
	    for (col = left; col <= right; ++col) {
		if (!((screen->protected_mode == DEC_PROTECT)
		      && (ld->attribs[col] & PROTECTED))) {
		    ld->attribs[col] |= CHARDRAWN;
		    ld->charData[col] = ' ';
		    if_OPT_WIDE_CHARS(screen, {
			size_t off;
			for_each_combData(off, ld) {
			    ld->combData[off][col] = '\0';
			}
		    })
		}
	    }
	}
	ScrnUpdate(xw,
		   (target->top - 1),
		   (target->left - 1),
		   (target->bottom - target->top) + 1,
		   ((target->right - target->left) + 1),
		   False);
    }
}

/*
 * Compute a checksum, ignoring the page number (since we have only one page).
 */
void
xtermCheckRect(XtermWidget xw,
	       int nparam,
	       int *params,
	       int *result)
{
    TScreen *screen = TScreenOf(xw);
    XTermRect target;
    LineData *ld;

    *result = 0;
    if (nparam > 2) {
	nparam -= 2;
	params += 2;
    }
    xtermParseRect(xw, nparam, params, &target);
    if (validRect(xw, &target)) {
	int top = target.top - 1;
	int bottom = target.bottom - 1;
	int row, col;

	for (row = top; row <= bottom; ++row) {
	    int left = (target.left - 1);
	    int right = (target.right - 1);

	    ld = getLineData(screen, row);
	    for (col = left; col <= right; ++col) {
		if (ld->attribs[col] & CHARDRAWN) {
		    *result += (int) ld->charData[col];
		    if_OPT_WIDE_CHARS(screen, {
			size_t off;
			for_each_combData(off, ld) {
			    *result += (int) ld->combData[off][col];
			}
		    })
		}
	    }
	}
    }
}
#endif /* OPT_DEC_RECTOPS */

#if OPT_MAXIMIZE

static _Xconst char *
ewmhProperty(int mode)
{
    _Xconst char *result;
    switch (mode) {
    default:
	result = 0;
	break;
    case 1:
	result = "_NET_WM_STATE_FULLSCREEN";
	break;
    case 2:
	result = "_NET_WM_STATE_MAXIMIZED_VERT";
	break;
    case 3:
	result = "_NET_WM_STATE_MAXIMIZED_HORZ";
	break;
    }
    return result;
}

static void
set_resize_increments(XtermWidget xw)
{
    TScreen *screen = TScreenOf(xw);
    int min_width = (2 * screen->border) + screen->fullVwin.sb_info.width;
    int min_height = (2 * screen->border);
    XSizeHints sizehints;

    memset(&sizehints, 0, sizeof(XSizeHints));
    sizehints.width_inc = FontWidth(screen);
    sizehints.height_inc = FontHeight(screen);
    sizehints.flags = PResizeInc;
    XSetWMNormalHints(screen->display, VShellWindow(xw), &sizehints);

    XtVaSetValues(SHELL_OF(xw),
		  XtNbaseWidth, min_width,
		  XtNbaseHeight, min_height,
		  XtNminWidth, min_width + FontWidth(screen),
		  XtNminHeight, min_height + FontHeight(screen),
		  XtNwidthInc, FontWidth(screen),
		  XtNheightInc, FontHeight(screen),
		  (XtPointer) 0);

    XFlush(XtDisplay(xw));
}

static void
unset_resize_increments(XtermWidget xw)
{
    TScreen *screen = TScreenOf(xw);
    XSizeHints sizehints;

    memset(&sizehints, 0, sizeof(XSizeHints));
    sizehints.width_inc = 1;
    sizehints.height_inc = 1;
    sizehints.flags = PResizeInc;
    XSetWMNormalHints(screen->display, VShellWindow(xw), &sizehints);

    XtVaSetValues(SHELL_OF(xw),
		  XtNwidthInc, 1,
		  XtNheightInc, 1,
		  (XtPointer) 0);

    XFlush(XtDisplay(xw));
}

static void
set_ewmh_hint(Display *dpy, Window window, int operation, _Xconst char *prop)
{
    XEvent e;
    Atom atom_fullscreen = XInternAtom(dpy, prop, False);
    Atom atom_state = XInternAtom(dpy, "_NET_WM_STATE", False);

    memset(&e, 0, sizeof(e));
    e.xclient.type = ClientMessage;
    e.xclient.message_type = atom_state;
    e.xclient.display = dpy;
    e.xclient.window = window;
    e.xclient.format = 32;
    e.xclient.data.l[0] = operation;
    e.xclient.data.l[1] = (long) atom_fullscreen;

    XSendEvent(dpy, DefaultRootWindow(dpy), False,
	       SubstructureRedirectMask, &e);
}

/*
 * Check if the given property is supported on the root window.
 *
 * The XGetWindowProperty function returns a list of Atom's which corresponds
 * to the output of xprop.  The actual list (ignore the manpage, which refers
 * to an array of 32-bit values) is constructed by _XRead32, which uses long
 * as a datatype.
 *
 * Alternatively, we could check _NET_WM_ALLOWED_ACTIONS on the application's
 * window.
 */
static Boolean
probe_netwm(Display *dpy, _Xconst char *propname)
{
    Atom atom_fullscreen = XInternAtom(dpy, propname, False);
    Atom atom_supported = XInternAtom(dpy, "_NET_SUPPORTED", False);
    Atom actual_type;
    int actual_format;
    long long_offset = 0;
    long long_length = 128;	/* number of items to ask for at a time */
    unsigned int i;
    unsigned long nitems, bytes_after;
    unsigned char *args;
    long *ldata;
    Boolean has_capability = False;
    Boolean rc;

    while (!has_capability) {
	rc = xtermGetWinProp(dpy,
			     DefaultRootWindow(dpy),
			     atom_supported,
			     long_offset,
			     long_length,
			     AnyPropertyType,	/* req_type */
			     &actual_type,	/* actual_type_return */
			     &actual_format,	/* actual_format_return */
			     &nitems,	/* nitems_return */
			     &bytes_after,	/* bytes_after_return */
			     &args	/* prop_return */
	    );
	if (!rc
	    || actual_type != XA_ATOM) {
	    break;
	}
	ldata = (long *) (void *) args;
	for (i = 0; i < nitems; i++) {
	    if ((Atom) ldata[i] == atom_fullscreen) {
		has_capability = True;
		break;
	    }
	}
	XFree(ldata);

	if (!has_capability) {
	    if (bytes_after != 0) {
		long remaining = (long) (bytes_after / sizeof(long));
		if (long_length > remaining)
		    long_length = remaining;
		long_offset += (long) nitems;
	    } else {
		break;
	    }
	}
    }

    TRACE(("probe_netwm(%s) ->%d\n", propname, has_capability));
    return has_capability;
}

/*
 * Alter fullscreen mode for the xterm widget, if the window manager supports
 * that feature.
 */
void
FullScreen(XtermWidget xw, int new_ewmh_mode)
{
    TScreen *screen = TScreenOf(xw);
    Display *dpy = screen->display;
    _Xconst char *oldprop = ewmhProperty(xw->work.ewmh[0].mode);
    _Xconst char *newprop = ewmhProperty(new_ewmh_mode);

    int which = 0;
    Window window;

#if OPT_TEK4014
    if (TEK4014_ACTIVE(xw)) {
	which = 1;
	window = TShellWindow;
    } else
#endif
	window = VShellWindow(xw);

    TRACE(("FullScreen %d:%s\n", new_ewmh_mode, BtoS(new_ewmh_mode)));

    if (new_ewmh_mode < 0 || new_ewmh_mode >= MAX_EWMH_MODE) {
	TRACE(("BUG: FullScreen %d\n", new_ewmh_mode));
	return;
    } else if (new_ewmh_mode == 0) {
	xw->work.ewmh[which].checked[new_ewmh_mode] = True;
	xw->work.ewmh[which].allowed[new_ewmh_mode] = True;
    } else if (resource.fullscreen == esNever) {
	xw->work.ewmh[which].checked[new_ewmh_mode] = True;
	xw->work.ewmh[which].allowed[new_ewmh_mode] = False;
    } else if (!xw->work.ewmh[which].checked[new_ewmh_mode]) {
	xw->work.ewmh[which].checked[new_ewmh_mode] = True;
	xw->work.ewmh[which].allowed[new_ewmh_mode] = probe_netwm(dpy, newprop);
    }

    if (xw->work.ewmh[which].allowed[new_ewmh_mode]) {
	if (new_ewmh_mode && !xw->work.ewmh[which].mode) {
	    unset_resize_increments(xw);
	    set_ewmh_hint(dpy, window, _NET_WM_STATE_ADD, newprop);
	} else if (xw->work.ewmh[which].mode && !new_ewmh_mode) {
	    set_resize_increments(xw);
	    set_ewmh_hint(dpy, window, _NET_WM_STATE_REMOVE, oldprop);
	} else {
	    set_ewmh_hint(dpy, window, _NET_WM_STATE_REMOVE, oldprop);
	    set_ewmh_hint(dpy, window, _NET_WM_STATE_ADD, newprop);
	}
	xw->work.ewmh[which].mode = new_ewmh_mode;
	update_fullscreen();
    } else {
	Bell(xw, XkbBI_MinorError, 100);
    }
}
#endif /* OPT_MAXIMIZE */
@


1.23
log
@Update to xterm 313. Tested by shadchin@@
@
text
@d1 1
a1 1
/* $XTermId: screen.c,v 1.505 2014/11/13 01:04:40 tom Exp $ */
d4 1
a4 1
 * Copyright 1999-2013,2014 by Thomas E. Dickey
d1122 3
a1125 1
    assert(last >= (int) n);
d1267 1
a1267 1
    assert(last >= (int) n);
d1329 1
a1329 1
    assert(last > (int) n);
d2498 2
d2510 2
@


1.22
log
@Update to xterm 311. ok shadchin@@
@
text
@d1 1
a1 1
/* $XTermId: screen.c,v 1.501 2014/07/30 08:06:23 tom Exp $ */
d405 1
a405 1
	LineData *src;
d414 2
a415 2
	LineData *src = (LineData *) scrnHeadAddr(screen,
						  screen->saveBuf_index, k);
d1030 1
d1366 1
a1366 1
ShowWrapMarks(XtermWidget xw, int row, LineData *ld)
d1403 1
a1403 1
 * 	     coordinates of characters in screen;
d1416 1
a1416 1
    LineData *ld;
d1453 1
a1453 1
	IAttr *attrs;
d1759 1
a1759 5
    refresh_displayed_graphics(screen,
			       leftcol,
			       toprow + screen->topline,
			       ncols,
			       nrows);
d1870 1
a1870 1
    int border = 2 * screen->border;
d2207 1
a2207 1
	scroll_displayed_graphics(-move_down_by);
@


1.21
log
@Update to xterm-309. Version 308 tested by several people including
naddy@@ who found a small regression, fixed in 309.
@
text
@d1 1
a1 1
/* $XTermId: screen.c,v 1.500 2014/06/19 21:09:11 tom Exp $ */
d1257 2
a1258 2
    } else if (last <= (col + (int) n)) {
	n = (unsigned) (last - col);
@


1.20
log
@Update to xterm 304. With help of shadchin@@

tested by ajacoutot@@ and shadchin@@
@
text
@d1 1
a1 1
/* $XTermId: screen.c,v 1.488 2014/05/03 19:32:51 tom Exp $ */
d65 1
a65 1
#if OPT_WIDE_CHARS
d196 1
a196 1
    unsigned skipNcolChar;
d204 1
a204 1
    skipNcolChar = (ncol * SizeofScrnPtr(attribs));
d218 1
a218 1
	SetupScrnPtr(ptr->attribs, data, Char);
d738 8
d764 1
a764 1
	memset(ld->attribs + col, flags, (size_t) len);
d834 1
a834 1
    Char *attrs;
d924 1
a924 1
    memset(attrs, (Char) flags, (size_t) real_width);
d998 1
a998 1
	    memset(work->attribs, (int) flags, (size_t) size);
d1008 1
a1008 1
	    memset(work->attribs, 0, (size_t) size);
d1383 16
d1425 3
d1434 2
d1452 1
a1452 1
	Char *attrs;
d1515 1
a1515 1
		xtermWarning("This should not happen. Why is it so?\n");
a1553 1
		recurse++;
a1558 1
		recurse++;
d1618 3
d1650 4
a1653 1
		x = drawXtermText(xw, test & DRAWX_MASK, gc, x, y,
d1674 2
a1675 2
					      (test & DRAWX_MASK)
					      | NOBACKGROUND,
d1701 3
d1721 4
a1724 1
	drawXtermText(xw, test & DRAWX_MASK, gc, x, y,
d1745 2
a1746 2
				      (test & DRAWX_MASK)
				      | NOBACKGROUND,
d1769 3
d2425 1
a2425 1
		ld->attribs[col] = (Char) temp;
d2660 1
a2660 1
		ld->attribs[col] = (Char) flags;
@


1.19
log
@Update to xterm-300. Tested  by ajacoutot@@ and shadchin@@.
@
text
@d1 1
a1 1
/* $XTermId: screen.c,v 1.487 2013/08/14 23:22:53 tom Exp $ */
d4 1
a4 1
 * Copyright 1999-2012,2013 by Thomas E. Dickey
a73 4
#ifndef _Xconst
#define _Xconst const		/* Solaris 7 workaround */
#endif /* _Xconst */

d2310 1
a2310 1
xtermParseRect(XtermWidget xw, int nparams, int *params, XTermRect * target)
d2327 1
a2327 1
validRect(XtermWidget xw, XTermRect * target)
d2349 1
a2349 1
		  XTermRect * target,
d2424 1
a2424 1
ScrnCopyRectangle(XtermWidget xw, XTermRect * source, int nparam, int *params)
d2517 1
a2517 1
		  XTermRect * target,
d2638 1
a2638 1
		  XTermRect * target)
@


1.18
log
@Update to xterm 296. Sixel graphics disabled for now.
@
text
@d1 1
a1 1
/* $XTermId: screen.c,v 1.485 2013/07/10 22:52:16 tom Exp $ */
d977 1
a977 1
    assert(n != 0);
d1121 1
a1121 1
    assert(n != 0);
d1166 1
a1166 1
    assert(n != 0);
d1259 1
a1259 1
    assert(n > 0);
d1321 1
a1321 1
    assert(n > 0);
@


1.17
log
@Update to xterm 293. Tested by naddy@@ ajacoutot@@
@
text
@d1 1
a1 1
/* $XTermId: screen.c,v 1.477 2013/04/23 09:50:23 Bertram.Felgenhauer Exp $ */
a60 1
#include <xcharmouse.h>
d78 2
d139 1
a139 1
traceScrnBuf(const char *tag, TScreen * screen, ScrnBuf sb, unsigned len)
d159 1
a159 1
scrnHeadSize(TScreen * screen, unsigned count)
d176 1
a176 1
scrnHeadAddr(TScreen * screen, ScrnBuf base, unsigned offset)
d190 1
a190 1
setupLineData(TScreen * screen, ScrnBuf base, Char * data, unsigned nrow, unsigned ncol)
d252 1
a252 1
extractScrnData(TScreen * screen,
d273 1
a273 1
allocScrnHead(TScreen * screen, unsigned nrow)
d292 1
a292 1
sizeofScrnRow(TScreen * screen, unsigned ncol)
d325 1
a325 1
allocScrnData(TScreen * screen, unsigned nrow, unsigned ncol)
d334 1
a334 1
	SysError(ERROR_SCALLOC2);
d355 1
a355 1
allocScrnBuf(XtermWidget xw, unsigned nrow, unsigned ncol, Char ** addr)
d376 1
a376 1
saveEditBufLines(TScreen * screen, ScrnBuf sb, unsigned n)
d400 1
a400 1
unsaveEditBufLines(TScreen * screen, ScrnBuf sb, unsigned n)
d433 2
a434 2
	   ScrnBuf * sbuf,
	   Char ** sbufaddr,
d527 2
a528 2
		     ScrnBuf * sbuf,
		     Char ** sbufaddr,
d712 1
a712 1
 * Clear cells, no side-effects.
d715 1
a715 1
CopyCells(TScreen * screen, LineData * src, LineData * dst, int col, int len)
d823 1
a823 1
	      IChar * str,
d839 1
a839 1
    (void) cur_fg_bg;
d941 9
d1020 11
d1088 1
a1088 1
ScrnPointers(TScreen * screen, size_t len)
d1361 1
a1361 1
ShowWrapMarks(XtermWidget xw, int row, LineData * ld)
d1723 6
d2172 1
d2242 1
a2242 1
non_blank_line(TScreen * screen,
d2799 1
a2799 1
set_ewmh_hint(Display * dpy, Window window, int operation, _Xconst char *prop)
d2830 1
a2830 1
probe_netwm(Display * dpy, _Xconst char *propname)
@


1.16
log
@Update to xterm 291. Tested by many.
@
text
@d1 1
a1 1
/* $XTermId: screen.c,v 1.475 2013/02/13 00:42:30 tom Exp $ */
d410 1
a410 1
	if ((screen->saved_fifo - extra) <= 0) {
d2037 1
a2037 2
			deleteScrollback(screen, -1);
			screen->saved_fifo--;
@


1.15
log
@Update to xterm 287. tested by mpi@@ and krw@@.
@
text
@d1 1
a1 1
/* $XTermId: screen.c,v 1.469 2012/10/25 23:12:20 tom Exp $ */
d4 1
a4 1
 * Copyright 1999-2011,2012 by Thomas E. Dickey
d75 4
d330 3
a332 2
    length = (nrow * sizeofScrnRow(screen, ncol));
    if ((result = (Char *) calloc(length, sizeof(Char))) == 0)
a449 4
    if (screen->widestLine < ncol)
	screen->widestLine = (Dimension) ncol;
    ncol = screen->widestLine;

a548 4
    if (screen->widestLine < ncol)
	screen->widestLine = (Dimension) ncol;
    ncol = screen->widestLine;

d1865 1
d1867 1
d2126 1
d2129 1
d2885 1
a2885 1
    if (new_ewmh_mode < 0 || new_ewmh_mode > MAX_EWMH_MODE) {
@


1.14
log
@Update to xterm 279. Tested by krw@@, mpi@@, shadchin@@.
@
text
@d1 1
a1 1
/* $XTermId: screen.c,v 1.452 2012/05/08 08:36:43 tom Exp $ */
d445 4
d548 4
d1354 1
a1354 1
    XFillRectangle(screen->display, VWindow(screen),
a1815 1
    Window tw = VWindow(screen);
d1828 7
a1834 1
	    XClearArea(screen->display, tw,
d1838 1
d1841 7
a1847 1
	    XClearArea(screen->display, tw,
d1851 1
d2406 3
d2703 21
d2771 1
a2771 1
netwm_fullscreen(XtermWidget xw, int operation)
a2772 1
    TScreen *screen = TScreenOf(xw);
d2774 1
a2774 3
    Display *dpy = screen->display;
    Window window = VShellWindow(xw);
    Atom atom_fullscreen = XInternAtom(dpy, "_NET_WM_STATE_FULLSCREEN", False);
d2791 2
a2792 1
 * Check if the "fullscreen" property is supported on the root window.
d2802 1
a2802 1
probe_netwm_fullscreen_capability(XtermWidget xw)
d2804 1
a2804 3
    TScreen *screen = TScreenOf(xw);
    Display *dpy = screen->display;
    Atom atom_fullscreen = XInternAtom(dpy, "_NET_WM_STATE_FULLSCREEN", False);
d2814 2
a2815 2
    Boolean netwm_fullscreen_capability = False;
    int rc;
d2817 12
a2828 13
    while (!netwm_fullscreen_capability) {
	rc = XGetWindowProperty(dpy,
				DefaultRootWindow(dpy),
				atom_supported,
				long_offset,
				long_length,
				False,	/* do not delete */
				AnyPropertyType,	/* req_type */
				&actual_type,	/* actual_type_return */
				&actual_format,		/* actual_format_return */
				&nitems,	/* nitems_return */
				&bytes_after,	/* bytes_after_return */
				&args	/* prop_return */
d2830 1
a2830 1
	if (rc != Success
d2837 1
a2837 1
		netwm_fullscreen_capability = True;
d2843 1
a2843 1
	if (!netwm_fullscreen_capability) {
d2855 2
a2856 1
    return netwm_fullscreen_capability;
d2860 2
a2861 2
 * Enable/disable fullscreen mode for the xterm widget, if the window manager
 * supports that feature.
d2864 1
a2864 1
FullScreen(XtermWidget xw, Bool enabled)
d2867 3
d2871 2
a2872 2
    static Boolean initialized = False;
    static Boolean netwm_fullscreen_capability = False;
d2874 9
a2882 1
    TRACE(("FullScreen %s\n", BtoS(enabled)));
d2884 12
a2895 6
    if (resource.fullscreen == esNever) {
	initialized = True;
	netwm_fullscreen_capability = False;
    } else if (!initialized) {
	initialized = True;
	netwm_fullscreen_capability = probe_netwm_fullscreen_capability(xw);
d2898 2
a2899 2
    if (netwm_fullscreen_capability) {
	if (enabled) {
d2901 4
a2904 1
	    netwm_fullscreen(xw, 1);
d2906 2
a2907 2
	    set_resize_increments(xw);
	    netwm_fullscreen(xw, 0);
d2909 1
a2909 1
	screen->fullscreen = (Boolean) enabled;
@


1.13
log
@Update to xterm 278. Tested by mpi@@, shadchin@@
@
text
@d1 1
a1 1
/* $XTermId: screen.c,v 1.440 2011/12/27 10:10:53 tom Exp $ */
d4 1
a4 1
 * Copyright 1999-2010,2011 by Thomas E. Dickey
d81 2
a82 2
#define getMinCol(screen) 0
#define getMaxCol(screen) ((screen)->max_col)
d709 31
d930 4
a933 4
    if_OPT_WIDE_CHARS(screen, {
	screen->last_written_col = screen->cur_col + (int) real_width - 1;
	screen->last_written_row = screen->cur_row;
    });
d1213 1
a1213 1
    	for (j = last - 1; j >= (col + (int) n); --j) \
d1217 2
a1218 1
    int last = MaxCols(screen);
d1224 4
a1227 3
    if (last <= (col + (int) n)) {
	if (last <= col)
	    return;
d1234 1
a1234 1
    assert(last > (int) n);
d1243 1
a1243 1
	kr = screen->max_col - (int) n + 1;
d1275 1
a1275 1
    	for (j = col; j < last - (int) n; ++j) \
d1279 2
a1280 1
    int last = MaxCols(screen);
d1286 4
a1289 3
    if (last <= (col + (int) n)) {
	if (last <= col)
	    return;
d2113 1
d2214 1
a2214 1
 * Rectangle parameters start from one.
d2222 1
a2222 1
limitedParseRow(XtermWidget xw, TScreen * screen, int row)
d2224 1
d2228 3
d2235 1
d2240 1
a2240 1
limitedParseCol(XtermWidget xw, TScreen * screen, int col)
d2242 1
d2246 3
a2248 1
    (void) xw;
d2253 1
d2258 1
a2258 1
	func(xw, screen, (nparams > num) ? params[num] : dft)
d2329 1
a2329 2
	     * Fill attributes, preserving "protected" flag, as well as
	     * colors if asked.
d2337 1
a2337 2
		temp = attrs | (temp & (FG_COLOR | BG_COLOR | PROTECTED));
		temp |= CHARDRAWN;
d2437 7
d2629 44
@


1.12
log
@Update to xterm 270. Tested by ajacoutot@@, shadchin@@, krw@@ and jasper@@
@
text
@d1 1
a1 1
/* $XTermId: screen.c,v 1.439 2011/04/20 09:10:21 tom Exp $ */
d1429 1
a1429 1
		fprintf(stderr, "This should not happen. Why is it so?\n");
@


1.11
log
@Update to xterm version 269.
Tested and ok ajacoutot@@, jasper@@, krw@@, shadchin@@
@
text
@d1 1
a1 1
/* $XTermId: screen.c,v 1.436 2011/02/20 00:48:23 tom Exp $ */
d195 2
a196 2
    unsigned skipNcolChar = (ncol * SizeofScrnPtr(attribs));
    unsigned skipNcolCharData = (ncol * SizeofScrnPtr(charData));
d198 1
a198 1
    unsigned skipNcolCellColor = (ncol * SizeofScrnPtr(color));
d201 4
a204 1
    AlignValue(skipNcolChar);
d206 1
a206 1
    AlignValue(skipNcolCellColor);
a207 1
    AlignValue(skipNcolCharData);
d323 1
a323 1
    size_t length = (nrow * sizeofScrnRow(screen, ncol));
d325 2
d2134 1
a2134 1
#if defined(SIGWINCH) && defined(USE_STRUCT_TTYSIZE)
@


1.10
log
@Update to xterm version 264, Tested at least by krw@@, jasper@@, ajacoutot@@.
@
text
@d1 1
a1 1
/* $XTermId: screen.c,v 1.426 2010/10/11 00:46:05 tom Exp $ */
d4 1
a4 1
 * Copyright 1999-2009,2010 by Thomas E. Dickey
d64 2
d68 2
a70 1
#endif
d125 1
a125 1
		dst = (type *) src; \
d129 2
a130 2
#define ScrnBufAddr(ptrs, offset)  (ScrnBuf)    ((char *) (ptrs) + (offset))
#define LineDataAddr(ptrs, offset) (LineData *) ((char *) (ptrs) + (offset))
d586 37
d654 3
a656 1
#if !OPT_FIFO_LINES
d1299 1
a1299 1
    Boolean set = LineTstWrapped(ld);
d2384 1
d2578 179
@


1.9
log
@Update to xterm 261. Tested by krw@@, jcs@@.
@
text
@d1 1
a1 1
/* $XTermId: screen.c,v 1.423 2010/06/14 00:00:58 tom Exp $ */
d1240 3
d1250 23
d1355 5
d1690 3
@


1.8
log
@Update to xterm 258. lightly tested by krw@@, thanks.
@
text
@d1 1
a1 1
/* $XTermId: screen.c,v 1.418 2010/04/28 23:49:28 tom Exp $ */
d424 1
a424 2
	   unsigned oldrow,
	   unsigned oldcol)
a430 1
    unsigned mincols;
d440 1
a440 1
    TRACE(("Reallocate %dx%d -> %dx%d\n", oldrow, oldcol, nrow, ncol));
a482 1
    mincols = (oldcol < ncol) ? oldcol : ncol;
a589 1
    int savelines = screen->scrollWidget ? screen->savelines : 0;
d598 3
d603 1
d672 1
a672 1
	UIntSet(flags, TERM_COLOR_FLAGS(xw));
a746 3
#if OPT_ISO_COLORS
    CellColor *fb = 0;
#endif
a773 4
    if_OPT_ISO_COLORS(screen, {
	fb = ld->color + screen->cur_col;
    });

d850 1
a850 1
	    fb[j] = (CellColor) cur_fg_bg;
d1143 1
a1143 1
    int j, nbytes;
a1150 1
    nbytes = (last - (col + (int) n));
d1203 1
a1203 1
    int j, nbytes;
a1210 1
    nbytes = (last - (col + (int) n));
d1287 1
a1287 1
#define ColorOf(col) fb[col]
d1318 3
d1327 1
a1327 1
	    continue;
a1335 2
	assert(chars != 0);
	assert(attrs != 0);
d1760 1
a1760 2
				  (unsigned) MaxRows(screen),
				  (unsigned) MaxCols(screen));
a1771 2
		move_down_by = delta_rows;

a1782 1
			move_up = (unsigned) -amount;
d1823 1
a1823 2
				      (unsigned) savelines,
				      (unsigned) MaxCols(screen));
d1836 1
a1836 2
				      (unsigned) MaxRows(screen),
				      (unsigned) MaxCols(screen));
d1863 1
a1863 2
				      (unsigned) MaxRows(screen),
				      (unsigned) MaxCols(screen));
d1939 1
a1939 2
				  (unsigned) savelines,
				  (unsigned) MaxCols(screen));
d1946 1
a1946 2
				  (unsigned) MaxRows(screen),
				  (unsigned) MaxCols(screen));
d1963 1
a1963 2
				  (unsigned) MaxRows(screen),
				  (unsigned) MaxCols(screen));
d1969 1
a1969 2
				      (unsigned) (MaxRows(screen) + savelines),
				      (unsigned) MaxCols(screen));
d2027 3
a2029 1
	    (Dimension) (screen->iconVwin.width + 2 * xw->misc.icon_border_width);
d2031 3
a2033 1
	    (Dimension) (screen->iconVwin.height + 2 * xw->misc.icon_border_width);
d2044 2
a2045 2
    TTYSIZE_ROWS(ts) = rows;
    TTYSIZE_COLS(ts) = cols;
d2047 2
a2048 2
    ts.ws_xpixel = width;
    ts.ws_ypixel = height;
@


1.7
log
@Update to xterm-255. Tested by stsp@@, oga@@.
@
text
@d1 1
a1 1
/* $XTermId: screen.c,v 1.410 2010/01/20 01:38:46 tom Exp $ */
d82 3
a84 3
	memmove(scrnHeadAddr(screen, base, dst), \
		scrnHeadAddr(screen, base, src), \
		scrnHeadSize(screen, len))
d90 1
a90 1
		scrnHeadSize(screen, len))
d95 1
a95 1
		scrnHeadSize(screen, len))
d107 1
a107 1
	sizeof(*((LineData *)0)->name)
d119 1
a119 1
		    value = (value | AlignMask()) + 1
d159 1
a159 1
	result += screen->lineExtra;
d268 1
a268 1
    result = (ScrnPtr *) calloc(nrow, size);
d292 1
a292 1
    result = (ncol * sizeof(CharData));
d323 2
a324 2
    TRACE(("allocScrnData %dx%d -> %d -> %p..%p\n",
	   nrow, ncol, length, result, result + length - 1));
d672 1
a672 1
	flags |= TERM_COLOR_FLAGS(xw);
d677 1
a677 1
	memset(ld->attribs + col, flags, len);
d688 1
a688 1
		memset(ld->combData[off] + col, 0, len * sizeof(CharData));
d742 1
a742 1
	      CellColor cur_fg_bg,
d844 1
a844 1
    memset(attrs, (Char) flags, real_width);
d857 1
a857 1
	    fb[j] = cur_fg_bg;
d909 1
a909 1
	    memset(work->attribs, (int) flags, size);
d919 1
a919 1
	    memset(work->attribs, 0, size);
d994 1
a994 1
    size_t result = scrnHeadSize(screen, len);
a1275 1
    int max = screen->max_row;
d1282 2
a1283 2
    TRACE(("ScrnRefresh (%d,%d) - (%d,%d)%s {{\n",
	   toprow, leftcol,
d1327 6
a1332 2
	TRACE2(("ScrnRefresh row=%d lastind=%d/%d\n", row, lastind, max));
	if (lastind < 0 || lastind > max)
d1334 1
a1334 3

	if ((ld = getLineData(screen, ROW2INX(screen, lastind))) == 0)
	    break;
d1342 2
d2017 1
a2017 1
	*flags &= ~ORIGIN;
d2226 1
a2226 1
		    temp &= ~(FG_COLOR | BG_COLOR);
d2414 1
a2414 1
			    flags &= ~SGR_MASK;
d2432 1
a2432 1
			    flags &= ~BOLD;
d2435 1
a2435 1
			    flags &= ~UNDERLINE;
d2438 1
a2438 1
			    flags &= ~BLINK;
d2441 1
a2441 1
			    flags &= ~INVERSE;
d2444 1
a2444 1
			    flags &= ~INVISIBLE;
@


1.6
log
@Update to xterm 250
@
text
@d1 1
a1 1
/* $XTermId: screen.c,v 1.403 2009/10/01 00:30:19 tom Exp $ */
d4 1
a4 1
 * Copyright 1999-2008,2009 by Thomas E. Dickey
d273 1
a273 1
	   result,
d354 1
a354 1
    TRACE(("allocScrnBuf %dx%d ->%p\n", nrow, ncol, base));
d456 1
a456 1
		- (xw->screen.max_row - xw->screen.cur_row);
d489 1
a489 1
	    move_down = Min((int) (nrow - oldrow), xw->screen.savedlines);
d506 1
a506 1
    TRACE(("...Reallocate %dx%d ->%p\n", nrow, ncol, newBufHead));
d592 1
a592 1
    TScreen *screen = &(xw->screen);
d600 2
d611 1
a611 1
	    SwitchBufPtrs(screen);
d649 2
a650 2
	if (screen->whichBuf)
	    SwitchBufPtrs(screen);
d666 1
a666 1
	TScreen *screen = &(xw->screen);
d688 1
a688 1
		memset(ld->combData[off] + col, 0, len * sizeof(IChar));
d702 1
a702 1
    TScreen *screen = &(xw->screen);
d725 2
a726 2
    if (ScrnHaveSelection(&(xw->screen))) {
	if (xw->screen.keepSelection) {
d745 1
a745 1
    TScreen *screen = &(xw->screen);
d851 1
a851 1
		   real_width * sizeof(IChar));
d878 1
a878 1
    TScreen *screen = &(xw->screen);
d907 1
a907 1
	memset(work->charData, 0, size * sizeof(IChar));
d929 1
a929 1
		memset(work->combData[off], 0, size * sizeof(IChar));
d1015 1
a1015 1
    TScreen *screen = &(xw->screen);
d1060 1
a1060 1
    TScreen *screen = &(xw->screen);
d1146 1
a1146 1
    TScreen *screen = &(xw->screen);
d1207 1
a1207 1
    TScreen *screen = &(xw->screen);
d1270 1
a1270 1
    TScreen *screen = &(xw->screen);
d1334 1
a1334 1
	if (maxcol >= ld->lineSize) {
d1632 1
a1632 1
    TScreen *screen = &(xw->screen);
d1651 1
a1651 1
    TScreen *screen = &(xw->screen);
d1691 1
a1691 1
    TScreen *screen = &(xw->screen);
d1710 1
a1710 1
	if (width >= FullWidth(screen)) {
d1716 1
a1716 1
	if (height >= FullHeight(screen)) {
d1737 1
d1964 1
a1964 1
		&& GravityIsSouthWest(xw))
d1966 5
a1970 1
		SwitchBufPtrs(screen);
d2007 2
a2008 2
		if (screen->whichBuf)
		    SwitchBufPtrs(screen);	/* put the pointers back */
d2154 1
a2154 1
    TScreen *screen = &(xw->screen);
d2171 1
a2171 1
    TScreen *screen = &(xw->screen);
d2196 1
a2196 1
    TScreen *screen = &(xw->screen);
d2243 1
a2243 1
		    memset(ld->combData[off] + left, 0, size * sizeof(IChar));
d2270 1
a2270 1
    TScreen *screen = &(xw->screen);
d2355 1
a2355 1
    TScreen *screen = &(xw->screen);
d2473 1
a2473 1
    TScreen *screen = &(xw->screen);
@


1.5
log
@update to xterm 247, a small bug fix over version 246.
@
text
@d1 1
a1 1
/* $XTermId: screen.c,v 1.396 2009/08/30 00:06:07 tom Exp $ */
d707 2
a708 1
	if (DamagedCells(screen, len, &kl, &kr, INX2ROW(screen, row), col)
d759 4
d1164 1
a1164 1
	int xx = INX2ROW(screen, screen->cur_row);
d1228 1
a1228 1
			 INX2ROW(screen, screen->cur_row),
d1655 9
a1663 7
	LineData *ld = getLineData(screen, ROW2INX(screen, row));
	if_OPT_DEC_CHRSET({
	    /* clearing the whole row resets the doublesize characters */
	    SetLineDblCS(ld, CSET_SWL);
	});
	LineClrWrapped(ld);
	ClearCells(xw, 0, len, row, 0);
d1787 2
a1788 2
			saveEditBufLines(screen, dst, -amount);
			move_up = -amount;
@


1.4
log
@update to xterm 246. Has been in snapshots for some time.
@
text
@d1 1
a1 1
/* $XTermId: screen.c,v 1.394 2009/08/16 18:16:45 tom Exp $ */
d284 1
a284 1
    unsigned result = 1;
d292 3
d297 1
a297 1
	result += (unsigned) screen->max_combining;
a299 2
    result = (ncol * result * sizeof(CharData));
    AlignValue(result);
@


1.3
log
@Update to xterm 242. Tested by jsg@@.
@
text
@d1 1
a1 1
/* $XTermId: screen.c,v 1.246 2009/02/09 21:37:57 tom Exp $ */
d72 4
d81 246
d338 1
a338 3
 * We store it all as pointers, because of alignment considerations, together
 * with the intention of being able to change the total number of pointers per
 * row according to whether the user wants color or not.
d341 1
a341 1
Allocate(int nrow, int ncol, Char ** addr)
d343 38
a380 5
    ScrnBuf base;
    Char *tmp;
    int i, j, k;
    size_t entries = (size_t) (MAX_PTRS * nrow);
    size_t length = (size_t) (BUF_PTRS * nrow * ncol);
d382 7
a388 2
    if ((base = TypeCallocN(ScrnPtr, entries)) == 0)
	SysError(ERROR_SCALLOC);
d390 6
a395 2
    if ((tmp = TypeCallocN(Char, length)) == 0)
	SysError(ERROR_SCALLOC2);
d397 3
a399 7
    *addr = tmp;
    for (i = k = 0; i < nrow; i++) {
	base[k] = 0;		/* per-line flags */
	k += BUF_HEAD;
	for (j = BUF_HEAD; j < MAX_PTRS; j++) {
	    base[k++] = tmp;
	    tmp += ncol;
d401 7
a408 2

    return (base);
d410 1
d421 12
a432 10
	   int nrow,
	   int ncol,
	   int oldrow,
	   int oldcol)
{
    ScrnBuf base;
    Char *tmp;
    int i, j, k, minrows;
    size_t mincols;
    Char *oldbuf;
a433 2
    size_t entries = (size_t) (MAX_PTRS * nrow);
    size_t length = (size_t) (BUF_PTRS * nrow * ncol);
d439 1
a439 1
    oldbuf = *sbufaddr;
d441 1
a441 7
    /*
     * Special case if oldcol == ncol - straight forward realloc and
     * update of the additional lines in sbuf
     *
     * FIXME: this is a good idea, but doesn't seem to be implemented.
     * -gildea
     */
d448 27
a474 15
    if (nrow < oldrow
	&& xw->misc.resizeGravity == SouthWestGravity) {
	/* Remove lines off the top of the buffer if necessary. */
	move_up = (oldrow - nrow)
	    - (xw->screen.max_row - xw->screen.cur_row);
	if (move_up < 0)
	    move_up = 0;
	/* Overlapping memmove here! */
	memmove(*sbuf, *sbuf + (move_up * MAX_PTRS),
		(unsigned) (MAX_PTRS * (oldrow - move_up)) * sizeof((*sbuf)[0]));
    }
    *sbuf = TypeRealloc(ScrnPtr, entries, *sbuf);
    if (*sbuf == 0)
	SysError(ERROR_RESIZE);
    base = *sbuf;
d477 2
a478 2
     *  create the new buffer space and copy old buffer contents there
     *  line by line.
d480 3
a482 3
    if ((tmp = TypeCallocN(Char, length)) == 0)
	SysError(ERROR_SREALLOC);
    *sbufaddr = tmp;
d484 5
a488 13
    mincols = (size_t) ((oldcol < ncol) ? oldcol : ncol);
    if (nrow > oldrow
	&& xw->misc.resizeGravity == SouthWestGravity) {
	/* move data down to bottom of expanded screen */
	move_down = Min(nrow - oldrow, xw->screen.savedlines);
	tmp += (ncol * move_down * BUF_PTRS);
    }

    for (i = k = 0; i < minrows; i++) {
	k += BUF_HEAD;
	for (j = BUF_HEAD; j < MAX_PTRS; j++) {
	    memcpy(tmp, base[k++], mincols);
	    tmp += ncol;
d492 9
a500 11
    /*
     * update the pointers in sbuf
     */
    for (i = k = 0, tmp = *sbufaddr; i < nrow; i++) {
	for (j = 0; j < BUF_HEAD; j++)
	    base[k++] = 0;
	for (j = BUF_HEAD; j < MAX_PTRS; j++) {
	    base[k++] = tmp;
	    tmp += ncol;
	}
    }
d502 2
a503 2
    /* Now free the old buffer */
    free(oldbuf);
d505 1
a509 33
#if 0
static void
dump_screen(const char *tag,
	    XtermWidget xw,
	    ScrnBuf sbuf,
	    Char * sbufaddr,
	    unsigned nrow,
	    unsigned ncol)
{
    unsigned y, x;

    TRACE(("DUMP %s, ptrs %d\n", tag, xw->num_ptrs));
    TRACE(("  sbuf      %p\n", sbuf));
    TRACE(("  sbufaddr  %p\n", sbufaddr));
    TRACE(("  nrow      %d\n", nrow));
    TRACE(("  ncol      %d\n", ncol));

    for (y = 0; y < nrow; ++y) {
	ScrnPtr ptr = BUF_CHARS(sbuf, y);
	TRACE(("%3d:%p:", y, ptr));
	for (x = 0; x < ncol; ++x) {
	    Char c = ptr[x];
	    if (c == 0)
		c = '~';
	    TRACE(("%c", c));
	}
	TRACE(("\n"));
    }
}
#else
#define dump_screen(tag, xw, sbuf, sbufaddr, nrow, ncol)	/* nothing */
#endif

d519 1
a519 2
		     unsigned ncol,
		     size_t new_max_offsets)
d521 1
d523 12
a534 10
    int j, k;
    ScrnBuf base;
    Char *oldbuf, *tmp;
    size_t entries, length;
    /*
     * As there are 2 buffers (allbuf, altbuf), we cannot change num_ptrs in
     * this function.  However MAX_PTRS and BUF_PTRS depend on num_ptrs so
     * change it now and restore the value when done.
     */
    int old_max_ptrs = MAX_PTRS;
a537 1
    assert(new_max_offsets != 0);
d539 2
a540 1
    dump_screen("before", xw, *sbuf, *sbufaddr, nrow, ncol);
d542 9
a550 1
    xw->num_ptrs = (int) new_max_offsets;
d552 18
a569 3
    entries = ((unsigned) MAX_PTRS * nrow);
    length = ((unsigned) BUF_PTRS * nrow * ncol);
    oldbuf = *sbufaddr;
d571 3
a573 16
    *sbuf = TypeRealloc(ScrnPtr, entries, *sbuf);
    if (*sbuf == 0)
	SysError(ERROR_RESIZE);
    base = *sbuf;

    if ((tmp = TypeCallocN(Char, length)) == 0)
	SysError(ERROR_SREALLOC);
    *sbufaddr = tmp;

    for (i = 0, k = 0; i < nrow; i++) {
	k += BUF_HEAD;
	for (j = BUF_HEAD; j < old_max_ptrs; j++) {
	    memcpy(tmp, base[k++], ncol);
	    tmp += ncol;
	}
	tmp += ncol * (new_max_offsets - (unsigned) old_max_ptrs);
d576 3
a578 11
    /*
     * update the pointers in sbuf
     */
    for (i = 0, k = 0, tmp = *sbufaddr; i < nrow; i++) {
	for (j = 0; j < BUF_HEAD; j++)
	    base[k++] = 0;
	for (j = BUF_HEAD; j < MAX_PTRS; j++) {
	    base[k++] = tmp;
	    tmp += ncol;
	}
    }
d580 1
a580 3
    /* Now free the old buffer and restore num_ptrs */
    free(oldbuf);
    dump_screen("after", xw, *sbuf, *sbufaddr, nrow, ncol);
d582 1
a582 1
    xw->num_ptrs = old_max_ptrs;
a591 2
    unsigned new_bufoffset = (unsigned) (OFF_FINAL
					 + (screen->max_combining * 2));
d605 1
a605 1
	 * data in altbuf.
d607 1
a607 1
	if (screen->alternate)
d610 2
d613 16
a628 1
			     &screen->allbuf, &screen->sbuf_address,
d630 3
a632 3
			     (unsigned) MaxCols(screen),
			     new_bufoffset);
	if (screen->altbuf) {
d634 2
a635 1
				 &screen->altbuf, &screen->abuf_address,
d637 1
a637 2
				 (unsigned) MaxCols(screen),
				 new_bufoffset);
d641 1
a641 2
	xw->num_ptrs = (int) new_bufoffset;
	screen->visbuf = &screen->allbuf[MAX_PTRS * savelines];
d646 1
a646 1
	if (screen->alternate)
d664 5
d671 4
a674 2
	memset(SCRN_BUF_CHARS(screen, row) + col, ' ', len);
	memset(SCRN_BUF_ATTRS(screen, row) + col, flags, len);
d676 5
a680 13
	if_OPT_EXT_COLORS(screen, {
	    memset(SCRN_BUF_FGRND(screen, row) + col,
		   xw->sgr_foreground, len);
	    memset(SCRN_BUF_BGRND(screen, row) + col,
		   xw->cur_background, len);
	});
	if_OPT_ISO_TRADITIONAL_COLORS(screen, {
	    memset(SCRN_BUF_COLOR(screen, row) + col,
		   (int) xtermColorPair(xw), len);
	});
	if_OPT_DEC_CHRSET({
	    memset(SCRN_BUF_CSETS(screen, row) + col,
		   curXtermChrSet(xw, row), len);
d683 3
a685 3
	    int off;
	    for (off = OFF_WIDEC; off < MAX_PTRS; ++off) {
		memset(SCREEN_PTR(screen, row, off) + col, 0, len);
d738 1
a738 1
	      unsigned cur_fg_bg,
d742 1
d744 1
a744 9
#if OPT_EXT_COLORS
    Char *fbf = 0;
    Char *fbb = 0;
#else
    Char *fb = 0;
#endif
#endif
#if OPT_DEC_CHRSET
    Char *cb = 0;
d748 1
a748 1
    Char *chars;
d750 1
a750 1
    Char starcol1, starcol2;
d764 4
a767 2
    chars = SCRN_BUF_CHARS(screen, screen->cur_row) + screen->cur_col;
    attrs = SCRN_BUF_ATTRS(screen, screen->cur_row) + screen->cur_col;
d769 2
a770 9
    if_OPT_EXT_COLORS(screen, {
	fbf = SCRN_BUF_FGRND(screen, screen->cur_row) + screen->cur_col;
	fbb = SCRN_BUF_BGRND(screen, screen->cur_row) + screen->cur_col;
    });
    if_OPT_ISO_TRADITIONAL_COLORS(screen, {
	fb = SCRN_BUF_COLOR(screen, screen->cur_row) + screen->cur_col;
    });
    if_OPT_DEC_CHRSET({
	cb = SCRN_BUF_CSETS(screen, screen->cur_row) + screen->cur_col;
a774 1
    starcol2 = chars[length - 1];
d782 1
a782 1
	    chars[n] = LO_BYTE(str[n]);
d787 1
a787 1
	ScrnSetBlinked(screen, screen->cur_row);
a790 2
#define ERROR_1 0x20
#define ERROR_2 0x00
a792 2
	Char *char2;

d794 5
a798 7
	    Char *char1 = chars;
	    char2 = SCRN_BUF_WIDEC(screen, screen->cur_row);
	    char2 += screen->cur_col;
	    if (screen->cur_col && starcol1 == HIDDEN_LO && *char2 == HIDDEN_HI
		&& isWide(PACK_PAIR(char1, char2, -1))) {
		char1[-1] = ERROR_1;
		char2[-1] = ERROR_2;
d805 1
a805 3
		*char1++ = LO_BYTE(*str);
		*char2++ = HI_BYTE(*str);
		str++;
d809 1
a809 4
		    *char1 = HIDDEN_LO;
		    *char2 = HIDDEN_HI;
		    char1++;
		    char2++;
d813 3
a815 6
	    if (*char1 == HIDDEN_LO
		&& *char2 == HIDDEN_HI
		&& char1[-1] == HIDDEN_LO
		&& char2[-1] == HIDDEN_HI) {
		*char1 = ERROR_1;
		*char2 = ERROR_2;
d820 10
a829 22
	    if ((char2 = SCRN_BUF_WIDEC(screen, screen->cur_row)) != 0) {
		char2 += screen->cur_col;
		if (screen->cur_col && starcol1 == HIDDEN_LO && *char2 == HIDDEN_HI
		    && isWide(PACK_PAIR(chars, char2, -1))) {
		    chars[-1] = ERROR_1;
		    char2[-1] = ERROR_2;
		}
		/* if we are overwriting the right hand half of a
		   wide character, make the other half vanish */
		if (chars[length] == HIDDEN_LO && char2[length] == HIDDEN_HI &&
		    isWide(PACK_PAIR(chars, char2, length - 1))) {
		    chars[length] = ERROR_1;
		    char2[length] = ERROR_2;
		}
		/* if we are overwriting the left hand half of a
		   wide character, make the other half vanish */
		for (n = 0; n < length; ++n) {
		    if ((flags & INVISIBLE))
			char2[n] = 0;
		    else
			char2[n] = HI_BYTE(str[n]);
		}
d839 5
a843 6
	int off;
	for (off = OFF_FINAL; off < MAX_PTRS; ++off) {
	    memset(SCREEN_PTR(screen,
			      screen->cur_row,
			      off) + screen->cur_col,
		   0, real_width);
d846 4
a849 9
    if_OPT_EXT_COLORS(screen, {
	memset(fbf, (int) ExtractForeground(cur_fg_bg), real_width);
	memset(fbb, (int) ExtractBackground(cur_fg_bg), real_width);
    });
    if_OPT_ISO_TRADITIONAL_COLORS(screen, {
	memset(fb, (int) cur_fg_bg, real_width);
    });
    if_OPT_DEC_CHRSET({
	memset(cb, curXtermChrSet(xw, screen->cur_row), real_width);
d860 2
d871 8
a878 3
    int i, j;
    size_t len = ScrnPointers(screen, n);
    int last = ((int) n * MAX_PTRS);
d880 3
a882 1
    TRACE(("ScrnClearLines(where %d, n %d, size %d)\n", where, n, size));
d888 1
a888 3
    memcpy((char *) screen->save_ptr,
	   (char *) &sb[MAX_PTRS * where],
	   len);
d891 11
a901 8
    if (TERM_COLOR_FLAGS(xw)) {
	unsigned flags = TERM_COLOR_FLAGS(xw);
	for (i = 0; i < last; i += MAX_PTRS) {
	    for (j = 0; j < MAX_PTRS; j++) {
		if (j < BUF_HEAD)
		    screen->save_ptr[i + j] = 0;
		else if (j == OFF_ATTRS)
		    memset(screen->save_ptr[i + j], (int) flags, size);
d903 6
a908 9
#if OPT_EXT_COLORS
		else if (j == OFF_FGRND)
		    memset(screen->save_ptr[i + j], xw->sgr_foreground, size);
		else if (j == OFF_BGRND)
		    memset(screen->save_ptr[i + j], xw->cur_background, size);
#else
		else if (j == OFF_COLOR)
		    memset(screen->save_ptr[i + j], (int)
			   xtermColorPair(xw), size);
d910 4
d915 7
a921 2
		else
		    bzero(screen->save_ptr[i + j], size);
d924 43
a966 6
    } else {
	for (i = 0; i < last; i += MAX_PTRS) {
	    for (j = 0; j < BUF_HEAD; j++)
		screen->save_ptr[i + j] = 0;
	    for (j = BUF_HEAD; j < MAX_PTRS; j++)
		bzero(screen->save_ptr[i + j], size);
d968 11
d980 1
d986 1
a986 1
    len *= (unsigned) MAX_PTRS;
d988 1
a988 1
    if (len > screen->save_len) {
d990 1
a990 1
	    screen->save_ptr = TypeRealloc(ScrnPtr, len, screen->save_ptr);
d992 1
a992 1
	    screen->save_ptr = TypeMallocN(ScrnPtr, len);
d997 2
a998 1
    return len * sizeof(ScrnPtr);
a1002 1
 * size is the size of each entry in sb.
d1005 1
a1005 2
ScrnInsertLine(XtermWidget xw, ScrnBuf sb, int last, int where,
	       unsigned n, unsigned size)
d1008 4
a1011 1
    size_t len = ScrnPointers(screen, n);
a1018 1
    assert(MAX_PTRS > 0);
d1033 8
a1040 3
    memmove((char *) &sb[MAX_PTRS * (where + (int) n)],
	    (char *) &sb[MAX_PTRS * where],
	    sizeof(char *) * (unsigned) (MAX_PTRS * (last - where)));
d1043 1
a1043 3
    memcpy((char *) &sb[MAX_PTRS * where],
	   (char *) screen->save_ptr,
	   len);
a1047 1
 * size is the size of each entry in sb.
d1050 1
a1050 2
ScrnDeleteLine(XtermWidget xw, ScrnBuf sb, int last, int where,
	       unsigned n, unsigned size)
d1053 5
a1063 1
    assert(MAX_PTRS > 0);
d1065 51
d1118 4
a1121 5
    /* move up lines */
    memmove((char *) &sb[MAX_PTRS * where],
	    (char *) &sb[MAX_PTRS * (where + (int) n)],
	    sizeof(char *) * (unsigned) (MAX_PTRS
					 * ((last -= ((int) n - 1)) - where)));
d1124 1
a1124 3
    memcpy((char *) &sb[MAX_PTRS * last],
	   (char *) screen->save_ptr,
	   (unsigned) MAX_PTRS * sizeof(char *) * n);
d1134 3
a1136 2
#define Target (data + col + n)
#define Source (data + col)
a1138 1
    ScrnBuf sb = screen->visbuf;
d1142 2
a1143 2
    Char *data;
    size_t nbytes;
d1150 1
a1150 1
    nbytes = (size_t) (last - (col + (int) n));
d1170 3
a1172 2
    data = BUF_CHARS(sb, row);
    memmove(Target, Source, nbytes);
d1174 10
a1183 24
    data = BUF_ATTRS(sb, row);
    memmove(Target, Source, nbytes);

    if_OPT_EXT_COLORS(screen, {
	data = BUF_FGRND(sb, row);
	memmove(Target, Source, nbytes);
	data = BUF_BGRND(sb, row);
	memmove(Target, Source, nbytes);
    });
    if_OPT_ISO_TRADITIONAL_COLORS(screen, {
	data = BUF_COLOR(sb, row);
	memmove(Target, Source, nbytes);
    });
    if_OPT_DEC_CHRSET({
	data = BUF_CSETS(sb, row);
	memmove(Target, Source, nbytes);
    });
    if_OPT_WIDE_CHARS(screen, {
	int off;
	for (off = OFF_WIDEC; off < MAX_PTRS; ++off) {
	    data = BUFFER_PTR(sb, row, off);
	    memmove(Target, Source, nbytes);
	}
    });
d1186 1
a1186 2
#undef Source
#undef Target
d1195 3
a1197 2
#define Target (data + col)
#define Source (data + col + n)
a1199 1
    ScrnBuf sb = screen->visbuf;
d1203 2
a1204 2
    Char *data;
    size_t nbytes;
d1211 1
a1211 1
    nbytes = (size_t) (last - (col + (int) n));
d1227 3
a1229 2
    data = BUF_CHARS(sb, row);
    memmove(Target, Source, nbytes);
d1231 11
a1241 24
    data = BUF_ATTRS(sb, row);
    memmove(Target, Source, nbytes);

    if_OPT_EXT_COLORS(screen, {
	data = BUF_FGRND(sb, row);
	memmove(Target, Source, nbytes);
	data = BUF_BGRND(sb, row);
	memmove(Target, Source, nbytes);
    });
    if_OPT_ISO_TRADITIONAL_COLORS(screen, {
	data = BUF_COLOR(sb, row);
	memmove(Target, Source, nbytes);
    });
    if_OPT_DEC_CHRSET({
	data = BUF_CSETS(sb, row);
	memmove(Target, Source, nbytes);
    });
    if_OPT_WIDE_CHARS(screen, {
	int off;
	for (off = OFF_WIDEC; off < MAX_PTRS; ++off) {
	    data = BUFFER_PTR(sb, row, off);
	    memmove(Target, Source, nbytes);
	}
    });
a1242 1
    ScrnClrWrapped(screen, row);
d1244 1
a1244 2
#undef Source
#undef Target
d1263 1
d1275 1
a1275 1
    TRACE(("ScrnRefresh (%d,%d) - (%d,%d)%s\n",
d1288 2
a1289 11
#if OPT_EXT_COLORS
	Char *fbf = 0;
	Char *fbb = 0;
#define ColorOf(col) (unsigned) ((fbf[col] << 8) | fbb[col])
#else
	Char *fb = 0;
#define ColorOf(col) (unsigned) (fb[col])
#endif
#endif
#if OPT_DEC_CHRSET
	Char *cb = 0;
d1293 1
a1293 4
	Char *widec = 0;
#define WIDEC_PTR(cell) widec ? &widec[cell] : 0
#define BLANK_CEL(cell) ((chars[cell] == ' ') && (widec == 0 || widec[cell] == 0))
#else
d1295 1
a1295 3
#endif
	Char cs = 0;
	Char *chars;
d1303 2
a1304 1
	unsigned fg_bg = 0, fg = 0, bg = 0;
d1311 3
d1320 1
a1320 1
	TRACE(("ScrnRefresh row=%d lastind=%d/%d\n", row, lastind, max));
d1324 6
a1329 6
	chars = SCRN_BUF_CHARS(screen, ROW2INX(screen, lastind));
	attrs = SCRN_BUF_ATTRS(screen, ROW2INX(screen, lastind));

	if_OPT_DEC_CHRSET({
	    cb = SCRN_BUF_CSETS(screen, ROW2INX(screen, lastind));
	});
d1331 2
a1332 3
	if_OPT_WIDE_CHARS(screen, {
	    widec = SCRN_BUF_WIDEC(screen, ROW2INX(screen, lastind));
	});
d1342 2
a1343 2
		    (PACK_PAIR(chars, widec, leftcol)) == HIDDEN_CHAR &&
		    isWide(PACK_PAIR(chars, widec, leftcol - 1))) {
d1361 1
a1361 1
	    if (CSET_DOUBLE(*cb)) {
d1379 1
a1379 1
	    if (CSET_DOUBLE(*cb)) {
d1435 1
a1435 1
	    if (CSET_DOUBLE(*cb)) {
a1438 1
	    cs = cb[col];
d1442 3
a1444 14
#if OPT_WIDE_CHARS
	if (widec)
	    wideness = isWide(PACK_PAIR(chars, widec, col));
	else
	    wideness = 0;
#endif
	if_OPT_EXT_COLORS(screen, {
	    fbf = SCRN_BUF_FGRND(screen, ROW2INX(screen, lastind));
	    fbb = SCRN_BUF_BGRND(screen, ROW2INX(screen, lastind));
	    fg_bg = ColorOf(col);
	    /* this combines them, then splits them again.  but
	       extract_fg does more, so seems reasonable */
	    fg = extract_fg(xw, fg_bg, flags);
	    bg = extract_bg(xw, fg_bg, flags);
d1446 3
a1448 2
	if_OPT_ISO_TRADITIONAL_COLORS(screen, {
	    fb = SCRN_BUF_COLOR(screen, ROW2INX(screen, lastind));
d1457 1
a1457 1
	x = CurCursorX(screen, ROW2INX(screen, row), col);
d1470 2
a1471 6
		|| (widec
		    && ((isWide(PACK_PAIR(chars, widec, col))) != wideness)
		    && !((PACK_PAIR(chars, widec, col)) == HIDDEN_CHAR))
#endif
#if OPT_DEC_CHRSET
		|| (cb[col] != cs)
d1477 2
a1478 3
		       visibleChars(PAIRED_CHARS(&chars[lastind],
						 WIDEC_PTR(lastind)),
				    (unsigned) (col - lastind))));
d1484 2
a1485 2
				  cs,
				  PAIRED_CHARS(&chars[lastind], WIDEC_PTR(lastind)),
d1490 5
a1494 8
		    int off;
		    for (off = OFF_FINAL; off < MAX_PTRS; off += 2) {
			Char *com_lo = BUFFER_PTR(screen->visbuf,
						  ROW2INX(screen, row),
						  off + 0);
			Char *com_hi = BUFFER_PTR(screen->visbuf,
						  ROW2INX(screen, row),
						  off + 1);
d1496 5
a1500 10
			    int my_x = CurCursorX(screen,
						  ROW2INX(screen, row),
						  i);
			    int base = PACK_PAIR(chars, widec, i);
			    int combo = PACK_PAIR(com_lo, com_hi, i);

			    if (isWide(base))
				my_x = CurCursorX(screen,
						  ROW2INX(screen, row),
						  i - 1);
d1502 1
a1502 1
			    if (combo != 0)
d1506 4
a1509 4
					      gc, my_x, y, cs,
					      PAIRED_CHARS(com_lo + i,
							   com_hi + i),
					      1, isWide(base));
d1522 1
a1522 1
		if_OPT_EXT_COLORS(screen, {
d1527 2
a1528 7
		if_OPT_ISO_TRADITIONAL_COLORS(screen, {
		    fg_bg = ColorOf(col);
		    fg = extract_fg(xw, fg_bg, flags);
		    bg = extract_bg(xw, fg_bg, flags);
		});
		if_OPT_DEC_CHRSET({
		    cs = cb[col];
a1529 4
#if OPT_WIDE_CHARS
		if (widec)
		    wideness = isWide(PACK_PAIR(chars, widec, col));
#endif
d1536 1
a1536 4
#if OPT_WIDE_CHARS
		if (widec == 0 || widec[col] == 0)
#endif
		    chars[col] = ' ';
d1543 1
a1543 2
	       visibleChars(PAIRED_CHARS(&chars[lastind], WIDEC_PTR(lastind)),
			    (unsigned) (col - lastind))));
d1549 2
a1550 2
		      cs,
		      PAIRED_CHARS(&chars[lastind], WIDEC_PTR(lastind)),
d1555 5
a1559 8
	    int off;
	    for (off = OFF_FINAL; off < MAX_PTRS; off += 2) {
		Char *com_lo = BUFFER_PTR(screen->visbuf,
					  ROW2INX(screen, row),
					  off + 0);
		Char *com_hi = BUFFER_PTR(screen->visbuf,
					  ROW2INX(screen, row),
					  off + 1);
d1561 2
a1562 5
		    int my_x = CurCursorX(screen,
					  ROW2INX(screen, row),
					  i);
		    int base = PACK_PAIR(chars, widec, i);
		    int combo = PACK_PAIR(com_lo, com_hi, i);
d1565 1
a1565 3
			my_x = CurCursorX(screen,
					  ROW2INX(screen, row),
					  i - 1);
d1567 1
a1567 1
		    if (combo != 0)
d1571 3
a1573 3
				      gc, my_x, y, cs,
				      PAIRED_CHARS(com_lo + i,
						   com_hi + i),
d1607 3
d1649 1
d1652 1
a1652 1
	    SCRN_ROW_CSET(screen, row) = CSET_SWL;
d1654 1
a1654 1
	ScrnClrWrapped(screen, row);
a1726 3
	int savelines = (screen->scrollWidget
			 ? screen->savelines
			 : 0);
d1728 3
d1732 2
a1733 1
	TRACE(("...ScreenResize chars %dx%d\n", rows, cols));
d1736 5
d1743 211
a1953 2
	    if (screen->alternate
		&& xw->misc.resizeGravity == SouthWestGravity)
d1956 1
a1956 1
	    if (screen->altbuf)
d1958 6
a1963 6
				  &screen->altbuf,
				  &screen->abuf_address,
				  rows,
				  cols,
				  MaxRows(screen),
				  MaxCols(screen));
d1965 8
a1972 6
				      &screen->allbuf,
				      &screen->sbuf_address,
				      rows + savelines, cols,
				      MaxRows(screen) + savelines,
				      MaxCols(screen));
	    screen->visbuf = &screen->allbuf[MAX_PTRS * savelines];
d1980 1
a1980 1
	    if (xw->misc.resizeGravity == SouthWestGravity) {
d1992 1
a1992 1
		if (screen->alternate)
a2078 1
    ScrnBuf sb = screen->visbuf;
d2080 2
a2081 6
    Char *ptr = BUF_CHARS(sb, row);

    for (i = col; i < len; i++) {
	if (ptr[i])
	    return True;
    }
d2083 5
a2087 5
    if_OPT_WIDE_CHARS(screen, {
	if ((ptr = BUF_WIDEC(sb, row)) != 0) {
	    for (i = col; i < len; i++) {
		if (ptr[i])
		    return True;
d2090 2
a2091 3
    });

    return False;
d2185 1
d2191 2
d2196 2
d2205 2
a2206 1
		unsigned temp = SCRN_BUF_ATTRS(screen, row)[col];
d2212 1
a2212 1
		SCRN_BUF_ATTRS(screen, row)[col] = (Char) temp;
d2215 2
a2216 6
		    if_OPT_EXT_COLORS(screen, {
			SCRN_BUF_FGRND(screen, row)[col] = (Char) xw->sgr_foreground;
			SCRN_BUF_BGRND(screen, row)[col] = (Char) xw->cur_background;
		    });
		    if_OPT_ISO_TRADITIONAL_COLORS(screen, {
			SCRN_BUF_COLOR(screen, row)[col] = xtermColorPair(xw);
d2222 3
a2224 1
	    memset(SCRN_BUF_CHARS(screen, row) + left, (Char) value, size);
d2226 3
a2228 3
		int off;
		for (off = OFF_WIDEC; off < MAX_PTRS; ++off) {
		    memset(SCREEN_PTR(screen, row, off) + left, 0, size);
d2266 24
a2289 20
	    int high = (source->bottom - source->top) + 1;
	    int wide = (source->right - source->left) + 1;
	    unsigned size = (unsigned) (high * wide * MAX_PTRS);
	    int row, col, n, j;

	    Char *cells = TypeMallocN(Char, size);

	    if (cells == 0)
		return;

	    TRACE(("OK - make copy %dx%d\n", high, wide));
	    target.bottom = target.top + (high - 1);
	    target.right = target.left + (wide - 1);

	    for (row = source->top - 1; row < source->bottom; ++row) {
		for (col = source->left - 1; col < source->right; ++col) {
		    n = (((1 + row - source->top) * wide)
			 + (1 + col - source->left)) * MAX_PTRS;
		    for (j = OFF_ATTRS; j < MAX_PTRS; ++j)
			cells[n + j] = SCREEN_PTR(screen, row, j)[col];
d2291 18
a2308 12
	    }
	    for (row = target.top - 1; row < target.bottom; ++row) {
		for (col = target.left - 1; col < target.right; ++col) {
		    if (row >= getMinRow(screen)
			&& row <= getMaxRow(screen)
			&& col >= getMinCol(screen)
			&& col <= getMaxCol(screen)) {
			n = (((1 + row - target.top) * wide)
			     + (1 + col - target.left)) * MAX_PTRS;
			for (j = OFF_ATTRS; j < MAX_PTRS; ++j)
			    SCREEN_PTR(screen, row, j)[col] = cells[n + j];
			SCRN_BUF_ATTRS(screen, row)[col] |= CHARDRAWN;
d2311 8
a2319 8
	    free(cells);

	    ScrnUpdate(xw,
		       (target.top - 1),
		       (target.left - 1),
		       (target.bottom - target.top) + 1,
		       ((target.right - target.left) + 1),
		       False);
d2350 1
d2364 2
d2368 1
a2368 1
		unsigned flags = SCRN_BUF_ATTRS(screen, row)[col];
d2434 1
a2434 1
			   SCRN_BUF_ATTRS(screen, row)[col] ^ flags));
d2436 1
a2436 1
		SCRN_BUF_ATTRS(screen, row)[col] = (Char) flags;
d2463 1
d2473 2
d2477 3
a2479 3
		      && (SCRN_BUF_ATTRS(screen, row)[col] & PROTECTED))) {
		    SCRN_BUF_ATTRS(screen, row)[col] |= CHARDRAWN;
		    SCRN_BUF_CHARS(screen, row)[col] = ' ';
d2481 3
a2483 3
			int off;
			for (off = OFF_WIDEC; off < MAX_PTRS; ++off) {
			    memset(SCREEN_PTR(screen, row, off) + col, 0, 1);
@


1.2
log
@xterm-236. Tested by form@@ and simon@@.
@
text
@d1 1
a1 1
/* $XTermId: screen.c,v 1.241 2008/04/20 21:07:10 tom Exp $ */
d4 1
a4 1
 * Copyright 1999-2007,2008 by Thomas E. Dickey
d98 2
a99 2
    size_t entries = MAX_PTRS * nrow;
    size_t length = BUF_PTRS * nrow * ncol;
d140 2
a141 2
    size_t entries = MAX_PTRS * nrow;
    size_t length = BUF_PTRS * nrow * ncol;
d171 1
a171 1
		MAX_PTRS * (oldrow - move_up) * sizeof((*sbuf)[0]));
d186 1
a186 1
    mincols = (oldcol < ncol) ? oldcol : ncol;
d284 1
a284 1
    xw->num_ptrs = new_max_offsets;
d286 2
a287 2
    entries = MAX_PTRS * nrow;
    length = BUF_PTRS * nrow * ncol;
d299 1
a299 1
    for (i = k = 0; i < nrow; i++) {
d305 1
a305 1
	tmp += ncol * (new_max_offsets - old_max_ptrs);
d311 1
a311 1
    for (i = k = 0, tmp = *sbufaddr; i < nrow; i++) {
d334 2
a335 1
    unsigned new_bufoffset = OFF_FINAL + (screen->max_combining * 2);
d368 1
a368 1
	xw->num_ptrs = new_bufoffset;
d465 1
a465 1
	      PAIRED_CHARS(Char * str, Char * str2),
d488 2
a489 1
    unsigned real_width = visual_width(PAIRED_CHARS(str, str2), length);
d496 1
a496 1
	length = avail;
d520 5
a524 5
    if (flags & INVISIBLE) {
	memset(chars, ' ', length);
    } else {
	memcpy(chars, str, length);	/* This can stand for the present. If it
					   is wrong, we will scribble over it */
d544 1
a544 1
		&& iswide(PACK_PAIR(char1, char2, -1))) {
d551 1
a551 1
		int ch = PACK_PAIR(str, str2, 0);
d553 2
a554 2
		*char1 = *str;
		char1++;
a555 7

		if (str2) {
		    *char2 = *str2;
		    str2++;
		} else
		    *char2 = 0;
		char2++;
d558 1
a558 1
		if (iswide(ch)) {
a575 1

d579 1
a579 1
		    && iswide(PACK_PAIR(chars, char2, -1))) {
d586 1
a586 1
		    iswide(PACK_PAIR(chars, char2, length - 1))) {
d592 6
a597 4
		if ((flags & INVISIBLE) || (str2 == 0))
		    memset(char2, 0, length);
		else
		    memcpy(char2, str2, length);
d627 1
a627 1
	screen->last_written_col = screen->cur_col + real_width - 1;
d645 1
a645 1
    int last = (n * MAX_PTRS);
d659 1
a659 1
	int flags = TERM_COLOR_FLAGS(xw);
d665 1
a665 1
		    memset(screen->save_ptr[i + j], flags, size);
d695 1
a695 1
    len *= MAX_PTRS;
d729 1
a729 1
    ScrnClearLines(xw, sb, (last -= n - 1), n, size);
d741 1
a741 1
    memmove((char *) &sb[MAX_PTRS * (where + n)],
d743 1
a743 1
	    MAX_PTRS * sizeof(char *) * (last - where));
d772 3
a774 2
	    (char *) &sb[MAX_PTRS * (where + n)],
	    MAX_PTRS * sizeof(char *) * ((last -= n - 1) - where));
d779 1
a779 1
	   MAX_PTRS * sizeof(char *) * n);
d800 1
a800 1
    if (last <= (int) (col + n)) {
d803 1
a803 1
	n = last - col;
d805 1
a805 1
    nbytes = (last - (col + n));
d819 1
a819 1
	kr = screen->max_col - n + 1;
d875 1
a875 1
    if (last <= (int) (col + n)) {
d878 1
a878 1
	n = last - col;
d880 1
a880 1
    nbytes = (last - (col + n));
d923 1
a923 1
    ClearCells(xw, 0, n, row, (int) (last - n));
d951 1
a951 1
    int gc_changes = 0;
d1036 1
a1036 1
		    iswide(PACK_PAIR(chars, widec, leftcol - 1))) {
d1138 1
a1138 1
	    wideness = iswide(PACK_PAIR(chars, widec, col));
d1175 1
a1175 1
		    && ((iswide(PACK_PAIR(chars, widec, col))) != wideness)
d1214 1
a1214 1
			    if (iswide(base))
d1226 1
a1226 1
					      1, iswide(base));
d1254 1
a1254 1
		    wideness = iswide(PACK_PAIR(chars, widec, col));
d1300 1
a1300 1
		    if (iswide(base))
d1312 1
a1312 1
				      1, iswide(base));
d1379 1
a1379 1
    unsigned len = MaxCols(screen);
d1529 2
a1530 2
    screen->fullVwin.fullheight = height;
    screen->fullVwin.fullwidth = width;
d1545 1
a1545 1
	    screen->iconVwin.width + 2 * xw->misc.icon_border_width;
d1547 2
a1548 2
	    screen->iconVwin.height + 2 * xw->misc.icon_border_width;
	changes.border_width = xw->misc.icon_border_width;
d1708 3
a1710 3
	unsigned left = target->left - 1;
	unsigned size = target->right - left;
	Char attrs = flags;
d1722 2
a1723 2
	    for (col = left; col < target->right; ++col) {
		Char temp = SCRN_BUF_ATTRS(screen, row)[col];
d1729 1
a1729 1
		SCRN_BUF_ATTRS(screen, row)[col] = temp;
d1733 2
a1734 2
			SCRN_BUF_FGRND(screen, row)[col] = xw->sgr_foreground;
			SCRN_BUF_BGRND(screen, row)[col] = xw->cur_background;
d1785 3
a1787 3
	    unsigned high = (source->bottom - source->top) + 1;
	    unsigned wide = (source->right - source->left) + 1;
	    unsigned size = (high * wide * MAX_PTRS);
d1942 1
a1942 1
		SCRN_BUF_ATTRS(screen, row)[col] = flags;
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/* $XTermId: screen.c,v 1.208 2006/07/23 22:06:22 tom Exp $ */
d4 1
a4 1
 * Copyright 1999-2005,2006 by Thomas E. Dickey
a54 2
/* $XFree86: xc/programs/xterm/screen.c,v 3.77 2006/06/19 00:36:51 dickey Exp $ */

d377 1
a377 1
	SetVTFont(xw, screen->menu_font_number, TRUE, NULL);
d384 59
d450 5
a454 1
	DisownSelection(xw);
d463 5
a467 5
ScreenWrite(XtermWidget xw,
	    PAIRED_CHARS(Char * str, Char * str2),
	    unsigned flags,
	    unsigned cur_fg_bg,
	    unsigned length)
a483 1
    int wrappedbit;
a511 2
    wrappedbit = ScrnTstWrapped(screen, screen->cur_row);

d542 1
a542 1
		&& iswide(char1[-1] | (char2[-1] << 8))) {
d549 1
a549 3
		int ch = *str;
		if (str2)
		    ch |= *str2 << 8;
d580 1
a580 3
	}

	else {
d585 1
a585 1
		    && iswide(chars[-1] | (char2[-1] << 8))) {
d592 1
a592 1
		    iswide(starcol2 | (char2[length - 1] << 8))) {
d620 2
a621 2
	memset(fbf, (Char) (cur_fg_bg >> 8), real_width);
	memset(fbb, (Char) (cur_fg_bg & 0xff), real_width);
a629 5
    if (wrappedbit)
	ScrnSetWrapped(screen, screen->cur_row);
    else
	ScrnClrWrapped(screen, screen->cur_row);

d792 3
d797 1
a797 1
    unsigned last = MaxCols(screen);
d799 2
a800 6
    unsigned col = screen->cur_col;
    unsigned i;
    Char *ptr = BUF_CHARS(sb, row);
    Char *attrs = BUF_ATTRS(sb, row);
    int wrappedbit = ScrnTstWrapped(screen, row);
    int flags = CHARDRAWN | TERM_COLOR_FLAGS(xw);
d803 1
a803 1
    if (last <= (col + n)) {
d813 17
a829 1
    assert(last > n);
d831 2
a832 7
    ScrnClrWrapped(screen, row);	/* make sure the bit isn't moved */
    for (i = last - 1; i >= col + n; i--) {
	unsigned j = i - n;
	assert(i >= n);
	ptr[i] = ptr[j];
	attrs[i] = attrs[j];
    }
a833 4
    for (i = col; i < col + n; i++)
	ptr[i] = ' ';
    for (i = col; i < col + n; i++)
	attrs[i] = flags;
d835 4
a838 6
	ptr = BUF_FGRND(sb, row);
	memmove(ptr + col + n, ptr + col, nbytes);
	memset(ptr + col, xw->sgr_foreground, n);
	ptr = BUF_BGRND(sb, row);
	memmove(ptr + col + n, ptr + col, nbytes);
	memset(ptr + col, xw->cur_background, n);
d841 2
a842 3
	ptr = BUF_COLOR(sb, row);
	memmove(ptr + col + n, ptr + col, nbytes);
	memset(ptr + col, (int) xtermColorPair(xw), n);
d845 2
a846 3
	ptr = BUF_CSETS(sb, row);
	memmove(ptr + col + n, ptr + col, nbytes);
	memset(ptr + col, curXtermChrSet(xw, row), n);
d851 2
a852 3
	    ptr = BUFFER_PTR(sb, row, off);
	    memmove(ptr + col + n, ptr + col, nbytes);
	    memset(ptr + col, 0, n);
d855 1
d857 2
a858 4
    if (wrappedbit)
	ScrnSetWrapped(screen, row);
    else
	ScrnClrWrapped(screen, row);
d867 3
d872 4
a875 5
    unsigned last = MaxCols(screen);
    unsigned row = screen->cur_row;
    unsigned col = screen->cur_col;
    Char *ptr = BUF_CHARS(sb, row);
    Char *attrs = BUF_ATTRS(sb, row);
d878 1
a878 1
    if (last <= (col + n)) {
d888 10
a897 1
    assert(last > n);
d899 5
a903 4
    memmove(ptr + col, ptr + col + n, nbytes);
    memmove(attrs + col, attrs + col + n, nbytes);
    bzero(ptr + last - n, n);
    memset(attrs + last - n, (Char) (TERM_COLOR_FLAGS(xw)), n);
d906 4
a909 6
	ptr = BUF_FGRND(sb, row);
	memmove(ptr + col, ptr + col + n, nbytes);
	memset(ptr + last - n, xw->sgr_foreground, n);
	ptr = BUF_BGRND(sb, row);
	memmove(ptr + col, ptr + col + n, nbytes);
	memset(ptr + last - n, xw->cur_background, n);
d912 2
a913 3
	ptr = BUF_COLOR(sb, row);
	memmove(ptr + col, ptr + col + n, nbytes);
	memset(ptr + last - n, (int) xtermColorPair(xw), n);
d916 2
a917 3
	ptr = BUF_CSETS(sb, row);
	memmove(ptr + col, ptr + col + n, nbytes);
	memset(ptr + last - n, curXtermChrSet(xw, row), n);
d922 2
a923 3
	    ptr = BUFFER_PTR(sb, row, off);
	    memmove(ptr + col, ptr + col + n, nbytes);
	    memset(ptr + last - n, 0, n);
d926 1
d928 3
d1038 2
a1039 2
		    (chars[leftcol] | (widec[leftcol] << 8)) == HIDDEN_CHAR &&
		    iswide(chars[leftcol - 1] | (widec[leftcol - 1] << 8))) {
d1141 1
a1141 1
	    wideness = iswide(chars[col] | (widec[col] << 8));
d1178 2
a1179 2
		    && ((iswide(chars[col] | (widec[col] << 8))) != wideness)
		    && !((chars[col] | (widec[col] << 8)) == HIDDEN_CHAR))
d1214 2
a1215 2
			    int base = chars[i] | (widec[i] << 8);
			    int combo = com_lo[i] | (com_hi[i] << 8);
d1257 1
a1257 1
		    wideness = iswide(chars[col] | (widec[col] << 8));
d1300 2
a1301 2
		    int base = chars[i] | (widec[i] << 8);
		    int combo = com_lo[i] | (com_hi[i] << 8);
a1381 1
    ScrnBuf buf = screen->visbuf;
a1383 1
    int flags = TERM_COLOR_FLAGS(xw);
a1386 10
	ScrnClrWrapped(screen, row);
	bzero(BUF_CHARS(buf, row), len);
	memset(BUF_ATTRS(buf, row), flags, len);
	if_OPT_EXT_COLORS(screen, {
	    memset(BUF_FGRND(buf, row), xw->sgr_foreground, len);
	    memset(BUF_BGRND(buf, row), xw->cur_background, len);
	});
	if_OPT_ISO_TRADITIONAL_COLORS(screen, {
	    memset(BUF_COLOR(buf, row), (int) xtermColorPair(xw), len);
	});
d1388 2
a1389 7
	    memset(BUF_CSETS(buf, row), 0, len);
	});
	if_OPT_WIDE_CHARS(screen, {
	    int off;
	    for (off = OFF_WIDEC; off < MAX_PTRS; ++off) {
		memset(BUFFER_PTR(buf, row, off), 0, len);
	    }
d1391 2
d1421 1
a1421 1
    int move_down_by;
d1434 15
a1448 13
    /* clear the right and bottom internal border because of NorthWest
       gravity might have left junk on the right and bottom edges */
    if (width >= FullWidth(screen)) {
	XClearArea(screen->display, tw,
		   FullWidth(screen), 0,	/* right edge */
		   0, (unsigned) height,	/* from top to bottom */
		   False);
    }
    if (height >= FullHeight(screen)) {
	XClearArea(screen->display, tw,
		   0, FullHeight(screen),	/* bottom */
		   (unsigned) width, 0,		/* all across the bottom */
		   False);
d1471 14
a1484 19
	if (screen->cursor_state)
	    HideCursor();
	if (screen->alternate
	    && xw->misc.resizeGravity == SouthWestGravity)
	    /* swap buffer pointers back to make this work */
	    SwitchBufPtrs(screen);
	if (screen->altbuf)
	    (void) Reallocate(xw,
			      &screen->altbuf,
			      &screen->abuf_address,
			      rows,
			      cols,
			      MaxRows(screen),
			      MaxCols(screen));
	move_down_by = Reallocate(xw,
				  &screen->allbuf,
				  &screen->sbuf_address,
				  rows + savelines, cols,
				  MaxRows(screen) + savelines,
d1486 8
a1493 1
	screen->visbuf = &screen->allbuf[MAX_PTRS * savelines];
d1495 1
d1499 12
a1510 11
	if (xw->misc.resizeGravity == SouthWestGravity) {
	    screen->savedlines -= move_down_by;
	    if (screen->savedlines < 0)
		screen->savedlines = 0;
	    if (screen->savedlines > screen->savelines)
		screen->savedlines = screen->savelines;
	    if (screen->topline < -screen->savedlines)
		screen->topline = -screen->savedlines;
	    set_cur_row(screen, screen->cur_row + move_down_by);
	    screen->cursorp.row += move_down_by;
	    ScrollSelection(screen, move_down_by, True);
d1512 3
a1514 2
	    if (screen->alternate)
		SwitchBufPtrs(screen);	/* put the pointers back */
d1535 1
a1535 3
    if (screen->scrollWidget)
	ResizeScrollBar(xw);

d1621 38
d1668 4
a1671 4
    target->top = (nparams > 0) ? params[0] : getMinRow(screen) + 1;
    target->left = (nparams > 1) ? params[1] : getMinCol(screen) + 1;
    target->bottom = (nparams > 2) ? params[2] : getMaxRow(screen) + 1;
    target->right = (nparams > 3) ? params[3] : getMaxCol(screen) + 1;
d1685 2
a1686 2
	   getMaxRow(screen) + 1,
	   getMaxCol(screen) + 1));
d1688 2
a1689 2
	    && target->top > getMinRow(screen)
	    && target->left > getMinCol(screen)
d1692 2
a1693 2
	    && target->top <= getMaxRow(screen) + 1
	    && target->right <= getMaxCol(screen) + 1);
d1697 2
a1698 1
 * Fills a rectangle with the given character and video-attributes.
d1701 5
a1705 1
ScrnFillRectangle(XtermWidget xw, XTermRect * target, int value, unsigned flags)
d1709 1
a1709 1
    TRACE(("filling rectangle with '%c'\n", value));
d1714 1
a1714 1
	int row;
d1719 27
a1745 2
	    TRACE(("filling %d [%d..%d]\n", row, left + 1, left + size));
	    memset(SCRN_BUF_ATTRS(screen, row) + left, attrs, size);
d1748 5
a1752 2
		bzero(SCRN_BUF_WIDEC(screen, row) + left, size);
	    });
d1785 1
a1785 1
		       params + 1,
d1790 2
a1791 2
	    unsigned size = (high * wide);
	    int row, col, n;
d1793 1
a1793 2
	    Char *attrs = TypeMallocN(Char, size);
	    Char *chars = TypeMallocN(Char, size);
d1795 1
a1795 7
#if OPT_WIDE_CHARS
	    Char *widec = TypeMallocN(Char, size);
	    if (widec == 0)
		return;
#endif
	    if (attrs == 0
		|| chars == 0)
d1804 4
a1807 6
		    n = ((1 + row - source->top) * wide) + (1 + col - source->left);
		    attrs[n] = SCRN_BUF_ATTRS(screen, row)[col] | CHARDRAWN;
		    chars[n] = SCRN_BUF_CHARS(screen, row)[col];
		    if_OPT_WIDE_CHARS(screen, {
			widec[n] = SCRN_BUF_WIDEC(screen, row)[col];
		    })
d1816 5
a1820 6
			n = ((1 + row - target.top) * wide) + (1 + col - target.left);
			SCRN_BUF_ATTRS(screen, row)[col] = attrs[n];
			SCRN_BUF_CHARS(screen, row)[col] = chars[n];
			if_OPT_WIDE_CHARS(screen, {
			    SCRN_BUF_WIDEC(screen, row)[col] = widec[n];
			})
d1824 1
a1824 5
	    free(attrs);
	    free(chars);
#if OPT_WIDE_CHARS
	    free(widec);
#endif
d1837 7
a1843 1
 * Modifies the video-attributes only - so selection is unaffected.
d1875 1
a1875 1
	    TRACE(("marking %d [%d..%d]\n", row, left + 1, right + 1));
d1898 3
d1919 3
d1934 3
d1961 1
a1961 1
 * attributes are untouched.
d1980 1
a1980 1
	    TRACE(("wiping %d [%d..%d]\n", row, left + 1, right + 1));
d1987 4
a1990 1
			SCRN_BUF_WIDEC(screen, row)[col] = '\0';
@


1.1.1.1
log
@Importing xterm 216
@
text
@@


1.1.1.2
log
@import xterm 225
@
text
@d1 1
a1 1
/* $XTermId: screen.c,v 1.210 2006/11/26 19:12:44 tom Exp $ */
d379 1
a379 1
	SetVTFont(xw, screen->menu_font_number, True, NULL);
d1664 1
a1664 1
		       params,
@


1.1.1.3
log
@import xterm 229
@
text
@d1 1
a1 1
/* $XTermId: screen.c,v 1.223 2007/07/22 20:37:55 tom Exp $ */
d55 2
a385 59
 * Clear cells, no side-effects.
 */
void
ClearCells(XtermWidget xw, int flags, unsigned len, int row, int col)
{
    if (len != 0) {
	TScreen *screen = &(xw->screen);
	flags |= TERM_COLOR_FLAGS(xw);

	memset(SCRN_BUF_CHARS(screen, row) + col, ' ', len);
	memset(SCRN_BUF_ATTRS(screen, row) + col, flags, len);

	if_OPT_EXT_COLORS(screen, {
	    memset(SCRN_BUF_FGRND(screen, row) + col,
		   xw->sgr_foreground, len);
	    memset(SCRN_BUF_BGRND(screen, row) + col,
		   xw->cur_background, len);
	});
	if_OPT_ISO_TRADITIONAL_COLORS(screen, {
	    memset(SCRN_BUF_COLOR(screen, row) + col,
		   (int) xtermColorPair(xw), len);
	});
	if_OPT_DEC_CHRSET({
	    memset(SCRN_BUF_CSETS(screen, row) + col,
		   curXtermChrSet(xw, screen->cur_row), len);
	});
	if_OPT_WIDE_CHARS(screen, {
	    int off;
	    for (off = OFF_WIDEC; off < MAX_PTRS; ++off) {
		memset(SCREEN_PTR(screen, row, off) + col, 0, len);
	    }
	});
    }
}

/*
 * Clear data in the screen-structure (no I/O).
 * Check for wide-character damage as well, clearing the damaged cells.
 */
void
ScrnClearCells(XtermWidget xw, int row, int col, unsigned len)
{
#if OPT_WIDE_CHARS
    TScreen *screen = &(xw->screen);
#endif
    int flags = 0;

    if_OPT_WIDE_CHARS(screen, {
	int kl;
	int kr;
	if (DamagedCells(screen, len, &kl, &kr, INX2ROW(screen, row), col)
	    && kr >= kl) {
	    ClearCells(xw, flags, (unsigned) (kr - kl + 1), row, kl);
	}
    });
    ClearCells(xw, flags, len, row, col);
}

/*
d402 5
a406 5
ScrnWriteText(XtermWidget xw,
	      PAIRED_CHARS(Char * str, Char * str2),
	      unsigned flags,
	      unsigned cur_fg_bg,
	      unsigned length)
d423 1
d452 2
d524 3
a526 1
	} else {
d566 2
a567 2
	memset(fbf, (int) ExtractForeground(cur_fg_bg), real_width);
	memset(fbb, (int) ExtractBackground(cur_fg_bg), real_width);
d576 5
a742 3
#define Target (data + col + n)
#define Source (data + col)

d745 1
a745 1
    int last = MaxCols(screen);
d747 6
a752 2
    int col = screen->cur_col;
    Char *data;
d755 1
a755 1
    if (last <= (int) (col + n)) {
d765 1
a765 1
    assert(last > (int) n);
d767 7
a773 18
    if_OPT_WIDE_CHARS(screen, {
	int xx = INX2ROW(screen, screen->cur_row);
	int kl;
	int kr = screen->cur_col;
	if (DamagedCells(screen, n, &kl, (int *) 0, xx, kr) && kr > kl) {
	    ClearCells(xw, 0, (unsigned) (kr - kl + 1), row, kl);
	}
	kr = screen->max_col - n + 1;
	if (DamagedCells(screen, n, &kl, (int *) 0, xx, kr) && kr > kl) {
	    ClearCells(xw, 0, (unsigned) (kr - kl + 1), row, kl);
	}
    });

    data = BUF_CHARS(sb, row);
    memmove(Target, Source, nbytes);

    data = BUF_ATTRS(sb, row);
    memmove(Target, Source, nbytes);
d775 4
d780 6
a785 4
	data = BUF_FGRND(sb, row);
	memmove(Target, Source, nbytes);
	data = BUF_BGRND(sb, row);
	memmove(Target, Source, nbytes);
d788 3
a790 2
	data = BUF_COLOR(sb, row);
	memmove(Target, Source, nbytes);
d793 3
a795 2
	data = BUF_CSETS(sb, row);
	memmove(Target, Source, nbytes);
d800 3
a802 2
	    data = BUFFER_PTR(sb, row, off);
	    memmove(Target, Source, nbytes);
a804 1
    ClearCells(xw, CHARDRAWN, n, row, col);
d806 4
a809 2
#undef Source
#undef Target
a817 3
#define Target (data + col)
#define Source (data + col + n)

d820 5
a824 4
    int last = MaxCols(screen);
    int row = screen->cur_row;
    int col = screen->cur_col;
    Char *data;
d827 1
a827 1
    if (last <= (int) (col + n)) {
d837 1
a837 13
    assert(last > (int) n);

    if_OPT_WIDE_CHARS(screen, {
	int kl;
	int kr;
	if (DamagedCells(screen, n, &kl, &kr,
			 INX2ROW(screen, screen->cur_row),
			 screen->cur_col))
	    ClearCells(xw, 0, (unsigned) (kr - kl + 1), row, kl);
    });

    data = BUF_CHARS(sb, row);
    memmove(Target, Source, nbytes);
d839 4
a842 2
    data = BUF_ATTRS(sb, row);
    memmove(Target, Source, nbytes);
d845 6
a850 4
	data = BUF_FGRND(sb, row);
	memmove(Target, Source, nbytes);
	data = BUF_BGRND(sb, row);
	memmove(Target, Source, nbytes);
d853 3
a855 2
	data = BUF_COLOR(sb, row);
	memmove(Target, Source, nbytes);
d858 3
a860 2
	data = BUF_CSETS(sb, row);
	memmove(Target, Source, nbytes);
d865 3
a867 2
	    data = BUFFER_PTR(sb, row, off);
	    memmove(Target, Source, nbytes);
a869 1
    ClearCells(xw, 0, n, row, (int) (last - n));
a870 3

#undef Source
#undef Target
d1322 1
d1325 1
d1330 18
a1347 1
	ClearCells(xw, 0, len, row, 0);
a1861 1
		    /* FIXME - use ClearCells */
@


1.1.1.4
log
@Import xterm version 232. tested by many.
@
text
@d1 1
a1 1
/* $XTermId: screen.c,v 1.234 2008/01/27 16:43:54 tom Exp $ */
d408 1
a408 1
		   curXtermChrSet(xw, row), len);
d450 1
a450 5
	if (xw->screen.keepSelection) {
	    UnhiliteSelection(xw);
	} else {
	    DisownSelection(xw);
	}
d538 1
a538 1
		&& iswide(PACK_PAIR(char1, char2, -1))) {
d545 3
a547 1
		int ch = PACK_PAIR(str, str2, 0);
d583 1
a583 1
		    && iswide(PACK_PAIR(chars, char2, -1))) {
d590 1
a590 1
		    iswide(PACK_PAIR(chars, char2, length - 1))) {
d1036 2
a1037 2
		    (PACK_PAIR(chars, widec, leftcol)) == HIDDEN_CHAR &&
		    iswide(PACK_PAIR(chars, widec, leftcol - 1))) {
d1139 1
a1139 1
	    wideness = iswide(PACK_PAIR(chars, widec, col));
d1176 2
a1177 2
		    && ((iswide(PACK_PAIR(chars, widec, col))) != wideness)
		    && !((PACK_PAIR(chars, widec, col)) == HIDDEN_CHAR))
d1212 2
a1213 2
			    int base = PACK_PAIR(chars, widec, i);
			    int combo = PACK_PAIR(com_lo, com_hi, i);
d1255 1
a1255 1
		    wideness = iswide(PACK_PAIR(chars, widec, col));
d1298 2
a1299 2
		    int base = PACK_PAIR(chars, widec, i);
		    int combo = PACK_PAIR(com_lo, com_hi, i);
a1384 4
	if_OPT_DEC_CHRSET({
	    /* clearing the whole row resets the doublesize characters */
	    SCRN_ROW_CSET(screen, row) = CSET_SWL;
	});
a1609 38
 * Rectangle parameters start from one.
 */
#define minRectRow(screen) (getMinRow(screen) + 1)
#define minRectCol(screen) (getMinCol(screen) + 1)
#define maxRectRow(screen) (getMaxRow(screen) + 1)
#define maxRectCol(screen) (getMaxCol(screen) + 1)

static int
limitedParseRow(XtermWidget xw, TScreen * screen, int row)
{
    int min_row = minRectRow(screen);
    int max_row = maxRectRow(screen);

    if (row < min_row)
	row = min_row;
    else if (row > max_row)
	row = max_row;
    return row;
}

static int
limitedParseCol(XtermWidget xw, TScreen * screen, int col)
{
    int min_col = minRectCol(screen);
    int max_col = maxRectCol(screen);

    (void) xw;
    if (col < min_col)
	col = min_col;
    else if (col > max_col)
	col = max_col;
    return col;
}

#define LimitedParse(num, func, dft) \
	func(xw, screen, (nparams > num) ? params[num] : dft)

/*
d1619 4
a1622 4
    target->top = LimitedParse(0, limitedParseRow, minRectRow(screen));
    target->left = LimitedParse(1, limitedParseCol, minRectCol(screen));
    target->bottom = LimitedParse(2, limitedParseRow, maxRectRow(screen));
    target->right = LimitedParse(3, limitedParseCol, maxRectCol(screen));
d1636 2
a1637 2
	   maxRectRow(screen),
	   maxRectCol(screen)));
d1639 2
a1640 2
	    && target->top >= minRectRow(screen)
	    && target->left >= minRectCol(screen)
d1643 2
a1644 2
	    && target->top <= maxRectRow(screen)
	    && target->right <= maxRectCol(screen));
d1648 1
a1648 2
 * Fills a rectangle with the given 8-bit character and video-attributes.
 * Colors and double-size attribute are unmodified.
d1651 1
a1651 5
ScrnFillRectangle(XtermWidget xw,
		  XTermRect * target,
		  int value,
		  unsigned flags,
		  Bool keepColors)
d1655 1
a1655 1
    TRACE(("filling rectangle with '%c' flags %#x\n", value, flags));
d1660 1
a1660 1
	int row, col;
d1665 2
a1666 27
	    TRACE(("filling %d [%d..%d]\n", row, left, left + size));

	    /*
	     * Fill attributes, preserving "protected" flag, as well as
	     * colors if asked.
	     */
	    for (col = left; col < target->right; ++col) {
		Char temp = SCRN_BUF_ATTRS(screen, row)[col];
		if (!keepColors) {
		    temp &= ~(FG_COLOR | BG_COLOR);
		}
		temp = attrs | (temp & (FG_COLOR | BG_COLOR | PROTECTED));
		temp |= CHARDRAWN;
		SCRN_BUF_ATTRS(screen, row)[col] = temp;
#if OPT_ISO_COLORS
		if (attrs & (FG_COLOR | BG_COLOR)) {
		    if_OPT_EXT_COLORS(screen, {
			SCRN_BUF_FGRND(screen, row)[col] = xw->sgr_foreground;
			SCRN_BUF_BGRND(screen, row)[col] = xw->cur_background;
		    });
		    if_OPT_ISO_TRADITIONAL_COLORS(screen, {
			SCRN_BUF_COLOR(screen, row)[col] = xtermColorPair(xw);
		    });
		}
#endif
	    }

d1669 2
a1670 5
		int off;
		for (off = OFF_WIDEC; off < MAX_PTRS; ++off) {
		    memset(SCREEN_PTR(screen, row, off) + left, 0, size);
		}
	    })
d1708 2
a1709 2
	    unsigned size = (high * wide * MAX_PTRS);
	    int row, col, n, j;
d1711 2
a1712 1
	    Char *cells = TypeMallocN(Char, size);
d1714 7
a1720 1
	    if (cells == 0)
d1729 6
a1734 4
		    n = (((1 + row - source->top) * wide)
			 + (1 + col - source->left)) * MAX_PTRS;
		    for (j = OFF_ATTRS; j < MAX_PTRS; ++j)
			cells[n + j] = SCREEN_PTR(screen, row, j)[col];
d1743 6
a1748 5
			n = (((1 + row - target.top) * wide)
			     + (1 + col - target.left)) * MAX_PTRS;
			for (j = OFF_ATTRS; j < MAX_PTRS; ++j)
			    SCREEN_PTR(screen, row, j)[col] = cells[n + j];
			SCRN_BUF_ATTRS(screen, row)[col] |= CHARDRAWN;
d1752 5
a1756 1
	    free(cells);
d1769 1
a1769 7
 * Modifies the video-attributes only - so selection (not a video attribute) is
 * unaffected.  Colors and double-size flags are unaffected as well.
 *
 * FIXME: our representation for "invisible" does not work with this operation,
 * since the attribute byte is fully-allocated for other flags.  The logic
 * is shown for INVISIBLE because it's harmless, and useful in case the
 * CHARDRAWN or PROTECTED flags are reassigned.
d1801 1
a1801 1
	    TRACE(("marking %d [%d..%d]\n", row, left, right));
a1823 3
			case 8:
			    flags ^= INVISIBLE;
			    break;
a1841 3
			case 8:
			    flags |= INVISIBLE;
			    break;
a1853 3
			case 28:
			    flags &= ~INVISIBLE;
			    break;
d1878 1
a1878 1
 * attributes (including color) are untouched.
d1897 1
a1897 1
	    TRACE(("wiping %d [%d..%d]\n", row, left, right));
d1901 1
d1905 1
a1905 4
			int off;
			for (off = OFF_WIDEC; off < MAX_PTRS; ++off) {
			    memset(SCREEN_PTR(screen, row, off) + col, 0, 1);
			}
@


