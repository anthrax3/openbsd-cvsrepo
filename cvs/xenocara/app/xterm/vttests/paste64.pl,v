head	1.4;
access;
symbols
	OPENBSD_6_0:1.4.0.8
	OPENBSD_6_0_BASE:1.4
	OPENBSD_5_9:1.4.0.6
	OPENBSD_5_9_BASE:1.4
	OPENBSD_5_8:1.4.0.4
	OPENBSD_5_8_BASE:1.4
	OPENBSD_5_7:1.4.0.2
	OPENBSD_5_7_BASE:1.4
	OPENBSD_5_6:1.3.0.2
	OPENBSD_5_6_BASE:1.3
	OPENBSD_5_5:1.2.0.16
	OPENBSD_5_5_BASE:1.2
	OPENBSD_5_4:1.2.0.14
	OPENBSD_5_4_BASE:1.2
	OPENBSD_5_3:1.2.0.12
	OPENBSD_5_3_BASE:1.2
	OPENBSD_5_2:1.2.0.10
	OPENBSD_5_2_BASE:1.2
	OPENBSD_5_1_BASE:1.2
	OPENBSD_5_1:1.2.0.8
	OPENBSD_5_0:1.2.0.6
	OPENBSD_5_0_BASE:1.2
	OPENBSD_4_9:1.2.0.2
	OPENBSD_4_9_BASE:1.2
	OPENBSD_4_8:1.2.0.4
	OPENBSD_4_8_BASE:1.2
	OPENBSD_4_7:1.1.1.1.0.12
	OPENBSD_4_7_BASE:1.1.1.1
	OPENBSD_4_6:1.1.1.1.0.10
	OPENBSD_4_6_BASE:1.1.1.1
	OPENBSD_4_5:1.1.1.1.0.8
	OPENBSD_4_5_BASE:1.1.1.1
	OPENBSD_4_4:1.1.1.1.0.6
	OPENBSD_4_4_BASE:1.1.1.1
	OPENBSD_4_3_BASE:1.1.1.1
	OPENBSD_4_3:1.1.1.1.0.4
	v232:1.1.1.1
	v229:1.1.1.1
	OPENBSD_4_2:1.1.1.1.0.2
	OPENBSD_4_2_BASE:1.1.1.1
	v225:1.1.1.1
	v216:1.1.1.1
	xterm:1.1.1;
locks; strict;
comment	@# @;


1.4
date	2015.01.18.20.24.40;	author matthieu;	state Exp;
branches;
next	1.3;
commitid	PDdlFuihcMifzxwp;

1.3
date	2014.05.09.19.56.41;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2010.03.25.22.03.51;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.26.11.11.54;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.11.26.11.11.54;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.4
log
@xterm 314. tested by naddy@@
@
text
@#!/usr/bin/env perl
# $XTermId: paste64.pl,v 1.13 2014/12/28 21:16:36 tom Exp $
# -----------------------------------------------------------------------------
# this file is part of xterm
#
# Copyright 2006,2014 by Thomas E. Dickey
#
#                         All Rights Reserved
#
# Permission is hereby granted, free of charge, to any person obtaining a
# copy of this software and associated documentation files (the
# "Software"), to deal in the Software without restriction, including
# without limitation the rights to use, copy, modify, merge, publish,
# distribute, sublicense, and/or sell copies of the Software, and to
# permit persons to whom the Software is furnished to do so, subject to
# the following conditions:
#
# The above copyright notice and this permission notice shall be included
# in all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
# OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
# MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
# IN NO EVENT SHALL THE ABOVE LISTED COPYRIGHT HOLDER(S) BE LIABLE FOR ANY
# CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
# TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
# SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
#
# Except as contained in this notice, the name(s) of the above copyright
# holders shall not be used in advertising or otherwise to promote the
# sale, use or other dealings in this Software without prior written
# authorization.
# -----------------------------------------------------------------------------
# Test the paste64 option of xterm.

use strict;
use warnings;

use Term::ReadKey;
use IO::Handle;
use MIME::Base64;

our $target = "";

sub to_hex($) {
    my $value  = $_[0];
    my $result = "";
    my $n;

    for ( $n = 0 ; $n < length($value) ; ++$n ) {
        $result .= sprintf( "%02X", ord substr( $value, $n, 1 ) );
    }
    return $result;
}

sub show_string($) {
    my $value = $_[0];
    my $n;

    my $result = "";
    for ( $n = 0 ; $n < length($value) ; $n += 1 ) {
        my $c = ord substr( $value, $n, 1 );
        if ( $c == ord '\\' ) {
            $result .= "\\\\";
        }
        elsif ( $c == 0x1b ) {
            $result .= "\\E";
        }
        elsif ( $c == 0x7f ) {
            $result .= "^?";
        }
        elsif ( $c == 32 ) {
            $result .= "\\s";
        }
        elsif ( $c < 32 ) {
            $result .= sprintf( "^%c", $c + 64 );
        }
        elsif ( $c > 128 ) {
            $result .= sprintf( "\\%03o", $c );
        }
        else {
            $result .= chr($c);
        }
    }

    printf "%s\r\n", $result;
}

sub get_reply($) {
    my $command = $_[0];
    my $reply   = "";

    printf "send: ";
    show_string($command);

    print STDOUT $command;
    autoflush STDOUT 1;
    while (1) {
        my $test = ReadKey 1;
        last if not defined $test;

        #printf "%d:%s\r\n", length($reply), to_hex($test);
        $reply .= $test;
    }
    return $reply;
}

sub get_paste() {
    my $reply = get_reply( "\x1b]52;" . $target . ";?\x1b\\" );

    printf "read: ";
    show_string($reply);

    my $data = $reply;
    $data =~ s/^\x1b]52;[[:alnum:]]*;//;
    $data =~ s/\x1b\\$//;
    printf "chop: ";
    show_string($data);

    $data = decode_base64($data);
    printf "data: ";
    show_string($data);
}

sub put_paste() {
    ReadMode 1;

    printf "data: ";
    my $data = ReadLine 0;
    chomp $data;
    ReadMode 5;

    $data = encode_base64($data);
    chomp $data;
    printf "data: ";
    show_string($data);

    my $send = "\x1b]52;" . $target . ";" . $data . "\x1b\\";

    printf "send: ";
    show_string($send);
    print STDOUT $send;
    autoflush STDOUT 1;
}

sub set_target() {
    ReadMode 1;

    printf "target: ";
    $target = ReadLine 0;
    $target =~ s/[^[:alnum:]]//g;
    ReadMode 5;
    printf "result: %s\r\n", $target;
}

ReadMode 5, 'STDIN';    # allow single-character inputs
while (1) {
    my $cmd;

    printf "\r\nCommand (? for help):";
    $cmd = ReadKey 0;
    if ( $cmd eq "?" ) {
        printf "\r\np=put selection,"
          . " g=get selection,"
          . " q=quit,"
          . " r=reset target,"
          . " s=set target\r\n";
    }
    elsif ( $cmd eq "p" ) {
        printf " ...put selection\r\n";
        put_paste();
    }
    elsif ( $cmd eq "g" ) {
        printf " ...get selection\r\n";
        get_paste();
    }
    elsif ( $cmd eq "q" ) {
        printf " ...quit\r\n";
        last;
    }
    elsif ( $cmd eq "r" ) {
        printf " ...reset\r\n";
        $target = "";
    }
    elsif ( $cmd eq "s" ) {
        printf " ...set target\r\n";
        set_target();
    }
}
ReadMode 0, 'STDIN';    # Reset tty mode before exiting
@


1.3
log
@Update to xterm 304. With help of shadchin@@

tested by ajacoutot@@ and shadchin@@
@
text
@d2 1
a2 1
# $XTermId: paste64.pl,v 1.11 2014/02/26 20:14:32 tom Exp $
d7 1
a7 1
# 
d9 1
a9 1
# 
d17 1
a17 1
# 
d20 1
a20 1
# 
d28 1
a28 1
# 
a38 1

d46 8
a53 8
	my $value = $_[0];
	my $result = "";
	my $n;

	for ( $n = 0; $n < length($value); ++$n) {
		$result .= sprintf("%02X", ord substr($value,$n,1));
	}
	return $result;
d57 2
a58 2
	my $value = $_[0];
	my $n;
d60 25
a84 19
	my $result = "";
	for ( $n = 0; $n < length($value); $n += 1) {
		my $c = ord substr($value,$n,1);
		if ( $c == ord '\\' ) {
			$result .= "\\\\";
		} elsif ( $c == 0x1b ) {
			$result .= "\\E";
		} elsif ( $c == 0x7f ) {
			$result .= "^?";
		} elsif ( $c == 32 ) {
			$result .= "\\s";
		} elsif ( $c < 32 ) {
			$result .= sprintf("^%c", $c + 64);
		} elsif ( $c > 128 ) {
			$result .= sprintf("\\%03o", $c);
		} else {
			$result .= chr($c);
		}
	}
d86 1
a86 1
	printf "%s\r\n", $result;
d90 2
a91 2
	my $command = $_[0];
	my $reply = "";
d93 2
a94 2
	printf "send: ";
	show_string($command);
d96 10
a105 9
	print STDOUT $command;
	autoflush STDOUT 1;
	while (1) {
		my $test=ReadKey 1;
		last if not defined $test;
		#printf "%d:%s\r\n", length($reply), to_hex($test);
		$reply .= $test;
	}
	return $reply;
d109 1
a109 1
	my $reply = get_reply("\x1b]52;" . $target . ";?\x1b\\");
d111 2
a112 2
	printf "read: ";
	show_string($reply);
d114 9
a122 9
	my $data = $reply;
	$data =~ s/^\x1b]52;[[:alnum:]]*;//;
	$data =~ s/\x1b\\$//;
	printf "chop: ";
	show_string($data);

        $data = decode_base64($data);
	printf "data: ";
	show_string($data);
d126 1
a126 13
	ReadMode 1;

	printf "data: ";
	my $data = ReadLine 0;
	chomp $data;
	ReadMode 5;

	$data = encode_base64($data);
	chomp $data;
	printf "data: ";
	show_string($data);

	my $send = "\x1b]52;" . $target . ";" . $data . "\x1b\\";
d128 16
a143 2
	printf "send: ";
	show_string($send);
d147 1
a147 1
	ReadMode 1;
d149 5
a153 5
	printf "target: ";
	$target = ReadLine 0;
	$target =~ s/[^[:alnum:]]//g;
	ReadMode 5;
	printf "result: %s\r\n", $target;
d156 1
a156 1
ReadMode 5, 'STDIN'; # allow single-character inputs
d158 1
a158 1
	my $cmd;
d160 29
a188 20
	printf "\r\nCommand (? for help):";
	$cmd = ReadKey 0;
	if ( $cmd eq "?" ) {
		printf "\r\np=put selection, g=get selection, q=quit, r=reset target, s=set target\r\n";
	} elsif ($cmd eq "p") {
		printf " ...put selection\r\n";
		put_paste();
	} elsif ($cmd eq "g") {
		printf " ...get selection\r\n";
		get_paste();
	} elsif ($cmd eq "q") {
		printf " ...quit\r\n";
		last;
	} elsif ($cmd eq "r") {
		printf " ...reset\r\n";
		$target = "";
	} elsif ($cmd eq "s") {
		printf " ...set target\r\n";
		set_target();
	}
d190 1
a190 1
ReadMode 0, 'STDIN'; # Reset tty mode before exiting
@


1.2
log
@Update to xterm-255. Tested by stsp@@, oga@@.
@
text
@d1 2
a2 2
#!/usr/bin/perl -w
# $XTermId: paste64.pl,v 1.10 2006/03/13 01:28:02 tom Exp $
d6 1
a6 1
# Copyright 2006 by Thomas E. Dickey
d37 2
@


1.1
log
@Initial revision
@
text
@d2 3
a4 2
# $XTermId: paste64.pl,v 1.9 2006/03/13 01:28:02 tom Exp $
# $XFree86: xc/programs/xterm/vttests/paste64.pl,v 1.1 2006/03/13 01:28:02 dickey Exp $
d6 28
a33 1
# -- Thomas Dickey (2006/3/7)
@


1.1.1.1
log
@Importing xterm 216
@
text
@@
