head	1.41;
access;
symbols
	OPENBSD_6_1_BASE:1.41
	OPENBSD_6_0:1.40.0.4
	OPENBSD_6_0_BASE:1.40
	OPENBSD_5_9:1.40.0.2
	OPENBSD_5_9_BASE:1.40
	OPENBSD_5_8:1.38.0.4
	OPENBSD_5_8_BASE:1.38
	OPENBSD_5_7:1.38.0.2
	OPENBSD_5_7_BASE:1.38
	OPENBSD_5_6:1.35.0.2
	OPENBSD_5_6_BASE:1.35
	OPENBSD_5_5:1.33.0.2
	OPENBSD_5_5_BASE:1.33
	OPENBSD_5_4:1.30.0.2
	OPENBSD_5_4_BASE:1.30
	OPENBSD_5_3:1.28.0.2
	OPENBSD_5_3_BASE:1.28
	OPENBSD_5_2:1.27.0.2
	OPENBSD_5_2_BASE:1.27
	OPENBSD_5_1_BASE:1.25
	OPENBSD_5_1:1.25.0.2
	OPENBSD_5_0:1.21.0.2
	OPENBSD_5_0_BASE:1.21
	OPENBSD_4_9:1.19.0.2
	OPENBSD_4_9_BASE:1.19
	OPENBSD_4_8:1.15.0.4
	OPENBSD_4_8_BASE:1.15
	OPENBSD_4_7:1.13.0.2
	OPENBSD_4_7_BASE:1.13
	OPENBSD_4_6:1.10.0.2
	OPENBSD_4_6_BASE:1.10
	OPENBSD_4_5:1.8.0.2
	OPENBSD_4_5_BASE:1.8
	OPENBSD_4_4:1.5.0.4
	OPENBSD_4_4_BASE:1.5
	OPENBSD_4_3_BASE:1.5
	OPENBSD_4_3:1.5.0.2
	v232:1.1.1.4
	v229:1.1.1.3
	OPENBSD_4_2:1.3.0.2
	OPENBSD_4_2_BASE:1.3
	v225:1.1.1.2
	v216:1.1.1.1
	xterm:1.1.1;
locks; strict;
comment	@ * @;


1.41
date	2016.08.07.21.27.36;	author matthieu;	state Exp;
branches;
next	1.40;
commitid	psxxjI5z4Vpv2LL4;

1.40
date	2016.01.13.20.40.08;	author matthieu;	state Exp;
branches;
next	1.39;
commitid	by9Wu4LDAgU65dBU;

1.39
date	2015.09.05.14.11.46;	author matthieu;	state Exp;
branches;
next	1.38;
commitid	YVUODLQ4QcYTuGkb;

1.38
date	2015.01.18.20.24.40;	author matthieu;	state Exp;
branches;
next	1.37;
commitid	PDdlFuihcMifzxwp;

1.37
date	2014.12.18.20.16.55;	author matthieu;	state Exp;
branches;
next	1.36;
commitid	pCMhkpVdt9Oe52hU;

1.36
date	2014.10.05.16.39.19;	author matthieu;	state Exp;
branches;
next	1.35;
commitid	0wVJ6bWh03LWbUdn;

1.35
date	2014.07.14.08.30.11;	author matthieu;	state Exp;
branches;
next	1.34;
commitid	EnwNNUjlkdrocnMa;

1.34
date	2014.05.09.19.56.41;	author matthieu;	state Exp;
branches;
next	1.33;

1.33
date	2014.02.14.19.40.03;	author matthieu;	state Exp;
branches;
next	1.32;

1.32
date	2014.01.02.15.14.50;	author matthieu;	state Exp;
branches;
next	1.31;

1.31
date	2013.08.26.20.06.14;	author matthieu;	state Exp;
branches;
next	1.30;

1.30
date	2013.06.02.19.55.50;	author matthieu;	state Exp;
branches;
next	1.29;

1.29
date	2013.03.09.14.45.38;	author matthieu;	state Exp;
branches;
next	1.28;

1.28
date	2013.01.04.16.40.18;	author matthieu;	state Exp;
branches;
next	1.27;

1.27
date	2012.06.07.20.20.24;	author matthieu;	state Exp;
branches;
next	1.26;

1.26
date	2012.04.14.09.02.46;	author matthieu;	state Exp;
branches;
next	1.25;

1.25
date	2011.11.16.21.14.25;	author matthieu;	state Exp;
branches;
next	1.24;

1.24
date	2011.09.17.11.51.57;	author matthieu;	state Exp;
branches;
next	1.23;

1.23
date	2011.08.28.17.40.55;	author matthieu;	state Exp;
branches;
next	1.22;

1.22
date	2011.08.18.19.47.42;	author matthieu;	state Exp;
branches;
next	1.21;

1.21
date	2011.06.07.19.21.06;	author matthieu;	state Exp;
branches;
next	1.20;

1.20
date	2011.03.07.20.41.27;	author matthieu;	state Exp;
branches;
next	1.19;

1.19
date	2010.11.29.20.10.09;	author matthieu;	state Exp;
branches;
next	1.18;

1.18
date	2010.10.23.19.14.52;	author matthieu;	state Exp;
branches;
next	1.17;

1.17
date	2010.10.05.19.37.23;	author matthieu;	state Exp;
branches;
next	1.16;

1.16
date	2010.08.22.13.38.11;	author matthieu;	state Exp;
branches;
next	1.15;

1.15
date	2010.05.08.12.20.47;	author matthieu;	state Exp;
branches;
next	1.14;

1.14
date	2010.03.25.22.03.51;	author matthieu;	state Exp;
branches;
next	1.13;

1.13
date	2009.10.31.14.11.57;	author matthieu;	state Exp;
branches;
next	1.12;

1.12
date	2009.09.19.00.03.36;	author sthen;	state Exp;
branches;
next	1.11;

1.11
date	2009.09.05.15.58.09;	author matthieu;	state Exp;
branches;
next	1.10;

1.10
date	2009.04.04.15.10.45;	author matthieu;	state Exp;
branches;
next	1.9;

1.9
date	2009.03.09.22.13.04;	author matthieu;	state Exp;
branches;
next	1.8;

1.8
date	2009.01.06.20.10.21;	author matthieu;	state Exp;
branches;
next	1.7;

1.7
date	2008.09.23.19.08.55;	author matthieu;	state Exp;
branches;
next	1.6;

1.6
date	2008.08.25.18.05.57;	author matthieu;	state Exp;
branches;
next	1.5;

1.5
date	2008.02.16.09.40.00;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2007.08.25.18.58.42;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2007.06.15.19.34.50;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2006.11.26.15.48.06;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.26.11.11.45;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.11.26.11.11.45;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2007.06.15.19.30.38;	author matthieu;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2007.08.25.18.54.12;	author matthieu;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2008.02.16.09.35.23;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.41
log
@Update to xterm-325. Testing by krw@@, shadchin@@ and naddy@@. Thanks
@
text
@/* $XTermId: xterm.h,v 1.765 2016/05/29 18:34:09 tom Exp $ */

/*
 * Copyright 1999-2015,2016 by Thomas E. Dickey
 *
 *                         All Rights Reserved
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 *
 * The above copyright notice and this permission notice shall be included
 * in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
 * IN NO EVENT SHALL THE ABOVE LISTED COPYRIGHT HOLDER(S) BE LIABLE FOR ANY
 * CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
 * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
 * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 *
 * Except as contained in this notice, the name(s) of the above copyright
 * holders shall not be used in advertising or otherwise to promote the
 * sale, use or other dealings in this Software without prior written
 * authorization.
 */

/*
 * Common/useful definitions for XTERM application.
 *
 * This is also where we put the fallback definitions if we do not build using
 * the configure script.
 */
#ifndef included_xterm_h
#define included_xterm_h
/* *INDENT-OFF* */

#ifdef HAVE_CONFIG_H
#include <xtermcfg.h>
#endif

#ifndef GCC_PRINTFLIKE
#define GCC_PRINTFLIKE(f,n)	/* nothing */
#endif

#ifndef GCC_UNUSED
#define GCC_UNUSED		/* nothing */
#endif

#ifndef GCC_NORETURN
#define GCC_NORETURN		/* nothing */
#endif

#if defined(__GNUC__) && defined(_FORTIFY_SOURCE)
#define USE_IGNORE_RC
#define IGNORE_RC(func) ignore_unused = (int) func
#else
#define IGNORE_RC(func) (void) func
#endif /* gcc workarounds */

#undef bcopy
#include <X11/Xos.h>

#ifndef HAVE_CONFIG_H

#define HAVE_LIB_XAW 1

#ifdef CSRG_BASED
/* Get definition of BSD */
#include <sys/param.h>
#endif

#ifndef DFT_TERMTYPE
#define DFT_TERMTYPE "xterm"
#endif

#ifndef X_NOT_POSIX
#define HAVE_WAITPID 1
#define HAVE_SYS_WAIT_H 1
#define HAVE_UNISTD_H 1
#endif

#define HAVE_STDLIB_H 1

#if defined(sun)
/* errno is declared in <errno.h> */
#else
#define DECL_ERRNO 1
#endif

#undef DECL_PTSNAME		/* ptsname() is normally in stdlib.h */

#ifndef NOPUTENV
#define HAVE_PUTENV 1
#endif

#if defined(CSRG_BASED) || defined(__GNU__) || defined(__minix)
#define USE_POSIX_TERMIOS 1
#endif

#ifdef __FreeBSD__
#if __FreeBSD_version >= 900000	
#define USE_SYSV_UTMP 1
#define UTMPX_FOR_UTMP 1
#define HAVE_UTMP_UT_HOST 1
#define HAVE_UTMP_UT_XTIME 1
#define ut_name ut_user
#define ut_xtime ut_tv.tv_sec
#endif
#endif

#ifdef __NetBSD__
#if __NetBSD_Version__ >= 106030000	/* 1.6C */
#define BSD_UTMPX 1
#define ut_xtime ut_tv.tv_sec
#endif
#endif

#if defined(hpux) && !defined(__hpux)
#define __hpux 1		/* HPUX 11.0 does not define this */
#endif

#if !defined(__SCO__) && (defined(SCO) || defined(sco) || defined(SCO325))
#define __SCO__ 1
#endif

#ifdef USE_POSIX_TERMIOS
#define HAVE_TERMIOS_H 1
#define HAVE_TCGETATTR 1
#endif

#if defined(__SCO__) || defined(__UNIXWARE__) || defined(__minix)
#define USE_TERMCAP 1
#endif

#if defined(UTMP)
#define HAVE_UTMP 1
#endif

#if (defined(__MVS__) || defined(SVR4) || defined(__SCO__) || defined(BSD_UTMPX)) && !defined(__CYGWIN__)
#define UTMPX_FOR_UTMP 1
#endif

#if !defined(ISC) && !defined(__QNX__)
#define HAVE_UTMP_UT_HOST 1
#endif

#if defined(UTMPX_FOR_UTMP) && !(defined(__MVS__) || defined(__hpux) || defined(__FreeBSD__))
#define HAVE_UTMP_UT_SESSION 1
#endif

#if !(defined(linux) && (!defined(__GLIBC__) || (__GLIBC__ < 2))) && !defined(SVR4) && !defined(__FreeBSD__)
#define ut_xstatus ut_exit.e_exit
#endif

#if defined(SVR4) || defined(__SCO__) || defined(BSD_UTMPX) || (defined(linux) && defined(__GLIBC__) && (__GLIBC__ >= 2) && !(defined(__powerpc__) && (__GLIBC__ == 2) && (__GLIBC_MINOR__ == 0)))
#define HAVE_UTMP_UT_XTIME 1
#endif

#if defined(linux) || defined(__CYGWIN__)
#define USE_LASTLOG
#define HAVE_LASTLOG_H
#define USE_STRUCT_LASTLOG
#elif defined(BSD) && (BSD >= 199103)
#ifdef BSD_UTMPX
#define USE_LASTLOGX
#elif defined(USE_SYSV_UTMP)
#else
#define USE_LASTLOG
#define USE_STRUCT_LASTLOG
#endif
#endif

#if defined(__OpenBSD__)
#define USE_UTMP_SETGID True
#define DEFDELETE_DEL True
#define DEF_BACKARO_ERASE True
#define DEF_INITIAL_ERASE True
#define SIG_ATOMIC_T volatile sig_atomic_t
#endif

#if defined(__SCO__) || defined(__UNIXWARE__)
#define DEFDELETE_DEL True
#define OPT_SCO_FUNC_KEYS 1
#endif

#if defined(__SCO__) || defined(SVR4) || defined(_POSIX_SOURCE) || defined(__QNX__) || defined(__hpux) || (defined(BSD) && (BSD >= 199103)) || defined(__CYGWIN__)
#define USE_POSIX_WAIT
#endif

#if defined(AIXV3) || defined(CRAY) || defined(__SCO__) || defined(SVR4) || (defined(SYSV) && defined(i386)) || defined(__MVS__) || defined(__hpux) || defined(__osf__) || defined(linux) || defined(macII) || defined(BSD_UTMPX)
#define USE_SYSV_UTMP
#endif

#if defined(__GNU__) || defined(__MVS__) || defined(__osf__)
#define USE_TTY_GROUP
#endif

#if defined(__CYGWIN__)
#define HAVE_NCURSES_TERM_H 1
#endif

#ifdef __osf__
#define TTY_GROUP_NAME "terminal"
#endif

#if defined(__MVS__)
#undef ut_xstatus
#define ut_name ut_user
#define ut_xstatus ut_exit.ut_e_exit
#define ut_xtime ut_tv.tv_sec
#endif

#if defined(ut_xstatus)
#define HAVE_UTMP_UT_XSTATUS 1
#endif

#if defined(XKB)
#define HAVE_XKB_BELL_EXT 1
#endif

#if (defined(SVR4) && !defined(__CYGWIN__)) || defined(linux) || (defined(BSD) && (BSD >= 199103))
#define HAVE_POSIX_SAVED_IDS
#endif

#if defined(linux) || defined(__GLIBC__) || (defined(SYSV) && (defined(CRAY) || defined(macII) || defined(__hpux) || defined(__osf__) || defined(__sgi))) || !(defined(SYSV) || defined(__QNX__) || defined(VMS) || defined(__INTERIX))
#define HAVE_INITGROUPS
#endif

#endif /* HAVE_CONFIG_H */

#ifndef HAVE_X11_DECKEYSYM_H
#define HAVE_X11_DECKEYSYM_H 1
#endif

#ifndef HAVE_X11_SUNKEYSYM_H
#define HAVE_X11_SUNKEYSYM_H 1
#endif

#ifndef HAVE_X11_XF86KEYSYM_H
#define HAVE_X11_XF86KEYSYM_H 0
#endif

/***====================================================================***/

/* if compiling with gcc -ansi -pedantic, we must fix POSIX definitions */
#if defined(SVR4) && defined(sun)
#ifndef __EXTENSIONS__
#define __EXTENSIONS__ 1
#endif
#ifndef _POSIX_C_SOURCE
#define _POSIX_C_SOURCE 1
#endif
#endif

/***====================================================================***/

#ifdef HAVE_STDLIB_H
#include <stdlib.h>
#else
extern char *calloc();
extern char *getenv();
extern char *malloc();
extern char *realloc();
extern void exit();
extern void free();
#endif

#ifdef HAVE_UNISTD_H
#include <unistd.h>
#endif

#ifdef HAVE_SYS_WAIT_H
#include <sys/wait.h>
#endif

#include <errno.h>
#if defined(DECL_ERRNO) && !defined(errno)
extern int errno;
#endif

/*
 * FIXME:  Toggling logging from xterm hangs under Linux 2.0.29 with libc5 if
 * we use 'waitpid()', while 'wait()' seems to work properly.
 */
#ifdef linux
#undef HAVE_WAITPID
#endif

#ifndef OPT_WIDE_CHARS
#define OPT_WIDE_CHARS 0
#endif

#if OPT_WIDE_CHARS
#define HIDDEN_CHAR 0xffff
#endif

/***====================================================================***/

#define PROTO_XT_ACTIONS_ARGS \
	(Widget w, XEvent *event, String *params, Cardinal *num_params)

#define PROTO_XT_CALLBACK_ARGS \
	(Widget gw, XtPointer closure, XtPointer data)

#define PROTO_XT_CVT_SELECT_ARGS \
	(Widget w, Atom *selection, Atom *target, Atom *type, XtPointer *value, unsigned long *length, int *format)

#define PROTO_XT_EV_HANDLER_ARGS \
	(Widget w, XtPointer closure, XEvent *event, Boolean *cont)

#define PROTO_XT_SEL_CB_ARGS \
	(Widget w, XtPointer client_data, Atom *selection, Atom *type, XtPointer value, unsigned long *length, int *format)

#include <ptyx.h>

#if (XtSpecificationRelease >= 6) && !defined(NO_XPOLL_H) && !defined(sun)
#include <X11/Xpoll.h>
#define USE_XPOLL_H 1
#else
#define Select(n,r,w,e,t) select(n,(fd_set*)r,(fd_set*)w,(fd_set*)e,(struct timeval *)t)
#define XFD_COPYSET(src,dst) memcpy((dst)->fds_bits, (src)->fds_bits, sizeof(fd_set))
#if defined(__MVS__) && !defined(TIME_WITH_SYS_TIME)
#define TIME_WITH_SYS_TIME
#endif
#endif

#ifdef TIME_WITH_SYS_TIME
# include <sys/time.h>
# include <time.h>
#else
# ifdef HAVE_SYS_TIME_H
#  include <sys/time.h>
# else
#  include <time.h>
# endif
#endif

/* these may be needed for sig_atomic_t */
#include <sys/types.h>
#include <signal.h>

#ifdef USE_SYS_SELECT_H

#if defined(USE_XPOLL_H) && defined(AIXV3) && defined(NFDBITS)
#undef NFDBITS			/* conflict between X11/Xpoll.h and sys/select.h */
#endif

#include <sys/select.h>

#endif /* USE_SYS_SELECT_H */

#include <setjmp.h>

#if !defined(VMS) && !(defined(linux) && defined(__USE_GNU)) && !defined(__hpux) && !defined(_ALL_SOURCE) && !defined(__osf__)
extern char **environ;
#endif

#ifndef _Xconst
#define _Xconst const		/* Solaris 7 workaround */
#endif /* _Xconst */

#define XK_Fn(n)	(XK_F1 + (n) - 1)

#define Maybe		2

#define ALLOC_STRING(name) \
	if (name != 0) \
	    name = x_strdup(name)
#define FREE_STRING(name) \
	    free_string(name)

/* strftime format and length of the result */
#define FMT_TIMESTAMP ".%Y.%m.%d.%H.%M.%S"
#define LEN_TIMESTAMP sizeof(".YYYY.MM.DD.hh.mm.ss")

/***====================================================================***/

#define XtNallowBoldFonts	"allowBoldFonts"
#define XtNallowC1Printable	"allowC1Printable"
#define XtNallowColorOps	"allowColorOps"
#define XtNallowFontOps		"allowFontOps"
#define XtNallowPasteControls	"allowPasteControls"
#define XtNallowScrollLock	"allowScrollLock"
#define XtNallowSendEvents	"allowSendEvents"
#define XtNallowTcapOps		"allowTcapOps"
#define XtNallowTitleOps	"allowTitleOps"
#define XtNallowWindowOps	"allowWindowOps"
#define XtNaltIsNotMeta		"altIsNotMeta"
#define XtNaltSendsEscape	"altSendsEscape"
#define XtNalternateScroll	"alternateScroll"
#define XtNalwaysBoldMode	"alwaysBoldMode"
#define XtNalwaysHighlight	"alwaysHighlight"
#define XtNalwaysUseMods	"alwaysUseMods"
#define XtNanswerbackString	"answerbackString"
#define XtNappcursorDefault	"appcursorDefault"
#define XtNappkeypadDefault	"appkeypadDefault"
#define XtNassumeAllChars	"assumeAllChars"
#define XtNautoWrap		"autoWrap"
#define XtNawaitInput		"awaitInput"
#define XtNbackarrowKey		"backarrowKey"
#define XtNbellIsUrgent		"bellIsUrgent"
#define XtNbellOnReset		"bellOnReset"
#define XtNbellSuppressTime	"bellSuppressTime"
#define XtNboldColors		"boldColors"
#define XtNboldFont		"boldFont"
#define XtNboldMode		"boldMode"
#define XtNbrokenLinuxOSC	"brokenLinuxOSC"
#define XtNbrokenSelections	"brokenSelections"
#define XtNbrokenStringTerm	"brokenStringTerm"
#define XtNc132			"c132"
#define XtNcacheDoublesize	"cacheDoublesize"
#define XtNcdXtraScroll		"cdXtraScroll"
#define XtNcharClass		"charClass"
#define XtNcjkWidth		"cjkWidth"
#define XtNcolorAttrMode	"colorAttrMode"
#define XtNcolorBDMode		"colorBDMode"
#define XtNcolorBLMode		"colorBLMode"
#define XtNcolorITMode		"colorITMode"
#define XtNcolorMode		"colorMode"
#define XtNcolorRVMode		"colorRVMode"
#define XtNcolorULMode		"colorULMode"
#define XtNcombiningChars	"combiningChars"
#define XtNctrlFKeys		"ctrlFKeys"
#define XtNcurses		"curses"
#define XtNcursorBlink		"cursorBlink"
#define XtNcursorColor		"cursorColor"
#define XtNcursorOffTime	"cursorOffTime"
#define XtNcursorOnTime		"cursorOnTime"
#define XtNcursorUnderLine	"cursorUnderLine"
#define XtNcutNewline		"cutNewline"
#define XtNcutToBeginningOfLine	"cutToBeginningOfLine"
#define XtNdecTerminalID	"decTerminalID"
#define XtNdefaultString	"defaultString"
#define XtNdeleteIsDEL		"deleteIsDEL"
#define XtNdisallowedColorOps	"disallowedColorOps"
#define XtNdisallowedFontOps	"disallowedFontOps"
#define XtNdisallowedTcapOps	"disallowedTcapOps"
#define XtNdisallowedWindowOps	"disallowedWindowOps"
#define XtNdynamicColors	"dynamicColors"
#define XtNeightBitControl	"eightBitControl"
#define XtNeightBitInput	"eightBitInput"
#define XtNeightBitMeta		"eightBitMeta"
#define XtNeightBitOutput	"eightBitOutput"
#define XtNeightBitSelectTypes	"eightBitSelectTypes"
#define XtNfaceName		"faceName"
#define XtNfaceNameDoublesize	"faceNameDoublesize"
#define XtNfaceSize		"faceSize"
#define XtNfastScroll		"fastScroll"
#define XtNfont1		"font1"
#define XtNfont2		"font2"
#define XtNfont3		"font3"
#define XtNfont4		"font4"
#define XtNfont5		"font5"
#define XtNfont6		"font6"
#define XtNfontDoublesize	"fontDoublesize"
#define XtNfontStyle		"fontStyle"
#define XtNfontWarnings		"fontWarnings"
#define XtNforceBoxChars	"forceBoxChars"
#define XtNforcePackedFont	"forcePackedFont"
#define XtNformatOtherKeys	"formatOtherKeys"
#define XtNfreeBoldBox		"freeBoldBox"
#define XtNfullscreen		"fullscreen"
#define XtNhighlightColor	"highlightColor"
#define XtNhighlightColorMode	"highlightColorMode"
#define XtNhighlightReverse	"highlightReverse"
#define XtNhighlightSelection	"highlightSelection"
#define XtNhighlightTextColor	"highlightTextColor"
#define XtNhpLowerleftBugCompat	"hpLowerleftBugCompat"
#define XtNi18nSelections	"i18nSelections"
#define XtNiconHint		"iconHint"
#define XtNinitialFont		"initialFont"
#define XtNinternalBorder	"internalBorder"
#define XtNitalicULMode		"italicULMode"
#define XtNjumpScroll		"jumpScroll"
#define XtNkeepClipboard	"keepClipboard"
#define XtNkeepSelection	"keepSelection"
#define XtNkeyboardDialect	"keyboardDialect"
#define XtNlimitResize		"limitResize"
#define XtNlocale		"locale"
#define XtNlocaleFilter		"localeFilter"
#define XtNlogFile		"logFile"
#define XtNlogInhibit		"logInhibit"
#define XtNlogging		"logging"
#define XtNloginShell		"loginShell"
#define XtNmarginBell		"marginBell"
#define XtNmaximized		"maximized"
#define XtNmaxGraphicSize	"maxGraphicSize"
#define XtNmenuBar		"menuBar"
#define XtNmenuHeight		"menuHeight"
#define XtNmetaSendsEscape	"metaSendsEscape"
#define XtNmkSamplePass		"mkSamplePass"
#define XtNmkSampleSize		"mkSampleSize"
#define XtNmkWidth		"mkWidth"
#define XtNmodifyCursorKeys	"modifyCursorKeys"
#define XtNmodifyFunctionKeys	"modifyFunctionKeys"
#define XtNmodifyKeyboard	"modifyKeyboard"
#define XtNmodifyKeypadKeys	"modifyKeypadKeys"
#define XtNmodifyOtherKeys	"modifyOtherKeys"
#define XtNmodifyStringKeys	"modifyStringKeys"
#define XtNmultiClickTime	"multiClickTime"
#define XtNmultiScroll		"multiScroll"
#define XtNnMarginBell		"nMarginBell"
#define XtNnumColorRegisters	"numColorRegisters"
#define XtNnumLock		"numLock"
#define XtNoldXtermFKeys	"oldXtermFKeys"
#define XtNpointerColor		"pointerColor"
#define XtNpointerColorBackground "pointerColorBackground"
#define XtNpointerMode		"pointerMode"
#define XtNpointerShape		"pointerShape"
#define XtNpopOnBell		"popOnBell"
#define XtNprecompose		"precompose"
#define XtNprintAttributes	"printAttributes"
#define XtNprinterAutoClose	"printerAutoClose"
#define XtNprinterCommand	"printerCommand"
#define XtNprinterControlMode	"printerControlMode"
#define XtNprinterExtent	"printerExtent"
#define XtNprinterFormFeed	"printerFormFeed"
#define XtNprinterNewLine	"printerNewLine"
#define XtNprivateColorRegisters "privateColorRegisters"
#define XtNquietGrab		"quietGrab"
#define XtNregisDefaultFont	"regisDefaultFont"
#define XtNregisScreenSize	"regisScreenSize"
#define XtNrenderFont		"renderFont"
#define XtNresizeGravity	"resizeGravity"
#define XtNretryInputMethod	"retryInputMethod"
#define XtNreverseWrap		"reverseWrap"
#define XtNrightScrollBar	"rightScrollBar"
#define XtNsaveLines		"saveLines"
#define XtNscaleHeight		"scaleHeight"
#define XtNscrollBar		"scrollBar"
#define XtNscrollBarBorder	"scrollBarBorder"
#define XtNscrollKey		"scrollKey"
#define XtNscrollLines		"scrollLines"
#define XtNscrollPos		"scrollPos"
#define XtNscrollTtyOutput	"scrollTtyOutput"
#define XtNselectToClipboard	"selectToClipboard"
#define XtNshiftFonts		"shiftFonts"
#define XtNshowBlinkAsBold	"showBlinkAsBold"
#define XtNshowMissingGlyphs	"showMissingGlyphs"
#define XtNshowWrapMarks	"showWrapMarks"
#define XtNsignalInhibit	"signalInhibit"
#define XtNsixelScrolling	"sixelScrolling"
#define XtNsixelScrollsRight	"sixelScrollsRight"
#define XtNtekGeometry		"tekGeometry"
#define XtNtekInhibit		"tekInhibit"
#define XtNtekSmall		"tekSmall"
#define XtNtekStartup		"tekStartup"
#define XtNtiXtraScroll		"tiXtraScroll"
#define XtNtiteInhibit		"titeInhibit"
#define XtNtitleModes		"titleModes"
#define XtNtoolBar		"toolBar"
#define XtNtrimSelection	"trimSelection"
#define XtNunderLine		"underLine"
#define XtNuseClipping		"useClipping"
#define XtNutf8			"utf8"
#define XtNutf8Fonts		"utf8Fonts"
#define XtNutf8Latin1		"utf8Latin1"
#define XtNutf8SelectTypes	"utf8SelectTypes"
#define XtNutf8Title		"utf8Title"
#define XtNveryBoldColors	"veryBoldColors"
#define XtNvisualBell		"visualBell"
#define XtNvisualBellDelay	"visualBellDelay"
#define XtNvisualBellLine	"visualBellLine"
#define XtNvt100Graphics	"vt100Graphics"
#define XtNwideBoldFont		"wideBoldFont"
#define XtNwideChars		"wideChars"
#define XtNwideFont		"wideFont"
#define XtNximFont		"ximFont"
#define XtNxmcAttributes	"xmcAttributes"
#define XtNxmcGlitch		"xmcGlitch"
#define XtNxmcInline		"xmcInline"
#define XtNxmcMoveSGR		"xmcMoveSGR"

#define XtCAllowBoldFonts	"AllowBoldFonts"
#define XtCAllowC1Printable	"AllowC1Printable"
#define XtCAllowColorOps	"AllowColorOps"
#define XtCAllowFontOps		"AllowFontOps"
#define XtCAllowPasteControls	"AllowPasteControls"
#define XtCAllowScrollLock	"AllowScrollLock"
#define XtCAllowSendEvents	"AllowSendEvents"
#define XtCAllowTcapOps		"AllowTcapOps"
#define XtCAllowTitleOps	"AllowTitleOps"
#define XtCAllowWindowOps	"AllowWindowOps"
#define XtCAltIsNotMeta		"AltIsNotMeta"
#define XtCAltSendsEscape	"AltSendsEscape"
#define XtCAlwaysBoldMode	"AlwaysBoldMode"
#define XtCAlwaysHighlight	"AlwaysHighlight"
#define XtCAlwaysUseMods	"AlwaysUseMods"
#define XtCAnswerbackString	"AnswerbackString"
#define XtCAppcursorDefault	"AppcursorDefault"
#define XtCAppkeypadDefault	"AppkeypadDefault"
#define XtCAssumeAllChars	"AssumeAllChars"
#define XtCAutoWrap		"AutoWrap"
#define XtCAwaitInput		"AwaitInput"
#define XtCBackarrowKey		"BackarrowKey"
#define XtCBellIsUrgent		"BellIsUrgent"
#define XtCBellOnReset		"BellOnReset"
#define XtCBellSuppressTime	"BellSuppressTime"
#define XtCBoldFont		"BoldFont"
#define XtCBoldMode		"BoldMode"
#define XtCBrokenLinuxOSC	"BrokenLinuxOSC"
#define XtCBrokenSelections	"BrokenSelections"
#define XtCBrokenStringTerm	"BrokenStringTerm"
#define XtCC132			"C132"
#define XtCCacheDoublesize	"CacheDoublesize"
#define XtCCdXtraScroll		"CdXtraScroll"
#define XtCCharClass		"CharClass"
#define XtCCjkWidth		"CjkWidth"
#define XtCColorAttrMode	"ColorAttrMode"
#define XtCColorMode		"ColorMode"
#define XtCColumn		"Column"
#define XtCCombiningChars	"CombiningChars"
#define XtCCtrlFKeys		"CtrlFKeys"
#define XtCCurses		"Curses"
#define XtCCursorBlink		"CursorBlink"
#define XtCCursorOffTime	"CursorOffTime"
#define XtCCursorOnTime		"CursorOnTime"
#define XtCCursorUnderLine	"CursorUnderLine"
#define XtCCutNewline		"CutNewline"
#define XtCCutToBeginningOfLine	"CutToBeginningOfLine"
#define XtCDecTerminalID	"DecTerminalID"
#define XtCDefaultString	"DefaultString"
#define XtCDeleteIsDEL		"DeleteIsDEL"
#define XtCDisallowedColorOps	"DisallowedColorOps"
#define XtCDisallowedFontOps	"DisallowedFontOps"
#define XtCDisallowedTcapOps	"DisallowedTcapOps"
#define XtCDisallowedWindowOps	"DisallowedWindowOps"
#define XtCDynamicColors	"DynamicColors"
#define XtCEightBitControl	"EightBitControl"
#define XtCEightBitInput	"EightBitInput"
#define XtCEightBitMeta		"EightBitMeta"
#define XtCEightBitOutput	"EightBitOutput"
#define XtCEightBitSelectTypes	"EightBitSelectTypes"
#define XtCFaceName		"FaceName"
#define XtCFaceNameDoublesize	"FaceNameDoublesize"
#define XtCFaceSize		"FaceSize"
#define XtCFastScroll		"FastScroll"
#define XtCFont1		"Font1"
#define XtCFont2		"Font2"
#define XtCFont3		"Font3"
#define XtCFont4		"Font4"
#define XtCFont5		"Font5"
#define XtCFont6		"Font6"
#define XtCFontDoublesize	"FontDoublesize"
#define XtCFontStyle		"FontStyle"
#define XtCFontWarnings		"FontWarnings"
#define XtCForceBoxChars	"ForceBoxChars"
#define XtCForcePackedFont	"ForcePackedFont"
#define XtCFormatOtherKeys	"FormatOtherKeys"
#define XtCFreeBoldBox		"FreeBoldBox"
#define XtCFullscreen		"Fullscreen"
#define XtCHighlightColorMode	"HighlightColorMode"
#define XtCHighlightReverse	"HighlightReverse"
#define XtCHighlightSelection	"HighlightSelection"
#define XtCHpLowerleftBugCompat	"HpLowerleftBugCompat"
#define XtCI18nSelections	"I18nSelections"
#define XtCIconHint		"IconHint"
#define XtCInitialFont		"InitialFont"
#define XtCJumpScroll		"JumpScroll"
#define XtCKeepClipboard	"KeepClipboard"
#define XtCKeepSelection	"KeepSelection"
#define XtCKeyboardDialect	"KeyboardDialect"
#define XtCLimitResize		"LimitResize"
#define XtCLocale		"Locale"
#define XtCLocaleFilter		"LocaleFilter"
#define XtCLogInhibit		"LogInhibit"
#define XtCLogfile		"Logfile"
#define XtCLogging		"Logging"
#define XtCLoginShell		"LoginShell"
#define XtCMarginBell		"MarginBell"
#define XtCMaximized		"Maximized"
#define XtCMaxGraphicSize	"MaxGraphicSize"
#define XtCMenuBar		"MenuBar"
#define XtCMenuHeight		"MenuHeight"
#define XtCMetaSendsEscape	"MetaSendsEscape"
#define XtCMkSamplePass		"MkSamplePass"
#define XtCMkSampleSize		"MkSampleSize"
#define XtCMkWidth		"MkWidth"
#define XtCModifyCursorKeys	"ModifyCursorKeys"
#define XtCModifyFunctionKeys	"ModifyFunctionKeys"
#define XtCModifyKeyboard	"ModifyKeyboard"
#define XtCModifyKeypadKeys	"ModifyKeypadKeys"
#define XtCModifyOtherKeys	"ModifyOtherKeys"
#define XtCModifyStringKeys	"ModifyStringKeys"
#define XtCMultiClickTime	"MultiClickTime"
#define XtCMultiScroll		"MultiScroll"
#define XtCNumColorRegisters	"NumColorRegisters"
#define XtCNumLock		"NumLock"
#define XtCOldXtermFKeys	"OldXtermFKeys"
#define XtCPointerMode		"PointerMode"
#define XtCPopOnBell		"PopOnBell"
#define XtCPrecompose		"Precompose"
#define XtCPrintAttributes	"PrintAttributes"
#define XtCPrinterAutoClose	"PrinterAutoClose"
#define XtCPrinterCommand	"PrinterCommand"
#define XtCPrinterControlMode	"PrinterControlMode"
#define XtCPrinterExtent	"PrinterExtent"
#define XtCPrinterFormFeed	"PrinterFormFeed"
#define XtCPrinterNewLine	"PrinterNewLine"
#define XtCPrivateColorRegisters "PrivateColorRegisters"
#define XtCQuietGrab		"QuietGrab"
#define XtCRegisDefaultFont	"RegisDefaultFont"
#define XtCRegisScreenSize	"RegisScreenSize"
#define XtCRenderFont		"RenderFont"
#define XtCResizeGravity	"ResizeGravity"
#define XtCRetryInputMethod	"RetryInputMethod"
#define XtCReverseWrap		"ReverseWrap"
#define XtCRightScrollBar	"RightScrollBar"
#define XtCSaveLines		"SaveLines"
#define XtCScaleHeight		"ScaleHeight"
#define XtCScrollBar		"ScrollBar"
#define XtCScrollBarBorder	"ScrollBarBorder"
#define XtCScrollCond		"ScrollCond"
#define XtCScrollLines		"ScrollLines"
#define XtCScrollPos		"ScrollPos"
#define XtCSelectToClipboard	"SelectToClipboard"
#define XtCShiftFonts		"ShiftFonts"
#define XtCShowBlinkAsBold	"ShowBlinkAsBold"
#define XtCShowMissingGlyphs	"ShowMissingGlyphs"
#define XtCShowWrapMarks	"ShowWrapMarks"
#define XtCSignalInhibit	"SignalInhibit"
#define XtCSixelScrolling	"SixelScrolling"
#define XtCSixelScrollsRight	"SixelScrollsRight"
#define XtCTekInhibit		"TekInhibit"
#define XtCTekSmall		"TekSmall"
#define XtCTekStartup		"TekStartup"
#define XtCTiXtraScroll		"TiXtraScroll"
#define XtCTiteInhibit		"TiteInhibit"
#define XtCTitleModes		"TitleModes"
#define XtCToolBar		"ToolBar"
#define XtCTrimSelection	"TrimSelection"
#define XtCUnderLine		"UnderLine"
#define XtCUseClipping		"UseClipping"
#define XtCUtf8			"Utf8"
#define XtCUtf8Fonts		"Utf8Fonts"
#define XtCUtf8Latin1		"Utf8Latin1"
#define XtCUtf8SelectTypes	"Utf8SelectTypes"
#define XtCUtf8Title		"Utf8Title"
#define XtCVT100Graphics	"VT100Graphics"
#define XtCVeryBoldColors	"VeryBoldColors"
#define XtCVisualBell		"VisualBell"
#define XtCVisualBellDelay	"VisualBellDelay"
#define XtCVisualBellLine	"VisualBellLine"
#define XtCWideBoldFont		"WideBoldFont"
#define XtCWideChars		"WideChars"
#define XtCWideFont		"WideFont"
#define XtCXimFont		"XimFont"
#define XtCXmcAttributes	"XmcAttributes"
#define XtCXmcGlitch		"XmcGlitch"
#define XtCXmcInline		"XmcInline"
#define XtCXmcMoveSGR		"XmcMoveSGR"

#if defined(NO_ACTIVE_ICON) && !defined(XtNgeometry)
#define XtNgeometry		"geometry"
#define XtCGeometry		"Geometry"
#endif

#if OPT_COLOR_CLASS
#define XtCCursorColor		"CursorColor"
#define XtCPointerColor		"PointerColor"
#define XtCHighlightColor	"HighlightColor"
#define XtCHighlightTextColor	"HighlightTextColor"
#else
#define XtCCursorColor		XtCForeground
#define XtCPointerColor		XtCForeground
#define XtCHighlightColor	XtCForeground
#define XtCHighlightTextColor	XtCBackground
#endif

/***====================================================================***/

#ifdef __cplusplus
extern "C" {
#endif

struct XTERM_RESOURCE;

/* Tekproc.c */
#if OPT_TEK4014
extern TekWidget getTekWidget(Widget /* w */);
extern int TekGetFontSize (const char * /* param */);
extern int TekInit (void);
extern int TekPtyData(void);
extern void ChangeTekColors (TekWidget /* tw */, TScreen * /* screen */, ScrnColors * /* pNew */);
extern void HandleGINInput             PROTO_XT_ACTIONS_ARGS;
extern void TCursorToggle (TekWidget /* tw */, int /* toggle */);
extern void TekCopy (TekWidget /* tw */);
extern void TekEnqMouse (TekWidget /* tw */, int /* c */);
extern void TekExpose (Widget  /* w */, XEvent * /* event */, Region  /* region */);
extern void TekGINoff (TekWidget /* tw */);
extern void TekRefresh (TekWidget /* tw */);
extern void TekRepaint (TekWidget /* xw */);
extern void TekReverseVideo (TekWidget /* tw */);
extern void TekRun (void);
extern void TekSetFontSize (TekWidget /* tw */, Bool /* fromMenu */, int  /* newitem */);
extern void TekSimulatePageButton (TekWidget /* tw */, Bool /* reset */);
#endif

/* button.c */
#define	MotionOff( s, t ) if (!(screen->hide_pointer)) {		\
	    (s)->event_mask |= ButtonMotionMask;			\
	    (s)->event_mask &= ~PointerMotionMask;			\
	    XSelectInput(XtDisplay((t)), XtWindow((t)), (long) (s)->event_mask); }

#define	MotionOn( s, t ) {						\
	    (s)->event_mask &= ~ButtonMotionMask;			\
	    (s)->event_mask |= PointerMotionMask;			\
	    XSelectInput(XtDisplay((t)), XtWindow((t)), (long) (s)->event_mask); }

extern Bool SendMousePosition (XtermWidget  /* w */, XEvent*  /* event */);
extern void DiredButton                PROTO_XT_ACTIONS_ARGS;
extern void DisownSelection (XtermWidget  /* termw */);
extern void UnhiliteSelection (XtermWidget  /* termw */);
extern void HandleCopySelection        PROTO_XT_ACTIONS_ARGS;
extern void HandleInsertSelection      PROTO_XT_ACTIONS_ARGS;
extern void HandleKeyboardSelectEnd    PROTO_XT_ACTIONS_ARGS;
extern void HandleKeyboardSelectExtend PROTO_XT_ACTIONS_ARGS;
extern void HandleKeyboardSelectStart  PROTO_XT_ACTIONS_ARGS;
extern void HandleKeyboardStartExtend  PROTO_XT_ACTIONS_ARGS;
extern void HandleSelectEnd            PROTO_XT_ACTIONS_ARGS;
extern void HandleSelectExtend         PROTO_XT_ACTIONS_ARGS;
extern void HandleSelectSet            PROTO_XT_ACTIONS_ARGS;
extern void HandleSelectStart          PROTO_XT_ACTIONS_ARGS;
extern void HandleStartExtend          PROTO_XT_ACTIONS_ARGS;
extern void ResizeSelection (TScreen * /* screen */, int  /* rows */, int  /* cols */);
extern void ScrollSelection (TScreen * /* screen */, int  /* amount */,  Bool /* always */);
extern void TrackMouse (XtermWidget /* xw */, int /* func */, CELL * /* start */, int /* firstrow */, int /* lastrow */);
extern void ViButton                   PROTO_XT_ACTIONS_ARGS;

extern int xtermUtf8ToTextList(XtermWidget /* xw */, XTextProperty * /* text_prop */, char *** /* text_list */, int * /* text_list_count */);

#if OPT_DEC_LOCATOR
extern void GetLocatorPosition (XtermWidget  /* w */);
extern void InitLocatorFilter (XtermWidget  /* w */);
#endif	/* OPT_DEC_LOCATOR */

#if OPT_FOCUS_EVENT
extern void SendFocusButton(XtermWidget /* xw */, XFocusChangeEvent * /* event */);
#else
#define SendFocusBotton(xw, event) /* nothing */
#endif

#if OPT_PASTE64
extern void AppendToSelectionBuffer (TScreen * /* screen */, unsigned  /* c */);
extern void ClearSelectionBuffer (TScreen * /* screen */);
extern void CompleteSelection (XtermWidget  /* xw */, String * /* args */, Cardinal  /* len */);
extern void xtermGetSelection (Widget  /* w */, Time  /* ev_time */, String * /* params */, Cardinal  /* num_params */, Atom * /* targets */);
#endif

#if OPT_READLINE
extern void ReadLineButton             PROTO_XT_ACTIONS_ARGS;
#endif

#if OPT_WIDE_CHARS
extern Bool iswide(int  /* i */);
#define WideCells(n) (((IChar)(n) >= first_widechar) ? my_wcwidth((wchar_t) (n)) : 1)
#define isWide(n)    (((IChar)(n) >= first_widechar) && iswide(n))
#else
#define WideCells(n) 1
#endif

/* cachedCgs.c */
extern CgsEnum getCgsId(XtermWidget /*xw*/, VTwin * /*cgsWin*/, GC /*gc*/);
extern GC freeCgs(XtermWidget /*xw*/, VTwin * /*cgsWin*/, CgsEnum /*cgsId*/);
extern GC getCgsGC(XtermWidget /*xw*/, VTwin * /*cgsWin*/, CgsEnum /*cgsId*/);
extern Pixel getCgsBack(XtermWidget /*xw*/, VTwin * /*cgsWin*/, GC /*gc*/);
extern Pixel getCgsFore(XtermWidget /*xw*/, VTwin * /*cgsWin*/, GC /*gc*/);
extern XTermFonts * getCgsFont(XtermWidget /*xw*/, VTwin * /*cgsWin*/, GC /*gc*/);
extern void clrCgsFonts(XtermWidget /*xw*/, VTwin * /*cgsWin*/, XTermFonts * /*font*/);
extern void copyCgs(XtermWidget /*xw*/, VTwin * /*cgsWin*/, CgsEnum /*dstCgsId*/, CgsEnum /*srcCgsId*/);
extern void redoCgs(XtermWidget /*xw*/, Pixel /*fg*/, Pixel /*bg*/, CgsEnum /*cgsId*/);
extern void setCgsBack(XtermWidget /*xw*/, VTwin * /*cgsWin*/, CgsEnum /*cgsId*/, Pixel /*bg*/);
extern void setCgsCSet(XtermWidget /*xw*/, VTwin * /*cgsWin*/, CgsEnum /*cgsId*/, unsigned /*cset*/);
extern void setCgsFont(XtermWidget /*xw*/, VTwin * /*cgsWin*/, CgsEnum /*cgsId*/, XTermFonts * /*font*/);
extern void setCgsFore(XtermWidget /*xw*/, VTwin * /*cgsWin*/, CgsEnum /*cgsId*/, Pixel /*fg*/);
extern void swapCgs(XtermWidget /*xw*/, VTwin * /*cgsWin*/, CgsEnum /*dstCgsId*/, CgsEnum /*srcCgsId*/);

#ifdef NO_LEAKS
extern void noleaks_cachedCgs (XtermWidget /* xw */);
#endif

/* charproc.c */
extern Bool CheckBufPtrs (TScreen * /* screen */);
extern Bool set_cursor_gcs (XtermWidget /* xw */);
extern int VTInit (XtermWidget /* xw */);
extern void FindFontSelection (XtermWidget /* xw */, const char * /* atom_name */, Bool  /* justprobe */);
extern void HideCursor (void);
extern void RestartBlinking(TScreen * /* screen */);
extern void ShowCursor (void);
extern void SwitchBufPtrs (TScreen * /* screen */, int /* toBuf */);
extern void ToggleAlternate (XtermWidget /* xw */);
extern void VTInitTranslations (void);
extern void VTReset (XtermWidget /* xw */, int /* full */, int /* saved */) GCC_NORETURN;
extern void VTRun (XtermWidget /* xw */);
extern void dotext (XtermWidget /* xw */, int  /* charset */, IChar * /* buf */, Cardinal  /* len */);
extern void getKeymapResources(Widget /* w */, const char * /*mapName */, const char * /* mapClass */, const char * /* type */, void * /* result */, size_t /* size */);
extern void lookupSelectUnit(XtermWidget /* xw */, Cardinal /* item */, String /* value */);
extern void releaseCursorGCs(XtermWidget /*xw*/);
extern void releaseWindowGCs(XtermWidget /*xw*/, VTwin * /*win*/);
extern void resetCharsets (TScreen * /* screen */);
extern void set_max_col(TScreen *  /* screen */, int  /* cols */);
extern void set_max_row(TScreen *  /* screen */, int  /* rows */);
extern void set_lr_margins (TScreen * /* screen */, int  /* left */, int  /* right */);
extern void set_tb_margins (TScreen * /* screen */, int  /* top */, int  /* bottom */);
extern void unparse_end (XtermWidget /* xw */);
extern void unparseputc (XtermWidget /* xw */, int  /* c */);
extern void unparseputc1 (XtermWidget /* xw */, int  /* c */);
extern void unparseputn (XtermWidget /* xw */, unsigned /* n */);
extern void unparseputs (XtermWidget /* xw */, const char * /* s */);
extern void unparseseq (XtermWidget /* xw */, ANSI * /* ap */);
extern void v_write (int  /* f */, const Char * /* d */, unsigned  /* len */);
extern void xtermAddInput(Widget  /* w */);

#if OPT_BLINK_CURS
extern void ToggleCursorBlink(TScreen * /* screen */);
#endif

#if OPT_BLINK_TEXT
extern Bool LineHasBlinking(TScreen * /* screen */, CLineData * /* ld */);
#endif

#if OPT_INPUT_METHOD
extern TInput *lookupTInput (XtermWidget /* xw */, Widget /* w */);
#endif

#if OPT_ISO_COLORS
extern void SGR_Background (XtermWidget /* xw */, int  /* color */);
extern void SGR_Foreground (XtermWidget /* xw */, int  /* color */);
#endif

#ifdef NO_LEAKS
extern void noleaks_charproc (void);
#endif

/* charsets.c */
extern unsigned xtermCharSetIn (TScreen * /* screen */, unsigned  /* code */, int  /* charset */);
extern int xtermCharSetOut (XtermWidget /* xw */, IChar * /* buf */, IChar * /* ptr */, int  /* charset */);

/* cursor.c */
extern int CursorCol (XtermWidget /* xw */);
extern int CursorRow (XtermWidget /* xw */);
extern void AdjustSavedCursor (XtermWidget /* xw */, int /* adjust */);
extern void CarriageReturn (XtermWidget /* xw */);
extern void CursorBack (XtermWidget /* xw */, int /* n */);
extern void CursorDown (TScreen * /* screen */, int /* n */);
extern void CursorForward (XtermWidget /* xw */, int /* n */);
extern void CursorNextLine (XtermWidget /* xw */, int /* count */);
extern void CursorPrevLine (XtermWidget /* xw */, int /* count */);
extern void CursorRestore (XtermWidget  /* xw */);
extern void CursorSave (XtermWidget  /* xw */);
extern void CursorSet (TScreen * /* screen */, int  /* row */, int  /* col */, unsigned  /* flags */);
extern void CursorUp (TScreen * /* screen */, int   /* n */);
extern void RevIndex (XtermWidget /* xw */, int  /* amount */);
extern void xtermIndex (XtermWidget /* xw */, int  /* amount */);

#if OPT_TRACE
extern int set_cur_col(TScreen * /* screen */, int  /* value */);
extern int set_cur_row(TScreen * /* screen */, int  /* value */);
#else
#define set_cur_col(screen, value) screen->cur_col = value
#define set_cur_row(screen, value) screen->cur_row = value
#endif

/* doublechr.c */
extern void xterm_DECDHL (XtermWidget /* xw */, Bool  /* top */);
extern void xterm_DECSWL (XtermWidget /* xw */);
extern void xterm_DECDWL (XtermWidget /* xw */);
extern void xterm_ResetDouble(XtermWidget /* xw */);
#if OPT_DEC_CHRSET
extern int xterm_Double_index(XtermWidget /* xw */, unsigned  /* chrset */, unsigned  /* flags */);
extern GC xterm_DoubleGC(XtermWidget /* xw */, unsigned  /* chrset */, unsigned  /* attr_flags */, unsigned  /* draw_flags */, GC  /* old_gc */, int * /* inxp */);
#endif

/* input.c */
extern unsigned xtermParamToState (XtermWidget /* xw */, unsigned /* param */);
extern unsigned xtermStateToParam (XtermWidget /* xw */, unsigned /* state */);
extern Bool xtermDeleteIsDEL (XtermWidget /* xw */);
extern void Input (XtermWidget /* xw */, XKeyEvent */* event */, Bool /* eightbit */);
extern void StringInput (XtermWidget /* xw */, const Char * /* string */, size_t  /* nbytes */);

#if OPT_NUM_LOCK
extern void VTInitModifiers(XtermWidget /* xw */);
#endif

/* linedata.c */
extern LineData *getLineData(TScreen * /* screen */, int /* row */);
extern void copyLineData(LineData * /* dst */, CLineData * /* src */);
extern void initLineData(XtermWidget /* xw */);

extern CellData *newCellData(XtermWidget /* xw */, Cardinal /* count */);
extern void saveCellData(TScreen * /* screen */, CellData * /* data */, Cardinal /* cell */, CLineData * /* ld */, int /* column */);
extern void restoreCellData(TScreen * /* screen */, const CellData * /* data */, Cardinal /* cell */, LineData * /* ld */, int /* column */);

/* main.c */
#define ENVP_ARG /**/

extern int main (int  /* argc */, char ** /* argv */ ENVP_ARG);
extern int GetBytesAvailable (int  /* fd */);
extern int kill_process_group (int  /* pid */, int  /* sig */);
extern int nonblocking_wait (void);

#if OPT_PTY_HANDSHAKE
extern void first_map_occurred (void);
#else
#define first_map_occurred() /* nothing */
#endif

extern void Exit (int  /* n */) GCC_NORETURN;

#ifndef SIG_ATOMIC_T
#define SIG_ATOMIC_T int
#endif

#if OPT_WIDE_CHARS
extern unsigned first_widechar;
extern int (*my_wcwidth)(wchar_t);
#endif

/* menu.c */
extern void do_hangup          PROTO_XT_CALLBACK_ARGS;
extern void repairSizeHints    (void);
extern void show_8bit_control  (Bool  /* value */);

/* misc.c */

#define TIMESTAMP_LEN 20	/* length of TIMESTAMP_FMT */

extern Bool AllocateTermColor(XtermWidget, ScrnColors *, int, const char *, Bool);
extern Boolean xtermGetWinAttrs(Display * /* dpy */, Window /* win */, XWindowAttributes * /* attrs */);
extern Boolean xtermGetWinProp(Display * /* dpy */, Window /* win */, Atom /* property */, long /* long_offset */, long /* long_length */, Atom /* req_type */, Atom * /* actual_type_return */, int * /* actual_format_return */, unsigned long * /* nitems_return */, unsigned long * /* bytes_after_return */, unsigned char ** /* prop_return */);
extern Cursor make_colored_cursor (unsigned /* cursorindex */, unsigned long  /* fg */, unsigned long  /* bg */);
extern OptionHelp * sortedOpts(OptionHelp *, XrmOptionDescRec *, Cardinal);
extern String xtermEnvLocale (void);
extern Widget xtermOpenApplication (XtAppContext * /* app_context_return */, String /* application_class */, XrmOptionDescRec */* options */, Cardinal /* num_options */, int * /* argc_in_out */, String */* argv_in_out */, String * /* fallback_resources */, WidgetClass /* widget_class */, ArgList /* args */, Cardinal /* num_args */);
extern Window WMFrameWindow (XtermWidget /* termw */);
extern XtInputMask xtermAppPending (void);
extern XrmOptionDescRec * sortedOptDescs (XrmOptionDescRec *, Cardinal);
extern XtermWidget getXtermWidget (Widget /* w */);
extern char *udk_lookup (XtermWidget /* xw */, int /* keycode */, int * /* len */);
extern char *xtermEnvEncoding (void);
extern char *xtermFindShell (char * /* leaf */, Bool  /* warning */);
extern const char *SysErrorMsg (int /* n */);
extern const char *SysReasonMsg (int /* n */);
extern Boolean allocateBestRGB(XtermWidget /* xw */, XColor * /* def */);
extern Boolean validProgram(const char * /* pathname */);
extern int ResetAnsiColorRequest (XtermWidget, char *, int);
extern int XStrCmp (char * /* s1 */, char * /* s2 */);
extern int creat_as (uid_t  /* uid */, gid_t  /* gid */, Bool  /* append */, char * /* pathname */, unsigned  /* mode */);
extern int getVisualDepth (XtermWidget /* xw */);
extern int getVisualInfo (XtermWidget /* xw */);
extern int open_userfile (uid_t  /* uid */, gid_t  /* gid */, char * /* path */, Bool  /* append */);
extern int xerror (Display * /* d */, XErrorEvent * /* ev */);
extern int xioerror (Display * /* dpy */);
extern int xtermClosestColor (XtermWidget /* xw */, int /* red */, int /* green */, int /* blue */);
extern int xtermResetIds (TScreen *  /* screen */);
extern void Bell (XtermWidget /* xw */, int  /* which */, int  /* percent */);
extern void ChangeGroup(XtermWidget /* xw */, const char * /* attribute */, char * /* value */);
extern void ChangeIconName (XtermWidget /* xw */, char * /* name */);
extern void ChangeTitle (XtermWidget /* xw */, char * /* name */);
extern void ChangeXprop (char * /* name */);
extern void Cleanup (int /* code */) GCC_NORETURN;
extern void HandleBellPropertyChange   PROTO_XT_EV_HANDLER_ARGS;
extern void HandleEightBitKeyPressed   PROTO_XT_ACTIONS_ARGS;
extern void HandleEnterWindow          PROTO_XT_EV_HANDLER_ARGS;
extern void HandleFocusChange          PROTO_XT_EV_HANDLER_ARGS;
extern void HandleInterpret            PROTO_XT_ACTIONS_ARGS;
extern void HandleKeyPressed           PROTO_XT_ACTIONS_ARGS;
extern void HandleLeaveWindow          PROTO_XT_EV_HANDLER_ARGS;
extern void HandleSpawnTerminal        PROTO_XT_ACTIONS_ARGS;
extern void HandleStringEvent          PROTO_XT_ACTIONS_ARGS;
extern void NormalExit (void);
extern void Panic (const char * /* s */, int  /* a */);
extern void Redraw (void);
extern void ReverseOldColors (XtermWidget /* xw */);
extern void SysError (int /* i */) GCC_NORETURN;
extern void VisualBell (void);
extern void cleanup_colored_cursor (void);
extern void do_dcs (XtermWidget /* xw */, Char * /* buf */, size_t  /* len */);
extern void do_decrpm (XtermWidget /* xw */, int /* nparam */, int *  /* params */);
extern void do_osc (XtermWidget /* xw */, Char * /* buf */, size_t  /* len */, int  /* final */);
extern void do_rpm (XtermWidget /* xw */, int /* nparam */, int *  /* params */);
extern void do_xevents (void);
extern void end_tek_mode (void);
extern void end_vt_mode (void);
extern void free_string(String value);
extern void hide_tek_window (void);
extern void hide_vt_window (void);
extern void ice_error (IceConn /* iceConn */);
extern void init_colored_cursor (Display * /* dpy */);
extern void reset_decudk (XtermWidget /* xw */);
extern void set_tek_visibility (Bool  /* on */);
extern void set_vt_visibility (Bool  /* on */);
extern void switch_modes (Bool  /* tovt */);
extern void timestamp_filename(char * /* dst */, const char * /* src */);
extern void xevents (void);
extern void xt_error (String  /* message */);
extern void xtermBell(XtermWidget /* xw */, int /* which */, int /* percent */);
extern void xtermCopyEnv (char ** /* oldenv */);
extern void xtermDisplayCursor (XtermWidget /* xw */);
extern void xtermEmbedWindow (Window /* winToEmbedInfo */);
extern void xtermLoadIcon (XtermWidget /* xw */);
extern void xtermPerror (const char * /*fmt*/,...) GCC_PRINTFLIKE(1,2);
extern void xtermSetenv (const char * /* var */, const char * /* value */);
extern void xtermShowPointer (XtermWidget /* xw */, Bool /* enable */);
extern void xtermUnsetenv (const char * /* var */);
extern void xtermWarning (const char * /*fmt*/,...) GCC_PRINTFLIKE(1,2);

#if OPT_DABBREV
extern void HandleDabbrevExpand        PROTO_XT_ACTIONS_ARGS;
#endif

#if OPT_EXEC_XTERM
extern char *ProcGetCWD(pid_t /* pid */);
#else
#define ProcGetCWD(pid) NULL
#endif

#if OPT_MAXIMIZE
extern int QueryMaximize (XtermWidget  /* termw */, unsigned * /* width */, unsigned * /* height */);
extern void HandleDeIconify            PROTO_XT_ACTIONS_ARGS;
extern void HandleIconify              PROTO_XT_ACTIONS_ARGS;
extern void HandleMaximize             PROTO_XT_ACTIONS_ARGS;
extern void HandleRestoreSize          PROTO_XT_ACTIONS_ARGS;
extern void RequestMaximize (XtermWidget  /* termw */, int  /* maximize */);
#endif

#if OPT_SCROLL_LOCK
extern void GetScrollLock (TScreen * /* screen */);
extern void HandleScrollLock           PROTO_XT_ACTIONS_ARGS;
extern void ShowScrollLock (TScreen * /* screen */, Bool /* enable */);
extern void SetScrollLock (TScreen * /* screen */, Bool /* enable */);
extern void xtermShowLED (TScreen * /* screen */, Cardinal /* led_number */, Bool /* enable */);
extern void xtermClearLEDs (TScreen * /* screen */);
#else
#define ShowScrollLock(screen, enable) /* nothing */
#define SetScrollLock(screen, enable) /* nothing */
#define GetScrollLock(screen) /* nothing */
#endif

#if OPT_SELECTION_OPS
extern void HandleExecFormatted        PROTO_XT_ACTIONS_ARGS;
extern void HandleExecSelectable       PROTO_XT_ACTIONS_ARGS;
extern void HandleInsertFormatted      PROTO_XT_ACTIONS_ARGS;
extern void HandleInsertSelectable     PROTO_XT_ACTIONS_ARGS;
#endif

#if OPT_SESSION_MGT
extern void xtermCloseSession (void);
extern void xtermOpenSession (void);
#else
#define xtermCloseSession() /* nothing */
#define xtermOpenSession() /* nothing */
#endif

#if OPT_WIDE_CHARS
extern Bool xtermEnvUTF8(void);
#else
#define xtermEnvUTF8() False
#endif

#ifdef ALLOWLOGGING
extern void StartLog (XtermWidget /* xw */);
extern void CloseLog (XtermWidget /* xw */);
extern void FlushLog (XtermWidget /* xw */);
#else
#define FlushLog(xw) /*nothing*/
#endif

/* print.c */
extern Bool xtermHasPrinter (XtermWidget /* xw */);
extern PrinterFlags *getPrinterFlags (XtermWidget /* xw */, String * /* params */, Cardinal * /* param_count */);
extern int xtermPrinterControl (XtermWidget /* xw */, int /* chr */);
extern void setPrinterControlMode (XtermWidget /* xw */, int /* mode */);
extern void xtermAutoPrint (XtermWidget /* xw */, unsigned /* chr */);
extern void xtermMediaControl (XtermWidget /* xw */, int  /* param */, int  /* private_seq */);
extern void xtermPrintScreen (XtermWidget /* xw */, Bool  /* use_DECPEX */, PrinterFlags * /* p */);
extern void xtermPrintEverything (XtermWidget /* xw */, PrinterFlags * /* p */);
extern void xtermPrintImmediately (XtermWidget /* xw */, String /* filename */, int /* opts */, int /* attributes */);
extern void xtermPrintOnXError (XtermWidget /* xw */, int /* n */);

#if OPT_SCREEN_DUMPS
/* html.c */
extern void xtermDumpHtml (XtermWidget /* xw */);
/* svg.c */
extern void xtermDumpSvg (XtermWidget /* xw */);
#endif

/* ptydata.c */
#ifdef VMS
#define PtySelect int
#else
#define PtySelect fd_set
#endif

extern Bool decodeUtf8 (TScreen * /* screen */, PtyData * /* data */);
extern int readPtyData (XtermWidget /* xw */, PtySelect * /* select_mask */, PtyData * /* data */);
extern void fillPtyData (XtermWidget /* xw */, PtyData * /* data */, const char * /* value */, int  /* length */);
extern void initPtyData (PtyData ** /* data */);
extern void trimPtyData (XtermWidget /* xw */, PtyData * /* data */);

#ifdef NO_LEAKS
extern void noleaks_ptydata ( void );
#endif

#if OPT_WIDE_CHARS
extern Char *convertToUTF8 (Char * /* lp */, unsigned  /* c */);
extern IChar nextPtyData (TScreen * /* screen */, PtyData * /* data */);
extern IChar skipPtyData (PtyData * /* data */);
extern PtyData * fakePtyData(PtyData * /* result */, Char * /* next */, Char * /* last */);
extern void switchPtyData (TScreen * /* screen */, int  /* f */);
extern void writePtyData (int  /* f */, IChar * /* d */, unsigned  /* len */);

#define morePtyData(screen,data) \
	(((data)->last > (data)->next) \
	 ? (((screen)->utf8_inparse && !(data)->utf_size) \
	    ? decodeUtf8(screen, data) \
	    : True) \
	 : False)
#else
#define morePtyData(screen, data) ((data)->last > (data)->next)
#define nextPtyData(screen, data) (IChar) (*((data)->next++) & \
					   (screen->output_eight_bits \
					    ? 0xff \
					    : 0x7f))
#define writePtyData(f,d,len) v_write(f,d,len)
#endif

/* screen.c */

/*
 * See http://standards.freedesktop.org/wm-spec/wm-spec-latest.html
 */
#define _NET_WM_STATE_REMOVE	0	/* remove/unset property */
#define _NET_WM_STATE_ADD	1	/* add/set property */
#define _NET_WM_STATE_TOGGLE	2	/* toggle property */

extern Bool non_blank_line (TScreen */* screen */, int  /* row */, int  /* col */, int  /* len */);
extern Char * allocScrnData (TScreen * /* screen */, unsigned /* nrow */, unsigned /* ncol */);
extern ScrnBuf allocScrnBuf (XtermWidget /* xw */, unsigned  /* nrow */, unsigned  /* ncol */, ScrnPtr * /* addr */);
extern ScrnBuf scrnHeadAddr (TScreen * /* screen */, ScrnBuf /* base */, unsigned /* offset */);
extern int ScreenResize (XtermWidget /* xw */, int  /* width */, int  /* height */, unsigned * /* flags */);
extern size_t ScrnPointers (TScreen * /* screen */, size_t  /* len */);
extern void ClearBufRows (XtermWidget /* xw */, int  /* first */, int  /* last */);
extern void ClearCells (XtermWidget /* xw */, int /* flags */, unsigned /* len */, int /* row */, int /* col */);
extern void CopyCells (TScreen * /* screen */, LineData * /* src */, LineData * /* dst */, int /* col */, int /* len */);
extern void FullScreen (XtermWidget /* xw */, int /* mode */);
extern void ScrnAllocBuf (XtermWidget /* xw */);
extern void ScrnClearCells (XtermWidget /* xw */, int /* row */, int /* col */, unsigned /* len */);
extern void ScrnDeleteChar (XtermWidget /* xw */, unsigned  /* n */);
extern void ScrnDeleteCol (XtermWidget /* xw */, unsigned  /* n */);
extern void ScrnDeleteLine (XtermWidget /* xw */, ScrnBuf  /* sb */, int  /* n */, int  /* last */, unsigned /* where */);
extern void ScrnDisownSelection (XtermWidget /* xw */);
extern void ScrnFillRectangle (XtermWidget /* xw */, XTermRect *,  int ,  unsigned /* flags */, Bool /* keepColors */);
extern void ScrnInsertChar (XtermWidget /* xw */, unsigned  /* n */);
extern void ScrnInsertCol (XtermWidget /* xw */, unsigned  /* n */);
extern void ScrnInsertLine (XtermWidget /* xw */, ScrnBuf /* sb */, int  /* last */, int  /* where */, unsigned  /* n */);
extern void ScrnRefresh (XtermWidget /* xw */, int  /* toprow */, int  /* leftcol */, int  /* nrows */, int  /* ncols */, Bool  /* force */);
extern void ScrnUpdate (XtermWidget /* xw */, int  /* toprow */, int  /* leftcol */, int  /* nrows */, int  /* ncols */, Bool  /* force */);
extern void ScrnWriteText (XtermWidget /* xw */, IChar * /* str */, unsigned  /* flags */, unsigned /* cur_fg_bg */, unsigned  /* length */);
extern void ShowWrapMarks (XtermWidget /* xw */, int /* row */, CLineData * /* ld */);
extern void setupLineData (TScreen * /* screen */, ScrnBuf /* base */, Char * /* data */, unsigned /* nrow */, unsigned /* ncol */);
extern void xtermParseRect (XtermWidget /* xw */, int, int *, XTermRect *);

#if OPT_TRACE && OPT_TRACE_FLAGS
extern int  LineTstFlag(LineData /* ld */, int /* flag */);
extern void LineClrFlag(LineData /* ld */, int /* flag */);
extern void LineSetFlag(LineData /* ld */, int /* flag */);
#else

#define LineFlags(ld)         GetLineFlags(ld)

#define LineClrFlag(ld, flag) SetLineFlags(ld, (GetLineFlags(ld) & ~ (flag)))
#define LineSetFlag(ld, flag) SetLineFlags(ld, (GetLineFlags(ld) | (flag)))
#define LineTstFlag(ld, flag) ((GetLineFlags(ld) & flag) != 0)

#endif /* OPT_TRACE && OPT_TRACE_FLAGS */

#define LineClrBlinked(ld) LineClrFlag(ld, LINEBLINKED)
#define LineSetBlinked(ld) LineSetFlag(ld, LINEBLINKED)
#define LineTstBlinked(ld) LineTstFlag(ld, LINEBLINKED)

#define LineClrWrapped(ld) LineClrFlag(ld, LINEWRAPPED)
#define LineSetWrapped(ld) LineSetFlag(ld, LINEWRAPPED)
#define LineTstWrapped(ld) LineTstFlag(ld, LINEWRAPPED)

#define ScrnHaveSelection(screen) \
			((screen)->startH.row != (screen)->endH.row \
			|| (screen)->startH.col != (screen)->endH.col)

#define ScrnAreRowsInSelection(screen, first, last) \
	((last) >= (screen)->startH.row && (first) <= (screen)->endH.row)

#define ScrnIsRowInSelection(screen, line) \
	((line) >= (screen)->startH.row && (line) <= (screen)->endH.row)

#define ScrnHaveRowMargins(screen) \
			((screen)->top_marg != 0 \
			|| ((screen)->bot_marg != screen->max_row))

#define ScrnIsRowInMargins(screen, line) \
	((line) >= (screen)->top_marg && (line) <= (screen)->bot_marg)

#define ScrnHaveColMargins(screen) \
			((screen)->rgt_marg > (screen)->max_col)

#define ScrnIsColInMargins(screen, col) \
	((col) >= (screen)->lft_marg && (col) <= (screen)->rgt_marg)

#define IsLeftRightMode(xw) ((xw)->flags & LEFT_RIGHT)
#define ScrnLeftMargin(xw)  (IsLeftRightMode(xw) \
			     ? TScreenOf(xw)->lft_marg \
			     : 0)
#define ScrnRightMargin(xw) (IsLeftRightMode(xw) \
			     ? TScreenOf(xw)->rgt_marg \
			     : MaxCols(TScreenOf(xw)) - 1)

#if OPT_DEC_RECTOPS
extern void ScrnCopyRectangle (XtermWidget /* xw */, XTermRect *, int, int *);
extern void ScrnMarkRectangle (XtermWidget /* xw */, XTermRect *, Bool, int, int *);
extern void ScrnWipeRectangle (XtermWidget /* xw */, XTermRect *);
extern void xtermCheckRect(XtermWidget /* xw */, int /* nparam */, int */* params */, int * /* result */);
#endif

#if OPT_WIDE_CHARS
extern void ChangeToWide(XtermWidget /* xw */);
#endif

/* scrollback.c */
extern LineData *getScrollback (TScreen * /* screen */, int /* row */);
extern LineData *addScrollback (TScreen * /* screen */);
extern void deleteScrollback (TScreen * /* screen */);

/* scrollbar.c */
extern void DoResizeScreen (XtermWidget /* xw */);
extern void HandleScrollBack           PROTO_XT_ACTIONS_ARGS;
extern void HandleScrollForward        PROTO_XT_ACTIONS_ARGS;
extern void ResizeScrollBar (XtermWidget  /* xw */);
extern void ScrollBarDrawThumb (Widget  /* scrollWidget */);
extern void ScrollBarOff (XtermWidget  /* xw */);
extern void ScrollBarOn (XtermWidget  /* xw */, Bool /* init */);
extern void ScrollBarReverseVideo (Widget  /* scrollWidget */);
extern void ToggleScrollBar (XtermWidget  /* xw */);
extern void WindowScroll (XtermWidget /* xw */, int  /* top */, Bool /* always */);

#ifdef SCROLLBAR_RIGHT
extern void updateRightScrollbar(XtermWidget  /* xw */);
#else
#define updateRightScrollbar(xw) /* nothing */
#endif

/* tabs.c */
extern Bool TabToNextStop (XtermWidget /* xw */);
extern Bool TabToPrevStop (XtermWidget /* xw */);
extern void TabClear (Tabs  /* tabs */, int  /* col */);
extern void TabReset (Tabs  /* tabs */);
extern void TabSet (Tabs  /* tabs */, int  /* col */);
extern void TabZonk (Tabs  /* tabs */);

/* util.c */
extern Boolean isDefaultBackground(const char * /* name */);
extern Boolean isDefaultForeground(const char * /* name */);
extern CgsEnum whichXtermCgs(XtermWidget /* xw */, unsigned /* attr_flags */, Bool /* hilite */);
extern GC updatedXtermGC (XtermWidget /* xw */, unsigned  /* flags */, unsigned /* fg_bg */, Bool  /* hilite */);
extern Pixel getXtermBackground(XtermWidget /* xw */, unsigned /* flags */, int /* color */);
extern Pixel getXtermForeground(XtermWidget /* xw */, unsigned /* flags */, int /* color */);
extern int ClearInLine (XtermWidget /* xw */, int /* row */, int /* col */, unsigned /* len */);
extern int HandleExposure (XtermWidget /* xw */, XEvent * /* event */);
extern int dimRound (double /* value */);
extern int drawXtermText (XtermWidget /* xw */, unsigned /* attr_flags */, unsigned /* draw_flags */, GC /* gc */, int /* x */, int /* y */, int /* chrset */, const IChar * /* text */, Cardinal /* len */, int /* on_wide */);
extern int extendedBoolean(const char * /* value */, const FlagList * /* table */, Cardinal /* limit */);
extern void ChangeColors (XtermWidget  /* xw */, ScrnColors * /* pNew */);
extern void ClearRight (XtermWidget /* xw */, int /* n */);
extern void ClearScreen (XtermWidget /* xw */);
extern void DeleteChar (XtermWidget /* xw */, unsigned /* n */);
extern void DeleteLine (XtermWidget /* xw */, int /* n */);
extern void FlushScroll (XtermWidget /* xw */);
extern void GetColors (XtermWidget  /* xw */, ScrnColors * /* pColors */);
extern void InsertChar (XtermWidget /* xw */, unsigned /* n */);
extern void InsertLine (XtermWidget /* xw */, int  /* n */);
extern void RevScroll (XtermWidget /* xw */, int  /* amount */);
extern void ReverseVideo (XtermWidget  /* termw */);
extern void WriteText (XtermWidget /* xw */, IChar * /* str */, Cardinal /* len */);
extern void decode_keyboard_type (XtermWidget /* xw */, struct XTERM_RESOURCE * /* rp */);
extern void decode_wcwidth (XtermWidget  /* xw */);
extern void do_cd_xtra_scroll (XtermWidget /* xw */);
extern void do_erase_display (XtermWidget /* xw */, int  /* param */, int  /* mode */);
extern void do_erase_line (XtermWidget /* xw */, int  /* param */, int  /* mode */);
extern void do_ti_xtra_scroll (XtermWidget /* xw */);
extern void getXtermSizeHints (XtermWidget /* xw */);
extern void recolor_cursor (TScreen * /* screen */, Cursor  /* cursor */, unsigned long  /* fg */, unsigned long  /* bg */);
extern void resetXtermGC (XtermWidget /* xw */, unsigned  /* flags */, Bool  /* hilite */);
extern void scrolling_copy_area (XtermWidget /* xw */, int  /* firstline */, int  /* nlines */, int  /* amount */);
extern void set_keyboard_type (XtermWidget /* xw */, xtermKeyboardType  /* type */, Bool  /* set */);
extern void toggle_keyboard_type (XtermWidget /* xw */, xtermKeyboardType  /* type */);
extern void update_keyboard_type (void);
extern void xtermClear (XtermWidget /* xw */);
extern void xtermColIndex (XtermWidget /* xw */, Bool /* toLeft */);
extern void xtermColScroll (XtermWidget /* xw */, int /* amount */, Bool /* toLeft */, int /* at_col */);
extern void xtermRepaint (XtermWidget /* xw */);
extern void xtermScroll (XtermWidget /* xw */, int /* amount */);
extern void xtermScrollLR (XtermWidget /* xw */, int /* amount */, Bool /* toLeft */);
extern void xtermSizeHints (XtermWidget  /* xw */, int /* scrollbarWidth */);

struct Xinerama_geometry {
    int x;
    int y;
    unsigned w;
    unsigned h;
    int scr_x;
    int scr_y;
    int scr_w;
    int scr_h;
};
extern int XParseXineramaGeometry(Display * /* display */, char * /* parsestring */, struct Xinerama_geometry * /* ret */);

#if OPT_ISO_COLORS

extern unsigned extract_fg (XtermWidget /* xw */, unsigned  /* color */, unsigned  /* flags */);
extern unsigned extract_bg (XtermWidget /* xw */, unsigned  /* color */, unsigned  /* flags */);
extern CellColor makeColorPair (int  /* fg */, int  /* bg */);
extern void ClearCurBackground (XtermWidget /* xw */, int  /* top */, int  /* left */, unsigned  /* height */, unsigned  /* width */, unsigned /* fw */);

#define xtermColorPair(xw) makeColorPair(xw->sgr_foreground, xw->sgr_background)

#if OPT_COLOR_RES
#define GET_COLOR_RES(xw, res) xtermGetColorRes(xw, &(res))
#define SET_COLOR_RES(res,color) (res)->value = color
#define EQL_COLOR_RES(res,color) (res)->value == color
#define T_COLOR(v,n) (v)->Tcolors[n].value
extern Pixel xtermGetColorRes(XtermWidget /* xw */, ColorRes * /* res */);
#else
#define GET_COLOR_RES(xw, res) res
#define SET_COLOR_RES(res,color) *res = color
#define EQL_COLOR_RES(res,color) *res == color
#define T_COLOR(v,n) (v)->Tcolors[n]
#endif

#define ExtractForeground(color) (unsigned) GetCellColorFG(color)
#define ExtractBackground(color) (unsigned) GetCellColorBG(color)

#if OPT_WIDE_ATTRS
#define MapToWideColorMode(fg, screen, flags) \
	(((screen)->colorITMode && ((flags) & ATR_ITALIC)) \
	 ? COLOR_IT \
	 : fg)
#else
#define MapToWideColorMode(fg, screen, flags) fg
#endif

#define MapToColorMode(fg, screen, flags) \
	(((screen)->colorBLMode && ((flags) & BLINK)) \
	 ? COLOR_BL \
	 : (((screen)->colorBDMode && ((flags) & BOLD)) \
	    ? COLOR_BD \
	    : (((screen)->colorULMode && ((flags) & UNDERLINE)) \
	       ? COLOR_UL \
	       : MapToWideColorMode(fg, screen, flags))))

#define checkVeryBoldAttr(flags, fg, code, attr) \
	if ((flags & FG_COLOR) != 0 \
	 && (screen->veryBoldColors & attr) == 0 \
	 && (flags & attr) != 0 \
	 && (fg == code)) \
		 UIntClr(flags, attr)

#if OPT_WIDE_ATTRS
#define checkVeryBoldWideAttr(flags, fg, it, atr) \
	    checkVeryBoldAttr(flags, fg, it, atr)
#else
#define checkVeryBoldWideAttr(flags, fg, it, atr) (void) flags
#endif

#define checkVeryBoldColors(flags, fg) \
	checkVeryBoldAttr(flags, fg, COLOR_RV, INVERSE); \
	checkVeryBoldAttr(flags, fg, COLOR_UL, UNDERLINE); \
	checkVeryBoldAttr(flags, fg, COLOR_BD, BOLD); \
	checkVeryBoldAttr(flags, fg, COLOR_BL, BLINK); \
	checkVeryBoldWideAttr(flags, fg, COLOR_IT, ATR_ITALIC)

#else /* !OPT_ISO_COLORS */

#define MapToColorMode(fg, screen, flags) fg

#define ClearCurBackground(xw, top, left, height, width, fw) \
	XClearArea (TScreenOf(xw)->display, \
		    VDrawable(TScreenOf(xw)), \
		    CursorX2(TScreenOf(xw), left, fw), \
		    CursorY(TScreenOf(xw), top), \
		    ((width) * (unsigned) fw), \
		    ((height) * (unsigned) FontHeight(TScreenOf(xw))), \
		    False)

#define extract_fg(xw, color, flags) (unsigned) (xw)->cur_foreground
#define extract_bg(xw, color, flags) (unsigned) (xw)->cur_background

		/* FIXME: Reverse-Video? */
#define T_COLOR(v,n) (v)->Tcolors[n]
#define makeColorPair(fg, bg) 0
#define xtermColorPair(xw) 0

#define checkVeryBoldColors(flags, fg) /* nothing */

#endif	/* OPT_ISO_COLORS */

#if OPT_ZICONBEEP
extern void initZIconBeep(void);
extern void resetZIconBeep(XtermWidget /* xw */);
extern Boolean showZIconBeep(XtermWidget /* xw */, char * /* name */);
#else
#define initZIconBeep() /* nothing */
#define showZIconBeep(xw, name) False
#endif

#define XTERM_CELL(row,col)    getXtermCell(screen,     ROW2INX(screen, row), col)

extern unsigned getXtermCell (TScreen * /* screen */, int  /* row */, int  /* col */);
extern unsigned getXtermCombining(TScreen * /* screen */, int /* row */, int /* col */, int /* off */);
extern void putXtermCell (TScreen * /* screen */, int  /* row */, int  /* col */, int  /* ch */);

#define IsCellCombined(screen, row, col) (getXtermCombining(screen, row, col, 0) != 0)

#if OPT_HIGHLIGHT_COLOR
#define isNotForeground(xw, fg, bg, sel) \
		(Boolean) ((sel) != T_COLOR(TScreenOf(xw), TEXT_FG) \
			   && (sel) != (fg) \
			   && (sel) != (bg) \
			   && (sel) != (xw)->dft_foreground)
#define isNotBackground(xw, fg, bg, sel) \
		(Boolean) ((sel) != T_COLOR(TScreenOf(xw), TEXT_BG) \
			   && (sel) != (fg) \
			   && (sel) != (bg) \
			   && (sel) != (xw)->dft_background)
#endif

#if OPT_WIDE_CHARS
extern Boolean isWideControl(unsigned /* ch */);
extern int DamagedCells(TScreen * /* screen */, unsigned /* n */, int * /* klp */, int * /* krp */, int /* row */, int /* col */);
extern int DamagedCurCells(TScreen * /* screen */, unsigned /* n */, int * /* klp */, int * /* krp */);
extern unsigned AsciiEquivs(unsigned /* ch */);
extern void addXtermCombining (TScreen * /* screen */, int  /* row */, int  /* col */, unsigned  /* ch */);
extern void allocXtermChars(ScrnPtr * /* buffer */, Cardinal /* length */);
#endif

#if OPT_XMC_GLITCH
extern void Mark_XMC (XtermWidget /* xw */, int  /* param */);
extern void Jump_XMC (XtermWidget /* xw */);
extern void Resolve_XMC (XtermWidget /* xw */);
#endif

#if OPT_WIDE_CHARS
unsigned visual_width(const IChar * /* str */, Cardinal  /* len */);
#else
#define visual_width(a, b) (b)
#endif

#define BtoS(b)    ((b) ? "on" : "off")
#define MtoS(b)    (((b) == Maybe) ? "maybe" : BtoS(b))
#define NonNull(s) ((s) ? (s) : "<null>")

#define UIntSet(dst,bits) dst = dst | (unsigned) (bits)
#define UIntClr(dst,bits) dst = dst & (unsigned) ~(bits)

#ifdef __cplusplus
	}
#endif
/* *INDENT-ON* */

#endif /* included_xterm_h */
@


1.40
log
@Update to xterm 322. Tested by shadchin@@ and jsg@@. Thanks.
@
text
@d1 1
a1 1
/* $XTermId: xterm.h,v 1.759 2015/12/30 02:00:38 tom Exp $ */
d4 1
a4 1
 * Copyright 1999-2014,2015 by Thomas E. Dickey
d378 4
d1118 6
d1187 7
a1395 1
extern void init_keyboard_type (XtermWidget /* xw */, xtermKeyboardType /* type */, Bool  /* set */);
@


1.39
log
@Update to xterm 320. Tested by jsg@@ Thanks.
@
text
@d1 1
a1 1
/* $XTermId: xterm.h,v 1.758 2015/08/19 00:26:56 tom Exp $ */
d477 1
d662 1
@


1.38
log
@xterm 314. tested by naddy@@
@
text
@d1 1
a1 1
/* $XTermId: xterm.h,v 1.753 2014/12/23 00:08:58 Ross.Combs Exp $ */
d4 1
a4 1
 * Copyright 1999-2013,2014 by Thomas E. Dickey
d896 1
d1089 1
a1089 1
extern void init_colored_cursor (void);
d1392 12
d1544 2
a1545 1
#define BtoS(b)    (((b) == Maybe) ? "maybe" : ((b) ? "on" : "off"))
@


1.37
log
@Update to xterm 313. Tested by shadchin@@
@
text
@d1 1
a1 1
/* $XTermId: xterm.h,v 1.749 2014/11/28 19:30:12 tom Exp $ */
d420 1
d488 1
d522 1
d672 1
d702 1
d1416 9
d1432 1
a1432 1
	       : fg)))
d1441 7
d1452 2
a1453 1
	checkVeryBoldAttr(flags, fg, COLOR_BL, BLINK)
@


1.36
log
@Update to xterm 311. ok shadchin@@
@
text
@d1 1
a1 1
/* $XTermId: xterm.h,v 1.746 2014/09/03 23:58:49 tom Exp $ */
d520 1
d698 1
d913 1
a913 1
extern Bool LineHasBlinking(TScreen * /* screen */, LineData * /* ld */);
d981 1
a981 1
extern void copyLineData(LineData * /* dst */, LineData * /* src */);
d985 2
a986 2
extern void saveCellData(TScreen * /* screen */, CellData * /* data */, Cardinal /* cell */, LineData * /* ld */, int /* column */);
extern void restoreCellData(TScreen * /* screen */, CellData * /* data */, Cardinal /* cell */, LineData * /* ld */, int /* column */);
d1241 1
a1241 1
extern void ShowWrapMarks (XtermWidget /* xw */, int /* row */, LineData * /* ld */);
d1350 1
a1350 1
extern int drawXtermText (XtermWidget /* xw */, unsigned /* attr_flags */, unsigned /* draw_flags */, GC /* gc */, int /* x */, int /* y */, int /* chrset */, IChar * /* text */, Cardinal /* len */, int /* on_wide */);
d1504 1
a1504 1
unsigned visual_width(IChar * /* str */, Cardinal  /* len */);
@


1.35
log
@Update to xterm-309. Version 308 tested by several people including
naddy@@ who found a small regression, fixed in 309.
@
text
@d1 1
a1 1
/* $XTermId: xterm.h,v 1.743 2014/06/28 20:53:20 tom Exp $ */
d102 1
a102 1
#if defined(CSRG_BASED) || defined(__GNU__)
d137 1
a137 1
#if defined(__SCO__) || defined(__UNIXWARE__)
d372 6
d1077 1
@


1.34
log
@Update to xterm 304. With help of shadchin@@

tested by ajacoutot@@ and shadchin@@
@
text
@d1 1
a1 1
/* $XTermId: xterm.h,v 1.737 2014/05/03 19:30:17 tom Exp $ */
d424 1
a424 1
#define XtNcursorUnderline	"cursorUnderLine"
d609 1
a609 1
#define XtCCursorUnderline	"CursorUnderLine"
d957 1
a957 1
extern GC xterm_DoubleGC(XtermWidget /* xw */, unsigned  /* chrset */, unsigned  /* flags */, GC  /* old_gc */, int * /* inxp */);
d1167 1
a1167 1
extern Bool decodeUtf8 (PtyData * /* data */);
d1188 1
a1188 1
	    ? decodeUtf8(data) \
d1334 1
d1336 2
d1341 1
a1341 1
extern int drawXtermText (XtermWidget /* xw */, unsigned /* flags */, GC /* gc */, int /* x */, int /* y */, int /* chrset */, IChar * /* text */, Cardinal /* len */, int /* on_wide */);
a1385 10
#define getXtermForeground(xw, flags, color) \
	(((flags) & FG_COLOR) && ((int)(color) >= 0 && (color) < MAXCOLORS) \
			? GET_COLOR_RES(xw, TScreenOf(xw)->Acolors[color]) \
			: T_COLOR(TScreenOf(xw), TEXT_FG))

#define getXtermBackground(xw, flags, color) \
	(((flags) & BG_COLOR) && ((int)(color) >= 0 && (color) < MAXCOLORS) \
			? GET_COLOR_RES(xw, TScreenOf(xw)->Acolors[color]) \
			: T_COLOR(TScreenOf(xw), TEXT_BG))

a1441 2
#define getXtermBackground(xw, flags, color) T_COLOR(TScreenOf(xw), TEXT_BG)
#define getXtermForeground(xw, flags, color) T_COLOR(TScreenOf(xw), TEXT_FG)
@


1.33
log
@Update to xterm 301
@
text
@d1 1
a1 1
/* $XTermId: xterm.h,v 1.727 2014/01/16 19:34:54 tom Exp $ */
d106 11
d153 1
a153 1
#if defined(UTMPX_FOR_UTMP) && !(defined(__MVS__) || defined(__hpux))
d157 1
a157 1
#if !(defined(linux) && (!defined(__GLIBC__) || (__GLIBC__ < 2))) && !defined(SVR4)
d172 1
d364 4
d496 1
d534 1
d676 1
d710 1
d1025 1
a1025 1
extern char *udk_lookup (int /* keycode */, int * /* len */);
d1031 1
d1036 1
d1060 1
a1060 1
extern void ReverseOldColors (void);
d1075 1
a1075 1
extern void reset_decudk (void);
d1339 1
a1339 1
extern int extendedBoolean(const char * /* value */, FlagList * /* table */, Cardinal /* limit */);
d1440 2
a1441 2
		    width * fw, \
		    height * FontHeight(TScreenOf(xw)), \
d1444 2
a1445 2
#define extract_fg(xw, color, flags) (xw)->cur_foreground
#define extract_bg(xw, color, flags) (xw)->cur_background
@


1.32
log
@Update to xterm-300. Tested  by ajacoutot@@ and shadchin@@.
@
text
@d1 1
a1 1
/* $XTermId: xterm.h,v 1.724 2013/11/23 00:25:35 tom Exp $ */
d4 1
a4 1
 * Copyright 1999-2012,2013 by Thomas E. Dickey
d217 4
@


1.31
log
@Update to xterm 296. Sixel graphics disabled for now.
@
text
@d1 1
a1 1
/* $XTermId: xterm.h,v 1.720 2013/06/23 08:57:13 Ross.Combs Exp $ */
d373 1
a482 1
#define XtNprivateColorRegisters "privateColorRegisters"
d491 1
d561 1
a657 1
#define XtCPrivateColorRegisters "PrivateColorRegisters"
d666 1
d898 1
a898 1
extern unsigned xtermCharSetIn (unsigned  /* code */, int  /* charset */);
d1037 1
d1048 1
@


1.30
log
@Update to xterm 293. Tested by naddy@@ ajacoutot@@
@
text
@d1 1
a1 1
/* $XTermId: xterm.h,v 1.718 2013/04/24 08:55:50 tom Exp $ */
d482 1
d511 1
d641 2
a642 2
#define XtCMkSamplePass 	"MkSamplePass"
#define XtCMkSampleSize 	"MkSampleSize"
d656 1
d684 1
d1004 1
@


1.29
log
@Update to xterm 291. Tested by many.
@
text
@d1 1
a1 1
/* $XTermId: xterm.h,v 1.716 2013/02/03 23:21:00 tom Exp $ */
d358 1
d544 1
d1268 1
a1268 1
extern void deleteScrollback (TScreen * /* screen */, int /* row */);
@


1.28
log
@Update to xterm 287. tested by mpi@@ and krw@@.
@
text
@d1 1
a1 1
/* $XTermId: xterm.h,v 1.710 2012/10/25 23:18:58 tom Exp $ */
d4 1
a4 1
 * Copyright 1999-2011,2012 by Thomas E. Dickey
d126 1
a126 1
#if defined(__UNIXOS2__) || defined(__SCO__) || defined(__UNIXWARE__)
d289 15
a303 1
#include <proto.h>
a343 4
#if defined(__UNIXOS2__) && !defined(XTERM_MAIN)
#define environ gblenvp		/* circumvent a bug */
#endif

a948 1
#ifndef __UNIXOS2__
a949 3
#else
#define ENVP_ARG , char ** /* envp */
#endif
d962 1
a962 3
#ifdef SIGNAL_T
extern SIGNAL_T Exit (int  /* n */) GCC_NORETURN;
#endif
a995 1
extern char *xtermVersion (void);
d1012 1
a1012 1
extern void Cleanup (int  /* code */);
d1022 1
@


1.27
log
@Update to xterm 279. Tested by krw@@, mpi@@, shadchin@@.
@
text
@d1 1
a1 1
/* $XTermId: xterm.h,v 1.694 2012/05/09 10:47:22 tom Exp $ */
d66 1
a168 1
#define USE_OPENPTY True
d172 1
a179 4
#if defined(__OpenBSD__)
#define DEFDELETE_DEL TRUE
#endif

d355 1
d376 1
d433 1
d457 1
d559 1
d610 1
d632 1
d961 1
a961 1
#define SIG_ATOMIC_T volatile sig_atomic_t
d979 2
d984 2
a985 2
extern Widget xtermOpenApplication(XtAppContext * /* app_context_return */, String /* application_class */, XrmOptionDescRec */* options */, Cardinal /* num_options */, int * /* argc_in_out */, String */* argv_in_out */, String * /* fallback_resources */, WidgetClass /* widget_class */, ArgList /* args */, Cardinal /* num_args */);
extern Window WMFrameWindow(XtermWidget /* termw */);
d987 2
a988 2
extern XrmOptionDescRec * sortedOptDescs(XrmOptionDescRec *, Cardinal);
extern XtermWidget getXtermWidget(Widget /* w */);
d991 2
a992 2
extern char *xtermFindShell(char * /* leaf */, Bool  /* warning */);
extern char *xtermVersion(void);
d995 1
a995 1
extern int ResetAnsiColorRequest(XtermWidget, char *, int);
d998 1
d1002 2
a1003 1
extern int xtermResetIds(TScreen *  /* screen */);
a1020 1
extern void ice_error (IceConn /* iceConn */);
d1033 1
d1044 2
a1045 1
extern void xtermEmbedWindow(Window /* winToEmbedInfo */);
a1110 1
extern void closePrinter (XtermWidget /* xw */);
d1160 8
d1177 1
a1177 1
extern void FullScreen (XtermWidget /* xw */, Bool /* enabled */);
d1313 1
d1316 1
d1396 1
a1396 1
		    VWindow(TScreenOf(xw)), \
@


1.26
log
@Update to xterm 278. Tested by mpi@@, shadchin@@
@
text
@d1 1
a1 1
/* $XTermId: xterm.h,v 1.673 2011/12/27 09:51:07 tom Exp $ */
d4 1
a4 1
 * Copyright 1999-2010,2011 by Thomas E. Dickey
d470 1
d481 1
a481 1
#define XtNretryInputMethod     "retryInputMethod"
d638 1
d649 1
a649 1
#define XtCRetryInputMethod     "RetryInputMethod"
d843 1
d858 4
d880 2
d883 6
a888 6
extern void CarriageReturn (TScreen * /* screen */);
extern void CursorBack (XtermWidget /* xw */, int   /* n */);
extern void CursorDown (TScreen * /* screen */, int   /* n */);
extern void CursorForward (TScreen * /* screen */, int   /* n */);
extern void CursorNextLine (TScreen * /* screen */, int  /* count */);
extern void CursorPrevLine (TScreen * /* screen */, int  /* count */);
d908 1
d997 1
d1153 1
a1153 1
extern Char * allocScrnData(TScreen * /* screen */, unsigned /* nrow */, unsigned /* ncol */);
d1160 2
a1161 1
extern void FullScreen(XtermWidget /* xw */, Bool /* enabled */);
d1205 1
a1205 1
#define ScrnAreLinesInSelection(screen, first, last) \
d1208 1
a1208 1
#define ScrnIsLineInSelection(screen, line) \
d1211 1
a1211 1
#define ScrnHaveLineMargins(screen) \
d1215 1
a1215 1
#define ScrnIsLineInMargins(screen, line) \
d1218 14
d1236 1
a1277 1
extern int AddToRefresh (XtermWidget /* xw */);
d1320 1
a1320 1
extern void ClearCurBackground (XtermWidget /* xw */, int  /* top */, int  /* left */, unsigned  /* height */, unsigned  /* width */);
d1376 8
a1383 6
#define ClearDFtBackground(xw, top, left, height, width) \
	ClearCurBackground(xw, top, left, height, width)

#define ClearCurBackground(xw, top, left, height, width) \
	XClearArea (TScreenOf(xw)->display, VWindow(TScreenOf(xw)), \
		left, top, width, height, False)
d1399 9
d1411 1
d1413 2
@


1.25
log
@Update to xterm 276. Tested by ajacoutot@@, krw@@, naddy@@, shadchin@@.
@
text
@d1 1
a1 1
/* $XTermId: xterm.h,v 1.662 2011/10/09 21:58:44 tom Exp $ */
d406 1
d516 1
d581 1
d682 1
d835 1
d855 4
d1026 1
d1030 1
d1058 7
d1153 1
d1158 1
d1282 2
d1286 1
@


1.24
log
@Update to xterm-275. Tested by jasper@@.
@
text
@d1 1
a1 1
/* $XTermId: xterm.h,v 1.661 2011/09/11 14:59:22 tom Exp $ */
d1234 1
@


1.23
log
@Update to xterm 273. Tested by marco@@, jasper@@.
@
text
@d1 1
a1 1
/* $XTermId: xterm.h,v 1.656 2011/08/20 00:20:20 tom Exp $ */
d3 29
a31 31
/************************************************************

Copyright 1999-2010,2011 by Thomas E. Dickey

                        All Rights Reserved

Permission is hereby granted, free of charge, to any person obtaining a
copy of this software and associated documentation files (the
"Software"), to deal in the Software without restriction, including
without limitation the rights to use, copy, modify, merge, publish,
distribute, sublicense, and/or sell copies of the Software, and to
permit persons to whom the Software is furnished to do so, subject to
the following conditions:

The above copyright notice and this permission notice shall be included
in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
IN NO EVENT SHALL THE ABOVE LISTED COPYRIGHT HOLDER(S) BE LIABLE FOR ANY
CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

Except as contained in this notice, the name(s) of the above copyright
holders shall not be used in advertising or otherwise to promote the
sale, use or other dealings in this Software without prior written
authorization.

********************************************************/
d483 1
d648 1
d958 1
d961 1
a965 1
extern char *xtermEnvLocale (void);
d1019 1
@


1.22
log
@Update to xterm 271. Tested by shadchin@@ and ajacoutot@@
@
text
@d1 1
a1 1
/* $XTermId: xterm.h,v 1.654 2011/07/12 08:39:49 tom Exp $ */
d958 1
d1015 1
d1043 8
@


1.21
log
@Update to xterm 270. Tested by ajacoutot@@, shadchin@@, krw@@ and jasper@@
@
text
@d1 1
a1 1
/* $XTermId: xterm.h,v 1.647 2011/04/23 12:15:04 tom Exp $ */
d828 1
a828 1
extern void VTReset (XtermWidget /* xw */, int /* full */, int /* saved */);
d952 3
d970 1
a970 1
extern int creat_as (uid_t  /* uid */, gid_t  /* gid */, Bool  /* append */, char * /* pathname */, int  /* mode */);
d1067 2
@


1.20
log
@Update to xterm version 269.
Tested and ok ajacoutot@@, jasper@@, krw@@, shadchin@@
@
text
@d1 1
a1 1
/* $XTermId: xterm.h,v 1.644 2011/02/20 00:49:16 tom Exp $ */
d349 1
d509 1
d526 1
d671 1
d934 1
a934 1
extern SIGNAL_T Exit (int  /* n */);
d988 1
d1056 1
a1056 1
extern PrinterFlags *getPrinterFlags(XtermWidget /* xw */, String * /* params */, Cardinal * /* param_count */);
d1058 1
@


1.19
log
@Update to xterm 267. Tested by shadchin@@, jasper@@, ajacoutot@@.
@
text
@d1 1
a1 1
/* $XTermId: xterm.h,v 1.637 2010/11/11 11:41:54 tom Exp $ */
d5 1
a5 1
Copyright 1999-2009,2010 by Thomas E. Dickey
d43 1
d49 4
d426 1
d554 1
a554 1
#define XtCCjkWidth 		"CjkWidth"
d596 1
d620 1
a620 1
#define XtCMkWidth 		"MkWidth"
d823 1
d985 1
a985 1
extern void SysError (int  /* i */) GCC_NORETURN;
d1092 4
a1095 4
#define nextPtyData(screen, data) (*((data)->next++) & \
					(screen->output_eight_bits \
					? 0xff \
					: 0x7f))
d1108 1
d1212 1
d1280 4
a1283 4
	 : (((screen)->colorULMode && ((flags) & UNDERLINE)) \
	    ? COLOR_UL \
	    : (((screen)->colorBDMode && ((flags) & BOLD)) \
	       ? COLOR_BD \
d1372 1
d1374 1
a1374 1
#endif	/* included_xterm_h */
@


1.18
log
@Update to xterm version 264, Tested at least by krw@@, jasper@@, ajacoutot@@.
@
text
@d1 1
a1 1
/* $XTermId: xterm.h,v 1.635 2010/10/12 08:55:47 tom Exp $ */
d738 1
a742 1
extern void HandleKeyboardSelectStop   PROTO_XT_ACTIONS_ARGS;
a747 1
extern void HandleSelectStop           PROTO_XT_ACTIONS_ARGS;
@


1.17
log
@Update to xterm 262.

tested by ajacoutot@@, jasper@@ and krw@@.
@
text
@d1 1
a1 1
/* $XTermId: xterm.h,v 1.630 2010/08/29 22:42:57 tom Exp $ */
d488 1
d648 1
d724 1
a724 1
#define	MotionOff( s, t ) {						\
d742 1
d748 1
d832 1
a832 1
extern void v_write (int  /* f */, Char * /* d */, unsigned  /* len */);
d1112 1
@


1.16
log
@Update to xterm 261. Tested by krw@@, jcs@@.
@
text
@d1 1
a1 1
/* $XTermId: xterm.h,v 1.628 2010/06/20 21:34:48 tom Exp $ */
d805 1
a818 1
extern void set_cursor_gcs (XtermWidget /* xw */);
d977 1
d979 1
@


1.15
log
@Update to xterm 258. lightly tested by krw@@, thanks.
@
text
@d1 1
a1 1
/* $XTermId: xterm.h,v 1.625 2010/04/18 17:10:42 tom Exp $ */
d885 1
a885 1
extern void StringInput (XtermWidget /* xw */, Char * /* string */, size_t  /* nbytes */);
d957 1
a957 1
extern void Bell (int  /* which */, int  /* percent */);
d1029 3
a1031 3
extern void StartLog (TScreen * /* screen */);
extern void CloseLog (TScreen * /* screen */);
extern void FlushLog (TScreen * /* screen */);
d1033 1
a1033 1
#define FlushLog(screen) /*nothing*/
d1054 2
a1055 2
extern int readPtyData (TScreen * /* screen */, PtySelect * /* select_mask */, PtyData * /* data */);
extern void fillPtyData (TScreen * /* screen */, PtyData * /* data */, char * /* value */, int  /* length */);
d1057 1
a1057 1
extern void trimPtyData (TScreen * /* screen */, PtyData * /* data */);
@


1.14
log
@Update to xterm-255. Tested by stsp@@, oga@@.
@
text
@d1 1
a1 1
/* $XTermId: xterm.h,v 1.608 2010/01/20 01:36:37 tom Exp $ */
d58 1
a58 1
#define IGNORE_RC(func) ignore_unused = func
d347 1
d520 1
d777 2
a778 3
#define FIRST_WIDECHAR 256
#define WideCells(n) (((IChar)(n) >= FIRST_WIDECHAR) ? my_wcwidth((wchar_t) (n)) : 1)
#define isWide(n)    (((IChar)(n) >= FIRST_WIDECHAR) && iswide(n))
a805 1
extern int v_write (int  /* f */, Char * /* d */, unsigned  /* len */);
d828 1
d927 1
d937 1
a937 1
extern Bool AllocateTermColor(XtermWidget, ScrnColors *, int, const char *);
d977 1
a977 1
extern void do_osc (XtermWidget /* xw */, Char * /* buf */, unsigned  /* len */, int  /* final */);
d1009 13
d1105 1
a1105 1
extern void ScrnWriteText (XtermWidget /* xw */, IChar * /* str */, unsigned  /* flags */, CellColor /* cur_fg_bg */, unsigned  /* length */);
d1173 1
a1173 1
extern void WindowScroll (XtermWidget /* xw */, int  /* top */);
d1192 1
a1192 1
extern GC updatedXtermGC (XtermWidget /* xw */, unsigned  /* flags */, CellColor /* fg_bg */, Bool  /* hilite */);
d1210 1
a1210 1
extern void decode_wcwidth (int  /* mode */, int /* samplesize */, int /* samplepass */);
d1228 2
a1229 2
extern unsigned extract_fg (XtermWidget /* xw */, CellColor  /* color */, unsigned  /* flags */);
extern unsigned extract_bg (XtermWidget /* xw */, CellColor  /* color */, unsigned  /* flags */);
d1275 1
a1275 1
		 flags &= ~(attr)
d1349 3
@


1.13
log
@Update to xterm 250
@
text
@d1 1
a1 1
/* $XTermId: xterm.h,v 1.589 2009/10/12 00:34:48 tom Exp $ */
d5 1
a5 1
Copyright 1999-2008,2009 by Thomas E. Dickey
d345 1
d394 4
d469 1
d494 1
d517 1
d561 4
d628 1
d651 1
d746 1
a746 1
extern void TrackMouse (XtermWidget /* xw */, int /* func */, CELL *  /* start */, int  /* firstrow */, int  /* lastrow */);
d749 2
d765 1
a765 1
extern void CompleteSelection (XtermWidget  /* xw */, char ** /* args */, Cardinal  /* len */);
d810 1
a810 1
extern void SwitchBufPtrs (TScreen * /* screen */);
d948 1
d1023 1
d1028 2
a1029 2
extern void xtermPrintScreen (XtermWidget /* xw */, Bool  /* use_DECPEX */);
extern void xtermPrintEverything (XtermWidget /* xw */);
d1222 2
a1223 2
			? GET_COLOR_RES(xw->screen.Acolors[color]) \
			: T_COLOR(&(xw->screen), TEXT_FG))
d1227 2
a1228 2
			? GET_COLOR_RES(xw->screen.Acolors[color]) \
			: T_COLOR(&(xw->screen), TEXT_BG))
d1231 1
a1231 1
#define GET_COLOR_RES(res) xtermGetColorRes(&(res))
d1235 1
a1235 1
extern Pixel xtermGetColorRes(ColorRes *res);
d1237 1
a1237 1
#define GET_COLOR_RES(res) res
d1246 9
d1270 2
d1276 1
a1276 1
	XClearArea (xw->screen.display, VWindow(&(xw->screen)), \
d1284 2
a1285 2
#define getXtermBackground(xw, flags, color) T_COLOR(&(xw->screen), TEXT_BG)
#define getXtermForeground(xw, flags, color) T_COLOR(&(xw->screen), TEXT_FG)
d1300 1
a1300 1
		(Boolean) ((sel) != T_COLOR(&((xw)->screen), TEXT_FG) \
d1305 1
a1305 1
		(Boolean) ((sel) != T_COLOR(&((xw)->screen), TEXT_BG) \
@


1.12
log
@Update to xterm 248, fixing several bugs including a regression with
copy-and-paste. Works for martynas@@, ok matthieu@@
@
text
@d1 1
a1 1
/* $XTermId: xterm.h,v 1.582 2009/09/10 09:01:22 tom Exp $ */
d56 7
d412 1
d572 1
d760 4
a763 1
#define isWide(n) ((int) (n) >= FIRST_WIDECHAR && iswide(n))
d792 1
d810 1
a810 1
extern void unparseputs (XtermWidget /* xw */, char * /* s */);
d952 1
a952 1
extern void Panic (char * /* s */, int  /* a */);
d974 1
a974 1
extern void xtermSetenv (char * /* var */, char * /* value */);
@


1.11
log
@update to xterm 246. Has been in snapshots for some time.
@
text
@d1 1
a1 1
/* $XTermId: xterm.h,v 1.581 2009/08/08 14:04:16 tom Exp $ */
a1251 1
#define XTERM_CELLC(row,col,n) getXtermCellComb(screen, ROW2INX(screen, row), col, n)
a1273 1
extern unsigned getXtermCellComb (TScreen * /* screen */, int  /* row */, int  /* col */, unsigned /* off */);
@


1.10
log
@Update to xterm 243. tested by naddy@@.

Patch #243 - 2009/3/28

* revert change to default for allowTcapOps (request by Bram Moolenaar).
* reallocate result returned by xtermEnvLocale() to avoid reference to
freed memory after handling menuLocale resource.
* fix an old (X11R5) bug in tek4014 for switching fontsizes.
* add resource defaultString to make configurable the use of "#" when
pastes of UTF-8 text fail due to limitations in the current locale settings.
* make the set of selection target Atom's configurable by two new
resources eightBitSelectTypes and utf8SelectTypes, e.g., to use the TEXT
Atom in preference to UTF8_STRING (discussion with Stanislav Sedov
regarding koi8rxterm and the FreeBSD port).
* modify handling of TARGETS Atom by making it return exactly the set of
targets as those which xterm is currently providing.
* set MANPAGER and PAGER explicitly to /bin/cat in minstall.sh to work
around /etc/man.conf's with those variables already set (report by
Mar'yasin Semion).
* improve error-checking of tcap-query parser.
* add check for keyboard tcap), which ensures that terminal descriptions
containing the same string for shifted/unshifted keys will be seen by
tcap-query as only the unshifted key. (This would only happen with an
incorrect terminal description).
* fix conversion for input event-state to modifier-parameter which made
tcap-query feature not work with tcapFunctionKeys (keyboard type tcap).
* add "DEF_ALLOW_XXX" definitions to main.h to allow overriding the
default compiled-in values for "allowxxx" resources.
* remove check on bell-percentage added in patch #242, which disallowed
zero/negative values (Redhat Bugzilla #487829).
@
text
@d1 1
a1 1
/* $XTermId: xterm.h,v 1.523 2009/03/28 14:56:54 tom Exp $ */
a276 2
#define HIDDEN_HI 0xff
#define HIDDEN_LO 0xff
d394 1
d459 1
d553 1
d610 1
d692 1
a692 1
extern void TekSetFontSize (TekWidget /* tw */, int  /* newitem */);
d751 1
a751 1
#define isWide(n) ((n) >= FIRST_WIDECHAR && iswide(n))
d776 1
a776 1
extern int VTInit (void);
d784 1
a784 1
extern void VTRun (void);
d861 9
d992 7
a998 6
extern Bool xtermHasPrinter (void);
extern int xtermPrinterControl (int  /* chr */);
extern void setPrinterControlMode (int  /* mode */);
extern void xtermAutoPrint (unsigned  /* chr */);
extern void xtermMediaControl (int  /* param */, int  /* private_seq */);
extern void xtermPrintScreen (Bool  /* use_DECPEX */);
a1017 1
extern Bool morePtyData (TScreen * /* screen */, PtyData * /* data */);
d1024 7
d1042 3
a1044 1
extern ScrnBuf Allocate (int  /* nrow */, int  /* ncol */, Char ** /* addr */);
d1049 1
d1052 1
a1052 1
extern void ScrnDeleteLine (XtermWidget /* xw */, ScrnBuf  /* sb */, int  /* n */, int  /* last */, unsigned  /* size */, unsigned  /* where */);
d1056 1
a1056 1
extern void ScrnInsertLine (XtermWidget /* xw */, ScrnBuf  /* sb */, int  /* last */, int  /* where */, unsigned  /* n */, unsigned  /* size */);
d1059 2
a1060 1
extern void ScrnWriteText (XtermWidget /* xw */, IChar * /* str */, unsigned  /* flags */, unsigned  /* cur_fg_bg */, unsigned  /* length */);
d1064 3
a1066 3
extern int  ScrnTstFlag(TScreen * /* screen */, int /* row */, int /* flag */);
extern void ScrnClrFlag(TScreen * /* screen */, int /* row */, int /* flag */);
extern void ScrnSetFlag(TScreen * /* screen */, int /* row */, int /* flag */);
d1068 7
a1074 11
#define ScrnClrFlag(screen, row, flag) \
	SCRN_BUF_FLAGS(screen, row) = \
		(Char *)((long)SCRN_BUF_FLAGS(screen, row) & ~ (flag))

#define ScrnSetFlag(screen, row, flag) \
	SCRN_BUF_FLAGS(screen, row) = \
		(Char *)(((long)SCRN_BUF_FLAGS(screen, row) | (flag)))

#define ScrnTstFlag(screen, row, flag) \
	(okScrnRow(screen, row) && \
	 ((long)SCRN_BUF_FLAGS(screen, row) & (flag)) != 0)
d1077 7
a1083 7
#define ScrnClrBlinked(screen, row) ScrnClrFlag(screen, ROW2INX(screen, row), BLINK)
#define ScrnSetBlinked(screen, row) ScrnSetFlag(screen, ROW2INX(screen, row), BLINK)
#define ScrnTstBlinked(screen, row) ScrnTstFlag(screen, ROW2INX(screen, row), BLINK)

#define ScrnClrWrapped(screen, row) ScrnClrFlag(screen, ROW2INX(screen, row), LINEWRAPPED)
#define ScrnSetWrapped(screen, row) ScrnSetFlag(screen, ROW2INX(screen, row), LINEWRAPPED)
#define ScrnTstWrapped(screen, row) ScrnTstFlag(screen, ROW2INX(screen, row), LINEWRAPPED)
d1112 5
d1124 1
a1124 1
extern void ScrollBarOn (XtermWidget  /* xw */, int  /* init */, int  /* doalloc */);
d1146 1
a1146 1
extern GC updatedXtermGC (XtermWidget /* xw */, unsigned  /* flags */, unsigned  /* fg_bg */, Bool  /* hilite */);
d1150 1
a1150 2
extern int drawXtermIChars(XtermWidget /* xw */, unsigned /* flags */, GC /* gc */, int /* x */, int /* y */, int /* chrset */, IChar * /* text */, Cardinal /* len */, int /* on_wide */);
extern int drawXtermText (XtermWidget /* xw */, unsigned  /* flags */, GC  /* gc */, int  /* x */, int  /* y */, int  /* chrset */, PAIRED_CHARS(Char * /* text */, Char * /* text2 */), Cardinal  /* len */, int  /* on_wide */);
d1182 3
a1184 3
extern unsigned extract_fg (XtermWidget /* xw */, unsigned  /* color */, unsigned  /* flags */);
extern unsigned extract_bg (XtermWidget /* xw */, unsigned  /* color */, unsigned  /* flags */);
extern unsigned makeColorPair (int  /* fg */, int  /* bg */);
d1212 2
a1213 7
#if OPT_EXT_COLORS
#define ExtractForeground(color) ((color >> 8) & 0xff)
#define ExtractBackground(color) (color & 0xff)
#else
#define ExtractForeground(color) ((color >> 4) & 0xf)
#define ExtractBackground(color) (color & 0xf)
#endif
a1250 9
#if OPT_DEC_CHRSET
#define curXtermChrSet(xw, row) \
	((CSET_DOUBLE(SCRN_ROW_CSET((&xw->screen), row))) \
		? SCRN_ROW_CSET((&xw->screen), row) \
		: (xw->screen).cur_chrset)
#else
#define curXtermChrSet(xw, row) 0
#endif

d1275 1
a1275 1
extern unsigned getXtermCellComb (TScreen * /* screen */, int  /* row */, int  /* col */, int /* off */);
d1277 1
a1277 1
extern void allocXtermChars(Char ** /* buffer */, Cardinal /* length */);
@


1.9
log
@Update to xterm 242. Tested by jsg@@.
@
text
@d1 1
a1 1
/* $XTermId: xterm.h,v 1.520 2009/02/13 23:39:20 tom Exp $ */
d386 1
d392 1
d417 1
a417 1
#define XtNitalicULMode         "italicULMode"
d429 1
a429 1
#define XtNmaximized            "maximized"
d486 1
d530 1
a530 1
#define XtCColorAttrMode        "ColorAttrMode"
d543 1
d549 1
d582 1
a582 1
#define XtCMaximized            "Maximized"
d633 1
d675 1
@


1.8
log
@xterm 238. includes fix for CVE-2008-2383.
@
text
@d1 1
a1 1
/* $XTermId: xterm.h,v 1.507 2008/12/30 15:46:41 tom Exp $ */
d5 1
a5 1
Copyright 1999-2007,2008 by Thomas E. Dickey
d402 1
d427 1
d556 1
d577 1
d741 2
d842 2
a843 2
extern int xtermParamToState (XtermWidget /* xw */, unsigned /* param */);
extern int xtermStateToParam (XtermWidget /* xw */, unsigned /* state */);
d893 1
d907 3
a909 3
extern void Bell (Atom  /* which */, int  /* percent */);
extern void ChangeIconName (char * /* name */);
extern void ChangeTitle (char * /* name */);
d940 1
d1031 1
a1031 1
extern void ScrnWriteText (XtermWidget /* xw */, PAIRED_CHARS(Char * /* str */, Char * /* str2 */), unsigned  /* flags */, unsigned  /* cur_fg_bg */, unsigned  /* length */);
d1120 1
d1133 1
a1133 1
extern void WriteText (XtermWidget /* xw */, PAIRED_CHARS(Char * /* str */, Char * /* str2 */), Cardinal /* len */);
d1262 1
d1272 1
a1272 1
unsigned visual_width(PAIRED_CHARS(Char * /* str */, Char * /* str2 */), Cardinal  /* len */);
@


1.7
log
@xterm 237. tested by krw@@ oga@@ and others.
@
text
@d1 1
a1 1
/* $XTermId: xterm.h,v 1.503 2008/09/14 15:18:39 Paul.Lampert Exp $ */
d340 1
d342 1
d497 1
d499 1
a1111 1
extern int char2lower (int  /* ch */);
d1235 4
a1238 4
		((sel) != T_COLOR(&((xw)->screen), TEXT_FG) \
		 && (sel) != (fg) \
		 && (sel) != (bg) \
		 && (sel) != (xw)->dft_foreground)
d1240 4
a1243 4
		((sel) != T_COLOR(&((xw)->screen), TEXT_BG) \
		 && (sel) != (fg) \
		 && (sel) != (bg) \
		 && (sel) != (xw)->dft_background)
@


1.6
log
@xterm-236. Tested by form@@ and simon@@.
@
text
@d1 1
a1 1
/* $XTermId: xterm.h,v 1.502 2008/05/26 19:23:05 tom Exp $ */
d380 1
d530 1
@


1.5
log
@Merge xterm 232.
New local change: default value for pointerMode is 0.
@
text
@d1 1
a1 1
/* $XTermId: xterm.h,v 1.498 2008/01/30 00:50:07 tom Exp $ */
d400 1
a438 1
#define XtNpointerMode		"pointerMode"
d441 1
d549 1
d754 1
d795 1
a795 1
extern int xtermCharSetOut (IChar * /* buf */, IChar * /* ptr */, int  /* charset */);
d798 1
@


1.4
log
@update to xterm 229. Tested on various architectures by aanriot@@
@
text
@d1 1
a1 3
/* $XTermId: xterm.h,v 1.482 2007/07/22 20:14:48 tom Exp $ */

/* $XFree86: xc/programs/xterm/xterm.h,v 3.117 2006/06/19 00:36:52 dickey Exp $ */
d5 1
a5 1
Copyright 1999-2006,2007 by Thomas E. Dickey
d335 2
d402 1
d412 1
d438 1
d449 1
d549 1
d556 1
d581 1
d589 1
d689 1
d737 2
a738 2
extern XFontStruct * getCgsFont(XtermWidget /*xw*/, VTwin * /*cgsWin*/, GC /*gc*/);
extern void clrCgsFonts(XtermWidget /*xw*/, VTwin * /*cgsWin*/, XFontStruct * /*font*/);
d743 1
a743 1
extern void setCgsFont(XtermWidget /*xw*/, VTwin * /*cgsWin*/, CgsEnum /*cgsId*/, XFontStruct * /*font*/);
d754 1
a754 1
extern void FindFontSelection (XtermWidget /* xw */, char * /* atom_name */, Bool  /* justprobe */);
d822 1
a822 1
extern GC xterm_DoubleGC(XtermWidget /* xw */, unsigned  /* chrset */, unsigned  /* flags */, GC  /* old_gc */);
d826 2
d924 1
d926 1
d1008 1
a1008 1
extern void ScrnFillRectangle (XtermWidget /* xw */, XTermRect *,  int ,  unsigned);
d1096 2
d1238 1
d1258 1
a1258 1
#define BtoS(b)    ((b) ? "on" : "off")
@


1.3
log
@Merge xterm version 225
@
text
@d1 1
a1 1
/* $XTermId: xterm.h,v 1.461 2007/03/20 23:56:57 tom Exp $ */
a68 8
#ifndef HAVE_X11_DECKEYSYM_H
#define HAVE_X11_DECKEYSYM_H 1
#endif

#ifndef HAVE_X11_SUNKEYSYM_H
#define HAVE_X11_SUNKEYSYM_H 1
#endif

d216 12
d331 1
a331 1
#if !defined(VMS) && !(defined(linux) && defined(__USE_GNU)) && !defined(__hpux) && !defined(_ALL_SOURCE) && !defined(__osf__) 
d341 1
d402 1
d423 2
d490 1
d545 1
d563 2
d738 4
d836 2
d839 3
d862 1
a862 1
extern Cursor make_colored_cursor (unsigned  /* cursorindex */, unsigned long  /* fg */, unsigned long  /* bg */);
d864 1
a864 1
extern Window WMFrameWindow(XtermWidget  /* termw */);
d866 1
a866 2
extern char *SysErrorMsg (int  /* n */);
extern char *udk_lookup (int  /* keycode */, int * /* len */);
d871 2
d912 1
d990 2
a991 1
extern void ScreenWrite (XtermWidget /* xw */, PAIRED_CHARS(Char * /* str */, Char * /* str2 */), unsigned  /* flags */, unsigned  /* cur_fg_bg */, unsigned  /* length */);
d994 1
d1000 1
a1000 1
extern void ScrnDisownSelection (XtermWidget /* xw */);
d1003 5
d1009 2
a1010 2
	SCRN_BUF_FLAGS(screen, ROW2INX(screen, row)) = \
		(Char *)((long)SCRN_BUF_FLAGS(screen, ROW2INX(screen, row)) & ~ (flag))
d1013 2
a1014 2
	SCRN_BUF_FLAGS(screen, ROW2INX(screen, row)) = \
		(Char *)(((long)SCRN_BUF_FLAGS(screen, ROW2INX(screen, row)) | (flag)))
d1017 11
a1027 9
	(ROW2INX(screen, row + screen->savelines) >= 0 && ((long)SCRN_BUF_FLAGS(screen, ROW2INX(screen, row)) & (flag)) != 0)

#define ScrnClrBlinked(screen, row) ScrnClrFlag(screen, row, BLINK)
#define ScrnSetBlinked(screen, row) ScrnSetFlag(screen, row, BLINK)
#define ScrnTstBlinked(screen, row) ScrnTstFlag(screen, row, BLINK)

#define ScrnClrWrapped(screen, row) ScrnClrFlag(screen, row, LINEWRAPPED)
#define ScrnSetWrapped(screen, row) ScrnSetFlag(screen, row, LINEWRAPPED)
#define ScrnTstWrapped(screen, row) ScrnTstFlag(screen, row, LINEWRAPPED)
d1084 2
a1085 1
extern int AddToRefresh (TScreen * /* screen */);
d1100 1
d1102 1
a1102 1
extern void decode_wcwidth (int  /* mode */);
d1223 2
a1226 2
extern unsigned getXtermCellComb1 (TScreen * /* screen */, int  /* row */, int  /* col */);
extern unsigned getXtermCellComb2 (TScreen * /* screen */, int  /* row */, int  /* col */);
@


1.2
log
@OpenBSD local changes
@
text
@d1 1
a1 1
/* $XTermId: xterm.h,v 1.415 2006/08/03 23:43:39 tom Exp $ */
d7 1
a7 1
Copyright 1999-2005,2006 by Thomas E. Dickey
d167 5
a171 5
#define USE_UTMP_SETGID TRUE
#define USE_OPENPTY TRUE
#define DEFDELETE_DEL TRUE
#define DEF_BACKARO_ERASE TRUE
#define DEF_INITIAL_ERASE TRUE
d175 1
a175 1
#define DEFDELETE_DEL TRUE
d331 2
d338 3
d349 1
d398 1
d401 1
d463 1
d483 3
d494 1
d539 1
d593 1
d619 1
d624 1
d636 2
d640 5
a644 4
extern void ChangeTekColors (TScreen * /* screen */, ScrnColors * /* pNew */);
extern void TCursorToggle (int  /* toggle */);
extern void TekCopy (void);
extern void TekEnqMouse (int  /* c */);
d646 4
a649 2
extern void TekGINoff (void);
extern void TekReverseVideo (TScreen * /* screen */);
d651 3
a653 3
extern void TekSetFontSize (int  /* newitem */);
extern void TekSimulatePageButton (Bool  /* reset */);
extern void dorefresh (void);
a668 1
extern void HandleGINInput             PROTO_XT_ACTIONS_ARGS;
d689 6
d710 16
d737 2
d792 3
a794 3
extern void xterm_DECDHL (Bool  /* top */);
extern void xterm_DECSWL (void);
extern void xterm_DECDWL (void);
d796 2
a797 2
extern int xterm_Double_index(unsigned  /* chrset */, unsigned  /* flags */);
extern GC xterm_DoubleGC(unsigned  /* chrset */, unsigned  /* flags */, GC  /* old_gc */);
a808 4
#if OPT_TCAP_QUERY
extern int xtermcapKeycode(XtermWidget /* xw */, char ** /* params */, unsigned * /* state */, Bool * /* fkey */);
#endif

d858 2
a860 2
extern void Changename (char * /* name */);
extern void Changetitle (char * /* name */);
d869 1
d934 1
d948 2
d1030 1
a1030 1
extern void ScrollBarOff (TScreen * /* screen */);
d1033 2
a1034 2
extern void ToggleScrollBar (XtermWidget  /* w */);
extern void WindowScroll (TScreen * /* screen */, int  /* top */);
a1055 1
extern void ChangeAnsiColors (XtermWidget  /* xw */);
d1071 1
d1079 2
d1106 1
d1112 1
d1139 3
d1144 1
a1144 1
		left, top, width, height, FALSE)
d1175 13
d1189 1
@


1.1
log
@Initial revision
@
text
@d167 2
d179 4
d786 1
a786 1
#define SIG_ATOMIC_T int
@


1.1.1.1
log
@Importing xterm 216
@
text
@@


1.1.1.2
log
@import xterm 225
@
text
@d1 1
a1 1
/* $XTermId: xterm.h,v 1.461 2007/03/20 23:56:57 tom Exp $ */
d7 1
a7 1
Copyright 1999-2006,2007 by Thomas E. Dickey
d167 3
a169 3
#define DEFDELETE_DEL True
#define DEF_BACKARO_ERASE True
#define DEF_INITIAL_ERASE True
d173 1
a173 1
#define DEFDELETE_DEL True
a324 2
#define XK_Fn(n)	(XK_F1 + (n) - 1)

a329 3
#define XtNaltIsNotMeta		"altIsNotMeta"
#define XtNaltSendsEscape	"altSendsEscape"
#define XtNalwaysBoldMode	"alwaysBoldMode"
a337 1
#define XtNbellIsUrgent		"bellIsUrgent"
a385 1
#define XtNhighlightTextColor	"highlightTextColor"
a387 1
#define XtNinitialFont		"initialFont"
a448 1
#define XtNuseClipping		"useClipping"
a467 3
#define XtCAltIsNotMeta		"AltIsNotMeta"
#define XtCAltSendsEscape	"AltSendsEscape"
#define XtCAlwaysBoldMode	"AlwaysBoldMode"
a475 1
#define XtCBellIsUrgent		"BellIsUrgent"
a519 1
#define XtCInitialFont		"InitialFont"
a572 1
#define XtCUseClipping		"UseClipping"
a597 1
#define XtCHighlightTextColor	"HighlightTextColor"
a601 1
#define XtCHighlightTextColor	XtCBackground
a612 2
#if OPT_TEK4014
extern int TekGetFontSize (const char * /* param */);
d615 4
a618 5
extern void ChangeTekColors (TekWidget /* tw */, TScreen * /* screen */, ScrnColors * /* pNew */);
extern void HandleGINInput             PROTO_XT_ACTIONS_ARGS;
extern void TCursorToggle (TekWidget /* tw */, int /* toggle */);
extern void TekCopy (TekWidget /* tw */);
extern void TekEnqMouse (TekWidget /* tw */, int /* c */);
d620 2
a621 4
extern void TekGINoff (TekWidget /* tw */);
extern void TekRefresh (TekWidget /* tw */);
extern void TekRepaint (TekWidget /* xw */);
extern void TekReverseVideo (TekWidget /* tw */);
d623 3
a625 3
extern void TekSetFontSize (TekWidget /* tw */, int  /* newitem */);
extern void TekSimulatePageButton (TekWidget /* tw */, Bool /* reset */);
#endif
d641 1
a661 6
#if OPT_FOCUS_EVENT
extern void SendFocusButton(XtermWidget /* xw */, XFocusChangeEvent * /* event */);
#else
#define SendFocusBotton(xw, event) /* nothing */
#endif

a676 16
/* cachedCgs.c */
extern CgsEnum getCgsId(XtermWidget /*xw*/, VTwin * /*cgsWin*/, GC /*gc*/);
extern GC freeCgs(XtermWidget /*xw*/, VTwin * /*cgsWin*/, CgsEnum /*cgsId*/);
extern GC getCgsGC(XtermWidget /*xw*/, VTwin * /*cgsWin*/, CgsEnum /*cgsId*/);
extern Pixel getCgsBack(XtermWidget /*xw*/, VTwin * /*cgsWin*/, GC /*gc*/);
extern Pixel getCgsFore(XtermWidget /*xw*/, VTwin * /*cgsWin*/, GC /*gc*/);
extern XFontStruct * getCgsFont(XtermWidget /*xw*/, VTwin * /*cgsWin*/, GC /*gc*/);
extern void clrCgsFonts(XtermWidget /*xw*/, VTwin * /*cgsWin*/, XFontStruct * /*font*/);
extern void copyCgs(XtermWidget /*xw*/, VTwin * /*cgsWin*/, CgsEnum /*dstCgsId*/, CgsEnum /*srcCgsId*/);
extern void redoCgs(XtermWidget /*xw*/, Pixel /*fg*/, Pixel /*bg*/, CgsEnum /*cgsId*/);
extern void setCgsBack(XtermWidget /*xw*/, VTwin * /*cgsWin*/, CgsEnum /*cgsId*/, Pixel /*bg*/);
extern void setCgsCSet(XtermWidget /*xw*/, VTwin * /*cgsWin*/, CgsEnum /*cgsId*/, unsigned /*cset*/);
extern void setCgsFont(XtermWidget /*xw*/, VTwin * /*cgsWin*/, CgsEnum /*cgsId*/, XFontStruct * /*font*/);
extern void setCgsFore(XtermWidget /*xw*/, VTwin * /*cgsWin*/, CgsEnum /*cgsId*/, Pixel /*fg*/);
extern void swapCgs(XtermWidget /*xw*/, VTwin * /*cgsWin*/, CgsEnum /*dstCgsId*/, CgsEnum /*srcCgsId*/);

a687 2
extern void releaseCursorGCs(XtermWidget /*xw*/);
extern void releaseWindowGCs(XtermWidget /*xw*/, VTwin * /*win*/);
d741 3
a743 3
extern void xterm_DECDHL (XtermWidget /* xw */, Bool  /* top */);
extern void xterm_DECSWL (XtermWidget /* xw */);
extern void xterm_DECDWL (XtermWidget /* xw */);
d745 2
a746 2
extern int xterm_Double_index(XtermWidget /* xw */, unsigned  /* chrset */, unsigned  /* flags */);
extern GC xterm_DoubleGC(XtermWidget /* xw */, unsigned  /* chrset */, unsigned  /* flags */, GC  /* old_gc */);
d758 4
a810 2
extern void ChangeIconName (char * /* name */);
extern void ChangeTitle (char * /* name */);
d812 2
a821 1
extern void HandleSpawnTerminal        PROTO_XT_ACTIONS_ARGS;
a885 1
extern Bool decodeUtf8 (PtyData * /* data */);
a898 2
extern IChar skipPtyData (PtyData * /* data */);
extern PtyData * fakePtyData(PtyData * /* result */, Char * /* next */, Char * /* last */);
d979 1
a979 1
extern void ScrollBarOff (XtermWidget  /* xw */);
d982 2
a983 2
extern void ToggleScrollBar (XtermWidget  /* xw */);
extern void WindowScroll (XtermWidget /* xw */, int  /* top */);
d1005 1
a1020 1
extern void getXtermSizeHints (XtermWidget /* xw */);
a1027 2
extern void xtermClear (XtermWidget /* xw */);
extern void xtermRepaint (XtermWidget /* xw */);
a1052 1
#define EQL_COLOR_RES(res,color) (res)->value == color
a1057 1
#define EQL_COLOR_RES(res,color) *res == color
a1083 3
#define ClearDFtBackground(xw, top, left, height, width) \
	ClearCurBackground(xw, top, left, height, width)

d1086 1
a1086 1
		left, top, width, height, False)
a1116 13
#if OPT_HIGHLIGHT_COLOR
#define isNotForeground(xw, fg, bg, sel) \
		((sel) != T_COLOR(&((xw)->screen), TEXT_FG) \
		 && (sel) != (fg) \
		 && (sel) != (bg) \
		 && (sel) != (xw)->dft_foreground)
#define isNotBackground(xw, fg, bg, sel) \
		((sel) != T_COLOR(&((xw)->screen), TEXT_BG) \
		 && (sel) != (fg) \
		 && (sel) != (bg) \
		 && (sel) != (xw)->dft_background)
#endif

a1117 1
extern unsigned AsciiEquivs(unsigned /* ch */);
@


1.1.1.3
log
@import xterm 229
@
text
@d1 1
a1 1
/* $XTermId: xterm.h,v 1.482 2007/07/22 20:14:48 tom Exp $ */
d69 8
a217 12
#ifndef HAVE_X11_DECKEYSYM_H
#define HAVE_X11_DECKEYSYM_H 1
#endif

#ifndef HAVE_X11_SUNKEYSYM_H
#define HAVE_X11_SUNKEYSYM_H 1
#endif

#ifndef HAVE_X11_XF86KEYSYM_H
#define HAVE_X11_XF86KEYSYM_H 0
#endif

d321 1
a321 1
#if !defined(VMS) && !(defined(linux) && defined(__USE_GNU)) && !defined(__hpux) && !defined(_ALL_SOURCE) && !defined(__osf__)
a330 1
#define XtNallowTitleOps	"allowTitleOps"
a390 1
#define XtNhighlightReverse	"highlightReverse"
a410 2
#define XtNmkSamplePass		"mkSamplePass"
#define XtNmkSampleSize		"mkSampleSize"
a475 1
#define XtCAllowTitleOps	"AllowTitleOps"
a529 1
#define XtCHighlightReverse	"HighlightReverse"
a546 2
#define XtCMkSamplePass 	"MkSamplePass"
#define XtCMkSampleSize 	"MkSampleSize"
a719 4
#ifdef NO_LEAKS
extern void noleaks_cachedCgs (XtermWidget /* xw */);
#endif

a813 2

#if OPT_PTY_HANDSHAKE
a814 3
#else
#define first_map_occurred() /* nothing */
#endif
d835 1
a835 1
extern Cursor make_colored_cursor (unsigned /* cursorindex */, unsigned long  /* fg */, unsigned long  /* bg */);
d837 1
a837 1
extern Window WMFrameWindow(XtermWidget /* termw */);
d839 2
a840 1
extern char *udk_lookup (int /* keycode */, int * /* len */);
a844 2
extern const char *SysErrorMsg (int /* n */);
extern const char *SysReasonMsg (int /* n */);
a883 1
extern void xtermCopyEnv (char ** /* oldenv */);
d961 1
a961 2
extern void ClearCells (XtermWidget /* xw */, int /* flags */, unsigned /* len */, int /* row */, int /* col */);
extern void ScrnClearCells (XtermWidget /* xw */, int /* row */, int /* col */, unsigned /* len */);
a963 1
extern void ScrnDisownSelection (XtermWidget /* xw */);
d969 1
a969 1
extern void ScrnWriteText (XtermWidget /* xw */, PAIRED_CHARS(Char * /* str */, Char * /* str2 */), unsigned  /* flags */, unsigned  /* cur_fg_bg */, unsigned  /* length */);
a971 5
#if OPT_TRACE && OPT_TRACE_FLAGS
extern int  ScrnTstFlag(TScreen * /* screen */, int /* row */, int /* flag */);
extern void ScrnClrFlag(TScreen * /* screen */, int /* row */, int /* flag */);
extern void ScrnSetFlag(TScreen * /* screen */, int /* row */, int /* flag */);
#else
d973 2
a974 2
	SCRN_BUF_FLAGS(screen, row) = \
		(Char *)((long)SCRN_BUF_FLAGS(screen, row) & ~ (flag))
d977 2
a978 2
	SCRN_BUF_FLAGS(screen, row) = \
		(Char *)(((long)SCRN_BUF_FLAGS(screen, row) | (flag)))
d981 9
a989 11
	(okScrnRow(screen, row) && \
	 ((long)SCRN_BUF_FLAGS(screen, row) & (flag)) != 0)
#endif /* OPT_TRACE && OPT_TRACE_FLAGS */

#define ScrnClrBlinked(screen, row) ScrnClrFlag(screen, ROW2INX(screen, row), BLINK)
#define ScrnSetBlinked(screen, row) ScrnSetFlag(screen, ROW2INX(screen, row), BLINK)
#define ScrnTstBlinked(screen, row) ScrnTstFlag(screen, ROW2INX(screen, row), BLINK)

#define ScrnClrWrapped(screen, row) ScrnClrFlag(screen, ROW2INX(screen, row), LINEWRAPPED)
#define ScrnSetWrapped(screen, row) ScrnSetFlag(screen, ROW2INX(screen, row), LINEWRAPPED)
#define ScrnTstWrapped(screen, row) ScrnTstFlag(screen, ROW2INX(screen, row), LINEWRAPPED)
d1046 1
a1046 2
extern int AddToRefresh (XtermWidget /* xw */);
extern int ClearInLine (XtermWidget /* xw */, int /* row */, int /* col */, unsigned /* len */);
a1060 1
extern void WriteText (XtermWidget /* xw */, PAIRED_CHARS(Char * /* str */, Char * /* str2 */), Cardinal /* len */);
d1062 1
a1062 1
extern void decode_wcwidth (int  /* mode */, int /* samplesize */, int /* samplepass */);
a1182 2
extern int DamagedCells(TScreen * /* screen */, unsigned /* n */, int * /* klp */, int * /* krp */, int /* row */, int /* col */);
extern int DamagedCurCells(TScreen * /* screen */, unsigned /* n */, int * /* klp */, int * /* krp */);
d1185 2
@


1.1.1.4
log
@Import xterm version 232. tested by many.
@
text
@d1 3
a3 1
/* $XTermId: xterm.h,v 1.498 2008/01/30 00:50:07 tom Exp $ */
d7 1
a7 1
Copyright 1999-2007,2008 by Thomas E. Dickey
a330 2
#define Maybe		2

a395 1
#define XtNhighlightColorMode	"highlightColorMode"
a404 1
#define XtNkeepSelection	"keepSelection"
a429 1
#define XtNpointerMode		"pointerMode"
a439 1
#define XtNquietGrab		"quietGrab"
a538 1
#define XtCHighlightColorMode	"HighlightColorMode"
a544 1
#define XtCKeepSelection	"KeepSelection"
a568 1
#define XtCPointerMode		"PointerMode"
a575 1
#define XtCQuietGrab		"QuietGrab"
a674 1
extern void UnhiliteSelection (XtermWidget  /* termw */);
d722 2
a723 2
extern XTermFonts * getCgsFont(XtermWidget /*xw*/, VTwin * /*cgsWin*/, GC /*gc*/);
extern void clrCgsFonts(XtermWidget /*xw*/, VTwin * /*cgsWin*/, XTermFonts * /*font*/);
d728 1
a728 1
extern void setCgsFont(XtermWidget /*xw*/, VTwin * /*cgsWin*/, CgsEnum /*cgsId*/, XTermFonts * /*font*/);
d739 1
a739 1
extern void FindFontSelection (XtermWidget /* xw */, const char * /* atom_name */, Bool  /* justprobe */);
d807 1
a807 1
extern GC xterm_DoubleGC(XtermWidget /* xw */, unsigned  /* chrset */, unsigned  /* flags */, GC  /* old_gc */, int * /* inxp */);
a810 2
extern int xtermParamToState (XtermWidget /* xw */, unsigned /* param */);
extern int xtermStateToParam (XtermWidget /* xw */, unsigned /* state */);
a906 1
extern void xtermDisplayCursor (XtermWidget /* xw */);
a907 1
extern void xtermShowPointer (XtermWidget /* xw */, Bool /* enable */);
d989 1
a989 1
extern void ScrnFillRectangle (XtermWidget /* xw */, XTermRect *,  int ,  unsigned /* flags */, Bool /* keepColors */);
a1076 2
extern Boolean isDefaultBackground(const char * /* name */);
extern Boolean isDefaultForeground(const char * /* name */);
a1216 1
extern Boolean isWideControl(unsigned /* ch */);
d1236 1
a1236 1
#define BtoS(b)    (((b) == Maybe) ? "maybe" : ((b) ? "on" : "off"))
@


