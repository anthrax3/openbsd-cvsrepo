head	1.8;
access;
symbols
	OPENBSD_6_0:1.7.0.4
	OPENBSD_6_0_BASE:1.7
	OPENBSD_5_9:1.7.0.2
	OPENBSD_5_9_BASE:1.7
	OPENBSD_5_8:1.6.0.4
	OPENBSD_5_8_BASE:1.6
	OPENBSD_5_7:1.6.0.2
	OPENBSD_5_7_BASE:1.6
	OPENBSD_5_6:1.4.0.2
	OPENBSD_5_6_BASE:1.4
	OPENBSD_5_5:1.2.0.2
	OPENBSD_5_5_BASE:1.2;
locks; strict;
comment	@ * @;


1.8
date	2016.08.07.21.27.36;	author matthieu;	state Exp;
branches;
next	1.7;
commitid	psxxjI5z4Vpv2LL4;

1.7
date	2015.09.05.14.11.46;	author matthieu;	state Exp;
branches;
next	1.6;
commitid	YVUODLQ4QcYTuGkb;

1.6
date	2015.01.18.20.24.40;	author matthieu;	state Exp;
branches;
next	1.5;
commitid	PDdlFuihcMifzxwp;

1.5
date	2014.12.18.20.16.55;	author matthieu;	state Exp;
branches;
next	1.4;
commitid	pCMhkpVdt9Oe52hU;

1.4
date	2014.07.14.08.30.11;	author matthieu;	state Exp;
branches;
next	1.3;
commitid	EnwNNUjlkdrocnMa;

1.3
date	2014.05.09.19.56.40;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2014.01.02.15.14.50;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2013.08.26.20.06.12;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.8
log
@Update to xterm-325. Testing by krw@@, shadchin@@ and naddy@@. Thanks
@
text
@/* $XTermId: graphics.c,v 1.69 2016/05/17 10:04:40 tom Exp $ */

/*
 * Copyright 2013-2015,2016 by Ross Combs
 *
 *                         All Rights Reserved
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 *
 * The above copyright notice and this permission notice shall be included
 * in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
 * IN NO EVENT SHALL THE ABOVE LISTED COPYRIGHT HOLDER(S) BE LIABLE FOR ANY
 * CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
 * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
 * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 *
 * Except as contained in this notice, the name(s) of the above copyright
 * holders shall not be used in advertising or otherwise to promote the
 * sale, use or other dealings in this Software without prior written
 * authorization.
 */

#include <xterm.h>

#include <stdio.h>
#include <ctype.h>
#include <stdlib.h>

#include <data.h>
#include <ptyx.h>

#include <assert.h>
#include <graphics.h>

#undef DUMP_BITMAP
#undef DUMP_COLORS
#undef DEBUG_PALETTE
#undef DEBUG_PIXEL
#undef DEBUG_REFRESH

/*
 * graphics TODO list
 *
 * ReGIS:
 * - ship a default alphabet zero font instead of scaling Xft fonts
 * - input and output cursors
 * - mouse input
 * - fix graphic pages for ReGIS -- they should also apply to text and sixel graphics
 * - fix interpolated curves to more closely match implementation (identical despite direction and starting point)
 * - non-ASCII alphabets
 * - enter/leave anywhere in a command
 * - locator key definitions (DECLKD)
 * - command display mode
 * - re-rasterization on resize
 * - macros
 * - improved fills for narrow angles (track actual lines not just pixels)
 *
 * sixel:
 * - fix problem where new_row < 0 during sixel parsing (see FIXME)
 * - screen-capture support (need dialog of some sort for safety)
 *
 * VT55/VT105 waveform graphics
 * - everything
 *
 * Tektronix:
 * - color (VT340 4014 emulation, 41xx, IRAF GTERM, and also MS-DOS Kermit color support)
 * - polygon fill (41xx)
 * - clear area extension
 * - area fill extension
 * - pixel operations (RU/RS/RP)
 * - research other 41xx and 42xx extensions
 *
 * common graphics features:
 * - handle light/dark screen modes (CSI?5[hl])
 * - update text fg/bg color which overlaps images
 * - handle graphic updates in scroll regions (verify effect on graphics)
 * - handle rectangular area copies (verify they work with graphics)
 * - invalidate graphics under graphic if same origin, at least as big, and bg not transparent
 * - invalidate graphic if completely scrolled past end of scrollback
 * - invalidate graphic if all pixels are transparent/erased
 * - invalidate graphic if completely scrolled out of alt buffer
 * - posturize requested colors to match hardware palettes (e.g. only four possible shades on VT240)
 * - color register report/restore
 * - ability to select/copy graphics for pasting in other programs
 * - ability to show non-scroll-mode sixel graphics in a separate window
 * - ability to show ReGIS graphics in a separate window
 * - ability to show Tektronix graphics in VT100 window
 * - truncate graphics at bottom edge of terminal?
 * - locator events (DECEFR DECSLE DECELR DECLRP)
 * - locator controller mode (CSI6i / CSI7i)
 *
 * new escape sequences:
 * - way to query text font size without "window ops" (or make "window ops" permissions more fine grained)
 * - way to query and set the number of graphics pages
 *
 * ReGIS extensions:
 * - non-integer text scaling
 * - free distortionless text rotation
 * - font characteristics: bold/underline/italic
 * - remove/increase arbitrary limits (pattern size, pages, alphabets, stack size, font names, etc.)
 * - comment command
 * - shade/fill with borders
 * - sprites (copy portion of page into/out of buffer with scaling and rotation)
 * - ellipses
 * - 2D patterns
 * - option to set actual graphic size (not just coordinate range)
 * - gradients (for lines and fills)
 * - line width (RLogin has this and it is mentioned in docs for the DEC ReGIS to Postscript converter)
 * - transparency
 * - background color as stackable write control
 * - true color (virtual color registers created upon lookup)
 * - anti-aliasing
 * - variable-width text
 */

/* font sizes:
 * VT510:
 *   80 Columns 132 Columns Maximum Number of Lines
 *   10 x 16   6 x 16  26 lines + keyboard indicator line
 *   10 x 13   6 x 13  26 lines + keyboard indicator line
 *   10 x 10   6 x 10  42 lines + keyboard indicator line
 *   10 x 8    6 x 8   53 lines + keyboard indicator line
 */

typedef struct allocated_color_register {
    struct allocated_color_register *next;
    Pixel pix;
    short r, g, b;
} AllocatedColorRegister;

#define LOOKUP_WIDTH 16
static AllocatedColorRegister *allocated_colors[LOOKUP_WIDTH][LOOKUP_WIDTH][LOOKUP_WIDTH];

#define FOR_EACH_SLOT(ii) for (ii = 0U; ii < MAX_GRAPHICS; ii++)

static ColorRegister *shared_color_registers;
static Graphic *displayed_graphics[MAX_GRAPHICS];
static unsigned next_graphic_id = 0U;

static ColorRegister *
allocRegisters(void)
{
    return TypeCallocN(ColorRegister, MAX_COLOR_REGISTERS);
}

static Graphic *
freeGraphic(Graphic *obj)
{
    if (obj) {
	if (obj->pixels)
	    free(obj->pixels);
	if (obj->private_color_registers)
	    free(obj->private_color_registers);
	free(obj);
    }
    return NULL;
}

static Graphic *
allocGraphic(int max_w, int max_h)
{
    Graphic *result = TypeCalloc(Graphic);
    if (result) {
	result->max_width = max_w;
	result->max_height = max_h;
	if (!(result->pixels = TypeCallocN(RegisterNum,
					     (size_t) max_w * (size_t) max_h))) {
	    result = freeGraphic(result);
	} else if (!(result->private_color_registers = allocRegisters())) {
	    result = freeGraphic(result);
	}
    }
    return result;
}

static Graphic *
getActiveSlot(unsigned n)
{
    if (n < MAX_GRAPHICS &&
	displayed_graphics[n] &&
	displayed_graphics[n]->valid) {
	return displayed_graphics[n];
    }
    return NULL;
}

static Graphic *
getInactiveSlot(const TScreen *screen, unsigned n)
{
    if (n < MAX_GRAPHICS &&
	(!displayed_graphics[n] ||
	 !displayed_graphics[n]->valid)) {
	if (!displayed_graphics[n]) {
	    displayed_graphics[n] = allocGraphic(screen->graphics_max_wide,
						 screen->graphics_max_high);
	}
	return displayed_graphics[n];
    }
    return NULL;
}

static ColorRegister *
getSharedRegisters(void)
{
    if (!shared_color_registers)
	shared_color_registers = allocRegisters();
    return shared_color_registers;
}

static void
deactivateSlot(unsigned n)
{
    if (n < MAX_GRAPHICS) {
	displayed_graphics[n] = freeGraphic(displayed_graphics[n]);
    }
}

extern RegisterNum
read_pixel(Graphic *graphic, int x, int y)
{
    if (x < 0 || x >= graphic->actual_width ||
	y < 0 || y >= graphic->actual_height) {
	return COLOR_HOLE;
    }

    return graphic->pixels[y * graphic->max_width + x];
}

#define _draw_pixel(G, X, Y, C) \
    do { \
        (G)->pixels[(Y) * (G)->max_width + (X)] = (RegisterNum) (C); \
    } while (0)

void
draw_solid_pixel(Graphic *graphic, int x, int y, unsigned color)
{
    assert(color <= MAX_COLOR_REGISTERS);

#ifdef DEBUG_PIXEL
    TRACE(("drawing pixel at %d,%d color=%hu (hole=%hu, [%d,%d,%d])\n",
	   x,
	   y,
	   color,
	   COLOR_HOLE,
	   ((color != COLOR_HOLE)
	    ? (unsigned) graphic->color_registers[color].r : 0U),
	   ((color != COLOR_HOLE)
	    ? (unsigned) graphic->color_registers[color].g : 0U),
	   ((color != COLOR_HOLE)
	    ? (unsigned) graphic->color_registers[color].b : 0U)));
#endif
    if (x >= 0 && x < graphic->actual_width &&
	y >= 0 && y < graphic->actual_height) {
	_draw_pixel(graphic, x, y, color);
	if (color < MAX_COLOR_REGISTERS)
	    graphic->color_registers_used[color] = 1;
    }
}

void
draw_solid_rectangle(Graphic *graphic, int x1, int y1, int x2, int y2, unsigned color)
{
    int x, y;
    int tmp;

    assert(color <= MAX_COLOR_REGISTERS);

    if (x1 > x2) {
	EXCHANGE(x1, x2, tmp);
    }
    if (y1 > y2) {
	EXCHANGE(y1, y2, tmp);
    }

    if (x2 < 0 || x1 >= graphic->actual_width ||
	y2 < 0 || y1 >= graphic->actual_height)
	return;

    if (x1 < 0)
	x1 = 0;
    if (x2 >= graphic->actual_width)
	x2 = graphic->actual_width - 1;
    if (y1 < 0)
	y1 = 0;
    if (y2 >= graphic->actual_height)
	y2 = graphic->actual_height - 1;

    if (color < MAX_COLOR_REGISTERS)
	graphic->color_registers_used[color] = 1;
    for (y = y1; y <= y2; y++)
	for (x = x1; x <= x2; x++)
	    _draw_pixel(graphic, x, y, color);
}

void
draw_solid_line(Graphic *graphic, int x1, int y1, int x2, int y2, unsigned color)
{
    int x, y;
    int dx, dy;
    int dir, diff;

    assert(color <= MAX_COLOR_REGISTERS);

    dx = abs(x1 - x2);
    dy = abs(y1 - y2);

    if (dx > dy) {
	if (x1 > x2) {
	    int tmp;
	    EXCHANGE(x1, x2, tmp);
	    EXCHANGE(y1, y2, tmp);
	}
	if (y1 < y2)
	    dir = 1;
	else if (y1 > y2)
	    dir = -1;
	else
	    dir = 0;

	diff = 0;
	y = y1;
	for (x = x1; x <= x2; x++) {
	    if (diff >= dx) {
		diff -= dx;
		y += dir;
	    }
	    diff += dy;
	    draw_solid_pixel(graphic, x, y, color);
	}
    } else {
	if (y1 > y2) {
	    int tmp;
	    EXCHANGE(x1, x2, tmp);
	    EXCHANGE(y1, y2, tmp);
	}
	if (x1 < x2)
	    dir = 1;
	else if (x1 > x2)
	    dir = -1;
	else
	    dir = 0;

	diff = 0;
	x = x1;
	for (y = y1; y <= y2; y++) {
	    if (diff >= dy) {
		diff -= dy;
		x += dir;
	    }
	    diff += dx;
	    draw_solid_pixel(graphic, x, y, color);
	}
    }
}

void
copy_overlapping_area(Graphic *graphic, int src_ul_x, int src_ul_y,
		      int dst_ul_x, int dst_ul_y, unsigned w, unsigned h,
		      unsigned default_color)
{
    int sx, ex, dx;
    int sy, ey, dy;
    int xx, yy;
    RegisterNum color;

    if (dst_ul_x <= src_ul_x) {
	sx = 0;
	ex = (int) w - 1;
	dx = +1;
    } else {
	sx = (int) w - 1;
	ex = 0;
	dx = -1;
    }

    if (dst_ul_y <= src_ul_y) {
	sy = 0;
	ey = (int) h - 1;
	dy = +1;
    } else {
	sy = (int) h - 1;
	ey = 0;
	dy = -1;
    }

    for (yy = sy; yy != ey + dy; yy += dy) {
	int dst_y = dst_ul_y + yy;
	int src_y = src_ul_y + yy;
	if (dst_y < 0 || dst_y >= (int) graphic->actual_height)
	    continue;

	for (xx = sx; xx != ex + dx; xx += dx) {
	    int dst_x = dst_ul_x + xx;
	    int src_x = src_ul_x + xx;
	    if (dst_x < 0 || dst_x >= (int) graphic->actual_width)
		continue;

	    if (src_x < 0 || src_x >= (int) graphic->actual_width ||
		src_y < 0 || src_y >= (int) graphic->actual_height)
		color = (RegisterNum) default_color;
	    else
		color = graphic->pixels[(unsigned) (src_y *
						    graphic->max_width) +
					(unsigned) src_x];

	    graphic->pixels[(unsigned) (dst_y * graphic->max_width) +
			    (unsigned) dst_x] = color;
	}
    }
}

static void
set_color_register(ColorRegister *color_registers,
		   unsigned color,
		   int r,
		   int g,
		   int b)
{
    ColorRegister *reg = &color_registers[color];
    reg->r = (short) r;
    reg->g = (short) g;
    reg->b = (short) b;
}

/* Graphics which don't use private colors will act as if they are using a
 * device-wide color palette.
 */
static void
set_shared_color_register(unsigned color, int r, int g, int b)
{
    unsigned ii;

    assert(color < MAX_COLOR_REGISTERS);

    set_color_register(getSharedRegisters(), color, r, g, b);

    FOR_EACH_SLOT(ii) {
	Graphic *graphic;

	if (!(graphic = getActiveSlot(ii)))
	    continue;
	if (graphic->private_colors)
	    continue;

	if (graphic->color_registers_used[ii]) {
	    graphic->dirty = 1;
	}
    }
}

void
update_color_register(Graphic *graphic,
		      unsigned color,
		      int r,
		      int g,
		      int b)
{
    assert(color < MAX_COLOR_REGISTERS);

    if (graphic->private_colors) {
	set_color_register(graphic->private_color_registers,
			   color, r, g, b);
	if (graphic->color_registers_used[color]) {
	    graphic->dirty = 1;
	}
	graphic->color_registers_used[color] = 1;
    } else {
	set_shared_color_register(color, r, g, b);
    }
}

#define SQUARE(X) ( (X) * (X) )

RegisterNum
find_color_register(ColorRegister const *color_registers, int r, int g, int b)
{
    unsigned i;
    unsigned closest_index;
    unsigned closest_distance;

    /* I have no idea what algorithm DEC used for this.
     * The documentation warns that it is unpredictable, especially with values
     * far away from any allocated color so it is probably a very simple
     * heuristic rather than something fancy like finding the minimum distance
     * in a linear perceptive color space.
     */
    closest_index = MAX_COLOR_REGISTERS;
    closest_distance = 0U;
    for (i = 0U; i < MAX_COLOR_REGISTERS; i++) {
	unsigned d = (unsigned) (SQUARE(2 * (color_registers[i].r - r)) +
				 SQUARE(3 * (color_registers[i].g - g)) +
				 SQUARE(1 * (color_registers[i].b - b)));
	if (closest_index == MAX_COLOR_REGISTERS || d < closest_distance) {
	    closest_index = i;
	    closest_distance = d;
	}
    }

    TRACE(("found closest color register to %d,%d,%d: %u (distance %u value %d,%d,%d)\n",
	   r, g, b,
	   closest_index,
	   closest_distance,
	   color_registers[closest_index].r,
	   color_registers[closest_index].g,
	   color_registers[closest_index].b));
    return (RegisterNum) closest_index;
}

static void
init_color_registers(ColorRegister *color_registers, int terminal_id)
{
    TRACE(("setting initial colors for terminal %d\n", terminal_id));
    {
	unsigned i;

	for (i = 0U; i < MAX_COLOR_REGISTERS; i++) {
	    set_color_register(color_registers, (RegisterNum) i, 0, 0, 0);
	}
    }

    /*
     * default color registers:
     *     (mono) (color)
     * VK100/GIGI (fixed)
     * VT125:
     *   0: 0%      0%
     *   1: 33%     blue
     *   2: 66%     red
     *   3: 100%    green
     * VT240:
     *   0: 0%      0%
     *   1: 33%     blue
     *   2: 66%     red
     *   3: 100%    green
     * VT241:
     *   0: 0%      0%
     *   1: 33%     blue
     *   2: 66%     red
     *   3: 100%    green
     * VT330:
     *   0: 0%      0%              (bg for light on dark mode)
     *   1: 33%     blue (red?)
     *   2: 66%     red (green?)
     *   3: 100%    green (yellow?) (fg for light on dark mode)
     * VT340:
     *   0: 0%      0%              (bg for light on dark mode)
     *   1: 14%     blue
     *   2: 29%     red
     *   3: 43%     green
     *   4: 57%     magenta
     *   5: 71%     cyan
     *   6: 86%     yellow
     *   7: 100%    50%             (fg for light on dark mode)
     *   8: 0%      25%
     *   9: 14%     gray-blue
     *  10: 29%     gray-red
     *  11: 43%     gray-green
     *  12: 57%     gray-magenta
     *  13: 71%     gray-cyan
     *  14: 86%     gray-yellow
     *  15: 100%    75%             ("white")
     * VT382:
     *   ? (FIXME: B&W only?)
     * dxterm:
     *  ?
     */
    switch (terminal_id) {
    case 125:
    case 241:
	set_color_register(color_registers, 0, 0, 0, 0);
	set_color_register(color_registers, 1, 0, 0, 100);
	set_color_register(color_registers, 2, 0, 100, 0);
	set_color_register(color_registers, 3, 100, 0, 0);
	break;
    case 240:
    case 330:
	set_color_register(color_registers, 0, 0, 0, 0);
	set_color_register(color_registers, 1, 33, 33, 33);
	set_color_register(color_registers, 2, 66, 66, 66);
	set_color_register(color_registers, 3, 100, 100, 100);
	break;
    case 340:
    default:
	set_color_register(color_registers, 0, 0, 0, 0);
	set_color_register(color_registers, 1, 20, 20, 80);
	set_color_register(color_registers, 2, 80, 13, 13);
	set_color_register(color_registers, 3, 20, 80, 20);
	set_color_register(color_registers, 4, 80, 20, 80);
	set_color_register(color_registers, 5, 20, 80, 80);
	set_color_register(color_registers, 6, 80, 80, 20);
	set_color_register(color_registers, 7, 53, 53, 53);
	set_color_register(color_registers, 8, 26, 26, 26);
	set_color_register(color_registers, 9, 33, 33, 60);
	set_color_register(color_registers, 10, 60, 26, 26);
	set_color_register(color_registers, 11, 33, 60, 33);
	set_color_register(color_registers, 12, 60, 33, 60);
	set_color_register(color_registers, 13, 33, 60, 60);
	set_color_register(color_registers, 14, 60, 60, 33);
	set_color_register(color_registers, 15, 80, 80, 80);
	break;
    case 382:			/* FIXME: verify */
	set_color_register(color_registers, 0, 0, 0, 0);
	set_color_register(color_registers, 1, 100, 100, 100);
	break;
    }

#ifdef DEBUG_PALETTE
    {
	unsigned i;

	for (i = 0U; i < MAX_COLOR_REGISTERS; i++) {
	    TRACE(("initial value for register %03u: %d,%d,%d\n",
		   i,
		   color_registers[i].r,
		   color_registers[i].g,
		   color_registers[i].b));
	}
    }
#endif
}

unsigned
get_color_register_count(TScreen const *screen)
{
    unsigned num_color_registers;

    if (screen->numcolorregisters >= 0) {
	num_color_registers = (unsigned) screen->numcolorregisters;
    } else {
	num_color_registers = 0U;
    }

    if (num_color_registers > 1U) {
	if (num_color_registers > MAX_COLOR_REGISTERS)
	    return MAX_COLOR_REGISTERS;
	return num_color_registers;
    }

    /*
     * color capabilities:
     * VK100/GIGI  1 plane (12x1 pixel attribute blocks) colorspace is 8 fixed colors (black, white, red, green, blue, cyan, yellow, magenta)
     * VT125       2 planes (4 registers) colorspace is (64?) (color), ? (grayscale)
     * VT240       2 planes (4 registers) colorspace is 4 shades (grayscale)
     * VT241       2 planes (4 registers) colorspace is ? (color), ? shades (grayscale)
     * VT330       2 planes (4 registers) colorspace is 4 shades (grayscale)
     * VT340       4 planes (16 registers) colorspace is r16g16b16 (color), 16 shades (grayscale)
     * VT382       1 plane (two fixed colors: black and white)  FIXME: verify
     * dxterm      ?
     */
    switch (screen->terminal_id) {
    case 125:
	return 4U;
    case 240:
	return 4U;
    case 241:
	return 4U;
    case 330:
	return 4U;
    case 340:
	return 16U;
    case 382:
	return 2U;
    default:
	/* unknown graphics model -- might as well be generous */
	return MAX_COLOR_REGISTERS;
    }
}

static void
init_graphic(Graphic *graphic,
	     unsigned type,
	     int terminal_id,
	     int charrow,
	     int charcol,
	     unsigned num_color_registers,
	     int private_colors)
{
    const unsigned max_pixels = (unsigned) (graphic->max_width *
					    graphic->max_height);
    unsigned i;

    TRACE(("initializing graphic object\n"));

    graphic->hidden = 0;
    graphic->dirty = 1;
    for (i = 0U; i < max_pixels; i++)
	graphic->pixels[i] = COLOR_HOLE;
    memset(graphic->color_registers_used, 0, sizeof(graphic->color_registers_used));

    /*
     * text and graphics interactions:
     * VK100/GIGI                text writes on top of graphics buffer, color attribute shared with text
     * VT240,VT241,VT330,VT340   text writes on top of graphics buffer
     * VT382                     text writes on top of graphics buffer FIXME: verify
     * VT125                     graphics buffer overlaid on top of text in B&W display, text not present in color display
     */

    /*
     * dimensions (ReGIS logical, physical):
     * VK100/GIGI  768x4??  768x240(status?)
     * VT125       768x460  768x230(+10status) (1:2 aspect ratio, ReGIS halves vertical addresses through "odd y emulation")
     * VT240       800x460  800x230(+10status) (1:2 aspect ratio, ReGIS halves vertical addresses through "odd y emulation")
     * VT241       800x460  800x230(+10status) (1:2 aspect ratio, ReGIS halves vertical addresses through "odd y emulation")
     * VT330       800x480  800x480(+?status)
     * VT340       800x480  800x480(+?status)
     * VT382       960x750  sixel only
     * dxterm      ?x? ?x?  variable?
     */

    graphic->actual_width = 0;
    graphic->actual_height = 0;

    graphic->pixw = 1;
    graphic->pixh = 1;

    graphic->valid_registers = num_color_registers;
    TRACE(("%d color registers\n", graphic->valid_registers));

    graphic->private_colors = private_colors;
    if (graphic->private_colors) {
	TRACE(("using private color registers\n"));
	init_color_registers(graphic->private_color_registers, terminal_id);
	graphic->color_registers = graphic->private_color_registers;
    } else {
	TRACE(("using shared color registers\n"));
	graphic->color_registers = getSharedRegisters();
    }

    graphic->charrow = charrow;
    graphic->charcol = charcol;
    graphic->type = type;
    graphic->valid = 0;
}

Graphic *
get_new_graphic(XtermWidget xw, int charrow, int charcol, unsigned type)
{
    TScreen const *screen = TScreenOf(xw);
    int bufferid = screen->whichBuf;
    int terminal_id = screen->terminal_id;
    Graphic *graphic;
    unsigned ii;

    FOR_EACH_SLOT(ii) {
	if ((graphic = getInactiveSlot(screen, ii))) {
	    TRACE(("using fresh graphic index=%u id=%u\n", ii, next_graphic_id));
	    break;
	}
    }

    /* if none are free, recycle the graphic scrolled back the farthest */
    if (!graphic) {
	int min_charrow = 0;
	Graphic *min_graphic = NULL;

	FOR_EACH_SLOT(ii) {
	    if (!(graphic = getActiveSlot(ii)))
		continue;
	    if (!min_graphic || graphic->charrow < min_charrow) {
		min_charrow = graphic->charrow;
		min_graphic = graphic;
	    }
	}
	TRACE(("recycling old graphic index=%u id=%u\n", ii, next_graphic_id));
	graphic = min_graphic;
    }

    if (graphic) {
	unsigned num_color_registers;
	num_color_registers = get_color_register_count(screen);
	graphic->xw = xw;
	graphic->bufferid = bufferid;
	graphic->id = next_graphic_id++;
	init_graphic(graphic,
		     type,
		     terminal_id,
		     charrow,
		     charcol,
		     num_color_registers,
		     screen->privatecolorregisters);
    }
    return graphic;
}

Graphic *
get_new_or_matching_graphic(XtermWidget xw,
			    int charrow,
			    int charcol,
			    int actual_width,
			    int actual_height,
			    unsigned type)
{
    TScreen const *screen = TScreenOf(xw);
    int bufferid = screen->whichBuf;
    Graphic *graphic;
    unsigned ii;

    FOR_EACH_SLOT(ii) {
	TRACE(("checking slot=%u for graphic at %d,%d %dx%d bufferid=%d type=%u\n", ii,
	       charrow, charcol,
	       actual_width, actual_height,
	       bufferid, type));
	if ((graphic = getActiveSlot(ii))) {
	    if (graphic->type == type &&
		graphic->bufferid == bufferid &&
		graphic->charrow == charrow &&
		graphic->charcol == charcol &&
		graphic->actual_width == actual_width &&
		graphic->actual_height == actual_height) {
		TRACE(("found existing graphic slot=%u id=%u\n", ii, graphic->id));
		return graphic;
	    }
	    TRACE(("not a match: graphic at %d,%d %dx%d bufferid=%d type=%u\n",
		   graphic->charrow, graphic->charcol,
		   graphic->actual_width, graphic->actual_height,
		   graphic->bufferid, graphic->type));
	}
    }

    /* if no match get a new graphic */
    if ((graphic = get_new_graphic(xw, charrow, charcol, type))) {
	graphic->actual_width = actual_width;
	graphic->actual_height = actual_height;
	TRACE(("no match; created graphic at %d,%d %dx%d bufferid=%d type=%u\n",
	       graphic->charrow, graphic->charcol,
	       graphic->actual_width, graphic->actual_height,
	       graphic->bufferid, graphic->type));
    }
    return graphic;
}

static int
lookup_allocated_color(const ColorRegister *reg, Pixel *pix)
{
    unsigned const rr = ((unsigned) reg->r * (LOOKUP_WIDTH - 1)) / CHANNEL_MAX;
    unsigned const gg = ((unsigned) reg->g * (LOOKUP_WIDTH - 1)) / CHANNEL_MAX;
    unsigned const bb = ((unsigned) reg->b * (LOOKUP_WIDTH - 1)) / CHANNEL_MAX;
    const AllocatedColorRegister *search;

    for (search = allocated_colors[rr][gg][bb]; search; search = search->next) {
	if (search->r == reg->r &&
	    search->g == reg->g &&
	    search->b == reg->b) {
	    *pix = search->pix;
	    return 1;
	}
    }

    *pix = 0UL;
    return 0;
}

#define ScaleForXColor(s) (unsigned short) ((long)(s) * 65535 / CHANNEL_MAX)

static int
save_allocated_color(const ColorRegister *reg, XtermWidget xw, Pixel *pix)
{
    unsigned const rr = ((unsigned) reg->r * (LOOKUP_WIDTH - 1)) / CHANNEL_MAX;
    unsigned const gg = ((unsigned) reg->g * (LOOKUP_WIDTH - 1)) / CHANNEL_MAX;
    unsigned const bb = ((unsigned) reg->b * (LOOKUP_WIDTH - 1)) / CHANNEL_MAX;
    XColor xcolor;
    AllocatedColorRegister *new_color;

    xcolor.pixel = 0UL;
    xcolor.red = ScaleForXColor(reg->r);
    xcolor.green = ScaleForXColor(reg->g);
    xcolor.blue = ScaleForXColor(reg->b);
    xcolor.flags = DoRed | DoGreen | DoBlue;
    if (!allocateBestRGB(xw, &xcolor)) {
	TRACE(("unable to allocate xcolor\n"));
	*pix = 0UL;
	return 0;
    }

    *pix = xcolor.pixel;

    if (!(new_color = malloc(sizeof(*new_color)))) {
	TRACE(("unable to save pixel %lu\n", (unsigned long) *pix));
	return 0;
    }
    new_color->r = reg->r;
    new_color->g = reg->g;
    new_color->b = reg->b;
    new_color->pix = *pix;
    new_color->next = allocated_colors[rr][gg][bb];

    allocated_colors[rr][gg][bb] = new_color;

    return 1;
}

static Pixel
color_register_to_xpixel(const ColorRegister *reg, XtermWidget xw)
{
    Pixel pix;

    if (!lookup_allocated_color(reg, &pix))
	save_allocated_color(reg, xw, &pix);

    /* FIXME: with so many possible colors we need to determine
     * when to free them to be nice to PseudoColor displays
     */
    return pix;
}

static void
refresh_graphic(TScreen const *screen,
		Graphic const *graphic,
		ColorRegister *buffer,
		int refresh_x,
		int refresh_y,
		int refresh_w,
		int refresh_h,
		int draw_x,
		int draw_y,
		int draw_w,
		int draw_h)
{
    int const pw = graphic->pixw;
    int const ph = graphic->pixh;
    int const graph_x = graphic->charcol * FontWidth(screen);
    int const graph_y = graphic->charrow * FontHeight(screen);
    int const graph_w = graphic->actual_width;
    int const graph_h = graphic->actual_height;
    int const mw = graphic->max_width;
    int r, c;
    int fillx, filly;
    int holes, total, out_of_range;
    RegisterNum regnum;

    TRACE(("refreshing graphic %u from %d,%d %dx%d (valid=%d, size=%dx%d, scale=%dx%d max=%dx%d)\n",
	   graphic->id,
	   graph_x, graph_y, draw_w, draw_h,
	   graphic->valid,
	   graphic->actual_width,
	   graphic->actual_height,
	   pw, ph,
	   graphic->max_width,
	   graphic->max_height));

    TRACE(("refresh pixmap starts at %d,%d\n", refresh_x, refresh_y));

    holes = total = 0;
    out_of_range = 0;
    for (r = 0; r < graph_h; r++) {
	int pmy = graph_y + r * ph;

	if (pmy + ph - 1 < draw_y)
	    continue;
	if (pmy > draw_y + draw_h - 1)
	    break;

	for (c = 0; c < graph_w; c++) {
	    int pmx = graph_x + c * pw;

	    if (pmx + pw - 1 < draw_x)
		continue;
	    if (pmx > draw_x + draw_w - 1)
		break;

	    total++;
	    regnum = graphic->pixels[r * mw + c];
	    if (regnum == COLOR_HOLE) {
		holes++;
		continue;
	    }

	    for (fillx = 0; fillx < pw; fillx++) {
		for (filly = 0; filly < ph; filly++) {
		    if (pmx < draw_x || pmx > draw_x + draw_w - 1 ||
			pmy < draw_y || pmy > draw_y + draw_h - 1) {
			out_of_range++;
			continue;
		    }

		    /* this shouldn't happen, but it doesn't hurt to check */
		    if (pmx < refresh_x || pmx > refresh_x + refresh_w - 1 ||
			pmy < refresh_y || pmy > refresh_y + refresh_h - 1) {
			TRACE(("OUT OF RANGE: %d,%d (%d,%d)\n", pmx, pmy, r, c));
			out_of_range++;
			continue;
		    }

		    buffer[(pmy - refresh_y) * refresh_w +
			   (pmx - refresh_x)] =
			graphic->color_registers[regnum];
		}
	    }
	}
    }

    TRACE(("done refreshing graphic: %d of %d refreshed pixels were holes; %d were out of pixmap range\n",
	   holes, total, out_of_range));
}

#ifdef DEBUG_REFRESH

#define BASEX(X) ( (draw_x - base_x) + (X) )
#define BASEY(Y) ( (draw_y - base_y) + (Y) )

static void
outline_refresh(TScreen const *screen,
		Graphic const *graphic,
		Pixmap output_pm,
		GC graphics_gc,
		int base_x,
		int base_y,
		int draw_x,
		int draw_y,
		int draw_w,
		int draw_h)
{
    Display *const display = screen->display;
    int const pw = graphic->pixw;
    int const ph = graphic->pixh;
    XGCValues xgcv;
    XColor def;

    def.red = (unsigned short) ((1.0 - 0.1 * (rand() / (double)
					      RAND_MAX) * 65535.0));
    def.green = (unsigned short) ((0.7 + 0.2 * (rand() / (double)
						RAND_MAX)) * 65535.0);
    def.blue = (unsigned short) ((0.1 + 0.1 * (rand() / (double)
					       RAND_MAX)) * 65535.0);
    def.flags = DoRed | DoGreen | DoBlue;
    if (allocateBestRGB(graphic->xw, &def)) {
	xgcv.foreground = def.pixel;
	XChangeGC(display, graphics_gc, GCForeground, &xgcv);
    }

    XDrawLine(display, output_pm, graphics_gc,
	      BASEX(0), BASEY(0),
	      BASEX(draw_w - 1), BASEY(0));
    XDrawLine(display, output_pm, graphics_gc,
	      BASEX(0), BASEY(draw_h - 1),
	      BASEX(draw_w - 1), BASEY(draw_h - 1));

    XDrawLine(display, output_pm, graphics_gc,
	      BASEX(0), BASEY(0),
	      BASEX(0), BASEY(draw_h - 1));
    XDrawLine(display, output_pm, graphics_gc,
	      BASEX(draw_w - 1), BASEY(0),
	      BASEX(draw_w - 1), BASEY(draw_h - 1));

    XDrawLine(display, output_pm, graphics_gc,
	      BASEX(draw_w - 1), BASEY(0),
	      BASEX(0), BASEY(draw_h - 1));
    XDrawLine(display, output_pm, graphics_gc,
	      BASEX(draw_w - 1), BASEY(draw_h - 1),
	      BASEX(0), BASEY(0));

    def.red = (short) (0.7 * 65535.0);
    def.green = (short) (0.1 * 65535.0);
    def.blue = (short) (1.0 * 65535.0);
    def.flags = DoRed | DoGreen | DoBlue;
    if (allocateBestRGB(graphic->xw, &def)) {
	xgcv.foreground = def.pixel;
	XChangeGC(display, graphics_gc, GCForeground, &xgcv);
    }
    XFillRectangle(display, output_pm, graphics_gc,
		   BASEX(0),
		   BASEY(0),
		   (unsigned) pw, (unsigned) ph);
    XFillRectangle(display, output_pm, graphics_gc,
		   BASEX(draw_w - 1 - pw),
		   BASEY(draw_h - 1 - ph),
		   (unsigned) pw, (unsigned) ph);
}
#endif

/*
 * Primary color hues:
 *  blue:    0 degrees
 *  red:   120 degrees
 *  green: 240 degrees
 */
void
hls2rgb(int h, int l, int s, short *r, short *g, short *b)
{
    const int hs = ((h + 240) / 60) % 6;
    const double lv = l / 100.0;
    const double sv = s / 100.0;
    double c, x, m, c2;
    double r1, g1, b1;

    if (s == 0) {
	*r = *g = *b = (short) l;
	return;
    }

    c2 = (2.0 * lv) - 1.0;
    if (c2 < 0.0)
	c2 = -c2;
    c = (1.0 - c2) * sv;
    x = (hs & 1) ? c : 0.0;
    m = lv - 0.5 * c;

    switch (hs) {
    case 0:
	r1 = c;
	g1 = x;
	b1 = 0.0;
	break;
    case 1:
	r1 = x;
	g1 = c;
	b1 = 0.0;
	break;
    case 2:
	r1 = 0.0;
	g1 = c;
	b1 = x;
	break;
    case 3:
	r1 = 0.0;
	g1 = x;
	b1 = c;
	break;
    case 4:
	r1 = x;
	g1 = 0.0;
	b1 = c;
	break;
    case 5:
	r1 = c;
	g1 = 0.0;
	b1 = x;
	break;
    default:
	TRACE(("Bad HLS input: [%d,%d,%d], returning white\n", h, l, s));
	*r = (short) 100;
	*g = (short) 100;
	*b = (short) 100;
	return;
    }

    *r = (short) ((r1 + m) * 100.0 + 0.5);
    *g = (short) ((g1 + m) * 100.0 + 0.5);
    *b = (short) ((b1 + m) * 100.0 + 0.5);

    if (*r < 0)
	*r = 0;
    else if (*r > 100)
	*r = 100;
    if (*g < 0)
	*g = 0;
    else if (*g > 100)
	*g = 100;
    if (*b < 0)
	*b = 0;
    else if (*b > 100)
	*b = 100;
}

void
dump_graphic(Graphic const *graphic)
{
#if defined(DUMP_COLORS) || defined(DUMP_BITMAP)
    RegisterNum color;
#endif
#ifdef DUMP_BITMAP
    int r, c;
    ColorRegister const *reg;
#endif

    (void) graphic;

    TRACE(("graphic stats: id=%u charrow=%d charcol=%d actual_width=%d actual_height=%d pixw=%d pixh=%d\n",
	   graphic->id,
	   graphic->charrow,
	   graphic->charcol,
	   graphic->actual_width,
	   graphic->actual_height,
	   graphic->pixw,
	   graphic->pixh));

#ifdef DUMP_COLORS
    TRACE(("graphic colors:\n"));
    for (color = 0; color < graphic->valid_registers; color++) {
	TRACE(("%03u: %d,%d,%d\n",
	       color,
	       graphic->color_registers[color].r,
	       graphic->color_registers[color].g,
	       graphic->color_registers[color].b));
    }
#endif

#ifdef DUMP_BITMAP
    TRACE(("graphic pixels:\n"));
    for (r = 0; r < graphic->actual_height; r++) {
	for (c = 0; c < graphic->actual_width; c++) {
	    color = graphic->pixels[r * graphic->max_width + c];
	    if (color == COLOR_HOLE) {
		TRACE(("?"));
	    } else {
		reg = &graphic->color_registers[color];
		if (reg->r + reg->g + reg->b > 200) {
		    TRACE(("#"));
		} else if (reg->r + reg->g + reg->b > 150) {
		    TRACE(("%%"));
		} else if (reg->r + reg->g + reg->b > 100) {
		    TRACE((":"));
		} else if (reg->r + reg->g + reg->b > 80) {
		    TRACE(("."));
		} else {
		    TRACE((" "));
		}
	    }
	}
	TRACE(("\n"));
    }

    TRACE(("\n"));
#endif
}

/* Erase the portion of any displayed graphic overlapping with a rectangle
 * of the given size and location in pixels relative to the start of the
 * graphic.  This is used to allow text to "erase" graphics underneath it.
 */
static void
erase_graphic(Graphic *graphic, int x, int y, int w, int h)
{
    RegisterNum hole = COLOR_HOLE;
    int pw, ph;
    int r, c;
    int rbase, cbase;

    pw = graphic->pixw;
    ph = graphic->pixh;

    TRACE(("erasing graphic %d,%d %dx%d\n", x, y, w, h));

    rbase = 0;
    for (r = 0; r < graphic->actual_height; r++) {
	if (rbase + ph - 1 >= y
	    && rbase <= y + h - 1) {
	    cbase = 0;
	    for (c = 0; c < graphic->actual_width; c++) {
		if (cbase + pw - 1 >= x
		    && cbase <= x + w - 1) {
		    graphic->pixels[r * graphic->max_width + c] = hole;
		}
		cbase += pw;
	    }
	}
	rbase += ph;
    }
}

static int
compare_graphic_ids(const void *left, const void *right)
{
    const Graphic *l = *(const Graphic *const *) left;
    const Graphic *r = *(const Graphic *const *) right;

    if (!l->valid || !r->valid)
	return 0;

    if (l->bufferid < r->bufferid)
	return -1;
    else if (l->bufferid > r->bufferid)
	return 1;

    if (l->id < r->id)
	return -1;
    else
	return 1;
}

static void
clip_area(int *orig_x, int *orig_y, int *orig_w, int *orig_h,
	  int clip_x, int clip_y, int clip_w, int clip_h)
{
    if (*orig_x < clip_x) {
	const int diff = clip_x - *orig_x;
	*orig_x += diff;
	*orig_w -= diff;
    }
    if (*orig_w > 0 && *orig_x + *orig_w > clip_x + clip_w) {
	*orig_w -= (*orig_x + *orig_w) - (clip_x + clip_w);
    }

    if (*orig_y < clip_y) {
	const int diff = clip_y - *orig_y;
	*orig_y += diff;
	*orig_h -= diff;
    }
    if (*orig_h > 0 && *orig_y + *orig_h > clip_y + clip_h) {
	*orig_h -= (*orig_y + *orig_h) - (clip_y + clip_h);
    }
}

/* the coordinates are relative to the screen */
static void
refresh_graphics(XtermWidget xw,
		 int leftcol,
		 int toprow,
		 int ncols,
		 int nrows,
		 int skip_clean)
{
    TScreen *const screen = TScreenOf(xw);
    Display *const display = screen->display;
    Window const drawable = VDrawable(screen);
    int const scroll_y = screen->topline * FontHeight(screen);
    int const refresh_x = leftcol * FontWidth(screen);
    int const refresh_y = toprow * FontHeight(screen) + scroll_y;
    int const refresh_w = ncols * FontWidth(screen);
    int const refresh_h = nrows * FontHeight(screen);
    int draw_x_min, draw_x_max;
    int draw_y_min, draw_y_max;
    Graphic *ordered_graphics[MAX_GRAPHICS];
    unsigned ii, jj;
    unsigned active_count;
    unsigned holes, non_holes;
    int xx, yy;
    ColorRegister *buffer;

    active_count = 0;
    FOR_EACH_SLOT(ii) {
	Graphic *graphic;
	if (!(graphic = getActiveSlot(ii)))
	    continue;
	TRACE(("refreshing graphic %d on buffer %d, current buffer %d\n",
	       graphic->id, graphic->bufferid, screen->whichBuf));
	if (screen->whichBuf == 0) {
	    if (graphic->bufferid != 0) {
		TRACE(("skipping graphic %d from alt buffer (%d) when drawing screen=%d\n",
		       graphic->id, graphic->bufferid, screen->whichBuf));
		continue;
	    }
	} else {
	    if (graphic->bufferid == 0 && graphic->charrow >= 0) {
		TRACE(("skipping graphic %d from normal buffer (%d) when drawing screen=%d because it is not in scrollback area\n",
		       graphic->id, graphic->bufferid, screen->whichBuf));
		continue;
	    }
	    if (graphic->bufferid == 1 &&
		graphic->charrow + (graphic->actual_height +
				    FontHeight(screen) - 1) /
		FontHeight(screen) < 0) {
		TRACE(("skipping graphic %d from alt buffer (%d) when drawing screen=%d because it is completely in scrollback area\n",
		       graphic->id, graphic->bufferid, screen->whichBuf));
		continue;
	    }
	}
	if (graphic->hidden)
	    continue;
	ordered_graphics[active_count++] = graphic;
    }

    if (active_count == 0)
	return;
    if (active_count > 1) {
	qsort(ordered_graphics,
	      (size_t) active_count,
	      sizeof(ordered_graphics[0]),
	      compare_graphic_ids);
    }

    if (skip_clean) {
	unsigned skip_count;

	for (jj = 0; jj < active_count; ++jj) {
	    if (ordered_graphics[jj]->dirty)
		break;
	}
	skip_count = jj;
	if (skip_count == active_count)
	    return;

	active_count -= skip_count;
	for (jj = 0; jj < active_count; ++jj) {
	    ordered_graphics[jj] = ordered_graphics[jj + skip_count];
	}
    }

    if (!(buffer = malloc(sizeof(*buffer) *
			  (unsigned) refresh_w * (unsigned) refresh_h))) {
	TRACE(("unable to allocate %dx%d buffer for graphics refresh\n",
	       refresh_w, refresh_h));
	return;
    }
    for (yy = 0; yy < refresh_h; yy++) {
	for (xx = 0; xx < refresh_w; xx++) {
	    buffer[yy * refresh_w + xx].r = -1;
	    buffer[yy * refresh_w + xx].g = -1;
	    buffer[yy * refresh_w + xx].b = -1;
	}
    }

    TRACE(("refresh: screen->topline=%d leftcol=%d toprow=%d nrows=%d ncols=%d (%d,%d %dx%d)\n",
	   screen->topline,
	   leftcol, toprow,
	   nrows, ncols,
	   refresh_x, refresh_y,
	   refresh_w, refresh_h));

    {
	int const altarea_x = 0;
	int const altarea_y = 0;
	int const altarea_w = Width(screen) * FontWidth(screen);
	int const altarea_h = Height(screen) * FontHeight(screen);

	int const scrollarea_x = 0;
	int const scrollarea_y = scroll_y;
	int const scrollarea_w = Width(screen) * FontWidth(screen);
	int const scrollarea_h = -scroll_y;

	int const mainarea_x = 0;
	int const mainarea_y = scroll_y;
	int const mainarea_w = Width(screen) * FontWidth(screen);
	int const mainarea_h = -scroll_y + Height(screen) * FontHeight(screen);

	draw_x_min = refresh_x + refresh_w;
	draw_x_max = refresh_x - 1;
	draw_y_min = refresh_y + refresh_h;
	draw_y_max = refresh_y - 1;
	for (jj = 0; jj < active_count; ++jj) {
	    Graphic *graphic = ordered_graphics[jj];
	    int draw_x = graphic->charcol * FontWidth(screen);
	    int draw_y = graphic->charrow * FontHeight(screen);
	    int draw_w = graphic->actual_width;
	    int draw_h = graphic->actual_height;

	    if (screen->whichBuf != 0) {
		if (graphic->bufferid != 0) {
		    /* clip to alt buffer */
		    clip_area(&draw_x, &draw_y, &draw_w, &draw_h,
			      altarea_x, altarea_y, altarea_w, altarea_h);
		} else {
		    /* clip to scrollback area */
		    clip_area(&draw_x, &draw_y, &draw_w, &draw_h,
			      scrollarea_x, scrollarea_y,
			      scrollarea_w, scrollarea_h);
		}
	    } else {
		/* clip to scrollback + normal area */
		clip_area(&draw_x, &draw_y, &draw_w, &draw_h,
			  mainarea_x, mainarea_y,
			  mainarea_w, mainarea_h);
	    }

	    clip_area(&draw_x, &draw_y, &draw_w, &draw_h,
		      refresh_x, refresh_y, refresh_w, refresh_h);

	    TRACE(("refresh: graph=%u\n", jj));
	    TRACE(("         refresh_x=%d refresh_y=%d refresh_w=%d refresh_h=%d\n",
		   refresh_x, refresh_y, refresh_w, refresh_h));
	    TRACE(("         draw_x=%d draw_y=%d draw_w=%d draw_h=%d\n",
		   draw_x, draw_y, draw_w, draw_h));

	    if (draw_w > 0 && draw_h > 0) {
		refresh_graphic(screen, graphic, buffer,
				refresh_x, refresh_y,
				refresh_w, refresh_h,
				draw_x, draw_y,
				draw_w, draw_h);
		if (draw_x < draw_x_min)
		    draw_x_min = draw_x;
		if (draw_x + draw_w - 1 > draw_x_max)
		    draw_x_max = draw_x + draw_w - 1;
		if (draw_y < draw_y_min)
		    draw_y_min = draw_y;
		if (draw_y + draw_h - 1 > draw_y_max)
		    draw_y_max = draw_y + draw_h - 1;
	    }
	    graphic->dirty = 0;
	}
    }

    if (draw_x_max < refresh_x ||
	draw_x_min > refresh_x + refresh_w - 1 ||
	draw_y_max < refresh_y ||
	draw_y_min > refresh_y + refresh_h - 1) {
	free(buffer);
	return;
    }

    holes = 0U;
    non_holes = 0U;
    for (yy = draw_y_min - refresh_y; yy <= draw_y_max - refresh_y; yy++) {
	for (xx = draw_x_min - refresh_x; xx <= draw_x_max - refresh_x; xx++) {
	    const ColorRegister color = buffer[yy * refresh_w + xx];
	    if (color.r < 0 || color.g < 0 || color.b < 0) {
		holes++;
	    } else {
		non_holes++;
	    }
	}
    }

    if (non_holes < 1U) {
	TRACE(("refresh: visible graphics areas are erased; nothing to do\n"));
	free(buffer);
	return;
    }

    /*
     * If we have any holes we can't just copy an image rectangle, and masking
     * with bitmaps is very expensive.  This fallback is surprisingly faster
     * than the XPutImage version in some cases, but I don't know why.
     * (This is even though there's no X11 primitive for drawing a horizontal
     * line of height one and no attempt is made to handle multiple lines at
     * once.)
     */
    if (holes > 0U) {
	GC graphics_gc;
	XGCValues xgcv;
	ColorRegister last_color;
	ColorRegister gc_color;
	int run;

	memset(&xgcv, 0, sizeof(xgcv));
	xgcv.graphics_exposures = False;
	graphics_gc = XCreateGC(display, drawable, GCGraphicsExposures, &xgcv);
	if (graphics_gc == None) {
	    TRACE(("unable to allocate GC for graphics refresh\n"));
	    free(buffer);
	    return;
	}

	last_color.r = -1;
	last_color.g = -1;
	last_color.b = -1;
	gc_color.r = -1;
	gc_color.g = -1;
	gc_color.b = -1;
	run = 0;
	for (yy = draw_y_min - refresh_y; yy <= draw_y_max - refresh_y; yy++) {
	    for (xx = draw_x_min - refresh_x; xx <= draw_x_max - refresh_x;
		 xx++) {
		const ColorRegister color = buffer[yy * refresh_w + xx];

		if (color.r < 0 || color.g < 0 || color.b < 0) {
		    last_color = color;
		    if (run > 0) {
			XDrawLine(display, drawable, graphics_gc,
				  OriginX(screen) + refresh_x + xx - run,
				  (OriginY(screen) - scroll_y) + refresh_y + yy,
				  OriginX(screen) + refresh_x + xx - 1,
				  (OriginY(screen) - scroll_y) + refresh_y + yy);
			run = 0;
		    }
		    continue;
		}

		if (color.r != last_color.r ||
		    color.g != last_color.g ||
		    color.b != last_color.b) {
		    last_color = color;
		    if (run > 0) {
			XDrawLine(display, drawable, graphics_gc,
				  OriginX(screen) + refresh_x + xx - run,
				  (OriginY(screen) - scroll_y) + refresh_y + yy,
				  OriginX(screen) + refresh_x + xx - 1,
				  (OriginY(screen) - scroll_y) + refresh_y + yy);
			run = 0;
		    }

		    if (color.r != gc_color.r ||
			color.g != gc_color.g ||
			color.b != gc_color.b) {
			xgcv.foreground =
			    color_register_to_xpixel(&color, xw);
			XChangeGC(display, graphics_gc, GCForeground, &xgcv);
			gc_color = color;
		    }
		}
		run++;
	    }
	    if (run > 0) {
		last_color.r = -1;
		last_color.g = -1;
		last_color.b = -1;
		XDrawLine(display, drawable, graphics_gc,
			  OriginX(screen) + refresh_x + xx - run,
			  (OriginY(screen) - scroll_y) + refresh_y + yy,
			  OriginX(screen) + refresh_x + xx - 1,
			  (OriginY(screen) - scroll_y) + refresh_y + yy);
		run = 0;
	    }
	}

	XFreeGC(display, graphics_gc);
    } else {
	XGCValues xgcv;
	GC graphics_gc;
	ColorRegister old_color;
	Pixel fg;
	XImage *image;
	char *imgdata;
	unsigned image_w, image_h;

	memset(&xgcv, 0, sizeof(xgcv));
	xgcv.graphics_exposures = False;
	graphics_gc = XCreateGC(display, drawable, GCGraphicsExposures, &xgcv);
	if (graphics_gc == None) {
	    TRACE(("unable to allocate GC for graphics refresh\n"));
	    free(buffer);
	    return;
	}

	/* FIXME: is it worth reusing the GC/Image/imagedata across calls? */
	/* FIXME: is it worth using shared memory when available? */
	image_w = (unsigned) draw_x_max + 1U - (unsigned) draw_x_min;
	image_h = (unsigned) draw_y_max + 1U - (unsigned) draw_y_min;
	image = XCreateImage(display, xw->visInfo->visual,
			     (unsigned) xw->visInfo->depth,
			     ZPixmap, 0, NULL,
			     image_w, image_h,
			     sizeof(int) * 8U, 0);
	if (!image) {
	    TRACE(("unable to allocate XImage for graphics refresh\n"));
	    XFreeGC(display, graphics_gc);
	    free(buffer);
	    return;
	}
	imgdata = malloc(image_h * (unsigned) image->bytes_per_line);
	if (!imgdata) {
	    TRACE(("unable to allocate XImage for graphics refresh\n"));
	    XDestroyImage(image);
	    XFreeGC(display, graphics_gc);
	    free(buffer);
	    return;
	}
	image->data = imgdata;

	fg = 0U;
	old_color.r = -1;
	old_color.g = -1;
	old_color.b = -1;
	for (yy = draw_y_min - refresh_y; yy <= draw_y_max - refresh_y; yy++) {
	    for (xx = draw_x_min - refresh_x; xx <= draw_x_max - refresh_x;
		 xx++) {
		const ColorRegister color = buffer[yy * refresh_w + xx];

		if (color.r != old_color.r ||
		    color.g != old_color.g ||
		    color.b != old_color.b) {
		    fg = color_register_to_xpixel(&color, xw);
		    old_color = color;
		}

		XPutPixel(image, xx + refresh_x - draw_x_min,
			  yy + refresh_y - draw_y_min, fg);
	    }
	}

	XPutImage(display, drawable, graphics_gc, image,
		  0, 0,
		  OriginX(screen) + draw_x_min,
		  (OriginY(screen) - scroll_y) + draw_y_min,
		  image_w, image_h);
	free(imgdata);
	image->data = NULL;
	XDestroyImage(image);
	XFreeGC(display, graphics_gc);
    }

    free(buffer);
    XFlush(display);
}

void
refresh_displayed_graphics(XtermWidget xw,
			   int leftcol,
			   int toprow,
			   int ncols,
			   int nrows)
{
    refresh_graphics(xw, leftcol, toprow, ncols, nrows, 0);
}

void
refresh_modified_displayed_graphics(XtermWidget xw)
{
    TScreen const *screen = TScreenOf(xw);
    refresh_graphics(xw, 0, 0, MaxCols(screen), MaxRows(screen), 1);
}

void
scroll_displayed_graphics(XtermWidget xw, int rows)
{
    TScreen const *screen = TScreenOf(xw);
    unsigned ii;

    TRACE(("graphics scroll: moving all up %d rows\n", rows));
    /* FIXME: VT125 ReGIS graphics are fixed at the upper left of the display; need to verify */

    FOR_EACH_SLOT(ii) {
	Graphic *graphic;

	if (!(graphic = getActiveSlot(ii)))
	    continue;
	if (graphic->bufferid != screen->whichBuf)
	    continue;
	if (graphic->hidden)
	    continue;

	graphic->charrow -= rows;
    }
}

void
pixelarea_clear_displayed_graphics(TScreen const *screen,
				   int winx,
				   int winy,
				   int w,
				   int h)
{
    unsigned ii;

    FOR_EACH_SLOT(ii) {
	Graphic *graphic;
	/* FIXME: are these coordinates (scrolled) screen-relative? */
	int const scroll_y = (screen->whichBuf == 0
			      ? screen->topline * FontHeight(screen)
			      : 0);
	int graph_x;
	int graph_y;
	int x, y;

	if (!(graphic = getActiveSlot(ii)))
	    continue;
	if (graphic->bufferid != screen->whichBuf)
	    continue;
	if (graphic->hidden)
	    continue;

	graph_x = graphic->charcol * FontWidth(screen);
	graph_y = graphic->charrow * FontHeight(screen);
	x = winx - graph_x;
	y = (winy - scroll_y) - graph_y;

	TRACE(("pixelarea clear graphics: screen->topline=%d winx=%d winy=%d w=%d h=%d x=%d y=%d\n",
	       screen->topline,
	       winx, winy,
	       w, h,
	       x, y));
	erase_graphic(graphic, x, y, w, h);
    }
}

void
chararea_clear_displayed_graphics(TScreen const *screen,
				  int leftcol,
				  int toprow,
				  int ncols,
				  int nrows)
{
    int const x = leftcol * FontWidth(screen);
    int const y = toprow * FontHeight(screen);
    int const w = ncols * FontWidth(screen);
    int const h = nrows * FontHeight(screen);

    TRACE(("chararea clear graphics: screen->topline=%d leftcol=%d toprow=%d nrows=%d ncols=%d x=%d y=%d w=%d h=%d\n",
	   screen->topline,
	   leftcol, toprow,
	   nrows, ncols,
	   x, y, w, h));
    pixelarea_clear_displayed_graphics(screen, x, y, w, h);
}

void
reset_displayed_graphics(TScreen const *screen)
{
    unsigned ii;

    init_color_registers(getSharedRegisters(), screen->terminal_id);

    TRACE(("resetting all graphics\n"));
    FOR_EACH_SLOT(ii) {
	deactivateSlot(ii);
    }
}

#ifdef NO_LEAKS
void
noleaks_graphics(void)
{
    unsigned ii;

    FOR_EACH_SLOT(ii) {
	deactivateSlot(ii);
    }
}
#endif
@


1.7
log
@Update to xterm 320. Tested by jsg@@ Thanks.
@
text
@d1 1
a1 1
/* $XTermId: graphics.c,v 1.68 2015/07/13 08:58:48 Ross.Combs Exp $ */
d4 1
a4 1
 * Copyright 2013-2014,2015 by Ross Combs
a373 2
    int dst_x, dst_y;
    int src_x, src_y;
d397 2
a398 2
	dst_y = dst_ul_y + yy;
	src_y = src_ul_y + yy;
d403 2
a404 2
	    dst_x = dst_ul_x + xx;
	    src_x = src_ul_x + xx;
a440 1
    Graphic *graphic;
d448 2
a487 1
    unsigned d;
d500 3
a502 3
	d = (unsigned) (SQUARE(2 * (color_registers[i].r - r)) +
			SQUARE(3 * (color_registers[i].g - g)) +
			SQUARE(1 * (color_registers[i].b - b)));
d1442 1
a1442 1
		} else if (graphic->bufferid == 0) {
a1696 1
    Graphic *graphic;
d1703 2
@


1.6
log
@xterm 314. tested by naddy@@
@
text
@d1 1
a1 1
/* $XTermId: graphics.c,v 1.62 2014/12/23 00:08:58 Ross.Combs Exp $ */
d4 1
a4 1
 * Copyright 2013,2014 by Ross Combs
d55 1
a55 1
 * - find a suitable default alphabet zero font instead of scaling Xft fonts
d58 1
a58 1
 * - investigate second graphic page for ReGIS -- does it also apply to text and sixel graphics? are the contents preserved?
d61 2
a62 1
 * - enter/leave during a command
d98 3
a100 1
 * - truncate graphics at bottom edge of window?
d696 1
d811 18
a828 9
	if ((graphic = getActiveSlot(ii)) &&
	    graphic->type == type &&
	    graphic->bufferid == bufferid &&
	    graphic->charrow == charrow &&
	    graphic->charcol == charcol &&
	    graphic->actual_width == actual_width &&
	    graphic->actual_height == actual_height) {
	    TRACE(("found existing graphic index=%u id=%u\n", ii, graphic->id));
	    return graphic;
d836 4
d1360 2
d1710 2
d1739 2
@


1.5
log
@Update to xterm 313. Tested by shadchin@@
@
text
@d1 1
a1 1
/* $XTermId: graphics.c,v 1.58 2014/11/28 21:00:04 tom Exp $ */
a57 1
 * - custom coordinate systems
d63 1
a63 1
 * - scaling/re-rasterization to fit screen
d120 1
d167 1
a167 1
allocGraphic(const TScreen *screen)
d171 4
a174 2
	size_t max_pixels = (size_t) (screen->regis_max_wide * screen->regis_max_high);
	if (!(result->pixels = TypeCallocN(RegisterNum, max_pixels))) {
d201 2
a202 1
	    displayed_graphics[n] = allocGraphic(screen);
d679 1
a679 2
init_graphic(const TScreen *screen,
	     Graphic *graphic,
d687 2
a688 1
    size_t max_pixels = (size_t) (screen->regis_max_wide * screen->regis_max_high);
a716 2
    graphic->max_width = screen->regis_max_wide;
    graphic->max_height = screen->regis_max_high;
d782 1
a782 2
	init_graphic(screen,
		     graphic,
d920 1
d957 1
a957 1
	    regnum = graphic->pixels[r * graphic->max_width + c];
@


1.4
log
@Update to xterm-309. Version 308 tested by several people including
naddy@@ who found a small regression, fixed in 309.
@
text
@d1 1
a1 1
/* $XTermId: graphics.c,v 1.47 2014/07/13 01:19:45 Ross.Combs Exp $ */
d51 3
a53 1
/* TODO:
a55 1
 * - load command extension to load by font name (via Xft)
d66 1
a83 1
 * - speed up drawing by using an XImage and/or better GC and color handling
d86 1
a86 2
 * - erase graphic when erasing screen
 * - handle graphic updates in scroll regions
d88 4
a91 7
 * - maintain ordered list/array of graphics instead of qsort()
 * - erase text under graphic if bg not transparent to avoid flickering (or not: bad if the font changes or window resizes)
 * - erase graphics under graphic if same origin and bg not transparent to avoid flickering
 * - erase scrolled portions of all graphics on alt buffer
 * - delete graphic if scrolled past end of scrollback
 * - delete graphic if all pixels are transparent/erased
 * - auto-convert color graphics in VT330 mode
d95 1
a95 1
 * - ability to show non-scrolled sixel graphics in a separate window
d98 1
a107 2
 * - font selection by name
 * - user fonts in larger sizes than 8x10
d114 1
a114 1
 * - option to set actual size (not just coordinates)
a116 1
 * - F option for screen command (mentioned in docs for the DEC ReGIS to Postscript converter)
a118 1
 * - RGB triplets
d130 10
a139 1
*/
d167 1
a167 1
allocGraphic(void)
d171 2
a172 1
	if (!(result->pixels = TypeCallocN(RegisterNum, MAX_PIXELS))) {
d193 1
a193 1
getInactiveSlot(unsigned n)
d199 1
a199 1
	    displayed_graphics[n] = allocGraphic();
d233 5
d258 1
a258 1
	graphic->pixels[y * graphic->max_width + x] = (RegisterNum) color;
a260 2
    } else {
	TRACE(("pixel %d,%d out of bounds\n", x, y));
d279 15
d295 2
a296 2
	for (x = x1; x < x2; x++)
	    draw_solid_pixel(graphic, x, y, color);
a428 1
    reg->allocated = 0;
d490 1
a490 1
     * hueristic rather than something fancy like finding the minimum distance
d618 1
a618 1
	    printf("initial value for register %03u: %d,%d,%d\n",
d622 1
a622 1
		   color_registers[i].b);
d676 2
a677 1
init_graphic(Graphic *graphic,
d685 1
d691 1
a691 1
    for (i = 0U; i < MAX_PIXELS; i++)
d714 2
a715 2
    graphic->max_width = BUFFER_WIDTH;
    graphic->max_height = BUFFER_HEIGHT;
d752 1
a752 1
	if ((graphic = getInactiveSlot(ii))) {
d781 2
a782 1
	init_graphic(graphic,
d827 59
a885 1
#define ScaleForXColor(s) (unsigned short) ((long)(s) * 65535 / 100)
d888 1
a888 1
color_register_to_xpixel(ColorRegister *reg, XtermWidget xw)
d890 1
a890 2
    if (!reg->allocated) {
	XColor def;
d892 2
a893 11
	def.red = ScaleForXColor(reg->r);
	def.green = ScaleForXColor(reg->g);
	def.blue = ScaleForXColor(reg->b);
	def.flags = DoRed | DoGreen | DoBlue;
	if (!allocateBestRGB(xw, &def)) {
	    TRACE(("unable to allocate xcolor for color register\n"));
	    return 0UL;
	}
	reg->pix = def.pixel;
	reg->allocated = 1;
    }
d898 1
a898 1
    return reg->pix;
d904 16
a919 10
		int xbase,
		int ybase,
		int x,
		int y,
		int w,
		int h)
{
    Display *display = screen->display;
    Window vwindow = WhichVWin(screen)->window;
    GC graphics_gc;
d921 3
a923 7
    int pw, ph;
    int rbase, cbase;
    RegisterNum color;
    RegisterNum old_fg;
    XGCValues xgcv;
    XtGCMask mask;
    int holes, total;
d925 3
a927 2
    TRACE(("refreshing graphic from %d,%d %dx%d (valid=%d, size=%dx%d, scale=%dx%d max=%dx%d) at base=%d,%d\n",
	   x, y, w, h,
d931 1
a931 2
	   graphic->pixw,
	   graphic->pixh,
d933 1
a933 11
	   graphic->max_height,
	   xbase, ybase));

    memset(&xgcv, 0, sizeof(xgcv));
    xgcv.foreground = 0UL;
    xgcv.graphics_exposures = False;
    mask = GCForeground | GCGraphicsExposures;
    graphics_gc = XCreateGC(display, vwindow, mask, &xgcv);

    pw = graphic->pixw;
    ph = graphic->pixh;
d935 1
a935 7
    TRACE(("refreshed graphic covers 0,0 to %d,%d\n",
	   (graphic->actual_width - 1) * pw + pw - 1,
	   (graphic->actual_height - 1) * ph + ph - 1));
    TRACE(("refreshed area covers %d,%d to %d,%d\n",
	   x, y,
	   x + w - 1,
	   y + h - 1));
a936 1
    old_fg = COLOR_HOLE;
d938 3
a940 3
    rbase = 0;
    for (r = 0; r < graphic->actual_height; r++) {
	int rtest = rbase;
d942 1
a942 4
	rbase += ph;
	if (rtest + ph - 1 < y)
	    continue;
	if (rtest > y + h - 1)
d944 2
d947 2
a948 3
	cbase = 0;
	for (c = 0; c < graphic->actual_width; c++) {
	    int ctest = cbase;
d950 1
a950 4
	    cbase += pw;
	    if (ctest + pw - 1 < x)
		continue;
	    if (ctest > x + w - 1)
d952 2
d956 2
a957 2
	    color = graphic->pixels[r * graphic->max_width + c];
	    if (color == COLOR_HOLE) {
d962 20
a981 6
	    if (color != old_fg) {
		xgcv.foreground =
		    color_register_to_xpixel(&graphic->color_registers[color],
					     graphic->xw);
		XChangeGC(display, graphics_gc, mask, &xgcv);
		old_fg = color;
a982 6

	    XFillRectangle(display, vwindow, graphics_gc,
			   xbase + ctest,
			   ybase + rtest,
			   (unsigned) pw,
			   (unsigned) ph);
d986 4
a990 2
    {
	XColor def;
d992 20
a1011 45
	def.red = (short) (1.0 * 65535.0);
	def.green = (short) (0.1 * 65535.0);
	def.blue = (short) (1.0 * 65535.0);
	def.flags = DoRed | DoGreen | DoBlue;
	if (allocateBestRGB(graphic->xw, &def)) {
	    xgcv.foreground = def.pixel;
	    XChangeGC(display, graphics_gc, mask, &xgcv);
	}
	XFillRectangle(display, vwindow, graphics_gc,
		       xbase + 0,
		       ybase + 0,
		       (unsigned) pw, (unsigned) ph);
	XFillRectangle(display, vwindow, graphics_gc,
		       xbase + (graphic->actual_width - 1) * pw,
		       ybase + (graphic->actual_height - 1) * ph,
		       (unsigned) pw, (unsigned) ph);

	def.red = (unsigned short) ((1.0 - 0.1 * (rand() / (double)
						  RAND_MAX) * 65535.0));
	def.green = (unsigned short) ((0.7 + 0.2 * (rand() / (double)
						    RAND_MAX)) * 65535.0);
	def.blue = (unsigned short) ((0.1 + 0.1 * (rand() / (double)
						   RAND_MAX)) * 65535.0);
	def.flags = DoRed | DoGreen | DoBlue;
	if (allocateBestRGB(graphic->xw, &def)) {
	    xgcv.foreground = def.pixel;
	    XChangeGC(display, graphics_gc, mask, &xgcv);
	}
	XDrawLine(display, vwindow, graphics_gc,
		  xbase + x + 0, ybase + y + 0,
		  xbase + x + w - 1, ybase + y + 0);
	XDrawLine(display, vwindow, graphics_gc,
		  xbase + x + w - 1, ybase + y + 0,
		  xbase + x + 0, ybase + y + h - 1);
	XDrawLine(display, vwindow, graphics_gc,
		  xbase + x + 0, ybase + y + h - 1,
		  xbase + x + w - 1, ybase + y + h - 1);
	XDrawLine(display, vwindow, graphics_gc,
		  xbase + x + w - 1, ybase + y + h - 1,
		  xbase + x + 0, ybase + y + 0);
    }
#endif
    XFlush(display);
    TRACE(("done refreshing graphic: %d of %d refreshed pixels were holes\n",
	   holes, total));
d1013 49
a1061 1
    XFreeGC(display, graphics_gc);
d1063 1
d1074 3
a1076 4
    double hs = (h + 240) % 360;
    double hv = hs / 360.0;
    double lv = l / 100.0;
    double sv = s / 100.0;
a1078 1
    int hpi;
d1085 2
a1086 1
    if ((c2 = ((2.0 * lv) - 1.0)) < 0.0)
d1089 1
a1089 2
    hpi = (int) (hv * 6.0);
    x = (hpi & 1) ? c : 0.0;
d1092 1
a1092 1
    switch (hpi) {
d1212 2
a1213 2
 * of the given size and location in pixels.
 * This is used to allow text to "erase" graphics underneath it.
d1253 6
d1265 3
a1267 6
void
refresh_displayed_graphics(TScreen const *screen,
			   int leftcol,
			   int toprow,
			   int ncols,
			   int nrows)
d1269 38
d1308 5
a1312 5
    Graphic *graphic;
    unsigned ii;
    unsigned jj = 0;
    int x, y, w, h;
    int xbase, ybase;
d1314 1
d1316 25
a1340 2
	if ((graphic = getActiveSlot(ii))) {
	    ordered_graphics[jj++] = graphic;
d1342 1
d1344 4
a1347 1
    if (jj > 1) {
d1349 1
a1349 1
	      (size_t) jj,
d1354 118
a1471 4
    for (ii = 0; ii < jj; ++ii) {
	graphic = ordered_graphics[ii];
	if (graphic->bufferid != screen->whichBuf)
	    continue;
d1473 10
a1482 18
	x = (leftcol - graphic->charcol) * FontWidth(screen);
	y = (toprow - graphic->charrow) * FontHeight(screen);
	w = ncols * FontWidth(screen);
	h = nrows * FontHeight(screen);

	xbase = (OriginX(screen)
		 + graphic->charcol * FontWidth(screen));
	ybase = (OriginY(screen)
		 + (graphic->charrow - screen->topline) * FontHeight(screen));

	if (xbase + x + w + OriginX(screen) > FullWidth(screen))
	    w = FullWidth(screen) - (xbase + x + OriginX(screen));
	if (ybase + y + h + OriginY(screen) > FullHeight(screen))
	    h = FullHeight(screen) - (ybase + y + OriginY(screen));
	else if (ybase + y < OriginY(screen)) {
	    int diff = OriginY(screen) - (ybase + y);
	    y += diff;
	    h -= diff;
d1484 1
d1486 4
a1489 7
	TRACE(("graphics refresh: screen->topline=%d leftcol=%d toprow=%d nrows=%d ncols=%d x=%d y=%d w=%d h=%d xbase=%d ybase=%d\n",
	       screen->topline,
	       leftcol, toprow,
	       nrows, ncols,
	       x, y, w, h,
	       xbase, ybase));
	refresh_graphic(screen, graphic, xbase, ybase, x, y, w, h);
a1490 1
}
d1492 85
a1576 9
void
refresh_modified_displayed_graphics(TScreen const *screen)
{
    Graphic *graphic;
    unsigned ii;
    int leftcol, toprow;
    int nrows, ncols;
    int x, y, w, h;
    int xbase, ybase;
d1578 59
a1636 7
    FOR_EACH_SLOT(ii) {
	if (!(graphic = getActiveSlot(ii)))
	    continue;
	if (graphic->bufferid != screen->whichBuf)
	    continue;
	if (!graphic->dirty)
	    continue;
d1638 3
a1640 27
	leftcol = graphic->charcol;
	toprow = graphic->charrow;
	nrows = (((graphic->actual_height * graphic->pixh)
		  + FontHeight(screen) - 1)
		 / FontHeight(screen));
	ncols = (((graphic->actual_width * graphic->pixw)
		  + FontWidth(screen) - 1)
		 / FontWidth(screen));

	x = (leftcol - graphic->charcol) * FontWidth(screen);
	y = (toprow - graphic->charrow) * FontHeight(screen);
	w = ncols * FontWidth(screen);
	h = nrows * FontHeight(screen);

	xbase = (OriginX(screen)
		 + graphic->charcol * FontWidth(screen));
	ybase = (OriginY(screen)
		 + (graphic->charrow - screen->topline) * FontHeight(screen));

	if (xbase + x + w + OriginX(screen) > FullWidth(screen))
	    w = FullWidth(screen) - (xbase + x + OriginX(screen));
	if (ybase + y + h + OriginY(screen) > FullHeight(screen))
	    h = FullHeight(screen) - (ybase + y + OriginY(screen));
	else if (ybase + y < OriginY(screen)) {
	    int diff = OriginY(screen) - (ybase + y);
	    y += diff;
	    h -= diff;
d1643 9
a1651 8
	TRACE(("full graphics refresh: screen->topline=%d leftcol=%d toprow=%d nrows=%d ncols=%d x=%d y=%d w=%d h=%d xbase=%d ybase=%d\n",
	       screen->topline,
	       leftcol, toprow,
	       nrows, ncols,
	       x, y, w, h,
	       xbase, ybase));
	refresh_graphic(screen, graphic, xbase, ybase, x, y, w, h);
	graphic->dirty = 0;
d1653 3
d1659 18
a1676 1
scroll_displayed_graphics(int rows)
d1678 1
d1688 2
a1701 1
    Graphic *graphic;
a1702 1
    int x, y;
d1705 9
d1716 2
d1719 4
a1722 2
	x = winx - graphic->charcol * FontWidth(screen);
	y = winy - graphic->charrow * FontHeight(screen);
d1724 1
a1724 1
	TRACE(("pixelarea graphics erase: screen->topline=%d winx=%d winy=%d w=%d h=%d x=%d y=%d\n",
d1740 4
a1743 6
    int x, y, w, h;

    x = leftcol * FontWidth(screen);
    y = toprow * FontHeight(screen);
    w = ncols * FontWidth(screen);
    h = nrows * FontHeight(screen);
@


1.3
log
@Update to xterm 304. With help of shadchin@@

tested by ajacoutot@@ and shadchin@@
@
text
@d1 1
a1 1
/* $XTermId: graphics.c,v 1.42 2014/05/03 14:26:57 tom Exp $ */
d53 2
a54 5
 * - shading with text
 * - polygon filling
 * - plane write control
 * - fix interpolated curves to more closely match implementation (identical despite direction and starting point)
 * - text
d57 1
a57 1
 * - stacks
d59 2
a60 1
 * - font upload, italics, and other text attributes
a62 2
 * - scrolling
 * - custom coordinate systems
d65 1
d68 2
d72 11
a82 1
 * common:
d88 1
a88 1
 * - maintain ordered list/array instead of qsort()
d94 2
a95 3
 * - dynamic memory allocation of graphics buffers, add configurable limits
 * - auto convert color graphics in VT330 mode
 * - posturize requested colors to match hardware palettes (e.g. four possible shades on VT240)
d97 7
a103 3
 * escape sequences:
 * - way to query font size without "window ops" (or make "window ops" permissions more fine grained)
 * - way to query and/or set the maximum number of color registers
d105 1
d107 13
a119 1
 * - gradients
d221 2
a222 2
    if (x < 0 && x >= graphic->actual_width &&
	y < 0 && y >= graphic->actual_height) {
d338 58
d497 1
a497 1
    TRACE(("setting inital colors for terminal %d\n", terminal_id));
@


1.2
log
@Update to xterm-300. Tested  by ajacoutot@@ and shadchin@@.
@
text
@d1 1
a1 1
/* $XTermId: graphics.c,v 1.17 2013/11/26 22:15:21 tom Exp $ */
d4 1
a4 1
 * Copyright 2013 by Ross Combs
a35 1
#include <math.h>
a39 1
#include <VTparse.h>
d45 4
a48 1
#undef DUMP_SIXEL_BITMAP
d53 19
d73 3
a75 1
 * sixel:
d77 2
d80 2
a81 1
 * - erase text under graphics if bg not transparent
d85 1
a85 1
 * - dynamic memory allocation, add configurable limits
d87 3
a89 5
 * - investigate second graphic framebuffer for ReGIS -- does this apply to text and sixel graphics?
 * - fix problem where new_row < 0 during sixel parsing (see FIXME)
 * VT55/VT105 waveform graphics
 * - everything
 * escape sequences
d92 10
d108 1
a110 1
 *   10 x 13   6 x 13  26 lines + keyboard indicator line
d113 27
a139 13
/***====================================================================***/
/*
 * Parse numeric parameters which have the operator as a prefix rather than a
 * suffix as in ANSI format.
 *
 *  #             0
 *  #1            1
 *  #1;           1
 *  "1;2;640;480  4
 *  #1;2;0;0;0    5
 */
static void
parse_prefixedtype_params(ANSI *params, const char **string)
d141 6
a146 26
    const char *cp = *string;
    ParmType nparam = 0;
    int last_empty = 1;

    memset(params, 0, sizeof(*params));
    params->a_final = CharOf(*cp);
    if (*cp != '\0')
	cp++;

    while (*cp != '\0') {
	Char ch = CharOf(*cp);

	if (isdigit(ch)) {
	    last_empty = 0;
	    if (nparam < NPARAM) {
		params->a_param[nparam] =
		    (ParmType) ((params->a_param[nparam] * 10)
				+ (ch - '0'));
	    }
	} else if (ch == ';') {
	    last_empty = 1;
	    nparam++;
	} else if (ch == ' ' || ch == '\r' || ch == '\n') {
	    /* EMPTY */ ;
	} else {
	    break;
a147 1
	cp++;
d149 2
d152 23
a174 7
    *string = cp;
    if (!last_empty)
	nparam++;
    if (nparam > NPARAM)
	params->a_nparam = NPARAM;
    else
	params->a_nparam = nparam;
d177 7
a183 57
typedef struct {
    Pixel pix;
    short r, g, b;
    short allocated;
} ColorRegister;

#define MAX_COLOR_REGISTERS 256U
#define COLOR_HOLE ((unsigned short)MAX_COLOR_REGISTERS)
#define BUFFER_WIDTH 1000
#define BUFFER_HEIGHT 800
typedef struct {
    RegisterNum pixels[BUFFER_HEIGHT * BUFFER_WIDTH];
    ColorRegister private_color_registers[MAX_COLOR_REGISTERS];
    ColorRegister *color_registers;
    char color_registers_used[MAX_COLOR_REGISTERS];
    XtermWidget xw;
    int max_width;		/* largest image which can be stored */
    int max_height;		/* largest image which can be stored */
    RegisterNum current_register;
    int valid_registers;	/* for wrap-around behavior */
    int device_background;	/* 0: set to color 0, 1: unchanged */
    int background;		/* current background color */
    int aspect_vertical;
    int aspect_horizontal;
    int declared_width;		/* size as reported by the application */
    int declared_height;	/* size as reported by the application */
    int actual_width;		/* size measured during parsing */
    int actual_height;		/* size measured during parsing */
    int private_colors;		/* if not using the shared color registers */
    int charrow;		/* upper left starting point in characters */
    int charcol;		/* upper left starting point in characters */
    int pixw;			/* width of graphic pixels in screen pixels */
    int pixh;			/* height of graphic pixels in screen pixels */
    int row;			/* context used during parsing */
    int col;			/* context used during parsing */
    int bufferid;		/* which screen buffer the graphic is associated with */
    unsigned int id;		/* sequential id used for preserving layering */
    int valid;			/* if the graphic has been initialized */
    int dirty;			/* if the graphic needs to be redrawn */
} SixelGraphic;

static unsigned int next_sixel_id = 0U;

static ColorRegister shared_color_registers[MAX_COLOR_REGISTERS];

#define MAX_SIXEL_GRAPHICS 16U
static SixelGraphic sixel_graphics[MAX_SIXEL_GRAPHICS];

/* sixel scrolling:
 * VK100/GIGI ? (did it even support Sixel?)
 * VT125      unsupported
 * VT240      unsupported
 * VT241      unsupported
 * VT330      mode setting
 * VT340      mode setting
 * dxterm     ?
 */
d186 1
a186 1
init_sixel_background(SixelGraphic *graphic)
d188 4
a191 2
    RegisterNum bgcolor = (RegisterNum) graphic->background;
    int r, c;
d193 6
a198 12
    TRACE(("initializing sixel background to size=%dx%d bgcolor=%hu\n",
	   graphic->declared_width,
	   graphic->declared_height,
	   bgcolor));
    for (r = 0; r < graphic->max_height; r++) {
	for (c = 0; c < graphic->max_width; c++) {
	    if (c < graphic->declared_width && r < graphic->declared_height) {
		graphic->pixels[r * graphic->max_width + c] = bgcolor;
	    } else {
		graphic->pixels[r * graphic->max_width + c] = COLOR_HOLE;
	    }
	}
d200 2
d204 2
a205 2
static void
set_sixel(SixelGraphic *graphic, int sixel)
d207 1
a207 2
    RegisterNum color;
    int pix;
d209 4
a212 4
    color = graphic->current_register;
    TRACE(("drawing sixel at pos=%d,%d color=%hu (hole=%d, [%d,%d,%d])\n",
	   graphic->col,
	   graphic->row,
d214 1
a214 1
	   color == COLOR_HOLE,
d216 1
a216 1
	    ? (unsigned int) graphic->color_registers[color].r : 0U),
d218 1
a218 1
	    ? (unsigned int) graphic->color_registers[color].g : 0U),
d220 86
a305 15
	    ? (unsigned int) graphic->color_registers[color].b : 0U)));
    for (pix = 0; pix < 6; pix++) {
	if (graphic->col < graphic->max_width &&
	    graphic->row + pix < graphic->max_height) {
	    if (sixel & (1 << pix)) {
		if (graphic->col + 1 > graphic->actual_width) {
		    graphic->actual_width = graphic->col + 1;
		}
		if (graphic->row + pix + 1 > graphic->actual_height) {
		    graphic->actual_height = graphic->row + pix + 1;
		}
		graphic->pixels[
				   (((graphic->row + pix) * graphic->max_width)
				    + graphic->col)
		    ] = color;
d307 2
a308 2
	} else {
	    TRACE(("sixel pixel %d out of bounds\n", pix));
d314 5
a318 5
set_sixel_color_register(ColorRegister *color_registers,
			 int color,
			 int r,
			 int g,
			 int b)
d327 84
d414 1
a414 1
    TRACE(("initializing colors for %d\n", terminal_id));
d416 1
a416 1
	unsigned int i;
d419 1
a419 1
	    set_sixel_color_register(color_registers, (int) i, 0, 0, 0);
d463 3
a465 1
     *  15: 100%    75%
d472 4
a475 4
	set_sixel_color_register(color_registers, 0, 0, 0, 0);
	set_sixel_color_register(color_registers, 1, 0, 0, 100);
	set_sixel_color_register(color_registers, 2, 0, 100, 0);
	set_sixel_color_register(color_registers, 3, 100, 0, 0);
d479 4
a482 4
	set_sixel_color_register(color_registers, 0, 0, 0, 0);
	set_sixel_color_register(color_registers, 1, 33, 33, 33);
	set_sixel_color_register(color_registers, 2, 66, 66, 66);
	set_sixel_color_register(color_registers, 3, 100, 100, 100);
d486 20
a505 16
	set_sixel_color_register(color_registers, 0, 0, 0, 0);
	set_sixel_color_register(color_registers, 1, 20, 20, 80);
	set_sixel_color_register(color_registers, 2, 80, 13, 13);
	set_sixel_color_register(color_registers, 3, 20, 80, 20);
	set_sixel_color_register(color_registers, 4, 80, 20, 80);
	set_sixel_color_register(color_registers, 5, 20, 80, 80);
	set_sixel_color_register(color_registers, 6, 80, 80, 20);
	set_sixel_color_register(color_registers, 7, 53, 53, 53);
	set_sixel_color_register(color_registers, 8, 26, 26, 26);
	set_sixel_color_register(color_registers, 9, 33, 33, 60);
	set_sixel_color_register(color_registers, 10, 60, 26, 26);
	set_sixel_color_register(color_registers, 11, 33, 60, 33);
	set_sixel_color_register(color_registers, 12, 60, 33, 60);
	set_sixel_color_register(color_registers, 13, 33, 60, 60);
	set_sixel_color_register(color_registers, 14, 60, 60, 33);
	set_sixel_color_register(color_registers, 15, 80, 80, 80);
d508 14
d524 2
a525 2
static void
init_sixel_graphic(SixelGraphic *graphic, int terminal_id, int private_colors)
d527 1
a527 1
    TRACE(("initializing sixel graphic\n"));
d529 5
a533 3
    graphic->dirty = 1;
    memset(graphic->pixels, 0, sizeof(graphic->pixels));
    memset(graphic->color_registers_used, 0, sizeof(graphic->color_registers_used));
d535 5
a539 29
    /*
     * dimensions (REGIS logical, physical):
     * VK100/GIGI  768x4??  768x2??
     * VT125       768x460  768x230(+10status) (1:2 aspect ratio, REGIS halves vertical addresses through "odd y emulation")
     * VT240       800x460  800x230(+10status) (1:2 aspect ratio, REGIS halves vertical addresses through "odd y emulation")
     * VT241       800x460  800x230(+10status) (1:2 aspect ratio, REGIS halves vertical addresses through "odd y emulation")
     * VT330       800x480  800x480(+?status)
     * VT340       800x480  800x480(+?status)
     * dxterm      ?x?      variable?
     */
    graphic->max_width = BUFFER_WIDTH;
    graphic->max_height = BUFFER_HEIGHT;

    /* default isn't white on the VT240, but not sure what it is */
    graphic->current_register = 3;	/* FIXME: using green, but not sure what it should be */

    /*
     * When an application selects the monochrome map:  the terminal sets the
     * 16 entries of the color map to the default monochrome gray level.
     * Therefore, the original colors are lost when changing from the color map
     * to the monochrome map.
     *
     * If you change the color value (green, red, blue) using the Color Set-Up
     * screen or a ReGIS command, the VT340 sets the gray scale by using the
     * formula (2G + R)/3.
     *
     * When an application selects the color map:  the terminal sets the 16
     * entries of the color map to the default (color) color map.
     */
d545 1
a545 1
     * VT240       2 planes (4 registers) colorspace is ? shades (grayscale)
d549 1
d552 1
a552 1
    switch (terminal_id) {
d554 1
a554 2
	graphic->valid_registers = 4;
	break;
d556 1
a556 2
	graphic->valid_registers = 4;
	break;
d558 1
a558 2
	graphic->valid_registers = 4;
	break;
d560 1
a560 2
	graphic->valid_registers = 4;
	break;
d562 3
a564 2
	graphic->valid_registers = 16;
	break;
d566 2
a567 2
	graphic->valid_registers = 64;	/* unknown graphics model -- might as well be generous */
	break;
d569 19
d593 1
d597 13
a609 2
    /* FIXME: is this always zero?  what about in light background mode? */
    graphic->device_background = 0;	/* default background color register */
d611 2
a612 4
    /* pixel sizes seem to have differed by model and options */
    /* VT240 and VT340 defaulted to 2:1 ratio */
    graphic->aspect_vertical = 2;
    graphic->aspect_horizontal = 1;
d614 2
a615 2
    graphic->declared_width = 0;
    graphic->declared_height = 0;
d617 2
a618 2
    graphic->actual_width = 0;
    graphic->actual_height = 0;
d622 1
a622 1
	TRACE(("sixel using private color registers\n"));
d626 2
a627 2
	TRACE(("sixel using shared color registers\n"));
	graphic->color_registers = shared_color_registers;
d630 3
a632 6
    graphic->charrow = 0;
    graphic->charcol = 0;

    graphic->row = 0;
    graphic->col = 0;

d636 2
a637 2
static SixelGraphic *
get_sixel_graphic(XtermWidget xw)
d642 6
a647 7
    int private_colors = screen->privatecolorregisters;
    SixelGraphic *graphic;
    unsigned int ii;

    for (ii = 0U; ii < MAX_SIXEL_GRAPHICS; ii++) {
	graphic = &sixel_graphics[ii];
	if (!graphic->valid)
d649 1
d652 2
a653 1
    if (ii >= MAX_SIXEL_GRAPHICS) {
d655 1
a655 1
	SixelGraphic *min_graphic = NULL;
d657 3
a659 2
	for (ii = 0U; ii < MAX_SIXEL_GRAPHICS; ii++) {
	    graphic = &sixel_graphics[ii];
d665 1
d669 14
a682 4
    graphic->xw = xw;
    graphic->bufferid = bufferid;
    graphic->id = next_sixel_id++;
    init_sixel_graphic(graphic, terminal_id, private_colors);
d686 7
a692 2
static void
dump_sixel(SixelGraphic const *graphic)
d694 4
a697 15
#ifdef DUMP_SIXEL_BITMAP
    int r, c;
    RegisterNum color;
    ColorRegister const *reg;
#endif

    (void) graphic;

    TRACE(("sixel stats: charrow=%d charcol=%d actual_width=%d actual_height=%d pixw=%d pixh=%d\n",
	   graphic->charrow,
	   graphic->charcol,
	   graphic->actual_width,
	   graphic->actual_height,
	   graphic->pixw,
	   graphic->pixh));
d699 10
a708 21
#ifdef DUMP_SIXEL_BITMAP
    TRACE(("sixel dump:\n"));
    for (r = 0; r < graphic->max_height; r++) {
	for (c = 0; c < graphic->max_width; c++) {
	    color = graphic->pixels[r * graphic->max_width + c];
	    if (color == COLOR_HOLE) {
		TRACE(("?"));
	    } else {
		reg = &graphic->color_registers[color];
		if (reg->r + reg->g + reg->b > 200) {
		    TRACE(("#"));
		} else if (reg->r + reg->g + reg->b > 150) {
		    TRACE(("%%"));
		} else if (reg->r + reg->g + reg->b > 100) {
		    TRACE((":"));
		} else if (reg->r + reg->g + reg->b > 80) {
		    TRACE(("."));
		} else {
		    TRACE((" "));
		}
	    }
a709 1
	TRACE(("\n"));
a710 3
#endif
    TRACE(("\n"));
}
d712 4
a715 18
static void
set_shared_color_register(int color, int r, int g, int b)
{
    SixelGraphic *graphic;
    unsigned int ii;

    assert(color < (int) MAX_COLOR_REGISTERS);

    set_sixel_color_register(shared_color_registers, color, r, g, b);

    for (ii = 0U; ii < MAX_SIXEL_GRAPHICS; ii++) {
	graphic = &sixel_graphics[ii];
	if (graphic->private_colors)
	    continue;

	if (graphic->color_registers_used[ii]) {
	    graphic->dirty = 1;
	}
d717 1
d723 1
a723 1
sixel_register_to_xpixel(ColorRegister *reg, XtermWidget xw)
d733 1
d747 8
a754 8
refresh_sixel_graphic(TScreen const *screen,
		      SixelGraphic *graphic,
		      int xbase,
		      int ybase,
		      int x,
		      int y,
		      int w,
		      int h)
a759 1
    int wx, wy;
d761 1
d768 1
a768 1
    TRACE(("refreshing sixel graphic from %d,%d %dx%d (valid=%d, bg=%dx%d size=%dx%d, max=%dx%d) at base=%d,%d\n",
a770 2
	   graphic->declared_width,
	   graphic->declared_height,
d773 2
d798 11
a808 1
    for (r = 0; r < graphic->actual_height; r++)
d810 6
a815 4
	    if (r * ph + ph - 1 < y ||
		r * ph > y + h - 1 ||
		c * pw + pw - 1 < x ||
		c * pw > x + w - 1)
a817 3
	    wy = ybase + r * ph;
	    wx = xbase + c * pw;

d827 1
a827 1
		    sixel_register_to_xpixel(&graphic->color_registers[color],
d834 4
a837 1
			   wx, wy, (unsigned) pw, (unsigned) ph);
d839 1
d888 1
a888 1
    TRACE(("done refreshing sixel graphic: %d of %d refreshed pixels were holes\n",
d900 1
a900 1
static void
d907 1
a907 1
    double c, x, m;
d916 3
a918 1
    c = (1.0 - fabs(2.0 * lv - 1.0)) * sv;
d955 1
a955 1
	printf("BAD\n");
d980 2
a981 2
static void
update_sixel_aspect(SixelGraphic *graphic)
d983 16
a998 24
    /* We want to keep the ratio accurate but would like every pixel to have
     * the same size so keep these as whole numbers.
     */
    /* FIXME: DEC terminals had pixels about twice as tall as they were wide,
     * and it seems the VT125 and VT24x only used data from odd graphic rows.
     * This means it basically cancels out if we ignore both, except that
     * the even rows of pixels may not be written by the application such that
     * they are suitable for display.  In practice this doesn't seem to be
     * an issue but I have very few test files/programs.
     */
    if (graphic->aspect_vertical < graphic->aspect_horizontal) {
	graphic->pixw = 1;
	graphic->pixh = ((graphic->aspect_vertical
			  + graphic->aspect_horizontal - 1)
			 / graphic->aspect_horizontal);
    } else {
	graphic->pixw = ((graphic->aspect_horizontal
			  + graphic->aspect_vertical - 1)
			 / graphic->aspect_vertical);
	graphic->pixh = 1;
    }
    TRACE(("sixel aspect ratio: an=%d ad=%d -> pixw=%d pixh=%d\n",
	   graphic->aspect_vertical,
	   graphic->aspect_horizontal,
a1000 105
}

/*
 * Interpret sixel graphics sequences.
 *
 * Resources:
 *  http://en.wikipedia.org/wiki/Sixel
 *  http://vt100.net/docs/vt3xx-gp/chapter14.html
 *  ftp://ftp.cs.utk.edu/pub/shuford/terminal/sixel_graphics_news.txt
 *  ftp://ftp.cs.utk.edu/pub/shuford/terminal/all_about_sixels.txt
 */
extern void
parse_sixel(XtermWidget xw, ANSI *params, char const *string)
{
    TScreen *screen = TScreenOf(xw);
    SixelGraphic *graphic;
    Char ch;

    graphic = get_sixel_graphic(xw);

    {
	int Pmacro = params->a_param[0];
	int Pbgmode = params->a_param[1];
	int Phgrid = params->a_param[2];
	int Pan = params->a_param[3];
	int Pad = params->a_param[4];
	int Ph = params->a_param[5];
	int Pv = params->a_param[6];

	(void) Phgrid;

	TRACE(("sixel bitmap graphics sequence: params=%d (Pmacro=%d Pbgmode=%d Phgrid=%d) scroll_amt=%d\n",
	       params->a_nparam,
	       Pmacro,
	       Pbgmode,
	       Phgrid,
	       screen->scroll_amt));

	switch (params->a_nparam) {
	case 7:
	    if (Pan == 0 || Pad == 0) {
		TRACE(("DATA_ERROR: invalid raster ratio %d/%d\n", Pan, Pad));
		return;
	    }
	    graphic->aspect_vertical = Pan;
	    graphic->aspect_horizontal = Pad;

	    if (Ph == 0 || Pv == 0) {
		TRACE(("DATA_ERROR: raster image dimensions are invalid %dx%d\n",
		       Ph, Pv));
		return;
	    }
	    if (Ph > graphic->max_width || Pv > graphic->max_height) {
		TRACE(("DATA_ERROR: raster image dimensions are too large %dx%d\n",
		       Ph, Pv));
		return;
	    }
	    graphic->declared_width = Ph;
	    graphic->declared_height = Pv;
	    if (graphic->declared_width > graphic->actual_width) {
		graphic->actual_width = graphic->declared_width;
	    }
	    if (graphic->declared_height > graphic->actual_height) {
		graphic->actual_height = graphic->declared_height;
	    }
	    break;
	case 3:
	case 2:
	    switch (Pmacro) {
	    case 0:
	    case 1:
		graphic->aspect_vertical = 5;
		graphic->aspect_horizontal = 1;
		break;
	    case 2:
		graphic->aspect_vertical = 3;
		graphic->aspect_horizontal = 1;
		break;
	    case 3:
	    case 4:
		graphic->aspect_vertical = 2;
		graphic->aspect_horizontal = 1;
		break;
	    case 5:
	    case 6:
		graphic->aspect_vertical = 2;
		graphic->aspect_horizontal = 1;
		break;
	    case 7:
	    case 8:
	    case 9:
		graphic->aspect_vertical = 1;
		graphic->aspect_horizontal = 1;
		break;
	    default:
		TRACE(("DATA_ERROR: unknown sixel macro mode parameter\n"));
		return;
	    }
	    break;
	case 0:
	    break;
	default:
	    TRACE(("DATA_ERROR: unexpected parameter count (found %d)\n", params->a_nparam));
	    return;
	}
d1002 8
a1009 16
	if (Pbgmode == 1) {
	    graphic->background = COLOR_HOLE;
	} else {
	    graphic->background = graphic->device_background;
	}

	/* Ignore the grid parameter because it seems only printers paid attention to it.
	 * The VT3xx was always 0.0195 cm.
	 */
    }

#if OPT_SIXEL_GRAPHICS
    if (xw->keyboard.flags & MODE_DECSDM) {
	TRACE(("sixel scrolling enabled: inline positioning for graphic\n"));
	graphic->charrow = screen->cur_row;
	graphic->charcol = screen->cur_col;
a1010 2

    update_sixel_aspect(graphic);
d1013 17
a1029 44
    for (;;) {
	ch = CharOf(*string);
	if (ch == '\0')
	    break;

	if (ch >= 0x3f && ch <= 0x7e) {
	    int sixel = ch - 0x3f;
	    TRACE(("sixel=%x (%c)\n", sixel, (char) ch));
	    if (!graphic->valid) {
		init_sixel_background(graphic);
		graphic->valid = 1;
	    }
	    set_sixel(graphic, sixel);
	    graphic->col++;
	} else if (ch == '$') {	/* DECGCR */
	    /* ignore DECCRNLM in sixel mode */
	    TRACE(("sixel CR\n"));
	    graphic->col = 0;
	} else if (ch == '-') {	/* DECGNL */
	    int scroll_lines;
	    TRACE(("sixel NL\n"));
	    scroll_lines = 0;
	    while (graphic->charrow - scroll_lines +
		   (((graphic->row + 6) * graphic->pixh
		     + FontHeight(screen) - 1)
		    / FontHeight(screen)) > screen->bot_marg) {
		scroll_lines++;
	    }
	    graphic->col = 0;
	    graphic->row += 6;
	    /* If we hit the bottom margin on the graphics page (well, we just use the text margin for now),
	     * the behavior is to either scroll or to discard the remainder of the graphic depending on this
	     * setting.
	     */
	    if (scroll_lines > 0) {
		if (xw->keyboard.flags & MODE_DECSDM) {
		    Display *display = screen->display;
		    xtermScroll(xw, scroll_lines);
		    XSync(display, False);
		    TRACE(("graphic scrolled the screen %d lines. screen->scroll_amt=%d screen->topline=%d, now starting row is %d\n",
			   scroll_lines,
			   screen->scroll_amt,
			   screen->topline,
			   graphic->charrow));
d1031 1
a1031 1
		    break;
a1033 160
	} else if (ch == '!') {	/* DECGRI */
	    int Pcount;
	    const char *start;
	    int sixel;
	    int i;

	    start = ++string;
	    for (;;) {
		ch = CharOf(*string);
		if (ch != '0' &&
		    ch != '1' &&
		    ch != '2' &&
		    ch != '3' &&
		    ch != '4' &&
		    ch != '5' &&
		    ch != '6' &&
		    ch != '7' &&
		    ch != '8' &&
		    ch != '9' &&
		    ch != ' ' &&
		    ch != '\r' &&
		    ch != '\n')
		    break;
		string++;
	    }
	    if (ch == '\0') {
		TRACE(("DATA_ERROR: sixel data string terminated in the middle of a repeat operator\n"));
		return;
	    }
	    if (string == start) {
		TRACE(("DATA_ERROR: sixel data string contains a repeat operator with empty count\n"));
		return;
	    }
	    Pcount = atoi(start);
	    sixel = ch - 0x3f;
	    TRACE(("sixel repeat operator: sixel=%d (%c), count=%d\n",
		   sixel, (char) ch, Pcount));
	    if (!graphic->valid) {
		init_sixel_background(graphic);
		graphic->valid = 1;
	    }
	    for (i = 0; i < Pcount; i++) {
		set_sixel(graphic, sixel);
		graphic->col++;
	    }
	} else if (ch == '#') {	/* DECGCI */
	    ANSI color_params;
	    int Pregister;

	    parse_prefixedtype_params(&color_params, &string);
	    Pregister = color_params.a_param[0];
	    if (Pregister >= graphic->valid_registers) {
		TRACE(("DATA_WARNING: sixel color operator uses out-of-range register %d\n", Pregister));
		/* FIXME: supposedly the DEC terminals wrapped register indicies -- verify */
		while (Pregister >= graphic->valid_registers)
		    Pregister -= graphic->valid_registers;
		TRACE(("DATA_WARNING: converted to %d\n", Pregister));
	    }

	    if (color_params.a_nparam > 2 && color_params.a_nparam <= 5) {
		int Pspace = color_params.a_param[1];
		int Pc1 = color_params.a_param[2];
		int Pc2 = color_params.a_param[3];
		int Pc3 = color_params.a_param[4];
		short r, g, b;

		TRACE(("sixel set color register=%d space=%d color=[%d,%d,%d] (nparams=%d)\n",
		       Pregister, Pspace, Pc1, Pc2, Pc3, color_params.a_nparam));

		switch (Pspace) {
		case 1:	/* HLS */
		    if (Pc1 > 360 || Pc2 > 100 || Pc3 > 100) {
			TRACE(("DATA_ERROR: sixel set color operator uses out-of-range HLS color coordinates %d,%d,%d\n",
			       Pc1, Pc2, Pc3));
			return;
		    }
		    hls2rgb(Pc1, Pc2, Pc3, &r, &g, &b);
		    break;
		case 2:	/* RGB */
		    if (Pc1 > 100 || Pc2 > 100 || Pc3 > 100) {
			TRACE(("DATA_ERROR: sixel set color operator uses out-of-range RGB color coordinates %d,%d,%d\n",
			       Pc1, Pc2, Pc3));
			return;
		    }
		    r = (short) Pc1;
		    g = (short) Pc2;
		    b = (short) Pc3;
		    break;
		default:	/* unknown */
		    TRACE(("DATA_ERROR: sixel set color operator uses unknown color space %d\n", Pspace));
		    return;
		}
		if (graphic->private_colors) {
		    set_sixel_color_register(graphic->private_color_registers,
					     Pregister,
					     r, g, b);
		} else {
		    set_shared_color_register(Pregister, r, g, b);
		}
		graphic->color_registers_used[Pregister] = 1;
	    } else if (color_params.a_nparam == 1) {
		TRACE(("sixel switch to color register=%d (nparams=%d)\n",
		       Pregister, color_params.a_nparam));
		graphic->current_register = (RegisterNum) Pregister;
	    } else {
		TRACE(("DATA_ERROR: sixel switch color operator with unexpected parameter count (nparams=%d)\n", color_params.a_nparam));
		return;
	    }
	    continue;
	} else if (ch == '"') /* DECGRA */  {
	    ANSI raster_params;

	    parse_prefixedtype_params(&raster_params, &string);
	    if (raster_params.a_nparam < 2) {
		TRACE(("DATA_ERROR: sixel raster attribute operator with incomplete parameters (found %d, expected 2 or 4)\n", raster_params.a_nparam));
		return;
	    } {
		int Pan = raster_params.a_param[0];
		int Pad = raster_params.a_param[1];
		TRACE(("sixel raster attribute with h:w=%d:%d\n", Pan, Pad));
		if (Pan == 0 || Pad == 0) {
		    TRACE(("DATA_ERROR: invalid raster ratio %d/%d\n", Pan, Pad));
		    return;
		}
		graphic->aspect_vertical = Pan;
		graphic->aspect_horizontal = Pad;
		update_sixel_aspect(graphic);
	    }

	    if (raster_params.a_nparam >= 4) {
		int Ph = raster_params.a_param[2];
		int Pv = raster_params.a_param[3];

		TRACE(("sixel raster attribute with h=%d v=%d\n", Ph, Pv));
		if (Ph == 0 || Pv == 0) {
		    TRACE(("DATA_ERROR: raster image dimensions are invalid %dx%d\n",
			   Ph, Pv));
		    return;
		}
		if (Ph > graphic->max_width || Pv > graphic->max_height) {
		    TRACE(("DATA_ERROR: raster image dimensions are too large %dx%d\n",
			   Ph, Pv));
		    return;
		}
		graphic->declared_width = Ph;
		graphic->declared_height = Pv;
		if (graphic->declared_width > graphic->actual_width) {
		    graphic->actual_width = graphic->declared_width;
		}
		if (graphic->declared_height > graphic->actual_height) {
		    graphic->actual_height = graphic->declared_height;
		}
	    }

	    continue;
	} else if (ch == ' ' || ch == '\r' || ch == '\n') {
	    /* EMPTY */ ;
	} else {
	    TRACE(("DATA_ERROR: unknown sixel command %04x (%c)\n",
		   (int) ch, ch));
d1035 1
a1035 2

	string++;
d1038 2
a1039 55
    /* update the screen */
    if (screen->scroll_amt)
	FlushScroll(xw);

    if (xw->keyboard.flags & MODE_DECSDM) {
	int new_row = (graphic->charrow
		       + ((graphic->actual_height * graphic->pixh)
			  / FontHeight(screen)));
	int new_col = (graphic->charcol
		       + (((graphic->actual_width * graphic->pixw)
			   + FontWidth(screen) - 1)
			  / FontWidth(screen)));

	TRACE(("setting text position after %dx%d graphic starting on row=%d col=%d: cursor new_row=%d new_col=%d\n",
	       graphic->actual_width * graphic->pixw,
	       graphic->actual_height * graphic->pixh,
	       graphic->charrow,
	       graphic->charcol,
	       new_row, new_col));

	if (new_col > screen->rgt_marg) {
	    new_col = screen->lft_marg;
	    new_row++;
	    TRACE(("column past left margin, overriding to row=%d col=%d\n",
		   new_row, new_col));
	}

	while (new_row > screen->bot_marg) {
	    xtermScroll(xw, 1);
	    new_row--;
	    TRACE(("bottom row was past screen.  new start row=%d, cursor row=%d\n",
		   graphic->charrow, new_row));
	}

	if (new_row < 0) {
	    TRACE(("new row is going to be negative (%d)!", new_row));	/* FIXME: this was triggering, now it isn't */
	}
	set_cur_row(screen, new_row);
	set_cur_col(screen, new_col <= screen->rgt_marg ? new_col : screen->rgt_marg);
    }

    refresh_modified_displayed_graphics(screen);

    TRACE(("DONE successfully parsed sixel data\n"));
    dump_sixel(graphic);
}

extern void
parse_regis(XtermWidget xw, ANSI *params, char const *string)
{
    (void) xw;
    (void) string;
    (void) params;

    TRACE(("ReGIS vector graphics mode, params=%d\n", params->a_nparam));
d1047 1
a1047 1
erase_sixel_graphic(SixelGraphic *graphic, int x, int y, int w, int h)
d1052 1
d1057 1
a1057 1
    TRACE(("erasing sixel bitmap %d,%d %dx%d\n", x, y, w, h));
d1059 1
d1061 10
a1070 8
	for (c = 0; c < graphic->actual_width; c++) {
	    if (r * ph + ph - 1 < y ||
		r * ph > y + h - 1 ||
		c * pw + pw - 1 < x ||
		c * pw > x + w - 1)
		continue;

	    graphic->pixels[r * graphic->max_width + c] = hole;
d1072 1
d1077 1
a1077 1
compare_sixel_ids(const void *left, const void *right)
d1079 2
a1080 2
    const SixelGraphic *l = *(const SixelGraphic *const *) left;
    const SixelGraphic *r = *(const SixelGraphic *const *) right;
d1090 1
a1090 1
extern void
d1097 4
a1100 3
    SixelGraphic *ordered_graphics[MAX_SIXEL_GRAPHICS];
    SixelGraphic *graphic;
    unsigned int ii;
d1104 10
a1113 2
    for (ii = 0U; ii < MAX_SIXEL_GRAPHICS; ii++) {
	ordered_graphics[ii] = &sixel_graphics[ii];
a1114 4
    qsort(ordered_graphics,
	  (size_t) MAX_SIXEL_GRAPHICS,
	  sizeof(ordered_graphics[0]),
	  compare_sixel_ids);
d1116 1
a1116 1
    for (ii = 0U; ii < MAX_SIXEL_GRAPHICS; ii++) {
d1118 1
a1118 1
	if (!graphic->valid || graphic->bufferid != screen->whichBuf)
d1147 1
a1147 1
	refresh_sixel_graphic(screen, graphic, xbase, ybase, x, y, w, h);
d1151 1
a1151 1
extern void
d1154 2
a1155 2
    SixelGraphic *graphic;
    unsigned int ii;
d1161 6
a1166 3
    for (ii = 0U; ii < MAX_SIXEL_GRAPHICS; ii++) {
	graphic = &sixel_graphics[ii];
	if (!graphic->valid || graphic->bufferid != screen->whichBuf || !graphic->dirty)
d1204 1
a1204 1
	refresh_sixel_graphic(screen, graphic, xbase, ybase, x, y, w, h);
d1209 1
a1209 1
extern void
d1212 2
a1213 2
    SixelGraphic *graphic;
    unsigned int ii;
d1216 4
a1219 3
    for (ii = 0U; ii < MAX_SIXEL_GRAPHICS; ii++) {
	graphic = &sixel_graphics[ii];
	if (!graphic->valid)
d1226 1
a1226 1
extern void
d1233 2
a1234 2
    SixelGraphic *graphic;
    unsigned int ii;
d1237 2
a1238 3
    for (ii = 0U; ii < MAX_SIXEL_GRAPHICS; ii++) {
	graphic = &sixel_graphics[ii];
	if (!graphic->valid)
d1249 1
a1249 1
	erase_sixel_graphic(graphic, x, y, w, h);
d1253 1
a1253 1
extern void
d1275 1
a1275 1
extern void
d1278 15
a1292 2
    SixelGraphic *graphic;
    unsigned int ii;
d1294 2
a1295 5
    init_color_registers(shared_color_registers, screen->terminal_id);
    TRACE(("resetting all sixel graphics\n"));
    for (ii = 0U; ii < MAX_SIXEL_GRAPHICS; ii++) {
	graphic = &sixel_graphics[ii];
	graphic->valid = 0;
d1298 1
@


1.1
log
@Update to xterm 296. Sixel graphics disabled for now.
@
text
@d1 1
a1 1
/* $XTermId: graphics.c,v 1.12 2013/07/10 22:35:28 Ross.Combs Exp $ */
d253 4
a256 4
			 RegisterNum color,
			 short r,
			 short g,
			 short b)
d259 3
a261 3
    reg->r = r;
    reg->g = g;
    reg->b = b;
d273 1
a273 1
	    set_sixel_color_register(color_registers, (RegisterNum) i, 0, 0, 0);
d553 1
a553 1
set_shared_color_register(RegisterNum color, short r, short g, short b)
d558 1
a558 1
    assert(color < MAX_COLOR_REGISTERS);
d1115 1
a1115 1
					     (RegisterNum) Pregister,
d1118 1
a1118 1
		    set_shared_color_register((RegisterNum) Pregister, r, g, b);
d1303 1
a1303 1
	  MAX_SIXEL_GRAPHICS,
d1317 1
a1317 1
	xbase = (screen->border
d1319 1
a1319 1
	ybase = (screen->border
d1322 6
a1327 6
	if (xbase + x + w + screen->border > FullWidth(screen))
	    w = FullWidth(screen) - (xbase + x + screen->border);
	if (ybase + y + h + screen->border > FullHeight(screen))
	    h = FullHeight(screen) - (ybase + y + screen->border);
	else if (ybase + y < screen->border) {
	    int diff = screen->border - (ybase + y);
d1371 1
a1371 1
	xbase = (screen->border
d1373 1
a1373 1
	ybase = (screen->border
d1376 6
a1381 6
	if (xbase + x + w + screen->border > FullWidth(screen))
	    w = FullWidth(screen) - (xbase + x + screen->border);
	if (ybase + y + h + screen->border > FullHeight(screen))
	    h = FullHeight(screen) - (ybase + y + screen->border);
	else if (ybase + y < screen->border) {
	    int diff = screen->border - (ybase + y);
@

