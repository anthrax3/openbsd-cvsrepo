head	1.39;
access;
symbols
	OPENBSD_6_1:1.38.0.2
	OPENBSD_6_1_BASE:1.38
	OPENBSD_6_0:1.36.0.4
	OPENBSD_6_0_BASE:1.36
	OPENBSD_5_9:1.36.0.2
	OPENBSD_5_9_BASE:1.36
	OPENBSD_5_8:1.34.0.4
	OPENBSD_5_8_BASE:1.34
	OPENBSD_5_7:1.34.0.2
	OPENBSD_5_7_BASE:1.34
	OPENBSD_5_6:1.31.0.2
	OPENBSD_5_6_BASE:1.31
	OPENBSD_5_5:1.29.0.2
	OPENBSD_5_5_BASE:1.29
	OPENBSD_5_4:1.27.0.2
	OPENBSD_5_4_BASE:1.27
	OPENBSD_5_3:1.25.0.2
	OPENBSD_5_3_BASE:1.25
	OPENBSD_5_2:1.24.0.2
	OPENBSD_5_2_BASE:1.24
	OPENBSD_5_1_BASE:1.22
	OPENBSD_5_1:1.22.0.2
	OPENBSD_5_0:1.19.0.2
	OPENBSD_5_0_BASE:1.19
	OPENBSD_4_9:1.17.0.2
	OPENBSD_4_9_BASE:1.17
	OPENBSD_4_8:1.13.0.4
	OPENBSD_4_8_BASE:1.13
	OPENBSD_4_7:1.11.0.2
	OPENBSD_4_7_BASE:1.11
	OPENBSD_4_6:1.8.0.2
	OPENBSD_4_6_BASE:1.8
	OPENBSD_4_5:1.6.0.2
	OPENBSD_4_5_BASE:1.6
	OPENBSD_4_4:1.2.0.2
	OPENBSD_4_4_BASE:1.2
	OPENBSD_4_3_BASE:1.1.1.4
	OPENBSD_4_3:1.1.1.4.0.2
	v232:1.1.1.4
	v229:1.1.1.3
	OPENBSD_4_2:1.1.1.2.0.2
	OPENBSD_4_2_BASE:1.1.1.2
	v225:1.1.1.2
	v216:1.1.1.1
	xterm:1.1.1;
locks; strict;
comment	@ * @;


1.39
date	2017.07.15.19.20.51;	author matthieu;	state Exp;
branches;
next	1.38;
commitid	b9xPQ49d1NNt4zlu;

1.38
date	2016.11.03.14.25.06;	author matthieu;	state Exp;
branches;
next	1.37;
commitid	f4xcYrkdKFtVElPL;

1.37
date	2016.08.07.21.27.36;	author matthieu;	state Exp;
branches;
next	1.36;
commitid	psxxjI5z4Vpv2LL4;

1.36
date	2016.01.13.20.40.08;	author matthieu;	state Exp;
branches;
next	1.35;
commitid	by9Wu4LDAgU65dBU;

1.35
date	2015.09.05.14.11.45;	author matthieu;	state Exp;
branches;
next	1.34;
commitid	YVUODLQ4QcYTuGkb;

1.34
date	2015.01.18.20.24.39;	author matthieu;	state Exp;
branches;
next	1.33;
commitid	PDdlFuihcMifzxwp;

1.33
date	2014.12.18.20.16.55;	author matthieu;	state Exp;
branches;
next	1.32;
commitid	pCMhkpVdt9Oe52hU;

1.32
date	2014.10.05.16.39.19;	author matthieu;	state Exp;
branches;
next	1.31;
commitid	0wVJ6bWh03LWbUdn;

1.31
date	2014.07.14.08.30.11;	author matthieu;	state Exp;
branches;
next	1.30;
commitid	EnwNNUjlkdrocnMa;

1.30
date	2014.05.09.19.56.40;	author matthieu;	state Exp;
branches;
next	1.29;

1.29
date	2014.01.02.15.14.50;	author matthieu;	state Exp;
branches;
next	1.28;

1.28
date	2013.08.26.20.06.11;	author matthieu;	state Exp;
branches;
next	1.27;

1.27
date	2013.06.02.19.55.50;	author matthieu;	state Exp;
branches;
next	1.26;

1.26
date	2013.03.09.14.45.38;	author matthieu;	state Exp;
branches;
next	1.25;

1.25
date	2013.01.04.16.40.18;	author matthieu;	state Exp;
branches;
next	1.24;

1.24
date	2012.06.07.20.20.23;	author matthieu;	state Exp;
branches;
next	1.23;

1.23
date	2012.04.14.09.02.46;	author matthieu;	state Exp;
branches;
next	1.22;

1.22
date	2011.09.17.11.51.57;	author matthieu;	state Exp;
branches;
next	1.21;

1.21
date	2011.08.28.17.40.55;	author matthieu;	state Exp;
branches;
next	1.20;

1.20
date	2011.08.18.19.47.42;	author matthieu;	state Exp;
branches;
next	1.19;

1.19
date	2011.06.07.19.21.06;	author matthieu;	state Exp;
branches;
next	1.18;

1.18
date	2011.03.07.20.41.27;	author matthieu;	state Exp;
branches;
next	1.17;

1.17
date	2010.11.29.20.10.09;	author matthieu;	state Exp;
branches;
next	1.16;

1.16
date	2010.10.23.19.14.52;	author matthieu;	state Exp;
branches;
next	1.15;

1.15
date	2010.10.05.19.37.23;	author matthieu;	state Exp;
branches;
next	1.14;

1.14
date	2010.08.22.13.38.11;	author matthieu;	state Exp;
branches;
next	1.13;

1.13
date	2010.05.08.12.20.46;	author matthieu;	state Exp;
branches;
next	1.12;

1.12
date	2010.03.25.22.03.51;	author matthieu;	state Exp;
branches;
next	1.11;

1.11
date	2009.10.31.14.11.57;	author matthieu;	state Exp;
branches;
next	1.10;

1.10
date	2009.09.19.00.03.36;	author sthen;	state Exp;
branches;
next	1.9;

1.9
date	2009.09.05.15.58.09;	author matthieu;	state Exp;
branches;
next	1.8;

1.8
date	2009.04.04.15.10.44;	author matthieu;	state Exp;
branches;
next	1.7;

1.7
date	2009.03.09.22.13.04;	author matthieu;	state Exp;
branches;
next	1.6;

1.6
date	2009.01.06.20.31.59;	author matthieu;	state Exp;
branches;
next	1.5;

1.5
date	2009.01.06.20.10.20;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2008.09.23.19.08.55;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2008.08.25.18.05.57;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2008.03.19.21.15.46;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.26.11.11.23;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.11.26.11.11.23;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2007.06.15.19.30.08;	author matthieu;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2007.08.25.18.53.41;	author matthieu;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2008.02.16.09.34.49;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.39
log
@Update to xterm 330
@
text
@/* $XTermId: charproc.c,v 1.1492 2017/06/19 08:34:54 tom Exp $ */

/*
 * Copyright 1999-2016,2017 by Thomas E. Dickey
 *
 *                         All Rights Reserved
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 *
 * The above copyright notice and this permission notice shall be included
 * in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
 * IN NO EVENT SHALL THE ABOVE LISTED COPYRIGHT HOLDER(S) BE LIABLE FOR ANY
 * CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
 * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
 * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 *
 * Except as contained in this notice, the name(s) of the above copyright
 * holders shall not be used in advertising or otherwise to promote the
 * sale, use or other dealings in this Software without prior written
 * authorization.
 *
 *
 * Copyright 1988  The Open Group
 *
 * Permission to use, copy, modify, distribute, and sell this software and its
 * documentation for any purpose is hereby granted without fee, provided that
 * the above copyright notice appear in all copies and that both that
 * copyright notice and this permission notice appear in supporting
 * documentation.
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
 * OPEN GROUP BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
 * AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 *
 * Except as contained in this notice, the name of The Open Group shall not be
 * used in advertising or otherwise to promote the sale, use or other dealings
 * in this Software without prior written authorization from The Open Group.
 *
 */
/*
 * Copyright 1987 by Digital Equipment Corporation, Maynard, Massachusetts.
 *
 *                         All Rights Reserved
 *
 * Permission to use, copy, modify, and distribute this software and its
 * documentation for any purpose and without fee is hereby granted,
 * provided that the above copyright notice appear in all copies and that
 * both that copyright notice and this permission notice appear in
 * supporting documentation, and that the name of Digital Equipment
 * Corporation not be used in advertising or publicity pertaining to
 * distribution of the software without specific, written prior permission.
 *
 *
 * DIGITAL DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING
 * ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL
 * DIGITAL BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR
 * ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
 * WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
 * ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
 * SOFTWARE.
 */

/* charproc.c */

#include <version.h>
#include <xterm.h>

#include <X11/Xatom.h>
#include <X11/Xutil.h>
#include <X11/cursorfont.h>
#include <X11/Xmu/Atoms.h>
#include <X11/Xmu/CharSet.h>
#include <X11/Xmu/Converters.h>

#if OPT_INPUT_METHOD

#if defined(HAVE_LIB_XAW)
#include <X11/Xaw/XawImP.h>
#elif defined(HAVE_LIB_XAW3D)
#include <X11/Xaw3d/XawImP.h>
#elif defined(HAVE_LIB_XAW3DXFT)
#include <X11/Xaw3dxft/XawImP.h>
#elif defined(HAVE_LIB_NEXTAW)
#include <X11/neXtaw/XawImP.h>
#elif defined(HAVE_LIB_XAWPLUS)
#include <X11/XawPlus/XawImP.h>
#endif

#endif

#if OPT_DOUBLE_BUFFER
#include <X11/extensions/Xdbe.h>
#endif

#if OPT_WIDE_CHARS
#include <xutf8.h>
#include <wcwidth.h>
#include <precompose.h>
#ifdef HAVE_LANGINFO_CODESET
#include <langinfo.h>
#endif
#endif

#if OPT_INPUT_METHOD
#include <X11/Xlocale.h>
#endif

#include <stdio.h>
#include <ctype.h>
#include <assert.h>

#if defined(HAVE_SCHED_YIELD)
#include <sched.h>
#endif

#include <VTparse.h>
#include <data.h>
#include <error.h>
#include <menu.h>
#include <main.h>
#include <fontutils.h>
#include <charclass.h>
#include <xstrings.h>
#include <graphics.h>

typedef int (*BitFunc) (unsigned * /* p */ ,
			unsigned /* mask */ );

static IChar doinput(void);
static int set_character_class(char * /*s */ );
static void FromAlternate(XtermWidget /* xw */ );
static void ReallyReset(XtermWidget /* xw */ ,
			Bool /* full */ ,
			Bool /* saved */ );
static void RequestResize(XtermWidget /* xw */ ,
			  int /* rows */ ,
			  int /* cols */ ,
			  Bool /* text */ );
static void SwitchBufs(XtermWidget /* xw */ ,
		       int /* toBuf */ ,
		       Bool /* clearFirst */ );
static void ToAlternate(XtermWidget /* xw */ ,
			Bool /* clearFirst */ );
static void ansi_modes(XtermWidget termw,
		       BitFunc /* func */ );
static int bitclr(unsigned *p, unsigned mask);
static int bitcpy(unsigned *p, unsigned q, unsigned mask);
static int bitset(unsigned *p, unsigned mask);
static void dpmodes(XtermWidget /* xw */ ,
		    BitFunc /* func */ );
static void restoremodes(XtermWidget /* xw */ );
static void savemodes(XtermWidget /* xw */ );
static void window_ops(XtermWidget /* xw */ );

#define DoStartBlinking(s) ((s)->cursor_blink ^ (s)->cursor_blink_esc)

#if OPT_BLINK_CURS || OPT_BLINK_TEXT
#define UpdateCursorBlink(screen) SetCursorBlink(screen, screen->cursor_blink)
static void SetCursorBlink(TScreen * /* screen */ ,
			   Bool /* enable */ );
static void HandleBlinking(XtPointer /* closure */ ,
			   XtIntervalId * /* id */ );
static void StartBlinking(TScreen * /* screen */ );
static void StopBlinking(TScreen * /* screen */ );
#else
#define StartBlinking(screen)	/* nothing */
#define StopBlinking(screen)	/* nothing */
#endif

#if OPT_I18N_SUPPORT && OPT_INPUT_METHOD
static void PreeditPosition(XtermWidget /* xw */ );
#endif

#define	DEFAULT		-1
#define BELLSUPPRESSMSEC 200

static ANSI reply;
static PARAMS parms;

#define nparam parms.count

#define InitParams()  parms.count = parms.is_sub[0] = parms.has_subparams = 0
#define GetParam(n)   parms.params[(n)]
#define SetParam(n,v) parms.params[(n)] = v
#define ParamPair(n)  nparam - (n), parms.params + (n)
#define ParamsDone()  InitParams()

static jmp_buf vtjmpbuf;

/* event handlers */
static void HandleBell PROTO_XT_ACTIONS_ARGS;
static void HandleIgnore PROTO_XT_ACTIONS_ARGS;
static void HandleKeymapChange PROTO_XT_ACTIONS_ARGS;
static void HandleVisualBell PROTO_XT_ACTIONS_ARGS;
#if HANDLE_STRUCT_NOTIFY
static void HandleStructNotify PROTO_XT_EV_HANDLER_ARGS;
#endif

/*
 * NOTE: VTInitialize zeros out the entire ".screen" component of the
 * XtermWidget, so make sure to add an assignment statement in VTInitialize()
 * for each new ".screen" field added to this resource list.
 */

/* Defaults */
#if OPT_ISO_COLORS

/*
 * If we default to colorMode enabled, compile-in defaults for the ANSI colors.
 */
#if DFT_COLORMODE
#define DFT_COLOR(name) name
#else
#define DFT_COLOR(name) XtDefaultForeground
#endif
#endif

static char _Font_Selected_[] = "yes";	/* string is arbitrary */

static const char *defaultTranslations;
/* *INDENT-OFF* */
static XtActionsRec actionsList[] = {
    { "allow-bold-fonts",	HandleAllowBoldFonts },
    { "allow-send-events",	HandleAllowSends },
    { "bell",			HandleBell },
    { "clear-saved-lines",	HandleClearSavedLines },
    { "copy-selection",		HandleCopySelection },
    { "create-menu",		HandleCreateMenu },
    { "delete-is-del",		HandleDeleteIsDEL },
    { "dired-button",		DiredButton },
    { "hard-reset",		HandleHardReset },
    { "ignore",			HandleIgnore },
    { "insert",			HandleKeyPressed },  /* alias for insert-seven-bit */
    { "insert-eight-bit",	HandleEightBitKeyPressed },
    { "insert-selection",	HandleInsertSelection },
    { "insert-seven-bit",	HandleKeyPressed },
    { "interpret",		HandleInterpret },
    { "keymap",			HandleKeymapChange },
    { "popup-menu",		HandlePopupMenu },
    { "print",			HandlePrintScreen },
    { "print-everything",	HandlePrintEverything },
    { "print-redir",		HandlePrintControlMode },
    { "quit",			HandleQuit },
    { "redraw",			HandleRedraw },
    { "scroll-back",		HandleScrollBack },
    { "scroll-forw",		HandleScrollForward },
    { "secure",			HandleSecure },
    { "select-cursor-end",	HandleKeyboardSelectEnd },
    { "select-cursor-extend",   HandleKeyboardSelectExtend },
    { "select-cursor-start",	HandleKeyboardSelectStart },
    { "select-end",		HandleSelectEnd },
    { "select-extend",		HandleSelectExtend },
    { "select-set",		HandleSelectSet },
    { "select-start",		HandleSelectStart },
    { "send-signal",		HandleSendSignal },
    { "set-8-bit-control",	Handle8BitControl },
    { "set-allow132",		HandleAllow132 },
    { "set-altscreen",		HandleAltScreen },
    { "set-appcursor",		HandleAppCursor },
    { "set-appkeypad",		HandleAppKeypad },
    { "set-autolinefeed",	HandleAutoLineFeed },
    { "set-autowrap",		HandleAutoWrap },
    { "set-backarrow",		HandleBackarrow },
    { "set-bellIsUrgent",	HandleBellIsUrgent },
    { "set-cursesemul",		HandleCursesEmul },
    { "set-jumpscroll",		HandleJumpscroll },
    { "set-keep-clipboard",	HandleKeepClipboard },
    { "set-keep-selection",	HandleKeepSelection },
    { "set-marginbell",		HandleMarginBell },
    { "set-old-function-keys",	HandleOldFunctionKeys },
    { "set-pop-on-bell",	HandleSetPopOnBell },
    { "set-reverse-video",	HandleReverseVideo },
    { "set-reversewrap",	HandleReverseWrap },
    { "set-scroll-on-key",	HandleScrollKey },
    { "set-scroll-on-tty-output", HandleScrollTtyOutput },
    { "set-scrollbar",		HandleScrollbar },
    { "set-select",		HandleSetSelect },
    { "set-sun-keyboard",	HandleSunKeyboard },
    { "set-titeInhibit",	HandleTiteInhibit },
    { "set-visual-bell",	HandleSetVisualBell },
    { "set-vt-font",		HandleSetFont },
    { "soft-reset",		HandleSoftReset },
    { "start-cursor-extend",	HandleKeyboardStartExtend },
    { "start-extend",		HandleStartExtend },
    { "string",			HandleStringEvent },
    { "vi-button",		ViButton },
    { "visual-bell",		HandleVisualBell },
#ifdef ALLOWLOGGING
    { "set-logging",		HandleLogging },
#endif
#if OPT_ALLOW_XXX_OPS
    { "allow-color-ops",	HandleAllowColorOps },
    { "allow-font-ops",		HandleAllowFontOps },
    { "allow-mouse-ops",	HandleAllowMouseOps },
    { "allow-tcap-ops",		HandleAllowTcapOps },
    { "allow-title-ops",	HandleAllowTitleOps },
    { "allow-window-ops",	HandleAllowWindowOps },
#endif
#if OPT_BLINK_CURS
    { "set-cursorblink",	HandleCursorBlink },
#endif
#if OPT_BOX_CHARS
    { "set-font-linedrawing",	HandleFontBoxChars },
    { "set-font-packed",	HandleFontPacked },
#endif
#if OPT_DABBREV
    { "dabbrev-expand",		HandleDabbrevExpand },
#endif
#if OPT_DEC_CHRSET
    { "set-font-doublesize",	HandleFontDoublesize },
#endif
#if OPT_DEC_SOFTFONT
    { "set-font-loading",	HandleFontLoading },
#endif
#if OPT_SCREEN_DUMPS
    { "dump-html",	        HandleDumpHtml },
    { "dump-svg",	        HandleDumpSvg },
#endif
#if OPT_EXEC_XTERM
    { "spawn-new-terminal",	HandleSpawnTerminal },
#endif
#if OPT_HP_FUNC_KEYS
    { "set-hp-function-keys",	HandleHpFunctionKeys },
#endif
#if OPT_LOAD_VTFONTS
    { "load-vt-fonts",		HandleLoadVTFonts },
#endif
#if OPT_MAXIMIZE
    { "deiconify",		HandleDeIconify },
    { "fullscreen",		HandleFullscreen },
    { "iconify",		HandleIconify },
    { "maximize",		HandleMaximize },
    { "restore",		HandleRestoreSize },
#endif
#if OPT_NUM_LOCK
    { "alt-sends-escape",	HandleAltEsc },
    { "meta-sends-escape",	HandleMetaEsc },
    { "set-num-lock",		HandleNumLock },
#endif
#if OPT_READLINE
    { "readline-button",	ReadLineButton },
#endif
#if OPT_RENDERFONT
    { "set-render-font",	HandleRenderFont },
#endif
#if OPT_SCO_FUNC_KEYS
    { "set-sco-function-keys",	HandleScoFunctionKeys },
#endif
#if OPT_SCROLL_LOCK
    { "scroll-lock",		HandleScrollLock },
#endif
#if OPT_SELECTION_OPS
    { "exec-formatted",		HandleExecFormatted },
    { "exec-selectable",	HandleExecSelectable },
    { "insert-formatted",	HandleInsertFormatted },
    { "insert-selectable",	HandleInsertSelectable },
#endif
#if OPT_SHIFT_FONTS
    { "larger-vt-font",		HandleLargerFont },
    { "smaller-vt-font",	HandleSmallerFont },
#endif
#if OPT_SIXEL_GRAPHICS
    { "set-sixel-scrolling",	HandleSixelScrolling },
#endif
#if OPT_GRAPHICS
    { "set-private-colors",	HandleSetPrivateColorRegisters },
#endif
#if OPT_SUN_FUNC_KEYS
    { "set-sun-function-keys",	HandleSunFunctionKeys },
#endif
#if OPT_TEK4014
    { "set-terminal-type",	HandleSetTerminalType },
    { "set-visibility",		HandleVisibility },
    { "set-tek-text",		HandleSetTekText },
    { "tek-page",		HandleTekPage },
    { "tek-reset",		HandleTekReset },
    { "tek-copy",		HandleTekCopy },
#endif
#if OPT_TOOLBAR
    { "set-toolbar",		HandleToolbar },
#endif
#if OPT_WIDE_CHARS
    { "set-utf8-mode",		HandleUTF8Mode },
    { "set-utf8-fonts",		HandleUTF8Fonts },
    { "set-utf8-title",		HandleUTF8Title },
#endif
};
/* *INDENT-ON* */

#define SPS screen.printer_state

static XtResource xterm_resources[] =
{
    Bres(XtNallowPasteControls, XtCAllowPasteControls,
	 screen.allowPasteControl0, False),
    Bres(XtNallowSendEvents, XtCAllowSendEvents, screen.allowSendEvent0, False),
    Bres(XtNallowColorOps, XtCAllowColorOps, screen.allowColorOp0, DEF_ALLOW_COLOR),
    Bres(XtNallowFontOps, XtCAllowFontOps, screen.allowFontOp0, DEF_ALLOW_FONT),
    Bres(XtNallowMouseOps, XtCAllowMouseOps, screen.allowMouseOp0, DEF_ALLOW_MOUSE),
    Bres(XtNallowTcapOps, XtCAllowTcapOps, screen.allowTcapOp0, DEF_ALLOW_TCAP),
    Bres(XtNallowTitleOps, XtCAllowTitleOps, screen.allowTitleOp0, DEF_ALLOW_TITLE),
    Bres(XtNallowWindowOps, XtCAllowWindowOps, screen.allowWindowOp0, DEF_ALLOW_WINDOW),
    Bres(XtNaltIsNotMeta, XtCAltIsNotMeta, screen.alt_is_not_meta, False),
    Bres(XtNaltSendsEscape, XtCAltSendsEscape, screen.alt_sends_esc, DEF_ALT_SENDS_ESC),
    Bres(XtNallowBoldFonts, XtCAllowBoldFonts, screen.allowBoldFonts, True),
    Bres(XtNalwaysBoldMode, XtCAlwaysBoldMode, screen.always_bold_mode, False),
    Bres(XtNalwaysHighlight, XtCAlwaysHighlight, screen.always_highlight, False),
    Bres(XtNappcursorDefault, XtCAppcursorDefault, misc.appcursorDefault, False),
    Bres(XtNappkeypadDefault, XtCAppkeypadDefault, misc.appkeypadDefault, False),
    Bres(XtNalternateScroll, XtCScrollCond, screen.alternateScroll, False),
    Bres(XtNautoWrap, XtCAutoWrap, misc.autoWrap, True),
    Bres(XtNawaitInput, XtCAwaitInput, screen.awaitInput, False),
    Bres(XtNfreeBoldBox, XtCFreeBoldBox, screen.free_bold_box, False),
    Bres(XtNbackarrowKey, XtCBackarrowKey, screen.backarrow_key, DEF_BACKARO_BS),
    Bres(XtNbellIsUrgent, XtCBellIsUrgent, screen.bellIsUrgent, False),
    Bres(XtNbellOnReset, XtCBellOnReset, screen.bellOnReset, True),
    Bres(XtNboldMode, XtCBoldMode, screen.bold_mode, True),
    Bres(XtNbrokenSelections, XtCBrokenSelections, screen.brokenSelections, False),
    Bres(XtNc132, XtCC132, screen.c132, False),
    Bres(XtNcdXtraScroll, XtCCdXtraScroll, misc.cdXtraScroll, False),
    Bres(XtNcurses, XtCCurses, screen.curses, False),
    Bres(XtNcutNewline, XtCCutNewline, screen.cutNewline, True),
    Bres(XtNcutToBeginningOfLine, XtCCutToBeginningOfLine,
	 screen.cutToBeginningOfLine, True),
    Bres(XtNdeleteIsDEL, XtCDeleteIsDEL, screen.delete_is_del, DEFDELETE_DEL),
    Bres(XtNdynamicColors, XtCDynamicColors, misc.dynamicColors, True),
    Bres(XtNeightBitControl, XtCEightBitControl, screen.control_eight_bits, False),
    Bres(XtNeightBitInput, XtCEightBitInput, screen.input_eight_bits, True),
    Bres(XtNeightBitOutput, XtCEightBitOutput, screen.output_eight_bits, True),
    Bres(XtNeraseSavedLines, XtCEraseSavedLines, screen.eraseSavedLines0, True),
    Bres(XtNhighlightSelection, XtCHighlightSelection,
	 screen.highlight_selection, False),
    Bres(XtNshowWrapMarks, XtCShowWrapMarks, screen.show_wrap_marks, False),
    Bres(XtNhpLowerleftBugCompat, XtCHpLowerleftBugCompat, screen.hp_ll_bc, False),
    Bres(XtNi18nSelections, XtCI18nSelections, screen.i18nSelections, True),
    Bres(XtNfastScroll, XtCFastScroll, screen.fastscroll, False),
    Bres(XtNjumpScroll, XtCJumpScroll, screen.jumpscroll, True),
    Bres(XtNkeepClipboard, XtCKeepClipboard, screen.keepClipboard, False),
    Bres(XtNkeepSelection, XtCKeepSelection, screen.keepSelection, True),
    Bres(XtNloginShell, XtCLoginShell, misc.login_shell, False),
    Bres(XtNmarginBell, XtCMarginBell, screen.marginbell, False),
    Bres(XtNmetaSendsEscape, XtCMetaSendsEscape, screen.meta_sends_esc, DEF_META_SENDS_ESC),
    Bres(XtNmultiScroll, XtCMultiScroll, screen.multiscroll, False),
    Bres(XtNoldXtermFKeys, XtCOldXtermFKeys, screen.old_fkeys, False),
    Bres(XtNpopOnBell, XtCPopOnBell, screen.poponbell, False),
    Bres(XtNprinterAutoClose, XtCPrinterAutoClose, SPS.printer_autoclose, False),
    Bres(XtNprinterExtent, XtCPrinterExtent, SPS.printer_extent, False),
    Bres(XtNprinterFormFeed, XtCPrinterFormFeed, SPS.printer_formfeed, False),
    Bres(XtNprinterNewLine, XtCPrinterNewLine, SPS.printer_newline, True),
    Bres(XtNquietGrab, XtCQuietGrab, screen.quiet_grab, False),
    Bres(XtNreverseVideo, XtCReverseVideo, misc.re_verse, False),
    Bres(XtNreverseWrap, XtCReverseWrap, misc.reverseWrap, False),
    Bres(XtNscrollBar, XtCScrollBar, misc.scrollbar, False),
    Bres(XtNscrollKey, XtCScrollCond, screen.scrollkey, False),
    Bres(XtNscrollTtyOutput, XtCScrollCond, screen.scrollttyoutput, True),
    Bres(XtNselectToClipboard, XtCSelectToClipboard,
	 screen.selectToClipboard, False),
    Bres(XtNsignalInhibit, XtCSignalInhibit, misc.signalInhibit, False),
    Bres(XtNtiteInhibit, XtCTiteInhibit, misc.titeInhibit, False),
    Bres(XtNtiXtraScroll, XtCTiXtraScroll, misc.tiXtraScroll, False),
    Bres(XtNtrimSelection, XtCTrimSelection, screen.trim_selection, False),
    Bres(XtNunderLine, XtCUnderLine, screen.underline, True),
    Bres(XtNvisualBell, XtCVisualBell, screen.visualbell, False),
    Bres(XtNvisualBellLine, XtCVisualBellLine, screen.flash_line, False),

    Dres(XtNscaleHeight, XtCScaleHeight, screen.scale_height, "1.0"),

    Ires(XtNbellSuppressTime, XtCBellSuppressTime, screen.bellSuppressTime, BELLSUPPRESSMSEC),
    Ires(XtNfontWarnings, XtCFontWarnings, misc.fontWarnings, fwResource),
    Ires(XtNinternalBorder, XtCBorderWidth, screen.border, DEFBORDER),
    Ires(XtNlimitResize, XtCLimitResize, misc.limit_resize, 1),
    Ires(XtNmultiClickTime, XtCMultiClickTime, screen.multiClickTime, MULTICLICKTIME),
    Ires(XtNnMarginBell, XtCColumn, screen.nmarginbell, N_MARGINBELL),
    Ires(XtNpointerMode, XtCPointerMode, screen.pointer_mode, DEF_POINTER_MODE),
    Ires(XtNprinterControlMode, XtCPrinterControlMode,
	 SPS.printer_controlmode, 0),
    Ires(XtNtitleModes, XtCTitleModes, screen.title_modes, DEF_TITLE_MODES),
    Ires(XtNvisualBellDelay, XtCVisualBellDelay, screen.visualBellDelay, 100),
    Ires(XtNsaveLines, XtCSaveLines, screen.savelines, SAVELINES),
    Ires(XtNscrollBarBorder, XtCScrollBarBorder, screen.scrollBarBorder, 1),
    Ires(XtNscrollLines, XtCScrollLines, screen.scrolllines, SCROLLLINES),

    Sres(XtNinitialFont, XtCInitialFont, screen.initial_font, NULL),
    Sres(XtNfont1, XtCFont1, screen.MenuFontName(fontMenu_font1), NULL),
    Sres(XtNfont2, XtCFont2, screen.MenuFontName(fontMenu_font2), NULL),
    Sres(XtNfont3, XtCFont3, screen.MenuFontName(fontMenu_font3), NULL),
    Sres(XtNfont4, XtCFont4, screen.MenuFontName(fontMenu_font4), NULL),
    Sres(XtNfont5, XtCFont5, screen.MenuFontName(fontMenu_font5), NULL),
    Sres(XtNfont6, XtCFont6, screen.MenuFontName(fontMenu_font6), NULL),

    Sres(XtNanswerbackString, XtCAnswerbackString, screen.answer_back, ""),
    Sres(XtNboldFont, XtCBoldFont, misc.default_font.f_b, DEFBOLDFONT),
    Sres(XtNcharClass, XtCCharClass, screen.charClass, NULL),
    Sres(XtNdecTerminalID, XtCDecTerminalID, screen.term_id, DFT_DECID),
    Sres(XtNdefaultString, XtCDefaultString, screen.default_string, "#"),
    Sres(XtNdisallowedColorOps, XtCDisallowedColorOps,
	 screen.disallowedColorOps, DEF_DISALLOWED_COLOR),
    Sres(XtNdisallowedFontOps, XtCDisallowedFontOps,
	 screen.disallowedFontOps, DEF_DISALLOWED_FONT),
    Sres(XtNdisallowedMouseOps, XtCDisallowedMouseOps,
	 screen.disallowedMouseOps, DEF_DISALLOWED_MOUSE),
    Sres(XtNdisallowedTcapOps, XtCDisallowedTcapOps,
	 screen.disallowedTcapOps, DEF_DISALLOWED_TCAP),
    Sres(XtNdisallowedWindowOps, XtCDisallowedWindowOps,
	 screen.disallowedWinOps, DEF_DISALLOWED_WINDOW),
    Sres(XtNeightBitMeta, XtCEightBitMeta, screen.eight_bit_meta_s, DEF_8BIT_META),
    Sres(XtNeightBitSelectTypes, XtCEightBitSelectTypes,
	 screen.eightbit_select_types, NULL),
    Sres(XtNfont, XtCFont, misc.default_font.f_n, DEFFONT),
    Sres(XtNgeometry, XtCGeometry, misc.geo_metry, NULL),
    Sres(XtNkeyboardDialect, XtCKeyboardDialect, screen.keyboard_dialect, DFT_KBD_DIALECT),
    Sres(XtNprinterCommand, XtCPrinterCommand, SPS.printer_command, ""),
    Sres(XtNtekGeometry, XtCGeometry, misc.T_geometry, NULL),

    Tres(XtNcursorColor, XtCCursorColor, TEXT_CURSOR, XtDefaultForeground),
    Tres(XtNforeground, XtCForeground, TEXT_FG, XtDefaultForeground),
    Tres(XtNpointerColor, XtCPointerColor, MOUSE_FG, XtDefaultForeground),
    Tres(XtNbackground, XtCBackground, TEXT_BG, XtDefaultBackground),
    Tres(XtNpointerColorBackground, XtCBackground, MOUSE_BG, XtDefaultBackground),

    {XtNresizeGravity, XtCResizeGravity, XtRGravity, sizeof(XtGravity),
     XtOffsetOf(XtermWidgetRec, misc.resizeGravity),
     XtRImmediate, (XtPointer) SouthWestGravity},

    {XtNpointerShape, XtCCursor, XtRCursor, sizeof(Cursor),
     XtOffsetOf(XtermWidgetRec, screen.pointer_cursor),
     XtRString, (XtPointer) "xterm"},

#ifdef ALLOWLOGGING
    Bres(XtNlogInhibit, XtCLogInhibit, misc.logInhibit, False),
    Bres(XtNlogging, XtCLogging, misc.log_on, False),
    Sres(XtNlogFile, XtCLogfile, screen.logfile, NULL),
#endif

#ifndef NO_ACTIVE_ICON
    Sres("activeIcon", "ActiveIcon", misc.active_icon_s, "default"),
    Ires("iconBorderWidth", XtCBorderWidth, misc.icon_border_width, 2),
    Sres("iconFont", "IconFont", screen.icon_fontname, "nil2"),
    Cres("iconBorderColor", XtCBorderColor, misc.icon_border_pixel, XtDefaultBackground),
#endif				/* NO_ACTIVE_ICON */

#if OPT_BLINK_CURS
    Bres(XtNcursorBlink, XtCCursorBlink, screen.cursor_blink, False),
#endif
    Bres(XtNcursorUnderLine, XtCCursorUnderLine, screen.cursor_underline, False),

#if OPT_BLINK_TEXT
    Bres(XtNshowBlinkAsBold, XtCCursorBlink, screen.blink_as_bold, DEFBLINKASBOLD),
#endif

#if OPT_BLINK_CURS || OPT_BLINK_TEXT
    Ires(XtNcursorOnTime, XtCCursorOnTime, screen.blink_on, 600),
    Ires(XtNcursorOffTime, XtCCursorOffTime, screen.blink_off, 300),
#endif

#if OPT_BOX_CHARS
    Bres(XtNforceBoxChars, XtCForceBoxChars, screen.force_box_chars, False),
    Bres(XtNforcePackedFont, XtCForcePackedFont, screen.force_packed, True),
    Bres(XtNshowMissingGlyphs, XtCShowMissingGlyphs, screen.force_all_chars, False),
    Bres(XtNassumeAllChars, XtCAssumeAllChars, screen.assume_all_chars, True),
#endif

#if OPT_BROKEN_OSC
    Bres(XtNbrokenLinuxOSC, XtCBrokenLinuxOSC, screen.brokenLinuxOSC, True),
#endif

#if OPT_BROKEN_ST
    Bres(XtNbrokenStringTerm, XtCBrokenStringTerm, screen.brokenStringTerm, False),
#endif

#if OPT_C1_PRINT
    Bres(XtNallowC1Printable, XtCAllowC1Printable, screen.c1_printable, False),
#endif

#if OPT_CLIP_BOLD
    Bres(XtNuseClipping, XtCUseClipping, screen.use_clipping, True),
#endif

#if OPT_DEC_CHRSET
    Bres(XtNfontDoublesize, XtCFontDoublesize, screen.font_doublesize, True),
    Ires(XtNcacheDoublesize, XtCCacheDoublesize, screen.cache_doublesize, NUM_CHRSET),
#endif

#if OPT_HIGHLIGHT_COLOR
    Tres(XtNhighlightColor, XtCHighlightColor, HIGHLIGHT_BG, XtDefaultForeground),
    Tres(XtNhighlightTextColor, XtCHighlightTextColor, HIGHLIGHT_FG, XtDefaultBackground),
    Bres(XtNhighlightReverse, XtCHighlightReverse, screen.hilite_reverse, True),
    Bres(XtNhighlightColorMode, XtCHighlightColorMode, screen.hilite_color, Maybe),
#endif				/* OPT_HIGHLIGHT_COLOR */

#if OPT_INPUT_METHOD
    Bres(XtNopenIm, XtCOpenIm, misc.open_im, True),
    Sres(XtNinputMethod, XtCInputMethod, misc.input_method, NULL),
    Sres(XtNpreeditType, XtCPreeditType, misc.preedit_type,
	 "OverTheSpot,Root"),
    Ires(XtNretryInputMethod, XtCRetryInputMethod, misc.retry_im, 3),
#endif

#if OPT_ISO_COLORS
    Bres(XtNboldColors, XtCColorMode, screen.boldColors, True),
    Ires(XtNveryBoldColors, XtCVeryBoldColors, screen.veryBoldColors, 0),
    Bres(XtNcolorMode, XtCColorMode, screen.colorMode, DFT_COLORMODE),

    Bres(XtNcolorAttrMode, XtCColorAttrMode, screen.colorAttrMode, False),
    Bres(XtNcolorBDMode, XtCColorAttrMode, screen.colorBDMode, False),
    Bres(XtNcolorBLMode, XtCColorAttrMode, screen.colorBLMode, False),
    Bres(XtNcolorRVMode, XtCColorAttrMode, screen.colorRVMode, False),
    Bres(XtNcolorULMode, XtCColorAttrMode, screen.colorULMode, False),
    Bres(XtNitalicULMode, XtCColorAttrMode, screen.italicULMode, False),
#if OPT_WIDE_ATTRS
    Bres(XtNcolorITMode, XtCColorAttrMode, screen.colorITMode, False),
#endif

    COLOR_RES("0", screen.Acolors[COLOR_0], DFT_COLOR("black")),
    COLOR_RES("1", screen.Acolors[COLOR_1], DFT_COLOR("red3")),
    COLOR_RES("2", screen.Acolors[COLOR_2], DFT_COLOR("green3")),
    COLOR_RES("3", screen.Acolors[COLOR_3], DFT_COLOR("yellow3")),
    COLOR_RES("4", screen.Acolors[COLOR_4], DFT_COLOR(DEF_COLOR4)),
    COLOR_RES("5", screen.Acolors[COLOR_5], DFT_COLOR("magenta3")),
    COLOR_RES("6", screen.Acolors[COLOR_6], DFT_COLOR("cyan3")),
    COLOR_RES("7", screen.Acolors[COLOR_7], DFT_COLOR("gray90")),
    COLOR_RES("8", screen.Acolors[COLOR_8], DFT_COLOR("gray50")),
    COLOR_RES("9", screen.Acolors[COLOR_9], DFT_COLOR("red")),
    COLOR_RES("10", screen.Acolors[COLOR_10], DFT_COLOR("green")),
    COLOR_RES("11", screen.Acolors[COLOR_11], DFT_COLOR("yellow")),
    COLOR_RES("12", screen.Acolors[COLOR_12], DFT_COLOR(DEF_COLOR12)),
    COLOR_RES("13", screen.Acolors[COLOR_13], DFT_COLOR("magenta")),
    COLOR_RES("14", screen.Acolors[COLOR_14], DFT_COLOR("cyan")),
    COLOR_RES("15", screen.Acolors[COLOR_15], DFT_COLOR("white")),
    COLOR_RES("BD", screen.Acolors[COLOR_BD], DFT_COLOR(XtDefaultForeground)),
    COLOR_RES("BL", screen.Acolors[COLOR_BL], DFT_COLOR(XtDefaultForeground)),
    COLOR_RES("UL", screen.Acolors[COLOR_UL], DFT_COLOR(XtDefaultForeground)),
    COLOR_RES("RV", screen.Acolors[COLOR_RV], DFT_COLOR(XtDefaultForeground)),

#if OPT_WIDE_ATTRS
    COLOR_RES("IT", screen.Acolors[COLOR_IT], DFT_COLOR(XtDefaultForeground)),
#endif

#if !OPT_COLOR_RES2
#if OPT_256_COLORS
# include <256colres.h>
#elif OPT_88_COLORS
# include <88colres.h>
#endif
#endif				/* !OPT_COLOR_RES2 */

#endif				/* OPT_ISO_COLORS */

    CLICK_RES("2", screen.onClick[1], "word"),
    CLICK_RES("3", screen.onClick[2], "line"),
    CLICK_RES("4", screen.onClick[3], 0),
    CLICK_RES("5", screen.onClick[4], 0),

#if OPT_MOD_FKEYS
    Ires(XtNmodifyKeyboard, XtCModifyKeyboard,
	 keyboard.modify_1st.allow_keys, 0),
    Ires(XtNmodifyCursorKeys, XtCModifyCursorKeys,
	 keyboard.modify_1st.cursor_keys, 2),
    Ires(XtNmodifyFunctionKeys, XtCModifyFunctionKeys,
	 keyboard.modify_1st.function_keys, 2),
    Ires(XtNmodifyKeypadKeys, XtCModifyKeypadKeys,
	 keyboard.modify_1st.keypad_keys, 0),
    Ires(XtNmodifyOtherKeys, XtCModifyOtherKeys,
	 keyboard.modify_1st.other_keys, 0),
    Ires(XtNmodifyStringKeys, XtCModifyStringKeys,
	 keyboard.modify_1st.string_keys, 0),
    Ires(XtNformatOtherKeys, XtCFormatOtherKeys,
	 keyboard.format_keys, 0),
#endif

#if OPT_NUM_LOCK
    Bres(XtNalwaysUseMods, XtCAlwaysUseMods, misc.alwaysUseMods, False),
    Bres(XtNnumLock, XtCNumLock, misc.real_NumLock, True),
#endif

#if OPT_PRINT_COLORS
    Ires(XtNprintAttributes, XtCPrintAttributes, SPS.print_attributes, 1),
#endif

#if OPT_REGIS_GRAPHICS
    Sres(XtNregisDefaultFont, XtCRegisDefaultFont,
	 screen.graphics_regis_default_font, ""),
    Sres(XtNregisScreenSize, XtCRegisScreenSize,
	 screen.graphics_regis_screensize, "auto"),
#endif

#if OPT_GRAPHICS
    Sres(XtNmaxGraphicSize, XtCMaxGraphicSize, screen.graphics_max_size,
	 "1000x1000"),
#endif

#if OPT_SHIFT_FONTS
    Bres(XtNshiftFonts, XtCShiftFonts, misc.shift_fonts, True),
#endif

#if OPT_SIXEL_GRAPHICS
    Bres(XtNsixelScrolling, XtCSixelScrolling, screen.sixel_scrolling, True),
    Bres(XtNsixelScrollsRight, XtCSixelScrollsRight,
	 screen.sixel_scrolls_right, False),
#endif

#if OPT_GRAPHICS
    Ires(XtNnumColorRegisters, XtCNumColorRegisters,
	 screen.numcolorregisters, 0),
    Bres(XtNprivateColorRegisters, XtCPrivateColorRegisters,
	 screen.privatecolorregisters, True),
#endif

#if OPT_SUNPC_KBD
    Ires(XtNctrlFKeys, XtCCtrlFKeys, misc.ctrl_fkeys, 10),
#endif

#if OPT_TEK4014
    Bres(XtNtekInhibit, XtCTekInhibit, misc.tekInhibit, False),
    Bres(XtNtekSmall, XtCTekSmall, misc.tekSmall, False),
    Bres(XtNtekStartup, XtCTekStartup, misc.TekEmu, False),
#endif

#if OPT_TOOLBAR
    Wres(XtNmenuBar, XtCMenuBar, VT100_TB_INFO(menu_bar), 0),
    Ires(XtNmenuHeight, XtCMenuHeight, VT100_TB_INFO(menu_height), 25),
#endif

#if OPT_WIDE_CHARS
    Bres(XtNcjkWidth, XtCCjkWidth, misc.cjk_width, False),
    Bres(XtNmkWidth, XtCMkWidth, misc.mk_width, False),
    Bres(XtNprecompose, XtCPrecompose, screen.normalized_c, True),
    Bres(XtNutf8Latin1, XtCUtf8Latin1, screen.utf8_latin1, False),
    Bres(XtNutf8Title, XtCUtf8Title, screen.utf8_title, False),
    Bres(XtNvt100Graphics, XtCVT100Graphics, screen.vt100_graphics, True),
    Bres(XtNwideChars, XtCWideChars, screen.wide_chars, False),
    Ires(XtNcombiningChars, XtCCombiningChars, screen.max_combining, 2),
    Ires(XtNmkSamplePass, XtCMkSamplePass, misc.mk_samplepass, 655),
    Ires(XtNmkSampleSize, XtCMkSampleSize, misc.mk_samplesize, 65536),
    Sres(XtNutf8, XtCUtf8, screen.utf8_mode_s, "default"),
    Sres(XtNutf8Fonts, XtCUtf8Fonts, screen.utf8_fonts_s, "default"),
    Sres(XtNwideBoldFont, XtCWideBoldFont, misc.default_font.f_wb, DEFWIDEBOLDFONT),
    Sres(XtNwideFont, XtCWideFont, misc.default_font.f_w, DEFWIDEFONT),
    Sres(XtNutf8SelectTypes, XtCUtf8SelectTypes, screen.utf8_select_types, NULL),
#endif

#if OPT_LUIT_PROG
    Sres(XtNlocale, XtCLocale, misc.locale_str, "medium"),
    Sres(XtNlocaleFilter, XtCLocaleFilter, misc.localefilter, DEFLOCALEFILTER),
#endif

#if OPT_INPUT_METHOD
    Sres(XtNximFont, XtCXimFont, misc.f_x, DEFXIMFONT),
#endif

#if OPT_SCROLL_LOCK
    Bres(XtNallowScrollLock, XtCAllowScrollLock, screen.allowScrollLock0, False),
#endif

    /* these are used only for testing ncurses, not in the manual page */
#if OPT_XMC_GLITCH
    Bres(XtNxmcInline, XtCXmcInline, screen.xmc_inline, False),
    Bres(XtNxmcMoveSGR, XtCXmcMoveSGR, screen.move_sgr_ok, True),
    Ires(XtNxmcAttributes, XtCXmcAttributes, screen.xmc_attributes, 1),
    Ires(XtNxmcGlitch, XtCXmcGlitch, screen.xmc_glitch, 0),
#endif

#ifdef SCROLLBAR_RIGHT
    Bres(XtNrightScrollBar, XtCRightScrollBar, misc.useRight, False),
#endif

#if OPT_RENDERFONT
#define RES_FACESIZE(n) Dres(XtNfaceSize #n, XtCFaceSize #n, misc.face_size[n], "0.0")
    RES_FACESIZE(1),
    RES_FACESIZE(2),
    RES_FACESIZE(3),
    RES_FACESIZE(4),
    RES_FACESIZE(5),
    RES_FACESIZE(6),
    Dres(XtNfaceSize, XtCFaceSize, misc.face_size[0], DEFFACESIZE),
    Sres(XtNfaceName, XtCFaceName, misc.default_xft.f_n, DEFFACENAME),
    Sres(XtNrenderFont, XtCRenderFont, misc.render_font_s, "default"),
#if OPT_RENDERWIDE
    Sres(XtNfaceNameDoublesize, XtCFaceNameDoublesize, misc.default_xft.f_w, DEFFACENAME),
#endif
#endif
};

static Boolean VTSetValues(Widget cur, Widget request, Widget new_arg,
			   ArgList args, Cardinal *num_args);
static void VTClassInit(void);
static void VTDestroy(Widget w);
static void VTExpose(Widget w, XEvent *event, Region region);
static void VTInitialize(Widget wrequest, Widget new_arg, ArgList args,
			 Cardinal *num_args);
static void VTRealize(Widget w, XtValueMask * valuemask,
		      XSetWindowAttributes * values);
static void VTResize(Widget w);

#if OPT_I18N_SUPPORT && OPT_INPUT_METHOD
static void VTInitI18N(XtermWidget);
#endif

#ifdef VMS
globaldef {
    "xtermclassrec"
} noshare

#else
static
#endif				/* VMS */
WidgetClassRec xtermClassRec =
{
    {
	/* core_class fields */
	(WidgetClass) & widgetClassRec,		/* superclass   */
	"VT100",		/* class_name                   */
	sizeof(XtermWidgetRec),	/* widget_size                  */
	VTClassInit,		/* class_initialize             */
	NULL,			/* class_part_initialize        */
	False,			/* class_inited                 */
	VTInitialize,		/* initialize                   */
	NULL,			/* initialize_hook              */
	VTRealize,		/* realize                      */
	actionsList,		/* actions                      */
	XtNumber(actionsList),	/* num_actions                  */
	xterm_resources,	/* resources                    */
	XtNumber(xterm_resources),	/* num_resources        */
	NULLQUARK,		/* xrm_class                    */
	True,			/* compress_motion              */
	False,			/* compress_exposure            */
	True,			/* compress_enterleave          */
	False,			/* visible_interest             */
	VTDestroy,		/* destroy                      */
	VTResize,		/* resize                       */
	VTExpose,		/* expose                       */
	VTSetValues,		/* set_values                   */
	NULL,			/* set_values_hook              */
	XtInheritSetValuesAlmost,	/* set_values_almost    */
	NULL,			/* get_values_hook              */
	NULL,			/* accept_focus                 */
	XtVersion,		/* version                      */
	NULL,			/* callback_offsets             */
	0,			/* tm_table                     */
	XtInheritQueryGeometry,	/* query_geometry               */
	XtInheritDisplayAccelerator,	/* display_accelerator  */
	NULL			/* extension                    */
    }
};

#ifdef VMS
globaldef {
    "xtermwidgetclass"
}
noshare
#endif /* VMS */
WidgetClass xtermWidgetClass = (WidgetClass) & xtermClassRec;

/*
 * Add input-actions for widgets that are overlooked (scrollbar and toolbar):
 *
 *	a) Sometimes the scrollbar passes through translations, sometimes it
 *	   doesn't.  We add the KeyPress translations here, just to be sure.
 *	b) In the normal (non-toolbar) configuration, the xterm widget covers
 *	   almost all of the window.  With a toolbar, there's a relatively
 *	   large area that the user would expect to enter keystrokes since the
 *	   program can get the focus.
 */
void
xtermAddInput(Widget w)
{
    /* *INDENT-OFF* */
    XtActionsRec input_actions[] = {
	{ "insert",		    HandleKeyPressed }, /* alias */
	{ "insert-eight-bit",	    HandleEightBitKeyPressed },
	{ "insert-seven-bit",	    HandleKeyPressed },
	{ "secure",		    HandleSecure },
	{ "string",		    HandleStringEvent },
	{ "scroll-back",	    HandleScrollBack },
	{ "scroll-forw",	    HandleScrollForward },
	{ "select-cursor-end",	    HandleKeyboardSelectEnd },
	{ "select-cursor-extend",   HandleKeyboardSelectExtend },
	{ "select-cursor-start",    HandleKeyboardSelectStart },
	{ "insert-selection",	    HandleInsertSelection },
	{ "select-start",	    HandleSelectStart },
	{ "select-extend",	    HandleSelectExtend },
	{ "start-extend",	    HandleStartExtend },
	{ "select-end",		    HandleSelectEnd },
	{ "clear-saved-lines",	    HandleClearSavedLines },
	{ "popup-menu",		    HandlePopupMenu },
	{ "bell",		    HandleBell },
	{ "ignore",		    HandleIgnore },
#if OPT_DABBREV
	{ "dabbrev-expand",	    HandleDabbrevExpand },
#endif
#if OPT_MAXIMIZE
	{ "fullscreen",		    HandleFullscreen },
#endif
#if OPT_SCROLL_LOCK
	{ "scroll-lock",	    HandleScrollLock },
#endif
#if OPT_SHIFT_FONTS
	{ "larger-vt-font",	    HandleLargerFont },
	{ "smaller-vt-font",	    HandleSmallerFont },
#endif
    };
    /* *INDENT-ON* */

    TRACE_TRANS("BEFORE", w);
    XtAppAddActions(app_con, input_actions, XtNumber(input_actions));
    XtAugmentTranslations(w, XtParseTranslationTable(defaultTranslations));
    TRACE_TRANS("AFTER:", w);

#if OPT_EXTRA_PASTE
    if (term && term->keyboard.extra_translations)
	XtOverrideTranslations((Widget) term, XtParseTranslationTable(term->keyboard.extra_translations));
#endif
}

#if OPT_ISO_COLORS
#ifdef EXP_BOGUS_FG
static Bool
CheckBogusForeground(TScreen *screen, const char *tag)
{
    int row = -1, col = -1, pass;
    Bool isClear = True;

    (void) tag;
    for (pass = 0; pass < 2; ++pass) {
	row = screen->cur_row;
	for (; isClear && (row <= screen->max_row); ++row) {
	    CLineData *ld = getLineData(screen, row);

	    if (ld != 0) {
		IAttr *attribs = ld->attribs;

		col = (row == screen->cur_row) ? screen->cur_col : 0;
		for (; isClear && (col <= screen->max_col); ++col) {
		    unsigned flags = attribs[col];
		    if (pass) {
			flags &= ~FG_COLOR;
			attribs[col] = (IAttr) flags;
		    } else if ((flags & BG_COLOR)) {
			isClear = False;
		    } else if ((flags & FG_COLOR)) {
			unsigned ch = ld->charData[col];
			isClear = ((ch == ' ') || (ch == 0));
		    } else {
			isClear = False;
		    }
		}
	    }
	}
    }
    TRACE(("%s checked %d,%d to %d,%d %s pass %d\n",
	   tag, screen->cur_row, screen->cur_col,
	   row, col,
	   isClear && pass ? "cleared" : "unchanged",
	   pass));

    return isClear;
}
#endif

/*
 * The terminal's foreground and background colors are set via two mechanisms:
 *	text (cur_foreground, cur_background values that are passed down to
 *		XDrawImageString and XDrawString)
 *	area (X11 graphics context used in XClearArea and XFillRectangle)
 */
void
SGR_Foreground(XtermWidget xw, int color)
{
    TScreen *screen = TScreenOf(xw);
    Pixel fg;

    if (color >= 0) {
	UIntSet(xw->flags, FG_COLOR);
    } else {
	UIntClr(xw->flags, FG_COLOR);
    }
    fg = getXtermForeground(xw, xw->flags, color);
    xw->cur_foreground = color;

    setCgsFore(xw, WhichVWin(screen), gcNorm, fg);
    setCgsBack(xw, WhichVWin(screen), gcNormReverse, fg);

    setCgsFore(xw, WhichVWin(screen), gcBold, fg);
    setCgsBack(xw, WhichVWin(screen), gcBoldReverse, fg);

#ifdef EXP_BOGUS_FG
    /*
     * If we've just turned off the foreground color, check for blank cells
     * which have no background color, but do have foreground color.  This
     * could happen due to setting the foreground color just before scrolling.
     *
     * Those cells look uncolored, but will confuse ShowCursor(), which looks
     * for the colors in the current cell, and will see the foreground color.
     * In that case, remove the foreground color from the blank cells.
     */
    if (color < 0) {
	CheckBogusForeground(screen, "SGR_Foreground");
    }
#endif
}

void
SGR_Background(XtermWidget xw, int color)
{
    TScreen *screen = TScreenOf(xw);
    Pixel bg;

    /*
     * An indexing operation may have set screen->scroll_amt, which would
     * normally result in calling FlushScroll() in WriteText().  However,
     * if we're changing the background color now, then the new value
     * should not apply to the pending blank lines.
     */
    if (screen->scroll_amt && (color != xw->cur_background))
	FlushScroll(xw);

    if (color >= 0) {
	UIntSet(xw->flags, BG_COLOR);
    } else {
	UIntClr(xw->flags, BG_COLOR);
    }
    bg = getXtermBackground(xw, xw->flags, color);
    xw->cur_background = color;

    setCgsBack(xw, WhichVWin(screen), gcNorm, bg);
    setCgsFore(xw, WhichVWin(screen), gcNormReverse, bg);

    setCgsBack(xw, WhichVWin(screen), gcBold, bg);
    setCgsFore(xw, WhichVWin(screen), gcBoldReverse, bg);
}

/* Invoked after updating bold/underline flags, computes the extended color
 * index to use for foreground.  (See also 'extract_fg()').
 */
static void
setExtendedFG(XtermWidget xw)
{
    int fg = xw->sgr_foreground;

    if (TScreenOf(xw)->colorAttrMode
	|| (fg < 0)) {
	fg = MapToColorMode(fg, TScreenOf(xw), xw->flags);
    }

    /* This implements the IBM PC-style convention of 8-colors, with one
     * bit for bold, thus mapping the 0-7 codes to 8-15.  It won't make
     * much sense for 16-color applications, but we keep it to retain
     * compatiblity with ANSI-color applications.
     */
#if OPT_PC_COLORS		/* XXXJTL should be settable at runtime (resource or OSC?) */
    if (TScreenOf(xw)->boldColors
	&& (!xw->sgr_extended)
	&& (fg >= 0)
	&& (fg < 8)
	&& (xw->flags & BOLD))
	fg |= 8;
#endif

    SGR_Foreground(xw, fg);
}

/* Invoked after updating inverse flag, computes the extended color
 * index to use for background.  (See also 'extract_bg()').
 */
static void
setExtendedBG(XtermWidget xw)
{
    int bg = xw->sgr_background;

    if (TScreenOf(xw)->colorAttrMode
	|| (bg < 0)) {
	if (TScreenOf(xw)->colorRVMode && (xw->flags & INVERSE))
	    bg = COLOR_RV;
    }

    SGR_Background(xw, bg);
}

static void
reset_SGR_Foreground(XtermWidget xw)
{
    xw->sgr_foreground = -1;
    xw->sgr_extended = False;
    setExtendedFG(xw);
}

static void
reset_SGR_Background(XtermWidget xw)
{
    xw->sgr_background = -1;
    setExtendedBG(xw);
}

static void
reset_SGR_Colors(XtermWidget xw)
{
    reset_SGR_Foreground(xw);
    reset_SGR_Background(xw);
}
#endif /* OPT_ISO_COLORS */

#if OPT_WIDE_ATTRS
/*
 * Call this before changing the state of ATR_ITALIC, to update the GC fonts.
 */
static void
setItalicFont(XtermWidget xw, Bool enable)
{
    if (enable) {
	if ((xw->flags & ATR_ITALIC) == 0) {
	    xtermLoadItalics(xw);
	    TRACE(("setItalicFont: enabling Italics\n"));
	    xtermUpdateFontGCs(xw, True);
	}
    } else if ((xw->flags & ATR_ITALIC) != 0) {
	TRACE(("setItalicFont: disabling Italics\n"));
	xtermUpdateFontGCs(xw, False);
    }
}
#endif

void
resetCharsets(TScreen *screen)
{
    TRACE(("resetCharsets\n"));

    screen->gsets[0] = nrc_ASCII;
    screen->gsets[1] = nrc_ASCII;
    screen->gsets[2] = nrc_ASCII;
    screen->gsets[3] = nrc_ASCII;

    screen->curgl = 0;		/* G0 => GL.            */
    screen->curgr = 2;		/* G2 => GR.            */
    screen->curss = 0;		/* No single shift.     */

#if OPT_VT52_MODE
    if (screen->vtXX_level == 0)
	screen->gsets[1] = nrc_DEC_Spec_Graphic;	/* Graphics */
#endif
}

static void
modified_DECNRCM(XtermWidget xw)
{
#if OPT_WIDE_CHARS
    TScreen *screen = TScreenOf(xw);
    if (screen->wide_chars && (screen->utf8_mode || screen->utf8_nrc_mode)) {
	int enabled = ((xw->flags & NATIONAL) != 0);
	int modefix;
	EXCHANGE(screen->utf8_nrc_mode, screen->utf8_mode, modefix);
	switchPtyData(screen, !enabled);
	TRACE(("UTF8 mode temporarily %s\n", enabled ? "ON" : "OFF"));
    }
#endif
}

/*
 * VT300 and up support three ANSI conformance levels, defined according to
 * the dpANSI X3.134.1 standard.  DEC's manuals equate levels 1 and 2, and
 * are unclear.  This code is written based on the manuals.
 */
static void
set_ansi_conformance(TScreen *screen, int level)
{
    TRACE(("set_ansi_conformance(%d) dec_level %d:%d, ansi_level %d\n",
	   level,
	   screen->vtXX_level * 100,
	   screen->terminal_id,
	   screen->ansi_level));
    if (screen->vtXX_level >= 3) {
	switch (screen->ansi_level = level) {
	case 1:
	    /* FALLTHRU */
	case 2:
	    screen->gsets[0] = nrc_ASCII;	/* G0 is ASCII */
	    screen->gsets[1] = nrc_ASCII;	/* G1 is ISO Latin-1 */
	    screen->curgl = 0;
	    screen->curgr = 1;
	    break;
	case 3:
	    screen->gsets[0] = nrc_ASCII;	/* G0 is ASCII */
	    screen->curgl = 0;
	    break;
	}
    }
}

/*
 * Set scrolling margins.  VTxxx terminals require that the top/bottom are
 * different, so we have at least two lines in the scrolling region.
 */
void
set_tb_margins(TScreen *screen, int top, int bottom)
{
    TRACE(("set_tb_margins %d..%d, prior %d..%d\n",
	   top, bottom,
	   screen->top_marg,
	   screen->bot_marg));
    if (bottom > top) {
	screen->top_marg = top;
	screen->bot_marg = bottom;
    }
    if (screen->top_marg > screen->max_row)
	screen->top_marg = screen->max_row;
    if (screen->bot_marg > screen->max_row)
	screen->bot_marg = screen->max_row;
}

void
set_lr_margins(TScreen *screen, int left, int right)
{
    TRACE(("set_lr_margins %d..%d, prior %d..%d\n",
	   left, right,
	   screen->lft_marg,
	   screen->rgt_marg));
    if (right > left) {
	screen->lft_marg = left;
	screen->rgt_marg = right;
    }
    if (screen->lft_marg > screen->max_col)
	screen->lft_marg = screen->max_col;
    if (screen->rgt_marg > screen->max_col)
	screen->rgt_marg = screen->max_col;
}

#define reset_tb_margins(screen) set_tb_margins(screen, 0, screen->max_row)
#define reset_lr_margins(screen) set_lr_margins(screen, 0, screen->max_col)

static void
reset_margins(TScreen *screen)
{
    reset_tb_margins(screen);
    reset_lr_margins(screen);
}

void
set_max_col(TScreen *screen, int cols)
{
    TRACE(("set_max_col %d, prior %d\n", cols, screen->max_col));
    if (cols < 0)
	cols = 0;
    screen->max_col = cols;
}

void
set_max_row(TScreen *screen, int rows)
{
    TRACE(("set_max_row %d, prior %d\n", rows, screen->max_row));
    if (rows < 0)
	rows = 0;
    screen->max_row = rows;
}

#if OPT_MOD_FKEYS
static void
set_mod_fkeys(XtermWidget xw, int which, int what, Bool enabled)
{
#define SET_MOD_FKEYS(field) \
    xw->keyboard.modify_now.field = ((what == DEFAULT) && enabled) \
				     ? xw->keyboard.modify_1st.field \
				     : what; \
    TRACE(("set modify_now.%s to %d\n", #field, \
	   xw->keyboard.modify_now.field));

    switch (which) {
    case 0:
	SET_MOD_FKEYS(allow_keys);
	break;
    case 1:
	SET_MOD_FKEYS(cursor_keys);
	break;
    case 2:
	SET_MOD_FKEYS(function_keys);
	break;
    case 3:
	SET_MOD_FKEYS(keypad_keys);
	break;
    case 4:
	SET_MOD_FKEYS(other_keys);
	break;
    case 5:
	SET_MOD_FKEYS(string_keys);
	break;
    }
}
#endif /* OPT_MOD_FKEYS */

#if OPT_TRACE
#define DATA(name) { name, #name }
static const struct {
    Const PARSE_T *table;
    const char *name;
} all_tables[] = {

    DATA(ansi_table)
	,DATA(cigtable)
	,DATA(csi2_table)
	,DATA(csi_ex_table)
	,DATA(csi_quo_table)
	,DATA(csi_table)
	,DATA(dec2_table)
	,DATA(dec3_table)
	,DATA(dec_table)
	,DATA(eigtable)
	,DATA(esc_sp_table)
	,DATA(esc_table)
	,DATA(scrtable)
	,DATA(scs96table)
	,DATA(scstable)
	,DATA(sos_table)
#if OPT_BLINK_CURS
	,DATA(csi_sp_table)
#endif
#if OPT_DEC_LOCATOR
	,DATA(csi_tick_table)
#endif
#if OPT_DEC_RECTOPS
	,DATA(csi_dollar_table)
	,DATA(csi_star_table)
	,DATA(csi_dec_dollar_table)
#endif
#if OPT_WIDE_CHARS
	,DATA(esc_pct_table)
	,DATA(scs_pct_table)
#endif
#if OPT_VT52_MODE
	,DATA(vt52_table)
	,DATA(vt52_esc_table)
	,DATA(vt52_ignore_table)
#endif
#undef DATA
};

#define WHICH_TABLE(name) if (table == name) result = #name
static const char *
which_table(Const PARSE_T * table)
{
    const char *result = "?";
    Cardinal n;
    for (n = 0; n < XtNumber(all_tables); ++n) {
	if (table == all_tables[n].table) {
	    result = all_tables[n].name;
	    break;
	}
    }

    return result;
}

static void
check_tables(void)
{
    Cardinal n;
    int ch;

    TRACE(("** check_tables\n"));
    for (n = 0; n < XtNumber(all_tables); ++n) {
	Const PARSE_T *table = all_tables[n].table;
	TRACE(("*** %s\n", all_tables[n].name));
	/*
	 * Most of the tables should use the same codes in 0..31, 128..159
	 * as the "ansi" table.
	 */
	if (strncmp(all_tables[n].name, "ansi", 4) &&
	    strncmp(all_tables[n].name, "sos_", 4) &&
	    strncmp(all_tables[n].name, "vt52", 4)) {
	    for (ch = 0; ch < 32; ++ch) {
		int c1 = ch + 128;
		PARSE_T st_l = table[ch];
		PARSE_T st_r = table[c1];
		if (st_l != ansi_table[ch]) {
		    TRACE(("  %3d: %d vs %d\n", ch, st_l, ansi_table[ch]));
		}
		if (st_r != ansi_table[c1]) {
		    TRACE(("  %3d: %d vs %d\n", c1, st_r, ansi_table[c1]));
		}
	    }
	}
	/*
	 * All of the tables should have their GL/GR parts encoded the same.
	 */
	for (ch = 32; ch < 127; ++ch) {
	    PARSE_T st_l = table[ch];
	    PARSE_T st_r = table[ch + 128];
	    if (st_l != st_r) {
		if (st_r == CASE_IGNORE &&
		    !strncmp(all_tables[n].name, "vt52", 4)) {
		    ;
		} else {
		    TRACE(("  %3d: %d vs %d\n", ch, st_l, st_r));
		}
	    }
	}
    }
}
#endif

#if OPT_TRACE > 0
static void
dump_params(void)
{
    int n;
    int arg;
    TRACE(("params %d (%d)\n", nparam, parms.has_subparams));
    for (arg = 1, n = 0; n < nparam; ++n) {
	TRACE(("%3d.%d %d\n", arg, parms.is_sub[n], parms.params[n]));
	if (!parms.is_sub[n])
	    ++arg;
    }
}
#define DumpParams() dump_params()
#else
#define DumpParams()		/* nothing */
#endif

	/* allocate larger buffer if needed/possible */
#define SafeAlloc(type, area, used, size) \
		type *new_string = area; \
		size_t new_length = size; \
		if (new_length == 0) { \
		    new_length = 256; \
		    new_string = TypeMallocN(type, new_length); \
		} else if (used+1 >= new_length) { \
		    new_length = size * 2; \
		    new_string = TypeMallocN(type, new_length); \
		    if (new_string != 0 \
		     && area != 0 \
		     && used != 0) { \
			memcpy(new_string, area, used * sizeof(type)); \
		     } \
		}
#define SafeFree(area, size) \
		if (area != new_string) { \
		    free(area); \
		    area = new_string; \
		} \
		size = new_length

#define WriteNow() {						\
	    unsigned single = 0;				\
								\
	    if (screen->curss) {				\
		dotext(xw,					\
		       screen->gsets[(int) (screen->curss)],	\
		       sp->print_area,				\
		       (Cardinal) 1);				\
		screen->curss = 0;				\
		single++;					\
	    }							\
	    if (sp->print_used > single) {			\
		dotext(xw,					\
		       screen->gsets[(int) (screen->curgl)],	\
		       sp->print_area + single,			\
		       (Cardinal) (sp->print_used - single));	\
	    }							\
	    sp->print_used = 0;					\
	}							\

struct ParseState {
#if OPT_VT52_MODE
    Bool vt52_cup;
#endif
    Const PARSE_T *groundtable;
    Const PARSE_T *parsestate;
    int scstype;
    int scssize;
    Bool private_function;	/* distinguish private-mode from standard */
    int string_mode;		/* nonzero iff we're processing a string */
    int lastchar;		/* positive iff we had a graphic character */
    int nextstate;
#if OPT_WIDE_CHARS
    int last_was_wide;
#endif
    /* Buffer for processing printable text */
    IChar *print_area;
    size_t print_size;
    size_t print_used;
    /* Buffer for processing strings (e.g., OSC ... ST) */
    Char *string_area;
    size_t string_size;
    size_t string_used;
};

static struct ParseState myState;

static void
init_groundtable(TScreen *screen, struct ParseState *sp)
{
    (void) screen;

#if OPT_VT52_MODE
    if (!(screen->vtXX_level)) {
	sp->groundtable = vt52_table;
    } else if (screen->terminal_id >= 100)
#endif
    {
	sp->groundtable = ansi_table;
    }
}

static void
select_charset(struct ParseState *sp, int type, int size)
{
    TRACE(("select_charset %d %d\n", type, size));
    sp->scstype = type;
    sp->scssize = size;
    if (size == 94) {
	sp->parsestate = scstable;
    } else {
	sp->parsestate = scs96table;
    }
}

static void
decode_scs(XtermWidget xw, int which, int prefix, int suffix)
{
    /* *INDENT-OFF* */
    static struct {
	DECNRCM_codes result;
	int prefix;
	int suffix;
	int min_level;
	int max_level;
	int need_nrc;
    } table[] = {
	{ nrc_ASCII,             0,   'B', 1, 9, 0 },
	{ nrc_British,           0,   'A', 1, 9, 0 },
	{ nrc_DEC_Spec_Graphic,  0,   '0', 1, 9, 0 },
	{ nrc_DEC_Alt_Chars,     0,   '1', 1, 1, 0 },
	{ nrc_DEC_Alt_Graphics,  0,   '2', 1, 1, 0 },
	/* VT2xx */
	{ nrc_DEC_Supp,          0,   '<', 2, 9, 0 },
	{ nrc_Dutch,             0,   '4', 2, 9, 1 },
	{ nrc_Finnish,           0,   '5', 2, 9, 1 },
	{ nrc_Finnish2,          0,   'C', 2, 9, 1 },
	{ nrc_French,            0,   'R', 2, 9, 1 },
	{ nrc_French2,           0,   'f', 2, 9, 1 },
	{ nrc_French_Canadian,   0,   'Q', 2, 9, 1 },
	{ nrc_German,            0,   'K', 2, 9, 1 },
	{ nrc_Italian,           0,   'Y', 2, 9, 1 },
	{ nrc_Norwegian_Danish2, 0,   'E', 2, 9, 1 },
	{ nrc_Norwegian_Danish3, 0,   '6', 2, 9, 1 },
	{ nrc_Spanish,           0,   'Z', 2, 9, 1 },
	{ nrc_Swedish,           0,   '7', 2, 9, 1 },
	{ nrc_Swedish2,          0,   'H', 2, 9, 1 },
	{ nrc_Swiss,             0,   '=', 2, 9, 1 },
	/* VT3xx */
	{ nrc_British_Latin_1,   0,   'A', 3, 9, 1 },
	{ nrc_DEC_Supp_Graphic,  '%', '5', 3, 9, 0 },
	{ nrc_DEC_Technical,     0,   '>', 3, 9, 0 },
	{ nrc_French_Canadian2,  0,   '9', 3, 9, 1 },
	{ nrc_Norwegian_Danish,  0,   '`', 3, 9, 1 },
	{ nrc_Portugese,         '%', '6', 3, 9, 1 },
#if 0
	/* VT5xx (not implemented) */
	{ nrc_Cyrillic,          '&', '4', 5, 9, 0 },
	{ nrc_Greek,             '"', '?', 5, 9, 0 },
	{ nrc_Greek_Supp,        0,   'F', 5, 9, 0 },
	{ nrc_Hebrew,            '"', '4', 5, 9, 0 },
	{ nrc_Hebrew2,           '%', '=', 5, 9, 1 },
	{ nrc_Hebrew_Supp,       0,   'H', 5, 9, 0 },
	{ nrc_Latin_5_Supp,      0,   'M', 5, 9, 0 },
	{ nrc_Latin_Cyrillic,    0,   'L', 5, 9, 0 },
	{ nrc_Russian,           '&', '5', 5, 9, 1 },
	{ nrc_SCS_NRCS,          '%', '3', 5, 9, 0 },
	{ nrc_Turkish,           '%', '0', 5, 9, 0 },
	{ nrc_Turkish2,		 '%', '2', 5, 9, 1 },
#endif
    };
    /* *INDENT-ON* */

    TScreen *screen = TScreenOf(xw);
    Cardinal n;
    DECNRCM_codes result = nrc_Unknown;

    suffix &= 0x7f;
    for (n = 0; n < XtNumber(table); ++n) {
	if (prefix == table[n].prefix
	    && suffix == table[n].suffix
	    && screen->vtXX_level >= table[n].min_level
	    && screen->vtXX_level <= table[n].max_level
	    && (table[n].need_nrc == 0 || (xw->flags & NATIONAL) != 0)) {
	    result = table[n].result;
	    break;
	}
    }
    if (result != nrc_Unknown) {
	screen->gsets[which] = result;
	TRACE(("setting G%d to %s\n", which, visibleScsCode((int) result)));
    } else {
	TRACE(("...unknown GSET\n"));
    }
}

/*
 * Given a parameter number, and subparameter (starting in each case from zero)
 * return the corresponding index into the parameter array.  If the combination
 * is not found, return -1.
 */
static int
subparam_index(int p, int s)
{
    int result = -1;
    int j, p2, s2;

    for (j = p2 = 0; j < nparam; ++j, ++p2) {
	if (parms.is_sub[j]) {
	    s2 = 0;

	    do {
		if ((p == p2) && (s == s2)) {
		    result = j;
		    break;
		}
		++s2;
	    } while ((++j < nparam) && (parms.is_sub[j - 1] < parms.is_sub[j]));

	    if (result >= 0)
		break;

	    --j;		/* undo the last "while" */
	} else if (p == p2) {
	    if (s == 0) {
		result = j;
	    }
	    break;
	}
    }
    TRACE2(("...subparam_index %d.%d = %d\n", p + 1, s + 1, result));
    return result;
}

/*
 * Check if the given item in the parameter array has subparameters.
 * If so, return the number of subparameters to use as a loop limit, etc.
 */
static int
param_has_subparams(int item)
{
    int result = 0;
    if (parms.has_subparams) {
	int n = subparam_index(item, 0);
	if (n >= 0 && parms.is_sub[n]) {
	    while (n++ < nparam && parms.is_sub[n - 1] < parms.is_sub[n]) {
		result++;
	    }
	}
    }
    TRACE(("...param_has_subparams(%d) ->%d\n", item, result));
    return result;
}

#if OPT_256_COLORS || OPT_88_COLORS || OPT_ISO_COLORS
/*
 * Given an index into the parameter array, return the corresponding parameter
 * number (starting from zero).
 */
static int
param_number(int item)
{
    int result = -1;
    int j, p;

    for (j = p = 0; j < nparam; ++j, ++p) {
	if (p >= item) {
	    result = j;
	    break;
	}
	if (parms.is_sub[j]) {
	    while ((++j < nparam) && (parms.is_sub[j - 1] < parms.is_sub[j])) {
		/* EMPTY */
	    }
	    --j;
	}
    }

    TRACE2(("...param_number(%d) = %d\n", item, result));
    return result;
}

static int
get_subparam(int p, int s)
{
    int item = subparam_index(p, s);
    int result = (item >= 0) ? parms.params[item] : DEFAULT;
    TRACE(("...get_subparam[%d] = %d\n", item, result));
    return result;
}

/*
 * Some background -
 *
 * Todd Larason provided the initial changes to support 256-colors in July 1999.
 * I pointed out that the description of SGR 38/48 in ECMA-48 was vague, and
 * was unsure if there would be some standard using those codes.  His response
 * was that this was documented (it turns out, in equally vague terms) in ITU
 * T.416
 *
 * Discussing this with Todd Larason in mid-1999, my point was that given the
 * high cost of obtaining ITU T.416 (ISO-8613-6), the standard was not going
 * to be effective (more than $100 then, more than $200 in 2012)
 *
 * We overlooked the detail about ":" as a subparameter delimiter (documented
 * in 5.4.t2 in ECMA-48).  Some discussion in KDE in mid-2006 led Lars Doelle
 * to discuss the issue with me.  Lars' initial concern dealt with the fact
 * that a sequence such as
 *	CSI 38 ; 5 ; 1 m
 * violated the principle that SGR parameters could be used in any order.
 * Further discussion (see KDE #107487) resolved that the standard expected
 * that the sequence would look like
 *	CSI 38 ; 5 : 1 m
 * which still violates that principle, since the "5:1" parameter has to
 * follow the "38" to be useful.
 *
 * This function accepts either format (per request by Paul Leonerd Evans).
 * It also accepts
 *	CSI 38 : 5 : 1 m
 * according to Lars' original assumption.
 *
 * By the way - all of the parameters are decimal integers.
 */
#define extended_colors_limit(n) ((n) == 5 ? 1 : ((n) == 2 ? 3 : 0))
static Boolean
parse_extended_colors(XtermWidget xw, int *colorp, int *itemp)
{
    Boolean result = False;
    int item = *itemp;
    int next = item;
    int base = param_number(item);
    int code = -1;
    int values[3];		/* maximum number of subparameters */
    int need = 0;		/* number of subparameters needed */
    int have;
    int n;

    /*
     * On entry, 'item' points to the 38/48 code in the parameter array.
     * If that has subparameters, we will expect all of the values to
     * be subparameters of that item.
     */
    if ((have = param_has_subparams(item)) != 0) {
	/* accept CSI 38 : 5 : 1 m */
	/* accept CSI 38 : 2 : 1 : 2 : 3 m */
	code = get_subparam(base, 1);
	need = extended_colors_limit(code);
	next = item + have;
	for (n = 0; n < need && n < 3; ++n) {
	    values[n] = get_subparam(base, 2 + n);
	}
    } else if (++item < nparam) {
	++base;
	if ((have = param_has_subparams(item)) != 0) {
	    /* accept CSI 38 ; 5 : 1 m */
	    /* accept CSI 38 ; 2 : 1 : 2 : 3 m */
	    code = get_subparam(base, 0);
	    need = extended_colors_limit(code);
	    next = base + have;
	    for (n = 0; n < need && n < 3; ++n) {
		values[n] = get_subparam(base, 1 + n);
	    }
	} else {
	    /* accept CSI 38 ; 5 ; 1 m */
	    /* accept CSI 38 ; 2 ; 1 ; 2 ; 3 m */
	    code = GetParam(item);
	    need = extended_colors_limit(code);
	    next = item + need;
	    for (n = 0; n < need && n < 3; ++n) {
		values[n] = GetParam(item + 1 + n);
	    }
	}
    }
    item = next;

    switch (code) {
    case 2:
	/* direct color in rgb space */
	if ((values[0] >= 0 && values[0] < 256) &&
	    (values[1] >= 0 && values[1] < 256) &&
	    (values[2] >= 0 && values[2] < 256)) {
	    *colorp = xtermClosestColor(xw, values[0], values[1], values[2]);
	} else {
	    *colorp = -1;
	}
	break;
    case 5:
	/* indexed color */
	*colorp = values[0];
	break;
    default:
	*colorp = -1;
	break;
    }

    result = (*colorp >= 0 && *colorp < NUM_ANSI_COLORS);
    TRACE(("...resulting color %d/%d %s\n",
	   *colorp, NUM_ANSI_COLORS,
	   result ? "OK" : "ERR"));

    *itemp = item;
    return result;
}
#endif /* ...extended_colors */

static int
optional_param(int which)
{
    return (nparam > which) ? GetParam(which) : DEFAULT;
}

static int
zero_if_default(int which)
{
    int result = (nparam > which) ? GetParam(which) : 0;
    if (result <= 0)
	result = 0;
    return result;
}

static int
one_if_default(int which)
{
    int result = (nparam > which) ? GetParam(which) : 0;
    if (result <= 0)
	result = 1;
    return result;
}

/*
 * Color palette changes using the OSC controls require a repaint of the
 * screen - but not immediately.  Do the repaint as soon as we detect a
 * state which will not lead to another color palette change.
 */
static void
repaintWhenPaletteChanged(XtermWidget xw, struct ParseState *sp)
{
    Boolean ignore = False;

    switch (sp->nextstate) {
    case CASE_ESC:
	ignore = ((sp->parsestate == ansi_table) ||
		  (sp->parsestate == sos_table));
	break;
    case CASE_OSC:
	ignore = ((sp->parsestate == ansi_table) ||
		  (sp->parsestate == esc_table));
	break;
    case CASE_IGNORE:
	ignore = (sp->parsestate == sos_table);
	break;
    case CASE_ST:
	ignore = ((sp->parsestate == esc_table) ||
		  (sp->parsestate == sos_table));
	break;
    case CASE_ESC_DIGIT:
	ignore = (sp->parsestate == csi_table);
	break;
    case CASE_ESC_SEMI:
	ignore = (sp->parsestate == csi2_table);
	break;
    }

    if (!ignore) {
	TRACE(("repaintWhenPaletteChanged\n"));
	xw->work.palette_changed = False;
	xtermRepaint(xw);
    }
}

#if OPT_C1_PRINT || OPT_WIDE_CHARS
#define ParseSOS(screen) ((screen)->c1_printable == 0)
#else
#define ParseSOS(screen) 0
#endif

#define ResetState(sp) ParamsDone(), (sp)->parsestate = (sp)->groundtable

static void
illegal_parse(XtermWidget xw, unsigned c, struct ParseState *sp)
{
    ResetState(sp);
    sp->nextstate = sp->parsestate[E2A(c)];
    Bell(xw, XkbBI_MinorError, 0);
}

static void
init_parser(XtermWidget xw, struct ParseState *sp)
{
    TScreen *screen = TScreenOf(xw);

    memset(sp, 0, sizeof(*sp));
    sp->scssize = 94;		/* number of printable/nonspace ASCII */
    sp->lastchar = -1;		/* not a legal IChar */
    sp->nextstate = -1;		/* not a legal state */

    init_groundtable(screen, sp);
    ResetState(sp);
}

static void
init_reply(unsigned type)
{
    memset(&reply, 0, sizeof(reply));
    reply.a_type = (Char) type;
}

static Boolean
doparsing(XtermWidget xw, unsigned c, struct ParseState *sp)
{
    TScreen *screen = TScreenOf(xw);
    int item;
    int count;
    int value;
    int laststate;
    int thischar = -1;
    XTermRect myRect;

    do {
#if OPT_WIDE_CHARS
	int this_is_wide = 0;

	/*
	 * Handle zero-width combining characters.  Make it faster by noting
	 * that according to the Unicode charts, the majority of Western
	 * character sets do not use this feature.  There are some unassigned
	 * codes at 0x242, but no zero-width characters until past 0x300.
	 */
	if (c >= 0x300
	    && screen->wide_chars
	    && my_wcwidth((wchar_t) c) == 0
	    && !isWideControl(c)) {
	    int prev, test;
	    Boolean used = True;
	    int use_row;
	    int use_col;

	    WriteNow();
	    use_row = (screen->char_was_written
		       ? screen->last_written_row
		       : screen->cur_row);
	    use_col = (screen->char_was_written
		       ? screen->last_written_col
		       : screen->cur_col);

	    /*
	     * Check if the latest data can be added to the base character.
	     * If there is already a combining character stored for the cell,
	     * we cannot, since that would change the order.
	     */
	    if (screen->normalized_c
		&& !IsCellCombined(screen, use_row, use_col)) {
		prev = (int) XTERM_CELL(use_row, use_col);
		test = do_precomposition(prev, (int) c);
		TRACE(("do_precomposition (U+%04X [%d], U+%04X [%d]) -> U+%04X [%d]\n",
		       prev, my_wcwidth((wchar_t) prev),
		       (int) c, my_wcwidth((wchar_t) c),
		       test, my_wcwidth((wchar_t) test)));
	    } else {
		prev = -1;
		test = -1;
	    }

	    /* substitute combined character with precomposed character
	     * only if it does not change the width of the base character
	     */
	    if (test != -1
		&& my_wcwidth((wchar_t) test) == my_wcwidth((wchar_t) prev)) {
		putXtermCell(screen, use_row, use_col, test);
	    } else if (screen->char_was_written
		       || getXtermCell(screen, use_row, use_col) > ' ') {
		addXtermCombining(screen, use_row, use_col, c);
	    } else {
		/*
		 * none of the above... we will add the combining character as
		 * a base character.
		 */
		used = False;
	    }

	    if (used) {
		if (!screen->scroll_amt)
		    ScrnUpdate(xw, use_row, use_col, 1, 1, 1);
		continue;
	    }
	}
#endif

	/* Intercept characters for printer controller mode */
	if (PrinterOf(screen).printer_controlmode == 2) {
	    if ((c = (unsigned) xtermPrinterControl(xw, (int) c)) == 0)
		continue;
	}

	/*
	 * VT52 is a little ugly in the one place it has a parameterized
	 * control sequence, since the parameter falls after the character
	 * that denotes the type of sequence.
	 */
#if OPT_VT52_MODE
	if (sp->vt52_cup) {
	    if (nparam < NPARAM - 1) {
		SetParam(nparam++, (int) (c & 0x7f) - 32);
		parms.is_sub[nparam] = 0;
	    }
	    if (nparam < 2)
		continue;
	    sp->vt52_cup = False;
	    CursorSet(screen, zero_if_default(0), zero_if_default(1), xw->flags);
	    sp->parsestate = vt52_table;
	    SetParam(0, 0);
	    SetParam(1, 0);
	    continue;
	}
#endif

	laststate = sp->nextstate;
	if (c == ANSI_DEL
	    && sp->parsestate == sp->groundtable
	    && sp->scssize == 96
	    && sp->scstype != 0) {
	    /*
	     * Handle special case of shifts for 96-character sets by checking
	     * if we have a DEL.  The other special case for SPACE will always
	     * be printable.
	     */
	    sp->nextstate = CASE_PRINT;
	} else
#if OPT_WIDE_CHARS
	if (c > 255) {
	    /*
	     * The parsing tables all have 256 entries.  If we're supporting
	     * wide characters, we handle them by treating them the same as
	     * printing characters.
	     */
	    if (sp->parsestate == sp->groundtable) {
		sp->nextstate = CASE_PRINT;
	    } else if (sp->parsestate == sos_table) {
		c &= 0xffff;
		if (c > 255) {
		    TRACE(("Found code > 255 while in SOS state: %04X\n", c));
		    c = '?';
		}
	    } else {
		sp->nextstate = CASE_GROUND_STATE;
	    }
	} else
#endif
	    sp->nextstate = sp->parsestate[E2A(c)];

#if OPT_BROKEN_OSC
	/*
	 * Linux console palette escape sequences start with an OSC, but do
	 * not terminate correctly.  Some scripts do not check before writing
	 * them, making xterm appear to hang (it's awaiting a valid string
	 * terminator).  Just ignore these if we see them - there's no point
	 * in emulating bad code.
	 */
	if (screen->brokenLinuxOSC
	    && sp->parsestate == sos_table) {
	    if (sp->string_used) {
		switch (sp->string_area[0]) {
		case 'P':
		    if (sp->string_used <= 7)
			break;
		    /* FALLTHRU */
		case 'R':
		    illegal_parse(xw, c, sp);
		    TRACE(("Reset to ground state (brokenLinuxOSC)\n"));
		    break;
		}
	    }
	}
#endif

#if OPT_BROKEN_ST
	/*
	 * Before patch #171, carriage control embedded within an OSC string
	 * would terminate it.  Some (buggy, of course) applications rely on
	 * this behavior.  Accommodate them by allowing one to compile xterm
	 * and emulate the old behavior.
	 */
	if (screen->brokenStringTerm
	    && sp->parsestate == sos_table
	    && c < 32) {
	    switch (c) {
	    case ANSI_EOT:	/* FALLTHRU */
	    case ANSI_BS:	/* FALLTHRU */
	    case ANSI_HT:	/* FALLTHRU */
	    case ANSI_LF:	/* FALLTHRU */
	    case ANSI_VT:	/* FALLTHRU */
	    case ANSI_FF:	/* FALLTHRU */
	    case ANSI_CR:	/* FALLTHRU */
	    case ANSI_SO:	/* FALLTHRU */
	    case ANSI_SI:	/* FALLTHRU */
	    case ANSI_XON:	/* FALLTHRU */
	    case ANSI_CAN:
		illegal_parse(xw, c, sp);
		TRACE(("Reset to ground state (brokenStringTerm)\n"));
		break;
	    }
	}
#endif

#if OPT_C1_PRINT
	/*
	 * This is not completely foolproof, but will allow an application
	 * with values in the C1 range to use them as printable characters,
	 * provided that they are not intermixed with an escape sequence.
	 */
	if (screen->c1_printable
	    && (c >= 128 && c < 256)) {
	    sp->nextstate = (sp->parsestate == esc_table
			     ? CASE_ESC_IGNORE
			     : sp->parsestate[E2A(160)]);
	    TRACE(("allowC1Printable %04X %s ->%s\n",
		   c, which_table(sp->parsestate),
		   visibleVTparse(sp->nextstate)));
	}
#endif

#if OPT_WIDE_CHARS
	/*
	 * If we have a C1 code and the c1_printable flag is not set, simply
	 * ignore it when it was translated from UTF-8.  That is because the
	 * value could not have been present as-is in the UTF-8.
	 *
	 * To see that CASE_IGNORE is a consistent value, note that it is
	 * always used for NUL and other uninteresting C0 controls.
	 */
#if OPT_C1_PRINT
	if (!screen->c1_printable)
#endif
	    if (screen->wide_chars
		&& (c >= 128 && c < 160)) {
		sp->nextstate = CASE_IGNORE;
	    }

	/*
	 * If this character is a different width than the last one, put the
	 * previous text into the buffer and draw it now.
	 */
	this_is_wide = isWide((int) c);
	if (this_is_wide != sp->last_was_wide) {
	    WriteNow();
	}
#endif

	/*
	 * Accumulate string for printable text.  This may be 8/16-bit
	 * characters.
	 */
	if (sp->nextstate == CASE_PRINT) {
	    SafeAlloc(IChar, sp->print_area, sp->print_used, sp->print_size);
	    if (new_string == 0) {
		xtermWarning("Cannot allocate %lu bytes for printable text\n",
			     (unsigned long) new_length);
		continue;
	    }
	    SafeFree(sp->print_area, sp->print_size);
#if OPT_VT52_MODE
	    /*
	     * Strip output text to 7-bits for VT52.  We should do this for
	     * VT100 also (which is a 7-bit device), but xterm has been
	     * doing this for so long we shouldn't change this behavior.
	     */
	    if (screen->vtXX_level < 1)
		c &= 0x7f;
#endif
	    sp->print_area[sp->print_used++] = (IChar) c;
	    sp->lastchar = thischar = (int) c;
#if OPT_WIDE_CHARS
	    sp->last_was_wide = this_is_wide;
#endif
	    if (morePtyData(screen, VTbuffer)) {
		continue;
	    }
	}

	if (sp->nextstate == CASE_PRINT
	    || (laststate == CASE_PRINT && sp->print_used)) {
	    WriteNow();
	}

	/*
	 * Accumulate string for APC, DCS, PM, OSC, SOS controls
	 * This should always be 8-bit characters.
	 */
	if (sp->parsestate == sos_table) {
	    SafeAlloc(Char, sp->string_area, sp->string_used, sp->string_size);
	    if (new_string == 0) {
		xtermWarning("Cannot allocate %lu bytes for string mode %d\n",
			     (unsigned long) new_length, sp->string_mode);
		continue;
	    }
	    SafeFree(sp->string_area, sp->string_size);
#if OPT_WIDE_CHARS
	    /*
	     * We cannot display codes above 255, but let's try to
	     * accommodate the application a little by not aborting the
	     * string.
	     */
	    if ((c & 0xffff) > 255) {
		sp->nextstate = CASE_PRINT;
		c = '?';
	    }
#endif
	    sp->string_area[(sp->string_used)++] = CharOf(c);
	} else if (sp->parsestate != esc_table) {
	    /* if we were accumulating, we're not any more */
	    sp->string_mode = 0;
	    sp->string_used = 0;
	}

	DumpParams();
	TRACE(("parse %04X -> %s %s (used=%lu)\n",
	       c, visibleVTparse(sp->nextstate),
	       which_table(sp->parsestate),
	       (unsigned long) sp->string_used));

	/*
	 * If the parameter list has subparameters (tokens separated by ":")
	 * reject any controls that do not accept subparameters.
	 */
	if (parms.has_subparams) {
	    switch (sp->nextstate) {
	    case CASE_GROUND_STATE:
	    case CASE_CSI_IGNORE:
		/* FALLTHRU */

	    case CASE_ESC_DIGIT:
	    case CASE_ESC_SEMI:
	    case CASE_ESC_COLON:
		/* these states are required to parse parameter lists */
		break;

	    case CASE_SGR:
		TRACE(("...possible subparam usage\n"));
		break;

	    case CASE_CSI_DEC_DOLLAR_STATE:
	    case CASE_CSI_DOLLAR_STATE:
	    case CASE_CSI_EX_STATE:
	    case CASE_CSI_QUOTE_STATE:
	    case CASE_CSI_SPACE_STATE:
	    case CASE_CSI_STAR_STATE:
	    case CASE_CSI_TICK_STATE:
	    case CASE_DEC2_STATE:
	    case CASE_DEC3_STATE:
	    case CASE_DEC_STATE:
		/* use this branch when we do not yet have the final character */
		TRACE(("...unexpected subparam usage\n"));
		ParamsDone();
		sp->nextstate = CASE_CSI_IGNORE;
		break;

	    default:
		/* use this branch for cases where we have the final character
		 * in the table that processed the parameter list.
		 */
		TRACE(("...unexpected subparam usage\n"));
		ResetState(sp);
		continue;
	    }
	}

	if (xw->work.palette_changed) {
	    repaintWhenPaletteChanged(xw, sp);
	}

	switch (sp->nextstate) {
	case CASE_PRINT:
	    TRACE(("CASE_PRINT - printable characters\n"));
	    break;

	case CASE_GROUND_STATE:
	    TRACE(("CASE_GROUND_STATE - exit ignore mode\n"));
	    ResetState(sp);
	    break;

	case CASE_IGNORE:
	    TRACE(("CASE_IGNORE - Ignore character %02X\n", c));
	    break;

	case CASE_ENQ:
	    TRACE(("CASE_ENQ - answerback\n"));
	    for (count = 0; screen->answer_back[count] != 0; count++)
		unparseputc(xw, screen->answer_back[count]);
	    unparse_end(xw);
	    break;

	case CASE_BELL:
	    TRACE(("CASE_BELL - bell\n"));
	    if (sp->string_mode == ANSI_OSC) {
		if (sp->string_used)
		    sp->string_area[--(sp->string_used)] = '\0';
		do_osc(xw, sp->string_area, sp->string_used, (int) c);
		ResetState(sp);
	    } else {
		/* bell */
		Bell(xw, XkbBI_TerminalBell, 0);
	    }
	    break;

	case CASE_BS:
	    TRACE(("CASE_BS - backspace\n"));
	    CursorBack(xw, 1);
	    break;

	case CASE_CR:
	    TRACE(("CASE_CR\n"));
	    CarriageReturn(xw);
	    break;

	case CASE_ESC:
	    if_OPT_VT52_MODE(screen, {
		sp->parsestate = vt52_esc_table;
		break;
	    });
	    sp->parsestate = esc_table;
	    break;

#if OPT_VT52_MODE
	case CASE_VT52_CUP:
	    TRACE(("CASE_VT52_CUP - VT52 cursor addressing\n"));
	    sp->vt52_cup = True;
	    InitParams();
	    break;

	case CASE_VT52_IGNORE:
	    TRACE(("CASE_VT52_IGNORE - VT52 ignore-character\n"));
	    sp->parsestate = vt52_ignore_table;
	    break;
#endif

	case CASE_VMOT:
	    TRACE(("CASE_VMOT\n"));
	    /*
	     * form feed, line feed, vertical tab
	     */
	    xtermAutoPrint(xw, c);
	    xtermIndex(xw, 1);
	    if (xw->flags & LINEFEED)
		CarriageReturn(xw);
	    else
		do_xevents();
	    break;

	case CASE_CBT:
	    TRACE(("CASE_CBT\n"));
	    /* cursor backward tabulation */
	    count = one_if_default(0);
	    while ((count-- > 0)
		   && (TabToPrevStop(xw))) ;
	    ResetState(sp);
	    break;

	case CASE_CHT:
	    TRACE(("CASE_CHT\n"));
	    /* cursor forward tabulation */
	    count = one_if_default(0);
	    while ((count-- > 0)
		   && (TabToNextStop(xw))) ;
	    ResetState(sp);
	    break;

	case CASE_TAB:
	    /* tab */
	    TabToNextStop(xw);
	    break;

	case CASE_SI:
	    screen->curgl = 0;
	    if_OPT_VT52_MODE(screen, {
		ResetState(sp);
	    });
	    break;

	case CASE_SO:
	    screen->curgl = 1;
	    if_OPT_VT52_MODE(screen, {
		ResetState(sp);
	    });
	    break;

	case CASE_DECDHL:
	    xterm_DECDHL(xw, c == '3');
	    ResetState(sp);
	    break;

	case CASE_DECSWL:
	    xterm_DECSWL(xw);
	    ResetState(sp);
	    break;

	case CASE_DECDWL:
	    xterm_DECDWL(xw);
	    ResetState(sp);
	    break;

	case CASE_SCR_STATE:
	    /* enter scr state */
	    sp->parsestate = scrtable;
	    break;

	case CASE_SCS0_STATE:
	    /* enter scs state 0 */
	    select_charset(sp, 0, 94);
	    break;

	case CASE_SCS1_STATE:
	    /* enter scs state 1 */
	    select_charset(sp, 1, 94);
	    break;

	case CASE_SCS2_STATE:
	    /* enter scs state 2 */
	    select_charset(sp, 2, 94);
	    break;

	case CASE_SCS3_STATE:
	    /* enter scs state 3 */
	    select_charset(sp, 3, 94);
	    break;

	case CASE_SCS1A_STATE:
	    /* enter scs state 1 */
	    select_charset(sp, 1, 96);
	    break;

	case CASE_SCS2A_STATE:
	    /* enter scs state 2 */
	    select_charset(sp, 2, 96);
	    break;

	case CASE_SCS3A_STATE:
	    /* enter scs state 3 */
	    select_charset(sp, 3, 96);
	    break;

	case CASE_ESC_IGNORE:
	    /* unknown escape sequence */
	    sp->parsestate = eigtable;
	    break;

	case CASE_ESC_DIGIT:
	    /* digit in csi or dec mode */
	    if (nparam > 0) {
		value = zero_if_default(nparam - 1);
		SetParam(nparam - 1, (10 * value) + ((int) c - '0'));
		if (GetParam(nparam - 1) > 65535)
		    SetParam(nparam - 1, 65535);
		if (sp->parsestate == csi_table)
		    sp->parsestate = csi2_table;
	    }
	    break;

	case CASE_ESC_SEMI:
	    /* semicolon in csi or dec mode */
	    if (nparam < NPARAM) {
		parms.is_sub[nparam] = 0;
		SetParam(nparam++, DEFAULT);
	    }
	    if (sp->parsestate == csi_table)
		sp->parsestate = csi2_table;
	    break;

	    /*
	     * A _few_ commands accept colon-separated subparameters.
	     * Mark the parameter list so that we can exclude (most) bogus
	     * commands with simple/fast checks.
	     */
	case CASE_ESC_COLON:
	    if (nparam < NPARAM) {
		parms.has_subparams = 1;
		if (nparam == 0) {
		    parms.is_sub[nparam] = 1;
		    SetParam(nparam++, DEFAULT);
		} else if (parms.is_sub[nparam - 1] == 0) {
		    parms.is_sub[nparam - 1] = 1;
		    parms.is_sub[nparam] = 2;
		    parms.params[nparam] = 0;
		    ++nparam;
		} else {
		    parms.is_sub[nparam] = 1 + parms.is_sub[nparam - 1];
		    parms.params[nparam] = 0;
		    ++nparam;
		}
	    }
	    break;

	case CASE_DEC_STATE:
	    /* enter dec mode */
	    sp->parsestate = dec_table;
	    break;

	case CASE_DEC2_STATE:
	    /* enter dec2 mode */
	    sp->parsestate = dec2_table;
	    break;

	case CASE_DEC3_STATE:
	    /* enter dec3 mode */
	    sp->parsestate = dec3_table;
	    break;

	case CASE_ICH:
	    TRACE(("CASE_ICH - insert char\n"));
	    InsertChar(xw, (unsigned) one_if_default(0));
	    ResetState(sp);
	    break;

	case CASE_CUU:
	    TRACE(("CASE_CUU - cursor up\n"));
	    CursorUp(screen, one_if_default(0));
	    ResetState(sp);
	    break;

	case CASE_CUD:
	    TRACE(("CASE_CUD - cursor down\n"));
	    CursorDown(screen, one_if_default(0));
	    ResetState(sp);
	    break;

	case CASE_CUF:
	    TRACE(("CASE_CUF - cursor forward\n"));
	    CursorForward(xw, one_if_default(0));
	    ResetState(sp);
	    break;

	case CASE_CUB:
	    TRACE(("CASE_CUB - cursor backward\n"));
	    CursorBack(xw, one_if_default(0));
	    ResetState(sp);
	    break;

	case CASE_CUP:
	    TRACE(("CASE_CUP - cursor position\n"));
	    if_OPT_XMC_GLITCH(screen, {
		Jump_XMC(xw);
	    });
	    CursorSet(screen, one_if_default(0) - 1, one_if_default(1) - 1, xw->flags);
	    ResetState(sp);
	    break;

	case CASE_VPA:
	    TRACE(("CASE_VPA - vertical position absolute\n"));
	    CursorSet(screen, one_if_default(0) - 1, CursorCol(xw), xw->flags);
	    ResetState(sp);
	    break;

	case CASE_HPA:
	    TRACE(("CASE_HPA - horizontal position absolute\n"));
	    CursorSet(screen, CursorRow(xw), one_if_default(0) - 1, xw->flags);
	    ResetState(sp);
	    break;

	case CASE_VPR:
	    TRACE(("CASE_VPR - vertical position relative\n"));
	    CursorSet(screen,
		      CursorRow(xw) + one_if_default(0),
		      CursorCol(xw),
		      xw->flags);
	    ResetState(sp);
	    break;

	case CASE_HPR:
	    TRACE(("CASE_HPR - horizontal position relative\n"));
	    CursorSet(screen,
		      CursorRow(xw),
		      CursorCol(xw) + one_if_default(0),
		      xw->flags);
	    ResetState(sp);
	    break;

	case CASE_HP_BUGGY_LL:
	    TRACE(("CASE_HP_BUGGY_LL\n"));
	    /* Some HP-UX applications have the bug that they
	       assume ESC F goes to the lower left corner of
	       the screen, regardless of what terminfo says. */
	    if (screen->hp_ll_bc)
		CursorSet(screen, screen->max_row, 0, xw->flags);
	    ResetState(sp);
	    break;

	case CASE_ED:
	    TRACE(("CASE_ED - erase display\n"));
	    do_cd_xtra_scroll(xw);
	    do_erase_display(xw, zero_if_default(0), OFF_PROTECT);
	    ResetState(sp);
	    break;

	case CASE_EL:
	    TRACE(("CASE_EL - erase line\n"));
	    do_erase_line(xw, zero_if_default(0), OFF_PROTECT);
	    ResetState(sp);
	    break;

	case CASE_ECH:
	    TRACE(("CASE_ECH - erase char\n"));
	    /* ECH */
	    ClearRight(xw, one_if_default(0));
	    ResetState(sp);
	    break;

	case CASE_IL:
	    TRACE(("CASE_IL - insert line\n"));
	    set_cur_col(screen, ScrnLeftMargin(xw));
	    InsertLine(xw, one_if_default(0));
	    ResetState(sp);
	    break;

	case CASE_DL:
	    TRACE(("CASE_DL - delete line\n"));
	    set_cur_col(screen, ScrnLeftMargin(xw));
	    DeleteLine(xw, one_if_default(0));
	    ResetState(sp);
	    break;

	case CASE_DCH:
	    TRACE(("CASE_DCH - delete char\n"));
	    DeleteChar(xw, (unsigned) one_if_default(0));
	    ResetState(sp);
	    break;

	case CASE_TRACK_MOUSE:
	    /*
	     * A single parameter other than zero is always scroll-down.
	     * A zero-parameter is used to reset the mouse mode, and is
	     * not useful for scrolling anyway.
	     */
	    if (nparam > 1 || GetParam(0) == 0) {
		CELL start;

		TRACE(("CASE_TRACK_MOUSE\n"));
		/* Track mouse as long as in window and between
		 * specified rows
		 */
		start.row = one_if_default(2) - 1;
		start.col = GetParam(1) - 1;
		TrackMouse(xw,
			   GetParam(0),
			   &start,
			   GetParam(3) - 1, GetParam(4) - 2);
	    } else {
		TRACE(("CASE_SD - scroll down\n"));
		/* SD */
		RevScroll(xw, one_if_default(0));
		do_xevents();
	    }
	    ResetState(sp);
	    break;

	case CASE_DECID:
	    TRACE(("CASE_DECID\n"));
	    if_OPT_VT52_MODE(screen, {
		unparseputc(xw, ANSI_ESC);
		unparseputc(xw, '/');
		unparseputc(xw, 'Z');
		unparse_end(xw);
		ResetState(sp);
		break;
	    });
	    SetParam(0, DEFAULT);	/* Default ID parameter */
	    /* FALLTHRU */
	case CASE_DA1:
	    TRACE(("CASE_DA1\n"));
	    if (GetParam(0) <= 0) {	/* less than means DEFAULT */
		count = 0;
		init_reply(ANSI_CSI);
		reply.a_pintro = '?';

		/*
		 * The first parameter corresponds to the highest operating
		 * level (i.e., service level) of the emulation.  A DEC
		 * terminal can be setup to respond with a different DA
		 * response, but there's no control sequence that modifies
		 * this.  We set it via a resource.
		 */
		if (screen->terminal_id < 200) {
		    switch (screen->terminal_id) {
		    case 125:
			reply.a_param[count++] = 12;	/* VT125 */
#if OPT_REGIS_GRAPHICS
			reply.a_param[count++] = 0 | 2 | 1;	/* no STP, AVO, GPO (ReGIS) */
#else
			reply.a_param[count++] = 0 | 2 | 0;	/* no STP, AVO, no GPO (ReGIS) */
#endif
			reply.a_param[count++] = 0;	/* no printer */
			reply.a_param[count++] = XTERM_PATCH;	/* ROM version */
			break;
		    case 102:
			reply.a_param[count++] = 6;	/* VT102 */
			break;
		    case 101:
			reply.a_param[count++] = 1;	/* VT101 */
			reply.a_param[count++] = 0;	/* no options */
			break;
		    default:	/* VT100 */
			reply.a_param[count++] = 1;	/* VT100 */
			reply.a_param[count++] = 0 | 2 | 0;	/* no STP, AVO, no GPO (ReGIS) */
			break;
		    }
		} else {
		    reply.a_param[count++] = (ParmType) (60
							 + screen->terminal_id
							 / 100);
		    reply.a_param[count++] = 1;		/* 132-columns */
		    reply.a_param[count++] = 2;		/* printer */
#if OPT_REGIS_GRAPHICS
		    if (screen->terminal_id == 240 ||
			screen->terminal_id == 241 ||
			screen->terminal_id == 330 ||
			screen->terminal_id == 340) {
			reply.a_param[count++] = 3;	/* ReGIS graphics */
		    }
#endif
#if OPT_SIXEL_GRAPHICS
		    if (screen->terminal_id == 240 ||
			screen->terminal_id == 241 ||
			screen->terminal_id == 330 ||
			screen->terminal_id == 340 ||
			screen->terminal_id == 382) {
			reply.a_param[count++] = 4;	/* sixel graphics */
		    }
#endif
		    reply.a_param[count++] = 6;		/* selective-erase */
#if OPT_SUNPC_KBD
		    if (xw->keyboard.type == keyboardIsVT220)
#endif
			reply.a_param[count++] = 8;	/* user-defined-keys */
		    reply.a_param[count++] = 9;		/* national replacement charsets */
		    reply.a_param[count++] = 15;	/* technical characters */
		    if (screen->terminal_id >= 400) {
			reply.a_param[count++] = 18;	/* windowing capability */
			reply.a_param[count++] = 21;	/* horizontal scrolling */
		    }
		    if_OPT_ISO_COLORS(screen, {
			reply.a_param[count++] = 22;	/* ANSI color, VT525 */
		    });
#if OPT_DEC_LOCATOR
		    reply.a_param[count++] = 29;	/* ANSI text locator */
#endif
		}
		reply.a_nparam = (ParmType) count;
		reply.a_inters = 0;
		reply.a_final = 'c';
		unparseseq(xw, &reply);
	    }
	    ResetState(sp);
	    break;

	case CASE_DA2:
	    TRACE(("CASE_DA2\n"));
	    if (GetParam(0) <= 0) {	/* less than means DEFAULT */
		count = 0;
		init_reply(ANSI_CSI);
		reply.a_pintro = '>';

		if (screen->terminal_id >= 200) {
		    switch (screen->terminal_id) {
		    case 220:
		    default:
			reply.a_param[count++] = 1;	/* VT220 */
			break;
		    case 240:
			/* http://www.decuslib.com/DECUS/vax87a/gendyn/vt200_kind.lis */
			reply.a_param[count++] = 2;	/* VT240 */
			break;
		    case 320:
			/* http://www.vt100.net/docs/vt320-uu/appendixe.html */
			reply.a_param[count++] = 24;	/* VT320 */
			break;
		    case 330:
			reply.a_param[count++] = 18;	/* VT330 */
			break;
		    case 340:
			reply.a_param[count++] = 19;	/* VT340 */
			break;
		    case 420:
			reply.a_param[count++] = 41;	/* VT420 */
			break;
		    case 510:
			/* http://www.vt100.net/docs/vt510-rm/DA2 */
			reply.a_param[count++] = 61;	/* VT510 */
			break;
		    case 520:
			reply.a_param[count++] = 64;	/* VT520 */
			break;
		    case 525:
			reply.a_param[count++] = 65;	/* VT525 */
			break;
		    }
		} else {
		    reply.a_param[count++] = 0;		/* VT100 (nonstandard) */
		}
		reply.a_param[count++] = XTERM_PATCH;	/* Version */
		reply.a_param[count++] = 0;	/* options (none) */
		reply.a_nparam = (ParmType) count;
		reply.a_inters = 0;
		reply.a_final = 'c';
		unparseseq(xw, &reply);
	    }
	    ResetState(sp);
	    break;

	case CASE_DECRPTUI:
	    TRACE(("CASE_DECRPTUI\n"));
	    if ((screen->vtXX_level >= 4)
		&& (GetParam(0) <= 0)) {	/* less than means DEFAULT */
		unparseputc1(xw, ANSI_DCS);
		unparseputc(xw, '!');
		unparseputc(xw, '|');
		unparseputc(xw, '0');
		unparseputc1(xw, ANSI_ST);
		unparse_end(xw);
	    }
	    ResetState(sp);
	    break;

	case CASE_TBC:
	    TRACE(("CASE_TBC - tab clear\n"));
	    if ((value = GetParam(0)) <= 0)	/* less than means default */
		TabClear(xw->tabs, screen->cur_col);
	    else if (value == 3)
		TabZonk(xw->tabs);
	    ResetState(sp);
	    break;

	case CASE_SET:
	    TRACE(("CASE_SET - set mode\n"));
	    ansi_modes(xw, bitset);
	    ResetState(sp);
	    break;

	case CASE_RST:
	    TRACE(("CASE_RST - reset mode\n"));
	    ansi_modes(xw, bitclr);
	    ResetState(sp);
	    break;

	case CASE_SGR:
	    for (item = 0; item < nparam; ++item) {
		int op = GetParam(item);

		if_OPT_XMC_GLITCH(screen, {
		    Mark_XMC(xw, op);
		});
		TRACE(("CASE_SGR %d\n", op));

		/*
		 * Only SGR 38/48 accept subparameters, and in those cases
		 * the values will not be seen at this point.
		 */
		if (param_has_subparams(item)) {
		    switch (op) {
		    case 38:
			/* FALLTHRU */
		    case 48:
			if_OPT_ISO_COLORS(screen, {
			    break;
			});
			/* FALLTHRU */
		    default:
			TRACE(("...unexpected subparameter in SGR\n"));
			op = 9999;
			ResetState(sp);
			break;
		    }
		}

		switch (op) {
		case DEFAULT:
		    /* FALLTHRU */
		case 0:
#if OPT_WIDE_ATTRS
		    setItalicFont(xw, False);
#endif
		    UIntClr(xw->flags,
			    (SGR_MASK | SGR_MASK2 | INVISIBLE));
		    if_OPT_ISO_COLORS(screen, {
			reset_SGR_Colors(xw);
		    });
		    break;
		case 1:	/* Bold                 */
		    UIntSet(xw->flags, BOLD);
		    if_OPT_ISO_COLORS(screen, {
			setExtendedFG(xw);
		    });
		    break;
#if OPT_WIDE_ATTRS
		case 2:	/* faint, decreased intensity or second colour */
		    UIntSet(xw->flags, ATR_FAINT);
		    if_OPT_ISO_COLORS(screen, {
			setExtendedFG(xw);
		    });
		    break;
		case 3:	/* italicized */
		    setItalicFont(xw, UseItalicFont(screen));
		    UIntSet(xw->flags, ATR_ITALIC);
		    if_OPT_ISO_COLORS(screen, {
			setExtendedFG(xw);
		    });
		    break;
#endif
		case 4:	/* Underscore           */
		    UIntSet(xw->flags, UNDERLINE);
		    if_OPT_ISO_COLORS(screen, {
			setExtendedFG(xw);
		    });
		    break;
		case 5:	/* Blink                */
		    UIntSet(xw->flags, BLINK);
		    StartBlinking(screen);
		    if_OPT_ISO_COLORS(screen, {
			setExtendedFG(xw);
		    });
		    break;
		case 7:
		    UIntSet(xw->flags, INVERSE);
		    if_OPT_ISO_COLORS(screen, {
			setExtendedBG(xw);
		    });
		    break;
		case 8:
		    UIntSet(xw->flags, INVISIBLE);
		    break;
#if OPT_WIDE_ATTRS
		case 9:	/* crossed-out characters */
		    UIntSet(xw->flags, ATR_STRIKEOUT);
		    break;
#endif
#if OPT_WIDE_ATTRS
		case 21:	/* doubly-underlined */
		    UIntSet(xw->flags, ATR_DBL_UNDER);
		    break;
#endif
		case 22:	/* reset 'bold' */
		    UIntClr(xw->flags, BOLD);
#if OPT_WIDE_ATTRS
		    UIntClr(xw->flags, ATR_FAINT);
#endif
		    if_OPT_ISO_COLORS(screen, {
			setExtendedFG(xw);
		    });
		    break;
#if OPT_WIDE_ATTRS
		case 23:	/* not italicized */
		    setItalicFont(xw, False);
		    UIntClr(xw->flags, ATR_ITALIC);
		    if_OPT_ISO_COLORS(screen, {
			setExtendedFG(xw);
		    });
		    break;
#endif
		case 24:
		    UIntClr(xw->flags, UNDERLINE);
#if OPT_WIDE_ATTRS
		    UIntClr(xw->flags, ATR_DBL_UNDER);
#endif
		    if_OPT_ISO_COLORS(screen, {
			setExtendedFG(xw);
		    });
		    break;
		case 25:	/* reset 'blink' */
		    UIntClr(xw->flags, BLINK);
		    if_OPT_ISO_COLORS(screen, {
			setExtendedFG(xw);
		    });
		    break;
		case 27:
		    UIntClr(xw->flags, INVERSE);
		    if_OPT_ISO_COLORS(screen, {
			setExtendedBG(xw);
		    });
		    break;
		case 28:
		    UIntClr(xw->flags, INVISIBLE);
		    break;
#if OPT_WIDE_ATTRS
		case 29:	/* not crossed out */
		    UIntClr(xw->flags, ATR_STRIKEOUT);
		    break;
#endif
		case 30:
		    /* FALLTHRU */
		case 31:
		    /* FALLTHRU */
		case 32:
		    /* FALLTHRU */
		case 33:
		    /* FALLTHRU */
		case 34:
		    /* FALLTHRU */
		case 35:
		    /* FALLTHRU */
		case 36:
		    /* FALLTHRU */
		case 37:
		    if_OPT_ISO_COLORS(screen, {
			xw->sgr_foreground = (op - 30);
			xw->sgr_extended = False;
			setExtendedFG(xw);
		    });
		    break;
		case 38:
		    /* This is more complicated than I'd like, but it should
		     * properly eat all the parameters for unsupported modes.
		     */
		    if_OPT_ISO_COLORS(screen, {
			if (parse_extended_colors(xw, &value, &item)) {
			    xw->sgr_foreground = value;
			    xw->sgr_extended = True;
			    setExtendedFG(xw);
			}
		    });
		    break;
		case 39:
		    if_OPT_ISO_COLORS(screen, {
			reset_SGR_Foreground(xw);
		    });
		    break;
		case 40:
		    /* FALLTHRU */
		case 41:
		    /* FALLTHRU */
		case 42:
		    /* FALLTHRU */
		case 43:
		    /* FALLTHRU */
		case 44:
		    /* FALLTHRU */
		case 45:
		    /* FALLTHRU */
		case 46:
		    /* FALLTHRU */
		case 47:
		    if_OPT_ISO_COLORS(screen, {
			xw->sgr_background = (op - 40);
			setExtendedBG(xw);
		    });
		    break;
		case 48:
		    if_OPT_ISO_COLORS(screen, {
			if (parse_extended_colors(xw, &value, &item)) {
			    xw->sgr_background = value;
			    setExtendedBG(xw);
			}
		    });
		    break;
		case 49:
		    if_OPT_ISO_COLORS(screen, {
			reset_SGR_Background(xw);
		    });
		    break;
		case 90:
		    /* FALLTHRU */
		case 91:
		    /* FALLTHRU */
		case 92:
		    /* FALLTHRU */
		case 93:
		    /* FALLTHRU */
		case 94:
		    /* FALLTHRU */
		case 95:
		    /* FALLTHRU */
		case 96:
		    /* FALLTHRU */
		case 97:
		    if_OPT_AIX_COLORS(screen, {
			xw->sgr_foreground = (op - 90 + 8);
			xw->sgr_extended = False;
			setExtendedFG(xw);
		    });
		    break;
		case 100:
#if !OPT_AIX_COLORS
		    if_OPT_ISO_COLORS(screen, {
			reset_SGR_Foreground(xw);
			reset_SGR_Background(xw);
		    });
		    break;
#endif
		case 101:
		    /* FALLTHRU */
		case 102:
		    /* FALLTHRU */
		case 103:
		    /* FALLTHRU */
		case 104:
		    /* FALLTHRU */
		case 105:
		    /* FALLTHRU */
		case 106:
		    /* FALLTHRU */
		case 107:
		    if_OPT_AIX_COLORS(screen, {
			xw->sgr_background = (op - 100 + 8);
			setExtendedBG(xw);
		    });
		    break;
		}
	    }
	    ResetState(sp);
	    break;

	    /* DSR (except for the '?') is a superset of CPR */
	case CASE_DSR:
	    sp->private_function = True;

	    /* FALLTHRU */
	case CASE_CPR:
	    TRACE(("CASE_DSR - device status report\n"));
	    count = 0;
	    init_reply(ANSI_CSI);
	    reply.a_pintro = CharOf(sp->private_function ? '?' : 0);
	    reply.a_inters = 0;
	    reply.a_final = 'n';

	    switch (GetParam(0)) {
	    case 5:
		TRACE(("...request operating status\n"));
		/* operating status */
		reply.a_param[count++] = 0;	/* (no malfunction ;-) */
		break;
	    case 6:
		TRACE(("...request %s\n",
		       (sp->private_function
			? "DECXCPR"
			: "CPR")));
		/* CPR */
		/* DECXCPR (with page=1) */
		value = (screen->cur_row + 1);
		if ((xw->flags & ORIGIN) != 0) {
		    value -= screen->top_marg;
		}
		reply.a_param[count++] = (ParmType) value;

		value = (screen->cur_col + 1);
		if ((xw->flags & ORIGIN) != 0) {
		    value -= screen->lft_marg;
		}
		reply.a_param[count++] = (ParmType) value;

		if (sp->private_function
		    && screen->vtXX_level >= 4) {	/* VT420 */
		    reply.a_param[count++] = 1;
		}
		reply.a_final = 'R';
		break;
	    case 15:
		TRACE(("...request printer status\n"));
		if (sp->private_function
		    && screen->vtXX_level >= 2) {	/* VT220 */
		    reply.a_param[count++] = 13;	/* no printer detected */
		}
		break;
	    case 25:
		TRACE(("...request UDK status\n"));
		if (sp->private_function
		    && screen->vtXX_level >= 2) {	/* VT220 */
		    reply.a_param[count++] = 20;	/* UDK always unlocked */
		}
		break;
	    case 26:
		TRACE(("...request keyboard status\n"));
		if (sp->private_function
		    && screen->vtXX_level >= 2) {	/* VT220 */
		    reply.a_param[count++] = 27;
		    reply.a_param[count++] = 1;		/* North American */
		    if (screen->vtXX_level >= 4) {	/* VT420 */
			reply.a_param[count++] = 0;	/* ready */
			reply.a_param[count++] = 0;	/* LK201 */
		    }
		}
		break;
	    case 53:		/* according to existing xterm handling */
		/* FALLTHRU */
	    case 55:		/* according to the VT330/VT340 Text Programming Manual */
		TRACE(("...request locator status\n"));
		if (sp->private_function
		    && screen->vtXX_level >= 2) {	/* VT220 */
#if OPT_DEC_LOCATOR
		    reply.a_param[count++] = 50;	/* locator ready */
#else
		    reply.a_param[count++] = 53;	/* no locator */
#endif
		}
		break;
	    case 56:
		TRACE(("...request locator type\n"));
		if (sp->private_function
		    && screen->vtXX_level >= 3) {	/* VT330 (FIXME: what about VT220?) */
		    reply.a_param[count++] = 57;
#if OPT_DEC_LOCATOR
		    reply.a_param[count++] = 1;		/* mouse */
#else
		    reply.a_param[count++] = 0;		/* unknown */
#endif
		}
		break;
	    case 62:
		TRACE(("...request DECMSR - macro space\n"));
		if (sp->private_function
		    && screen->vtXX_level >= 4) {	/* VT420 */
		    reply.a_pintro = 0;
		    reply.a_radix[count] = 16;	/* no data */
		    reply.a_param[count++] = 0;		/* no space for macros */
		    reply.a_inters = '*';
		    reply.a_final = L_CURL;
		}
		break;
	    case 63:
		TRACE(("...request DECCKSR - memory checksum\n"));
		/* DECCKSR - Memory checksum */
		if (sp->private_function
		    && screen->vtXX_level >= 4) {	/* VT420 */
		    init_reply(ANSI_DCS);
		    reply.a_param[count++] = (ParmType) GetParam(1);	/* PID */
		    reply.a_delim = "!~";	/* delimiter */
		    reply.a_radix[count] = 16;	/* use hex */
		    reply.a_param[count++] = 0;		/* no data */
		}
		break;
	    case 75:
		TRACE(("...request data integrity\n"));
		if (sp->private_function
		    && screen->vtXX_level >= 4) {	/* VT420 */
		    reply.a_param[count++] = 70;	/* no errors */
		}
		break;
	    case 85:
		TRACE(("...request multi-session configuration\n"));
		if (sp->private_function
		    && screen->vtXX_level >= 4) {	/* VT420 */
		    reply.a_param[count++] = 83;	/* not configured */
		}
		break;
	    default:
		break;
	    }

	    if ((reply.a_nparam = (ParmType) count) != 0)
		unparseseq(xw, &reply);

	    ResetState(sp);
	    sp->private_function = False;
	    break;

	case CASE_MC:
	    TRACE(("CASE_MC - media control\n"));
	    xtermMediaControl(xw, GetParam(0), False);
	    ResetState(sp);
	    break;

	case CASE_DEC_MC:
	    TRACE(("CASE_DEC_MC - DEC media control\n"));
	    xtermMediaControl(xw, GetParam(0), True);
	    ResetState(sp);
	    break;

	case CASE_HP_MEM_LOCK:
	    /* FALLTHRU */
	case CASE_HP_MEM_UNLOCK:
	    TRACE(("%s\n", ((sp->parsestate[c] == CASE_HP_MEM_LOCK)
			    ? "CASE_HP_MEM_LOCK"
			    : "CASE_HP_MEM_UNLOCK")));
	    if (screen->scroll_amt)
		FlushScroll(xw);
	    if (sp->parsestate[c] == CASE_HP_MEM_LOCK)
		set_tb_margins(screen, screen->cur_row, screen->bot_marg);
	    else
		set_tb_margins(screen, 0, screen->bot_marg);
	    ResetState(sp);
	    break;

	case CASE_DECSTBM:
	    TRACE(("CASE_DECSTBM - set scrolling region\n"));
	    {
		int top;
		int bot;
		top = one_if_default(0);
		if (nparam < 2 || (bot = GetParam(1)) == DEFAULT
		    || bot > MaxRows(screen)
		    || bot == 0)
		    bot = MaxRows(screen);
		if (bot > top) {
		    if (screen->scroll_amt)
			FlushScroll(xw);
		    set_tb_margins(screen, top - 1, bot - 1);
		    CursorSet(screen, 0, 0, xw->flags);
		}
		ResetState(sp);
	    }
	    break;

	case CASE_DECREQTPARM:
	    TRACE(("CASE_DECREQTPARM\n"));
	    if (screen->terminal_id < 200) {	/* VT102 */
		value = zero_if_default(0);
		if (value == 0 || value == 1) {
		    init_reply(ANSI_CSI);
		    reply.a_pintro = 0;
		    reply.a_nparam = 7;
		    reply.a_param[0] = (ParmType) (value + 2);
		    reply.a_param[1] = 1;	/* no parity */
		    reply.a_param[2] = 1;	/* eight bits */
		    reply.a_param[3] = 128;	/* transmit 38.4k baud */
		    reply.a_param[4] = 128;	/* receive 38.4k baud */
		    reply.a_param[5] = 1;	/* clock multiplier ? */
		    reply.a_param[6] = 0;	/* STP flags ? */
		    reply.a_inters = 0;
		    reply.a_final = 'x';
		    unparseseq(xw, &reply);
		}
	    }
	    ResetState(sp);
	    break;

	case CASE_DECSET:
	    /* DECSET */
#if OPT_VT52_MODE
	    if (screen->vtXX_level != 0)
#endif
		dpmodes(xw, bitset);
	    ResetState(sp);
#if OPT_TEK4014
	    if (TEK4014_ACTIVE(xw)) {
		TRACE(("Tek4014 is now active...\n"));
		return False;
	    }
#endif
	    break;

	case CASE_DECRST:
	    /* DECRST */
	    dpmodes(xw, bitclr);
	    init_groundtable(screen, sp);
	    ResetState(sp);
	    break;

	case CASE_DECALN:
	    TRACE(("CASE_DECALN - alignment test\n"));
	    if (screen->cursor_state)
		HideCursor();
	    reset_margins(screen);
	    CursorSet(screen, 0, 0, xw->flags);
	    xtermParseRect(xw, 0, 0, &myRect);
	    ScrnFillRectangle(xw, &myRect, 'E', 0, False);
	    ResetState(sp);
	    break;

	case CASE_GSETS:
	    TRACE(("CASE_GSETS(%d) = '%c'\n", sp->scstype, c));
	    decode_scs(xw, sp->scstype, 0, (int) c);
	    ResetState(sp);
	    break;

	case CASE_ANSI_SC:
	    if (IsLeftRightMode(xw)) {
		int left;
		int right;

		TRACE(("CASE_DECSLRM - set left and right margin\n"));
		left = one_if_default(0);
		if (nparam < 2 || (right = GetParam(1)) == DEFAULT
		    || right > MaxCols(screen)
		    || right == 0)
		    right = MaxCols(screen);
		if (right > left) {
		    set_lr_margins(screen, left - 1, right - 1);
		    CursorSet(screen, 0, 0, xw->flags);
		}
	    } else {
		TRACE(("CASE_ANSI_SC - save cursor\n"));
		CursorSave(xw);
	    }
	    ResetState(sp);
	    break;

	case CASE_DECSC:
	    TRACE(("CASE_DECSC - save cursor\n"));
	    CursorSave(xw);
	    ResetState(sp);
	    break;

	case CASE_ANSI_RC:
	    /* FALLTHRU */
	case CASE_DECRC:
	    TRACE(("CASE_%sRC - restore cursor\n",
		   (sp->nextstate == CASE_DECRC) ? "DEC" : "ANSI_"));
	    CursorRestore(xw);
	    if_OPT_ISO_COLORS(screen, {
		setExtendedFG(xw);
	    });
	    ResetState(sp);
	    break;

	case CASE_DECKPAM:
	    TRACE(("CASE_DECKPAM\n"));
	    xw->keyboard.flags |= MODE_DECKPAM;
	    update_appkeypad();
	    ResetState(sp);
	    break;

	case CASE_DECKPNM:
	    TRACE(("CASE_DECKPNM\n"));
	    UIntClr(xw->keyboard.flags, MODE_DECKPAM);
	    update_appkeypad();
	    ResetState(sp);
	    break;

	case CASE_CSI_QUOTE_STATE:
	    sp->parsestate = csi_quo_table;
	    break;

#if OPT_BLINK_CURS
	case CASE_CSI_SPACE_STATE:
	    sp->parsestate = csi_sp_table;
	    break;

	case CASE_DECSCUSR:
	    TRACE(("CASE_DECSCUSR\n"));
	    {
		Boolean change = True;
		Boolean blinks = screen->cursor_blink_esc;

		HideCursor();

		switch (GetParam(0)) {
		case DEFAULT:
		    /* FALLTHRU */
		case DEFAULT_STYLE:
		    /* FALLTHRU */
		case BLINK_BLOCK:
		    blinks = True;
		    screen->cursor_shape = CURSOR_BLOCK;
		    break;
		case STEADY_BLOCK:
		    blinks = False;
		    screen->cursor_shape = CURSOR_BLOCK;
		    break;
		case BLINK_UNDERLINE:
		    blinks = True;
		    screen->cursor_shape = CURSOR_UNDERLINE;
		    break;
		case STEADY_UNDERLINE:
		    blinks = False;
		    screen->cursor_shape = CURSOR_UNDERLINE;
		    break;
		case BLINK_BAR:
		    blinks = True;
		    screen->cursor_shape = CURSOR_BAR;
		    break;
		case STEADY_BAR:
		    blinks = False;
		    screen->cursor_shape = CURSOR_BAR;
		    break;
		default:
		    change = False;
		    break;
		}
		TRACE(("cursor_shape:%d blinks:%s\n",
		       screen->cursor_shape, BtoS(blinks)));
		if (change) {
		    xtermSetCursorBox(screen);
		    screen->cursor_blink_esc = blinks;
		    UpdateCursorBlink(screen);
		}
	    }
	    ResetState(sp);
	    break;
#endif

#if OPT_SCROLL_LOCK
	case CASE_DECLL:
	    TRACE(("CASE_DECLL\n"));
	    if (nparam > 0) {
		for (count = 0; count < nparam; ++count) {
		    int op = zero_if_default(count);
		    switch (op) {
		    case 0:
		    case DEFAULT:
			xtermClearLEDs(screen);
			break;
		    case 1:
			/* FALLTHRU */
		    case 2:
			/* FALLTHRU */
		    case 3:
			xtermShowLED(screen,
				     (Cardinal) op,
				     True);
			break;
		    case 21:
			/* FALLTHRU */
		    case 22:
			/* FALLTHRU */
		    case 23:
			xtermShowLED(screen,
				     (Cardinal) (op - 20),
				     True);
			break;
		    }
		}
	    } else {
		xtermClearLEDs(screen);
	    }
	    ResetState(sp);
	    break;
#endif

#if OPT_VT52_MODE
	case CASE_VT52_FINISH:
	    TRACE(("CASE_VT52_FINISH terminal_id %d, vtXX_level %d\n",
		   screen->terminal_id,
		   screen->vtXX_level));
	    if (screen->terminal_id >= 100
		&& screen->vtXX_level == 0) {
		sp->groundtable =
		    sp->parsestate = ansi_table;
		/*
		 * On restore, the terminal does not recognize DECRQSS for
		 * DECSCL (per vttest).
		 */
		screen->vtXX_level = 1;
		screen->curgl = screen->vt52_save_curgl;
		screen->curgr = screen->vt52_save_curgr;
		screen->curss = screen->vt52_save_curss;
		memmove(screen->gsets, screen->vt52_save_gsets, sizeof(screen->gsets));
	    }
	    break;
#endif

	case CASE_ANSI_LEVEL_1:
	    TRACE(("CASE_ANSI_LEVEL_1\n"));
	    set_ansi_conformance(screen, 1);
	    ResetState(sp);
	    break;

	case CASE_ANSI_LEVEL_2:
	    TRACE(("CASE_ANSI_LEVEL_2\n"));
	    set_ansi_conformance(screen, 2);
	    ResetState(sp);
	    break;

	case CASE_ANSI_LEVEL_3:
	    TRACE(("CASE_ANSI_LEVEL_3\n"));
	    set_ansi_conformance(screen, 3);
	    ResetState(sp);
	    break;

	case CASE_DECSCL:
	    TRACE(("CASE_DECSCL(%d,%d)\n", GetParam(0), GetParam(1)));
	    /*
	     * This changes the emulation level, and is not recognized by
	     * VT100s.
	     */
	    if (screen->terminal_id >= 200) {
		/*
		 * Disallow unrecognized parameters, as well as attempts to set
		 * the operating level higher than the given terminal-id.
		 */
		if (GetParam(0) >= 61
		    && GetParam(0) <= 60 + (screen->terminal_id / 100)) {
		    int new_vtXX_level = GetParam(0) - 60;
		    int case_value = zero_if_default(1);
		    /*
		     * VT300, VT420, VT520 manuals claim that DECSCL does a
		     * hard reset (RIS).  VT220 manual states that it is a soft
		     * reset.  Perhaps both are right (unlikely).  Kermit says
		     * it's soft.
		     */
		    ReallyReset(xw, False, False);
		    init_parser(xw, sp);
		    screen->vtXX_level = new_vtXX_level;
		    if (new_vtXX_level > 1) {
			switch (case_value) {
			case 1:
			    show_8bit_control(False);
			    break;
			case 0:
			case 2:
			    show_8bit_control(True);
			    break;
			}
		    }
		}
	    }
	    ResetState(sp);
	    break;

	case CASE_DECSCA:
	    TRACE(("CASE_DECSCA\n"));
	    screen->protected_mode = DEC_PROTECT;
	    if (GetParam(0) <= 0 || GetParam(0) == 2) {
		UIntClr(xw->flags, PROTECTED);
		TRACE(("...clear PROTECTED\n"));
	    } else if (GetParam(0) == 1) {
		xw->flags |= PROTECTED;
		TRACE(("...set PROTECTED\n"));
	    }
	    ResetState(sp);
	    break;

	case CASE_DECSED:
	    TRACE(("CASE_DECSED\n"));
	    do_erase_display(xw, zero_if_default(0), DEC_PROTECT);
	    ResetState(sp);
	    break;

	case CASE_DECSEL:
	    TRACE(("CASE_DECSEL\n"));
	    do_erase_line(xw, zero_if_default(0), DEC_PROTECT);
	    ResetState(sp);
	    break;

	case CASE_GRAPHICS_ATTRIBUTES:
#if OPT_GRAPHICS
	    TRACE(("CASE_GRAPHICS_ATTRIBUTES\n"));
	    {
		/* request: item, action, value */
		/* reply: item, status, value */
		if (nparam != 3) {
		    TRACE(("DATA_ERROR: malformed CASE_GRAPHICS_ATTRIBUTES request with %d parameters\n", nparam));
		} else {
		    int status = 3;
		    int result = 0;
		    int result2 = 0;

		    TRACE(("CASE_GRAPHICS_ATTRIBUTES request: %d, %d, %d\n",
			   GetParam(0), GetParam(1), GetParam(2)));
		    switch (GetParam(0)) {
		    case 1:	/* color register count */
			switch (GetParam(1)) {
			case 1:	/* read */
			    status = 0;
			    result = (int) get_color_register_count(screen);
			    break;
			case 2:	/* reset */
			    screen->numcolorregisters = 0;
			    status = 0;
			    result = (int) get_color_register_count(screen);
			    break;
			case 3:	/* set */
			    if (GetParam(2) > 1 &&
				(unsigned) GetParam(2) <= MAX_COLOR_REGISTERS) {
				screen->numcolorregisters = GetParam(2);
				status = 0;
				result = (int) get_color_register_count(screen);
			    }
			    break;
			case 4:	/* read maximum */
			    status = 0;
			    result = MAX_COLOR_REGISTERS;
			    break;
			default:
			    TRACE(("DATA_ERROR: CASE_GRAPHICS_ATTRIBUTES color register count request with unknown action parameter: %d\n",
				   GetParam(1)));
			    status = 2;
			    break;
			}
			break;
		    case 2:	/* graphics geometry */
			switch (GetParam(1)) {
			case 1:	/* read */
			    status = 0;
			    result = screen->graphics_max_wide;
			    result2 = screen->graphics_max_high;
			    break;
			case 2:	/* reset */
			    /* FALLTHRU */
			case 3:	/* set */
			    /* FALLTHRU */
			case 4:	/* read maximum */
			    /* not implemented */
			    break;
			default:
			    TRACE(("DATA_ERROR: CASE_GRAPHICS_ATTRIBUTES graphics geometry request with unknown action parameter: %d\n",
				   GetParam(1)));
			    status = 2;
			    break;
			}
			break;
# if OPT_REGIS_GRAPHICS
		    case 3:	/* ReGIS geometry */
			switch (GetParam(1)) {
			case 1:	/* read */
			    status = 0;
			    result = screen->graphics_regis_def_wide;
			    result2 = screen->graphics_regis_def_high;
			    break;
			case 2:	/* reset */
			    /* FALLTHRU */
			case 3:	/* set */
			    /* FALLTHRU */
			case 4:	/* read maximum */
			    /* not implemented */
			    break;
			default:
			    TRACE(("DATA_ERROR: CASE_GRAPHICS_ATTRIBUTES ReGIS geometry request with unknown action parameter: %d\n",
				   GetParam(1)));
			    status = 2;
			    break;
			}
			break;
#endif
		    default:
			TRACE(("DATA_ERROR: CASE_GRAPHICS_ATTRIBUTES request with unknown item parameter: %d\n",
			       GetParam(0)));
			status = 1;
			break;
		    }

		    init_reply(ANSI_CSI);
		    reply.a_pintro = '?';
		    count = 0;
		    reply.a_param[count++] = (ParmType) GetParam(0);
		    reply.a_param[count++] = (ParmType) status;
		    reply.a_param[count++] = (ParmType) result;
		    if (GetParam(0) >= 2)
			reply.a_param[count++] = (ParmType) result2;
		    reply.a_nparam = (ParmType) count;
		    reply.a_inters = 0;
		    reply.a_final = 'S';
		    unparseseq(xw, &reply);
		}
	    }
#endif
	    ResetState(sp);
	    break;

	case CASE_ST:
	    TRACE(("CASE_ST: End of String (%lu bytes) (mode=%d)\n",
		   (unsigned long) sp->string_used,
		   sp->string_mode));
	    ResetState(sp);
	    if (!sp->string_used)
		break;
	    sp->string_area[--(sp->string_used)] = '\0';
	    switch (sp->string_mode) {
	    case ANSI_APC:
		/* ignored */
		break;
	    case ANSI_DCS:
		do_dcs(xw, sp->string_area, sp->string_used);
		break;
	    case ANSI_OSC:
		do_osc(xw, sp->string_area, sp->string_used, ANSI_ST);
		break;
	    case ANSI_PM:
		/* ignored */
		break;
	    case ANSI_SOS:
		/* ignored */
		break;
	    default:
		TRACE(("unknown mode\n"));
		break;
	    }
	    break;

	case CASE_SOS:
	    TRACE(("CASE_SOS: Start of String\n"));
	    if (ParseSOS(screen)) {
		sp->string_mode = ANSI_SOS;
		sp->parsestate = sos_table;
	    } else {
		illegal_parse(xw, c, sp);
	    }
	    break;

	case CASE_PM:
	    TRACE(("CASE_PM: Privacy Message\n"));
	    if (ParseSOS(screen)) {
		sp->string_mode = ANSI_PM;
		sp->parsestate = sos_table;
	    } else {
		illegal_parse(xw, c, sp);
	    }
	    break;

	case CASE_DCS:
	    TRACE(("CASE_DCS: Device Control String\n"));
	    sp->string_mode = ANSI_DCS;
	    sp->parsestate = sos_table;
	    break;

	case CASE_APC:
	    TRACE(("CASE_APC: Application Program Command\n"));
	    if (ParseSOS(screen)) {
		sp->string_mode = ANSI_APC;
		sp->parsestate = sos_table;
	    } else {
		illegal_parse(xw, c, sp);
	    }
	    break;

	case CASE_SPA:
	    TRACE(("CASE_SPA - start protected area\n"));
	    screen->protected_mode = ISO_PROTECT;
	    xw->flags |= PROTECTED;
	    ResetState(sp);
	    break;

	case CASE_EPA:
	    TRACE(("CASE_EPA - end protected area\n"));
	    UIntClr(xw->flags, PROTECTED);
	    ResetState(sp);
	    break;

	case CASE_SU:
	    TRACE(("CASE_SU - scroll up\n"));
	    xtermScroll(xw, one_if_default(0));
	    ResetState(sp);
	    break;

	case CASE_SL:		/* ISO 6429, non-DEC */
	    TRACE(("CASE_SL - scroll left\n"));
	    xtermScrollLR(xw, one_if_default(0), True);
	    ResetState(sp);
	    break;

	case CASE_SR:		/* ISO 6429, non-DEC */
	    TRACE(("CASE_SR - scroll right\n"));
	    xtermScrollLR(xw, one_if_default(0), False);
	    ResetState(sp);
	    break;

	case CASE_DECDC:
	    TRACE(("CASE_DC - delete column\n"));
	    if (screen->vtXX_level >= 4) {
		xtermColScroll(xw, one_if_default(0), True, screen->cur_col);
	    }
	    ResetState(sp);
	    break;

	case CASE_DECIC:
	    TRACE(("CASE_IC - insert column\n"));
	    if (screen->vtXX_level >= 4) {
		xtermColScroll(xw, one_if_default(0), False, screen->cur_col);
	    }
	    ResetState(sp);
	    break;

	case CASE_DECBI:
	    TRACE(("CASE_BI - back index\n"));
	    if (screen->vtXX_level >= 4) {
		xtermColIndex(xw, True);
	    }
	    ResetState(sp);
	    break;

	case CASE_DECFI:
	    TRACE(("CASE_FI - forward index\n"));
	    if (screen->vtXX_level >= 4) {
		xtermColIndex(xw, False);
	    }
	    ResetState(sp);
	    break;

	case CASE_IND:
	    TRACE(("CASE_IND - index\n"));
	    xtermIndex(xw, 1);
	    do_xevents();
	    ResetState(sp);
	    break;

	case CASE_CPL:
	    TRACE(("CASE_CPL - cursor prev line\n"));
	    CursorPrevLine(xw, one_if_default(0));
	    ResetState(sp);
	    break;

	case CASE_CNL:
	    TRACE(("CASE_CNL - cursor next line\n"));
	    CursorNextLine(xw, one_if_default(0));
	    ResetState(sp);
	    break;

	case CASE_NEL:
	    TRACE(("CASE_NEL\n"));
	    xtermIndex(xw, 1);
	    CarriageReturn(xw);
	    ResetState(sp);
	    break;

	case CASE_HTS:
	    TRACE(("CASE_HTS - horizontal tab set\n"));
	    TabSet(xw->tabs, screen->cur_col);
	    ResetState(sp);
	    break;

	case CASE_RI:
	    TRACE(("CASE_RI - reverse index\n"));
	    RevIndex(xw, 1);
	    ResetState(sp);
	    break;

	case CASE_SS2:
	    TRACE(("CASE_SS2\n"));
	    screen->curss = 2;
	    ResetState(sp);
	    break;

	case CASE_SS3:
	    TRACE(("CASE_SS3\n"));
	    screen->curss = 3;
	    ResetState(sp);
	    break;

	case CASE_CSI_STATE:
	    /* enter csi state */
	    InitParams();
	    SetParam(nparam++, DEFAULT);
	    sp->parsestate = csi_table;
	    break;

	case CASE_ESC_SP_STATE:
	    /* esc space */
	    sp->parsestate = esc_sp_table;
	    break;

	case CASE_CSI_EX_STATE:
	    /* csi exclamation */
	    sp->parsestate = csi_ex_table;
	    break;

	case CASE_CSI_TICK_STATE:
	    /* csi tick (') */
	    sp->parsestate = csi_tick_table;
	    break;

#if OPT_DEC_LOCATOR
	case CASE_DECEFR:
	    TRACE(("CASE_DECEFR - Enable Filter Rectangle\n"));
	    if (okSendMousePos(xw) == DEC_LOCATOR) {
		MotionOff(screen, xw);
		if ((screen->loc_filter_top = GetParam(0)) < 1)
		    screen->loc_filter_top = LOC_FILTER_POS;
		if (nparam < 2
		    || (screen->loc_filter_left = GetParam(1)) < 1)
		    screen->loc_filter_left = LOC_FILTER_POS;
		if (nparam < 3
		    || (screen->loc_filter_bottom = GetParam(2)) < 1)
		    screen->loc_filter_bottom = LOC_FILTER_POS;
		if (nparam < 4
		    || (screen->loc_filter_right = GetParam(3)) < 1)
		    screen->loc_filter_right = LOC_FILTER_POS;
		InitLocatorFilter(xw);
	    }
	    ResetState(sp);
	    break;

	case CASE_DECELR:
	    MotionOff(screen, xw);
	    if (GetParam(0) <= 0 || GetParam(0) > 2) {
		screen->send_mouse_pos = MOUSE_OFF;
		TRACE(("DECELR - Disable Locator Reports\n"));
	    } else {
		TRACE(("DECELR - Enable Locator Reports\n"));
		screen->send_mouse_pos = DEC_LOCATOR;
		xtermShowPointer(xw, True);
		if (GetParam(0) == 2) {
		    screen->locator_reset = True;
		} else {
		    screen->locator_reset = False;
		}
		if (nparam < 2 || GetParam(1) != 1) {
		    screen->locator_pixels = False;
		} else {
		    screen->locator_pixels = True;
		}
		screen->loc_filter = False;
	    }
	    ResetState(sp);
	    break;

	case CASE_DECSLE:
	    TRACE(("DECSLE - Select Locator Events\n"));
	    for (count = 0; count < nparam; ++count) {
		switch (zero_if_default(count)) {
		case 0:
		    MotionOff(screen, xw);
		    screen->loc_filter = False;
		    screen->locator_events = 0;
		    break;
		case 1:
		    screen->locator_events |= LOC_BTNS_DN;
		    break;
		case 2:
		    UIntClr(screen->locator_events, LOC_BTNS_DN);
		    break;
		case 3:
		    screen->locator_events |= LOC_BTNS_UP;
		    break;
		case 4:
		    UIntClr(screen->locator_events, LOC_BTNS_UP);
		    break;
		}
	    }
	    ResetState(sp);
	    break;

	case CASE_DECRQLP:
	    TRACE(("DECRQLP - Request Locator Position\n"));
	    if (GetParam(0) < 2) {
		/* Issue DECLRP Locator Position Report */
		GetLocatorPosition(xw);
	    }
	    ResetState(sp);
	    break;
#endif /* OPT_DEC_LOCATOR */

#if OPT_DEC_RECTOPS
	case CASE_CSI_DOLLAR_STATE:
	    TRACE(("CASE_CSI_DOLLAR_STATE\n"));
	    /* csi dollar ($) */
	    if (screen->vtXX_level >= 3)
		sp->parsestate = csi_dollar_table;
	    else
		sp->parsestate = eigtable;
	    break;

	case CASE_CSI_STAR_STATE:
	    TRACE(("CASE_CSI_STAR_STATE\n"));
	    /* csi star (*) */
	    if (screen->vtXX_level >= 4)
		sp->parsestate = csi_star_table;
	    else
		sp->parsestate = eigtable;
	    break;

	case CASE_DECRQCRA:
	    if (screen->vtXX_level >= 4) {
		int checksum;

		TRACE(("CASE_DECRQCRA - Request checksum of rectangular area\n"));
		xtermCheckRect(xw, ParamPair(0), &checksum);
		init_reply(ANSI_DCS);
		count = 0;
		reply.a_param[count++] = (ParmType) GetParam(1);	/* PID */
		reply.a_delim = "!~";	/* delimiter */
		reply.a_radix[count] = 16;
		reply.a_param[count++] = (ParmType) checksum;
		reply.a_nparam = (ParmType) count;
		unparseseq(xw, &reply);
	    }
	    ResetState(sp);
	    break;

	case CASE_DECCRA:
	    if (screen->vtXX_level >= 4) {
		TRACE(("CASE_DECCRA - Copy rectangular area\n"));
		xtermParseRect(xw, ParamPair(0), &myRect);
		ScrnCopyRectangle(xw, &myRect, ParamPair(5));
	    }
	    ResetState(sp);
	    break;

	case CASE_DECERA:
	    if (screen->vtXX_level >= 4) {
		TRACE(("CASE_DECERA - Erase rectangular area\n"));
		xtermParseRect(xw, ParamPair(0), &myRect);
		ScrnFillRectangle(xw, &myRect, ' ', 0, True);
	    }
	    ResetState(sp);
	    break;

	case CASE_DECFRA:
	    if (screen->vtXX_level >= 4) {
		value = zero_if_default(0);

		TRACE(("CASE_DECFRA - Fill rectangular area\n"));
		if (nparam > 0
		    && ((value >= 32 && value <= 126)
			|| (value >= 160 && value <= 255))) {
		    xtermParseRect(xw, ParamPair(1), &myRect);
		    ScrnFillRectangle(xw, &myRect, value, xw->flags, True);
		}
	    }
	    ResetState(sp);
	    break;

	case CASE_DECSERA:
	    if (screen->vtXX_level >= 4) {
		TRACE(("CASE_DECSERA - Selective erase rectangular area\n"));
		xtermParseRect(xw, ParamPair(0), &myRect);
		ScrnWipeRectangle(xw, &myRect);
	    }
	    ResetState(sp);
	    break;

	case CASE_DECSACE:
	    TRACE(("CASE_DECSACE - Select attribute change extent\n"));
	    screen->cur_decsace = zero_if_default(0);
	    ResetState(sp);
	    break;

	case CASE_DECCARA:
	    if (screen->vtXX_level >= 4) {
		TRACE(("CASE_DECCARA - Change attributes in rectangular area\n"));
		xtermParseRect(xw, ParamPair(0), &myRect);
		ScrnMarkRectangle(xw, &myRect, False, ParamPair(4));
	    }
	    ResetState(sp);
	    break;

	case CASE_DECRARA:
	    if (screen->vtXX_level >= 4) {
		TRACE(("CASE_DECRARA - Reverse attributes in rectangular area\n"));
		xtermParseRect(xw, ParamPair(0), &myRect);
		ScrnMarkRectangle(xw, &myRect, True, ParamPair(4));
	    }
	    ResetState(sp);
	    break;

	case CASE_RQM:
	    TRACE(("CASE_RQM\n"));
	    do_rpm(xw, ParamPair(0));
	    ResetState(sp);
	    break;

	case CASE_DECRQM:
	    TRACE(("CASE_DECRQM\n"));
	    do_decrpm(xw, ParamPair(0));
	    ResetState(sp);
	    break;

	case CASE_CSI_DEC_DOLLAR_STATE:
	    TRACE(("CASE_CSI_DEC_DOLLAR_STATE\n"));
	    /* csi ? dollar ($) */
	    sp->parsestate = csi_dec_dollar_table;
	    break;
#else
	case CASE_CSI_DOLLAR_STATE:
	    /* csi dollar ($) */
	    sp->parsestate = eigtable;
	    break;

	case CASE_CSI_STAR_STATE:
	    /* csi dollar (*) */
	    sp->parsestate = eigtable;
	    break;

	case CASE_CSI_DEC_DOLLAR_STATE:
	    /* csi ? dollar ($) */
	    sp->parsestate = eigtable;
	    break;
#endif /* OPT_DEC_RECTOPS */

	case CASE_S7C1T:
	    TRACE(("CASE_S7C1T\n"));
	    if (screen->vtXX_level >= 2) {
		show_8bit_control(False);
		ResetState(sp);
	    }
	    break;

	case CASE_S8C1T:
	    TRACE(("CASE_S8C1T\n"));
	    if (screen->vtXX_level >= 2) {
#if OPT_VT52_MODE
		if (screen->vtXX_level <= 1)
		    break;
#endif
		show_8bit_control(True);
		ResetState(sp);
	    }
	    break;

	case CASE_OSC:
	    TRACE(("CASE_OSC: Operating System Command\n"));
	    sp->parsestate = sos_table;
	    sp->string_mode = ANSI_OSC;
	    break;

	case CASE_RIS:
	    TRACE(("CASE_RIS\n"));
	    VTReset(xw, True, True);
	    /* NOTREACHED */

	case CASE_DECSTR:
	    TRACE(("CASE_DECSTR\n"));
	    VTReset(xw, False, False);
	    /* NOTREACHED */

	case CASE_REP:
	    TRACE(("CASE_REP\n"));
	    if (sp->lastchar >= 0 &&
		sp->lastchar < 256 &&
		sp->groundtable[E2A(sp->lastchar)] == CASE_PRINT) {
		IChar repeated[2];
		count = one_if_default(0);
		repeated[0] = (IChar) sp->lastchar;
		while (count-- > 0) {
		    dotext(xw,
			   screen->gsets[(int) (screen->curgl)],
			   repeated, 1);
		}
	    }
	    ResetState(sp);
	    break;

	case CASE_LS2:
	    TRACE(("CASE_LS2\n"));
	    screen->curgl = 2;
	    ResetState(sp);
	    break;

	case CASE_LS3:
	    TRACE(("CASE_LS3\n"));
	    screen->curgl = 3;
	    ResetState(sp);
	    break;

	case CASE_LS3R:
	    TRACE(("CASE_LS3R\n"));
	    screen->curgr = 3;
	    ResetState(sp);
	    break;

	case CASE_LS2R:
	    TRACE(("CASE_LS2R\n"));
	    screen->curgr = 2;
	    ResetState(sp);
	    break;

	case CASE_LS1R:
	    TRACE(("CASE_LS1R\n"));
	    screen->curgr = 1;
	    ResetState(sp);
	    break;

	case CASE_XTERM_SAVE:
	    savemodes(xw);
	    ResetState(sp);
	    break;

	case CASE_XTERM_RESTORE:
	    restoremodes(xw);
	    ResetState(sp);
	    break;

	case CASE_XTERM_WINOPS:
	    TRACE(("CASE_XTERM_WINOPS\n"));
	    window_ops(xw);
	    ResetState(sp);
	    break;
#if OPT_WIDE_CHARS
	case CASE_ESC_PERCENT:
	    TRACE(("CASE_ESC_PERCENT\n"));
	    sp->parsestate = esc_pct_table;
	    break;

	case CASE_UTF8:
	    /* If we did not set UTF-8 mode from resource or the
	     * command-line, allow it to be enabled/disabled by
	     * control sequence.
	     */
	    TRACE(("CASE_UTF8 wide:%d, utf8:%d, req:%s\n",
		   screen->wide_chars,
		   screen->utf8_mode,
		   BtoS(c == 'G')));
	    if ((!screen->wide_chars) && (c == 'G')) {
		WriteNow();
		ChangeToWide(xw);
	    }
	    if (screen->wide_chars
		&& !screen->utf8_always) {
		switchPtyData(screen, c == 'G');
		TRACE(("UTF8 mode %s\n",
		       BtoS(screen->utf8_mode)));
	    } else {
		TRACE(("UTF8 mode NOT turned %s (%s)\n",
		       BtoS(c == 'G'),
		       (screen->utf8_mode == uAlways)
		       ? "UTF-8 mode set from command-line"
		       : "wideChars resource was not set"));
	    }
	    ResetState(sp);
	    break;

	case CASE_SCS_PERCENT:
	    TRACE(("CASE_SCS_PERCENT\n"));
	    sp->parsestate = scs_pct_table;
	    break;

	case CASE_GSETS_PERCENT:
	    TRACE(("CASE_GSETS_PERCENT(%d) = '%c'\n", sp->scstype, c));
	    decode_scs(xw, sp->scstype, '%', (int) c);
	    ResetState(sp);
	    break;
#endif
#if OPT_MOD_FKEYS
	case CASE_SET_MOD_FKEYS:
	    TRACE(("CASE_SET_MOD_FKEYS\n"));
	    if (nparam >= 1) {
		set_mod_fkeys(xw,
			      GetParam(0),
			      ((nparam > 1)
			       ? GetParam(1)
			       : DEFAULT),
			      True);
	    } else {
		for (value = 1; value <= 5; ++value)
		    set_mod_fkeys(xw, value, DEFAULT, True);
	    }
	    break;
	case CASE_SET_MOD_FKEYS0:
	    TRACE(("CASE_SET_MOD_FKEYS0\n"));
	    if (nparam >= 1 && GetParam(0) != DEFAULT) {
		set_mod_fkeys(xw, GetParam(0), -1, False);
	    } else {
		xw->keyboard.modify_now.function_keys = -1;
	    }
	    break;
#endif
	case CASE_HIDE_POINTER:
	    TRACE(("CASE_HIDE_POINTER\n"));
	    if (nparam >= 1 && GetParam(0) != DEFAULT) {
		screen->pointer_mode = GetParam(0);
	    } else {
		screen->pointer_mode = DEF_POINTER_MODE;
	    }
	    break;

	case CASE_SM_TITLE:
	    TRACE(("CASE_SM_TITLE\n"));
	    if (nparam >= 1) {
		int n;
		for (n = 0; n < nparam; ++n) {
		    if (GetParam(n) != DEFAULT)
			screen->title_modes |= (1 << GetParam(n));
		}
	    } else {
		screen->title_modes = DEF_TITLE_MODES;
	    }
	    TRACE(("...title_modes %#x\n", screen->title_modes));
	    break;

	case CASE_RM_TITLE:
	    TRACE(("CASE_RM_TITLE\n"));
	    if (nparam >= 1) {
		int n;
		for (n = 0; n < nparam; ++n) {
		    if (GetParam(n) != DEFAULT)
			screen->title_modes &= ~(1 << GetParam(n));
		}
	    } else {
		screen->title_modes = DEF_TITLE_MODES;
	    }
	    TRACE(("...title_modes %#x\n", screen->title_modes));
	    break;

	case CASE_CSI_IGNORE:
	    sp->parsestate = cigtable;
	    break;

	case CASE_DECSWBV:
	    TRACE(("CASE_DECSWBV\n"));
	    switch (zero_if_default(0)) {
	    case 2:
		/* FALLTHRU */
	    case 3:
		/* FALLTHRU */
	    case 4:
		screen->warningVolume = bvLow;
		break;
	    case 5:
		/* FALLTHRU */
	    case 6:
		/* FALLTHRU */
	    case 7:
		/* FALLTHRU */
	    case 8:
		screen->warningVolume = bvHigh;
		break;
	    default:
		screen->warningVolume = bvOff;
		break;
	    }
	    TRACE(("...warningVolume %d\n", screen->warningVolume));
	    ResetState(sp);
	    break;

	case CASE_DECSMBV:
	    TRACE(("CASE_DECSMBV\n"));
	    switch (zero_if_default(0)) {
	    case 2:
		/* FALLTHRU */
	    case 3:
		/* FALLTHRU */
	    case 4:
		screen->marginVolume = bvLow;
		break;
	    case 0:
		/* FALLTHRU */
	    case 5:
		/* FALLTHRU */
	    case 6:
		/* FALLTHRU */
	    case 7:
		/* FALLTHRU */
	    case 8:
		screen->marginVolume = bvHigh;
		break;
	    default:
		screen->marginVolume = bvOff;
		break;
	    }
	    TRACE(("...marginVolume %d\n", screen->marginVolume));
	    ResetState(sp);
	    break;
	}
	if (sp->parsestate == sp->groundtable)
	    sp->lastchar = thischar;
    } while (0);

#if OPT_WIDE_CHARS
    screen->utf8_inparse = (Boolean) ((screen->utf8_mode != uFalse)
				      && (sp->parsestate != sos_table));
#endif

    return True;
}

static void
VTparse(XtermWidget xw)
{
    /* We longjmp back to this point in VTReset() */
    (void) setjmp(vtjmpbuf);
    init_parser(xw, &myState);

    do {
    } while (doparsing(xw, doinput(), &myState));
}

static Char *v_buffer;		/* pointer to physical buffer */
static Char *v_bufstr = NULL;	/* beginning of area to write */
static Char *v_bufptr;		/* end of area to write */
static Char *v_bufend;		/* end of physical buffer */

/* Write data to the pty as typed by the user, pasted with the mouse,
   or generated by us in response to a query ESC sequence. */

void
v_write(int f, const Char *data, unsigned len)
{
    TRACE2(("v_write(%d:%s)\n", len, visibleChars(data, len)));
    if (v_bufstr == NULL) {
	if (len > 0) {
	    v_buffer = (Char *) XtMalloc((Cardinal) len);
	    v_bufstr = v_buffer;
	    v_bufptr = v_buffer;
	    v_bufend = v_buffer + len;
	}
	if (v_bufstr == NULL) {
	    return;
	}
    }
    if_DEBUG({
	fprintf(stderr, "v_write called with %u bytes (%ld left over)",
		len, (long) (v_bufptr - v_bufstr));
	if (len > 1 && len < 10)
	    fprintf(stderr, " \"%.*s\"", len, (const char *) data);
	fprintf(stderr, "\n");
    });

#ifdef VMS
    if ((1 << f) != pty_mask) {
	tt_write((const char *) data, len);
	return;
    }
#else /* VMS */
    if (!FD_ISSET(f, &pty_mask)) {
	IGNORE_RC(write(f, (const char *) data, (size_t) len));
	return;
    }
#endif /* VMS */

    /*
     * Append to the block we already have.
     * Always doing this simplifies the code, and
     * isn't too bad, either.  If this is a short
     * block, it isn't too expensive, and if this is
     * a long block, we won't be able to write it all
     * anyway.
     */

    if (len > 0) {
#if OPT_DABBREV
	TScreenOf(term)->dabbrev_working = False;	/* break dabbrev sequence */
#endif
	if (v_bufend < v_bufptr + len) {	/* we've run out of room */
	    if (v_bufstr != v_buffer) {
		/* there is unused space, move everything down */
		/* possibly overlapping memmove here */
		if_DEBUG({
		    fprintf(stderr, "moving data down %ld\n",
			    (long) (v_bufstr - v_buffer));
		});
		memmove(v_buffer, v_bufstr, (size_t) (v_bufptr - v_bufstr));
		v_bufptr -= v_bufstr - v_buffer;
		v_bufstr = v_buffer;
	    }
	    if (v_bufend < v_bufptr + len) {
		/* still won't fit: get more space */
		/* Don't use XtRealloc because an error is not fatal. */
		unsigned size = (unsigned) (v_bufptr - v_buffer);
		v_buffer = TypeRealloc(Char, size + len, v_buffer);
		if (v_buffer) {
		    if_DEBUG({
			fprintf(stderr, "expanded buffer to %u\n",
				size + len);
		    });
		    v_bufstr = v_buffer;
		    v_bufptr = v_buffer + size;
		    v_bufend = v_bufptr + len;
		} else {
		    /* no memory: ignore entire write request */
		    xtermWarning("cannot allocate buffer space\n");
		    v_buffer = v_bufstr;	/* restore clobbered pointer */
		}
	    }
	}
	if (v_bufend >= v_bufptr + len) {
	    /* new stuff will fit */
	    memmove(v_bufptr, data, (size_t) len);
	    v_bufptr += len;
	}
    }

    /*
     * Write out as much of the buffer as we can.
     * Be careful not to overflow the pty's input silo.
     * We are conservative here and only write
     * a small amount at a time.
     *
     * If we can't push all the data into the pty yet, we expect write
     * to return a non-negative number less than the length requested
     * (if some data written) or -1 and set errno to EAGAIN,
     * EWOULDBLOCK, or EINTR (if no data written).
     *
     * (Not all systems do this, sigh, so the code is actually
     * a little more forgiving.)
     */

#define MAX_PTY_WRITE 128	/* 1/2 POSIX minimum MAX_INPUT */

    if (v_bufptr > v_bufstr) {
	int riten;

#ifdef VMS
	riten = tt_write(v_bufstr,
			 ((v_bufptr - v_bufstr <= VMS_TERM_BUFFER_SIZE)
			  ? v_bufptr - v_bufstr
			  : VMS_TERM_BUFFER_SIZE));
	if (riten == 0)
	    return (riten);
#else /* VMS */
	riten = (int) write(f, v_bufstr,
			    (size_t) ((v_bufptr - v_bufstr <= MAX_PTY_WRITE)
				      ? v_bufptr - v_bufstr
				      : MAX_PTY_WRITE));
	if (riten < 0)
#endif /* VMS */
	{
	    if_DEBUG({
		perror("write");
	    });
	    riten = 0;
	}
	if_DEBUG({
	    fprintf(stderr, "write called with %ld, wrote %d\n",
		    ((long) ((v_bufptr - v_bufstr) <= MAX_PTY_WRITE)
		     ? (long) (v_bufptr - v_bufstr)
		     : MAX_PTY_WRITE),
		    riten);
	});
	v_bufstr += riten;
	if (v_bufstr >= v_bufptr)	/* we wrote it all */
	    v_bufstr = v_bufptr = v_buffer;
    }

    /*
     * If we have lots of unused memory allocated, return it
     */
    if (v_bufend - v_bufptr > 1024) {	/* arbitrary hysteresis */
	/* save pointers across realloc */
	int start = (int) (v_bufstr - v_buffer);
	int size = (int) (v_bufptr - v_buffer);
	unsigned allocsize = (unsigned) (size ? size : 1);

	v_buffer = TypeRealloc(Char, allocsize, v_buffer);
	if (v_buffer) {
	    v_bufstr = v_buffer + start;
	    v_bufptr = v_buffer + size;
	    v_bufend = v_buffer + allocsize;
	    if_DEBUG({
		fprintf(stderr, "shrunk buffer to %u\n", allocsize);
	    });
	} else {
	    /* should we print a warning if couldn't return memory? */
	    v_buffer = v_bufstr - start;	/* restore clobbered pointer */
	}
    }
}

static void
updateCursor(TScreen *screen)
{
    if (screen->cursor_set != screen->cursor_state) {
	if (screen->cursor_set)
	    ShowCursor();
	else
	    HideCursor();
    }
}

#if OPT_BLINK_CURS || OPT_BLINK_TEXT
static void
reallyStopBlinking(TScreen *screen)
{
    if (screen->cursor_state == BLINKED_OFF) {
	/* force cursor to display if it is enabled */
	screen->cursor_state = !screen->cursor_set;
	updateCursor(screen);
	xevents();
    }
}
#endif

#ifdef VMS
#define	ptymask()	(v_bufptr > v_bufstr ? pty_mask : 0)

static void
in_put(XtermWidget xw)
{
    static PtySelect select_mask;
    static PtySelect write_mask;
    int update = VTbuffer->update;
    int size;

    int status;
    Dimension replyWidth, replyHeight;
    XtGeometryResult stat;

    TScreen *screen = TScreenOf(xw);
    char *cp;
    int i;

    select_mask = pty_mask;	/* force initial read */
    for (;;) {

	/* if the terminal changed size, resize the widget */
	if (tt_changed) {
	    tt_changed = False;

	    stat = REQ_RESIZE((Widget) xw,
			      ((Dimension) FontWidth(screen)
			       * (tt_width)
			       + 2 * screen->border
			       + screen->fullVwin.sb_info.width),
			      ((Dimension) FontHeight(screen)
			       * (tt_length)
			       + 2 * screen->border),
			      &replyWidth, &replyHeight);

	    if (stat == XtGeometryYes || stat == XtGeometryDone) {
		xw->core.width = replyWidth;
		xw->core.height = replyHeight;

		ScreenResize(xw, replyWidth, replyHeight, &xw->flags);
	    }
	    repairSizeHints();
	}

	if (screen->eventMode == NORMAL
	    && readPtyData(xw, &select_mask, VTbuffer)) {
	    if (screen->scrollWidget
		&& screen->scrollttyoutput
		&& screen->topline < 0)
		/* Scroll to bottom */
		WindowScroll(xw, 0, False);
	    break;
	}
	if (screen->scroll_amt)
	    FlushScroll(xw);
	if (screen->cursor_set && CursorMoved(screen)) {
	    if (screen->cursor_state)
		HideCursor();
	    ShowCursor();
#if OPT_I18N_SUPPORT && OPT_INPUT_METHOD
	    PreeditPosition(xw);
#endif
	} else {
	    updateCursor(screen);
	}

	if (QLength(screen->display)) {
	    select_mask = X_mask;
	} else {
	    write_mask = ptymask();
	    XFlush(screen->display);
	    select_mask = Select_mask;
	    if (screen->eventMode != NORMAL)
		select_mask = X_mask;
	}
	if (write_mask & ptymask()) {
	    v_write(screen->respond, 0, 0);	/* flush buffer */
	}

	if (select_mask & X_mask) {
	    xevents();
	    if (VTbuffer->update != update)
		break;
	}
    }
}
#else /* VMS */

static void
in_put(XtermWidget xw)
{
    static PtySelect select_mask;
    static PtySelect write_mask;

    TScreen *screen = TScreenOf(xw);
    int i;
    int update = VTbuffer->update;
#if OPT_DOUBLE_BUFFER
    int should_wait = 1;
#endif

    static struct timeval select_timeout;

#if OPT_BLINK_CURS
    /*
     * Compute the timeout for the blinking cursor to be much smaller than
     * the "on" or "off" interval.
     */
    int tick = ((screen->blink_on < screen->blink_off)
		? screen->blink_on
		: screen->blink_off);
    tick *= (1000 / 8);		/* 1000 for msec/usec, 8 for "much" smaller */
    if (tick < 1)
	tick = 1;
#endif

    for (;;) {
	int size;
	int time_select;

	if (screen->eventMode == NORMAL
	    && (size = readPtyData(xw, &select_mask, VTbuffer)) != 0) {
	    if (screen->scrollWidget
		&& screen->scrollttyoutput
		&& screen->topline < 0)
		WindowScroll(xw, 0, False);	/* Scroll to bottom */
	    /* stop speed reading at some point to look for X stuff */
	    TRACE(("VTbuffer uses %ld/%d\n",
		   (long) (VTbuffer->last - VTbuffer->buffer),
		   BUF_SIZE));
	    if ((VTbuffer->last - VTbuffer->buffer) > BUF_SIZE) {
		FD_CLR(screen->respond, &select_mask);
		break;
	    }
#if OPT_DOUBLE_BUFFER
	    if (should_wait) {
		/* wait 25 msec for potential extra data (avoids some bogus flickering) */
		/* that's only 40 FPS but hey, it's still lower than the input lag on some consoles! :) */
		usleep(25000);
		should_wait = 0;
	    }
	    select_timeout.tv_sec = 0;
	    i = Select(max_plus1, &select_mask, &write_mask, 0,
		       &select_timeout);
	    if (i > 0 && FD_ISSET(screen->respond, &select_mask))
		continue;
	    else
		break;
#elif defined(HAVE_SCHED_YIELD)
	    /*
	     * If we've read a full (small/fragment) buffer, let the operating
	     * system have a turn, and we'll resume reading until we've either
	     * read only a fragment of the buffer, or we've filled the large
	     * buffer (see above).  Doing this helps keep up with large bursts
	     * of output.
	     */
	    if (size == FRG_SIZE) {
		select_timeout.tv_sec = 0;
		i = Select(max_plus1, &select_mask, &write_mask, 0,
			   &select_timeout);
		if (i > 0 && FD_ISSET(screen->respond, &select_mask)) {
		    sched_yield();
		} else
		    break;
	    } else {
		break;
	    }
#else
	    (void) size;	/* unused in this branch */
	    break;
#endif
	}
	/* update the screen */
	if (screen->scroll_amt)
	    FlushScroll(xw);
	if (screen->cursor_set && CursorMoved(screen)) {
	    if (screen->cursor_state)
		HideCursor();
	    ShowCursor();
#if OPT_I18N_SUPPORT && OPT_INPUT_METHOD
	    PreeditPosition(xw);
#endif
	} else {
	    updateCursor(screen);
	}

	XFlush(screen->display);	/* always flush writes before waiting */

	/* Update the masks and, unless X events are already in the queue,
	   wait for I/O to be possible. */
	XFD_COPYSET(&Select_mask, &select_mask);
	/* in selection mode xterm does not read pty */
	if (screen->eventMode != NORMAL)
	    FD_CLR(screen->respond, &select_mask);

	if (v_bufptr > v_bufstr) {
	    XFD_COPYSET(&pty_mask, &write_mask);
	} else
	    FD_ZERO(&write_mask);
	select_timeout.tv_sec = 0;
	time_select = 0;

	/*
	 * if there's either an XEvent or an XtTimeout pending, just take
	 * a quick peek, i.e. timeout from the select() immediately.  If
	 * there's nothing pending, let select() block a little while, but
	 * for a shorter interval than the arrow-style scrollbar timeout.
	 * The blocking is optional, because it tends to increase the load
	 * on the host.
	 */
	if (xtermAppPending()) {
	    select_timeout.tv_usec = 0;
	    time_select = 1;
	} else if (screen->awaitInput) {
	    select_timeout.tv_usec = 50000;
	    time_select = 1;
#if OPT_BLINK_CURS
	} else if ((screen->blink_timer != 0 &&
		    ((screen->select & FOCUS) || screen->always_highlight)) ||
		   (screen->cursor_state == BLINKED_OFF)) {
	    select_timeout.tv_usec = tick;
	    while (select_timeout.tv_usec > 1000000) {
		select_timeout.tv_usec -= 1000000;
		select_timeout.tv_sec++;
	    }
	    time_select = 1;
#endif
#if OPT_SESSION_MGT
	} else if (resource.sessionMgt) {
	    if (ice_fd >= 0)
		FD_SET(ice_fd, &select_mask);
#endif
	}
	if (need_cleanup)
	    NormalExit();
#if OPT_DOUBLE_BUFFER
	if (screen->needSwap) {
	    XdbeSwapInfo swap;
	    swap.swap_window = VWindow(screen);
	    swap.swap_action = XdbeCopied;
	    XdbeSwapBuffers(XtDisplay(term), &swap, 1);
	    XFlush(XtDisplay(xw));
	    screen->needSwap = 0;
	}
#endif
	i = Select(max_plus1, &select_mask, &write_mask, 0,
		   (time_select ? &select_timeout : 0));
	if (i < 0) {
	    if (errno != EINTR)
		SysError(ERROR_SELECT);
	    continue;
	}

	/* if there is room to write more data to the pty, go write more */
	if (FD_ISSET(screen->respond, &write_mask)) {
	    v_write(screen->respond, (Char *) 0, 0);	/* flush buffer */
	}

	/* if there are X events already in our queue, it
	   counts as being readable */
	if (xtermAppPending() ||
	    FD_ISSET(ConnectionNumber(screen->display), &select_mask)) {
	    xevents();
	    if (VTbuffer->update != update)	/* HandleInterpret */
		break;
	}

    }
}
#endif /* VMS */

static IChar
doinput(void)
{
    TScreen *screen = TScreenOf(term);

    while (!morePtyData(screen, VTbuffer))
	in_put(term);
    return nextPtyData(screen, VTbuffer);
}

#if OPT_I18N_SUPPORT && OPT_INPUT_METHOD
/*
 *  For OverTheSpot, client has to inform the position for XIM preedit.
 */
static void
PreeditPosition(XtermWidget xw)
{
    TInput *input = lookupTInput(xw, (Widget) xw);
    TScreen *screen = TScreenOf(xw);
    CLineData *ld;
    XPoint spot;
    XVaNestedList list;

    if (input && input->xic
	&& (ld = getLineData(screen, screen->cur_row)) != 0) {
	spot.x = (short) LineCursorX(screen, ld, screen->cur_col);
	spot.y = (short) (CursorY(screen, screen->cur_row) + xw->work.xim_fs_ascent);
	list = XVaCreateNestedList(0,
				   XNSpotLocation, &spot,
				   XNForeground, T_COLOR(screen, TEXT_FG),
				   XNBackground, T_COLOR(screen, TEXT_BG),
				   (void *) 0);
	XSetICValues(input->xic, XNPreeditAttributes, list, (void *) 0);
	XFree(list);
    }
}
#endif

static void
WrapLine(XtermWidget xw)
{
    TScreen *screen = TScreenOf(xw);
    LineData *ld = getLineData(screen, screen->cur_row);

    if (ld != 0) {
	/* mark that we had to wrap this line */
	LineSetFlag(ld, LINEWRAPPED);
	if (screen->show_wrap_marks) {
	    ShowWrapMarks(xw, screen->cur_row, ld);
	}
	xtermAutoPrint(xw, '\n');
	xtermIndex(xw, 1);
	set_cur_col(screen, ScrnLeftMargin(xw));
    }
}

/*
 * process a string of characters according to the character set indicated
 * by charset.  worry about end of line conditions (wraparound if selected).
 */
void
dotext(XtermWidget xw,
       int charset,
       IChar *buf,		/* start of characters to process */
       Cardinal len)		/* end */
{
    TScreen *screen = TScreenOf(xw);
#if OPT_WIDE_CHARS
    Cardinal chars_chomped = 1;
    int next_col = screen->cur_col;
#else
    int next_col, this_col;	/* must be signed */
#endif
    Cardinal offset;
    int right = ScrnRightMargin(xw);

    /*
     * It is possible to use CUP, etc., to move outside margins.  In that
     * case, the right-margin is ineffective.
     */
    if (screen->cur_col > right) {
	right = screen->max_col;
    }
#if OPT_WIDE_CHARS
    if (screen->vt100_graphics)
#endif
	if (!xtermCharSetOut(xw, buf, buf + len, charset))
	    return;

    if_OPT_XMC_GLITCH(screen, {
	Cardinal n;
	if (charset != '?') {
	    for (n = 0; n < len; n++) {
		if (buf[n] == XMC_GLITCH)
		    buf[n] = XMC_GLITCH + 1;
	    }
	}
    });

#if OPT_WIDE_CHARS
    for (offset = 0;
	 offset < len && (chars_chomped > 0 || screen->do_wrap);
	 offset += chars_chomped) {
	int width_available = right + 1 - screen->cur_col;
	int width_here = 0;
	Boolean force_wrap;
	Boolean need_wrap;
	Boolean did_wrap;
	int last_chomp = 0;
	chars_chomped = 0;

	do {
	    force_wrap = False;
	    need_wrap = False;
	    did_wrap = False;

	    if (screen->do_wrap) {
		screen->do_wrap = False;
		if ((xw->flags & WRAPAROUND)) {
		    WrapLine(xw);
		    width_available = right + 1 - screen->cur_col;
		    next_col = screen->cur_col;
		    did_wrap = True;
		}
	    }

	    /*
	     * This can happen with left/right margins...
	     */
	    if (width_available <= 0) {
		break;
	    }

	    /*
	     * Regarding the soft-hyphen aberration, see
	     * http://archives.miloush.net/michkap/archive/2006/09/02/736881.html
	     */
	    while (width_here <= width_available
		   && chars_chomped < (len - offset)) {
		Cardinal n = chars_chomped + offset;
		if (!screen->utf8_mode
		    || (screen->vt100_graphics && charset == '0')) {
		    last_chomp = 1;
		} else if (screen->c1_printable &&
			   buf[n] >= 0x80 &&
			   buf[n] <= 0xa0) {
		    last_chomp = 1;
		} else {
		    last_chomp = my_wcwidth((wchar_t) buf[n]);
		    if (last_chomp <= 0) {
			IChar ch = buf[n];
			Bool eat_it = (ch > 127);
			if (ch == 0xad) {
			    /*
			     * Only display soft-hyphen if it happens to be at
			     * the right-margin.  While that means that only
			     * the displayed character could be selected for
			     * pasting, a well-behaved application would never
			     * send this, anyway...
			     */
			    if (width_here < width_available - 1) {
				eat_it = True;
			    } else {
				last_chomp = 1;
				eat_it = False;
			    }
			    TRACE(("...will%s display soft-hyphen\n",
				   eat_it ? " not" : ""));
			}
			/*
			 * Supposedly we dealt with combining characters and
			 * control characters in doparse().  Anything left over
			 * is junk that we will not attempt to display.
			 */
			if (eat_it) {
			    TRACE(("...will not display U+%04X\n", ch));
			    --len;
			    while (n < len) {
				buf[n] = buf[n + 1];
				++n;
			    }
			    last_chomp = 0;
			    chars_chomped--;
			}
		    }
		}
		width_here += last_chomp;
		chars_chomped++;
	    }

	    if (width_here > width_available) {
		if (last_chomp > right + 1) {
		    break;	/* give up - it is too big */
		} else if (chars_chomped-- == 0) {
		    /* This can happen with left/right margins... */
		    break;
		}
		width_here -= last_chomp;
		if (chars_chomped > 0) {
		    if (!(xw->flags & WRAPAROUND)) {
			buf[chars_chomped + offset - 1] = buf[len - 1];
		    } else {
			need_wrap = True;
		    }
		}
	    } else if (width_here == width_available) {
		need_wrap = True;
	    } else if (chars_chomped != (len - offset)) {
		need_wrap = True;
	    }

	    if (chars_chomped != 0 && next_col <= screen->max_col) {
		WriteText(xw, buf + offset, chars_chomped);
	    } else if (!did_wrap
		       && len > 0
		       && (xw->flags & WRAPAROUND)
		       && screen->cur_col > ScrnLeftMargin(xw)) {
		force_wrap = True;
		need_wrap = True;
	    }
	    next_col += width_here;
	    screen->do_wrap = need_wrap;
	} while (force_wrap);
    }

    /*
     * Remember that we wrote something to the screen, for use as a base of
     * combining characters.  The logic above may have called cursor-forward
     * or carriage-return operations which resets this flag, so we set it at
     * the very end.
     */
    screen->char_was_written = True;
#else /* ! OPT_WIDE_CHARS */

    for (offset = 0; offset < len; offset += (Cardinal) this_col) {
#if OPT_DEC_CHRSET
	CLineData *ld = getLineData(screen, screen->cur_row);
#endif

	int last_col = LineMaxCol(screen, ld);
	if (last_col > (right + 1))
	    last_col = right + 1;
	this_col = last_col - screen->cur_col + 1;
	if (this_col <= 1) {
	    if (screen->do_wrap) {
		screen->do_wrap = False;
		if ((xw->flags & WRAPAROUND)) {
		    WrapLine(xw);
		}
	    }
	    this_col = 1;
	}
	if (offset + (Cardinal) this_col > len) {
	    this_col = (int) (len - offset);
	}
	next_col = screen->cur_col + this_col;

	WriteText(xw, buf + offset, (unsigned) this_col);

	/*
	 * The call to WriteText updates screen->cur_col.
	 * If screen->cur_col is less than next_col, we must have
	 * hit the right margin - so set the do_wrap flag.
	 */
	screen->do_wrap = (Boolean) (screen->cur_col < next_col);
    }

#endif /* OPT_WIDE_CHARS */
}

#if OPT_WIDE_CHARS
unsigned
visual_width(const IChar *str, Cardinal len)
{
    /* returns the visual width of a string (doublewide characters count
       as 2, normalwide characters count as 1) */
    unsigned my_len = 0;
    while (len) {
	int ch = (int) *str++;
	if (isWide(ch))
	    my_len += 2;
	else
	    my_len++;
	len--;
    }
    return my_len;
}
#endif

#if HANDLE_STRUCT_NOTIFY
/* Flag icon name with "***" on window output when iconified.
 */
static void
HandleStructNotify(Widget w GCC_UNUSED,
		   XtPointer closure GCC_UNUSED,
		   XEvent *event,
		   Boolean *cont GCC_UNUSED)
{
    XtermWidget xw = term;

    switch (event->type) {
    case MapNotify:
	TRACE(("HandleStructNotify(MapNotify) %#lx\n", event->xmap.window));
	resetZIconBeep(xw);
	mapstate = !IsUnmapped;
	break;
    case UnmapNotify:
	TRACE(("HandleStructNotify(UnmapNotify) %#lx\n", event->xunmap.window));
	mapstate = IsUnmapped;
	break;
    case ConfigureNotify:
	if (event->xconfigure.window == XtWindow(toplevel)) {
#if !OPT_TOOLBAR
	    int height, width;

	    height = event->xconfigure.height;
	    width = event->xconfigure.width;
#endif
	    TRACE(("HandleStructNotify(ConfigureNotify) %#lx %d,%d %dx%d\n",
		   event->xconfigure.window,
		   event->xconfigure.y, event->xconfigure.x,
		   event->xconfigure.height, event->xconfigure.width));

#if OPT_TOOLBAR
	    /*
	     * The notification is for the top-level widget, but we care about
	     * vt100 (ignore the tek4014 window).
	     */
	    if (TScreenOf(xw)->Vshow) {
		VTwin *Vwin = WhichVWin(TScreenOf(xw));
		TbInfo *info = &(Vwin->tb_info);
		TbInfo save = *info;

		if (info->menu_bar) {
		    XtVaGetValues(info->menu_bar,
				  XtNheight, &info->menu_height,
				  XtNborderWidth, &info->menu_border,
				  (XtPointer) 0);

		    if (save.menu_height != info->menu_height
			|| save.menu_border != info->menu_border) {

			TRACE(("...menu_height %d\n", info->menu_height));
			TRACE(("...menu_border %d\n", info->menu_border));
			TRACE(("...had height  %d, border %d\n",
			       save.menu_height,
			       save.menu_border));

			/*
			 * Window manager still may be using the old values.
			 * Try to fool it.
			 */
			REQ_RESIZE((Widget) xw,
				   TScreenOf(xw)->fullVwin.fullwidth,
				   (Dimension) (info->menu_height
						- save.menu_height
						+ TScreenOf(xw)->fullVwin.fullheight),
				   NULL, NULL);
			repairSizeHints();
		    }
		}
	    }
#else
	    if (height != xw->hints.height || width != xw->hints.width)
		RequestResize(xw, height, width, False);
#endif /* OPT_TOOLBAR */
	}
	break;
    case ReparentNotify:
	TRACE(("HandleStructNotify(ReparentNotify) %#lx\n", event->xreparent.window));
	break;
    default:
	TRACE(("HandleStructNotify(event %s) %#lx\n",
	       visibleEventType(event->type),
	       event->xany.window));
	break;
    }
}
#endif /* HANDLE_STRUCT_NOTIFY */

#if OPT_BLINK_CURS
static void
SetCursorBlink(TScreen *screen, Bool enable)
{
    screen->cursor_blink = (Boolean) enable;
    if (DoStartBlinking(screen)) {
	StartBlinking(screen);
    } else {
	/* EMPTY */
#if OPT_BLINK_TEXT
	reallyStopBlinking(screen);
#else
	StopBlinking(screen);
#endif
    }
    update_cursorblink();
}

void
ToggleCursorBlink(TScreen *screen)
{
    SetCursorBlink(screen, (Bool) (!(screen->cursor_blink)));
}
#endif

/*
 * process ANSI modes set, reset
 */
static void
ansi_modes(XtermWidget xw, BitFunc func)
{
    int i;

    for (i = 0; i < nparam; ++i) {
	switch (GetParam(i)) {
	case 2:		/* KAM (if set, keyboard locked */
	    (*func) (&xw->keyboard.flags, MODE_KAM);
	    break;

	case 4:		/* IRM                          */
	    (*func) (&xw->flags, INSERT);
	    break;

	case 12:		/* SRM (if set, local echo      */
	    (*func) (&xw->keyboard.flags, MODE_SRM);
	    break;

	case 20:		/* LNM                          */
	    (*func) (&xw->flags, LINEFEED);
	    update_autolinefeed();
	    break;
	}
    }
}

#define IsSM() (func == bitset)

#define set_bool_mode(flag) \
	flag = (Boolean) IsSM()

static void
really_set_mousemode(XtermWidget xw,
		     Bool enabled,
		     XtermMouseModes mode)
{
    TScreenOf(xw)->send_mouse_pos = enabled ? mode : MOUSE_OFF;
    if (okSendMousePos(xw) != MOUSE_OFF)
	xtermShowPointer(xw, True);
}

#define set_mousemode(mode) really_set_mousemode(xw, IsSM(), mode)

#if OPT_READLINE
#define set_mouseflag(f)		\
	(IsSM()				\
	 ? SCREEN_FLAG_set(screen, f)	\
	 : SCREEN_FLAG_unset(screen, f))
#endif

/*
 * process DEC private modes set, reset
 */
static void
dpmodes(XtermWidget xw, BitFunc func)
{
    TScreen *screen = TScreenOf(xw);
    int i, j;
    unsigned myflags;

    TRACE(("changing %d DEC private modes\n", nparam));
    for (i = 0; i < nparam; ++i) {
	int code = GetParam(i);

	TRACE(("%s %d\n", IsSM()? "DECSET" : "DECRST", code));
	switch ((DECSET_codes) code) {
	case srm_DECCKM:
	    (*func) (&xw->keyboard.flags, MODE_DECCKM);
	    update_appcursor();
	    break;
	case srm_DECANM:	/* ANSI/VT52 mode      */
	    if (IsSM()) {	/* ANSI (VT100) */
		/*
		 * Setting DECANM should have no effect, since this function
		 * cannot be reached from vt52 mode.
		 */
		/* EMPTY */ ;
	    }
#if OPT_VT52_MODE
	    else if (screen->terminal_id >= 100) {	/* VT52 */
		TRACE(("DECANM terminal_id %d, vtXX_level %d\n",
		       screen->terminal_id,
		       screen->vtXX_level));
		screen->vtXX_level = 0;
		screen->vt52_save_curgl = screen->curgl;
		screen->vt52_save_curgr = screen->curgr;
		screen->vt52_save_curss = screen->curss;
		memmove(screen->vt52_save_gsets, screen->gsets, sizeof(screen->gsets));
		resetCharsets(screen);
		InitParams();	/* ignore the remaining params, if any */
	    }
#endif
	    break;
	case srm_DECCOLM:
	    if (screen->c132) {
		if (!(xw->flags & NOCLEAR_COLM))
		    ClearScreen(xw);
		CursorSet(screen, 0, 0, xw->flags);
		if ((j = IsSM()? 132 : 80) !=
		    ((xw->flags & IN132COLUMNS) ? 132 : 80) ||
		    j != MaxCols(screen))
		    RequestResize(xw, -1, j, True);
		(*func) (&xw->flags, IN132COLUMNS);
		if (xw->flags & IN132COLUMNS) {
		    UIntClr(xw->flags, LEFT_RIGHT);
		    reset_lr_margins(screen);
		}
	    }
	    break;
	case srm_DECSCLM:	/* (slow scroll)        */
	    if (IsSM()) {
		screen->jumpscroll = 0;
		if (screen->scroll_amt)
		    FlushScroll(xw);
	    } else
		screen->jumpscroll = 1;
	    (*func) (&xw->flags, SMOOTHSCROLL);
	    update_jumpscroll();
	    break;
	case srm_DECSCNM:
	    myflags = xw->flags;
	    (*func) (&xw->flags, REVERSE_VIDEO);
	    if ((xw->flags ^ myflags) & REVERSE_VIDEO)
		ReverseVideo(xw);
	    /* update_reversevideo done in RevVid */
	    break;

	case srm_DECOM:
	    (*func) (&xw->flags, ORIGIN);
	    CursorSet(screen, 0, 0, xw->flags);
	    break;

	case srm_DECAWM:
	    (*func) (&xw->flags, WRAPAROUND);
	    update_autowrap();
	    break;
	case srm_DECARM:
	    /* ignore autorepeat
	     * XAutoRepeatOn() and XAutoRepeatOff() can do this, but only
	     * for the whole display - not limited to a given window.
	     */
	    break;
	case srm_X10_MOUSE:	/* MIT bogus sequence           */
	    MotionOff(screen, xw);
	    set_mousemode(X10_MOUSE);
	    break;
#if OPT_TOOLBAR
	case srm_RXVT_TOOLBAR:
	    ShowToolbar(IsSM());
	    break;
#endif
#if OPT_BLINK_CURS
	case srm_ATT610_BLINK:	/* att610: Start/stop blinking cursor */
	    if (screen->cursor_blink_res) {
		set_bool_mode(screen->cursor_blink_esc);
		UpdateCursorBlink(screen);
	    }
	    break;
#endif
	case srm_DECPFF:	/* print form feed */
	    set_bool_mode(PrinterOf(screen).printer_formfeed);
	    break;
	case srm_DECPEX:	/* print extent */
	    set_bool_mode(PrinterOf(screen).printer_extent);
	    break;
	case srm_DECTCEM:	/* Show/hide cursor (VT200) */
	    set_bool_mode(screen->cursor_set);
	    break;
	case srm_RXVT_SCROLLBAR:
	    if (screen->fullVwin.sb_info.width != (IsSM()? ON : OFF))
		ToggleScrollBar(xw);
	    break;
#if OPT_SHIFT_FONTS
	case srm_RXVT_FONTSIZE:
	    set_bool_mode(xw->misc.shift_fonts);
	    break;
#endif
#if OPT_TEK4014
	case srm_DECTEK:
	    if (IsSM() && !(screen->inhibit & I_TEK)) {
		FlushLog(xw);
		TEK4014_ACTIVE(xw) = True;
		TRACE(("Tek4014 is now active...\n"));
		update_vttekmode();
	    }
	    break;
#endif
	case srm_132COLS:	/* 132 column mode              */
	    set_bool_mode(screen->c132);
	    update_allow132();
	    break;
	case srm_CURSES_HACK:
	    set_bool_mode(screen->curses);
	    update_cursesemul();
	    break;
	case srm_DECNRCM:	/* national charset (VT220) */
	    if (screen->vtXX_level >= 2) {
		if ((*func) (&xw->flags, NATIONAL)) {
		    modified_DECNRCM(xw);
		}
	    }
	    break;
	case srm_MARGIN_BELL:	/* margin bell                  */
	    set_bool_mode(screen->marginbell);
	    if (!screen->marginbell)
		screen->bellArmed = -1;
	    update_marginbell();
	    break;
	case srm_REVERSEWRAP:	/* reverse wraparound   */
	    (*func) (&xw->flags, REVERSEWRAP);
	    update_reversewrap();
	    break;
#ifdef ALLOWLOGGING
	case srm_ALLOWLOGGING:	/* logging              */
#ifdef ALLOWLOGFILEONOFF
	    /*
	     * if this feature is enabled, logging may be
	     * enabled and disabled via escape sequences.
	     */
	    if (IsSM())
		StartLog(xw);
	    else
		CloseLog(xw);
#else
	    Bell(xw, XkbBI_Info, 0);
	    Bell(xw, XkbBI_Info, 0);
#endif /* ALLOWLOGFILEONOFF */
	    break;
#endif
	case srm_OPT_ALTBUF_CURSOR:	/* alternate buffer & cursor */
	    if (!xw->misc.titeInhibit) {
		if (IsSM()) {
		    CursorSave(xw);
		    ToAlternate(xw, True);
		    ClearScreen(xw);
		} else {
		    FromAlternate(xw);
		    CursorRestore(xw);
		}
	    } else if (IsSM()) {
		do_ti_xtra_scroll(xw);
	    }
	    break;
	case srm_OPT_ALTBUF:
	    /* FALLTHRU */
	case srm_ALTBUF:	/* alternate buffer */
	    if (!xw->misc.titeInhibit) {
		if (IsSM()) {
		    ToAlternate(xw, False);
		} else {
		    if (screen->whichBuf
			&& (code == 1047))
			ClearScreen(xw);
		    FromAlternate(xw);
		}
	    } else if (IsSM()) {
		do_ti_xtra_scroll(xw);
	    }
	    break;
	case srm_DECNKM:
	    (*func) (&xw->keyboard.flags, MODE_DECKPAM);
	    update_appkeypad();
	    break;
	case srm_DECBKM:
	    /* back-arrow mapped to backspace or delete(D) */
	    (*func) (&xw->keyboard.flags, MODE_DECBKM);
	    TRACE(("DECSET DECBKM %s\n",
		   BtoS(xw->keyboard.flags & MODE_DECBKM)));
	    update_decbkm();
	    break;
	case srm_DECLRMM:
	    if (screen->vtXX_level >= 4) {	/* VT420 */
		(*func) (&xw->flags, LEFT_RIGHT);
		if (IsLeftRightMode(xw)) {
		    xterm_ResetDouble(xw);
		} else {
		    reset_lr_margins(screen);
		}
	    }
	    break;
#if OPT_SIXEL_GRAPHICS
	case srm_DECSDM:	/* sixel scrolling */
	    if (screen->terminal_id == 240 ||	/* FIXME: VT24x did not scroll sixel graphics */
		screen->terminal_id == 241 ||
		screen->terminal_id == 330 ||
		screen->terminal_id == 340 ||
		screen->terminal_id == 382) {
		(*func) (&xw->keyboard.flags, MODE_DECSDM);
		TRACE(("DECSET/DECRST DECSDM %s (resource default is %d)\n",
		       BtoS(xw->keyboard.flags & MODE_DECSDM),
		       TScreenOf(xw)->sixel_scrolling));
		update_decsdm();
	    }
	    break;
#endif
	case srm_DECNCSM:
	    if (screen->vtXX_level >= 5) {	/* VT510 */
		(*func) (&xw->flags, NOCLEAR_COLM);
	    }
	    break;
	case srm_VT200_MOUSE:	/* xterm bogus sequence         */
	    MotionOff(screen, xw);
	    set_mousemode(VT200_MOUSE);
	    break;
	case srm_VT200_HIGHLIGHT_MOUSE:	/* xterm sequence w/hilite tracking */
	    MotionOff(screen, xw);
	    set_mousemode(VT200_HIGHLIGHT_MOUSE);
	    break;
	case srm_BTN_EVENT_MOUSE:
	    MotionOff(screen, xw);
	    set_mousemode(BTN_EVENT_MOUSE);
	    break;
	case srm_ANY_EVENT_MOUSE:
	    set_mousemode(ANY_EVENT_MOUSE);
	    if (screen->send_mouse_pos == MOUSE_OFF) {
		MotionOff(screen, xw);
	    } else {
		MotionOn(screen, xw);
	    }
	    break;
#if OPT_FOCUS_EVENT
	case srm_FOCUS_EVENT_MOUSE:
	    set_bool_mode(screen->send_focus_pos);
	    break;
#endif
	case srm_EXT_MODE_MOUSE:
	    /* FALLTHRU */
	case srm_SGR_EXT_MODE_MOUSE:
	    /* FALLTHRU */
	case srm_URXVT_EXT_MODE_MOUSE:
	    /*
	     * Rather than choose an arbitrary precedence among the coordinate
	     * modes, they are mutually exclusive.  For consistency, a reset is
	     * only effective against the matching mode.
	     */
	    if (IsSM()) {
		screen->extend_coords = code;
	    } else if (screen->extend_coords == code) {
		screen->extend_coords = 0;
	    }
	    break;
	case srm_ALTERNATE_SCROLL:
	    set_bool_mode(screen->alternateScroll);
	    break;
	case srm_RXVT_SCROLL_TTY_OUTPUT:
	    set_bool_mode(screen->scrollttyoutput);
	    update_scrollttyoutput();
	    break;
	case srm_RXVT_SCROLL_TTY_KEYPRESS:
	    set_bool_mode(screen->scrollkey);
	    update_scrollkey();
	    break;
	case srm_EIGHT_BIT_META:
	    if (screen->eight_bit_meta != ebNever) {
		set_bool_mode(screen->eight_bit_meta);
	    }
	    break;
#if OPT_NUM_LOCK
	case srm_REAL_NUMLOCK:
	    set_bool_mode(xw->misc.real_NumLock);
	    update_num_lock();
	    break;
	case srm_META_SENDS_ESC:
	    set_bool_mode(screen->meta_sends_esc);
	    update_meta_esc();
	    break;
#endif
	case srm_DELETE_IS_DEL:
	    set_bool_mode(screen->delete_is_del);
	    update_delete_del();
	    break;
#if OPT_NUM_LOCK
	case srm_ALT_SENDS_ESC:
	    set_bool_mode(screen->alt_sends_esc);
	    update_alt_esc();
	    break;
#endif
	case srm_KEEP_SELECTION:
	    set_bool_mode(screen->keepSelection);
	    update_keepSelection();
	    break;
	case srm_SELECT_TO_CLIPBOARD:
	    set_bool_mode(screen->selectToClipboard);
	    update_selectToClipboard();
	    break;
	case srm_BELL_IS_URGENT:
	    set_bool_mode(screen->bellIsUrgent);
	    update_bellIsUrgent();
	    break;
	case srm_POP_ON_BELL:
	    set_bool_mode(screen->poponbell);
	    update_poponbell();
	    break;
	case srm_KEEP_CLIPBOARD:
	    set_bool_mode(screen->keepClipboard);
	    update_keepClipboard();
	    break;
	case srm_TITE_INHIBIT:
	    if (!xw->misc.titeInhibit) {
		if (IsSM())
		    CursorSave(xw);
		else
		    CursorRestore(xw);
	    }
	    break;
#if OPT_TCAP_FKEYS
	case srm_TCAP_FKEYS:
	    set_keyboard_type(xw, keyboardIsTermcap, IsSM());
	    break;
#endif
#if OPT_SUN_FUNC_KEYS
	case srm_SUN_FKEYS:
	    set_keyboard_type(xw, keyboardIsSun, IsSM());
	    break;
#endif
#if OPT_HP_FUNC_KEYS
	case srm_HP_FKEYS:
	    set_keyboard_type(xw, keyboardIsHP, IsSM());
	    break;
#endif
#if OPT_SCO_FUNC_KEYS
	case srm_SCO_FKEYS:
	    set_keyboard_type(xw, keyboardIsSCO, IsSM());
	    break;
#endif
	case srm_LEGACY_FKEYS:
	    set_keyboard_type(xw, keyboardIsLegacy, IsSM());
	    break;
#if OPT_SUNPC_KBD
	case srm_VT220_FKEYS:
	    set_keyboard_type(xw, keyboardIsVT220, IsSM());
	    break;
#endif
#if OPT_READLINE
	case srm_BUTTON1_MOVE_POINT:
	    set_mouseflag(click1_moves);
	    break;
	case srm_BUTTON2_MOVE_POINT:
	    set_mouseflag(paste_moves);
	    break;
	case srm_DBUTTON3_DELETE:
	    set_mouseflag(dclick3_deletes);
	    break;
	case srm_PASTE_IN_BRACKET:
	    set_mouseflag(paste_brackets);
	    break;
	case srm_PASTE_QUOTE:
	    set_mouseflag(paste_quotes);
	    break;
	case srm_PASTE_LITERAL_NL:
	    set_mouseflag(paste_literal_nl);
	    break;
#endif /* OPT_READLINE */
#if OPT_GRAPHICS
	case srm_PRIVATE_COLOR_REGISTERS:	/* private color registers for each graphic */
	    TRACE(("DECSET/DECRST PRIVATE_COLOR_REGISTERS to %s (resource default is %s)\n",
		   BtoS(screen->privatecolorregisters),
		   BtoS(TScreenOf(xw)->privatecolorregisters)));
	    set_bool_mode(screen->privatecolorregisters);
	    update_privatecolorregisters();
	    break;
#endif
#if OPT_SIXEL_GRAPHICS
	case srm_SIXEL_SCROLLS_RIGHT:	/* sixel scrolling moves cursor to right */
	    if (screen->terminal_id == 240 ||	/* FIXME: VT24x did not scroll sixel graphics */
		screen->terminal_id == 241 ||
		screen->terminal_id == 330 ||
		screen->terminal_id == 340 ||
		screen->terminal_id == 382) {
		set_bool_mode(screen->sixel_scrolls_right);
		TRACE(("DECSET/DECRST SIXEL_SCROLLS_RIGHT to %s (resource default is %s)\n",
		       BtoS(screen->sixel_scrolls_right),
		       BtoS(TScreenOf(xw)->sixel_scrolls_right)));
	    }
	    break;
#endif
	default:
	    TRACE(("DATA_ERROR: unknown private code %d\n", code));
	    break;
	}
    }
}

/*
 * process xterm private modes save
 */
static void
savemodes(XtermWidget xw)
{
    TScreen *screen = TScreenOf(xw);
    int i;

    for (i = 0; i < nparam; i++) {
	int code = GetParam(i);

	TRACE(("savemodes %d\n", code));
	switch ((DECSET_codes) code) {
	case srm_DECCKM:
	    DoSM(DP_DECCKM, xw->keyboard.flags & MODE_DECCKM);
	    break;
	case srm_DECANM:	/* ANSI/VT52 mode      */
	    /* no effect */
	    break;
	case srm_DECCOLM:
	    if (screen->c132)
		DoSM(DP_DECCOLM, xw->flags & IN132COLUMNS);
	    break;
	case srm_DECSCLM:	/* (slow scroll)        */
	    DoSM(DP_DECSCLM, xw->flags & SMOOTHSCROLL);
	    break;
	case srm_DECSCNM:
	    DoSM(DP_DECSCNM, xw->flags & REVERSE_VIDEO);
	    break;
	case srm_DECOM:
	    DoSM(DP_DECOM, xw->flags & ORIGIN);
	    break;
	case srm_DECAWM:
	    DoSM(DP_DECAWM, xw->flags & WRAPAROUND);
	    break;
	case srm_DECARM:
	    /* ignore autorepeat */
	    break;
	case srm_X10_MOUSE:	/* mouse bogus sequence */
	    DoSM(DP_X_X10MSE, screen->send_mouse_pos);
	    break;
#if OPT_TOOLBAR
	case srm_RXVT_TOOLBAR:
	    DoSM(DP_TOOLBAR, resource.toolBar);
	    break;
#endif
#if OPT_BLINK_CURS
	case srm_ATT610_BLINK:	/* att610: Start/stop blinking cursor */
	    if (screen->cursor_blink_res) {
		DoSM(DP_CRS_BLINK, screen->cursor_blink_esc);
	    }
	    break;
#endif
	case srm_DECPFF:	/* print form feed */
	    DoSM(DP_PRN_FORMFEED, PrinterOf(screen).printer_formfeed);
	    break;
	case srm_DECPEX:	/* print extent */
	    DoSM(DP_PRN_EXTENT, PrinterOf(screen).printer_extent);
	    break;
	case srm_DECTCEM:	/* Show/hide cursor (VT200) */
	    DoSM(DP_CRS_VISIBLE, screen->cursor_set);
	    break;
	case srm_RXVT_SCROLLBAR:
	    DoSM(DP_RXVT_SCROLLBAR, (screen->fullVwin.sb_info.width != 0));
	    break;
#if OPT_SHIFT_FONTS
	case srm_RXVT_FONTSIZE:
	    DoSM(DP_RXVT_FONTSIZE, xw->misc.shift_fonts);
	    break;
#endif
#if OPT_TEK4014
	case srm_DECTEK:
	    DoSM(DP_DECTEK, TEK4014_ACTIVE(xw));
	    break;
#endif
	case srm_132COLS:	/* 132 column mode              */
	    DoSM(DP_X_DECCOLM, screen->c132);
	    break;
	case srm_CURSES_HACK:	/* curses hack                  */
	    DoSM(DP_X_MORE, screen->curses);
	    break;
	case srm_DECNRCM:	/* national charset (VT220) */
	    if (screen->vtXX_level >= 2) {
		DoSM(DP_DECNRCM, xw->flags & NATIONAL);
	    }
	    break;
	case srm_MARGIN_BELL:	/* margin bell                  */
	    DoSM(DP_X_MARGIN, screen->marginbell);
	    break;
	case srm_REVERSEWRAP:	/* reverse wraparound   */
	    DoSM(DP_X_REVWRAP, xw->flags & REVERSEWRAP);
	    break;
#ifdef ALLOWLOGGING
	case srm_ALLOWLOGGING:	/* logging              */
	    DoSM(DP_X_LOGGING, screen->logging);
	    break;
#endif
	case srm_OPT_ALTBUF_CURSOR:
	    /* FALLTHRU */
	case srm_OPT_ALTBUF:
	    /* FALLTHRU */
	case srm_ALTBUF:	/* alternate buffer             */
	    DoSM(DP_X_ALTSCRN, screen->whichBuf);
	    break;
	case srm_DECNKM:
	    DoSM(DP_DECKPAM, xw->keyboard.flags & MODE_DECKPAM);
	    break;
	case srm_DECBKM:	/* backarrow mapping */
	    DoSM(DP_DECBKM, xw->keyboard.flags & MODE_DECBKM);
	    break;
	case srm_DECLRMM:	/* left-right */
	    DoSM(DP_X_LRMM, LEFT_RIGHT);
	    break;
#if OPT_SIXEL_GRAPHICS
	case srm_DECSDM:	/* sixel scrolling */
	    DoSM(DP_DECSDM, xw->keyboard.flags & MODE_DECSDM);
	    update_decsdm();
	    break;
#endif
	case srm_DECNCSM:	/* noclear */
	    DoSM(DP_X_NCSM, NOCLEAR_COLM);
	    break;
	case srm_VT200_MOUSE:	/* mouse bogus sequence         */
	    /* FALLTHRU */
	case srm_VT200_HIGHLIGHT_MOUSE:
	    /* FALLTHRU */
	case srm_BTN_EVENT_MOUSE:
	    /* FALLTHRU */
	case srm_ANY_EVENT_MOUSE:
	    DoSM(DP_X_MOUSE, screen->send_mouse_pos);
	    break;
#if OPT_FOCUS_EVENT
	case srm_FOCUS_EVENT_MOUSE:
	    DoSM(DP_X_FOCUS, screen->send_focus_pos);
	    break;
#endif
	case srm_EXT_MODE_MOUSE:
	    /* FALLTHRU */
	case srm_SGR_EXT_MODE_MOUSE:
	    /* FALLTHRU */
	case srm_URXVT_EXT_MODE_MOUSE:
	    DoSM(DP_X_EXT_MOUSE, screen->extend_coords);
	    break;
	case srm_ALTERNATE_SCROLL:
	    DoSM(DP_ALTERNATE_SCROLL, screen->alternateScroll);
	    break;
	case srm_RXVT_SCROLL_TTY_OUTPUT:
	    DoSM(DP_RXVT_SCROLL_TTY_OUTPUT, screen->scrollttyoutput);
	    break;
	case srm_RXVT_SCROLL_TTY_KEYPRESS:
	    DoSM(DP_RXVT_SCROLL_TTY_KEYPRESS, screen->scrollkey);
	    break;
	case srm_EIGHT_BIT_META:
	    DoSM(DP_EIGHT_BIT_META, screen->eight_bit_meta);
	    break;
#if OPT_NUM_LOCK
	case srm_REAL_NUMLOCK:
	    DoSM(DP_REAL_NUMLOCK, xw->misc.real_NumLock);
	    break;
	case srm_META_SENDS_ESC:
	    DoSM(DP_META_SENDS_ESC, screen->meta_sends_esc);
	    break;
#endif
	case srm_DELETE_IS_DEL:
	    DoSM(DP_DELETE_IS_DEL, screen->delete_is_del);
	    break;
#if OPT_NUM_LOCK
	case srm_ALT_SENDS_ESC:
	    DoSM(DP_ALT_SENDS_ESC, screen->alt_sends_esc);
	    break;
#endif
	case srm_KEEP_SELECTION:
	    DoSM(DP_KEEP_SELECTION, screen->keepSelection);
	    break;
	case srm_SELECT_TO_CLIPBOARD:
	    DoSM(DP_SELECT_TO_CLIPBOARD, screen->selectToClipboard);
	    break;
	case srm_BELL_IS_URGENT:
	    DoSM(DP_BELL_IS_URGENT, screen->bellIsUrgent);
	    break;
	case srm_POP_ON_BELL:
	    DoSM(DP_POP_ON_BELL, screen->poponbell);
	    break;
	case srm_KEEP_CLIPBOARD:
	    DoSM(DP_KEEP_CLIPBOARD, screen->keepClipboard);
	    break;
#if OPT_TCAP_FKEYS
	case srm_TCAP_FKEYS:
	    /* FALLTHRU */
#endif
#if OPT_SUN_FUNC_KEYS
	case srm_SUN_FKEYS:
	    /* FALLTHRU */
#endif
#if OPT_HP_FUNC_KEYS
	case srm_HP_FKEYS:
	    /* FALLTHRU */
#endif
#if OPT_SCO_FUNC_KEYS
	case srm_SCO_FKEYS:
	    /* FALLTHRU */
#endif
#if OPT_SUNPC_KBD
	case srm_VT220_FKEYS:
	    /* FALLTHRU */
#endif
	case srm_LEGACY_FKEYS:
	    DoSM(DP_KEYBOARD_TYPE, xw->keyboard.type);
	    break;
	case srm_TITE_INHIBIT:
	    if (!xw->misc.titeInhibit) {
		CursorSave(xw);
	    }
	    break;
#if OPT_READLINE
	case srm_BUTTON1_MOVE_POINT:
	    SCREEN_FLAG_save(screen, click1_moves);
	    break;
	case srm_BUTTON2_MOVE_POINT:
	    SCREEN_FLAG_save(screen, paste_moves);
	    break;
	case srm_DBUTTON3_DELETE:
	    SCREEN_FLAG_save(screen, dclick3_deletes);
	    break;
	case srm_PASTE_IN_BRACKET:
	    SCREEN_FLAG_save(screen, paste_brackets);
	    break;
	case srm_PASTE_QUOTE:
	    SCREEN_FLAG_save(screen, paste_quotes);
	    break;
	case srm_PASTE_LITERAL_NL:
	    SCREEN_FLAG_save(screen, paste_literal_nl);
	    break;
#endif /* OPT_READLINE */
#if OPT_GRAPHICS
	case srm_PRIVATE_COLOR_REGISTERS:	/* private color registers for each graphic */
	    TRACE(("save PRIVATE_COLOR_REGISTERS %s\n",
		   BtoS(screen->privatecolorregisters)));
	    DoSM(DP_X_PRIVATE_COLOR_REGISTERS, screen->privatecolorregisters);
	    update_privatecolorregisters();
	    break;
#endif
#if OPT_SIXEL_GRAPHICS
	case srm_SIXEL_SCROLLS_RIGHT:
	    TRACE(("save SIXEL_SCROLLS_RIGHT %s\n",
		   BtoS(screen->sixel_scrolls_right)));
	    DoSM(DP_SIXEL_SCROLLS_RIGHT, screen->sixel_scrolls_right);
	    break;
#endif
	}
    }
}

/*
 * process xterm private modes restore
 */
static void
restoremodes(XtermWidget xw)
{
    TScreen *screen = TScreenOf(xw);
    int i, j;

    for (i = 0; i < nparam; i++) {
	int code = GetParam(i);

	TRACE(("restoremodes %d\n", code));
	switch ((DECSET_codes) code) {
	case srm_DECCKM:
	    bitcpy(&xw->keyboard.flags,
		   screen->save_modes[DP_DECCKM], MODE_DECCKM);
	    update_appcursor();
	    break;
	case srm_DECANM:	/* ANSI/VT52 mode      */
	    /* no effect */
	    break;
	case srm_DECCOLM:
	    if (screen->c132) {
		if (!(xw->flags & NOCLEAR_COLM))
		    ClearScreen(xw);
		CursorSet(screen, 0, 0, xw->flags);
		if ((j = (screen->save_modes[DP_DECCOLM] & IN132COLUMNS)
		     ? 132 : 80) != ((xw->flags & IN132COLUMNS)
				     ? 132 : 80) || j != MaxCols(screen))
		    RequestResize(xw, -1, j, True);
		bitcpy(&xw->flags,
		       screen->save_modes[DP_DECCOLM],
		       IN132COLUMNS);
	    }
	    break;
	case srm_DECSCLM:	/* (slow scroll)        */
	    if (screen->save_modes[DP_DECSCLM] & SMOOTHSCROLL) {
		screen->jumpscroll = 0;
		if (screen->scroll_amt)
		    FlushScroll(xw);
	    } else
		screen->jumpscroll = 1;
	    bitcpy(&xw->flags, screen->save_modes[DP_DECSCLM], SMOOTHSCROLL);
	    update_jumpscroll();
	    break;
	case srm_DECSCNM:
	    if ((screen->save_modes[DP_DECSCNM] ^ xw->flags) & REVERSE_VIDEO) {
		bitcpy(&xw->flags, screen->save_modes[DP_DECSCNM], REVERSE_VIDEO);
		ReverseVideo(xw);
		/* update_reversevideo done in RevVid */
	    }
	    break;
	case srm_DECOM:
	    bitcpy(&xw->flags, screen->save_modes[DP_DECOM], ORIGIN);
	    CursorSet(screen, 0, 0, xw->flags);
	    break;

	case srm_DECAWM:
	    bitcpy(&xw->flags, screen->save_modes[DP_DECAWM], WRAPAROUND);
	    update_autowrap();
	    break;
	case srm_DECARM:
	    /* ignore autorepeat */
	    break;
	case srm_X10_MOUSE:	/* MIT bogus sequence           */
	    DoRM0(DP_X_X10MSE, screen->send_mouse_pos);
	    really_set_mousemode(xw,
				 screen->send_mouse_pos != MOUSE_OFF,
				 (XtermMouseModes) screen->send_mouse_pos);
	    break;
#if OPT_TOOLBAR
	case srm_RXVT_TOOLBAR:
	    DoRM(DP_TOOLBAR, resource.toolBar);
	    ShowToolbar(resource.toolBar);
	    break;
#endif
#if OPT_BLINK_CURS
	case srm_ATT610_BLINK:	/* Start/stop blinking cursor */
	    if (screen->cursor_blink_res) {
		DoRM(DP_CRS_BLINK, screen->cursor_blink_esc);
		UpdateCursorBlink(screen);
	    }
	    break;
#endif
	case srm_DECPFF:	/* print form feed */
	    DoRM(DP_PRN_FORMFEED, PrinterOf(screen).printer_formfeed);
	    break;
	case srm_DECPEX:	/* print extent */
	    DoRM(DP_PRN_EXTENT, PrinterOf(screen).printer_extent);
	    break;
	case srm_DECTCEM:	/* Show/hide cursor (VT200) */
	    DoRM(DP_CRS_VISIBLE, screen->cursor_set);
	    break;
	case srm_RXVT_SCROLLBAR:
	    if ((screen->fullVwin.sb_info.width != 0) !=
		screen->save_modes[DP_RXVT_SCROLLBAR]) {
		ToggleScrollBar(xw);
	    }
	    break;
#if OPT_SHIFT_FONTS
	case srm_RXVT_FONTSIZE:
	    DoRM(DP_RXVT_FONTSIZE, xw->misc.shift_fonts);
	    break;
#endif
#if OPT_TEK4014
	case srm_DECTEK:
	    if (!(screen->inhibit & I_TEK) &&
		(TEK4014_ACTIVE(xw) != (Boolean) screen->save_modes[DP_DECTEK])) {
		FlushLog(xw);
		TEK4014_ACTIVE(xw) = (Boolean) screen->save_modes[DP_DECTEK];
		update_vttekmode();
	    }
	    break;
#endif
	case srm_132COLS:	/* 132 column mode              */
	    DoRM(DP_X_DECCOLM, screen->c132);
	    update_allow132();
	    break;
	case srm_CURSES_HACK:	/* curses hack                  */
	    DoRM(DP_X_MORE, screen->curses);
	    update_cursesemul();
	    break;
	case srm_DECNRCM:	/* national charset (VT220) */
	    if (screen->vtXX_level >= 2) {
		if (bitcpy(&xw->flags, screen->save_modes[DP_DECNRCM], NATIONAL))
		    modified_DECNRCM(xw);
	    }
	    break;
	case srm_MARGIN_BELL:	/* margin bell                  */
	    if ((DoRM(DP_X_MARGIN, screen->marginbell)) == 0)
		screen->bellArmed = -1;
	    update_marginbell();
	    break;
	case srm_REVERSEWRAP:	/* reverse wraparound   */
	    bitcpy(&xw->flags, screen->save_modes[DP_X_REVWRAP], REVERSEWRAP);
	    update_reversewrap();
	    break;
#ifdef ALLOWLOGGING
	case srm_ALLOWLOGGING:	/* logging              */
#ifdef ALLOWLOGFILEONOFF
	    if (screen->save_modes[DP_X_LOGGING])
		StartLog(xw);
	    else
		CloseLog(xw);
#endif /* ALLOWLOGFILEONOFF */
	    /* update_logging done by StartLog and CloseLog */
	    break;
#endif
	case srm_OPT_ALTBUF_CURSOR:	/* alternate buffer & cursor */
	    /* FALLTHRU */
	case srm_OPT_ALTBUF:
	    /* FALLTHRU */
	case srm_ALTBUF:	/* alternate buffer */
	    if (!xw->misc.titeInhibit) {
		if (screen->save_modes[DP_X_ALTSCRN])
		    ToAlternate(xw, False);
		else
		    FromAlternate(xw);
		/* update_altscreen done by ToAlt and FromAlt */
	    } else if (screen->save_modes[DP_X_ALTSCRN]) {
		do_ti_xtra_scroll(xw);
	    }
	    break;
	case srm_DECNKM:
	    bitcpy(&xw->flags, screen->save_modes[DP_DECKPAM], MODE_DECKPAM);
	    update_appkeypad();
	    break;
	case srm_DECBKM:	/* backarrow mapping */
	    bitcpy(&xw->flags, screen->save_modes[DP_DECBKM], MODE_DECBKM);
	    update_decbkm();
	    break;
	case srm_DECLRMM:	/* left-right */
	    bitcpy(&xw->flags, screen->save_modes[DP_X_LRMM], LEFT_RIGHT);
	    if (IsLeftRightMode(xw)) {
		xterm_ResetDouble(xw);
	    } else {
		reset_lr_margins(screen);
	    }
	    break;
#if OPT_SIXEL_GRAPHICS
	case srm_DECSDM:	/* sixel scrolling */
	    bitcpy(&xw->keyboard.flags, screen->save_modes[DP_DECSDM], MODE_DECSDM);
	    update_decsdm();
	    break;
#endif
	case srm_DECNCSM:	/* noclear */
	    bitcpy(&xw->flags, screen->save_modes[DP_X_NCSM], NOCLEAR_COLM);
	    break;
	case srm_VT200_MOUSE:	/* mouse bogus sequence         */
	    /* FALLTHRU */
	case srm_VT200_HIGHLIGHT_MOUSE:
	    /* FALLTHRU */
	case srm_BTN_EVENT_MOUSE:
	    /* FALLTHRU */
	case srm_ANY_EVENT_MOUSE:
	    DoRM0(DP_X_MOUSE, screen->send_mouse_pos);
	    really_set_mousemode(xw,
				 screen->send_mouse_pos != MOUSE_OFF,
				 (XtermMouseModes) screen->send_mouse_pos);
	    break;
#if OPT_FOCUS_EVENT
	case srm_FOCUS_EVENT_MOUSE:
	    DoRM(DP_X_FOCUS, screen->send_focus_pos);
	    break;
#endif
	case srm_EXT_MODE_MOUSE:
	    /* FALLTHRU */
	case srm_SGR_EXT_MODE_MOUSE:
	    /* FALLTHRU */
	case srm_URXVT_EXT_MODE_MOUSE:
	    DoRM(DP_X_EXT_MOUSE, screen->extend_coords);
	    break;
	case srm_TITE_INHIBIT:
	    if (!xw->misc.titeInhibit) {
		CursorRestore(xw);
	    }
	    break;
	case srm_ALTERNATE_SCROLL:
	    DoRM(DP_ALTERNATE_SCROLL, screen->alternateScroll);
	    break;
	case srm_RXVT_SCROLL_TTY_OUTPUT:
	    DoRM(DP_RXVT_SCROLL_TTY_OUTPUT, screen->scrollttyoutput);
	    update_scrollttyoutput();
	    break;
	case srm_RXVT_SCROLL_TTY_KEYPRESS:
	    DoRM(DP_RXVT_SCROLL_TTY_KEYPRESS, screen->scrollkey);
	    update_scrollkey();
	    break;
	case srm_EIGHT_BIT_META:
	    DoRM(DP_EIGHT_BIT_META, screen->eight_bit_meta);
	    break;
#if OPT_NUM_LOCK
	case srm_REAL_NUMLOCK:
	    DoRM(DP_REAL_NUMLOCK, xw->misc.real_NumLock);
	    update_num_lock();
	    break;
	case srm_META_SENDS_ESC:
	    DoRM(DP_META_SENDS_ESC, screen->meta_sends_esc);
	    update_meta_esc();
	    break;
#endif
	case srm_DELETE_IS_DEL:
	    DoRM(DP_DELETE_IS_DEL, screen->delete_is_del);
	    update_delete_del();
	    break;
#if OPT_NUM_LOCK
	case srm_ALT_SENDS_ESC:
	    DoRM(DP_ALT_SENDS_ESC, screen->alt_sends_esc);
	    update_alt_esc();
	    break;
#endif
	case srm_KEEP_SELECTION:
	    DoRM(DP_KEEP_SELECTION, screen->keepSelection);
	    update_keepSelection();
	    break;
	case srm_SELECT_TO_CLIPBOARD:
	    DoRM(DP_SELECT_TO_CLIPBOARD, screen->selectToClipboard);
	    update_selectToClipboard();
	    break;
	case srm_BELL_IS_URGENT:
	    DoRM(DP_BELL_IS_URGENT, screen->bellIsUrgent);
	    update_bellIsUrgent();
	    break;
	case srm_POP_ON_BELL:
	    DoRM(DP_POP_ON_BELL, screen->poponbell);
	    update_poponbell();
	    break;
	case srm_KEEP_CLIPBOARD:
	    DoRM(DP_KEEP_CLIPBOARD, screen->keepClipboard);
	    update_keepClipboard();
	    break;
#if OPT_TCAP_FKEYS
	case srm_TCAP_FKEYS:
	    /* FALLTHRU */
#endif
#if OPT_SUN_FUNC_KEYS
	case srm_SUN_FKEYS:
	    /* FALLTHRU */
#endif
#if OPT_HP_FUNC_KEYS
	case srm_HP_FKEYS:
	    /* FALLTHRU */
#endif
#if OPT_SCO_FUNC_KEYS
	case srm_SCO_FKEYS:
	    /* FALLTHRU */
#endif
#if OPT_SUNPC_KBD
	case srm_VT220_FKEYS:
	    /* FALLTHRU */
#endif
	case srm_LEGACY_FKEYS:
	    xw->keyboard.type = (xtermKeyboardType) screen->save_modes[DP_KEYBOARD_TYPE];
	    break;
#if OPT_READLINE
	case srm_BUTTON1_MOVE_POINT:
	    SCREEN_FLAG_restore(screen, click1_moves);
	    break;
	case srm_BUTTON2_MOVE_POINT:
	    SCREEN_FLAG_restore(screen, paste_moves);
	    break;
	case srm_DBUTTON3_DELETE:
	    SCREEN_FLAG_restore(screen, dclick3_deletes);
	    break;
	case srm_PASTE_IN_BRACKET:
	    SCREEN_FLAG_restore(screen, paste_brackets);
	    break;
	case srm_PASTE_QUOTE:
	    SCREEN_FLAG_restore(screen, paste_quotes);
	    break;
	case srm_PASTE_LITERAL_NL:
	    SCREEN_FLAG_restore(screen, paste_literal_nl);
	    break;
#endif /* OPT_READLINE */
#if OPT_GRAPHICS
	case srm_PRIVATE_COLOR_REGISTERS:	/* private color registers for each graphic */
	    TRACE(("restore PRIVATE_COLOR_REGISTERS before: %s\n",
		   BtoS(screen->privatecolorregisters)));
	    DoRM(DP_X_PRIVATE_COLOR_REGISTERS, screen->privatecolorregisters);
	    TRACE(("restore PRIVATE_COLOR_REGISTERS after: %s\n",
		   BtoS(screen->privatecolorregisters)));
	    update_privatecolorregisters();
	    break;
#endif
#if OPT_SIXEL_GRAPHICS
	case srm_SIXEL_SCROLLS_RIGHT:
	    TRACE(("restore SIXEL_SCROLLS_RIGHT before: %s\n",
		   BtoS(screen->sixel_scrolls_right)));
	    DoRM(DP_SIXEL_SCROLLS_RIGHT, screen->sixel_scrolls_right);
	    TRACE(("restore SIXEL_SCROLLS_RIGHT after: %s\n",
		   BtoS(screen->sixel_scrolls_right)));
	    break;
#endif
	}
    }
}

/*
 * Convert an XTextProperty to a string.
 *
 * This frees the data owned by the XTextProperty, and returns in its place the
 * string, which must be freed by the caller.
 */
static char *
property_to_string(XtermWidget xw, XTextProperty * text)
{
    TScreen *screen = TScreenOf(xw);
    Display *dpy = screen->display;
    char *result = 0;
    char **list;
    int length = 0;
    int rc;

    TRACE(("property_to_string value %p, encoding %s, format %d, nitems %ld\n",
	   text->value,
	   TraceAtomName(dpy, text->encoding),
	   text->format,
	   text->nitems));

#if OPT_WIDE_CHARS
    /*
     * We will use the XmbTextPropertyToTextList call to extract UTF-8 data.
     * The xtermUtf8ToTextList() call is used to convert UTF-8 explicitly to
     * ISO-8859-1.
     */
    if ((text->format != 8)
	|| IsTitleMode(xw, tmGetUtf8)
	|| (rc = xtermUtf8ToTextList(xw, text, &list, &length)) < 0)
#endif
	if ((rc = XmbTextPropertyToTextList(dpy, text, &list, &length)) < 0)
	    rc = XTextPropertyToStringList(text, &list, &length);

    if (rc >= 0) {
	int n, c, pass;
	size_t need = 0;

	for (pass = 0; pass < 2; ++pass) {
	    for (n = 0, need = 0; n < length; n++) {
		char *s = list[n];
		while ((c = *s++) != '\0') {
		    if (pass)
			result[need] = (char) c;
		    ++need;
		}
	    }
	    if (pass)
		result[need] = '\0';
	    else
		result = malloc(need + 1);
	    if (result == 0)
		break;
	}
	XFreeStringList(list);
    }
    if (text->value != 0)
	XFree(text->value);

    return result;
}

static char *
get_icon_label(XtermWidget xw)
{
    XTextProperty text;
    char *result = 0;

    if (XGetWMIconName(TScreenOf(xw)->display, VShellWindow(xw), &text)) {
	result = property_to_string(xw, &text);
    }
    return result;
}

static char *
get_window_label(XtermWidget xw)
{
    XTextProperty text;
    char *result = 0;

    if (XGetWMName(TScreenOf(xw)->display, VShellWindow(xw), &text)) {
	result = property_to_string(xw, &text);
    }
    return result;
}

/*
 * Report window label (icon or title) in dtterm protocol
 * ESC ] code label ESC backslash
 */
static void
report_win_label(XtermWidget xw,
		 int code,
		 char *text)
{
    unparseputc(xw, ANSI_ESC);
    unparseputc(xw, ']');
    unparseputc(xw, code);

    if (text != 0) {
	int copy = IsTitleMode(xw, tmGetBase16);
	if (copy) {
	    TRACE(("Encoding hex:%s\n", text));
	    text = x_encode_hex(text);
	}
	unparseputs(xw, text);
	if (copy)
	    free(text);
    }

    unparseputc(xw, ANSI_ESC);
    unparseputc(xw, '\\');	/* should be ST */
    unparse_end(xw);
}

/*
 * Window operations (from CDE dtterm description, as well as extensions).
 * See also "allowWindowOps" resource.
 */
static void
window_ops(XtermWidget xw)
{
    TScreen *screen = TScreenOf(xw);
    XWindowChanges values;
    XWindowAttributes win_attrs;
#if OPT_MAXIMIZE
    unsigned root_width;
    unsigned root_height;
#endif
    int code = zero_if_default(0);
    char *label;

    TRACE(("window_ops %d\n", code));
    switch (code) {
    case ewRestoreWin:		/* Restore (de-iconify) window */
	if (AllowWindowOps(xw, ewRestoreWin)) {
	    TRACE(("...de-iconify window\n"));
	    XMapWindow(screen->display,
		       VShellWindow(xw));
	}
	break;

    case ewMinimizeWin:	/* Minimize (iconify) window */
	if (AllowWindowOps(xw, ewMinimizeWin)) {
	    TRACE(("...iconify window\n"));
	    XIconifyWindow(screen->display,
			   VShellWindow(xw),
			   DefaultScreen(screen->display));
	}
	break;

    case ewSetWinPosition:	/* Move the window to the given position */
	if (AllowWindowOps(xw, ewSetWinPosition)) {
	    unsigned value_mask;

	    values.x = zero_if_default(1);
	    values.y = zero_if_default(2);
	    TRACE(("...move window to %d,%d\n", values.x, values.y));
	    value_mask = (CWX | CWY);
	    XReconfigureWMWindow(screen->display,
				 VShellWindow(xw),
				 DefaultScreen(screen->display),
				 value_mask,
				 &values);
	}
	break;

    case ewSetWinSizePixels:	/* Resize the window to given size in pixels */
	if (AllowWindowOps(xw, ewSetWinSizePixels)) {
	    RequestResize(xw, optional_param(1), optional_param(2), False);
	}
	break;

    case ewRaiseWin:		/* Raise the window to the front of the stack */
	if (AllowWindowOps(xw, ewRaiseWin)) {
	    TRACE(("...raise window\n"));
	    XRaiseWindow(screen->display, VShellWindow(xw));
	}
	break;

    case ewLowerWin:		/* Lower the window to the bottom of the stack */
	if (AllowWindowOps(xw, ewLowerWin)) {
	    TRACE(("...lower window\n"));
	    XLowerWindow(screen->display, VShellWindow(xw));
	}
	break;

    case ewRefreshWin:		/* Refresh the window */
	if (AllowWindowOps(xw, ewRefreshWin)) {
	    TRACE(("...redraw window\n"));
	    Redraw();
	}
	break;

    case ewSetWinSizeChars:	/* Resize the text-area, in characters */
	if (AllowWindowOps(xw, ewSetWinSizeChars)) {
	    RequestResize(xw, optional_param(1), optional_param(2), True);
	}
	break;

#if OPT_MAXIMIZE
    case ewMaximizeWin:	/* Maximize or restore */
	if (AllowWindowOps(xw, ewMaximizeWin)) {
	    RequestMaximize(xw, zero_if_default(1));
	}
	break;
    case ewFullscreenWin:	/* Fullscreen or restore */
	if (AllowWindowOps(xw, ewFullscreenWin)) {
	    FullScreen(xw, zero_if_default(1));
	}
	break;
#endif

    case ewGetWinState:	/* Report the window's state */
	if (AllowWindowOps(xw, ewGetWinState)) {
	    TRACE(("...get window attributes\n"));
	    xtermGetWinAttrs(screen->display,
			     VWindow(screen),
			     &win_attrs);
	    init_reply(ANSI_CSI);
	    reply.a_pintro = 0;
	    reply.a_nparam = 1;
	    reply.a_param[0] = (ParmType) ((win_attrs.map_state == IsViewable)
					   ? 1
					   : 2);
	    reply.a_inters = 0;
	    reply.a_final = 't';
	    unparseseq(xw, &reply);
	}
	break;

    case ewGetWinPosition:	/* Report the window's position */
	if (AllowWindowOps(xw, ewGetWinPosition)) {
	    TRACE(("...get window position\n"));
	    xtermGetWinAttrs(screen->display,
			     WMFrameWindow(xw),
			     &win_attrs);
	    init_reply(ANSI_CSI);
	    reply.a_pintro = 0;
	    reply.a_nparam = 3;
	    reply.a_param[0] = 3;
	    reply.a_param[1] = (ParmType) win_attrs.x;
	    reply.a_param[2] = (ParmType) win_attrs.y;
	    reply.a_inters = 0;
	    reply.a_final = 't';
	    unparseseq(xw, &reply);
	}
	break;

    case ewGetWinSizePixels:	/* Report the window's size in pixels */
	if (AllowWindowOps(xw, ewGetWinSizePixels)) {
	    TRACE(("...get window size in pixels\n"));
	    init_reply(ANSI_CSI);
	    reply.a_pintro = 0;
	    reply.a_nparam = 3;
	    reply.a_param[0] = 4;
	    reply.a_param[1] = (ParmType) Height(screen);
	    reply.a_param[2] = (ParmType) Width(screen);
	    reply.a_inters = 0;
	    reply.a_final = 't';
	    unparseseq(xw, &reply);
	}
	break;

    case ewGetWinSizeChars:	/* Report the text's size in characters */
	if (AllowWindowOps(xw, ewGetWinSizeChars)) {
	    TRACE(("...get window size in characters\n"));
	    init_reply(ANSI_CSI);
	    reply.a_pintro = 0;
	    reply.a_nparam = 3;
	    reply.a_param[0] = 8;
	    reply.a_param[1] = (ParmType) MaxRows(screen);
	    reply.a_param[2] = (ParmType) MaxCols(screen);
	    reply.a_inters = 0;
	    reply.a_final = 't';
	    unparseseq(xw, &reply);
	}
	break;

#if OPT_MAXIMIZE
    case ewGetScreenSizeChars:	/* Report the screen's size, in characters */
	if (AllowWindowOps(xw, ewGetScreenSizeChars)) {
	    TRACE(("...get screen size in characters\n"));
	    TRACE(("...using font size %dx%d\n",
		   FontHeight(screen),
		   FontWidth(screen)));
	    (void) QueryMaximize(xw, &root_width, &root_height);
	    init_reply(ANSI_CSI);
	    reply.a_pintro = 0;
	    reply.a_nparam = 3;
	    reply.a_param[0] = 9;
	    reply.a_param[1] = (ParmType) (root_height
					   / (unsigned) FontHeight(screen));
	    reply.a_param[2] = (ParmType) (root_width
					   / (unsigned) FontWidth(screen));
	    reply.a_inters = 0;
	    reply.a_final = 't';
	    unparseseq(xw, &reply);
	}
	break;
#endif

    case ewGetIconTitle:	/* Report the icon's label */
	if (AllowWindowOps(xw, ewGetIconTitle)) {
	    TRACE(("...get icon's label\n"));
	    report_win_label(xw, 'L', label = get_icon_label(xw));
	    free(label);
	}
	break;

    case ewGetWinTitle:	/* Report the window's title */
	if (AllowWindowOps(xw, ewGetWinTitle)) {
	    TRACE(("...get window's label\n"));
	    report_win_label(xw, 'l', label = get_window_label(xw));
	    free(label);
	}
	break;

    case ewPushTitle:		/* save the window's title(s) on stack */
	if (AllowWindowOps(xw, ewPushTitle)) {
	    SaveTitle *last = screen->save_title;
	    SaveTitle *item = TypeCalloc(SaveTitle);

	    TRACE(("...push title onto stack\n"));
	    if (item != 0) {
		switch (zero_if_default(1)) {
		case 0:
		    item->iconName = get_icon_label(xw);
		    item->windowName = get_window_label(xw);
		    break;
		case 1:
		    item->iconName = get_icon_label(xw);
		    break;
		case 2:
		    item->windowName = get_window_label(xw);
		    break;
		}
		item->next = last;
		if (item->iconName == 0) {
		    item->iconName = ((last == 0)
				      ? get_icon_label(xw)
				      : x_strdup(last->iconName));
		}
		if (item->windowName == 0) {
		    item->windowName = ((last == 0)
					? get_window_label(xw)
					: x_strdup(last->windowName));
		}
		screen->save_title = item;
	    }
	}
	break;

    case ewPopTitle:		/* restore the window's title(s) from stack */
	if (AllowWindowOps(xw, ewPopTitle)) {
	    SaveTitle *item = screen->save_title;

	    TRACE(("...pop title off stack\n"));
	    if (item != 0) {
		switch (zero_if_default(1)) {
		case 0:
		    ChangeIconName(xw, item->iconName);
		    ChangeTitle(xw, item->windowName);
		    break;
		case 1:
		    ChangeIconName(xw, item->iconName);
		    break;
		case 2:
		    ChangeTitle(xw, item->windowName);
		    break;
		}
		screen->save_title = item->next;
		free(item->iconName);
		free(item->windowName);
		free(item);
	    }
	}
	break;

    default:			/* DECSLPP (24, 25, 36, 48, 72, 144) */
	if (AllowWindowOps(xw, ewSetWinLines)) {
	    if (code >= 24)
		RequestResize(xw, code, -1, True);
	}
	break;
    }
}

/*
 * set a bit in a word given a pointer to the word and a mask.
 */
static int
bitset(unsigned *p, unsigned mask)
{
    unsigned before = *p;
    *p |= mask;
    return (before != *p);
}

/*
 * clear a bit in a word given a pointer to the word and a mask.
 */
static int
bitclr(unsigned *p, unsigned mask)
{
    unsigned before = *p;
    *p &= ~mask;
    return (before != *p);
}

/*
 * Copy bits from one word to another, given a mask
 */
static int
bitcpy(unsigned *p, unsigned q, unsigned mask)
{
    unsigned before = *p;
    bitclr(p, mask);
    bitset(p, q & mask);
    return (before != *p);
}

void
unparseputc1(XtermWidget xw, int c)
{
    if (c >= 0x80 && c <= 0x9F) {
	if (!TScreenOf(xw)->control_eight_bits) {
	    unparseputc(xw, A2E(ANSI_ESC));
	    c = A2E(c - 0x40);
	}
    }
    unparseputc(xw, c);
}

void
unparseseq(XtermWidget xw, ANSI *ap)
{
    int c;

    unparseputc1(xw, c = ap->a_type);
    if (c == ANSI_ESC
	|| c == ANSI_DCS
	|| c == ANSI_CSI
	|| c == ANSI_OSC
	|| c == ANSI_PM
	|| c == ANSI_APC
	|| c == ANSI_SS3) {
	int i;
	int inters;

	if (ap->a_pintro != 0)
	    unparseputc(xw, ap->a_pintro);
	for (i = 0; i < ap->a_nparam; ++i) {
	    if (i != 0) {
		if (ap->a_delim) {
		    unparseputs(xw, ap->a_delim);
		} else {
		    unparseputc(xw, ';');
		}
	    }
	    if (ap->a_radix[i]) {
		char temp[8];
		sprintf(temp, "%04X", ap->a_param[i] & 0xffff);
		unparseputs(xw, temp);
	    } else {
		unparseputn(xw, (unsigned int) ap->a_param[i]);
	    }
	}
	if ((inters = ap->a_inters) != 0) {
	    for (i = 3; i >= 0; --i) {
		c = CharOf(inters >> (8 * i));
		if (c != 0)
		    unparseputc(xw, c);
	    }
	}
	switch (ap->a_type) {
	case ANSI_DCS:
	    /* FALLTHRU */
	case ANSI_OSC:
	    /* FALLTHRU */
	case ANSI_PM:
	    /* FALLTHRU */
	case ANSI_APC:
	    unparseputc1(xw, ANSI_ST);
	    break;
	default:
	    unparseputc(xw, (char) ap->a_final);
	    break;
	}
    }
    unparse_end(xw);
}

void
unparseputn(XtermWidget xw, unsigned int n)
{
    unsigned int q;

    q = n / 10;
    if (q != 0)
	unparseputn(xw, q);
    unparseputc(xw, (char) ('0' + (n % 10)));
}

void
unparseputs(XtermWidget xw, const char *s)
{
    if (s != 0) {
	while (*s)
	    unparseputc(xw, *s++);
    }
}

void
unparseputc(XtermWidget xw, int c)
{
    TScreen *screen = TScreenOf(xw);
    IChar *buf = screen->unparse_bfr;
    unsigned len;

    if ((screen->unparse_len + 2) >= sizeof(screen->unparse_bfr) / sizeof(IChar))
	  unparse_end(xw);

    len = screen->unparse_len;

#if OPT_TCAP_QUERY
    /*
     * If we're returning a termcap string, it has to be translated since
     * a DCS must not contain any characters except for the normal 7-bit
     * printable ASCII (counting tab, carriage return, etc).  For now,
     * just use hexadecimal for the whole thing.
     */
    if (screen->tc_query_code >= 0) {
	char tmp[3];
	sprintf(tmp, "%02X", c & 0xFF);
	buf[len++] = CharOf(tmp[0]);
	buf[len++] = CharOf(tmp[1]);
    } else
#endif
    if ((buf[len++] = (IChar) c) == '\r' && (xw->flags & LINEFEED)) {
	buf[len++] = '\n';
    }

    screen->unparse_len = len;

    /* If send/receive mode is reset, we echo characters locally */
    if ((xw->keyboard.flags & MODE_SRM) == 0) {
	(void) doparsing(xw, (unsigned) c, &myState);
    }
}

void
unparse_end(XtermWidget xw)
{
    TScreen *screen = TScreenOf(xw);

    if (screen->unparse_len) {
#ifdef VMS
	tt_write(screen->unparse_bfr, screen->unparse_len);
#else /* VMS */
	writePtyData(screen->respond, screen->unparse_bfr, screen->unparse_len);
#endif /* VMS */
	screen->unparse_len = 0;
    }
}

void
ToggleAlternate(XtermWidget xw)
{
    if (TScreenOf(xw)->whichBuf)
	FromAlternate(xw);
    else
	ToAlternate(xw, False);
}

static void
ToAlternate(XtermWidget xw, Bool clearFirst)
{
    TScreen *screen = TScreenOf(xw);

    if (screen->whichBuf == 0) {
	TRACE(("ToAlternate\n"));
	if (!screen->editBuf_index[1])
	    screen->editBuf_index[1] = allocScrnBuf(xw,
						    (unsigned) MaxRows(screen),
						    (unsigned) MaxCols(screen),
						    &screen->editBuf_data[1]);
	SwitchBufs(xw, 1, clearFirst);
#if OPT_SAVE_LINES
	screen->visbuf = screen->editBuf_index[screen->whichBuf];
#endif
	update_altscreen();
    }
}

static void
FromAlternate(XtermWidget xw)
{
    TScreen *screen = TScreenOf(xw);

    if (screen->whichBuf != 0) {
	TRACE(("FromAlternate\n"));
	if (screen->scroll_amt)
	    FlushScroll(xw);
	SwitchBufs(xw, 0, False);
#if OPT_SAVE_LINES
	screen->visbuf = screen->editBuf_index[screen->whichBuf];
#endif
	update_altscreen();
    }
}

static void
SwitchBufs(XtermWidget xw, int toBuf, Bool clearFirst)
{
    TScreen *screen = TScreenOf(xw);
    int rows, top;

    screen->whichBuf = toBuf;
    if (screen->cursor_state)
	HideCursor();

    rows = MaxRows(screen);
    SwitchBufPtrs(screen, toBuf);

    if ((top = INX2ROW(screen, 0)) < rows) {
	if (screen->scroll_amt) {
	    FlushScroll(xw);
	}
#if OPT_DOUBLE_BUFFER
	XFillRectangle(screen->display,
		       VDrawable(screen),
		       ReverseGC(xw, screen),
		       (int) OriginX(screen),
		       (int) top * FontHeight(screen) + screen->border,
		       (unsigned) Width(screen),
		       (unsigned) ((rows - top) * FontHeight(screen)));
#else
	XClearArea(screen->display,
		   VWindow(screen),
		   (int) OriginX(screen),
		   (int) top * FontHeight(screen) + screen->border,
		   (unsigned) Width(screen),
		   (unsigned) ((rows - top) * FontHeight(screen)),
		   False);
#endif
	if (clearFirst) {
	    ClearBufRows(xw, top, rows);
	}
    }
    ScrnUpdate(xw, 0, 0, rows, MaxCols(screen), False);
}

Bool
CheckBufPtrs(TScreen *screen)
{
    return (screen->visbuf != 0
#if OPT_SAVE_LINES
	    && screen->editBuf_index[0] != 0
#endif
	    && screen->editBuf_index[1] != 0);
}

/*
 * Swap buffer line pointers between alternate and regular screens.
 */
void
SwitchBufPtrs(TScreen *screen, int toBuf GCC_UNUSED)
{
    if (CheckBufPtrs(screen)) {
#if OPT_SAVE_LINES
	screen->visbuf = screen->editBuf_index[toBuf];
#else
	size_t len = ScrnPointers(screen, (size_t) MaxRows(screen));

	memcpy(screen->save_ptr, screen->visbuf, len);
	memcpy(screen->visbuf, screen->editBuf_index[1], len);
	memcpy(screen->editBuf_index[1], screen->save_ptr, len);
#endif
    }
}

void
VTRun(XtermWidget xw)
{
    TScreen *screen = TScreenOf(xw);

    TRACE(("VTRun ...\n"));

    if (!screen->Vshow) {
	set_vt_visibility(True);
    }
    update_vttekmode();
    update_vtshow();
    update_tekshow();
    set_vthide_sensitivity();

    ScrnAllocBuf(xw);

    screen->cursor_state = OFF;
    screen->cursor_set = ON;
#if OPT_BLINK_CURS
    if (DoStartBlinking(screen))
	StartBlinking(screen);
#endif

#if OPT_TEK4014
    if (Tpushb > Tpushback) {
	fillPtyData(xw, VTbuffer, (char *) Tpushback, (int) (Tpushb - Tpushback));
	Tpushb = Tpushback;
    }
#endif
    screen->is_running = True;
    if (screen->embed_high && screen->embed_wide) {
	ScreenResize(xw, screen->embed_wide, screen->embed_high, &(xw->flags));
    }
#if OPT_MAXIMIZE
    else if (resource.fullscreen == esTrue || resource.fullscreen == esAlways)
	FullScreen(term, True);
#endif
    if (!setjmp(VTend))
	VTparse(xw);
    StopBlinking(screen);
    HideCursor();
    screen->cursor_set = OFF;
    TRACE(("... VTRun\n"));
}

/*ARGSUSED*/
static void
VTExpose(Widget w GCC_UNUSED,
	 XEvent *event,
	 Region region GCC_UNUSED)
{
    DEBUG_MSG("Expose\n");
    if (event->type == Expose)
	HandleExposure(term, event);
}

static void
VTGraphicsOrNoExpose(XEvent *event)
{
    TScreen *screen = TScreenOf(term);
    if (screen->incopy <= 0) {
	screen->incopy = 1;
	if (screen->scrolls > 0)
	    screen->scrolls--;
    }
    if (event->type == GraphicsExpose)
	if (HandleExposure(term, event))
	    screen->cursor_state = OFF;
    if ((event->type == NoExpose)
	|| ((XGraphicsExposeEvent *) event)->count == 0) {
	if (screen->incopy <= 0 && screen->scrolls > 0)
	    screen->scrolls--;
	if (screen->scrolls)
	    screen->incopy = -1;
	else
	    screen->incopy = 0;
    }
}

/*ARGSUSED*/
static void
VTNonMaskableEvent(Widget w GCC_UNUSED,
		   XtPointer closure GCC_UNUSED,
		   XEvent *event,
		   Boolean *cont GCC_UNUSED)
{
    switch (event->type) {
    case GraphicsExpose:
	/* FALLTHRU */
    case NoExpose:
	VTGraphicsOrNoExpose(event);
	break;
    }
}

static void
VTResize(Widget w)
{
    if (XtIsRealized(w)) {
	XtermWidget xw = (XtermWidget) w;
	ScreenResize(xw, xw->core.width, xw->core.height, &xw->flags);
    }
}

#define okDimension(src,dst) ((src <= 32767) \
			  && ((dst = (Dimension) src) == src))

static void
RequestResize(XtermWidget xw, int rows, int cols, Bool text)
{
    TScreen *screen = TScreenOf(xw);
    Dimension replyWidth, replyHeight;
    Dimension askedWidth, askedHeight;
    XtGeometryResult status;
    XWindowAttributes attrs;

    TRACE(("RequestResize(rows=%d, cols=%d, text=%d)\n", rows, cols, text));

    /* check first if the row/column values fit into a Dimension */
    if (cols > 0) {
	if ((int) (askedWidth = (Dimension) cols) < cols) {
	    TRACE(("... cols too large for Dimension\n"));
	    return;
	}
    } else {
	askedWidth = 0;
    }
    if (rows > 0) {
	if ((int) (askedHeight = (Dimension) rows) < rows) {
	    TRACE(("... rows too large for Dimension\n"));
	    return;
	}
    } else {
	askedHeight = 0;
    }

    if (askedHeight == 0
	|| askedWidth == 0
	|| xw->misc.limit_resize > 0) {
	xtermGetWinAttrs(XtDisplay(xw),
			 RootWindowOfScreen(XtScreen(xw)), &attrs);
    }

    if (text) {
	unsigned long value;

	if ((value = (unsigned long) rows) != 0) {
	    if (rows < 0)
		value = (unsigned long) MaxRows(screen);
	    value *= (unsigned long) FontHeight(screen);
	    value += (unsigned long) (2 * screen->border);
	    if (!okDimension(value, askedHeight))
		return;
	}

	if ((value = (unsigned long) cols) != 0) {
	    if (cols < 0)
		value = (unsigned long) MaxCols(screen);
	    value *= (unsigned long) FontWidth(screen);
	    value += (unsigned long) ((2 * screen->border)
				      + ScrollbarWidth(screen));
	    if (!okDimension(value, askedWidth))
		return;
	}

    } else {
	if (rows < 0)
	    askedHeight = FullHeight(screen);
	if (cols < 0)
	    askedWidth = FullWidth(screen);
    }

    if (rows == 0)
	askedHeight = (Dimension) attrs.height;
    if (cols == 0)
	askedWidth = (Dimension) attrs.width;

    if (xw->misc.limit_resize > 0) {
	Dimension high = (Dimension) (xw->misc.limit_resize * attrs.height);
	Dimension wide = (Dimension) (xw->misc.limit_resize * attrs.width);
	if ((int) high < attrs.height)
	    high = (Dimension) attrs.height;
	if (askedHeight > high)
	    askedHeight = high;
	if ((int) wide < attrs.width)
	    wide = (Dimension) attrs.width;
	if (askedWidth > wide)
	    askedWidth = wide;
    }
#ifndef nothack
    getXtermSizeHints(xw);
#endif

    TRACE(("...requesting resize %dx%d\n", askedHeight, askedWidth));
    status = REQ_RESIZE((Widget) xw,
			askedWidth, askedHeight,
			&replyWidth, &replyHeight);

    if (status == XtGeometryYes ||
	status == XtGeometryDone) {
	ScreenResize(xw, replyWidth, replyHeight, &xw->flags);
    }
#ifndef nothack
    /*
     * XtMakeResizeRequest() has the undesirable side-effect of clearing
     * the window manager's hints, even on a failed request.  This would
     * presumably be fixed if the shell did its own work.
     */
    if (xw->hints.flags
	&& replyHeight
	&& replyWidth) {
	xw->hints.height = replyHeight;
	xw->hints.width = replyWidth;

	TRACE(("%s@@%d -- ", __FILE__, __LINE__));
	TRACE_HINTS(&xw->hints);
	XSetWMNormalHints(screen->display, VShellWindow(xw), &xw->hints);
	TRACE(("%s@@%d -- ", __FILE__, __LINE__));
	TRACE_WM_HINTS(xw);
    }
#endif

    XSync(screen->display, False);	/* synchronize */
    if (xtermAppPending())
	xevents();

    TRACE(("...RequestResize done\n"));
}

static String xterm_trans =
"<ClientMessage>WM_PROTOCOLS: DeleteWindow()\n\
     <MappingNotify>: KeyboardMapping()\n";

int
VTInit(XtermWidget xw)
{
    Widget vtparent = SHELL_OF(xw);

    TRACE(("VTInit {{\n"));

    XtRealizeWidget(vtparent);
    XtOverrideTranslations(vtparent, XtParseTranslationTable(xterm_trans));
    (void) XSetWMProtocols(XtDisplay(vtparent), XtWindow(vtparent),
			   &wm_delete_window, 1);
    TRACE_TRANS("shell", vtparent);
    TRACE_TRANS("vt100", (Widget) (xw));

    ScrnAllocBuf(xw);

    TRACE(("...}} VTInit\n"));
    return (1);
}

static void
VTClassInit(void)
{
    XtAddConverter(XtRString, XtRGravity, XmuCvtStringToGravity,
		   (XtConvertArgList) NULL, (Cardinal) 0);
}

#if OPT_COLOR_RES
/*
 * Override the use of XtDefaultForeground/XtDefaultBackground to make some
 * colors, such as cursor color, use the actual foreground/background value
 * if there is no explicit resource value used.
 */
static Pixel
fill_Tres(XtermWidget target, XtermWidget source, int offset)
{
    char *name;
    ScrnColors temp;
    TScreen *src = TScreenOf(source);
    TScreen *dst = TScreenOf(target);

    dst->Tcolors[offset] = src->Tcolors[offset];
    dst->Tcolors[offset].mode = False;

    if ((name = x_strtrim(dst->Tcolors[offset].resource)) != 0)
	dst->Tcolors[offset].resource = name;

    if (name == 0) {
	dst->Tcolors[offset].value = target->dft_foreground;
    } else if (isDefaultForeground(name)) {
	dst->Tcolors[offset].value = ((offset == TEXT_FG || offset == TEXT_BG)
				      ? target->dft_foreground
				      : dst->Tcolors[TEXT_FG].value);
    } else if (isDefaultBackground(name)) {
	dst->Tcolors[offset].value = ((offset == TEXT_FG || offset == TEXT_BG)
				      ? target->dft_background
				      : dst->Tcolors[TEXT_BG].value);
    } else {
	memset(&temp, 0, sizeof(temp));
	if (AllocateTermColor(target, &temp, offset, name, True)) {
	    if (COLOR_DEFINED(&(temp), offset))
		free(temp.names[offset]);
	    dst->Tcolors[offset].value = temp.colors[offset];
	} else if (offset == TEXT_FG || offset == TEXT_BG) {
	    free(name);
	    dst->Tcolors[offset].resource = 0;
	}
    }
    return dst->Tcolors[offset].value;
}

/*
 * If one or both of the foreground/background colors cannot be allocated,
 * e.g., due to gross misconfiguration, recover by setting both to the
 * display's default values.
 */
static void
repairColors(XtermWidget target)
{
    TScreen *screen = TScreenOf(target);

    if (screen->Tcolors[TEXT_FG].resource == 0 ||
	screen->Tcolors[TEXT_BG].resource == 0) {
	xtermWarning("unable to allocate fg/bg colors\n");
	screen->Tcolors[TEXT_FG].resource = x_strdup(XtDefaultForeground);
	screen->Tcolors[TEXT_BG].resource = x_strdup(XtDefaultBackground);
	if (screen->Tcolors[TEXT_FG].resource == 0 ||
	    screen->Tcolors[TEXT_BG].resource == 0) {
	    Exit(1);
	}
	screen->Tcolors[TEXT_FG].value = target->dft_foreground;
	screen->Tcolors[TEXT_BG].value = target->dft_background;
    }
}
#else
#define fill_Tres(target, source, offset) \
	TScreenOf(target)->Tcolors[offset] = TScreenOf(source)->Tcolors[offset]
#define repairColors(target)	/* nothing */
#endif

#if OPT_WIDE_CHARS
static void
VTInitialize_locale(XtermWidget xw)
{
    TScreen *screen = TScreenOf(xw);
    Bool is_utf8 = xtermEnvUTF8();

    TRACE(("VTInitialize_locale\n"));
    TRACE(("... request screen.utf8_mode = %d\n", screen->utf8_mode));
    TRACE(("... request screen.utf8_fonts = %d\n", screen->utf8_fonts));

    screen->utf8_always = (screen->utf8_mode == uAlways);
    if (screen->utf8_mode < 0)
	screen->utf8_mode = uFalse;

    if (screen->utf8_mode > 3)
	screen->utf8_mode = uDefault;

    screen->latin9_mode = 0;
    screen->unicode_font = 0;
#if OPT_LUIT_PROG
    xw->misc.callfilter = 0;
    xw->misc.use_encoding = 0;

    TRACE(("... setup for luit:\n"));
    TRACE(("... request misc.locale_str = \"%s\"\n", xw->misc.locale_str));

    if (screen->utf8_mode == uFalse) {
	TRACE(("... command-line +u8 overrides\n"));
    } else
#if OPT_MINI_LUIT
    if (x_strcasecmp(xw->misc.locale_str, "CHECKFONT") == 0) {
	int fl = (int) strlen(DefaultFontN(xw));
	if (fl > 11
	    && x_strcasecmp(DefaultFontN(xw) + fl - 11, "-ISO10646-1") == 0) {
	    screen->unicode_font = 1;
	    /* unicode font, use True */
#ifdef HAVE_LANGINFO_CODESET
	    if (!strcmp(xtermEnvEncoding(), "ANSI_X3.4-1968")
		|| !strcmp(xtermEnvEncoding(), "ISO-8859-1")) {
		if (screen->utf8_mode == uDefault)
		    screen->utf8_mode = uFalse;
	    } else if (!strcmp(xtermEnvEncoding(), "ISO-8859-15")) {
		if (screen->utf8_mode == uDefault)
		    screen->utf8_mode = uFalse;
		screen->latin9_mode = 1;
	    } else {
		xw->misc.callfilter = (Boolean) (is_utf8 ? 0 : 1);
		screen->utf8_mode = uAlways;
	    }
#else
	    xw->misc.callfilter = is_utf8 ? 0 : 1;
	    screen->utf8_mode = uAlways;
#endif
	} else {
	    /* other encoding, use False */
	    if (screen->utf8_mode == uDefault) {
		screen->utf8_mode = is_utf8 ? uAlways : uFalse;
	    }
	}
    } else
#endif /* OPT_MINI_LUIT */
	if (x_strcasecmp(xw->misc.locale_str, "TRUE") == 0 ||
	    x_strcasecmp(xw->misc.locale_str, "ON") == 0 ||
	    x_strcasecmp(xw->misc.locale_str, "YES") == 0 ||
	    x_strcasecmp(xw->misc.locale_str, "AUTO") == 0 ||
	    strcmp(xw->misc.locale_str, "1") == 0) {
	/* when true ... fully obeying LC_CTYPE locale */
	xw->misc.callfilter = (Boolean) (is_utf8 ? 0 : 1);
	screen->utf8_mode = uAlways;
    } else if (x_strcasecmp(xw->misc.locale_str, "FALSE") == 0 ||
	       x_strcasecmp(xw->misc.locale_str, "OFF") == 0 ||
	       x_strcasecmp(xw->misc.locale_str, "NO") == 0 ||
	       strcmp(xw->misc.locale_str, "0") == 0) {
	/* when false ... original value of utf8_mode is effective */
	if (screen->utf8_mode == uDefault) {
	    screen->utf8_mode = is_utf8 ? uAlways : uFalse;
	}
    } else if (x_strcasecmp(xw->misc.locale_str, "MEDIUM") == 0 ||
	       x_strcasecmp(xw->misc.locale_str, "SEMIAUTO") == 0) {
	/* when medium ... obeying locale only for UTF-8 and Asian */
	if (is_utf8) {
	    screen->utf8_mode = uAlways;
	} else if (
#ifdef MB_CUR_MAX
		      MB_CUR_MAX > 1 ||
#else
		      !strncmp(xtermEnvLocale(), "ja", (size_t) 2) ||
		      !strncmp(xtermEnvLocale(), "ko", (size_t) 2) ||
		      !strncmp(xtermEnvLocale(), "zh", (size_t) 2) ||
#endif
		      !strncmp(xtermEnvLocale(), "th", (size_t) 2) ||
		      !strncmp(xtermEnvLocale(), "vi", (size_t) 2)) {
	    xw->misc.callfilter = 1;
	    screen->utf8_mode = uAlways;
	} else {
	    screen->utf8_mode = uFalse;
	}
    } else if (x_strcasecmp(xw->misc.locale_str, "UTF-8") == 0 ||
	       x_strcasecmp(xw->misc.locale_str, "UTF8") == 0) {
	/* when UTF-8 ... UTF-8 mode */
	screen->utf8_mode = uAlways;
    } else {
	/* other words are regarded as encoding name passed to luit */
	xw->misc.callfilter = 1;
	screen->utf8_mode = uAlways;
	xw->misc.use_encoding = 1;
    }
    TRACE(("... updated misc.callfilter = %s\n", BtoS(xw->misc.callfilter)));
    TRACE(("... updated misc.use_encoding = %s\n", BtoS(xw->misc.use_encoding)));
#else
    if (screen->utf8_mode == uDefault) {
	screen->utf8_mode = is_utf8 ? uAlways : uFalse;
    }
#endif /* OPT_LUIT_PROG */

    if (screen->utf8_fonts == uDefault) {
	switch (screen->utf8_mode) {
	case uFalse:
	    /* FALLTHRU */
	case uTrue:
	    screen->utf8_fonts = screen->utf8_mode;
	    break;
	case uDefault:
	    /* should not happen */
	    screen->utf8_fonts = uTrue;
	    break;
	case uAlways:
	    /* use this to disable menu entry */
	    break;
	}
    }

    screen->utf8_inparse = (Boolean) (screen->utf8_mode != uFalse);

    TRACE(("... updated screen.utf8_mode = %d\n", screen->utf8_mode));
    TRACE(("... updated screen.utf8_fonts = %d\n", screen->utf8_fonts));
    TRACE(("...VTInitialize_locale done\n"));
}
#endif

void
lookupSelectUnit(XtermWidget xw, Cardinal item, String value)
{
    /* *INDENT-OFF* */
    static const struct {
	const char *	name;
	SelectUnit	code;
    } table[] = {
    	{ "char",	Select_CHAR },
    	{ "word",	Select_WORD },
    	{ "line",	Select_LINE },
    	{ "group",	Select_GROUP },
    	{ "page",	Select_PAGE },
    	{ "all",	Select_ALL },
#if OPT_SELECT_REGEX
    	{ "regex",	Select_REGEX },
#endif
    };
    /* *INDENT-ON* */

    TScreen *screen = TScreenOf(xw);
    String next = x_skip_nonblanks(value);
    Cardinal n;

    screen->selectMap[item] = NSELECTUNITS;
    for (n = 0; n < XtNumber(table); ++n) {
	if (!x_strncasecmp(table[n].name, value, (unsigned) (next - value))) {
	    screen->selectMap[item] = table[n].code;
#if OPT_SELECT_REGEX
	    if (table[n].code == Select_REGEX) {
		screen->selectExpr[item] = x_strtrim(next);
		TRACE(("Parsed regex \"%s\"\n", screen->selectExpr[item]));
	    }
#endif
	    break;
	}
    }
}

static void
ParseOnClicks(XtermWidget wnew, XtermWidget wreq, Cardinal item)
{
    lookupSelectUnit(wnew, item, TScreenOf(wreq)->onClick[item]);
}

/*
 * Parse a comma-separated list, returning a string which the caller must
 * free, and updating the source pointer.
 */
static char *
ParseList(const char **source)
{
    const char *base = *source;
    const char *next;
    char *value = 0;
    char *result;

    /* ignore empty values */
    while (*base == ',')
	++base;

    if (*base != '\0') {
	size_t size;

	next = base;
	while (*next != '\0' && *next != ',')
	    ++next;
	size = (size_t) (1 + next - base);
	value = malloc(size);
	if (value != 0) {
	    memcpy(value, base, size);
	    value[size - 1] = '\0';
	}
	*source = next;
    } else {
	*source = base;
    }
    result = x_strtrim(value);
    free(value);
    return result;
}

static void
set_flags_from_list(char *target,
		    const char *source,
		    const FlagList * list)
{
    Cardinal n;
    int value = -1;

    while (!IsEmpty(source)) {
	char *next = ParseList(&source);
	Boolean found = False;

	if (next == 0)
	    break;
	if (isdigit(CharOf(*next))) {
	    char *temp;

	    value = (int) strtol(next, &temp, 0);
	    if (!FullS2L(next, temp)) {
		xtermWarning("Expected a number: %s\n", next);
	    } else {
		for (n = 0; list[n].name != 0; ++n) {
		    if (list[n].code == value) {
			target[value] = 1;
			found = True;
			TRACE(("...found %s (%d)\n", list[n].name, value));
			break;
		    }
		}
	    }
	} else {
	    for (n = 0; list[n].name != 0; ++n) {
		if (!x_wildstrcmp(next, list[n].name)) {
		    value = list[n].code;
		    target[value] = 1;
		    found = True;
		    TRACE(("...found %s (%d)\n", list[n].name, value));
		}
	    }
	}
	if (!found) {
	    xtermWarning("Unrecognized keyword: %s\n", next);
	}
	free(next);
    }
}

#define InitCursorShape(target, source) \
    target->cursor_shape = source->cursor_underline \
	? CURSOR_UNDERLINE \
	: CURSOR_BLOCK

/* ARGSUSED */
static void
VTInitialize(Widget wrequest,
	     Widget new_arg,
	     ArgList args GCC_UNUSED,
	     Cardinal *num_args GCC_UNUSED)
{
#define Kolor(name) TScreenOf(wnew)->name.resource
#define TxtFg(name) !x_strcasecmp(Kolor(Tcolors[TEXT_FG]), Kolor(name))
#define TxtBg(name) !x_strcasecmp(Kolor(Tcolors[TEXT_BG]), Kolor(name))
#define DftFg(name) isDefaultForeground(Kolor(name))
#define DftBg(name) isDefaultBackground(Kolor(name))

#define DATA_END   { NULL,  -1       }
#define DATA(name) { #name, ec##name }
    static const FlagList tblColorOps[] =
    {
	DATA(SetColor)
	,DATA(GetColor)
	,DATA(GetAnsiColor)
	,DATA_END
    };
#undef DATA

#define DATA(name) { #name, ef##name }
    static const FlagList tblFontOps[] =
    {
	DATA(SetFont)
	,DATA(GetFont)
	,DATA_END
    };
#undef DATA

#define DATA(name) { #name, em##name }
    static const FlagList tblMouseOps[] =
    {
	DATA(X10)
	,DATA(Locator)
	,DATA(VT200Click)
	,DATA(VT200Hilite)
	,DATA(AnyButton)
	,DATA(AnyEvent)
	,DATA(FocusEvent)
	,DATA(Extended)
	,DATA(SGR)
	,DATA(URXVT)
	,DATA(AlternateScroll)
	,DATA_END
    };
#undef DATA

#define DATA(name) { #name, et##name }
    static const FlagList tblTcapOps[] =
    {
	DATA(SetTcap)
	,DATA(GetTcap)
	,DATA_END
    };
#undef DATA

#define DATA(name) { #name, ew##name }
    static const FlagList tblWindowOps[] =
    {
	DATA(RestoreWin)
	,DATA(MinimizeWin)
	,DATA(SetWinPosition)
	,DATA(SetWinSizePixels)
	,DATA(RaiseWin)
	,DATA(LowerWin)
	,DATA(RefreshWin)
	,DATA(SetWinSizeChars)
#if OPT_MAXIMIZE
	,DATA(MaximizeWin)
	,DATA(FullscreenWin)
#endif
	,DATA(GetWinState)
	,DATA(GetWinPosition)
	,DATA(GetWinSizePixels)
	,DATA(GetWinSizeChars)
#if OPT_MAXIMIZE
	,DATA(GetScreenSizeChars)
#endif
	,DATA(GetIconTitle)
	,DATA(GetWinTitle)
	,DATA(PushTitle)
	,DATA(PopTitle)
	,DATA(SetWinLines)
	,DATA(SetXprop)
	,DATA(GetSelection)
	,DATA(SetSelection)
	,DATA_END
    };
#undef DATA

#if OPT_RENDERFONT
#define DATA(name) { #name, er##name }
    static const FlagList tblRenderFont[] =
    {
	DATA(Default)
	,DATA_END
    };
#undef DATA
#endif

#if OPT_WIDE_CHARS
#define DATA(name) { #name, u##name }
    static const FlagList tblUtf8Mode[] =
    {
	DATA(Always)
	,DATA(Default)
	,DATA_END
    };
#undef DATA
#endif

#ifndef NO_ACTIVE_ICON
#define DATA(name) { #name, ei##name }
    static const FlagList tblAIconOps[] =
    {
	DATA(Default)
	,DATA_END
    };
#undef DATA
#endif

#define DATA(name) { #name, eb##name }
    static const FlagList tbl8BitMeta[] =
    {
	DATA(Never)
	,DATA(Locale)
	,DATA_END
    };
#undef DATA

    XtermWidget request = (XtermWidget) wrequest;
    XtermWidget wnew = (XtermWidget) new_arg;
    Widget my_parent = SHELL_OF(wnew);
    int i;
    const char *s;

#if OPT_ISO_COLORS
    Bool color_ok;
#endif

#if OPT_COLOR_RES2
    static XtResource fake_resources[] =
    {
#if OPT_256_COLORS
# include <256colres.h>
#elif OPT_88_COLORS
# include <88colres.h>
#endif
    };
#endif /* OPT_COLOR_RES2 */
    TScreen *screen = TScreenOf(wnew);

#if OPT_TRACE
    check_tables();
#endif

    TRACE(("VTInitialize wnew %p, %d / %d resources\n",
	   (void *) wnew, XtNumber(xterm_resources), MAXRESOURCES));
    assert(XtNumber(xterm_resources) < MAXRESOURCES);

    /* Zero out the entire "screen" component of "wnew" widget, then do
     * field-by-field assignment of "screen" fields that are named in the
     * resource list.
     */
    memset(screen, 0, sizeof(wnew->screen));

    /* DESCO Sys#67660
     * Zero out the entire "keyboard" component of "wnew" widget.
     */
    memset(&wnew->keyboard, 0, sizeof(wnew->keyboard));

    /*
     * The workspace has no resources - clear it.
     */
    memset(&wnew->work, 0, sizeof(wnew->work));

    /* dummy values so that we don't try to Realize the parent shell with height
     * or width of 0, which is illegal in X.  The real size is computed in the
     * xtermWidget's Realize proc, but the shell's Realize proc is called first,
     * and must see a valid size.
     */
    wnew->core.height = wnew->core.width = 1;

    /*
     * The definition of -rv now is that it changes the definition of
     * XtDefaultForeground and XtDefaultBackground.  So, we no longer
     * need to do anything special.
     */
    screen->display = wnew->core.screen->display;

    /* prep getVisualInfo() */
    wnew->visInfo = 0;
    wnew->numVisuals = 0;
    (void) getVisualInfo(wnew);

    /*
     * We use the default foreground/background colors to compare/check if a
     * color-resource has been set.
     */
#define MyBlackPixel(dpy) BlackPixel(dpy,DefaultScreen(dpy))
#define MyWhitePixel(dpy) WhitePixel(dpy,DefaultScreen(dpy))

    if (request->misc.re_verse) {
	wnew->dft_foreground = MyWhitePixel(screen->display);
	wnew->dft_background = MyBlackPixel(screen->display);
    } else {
	wnew->dft_foreground = MyBlackPixel(screen->display);
	wnew->dft_background = MyWhitePixel(screen->display);
    }

    init_Tres(TEXT_FG);
    init_Tres(TEXT_BG);
    repairColors(wnew);

    wnew->old_foreground = T_COLOR(screen, TEXT_FG);
    wnew->old_background = T_COLOR(screen, TEXT_BG);

    TRACE(("Color resource initialization:\n"));
    TRACE(("   Default foreground 0x%06lx\n", wnew->dft_foreground));
    TRACE(("   Default background 0x%06lx\n", wnew->dft_background));
    TRACE(("   Screen foreground  0x%06lx\n", T_COLOR(screen, TEXT_FG)));
    TRACE(("   Screen background  0x%06lx\n", T_COLOR(screen, TEXT_BG)));
    TRACE(("   Actual  foreground 0x%06lx\n", wnew->old_foreground));
    TRACE(("   Actual  background 0x%06lx\n", wnew->old_background));

    screen->mouse_button = 0;
    screen->mouse_row = -1;
    screen->mouse_col = -1;

#if OPT_BOX_CHARS
    init_Bres(screen.force_box_chars);
    init_Bres(screen.force_packed);
    init_Bres(screen.force_all_chars);
    init_Bres(screen.assume_all_chars);
#endif
    init_Bres(screen.free_bold_box);
    init_Bres(screen.allowBoldFonts);

    init_Bres(screen.c132);
    init_Bres(screen.curses);
    init_Bres(screen.hp_ll_bc);
#if OPT_XMC_GLITCH
    init_Ires(screen.xmc_glitch);
    init_Ires(screen.xmc_attributes);
    init_Bres(screen.xmc_inline);
    init_Bres(screen.move_sgr_ok);
#endif
#if OPT_BLINK_CURS
    init_Bres(screen.cursor_blink);
    init_Ires(screen.blink_on);
    init_Ires(screen.blink_off);
    screen->cursor_blink_res = screen->cursor_blink;
#endif
    init_Bres(screen.cursor_underline);
    /* resources allow for underline or block, not (yet) bar */
    InitCursorShape(screen, TScreenOf(request));
#if OPT_BLINK_CURS
    TRACE(("cursor_shape:%d blinks:%s\n",
	   screen->cursor_shape,
	   BtoS(screen->cursor_blink)));
#endif
#if OPT_BLINK_TEXT
    init_Ires(screen.blink_as_bold);
#endif
    init_Ires(screen.border);
    init_Bres(screen.jumpscroll);
    init_Bres(screen.fastscroll);

    init_Bres(screen.old_fkeys);
    wnew->screen.old_fkeys0 = wnew->screen.old_fkeys;
    wnew->keyboard.type = screen->old_fkeys
	? keyboardIsLegacy
	: keyboardIsDefault;

    init_Mres(screen.delete_is_del);
#ifdef ALLOWLOGGING
    init_Bres(misc.logInhibit);
    init_Bres(misc.log_on);
    init_Sres(screen.logfile);
#endif
    init_Bres(screen.bellIsUrgent);
    init_Bres(screen.bellOnReset);
    init_Bres(screen.marginbell);
    init_Bres(screen.multiscroll);
    init_Ires(screen.nmarginbell);
    init_Ires(screen.savelines);
    init_Ires(screen.scrollBarBorder);
    init_Ires(screen.scrolllines);
    init_Bres(screen.alternateScroll);
    init_Bres(screen.scrollttyoutput);
    init_Bres(screen.scrollkey);

    init_Dres(screen.scale_height);
    if (screen->scale_height < 0.9)
	screen->scale_height = (float) 0.9;
    if (screen->scale_height > 1.5)
	screen->scale_height = (float) 1.5;

    init_Bres(misc.autoWrap);
    init_Bres(misc.login_shell);
    init_Bres(misc.reverseWrap);
    init_Bres(misc.scrollbar);
    init_Sres(misc.geo_metry);
    init_Sres(misc.T_geometry);

    init_Sres(screen.term_id);
    for (s = TScreenOf(request)->term_id; *s; s++) {
	if (!isalpha(CharOf(*s)))
	    break;
    }
    screen->terminal_id = atoi(s);
    if (screen->terminal_id < MIN_DECID)
	screen->terminal_id = MIN_DECID;
    if (screen->terminal_id > MAX_DECID)
	screen->terminal_id = MAX_DECID;
    TRACE(("term_id '%s' -> terminal_id %d\n",
	   screen->term_id,
	   screen->terminal_id));

    screen->vtXX_level = (screen->terminal_id / 100);

    init_Ires(screen.title_modes);
    wnew->screen.title_modes0 = wnew->screen.title_modes;

    init_Bres(screen.visualbell);
    init_Bres(screen.flash_line);
    init_Ires(screen.visualBellDelay);
    init_Bres(screen.poponbell);

    init_Bres(screen.eraseSavedLines0);
    screen->eraseSavedLines = screen->eraseSavedLines0;

    init_Ires(misc.limit_resize);

#if OPT_NUM_LOCK
    init_Bres(misc.real_NumLock);
    init_Bres(misc.alwaysUseMods);
#endif

#if OPT_INPUT_METHOD
    init_Bres(misc.open_im);
    init_Ires(misc.retry_im);
    init_Sres(misc.f_x);
    init_Sres(misc.input_method);
    init_Sres(misc.preedit_type);
#endif

#if OPT_SHIFT_FONTS
    init_Bres(misc.shift_fonts);
#endif
#if OPT_SUNPC_KBD
    init_Ires(misc.ctrl_fkeys);
#endif
#if OPT_TEK4014
    TEK4014_SHOWN(wnew) = False;	/* not a resource... */
    init_Bres(misc.tekInhibit);
    init_Bres(misc.tekSmall);
    init_Bres(misc.TekEmu);
#endif
#if OPT_TCAP_QUERY
    screen->tc_query_code = -1;
#endif
    wnew->misc.re_verse0 = request->misc.re_verse;
    init_Bres(misc.re_verse);
    init_Ires(screen.multiClickTime);
    init_Ires(screen.bellSuppressTime);
    init_Sres(screen.charClass);

    init_Bres(screen.always_highlight);
    init_Bres(screen.brokenSelections);
    init_Bres(screen.cutNewline);
    init_Bres(screen.cutToBeginningOfLine);
    init_Bres(screen.highlight_selection);
    init_Bres(screen.show_wrap_marks);
    init_Bres(screen.i18nSelections);
    init_Bres(screen.keepClipboard);
    init_Bres(screen.keepSelection);
    init_Bres(screen.selectToClipboard);
    init_Bres(screen.trim_selection);

    screen->pointer_cursor = TScreenOf(request)->pointer_cursor;
    init_Ires(screen.pointer_mode);
    wnew->screen.pointer_mode0 = wnew->screen.pointer_mode;

    init_Sres(screen.answer_back);

    wnew->SPS.printer_checked = False;
    init_Sres(SPS.printer_command);
    init_Bres(SPS.printer_autoclose);
    init_Bres(SPS.printer_extent);
    init_Bres(SPS.printer_formfeed);
    init_Bres(SPS.printer_newline);
    init_Ires(SPS.printer_controlmode);
#if OPT_PRINT_COLORS
    init_Ires(SPS.print_attributes);
#endif

    init_Sres(screen.keyboard_dialect);

    init_Bres(screen.input_eight_bits);
    init_Bres(screen.output_eight_bits);
    init_Bres(screen.control_eight_bits);
    init_Bres(screen.backarrow_key);
    init_Bres(screen.alt_is_not_meta);
    init_Bres(screen.alt_sends_esc);
    init_Bres(screen.meta_sends_esc);

    init_Bres(screen.allowPasteControl0);
    init_Bres(screen.allowSendEvent0);
    init_Bres(screen.allowColorOp0);
    init_Bres(screen.allowFontOp0);
    init_Bres(screen.allowMouseOp0);
    init_Bres(screen.allowTcapOp0);
    init_Bres(screen.allowTitleOp0);
    init_Bres(screen.allowWindowOp0);

#if OPT_SCROLL_LOCK
    init_Bres(screen.allowScrollLock0);
#endif

    init_Sres(screen.disallowedColorOps);

    set_flags_from_list(screen->disallow_color_ops,
			screen->disallowedColorOps,
			tblColorOps);

    init_Sres(screen.disallowedFontOps);

    set_flags_from_list(screen->disallow_font_ops,
			screen->disallowedFontOps,
			tblFontOps);

    init_Sres(screen.disallowedMouseOps);

    set_flags_from_list(screen->disallow_mouse_ops,
			screen->disallowedMouseOps,
			tblMouseOps);

    init_Sres(screen.disallowedTcapOps);

    set_flags_from_list(screen->disallow_tcap_ops,
			screen->disallowedTcapOps,
			tblTcapOps);

    init_Sres(screen.disallowedWinOps);

    set_flags_from_list(screen->disallow_win_ops,
			screen->disallowedWinOps,
			tblWindowOps);

    init_Sres(screen.default_string);
    init_Sres(screen.eightbit_select_types);
#if OPT_WIDE_CHARS
    init_Sres(screen.utf8_select_types);
#endif

    /* make a copy so that editres cannot change the resource after startup */
    screen->allowPasteControls = screen->allowPasteControl0;
    screen->allowSendEvents = screen->allowSendEvent0;
    screen->allowColorOps = screen->allowColorOp0;
    screen->allowFontOps = screen->allowFontOp0;
    screen->allowMouseOps = screen->allowMouseOp0;
    screen->allowTcapOps = screen->allowTcapOp0;
    screen->allowTitleOps = screen->allowTitleOp0;
    screen->allowWindowOps = screen->allowWindowOp0;

#if OPT_SCROLL_LOCK
    screen->allowScrollLock = screen->allowScrollLock0;
#endif

    init_Bres(screen.quiet_grab);

#ifndef NO_ACTIVE_ICON
    init_Sres(screen.icon_fontname);
    getIconicFont(screen)->fs = XLoadQueryFont(screen->display,
					       screen->icon_fontname);
    TRACE(("iconFont '%s' %sloaded successfully\n",
	   screen->icon_fontname,
	   getIconicFont(screen)->fs ? "" : "NOT "));
    init_Sres(misc.active_icon_s);
    wnew->work.active_icon =
	(Boolean) extendedBoolean(wnew->misc.active_icon_s,
				  tblAIconOps, eiLAST);
    init_Ires(misc.icon_border_width);
    wnew->misc.icon_border_pixel = request->misc.icon_border_pixel;
#endif /* NO_ACTIVE_ICON */

    init_Bres(misc.signalInhibit);
    init_Bres(misc.titeInhibit);
    init_Bres(misc.tiXtraScroll);
    init_Bres(misc.cdXtraScroll);
    init_Bres(misc.dynamicColors);

#if OPT_DEC_CHRSET
    for (i = 0; i < NUM_CHRSET; i++) {
	screen->double_fonts[i].warn = fwResource;
    }
#endif
    for (i = fontMenu_font1; i <= fontMenu_lastBuiltin; i++) {
	init_Sres2(screen.MenuFontName, i);
    }
    for (i = 0; i < fMAX; i++) {
	screen->fnts[i].warn = fwResource;
#if OPT_WIDE_ATTRS
	screen->ifnts[i].warn = fwResource;
#endif
    }
#ifndef NO_ACTIVE_ICON
    screen->fnt_icon.warn = fwResource;
#endif

    init_Ires(misc.fontWarnings);

    initFontLists(wnew);

#define DefaultFontNames screen->menu_font_names[fontMenu_default]

    /*
     * Process Xft font resources first, since faceName may contain X11 fonts
     * that should override the "font" resource.
     */
#if OPT_RENDERFONT
    for (i = 0; i <= fontMenu_lastBuiltin; ++i) {
	init_Dres2(misc.face_size, i);
    }

#define ALLOC_FONTLIST(name,which,field) \
    init_Sres(misc.default_xft.field);\
    allocFontList(wnew,\
		  name,\
		  &(wnew->work.fonts),\
		  which,\
		  wnew->misc.default_xft.field,\
		  True)

    ALLOC_FONTLIST(XtNfaceName, fNorm, f_n);

#if OPT_WIDE_CHARS
    ALLOC_FONTLIST(XtNfaceNameDoublesize, fWide, f_w);
#endif

#undef ALLOC_FONTLIST

#endif

    /*
     * Process X11 (XLFD) font specifications.
     */
#define ALLOC_FONTLIST(name,which,field) \
    init_Sres(misc.default_font.field);\
    allocFontList(wnew,\
		  name,\
		  &(wnew->work.fonts),\
		  which,\
		  wnew->misc.default_font.field,\
		  False)

    ALLOC_FONTLIST(XtNfont, fNorm, f_n);
    ALLOC_FONTLIST(XtNboldFont, fBold, f_b);

    DefaultFontNames[fNorm] = x_strdup(DefaultFontN(wnew));
    DefaultFontNames[fBold] = x_strdup(DefaultFontB(wnew));

#if OPT_WIDE_CHARS
    ALLOC_FONTLIST(XtNwideFont, fWide, f_w);
    ALLOC_FONTLIST(XtNwideBoldFont, fWBold, f_wb);

    DefaultFontNames[fWide] = x_strdup(DefaultFontW(wnew));
    DefaultFontNames[fWBold] = x_strdup(DefaultFontWB(wnew));
#endif

#undef ALLOC_FONTLIST

    screen->EscapeFontName() = NULL;
    screen->SelectFontName() = NULL;

    screen->menu_font_number = fontMenu_default;
    init_Sres(screen.initial_font);
    if (screen->initial_font != 0) {
	int result = xtermGetFont(screen->initial_font);
	if (result >= 0)
	    screen->menu_font_number = result;
    }
#if OPT_BROKEN_OSC
    init_Bres(screen.brokenLinuxOSC);
#endif

#if OPT_BROKEN_ST
    init_Bres(screen.brokenStringTerm);
#endif

#if OPT_C1_PRINT
    init_Bres(screen.c1_printable);
#endif

#if OPT_CLIP_BOLD
    init_Bres(screen.use_clipping);
#endif

#if OPT_DEC_CHRSET
    init_Bres(screen.font_doublesize);
    init_Ires(screen.cache_doublesize);
    if (screen->cache_doublesize > NUM_CHRSET)
	screen->cache_doublesize = NUM_CHRSET;
    if (screen->cache_doublesize == 0)
	screen->font_doublesize = False;
    TRACE(("Doublesize%s enabled, up to %d fonts\n",
	   screen->font_doublesize ? "" : " not",
	   screen->cache_doublesize));
#endif

#if OPT_ISO_COLORS
    init_Ires(screen.veryBoldColors);
    init_Bres(screen.boldColors);
    init_Bres(screen.colorAttrMode);
    init_Bres(screen.colorBDMode);
    init_Bres(screen.colorBLMode);
    init_Bres(screen.colorMode);
    init_Bres(screen.colorULMode);
    init_Bres(screen.italicULMode);
    init_Bres(screen.colorRVMode);

#if OPT_WIDE_ATTRS
    init_Bres(screen.colorITMode);
#endif

#if OPT_COLOR_RES2
    TRACE(("...will fake resources for color%d to color%d\n",
	   MIN_ANSI_COLORS,
	   NUM_ANSI_COLORS - 1));
#endif
    for (i = 0, color_ok = False; i < MAXCOLORS; i++) {

#if OPT_COLOR_RES2
	/*
	 * Xt has a hardcoded limit on the maximum number of resources that can
	 * be used in a widget.  If we configure both luit (which implies
	 * wide-characters) and 256-colors, it goes over that limit.  Most
	 * people would not need a resource-file with 256-colors; the default
	 * values in our table are sufficient.  In that case, fake the resource
	 * setting by copying the default value from the table.  The #define's
	 * can be overridden to make these true resources.
	 */
	if (i >= MIN_ANSI_COLORS && i < NUM_ANSI_COLORS) {
	    screen->Acolors[i].resource =
		x_strtrim(fake_resources[i - MIN_ANSI_COLORS].default_addr);
	    if (screen->Acolors[i].resource == 0)
		screen->Acolors[i].resource = XtDefaultForeground;
	} else
#endif /* OPT_COLOR_RES2 */
	{
	    screen->Acolors[i] = TScreenOf(request)->Acolors[i];
	    screen->Acolors[i].resource =
		x_strtrim(screen->Acolors[i].resource);
	}

#if OPT_COLOR_RES
	TRACE(("Acolors[%d] = %s\n", i, screen->Acolors[i].resource));
	screen->Acolors[i].mode = False;
	if (DftFg(Acolors[i])) {
	    screen->Acolors[i].value = T_COLOR(screen, TEXT_FG);
	    screen->Acolors[i].mode = True;
	} else if (DftBg(Acolors[i])) {
	    screen->Acolors[i].value = T_COLOR(screen, TEXT_BG);
	    screen->Acolors[i].mode = True;
	} else {
	    color_ok = True;
	}
#else
	TRACE(("Acolors[%d] = %#lx\n", i, TScreenOf(request)->Acolors[i]));
	if (screen->Acolors[i] != wnew->dft_foreground &&
	    screen->Acolors[i] != T_COLOR(screen, TEXT_FG) &&
	    screen->Acolors[i] != T_COLOR(screen, TEXT_BG))
	    color_ok = True;
#endif
    }

    /*
     * Check if we're trying to use color in a monochrome screen.  Disable
     * color in that case, since that would make ANSI colors unusable.  A 4-bit
     * or 8-bit display is usable, so we do not have to check for anything more
     * specific.
     */
    if (color_ok) {
	if (getVisualDepth(wnew) <= 1) {
	    TRACE(("disabling color since screen is monochrome\n"));
	    color_ok = False;
	}
    }

    /* If none of the colors are anything other than the foreground or
     * background, we'll assume this isn't color, no matter what the colorMode
     * resource says.  (There doesn't seem to be any good way to determine if
     * the resource lookup failed versus the user having misconfigured this).
     */
    if (!color_ok) {
	screen->colorMode = False;
	TRACE(("All colors are foreground or background: disable colorMode\n"));
    }
    wnew->sgr_foreground = -1;
    wnew->sgr_background = -1;
    wnew->sgr_extended = False;
#endif /* OPT_ISO_COLORS */

    /*
     * Decode the resources that control the behavior on multiple mouse clicks.
     * A single click is always bound to normal character selection, but the
     * other flavors can be changed.
     */
    for (i = 0; i < NSELECTUNITS; ++i) {
	int ck = (i + 1);
	screen->maxClicks = ck;
	if (i == Select_CHAR)
	    screen->selectMap[i] = Select_CHAR;
	else if (TScreenOf(request)->onClick[i] != 0)
	    ParseOnClicks(wnew, request, (unsigned) i);
	else if (i <= Select_LINE)
	    screen->selectMap[i] = (SelectUnit) i;
	else
	    break;
	TRACE(("on%dClicks %s=%d\n", ck,
	       NonNull(TScreenOf(request)->onClick[i]),
	       screen->selectMap[i]));
	if (screen->selectMap[i] == NSELECTUNITS)
	    break;
    }
    TRACE(("maxClicks %d\n", screen->maxClicks));

    init_Tres(MOUSE_FG);
    init_Tres(MOUSE_BG);
    init_Tres(TEXT_CURSOR);
#if OPT_HIGHLIGHT_COLOR
    init_Tres(HIGHLIGHT_BG);
    init_Tres(HIGHLIGHT_FG);
    init_Bres(screen.hilite_reverse);
    init_Mres(screen.hilite_color);
    if (screen->hilite_color == Maybe) {
	screen->hilite_color = False;
#if OPT_COLOR_RES
	/*
	 * If the highlight text/background are both set, and if they are
	 * not equal to either the text/background or background/text, then
	 * set the highlightColorMode automatically.
	 */
	if (!DftFg(Tcolors[HIGHLIGHT_BG])
	    && !DftBg(Tcolors[HIGHLIGHT_FG])
	    && !TxtFg(Tcolors[HIGHLIGHT_BG])
	    && !TxtBg(Tcolors[HIGHLIGHT_FG])
	    && !TxtBg(Tcolors[HIGHLIGHT_BG])
	    && !TxtFg(Tcolors[HIGHLIGHT_FG])) {
	    TRACE(("...setting hilite_color automatically\n"));
	    screen->hilite_color = True;
	}
#endif
    }
#endif

#if OPT_TEK4014
    /*
     * The Tek4014 window has no separate resources for foreground, background
     * and cursor color.  Since xterm always creates the vt100 widget first, we
     * can set the Tektronix colors here.  That lets us use escape sequences to
     * set its dynamic colors and get consistent behavior whether or not the
     * window is displayed.
     */
    screen->Tcolors[TEK_BG] = screen->Tcolors[TEXT_BG];
    screen->Tcolors[TEK_FG] = screen->Tcolors[TEXT_FG];
    screen->Tcolors[TEK_CURSOR] = screen->Tcolors[TEXT_CURSOR];
#endif

#ifdef SCROLLBAR_RIGHT
    init_Bres(misc.useRight);
#endif

#if OPT_RENDERFONT
    init_Sres(misc.render_font_s);
    wnew->work.render_font =
	(Boolean) extendedBoolean(wnew->misc.render_font_s,
				  tblRenderFont, erLast);
    if (wnew->work.render_font == erDefault) {
	if (IsEmpty(CurrentXftFont(wnew))) {
	    free((void *) CurrentXftFont(wnew));
	    CurrentXftFont(wnew) = x_strdup(DEFFACENAME_AUTO);
	    TRACE(("will allow runtime switch to render_font using \"%s\"\n",
		   CurrentXftFont(wnew)));
	} else {
	    wnew->work.render_font = erTrue;
	    TRACE(("initially using TrueType font\n"));
	}
    }
    /* minor tweak to make debug traces consistent: */
    if (wnew->work.render_font) {
	if (IsEmpty(CurrentXftFont(wnew))) {
	    wnew->work.render_font = False;
	    TRACE(("reset render_font since there is no face_name\n"));
	}
    }
#endif

#if OPT_WIDE_CHARS
    /* setup data for next call */
    request->screen.utf8_mode =
	extendedBoolean(request->screen.utf8_mode_s, tblUtf8Mode, uLast);
    request->screen.utf8_fonts =
	extendedBoolean(request->screen.utf8_fonts_s, tblUtf8Mode, uLast);

    /*
     * Make a copy in the input/request so that DefaultFontN() works for
     * the "CHECKFONT" option.
     */
    copyFontList(&(request->work.fonts.x11.list_n),
		 wnew->work.fonts.x11.list_n);

    VTInitialize_locale(request);
    init_Bres(screen.normalized_c);
    init_Bres(screen.utf8_latin1);
    init_Bres(screen.utf8_title);

#if OPT_LUIT_PROG
    init_Bres(misc.callfilter);
    init_Bres(misc.use_encoding);
    init_Sres(misc.locale_str);
    init_Sres(misc.localefilter);
#endif

    init_Ires(screen.utf8_inparse);
    init_Ires(screen.utf8_mode);
    init_Ires(screen.utf8_fonts);
    init_Ires(screen.max_combining);

    init_Ires(screen.utf8_always);	/* from utf8_mode, used in doparse */

    if (screen->max_combining < 0) {
	screen->max_combining = 0;
    }
    if (screen->max_combining > 5) {
	screen->max_combining = 5;
    }

    init_Bres(screen.vt100_graphics);
    init_Bres(screen.wide_chars);
    init_Bres(misc.mk_width);
    init_Bres(misc.cjk_width);

    init_Ires(misc.mk_samplesize);
    init_Ires(misc.mk_samplepass);

    if (wnew->misc.mk_samplesize > 0xffff)
	wnew->misc.mk_samplesize = 0xffff;
    if (wnew->misc.mk_samplesize < 0)
	wnew->misc.mk_samplesize = 0;

    if (wnew->misc.mk_samplepass > wnew->misc.mk_samplesize)
	wnew->misc.mk_samplepass = wnew->misc.mk_samplesize;
    if (wnew->misc.mk_samplepass < 0)
	wnew->misc.mk_samplepass = 0;

    if (TScreenOf(request)->utf8_mode) {
	TRACE(("setting wide_chars on\n"));
	screen->wide_chars = True;
    } else {
	TRACE(("setting utf8_mode to 0\n"));
	screen->utf8_mode = uFalse;
    }
    mk_wcwidth_init(screen->utf8_mode);
    TRACE(("initialized UTF-8 mode to %d\n", screen->utf8_mode));

#if OPT_MINI_LUIT
    if (TScreenOf(request)->latin9_mode) {
	screen->latin9_mode = True;
    }
    if (TScreenOf(request)->unicode_font) {
	screen->unicode_font = True;
    }
    TRACE(("initialized Latin9 mode to %d\n", screen->latin9_mode));
    TRACE(("initialized unicode_font to %d\n", screen->unicode_font));
#endif

    decode_wcwidth(wnew);
    xtermSaveVTFonts(wnew);
#endif /* OPT_WIDE_CHARS */

    init_Sres(screen.eight_bit_meta_s);
    wnew->screen.eight_bit_meta =
	extendedBoolean(request->screen.eight_bit_meta_s, tbl8BitMeta, uLast);
    if (wnew->screen.eight_bit_meta == ebLocale) {
#if OPT_WIDE_CHARS
	if (xtermEnvUTF8()) {
	    wnew->screen.eight_bit_meta = ebFalse;
	    TRACE(("...eightBitMeta is false due to locale\n"));
	} else
#endif /* OPT_WIDE_CHARS */
	{
	    wnew->screen.eight_bit_meta = ebTrue;
	    TRACE(("...eightBitMeta is true due to locale\n"));
	}
    }

    init_Bres(screen.always_bold_mode);
    init_Bres(screen.bold_mode);
    init_Bres(screen.underline);

    wnew->cur_foreground = 0;
    wnew->cur_background = 0;

    wnew->keyboard.flags = MODE_SRM;

    if (screen->backarrow_key)
	wnew->keyboard.flags |= MODE_DECBKM;
    TRACE(("initialized DECBKM %s\n",
	   BtoS(wnew->keyboard.flags & MODE_DECBKM)));

#if OPT_SIXEL_GRAPHICS
    init_Bres(screen.sixel_scrolling);
    if (screen->sixel_scrolling)
	wnew->keyboard.flags |= MODE_DECSDM;
    TRACE(("initialized DECSDM %s\n",
	   BtoS(wnew->keyboard.flags & MODE_DECSDM)));
#endif

#if OPT_GRAPHICS
    init_Ires(screen.numcolorregisters);
    TRACE(("initialized NUM_COLOR_REGISTERS to resource default: %d\n",
	   screen->numcolorregisters));

    init_Bres(screen.privatecolorregisters);	/* FIXME: should this be off unconditionally here? */
    TRACE(("initialized PRIVATE_COLOR_REGISTERS to resource default: %s\n",
	   BtoS(screen->privatecolorregisters)));
#endif

#if OPT_GRAPHICS
    {
	int native_w, native_h;

	switch (screen->terminal_id) {
	case 125:
	    native_w = 768;
	    native_h = 460;
	    break;
	case 240:
	    native_w = 800;
	    native_h = 460;
	    break;
	case 241:
	    native_w = 800;
	    native_h = 460;
	    break;
	case 330:
	    native_w = 800;
	    native_h = 480;
	    break;
	case 340:
	    /* FALLTHRU */
	default:
	    native_w = 800;
	    native_h = 480;
	    break;
	case 382:
	    native_w = 960;
	    native_h = 750;
	    break;
	}

# if OPT_REGIS_GRAPHICS
	init_Sres(screen.graphics_regis_default_font);
	TRACE(("default ReGIS font: %s\n",
	       screen->graphics_regis_default_font));

	init_Sres(screen.graphics_regis_screensize);
	screen->graphics_regis_def_high = 1000;
	screen->graphics_regis_def_wide = 1000;
	if (!x_strcasecmp(screen->graphics_regis_screensize, "auto")) {
	    TRACE(("setting default ReGIS screensize based on terminal_id %d\n",
		   screen->terminal_id));
	    screen->graphics_regis_def_high = (Dimension) native_w;
	    screen->graphics_regis_def_wide = (Dimension) native_h;
	} else {
	    int conf_high;
	    int conf_wide;
	    char ignore;

	    if (sscanf(screen->graphics_regis_screensize,
		       "%dx%d%c",
		       &conf_wide,
		       &conf_high,
		       &ignore) == 2) {
		if (conf_high > 0 && conf_wide > 0) {
		    screen->graphics_regis_def_high =
			(Dimension) conf_high;
		    screen->graphics_regis_def_wide =
			(Dimension) conf_wide;
		} else {
		    TRACE(("ignoring invalid regisScreenSize %s\n",
			   screen->graphics_regis_screensize));
		}
	    } else {
		TRACE(("ignoring invalid regisScreenSize %s\n",
		       screen->graphics_regis_screensize));
	    }
	}
	TRACE(("default ReGIS graphics screensize %dx%d\n",
	       (int) screen->graphics_regis_def_wide,
	       (int) screen->graphics_regis_def_high));
# endif

	init_Sres(screen.graphics_max_size);
	screen->graphics_max_high = 1000;
	screen->graphics_max_wide = 1000;
	if (!x_strcasecmp(screen->graphics_max_size, "auto")) {
	    TRACE(("setting max graphics screensize based on terminal_id %d\n",
		   screen->terminal_id));
	    screen->graphics_max_high = (Dimension) native_w;
	    screen->graphics_max_wide = (Dimension) native_h;
	} else {
	    int conf_high;
	    int conf_wide;
	    char ignore;

	    if (sscanf(screen->graphics_max_size,
		       "%dx%d%c",
		       &conf_wide,
		       &conf_high,
		       &ignore) == 2) {
		if (conf_high > 0 && conf_wide > 0) {
		    screen->graphics_max_high = (Dimension) conf_high;
		    screen->graphics_max_wide = (Dimension) conf_wide;
		} else {
		    TRACE(("ignoring invalid maxGraphicSize %s\n",
			   screen->graphics_max_size));
		}
	    } else {
		TRACE(("ignoring invalid maxGraphicSize %s\n",
		       screen->graphics_max_size));
	    }
	}
# if OPT_REGIS_GRAPHICS
	/* Make sure the max is large enough for the default ReGIS size. */
	if (screen->graphics_regis_def_high >
	    screen->graphics_max_high) {
	    screen->graphics_max_high =
		screen->graphics_regis_def_high;
	}
	if (screen->graphics_regis_def_wide >
	    screen->graphics_max_wide) {
	    screen->graphics_max_wide =
		screen->graphics_regis_def_wide;
	}
# endif
	TRACE(("max graphics screensize %dx%d\n",
	       (int) screen->graphics_max_wide,
	       (int) screen->graphics_max_high));
    }
#endif

#if OPT_SIXEL_GRAPHICS
    init_Bres(screen.sixel_scrolls_right);
    TRACE(("initialized SIXEL_SCROLLS_RIGHT to resource default: %s\n",
	   BtoS(screen->sixel_scrolls_right)));
#endif

    /* look for focus related events on the shell, because we need
     * to care about the shell's border being part of our focus.
     */
    TRACE(("adding event handlers for my_parent %p\n", (void *) my_parent));
    XtAddEventHandler(my_parent, EnterWindowMask, False,
		      HandleEnterWindow, (Opaque) NULL);
    XtAddEventHandler(my_parent, LeaveWindowMask, False,
		      HandleLeaveWindow, (Opaque) NULL);
    XtAddEventHandler(my_parent, FocusChangeMask, False,
		      HandleFocusChange, (Opaque) NULL);
    XtAddEventHandler((Widget) wnew, 0L, True,
		      VTNonMaskableEvent, (Opaque) NULL);
    XtAddEventHandler((Widget) wnew, PropertyChangeMask, False,
		      HandleBellPropertyChange, (Opaque) NULL);

#if HANDLE_STRUCT_NOTIFY
#if OPT_TOOLBAR
    wnew->VT100_TB_INFO(menu_bar) = request->VT100_TB_INFO(menu_bar);
    init_Ires(VT100_TB_INFO(menu_height));
#else
    /* Flag icon name with "***"  on window output when iconified.
     * Put in a handler that will tell us when we get Map/Unmap events.
     */
    if (resource.zIconBeep)
#endif
	XtAddEventHandler(my_parent, StructureNotifyMask, False,
			  HandleStructNotify, (Opaque) 0);
#endif /* HANDLE_STRUCT_NOTIFY */

    screen->bellInProgress = False;

    set_character_class(screen->charClass);
#if OPT_REPORT_CCLASS
    if (resource.reportCClass)
	report_char_class(wnew);
#endif

    /* create it, but don't realize it */
    ScrollBarOn(wnew, True);

    /* make sure that the resize gravity acceptable */
    if (!GravityIsNorthWest(wnew) &&
	!GravityIsSouthWest(wnew)) {
	char value[80];
	String temp[2];
	Cardinal nparams = 1;

	sprintf(value, "%d", wnew->misc.resizeGravity);
	temp[0] = value;
	temp[1] = 0;
	XtAppWarningMsg(app_con, "rangeError", "resizeGravity", "XTermError",
			"unsupported resizeGravity resource value (%s)",
			temp, &nparams);
	wnew->misc.resizeGravity = SouthWestGravity;
    }
#ifndef NO_ACTIVE_ICON
    screen->whichVwin = &screen->fullVwin;
#endif /* NO_ACTIVE_ICON */

    if (screen->savelines < 0)
	screen->savelines = 0;

    init_Bres(screen.awaitInput);

    wnew->flags = 0;
    if (!screen->jumpscroll)
	wnew->flags |= SMOOTHSCROLL;
    if (wnew->misc.reverseWrap)
	wnew->flags |= REVERSEWRAP;
    if (wnew->misc.autoWrap)
	wnew->flags |= WRAPAROUND;
    if (wnew->misc.re_verse != wnew->misc.re_verse0)
	wnew->flags |= REVERSE_VIDEO;
    if (screen->c132)
	wnew->flags |= IN132COLUMNS;

    wnew->initflags = wnew->flags;

#if OPT_MOD_FKEYS
    init_Ires(keyboard.modify_1st.allow_keys);
    init_Ires(keyboard.modify_1st.cursor_keys);
    init_Ires(keyboard.modify_1st.function_keys);
    init_Ires(keyboard.modify_1st.keypad_keys);
    init_Ires(keyboard.modify_1st.other_keys);
    init_Ires(keyboard.modify_1st.string_keys);
    init_Ires(keyboard.format_keys);
    wnew->keyboard.modify_now = wnew->keyboard.modify_1st;
#endif

    init_Ires(misc.appcursorDefault);
    if (wnew->misc.appcursorDefault)
	wnew->keyboard.flags |= MODE_DECCKM;

    init_Ires(misc.appkeypadDefault);
    if (wnew->misc.appkeypadDefault)
	wnew->keyboard.flags |= MODE_DECKPAM;

    initLineData(wnew);
#if OPT_WIDE_CHARS
    freeFontList(&(request->work.fonts.x11.list_n));
#endif
    return;
}

void
releaseCursorGCs(XtermWidget xw)
{
    TScreen *screen = TScreenOf(xw);
    VTwin *win = WhichVWin(screen);
    int n;

    for_each_curs_gc(n) {
	freeCgs(xw, win, (CgsEnum) n);
    }
}

void
releaseWindowGCs(XtermWidget xw, VTwin *win)
{
    int n;

    for_each_text_gc(n) {
	freeCgs(xw, win, (CgsEnum) n);
    }
}

#define TRACE_FREE_LEAK(name) \
	if (name) { \
	    TRACE(("freed " #name ": %p\n", (const void *) name)); \
	    free((void *) name); \
	    name = 0; \
	}

#define FREE_LEAK(name) \
	if (name) { \
	    free((void *) name); \
	    name = 0; \
	}

#if OPT_I18N_SUPPORT && OPT_INPUT_METHOD
static void
cleanupInputMethod(XtermWidget xw)
{
    TInput *input = lookupTInput(xw, (Widget) xw);

    if (input && input->xim) {
	XCloseIM(input->xim);
	input->xim = 0;
	TRACE(("freed screen->xim\n"));
    }
}
#endif

static void
VTDestroy(Widget w GCC_UNUSED)
{
#ifdef NO_LEAKS
    XtermWidget xw = (XtermWidget) w;
    TScreen *screen = TScreenOf(xw);
    Cardinal n, k;

    StopBlinking(screen);

    if (screen->scrollWidget) {
	XtUninstallTranslations(screen->scrollWidget);
	XtDestroyWidget(screen->scrollWidget);
    }
#if OPT_FIFO_LINES
    while (screen->saved_fifo > 0) {
	deleteScrollback(screen);
    }
#endif
    while (screen->save_title != 0) {
	SaveTitle *last = screen->save_title;
	screen->save_title = last->next;
	free(last->iconName);
	free(last->windowName);
	free(last);
    }
    TRACE_FREE_LEAK(xw->misc.active_icon_s);
#if OPT_ISO_COLORS
    TRACE_FREE_LEAK(screen->cmap_data);
    for (n = 0; n < MAXCOLORS; n++) {
	TRACE_FREE_LEAK(screen->Acolors[n].resource);
    }
#endif
#if OPT_COLOR_RES
    for (n = 0; n < NCOLORS; n++) {
	switch (n) {
#if OPT_TEK4014
	case TEK_BG:
	    /* FALLTHRU */
	case TEK_FG:
	    /* FALLTHRU */
	case TEK_CURSOR:
	    break;
#endif
	default:
	    TRACE_FREE_LEAK(screen->Tcolors[n].resource);
	    break;
	}
    }
#endif
    TRACE_FREE_LEAK(screen->save_ptr);
    TRACE_FREE_LEAK(screen->saveBuf_data);
    TRACE_FREE_LEAK(screen->saveBuf_index);
    for (n = 0; n < 2; ++n) {
	TRACE_FREE_LEAK(screen->editBuf_data[n]);
	TRACE_FREE_LEAK(screen->editBuf_index[n]);
    }
    TRACE_FREE_LEAK(screen->keyboard_dialect);
    TRACE_FREE_LEAK(screen->term_id);
#if OPT_WIDE_CHARS
#if OPT_LUIT_PROG
    TRACE_FREE_LEAK(xw->misc.locale_str);
    TRACE_FREE_LEAK(xw->misc.localefilter);
#endif
#endif
    TRACE_FREE_LEAK(xw->misc.T_geometry);
    TRACE_FREE_LEAK(xw->misc.geo_metry);
    TRACE_FREE_LEAK(xw->screen.term_id);
#if OPT_INPUT_METHOD
    cleanupInputMethod(xw);
    TRACE_FREE_LEAK(xw->misc.f_x);
    TRACE_FREE_LEAK(xw->misc.input_method);
    TRACE_FREE_LEAK(xw->misc.preedit_type);
#endif
    releaseCursorGCs(xw);
    releaseWindowGCs(xw, &(screen->fullVwin));
#ifndef NO_ACTIVE_ICON
    XFreeFont(screen->display, getIconicFont(screen)->fs);
    releaseWindowGCs(xw, &(screen->iconVwin));
#endif
    XtUninstallTranslations((Widget) xw);
#if OPT_TOOLBAR
    XtUninstallTranslations((Widget) XtParent(xw));
#endif
    XtUninstallTranslations((Widget) SHELL_OF(xw));

    if (screen->hidden_cursor)
	XFreeCursor(screen->display, screen->hidden_cursor);

    xtermCloseFonts(xw, screen->fnts);
#if OPT_WIDE_ATTRS
    xtermCloseFonts(xw, screen->ifnts);
#endif
    noleaks_cachedCgs(xw);

    TRACE_FREE_LEAK(screen->selection_targets_8bit);
#if OPT_SELECT_REGEX
    for (n = 0; n < NSELECTUNITS; ++n) {
	if (screen->selectMap[n] == Select_REGEX) {
	    TRACE_FREE_LEAK(screen->selectExpr[n]);
	}
    }
#endif

#if OPT_RENDERFONT
    for (n = 0; n < NMENUFONTS; ++n) {
	int e;
	for (e = 0; e < fMAX; ++e) {
	    xtermCloseXft(screen, getMyXftFont(xw, e, (int) n));
	}
    }
    if (screen->renderDraw)
	XftDrawDestroy(screen->renderDraw);
#endif

    /* free things allocated via init_Sres or Init_Sres2 */
#ifndef NO_ACTIVE_ICON
    TRACE_FREE_LEAK(screen->icon_fontname);
#endif
#ifdef ALLOWLOGGING
    TRACE_FREE_LEAK(screen->logfile);
#endif
    TRACE_FREE_LEAK(screen->eight_bit_meta_s);
    TRACE_FREE_LEAK(screen->term_id);
    TRACE_FREE_LEAK(screen->charClass);
    TRACE_FREE_LEAK(screen->answer_back);
    TRACE_FREE_LEAK(screen->printer_state.printer_command);
    TRACE_FREE_LEAK(screen->keyboard_dialect);
    TRACE_FREE_LEAK(screen->disallowedColorOps);
    TRACE_FREE_LEAK(screen->disallowedFontOps);
    TRACE_FREE_LEAK(screen->disallowedMouseOps);
    TRACE_FREE_LEAK(screen->disallowedTcapOps);
    TRACE_FREE_LEAK(screen->disallowedWinOps);
    TRACE_FREE_LEAK(screen->default_string);
    TRACE_FREE_LEAK(screen->eightbit_select_types);

#if OPT_WIDE_CHARS
    TRACE_FREE_LEAK(screen->utf8_select_types);
#endif

#if 0
    for (n = fontMenu_font1; n <= fontMenu_lastBuiltin; n++) {
	TRACE_FREE_LEAK(screen->MenuFontName(n));
    }
#endif

    TRACE_FREE_LEAK(screen->initial_font);

#if OPT_LUIT_PROG
    TRACE_FREE_LEAK(xw->misc.locale_str);
    TRACE_FREE_LEAK(xw->misc.localefilter);
#endif

#if OPT_RENDERFONT
    TRACE_FREE_LEAK(xw->misc.default_xft.f_n);
    TRACE_FREE_LEAK(xw->misc.default_xft.f_w);
    TRACE_FREE_LEAK(xw->misc.render_font_s);
#endif

    TRACE_FREE_LEAK(xw->misc.default_font.f_n);
    TRACE_FREE_LEAK(xw->misc.default_font.f_b);

#if OPT_WIDE_CHARS
    TRACE_FREE_LEAK(xw->misc.default_font.f_w);
    TRACE_FREE_LEAK(xw->misc.default_font.f_wb);
#endif

    freeFontLists(&(xw->work.fonts.x11));
#if OPT_RENDERFONT
    freeFontLists(&(xw->work.fonts.xft));
#endif

    xtermFontName(NULL);
#if OPT_LOAD_VTFONTS || OPT_WIDE_CHARS
    TRACE_FREE_LEAK(screen->cacheVTFonts.default_font.f_n);
    TRACE_FREE_LEAK(screen->cacheVTFonts.default_font.f_b);
#if OPT_WIDE_CHARS
    TRACE_FREE_LEAK(screen->cacheVTFonts.default_font.f_w);
    TRACE_FREE_LEAK(screen->cacheVTFonts.default_font.f_wb);
#endif
    freeFontLists(&(screen->cacheVTFonts.fonts.x11));
    for (n = 0; n < NMENUFONTS; ++n) {
	for (k = 0; k < fMAX; ++k) {
	    if (screen->menu_font_names[n][k] !=
		screen->cacheVTFonts.menu_font_names[n][k]) {
		TRACE_FREE_LEAK(screen->menu_font_names[n][k]);
		TRACE_FREE_LEAK(screen->cacheVTFonts.menu_font_names[n][k]);
	    } else {
		TRACE_FREE_LEAK(screen->menu_font_names[n][k]);
	    }
	}
    }
#endif

#if OPT_SELECT_REGEX
    for (n = 0; n < NSELECTUNITS; ++n) {
	FREE_LEAK(screen->selectExpr[n]);
    }
#endif

    if (screen->selection_atoms)
	XtFree((void *) (screen->selection_atoms));

    XtFree((void *) (screen->selection_data));

    TRACE_FREE_LEAK(xtermClassRec.core_class.tm_table);
    TRACE_FREE_LEAK(xw->keyboard.extra_translations);
    TRACE_FREE_LEAK(xw->keyboard.shell_translations);
    TRACE_FREE_LEAK(xw->keyboard.xterm_translations);

    XtFree((void *) (xw->visInfo));

#if OPT_WIDE_CHARS
    FreeTypedBuffer(XChar2b);
    FreeTypedBuffer(char);
#endif
#if OPT_RENDERFONT
#if OPT_RENDERWIDE
    FreeTypedBuffer(XftCharSpec);
#else
    FreeTypedBuffer(XftChar8);
#endif
#endif

    TRACE_FREE_LEAK(myState.print_area);
    TRACE_FREE_LEAK(myState.string_area);
    memset(&myState, 0, sizeof(myState));

#endif /* defined(NO_LEAKS) */
}

#ifndef NO_ACTIVE_ICON
static void *
getProperty(Display *dpy,
	    Window w,
	    Atom req_type,
	    const char *prop_name)
{
    Atom property;
    Atom actual_return_type;
    int actual_format_return = 0;
    unsigned long nitems_return = 0;
    unsigned long bytes_after_return = 0;
    unsigned char *prop_return = 0;
    long long_length = 1024;
    size_t limit;
    char *result = 0;

    TRACE(("getProperty %s(%s)\n", prop_name,
	   req_type ? TraceAtomName(dpy, req_type) : "?"));
    property = XInternAtom(dpy, prop_name, False);

    if (!xtermGetWinProp(dpy,
			 w,
			 property,
			 0L,
			 long_length,
			 req_type,
			 &actual_return_type,
			 &actual_format_return,
			 &nitems_return,
			 &bytes_after_return,
			 &prop_return)) {
	TRACE((".. Cannot get %s property.\n", prop_name));
    } else if (prop_return != 0) {

	if (nitems_return != 0 &&
	    actual_format_return != 0 &&
	    actual_return_type == req_type) {
	    /*
	     * Null-terminate the result to make string handling easier.
	     * The format==8 corresponds to strings, and the number of items
	     * is the number of characters.
	     */
	    if (actual_format_return == 8) {
		limit = nitems_return;
	    } else {
		/* manpage is misleading - X really uses 'long', not 32-bits */
		limit = sizeof(long) * nitems_return;
	    }
	    if ((result = malloc(limit + 1)) != 0) {
		memcpy(result, prop_return, limit);
		result[limit] = '\0';
	    }
	    TRACE(("... result %s\n", result ? ("ok") : "null"));
	}
	XFree(prop_return);
    } else {
	TRACE((".. no property returned\n"));
    }
    return (void *) result;
}

/*
 * Active icons are supported by fvwm.  This feature is not supported by
 * metacity (gnome) or kwin (kde).  Both metacity and kwin support (in
 * incompatible ways, e.g., one uses the icon theme as a fallback for window
 * decorations but the other does not, etc, ...) an icon as part of the window
 * decoration (usually on the upper-left of the window).
 *
 * In either case, xterm's icon will only be shown in the window decorations if
 * xterm does not use the active icon feature.
 *
 * This function (tries to) determine the window manager's name, so that we can
 * provide a useful automatic default for active icons.  It is based on reading
 * wmctrl, which covers most of EWMH and ICCM.
 */
static char *
getWindowManagerName(XtermWidget xw)
{
    TScreen *screen = TScreenOf(xw);
    Display *dpy = screen->display;
    Window *sup_window = NULL;
    char *result = 0;

    TRACE(("getWindowManagerName\n"));
#define getWinProp(type, name) \
    (Window *)getProperty(dpy, DefaultRootWindow(dpy), type, name)
    if ((sup_window = getWinProp(XA_WINDOW, "_NET_SUPPORTING_WM_CHECK")) == 0) {
	sup_window = getWinProp(XA_CARDINAL, "_WIN_SUPPORTING_WM_CHECK");
    }

    /*
     * If we found the supporting window, get the property containing the
     * window manager's name.  EWMH defines _NET_WM_NAME, while ICCM defines
     * WM_CLASS.  There is no standard for the names stored there;
     * conventionally it is mixed case.  In practice, the former is more often
     * set; the latter is not given (or is a lowercased version of the former).
     */
    if (sup_window != 0) {
#define getStringProp(type,name) \
	(char *)getProperty(dpy, *sup_window, type, name)
	if ((result = getStringProp(XA_UTF8_STRING(dpy), "_NET_WM_NAME")) == 0
	    && (result = getStringProp(XA_STRING, "_NET_WM_NAME")) == 0
	    && (result = getStringProp(XA_STRING, "WM_CLASS")) == 0) {
	    TRACE(("... window manager does not tell its name\n"));
	}
	free(sup_window);
    } else {
	TRACE(("... Cannot get window manager info properties\n"));
    }
    if (result == 0)
	result = x_strdup("unknown");
    TRACE(("... window manager name is %s\n", result));
    return result;
}
#endif

/*ARGSUSED*/
static void
VTRealize(Widget w,
	  XtValueMask * valuemask,
	  XSetWindowAttributes * values)
{
    XtermWidget xw = (XtermWidget) w;
    TScreen *screen = TScreenOf(xw);

    const VTFontNames *myfont;
    struct Xinerama_geometry pos;
    int pr;
    Atom pid_atom;
    int i;

    TRACE(("VTRealize {{\n"));

#if OPT_TOOLBAR
    /*
     * Layout for the toolbar confuses the Shell widget.  Remind it that we
     * would like to be iconified if the corresponding resource was set.
     */
    if (XtIsRealized(toplevel)) {
	Boolean iconic = 0;

	XtVaGetValues(toplevel,
		      XtNiconic, &iconic,
		      (XtPointer) 0);

	if (iconic) {
	    XIconifyWindow(XtDisplay(toplevel),
			   XtWindow(toplevel),
			   DefaultScreen(XtDisplay(toplevel)));
	}
    }
#endif

    TabReset(xw->tabs);

    if (screen->menu_font_number == fontMenu_default) {
	myfont = defaultVTFontNames(xw);
    } else {
	myfont = xtermFontName(screen->MenuFontName(screen->menu_font_number));
    }
    memset(screen->fnts, 0, sizeof(screen->fnts));

    if (!xtermLoadFont(xw,
		       myfont,
		       False,
		       screen->menu_font_number)) {
	if (XmuCompareISOLatin1(myfont->f_n, DEFFONT) != 0) {
	    char *use_font = x_strdup(DEFFONT);
	    xtermWarning("unable to open font \"%s\", trying \"%s\"....\n",
			 myfont->f_n, use_font);
	    (void) xtermLoadFont(xw,
				 xtermFontName(use_font),
				 False,
				 screen->menu_font_number);
	    screen->MenuFontName(screen->menu_font_number) = use_font;
	}
    }

    /* really screwed if we couldn't open default font */
    if (!getNormalFont(screen, fNorm)->fs) {
	xtermWarning("unable to locate a suitable font\n");
	Exit(1);
    }
#if OPT_WIDE_CHARS
    if (screen->utf8_mode) {
	TRACE(("check if this is a wide font, if not try again\n"));
	if (xtermLoadWideFonts(xw, False)) {
	    SetVTFont(xw, screen->menu_font_number, True, NULL);
	    /* we will not be able to switch to ISO-8859-1 */
	    if (!screen->mergedVTFonts) {
		screen->utf8_fonts = uAlways;
		update_font_utf8_fonts();
	    }
	}
    }
#endif

    /* making cursor */
    if (!screen->pointer_cursor) {
	screen->pointer_cursor =
	    make_colored_cursor(XC_xterm,
				T_COLOR(screen, MOUSE_FG),
				T_COLOR(screen, MOUSE_BG));
    } else {
	recolor_cursor(screen,
		       screen->pointer_cursor,
		       T_COLOR(screen, MOUSE_FG),
		       T_COLOR(screen, MOUSE_BG));
    }

    /* set defaults */
    pos.x = 1;
    pos.y = 1;
    pos.w = 80;
    pos.h = 24;

    TRACE(("parsing geo_metry %s\n", NonNull(xw->misc.geo_metry)));
    pr = XParseXineramaGeometry(screen->display, xw->misc.geo_metry, &pos);
    TRACE(("... position %d,%d size %dx%d\n", pos.y, pos.x, pos.h, pos.w));

    set_max_col(screen, (int) (pos.w - 1));	/* units in character cells */
    set_max_row(screen, (int) (pos.h - 1));	/* units in character cells */
    xtermUpdateFontInfo(xw, False);

    pos.w = screen->fullVwin.fullwidth;
    pos.h = screen->fullVwin.fullheight;

    TRACE(("... border widget %d parent %d shell %d\n",
	   BorderWidth(xw),
	   BorderWidth(XtParent(xw)),
	   BorderWidth(SHELL_OF(xw))));

    if ((pr & XValue) && (XNegative & pr)) {
	pos.x = (Position) (pos.x + (pos.scr_w
				     - (int) pos.w
				     - (BorderWidth(XtParent(xw)) * 2)));
    }
    if ((pr & YValue) && (YNegative & pr)) {
	pos.y = (Position) (pos.y + (pos.scr_h
				     - (int) pos.h
				     - (BorderWidth(XtParent(xw)) * 2)));
    }
    pos.x = (Position) (pos.x + pos.scr_x);
    pos.y = (Position) (pos.y + pos.scr_y);

    /* set up size hints for window manager; min 1 char by 1 char */
    getXtermSizeHints(xw);
    xtermSizeHints(xw, (xw->misc.scrollbar
			? (screen->scrollWidget->core.width
			   + BorderWidth(screen->scrollWidget))
			: 0));

    xw->hints.x = pos.x;
    xw->hints.y = pos.y;
#if OPT_MAXIMIZE
    /* assure single-increment resize for fullscreen */
    if (term->work.ewmh[0].mode) {
	xw->hints.width_inc = 1;
	xw->hints.height_inc = 1;
    }
#endif
    if ((XValue & pr) || (YValue & pr)) {
	xw->hints.flags |= USSize | USPosition;
	xw->hints.flags |= PWinGravity;
	switch (pr & (XNegative | YNegative)) {
	case 0:
	    xw->hints.win_gravity = NorthWestGravity;
	    break;
	case XNegative:
	    xw->hints.win_gravity = NorthEastGravity;
	    break;
	case YNegative:
	    xw->hints.win_gravity = SouthWestGravity;
	    break;
	default:
	    xw->hints.win_gravity = SouthEastGravity;
	    break;
	}
    } else {
	/* set a default size, but do *not* set position */
	xw->hints.flags |= PSize;
    }
    xw->hints.height = xw->hints.base_height
	+ xw->hints.height_inc * MaxRows(screen);
    xw->hints.width = xw->hints.base_width
	+ xw->hints.width_inc * MaxCols(screen);

    if ((WidthValue & pr) || (HeightValue & pr))
	xw->hints.flags |= USSize;
    else
	xw->hints.flags |= PSize;

    /*
     * Note that the size-hints are for the shell, while the resize-request
     * is for the vt100 widget.  They are not the same size.
     */
    (void) REQ_RESIZE((Widget) xw,
		      (Dimension) pos.w, (Dimension) pos.h,
		      &xw->core.width, &xw->core.height);

    /* XXX This is bogus.  We are parsing geometries too late.  This
     * is information that the shell widget ought to have before we get
     * realized, so that it can do the right thing.
     */
    if (xw->hints.flags & USPosition)
	XMoveWindow(XtDisplay(xw), VShellWindow(xw),
		    xw->hints.x, xw->hints.y);

    TRACE(("%s@@%d -- ", __FILE__, __LINE__));
    TRACE_HINTS(&xw->hints);
    XSetWMNormalHints(XtDisplay(xw), VShellWindow(xw), &xw->hints);
    TRACE(("%s@@%d -- ", __FILE__, __LINE__));
    TRACE_WM_HINTS(xw);

    if ((pid_atom = XInternAtom(XtDisplay(xw), "_NET_WM_PID", False)) != None) {
	/* XChangeProperty format 32 really is "long" */
	unsigned long pid_l = (unsigned long) getpid();
	TRACE(("Setting _NET_WM_PID property to %lu\n", pid_l));
	XChangeProperty(XtDisplay(xw), VShellWindow(xw),
			pid_atom, XA_CARDINAL, 32, PropModeReplace,
			(unsigned char *) &pid_l, 1);
    }

    XFlush(XtDisplay(xw));	/* get it out to window manager */

    /* use ForgetGravity instead of SouthWestGravity because translating
       the Expose events for ConfigureNotifys is too hard */
    values->bit_gravity = (GravityIsNorthWest(xw)
			   ? NorthWestGravity
			   : ForgetGravity);
    screen->fullVwin.window = XtWindow(xw) =
	XCreateWindow(XtDisplay(xw), XtWindow(XtParent(xw)),
		      xw->core.x, xw->core.y,
		      xw->core.width, xw->core.height, BorderWidth(xw),
		      (int) xw->core.depth,
		      InputOutput, CopyFromParent,
		      *valuemask | CWBitGravity, values);
#if OPT_DOUBLE_BUFFER
    screen->fullVwin.drawable = screen->fullVwin.window;

    {
	Window win = screen->fullVwin.window;
	Drawable d;
	int major, minor;
	if (!XdbeQueryExtension(XtDisplay(xw), &major, &minor)) {
	    fprintf(stderr, "XdbeQueryExtension returned zero!\n");
	    exit(3);
	}
	d = XdbeAllocateBackBufferName(XtDisplay(xw), win, XdbeCopied);
	if (d == None) {
	    fprintf(stderr, "Couldn't allocate a back buffer!\n");
	    exit(3);
	}
	screen->fullVwin.drawable = d;
	screen->needSwap = 1;
    }
#endif /* OPT_DOUBLE_BUFFER */
    screen->event_mask = values->event_mask;

#ifndef NO_ACTIVE_ICON
    /*
     * Normally, the font-number for icon fonts does not correspond with any of
     * the menu-selectable fonts.  If we cannot load the font given for the
     * iconFont resource, try with font1 aka "Unreadable".
     */
    screen->icon_fontnum = -1;
    if (getIconicFont(screen)->fs == 0) {
	getIconicFont(screen)->fs =
	    XLoadQueryFont(screen->display,
			   screen->MenuFontName(fontMenu_font1));
	TRACE(("%susing font1 '%s' as iconFont\n",
	       (getIconicFont(screen)->fs
		? ""
		: "NOT "),
	       screen->MenuFontName(fontMenu_font1)));
    }
#if OPT_RENDERFONT
    /*
     * If we still have no result from iconFont resource (perhaps because fonts
     * are missing) but are using Xft, try to use that instead.  We prefer
     * bitmap fonts in any case, since scaled fonts are usually less readable,
     * particularly at small sizes.
     */
    if (UsingRenderFont(xw)
	&& getIconicFont(screen)->fs == 0) {
	screen->icon_fontnum = fontMenu_default;
	getIconicFont(screen)->fs = getNormalFont(screen, fNorm)->fs;	/* need for next-if */
	TRACE(("using TrueType font as iconFont\n"));
    }
#endif
    if ((xw->work.active_icon == eiDefault) && getIconicFont(screen)->fs) {
	char *wm_name = getWindowManagerName(xw);
	if (x_strncasecmp(wm_name, "fvwm", 4) &&
	    x_strncasecmp(wm_name, "window maker", 12))
	    xw->work.active_icon = eiFalse;
	free(wm_name);
    }
    if (xw->work.active_icon && getIconicFont(screen)->fs) {
	int iconX = 0, iconY = 0;
	Widget shell = SHELL_OF(xw);
	VTwin *win = &(screen->iconVwin);
	int save_fontnum = screen->menu_font_number;

	TRACE(("Initializing active-icon %d\n", screen->icon_fontnum));
	screen->menu_font_number = screen->icon_fontnum;
	XtVaGetValues(shell,
		      XtNiconX, &iconX,
		      XtNiconY, &iconY,
		      (XtPointer) 0);
	xtermComputeFontInfo(xw, &(screen->iconVwin),
			     getIconicFont(screen)->fs, 0);
	screen->menu_font_number = save_fontnum;

	/* since only one client is permitted to select for Button
	 * events, we have to let the window manager get 'em...
	 */
	values->event_mask &= ~(ButtonPressMask | ButtonReleaseMask);
	values->border_pixel = xw->misc.icon_border_pixel;

	screen->iconVwin.window =
	    XCreateWindow(XtDisplay(xw),
			  RootWindowOfScreen(XtScreen(shell)),
			  iconX, iconY,
			  screen->iconVwin.fullwidth,
			  screen->iconVwin.fullheight,
			  xw->misc.icon_border_width,
			  (int) xw->core.depth,
			  InputOutput, CopyFromParent,
			  *valuemask | CWBitGravity | CWBorderPixel,
			  values);
#if OPT_DOUBLE_BUFFER
	screen->iconVwin.drawable = screen->iconVwin.window;
#endif
	XtVaSetValues(shell,
		      XtNiconWindow, screen->iconVwin.window,
		      (XtPointer) 0);
	XtRegisterDrawable(XtDisplay(xw), screen->iconVwin.window, w);

	setCgsFont(xw, win, gcNorm, getIconicFont(screen));
	setCgsFore(xw, win, gcNorm, T_COLOR(screen, TEXT_FG));
	setCgsBack(xw, win, gcNorm, T_COLOR(screen, TEXT_BG));

	copyCgs(xw, win, gcBold, gcNorm);

	setCgsFont(xw, win, gcNormReverse, getIconicFont(screen));
	setCgsFore(xw, win, gcNormReverse, T_COLOR(screen, TEXT_BG));
	setCgsBack(xw, win, gcNormReverse, T_COLOR(screen, TEXT_FG));

	copyCgs(xw, win, gcBoldReverse, gcNormReverse);

#if OPT_TOOLBAR
	/*
	 * Toolbar is initialized before we get here.  Enable the menu item
	 * and set it properly.
	 */
	SetItemSensitivity(vtMenuEntries[vtMenu_activeicon].widget, True);
	update_activeicon();
#endif
    } else {
	TRACE(("Disabled active-icon\n"));
	xw->work.active_icon = eiFalse;
    }
#endif /* NO_ACTIVE_ICON */

#if OPT_I18N_SUPPORT && OPT_INPUT_METHOD
    VTInitI18N(xw);
#endif
#if OPT_NUM_LOCK
    VTInitModifiers(xw);
#if OPT_EXTRA_PASTE
    if (xw->keyboard.extra_translations) {
	XtOverrideTranslations((Widget) xw,
			       XtParseTranslationTable(xw->keyboard.extra_translations));
    }
#endif
#endif

    set_cursor_gcs(xw);

    /* Reset variables used by ANSI emulation. */

    resetCharsets(screen);

    XDefineCursor(screen->display, VShellWindow(xw), screen->pointer_cursor);

    set_cur_col(screen, 0);
    set_cur_row(screen, 0);
    set_max_col(screen, Width(screen) / screen->fullVwin.f_width - 1);
    set_max_row(screen, Height(screen) / screen->fullVwin.f_height - 1);
    reset_margins(screen);

    memset(screen->sc, 0, sizeof(screen->sc));

    /* Mark screen buffer as unallocated.  We wait until the run loop so
       that the child process does not fork and exec with all the dynamic
       memory it will never use.  If we were to do it here, the
       swap space for new process would be huge for huge savelines. */
#if OPT_TEK4014
    if (!tekWidget)		/* if not called after fork */
#endif
    {
	screen->visbuf = NULL;
	screen->saveBuf_index = NULL;
    }

    ResetWrap(screen);
    screen->scrolls = screen->incopy = 0;
    xtermSetCursorBox(screen);

    screen->savedlines = 0;

    for (i = 0; i < 2; ++i) {
	screen->whichBuf = !screen->whichBuf;
	CursorSave(xw);
    }

#ifndef NO_ACTIVE_ICON
    if (!xw->work.active_icon)
#endif
	xtermLoadIcon(xw);

    /*
     * Do this last, since it may change the layout via a resize.
     */
    if (xw->misc.scrollbar) {
	screen->fullVwin.sb_info.width = 0;
	ScrollBarOn(xw, False);
    }

    xtermSetWinSize(xw);
    TRACE(("}} VTRealize\n"));
}

#if OPT_I18N_SUPPORT && OPT_INPUT_METHOD

/* limit this feature to recent XFree86 since X11R6.x core dumps */
#if defined(XtSpecificationRelease) && XtSpecificationRelease >= 6 && defined(X_HAVE_UTF8_STRING)
#define USE_XIM_INSTANTIATE_CB

static void
xim_instantiate_cb(Display *display,
		   XPointer client_data GCC_UNUSED,
		   XPointer call_data GCC_UNUSED)
{
    TRACE(("xim_instantiate_cb client=%p, call=%p\n", client_data, call_data));

    if (display == XtDisplay(term)) {
	VTInitI18N(term);
    }
}

static void
xim_destroy_cb(XIM im GCC_UNUSED,
	       XPointer client_data GCC_UNUSED,
	       XPointer call_data GCC_UNUSED)
{
    XtermWidget xw = term;
    TInput *input = lookupTInput(xw, (Widget) xw);

    TRACE(("xim_destroy_cb im=%lx, client=%p, call=%p\n",
	   (long) im, client_data, call_data));
    if (input)
	input->xic = NULL;
    XRegisterIMInstantiateCallback(XtDisplay(xw), NULL, NULL, NULL,
				   xim_instantiate_cb, NULL);
}
#endif /* X11R6+ */

static Boolean
xim_create_fs(XtermWidget xw)
{
    XFontStruct **fonts;
    char **font_name_list;
    char **missing_charset_list;
    char *def_string;
    int missing_charset_count;
    unsigned i, j;

    if (xw->work.xim_fs == 0) {
	xw->work.xim_fs = XCreateFontSet(XtDisplay(xw),
					 xw->misc.f_x,
					 &missing_charset_list,
					 &missing_charset_count,
					 &def_string);
	if (xw->work.xim_fs == NULL) {
	    xtermWarning("Preparation of font set "
			 "\"%s\" for XIM failed.\n", xw->misc.f_x);
	    xw->work.xim_fs = XCreateFontSet(XtDisplay(xw),
					     DEFXIMFONT,
					     &missing_charset_list,
					     &missing_charset_count,
					     &def_string);
	}
    }
    if (xw->work.xim_fs == NULL) {
	xtermWarning("Preparation of default font set "
		     "\"%s\" for XIM failed.\n", DEFXIMFONT);
	cleanupInputMethod(xw);
	xw->work.cannot_im = True;
    } else {
	(void) XExtentsOfFontSet(xw->work.xim_fs);
	j = (unsigned) XFontsOfFontSet(xw->work.xim_fs, &fonts, &font_name_list);
	for (i = 0, xw->work.xim_fs_ascent = 0; i < j; i++) {
	    if (xw->work.xim_fs_ascent < (*fonts)->ascent)
		xw->work.xim_fs_ascent = (*fonts)->ascent;
	}
    }
    return (Boolean) !(xw->work.cannot_im);
}

static void
xim_create_xic(XtermWidget xw, Widget theInput)
{
    Display *myDisplay = XtDisplay(theInput);
    Window myWindow = XtWindow(theInput);
    unsigned i, j;
    char *p = NULL, *s, *t, *ns, *end, buf[32];
    XIMStyles *xim_styles;
    XIMStyle input_style = 0;
    Bool found;
    static struct {
	const char *name;
	unsigned long code;
    } known_style[] = {
	{
	    "OverTheSpot", (XIMPreeditPosition | XIMStatusNothing)
	},
	{
	    "OffTheSpot", (XIMPreeditArea | XIMStatusArea)
	},
	{
	    "Root", (XIMPreeditNothing | XIMStatusNothing)
	},
    };
    TInput *input = lookupTInput(xw, theInput);

    if (xw->work.cannot_im) {
	return;
    }

    if (input == 0) {
	for (i = 0; i < NINPUTWIDGETS; ++i) {
	    if (xw->work.inputs[i].w == 0) {
		input = xw->work.inputs + i;
		input->w = theInput;
		break;
	    }
	}
    }

    if (input == 0) {
	xtermWarning("attempted to add too many input widgets\n");
	return;
    }

    TRACE(("xim_real_init\n"));

    if (IsEmpty(xw->misc.input_method)) {
	if ((p = XSetLocaleModifiers("")) != NULL && *p) {
	    input->xim = XOpenIM(myDisplay, NULL, NULL, NULL);
	}
    } else {
	s = xw->misc.input_method;
	i = 5 + (unsigned) strlen(s);

	t = (char *) MyStackAlloc(i, buf);
	if (t == NULL) {
	    SysError(ERROR_VINIT);
	} else {

	    for (ns = s; ns && *s;) {
		while (*s && isspace(CharOf(*s)))
		    s++;
		if (!*s)
		    break;
		if ((ns = end = strchr(s, ',')) == 0)
		    end = s + strlen(s);
		while ((end != s) && isspace(CharOf(end[-1])))
		    end--;

		if (end != s) {
		    strcpy(t, "@@im=");
		    strncat(t, s, (size_t) (end - s));

		    if ((p = XSetLocaleModifiers(t)) != 0 && *p
			&& (input->xim = XOpenIM(myDisplay,
						 NULL,
						 NULL,
						 NULL)) != 0) {
			break;
		    }

		}
		s = ns + 1;
	    }
	    MyStackFree(t, buf);
	}
    }

    if (input->xim == NULL
	&& (p = XSetLocaleModifiers("@@im=none")) != NULL
	&& *p) {
	input->xim = XOpenIM(myDisplay, NULL, NULL, NULL);
    }

    if (!input->xim) {
	xtermWarning("Failed to open input method\n");
	return;
    }
    TRACE(("VTInitI18N opened input method:%s\n", NonNull(p)));

    if (XGetIMValues(input->xim, XNQueryInputStyle, &xim_styles, (void *) 0)
	|| !xim_styles
	|| !xim_styles->count_styles) {
	xtermWarning("input method doesn't support any style\n");
	cleanupInputMethod(xw);
	xw->work.cannot_im = True;
	return;
    }

    found = False;
    for (s = xw->misc.preedit_type; s && !found;) {
	while (*s && isspace(CharOf(*s)))
	    s++;
	if (!*s)
	    break;
	if ((ns = end = strchr(s, ',')) != 0)
	    ns++;
	else
	    end = s + strlen(s);
	while ((end != s) && isspace(CharOf(end[-1])))
	    end--;

	if (end != s) {		/* just in case we have a spurious comma */
	    TRACE(("looking for style '%.*s'\n", (int) (end - s), s));
	    for (i = 0; i < XtNumber(known_style); i++) {
		if ((int) strlen(known_style[i].name) == (end - s)
		    && !strncmp(s, known_style[i].name, (size_t) (end - s))) {
		    input_style = known_style[i].code;
		    for (j = 0; j < xim_styles->count_styles; j++) {
			if (input_style == xim_styles->supported_styles[j]) {
			    found = True;
			    break;
			}
		    }
		    if (found)
			break;
		}
	    }
	}

	s = ns;
    }
    XFree(xim_styles);

    if (!found) {
	xtermWarning("input method doesn't support my preedit type (%s)\n",
		     xw->misc.preedit_type);
	cleanupInputMethod(xw);
	xw->work.cannot_im = True;
	return;
    }

    /*
     * Check for styles we do not yet support.
     */
    TRACE(("input_style %#lx\n", input_style));
    if (input_style == (XIMPreeditArea | XIMStatusArea)) {
	xtermWarning("This program doesn't support the 'OffTheSpot' preedit type\n");
	cleanupInputMethod(xw);
	xw->work.cannot_im = True;
	return;
    }

    /*
     * For XIMPreeditPosition (or OverTheSpot), XIM client has to
     * prepare a font.
     * The font has to be locale-dependent XFontSet, whereas
     * XTerm use Unicode font.  This leads a problem that the
     * same font cannot be used for XIM preedit.
     */
    if (input_style != (XIMPreeditNothing | XIMStatusNothing)) {
	XVaNestedList p_list;
	XPoint spot =
	{0, 0};

	if (xim_create_fs(xw)) {
	    p_list = XVaCreateNestedList(0,
					 XNSpotLocation, &spot,
					 XNFontSet, xw->work.xim_fs,
					 (void *) 0);
	    input->xic = XCreateIC(input->xim,
				   XNInputStyle, input_style,
				   XNClientWindow, myWindow,
				   XNFocusWindow, myWindow,
				   XNPreeditAttributes, p_list,
				   (void *) 0);
	}
    } else {
	input->xic = XCreateIC(input->xim, XNInputStyle, input_style,
			       XNClientWindow, myWindow,
			       XNFocusWindow, myWindow,
			       (void *) 0);
    }

    if (!input->xic) {
	xtermWarning("Failed to create input context\n");
	cleanupInputMethod(xw);
    }
#if defined(USE_XIM_INSTANTIATE_CB)
    else {
	XIMCallback destroy_cb;

	destroy_cb.callback = xim_destroy_cb;
	destroy_cb.client_data = NULL;
	if (XSetIMValues(input->xim,
			 XNDestroyCallback,
			 &destroy_cb,
			 (void *) 0)) {
	    xtermWarning("Could not set destroy callback to IM\n");
	}
    }
#endif

    return;
}

static void
xim_real_init(XtermWidget xw)
{
    xim_create_xic(xw, (Widget) xw);
}

static void
VTInitI18N(XtermWidget xw)
{
    if (xw->misc.open_im) {
	xim_real_init(xw);

#if defined(USE_XIM_INSTANTIATE_CB)
	if (lookupTInput(xw, (Widget) xw) == NULL
	    && !xw->work.cannot_im
	    && xw->misc.retry_im-- > 0) {
	    sleep(3);
	    XRegisterIMInstantiateCallback(XtDisplay(xw), NULL, NULL, NULL,
					   xim_instantiate_cb, NULL);
	}
#endif
    }
}

TInput *
lookupTInput(XtermWidget xw, Widget w)
{
    TInput *result = 0;
    unsigned n;

    for (n = 0; n < NINPUTWIDGETS; ++n) {
	if (xw->work.inputs[n].w == w) {
	    result = xw->work.inputs + n;
	    break;
	}
    }

    return result;
}
#endif /* OPT_I18N_SUPPORT && OPT_INPUT_METHOD */

static void
set_cursor_outline_gc(XtermWidget xw,
		      Bool filled,
		      Pixel fg,
		      Pixel bg,
		      Pixel cc)
{
    TScreen *screen = TScreenOf(xw);
    VTwin *win = WhichVWin(screen);
    CgsEnum cgsId = gcVTcursOutline;

    if (cc == bg)
	cc = fg;

    if (filled) {
	setCgsFore(xw, win, cgsId, bg);
	setCgsBack(xw, win, cgsId, cc);
    } else {
	setCgsFore(xw, win, cgsId, cc);
	setCgsBack(xw, win, cgsId, bg);
    }
}

static Boolean
VTSetValues(Widget cur,
	    Widget request GCC_UNUSED,
	    Widget wnew,
	    ArgList args GCC_UNUSED,
	    Cardinal *num_args GCC_UNUSED)
{
    XtermWidget curvt = (XtermWidget) cur;
    XtermWidget newvt = (XtermWidget) wnew;
    Boolean refresh_needed = False;
    Boolean fonts_redone = False;

    if ((T_COLOR(TScreenOf(curvt), TEXT_BG) !=
	 T_COLOR(TScreenOf(newvt), TEXT_BG)) ||
	(T_COLOR(TScreenOf(curvt), TEXT_FG) !=
	 T_COLOR(TScreenOf(newvt), TEXT_FG)) ||
	(TScreenOf(curvt)->MenuFontName(TScreenOf(curvt)->menu_font_number) !=
	 TScreenOf(newvt)->MenuFontName(TScreenOf(newvt)->menu_font_number)) ||
	strcmp(DefaultFontN(curvt), DefaultFontN(newvt))) {
	if (strcmp(DefaultFontN(curvt), DefaultFontN(newvt))) {
	    TScreenOf(newvt)->MenuFontName(fontMenu_default) = DefaultFontN(newvt);
	}
	if (xtermLoadFont(newvt,
			  xtermFontName(TScreenOf(newvt)->MenuFontName(TScreenOf(curvt)->menu_font_number)),
			  True, TScreenOf(newvt)->menu_font_number)) {
	    /* resizing does the redisplay, so don't ask for it here */
	    refresh_needed = True;
	    fonts_redone = True;
	} else if (strcmp(DefaultFontN(curvt), DefaultFontN(newvt))) {
	    TScreenOf(newvt)->MenuFontName(fontMenu_default) = DefaultFontN(curvt);
	}
    }
    if (!fonts_redone
	&& (T_COLOR(TScreenOf(curvt), TEXT_CURSOR) !=
	    T_COLOR(TScreenOf(newvt), TEXT_CURSOR))) {
	if (set_cursor_gcs(newvt))
	    refresh_needed = True;
    }
    if (curvt->misc.re_verse != newvt->misc.re_verse) {
	newvt->flags ^= REVERSE_VIDEO;
	ReverseVideo(newvt);
	/* ReverseVideo toggles */
	newvt->misc.re_verse = (Boolean) (!newvt->misc.re_verse);
	refresh_needed = True;
    }
    if ((T_COLOR(TScreenOf(curvt), MOUSE_FG) !=
	 T_COLOR(TScreenOf(newvt), MOUSE_FG)) ||
	(T_COLOR(TScreenOf(curvt), MOUSE_BG) !=
	 T_COLOR(TScreenOf(newvt), MOUSE_BG))) {
	recolor_cursor(TScreenOf(newvt),
		       TScreenOf(newvt)->pointer_cursor,
		       T_COLOR(TScreenOf(newvt), MOUSE_FG),
		       T_COLOR(TScreenOf(newvt), MOUSE_BG));
	refresh_needed = True;
    }
    if (curvt->misc.scrollbar != newvt->misc.scrollbar) {
	ToggleScrollBar(newvt);
    }

    return refresh_needed;
}

/*
 * Given a font-slot and information about selection/reverse, find the
 * corresponding cached-GC slot.
 */
static int
reverseCgs(XtermWidget xw, unsigned attr_flags, Bool hilite, int font)
{
    TScreen *screen = TScreenOf(xw);
    CgsEnum result = gcMAX;

    if (ReverseOrHilite(screen, attr_flags, hilite)) {
	switch (font) {
	case fNorm:
	    result = gcNormReverse;
	    break;
	case fBold:
	    result = gcBoldReverse;
	    break;
#if OPT_WIDE_ATTRS || OPT_RENDERWIDE
	case fItal:
	    result = gcNormReverse;	/* FIXME */
	    break;
#endif
#if OPT_WIDE_CHARS
	case fWide:
	    result = gcWideReverse;
	    break;
	case fWBold:
	    result = gcWBoldReverse;
	    break;
	case fWItal:
	    result = gcWideReverse;	/* FIXME */
	    break;
#endif
	}
    } else {
	switch (font) {
	case fNorm:
	    result = gcNorm;
	    break;
	case fBold:
	    result = gcBold;
	    break;
#if OPT_WIDE_ATTRS || OPT_RENDERWIDE
	case fItal:
	    result = gcNorm;	/* FIXME */
	    break;
#endif
#if OPT_WIDE_CHARS
	case fWide:
	    result = gcWide;
	    break;
	case fWBold:
	    result = gcWBold;
	    break;
	case fWItal:
	    result = gcWide;	/* FIXME */
	    break;
#endif
	}
    }
    return result;
}

#define setGC(code) set_at = __LINE__, currentCgs = code

#define OutsideSelection(screen,srow,scol)  \
	 ((srow) > (screen)->endH.row || \
	  ((srow) == (screen)->endH.row && \
	   (scol) >= (screen)->endH.col) || \
	  (srow) < (screen)->startH.row || \
	  ((srow) == (screen)->startH.row && \
	   (scol) < (screen)->startH.col))

/*
 * Shows cursor at new cursor position in screen.
 */
void
ShowCursor(void)
{
    XtermWidget xw = term;
    TScreen *screen = TScreenOf(xw);
    IChar base;
    unsigned flags;
    CellColor fg_bg = 0;
    GC currentGC;
    GC outlineGC;
    CgsEnum currentCgs = gcMAX;
    VTwin *currentWin = WhichVWin(screen);
    int set_at;
    Bool in_selection;
    Bool reversed;
    Bool filled;
    Pixel fg_pix;
    Pixel bg_pix;
    Pixel tmp;
#if OPT_HIGHLIGHT_COLOR
    Pixel selbg_pix = T_COLOR(screen, HIGHLIGHT_BG);
    Pixel selfg_pix = T_COLOR(screen, HIGHLIGHT_FG);
    Boolean use_selbg;
    Boolean use_selfg;
#endif
#if OPT_WIDE_CHARS
    int my_col = 0;
#endif
    int cursor_col;
    CLineData *ld = 0;

    if (screen->cursor_state == BLINKED_OFF)
	return;

    if (screen->eventMode != NORMAL)
	return;

    if (INX2ROW(screen, screen->cur_row) > screen->max_row)
	return;

    screen->cursorp.row = screen->cur_row;
    cursor_col = screen->cursorp.col = screen->cur_col;
    screen->cursor_moved = False;

#ifndef NO_ACTIVE_ICON
    if (IsIcon(screen)) {
	screen->cursor_state = ON;
	return;
    }
#endif /* NO_ACTIVE_ICON */

    ld = getLineData(screen, screen->cur_row);

    base = ld->charData[cursor_col];
    flags = ld->attribs[cursor_col];

    if_OPT_WIDE_CHARS(screen, {
	if (base == HIDDEN_CHAR && cursor_col > 0) {
	    /* if cursor points to non-initial part of wide character,
	     * back it up
	     */
	    --cursor_col;
	    base = ld->charData[cursor_col];
	}
	my_col = cursor_col;
	if (base == 0)
	    base = ' ';
	if (isWide((int) base))
	    my_col += 1;
    });

    if (base == 0) {
	base = ' ';
    }
#if OPT_ISO_COLORS
#ifdef EXP_BOGUS_FG
    /*
     * If the cursor happens to be on blanks, and we have not set both
     * foreground and background color, do not treat it as a colored cell.
     */
    if (base == ' ') {
	if ((flags & (FG_COLOR | BG_COLOR)) == BG_COLOR) {
	    TRACE(("ShowCursor - do not treat as a colored cell\n"));
	    flags &= ~(FG_COLOR | BG_COLOR);
	} else if ((flags & (FG_COLOR | BG_COLOR)) == FG_COLOR) {
	    TRACE(("ShowCursor - should we treat as a colored cell?\n"));
	    if (!(xw->flags & FG_COLOR))
		if (CheckBogusForeground(screen, "ShowCursor"))
		    flags &= ~(FG_COLOR | BG_COLOR);
	}
    }
#else /* !EXP_BOGUS_FG */
    /*
     * If the cursor happens to be on blanks, and the foreground color is set
     * but not the background, do not treat it as a colored cell.
     */
    if ((flags & TERM_COLOR_FLAGS(xw)) == FG_COLOR
	&& base == ' ') {
	flags &= ~TERM_COLOR_FLAGS(xw);
    }
#endif
#endif

    /*
     * Compare the current cell to the last set of colors used for the
     * cursor and update the GC's if needed.
     */
    if_OPT_ISO_COLORS(screen, {
	fg_bg = ld->color[cursor_col];
    });

    fg_pix = getXtermForeground(xw, flags, (int) extract_fg(xw, fg_bg, flags));
    bg_pix = getXtermBackground(xw, flags, (int) extract_bg(xw, fg_bg, flags));

    /*
     * If we happen to have the same foreground/background colors, choose
     * a workable foreground color from which we can obtain a visible cursor.
     */
    if (fg_pix == bg_pix) {
	long bg_diff = (long) (bg_pix - T_COLOR(TScreenOf(xw), TEXT_BG));
	long fg_diff = (long) (bg_pix - T_COLOR(TScreenOf(xw), TEXT_FG));
	if (bg_diff < 0)
	    bg_diff = -bg_diff;
	if (fg_diff < 0)
	    fg_diff = -fg_diff;
	if (bg_diff < fg_diff) {
	    fg_pix = T_COLOR(TScreenOf(xw), TEXT_FG);
	} else {
	    fg_pix = T_COLOR(TScreenOf(xw), TEXT_BG);
	}
    }

    if (OutsideSelection(screen, screen->cur_row, screen->cur_col))
	in_selection = False;
    else
	in_selection = True;

    reversed = ReverseOrHilite(screen, flags, in_selection);

    /* This is like updatedXtermGC(), except that we have to worry about
     * whether the window has focus, since in that case we want just an
     * outline for the cursor.
     */
    filled = (screen->select || screen->always_highlight) && isCursorBlock(screen);
#if OPT_HIGHLIGHT_COLOR
    use_selbg = isNotForeground(xw, fg_pix, bg_pix, selbg_pix);
    use_selfg = isNotBackground(xw, fg_pix, bg_pix, selfg_pix);
#endif
    if (filled) {
	if (reversed) {		/* text is reverse video */
	    if (getCgsGC(xw, currentWin, gcVTcursNormal)) {
		setGC(gcVTcursNormal);
	    } else {
		if (flags & BOLDATTR(screen)) {
		    setGC(gcBold);
		} else {
		    setGC(gcNorm);
		}
	    }
	    EXCHANGE(fg_pix, bg_pix, tmp);
#if OPT_HIGHLIGHT_COLOR
	    if (screen->hilite_reverse) {
		if (use_selbg && !use_selfg)
		    fg_pix = bg_pix;
		if (use_selfg && !use_selbg)
		    bg_pix = fg_pix;
		if (use_selbg)
		    bg_pix = selbg_pix;
		if (use_selfg)
		    fg_pix = selfg_pix;
	    }
#endif
	} else {		/* normal video */
	    if (getCgsGC(xw, currentWin, gcVTcursReverse)) {
		setGC(gcVTcursReverse);
	    } else {
		if (flags & BOLDATTR(screen)) {
		    setGC(gcBoldReverse);
		} else {
		    setGC(gcNormReverse);
		}
	    }
	}

#define CUR_XX T_COLOR(screen, TEXT_CURSOR)
#define CGS_FG getCgsFore(xw, currentWin, getCgsGC(xw, currentWin, currentCgs))
#define CGS_BG getCgsBack(xw, currentWin, getCgsGC(xw, currentWin, currentCgs))

#define FIX_311 (CUR_XX == (reversed ? xw->dft_background : xw->dft_foreground))
#define FIX_328 (CUR_XX == bg_pix)
#define FIX_330 (FIX_328 && reversed && in_selection)

	if (FIX_330 || FIX_311) {
	    setCgsBack(xw, currentWin, currentCgs, fg_pix);
	}
	setCgsFore(xw, currentWin, currentCgs, bg_pix);
    } else {			/* not selected */
	if (reversed) {		/* text is reverse video */
	    EXCHANGE(fg_pix, bg_pix, tmp);
	    setGC(gcNormReverse);
	} else {		/* normal video */
	    setGC(gcNorm);
	}
#if OPT_HIGHLIGHT_COLOR
	if (screen->hilite_reverse) {
	    if (in_selection && !reversed) {
		/* EMPTY */
		/* really INVERSE ... */
		;
	    } else if (in_selection || reversed) {
		if (use_selbg) {
		    if (use_selfg) {
			bg_pix = fg_pix;
		    } else {
			fg_pix = bg_pix;
		    }
		}
		if (use_selbg) {
		    bg_pix = selbg_pix;
		}
		if (use_selfg) {
		    fg_pix = selfg_pix;
		}
	    }
	} else {
	    if (in_selection) {
		if (use_selbg) {
		    bg_pix = selbg_pix;
		}
		if (use_selfg) {
		    fg_pix = selfg_pix;
		}
	    }
	}
#endif
	setCgsFore(xw, currentWin, currentCgs, fg_pix);
	setCgsBack(xw, currentWin, currentCgs, bg_pix);
    }

    if (screen->cursor_busy == 0
	&& (screen->cursor_state != ON || screen->cursor_GC != set_at)) {
	int x, y;

	screen->cursor_GC = set_at;
	TRACE(("ShowCursor calling drawXtermText cur(%d,%d) %s-%s, set_at %d\n",
	       screen->cur_row, screen->cur_col,
	       (filled ? "filled" : "outline"),
	       (isCursorBlock(screen) ? "box" :
		isCursorUnderline(screen) ? "underline" : "bar"),
	       set_at));

	currentGC = getCgsGC(xw, currentWin, currentCgs);
	x = LineCursorX(screen, ld, cursor_col);
	y = CursorY(screen, screen->cur_row);

	if (!isCursorBlock(screen)) {
	    /*
	     * Overriding the combination of filled, reversed, in_selection is
	     * too complicated since the underline or bar and the text-cell use
	     * different rules.  Just redraw the text-cell, and draw the
	     * underline or bar on top of it.
	     */
	    HideCursor();

	    /*
	     * Our current-GC is likely to have been modified in HideCursor().
	     * Set up a new request.
	     */
	    if (filled) {
		if (FIX_330 || FIX_311) {
		    setCgsBack(xw, currentWin, currentCgs, fg_pix);
		}
		setCgsFore(xw, currentWin, currentCgs, bg_pix);
	    } else {
		setCgsFore(xw, currentWin, currentCgs, fg_pix);
		setCgsBack(xw, currentWin, currentCgs, bg_pix);
	    }
	}

	/*
	 * Update the outline-gc, to keep the cursor color distinct from the
	 * background color.
	 */
	set_cursor_outline_gc(xw,
			      filled,
			      fg_pix,
			      bg_pix,
			      T_COLOR(screen, TEXT_CURSOR));

	outlineGC = getCgsGC(xw, currentWin, gcVTcursOutline);
	if (outlineGC == 0)
	    outlineGC = currentGC;

	if (isCursorUnderline(screen)) {

	    /*
	     * Finally, draw the underline.
	     */
	    screen->box->x = (short) x;
	    screen->box->y = (short) (y + FontHeight(screen) - 2);
	    XDrawLines(screen->display, VDrawable(screen), outlineGC,
		       screen->box, NBOX, CoordModePrevious);
	} else if (isCursorBar(screen)) {

	    /*
	     * Or draw the bar.
	     */
	    screen->box->x = (short) x;
	    screen->box->y = (short) y;
	    XDrawLines(screen->display, VWindow(screen), outlineGC,
		       screen->box, NBOX, CoordModePrevious);
	} else {
#if OPT_WIDE_ATTRS
	    int italics_on = ((ld->attribs[cursor_col] & ATR_ITALIC) != 0);
	    int italics_off = ((xw->flags & ATR_ITALIC) != 0);
	    int fix_italics = (italics_on != italics_off);
	    int which_font = ((xw->flags & BOLD) ? fBold : fNorm);

	    if_OPT_WIDE_CHARS(screen, {
		if (isWide((int) base)) {
		    which_font = ((xw->flags & BOLD) ? fWBold : fWide);
		}
	    });

	    if (fix_italics && UseItalicFont(screen)) {
		xtermLoadItalics(xw);
		if (italics_on) {
		    setCgsFont(xw, currentWin, currentCgs,
			       getItalicFont(screen, which_font));
		} else {
		    setCgsFont(xw, currentWin, currentCgs,
			       getNormalFont(screen, which_font));
		}
	    }
	    currentGC = getCgsGC(xw, currentWin, currentCgs);
#endif /* OPT_WIDE_ATTRS */

	    drawXtermText(xw,
			  flags & DRAWX_MASK,
			  0,
			  currentGC, x, y,
			  LineCharSet(screen, ld),
			  &base, 1, 0);

#if OPT_WIDE_CHARS
	    if_OPT_WIDE_CHARS(screen, {
		size_t off;
		for_each_combData(off, ld) {
		    if (!(ld->combData[off][my_col]))
			break;
		    drawXtermText(xw,
				  (flags & DRAWX_MASK),
				  NOBACKGROUND,
				  currentGC, x, y,
				  LineCharSet(screen, ld),
				  ld->combData[off] + my_col,
				  1, isWide((int) base));
		}
	    });
#endif

	    if (!filled) {
		screen->box->x = (short) x;
		screen->box->y = (short) y;
		XDrawLines(screen->display, VDrawable(screen), outlineGC,
			   screen->box, NBOX, CoordModePrevious);
	    }
#if OPT_WIDE_ATTRS
	    if (fix_italics && UseItalicFont(screen)) {
		if (italics_on) {
		    setCgsFont(xw, currentWin, currentCgs,
			       getNormalFont(screen, which_font));
		} else {
		    setCgsFont(xw, currentWin, currentCgs,
			       getItalicFont(screen, which_font));
		}
	    }
#endif
	}
    }
    screen->cursor_state = ON;

    return;
}

/*
 * hide cursor at previous cursor position in screen.
 */
void
HideCursor(void)
{
    XtermWidget xw = term;
    TScreen *screen = TScreenOf(xw);
    GC currentGC;
    int x, y;
    IChar base;
    unsigned flags;
    CellColor fg_bg = 0;
    Bool in_selection;
#if OPT_WIDE_CHARS
    int my_col = 0;
#endif
    int cursor_col;
    CLineData *ld = 0;
#if OPT_WIDE_ATTRS
    int which_Cgs = gcMAX;
    unsigned attr_flags;
    int which_font = fNorm;
#endif

    if (screen->cursor_state == OFF)
	return;
    if (INX2ROW(screen, screen->cursorp.row) > screen->max_row)
	return;

    cursor_col = screen->cursorp.col;

#ifndef NO_ACTIVE_ICON
    if (IsIcon(screen)) {
	screen->cursor_state = OFF;
	return;
    }
#endif /* NO_ACTIVE_ICON */

    ld = getLineData(screen, screen->cursorp.row);

    base = ld->charData[cursor_col];
    flags = ld->attribs[cursor_col];

    if_OPT_WIDE_CHARS(screen, {
	if (base == HIDDEN_CHAR && cursor_col > 0) {
	    /* if cursor points to non-initial part of wide character,
	     * back it up
	     */
	    --cursor_col;
	    base = ld->charData[cursor_col];
	}
	my_col = cursor_col;
	if (base == 0)
	    base = ' ';
	if (isWide((int) base))
	    my_col += 1;
    });

    if (base == 0) {
	base = ' ';
    }
#ifdef EXP_BOGUS_FG
    /*
     * If the cursor happens to be on blanks, and we have not set both
     * foreground and background color, do not treat it as a colored cell.
     */
#if OPT_ISO_COLORS
    if (base == ' ') {
	if ((flags & (FG_COLOR | BG_COLOR)) == BG_COLOR) {
	    TRACE(("HideCursor - do not treat as a colored cell\n"));
	    flags &= ~(FG_COLOR | BG_COLOR);
	} else if ((flags & (FG_COLOR | BG_COLOR)) == FG_COLOR) {
	    TRACE(("HideCursor - should we treat as a colored cell?\n"));
	    if (!(xw->flags & FG_COLOR))
		if (CheckBogusForeground(screen, "HideCursor"))
		    flags &= ~(FG_COLOR | BG_COLOR);
	}
    }
#endif
#endif
#if OPT_ISO_COLORS
    fg_bg = 0;
#endif

    /*
     * Compare the current cell to the last set of colors used for the
     * cursor and update the GC's if needed.
     */
    if_OPT_ISO_COLORS(screen, {
	fg_bg = ld->color[cursor_col];
    });

    if (OutsideSelection(screen, screen->cursorp.row, screen->cursorp.col))
	in_selection = False;
    else
	in_selection = True;

#if OPT_WIDE_ATTRS
    attr_flags = ld->attribs[cursor_col];
    if ((attr_flags & ATR_ITALIC) ^ (xw->flags & ATR_ITALIC)) {
	which_font = ((attr_flags & BOLD) ? fBold : fNorm);

	if_OPT_WIDE_CHARS(screen, {
	    if (isWide((int) base)) {
		which_font = ((attr_flags & BOLD) ? fWBold : fWide);
	    }
	});

	which_Cgs = reverseCgs(xw, attr_flags, in_selection, which_font);
	if (which_Cgs != gcMAX) {
	    setCgsFont(xw, WhichVWin(screen),
		       (CgsEnum) which_Cgs,
		       (((attr_flags & ATR_ITALIC) && UseItalicFont(screen))
			? getItalicFont(screen, which_font)
			: getNormalFont(screen, which_font)));
	}
    }
#endif

    currentGC = updatedXtermGC(xw, flags, fg_bg, in_selection);

    TRACE(("HideCursor calling drawXtermText cur(%d,%d)\n",
	   screen->cursorp.row, screen->cursorp.col));

    x = LineCursorX(screen, ld, cursor_col);
    y = CursorY(screen, screen->cursorp.row);

    drawXtermText(xw,
		  flags & DRAWX_MASK,
		  0,
		  currentGC, x, y,
		  LineCharSet(screen, ld),
		  &base, 1, 0);

#if OPT_WIDE_CHARS
    if_OPT_WIDE_CHARS(screen, {
	size_t off;
	for_each_combData(off, ld) {
	    if (!(ld->combData[off][my_col]))
		break;
	    drawXtermText(xw,
			  (flags & DRAWX_MASK),
			  NOBACKGROUND,
			  currentGC, x, y,
			  LineCharSet(screen, ld),
			  ld->combData[off] + my_col,
			  1, isWide((int) base));
	}
    });
#endif
    screen->cursor_state = OFF;

#if OPT_WIDE_ATTRS
    if (which_Cgs != gcMAX) {
	setCgsFont(xw, WhichVWin(screen),
		   (CgsEnum) which_Cgs,
		   (((xw->flags & ATR_ITALIC) && UseItalicFont(screen))
		    ? getItalicFont(screen, which_font)
		    : getNormalFont(screen, which_font)));
    }
#endif
    resetXtermGC(xw, flags, in_selection);

    refresh_displayed_graphics(xw,
			       screen->cursorp.col,
			       screen->cursorp.row,
			       1, 1);

    return;
}

#if OPT_BLINK_CURS || OPT_BLINK_TEXT
static void
StartBlinking(TScreen *screen)
{
    if (screen->blink_timer == 0) {
	unsigned long interval = (unsigned long) ((screen->cursor_state == ON)
						  ? screen->blink_on
						  : screen->blink_off);
	if (interval == 0)	/* wow! */
	    interval = 1;	/* let's humor him anyway */
	screen->blink_timer = XtAppAddTimeOut(app_con,
					      interval,
					      HandleBlinking,
					      screen);
    }
}

static void
StopBlinking(TScreen *screen)
{
    if (screen->blink_timer) {
	XtRemoveTimeOut(screen->blink_timer);
	screen->blink_timer = 0;
	reallyStopBlinking(screen);
    } else {
	screen->blink_timer = 0;
    }
}

#if OPT_BLINK_TEXT
Bool
LineHasBlinking(TScreen *screen, CLineData *ld)
{
    Bool result = False;
    if (ld != 0) {
	int col;

	for (col = 0; col < MaxCols(screen); ++col) {
	    if (ld->attribs[col] & BLINK) {
		result = True;
		break;
	    }
	}
    }
    return result;
}
#endif

/*
 * Blink the cursor by alternately showing/hiding cursor.  We leave the timer
 * running all the time (even though that's a little inefficient) to make the
 * logic simple.
 */
static void
HandleBlinking(XtPointer closure, XtIntervalId * id GCC_UNUSED)
{
    TScreen *screen = (TScreen *) closure;
    Bool resume = False;

    screen->blink_timer = 0;
    screen->blink_state = !screen->blink_state;

#if OPT_BLINK_CURS
    if (DoStartBlinking(screen)) {
	if (screen->cursor_state == ON) {
	    if (screen->select || screen->always_highlight) {
		HideCursor();
		if (screen->cursor_state == OFF)
		    screen->cursor_state = BLINKED_OFF;
	    }
	} else if (screen->cursor_state == BLINKED_OFF) {
	    screen->cursor_state = OFF;
	    ShowCursor();
	    if (screen->cursor_state == OFF)
		screen->cursor_state = BLINKED_OFF;
	}
	resume = True;
    }
#endif

#if OPT_BLINK_TEXT
    /*
     * Inspect the lines on the current screen to see if any have the BLINK flag
     * associated with them.  Prune off any that have had the corresponding
     * cells reset.  If any are left, repaint those lines with ScrnRefresh().
     */
    if (!(screen->blink_as_bold)) {
	int row;
	int first_row = screen->max_row;
	int last_row = -1;

	for (row = screen->max_row; row >= 0; row--) {
	    LineData *ld = getLineData(screen, ROW2INX(screen, row));

	    if (ld != 0 && LineTstBlinked(ld)) {
		if (LineHasBlinking(screen, ld)) {
		    resume = True;
		    if (row > last_row)
			last_row = row;
		    if (row < first_row)
			first_row = row;
		} else {
		    LineClrBlinked(ld);
		}
	    }
	}
	/*
	 * FIXME: this could be a little more efficient, e.g,. by limiting the
	 * columns which are updated.
	 */
	if (first_row <= last_row) {
	    ScrnRefresh(term,
			first_row,
			0,
			last_row + 1 - first_row,
			MaxCols(screen),
			True);
	}
    }
#endif

    /*
     * If either the cursor or text is blinking, restart the timer.
     */
    if (resume)
	StartBlinking(screen);
}
#endif /* OPT_BLINK_CURS || OPT_BLINK_TEXT */

void
RestartBlinking(TScreen *screen GCC_UNUSED)
{
#if OPT_BLINK_CURS || OPT_BLINK_TEXT
    if (screen->blink_timer == 0) {
	Bool resume = False;

#if OPT_BLINK_CURS
	if (DoStartBlinking(screen)) {
	    resume = True;
	}
#endif
#if OPT_BLINK_TEXT
	if (!resume) {
	    int row;

	    for (row = screen->max_row; row >= 0; row--) {
		CLineData *ld = getLineData(screen, ROW2INX(screen, row));

		if (ld != 0 && LineTstBlinked(ld)) {
		    if (LineHasBlinking(screen, ld)) {
			resume = True;
			break;
		    }
		}
	    }
	}
#endif
	if (resume)
	    StartBlinking(screen);
    }
#endif
}

/*
 * Implement soft or hard (full) reset of the VTxxx emulation.  There are a
 * couple of differences from real DEC VTxxx terminals (to avoid breaking
 * applications which have come to rely on xterm doing this):
 *
 *	+ autowrap mode should be reset (instead it's reset to the resource
 *	  default).
 *	+ the popup menu offers a choice of resetting the savedLines, or not.
 *	  (but the control sequence does this anyway).
 */
static void
ReallyReset(XtermWidget xw, Bool full, Bool saved)
{
    TScreen *screen = TScreenOf(xw);

    if (!XtIsRealized((Widget) xw) || (CURRENT_EMU() != (Widget) xw)) {
	Bell(xw, XkbBI_MinorError, 0);
	return;
    }

    if (saved) {
	screen->savedlines = 0;
	ScrollBarDrawThumb(screen->scrollWidget);
    }

    /* make cursor visible */
    screen->cursor_set = ON;
    InitCursorShape(screen, screen);
#if OPT_BLINK_CURS
    TRACE(("cursor_shape:%d blinks:%s\n",
	   screen->cursor_shape,
	   BtoS(screen->cursor_blink)));
#endif

    /* reset scrolling region */
    reset_margins(screen);

    bitclr(&xw->flags, ORIGIN);

    if_OPT_ISO_COLORS(screen, {
	static char empty[1];
	reset_SGR_Colors(xw);
	if (ResetAnsiColorRequest(xw, empty, 0))
	    xtermRepaint(xw);
    });

    /* Reset character-sets to initial state */
    resetCharsets(screen);

#if OPT_MOD_FKEYS
    /* Reset modifier-resources to initial state */
    xw->keyboard.modify_now = xw->keyboard.modify_1st;
#endif

    /* Reset DECSCA */
    bitclr(&xw->flags, PROTECTED);
    screen->protected_mode = OFF_PROTECT;

    reset_displayed_graphics(screen);

    if (full) {			/* RIS */
	if (screen->bellOnReset)
	    Bell(xw, XkbBI_TerminalBell, 0);

	/* reset the mouse mode */
	screen->send_mouse_pos = MOUSE_OFF;
	screen->send_focus_pos = OFF;
	screen->extend_coords = 0;
	screen->waitingForTrackInfo = False;
	screen->eventMode = NORMAL;

	xtermShowPointer(xw, True);

	TabReset(xw->tabs);
	xw->keyboard.flags = MODE_SRM;

	guard_keyboard_type = False;
	screen->old_fkeys = screen->old_fkeys0;
	decode_keyboard_type(xw, &resource);
	update_keyboard_type();

#if OPT_INITIAL_ERASE
	if (xw->keyboard.reset_DECBKM == 1)
	    xw->keyboard.flags |= MODE_DECBKM;
	else if (xw->keyboard.reset_DECBKM == 2)
#endif
	    if (TScreenOf(xw)->backarrow_key)
		xw->keyboard.flags |= MODE_DECBKM;
	TRACE(("full reset DECBKM %s\n",
	       BtoS(xw->keyboard.flags & MODE_DECBKM)));

#if OPT_SCROLL_LOCK
	xtermClearLEDs(screen);
#endif
	screen->title_modes = screen->title_modes0;
	screen->pointer_mode = screen->pointer_mode0;
#if OPT_SIXEL_GRAPHICS
	if (TScreenOf(xw)->sixel_scrolling)
	    xw->keyboard.flags |= MODE_DECSDM;
	TRACE(("full reset DECSDM to %s (resource default is %s)\n",
	       BtoS(xw->keyboard.flags & MODE_DECSDM),
	       BtoS(TScreenOf(xw)->sixel_scrolling)));
#endif

#if OPT_GRAPHICS
	screen->privatecolorregisters = TScreenOf(xw)->privatecolorregisters;
	TRACE(("full reset PRIVATE_COLOR_REGISTERS to %s (resource default is %s)\n",
	       BtoS(screen->privatecolorregisters),
	       BtoS(TScreenOf(xw)->privatecolorregisters)));
#endif

#if OPT_SIXEL_GRAPHICS
	screen->sixel_scrolls_right = TScreenOf(xw)->sixel_scrolls_right;
	TRACE(("full reset SIXEL_SCROLLS_RIGHT to %s (resource default is %s)\n",
	       BtoS(screen->sixel_scrolls_right),
	       BtoS(TScreenOf(xw)->sixel_scrolls_right)));
#endif

	update_appcursor();
	update_appkeypad();
	update_decbkm();
	update_decsdm();
	show_8bit_control(False);
	reset_decudk(xw);

	FromAlternate(xw);
	ClearScreen(xw);
	screen->cursor_state = OFF;
	if (xw->flags & REVERSE_VIDEO)
	    ReverseVideo(xw);

	xw->flags = xw->initflags;
	update_reversevideo();
	update_autowrap();
	update_reversewrap();
	update_autolinefeed();

	screen->jumpscroll = (Boolean) (!(xw->flags & SMOOTHSCROLL));
	update_jumpscroll();

#if OPT_DEC_RECTOPS
	screen->cur_decsace = 0;
#endif
#if OPT_READLINE
	screen->click1_moves = OFF;
	screen->paste_moves = OFF;
	screen->dclick3_deletes = OFF;
	screen->paste_brackets = OFF;
	screen->paste_quotes = OFF;
	screen->paste_literal_nl = OFF;
#endif /* OPT_READLINE */

	if (screen->c132 && (xw->flags & IN132COLUMNS)) {
	    Dimension reqWidth = (Dimension) (80 * FontWidth(screen)
					      + 2 * screen->border
					      + ScrollbarWidth(screen));
	    Dimension reqHeight = (Dimension) (FontHeight(screen)
					       * MaxRows(screen)
					       + 2 * screen->border);
	    Dimension replyWidth;
	    Dimension replyHeight;

	    TRACE(("Making resize-request to restore 80-columns %dx%d\n",
		   reqHeight, reqWidth));
	    REQ_RESIZE((Widget) xw,
		       reqWidth,
		       reqHeight,
		       &replyWidth, &replyHeight);
	    repairSizeHints();
	    XSync(screen->display, False);	/* synchronize */
	    if (xtermAppPending())
		xevents();
	}

	CursorSet(screen, 0, 0, xw->flags);
	CursorSave(xw);
    } else {			/* DECSTR */
	/*
	 * There's a tiny difference, to accommodate usage of xterm.
	 * We reset autowrap to the resource values rather than turning
	 * it off.
	 */
	UIntClr(xw->keyboard.flags, (MODE_DECCKM | MODE_KAM | MODE_DECKPAM));
	bitcpy(&xw->flags, xw->initflags, WRAPAROUND | REVERSEWRAP);
	bitclr(&xw->flags, INSERT | INVERSE | BOLD | BLINK | UNDERLINE | INVISIBLE);
	if_OPT_ISO_COLORS(screen, {
	    reset_SGR_Colors(xw);
	});
	update_appcursor();
	update_autowrap();
	update_reversewrap();

	CursorSave(xw);
	screen->sc[screen->whichBuf].row =
	    screen->sc[screen->whichBuf].col = 0;
    }
}

void
VTReset(XtermWidget xw, Bool full, Bool saved)
{
    ReallyReset(xw, full, saved);
    longjmp(vtjmpbuf, 1);	/* force ground state in parser */
}

typedef enum {
    ccLO,
    ccDASH,
    ccHI,
    ccCOLON,
    ccID,
    ccCOMMA
} CCLASS;

/*
 * set_character_class - takes a string of the form
 *
 *   low[-high][:id][,low[-high][:id][...]]
 *
 * and sets the indicated ranges to the indicated values.
 */
static int
set_character_class(char *s)
{
#define FMT "%s in range string \"%s\" (position %d)\n"

    TRACE(("set_character_class(%s) {{\n", NonNull(s)));
    if (IsEmpty(s)) {
	return -1;
    } else {
	CCLASS state = ccLO;
	int arg[3];
	int i;
	int len = (int) strlen(s);

	arg[0] =
	    arg[1] =
	    arg[2] = -1;

	for (i = 0; i < len; ++i) {
	    int ch = CharOf(s[i]);
	    char *t = 0;
	    long value = 0;

	    if (isspace(ch))
		continue;

	    switch (state) {
	    case ccLO:
	    case ccHI:
	    case ccID:
		if (!isdigit(ch)) {
		    xtermWarning(FMT, "missing number", s, i);
		    return (-1);
		}
		value = strtol(s + i, &t, 0);
		i = (int) (t - s - 1);
		break;
	    case ccDASH:
	    case ccCOLON:
	    case ccCOMMA:
		break;
	    }

	    switch (state) {
	    case ccLO:
		arg[0] =
		    arg[1] = (int) value;
		arg[2] = -1;
		state = ccDASH;
		break;

	    case ccDASH:
		if (ch == '-') {
		    state = ccHI;
		} else {
		    goto parse_class;
		}
		break;

	    case ccHI:
		arg[1] = (int) value;
		state = ccCOLON;
		break;

	      parse_class:
	    case ccCOLON:
		if (ch == ':') {
		    state = ccID;
		} else if (ch == ',') {
		    goto apply_class;
		} else {
		    xtermWarning(FMT, "unexpected character", s, i);
		    return (-1);
		}
		break;

	    case ccID:
		arg[2] = (int) value;
		state = ccCOMMA;
		break;

	      apply_class:
	    case ccCOMMA:
		if (SetCharacterClassRange(arg[0], arg[1], arg[2]) != 0) {
		    xtermWarning(FMT, "bad range", s, i);
		    return -1;
		}
		state = ccLO;
		break;
	    }
	}
	if (state >= ccDASH) {
	    if (SetCharacterClassRange(arg[0], arg[1], arg[2]) != 0) {
		xtermWarning(FMT, "bad range", s, i);
		return -1;
	    }
	}
    }

    TRACE(("}} set_character_class\n"));
    return (0);
#undef FMT
}

void
getKeymapResources(Widget w,
		   const char *mapName,
		   const char *mapClass,
		   const char *type,
		   void *result,
		   size_t size)
{
    XtResource key_resources[1];
    key_resources[0].resource_name = XtNtranslations;
    key_resources[0].resource_class = XtCTranslations;
    key_resources[0].resource_type = (char *) type;
    key_resources[0].resource_size = (Cardinal) size;
    key_resources[0].resource_offset = 0;
    key_resources[0].default_type = key_resources[0].resource_type;
    key_resources[0].default_addr = 0;
    XtGetSubresources(w, (XtPointer) result, mapName, mapClass,
		      key_resources, (Cardinal) 1, NULL, (Cardinal) 0);
}

/* ARGSUSED */
static void
HandleKeymapChange(Widget w,
		   XEvent *event GCC_UNUSED,
		   String *params,
		   Cardinal *param_count)
{
    static XtTranslations keymap, original;

    TRACE(("HandleKeymapChange(%#lx, %s)\n",
	   (unsigned long) w,
	   (*param_count
	    ? params[0]
	    : "missing")));

    if (*param_count != 1)
	return;

    if (original == NULL) {
	TRACE(("...saving original keymap-translations\n"));
	original = w->core.tm.translations;
    }

    if (strcmp(params[0], "None") == 0) {
	TRACE(("...restoring original keymap-translations\n"));
	XtOverrideTranslations(w, original);
    } else {
	char mapName[1000];
	char mapClass[1000];
	char *pmapName;
	char *pmapClass;
	size_t len;

	len = strlen(params[0]) + 7;

	pmapName = (char *) MyStackAlloc(len, mapName);
	pmapClass = (char *) MyStackAlloc(len, mapClass);
	if (pmapName == NULL
	    || pmapClass == NULL) {
	    SysError(ERROR_KMMALLOC1);
	} else {

	    (void) sprintf(pmapName, "%sKeymap", params[0]);
	    (void) strcpy(pmapClass, pmapName);
	    if (islower(CharOf(pmapClass[0])))
		pmapClass[0] = x_toupper(pmapClass[0]);
	    getKeymapResources(w, pmapName, pmapClass, XtRTranslationTable,
			       &keymap, sizeof(keymap));
	    if (keymap != NULL) {
		TRACE(("...applying keymap \"%s\"\n", pmapName));
		XtOverrideTranslations(w, keymap);
	    } else {
		TRACE(("...found no match for keymap \"%s\"\n", pmapName));
	    }

	    MyStackFree(pmapName, mapName);
	    MyStackFree(pmapClass, mapClass);
	}
    }
}

/* ARGSUSED */
static void
HandleBell(Widget w GCC_UNUSED,
	   XEvent *event GCC_UNUSED,
	   String *params,	/* [0] = volume */
	   Cardinal *param_count)	/* 0 or 1 */
{
    int percent = (*param_count) ? atoi(params[0]) : 0;

    Bell(term, XkbBI_TerminalBell, percent);
}

/* ARGSUSED */
static void
HandleVisualBell(Widget w GCC_UNUSED,
		 XEvent *event GCC_UNUSED,
		 String *params GCC_UNUSED,
		 Cardinal *param_count GCC_UNUSED)
{
    VisualBell();
}

/* ARGSUSED */
static void
HandleIgnore(Widget w,
	     XEvent *event,
	     String *params GCC_UNUSED,
	     Cardinal *param_count GCC_UNUSED)
{
    XtermWidget xw;

    TRACE(("Handle ignore for %p %s\n",
	   (void *) w, visibleEventType(event->type)));
    if ((xw = getXtermWidget(w)) != 0) {
	/* do nothing, but check for funny escape sequences */
	(void) SendMousePosition(xw, event);
    }
}

/* ARGSUSED */
static void
DoSetSelectedFont(Widget w,
		  XtPointer client_data GCC_UNUSED,
		  Atom *selection GCC_UNUSED,
		  Atom *type,
		  XtPointer value,
		  unsigned long *length,
		  int *format)
{
    XtermWidget xw = getXtermWidget(w);

    if (xw == 0) {
	xtermWarning("unexpected widget in DoSetSelectedFont\n");
    } else if (*type != XA_STRING || *format != 8) {
	Bell(xw, XkbBI_MinorError, 0);
    } else {
	Boolean failed = False;
	int oldFont = TScreenOf(xw)->menu_font_number;
	char *save = TScreenOf(xw)->SelectFontName();
	char *val;
	char *test = 0;
	unsigned len = (unsigned) *length;
	unsigned tst;

	/*
	 * Some versions of X deliver null-terminated selections, some do not.
	 */
	for (tst = 0; tst < len; ++tst) {
	    if (((char *) value)[tst] == '\0') {
		len = tst;
		break;
	    }
	}

	if (len > 0 && (val = TypeMallocN(char, len + 1)) != 0) {
	    char *used;

	    memcpy(val, value, (size_t) len);
	    val[len] = '\0';
	    used = x_strtrim(val);
	    TRACE(("DoSetSelectedFont(%s)\n", used));
	    /* Do some sanity checking to avoid sending a long selection
	       back to the server in an OpenFont that is unlikely to succeed.
	       XLFD allows up to 255 characters and no control characters;
	       we are a little more liberal here. */
	    if (len < 1000
		&& used != 0
		&& !strchr(used, '\n')
		&& (test = x_strdup(used)) != 0) {
		TScreenOf(xw)->SelectFontName() = test;
		if (!xtermLoadFont(term,
				   xtermFontName(used),
				   True,
				   fontMenu_fontsel)) {
		    failed = True;
		    free(test);
		    TScreenOf(xw)->SelectFontName() = save;
		}
	    } else {
		failed = True;
	    }
	    if (failed) {
		(void) xtermLoadFont(term,
				     xtermFontName(TScreenOf(xw)->MenuFontName(oldFont)),
				     True,
				     oldFont);
		Bell(xw, XkbBI_MinorError, 0);
	    }
	    free(used);
	    free(val);
	}
    }
}

void
FindFontSelection(XtermWidget xw, const char *atom_name, Bool justprobe)
{
    TScreen *screen = TScreenOf(xw);
    static AtomPtr *atoms;
    static unsigned int atomCount = 0;
    AtomPtr *pAtom;
    unsigned a;
    Atom target;

    if (!atom_name)
	atom_name = ((screen->mappedSelect && atomCount)
		     ? screen->mappedSelect[0]
		     : "PRIMARY");
    TRACE(("FindFontSelection(%s)\n", atom_name));

    for (pAtom = atoms, a = atomCount; a; a--, pAtom++) {
	if (strcmp(atom_name, XmuNameOfAtom(*pAtom)) == 0) {
	    TRACE(("...found atom %d:%s\n", a + 1, atom_name));
	    break;
	}
    }
    if (!a) {
	atoms = TypeXtReallocN(AtomPtr, atoms, atomCount + 1);
	*(pAtom = &atoms[atomCount]) = XmuMakeAtom(atom_name);
	++atomCount;
	TRACE(("...added atom %d:%s\n", atomCount, atom_name));
    }

    target = XmuInternAtom(XtDisplay(xw), *pAtom);
    if (justprobe) {
	screen->SelectFontName() =
	    XGetSelectionOwner(XtDisplay(xw), target) ? _Font_Selected_ : 0;
	TRACE(("...selected fontname '%s'\n",
	       NonNull(screen->SelectFontName())));
    } else {
	XtGetSelectionValue((Widget) xw, target, XA_STRING,
			    DoSetSelectedFont, NULL,
			    XtLastTimestampProcessed(XtDisplay(xw)));
    }
    return;
}

Bool
set_cursor_gcs(XtermWidget xw)
{
    TScreen *screen = TScreenOf(xw);
    VTwin *win = WhichVWin(screen);

    Pixel cc = T_COLOR(screen, TEXT_CURSOR);
    Pixel fg = T_COLOR(screen, TEXT_FG);
    Pixel bg = T_COLOR(screen, TEXT_BG);
    Bool changed = False;

    /*
     * Let's see, there are three things that have "color":
     *
     *     background
     *     text
     *     cursorblock
     *
     * And, there are four situations when drawing a cursor, if we decide
     * that we like have a solid block of cursor color with the letter
     * that it is highlighting shown in the background color to make it
     * stand out:
     *
     *     selected window, normal video - background on cursor
     *     selected window, reverse video - foreground on cursor
     *     unselected window, normal video - foreground on background
     *     unselected window, reverse video - background on foreground
     *
     * Since the last two are really just normalGC and reverseGC, we only
     * need two new GC's.  Under monochrome, we get the same effect as
     * above by setting cursor color to foreground.
     */

    TRACE(("set_cursor_gcs cc=%#lx, fg=%#lx, bg=%#lx\n", cc, fg, bg));
    if (win != 0 && (cc != bg)) {
	/* set the fonts to the current one */
	setCgsFont(xw, win, gcVTcursNormal, 0);
	setCgsFont(xw, win, gcVTcursFilled, 0);
	setCgsFont(xw, win, gcVTcursReverse, 0);
	setCgsFont(xw, win, gcVTcursOutline, 0);

	/* we have a colored cursor */
	setCgsFore(xw, win, gcVTcursNormal, fg);
	setCgsBack(xw, win, gcVTcursNormal, cc);

	setCgsFore(xw, win, gcVTcursFilled, cc);
	setCgsBack(xw, win, gcVTcursFilled, fg);

	if (screen->always_highlight) {
	    /* both GC's use the same color */
	    setCgsFore(xw, win, gcVTcursReverse, bg);
	    setCgsBack(xw, win, gcVTcursReverse, cc);
	} else {
	    setCgsFore(xw, win, gcVTcursReverse, bg);
	    setCgsBack(xw, win, gcVTcursReverse, cc);
	}
	set_cursor_outline_gc(xw, screen->always_highlight, fg, bg, cc);
	changed = True;
    }

    if (changed) {
	TRACE(("...set_cursor_gcs - done\n"));
    }
    return changed;
}

/*
 * Build up the default translations string, allowing the user to suppress
 * some of the features.
 */
void
VTInitTranslations(void)
{
    /* *INDENT-OFF* */
    static struct {
	Boolean wanted;
	const char *name;
	const char *value;
    } table[] = {
	{
	    False,
	    "default",
"\
          Shift <KeyPress> Prior:scroll-back(1,halfpage) \n\
           Shift <KeyPress> Next:scroll-forw(1,halfpage) \n\
         Shift <KeyPress> Select:select-cursor-start() select-cursor-end(SELECT, CUT_BUFFER0) \n\
         Shift <KeyPress> Insert:insert-selection(SELECT, CUT_BUFFER0) \n\
"
	},
#if OPT_MAXIMIZE
	{
	    False,
	    "fullscreen",
"\
                 Alt <Key>Return:fullscreen() \n\
"
	},
#endif
#if OPT_SCROLL_LOCK
	{
	    False,
	    "scroll-lock",
"\
        <KeyRelease> Scroll_Lock:scroll-lock() \n\
"
	},
#endif
#if OPT_SHIFT_FONTS
	{
	    False,
	    "shift-fonts",
"\
    Shift~Ctrl <KeyPress> KP_Add:larger-vt-font() \n\
    Shift Ctrl <KeyPress> KP_Add:smaller-vt-font() \n\
    Shift <KeyPress> KP_Subtract:smaller-vt-font() \n\
"
	},
#endif
	/* PROCURA added "Meta <Btn2Down>:clear-saved-lines()" */
	{
	    False,
	    "default",
"\
                ~Meta <KeyPress>:insert-seven-bit() \n\
                 Meta <KeyPress>:insert-eight-bit() \n\
                !Ctrl <Btn1Down>:popup-menu(mainMenu) \n\
           !Lock Ctrl <Btn1Down>:popup-menu(mainMenu) \n\
 !Lock Ctrl @@Num_Lock <Btn1Down>:popup-menu(mainMenu) \n\
     ! @@Num_Lock Ctrl <Btn1Down>:popup-menu(mainMenu) \n\
                ~Meta <Btn1Down>:select-start() \n\
              ~Meta <Btn1Motion>:select-extend() \n\
                !Ctrl <Btn2Down>:popup-menu(vtMenu) \n\
           !Lock Ctrl <Btn2Down>:popup-menu(vtMenu) \n\
 !Lock Ctrl @@Num_Lock <Btn2Down>:popup-menu(vtMenu) \n\
     ! @@Num_Lock Ctrl <Btn2Down>:popup-menu(vtMenu) \n\
          ~Ctrl ~Meta <Btn2Down>:ignore() \n\
                 Meta <Btn2Down>:clear-saved-lines() \n\
            ~Ctrl ~Meta <Btn2Up>:insert-selection(SELECT, CUT_BUFFER0) \n\
                !Ctrl <Btn3Down>:popup-menu(fontMenu) \n\
           !Lock Ctrl <Btn3Down>:popup-menu(fontMenu) \n\
 !Lock Ctrl @@Num_Lock <Btn3Down>:popup-menu(fontMenu) \n\
     ! @@Num_Lock Ctrl <Btn3Down>:popup-menu(fontMenu) \n\
          ~Ctrl ~Meta <Btn3Down>:start-extend() \n\
              ~Meta <Btn3Motion>:select-extend() \n\
"
	},
	{
	    False,
	    "wheel-mouse",
"\
                 Ctrl <Btn4Down>:scroll-back(1,halfpage,m) \n\
            Lock Ctrl <Btn4Down>:scroll-back(1,halfpage,m) \n\
  Lock @@Num_Lock Ctrl <Btn4Down>:scroll-back(1,halfpage,m) \n\
       @@Num_Lock Ctrl <Btn4Down>:scroll-back(1,halfpage,m) \n\
                      <Btn4Down>:scroll-back(5,line,m)     \n\
                 Ctrl <Btn5Down>:scroll-forw(1,halfpage,m) \n\
            Lock Ctrl <Btn5Down>:scroll-forw(1,halfpage,m) \n\
  Lock @@Num_Lock Ctrl <Btn5Down>:scroll-forw(1,halfpage,m) \n\
       @@Num_Lock Ctrl <Btn5Down>:scroll-forw(1,halfpage,m) \n\
                      <Btn5Down>:scroll-forw(5,line,m)     \n\
"
	},
	{
	    False,
	    "default",
"\
                         <BtnUp>:select-end(SELECT, CUT_BUFFER0) \n\
                       <BtnDown>:ignore() \
"
	}
    };
    /* *INDENT-ON* */

    char *result = 0;

    int pass;
    Cardinal item;

    TRACE(("VTInitTranslations\n"));
    for (item = 0; item < XtNumber(table); ++item) {
	table[item].wanted = True;
    }
#if OPT_MAXIMIZE
    /*
     * As a special case, allow for disabling the alt-enter translation if
     * the resource settings prevent fullscreen from being used.  We would
     * do the same for scroll-lock and shift-fonts if they were application
     * resources too, rather than in the widget.
     */
    if (resource.fullscreen == esNever) {
	for (item = 0; item < XtNumber(table); ++item) {
	    if (!strcmp(table[item].name, "fullscreen")) {
		table[item].wanted = False;
		TRACE(("omit(%s):\n%s\n", table[item].name, table[item].value));
	    }
	}
    }
#endif
    if (!IsEmpty(resource.omitTranslation)) {
	char *value;
	const char *source = resource.omitTranslation;

	while (*source != '\0' && (value = ParseList(&source)) != 0) {
	    size_t len = strlen(value);

	    TRACE(("parsed:%s\n", value));
	    for (item = 0; item < XtNumber(table); ++item) {
		if (strlen(table[item].name) >= len
		    && x_strncasecmp(table[item].name,
				     value,
				     (unsigned) len) == 0) {
		    table[item].wanted = False;
		    TRACE(("omit(%s):\n%s\n", table[item].name, table[item].value));
		    break;
		}
	    }
	    free(value);
	}
    }

    for (pass = 0; pass < 2; ++pass) {
	size_t needed = 0;
	for (item = 0; item < XtNumber(table); ++item) {
	    if (table[item].wanted) {
		if (pass) {
		    strcat(result, table[item].value);
		} else {
		    needed += strlen(table[item].value) + 1;
		}
	    }
	}
	if (!pass) {
	    result = XtMalloc((Cardinal) needed);
	    *result = '\0';
	}
    }

    TRACE(("result:\n%s\n", result));

    defaultTranslations = result;
    xtermClassRec.core_class.tm_table = result;
}

#ifdef NO_LEAKS
void
noleaks_charproc(void)
{
    if (v_buffer != 0)
	free(v_buffer);
}
#endif
@


1.38
log
@Update to xterm 327
@
text
@d1 1
a1 1
/* $XTermId: charproc.c,v 1.1426 2016/10/07 21:14:54 tom Exp $ */
d4 1
a4 1
 * Copyright 1999-2015,2016 by Thomas E. Dickey
d234 1
a234 1
static String _Font_Selected_ = "yes";	/* string is arbitrary */
d310 1
d415 1
d446 1
d516 2
d749 2
a750 2
    Ires(XtNmkSamplePass, XtCMkSamplePass, misc.mk_samplepass, 256),
    Ires(XtNmkSampleSize, XtCMkSampleSize, misc.mk_samplesize, 1024),
d771 1
d792 1
a792 2
    Sres(XtNfaceName, XtCFaceName, misc.face_name, DEFFACENAME),
    Sres(XtNfaceNameDoublesize, XtCFaceNameDoublesize, misc.face_wide_name, DEFFACENAME),
d794 3
a1124 2
    TScreen *screen = TScreenOf(xw);

d1129 1
a1129 1
	    xtermUpdateFontGCs(xw, screen->ifnts);
d1133 1
a1133 1
	xtermUpdateFontGCs(xw, screen->fnts);
d1444 1
a1444 1
		     && used != 0) \
d1446 1
d1448 6
d1880 1
a1880 1
	xw->misc.palette_changed = False;
d2174 1
a2183 2
	    sp->print_area = new_string;
	    sp->print_size = new_length;
d2210 1
a2221 5
	    if (sp->string_area != new_string) {
		free(sp->string_area);
	    }
	    sp->string_area = new_string;
	    sp->string_size = new_length;
d2281 1
a2281 1
	if (xw->misc.palette_changed) {
d2877 1
d3644 1
d3668 4
d3679 44
d3732 7
a3738 4
		    reply.a_nparam = 3;
		    reply.a_param[0] = (ParmType) GetParam(0);
		    reply.a_param[1] = (ParmType) status;
		    reply.a_param[2] = (ParmType) result;
d3952 1
a3952 1
	    if (screen->send_mouse_pos == DEC_LOCATOR) {
d4947 1
a4947 1
	spot.y = (short) (CursorY(screen, screen->cur_row) + xw->misc.xim_fs_ascent);
d5054 4
d5060 1
d5065 2
a5066 2
			   buf[chars_chomped + offset] >= 0x80 &&
			   buf[chars_chomped + offset] <= 0xa0) {
d5069 37
a5105 1
		    last_chomp = my_wcwidth((wchar_t) buf[chars_chomped + offset]);
d5135 1
d5367 1
a5367 1
    if (TScreenOf(xw)->send_mouse_pos != MOUSE_OFF)
d6423 1
a6423 1
	   XGetAtomName(dpy, text->encoding),
d7454 1
a7454 3
	int fl = (xw->misc.default_font.f_n
		  ? (int) strlen(xw->misc.default_font.f_n)
		  : 0);
d7456 1
a7456 2
	    && x_strcasecmp(xw->misc.default_font.f_n + fl - 11,
			    "-ISO10646-1") == 0) {
d7648 1
a7648 2
		    const FlagList * list,
		    Cardinal limit)
d7666 1
a7666 1
		for (n = 0; n < limit; ++n) {
d7670 1
d7676 2
a7677 2
	    for (n = 0; n < limit; ++n) {
		if (!x_strcasecmp(next, list[n].name)) {
d7681 1
a7681 1
		    break;
a7686 2
	} else {
	    TRACE(("...found %s (%d)\n", next, value));
a7691 38
#if OPT_RENDERFONT
static void
trimSizeFromFace(char *face_name, float *face_size)
{
    char *first = strstr(face_name, ":size=");
    if (first == 0) {
	first = face_name;
    } else {
	first++;
    }
    if (!strncmp(first, "size=", (size_t) 5)) {
	char *last = strchr(first, ':');
	char mark;
	float value;
	char extra;
	if (last == 0)
	    last = first + strlen(first);
	mark = *last;
	*last = '\0';
	if (sscanf(first, "size=%g%c", &value, &extra) == 1) {
	    TRACE(("...trimmed size from font: %g\n", value));
	    if (face_size != 0)
		*face_size = value;
	}
	if (mark) {
	    while ((*first++ = *++last) != '\0') {
		;
	    }
	} else {
	    if (first != face_name)
		--first;
	    *first = '\0';
	}
	TRACE(("...after trimming, font = \"%s\"\n", face_name));
    }
}
#endif

d7710 1
d7717 1
d7726 19
d7753 1
d7787 1
d7796 1
d7807 1
d7817 1
d7827 1
d7851 1
d7865 1
a7865 1
    memset(TScreenOf(wnew), 0, sizeof(wnew->screen));
d7889 1
a7889 1
    TScreenOf(wnew)->display = wnew->core.screen->display;
d7904 2
a7905 2
	wnew->dft_foreground = MyWhitePixel(TScreenOf(wnew)->display);
	wnew->dft_background = MyBlackPixel(TScreenOf(wnew)->display);
d7907 2
a7908 2
	wnew->dft_foreground = MyBlackPixel(TScreenOf(wnew)->display);
	wnew->dft_background = MyWhitePixel(TScreenOf(wnew)->display);
d7915 2
a7916 2
    wnew->old_foreground = T_COLOR(TScreenOf(wnew), TEXT_FG);
    wnew->old_background = T_COLOR(TScreenOf(wnew), TEXT_BG);
d7921 2
a7922 2
    TRACE(("   Screen foreground  0x%06lx\n", T_COLOR(TScreenOf(wnew), TEXT_FG)));
    TRACE(("   Screen background  0x%06lx\n", T_COLOR(TScreenOf(wnew), TEXT_BG)));
d7926 3
a7928 3
    TScreenOf(wnew)->mouse_button = 0;
    TScreenOf(wnew)->mouse_row = -1;
    TScreenOf(wnew)->mouse_col = -1;
d7952 1
a7952 1
    TScreenOf(wnew)->cursor_blink_res = TScreenOf(wnew)->cursor_blink;
d7956 1
a7956 1
    InitCursorShape(TScreenOf(wnew), TScreenOf(request));
d7959 2
a7960 2
	   TScreenOf(wnew)->cursor_shape,
	   BtoS(TScreenOf(wnew)->cursor_blink)));
d7971 1
a7971 1
    wnew->keyboard.type = TScreenOf(wnew)->old_fkeys
d7994 4
a7997 4
    if (TScreenOf(wnew)->scale_height < 0.9)
	TScreenOf(wnew)->scale_height = (float) 0.9;
    if (TScreenOf(wnew)->scale_height > 1.5)
	TScreenOf(wnew)->scale_height = (float) 1.5;
d8011 5
a8015 5
    TScreenOf(wnew)->terminal_id = atoi(s);
    if (TScreenOf(wnew)->terminal_id < MIN_DECID)
	TScreenOf(wnew)->terminal_id = MIN_DECID;
    if (TScreenOf(wnew)->terminal_id > MAX_DECID)
	TScreenOf(wnew)->terminal_id = MAX_DECID;
d8017 2
a8018 2
	   TScreenOf(wnew)->term_id,
	   TScreenOf(wnew)->terminal_id));
d8020 1
a8020 1
    TScreenOf(wnew)->vtXX_level = (TScreenOf(wnew)->terminal_id / 100);
d8029 4
d8061 1
a8061 1
    TScreenOf(wnew)->tc_query_code = -1;
d8081 1
a8081 1
    TScreenOf(wnew)->pointer_cursor = TScreenOf(request)->pointer_cursor;
d8112 1
d8123 3
a8125 4
    set_flags_from_list(TScreenOf(wnew)->disallow_color_ops,
			TScreenOf(wnew)->disallowedColorOps,
			tblColorOps,
			ecLAST);
d8129 9
a8137 4
    set_flags_from_list(TScreenOf(wnew)->disallow_font_ops,
			TScreenOf(wnew)->disallowedFontOps,
			tblFontOps,
			efLAST);
d8141 3
a8143 4
    set_flags_from_list(TScreenOf(wnew)->disallow_tcap_ops,
			TScreenOf(wnew)->disallowedTcapOps,
			tblTcapOps,
			etLAST);
d8147 3
a8149 4
    set_flags_from_list(TScreenOf(wnew)->disallow_win_ops,
			TScreenOf(wnew)->disallowedWinOps,
			tblWindowOps,
			ewLAST);
d8158 8
a8165 7
    TScreenOf(wnew)->allowPasteControls = TScreenOf(wnew)->allowPasteControl0;
    TScreenOf(wnew)->allowSendEvents = TScreenOf(wnew)->allowSendEvent0;
    TScreenOf(wnew)->allowColorOps = TScreenOf(wnew)->allowColorOp0;
    TScreenOf(wnew)->allowFontOps = TScreenOf(wnew)->allowFontOp0;
    TScreenOf(wnew)->allowTcapOps = TScreenOf(wnew)->allowTcapOp0;
    TScreenOf(wnew)->allowTitleOps = TScreenOf(wnew)->allowTitleOp0;
    TScreenOf(wnew)->allowWindowOps = TScreenOf(wnew)->allowWindowOp0;
d8168 1
a8168 1
    TScreenOf(wnew)->allowScrollLock = TScreenOf(wnew)->allowScrollLock0;
d8175 2
a8176 2
    TScreenOf(wnew)->fnt_icon.fs = XLoadQueryFont(TScreenOf(wnew)->display,
						  TScreenOf(wnew)->icon_fontname);
d8178 2
a8179 2
	   TScreenOf(wnew)->icon_fontname,
	   TScreenOf(wnew)->fnt_icon.fs ? "" : "NOT "));
d8193 6
d8202 10
d8213 51
a8263 5
#define DefaultFontNames TScreenOf(wnew)->menu_font_names[fontMenu_default]
    init_Sres(misc.default_font.f_n);
    init_Sres(misc.default_font.f_b);
    DefaultFontNames[fNorm] = x_strdup(wnew->misc.default_font.f_n);
    DefaultFontNames[fBold] = x_strdup(wnew->misc.default_font.f_b);
d8265 5
a8269 4
    init_Sres(misc.default_font.f_w);
    init_Sres(misc.default_font.f_wb);
    DefaultFontNames[fWide] = x_strdup(wnew->misc.default_font.f_w);
    DefaultFontNames[fWBold] = x_strdup(wnew->misc.default_font.f_wb);
a8270 2
    TScreenOf(wnew)->EscapeFontName() = NULL;
    TScreenOf(wnew)->SelectFontName() = NULL;
d8272 6
a8277 1
    TScreenOf(wnew)->menu_font_number = fontMenu_default;
d8279 2
a8280 2
    if (TScreenOf(wnew)->initial_font != 0) {
	int result = xtermGetFont(TScreenOf(wnew)->initial_font);
d8282 1
a8282 1
	    TScreenOf(wnew)->menu_font_number = result;
d8303 4
a8306 4
    if (TScreenOf(wnew)->cache_doublesize > NUM_CHRSET)
	TScreenOf(wnew)->cache_doublesize = NUM_CHRSET;
    if (TScreenOf(wnew)->cache_doublesize == 0)
	TScreenOf(wnew)->font_doublesize = False;
d8308 2
a8309 2
	   TScreenOf(wnew)->font_doublesize ? "" : " not",
	   TScreenOf(wnew)->cache_doublesize));
d8345 1
a8345 1
	    TScreenOf(wnew)->Acolors[i].resource =
d8347 2
a8348 2
	    if (TScreenOf(wnew)->Acolors[i].resource == 0)
		TScreenOf(wnew)->Acolors[i].resource = XtDefaultForeground;
d8352 3
a8354 3
	    TScreenOf(wnew)->Acolors[i] = TScreenOf(request)->Acolors[i];
	    TScreenOf(wnew)->Acolors[i].resource =
		x_strtrim(TScreenOf(wnew)->Acolors[i].resource);
d8358 2
a8359 2
	TRACE(("Acolors[%d] = %s\n", i, TScreenOf(wnew)->Acolors[i].resource));
	TScreenOf(wnew)->Acolors[i].mode = False;
d8361 2
a8362 2
	    TScreenOf(wnew)->Acolors[i].value = T_COLOR(TScreenOf(wnew), TEXT_FG);
	    TScreenOf(wnew)->Acolors[i].mode = True;
d8364 2
a8365 2
	    TScreenOf(wnew)->Acolors[i].value = T_COLOR(TScreenOf(wnew), TEXT_BG);
	    TScreenOf(wnew)->Acolors[i].mode = True;
d8371 3
a8373 3
	if (TScreenOf(wnew)->Acolors[i] != wnew->dft_foreground &&
	    TScreenOf(wnew)->Acolors[i] != T_COLOR(TScreenOf(wnew), TEXT_FG) &&
	    TScreenOf(wnew)->Acolors[i] != T_COLOR(TScreenOf(wnew), TEXT_BG))
d8397 1
a8397 1
	TScreenOf(wnew)->colorMode = False;
d8412 1
a8412 1
	TScreenOf(wnew)->maxClicks = ck;
d8414 1
a8414 1
	    TScreenOf(wnew)->selectMap[i] = Select_CHAR;
d8418 1
a8418 1
	    TScreenOf(wnew)->selectMap[i] = (SelectUnit) i;
d8423 2
a8424 2
	       TScreenOf(wnew)->selectMap[i]));
	if (TScreenOf(wnew)->selectMap[i] == NSELECTUNITS)
d8427 1
a8427 1
    TRACE(("maxClicks %d\n", TScreenOf(wnew)->maxClicks));
d8437 2
a8438 2
    if (TScreenOf(wnew)->hilite_color == Maybe) {
	TScreenOf(wnew)->hilite_color = False;
d8452 1
a8452 1
	    TScreenOf(wnew)->hilite_color = True;
d8466 3
a8468 3
    TScreenOf(wnew)->Tcolors[TEK_BG] = TScreenOf(wnew)->Tcolors[TEXT_BG];
    TScreenOf(wnew)->Tcolors[TEK_FG] = TScreenOf(wnew)->Tcolors[TEXT_FG];
    TScreenOf(wnew)->Tcolors[TEK_CURSOR] = TScreenOf(wnew)->Tcolors[TEXT_CURSOR];
a8475 7
    for (i = 0; i <= fontMenu_lastBuiltin; ++i) {
	init_Dres2(misc.face_size, i);
    }
    init_Sres(misc.face_name);
    init_Sres(misc.face_wide_name);
    trimSizeFromFace(wnew->misc.face_wide_name, (float *) 0);
    trimSizeFromFace(wnew->misc.face_name, &(wnew->misc.face_size[0]));
d8481 3
a8483 3
	if (IsEmpty(wnew->misc.face_name)) {
	    free(wnew->misc.face_name);
	    wnew->misc.face_name = x_strdup(DEFFACENAME_AUTO);
d8485 1
a8485 1
		   wnew->misc.face_name));
d8493 1
a8493 1
	if (IsEmpty(wnew->misc.face_name)) {
d8507 7
d8531 4
a8534 2
    if (TScreenOf(wnew)->max_combining < 0) {
	TScreenOf(wnew)->max_combining = 0;
d8536 2
a8537 2
    if (TScreenOf(wnew)->max_combining > 5) {
	TScreenOf(wnew)->max_combining = 5;
d8560 1
a8560 1
	TScreenOf(wnew)->wide_chars = True;
d8563 1
a8563 1
	TScreenOf(wnew)->utf8_mode = uFalse;
d8565 2
a8566 1
    TRACE(("initialized UTF-8 mode to %d\n", TScreenOf(wnew)->utf8_mode));
d8570 1
a8570 1
	TScreenOf(wnew)->latin9_mode = True;
d8573 1
a8573 1
	TScreenOf(wnew)->unicode_font = True;
d8575 2
a8576 2
    TRACE(("initialized Latin9 mode to %d\n", TScreenOf(wnew)->latin9_mode));
    TRACE(("initialized unicode_font to %d\n", TScreenOf(wnew)->unicode_font));
d8608 1
a8608 1
    if (TScreenOf(wnew)->backarrow_key)
d8615 1
a8615 1
    if (TScreenOf(wnew)->sixel_scrolling)
d8624 1
a8624 1
	   TScreenOf(wnew)->numcolorregisters));
d8628 1
a8628 1
	   BtoS(TScreenOf(wnew)->privatecolorregisters)));
d8635 1
a8635 1
	switch (TScreenOf(wnew)->terminal_id) {
d8667 1
a8667 1
	       TScreenOf(wnew)->graphics_regis_default_font));
d8670 3
a8672 3
	TScreenOf(wnew)->graphics_regis_def_high = 800;
	TScreenOf(wnew)->graphics_regis_def_wide = 1000;
	if (!x_strcasecmp(TScreenOf(wnew)->graphics_regis_screensize, "auto")) {
d8674 3
a8676 3
		   TScreenOf(wnew)->terminal_id));
	    TScreenOf(wnew)->graphics_regis_def_high = (Dimension) native_w;
	    TScreenOf(wnew)->graphics_regis_def_wide = (Dimension) native_h;
d8682 1
a8682 1
	    if (sscanf(TScreenOf(wnew)->graphics_regis_screensize,
d8688 1
a8688 1
		    TScreenOf(wnew)->graphics_regis_def_high =
d8690 1
a8690 1
		    TScreenOf(wnew)->graphics_regis_def_wide =
d8694 1
a8694 1
			   TScreenOf(wnew)->graphics_regis_screensize));
d8698 1
a8698 1
		       TScreenOf(wnew)->graphics_regis_screensize));
d8702 2
a8703 2
	       (int) TScreenOf(wnew)->graphics_regis_def_wide,
	       (int) TScreenOf(wnew)->graphics_regis_def_high));
d8707 3
a8709 3
	TScreenOf(wnew)->graphics_max_high = 1000;
	TScreenOf(wnew)->graphics_max_wide = 1000;
	if (!x_strcasecmp(TScreenOf(wnew)->graphics_max_size, "auto")) {
d8711 3
a8713 3
		   TScreenOf(wnew)->terminal_id));
	    TScreenOf(wnew)->graphics_max_high = (Dimension) native_w;
	    TScreenOf(wnew)->graphics_max_wide = (Dimension) native_h;
d8719 1
a8719 1
	    if (sscanf(TScreenOf(wnew)->graphics_max_size,
d8725 2
a8726 2
		    TScreenOf(wnew)->graphics_max_high = (Dimension) conf_high;
		    TScreenOf(wnew)->graphics_max_wide = (Dimension) conf_wide;
d8729 1
a8729 1
			   TScreenOf(wnew)->graphics_regis_screensize));
d8733 1
a8733 1
		       TScreenOf(wnew)->graphics_regis_screensize));
d8738 9
a8746 9
	if (TScreenOf(wnew)->graphics_regis_def_high >
	    TScreenOf(wnew)->graphics_max_high) {
	    TScreenOf(wnew)->graphics_max_high =
		TScreenOf(wnew)->graphics_regis_def_high;
	}
	if (TScreenOf(wnew)->graphics_regis_def_wide >
	    TScreenOf(wnew)->graphics_max_wide) {
	    TScreenOf(wnew)->graphics_max_wide =
		TScreenOf(wnew)->graphics_regis_def_wide;
d8750 2
a8751 2
	       (int) TScreenOf(wnew)->graphics_max_wide,
	       (int) TScreenOf(wnew)->graphics_max_high));
d8758 1
a8758 1
	   BtoS(TScreenOf(wnew)->sixel_scrolls_right)));
d8790 1
a8790 1
    TScreenOf(wnew)->bellInProgress = False;
d8792 5
a8796 1
    set_character_class(TScreenOf(wnew)->charClass);
d8817 1
a8817 1
    TScreenOf(wnew)->whichVwin = &TScreenOf(wnew)->fullVwin;
d8820 2
a8821 2
    if (TScreenOf(wnew)->savelines < 0)
	TScreenOf(wnew)->savelines = 0;
d8826 1
a8826 1
    if (!TScreenOf(wnew)->jumpscroll)
d8834 1
a8834 1
    if (TScreenOf(wnew)->c132)
d8859 3
d8940 1
d8991 1
a8991 1
    XFreeFont(screen->display, screen->fnt_icon.fs);
d9020 4
a9023 8
	xtermCloseXft(screen, &(screen->renderFontNorm[n]));
	xtermCloseXft(screen, &(screen->renderFontBold[n]));
	xtermCloseXft(screen, &(screen->renderFontItal[n]));
#if OPT_RENDERWIDE
	xtermCloseXft(screen, &(screen->renderWideNorm[n]));
	xtermCloseXft(screen, &(screen->renderWideBold[n]));
	xtermCloseXft(screen, &(screen->renderWideItal[n]));
#endif
d9025 2
d9044 1
d9049 1
d9053 1
d9059 1
d9061 1
d9066 1
d9068 2
a9069 2
    TRACE_FREE_LEAK(xw->misc.face_name);
    TRACE_FREE_LEAK(xw->misc.face_wide_name);
d9075 1
d9081 6
d9088 7
d9163 1
a9163 1
	   req_type ? XGetAtomName(dpy, req_type) : "?"));
d9277 1
a9277 1
    TRACE(("VTRealize\n"));
d9302 1
a9302 1
	myfont = &(xw->misc.default_font);
d9325 1
a9325 1
    if (!screen->fnts[fNorm].fs) {
d9512 4
a9515 3
    if (screen->fnt_icon.fs == 0) {
	screen->fnt_icon.fs = XLoadQueryFont(screen->display,
					     screen->MenuFontName(fontMenu_font1));
d9517 1
a9517 1
	       (screen->fnt_icon.fs
d9530 1
a9530 1
	&& screen->fnt_icon.fs == 0) {
d9532 1
a9532 1
	screen->fnt_icon.fs = screen->fnts[0].fs;	/* need for next-if */
d9536 1
a9536 1
    if ((xw->work.active_icon == eiDefault) && screen->fnt_icon.fs) {
d9543 1
a9543 1
    if (xw->work.active_icon && screen->fnt_icon.fs) {
d9555 2
a9556 1
	xtermComputeFontInfo(xw, &(screen->iconVwin), screen->fnt_icon.fs, 0);
d9584 1
a9584 1
	setCgsFont(xw, win, gcNorm, &(screen->fnt_icon));
d9590 1
a9590 1
	setCgsFont(xw, win, gcNormReverse, &(screen->fnt_icon));
d9675 2
a9676 1
    return;
d9724 2
a9725 2
    if (xw->misc.xim_fs == 0) {
	xw->misc.xim_fs = XCreateFontSet(XtDisplay(xw),
d9730 1
a9730 1
	if (xw->misc.xim_fs == NULL) {
d9733 1
a9733 1
	    xw->misc.xim_fs = XCreateFontSet(XtDisplay(xw),
d9740 1
a9740 1
    if (xw->misc.xim_fs == NULL) {
d9744 1
a9744 1
	xw->misc.cannot_im = True;
d9746 5
a9750 5
	(void) XExtentsOfFontSet(xw->misc.xim_fs);
	j = (unsigned) XFontsOfFontSet(xw->misc.xim_fs, &fonts, &font_name_list);
	for (i = 0, xw->misc.xim_fs_ascent = 0; i < j; i++) {
	    if (xw->misc.xim_fs_ascent < (*fonts)->ascent)
		xw->misc.xim_fs_ascent = (*fonts)->ascent;
d9753 1
a9753 1
    return (Boolean) !(xw->misc.cannot_im);
d9782 1
a9782 1
    if (xw->misc.cannot_im) {
d9788 2
a9789 2
	    if (xw->misc.inputs[i].w == 0) {
		input = xw->misc.inputs + i;
d9862 1
a9862 1
	xw->misc.cannot_im = True;
d9905 1
a9905 1
	xw->misc.cannot_im = True;
d9916 1
a9916 1
	xw->misc.cannot_im = True;
d9935 1
a9935 1
					 XNFontSet, xw->misc.xim_fs,
d9987 1
a9987 1
	    && !xw->misc.cannot_im
d10004 2
a10005 2
	if (xw->misc.inputs[n].w == w) {
	    result = xw->misc.inputs + n;
d10055 4
a10058 3
	(curvt->misc.default_font.f_n != newvt->misc.default_font.f_n)) {
	if (curvt->misc.default_font.f_n != newvt->misc.default_font.f_n)
	    TScreenOf(newvt)->MenuFontName(fontMenu_default) = newvt->misc.default_font.f_n;
d10065 3
a10067 2
	} else if (curvt->misc.default_font.f_n != newvt->misc.default_font.f_n)
	    TScreenOf(newvt)->MenuFontName(fontMenu_default) = curvt->misc.default_font.f_n;
d10099 64
d10359 10
a10368 3
	if (T_COLOR(screen, TEXT_CURSOR) == (reversed
					     ? xw->dft_background
					     : xw->dft_foreground)) {
d10445 1
a10445 3
		if (T_COLOR(screen, TEXT_CURSOR) == (reversed
						     ? xw->dft_background
						     : xw->dft_foreground)) {
d10503 2
a10504 1
		    setCgsFont(xw, currentWin, currentCgs, &screen->ifnts[which_font]);
d10506 2
a10507 1
		    setCgsFont(xw, currentWin, currentCgs, &screen->fnts[which_font]);
d10546 2
a10547 1
		    setCgsFont(xw, currentWin, currentCgs, &screen->fnts[which_font]);
d10549 2
a10550 1
		    setCgsFont(xw, currentWin, currentCgs, &screen->ifnts[which_font]);
d10581 1
d10669 9
a10677 5
	setCgsFont(xw, WhichVWin(screen),
		   whichXtermCgs(xw, attr_flags, in_selection),
		   (((attr_flags & ATR_ITALIC) && UseItalicFont(screen))
		    ? &screen->ifnts[which_font]
		    : &screen->fnts[which_font]));
d10715 1
a10715 1
    if ((attr_flags & ATR_ITALIC) ^ (xw->flags & ATR_ITALIC)) {
d10717 1
a10717 1
		   whichXtermCgs(xw, xw->flags, in_selection),
d10719 2
a10720 2
		    ? &screen->ifnts[which_font]
		    : &screen->fnts[which_font]));
d11101 9
d11113 1
a11113 1
 *   low[-high]:val[,low[-high]:val[...]]
a11120 7
    int i;			/* iterator, index into s */
    int len;			/* length of s */
    int acc;			/* accumulator */
    int low, high;		/* bounds of range [0..127] */
    int base;			/* 8, 10, 16 (octal, decimal, hex) */
    int numbers;		/* count of numbers per range */
    int digits;			/* count of digits in a number */
d11122 2
a11123 1
    if (!s || !s[0])
d11125 5
d11131 8
a11138 2
    base = 10;			/* in case we ever add octal, hex */
    low = high = -1;		/* out of range */
d11140 2
a11141 3
    for (i = 0, len = (int) strlen(s), acc = 0, numbers = digits = 0;
	 i < len; i++) {
	Char c = CharOf(s[i]);
d11143 15
a11157 42
	if (isspace(c)) {
	    continue;
	} else if (isdigit(c)) {
	    acc = acc * base + (c - '0');
	    digits++;
	    continue;
	} else if (c == '-') {
	    low = acc;
	    acc = 0;
	    if (digits == 0) {
		xtermWarning(FMT, "missing number", s, i);
		return (-1);
	    }
	    digits = 0;
	    numbers++;
	    continue;
	} else if (c == ':') {
	    if (numbers == 0)
		low = acc;
	    else if (numbers == 1)
		high = acc;
	    else {
		xtermWarning(FMT, "too many numbers", s, i);
		return (-1);
	    }
	    digits = 0;
	    numbers++;
	    acc = 0;
	    continue;
	} else if (c == ',') {
	    /*
	     * now, process it
	     */

	    if (high < 0) {
		high = low;
		numbers++;
	    }
	    if (numbers != 2) {
		xtermWarning(FMT, "bad value number", s, i);
	    } else if (SetCharacterClassRange(low, high, acc) != 0) {
		xtermWarning(FMT, "bad range", s, i);
d11160 15
a11174 9
	    low = high = -1;
	    acc = 0;
	    digits = 0;
	    numbers = 0;
	    continue;
	} else {
	    xtermWarning(FMT, "bad character", s, i);
	    return (-1);
	}			/* end if else if ... else */
d11176 4
a11179 1
    }
d11181 11
a11191 2
    if (low < 0 && high < 0)
	return (0);
d11193 4
a11196 3
    /*
     * now, process it
     */
d11198 16
a11213 6
    if (high < 0)
	high = low;
    if (numbers < 1 || numbers > 2) {
	xtermWarning(FMT, "bad value number", s, i);
    } else if (SetCharacterClassRange(low, high, acc) != 0) {
	xtermWarning(FMT, "bad range", s, i);
d11216 1
d11360 1
a11360 1
	String save = TScreenOf(xw)->SelectFontName();
@


1.37
log
@Update to xterm-325. Testing by krw@@, shadchin@@ and naddy@@. Thanks
@
text
@d1 1
a1 1
/* $XTermId: charproc.c,v 1.1420 2016/05/30 19:31:33 tom Exp $ */
d239 1
d1148 1
a1148 1
	screen->gsets[1] = '0';	/* Graphics             */
d2113 1
a2113 1
	    && (c >= 128 && c < 160)) {
d2117 3
d2222 2
a2223 2
	TRACE(("parse %04X -> %d %s (used=%lu)\n",
	       c, sp->nextstate,
d4998 4
d7564 1
a7564 1
	    if (!IsEmpty(temp)) {
@


1.36
log
@Update to xterm 322. Tested by shadchin@@ and jsg@@. Thanks.
@
text
@d1 1
a1 1
/* $XTermId: charproc.c,v 1.1414 2015/12/30 09:38:49 tom Exp $ */
d4 1
a4 1
 * Copyright 1999-2014,2015 by Thomas E. Dickey
d329 4
d4131 1
a4131 2
	    ResetState(sp);
	    break;
d4136 1
a4136 2
	    ResetState(sp);
	    break;
a4399 2
    int riten;

d4413 1
a4413 1
	fprintf(stderr, "v_write called with %d bytes (%ld left over)",
d4464 1
a4464 1
			fprintf(stderr, "expanded buffer to %d\n",
d4502 2
d4551 1
a4551 1
		fprintf(stderr, "shrunk buffer to %d\n", allocsize);
d4680 1
a4680 2
    int i, time_select;
    int size;
d4702 3
d4927 1
a4927 1
    int next_col, last_col, this_col;	/* must be signed */
d5049 1
a5049 1
	last_col = LineMaxCol(screen, ld);
a6419 1
    unsigned value_mask;
d6448 2
a6732 2
    int i;
    int inters;
d6742 3
a7088 1
    unsigned long value;
d7122 2
a7508 1
    size_t size;
d7515 1
d7517 2
a7623 8
static void
initializeKeyboardType(XtermWidget xw)
{
    xw->keyboard.type = TScreenOf(xw)->old_fkeys
	? keyboardIsLegacy
	: keyboardIsDefault;
}

d7861 1
d7865 1
d7875 3
a7879 1
    initializeKeyboardType(wnew);
a9912 1
    int x, y;
a9933 1
    size_t off;
d10142 1
d10219 1
a10219 1
	    int which_font = (xw->flags & BOLD ? fBold : fNorm);
d10223 1
a10223 1
		    which_font = (xw->flags & BOLD ? fWBold : fWide);
d10247 1
a10298 1
    size_t off;
d10384 1
a10384 1
	which_font = (attr_flags & BOLD ? fBold : fNorm);
d10388 1
a10388 1
		which_font = (attr_flags & BOLD ? fWBold : fWide);
d10416 1
a10626 4
#if OPT_ISO_COLORS
    static char empty[1];
#endif

d10642 1
d10646 1
d10654 1
d10690 1
d10692 2
a10693 1
	initializeKeyboardType(xw);
a10950 5
    char mapName[1000];
    char mapClass[1000];
    char *pmapName;
    char *pmapClass;
    size_t len;
d10970 5
a11064 1
	char *used = 0;
d11079 2
a11333 1
    size_t needed = 0;
d11382 1
a11382 1
	needed = 0;
@


1.35
log
@Update to xterm 320. Tested by jsg@@ Thanks.
@
text
@d1 1
a1 1
/* $XTermId: charproc.c,v 1.1413 2015/07/15 09:21:40 tom Exp $ */
d282 1
d446 1
d5608 4
d5882 3
d6220 4
d7971 1
@


1.34
log
@xterm 314. tested by naddy@@
@
text
@d1 1
a1 1
/* $XTermId: charproc.c,v 1.1393 2014/12/28 22:12:39 tom Exp $ */
d4 1
a4 1
 * Copyright 1999-2013,2014 by Thomas E. Dickey
a2713 1
		    reply.a_param[count++] = 6;		/* selective-erase */
d3206 1
a3206 1
		    reply.a_final = '{';
d3324 2
a3325 1
	    if (TEK4014_ACTIVE(xw))
d3327 1
d3562 2
d3572 3
a3574 3
		    screen->vtXX_level = GetParam(0) - 60;
		    if (GetParam(0) > 61) {
			switch (zero_if_default(1)) {
d3776 1
a3776 2
	    if (screen->vtXX_level >= 4
		&& IsLeftRightMode(xw)) {
d3784 1
a3784 2
	    if (screen->vtXX_level >= 4
		&& IsLeftRightMode(xw)) {
a3872 1
#if OPT_DEC_LOCATOR
d3878 1
d5004 5
a5008 1
		    need_wrap = True;
d5395 1
d6560 4
a6563 1
	    (void) QueryMaximize(xw, &root_height, &root_width);
d7078 17
a7094 3
    if ((int) (askedWidth = (Dimension) cols) < cols
	|| (int) (askedHeight = (Dimension) rows) < rows)
	return;
d7439 1
a7439 1
    static struct {
d7860 1
a7860 1
    init_Bres(screen.delete_is_del);
d8247 1
a8247 1
    init_Bres(screen.hilite_color);
d9054 2
a9055 2
    unsigned width, height;
    int xpos, ypos, pr;
d9139 4
a9142 4
    xpos = 1;
    ypos = 1;
    width = 80;
    height = 24;
d9145 2
a9146 3
    pr = XParseGeometry(xw->misc.geo_metry, &xpos, &ypos,
			&width, &height);
    TRACE(("... position %d,%d size %dx%d\n", ypos, xpos, height, width));
d9148 2
a9149 2
    set_max_col(screen, (int) (width - 1));	/* units in character cells */
    set_max_row(screen, (int) (height - 1));	/* units in character cells */
d9152 2
a9153 2
    width = screen->fullVwin.fullwidth;
    height = screen->fullVwin.fullheight;
d9161 3
a9163 3
	xpos += (DisplayWidth(screen->display, DefaultScreen(screen->display))
		 - (int) width
		 - (BorderWidth(XtParent(xw)) * 2));
d9166 3
a9168 3
	ypos += (DisplayHeight(screen->display, DefaultScreen(screen->display))
		 - (int) height
		 - (BorderWidth(XtParent(xw)) * 2));
d9170 2
d9180 2
a9181 2
    xw->hints.x = xpos;
    xw->hints.y = ypos;
d9225 1
a9225 1
		      (Dimension) width, (Dimension) height,
a10464 1
    int col;
d10466 2
d10469 5
a10473 4
    for (col = 0; col < MaxCols(screen); ++col) {
	if (ld->attribs[col] & BLINK) {
	    result = True;
	    break;
d10903 20
a10930 5
    static XtResource key_resources[] =
    {
	{XtNtranslations, XtCTranslations, XtRTranslationTable,
	 sizeof(XtTranslations), 0, XtRTranslationTable, (XtPointer) NULL}
    };
d10937 6
d10946 2
a10947 1
    if (original == NULL)
d10949 1
d10952 1
d10954 1
a10954 2
	return;
    }
d10956 1
a10956 1
    len = strlen(params[0]) + 7;
d10958 6
a10963 6
    pmapName = (char *) MyStackAlloc(len, mapName);
    pmapClass = (char *) MyStackAlloc(len, mapClass);
    if (pmapName == NULL
	|| pmapClass == NULL) {
	SysError(ERROR_KMMALLOC1);
    } else {
d10965 12
a10976 8
	(void) sprintf(pmapName, "%sKeymap", params[0]);
	(void) strcpy(pmapClass, pmapName);
	if (islower(CharOf(pmapClass[0])))
	    pmapClass[0] = x_toupper(pmapClass[0]);
	XtGetSubresources(w, (XtPointer) &keymap, pmapName, pmapClass,
			  key_resources, (Cardinal) 1, NULL, (Cardinal) 0);
	if (keymap != NULL)
	    XtOverrideTranslations(w, keymap);
d10978 3
a10980 2
	MyStackFree(pmapName, mapName);
	MyStackFree(pmapClass, mapClass);
@


1.33
log
@Update to xterm 313. Tested by shadchin@@
@
text
@d1 1
a1 1
/* $XTermId: charproc.c,v 1.1379 2014/11/28 22:27:20 tom Exp $ */
d404 1
a404 1
	 screen.allowPasteControls, False),
d614 3
d639 4
d685 9
a693 2
    Sres(XtNregisScreenSize, XtCRegisScreenSize, screen.regis_screensize,
	 "800x1000"),
d2855 1
d2870 1
d2895 1
a2895 1
		    setItalicFont(xw, True);
d2897 3
d2947 3
d2982 1
d2984 1
d2986 1
d2988 1
d2990 1
d2992 1
d2994 1
d3020 1
d3022 1
d3024 1
d3026 1
d3028 1
d3030 1
d3032 1
d3053 1
d3055 1
d3057 1
d3059 1
d3061 1
d3063 1
d3065 1
d3082 1
d3084 1
d3086 1
d3088 1
d3090 1
d3092 1
d3175 1
d3260 1
d3383 1
d3427 1
d3429 1
d3482 1
d3484 1
d3491 1
d3493 1
d4309 1
d4311 1
d4316 1
d4318 1
d4320 1
d4336 1
d4338 1
d4343 1
d4345 1
d4347 1
d4349 1
d5810 1
d5812 1
d5814 1
d6127 1
d6129 1
d6131 1
d6744 1
d6746 1
d6748 1
d7038 1
d7390 1
d7966 1
a7966 1
    init_Bres(screen.allowPasteControls);
d8013 1
d8111 4
d8416 4
a8419 7
#if OPT_REGIS_GRAPHICS
    init_Sres(screen.regis_screensize);
    TScreenOf(wnew)->regis_max_high = 800;
    TScreenOf(wnew)->regis_max_wide = 1000;
    if (!x_strcasecmp(TScreenOf(wnew)->regis_screensize, "auto")) {
	TRACE(("setting ReGIS screensize based on terminal_id %d\n",
	       TScreenOf(wnew)->terminal_id));
d8422 2
a8423 2
	    TScreenOf(wnew)->regis_max_high = 768;
	    TScreenOf(wnew)->regis_max_wide = 460;
d8426 2
a8427 2
	    TScreenOf(wnew)->regis_max_high = 800;
	    TScreenOf(wnew)->regis_max_wide = 460;
d8430 2
a8431 2
	    TScreenOf(wnew)->regis_max_high = 800;
	    TScreenOf(wnew)->regis_max_wide = 460;
d8434 2
a8435 2
	    TScreenOf(wnew)->regis_max_high = 800;
	    TScreenOf(wnew)->regis_max_wide = 480;
d8438 4
a8441 2
	    TScreenOf(wnew)->regis_max_high = 800;
	    TScreenOf(wnew)->regis_max_wide = 480;
d8444 2
a8445 2
	    TScreenOf(wnew)->regis_max_high = 960;
	    TScreenOf(wnew)->regis_max_wide = 750;
d8448 90
a8537 17
    } else {
	int max_high;
	int max_wide;
	char ignore;

	if (sscanf(TScreenOf(wnew)->regis_screensize,
		   "%dx%d%c",
		   &max_high,
		   &max_wide,
		   &ignore) == 2) {
	    TScreenOf(wnew)->regis_max_high = (Dimension) max_high;
	    TScreenOf(wnew)->regis_max_wide = (Dimension) max_wide;
	}
    }
    TRACE(("maximum ReGIS screensize %dx%d\n",
	   (int) TScreenOf(wnew)->regis_max_high,
	   (int) TScreenOf(wnew)->regis_max_wide));
d8729 1
d8731 1
d10185 1
a10185 1
	    if (fix_italics) {
d10226 1
a10226 1
	    if (fix_italics) {
d10351 1
a10351 1
		   ((attr_flags & ATR_ITALIC)
d10393 1
a10393 1
		   ((xw->flags & ATR_ITALIC)
@


1.32
log
@Update to xterm 311. ok shadchin@@
@
text
@d1 1
a1 1
/* $XTermId: charproc.c,v 1.1370 2014/09/15 23:39:44 tom Exp $ */
d677 5
d914 1
a914 1
	    LineData *ld = getLineData(screen, row)->;
d4799 1
a4799 1
    LineData *ld;
d4966 1
a4966 1
	LineData *ld = getLineData(screen, screen->cur_row);
d5002 1
a5002 1
visual_width(IChar *str, Cardinal len)
d5032 1
a5032 1
	TRACE(("HandleStructNotify(MapNotify)\n"));
d5037 1
a5037 1
	TRACE(("HandleStructNotify(UnmapNotify)\n"));
d5048 2
a5049 1
	    TRACE(("HandleStructNotify(ConfigureNotify) %d,%d %dx%d\n",
d5099 1
a5099 1
	TRACE(("HandleStructNotify(ReparentNotify)\n"));
d5102 3
a5104 2
	TRACE(("HandleStructNotify(event %s)\n",
	       visibleEventType(event->type)));
a6776 1
	screen->whichBuf = 1;
a6792 1
	screen->whichBuf = 0;
d6807 1
d8331 52
d9737 1
a9737 1
    LineData *ld = 0;
d10101 1
a10101 1
    LineData *ld = 0;
d10241 1
a10241 1
    refresh_displayed_graphics(screen,
d10280 1
a10280 1
LineHasBlinking(TScreen *screen, LineData *ld)
d10393 1
a10393 1
		LineData *ld = getLineData(screen, ROW2INX(screen, row));
@


1.31
log
@Update to xterm-309. Version 308 tested by several people including
naddy@@ who found a small regression, fixed in 309.
@
text
@d1 1
a1 1
/* $XTermId: charproc.c,v 1.1367 2014/07/12 22:49:54 Steve.Wall Exp $ */
d7975 2
a7976 2
    TScreenOf(wnew)->MenuFontName(fontMenu_fontescape) = NULL;
    TScreenOf(wnew)->MenuFontName(fontMenu_fontsel) = NULL;
d9833 3
a9835 1
	if (T_COLOR(screen, TEXT_CURSOR) == xw->dft_foreground) {
d9911 3
a9913 1
		if (T_COLOR(screen, TEXT_CURSOR) == xw->dft_foreground) {
d10771 1
a10771 1
	String save = TScreenOf(xw)->MenuFontName(fontMenu_fontsel);
d10801 1
a10801 1
		TScreenOf(xw)->MenuFontName(fontMenu_fontsel) = test;
d10808 1
a10808 1
		    TScreenOf(xw)->MenuFontName(fontMenu_fontsel) = save;
d10837 1
a10837 1
	atom_name = (screen->mappedSelect
d10857 1
a10857 1
	screen->MenuFontName(fontMenu_fontsel) =
d10860 1
a10860 1
	       NonNull(screen->MenuFontName(fontMenu_fontsel))));
@


1.30
log
@Update to xterm 304. With help of shadchin@@

tested by ajacoutot@@ and shadchin@@
@
text
@d1 1
a1 1
/* $XTermId: charproc.c,v 1.1332 2014/05/02 21:48:33 tom Exp $ */
d97 2
d549 1
a549 1
    Bres(XtNcursorUnderline, XtCCursorUnderline, screen.cursor_underline, False),
d912 1
a912 1
		Char *attribs = ld->attribs;
d919 1
a919 1
			attribs[col] = (Char) flags;
d1084 22
d1344 22
d2851 3
d2855 1
a2855 1
			    (INVERSE | BOLD | BLINK | UNDERLINE | INVISIBLE));
d2861 1
a2861 1
		    xw->flags |= BOLD;
d2866 3
a2868 3
		case 5:	/* Blink                */
		    xw->flags |= BLINK;
		    StartBlinking(screen);
d2873 5
d2879 8
a2886 1
		    xw->flags |= UNDERLINE;
d2892 1
a2892 1
		    xw->flags |= INVERSE;
d2898 5
a2902 1
		    xw->flags |= INVISIBLE;
d2904 6
d2912 3
d2919 6
d2927 3
d2949 5
d3399 2
a3400 1

d7493 13
d7735 1
d7737 4
a7740 3
    TScreenOf(wnew)->cursor_shape = request->screen.cursor_underline
	? CURSOR_UNDERLINE
	: CURSOR_BLOCK;
d7747 1
d7749 2
d7752 1
a7752 3
    wnew->keyboard.type = TScreenOf(wnew)->old_fkeys
	? keyboardIsLegacy
	: keyboardIsDefault;
d7800 2
d7855 1
d8483 1
a8483 1
    Cardinal n;
d8551 1
d8564 3
d8629 21
d9761 2
a9762 2
    fg_pix = getXtermForeground(xw, flags, extract_fg(xw, fg_bg, flags));
    bg_pix = getXtermBackground(xw, flags, extract_bg(xw, fg_bg, flags));
d9952 11
d9964 14
a9977 1
	    drawXtermText(xw, flags & DRAWX_MASK,
d9987 3
a9989 1
		    drawXtermText(xw, (flags & DRAWX_MASK) | NOBACKGROUND,
d10004 9
d10040 4
d10118 18
d10144 3
a10146 1
    drawXtermText(xw, flags & DRAWX_MASK,
d10156 3
a10158 1
	    drawXtermText(xw, (flags & DRAWX_MASK) | NOBACKGROUND,
d10167 10
d10379 4
d10424 4
d10438 5
d10486 12
@


1.29
log
@Update to xterm-300. Tested  by ajacoutot@@ and shadchin@@.
@
text
@d1 1
a1 1
/* $XTermId: charproc.c,v 1.1319 2013/11/26 20:38:11 tom Exp $ */
d4 1
a4 1
 * Copyright 1999-2012,2013 by Thomas E. Dickey
d370 3
a373 1
    { "set-sixel-scrolling",	HandleSixelScrolling },
d680 8
a689 1
    Bres(XtNsixelScrolling, XtCSixelScrolling, screen.sixel_scrolling, False),
d768 1
a768 1
static void VTExpose(Widget w, XEvent * event, Region region);
d1249 22
a1270 22
#define WHICH_TABLE(name) if (table == name) result = #name
static const char *
which_table(Const PARSE_T * table)
{
    const char *result = "?";
    /* *INDENT-OFF* */
    WHICH_TABLE (ansi_table);
    else WHICH_TABLE (cigtable);
    else WHICH_TABLE (csi2_table);
    else WHICH_TABLE (csi_ex_table);
    else WHICH_TABLE (csi_quo_table);
    else WHICH_TABLE (csi_table);
    else WHICH_TABLE (dec2_table);
    else WHICH_TABLE (dec3_table);
    else WHICH_TABLE (dec_table);
    else WHICH_TABLE (eigtable);
    else WHICH_TABLE (esc_sp_table);
    else WHICH_TABLE (esc_table);
    else WHICH_TABLE (scrtable);
    else WHICH_TABLE (scs96table);
    else WHICH_TABLE (scstable);
    else WHICH_TABLE (sos_table);
d1272 1
a1272 1
    else WHICH_TABLE (csi_sp_table);
d1275 1
a1275 1
    else WHICH_TABLE (csi_tick_table);
d1278 3
a1280 3
    else WHICH_TABLE (csi_dollar_table);
    else WHICH_TABLE (csi_star_table);
    else WHICH_TABLE (csi_dec_dollar_table);
d1283 2
a1284 2
    else WHICH_TABLE (esc_pct_table);
    else WHICH_TABLE (scs_pct_table);
d1287 3
a1289 3
    else WHICH_TABLE (vt52_table);
    else WHICH_TABLE (vt52_esc_table);
    else WHICH_TABLE (vt52_ignore_table);
d1291 15
a1305 1
    /* *INDENT-ON* */
d1309 25
d1565 21
a1621 21
 * Check if the given item in the parameter array has subparameters.
 * If so, return the number of subparameters to use as a loop limit, etc.
 */
static int
param_has_subparams(int item)
{
    int result = 0;
    if (parms.has_subparams) {
	int n = subparam_index(item, 0);
	if (n >= 0 && parms.is_sub[n]) {
	    while (n++ < nparam && parms.is_sub[n - 1] < parms.is_sub[n]) {
		result++;
	    }
	}
    }
    TRACE(("...param_has_subparams(%d) ->%d\n", item, result));
    return result;
}

#if OPT_256_COLORS || OPT_88_COLORS || OPT_ISO_COLORS
/*
d2134 3
d2615 3
d2619 1
d2641 1
a2641 1
#if OPT_SIXEL_GRAPHICS
d2647 9
d3459 63
d4054 8
d4063 1
a4063 5
		&& screen->utf8_mode != uAlways) {
		if (!screen->wide_chars) {
		    WriteNow();
		    ChangeToWide(xw);
		}
d4931 1
a4931 1
		   XEvent * event,
d5324 1
a5324 1
	    if (screen->terminal_id == 240 ||
d5327 2
a5328 1
		screen->terminal_id == 340) {
d5491 1
a5491 1
#if OPT_SIXEL_GRAPHICS
d5493 3
a5495 2
	    TRACE(("DECSET/DECRST PRIVATE_COLOR_REGISTERS %s\n",
		   BtoS(screen->privatecolorregisters)));
d5500 14
d5750 1
a5750 1
#if OPT_SIXEL_GRAPHICS
d5758 7
d6077 1
a6077 1
#if OPT_SIXEL_GRAPHICS
d6079 1
a6079 1
	    TRACE(("restore PRIVATE_COLOR_REGISTERS %s\n",
d6082 2
d6087 9
d6825 1
a6825 1
	 XEvent * event,
d6834 1
a6834 1
VTGraphicsOrNoExpose(XEvent * event)
d6860 1
a6860 1
		   XEvent * event,
d7105 1
d7320 1
a7320 1
		    FlagList * list,
d7418 1
a7418 1
    static FlagList tblColorOps[] =
d7427 1
a7427 1
    static FlagList tblFontOps[] =
d7435 1
a7435 1
    static FlagList tblTcapOps[] =
d7443 1
a7443 1
    static FlagList tblWindowOps[] =
d7477 1
a7477 1
    static FlagList tblRenderFont[] =
d7486 1
a7486 1
    static FlagList tblUtf8Mode[] =
d7496 1
a7496 1
    static FlagList tblAIconOps[] =
d7504 1
a7504 1
    static FlagList tbl8BitMeta[] =
d7532 4
d7570 5
d8193 1
d8201 1
a8201 1
    if (TScreenOf(wnew)->sixel_scrolling)	/* FIXME: should this be off unconditionally here? */
d8203 8
a8210 3
    TRACE(("initialized DECSDM %s (resource default is %d)\n",
	   BtoS(wnew->keyboard.flags & MODE_DECSDM),
	   TScreenOf(wnew)->sixel_scrolling));
d8213 1
a8213 1
    TRACE(("initialized PRIVATE_COLOR_REGISTERS to resource default %s\n",
d8217 6
d8333 1
a8333 1
releaseWindowGCs(XtermWidget xw, VTwin * win)
d8524 1
a8524 1
	XtFree((char *) (screen->selection_atoms));
d8526 1
a8526 1
    XtFree((char *) (screen->selection_data));
d8533 2
d8554 1
d8669 1
d10157 1
d10159 1
d10225 1
d10227 1
a10227 1
	if (TScreenOf(xw)->sixel_scrolling)	/* FIXME: should this be off unconditionally here? */
d10229 1
a10229 1
	TRACE(("full reset DECSDM %s (resource default is %d)\n",
d10231 8
a10238 1
	       TScreenOf(xw)->sixel_scrolling));
d10240 8
d10253 1
a10253 1
	reset_decudk();
d10430 1
a10430 1
		   XEvent * event GCC_UNUSED,
d10483 1
a10483 1
	   XEvent * event GCC_UNUSED,
d10495 1
a10495 1
		 XEvent * event GCC_UNUSED,
d10505 1
a10505 1
	     XEvent * event,
d10523 2
a10524 2
		  Atom * selection GCC_UNUSED,
		  Atom * type,
@


1.28
log
@Update to xterm 296. Sixel graphics disabled for now.
@
text
@d1 1
a1 1
/* $XTermId: charproc.c,v 1.1300 2013/07/04 15:19:32 tom Exp $ */
d140 2
a141 2
typedef void (*BitFunc) (unsigned * /* p */ ,
			 unsigned /* mask */ );
d160 3
a162 3
static void bitclr(unsigned *p, unsigned mask);
static void bitcpy(unsigned *p, unsigned q, unsigned mask);
static void bitset(unsigned *p, unsigned mask);
d560 1
d889 1
a889 1
CheckBogusForeground(TScreen * screen, const char *tag)
d1074 1
a1074 1
resetCharsets(TScreen * screen)
d1078 4
a1081 4
    screen->gsets[0] = 'B';	/* ASCII_G              */
    screen->gsets[1] = 'B';	/* ASCII_G              */
    screen->gsets[2] = 'B';	/* ASCII_G              */
    screen->gsets[3] = 'B';	/* ASCII_G              */
d1093 15
d1114 1
a1114 1
set_ansi_conformance(TScreen * screen, int level)
d1126 2
a1127 2
	    screen->gsets[0] = 'B';	/* G0 is ASCII */
	    screen->gsets[1] = 'B';	/* G1 is ISO Latin-1 */
d1132 1
a1132 1
	    screen->gsets[0] = 'B';	/* G0 is ASCII */
d1144 1
a1144 1
set_tb_margins(TScreen * screen, int top, int bottom)
d1161 1
a1161 1
set_lr_margins(TScreen * screen, int left, int right)
d1181 1
a1181 1
reset_margins(TScreen * screen)
d1188 1
a1188 1
set_max_col(TScreen * screen, int cols)
d1197 1
a1197 1
set_max_row(TScreen * screen, int rows)
d1275 1
d1370 1
a1370 1
init_groundtable(TScreen * screen, struct ParseState *sp)
d1387 1
a1387 1
    TRACE(("select_charset %#x %d\n", type, size));
d1397 81
d2924 12
a2935 2
		reply.a_param[count++] = (ParmType) (screen->cur_row + 1);
		reply.a_param[count++] = (ParmType) (screen->cur_col + 1);
d3142 1
a3142 2
	    if (screen->vtXX_level != 0)
		screen->gsets[sp->scstype] = CharOf(c);
d3918 1
d3945 11
d4099 1
a4099 1
v_write(int f, const Char * data, unsigned len)
d4262 1
a4262 1
updateCursor(TScreen * screen)
d4274 1
a4274 1
reallyStopBlinking(TScreen * screen)
d4618 1
a4618 1
       IChar * buf,		/* start of characters to process */
d4639 1
a4639 5
    /* don't translate if we use UTF-8, and are not handling legacy support
     * for line-drawing characters.
     */
    if ((screen->utf8_mode == uFalse)
	|| (screen->vt100_graphics))
d4777 1
a4777 1
visual_width(IChar * str, Cardinal len)
d4801 1
a4801 1
		   Boolean * cont GCC_UNUSED)
d4885 1
a4885 1
SetCursorBlink(TScreen * screen, Bool enable)
d4902 1
a4902 1
ToggleCursorBlink(TScreen * screen)
d5107 5
a5111 1
	    (*func) (&xw->flags, NATIONAL);
a5188 1
		CursorSet(screen, 0, 0, xw->flags);
d5457 3
a5459 1
	    DoSM(DP_DECNRCM, xw->flags & NATIONAL);
d5739 4
a5742 1
	    bitcpy(&xw->flags, screen->save_modes[DP_DECNRCM], NATIONAL);
a5793 1
	    CursorSet(screen, 0, 0, xw->flags);
d6323 1
a6323 1
static void
d6326 1
d6328 1
d6334 1
a6334 1
static void
d6337 1
d6339 1
d6345 1
a6345 1
static void
d6348 1
d6351 1
d6367 1
a6367 1
unparseseq(XtermWidget xw, ANSI * ap)
d6449 1
a6449 1
	unparse_end(xw);
d6583 1
a6583 1
CheckBufPtrs(TScreen * screen)
d6596 1
a6596 1
SwitchBufPtrs(TScreen * screen, int toBuf GCC_UNUSED)
d6696 1
a6696 1
		   Boolean * cont GCC_UNUSED)
d7200 38
d7438 1
d7895 2
d8366 1
a8366 1
getProperty(Display * dpy,
d8900 1
a8900 1
xim_instantiate_cb(Display * display,
d8967 1
a8967 1
    return (Boolean) ! (xw->misc.cannot_im);
d9794 1
a9794 1
StartBlinking(TScreen * screen)
d9810 1
a9810 1
StopBlinking(TScreen * screen)
d9823 1
a9823 1
LineHasBlinking(TScreen * screen, LineData * ld)
d9920 1
a9920 1
RestartBlinking(TScreen * screen GCC_UNUSED)
d10222 1
a10222 1
		   String * params,
d10275 1
a10275 1
	   String * params,	/* [0] = volume */
d10287 1
a10287 1
		 String * params GCC_UNUSED,
d10297 1
a10297 1
	     String * params GCC_UNUSED,
@


1.27
log
@Update to xterm 293. Tested by naddy@@ ajacoutot@@
@
text
@d1 1
a1 1
/* $XTermId: charproc.c,v 1.1289 2013/05/26 21:18:52 tom Exp $ */
a135 1
#include <xcharmouse.h>
d138 1
d154 4
a157 2
		       int /* toBuf */ );
static void ToAlternate(XtermWidget /* xw */ );
d369 4
d676 6
d1998 4
a2001 1
	TRACE(("parse %04X -> %d %s\n", c, sp->nextstate, which_table(sp->parsestate)));
d2464 6
d2479 1
a2479 1
			reply.a_param[count++] = 2;	/* AVO */
d2488 9
d2838 1
a2838 1
		    reply.a_param[count++] = 13;	/* implement printer */
d2860 2
a2861 1
	    case 53:
d2872 12
d3289 3
a3291 1
	    TRACE(("CASE_ST: End of String (%lu bytes)\n", (unsigned long) sp->string_used));
d3312 3
a4847 98
 * Use this enumerated type to check consistency among dpmodes(), savemodes()
 * and restoremodes().
 */
typedef enum {
    srm_DECCKM = 1
    ,srm_DECANM = 2
    ,srm_DECCOLM = 3
    ,srm_DECSCLM = 4
    ,srm_DECSCNM = 5
    ,srm_DECOM = 6
    ,srm_DECAWM = 7
    ,srm_DECARM = 8
    ,srm_X10_MOUSE = SET_X10_MOUSE
#if OPT_TOOLBAR
    ,srm_RXVT_TOOLBAR = 10
#endif
#if OPT_BLINK_CURS
    ,srm_ATT610_BLINK = 12
#endif
    ,srm_DECPFF = 18
    ,srm_DECPEX = 19
    ,srm_DECTCEM = 25
    ,srm_RXVT_SCROLLBAR = 30
#if OPT_SHIFT_FONTS
    ,srm_RXVT_FONTSIZE = 35
#endif
#if OPT_TEK4014
    ,srm_DECTEK = 38
#endif
    ,srm_132COLS = 40
    ,srm_CURSES_HACK = 41
    ,srm_DECNRCM = 42
    ,srm_MARGIN_BELL = 44
    ,srm_REVERSEWRAP = 45
#ifdef ALLOWLOGGING
    ,srm_ALLOWLOGGING = 46
#endif
    ,srm_OPT_ALTBUF_CURSOR = 1049
    ,srm_OPT_ALTBUF = 1047
    ,srm_ALTBUF = 47
    ,srm_DECNKM = 66
    ,srm_DECBKM = 67
    ,srm_DECLRMM = 69
    ,srm_DECNCSM = 95
    ,srm_VT200_MOUSE = SET_VT200_MOUSE
    ,srm_VT200_HIGHLIGHT_MOUSE = SET_VT200_HIGHLIGHT_MOUSE
    ,srm_BTN_EVENT_MOUSE = SET_BTN_EVENT_MOUSE
    ,srm_ANY_EVENT_MOUSE = SET_ANY_EVENT_MOUSE
#if OPT_FOCUS_EVENT
    ,srm_FOCUS_EVENT_MOUSE = SET_FOCUS_EVENT_MOUSE
#endif
    ,srm_EXT_MODE_MOUSE = SET_EXT_MODE_MOUSE
    ,srm_SGR_EXT_MODE_MOUSE = SET_SGR_EXT_MODE_MOUSE
    ,srm_URXVT_EXT_MODE_MOUSE = SET_URXVT_EXT_MODE_MOUSE
    ,srm_ALTERNATE_SCROLL = SET_ALTERNATE_SCROLL
    ,srm_RXVT_SCROLL_TTY_OUTPUT = 1010
    ,srm_RXVT_SCROLL_TTY_KEYPRESS = 1011
    ,srm_EIGHT_BIT_META = 1034
#if OPT_NUM_LOCK
    ,srm_REAL_NUMLOCK = 1035
    ,srm_META_SENDS_ESC = 1036
#endif
    ,srm_DELETE_IS_DEL = 1037
#if OPT_NUM_LOCK
    ,srm_ALT_SENDS_ESC = 1039
#endif
    ,srm_KEEP_SELECTION = 1040
    ,srm_SELECT_TO_CLIPBOARD = 1041
    ,srm_BELL_IS_URGENT = 1042
    ,srm_POP_ON_BELL = 1043
    ,srm_TITE_INHIBIT = 1048
#if OPT_TCAP_FKEYS
    ,srm_TCAP_FKEYS = 1050
#endif
#if OPT_SUN_FUNC_KEYS
    ,srm_SUN_FKEYS = 1051
#endif
#if OPT_HP_FUNC_KEYS
    ,srm_HP_FKEYS = 1052
#endif
#if OPT_SCO_FUNC_KEYS
    ,srm_SCO_FKEYS = 1053
#endif
    ,srm_LEGACY_FKEYS = 1060
#if OPT_SUNPC_KBD
    ,srm_VT220_FKEYS = 1061
#endif
#if OPT_READLINE
    ,srm_BUTTON1_MOVE_POINT = SET_BUTTON1_MOVE_POINT
    ,srm_BUTTON2_MOVE_POINT = SET_BUTTON2_MOVE_POINT
    ,srm_DBUTTON3_DELETE = SET_DBUTTON3_DELETE
    ,srm_PASTE_IN_BRACKET = SET_PASTE_IN_BRACKET
    ,srm_PASTE_QUOTE = SET_PASTE_QUOTE
    ,srm_PASTE_LITERAL_NL = SET_PASTE_LITERAL_NL
#endif				/* OPT_READLINE */
} DECSET_codes;

/*
d4857 1
d5025 1
a5025 1
		    ToAlternate(xw);
d5040 1
a5040 1
		    ToAlternate(xw);
d5073 14
d5241 11
d5362 1
a5362 1
	case srm_DECBKM:
d5368 6
d5483 8
d5648 1
a5648 1
		    ToAlternate(xw);
d5660 1
a5660 1
	case srm_DECBKM:
d5673 6
d5801 8
d6372 1
a6372 1
	ToAlternate(xw);
d6376 1
a6376 1
ToAlternate(XtermWidget xw)
d6387 1
a6387 1
	SwitchBufs(xw, 1);
d6406 1
a6406 1
	SwitchBufs(xw, 0);
d6415 1
a6415 1
SwitchBufs(XtermWidget xw, int toBuf)
d6447 3
d7854 13
d9615 5
d9837 2
d9863 7
d9873 1
@


1.26
log
@Update to xterm 291. Tested by many.
@
text
@d1 1
a1 1
/* $XTermId: charproc.c,v 1.1283 2013/02/05 01:47:58 tom Exp $ */
d393 2
d412 1
a412 1
    Bres(XtNbackarrowKey, XtCBackarrowKey, screen.backarrow_key, DEF_BACKARO_DEL),
d3948 3
a3950 4
#ifdef DEBUG
    if (debug) {
	fprintf(stderr, "v_write called with %d bytes (%d left over)",
		len, v_bufptr - v_bufstr);
d3954 1
a3954 2
    }
#endif
d3985 4
a3988 5
#ifdef DEBUG
		if (debug)
		    fprintf(stderr, "moving data down %d\n",
			    v_bufstr - v_buffer);
#endif
d3999 1
a3999 2
#ifdef DEBUG
		    if (debug)
d4002 1
a4002 1
#endif
d4053 1
a4053 2
#ifdef DEBUG
	    if (debug)
d4055 1
a4055 1
#endif
d4058 5
a4062 5
#ifdef DEBUG
	if (debug)
	    fprintf(stderr, "write called with %d, wrote %d\n",
		    v_bufptr - v_bufstr <= MAX_PTY_WRITE ?
		    v_bufptr - v_bufstr : MAX_PTY_WRITE,
d4064 1
a4064 1
#endif
d4084 1
a4084 2
#ifdef DEBUG
	    if (debug)
d4086 1
a4086 1
#endif
d6528 1
a6528 4
#ifdef DEBUG
    if (debug)
	fputs("Expose\n", stderr);
#endif /* DEBUG */
d7423 1
d8008 2
a8009 2
    while (screen->saved_fifo-- > 0) {
	deleteScrollback(screen, 0);
@


1.25
log
@Update to xterm 287. tested by mpi@@ and krw@@.
@
text
@d1 1
a1 1
/* $XTermId: charproc.c,v 1.1270 2012/11/25 19:25:10 Balazs.Kezes Exp $ */
d4 1
a4 1
 * Copyright 1999-2011,2012 by Thomas E. Dickey
d1771 1
a1771 1
	    if (nparam < NPARAM) {
d3935 10
a3944 5
    if (v_bufstr == NULL && len > 0) {
	v_buffer = (Char *) XtMalloc((Cardinal) len);
	v_bufstr = v_buffer;
	v_bufptr = v_buffer;
	v_bufend = v_buffer + len;
d4355 1
a4355 1
	    Cleanup(0);
d5945 1
d6115 2
a6116 1
	    report_win_label(xw, 'L', get_icon_label(xw));
d6123 2
a6124 1
	    report_win_label(xw, 'l', get_window_label(xw));
d6320 1
a6320 1
    if ((screen->unparse_len + 2) >= sizeof(screen->unparse_bfr))
d7032 1
a7032 1
    while (*source != '\0') {
d7264 1
a7264 1
    TScreenOf(wnew)->mouse_button = -1;
d7974 1
a7975 1
	    TRACE(("freed " #name ": %p\n", (const void *) name)); \
d9239 1
a9239 1
    if ((flags & TERM_COLOR_FLAGS(xw)) == BG_COLOR
d9257 18
d10124 3
a10126 1
    if ((xw == 0) || *type != XA_STRING || *format != 8) {
d10158 1
d10191 1
a10191 1
    unsigned int atomCount = 0;
d10203 2
a10204 1
	if (strcmp(atom_name, XmuNameOfAtom(*pAtom)) == 0)
d10206 1
d10211 2
@


1.24
log
@Update to xterm 279. Tested by krw@@, mpi@@, shadchin@@.
@
text
@d1 1
a1 1
/* $XTermId: charproc.c,v 1.1205 2012/05/10 10:51:37 tom Exp $ */
d105 4
d110 1
a188 1
static int nparam;
d190 9
a198 1
static int param[NPARAM];
d400 1
a400 1
    Bres(XtNaltSendsEscape, XtCAltSendsEscape, screen.alt_sends_esc, False),
d406 1
d410 1
a410 1
    Bres(XtNbackarrowKey, XtCBackarrowKey, screen.backarrow_key, True),
d416 1
d436 1
a436 1
    Bres(XtNmetaSendsEscape, XtCMetaSendsEscape, screen.meta_sends_esc, False),
d528 1
a528 1
    Bres("activeIcon", "ActiveIcon", misc.active_icon, False),
d639 2
d1187 3
d1257 18
d1366 215
d1584 1
a1584 1
    int result = (nparam > which) ? param[which] : 0;
d1593 1
a1593 1
    int result = (nparam > which) ? param[which] : 0;
d1599 41
d1646 1
a1646 1
#define ResetState(sp) (sp)->parsestate = (sp)->groundtable
d1681 1
a1681 2
    int row;
    int col;
d1683 1
d1698 3
a1700 2
	if (c >= 0x300 && screen->wide_chars
	    && my_wcwidth((int) c) == 0
d1703 3
d1708 6
d1721 2
a1722 5
		&& !IsCellCombined(screen,
				   screen->last_written_row,
				   screen->last_written_col)) {
		prev = (int) XTERM_CELL(screen->last_written_row,
					screen->last_written_col);
d1725 3
a1727 3
		       prev, my_wcwidth(prev),
		       (int) c, my_wcwidth((int) c),
		       test, my_wcwidth(test)));
d1736 6
a1741 4
	    if (test != -1 && my_wcwidth(test) == my_wcwidth(prev)) {
		putXtermCell(screen,
			     screen->last_written_row,
			     screen->last_written_col, test);
d1743 5
a1747 3
		addXtermCombining(screen,
				  screen->last_written_row,
				  screen->last_written_col, c);
d1750 5
a1754 5
	    if (!screen->scroll_amt)
		ScrnUpdate(xw,
			   screen->last_written_row,
			   screen->last_written_col, 1, 1, 1);
	    continue;
d1771 4
a1774 2
	    if (nparam < NPARAM)
		param[nparam++] = (int) (c & 0x7f) - 32;
d1778 1
a1778 5
	    if ((row = param[0]) < 0)
		row = 0;
	    if ((col = param[1]) < 0)
		col = 0;
	    CursorSet(screen, row, col, xw->flags);
d1780 2
a1781 2
	    param[0] = 0;
	    param[1] = 0;
d1983 1
d1986 50
d2092 1
a2092 1
	    nparam = 0;
d2117 1
a2117 2
	    if ((count = param[0]) == DEFAULT)
		count = 1;
d2126 1
a2126 2
	    if ((count = param[0]) == DEFAULT)
		count = 1;
d2214 4
a2217 5
		if ((row = param[nparam - 1]) == DEFAULT)
		    row = 0;
		param[nparam - 1] = (10 * row) + ((int) c - '0');
		if (param[nparam - 1] > 65535)
		    param[nparam - 1] = 65535;
d2225 4
a2228 2
	    if (nparam < NPARAM)
		param[nparam++] = DEFAULT;
d2233 24
d2274 1
a2274 3
	    if ((row = param[0]) < 1)
		row = 1;
	    InsertChar(xw, (unsigned) row);
d2280 1
a2280 3
	    if ((row = param[0]) < 1)
		row = 1;
	    CursorUp(screen, row);
d2286 1
a2286 3
	    if ((row = param[0]) < 1)
		row = 1;
	    CursorDown(screen, row);
d2292 1
a2292 3
	    if ((col = param[0]) < 1)
		col = 1;
	    CursorForward(xw, col);
d2298 1
a2298 3
	    if ((col = param[0]) < 1)
		col = 1;
	    CursorBack(xw, col);
d2307 1
a2307 5
	    if ((row = param[0]) < 1)
		row = 1;
	    if (nparam < 2 || (col = param[1]) < 1)
		col = 1;
	    CursorSet(screen, row - 1, col - 1, xw->flags);
d2313 1
a2313 3
	    if ((row = param[0]) < 1)
		row = 1;
	    CursorSet(screen, row - 1, CursorCol(xw), xw->flags);
d2319 1
a2319 3
	    if ((col = param[0]) < 1)
		col = 1;
	    CursorSet(screen, CursorRow(xw), col - 1, xw->flags);
d2325 4
a2328 3
	    if ((row = param[0]) < 1)
		row = 1;
	    CursorSet(screen, CursorRow(xw) + row, CursorCol(xw), xw->flags);
d2334 4
a2337 3
	    if ((col = param[0]) < 1)
		col = 1;
	    CursorSet(screen, CursorRow(xw), CursorCol(xw) + col, xw->flags);
d2353 2
a2354 1
	    do_erase_display(xw, param[0], OFF_PROTECT);
d2360 1
a2360 1
	    do_erase_line(xw, param[0], OFF_PROTECT);
d2367 1
a2367 1
	    ClearRight(xw, param[0] < 1 ? 1 : param[0]);
d2373 2
a2374 3
	    if ((row = param[0]) < 1)
		row = 1;
	    InsertLine(xw, row);
d2380 2
a2381 3
	    if ((row = param[0]) < 1)
		row = 1;
	    DeleteLine(xw, row);
d2387 1
a2387 3
	    if ((row = param[0]) < 1)
		row = 1;
	    DeleteChar(xw, (unsigned) row);
d2397 1
a2397 1
	    if (nparam > 1 || param[0] == 0) {
d2405 1
a2405 1
		start.col = param[1] - 1;
d2407 1
a2407 1
			   param[0],
d2409 1
a2409 1
			   param[3] - 1, param[4] - 2);
d2413 1
a2413 3
		if ((count = param[0]) < 1)
		    count = 1;
		RevScroll(xw, count);
d2429 1
a2429 1
	    param[0] = DEFAULT;	/* Default ID parameter */
d2433 1
a2433 1
	    if (param[0] <= 0) {	/* less than means DEFAULT */
d2438 6
a2443 6
		/* The first param corresponds to the highest
		 * operating level (i.e., service level) of the
		 * emulation.  A DEC terminal can be setup to
		 * respond with a different DA response, but
		 * there's no control sequence that modifies this.
		 * We set it via a resource.
d2472 4
d2493 1
a2493 1
	    if (param[0] <= 0) {	/* less than means DEFAULT */
d2498 35
a2532 3
		if (screen->terminal_id >= 200)
		    reply.a_param[count++] = 1;		/* VT220 */
		else
d2534 1
d2547 2
a2548 2
	    if ((screen->terminal_id >= 400)
		&& (param[0] <= 0)) {	/* less than means DEFAULT */
d2561 1
a2561 1
	    if ((row = param[0]) <= 0)	/* less than means default */
d2563 1
a2563 1
	    else if (row == 3)
d2581 3
a2583 1
	    for (row = 0; row < nparam; ++row) {
d2585 1
a2585 1
		    Mark_XMC(xw, param[row]);
d2587 22
a2608 2
		TRACE(("CASE_SGR %d\n", param[row]));
		switch (param[row]) {
d2681 1
a2681 1
			xw->sgr_foreground = (param[row] - 30);
d2687 2
a2688 3
		    /* This is more complicated than I'd
		       like, but it should properly eat all
		       the parameters for unsupported modes
d2691 4
a2694 16
			row++;
			if (row < nparam) {
			    switch (param[row]) {
			    case 5:
				row++;
				if (row < nparam &&
				    param[row] < NUM_ANSI_COLORS) {
				    xw->sgr_foreground = param[row];
				    xw->sgr_extended = True;
				    setExtendedFG(xw);
				}
				break;
			    default:
				row += 7;
				break;
			    }
d2712 1
a2712 1
			xw->sgr_background = (param[row] - 40);
d2718 3
a2720 15
			row++;
			if (row < nparam) {
			    switch (param[row]) {
			    case 5:
				row++;
				if (row < nparam &&
				    param[row] < NUM_ANSI_COLORS) {
				    xw->sgr_background = param[row];
				    setExtendedBG(xw);
				}
				break;
			    default:
				row += 7;
				break;
			    }
d2738 1
a2738 1
			xw->sgr_foreground = (param[row] - 90 + 8);
d2759 1
a2759 1
			xw->sgr_background = (param[row] - 100 + 8);
d2781 1
a2781 1
	    switch (param[0]) {
d2856 1
a2856 1
		    reply.a_param[count++] = (ParmType) param[1];	/* PID */
d2889 1
a2889 1
	    xtermMediaControl(xw, param[0], False);
d2895 1
a2895 1
	    xtermMediaControl(xw, param[0], True);
d2918 2
a2919 3
		if ((top = param[0]) < 1)
		    top = 1;
		if (nparam < 2 || (bot = param[1]) == DEFAULT
d2936 2
a2937 3
		if ((row = param[0]) == DEFAULT)
		    row = 0;
		if (row == 0 || row == 1) {
d2941 1
a2941 1
		    reply.a_param[0] = (ParmType) (row + 2);
d2994 1
a2994 1
	case CASE_DECSC:
d3000 2
a3001 3
		if ((left = param[0]) < 1)
		    left = 1;
		if (nparam < 2 || (right = param[1]) == DEFAULT
d3010 1
a3010 1
		TRACE(("CASE_DECSC - save cursor\n"));
a3011 1
		ResetState(sp);
d3013 1
d3016 7
d3024 2
a3025 1
	    TRACE(("CASE_DECRC - restore cursor\n"));
d3064 1
a3064 3
		switch (param[0]) {
		case 0:
		case 1:
d3066 2
a3067 2
		    /* blinking block */
		    screen->cursor_underline = False;
d3069 1
d3071 9
a3079 3
		case 2:
		    /* steady block */
		    screen->cursor_underline = False;
d3081 1
d3083 1
a3083 3
		case 3:
		    /* blinking underline */
		    screen->cursor_underline = True;
d3085 1
d3087 1
a3087 3
		case 4:
		    /* steady underline */
		    screen->cursor_underline = True;
d3089 1
d3111 2
a3112 1
		    switch (param[count]) {
d3120 3
a3122 1
			xtermShowLED(screen, (Cardinal) param[count], True);
d3127 3
a3129 1
			xtermShowLED(screen, (Cardinal) (param[count] - 20), True);
d3181 5
a3185 1
	    TRACE(("CASE_DECSCL(%d,%d)\n", param[0], param[1]));
d3187 6
a3192 1
		if (param[0] >= 61 && param[0] <= 65) {
d3201 2
a3202 2
		    screen->vtXX_level = param[0] - 60;
		    if (param[0] > 61) {
d3221 1
a3221 1
	    if (param[0] <= 0 || param[0] == 2) {
d3224 1
a3224 1
	    } else if (param[0] == 1) {
d3233 1
a3233 1
	    do_erase_display(xw, param[0], DEC_PROTECT);
d3239 1
a3239 1
	    do_erase_line(xw, param[0], DEC_PROTECT);
d3319 1
a3319 3
	    if ((count = param[0]) < 1)
		count = 1;
	    xtermScroll(xw, count);
d3325 1
a3325 3
	    if ((count = param[0]) < 1)
		count = 1;
	    xtermScrollLR(xw, count, True);
d3331 1
a3331 3
	    if ((count = param[0]) < 1)
		count = 1;
	    xtermScrollLR(xw, count, False);
d3339 1
a3339 3
		if ((count = param[0]) < 1)
		    count = 1;
		xtermColScroll(xw, count, True, screen->cur_col);
d3348 1
a3348 3
		if ((count = param[0]) < 1)
		    count = 1;
		xtermColScroll(xw, count, False, screen->cur_col);
d3378 1
a3378 1
	    CursorPrevLine(xw, param[0]);
d3384 1
a3384 1
	    CursorNextLine(xw, param[0]);
d3421 2
a3422 2
	    nparam = 1;
	    param[0] = DEFAULT;
d3446 1
a3446 1
		if ((screen->loc_filter_top = param[0]) < 1)
d3448 2
a3449 1
		if (nparam < 2 || (screen->loc_filter_left = param[1]) < 1)
d3451 2
a3452 1
		if (nparam < 3 || (screen->loc_filter_bottom = param[2]) < 1)
d3454 2
a3455 1
		if (nparam < 4 || (screen->loc_filter_right = param[3]) < 1)
d3464 1
a3464 1
	    if (param[0] <= 0 || param[0] > 2) {
d3471 1
a3471 1
		if (param[0] == 2) {
d3476 1
a3476 1
		if (nparam < 2 || param[1] != 1) {
d3489 1
a3489 2
		switch (param[count]) {
		case DEFAULT:
d3514 1
a3514 1
	    if (param[0] < 2) {
d3546 1
a3546 1
		xtermCheckRect(xw, nparam, param, &checksum);
d3549 1
a3549 1
		reply.a_param[count++] = (ParmType) param[1];	/* PID */
d3562 2
a3563 2
		xtermParseRect(xw, nparam, param, &myRect);
		ScrnCopyRectangle(xw, &myRect, nparam - 5, param + 5);
d3571 1
a3571 1
		xtermParseRect(xw, nparam, param, &myRect);
d3579 2
d3583 4
a3586 4
		    && ((param[0] >= 32 && param[0] <= 126)
			|| (param[0] >= 160 && param[0] <= 255))) {
		    xtermParseRect(xw, nparam - 1, param + 1, &myRect);
		    ScrnFillRectangle(xw, &myRect, param[0], xw->flags, True);
d3595 1
a3595 1
		xtermParseRect(xw, nparam > 4 ? 4 : nparam, param, &myRect);
d3603 1
a3603 1
	    screen->cur_decsace = param[0];
d3610 2
a3611 2
		xtermParseRect(xw, nparam > 4 ? 4 : nparam, param, &myRect);
		ScrnMarkRectangle(xw, &myRect, False, nparam - 4, param + 4);
d3619 2
a3620 2
		xtermParseRect(xw, nparam > 4 ? 4 : nparam, param, &myRect);
		ScrnMarkRectangle(xw, &myRect, True, nparam - 4, param + 4);
d3627 1
a3627 1
	    do_rpm(xw, nparam, param);
d3633 1
a3633 1
	    do_decrpm(xw, nparam, param);
d3661 1
a3661 1
	    if (screen->terminal_id >= 200) {
d3669 1
a3669 1
	    if (screen->terminal_id >= 200) {
d3703 1
a3703 1
		count = (param[0] < 1) ? 1 : param[0];
d3792 6
a3797 1
		set_mod_fkeys(xw, param[0], nparam > 1 ? param[1] : DEFAULT, True);
d3799 2
a3800 2
		for (row = 1; row <= 5; ++row)
		    set_mod_fkeys(xw, row, DEFAULT, True);
d3805 2
a3806 2
	    if (nparam >= 1 && param[0] != DEFAULT) {
		set_mod_fkeys(xw, param[0], -1, False);
d3814 2
a3815 2
	    if (nparam >= 1 && param[0] != DEFAULT) {
		screen->pointer_mode = param[0];
d3826 2
a3827 2
		    if (param[n] != DEFAULT)
			screen->title_modes |= (1 << param[n]);
d3840 2
a3841 2
		    if (param[n] != DEFAULT)
			screen->title_modes &= ~(1 << param[n]);
d3855 1
a3855 1
	    switch ((nparam >= 1) ? param[0] : DEFAULT) {
d3877 1
a3877 1
	    switch ((nparam >= 1) ? param[0] : DEFAULT) {
a3883 1
	    case DEFAULT:
d4216 3
d4250 15
a4264 1
#if defined(HAVE_SCHED_YIELD)
d4276 1
a4276 1
		if (i > 0) {
d4351 10
d4410 1
a4410 1
    if (input->xic
d4496 3
a4498 1
	Boolean need_wrap = False;
d4502 13
a4514 6
	if (screen->do_wrap) {
	    screen->do_wrap = False;
	    if ((xw->flags & WRAPAROUND)) {
		WrapLine(xw);
		width_available = right + 1 - screen->cur_col;
		next_col = screen->cur_col;
a4515 1
	}
d4517 6
a4522 5
	/*
	 * This can happen with left/right margins...
	 */
	if (width_available <= 0)
	    break;
d4524 11
a4534 9
	while (width_here <= width_available && chars_chomped < (len - offset)) {
	    if (!screen->utf8_mode
		|| (screen->vt100_graphics && charset == '0'))
		last_chomp = 1;
	    else
		last_chomp = my_wcwidth((int) buf[chars_chomped + offset]);
	    width_here += last_chomp;
	    chars_chomped++;
	}
d4536 15
a4550 6
	if (width_here > width_available) {
	    if (last_chomp > right + 1)
		break;		/* give up - it is too big */
	    if (chars_chomped-- == 0) {
		/* This can happen with left/right margins... */
		break;
d4552 7
a4558 2
	    width_here -= last_chomp;
	    if (chars_chomped > 0) {
d4561 4
a4564 5
	} else if (width_here == width_available) {
	    need_wrap = True;
	} else if (chars_chomped != (len - offset)) {
	    need_wrap = True;
	}
d4566 7
a4572 14
	/*
	 * Split the wide characters back into separate arrays of 8-bit
	 * characters so we can use the existing interface.
	 *
	 * FIXME:  If we rewrote this interface, it would involve
	 * rewriting all of the memory-management for the screen
	 * buffers (perhaps this is simpler).
	 */
	if (chars_chomped != 0 && next_col <= screen->max_col) {
	    WriteText(xw, buf + offset, chars_chomped);
	}
	next_col += width_here;
	screen->do_wrap = need_wrap;
    }
d4689 1
a4689 1
			 * Window manager still may be using the old values. 
d4753 1
a4753 1
	switch (param[i]) {
d4853 1
d4907 4
a4910 2
	TRACE(("%s %d\n", IsSM()? "DECSET" : "DECRST", param[i]));
	switch ((DECSET_codes) param[i]) {
d4934 1
a4934 1
		nparam = 0;	/* ignore the remaining params, if any */
d4949 1
a4949 1
		    xw->flags &= ~LEFT_RIGHT;
d5027 1
d5079 2
a5080 4
	    } else if (xw->misc.tiXtraScroll) {
		if (IsSM()) {
		    xtermScroll(xw, screen->max_row);
		}
d5091 1
a5091 1
			&& (param[i] == 1047))
d5095 2
a5096 4
	    } else if (xw->misc.tiXtraScroll) {
		if (IsSM()) {
		    xtermScroll(xw, screen->max_row);
		}
d5111 1
a5111 1
	    if (screen->terminal_id >= 400) {	/* VT420 */
d5122 1
a5122 1
	    if (screen->terminal_id >= 500) {	/* VT510 */
d5162 2
a5163 2
		screen->extend_coords = param[i];
	    } else if (screen->extend_coords == param[i]) {
d5167 3
d5289 4
a5292 2
	TRACE(("savemodes %d\n", param[i]));
	switch ((DECSET_codes) param[i]) {
d5412 3
d5514 4
a5517 2
	TRACE(("restoremodes %d\n", param[i]));
	switch ((DECSET_codes) param[i]) {
d5571 3
a5573 2
	    really_set_mousemode(xw, screen->send_mouse_pos,
				 screen->send_mouse_pos != MOUSE_OFF);
d5614 2
a5615 1
		TEK4014_ACTIVE(xw) = screen->save_modes[DP_DECTEK];
d5661 2
a5662 4
	    } else if (xw->misc.tiXtraScroll) {
		if (screen->save_modes[DP_X_ALTSCRN]) {
		    xtermScroll(xw, screen->max_row);
		}
d5690 3
a5692 2
	    really_set_mousemode(xw, screen->send_mouse_pos,
				 screen->send_mouse_pos != MOUSE_OFF);
d5711 3
d5939 1
d5941 2
a5942 2
    TRACE(("window_ops %d\n", param[0]));
    switch (param[0]) {
d5976 1
a5976 1
	    RequestResize(xw, param[1], param[2], False);
d6003 1
a6003 1
	    RequestResize(xw, param[1], param[2], True);
d6023 3
a6025 3
	    XGetWindowAttributes(screen->display,
				 VWindow(screen),
				 &win_attrs);
d6041 3
a6043 3
	    XGetWindowAttributes(screen->display,
				 WMFrameWindow(xw),
				 &win_attrs);
a6058 3
	    XGetWindowAttributes(screen->display,
				 VWindow(screen),
				 &win_attrs);
a6062 4
	    /*FIXME: find if dtterm uses
	     *    win_attrs.height or Height
	     *      win_attrs.width  or Width
	     */
d6090 1
a6090 4
	    if (!QueryMaximize(xw, &root_height, &root_width)) {
		root_height = 0;
		root_width = 0;
	    }
d6183 2
a6184 2
	    if (param[0] >= 24)
		RequestResize(xw, param[0], -1, True);
d6422 9
d6438 1
d6601 2
a6602 2
	XGetWindowAttributes(XtDisplay(xw),
			     RootWindowOfScreen(XtScreen(xw)), &attrs);
d6731 2
d6734 2
a6735 2
    TScreenOf(target)->Tcolors[offset] = TScreenOf(source)->Tcolors[offset];
    TScreenOf(target)->Tcolors[offset].mode = False;
d6737 2
a6738 2
    if ((name = x_strtrim(TScreenOf(target)->Tcolors[offset].resource)) != 0)
	TScreenOf(target)->Tcolors[offset].resource = name;
d6741 1
a6741 1
	TScreenOf(target)->Tcolors[offset].value = target->dft_foreground;
d6743 3
a6745 4
	TScreenOf(target)->Tcolors[offset].value =
	    ((offset == TEXT_FG || offset == TEXT_BG)
	     ? target->dft_foreground
	     : TScreenOf(target)->Tcolors[TEXT_FG].value);
d6747 3
a6749 4
	TScreenOf(target)->Tcolors[offset].value =
	    ((offset == TEXT_FG || offset == TEXT_BG)
	     ? target->dft_background
	     : TScreenOf(target)->Tcolors[TEXT_BG].value);
d6755 4
a6758 1
	    TScreenOf(target)->Tcolors[offset].value = temp.colors[offset];
d6761 25
a6785 1
    return TScreenOf(target)->Tcolors[offset].value;
d6790 1
d7154 9
d7207 5
d7243 1
d7283 4
a7286 1
    init_Bres(screen.cursor_underline);
d7311 1
a7353 4
    wnew->misc.num_lock = 0;
    wnew->misc.alt_mods = 0;
    wnew->misc.meta_mods = 0;
    wnew->misc.other_mods = 0;
d7401 1
d7488 4
a7491 1
    init_Bres(misc.active_icon);
d7499 1
d7623 1
a7623 11
	Display *display = TScreenOf(wnew)->display;
	XVisualInfo myTemplate, *visInfoPtr;
	int numFound;

	myTemplate.visualid = XVisualIDFromVisual(DefaultVisual(display,
								XDefaultScreen(display)));
	visInfoPtr = XGetVisualInfo(display, (long) VisualIDMask,
				    &myTemplate, &numFound);
	if (visInfoPtr == 0
	    || numFound == 0
	    || visInfoPtr->depth <= 1) {
a7625 2
	} else {
	    XFree(visInfoPtr);
d7720 1
a7720 1
    wnew->misc.render_font =
d7723 1
a7723 1
    if (wnew->misc.render_font == erDefault) {
d7730 1
a7730 1
	    wnew->misc.render_font = erTrue;
d7735 1
a7735 1
    if (wnew->misc.render_font) {
d7737 1
a7737 1
	    wnew->misc.render_font = False;
d7920 1
d7967 1
a7967 1
	    TRACE(("freed " #name ": %p\n", name)); \
d7983 1
a7983 1
    if (input->xim) {
d8174 115
d8306 20
d8428 1
a8428 1
    if (term->screen.fullscreen) {
d8509 20
d8561 8
a8568 1
    if (xw->misc.active_icon && screen->fnt_icon.fs) {
d8600 3
d8630 1
a8630 1
	xw->misc.active_icon = False;
d8675 1
a8675 1
    screen->do_wrap = False;
d8686 5
d8730 2
a8731 2

    input->xic = NULL;
d9260 1
a9260 1
    filled = (screen->select || screen->always_highlight) && !screen->cursor_underline;
d9354 2
a9355 1
	       (screen->cursor_underline ? "underline" : "box"),
d9362 1
a9362 1
	if (screen->cursor_underline) {
d9365 1
a9365 1
	     * too complicated since the underline and the text-cell use
d9367 1
a9367 1
	     * underline on top of it.
d9400 1
a9400 1
	if (screen->cursor_underline) {
d9407 9
d9442 1
a9442 1
		XDrawLines(screen->display, VWindow(screen), outlineGC,
@


1.23
log
@Update to xterm 278. Tested by mpi@@, shadchin@@
@
text
@d1 1
a1 1
/* $XTermId: charproc.c,v 1.1161 2012/01/19 00:22:08 tom Exp $ */
d4 1
a4 1
 * Copyright 1999-2010,2011 by Thomas E. Dickey
d165 1
d670 1
d1070 1
a1070 1
    TRACE(("set_ansi_conformance(%d) terminal_id %d, ansi_level %d\n",
d1072 1
d1115 27
d1377 7
a1389 2
    int top;
    int bot;
d1408 1
a1408 1
	    int prev, precomposed;
d1412 20
a1431 7
	    prev = (int) XTERM_CELL(screen->last_written_row,
				    screen->last_written_col);
	    precomposed = do_precomposition(prev, (int) c);
	    TRACE(("do_precomposition (U+%04X [%d], U+%04X [%d]) -> U+%04X [%d]\n",
		   prev, my_wcwidth(prev),
		   (int) c, my_wcwidth((int) c),
		   precomposed, my_wcwidth(precomposed)));
d1436 1
a1436 1
	    if (precomposed != -1 && my_wcwidth(precomposed) == my_wcwidth(prev)) {
d1439 1
a1439 1
			     screen->last_written_col, precomposed);
d1723 2
a1724 2
	    /* CR */
	    CarriageReturn(screen);
d1749 1
d1756 1
a1756 1
		CarriageReturn(screen);
d1762 1
d1772 1
d1924 1
a1924 1
	    CursorForward(screen, col);
d1950 1
a1950 1
	    TRACE(("CASE_VPA - vertical position\n"));
d1953 1
a1953 1
	    CursorSet(screen, row - 1, screen->cur_col, xw->flags);
d1958 1
a1958 1
	    TRACE(("CASE_HPA - horizontal position\n"));
d1961 17
a1977 1
	    CursorSet(screen, screen->cur_row, col - 1, xw->flags);
d2080 1
a2080 1
		reply.a_type = ANSI_CSI;
d2136 1
a2136 1
		reply.a_type = ANSI_CSI;
d2385 1
a2385 1
	    TRACE(("CASE_CPR - cursor position\n"));
d2387 1
a2387 1
	    reply.a_type = ANSI_CSI;
d2394 1
d2399 4
d2404 1
a2404 1
		/* DECXCPR (with page=0) */
d2407 4
d2414 3
a2416 2
		/* printer status */
		if (screen->terminal_id >= 200) {	/* VT220 */
d2421 3
a2423 2
		/* UDK status */
		if (screen->terminal_id >= 200) {	/* VT220 */
d2428 3
a2430 2
		/* keyboard status */
		if (screen->terminal_id >= 200) {	/* VT220 */
d2433 1
a2433 1
		    if (screen->terminal_id >= 400) {
d2440 3
a2442 2
		/* Locator status */
		if (screen->terminal_id >= 200) {	/* VT220 */
d2450 37
d2526 16
a2541 11
	    if ((top = param[0]) < 1)
		top = 1;
	    if (nparam < 2 || (bot = param[1]) == DEFAULT
		|| bot > MaxRows(screen)
		|| bot == 0)
		bot = MaxRows(screen);
	    if (bot > top) {
		if (screen->scroll_amt)
		    FlushScroll(xw);
		set_tb_margins(screen, top - 1, bot - 1);
		CursorSet(screen, 0, 0, xw->flags);
a2542 1
	    ResetState(sp);
d2551 1
a2551 1
		    reply.a_type = ANSI_CSI;
d2593 1
a2593 1
	    set_tb_margins(screen, 0, screen->max_row);
d2608 20
a2627 3
	    TRACE(("CASE_DECSC - save cursor\n"));
	    CursorSave(xw);
	    ResetState(sp);
d2666 1
a2666 1
		Boolean blinks = screen->cursor_blink;
d2700 2
a2701 1
		    SetCursorBlink(screen, blinks);
d2746 5
a2750 1
		screen->vtXX_level = screen->vt52_save_level;
d2779 21
a2799 18
	    if (param[0] >= 61 && param[0] <= 65) {
		/*
		 * VT300, VT420, VT520 manuals claim that DECSCL does a hard
		 * reset (RIS).  VT220 manual states that it is a soft reset.
		 * Perhaps both are right (unlikely).  Kermit says it's soft.
		 */
		ReallyReset(xw, False, False);
		init_parser(xw, sp);
		screen->vtXX_level = param[0] - 60;
		if (param[0] > 61) {
		    switch (zero_if_default(1)) {
		    case 1:
			show_8bit_control(False);
			break;
		    case 0:
		    case 2:
			show_8bit_control(True);
			break;
d2809 1
a2809 1
	    if (param[0] <= 0 || param[0] == 2)
d2811 2
a2812 1
	    else if (param[0] == 1)
d2814 2
d2931 2
a2932 1
	    if (screen->terminal_id >= 400) {
d2942 2
a2943 1
	    if (screen->terminal_id >= 400) {
d2953 1
a2953 1
	    if (screen->terminal_id >= 400) {
d2961 1
a2961 1
	    if (screen->terminal_id >= 400) {
d2976 1
a2976 1
	    CursorPrevLine(screen, param[0]);
d2982 1
a2982 1
	    CursorNextLine(screen, param[0]);
d2989 1
a2989 1
	    CarriageReturn(screen);
d3137 18
d3255 4
a3258 2
	    show_8bit_control(False);
	    ResetState(sp);
d3263 1
d3265 2
a3266 2
	    if (screen->vtXX_level <= 1)
		break;
d3268 3
a3270 2
	    show_8bit_control(True);
	    ResetState(sp);
d4002 1
a4002 1
	set_cur_col(screen, 0);
d4024 1
d4026 7
d4057 1
a4057 1
	int width_available = MaxCols(screen) - screen->cur_col;
d4067 1
a4067 1
		width_available = MaxCols(screen) - screen->cur_col;
d4072 6
d4089 1
a4089 1
	    if (last_chomp > MaxCols(screen))
d4091 4
a4094 1
	    chars_chomped--;
d4127 2
a4184 5
    static char *icon_name;
    static Arg args[] =
    {
	{XtNiconName, (XtArgVal) & icon_name}
    };
a4185 1
    TScreen *screen = TScreenOf(xw);
d4190 1
a4190 17
#if OPT_ZICONBEEP
	if (screen->zIconBeep_flagged) {
	    screen->zIconBeep_flagged = False;
	    icon_name = NULL;
	    XtGetValues(toplevel, args, XtNumber(args));
	    if (icon_name != NULL) {
		char *buf = CastMallocN(char, strlen(icon_name));
		if (buf == NULL) {
		    screen->zIconBeep_flagged = True;
		    return;
		}
		strcpy(buf, icon_name + 4);
		ChangeIconName(xw, buf);
		free(buf);
	    }
	}
#endif /* OPT_ZICONBEEP */
d4239 1
a4239 1
				   screen->fullVwin.fullwidth,
d4242 1
a4242 1
						+ screen->fullVwin.fullheight),
d4345 97
d4453 2
a4454 2
	switch (param[i]) {
	case 1:		/* DECCKM                       */
d4458 1
a4458 1
	case 2:		/* DECANM - ANSI/VT52 mode      */
a4470 1
		screen->vt52_save_level = screen->vtXX_level;
d4481 1
a4481 1
	case 3:		/* DECCOLM                      */
d4483 2
a4484 1
		ClearScreen(xw);
d4491 4
d4497 1
a4497 1
	case 4:		/* DECSCLM (slow scroll)        */
d4507 1
a4507 1
	case 5:		/* DECSCNM                      */
d4515 1
a4515 1
	case 6:		/* DECOM                        */
d4520 1
a4520 1
	case 7:		/* DECAWM                       */
d4524 1
a4524 1
	case 8:		/* DECARM                       */
d4530 1
a4530 1
	case SET_X10_MOUSE:	/* MIT bogus sequence           */
d4535 1
a4535 1
	case 10:		/* rxvt */
d4540 1
a4540 1
	case 12:		/* att610: Start/stop blinking cursor */
d4543 1
a4543 1
		SetCursorBlink(screen, screen->cursor_blink);
d4547 1
a4547 1
	case 18:		/* DECPFF: print form feed */
d4550 1
a4550 1
	case 19:		/* DECPEX: print extent */
d4553 1
a4553 1
	case 25:		/* DECTCEM: Show/hide cursor (VT200) */
d4556 1
a4556 1
	case 30:		/* rxvt */
d4561 1
a4561 1
	case 35:		/* rxvt */
a4564 1
	case 38:		/* DECTEK                       */
d4566 1
d4571 1
d4573 1
a4573 2
	    break;
	case 40:		/* 132 column mode              */
d4577 1
a4577 1
	case 41:		/* curses hack                  */
d4581 1
a4581 1
	case 42:		/* DECNRCM national charset (VT220) */
d4584 1
a4584 1
	case 44:		/* margin bell                  */
d4590 1
a4590 1
	case 45:		/* reverse wraparound   */
d4595 1
a4595 1
	case 46:		/* logging              */
d4611 1
a4611 1
	case 1049:		/* alternate buffer & cursor */
d4627 1
a4627 1
	case 1047:
d4629 1
a4629 1
	case 47:		/* alternate buffer */
d4645 1
a4645 1
	case 66:		/* DECNKM */
d4649 1
a4649 1
	case 67:		/* DECBKM */
d4656 17
a4672 1
	case SET_VT200_MOUSE:	/* xterm bogus sequence         */
d4676 1
a4676 1
	case SET_VT200_HIGHLIGHT_MOUSE:	/* xterm sequence w/hilite tracking */
d4680 1
a4680 1
	case SET_BTN_EVENT_MOUSE:
d4684 1
a4684 1
	case SET_ANY_EVENT_MOUSE:
d4693 1
a4693 1
	case SET_FOCUS_EVENT_MOUSE:
d4697 1
a4697 1
	case SET_EXT_MODE_MOUSE:
d4699 1
a4699 1
	case SET_SGR_EXT_MODE_MOUSE:
d4701 1
a4701 1
	case SET_URXVT_EXT_MODE_MOUSE:
d4713 1
a4713 1
	case 1010:		/* rxvt */
d4717 1
a4717 1
	case 1011:		/* rxvt */
d4721 1
a4721 1
	case 1034:
d4727 1
a4727 1
	case 1035:
d4731 1
a4731 1
	case 1036:
d4736 1
a4736 1
	case 1037:
d4741 1
a4741 1
	case 1039:
d4746 1
a4746 1
	case 1040:
d4750 1
a4750 1
	case 1041:
d4754 1
a4754 1
	case 1042:
d4758 1
a4758 1
	case 1043:
d4762 1
a4762 1
	case 1048:
d4771 1
a4771 1
	case 1050:
d4776 1
a4776 1
	case 1051:
d4781 1
a4781 1
	case 1052:
d4786 1
a4786 1
	case 1053:
d4790 1
a4790 1
	case 1060:
d4794 1
a4794 1
	case 1061:
d4799 1
a4799 1
	case SET_BUTTON1_MOVE_POINT:
d4802 1
a4802 1
	case SET_BUTTON2_MOVE_POINT:
d4805 1
a4805 1
	case SET_DBUTTON3_DELETE:
d4808 1
a4808 1
	case SET_PASTE_IN_BRACKET:
d4811 1
a4811 1
	case SET_PASTE_QUOTE:
d4814 1
a4814 1
	case SET_PASTE_LITERAL_NL:
d4833 2
a4834 2
	switch (param[i]) {
	case 1:		/* DECCKM                       */
d4837 4
a4840 1
	case 3:		/* DECCOLM                      */
d4844 1
a4844 1
	case 4:		/* DECSCLM (slow scroll)        */
d4847 1
a4847 1
	case 5:		/* DECSCNM                      */
d4850 1
a4850 1
	case 6:		/* DECOM                        */
d4853 1
a4853 1
	case 7:		/* DECAWM                       */
d4856 1
a4856 1
	case 8:		/* DECARM                       */
d4859 1
a4859 1
	case SET_X10_MOUSE:	/* mouse bogus sequence */
d4863 1
a4863 1
	case 10:		/* rxvt */
d4868 1
a4868 1
	case 12:		/* att610: Start/stop blinking cursor */
d4874 1
a4874 1
	case 18:		/* DECPFF: print form feed */
d4877 1
a4877 1
	case 19:		/* DECPEX: print extent */
d4880 1
a4880 1
	case 25:		/* DECTCEM: Show/hide cursor (VT200) */
d4883 14
a4896 1
	case 40:		/* 132 column mode              */
d4899 1
a4899 1
	case 41:		/* curses hack                  */
d4902 2
a4903 2
	case 42:		/* DECNRCM national charset (VT220) */
	    /* do nothing */
d4905 1
a4905 1
	case 44:		/* margin bell                  */
d4908 1
a4908 1
	case 45:		/* reverse wraparound   */
d4912 1
a4912 1
	case 46:		/* logging              */
d4916 1
a4916 1
	case 1047:		/* alternate buffer             */
d4918 3
a4920 1
	case 47:		/* alternate buffer             */
d4923 16
a4938 4
	case SET_VT200_MOUSE:	/* mouse bogus sequence         */
	case SET_VT200_HIGHLIGHT_MOUSE:
	case SET_BTN_EVENT_MOUSE:
	case SET_ANY_EVENT_MOUSE:
d4942 1
a4942 1
	case SET_FOCUS_EVENT_MOUSE:
d4946 1
a4946 1
	case SET_EXT_MODE_MOUSE:
d4948 1
a4948 1
	case SET_SGR_EXT_MODE_MOUSE:
d4950 1
a4950 1
	case SET_URXVT_EXT_MODE_MOUSE:
d4953 61
a5013 1
	case 1048:
d5019 1
a5019 1
	case SET_BUTTON1_MOVE_POINT:
d5022 1
a5022 1
	case SET_BUTTON2_MOVE_POINT:
d5025 1
a5025 1
	case SET_DBUTTON3_DELETE:
d5028 1
a5028 1
	case SET_PASTE_IN_BRACKET:
d5031 1
a5031 1
	case SET_PASTE_QUOTE:
d5034 1
a5034 1
	case SET_PASTE_LITERAL_NL:
d5053 2
a5054 2
	switch (param[i]) {
	case 1:		/* DECCKM                       */
d5059 4
a5062 1
	case 3:		/* DECCOLM                      */
d5064 2
a5065 1
		ClearScreen(xw);
d5076 1
a5076 1
	case 4:		/* DECSCLM (slow scroll)        */
d5086 1
a5086 1
	case 5:		/* DECSCNM                      */
d5093 1
a5093 1
	case 6:		/* DECOM                        */
d5098 1
a5098 1
	case 7:		/* DECAWM                       */
d5102 1
a5102 1
	case 8:		/* DECARM                       */
d5105 1
a5105 1
	case SET_X10_MOUSE:	/* MIT bogus sequence           */
d5107 2
d5111 1
a5111 1
	case 10:		/* rxvt */
d5117 1
a5117 1
	case 12:		/* att610: Start/stop blinking cursor */
d5120 1
a5120 1
		SetCursorBlink(screen, screen->cursor_blink);
d5124 1
a5124 1
	case 18:		/* DECPFF: print form feed */
d5127 1
a5127 1
	case 19:		/* DECPEX: print extent */
d5130 1
a5130 1
	case 25:		/* DECTCEM: Show/hide cursor (VT200) */
d5133 21
a5153 1
	case 40:		/* 132 column mode              */
d5157 1
a5157 1
	case 41:		/* curses hack                  */
d5161 4
a5164 1
	case 44:		/* margin bell                  */
d5169 1
a5169 1
	case 45:		/* reverse wraparound   */
d5174 1
a5174 1
	case 46:		/* logging              */
d5184 3
a5186 1
	case 1047:		/* alternate buffer */
d5188 1
a5188 1
	case 47:		/* alternate buffer */
d5201 24
a5224 4
	case SET_VT200_MOUSE:	/* mouse bogus sequence         */
	case SET_VT200_HIGHLIGHT_MOUSE:
	case SET_BTN_EVENT_MOUSE:
	case SET_ANY_EVENT_MOUSE:
d5226 2
d5230 1
a5230 1
	case SET_FOCUS_EVENT_MOUSE:
d5234 1
a5234 1
	case SET_EXT_MODE_MOUSE:
d5236 1
a5236 1
	case SET_SGR_EXT_MODE_MOUSE:
d5238 1
a5238 1
	case SET_URXVT_EXT_MODE_MOUSE:
d5241 1
a5241 1
	case 1048:
d5246 70
d5317 1
a5317 1
	case SET_BUTTON1_MOVE_POINT:
d5320 1
a5320 1
	case SET_BUTTON2_MOVE_POINT:
d5323 1
a5323 1
	case SET_DBUTTON3_DELETE:
d5326 1
a5326 1
	case SET_PASTE_IN_BRACKET:
d5329 1
a5329 1
	case SET_PASTE_QUOTE:
d5332 1
a5332 1
	case SET_PASTE_LITERAL_NL:
a5435 1
    reply.a_type = ANSI_ESC;
d5557 1
a5557 1
	    reply.a_type = ANSI_CSI;
d5575 1
a5575 1
	    reply.a_type = ANSI_CSI;
d5593 1
a5593 1
	    reply.a_type = ANSI_CSI;
d5612 1
a5612 1
	    reply.a_type = ANSI_CSI;
d5632 1
a5632 1
	    reply.a_type = ANSI_CSI;
d5789 14
a5802 3
	    if (i != 0)
		unparseputc(xw, ';');
	    unparseputn(xw, (unsigned int) ap->a_param[i]);
d5811 11
a5821 1
	unparseputc(xw, (char) ap->a_final);
d7220 1
d7246 1
d7461 1
a7462 1
	    TRACE(("freed " #name "\n")); \
d7517 15
d7552 3
d7596 3
d7602 1
d7644 1
d7988 1
a7988 1
    set_tb_margins(screen, 0, screen->max_row);
d8922 1
a8922 1
static Bool
d9084 1
a9084 1
    set_tb_margins(screen, 0, screen->max_row);
@


1.22
log
@Update to xterm-275. Tested by jasper@@.
@
text
@d1 1
a1 1
/* $XTermId: charproc.c,v 1.1132 2011/09/04 18:18:16 tom Exp $ */
d176 2
a177 2
#if OPT_INPUT_METHOD
static void PreeditPosition(TScreen * screen);
d344 6
d443 1
d483 1
d1078 1
a1078 1
	    screen->gsets[1] = 'B';	/* G1 is ISO Latin-1 (FIXME) */
a1299 9
minus_if_default(int which)
{
    int result = (nparam > which) ? param[which] : -1;
    if (result <= 0)
	result = -1;
    return result;
}

static int
d1572 2
a1573 3
		fprintf(stderr,
			"Cannot allocate %lu bytes for printable text\n",
			(unsigned long) new_length);
d1609 2
a1610 3
		fprintf(stderr,
			"Cannot allocate %lu bytes for string mode %d\n",
			(unsigned long) new_length, sp->string_mode);
d2764 52
d3422 1
a3422 2
		    fprintf(stderr, "%s: cannot allocate buffer space\n",
			    ProgramName);
d3594 2
a3595 2
#if OPT_INPUT_METHOD
	    PreeditPosition(screen);
d3695 2
a3696 2
#if OPT_INPUT_METHOD
	    PreeditPosition(screen);
d3787 1
a3787 1
#if OPT_INPUT_METHOD
d3792 1
a3792 1
PreeditPosition(TScreen * screen)
d3794 2
d3800 1
a3800 1
    if (screen->xic
d3803 1
a3803 1
	spot.y = (short) (CursorY(screen, screen->cur_row) + screen->fs_ascent);
d3808 2
a3809 2
				   NULL);
	XSetICValues(screen->xic, XNPreeditAttributes, list, NULL);
d4065 2
a4066 2
			 * FIXME:  Window manager still may be using the old
			 * values.  Try to fool it.
d4411 14
a4424 1
	    set_bool_mode(screen->ext_mode_mouse);
d4435 3
a4437 2
	    set_bool_mode(screen->input_eight_bits);
	    update_alt_esc();
d4630 5
a4634 1
	    DoSM(DP_X_EXT_MOUSE, screen->ext_mode_mouse);
d4805 5
a4809 1
	    DoRM(DP_X_EXT_MOUSE, screen->ext_mode_mouse);
d5008 1
a5008 1
	    RequestResize(xw, minus_if_default(1), minus_if_default(2), False);
d5035 1
a5035 1
	    RequestResize(xw, minus_if_default(1), minus_if_default(2), True);
d5918 2
a5919 2
static void
ParseOnClicks(XtermWidget wnew, XtermWidget wreq, Cardinal item)
d5938 2
a5939 2
    String res = TScreenOf(wreq)->onClick[item];
    String next = x_skip_nonblanks(res);
d5942 1
a5942 1
    TScreenOf(wnew)->selectMap[item] = NSELECTUNITS;
d5944 2
a5945 2
	if (!x_strncasecmp(table[n].name, res, (unsigned) (next - res))) {
	    TScreenOf(wnew)->selectMap[item] = table[n].code;
d5948 2
a5949 2
		TScreenOf(wnew)->selectExpr[item] = x_strtrim(next);
		TRACE(("Parsed regex \"%s\"\n", TScreenOf(wnew)->selectExpr[item]));
d5957 6
d6018 1
a6018 1
		fprintf(stderr, "Expected a number: %s\n", next);
d6039 1
a6039 1
	    fprintf(stderr, "Unrecognized keyword: %s\n", next);
d6137 8
d6310 1
d6789 16
d6949 1
a6949 1
#if OPT_INPUT_METHOD
d6951 1
a6951 1
cleanupInputMethod(TScreen * screen)
d6953 5
a6957 3
    if (screen->xim) {
	XCloseIM(screen->xim);
	screen->xim = 0;
d6989 6
d7010 3
d7014 1
a7014 1
    cleanupInputMethod(screen);
d7033 9
d7086 1
d7155 2
a7156 3
	    fprintf(stderr,
		    "%s:  unable to open font \"%s\", trying \"%s\"....\n",
		    ProgramName, myfont->f_n, use_font);
d7167 1
a7167 2
	fprintf(stderr, "%s:  unable to locate a suitable font\n",
		ProgramName);
a7419 2
#else
    screen->xic = NULL;
d7492 1
a7492 2
    if (display != XtDisplay(term))
	return;
d7494 3
a7496 1
    VTInitI18N(term);
d7504 2
a7505 1
    TScreenOf(term)->xic = NULL;
d7507 5
a7511 1
    XRegisterIMInstantiateCallback(XtDisplay(term), NULL, NULL, NULL,
d7516 42
d7559 1
a7559 1
xim_real_init(XtermWidget xw)
d7561 2
a7562 1
    TScreen *screen = TScreenOf(xw);
d7564 1
a7564 1
    char *p, *s, *t, *ns, *end, buf[32];
d7582 1
d7584 3
a7586 1
    screen->xic = NULL;
d7588 12
a7599 1
    if (xw->misc.cannot_im) {
d7603 6
a7608 3
    if (!xw->misc.input_method || !*xw->misc.input_method) {
	if ((p = XSetLocaleModifiers("")) != NULL && *p)
	    screen->xim = XOpenIM(XtDisplay(xw), NULL, NULL, NULL);
d7633 4
a7636 4
			&& (screen->xim = XOpenIM(XtDisplay(xw),
						  NULL,
						  NULL,
						  NULL)) != 0)
d7638 1
d7647 1
a7647 1
    if (screen->xim == NULL
d7650 1
a7650 1
	screen->xim = XOpenIM(XtDisplay(xw), NULL, NULL, NULL);
d7653 2
a7654 2
    if (!screen->xim) {
	fprintf(stderr, "Failed to open input method\n");
d7657 1
a7657 1
    TRACE(("VTInitI18N opened input method\n"));
d7659 1
a7659 1
    if (XGetIMValues(screen->xim, XNQueryInputStyle, &xim_styles, NULL)
d7662 2
a7663 2
	fprintf(stderr, "input method doesn't support any style\n");
	cleanupInputMethod(screen);
d7704 3
a7706 4
	fprintf(stderr,
		"input method doesn't support my preedit type (%s)\n",
		xw->misc.preedit_type);
	cleanupInputMethod(screen);
d7716 2
a7717 3
	fprintf(stderr,
		"This program doesn't support the 'OffTheSpot' preedit type\n");
	cleanupInputMethod(screen);
a7729 3
	char **missing_charset_list;
	int missing_charset_count;
	char *def_string;
a7732 2
	XFontStruct **fonts;
	char **font_name_list;
d7734 11
a7744 20
	screen->fs = XCreateFontSet(XtDisplay(xw),
				    xw->misc.f_x,
				    &missing_charset_list,
				    &missing_charset_count,
				    &def_string);
	if (screen->fs == NULL) {
	    fprintf(stderr, "Preparation of font set "
		    "\"%s\" for XIM failed.\n", xw->misc.f_x);
	    screen->fs = XCreateFontSet(XtDisplay(xw),
					DEFXIMFONT,
					&missing_charset_list,
					&missing_charset_count,
					&def_string);
	}
	if (screen->fs == NULL) {
	    fprintf(stderr, "Preparation of default font set "
		    "\"%s\" for XIM failed.\n", DEFXIMFONT);
	    cleanupInputMethod(screen);
	    xw->misc.cannot_im = True;
	    return;
a7745 16
	(void) XExtentsOfFontSet(screen->fs);
	j = (unsigned) XFontsOfFontSet(screen->fs, &fonts, &font_name_list);
	for (i = 0, screen->fs_ascent = 0; i < j; i++) {
	    if (screen->fs_ascent < (*fonts)->ascent)
		screen->fs_ascent = (*fonts)->ascent;
	}
	p_list = XVaCreateNestedList(0,
				     XNSpotLocation, &spot,
				     XNFontSet, screen->fs,
				     NULL);
	screen->xic = XCreateIC(screen->xim,
				XNInputStyle, input_style,
				XNClientWindow, XtWindow(xw),
				XNFocusWindow, XtWindow(xw),
				XNPreeditAttributes, p_list,
				NULL);
d7747 4
a7750 4
	screen->xic = XCreateIC(screen->xim, XNInputStyle, input_style,
				XNClientWindow, XtWindow(xw),
				XNFocusWindow, XtWindow(xw),
				NULL);
d7753 3
a7755 3
    if (!screen->xic) {
	fprintf(stderr, "Failed to create input context\n");
	cleanupInputMethod(screen);
d7763 6
a7768 2
	if (XSetIMValues(screen->xim, XNDestroyCallback, &destroy_cb, NULL))
	    fprintf(stderr, "Could not set destroy callback to IM\n");
d7776 6
d7788 1
a7788 1
	if (TScreenOf(xw)->xic == NULL
d7798 16
d8568 1
a8568 1
	screen->ext_mode_mouse = OFF;
d8669 1
a8676 1
    static const char errfmt[] = "%s:  %s in range string \"%s\" (position %d)\n";
d8698 1
a8698 1
		fprintf(stderr, errfmt, ProgramName, "missing number", s, i);
d8710 1
a8710 2
		fprintf(stderr, errfmt, ProgramName, "too many numbers",
			s, i);
d8727 1
a8727 2
		fprintf(stderr, errfmt, ProgramName, "bad value number",
			s, i);
d8729 1
a8729 1
		fprintf(stderr, errfmt, ProgramName, "bad range", s, i);
d8738 1
a8738 1
	    fprintf(stderr, errfmt, ProgramName, "bad character", s, i);
d8754 1
a8754 1
	fprintf(stderr, errfmt, ProgramName, "bad value number", s, i);
d8756 1
a8756 1
	fprintf(stderr, errfmt, ProgramName, "bad range", s, i);
d8760 1
d8847 2
a8848 1
    TRACE(("Handle ignore for %p\n", (void *) w));
@


1.21
log
@Update to xterm 273. Tested by marco@@, jasper@@.
@
text
@d1 1
a1 1
/* $XTermId: charproc.c,v 1.1127 2011/08/22 23:36:42 tom Exp $ */
d438 2
d3473 1
d3484 1
d3678 1
a3678 1
	if (XtAppPending(app_con)) {
d3718 1
a3718 1
	if (XtAppPending(app_con) ||
d5622 1
a5622 1
    if (XtAppPending(app_con))
d6193 6
d6939 1
a6939 1
    TRACE_FREE_LEAK(screen->printer_command);
d8443 1
a8443 1
	    if (XtAppPending(app_con))
@


1.20
log
@Update to xterm 271. Tested by shadchin@@ and ajacoutot@@
@
text
@d1 1
a1 1
/* $XTermId: charproc.c,v 1.1126 2011/07/10 23:19:26 tom Exp $ */
d5438 3
d5442 1
a5442 1
    if (resource.fullscreen == esTrue || resource.fullscreen == esAlways)
@


1.19
log
@Update to xterm 270. Tested by ajacoutot@@, shadchin@@, krw@@ and jasper@@
@
text
@d1 1
a1 1
/* $XTermId: charproc.c,v 1.1121 2011/04/24 22:57:13 tom Exp $ */
d141 3
d370 2
d419 4
a422 4
    Bres(XtNprinterAutoClose, XtCPrinterAutoClose, screen.printer_autoclose, False),
    Bres(XtNprinterExtent, XtCPrinterExtent, screen.printer_extent, False),
    Bres(XtNprinterFormFeed, XtCPrinterFormFeed, screen.printer_formfeed, False),
    Bres(XtNprinterNewLine, XtCPrinterNewLine, screen.printer_newline, True),
d446 1
a446 1
	 screen.printer_controlmode, 0),
d479 1
a479 1
    Sres(XtNprinterCommand, XtCPrinterCommand, screen.printer_command, ""),
d534 1
a534 1
    Bres(XtNbrokenStringTerm, XtCBrokenStringTerm, screen.brokenStringTerm, True),
d634 1
a634 1
    Ires(XtNprintAttributes, XtCPrintAttributes, screen.print_attributes, 1),
d1332 14
d1406 1
a1406 1
	if (screen->printer_controlmode == 2) {
d2643 2
a2644 1
		VTReset(xw, False, False);
a3278 2
    TScreen *screen;

d3281 1
a3281 8
    screen = TScreenOf(xw);
    memset(&myState, 0, sizeof(myState));
    myState.scssize = 94;	/* number of printable/nonspace ASCII */
    myState.lastchar = -1;	/* not a legal IChar */
    myState.nextstate = -1;	/* not a legal state */

    init_groundtable(screen, &myState);
    myState.parsestate = myState.groundtable;
d3460 22
d3545 2
a3546 5
	} else if (screen->cursor_set != screen->cursor_state) {
	    if (screen->cursor_set)
		ShowCursor();
	    else
		HideCursor();
d3646 2
a3647 5
	} else if (screen->cursor_set != screen->cursor_state) {
	    if (screen->cursor_set)
		ShowCursor();
	    else
		HideCursor();
d4050 3
a4052 1
#if !OPT_BLINK_TEXT
d4223 1
a4223 1
	    set_bool_mode(screen->printer_formfeed);
d4226 1
a4226 1
	    set_bool_mode(screen->printer_extent);
d4517 1
a4517 1
	    DoSM(DP_PRN_FORMFEED, screen->printer_formfeed);
d4520 1
a4520 1
	    DoSM(DP_PRN_EXTENT, screen->printer_extent);
d4670 1
a4670 1
	    DoRM(DP_PRN_FORMFEED, screen->printer_formfeed);
d4673 1
a4673 1
	    DoRM(DP_PRN_EXTENT, screen->printer_extent);
d6116 1
d6120 3
d6124 6
a6129 4
    TRACE(("   Default foreground %#lx\n", wnew->dft_foreground));
    TRACE(("   Default background %#lx\n", wnew->dft_background));
    TRACE(("   Screen foreground  %#lx\n", T_COLOR(TScreenOf(wnew), TEXT_FG)));
    TRACE(("   Screen background  %#lx\n", T_COLOR(TScreenOf(wnew), TEXT_BG)));
d6269 6
a6274 6
    init_Sres(screen.printer_command);
    init_Bres(screen.printer_autoclose);
    init_Bres(screen.printer_extent);
    init_Bres(screen.printer_formfeed);
    init_Bres(screen.printer_newline);
    init_Ires(screen.printer_controlmode);
d6276 1
a6276 1
    init_Ires(screen.print_attributes);
d8173 1
a8173 1
    if (screen->blink_timer)
d8175 5
a8179 1
    screen->blink_timer = 0;
d8324 2
a8325 2
void
VTReset(XtermWidget xw, Bool full, Bool saved)
d8456 6
@


1.18
log
@Update to xterm version 269.
Tested and ok ajacoutot@@, jasper@@, krw@@, shadchin@@
@
text
@d1 1
a1 1
/* $XTermId: charproc.c,v 1.1112 2011/02/20 00:50:46 tom Exp $ */
d361 1
d377 1
d661 2
a662 1
    Ires(XtNutf8, XtCUtf8, screen.utf8_mode, uDefault),
d1285 9
d4903 1
a4903 1
	    RequestResize(xw, zero_if_default(1), zero_if_default(2), False);
d4930 1
a4930 1
	    RequestResize(xw, zero_if_default(1), zero_if_default(2), True);
d5677 1
d5786 16
d5805 1
d6013 10
d6106 1
d6583 6
d6602 1
d6651 1
d7001 1
a7001 1
    if (TScreenOf(xw)->utf8_mode) {
d7003 1
a7003 1
	if (xtermLoadWideFonts(xw, False))
d7005 6
d7146 1
a7146 1
    TScreenOf(xw)->fullVwin.window = XtWindow(xw) =
d7251 1
a7251 1
    TScreenOf(xw)->xic = NULL;
d8918 1
a8918 1
	    if (!strcmp(table[item].name, "fullscreen"))
d8920 2
@


1.17
log
@Update to xterm 267. Tested by shadchin@@, jasper@@, ajacoutot@@.
@
text
@d1 1
a1 1
/* $XTermId: charproc.c,v 1.1091 2010/11/11 11:41:26 tom Exp $ */
d4 52
a55 52

Copyright 1999-2009,2010 by Thomas E. Dickey

                        All Rights Reserved

Permission is hereby granted, free of charge, to any person obtaining a
copy of this software and associated documentation files (the
"Software"), to deal in the Software without restriction, including
without limitation the rights to use, copy, modify, merge, publish,
distribute, sublicense, and/or sell copies of the Software, and to
permit persons to whom the Software is furnished to do so, subject to
the following conditions:

The above copyright notice and this permission notice shall be included
in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
IN NO EVENT SHALL THE ABOVE LISTED COPYRIGHT HOLDER(S) BE LIABLE FOR ANY
CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

Except as contained in this notice, the name(s) of the above copyright
holders shall not be used in advertising or otherwise to promote the
sale, use or other dealings in this Software without prior written
authorization.

Copyright 1988  The Open Group

Permission to use, copy, modify, distribute, and sell this software and its
documentation for any purpose is hereby granted without fee, provided that
the above copyright notice appear in all copies and that both that
copyright notice and this permission notice appear in supporting
documentation.

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
OPEN GROUP BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

Except as contained in this notice, the name of The Open Group shall not be
used in advertising or otherwise to promote the sale, use or other dealings
in this Software without prior written authorization from The Open Group.

*/
a134 5
typedef struct {
    const char *name;
    int code;
} FlagList;

d216 1
a216 54
static char defaultTranslations[] =
"\
          Shift <KeyPress> Prior:scroll-back(1,halfpage) \n\
           Shift <KeyPress> Next:scroll-forw(1,halfpage) \n\
         Shift <KeyPress> Select:select-cursor-start() select-cursor-end(SELECT, CUT_BUFFER0) \n\
         Shift <KeyPress> Insert:insert-selection(SELECT, CUT_BUFFER0) \n\
"
#if OPT_SCROLL_LOCK
"\
        <KeyRelease> Scroll_Lock:scroll-lock() \n\
"
#endif
#if OPT_SHIFT_FONTS
"\
    Shift~Ctrl <KeyPress> KP_Add:larger-vt-font() \n\
    Shift Ctrl <KeyPress> KP_Add:smaller-vt-font() \n\
    Shift <KeyPress> KP_Subtract:smaller-vt-font() \n\
"
#endif
"\
                ~Meta <KeyPress>:insert-seven-bit() \n\
                 Meta <KeyPress>:insert-eight-bit() \n\
                !Ctrl <Btn1Down>:popup-menu(mainMenu) \n\
           !Lock Ctrl <Btn1Down>:popup-menu(mainMenu) \n\
 !Lock Ctrl @@Num_Lock <Btn1Down>:popup-menu(mainMenu) \n\
     ! @@Num_Lock Ctrl <Btn1Down>:popup-menu(mainMenu) \n\
                ~Meta <Btn1Down>:select-start() \n\
              ~Meta <Btn1Motion>:select-extend() \n\
                !Ctrl <Btn2Down>:popup-menu(vtMenu) \n\
           !Lock Ctrl <Btn2Down>:popup-menu(vtMenu) \n\
 !Lock Ctrl @@Num_Lock <Btn2Down>:popup-menu(vtMenu) \n\
     ! @@Num_Lock Ctrl <Btn2Down>:popup-menu(vtMenu) \n\
          ~Ctrl ~Meta <Btn2Down>:ignore() \n\
                 Meta <Btn2Down>:clear-saved-lines() \n\
            ~Ctrl ~Meta <Btn2Up>:insert-selection(SELECT, CUT_BUFFER0) \n\
                !Ctrl <Btn3Down>:popup-menu(fontMenu) \n\
           !Lock Ctrl <Btn3Down>:popup-menu(fontMenu) \n\
 !Lock Ctrl @@Num_Lock <Btn3Down>:popup-menu(fontMenu) \n\
     ! @@Num_Lock Ctrl <Btn3Down>:popup-menu(fontMenu) \n\
          ~Ctrl ~Meta <Btn3Down>:start-extend() \n\
              ~Meta <Btn3Motion>:select-extend() \n\
                 Ctrl <Btn4Down>:scroll-back(1,halfpage,m) \n\
            Lock Ctrl <Btn4Down>:scroll-back(1,halfpage,m) \n\
  Lock @@Num_Lock Ctrl <Btn4Down>:scroll-back(1,halfpage,m) \n\
       @@Num_Lock Ctrl <Btn4Down>:scroll-back(1,halfpage,m) \n\
                      <Btn4Down>:scroll-back(5,line,m)     \n\
                 Ctrl <Btn5Down>:scroll-forw(1,halfpage,m) \n\
            Lock Ctrl <Btn5Down>:scroll-forw(1,halfpage,m) \n\
  Lock @@Num_Lock Ctrl <Btn5Down>:scroll-forw(1,halfpage,m) \n\
       @@Num_Lock Ctrl <Btn5Down>:scroll-forw(1,halfpage,m) \n\
                      <Btn5Down>:scroll-forw(5,line,m)     \n\
                         <BtnUp>:select-end(SELECT, CUT_BUFFER0) \n\
                       <BtnDown>:ignore() \
";				/* PROCURA added "Meta <Btn2Down>:clear-saved-lines()" */
d319 1
d759 1
a759 1
	defaultTranslations,	/* tm_table                     */
d811 3
d3349 1
a3349 1
			    xterm_name);
d3838 1
a3838 1
    for (offset = 0; offset < len; offset += this_col) {
d3854 2
a3855 2
	if (offset + this_col > len) {
	    this_col = len - offset;
d3866 1
a3866 1
	screen->do_wrap = (screen->cur_col < next_col);
d4010 1
d4102 1
a4102 1
		;
d4792 1
a4792 1
    if (XGetWMIconName(TScreenOf(xw)->display, VShellWindow, &text)) {
d4804 1
a4804 1
    if (XGetWMName(TScreenOf(xw)->display, VShellWindow, &text)) {
d4862 1
a4862 1
		       VShellWindow);
d4870 1
a4870 1
			   VShellWindow,
d4882 1
a4882 1
				 VShellWindow,
d4898 1
a4898 1
	    XRaiseWindow(screen->display, VShellWindow);
d4905 1
a4905 1
	    XLowerWindow(screen->display, VShellWindow);
d4928 5
d5397 4
d5567 1
a5567 1
	XSetWMNormalHints(screen->display, VShellWindow, &xw->hints);
a5902 43
/*
 * Extend a (normally) boolean resource value by checking for additional values
 * which will be mapped into true/false.
 */
#if OPT_RENDERFONT
static int
extendedBoolean(const char *value, FlagList * table, Cardinal limit)
{
    int result = -1;
    long check;
    char *next;
    Cardinal n;

    if ((x_strcasecmp(value, "true") == 0)
	|| (x_strcasecmp(value, "yes") == 0)
	|| (x_strcasecmp(value, "on") == 0)) {
	result = True;
    } else if ((x_strcasecmp(value, "false") == 0)
	       || (x_strcasecmp(value, "no") == 0)
	       || (x_strcasecmp(value, "off") == 0)) {
	result = False;
    } else if ((check = strtol(value, &next, 0)) >= 0 && *next == '\0') {
	if (check >= (long) limit)
	    check = True;
	result = (int) check;
    } else {
	for (n = 0; n < limit; ++n) {
	    if (x_strcasecmp(value, table[n].name) == 0) {
		result = table[n].code;
		break;
	    }
	}
    }

    if (result < 0) {
	fprintf(stderr, "Unrecognized keyword: %s\n", value);
	result = False;
    }

    return result;
}
#endif /* OPT_RENDERFONT */

d5954 1
d6936 1
a6936 1
		    xterm_name, myfont->f_n, use_font);
d6948 1
a6948 1
		xterm_name);
d7015 7
d7066 1
a7066 1
	XMoveWindow(XtDisplay(xw), XtWindow(SHELL_OF(xw)),
d7071 1
a7071 1
    XSetWMNormalHints(XtDisplay(xw), XtWindow(SHELL_OF(xw)), &xw->hints);
d7079 1
a7079 1
	XChangeProperty(XtDisplay(xw), VShellWindow,
d7214 1
a7214 1
    XDefineCursor(screen->display, VShellWindow, screen->pointer_cursor);
d7254 1
d7532 23
d7809 3
a7811 1
		;		/* really INVERSE ... */
a7856 1

d7858 2
a7859 2
	     * Overriding the combination of filled, reversed, in_selection
	     * is too complicated since the underline and the text-cell use
d7867 1
a7867 1
	     * Setup a new request.
d7878 1
d7880 15
a7894 3
	    outlineGC = getCgsGC(xw, currentWin, gcVTcursOutline);
	    if (outlineGC == 0)
		outlineGC = currentGC;
a7903 3
	    outlineGC = getCgsGC(xw, currentWin, gcVTcursOutline);
	    if (outlineGC == 0)
		outlineGC = currentGC;
d8653 1
a8653 3
	atoms = (AtomPtr *) XtRealloc((char *) atoms,
				      (Cardinal) sizeof(AtomPtr)
				      * (atomCount + 1));
a8722 3

	    setCgsFore(xw, win, gcVTcursOutline, bg);
	    setCgsBack(xw, win, gcVTcursOutline, cc);
a8725 3

	    setCgsFore(xw, win, gcVTcursOutline, cc);
	    setCgsBack(xw, win, gcVTcursOutline, bg);
d8727 1
d8735 176
@


1.16
log
@Update to xterm version 264, Tested at least by krw@@, jasper@@, ajacoutot@@.
@
text
@d1 1
a1 1
/* $XTermId: charproc.c,v 1.1086 2010/10/13 23:04:01 tom Exp $ */
d280 1
a303 3
#if 0
    { "select-cursor-stop",	HandleKeyboardSelectStop },
#endif
a307 3
#if 0
    { "select-stop",		HandleSelectStop },
#endif
d6381 2
a6382 2
    DefaultFontNames[fNorm] = wnew->misc.default_font.f_n;
    DefaultFontNames[fBold] = wnew->misc.default_font.f_b;
d6386 2
a6387 2
    DefaultFontNames[fWide] = wnew->misc.default_font.f_w;
    DefaultFontNames[fWBold] = wnew->misc.default_font.f_wb;
d6456 2
a6457 2
	    TScreenOf(wnew)->Acolors[i].resource
		= ((char *) fake_resources[i - MIN_ANSI_COLORS].default_addr);
d6462 1
d6464 3
d8426 1
a8426 1
    static const char *errfmt = "%s:  %s in range string \"%s\" (position %d)\n";
d8643 1
a8643 1
	    TRACE(("DoSetSelectedFont(%s)\n", val));
d8649 2
a8650 2
		&& !strchr(val, '\n')
		&& (test = x_strdup(val)) != 0) {
d8653 1
a8653 1
				   xtermFontName(val),
d8670 1
a8670 2
	    if (used != val)
		free(used);
@


1.15
log
@Update to xterm 262.

tested by ajacoutot@@, jasper@@ and krw@@.
@
text
@d1 1
a1 1
/* $XTermId: charproc.c,v 1.1076 2010/08/29 22:51:09 tom Exp $ */
d303 3
d310 3
d462 1
d560 1
a560 1
    Fres("iconFont", "IconFont", screen.fnt_icon.fs, XtDefaultFont),
d3332 1
a3332 1
v_write(int f, Char * data, unsigned len)
d3348 1
a3348 1
	    fprintf(stderr, " \"%.*s\"", len, (char *) data);
d3355 1
a3355 1
	tt_write((char *) data, len);
d3360 1
a3360 1
	IGNORE_RC(write(f, (char *) data, (size_t) len));
d3790 3
a5659 36
/*
 * The whole wnew->screen struct is zeroed in VTInitialize.  Use these macros
 * where applicable for copying the pieces from the request widget into the
 * new widget.  We do not have to use them for wnew->misc, but the associated
 * traces are very useful for debugging.
 */
#if OPT_TRACE
#define init_Bres(name) \
	TRACE(("init " #name " = %s\n", \
		BtoS(wnew->name = request->name)))
#define init_Dres2(name,i) \
	TRACE(("init " #name "[%d] = %f\n", i, \
		wnew->name[i] = request->name[i]))
#define init_Ires(name) \
	TRACE(("init " #name " = %d\n", \
		wnew->name = request->name))
#define init_Sres(name) \
	TRACE(("init " #name " = \"%s\"\n", \
		(wnew->name = x_strtrim(request->name)) != NULL \
			? wnew->name : "<null>"))
#define init_Sres2(name,i) \
	TRACE(("init " #name "[%d] = \"%s\"\n", i, \
		(wnew->name(i) = x_strtrim(request->name(i))) != NULL \
			? wnew->name(i) : "<null>"))
#define init_Tres(offset) \
	TRACE(("init screen.Tcolors[" #offset "] = %#lx\n", \
		fill_Tres(wnew, request, offset)))
#else
#define init_Bres(name)    wnew->name = request->name
#define init_Dres2(name,i) wnew->name[i] = request->name[i]
#define init_Ires(name)    wnew->name = request->name
#define init_Sres(name)    wnew->name = x_strtrim(request->name)
#define init_Sres2(name,i) wnew->name(i) = x_strtrim(request->name(i))
#define init_Tres(offset)  fill_Tres(wnew, request, offset)
#endif

d6078 1
a6078 1
    char *s;
d6186 2
d6201 7
d6239 8
d6273 1
d6364 6
a6369 1
    TScreenOf(wnew)->fnt_icon.fs = TScreenOf(request)->fnt_icon.fs;
d6374 2
d6384 2
d6389 2
d6595 4
d7181 29
d7214 1
d7216 6
a7221 2
	TRACE(("Initializing active-icon\n"));
	XtVaGetValues(shell, XtNiconX, &iconX, XtNiconY, &iconY, (XtPointer) 0);
d7223 1
@


1.14
log
@Update to xterm 261. Tested by krw@@, jcs@@.
@
text
@d1 1
a1 1
/* $XTermId: charproc.c,v 1.1071 2010/06/28 09:03:42 tom Exp $ */
d1226 1
d2938 1
d2940 1
a2940 1
	    if (screen->vtXX_level >= 4)
d2947 2
a2948 1
	    /* csi dollar (*) */
d2956 5
a2960 3
	    TRACE(("CASE_DECCRA - Copy rectangular area\n"));
	    xtermParseRect(xw, nparam, param, &myRect);
	    ScrnCopyRectangle(xw, &myRect, nparam - 5, param + 5);
d2965 5
a2969 3
	    TRACE(("CASE_DECERA - Erase rectangular area\n"));
	    xtermParseRect(xw, nparam, param, &myRect);
	    ScrnFillRectangle(xw, &myRect, ' ', 0, True);
d2974 8
a2981 6
	    TRACE(("CASE_DECFRA - Fill rectangular area\n"));
	    if (nparam > 0
		&& ((param[0] >= 32 && param[0] <= 126)
		    || (param[0] >= 160 && param[0] <= 255))) {
		xtermParseRect(xw, nparam - 1, param + 1, &myRect);
		ScrnFillRectangle(xw, &myRect, param[0], xw->flags, True);
d2987 5
a2991 3
	    TRACE(("CASE_DECSERA - Selective erase rectangular area\n"));
	    xtermParseRect(xw, nparam > 4 ? 4 : nparam, param, &myRect);
	    ScrnWipeRectangle(xw, &myRect);
d3002 5
a3006 3
	    TRACE(("CASE_DECCARA - Change attributes in rectangular area\n"));
	    xtermParseRect(xw, nparam > 4 ? 4 : nparam, param, &myRect);
	    ScrnMarkRectangle(xw, &myRect, False, nparam - 4, param + 4);
d3011 17
a3027 3
	    TRACE(("CASE_DECRARA - Reverse attributes in rectangular area\n"));
	    xtermParseRect(xw, nparam > 4 ? 4 : nparam, param, &myRect);
	    ScrnMarkRectangle(xw, &myRect, True, nparam - 4, param + 4);
d3030 6
d3046 5
d4363 3
d4375 1
a4375 1
	    set_bool_mode(TScreenOf(xw)->input_eight_bits);
d4568 3
d4739 3
d5255 2
a5256 1
    IChar *buf = TScreenOf(xw)->unparse_bfr;
d5259 1
a5259 1
    if ((TScreenOf(xw)->unparse_len + 2) >= sizeof(TScreenOf(xw)->unparse_bfr))
d5262 1
a5262 1
    len = TScreenOf(xw)->unparse_len;
d5271 1
a5271 1
    if (TScreenOf(xw)->tc_query_code >= 0) {
d5282 1
a5282 1
    TScreenOf(xw)->unparse_len = len;
d7602 2
a7603 2
	set_cursor_gcs(newvt);
	refresh_needed = True;
d8283 1
d8677 1
a8677 1
void
d8686 1
a8686 1
    Boolean changed = False;
d8745 1
@


1.13
log
@Update to xterm 258. lightly tested by krw@@, thanks.
@
text
@d1 1
a1 1
/* $XTermId: charproc.c,v 1.1055 2010/04/18 17:48:58 tom Exp $ */
d219 1
a219 1
static char *_Font_Selected_ = "yes";	/* string is arbitrary */
d730 1
a730 1
    Bres(XtNallowScrollLock, XtCAllowScrollLock, screen.allowScrollLock0, True),
d755 1
a755 1
    Bres(XtNrenderFont, XtCRenderFont, misc.render_font, True),
d1350 16
d1506 1
a1506 2
		    sp->parsestate = sp->groundtable;
		    sp->nextstate = sp->parsestate[E2A(c)];
d1525 12
a1536 12
	    case 5:		/* FALLTHRU */
	    case 8:		/* FALLTHRU */
	    case 9:		/* FALLTHRU */
	    case 10:		/* FALLTHRU */
	    case 11:		/* FALLTHRU */
	    case 12:		/* FALLTHRU */
	    case 13:		/* FALLTHRU */
	    case 14:		/* FALLTHRU */
	    case 15:		/* FALLTHRU */
	    case 24:
		sp->parsestate = sp->groundtable;
		sp->nextstate = sp->parsestate[E2A(c)];
d1663 1
a1663 1
	    sp->parsestate = sp->groundtable;
d1683 1
a1683 1
		sp->parsestate = sp->groundtable;
d1686 1
a1686 1
		Bell(XkbBI_TerminalBell, 0);
d1739 1
a1739 1
	    sp->parsestate = sp->groundtable;
d1748 1
a1748 1
	    sp->parsestate = sp->groundtable;
d1759 1
a1759 1
		sp->parsestate = sp->groundtable;
d1766 1
a1766 1
		sp->parsestate = sp->groundtable;
d1772 1
a1772 1
	    sp->parsestate = sp->groundtable;
d1777 1
a1777 1
	    sp->parsestate = sp->groundtable;
d1782 1
a1782 1
	    sp->parsestate = sp->groundtable;
d1871 1
a1871 1
	    sp->parsestate = sp->groundtable;
d1879 1
a1879 1
	    sp->parsestate = sp->groundtable;
d1887 1
a1887 1
	    sp->parsestate = sp->groundtable;
d1895 1
a1895 1
	    sp->parsestate = sp->groundtable;
d1903 1
a1903 1
	    sp->parsestate = sp->groundtable;
d1916 1
a1916 1
	    sp->parsestate = sp->groundtable;
d1924 1
a1924 1
	    sp->parsestate = sp->groundtable;
d1932 1
a1932 1
	    sp->parsestate = sp->groundtable;
d1942 1
a1942 1
	    sp->parsestate = sp->groundtable;
d1948 1
a1948 1
	    sp->parsestate = sp->groundtable;
d1954 1
a1954 1
	    sp->parsestate = sp->groundtable;
d1961 1
a1961 1
	    sp->parsestate = sp->groundtable;
d1969 1
a1969 1
	    sp->parsestate = sp->groundtable;
d1977 1
a1977 1
	    sp->parsestate = sp->groundtable;
d1985 1
a1985 1
	    sp->parsestate = sp->groundtable;
d2015 1
a2015 1
	    sp->parsestate = sp->groundtable;
d2025 1
a2025 1
		sp->parsestate = sp->groundtable;
d2083 1
a2083 1
	    sp->parsestate = sp->groundtable;
d2104 1
a2104 1
	    sp->parsestate = sp->groundtable;
d2118 1
a2118 1
	    sp->parsestate = sp->groundtable;
d2127 1
a2127 1
	    sp->parsestate = sp->groundtable;
d2133 1
a2133 1
	    sp->parsestate = sp->groundtable;
d2139 1
a2139 1
	    sp->parsestate = sp->groundtable;
d2330 1
a2330 1
	    sp->parsestate = sp->groundtable;
d2398 1
a2398 1
	    sp->parsestate = sp->groundtable;
d2405 1
a2405 1
	    sp->parsestate = sp->groundtable;
d2411 1
a2411 1
	    sp->parsestate = sp->groundtable;
d2425 1
a2425 1
	    sp->parsestate = sp->groundtable;
d2442 1
a2442 1
	    sp->parsestate = sp->groundtable;
d2466 1
a2466 1
	    sp->parsestate = sp->groundtable;
d2475 1
a2475 1
	    sp->parsestate = sp->groundtable;
d2486 1
a2486 1
	    sp->parsestate = sp->groundtable;
d2497 1
a2497 1
	    sp->parsestate = sp->groundtable;
d2504 1
a2504 1
	    sp->parsestate = sp->groundtable;
d2510 1
a2510 1
	    sp->parsestate = sp->groundtable;
d2519 1
a2519 1
	    sp->parsestate = sp->groundtable;
d2526 1
a2526 1
	    sp->parsestate = sp->groundtable;
d2533 1
a2533 1
	    sp->parsestate = sp->groundtable;
d2586 1
a2586 1
	    sp->parsestate = sp->groundtable;
d2615 1
a2615 1
	    sp->parsestate = sp->groundtable;
d2640 1
a2640 1
	    sp->parsestate = sp->groundtable;
d2646 1
a2646 1
	    sp->parsestate = sp->groundtable;
d2652 1
a2652 1
	    sp->parsestate = sp->groundtable;
d2677 1
a2677 1
	    sp->parsestate = sp->groundtable;
d2687 1
a2687 1
	    sp->parsestate = sp->groundtable;
d2693 1
a2693 1
	    sp->parsestate = sp->groundtable;
d2699 1
a2699 1
	    sp->parsestate = sp->groundtable;
d2704 1
a2704 1
	    sp->parsestate = sp->groundtable;
d2729 6
a2734 2
	    sp->string_mode = ANSI_SOS;
	    sp->parsestate = sos_table;
d2739 6
a2744 2
	    sp->string_mode = ANSI_PM;
	    sp->parsestate = sos_table;
d2755 6
a2760 2
	    sp->string_mode = ANSI_APC;
	    sp->parsestate = sos_table;
d2767 1
a2767 1
	    sp->parsestate = sp->groundtable;
d2773 1
a2773 1
	    sp->parsestate = sp->groundtable;
d2781 1
a2781 1
	    sp->parsestate = sp->groundtable;
d2788 1
a2788 1
	    sp->parsestate = sp->groundtable;
d2794 1
a2794 1
	    sp->parsestate = sp->groundtable;
d2800 1
a2800 1
	    sp->parsestate = sp->groundtable;
d2807 1
a2807 1
	    sp->parsestate = sp->groundtable;
d2813 1
a2813 1
	    sp->parsestate = sp->groundtable;
d2819 1
a2819 1
	    sp->parsestate = sp->groundtable;
d2825 1
a2825 1
	    sp->parsestate = sp->groundtable;
d2831 1
a2831 1
	    sp->parsestate = sp->groundtable;
d2871 1
a2871 1
	    sp->parsestate = sp->groundtable;
d2895 1
a2895 1
	    sp->parsestate = sp->groundtable;
d2922 1
a2922 1
	    sp->parsestate = sp->groundtable;
d2931 1
a2931 1
	    sp->parsestate = sp->groundtable;
d2956 1
a2956 1
	    sp->parsestate = sp->groundtable;
d2963 1
a2963 1
	    sp->parsestate = sp->groundtable;
d2974 1
a2974 1
	    sp->parsestate = sp->groundtable;
d2981 1
a2981 1
	    sp->parsestate = sp->groundtable;
d2987 1
a2987 1
	    sp->parsestate = sp->groundtable;
d2994 1
a2994 1
	    sp->parsestate = sp->groundtable;
d3001 1
a3001 1
	    sp->parsestate = sp->groundtable;
d3018 1
a3018 1
	    sp->parsestate = sp->groundtable;
d3028 1
a3028 1
	    sp->parsestate = sp->groundtable;
d3040 1
a3040 1
	    sp->parsestate = sp->groundtable;
d3046 1
a3046 1
	    sp->parsestate = sp->groundtable;
d3063 1
a3063 1
	    sp->parsestate = sp->groundtable;
d3069 1
a3069 1
	    sp->parsestate = sp->groundtable;
d3075 1
a3075 1
	    sp->parsestate = sp->groundtable;
d3081 1
a3081 1
	    sp->parsestate = sp->groundtable;
d3087 1
a3087 1
	    sp->parsestate = sp->groundtable;
d3093 1
a3093 1
	    sp->parsestate = sp->groundtable;
d3098 1
a3098 1
	    sp->parsestate = sp->groundtable;
d3103 1
a3103 1
	    sp->parsestate = sp->groundtable;
d3109 1
a3109 1
	    sp->parsestate = sp->groundtable;
d3137 1
a3137 1
	    sp->parsestate = sp->groundtable;
d3219 1
a3219 1
	    sp->parsestate = sp->groundtable;
d3243 1
a3243 1
	    sp->parsestate = sp->groundtable;
a3289 1
    unsigned c = len;
a3364 1
		    c = 0;
d3497 1
a3497 1
	    && readPtyData(screen, &select_mask, VTbuffer)) {
d3571 1
a3571 1
	    && (size = readPtyData(screen, &select_mask, VTbuffer)) != 0) {
d3947 1
d3952 1
d4212 1
a4212 1
		FlushLog(screen);
d4246 1
a4246 1
		StartLog(screen);
d4248 1
a4248 1
		CloseLog(screen);
d4250 2
a4251 2
	    Bell(XkbBI_Info, 0);
	    Bell(XkbBI_Info, 0);
d4662 1
a4662 1
		StartLog(screen);
d4664 1
a4664 1
		CloseLog(screen);
d5016 4
a5019 2
	    reply.a_param[1] = (ParmType) (root_height / FontHeight(screen));
	    reply.a_param[2] = (ParmType) (root_width / FontWidth(screen));
d5387 1
a5387 1
	fillPtyData(screen, VTbuffer, (char *) Tpushback, (int) (Tpushb - Tpushback));
d5888 1
a5888 1
    int value;
d5930 43
d6043 9
a6543 12
#if OPT_WIDE_CHARS
    VTInitialize_locale(request);
    init_Bres(screen.utf8_latin1);
    init_Bres(screen.utf8_title);

#if OPT_LUIT_PROG
    init_Bres(misc.callfilter);
    init_Bres(misc.use_encoding);
    init_Sres(misc.locale_str);
    init_Sres(misc.localefilter);
#endif

d6550 14
a6563 1
    init_Bres(misc.render_font);
d6573 12
d6770 1
a6770 1
	    free(name); \
d6777 1
a6777 1
	    free(name); \
d7312 1
d7314 1
a7314 1
	if (t == NULL)
d7316 1
d7318 4
a7321 19
	for (ns = s; ns && *s;) {
	    while (*s && isspace(CharOf(*s)))
		s++;
	    if (!*s)
		break;
	    if ((ns = end = strchr(s, ',')) == 0)
		end = s + strlen(s);
	    while ((end != s) && isspace(CharOf(end[-1])))
		end--;

	    if (end != s) {
		strcpy(t, "@@im=");
		strncat(t, s, (size_t) (end - s));

		if ((p = XSetLocaleModifiers(t)) != 0 && *p
		    && (screen->xim = XOpenIM(XtDisplay(xw),
					      NULL,
					      NULL,
					      NULL)) != 0)
d7323 15
d7339 2
d7342 1
a7342 1
	    s = ns + 1;
a7343 1
	MyStackFree(t, buf);
d7990 6
a7995 3
    drawXtermText(xw, flags & DRAWX_MASK, currentGC,
		  x = LineCursorX(screen, ld, cursor_col),
		  y = CursorY(screen, screen->cursorp.row),
d8193 1
a8193 1
	Bell(XkbBI_MinorError, 0);
d8230 1
a8230 1
	    Bell(XkbBI_TerminalBell, 0);
d8459 1
a8459 1
	|| pmapClass == NULL)
d8461 1
d8463 8
a8470 8
    (void) sprintf(pmapName, "%sKeymap", params[0]);
    (void) strcpy(pmapClass, pmapName);
    if (islower(CharOf(pmapClass[0])))
	pmapClass[0] = x_toupper(pmapClass[0]);
    XtGetSubresources(w, (XtPointer) &keymap, pmapName, pmapClass,
		      key_resources, (Cardinal) 1, NULL, (Cardinal) 0);
    if (keymap != NULL)
	XtOverrideTranslations(w, keymap);
d8472 3
a8474 2
    MyStackFree(pmapName, mapName);
    MyStackFree(pmapClass, mapClass);
d8486 1
a8486 1
    Bell(XkbBI_TerminalBell, percent);
d8528 1
a8528 1
	Bell(XkbBI_MinorError, 0);
d8578 1
a8578 1
		Bell(XkbBI_MinorError, 0);
d8611 1
a8611 1
	*(pAtom = &atoms[atomCount++]) = XmuMakeAtom(atom_name);
@


1.12
log
@Update to xterm-255. Tested by stsp@@, oga@@.
@
text
@d1 1
a1 1
/* $XTermId: charproc.c,v 1.1033 2010/01/20 01:59:19 tom Exp $ */
d228 5
d394 3
d729 4
d866 3
a899 1
	    Char *attribs = ld->attribs;
d901 17
a917 13
	    col = (row == screen->cur_row) ? screen->cur_col : 0;
	    for (; isClear && (col <= screen->max_col); ++col) {
		unsigned flags = attribs[col];
		if (pass) {
		    flags &= ~FG_COLOR;
		    attribs[col] = (Char) flags;
		} else if ((flags & BG_COLOR)) {
		    isClear = False;
		} else if ((flags & FG_COLOR)) {
		    unsigned ch = ld->charData[col];
		    isClear = ((ch == ' ') || (ch == 0));
		} else {
		    isClear = False;
d945 1
a945 1
	xw->flags |= FG_COLOR;
d947 1
a947 1
	xw->flags &= ~FG_COLOR;
d990 1
a990 1
	xw->flags |= BG_COLOR;
d992 1
a992 1
	xw->flags &= ~BG_COLOR;
d1244 1
a1244 1
		unsigned new_length = size; \
d1577 2
a1578 2
			"Cannot allocate %u bytes for printable text\n",
			new_length);
d1615 2
a1616 2
			"Cannot allocate %u bytes for string mode %d\n",
			new_length, sp->string_mode);
d2136 2
a2137 2
		    xw->flags &=
			~(INVERSE | BOLD | BLINK | UNDERLINE | INVISIBLE);
d2171 1
a2171 1
		    xw->flags &= ~BOLD;
d2177 1
a2177 1
		    xw->flags &= ~UNDERLINE;
d2183 1
a2183 1
		    xw->flags &= ~BLINK;
d2189 1
a2189 1
		    xw->flags &= ~INVERSE;
d2195 1
a2195 1
		    xw->flags &= ~INVISIBLE;
d2516 1
a2516 1
	    xw->keyboard.flags &= ~MODE_DECKPAM;
d2575 29
d2669 1
a2669 1
		xw->flags &= ~PROTECTED;
d2688 1
a2688 1
	    TRACE(("CASE_ST: End of String (%d bytes)\n", sp->string_used));
d2745 1
a2745 1
	    xw->flags &= ~PROTECTED;
d2885 1
a2885 1
		    screen->locator_events &= ~LOC_BTNS_DN;
d2891 1
a2891 1
		    screen->locator_events &= ~LOC_BTNS_UP;
a3093 4
	    if (!screen->wide_chars) {
		WriteNow();
		ChangeToWide(xw);
	    }
d3096 4
d3259 1
a3259 1
int
d3283 4
a3286 2
    if ((1 << f) != pty_mask)
	return (tt_write((char *) data, len));
d3288 4
a3291 2
    if (!FD_ISSET(f, &pty_mask))
	return (write(f, (char *) data, len));
d3316 1
a3316 1
		memmove(v_buffer, v_bufstr, (unsigned) (v_bufptr - v_bufstr));
d3345 1
a3345 1
	    memmove(v_bufptr, data, len);
d3376 4
a3379 4
	riten = write(f, v_bufstr,
		      (size_t) ((v_bufptr - v_bufstr <= MAX_PTY_WRITE)
				? v_bufptr - v_bufstr
				: MAX_PTY_WRITE));
d3406 2
a3407 2
	int start = v_bufstr - v_buffer;
	int size = v_bufptr - v_buffer;
a3423 1
    return ((int) c);
d3477 1
a3477 1
		WindowScroll(xw, 0);
d3550 1
a3550 1
		WindowScroll(xw, 0);	/* Scroll to bottom */
d3552 2
a3553 2
	    TRACE(("VTbuffer uses %d/%d\n",
		   VTbuffer->last - VTbuffer->buffer,
d5323 1
a5323 1
	size_t len = ScrnPointers(screen, (unsigned) MaxRows(screen));
d5358 1
a5358 1
	fillPtyData(screen, VTbuffer, (char *) Tpushback, Tpushb - Tpushback);
d5641 1
a5641 1
	if (AllocateTermColor(target, &temp, offset, name)) {
d5742 3
a5744 3
		      !strncmp(xtermEnvLocale(), "ja", 2) ||
		      !strncmp(xtermEnvLocale(), "ko", 2) ||
		      !strncmp(xtermEnvLocale(), "zh", 2) ||
d5746 2
a5747 2
		      !strncmp(xtermEnvLocale(), "th", 2) ||
		      !strncmp(xtermEnvLocale(), "vi", 2)) {
d5826 1
a5826 1
    unsigned size;
d5837 1
a5837 1
	size = (unsigned) (1 + next - base);
d6190 4
d6236 4
d6540 1
a6540 5
    decode_wcwidth((wnew->misc.cjk_width ? 2 : 0)
		   + (wnew->misc.mk_width ? 1 : 0)
		   + 1,
		   wnew->misc.mk_samplesize,
		   wnew->misc.mk_samplepass);
d6773 21
a6793 8
#if 0				/* some strings may be owned by X libraries */
    for (n = 0; n <= fontMenu_lastBuiltin; ++n) {
	int k;
	for (k = 0; k < fMAX; ++k) {
	    char *s = screen->menu_font_names[n][k];
	    if (s != 0)
		free(s);
	}
d6796 9
d7217 1
a7217 1
	i = 5 + strlen(s);
d7234 1
a7234 1
		strncat(t, s, (unsigned) (end - s));
d7284 1
a7284 1
	    TRACE(("looking for style '%.*s'\n", end - s, s));
d7287 1
a7287 1
		    && !strncmp(s, known_style[i].name, (unsigned) (end - s))) {
d7994 1
a7994 1
     * Inspect the line on the current screen to see if any have the BLINK flag
d8005 2
a8006 1
	    if (LineTstBlinked(ld)) {
d8059 2
a8060 1
		if (LineTstBlinked(ld)) {
d8202 1
a8202 1
	xw->keyboard.flags &= ~(MODE_DECCKM | MODE_KAM | MODE_DECKPAM);
d8434 1
a8434 1
	unsigned len = *length;
d8448 1
a8448 1
	    memcpy(val, value, len);
d8507 2
a8508 1
				      sizeof(AtomPtr) * (atomCount + 1));
@


1.11
log
@Update to xterm 250
@
text
@d1 1
a1 1
/* $XTermId: charproc.c,v 1.980 2009/10/11 23:48:30 tom Exp $ */
d5 1
a5 1
Copyright 1999-2008,2009 by Thomas E. Dickey
d135 8
d144 1
a144 1
static int set_character_class(char *s);
d146 6
a151 2
static void RequestResize(XtermWidget termw, int rows, int cols, Bool text);
static void SwitchBufs(XtermWidget xw);
d154 1
a154 1
		       void (*func) (unsigned *p, unsigned mask));
d158 5
a162 4
static void dpmodes(XtermWidget termw, void (*func) (unsigned *p, unsigned mask));
static void restoremodes(XtermWidget termw);
static void savemodes(XtermWidget termw);
static void window_ops(XtermWidget termw);
d167 6
a172 3
static void HandleBlinking(XtPointer closure, XtIntervalId * id);
static void StartBlinking(TScreen * screen);
static void StopBlinking(TScreen * screen);
d338 1
d417 1
d462 1
d487 1
d506 8
a637 5
    CLICK_RES("2", screen.onClick[1], "word"),
    CLICK_RES("3", screen.onClick[2], "line"),
    CLICK_RES("4", screen.onClick[3], 0),
    CLICK_RES("5", screen.onClick[4], 0),

d648 5
d923 1
a923 1
    TScreen *screen = &xw->screen;
d947 1
a947 1
     * for the colors in the current cell, and will see the foreground color. 
d959 1
a959 1
    TScreen *screen = &xw->screen;
d994 1
a994 1
    if (xw->screen.colorAttrMode
d996 1
a996 6
	if (xw->screen.colorULMode && (xw->flags & UNDERLINE))
	    fg = COLOR_UL;
	if (xw->screen.colorBDMode && (xw->flags & BOLD))
	    fg = COLOR_BD;
	if (xw->screen.colorBLMode && (xw->flags & BLINK))
	    fg = COLOR_BL;
d1005 1
a1005 1
    if (xw->screen.boldColors
d1024 1
a1024 1
    if (xw->screen.colorAttrMode
d1026 1
a1026 1
	if (xw->screen.colorRVMode && (xw->flags & INVERSE))
d1199 3
d1314 18
d1335 1
a1335 1
    TScreen *screen = &xw->screen;
d1799 9
a1807 7
	    if ((row = param[nparam - 1]) == DEFAULT)
		row = 0;
	    param[nparam - 1] = (10 * row) + ((int) c - '0');
	    if (param[nparam - 1] > 65535)
		param[nparam - 1] = 65535;
	    if (sp->parsestate == csi_table)
		sp->parsestate = csi2_table;
d1968 1
a1968 1
		start.row = param[2] - 1;
d2507 50
d2604 2
a2605 1
		    if (param[1] == 1)
d2607 3
a2609 1
		    else if (param[1] == 0 || param[1] == 2)
d2611 2
d3034 1
a3034 2
	    if (AllowWindowOps(xw))
		window_ops(xw);
d3094 28
d3125 46
d3191 1
a3191 1
    screen = &xw->screen;
d3218 1
d3254 1
a3254 1
	term->screen.dabbrev_working = False;	/* break dabbrev sequence */
d3391 1
a3391 1
    TScreen *screen = &xw->screen;
d3474 1
a3474 1
    TScreen *screen = &xw->screen;
d3664 1
a3664 1
    TScreen *screen = &(xw->screen);
d3686 1
a3686 1
    TScreen *screen = &(xw->screen);
d3828 1
a3828 1
/* Flag icon name with "***"  on window output when iconified.
d3885 2
a3886 2
	    if (xw->screen.Vshow) {
		VTwin *Vwin = WhichVWin(&(xw->screen));
d3962 1
a3962 2
ansi_modes(XtermWidget xw,
	   void (*func) (unsigned *p, unsigned mask))
d3998 2
a3999 2
    xw->screen.send_mouse_pos = enabled ? mode : MOUSE_OFF;
    if (xw->screen.send_mouse_pos != MOUSE_OFF)
d4016 1
a4016 2
dpmodes(XtermWidget xw,
	void (*func) (unsigned *p, unsigned mask))
d4018 1
a4018 1
    TScreen *screen = &xw->screen;
d4154 1
a4154 1
		screen->bellarmed = -1;
d4257 1
a4257 1
	    set_bool_mode(xw->screen.input_eight_bits);
d4362 1
a4362 1
    TScreen *screen = &xw->screen;
d4485 1
a4485 1
    TScreen *screen = &xw->screen;
d4574 1
a4574 1
		screen->bellarmed = -1;
d4648 87
d4741 1
a4741 2
		 XTextProperty * text,
		 Status ok)
a4742 3
    char **list;
    int length = 0;

d4748 9
a4756 12
    if (ok) {
	if (XTextPropertyToStringList(text, &list, &length)) {
	    int n, c;
	    for (n = 0; n < length; n++) {
		char *s = list[n];
		while ((c = *s++) != '\0')
		    unparseputc(xw, c);
	    }
	    XFreeStringList(list);
	}
	if (text->value != 0)
	    XFree(text->value);
d4771 1
a4771 1
    TScreen *screen = &xw->screen;
a4773 1
    XTextProperty text;
d4782 6
a4787 4
    case 1:			/* Restore (de-iconify) window */
	TRACE(("...de-iconify window\n"));
	XMapWindow(screen->display,
		   VShellWindow);
d4790 7
a4796 5
    case 2:			/* Minimize (iconify) window */
	TRACE(("...iconify window\n"));
	XIconifyWindow(screen->display,
		       VShellWindow,
		       DefaultScreen(screen->display));
d4799 12
a4810 10
    case 3:			/* Move the window to the given position */
	TRACE(("...move window to %d,%d\n", param[1], param[2]));
	values.x = param[1];
	values.y = param[2];
	value_mask = (CWX | CWY);
	XReconfigureWMWindow(screen->display,
			     VShellWindow,
			     DefaultScreen(screen->display),
			     value_mask,
			     &values);
d4813 4
a4816 2
    case 4:			/* Resize the window to given size in pixels */
	RequestResize(xw, param[1], param[2], False);
d4819 5
a4823 3
    case 5:			/* Raise the window to the front of the stack */
	TRACE(("...raise window\n"));
	XRaiseWindow(screen->display, VShellWindow);
d4826 5
a4830 3
    case 6:			/* Lower the window to the bottom of the stack */
	TRACE(("...lower window\n"));
	XLowerWindow(screen->display, VShellWindow);
d4833 5
a4837 3
    case 7:			/* Refresh the window */
	TRACE(("...redraw window\n"));
	Redraw();
d4840 4
a4843 2
    case 8:			/* Resize the text-area, in characters */
	RequestResize(xw, param[1], param[2], True);
d4847 4
a4850 2
    case 9:			/* Maximize or restore */
	RequestMaximize(xw, param[1]);
d4854 16
a4869 14
    case 11:			/* Report the window's state */
	TRACE(("...get window attributes\n"));
	XGetWindowAttributes(screen->display,
			     VWindow(screen),
			     &win_attrs);
	reply.a_type = ANSI_CSI;
	reply.a_pintro = 0;
	reply.a_nparam = 1;
	reply.a_param[0] = (ParmType) ((win_attrs.map_state == IsViewable)
				       ? 1
				       : 2);
	reply.a_inters = 0;
	reply.a_final = 't';
	unparseseq(xw, &reply);
d4872 16
a4887 14
    case 13:			/* Report the window's position */
	TRACE(("...get window position\n"));
	XGetWindowAttributes(screen->display,
			     WMFrameWindow(xw),
			     &win_attrs);
	reply.a_type = ANSI_CSI;
	reply.a_pintro = 0;
	reply.a_nparam = 3;
	reply.a_param[0] = 3;
	reply.a_param[1] = (ParmType) win_attrs.x;
	reply.a_param[2] = (ParmType) win_attrs.y;
	reply.a_inters = 0;
	reply.a_final = 't';
	unparseseq(xw, &reply);
d4890 20
a4909 18
    case 14:			/* Report the window's size in pixels */
	TRACE(("...get window size in pixels\n"));
	XGetWindowAttributes(screen->display,
			     VWindow(screen),
			     &win_attrs);
	reply.a_type = ANSI_CSI;
	reply.a_pintro = 0;
	reply.a_nparam = 3;
	reply.a_param[0] = 4;
	/*FIXME: find if dtterm uses
	 *    win_attrs.height or Height
	 *      win_attrs.width  or Width
	 */
	reply.a_param[1] = (ParmType) Height(screen);
	reply.a_param[2] = (ParmType) Width(screen);
	reply.a_inters = 0;
	reply.a_final = 't';
	unparseseq(xw, &reply);
d4912 13
a4924 11
    case 18:			/* Report the text's size in characters */
	TRACE(("...get window size in characters\n"));
	reply.a_type = ANSI_CSI;
	reply.a_pintro = 0;
	reply.a_nparam = 3;
	reply.a_param[0] = 8;
	reply.a_param[1] = (ParmType) MaxRows(screen);
	reply.a_param[2] = (ParmType) MaxCols(screen);
	reply.a_inters = 0;
	reply.a_final = 't';
	unparseseq(xw, &reply);
d4928 17
a4944 14
    case 19:			/* Report the screen's size, in characters */
	if (!QueryMaximize(xw, &root_height, &root_width)) {
	    root_height = 0;
	    root_width = 0;
	}
	reply.a_type = ANSI_CSI;
	reply.a_pintro = 0;
	reply.a_nparam = 3;
	reply.a_param[0] = 9;
	reply.a_param[1] = (ParmType) (root_height / FontHeight(screen));
	reply.a_param[2] = (ParmType) (root_width / FontWidth(screen));
	reply.a_inters = 0;
	reply.a_final = 't';
	unparseseq(xw, &reply);
d4948 5
a4952 3
    case 20:			/* Report the icon's label */
	report_win_label(xw, 'L', &text,
			 XGetWMIconName(screen->display, VShellWindow, &text));
d4955 66
a5020 3
    case 21:			/* Report the window's title */
	report_win_label(xw, 'l', &text,
			 XGetWMName(screen->display, VShellWindow, &text));
d5024 4
a5027 2
	if (param[0] >= 24)
	    RequestResize(xw, param[0], -1, True);
d5064 1
a5064 1
	if (!xw->screen.control_eight_bits) {
d5120 4
a5123 2
    while (*s)
	unparseputc(xw, *s++);
d5129 1
a5129 1
    IChar *buf = xw->screen.unparse_bfr;
d5132 1
a5132 1
    if ((xw->screen.unparse_len + 2) >= sizeof(xw->screen.unparse_bfr))
d5135 1
a5135 1
    len = xw->screen.unparse_len;
d5144 1
a5144 1
    if (xw->screen.tc_query_code >= 0) {
d5155 1
a5155 1
    xw->screen.unparse_len = len;
d5166 3
a5168 1
    if (xw->screen.unparse_len) {
d5170 1
a5170 1
	tt_write(xw->screen.unparse_bfr, xw->screen.unparse_len);
d5172 1
a5172 1
	writePtyData(xw->screen.respond, xw->screen.unparse_bfr, xw->screen.unparse_len);
d5174 1
a5174 1
	xw->screen.unparse_len = 0;
d5181 1
a5181 1
    if (xw->screen.whichBuf)
d5190 1
a5190 1
    TScreen *screen = &(xw->screen);
d5199 1
a5199 1
	SwitchBufs(xw);
d5211 1
a5211 1
    TScreen *screen = &(xw->screen);
d5218 1
a5218 1
	SwitchBufs(xw);
d5227 1
a5227 1
SwitchBufs(XtermWidget xw)
d5229 1
a5229 1
    TScreen *screen = &(xw->screen);
d5236 1
a5236 1
    SwitchBufPtrs(screen);
d5239 1
a5239 1
	if (screen->scroll_amt)
d5241 1
d5267 1
a5267 1
SwitchBufPtrs(TScreen * screen)
d5271 1
a5271 1
	screen->visbuf = screen->editBuf_index[screen->whichBuf];
d5388 1
a5388 1
    TScreen *screen = &xw->screen;
d5397 2
a5398 2
    if ((askedWidth = (Dimension) cols) < cols
	|| (askedHeight = (Dimension) rows) < rows)
d5443 1
a5443 1
	if (high < attrs.height)
d5447 1
a5447 1
	if (wide < attrs.width)
d5571 2
a5572 2
    target->screen.Tcolors[offset] = source->screen.Tcolors[offset];
    target->screen.Tcolors[offset].mode = False;
d5574 2
a5575 2
    if ((name = x_strtrim(target->screen.Tcolors[offset].resource)) != 0)
	target->screen.Tcolors[offset].resource = name;
d5578 1
a5578 1
	target->screen.Tcolors[offset].value = target->dft_foreground;
d5580 1
a5580 1
	target->screen.Tcolors[offset].value =
d5583 1
a5583 1
	     : target->screen.Tcolors[TEXT_FG].value);
d5585 1
a5585 1
	target->screen.Tcolors[offset].value =
d5588 1
a5588 1
	     : target->screen.Tcolors[TEXT_BG].value);
d5594 1
a5594 1
	    target->screen.Tcolors[offset].value = temp.colors[offset];
d5597 1
a5597 1
    return target->screen.Tcolors[offset].value;
d5601 1
a5601 1
	target->screen.Tcolors[offset] = source->screen.Tcolors[offset]
d5606 1
a5606 1
VTInitialize_locale(XtermWidget request)
d5608 1
d5612 1
a5612 1
    TRACE(("... request screen.utf8_mode = %d\n", request->screen.utf8_mode));
d5614 2
a5615 2
    if (request->screen.utf8_mode < 0)
	request->screen.utf8_mode = uFalse;
d5617 2
a5618 2
    if (request->screen.utf8_mode > 3)
	request->screen.utf8_mode = uDefault;
d5620 2
a5621 2
    request->screen.latin9_mode = 0;
    request->screen.unicode_font = 0;
d5623 2
a5624 2
    request->misc.callfilter = 0;
    request->misc.use_encoding = 0;
d5627 1
a5627 1
    TRACE(("... request misc.locale_str = \"%s\"\n", request->misc.locale_str));
d5629 1
a5629 1
    if (request->screen.utf8_mode == uFalse) {
d5633 3
a5635 3
    if (x_strcasecmp(request->misc.locale_str, "CHECKFONT") == 0) {
	int fl = (request->misc.default_font.f_n
		  ? (int) strlen(request->misc.default_font.f_n)
d5638 1
a5638 1
	    && x_strcasecmp(request->misc.default_font.f_n + fl - 11,
d5640 1
a5640 1
	    request->screen.unicode_font = 1;
d5645 2
a5646 2
		if (request->screen.utf8_mode == uDefault)
		    request->screen.utf8_mode = uFalse;
d5648 3
a5650 3
		if (request->screen.utf8_mode == uDefault)
		    request->screen.utf8_mode = uFalse;
		request->screen.latin9_mode = 1;
d5652 2
a5653 2
		request->misc.callfilter = (Boolean) (is_utf8 ? 0 : 1);
		request->screen.utf8_mode = uAlways;
d5656 2
a5657 2
	    request->misc.callfilter = is_utf8 ? 0 : 1;
	    request->screen.utf8_mode = uAlways;
d5661 2
a5662 2
	    if (request->screen.utf8_mode == uDefault) {
		request->screen.utf8_mode = is_utf8 ? uAlways : uFalse;
d5667 5
a5671 5
	if (x_strcasecmp(request->misc.locale_str, "TRUE") == 0 ||
	    x_strcasecmp(request->misc.locale_str, "ON") == 0 ||
	    x_strcasecmp(request->misc.locale_str, "YES") == 0 ||
	    x_strcasecmp(request->misc.locale_str, "AUTO") == 0 ||
	    strcmp(request->misc.locale_str, "1") == 0) {
d5673 6
a5678 6
	request->misc.callfilter = (Boolean) (is_utf8 ? 0 : 1);
	request->screen.utf8_mode = uAlways;
    } else if (x_strcasecmp(request->misc.locale_str, "FALSE") == 0 ||
	       x_strcasecmp(request->misc.locale_str, "OFF") == 0 ||
	       x_strcasecmp(request->misc.locale_str, "NO") == 0 ||
	       strcmp(request->misc.locale_str, "0") == 0) {
d5680 2
a5681 2
	if (request->screen.utf8_mode == uDefault) {
	    request->screen.utf8_mode = is_utf8 ? uAlways : uFalse;
d5683 2
a5684 2
    } else if (x_strcasecmp(request->misc.locale_str, "MEDIUM") == 0 ||
	       x_strcasecmp(request->misc.locale_str, "SEMIAUTO") == 0) {
d5687 1
a5687 1
	    request->screen.utf8_mode = uAlways;
d5698 2
a5699 2
	    request->misc.callfilter = 1;
	    request->screen.utf8_mode = uAlways;
d5701 1
a5701 1
	    request->screen.utf8_mode = uFalse;
d5703 2
a5704 2
    } else if (x_strcasecmp(request->misc.locale_str, "UTF-8") == 0 ||
	       x_strcasecmp(request->misc.locale_str, "UTF8") == 0) {
d5706 1
a5706 1
	request->screen.utf8_mode = uAlways;
d5709 3
a5711 3
	request->misc.callfilter = 1;
	request->screen.utf8_mode = uAlways;
	request->misc.use_encoding = 1;
d5713 2
a5714 2
    TRACE(("... updated misc.callfilter = %s\n", BtoS(request->misc.callfilter)));
    TRACE(("... updated misc.use_encoding = %s\n", BtoS(request->misc.use_encoding)));
d5716 2
a5717 2
    if (request->screen.utf8_mode == uDefault) {
	request->screen.utf8_mode = is_utf8 ? uAlways : uFalse;
d5721 1
a5721 1
    request->screen.utf8_inparse = (Boolean) (request->screen.utf8_mode != uFalse);
d5723 1
a5723 1
    TRACE(("... updated screen.utf8_mode = %d\n", request->screen.utf8_mode));
d5748 1
a5748 1
    String res = wreq->screen.onClick[item];
d5752 1
a5752 1
    wnew->screen.selectMap[item] = NSELECTUNITS;
d5755 1
a5755 1
	    wnew->screen.selectMap[item] = table[n].code;
d5758 2
a5759 2
		wnew->screen.selectExpr[item] = x_strtrim(next);
		TRACE(("Parsed regex \"%s\"\n", wnew->screen.selectExpr[item]));
d5767 84
d5858 1
a5858 1
#define Kolor(name) wnew->screen.name.resource
d5864 57
d5942 2
a5943 1
    TRACE(("VTInitialize %d / %d\n", XtNumber(xterm_resources), MAXRESOURCES));
d5950 1
a5950 1
    memset(&wnew->screen, 0, sizeof(wnew->screen));
d5969 1
a5969 1
    wnew->screen.display = wnew->core.screen->display;
d5979 2
a5980 2
	wnew->dft_foreground = MyWhitePixel(wnew->screen.display);
	wnew->dft_background = MyBlackPixel(wnew->screen.display);
d5982 2
a5983 2
	wnew->dft_foreground = MyBlackPixel(wnew->screen.display);
	wnew->dft_background = MyWhitePixel(wnew->screen.display);
d5991 2
a5992 2
    TRACE(("   Screen foreground  %#lx\n", T_COLOR(&(wnew->screen), TEXT_FG)));
    TRACE(("   Screen background  %#lx\n", T_COLOR(&(wnew->screen), TEXT_BG)));
d5994 3
a5996 3
    wnew->screen.mouse_button = -1;
    wnew->screen.mouse_row = -1;
    wnew->screen.mouse_col = -1;
d6018 1
a6018 1
    wnew->screen.cursor_blink_res = wnew->screen.cursor_blink;
d6029 1
a6029 1
    wnew->keyboard.type = wnew->screen.old_fkeys
d6047 1
a6047 1
    for (s = request->screen.term_id; *s; s++) {
d6051 5
a6055 5
    wnew->screen.terminal_id = atoi(s);
    if (wnew->screen.terminal_id < MIN_DECID)
	wnew->screen.terminal_id = MIN_DECID;
    if (wnew->screen.terminal_id > MAX_DECID)
	wnew->screen.terminal_id = MAX_DECID;
d6057 2
a6058 2
	   wnew->screen.term_id,
	   wnew->screen.terminal_id));
d6060 3
a6062 1
    wnew->screen.vtXX_level = (wnew->screen.terminal_id / 100);
d6067 1
d6076 1
d6090 1
a6090 1
    wnew->screen.tc_query_code = -1;
d6108 1
a6108 1
    wnew->screen.pointer_cursor = request->screen.pointer_cursor;
d6117 1
d6134 1
d6140 28
d6175 6
a6180 5
    wnew->screen.allowSendEvents = wnew->screen.allowSendEvent0;
    wnew->screen.allowFontOps = wnew->screen.allowFontOp0;
    wnew->screen.allowTcapOps = wnew->screen.allowTcapOp0;
    wnew->screen.allowTitleOps = wnew->screen.allowTitleOp0;
    wnew->screen.allowWindowOps = wnew->screen.allowWindowOp0;
d6185 1
a6185 1
    wnew->screen.fnt_icon.fs = request->screen.fnt_icon.fs;
d6197 1
a6197 1
#define DefaultFontNames wnew->screen.menu_font_names[fontMenu_default]
d6204 2
a6205 2
    wnew->screen.MenuFontName(fontMenu_fontescape) = NULL;
    wnew->screen.MenuFontName(fontMenu_fontsel) = NULL;
d6207 1
a6207 1
    wnew->screen.menu_font_number = fontMenu_default;
d6209 2
a6210 2
    if (wnew->screen.initial_font != 0) {
	int result = xtermGetFont(wnew->screen.initial_font);
d6212 1
a6212 1
	    wnew->screen.menu_font_number = result;
d6233 4
a6236 4
    if (wnew->screen.cache_doublesize > NUM_CHRSET)
	wnew->screen.cache_doublesize = NUM_CHRSET;
    if (wnew->screen.cache_doublesize == 0)
	wnew->screen.font_doublesize = False;
d6238 2
a6239 2
	   wnew->screen.font_doublesize ? "" : " not",
	   wnew->screen.cache_doublesize));
d6271 1
a6271 1
	    wnew->screen.Acolors[i].resource
d6273 2
a6274 2
	    if (wnew->screen.Acolors[i].resource == 0)
		wnew->screen.Acolors[i].resource = XtDefaultForeground;
d6277 1
a6277 1
	    wnew->screen.Acolors[i] = request->screen.Acolors[i];
d6280 2
a6281 2
	TRACE(("Acolors[%d] = %s\n", i, wnew->screen.Acolors[i].resource));
	wnew->screen.Acolors[i].mode = False;
d6283 2
a6284 2
	    wnew->screen.Acolors[i].value = T_COLOR(&(wnew->screen), TEXT_FG);
	    wnew->screen.Acolors[i].mode = True;
d6286 2
a6287 2
	    wnew->screen.Acolors[i].value = T_COLOR(&(wnew->screen), TEXT_BG);
	    wnew->screen.Acolors[i].mode = True;
d6292 4
a6295 4
	TRACE(("Acolors[%d] = %#lx\n", i, request->screen.Acolors[i]));
	if (wnew->screen.Acolors[i] != wnew->dft_foreground &&
	    wnew->screen.Acolors[i] != T_COLOR(&(wnew->screen), TEXT_FG) &&
	    wnew->screen.Acolors[i] != T_COLOR(&(wnew->screen), TEXT_BG))
d6307 1
a6307 1
	Display *display = wnew->screen.display;
d6331 1
a6331 1
	wnew->screen.colorMode = False;
d6346 1
a6346 1
	wnew->screen.maxClicks = ck;
d6348 2
a6349 2
	    wnew->screen.selectMap[i] = Select_CHAR;
	else if (request->screen.onClick[i] != 0)
d6352 1
a6352 1
	    wnew->screen.selectMap[i] = (SelectUnit) i;
d6356 3
a6358 3
	       NonNull(request->screen.onClick[i]),
	       wnew->screen.selectMap[i]));
	if (wnew->screen.selectMap[i] == NSELECTUNITS)
d6361 1
a6361 1
    TRACE(("maxClicks %d\n", wnew->screen.maxClicks));
d6371 2
a6372 2
    if (wnew->screen.hilite_color == Maybe) {
	wnew->screen.hilite_color = False;
d6386 1
a6386 1
	    wnew->screen.hilite_color = True;
d6400 3
a6402 3
    T_COLOR(&(wnew->screen), TEK_BG) = T_COLOR(&(wnew->screen), TEXT_BG);
    T_COLOR(&(wnew->screen), TEK_FG) = T_COLOR(&(wnew->screen), TEXT_FG);
    T_COLOR(&(wnew->screen), TEK_CURSOR) = T_COLOR(&(wnew->screen), TEXT_CURSOR);
d6426 1
a6426 1
	if (wnew->misc.face_name == 0) {
d6437 2
a6438 2
    if (wnew->screen.max_combining < 0) {
	wnew->screen.max_combining = 0;
d6440 2
a6441 2
    if (wnew->screen.max_combining > 5) {
	wnew->screen.max_combining = 5;
d6462 1
a6462 1
    if (request->screen.utf8_mode) {
d6464 1
a6464 1
	wnew->screen.wide_chars = True;
d6467 1
a6467 1
	wnew->screen.utf8_mode = uFalse;
d6469 1
a6469 1
    TRACE(("initialized UTF-8 mode to %d\n", wnew->screen.utf8_mode));
d6472 2
a6473 2
    if (request->screen.latin9_mode) {
	wnew->screen.latin9_mode = True;
d6475 2
a6476 2
    if (request->screen.unicode_font) {
	wnew->screen.unicode_font = True;
d6478 2
a6479 2
    TRACE(("initialized Latin9 mode to %d\n", wnew->screen.latin9_mode));
    TRACE(("initialized unicode_font to %d\n", wnew->screen.unicode_font));
d6497 1
a6497 1
    if (wnew->screen.backarrow_key)
d6505 1
d6531 1
a6531 1
    wnew->screen.bellInProgress = False;
d6533 1
a6533 1
    set_character_class(wnew->screen.charClass);
d6542 1
a6542 1
	char *temp[2];
d6545 2
a6546 1
	sprintf(temp[0] = value, "%d", wnew->misc.resizeGravity);
d6554 1
a6554 1
    wnew->screen.whichVwin = &wnew->screen.fullVwin;
d6557 2
a6558 2
    if (wnew->screen.savelines < 0)
	wnew->screen.savelines = 0;
d6563 1
a6563 1
    if (!wnew->screen.jumpscroll)
d6571 1
a6571 1
    if (wnew->screen.c132)
d6601 1
a6601 1
    TScreen *screen = &xw->screen;
a6632 13
#ifdef NO_LEAKS
#if OPT_RENDERFONT
static void
xtermCloseXft(TScreen * screen, XTermXftFonts * pub)
{
    if (pub->font != 0) {
	XftFontClose(screen->display, pub->font);
	pub->font = 0;
    }
}
#endif
#endif

d6650 1
a6650 1
    TScreen *screen = &xw->screen;
d6664 7
a6729 6
#if OPT_COLOR_RES
    /* free local copies of resource strings */
    for (n = 0; n < NCOLORS; ++n) {
	FREE_LEAK(screen->Tcolors[n].resource);
    }
#endif
d6771 1
a6771 1
    TScreen *screen = &xw->screen;
d6814 1
a6814 1
    if (xw->screen.utf8_mode) {
d6946 1
a6946 1
    xw->screen.fullVwin.window = XtWindow(xw) =
d7016 1
a7016 1
    xw->screen.xic = NULL;
d7099 1
a7099 1
    term->screen.xic = NULL;
d7336 1
a7336 1
	if (xw->screen.xic == NULL
d7360 6
a7365 6
    if ((T_COLOR(&(curvt->screen), TEXT_BG) !=
	 T_COLOR(&(newvt->screen), TEXT_BG)) ||
	(T_COLOR(&(curvt->screen), TEXT_FG) !=
	 T_COLOR(&(newvt->screen), TEXT_FG)) ||
	(curvt->screen.MenuFontName(curvt->screen.menu_font_number) !=
	 newvt->screen.MenuFontName(newvt->screen.menu_font_number)) ||
d7368 1
a7368 1
	    newvt->screen.MenuFontName(fontMenu_default) = newvt->misc.default_font.f_n;
d7370 2
a7371 2
			  xtermFontName(newvt->screen.MenuFontName(curvt->screen.menu_font_number)),
			  True, newvt->screen.menu_font_number)) {
d7376 1
a7376 1
	    newvt->screen.MenuFontName(fontMenu_default) = curvt->misc.default_font.f_n;
d7379 2
a7380 2
	&& (T_COLOR(&(curvt->screen), TEXT_CURSOR) !=
	    T_COLOR(&(newvt->screen), TEXT_CURSOR))) {
d7391 8
a7398 8
    if ((T_COLOR(&(curvt->screen), MOUSE_FG) !=
	 T_COLOR(&(newvt->screen), MOUSE_FG)) ||
	(T_COLOR(&(curvt->screen), MOUSE_BG) !=
	 T_COLOR(&(newvt->screen), MOUSE_BG))) {
	recolor_cursor(&(newvt->screen),
		       newvt->screen.pointer_cursor,
		       T_COLOR(&(newvt->screen), MOUSE_FG),
		       T_COLOR(&(newvt->screen), MOUSE_BG));
d7425 1
a7425 1
    TScreen *screen = &xw->screen;
d7431 1
d7533 1
d7637 1
a7637 1
	TRACE(("ShowCursor calling drawXtermText cur(%d,%d) %s, set_at %d\n",
d7639 3
a7641 1
	       (filled ? "filled" : "outline"), set_at));
d7644 4
a7647 5
	drawXtermText(xw, flags & DRAWX_MASK, currentGC,
		      x = LineCursorX(screen, ld, cursor_col),
		      y = CursorY(screen, screen->cur_row),
		      LineCharSet(screen, ld),
		      &base, 1, 0);
d7649 20
a7668 10
#if OPT_WIDE_CHARS
	if_OPT_WIDE_CHARS(screen, {
	    for_each_combData(off, ld) {
		if (!(ld->combData[off][my_col]))
		    break;
		drawXtermText(xw, (flags & DRAWX_MASK) | NOBACKGROUND,
			      currentGC, x, y,
			      LineCharSet(screen, ld),
			      ld->combData[off] + my_col,
			      1, isWide((int) base));
a7669 2
	});
#endif
d7671 1
a7671 2
	if (!filled) {
	    GC outlineGC = getCgsGC(xw, currentWin, gcVTcursOutline);
d7675 3
d7679 1
a7679 4
	    if (!screen->cursor_underline)
		screen->box->y = (short) y;
	    else
		screen->box->y = (short) (y + FontHeight(screen) - 2);
d7682 30
d7726 1
a7726 1
    TScreen *screen = &xw->screen;
d7740 1
a7740 1
    if (screen->cursor_state == OFF)	/* FIXME */
d8010 3
a8012 1
    TScreen *screen = &xw->screen;
d8034 2
d8069 1
a8069 1
	    if (xw->screen.backarrow_key)
d8158 1
a8158 1
    static char *errfmt = "%s:  %s in range string \"%s\" (position %d)\n";
d8328 1
a8328 1
    TRACE(("Handle ignore for %p\n", w));
d8351 2
a8352 2
	int oldFont = xw->screen.menu_font_number;
	char *save = xw->screen.MenuFontName(fontMenu_fontsel);
d8381 1
a8381 1
		xw->screen.MenuFontName(fontMenu_fontsel) = test;
d8388 1
a8388 1
		    xw->screen.MenuFontName(fontMenu_fontsel) = save;
d8395 1
a8395 1
				     xtermFontName(xw->screen.MenuFontName(oldFont)),
d8410 1
a8410 1
    TScreen *screen = &(xw->screen);
d8450 1
a8450 1
    TScreen *screen = &(xw->screen);
@


1.10
log
@Update to xterm 248, fixing several bugs including a regression with
copy-and-paste. Works for martynas@@, ok matthieu@@
@
text
@d1 1
a1 1
/* $XTermId: charproc.c,v 1.972 2009/09/10 09:03:49 tom Exp $ */
d119 1
d332 1
d397 1
a397 1
static XtResource resources[] =
d537 1
d745 2
a746 2
/* core_class fields */
	(WidgetClass) & widgetClassRec,		/* superclass     */
d757 2
a758 2
	resources,		/* resources                    */
	XtNumber(resources),	/* num_resources                */
d1155 1
a1155 1
static char *
d1158 1
a1158 1
    char *result = "?";
d4770 1
a4770 1
unparseputs(XtermWidget xw, char *s)
d5379 1
a5379 1
	const String	name;
d5436 1
a5436 1
#if OPT_COLOR_RES2 && (MAXCOLORS > MIN_ANSI_COLORS)
d5447 2
a5448 1
    TRACE(("VTInitialize\n"));
d5504 1
d5722 5
d5729 1
a5729 1
#if OPT_COLOR_RES2 && (MAXCOLORS > MIN_ANSI_COLORS)
d6274 1
d6277 1
a6277 1
		    xterm_name, myfont->f_n, DEFFONT);
d6279 1
a6279 1
				 xtermFontName(DEFFONT),
d6282 1
a6282 1
	    screen->MenuFontName(screen->menu_font_number) = DEFFONT;
d6595 1
a6595 1
	char *name;
d7402 33
@


1.9
log
@update to xterm 246. Has been in snapshots for some time.
@
text
@d1 1
a1 1
/* $XTermId: charproc.c,v 1.971 2009/08/09 13:59:06 tom Exp $ */
d853 2
a854 1
	    Char *attribs = getLineData(screen, row)->attribs;
d865 1
a865 1
		    unsigned ch = getXtermCell(screen, row, col);
@


1.8
log
@Update to xterm 243. tested by naddy@@.

Patch #243 - 2009/3/28

* revert change to default for allowTcapOps (request by Bram Moolenaar).
* reallocate result returned by xtermEnvLocale() to avoid reference to
freed memory after handling menuLocale resource.
* fix an old (X11R5) bug in tek4014 for switching fontsizes.
* add resource defaultString to make configurable the use of "#" when
pastes of UTF-8 text fail due to limitations in the current locale settings.
* make the set of selection target Atom's configurable by two new
resources eightBitSelectTypes and utf8SelectTypes, e.g., to use the TEXT
Atom in preference to UTF8_STRING (discussion with Stanislav Sedov
regarding koi8rxterm and the FreeBSD port).
* modify handling of TARGETS Atom by making it return exactly the set of
targets as those which xterm is currently providing.
* set MANPAGER and PAGER explicitly to /bin/cat in minstall.sh to work
around /etc/man.conf's with those variables already set (report by
Mar'yasin Semion).
* improve error-checking of tcap-query parser.
* add check for keyboard tcap), which ensures that terminal descriptions
containing the same string for shifted/unshifted keys will be seen by
tcap-query as only the unshifted key. (This would only happen with an
incorrect terminal description).
* fix conversion for input event-state to modifier-parameter which made
tcap-query feature not work with tcapFunctionKeys (keyboard type tcap).
* add "DEF_ALLOW_XXX" definitions to main.h to allow overriding the
default compiled-in values for "allowxxx" resources.
* remove check on bell-percentage added in patch #242, which disallowed
zero/negative values (Redhat Bugzilla #487829).
@
text
@d1 1
a1 1
/* $XTermId: charproc.c,v 1.897 2009/03/29 00:23:12 tom Exp $ */
a139 1
static void VTallocbuf(void);
d271 1
d430 1
d432 1
a432 1
    Bres(XtNkeepSelection, XtCKeepSelection, screen.keepSelection, False),
d571 1
d728 1
a728 1
static void VTInitI18N(void);
d842 1
d853 2
d857 1
a857 1
		unsigned flags = SCRN_BUF_ATTRS(screen, row)[col];
d860 1
a860 1
		    SCRN_BUF_ATTRS(screen, row)[col] = (Char) flags;
d880 1
d908 1
d921 1
d1215 2
a1216 1
		       print_area, 1);				\
d1220 1
a1220 1
	    if (print_used > single) {				\
d1223 2
a1224 2
		       print_area + single,			\
		       print_used - single);			\
d1226 1
a1226 1
	    print_used = 0;					\
d1244 8
d1259 2
a1286 8
    /* Buffer for processing printable text */
    static IChar *print_area;
    static size_t print_size, print_used;

    /* Buffer for processing strings (e.g., OSC ... ST) */
    static Char *string_area;
    static size_t string_size, string_used;

d1345 1
a1345 1
	    if ((c = (unsigned) xtermPrinterControl((int) c)) == 0)
d1417 2
a1418 2
	    if (string_used) {
		switch (string_area[0]) {
d1420 1
a1420 1
		    if (string_used <= 7)
d1508 1
a1508 1
	    SafeAlloc(IChar, print_area, print_used, print_size);
d1524 3
a1526 3
	    print_area = new_string;
	    print_size = new_length;
	    print_area[print_used++] = c;
d1537 1
a1537 1
	    || (laststate == CASE_PRINT && print_used)) {
d1546 1
a1546 1
	    SafeAlloc(Char, string_area, string_used, string_size);
d1564 3
a1566 3
	    string_area = new_string;
	    string_size = new_length;
	    string_area[string_used++] = CharOf(c);
d1570 1
a1570 1
	    string_used = 0;
d1599 3
a1601 3
		if (string_used)
		    string_area[--string_used] = '\0';
		do_osc(xw, string_area, string_used, (int) c);
d1644 1
a1644 1
	    xtermAutoPrint(c);
d2321 1
a2321 1
	    xtermMediaControl(param[0], False);
d2327 1
a2327 1
	    xtermMediaControl(param[0], True);
d2536 1
a2536 1
	    TRACE(("CASE_ST: End of String (%d bytes)\n", string_used));
d2538 1
a2538 1
	    if (!string_used)
d2540 1
a2540 1
	    string_area[--string_used] = '\0';
d2546 1
a2546 1
		do_dcs(xw, string_area, string_used);
d2549 1
a2549 1
		do_osc(xw, string_area, string_used, ANSI_ST);
d3075 1
a3075 1
	term->screen.dabbrev_working = 0;	/* break dabbrev sequence */
d3463 1
d3467 12
a3478 11
    if (!screen->xic)
	return;
    spot.x = (short) CurCursorX(screen, screen->cur_row, screen->cur_col);
    spot.y = (short) (CursorY(screen, screen->cur_row) + screen->fs_ascent);
    list = XVaCreateNestedList(0,
			       XNSpotLocation, &spot,
			       XNForeground, T_COLOR(screen, TEXT_FG),
			       XNBackground, T_COLOR(screen, TEXT_BG),
			       NULL);
    XSetICValues(screen->xic, XNPreeditAttributes, list, NULL);
    XFree(list);
d3486 1
d3488 7
a3494 5
    /* mark that we had to wrap this line */
    ScrnSetFlag(screen, screen->cur_row, LINEWRAPPED);
    xtermAutoPrint('\n');
    xtermIndex(xw, 1);
    set_cur_col(screen, 0);
d3596 5
a3600 1
	last_col = CurMaxCol(screen, screen->cur_row);
d4024 1
a4024 1
		    if (screen->alternate
d4260 1
a4260 1
	    DoSM(DP_X_ALTSCRN, screen->alternate);
d4527 1
d4533 1
d4540 1
d4556 1
d4561 1
d4566 1
d4581 1
d4597 1
d4613 1
d4633 1
d4825 1
a4825 1
    if (xw->screen.alternate)
d4836 1
a4836 1
    if (!screen->alternate) {
d4838 5
a4842 3
	if (!screen->altbuf)
	    screen->altbuf = Allocate(MaxRows(screen), MaxCols(screen),
				      &screen->abuf_address);
d4844 4
a4847 1
	screen->alternate = True;
d4857 1
a4857 1
    if (screen->alternate) {
d4861 1
a4861 1
	screen->alternate = False;
d4863 3
d4900 4
a4903 1
	    && screen->altbuf != 0);
a4907 4
 * visbuf contains pointers from allbuf or altbuf for the visible screen,
 * and pointers from allbuf for the saved lines.  That makes it simple to
 * scroll back over the saved lines without juggling pointers for the
 * regular and alternate screens.
d4913 3
d4918 4
a4921 3
	memcpy((char *) screen->save_ptr, (char *) screen->visbuf, len);
	memcpy((char *) screen->visbuf, (char *) screen->altbuf, len);
	memcpy((char *) screen->altbuf, (char *) screen->save_ptr, len);
d4926 1
a4926 1
VTRun(void)
d4928 1
a4928 1
    TScreen *screen = TScreenOf(term);
d4940 1
a4940 2
    if (screen->allbuf == NULL)
	VTallocbuf();
d4957 1
a4957 1
	VTparse(term);
d5099 1
d5140 1
a5140 1
VTInit(void)
d5142 1
a5142 2
    TScreen *screen = TScreenOf(term);
    Widget vtparent = SHELL_OF(term);
d5151 1
a5151 1
    TRACE_TRANS("vt100", (Widget) (term));
d5153 1
a5153 2
    if (screen->allbuf == NULL)
	VTallocbuf();
a5159 18
VTallocbuf(void)
{
    TScreen *screen = TScreenOf(term);
    int nrows = MaxRows(screen);

    /* allocate screen buffer now, if necessary. */
    if (screen->scrollWidget)
	nrows += screen->savelines;
    screen->allbuf = Allocate(nrows, MaxCols(screen),
			      &screen->sbuf_address);
    if (screen->scrollWidget)
	screen->visbuf = &screen->allbuf[MAX_PTRS * screen->savelines];
    else
	screen->visbuf = screen->allbuf;
    return;
}

static void
d5449 1
a5449 1
    bzero((char *) &wnew->screen, sizeof(wnew->screen));
d5454 1
a5454 1
    bzero((char *) &wnew->keyboard, sizeof(wnew->keyboard));
d5524 1
a5704 3
#if OPT_WIDE_CHARS
    wnew->num_ptrs = (OFF_CHARS + 1);	/* minimum needed for cell */
#endif
a5939 3
    if (wnew->screen.wide_chars != False)
	wnew->num_ptrs = OFF_FINAL + (wnew->screen.max_combining * 2);

d5993 1
a5993 1
    ScrollBarOn(wnew, True, False);
d5996 2
a5997 2
    if (wnew->misc.resizeGravity != NorthWestGravity &&
	wnew->misc.resizeGravity != SouthWestGravity) {
d6050 1
d6092 1
a6092 1
xtermCloseXft(TScreen * screen, XftFont ** pub)
d6094 3
a6096 3
    if (*pub != 0) {
	XftFontClose(screen->display, *pub);
	*pub = 0;
d6102 12
d6128 5
a6132 1

d6134 6
a6139 4
    TRACE_FREE_LEAK(screen->sbuf_address);
    TRACE_FREE_LEAK(screen->allbuf);
    TRACE_FREE_LEAK(screen->abuf_address);
    TRACE_FREE_LEAK(screen->altbuf);
a6142 1
    TRACE_FREE_LEAK(screen->draw_buf);
d6149 1
a6149 4
    if (screen->xim) {
	XCloseIM(screen->xim);
	TRACE(("freed screen->xim\n"));
    }
d6173 1
d6177 1
d6212 17
d6410 1
a6410 1
    values->bit_gravity = ((xw->misc.resizeGravity == NorthWestGravity)
d6481 1
a6481 1
    VTInitI18N();
d6518 4
a6521 1
	screen->visbuf = screen->allbuf = NULL;
d6530 1
a6530 1
	screen->alternate = (Boolean) (!screen->alternate);
d6539 1
a6539 1
	ScrollBarOn(xw, False, True);
d6558 1
a6558 1
    VTInitI18N();
d6574 1
a6574 1
xim_real_init(void)
d6576 1
d6597 1
a6597 1
    term->screen.xic = NULL;
d6599 1
a6599 1
    if (term->misc.cannot_im) {
d6603 1
a6603 1
    if (!term->misc.input_method || !*term->misc.input_method) {
d6605 1
a6605 1
	    term->screen.xim = XOpenIM(XtDisplay(term), NULL, NULL, NULL);
d6607 1
a6607 1
	s = term->misc.input_method;
d6628 4
a6631 4
		    && (term->screen.xim = XOpenIM(XtDisplay(term),
						   NULL,
						   NULL,
						   NULL)) != 0)
d6640 1
a6640 1
    if (term->screen.xim == NULL
d6643 1
a6643 1
	term->screen.xim = XOpenIM(XtDisplay(term), NULL, NULL, NULL);
d6646 1
a6646 1
    if (!term->screen.xim) {
d6652 1
a6652 1
    if (XGetIMValues(term->screen.xim, XNQueryInputStyle, &xim_styles, NULL)
d6656 2
a6657 2
	XCloseIM(term->screen.xim);
	term->misc.cannot_im = True;
d6662 1
a6662 1
    for (s = term->misc.preedit_type; s && !found;) {
d6699 3
a6701 3
		term->misc.preedit_type);
	XCloseIM(term->screen.xim);
	term->misc.cannot_im = True;
d6712 2
a6713 2
	XCloseIM(term->screen.xim);
	term->misc.cannot_im = True;
d6734 6
a6739 6
	term->screen.fs = XCreateFontSet(XtDisplay(term),
					 term->misc.f_x,
					 &missing_charset_list,
					 &missing_charset_count,
					 &def_string);
	if (term->screen.fs == NULL) {
d6741 6
a6746 6
		    "\"%s\" for XIM failed.\n", term->misc.f_x);
	    term->screen.fs = XCreateFontSet(XtDisplay(term),
					     DEFXIMFONT,
					     &missing_charset_list,
					     &missing_charset_count,
					     &def_string);
d6748 1
a6748 1
	if (term->screen.fs == NULL) {
d6751 2
a6752 2
	    XCloseIM(term->screen.xim);
	    term->misc.cannot_im = True;
d6755 5
a6759 5
	(void) XExtentsOfFontSet(term->screen.fs);
	j = (unsigned) XFontsOfFontSet(term->screen.fs, &fonts, &font_name_list);
	for (i = 0, term->screen.fs_ascent = 0; i < j; i++) {
	    if (term->screen.fs_ascent < (*fonts)->ascent)
		term->screen.fs_ascent = (*fonts)->ascent;
d6763 1
a6763 7
				     XNFontSet, term->screen.fs,
				     NULL);
	term->screen.xic = XCreateIC(term->screen.xim,
				     XNInputStyle, input_style,
				     XNClientWindow, XtWindow(term),
				     XNFocusWindow, XtWindow(term),
				     XNPreeditAttributes, p_list,
d6765 6
d6772 4
a6775 4
	term->screen.xic = XCreateIC(term->screen.xim, XNInputStyle, input_style,
				     XNClientWindow, XtWindow(term),
				     XNFocusWindow, XtWindow(term),
				     NULL);
d6778 1
a6778 1
    if (!term->screen.xic) {
d6780 1
a6780 1
	XCloseIM(term->screen.xim);
d6788 1
a6788 1
	if (XSetIMValues(term->screen.xim, XNDestroyCallback, &destroy_cb, NULL))
d6797 1
a6797 1
VTInitI18N(void)
d6799 2
a6800 2
    if (term->misc.open_im) {
	xim_real_init();
d6803 3
a6805 1
	if (term->screen.xic == NULL && !term->misc.cannot_im) {
d6807 1
a6807 1
	    XRegisterIMInstantiateCallback(XtDisplay(term), NULL, NULL, NULL,
d6894 1
a6894 2
    int base;
    Char clo;
d6896 1
a6896 1
    unsigned fg_bg = 0;
d6914 1
a6914 2
    Char chi = 0;
    int off;
d6918 1
d6940 4
a6943 3
    base =
	clo = SCRN_BUF_CHARS(screen, screen->cursorp.row)[cursor_col];
    flags = SCRN_BUF_ATTRS(screen, screen->cursorp.row)[cursor_col];
d6946 1
a6946 2
	chi = SCRN_BUF_WIDEC(screen, screen->cursorp.row)[cursor_col];
	if (clo == HIDDEN_LO && chi == HIDDEN_HI && cursor_col > 0) {
d6951 1
a6951 2
	    clo = SCRN_BUF_CHARS(screen, screen->cursorp.row)[cursor_col];
	    chi = SCRN_BUF_WIDEC(screen, screen->cursorp.row)[cursor_col];
a6953 1
	base = (chi << 8) | clo;
d6955 2
a6956 2
	    base = clo = ' ';
	if (isWide(base))
d6961 1
a6961 1
	base = clo = ' ';
d6963 2
a6964 1

a6968 1
#if OPT_ISO_COLORS
d6980 10
d6996 2
a6997 6
    (void) fg_bg;
    if_OPT_EXT_COLORS(screen, {
	fg_bg = PACK_FGBG(screen, screen->cursorp.row, cursor_col);
    });
    if_OPT_ISO_TRADITIONAL_COLORS(screen, {
	fg_bg = SCRN_BUF_COLOR(screen, screen->cursorp.row)[cursor_col];
d7108 1
a7108 1
		      x = CurCursorX(screen, screen->cur_row, cursor_col),
d7110 2
a7111 2
		      curXtermChrSet(xw, screen->cur_row),
		      PAIRED_CHARS(&clo, &chi), 1, 0);
d7115 2
a7116 4
	    for (off = OFF_FINAL; off < MAX_PTRS; off += 2) {
		clo = SCREEN_PTR(screen, screen->cursorp.row, off + 0)[my_col];
		chi = SCREEN_PTR(screen, screen->cursorp.row, off + 1)[my_col];
		if (!(clo || chi))
d7120 3
a7122 2
			      curXtermChrSet(xw, screen->cur_row),
			      PAIRED_CHARS(&clo, &chi), 1, isWide(base));
d7142 2
d7156 1
a7156 2
    int base;
    Char clo;
d7158 1
a7158 1
    unsigned fg_bg = 0;
d7161 1
a7161 2
    Char chi = 0;
    int off;
d7165 1
d7181 4
a7184 3
    base =
	clo = SCRN_BUF_CHARS(screen, screen->cursorp.row)[cursor_col];
    flags = SCRN_BUF_ATTRS(screen, screen->cursorp.row)[cursor_col];
d7187 1
a7187 2
	chi = SCRN_BUF_WIDEC(screen, screen->cursorp.row)[cursor_col];
	if (clo == HIDDEN_LO && chi == HIDDEN_HI && cursor_col > 0) {
d7192 1
a7192 2
	    clo = SCRN_BUF_CHARS(screen, screen->cursorp.row)[cursor_col];
	    chi = SCRN_BUF_WIDEC(screen, screen->cursorp.row)[cursor_col];
a7194 1
	base = (chi << 8) | clo;
d7196 2
a7197 2
	    base = clo = ' ';
	if (isWide(base))
d7202 1
a7202 1
	base = clo = ' ';
d7204 1
a7204 1

d7222 4
d7231 2
a7232 5
    if_OPT_EXT_COLORS(screen, {
	fg_bg = PACK_FGBG(screen, screen->cursorp.row, cursor_col);
    });
    if_OPT_ISO_TRADITIONAL_COLORS(screen, {
	fg_bg = SCRN_BUF_COLOR(screen, screen->cursorp.row)[cursor_col];
d7245 1
a7245 1
		  x = CurCursorX(screen, screen->cursorp.row, cursor_col),
d7247 2
a7248 2
		  curXtermChrSet(xw, screen->cursorp.row),
		  PAIRED_CHARS(&clo, &chi), 1, 0);
d7252 2
a7253 4
	for (off = OFF_FINAL; off < MAX_PTRS; off += 2) {
	    clo = SCREEN_PTR(screen, screen->cursorp.row, off + 0)[my_col];
	    chi = SCREEN_PTR(screen, screen->cursorp.row, off + 1)[my_col];
	    if (!(clo || chi))
d7257 3
a7259 2
			  curXtermChrSet(xw, screen->cur_row),
			  PAIRED_CHARS(&clo, &chi), 1, isWide(base));
d7265 2
d7296 1
a7296 1
ScrnHasBlinking(TScreen * screen, int row)
a7297 1
    Char *attrs = SCRN_BUF_ATTRS(screen, row);
d7302 1
a7302 1
	if (attrs[col] & BLINK) {
d7355 3
a7357 2
	    if (ScrnTstBlinked(screen, row)) {
		if (ScrnHasBlinking(screen, row)) {
d7364 1
a7364 1
		    ScrnClrBlinked(screen, row);
d7525 2
a7526 2
	screen->sc[screen->alternate != False].row =
	    screen->sc[screen->alternate != False].col = 0;
@


1.7
log
@Update to xterm 242. Tested by jsg@@.
@
text
@d1 1
a1 1
/* $XTermId: charproc.c,v 1.892 2009/02/13 21:15:35 tom Exp $ */
d398 4
a401 4
    Bres(XtNallowFontOps, XtCAllowFontOps, screen.allowFontOp0, False),
    Bres(XtNallowTcapOps, XtCAllowTcapOps, screen.allowTcapOp0, False),
    Bres(XtNallowTitleOps, XtCAllowTitleOps, screen.allowTitleOp0, True),
    Bres(XtNallowWindowOps, XtCAllowWindowOps, screen.allowWindowOp0, False),
d477 1
d482 3
d676 1
d3739 1
a3739 1
SetCursorBlink(TScreen * screen, Boolean enable)
d3741 1
a3741 1
    screen->cursor_blink = enable;
d3755 1
a3755 1
    SetCursorBlink(screen, (Boolean) (!(screen->cursor_blink)));
d5609 6
@


1.6
log
@Disable allowFontOps, allowTcapOps and allowWindowOps by default
on OpenBSD.
@
text
@d1 1
a1 1
/* $XTermId: charproc.c,v 1.865 2008/12/30 14:45:41 tom Exp $ */
d5 1
a5 1
Copyright 1999-2007,2008 by Thomas E. Dickey
d320 6
d457 1
a791 1
#if OPT_TOOLBAR
d823 1
a824 1
#endif
d826 1
d835 36
d896 13
d1283 1
d1481 2
a1482 1
	if (iswide((int) c) != sp->last_was_wide) {
d1513 1
a1513 1
	    sp->last_was_wide = iswide((int) c);
d2913 1
a2913 1
	    if (screen->allowWindowOps)
d3025 1
a3025 1
	v_buffer = (Char *) XtMalloc(len);
d3567 1
a3567 35
	    static unsigned limit;
	    static Char *hibyte, *lobyte;
	    Bool both = False;
	    unsigned j, k;

	    if (chars_chomped >= limit) {
		limit = (chars_chomped + 1) * 2;
		lobyte = (Char *) XtRealloc((char *) lobyte, limit);
		hibyte = (Char *) XtRealloc((char *) hibyte, limit);
	    }
	    for (j = offset, k = 0; j < offset + chars_chomped; j++) {
		if (buf[j] == HIDDEN_CHAR)
		    continue;
		lobyte[k] = LO_BYTE(buf[j]);
		if (buf[j] > 255) {
		    hibyte[k] = HI_BYTE(buf[j]);
		    both = True;
		} else {
		    hibyte[k] = 0;
		}
		++k;
	    }

	    WriteText(xw, PAIRED_CHARS(lobyte,
				       (both ? hibyte : 0)),
		      k);
#ifdef NO_LEAKS
	    if (limit != 0) {
		limit = 0;
		XtFree((char *) lobyte);
		XtFree((char *) hibyte);
		lobyte = 0;
		hibyte = 0;
	    }
#endif
d3591 1
a3591 3
	WriteText(xw, PAIRED_CHARS(buf + offset,
				   buf2 ? buf2 + offset : 0),
		  (unsigned) this_col);
d3606 1
a3606 1
visual_width(PAIRED_CHARS(Char * str, Char * str2), Cardinal len)
d3612 2
a3613 8
	int ch = *str;
	if (str2)
	    ch |= *str2 << 8;
	if (str)
	    str++;
	if (str2)
	    str2++;
	if (iswide(ch))
d3655 1
a3655 1
		ChangeIconName(buf);
d5626 8
a5633 1
    wnew->screen.MenuFontName(fontMenu_default) = wnew->misc.default_font.f_n;
d6827 1
a6848 1
    int base;
a6873 1
#if OPT_WIDE_CHARS
a6874 1
#endif
d6876 1
d6890 3
a6892 1
	if (iswide(base))
d6896 2
a6897 8
    flags = SCRN_BUF_ATTRS(screen, screen->cursorp.row)[cursor_col];

    if (clo == 0
#if OPT_WIDE_CHARS
	&& chi == 0
#endif
	) {
	clo = ' ';
d6901 2
a6902 2
     * If the cursor happens to be on blanks, and the foreground color is set
     * but not the background, do not treat it as a colored cell.
d6905 10
a6914 6
    if ((flags & TERM_COLOR_FLAGS(xw)) == BG_COLOR
#if OPT_WIDE_CHARS
	&& chi == 0
#endif
	&& clo == ' ') {
	flags &= ~TERM_COLOR_FLAGS(xw);
d7032 1
a7032 1
	TRACE(("ShowCursor calling drawXtermText cur(%d,%d) %s\n",
d7034 1
a7034 1
	       (filled ? "filled" : "outline")));
d7053 1
a7053 1
			      PAIRED_CHARS(&clo, &chi), 1, iswide(base));
d7084 3
a7088 2
    int x, y;
    Char clo;
a7091 1
    int base;
a7110 1
#if OPT_WIDE_CHARS
a7111 1
#endif
d7117 1
a7117 1
	if (clo == HIDDEN_LO && chi == HIDDEN_HI) {
d7127 3
a7129 1
	if (iswide(base))
d7133 26
a7172 8
    if (clo == 0
#if OPT_WIDE_CHARS
	&& chi == 0
#endif
	) {
	clo = ' ';
    }

d7191 1
a7191 1
			  PAIRED_CHARS(&clo, &chi), 1, iswide(base));
d7646 4
a7649 1
    if (IsXtermWidget(w)) {
d7651 1
a7651 1
	(void) SendMousePosition((XtermWidget) w, event);
d7665 3
a7667 1
    if (!IsXtermWidget(w) || *type != XA_STRING || *format != 8) {
a7670 1
	XtermWidget xw = (XtermWidget) w;
d7730 1
d7738 2
a7739 2
	atom_name = (xw->screen.mappedSelect
		     ? xw->screen.mappedSelect[0]
d7755 1
a7755 1
	xw->screen.MenuFontName(fontMenu_fontsel) =
d7757 2
@


1.5
log
@xterm 238. includes fix for CVE-2008-2383.
@
text
@d392 2
a393 2
    Bres(XtNallowFontOps, XtCAllowFontOps, screen.allowFontOp0, True),
    Bres(XtNallowTcapOps, XtCAllowTcapOps, screen.allowTcapOp0, True),
d395 1
a395 1
    Bres(XtNallowWindowOps, XtCAllowWindowOps, screen.allowWindowOp0, True),
@


1.4
log
@xterm 237. tested by krw@@ oga@@ and others.
@
text
@d1 1
a1 1
/* $XTermId: charproc.c,v 1.852 2008/09/14 21:27:54 tom Exp $ */
d392 2
d1241 2
a1242 2
	    prev = XTERM_CELL(screen->last_written_row,
			      screen->last_written_col);
d1272 1
a1272 1
	    if ((c = xtermPrinterControl((int) c)) == 0)
d1284 1
a1284 1
		param[nparam++] = (c & 0x7f) - 32;
d1452 2
a1453 1
	    print_area[print_used++] = sp->lastchar = thischar = c;
d1492 1
a1492 1
	    string_area[string_used++] = c;
d1679 1
a1679 1
	    param[nparam - 1] = 10 * row + (c - '0');
d1902 3
a1904 1
		    reply.a_param[count++] = 60 + screen->terminal_id / 100;
d1921 1
a1921 1
		reply.a_nparam = count;
d1942 1
a1942 1
		reply.a_nparam = count;
d2185 1
a2185 1
	    reply.a_pintro = sp->private_function ? '?' : 0;
d2197 2
a2198 2
		reply.a_param[count++] = screen->cur_row + 1;
		reply.a_param[count++] = screen->cur_col + 1;
d2203 3
a2205 1
		reply.a_param[count++] = 13;	/* implement printer */
d2209 3
a2211 1
		reply.a_param[count++] = 20;	/* UDK always unlocked */
d2215 7
a2221 5
		reply.a_param[count++] = 27;
		reply.a_param[count++] = 1;	/* North American */
		if (screen->terminal_id >= 400) {
		    reply.a_param[count++] = 0;		/* ready */
		    reply.a_param[count++] = 0;		/* LK201 */
d2226 1
d2228 1
a2228 1
		reply.a_param[count++] = 50;	/* locator ready */
d2230 1
a2230 1
		reply.a_param[count++] = 53;	/* no locator */
d2232 3
d2238 1
a2238 1
	    if ((reply.a_nparam = count) != 0)
d2297 1
a2297 1
		    reply.a_param[0] = row + 2;
d2346 1
a2346 1
		screen->gsets[sp->scstype] = c;
d2803 1
a2803 1
		repeated[0] = sp->lastchar;
d2925 2
a2926 2
    screen->utf8_inparse = (screen->utf8_mode != uFalse
			    && sp->parsestate != sos_table);
d3019 1
a3019 1
		int size = v_bufptr - v_buffer;		/* save across realloc */
d3120 1
a3120 1
    return (c);
d3394 2
a3395 2
    spot.x = CurCursorX(screen, screen->cur_row, screen->cur_col);
    spot.y = CursorY(screen, screen->cur_row) + screen->fs_ascent;
d3463 1
a3463 1
	int need_wrap = 0;
d3468 1
a3468 1
	    screen->do_wrap = 0;
d3492 1
a3492 1
		need_wrap = 1;
d3495 1
a3495 1
	    need_wrap = 1;
d3497 1
a3497 1
	    need_wrap = 1;
d3555 1
a3555 1
		screen->do_wrap = 0;
d3588 1
a3588 1
    int my_len = 0;
d3691 3
a3693 3
				   info->menu_height
				   - save.menu_height
				   + screen->fullVwin.fullheight,
d3718 1
a3718 1
SetCursorBlink(TScreen * screen, int enable)
d3734 1
a3734 1
    SetCursorBlink(screen, !(screen->cursor_blink));
d3772 1
a3772 1
	flag = (IsSM()) ? ON : OFF
d3777 1
a3777 1
		     unsigned mode)
d3802 1
d3857 1
a3857 1
	    j = xw->flags;
d3859 1
a3859 1
	    if ((xw->flags ^ j) & REVERSE_VIDEO)
d4321 1
a4321 1
	    DoRM(DP_X_X10MSE, screen->send_mouse_pos);
d4393 1
a4393 1
	    DoRM(DP_X_MOUSE, screen->send_mouse_pos);
d4540 3
a4542 1
	reply.a_param[0] = (win_attrs.map_state == IsViewable) ? 1 : 2;
d4556 2
a4557 2
	reply.a_param[1] = win_attrs.x;
	reply.a_param[2] = win_attrs.y;
d4575 2
a4576 2
	reply.a_param[1] = Height(screen);
	reply.a_param[2] = Width(screen);
d4587 2
a4588 2
	reply.a_param[1] = MaxRows(screen);
	reply.a_param[2] = MaxCols(screen);
d4604 2
a4605 2
	reply.a_param[1] = root_height / FontHeight(screen);
	reply.a_param[2] = root_width / FontWidth(screen);
d4742 2
a4743 2
	buf[len++] = tmp[0];
	buf[len++] = tmp[1];
d4746 1
a4746 1
    if ((buf[len++] = c) == '\r' && (xw->flags & LINEFEED)) {
d4831 1
a4831 1
		   (unsigned) (rows - top) * FontHeight(screen),
d4964 2
a4965 1
#define okDimension(src,dst) ((src <= 32767) && ((dst = src) == src))
d4979 2
a4980 2
    if ((askedWidth = cols) < cols
	|| (askedHeight = rows) < rows)
d4991 1
a4991 1
	if ((value = rows) != 0) {
d4993 3
a4995 3
		value = MaxRows(screen);
	    value *= FontHeight(screen);
	    value += (2 * screen->border);
d5000 1
a5000 1
	if ((value = cols) != 0) {
d5002 4
a5005 3
		value = MaxCols(screen);
	    value *= FontWidth(screen);
	    value += (2 * screen->border) + ScrollbarWidth(screen);
d5018 1
a5018 1
	askedHeight = attrs.height;
d5020 1
a5020 1
	askedWidth = attrs.width;
d5023 2
a5024 2
	Dimension high = xw->misc.limit_resize * attrs.height;
	Dimension wide = xw->misc.limit_resize * attrs.width;
d5026 1
a5026 1
	    high = attrs.height;
d5030 1
a5030 1
	    wide = attrs.width;
d5235 1
a5235 1
		  ? strlen(request->misc.default_font.f_n)
d5252 1
a5252 1
		request->misc.callfilter = is_utf8 ? 0 : 1;
d5273 1
a5273 1
	request->misc.callfilter = is_utf8 ? 0 : 1;
d5321 1
a5321 1
    request->screen.utf8_inparse = (request->screen.utf8_mode != uFalse);
d5584 2
d5591 2
d6061 2
a6062 1
    if (screen->scrollWidget)
d6064 1
a6091 1
    XtUninstallTranslations(screen->scrollWidget);
d6241 3
a6243 2
	xpos += DisplayWidth(screen->display, DefaultScreen(screen->display))
	    - width - (BorderWidth(XtParent(xw)) * 2);
d6246 3
a6248 2
	ypos += DisplayHeight(screen->display, DefaultScreen(screen->display))
	    - height - (BorderWidth(XtParent(xw)) * 2);
d6436 1
a6436 1
    screen->do_wrap = 0;
d6443 1
a6443 1
	screen->alternate = !screen->alternate;
d6668 1
a6668 1
	j = XFontsOfFontSet(term->screen.fs, &fonts, &font_name_list);
d6734 2
a6735 2
    Bool refresh_needed = False;
    Bool fonts_redone = False;
d6764 2
a6765 1
	newvt->misc.re_verse = !newvt->misc.re_verse;	/* ReverseVideo toggles */
d6902 1
a6902 2
	fg_bg = (SCRN_BUF_FGRND(screen, screen->cursorp.row)[cursor_col] << 8)
	    | (SCRN_BUF_BGRND(screen, screen->cursorp.row)[cursor_col]);
d7041 1
a7041 1
	    screen->box->x = x;
d7043 1
a7043 1
		screen->box->y = y;
d7045 1
a7045 1
		screen->box->y = y + FontHeight(screen) - 2;
d7112 1
a7112 2
	fg_bg = (SCRN_BUF_FGRND(screen, screen->cursorp.row)[cursor_col] << 8)
	    | (SCRN_BUF_BGRND(screen, screen->cursorp.row)[cursor_col]);
d7164 3
a7166 2
	unsigned long interval = (screen->cursor_state == ON ?
				  screen->blink_on : screen->blink_off);
d7371 1
a7371 1
	screen->jumpscroll = !(xw->flags & SMOOTHSCROLL);
d7375 6
a7380 4
	    Dimension reqWidth = (80 * FontWidth(screen)
				  + 2 * screen->border + ScrollbarWidth(screen));
	    Dimension reqHeight = (FontHeight(screen)
				   * MaxRows(screen) + 2 * screen->border);
d7446 1
a7446 1
    for (i = 0, len = strlen(s), acc = 0, numbers = digits = 0;
d7448 1
a7448 1
	Char c = s[i];
d7567 1
a7567 1
	pmapClass[0] = toupper(CharOf(pmapClass[0]));
d7687 1
a7687 1
    static int atomCount = 0;
d7689 1
a7689 1
    int a;
@


1.3
log
@xterm-236. Tested by form@@ and simon@@.
@
text
@d1 1
a1 1
/* $XTermId: charproc.c,v 1.848 2008/07/27 19:00:21 tom Exp $ */
d508 1
d3639 6
a3644 15
	    /*
	     * Some window managers modify the configuration during
	     * initialization.  Skip notification events that we know are
	     * obsolete because there is already another in the queue.
	     */
	    do {
		height = event->xconfigure.height;
		width = event->xconfigure.width;
		TRACE(("HandleStructNotify(ConfigureNotify) %d,%d %dx%d\n",
		       event->xconfigure.y, event->xconfigure.x,
		       event->xconfigure.height, event->xconfigure.width));

	    } while (XCheckTypedWindowEvent(XtDisplay(xw),
					    event->xconfigure.window,
					    ConfigureNotify, event));
d5114 3
a5116 3
#define init_Dres(name) \
	TRACE(("init " #name " = %f\n", \
		wnew->name = request->name))
d5124 4
d5132 6
a5137 5
#define init_Bres(name) wnew->name = request->name
#define init_Dres(name) wnew->name = request->name
#define init_Ires(name) wnew->name = request->name
#define init_Sres(name) wnew->name = x_strtrim(request->name)
#define init_Tres(offset) fill_Tres(wnew, request, offset)
d5456 1
d5584 1
a5584 1
	init_Sres(screen.MenuFontName(i));
d5800 1
a5800 1
	init_Dres(misc.face_size[i]);
d6065 1
a6065 1
    XtUninstallTranslations((Widget)xw);
d6068 1
a6068 1
    XtUninstallTranslations((Widget)XtParent(xw));
d6070 1
a6070 1
    XtUninstallTranslations((Widget)SHELL_OF(xw));
d6894 1
a6894 1
    filled = (screen->select || screen->always_highlight);
d7015 4
a7018 1
	    screen->box->y = y;
@


1.2
log
@update to xterm 234. tested by merdely@@, 'looks ok' deraadt@@.
@
text
@d1 1
a1 1
/* $XTermId: charproc.c,v 1.836 2008/02/29 01:55:13 tom Exp $ */
d617 2
d1085 1
a1085 1
    else WHICH_TABLE (csi_table);
d1089 11
a1106 10
    else WHICH_TABLE (dec_table);
    else WHICH_TABLE (dec2_table);
    else WHICH_TABLE (dec3_table);
    else WHICH_TABLE (cigtable);
    else WHICH_TABLE (eigtable);
    else WHICH_TABLE (esc_table);
    else WHICH_TABLE (esc_sp_table);
    else WHICH_TABLE (scrtable);
    else WHICH_TABLE (scstable);
    else WHICH_TABLE (sos_table);
d1163 1
d1175 26
a1296 5
	/*
	 * The parsing tables all have 256 entries.  If we're supporting
	 * wide characters, we handle them by treating them the same as
	 * printing characters.
	 */
d1298 11
d1311 5
d1633 1
a1633 2
	    sp->scstype = 0;
	    sp->parsestate = scstable;
d1638 1
a1638 2
	    sp->scstype = 1;
	    sp->parsestate = scstable;
d1643 1
a1643 2
	    sp->scstype = 2;
	    sp->parsestate = scstable;
d1648 16
a1663 2
	    sp->scstype = 3;
	    sp->parsestate = scstable;
d2312 1
a2312 6
#if OPT_VT52_MODE
	    if (screen->vtXX_level == 0)
		sp->groundtable = vt52_table;
	    else if (screen->terminal_id >= 100)
		sp->groundtable = ansi_table;
#endif
d2925 1
a2925 6
#if OPT_VT52_MODE
    myState.groundtable = screen->vtXX_level ? ansi_table : vt52_table;
#else
    myState.groundtable = ansi_table;
#endif
    myState.parsestate = myState.groundtable;
d2929 5
a2933 4
    for (;;) {
	if (!doparsing(xw, doinput(), &myState))
	    return;
    }
d3133 9
a3141 9
	    stat = XtMakeResizeRequest((Widget) xw,
				       ((Dimension) FontWidth(screen)
					* (tt_width)
					+ 2 * screen->border
					+ screen->fullVwin.sb_info.width),
				       ((Dimension) FontHeight(screen)
					* (tt_length)
					+ 2 * screen->border),
				       &replyWidth, &replyHeight);
d3426 1
a3426 1
	|| (screen->vt100_graphics && charset == '0'))
d3428 1
a3428 2

	if (!xtermCharSetOut(buf, buf + len, charset))
d3605 2
a3606 1
    TScreen *screen = TScreenOf(term);
d3636 17
a3653 1
	    TRACE(("HandleStructNotify(ConfigureNotify)\n"));
d3658 2
a3659 2
	    if (term->screen.Vshow) {
		VTwin *Vwin = WhichVWin(&(term->screen));
d3682 6
a3687 6
			XtMakeResizeRequest((Widget) term,
					    screen->fullVwin.fullwidth,
					    info->menu_height
					    - save.menu_height
					    + screen->fullVwin.fullheight,
					    NULL, NULL);
d3693 2
a3694 19
	    int height, width;

	    /*
	     * Some window managers modify the configuration during
	     * initialization.  Skip notification events that we know are
	     * obsolete because there is already another in the queue.
	     */
	    do {
		height = event->xconfigure.height;
		width = event->xconfigure.width;
		TRACE(("HandleStructNotify(ConfigureNotify) %dx%d\n",
		       event->xconfigure.height, event->xconfigure.width));

	    } while (XCheckTypedWindowEvent(XtDisplay(term),
					    event->xconfigure.window,
					    ConfigureNotify, event));

	    if (height != term->hints.height || width != term->hints.width)
		RequestResize(term, height, width, False);
d4048 22
d4827 7
d4844 2
a4845 1
    size_t len = ScrnPointers(screen, (unsigned) MaxRows(screen));
d4847 4
a4850 3
    memcpy((char *) screen->save_ptr, (char *) screen->visbuf, len);
    memcpy((char *) screen->visbuf, (char *) screen->altbuf, len);
    memcpy((char *) screen->altbuf, (char *) screen->save_ptr, len);
d4884 1
d4890 1
d5026 3
a5028 7
    status = XtMakeResizeRequest((Widget) xw,
				 askedWidth, askedHeight,
				 &replyWidth, &replyHeight);
    TRACE(("...RequestResize XtMakeResizeRequest %dx%d -> %dx%d (status %d)\n",
	   askedHeight, askedWidth,
	   replyHeight, replyWidth,
	   status));
d5966 1
d6067 6
d6270 3
a6272 5
    TRACE(("make resize request %dx%d\n", height, width));
    (void) XtMakeResizeRequest((Widget) xw,
			       (Dimension) width, (Dimension) height,
			       &xw->core.width, &xw->core.height);
    TRACE(("...made resize request %dx%d\n", xw->core.height, xw->core.width));
d6417 8
a6428 4
    for (i = 0; i < 2; ++i) {
	screen->alternate = !screen->alternate;
	CursorSave(xw);
    }
d7356 4
a7359 5
	    XtMakeResizeRequest((Widget) xw,
				reqWidth,
				reqHeight,
				&replyWidth, &replyHeight);
	    TRACE(("...result %dx%d\n", replyHeight, replyWidth));
@


1.1
log
@Initial revision
@
text
@d1 1
a1 3
/* $XTermId: charproc.c,v 1.727 2006/08/03 23:52:22 tom Exp $ */

/* $XFree86: xc/programs/xterm/charproc.c,v 3.185 2006/06/20 00:42:38 dickey Exp $ */
d5 1
a5 1
Copyright 1999-2005,2006 by Thomas E. Dickey
a133 6
#if OPT_ZICONBEEP || OPT_TOOLBAR
#define HANDLE_STRUCT_NOTIFY 1
#else
#define HANDLE_STRUCT_NOTIFY 0
#endif

a140 3
static void WriteText(XtermWidget xw,
		      PAIRED_CHARS(Char * str, Char * str2),
		      Cardinal len);
d260 1
a274 1
    { "delete-is-del",		HandleDeleteIsDEL },
d294 1
d297 2
d300 1
a300 1
    { "set-marginbell",		HandleMarginBell },
a309 1
    { "set-pop-on-bell",	HandleSetPopOnBell },
d335 3
d392 1
d394 3
d404 1
d423 1
d433 1
d453 1
d461 1
d501 1
a501 1
    Fres("iconFont", "IconFont", screen.fnt_icon, XtDefaultFont),
d535 4
d546 3
d639 1
a639 1
    Bres(XtNtekStartup, XtCTekStartup, screen.TekEmu, False),
d655 2
d683 8
a690 1
    Dres(XtNfaceSize, XtCFaceSize, misc.face_size, DEFFACESIZE),
d815 5
d843 5
a847 7
    if (NormalGC(screen) != NormalBoldGC(screen)) {
	XSetForeground(screen->display, NormalBoldGC(screen), fg);
	XSetBackground(screen->display, ReverseBoldGC(screen), fg);
    } else {
	XSetForeground(screen->display, NormalGC(screen), fg);
	XSetBackground(screen->display, ReverseGC(screen), fg);
    }
d873 5
a877 7
    if (NormalGC(screen) != NormalBoldGC(screen)) {
	XSetBackground(screen->display, NormalBoldGC(screen), bg);
	XSetForeground(screen->display, ReverseBoldGC(screen), bg);
    } else {
	XSetBackground(screen->display, NormalGC(screen), bg);
	XSetForeground(screen->display, ReverseGC(screen), bg);
    }
d1046 1
a1046 1
set_mod_fkeys(XtermWidget xw, int which, int what)
d1049 1
a1049 1
    xw->keyboard.modify_now.field = (what == DEFAULT) \
d1051 1
a1051 1
				     : param[1]; \
d1202 2
a1203 1
	    && my_wcwidth((int) c) == 0) {
d1211 4
d1216 4
a1219 1
	    if (precomposed != -1) {
d1228 1
d1479 1
a1479 1
	    if (sp->string_mode == OSC) {
d1529 2
a1530 1
	    do_xevents();
d1571 1
a1571 1
	    xterm_DECDHL(c == '3');
d1576 1
a1576 1
	    xterm_DECSWL();
d1581 1
a1581 1
	    xterm_DECDWL();
d1808 1
a1808 1
		unparseputc(xw, ESC);
d1821 1
a1821 1
		reply.a_type = CSI;
d1875 1
a1875 1
		reply.a_type = CSI;
d1896 1
a1896 1
		unparseputc1(xw, DCS);
d1900 1
a1900 1
		unparseputc1(xw, ST);
d2126 1
a2126 1
	    reply.a_type = CSI;
d2226 1
a2226 1
		    reply.a_type = CSI;
d2252 1
a2252 1
	    if (screen->TekEmu)
d2276 1
a2276 1
	    ScrnFillRectangle(xw, &myRect, 'E', 0);
d2405 1
a2405 1
	    case APC:
d2408 1
a2408 1
	    case DCS:
d2411 2
a2412 2
	    case OSC:
		do_osc(xw, string_area, string_used, ST);
d2414 1
a2414 1
	    case PM:
d2417 1
a2417 1
	    case SOS:
d2425 1
a2425 1
	    sp->string_mode = SOS;
d2431 1
a2431 1
	    sp->string_mode = PM;
d2437 1
a2437 1
	    sp->string_mode = DCS;
d2443 1
a2443 1
	    sp->string_mode = APC;
d2482 1
a2482 1
	    TRACE(("CASE_NPL - cursor next line\n"));
a2490 1
	    do_xevents();
d2566 1
d2646 1
a2646 1
	    ScrnFillRectangle(xw, &myRect, ' ', 0);
d2656 1
a2656 1
		ScrnFillRectangle(xw, &myRect, param[0], xw->flags);
d2718 1
a2718 1
	    sp->string_mode = OSC;
d2736 1
d2829 1
a2829 1
		set_mod_fkeys(xw, param[0], nparam > 1 ? param[1] : DEFAULT);
d2832 1
a2832 1
		    set_mod_fkeys(xw, row, DEFAULT);
d2837 5
a2841 1
	    xw->keyboard.modify_now.function_keys = -1;
d2844 8
d3109 1
a3109 1
	if (eventMode == NORMAL
d3115 1
a3115 1
		WindowScroll(screen, 0);
d3140 1
a3140 1
	    if (eventMode != NORMAL)
d3183 1
a3183 1
	if (eventMode == NORMAL
d3188 1
a3188 1
		WindowScroll(screen, 0);	/* Scroll to bottom */
d3244 1
a3244 1
	if (eventMode != NORMAL)
d3281 2
a3282 7
	    /*
	     * When session management is enabled, we should not block since
	     * session related events can arrive any time.
	     */
	    select_timeout.tv_sec = 1;
	    select_timeout.tv_usec = 0;
	    time_select = 1;
d3316 1
a3316 1
    TScreen *screen = &term->screen;
d3347 12
d3409 1
a3409 6
	if (screen->do_wrap && (xw->flags & WRAPAROUND)) {
	    /* mark that we had to wrap this line */
	    ScrnSetWrapped(screen, screen->cur_row);
	    xtermAutoPrint('\n');
	    xtermIndex(xw, 1);
	    set_cur_col(screen, 0);
d3411 5
a3415 2
	    width_available = MaxCols(screen) - screen->cur_col;
	    next_col = screen->cur_col;
d3429 2
d3433 1
a3433 1
	    if (chars_chomped > 0 || (xw->flags & WRAPAROUND))
d3435 1
d3461 4
a3464 3
	    for (j = offset; j < offset + chars_chomped; j++) {
		k = j - offset;
		lobyte[k] = buf[j];
d3466 1
a3466 1
		    hibyte[k] = (buf[j] >> 8);
d3471 1
d3476 1
a3476 1
		      chars_chomped);
d3496 1
a3496 6
	    if (screen->do_wrap && (xw->flags & WRAPAROUND)) {
		/* mark that we had to wrap this line */
		ScrnSetWrapped(screen, screen->cur_row);
		xtermAutoPrint('\n');
		xtermIndex(xw, 1);
		set_cur_col(screen, 0);
d3498 5
a3502 3
		this_col = last_col + 1;
	    } else
		this_col = 1;
d3514 3
a3516 3
	 * the call to WriteText updates screen->cur_col.
	 * If screen->cur_col != next_col, we must have
	 * hit the right margin, so set the do_wrap flag.
a3523 13
#if HANDLE_STRUCT_NOTIFY
/* Flag icon name with "*** "  on window output when iconified.
 * I'd like to do something like reverse video, but I don't
 * know how to tell this to window managers in general.
 *
 * mapstate can be IsUnmapped, !IsUnmapped, or -1;
 * -1 means no change; the other two are set by event handlers
 * and indicate a new mapstate.  !IsMapped is done in the handler.
 * we worry about IsUnmapped when output occurs.  -IAN!
 */
static int mapstate = -1;
#endif /* HANDLE_STRUCT_NOTIFY */

a3548 116
/*
 * write a string str of length len onto the screen at
 * the current cursor position.  update cursor position.
 */
static void
WriteText(XtermWidget xw, PAIRED_CHARS(Char * str, Char * str2), Cardinal len)
{
    TScreen *screen = &(xw->screen);
    ScrnPtr PAIRED_CHARS(temp_str = 0, temp_str2 = 0);
    unsigned test;
    unsigned flags = xw->flags;
    unsigned fg_bg = makeColorPair(xw->cur_foreground, xw->cur_background);
    unsigned cells = visual_width(PAIRED_CHARS(str, str2), len);
    GC currentGC;

    TRACE(("WriteText (%2d,%2d) (%d) %3d:%s\n",
	   screen->cur_row,
	   screen->cur_col,
	   curXtermChrSet(xw, screen->cur_row),
	   len, visibleChars(PAIRED_CHARS(str, str2), len)));

    if (ScrnHaveSelection(screen)
	&& ScrnIsLineInSelection(screen, INX2ROW(screen, screen->cur_row))) {
	ScrnDisownSelection(xw);
    }

    if (INX2ROW(screen, screen->cur_row) <= screen->max_row) {
	if (screen->cursor_state)
	    HideCursor();

	if (flags & INSERT) {
	    InsertChar(xw, cells);
	}
	if (!AddToRefresh(screen)) {

	    if (screen->scroll_amt)
		FlushScroll(xw);

	    if (flags & INVISIBLE) {
		if (cells > len) {
		    str = temp_str = TypeMallocN(Char, cells);
		    if (str == 0)
			return;
		}
		if_OPT_WIDE_CHARS(screen, {
		    if (cells > len) {
			str2 = temp_str2 = TypeMallocN(Char, cells);
		    }
		});
		len = cells;

		memset(str, ' ', len);
		if_OPT_WIDE_CHARS(screen, {
		    if (str2 != 0)
			memset(str2, 0, len);
		});
	    }

	    TRACE(("WriteText calling drawXtermText (%d,%d)\n",
		   screen->cur_col,
		   screen->cur_row));

	    test = flags;
	    checkVeryBoldColors(test, xw->cur_foreground);

	    /* make sure that the correct GC is current */
	    currentGC = updatedXtermGC(xw, flags, fg_bg, False);

	    drawXtermText(xw, test & DRAWX_MASK, currentGC,
			  CurCursorX(screen, screen->cur_row, screen->cur_col),
			  CursorY(screen, screen->cur_row),
			  curXtermChrSet(xw, screen->cur_row),
			  PAIRED_CHARS(str, str2), len, 0);

	    resetXtermGC(xw, flags, False);
	}
    }

    ScreenWrite(xw, PAIRED_CHARS(str, str2), flags, fg_bg, len);
    CursorForward(screen, (int) cells);
#if OPT_ZICONBEEP
    /* Flag icon name with "***"  on window output when iconified.
     */
    if (zIconBeep && mapstate == IsUnmapped && !zIconBeep_flagged) {
	static char *icon_name;
	static Arg args[] =
	{
	    {XtNiconName, (XtArgVal) & icon_name}
	};

	icon_name = NULL;
	XtGetValues(toplevel, args, XtNumber(args));

	if (icon_name != NULL) {
	    zIconBeep_flagged = True;
	    Changename(icon_name);
	}
	if (zIconBeep > 0) {
#if defined(HAVE_XKB_BELL_EXT)
	    XkbBell(XtDisplay(toplevel), VShellWindow, zIconBeep, XkbBI_Info);
#else
	    XBell(XtDisplay(toplevel), zIconBeep);
#endif
	}
    }
    mapstate = -1;
#endif /* OPT_ZICONBEEP */
    if (temp_str != 0)
	free(temp_str);
    if_OPT_WIDE_CHARS(screen, {
	if (temp_str2 != 0)
	    free(temp_str2);
    });
    return;
}

d3563 1
d3569 2
a3570 2
	if (zIconBeep_flagged) {
	    zIconBeep_flagged = False;
d3576 1
a3576 1
		    zIconBeep_flagged = True;
d3580 1
a3580 1
		Changename(buf);
d3600 1
a3600 2
		TScreen *screen = &term->screen;
		struct _vtwin *Vwin = WhichVWin(&(term->screen));
d3660 2
a3661 1
	TRACE(("HandleStructNotify(event %d)\n", event->type));
d3720 18
a3737 2
#define set_mousemode(mode) \
	screen->send_mouse_pos = (func == bitset) ? mode : MOUSE_OFF
d3739 1
a3739 1
	((func == bitset)		\
d3742 1
d3755 1
a3755 1
	TRACE(("%s %d\n", (func == bitset) ? "DECSET" : "DECRST", param[i]));
d3762 1
a3762 1
	    if (func == bitset) {	/* ANSI (VT100) */
d3789 1
a3789 1
		if ((j = func == bitset ? 132 : 80) !=
d3797 1
a3797 1
	    if (func == bitset) {
d3835 1
a3835 1
	    ShowToolbar(func == bitset);
d3841 1
a3841 1
		screen->cursor_blink_esc = (func == bitset) ? ON : OFF;
d3847 1
a3847 1
	    screen->printer_formfeed = (func == bitset) ? ON : OFF;
d3850 1
a3850 1
	    screen->printer_extent = (func == bitset) ? ON : OFF;
d3853 1
a3853 1
	    screen->cursor_set = (func == bitset) ? ON : OFF;
d3856 1
a3856 1
	    if (screen->fullVwin.sb_info.width != ((func == bitset) ? ON : OFF))
d3861 1
a3861 1
	    xw->misc.shift_fonts = (func == bitset) ? ON : OFF;
d3866 1
a3866 1
	    if (func == bitset && !(screen->inhibit & I_TEK)) {
d3868 1
a3868 1
		screen->TekEmu = True;
d3873 1
a3873 1
	    screen->c132 = (func == bitset);
d3877 1
a3877 1
	    screen->curses = (func == bitset);
d3884 1
a3884 1
	    screen->marginbell = (func == bitset);
d3900 1
a3900 1
	    if (func == bitset)
d3912 1
a3912 1
		if (func == bitset) {
d3921 1
a3921 1
		if (func == bitset) {
d3927 1
d3930 1
a3930 1
		if (func == bitset) {
d3939 1
a3939 1
		if (func == bitset) {
d3975 5
d3981 1
a3981 1
	    screen->scrollttyoutput = (func == bitset) ? ON : OFF;
d3985 1
a3985 1
	    screen->scrollkey = (func == bitset) ? ON : OFF;
d3989 1
a3989 1
	    xw->screen.input_eight_bits = (func == bitset) ? ON : OFF;
d3994 1
a3994 1
	    xw->misc.real_NumLock = (func == bitset) ? ON : OFF;
d3998 1
a3998 1
	    screen->meta_sends_esc = (func == bitset) ? ON : OFF;
d4003 1
a4003 1
	    screen->delete_is_del = (func == bitset) ? ON : OFF;
d4008 1
a4008 1
		if (func == bitset)
d4014 6
a4019 1
#ifdef OPT_SUN_FUNC_KEYS
d4021 1
a4021 1
	    set_keyboard_type(xw, keyboardIsSun, func == bitset);
d4026 1
a4026 1
	    set_keyboard_type(xw, keyboardIsHP, func == bitset);
d4031 1
a4031 1
	    set_keyboard_type(xw, keyboardIsSCO, func == bitset);
d4035 1
a4035 1
	    set_keyboard_type(xw, keyboardIsLegacy, func == bitset);
d4039 1
a4039 1
	    set_keyboard_type(xw, keyboardIsVT220, func == bitset);
a4093 1

d4130 3
d4155 5
d4323 5
d4370 2
a4371 2
    reply.a_type = ESC;
    unparseputc(xw, ESC);
d4389 1
a4389 1
    unparseputc(xw, ESC);
d4465 1
a4465 1
	reply.a_type = CSI;
d4478 1
a4478 1
	reply.a_type = CSI;
d4493 1
a4493 1
	reply.a_type = CSI;
d4509 1
a4509 1
	reply.a_type = CSI;
d4526 1
a4526 1
	reply.a_type = CSI;
d4588 1
a4588 1
	    unparseputc(xw, A2E(ESC));
d4603 7
a4609 7
    if (c == ESC
	|| c == DCS
	|| c == CSI
	|| c == OSC
	|| c == PM
	|| c == APC
	|| c == SS3) {
d4752 7
a4758 10
	if (top == 0)
	    XClearWindow(screen->display, VWindow(screen));
	else
	    XClearArea(screen->display,
		       VWindow(screen),
		       (int) OriginX(screen),
		       (int) top * FontHeight(screen) + screen->border,
		       (unsigned) Width(screen),
		       (unsigned) (rows - top) * FontHeight(screen),
		       False);
d4783 1
a4783 1
    TScreen *screen = &term->screen;
d4835 1
a4835 1
    TScreen *screen = &term->screen;
a4883 3
#ifndef nothack
    long supp;
#endif
d4948 1
a4948 3
    if (!XGetWMNormalHints(screen->display, VShellWindow,
			   &xw->hints, &supp))
	bzero(&xw->hints, sizeof(xw->hints));
d4997 1
a4997 1
    TScreen *screen = &term->screen;
d5000 2
d5011 2
d5019 1
a5019 1
    TScreen *screen = &term->screen;
d5092 1
a5092 1
    } else if (!x_strcasecmp(name, XtDefaultForeground)) {
d5097 1
a5097 1
    } else if (!x_strcasecmp(name, XtDefaultBackground)) {
d5286 6
d5321 5
d5401 1
a5410 1
    init_Bres(screen.selectToClipboard);
d5446 1
d5449 1
a5449 1
    init_Bres(screen.TekEmu);
d5459 3
d5465 3
d5469 1
a5469 3
    init_Bres(screen.i18nSelections);
    init_Bres(screen.brokenSelections);
    init_Bres(screen.always_highlight);
d5471 1
d5490 2
d5495 1
d5500 1
d5503 2
d5506 1
a5506 1
    wnew->screen.fnt_icon = request->screen.fnt_icon;
d5517 1
a5517 2
    /* set default in realize proc */
    wnew->screen.MenuFontName(fontMenu_fontdefault) = NULL;
a5519 1
    wnew->screen.menu_font_number = fontMenu_fontdefault;
d5521 7
d5540 4
d5594 1
a5594 1
	if (!x_strcasecmp(wnew->screen.Acolors[i].resource, XtDefaultForeground)) {
d5597 1
a5597 1
	} else if (!x_strcasecmp(wnew->screen.Acolors[i].resource, XtDefaultBackground)) {
d5680 22
d5730 3
a5732 1
    init_Dres(misc.face_size);
d5745 1
d5761 13
d5799 3
a5801 1
		   + 1);
d5804 1
d5839 1
a5839 1
    if (zIconBeep)
a5867 3
#if OPT_TEK4014
    wnew->screen.whichTwin = &wnew->screen.fullTwin;
#endif
d5909 1
a5909 1
static void
d5913 7
a5919 4
    GC cursorGC = screen->cursorGC;
    GC fillCursorGC = screen->fillCursorGC;
    GC reverseCursorGC = screen->reversecursorGC;
    GC cursorOutlineGC = screen->cursoroutlineGC;
d5921 7
a5927 47
#if OPT_ISO_COLORS
    if (screen->colorMode) {
	if (cursorGC)
	    XFreeGC(screen->display, cursorGC);
	screen->cursorGC = 0;

	if (fillCursorGC
	    && (fillCursorGC != cursorGC))
	    XFreeGC(screen->display, fillCursorGC);
	screen->fillCursorGC = 0;

	if (reverseCursorGC
	    && (reverseCursorGC != cursorGC)
	    && (reverseCursorGC != fillCursorGC))
	    XFreeGC(screen->display, screen->reversecursorGC);
	screen->reversecursorGC = 0;

	if (cursorOutlineGC
	    && (cursorOutlineGC != cursorGC)
	    && (cursorOutlineGC != fillCursorGC)
	    && (cursorOutlineGC != reverseCursorGC))
	    XFreeGC(screen->display, screen->cursoroutlineGC);
	screen->cursoroutlineGC = 0;
    } else
#endif
    {
	if (cursorGC)
	    XtReleaseGC((Widget) xw, cursorGC);
	screen->cursorGC = 0;

	if ((fillCursorGC)
	    && (fillCursorGC != cursorGC))
	    XtReleaseGC((Widget) xw, fillCursorGC);
	screen->fillCursorGC = 0;

	if ((reverseCursorGC)
	    && (reverseCursorGC != cursorGC)
	    && (reverseCursorGC != fillCursorGC))
	    XtReleaseGC((Widget) xw, reverseCursorGC);
	screen->reversecursorGC = 0;

	if ((cursorOutlineGC)
	    && (cursorOutlineGC != cursorGC)
	    && (cursorOutlineGC != fillCursorGC)
	    && (cursorOutlineGC != reverseCursorGC))
	    XtReleaseGC((Widget) xw, cursorOutlineGC);
	screen->cursoroutlineGC = 0;
d5931 13
d5945 1
d5947 1
a5947 1
releaseWindowGCs(Widget w, struct _vtwin *win)
d5949 4
a5952 4
    XtReleaseGC(w, win->normalGC);
    XtReleaseGC(w, win->reverseGC);
    XtReleaseGC(w, win->normalboldGC);
    XtReleaseGC(w, win->reverseboldGC);
d5955 1
d5970 7
a5976 22
    if (screen->save_ptr) {
	free(screen->save_ptr);
	TRACE(("freed screen->save_ptr\n"));
    }

    if (screen->sbuf_address) {
	free(screen->sbuf_address);
	TRACE(("freed screen->sbuf_address\n"));
    }
    if (screen->allbuf) {
	free(screen->allbuf);
	TRACE(("freed screen->allbuf\n"));
    }

    if (screen->abuf_address) {
	free(screen->abuf_address);
	TRACE(("freed screen->abuf_address\n"));
    }
    if (screen->altbuf) {
	free(screen->altbuf);
	TRACE(("freed screen->altbuf\n"));
    }
d5978 5
a5982 4
    if (screen->draw_buf) {
	free(screen->draw_buf);
	TRACE(("freed screen->draw_buf\n"));
    }
d5991 1
a5991 1
    releaseWindowGCs(w, &(screen->fullVwin));
d5993 1
a5993 1
    releaseWindowGCs(w, &(screen->iconVwin));
d5996 16
a6011 1
    xtermCloseFonts(screen, screen->fnts);
d6024 1
d6027 1
a6027 2
	if (screen->Tcolors[n].resource)
	    free(screen->Tcolors[n].resource);
d6029 1
d6032 1
a6032 2
	if (screen->selectExpr[n])
	    free(screen->selectExpr[n]);
d6040 4
d6056 1
d6066 5
a6070 1
    screen->MenuFontName(fontMenu_fontdefault) = xw->misc.default_font.f_n;
d6074 4
a6077 3
		       &(xw->misc.default_font),
		       False, 0)) {
	if (XmuCompareISOLatin1(xw->misc.default_font.f_n, "fixed") != 0) {
d6079 2
a6080 2
		    "%s:  unable to open font \"%s\", trying \"fixed\"....\n",
		    xterm_name, xw->misc.default_font.f_n);
d6082 4
a6085 3
				 xtermFontName("fixed"),
				 False, 0);
	    screen->MenuFontName(fontMenu_fontdefault) = "fixed";
d6090 1
a6090 1
    if (!screen->fnts[fNorm]) {
d6099 1
a6099 1
	    SetVTFont(xw, screen->menu_font_number, TRUE, NULL);
d6149 1
a6149 1
    bzero(&xw->hints, sizeof(xw->hints));
d6238 1
a6238 1
    if (xw->misc.active_icon && screen->fnt_icon) {
d6241 1
a6241 2
	unsigned long mask;
	XGCValues xgcv;
d6245 1
a6245 1
	xtermComputeFontInfo(xw, &(screen->iconVwin), screen->fnt_icon, 0);
d6269 11
a6279 2
	mask = (GCFont | GCForeground | GCBackground |
		GCGraphicsExposures | GCFunction);
a6280 16
	xgcv.font = screen->fnt_icon->fid;
	xgcv.foreground = T_COLOR(screen, TEXT_FG);
	xgcv.background = T_COLOR(screen, TEXT_BG);
	xgcv.graphics_exposures = True;		/* default */
	xgcv.function = GXcopy;

	screen->iconVwin.normalGC =
	    screen->iconVwin.normalboldGC =
	    XtGetGC(shell, mask, &xgcv);

	xgcv.foreground = T_COLOR(screen, TEXT_BG);
	xgcv.background = T_COLOR(screen, TEXT_FG);

	screen->iconVwin.reverseGC =
	    screen->iconVwin.reverseboldGC =
	    XtGetGC(shell, mask, &xgcv);
d6302 6
d6640 1
a6640 1
	    newvt->screen.MenuFontName(fontMenu_fontdefault) = newvt->misc.default_font.f_n;
d6648 1
a6648 1
	    newvt->screen.MenuFontName(fontMenu_fontdefault) = curvt->misc.default_font.f_n;
d6679 1
a6679 1
#define setGC(value) set_at = __LINE__, currentGC = value
d6702 2
d6707 1
d6712 4
a6715 1
    Pixel hi_pix = T_COLOR(screen, HIGHLIGHT_BG);
d6728 1
a6728 1
    if (eventMode != NORMAL)
d6816 6
a6821 1
    if (screen->select || screen->always_highlight) {
d6823 2
a6824 2
	    if (screen->cursorGC) {
		setGC(screen->cursorGC);
d6827 1
a6827 1
		    setGC(NormalBoldGC(screen));
d6829 1
a6829 1
		    setGC(NormalGC(screen));
d6832 1
d6834 9
a6842 6
	    if (hi_pix != T_COLOR(screen, TEXT_FG)
		&& hi_pix != fg_pix
		&& hi_pix != bg_pix
		&& hi_pix != xw->dft_foreground) {
		bg_pix = fg_pix;
		fg_pix = hi_pix;
a6844 1
	    EXCHANGE(fg_pix, bg_pix, tmp);
d6846 2
a6847 2
	    if (screen->reversecursorGC) {
		setGC(screen->reversecursorGC);
d6850 1
a6850 1
		    setGC(ReverseBoldGC(screen));
d6852 1
a6852 1
		    setGC(ReverseGC(screen));
d6857 1
a6857 1
	    XSetBackground(screen->display, currentGC, fg_pix);
d6859 1
a6859 1
	XSetForeground(screen->display, currentGC, bg_pix);
d6862 5
d6868 26
a6893 6
	    if (hi_pix != T_COLOR(screen, TEXT_FG)
		&& hi_pix != fg_pix
		&& hi_pix != bg_pix
		&& hi_pix != xw->dft_foreground) {
		bg_pix = fg_pix;
		fg_pix = hi_pix;
d6895 1
d6897 2
a6898 8
	    setGC(ReverseGC(screen));
	    XSetForeground(screen->display, currentGC, bg_pix);
	    XSetBackground(screen->display, currentGC, fg_pix);
	} else {		/* normal video */
	    setGC(NormalGC(screen));
	    XSetForeground(screen->display, currentGC, fg_pix);
	    XSetBackground(screen->display, currentGC, bg_pix);
	}
d6905 3
a6907 2
	TRACE(("ShowCursor calling drawXtermText cur(%d,%d)\n",
	       screen->cur_row, screen->cur_col));
d6909 1
d6921 6
a6926 5
		if (clo || chi)
		    drawXtermText(xw, (flags & DRAWX_MASK) | NOBACKGROUND,
				  currentGC, x, y,
				  curXtermChrSet(xw, screen->cur_row),
				  PAIRED_CHARS(&clo, &chi), 1, iswide(base));
d6931 5
a6935 1
	if (!screen->select && !screen->always_highlight) {
d6938 1
a6938 3
	    XDrawLines(screen->display, VWindow(screen),
		       screen->cursoroutlineGC ? screen->cursoroutlineGC
		       : currentGC,
d7039 6
a7044 5
	    if (clo || chi)
		drawXtermText(xw, (flags & DRAWX_MASK) | NOBACKGROUND,
			      currentGC, x, y,
			      curXtermChrSet(xw, screen->cur_row),
			      PAIRED_CHARS(&clo, &chi), 1, iswide(base));
d7188 1
a7188 1
    if (!XtIsRealized((Widget) xw)) {
d7228 5
a7232 2
	waitingForTrackInfo = False;
	eventMode = NORMAL;
d7497 4
a7500 2
    /* do nothing, but check for funny escape sequences */
    (void) SendMousePosition((XtermWidget) w, event);
d7505 1
a7505 1
DoSetSelectedFont(Widget w GCC_UNUSED,
d7510 1
a7510 1
		  unsigned long *length GCC_UNUSED,
d7513 1
a7513 3
    char *val = (char *) value;
    int len;
    if (*type != XA_STRING || *format != 8) {
d7515 56
a7570 17
	return;
    }
    len = strlen(val);
    if (len > 0) {
	if (val[len - 1] == '\n')
	    val[len - 1] = '\0';
	/* Do some sanity checking to avoid sending a long selection
	   back to the server in an OpenFont that is unlikely to succeed.
	   XLFD allows up to 255 characters and no control characters;
	   we are a little more liberal here. */
	if (len > 1000 || strchr(val, '\n'))
	    return;
	if (!xtermLoadFont(term,
			   xtermFontName(val),
			   True,
			   fontMenu_fontsel))
	    Bell(XkbBI_MinorError, 0);
d7575 1
a7575 1
FindFontSelection(XtermWidget xw, char *atom_name, Bool justprobe)
d7584 4
a7587 1
	atom_name = "PRIMARY";
d7615 1
a7616 2
    XGCValues xgcv;
    XtGCMask mask;
a7619 4
    GC new_cursorGC = NULL;
    GC new_cursorFillGC = NULL;
    GC new_reversecursorGC = NULL;
    GC new_cursoroutlineGC = NULL;
d7629 1
a7629 1
     * And, there are four situation when drawing a cursor, if we decide
d7645 7
a7651 42
#if OPT_ISO_COLORS
    /*
     * If we're using ANSI colors, the functions manipulating the SGR code will
     * use the same GC's.  To avoid having the cursor change color, we use the
     * Xlib calls rather than the Xt calls.
     *
     * Use the colorMode value to determine which we'll do (the VWindow may
     * not be set before the widget's realized, so it's tested separately).
     */
    if (screen->colorMode) {
	if (VWindow(screen) != 0 && (cc != bg)) {
	    /* we might have a colored foreground/background later */
	    xgcv.font = screen->fnts[fNorm]->fid;
	    mask = (GCForeground | GCBackground | GCFont);
	    xgcv.foreground = fg;
	    xgcv.background = cc;
	    new_cursorGC = XCreateGC(screen->display, VWindow(screen), mask, &xgcv);

	    xgcv.foreground = cc;
	    xgcv.background = fg;
	    new_cursorFillGC =
		XCreateGC(screen->display, VWindow(screen), mask, &xgcv);

	    if (screen->always_highlight) {
		new_reversecursorGC = (GC) 0;
		new_cursoroutlineGC = (GC) 0;
	    } else {
		xgcv.foreground = bg;
		xgcv.background = cc;
		new_reversecursorGC =
		    XCreateGC(screen->display, VWindow(screen), mask, &xgcv);
		xgcv.foreground = cc;
		xgcv.background = bg;
		new_cursoroutlineGC =
		    XCreateGC(screen->display, VWindow(screen), mask, &xgcv);
	    }
	    releaseCursorGCs(xw);
	    changed = True;
	}
    } else
#endif
    if (VWindow(screen) != 0 && (cc != bg)) {
d7653 2
a7654 2
	xgcv.font = screen->fnts[fNorm]->fid;
	mask = (GCForeground | GCBackground | GCFont);
d7656 2
a7657 7
	xgcv.foreground = fg;
	xgcv.background = cc;
	new_cursorGC = XtGetGC((Widget) xw, mask, &xgcv);

	xgcv.foreground = cc;
	xgcv.background = fg;
	new_cursorFillGC = XtGetGC((Widget) xw, mask, &xgcv);
d7660 6
a7665 2
	    new_reversecursorGC = (GC) 0;
	    new_cursoroutlineGC = (GC) 0;
d7667 5
a7671 6
	    xgcv.foreground = bg;
	    xgcv.background = cc;
	    new_reversecursorGC = XtGetGC((Widget) xw, mask, &xgcv);
	    xgcv.foreground = cc;
	    xgcv.background = bg;
	    new_cursoroutlineGC = XtGetGC((Widget) xw, mask, &xgcv);
a7672 1
	releaseCursorGCs(xw);
a7677 4
	screen->cursorGC = new_cursorGC;
	screen->fillCursorGC = new_cursorFillGC;
	screen->reversecursorGC = new_reversecursorGC;
	screen->cursoroutlineGC = new_cursoroutlineGC;
@


1.1.1.1
log
@Importing xterm 216
@
text
@@


1.1.1.2
log
@import xterm 225
@
text
@d1 1
a1 1
/* $XTermId: charproc.c,v 1.784 2007/03/20 23:59:25 tom Exp $ */
d7 1
a7 1
Copyright 1999-2006,2007 by Thomas E. Dickey
a304 1
    { "set-bellIsUrgent",	HandleBellIsUrgent },
d307 1
a308 2
    { "set-old-function-keys",	HandleOldFunctionKeys },
    { "set-pop-on-bell",	HandleSetPopOnBell },
d318 1
a343 3
#if OPT_EXEC_XTERM
    { "spawn-new-terminal",	HandleSpawnTerminal },
#endif
a398 3
    Bres(XtNaltIsNotMeta, XtCAltIsNotMeta, screen.alt_is_not_meta, False),
    Bres(XtNaltSendsEscape, XtCAltSendsEscape, screen.alt_sends_esc, False),
    Bres(XtNalwaysBoldMode, XtCAlwaysBoldMode, screen.always_bold_mode, False),
a405 1
    Bres(XtNbellIsUrgent, XtCBellIsUrgent, screen.bellIsUrgent, False),
a458 1
    Sres(XtNinitialFont, XtCInitialFont, screen.initial_font, NULL),
a531 4
#if OPT_CLIP_BOLD
    Bres(XtNuseClipping, XtCUseClipping, screen.use_clipping, True),
#endif

a538 1
    Tres(XtNhighlightTextColor, XtCHighlightTextColor, HIGHLIGHT_FG, XtDefaultBackground),
d629 1
a629 1
    Bres(XtNtekStartup, XtCTekStartup, misc.TekEmu, False),
d671 1
a671 8
#define RES_FACESIZE(n) Dres(XtNfaceSize #n, XtCFaceSize #n, misc.face_size[n], "0.0")
    RES_FACESIZE(1),
    RES_FACESIZE(2),
    RES_FACESIZE(3),
    RES_FACESIZE(4),
    RES_FACESIZE(5),
    RES_FACESIZE(6),
    Dres(XtNfaceSize, XtCFaceSize, misc.face_size[0], DEFFACESIZE),
d819 7
a825 5
    setCgsFore(xw, WhichVWin(screen), gcNorm, fg);
    setCgsBack(xw, WhichVWin(screen), gcNormReverse, fg);

    setCgsFore(xw, WhichVWin(screen), gcBold, fg);
    setCgsBack(xw, WhichVWin(screen), gcBoldReverse, fg);
d851 7
a857 5
    setCgsBack(xw, WhichVWin(screen), gcNorm, bg);
    setCgsFore(xw, WhichVWin(screen), gcNormReverse, bg);

    setCgsBack(xw, WhichVWin(screen), gcBold, bg);
    setCgsFore(xw, WhichVWin(screen), gcBoldReverse, bg);
a1189 9
#ifdef DEBUG
	    if (debug) {
		fprintf(stderr,
			"do_precomposition (U+%04X [%d], U+%04X [%d]) -> U+%04X [%d]\n",
			prev, my_wcwidth(prev), (int) c, my_wcwidth((int)
								    c),
			precomposed, my_wcwidth(precomposed));
	    }
#endif
d1191 1
a1191 4
	    /* substitute combined character with precomposed character 
	     * only if it does not change the width of the base character
	     */
	    if (precomposed != -1 && my_wcwidth(precomposed) == my_wcwidth(prev)) {
a1199 1

d1450 1
a1450 1
	    if (sp->string_mode == ANSI_OSC) {
d1541 1
a1541 1
	    xterm_DECDHL(xw, c == '3');
d1546 1
a1546 1
	    xterm_DECSWL(xw);
d1551 1
a1551 1
	    xterm_DECDWL(xw);
d1778 1
a1778 1
		unparseputc(xw, ANSI_ESC);
d1791 1
a1791 1
		reply.a_type = ANSI_CSI;
d1845 1
a1845 1
		reply.a_type = ANSI_CSI;
d1866 1
a1866 1
		unparseputc1(xw, ANSI_DCS);
d1870 1
a1870 1
		unparseputc1(xw, ANSI_ST);
d2096 1
a2096 1
	    reply.a_type = ANSI_CSI;
d2196 1
a2196 1
		    reply.a_type = ANSI_CSI;
d2222 1
a2222 1
	    if (TEK4014_ACTIVE(xw))
d2375 1
a2375 1
	    case ANSI_APC:
d2378 1
a2378 1
	    case ANSI_DCS:
d2381 2
a2382 2
	    case ANSI_OSC:
		do_osc(xw, string_area, string_used, ANSI_ST);
d2384 1
a2384 1
	    case ANSI_PM:
d2387 1
a2387 1
	    case ANSI_SOS:
d2395 1
a2395 1
	    sp->string_mode = ANSI_SOS;
d2401 1
a2401 1
	    sp->string_mode = ANSI_PM;
d2407 1
a2407 1
	    sp->string_mode = ANSI_DCS;
d2413 1
a2413 1
	    sp->string_mode = ANSI_APC;
d2452 1
a2452 1
	    TRACE(("CASE_CNL - cursor next line\n"));
d2688 1
a2688 1
	    sp->string_mode = ANSI_OSC;
a2705 1
		sp->lastchar < 256 &&
d3066 1
a3066 1
	if (screen->eventMode == NORMAL
d3072 1
a3072 1
		WindowScroll(xw, 0);
d3097 1
a3097 1
	    if (screen->eventMode != NORMAL)
d3140 1
a3140 1
	if (screen->eventMode == NORMAL
d3145 1
a3145 1
		WindowScroll(xw, 0);	/* Scroll to bottom */
d3201 1
a3201 1
	if (screen->eventMode != NORMAL)
d3278 1
a3278 1
    TScreen *screen = TScreenOf(term);
d3595 1
a3595 1
    if (resource.zIconBeep && mapstate == IsUnmapped && !screen->zIconBeep_flagged) {
d3606 2
a3607 2
	    screen->zIconBeep_flagged = True;
	    ChangeIconName(icon_name);
d3609 1
a3609 1
	if (resource.zIconBeep > 0) {
d3611 1
a3611 1
	    XkbBell(XtDisplay(toplevel), VShellWindow, resource.zIconBeep, XkbBI_Info);
d3613 1
a3613 1
	    XBell(XtDisplay(toplevel), resource.zIconBeep);
a3641 1
    TScreen *screen = TScreenOf(term);
d3647 2
a3648 2
	if (screen->zIconBeep_flagged) {
	    screen->zIconBeep_flagged = False;
d3654 1
a3654 1
		    screen->zIconBeep_flagged = True;
d3658 1
a3658 1
		ChangeIconName(buf);
d3678 2
a3679 1
		VTwin *Vwin = WhichVWin(&(term->screen));
d3739 1
a3739 2
	TRACE(("HandleStructNotify(event %s)\n",
	       visibleEventType(event->type)));
a3797 5
#define IsSM() (func == bitset)

#define set_bool_mode(flag) \
	flag = (IsSM()) ? ON : OFF

d3799 1
a3799 3
	screen->send_mouse_pos = IsSM() ? mode : MOUSE_OFF

#if OPT_READLINE
d3801 1
a3801 1
	(IsSM()				\
a3803 1
#endif
d3816 1
a3816 1
	TRACE(("%s %d\n", IsSM()? "DECSET" : "DECRST", param[i]));
d3823 1
a3823 1
	    if (IsSM()) {	/* ANSI (VT100) */
d3850 1
a3850 1
		if ((j = IsSM()? 132 : 80) !=
d3858 1
a3858 1
	    if (IsSM()) {
d3896 1
a3896 1
	    ShowToolbar(IsSM());
d3902 1
a3902 1
		set_bool_mode(screen->cursor_blink_esc);
d3908 1
a3908 1
	    set_bool_mode(screen->printer_formfeed);
d3911 1
a3911 1
	    set_bool_mode(screen->printer_extent);
d3914 1
a3914 1
	    set_bool_mode(screen->cursor_set);
d3917 1
a3917 1
	    if (screen->fullVwin.sb_info.width != (IsSM()? ON : OFF))
d3922 1
a3922 1
	    set_bool_mode(xw->misc.shift_fonts);
d3927 1
a3927 1
	    if (IsSM() && !(screen->inhibit & I_TEK)) {
d3929 1
a3929 1
		TEK4014_ACTIVE(xw) = True;
d3934 1
a3934 1
	    set_bool_mode(screen->c132);
d3938 1
a3938 1
	    set_bool_mode(screen->curses);
d3945 1
a3945 1
	    set_bool_mode(screen->marginbell);
d3961 1
a3961 1
	    if (IsSM())
d3973 1
a3973 1
		if (IsSM()) {
d3982 1
a3982 1
		if (IsSM()) {
a3987 1
	    /* FALLTHRU */
d3990 1
a3990 1
		if (IsSM()) {
d3999 1
a3999 1
		if (IsSM()) {
a4034 5
#if OPT_FOCUS_EVENT
	case SET_FOCUS_EVENT_MOUSE:
	    set_bool_mode(screen->send_focus_pos);
	    break;
#endif
d4036 1
a4036 1
	    set_bool_mode(screen->scrollttyoutput);
d4040 1
a4040 1
	    set_bool_mode(screen->scrollkey);
d4044 1
a4044 1
	    set_bool_mode(xw->screen.input_eight_bits);
d4049 1
a4049 1
	    set_bool_mode(xw->misc.real_NumLock);
d4053 1
a4053 1
	    set_bool_mode(screen->meta_sends_esc);
d4058 1
a4058 1
	    set_bool_mode(screen->delete_is_del);
d4063 1
a4063 1
		if (IsSM())
d4069 1
a4069 1
#if OPT_SUN_FUNC_KEYS
d4071 1
a4071 1
	    set_keyboard_type(xw, keyboardIsSun, IsSM());
d4076 1
a4076 1
	    set_keyboard_type(xw, keyboardIsHP, IsSM());
d4081 1
a4081 1
	    set_keyboard_type(xw, keyboardIsSCO, IsSM());
d4085 1
a4085 1
	    set_keyboard_type(xw, keyboardIsLegacy, IsSM());
d4089 1
a4089 1
	    set_keyboard_type(xw, keyboardIsVT220, IsSM());
d4144 1
a4180 3
	case 42:		/* DECNRCM national charset (VT220) */
	    /* do nothing */
	    break;
a4202 5
#if OPT_FOCUS_EVENT
	case SET_FOCUS_EVENT_MOUSE:
	    DoSM(DP_X_FOCUS, screen->send_focus_pos);
	    break;
#endif
a4365 5
#if OPT_FOCUS_EVENT
	case SET_FOCUS_EVENT_MOUSE:
	    DoRM(DP_X_FOCUS, screen->send_focus_pos);
	    break;
#endif
d4408 2
a4409 2
    reply.a_type = ANSI_ESC;
    unparseputc(xw, ANSI_ESC);
d4427 1
a4427 1
    unparseputc(xw, ANSI_ESC);
d4503 1
a4503 1
	reply.a_type = ANSI_CSI;
d4516 1
a4516 1
	reply.a_type = ANSI_CSI;
d4531 1
a4531 1
	reply.a_type = ANSI_CSI;
d4547 1
a4547 1
	reply.a_type = ANSI_CSI;
d4564 1
a4564 1
	reply.a_type = ANSI_CSI;
d4626 1
a4626 1
	    unparseputc(xw, A2E(ANSI_ESC));
d4641 7
a4647 7
    if (c == ANSI_ESC
	|| c == ANSI_DCS
	|| c == ANSI_CSI
	|| c == ANSI_OSC
	|| c == ANSI_PM
	|| c == ANSI_APC
	|| c == ANSI_SS3) {
d4790 10
a4799 7
	XClearArea(screen->display,
		   VWindow(screen),
		   (int) OriginX(screen),
		   (int) top * FontHeight(screen) + screen->border,
		   (unsigned) Width(screen),
		   (unsigned) (rows - top) * FontHeight(screen),
		   False);
d4824 1
a4824 1
    TScreen *screen = TScreenOf(term);
d4876 1
a4876 1
    TScreen *screen = TScreenOf(term);
d4925 3
d4992 3
a4994 1
    getXtermSizeHints(xw);
d5043 1
a5043 1
    TScreen *screen = TScreenOf(term);
d5061 1
a5061 1
    TScreen *screen = TScreenOf(term);
a5431 1
    init_Bres(screen.bellIsUrgent);
a5476 1
    TEK4014_SHOWN(wnew) = False;	/* not a resource... */
d5479 1
a5479 1
    init_Bres(misc.TekEmu);
a5514 2
    init_Bres(screen.alt_is_not_meta);
    init_Bres(screen.alt_sends_esc);
d5536 2
a5537 1
    wnew->screen.MenuFontName(fontMenu_default) = wnew->misc.default_font.f_n;
d5540 1
a5541 7
    wnew->screen.menu_font_number = fontMenu_default;
    init_Sres(screen.initial_font);
    if (wnew->screen.initial_font != 0) {
	int result = xtermGetFont(wnew->screen.initial_font);
	if (result >= 0)
	    wnew->screen.menu_font_number = result;
    }
a5553 4
#if OPT_CLIP_BOLD
    init_Bres(screen.use_clipping);
#endif

a5689 1
    init_Tres(HIGHLIGHT_FG);
d5718 1
a5718 3
    for (i = 0; i <= fontMenu_lastBuiltin; ++i) {
	init_Dres(misc.face_size[i]);
    }
a5773 1
    init_Bres(screen.always_bold_mode);
d5808 1
a5808 1
    if (resource.zIconBeep)
d5837 3
d5881 1
a5881 1
void
d5885 4
a5888 2
    VTwin *win = WhichVWin(screen);
    int n;
d5890 47
a5936 2
    for_each_curs_gc(n) {
	freeCgs(xw, win, (CgsEnum) n);
d5940 3
a5942 2
void
releaseWindowGCs(XtermWidget xw, VTwin * win)
d5944 4
a5947 5
    int n;

    for_each_text_gc(n) {
	freeCgs(xw, win, (CgsEnum) n);
    }
d5949 1
d5999 1
a5999 1
    releaseWindowGCs(xw, &(screen->fullVwin));
d6001 1
a6001 1
    releaseWindowGCs(xw, &(screen->iconVwin));
d6004 1
a6004 1
    xtermCloseFonts(xw, screen->fnts);
a6044 1
    const VTFontNames *myfont;
d6054 1
a6054 5
    if (screen->menu_font_number == fontMenu_default) {
	myfont = &(xw->misc.default_font);
    } else {
	myfont = xtermFontName(screen->MenuFontName(screen->menu_font_number));
    }
d6058 3
a6060 4
		       myfont,
		       False,
		       screen->menu_font_number)) {
	if (XmuCompareISOLatin1(myfont->f_n, DEFFONT) != 0) {
d6062 2
a6063 2
		    "%s:  unable to open font \"%s\", trying \"%s\"....\n",
		    xterm_name, myfont->f_n, DEFFONT);
d6065 3
a6067 4
				 xtermFontName(DEFFONT),
				 False,
				 screen->menu_font_number);
	    screen->MenuFontName(screen->menu_font_number) = DEFFONT;
d6081 1
a6081 1
	    SetVTFont(xw, screen->menu_font_number, True, NULL);
d6131 1
a6131 1
    getXtermSizeHints(xw);
d6223 2
a6224 1
	VTwin *win = &(screen->iconVwin);
d6252 2
a6253 11
	setCgsFont(xw, win, gcNorm, screen->fnt_icon);
	setCgsFore(xw, win, gcNorm, T_COLOR(screen, TEXT_FG));
	setCgsBack(xw, win, gcNorm, T_COLOR(screen, TEXT_BG));

	copyCgs(xw, win, gcBold, gcNorm);

	setCgsFont(xw, win, gcNormReverse, screen->fnt_icon);
	setCgsFore(xw, win, gcNormReverse, T_COLOR(screen, TEXT_BG));
	setCgsBack(xw, win, gcNormReverse, T_COLOR(screen, TEXT_FG));

	copyCgs(xw, win, gcBoldReverse, gcNormReverse);
d6255 16
d6624 1
a6624 1
	    newvt->screen.MenuFontName(fontMenu_default) = newvt->misc.default_font.f_n;
d6632 1
a6632 1
	    newvt->screen.MenuFontName(fontMenu_default) = curvt->misc.default_font.f_n;
d6663 1
a6663 1
#define setGC(code) set_at = __LINE__, currentCgs = code
a6685 2
    CgsEnum currentCgs = gcMAX;
    VTwin *currentWin = WhichVWin(screen);
a6688 1
    Bool filled;
d6693 1
a6693 2
    Pixel selbg_pix = T_COLOR(screen, HIGHLIGHT_BG);
    Pixel selfg_pix = T_COLOR(screen, HIGHLIGHT_FG);
d6706 1
a6706 1
    if (screen->eventMode != NORMAL)
d6794 1
a6794 2
    filled = (screen->select || screen->always_highlight);
    if (filled) {
d6796 2
a6797 2
	    if (getCgsGC(xw, currentWin, gcVTcursNormal)) {
		setGC(gcVTcursNormal);
d6800 1
a6800 1
		    setGC(gcBold);
d6802 1
a6802 1
		    setGC(gcNorm);
d6806 6
a6811 8
	    {
		Bool use_selbg = isNotForeground(xw, fg_pix, bg_pix, selbg_pix);
		Bool use_selfg = isNotBackground(xw, fg_pix, bg_pix, selfg_pix);

		if (use_selbg)
		    fg_pix = selbg_pix;
		if (use_selfg)
		    bg_pix = selfg_pix;
d6816 2
a6817 2
	    if (getCgsGC(xw, currentWin, gcVTcursReverse)) {
		setGC(gcVTcursReverse);
d6820 1
a6820 1
		    setGC(gcBoldReverse);
d6822 1
a6822 1
		    setGC(gcNormReverse);
d6827 1
a6827 1
	    setCgsBack(xw, currentWin, currentCgs, fg_pix);
d6829 1
a6829 1
	setCgsFore(xw, currentWin, currentCgs, bg_pix);
d6833 6
a6838 8
	    {
		Bool use_selbg = isNotForeground(xw, fg_pix, bg_pix, selbg_pix);
		Bool use_selfg = isNotBackground(xw, fg_pix, bg_pix, selfg_pix);

		if (use_selbg)
		    fg_pix = selbg_pix;
		if (use_selfg)
		    bg_pix = selfg_pix;
d6841 3
a6843 3
	    setGC(gcNormReverse);
	    setCgsFore(xw, currentWin, currentCgs, bg_pix);
	    setCgsBack(xw, currentWin, currentCgs, fg_pix);
d6845 3
a6847 3
	    setGC(gcNorm);
	    setCgsFore(xw, currentWin, currentCgs, fg_pix);
	    setCgsBack(xw, currentWin, currentCgs, bg_pix);
d6855 2
a6856 3
	TRACE(("ShowCursor calling drawXtermText cur(%d,%d) %s\n",
	       screen->cur_row, screen->cur_col,
	       (filled ? "filled" : "outline")));
a6857 1
	currentGC = getCgsGC(xw, currentWin, currentCgs);
d6878 1
a6878 5
	if (!filled) {
	    GC outlineGC = getCgsGC(xw, currentWin, gcVTcursOutline);
	    if (outlineGC == 0)
		outlineGC = currentGC;

d6881 3
a6883 1
	    XDrawLines(screen->display, VWindow(screen), outlineGC,
d7132 1
a7132 1
    if (!XtIsRealized((Widget) xw) || (CURRENT_EMU() != (Widget) xw)) {
d7172 2
a7173 3
	screen->send_focus_pos = OFF;
	screen->waitingForTrackInfo = False;
	screen->eventMode = NORMAL;
d7438 2
a7439 4
    if (IsXtermWidget(w)) {
	/* do nothing, but check for funny escape sequences */
	(void) SendMousePosition((XtermWidget) w, event);
    }
d7444 1
a7444 1
DoSetSelectedFont(Widget w,
d7449 1
a7449 1
		  unsigned long *length,
d7452 3
a7454 1
    if (!IsXtermWidget(w) || *type != XA_STRING || *format != 8) {
d7456 17
a7472 39
    } else {
	XtermWidget xw = (XtermWidget) w;
	char *save = xw->screen.MenuFontName(fontMenu_fontsel);
	char *val = (char *) value;
	char *test = 0;
	char *used = 0;
	int len = strlen(val);

	if (len > (int) *length) {
	    len = (int) *length;
	}
	if (len > 0) {
	    val[len] = '\0';
	    used = x_strtrim(val);
	    TRACE(("DoSetSelectedFont(%s)\n", val));
	    /* Do some sanity checking to avoid sending a long selection
	       back to the server in an OpenFont that is unlikely to succeed.
	       XLFD allows up to 255 characters and no control characters;
	       we are a little more liberal here. */
	    if (len < 1000
		&& !strchr(val, '\n')
		&& (test = x_strdup(val)) != 0) {
		xw->screen.MenuFontName(fontMenu_fontsel) = test;
		if (!xtermLoadFont(term,
				   xtermFontName(val),
				   True,
				   fontMenu_fontsel)) {
		    Bell(XkbBI_MinorError, 0);
		    free(test);
		    xw->screen.MenuFontName(fontMenu_fontsel) = save;
		} else {
		    free(save);
		}
	    } else {
		Bell(XkbBI_MinorError, 0);
	    }
	    if (used != val)
		free(used);
	}
d7486 1
a7486 4
	atom_name = (xw->screen.mappedSelect
		     ? xw->screen.mappedSelect[0]
		     : "PRIMARY");
    TRACE(("FindFontSelection(%s)\n", atom_name));
a7513 1
    VTwin *win = WhichVWin(screen);
d7515 2
d7520 4
d7533 1
a7533 1
     * And, there are four situations when drawing a cursor, if we decide
d7549 42
a7590 7
    if (win != 0 && (cc != bg)) {
	/* set the fonts to the current one */
	setCgsFont(xw, win, gcVTcursNormal, 0);
	setCgsFont(xw, win, gcVTcursFilled, 0);
	setCgsFont(xw, win, gcVTcursReverse, 0);
	setCgsFont(xw, win, gcVTcursOutline, 0);

d7592 2
a7593 2
	setCgsFore(xw, win, gcVTcursNormal, fg);
	setCgsBack(xw, win, gcVTcursNormal, cc);
d7595 7
a7601 2
	setCgsFore(xw, win, gcVTcursFilled, cc);
	setCgsBack(xw, win, gcVTcursFilled, fg);
d7604 2
a7605 6
	    /* both GC's use the same color */
	    setCgsFore(xw, win, gcVTcursReverse, bg);
	    setCgsBack(xw, win, gcVTcursReverse, cc);

	    setCgsFore(xw, win, gcVTcursOutline, bg);
	    setCgsBack(xw, win, gcVTcursOutline, cc);
d7607 6
a7612 5
	    setCgsFore(xw, win, gcVTcursReverse, bg);
	    setCgsBack(xw, win, gcVTcursReverse, cc);

	    setCgsFore(xw, win, gcVTcursOutline, cc);
	    setCgsBack(xw, win, gcVTcursOutline, bg);
d7614 1
d7620 4
@


1.1.1.3
log
@import xterm 229
@
text
@d1 1
a1 1
/* $XTermId: charproc.c,v 1.810 2007/07/17 21:09:48 tom Exp $ */
d136 6
d149 3
a401 1
    Bres(XtNallowTitleOps, XtCAllowTitleOps, screen.allowTitleOp0, True),
a552 1
    Bres(XtNhighlightReverse, XtCHighlightReverse, screen.hilite_reverse, True),
a658 2
    Ires(XtNmkSamplePass, XtCMkSamplePass, misc.mk_samplepass, 256),
    Ires(XtNmkSampleSize, XtCMkSampleSize, misc.mk_samplesize, 1024),
a816 5

#if OPT_EXTRA_PASTE
    if (term && term->keyboard.extra_translations)
	XtOverrideTranslations((Widget) term, XtParseTranslationTable(term->keyboard.extra_translations));
#endif
d1217 1
a1217 1
	    /* substitute combined character with precomposed character
d1530 1
a1530 2
	    else
		do_xevents();
d2491 1
d3269 7
a3275 2
	    if (ice_fd >= 0)
		FD_SET(ice_fd, &select_mask);
a3339 12
static void
WrapLine(XtermWidget xw)
{
    TScreen *screen = &(xw->screen);

    /* mark that we had to wrap this line */
    ScrnSetFlag(screen, screen->cur_row, LINEWRAPPED);
    xtermAutoPrint('\n');
    xtermIndex(xw, 1);
    set_cur_col(screen, 0);
}

d3390 6
a3395 1
	if (screen->do_wrap) {
d3397 2
a3398 5
	    if ((xw->flags & WRAPAROUND)) {
		WrapLine(xw);
		width_available = MaxCols(screen) - screen->cur_col;
		next_col = screen->cur_col;
	    }
a3411 2
	    if (last_chomp > MaxCols(screen))
		break;		/* give up - it is too big */
d3414 1
a3414 1
	    if (chars_chomped > 0) {
a3415 1
	    }
d3441 2
a3442 3
	    for (j = offset, k = 0; j < offset + chars_chomped; j++) {
		if (buf[j] == HIDDEN_CHAR)
		    continue;
a3449 1
		++k;
d3454 1
a3454 1
		      k);
d3474 6
a3479 1
	    if (screen->do_wrap) {
d3481 3
a3483 5
		if ((xw->flags & WRAPAROUND)) {
		    WrapLine(xw);
		}
	    }
	    this_col = 1;
d3495 3
a3497 3
	 * The call to WriteText updates screen->cur_col.
	 * If screen->cur_col is less than next_col, we must have
	 * hit the right margin - so set the do_wrap flag.
d3505 13
d3543 116
a5095 2
    TRACE(("VTInit {{\n"));

a5104 2

    TRACE(("...}} VTInit\n"));
a5406 5
    /* DESCO Sys#67660
     * Zero out the entire "keyboard" component of "wnew" widget.
     */
    bzero((char *) &wnew->keyboard, sizeof(wnew->keyboard));

a5571 1
    init_Bres(screen.allowTitleOp0);
a5575 1
    wnew->screen.allowTitleOps = wnew->screen.allowTitleOp0;
a5753 1
    init_Bres(screen.hilite_reverse);
a5796 1
    init_Ires(screen.utf8_inparse);
a5811 13
    init_Ires(misc.mk_samplesize);
    init_Ires(misc.mk_samplepass);

    if (wnew->misc.mk_samplesize > 0xffff)
	wnew->misc.mk_samplesize = 0xffff;
    if (wnew->misc.mk_samplesize < 0)
	wnew->misc.mk_samplesize = 0;

    if (wnew->misc.mk_samplepass > wnew->misc.mk_samplesize)
	wnew->misc.mk_samplepass = wnew->misc.mk_samplesize;
    if (wnew->misc.mk_samplepass < 0)
	wnew->misc.mk_samplepass = 0;

d5837 1
a5837 3
		   + 1,
		   wnew->misc.mk_samplesize,
		   wnew->misc.mk_samplepass);
a5966 13
#define TRACE_FREE_LEAK(name) \
	if (name) { \
	    free(name); \
	    name = 0; \
	    TRACE(("freed " #name "\n")); \
	}

#define FREE_LEAK(name) \
	if (name) { \
	    free(name); \
	    name = 0; \
	}

d5980 22
a6001 5
    TRACE_FREE_LEAK(screen->save_ptr);
    TRACE_FREE_LEAK(screen->sbuf_address);
    TRACE_FREE_LEAK(screen->allbuf);
    TRACE_FREE_LEAK(screen->abuf_address);
    TRACE_FREE_LEAK(screen->altbuf);
d6003 4
a6006 1
    TRACE_FREE_LEAK(screen->draw_buf);
a6020 1
    noleaks_cachedCgs(xw);
d6035 2
a6036 1
	FREE_LEAK(screen->Tcolors[n].resource);
d6040 2
a6041 1
	FREE_LEAK(screen->selectExpr[n]);
a6048 4

    TRACE_FREE_LEAK(xw->keyboard.extra_translations);
    TRACE_FREE_LEAK(xw->keyboard.shell_translations);
    TRACE_FREE_LEAK(xw->keyboard.xterm_translations);
a6306 6
#if OPT_EXTRA_PASTE
    if (xw->keyboard.extra_translations) {
	XtOverrideTranslations((Widget) xw,
			       XtParseTranslationTable(xw->keyboard.extra_translations));
    }
#endif
a6712 2
    Boolean use_selbg;
    Boolean use_selfg;
a6813 4
#if OPT_HIGHLIGHT_COLOR
    use_selbg = isNotForeground(xw, fg_pix, bg_pix, selbg_pix);
    use_selfg = isNotBackground(xw, fg_pix, bg_pix, selfg_pix);
#endif
a6824 1
	    EXCHANGE(fg_pix, bg_pix, tmp);
d6826 4
a6829 5
	    if (screen->hilite_reverse) {
		if (use_selbg && !use_selfg)
		    fg_pix = bg_pix;
		if (use_selfg && !use_selbg)
		    bg_pix = fg_pix;
d6831 1
a6831 1
		    bg_pix = selbg_pix;
d6833 1
a6833 1
		    fg_pix = selfg_pix;
d6836 1
d6854 11
a6864 1
	    EXCHANGE(fg_pix, bg_pix, tmp);
d6866 2
d6870 2
a6872 32
#if OPT_HIGHLIGHT_COLOR
	if (screen->hilite_reverse) {
	    if (in_selection && !reversed) {
		;		/* really INVERSE ... */
	    } else if (in_selection || reversed) {
		if (use_selbg) {
		    if (use_selfg) {
			bg_pix = fg_pix;
		    } else {
			fg_pix = bg_pix;
		    }
		}
		if (use_selbg) {
		    bg_pix = selbg_pix;
		}
		if (use_selfg) {
		    fg_pix = selfg_pix;
		}
	    }
	} else {
	    if (in_selection) {
		if (use_selbg) {
		    bg_pix = selbg_pix;
		}
		if (use_selfg) {
		    fg_pix = selfg_pix;
		}
	    }
	}
#endif
	setCgsFore(xw, currentWin, currentCgs, fg_pix);
	setCgsBack(xw, currentWin, currentCgs, bg_pix);
d6895 5
a6899 6
		if (!(clo || chi))
		    break;
		drawXtermText(xw, (flags & DRAWX_MASK) | NOBACKGROUND,
			      currentGC, x, y,
			      curXtermChrSet(xw, screen->cur_row),
			      PAIRED_CHARS(&clo, &chi), 1, iswide(base));
d7012 5
a7016 6
	    if (!(clo || chi))
		break;
	    drawXtermText(xw, (flags & DRAWX_MASK) | NOBACKGROUND,
			  currentGC, x, y,
			  curXtermChrSet(xw, screen->cur_row),
			  PAIRED_CHARS(&clo, &chi), 1, iswide(base));
a7485 1
	Boolean failed = False;
a7486 1
	int oldFont = xw->screen.menu_font_number;
d7488 1
a7488 1
	char *val;
d7491 1
a7491 2
	unsigned len = *length;
	unsigned tst;
d7493 2
a7494 8
	/*
	 * Some versions of X deliver null-terminated selections, some do not.
	 */
	for (tst = 0; tst < len; ++tst) {
	    if (((char *) value)[tst] == '\0') {
		len = tst;
		break;
	    }
d7496 1
a7496 3

	if (len > 0 && (val = malloc(len + 1)) != 0) {
	    memcpy(val, value, len);
d7512 1
a7512 1
		    failed = True;
d7515 2
a7518 7
		failed = True;
	    }
	    if (failed) {
		(void) xtermLoadFont(term,
				     xtermFontName(xw->screen.MenuFontName(oldFont)),
				     True,
				     oldFont);
a7522 1
	    free(val);
@


1.1.1.4
log
@Import xterm version 232. tested by many.
@
text
@d1 3
a3 1
/* $XTermId: charproc.c,v 1.834 2008/01/27 17:39:53 tom Exp $ */
d7 1
a7 1
Copyright 1999-2007,2008 by Thomas E. Dickey
a261 1
    { "delete-is-del",		HandleDeleteIsDEL },
d276 1
a298 1
    { "set-keep-selection",	HandleKeepSelection },
a423 1
    Bres(XtNkeepSelection, XtCKeepSelection, screen.keepSelection, False),
a432 1
    Bres(XtNquietGrab, XtCQuietGrab, screen.quiet_grab, False),
a451 1
    Ires(XtNpointerMode, XtCPointerMode, screen.pointer_mode, DEF_POINTER_MODE),
d499 1
a499 1
    Fres("iconFont", "IconFont", screen.fnt_icon.fs, XtDefaultFont),
a545 1
    Bres(XtNhighlightColorMode, XtCHighlightColorMode, screen.hilite_color, Maybe),
d1043 1
a1043 1
set_mod_fkeys(XtermWidget xw, int which, int what, Bool enabled)
d1046 1
a1046 1
    xw->keyboard.modify_now.field = ((what == DEFAULT) && enabled) \
d1048 1
a1048 1
				     : what; \
d1199 1
a1199 2
	    && my_wcwidth((int) c) == 0
	    && !isWideControl(c)) {
d1207 9
a1215 4
	    TRACE(("do_precomposition (U+%04X [%d], U+%04X [%d]) -> U+%04X [%d]\n",
		   prev, my_wcwidth(prev),
		   (int) c, my_wcwidth((int) c),
		   precomposed, my_wcwidth(precomposed)));
d2277 1
a2277 1
	    ScrnFillRectangle(xw, &myRect, 'E', 0, False);
a2566 1
		xtermShowPointer(xw, True);
d2646 1
a2646 1
	    ScrnFillRectangle(xw, &myRect, ' ', 0, True);
d2656 1
a2656 1
		ScrnFillRectangle(xw, &myRect, param[0], xw->flags, True);
d2829 1
a2829 1
		set_mod_fkeys(xw, param[0], nparam > 1 ? param[1] : DEFAULT, True);
d2832 1
a2832 1
		    set_mod_fkeys(xw, row, DEFAULT, True);
d2837 1
a2837 5
	    if (nparam >= 1 && param[0] != DEFAULT) {
		set_mod_fkeys(xw, param[0], -1, False);
	    } else {
		xw->keyboard.modify_now.function_keys = -1;
	    }
a2839 8
	case CASE_HIDE_POINTER:
	    TRACE(("CASE_HIDE_POINTER\n"));
	    if (nparam >= 1 && param[0] != DEFAULT) {
		screen->pointer_mode = param[0];
	    } else {
		screen->pointer_mode = DEF_POINTER_MODE;
	    }
	    break;
d3713 2
a3714 11
static void
really_set_mousemode(XtermWidget xw,
		     Bool enabled,
		     unsigned mode)
{
    xw->screen.send_mouse_pos = enabled ? mode : MOUSE_OFF;
    if (xw->screen.send_mouse_pos != MOUSE_OFF)
	xtermShowPointer(xw, True);
}

#define set_mousemode(mode) really_set_mousemode(xw, IsSM(), mode)
a3992 5
#if OPT_TCAP_FKEYS
	case 1050:
	    set_keyboard_type(xw, keyboardIsTermcap, IsSM());
	    break;
#endif
d5066 1
a5066 1
    } else if (isDefaultForeground(name)) {
d5071 1
a5071 1
    } else if (isDefaultBackground(name)) {
a5259 6
#define Kolor(name) wnew->screen.name.resource
#define TxtFg(name) !x_strcasecmp(Kolor(Tcolors[TEXT_FG]), Kolor(name))
#define TxtBg(name) !x_strcasecmp(Kolor(Tcolors[TEXT_BG]), Kolor(name))
#define DftFg(name) isDefaultForeground(Kolor(name))
#define DftBg(name) isDefaultBackground(Kolor(name))

d5379 1
a5427 3

    init_Bres(screen.always_highlight);
    init_Bres(screen.brokenSelections);
d5431 1
d5433 2
a5434 4
    init_Bres(screen.keepSelection);
    init_Bres(screen.selectToClipboard);
    init_Bres(screen.trim_selection);

a5435 1
    init_Ires(screen.pointer_mode);
a5466 2
    init_Bres(screen.quiet_grab);

d5468 1
a5468 1
    wnew->screen.fnt_icon.fs = request->screen.fnt_icon.fs;
d5556 1
a5556 1
	if (DftFg(Acolors[i])) {
d5559 1
a5559 1
	} else if (DftBg(Acolors[i])) {
a5643 20
    init_Bres(screen.hilite_color);
    if (wnew->screen.hilite_color == Maybe) {
	wnew->screen.hilite_color = False;
#if OPT_COLOR_RES
	/*
	 * If the highlight text/background are both set, and if they are
	 * not equal to either the text/background or background/text, then
	 * set the highlightColorMode automatically.
	 */
	if (!DftFg(Tcolors[HIGHLIGHT_BG])
	    && !DftBg(Tcolors[HIGHLIGHT_FG])
	    && !TxtFg(Tcolors[HIGHLIGHT_BG])
	    && !TxtBg(Tcolors[HIGHLIGHT_FG])
	    && !TxtBg(Tcolors[HIGHLIGHT_BG])
	    && !TxtFg(Tcolors[HIGHLIGHT_FG])) {
	    TRACE(("...setting hilite_color automatically\n"));
	    wnew->screen.hilite_color = True;
	}
#endif
    }
a5903 2
    TRACE_FREE_LEAK(screen->keyboard_dialect);
    TRACE_FREE_LEAK(screen->term_id);
a5905 4
#if OPT_LUIT_PROG
    TRACE_FREE_LEAK(xw->misc.locale_str);
    TRACE_FREE_LEAK(xw->misc.localefilter);
#endif
a5918 3
    if (screen->hidden_cursor)
	XFreeCursor(screen->display, screen->hidden_cursor);

a5932 1
#if OPT_COLOR_RES
a5936 1
#endif
d5997 1
a5997 1
    if (!screen->fnts[fNorm].fs) {
d6145 1
a6145 1
    if (xw->misc.active_icon && screen->fnt_icon.fs) {
d6152 1
a6152 1
	xtermComputeFontInfo(xw, &(screen->iconVwin), screen->fnt_icon.fs, 0);
d6176 1
a6176 1
	setCgsFont(xw, win, gcNorm, &(screen->fnt_icon));
d6182 1
a6182 1
	setCgsFont(xw, win, gcNormReverse, &(screen->fnt_icon));
a7138 2
	xtermShowPointer(xw, True);

d7441 1
a7441 1
	if (len > 0 && (val = TypeMallocN(char, len + 1)) != 0) {
d7480 1
a7480 1
FindFontSelection(XtermWidget xw, const char *atom_name, Bool justprobe)
@


