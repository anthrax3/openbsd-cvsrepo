head	1.31;
access;
symbols
	OPENBSD_6_1:1.30.0.2
	OPENBSD_6_1_BASE:1.30
	OPENBSD_6_0:1.29.0.4
	OPENBSD_6_0_BASE:1.29
	OPENBSD_5_9:1.29.0.2
	OPENBSD_5_9_BASE:1.29
	OPENBSD_5_8:1.28.0.4
	OPENBSD_5_8_BASE:1.28
	OPENBSD_5_7:1.28.0.2
	OPENBSD_5_7_BASE:1.28
	OPENBSD_5_6:1.26.0.2
	OPENBSD_5_6_BASE:1.26
	OPENBSD_5_5:1.24.0.2
	OPENBSD_5_5_BASE:1.24
	OPENBSD_5_4:1.22.0.2
	OPENBSD_5_4_BASE:1.22
	OPENBSD_5_3:1.20.0.2
	OPENBSD_5_3_BASE:1.20
	OPENBSD_5_2:1.19.0.2
	OPENBSD_5_2_BASE:1.19
	OPENBSD_5_1_BASE:1.18
	OPENBSD_5_1:1.18.0.2
	OPENBSD_5_0:1.14.0.2
	OPENBSD_5_0_BASE:1.14
	OPENBSD_4_9:1.13.0.2
	OPENBSD_4_9_BASE:1.13
	OPENBSD_4_8:1.10.0.4
	OPENBSD_4_8_BASE:1.10
	OPENBSD_4_7:1.8.0.2
	OPENBSD_4_7_BASE:1.8
	OPENBSD_4_6:1.6.0.2
	OPENBSD_4_6_BASE:1.6
	OPENBSD_4_5:1.5.0.2
	OPENBSD_4_5_BASE:1.5
	OPENBSD_4_4:1.2.0.2
	OPENBSD_4_4_BASE:1.2
	OPENBSD_4_3_BASE:1.1.1.4
	OPENBSD_4_3:1.1.1.4.0.2
	v232:1.1.1.4
	v229:1.1.1.3
	OPENBSD_4_2:1.1.1.2.0.2
	OPENBSD_4_2_BASE:1.1.1.2
	v225:1.1.1.2
	v216:1.1.1.1
	xterm:1.1.1;
locks; strict;
comment	@ * @;


1.31
date	2017.07.15.19.20.51;	author matthieu;	state Exp;
branches;
next	1.30;
commitid	b9xPQ49d1NNt4zlu;

1.30
date	2016.08.07.21.27.36;	author matthieu;	state Exp;
branches;
next	1.29;
commitid	psxxjI5z4Vpv2LL4;

1.29
date	2015.09.05.14.11.46;	author matthieu;	state Exp;
branches;
next	1.28;
commitid	YVUODLQ4QcYTuGkb;

1.28
date	2015.01.18.20.24.40;	author matthieu;	state Exp;
branches;
next	1.27;
commitid	PDdlFuihcMifzxwp;

1.27
date	2014.10.05.16.39.19;	author matthieu;	state Exp;
branches;
next	1.26;
commitid	0wVJ6bWh03LWbUdn;

1.26
date	2014.07.14.08.30.11;	author matthieu;	state Exp;
branches;
next	1.25;
commitid	EnwNNUjlkdrocnMa;

1.25
date	2014.05.09.19.56.40;	author matthieu;	state Exp;
branches;
next	1.24;

1.24
date	2014.02.14.19.40.03;	author matthieu;	state Exp;
branches;
next	1.23;

1.23
date	2014.01.02.15.14.50;	author matthieu;	state Exp;
branches;
next	1.22;

1.22
date	2013.06.02.19.55.50;	author matthieu;	state Exp;
branches;
next	1.21;

1.21
date	2013.03.09.14.45.38;	author matthieu;	state Exp;
branches;
next	1.20;

1.20
date	2013.01.04.16.40.18;	author matthieu;	state Exp;
branches;
next	1.19;

1.19
date	2012.04.14.09.02.46;	author matthieu;	state Exp;
branches;
next	1.18;

1.18
date	2011.11.16.21.14.25;	author matthieu;	state Exp;
branches;
next	1.17;

1.17
date	2011.09.17.11.51.57;	author matthieu;	state Exp;
branches;
next	1.16;

1.16
date	2011.08.28.17.40.55;	author matthieu;	state Exp;
branches;
next	1.15;

1.15
date	2011.08.18.19.47.42;	author matthieu;	state Exp;
branches;
next	1.14;

1.14
date	2011.06.07.19.21.06;	author matthieu;	state Exp;
branches;
next	1.13;

1.13
date	2010.11.29.20.10.09;	author matthieu;	state Exp;
branches;
next	1.12;

1.12
date	2010.10.23.19.14.52;	author matthieu;	state Exp;
branches;
next	1.11;

1.11
date	2010.08.22.13.38.11;	author matthieu;	state Exp;
branches;
next	1.10;

1.10
date	2010.05.08.12.20.46;	author matthieu;	state Exp;
branches;
next	1.9;

1.9
date	2010.03.25.22.03.51;	author matthieu;	state Exp;
branches;
next	1.8;

1.8
date	2009.10.31.14.11.57;	author matthieu;	state Exp;
branches;
next	1.7;

1.7
date	2009.09.05.15.58.09;	author matthieu;	state Exp;
branches;
next	1.6;

1.6
date	2009.03.09.22.13.04;	author matthieu;	state Exp;
branches;
next	1.5;

1.5
date	2009.01.06.20.10.20;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2008.09.23.19.08.55;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2008.08.25.18.05.57;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2008.03.19.21.15.46;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.26.11.11.32;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.11.26.11.11.32;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2007.06.15.19.30.21;	author matthieu;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2007.08.25.18.53.54;	author matthieu;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2008.02.16.09.35.00;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.31
log
@Update to xterm 330
@
text
@/* $XTermId: fontutils.c,v 1.531 2017/06/20 09:10:19 tom Exp $ */

/*
 * Copyright 1998-2016,2017 by Thomas E. Dickey
 *
 *                         All Rights Reserved
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 *
 * The above copyright notice and this permission notice shall be included
 * in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
 * IN NO EVENT SHALL THE ABOVE LISTED COPYRIGHT HOLDER(S) BE LIABLE FOR ANY
 * CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
 * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
 * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 *
 * Except as contained in this notice, the name(s) of the above copyright
 * holders shall not be used in advertising or otherwise to promote the
 * sale, use or other dealings in this Software without prior written
 * authorization.
 */

/*
 * A portion of this module (for FontNameProperties) was adapted from EMU 1.3;
 * it constructs font names with specific properties changed, e.g., for bold
 * and double-size characters.
 */

#define RES_OFFSET(field)	XtOffsetOf(SubResourceRec, field)

#include <fontutils.h>
#include <X11/Xmu/Drawing.h>
#include <X11/Xmu/CharSet.h>

#include <main.h>
#include <data.h>
#include <menu.h>
#include <xstrings.h>
#include <xterm.h>

#include <stdio.h>
#include <ctype.h>

#define SetFontWidth(screen,dst,src)  (dst)->f_width = (src)
#define SetFontHeight(screen,dst,src) (dst)->f_height = dimRound((screen)->scale_height * (float) (src))

/* from X11/Xlibint.h - not all vendors install this file */
#define CI_NONEXISTCHAR(cs) (((cs)->width == 0) && \
			     (((cs)->rbearing|(cs)->lbearing| \
			       (cs)->ascent|(cs)->descent) == 0))

#define CI_GET_CHAR_INFO_1D(fs,col,cs) \
{ \
    cs = 0; \
    if (col >= fs->min_char_or_byte2 && col <= fs->max_char_or_byte2) { \
	if (fs->per_char == NULL) { \
	    cs = &fs->min_bounds; \
	} else { \
	    cs = &fs->per_char[(col - fs->min_char_or_byte2)]; \
	} \
	if (CI_NONEXISTCHAR(cs)) cs = 0; \
    } \
}

#define CI_GET_CHAR_INFO_2D(fs,row,col,cs) \
{ \
    cs = 0; \
    if (row >= fs->min_byte1 && row <= fs->max_byte1 && \
	col >= fs->min_char_or_byte2 && col <= fs->max_char_or_byte2) { \
	if (fs->per_char == NULL) { \
	    cs = &fs->min_bounds; \
	} else { \
	    cs = &fs->per_char[((row - fs->min_byte1) * \
				(fs->max_char_or_byte2 - \
				 fs->min_char_or_byte2 + 1)) + \
			       (col - fs->min_char_or_byte2)]; \
	} \
	if (CI_NONEXISTCHAR(cs)) cs = 0; \
    } \
}

#define FREE_FNAME(field) \
	    if (fonts == 0 || myfonts.field != fonts->field) { \
		FREE_STRING(myfonts.field); \
		myfonts.field = 0; \
	    }

/*
 * A structure to hold the relevant properties from a font
 * we need to make a well formed font name for it.
 */
typedef struct {
    /* registry, foundry, family */
    const char *beginning;
    /* weight */
    const char *weight;
    /* slant */
    const char *slant;
    /* wideness */
    const char *wideness;
    /* add style */
    const char *add_style;
    int pixel_size;
    const char *point_size;
    int res_x;
    int res_y;
    const char *spacing;
    int average_width;
    /* charset registry, charset encoding */
    char *end;
} FontNameProperties;

#if OPT_LOAD_VTFONTS || OPT_WIDE_CHARS
static Boolean merge_sublist(char ***, char **);
#endif

static void save2FontList(XtermWidget, const char *, XtermFontNames *,
			  VTFontEnum, const char *, Bool);

#if OPT_RENDERFONT
static void fillInFaceSize(XtermWidget, int);
#endif

#if OPT_SHIFT_FONTS
static int lookupOneFontSize(XtermWidget, int);
#endif

#if OPT_REPORT_FONTS || OPT_WIDE_CHARS
static unsigned
countGlyphs(XFontStruct *fp)
{
    unsigned count = 0;

    if (fp != 0) {
	if (fp->min_byte1 == 0 && fp->max_byte1 == 0) {
	    count = fp->max_char_or_byte2 - fp->min_char_or_byte2 + 1;
	} else if (fp->min_char_or_byte2 < 256
		   && fp->max_char_or_byte2 < 256) {
	    unsigned first = (fp->min_byte1 << 8) + fp->min_char_or_byte2;
	    unsigned last = (fp->max_byte1 << 8) + fp->max_char_or_byte2;
	    count = last + 1 - first;
	}
    }
    return count;
}
#endif

#if OPT_WIDE_CHARS
/*
 * Verify that the wide-bold font is at least a bold font with roughly as many
 * glyphs as the wide font.  The counts should be the same, but settle for
 * filtering out the worst of the font mismatches.
 */
static Bool
compatibleWideCounts(XFontStruct *wfs, XFontStruct *wbfs)
{
    unsigned count_w = countGlyphs(wfs);
    unsigned count_wb = countGlyphs(wbfs);
    if (count_w <= 256 ||
	count_wb <= 256 ||
	((count_w / 4) * 3) > count_wb) {
	TRACE(("...font server lied (count wide %u vs wide-bold %u)\n",
	       count_w, count_wb));
	return False;
    }
    return True;
}
#endif /* OPT_WIDE_CHARS */

#if OPT_BOX_CHARS
static void
setupPackedFonts(XtermWidget xw)
{
    TScreen *screen = TScreenOf(xw);
    Bool value = False;

#if OPT_RENDERFONT
    if (xw->work.render_font == True) {
	int e;

	for (e = 0; e < fMAX; ++e) {
	    XTermXftFonts *data = getMyXftFont(xw, e, screen->menu_font_number);
	    if (data != 0) {
		if (data->map.mixed) {
		    screen->allow_packing = True;
		    break;
		}
	    }
	}
    }
#endif /* OPT_RENDERFONT */

    value = screen->allow_packing;

    SetItemSensitivity(fontMenuEntries[fontMenu_font_packedfont].widget, value);
}
#endif

/*
 * Returns the fields from start to stop in a dash- separated string.  This
 * function will modify the source, putting '\0's in the appropriate place and
 * moving the beginning forward to after the '\0'
 *
 * This will NOT work for the last field (but we won't need it).
 */
static char *
n_fields(char **source, int start, int stop)
{
    int i;
    char *str, *str1;

    /*
     * find the start-1th dash
     */
    for (i = start - 1, str = *source; i; i--, str++) {
	if ((str = strchr(str, '-')) == 0)
	    return 0;
    }

    /*
     * find the stopth dash
     */
    for (i = stop - start + 1, str1 = str; i; i--, str1++) {
	if ((str1 = strchr(str1, '-')) == 0)
	    return 0;
    }

    /*
     * put a \0 at the end of the fields
     */
    *(str1 - 1) = '\0';

    /*
     * move source forward
     */
    *source = str1;

    return str;
}

static Boolean
check_fontname(const char *name)
{
    Boolean result = True;

    if (IsEmpty(name)) {
	TRACE(("fontname missing\n"));
	result = False;
    }
    return result;
}

/*
 * Gets the font properties from a given font structure.  We use the FONT name
 * to find them out, since that seems easier.
 *
 * Returns a pointer to a static FontNameProperties structure
 * or NULL on error.
 */
static FontNameProperties *
get_font_name_props(Display *dpy, XFontStruct *fs, char **result)
{
    static FontNameProperties props;
    static char *last_name;

    Atom fontatom = XInternAtom(dpy, "FONT", False);
    char *name = 0;
    char *str;

    /*
     * first get the full font name
     */
    if (fontatom != 0) {
	XFontProp *fp;
	int i;

	for (i = 0, fp = fs->properties; i < fs->n_properties; i++, fp++) {
	    if (fp->name == fontatom) {
		name = XGetAtomName(dpy, fp->card32);
		break;
	    }
	}
    }

    if (name == 0)
	return 0;

    /*
     * XGetAtomName allocates memory - don't leak
     */
    if (last_name != 0)
	XFree(last_name);
    last_name = name;

    if (result != 0) {
	if (!check_fontname(name))
	    return 0;
	if (*result != 0)
	    free(*result);
	*result = x_strdup(name);
    }

    /*
     * Now split it up into parts and put them in
     * their places. Since we are using parts of
     * the original string, we must not free the Atom Name
     */

    /* registry, foundry, family */
    if ((props.beginning = n_fields(&name, 1, 3)) == 0)
	return 0;

    /* weight is the next */
    if ((props.weight = n_fields(&name, 1, 1)) == 0)
	return 0;

    /* slant */
    if ((props.slant = n_fields(&name, 1, 1)) == 0)
	return 0;

    /* width */
    if ((props.wideness = n_fields(&name, 1, 1)) == 0)
	return 0;

    /* add style */
    if ((props.add_style = n_fields(&name, 1, 1)) == 0)
	return 0;

    /* pixel size */
    if ((str = n_fields(&name, 1, 1)) == 0)
	return 0;
    if ((props.pixel_size = atoi(str)) == 0)
	return 0;

    /* point size */
    if ((props.point_size = n_fields(&name, 1, 1)) == 0)
	return 0;

    /* res_x */
    if ((str = n_fields(&name, 1, 1)) == 0)
	return 0;
    if ((props.res_x = atoi(str)) == 0)
	return 0;

    /* res_y */
    if ((str = n_fields(&name, 1, 1)) == 0)
	return 0;
    if ((props.res_y = atoi(str)) == 0)
	return 0;

    /* spacing */
    if ((props.spacing = n_fields(&name, 1, 1)) == 0)
	return 0;

    /* average width */
    if ((str = n_fields(&name, 1, 1)) == 0)
	return 0;
    if ((props.average_width = atoi(str)) == 0)
	return 0;

    /* the rest: charset registry and charset encoding */
    props.end = name;

    return &props;
}

#define ALLOCHUNK(n) ((n | 127) + 1)

static void
alloca_fontname(char **result, size_t next)
{
    size_t last = (*result != 0) ? strlen(*result) : 0;
    size_t have = (*result != 0) ? ALLOCHUNK(last) : 0;
    size_t want = last + next + 2;

    if (want >= have) {
	want = ALLOCHUNK(want);
	if (last != 0) {
	    char *save = *result;
	    *result = TypeRealloc(char, want, *result);
	    if (*result == 0)
		free(save);
	} else {
	    if ((*result = TypeMallocN(char, want)) != 0)
		**result = '\0';
	}
    }
}

static void
append_fontname_str(char **result, const char *value)
{
    if (value == 0)
	value = "*";
    alloca_fontname(result, strlen(value));
    if (*result != 0) {
	if (**result != '\0')
	    strcat(*result, "-");
	strcat(*result, value);
    }
}

static void
append_fontname_num(char **result, int value)
{
    if (value < 0) {
	append_fontname_str(result, "*");
    } else {
	char temp[100];
	sprintf(temp, "%d", value);
	append_fontname_str(result, temp);
    }
}

/*
 * Take the given font props and try to make a well formed font name specifying
 * the same base font and size and everything, but with different weight/width
 * according to the parameters.  The return value is allocated, should be freed
 * by the caller.
 */
static char *
derive_font_name(FontNameProperties *props,
		 const char *use_weight,
		 int use_average_width,
		 const char *use_encoding)
{
    char *result = 0;

    append_fontname_str(&result, props->beginning);
    append_fontname_str(&result, use_weight);
    append_fontname_str(&result, props->slant);
    append_fontname_str(&result, 0);
    append_fontname_str(&result, 0);
    append_fontname_num(&result, props->pixel_size);
    append_fontname_str(&result, props->point_size);
    append_fontname_num(&result, props->res_x);
    append_fontname_num(&result, props->res_y);
    append_fontname_str(&result, props->spacing);
    append_fontname_num(&result, use_average_width);
    append_fontname_str(&result, use_encoding);

    return result;
}

static char *
bold_font_name(FontNameProperties *props, int use_average_width)
{
    return derive_font_name(props, "bold", use_average_width, props->end);
}

#if OPT_WIDE_ATTRS
static char *
italic_font_name(FontNameProperties *props, const char *slant)
{
    FontNameProperties myprops = *props;
    myprops.slant = slant;
    return derive_font_name(&myprops, props->weight, myprops.average_width, props->end);
}

static Boolean
open_italic_font(XtermWidget xw, int n, FontNameProperties *fp, XTermFonts * data)
{
    static const char *slant[] =
    {
	"o",
	"i"
    };
    char *name;
    Cardinal pass;
    Boolean result = False;

    for (pass = 0; pass < XtNumber(slant); ++pass) {
	if ((name = italic_font_name(fp, slant[pass])) != 0) {
	    TRACE(("open_italic_font %s %s\n",
		   whichFontEnum((VTFontEnum) n), name));
	    if (xtermOpenFont(xw, name, data, False)) {
		result = (data->fs != 0);
#if OPT_REPORT_FONTS
		if (resource.reportFonts) {
		    printf("opened italic version of %s:\n\t%s\n",
			   whichFontEnum(n),
			   name);
		}
#endif
	    }
	    free(name);
	    if (result)
		break;
	}
    }
#if OPT_TRACE
    if (result) {
	XFontStruct *fs = data->fs;
	if (fs != 0) {
	    TRACE(("...actual size %dx%d (ascent %d, descent %d)\n",
		   fs->ascent +
		   fs->descent,
		   fs->max_bounds.width,
		   fs->ascent,
		   fs->descent));
	}
    }
#endif
    return result;
}
#endif

#if OPT_WIDE_CHARS
#define derive_wide_font(props, weight) \
	derive_font_name(props, weight, props->average_width * 2, "ISO10646-1")

static char *
wide_font_name(FontNameProperties *props)
{
    return derive_wide_font(props, "medium");
}

static char *
widebold_font_name(FontNameProperties *props)
{
    return derive_wide_font(props, "bold");
}
#endif /* OPT_WIDE_CHARS */

#if OPT_DEC_CHRSET
/*
 * Take the given font props and try to make a well formed font name specifying
 * the same base font but changed depending on the given attributes and chrset.
 *
 * For double width fonts, we just double the X-resolution, for double height
 * fonts we double the pixel-size and Y-resolution
 */
char *
xtermSpecialFont(XtermWidget xw, unsigned attr_flags, unsigned draw_flags, unsigned chrset)
{
    TScreen *screen = TScreenOf(xw);
#if OPT_TRACE
    static char old_spacing[80];
    static FontNameProperties old_props;
#endif
    FontNameProperties *props;
    char *result = 0;
    const char *weight;
    int pixel_size;
    int res_x;
    int res_y;

    props = get_font_name_props(screen->display,
				getNormalFont(screen, fNorm)->fs, 0);
    if (props == 0)
	return result;

    pixel_size = props->pixel_size;
    res_x = props->res_x;
    res_y = props->res_y;
    if (attr_flags & BOLD)
	weight = "bold";
    else
	weight = props->weight;

    if (CSET_DOUBLE(chrset))
	res_x *= 2;

    if (chrset == CSET_DHL_TOP
	|| chrset == CSET_DHL_BOT) {
	res_y *= 2;
	pixel_size *= 2;
    }
#if OPT_TRACE
    if (old_props.res_x != res_x
	|| old_props.res_x != res_y
	|| old_props.pixel_size != pixel_size
	|| strcmp(old_props.spacing, props->spacing)) {
	TRACE(("xtermSpecialFont(atts = %#x, draw = %#x, chrset = %#x)\n",
	       attr_flags, draw_flags, chrset));
	TRACE(("res_x      = %d\n", res_x));
	TRACE(("res_y      = %d\n", res_y));
	TRACE(("point_size = %s\n", props->point_size));
	TRACE(("pixel_size = %d\n", pixel_size));
	TRACE(("spacing    = %s\n", props->spacing));
	old_props.res_x = res_x;
	old_props.res_y = res_y;
	old_props.pixel_size = pixel_size;
	old_props.spacing = old_spacing;
	sprintf(old_spacing, "%.*s", (int) sizeof(old_spacing) - 2, props->spacing);
    }
#endif

    append_fontname_str(&result, props->beginning);
    append_fontname_str(&result, weight);
    append_fontname_str(&result, props->slant);
    append_fontname_str(&result, props->wideness);
    append_fontname_str(&result, props->add_style);
    append_fontname_num(&result, pixel_size);
    append_fontname_str(&result, props->point_size);
    append_fontname_num(&result, (draw_flags & NORESOLUTION) ? -1 : res_x);
    append_fontname_num(&result, (draw_flags & NORESOLUTION) ? -1 : res_y);
    append_fontname_str(&result, props->spacing);
    append_fontname_str(&result, 0);
    append_fontname_str(&result, props->end);

    return result;
}
#endif /* OPT_DEC_CHRSET */

/*
 * Case-independent comparison for font-names, including wildcards.
 * XLFD allows '?' as a wildcard, but we do not handle that (no one seems
 * to use it).
 */
static Bool
same_font_name(const char *pattern, const char *match)
{
    Bool result = False;

    if (pattern && match) {
	while (*pattern && *match) {
	    if (*pattern == *match) {
		pattern++;
		match++;
	    } else if (*pattern == '*' || *match == '*') {
		if (same_font_name(pattern + 1, match)) {
		    return True;
		} else if (same_font_name(pattern, match + 1)) {
		    return True;
		} else {
		    return False;
		}
	    } else {
		int p = x_toupper(*pattern++);
		int m = x_toupper(*match++);
		if (p != m)
		    return False;
	    }
	}
	result = (*pattern == *match);	/* both should be NUL */
    }
    return result;
}

/*
 * Double-check the fontname that we asked for versus what the font server
 * actually gave us.  The larger fixed fonts do not always have a matching bold
 * font, and the font server may try to scale another font or otherwise
 * substitute a mismatched font.
 *
 * If we cannot get what we requested, we will fallback to the original
 * behavior, which simulates bold by overstriking each character at one pixel
 * offset.
 */
static int
got_bold_font(Display *dpy, XFontStruct *fs, String requested)
{
    char *actual = 0;
    int got;

    if (get_font_name_props(dpy, fs, &actual) == 0)
	got = 0;
    else
	got = same_font_name(requested, actual);
    free(actual);
    return got;
}

/*
 * Check normal/bold (or wide/wide-bold) font pairs to see if we will be able
 * to check for missing glyphs in a comparable manner.
 */
static int
comparable_metrics(XFontStruct *normal, XFontStruct *bold)
{
#define DATA "comparable_metrics: "
    int result = 0;

    if (normal == 0 || bold == 0) {
	;
    } else if (normal->all_chars_exist) {
	if (bold->all_chars_exist) {
	    result = 1;
	} else {
	    TRACE((DATA "all chars exist in normal font, but not in bold\n"));
	}
    } else if (normal->per_char != 0) {
	if (bold->per_char != 0) {
	    result = 1;
	} else {
	    TRACE((DATA "normal font has per-char metrics, but not bold\n"));
	}
    } else {
	TRACE((DATA "normal font is not very good!\n"));
	result = 1;		/* give in (we're not going in reverse) */
    }
    return result;
#undef DATA
}

/*
 * If the font server tries to adjust another font, it may not adjust it
 * properly.  Check that the bounding boxes are compatible.  Otherwise we'll
 * leave trash on the display when we mix normal and bold fonts.
 */
static int
same_font_size(XtermWidget xw, XFontStruct *nfs, XFontStruct *bfs)
{
    TScreen *screen = TScreenOf(xw);
    int result = 0;

    if (nfs != 0 && bfs != 0) {
	TRACE(("same_font_size height %d/%d, min %d/%d max %d/%d\n",
	       nfs->ascent + nfs->descent,
	       bfs->ascent + bfs->descent,
	       nfs->min_bounds.width, bfs->min_bounds.width,
	       nfs->max_bounds.width, bfs->max_bounds.width));
	result = screen->free_bold_box
	    || ((nfs->ascent + nfs->descent) == (bfs->ascent + bfs->descent)
		&& (nfs->min_bounds.width == bfs->min_bounds.width
		    || nfs->min_bounds.width == bfs->min_bounds.width + 1)
		&& (nfs->max_bounds.width == bfs->max_bounds.width
		    || nfs->max_bounds.width == bfs->max_bounds.width + 1));
    }
    return result;
}

/*
 * Check if the font looks like it has fixed width
 */
static int
is_fixed_font(XFontStruct *fs)
{
    if (fs)
	return (fs->min_bounds.width == fs->max_bounds.width);
    return 1;
}

/*
 * Check if the font looks like a double width font (i.e. contains
 * characters of width X and 2X
 */
#if OPT_WIDE_CHARS
static int
is_double_width_font(XFontStruct *fs)
{
    return ((2 * fs->min_bounds.width) == fs->max_bounds.width);
}
#else
#define is_double_width_font(fs) 0
#endif

#if OPT_WIDE_CHARS && OPT_RENDERFONT && defined(HAVE_TYPE_FCCHAR32)
#define HALF_WIDTH_TEST_STRING "1234567890"

/* '1234567890' in Chinese characters in UTF-8 */
#define FULL_WIDTH_TEST_STRING "\xe4\xb8\x80\xe4\xba\x8c\xe4\xb8\x89" \
                               "\xe5\x9b\x9b\xe4\xba\x94" \
			       "\xef\xa7\x91\xe4\xb8\x83\xe5\x85\xab" \
			       "\xe4\xb9\x9d\xef\xa6\xb2"

/* '1234567890' in Korean script in UTF-8 */
#define FULL_WIDTH_TEST_STRING2 "\xec\x9d\xbc\xec\x9d\xb4\xec\x82\xbc" \
                                "\xec\x82\xac\xec\x98\xa4" \
			        "\xec\x9c\xa1\xec\xb9\xa0\xed\x8c\x94" \
			        "\xea\xb5\xac\xec\x98\x81"

#define HALF_WIDTH_CHAR1  0x0031	/* '1' */
#define HALF_WIDTH_CHAR2  0x0057	/* 'W' */
#define FULL_WIDTH_CHAR1  0x4E00	/* CJK Ideograph 'number one' */
#define FULL_WIDTH_CHAR2  0xAC00	/* Korean script syllable 'Ka' */

static Bool
is_double_width_font_xft(Display *dpy, XftFont *font)
{
    XGlyphInfo gi1, gi2;
    FcChar32 c1 = HALF_WIDTH_CHAR1, c2 = HALF_WIDTH_CHAR2;
    String fwstr = FULL_WIDTH_TEST_STRING;
    String hwstr = HALF_WIDTH_TEST_STRING;

    /* Some Korean fonts don't have Chinese characters at all. */
    if (!XftCharExists(dpy, font, FULL_WIDTH_CHAR1)) {
	if (!XftCharExists(dpy, font, FULL_WIDTH_CHAR2))
	    return False;	/* Not a CJK font */
	else			/* a Korean font without CJK Ideographs */
	    fwstr = FULL_WIDTH_TEST_STRING2;
    }

    XftTextExtents32(dpy, font, &c1, 1, &gi1);
    XftTextExtents32(dpy, font, &c2, 1, &gi2);
    if (gi1.xOff != gi2.xOff)	/* Not a fixed-width font */
	return False;

    XftTextExtentsUtf8(dpy,
		       font,
		       (_Xconst FcChar8 *) hwstr,
		       (int) strlen(hwstr),
		       &gi1);
    XftTextExtentsUtf8(dpy,
		       font,
		       (_Xconst FcChar8 *) fwstr,
		       (int) strlen(fwstr),
		       &gi2);

    /*
     * fontconfig and Xft prior to 2.2(?) set the width of half-width
     * characters identical to that of full-width character in CJK double-width
     * (bi-width / monospace) font even though the former is half as wide as
     * the latter.  This was fixed sometime before the release of fontconfig
     * 2.2 in early 2003.  See
     *  http://bugzilla.mozilla.org/show_bug.cgi?id=196312
     * In the meantime, we have to check both possibilities.
     */
    return ((2 * gi1.xOff == gi2.xOff) || (gi1.xOff == gi2.xOff));
}
#else
#define is_double_width_font_xft(dpy, xftfont) 0
#endif

#define EmptyFont(fs) (fs != 0 \
		   && ((fs)->ascent + (fs)->descent == 0 \
		    || (fs)->max_bounds.width == 0))

#define FontSize(fs) (((fs)->ascent + (fs)->descent) \
		    *  (fs)->max_bounds.width)

const VTFontNames *
xtermFontName(const char *normal)
{
    static VTFontNames data;
    FREE_STRING(data.f_n);
    memset(&data, 0, sizeof(data));
    if (normal)
	data.f_n = x_strdup(normal);
    return &data;
}

const VTFontNames *
defaultVTFontNames(XtermWidget xw)
{
    static VTFontNames data;
    memset(&data, 0, sizeof(data));
    data.f_n = DefaultFontN(xw);
    data.f_b = DefaultFontB(xw);
#if OPT_WIDE_CHARS
    data.f_w = DefaultFontW(xw);
    data.f_wb = DefaultFontWB(xw);
#endif
    return &data;
}

static void
cache_menu_font_name(TScreen *screen, int fontnum, int which, const char *name)
{
    if (name != 0) {
	String last = screen->menu_font_names[fontnum][which];
	if (last != 0) {
	    if (strcmp(last, name)) {
		FREE_STRING(last);
		TRACE(("caching menu fontname %d.%d %s\n", fontnum, which, name));
		screen->menu_font_names[fontnum][which] = x_strdup(name);
	    }
	} else {
	    TRACE(("caching menu fontname %d.%d %s\n", fontnum, which, name));
	    screen->menu_font_names[fontnum][which] = x_strdup(name);
	}
    }
}

typedef struct _cannotFont {
    struct _cannotFont *next;
    char *where;
} CannotFont;

static void
cannotFont(XtermWidget xw, const char *who, const char *what, const char *where)
{
    static CannotFont *ignored;
    CannotFont *list;

    switch (xw->misc.fontWarnings) {
    case fwNever:
	return;
    case fwResource:
	for (list = ignored; list != 0; list = list->next) {
	    if (!strcmp(where, list->where)) {
		return;
	    }
	}
	if ((list = TypeMalloc(CannotFont)) != 0) {
	    list->where = x_strdup(where);
	    list->next = ignored;
	    ignored = list;
	}
	break;
    case fwAlways:
	break;
    }
    TRACE(("OOPS: cannot %s%s%s font \"%s\"\n", who, *what ? " " : "", what, where));
    xtermWarning("cannot %s%s%s font \"%s\"\n", who, *what ? " " : "", what, where);
}

/*
 * Open the given font and verify that it is non-empty.  Return a null on
 * failure.
 */
Bool
xtermOpenFont(XtermWidget xw,
	      const char *name,
	      XTermFonts * result,
	      Bool force)
{
    Bool code = False;
    TScreen *screen = TScreenOf(xw);

    if (!IsEmpty(name)) {
	if ((result->fs = XLoadQueryFont(screen->display, name)) != 0) {
	    code = True;
	    if (EmptyFont(result->fs)) {
		xtermCloseFont(xw, result);
		code = False;
	    } else {
		result->fn = x_strdup(name);
	    }
	} else if (XmuCompareISOLatin1(name, DEFFONT) != 0) {
	    if (result->warn <= xw->misc.fontWarnings
#if OPT_RENDERFONT
		&& !UsingRenderFont(xw)
#endif
		) {
		TRACE(("OOPS: cannot load font %s\n", name));
		cannotFont(xw, "load", "", name);
	    } else {
		TRACE(("xtermOpenFont: cannot load font '%s'\n", name));
	    }
	    if (force) {
		result->warn = fwAlways;
		code = xtermOpenFont(xw, DEFFONT, result, True);
	    }
	}
    }
    result->warn = fwAlways;
    return code;
}

/*
 * Close the font and free the font info.
 */
void
xtermCloseFont(XtermWidget xw, XTermFonts * fnt)
{
    if (fnt != 0 && fnt->fs != 0) {
	TScreen *screen = TScreenOf(xw);

	clrCgsFonts(xw, WhichVWin(screen), fnt);
	XFreeFont(screen->display, fnt->fs);
	xtermFreeFontInfo(fnt);
    }
}

/*
 * Close and free the font (as well as any aliases).
 */
static void
xtermCloseFont2(XtermWidget xw, XTermFonts * fnts, int which)
{
    XFontStruct *thisFont = fnts[which].fs;

    if (thisFont != 0) {
	int k;

	xtermCloseFont(xw, &fnts[which]);
	for (k = 0; k < fMAX; ++k) {
	    if (k != which) {
		if (thisFont == fnts[k].fs) {
		    xtermFreeFontInfo(&fnts[k]);
		}
	    }
	}
    }
}

/*
 * Close the listed fonts, noting that some may use copies of the pointer.
 */
void
xtermCloseFonts(XtermWidget xw, XTermFonts * fnts)
{
    int j;

    for (j = 0; j < fMAX; ++j) {
	xtermCloseFont2(xw, fnts, j);
    }
}

/*
 * Make a copy of the source, assuming the XFontStruct's to be unique, but
 * ensuring that the names are reallocated to simplify freeing.
 */
void
xtermCopyFontInfo(XTermFonts * target, XTermFonts * source)
{
    xtermFreeFontInfo(target);
    target->chrset = source->chrset;
    target->flags = source->flags;
    target->fn = x_strdup(source->fn);
    target->fs = source->fs;
    target->warn = source->warn;
}

void
xtermFreeFontInfo(XTermFonts * target)
{
    target->chrset = 0;
    target->flags = 0;
    if (target->fn != 0) {
	free(target->fn);
	target->fn = 0;
    }
    target->fs = 0;
}

#if OPT_REPORT_FONTS
static void
reportXCharStruct(const char *tag, XCharStruct * cs)
{
    printf("\t\t%s:\n", tag);
    printf("\t\t\tlbearing: %d\n", cs->lbearing);
    printf("\t\t\trbearing: %d\n", cs->rbearing);
    printf("\t\t\twidth:    %d\n", cs->width);
    printf("\t\t\tascent:   %d\n", cs->ascent);
    printf("\t\t\tdescent:  %d\n", cs->descent);
}

static void
reportOneVTFont(const char *tag,
		XTermFonts * fnt)
{
    if (!IsEmpty(fnt->fn) && fnt->fs != 0) {
	XFontStruct *fs = fnt->fs;
	unsigned first_char = 0;
	unsigned last_char = 0;

	if (fs->max_byte1 == 0) {
	    first_char = fs->min_char_or_byte2;
	    last_char = fs->max_char_or_byte2;
	} else {
	    first_char = (fs->min_byte1 * 256) + fs->min_char_or_byte2;
	    last_char = (fs->max_byte1 * 256) + fs->max_char_or_byte2;
	}

	printf("\t%s: %s\n", tag, NonNull(fnt->fn));
	printf("\t\tall chars:     %s\n", fs->all_chars_exist ? "yes" : "no");
	printf("\t\tdefault char:  %d\n", fs->default_char);
	printf("\t\tdirection:     %d\n", fs->direction);
	printf("\t\tascent:        %d\n", fs->ascent);
	printf("\t\tdescent:       %d\n", fs->descent);
	printf("\t\tfirst char:    %u\n", first_char);
	printf("\t\tlast char:     %u\n", last_char);
	printf("\t\tmaximum-chars: %u\n", countGlyphs(fs));
	if (FontLacksMetrics(fnt)) {
	    printf("\t\tmissing-chars: ?\n");
	    printf("\t\tpresent-chars: ?\n");
	} else {
	    unsigned missing = 0;
	    unsigned ch;
	    for (ch = first_char; ch <= last_char; ++ch) {
		if (xtermMissingChar(ch, fnt)) {
		    ++missing;
		}
	    }
	    printf("\t\tmissing-chars: %u\n", missing);
	    printf("\t\tpresent-chars: %u\n", countGlyphs(fs) - missing);
	}
	printf("\t\tmin_byte1:     %d\n", fs->min_byte1);
	printf("\t\tmax_byte1:     %d\n", fs->max_byte1);
	printf("\t\tproperties:    %d\n", fs->n_properties);
	reportXCharStruct("min_bounds", &(fs->min_bounds));
	reportXCharStruct("max_bounds", &(fs->max_bounds));
	/* TODO: report fs->properties and fs->per_char */
    }
}

static void
reportVTFontInfo(XtermWidget xw, int fontnum)
{
    if (resource.reportFonts) {
	TScreen *screen = TScreenOf(xw);

	if (fontnum) {
	    printf("Loaded VTFonts(font%d)\n", fontnum);
	} else {
	    printf("Loaded VTFonts(default)\n");
	}

	reportOneVTFont("fNorm", getNormalFont(screen, fNorm));
	reportOneVTFont("fBold", getNormalFont(screen, fBold));
#if OPT_WIDE_CHARS
	reportOneVTFont("fWide", getNormalFont(screen, fWide));
	reportOneVTFont("fWBold", getNormalFont(screen, fWBold));
#endif
    }
}
#endif

typedef XTermFonts *(*MyGetFont) (TScreen *, int);

void
xtermUpdateFontGCs(XtermWidget xw, Bool italic)
{
    TScreen *screen = TScreenOf(xw);
#if OPT_WIDE_ATTRS || OPT_RENDERWIDE
    MyGetFont myfunc = italic ? getItalicFont : getNormalFont;
#else
    MyGetFont myfunc = getNormalFont;
#endif
    VTwin *win = WhichVWin(screen);
    Pixel new_normal = getXtermForeground(xw, xw->flags, xw->cur_foreground);
    Pixel new_revers = getXtermBackground(xw, xw->flags, xw->cur_background);

    (void) italic;

    setCgsFore(xw, win, gcNorm, new_normal);
    setCgsBack(xw, win, gcNorm, new_revers);
    setCgsFont(xw, win, gcNorm, myfunc(screen, fNorm));

    copyCgs(xw, win, gcBold, gcNorm);
    setCgsFont(xw, win, gcBold, myfunc(screen, fBold));

    setCgsFore(xw, win, gcNormReverse, new_revers);
    setCgsBack(xw, win, gcNormReverse, new_normal);
    setCgsFont(xw, win, gcNormReverse, myfunc(screen, fNorm));

    copyCgs(xw, win, gcBoldReverse, gcNormReverse);
    setCgsFont(xw, win, gcBoldReverse, myfunc(screen, fBold));

    if_OPT_WIDE_CHARS(screen, {
	XTermFonts *wide_xx = myfunc(screen, fWide);
	XTermFonts *bold_xx = myfunc(screen, fWBold);
	if (wide_xx->fs != 0
	    && bold_xx->fs != 0) {
	    setCgsFore(xw, win, gcWide, new_normal);
	    setCgsBack(xw, win, gcWide, new_revers);
	    setCgsFont(xw, win, gcWide, wide_xx);

	    copyCgs(xw, win, gcWBold, gcWide);
	    setCgsFont(xw, win, gcWBold, bold_xx);

	    setCgsFore(xw, win, gcWideReverse, new_revers);
	    setCgsBack(xw, win, gcWideReverse, new_normal);
	    setCgsFont(xw, win, gcWideReverse, wide_xx);

	    copyCgs(xw, win, gcWBoldReverse, gcWideReverse);
	    setCgsFont(xw, win, gcWBoldReverse, bold_xx);
	}
    });
}

#if OPT_TRACE
static void
show_font_misses(const char *name, XTermFonts * fp)
{
    if (fp->fs != 0) {
	if (FontLacksMetrics(fp)) {
	    TRACE(("%s font lacks metrics\n", name));
	} else if (FontIsIncomplete(fp)) {
	    TRACE(("%s font is incomplete\n", name));
	} else {
	    TRACE(("%s font is complete\n", name));
	}
    } else {
	TRACE(("%s font is missing\n", name));
    }
}
#endif

static Bool
loadNormFP(XtermWidget xw,
	   char **nameOutP,
	   XTermFonts * infoOut,
	   int fontnum)
{
    Bool status = True;

    TRACE(("loadNormFP (%s)\n", NonNull(*nameOutP)));

    if (!xtermOpenFont(xw,
		       *nameOutP,
		       infoOut,
		       (fontnum == fontMenu_default))) {
	/*
	 * If we are opening the default font, and it happens to be missing,
	 * force that to the compiled-in default font, e.g., "fixed".  If we
	 * cannot open the font, disable it from the menu.
	 */
	if (fontnum != fontMenu_fontsel) {
	    SetItemSensitivity(fontMenuEntries[fontnum].widget, False);
	}
	status = False;
    }
    return status;
}

static Bool
loadBoldFP(XtermWidget xw,
	   char **nameOutP,
	   XTermFonts * infoOut,
	   const char *nameRef,
	   XTermFonts * infoRef,
	   int fontnum)
{
    TScreen *screen = TScreenOf(xw);
    Bool status = True;

    TRACE(("loadBoldFP (%s)\n", NonNull(*nameOutP)));

    if (!check_fontname(*nameOutP)) {
	FontNameProperties *fp;
	char *normal = x_strdup(nameRef);

	fp = get_font_name_props(screen->display, infoRef->fs, &normal);
	if (fp != 0) {
	    *nameOutP = bold_font_name(fp, fp->average_width);
	    if (!xtermOpenFont(xw, *nameOutP, infoOut, False)) {
		free(*nameOutP);
		*nameOutP = bold_font_name(fp, -1);
		xtermOpenFont(xw, *nameOutP, infoOut, False);
	    }
	    TRACE(("...derived bold '%s'\n", NonNull(*nameOutP)));
	}
	if (fp == 0 || infoOut->fs == 0) {
	    xtermCopyFontInfo(infoOut, infoRef);
	    TRACE(("...cannot load a matching bold font\n"));
	} else if (comparable_metrics(infoRef->fs, infoOut->fs)
		   && same_font_size(xw, infoRef->fs, infoOut->fs)
		   && got_bold_font(screen->display, infoOut->fs, *nameOutP)) {
	    TRACE(("...got a matching bold font\n"));
	    cache_menu_font_name(screen, fontnum, fBold, *nameOutP);
	} else {
	    xtermCloseFont2(xw, infoOut - fBold, fBold);
	    *infoOut = *infoRef;
	    TRACE(("...did not get a matching bold font\n"));
	}
	free(normal);
    } else if (!xtermOpenFont(xw, *nameOutP, infoOut, False)) {
	xtermCopyFontInfo(infoOut, infoRef);
	TRACE(("...cannot load bold font '%s'\n", NonNull(*nameOutP)));
    } else {
	cache_menu_font_name(screen, fontnum, fBold, *nameOutP);
    }

    /*
     * Most of the time this call to load the font will succeed, even if
     * there is no wide font :  the X server doubles the width of the
     * normal font, or similar.
     *
     * But if it did fail for some reason, then nevermind.
     */
    if (EmptyFont(infoOut->fs))
	status = False;		/* can't use a 0-sized font */

    if (!same_font_size(xw, infoRef->fs, infoOut->fs)
	&& (is_fixed_font(infoRef->fs) && is_fixed_font(infoOut->fs))) {
	TRACE(("...ignoring mismatched normal/bold fonts\n"));
	xtermCloseFont2(xw, infoOut - fBold, fBold);
	xtermCopyFontInfo(infoOut, infoRef);
    }

    return status;
}

#if OPT_WIDE_CHARS
static Bool
loadWideFP(XtermWidget xw,
	   char **nameOutP,
	   XTermFonts * infoOut,
	   const char *nameRef,
	   XTermFonts * infoRef,
	   int fontnum)
{
    TScreen *screen = TScreenOf(xw);
    FontNameProperties *fp;
    Bool status = True;

    TRACE(("loadWideFP (%s)\n", NonNull(*nameOutP)));

    if (check_fontname(*nameOutP)) {
	cache_menu_font_name(screen, fontnum, fWide, *nameOutP);
    } else if (screen->utf8_fonts && !is_double_width_font(infoRef->fs)) {
	char *normal = x_strdup(nameRef);
	fp = get_font_name_props(screen->display, infoRef->fs, &normal);
	if (fp != 0) {
	    *nameOutP = wide_font_name(fp);
	    TRACE(("...derived wide %s\n", NonNull(*nameOutP)));
	    cache_menu_font_name(screen, fontnum, fWide, *nameOutP);
	}
	free(normal);
    }

    if (check_fontname(*nameOutP)) {
	if (!xtermOpenFont(xw, *nameOutP, infoOut, False)) {
	    xtermCopyFontInfo(infoOut, infoRef);
	}
    } else {
	xtermCopyFontInfo(infoOut, infoRef);
    }
    return status;
}

static Bool
loadWBoldFP(XtermWidget xw,
	    char **nameOutP,
	    XTermFonts * infoOut,
	    const char *wideNameRef, XTermFonts * wideInfoRef,
	    const char *boldNameRef, XTermFonts * boldInfoRef,
	    int fontnum)
{
    TScreen *screen = TScreenOf(xw);
    Bool status = True;
    Boolean derived;
    char *bold = NULL;

    TRACE(("loadWBoldFP (%s)\n", NonNull(*nameOutP)));

    derived = False;
    if (!check_fontname(*nameOutP)) {
	FontNameProperties *fp;
	fp = get_font_name_props(screen->display, boldInfoRef->fs, &bold);
	if (fp != 0) {
	    *nameOutP = widebold_font_name(fp);
	    derived = True;
	}
    }

    if (check_fontname(*nameOutP)) {

	if (xtermOpenFont(xw, *nameOutP, infoOut, False)
	    && derived
	    && !compatibleWideCounts(wideInfoRef->fs, infoOut->fs)) {
	    xtermCloseFont2(xw, infoOut - fWBold, fWBold);
	}

	if (infoOut->fs == 0) {
	    if (derived)
		free(*nameOutP);
	    if (IsEmpty(wideNameRef)) {
		*nameOutP = x_strdup(boldNameRef);
		xtermCopyFontInfo(infoOut, boldInfoRef);
		TRACE(("...cannot load wide-bold, use bold %s\n",
		       NonNull(boldNameRef)));
	    } else {
		*nameOutP = x_strdup(wideNameRef);
		xtermCopyFontInfo(infoOut, wideInfoRef);
		TRACE(("...cannot load wide-bold, use wide %s\n",
		       NonNull(wideNameRef)));
	    }
	} else {
	    TRACE(("...%s wide/bold %s\n",
		   derived ? "derived" : "given",
		   NonNull(*nameOutP)));
	    cache_menu_font_name(screen, fontnum, fWBold, *nameOutP);
	}
    } else if (is_double_width_font(boldInfoRef->fs)) {
	xtermCopyFontInfo(infoOut, boldInfoRef);
	TRACE(("...bold font is double-width, use it %s\n", NonNull(boldNameRef)));
    } else {
	xtermCopyFontInfo(infoOut, wideInfoRef);
	TRACE(("...cannot load wide bold font, use wide %s\n", NonNull(wideNameRef)));
    }

    free(bold);

    if (EmptyFont(infoOut->fs)) {
	status = False;		/* can't use a 0-sized font */
    } else {
	if ((!comparable_metrics(wideInfoRef->fs, infoOut->fs)
	     || (!same_font_size(xw, wideInfoRef->fs, infoOut->fs)
		 && is_fixed_font(wideInfoRef->fs)
		 && is_fixed_font(infoOut->fs)))) {
	    TRACE(("...ignoring mismatched normal/bold wide fonts\n"));
	    xtermCloseFont2(xw, infoOut - fWBold, fWBold);
	    xtermCopyFontInfo(infoOut, wideInfoRef);
	}
    }

    return status;
}
#endif

int
xtermLoadFont(XtermWidget xw,
	      const VTFontNames * fonts,
	      Bool doresize,
	      int fontnum)
{
    TScreen *screen = TScreenOf(xw);
    VTwin *win = WhichVWin(screen);

    VTFontNames myfonts;
    XTermFonts fnts[fMAX];
    char *tmpname = NULL;
    Boolean proportional = False;

    memset(&myfonts, 0, sizeof(myfonts));
    memset(fnts, 0, sizeof(fnts));

    if (fonts != 0)
	myfonts = *fonts;
    if (!check_fontname(myfonts.f_n))
	return 0;

    if (fontnum == fontMenu_fontescape
	&& myfonts.f_n != screen->MenuFontName(fontnum)) {
	if ((tmpname = x_strdup(myfonts.f_n)) == 0)
	    return 0;
    }

    TRACE(("Begin Cgs - xtermLoadFont(%s)\n", myfonts.f_n));
    releaseWindowGCs(xw, win);

#define DbgResource(name, field, index) \
    TRACE(("xtermLoadFont #%d "name" %s%s\n", \
    	   fontnum, \
	   (fnts[index].warn == fwResource) ? "*" : " ", \
	   NonNull(myfonts.field)))
    DbgResource("normal", f_n, fNorm);
    DbgResource("bold  ", f_b, fBold);
#if OPT_WIDE_CHARS
    DbgResource("wide  ", f_w, fWide);
    DbgResource("w/bold", f_wb, fWBold);
#endif

    if (!loadNormFP(xw,
		    &myfonts.f_n,
		    &fnts[fNorm],
		    fontnum))
	goto bad;

    if (!loadBoldFP(xw,
		    &myfonts.f_b,
		    &fnts[fBold],
		    myfonts.f_n,
		    &fnts[fNorm],
		    fontnum))
	goto bad;

    /*
     * If there is no widefont specified, fake it by doubling AVERAGE_WIDTH
     * of normal fonts XLFD, and asking for it.  This plucks out 18x18ja
     * and 12x13ja as the corresponding fonts for 9x18 and 6x13.
     */
    if_OPT_WIDE_CHARS(screen, {

	if (!loadWideFP(xw,
			&myfonts.f_w,
			&fnts[fWide],
			myfonts.f_n,
			&fnts[fNorm],
			fontnum))
	    goto bad;

	if (!loadWBoldFP(xw,
			 &myfonts.f_wb,
			 &fnts[fWBold],
			 myfonts.f_w,
			 &fnts[fWide],
			 myfonts.f_b,
			 &fnts[fBold],
			 fontnum))
	    goto bad;

    });

    /*
     * Normal/bold fonts should be the same width.  Also, the min/max
     * values should be the same.
     */
    if (!is_fixed_font(fnts[fNorm].fs)
	|| !is_fixed_font(fnts[fBold].fs)
	|| fnts[fNorm].fs->max_bounds.width != fnts[fBold].fs->max_bounds.width) {
	TRACE(("Proportional font! normal %d/%d, bold %d/%d\n",
	       fnts[fNorm].fs->min_bounds.width,
	       fnts[fNorm].fs->max_bounds.width,
	       fnts[fBold].fs->min_bounds.width,
	       fnts[fBold].fs->max_bounds.width));
	proportional = True;
    }

    if_OPT_WIDE_CHARS(screen, {
	if (fnts[fWide].fs != 0
	    && fnts[fWBold].fs != 0
	    && (!is_fixed_font(fnts[fWide].fs)
		|| !is_fixed_font(fnts[fWBold].fs)
		|| fnts[fWide].fs->max_bounds.width != fnts[fWBold].fs->max_bounds.width)) {
	    TRACE(("Proportional font! wide %d/%d, wide bold %d/%d\n",
		   fnts[fWide].fs->min_bounds.width,
		   fnts[fWide].fs->max_bounds.width,
		   fnts[fWBold].fs->min_bounds.width,
		   fnts[fWBold].fs->max_bounds.width));
	    proportional = True;
	}
    });

    /* TODO : enforce that the width of the wide font is 2* the width
       of the narrow font */

    /*
     * If we're switching fonts, free the old ones.  Otherwise we'll leak
     * the memory that is associated with the old fonts.  The
     * XLoadQueryFont call allocates a new XFontStruct.
     */
    xtermCloseFonts(xw, screen->fnts);
#if OPT_WIDE_ATTRS
    xtermCloseFonts(xw, screen->ifnts);
    screen->ifnts_ok = False;
#endif

    xtermCopyFontInfo(getNormalFont(screen, fNorm), &fnts[fNorm]);
    xtermCopyFontInfo(getNormalFont(screen, fBold), &fnts[fBold]);
#if OPT_WIDE_CHARS
    xtermCopyFontInfo(getNormalFont(screen, fWide), &fnts[fWide]);
    if (fnts[fWBold].fs == NULL)
	xtermCopyFontInfo(getNormalFont(screen, fWide), &fnts[fWide]);
    xtermCopyFontInfo(getNormalFont(screen, fWBold), &fnts[fWBold]);
#endif

    xtermUpdateFontGCs(xw, False);

#if OPT_BOX_CHARS
    screen->allow_packing = proportional;
    setupPackedFonts(xw);
#endif
    screen->fnt_prop = (Boolean) (proportional && !(screen->force_packed));
    screen->fnt_boxes = True;

#if OPT_BOX_CHARS
    /*
     * xterm uses character positions 1-31 of a font for the line-drawing
     * characters.  Check that they are all present.  The null character
     * (0) is special, and is not used.
     */
#if OPT_RENDERFONT
    if (UsingRenderFont(xw)) {
	/*
	 * FIXME: we shouldn't even be here if we're using Xft.
	 */
	screen->fnt_boxes = False;
	TRACE(("assume Xft missing line-drawing chars\n"));
    } else
#endif
    {
	unsigned ch;

#if OPT_TRACE
#define TRACE_MISS(index) show_font_misses(#index, &fnts[index])
	TRACE_MISS(fNorm);
	TRACE_MISS(fBold);
#if OPT_WIDE_CHARS
	TRACE_MISS(fWide);
	TRACE_MISS(fWBold);
#endif
#endif

	for (ch = 1; ch < 32; ch++) {
	    unsigned n = ch;
#if OPT_WIDE_CHARS
	    if (screen->utf8_mode || screen->unicode_font) {
		n = dec2ucs(ch);
		if (n == UCS_REPL)
		    continue;
	    }
#endif
	    if (IsXtermMissingChar(screen, n, &fnts[fNorm])) {
		TRACE(("missing normal char #%d\n", n));
		screen->fnt_boxes = False;
		break;
	    }
	    if (IsXtermMissingChar(screen, n, &fnts[fBold])) {
		TRACE(("missing bold char #%d\n", n));
		screen->fnt_boxes = False;
		break;
	    }
	}
    }
    TRACE(("Will %suse internal line-drawing characters\n",
	   screen->fnt_boxes ? "not " : ""));
#endif

    if (screen->always_bold_mode) {
	screen->enbolden = screen->bold_mode;
    } else {
	screen->enbolden = screen->bold_mode
	    && ((fnts[fNorm].fs == fnts[fBold].fs)
		|| same_font_name(myfonts.f_n, myfonts.f_b));
    }
    TRACE(("Will %suse 1-pixel offset/overstrike to simulate bold\n",
	   screen->enbolden ? "" : "not "));

    set_menu_font(False);
    screen->menu_font_number = fontnum;
    set_menu_font(True);
    if (tmpname) {		/* if setting escape or sel */
	if (screen->MenuFontName(fontnum))
	    FREE_STRING(screen->MenuFontName(fontnum));
	screen->MenuFontName(fontnum) = tmpname;
	if (fontnum == fontMenu_fontescape) {
	    update_font_escape();
	}
#if OPT_SHIFT_FONTS
	screen->menu_font_sizes[fontnum] = FontSize(fnts[fNorm].fs);
#endif
    }
    set_cursor_gcs(xw);
    xtermUpdateFontInfo(xw, doresize);
    TRACE(("Success Cgs - xtermLoadFont\n"));
#if OPT_REPORT_FONTS
    reportVTFontInfo(xw, fontnum);
#endif
    FREE_FNAME(f_n);
    FREE_FNAME(f_b);
#if OPT_WIDE_CHARS
    FREE_FNAME(f_w);
    FREE_FNAME(f_wb);
#endif
    if (fnts[fNorm].fn == fnts[fBold].fn) {
	free(fnts[fNorm].fn);
    } else {
	free(fnts[fNorm].fn);
	free(fnts[fBold].fn);
    }
#if OPT_WIDE_CHARS
    free(fnts[fWide].fn);
    free(fnts[fWBold].fn);
#endif
    xtermSetWinSize(xw);
    return 1;

  bad:
    if (tmpname)
	free(tmpname);

#if OPT_RENDERFONT
    if ((fontnum == fontMenu_fontsel) && (fontnum != screen->menu_font_number)) {
	int old_fontnum = screen->menu_font_number;
#if OPT_TOOLBAR
	SetItemSensitivity(fontMenuEntries[fontnum].widget, True);
#endif
	Bell(xw, XkbBI_MinorError, 0);
	myfonts.f_n = screen->MenuFontName(old_fontnum);
	return xtermLoadFont(xw, &myfonts, doresize, old_fontnum);
    } else if (x_strcasecmp(myfonts.f_n, DEFFONT)) {
	int code;

	myfonts.f_n = x_strdup(DEFFONT);
	TRACE(("...recovering for TrueType fonts\n"));
	code = xtermLoadFont(xw, &myfonts, doresize, fontnum);
	if (code) {
	    if (fontnum != fontMenu_fontsel) {
		SetItemSensitivity(fontMenuEntries[fontnum].widget,
				   UsingRenderFont(xw));
	    }
	    TRACE(("...recovered size %dx%d\n",
		   FontHeight(screen),
		   FontWidth(screen)));
	}
	return code;
    }
#endif

    releaseWindowGCs(xw, win);

    xtermCloseFonts(xw, fnts);
    TRACE(("Fail Cgs - xtermLoadFont\n"));
    return 0;
}

#if OPT_WIDE_ATTRS
/*
 * (Attempt to) load matching italics for the current normal/bold/etc fonts.
 * If the attempt fails for a given style, use the non-italic font.
 */
void
xtermLoadItalics(XtermWidget xw)
{
    TScreen *screen = TScreenOf(xw);

    if (!screen->ifnts_ok) {
	int n;
	FontNameProperties *fp;
	XTermFonts *data;

	screen->ifnts_ok = True;
	for (n = 0; n < fMAX; ++n) {
	    switch (n) {
	    case fNorm:
		/* FALLTHRU */
	    case fBold:
		/* FALLTHRU */
#if OPT_WIDE_CHARS
	    case fWide:
		/* FALLTHRU */
	    case fWBold:
#endif
		/* FALLTHRU */
		data = getItalicFont(screen, n);

		/*
		 * FIXME - need to handle font-leaks
		 */
		data->fs = 0;
		if (getNormalFont(screen, n)->fs != 0 &&
		    (fp = get_font_name_props(screen->display,
					      getNormalFont(screen, n)->fs,
					      0)) != 0) {
		    if (!open_italic_font(xw, n, fp, data)) {
			if (n > 0) {
			    xtermCopyFontInfo(data,
					      getItalicFont(screen, n - 1));
			} else {
			    xtermOpenFont(xw,
					  getNormalFont(screen, n)->fn,
					  data, False);
			}
		    }
		}
		break;
	    }
	}
    }
}
#endif

#if OPT_LOAD_VTFONTS || OPT_WIDE_CHARS
/*
 * Collect font-names that we can modify with the load-vt-fonts() action.
 */
#define MERGE_SUBFONT(dst,src,name) \
	if (IsEmpty(dst.name)) { \
	    TRACE(("MERGE_SUBFONT " #dst "." #name " merge \"%s\"\n", NonNull(src.name))); \
	    dst.name = x_strdup(src.name); \
	} else { \
	    TRACE(("MERGE_SUBFONT " #dst "." #name " found \"%s\"\n", NonNull(dst.name))); \
	}
#define MERGE_SUBLIST(dst,src,name) \
	if (merge_sublist(&(dst.fonts.x11.name), src.fonts.x11.name)) { \
	    TRACE(("MERGE_SUBLIST " #dst "." #name " merge \"%s\"\n", src.fonts.x11.name[0])); \
	} else { \
	    TRACE(("MERGE_SUBLIST " #dst "." #name " found \"%s\"\n", dst.fonts.x11.name[0])); \
	}

#define INFER_SUBFONT(dst,src,name) \
	if (IsEmpty(dst.name)) { \
	    TRACE(("INFER_SUBFONT " #dst "." #name " will infer\n")); \
	    dst.name = x_strdup(""); \
	} else { \
	    TRACE(("INFER_SUBFONT " #dst "." #name " found \"%s\"\n", NonNull(dst.name))); \
	}

#define FREE_MENU_FONTS(dst) \
	TRACE(("FREE_MENU_FONTS " #dst "\n")); \
	for (n = fontMenu_default; n <= fontMenu_lastBuiltin; ++n) { \
	    for (m = 0; m < fMAX; ++m) { \
		FREE_STRING(dst.menu_font_names[n][m]); \
		dst.menu_font_names[n][m] = 0; \
	    } \
	}

#define COPY_MENU_FONTS(dst,src) \
	TRACE(("COPY_MENU_FONTS " #src " to " #dst "\n")); \
	for (n = fontMenu_default; n <= fontMenu_lastBuiltin; ++n) { \
	    for (m = 0; m < fMAX; ++m) { \
		FREE_STRING(dst.menu_font_names[n][m]); \
		dst.menu_font_names[n][m] = x_strdup(src.menu_font_names[n][m]); \
	    } \
	    TRACE((".. " #dst ".menu_fonts_names[%d] = %s\n", n, NonNull(dst.menu_font_names[n][fNorm]))); \
	}

#define COPY_DEFAULT_FONTS(target, source) \
	TRACE(("COPY_DEFAULT_FONTS " #source " to " #target "\n")); \
	xtermCopyVTFontNames(&target.default_font, &source.default_font)

#define COPY_X11_FONTLISTS(target, source) \
	TRACE(("COPY_X11_FONTLISTS " #source " to " #target "\n")); \
	xtermCopyFontLists(xw, &target.fonts.x11, &source.fonts.x11)

static void
xtermCopyVTFontNames(VTFontNames * target, VTFontNames * source)
{
#define COPY_IT(name,field) \
    TRACE((".. "#name" = %s\n", NonNull(source->field))); \
    free(target->field); \
    target->field = x_strdup(source->field)

    TRACE(("xtermCopyVTFontNames\n"));

    COPY_IT(font, f_n);
    COPY_IT(boldFont, f_b);

#if OPT_WIDE_CHARS
    COPY_IT(wideFont, f_w);
    COPY_IT(wideBoldFont, f_wb);
#endif
#undef COPY_IT
}

static void
xtermCopyFontLists(XtermWidget xw, VTFontList * target, VTFontList * source)
{
#define COPY_IT(name,field) \
    copyFontList(&(target->field), source->field); \
    TRACE_ARGV(".. " #name, source->field)

    (void) xw;
    TRACE(("xtermCopyFontLists %s ->%s\n",
	   whichFontList(xw, source),
	   whichFontList(xw, target)));

    COPY_IT(font, list_n);
    COPY_IT(fontBold, list_b);
#if OPT_WIDE_ATTRS || OPT_RENDERWIDE
    COPY_IT(fontItal, list_i);
#endif
#if OPT_WIDE_CHARS
    COPY_IT(wideFont, list_w);
    COPY_IT(wideBoldFont, list_wb);
    COPY_IT(wideItalFont, list_wi);
#endif
#undef COPY_IT
}

void
xtermSaveVTFonts(XtermWidget xw)
{
    TScreen *screen = TScreenOf(xw);
    Cardinal n, m;

    if (!screen->savedVTFonts) {

	screen->savedVTFonts = True;
	TRACE(("xtermSaveVTFonts saving original\n"));
	COPY_DEFAULT_FONTS(screen->cacheVTFonts, xw->misc);
	COPY_X11_FONTLISTS(screen->cacheVTFonts, xw->work);
	COPY_MENU_FONTS(screen->cacheVTFonts, xw->screen);
    }
}

#define SAME_STRING(x,y) ((x) == (y) || ((x) && (y) && !strcmp(x, y)))
#define SAME_MEMBER(n)   SAME_STRING(a->n, b->n)

static Boolean
sameSubResources(SubResourceRec * a, SubResourceRec * b)
{
    Boolean result = True;

    if (!SAME_MEMBER(default_font.f_n)
	|| !SAME_MEMBER(default_font.f_b)
#if OPT_WIDE_CHARS
	|| !SAME_MEMBER(default_font.f_w)
	|| !SAME_MEMBER(default_font.f_wb)
#endif
	) {
	TRACE(("sameSubResources: default_font differs\n"));
	result = False;
    } else {
	int n;

	for (n = 0; n < NMENUFONTS; ++n) {
	    if (!SAME_MEMBER(menu_font_names[n][fNorm])) {
		TRACE(("sameSubResources: menu_font_names[%d] differs\n", n));
		result = False;
		break;
	    }
	}
    }

    return result;
}

/*
 * Load the "VT" font names from the given subresource name/class.  These
 * correspond to the VT100 resources.
 */
static Bool
xtermLoadVTFonts(XtermWidget xw, String myName, String myClass)
{
    SubResourceRec subresourceRec;
    SubResourceRec referenceRec;

    /*
     * These are duplicates of the VT100 font resources, but with a special
     * application/classname passed in to distinguish them.
     */
    static XtResource font_resources[] =
    {
	Sres(XtNfont, XtCFont, default_font.f_n, DEFFONT),
	Sres(XtNboldFont, XtCBoldFont, default_font.f_b, DEFBOLDFONT),
#if OPT_WIDE_CHARS
	Sres(XtNwideFont, XtCWideFont, default_font.f_w, DEFWIDEFONT),
	Sres(XtNwideBoldFont, XtCWideBoldFont, default_font.f_wb, DEFWIDEBOLDFONT),
#endif
	Sres(XtNfont1, XtCFont1, MenuFontName(fontMenu_font1), NULL),
	Sres(XtNfont2, XtCFont2, MenuFontName(fontMenu_font2), NULL),
	Sres(XtNfont3, XtCFont3, MenuFontName(fontMenu_font3), NULL),
	Sres(XtNfont4, XtCFont4, MenuFontName(fontMenu_font4), NULL),
	Sres(XtNfont5, XtCFont5, MenuFontName(fontMenu_font5), NULL),
	Sres(XtNfont6, XtCFont6, MenuFontName(fontMenu_font6), NULL),
    };
    Cardinal n, m;
    Bool status = True;
    TScreen *screen = TScreenOf(xw);

    TRACE(("called xtermLoadVTFonts(name=%s, class=%s)\n",
	   NonNull(myName), NonNull(myClass)));

    xtermSaveVTFonts(xw);

    if (IsEmpty(myName)) {
	TRACE(("xtermLoadVTFonts restoring original\n"));
	COPY_DEFAULT_FONTS(xw->misc, screen->cacheVTFonts);
	COPY_X11_FONTLISTS(xw->work, screen->cacheVTFonts);
	FREE_MENU_FONTS(xw->screen);
	COPY_MENU_FONTS(xw->screen, screen->cacheVTFonts);
    } else {
	TRACE(("xtermLoadVTFonts(%s, %s)\n", myName, myClass));

	memset(&referenceRec, 0, sizeof(referenceRec));
	memset(&subresourceRec, 0, sizeof(subresourceRec));
	XtGetSubresources((Widget) xw, (XtPointer) &subresourceRec,
			  myName, myClass,
			  font_resources,
			  (Cardinal) XtNumber(font_resources),
			  NULL, (Cardinal) 0);

	/*
	 * XtGetSubresources returns no status, so we compare the returned
	 * data against a zero'd struct to see if any data is returned.
	 */
	if (memcmp(&referenceRec, &subresourceRec, sizeof(referenceRec))
	    && !sameSubResources(&(screen->cacheVTFonts), &subresourceRec)) {

	    screen->mergedVTFonts = True;

	    /*
	     * To make it simple, reallocate the strings returned by
	     * XtGetSubresources.  We can free our own strings, but not theirs.
	     */
	    ALLOC_STRING(subresourceRec.default_font.f_n);
	    ALLOC_STRING(subresourceRec.default_font.f_b);
#if OPT_WIDE_CHARS
	    ALLOC_STRING(subresourceRec.default_font.f_w);
	    ALLOC_STRING(subresourceRec.default_font.f_wb);
#endif
	    for (n = fontMenu_font1; n <= fontMenu_lastBuiltin; ++n) {
		ALLOC_STRING(subresourceRec.MenuFontName(n));
	    }

	    /*
	     * Now, save the string to a font-list for consistency
	     */
#define ALLOC_SUBLIST(which,field) \
	    save2FontList(xw, "cached", \
			  &(subresourceRec.fonts), \
			  which, \
			  subresourceRec.default_font.field, False)

	    ALLOC_SUBLIST(fNorm, f_n);
	    ALLOC_SUBLIST(fBold, f_b);
#if OPT_WIDE_CHARS
	    ALLOC_SUBLIST(fWide, f_w);
	    ALLOC_SUBLIST(fWBold, f_wb);
#endif

	    /*
	     * If a particular resource value was not found, use the original.
	     */
	    MERGE_SUBFONT(subresourceRec, xw->misc, default_font.f_n);
	    INFER_SUBFONT(subresourceRec, xw->misc, default_font.f_b);
	    MERGE_SUBLIST(subresourceRec, xw->work, list_n);
	    MERGE_SUBLIST(subresourceRec, xw->work, list_b);
#if OPT_WIDE_CHARS
	    INFER_SUBFONT(subresourceRec, xw->misc, default_font.f_w);
	    INFER_SUBFONT(subresourceRec, xw->misc, default_font.f_wb);
	    MERGE_SUBLIST(subresourceRec, xw->work, list_w);
	    MERGE_SUBLIST(subresourceRec, xw->work, list_wb);
#endif
	    for (n = fontMenu_font1; n <= fontMenu_lastBuiltin; ++n) {
		MERGE_SUBFONT(subresourceRec, xw->screen, MenuFontName(n));
	    }

	    /*
	     * Finally, copy the subresource data to the widget.
	     */
	    COPY_DEFAULT_FONTS(xw->misc, subresourceRec);
	    COPY_X11_FONTLISTS(xw->work, subresourceRec);
	    FREE_MENU_FONTS(xw->screen);
	    COPY_MENU_FONTS(xw->screen, subresourceRec);

	    FREE_STRING(screen->MenuFontName(fontMenu_default));
	    FREE_STRING(screen->menu_font_names[0][fBold]);
	    screen->MenuFontName(fontMenu_default) = x_strdup(DefaultFontN(xw));
	    screen->menu_font_names[0][fBold] = x_strdup(DefaultFontB(xw));
#if OPT_WIDE_CHARS
	    FREE_STRING(screen->menu_font_names[0][fWide]);
	    FREE_STRING(screen->menu_font_names[0][fWBold]);
	    screen->menu_font_names[0][fWide] = x_strdup(DefaultFontW(xw));
	    screen->menu_font_names[0][fWBold] = x_strdup(DefaultFontWB(xw));
#endif
	    /*
	     * And remove our copies of strings.
	     */
	    FREE_STRING(subresourceRec.default_font.f_n);
	    FREE_STRING(subresourceRec.default_font.f_b);
#if OPT_WIDE_CHARS
	    FREE_STRING(subresourceRec.default_font.f_w);
	    FREE_STRING(subresourceRec.default_font.f_wb);
#endif
	    for (n = fontMenu_font1; n <= fontMenu_lastBuiltin; ++n) {
		FREE_STRING(subresourceRec.MenuFontName(n));
	    }
	} else {
	    TRACE(("...no resources found\n"));
	    status = False;
	}
    }
    TRACE((".. xtermLoadVTFonts: %d\n", status));
    return status;
}

#if OPT_WIDE_CHARS
static Bool
isWideFont(XFontStruct *fp, const char *tag, Bool nullOk)
{
    Bool result = False;

    (void) tag;
    if (okFont(fp)) {
	unsigned count = countGlyphs(fp);
	TRACE(("isWideFont(%s) found %d cells\n", tag, count));
	result = (count > 256) ? True : False;
    } else {
	result = nullOk;
    }
    return result;
}

/*
 * If the current fonts are not wide, load the UTF8 fonts.
 *
 * Called during initialization (for wide-character mode), the fonts have not
 * been setup, so we pass nullOk=True to isWideFont().
 *
 * Called after initialization, e.g., in response to the UTF-8 menu entry
 * (starting from narrow character mode), it checks if the fonts are not wide.
 */
Bool
xtermLoadWideFonts(XtermWidget xw, Bool nullOk)
{
    TScreen *screen = TScreenOf(xw);
    Bool result;

    if (EmptyFont(getNormalFont(screen, fWide)->fs)) {
	result = (isWideFont(getNormalFont(screen, fNorm)->fs, "normal", nullOk)
		  && isWideFont(getNormalFont(screen, fBold)->fs, "bold", nullOk));
    } else {
	result = (isWideFont(getNormalFont(screen, fWide)->fs, "wide", nullOk)
		  && isWideFont(getNormalFont(screen, fWBold)->fs,
				"wide-bold", nullOk));
	if (result && !screen->utf8_latin1) {
	    result = (isWideFont(getNormalFont(screen, fNorm)->fs, "normal", nullOk)
		      && isWideFont(getNormalFont(screen, fBold)->fs,
				    "bold", nullOk));
	}
    }
    if (!result) {
	TRACE(("current fonts are not all wide%s\n", nullOk ? " nullOk" : ""));
	result = xtermLoadVTFonts(xw, XtNutf8Fonts, XtCUtf8Fonts);
    }
    TRACE(("xtermLoadWideFonts:%d\n", result));
    return result;
}
#endif /* OPT_WIDE_CHARS */

/*
 * Restore the default fonts, i.e., if we had switched to wide-fonts.
 */
Bool
xtermLoadDefaultFonts(XtermWidget xw)
{
    Bool result;
    result = xtermLoadVTFonts(xw, NULL, NULL);
    TRACE(("xtermLoadDefaultFonts:%d\n", result));
    return result;
}
#endif /* OPT_LOAD_VTFONTS || OPT_WIDE_CHARS */

#if OPT_LOAD_VTFONTS
void
HandleLoadVTFonts(Widget w,
		  XEvent *event GCC_UNUSED,
		  String *params GCC_UNUSED,
		  Cardinal *param_count GCC_UNUSED)
{
    XtermWidget xw;

    if ((xw = getXtermWidget(w)) != 0) {
	static char empty[] = "";	/* appease strict compilers */

	TScreen *screen = TScreenOf(xw);
	char name_buf[80];
	String name = (String) ((*param_count > 0) ? params[0] : empty);
	char *myName = MyStackAlloc(strlen(name) + 1, name_buf);

	TRACE(("HandleLoadVTFonts(%d)\n", *param_count));
	if (myName != 0) {
	    char class_buf[80];
	    String convert = (String) ((*param_count > 1) ? params[1] : myName);
	    char *myClass = MyStackAlloc(strlen(convert) + 1, class_buf);

	    strcpy(myName, name);
	    if (myClass != 0) {
		strcpy(myClass, convert);
		if (*param_count == 1)
		    myClass[0] = x_toupper(myClass[0]);

		if (xtermLoadVTFonts(xw, myName, myClass)) {
		    int n;
		    /*
		     * When switching fonts, try to preserve the font-menu
		     * selection, since it is less surprising to do that (if
		     * the font-switching can be undone) than to switch to
		     * "Default".
		     */
		    int font_number = screen->menu_font_number;
		    if (font_number > fontMenu_lastBuiltin)
			font_number = fontMenu_lastBuiltin;
		    for (n = 0; n < NMENUFONTS; ++n) {
			screen->menu_font_sizes[n] = 0;
		    }
		    if (font_number == fontMenu_default) {
			SetVTFont(xw, font_number, True, defaultVTFontNames(xw));
		    } else {
			SetVTFont(xw, font_number, True, NULL);
		    }
		}
		MyStackFree(myClass, class_buf);
	    }
	    MyStackFree(myName, name_buf);
	}
    }
}
#endif /* OPT_LOAD_VTFONTS */

/*
 * Set the limits for the box that outlines the cursor.
 */
void
xtermSetCursorBox(TScreen *screen)
{
    static XPoint VTbox[NBOX];
    XPoint *vp;
    int fw = FontWidth(screen) - 1;
    int fh = FontHeight(screen) - 1;
    int ww = isCursorBar(screen) ? 1 : fw;
    int hh = isCursorUnderline(screen) ? 1 : fh;

    vp = &VTbox[1];
    (vp++)->x = (short) ww;
    (vp++)->y = (short) hh;
    (vp++)->x = (short) -ww;
    vp->y = (short) -hh;

    screen->box = VTbox;
}

#define CACHE_XFT(dst,src) if (src != 0) {\
	    checkXft(xw, &(dst[fontnum]), src);\
	    TRACE(("Xft metrics %s[%d] = %d (%d,%d)%s advance %d, actual %d%s\n",\
		#dst,\
	    	fontnum,\
		src->height,\
		src->ascent,\
		src->descent,\
		((src->ascent + src->descent) > src->height ? "*" : ""),\
		src->max_advance_width,\
		dst[fontnum].map.min_width,\
		dst[fontnum].map.mixed ? " mixed" : ""));\
	}

#if OPT_RENDERFONT

#if OPT_REPORT_FONTS
static FcChar32
xtermXftFirstChar(XftFont *xft)
{
    FcChar32 map[FC_CHARSET_MAP_SIZE];
    FcChar32 next;
    FcChar32 first;
    int i;

    first = FcCharSetFirstPage(xft->charset, map, &next);
    for (i = 0; i < FC_CHARSET_MAP_SIZE; i++) {
	if (map[i]) {
	    FcChar32 bits = map[i];
	    first += (FcChar32) i *32;
	    while (!(bits & 0x1)) {
		bits >>= 1;
		first++;
	    }
	    break;
	}
    }
    return first;
}

static FcChar32
xtermXftLastChar(XftFont *xft)
{
    FcChar32 this, last, next;
    FcChar32 map[FC_CHARSET_MAP_SIZE];
    int i;
    last = FcCharSetFirstPage(xft->charset, map, &next);
    while ((this = FcCharSetNextPage(xft->charset, map, &next)) != FC_CHARSET_DONE)
	last = this;
    last &= (FcChar32) ~ 0xff;
    for (i = FC_CHARSET_MAP_SIZE - 1; i >= 0; i--) {
	if (map[i]) {
	    FcChar32 bits = map[i];
	    last += (FcChar32) i *32 + 31;
	    while (!(bits & 0x80000000)) {
		last--;
		bits <<= 1;
	    }
	    break;
	}
    }
    return (FcChar32) last;
}
#endif /* OPT_REPORT_FONTS */

#if OPT_TRACE > 1
static void
dumpXft(XtermWidget xw, XTermXftFonts *data)
{
    XftFont *xft = data->font;
    TScreen *screen = TScreenOf(xw);
    VTwin *win = WhichVWin(screen);

    FcChar32 c;
    FcChar32 first = xtermXftFirstChar(xft);
    FcChar32 last = xtermXftLastChar(xft);
    unsigned count = 0;
    unsigned outside = 0;

    TRACE(("dumpXft {{\n"));
    TRACE(("   data range %#6x..%#6x\n", first, last));
    for (c = first; c <= last; ++c) {
	if (FcCharSetHasChar(xft->charset, c)) {
	    int width = my_wcwidth((int) c);
	    XGlyphInfo extents;

	    XftTextExtents32(XtDisplay(xw), xft, &c, 1, &extents);
	    TRACE(("%#6x  %2d  %.1f\n", c, width,
		   ((double) extents.width) / win->f_width));
	    if (extents.width > win->f_width)
		++outside;
	    ++count;
	}
    }
    TRACE(("}} %u total, %u outside\n", count, outside));
}
#define DUMP_XFT(xw, data) dumpXft(xw, data)
#else
#define DUMP_XFT(xw, data)	/* nothing */
#endif

static void
checkXft(XtermWidget xw, XTermXftFonts *data, XftFont *xft)
{
    FcChar32 c;
    Dimension width = 0;

    data->font = xft;
    data->map.min_width = 0;
    data->map.max_width = (Dimension) xft->max_advance_width;

    /*
     * For each ASCII or ISO-8859-1 printable code, ask what its width is.
     * Given the maximum width for those, we have a reasonable estimate of
     * the single-column width.
     *
     * Ignore control characters - their extent information is misleading.
     */
    for (c = 32; c < 256; ++c) {
	if (c >= 127 && c <= 159)
	    continue;
	if (FcCharSetHasChar(xft->charset, c)) {
	    XGlyphInfo extents;

	    XftTextExtents32(XtDisplay(xw), xft, &c, 1, &extents);
	    if (width < extents.width && extents.width <= data->map.max_width) {
		width = extents.width;
	    }
	}
    }
    data->map.min_width = width;
    data->map.mixed = (data->map.max_width >= (data->map.min_width + 1));
}

#if OPT_REPORT_FONTS
static void
reportXftFonts(XtermWidget xw,
	       XftFont *fp,
	       const char *name,
	       const char *tag,
	       XftPattern *match)
{
    if (resource.reportFonts) {
	char buffer[1024];
	FcChar32 first_char = xtermXftFirstChar(fp);
	FcChar32 last_char = xtermXftLastChar(fp);
	FcChar32 ch;
	unsigned missing = 0;

	printf("Loaded XftFonts(%s[%s])\n", name, tag);

	for (ch = first_char; ch <= last_char; ++ch) {
	    if (xtermXftMissing(xw, fp, ch)) {
		++missing;
	    }
	}
	printf("\t\tfirst char:    %u\n", first_char);
	printf("\t\tlast char:     %u\n", last_char);
	printf("\t\tmissing-chars: %u\n", missing);
	printf("\t\tpresent-chars: %u\n", (last_char - first_char) + 1 - missing);

	if (XftNameUnparse(match, buffer, (int) sizeof(buffer))) {
	    char *target;
	    char *source = buffer;
	    while ((target = strtok(source, ":")) != 0) {
		printf("\t%s\n", target);
		source = 0;
	    }
	}
    }
}
#else
#define reportXftFonts(xw, result, name, tag, match)	/* empty */
#endif /* OPT_REPORT_FONTS */

static XftFont *
xtermOpenXft(XtermWidget xw, const char *name, XftPattern *pat, const char *tag)
{
    TScreen *screen = TScreenOf(xw);
    Display *dpy = screen->display;
    XftResult status;
    XftFont *result = 0;

    if (pat != 0) {
	XftPattern *match = XftFontMatch(dpy, DefaultScreen(dpy), pat, &status);
	if (match != 0) {
	    result = XftFontOpenPattern(dpy, match);
	    if (result != 0) {
		TRACE(("...matched %s font\n", tag));
		reportXftFonts(xw, result, name, tag, match);
	    } else {
		TRACE(("...could did not open %s font\n", tag));
		XftPatternDestroy(match);
		if (xw->misc.fontWarnings >= fwAlways) {
		    TRACE(("OOPS cannot open %s font \"%s\"\n", tag, name));
		    cannotFont(xw, "open", tag, name);
		}
	    }
	} else {
	    TRACE(("...did not match %s font\n", tag));
	    if (xw->misc.fontWarnings >= fwResource) {
		TRACE(("OOPS: cannot match %s font \"%s\"\n", tag, name));
		cannotFont(xw, "match", tag, name);
	    }
	}
    }
    return result;
}
#endif

#if OPT_RENDERFONT
#if OPT_SHIFT_FONTS
/*
 * Don't make a dependency on the math library for a single function.
 * (Newton Raphson).
 */
static double
dimSquareRoot(double value)
{
    double result = 0.0;
    if (value > 0.0) {
	int n;
	double older = value;
	for (n = 0; n < 10; ++n) {
	    double delta = (older * older - value) / (2.0 * older);
	    double newer = older - delta;
	    older = newer;
	    result = newer;
	    if (delta > -0.001 && delta < 0.001)
		break;
	}
    }
    return result;
}
#endif

/*
 * Given the Xft font metrics, determine the actual font size.  This is used
 * for each font to ensure that normal, bold and italic fonts follow the same
 * rule.
 */
static void
setRenderFontsize(TScreen *screen, VTwin *win, XftFont *font, const char *tag)
{
    if (font != 0) {
	int width, height, ascent, descent;

	(void) screen;

	width = font->max_advance_width;
	height = font->height;
	ascent = font->ascent;
	descent = font->descent;
	if (height < ascent + descent) {
	    TRACE(("...increase height from %d\n", height));
	    height = ascent + descent;
	}
	if (is_double_width_font_xft(screen->display, font)) {
	    TRACE(("...reduced width from %d\n", width));
	    width >>= 1;
	}
	if (tag == 0) {
	    SetFontWidth(screen, win, width);
	    SetFontHeight(screen, win, height);
	    win->f_ascent = ascent;
	    win->f_descent = descent;
	    TRACE(("setRenderFontsize result %dx%d (%d+%d)\n",
		   width, height, ascent, descent));
	} else if (win->f_width < width ||
		   win->f_height < height ||
		   win->f_ascent < ascent ||
		   win->f_descent < descent) {
	    TRACE(("setRenderFontsize %s changed %dx%d (%d+%d) to %dx%d (%d+%d)\n",
		   tag,
		   win->f_width, win->f_height, win->f_ascent, win->f_descent,
		   width, height, ascent, descent));

	    SetFontWidth(screen, win, width);
	    SetFontHeight(screen, win, height);
	    win->f_ascent = ascent;
	    win->f_descent = descent;
	} else {
	    TRACE(("setRenderFontsize %s unchanged\n", tag));
	}
    }
}
#endif

static void
checkFontInfo(int value, const char *tag)
{
    if (value == 0) {
	xtermWarning("Selected font has no non-zero %s for ISO-8859-1 encoding\n", tag);
	exit(1);
    }
}

#if OPT_RENDERFONT
void
xtermCloseXft(TScreen *screen, XTermXftFonts *pub)
{
    if (pub->font != 0) {
	XftFontClose(screen->display, pub->font);
	pub->font = 0;
    }
}

/*
 * Get the faceName/faceDoublesize resource setting.
 */
String
getFaceName(XtermWidget xw, Bool wideName GCC_UNUSED)
{
#if OPT_RENDERWIDE
    String result = (wideName
		     ? FirstItemOf(xw->work.fonts.xft.list_w)
		     : CurrentXftFont(xw));
#else
    String result = CurrentXftFont(xw);
#endif
    return x_nonempty(result);
}

/*
 * If we change the faceName, we'll have to re-acquire all of the fonts that
 * are derived from it.
 */
void
setFaceName(XtermWidget xw, const char *value)
{
    TScreen *screen = TScreenOf(xw);
    Boolean changed = (Boolean) ((CurrentXftFont(xw) == 0)
				 || strcmp(CurrentXftFont(xw), value));

    if (changed) {
	int n;

	CurrentXftFont(xw) = x_strdup(value);
	for (n = 0; n < NMENUFONTS; ++n) {
	    int e;
	    xw->misc.face_size[n] = -1.0;
	    for (e = 0; e < fMAX; ++e) {
		xtermCloseXft(screen, getMyXftFont(xw, e, n));
	    }
	}
    }
}
#endif

/*
 * Compute useful values for the font/window sizes
 */
void
xtermComputeFontInfo(XtermWidget xw,
		     VTwin *win,
		     XFontStruct *font,
		     int sbwidth)
{
    TScreen *screen = TScreenOf(xw);

    int i, j, width, height;
#if OPT_RENDERFONT
    int fontnum = screen->menu_font_number;
#endif

#if OPT_RENDERFONT
    /*
     * xterm contains a lot of references to fonts, assuming they are fixed
     * size.  This chunk of code overrides the actual font-selection (see
     * drawXtermText()), if the user has selected render-font.  All of the
     * font-loading for fixed-fonts still goes on whether or not this chunk
     * overrides it.
     */
    if (UsingRenderFont(xw) && fontnum >= 0) {
	String face_name = getFaceName(xw, False);
	XftFont *norm = screen->renderFontNorm[fontnum].font;
	XftFont *bold = screen->renderFontBold[fontnum].font;
	XftFont *ital = screen->renderFontItal[fontnum].font;
#if OPT_RENDERWIDE
	XftFont *wnorm = screen->renderWideNorm[fontnum].font;
	XftFont *wbold = screen->renderWideBold[fontnum].font;
	XftFont *wital = screen->renderWideItal[fontnum].font;
#endif

	if (norm == 0 && face_name) {
	    XftPattern *pat;
	    double face_size;

	    TRACE(("xtermComputeFontInfo font %d: norm(face %s, size %.1f)\n",
		   fontnum, face_name,
		   xw->misc.face_size[fontnum]));

	    fillInFaceSize(xw, fontnum);
	    face_size = xw->misc.face_size[fontnum];

	    /*
	     * By observation (there is no documentation), XftPatternBuild is
	     * cumulative.  Build the bold- and italic-patterns on top of the
	     * normal pattern.
	     */
#define NormXftPattern \
	    XFT_FAMILY, XftTypeString, "mono", \
	    XFT_SIZE, XftTypeDouble, face_size

#define BoldXftPattern(norm) \
	    XFT_WEIGHT, XftTypeInteger, XFT_WEIGHT_BOLD, \
	    XFT_CHAR_WIDTH, XftTypeInteger, norm->max_advance_width

#define ItalXftPattern(norm) \
	    XFT_SLANT, XftTypeInteger, XFT_SLANT_ITALIC, \
	    XFT_CHAR_WIDTH, XftTypeInteger, norm->max_advance_width

#if OPT_WIDE_ATTRS
#define HAVE_ITALICS 1
#define FIND_ITALICS ((pat = XftNameParse(face_name)) != 0)
#elif OPT_ISO_COLORS
#define HAVE_ITALICS 1
#define FIND_ITALICS (screen->italicULMode && (pat = XftNameParse(face_name)) != 0)
#else
#define HAVE_ITALICS 0
#endif

	    if ((pat = XftNameParse(face_name)) != 0) {
#define OPEN_XFT(tag) xtermOpenXft(xw, face_name, pat, tag)
		XftPatternBuild(pat,
				NormXftPattern,
				(void *) 0);
		norm = OPEN_XFT("normal");

		if (norm != 0) {
		    XftPatternBuild(pat,
				    BoldXftPattern(norm),
				    (void *) 0);
		    bold = OPEN_XFT("bold");

#if HAVE_ITALICS
		    if (FIND_ITALICS) {
			XftPatternBuild(pat,
					NormXftPattern,
					ItalXftPattern(norm),
					(void *) 0);
			ital = OPEN_XFT("italic");
		    }
#endif
#undef OPEN_XFT

		    /*
		     * FIXME:  just assume that the corresponding font has no
		     * graphics characters.
		     */
		    if (screen->fnt_boxes) {
			screen->fnt_boxes = False;
			TRACE(("Xft opened - will %suse internal line-drawing characters\n",
			       screen->fnt_boxes ? "not " : ""));
		    }
		}

		XftPatternDestroy(pat);
	    }

	    CACHE_XFT(screen->renderFontNorm, norm);
	    CACHE_XFT(screen->renderFontBold, bold);
	    CACHE_XFT(screen->renderFontItal, ital);

	    /*
	     * See xtermXftDrawString().
	     */
#if OPT_RENDERWIDE
	    if (norm != 0 && screen->wide_chars) {
		int char_width = norm->max_advance_width * 2;
#ifdef FC_ASPECT
		double aspect = ((FirstItemOf(xw->work.fonts.xft.list_w)
				  || screen->renderFontNorm[fontnum].map.mixed)
				 ? 1.0
				 : 2.0);
#endif

		face_name = getFaceName(xw, True);
		TRACE(("xtermComputeFontInfo wide(face %s, char_width %d)\n",
		       NonNull(face_name),
		       char_width));

#define WideXftPattern \
		XFT_FAMILY, XftTypeString, "mono", \
		XFT_SIZE, XftTypeDouble, face_size, \
		XFT_SPACING, XftTypeInteger, XFT_MONO

		if (face_name && (pat = XftNameParse(face_name)) != 0) {
#define OPEN_XFT(tag) xtermOpenXft(xw, face_name, pat, tag)
		    XftPatternBuild(pat,
				    WideXftPattern,
				    XFT_CHAR_WIDTH, XftTypeInteger, char_width,
#ifdef FC_ASPECT
				    FC_ASPECT, XftTypeDouble, aspect,
#endif
				    (void *) 0);
		    wnorm = OPEN_XFT("wide");

		    if (wnorm != 0) {
			XftPatternBuild(pat,
					WideXftPattern,
					BoldXftPattern(wnorm),
					(void *) 0);
			wbold = OPEN_XFT("wide-bold");

#if HAVE_ITALICS
			if (FIND_ITALICS) {
			    XftPatternBuild(pat,
					    WideXftPattern,
					    ItalXftPattern(wnorm),
					    (void *) 0);
			    wital = OPEN_XFT("wide-italic");
			}
#endif
#undef OPEN_XFT
		    }
		    XftPatternDestroy(pat);
		}

		CACHE_XFT(screen->renderWideNorm, wnorm);
		CACHE_XFT(screen->renderWideBold, wbold);
		CACHE_XFT(screen->renderWideItal, wital);
	    }
#endif /* OPT_RENDERWIDE */
	}
	if (norm == 0) {
	    TRACE(("...no TrueType font found for number %d, disable menu entry\n", fontnum));
	    xw->work.render_font = False;
	    update_font_renderfont();
	    /* now we will fall through into the bitmap fonts */
	} else {
	    setRenderFontsize(screen, win, norm, NULL);
	    setRenderFontsize(screen, win, bold, "bold");
	    setRenderFontsize(screen, win, ital, "ital");
#if OPT_BOX_CHARS
	    setupPackedFonts(xw);

	    if (screen->force_packed) {
		XTermXftFonts *use = &(screen->renderFontNorm[fontnum]);
		SetFontHeight(screen, win, use->font->ascent + use->font->descent);
		SetFontWidth(screen, win, use->map.min_width);
		TRACE(("...packed TrueType font %dx%d vs %d\n",
		       win->f_height,
		       win->f_width,
		       use->map.max_width));
	    }
#endif
	    DUMP_XFT(xw, &(screen->renderFontNorm[fontnum]));
	}
    }
    /*
     * Are we handling a bitmap font?
     */
    else
#endif /* OPT_RENDERFONT */
    {
	if (is_double_width_font(font) && !(screen->fnt_prop)) {
	    SetFontWidth(screen, win, font->min_bounds.width);
	} else {
	    SetFontWidth(screen, win, font->max_bounds.width);
	}
	SetFontHeight(screen, win, font->ascent + font->descent);
	win->f_ascent = font->ascent;
	win->f_descent = font->descent;
    }
    i = 2 * screen->border + sbwidth;
    j = 2 * screen->border;
    width = MaxCols(screen) * win->f_width + i;
    height = MaxRows(screen) * win->f_height + j;
    win->fullwidth = (Dimension) width;
    win->fullheight = (Dimension) height;
    win->width = width - i;
    win->height = height - j;

    TRACE(("xtermComputeFontInfo window %dx%d (full %dx%d), fontsize %dx%d (asc %d, dsc %d)\n",
	   win->height,
	   win->width,
	   win->fullheight,
	   win->fullwidth,
	   win->f_height,
	   win->f_width,
	   win->f_ascent,
	   win->f_descent));

    checkFontInfo(win->f_height, "height");
    checkFontInfo(win->f_width, "width");
}

/* save this information as a side-effect for double-sized characters */
void
xtermSaveFontInfo(TScreen *screen, XFontStruct *font)
{
    screen->fnt_wide = (Dimension) (font->max_bounds.width);
    screen->fnt_high = (Dimension) (font->ascent + font->descent);
    TRACE(("xtermSaveFontInfo %dx%d\n", screen->fnt_high, screen->fnt_wide));
}

/*
 * After loading a new font, update the structures that use its size.
 */
void
xtermUpdateFontInfo(XtermWidget xw, Bool doresize)
{
    TScreen *screen = TScreenOf(xw);

    int scrollbar_width;
    VTwin *win = &(screen->fullVwin);

    scrollbar_width = (xw->misc.scrollbar
		       ? (screen->scrollWidget->core.width +
			  BorderWidth(screen->scrollWidget))
		       : 0);
    xtermComputeFontInfo(xw, win, getNormalFont(screen, fNorm)->fs, scrollbar_width);
    xtermSaveFontInfo(screen, getNormalFont(screen, fNorm)->fs);

    if (doresize) {
	if (VWindow(screen)) {
	    xtermClear(xw);
	}
	TRACE(("xtermUpdateFontInfo {{\n"));
	DoResizeScreen(xw);	/* set to the new natural size */
	ResizeScrollBar(xw);
	Redraw();
	TRACE(("... }} xtermUpdateFontInfo\n"));
#ifdef SCROLLBAR_RIGHT
	updateRightScrollbar(xw);
#endif
    }
    xtermSetCursorBox(screen);
}

#if OPT_BOX_CHARS || OPT_REPORT_FONTS

/*
 * Returns true if the given character is missing from the specified font.
 */
Bool
xtermMissingChar(unsigned ch, XTermFonts * font)
{
    Bool result = False;
    XFontStruct *fs = font->fs;
    XCharStruct *pc = 0;

    if (fs->max_byte1 == 0) {
#if OPT_WIDE_CHARS
	if (ch < 256)
#endif
	{
	    CI_GET_CHAR_INFO_1D(fs, E2A(ch), pc);
	}
    }
#if OPT_WIDE_CHARS
    else {
	unsigned row = (ch >> 8);
	unsigned col = (ch & 0xff);
	CI_GET_CHAR_INFO_2D(fs, row, col, pc);
    }
#endif

    if (pc == 0 || CI_NONEXISTCHAR(pc)) {
	TRACE2(("xtermMissingChar %#04x (!exists), %d cells\n",
		ch, my_wcwidth((wchar_t) ch)));
	result = True;
    }
    if (ch < KNOWN_MISSING) {
	font->known_missing[ch] = (Char) (result ? 2 : 1);
    }
    return result;
}
#endif

#if OPT_BOX_CHARS
/*
 * The grid is arbitrary, enough resolution that nothing's lost in
 * initialization.
 */
#define BOX_HIGH 60
#define BOX_WIDE 60

#define MID_HIGH (BOX_HIGH/2)
#define MID_WIDE (BOX_WIDE/2)

#define CHR_WIDE ((9*BOX_WIDE)/10)
#define CHR_HIGH ((9*BOX_HIGH)/10)

/*
 * ...since we'll scale the values anyway.
 */
#define SCALED_X(n) ((int)(n) * (((int) font_width) - 1)) / (BOX_WIDE-1)
#define SCALED_Y(n) ((int)(n) * (((int) font_height) - 1)) / (BOX_HIGH-1)
#define SCALE_X(n) n = SCALED_X(n)
#define SCALE_Y(n) n = SCALED_Y(n)

#define SEG(x0,y0,x1,y1) x0,y0, x1,y1

/*
 * Draw the given graphic character, if it is simple enough (i.e., a
 * line-drawing character).
 */
void
xtermDrawBoxChar(XtermWidget xw,
		 unsigned ch,
		 unsigned attr_flags,
		 unsigned draw_flags,
		 GC gc,
		 int x,
		 int y,
		 int cells)
{
    TScreen *screen = TScreenOf(xw);
    /* *INDENT-OFF* */
    static const short glyph_ht[] = {
	SEG(1*BOX_WIDE/10,  0,		1*BOX_WIDE/10,5*MID_HIGH/6),	/* H */
	SEG(6*BOX_WIDE/10,  0,		6*BOX_WIDE/10,5*MID_HIGH/6),
	SEG(1*BOX_WIDE/10,5*MID_HIGH/12,6*BOX_WIDE/10,5*MID_HIGH/12),
	SEG(2*BOX_WIDE/10,  MID_HIGH,	  CHR_WIDE,	MID_HIGH),	/* T */
	SEG(6*BOX_WIDE/10,  MID_HIGH,	6*BOX_WIDE/10,	CHR_HIGH),
	-1
    }, glyph_ff[] = {
	SEG(1*BOX_WIDE/10,  0,		6*BOX_WIDE/10,	0),		/* F */
	SEG(1*BOX_WIDE/10,5*MID_HIGH/12,6*CHR_WIDE/12,5*MID_HIGH/12),
	SEG(1*BOX_WIDE/10,  0,		0*BOX_WIDE/3, 5*MID_HIGH/6),
	SEG(1*BOX_WIDE/3,   MID_HIGH,	  CHR_WIDE,	MID_HIGH),	/* F */
	SEG(1*BOX_WIDE/3, 8*MID_HIGH/6,10*CHR_WIDE/12,8*MID_HIGH/6),
	SEG(1*BOX_WIDE/3,   MID_HIGH,	1*BOX_WIDE/3,	CHR_HIGH),
	-1
    }, glyph_lf[] = {
	SEG(1*BOX_WIDE/10,  0,		1*BOX_WIDE/10,9*MID_HIGH/12),	/* L */
	SEG(1*BOX_WIDE/10,9*MID_HIGH/12,6*BOX_WIDE/10,9*MID_HIGH/12),
	SEG(1*BOX_WIDE/3,   MID_HIGH,	  CHR_WIDE,	MID_HIGH),	/* F */
	SEG(1*BOX_WIDE/3, 8*MID_HIGH/6,10*CHR_WIDE/12,8*MID_HIGH/6),
	SEG(1*BOX_WIDE/3,   MID_HIGH,	1*BOX_WIDE/3,	CHR_HIGH),
	-1
    }, glyph_nl[] = {
	SEG(1*BOX_WIDE/10,5*MID_HIGH/6, 1*BOX_WIDE/10,	0),		/* N */
	SEG(1*BOX_WIDE/10,  0,		5*BOX_WIDE/6, 5*MID_HIGH/6),
	SEG(5*BOX_WIDE/6, 5*MID_HIGH/6, 5*BOX_WIDE/6,	0),
	SEG(1*BOX_WIDE/3,   MID_HIGH,	1*BOX_WIDE/3,	CHR_HIGH),	/* L */
	SEG(1*BOX_WIDE/3,   CHR_HIGH,	  CHR_WIDE,	CHR_HIGH),
	-1
    }, glyph_vt[] = {
	SEG(1*BOX_WIDE/10,   0,		5*BOX_WIDE/12,5*MID_HIGH/6),	/* V */
	SEG(5*BOX_WIDE/12,5*MID_HIGH/6, 5*BOX_WIDE/6,	0),
	SEG(2*BOX_WIDE/10,  MID_HIGH,	  CHR_WIDE,	MID_HIGH),	/* T */
	SEG(6*BOX_WIDE/10,  MID_HIGH,	6*BOX_WIDE/10,	CHR_HIGH),
	-1
    }, plus_or_minus[] =
    {
	SEG(  0,	  5*BOX_HIGH/6,	  CHR_WIDE,   5*BOX_HIGH/6),
	SEG(  MID_WIDE,	  2*BOX_HIGH/6,	  MID_WIDE,   4*BOX_HIGH/6),
	SEG(  0,	  3*BOX_HIGH/6,	  CHR_WIDE,   3*BOX_HIGH/6),
	-1
    }, lower_right_corner[] =
    {
	SEG(  0,	    MID_HIGH,	  MID_WIDE,	MID_HIGH),
	SEG(  MID_WIDE,	    MID_HIGH,	  MID_WIDE,	0),
	-1
    }, upper_right_corner[] =
    {
	SEG(  0,	    MID_HIGH,	  MID_WIDE,	MID_HIGH),
	SEG( MID_WIDE,	    MID_HIGH,	  MID_WIDE,	BOX_HIGH),
	-1
    }, upper_left_corner[] =
    {
	SEG(  MID_WIDE,	    MID_HIGH,	  BOX_WIDE,	MID_HIGH),
	SEG(  MID_WIDE,	    MID_HIGH,	  MID_WIDE,	BOX_HIGH),
	-1
    }, lower_left_corner[] =
    {
	SEG(  MID_WIDE,	    0,		  MID_WIDE,	MID_HIGH),
	SEG(  MID_WIDE,	    MID_WIDE,	  BOX_WIDE,	MID_HIGH),
	-1
    }, cross[] =
    {
	SEG(  0,	    MID_HIGH,	  BOX_WIDE,	MID_HIGH),
	SEG(  MID_WIDE,	    0,		  MID_WIDE,	BOX_HIGH),
	-1
    }, scan_line_1[] =
    {
	SEG(  0,	    0,		  BOX_WIDE,	0),
	-1
    }, scan_line_3[] =
    {
	SEG(  0,	    BOX_HIGH/4,	  BOX_WIDE,	BOX_HIGH/4),
	-1
    }, scan_line_7[] =
    {
	SEG( 0,		    MID_HIGH,	  BOX_WIDE,	MID_HIGH),
	-1
    }, scan_line_9[] =
    {
	SEG(  0,	  3*BOX_HIGH/4,	  BOX_WIDE,   3*BOX_HIGH/4),
	-1
    }, horizontal_line[] =
    {
	SEG(  0,	    BOX_HIGH,	  BOX_WIDE,	BOX_HIGH),
	-1
    }, left_tee[] =
    {
	SEG(  MID_WIDE,	    0,		  MID_WIDE,	BOX_HIGH),
	SEG(  MID_WIDE,	    MID_HIGH,	  BOX_WIDE,	MID_HIGH),
	-1
    }, right_tee[] =
    {
	SEG(  MID_WIDE,	    0,		  MID_WIDE,	BOX_HIGH),
	SEG(  MID_WIDE,	    MID_HIGH,	  0,		MID_HIGH),
	-1
    }, bottom_tee[] =
    {
	SEG(  0,	    MID_HIGH,	  BOX_WIDE,	MID_HIGH),
	SEG(  MID_WIDE,	    0,		  MID_WIDE,	MID_HIGH),
	-1
    }, top_tee[] =
    {
	SEG(  0,	    MID_HIGH,	  BOX_WIDE,	MID_HIGH),
	SEG(  MID_WIDE,	    MID_HIGH,	  MID_WIDE,	BOX_HIGH),
	-1
    }, vertical_line[] =
    {
	SEG(  MID_WIDE,	    0,		  MID_WIDE,	BOX_HIGH),
	-1
    }, less_than_or_equal[] =
    {
	SEG(  CHR_WIDE,	    BOX_HIGH/3,	  0,		MID_HIGH),
	SEG(  CHR_WIDE,	  2*BOX_HIGH/3,	  0,		MID_HIGH),
	SEG(  0,	  3*BOX_HIGH/4,	  CHR_WIDE,   3*BOX_HIGH/4),
	-1
    }, greater_than_or_equal[] =
    {
	SEG(  0,	    BOX_HIGH/3,	  CHR_WIDE,	MID_HIGH),
	SEG(  0,	  2*BOX_HIGH/3,	  CHR_WIDE,	MID_HIGH),
	SEG(  0,	  3*BOX_HIGH/4,	  CHR_WIDE,   3*BOX_HIGH/4),
	-1
    }, greek_pi[] =
    {
	SEG(  0,	    MID_HIGH,	  CHR_WIDE,	MID_HIGH),
	SEG(5*CHR_WIDE/6,   MID_HIGH,	5*CHR_WIDE/6,	CHR_HIGH),
	SEG(2*CHR_WIDE/6,   MID_HIGH,	2*CHR_WIDE/6,	CHR_HIGH),
	-1
    }, not_equal_to[] =
    {
	SEG(2*BOX_WIDE/3, 1*BOX_HIGH/3, 1*BOX_WIDE/3,	CHR_HIGH),
	SEG(  0,	  2*BOX_HIGH/3,	  CHR_WIDE,   2*BOX_HIGH/3),
	SEG(  0,	    MID_HIGH,	  CHR_WIDE,	MID_HIGH),
	-1
    };
    /* *INDENT-ON* */

    static const short *lines[] =
    {
	0,			/* 00 (unused) */
	0,			/* 01 diamond */
	0,			/* 02 box */
	glyph_ht,		/* 03 HT */
	glyph_ff,		/* 04 FF */
	0,			/* 05 CR */
	glyph_lf,		/* 06 LF */
	0,			/* 07 degrees (small circle) */
	plus_or_minus,		/* 08 */
	glyph_nl,		/* 09 */
	glyph_vt,		/* 0A */
	lower_right_corner,	/* 0B */
	upper_right_corner,	/* 0C */
	upper_left_corner,	/* 0D */
	lower_left_corner,	/* 0E */
	cross,			/* 0F */
	scan_line_1,		/* 10 */
	scan_line_3,		/* 11 */
	scan_line_7,		/* 12 */
	scan_line_9,		/* 13 */
	horizontal_line,	/* 14 */
	left_tee,		/* 15 */
	right_tee,		/* 16 */
	bottom_tee,		/* 17 */
	top_tee,		/* 18 */
	vertical_line,		/* 19 */
	less_than_or_equal,	/* 1A */
	greater_than_or_equal,	/* 1B */
	greek_pi,		/* 1C */
	not_equal_to,		/* 1D */
	0,			/* 1E LB */
	0,			/* 1F bullet */
    };

    GC gc2;
    CgsEnum cgsId = (ch == 2) ? gcDots : gcLine;
    VTwin *cgsWin = WhichVWin(screen);
    const short *p;
    unsigned font_width = (unsigned) (((draw_flags & DOUBLEWFONT) ? 2 : 1)
				      * screen->fnt_wide);
    unsigned font_height = (unsigned) (((draw_flags & DOUBLEHFONT) ? 2 : 1)
				       * screen->fnt_high);

    if (cells > 1)
	font_width *= (unsigned) cells;

#if OPT_WIDE_CHARS
    /*
     * Try to show line-drawing characters if we happen to be in UTF-8
     * mode, but have gotten an old-style font.
     */
    if (screen->utf8_mode
#if OPT_RENDERFONT
	&& !UsingRenderFont(xw)
#endif
	&& (ch > 127)
	&& (ch != UCS_REPL)) {
	unsigned n;
	for (n = 1; n < 32; n++) {
	    if (dec2ucs(n) == ch
		&& !((attr_flags & BOLD)
		     ? IsXtermMissingChar(screen, n, getNormalFont(screen, fBold))
		     : IsXtermMissingChar(screen, n, getNormalFont(screen, fNorm)))) {
		TRACE(("...use xterm-style linedrawing\n"));
		ch = n;
		break;
	    }
	}
    }
#endif

    TRACE(("DRAW_BOX(%d) cell %dx%d at %d,%d%s\n",
	   ch, font_height, font_width, y, x,
	   (ch >= (sizeof(lines) / sizeof(lines[0]))
	    ? "-BAD"
	    : "")));

    if (cgsId == gcDots) {
	setCgsFont(xw, cgsWin, cgsId, getCgsFont(xw, cgsWin, gc));
	setCgsFore(xw, cgsWin, cgsId, getCgsFore(xw, cgsWin, gc));
	setCgsBack(xw, cgsWin, cgsId, getCgsBack(xw, cgsWin, gc));
    } else {
	setCgsFont(xw, cgsWin, cgsId, getCgsFont(xw, cgsWin, gc));
	setCgsFore(xw, cgsWin, cgsId, getCgsBack(xw, cgsWin, gc));
	setCgsBack(xw, cgsWin, cgsId, getCgsBack(xw, cgsWin, gc));
    }
    gc2 = getCgsGC(xw, cgsWin, cgsId);

    if (!(draw_flags & NOBACKGROUND)) {
	XFillRectangle(screen->display, VDrawable(screen), gc2, x, y,
		       font_width,
		       font_height);
    }

    setCgsFont(xw, cgsWin, cgsId, getCgsFont(xw, cgsWin, gc));
    setCgsFore(xw, cgsWin, cgsId, getCgsFore(xw, cgsWin, gc));
    setCgsBack(xw, cgsWin, cgsId, getCgsBack(xw, cgsWin, gc));
    gc2 = getCgsGC(xw, cgsWin, cgsId);

    XSetLineAttributes(screen->display, gc2,
		       (attr_flags & BOLD)
		       ? ((font_height > 12)
			  ? font_height / 12
			  : 1)
		       : ((font_height > 16)
			  ? font_height / 16
			  : 1),
		       LineSolid,
		       CapProjecting,
		       JoinMiter);

    if (ch == 1) {		/* diamond */
	XPoint points[5];
	int npoints = 5, n;

	points[0].x = MID_WIDE;
	points[0].y = BOX_HIGH / 4;

	points[1].x = 8 * BOX_WIDE / 8;
	points[1].y = MID_HIGH;

	points[2].x = points[0].x;
	points[2].y = 3 * BOX_HIGH / 4;

	points[3].x = 0 * BOX_WIDE / 8;
	points[3].y = points[1].y;

	points[4].x = points[0].x;
	points[4].y = points[0].y;

	for (n = 0; n < npoints; ++n) {
	    points[n].x = (short) SCALED_X(points[n].x);
	    points[n].y = (short) SCALED_Y(points[n].y);
	    points[n].x = (short) (points[n].x + x);
	    points[n].y = (short) (points[n].y + y);
	}

	XFillPolygon(screen->display,
		     VDrawable(screen), gc2,
		     points, npoints,
		     Convex, CoordModeOrigin);
    } else if (ch == 7) {	/* degrees */
	unsigned width = (BOX_WIDE / 3);
	int x_coord = MID_WIDE - (int) (width / 2);
	int y_coord = MID_HIGH - (int) width;

	SCALE_X(x_coord);
	SCALE_Y(y_coord);
	width = (unsigned) SCALED_X(width);

	XDrawArc(screen->display,
		 VDrawable(screen), gc2,
		 x + x_coord, y + y_coord, width, width,
		 0,
		 360 * 64);
    } else if (ch == 0x1f) {	/* bullet */
	unsigned width = 7 * BOX_WIDE / 10;
	int x_coord = MID_WIDE - (int) (width / 3);
	int y_coord = MID_HIGH - (int) (width / 3);

	SCALE_X(x_coord);
	SCALE_Y(y_coord);
	width = (unsigned) SCALED_X(width);

	XDrawArc(screen->display,
		 VDrawable(screen), gc2,
		 x + x_coord, y + y_coord, width, width,
		 0,
		 360 * 64);
    } else if (ch < (sizeof(lines) / sizeof(lines[0]))
	       && (p = lines[ch]) != 0) {
	int coord[4];
	int n = 0;
	while (*p >= 0) {
	    coord[n++] = *p++;
	    if (n == 4) {
		SCALE_X(coord[0]);
		SCALE_Y(coord[1]);
		SCALE_X(coord[2]);
		SCALE_Y(coord[3]);
		XDrawLine(screen->display,
			  VDrawable(screen), gc2,
			  x + coord[0], y + coord[1],
			  x + coord[2], y + coord[3]);
		n = 0;
	    }
	}
    } else if (screen->force_all_chars) {
	/* bounding rectangle, for debugging */
	XDrawRectangle(screen->display, VDrawable(screen), gc2, x, y,
		       font_width - 1,
		       font_height - 1);
    }
}
#endif /* OPT_BOX_CHARS */

#if OPT_RENDERFONT

/*
 * Check if the given character has a glyph known to Xft.
 *
 * see xc/lib/Xft/xftglyphs.c
 */
Bool
xtermXftMissing(XtermWidget xw, XftFont *font, unsigned wc)
{
    Bool result = False;

    if (font != 0) {
	TScreen *screen = TScreenOf(xw);
	if (!XftGlyphExists(screen->display, font, wc)) {
#if OPT_WIDE_CHARS
	    TRACE2(("xtermXftMissing %d (dec=%#x, ucs=%#x)\n",
		    wc, ucs2dec(wc), dec2ucs(wc)));
#else
	    TRACE2(("xtermXftMissing %d\n", wc));
#endif
	    result = True;
	}
    }
    return result;
}
#endif /* OPT_RENDERFONT */

#if OPT_WIDE_CHARS
#define MY_UCS(ucs,dec) case ucs: result = dec; break
unsigned
ucs2dec(unsigned ch)
{
    unsigned result = ch;
    if ((ch > 127)
	&& (ch != UCS_REPL)) {
	switch (ch) {
	    MY_UCS(0x25ae, 0);	/* black vertical rectangle                   */
	    MY_UCS(0x25c6, 1);	/* black diamond                              */
	    MY_UCS(0x2592, 2);	/* medium shade                               */
	    MY_UCS(0x2409, 3);	/* symbol for horizontal tabulation           */
	    MY_UCS(0x240c, 4);	/* symbol for form feed                       */
	    MY_UCS(0x240d, 5);	/* symbol for carriage return                 */
	    MY_UCS(0x240a, 6);	/* symbol for line feed                       */
	    MY_UCS(0x00b0, 7);	/* degree sign                                */
	    MY_UCS(0x00b1, 8);	/* plus-minus sign                            */
	    MY_UCS(0x2424, 9);	/* symbol for newline                         */
	    MY_UCS(0x240b, 10);	/* symbol for vertical tabulation             */
	    MY_UCS(0x2518, 11);	/* box drawings light up and left             */
	    MY_UCS(0x2510, 12);	/* box drawings light down and left           */
	    MY_UCS(0x250c, 13);	/* box drawings light down and right          */
	    MY_UCS(0x2514, 14);	/* box drawings light up and right            */
	    MY_UCS(0x253c, 15);	/* box drawings light vertical and horizontal */
	    MY_UCS(0x23ba, 16);	/* box drawings scan 1                        */
	    MY_UCS(0x23bb, 17);	/* box drawings scan 3                        */
	    MY_UCS(0x2500, 18);	/* box drawings light horizontal              */
	    MY_UCS(0x23bc, 19);	/* box drawings scan 7                        */
	    MY_UCS(0x23bd, 20);	/* box drawings scan 9                        */
	    MY_UCS(0x251c, 21);	/* box drawings light vertical and right      */
	    MY_UCS(0x2524, 22);	/* box drawings light vertical and left       */
	    MY_UCS(0x2534, 23);	/* box drawings light up and horizontal       */
	    MY_UCS(0x252c, 24);	/* box drawings light down and horizontal     */
	    MY_UCS(0x2502, 25);	/* box drawings light vertical                */
	    MY_UCS(0x2264, 26);	/* less-than or equal to                      */
	    MY_UCS(0x2265, 27);	/* greater-than or equal to                   */
	    MY_UCS(0x03c0, 28);	/* greek small letter pi                      */
	    MY_UCS(0x2260, 29);	/* not equal to                               */
	    MY_UCS(0x00a3, 30);	/* pound sign                                 */
	    MY_UCS(0x00b7, 31);	/* middle dot                                 */
	}
    }
    return result;
}

#undef  MY_UCS
#define MY_UCS(ucs,dec) case dec: result = ucs; break

unsigned
dec2ucs(unsigned ch)
{
    unsigned result = ch;
    if (xtermIsDecGraphic(ch)) {
	switch (ch) {
	    MY_UCS(0x25ae, 0);	/* black vertical rectangle                   */
	    MY_UCS(0x25c6, 1);	/* black diamond                              */
	    MY_UCS(0x2592, 2);	/* medium shade                               */
	    MY_UCS(0x2409, 3);	/* symbol for horizontal tabulation           */
	    MY_UCS(0x240c, 4);	/* symbol for form feed                       */
	    MY_UCS(0x240d, 5);	/* symbol for carriage return                 */
	    MY_UCS(0x240a, 6);	/* symbol for line feed                       */
	    MY_UCS(0x00b0, 7);	/* degree sign                                */
	    MY_UCS(0x00b1, 8);	/* plus-minus sign                            */
	    MY_UCS(0x2424, 9);	/* symbol for newline                         */
	    MY_UCS(0x240b, 10);	/* symbol for vertical tabulation             */
	    MY_UCS(0x2518, 11);	/* box drawings light up and left             */
	    MY_UCS(0x2510, 12);	/* box drawings light down and left           */
	    MY_UCS(0x250c, 13);	/* box drawings light down and right          */
	    MY_UCS(0x2514, 14);	/* box drawings light up and right            */
	    MY_UCS(0x253c, 15);	/* box drawings light vertical and horizontal */
	    MY_UCS(0x23ba, 16);	/* box drawings scan 1                        */
	    MY_UCS(0x23bb, 17);	/* box drawings scan 3                        */
	    MY_UCS(0x2500, 18);	/* box drawings light horizontal              */
	    MY_UCS(0x23bc, 19);	/* box drawings scan 7                        */
	    MY_UCS(0x23bd, 20);	/* box drawings scan 9                        */
	    MY_UCS(0x251c, 21);	/* box drawings light vertical and right      */
	    MY_UCS(0x2524, 22);	/* box drawings light vertical and left       */
	    MY_UCS(0x2534, 23);	/* box drawings light up and horizontal       */
	    MY_UCS(0x252c, 24);	/* box drawings light down and horizontal     */
	    MY_UCS(0x2502, 25);	/* box drawings light vertical                */
	    MY_UCS(0x2264, 26);	/* less-than or equal to                      */
	    MY_UCS(0x2265, 27);	/* greater-than or equal to                   */
	    MY_UCS(0x03c0, 28);	/* greek small letter pi                      */
	    MY_UCS(0x2260, 29);	/* not equal to                               */
	    MY_UCS(0x00a3, 30);	/* pound sign                                 */
	    MY_UCS(0x00b7, 31);	/* middle dot                                 */
	}
    }
    return result;
}

#endif /* OPT_WIDE_CHARS */

#if OPT_RENDERFONT || OPT_SHIFT_FONTS
static int
lookupOneFontSize(XtermWidget xw, int fontnum)
{
    TScreen *screen = TScreenOf(xw);

    if (screen->menu_font_sizes[fontnum] == 0) {
	XTermFonts fnt;

	memset(&fnt, 0, sizeof(fnt));
	screen->menu_font_sizes[fontnum] = -1;
	if (xtermOpenFont(xw, screen->MenuFontName(fontnum), &fnt, True)) {
	    if (fontnum <= fontMenu_lastBuiltin
		|| strcmp(fnt.fn, DEFFONT)) {
		screen->menu_font_sizes[fontnum] = FontSize(fnt.fs);
		if (screen->menu_font_sizes[fontnum] <= 0)
		    screen->menu_font_sizes[fontnum] = -1;
	    }
	    xtermCloseFont(xw, &fnt);
	}
    }
    return (screen->menu_font_sizes[fontnum] > 0);
}

/*
 * Cache the font-sizes so subsequent larger/smaller font actions will go fast.
 */
static void
lookupFontSizes(XtermWidget xw)
{
    int n;

    for (n = 0; n < NMENUFONTS; n++) {
	(void) lookupOneFontSize(xw, n);
    }
}
#endif /* OPT_RENDERFONT || OPT_SHIFT_FONTS */

#if OPT_RENDERFONT
static double
defaultFaceSize(void)
{
    double result;
    float value;

    if (sscanf(DEFFACESIZE, "%f", &value) == 1)
	result = value;
    else
	result = 14.0;
    return result;
}

static void
fillInFaceSize(XtermWidget xw, int fontnum)
{
    TScreen *screen = TScreenOf(xw);
    double face_size = xw->misc.face_size[fontnum];

    if (face_size <= 0.0) {
#if OPT_SHIFT_FONTS
	/*
	 * If the user is switching font-sizes, make it follow by
	 * default the same ratios to the default as the fixed fonts
	 * would, for easy comparison.  There will be some differences
	 * since the fixed fonts have a variety of height/width ratios,
	 * but this is simpler than adding another resource value - and
	 * as noted above, the data for the fixed fonts are available.
	 */
	(void) lookupOneFontSize(xw, 0);
	if (fontnum == fontMenu_default) {
	    face_size = defaultFaceSize();
	} else if (lookupOneFontSize(xw, fontnum)
		   && (screen->menu_font_sizes[0]
		       != screen->menu_font_sizes[fontnum])) {
	    double ratio;
	    long num = screen->menu_font_sizes[fontnum];
	    long den = screen->menu_font_sizes[0];

	    if (den <= 0)
		den = 1;
	    ratio = dimSquareRoot((double) num / (double) den);

	    face_size = (ratio * xw->misc.face_size[0]);
	    TRACE(("scaled[%d] using %3ld/%ld = %.2f -> %f\n",
		   fontnum, num, den, ratio, face_size));
	} else
#endif
	{
#define LikeBitmap(s) (((s) / 78.0) * xw->misc.face_size[fontMenu_default])
	    switch (fontnum) {
	    case fontMenu_font1:
		face_size = LikeBitmap(2.0);
		break;
	    case fontMenu_font2:
		face_size = LikeBitmap(35.0);
		break;
	    case fontMenu_font3:
		face_size = LikeBitmap(60.0);
		break;
	    default:
		face_size = defaultFaceSize();
		break;
	    case fontMenu_font4:
		face_size = LikeBitmap(90.0);
		break;
	    case fontMenu_font5:
		face_size = LikeBitmap(135.0);
		break;
	    case fontMenu_font6:
		face_size = LikeBitmap(200.0);
		break;
	    }
	    TRACE(("builtin[%d] -> %f\n", fontnum, face_size));
	}
	xw->misc.face_size[fontnum] = (float) face_size;
    }
}

/* no selection or escape */
#define NMENU_RENDERFONTS (fontMenu_lastBuiltin + 1)

/*
 * Workaround for breakage in font-packages - check if all of the bitmap font
 * sizes are the same, and if we're using TrueType fonts.
 */
static Boolean
useFaceSizes(XtermWidget xw)
{
    Boolean result = False;

    TRACE(("useFaceSizes {{\n"));
    if (UsingRenderFont(xw)) {
	Boolean nonzero = True;
	int n;

	for (n = 0; n < NMENU_RENDERFONTS; ++n) {
	    if (xw->misc.face_size[n] <= 0.0) {
		nonzero = False;
		break;
	    }
	}
	if (!nonzero) {
	    Boolean broken_fonts = True;
	    TScreen *screen = TScreenOf(xw);
	    long first;

	    lookupFontSizes(xw);
	    first = screen->menu_font_sizes[0];
	    for (n = 0; n < NMENUFONTS; n++) {
		if (screen->menu_font_sizes[n] > 0
		    && screen->menu_font_sizes[n] != first) {
		    broken_fonts = False;
		    break;
		}
	    }

	    if (broken_fonts) {

		TRACE(("bitmap fonts are broken - set faceSize resources\n"));
		for (n = 0; n < NMENUFONTS; n++) {
		    fillInFaceSize(xw, n);
		}

	    }
	}
	result = True;
    }
    TRACE(("...}}useFaceSizes %d\n", result));
    return result;
}
#endif /* OPT_RENDERFONT */

#if OPT_SHIFT_FONTS
/*
 * Find the index of a larger/smaller font (according to the sign of 'relative'
 * and its magnitude), starting from the 'old' index.
 */
int
lookupRelativeFontSize(XtermWidget xw, int old, int relative)
{
    TScreen *screen = TScreenOf(xw);
    int m = -1;

    TRACE(("lookupRelativeFontSize(old=%d, relative=%d)\n", old, relative));
    if (!IsIcon(screen)) {
#if OPT_RENDERFONT
	if (useFaceSizes(xw)) {
	    TRACE(("...using FaceSize\n"));
	    if (relative != 0) {
		int n;
		for (n = 0; n < NMENU_RENDERFONTS; ++n) {
		    fillInFaceSize(xw, n);
		    if (xw->misc.face_size[n] > 0 &&
			xw->misc.face_size[n] != xw->misc.face_size[old]) {
			int cmp_0 = ((xw->misc.face_size[n] >
				      xw->misc.face_size[old])
				     ? relative
				     : -relative);
			int cmp_m = ((m < 0)
				     ? 1
				     : ((xw->misc.face_size[n] <
					 xw->misc.face_size[m])
					? relative
					: -relative));
			if (cmp_0 > 0 && cmp_m > 0) {
			    m = n;
			}
		    }
		}
	    }
	} else
#endif
	{
	    TRACE(("...using bitmap areas\n"));
	    lookupFontSizes(xw);
	    if (relative != 0) {
		int n;
		for (n = 0; n < NMENUFONTS; ++n) {
		    if (screen->menu_font_sizes[n] > 0 &&
			screen->menu_font_sizes[n] !=
			screen->menu_font_sizes[old]) {
			int cmp_0 = ((screen->menu_font_sizes[n] >
				      screen->menu_font_sizes[old])
				     ? relative
				     : -relative);
			int cmp_m = ((m < 0)
				     ? 1
				     : ((screen->menu_font_sizes[n] <
					 screen->menu_font_sizes[m])
					? relative
					: -relative));
			if (cmp_0 > 0 && cmp_m > 0) {
			    m = n;
			}
		    }
		}
	    }
	}
	TRACE(("...new index %d\n", m));
	if (m >= 0) {
	    if (relative > 1)
		m = lookupRelativeFontSize(xw, m, relative - 1);
	    else if (relative < -1)
		m = lookupRelativeFontSize(xw, m, relative + 1);
	}
    }
    return m;
}

/* ARGSUSED */
void
HandleLargerFont(Widget w GCC_UNUSED,
		 XEvent *event GCC_UNUSED,
		 String *params GCC_UNUSED,
		 Cardinal *param_count GCC_UNUSED)
{
    XtermWidget xw;

    TRACE(("Handle larger-vt-font for %p\n", (void *) w));
    if ((xw = getXtermWidget(w)) != 0) {
	if (xw->misc.shift_fonts) {
	    TScreen *screen = TScreenOf(xw);
	    int m;

	    m = lookupRelativeFontSize(xw, screen->menu_font_number, 1);
	    if (m >= 0) {
		SetVTFont(xw, m, True, NULL);
	    } else {
		Bell(xw, XkbBI_MinorError, 0);
	    }
	}
    }
}

/* ARGSUSED */
void
HandleSmallerFont(Widget w GCC_UNUSED,
		  XEvent *event GCC_UNUSED,
		  String *params GCC_UNUSED,
		  Cardinal *param_count GCC_UNUSED)
{
    XtermWidget xw;

    TRACE(("Handle smaller-vt-font for %p\n", (void *) w));
    if ((xw = getXtermWidget(w)) != 0) {
	if (xw->misc.shift_fonts) {
	    TScreen *screen = TScreenOf(xw);
	    int m;

	    m = lookupRelativeFontSize(xw, screen->menu_font_number, -1);
	    if (m >= 0) {
		SetVTFont(xw, m, True, NULL);
	    } else {
		Bell(xw, XkbBI_MinorError, 0);
	    }
	}
    }
}
#endif /* OPT_SHIFT_FONTS */

int
xtermGetFont(const char *param)
{
    int fontnum;

    switch (param[0]) {
    case 'd':
    case 'D':
    case '0':
	fontnum = fontMenu_default;
	break;
    case '1':
	fontnum = fontMenu_font1;
	break;
    case '2':
	fontnum = fontMenu_font2;
	break;
    case '3':
	fontnum = fontMenu_font3;
	break;
    case '4':
	fontnum = fontMenu_font4;
	break;
    case '5':
	fontnum = fontMenu_font5;
	break;
    case '6':
	fontnum = fontMenu_font6;
	break;
    case 'e':
    case 'E':
	fontnum = fontMenu_fontescape;
	break;
    case 's':
    case 'S':
	fontnum = fontMenu_fontsel;
	break;
    default:
	fontnum = -1;
	break;
    }
    return fontnum;
}

/* ARGSUSED */
void
HandleSetFont(Widget w GCC_UNUSED,
	      XEvent *event GCC_UNUSED,
	      String *params,
	      Cardinal *param_count)
{
    XtermWidget xw;

    if ((xw = getXtermWidget(w)) != 0) {
	int fontnum;
	VTFontNames fonts;

	memset(&fonts, 0, sizeof(fonts));

	if (*param_count == 0) {
	    fontnum = fontMenu_default;
	} else {
	    Cardinal maxparams = 1;	/* total number of params allowed */
	    int result = xtermGetFont(params[0]);

	    switch (result) {
	    case fontMenu_default:	/* FALLTHRU */
	    case fontMenu_font1:	/* FALLTHRU */
	    case fontMenu_font2:	/* FALLTHRU */
	    case fontMenu_font3:	/* FALLTHRU */
	    case fontMenu_font4:	/* FALLTHRU */
	    case fontMenu_font5:	/* FALLTHRU */
	    case fontMenu_font6:	/* FALLTHRU */
		break;
	    case fontMenu_fontescape:
#if OPT_WIDE_CHARS
		maxparams = 5;
#else
		maxparams = 3;
#endif
		break;
	    case fontMenu_fontsel:
		maxparams = 2;
		break;
	    default:
		Bell(xw, XkbBI_MinorError, 0);
		return;
	    }
	    fontnum = result;

	    if (*param_count > maxparams) {	/* see if extra args given */
		Bell(xw, XkbBI_MinorError, 0);
		return;
	    }
	    switch (*param_count) {	/* assign 'em */
#if OPT_WIDE_CHARS
	    case 5:
		fonts.f_wb = x_strdup(params[4]);
		/* FALLTHRU */
	    case 4:
		fonts.f_w = x_strdup(params[3]);
#endif
		/* FALLTHRU */
	    case 3:
		fonts.f_b = x_strdup(params[2]);
		/* FALLTHRU */
	    case 2:
		fonts.f_n = x_strdup(params[1]);
		break;
	    }
	}

	SetVTFont(xw, fontnum, True, &fonts);
    }
}

void
SetVTFont(XtermWidget xw,
	  int which,
	  Bool doresize,
	  const VTFontNames * fonts)
{
    TScreen *screen = TScreenOf(xw);

    TRACE(("SetVTFont(which=%d, f_n=%s, f_b=%s)\n", which,
	   (fonts && fonts->f_n) ? fonts->f_n : "<null>",
	   (fonts && fonts->f_b) ? fonts->f_b : "<null>"));

    if (IsIcon(screen)) {
	Bell(xw, XkbBI_MinorError, 0);
    } else if (which >= 0 && which < NMENUFONTS) {
	VTFontNames myfonts;

	memset(&myfonts, 0, sizeof(myfonts));
	if (fonts != 0)
	    myfonts = *fonts;

	if (which == fontMenu_fontsel) {	/* go get the selection */
	    FindFontSelection(xw, myfonts.f_n, False);
	} else {
	    int oldFont = screen->menu_font_number;

#define USE_CACHED(field, name) \
	    if (myfonts.field == 0) { \
		myfonts.field = x_strdup(screen->menu_font_names[which][name]); \
		TRACE(("set myfonts." #field " from menu_font_names[%d][" #name "] %s\n", \
		       which, NonNull(myfonts.field))); \
	    } else { \
		TRACE(("set myfonts." #field " reused\n")); \
	    }
#define SAVE_FNAME(field, name) \
	    if (myfonts.field != 0) { \
		if (screen->menu_font_names[which][name] == 0 \
		 || strcmp(screen->menu_font_names[which][name], myfonts.field)) { \
		    TRACE(("updating menu_font_names[%d][" #name "] to %s\n", \
			   which, myfonts.field)); \
		    FREE_STRING(screen->menu_font_names[which][name]); \
		    screen->menu_font_names[which][name] = x_strdup(myfonts.field); \
		} \
	    }

	    USE_CACHED(f_n, fNorm);
	    USE_CACHED(f_b, fBold);
#if OPT_WIDE_CHARS
	    USE_CACHED(f_w, fWide);
	    USE_CACHED(f_wb, fWBold);
#endif
	    if (xtermLoadFont(xw,
			      &myfonts,
			      doresize, which)) {
		/*
		 * If successful, save the data so that a subsequent query via
		 * OSC-50 will return the expected values.
		 */
		SAVE_FNAME(f_n, fNorm);
		SAVE_FNAME(f_b, fBold);
#if OPT_WIDE_CHARS
		SAVE_FNAME(f_w, fWide);
		SAVE_FNAME(f_wb, fWBold);
#endif
	    } else {
		(void) xtermLoadFont(xw,
				     xtermFontName(screen->MenuFontName(oldFont)),
				     doresize, oldFont);
		Bell(xw, XkbBI_MinorError, 0);
	    }
	    FREE_FNAME(f_n);
	    FREE_FNAME(f_b);
#if OPT_WIDE_CHARS
	    FREE_FNAME(f_w);
	    FREE_FNAME(f_wb);
#endif
	}
    } else {
	Bell(xw, XkbBI_MinorError, 0);
    }
    return;
}

#if OPT_RENDERFONT
static void
trimSizeFromFace(char *face_name, float *face_size)
{
    char *first = strstr(face_name, ":size=");
    if (first == 0) {
	first = face_name;
    } else {
	first++;
    }
    if (!strncmp(first, "size=", (size_t) 5)) {
	char *last = strchr(first, ':');
	char mark;
	float value;
	char extra;
	TRACE(("...before trimming, font = \"%s\"\n", face_name));
	if (last == 0)
	    last = first + strlen(first);
	mark = *last;
	*last = '\0';
	if (sscanf(first, "size=%g%c", &value, &extra) == 1) {
	    TRACE(("...trimmed size from font: %g\n", value));
	    if (face_size != 0)
		*face_size = value;
	}
	if (mark) {
	    while ((*first++ = *++last) != '\0') {
		;
	    }
	} else {
	    if (first != face_name)
		--first;
	    *first = '\0';
	}
	TRACE(("...after trimming, font = \"%s\"\n", face_name));
    }
}
#endif

/*
 * Save a font specification to the proper list.
 */
static void
save2FontList(XtermWidget xw,
	      const char *name,
	      XtermFontNames * fontnames,
	      VTFontEnum which,
	      const char *source,
	      Bool ttf)
{
    char *value;
    size_t plen;
    Bool marked = False;
    Bool use_ttf = ttf;

    (void) xw;

    if (source == 0)
	source = "";
    while (isspace(CharOf(*source)))
	++source;

    /* fontconfig patterns can contain ':' separators, but we'll treat
     * a leading prefix specially to denote whether the pattern might be
     * XLFD ("x" or "xlfd") versus Xft ("xft").
     */
    for (plen = 0; source[plen] != '\0'; ++plen) {
	if (source[plen] == ':') {
	    marked = True;
	    switch (plen) {
	    case 0:
		++plen;		/* trim leading ':' */
		break;
	    case 1:
		if (!strncmp(source, "x", plen)) {
		    ++plen;
		    use_ttf = False;
		} else {
		    marked = False;
		}
		break;
	    case 3:
		if (!strncmp(source, "xft", plen)) {
		    ++plen;
		    use_ttf = True;
		} else {
		    marked = False;
		}
		break;
	    case 4:
		if (!strncmp(source, "xlfd", plen)) {
		    ++plen;
		    use_ttf = False;
		} else {
		    marked = False;
		}
		break;
	    default:
		marked = False;
		plen = 0;
		break;
	    }
	    break;
	}
    }
    if (!marked)
	plen = 0;
    value = x_strtrim(source + plen);
    if (value != 0) {
	Bool success = False;
#if OPT_RENDERFONT
	VTFontList *target = (use_ttf
			      ? &(fontnames->xft)
			      : &(fontnames->x11));
#else
	VTFontList *target = &(fontnames->x11);
#endif
	char ***list = 0;
	char **next = 0;
	size_t count = 0;

	(void) use_ttf;
	switch (which) {
	case fNorm:
	    list = &(target->list_n);
	    break;
	case fBold:
	    list = &(target->list_b);
	    break;
#if OPT_WIDE_ATTRS || OPT_RENDERWIDE
	case fItal:
	    list = &(target->list_i);
	    break;
#endif
#if OPT_WIDE_CHARS
	case fWide:
	    list = &(target->list_w);
	    break;
	case fWBold:
	    list = &(target->list_wb);
	    break;
	case fWItal:
	    list = &(target->list_wi);
	    break;
#endif
	case fMAX:
	    list = 0;
	    break;
	}

	if (list != 0) {
	    success = True;
	    if (*list != 0) {
		while ((*list)[count] != 0) {
		    if (IsEmpty((*list)[count])) {
			TRACE(("... initial %s\n", value));
			free((*list)[count]);
			break;
		    } else if (!strcmp(value, (*list)[count])) {
			TRACE(("... duplicate %s\n", value));
			success = False;
			break;
		    }
		    ++count;
		}
	    }
	    if (success) {
		next = realloc(*list, sizeof(char *) * (count + 2));
		if (next != 0) {
#if OPT_RENDERFONT
		    if (use_ttf) {
			trimSizeFromFace(value,
					 (count == 0 && which == fNorm)
					 ? &(xw->misc.face_size[0])
					 : (float *) 0);
		    }
#endif
		    next[count++] = value;
		    next[count] = 0;
		    *list = next;
		    TRACE(("... saved %s %s %lu:%s\n",
			   whichFontList(xw, target),
			   whichFontList2(xw, *list),
			   (unsigned long) count,
			   value));
		} else {
		    fprintf(stderr,
			    "realloc failure in save2FontList(%s)\n",
			    name);
		    freeFontList(list);
		    success = False;
		}
	    }
	}
	if (success) {
	    size_t limit = use_ttf ? MAX_XFT_FONTS : MAX_XLFD_FONTS;
	    if (count > limit && !IsEmpty(value)) {
		fprintf(stderr, "%s: too many fonts for %s, ignoring %s\n",
			ProgramName,
			whichFontEnum(which),
			value);
		if (list && *list) {
		    free((*list)[limit]);
		    (*list)[limit] = 0;
		}
	    }
	} else {
	    free(value);
	}
    }
}

/*
 * In principle, any of the font-name resources could be extended to be a list
 * of font-names.  That would be bad for performance, but as a basis for an
 * extension, parse the font-name as a comma-separated list, creating/updating
 * an array of font-names.
 */
void
allocFontList(XtermWidget xw,
	      const char *name,
	      XtermFontNames * target,
	      VTFontEnum which,
	      const char *source,
	      Bool ttf)
{
    char *blob;

    blob = x_strdup(source);
    if (!IsEmpty(blob)) {
	int n;
	int pass;
	char **list = 0;

	TRACE(("allocFontList %s %s '%s'\n", whichFontEnum(which), name, blob));

	for (pass = 0; pass < 2; ++pass) {
	    unsigned count = 0;
	    if (pass)
		list[0] = blob;
	    for (n = 0; blob[n] != '\0'; ++n) {
		if (blob[n] == ',') {
		    ++count;
		    if (pass != 0) {
			blob[n] = '\0';
			list[count] = blob + n + 1;
		    }
		}
	    }
	    if (!pass) {
		if (count == 0 && *blob == '\0')
		    break;
		list = TypeCallocN(char *, count + 2);
		if (list == 0)
		    break;
	    }
	}
	if (list) {
	    for (n = 0; list[n] != 0; ++n) {
		if (*list[n]) {
		    save2FontList(xw, name, target, which, list[n], ttf);
		}
	    }
	    free(list);
	}
    }
    free(blob);
}

static void
initFontList(XtermWidget xw,
	     const char *name,
	     XtermFontNames * target,
	     Bool ttf)
{
    int which;

    TRACE(("initFontList(%s)\n", name));
    for (which = 0; which < fMAX; ++which) {
	save2FontList(xw, name, target, (VTFontEnum) which, "", ttf);
    }
}

void
initFontLists(XtermWidget xw)
{
    TRACE(("initFontLists\n"));
    initFontList(xw, "x11 font", &(xw->work.fonts), False);
#if OPT_RENDERFONT
    initFontList(xw, "xft font", &(xw->work.fonts), True);
#endif
#if OPT_LOAD_VTFONTS || OPT_WIDE_CHARS
    initFontList(xw, "cached font",
		 &(xw->screen.cacheVTFonts.fonts), False);
#endif
}

void
copyFontList(char ***targetp, char **source)
{
    freeFontList(targetp);

    if (source != 0) {
	int pass;
	size_t count;

	for (pass = 0; pass < 2; ++pass) {
	    for (count = 0; source[count] != 0; ++count) {
		if (pass)
		    (*targetp)[count] = x_strdup(source[count]);
	    }
	    if (!pass) {
		++count;
		*targetp = TypeCallocN(char *, count);
	    }
	}
    } else {
	*targetp = TypeCallocN(char *, 2);
	(*targetp)[0] = x_strdup("");
    }
}

#if OPT_LOAD_VTFONTS || OPT_WIDE_CHARS
static Boolean
merge_sublist(char ***targetp, char **source)
{
    Boolean result = False;
    if ((*targetp == 0 || IsEmpty(**targetp)) && !IsEmpty(*source)) {
	copyFontList(targetp, source);
	result = True;
    }
    return result;
}
#endif

void
freeFontList(char ***targetp)
{
    if (targetp != 0) {
	char **target = *targetp;
	if (target != 0) {
	    int n;
	    for (n = 0; target[n] != 0; ++n) {
		free(target[n]);
	    }
	    free(target);
	    *targetp = 0;
	}
    }
}

void
freeFontLists(VTFontList * lists)
{
    int which;

    TRACE(("freeFontLists\n"));
    for (which = 0; which < fMAX; ++which) {
	char ***target = 0;
	switch (which) {
	case fNorm:
	    target = &(lists->list_n);
	    break;
	case fBold:
	    target = &(lists->list_b);
	    break;
#if OPT_WIDE_ATTRS || OPT_RENDERWIDE
	case fItal:
	    target = &(lists->list_i);
	    break;
#endif
#if OPT_WIDE_CHARS
	case fWide:
	    target = &(lists->list_w);
	    break;
	case fWBold:
	    target = &(lists->list_wb);
	    break;
	case fWItal:
	    target = &(lists->list_wi);
	    break;
#endif
	default:
	    target = 0;
	    break;
	}
	freeFontList(target);
    }
}

/*
 * Return a pointer to the XLFD font information for a given font class.
 * XXX make this allocate the font on demand.
 */
XTermFonts *
getNormalFont(TScreen *screen, int which)
{
    XTermFonts *result = 0;
    if (which >= 0 && which < fMAX)
	result = &(screen->fnts[which]);
    return result;
}

#if OPT_DEC_CHRSET
XTermFonts *
getDoubleFont(TScreen *screen, int which)
{
    XTermFonts *result = 0;
    if ((int) which >= 0 && which < NUM_CHRSET)
	result = &(screen->double_fonts[which]);
    return result;
}
#endif

#if OPT_WIDE_ATTRS || OPT_RENDERWIDE
XTermFonts *
getItalicFont(TScreen *screen, int which)
{
    XTermFonts *result = 0;
#if OPT_WIDE_ATTRS
    if (which >= 0 && which < fMAX)
	result = &(screen->ifnts[which]);
#else
    (void) screen;
    (void) which;
#endif
    return result;
}
#endif

#if OPT_RENDERFONT
/*
 * This returns a pointer to everything known about a given Xft font.
 * XXX make this allocate the font on demand.
 */
XTermXftFonts *
getMyXftFont(XtermWidget xw, int which, int fontnum)
{
    TScreen *screen = TScreenOf(xw);
    XTermXftFonts *result = 0;
    if (fontnum >= 0 && fontnum < NMENUFONTS) {
	switch ((VTFontEnum) which) {
	case fNorm:
	    result = &(screen->renderFontNorm[fontnum]);
	    break;
	case fBold:
	    result = &(screen->renderFontBold[fontnum]);
	    break;
#if OPT_WIDE_ATTRS || OPT_RENDERWIDE
	case fItal:
	    result = &(screen->renderFontItal[fontnum]);
	    break;
#endif
#if OPT_WIDE_CHARS
	case fWide:
	    result = &(screen->renderWideNorm[fontnum]);
	    break;
	case fWBold:
	    result = &(screen->renderWideBold[fontnum]);
	    break;
	case fWItal:
	    result = &(screen->renderWideItal[fontnum]);
	    break;
#endif
	case fMAX:
	    break;
	}
    }
    return result;
}

XftFont *
getXftFont(XtermWidget xw, VTFontEnum which, int fontnum)
{
    XTermXftFonts *data = getMyXftFont(xw, which, fontnum);
    XftFont *result = 0;
    if (data != 0)
	result = data->font;
    return result;
}
#endif

const char *
whichFontEnum(VTFontEnum value)
{
    const char *result = "?";
#define DATA(name) case name: result = #name; break
    switch (value) {
	DATA(fNorm);
	DATA(fBold);
#if OPT_WIDE_ATTRS || OPT_RENDERWIDE
	DATA(fItal);
#endif
#if OPT_WIDE_CHARS
	DATA(fWide);
	DATA(fWBold);
	DATA(fWItal);
#endif
	DATA(fMAX);
    }
#undef DATA
    return result;
}

const char *
whichFontList(XtermWidget xw, VTFontList * value)
{
    const char *result = "?";
    if (value == &(xw->work.fonts.x11))
	result = "x11_fontnames";
#if OPT_RENDERFONT
    else if (value == &(xw->work.fonts.xft))
	result = "xft_fontnames";
#endif
#if OPT_LOAD_VTFONTS || OPT_WIDE_CHARS
    else if (value == &(xw->screen.cacheVTFonts.fonts.x11))
	result = "cached_fontnames";
#endif
    return result;
}

static const char *
whichFontList2s(VTFontList * list, char **value)
{
    const char *result = 0;
#define DATA(name) if (value == (list->name)) result = #name
    DATA(list_n);
    DATA(list_b);
#if OPT_WIDE_ATTRS || OPT_RENDERWIDE
    DATA(list_i);
#endif
#if OPT_WIDE_CHARS
    DATA(list_w);
    DATA(list_wb);
    DATA(list_wi);
#endif
#undef DATA
    return result;
}

const char *
whichFontList2(XtermWidget xw, char **value)
{
    const char *result = 0;
#define DATA(name) (result = whichFontList2s(&(xw->name), value))
    if (DATA(work.fonts.x11) == 0) {
#if OPT_RENDERFONT
	if (DATA(work.fonts.xft) == 0)
#endif
#if OPT_LOAD_VTFONTS || OPT_WIDE_CHARS
	    if (DATA(screen.cacheVTFonts.fonts.x11) == 0)
#endif
		result = "?";
    }
#undef DATA
    return result;
}
@


1.30
log
@Update to xterm-325. Testing by krw@@, shadchin@@ and naddy@@. Thanks
@
text
@d1 1
a1 1
/* $XTermId: fontutils.c,v 1.453 2016/06/03 08:56:53 tom Exp $ */
d4 1
a4 1
 * Copyright 1998-2015,2016 by Thomas E. Dickey
d123 7
a187 1
#define MIXED(name) screen->name[fontnum].map.mixed
d189 1
a189 1
	int fontnum = screen->menu_font_number;
d191 9
a199 10
	screen->allow_packing = (Boolean) (MIXED(renderFontNorm)
					   || MIXED(renderFontBold)
					   || MIXED(renderFontItal)
#if OPT_RENDERWIDE
					   || MIXED(renderWideNorm)
					   || MIXED(renderWideBold)
					   || MIXED(renderWideItal)
#endif
	    );
#undef MIXED
d463 1
a463 1
italic_font_name(FontNameProperties *props, int use_average_width)
d466 49
a514 2
    myprops.slant = "o";
    return derive_font_name(&myprops, props->weight, use_average_width, props->end);
d544 1
a544 1
xtermSpecialFont(TScreen *screen, unsigned attr_flags, unsigned draw_flags, unsigned chrset)
d546 1
d558 2
a559 1
    props = get_font_name_props(screen->display, screen->fnts[fNorm].fs, 0);
d685 3
a687 1
    if (normal->all_chars_exist) {
d716 16
a731 11
    TRACE(("same_font_size height %d/%d, min %d/%d max %d/%d\n",
	   nfs->ascent + nfs->descent,
	   bfs->ascent + bfs->descent,
	   nfs->min_bounds.width, bfs->min_bounds.width,
	   nfs->max_bounds.width, bfs->max_bounds.width));
    return screen->free_bold_box
	|| ((nfs->ascent + nfs->descent) == (bfs->ascent + bfs->descent)
	    && (nfs->min_bounds.width == bfs->min_bounds.width
		|| nfs->min_bounds.width == bfs->min_bounds.width + 1)
	    && (nfs->max_bounds.width == bfs->max_bounds.width
		|| nfs->max_bounds.width == bfs->max_bounds.width + 1));
d839 16
a854 1
    data.f_n = x_strdup(normal);
d876 33
a916 1
	      fontWarningTypes warn,
d926 1
a926 1
		(void) xtermCloseFont(xw, result);
d932 1
a932 1
	    if (warn <= xw->misc.fontWarnings
d938 1
a938 11
		xtermWarning("cannot load font '%s'\n", name);
#if OPT_RENDERFONT
		/*
		 * Do a sanity check in case someone's mixed up xterm with
		 * one of those programs that read their resource data from
		 * xterm's namespace.
		 */
		if (strchr(name, ':') != 0 || strchr(name, '=') != 0) {
		    xtermWarning("Use the \"-fa\" option for the Xft fonts\n");
		}
#endif
d943 2
a944 1
		code = xtermOpenFont(xw, DEFFONT, result, fwAlways, True);
d948 1
d955 1
a955 1
XTermFonts *
a964 1
    return 0;
d1014 1
d1045 1
a1045 1
    if (!IsEmpty(fnt->fn)) {
d1101 3
a1103 2
	reportOneVTFont("fNorm", &screen->fnts[fNorm]);
	reportOneVTFont("fBold", &screen->fnts[fBold]);
d1105 2
a1106 2
	reportOneVTFont("fWide", &screen->fnts[fWide]);
	reportOneVTFont("fWBold", &screen->fnts[fWBold]);
d1112 2
d1115 1
a1115 1
xtermUpdateFontGCs(XtermWidget xw, XTermFonts * fnts)
d1118 5
d1127 2
d1131 1
a1131 1
    setCgsFont(xw, win, gcNorm, &(fnts[fNorm]));
d1134 1
a1134 1
    setCgsFont(xw, win, gcBold, &(fnts[fBold]));
d1138 1
a1138 1
    setCgsFont(xw, win, gcNormReverse, &(fnts[fNorm]));
d1141 1
a1141 1
    setCgsFont(xw, win, gcBoldReverse, &(fnts[fBold]));
d1144 4
a1147 2
	if (fnts[fWide].fs != 0
	    && fnts[fWBold].fs != 0) {
d1150 1
a1150 1
	    setCgsFont(xw, win, gcWide, &(fnts[fWide]));
d1153 1
a1153 1
	    setCgsFont(xw, win, gcWBold, &(fnts[fWBold]));
d1157 1
a1157 1
	    setCgsFont(xw, win, gcWideReverse, &(fnts[fWide]));
d1160 1
a1160 1
	    setCgsFont(xw, win, gcWBoldReverse, &(fnts[fWBold]));
d1183 213
a1405 1
    FontNameProperties *fp;
a1407 1
    char *normal = NULL;
a1408 2
    fontWarningTypes warn[fMAX];
    int j;
a1417 21
    /*
     * Check the font names against the resource values, to see which were
     * derived in a previous call.  If so, we'll only warn about those if
     * the warning level is set to "always".
     */
    for (j = 0; j < fMAX; ++j) {
	warn[j] = fwAlways;
    }
#define CmpResource(field, index) \
    if (same_font_name(screen->menu_font_names[fontnum][index], myfonts.field)) \
	warn[index] = fwResource

    CmpResource(f_n, fNorm);
    if (fontnum == fontMenu_default) {
	CmpResource(f_b, fBold);
#if OPT_WIDE_CHARS
	CmpResource(f_b, fWide);
	CmpResource(f_b, fWBold);
#endif
    }

d1430 1
a1430 1
	   (warn[index] == fwResource) ? "*" : " ", \
d1439 4
a1442 13
    /*
     * If we are opening the default font, and it happens to be missing, force
     * that to the compiled-in default font, e.g., "fixed".  If we cannot open
     * the font, disable it from the menu.
     */
    if (!xtermOpenFont(xw,
		       myfonts.f_n,
		       &fnts[fNorm],
		       warn[fNorm],
		       (fontnum == fontMenu_default))) {
	if (fontnum != fontMenu_fontsel) {
	    SetItemSensitivity(fontMenuEntries[fontnum].widget, False);
	}
a1443 1
    }
d1445 7
a1451 34
    normal = x_strdup(myfonts.f_n);
    if (!check_fontname(myfonts.f_b)) {
	warn[fBold] = fwAlways;
	fp = get_font_name_props(screen->display, fnts[fNorm].fs, &normal);
	if (fp != 0) {
	    FREE_FNAME(f_b);
	    myfonts.f_b = bold_font_name(fp, fp->average_width);
	    if (!xtermOpenFont(xw, myfonts.f_b, &fnts[fBold], fwAlways, False)) {
		FREE_FNAME(f_b);
		myfonts.f_b = bold_font_name(fp, -1);
		xtermOpenFont(xw, myfonts.f_b, &fnts[fBold], fwAlways, False);
	    }
	    TRACE(("...derived bold '%s'\n", NonNull(myfonts.f_b)));
	}
	if (fp == 0 || fnts[fBold].fs == 0) {
	    xtermCopyFontInfo(&fnts[fBold], &fnts[fNorm]);
	    TRACE(("...cannot load a matching bold font\n"));
	} else if (comparable_metrics(fnts[fNorm].fs, fnts[fBold].fs)
		   && same_font_size(xw, fnts[fNorm].fs, fnts[fBold].fs)
		   && got_bold_font(screen->display, fnts[fBold].fs, myfonts.f_b)) {
	    TRACE(("...got a matching bold font\n"));
	    cache_menu_font_name(screen, fontnum, fBold, myfonts.f_b);
	} else {
	    xtermCloseFont2(xw, fnts, fBold);
	    fnts[fBold] = fnts[fNorm];
	    TRACE(("...did not get a matching bold font\n"));
	}
    } else if (!xtermOpenFont(xw, myfonts.f_b, &fnts[fBold], warn[fBold], False)) {
	xtermCopyFontInfo(&fnts[fBold], &fnts[fNorm]);
	warn[fBold] = fwAlways;
	TRACE(("...cannot load bold font '%s'\n", NonNull(myfonts.f_b)));
    } else {
	cache_menu_font_name(screen, fontnum, fBold, myfonts.f_b);
    }
a1458 77
	Boolean derived;
	char *bold = NULL;

	if (check_fontname(myfonts.f_w)) {
	    cache_menu_font_name(screen, fontnum, fWide, myfonts.f_w);
	} else if (screen->utf8_fonts && !is_double_width_font(fnts[fNorm].fs)) {
	    FREE_FNAME(f_w);
	    fp = get_font_name_props(screen->display, fnts[fNorm].fs, &normal);
	    if (fp != 0) {
		myfonts.f_w = wide_font_name(fp);
		warn[fWide] = fwAlways;
		TRACE(("...derived wide %s\n", NonNull(myfonts.f_w)));
		cache_menu_font_name(screen, fontnum, fWide, myfonts.f_w);
	    }
	}

	if (check_fontname(myfonts.f_w)) {
	    (void) xtermOpenFont(xw, myfonts.f_w, &fnts[fWide], warn[fWide], False);
	} else {
	    xtermCopyFontInfo(&fnts[fWide], &fnts[fNorm]);
	    warn[fWide] = fwAlways;
	}

	derived = False;
	if (!check_fontname(myfonts.f_wb)) {
	    fp = get_font_name_props(screen->display, fnts[fBold].fs, &bold);
	    if (fp != 0) {
		myfonts.f_wb = widebold_font_name(fp);
		warn[fWBold] = fwAlways;
		derived = True;
	    }
	}

	if (check_fontname(myfonts.f_wb)) {

	    xtermOpenFont(xw,
			  myfonts.f_wb,
			  &fnts[fWBold],
			  (screen->utf8_fonts
			   ? warn[fWBold]
			   : (fontWarningTypes) (xw->misc.fontWarnings + 1)),
			  False);

	    if (derived
		&& !compatibleWideCounts(fnts[fWide].fs, fnts[fWBold].fs)) {
		xtermCloseFont2(xw, fnts, fWBold);
	    }
	    if (fnts[fWBold].fs == 0) {
		FREE_FNAME(f_wb);
		if (IsEmpty(myfonts.f_w)) {
		    myfonts.f_wb = x_strdup(myfonts.f_b);
		    warn[fWBold] = fwAlways;
		    xtermCopyFontInfo(&fnts[fWBold], &fnts[fBold]);
		    TRACE(("...cannot load wide-bold, use bold %s\n",
			   NonNull(myfonts.f_b)));
		} else {
		    myfonts.f_wb = x_strdup(myfonts.f_w);
		    warn[fWBold] = fwAlways;
		    xtermCopyFontInfo(&fnts[fWBold], &fnts[fWide]);
		    TRACE(("...cannot load wide-bold, use wide %s\n",
			   NonNull(myfonts.f_w)));
		}
	    } else {
		TRACE(("...%s wide/bold %s\n",
		       derived ? "derived" : "given",
		       NonNull(myfonts.f_wb)));
		cache_menu_font_name(screen, fontnum, fWBold, myfonts.f_wb);
	    }
	} else if (is_double_width_font(fnts[fBold].fs)) {
	    xtermCopyFontInfo(&fnts[fWBold], &fnts[fBold]);
	    warn[fWBold] = fwAlways;
	    TRACE(("...bold font is double-width, use it %s\n", NonNull(myfonts.f_b)));
	} else {
	    xtermCopyFontInfo(&fnts[fWBold], &fnts[fWide]);
	    warn[fWBold] = fwAlways;
	    TRACE(("...cannot load wide bold font, use wide %s\n", NonNull(myfonts.f_w)));
	}
d1460 17
a1476 1
	free(bold);
a1477 32
	if (EmptyFont(fnts[fWBold].fs))
	    goto bad;		/* can't use a 0-sized font */
    });

    /*
     * Most of the time this call to load the font will succeed, even if
     * there is no wide font :  the X server doubles the width of the
     * normal font, or similar.
     *
     * But if it did fail for some reason, then nevermind.
     */
    if (EmptyFont(fnts[fBold].fs))
	goto bad;		/* can't use a 0-sized font */

    if (!same_font_size(xw, fnts[fNorm].fs, fnts[fBold].fs)
	&& (is_fixed_font(fnts[fNorm].fs) && is_fixed_font(fnts[fBold].fs))) {
	TRACE(("...ignoring mismatched normal/bold fonts\n"));
	xtermCloseFont2(xw, fnts, fBold);
	xtermCopyFontInfo(&fnts[fBold], &fnts[fNorm]);
    }

    if_OPT_WIDE_CHARS(screen, {
	if (fnts[fWide].fs != 0
	    && fnts[fWBold].fs != 0
	    && (!comparable_metrics(fnts[fWide].fs, fnts[fWBold].fs)
		|| (!same_font_size(xw, fnts[fWide].fs, fnts[fWBold].fs)
		    && is_fixed_font(fnts[fWide].fs)
		    && is_fixed_font(fnts[fWBold].fs)))) {
	    TRACE(("...ignoring mismatched normal/bold wide fonts\n"));
	    xtermCloseFont2(xw, fnts, fWBold);
	    xtermCopyFontInfo(&fnts[fWBold], &fnts[fWide]);
	}
d1524 2
a1525 2
    xtermCopyFontInfo(&(screen->fnts[fNorm]), &fnts[fNorm]);
    xtermCopyFontInfo(&(screen->fnts[fBold]), &fnts[fBold]);
d1527 1
a1527 1
    xtermCopyFontInfo(&(screen->fnts[fWide]), &fnts[fWide]);
d1529 2
a1530 2
	xtermCopyFontInfo(&fnts[fWBold], &fnts[fWide]);
    xtermCopyFontInfo(&(screen->fnts[fWBold]), &fnts[fWBold]);
d1533 1
a1533 1
    xtermUpdateFontGCs(xw, screen->fnts);
d1600 1
a1600 1
		|| same_font_name(normal, myfonts.f_b));
a1618 2
    if (normal)
	free(normal);
d1641 1
a1644 2
    if (normal)
	free(normal);
d1660 1
a1660 1
	myfonts.f_n = DEFFONT;
d1695 2
d1700 12
a1711 1
	    FontNameProperties *fp;
d1713 16
a1728 28
	    /*
	     * FIXME - need to handle font-leaks
	     */
	    screen->ifnts[n].fs = 0;
	    if (screen->fnts[n].fs != 0 &&
		(fp = get_font_name_props(screen->display,
					  screen->fnts[n].fs,
					  0)) != 0) {
		char *name;

		if ((name = italic_font_name(fp, fp->average_width)) != 0) {
		    TRACE(("xtermLoadItalics #%d %s\n", n, name));
		    (void) xtermOpenFont(xw,
					 name,
					 &(screen->ifnts[n]),
					 fwResource,
					 False);
#if OPT_TRACE
		    {
			XFontStruct *fs =
			screen->ifnts[n].fs;
			if (fs != 0) {
			    TRACE(("...actual size %dx%d (ascent %d, descent %d)\n",
				   fs->ascent +
				   fs->descent,
				   fs->max_bounds.width,
				   fs->ascent,
				   fs->descent));
a1730 2
#endif
		    free(name);
d1732 1
d1743 1
a1743 1
#define MERGE_SUBFONT(src,dst,name) \
d1745 1
a1745 1
	    TRACE(("MERGE_SUBFONT " #dst "." #name " merge %s\n", NonNull(src.name))); \
d1748 7
a1754 1
	    TRACE(("MERGE_SUBFONT " #dst "." #name " found %s\n", NonNull(dst.name))); \
d1757 1
a1757 1
#define INFER_SUBFONT(src,dst,name) \
d1762 1
a1762 1
	    TRACE(("INFER_SUBFONT " #dst "." #name " found %s\n", NonNull(dst.name))); \
d1774 1
a1774 1
#define COPY_MENU_FONTS(src,dst) \
d1785 1
d1788 4
d1795 34
a1828 2
    target->f_n = x_strdup(source->f_n);
    target->f_b = x_strdup(source->f_b);
d1830 3
a1832 2
    target->f_w = x_strdup(source->f_w);
    target->f_wb = x_strdup(source->f_wb);
d1834 1
d1848 2
a1849 1
	COPY_MENU_FONTS(xw->screen, screen->cacheVTFonts);
d1926 1
d1928 1
a1928 1
	COPY_MENU_FONTS(screen->cacheVTFonts, xw->screen);
d1964 16
d1982 4
a1985 2
	    MERGE_SUBFONT(xw->misc, subresourceRec, default_font.f_n);
	    INFER_SUBFONT(xw->misc, subresourceRec, default_font.f_b);
d1987 4
a1990 2
	    INFER_SUBFONT(xw->misc, subresourceRec, default_font.f_w);
	    INFER_SUBFONT(xw->misc, subresourceRec, default_font.f_wb);
d1993 1
a1993 1
		MERGE_SUBFONT(xw->screen, subresourceRec, MenuFontName(n));
d2000 1
d2002 1
a2002 1
	    COPY_MENU_FONTS(subresourceRec, xw->screen);
d2006 2
a2007 2
	    screen->MenuFontName(fontMenu_default) = x_strdup(xw->misc.default_font.f_n);
	    screen->menu_font_names[0][fBold] = x_strdup(xw->misc.default_font.f_b);
d2011 2
a2012 2
	    screen->menu_font_names[0][fWide] = x_strdup(xw->misc.default_font.f_w);
	    screen->menu_font_names[0][fWBold] = x_strdup(xw->misc.default_font.f_wb);
d2031 1
d2067 3
a2069 3
    if (EmptyFont(screen->fnts[fWide].fs)) {
	result = (isWideFont(screen->fnts[fNorm].fs, "normal", nullOk)
		  && isWideFont(screen->fnts[fBold].fs, "bold", nullOk));
d2071 3
a2073 2
	result = (isWideFont(screen->fnts[fWide].fs, "wide", nullOk)
		  && isWideFont(screen->fnts[fWBold].fs, "wide-bold", nullOk));
d2075 3
a2077 2
	    result = (isWideFont(screen->fnts[fNorm].fs, "normal", nullOk)
		      && isWideFont(screen->fnts[fBold].fs, "bold", nullOk));
d2145 5
a2149 4
		    SetVTFont(xw, font_number, True,
			      ((font_number == fontMenu_default)
			       ? &(xw->misc.default_font)
			       : NULL));
d2197 1
d2242 1
a2242 1
    return (long) last;
d2244 1
d2315 1
d2352 3
d2376 1
a2376 1
		    xtermWarning("cannot open %s font \"%s\"\n", tag, name);
d2383 1
a2383 1
		xtermWarning("cannot match %s font \"%s\"\n", tag, name);
d2489 1
a2489 2
 * Get the faceName/faceDoublesize resource setting.  Strip off "xft:", which
 * is not recognized by XftNameParse().
d2496 2
a2497 2
		     ? xw->misc.face_wide_name
		     : xw->misc.face_name);
d2499 1
a2499 1
    String result = xw->misc.face_name;
a2500 2
    if (!IsEmpty(result) && !strncmp(result, "xft:", (size_t) 4))
	result += 4;
d2512 2
a2513 2
    Boolean changed = (Boolean) ((xw->misc.face_name == 0)
				 || strcmp(xw->misc.face_name, value));
d2518 1
a2518 1
	xw->misc.face_name = x_strdup(value);
d2520 1
d2522 3
a2524 8
	    xtermCloseXft(screen, &(screen->renderFontNorm[n]));
	    xtermCloseXft(screen, &(screen->renderFontBold[n]));
	    xtermCloseXft(screen, &(screen->renderFontBold[n]));
#if OPT_RENDERWIDE
	    xtermCloseXft(screen, &(screen->renderWideNorm[n]));
	    xtermCloseXft(screen, &(screen->renderWideBold[n]));
	    xtermCloseXft(screen, &(screen->renderWideItal[n]));
#endif
d2583 1
a2583 2
	    XFT_SIZE, XftTypeDouble, face_size, \
	    XFT_SPACING, XftTypeInteger, XFT_MONO
d2652 1
a2652 1
		double aspect = ((xw->misc.face_wide_name
d2793 2
a2794 2
    xtermComputeFontInfo(xw, win, screen->fnts[fNorm].fs, scrollbar_width);
    xtermSaveFontInfo(screen, screen->fnts[fNorm].fs);
d2841 2
a2842 2
	TRACE(("xtermMissingChar %#04x (!exists), %d cells\n",
	       ch, my_wcwidth(ch)));
d3092 2
a3093 2
		     ? IsXtermMissingChar(screen, n, &screen->fnts[fBold])
		     : IsXtermMissingChar(screen, n, &screen->fnts[fNorm]))) {
d3243 2
a3244 2
	    TRACE(("xtermXftMissing %d (dec=%#x, ucs=%#x)\n",
		   wc, ucs2dec(wc), dec2ucs(wc)));
d3246 1
a3246 1
	    TRACE(("xtermXftMissing %d\n", wc));
d3360 1
a3360 7
	if (xtermOpenFont(xw,
			  screen->MenuFontName(fontnum),
			  &fnt,
			  ((fontnum <= fontMenu_lastBuiltin)
			   ? fwAlways
			   : fwResource),
			  True)) {
d3746 1
a3746 1
		fonts.f_wb = params[4];
d3749 2
a3750 1
		fonts.f_w = params[3];
a3751 1
#endif
d3753 1
a3753 1
		fonts.f_b = params[2];
d3756 1
a3756 1
		fonts.f_n = params[1];
d3846 558
@


1.29
log
@Update to xterm 320. Tested by jsg@@ Thanks.
@
text
@d1 1
a1 1
/* $XTermId: fontutils.c,v 1.451 2015/08/18 00:55:19 tom Exp $ */
d4 1
a4 1
 * Copyright 1998-2014,2015 by Thomas E. Dickey
a270 2
    XFontProp *fp;
    int i;
d279 3
a874 1
    int k;
d877 2
a948 1
	unsigned ch;
d972 1
a1524 3
    FontNameProperties *fp;
    char *name;
    int n;
d1527 2
d1531 2
d1541 2
a1646 1
    int n;
d1658 2
a1870 2
    static char empty[] = "";	/* appease strict compilers */

d1874 2
a1877 1
	char class_buf[80];
d1883 1
a1885 1
	    int n;
d1894 1
a2115 1
    XftPattern *match;
d2120 1
a2120 1
	match = XftFontMatch(dpy, DefaultScreen(dpy), pat, &status);
a2269 1
    int n;
d2274 2
d2604 2
a2605 1
	TRACE(("xtermMissingChar %#04x (!exists)\n", ch));
a3246 1
    int n;
d3251 1
d3299 1
a3299 1
    int n, m = -1;
d3307 1
d3334 1
@


1.28
log
@xterm 314. tested by naddy@@
@
text
@d1 1
a1 1
/* $XTermId: fontutils.c,v 1.445 2014/12/28 22:52:30 tom Exp $ */
d4 1
a4 1
 * Copyright 1998-2013,2014 by Thomas E. Dickey
d537 1
a537 1
	old_props.res_x = res_y;
d868 21
d894 1
a894 1
    int j, k;
d897 1
a897 11
	/*
	 * Need to save the pointer since xtermCloseFont zeroes it
	 */
	XFontStruct *thisFont = fnts[j].fs;
	if (thisFont != 0) {
	    xtermCloseFont(xw, &fnts[j]);
	    for (k = j + 1; k < fMAX; ++k) {
		if (thisFont == fnts[k].fs)
		    xtermFreeFontInfo(&fnts[k]);
	    }
	}
d1176 1
a1176 1
	    xtermCloseFont(xw, &fnts[fBold]);
d1239 1
a1239 1
		xtermCloseFont(xw, &fnts[fWBold]);
d1291 1
a1291 1
	xtermCloseFont(xw, &fnts[fBold]);
d1303 1
a1303 1
	    xtermCloseFont(xw, &fnts[fWBold]);
d1874 1
a1874 4
	char *myName = (char *) MyStackAlloc(strlen(name) + 1, name_buf);
	String convert = (String) ((*param_count > 1) ? params[1] : myName);
	char *myClass = (char *) MyStackAlloc(strlen(convert) + 1, class_buf);
	int n;
d1877 10
a1886 4
	strcpy(myName, name);
	strcpy(myClass, convert);
	if (*param_count == 1)
	    myClass[0] = x_toupper(myClass[0]);
d1888 21
a1908 16
	if (xtermLoadVTFonts(xw, myName, myClass)) {
	    /*
	     * When switching fonts, try to preserve the font-menu selection, since
	     * it is less surprising to do that (if the font-switching can be
	     * undone) than to switch to "Default".
	     */
	    int font_number = screen->menu_font_number;
	    if (font_number > fontMenu_lastBuiltin)
		font_number = fontMenu_lastBuiltin;
	    for (n = 0; n < NMENUFONTS; ++n) {
		screen->menu_font_sizes[n] = 0;
	    }
	    SetVTFont(xw, font_number, True,
		      ((font_number == fontMenu_default)
		       ? &(xw->misc.default_font)
		       : NULL));
a1909 3

	MyStackFree(myName, name_buf);
	MyStackFree(myClass, class_buf);
d3105 1
a3105 1
#if OPT_SHIFT_FONTS
d3147 1
d3283 1
d3407 1
a3407 1
#endif
@


1.27
log
@Update to xterm 311. ok shadchin@@
@
text
@d1 1
a1 1
/* $XTermId: fontutils.c,v 1.443 2014/09/03 23:58:53 tom Exp $ */
d1592 1
a1592 1
	    TRACE((".. " #dst ".menu_fonts_names[%d] = %s\n", n, dst.menu_font_names[n][fNorm])); \
d3572 3
a3574 3
		xtermLoadFont(xw,
			      xtermFontName(screen->MenuFontName(oldFont)),
			      doresize, oldFont);
@


1.26
log
@Update to xterm-309. Version 308 tested by several people including
naddy@@ who found a small regression, fixed in 309.
@
text
@d1 1
a1 1
/* $XTermId: fontutils.c,v 1.440 2014/07/13 00:34:40 Ross.Combs Exp $ */
a53 6
#define ALLOC_STRING(name) \
	if (name != 0) \
	    name = x_strdup(name)
#define FREE_STRING(name) \
	    free_string(name)

a122 6
static void
free_string(String value)
{
    free((void *) value);
}

d1136 3
a1138 1
	SetItemSensitivity(fontMenuEntries[fontnum].widget, False);
d1430 1
a1430 2
	    SetItemSensitivity(fontMenuEntries[fontMenu_fontescape].widget,
			       True);
d1469 1
a1469 1
    if (fontnum == fontMenu_fontsel) {
d1484 4
a1487 2
	    SetItemSensitivity(fontMenuEntries[fontnum].widget,
			       UsingRenderFont(xw));
@


1.25
log
@Update to xterm 304. With help of shadchin@@

tested by ajacoutot@@ and shadchin@@
@
text
@d1 1
a1 1
/* $XTermId: fontutils.c,v 1.405 2014/05/03 10:49:26 tom Exp $ */
d54 6
d98 6
d110 1
a110 1
    char *beginning;
d112 1
a112 1
    char *weight;
d114 1
a114 1
    char *slant;
d116 1
a116 1
    char *wideness;
d118 1
a118 1
    char *add_style;
d120 1
a120 1
    char *point_size;
d123 1
a123 1
    char *spacing;
d129 6
d218 1
a218 1
 * function will modify the source, putting '\0's in the appropiate place and
d232 1
a232 1
    for (i = start - 1, str = *source; i; i--, str++)
d235 1
d240 1
a240 1
    for (i = stop - start + 1, str1 = str; i; i--, str1++)
d243 1
d467 10
d503 1
a503 1
xtermSpecialFont(TScreen *screen, unsigned atts, unsigned chrset)
d523 1
a523 1
    if (atts & BOLD)
d541 2
a542 1
	TRACE(("xtermSpecialFont(atts = %#x, chrset = %#x)\n", atts, chrset));
d563 2
a564 2
    append_fontname_num(&result, (atts & NORESOLUTION) ? -1 : res_x);
    append_fontname_num(&result, (atts & NORESOLUTION) ? -1 : res_y);
d633 30
d787 1
a787 2
    if (data.f_n)
	free((void *) data.f_n);
d797 1
a797 1
	char *last = (char *) screen->menu_font_names[fontnum][which];
d800 1
a800 1
		free(last);
a945 1
	unsigned missing = 0;
a957 6
	for (ch = first_char; ch <= last_char; ++ch) {
	    if (xtermMissingChar(ch, fnt)) {
		++missing;
	    }
	}

d967 13
a979 2
	printf("\t\tmissing-chars: %u\n", missing);
	printf("\t\tpresent-chars: %u\n", countGlyphs(fs) - missing);
d1010 60
a1081 2
    Pixel new_normal;
    Pixel new_revers;
d1157 1
d1160 1
d1169 2
a1170 1
	} else if (same_font_size(xw, fnts[fNorm].fs, fnts[fBold].fs)
d1199 1
d1241 1
d1243 1
a1243 1
		    myfonts.f_wb = myfonts.f_b;
d1249 1
a1249 1
		    myfonts.f_wb = myfonts.f_w;
d1297 4
a1300 2
	    && !same_font_size(xw, fnts[fWide].fs, fnts[fWBold].fs)
	    && (is_fixed_font(fnts[fWide].fs) && is_fixed_font(fnts[fWBold].fs))) {
d1346 4
d1360 1
a1360 35
    new_normal = getXtermForeground(xw, xw->flags, xw->cur_foreground);
    new_revers = getXtermBackground(xw, xw->flags, xw->cur_background);

    setCgsFore(xw, win, gcNorm, new_normal);
    setCgsBack(xw, win, gcNorm, new_revers);
    setCgsFont(xw, win, gcNorm, &(screen->fnts[fNorm]));

    copyCgs(xw, win, gcBold, gcNorm);
    setCgsFont(xw, win, gcBold, &(screen->fnts[fBold]));

    setCgsFore(xw, win, gcNormReverse, new_revers);
    setCgsBack(xw, win, gcNormReverse, new_normal);
    setCgsFont(xw, win, gcNormReverse, &(screen->fnts[fNorm]));

    copyCgs(xw, win, gcBoldReverse, gcNormReverse);
    setCgsFont(xw, win, gcBoldReverse, &(screen->fnts[fBold]));

    if_OPT_WIDE_CHARS(screen, {
	if (screen->fnts[fWide].fs != 0
	    && screen->fnts[fWBold].fs != 0) {
	    setCgsFore(xw, win, gcWide, new_normal);
	    setCgsBack(xw, win, gcWide, new_revers);
	    setCgsFont(xw, win, gcWide, &(screen->fnts[fWide]));

	    copyCgs(xw, win, gcWBold, gcWide);
	    setCgsFont(xw, win, gcWBold, &(screen->fnts[fWBold]));

	    setCgsFore(xw, win, gcWideReverse, new_revers);
	    setCgsBack(xw, win, gcWideReverse, new_normal);
	    setCgsFont(xw, win, gcWideReverse, &(screen->fnts[fWide]));

	    copyCgs(xw, win, gcWBoldReverse, gcWideReverse);
	    setCgsFont(xw, win, gcWBoldReverse, &(screen->fnts[fWBold]));
	}
    });
d1371 1
a1371 1
     * Xterm uses character positions 1-31 of a font for the line-drawing
d1387 9
a1395 4
	TRACE(("normal font is %scomplete\n",
	       FontIsIncomplete(&fnts[fNorm]) ? "in" : ""));
	TRACE(("bold font is %scomplete\n",
	       FontIsIncomplete(&fnts[fBold]) ? "in" : ""));
d1437 1
a1437 1
	    free((void *) screen->MenuFontName(fontnum));
d1455 16
d1512 53
d1572 1
a1572 1
	    dst.name = src.name; \
d1585 9
d1598 1
d1604 14
d1628 1
a1628 1
	screen->cacheVTFonts.default_font = xw->misc.default_font;
d1704 2
a1705 1
	xw->misc.default_font = screen->cacheVTFonts.default_font;
a1706 3
	for (n = 0; n < XtNumber(screen->cacheVTFonts.menu_font_names); ++n) {
	    screen->MenuFontName(n) = screen->cacheVTFonts.MenuFontName(n);
	}
d1728 14
d1750 1
a1750 1
	    for (n = fontMenu_font1; n <= fontMenu_lastBuiltin; ++n)
d1752 1
d1757 2
a1758 1
	    xw->misc.default_font = subresourceRec.default_font;
d1760 3
d1766 2
d1771 12
d1892 1
a1892 1
	    for (n = 0; n < NMENUFONTS; ++n)
d1894 1
d1954 1
a1954 1
    for (i = 0; i < FC_CHARSET_MAP_SIZE; i++)
d1964 1
d1978 1
a1978 1
    for (i = FC_CHARSET_MAP_SIZE - 1; i >= 0; i--)
d1988 1
d2075 1
a2075 1
	printf("Loaded XftFonts(%s:%s)\n", name, tag);
d2343 10
d2366 2
a2367 3
#if OPT_ISO_COLORS
		    if (screen->italicULMode
			&& (pat = XftNameParse(face_name)) != 0) {
d2374 1
a2374 1
#endif /* OPT_ISO_COLORS */
d2436 2
a2437 3
#if OPT_ISO_COLORS
			if (screen->italicULMode
			    && (pat = XftNameParse(face_name)) != 0) {
d2632 2
a2633 1
		 unsigned flags,
d2818 4
a2821 2
    unsigned font_width = (unsigned) (((flags & DOUBLEWFONT) ? 2 : 1) * screen->fnt_wide);
    unsigned font_height = (unsigned) (((flags & DOUBLEHFONT) ? 2 : 1) * screen->fnt_high);
d2840 1
a2840 1
		&& !((flags & BOLD)
d2868 1
a2868 1
    if (!(flags & NOBACKGROUND)) {
d2880 1
a2880 1
		       (flags & BOLD)
d3556 1
d3586 6
@


1.24
log
@Update to xterm 301
@
text
@d1 1
a1 1
/* $XTermId: fontutils.c,v 1.400 2013/12/09 12:20:31 tom Exp $ */
d4 1
a4 1
 * Copyright 1998-2012,2013 by Thomas E. Dickey
d127 1
a127 1
countGlyphs(XFontStruct * fp)
d152 1
a152 1
compatibleWideCounts(XFontStruct * wfs, XFontStruct * wbfs)
d258 1
a258 1
get_font_name_props(Display *dpy, XFontStruct * fs, char **result)
d375 1
d377 2
d418 1
a418 1
derive_font_name(FontNameProperties * props,
d442 1
a442 1
bold_font_name(FontNameProperties * props, int use_average_width)
d452 1
a452 1
wide_font_name(FontNameProperties * props)
d458 1
a458 1
widebold_font_name(FontNameProperties * props)
d588 1
a588 1
got_bold_font(Display *dpy, XFontStruct * fs, String requested)
d607 1
a607 1
same_font_size(XtermWidget xw, XFontStruct * nfs, XFontStruct * bfs)
d627 1
a627 1
is_fixed_font(XFontStruct * fs)
d640 1
a640 1
is_double_width_font(XFontStruct * fs)
d669 1
a669 1
is_double_width_font_xft(Display *dpy, XftFont * font)
d1360 9
a1368 1
    if (x_strcasecmp(myfonts.f_n, DEFFONT)) {
d1565 1
a1565 1
isWideFont(XFontStruct * fp, const char *tag, Bool nullOk)
d1631 1
a1631 1
		  XEvent * event GCC_UNUSED,
d1717 1
a1717 1
xtermXftFirstChar(XftFont * xft)
d1739 1
a1739 1
xtermXftLastChar(XftFont * xft)
d1763 1
a1763 1
dumpXft(XtermWidget xw, XTermXftFonts * data)
d1798 1
a1798 1
checkXft(XtermWidget xw, XTermXftFonts * data, XftFont * xft)
d1832 1
a1832 1
	       XftFont * fp,
d1835 1
a1835 1
	       XftPattern * match)
d1868 1
a1868 1
xtermOpenXft(XtermWidget xw, const char *name, XftPattern * pat, const char *tag)
d1935 1
a1935 1
setRenderFontsize(TScreen *screen, VTwin * win, XftFont * font, const char *tag)
d1992 1
a1992 1
xtermCloseXft(TScreen *screen, XTermXftFonts * pub)
d2053 2
a2054 2
		     VTwin * win,
		     XFontStruct * font,
d2282 1
a2282 1
xtermSaveFontInfo(TScreen *screen, XFontStruct * font)
d2742 1
a2742 1
xtermXftMissing(XtermWidget xw, XftFont * font, unsigned wc)
d2900 13
a2916 1
    float value;
d2931 1
a2931 2
	    sscanf(DEFFACESIZE, "%f", &value);
	    face_size = value;
d2961 1
a2961 2
		sscanf(DEFFACESIZE, "%f", &value);
		face_size = value;
d3110 1
a3110 1
		 XEvent * event GCC_UNUSED,
d3135 1
a3135 1
		  XEvent * event GCC_UNUSED,
d3205 1
a3205 1
	      XEvent * event GCC_UNUSED,
@


1.23
log
@Update to xterm-300. Tested  by ajacoutot@@ and shadchin@@.
@
text
@d1 1
a1 1
/* $XTermId: fontutils.c,v 1.399 2013/11/26 20:12:00 tom Exp $ */
d125 1
a125 1
#if OPT_WIDE_CHARS
d143 1
d145 1
d2312 1
a2312 1
#if OPT_BOX_CHARS
d2349 1
d2351 1
d2721 1
d2749 1
a2749 3
#endif /* OPT_RENDERFONT && OPT_WIDE_CHARS */

#endif /* OPT_BOX_CHARS */
@


1.22
log
@Update to xterm 293. Tested by naddy@@ ajacoutot@@
@
text
@d1 1
a1 1
/* $XTermId: fontutils.c,v 1.387 2013/05/15 00:31:56 tom Exp $ */
d4 1
a4 1
 * Copyright 1998-2011,2012 by Thomas E. Dickey
d62 1
a62 1
#define CI_GET_CHAR_INFO_1D(fs,col,def,cs) \
d64 1
a64 1
    cs = def; \
a69 1
	    if (CI_NONEXISTCHAR(cs)) cs = def; \
d71 1
d75 1
a75 1
#define CI_GET_CHAR_INFO_2D(fs,row,col,def,cs) \
d77 1
a77 1
    cs = def; \
a86 1
	    if (CI_NONEXISTCHAR(cs)) cs = def; \
d88 1
d133 1
a133 1
	    count = fp->max_char_or_byte2 - fp->min_char_or_byte2;
d256 1
a256 1
get_font_name_props(Display * dpy, XFontStruct * fs, char **result)
d468 1
a468 1
xtermSpecialFont(TScreen * screen, unsigned atts, unsigned chrset)
d583 1
a583 1
got_bold_font(Display * dpy, XFontStruct * fs, String requested)
d664 1
a664 1
is_double_width_font_xft(Display * dpy, XftFont * font)
d729 1
a729 1
cache_menu_font_name(TScreen * screen, int fontnum, int which, const char *name)
d863 78
d1283 5
d1343 3
d1619 1
a1619 1
		  String * params GCC_UNUSED,
d1669 1
a1669 1
xtermSetCursorBox(TScreen * screen)
a1702 1
#if OPT_TRACE > 1
d1715 1
a1715 1
	    first += i * 32;
d1734 1
a1734 1
    last &= ~0xff;
d1738 1
a1738 1
	    last += i * 32 + 31;
d1748 1
d1817 37
d1869 1
d1922 1
a1922 1
setRenderFontsize(TScreen * screen, VTwin * win, XftFont * font, const char *tag)
d1979 1
a1979 1
xtermCloseXft(TScreen * screen, XTermXftFonts * pub)
d2269 1
a2269 1
xtermSaveFontInfo(TScreen * screen, XFontStruct * font)
d2320 1
a2320 1
    static XCharStruct dft, *tmp = &dft, *pc = 0;
d2324 4
a2327 3
	if (ch > 255) {
	    TRACE(("xtermMissingChar %#04x (row)\n", ch));
	    return True;
a2328 2
#endif
	CI_GET_CHAR_INFO_1D(fs, E2A(ch), tmp, pc);
d2332 3
a2334 1
	CI_GET_CHAR_INFO_2D(fs, HI_BYTE(ch), LO_BYTE(ch), tmp, pc);
a2335 4
#else

    if (!pc)
	return False;		/* Urgh! */
d2338 1
a2338 1
    if (CI_NONEXISTCHAR(pc)) {
d2342 1
a2342 1
    if (ch < 256) {
d3087 1
a3087 1
		 String * params GCC_UNUSED,
d3112 1
a3112 1
		  String * params GCC_UNUSED,
d3182 1
a3182 1
	      String * params,
@


1.21
log
@Update to xterm 291. Tested by many.
@
text
@d1 1
a1 1
/* $XTermId: fontutils.c,v 1.386 2012/12/31 20:51:54 tom Exp $ */
d1865 1
a1865 1
 * is not recognized by XftParseName().
@


1.20
log
@Update to xterm 287. tested by mpi@@ and krw@@.
@
text
@d1 1
a1 1
/* $XTermId: fontutils.c,v 1.383 2012/09/22 00:15:55 tom Exp $ */
a91 2
#define MAX_FONTNAME 200

a243 3
    } else if (strlen(name) >= MAX_FONTNAME - 1) {
	TRACE(("fontname too large: %s\n", name));
	result = False;
d256 1
a256 1
get_font_name_props(Display * dpy, XFontStruct * fs, char *result)
d292 3
a294 1
	strcpy(result, name);
d515 2
a516 1
	old_props.spacing = strcpy(old_spacing, props->spacing);
d585 1
a585 1
    char actual[MAX_FONTNAME];
d588 1
a588 1
    if (get_font_name_props(dpy, fs, actual) == 0)
d592 1
d878 1
a878 1
    char normal[MAX_FONTNAME];
d947 1
a947 1
    strcpy(normal, myfonts.f_n);
d950 1
a950 1
	fp = get_font_name_props(screen->display, fnts[fNorm].fs, normal);
d986 1
a986 1
	char bold[MAX_FONTNAME];
d991 1
a991 1
	    fp = get_font_name_props(screen->display, fnts[fNorm].fs, normal);
d1009 1
a1009 1
	    fp = get_font_name_props(screen->display, fnts[fBold].fs, bold);
d1061 2
d1255 2
d1263 2
d1545 1
a1545 1
	char *myName = (char *) MyStackAlloc(strlen(name), name_buf);
d1547 1
a1547 1
	char *myClass = (char *) MyStackAlloc(strlen(convert), class_buf);
@


1.19
log
@Update to xterm 278. Tested by mpi@@, shadchin@@
@
text
@d1 1
a1 1
/* $XTermId: fontutils.c,v 1.380 2011/12/27 10:20:50 tom Exp $ */
d4 1
a4 1
 * Copyright 1998-2010,2011 by Thomas E. Dickey
d176 1
a176 1
    if (xw->misc.render_font == True) {
d1584 2
a1585 1
    int hh = screen->cursor_underline ? 1 : fh;
d1588 1
a1588 1
    (vp++)->x = (short) fw;
d1590 1
a1590 1
    (vp++)->x = (short) -fw;
d2077 1
a2077 1
	    xw->misc.render_font = False;
d2486 1
a2486 1
	XFillRectangle(screen->display, VWindow(screen), gc2, x, y,
d2535 1
a2535 1
		     VWindow(screen), gc2,
d2548 1
a2548 1
		 VWindow(screen), gc2,
d2562 1
a2562 1
		 VWindow(screen), gc2,
d2578 1
a2578 1
			  VWindow(screen), gc2,
d2586 1
a2586 1
	XDrawRectangle(screen->display, VWindow(screen), gc2, x, y,
@


1.18
log
@Update to xterm 276. Tested by ajacoutot@@, krw@@, naddy@@, shadchin@@.
@
text
@d1 1
a1 1
/* $XTermId: fontutils.c,v 1.378 2011/10/10 23:46:00 tom Exp $ */
d777 1
a777 1
		fprintf(stderr, "%s: cannot load font '%s'\n", ProgramName, name);
d785 1
a785 2
		    fprintf(stderr,
			    "Use the \"-fa\" option for the Xft fonts\n");
d1745 1
a1745 2
		    fprintf(stderr, "%s: cannot open %s font \"%s\"\n",
			    ProgramName, tag, name);
d1752 1
a1752 2
		fprintf(stderr, "%s: cannot match %s font \"%s\"\n",
			ProgramName, tag, name);
d1842 1
a1842 2
	fprintf(stderr,
		"Selected font has no non-zero %s for ISO-8859-1 encoding\n", tag);
d1885 2
a1886 2
    Boolean changed = ((xw->misc.face_name == 0)
		       || strcmp(xw->misc.face_name, value));
@


1.17
log
@Update to xterm-275. Tested by jasper@@.
@
text
@d1 1
a1 1
/* $XTermId: fontutils.c,v 1.368 2011/09/11 13:22:34 tom Exp $ */
d55 1
a55 1
#define SetFontHeight(screen,dst,src) (dst)->f_height = (int)((screen)->scale_height * (float) (src))
d119 4
d124 1
a124 1
static void lookupOneFontSize(XtermWidget, int);
d1263 19
d1770 1
a1770 1
mySquareRoot(double value)
d1889 2
d1892 7
a1898 6
    xw->misc.face_name = x_strdup(value);
    for (n = 0; n < NMENUFONTS; ++n) {
	xw->misc.face_size[n] = -1.0;
	xtermCloseXft(screen, &(screen->renderFontNorm[n]));
	xtermCloseXft(screen, &(screen->renderFontBold[n]));
	xtermCloseXft(screen, &(screen->renderFontBold[n]));
d1900 3
a1902 3
	xtermCloseXft(screen, &(screen->renderWideNorm[n]));
	xtermCloseXft(screen, &(screen->renderWideBold[n]));
	xtermCloseXft(screen, &(screen->renderWideItal[n]));
d1904 1
d1946 1
a1946 1
	    double face_size = xw->misc.face_size[fontnum];
d1948 1
a1948 1
	    TRACE(("xtermComputeFontInfo font %d: norm(face %s, size %f)\n",
d1952 2
a1953 54
	    if (face_size <= 0.0) {
#if OPT_SHIFT_FONTS
		/*
		 * If the user is switching font-sizes, make it follow by
		 * default the same ratios to the default as the fixed fonts
		 * would, for easy comparison.  There will be some differences
		 * since the fixed fonts have a variety of height/width ratios,
		 * but this is simpler than adding another resource value - and
		 * as noted above, the data for the fixed fonts are available.
		 */
		lookupOneFontSize(xw, 0);
		lookupOneFontSize(xw, fontnum);
		if (fontnum == fontMenu_default) {
		    face_size = 14.0;
		} else {
		    double ratio;
		    long num = screen->menu_font_sizes[fontnum];
		    long den = screen->menu_font_sizes[0];

		    if (den <= 0)
			den = 1;
		    ratio = mySquareRoot((double) num / (double) den);

		    face_size = (ratio * xw->misc.face_size[0]);
		    TRACE(("scaled using %3ld/%ld = %.2f -> %f\n",
			   num, den, ratio, face_size));
		}
#else
		switch (fontnum) {
		case fontMenu_font1:
		    face_size = 8.0;
		    break;
		case fontMenu_font2:
		    face_size = 10.0;
		    break;
		case fontMenu_font3:
		    face_size = 12.0;
		    break;
		default:
		    face_size = 14.0;
		    break;
		case fontMenu_font4:
		    face_size = 16.0;
		    break;
		case fontMenu_font5:
		    face_size = 18.0;
		    break;
		case fontMenu_font6:
		    face_size = 20.0;
		    break;
		}
#endif
		xw->misc.face_size[fontnum] = (float) face_size;
	    }
d2720 1
a2720 1
static void
d2730 7
a2736 1
	if (xtermOpenFont(xw, screen->MenuFontName(fontnum), &fnt, fwAlways, True)) {
d2738 1
a2738 1
		|| strcmp(fnt.fn, DEFFONT))
d2740 3
d2746 1
d2758 1
a2758 1
	lookupOneFontSize(xw, n);
d2763 76
a2838 1
#define NMENU_RENDERFONTS (NMENUFONTS - 2)	/* no selection or escape */
d2845 1
d2847 2
a2848 1
	result = True;
d2851 1
a2851 1
		result = False;
d2855 1
a2855 1
	if (!result) {
d2858 1
a2858 1
	    long first = screen->menu_font_sizes[0];
d2861 1
a2869 5
	    /*
	     * Workaround for breakage in font-packages - check if all of the
	     * bitmap font sizes are the same, and if we're using TrueType
	     * fonts.
	     */
a2870 3
		float lo_value = (float) 9.0e9;
		float hi_value = (float) 0.0;
		float value;
d2874 1
a2874 7
		    value = xw->misc.face_size[n];
		    if (value > 0.0) {
			if (lo_value > value)
			    lo_value = value;
			if (hi_value < value)
			    hi_value = value;
		    }
a2876 13
		if (hi_value <= 0.0)
		    sscanf(DEFFACESIZE, "%f", &value);
		else
		    value = (float) ((hi_value + lo_value) / 2.0);
		if (value <= 0)
		    value = (float) 14.0;

		for (n = 0; n < NMENUFONTS; n++) {
		    TRACE(("setting faceSize%d %.1f\n", n, value));
		    xw->misc.face_size[n] = value;
		    value = (float) (value * 1.1);
		}
		result = True;
d2879 1
d2881 1
d2884 1
a2884 1
#endif
d2903 1
@


1.16
log
@Update to xterm 273. Tested by marco@@, jasper@@.
@
text
@d1 1
a1 1
/* $XTermId: fontutils.c,v 1.361 2011/07/17 22:26:05 tom Exp $ */
d3 29
a31 31
/************************************************************

Copyright 1998-2009,2010 by Thomas E. Dickey

                        All Rights Reserved

Permission is hereby granted, free of charge, to any person obtaining a
copy of this software and associated documentation files (the
"Software"), to deal in the Software without restriction, including
without limitation the rights to use, copy, modify, merge, publish,
distribute, sublicense, and/or sell copies of the Software, and to
permit persons to whom the Software is furnished to do so, subject to
the following conditions:

The above copyright notice and this permission notice shall be included
in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
IN NO EVENT SHALL THE ABOVE LISTED COPYRIGHT HOLDER(S) BE LIABLE FOR ANY
CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

Except as contained in this notice, the name(s) of the above copyright
holders shall not be used in advertising or otherwise to promote the
sale, use or other dealings in this Software without prior written
authorization.

********************************************************/
d54 3
d665 2
a666 2
    char *fwstr = FULL_WIDTH_TEST_STRING;
    char *hwstr = HALF_WIDTH_TEST_STRING;
d681 10
a690 2
    XftTextExtentsUtf8(dpy, font, (FcChar8 *) hwstr, (int) strlen(hwstr), &gi1);
    XftTextExtentsUtf8(dpy, font, (FcChar8 *) fwstr, (int) strlen(fwstr), &gi2);
d1321 1
d1323 3
a1325 1
	|| !SAME_MEMBER(default_font.f_wb)) {
d1575 1
a1575 1
	    TRACE(("Xft metrics %s[%d] = %d (%d,%d) advance %d, actual %d%s\n",\
d1581 1
d1792 2
a1793 2
	    win->f_width = width;
	    win->f_height = height;
d1807 2
a1808 2
	    win->f_width = width;
	    win->f_height = height;
d2117 2
a2118 2
		win->f_height = use->font->ascent + use->font->descent;
		win->f_width = use->map.min_width;
d2135 1
a2135 1
	    win->f_width = (font->min_bounds.width);
d2137 1
a2137 1
	    win->f_width = (font->max_bounds.width);
d2139 1
a2139 1
	win->f_height = (font->ascent + font->descent);
d2810 1
a2810 1
	     * fonts. 
@


1.15
log
@Update to xterm 271. Tested by shadchin@@ and ajacoutot@@
@
text
@d1 1
a1 1
/* $XTermId: fontutils.c,v 1.360 2011/07/13 09:54:49 tom Exp $ */
d974 1
a974 1
	Bool derived;
d1013 1
a1013 1
			   : (xw->misc.fontWarnings + 1)),
@


1.14
log
@Update to xterm 270. Tested by ajacoutot@@, shadchin@@, krw@@ and jasper@@
@
text
@d1 1
a1 1
/* $XTermId: fontutils.c,v 1.358 2011/04/24 22:58:56 tom Exp $ */
d979 1
a979 1
	} else if (!is_double_width_font(fnts[fNorm].fs)) {
d1008 7
a1014 1
	    xtermOpenFont(xw, myfonts.f_wb, &fnts[fWBold], warn[fWBold], False);
d1021 13
a1033 4
		myfonts.f_wb = myfonts.f_w;
		warn[fWBold] = fwAlways;
		xtermCopyFontInfo(&fnts[fWBold], &fnts[fWide]);
		TRACE(("...cannot load wide-bold, use wide %s\n", NonNull(myfonts.f_w)));
d1269 8
d1398 1
a1398 1
	    MERGE_SUBFONT(xw->misc, subresourceRec, default_font.f_b);
d1400 2
a1401 2
	    MERGE_SUBFONT(xw->misc, subresourceRec, default_font.f_w);
	    MERGE_SUBFONT(xw->misc, subresourceRec, default_font.f_wb);
d2253 4
a2256 2
#define SCALE_X(n) n = (n * (((int) font_width) - 1)) / (BOX_WIDE-1)
#define SCALE_Y(n) n = (n * (((int) font_height) - 1)) / (BOX_HIGH-1)
d2543 4
a2546 4
	    SCALE_X(points[n].x);
	    SCALE_Y(points[n].y);
	    points[n].x += x;
	    points[n].y += y;
d2560 1
a2560 1
	SCALE_X(width);
d2574 1
a2574 1
	SCALE_X(width);
@


1.13
log
@Update to xterm 267. Tested by shadchin@@, jasper@@, ajacoutot@@.
@
text
@d1 1
a1 1
/* $XTermId: fontutils.c,v 1.353 2010/10/23 00:27:22 tom Exp $ */
d922 11
a932 1
    if (!xtermOpenFont(xw, myfonts.f_n, &fnts[fNorm], warn[fNorm], True))
d934 1
a1245 5
typedef struct {
    VTFontNames default_font;
    String menu_font_names[fontMenu_lastBuiltin + 1][fMAX];
} SubResourceRec;

d1260 40
d1301 4
d1313 2
a1314 2
    static Bool initialized = False;
    static SubResourceRec original, referenceRec, subresourceRec;
d1339 2
a1340 1
    if (!initialized) {
d1342 1
a1342 5
	initialized = True;
	TRACE(("xtermLoadVTFonts saving original\n"));
	original.default_font = xw->misc.default_font;
	COPY_MENU_FONTS(xw->screen, original);
    }
d1346 5
a1350 4
	xw->misc.default_font = original.default_font;
	COPY_MENU_FONTS(original, xw->screen);
	for (n = 0; n < XtNumber(original.menu_font_names); ++n)
	    screen->MenuFontName(n) = original.MenuFontName(n);
d1354 1
d1362 8
a1369 1
	if (memcmp(&referenceRec, &subresourceRec, sizeof(referenceRec))) {
d1447 1
a1447 1
	result = xtermLoadVTFonts(xw, "utf8Fonts", "Utf8Fonts");
@


1.12
log
@Update to xterm version 264, Tested at least by krw@@, jasper@@, ajacoutot@@.
@
text
@d1 1
a1 1
/* $XTermId: fontutils.c,v 1.350 2010/10/14 09:27:25 tom Exp $ */
d238 1
a238 1
    if (name == 0) {
d914 1
a914 1
	   NonNull(myfonts.field)));
d1241 1
a1241 1
	if (dst.name == 0) { \
d1252 1
a1252 1
		dst.menu_font_names[n][m] = src.menu_font_names[n][m]; \
d1297 1
a1297 1
    if (myName == 0 || *myName == 0) {
d1332 2
a1333 2
	    screen->MenuFontName(fontMenu_default) = xw->misc.default_font.f_n;
	    screen->menu_font_names[0][fBold] = xw->misc.default_font.f_b;
d1335 2
a1336 2
	    screen->menu_font_names[0][fWide] = xw->misc.default_font.f_w;
	    screen->menu_font_names[0][fWBold] = xw->misc.default_font.f_wb;
d3022 1
a3022 1
		myfonts.field = screen->menu_font_names[which][name]; \
@


1.11
log
@Update to xterm 261. Tested by krw@@, jcs@@.
@
text
@d1 1
a1 1
/* $XTermId: fontutils.c,v 1.344 2010/06/15 08:18:58 tom Exp $ */
d540 1
a540 1
same_font_name(char *pattern, char *match)
d580 1
a580 1
got_bold_font(Display * dpy, XFontStruct * fs, char *requested)
d710 1
a710 1
	free(data.f_n);
d720 1
a720 1
	char *last = screen->menu_font_names[fontnum][which];
d748 1
a748 1
    if (name != 0) {
d764 1
a764 1
		fprintf(stderr, "%s: cannot load font %s\n", ProgramName, name);
d777 1
a777 1
		TRACE(("xtermOpenFont: cannot load font %s\n", name));
d935 1
a935 1
	    TRACE(("...derived bold %s\n", NonNull(myfonts.f_b)));
d952 1
a952 1
	TRACE(("...cannot load bold font %s\n", NonNull(myfonts.f_b)));
d1237 1
a1237 1
    char *menu_font_names[fontMenu_lastBuiltin + 1][fMAX];
d1424 6
a1429 4
	char buf[80];
	char *myName = (char *) ((*param_count > 0) ? params[0] : empty);
	char *convert = (char *) ((*param_count > 1) ? params[1] : myName);
	char *myClass = (char *) MyStackAlloc(strlen(convert), buf);
d1433 1
d1455 2
a1456 1
	MyStackFree(myClass, buf);
d1750 1
a1750 1
char *
d1754 3
a1756 3
    char *result = (wideName
		    ? xw->misc.face_wide_name
		    : xw->misc.face_name);
d1758 1
a1758 1
    char *result = xw->misc.face_name;
d1802 3
d1814 2
a1815 3
    if (UsingRenderFont(xw)) {
	char *face_name = getFaceName(xw, False);
	int fontnum = screen->menu_font_number;
d1829 2
a1830 2
	    TRACE(("xtermComputeFontInfo norm(face %s, size %f)\n",
		   face_name,
d2039 1
a2039 1
    if (!UsingRenderFont(xw))
@


1.10
log
@Update to xterm 258. lightly tested by krw@@, thanks.
@
text
@d1 1
a1 1
/* $XTermId: fontutils.c,v 1.340 2010/04/18 16:48:46 tom Exp $ */
d171 1
a171 1
    if (xw->misc.render_font) {
d752 1
a752 1
		result = xtermCloseFont(xw, result);
d1807 1
a1807 1
    if (xw->misc.render_font && !IsIconWin(screen, win)) {
d2033 1
a2033 1
    if (!xw->misc.render_font || IsIconWin(screen, win))
d2385 3
a2387 4
		&& !IsXtermMissingChar(screen, n,
				       ((flags & BOLD)
					? &screen->fnts[fBold]
					: &screen->fnts[fNorm]))) {
d2840 1
a2840 1
		Bell(XkbBI_MinorError, 0);
d2865 1
a2865 1
		Bell(XkbBI_MinorError, 0);
d2957 1
a2957 1
		Bell(XkbBI_MinorError, 0);
d2963 1
a2963 1
		Bell(XkbBI_MinorError, 0);
d3001 1
a3001 1
	Bell(XkbBI_MinorError, 0);
d3055 1
a3055 1
		Bell(XkbBI_MinorError, 0);
d3059 1
a3059 1
	Bell(XkbBI_MinorError, 0);
@


1.9
log
@Update to xterm-255. Tested by stsp@@, oga@@.
@
text
@d1 1
a1 1
/* $XTermId: fontutils.c,v 1.336 2010/01/01 15:02:26 tom Exp $ */
d264 1
a264 1
    char *name;
d270 8
a277 5
    for (name = 0, i = 0, fp = fs->properties;
	 i < fs->n_properties;
	 i++, fp++)
	if (fp->name == fontatom)
	    name = XGetAtomName(dpy, fp->card32);
d706 1
a706 1
xtermFontName(char *normal)
d709 2
d712 1
a712 1
    data.f_n = normal;
d1206 1
a1206 1
	    free(screen->MenuFontName(fontnum));
d1425 2
a1426 2
	char *myName = (*param_count > 0) ? params[0] : empty;
	char *convert = (*param_count > 1) ? params[1] : myName;
d1756 1
a1756 1
    if (!IsEmpty(result) && !strncmp(result, "xft:", 4))
d1843 2
a1844 2
		    int num = screen->menu_font_sizes[fontnum];
		    int den = screen->menu_font_sizes[0];
d1848 1
a1848 1
		    ratio = mySquareRoot((1.0 * num) / den);
d1851 1
a1851 1
		    TRACE(("scaled using %3d/%d = %.2f -> %f\n",
d2697 1
a2697 1
	    int first = screen->menu_font_sizes[0];
@


1.8
log
@Update to xterm 250
@
text
@d1 1
a1 1
/* $XTermId: fontutils.c,v 1.319 2009/10/12 22:29:42 tom Exp $ */
d5 1
a5 1
Copyright 1998-2008,2009 by Thomas E. Dickey
d45 1
d752 1
a752 1
	} else if (strcmp(name, DEFFONT)) {
d760 11
d1721 2
a1722 1
	fprintf(stderr, "Selected font has no non-zero %s for ISO-8859-1 encoding\n", tag);
d1727 54
d1803 1
d1814 1
a1814 1
	if (norm == 0 && xw->misc.face_name) {
d1819 1
a1819 1
		   xw->misc.face_name,
d1895 2
a1896 2
	    if ((pat = XftNameParse(xw->misc.face_name)) != 0) {
#define OPEN_XFT(tag) xtermOpenXft(xw, xw->misc.face_name, pat, tag)
d1910 1
a1910 1
			&& (pat = XftNameParse(xw->misc.face_name)) != 0) {
a1942 3
		char *face_name = (xw->misc.face_wide_name
				   ? xw->misc.face_wide_name
				   : xw->misc.face_name);
d1951 1
d1953 1
a1953 1
		       face_name,
d1961 1
a1961 1
		if ((pat = XftNameParse(face_name)) != 0) {
d2652 3
a2654 3
	    screen->menu_font_sizes[fontnum] = FontSize(fnt.fs);
	    TRACE(("menu_font_sizes[%d] = %ld\n", fontnum,
		   screen->menu_font_sizes[fontnum]));
d2826 1
a2826 1
    TRACE(("Handle larger-vt-font for %p\n", w));
d2851 1
a2851 1
    TRACE(("Handle smaller-vt-font for %p\n", w));
a3006 1
	    return;
d3018 10
d3037 10
a3046 1
		return;
d3051 1
d3054 2
a3056 2

    Bell(XkbBI_MinorError, 0);
@


1.7
log
@update to xterm 246. Has been in snapshots for some time.
@
text
@d1 1
a1 1
/* $XTermId: fontutils.c,v 1.307 2009/08/07 23:22:32 tom Exp $ */
d161 31
d376 1
a376 1
append_fontname_str(char **result, char *value)
d408 1
a408 1
		 char *use_weight,
d410 1
a410 1
		 char *use_encoding)
d470 1
a470 1
    char *weight;
d1124 5
a1128 1
    screen->fnt_prop = proportional;
d1244 1
a1244 1
xtermLoadVTFonts(XtermWidget xw, char *myName, char *myClass)
d1331 1
a1331 1
isWideFont(XFontStruct * fp, char *tag, Bool nullOk)
d1476 81
d1567 7
d1575 2
d1581 1
a1581 1
	    if (width < extents.width)
d1583 1
d1705 9
d1943 14
d1965 1
a1965 1
	if (is_double_width_font(font)) {
d1992 3
@


1.6
log
@Update to xterm 242. Tested by jsg@@.
@
text
@d1 1
a1 1
/* $XTermId: fontutils.c,v 1.300 2009/02/13 01:45:01 tom Exp $ */
d327 1
a327 1
alloca_fontname(char **result, unsigned next)
d329 3
a331 3
    unsigned last = (*result != 0) ? strlen(*result) : 0;
    unsigned have = (*result != 0) ? ALLOCHUNK(last) : 0;
    unsigned want = last + next + 2;
d1123 1
a1123 1
	    if (xtermMissingChar(xw, n, fnts[fNorm].fs)) {
d1128 1
a1128 1
	    if (xtermMissingChar(xw, n, fnts[fBold].fs)) {
d1427 2
a1428 2
	    dst[fontnum] = src;\
	    TRACE(("%s[%d] = %d (%d,%d) by %d\n",\
d1434 3
a1436 1
		src->max_advance_width));\
d1440 24
d1602 3
a1604 3
	XftFont *norm = screen->renderFontNorm[fontnum];
	XftFont *bold = screen->renderFontBold[fontnum];
	XftFont *ital = screen->renderFontItal[fontnum];
d1606 3
a1608 3
	XftFont *wnorm = screen->renderWideNorm[fontnum];
	XftFont *wbold = screen->renderWideBold[fontnum];
	XftFont *wital = screen->renderWideItal[fontnum];
d1744 6
d1765 3
d1894 1
a1894 1
xtermMissingChar(XtermWidget xw, unsigned ch, XFontStruct * font)
d1896 3
a1898 6
    TScreen *screen = TScreenOf(xw);

    if (font != 0
	&& font->per_char != 0
	&& !font->all_chars_exist) {
	static XCharStruct dft, *tmp = &dft, *pc = 0;
d1900 1
a1900 1
	if (font->max_byte1 == 0) {
d1902 4
a1905 4
	    if (ch > 255) {
		TRACE(("xtermMissingChar %#04x (row)\n", ch));
		return True;
	    }
d1907 2
a1908 2
	    CI_GET_CHAR_INFO_1D(font, E2A(ch), tmp, pc);
	}
d1910 3
a1912 3
	else {
	    CI_GET_CHAR_INFO_2D(font, HI_BYTE(ch), LO_BYTE(ch), tmp, pc);
	}
d1915 2
a1916 2
	if (!pc)
	    return False;	/* Urgh! */
d1919 3
a1921 4
	if (CI_NONEXISTCHAR(pc)) {
	    TRACE(("xtermMissingChar %#04x (!exists)\n", ch));
	    return True;
	}
d1923 2
a1924 4
    if (xtermIsDecGraphic(ch)
	&& screen->force_box_chars) {
	TRACE(("xtermMissingChar %#04x (forced off)\n", ch));
	return True;
d1926 1
a1926 1
    return False;
d2162 4
a2165 4
		&& !xtermMissingChar(xw, n,
				     ((flags & BOLD)
				      ? screen->fnts[fBold].fs
				      : screen->fnts[fNorm].fs))) {
@


1.5
log
@xterm 238. includes fix for CVE-2008-2383.
@
text
@d1 1
a1 1
/* $XTermId: fontutils.c,v 1.278 2008/12/30 17:32:06 tom Exp $ */
d5 1
a5 1
Copyright 1998-2007,2008 by Thomas E. Dickey
d201 15
d255 1
a255 4
	if (strlen(name) < MAX_FONTNAME - 1) {
	    strcpy(result, name);
	} else {
	    TRACE(("fontname too large: %s\n", name));
d257 1
a257 1
	}
d507 15
a521 9
    while (*pattern && *match) {
	if (*pattern == *match) {
	    pattern++;
	    match++;
	} else if (*pattern == '*' || *match == '*') {
	    if (same_font_name(pattern + 1, match)) {
		return True;
	    } else if (same_font_name(pattern, match + 1)) {
		return True;
d523 4
a526 1
		return False;
a527 5
	} else {
	    int p = x_toupper(*pattern++);
	    int m = x_toupper(*match++);
	    if (p != m)
		return False;
d529 1
d531 1
a531 1
    return (*pattern == *match);	/* both should be NUL */
d565 1
d571 1
a571 1
    return xw->screen.free_bold_box
d702 5
a706 1
xtermOpenFont(XtermWidget xw, char *name, XTermFonts * result)
d711 23
a733 8
    if (name != 0
	&& (result->fs = XLoadQueryFont(screen->display, name)) != 0) {
	code = True;
	if (EmptyFont(result->fs)) {
	    result = xtermCloseFont(xw, result);
	    code = False;
	} else {
	    result->fn = x_strdup(name);
d740 1
a740 1
 * Close the font and Free the font info
d810 1
a810 1
    TScreen *screen = &(xw->screen);
d820 3
a822 1
    Bool proportional = False;
d829 1
a829 1
    if (myfonts.f_n == 0)
d832 21
d862 7
a868 2
    TRACE(("xtermLoadFont #%d normal %s\n", fontnum, NonNull(myfonts.f_n)));
    TRACE(("xtermLoadFont #%d bold   %s\n", fontnum, NonNull(myfonts.f_b)));
d870 2
a871 2
    TRACE(("xtermLoadFont #%d wide   %s\n", fontnum, NonNull(myfonts.f_w)));
    TRACE(("xtermLoadFont #%d w/bold %s\n", fontnum, NonNull(myfonts.f_wb)));
d874 1
a874 1
    if (!xtermOpenFont(xw, myfonts.f_n, &fnts[fNorm]))
d878 2
a879 1
    if (myfonts.f_b == 0) {
d883 1
a883 1
	    if (!xtermOpenFont(xw, myfonts.f_b, &fnts[fBold])) {
d885 1
a885 1
		(void) xtermOpenFont(xw, myfonts.f_b, &fnts[fBold]);
d901 1
a901 1
    } else if (!xtermOpenFont(xw, myfonts.f_b, &fnts[fBold])) {
d903 1
d918 1
a918 1
	if (myfonts.f_w != 0) {
d924 1
d930 2
a931 2
	if (myfonts.f_w) {
	    (void) xtermOpenFont(xw, myfonts.f_w, &fnts[fWide]);
d934 1
d938 1
a938 1
	if (myfonts.f_wb == 0) {
d942 1
d947 1
a947 1
	if (myfonts.f_wb) {
d949 1
a949 1
	    (void) xtermOpenFont(xw, myfonts.f_wb, &fnts[fWBold]);
d957 1
d968 1
d972 1
d1209 1
a1209 1
xtermLoadVTFonts(XtermWidget w, char *myName, char *myClass)
d1235 1
d1241 2
a1242 2
	original.default_font = w->misc.default_font;
	COPY_MENU_FONTS(w->screen, original);
d1247 2
a1248 2
	w->misc.default_font = original.default_font;
	COPY_MENU_FONTS(original, w->screen);
d1250 1
a1250 1
	    w->screen.MenuFontName(n) = original.MenuFontName(n);
d1255 1
a1255 1
	XtGetSubresources((Widget) w, (XtPointer) &subresourceRec,
d1266 2
a1267 2
	    MERGE_SUBFONT(w->misc, subresourceRec, default_font.f_n);
	    MERGE_SUBFONT(w->misc, subresourceRec, default_font.f_b);
d1269 2
a1270 2
	    MERGE_SUBFONT(w->misc, subresourceRec, default_font.f_w);
	    MERGE_SUBFONT(w->misc, subresourceRec, default_font.f_wb);
d1273 1
a1273 1
		MERGE_SUBFONT(w->screen, subresourceRec, MenuFontName(n));
d1278 4
a1281 4
	    w->misc.default_font = subresourceRec.default_font;
	    COPY_MENU_FONTS(subresourceRec, w->screen);
	    w->screen.MenuFontName(fontMenu_default) = w->misc.default_font.f_n;
	    w->screen.menu_font_names[0][fBold] = w->misc.default_font.f_b;
d1283 2
a1284 2
	    w->screen.menu_font_names[0][fWide] = w->misc.default_font.f_w;
	    w->screen.menu_font_names[0][fWBold] = w->misc.default_font.f_wb;
d1323 1
a1323 1
    TScreen *screen = &(xw->screen);
d1350 1
a1350 1
xtermLoadDefaultFonts(XtermWidget w)
d1353 1
a1353 1
    result = xtermLoadVTFonts(w, NULL, NULL);
d1368 4
a1371 2
    if (IsXtermWidget(w)) {
	XtermWidget xw = (XtermWidget) w;
d1389 1
a1389 1
	    int font_number = xw->screen.menu_font_number;
d1393 1
a1393 1
		xw->screen.menu_font_sizes[n] = 0;
d1439 1
a1439 1
xtermOpenXft(Display * dpy, XftPattern * pat, const char *tag GCC_UNUSED)
d1441 2
d1456 5
d1464 5
d1562 1
a1562 1
    TScreen *screen = &(xw->screen);
a1574 1
	Display *dpy = screen->display;
d1645 1
a1645 1
		xw->misc.face_size[fontnum] = face_size;
d1667 1
d1671 1
a1671 1
		norm = xtermOpenXft(dpy, pat, "normal");
d1677 1
a1677 1
		    bold = xtermOpenXft(dpy, pat, "bold");
d1686 1
a1686 1
			ital = xtermOpenXft(dpy, pat, "italic");
d1689 1
d1729 1
d1734 1
a1734 1
		    wnorm = xtermOpenXft(dpy, pat, "wide");
d1741 1
a1741 1
			wbold = xtermOpenXft(dpy, pat, "wide-bold");
d1750 1
a1750 1
			    wital = xtermOpenXft(dpy, pat, "wide-italic");
d1753 1
d1794 2
a1795 2
    win->fullwidth = width;
    win->fullheight = height;
d1814 2
a1815 2
    screen->fnt_wide = (font->max_bounds.width);
    screen->fnt_high = (font->ascent + font->descent);
d1825 1
a1825 1
    TScreen *screen = &(xw->screen);
d1861 2
d1893 1
a1893 1
	&& xw->screen.force_box_chars) {
d1916 2
a1917 2
#define SCALE_X(n) n = (n * (font_width-1)) / (BOX_WIDE-1)
#define SCALE_Y(n) n = (n * (font_height-1)) / (BOX_HIGH-1)
d1934 1
a1934 1
    TScreen *screen = &(xw->screen);
d2113 2
a2114 2
    unsigned font_width = ((flags & DOUBLEWFONT) ? 2 : 1) * screen->fnt_wide;
    unsigned font_height = ((flags & DOUBLEHFONT) ? 2 : 1) * screen->fnt_high;
d2117 1
a2117 1
	font_width *= cells;
d2217 2
a2218 2
	int x_coord = MID_WIDE - (width / 2);
	int y_coord = MID_HIGH - width;
d2231 2
a2232 2
	int x_coord = MID_WIDE - (width / 3);
	int y_coord = MID_HIGH - (width / 3);
d2245 1
a2245 1
	unsigned coord[4];
d2282 2
a2283 1
	if (!XftGlyphExists(xw->screen.display, font, wc)) {
d2404 1
a2404 1
	if (xtermOpenFont(xw, screen->MenuFontName(fontnum), &fnt)) {
d2442 50
d2577 1
a2577 2
    if (IsXtermWidget(w)) {
	XtermWidget xw = (XtermWidget) w;
d2579 2
d2582 1
a2582 1
	    TScreen *screen = &xw->screen;
d2602 1
a2602 2
    if (IsXtermWidget(w)) {
	XtermWidget xw = (XtermWidget) w;
d2604 2
d2607 1
a2607 1
	    TScreen *screen = &xw->screen;
d2672 3
a2674 1
    if (IsXtermWidget(w)) {
d2733 1
a2733 1
	SetVTFont((XtermWidget) w, fontnum, True, &fonts);
d2743 1
a2743 1
    TScreen *screen = &xw->screen;
@


1.4
log
@xterm 237. tested by krw@@ oga@@ and others.
@
text
@d1 1
a1 1
/* $XTermId: fontutils.c,v 1.275 2008/09/14 22:21:14 tom Exp $ */
d122 1
a122 1
static Bool
d508 2
a509 2
	    int p = char2lower(*pattern++);
	    int m = char2lower(*match++);
d1304 2
a1305 3
	if (*param_count == 1
	    && islower(CharOf(myClass[0])))
	    myClass[0] = toupper(CharOf(myClass[0]));
d1342 4
a1345 4
    (vp++)->x = fw;
    (vp++)->y = hh;
    (vp++)->x = -fw;
    vp->y = -hh;
d2152 1
a2152 1
	int coord[4];
@


1.3
log
@xterm-236. Tested by form@@ and simon@@.
@
text
@d1 1
a1 1
/* $XTermId: fontutils.c,v 1.272 2008/04/17 23:23:37 tom Exp $ */
d1338 3
d1343 5
a1347 4
    (vp++)->x = FontWidth(screen) - 1;
    (vp++)->y = FontHeight(screen) - 1;
    (vp++)->x = -(FontWidth(screen) - 1);
    vp->y = -(FontHeight(screen) - 1);
d1675 1
d2333 21
d2364 1
d2366 20
a2385 17
	lookupFontSizes(xw);
	if (relative != 0) {
	    for (n = 0; n < NMENUFONTS; ++n) {
		if (screen->menu_font_sizes[n] > 0 &&
		    screen->menu_font_sizes[n] != screen->menu_font_sizes[old]) {
		    int cmp_0 = ((screen->menu_font_sizes[n] >
				  screen->menu_font_sizes[old])
				 ? relative
				 : -relative);
		    int cmp_m = ((m < 0)
				 ? 1
				 : ((screen->menu_font_sizes[n] <
				     screen->menu_font_sizes[m])
				    ? relative
				    : -relative));
		    if (cmp_0 > 0 && cmp_m > 0) {
			m = n;
d2389 25
a2413 5
	    if (m >= 0) {
		if (relative > 1)
		    m = lookupRelativeFontSize(xw, m, relative - 1);
		else if (relative < -1)
		    m = lookupRelativeFontSize(xw, m, relative + 1);
d2415 7
@


1.2
log
@update to xterm 234. tested by merdely@@, 'looks ok' deraadt@@.
@
text
@d1 1
a1 1
/* $XTermId: fontutils.c,v 1.270 2008/02/29 00:25:16 Andrea.Odetti Exp $ */
d1207 5
d1748 1
a1748 2
	if (screen->scrollWidget)
	    ResizeScrollBar(xw);
@


1.1
log
@Initial revision
@
text
@d1 1
a1 5
/* $XTermId: fontutils.c,v 1.208 2006/07/23 20:31:30 tom Exp $ */

/*
 * $XFree86: xc/programs/xterm/fontutils.c,v 1.60 2006/04/30 21:55:39 dickey Exp $
 */
d5 1
a5 1
Copyright 1998-2005,2006 by Thomas E. Dickey
d118 1
a118 1
static void lookupOneFontSize(TScreen *, int);
d432 1
a432 1
    props = get_font_name_props(screen->display, screen->fnts[fNorm], 0);
d601 1
a601 1
#define HALF_WIDTH_CHAR1  0x0031	/* 'l' */
d683 2
a684 2
XFontStruct *
xtermOpenFont(TScreen * screen, char *name)
d686 2
a687 1
    XFontStruct *nfs = 0;
d690 7
a696 3
	&& (nfs = XLoadQueryFont(screen->display, name)) != 0) {
	if (EmptyFont(nfs)) {
	    nfs = xtermCloseFont(screen, nfs);
d699 1
a699 1
    return nfs;
d702 5
a706 2
XFontStruct *
xtermCloseFont(TScreen * screen, XFontStruct * fnt)
d708 6
a713 2
    if (fnt != 0) {
	XFreeFont(screen->display, fnt);
d722 1
a722 1
xtermCloseFonts(TScreen * screen, XFontStruct ** fnts)
d727 6
a732 2
	if (fnts[j] != 0) {
	    xtermCloseFont(screen, fnts[j]);
d734 2
a735 2
		if (fnts[j] == fnts[k])
		    fnts[k] = 0;
a736 1
	    fnts[j] = 0;
d741 26
d774 1
a776 1
    /* FIXME: use XFreeFontInfo */
d778 1
a778 7
    XFontStruct *fnts[fMAX];
    XGCValues xgcv;
    unsigned long mask;
    GC new_normalGC = NULL;
    GC new_normalboldGC = NULL;
    GC new_reverseGC = NULL;
    GC new_reverseboldGC = NULL;
d799 3
d809 1
a809 1
    if (!(fnts[fNorm] = xtermOpenFont(screen, myfonts.f_n)))
d814 1
a814 1
	fp = get_font_name_props(screen->display, fnts[fNorm], normal);
d817 1
a817 1
	    if ((fnts[fBold] = xtermOpenFont(screen, myfonts.f_b)) == 0) {
d819 1
a819 1
		fnts[fBold] = xtermOpenFont(screen, myfonts.f_b);
d823 2
a824 2
	if (fp == 0 || fnts[fBold] == 0) {
	    fnts[fBold] = fnts[fNorm];
d826 2
a827 2
	} else if (same_font_size(xw, fnts[fNorm], fnts[fBold])
		   && got_bold_font(screen->display, fnts[fBold], myfonts.f_b)) {
d831 1
a831 1
	    xtermCloseFont(screen, fnts[fBold]);
d835 2
a836 2
    } else if ((fnts[fBold] = xtermOpenFont(screen, myfonts.f_b)) == 0) {
	fnts[fBold] = fnts[fNorm];
d853 2
a854 2
	} else if (!is_double_width_font(fnts[fNorm])) {
	    fp = get_font_name_props(screen->display, fnts[fNorm], normal);
d863 1
a863 1
	    fnts[fWide] = xtermOpenFont(screen, myfonts.f_w);
d865 1
a865 1
	    fnts[fWide] = fnts[fNorm];
d870 1
a870 1
	    fp = get_font_name_props(screen->display, fnts[fBold], bold);
d879 1
a879 1
	    fnts[fWBold] = xtermOpenFont(screen, myfonts.f_wb);
d882 2
a883 2
		&& !compatibleWideCounts(fnts[fWide], fnts[fWBold])) {
		fnts[fWBold] = xtermCloseFont(screen, fnts[fWBold]);
d885 1
a885 2
	    if (fnts[fWBold] == 0) {
		free(myfonts.f_wb);
d887 1
a887 1
		fnts[fWBold] = fnts[fWide];
d890 3
a892 1
		TRACE(("...derived wide/bold %s\n", NonNull(myfonts.f_wb)));
d895 2
a896 2
	} else if (is_double_width_font(fnts[fBold])) {
	    fnts[fWBold] = fnts[fBold];
d899 1
a899 1
	    fnts[fWBold] = fnts[fWide];
d903 1
a903 1
	if (EmptyFont(fnts[fWBold]))
d914 1
a914 1
    if (EmptyFont(fnts[fBold]))
d917 2
a918 2
    if (!same_font_size(xw, fnts[fNorm], fnts[fBold])
	&& (is_fixed_font(fnts[fNorm]) && is_fixed_font(fnts[fBold]))) {
d920 2
a921 2
	xtermCloseFont(screen, fnts[fBold]);
	fnts[fBold] = fnts[fNorm];
d925 4
a928 4
	if (fnts[fWide] != 0
	    && fnts[fWBold] != 0
	    && !same_font_size(xw, fnts[fWide], fnts[fWBold])
	    && (is_fixed_font(fnts[fWide]) && is_fixed_font(fnts[fWBold]))) {
d930 2
a931 2
	    xtermCloseFont(screen, fnts[fWBold]);
	    fnts[fWBold] = fnts[fWide];
d939 3
a941 3
    if (!is_fixed_font(fnts[fNorm])
	|| !is_fixed_font(fnts[fBold])
	|| fnts[fNorm]->max_bounds.width != fnts[fBold]->max_bounds.width) {
d943 4
a946 4
	       fnts[fNorm]->min_bounds.width,
	       fnts[fNorm]->max_bounds.width,
	       fnts[fBold]->min_bounds.width,
	       fnts[fBold]->max_bounds.width));
d951 5
a955 5
	if (fnts[fWide] != 0
	    && fnts[fWBold] != 0
	    && (!is_fixed_font(fnts[fWide])
		|| !is_fixed_font(fnts[fWBold])
		|| fnts[fWide]->max_bounds.width != fnts[fWBold]->max_bounds.width)) {
d957 4
a960 4
		   fnts[fWide]->min_bounds.width,
		   fnts[fWide]->max_bounds.width,
		   fnts[fWBold]->min_bounds.width,
		   fnts[fWBold]->max_bounds.width));
d968 15
a982 2
    mask = (GCFont | GCForeground | GCBackground | GCGraphicsExposures |
	    GCFunction);
d987 10
a996 5
    xgcv.font = fnts[fNorm]->fid;
    xgcv.foreground = new_normal;
    xgcv.background = new_revers;
    xgcv.graphics_exposures = True;	/* default */
    xgcv.function = GXcopy;
d998 2
a999 3
    new_normalGC = XtGetGC((Widget) xw, mask, &xgcv);
    if (!new_normalGC)
	goto bad;
d1001 13
a1013 8
    if (fnts[fNorm] == fnts[fBold]) {	/* there is no bold font */
	new_normalboldGC = new_normalGC;
    } else {
	xgcv.font = fnts[fBold]->fid;
	new_normalboldGC = XtGetGC((Widget) xw, mask, &xgcv);
	if (!new_normalboldGC)
	    goto bad;
    }
d1015 4
a1018 35
    xgcv.font = fnts[fNorm]->fid;
    xgcv.foreground = new_revers;
    xgcv.background = new_normal;
    new_reverseGC = XtGetGC((Widget) xw, mask, &xgcv);
    if (!new_reverseGC)
	goto bad;

    if (fnts[fNorm] == fnts[fBold]) {	/* there is no bold font */
	new_reverseboldGC = new_reverseGC;
    } else {
	xgcv.font = fnts[fBold]->fid;
	new_reverseboldGC = XtGetGC((Widget) xw, mask, &xgcv);
	if (!new_reverseboldGC)
	    goto bad;
    }

    if (NormalGC(screen) != NormalBoldGC(screen))
	XtReleaseGC((Widget) xw, NormalBoldGC(screen));
    XtReleaseGC((Widget) xw, NormalGC(screen));

    if (ReverseGC(screen) != ReverseBoldGC(screen))
	XtReleaseGC((Widget) xw, ReverseBoldGC(screen));
    XtReleaseGC((Widget) xw, ReverseGC(screen));

    NormalGC(screen) = new_normalGC;
    NormalBoldGC(screen) = new_normalboldGC;
    ReverseGC(screen) = new_reverseGC;
    ReverseBoldGC(screen) = new_reverseboldGC;

    /*
     * If we're switching fonts, free the old ones.  Otherwise we'll leak
     * the memory that is associated with the old fonts.  The
     * XLoadQueryFont call allocates a new XFontStruct.
     */
    xtermCloseFonts(screen, screen->fnts);
a1019 8
    screen->fnts[fNorm] = fnts[fNorm];
    screen->fnts[fBold] = fnts[fBold];
#if OPT_WIDE_CHARS
    screen->fnts[fWide] = fnts[fWide];
    if (fnts[fWBold] == NULL)
	fnts[fWBold] = fnts[fWide];
    screen->fnts[fWBold] = fnts[fWBold];
#endif
d1050 1
a1050 1
	    if (xtermMissingChar(xw, n, fnts[fNorm])) {
d1055 1
a1055 1
	    if (xtermMissingChar(xw, n, fnts[fBold])) {
d1066 7
a1072 2
    screen->enbolden = screen->bold_mode
	&& ((fnts[fNorm] == fnts[fBold]) || same_font_name(normal, myfonts.f_b));
d1088 1
a1088 1
	screen->menu_font_sizes[fontnum] = FontSize(fnts[fNorm]);
d1093 1
d1099 1
a1099 8
    if (new_normalGC)
	XtReleaseGC((Widget) xw, new_normalGC);
    if (new_normalboldGC && new_normalGC != new_normalboldGC)
	XtReleaseGC((Widget) xw, new_normalboldGC);
    if (new_reverseGC)
	XtReleaseGC((Widget) xw, new_reverseGC);
    if (new_reverseboldGC && new_reverseGC != new_reverseboldGC)
	XtReleaseGC((Widget) xw, new_reverseboldGC);
d1101 2
a1102 1
    xtermCloseFonts(screen, fnts);
d1125 1
a1125 1
	for (n = fontMenu_fontdefault; n <= fontMenu_lastBuiltin; ++n) { \
d1206 1
a1206 1
	    w->screen.MenuFontName(fontMenu_fontdefault) = w->misc.default_font.f_n;
d1222 1
a1222 1
    if (fp != 0) {
d1247 3
a1249 3
    if (EmptyFont(screen->fnts[fWide])) {
	result = (isWideFont(screen->fnts[fNorm], "normal", nullOk)
		  && isWideFont(screen->fnts[fBold], "bold", nullOk));
d1251 2
a1252 2
	result = (isWideFont(screen->fnts[fWide], "wide", nullOk)
		  && isWideFont(screen->fnts[fWBold], "wide-bold", nullOk));
d1254 2
a1255 2
	    result = (isWideFont(screen->fnts[fNorm], "normal", nullOk)
		      && isWideFont(screen->fnts[fBold], "bold", nullOk));
d1289 13
a1301 6
    XtermWidget xw = (XtermWidget) w;
    char buf[80];
    char *myName = (*param_count > 0) ? params[0] : empty;
    char *convert = (*param_count > 1) ? params[1] : myName;
    char *myClass = (char *) MyStackAlloc(strlen(convert), buf);
    int n;
d1303 16
a1318 5
    TRACE(("HandleLoadVTFonts(%d)\n", *param_count));
    strcpy(myClass, convert);
    if (*param_count == 1
	&& islower(CharOf(myClass[0])))
	myClass[0] = toupper(CharOf(myClass[0]));
d1320 1
a1320 15
    if (xtermLoadVTFonts(xw, myName, myClass)) {
	/*
	 * When switching fonts, try to preserve the font-menu selection, since
	 * it is less surprising to do that (if the font-switching can be
	 * undone) than to switch to "Default".
	 */
	int font_number = xw->screen.menu_font_number;
	if (font_number > fontMenu_lastBuiltin)
	    font_number = fontMenu_lastBuiltin;
	for (n = 0; n < NMENUFONTS; ++n)
	    xw->screen.menu_font_sizes[n] = 0;
	SetVTFont(xw, font_number, True,
		  ((font_number == fontMenu_fontdefault)
		   ? &(xw->misc.default_font)
		   : NULL));
a1321 2

    MyStackFree(myClass, buf);
d1379 78
d1462 1
a1462 1
		     struct _vtwin *win,
d1492 1
a1492 1
	    double face_size = xw->misc.face_size;
d1496 1
a1496 1
		   xw->misc.face_size));
d1498 1
d1500 53
d1554 3
a1556 6
	     * If the user is switching font-sizes, make it follow the same
	     * ratios to the default as the fixed fonts would, for easy
	     * comparison.  There will be some differences since the fixed
	     * fonts have a variety of height/width ratios, but this is simpler
	     * than adding another resource value - and as noted above, the
	     * data for the fixed fonts are available.
d1558 12
a1569 8
	    lookupOneFontSize(screen, fontnum);
	    if (fontnum != fontMenu_fontdefault) {
		int num = screen->menu_font_sizes[fontnum];
		int den = screen->menu_font_sizes[0];
		face_size = (1.0 * face_size * num) / den;
		TRACE(("scaled using %d/%d -> %f\n", num, den, face_size));
	    }
#endif
d1573 1
a1573 3
				XFT_FAMILY, XftTypeString, "mono",
				XFT_SIZE, XftTypeDouble, face_size,
				XFT_SPACING, XftTypeInteger, XFT_MONO,
d1579 1
a1579 2
				    XFT_WEIGHT, XftTypeInteger, XFT_WEIGHT_BOLD,
				    XFT_CHAR_WIDTH, XftTypeInteger, norm->max_advance_width,
d1584 2
a1585 1
		    if (screen->italicULMode) {
d1587 2
a1588 2
					XFT_SLANT, XftTypeInteger, XFT_SLANT_ITALIC,
					XFT_CHAR_WIDTH, XftTypeInteger, norm->max_advance_width,
d1626 6
a1631 1
		if ((pat = XftNameParse(xw->misc.face_name)) != 0) {
d1633 1
a1633 3
				    XFT_FAMILY, XftTypeString, face_name,
				    XFT_SIZE, XftTypeDouble, face_size,
				    XFT_SPACING, XftTypeInteger, XFT_MONO,
d1640 2
a1641 5
					XFT_FAMILY, XftTypeString, face_name,
					XFT_SIZE, XftTypeDouble, face_size,
					XFT_SPACING, XftTypeInteger, XFT_MONO,
					XFT_CHAR_WIDTH, XftTypeInteger, char_width,
					XFT_WEIGHT, XftTypeInteger, XFT_WEIGHT_BOLD,
d1645 3
a1647 1
			if (screen->italicULMode) {
d1649 2
a1650 5
					    XFT_FAMILY, XftTypeString, face_name,
					    XFT_SIZE, XftTypeDouble, face_size,
					    XFT_SPACING, XftTypeInteger, XFT_MONO,
					    XFT_CHAR_WIDTH, XftTypeInteger, char_width,
					    XFT_SLANT, XftTypeInteger, XFT_SLANT_ITALIC,
d1654 1
d1663 1
a1663 1
#endif
d1668 1
d1670 3
a1672 8
	    win->f_width = norm->max_advance_width;
	    win->f_height = norm->height;
	    win->f_ascent = norm->ascent;
	    win->f_descent = norm->descent;
	    if (win->f_height < win->f_ascent + win->f_descent)
		win->f_height = win->f_ascent + win->f_descent;
	    if (is_double_width_font_xft(screen->display, norm))
		win->f_width >>= 1;
d1675 3
d1679 1
a1679 1
#endif
d1728 1
a1728 1
    struct _vtwin *win = &(screen->fullVwin);
d1734 2
a1735 2
    xtermComputeFontInfo(xw, win, screen->fnts[fNorm], scrollbar_width);
    xtermSaveFontInfo(screen, screen->fnts[fNorm]);
d1739 1
a1739 1
	    XClearWindow(screen->display, VWindow(screen));
d1778 1
a1778 1
	    CI_GET_CHAR_INFO_2D(font, (ch >> 8), (ch & 0xff), tmp, pc);
d1791 1
a1791 1
    if (ch < 32
d1830 2
a1831 1
		 int y)
d1836 1
a1836 1
	SEG(  0,	    0,		  0,	      5*MID_HIGH/6),	/* H */
d1838 1
a1838 1
	SEG(  0,	  5*MID_HIGH/12,6*BOX_WIDE/10,5*MID_HIGH/12),
d1843 3
a1845 3
	SEG(  0,	    0,		6*BOX_WIDE/10,	0),		/* F */
	SEG(  0,	  5*MID_HIGH/12,6*CHR_WIDE/12,5*MID_HIGH/12),
	SEG(  0,	    0,		0*BOX_WIDE/3, 5*MID_HIGH/6),
d1851 2
a1852 2
	SEG(  0,	    0,		  0,	      5*MID_HIGH/6),	/* L */
	SEG(  0,	  5*MID_HIGH/6,	6*BOX_WIDE/10,5*MID_HIGH/6),
d1858 2
a1859 2
	SEG(  0,	  5*MID_HIGH/6,	  0,		0),		/* N */
	SEG(  0,	    0,		5*BOX_WIDE/6, 5*MID_HIGH/6),
d1865 1
a1865 1
	SEG(  0,	    0,		5*BOX_WIDE/12,5*MID_HIGH/6),	/* V */
a2007 2
    XGCValues values;
    unsigned long mask;
d2009 2
d2015 3
d2032 4
a2035 3
		&& !xtermMissingChar(xw, n, (flags & BOLD)
				     ? screen->fnts[fBold]
				     : screen->fnts[fNorm])) {
d2050 4
a2053 17
    memset(&values, 0, sizeof(values));
    if (!XGetGCValues(screen->display, gc, GCBackground, &values))
	return;

    mask = GCForeground;
    if (ch == 2) {
	values.tile =
	    XmuCreateStippledPixmap(XtScreen((Widget) xw),
				    getXtermForeground(xw, xw->flags, xw->cur_foreground),
				    getXtermBackground(xw, xw->flags, xw->cur_background),
				    xw->core.depth);
	if (values.stipple != XtUnspecifiedPixmap) {
	    mask |= GCBackground | GCTile | GCFillStyle;
	    values.fill_style = FillTiled;
	} else {
	    ch = (unsigned) (~0);	/* make this not match anything */
	}
d2055 3
a2057 1
	values.foreground = values.background;
d2059 1
a2059 4
    gc2 = XCreateGC(screen->display,
		    VWindow(screen),
		    mask,
		    &values);
d2067 5
a2071 1
    XCopyGC(screen->display, gc, (1 << GCLastBit) - 1, gc2);
d2091 1
a2091 1
	points[1].x = 3 * BOX_WIDE / 4;
d2097 1
a2097 1
	points[3].x = BOX_WIDE / 4;
a2113 2
    } else if (ch == 2) {	/* box */
	XmuReleaseStippledPixmap(XtScreen((Widget) xw), values.tile);
d2137 1
a2137 1
	XFillArc(screen->display,
a2165 2

    XFreeGC(screen->display, gc2);
d2168 1
a2168 1
#if OPT_RENDERFONT && OPT_WIDE_CHARS
d2181 7
a2187 4
	unsigned check = XftCharIndex(xw->screen.display, font, wc);

	if (check == 0) {
	    TRACE(("missingXft %d (%d)\n", wc, ucs2dec(wc)));
a2192 37

/*
 * Check if the character corresponds to one of xterm's internal codes for
 * line-drawing characters.  That is only a subset of the 1-31 codes used for
 * graphic characters.  We want to know specifically about the line-drawing
 * characters because the fonts used by Xft do not always give useful glyphs
 * for line-drawing, and there is no reliable way to detect this.
 */
Bool
xtermIsLineDrawing(unsigned wc)
{
    Bool result;
    switch (wc) {
    case 0x0B:			/* lower_right_corner   */
    case 0x0C:			/* upper_right_corner   */
    case 0x0D:			/* upper_left_corner    */
    case 0x0E:			/* lower_left_corner    */
    case 0x0F:			/* cross                */
    case 0x10:			/* scan_line_1          */
    case 0x11:			/* scan_line_3          */
    case 0x12:			/* scan_line_7          */
    case 0x13:			/* scan_line_9          */
    case 0x14:			/* horizontal_line      */
    case 0x15:			/* left_tee             */
    case 0x16:			/* right_tee            */
    case 0x17:			/* bottom_tee           */
    case 0x18:			/* top_tee              */
    case 0x19:			/* vertical_line        */
	result = True;
	TRACE(("xtermIsLineDrawing %d\n", wc));
	break;
    default:
	result = False;
	break;
    }
    return result;
}
d2250 1
a2250 1
    if (ch < 32) {
d2292 2
a2293 2
static XFontStruct *
xtermFindFont(TScreen * screen, int fontnum)
d2295 1
a2295 2
    return xtermOpenFont(screen, screen->MenuFontName(fontnum));
}
a2296 3
static void
lookupOneFontSize(TScreen * screen, int fontnum)
{
d2298 3
a2300 1
	XFontStruct *fs = xtermFindFont(screen, fontnum);
d2302 2
a2303 2
	if (fs != 0) {
	    screen->menu_font_sizes[fontnum] = FontSize(fs);
d2306 1
a2306 1
	    xtermCloseFont(screen, fs);
d2315 1
a2315 1
lookupFontSizes(TScreen * screen)
d2320 1
a2320 1
	lookupOneFontSize(screen, n);
d2329 1
a2329 1
lookupRelativeFontSize(TScreen * screen, int old, int relative)
d2331 1
d2335 1
a2335 1
	lookupFontSizes(screen);
d2357 1
a2357 1
		    m = lookupRelativeFontSize(screen, m, relative - 1);
d2359 1
a2359 1
		    m = lookupRelativeFontSize(screen, m, relative + 1);
d2373 6
a2378 1
    XtermWidget xw = (XtermWidget) w;
d2380 6
a2385 9
    if (xw->misc.shift_fonts) {
	TScreen *screen = &xw->screen;
	int m;

	m = lookupRelativeFontSize(screen, screen->menu_font_number, 1);
	if (m >= 0) {
	    SetVTFont(xw, m, True, NULL);
	} else {
	    Bell(XkbBI_MinorError, 0);
d2397 6
a2402 1
    XtermWidget xw = (XtermWidget) w;
d2404 6
a2409 9
    if (xw->misc.shift_fonts) {
	TScreen *screen = &xw->screen;
	int m;

	m = lookupRelativeFontSize(screen, screen->menu_font_number, -1);
	if (m >= 0) {
	    SetVTFont(xw, m, True, NULL);
	} else {
	    Bell(XkbBI_MinorError, 0);
d2415 44
d2466 3
a2468 2
    int fontnum;
    VTFontNames fonts;
d2470 1
a2470 1
    memset(&fonts, 0, sizeof(fonts));
d2472 5
a2476 4
    if (*param_count == 0) {
	fontnum = fontMenu_fontdefault;
    } else {
	Cardinal maxparams = 1;	/* total number of params allowed */
d2478 10
a2487 27
	switch (params[0][0]) {
	case 'd':
	case 'D':
	case '0':
	    fontnum = fontMenu_fontdefault;
	    break;
	case '1':
	    fontnum = fontMenu_font1;
	    break;
	case '2':
	    fontnum = fontMenu_font2;
	    break;
	case '3':
	    fontnum = fontMenu_font3;
	    break;
	case '4':
	    fontnum = fontMenu_font4;
	    break;
	case '5':
	    fontnum = fontMenu_font5;
	    break;
	case '6':
	    fontnum = fontMenu_font6;
	    break;
	case 'e':
	case 'E':
	    fontnum = fontMenu_fontescape;
d2489 1
a2489 1
	    maxparams = 5;
d2491 1
a2491 1
	    maxparams = 3;
d2493 15
a2507 15
	    break;
	case 's':
	case 'S':
	    fontnum = fontMenu_fontsel;
	    maxparams = 2;
	    break;
	default:
	    Bell(XkbBI_MinorError, 0);
	    return;
	}
	if (*param_count > maxparams) {		/* see if extra args given */
	    Bell(XkbBI_MinorError, 0);
	    return;
	}
	switch (*param_count) {	/* assign 'em */
d2509 14
a2522 13
	case 5:
	    fonts.f_wb = params[4];
	    /* FALLTHRU */
	case 4:
	    fonts.f_w = params[3];
	    /* FALLTHRU */
#endif
	case 3:
	    fonts.f_b = params[2];
	    /* FALLTHRU */
	case 2:
	    fonts.f_n = params[1];
	    break;
d2524 2
a2526 2

    SetVTFont((XtermWidget) w, fontnum, True, &fonts);
d2554 2
d2574 4
@


1.1.1.1
log
@Importing xterm 216
@
text
@@


1.1.1.2
log
@import xterm 225
@
text
@d1 1
a1 1
/* $XTermId: fontutils.c,v 1.246 2007/03/22 00:20:06 tom Exp $ */
d9 1
a9 1
Copyright 1998-2006,2007 by Thomas E. Dickey
d122 1
a122 1
static void lookupOneFontSize(XtermWidget, int);
d605 1
a605 1
#define HALF_WIDTH_CHAR1  0x0031	/* '1' */
d688 1
a688 1
xtermOpenFont(XtermWidget xw, char *name)
a689 1
    TScreen *screen = TScreenOf(xw);
d695 1
a695 1
	    nfs = xtermCloseFont(xw, nfs);
d702 1
a702 1
xtermCloseFont(XtermWidget xw, XFontStruct * fnt)
a704 3
	TScreen *screen = TScreenOf(xw);

	clrCgsFonts(xw, WhichVWin(screen), fnt);
d714 1
a714 1
xtermCloseFonts(XtermWidget xw, XFontStruct ** fnts)
d720 1
a720 1
	    xtermCloseFont(xw, fnts[j]);
a736 1
    VTwin *win = WhichVWin(screen);
d739 1
d742 6
a767 3
    TRACE(("Begin Cgs - xtermLoadFont(%s)\n", myfonts.f_n));
    releaseWindowGCs(xw, win);

d775 1
a775 1
    if (!(fnts[fNorm] = xtermOpenFont(xw, myfonts.f_n)))
d783 1
a783 1
	    if ((fnts[fBold] = xtermOpenFont(xw, myfonts.f_b)) == 0) {
d785 1
a785 1
		fnts[fBold] = xtermOpenFont(xw, myfonts.f_b);
d797 1
a797 1
	    xtermCloseFont(xw, fnts[fBold]);
d801 1
a801 1
    } else if ((fnts[fBold] = xtermOpenFont(xw, myfonts.f_b)) == 0) {
d829 1
a829 1
	    fnts[fWide] = xtermOpenFont(xw, myfonts.f_w);
d845 1
a845 1
	    fnts[fWBold] = xtermOpenFont(xw, myfonts.f_wb);
d849 1
a849 1
		fnts[fWBold] = xtermCloseFont(xw, fnts[fWBold]);
d857 1
a857 3
		TRACE(("...%s wide/bold %s\n",
		       derived ? "derived" : "given",
		       NonNull(myfonts.f_wb)));
d885 1
a885 1
	xtermCloseFont(xw, fnts[fBold]);
d895 1
a895 1
	    xtermCloseFont(xw, fnts[fWBold]);
d933 3
d939 5
a943 10
    setCgsFore(xw, win, gcNorm, new_normal);
    setCgsBack(xw, win, gcNorm, new_revers);
    setCgsFont(xw, win, gcNorm, fnts[fNorm]);

    copyCgs(xw, win, gcBold, gcNorm);
    setCgsFont(xw, win, gcBold, fnts[fBold]);

    setCgsFore(xw, win, gcNormReverse, new_revers);
    setCgsBack(xw, win, gcNormReverse, new_normal);
    setCgsFont(xw, win, gcNormReverse, fnts[fNorm]);
d945 12
a956 2
    copyCgs(xw, win, gcBoldReverse, gcNormReverse);
    setCgsFont(xw, win, gcBoldReverse, fnts[fBold]);
d958 6
a963 13
    if_OPT_WIDE_CHARS(screen, {
	if (fnts[fWide] != 0
	    && fnts[fWBold] != 0) {
	    setCgsFore(xw, win, gcWide, new_normal);
	    setCgsBack(xw, win, gcWide, new_revers);
	    setCgsFont(xw, win, gcWide, fnts[fWide]);

	    copyCgs(xw, win, gcWBold, gcWide);
	    setCgsFont(xw, win, gcWBold, fnts[fWBold]);

	    setCgsFore(xw, win, gcWideReverse, new_revers);
	    setCgsBack(xw, win, gcWideReverse, new_normal);
	    setCgsFont(xw, win, gcWideReverse, fnts[fWide]);
d965 21
a985 4
	    copyCgs(xw, win, gcWBoldReverse, gcWideReverse);
	    setCgsFont(xw, win, gcWBoldReverse, fnts[fWBold]);
	}
    });
d992 1
a992 1
    xtermCloseFonts(xw, screen->fnts);
d1048 2
a1049 7
    if (screen->always_bold_mode) {
	screen->enbolden = screen->bold_mode;
    } else {
	screen->enbolden = screen->bold_mode
	    && ((fnts[fNorm] == fnts[fBold])
		|| same_font_name(normal, myfonts.f_b));
    }
a1069 1
    TRACE(("Success Cgs - xtermLoadFont\n"));
d1075 8
a1082 1
    releaseWindowGCs(xw, win);
d1084 1
a1084 2
    xtermCloseFonts(xw, fnts);
    TRACE(("Fail Cgs - xtermLoadFont\n"));
d1107 1
a1107 1
	for (n = fontMenu_default; n <= fontMenu_lastBuiltin; ++n) { \
d1188 1
a1188 1
	    w->screen.MenuFontName(fontMenu_default) = w->misc.default_font.f_n;
d1204 1
a1204 1
    if (okFont(fp)) {
d1271 6
a1276 13
    if (IsXtermWidget(w)) {
	XtermWidget xw = (XtermWidget) w;
	char buf[80];
	char *myName = (*param_count > 0) ? params[0] : empty;
	char *convert = (*param_count > 1) ? params[1] : myName;
	char *myClass = (char *) MyStackAlloc(strlen(convert), buf);
	int n;

	TRACE(("HandleLoadVTFonts(%d)\n", *param_count));
	strcpy(myClass, convert);
	if (*param_count == 1
	    && islower(CharOf(myClass[0])))
	    myClass[0] = toupper(CharOf(myClass[0]));
d1278 5
a1282 16
	if (xtermLoadVTFonts(xw, myName, myClass)) {
	    /*
	     * When switching fonts, try to preserve the font-menu selection, since
	     * it is less surprising to do that (if the font-switching can be
	     * undone) than to switch to "Default".
	     */
	    int font_number = xw->screen.menu_font_number;
	    if (font_number > fontMenu_lastBuiltin)
		font_number = fontMenu_lastBuiltin;
	    for (n = 0; n < NMENUFONTS; ++n)
		xw->screen.menu_font_sizes[n] = 0;
	    SetVTFont(xw, font_number, True,
		      ((font_number == fontMenu_default)
		       ? &(xw->misc.default_font)
		       : NULL));
	}
d1284 15
a1298 1
	MyStackFree(myClass, buf);
d1300 2
a1358 78
#if OPT_RENDERFONT
#if OPT_SHIFT_FONTS
/*
 * Don't make a dependency on the math library for a single function.
 * (Newton Raphson).
 */
static float
mySquareRoot(float value)
{
    float result = 0.0;
    if (value > 0.0) {
	int n;
	float older = value;
	for (n = 0; n < 10; ++n) {
	    float delta = (older * older - value) / (2.0 * older);
	    float newer = older - delta;
	    older = newer;
	    result = newer;
	    if (delta > -0.001 && delta < 0.001)
		break;
	}
    }
    return result;
}
#endif

/*
 * Given the Xft font metrics, determine the actual font size.  This is used
 * for each font to ensure that normal, bold and italic fonts follow the same
 * rule.
 */
static void
setRenderFontsize(TScreen * screen, VTwin * win, XftFont * font, const char *tag)
{
    if (font != 0) {
	int width, height, ascent, descent;

	(void) screen;

	width = font->max_advance_width;
	height = font->height;
	ascent = font->ascent;
	descent = font->descent;
	if (height < ascent + descent) {
	    TRACE(("...increase height from %d\n", height));
	    height = ascent + descent;
	}
	if (is_double_width_font_xft(screen->display, font)) {
	    TRACE(("...reduced width from %d\n", width));
	    width >>= 1;
	}
	if (tag == 0) {
	    win->f_width = width;
	    win->f_height = height;
	    win->f_ascent = ascent;
	    win->f_descent = descent;
	    TRACE(("setRenderFontsize result %dx%d (%d+%d)\n",
		   width, height, ascent, descent));
	} else if (win->f_width < width ||
		   win->f_height < height ||
		   win->f_ascent < ascent ||
		   win->f_descent < descent) {
	    TRACE(("setRenderFontsize %s changed %dx%d (%d+%d) to %dx%d (%d+%d)\n",
		   tag,
		   win->f_width, win->f_height, win->f_ascent, win->f_descent,
		   width, height, ascent, descent));

	    win->f_width = width;
	    win->f_height = height;
	    win->f_ascent = ascent;
	    win->f_descent = descent;
	} else {
	    TRACE(("setRenderFontsize %s unchanged\n", tag));
	}
    }
}
#endif

d1364 1
a1364 1
		     VTwin * win,
d1394 1
a1394 1
	    double face_size = xw->misc.face_size[fontnum];
d1398 1
a1398 1
		   xw->misc.face_size[fontnum]));
a1399 1
	    if (face_size <= 0.0) {
d1401 15
a1415 49
		/*
		 * If the user is switching font-sizes, make it follow by
		 * default the same ratios to the default as the fixed fonts
		 * would, for easy comparison.  There will be some differences
		 * since the fixed fonts have a variety of height/width ratios,
		 * but this is simpler than adding another resource value - and
		 * as noted above, the data for the fixed fonts are available.
		 */
		lookupOneFontSize(xw, 0);
		lookupOneFontSize(xw, fontnum);
		if (fontnum == fontMenu_default) {
		    face_size = 14.0;
		} else {
		    float ratio;
		    int num = screen->menu_font_sizes[fontnum];
		    int den = screen->menu_font_sizes[0];

		    if (den <= 0)
			den = 1;
		    ratio = mySquareRoot((1.0 * num) / den);

		    face_size = (ratio * xw->misc.face_size[0]);
		    TRACE(("scaled using %3d/%d = %.2f -> %f\n",
			   num, den, ratio, face_size));
		}
#else
		switch (fontnum) {
		case fontMenu_font1:
		    face_size = 8.0;
		    break;
		case fontMenu_font2:
		    face_size = 10.0;
		    break;
		case fontMenu_font3:
		    face_size = 12.0;
		    break;
		default:
		    face_size = 14.0;
		    break;
		case fontMenu_font4:
		    face_size = 16.0;
		    break;
		case fontMenu_font5:
		    face_size = 18.0;
		    break;
		case fontMenu_font6:
		    face_size = 20.0;
		    break;
		}
a1416 2
		xw->misc.face_size[fontnum] = face_size;
	    }
d1475 1
a1475 1
		if ((pat = XftNameParse(face_name)) != 0) {
d1477 1
a1477 1
				    XFT_FAMILY, XftTypeString, "mono",
a1493 1
#if OPT_ISO_COLORS
a1503 1
#endif
d1512 1
a1512 1
#endif /* OPT_RENDERWIDE */
a1516 1
	    /* now we will fall through into the bitmap fonts */
d1518 8
a1525 3
	    setRenderFontsize(screen, win, norm, NULL);
	    setRenderFontsize(screen, win, bold, "bold");
	    setRenderFontsize(screen, win, ital, "ital");
a1527 3
    /*
     * Are we handling a bitmap font?
     */
d1529 1
a1529 1
#endif /* OPT_RENDERFONT */
d1578 1
a1578 1
    VTwin *win = &(screen->fullVwin);
d1589 1
a1589 1
	    xtermClear(xw);
d1857 2
a1859 2
    CgsEnum cgsId = (ch == 2) ? gcDots : gcLine;
    VTwin *cgsWin = WhichVWin(screen);
d1895 17
a1911 4
    if (cgsId == gcDots) {
	setCgsFont(xw, cgsWin, cgsId, getCgsFont(xw, cgsWin, gc));
	setCgsFore(xw, cgsWin, cgsId, getCgsFore(xw, cgsWin, gc));
	setCgsBack(xw, cgsWin, cgsId, getCgsBack(xw, cgsWin, gc));
d1913 1
a1913 3
	setCgsFont(xw, cgsWin, cgsId, getCgsFont(xw, cgsWin, gc));
	setCgsFore(xw, cgsWin, cgsId, getCgsBack(xw, cgsWin, gc));
	setCgsBack(xw, cgsWin, cgsId, getCgsBack(xw, cgsWin, gc));
d1915 4
a1918 1
    gc2 = getCgsGC(xw, cgsWin, cgsId);
d1926 1
a1926 5
    setCgsFont(xw, cgsWin, cgsId, getCgsFont(xw, cgsWin, gc));
    setCgsFore(xw, cgsWin, cgsId, getCgsFore(xw, cgsWin, gc));
    setCgsBack(xw, cgsWin, cgsId, getCgsBack(xw, cgsWin, gc));
    gc2 = getCgsGC(xw, cgsWin, cgsId);

d1969 2
d2023 2
d2040 3
a2042 1
	if (!XftGlyphExists(xw->screen.display, font, wc)) {
d2186 1
a2186 1
xtermFindFont(XtermWidget xw, TScreen * screen, int fontnum)
d2188 1
a2188 1
    return xtermOpenFont(xw, screen->MenuFontName(fontnum));
d2192 1
a2192 1
lookupOneFontSize(XtermWidget xw, int fontnum)
a2193 2
    TScreen *screen = TScreenOf(xw);

d2195 1
a2195 1
	XFontStruct *fs = xtermFindFont(xw, screen, fontnum);
d2201 1
a2201 1
	    xtermCloseFont(xw, fs);
d2210 1
a2210 1
lookupFontSizes(XtermWidget xw)
d2215 1
a2215 1
	lookupOneFontSize(xw, n);
d2224 1
a2224 1
lookupRelativeFontSize(XtermWidget xw, int old, int relative)
a2225 1
    TScreen *screen = TScreenOf(xw);
d2229 1
a2229 1
	lookupFontSizes(xw);
d2251 1
a2251 1
		    m = lookupRelativeFontSize(xw, m, relative - 1);
d2253 1
a2253 1
		    m = lookupRelativeFontSize(xw, m, relative + 1);
d2267 1
a2267 2
    if (IsXtermWidget(w)) {
	XtermWidget xw = (XtermWidget) w;
d2269 9
a2277 10
	if (xw->misc.shift_fonts) {
	    TScreen *screen = &xw->screen;
	    int m;

	    m = lookupRelativeFontSize(xw, screen->menu_font_number, 1);
	    if (m >= 0) {
		SetVTFont(xw, m, True, NULL);
	    } else {
		Bell(XkbBI_MinorError, 0);
	    }
d2289 1
a2289 2
    if (IsXtermWidget(w)) {
	XtermWidget xw = (XtermWidget) w;
d2291 9
a2299 10
	if (xw->misc.shift_fonts) {
	    TScreen *screen = &xw->screen;
	    int m;

	    m = lookupRelativeFontSize(xw, screen->menu_font_number, -1);
	    if (m >= 0) {
		SetVTFont(xw, m, True, NULL);
	    } else {
		Bell(XkbBI_MinorError, 0);
	    }
a2304 44
int
xtermGetFont(const char *param)
{
    int fontnum;

    switch (param[0]) {
    case 'd':
    case 'D':
    case '0':
	fontnum = fontMenu_default;
	break;
    case '1':
	fontnum = fontMenu_font1;
	break;
    case '2':
	fontnum = fontMenu_font2;
	break;
    case '3':
	fontnum = fontMenu_font3;
	break;
    case '4':
	fontnum = fontMenu_font4;
	break;
    case '5':
	fontnum = fontMenu_font5;
	break;
    case '6':
	fontnum = fontMenu_font6;
	break;
    case 'e':
    case 'E':
	fontnum = fontMenu_fontescape;
	break;
    case 's':
    case 'S':
	fontnum = fontMenu_fontsel;
	break;
    default:
	fontnum = -1;
	break;
    }
    return fontnum;
}

d2312 2
a2313 3
    if (IsXtermWidget(w)) {
	int fontnum;
	VTFontNames fonts;
d2315 1
a2315 1
	memset(&fonts, 0, sizeof(fonts));
d2317 4
a2320 5
	if (*param_count == 0) {
	    fontnum = fontMenu_default;
	} else {
	    Cardinal maxparams = 1;	/* total number of params allowed */
	    int result = xtermGetFont(params[0]);
d2322 27
a2348 10
	    switch (result) {
	    case fontMenu_default:	/* FALLTHRU */
	    case fontMenu_font1:	/* FALLTHRU */
	    case fontMenu_font2:	/* FALLTHRU */
	    case fontMenu_font3:	/* FALLTHRU */
	    case fontMenu_font4:	/* FALLTHRU */
	    case fontMenu_font5:	/* FALLTHRU */
	    case fontMenu_font6:	/* FALLTHRU */
		break;
	    case fontMenu_fontescape:
d2350 1
a2350 1
		maxparams = 5;
d2352 1
a2352 1
		maxparams = 3;
d2354 15
a2368 15
		break;
	    case fontMenu_fontsel:
		maxparams = 2;
		break;
	    default:
		Bell(XkbBI_MinorError, 0);
		return;
	    }
	    fontnum = result;

	    if (*param_count > maxparams) {	/* see if extra args given */
		Bell(XkbBI_MinorError, 0);
		return;
	    }
	    switch (*param_count) {	/* assign 'em */
d2370 13
a2382 14
	    case 5:
		fonts.f_wb = params[4];
		/* FALLTHRU */
	    case 4:
		fonts.f_w = params[3];
		/* FALLTHRU */
#endif
	    case 3:
		fonts.f_b = params[2];
		/* FALLTHRU */
	    case 2:
		fonts.f_n = params[1];
		break;
	    }
d2384 1
d2386 1
a2386 2
	SetVTFont((XtermWidget) w, fontnum, True, &fonts);
    }
@


1.1.1.3
log
@import xterm 229
@
text
@d1 5
a5 1
/* $XTermId: fontutils.c,v 1.251 2007/08/05 00:11:55 tom Exp $ */
d853 1
d1352 2
a1353 2
static double
mySquareRoot(double value)
d1355 1
a1355 1
    double result = 0.0;
d1358 1
a1358 1
	double older = value;
d1360 2
a1361 2
	    double delta = (older * older - value) / (2.0 * older);
	    double newer = older - delta;
d1480 1
a1480 1
		    double ratio;
a1519 18
	    /*
	     * By observation (there is no documentation), XftPatternBuild is
	     * cumulative.  Build the bold- and italic-patterns on top of the
	     * normal pattern.
	     */
#define NormXftPattern \
	    XFT_FAMILY, XftTypeString, "mono", \
	    XFT_SIZE, XftTypeDouble, face_size, \
	    XFT_SPACING, XftTypeInteger, XFT_MONO

#define BoldXftPattern(norm) \
	    XFT_WEIGHT, XftTypeInteger, XFT_WEIGHT_BOLD, \
	    XFT_CHAR_WIDTH, XftTypeInteger, norm->max_advance_width

#define ItalXftPattern(norm) \
	    XFT_SLANT, XftTypeInteger, XFT_SLANT_ITALIC, \
	    XFT_CHAR_WIDTH, XftTypeInteger, norm->max_advance_width

d1522 3
a1524 1
				NormXftPattern,
d1530 2
a1531 1
				    BoldXftPattern(norm),
d1536 1
a1536 2
		    if (screen->italicULMode
			&& (pat = XftNameParse(xw->misc.face_name)) != 0) {
d1538 2
a1539 2
					NormXftPattern,
					ItalXftPattern(norm),
a1576 5
#define WideXftPattern \
		XFT_FAMILY, XftTypeString, "mono", \
		XFT_SIZE, XftTypeDouble, face_size, \
		XFT_SPACING, XftTypeInteger, XFT_MONO

d1579 3
a1581 1
				    WideXftPattern,
d1588 5
a1592 2
					WideXftPattern,
					BoldXftPattern(wnorm),
d1597 1
a1597 2
			if (screen->italicULMode
			    && (pat = XftNameParse(face_name)) != 0) {
d1599 5
a1603 2
					    WideXftPattern,
					    ItalXftPattern(wnorm),
a2537 2
	    int oldFont = screen->menu_font_number;

a2555 4
	    } else {
		xtermLoadFont(xw,
			      xtermFontName(screen->MenuFontName(oldFont)),
			      doresize, oldFont);
@


1.1.1.4
log
@Import xterm version 232. tested by many.
@
text
@d1 1
a1 1
/* $XTermId: fontutils.c,v 1.267 2008/01/27 14:44:07 tom Exp $ */
d5 1
a5 1
Copyright 1998-2007,2008 by Thomas E. Dickey
d432 1
a432 1
    props = get_font_name_props(screen->display, screen->fnts[fNorm].fs, 0);
d683 2
a684 2
Bool
xtermOpenFont(XtermWidget xw, char *name, XTermFonts * result)
a685 1
    Bool code = False;
d687 1
d690 3
a692 7
	&& (result->fs = XLoadQueryFont(screen->display, name)) != 0) {
	code = True;
	if (EmptyFont(result->fs)) {
	    result = xtermCloseFont(xw, result);
	    code = False;
	} else {
	    result->fn = x_strdup(name);
d695 1
a695 1
    return code;
d698 2
a699 2
XTermFonts *
xtermCloseFont(XtermWidget xw, XTermFonts * fnt)
d701 1
a701 1
    if (fnt != 0 && fnt->fs != 0) {
d705 1
a705 1
	XFreeFont(screen->display, fnt->fs);
d714 1
a714 1
xtermCloseFonts(XtermWidget xw, XTermFonts * fnts)
d719 2
a720 2
	if (fnts[j].fs != 0) {
	    xtermCloseFont(xw, &fnts[j]);
d722 2
a723 2
		if (fnts[j].fs == fnts[k].fs)
		    xtermFreeFontInfo(&fnts[k]);
d725 1
a725 1
	    xtermFreeFontInfo(&fnts[j]);
a729 26
/*
 * Make a copy of the source, assuming the XFontStruct's to be unique, but
 * ensuring that the names are reallocated to simplify freeing.
 */
void
xtermCopyFontInfo(XTermFonts * target, XTermFonts * source)
{
    xtermFreeFontInfo(target);
    target->chrset = source->chrset;
    target->flags = source->flags;
    target->fn = x_strdup(source->fn);
    target->fs = source->fs;
}

void
xtermFreeFontInfo(XTermFonts * target)
{
    target->chrset = 0;
    target->flags = 0;
    if (target->fn != 0) {
	free(target->fn);
	target->fn = 0;
    }
    target->fs = 0;
}

d741 1
a741 1
    XTermFonts fnts[fMAX];
d772 1
a772 1
    if (!xtermOpenFont(xw, myfonts.f_n, &fnts[fNorm]))
d777 1
a777 1
	fp = get_font_name_props(screen->display, fnts[fNorm].fs, normal);
d780 1
a780 1
	    if (!xtermOpenFont(xw, myfonts.f_b, &fnts[fBold])) {
d782 1
a782 1
		(void) xtermOpenFont(xw, myfonts.f_b, &fnts[fBold]);
d786 2
a787 2
	if (fp == 0 || fnts[fBold].fs == 0) {
	    xtermCopyFontInfo(&fnts[fBold], &fnts[fNorm]);
d789 2
a790 2
	} else if (same_font_size(xw, fnts[fNorm].fs, fnts[fBold].fs)
		   && got_bold_font(screen->display, fnts[fBold].fs, myfonts.f_b)) {
d794 1
a794 1
	    xtermCloseFont(xw, &fnts[fBold]);
d798 2
a799 2
    } else if (!xtermOpenFont(xw, myfonts.f_b, &fnts[fBold])) {
	xtermCopyFontInfo(&fnts[fBold], &fnts[fNorm]);
d816 2
a817 2
	} else if (!is_double_width_font(fnts[fNorm].fs)) {
	    fp = get_font_name_props(screen->display, fnts[fNorm].fs, normal);
d826 1
a826 1
	    (void) xtermOpenFont(xw, myfonts.f_w, &fnts[fWide]);
d828 1
a828 1
	    xtermCopyFontInfo(&fnts[fWide], &fnts[fNorm]);
d833 1
a833 1
	    fp = get_font_name_props(screen->display, fnts[fBold].fs, bold);
d842 1
a842 1
	    (void) xtermOpenFont(xw, myfonts.f_wb, &fnts[fWBold]);
d845 2
a846 2
		&& !compatibleWideCounts(fnts[fWide].fs, fnts[fWBold].fs)) {
		xtermCloseFont(xw, &fnts[fWBold]);
d848 1
a848 1
	    if (fnts[fWBold].fs == 0) {
d850 1
a850 1
		xtermCopyFontInfo(&fnts[fWBold], &fnts[fWide]);
d858 2
a859 2
	} else if (is_double_width_font(fnts[fBold].fs)) {
	    xtermCopyFontInfo(&fnts[fWBold], &fnts[fBold]);
d862 1
a862 1
	    xtermCopyFontInfo(&fnts[fWBold], &fnts[fWide]);
d866 1
a866 1
	if (EmptyFont(fnts[fWBold].fs))
d877 1
a877 1
    if (EmptyFont(fnts[fBold].fs))
d880 2
a881 2
    if (!same_font_size(xw, fnts[fNorm].fs, fnts[fBold].fs)
	&& (is_fixed_font(fnts[fNorm].fs) && is_fixed_font(fnts[fBold].fs))) {
d883 2
a884 2
	xtermCloseFont(xw, &fnts[fBold]);
	xtermCopyFontInfo(&fnts[fBold], &fnts[fNorm]);
d888 4
a891 4
	if (fnts[fWide].fs != 0
	    && fnts[fWBold].fs != 0
	    && !same_font_size(xw, fnts[fWide].fs, fnts[fWBold].fs)
	    && (is_fixed_font(fnts[fWide].fs) && is_fixed_font(fnts[fWBold].fs))) {
d893 2
a894 2
	    xtermCloseFont(xw, &fnts[fWBold]);
	    xtermCopyFontInfo(&fnts[fWBold], &fnts[fWide]);
d902 3
a904 3
    if (!is_fixed_font(fnts[fNorm].fs)
	|| !is_fixed_font(fnts[fBold].fs)
	|| fnts[fNorm].fs->max_bounds.width != fnts[fBold].fs->max_bounds.width) {
d906 4
a909 4
	       fnts[fNorm].fs->min_bounds.width,
	       fnts[fNorm].fs->max_bounds.width,
	       fnts[fBold].fs->min_bounds.width,
	       fnts[fBold].fs->max_bounds.width));
d914 5
a918 5
	if (fnts[fWide].fs != 0
	    && fnts[fWBold].fs != 0
	    && (!is_fixed_font(fnts[fWide].fs)
		|| !is_fixed_font(fnts[fWBold].fs)
		|| fnts[fWide].fs->max_bounds.width != fnts[fWBold].fs->max_bounds.width)) {
d920 4
a923 4
		   fnts[fWide].fs->min_bounds.width,
		   fnts[fWide].fs->max_bounds.width,
		   fnts[fWBold].fs->min_bounds.width,
		   fnts[fWBold].fs->max_bounds.width));
a930 16
    /*
     * If we're switching fonts, free the old ones.  Otherwise we'll leak
     * the memory that is associated with the old fonts.  The
     * XLoadQueryFont call allocates a new XFontStruct.
     */
    xtermCloseFonts(xw, screen->fnts);

    xtermCopyFontInfo(&(screen->fnts[fNorm]), &fnts[fNorm]);
    xtermCopyFontInfo(&(screen->fnts[fBold]), &fnts[fBold]);
#if OPT_WIDE_CHARS
    xtermCopyFontInfo(&(screen->fnts[fWide]), &fnts[fWide]);
    if (fnts[fWBold].fs == NULL)
	xtermCopyFontInfo(&fnts[fWBold], &fnts[fWide]);
    xtermCopyFontInfo(&(screen->fnts[fWBold]), &fnts[fWBold]);
#endif

d936 1
a936 1
    setCgsFont(xw, win, gcNorm, &(screen->fnts[fNorm]));
d939 1
a939 1
    setCgsFont(xw, win, gcBold, &(screen->fnts[fBold]));
d943 1
a943 1
    setCgsFont(xw, win, gcNormReverse, &(screen->fnts[fNorm]));
d946 1
a946 1
    setCgsFont(xw, win, gcBoldReverse, &(screen->fnts[fBold]));
d949 2
a950 2
	if (screen->fnts[fWide].fs != 0
	    && screen->fnts[fWBold].fs != 0) {
d953 1
a953 1
	    setCgsFont(xw, win, gcWide, &(screen->fnts[fWide]));
d956 1
a956 1
	    setCgsFont(xw, win, gcWBold, &(screen->fnts[fWBold]));
d960 1
a960 1
	    setCgsFont(xw, win, gcWideReverse, &(screen->fnts[fWide]));
d963 1
a963 1
	    setCgsFont(xw, win, gcWBoldReverse, &(screen->fnts[fWBold]));
d967 15
d1012 1
a1012 1
	    if (xtermMissingChar(xw, n, fnts[fNorm].fs)) {
d1017 1
a1017 1
	    if (xtermMissingChar(xw, n, fnts[fBold].fs)) {
d1032 1
a1032 1
	    && ((fnts[fNorm].fs == fnts[fBold].fs)
d1050 1
a1050 1
	screen->menu_font_sizes[fontnum] = FontSize(fnts[fNorm].fs);
d1209 3
a1211 3
    if (EmptyFont(screen->fnts[fWide].fs)) {
	result = (isWideFont(screen->fnts[fNorm].fs, "normal", nullOk)
		  && isWideFont(screen->fnts[fBold].fs, "bold", nullOk));
d1213 2
a1214 2
	result = (isWideFont(screen->fnts[fWide].fs, "wide", nullOk)
		  && isWideFont(screen->fnts[fWBold].fs, "wide-bold", nullOk));
d1216 2
a1217 2
	    result = (isWideFont(screen->fnts[fNorm].fs, "normal", nullOk)
		      && isWideFont(screen->fnts[fBold].fs, "bold", nullOk));
d1696 2
a1697 2
    xtermComputeFontInfo(xw, win, screen->fnts[fNorm].fs, scrollbar_width);
    xtermSaveFontInfo(screen, screen->fnts[fNorm].fs);
d1753 1
a1753 1
    if (xtermIsDecGraphic(ch)
d1792 1
a1792 2
		 int y,
		 int cells)
d1797 1
a1797 1
	SEG(1*BOX_WIDE/10,  0,		1*BOX_WIDE/10,5*MID_HIGH/6),	/* H */
d1799 1
a1799 1
	SEG(1*BOX_WIDE/10,5*MID_HIGH/12,6*BOX_WIDE/10,5*MID_HIGH/12),
d1804 3
a1806 3
	SEG(1*BOX_WIDE/10,  0,		6*BOX_WIDE/10,	0),		/* F */
	SEG(1*BOX_WIDE/10,5*MID_HIGH/12,6*CHR_WIDE/12,5*MID_HIGH/12),
	SEG(1*BOX_WIDE/10,  0,		0*BOX_WIDE/3, 5*MID_HIGH/6),
d1812 2
a1813 2
	SEG(1*BOX_WIDE/10,  0,		1*BOX_WIDE/10,9*MID_HIGH/12),	/* L */
	SEG(1*BOX_WIDE/10,9*MID_HIGH/12,6*BOX_WIDE/10,9*MID_HIGH/12),
d1819 2
a1820 2
	SEG(1*BOX_WIDE/10,5*MID_HIGH/6, 1*BOX_WIDE/10,	0),		/* N */
	SEG(1*BOX_WIDE/10,  0,		5*BOX_WIDE/6, 5*MID_HIGH/6),
d1826 1
a1826 1
	SEG(1*BOX_WIDE/10,   0,		5*BOX_WIDE/12,5*MID_HIGH/6),	/* V */
a1975 3
    if (cells > 1)
	font_width *= cells;

d1990 3
a1992 4
		&& !xtermMissingChar(xw, n,
				     ((flags & BOLD)
				      ? screen->fnts[fBold].fs
				      : screen->fnts[fNorm].fs))) {
d2048 1
a2048 1
	points[1].x = 8 * BOX_WIDE / 8;
d2054 1
a2054 1
	points[3].x = 0 * BOX_WIDE / 8;
d2094 1
a2094 1
	XDrawArc(screen->display,
d2125 1
a2125 1
#if OPT_RENDERFONT
d2139 1
a2139 6
#if OPT_WIDE_CHARS
	    TRACE(("xtermXftMissing %d (dec=%#x, ucs=%#x)\n",
		   wc, ucs2dec(wc), dec2ucs(wc)));
#else
	    TRACE(("xtermXftMissing %d\n", wc));
#endif
d2145 37
d2239 1
a2239 1
    if (xtermIsDecGraphic(ch)) {
d2281 6
d2293 1
a2293 3
	XTermFonts fnt;

	memset(&fnt, 0, sizeof(fnt));
d2295 2
a2296 2
	if (xtermOpenFont(xw, screen->MenuFontName(fontnum), &fnt)) {
	    screen->menu_font_sizes[fontnum] = FontSize(fnt.fs);
d2299 1
a2299 1
	    xtermCloseFont(xw, &fnt);
@


