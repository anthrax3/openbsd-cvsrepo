head	1.41;
access;
symbols
	OPENBSD_6_1:1.41.0.2
	OPENBSD_6_1_BASE:1.41
	OPENBSD_6_0:1.38.0.4
	OPENBSD_6_0_BASE:1.38
	OPENBSD_5_9:1.38.0.2
	OPENBSD_5_9_BASE:1.38
	OPENBSD_5_8:1.33.0.4
	OPENBSD_5_8_BASE:1.33
	OPENBSD_5_7:1.33.0.2
	OPENBSD_5_7_BASE:1.33
	OPENBSD_5_6:1.31.0.2
	OPENBSD_5_6_BASE:1.31
	OPENBSD_5_5:1.29.0.2
	OPENBSD_5_5_BASE:1.29
	OPENBSD_5_4:1.27.0.2
	OPENBSD_5_4_BASE:1.27
	OPENBSD_5_3:1.25.0.2
	OPENBSD_5_3_BASE:1.25
	OPENBSD_5_2:1.24.0.2
	OPENBSD_5_2_BASE:1.24
	OPENBSD_5_1_BASE:1.22
	OPENBSD_5_1:1.22.0.2
	OPENBSD_5_0:1.18.0.2
	OPENBSD_5_0_BASE:1.18
	OPENBSD_4_9:1.16.0.2
	OPENBSD_4_9_BASE:1.16
	OPENBSD_4_8:1.15.0.4
	OPENBSD_4_8_BASE:1.15
	OPENBSD_4_7:1.13.0.2
	OPENBSD_4_7_BASE:1.13
	OPENBSD_4_6:1.10.0.2
	OPENBSD_4_6_BASE:1.10
	OPENBSD_4_5:1.9.0.2
	OPENBSD_4_5_BASE:1.9
	OPENBSD_4_4:1.7.0.2
	OPENBSD_4_4_BASE:1.7
	OPENBSD_4_3_BASE:1.6
	OPENBSD_4_3:1.6.0.2
	v232:1.1.1.4
	v229:1.1.1.3
	OPENBSD_4_2:1.3.0.2
	OPENBSD_4_2_BASE:1.3
	v225:1.1.1.2
	v216:1.1.1.1
	xterm:1.1.1;
locks; strict;
comment	@ * @;


1.41
date	2016.11.03.14.25.06;	author matthieu;	state Exp;
branches;
next	1.40;
commitid	f4xcYrkdKFtVElPL;

1.40
date	2016.10.26.19.21.51;	author matthieu;	state Exp;
branches;
next	1.39;
commitid	bz62mVVEOnlhQahU;

1.39
date	2016.08.07.21.27.36;	author matthieu;	state Exp;
branches;
next	1.38;
commitid	psxxjI5z4Vpv2LL4;

1.38
date	2016.01.13.20.40.08;	author matthieu;	state Exp;
branches;
next	1.37;
commitid	by9Wu4LDAgU65dBU;

1.37
date	2015.11.25.08.56.50;	author semarie;	state Exp;
branches;
next	1.36;
commitid	brHA8At0cgg8mxS4;

1.36
date	2015.11.11.07.09.50;	author deraadt;	state Exp;
branches;
next	1.35;
commitid	vyjh0vbYo8mQkaEc;

1.35
date	2015.11.07.08.10.24;	author semarie;	state Exp;
branches;
next	1.34;
commitid	qxCVHkcaxDT5S9OO;

1.34
date	2015.09.05.14.11.46;	author matthieu;	state Exp;
branches;
next	1.33;
commitid	YVUODLQ4QcYTuGkb;

1.33
date	2015.01.18.20.24.40;	author matthieu;	state Exp;
branches;
next	1.32;
commitid	PDdlFuihcMifzxwp;

1.32
date	2014.10.05.16.39.19;	author matthieu;	state Exp;
branches;
next	1.31;
commitid	0wVJ6bWh03LWbUdn;

1.31
date	2014.07.14.08.30.11;	author matthieu;	state Exp;
branches;
next	1.30;
commitid	EnwNNUjlkdrocnMa;

1.30
date	2014.05.09.19.56.40;	author matthieu;	state Exp;
branches;
next	1.29;

1.29
date	2014.02.14.19.40.03;	author matthieu;	state Exp;
branches;
next	1.28;

1.28
date	2014.01.02.15.14.50;	author matthieu;	state Exp;
branches;
next	1.27;

1.27
date	2013.06.02.19.55.50;	author matthieu;	state Exp;
branches;
next	1.26;

1.26
date	2013.03.09.14.45.38;	author matthieu;	state Exp;
branches;
next	1.25;

1.25
date	2013.01.04.16.40.18;	author matthieu;	state Exp;
branches;
next	1.24;

1.24
date	2012.06.07.20.20.23;	author matthieu;	state Exp;
branches;
next	1.23;

1.23
date	2012.04.14.09.02.46;	author matthieu;	state Exp;
branches;
next	1.22;

1.22
date	2011.11.16.21.14.25;	author matthieu;	state Exp;
branches;
next	1.21;

1.21
date	2011.09.17.11.51.57;	author matthieu;	state Exp;
branches;
next	1.20;

1.20
date	2011.08.28.17.40.55;	author matthieu;	state Exp;
branches;
next	1.19;

1.19
date	2011.08.18.19.47.42;	author matthieu;	state Exp;
branches;
next	1.18;

1.18
date	2011.06.07.19.21.06;	author matthieu;	state Exp;
branches;
next	1.17;

1.17
date	2011.03.07.20.41.27;	author matthieu;	state Exp;
branches;
next	1.16;

1.16
date	2010.08.22.13.38.11;	author matthieu;	state Exp;
branches;
next	1.15;

1.15
date	2010.05.08.12.20.46;	author matthieu;	state Exp;
branches;
next	1.14;

1.14
date	2010.03.25.22.03.51;	author matthieu;	state Exp;
branches;
next	1.13;

1.13
date	2009.10.31.14.11.57;	author matthieu;	state Exp;
branches;
next	1.12;

1.12
date	2009.09.05.16.06.57;	author matthieu;	state Exp;
branches;
next	1.11;

1.11
date	2009.09.05.15.58.09;	author matthieu;	state Exp;
branches;
next	1.10;

1.10
date	2009.03.09.22.13.04;	author matthieu;	state Exp;
branches;
next	1.9;

1.9
date	2008.09.23.19.08.55;	author matthieu;	state Exp;
branches;
next	1.8;

1.8
date	2008.08.25.18.05.57;	author matthieu;	state Exp;
branches;
next	1.7;

1.7
date	2008.03.19.21.15.46;	author matthieu;	state Exp;
branches;
next	1.6;

1.6
date	2008.02.24.22.22.48;	author matthieu;	state Exp;
branches;
next	1.5;

1.5
date	2008.02.16.09.40.00;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2007.08.25.18.58.42;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2007.06.15.19.34.50;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2006.11.26.15.48.06;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.26.11.11.36;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.11.26.11.11.36;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2007.06.15.19.30.26;	author matthieu;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2007.08.25.18.53.59;	author matthieu;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2008.02.16.09.35.06;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.41
log
@Update to xterm 327
@
text
@/* $XTermId: main.c,v 1.784 2016/10/07 00:40:34 tom Exp $ */

/*
 * Copyright 2002-2015,2016 by Thomas E. Dickey
 *
 *                         All Rights Reserved
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 *
 * The above copyright notice and this permission notice shall be included
 * in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
 * IN NO EVENT SHALL THE ABOVE LISTED COPYRIGHT HOLDER(S) BE LIABLE FOR ANY
 * CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
 * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
 * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 *
 * Except as contained in this notice, the name(s) of the above copyright
 * holders shall not be used in advertising or otherwise to promote the
 * sale, use or other dealings in this Software without prior written
 * authorization.
 *
 * Copyright 1987, 1988  The Open Group
 *
 * Permission to use, copy, modify, distribute, and sell this software and its
 * documentation for any purpose is hereby granted without fee, provided that
 * the above copyright notice appear in all copies and that both that
 * copyright notice and this permission notice appear in supporting
 * documentation.
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
 * OPEN GROUP BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
 * AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 *
 * Except as contained in this notice, the name of The Open Group shall not be
 * used in advertising or otherwise to promote the sale, use or other dealings
 * in this Software without prior written authorization from The Open Group.
 *
 * Copyright 1987, 1988 by Digital Equipment Corporation, Maynard.
 *
 *                         All Rights Reserved
 *
 * Permission to use, copy, modify, and distribute this software and its
 * documentation for any purpose and without fee is hereby granted,
 * provided that the above copyright notice appear in all copies and that
 * both that copyright notice and this permission notice appear in
 * supporting documentation, and that the name of Digital not be used in
 * advertising or publicity pertaining to distribution of the software
 * without specific, written prior permission.
 *
 * DIGITAL DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING
 * ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL
 * DIGITAL BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR
 * ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
 * WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
 * ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
 * SOFTWARE.
 */

/*
 *				 W A R N I N G
 *
 * If you think you know what all of this code is doing, you are
 * probably very mistaken.  There be serious and nasty dragons here.
 *
 * This client is *not* to be taken as an example of how to write X
 * Toolkit applications.  It is in need of a substantial rewrite,
 * ideally to create a generic tty widget with several different parsing
 * widgets so that you can plug 'em together any way you want.  Don't
 * hold your breath, though....
 */

/* main.c */

#define RES_OFFSET(field)	XtOffsetOf(XTERM_RESOURCE, field)

#include <xterm.h>
#include <version.h>
#include <graphics.h>

#include <X11/cursorfont.h>
#include <X11/Xlocale.h>

#if OPT_TOOLBAR

#if defined(HAVE_LIB_XAW)
#include <X11/Xaw/Form.h>
#elif defined(HAVE_LIB_XAW3D)
#include <X11/Xaw3d/Form.h>
#elif defined(HAVE_LIB_XAW3DXFT)
#include <X11/Xaw3dxft/Form.h>
#elif defined(HAVE_LIB_NEXTAW)
#include <X11/neXtaw/Form.h>
#elif defined(HAVE_LIB_XAWPLUS)
#include <X11/XawPlus/Form.h>
#endif

#endif /* OPT_TOOLBAR */

#include <pwd.h>
#include <ctype.h>

#include <data.h>
#include <error.h>
#include <menu.h>
#include <main.h>
#include <xstrings.h>
#include <xtermcap.h>
#include <xterm_io.h>

#if OPT_WIDE_CHARS
#include <charclass.h>
#endif

#ifdef __osf__
#define USE_SYSV_SIGNALS
#define WTMP
#include <pty.h>		/* openpty() */
#endif

#ifdef __sgi
#include <grp.h>		/* initgroups() */
#endif

static void Syntax(char *) GCC_NORETURN;
static void HsSysError(int) GCC_NORETURN;

#if defined(__SCO__) || defined(SVR4) || defined(_POSIX_SOURCE) || ( defined(_POSIX_C_SOURCE) && (_POSIX_C_SOURCE >= 1) )
#define USE_POSIX_SIGNALS
#endif

#if defined(SYSV) && !defined(SVR4) && !defined(ISC22) && !defined(ISC30)
/* older SYSV systems cannot ignore SIGHUP.
   Shell hangs, or you get extra shells, or something like that */
#define USE_SYSV_SIGHUP
#endif

#if defined(sony) && defined(bsd43) && !defined(KANJI)
#define KANJI
#endif

#ifdef linux
#define USE_SYSV_PGRP
#define USE_SYSV_SIGNALS
#define WTMP
#ifdef __GLIBC__
#if (__GLIBC__ > 2) || ((__GLIBC__ == 2) && (__GLIBC_MINOR__ >= 1))
#include <pty.h>
#endif
#endif
#endif

#ifdef __MVS__
#define USE_SYSV_PGRP
#define USE_SYSV_SIGNALS
#endif

#ifdef __CYGWIN__
#define WTMP
#endif

#ifdef __SCO__
#ifndef _SVID3
#define _SVID3
#endif
#endif

#if defined(__GLIBC__) && !defined(linux)
#define USE_SYSV_PGRP
#define WTMP
#endif

#if defined(USE_TTY_GROUP) || defined(USE_UTMP_SETGID)
#include <grp.h>
#endif

#ifndef TTY_GROUP_NAME
#define TTY_GROUP_NAME "tty"
#endif

#include <sys/stat.h>

#ifdef Lynx
#ifndef BSDLY
#define BSDLY	0
#endif
#ifndef VTDLY
#define VTDLY	0
#endif
#ifndef FFDLY
#define FFDLY	0
#endif
#endif

#ifdef SYSV			/* { */

#ifdef USE_USG_PTYS		/* AT&T SYSV has no ptyio.h */
#include <sys/stropts.h>	/* for I_PUSH */
#include <poll.h>		/* for POLLIN */
#endif /* USE_USG_PTYS */

#define USE_SYSV_SIGNALS
#define	USE_SYSV_PGRP

#if !defined(TIOCSWINSZ) || defined(__SCO__) || defined(__UNIXWARE__)
#define USE_SYSV_ENVVARS	/* COLUMNS/LINES vs. TERMCAP */
#endif

/*
 * now get system-specific includes
 */
#ifdef macII
#include <sys/ttychars.h>
#undef USE_SYSV_ENVVARS
#undef FIOCLEX
#undef FIONCLEX
#define setpgrp2 setpgrp
#include <sgtty.h>
#include <sys/resource.h>
#endif

#ifdef __hpux
#include <sys/ptyio.h>
#endif /* __hpux */

#ifdef __osf__
#undef  USE_SYSV_PGRP
#define setpgrp setpgid
#endif

#ifdef __sgi
#include <sys/sysmacros.h>
#endif /* __sgi */

#ifdef sun
#include <sys/strredir.h>
#endif

#else /* } !SYSV { */ /* BSD systems */

#ifdef __QNX__

#ifndef __QNXNTO__
#define ttyslot() 1
#else
#define USE_SYSV_PGRP
extern __inline__
int
ttyslot(void)
{
    return 1;			/* yuk */
}
#endif

#else

#if defined(__INTERIX) || defined(__APPLE__)
#define setpgrp setpgid
#endif

#ifndef linux
#ifndef VMS
#ifndef USE_POSIX_TERMIOS
#ifndef USE_ANY_SYSV_TERMIO
#include <sgtty.h>
#endif
#endif /* USE_POSIX_TERMIOS */
#ifdef Lynx
#include <resource.h>
#else
#include <sys/resource.h>
#endif
#endif /* !VMS */
#endif /* !linux */

#endif /* __QNX__ */

#endif /* } !SYSV */

/* Xpoll.h and <sys/param.h> on glibc 2.1 systems have colliding NBBY's */
#if defined(__GLIBC__) && ((__GLIBC__ > 2) || ((__GLIBC__ == 2) && (__GLIBC_MINOR__ >= 1)))
#ifndef NOFILE
#define NOFILE OPEN_MAX
#endif
#elif !(defined(VMS) || defined(WIN32) || defined(Lynx) || defined(__GNU__) || defined(__MVS__))
#include <sys/param.h>		/* for NOFILE */
#endif

#if defined(BSD) && (BSD >= 199103)
#define WTMP
#endif

#include <stdio.h>

#ifdef __hpux
#include <sys/utsname.h>
#endif /* __hpux */

#if defined(apollo) && (OSMAJORVERSION == 10) && (OSMINORVERSION < 4)
#define ttyslot() 1
#endif /* apollo */

#if defined(UTMPX_FOR_UTMP)
#define UTMP_STR utmpx
#else
#define UTMP_STR utmp
#endif

#if defined(USE_UTEMPTER)
#include <utempter.h>
#endif

#if defined(I_FIND) && defined(I_PUSH)
#define PUSH_FAILS(fd,name) ioctl(fd, I_FIND, name) == 0 \
			 && ioctl(fd, I_PUSH, name) < 0
#else
#define PUSH_FAILS(fd,name) ioctl(fd, I_PUSH, name) < 0
#endif

#if defined(UTMPX_FOR_UTMP)

#include <utmpx.h>

#define call_endutent  endutxent
#define call_getutid   getutxid
#define call_pututline pututxline
#define call_setutent  setutxent
#define call_updwtmp   updwtmpx

#elif defined(HAVE_UTMP)

#include <utmp.h>

#if defined(_CRAY) && (OSMAJORVERSION < 8)
extern struct utmp *getutid __((struct utmp * _Id));
#endif

#define call_endutent  endutent
#define call_getutid   getutid
#define call_pututline pututline
#define call_setutent  setutent
#define call_updwtmp   updwtmp

#endif

#if defined(USE_LASTLOG) && defined(HAVE_LASTLOG_H)
#include <lastlog.h>		/* caution: glibc includes utmp.h here */
#endif

#ifndef USE_LASTLOGX
#if defined(_NETBSD_SOURCE) && defined(_PATH_LASTLOGX)
#define USE_LASTLOGX 1
#endif
#endif

#ifdef  PUCC_PTYD
#include <local/openpty.h>
#endif /* PUCC_PTYD */

#if defined(__OpenBSD__) || defined(__NetBSD__) || defined(__APPLE__)
#include <util.h>		/* openpty() */
#endif

#if defined(__FreeBSD__) || defined(__DragonFly__)
#include <libutil.h>		/* openpty() */
#endif

#if !defined(UTMP_FILENAME)
#if defined(UTMP_FILE)
#define UTMP_FILENAME UTMP_FILE
#elif defined(_PATH_UTMP)
#define UTMP_FILENAME _PATH_UTMP
#else
#define UTMP_FILENAME "/etc/utmp"
#endif
#endif

#ifndef LASTLOG_FILENAME
#ifdef _PATH_LASTLOG
#define LASTLOG_FILENAME _PATH_LASTLOG
#else
#define LASTLOG_FILENAME "/usr/adm/lastlog"	/* only on BSD systems */
#endif
#endif

#if !defined(WTMP_FILENAME)
#if defined(WTMP_FILE)
#define WTMP_FILENAME WTMP_FILE
#elif defined(_PATH_WTMP)
#define WTMP_FILENAME _PATH_WTMP
#elif defined(SYSV)
#define WTMP_FILENAME "/etc/wtmp"
#else
#define WTMP_FILENAME "/usr/adm/wtmp"
#endif
#endif

#include <signal.h>

#if defined(__SCO__) || (defined(ISC) && !defined(_POSIX_SOURCE))
#undef SIGTSTP			/* defined, but not the BSD way */
#endif

#ifdef SIGTSTP
#include <sys/wait.h>
#endif

#if defined(__SCO__) || defined(__UNIXWARE__)
#undef ECHOKE
#undef ECHOCTL
#endif

#if defined(HAVE_SYS_TTYDEFAULTS_H) && !defined(CEOF)
#include <sys/ttydefaults.h>
#endif

#ifdef X_NOT_POSIX
extern long lseek();
#if defined(USG) || defined(SVR4)
extern unsigned sleep();
#else
extern void sleep();
#endif
extern char *ttyname();
#endif

#if defined(SYSV) && defined(DECL_PTSNAME)
extern char *ptsname(int);
#endif

#ifndef VMS
static void reapchild(int /* n */ );
static int spawnXTerm(XtermWidget	/* xw */
		      ,unsigned /* line_speed */ );
static void remove_termcap_entry(char *, const char *);
#ifdef USE_PTY_SEARCH
static int pty_search(int * /* pty */ );
#endif
#endif /* ! VMS */

static int get_pty(int *pty, char *from);
static void resize_termcap(XtermWidget xw);
static void set_owner(char *device, unsigned uid, unsigned gid, unsigned mode);

static Bool added_utmp_entry = False;

#ifdef HAVE_POSIX_SAVED_IDS
static uid_t save_euid;
static gid_t save_egid;
#endif

static uid_t save_ruid;
static gid_t save_rgid;

#if defined(USE_UTMP_SETGID)
static int really_get_pty(int *pty, char *from);
#endif

#if defined(USE_SYSV_UTMP) && !defined(USE_UTEMPTER)
static Bool xterm_exiting = False;
#endif

static char *explicit_shname = NULL;

/*
** Ordinarily it should be okay to omit the assignment in the following
** statement. Apparently the c89 compiler on AIX 4.1.3 has a bug, or does
** it? Without the assignment though the compiler will init command_to_exec
** to 0xffffffff instead of NULL; and subsequent usage, e.g. in spawnXTerm() to
** SEGV.
*/
static char **command_to_exec = NULL;

#if OPT_LUIT_PROG
static char **command_to_exec_with_luit = NULL;
static unsigned command_length_with_luit = 0;
#endif

#define TERMCAP_ERASE "kb"
#define VAL_INITIAL_ERASE A2E(8)

/* choose a nice default value for speed - if we make it too low, users who
 * mistakenly use $TERM set to vt100 will get padding delays.  Setting it to a
 * higher value is not useful since legacy applications (termcap) that care
 * about padding generally store the code in a short, which does not have
 * enough bits for the extended values.
 */
#ifdef B38400			/* everyone should define this */
#define VAL_LINE_SPEED B38400
#else /* ...but xterm's used this for a long time */
#define VAL_LINE_SPEED B9600
#endif

/*
 * Allow use of system default characters if defined and reasonable.
 * These are based on the BSD ttydefaults.h
 */
#ifndef CBRK
#define CBRK     0xff		/* was 0 */
#endif
#ifndef CDISCARD
#define CDISCARD CONTROL('O')
#endif
#ifndef CDSUSP
#define CDSUSP   CONTROL('Y')
#endif
#ifndef CEOF
#define CEOF     CONTROL('D')
#endif
#ifndef CEOL
#define CEOL	 0xff		/* was 0 */
#endif
#ifndef CERASE
#define CERASE   0177
#endif
#ifndef CERASE2
#define	CERASE2  CONTROL('H')
#endif
#ifndef CFLUSH
#define CFLUSH   CONTROL('O')
#endif
#ifndef CINTR
#define CINTR    CONTROL('C')
#endif
#ifndef CKILL
#define CKILL	 CONTROL('U')	/* was '@@' */
#endif
#ifndef CLNEXT
#define CLNEXT   CONTROL('V')
#endif
#ifndef CNUL
#define CNUL     0
#endif
#ifndef CQUIT
#define CQUIT    CONTROL('\\')
#endif
#ifndef CRPRNT
#define CRPRNT   CONTROL('R')
#endif
#ifndef CREPRINT
#define CREPRINT CRPRNT
#endif
#ifndef CSTART
#define CSTART   CONTROL('Q')
#endif
#ifndef CSTATUS
#define	CSTATUS  CONTROL('T')
#endif
#ifndef CSTOP
#define CSTOP    CONTROL('S')
#endif
#ifndef CSUSP
#define CSUSP    CONTROL('Z')
#endif
#ifndef CSWTCH
#define CSWTCH   0
#endif
#ifndef CWERASE
#define CWERASE  CONTROL('W')
#endif

#ifdef USE_ANY_SYSV_TERMIO
#define TERMIO_STRUCT struct termio
#define ttySetAttr(fd, datap) ioctl(fd, TCSETA, datap)
#define ttyGetAttr(fd, datap) ioctl(fd, TCGETA, datap)
#define ttyFlush(fd)          ioctl(fd, TCFLSH, 1)
#elif defined(USE_POSIX_TERMIOS)
#define TERMIO_STRUCT struct termios
#define ttySetAttr(fd, datap) tcsetattr(fd, TCSANOW, datap)
#define ttyGetAttr(fd, datap) tcgetattr(fd, datap)
#define ttyFlush(fd)          tcflush(fd, TCOFLUSH)
#endif /* USE_ANY_SYSV_TERMIO */

#ifndef VMS
#ifdef TERMIO_STRUCT
/* The following structures are initialized in main() in order
** to eliminate any assumptions about the internal order of their
** contents.
*/
static TERMIO_STRUCT d_tio;

#ifdef HAS_LTCHARS
static struct ltchars d_ltc;
#endif /* HAS_LTCHARS */

#ifdef TIOCLSET
static unsigned int d_lmode;
#endif /* TIOCLSET */

#else /* !TERMIO_STRUCT */
static struct sgttyb d_sg =
{
    0, 0, 0177, CKILL, (EVENP | ODDP | ECHO | XTABS | CRMOD)
};
static struct tchars d_tc =
{
    CINTR, CQUIT, CSTART,
    CSTOP, CEOF, CBRK
};
static struct ltchars d_ltc =
{
    CSUSP, CDSUSP, CRPRNT,
    CFLUSH, CWERASE, CLNEXT
};
static int d_disipline = NTTYDISC;
static long int d_lmode = LCRTBS | LCRTERA | LCRTKIL | LCTLECH;
#ifdef sony
static long int d_jmode = KM_SYSSJIS | KM_ASCII;
static struct jtchars d_jtc =
{
    'J', 'B'
};
#endif /* sony */
#endif /* TERMIO_STRUCT */
#endif /* ! VMS */

/*
 * SYSV has the termio.c_cc[V] and ltchars; BSD has tchars and ltchars;
 * SVR4 has only termio.c_cc, but it includes everything from ltchars.
 * POSIX termios has termios.c_cc, which is similar to SVR4.
 */
#define TTYMODE(name) { name, sizeof(name)-1, 0, 0 }
static Boolean override_tty_modes = False;
/* *INDENT-OFF* */
static struct _xttymodes {
    const char *name;
    size_t len;
    int set;
    int value;
} ttymodelist[] = {
    TTYMODE("intr"),		/* tchars.t_intrc ; VINTR */
#define XTTYMODE_intr	0
    TTYMODE("quit"),		/* tchars.t_quitc ; VQUIT */
#define XTTYMODE_quit	1
    TTYMODE("erase"),		/* sgttyb.sg_erase ; VERASE */
#define XTTYMODE_erase	2
    TTYMODE("kill"),		/* sgttyb.sg_kill ; VKILL */
#define XTTYMODE_kill	3
    TTYMODE("eof"),		/* tchars.t_eofc ; VEOF */
#define XTTYMODE_eof	4
    TTYMODE("eol"),		/* VEOL */
#define XTTYMODE_eol	5
    TTYMODE("swtch"),		/* VSWTCH */
#define XTTYMODE_swtch	6
    TTYMODE("start"),		/* tchars.t_startc ; VSTART */
#define XTTYMODE_start	7
    TTYMODE("stop"),		/* tchars.t_stopc ; VSTOP */
#define XTTYMODE_stop	8
    TTYMODE("brk"),		/* tchars.t_brkc */
#define XTTYMODE_brk	9
    TTYMODE("susp"),		/* ltchars.t_suspc ; VSUSP */
#define XTTYMODE_susp	10
    TTYMODE("dsusp"),		/* ltchars.t_dsuspc ; VDSUSP */
#define XTTYMODE_dsusp	11
    TTYMODE("rprnt"),		/* ltchars.t_rprntc ; VREPRINT */
#define XTTYMODE_rprnt	12
    TTYMODE("flush"),		/* ltchars.t_flushc ; VDISCARD */
#define XTTYMODE_flush	13
    TTYMODE("weras"),		/* ltchars.t_werasc ; VWERASE */
#define XTTYMODE_weras	14
    TTYMODE("lnext"),		/* ltchars.t_lnextc ; VLNEXT */
#define XTTYMODE_lnext	15
    TTYMODE("status"),		/* VSTATUS */
#define XTTYMODE_status	16
    TTYMODE("erase2"),		/* VERASE2 */
#define XTTYMODE_erase2	17
    TTYMODE("eol2"),		/* VEOL2 */
#define XTTYMODE_eol2	18
    { NULL,	0, 0, '\0' },	/* end of data */
};

#define validTtyChar(data, n) \
	    (known_ttyChars[n].sysMode >= 0 && \
	     known_ttyChars[n].sysMode < (int) XtNumber(data.c_cc))

static const struct {
    int sysMode;
    int myMode;
    int myDefault;
} known_ttyChars[] = {
#ifdef VINTR
    { VINTR,    XTTYMODE_intr,   CINTR },
#endif
#ifdef VQUIT
    { VQUIT,    XTTYMODE_quit,   CQUIT },
#endif
#ifdef VERASE
    { VERASE,   XTTYMODE_erase,  CERASE },
#endif
#ifdef VKILL
    { VKILL,    XTTYMODE_kill,   CKILL },
#endif
#ifdef VEOF
    { VEOF,     XTTYMODE_eof,    CEOF },
#endif
#ifdef VEOL
    { VEOL,     XTTYMODE_eol,    CEOL },
#endif
#ifdef VSWTCH
    { VSWTCH,   XTTYMODE_swtch,  CNUL },
#endif
#ifdef VSTART
    { VSTART,   XTTYMODE_start,  CSTART },
#endif
#ifdef VSTOP
    { VSTOP,    XTTYMODE_stop,   CSTOP },
#endif
#ifdef VSUSP
    { VSUSP,    XTTYMODE_susp,   CSUSP },
#endif
#ifdef VDSUSP
    { VDSUSP,   XTTYMODE_dsusp,  CDSUSP },
#endif
#ifdef VREPRINT
    { VREPRINT, XTTYMODE_rprnt,  CREPRINT },
#endif
#ifdef VDISCARD
    { VDISCARD, XTTYMODE_flush,  CDISCARD },
#endif
#ifdef VWERASE
    { VWERASE,  XTTYMODE_weras,  CWERASE },
#endif
#ifdef VLNEXT
    { VLNEXT,   XTTYMODE_lnext,  CLNEXT },
#endif
#ifdef VSTATUS
    { VSTATUS,  XTTYMODE_status, CSTATUS },
#endif
#ifdef VERASE2
    { VERASE2,  XTTYMODE_erase2, CERASE2 },
#endif
#ifdef VEOL2
    { VEOL2,    XTTYMODE_eol2,   CNUL },
#endif
};
/* *INDENT-ON* */

#define TMODE(ind,var) if (ttymodelist[ind].set) var = (cc_t) ttymodelist[ind].value

static int parse_tty_modes(char *s, struct _xttymodes *modelist);

#ifndef USE_UTEMPTER
#ifdef USE_SYSV_UTMP
#if (defined(AIXV3) && (OSMAJORVERSION < 4)) && !(defined(getutid))
extern struct utmp *getutid();
#endif /* AIXV3 */

#else /* not USE_SYSV_UTMP */
static char etc_utmp[] = UTMP_FILENAME;
#endif /* USE_SYSV_UTMP */

#if defined(USE_LASTLOG) && defined(USE_STRUCT_LASTLOG)
static char etc_lastlog[] = LASTLOG_FILENAME;
#else
#undef USE_LASTLOG
#endif

#ifdef WTMP
static char etc_wtmp[] = WTMP_FILENAME;
#endif
#endif /* !USE_UTEMPTER */

/*
 * Some people with 4.3bsd /bin/login seem to like to use login -p -f user
 * to implement xterm -ls.  They can turn on USE_LOGIN_DASH_P and turn off
 * WTMP and USE_LASTLOG.
 */
#ifdef USE_LOGIN_DASH_P
#ifndef LOGIN_FILENAME
#define LOGIN_FILENAME "/bin/login"
#endif
static char bin_login[] = LOGIN_FILENAME;
#endif

static char noPassedPty[2];
static char *passedPty = noPassedPty;	/* name if pty if slave */

#if defined(TIOCCONS) || defined(SRIOCSREDIR)
static int Console;
#include <X11/Xmu/SysUtil.h>	/* XmuGetHostname */
#define MIT_CONSOLE_LEN	12
#define MIT_CONSOLE "MIT_CONSOLE_"
static char mit_console_name[255 + MIT_CONSOLE_LEN + 1] = MIT_CONSOLE;
static Atom mit_console;
#endif /* TIOCCONS */

#ifndef USE_SYSV_UTMP
static int tslot;
#endif /* USE_SYSV_UTMP */
static sigjmp_buf env;

#define SetUtmpHost(dst, screen) \
	{ \
	    char host[sizeof(dst) + 1]; \
	    strncpy(host, DisplayString(screen->display), sizeof(host)); \
	    TRACE(("DisplayString(%s)\n", host)); \
	    if (!resource.utmpDisplayId) { \
		char *endptr = strrchr(host, ':'); \
		if (endptr) { \
		    TRACE(("trimming display-id '%s'\n", host)); \
		    *endptr = '\0'; \
		} \
	    } \
	    copy_filled(dst, host, sizeof(dst)); \
	}

#ifdef HAVE_UTMP_UT_SYSLEN
#  define SetUtmpSysLen(utmp) 			   \
	{ \
	    utmp.ut_host[sizeof(utmp.ut_host)-1] = '\0'; \
	    utmp.ut_syslen = strlen(utmp.ut_host) + 1; \
	}
#endif

/* used by VT (charproc.c) */

static XtResource application_resources[] =
{
    Sres("iconGeometry", "IconGeometry", icon_geometry, NULL),
    Sres(XtNtitle, XtCTitle, title, NULL),
    Sres(XtNiconHint, XtCIconHint, icon_hint, NULL),
    Sres(XtNiconName, XtCIconName, icon_name, NULL),
    Sres("termName", "TermName", term_name, NULL),
    Sres("ttyModes", "TtyModes", tty_modes, NULL),
    Bres("hold", "Hold", hold_screen, False),
    Bres("utmpInhibit", "UtmpInhibit", utmpInhibit, False),
    Bres("utmpDisplayId", "UtmpDisplayId", utmpDisplayId, True),
    Bres("messages", "Messages", messages, True),
    Ires("minBufSize", "MinBufSize", minBufSize, 4096),
    Ires("maxBufSize", "MaxBufSize", maxBufSize, 32768),
    Sres("menuLocale", "MenuLocale", menuLocale, DEF_MENU_LOCALE),
    Sres("omitTranslation", "OmitTranslation", omitTranslation, NULL),
    Sres("keyboardType", "KeyboardType", keyboardType, "unknown"),
#if OPT_PRINT_ON_EXIT
    Ires("printModeImmediate", "PrintModeImmediate", printModeNow, 0),
    Ires("printOptsImmediate", "PrintOptsImmediate", printOptsNow, 9),
    Sres("printFileImmediate", "PrintFileImmediate", printFileNow, NULL),
    Ires("printModeOnXError", "PrintModeOnXError", printModeOnXError, 0),
    Ires("printOptsOnXError", "PrintOptsOnXError", printOptsOnXError, 9),
    Sres("printFileOnXError", "PrintFileOnXError", printFileOnXError, NULL),
#endif
#if OPT_SUNPC_KBD
    Bres("sunKeyboard", "SunKeyboard", sunKeyboard, False),
#endif
#if OPT_HP_FUNC_KEYS
    Bres("hpFunctionKeys", "HpFunctionKeys", hpFunctionKeys, False),
#endif
#if OPT_SCO_FUNC_KEYS
    Bres("scoFunctionKeys", "ScoFunctionKeys", scoFunctionKeys, False),
#endif
#if OPT_SUN_FUNC_KEYS
    Bres("sunFunctionKeys", "SunFunctionKeys", sunFunctionKeys, False),
#endif
#if OPT_TCAP_FKEYS
    Bres("tcapFunctionKeys", "TcapFunctionKeys", termcapKeys, False),
#endif
#if OPT_INITIAL_ERASE
    Bres("ptyInitialErase", "PtyInitialErase", ptyInitialErase, DEF_INITIAL_ERASE),
    Bres("backarrowKeyIsErase", "BackarrowKeyIsErase", backarrow_is_erase, DEF_BACKARO_ERASE),
#endif
    Bres("useInsertMode", "UseInsertMode", useInsertMode, False),
#if OPT_ZICONBEEP
    Ires("zIconBeep", "ZIconBeep", zIconBeep, 0),
    Sres("zIconTitleFormat", "ZIconTitleFormat", zIconFormat, "*** %s"),
#endif
#if OPT_PTY_HANDSHAKE
    Bres("waitForMap", "WaitForMap", wait_for_map, False),
    Bres("ptyHandshake", "PtyHandshake", ptyHandshake, True),
    Bres("ptySttySize", "PtySttySize", ptySttySize, DEF_PTY_STTY_SIZE),
#endif
#if OPT_REPORT_COLORS
    Bres("reportColors", "ReportColors", reportColors, False),
#endif
#if OPT_REPORT_FONTS
    Bres("reportFonts", "ReportFonts", reportFonts, False),
#endif
#if OPT_SAME_NAME
    Bres("sameName", "SameName", sameName, True),
#endif
#if OPT_SESSION_MGT
    Bres("sessionMgt", "SessionMgt", sessionMgt, True),
#endif
#if OPT_TOOLBAR
    Bres(XtNtoolBar, XtCToolBar, toolBar, True),
#endif
#if OPT_MAXIMIZE
    Bres(XtNmaximized, XtCMaximized, maximized, False),
    Sres(XtNfullscreen, XtCFullscreen, fullscreen_s, "off"),
#endif
};

static String fallback_resources[] =
{
#if OPT_TOOLBAR
    "*toolBar: false",
#endif
    "*SimpleMenu*menuLabel.vertSpace: 100",
    "*SimpleMenu*HorizontalMargins: 16",
    "*SimpleMenu*Sme.height: 16",
    "*SimpleMenu*Cursor: left_ptr",
    "*mainMenu.Label:  Main Options (no app-defaults)",
    "*vtMenu.Label:  VT Options (no app-defaults)",
    "*fontMenu.Label:  VT Fonts (no app-defaults)",
#if OPT_TEK4014
    "*tekMenu.Label:  Tek Options (no app-defaults)",
#endif
    NULL
};

/* Command line options table.  Only resources are entered here...there is a
   pass over the remaining options after XrmParseCommand is let loose. */
/* *INDENT-OFF* */
static XrmOptionDescRec optionDescList[] = {
{"-geometry",	"*vt100.geometry",XrmoptionSepArg,	(XPointer) NULL},
{"-132",	"*c132",	XrmoptionNoArg,		(XPointer) "on"},
{"+132",	"*c132",	XrmoptionNoArg,		(XPointer) "off"},
{"-ah",		"*alwaysHighlight", XrmoptionNoArg,	(XPointer) "on"},
{"+ah",		"*alwaysHighlight", XrmoptionNoArg,	(XPointer) "off"},
{"-aw",		"*autoWrap",	XrmoptionNoArg,		(XPointer) "on"},
{"+aw",		"*autoWrap",	XrmoptionNoArg,		(XPointer) "off"},
#ifndef NO_ACTIVE_ICON
{"-ai",		"*activeIcon",	XrmoptionNoArg,		(XPointer) "off"},
{"+ai",		"*activeIcon",	XrmoptionNoArg,		(XPointer) "on"},
#endif /* NO_ACTIVE_ICON */
{"-b",		"*internalBorder",XrmoptionSepArg,	(XPointer) NULL},
{"-bc",		"*cursorBlink",	XrmoptionNoArg,		(XPointer) "on"},
{"+bc",		"*cursorBlink",	XrmoptionNoArg,		(XPointer) "off"},
{"-bcf",	"*cursorOffTime",XrmoptionSepArg,	(XPointer) NULL},
{"-bcn",	"*cursorOnTime",XrmoptionSepArg,	(XPointer) NULL},
{"-bdc",	"*colorBDMode",	XrmoptionNoArg,		(XPointer) "off"},
{"+bdc",	"*colorBDMode",	XrmoptionNoArg,		(XPointer) "on"},
{"-cb",		"*cutToBeginningOfLine", XrmoptionNoArg, (XPointer) "off"},
{"+cb",		"*cutToBeginningOfLine", XrmoptionNoArg, (XPointer) "on"},
{"-cc",		"*charClass",	XrmoptionSepArg,	(XPointer) NULL},
{"-cm",		"*colorMode",	XrmoptionNoArg,		(XPointer) "off"},
{"+cm",		"*colorMode",	XrmoptionNoArg,		(XPointer) "on"},
{"-cn",		"*cutNewline",	XrmoptionNoArg,		(XPointer) "off"},
{"+cn",		"*cutNewline",	XrmoptionNoArg,		(XPointer) "on"},
{"-cr",		"*cursorColor",	XrmoptionSepArg,	(XPointer) NULL},
{"-cu",		"*curses",	XrmoptionNoArg,		(XPointer) "on"},
{"+cu",		"*curses",	XrmoptionNoArg,		(XPointer) "off"},
{"-dc",		"*dynamicColors",XrmoptionNoArg,	(XPointer) "off"},
{"+dc",		"*dynamicColors",XrmoptionNoArg,	(XPointer) "on"},
{"-fb",		"*boldFont",	XrmoptionSepArg,	(XPointer) NULL},
{"-fbb",	"*freeBoldBox", XrmoptionNoArg,		(XPointer)"off"},
{"+fbb",	"*freeBoldBox", XrmoptionNoArg,		(XPointer)"on"},
{"-fbx",	"*forceBoxChars", XrmoptionNoArg,	(XPointer)"off"},
{"+fbx",	"*forceBoxChars", XrmoptionNoArg,	(XPointer)"on"},
#ifndef NO_ACTIVE_ICON
{"-fi",		"*iconFont",	XrmoptionSepArg,	(XPointer) NULL},
#endif /* NO_ACTIVE_ICON */
#if OPT_RENDERFONT
{"-fa",		"*faceName",	XrmoptionSepArg,	(XPointer) NULL},
{"-fd",		"*faceNameDoublesize", XrmoptionSepArg,	(XPointer) NULL},
{"-fs",		"*faceSize",	XrmoptionSepArg,	(XPointer) NULL},
#endif
#if OPT_WIDE_ATTRS && OPT_ISO_COLORS
{"-itc",	"*colorITMode",	XrmoptionNoArg,		(XPointer) "off"},
{"+itc",	"*colorITMode",	XrmoptionNoArg,		(XPointer) "on"},
#endif
#if OPT_WIDE_CHARS
{"-fw",		"*wideFont",	XrmoptionSepArg,	(XPointer) NULL},
{"-fwb",	"*wideBoldFont", XrmoptionSepArg,	(XPointer) NULL},
#endif
#if OPT_INPUT_METHOD
{"-fx",		"*ximFont",	XrmoptionSepArg,	(XPointer) NULL},
#endif
#if OPT_HIGHLIGHT_COLOR
{"-hc",		"*highlightColor", XrmoptionSepArg,	(XPointer) NULL},
{"-hm",		"*highlightColorMode", XrmoptionNoArg,	(XPointer) "on"},
{"+hm",		"*highlightColorMode", XrmoptionNoArg,	(XPointer) "off"},
{"-selfg",	"*highlightTextColor", XrmoptionSepArg,	(XPointer) NULL},
{"-selbg",	"*highlightColor", XrmoptionSepArg,	(XPointer) NULL},
#endif
#if OPT_HP_FUNC_KEYS
{"-hf",		"*hpFunctionKeys",XrmoptionNoArg,	(XPointer) "on"},
{"+hf",		"*hpFunctionKeys",XrmoptionNoArg,	(XPointer) "off"},
#endif
{"-hold",	"*hold",	XrmoptionNoArg,		(XPointer) "on"},
{"+hold",	"*hold",	XrmoptionNoArg,		(XPointer) "off"},
#if OPT_INITIAL_ERASE
{"-ie",		"*ptyInitialErase", XrmoptionNoArg,	(XPointer) "on"},
{"+ie",		"*ptyInitialErase", XrmoptionNoArg,	(XPointer) "off"},
#endif
{"-j",		"*jumpScroll",	XrmoptionNoArg,		(XPointer) "on"},
{"+j",		"*jumpScroll",	XrmoptionNoArg,		(XPointer) "off"},
#if OPT_C1_PRINT
{"-k8",		"*allowC1Printable", XrmoptionNoArg,	(XPointer) "on"},
{"+k8",		"*allowC1Printable", XrmoptionNoArg,	(XPointer) "off"},
#endif
{"-kt",		"*keyboardType", XrmoptionSepArg,	(XPointer) NULL},
/* parse logging options anyway for compatibility */
{"-l",		"*logging",	XrmoptionNoArg,		(XPointer) "on"},
{"+l",		"*logging",	XrmoptionNoArg,		(XPointer) "off"},
{"-lf",		"*logFile",	XrmoptionSepArg,	(XPointer) NULL},
{"-ls",		"*loginShell",	XrmoptionNoArg,		(XPointer) "on"},
{"+ls",		"*loginShell",	XrmoptionNoArg,		(XPointer) "off"},
{"-mb",		"*marginBell",	XrmoptionNoArg,		(XPointer) "on"},
{"+mb",		"*marginBell",	XrmoptionNoArg,		(XPointer) "off"},
{"-mc",		"*multiClickTime", XrmoptionSepArg,	(XPointer) NULL},
{"-mesg",	"*messages",	XrmoptionNoArg,		(XPointer) "off"},
{"+mesg",	"*messages",	XrmoptionNoArg,		(XPointer) "on"},
{"-ms",		"*pointerColor",XrmoptionSepArg,	(XPointer) NULL},
{"-nb",		"*nMarginBell",	XrmoptionSepArg,	(XPointer) NULL},
{"-nul",	"*underLine",	XrmoptionNoArg,		(XPointer) "off"},
{"+nul",	"*underLine",	XrmoptionNoArg,		(XPointer) "on"},
{"-pc",		"*boldColors",	XrmoptionNoArg,		(XPointer) "on"},
{"+pc",		"*boldColors",	XrmoptionNoArg,		(XPointer) "off"},
{"-rw",		"*reverseWrap",	XrmoptionNoArg,		(XPointer) "on"},
{"+rw",		"*reverseWrap",	XrmoptionNoArg,		(XPointer) "off"},
{"-s",		"*multiScroll",	XrmoptionNoArg,		(XPointer) "on"},
{"+s",		"*multiScroll",	XrmoptionNoArg,		(XPointer) "off"},
{"-sb",		"*scrollBar",	XrmoptionNoArg,		(XPointer) "on"},
{"+sb",		"*scrollBar",	XrmoptionNoArg,		(XPointer) "off"},
#if OPT_REPORT_COLORS
{"-report-colors","*reportColors", XrmoptionNoArg,	(XPointer) "on"},
#endif
#if OPT_REPORT_FONTS
{"-report-fonts","*reportFonts", XrmoptionNoArg,	(XPointer) "on"},
#endif
#ifdef SCROLLBAR_RIGHT
{"-leftbar",	"*rightScrollBar", XrmoptionNoArg,	(XPointer) "off"},
{"-rightbar",	"*rightScrollBar", XrmoptionNoArg,	(XPointer) "on"},
#endif
{"-rvc",	"*colorRVMode",	XrmoptionNoArg,		(XPointer) "off"},
{"+rvc",	"*colorRVMode",	XrmoptionNoArg,		(XPointer) "on"},
{"-sf",		"*sunFunctionKeys", XrmoptionNoArg,	(XPointer) "on"},
{"+sf",		"*sunFunctionKeys", XrmoptionNoArg,	(XPointer) "off"},
{"-sh",		"*scaleHeight", XrmoptionSepArg,	(XPointer) NULL},
{"-si",		"*scrollTtyOutput", XrmoptionNoArg,	(XPointer) "off"},
{"+si",		"*scrollTtyOutput", XrmoptionNoArg,	(XPointer) "on"},
{"-sk",		"*scrollKey",	XrmoptionNoArg,		(XPointer) "on"},
{"+sk",		"*scrollKey",	XrmoptionNoArg,		(XPointer) "off"},
{"-sl",		"*saveLines",	XrmoptionSepArg,	(XPointer) NULL},
#if OPT_SUNPC_KBD
{"-sp",		"*sunKeyboard", XrmoptionNoArg,		(XPointer) "on"},
{"+sp",		"*sunKeyboard", XrmoptionNoArg,		(XPointer) "off"},
#endif
#if OPT_TEK4014
{"-t",		"*tekStartup",	XrmoptionNoArg,		(XPointer) "on"},
{"+t",		"*tekStartup",	XrmoptionNoArg,		(XPointer) "off"},
#endif
{"-ti",		"*decTerminalID",XrmoptionSepArg,	(XPointer) NULL},
{"-tm",		"*ttyModes",	XrmoptionSepArg,	(XPointer) NULL},
{"-tn",		"*termName",	XrmoptionSepArg,	(XPointer) NULL},
#if OPT_WIDE_CHARS
{"-u8",		"*utf8",	XrmoptionNoArg,		(XPointer) "2"},
{"+u8",		"*utf8",	XrmoptionNoArg,		(XPointer) "0"},
#endif
#if OPT_LUIT_PROG
{"-lc",		"*locale",	XrmoptionNoArg,		(XPointer) "on"},
{"+lc",		"*locale",	XrmoptionNoArg,		(XPointer) "off"},
{"-lcc",	"*localeFilter",XrmoptionSepArg,	(XPointer) NULL},
{"-en",		"*locale",	XrmoptionSepArg,	(XPointer) NULL},
#endif
{"-uc",		"*cursorUnderLine", XrmoptionNoArg,	(XPointer) "on"},
{"+uc",		"*cursorUnderLine", XrmoptionNoArg,	(XPointer) "off"},
{"-ulc",	"*colorULMode",	XrmoptionNoArg,		(XPointer) "off"},
{"+ulc",	"*colorULMode",	XrmoptionNoArg,		(XPointer) "on"},
{"-ulit",       "*italicULMode", XrmoptionNoArg,        (XPointer) "off"},
{"+ulit",       "*italicULMode", XrmoptionNoArg,        (XPointer) "on"},
{"-ut",		"*utmpInhibit",	XrmoptionNoArg,		(XPointer) "on"},
{"+ut",		"*utmpInhibit",	XrmoptionNoArg,		(XPointer) "off"},
{"-im",		"*useInsertMode", XrmoptionNoArg,	(XPointer) "on"},
{"+im",		"*useInsertMode", XrmoptionNoArg,	(XPointer) "off"},
{"-vb",		"*visualBell",	XrmoptionNoArg,		(XPointer) "on"},
{"+vb",		"*visualBell",	XrmoptionNoArg,		(XPointer) "off"},
{"-pob",	"*popOnBell",	XrmoptionNoArg,		(XPointer) "on"},
{"+pob",	"*popOnBell",	XrmoptionNoArg,		(XPointer) "off"},
#if OPT_WIDE_CHARS
{"-wc",		"*wideChars",	XrmoptionNoArg,		(XPointer) "on"},
{"+wc",		"*wideChars",	XrmoptionNoArg,		(XPointer) "off"},
{"-mk_width",	"*mkWidth",	XrmoptionNoArg,		(XPointer) "on"},
{"+mk_width",	"*mkWidth",	XrmoptionNoArg,		(XPointer) "off"},
{"-cjk_width",	"*cjkWidth",	XrmoptionNoArg,		(XPointer) "on"},
{"+cjk_width",	"*cjkWidth",	XrmoptionNoArg,		(XPointer) "off"},
#endif
{"-wf",		"*waitForMap",	XrmoptionNoArg,		(XPointer) "on"},
{"+wf",		"*waitForMap",	XrmoptionNoArg,		(XPointer) "off"},
#if OPT_ZICONBEEP
{"-ziconbeep",	"*zIconBeep",	XrmoptionSepArg,	(XPointer) NULL},
#endif
#if OPT_SAME_NAME
{"-samename",	"*sameName",	XrmoptionNoArg,		(XPointer) "on"},
{"+samename",	"*sameName",	XrmoptionNoArg,		(XPointer) "off"},
#endif
#if OPT_SESSION_MGT
{"-sm",		"*sessionMgt",	XrmoptionNoArg,		(XPointer) "on"},
{"+sm",		"*sessionMgt",	XrmoptionNoArg,		(XPointer) "off"},
#endif
#if OPT_TOOLBAR
{"-tb",		"*"XtNtoolBar,	XrmoptionNoArg,		(XPointer) "on"},
{"+tb",		"*"XtNtoolBar,	XrmoptionNoArg,		(XPointer) "off"},
#endif
#if OPT_MAXIMIZE
{"-maximized",	"*maximized",	XrmoptionNoArg,		(XPointer) "on"},
{"+maximized",	"*maximized",	XrmoptionNoArg,		(XPointer) "off"},
{"-fullscreen",	"*fullscreen",	XrmoptionNoArg,		(XPointer) "on"},
{"+fullscreen",	"*fullscreen",	XrmoptionNoArg,		(XPointer) "off"},
#endif
/* options that we process ourselves */
{"-help",	NULL,		XrmoptionSkipNArgs,	(XPointer) NULL},
{"-version",	NULL,		XrmoptionSkipNArgs,	(XPointer) NULL},
{"-baudrate",	NULL,		XrmoptionSkipArg,	(XPointer) NULL},
{"-class",	NULL,		XrmoptionSkipArg,	(XPointer) NULL},
{"-e",		NULL,		XrmoptionSkipLine,	(XPointer) NULL},
{"-into",	NULL,		XrmoptionSkipArg,	(XPointer) NULL},
/* bogus old compatibility stuff for which there are
   standard XtOpenApplication options now */
{"%",		"*tekGeometry",	XrmoptionStickyArg,	(XPointer) NULL},
{"#",		".iconGeometry",XrmoptionStickyArg,	(XPointer) NULL},
{"-T",		".title",	XrmoptionSepArg,	(XPointer) NULL},
{"-n",		"*iconName",	XrmoptionSepArg,	(XPointer) NULL},
{"-r",		"*reverseVideo",XrmoptionNoArg,		(XPointer) "on"},
{"+r",		"*reverseVideo",XrmoptionNoArg,		(XPointer) "off"},
{"-rv",		"*reverseVideo",XrmoptionNoArg,		(XPointer) "on"},
{"+rv",		"*reverseVideo",XrmoptionNoArg,		(XPointer) "off"},
{"-w",		".borderWidth", XrmoptionSepArg,	(XPointer) NULL},
};

static OptionHelp xtermOptions[] = {
{ "-version",              "print the version number" },
{ "-help",                 "print out this message" },
{ "-display displayname",  "X server to contact" },
{ "-geometry geom",        "size (in characters) and position" },
{ "-/+rv",                 "turn on/off reverse video" },
{ "-bg color",             "background color" },
{ "-fg color",             "foreground color" },
{ "-bd color",             "border color" },
{ "-bw number",            "border width in pixels" },
{ "-fn fontname",          "normal text font" },
{ "-fb fontname",          "bold text font" },
{ "-/+fbb",                "turn on/off normal/bold font comparison inhibit"},
{ "-/+fbx",                "turn off/on linedrawing characters"},
#if OPT_RENDERFONT
{ "-fa pattern",           "FreeType font-selection pattern" },
{ "-fd pattern",           "FreeType Doublesize font-selection pattern" },
{ "-fs size",              "FreeType font-size" },
#endif
#if OPT_WIDE_CHARS
{ "-fw fontname",          "doublewidth text font" },
{ "-fwb fontname",         "doublewidth bold text font" },
#endif
#if OPT_INPUT_METHOD
{ "-fx fontname",          "XIM fontset" },
#endif
{ "-iconic",               "start iconic" },
{ "-name string",          "client instance, icon, and title strings" },
{ "-baudrate rate",        "set line-speed (default 38400)" },
{ "-class string",         "class string (XTerm)" },
{ "-title string",         "title string" },
{ "-xrm resourcestring",   "additional resource specifications" },
{ "-/+132",                "turn on/off 80/132 column switching" },
{ "-/+ah",                 "turn on/off always highlight" },
#ifndef NO_ACTIVE_ICON
{ "-/+ai",                 "turn off/on active icon" },
{ "-fi fontname",          "icon font for active icon" },
#endif /* NO_ACTIVE_ICON */
{ "-b number",             "internal border in pixels" },
{ "-/+bc",                 "turn on/off text cursor blinking" },
{ "-bcf milliseconds",     "time text cursor is off when blinking"},
{ "-bcn milliseconds",     "time text cursor is on when blinking"},
{ "-/+bdc",                "turn off/on display of bold as color"},
{ "-/+cb",                 "turn on/off cut-to-beginning-of-line inhibit" },
{ "-cc classrange",        "specify additional character classes" },
{ "-/+cm",                 "turn off/on ANSI color mode" },
{ "-/+cn",                 "turn on/off cut newline inhibit" },
{ "-cr color",             "text cursor color" },
{ "-/+cu",                 "turn on/off curses emulation" },
{ "-/+dc",                 "turn off/on dynamic color selection" },
#if OPT_HIGHLIGHT_COLOR
{ "-/+hm",                 "turn on/off selection-color override" },
{ "-selbg color",          "selection background color" },
{ "-selfg color",          "selection foreground color" },
/* -hc is deprecated, not shown in help message */
#endif
#if OPT_HP_FUNC_KEYS
{ "-/+hf",                 "turn on/off HP Function Key escape codes" },
#endif
{ "-/+hold",               "turn on/off logic that retains window after exit" },
#if OPT_INITIAL_ERASE
{ "-/+ie",                 "turn on/off initialization of 'erase' from pty" },
#endif
{ "-/+im",                 "use insert mode for TERMCAP" },
{ "-/+j",                  "turn on/off jump scroll" },
#if OPT_C1_PRINT
{ "-/+k8",                 "turn on/off C1-printable classification"},
#endif
{ "-kt keyboardtype",      "set keyboard type:" KEYBOARD_TYPES },
#ifdef ALLOWLOGGING
{ "-/+l",                  "turn on/off logging" },
{ "-lf filename",          "logging filename" },
#else
{ "-/+l",                  "turn on/off logging (not supported)" },
{ "-lf filename",          "logging filename (not supported)" },
#endif
{ "-/+ls",                 "turn on/off login shell" },
{ "-/+mb",                 "turn on/off margin bell" },
{ "-mc milliseconds",      "multiclick time in milliseconds" },
{ "-/+mesg",               "forbid/allow messages" },
{ "-ms color",             "pointer color" },
{ "-nb number",            "margin bell in characters from right end" },
{ "-/+nul",                "turn off/on display of underlining" },
{ "-/+aw",                 "turn on/off auto wraparound" },
{ "-/+pc",                 "turn on/off PC-style bold colors" },
{ "-/+rw",                 "turn on/off reverse wraparound" },
{ "-/+s",                  "turn on/off multiscroll" },
{ "-/+sb",                 "turn on/off scrollbar" },
#if OPT_REPORT_COLORS
{ "-report-colors",        "report colors as they are allocated" },
#endif
#if OPT_REPORT_FONTS
{ "-report-fonts",         "report fonts as loaded to stdout" },
#endif
#ifdef SCROLLBAR_RIGHT
{ "-rightbar",             "force scrollbar right (default left)" },
{ "-leftbar",              "force scrollbar left" },
#endif
{ "-/+rvc",                "turn off/on display of reverse as color" },
{ "-/+sf",                 "turn on/off Sun Function Key escape codes" },
{ "-sh number",            "scale line-height values by the given number" },
{ "-/+si",                 "turn on/off scroll-on-tty-output inhibit" },
{ "-/+sk",                 "turn on/off scroll-on-keypress" },
{ "-sl number",            "number of scrolled lines to save" },
#if OPT_SUNPC_KBD
{ "-/+sp",                 "turn on/off Sun/PC Function/Keypad mapping" },
#endif
#if OPT_TEK4014
{ "-/+t",                  "turn on/off Tek emulation window" },
#endif
#if OPT_TOOLBAR
{ "-/+tb",                 "turn on/off toolbar" },
#endif
{ "-ti termid",            "terminal identifier" },
{ "-tm string",            "terminal mode keywords and characters" },
{ "-tn name",              "TERM environment variable name" },
#if OPT_WIDE_CHARS
{ "-/+u8",                 "turn on/off UTF-8 mode (implies wide-characters)" },
#endif
#if OPT_LUIT_PROG
{ "-/+lc",                 "turn on/off locale mode using luit" },
{ "-lcc path",             "filename of locale converter (" DEFLOCALEFILTER ")" },
/* -en is deprecated, not shown in help message */
#endif
{ "-/+uc",                 "turn on/off underline cursor" },
{ "-/+ulc",                "turn off/on display of underline as color" },
{ "-/+ulit",               "turn off/on display of underline as italics" },
#ifdef HAVE_UTMP
{ "-/+ut",                 "turn on/off utmp support" },
#else
{ "-/+ut",                 "turn on/off utmp support (not available)" },
#endif
{ "-/+vb",                 "turn on/off visual bell" },
{ "-/+pob",                "turn on/off pop on bell" },
#if OPT_WIDE_ATTRS && OPT_ISO_COLORS
{ "-/+itc",                "turn off/on display of italic as color"},
#endif
#if OPT_WIDE_CHARS
{ "-/+wc",                 "turn on/off wide-character mode" },
{ "-/+mk_width",           "turn on/off simple width convention" },
{ "-/+cjk_width",          "turn on/off legacy CJK width convention" },
#endif
{ "-/+wf",                 "turn on/off wait for map before command exec" },
{ "-e command args ...",   "command to execute" },
#if OPT_TEK4014
{ "%geom",                 "Tek window geometry" },
#endif
{ "#geom",                 "icon window geometry" },
{ "-T string",             "title name for window" },
{ "-n string",             "icon name for window" },
#if defined(TIOCCONS) || defined(SRIOCSREDIR)
{ "-C",                    "intercept console messages" },
#else
{ "-C",                    "intercept console messages (not supported)" },
#endif
{ "-Sccn",                 "slave mode on \"ttycc\", file descriptor \"n\"" },
{ "-into windowId",        "use the window id given to -into as the parent window rather than the default root window" },
#if OPT_ZICONBEEP
{ "-ziconbeep percent",    "beep and flag icon of window having hidden output" },
#endif
#if OPT_SAME_NAME
{ "-/+samename",           "turn on/off the no-flicker option for title and icon name" },
#endif
#if OPT_SESSION_MGT
{ "-/+sm",                 "turn on/off the session-management support" },
#endif
#if OPT_MAXIMIZE
{"-/+maximized",           "turn on/off maxmize on startup" },
{"-/+fullscreen",          "turn on/off fullscreen on startup" },
#endif
{ NULL, NULL }};
/* *INDENT-ON* */

static const char *const message[] =
{
    "Fonts should be fixed width and, if both normal and bold are specified, should",
    "have the same size.  If only a normal font is specified, it will be used for",
    "both normal and bold text (by doing overstriking).  The -e option, if given,",
    "must appear at the end of the command line, otherwise the user's default shell",
    "will be started.  Options that start with a plus sign (+) restore the default.",
    NULL};

/*
 * Decode a key-definition.  This combines the termcap and ttyModes, for
 * comparison.  Note that octal escapes in ttyModes are done by the normal
 * resource translation.  Also, ttyModes allows '^-' as a synonym for disabled.
 */
static int
decode_keyvalue(char **ptr, int termcap)
{
    char *string = *ptr;
    int value = -1;

    TRACE(("decode_keyvalue '%s'\n", string));
    if (*string == '^') {
	switch (*++string) {
	case '?':
	    value = A2E(ANSI_DEL);
	    break;
	case '-':
	    if (!termcap) {
		errno = 0;
#if defined(_POSIX_VDISABLE) && defined(HAVE_UNISTD_H)
		value = _POSIX_VDISABLE;
#endif
#if defined(_PC_VDISABLE)
		if (value == -1) {
		    value = (int) fpathconf(0, _PC_VDISABLE);
		    if (value == -1) {
			if (errno != 0)
			    break;	/* skip this (error) */
			value = 0377;
		    }
		}
#elif defined(VDISABLE)
		if (value == -1)
		    value = VDISABLE;
#endif
		break;
	    }
	    /* FALLTHRU */
	default:
	    value = CONTROL(*string);
	    break;
	}
	++string;
    } else if (termcap && (*string == '\\')) {
	char *s = (string + 1);
	char *d;
	int temp = (int) strtol(s, &d, 8);
	if (PartS2L(s, d) && temp > 0) {
	    value = temp;
	    string = d;
	}
    } else {
	value = CharOf(*string);
	++string;
    }
    *ptr = string;
    TRACE(("...decode_keyvalue %#x\n", value));
    return value;
}

static int
matchArg(XrmOptionDescRec * table, const char *param)
{
    int result = -1;
    int n;
    int ch;

    for (n = 0; (ch = table->option[n]) != '\0'; ++n) {
	if (param[n] == ch) {
	    result = n;
	} else {
	    if (param[n] != '\0')
		result = -1;
	    break;
	}
    }

    return result;
}

/* return the number of argv[] entries which constitute arguments of option */
static int
countArg(XrmOptionDescRec * item)
{
    int result = 0;

    switch (item->argKind) {
    case XrmoptionNoArg:
	/* FALLTHRU */
    case XrmoptionIsArg:
	/* FALLTHRU */
    case XrmoptionStickyArg:
	break;
    case XrmoptionSepArg:
	/* FALLTHRU */
    case XrmoptionResArg:
	/* FALLTHRU */
    case XrmoptionSkipArg:
	result = 1;
	break;
    case XrmoptionSkipLine:
	break;
    case XrmoptionSkipNArgs:
	result = (int) (long) (item->value);
	break;
    }
    return result;
}

#define isOption(string) (Boolean)((string)[0] == '-' || (string)[0] == '+')

/*
 * Parse the argument list, more/less as XtInitialize, etc., would do, so we
 * can find our own "-help" and "-version" options reliably.  Improve on just
 * doing that, by detecting ambiguous options (things that happen to match the
 * abbreviated option we are examining), and making it smart enough to handle
 * "-d" as an abbreviation for "-display".  Doing this requires checking the
 * standard table (something that the X libraries should do).
 */
static XrmOptionDescRec *
parseArg(int *num, char **argv, char **valuep)
{
    /* table adapted from XtInitialize, used here to improve abbreviations */
    /* *INDENT-OFF* */
#define DATA(option,kind) { option, NULL, kind, (XtPointer) NULL }
    static XrmOptionDescRec opTable[] = {
	DATA("+synchronous",	   XrmoptionNoArg),
	DATA("-background",	   XrmoptionSepArg),
	DATA("-bd",		   XrmoptionSepArg),
	DATA("-bg",		   XrmoptionSepArg),
	DATA("-bordercolor",	   XrmoptionSepArg),
	DATA("-borderwidth",	   XrmoptionSepArg),
	DATA("-bw",		   XrmoptionSepArg),
	DATA("-display",	   XrmoptionSepArg),
	DATA("-fg",		   XrmoptionSepArg),
	DATA("-fn",		   XrmoptionSepArg),
	DATA("-font",		   XrmoptionSepArg),
	DATA("-foreground",	   XrmoptionSepArg),
	DATA("-iconic",		   XrmoptionNoArg),
	DATA("-name",		   XrmoptionSepArg),
	DATA("-reverse",	   XrmoptionNoArg),
	DATA("-selectionTimeout",  XrmoptionSepArg),
	DATA("-synchronous",	   XrmoptionNoArg),
	DATA("-title",		   XrmoptionSepArg),
	DATA("-xnllanguage",	   XrmoptionSepArg),
	DATA("-xrm",		   XrmoptionResArg),
	DATA("-xtsessionID",	   XrmoptionSepArg),
	/* These xterm options are processed after XtOpenApplication */
#if defined(TIOCCONS) || defined(SRIOCSREDIR)
	DATA("-C",		   XrmoptionNoArg),
#endif /* TIOCCONS */
	DATA("-S",		   XrmoptionStickyArg),
	DATA("-D",		   XrmoptionNoArg),
    };
#undef DATA
    /* *INDENT-ON* */

    XrmOptionDescRec *result = 0;
    Cardinal inlist;
    Cardinal limit = XtNumber(optionDescList) + XtNumber(opTable);
    int atbest = -1;
    int best = -1;
    int test;
    Boolean exact = False;
    int ambiguous1 = -1;
    int ambiguous2 = -1;
    char *option;
    char *value;

#define ITEM(n) ((Cardinal)(n) < XtNumber(optionDescList) \
		 ? &optionDescList[n] \
		 : &opTable[(Cardinal)(n) - XtNumber(optionDescList)])

    if ((option = argv[*num]) != 0) {
	Boolean need_value;
	Boolean have_value = False;

	TRACE(("parseArg %s\n", option));
	if ((value = argv[(*num) + 1]) != 0) {
	    have_value = (Boolean) !isOption(value);
	}
	for (inlist = 0; inlist < limit; ++inlist) {
	    XrmOptionDescRec *check = ITEM(inlist);

	    test = matchArg(check, option);
	    if (test < 0)
		continue;

	    /* check for exact match */
	    if ((test + 1) == (int) strlen(check->option)) {
		if (check->argKind == XrmoptionStickyArg) {
		    if (strlen(option) > strlen(check->option)) {
			exact = True;
			atbest = (int) inlist;
			break;
		    }
		} else if ((test + 1) == (int) strlen(option)) {
		    exact = True;
		    atbest = (int) inlist;
		    break;
		}
	    }

	    need_value = (Boolean) (test > 0 && countArg(check) > 0);

	    if (need_value && value != 0) {
		;
	    } else if (need_value ^ have_value) {
		TRACE(("...skipping, need %d vs have %d\n", need_value, have_value));
		continue;
	    }

	    /* special-case for our own options - always allow abbreviation */
	    if (test > 0
		&& ITEM(inlist)->argKind >= XrmoptionSkipArg) {
		atbest = (int) inlist;
		if (ITEM(inlist)->argKind == XrmoptionSkipNArgs) {
		    /* in particular, silence a warning about ambiguity */
		    exact = 1;
		}
		break;
	    }
	    if (test > best) {
		best = test;
		atbest = (int) inlist;
	    } else if (test == best) {
		if (atbest >= 0) {
		    if (atbest > 0) {
			ambiguous1 = (int) inlist;
			ambiguous2 = (int) atbest;
		    }
		    atbest = -1;
		}
	    }
	}
    }

    *valuep = 0;
    if (atbest >= 0) {
	result = ITEM(atbest);
	if (!exact) {
	    if (ambiguous1 >= 0 && ambiguous2 >= 0) {
		xtermWarning("ambiguous option \"%s\" vs \"%s\"\n",
			     ITEM(ambiguous1)->option,
			     ITEM(ambiguous2)->option);
	    } else if (strlen(option) > strlen(result->option)) {
		result = 0;
	    }
	}
	if (result != 0) {
	    TRACE(("...result %s\n", result->option));
	    /* expand abbreviations */
	    if (result->argKind != XrmoptionStickyArg) {
		if (strcmp(argv[*num], result->option)) {
		    argv[*num] = x_strdup(result->option);
		}
	    }

	    /* adjust (*num) to skip option value */
	    (*num) += countArg(result);
	    TRACE(("...next %s\n", NonNull(argv[*num])));
	    if (result->argKind == XrmoptionSkipArg) {
		*valuep = argv[*num];
		TRACE(("...parameter %s\n", NonNull(*valuep)));
	    }
	}
    }
#undef ITEM
    return result;
}

static void
Syntax(char *badOption)
{
    OptionHelp *opt;
    OptionHelp *list = sortedOpts(xtermOptions, optionDescList, XtNumber(optionDescList));
    int col;

    TRACE(("Syntax error at %s\n", badOption));
    xtermWarning("bad command line option \"%s\"\r\n\n", badOption);

    fprintf(stderr, "usage:  %s", ProgramName);
    col = 8 + (int) strlen(ProgramName);
    for (opt = list; opt->opt; opt++) {
	int len = 3 + (int) strlen(opt->opt);	/* space [ string ] */
	if (col + len > 79) {
	    fprintf(stderr, "\r\n   ");		/* 3 spaces */
	    col = 3;
	}
	fprintf(stderr, " [%s]", opt->opt);
	col += len;
    }

    fprintf(stderr, "\r\n\nType %s -help for a full description.\r\n\n",
	    ProgramName);
    exit(1);
}

static void
Version(void)
{
    printf("%s\n", xtermVersion());
    fflush(stdout);
}

static void
Help(void)
{
    OptionHelp *opt;
    OptionHelp *list = sortedOpts(xtermOptions, optionDescList, XtNumber(optionDescList));
    const char *const *cpp;

    printf("%s usage:\n    %s [-options ...] [-e command args]\n\n",
	   xtermVersion(), ProgramName);
    printf("where options include:\n");
    for (opt = list; opt->opt; opt++) {
	printf("    %-28s %s\n", opt->opt, opt->desc);
    }

    putchar('\n');
    for (cpp = message; *cpp; cpp++)
	puts(*cpp);
    putchar('\n');
    fflush(stdout);
}

#if defined(TIOCCONS) || defined(SRIOCSREDIR)
/* ARGSUSED */
static Boolean
ConvertConsoleSelection(Widget w GCC_UNUSED,
			Atom *selection GCC_UNUSED,
			Atom *target GCC_UNUSED,
			Atom *type GCC_UNUSED,
			XtPointer *value GCC_UNUSED,
			unsigned long *length GCC_UNUSED,
			int *format GCC_UNUSED)
{
    /* we don't save console output, so can't offer it */
    return False;
}
#endif /* TIOCCONS */

/*
 * DeleteWindow(): Action proc to implement ICCCM delete_window.
 */
/* ARGSUSED */
static void
DeleteWindow(Widget w,
	     XEvent *event GCC_UNUSED,
	     String *params GCC_UNUSED,
	     Cardinal *num_params GCC_UNUSED)
{
#if OPT_TEK4014
    if (w == toplevel) {
	if (TEK4014_SHOWN(term))
	    hide_vt_window();
	else
	    do_hangup(w, (XtPointer) 0, (XtPointer) 0);
    } else if (TScreenOf(term)->Vshow)
	hide_tek_window();
    else
#endif
	do_hangup(w, (XtPointer) 0, (XtPointer) 0);
}

/* ARGSUSED */
static void
KeyboardMapping(Widget w GCC_UNUSED,
		XEvent *event,
		String *params GCC_UNUSED,
		Cardinal *num_params GCC_UNUSED)
{
    switch (event->type) {
    case MappingNotify:
	XRefreshKeyboardMapping(&event->xmapping);
	break;
    }
}

static XtActionsRec actionProcs[] =
{
    {"DeleteWindow", DeleteWindow},
    {"KeyboardMapping", KeyboardMapping},
};

/*
 * Some platforms use names such as /dev/tty01, others /dev/pts/1.  Parse off
 * the "tty01" or "pts/1" portion, and return that for use as an identifier for
 * utmp.
 */
static char *
my_pty_name(char *device)
{
    size_t len = strlen(device);
    Bool name = False;

    while (len != 0) {
	int ch = device[len - 1];
	if (isdigit(ch)) {
	    len--;
	} else if (ch == '/') {
	    if (name)
		break;
	    len--;
	} else if (isalpha(ch)) {
	    name = True;
	    len--;
	} else {
	    break;
	}
    }
    TRACE(("my_pty_name(%s) -> '%s'\n", device, device + len));
    return device + len;
}

/*
 * If the name contains a '/', it is a "pts/1" case.  Otherwise, return the
 * last few characters for a utmp identifier.
 */
static char *
my_pty_id(char *device)
{
    char *name = my_pty_name(device);
    char *leaf = x_basename(name);

    if (name == leaf) {		/* no '/' in the name */
	int len = (int) strlen(leaf);
	if (PTYCHARLEN < len)
	    leaf = leaf + (len - PTYCHARLEN);
    }
    TRACE(("my_pty_id  (%s) -> '%s'\n", device, leaf));
    return leaf;
}

/*
 * Set the tty/pty identifier
 */
static void
set_pty_id(char *device, char *id)
{
    char *name = my_pty_name(device);
    char *leaf = x_basename(name);

    if (name == leaf) {
	strcpy(my_pty_id(device), id);
    } else {
	strcpy(leaf, id);
    }
    TRACE(("set_pty_id(%s) -> '%s'\n", id, device));
}

/*
 * The original -S option accepts two characters to identify the pty, and a
 * file-descriptor (assumed to be nonzero).  That is not general enough, so we
 * check first if the option contains a '/' to delimit the two fields, and if
 * not, fall-thru to the original logic.
 */
static Bool
ParseSccn(char *option)
{
    char *leaf = x_basename(option);
    Bool code = False;

    passedPty = x_strdup(option);
    if (leaf != option) {
	if (leaf - option > 0
	    && isdigit(CharOf(*leaf))
	    && sscanf(leaf, "%d", &am_slave) == 1) {
	    size_t len = (size_t) (leaf - option - 1);
	    /*
	     * If we have a slash, we only care about the part after the slash,
	     * which is a file-descriptor.  The part before the slash can be
	     * the /dev/pts/XXX value, but since we do not need to reopen it,
	     * it is useful mainly for display in a "ps -ef".
	     */
	    passedPty[len] = 0;
	    code = True;
	}
    } else {
	code = (sscanf(option, "%c%c%d",
		       passedPty, passedPty + 1, &am_slave) == 3);
	passedPty[2] = '\0';
    }
    TRACE(("ParseSccn(%s) = '%s' %d (%s)\n", option,
	   passedPty, am_slave, code ? "OK" : "ERR"));
    return code;
}

#if defined(USE_SYSV_UTMP) && !defined(USE_UTEMPTER)
/*
 * From "man utmp":
 * xterm and other terminal emulators directly create a USER_PROCESS record
 * and generate the ut_id by using the last two letters of /dev/ttyp%c or by
 * using p%d for /dev/pts/%d.  If they find a DEAD_PROCESS for this id, they
 * recycle it, otherwise they create a new entry.  If they can, they will mark
 * it as DEAD_PROCESS on exiting and it is advised that they null ut_line,
 * ut_time, ut_user and ut_host as well.
 *
 * Generally ut_id allows no more than 3 characters (plus null), even if the
 * pty implementation allows more than 3 digits.
 */
static char *
my_utmp_id(char *device)
{
    typedef struct UTMP_STR UTMP_STRUCT;
#define	UTIDSIZE	(sizeof(((UTMP_STRUCT *)NULL)->ut_id))
    static char result[UTIDSIZE + 1];

#if defined(__SCO__) || defined(__UNIXWARE__)
    /*
     * Legend does not support old-style pty's, has no related compatibility
     * issues, and can use the available space in ut_id differently from the
     * default convention.
     *
     * This scheme is intended to avoid conflicts both with other users of
     * utmpx as well as between multiple xterms.  First, Legend uses all of the
     * characters of ut_id, and adds no terminating NUL is required (the
     * default scheme may add a trailing NUL).  Second, all xterm entries will
     * start with the letter 'x' followed by three digits, which will be the
     * last three digits of the device name, regardless of the format of the
     * device name, with leading 0's added where necessary.  For instance, an
     * xterm on /dev/pts/3 will have a ut_id of x003; an xterm on /dev/pts123
     * will have a ut_id of x123.  Under the other convention, /dev/pts/3 would
     * have a ut_id of p3 and /dev/pts123 would have a ut_id of p123.
     */
    int len, n;

    len = strlen(device);
    n = UTIDSIZE;
    result[n] = '\0';
    while ((n > 0) && (len > 0) && isdigit(device[len - 1]))
	result[--n] = device[--len];
    while (n > 0)
	result[--n] = '0';
    result[0] = 'x';
#else
    char *name = my_pty_name(device);
    char *leaf = x_basename(name);
    size_t len = strlen(leaf);

    if ((UTIDSIZE - 1) < len)
	leaf = leaf + (len - (UTIDSIZE - 1));
    sprintf(result, "p%s", leaf);
#endif

    TRACE(("my_utmp_id (%s) -> '%s'\n", device, result));
    return result;
}
#endif /* USE_SYSV_UTMP */

#ifdef USE_POSIX_SIGNALS

typedef void (*sigfunc) (int);

/* make sure we sure we ignore SIGCHLD for the cases parent
   has just been stopped and not actually killed */

static sigfunc
posix_signal(int signo, sigfunc func)
{
    struct sigaction act, oact;

    act.sa_handler = func;
    sigemptyset(&act.sa_mask);
#ifdef SA_RESTART
    act.sa_flags = SA_NOCLDSTOP | SA_RESTART;
#else
    act.sa_flags = SA_NOCLDSTOP;
#endif
    if (sigaction(signo, &act, &oact) < 0)
	return (SIG_ERR);
    return (oact.sa_handler);
}

#endif /* USE_POSIX_SIGNALS */

#if defined(DISABLE_SETUID) || defined(USE_UTMP_SETGID)
static void
disableSetUid(void)
{
    TRACE(("process %d disableSetUid\n", (int) getpid()));
    if (setuid(save_ruid) == -1) {
	xtermWarning("unable to reset uid\n");
	exit(1);
    }
    TRACE_IDS;
}
#else
#define disableSetUid()		/* nothing */
#endif /* DISABLE_SETUID */

#if defined(DISABLE_SETGID) || defined(USE_UTMP_SETGID)
static void
disableSetGid(void)
{
    TRACE(("process %d disableSetGid\n", (int) getpid()));
    if (setegid(save_rgid) == -1) {
	xtermWarning("unable to reset effective gid\n");
	exit(1);
    }
    TRACE_IDS;
}
#else
#define disableSetGid()		/* nothing */
#endif /* DISABLE_SETGID */

#if defined(HAVE_POSIX_SAVED_IDS)
#if (!defined(USE_UTEMPTER) || !defined(DISABLE_SETGID))
static void
setEffectiveGroup(gid_t group)
{
    TRACE(("process %d setEffectiveGroup(%d)\n", (int) getpid(), (int) group));
    if (setegid(group) == -1) {
#ifdef __MVS__
	if (!(errno == EMVSERR))	/* could happen if _BPX_SHAREAS=REUSE */
#endif
	{
	    xtermPerror("setegid(%d)", (int) group);
	}
    }
    TRACE_IDS;
}
#endif

#if !defined(USE_UTMP_SETGID) && (!defined(USE_UTEMPTER) || !defined(DISABLE_SETUID))
static void
setEffectiveUser(uid_t user)
{
    TRACE(("process %d setEffectiveUser(%d)\n", (int) getpid(), (int) user));
    if (seteuid(user) == -1) {
#ifdef __MVS__
	if (!(errno == EMVSERR))
#endif
	{
	    xtermPerror("seteuid(%d)", (int) user);
	}
    }
    TRACE_IDS;
}
#endif
#endif /* HAVE_POSIX_SAVED_IDS */

#if OPT_LUIT_PROG
static Boolean
complex_command(char **args)
{
    Boolean result = False;
    if (x_countargv(args) == 1) {
	char *check = xtermFindShell(args[0], False);
	if (check == 0) {
	    result = True;
	} else {
	    free(check);
	}
    }
    return result;
}
#endif

static unsigned
lookup_baudrate(const char *value)
{
    struct speed {
	unsigned given_speed;	/* values for 'ospeed' */
	unsigned actual_speed;	/* the actual speed */
    };

#define DATA(number) { B##number, number }

    static struct speed const speeds[] =
    {
	DATA(0),
	DATA(50),
	DATA(75),
	DATA(110),
	DATA(134),
	DATA(150),
	DATA(200),
	DATA(300),
	DATA(600),
	DATA(1200),
	DATA(1800),
	DATA(2400),
	DATA(4800),
	DATA(9600),
#ifdef B19200
	DATA(19200),
#elif defined(EXTA)
	{EXTA, 19200},
#endif
#ifdef B28800
	DATA(28800),
#endif
#ifdef B38400
	DATA(38400),
#elif defined(EXTB)
	{EXTB, 38400},
#endif
#ifdef B57600
	DATA(57600),
#endif
#ifdef B76800
	DATA(76800),
#endif
#ifdef B115200
	DATA(115200),
#endif
#ifdef B153600
	DATA(153600),
#endif
#ifdef B230400
	DATA(230400),
#endif
#ifdef B307200
	DATA(307200),
#endif
#ifdef B460800
	DATA(460800),
#endif
#ifdef B500000
	DATA(500000),
#endif
#ifdef B576000
	DATA(576000),
#endif
#ifdef B921600
	DATA(921600),
#endif
#ifdef B1000000
	DATA(1000000),
#endif
#ifdef B1152000
	DATA(1152000),
#endif
#ifdef B1500000
	DATA(1500000),
#endif
#ifdef B2000000
	DATA(2000000),
#endif
#ifdef B2500000
	DATA(2500000),
#endif
#ifdef B3000000
	DATA(3000000),
#endif
#ifdef B3500000
	DATA(3500000),
#endif
#ifdef B4000000
	DATA(4000000),
#endif
    };
#undef DATA
    unsigned result = 0;
    long check;
    char *next;
    if (x_toupper(*value) == 'B')
	value++;
    if (isdigit(CharOf(*value))) {
	check = strtol(value, &next, 10);
	if (FullS2L(value, next) && (check > 0)) {
	    Cardinal n;
	    for (n = 0; n < XtNumber(speeds); ++n) {
		if (speeds[n].actual_speed == (unsigned) check) {
		    result = speeds[n].given_speed;
		    break;
		}
	    }
	}
    }
    if (result == 0) {
	fprintf(stderr, "unsupported value for baudrate: %s\n", value);
    }
    return result;
}

int
main(int argc, char *argv[]ENVP_ARG)
{
#if OPT_MAXIMIZE
#define DATA(name) { #name, es##name }
    static const FlagList tblFullscreen[] =
    {
	DATA(Always),
	DATA(Never)
    };
#undef DATA
#endif

    Widget form_top, menu_top;
    Dimension menu_high;
    TScreen *screen;
    int mode;
    char *my_class = x_strdup(DEFCLASS);
    unsigned line_speed = VAL_LINE_SPEED;
    Window winToEmbedInto = None;

    ProgramName = argv[0];

#ifdef HAVE_POSIX_SAVED_IDS
    save_euid = geteuid();
    save_egid = getegid();
#endif

    save_ruid = getuid();
    save_rgid = getgid();

#if defined(DISABLE_SETUID) || defined(DISABLE_SETGID)
#if defined(DISABLE_SETUID)
    disableSetUid();
#endif
#if defined(DISABLE_SETGID)
    disableSetGid();
#endif
    TRACE_IDS;
#endif

    /* extra length in case longer tty name like /dev/ttyq255 */
    ttydev = TypeMallocN(char, sizeof(TTYDEV) + 80);
#ifdef USE_PTY_DEVICE
    ptydev = TypeMallocN(char, sizeof(PTYDEV) + 80);
    if (!ttydev || !ptydev)
#else
    if (!ttydev)
#endif
    {
	xtermWarning("unable to allocate memory for ttydev or ptydev\n");
	exit(1);
    }
    strcpy(ttydev, TTYDEV);
#ifdef USE_PTY_DEVICE
    strcpy(ptydev, PTYDEV);
#endif

#if defined(USE_UTMP_SETGID)
    get_pty(NULL, NULL);
    disableSetUid();
    disableSetGid();
    TRACE_IDS;
#define get_pty(pty, from) really_get_pty(pty, from)
#endif

    /* Do these first, since we may not be able to open the display */
    TRACE_OPTS(xtermOptions, optionDescList, XtNumber(optionDescList));
    TRACE_ARGV("Before XtOpenApplication", argv);
    if (argc > 1) {
	XrmOptionDescRec *option_ptr;
	char *option_value;
	int n;
	Bool quit = False;

	for (n = 1; n < argc; n++) {
	    if ((option_ptr = parseArg(&n, argv, &option_value)) == 0) {
		if (argv[n] == 0) {
		    break;
		} else if (isOption(argv[n])) {
		    Syntax(argv[n]);
		} else if (explicit_shname != 0) {
		    xtermWarning("Explicit shell already was %s\n", explicit_shname);
		    Syntax(argv[n]);
		}
		explicit_shname = xtermFindShell(argv[n], True);
		if (explicit_shname == 0)
		    exit(0);
		TRACE(("...explicit shell %s\n", explicit_shname));
	    } else if (!strcmp(option_ptr->option, "-e")) {
		command_to_exec = (argv + n + 1);
		if (!command_to_exec[0])
		    Syntax(argv[n]);
		break;
	    } else if (!strcmp(option_ptr->option, "-version")) {
		Version();
		quit = True;
	    } else if (!strcmp(option_ptr->option, "-help")) {
		Help();
		quit = True;
	    } else if (!strcmp(option_ptr->option, "-baudrate")) {
		if ((line_speed = lookup_baudrate(option_value)) == 0) {
		    Help();
		    quit = True;
		}
	    } else if (!strcmp(option_ptr->option, "-class")) {
		free(my_class);
		if ((my_class = x_strdup(option_value)) == 0) {
		    Help();
		    quit = True;
		}
	    } else if (!strcmp(option_ptr->option, "-into")) {
		char *endPtr;
		winToEmbedInto = (Window) strtol(option_value, &endPtr, 0);
		if (!FullS2L(option_value, endPtr)) {
		    Help();
		    quit = True;
		}
	    }
	}
	if (quit)
	    exit(0);
	/*
	 * If there is anything left unparsed, and we're not using "-e",
	 * then give up.
	 */
	if (n < argc && !command_to_exec) {
	    Syntax(argv[n]);
	}
    }

    /* This dumped core on HP-UX 9.05 with X11R5 */
#if OPT_I18N_SUPPORT
    XtSetLanguageProc(NULL, NULL, NULL);
#endif

#ifdef TERMIO_STRUCT		/* { */
    /* Initialization is done here rather than above in order
     * to prevent any assumptions about the order of the contents
     * of the various terminal structures (which may change from
     * implementation to implementation).
     */
    memset(&d_tio, 0, sizeof(d_tio));
    d_tio.c_iflag = ICRNL | IXON;
#ifdef TAB3
    d_tio.c_oflag = OPOST | ONLCR | TAB3;
#else
#ifdef ONLCR
    d_tio.c_oflag = OPOST | ONLCR;
#else
    d_tio.c_oflag = OPOST;
#endif
#endif
    {
	Cardinal nn;

	/* fill in default-values */
	for (nn = 0; nn < XtNumber(known_ttyChars); ++nn) {
	    if (validTtyChar(d_tio, nn)) {
		d_tio.c_cc[known_ttyChars[nn].sysMode] =
		    (cc_t) known_ttyChars[nn].myDefault;
	    }
	}
    }
#if defined(macII) || defined(ATT) || defined(CRAY)	/* { */
    d_tio.c_cflag = line_speed | CS8 | CREAD | PARENB | HUPCL;
    d_tio.c_lflag = ISIG | ICANON | ECHO | ECHOE | ECHOK;
#ifdef ECHOKE
    d_tio.c_lflag |= ECHOKE | IEXTEN;
#endif
#ifdef ECHOCTL
    d_tio.c_lflag |= ECHOCTL | IEXTEN;
#endif
#ifndef USE_TERMIOS		/* { */
    d_tio.c_line = 0;
#endif /* } */
#ifdef HAS_LTCHARS		/* { */
    d_ltc.t_suspc = CSUSP;	/* t_suspc */
    d_ltc.t_dsuspc = CDSUSP;	/* t_dsuspc */
    d_ltc.t_rprntc = CRPRNT;
    d_ltc.t_flushc = CFLUSH;
    d_ltc.t_werasc = CWERASE;
    d_ltc.t_lnextc = CLNEXT;
#endif /* } HAS_LTCHARS */
#ifdef TIOCLSET			/* { */
    d_lmode = 0;
#endif /* } TIOCLSET */
#else /* }{ else !macII, ATT, CRAY */
#ifndef USE_POSIX_TERMIOS
#ifdef BAUD_0			/* { */
    d_tio.c_cflag = CS8 | CREAD | PARENB | HUPCL;
#else /* }{ !BAUD_0 */
    d_tio.c_cflag = line_speed | CS8 | CREAD | PARENB | HUPCL;
#endif /* } !BAUD_0 */
#else /* USE_POSIX_TERMIOS */
    d_tio.c_cflag = CS8 | CREAD | PARENB | HUPCL;
    cfsetispeed(&d_tio, line_speed);
    cfsetospeed(&d_tio, line_speed);
#endif
    d_tio.c_lflag = ISIG | ICANON | ECHO | ECHOE | ECHOK;
#ifdef ECHOKE
    d_tio.c_lflag |= ECHOKE | IEXTEN;
#endif
#ifdef ECHOCTL
    d_tio.c_lflag |= ECHOCTL | IEXTEN;
#endif
#ifndef USE_POSIX_TERMIOS
#ifdef NTTYDISC
    d_tio.c_line = NTTYDISC;
#else
    d_tio.c_line = 0;
#endif
#endif /* USE_POSIX_TERMIOS */
#ifdef __sgi
    d_tio.c_cflag &= ~(HUPCL | PARENB);
    d_tio.c_iflag |= BRKINT | ISTRIP | IGNPAR;
#endif
#ifdef __MVS__
    d_tio.c_cflag &= ~(HUPCL | PARENB);
#endif
    {
	Cardinal nn;
	int i;

	/* try to inherit tty settings */
	for (i = 0; i <= 2; i++) {
	    TERMIO_STRUCT deftio;
	    if (ttyGetAttr(i, &deftio) == 0) {
		for (nn = 0; nn < XtNumber(known_ttyChars); ++nn) {
		    if (validTtyChar(d_tio, nn)) {
			d_tio.c_cc[known_ttyChars[nn].sysMode] =
			    deftio.c_cc[known_ttyChars[nn].sysMode];
		    }
		}
		break;
	    }
	}
    }
#if defined(USE_TERMIOS) || defined(USE_POSIX_TERMIOS)	/* { */
    d_tio.c_cc[VMIN] = 1;
    d_tio.c_cc[VTIME] = 0;
#endif /* } */
#ifdef HAS_LTCHARS		/* { */
    d_ltc.t_suspc = CharOf('\000');	/* t_suspc */
    d_ltc.t_dsuspc = CharOf('\000');	/* t_dsuspc */
    d_ltc.t_rprntc = CharOf('\377');	/* reserved... */
    d_ltc.t_flushc = CharOf('\377');
    d_ltc.t_werasc = CharOf('\377');
    d_ltc.t_lnextc = CharOf('\377');
#endif /* } HAS_LTCHARS */

#ifdef TIOCLSET			/* { */
    d_lmode = 0;
#endif /* } TIOCLSET */
#endif /* } macII, ATT, CRAY */
#endif /* } TERMIO_STRUCT */

    /* Init the Toolkit. */
    {
#if defined(HAVE_POSIX_SAVED_IDS) && !defined(USE_UTMP_SETGID) && !defined(USE_UTEMPTER)
	setEffectiveGroup(save_rgid);
	setEffectiveUser(save_ruid);
	TRACE_IDS;
#endif
	toplevel = xtermOpenApplication(&app_con,
					my_class,
					optionDescList,
					XtNumber(optionDescList),
					&argc, (String *) argv,
					fallback_resources,
					sessionShellWidgetClass,
					NULL, 0);

	XtGetApplicationResources(toplevel, (XtPointer) &resource,
				  application_resources,
				  XtNumber(application_resources), NULL, 0);
	TRACE_XRES();
#if OPT_MAXIMIZE
	resource.fullscreen = extendedBoolean(resource.fullscreen_s,
					      tblFullscreen,
					      XtNumber(tblFullscreen));
#endif
	VTInitTranslations();
#if OPT_PTY_HANDSHAKE
	resource.wait_for_map0 = resource.wait_for_map;
#endif

#if defined(HAVE_POSIX_SAVED_IDS) && !defined(USE_UTMP_SETGID)
#if !defined(DISABLE_SETUID) || !defined(DISABLE_SETGID)
#if !defined(DISABLE_SETUID)
	setEffectiveUser(save_euid);
#endif
#if !defined(DISABLE_SETGID)
	setEffectiveGroup(save_egid);
#endif
	TRACE_IDS;
#endif
#endif
    }

    /*
     * ICCCM delete_window.
     */
    XtAppAddActions(app_con, actionProcs, XtNumber(actionProcs));

    /*
     * fill in terminal modes
     */
    if (resource.tty_modes) {
	int n = parse_tty_modes(resource.tty_modes, ttymodelist);
	if (n < 0) {
	    xtermWarning("bad tty modes \"%s\"\n", resource.tty_modes);
	} else if (n > 0) {
	    override_tty_modes = True;
	}
    }
    initZIconBeep();
    hold_screen = resource.hold_screen ? 1 : 0;
    if (resource.icon_geometry != NULL) {
	int scr, junk;
	int ix, iy;
	Arg args[2];

	for (scr = 0;		/* yyuucchh */
	     XtScreen(toplevel) != ScreenOfDisplay(XtDisplay(toplevel), scr);
	     scr++) ;

	args[0].name = XtNiconX;
	args[1].name = XtNiconY;
	XGeometry(XtDisplay(toplevel), scr, resource.icon_geometry, "",
		  0, 0, 0, 0, 0, &ix, &iy, &junk, &junk);
	args[0].value = (XtArgVal) ix;
	args[1].value = (XtArgVal) iy;
	XtSetValues(toplevel, args, 2);
    }

    XtSetValues(toplevel, ourTopLevelShellArgs,
		number_ourTopLevelShellArgs);

#if OPT_WIDE_CHARS
    /* seems as good a place as any */
    init_classtab();
#endif

    /* Parse the rest of the command line */
    TRACE_ARGV("After XtOpenApplication", argv);
    for (argc--, argv++; argc > 0; argc--, argv++) {
	if (!isOption(*argv)) {
#ifdef VMS
	    Syntax(*argv);
#else
	    if (argc > 1)
		Syntax(*argv);
	    continue;
#endif
	}

	TRACE(("parsing %s\n", argv[0]));
	switch (argv[0][1]) {
	case 'C':
#if defined(TIOCCONS) || defined(SRIOCSREDIR)
#ifndef __sgi
	    {
		struct stat sbuf;

		/* Must be owner and have read/write permission.
		   xdm cooperates to give the console the right user. */
		if (!stat("/dev/console", &sbuf) &&
		    (sbuf.st_uid == save_ruid) &&
		    !access("/dev/console", R_OK | W_OK)) {
		    Console = True;
		} else
		    Console = False;
	    }
#else /* __sgi */
	    Console = True;
#endif /* __sgi */
#endif /* TIOCCONS */
	    continue;
	case 'S':
	    if (!ParseSccn(*argv + 2))
		Syntax(*argv);
	    continue;
#ifdef DEBUG
	case 'D':
	    debug = True;
	    continue;
#endif /* DEBUG */
	case 'b':
	    if (strcmp(argv[0], "-baudrate"))
		Syntax(*argv);
	    argc--, argv++;
	    continue;
	case 'c':
	    if (strcmp(argv[0], "-class"))
		Syntax(*argv);
	    argc--, argv++;
	    continue;
	case 'e':
	    if (strcmp(argv[0], "-e"))
		Syntax(*argv);
	    command_to_exec = (argv + 1);
	    break;
	case 'i':
	    if (strcmp(argv[0], "-into"))
		Syntax(*argv);
	    argc--, argv++;
	    continue;

	default:
	    Syntax(*argv);
	}
	break;
    }

    SetupMenus(toplevel, &form_top, &menu_top, &menu_high);

    term = (XtermWidget) XtVaCreateManagedWidget("vt100", xtermWidgetClass,
						 form_top,
#if OPT_TOOLBAR
						 XtNmenuBar, menu_top,
						 XtNresizable, True,
						 XtNfromVert, menu_top,
						 XtNleft, XawChainLeft,
						 XtNright, XawChainRight,
						 XtNtop, XawChainTop,
						 XtNbottom, XawChainBottom,
						 XtNmenuHeight, menu_high,
#endif
						 (XtPointer) 0);
    decode_keyboard_type(term, &resource);

    screen = TScreenOf(term);
    screen->inhibit = 0;

#ifdef ALLOWLOGGING
    if (term->misc.logInhibit)
	screen->inhibit |= I_LOG;
#endif
    if (term->misc.signalInhibit)
	screen->inhibit |= I_SIGNAL;
#if OPT_TEK4014
    if (term->misc.tekInhibit)
	screen->inhibit |= I_TEK;
#endif

    /*
     * We might start by showing the tek4014 window.
     */
#if OPT_TEK4014
    if (screen->inhibit & I_TEK)
	TEK4014_ACTIVE(term) = False;

    if (TEK4014_ACTIVE(term) && !TekInit())
	SysError(ERROR_INIT);
#endif

    /*
     * Start the toolbar at this point, after the first window has been setup.
     */
#if OPT_TOOLBAR
    ShowToolbar(resource.toolBar);
#endif

    xtermOpenSession();

    /*
     * Set title and icon name if not specified
     */
    if (command_to_exec) {
	Arg args[2];

	if (!resource.title) {
	    if (command_to_exec) {
		resource.title = x_basename(command_to_exec[0]);
	    }			/* else not reached */
	}

	if (!resource.icon_name)
	    resource.icon_name = resource.title;
	XtSetArg(args[0], XtNtitle, resource.title);
	XtSetArg(args[1], XtNiconName, resource.icon_name);

	TRACE(("setting:\n\ttitle \"%s\"\n\ticon \"%s\"\n\thint \"%s\"\n\tbased on command \"%s\"\n",
	       resource.title,
	       resource.icon_name,
	       NonNull(resource.icon_hint),
	       *command_to_exec));

	XtSetValues(toplevel, args, 2);
    }
#if OPT_LUIT_PROG
    if (term->misc.callfilter) {
	char **split_filter = x_splitargs(term->misc.localefilter);
	unsigned count_split = x_countargv(split_filter);
	unsigned count_exec = x_countargv(command_to_exec);
	unsigned count_using = (unsigned) (term->misc.use_encoding ? 2 : 0);

	command_to_exec_with_luit = TypeCallocN(char *,
						  (count_split
						   + count_exec
						   + count_using
						   + 8));
	if (command_to_exec_with_luit == NULL)
	    SysError(ERROR_LUMALLOC);

	x_appendargv(command_to_exec_with_luit, split_filter);
	if (count_using) {
	    char *encoding_opt[4];
	    encoding_opt[0] = x_strdup("-encoding");
	    encoding_opt[1] = term->misc.locale_str;
	    encoding_opt[2] = 0;
	    x_appendargv(command_to_exec_with_luit, encoding_opt);
	}
	command_length_with_luit = x_countargv(command_to_exec_with_luit);
	if (count_exec) {
	    static char *fixup_shell[] =
	    {"sh", "-c", 0};
	    char *delimiter[2];
	    delimiter[0] = x_strdup("--");
	    delimiter[1] = 0;
	    x_appendargv(command_to_exec_with_luit, delimiter);
	    if (complex_command(command_to_exec)) {
		x_appendargv(command_to_exec_with_luit, fixup_shell);
	    }
	    x_appendargv(command_to_exec_with_luit, command_to_exec);
	}
	TRACE_ARGV("luit command", command_to_exec_with_luit);
	xtermSetenv("XTERM_FILTER", *command_to_exec_with_luit);
    }
#endif

    if_DEBUG({
	/* Set up stderr properly.  Opening this log file cannot be
	   done securely by a privileged xterm process (although we try),
	   so the debug feature is disabled by default. */
	char dbglogfile[TIMESTAMP_LEN + 20];
	int i = -1;
	timestamp_filename(dbglogfile, "xterm.debug.log.");
	if (creat_as(save_ruid, save_rgid, False, dbglogfile, 0600) > 0) {
	    i = open(dbglogfile, O_WRONLY | O_TRUNC);
	}
	if (i >= 0) {
	    dup2(i, 2);

	    /* mark this file as close on exec */
	    (void) fcntl(i, F_SETFD, 1);
	}
    });

    spawnXTerm(term, line_speed);

#ifndef VMS
    /* Child process is out there, let's catch its termination */

#ifdef USE_POSIX_SIGNALS
    (void) posix_signal(SIGCHLD, reapchild);
#else
    (void) signal(SIGCHLD, reapchild);
#endif
    /* Realize procs have now been executed */

    if (am_slave >= 0) {	/* Write window id so master end can read and use */
	char buf[80];

	buf[0] = '\0';
	sprintf(buf, "%lx\n", XtWindow(SHELL_OF(CURRENT_EMU())));
	IGNORE_RC(write(screen->respond, buf, strlen(buf)));
    }
#ifdef AIXV3
#if (OSMAJORVERSION < 4)
    /* In AIXV3, xterms started from /dev/console have CLOCAL set.
     * This means we need to clear CLOCAL so that SIGHUP gets sent
     * to the slave-pty process when xterm exits.
     */

    {
	TERMIO_STRUCT tio;

	if (ttyGetAttr(screen->respond, &tio) == -1)
	    SysError(ERROR_TIOCGETP);

	tio.c_cflag &= ~(CLOCAL);

	if (ttySetAttr(screen->respond, &tio) == -1)
	    SysError(ERROR_TIOCSETP);
    }
#endif
#endif
#if defined(USE_ANY_SYSV_TERMIO) || defined(__MVS__) || defined(__minix)
    if (0 > (mode = fcntl(screen->respond, F_GETFL, 0)))
	SysError(ERROR_F_GETFL);
#ifdef O_NDELAY
    mode |= O_NDELAY;
#else
    mode |= O_NONBLOCK;
#endif /* O_NDELAY */
    if (fcntl(screen->respond, F_SETFL, mode))
	SysError(ERROR_F_SETFL);
#else /* !USE_ANY_SYSV_TERMIO */
    mode = 1;
    if (ioctl(screen->respond, FIONBIO, (char *) &mode) == -1)
	SysError(ERROR_FIONBIO);
#endif /* USE_ANY_SYSV_TERMIO, etc */

    /* The erase character is used to delete the current completion */
#if OPT_DABBREV
#ifdef TERMIO_STRUCT
    screen->dabbrev_erase_char = d_tio.c_cc[VERASE];
#else
    screen->dabbrev_erase_char = d_sg.sg_erase;
#endif
    TRACE(("set dabbrev erase_char %#x\n", screen->dabbrev_erase_char));
#endif

    FD_ZERO(&pty_mask);
    FD_ZERO(&X_mask);
    FD_ZERO(&Select_mask);
    FD_SET(screen->respond, &pty_mask);
    FD_SET(ConnectionNumber(screen->display), &X_mask);
    FD_SET(screen->respond, &Select_mask);
    FD_SET(ConnectionNumber(screen->display), &Select_mask);
    max_plus1 = ((screen->respond < ConnectionNumber(screen->display))
		 ? (1 + ConnectionNumber(screen->display))
		 : (1 + screen->respond));

#endif /* !VMS */
    if_DEBUG({
	TRACE(("debugging on pid %d\n", (int) getpid()));
    });
    XSetErrorHandler(xerror);
    XSetIOErrorHandler(xioerror);
#if OPT_SESSION_MGT
    IceSetIOErrorHandler(ice_error);
#endif

    initPtyData(&VTbuffer);
#ifdef ALLOWLOGGING
    if (term->misc.log_on) {
	StartLog(term);
    }
#endif

    xtermEmbedWindow(winToEmbedInto);
#if OPT_COLOR_RES
    TRACE(("checking reverseVideo before rv %s fg %s, bg %s\n",
	   term->misc.re_verse0 ? "reverse" : "normal",
	   NonNull(TScreenOf(term)->Tcolors[TEXT_FG].resource),
	   NonNull(TScreenOf(term)->Tcolors[TEXT_BG].resource)));

    if (term->misc.re_verse0) {
	if (isDefaultForeground(TScreenOf(term)->Tcolors[TEXT_FG].resource)
	    && isDefaultBackground(TScreenOf(term)->Tcolors[TEXT_BG].resource)) {
	    TScreenOf(term)->Tcolors[TEXT_FG].resource = x_strdup(XtDefaultBackground);
	    TScreenOf(term)->Tcolors[TEXT_BG].resource = x_strdup(XtDefaultForeground);
	} else {
	    ReverseVideo(term);
	}
	term->misc.re_verse = True;
	update_reversevideo();
	TRACE(("updated  reverseVideo after  rv %s fg %s, bg %s\n",
	       term->misc.re_verse ? "reverse" : "normal",
	       NonNull(TScreenOf(term)->Tcolors[TEXT_FG].resource),
	       NonNull(TScreenOf(term)->Tcolors[TEXT_BG].resource)));
    }
#endif /* OPT_COLOR_RES */

#if OPT_MAXIMIZE
    if (resource.maximized)
	RequestMaximize(term, True);
#endif

    {
        String data = NULL;
        getKeymapResources(term, "vt100", "VT100", XtRString, &data, sizeof(data));
        if (data &&
            (strstr(data, "exec-formatted") || strstr(data, "exec-selectable"))) {

            if (pledge("stdio rpath wpath id proc exec tty", NULL) == -1) {
                xtermWarning("pledge\n");
                exit(1);
            }
        } else {
            if (pledge("stdio rpath wpath id proc tty", NULL) == -1) {
               xtermWarning("pledge\n");
               exit(1);
           }
       }
    }

    for (;;) {
#if OPT_TEK4014
	if (TEK4014_ACTIVE(term))
	    TekRun();
	else
#endif
	    VTRun(term);
    }
}

#if defined(__osf__) || (defined(__GLIBC__) && !defined(USE_USG_PTYS)) || defined(__DragonFly__) || defined(__FreeBSD__) || defined(__NetBSD__) || defined(__OpenBSD__) || defined(__APPLE__)
#define USE_OPENPTY 1
static int opened_tty = -1;
#endif

/*
 * This function opens up a pty master and stuffs its value into pty.
 *
 * If it finds one, it returns a value of 0.  If it does not find one,
 * it returns a value of !0.  This routine is designed to be re-entrant,
 * so that if a pty master is found and later, we find that the slave
 * has problems, we can re-enter this function and get another one.
 */
static int
get_pty(int *pty, char *from GCC_UNUSED)
{
    int result = 1;

#if defined(USE_OPENPTY)
    result = openpty(pty, &opened_tty, ttydev, NULL, NULL);
    if (opened_tty >= 0) {
	close(opened_tty);
	opened_tty = -1;
    }
#elif defined(HAVE_POSIX_OPENPT) && defined(HAVE_PTSNAME) && defined(HAVE_GRANTPT_PTY_ISATTY)
    if ((*pty = posix_openpt(O_RDWR)) >= 0) {
	char *name = ptsname(*pty);
	if (name != 0) {
	    strcpy(ttydev, name);
	    result = 0;
	}
    }
#ifdef USE_PTY_SEARCH
    if (result) {
	result = pty_search(pty);
    }
#endif
#elif defined(PUCC_PTYD)
    result = ((*pty = openrpty(ttydev, ptydev,
			       (resource.utmpInhibit ? OPTY_NOP : OPTY_LOGIN),
			       save_ruid, from)) < 0);
#elif defined(__QNXNTO__)
    result = pty_search(pty);
#else
#if defined(USE_USG_PTYS) || defined(__CYGWIN__)
#ifdef __GLIBC__		/* if __GLIBC__ and USE_USG_PTYS, we know glibc >= 2.1 */
    /* GNU libc 2 allows us to abstract away from having to know the
       master pty device name. */
    if ((*pty = getpt()) >= 0) {
	char *name = ptsname(*pty);
	if (name != 0) {	/* if filesystem is trashed, this may be null */
	    strcpy(ttydev, name);
	    result = 0;
	}
    }
#elif defined(__MVS__)
    result = pty_search(pty);
#else
    result = ((*pty = open("/dev/ptmx", O_RDWR)) < 0);
#endif
#if defined(SVR4) || defined(__SCO__)
    if (!result)
	strcpy(ttydev, ptsname(*pty));
#endif

#elif defined(AIXV3)

    if ((*pty = open("/dev/ptc", O_RDWR)) >= 0) {
	strcpy(ttydev, ttyname(*pty));
	result = 0;
    }
#elif defined(__convex__)

    char *pty_name;
    extern char *getpty(void);

    while ((pty_name = getpty()) != NULL) {
	if ((*pty = open(pty_name, O_RDWR)) >= 0) {
	    strcpy(ptydev, pty_name);
	    strcpy(ttydev, pty_name);
	    *x_basename(ttydev) = 't';
	    result = 0;
	    break;
	}
    }

#elif defined(sequent)

    result = ((*pty = getpseudotty(&ttydev, &ptydev)) < 0);

#elif defined(__sgi) && (OSMAJORVERSION >= 4)

    char *tty_name;

    tty_name = _getpty(pty, O_RDWR, 0622, 0);
    if (tty_name != 0) {
	strcpy(ttydev, tty_name);
	result = 0;
    }
#elif (defined(__sgi) && (OSMAJORVERSION < 4)) || (defined(umips) && defined (SYSTYPE_SYSV))

    struct stat fstat_buf;

    *pty = open("/dev/ptc", O_RDWR);
    if (*pty >= 0 && (fstat(*pty, &fstat_buf)) >= 0) {
	result = 0;
	sprintf(ttydev, "/dev/ttyq%d", minor(fstat_buf.st_rdev));
    }
#elif defined(__hpux)

    /*
     * Use the clone device if it works, otherwise use pty_search logic.
     */
    if ((*pty = open("/dev/ptym/clone", O_RDWR)) >= 0) {
	char *name = ptsname(*pty);
	if (name != 0) {
	    strcpy(ttydev, name);
	    result = 0;
	} else {		/* permissions, or other unexpected problem */
	    close(*pty);
	    *pty = -1;
	    result = pty_search(pty);
	}
    } else {
	result = pty_search(pty);
    }

#else

    result = pty_search(pty);

#endif
#endif

    TRACE(("get_pty(ttydev=%s, ptydev=%s) %s fd=%d\n",
	   ttydev != 0 ? ttydev : "?",
	   ptydev != 0 ? ptydev : "?",
	   result ? "FAIL" : "OK",
	   pty != 0 ? *pty : -1));
    return result;
}

static void
set_pty_permissions(uid_t uid, unsigned gid, unsigned mode)
{
#ifdef USE_TTY_GROUP
    struct group *ttygrp;

    if ((ttygrp = getgrnam(TTY_GROUP_NAME)) != 0) {
	gid = ttygrp->gr_gid;
	mode &= 0660U;
    }
    endgrent();
#endif /* USE_TTY_GROUP */

    TRACE_IDS;
    set_owner(ttydev, uid, gid, mode);
}

#ifdef get_pty			/* USE_UTMP_SETGID */
#undef get_pty
/*
 * Call the real get_pty() before relinquishing root-setuid, caching the
 * result.
 */
static int
get_pty(int *pty, char *from)
{
    static int m_pty = -1;
    int result = -1;

    if (pty == NULL) {
	result = really_get_pty(&m_pty, from);

	seteuid(0);
	set_pty_permissions(save_ruid, save_rgid, 0600U);
	seteuid(save_ruid);
	TRACE_IDS;

    } else if (m_pty != -1) {
	*pty = m_pty;
	result = 0;
    } else {
	result = -1;
    }
    TRACE(("get_pty(ttydev=%s, ptydev=%s) %s fd=%d (utmp setgid)\n",
	   ttydev != 0 ? ttydev : "?",
	   ptydev != 0 ? ptydev : "?",
	   result ? "FAIL" : "OK",
	   pty != 0 ? *pty : -1));
#ifdef USE_OPENPTY
    if (opened_tty >= 0) {
	close(opened_tty);
	opened_tty = -1;
    }
#endif
    return result;
}
#endif

/*
 * Called from get_pty to iterate over likely pseudo terminals
 * we might allocate.  Used on those systems that do not have
 * a functional interface for allocating a pty.
 * Returns 0 if found a pty, 1 if fails.
 */
#ifdef USE_PTY_SEARCH
static int
pty_search(int *pty)
{
    static int devindex = 0, letter = 0;

#if defined(CRAY) || defined(__MVS__)
    while (devindex < MAXPTTYS) {
	sprintf(ttydev, TTYFORMAT, devindex);
	sprintf(ptydev, PTYFORMAT, devindex);
	devindex++;

	TRACE(("pty_search(ttydev=%s, ptydev=%s)\n", ttydev, ptydev));
	if ((*pty = open(ptydev, O_RDWR)) >= 0) {
	    return 0;
	}
    }
#else /* CRAY || __MVS__ */
    while (PTYCHAR1[letter]) {
	ttydev[strlen(ttydev) - 2] =
	    ptydev[strlen(ptydev) - 2] = PTYCHAR1[letter];

	while (PTYCHAR2[devindex]) {
	    ttydev[strlen(ttydev) - 1] =
		ptydev[strlen(ptydev) - 1] = PTYCHAR2[devindex];
	    devindex++;

	    TRACE(("pty_search(ttydev=%s, ptydev=%s)\n", ttydev, ptydev));
	    if ((*pty = open(ptydev, O_RDWR)) >= 0) {
#ifdef sun
		/* Need to check the process group of the pty.
		 * If it exists, then the slave pty is in use,
		 * and we need to get another one.
		 */
		int pgrp_rtn;
		if (ioctl(*pty, TIOCGPGRP, &pgrp_rtn) == 0 || errno != EIO) {
		    close(*pty);
		    continue;
		}
#endif /* sun */
		return 0;
	    }
	}
	devindex = 0;
	letter++;
    }
#endif /* CRAY else */
    /*
     * We were unable to allocate a pty master!  Return an error
     * condition and let our caller terminate cleanly.
     */
    return 1;
}
#endif /* USE_PTY_SEARCH */

/*
 * The only difference in /etc/termcap between 4014 and 4015 is that
 * the latter has support for switching character sets.  We support the
 * 4015 protocol, but ignore the character switches.  Therefore, we
 * choose 4014 over 4015.
 *
 * Features of the 4014 over the 4012: larger (19") screen, 12-bit
 * graphics addressing (compatible with 4012 10-bit addressing),
 * special point plot mode, incremental plot mode (not implemented in
 * later Tektronix terminals), and 4 character sizes.
 * All of these are supported by xterm.
 */

#if OPT_TEK4014
static const char *const tekterm[] =
{
    "tek4014",
    "tek4015",			/* 4014 with APL character set support */
    "tek4012",			/* 4010 with lower case */
    "tek4013",			/* 4012 with APL character set support */
    "tek4010",			/* small screen, upper-case only */
    "dumb",
    0
};
#endif

/* The VT102 is a VT100 with the Advanced Video Option included standard.
 * It also adds Escape sequences for insert/delete character/line.
 * The VT220 adds 8-bit character sets, selective erase.
 * The VT320 adds a 25th status line, terminal state interrogation.
 * The VT420 has up to 48 lines on the screen.
 */

static const char *const vtterm[] =
{
#ifdef USE_X11TERM
    "x11term",			/* for people who want special term name */
#endif
    DFT_TERMTYPE,		/* for people who want special term name */
    "xterm",			/* the prefered name, should be fastest */
    "vt102",
    "vt100",
    "ansi",
    "dumb",
    0
};

/* ARGSUSED */
static void
hungtty(int i GCC_UNUSED)
{
    DEBUG_MSG("handle:hungtty\n");
    siglongjmp(env, 1);
}

#if OPT_PTY_HANDSHAKE
#define NO_FDS {-1, -1}

static int cp_pipe[2] = NO_FDS;	/* this pipe is used for child to parent transfer */
static int pc_pipe[2] = NO_FDS;	/* this pipe is used for parent to child transfer */

typedef enum {			/* c == child, p == parent                        */
    PTY_BAD,			/* c->p: can't open pty slave for some reason     */
    PTY_FATALERROR,		/* c->p: we had a fatal error with the pty        */
    PTY_GOOD,			/* c->p: we have a good pty, let's go on          */
    PTY_NEW,			/* p->c: here is a new pty slave, try this        */
    PTY_NOMORE,			/* p->c; no more pty's, terminate                 */
    UTMP_ADDED,			/* c->p: utmp entry has been added                */
    UTMP_TTYSLOT,		/* c->p: here is my ttyslot                       */
    PTY_EXEC			/* p->c: window has been mapped the first time    */
} status_t;

typedef struct {
    status_t status;
    int error;
    int fatal_error;
    int tty_slot;
    int rows;
    int cols;
    char buffer[1024];
} handshake_t;

#if OPT_TRACE
static void
trace_handshake(const char *tag, handshake_t * data)
{
    const char *status = "?";
    switch (data->status) {
    case PTY_BAD:
	status = "PTY_BAD";
	break;
    case PTY_FATALERROR:
	status = "PTY_FATALERROR";
	break;
    case PTY_GOOD:
	status = "PTY_GOOD";
	break;
    case PTY_NEW:
	status = "PTY_NEW";
	break;
    case PTY_NOMORE:
	status = "PTY_NOMORE";
	break;
    case UTMP_ADDED:
	status = "UTMP_ADDED";
	break;
    case UTMP_TTYSLOT:
	status = "UTMP_TTYSLOT";
	break;
    case PTY_EXEC:
	status = "PTY_EXEC";
	break;
    }
    TRACE(("handshake %s %s errno=%d, error=%d device \"%s\"\n",
	   tag,
	   status,
	   data->error,
	   data->fatal_error,
	   data->buffer));
}
#define TRACE_HANDSHAKE(tag, data) trace_handshake(tag, data)
#else
#define TRACE_HANDSHAKE(tag, data)	/* nothing */
#endif

/* HsSysError()
 *
 * This routine does the equivalent of a SysError but it handshakes
 * over the errno and error exit to the master process so that it can
 * display our error message and exit with our exit code so that the
 * user can see it.
 */

static void
HsSysError(int error)
{
    handshake_t handshake;

    memset(&handshake, 0, sizeof(handshake));
    handshake.status = PTY_FATALERROR;
    handshake.error = errno;
    handshake.fatal_error = error;
    strncpy(handshake.buffer, ttydev, sizeof(handshake.buffer));

    if (resource.ptyHandshake && (cp_pipe[1] >= 0)) {
	TRACE(("HsSysError errno=%d, error=%d device \"%s\"\n",
	       handshake.error,
	       handshake.fatal_error,
	       handshake.buffer));
	TRACE_HANDSHAKE("writing", &handshake);
	IGNORE_RC(write(cp_pipe[1],
			(const char *) &handshake,
			sizeof(handshake)));
    } else {
	xtermWarning("fatal pty error errno=%d, error=%d device \"%s\"\n",
		     handshake.error,
		     handshake.fatal_error,
		     handshake.buffer);
	fprintf(stderr, "%s\n", SysErrorMsg(handshake.error));
	fprintf(stderr, "Reason: %s\n", SysReasonMsg(handshake.fatal_error));
    }
    exit(error);
}

void
first_map_occurred(void)
{
    if (resource.wait_for_map) {
	handshake_t handshake;
	TScreen *screen = TScreenOf(term);

	memset(&handshake, 0, sizeof(handshake));
	handshake.status = PTY_EXEC;
	handshake.rows = screen->max_row;
	handshake.cols = screen->max_col;

	if (pc_pipe[1] >= 0) {
	    TRACE(("first_map_occurred: %dx%d\n", handshake.rows, handshake.cols));
	    TRACE_HANDSHAKE("writing", &handshake);
	    IGNORE_RC(write(pc_pipe[1],
			    (const char *) &handshake,
			    sizeof(handshake)));
	    close(cp_pipe[0]);
	    close(pc_pipe[1]);
	}
	resource.wait_for_map = False;
    }
}
#else
/*
 * temporary hack to get xterm working on att ptys
 */
static void
HsSysError(int error)
{
    xtermWarning("fatal pty error %d (errno=%d) on tty %s\n",
		 error, errno, ttydev);
    exit(error);
}
#endif /* OPT_PTY_HANDSHAKE else !OPT_PTY_HANDSHAKE */

#ifndef VMS
static void
set_owner(char *device, unsigned uid, unsigned gid, unsigned mode)
{
    int why;

    TRACE_IDS;
    TRACE(("set_owner(%s, uid=%d, gid=%d, mode=%#o\n",
	   device, (int) uid, (int) gid, (unsigned) mode));

    if (chown(device, uid, gid) < 0) {
	why = errno;
	if (why != ENOENT
	    && save_ruid == 0) {
	    xtermPerror("Cannot chown %s to %ld,%ld",
			device, (long) uid, (long) gid);
	}
	TRACE(("...chown failed: %s\n", strerror(why)));
    } else if (chmod(device, mode) < 0) {
	why = errno;
	if (why != ENOENT) {
	    struct stat sb;
	    if (stat(device, &sb) < 0) {
		xtermPerror("Cannot chmod %s to %03o",
			    device, (unsigned) mode);
	    } else if (mode != (sb.st_mode & 0777U)) {
		xtermPerror("Cannot chmod %s to %03lo currently %03lo",
			    device,
			    (unsigned long) mode,
			    (unsigned long) (sb.st_mode & 0777U));
		TRACE(("...stat uid=%d, gid=%d, mode=%#o\n",
		       (int) sb.st_uid, (int) sb.st_gid, (unsigned) sb.st_mode));
	    }
	}
	TRACE(("...chmod failed: %s\n", strerror(why)));
    }
}

/*
 * utmp data may not be null-terminated; even if it is, there may be garbage
 * after the null.  This fills the unused part of the result with nulls.
 */
static void
copy_filled(char *target, const char *source, size_t len)
{
    size_t used = 0;
    while (used < len) {
	if ((target[used] = source[used]) == 0)
	    break;
	++used;
    }
    while (used < len) {
	target[used++] = '\0';
    }
}

#if defined(HAVE_UTMP) && defined(USE_SYSV_UTMP) && !defined(USE_UTEMPTER)
/*
 * getutid() only looks at ut_type and ut_id.
 * But we'll also check ut_line in find_utmp().
 */
static void
init_utmp(int type, struct UTMP_STR *tofind)
{
    memset(tofind, 0, sizeof(*tofind));
    tofind->ut_type = type;
    copy_filled(tofind->ut_id, my_utmp_id(ttydev), sizeof(tofind->ut_id));
    copy_filled(tofind->ut_line, my_pty_name(ttydev), sizeof(tofind->ut_line));
}

/*
 * We could use getutline() if we didn't support old systems.
 */
static struct UTMP_STR *
find_utmp(struct UTMP_STR *tofind)
{
    struct UTMP_STR *result;
    struct UTMP_STR limited;
    struct UTMP_STR working;

    for (;;) {
	memset(&working, 0, sizeof(working));
	working.ut_type = tofind->ut_type;
	copy_filled(working.ut_id, tofind->ut_id, sizeof(tofind->ut_id));
#if defined(__digital__) && defined(__unix__) && (defined(OSMAJORVERSION) && OSMAJORVERSION < 5)
	working.ut_type = 0;
#endif
	if ((result = call_getutid(&working)) == 0)
	    break;
	copy_filled(limited.ut_line, result->ut_line, sizeof(result->ut_line));
	if (!memcmp(limited.ut_line, tofind->ut_line, sizeof(limited.ut_line)))
	    break;
	/*
	 * Solaris, IRIX64 and HPUX manpages say to fill the static area
	 * pointed to by the return-value to zeros if searching for multiple
	 * occurrences.  Otherwise it will continue to return the same value.
	 */
	memset(result, 0, sizeof(*result));
    }
    return result;
}
#endif /* HAVE_UTMP... */

#define close_fd(fd) close(fd), fd = -1

#if defined(TIOCNOTTY) && (!defined(__GLIBC__) || (__GLIBC__ < 2) || ((__GLIBC__ == 2) && (__GLIBC_MINOR__ < 1)))
#define USE_NO_DEV_TTY 1
#else
#define USE_NO_DEV_TTY 0
#endif

static int
same_leaf(char *a, char *b)
{
    char *p = x_basename(a);
    char *q = x_basename(b);
    return !strcmp(p, q);
}

/*
 * "good enough" (inode wouldn't port to Cygwin)
 */
static int
same_file(const char *a, const char *b)
{
    struct stat asb;
    struct stat bsb;
    int result = 0;

    if ((stat(a, &asb) == 0)
	&& (stat(b, &bsb) == 0)
	&& ((asb.st_mode & S_IFMT) == S_IFREG)
	&& ((bsb.st_mode & S_IFMT) == S_IFREG)
	&& (asb.st_mtime == bsb.st_mtime)
	&& (asb.st_size == bsb.st_size)) {
	result = 1;
    }
    return result;
}

/*
 * Only set $SHELL for paths found in the standard location.
 */
static Boolean
validShell(const char *pathname)
{
    Boolean result = False;
    const char *ok_shells = "/etc/shells";
    char *blob;
    struct stat sb;
    size_t rc;
    FILE *fp;

    if (validProgram(pathname)
	&& stat(ok_shells, &sb) == 0
	&& (sb.st_mode & S_IFMT) == S_IFREG
	&& ((size_t) sb.st_size > 0)
	&& ((size_t) sb.st_size < (((size_t) ~0) - 2))
	&& (blob = calloc((size_t) sb.st_size + 2, sizeof(char))) != 0) {
	if ((fp = fopen(ok_shells, "r")) != 0) {
	    rc = fread(blob, sizeof(char), (size_t) sb.st_size, fp);
	    if (rc == (size_t) sb.st_size) {
		char *p = blob;
		char *q, *r;
		blob[rc] = '\0';
		while (!result && (q = strtok(p, "\n")) != 0) {
		    if ((r = x_strtrim(q)) != 0) {
			TRACE(("...test \"%s\"\n", q));
			if (!strcmp(q, pathname)) {
			    result = True;
			} else if (same_leaf(q, (char *) pathname) &&
				   same_file(q, pathname)) {
			    result = True;
			}
			free(r);
		    }
		    p = 0;
		}
	    }
	    fclose(fp);
	}
	free(blob);
    }
    TRACE(("validShell %s ->%d\n", NonNull(pathname), result));
    return result;
}

static char *
resetShell(char *oldPath)
{
    char *newPath = x_strdup("/bin/sh");
    char *envPath = getenv("SHELL");
    if (oldPath != 0)
	free(oldPath);
    if (!IsEmpty(envPath))
	xtermSetenv("SHELL", newPath);
    return newPath;
}

/*
 *  Inits pty and tty and forks a login process.
 *  Does not close fd Xsocket.
 *  If slave, the pty named in passedPty is already open for use
 */
static int
spawnXTerm(XtermWidget xw, unsigned line_speed)
{
    TScreen *screen = TScreenOf(xw);
    Cardinal nn;
#if OPT_PTY_HANDSHAKE
    Bool got_handshake_size = False;
    handshake_t handshake;
    int done;
#endif
#if OPT_INITIAL_ERASE
    int initial_erase = VAL_INITIAL_ERASE;
    Bool setInitialErase;
#endif
    int rc = 0;
    int ttyfd = -1;
    Bool ok_termcap;
    char *newtc;

#ifdef TERMIO_STRUCT
    TERMIO_STRUCT tio;
#ifdef __MVS__
    TERMIO_STRUCT gio;
#endif /* __MVS__ */
#ifdef TIOCLSET
    unsigned lmode;
#endif /* TIOCLSET */
#ifdef HAS_LTCHARS
    struct ltchars ltc;
#endif /* HAS_LTCHARS */
#else /* !TERMIO_STRUCT */
    int ldisc = 0;
    int discipline;
    unsigned lmode;
    struct tchars tc;
    struct ltchars ltc;
    struct sgttyb sg;
#ifdef sony
    int jmode;
    struct jtchars jtc;
#endif /* sony */
#endif /* TERMIO_STRUCT */

    char *shell_path = 0;
    char *shname, *shname_minus;
    int i;
#if USE_NO_DEV_TTY
    int no_dev_tty = False;
#endif
    const char *const *envnew;	/* new environment */
    char buf[64];
    char *TermName = NULL;
#ifdef TTYSIZE_STRUCT
    TTYSIZE_STRUCT ts;
#endif
    struct passwd pw;
    char *login_name = NULL;
#ifndef USE_UTEMPTER
#ifdef HAVE_UTMP
    struct UTMP_STR utmp;
#ifdef USE_SYSV_UTMP
    struct UTMP_STR *utret = NULL;
#endif
#ifdef USE_LASTLOG
    struct lastlog lastlog;
#endif
#ifdef USE_LASTLOGX
    struct lastlogx lastlogx;
#endif /* USE_LASTLOG */
#endif /* HAVE_UTMP */
#endif /* !USE_UTEMPTER */

#if OPT_TRACE
    unsigned long xterm_parent = (unsigned long) getpid();
#endif

    /* Noisy compilers (suppress some unused-variable warnings) */
    (void) rc;
#if defined(HAVE_UTMP) && defined(USE_SYSV_UTMP) && !defined(USE_UTEMPTER)
    (void) utret;
#endif

    screen->uid = save_ruid;
    screen->gid = save_rgid;

#ifdef SIGTTOU
    /* so that TIOCSWINSZ || TIOCSIZE doesn't block */
    signal(SIGTTOU, SIG_IGN);
#endif

#if OPT_PTY_HANDSHAKE
    memset(&handshake, 0, sizeof(handshake));
#endif

    if (am_slave >= 0) {
	screen->respond = am_slave;
	set_pty_id(ttydev, passedPty);
#ifdef USE_PTY_DEVICE
	set_pty_id(ptydev, passedPty);
#endif
	if (xtermResetIds(screen) < 0)
	    exit(1);
    } else {
	Bool tty_got_hung;

	/*
	 * Sometimes /dev/tty hangs on open (as in the case of a pty
	 * that has gone away).  Simply make up some reasonable
	 * defaults.
	 */

	signal(SIGALRM, hungtty);
	alarm(2);		/* alarm(1) might return too soon */
	if (!sigsetjmp(env, 1)) {
	    ttyfd = open("/dev/tty", O_RDWR);
	    alarm(0);
	    tty_got_hung = False;
	} else {
	    tty_got_hung = True;
	    ttyfd = -1;
	    errno = ENXIO;
	}
	shell_path = 0;
	memset(&pw, 0, sizeof(pw));
#if OPT_PTY_HANDSHAKE
	got_handshake_size = False;
#endif /* OPT_PTY_HANDSHAKE */
#if OPT_INITIAL_ERASE
	initial_erase = VAL_INITIAL_ERASE;
#endif
	signal(SIGALRM, SIG_DFL);

	/*
	 * Check results and ignore current control terminal if
	 * necessary.  ENXIO is what is normally returned if there is
	 * no controlling terminal, but some systems (e.g. SunOS 4.0)
	 * seem to return EIO.  Solaris 2.3 is said to return EINVAL.
	 * Cygwin returns ENOENT.  FreeBSD can return ENOENT, especially
	 * if xterm is run within a jail.
	 */
#if USE_NO_DEV_TTY
	no_dev_tty = False;
#endif
	if (ttyfd < 0) {
	    if (tty_got_hung || errno == ENXIO || errno == EIO ||
		errno == ENOENT ||
#ifdef ENODEV
		errno == ENODEV ||
#endif
		errno == EINVAL || errno == ENOTTY || errno == EACCES) {
#if USE_NO_DEV_TTY
		no_dev_tty = True;
#endif
#ifdef HAS_LTCHARS
		ltc = d_ltc;
#endif /* HAS_LTCHARS */
#ifdef TIOCLSET
		lmode = d_lmode;
#endif /* TIOCLSET */
#ifdef TERMIO_STRUCT
		tio = d_tio;
#else /* !TERMIO_STRUCT */
		sg = d_sg;
		tc = d_tc;
		discipline = d_disipline;
#ifdef sony
		jmode = d_jmode;
		jtc = d_jtc;
#endif /* sony */
#endif /* TERMIO_STRUCT */
	    } else {
		SysError(ERROR_OPDEVTTY);
	    }
	} else {

	    /* Get a copy of the current terminal's state,
	     * if we can.  Some systems (e.g., SVR4 and MacII)
	     * may not have a controlling terminal at this point
	     * if started directly from xdm or xinit,
	     * in which case we just use the defaults as above.
	     */
#ifdef HAS_LTCHARS
	    if (ioctl(ttyfd, TIOCGLTC, &ltc) == -1)
		ltc = d_ltc;
#endif /* HAS_LTCHARS */
#ifdef TIOCLSET
	    if (ioctl(ttyfd, TIOCLGET, &lmode) == -1)
		lmode = d_lmode;
#endif /* TIOCLSET */
#ifdef TERMIO_STRUCT
	    rc = ttyGetAttr(ttyfd, &tio);
	    if (rc == -1)
		tio = d_tio;
#else /* !TERMIO_STRUCT */
	    rc = ioctl(ttyfd, TIOCGETP, (char *) &sg);
	    if (rc == -1)
		sg = d_sg;
	    if (ioctl(ttyfd, TIOCGETC, (char *) &tc) == -1)
		tc = d_tc;
	    if (ioctl(ttyfd, TIOCGETD, (char *) &discipline) == -1)
		discipline = d_disipline;
#ifdef sony
	    if (ioctl(ttyfd, TIOCKGET, (char *) &jmode) == -1)
		jmode = d_jmode;
	    if (ioctl(ttyfd, TIOCKGETC, (char *) &jtc) == -1)
		jtc = d_jtc;
#endif /* sony */
#endif /* TERMIO_STRUCT */

	    /*
	     * If ptyInitialErase is set, we want to get the pty's
	     * erase value.  Just in case that will fail, first get
	     * the value from /dev/tty, so we will have something
	     * at least.
	     */
#if OPT_INITIAL_ERASE
	    if (resource.ptyInitialErase) {
#ifdef TERMIO_STRUCT
		initial_erase = tio.c_cc[VERASE];
#else /* !TERMIO_STRUCT */
		initial_erase = sg.sg_erase;
#endif /* TERMIO_STRUCT */
		TRACE(("%s initial_erase:%d (from /dev/tty)\n",
		       rc == 0 ? "OK" : "FAIL",
		       initial_erase));
	    }
#endif
#ifdef __MVS__
	    if (ttyGetAttr(ttyfd, &gio) == 0) {
		gio.c_cflag &= ~(HUPCL | PARENB);
		ttySetAttr(ttyfd, &gio);
	    }
#endif /* __MVS__ */

	    close_fd(ttyfd);
	}

	if (get_pty(&screen->respond, XDisplayString(screen->display))) {
	    SysError(ERROR_PTYS);
	}
	TRACE_TTYSIZE(screen->respond, "after get_pty");
#if OPT_INITIAL_ERASE
	if (resource.ptyInitialErase) {
#ifdef TERMIO_STRUCT
	    TERMIO_STRUCT my_tio;
	    rc = ttyGetAttr(screen->respond, &my_tio);
	    if (rc == 0)
		initial_erase = my_tio.c_cc[VERASE];
#else /* !TERMIO_STRUCT */
	    struct sgttyb my_sg;
	    rc = ioctl(screen->respond, TIOCGETP, (char *) &my_sg);
	    if (rc == 0)
		initial_erase = my_sg.sg_erase;
#endif /* TERMIO_STRUCT */
	    TRACE(("%s initial_erase:%d (from pty)\n",
		   (rc == 0) ? "OK" : "FAIL",
		   initial_erase));
	}
#endif /* OPT_INITIAL_ERASE */
    }

    /* avoid double MapWindow requests */
    XtSetMappedWhenManaged(SHELL_OF(CURRENT_EMU()), False);

    wm_delete_window = XInternAtom(XtDisplay(toplevel), "WM_DELETE_WINDOW",
				   False);

    if (!TEK4014_ACTIVE(xw))
	VTInit(xw);		/* realize now so know window size for tty driver */
#if defined(TIOCCONS) || defined(SRIOCSREDIR)
    if (Console) {
	/*
	 * Inform any running xconsole program
	 * that we are going to steal the console.
	 */
	XmuGetHostname(mit_console_name + MIT_CONSOLE_LEN, 255);
	mit_console = XInternAtom(screen->display, mit_console_name, False);
	/* the user told us to be the console, so we can use CurrentTime */
	XtOwnSelection(SHELL_OF(CURRENT_EMU()),
		       mit_console, CurrentTime,
		       ConvertConsoleSelection, NULL, NULL);
    }
#endif
#if OPT_TEK4014
    if (TEK4014_ACTIVE(xw)) {
	envnew = tekterm;
    } else
#endif
    {
	envnew = vtterm;
    }

    /*
     * This used to exit if no termcap entry was found for the specified
     * terminal name.  That's a little unfriendly, so instead we'll allow
     * the program to proceed (but not to set $TERMCAP) if the termcap
     * entry is not found.
     */
    ok_termcap = True;
    if (!get_termcap(xw, TermName = resource.term_name)) {
	const char *last = NULL;
	char *next;

	TermName = x_strdup(*envnew);
	ok_termcap = False;
	while (*envnew != NULL) {
	    if (last == NULL || strcmp(last, *envnew)) {
		next = x_strdup(*envnew);
		if (get_termcap(xw, next)) {
		    free(TermName);
		    TermName = next;
		    ok_termcap = True + 1;
		    break;
		} else {
		    free(next);
		}
	    }
	    last = *envnew;
	    envnew++;
	}
    }
    if (ok_termcap) {
	resource.term_name = TermName;
	resize_termcap(xw);
    }

    /*
     * Check if ptyInitialErase is not set.  If so, we rely on the termcap
     * (or terminfo) to tell us what the erase mode should be set to.
     */
#if OPT_INITIAL_ERASE
    TRACE(("resource ptyInitialErase is %sset\n",
	   resource.ptyInitialErase ? "" : "not "));
    setInitialErase = False;
    if (override_tty_modes && ttymodelist[XTTYMODE_erase].set) {
	initial_erase = ttymodelist[XTTYMODE_erase].value;
	setInitialErase = True;
    } else if (resource.ptyInitialErase) {
	/* EMPTY */ ;
    } else if (ok_termcap) {
	char *s = get_tcap_erase(xw);
	TRACE(("...extracting initial_erase value from termcap\n"));
	if (s != 0) {
	    char *save = s;
	    initial_erase = decode_keyvalue(&s, True);
	    setInitialErase = True;
	    free(save);
	}
    }
    TRACE(("...initial_erase:%d\n", initial_erase));

    TRACE(("resource backarrowKeyIsErase is %sset\n",
	   resource.backarrow_is_erase ? "" : "not "));
    if (resource.backarrow_is_erase) {	/* see input.c */
	if (initial_erase == ANSI_DEL) {
	    UIntClr(xw->keyboard.flags, MODE_DECBKM);
	} else {
	    xw->keyboard.flags |= MODE_DECBKM;
	    xw->keyboard.reset_DECBKM = 1;
	}
	TRACE(("...sets DECBKM %s\n",
	       (xw->keyboard.flags & MODE_DECBKM) ? "on" : "off"));
    } else {
	xw->keyboard.reset_DECBKM = 2;
    }
#endif /* OPT_INITIAL_ERASE */

#ifdef TTYSIZE_STRUCT
    /* tell tty how big window is */
#if OPT_TEK4014
    if (TEK4014_ACTIVE(xw)) {
	TTYSIZE_ROWS(ts) = 38;
	TTYSIZE_COLS(ts) = 81;
#if defined(USE_STRUCT_WINSIZE)
	ts.ws_xpixel = TFullWidth(TekScreenOf(tekWidget));
	ts.ws_ypixel = TFullHeight(TekScreenOf(tekWidget));
#endif
    } else
#endif
    {
	TTYSIZE_ROWS(ts) = (ttySize_t) MaxRows(screen);
	TTYSIZE_COLS(ts) = (ttySize_t) MaxCols(screen);
#if defined(USE_STRUCT_WINSIZE)
	ts.ws_xpixel = (ttySize_t) FullWidth(screen);
	ts.ws_ypixel = (ttySize_t) FullHeight(screen);
#endif
    }
    TRACE_RC(i, SET_TTYSIZE(screen->respond, ts));
    TRACE(("spawn SET_TTYSIZE %dx%d return %d\n",
	   TTYSIZE_ROWS(ts),
	   TTYSIZE_COLS(ts), i));
#endif /* TTYSIZE_STRUCT */

#if !defined(USE_OPENPTY)
#if defined(USE_USG_PTYS) || defined(HAVE_POSIX_OPENPT)
    /*
     * utempter checks the ownership of the device; some implementations
     * set ownership in grantpt - do this first.
     */
    grantpt(screen->respond);
#endif
#if !defined(USE_USG_PTYS) && defined(HAVE_POSIX_OPENPT)
    unlockpt(screen->respond);
    TRACE_TTYSIZE(screen->respond, "after unlockpt");
#endif
#endif /* !USE_OPENPTY */

    added_utmp_entry = False;
#if defined(USE_UTEMPTER)
#undef UTMP
    if ((xw->misc.login_shell || !command_to_exec) && !resource.utmpInhibit) {
	struct UTMP_STR dummy;

	/* Note: utempter may trim it anyway */
	SetUtmpHost(dummy.ut_host, screen);
	TRACE(("...calling addToUtmp(pty=%s, hostname=%s, master_fd=%d)\n",
	       ttydev, dummy.ut_host, screen->respond));
	addToUtmp(ttydev, dummy.ut_host, screen->respond);
	added_utmp_entry = True;
    }
#endif

    if (am_slave < 0) {
#if OPT_PTY_HANDSHAKE
	if (resource.ptyHandshake && (pipe(pc_pipe) || pipe(cp_pipe)))
	    SysError(ERROR_FORK);
#endif
	TRACE(("Forking...\n"));
	if ((screen->pid = fork()) == -1)
	    SysError(ERROR_FORK);

	if (screen->pid == 0) {
#ifdef USE_USG_PTYS
	    int ptyfd = -1;
	    char *pty_name;
#endif
	    /*
	     * now in child process
	     */
#if defined(_POSIX_SOURCE) || defined(SVR4) || defined(__convex__) || defined(__SCO__) || defined(__QNX__)
	    int pgrp = setsid();	/* variable may not be used... */
#else
	    int pgrp = getpid();
#endif
	    TRACE_CHILD

#ifdef USE_USG_PTYS
#ifdef HAVE_SETPGID
		setpgid(0, 0);
#else
		setpgrp();
#endif
	    unlockpt(screen->respond);
	    TRACE_TTYSIZE(screen->respond, "after unlockpt");
	    if ((pty_name = ptsname(screen->respond)) == 0) {
		SysError(ERROR_PTSNAME);
	    } else if ((ptyfd = open(pty_name, O_RDWR)) < 0) {
		SysError(ERROR_OPPTSNAME);
	    }
#ifdef I_PUSH
	    else if (PUSH_FAILS(ptyfd, "ptem")) {
		SysError(ERROR_PTEM);
	    }
#if !defined(SVR4) && !(defined(SYSV) && defined(i386))
	    else if (!x_getenv("CONSEM")
		     && PUSH_FAILS(ptyfd, "consem")) {
		SysError(ERROR_CONSEM);
	    }
#endif /* !SVR4 */
	    else if (PUSH_FAILS(ptyfd, "ldterm")) {
		SysError(ERROR_LDTERM);
	    }
#ifdef SVR4			/* from Sony */
	    else if (PUSH_FAILS(ptyfd, "ttcompat")) {
		SysError(ERROR_TTCOMPAT);
	    }
#endif /* SVR4 */
#endif /* I_PUSH */
	    ttyfd = ptyfd;
#ifndef __MVS__
	    close_fd(screen->respond);
#endif /* __MVS__ */

#ifdef TTYSIZE_STRUCT
	    /* tell tty how big window is */
#if OPT_TEK4014
	    if (TEK4014_ACTIVE(xw)) {
		TTYSIZE_ROWS(ts) = 24;
		TTYSIZE_COLS(ts) = 80;
#ifdef USE_STRUCT_WINSIZE
		ts.ws_xpixel = TFullWidth(TekScreenOf(tekWidget));
		ts.ws_ypixel = TFullHeight(TekScreenOf(tekWidget));
#endif
	    } else
#endif /* OPT_TEK4014 */
	    {
		TTYSIZE_ROWS(ts) = (ttySize_t) MaxRows(screen);
		TTYSIZE_COLS(ts) = (ttySize_t) MaxCols(screen);
#ifdef USE_STRUCT_WINSIZE
		ts.ws_xpixel = (ttySize_t) FullWidth(screen);
		ts.ws_ypixel = (ttySize_t) FullHeight(screen);
#endif
	    }
#endif /* TTYSIZE_STRUCT */

#endif /* USE_USG_PTYS */

	    (void) pgrp;	/* not all branches use this variable */

#if OPT_PTY_HANDSHAKE		/* warning, goes for a long ways */
	    if (resource.ptyHandshake) {
		char *ptr;

		/* close parent's sides of the pipes */
		close(cp_pipe[0]);
		close(pc_pipe[1]);

		/* Make sure that our sides of the pipes are not in the
		 * 0, 1, 2 range so that we don't fight with stdin, out
		 * or err.
		 */
		if (cp_pipe[1] <= 2) {
		    if ((i = fcntl(cp_pipe[1], F_DUPFD, 3)) >= 0) {
			IGNORE_RC(close(cp_pipe[1]));
			cp_pipe[1] = i;
		    }
		}
		if (pc_pipe[0] <= 2) {
		    if ((i = fcntl(pc_pipe[0], F_DUPFD, 3)) >= 0) {
			IGNORE_RC(close(pc_pipe[0]));
			pc_pipe[0] = i;
		    }
		}

		/* we don't need the socket, or the pty master anymore */
		close(ConnectionNumber(screen->display));
#ifndef __MVS__
		if (screen->respond >= 0)
		    close(screen->respond);
#endif /* __MVS__ */

		/* Now is the time to set up our process group and
		 * open up the pty slave.
		 */
#ifdef USE_SYSV_PGRP
#if defined(CRAY) && (OSMAJORVERSION > 5)
		IGNORE_RC(setsid());
#else
		IGNORE_RC(setpgrp());
#endif
#endif /* USE_SYSV_PGRP */

#if defined(__QNX__) && !defined(__QNXNTO__)
		qsetlogin(getlogin(), ttydev);
#endif
		if (ttyfd >= 0) {
#ifdef __MVS__
		    if (ttyGetAttr(ttyfd, &gio) == 0) {
			gio.c_cflag &= ~(HUPCL | PARENB);
			ttySetAttr(ttyfd, &gio);
		    }
#else /* !__MVS__ */
		    close_fd(ttyfd);
#endif /* __MVS__ */
		}

		for (;;) {
#if USE_NO_DEV_TTY
		    if (!no_dev_tty
			&& (ttyfd = open("/dev/tty", O_RDWR)) >= 0) {
			ioctl(ttyfd, TIOCNOTTY, (char *) NULL);
			close_fd(ttyfd);
		    }
#endif /* USE_NO_DEV_TTY */
#ifdef CSRG_BASED
		    IGNORE_RC(revoke(ttydev));
#endif
		    if ((ttyfd = open(ttydev, O_RDWR)) >= 0) {
			TRACE_TTYSIZE(ttyfd, "after open");
			TRACE_RC(i, SET_TTYSIZE(ttyfd, ts));
			TRACE_TTYSIZE(ttyfd, "after fixup");
#if defined(CRAY) && defined(TCSETCTTY)
			/* make /dev/tty work */
			ioctl(ttyfd, TCSETCTTY, 0);
#endif
#if ((defined(__GLIBC__) && defined(__FreeBSD_kernel__)) || defined(__GNU__)) && defined(TIOCSCTTY)
			/* make /dev/tty work */
			ioctl(ttyfd, TIOCSCTTY, 0);
#endif
#ifdef USE_SYSV_PGRP
			/* We need to make sure that we are actually
			 * the process group leader for the pty.  If
			 * we are, then we should now be able to open
			 * /dev/tty.
			 */
			if ((i = open("/dev/tty", O_RDWR)) >= 0) {
			    /* success! */
			    close(i);
			    break;
			}
#else /* USE_SYSV_PGRP */
			break;
#endif /* USE_SYSV_PGRP */
		    }
		    perror("open ttydev");
#ifdef TIOCSCTTY
		    ioctl(ttyfd, TIOCSCTTY, 0);
#endif
		    /* let our master know that the open failed */
		    handshake.status = PTY_BAD;
		    handshake.error = errno;
		    strncpy(handshake.buffer, ttydev, sizeof(handshake.buffer));
		    TRACE_HANDSHAKE("writing", &handshake);
		    IGNORE_RC(write(cp_pipe[1],
				    (const char *) &handshake,
				    sizeof(handshake)));

		    /* get reply from parent */
		    i = (int) read(pc_pipe[0], (char *) &handshake,
				   sizeof(handshake));
		    if (i <= 0) {
			/* parent terminated */
			exit(1);
		    }

		    if (handshake.status == PTY_NOMORE) {
			/* No more ptys, let's shutdown. */
			exit(1);
		    }

		    /* We have a new pty to try */
		    if (ttyfd >= 0)
			close(ttyfd);
		    free(ttydev);
		    ttydev = x_strdup(handshake.buffer);
		}

		/* use the same tty name that everyone else will use
		 * (from ttyname)
		 */
		if ((ptr = ttyname(ttyfd)) != 0) {
		    free(ttydev);
		    ttydev = x_strdup(ptr);
		}
	    }
#endif /* OPT_PTY_HANDSHAKE -- from near fork */

	    set_pty_permissions(screen->uid,
				screen->gid,
				(resource.messages
				 ? 0622U
				 : 0600U));

	    /*
	     * set up the tty modes
	     */
	    {
#ifdef TERMIO_STRUCT
#if defined(umips) || defined(CRAY) || defined(linux)
		/* If the control tty had its modes screwed around with,
		   eg. by lineedit in the shell, or emacs, etc. then tio
		   will have bad values.  Let's just get termio from the
		   new tty and tailor it.  */
		if (ttyGetAttr(ttyfd, &tio) == -1)
		    SysError(ERROR_TIOCGETP);
		tio.c_lflag |= ECHOE;
#endif /* umips */
		/* Now is also the time to change the modes of the
		 * child pty.
		 */
		/* input: nl->nl, don't ignore cr, cr->nl */
		UIntClr(tio.c_iflag, (INLCR | IGNCR));
		tio.c_iflag |= ICRNL;
#if OPT_WIDE_CHARS && defined(IUTF8)
#if OPT_LUIT_PROG
		if (command_to_exec_with_luit == 0)
#endif
		    if (screen->utf8_mode)
			tio.c_iflag |= IUTF8;
#endif
		/* ouput: cr->cr, nl is not return, no delays, ln->cr/nl */
#ifndef USE_POSIX_TERMIOS
		UIntClr(tio.c_oflag,
			(OCRNL
			 | ONLRET
			 | NLDLY
			 | CRDLY
			 | TABDLY
			 | BSDLY
			 | VTDLY
			 | FFDLY));
#endif /* USE_POSIX_TERMIOS */
#ifdef ONLCR
		tio.c_oflag |= ONLCR;
#endif /* ONLCR */
#ifdef OPOST
		tio.c_oflag |= OPOST;
#endif /* OPOST */
#ifndef USE_POSIX_TERMIOS
# if defined(Lynx) && !defined(CBAUD)
#  define CBAUD V_CBAUD
# endif
		UIntClr(tio.c_cflag, CBAUD);
#ifdef BAUD_0
		/* baud rate is 0 (don't care) */
#elif defined(HAVE_TERMIO_C_ISPEED)
		tio.c_ispeed = tio.c_ospeed = line_speed;
#else /* !BAUD_0 */
		tio.c_cflag |= line_speed;
#endif /* !BAUD_0 */
#else /* USE_POSIX_TERMIOS */
		cfsetispeed(&tio, line_speed);
		cfsetospeed(&tio, line_speed);
#ifdef __MVS__
		/* turn off bits that can't be set from the slave side */
		tio.c_cflag &= ~(PACKET | PKT3270 | PTU3270 | PKTXTND);
#endif /* __MVS__ */
		/* Clear CLOCAL so that SIGHUP is sent to us
		   when the xterm ends */
		tio.c_cflag &= (unsigned) ~CLOCAL;
#endif /* USE_POSIX_TERMIOS */
		/* enable signals, canonical processing (erase, kill, etc),
		 * echo
		 */
		tio.c_lflag |= ISIG | ICANON | ECHO | ECHOE | ECHOK;
#ifdef ECHOKE
		tio.c_lflag |= ECHOKE | IEXTEN;
#endif
#ifdef ECHOCTL
		tio.c_lflag |= ECHOCTL | IEXTEN;
#endif
		for (nn = 0; nn < XtNumber(known_ttyChars); ++nn) {
		    if (validTtyChar(tio, nn)) {
			int sysMode = known_ttyChars[nn].sysMode;
#ifdef __MVS__
			if (tio.c_cc[sysMode] != 0) {
			    switch (sysMode) {
			    case VEOL:
			    case VEOF:
				continue;
			    }
			}
#endif
			tio.c_cc[sysMode] = (cc_t) known_ttyChars[nn].myDefault;
		    }
		}

		if (override_tty_modes) {
		    for (nn = 0; nn < XtNumber(known_ttyChars); ++nn) {
			if (validTtyChar(tio, nn)) {
			    TMODE(known_ttyChars[nn].myMode,
				  tio.c_cc[known_ttyChars[nn].sysMode]);
			}
		    }
#ifdef HAS_LTCHARS
		    /* both SYSV and BSD have ltchars */
		    TMODE(XTTYMODE_susp, ltc.t_suspc);
		    TMODE(XTTYMODE_dsusp, ltc.t_dsuspc);
		    TMODE(XTTYMODE_rprnt, ltc.t_rprntc);
		    TMODE(XTTYMODE_flush, ltc.t_flushc);
		    TMODE(XTTYMODE_weras, ltc.t_werasc);
		    TMODE(XTTYMODE_lnext, ltc.t_lnextc);
#endif
		}
#ifdef HAS_LTCHARS
#ifdef __hpux
		/* ioctl chokes when the "reserved" process group controls
		 * are not set to _POSIX_VDISABLE */
		ltc.t_rprntc = ltc.t_rprntc = ltc.t_flushc =
		    ltc.t_werasc = ltc.t_lnextc = _POSIX_VDISABLE;
#endif /* __hpux */
		if (ioctl(ttyfd, TIOCSLTC, &ltc) == -1)
		    HsSysError(ERROR_TIOCSETC);
#endif /* HAS_LTCHARS */
#ifdef TIOCLSET
		if (ioctl(ttyfd, TIOCLSET, (char *) &lmode) == -1)
		    HsSysError(ERROR_TIOCLSET);
#endif /* TIOCLSET */
		if (ttySetAttr(ttyfd, &tio) == -1)
		    HsSysError(ERROR_TIOCSETP);

		/* ignore errors here - some platforms don't work */
		UIntClr(tio.c_cflag, CSIZE);
		if (screen->input_eight_bits)
		    tio.c_cflag |= CS8;
		else
		    tio.c_cflag |= CS7;
		(void) ttySetAttr(ttyfd, &tio);

#else /* !TERMIO_STRUCT */
		sg.sg_flags &= ~(ALLDELAY | XTABS | CBREAK | RAW);
		sg.sg_flags |= ECHO | CRMOD;
		/* make sure speed is set on pty so that editors work right */
		sg.sg_ispeed = line_speed;
		sg.sg_ospeed = line_speed;
		/* reset t_brkc to default value */
		tc.t_brkc = -1;
#ifdef LPASS8
		if (screen->input_eight_bits)
		    lmode |= LPASS8;
		else
		    lmode &= ~(LPASS8);
#endif
#ifdef sony
		jmode &= ~KM_KANJI;
#endif /* sony */

		ltc = d_ltc;

		if (override_tty_modes) {
		    TMODE(XTTYMODE_intr, tc.t_intrc);
		    TMODE(XTTYMODE_quit, tc.t_quitc);
		    TMODE(XTTYMODE_erase, sg.sg_erase);
		    TMODE(XTTYMODE_kill, sg.sg_kill);
		    TMODE(XTTYMODE_eof, tc.t_eofc);
		    TMODE(XTTYMODE_start, tc.t_startc);
		    TMODE(XTTYMODE_stop, tc.t_stopc);
		    TMODE(XTTYMODE_brk, tc.t_brkc);
		    /* both SYSV and BSD have ltchars */
		    TMODE(XTTYMODE_susp, ltc.t_suspc);
		    TMODE(XTTYMODE_dsusp, ltc.t_dsuspc);
		    TMODE(XTTYMODE_rprnt, ltc.t_rprntc);
		    TMODE(XTTYMODE_flush, ltc.t_flushc);
		    TMODE(XTTYMODE_weras, ltc.t_werasc);
		    TMODE(XTTYMODE_lnext, ltc.t_lnextc);
		}

		if (ioctl(ttyfd, TIOCSETP, (char *) &sg) == -1)
		    HsSysError(ERROR_TIOCSETP);
		if (ioctl(ttyfd, TIOCSETC, (char *) &tc) == -1)
		    HsSysError(ERROR_TIOCSETC);
		if (ioctl(ttyfd, TIOCSETD, (char *) &discipline) == -1)
		    HsSysError(ERROR_TIOCSETD);
		if (ioctl(ttyfd, TIOCSLTC, (char *) &ltc) == -1)
		    HsSysError(ERROR_TIOCSLTC);
		if (ioctl(ttyfd, TIOCLSET, (char *) &lmode) == -1)
		    HsSysError(ERROR_TIOCLSET);
#ifdef sony
		if (ioctl(ttyfd, TIOCKSET, (char *) &jmode) == -1)
		    HsSysError(ERROR_TIOCKSET);
		if (ioctl(ttyfd, TIOCKSETC, (char *) &jtc) == -1)
		    HsSysError(ERROR_TIOCKSETC);
#endif /* sony */
#endif /* TERMIO_STRUCT */
#if defined(TIOCCONS) || defined(SRIOCSREDIR)
		if (Console) {
#ifdef TIOCCONS
		    int on = 1;
		    if (ioctl(ttyfd, TIOCCONS, (char *) &on) == -1)
			xtermPerror("cannot open console");
#endif
#ifdef SRIOCSREDIR
		    int fd = open("/dev/console", O_RDWR);
		    if (fd == -1 || ioctl(fd, SRIOCSREDIR, ttyfd) == -1)
			xtermPerror("cannot open console");
		    IGNORE_RC(close(fd));
#endif
		}
#endif /* TIOCCONS */
	    }

	    signal(SIGCHLD, SIG_DFL);
#ifdef USE_SYSV_SIGHUP
	    /* watch out for extra shells (I don't understand either) */
	    signal(SIGHUP, SIG_DFL);
#else
	    signal(SIGHUP, SIG_IGN);
#endif
	    /* restore various signals to their defaults */
	    signal(SIGINT, SIG_DFL);
	    signal(SIGQUIT, SIG_DFL);
	    signal(SIGTERM, SIG_DFL);

	    /*
	     * If we're not asked to let the parent process set the terminal's
	     * erase mode, or if we had the ttyModes erase resource, then set
	     * the terminal's erase mode from our best guess.
	     */
#if OPT_INITIAL_ERASE
	    TRACE(("check if we should set erase to %d:%s\n\tptyInitialErase:%d,\n\toveride_tty_modes:%d,\n\tXTTYMODE_erase:%d\n",
		   initial_erase,
		   setInitialErase ? "YES" : "NO",
		   resource.ptyInitialErase,
		   override_tty_modes,
		   ttymodelist[XTTYMODE_erase].set));
	    if (setInitialErase) {
#if OPT_TRACE
		int old_erase;
#endif
#ifdef TERMIO_STRUCT
		if (ttyGetAttr(ttyfd, &tio) == -1)
		    tio = d_tio;
#if OPT_TRACE
		old_erase = tio.c_cc[VERASE];
#endif
		tio.c_cc[VERASE] = (cc_t) initial_erase;
		TRACE_RC(rc, ttySetAttr(ttyfd, &tio));
#else /* !TERMIO_STRUCT */
		if (ioctl(ttyfd, TIOCGETP, (char *) &sg) == -1)
		    sg = d_sg;
#if OPT_TRACE
		old_erase = sg.sg_erase;
#endif
		sg.sg_erase = initial_erase;
		rc = ioctl(ttyfd, TIOCSETP, (char *) &sg);
#endif /* TERMIO_STRUCT */
		TRACE(("%s setting erase to %d (was %d)\n",
		       rc ? "FAIL" : "OK", initial_erase, old_erase));
	    }
#endif

	    xtermCopyEnv(environ);

	    /*
	     * standards.freedesktop.org/startup-notification-spec/
	     * notes that this variable is used when a "reliable" mechanism is
	     * not available; in practice it must be unset to avoid confusing
	     * GTK applications.
	     */
	    xtermUnsetenv("DESKTOP_STARTUP_ID");
	    /*
	     * We set this temporarily to work around poor design of Xcursor.
	     * Unset it here to avoid confusion.
	     */
	    xtermUnsetenv("XCURSOR_PATH");

	    xtermSetenv("TERM", resource.term_name);
	    if (!resource.term_name)
		*get_tcap_buffer(xw) = 0;

	    sprintf(buf, "%lu",
		    ((unsigned long) XtWindow(SHELL_OF(CURRENT_EMU()))));
	    xtermSetenv("WINDOWID", buf);

	    /* put the display into the environment of the shell */
	    xtermSetenv("DISPLAY", XDisplayString(screen->display));

	    xtermSetenv("XTERM_VERSION", xtermVersion());
	    xtermSetenv("XTERM_LOCALE", xtermEnvLocale());

	    /*
	     * For debugging only, add environment variables that can be used
	     * in scripts to selectively kill xterm's parent or child
	     * processes.
	     */
#if OPT_TRACE
	    sprintf(buf, "%lu", (unsigned long) xterm_parent);
	    xtermSetenv("XTERM_PARENT", buf);
	    sprintf(buf, "%lu", (unsigned long) getpid());
	    xtermSetenv("XTERM_CHILD", buf);
#endif

	    signal(SIGTERM, SIG_DFL);

	    /* this is the time to go and set up stdin, out, and err
	     */
	    {
#if defined(CRAY) && (OSMAJORVERSION >= 6)
		close_fd(ttyfd);

		IGNORE_RC(close(0));

		if (open("/dev/tty", O_RDWR)) {
		    SysError(ERROR_OPDEVTTY);
		}
		IGNORE_RC(close(1));
		IGNORE_RC(close(2));
		dup(0);
		dup(0);
#else
		/* dup the tty */
		for (i = 0; i <= 2; i++)
		    if (i != ttyfd) {
			IGNORE_RC(close(i));
			IGNORE_RC(dup(ttyfd));
		    }
#ifndef ATT
		/* and close the tty */
		if (ttyfd > 2)
		    close_fd(ttyfd);
#endif
#endif /* CRAY */
	    }

#if !defined(USE_SYSV_PGRP)
#ifdef TIOCSCTTY
	    setsid();
	    ioctl(0, TIOCSCTTY, 0);
#endif
	    ioctl(0, TIOCSPGRP, (char *) &pgrp);
	    setpgrp(0, 0);
	    close(open(ttydev, O_WRONLY));
	    setpgrp(0, pgrp);
#if defined(__QNX__)
	    tcsetpgrp(0, pgrp /*setsid() */ );
#endif
#endif /* !USE_SYSV_PGRP */

#ifdef Lynx
	    {
		TERMIO_STRUCT t;
		if (ttyGetAttr(0, &t) >= 0) {
		    /* this gets lost somewhere on our way... */
		    t.c_oflag |= OPOST;
		    ttySetAttr(0, &t);
		}
	    }
#endif

#ifdef HAVE_UTMP
	    login_name = NULL;
	    if (x_getpwuid(screen->uid, &pw)) {
		login_name = x_getlogin(screen->uid, &pw);
	    }
	    if (login_name != NULL) {
		xtermSetenv("LOGNAME", login_name);	/* for POSIX */
	    }
#ifndef USE_UTEMPTER
#ifdef USE_UTMP_SETGID
	    setEffectiveGroup(save_egid);
	    TRACE_IDS;
#endif
#ifdef USE_SYSV_UTMP
	    /* Set up our utmp entry now.  We need to do it here
	     * for the following reasons:
	     *   - It needs to have our correct process id (for
	     *     login).
	     *   - If our parent was to set it after the fork(),
	     *     it might make it out before we need it.
	     *   - We need to do it before we go and change our
	     *     user and group id's.
	     */
	    (void) call_setutent();
	    init_utmp(DEAD_PROCESS, &utmp);

	    /* position to entry in utmp file */
	    /* Test return value: beware of entries left behind: PSz 9 Mar 00 */
	    utret = find_utmp(&utmp);
	    if (utret == 0) {
		(void) call_setutent();
		init_utmp(USER_PROCESS, &utmp);
		utret = find_utmp(&utmp);
		if (utret == 0) {
		    (void) call_setutent();
		}
	    }
#if OPT_TRACE
	    if (!utret)
		TRACE(("getutid: NULL\n"));
	    else
		TRACE(("getutid: pid=%d type=%d user=%s line=%.*s id=%.*s\n",
		       (int) utret->ut_pid, utret->ut_type, utret->ut_user,
		       (int) sizeof(utret->ut_line), utret->ut_line,
		       (int) sizeof(utret->ut_id), utret->ut_id));
#endif

	    /* set up the new entry */
	    utmp.ut_type = USER_PROCESS;
#ifdef HAVE_UTMP_UT_XSTATUS
	    utmp.ut_xstatus = 2;
#endif
	    copy_filled(utmp.ut_user,
			(login_name != NULL) ? login_name : "????",
			sizeof(utmp.ut_user));
	    /* why are we copying this string again?  (see above) */
	    copy_filled(utmp.ut_id, my_utmp_id(ttydev), sizeof(utmp.ut_id));
	    copy_filled(utmp.ut_line,
			my_pty_name(ttydev), sizeof(utmp.ut_line));

#ifdef HAVE_UTMP_UT_HOST
	    SetUtmpHost(utmp.ut_host, screen);
#endif
#ifdef HAVE_UTMP_UT_SYSLEN
	    SetUtmpSysLen(utmp);
#endif

	    copy_filled(utmp.ut_name,
			(login_name) ? login_name : "????",
			sizeof(utmp.ut_name));

	    utmp.ut_pid = getpid();
#if defined(HAVE_UTMP_UT_XTIME)
#if defined(HAVE_UTMP_UT_SESSION)
	    utmp.ut_session = getsid(0);
#endif
	    utmp.ut_xtime = time((time_t *) 0);
	    utmp.ut_tv.tv_usec = 0;
#else
	    utmp.ut_time = time((time_t *) 0);
#endif

	    /* write out the entry */
	    if (!resource.utmpInhibit) {
		errno = 0;
		call_pututline(&utmp);
		TRACE(("pututline: id %.*s, line %.*s, pid %ld, errno %d %s\n",
		       (int) sizeof(utmp.ut_id), utmp.ut_id,
		       (int) sizeof(utmp.ut_line), utmp.ut_line,
		       (long) utmp.ut_pid,
		       errno, (errno != 0) ? strerror(errno) : ""));
	    }
#ifdef WTMP
#if defined(WTMPX_FILE) && (defined(SVR4) || defined(__SCO__))
	    if (xw->misc.login_shell)
		updwtmpx(WTMPX_FILE, &utmp);
#elif defined(linux) && defined(__GLIBC__) && (__GLIBC__ >= 2) && !(defined(__powerpc__) && (__GLIBC__ == 2) && (__GLIBC_MINOR__ == 0))
	    if (xw->misc.login_shell)
		call_updwtmp(etc_wtmp, &utmp);
#else
	    if (xw->misc.login_shell &&
		(i = open(etc_wtmp, O_WRONLY | O_APPEND)) >= 0) {
		IGNORE_RC(write(i, (char *) &utmp, sizeof(utmp)));
		close(i);
	    }
#endif
#endif
	    /* close the file */
	    (void) call_endutent();

#else /* USE_SYSV_UTMP */
	    /* We can now get our ttyslot!  We can also set the initial
	     * utmp entry.
	     */
	    tslot = ttyslot();
	    added_utmp_entry = False;
	    {
		if (tslot > 0 && OkPasswd(&pw) && !resource.utmpInhibit &&
		    (i = open(etc_utmp, O_WRONLY)) >= 0) {
		    memset(&utmp, 0, sizeof(utmp));
		    copy_filled(utmp.ut_line,
				my_pty_name(ttydev),
				sizeof(utmp.ut_line));
		    copy_filled(utmp.ut_name, login_name,
				sizeof(utmp.ut_name));
#ifdef HAVE_UTMP_UT_HOST
		    SetUtmpHost(utmp.ut_host, screen);
#endif
#ifdef HAVE_UTMP_UT_SYSLEN
		    SetUtmpSysLen(utmp);
#endif

		    utmp.ut_time = time((time_t *) 0);
		    lseek(i, (long) (tslot * sizeof(utmp)), 0);
		    IGNORE_RC(write(i, (char *) &utmp, sizeof(utmp)));
		    close(i);
		    added_utmp_entry = True;
#if defined(WTMP)
		    if (xw->misc.login_shell &&
			(i = open(etc_wtmp, O_WRONLY | O_APPEND)) >= 0) {
			int status;
			status = write(i, (char *) &utmp, sizeof(utmp));
			status = close(i);
		    }
#elif defined(MNX_LASTLOG)
		    if (xw->misc.login_shell &&
			(i = open(_U_LASTLOG, O_WRONLY)) >= 0) {
			lseek(i, (long) (screen->uid *
					 sizeof(utmp)), 0);
			IGNORE_RC(write(i, (char *) &utmp, sizeof(utmp)));
			close(i);
		    }
#endif /* WTMP or MNX_LASTLOG */
		} else
		    tslot = -tslot;
	    }

	    /* Let's pass our ttyslot to our parent so that it can
	     * clean up after us.
	     */
#if OPT_PTY_HANDSHAKE
	    if (resource.ptyHandshake) {
		handshake.tty_slot = tslot;
	    }
#endif /* OPT_PTY_HANDSHAKE */
#endif /* USE_SYSV_UTMP */

#ifdef USE_LASTLOGX
	    if (xw->misc.login_shell) {
		memset(&lastlogx, 0, sizeof(lastlogx));
		(void) strncpy(lastlogx.ll_line,
			       my_pty_name(ttydev),
			       sizeof(lastlogx.ll_line));
		X_GETTIMEOFDAY(&lastlogx.ll_tv);
		SetUtmpHost(lastlogx.ll_host, screen);
		updlastlogx(_PATH_LASTLOGX, screen->uid, &lastlogx);
	    }
#endif

#ifdef USE_LASTLOG
	    if (xw->misc.login_shell &&
		(i = open(etc_lastlog, O_WRONLY)) >= 0) {
		size_t size = sizeof(struct lastlog);
		off_t offset = (off_t) (screen->uid * size);

		memset(&lastlog, 0, size);
		(void) strncpy(lastlog.ll_line,
			       my_pty_name(ttydev),
			       sizeof(lastlog.ll_line));
		SetUtmpHost(lastlog.ll_host, screen);
		lastlog.ll_time = time((time_t *) 0);
		if (lseek(i, offset, 0) != (off_t) (-1)) {
		    IGNORE_RC(write(i, (char *) &lastlog, size));
		}
		close(i);
	    }
#endif /* USE_LASTLOG */

#if defined(USE_UTMP_SETGID)
	    disableSetGid();
	    TRACE_IDS;
#endif

#if OPT_PTY_HANDSHAKE
	    /* Let our parent know that we set up our utmp entry
	     * so that it can clean up after us.
	     */
	    if (resource.ptyHandshake) {
		handshake.status = UTMP_ADDED;
		handshake.error = 0;
		strncpy(handshake.buffer, ttydev, sizeof(handshake.buffer));
		TRACE_HANDSHAKE("writing", &handshake);
		IGNORE_RC(write(cp_pipe[1], (char *) &handshake, sizeof(handshake)));
	    }
#endif /* OPT_PTY_HANDSHAKE */
#endif /* USE_UTEMPTER */
#endif /* HAVE_UTMP */

	    IGNORE_RC(setgid(screen->gid));
	    TRACE_IDS;
#ifdef HAVE_INITGROUPS
	    if (geteuid() == 0 && OkPasswd(&pw)) {
		if (initgroups(login_name, pw.pw_gid)) {
		    perror("initgroups failed");
		    SysError(ERROR_INIGROUPS);
		}
	    }
#endif
	    if (setuid(screen->uid)) {
		SysError(ERROR_SETUID);
	    }
	    TRACE_IDS;
#if OPT_PTY_HANDSHAKE
	    if (resource.ptyHandshake) {
		/* mark the pipes as close on exec */
		(void) fcntl(cp_pipe[1], F_SETFD, 1);
		(void) fcntl(pc_pipe[0], F_SETFD, 1);

		/* We are at the point where we are going to
		 * exec our shell (or whatever).  Let our parent
		 * know we arrived safely.
		 */
		handshake.status = PTY_GOOD;
		handshake.error = 0;
		(void) strncpy(handshake.buffer, ttydev, sizeof(handshake.buffer));
		TRACE_HANDSHAKE("writing", &handshake);
		IGNORE_RC(write(cp_pipe[1],
				(const char *) &handshake,
				sizeof(handshake)));

		if (resource.wait_for_map) {
		    i = (int) read(pc_pipe[0], (char *) &handshake,
				   sizeof(handshake));
		    if (i != sizeof(handshake) ||
			handshake.status != PTY_EXEC) {
			/* some very bad problem occurred */
			exit(ERROR_PTY_EXEC);
		    }
		    if (handshake.rows > 0 && handshake.cols > 0) {
			TRACE(("handshake ttysize: %dx%d\n",
			       handshake.rows, handshake.cols));
			set_max_row(screen, handshake.rows);
			set_max_col(screen, handshake.cols);
#ifdef TTYSIZE_STRUCT
			got_handshake_size = True;
			TTYSIZE_ROWS(ts) = (ttySize_t) MaxRows(screen);
			TTYSIZE_COLS(ts) = (ttySize_t) MaxCols(screen);
#if defined(USE_STRUCT_WINSIZE)
			ts.ws_xpixel = (ttySize_t) FullWidth(screen);
			ts.ws_ypixel = (ttySize_t) FullHeight(screen);
#endif
#endif /* TTYSIZE_STRUCT */
		    }
		}
	    }
#endif /* OPT_PTY_HANDSHAKE */

#ifdef USE_SYSV_ENVVARS
	    {
		char numbuf[12];
		sprintf(numbuf, "%d", MaxCols(screen));
		xtermSetenv("COLUMNS", numbuf);
		sprintf(numbuf, "%d", MaxRows(screen));
		xtermSetenv("LINES", numbuf);
	    }
#ifdef HAVE_UTMP
	    if (OkPasswd(&pw)) {	/* SVR4 doesn't provide these */
		if (!x_getenv("HOME"))
		    xtermSetenv("HOME", pw.pw_dir);
		if (!x_getenv("SHELL"))
		    xtermSetenv("SHELL", pw.pw_shell);
	    }
#endif /* HAVE_UTMP */
#ifdef OWN_TERMINFO_DIR
	    xtermSetenv("TERMINFO", OWN_TERMINFO_DIR);
#endif
#else /* USE_SYSV_ENVVARS */
	    if (*(newtc = get_tcap_buffer(xw)) != '\0') {
		resize_termcap(xw);
		if (xw->misc.titeInhibit && !xw->misc.tiXtraScroll) {
		    remove_termcap_entry(newtc, "ti=");
		    remove_termcap_entry(newtc, "te=");
		}
		/*
		 * work around broken termcap entries */
		if (resource.useInsertMode) {
		    remove_termcap_entry(newtc, "ic=");
		    /* don't get duplicates */
		    remove_termcap_entry(newtc, "im=");
		    remove_termcap_entry(newtc, "ei=");
		    remove_termcap_entry(newtc, "mi");
		    if (*newtc)
			strcat(newtc, ":im=\\E[4h:ei=\\E[4l:mi:");
		}
		if (*newtc) {
#if OPT_INITIAL_ERASE
		    unsigned len;
		    remove_termcap_entry(newtc, TERMCAP_ERASE "=");
		    len = (unsigned) strlen(newtc);
		    if (len != 0 && newtc[len - 1] == ':')
			len--;
		    sprintf(newtc + len, ":%s=\\%03o:",
			    TERMCAP_ERASE,
			    CharOf(initial_erase));
#endif
		    xtermSetenv("TERMCAP", newtc);
		}
	    }
#endif /* USE_SYSV_ENVVARS */

#if OPT_PTY_HANDSHAKE
	    /*
	     * Need to reset after all the ioctl bashing we did above.
	     *
	     * If we expect the waitForMap logic to set the handshake-size,
	     * use that to prevent races.
	     */
	    if (resource.ptyHandshake
		&& resource.ptySttySize
		&& (got_handshake_size || !resource.wait_for_map0)) {
#ifdef TTYSIZE_STRUCT
		TRACE_RC(i, SET_TTYSIZE(0, ts));
		TRACE(("ptyHandshake SET_TTYSIZE %dx%d return %d\n",
		       TTYSIZE_ROWS(ts),
		       TTYSIZE_COLS(ts), i));
#endif /* TTYSIZE_STRUCT */
	    }
#endif /* OPT_PTY_HANDSHAKE */
	    signal(SIGHUP, SIG_DFL);

	    /*
	     * If we have an explicit shell to run, make that set $SHELL.
	     * Next, allow an existing setting of $SHELL, for absolute paths.
	     * Otherwise, if $SHELL is not set, determine it from the user's
	     * password information, if possible.
	     *
	     * Incidentally, our setting of $SHELL tells luit to use that
	     * program rather than choosing between $SHELL and "/bin/sh".
	     */
	    if (validShell(explicit_shname)) {
		xtermSetenv("SHELL", explicit_shname);
	    } else if (validProgram(shell_path = x_getenv("SHELL"))) {
		if (!validShell(shell_path)) {
		    xtermUnsetenv("SHELL");
		}
	    } else if ((!OkPasswd(&pw) && !x_getpwuid(screen->uid, &pw))
		       || *(shell_path = x_strdup(pw.pw_shell)) == 0) {
		shell_path = resetShell(shell_path);
	    } else if (validShell(shell_path)) {
		xtermSetenv("SHELL", shell_path);
	    } else {
		shell_path = resetShell(shell_path);
	    }

	    /*
	     * Set $XTERM_SHELL, which is not necessarily a valid shell, but
	     * is executable.
	     */
	    if (validProgram(explicit_shname)) {
		shell_path = explicit_shname;
	    } else if (shell_path == 0) {
		/* this could happen if the explicit shname lost a race */
		shell_path = resetShell(shell_path);
	    }
	    xtermSetenv("XTERM_SHELL", shell_path);

	    shname = x_basename(shell_path);
	    TRACE(("shell path '%s' leaf '%s'\n", shell_path, shname));

#if OPT_LUIT_PROG
	    /*
	     * Use two copies of command_to_exec, in case luit is not actually
	     * there, or refuses to run.  In that case we will fall-through to
	     * to command that the user gave anyway.
	     */
	    if (command_to_exec_with_luit && command_to_exec) {
		char *myShell = xtermFindShell(*command_to_exec_with_luit, False);
		xtermSetenv("XTERM_SHELL", myShell);
		free(myShell);
		TRACE_ARGV("spawning luit command", command_to_exec_with_luit);
		execvp(*command_to_exec_with_luit, command_to_exec_with_luit);
		xtermPerror("Can't execvp %s", *command_to_exec_with_luit);
		xtermWarning("cannot support your locale.\n");
	    }
#endif
	    if (command_to_exec) {
		char *myShell = xtermFindShell(*command_to_exec, False);
		xtermSetenv("XTERM_SHELL", myShell);
		free(myShell);
		TRACE_ARGV("spawning command", command_to_exec);
		execvp(*command_to_exec, command_to_exec);
		if (command_to_exec[1] == 0)
		    execlp(shell_path, shname, "-c", command_to_exec[0],
			   (void *) 0);
		xtermPerror("Can't execvp %s", *command_to_exec);
	    }
#ifdef USE_SYSV_SIGHUP
	    /* fix pts sh hanging around */
	    signal(SIGHUP, SIG_DFL);
#endif

	    if ((shname_minus = CastMallocN(char, strlen(shname) + 2)) != 0) {
		(void) strcpy(shname_minus, "-");
		(void) strcat(shname_minus, shname);
	    } else {
		static char default_minus[] = "-sh";
		shname_minus = default_minus;
	    }
#ifndef TERMIO_STRUCT
	    ldisc = (!XStrCmp("csh", shname + strlen(shname) - 3)
		     ? NTTYDISC
		     : 0);
	    ioctl(0, TIOCSETD, (char *) &ldisc);
#endif /* !TERMIO_STRUCT */

#ifdef USE_LOGIN_DASH_P
	    if (xw->misc.login_shell && OkPasswd(&pw) && added_utmp_entry)
		execl(bin_login, "login", "-p", "-f", login_name, (void *) 0);
#endif

#if OPT_LUIT_PROG
	    if (command_to_exec_with_luit) {
		if (xw->misc.login_shell) {
		    char *params[4];
		    params[0] = x_strdup("-argv0");
		    params[1] = shname_minus;
		    params[2] = NULL;
		    x_appendargv(command_to_exec_with_luit
				 + command_length_with_luit,
				 params);
		}
		TRACE_ARGV("final luit command", command_to_exec_with_luit);
		execvp(*command_to_exec_with_luit, command_to_exec_with_luit);
		/* Exec failed. */
		xtermPerror("Can't execvp %s", *command_to_exec_with_luit);
	    }
#endif
	    execlp(shell_path,
		   (xw->misc.login_shell ? shname_minus : shname),
		   (void *) 0);

	    /* Exec failed. */
	    xtermPerror("Could not exec %s", shell_path);
	    IGNORE_RC(sleep(5));
	    free(shell_path);
	    exit(ERROR_EXEC);
	}
	/* end if in child after fork */
#if OPT_PTY_HANDSHAKE
	if (resource.ptyHandshake) {
	    /* Parent process.  Let's handle handshaked requests to our
	     * child process.
	     */

	    /* close childs's sides of the pipes */
	    close(cp_pipe[1]);
	    close(pc_pipe[0]);

	    for (done = 0; !done;) {
		if (read(cp_pipe[0],
			 (char *) &handshake,
			 sizeof(handshake)) <= 0) {
		    /* Our child is done talking to us.  If it terminated
		     * due to an error, we will catch the death of child
		     * and clean up.
		     */
		    break;
		}

		TRACE_HANDSHAKE("read", &handshake);
		switch (handshake.status) {
		case PTY_GOOD:
		    /* Success!  Let's free up resources and
		     * continue.
		     */
		    done = 1;
		    break;

		case PTY_BAD:
		    /* The open of the pty failed!  Let's get
		     * another one.
		     */
		    IGNORE_RC(close(screen->respond));
		    if (get_pty(&screen->respond, XDisplayString(screen->display))) {
			/* no more ptys! */
			xtermPerror("child process can find no available ptys");
			handshake.status = PTY_NOMORE;
			TRACE_HANDSHAKE("writing", &handshake);
			IGNORE_RC(write(pc_pipe[1],
					(const char *) &handshake,
					sizeof(handshake)));
			exit(ERROR_PTYS);
		    }
		    handshake.status = PTY_NEW;
		    (void) strncpy(handshake.buffer, ttydev, sizeof(handshake.buffer));
		    TRACE_HANDSHAKE("writing", &handshake);
		    IGNORE_RC(write(pc_pipe[1],
				    (const char *) &handshake,
				    sizeof(handshake)));
		    break;

		case PTY_FATALERROR:
		    errno = handshake.error;
		    close(cp_pipe[0]);
		    close(pc_pipe[1]);
		    SysError(handshake.fatal_error);
		    /*NOTREACHED */

		case UTMP_ADDED:
		    /* The utmp entry was set by our slave.  Remember
		     * this so that we can reset it later.
		     */
		    added_utmp_entry = True;
#ifndef	USE_SYSV_UTMP
		    tslot = handshake.tty_slot;
#endif /* USE_SYSV_UTMP */
		    free(ttydev);
		    ttydev = x_strdup(handshake.buffer);
		    break;
		case PTY_NEW:
		case PTY_NOMORE:
		case UTMP_TTYSLOT:
		case PTY_EXEC:
		default:
		    xtermWarning("unexpected handshake status %d\n",
				 (int) handshake.status);
		}
	    }
	    /* close our sides of the pipes */
	    if (!resource.wait_for_map) {
		close(cp_pipe[0]);
		close(pc_pipe[1]);
	    }
	}
#endif /* OPT_PTY_HANDSHAKE */
    }

    /* end if no slave */
    /*
     * still in parent (xterm process)
     */
#ifdef USE_SYSV_SIGHUP
    /* hung sh problem? */
    signal(SIGHUP, SIG_DFL);
#else
    signal(SIGHUP, SIG_IGN);
#endif

/*
 * Unfortunately, System V seems to have trouble divorcing the child process
 * from the process group of xterm.  This is a problem because hitting the
 * INTR or QUIT characters on the keyboard will cause xterm to go away if we
 * don't ignore the signals.  This is annoying.
 */

#if defined(USE_SYSV_SIGNALS) && !defined(SIGTSTP)
    signal(SIGINT, SIG_IGN);

#ifndef SYSV
    /* hung shell problem */
    signal(SIGQUIT, SIG_IGN);
#endif
    signal(SIGTERM, SIG_IGN);
#elif defined(SYSV) || defined(__osf__)
    /* if we were spawned by a jobcontrol smart shell (like ksh or csh),
     * then our pgrp and pid will be the same.  If we were spawned by
     * a jobcontrol dumb shell (like /bin/sh), then we will be in our
     * parent's pgrp, and we must ignore keyboard signals, or we will
     * tank on everything.
     */
    if (getpid() == getpgrp()) {
	(void) signal(SIGINT, Exit);
	(void) signal(SIGQUIT, Exit);
	(void) signal(SIGTERM, Exit);
    } else {
	(void) signal(SIGINT, SIG_IGN);
	(void) signal(SIGQUIT, SIG_IGN);
	(void) signal(SIGTERM, SIG_IGN);
    }
    (void) signal(SIGPIPE, Exit);
#else /* SYSV */
    signal(SIGINT, Exit);
    signal(SIGQUIT, Exit);
    signal(SIGTERM, Exit);
    signal(SIGPIPE, Exit);
#endif /* USE_SYSV_SIGNALS and not SIGTSTP */
#ifdef NO_LEAKS
    if (ok_termcap != True)
	free(TermName);
#endif

    return 0;
}				/* end spawnXTerm */

void
Exit(int n)
{
    XtermWidget xw = term;
    TScreen *screen = TScreenOf(xw);

#ifdef USE_UTEMPTER
    DEBUG_MSG("handle:Exit USE_UTEMPTER\n");
    if (!resource.utmpInhibit && added_utmp_entry) {
	TRACE(("...calling removeFromUtmp\n"));
	removeFromUtmp();
    }
#elif defined(HAVE_UTMP)
#ifdef USE_SYSV_UTMP
    struct UTMP_STR utmp;
    struct UTMP_STR *utptr;

    DEBUG_MSG("handle:Exit USE_SYSV_UTMP\n");
    /* don't do this more than once */
    if (xterm_exiting) {
	exit(n);
    }
    xterm_exiting = True;

#ifdef PUCC_PTYD
    closepty(ttydev, ptydev, (resource.utmpInhibit ? OPTY_NOP : OPTY_LOGIN), screen->respond);
#endif /* PUCC_PTYD */

    /* cleanup the utmp entry we forged earlier */
    if (!resource.utmpInhibit
#if OPT_PTY_HANDSHAKE		/* without handshake, no way to know */
	&& (resource.ptyHandshake && added_utmp_entry)
#endif /* OPT_PTY_HANDSHAKE */
	) {
#if defined(USE_UTMP_SETGID)
	setEffectiveGroup(save_egid);
	TRACE_IDS;
#endif
	init_utmp(USER_PROCESS, &utmp);
	(void) call_setutent();

	/*
	 * We could use getutline() if we didn't support old systems.
	 */
	while ((utptr = find_utmp(&utmp)) != 0) {
	    if (utptr->ut_pid == screen->pid) {
		utptr->ut_type = DEAD_PROCESS;
#if defined(HAVE_UTMP_UT_XTIME)
#if defined(HAVE_UTMP_UT_SESSION)
		utptr->ut_session = getsid(0);
#endif
		utptr->ut_xtime = time((time_t *) 0);
		utptr->ut_tv.tv_usec = 0;
#else
		*utptr->ut_user = 0;
		utptr->ut_time = time((time_t *) 0);
#endif
		(void) call_pututline(utptr);
#ifdef WTMP
#if defined(WTMPX_FILE) && (defined(SVR4) || defined(__SCO__))
		if (xw->misc.login_shell)
		    updwtmpx(WTMPX_FILE, utptr);
#elif defined(linux) && defined(__GLIBC__) && (__GLIBC__ >= 2) && !(defined(__powerpc__) && (__GLIBC__ == 2) && (__GLIBC_MINOR__ == 0))
		copy_filled(utmp.ut_line, utptr->ut_line, sizeof(utmp.ut_line));
		if (xw->misc.login_shell)
		    call_updwtmp(etc_wtmp, utptr);
#else
		/* set wtmp entry if wtmp file exists */
		if (xw->misc.login_shell) {
		    int fd;
		    if ((fd = open(etc_wtmp, O_WRONLY | O_APPEND)) >= 0) {
			IGNORE_RC(write(fd, utptr, sizeof(*utptr)));
			close(fd);
		    }
		}
#endif
#endif
		break;
	    }
	    memset(utptr, 0, sizeof(*utptr));	/* keep searching */
	}
	(void) call_endutent();
#ifdef USE_UTMP_SETGID
	disableSetGid();
	TRACE_IDS;
#endif
    }
#else /* not USE_SYSV_UTMP */
    int wfd;
    struct utmp utmp;

    DEBUG_MSG("handle:Exit !USE_SYSV_UTMP\n");
    if (!resource.utmpInhibit && added_utmp_entry &&
	(am_slave < 0 && tslot > 0)) {
#if defined(USE_UTMP_SETGID)
	setEffectiveGroup(save_egid);
	TRACE_IDS;
#endif
	if ((wfd = open(etc_utmp, O_WRONLY)) >= 0) {
	    memset(&utmp, 0, sizeof(utmp));
	    lseek(wfd, (long) (tslot * sizeof(utmp)), 0);
	    IGNORE_RC(write(wfd, (char *) &utmp, sizeof(utmp)));
	    close(wfd);
	}
#ifdef WTMP
	if (xw->misc.login_shell &&
	    (wfd = open(etc_wtmp, O_WRONLY | O_APPEND)) >= 0) {
	    copy_filled(utmp.ut_line,
			my_pty_name(ttydev),
			sizeof(utmp.ut_line));
	    utmp.ut_time = time((time_t *) 0);
	    IGNORE_RC(write(wfd, (char *) &utmp, sizeof(utmp)));
	    close(wfd);
	}
#endif /* WTMP */
#ifdef USE_UTMP_SETGID
	disableSetGid();
	TRACE_IDS;
#endif
    }
#endif /* USE_SYSV_UTMP */
#endif /* HAVE_UTMP */

    cleanup_colored_cursor();

    /*
     * Flush pending data before releasing ownership, so nobody else can write
     * in the middle of the data.
     */
    ttyFlush(screen->respond);

#ifdef USE_PTY_SEARCH
    if (am_slave < 0) {
	TRACE_IDS;
	/* restore ownership of tty and pty */
	set_owner(ttydev, 0, 0, 0666U);
#if (defined(USE_PTY_DEVICE) && !defined(__sgi) && !defined(__hpux))
	set_owner(ptydev, 0, 0, 0666U);
#endif
    }
#endif

    /*
     * Close after releasing ownership to avoid race condition: other programs
     * grabbing it, and *then* having us release ownership....
     */
    close(screen->respond);	/* close explicitly to avoid race with slave side */
#ifdef ALLOWLOGGING
    if (screen->logging)
	CloseLog(xw);
#endif

    xtermPrintOnXError(xw, n);

#ifdef NO_LEAKS
    if (n == 0) {
	Display *dpy = TScreenOf(xw)->display;

	TRACE(("Freeing memory leaks\n"));

	if (toplevel) {
	    XtDestroyWidget(toplevel);
	    TRACE(("destroyed top-level widget\n"));
	}
	sortedOpts(0, 0, 0);
	noleaks_charproc();
	noleaks_ptydata();
#if OPT_GRAPHICS
	noleaks_graphics();
#endif
#if OPT_WIDE_CHARS
	noleaks_CharacterClass();
#endif
	/* XrmSetDatabase(dpy, 0); increases leaks ;-) */
	XtCloseDisplay(dpy);
	XtDestroyApplicationContext(app_con);
	xtermCloseSession();
	TRACE(("closed display\n"));

	TRACE_CLOSE();
    }
#endif

    exit(n);
}

/* ARGSUSED */
static void
resize_termcap(XtermWidget xw)
{
    char *newtc = get_tcap_buffer(xw);

#ifndef USE_SYSV_ENVVARS
    if (!TEK4014_ACTIVE(xw) && *newtc) {
	TScreen *screen = TScreenOf(xw);
	char *ptr1, *ptr2;
	size_t i;
	int li_first = 0;
	char *temp;
	char oldtc[TERMCAP_SIZE];

	strcpy(oldtc, newtc);
	TRACE(("resize %s\n", oldtc));
	if ((ptr1 = x_strindex(oldtc, "co#")) == NULL) {
	    strcat(oldtc, "co#80:");
	    ptr1 = x_strindex(oldtc, "co#");
	}
	if ((ptr2 = x_strindex(oldtc, "li#")) == NULL) {
	    strcat(oldtc, "li#24:");
	    ptr2 = x_strindex(oldtc, "li#");
	}
	if (ptr1 > ptr2) {
	    li_first++;
	    temp = ptr1;
	    ptr1 = ptr2;
	    ptr2 = temp;
	}
	ptr1 += 3;
	ptr2 += 3;
	strncpy(newtc, oldtc, i = (size_t) (ptr1 - oldtc));
	temp = newtc + i;
	sprintf(temp, "%d", (li_first
			     ? MaxRows(screen)
			     : MaxCols(screen)));
	temp += strlen(temp);
	if ((ptr1 = strchr(ptr1, ':')) != 0 && (ptr1 < ptr2)) {
	    strncpy(temp, ptr1, i = (size_t) (ptr2 - ptr1));
	    temp += i;
	    sprintf(temp, "%d", (li_first
				 ? MaxCols(screen)
				 : MaxRows(screen)));
	    if ((ptr2 = strchr(ptr2, ':')) != 0) {
		strcat(temp, ptr2);
	    }
	}
	TRACE(("   ==> %s\n", newtc));
	TRACE(("   new size %dx%d\n", MaxRows(screen), MaxCols(screen)));
    }
#endif /* USE_SYSV_ENVVARS */
}

#endif /* ! VMS */

/*
 * Does a non-blocking wait for a child process.  If the system
 * doesn't support non-blocking wait, do nothing.
 * Returns the pid of the child, or 0 or -1 if none or error.
 */
int
nonblocking_wait(void)
{
#ifdef USE_POSIX_WAIT
    pid_t pid;

    pid = waitpid(-1, NULL, WNOHANG);
#elif defined(USE_SYSV_SIGNALS) && (defined(CRAY) || !defined(SIGTSTP))
    /* cannot do non-blocking wait */
    int pid = 0;
#else /* defined(USE_SYSV_SIGNALS) && (defined(CRAY) || !defined(SIGTSTP)) */
#if defined(Lynx)
    int status;
#else
    union wait status;
#endif
    int pid;

    pid = wait3(&status, WNOHANG, (struct rusage *) NULL);
#endif /* USE_POSIX_WAIT else */
    return pid;
}

#ifndef VMS

/* ARGSUSED */
static void
reapchild(int n GCC_UNUSED)
{
    int olderrno = errno;
    int pid;

    DEBUG_MSG("handle:reapchild\n");

    pid = wait(NULL);

#ifdef USE_SYSV_SIGNALS
    /* cannot re-enable signal before waiting for child
     * because then SVR4 loops.  Sigh.  HP-UX 9.01 too.
     */
    (void) signal(SIGCHLD, reapchild);
#endif

    do {
	if (pid == TScreenOf(term)->pid) {
	    DEBUG_MSG("Exiting\n");
	    if (hold_screen)
		caught_intr = True;
	    else
		need_cleanup = True;
	}
    } while ((pid = nonblocking_wait()) > 0);

    errno = olderrno;
}
#endif /* !VMS */

static void
remove_termcap_entry(char *buf, const char *str)
{
    char *base = buf;
    char *first = base;
    int count = 0;
    size_t len = strlen(str);

    TRACE(("*** remove_termcap_entry('%s', '%s')\n", str, buf));

    while (*buf != 0) {
	if (!count && !strncmp(buf, str, len)) {
	    while (*buf != 0) {
		if (*buf == '\\')
		    buf++;
		else if (*buf == ':')
		    break;
		if (*buf != 0)
		    buf++;
	    }
	    while ((*first++ = *buf++) != 0) {
		;
	    }
	    TRACE(("...removed_termcap_entry('%s', '%s')\n", str, base));
	    return;
	} else if (*buf == '\\') {
	    buf++;
	} else if (*buf == ':') {
	    first = buf;
	    count = 0;
	} else if (!isspace(CharOf(*buf))) {
	    count++;
	}
	if (*buf != 0)
	    buf++;
    }
    TRACE(("...cannot remove\n"));
}

/*
 * parse_tty_modes accepts lines of the following form:
 *
 *         [SETTING] ...
 *
 * where setting consists of the words in the modelist followed by a character
 * or ^char.
 */
static int
parse_tty_modes(char *s, struct _xttymodes *modelist)
{
    struct _xttymodes *mp;
    int c;
    int count = 0;

    TRACE(("parse_tty_modes\n"));
    for (;;) {
	size_t len;

	while (*s && isascii(CharOf(*s)) && isspace(CharOf(*s)))
	    s++;
	if (!*s)
	    return count;

	for (len = 0; isalnum(CharOf(s[len])); ++len) ;
	for (mp = modelist; mp->name; mp++) {
	    if (len == mp->len
		&& strncmp(s, mp->name, mp->len) == 0)
		break;
	}
	if (!mp->name)
	    return -1;

	s += mp->len;
	while (*s && isascii(CharOf(*s)) && isspace(CharOf(*s)))
	    s++;
	if (!*s)
	    return -1;

	if ((c = decode_keyvalue(&s, False)) != -1) {
	    mp->value = c;
	    mp->set = 1;
	    count++;
	    TRACE(("...parsed #%d: %s=%#x\n", count, mp->name, c));
	}
    }
}

#ifndef VMS			/* don't use pipes on OpenVMS */
int
GetBytesAvailable(int fd)
{
#if defined(FIONREAD)
    int arg;
    ioctl(fd, FIONREAD, (char *) &arg);
    return (int) arg;
#elif defined(__CYGWIN__)
    fd_set set;
    struct timeval select_timeout =
    {0, 0};

    FD_ZERO(&set);
    FD_SET(fd, &set);
    if (Select(fd + 1, &set, NULL, NULL, &select_timeout) > 0)
	return 1;
    else
	return 0;
#elif defined(FIORDCK)
    return (ioctl(fd, FIORDCHK, NULL));
#else /* !FIORDCK */
    struct pollfd pollfds[1];

    pollfds[0].fd = fd;
    pollfds[0].events = POLLIN;
    return poll(pollfds, 1, 0);
#endif
}
#endif /* !VMS */

/* Utility function to try to hide system differences from
   everybody who used to call killpg() */

int
kill_process_group(int pid, int sig)
{
    TRACE(("kill_process_group(pid=%d, sig=%d)\n", pid, sig));
#if defined(SVR4) || defined(SYSV) || !defined(X_NOT_POSIX)
    return kill(-pid, sig);
#else
    return killpg(pid, sig);
#endif
}

#if OPT_EBCDIC
int
A2E(int x)
{
    char c;
    c = x;
    __atoe_l(&c, 1);
    return c;
}

int
E2A(int x)
{
    char c;
    c = x;
    __etoa_l(&c, 1);
    return c;
}
#endif

#if defined(__QNX__) && !defined(__QNXNTO__)
#include <sys/types.h>
#include <sys/proc_msg.h>
#include <sys/kernel.h>
#include <string.h>
#include <errno.h>

struct _proc_session ps;
struct _proc_session_reply rps;

int
qsetlogin(char *login, char *ttyname)
{
    int v = getsid(getpid());

    memset(&ps, 0, sizeof(ps));
    memset(&rps, 0, sizeof(rps));

    ps.type = _PROC_SESSION;
    ps.subtype = _PROC_SUB_ACTION1;
    ps.sid = v;
    strcpy(ps.name, login);

    Send(1, &ps, &rps, sizeof(ps), sizeof(rps));

    if (rps.status < 0)
	return (rps.status);

    ps.type = _PROC_SESSION;
    ps.subtype = _PROC_SUB_ACTION2;
    ps.sid = v;
    sprintf(ps.name, "//%d%s", getnid(), ttyname);
    Send(1, &ps, &rps, sizeof(ps), sizeof(rps));

    return (rps.status);
}
#endif

#ifdef __minix
int
setpgrp(void)
{
    return 0;
}

void
_longjmp(jmp_buf _env, int _val)
{
    longjmp(_env, _val);
}
#endif
@


1.40
log
@With the disabling of Tektronics emulation, the pledge(2) promises could
be reduced a bit: no more "cpath" should be required.
from Sebastien Marie. Thanks.
Reviewed by schwarze@@, "put it in" deraadt@@
@
text
@d1 1
a1 1
/* $XTermId: main.c,v 1.781 2016/06/01 09:13:46 tom Exp $ */
d448 2
a449 1
static int spawnXTerm(XtermWidget /* xw */ );
d1119 1
d1164 1
d1363 1
d1365 2
a1366 2
	int temp = (int) strtol(string + 1, &d, 8);
	if (temp > 0 && d != string) {
d1978 118
d2114 1
d2196 5
d2210 4
d2261 1
a2261 1
    d_tio.c_cflag = VAL_LINE_SPEED | CS8 | CREAD | PARENB | HUPCL;
d2288 1
a2288 1
    d_tio.c_cflag = VAL_LINE_SPEED | CS8 | CREAD | PARENB | HUPCL;
d2292 2
a2293 2
    cfsetispeed(&d_tio, VAL_LINE_SPEED);
    cfsetospeed(&d_tio, VAL_LINE_SPEED);
d2484 5
d2646 1
a2646 1
    spawnXTerm(term);
d3463 1
a3463 1
spawnXTerm(XtermWidget xw)
d4168 1
a4168 1
		tio.c_ispeed = tio.c_ospeed = VAL_LINE_SPEED;
d4170 1
a4170 1
		tio.c_cflag |= VAL_LINE_SPEED;
d4173 2
a4174 2
		cfsetispeed(&tio, VAL_LINE_SPEED);
		cfsetospeed(&tio, VAL_LINE_SPEED);
d4255 2
a4256 2
		sg.sg_ispeed = VAL_LINE_SPEED;
		sg.sg_ospeed = VAL_LINE_SPEED;
@


1.39
log
@Update to xterm-325. Testing by krw@@, shadchin@@ and naddy@@. Thanks
@
text
@d2637 1
a2637 1
            if (pledge("stdio rpath wpath cpath id proc exec tty", NULL) == -1) {
d2642 1
a2642 1
            if (pledge("stdio rpath wpath cpath id proc tty", NULL) == -1) {
@


1.38
log
@Update to xterm 322. Tested by shadchin@@ and jsg@@. Thanks.
@
text
@d1 1
a1 1
/* $XTermId: main.c,v 1.777 2016/01/02 14:12:19 tom Exp $ */
d143 1
a143 1
#if defined(__SCO__) || defined(SVR4) || defined(_POSIX_SOURCE)
d328 7
d3785 1
a3785 1
	    else if (ioctl(ptyfd, I_PUSH, "ptem") < 0) {
d3790 1
a3790 1
		     && ioctl(ptyfd, I_PUSH, "consem") < 0) {
d3794 1
a3794 1
	    else if (ioctl(ptyfd, I_PUSH, "ldterm") < 0) {
d3798 1
a3798 1
	    else if (ioctl(ptyfd, I_PUSH, "ttcompat") < 0) {
d4044 1
a4044 1
		tio.c_cflag &= ~CLOCAL;
d5242 3
a5244 1
	    if (!hold_screen)
@


1.37
log
@add pledge promise "exec" for few cases in xterm
in particular if the user use `exec-formatted' or `exec-selectable' actions in key binding.

problem reported by jirib at devio dot us.
@
text
@d1 1
a1 1
/* $XTermId: main.c,v 1.773 2015/08/26 23:39:36 tom Exp $ */
d4 1
a4 1
 * Copyright 2002-2014,2015 by Thomas E. Dickey
d1950 17
d2468 2
d2474 3
d2672 4
a2830 6
#ifdef USE_OPENPTY
	if (opened_tty >= 0) {
	    close(opened_tty);
	    opened_tty = -1;
	}
#endif
d2842 6
d3270 2
a3271 1
	&& (sb.st_size != 0)
@


1.36
log
@avoid using err(), use xtermWarning() instead; ok semarie
@
text
@d2602 16
a2617 3
    if (pledge("stdio rpath wpath cpath id proc tty", NULL) == -1) {
	xtermWarning("pledge\n");
	exit(1);
@


1.35
log
@add pledge to xterm

the pledge call is done just before the main loop, so initialisation
is almost done.

- stdio: for all communication on opened fds (read/write/select/recvmsg/...)
- rpath: for X11 error ("X Error of failed request: ...") which read
  at least /usr/X11R6/share/X11/XErrorDB
- wpath : on exit, for opening WR_ONLY "/var/run/utmp"
- cpath : for Tek emulation window (xterm -t)
- id : on exit, for calling setegid()
- proc: on exit, for calling kill()
- tty: on exit, for calling tcflush()

"it is time" deraadt@@
@
text
@d2601 6
a2606 2
    if (pledge("stdio rpath wpath cpath id proc tty", NULL) == -1)
	    err(1, "pledge");
@


1.34
log
@Update to xterm 320. Tested by jsg@@ Thanks.
@
text
@d2601 2
@


1.33
log
@xterm 314. tested by naddy@@
@
text
@d1 1
a1 1
/* $XTermId: main.c,v 1.767 2014/12/29 00:17:32 tom Exp $ */
d4 1
a4 1
 * Copyright 2002-2013,2014 by Thomas E. Dickey
d1299 1
a1299 1
static const char *message[] =
d1618 1
a1618 1
    const char **cpp;
d1955 1
a1955 1
    static FlagList tblFullscreen[] =
a2203 2
	init_colored_cursor();

d2882 1
a2882 1
static const char *tekterm[] =
d2901 1
a2901 1
static const char *vtterm[] =
d3321 1
a3321 1
    const char **envnew;	/* new environment */
d3394 1
d3682 1
a3682 1
    if (!resource.utmpInhibit) {
@


1.32
log
@Update to xterm 311. ok shadchin@@
@
text
@d1 1
a1 1
/* $XTermId: main.c,v 1.762 2014/07/24 22:47:09 tom Exp $ */
d782 2
a783 1
static char passedPty[PTYCHARLEN + 1];	/* name if pty if slave */
d964 4
d1260 3
d1771 1
a1782 1
	    strncpy(passedPty, option, len);
d1789 1
d4703 7
a4709 3
	    shname_minus = CastMallocN(char, strlen(shname) + 2);
	    (void) strcpy(shname_minus, "-");
	    (void) strcat(shname_minus, shname);
@


1.31
log
@Update to xterm-309. Version 308 tested by several people including
naddy@@ who found a small regression, fixed in 309.
@
text
@d1 1
a1 1
/* $XTermId: main.c,v 1.760 2014/07/12 22:50:07 Steve.Wall Exp $ */
d2512 1
a2512 1
#if defined(USE_ANY_SYSV_TERMIO) || defined(__MVS__)
d5373 14
@


1.30
log
@Update to xterm 304. With help of shadchin@@

tested by ajacoutot@@ and shadchin@@
@
text
@d1 1
a1 1
/* $XTermId: main.c,v 1.757 2014/05/03 17:17:00 tom Exp $ */
d105 2
d1221 1
d2555 1
d2557 1
@


1.29
log
@Update to xterm 301
@
text
@d1 1
a1 1
/* $XTermId: main.c,v 1.741 2014/01/16 02:12:25 tom Exp $ */
d94 1
d808 1
a808 1
	    strncpy(dst, host, sizeof(dst)); \
d875 3
d1015 3
d1207 3
d1627 3
a1629 3
			Atom * selection GCC_UNUSED,
			Atom * target GCC_UNUSED,
			Atom * type GCC_UNUSED,
d1645 1
a1645 1
	     XEvent * event GCC_UNUSED,
d1665 1
a1665 1
		XEvent * event,
d3095 18
d3123 2
a3124 2
    (void) strncpy(tofind->ut_id, my_utmp_id(ttydev), sizeof(tofind->ut_id));
    (void) strncpy(tofind->ut_line, my_pty_name(ttydev), sizeof(tofind->ut_line));
d3140 1
a3140 1
	strncpy(working.ut_id, tofind->ut_id, sizeof(tofind->ut_id));
d3146 1
a3146 7
	/*
	 * ut_line may not be null-terminated, but if it is, there may be
	 * garbage after the null.  Use strncpy to ensure that the value
	 * we check is null-terminated (if there is enough space in the
	 * buffer), and that unused space is nulled.
	 */
	strncpy(limited.ut_line, result->ut_line, sizeof(result->ut_line));
d3168 29
d3210 1
a3210 2
    if (!IsEmpty(pathname)
	&& access(pathname, X_OK) == 0
d3220 1
d3223 1
d3226 3
d3796 2
a3797 1
		close(screen->respond);
d4320 3
a4322 3
	    (void) strncpy(utmp.ut_user,
			   (login_name != NULL) ? login_name : "????",
			   sizeof(utmp.ut_user));
d4324 3
a4326 3
	    (void) strncpy(utmp.ut_id, my_utmp_id(ttydev), sizeof(utmp.ut_id));
	    (void) strncpy(utmp.ut_line,
			   my_pty_name(ttydev), sizeof(utmp.ut_line));
d4335 3
a4337 3
	    (void) strncpy(utmp.ut_name,
			   (login_name) ? login_name : "????",
			   sizeof(utmp.ut_name));
d4388 5
a4392 5
		    (void) strncpy(utmp.ut_line,
				   my_pty_name(ttydev),
				   sizeof(utmp.ut_line));
		    (void) strncpy(utmp.ut_name, login_name,
				   sizeof(utmp.ut_name));
d4620 1
d4629 4
a4632 3
		shell_path = explicit_shname;
	    } else if (validShell(shell_path = x_getenv("SHELL"))) {
		;		/* OK */
d4646 1
a4646 2
	    if (explicit_shname != 0 && access(explicit_shname, X_OK) == 0) {
		free(shell_path);
d4648 3
d4941 1
a4941 1
		strncpy(utmp.ut_line, utptr->ut_line, sizeof(utmp.ut_line));
d4985 3
a4987 3
	    (void) strncpy(utmp.ut_line,
			   my_pty_name(ttydev),
			   sizeof(utmp.ut_line));
d5045 3
@


1.28
log
@Update to xterm-300. Tested  by ajacoutot@@ and shadchin@@.
@
text
@d1 1
a1 1
/* $XTermId: main.c,v 1.735 2013/11/27 00:41:23 tom Exp $ */
d4 1
a4 1
 * Copyright 2002-2012,2013 by Thomas E. Dickey
a182 1
#define HAS_BSD_GROUPS
a223 4
#ifdef CRAY
#define HAS_BSD_GROUPS
#endif

a224 1
#define HAS_BSD_GROUPS
a234 1
#define HAS_BSD_GROUPS
a238 1
#define HAS_BSD_GROUPS
a243 1
#define HAS_BSD_GROUPS
a284 3
#ifndef __INTERIX
#define HAS_BSD_GROUPS
#endif
d3147 54
d4432 1
a4432 1
#ifdef HAS_BSD_GROUPS
d4563 1
a4563 1
	     * If we have an explicit program to run, make that set $SHELL.
d4570 10
a4579 11
	    if ((shell_path = explicit_shname) == NULL) {
		if ((shell_path = x_getenv("SHELL")) == NULL) {
		    if ((!OkPasswd(&pw) && !x_getpwuid(screen->uid, &pw))
			|| *(shell_path = x_strdup(pw.pw_shell)) == 0) {
			if (shell_path)
			    free(shell_path);
			shell_path = x_strdup("/bin/sh");
		    } else if (shell_path != 0) {
			xtermSetenv("SHELL", shell_path);
		    }
		}
d4581 1
a4581 1
		xtermSetenv("SHELL", explicit_shname);
d4583 6
a4588 2
	    if (access(shell_path, X_OK) != 0) {
		xtermPerror("Cannot use '%s' as shell", shell_path);
d4590 1
a4590 1
		shell_path = x_strdup("/bin/sh");
@


1.27
log
@Update to xterm 293. Tested by naddy@@ ajacoutot@@
@
text
@d1 1
a1 1
/* $XTermId: main.c,v 1.727 2013/05/27 22:11:11 tom Exp $ */
d459 1
a459 1
static void set_owner(char *device, uid_t uid, gid_t gid, mode_t mode);
d886 3
d1023 3
d1212 3
d1478 1
a1478 1
	    have_value = (Boolean) ! isOption(value);
d1515 4
d1648 1
a1648 1
	     String * params GCC_UNUSED,
d1668 1
a1668 1
		String * params GCC_UNUSED,
d1957 1
a1957 1
    char *my_class = DEFCLASS;
d2040 1
d2194 1
d2740 1
a2740 1
set_pty_permissions(uid_t uid, gid_t gid, mode_t mode)
d3061 1
a3061 1
set_owner(char *device, uid_t uid, gid_t gid, mode_t mode)
d3699 1
a3699 2
		if (screen->respond >= 0)
		    close(screen->respond);
d4081 5
d4895 2
@


1.26
log
@Update to xterm 291. Tested by many.
@
text
@d1 1
a1 1
/* $XTermId: main.c,v 1.716 2013/02/03 23:10:05 tom Exp $ */
d2435 1
d2439 1
a2439 2
#ifdef DEBUG
    {
d2445 3
a2447 5
	if (debug) {
	    timestamp_filename(dbglogfile, "xterm.debug.log.");
	    if (creat_as(save_ruid, save_rgid, False, dbglogfile, 0600) > 0) {
		i = open(dbglogfile, O_WRONLY | O_TRUNC);
	    }
d2455 1
a2455 2
    }
#endif /* DEBUG */
d2534 3
a2536 4
#ifdef DEBUG
    if (debug)
	printf("debugging on\n");
#endif /* DEBUG */
d2604 3
a2606 1
#if defined(HAVE_POSIX_OPENPT) && defined(HAVE_PTSNAME) && defined(HAVE_GRANTPT_PTY_ISATTY)
a2619 1

a2622 5

#elif defined(USE_OPENPTY)

    result = openpty(pty, &opened_tty, ttydev, NULL, NULL);

a2623 1

a2624 1

d2773 5
d2894 1
d3052 1
a3052 1
	   device, uid, gid, (unsigned) mode));
d3075 1
a3075 1
		       sb.st_uid, sb.st_gid, (unsigned) sb.st_mode));
d3192 1
a3192 1
    char *ptr, *shname, *shname_minus;
d3540 1
d3552 1
d3658 2
d4253 1
a4253 1
		write(i, (char *) &utmp, sizeof(utmp));
d4285 1
a4285 1
		    write(i, (char *) &utmp, sizeof(utmp));
d4300 1
a4300 1
			write(i, (char *) &utmp, sizeof(utmp));
d4343 1
a4343 1
		    write(i, (char *) &lastlog, size);
d4761 1
d4771 1
d4825 1
a4825 1
			write(fd, utptr, sizeof(*utptr));
d4845 1
d4855 1
a4855 1
	    write(wfd, (char *) &utmp, sizeof(utmp));
d4865 1
a4865 1
	    write(wfd, (char *) &utmp, sizeof(utmp));
d5029 2
d5042 1
a5042 4
#ifdef DEBUG
	    if (debug)
		fputs("Exiting\n", stderr);
#endif
@


1.25
log
@Update to xterm 287. tested by mpi@@ and krw@@.
@
text
@d1 1
a1 1
/* $XTermId: main.c,v 1.689 2012/11/19 10:33:33 tom Exp $ */
d4 1
a4 1
 * Copyright 2002-2011,2012 by Thomas E. Dickey
d93 1
d449 1
a449 1
static SIGNAL_T reapchild(int /* n */ );
d1538 4
a1541 3
	    if (result->argKind != XrmoptionStickyArg
		&& strcmp(argv[*num], x_strdup(result->option))) {
		argv[*num] = x_strdup(result->option);
d2003 3
a2005 1
		if (isOption(argv[n])) {
d2185 1
a2185 1
					&argc, argv,
d2896 1
a2896 1
static SIGNAL_T
a2899 1
    SIGNAL_RETURN;
d2989 1
a2989 1
    strcpy(handshake.buffer, ttydev);
d3107 1
d3113 1
a3113 1
	memcpy(working.ut_id, tofind->ut_id, sizeof(tofind->ut_id));
d3119 8
a3126 1
	if (!strcmp(result->ut_line, tofind->ut_line))
d3195 1
d3462 1
a3462 1
		    ok_termcap = True;
d3758 1
a3758 1
		    strcpy(handshake.buffer, ttydev);
d3778 2
d4192 1
a4192 1
		TRACE(("getutid: pid=%d type=%d user=%s line=%s id=%s\n",
d4194 2
a4195 1
		       utret->ut_line, utret->ut_id));
d4237 3
a4239 3
		TRACE(("pututline: id %s, line %s, pid %ld, errno %d %s\n",
		       utmp.ut_id,
		       utmp.ut_line,
d4361 1
a4361 1
		strcpy(handshake.buffer, ttydev);
d4386 2
a4387 2
		fcntl(cp_pipe[1], F_SETFD, 1);
		fcntl(pc_pipe[0], F_SETFD, 1);
d4395 1
a4395 1
		(void) strcpy(handshake.buffer, ttydev);
d4509 2
a4510 2
	    if ((ptr = explicit_shname) == NULL) {
		if ((ptr = x_getenv("SHELL")) == NULL) {
d4512 6
a4517 4
			|| *(ptr = pw.pw_shell) == 0) {
			ptr = x_strdup("/bin/sh");
		    } else if (ptr != 0) {
			xtermSetenv("SHELL", ptr);
d4523 6
a4528 1
	    xtermSetenv("XTERM_SHELL", ptr);
d4530 2
a4531 2
	    shname = x_basename(ptr);
	    TRACE(("shell path '%s' leaf '%s'\n", ptr, shname));
d4540 3
a4542 2
		xtermSetenv("XTERM_SHELL",
			    xtermFindShell(*command_to_exec_with_luit, False));
d4550 3
a4552 2
		xtermSetenv("XTERM_SHELL",
			    xtermFindShell(*command_to_exec, False));
d4556 2
a4557 1
		    execlp(ptr, shname, "-c", command_to_exec[0], (void *) 0);
d4597 1
a4597 1
	    execlp(ptr,
d4602 1
a4602 1
	    xtermPerror("Could not exec %s", ptr);
d4604 1
d4654 1
a4654 1
		    (void) strcpy(handshake.buffer, ttydev);
d4746 4
d4754 1
a4754 1
SIGNAL_T
d4771 3
a4773 2
    if (xterm_exiting)
	SIGNAL_RETURN;
d4905 2
a4907 2
	if (xw != 0) {
	    Display *dpy = TScreenOf(xw)->display;
d4909 7
a4915 7
	    if (toplevel) {
		XtDestroyWidget(toplevel);
		TRACE(("destroyed top-level widget\n"));
	    }
	    sortedOpts(0, 0, 0);
	    noleaks_charproc();
	    noleaks_ptydata();
d4917 1
a4917 1
	    noleaks_CharacterClass();
d4919 6
a4924 6
	    /* XrmSetDatabase(dpy, 0); increases leaks ;-) */
	    XtCloseDisplay(dpy);
	    XtDestroyApplicationContext(app_con);
	    xtermCloseSession();
	    TRACE(("closed display\n"));
	}
a4929 1
    SIGNAL_RETURN;
d4971 10
a4980 8
	ptr1 = strchr(ptr1, ':');
	strncpy(temp, ptr1, i = (size_t) (ptr2 - ptr1));
	temp += i;
	sprintf(temp, "%d", (li_first
			     ? MaxCols(screen)
			     : MaxRows(screen)));
	ptr2 = strchr(ptr2, ':');
	strcat(temp, ptr2);
d5020 1
a5020 1
static SIGNAL_T
a5046 1
    SIGNAL_RETURN;
@


1.24
log
@Update to xterm 279. Tested by krw@@, mpi@@, shadchin@@.
@
text
@d1 1
a1 1
/* $XTermId: main.c,v 1.684 2012/05/07 23:30:42 tom Exp $ */
d835 1
a871 1
#ifndef __OpenBSD__
a873 4
#else
    Bres("ptyInitialErase", "PtyInitialErase", ptyInitialErase, DEF_INITIAL_ERASE),
    Bres("backarrowKeyIsErase", "BackarrowKeyIsErase", backarrow_is_erase, DEF_BACKARO_ERASE),
#endif
a1523 6
	if (!exact && ambiguous1 >= 0 && ambiguous2 >= 0) {
	    xtermWarning(
			    "ambiguous option \"%s\" vs \"%s\"\n",
			    ITEM(ambiguous1)->option,
			    ITEM(ambiguous2)->option);
	}
d1525 24
a1548 13
	TRACE(("...result %s\n", result->option));
	/* expand abbreviations */
	if (result->argKind != XrmoptionStickyArg
	    && strcmp(argv[*num], x_strdup(result->option))) {
	    argv[*num] = x_strdup(result->option);
	}

	/* adjust (*num) to skip option value */
	(*num) += countArg(result);
	TRACE(("...next %s\n", NonNull(argv[*num])));
	if (result->argKind == XrmoptionSkipArg) {
	    *valuep = argv[*num];
	    TRACE(("...parameter %s\n", NonNull(*valuep)));
d1857 1
a1857 1
#endif /* linux && _POSIX_SOURCE */
d2391 1
a2391 1
	TRACE(("setting:\n\ttitle \"%s\"\n\ticon \"%s\"\n\tbased on command \"%s\"\n",
d2394 1
d4046 8
d5039 3
a5041 1
	    while ((*first++ = *buf++) != 0) ;
@


1.23
log
@Update to xterm 278. Tested by mpi@@, shadchin@@
@
text
@d1 1
a1 1
/* $XTermId: main.c,v 1.678 2012/01/06 22:04:40 tom Exp $ */
d4 1
a4 1
 * Copyright 2002-2010,2011 by Thomas E. Dickey
d882 1
d2228 1
a2228 6
#if OPT_ZICONBEEP
    if (resource.zIconBeep > 100 || resource.zIconBeep < -100) {
	resource.zIconBeep = 0;	/* was 100, but I prefer to defaulting off. */
	xtermWarning("a number between -100 and 100 is required for zIconBeep.  0 used by default\n");
    }
#endif /* OPT_ZICONBEEP */
d2602 1
a2602 1
#if defined(HAVE_POSIX_OPENPT) && defined(HAVE_PTSNAME)
d3377 1
d3539 1
d3588 1
d3711 3
d3804 1
a3804 1
#if OPT_WIDE_CHARS && defined(linux) && defined(IUTF8)
@


1.22
log
@Update to xterm 276. Tested by ajacoutot@@, krw@@, naddy@@, shadchin@@.
@
text
@d1 1
a1 1
/* $XTermId: main.c,v 1.669 2011/10/09 14:14:51 tom Exp $ */
a138 4
#ifdef USE_ISPTS_FLAG
static Bool IsPts = False;
#endif

d753 1
a753 1
#define TMODE(ind,var) if (ttymodelist[ind].set) var = ttymodelist[ind].value
d1528 4
a1531 5
	    fprintf(stderr,
		    "%s:  ambiguous option \"%s\" vs \"%s\"\n",
		    ProgramName,
		    ITEM(ambiguous1)->option,
		    ITEM(ambiguous2)->option);
d1561 1
a1561 2
    fprintf(stderr, "%s:  bad command line option \"%s\"\r\n\n",
	    ProgramName, badOption);
d1863 1
a1863 1
	fprintf(stderr, "%s: unable to reset uid\n", ProgramName);
d1878 1
a1878 1
	fprintf(stderr, "%s: unable to reset effective gid\n", ProgramName);
d1898 1
a1898 2
	    (void) fprintf(stderr, "setegid(%d): %s\n",
			   (int) group, strerror(errno));
d1915 1
a1915 2
	    (void) fprintf(stderr, "seteuid(%d): %s\n",
			   (int) user, strerror(errno));
d1972 1
a1972 3
	fprintf(stderr,
		"%s: unable to allocate memory for ttydev or ptydev\n",
		ProgramName);
d2002 1
a2002 1
		    fprintf(stderr, "Explicit shell already was %s\n", explicit_shname);
d2070 1
a2070 1
		    known_ttyChars[nn].myDefault;
d2222 1
a2222 2
	    fprintf(stderr, "%s:  bad tty modes \"%s\"\n",
		    ProgramName, resource.tty_modes);
d2230 1
a2230 2
	fprintf(stderr,
		"a number between -100 and 100 is required for zIconBeep.  0 used by default\n");
d2606 14
a2619 1
#if defined(PUCC_PTYD)
a2633 30
#if defined(USE_ISPTS_FLAG)

    /*
       The order of this code is *important*.  On SYSV/386 we want to open
       a /dev/ttyp? first if at all possible.  If none are available, then
       we'll try to open a /dev/pts??? device.

       The reason for this is because /dev/ttyp? works correctly, where
       as /dev/pts??? devices have a number of bugs, (won't update
       screen correcly, will hang -- it more or less works, but you
       really don't want to use it).

       Most importantly, for boxes of this nature, one of the major
       "features" is that you can emulate a 8086 by spawning off a UNIX
       program on 80386/80486 in v86 mode.  In other words, you can spawn
       off multiple MS-DOS environments.  On ISC the program that does
       this is named "vpix."  The catcher is that "vpix" will *not* work
       with a /dev/pts??? device, will only work with a /dev/ttyp? device.

       Since we can open either a /dev/ttyp? or a /dev/pts??? device,
       the flag "IsPts" is set here so that we know which type of
       device we're dealing with in routine spawnXTerm().  That's the reason
       for the "if (IsPts)" statement in spawnXTerm(); we have two different
       device types which need to be handled differently.
     */
    result = pty_search(pty);
    if (!result)
	IsPts = 0;

#endif
d2648 1
a2648 11
#if defined(USE_ISPTS_FLAG)
    if (result) {
#endif
	result = ((*pty = open("/dev/ptmx", O_RDWR)) < 0);
#endif
#if defined(SVR4) || defined(__SCO__) || defined(USE_ISPTS_FLAG)
	if (!result)
	    strcpy(ttydev, ptsname(*pty));
#ifdef USE_ISPTS_FLAG
	IsPts = !result;	/* true if we're successful */
    }
d2650 3
d3000 4
a3003 6
	fprintf(stderr,
		"%s: fatal pty error errno=%d, error=%d device \"%s\"\n",
		ProgramName,
		handshake.error,
		handshake.fatal_error,
		handshake.buffer);
d3041 2
a3042 2
    fprintf(stderr, "%s: fatal pty error %d (errno=%d) on tty %s\n",
	    ProgramName, error, errno, ttydev);
d3061 2
a3062 3
	    fprintf(stderr, "Cannot chown %s to %ld,%ld: %s\n",
		    device, (long) uid, (long) gid,
		    strerror(why));
d3070 2
a3071 3
		fprintf(stderr, "Cannot chmod %s to %03o: %s\n",
			device, (unsigned) mode,
			strerror(why));
d3073 4
a3076 6
		fprintf(stderr,
			"Cannot chmod %s to %03lo currently %03lo: %s\n",
			device,
			(unsigned long) mode,
			(unsigned long) (sb.st_mode & 0777U),
			strerror(why));
d3278 2
a3279 1
	 * Cygwin returns ENOENT.
d3286 1
a3289 3
#ifdef __CYGWIN__
		errno == ENOENT ||
#endif
d3533 11
d3552 2
d3584 4
a3587 2
#ifdef USE_ISPTS_FLAG
		if (IsPts) {	/* SYSV386 supports both, which did we open? */
d3589 6
a3594 8
		setpgrp();
		grantpt(screen->respond);
		unlockpt(screen->respond);
		if ((pty_name = ptsname(screen->respond)) == 0) {
		    SysError(ERROR_PTSNAME);
		} else if ((ptyfd = open(pty_name, O_RDWR)) < 0) {
		    SysError(ERROR_OPPTSNAME);
		}
d3596 3
a3598 3
		else if (ioctl(ptyfd, I_PUSH, "ptem") < 0) {
		    SysError(ERROR_PTEM);
		}
d3600 4
a3603 4
		else if (!x_getenv("CONSEM")
			 && ioctl(ptyfd, I_PUSH, "consem") < 0) {
		    SysError(ERROR_CONSEM);
		}
d3605 3
a3607 3
		else if (ioctl(ptyfd, I_PUSH, "ldterm") < 0) {
		    SysError(ERROR_LDTERM);
		}
d3609 3
a3611 3
		else if (ioctl(ptyfd, I_PUSH, "ttcompat") < 0) {
		    SysError(ERROR_TTCOMPAT);
		}
d3614 1
a3614 1
		ttyfd = ptyfd;
d3616 1
a3616 1
		close_fd(screen->respond);
d3620 1
a3620 1
		/* tell tty how big window is */
d3622 3
a3624 3
		if (TEK4014_ACTIVE(xw)) {
		    TTYSIZE_ROWS(ts) = 24;
		    TTYSIZE_COLS(ts) = 80;
d3626 2
a3627 2
		    ts.ws_xpixel = TFullWidth(TekScreenOf(tekWidget));
		    ts.ws_ypixel = TFullHeight(TekScreenOf(tekWidget));
d3629 1
a3629 1
		} else
d3631 3
a3633 3
		{
		    TTYSIZE_ROWS(ts) = (ttySize_t) MaxRows(screen);
		    TTYSIZE_COLS(ts) = (ttySize_t) MaxCols(screen);
d3635 2
a3636 2
		    ts.ws_xpixel = (ttySize_t) FullWidth(screen);
		    ts.ws_ypixel = (ttySize_t) FullHeight(screen);
d3638 1
a3638 1
		}
a3640 3
#ifdef USE_ISPTS_FLAG
	    } else {		/* else pty, not pts */
#endif
d3643 1
a3643 1
		(void) pgrp;	/* not all branches use this variable */
d3646 4
a3649 4
		if (resource.ptyHandshake) {
		    /* close parent's sides of the pipes */
		    close(cp_pipe[0]);
		    close(pc_pipe[1]);
d3651 8
a3658 9
		    /* Make sure that our sides of the pipes are not in the
		     * 0, 1, 2 range so that we don't fight with stdin, out
		     * or err.
		     */
		    if (cp_pipe[1] <= 2) {
			if ((i = fcntl(cp_pipe[1], F_DUPFD, 3)) >= 0) {
			    IGNORE_RC(close(cp_pipe[1]));
			    cp_pipe[1] = i;
			}
d3660 5
a3664 5
		    if (pc_pipe[0] <= 2) {
			if ((i = fcntl(pc_pipe[0], F_DUPFD, 3)) >= 0) {
			    IGNORE_RC(close(pc_pipe[0]));
			    pc_pipe[0] = i;
			}
d3666 1
d3668 2
a3669 2
		    /* we don't need the socket, or the pty master anymore */
		    close(ConnectionNumber(screen->display));
d3671 2
a3672 2
		    if (screen->respond >= 0)
			close(screen->respond);
d3675 3
a3677 3
		    /* Now is the time to set up our process group and
		     * open up the pty slave.
		     */
d3680 1
a3680 1
		    IGNORE_RC(setsid());
d3682 1
a3682 1
		    IGNORE_RC(setpgrp());
d3687 1
a3687 1
		    qsetlogin(getlogin(), ttydev);
d3689 1
a3689 1
		    if (ttyfd >= 0) {
d3691 4
a3694 4
			if (ttyGetAttr(ttyfd, &gio) == 0) {
			    gio.c_cflag &= ~(HUPCL | PARENB);
			    ttySetAttr(ttyfd, &gio);
			}
d3696 1
a3696 1
			close_fd(ttyfd);
d3698 1
a3698 1
		    }
d3700 1
a3700 1
		    for (;;) {
d3702 5
a3706 5
			if (!no_dev_tty
			    && (ttyfd = open("/dev/tty", O_RDWR)) >= 0) {
			    ioctl(ttyfd, TIOCNOTTY, (char *) NULL);
			    close_fd(ttyfd);
			}
d3709 1
a3709 1
			IGNORE_RC(revoke(ttydev));
d3711 1
a3711 1
			if ((ttyfd = open(ttydev, O_RDWR)) >= 0) {
d3713 2
a3714 2
			    /* make /dev/tty work */
			    ioctl(ttyfd, TCSETCTTY, 0);
d3717 2
a3718 2
			    /* make /dev/tty work */
			    ioctl(ttyfd, TIOCSCTTY, 0);
d3721 10
a3730 10
			    /* We need to make sure that we are actually
			     * the process group leader for the pty.  If
			     * we are, then we should now be able to open
			     * /dev/tty.
			     */
			    if ((i = open("/dev/tty", O_RDWR)) >= 0) {
				/* success! */
				close(i);
				break;
			    }
d3732 1
a3732 1
			    break;
d3734 2
a3735 2
			}
			perror("open ttydev");
d3737 1
a3737 1
			ioctl(ttyfd, TIOCSCTTY, 0);
d3739 8
a3746 8
			/* let our master know that the open failed */
			handshake.status = PTY_BAD;
			handshake.error = errno;
			strcpy(handshake.buffer, ttydev);
			TRACE_HANDSHAKE("writing", &handshake);
			IGNORE_RC(write(cp_pipe[1],
					(const char *) &handshake,
					sizeof(handshake)));
d3748 7
a3754 7
			/* get reply from parent */
			i = (int) read(pc_pipe[0], (char *) &handshake,
				       sizeof(handshake));
			if (i <= 0) {
			    /* parent terminated */
			    exit(1);
			}
d3756 4
a3759 4
			if (handshake.status == PTY_NOMORE) {
			    /* No more ptys, let's shutdown. */
			    exit(1);
			}
d3761 4
a3764 4
			/* We have a new pty to try */
			free(ttydev);
			ttydev = x_strdup(handshake.buffer);
		    }
d3766 6
a3771 7
		    /* use the same tty name that everyone else will use
		     * (from ttyname)
		     */
		    if ((ptr = ttyname(ttyfd)) != 0) {
			free(ttydev);
			ttydev = x_strdup(ptr);
		    }
d3773 1
a3775 4
#ifdef USE_ISPTS_FLAG
	    }			/* end of IsPts else clause */
#endif

d3872 1
a3872 1
			tio.c_cc[sysMode] = known_ttyChars[nn].myDefault;
d3978 1
a3978 2
			fprintf(stderr, "%s: cannot open console: %s\n",
				ProgramName, strerror(errno));
d3983 1
a3983 2
			fprintf(stderr, "%s: cannot open console: %s\n",
				ProgramName, strerror(errno));
d4024 1
a4024 1
		tio.c_cc[VERASE] = initial_erase;
d4307 1
a4307 1
		off_t offset = (screen->uid * size);
d4510 2
a4511 5
		/* print error message on screen */
		fprintf(stderr, "%s: Can't execvp %s: %s\n",
			ProgramName, *command_to_exec_with_luit, strerror(errno));
		fprintf(stderr, "%s: cannot support your locale.\n",
			ProgramName);
d4521 1
a4521 3
		/* print error message on screen */
		fprintf(stderr, "%s: Can't execvp %s: %s\n",
			ProgramName, *command_to_exec, strerror(errno));
d4557 1
a4557 2
		fprintf(stderr, "%s: Can't execvp %s: %s\n", ProgramName,
			*command_to_exec_with_luit, strerror(errno));
d4565 1
a4565 2
	    fprintf(stderr, "%s: Could not exec %s: %s\n", ProgramName,
		    ptr, strerror(errno));
d4607 1
a4607 3
			fprintf(stderr,
				"%s: child process can find no available ptys: %s\n",
				ProgramName, strerror(errno));
d4646 2
a4647 3
		    fprintf(stderr, "%s: unexpected handshake status %d\n",
			    ProgramName,
			    (int) handshake.status);
d4719 2
a4720 1
    if (!resource.utmpInhibit && added_utmp_entry)
d4722 1
@


1.21
log
@Update to xterm-275. Tested by jasper@@.
@
text
@d1 1
a1 1
/* $XTermId: main.c,v 1.667 2011/09/11 21:02:37 tom Exp $ */
d1405 1
a1405 1
#define isOption(string) ((string)[0] == '-' || (string)[0] == '+')
d1462 2
d1469 1
a1469 1
    if (argv[*num] != 0) {
d1473 2
a1474 3
	TRACE(("parseArg %s\n", argv[*num]));
	if (argv[(*num) + 1] != 0) {
	    char *value = argv[(*num) + 1];
d1480 1
a1480 1
	    test = matchArg(check, argv[*num]);
d1487 1
a1487 1
		    if (strlen(argv[*num]) > strlen(check->option)) {
d1492 1
a1492 1
		} else if ((test + 1) == (int) strlen(argv[*num])) {
d1501 3
a1503 1
	    if (need_value ^ have_value) {
@


1.20
log
@Update to xterm 273. Tested by marco@@, jasper@@.
@
text
@d1 73
a73 1
/* $XTermId: main.c,v 1.656 2011/08/25 08:55:31 tom Exp $ */
a87 74
/***********************************************************

Copyright 2002-2010,2011 by Thomas E. Dickey

                        All Rights Reserved

Permission is hereby granted, free of charge, to any person obtaining a
copy of this software and associated documentation files (the
"Software"), to deal in the Software without restriction, including
without limitation the rights to use, copy, modify, merge, publish,
distribute, sublicense, and/or sell copies of the Software, and to
permit persons to whom the Software is furnished to do so, subject to
the following conditions:

The above copyright notice and this permission notice shall be included
in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
IN NO EVENT SHALL THE ABOVE LISTED COPYRIGHT HOLDER(S) BE LIABLE FOR ANY
CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

Except as contained in this notice, the name(s) of the above copyright
holders shall not be used in advertising or otherwise to promote the
sale, use or other dealings in this Software without prior written
authorization.

Copyright 1987, 1988  The Open Group

Permission to use, copy, modify, distribute, and sell this software and its
documentation for any purpose is hereby granted without fee, provided that
the above copyright notice appear in all copies and that both that
copyright notice and this permission notice appear in supporting
documentation.

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
OPEN GROUP BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

Except as contained in this notice, the name of The Open Group shall not be
used in advertising or otherwise to promote the sale, use or other dealings
in this Software without prior written authorization from The Open Group.

Copyright 1987, 1988 by Digital Equipment Corporation, Maynard.

                        All Rights Reserved

Permission to use, copy, modify, and distribute this software and its
documentation for any purpose and without fee is hereby granted,
provided that the above copyright notice appear in all copies and that
both that copyright notice and this permission notice appear in
supporting documentation, and that the name of Digital not be used in
advertising or publicity pertaining to distribution of the software
without specific, written prior permission.

DIGITAL DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING
ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL
DIGITAL BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR
ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
SOFTWARE.

******************************************************************/

d1034 1
a1421 1
	DATA("+rv",		   XrmoptionNoArg),
a1433 1
	DATA("-geometry",	   XrmoptionSepArg),
a1436 1
	DATA("-rv",		   XrmoptionNoArg),
d1459 3
d1487 1
d1492 1
d1517 2
a1518 4
			fprintf(stderr,
				"%s:  ambiguous option \"%s\" vs \"%s\"\n",
				ProgramName, check->option,
				ITEM(atbest)->option);
d1528 7
d2415 1
a2415 1
	unsigned count_using = (term->misc.use_encoding ? 2 : 0);
d2428 1
a2428 1
	    encoding_opt[0] = "-encoding";
d2436 1
a2436 1
	    delimiter[0] = "--";
d3236 1
a3236 1
    struct passwd *pw = NULL;
d3303 1
a3303 1
	pw = NULL;
a4161 1
	    pw = getpwuid(screen->uid);
d4163 2
a4164 32
	    if (pw && pw->pw_name) {
#ifdef HAVE_GETLOGIN
		/*
		 * If the value from getlogin() differs from the value we
		 * get by looking in the password file, check if it does
		 * correspond to the same uid.  If so, allow that as an
		 * alias for the uid.
		 *
		 * Of course getlogin() will fail if we're started from
		 * a window-manager, since there's no controlling terminal
		 * to fuss with.  In that case, try to get something useful
		 * from the user's $LOGNAME or $USER environment variables.
		 */
		if (((login_name = getlogin()) != NULL
		     || (login_name = x_getenv("LOGNAME")) != NULL
		     || (login_name = x_getenv("USER")) != NULL)
		    && strcmp(login_name, pw->pw_name)) {
		    struct passwd *pw2 = getpwnam(login_name);
		    if (pw2 != 0) {
			uid_t uid2 = pw2->pw_uid;
			pw = getpwuid(screen->uid);
			if ((uid_t) pw->pw_uid != uid2)
			    login_name = NULL;
		    } else {
			pw = getpwuid(screen->uid);
		    }
		}
#endif
		if (login_name == NULL)
		    login_name = pw->pw_name;
		if (login_name != NULL)
		    login_name = x_strdup(login_name);
d4277 1
a4277 1
		if (tslot > 0 && pw && !resource.utmpInhibit &&
d4381 2
a4382 2
	    if (geteuid() == 0 && pw) {
		if (initgroups(login_name, pw->pw_gid)) {
d4446 1
a4446 1
	    if (pw) {		/* SVR4 doesn't provide these */
d4448 1
a4448 1
		    xtermSetenv("HOME", pw->pw_dir);
d4450 1
a4450 1
		    xtermSetenv("SHELL", pw->pw_shell);
a4517 1
	    unsetenv("SHELL");
d4520 2
a4521 2
		    if ((pw == NULL && (pw = getpwuid(screen->uid)) == NULL)
			|| *(ptr = pw->pw_shell) == 0) {
d4580 1
a4580 1
	    if (xw->misc.login_shell && pw && added_utmp_entry)
d4893 1
a4893 1
     * Close after releasing ownership to avoid race condition: other programs 
@


1.19
log
@Update to xterm 271. Tested by shadchin@@ and ajacoutot@@
@
text
@d1 1
a1 1
/* $XTermId: main.c,v 1.638 2011/07/14 00:18:58 tom Exp $ */
d138 3
d497 1
a1004 1
{"+kt",		"*keyboardType", XrmoptionSepArg,	(XPointer) NULL},
d1179 1
d1240 1
d1358 22
a1379 1
abbrev(const char *tst, const char *cmp, size_t need)
d1381 166
a1546 2
    size_t len = strlen(tst);
    return ((len >= need) && (!strncmp(tst, cmp, len)));
d1556 1
a1620 36
#if OPT_SESSION_MGT
static void
die_callback(Widget w GCC_UNUSED,
	     XtPointer client_data GCC_UNUSED,
	     XtPointer call_data GCC_UNUSED)
{
    Cleanup(0);
}

static void
save_callback(Widget w GCC_UNUSED,
	      XtPointer client_data GCC_UNUSED,
	      XtPointer call_data)
{
    XtCheckpointToken token = (XtCheckpointToken) call_data;
    /* we have nothing to save */
    token->save_success = True;
}

static void
icewatch(IceConn iceConn,
	 IcePointer clientData GCC_UNUSED,
	 Bool opening,
	 IcePointer * watchData GCC_UNUSED)
{
    if (opening) {
	ice_fd = IceConnectionNumber(iceConn);
	TRACE(("got IceConnectionNumber %d\n", ice_fd));
    } else {
	ice_fd = -1;
	TRACE(("reset IceConnectionNumber\n"));
    }
}

#endif /* OPT_SESSION_MGT */

d1993 2
a1995 1
	size_t unique = 2;
d1999 17
a2015 2
	    TRACE(("parsing %s\n", argv[n]));
	    if (abbrev(argv[n], "-version", unique)) {
d2018 1
a2018 1
	    } else if (abbrev(argv[n], "-help", unique)) {
d2021 2
a2022 2
	    } else if (abbrev(argv[n], "-class", (size_t) 3)) {
		if ((my_class = argv[++n]) == 0) {
d2026 3
d2033 7
d2042 1
a2042 1
    /* This dumps core on HP-UX 9.05 with X11R5 */
d2176 8
a2183 17
	XtSetErrorHandler(xt_error);
#if OPT_SESSION_MGT
	toplevel = XtOpenApplication(&app_con, my_class,
				     optionDescList,
				     XtNumber(optionDescList),
				     &argc, argv, fallback_resources,
				     sessionShellWidgetClass,
				     NULL, 0);
	IceAddConnectionWatch(icewatch, NULL);
#else
	toplevel = XtAppInitialize(&app_con, my_class,
				   optionDescList,
				   XtNumber(optionDescList),
				   &argc, argv, fallback_resources,
				   NULL, 0);
#endif /* OPT_SESSION_MGT */
	XtSetErrorHandler((XtErrorHandler) 0);
d2266 1
a2267 1
	if (**argv != '-')
a2269 1
	if (**argv != '-') {
a2271 2
	    if (command_to_exec == 0)	/* if no "-e" option */
		explicit_shname = xtermFindShell(*argv, True);
d2273 1
a2274 1
#endif
a2277 6
	case 'h':		/* -help */
	    Help();
	    exit(0);
	case 'v':		/* -version */
	    Version();
	    exit(0);
d2307 2
a2308 4
	case 'c':		/* -class param */
	    if (strcmp(argv[0] + 1, "class") == 0)
		argc--, argv++;
	    else
d2310 1
d2313 1
a2313 1
	    if (argc <= 1)
d2315 1
a2315 1
	    command_to_exec = ++argv;
d2318 1
a2318 1
	    if (argc <= 1) {
d2320 1
a2320 6
	    } else {
		char *endPtr;
		--argc;
		++argv;
		winToEmbedInto = (Window) strtol(argv[0], &endPtr, 10);
	    }
d2378 1
a2378 7
#if OPT_SESSION_MGT
    if (resource.sessionMgt) {
	TRACE(("Enabling session-management callbacks\n"));
	XtAddCallback(toplevel, XtNdieCallback, die_callback, NULL);
	XtAddCallback(toplevel, XtNsaveCallback, save_callback, NULL);
    }
#endif
d2406 28
a2433 26
	int u = (term->misc.use_encoding ? 2 : 0);
	if (command_to_exec) {
	    int n;
	    char **c;
	    for (n = 0, c = command_to_exec; *c; n++, c++) ;
	    c = TypeMallocN(char *, (unsigned) (n + 3 + u));
	    if (c == NULL)
		SysError(ERROR_LUMALLOC);
	    memcpy(c + 2 + u, command_to_exec, (unsigned) (n + 1) * sizeof(char *));
	    c[0] = term->misc.localefilter;
	    if (u) {
		c[1] = "-encoding";
		c[2] = term->misc.locale_str;
	    }
	    c[1 + u] = "--";
	    command_to_exec_with_luit = c;
	} else {
	    static char *luit[6];
	    luit[0] = term->misc.localefilter;
	    if (u) {
		luit[1] = "-encoding";
		luit[2] = term->misc.locale_str;
		luit[3] = NULL;
	    } else
		luit[1] = NULL;
	    command_to_exec_with_luit = luit;
d2435 1
d2553 1
a2553 15
    TRACE(("checking winToEmbedInto %#lx\n", winToEmbedInto));
    if (winToEmbedInto != None) {
	XtRealizeWidget(toplevel);
	/*
	 * This should probably query the tree or check the attributes of
	 * winToEmbedInto in order to verify that it exists, but I'm still not
	 * certain what is the best way to do it -GPS
	 */
	TRACE(("...reparenting toplevel %#lx into %#lx\n",
	       XtWindow(toplevel),
	       winToEmbedInto));
	XReparentWindow(XtDisplay(toplevel),
			XtWindow(toplevel),
			winToEmbedInto, 0, 0);
    }
d4535 9
d4545 7
a4551 4
		if (((ptr = x_getenv("SHELL")) == NULL) &&
		    ((pw == NULL && (pw = getpwuid(screen->uid)) == NULL) ||
		     *(ptr = pw->pw_shell) == 0)) {
		    ptr = x_strdup("/bin/sh");
d4570 1
a4570 1
		TRACE(("spawning command \"%s\"\n", *command_to_exec_with_luit));
d4582 1
a4582 1
		TRACE(("spawning command \"%s\"\n", *command_to_exec));
d4599 3
a4601 2
	    ldisc = XStrCmp("csh", shname + strlen(shname) - 3) == 0 ?
		NTTYDISC : 0;
d4613 7
a4619 5
		    int u;
		    u = (term->misc.use_encoding ? 2 : 0);
		    command_to_exec_with_luit[u + 1] = x_strdup("-argv0");
		    command_to_exec_with_luit[u + 2] = shname_minus;
		    command_to_exec_with_luit[u + 3] = NULL;
d4621 1
d4949 1
a4949 3
#if OPT_SESSION_MGT
	    IceRemoveConnectionWatch(icewatch, NULL);
#endif
@


1.18
log
@Update to xterm 270. Tested by ajacoutot@@, shadchin@@, krw@@ and jasper@@
@
text
@d1 1
a1 1
/* $XTermId: main.c,v 1.629 2011/04/22 23:09:15 tom Exp $ */
d850 3
d854 1
d1840 1
a1840 1
	Bool quit = True;
d1846 1
d1849 1
d1853 1
a1853 2
		} else {
		    quit = False;
a1854 4
		unique = 3;
	    } else {
		quit = False;
		unique = 3;
d2111 1
a2111 1
	    continue;
d2114 1
a2114 1
	    continue;
d2290 1
a2290 1
	char dbglogfile[45];
d2294 1
a2294 1
	    if (creat_as(save_ruid, save_rgid, False, dbglogfile, 0666) > 0) {
d2399 1
d2407 3
d2955 1
a2955 2
    }
    if (chmod(device, mode) < 0) {
d4751 1
d4760 1
d4772 1
a4772 24
#if OPT_PRINT_ON_EXIT
    /*
     * The user may have requested that the contents of the screen will be
     * written to a file if an X error occurs.
     */
    if (!IsEmpty(resource.printFileOnXError)) {
	switch (n) {
	case ERROR_XERROR:
	    /* FALLTHRU */
	case ERROR_XIOERROR:
	    /* FALLTHRU */
	case ERROR_ICEERROR:
	    closePrinter(xw);
	    screen->printToFile = True;
	    screen->printer_command = resource.printFileOnXError;
	    screen->printer_autoclose = True;
	    screen->printer_formfeed = False;
	    screen->printer_newline = True;
	    screen->print_attributes = resource.printModeOnXError;
	    xtermPrintEverything(xw, getPrinterFlags(xw, NULL, 0));
	    break;
	}
    }
#endif
@


1.17
log
@Update to xterm version 269.
Tested and ok ajacoutot@@, jasper@@, krw@@, shadchin@@
@
text
@d1 1
a1 1
/* $XTermId: main.c,v 1.625 2011/02/18 01:24:50 tom Exp $ */
d262 1
a262 1
#else	/* } !SYSV { */	/* BSD systems */
d849 4
d903 3
a2015 1
	VTInitTranslations();
d2021 1
d2389 1
d3103 4
d3942 12
d4764 25
@


1.16
log
@Update to xterm 261. Tested by krw@@, jcs@@.
@
text
@d1 1
a1 1
/* $XTermId: main.c,v 1.618 2010/06/20 21:11:51 tom Exp $ */
d18 1
a18 1
Copyright 2002-2009,2010 by Thomas E. Dickey
a834 1
    Sres("name", "Name", xterm_name, DFT_TERMTYPE),
d847 1
d893 1
d1090 2
d1267 1
d1759 10
a1774 3
#if OPT_COLOR_RES
    Bool reversed = False;
#endif
a1844 8
#if OPT_COLOR_RES
		if (abbrev(argv[n], "-reverse", (size_t) 2)
		    || !strcmp("-rv", argv[n])) {
		    reversed = True;
		} else if (!strcmp("+rv", argv[n])) {
		    reversed = False;
		}
#endif
d2009 6
a2056 3
    xterm_name = resource.xterm_name;
    if (strcmp(xterm_name, "-") == 0)
	xterm_name = DFT_TERMTYPE;
d2402 2
a2403 2
    TRACE(("checking resource values rv %s fg %s, bg %s\n",
	   BtoS(term->misc.re_verse0),
d2407 15
a2421 7
    if ((reversed && term->misc.re_verse0)
	&& ((TScreenOf(term)->Tcolors[TEXT_FG].resource
	     && !isDefaultForeground(TScreenOf(term)->Tcolors[TEXT_FG].resource))
	    || (TScreenOf(term)->Tcolors[TEXT_BG].resource
		&& !isDefaultBackground(TScreenOf(term)->Tcolors[TEXT_BG].resource))
	))
	ReverseVideo(term);
d3340 1
d3356 1
a3356 1
	;
d3568 1
a3568 1
		    while (1) {
d3916 2
a3917 2
	    xtermSetenv("TERM", TermName);
	    if (!TermName)
d4944 1
a4944 1
    while (1) {
@


1.15
log
@Update to xterm 258. lightly tested by krw@@, thanks.
@
text
@d1 1
a1 1
/* $XTermId: main.c,v 1.610 2010/04/18 17:09:13 tom Exp $ */
d1302 1
a1302 1
		    value = fpathconf(0, _PC_VDISABLE);
d1323 1
a1323 1
	int temp = strtol(string + 1, &d, 8);
d2380 1
a2380 1
	StartLog(screen);
d2999 6
d3054 4
a3057 1
    int i, no_dev_tty = False;
d3143 1
d3145 1
d3155 1
d3157 1
d3195 2
a3196 1
	    if ((rc = ttyGetAttr(ttyfd, &tio)) == -1)
d3199 2
a3200 1
	    if ((rc = ioctl(ttyfd, TIOCGETP, (char *) &sg)) == -1)
d3249 2
a3250 1
	    if ((rc = ttyGetAttr(screen->respond, &my_tio)) == 0)
d3254 2
a3255 1
	    if ((rc = ioctl(screen->respond, TIOCGETP, (char *) &my_sg)) == 0)
d3358 1
a3358 1
	    xw->keyboard.flags &= ~MODE_DECBKM;
d3383 2
a3384 2
	TTYSIZE_ROWS(ts) = MaxRows(screen);
	TTYSIZE_COLS(ts) = MaxCols(screen);
d3386 2
a3387 2
	ts.ws_xpixel = FullWidth(screen);
	ts.ws_ypixel = FullHeight(screen);
d3390 1
a3390 1
    i = SET_TTYSIZE(screen->respond, ts);
d3420 1
a3420 1
	    int ptyfd;
a3436 3
		ptyfd = 0;
		pty_name = 0;

d3442 1
a3442 2
		}
		if ((ptyfd = open(pty_name, O_RDWR)) < 0) {
d3446 1
a3446 1
		if (ioctl(ptyfd, I_PUSH, "ptem") < 0) {
d3450 2
a3451 1
		if (!x_getenv("CONSEM") && ioctl(ptyfd, I_PUSH, "consem") < 0) {
d3455 1
a3455 1
		if (ioctl(ptyfd, I_PUSH, "ldterm") < 0) {
d3459 1
a3459 1
		if (ioctl(ptyfd, I_PUSH, "ttcompat") < 0) {
d3482 2
a3483 2
		    TTYSIZE_ROWS(ts) = MaxRows(screen);
		    TTYSIZE_COLS(ts) = MaxCols(screen);
d3485 2
a3486 2
		    ts.ws_xpixel = FullWidth(screen);
		    ts.ws_ypixel = FullHeight(screen);
d3554 1
a3554 1
#if defined(TIOCNOTTY) && (!defined(__GLIBC__) || (__GLIBC__ < 2) || ((__GLIBC__ == 2) && (__GLIBC_MINOR__ < 1)))
d3560 1
a3560 1
#endif /* TIOCNOTTY && !glibc >= 2.1 */
d3602 2
a3603 2
			i = read(pc_pipe[0], (char *) &handshake,
				 sizeof(handshake));
d3616 1
a3616 5
			ttydev = CastMallocN(char, strlen(handshake.buffer));
			if (ttydev == NULL) {
			    SysError(ERROR_SPREALLOC);
			}
			strcpy(ttydev, handshake.buffer);
d3623 2
a3624 6
			/* it may be bigger */
			ttydev = TypeRealloc(char, strlen(ptr) + 1, ttydev);
			if (ttydev == NULL) {
			    SysError(ERROR_SPREALLOC);
			}
			(void) strcpy(ttydev, ptr);
d3657 1
a3657 1
		tio.c_iflag &= ~(INLCR | IGNCR);
d3668 9
a3676 9
		tio.c_oflag &=
		    ~(OCRNL
		      | ONLRET
		      | NLDLY
		      | CRDLY
		      | TABDLY
		      | BSDLY
		      | VTDLY
		      | FFDLY);
d3688 1
a3688 1
		tio.c_cflag &= ~(CBAUD);
d3768 1
a3768 1
		tio.c_cflag &= ~CSIZE;
d3884 1
a3884 1
		rc = ttySetAttr(ttyfd, &tio);
d4031 2
a4032 1
	    if (!(utret = find_utmp(&utmp))) {
d4035 2
a4036 1
		if (!(utret = find_utmp(&utmp))) {
d4253 2
a4254 2
		    i = read(pc_pipe[0], (char *) &handshake,
			     sizeof(handshake));
d4267 2
a4268 2
			TTYSIZE_ROWS(ts) = MaxRows(screen);
			TTYSIZE_COLS(ts) = MaxCols(screen);
d4270 2
a4271 2
			ts.ws_xpixel = FullWidth(screen);
			ts.ws_ypixel = FullHeight(screen);
d4320 1
a4320 1
		    len = strlen(newtc);
d4343 1
a4343 1
		i = SET_TTYSIZE(0, ts);
d4588 2
a4589 1
    TScreen *screen = TScreenOf(term);
d4640 1
a4640 1
		if (term->misc.login_shell)
d4644 1
a4644 1
		if (term->misc.login_shell)
d4648 1
a4648 1
		if (term->misc.login_shell) {
d4684 1
a4684 1
	if (term->misc.login_shell &&
d4724 1
a4724 1
	CloseLog(screen);
d4730 2
a4731 2
	if (term != 0) {
	    Display *dpy = TScreenOf(term)->display;
d4751 1
a4751 1
	TRACE((0));
@


1.14
log
@Update to xterm-255. Tested by stsp@@, oga@@.
@
text
@d1 1
a1 1
/* $XTermId: main.c,v 1.602 2010/01/20 22:07:23 tom Exp $ */
d847 1
a847 1
    Sres("menuLocale", "MenuLocale", menuLocale, ""),
d1826 1
a1826 1
	    } else if (abbrev(argv[n], "-class", 3)) {
d1835 1
a1835 1
		if (abbrev(argv[n], "-reverse", 2)
d2916 2
a2917 1
    TRACE(("set_owner(%s, uid=%d, gid=%d, mode=%#o\n", device, uid, gid, mode));
d2945 1
a2945 1
		       sb.st_uid, sb.st_gid, sb.st_mode));
d3496 1
a3496 1
			    (void) close(cp_pipe[1]);
d3502 1
a3502 1
			    (void) close(pc_pipe[0]);
d3510 2
a3511 1
		    close(screen->respond);
d3519 1
a3519 1
		    (void) setsid();
d3521 1
a3521 1
		    (void) setpgrp();
d3548 1
a3548 1
			(void) revoke(ttydev);
d3837 1
a3837 1
		    (void) close(fd);
d3917 1
a3917 1
		(void) close(0);
d3922 2
a3923 2
		(void) close(1);
		(void) close(2);
d3930 1
a3930 1
			(void) close(i);
d4037 1
a4037 1
		       utret->ut_pid, utret->ut_type, utret->ut_user,
d4206 1
a4206 1
		(void) write(cp_pipe[1], (char *) &handshake, sizeof(handshake));
d4212 1
a4212 1
	    (void) setgid(screen->gid);
d4428 1
a4428 1
	    (void) sleep(5);
d4466 1
a4466 1
		    (void) close(screen->respond);
@


1.13
log
@Update to xterm 250
@
text
@d1 1
a1 1
/* $XTermId: main.c,v 1.597 2009/10/12 21:58:27 tom Exp $ */
d18 1
a18 1
Copyright 2002-2008,2009 by Thomas E. Dickey
d460 1
a460 1
static void resize_termcap(XtermWidget xw, char *newtc);
d896 1
a896 1
static char *fallback_resources[] =
d915 7
a921 7
{"-geometry",	"*vt100.geometry",XrmoptionSepArg,	(caddr_t) NULL},
{"-132",	"*c132",	XrmoptionNoArg,		(caddr_t) "on"},
{"+132",	"*c132",	XrmoptionNoArg,		(caddr_t) "off"},
{"-ah",		"*alwaysHighlight", XrmoptionNoArg,	(caddr_t) "on"},
{"+ah",		"*alwaysHighlight", XrmoptionNoArg,	(caddr_t) "off"},
{"-aw",		"*autoWrap",	XrmoptionNoArg,		(caddr_t) "on"},
{"+aw",		"*autoWrap",	XrmoptionNoArg,		(caddr_t) "off"},
d923 2
a924 2
{"-ai",		"*activeIcon",	XrmoptionNoArg,		(caddr_t) "off"},
{"+ai",		"*activeIcon",	XrmoptionNoArg,		(caddr_t) "on"},
d926 24
a949 24
{"-b",		"*internalBorder",XrmoptionSepArg,	(caddr_t) NULL},
{"-bc",		"*cursorBlink",	XrmoptionNoArg,		(caddr_t) "on"},
{"+bc",		"*cursorBlink",	XrmoptionNoArg,		(caddr_t) "off"},
{"-bcf",	"*cursorOffTime",XrmoptionSepArg,	(caddr_t) NULL},
{"-bcn",	"*cursorOnTime",XrmoptionSepArg,	(caddr_t) NULL},
{"-bdc",	"*colorBDMode",	XrmoptionNoArg,		(caddr_t) "off"},
{"+bdc",	"*colorBDMode",	XrmoptionNoArg,		(caddr_t) "on"},
{"-cb",		"*cutToBeginningOfLine", XrmoptionNoArg, (caddr_t) "off"},
{"+cb",		"*cutToBeginningOfLine", XrmoptionNoArg, (caddr_t) "on"},
{"-cc",		"*charClass",	XrmoptionSepArg,	(caddr_t) NULL},
{"-cm",		"*colorMode",	XrmoptionNoArg,		(caddr_t) "off"},
{"+cm",		"*colorMode",	XrmoptionNoArg,		(caddr_t) "on"},
{"-cn",		"*cutNewline",	XrmoptionNoArg,		(caddr_t) "off"},
{"+cn",		"*cutNewline",	XrmoptionNoArg,		(caddr_t) "on"},
{"-cr",		"*cursorColor",	XrmoptionSepArg,	(caddr_t) NULL},
{"-cu",		"*curses",	XrmoptionNoArg,		(caddr_t) "on"},
{"+cu",		"*curses",	XrmoptionNoArg,		(caddr_t) "off"},
{"-dc",		"*dynamicColors",XrmoptionNoArg,	(caddr_t) "off"},
{"+dc",		"*dynamicColors",XrmoptionNoArg,	(caddr_t) "on"},
{"-fb",		"*boldFont",	XrmoptionSepArg,	(caddr_t) NULL},
{"-fbb",	"*freeBoldBox", XrmoptionNoArg,		(caddr_t)"off"},
{"+fbb",	"*freeBoldBox", XrmoptionNoArg,		(caddr_t)"on"},
{"-fbx",	"*forceBoxChars", XrmoptionNoArg,	(caddr_t)"off"},
{"+fbx",	"*forceBoxChars", XrmoptionNoArg,	(caddr_t)"on"},
d951 1
a951 1
{"-fi",		"*iconFont",	XrmoptionSepArg,	(caddr_t) NULL},
d954 3
a956 3
{"-fa",		"*faceName",	XrmoptionSepArg,	(caddr_t) NULL},
{"-fd",		"*faceNameDoublesize", XrmoptionSepArg,	(caddr_t) NULL},
{"-fs",		"*faceSize",	XrmoptionSepArg,	(caddr_t) NULL},
d959 2
a960 2
{"-fw",		"*wideFont",	XrmoptionSepArg,	(caddr_t) NULL},
{"-fwb",	"*wideBoldFont", XrmoptionSepArg,	(caddr_t) NULL},
d963 1
a963 1
{"-fx",		"*ximFont",	XrmoptionSepArg,	(caddr_t) NULL},
d966 5
a970 5
{"-hc",		"*highlightColor", XrmoptionSepArg,	(caddr_t) NULL},
{"-hm",		"*highlightColorMode", XrmoptionNoArg,	(caddr_t) "on"},
{"+hm",		"*highlightColorMode", XrmoptionNoArg,	(caddr_t) "off"},
{"-selfg",	"*highlightTextColor", XrmoptionSepArg,	(caddr_t) NULL},
{"-selbg",	"*highlightColor", XrmoptionSepArg,	(caddr_t) NULL},
d973 2
a974 2
{"-hf",		"*hpFunctionKeys",XrmoptionNoArg,	(caddr_t) "on"},
{"+hf",		"*hpFunctionKeys",XrmoptionNoArg,	(caddr_t) "off"},
d976 2
a977 2
{"-hold",	"*hold",	XrmoptionNoArg,		(caddr_t) "on"},
{"+hold",	"*hold",	XrmoptionNoArg,		(caddr_t) "off"},
d979 2
a980 2
{"-ie",		"*ptyInitialErase", XrmoptionNoArg,	(caddr_t) "on"},
{"+ie",		"*ptyInitialErase", XrmoptionNoArg,	(caddr_t) "off"},
d982 2
a983 2
{"-j",		"*jumpScroll",	XrmoptionNoArg,		(caddr_t) "on"},
{"+j",		"*jumpScroll",	XrmoptionNoArg,		(caddr_t) "off"},
d985 2
a986 2
{"-k8",		"*allowC1Printable", XrmoptionNoArg,	(caddr_t) "on"},
{"+k8",		"*allowC1Printable", XrmoptionNoArg,	(caddr_t) "off"},
d988 2
a989 2
{"-kt",		"*keyboardType", XrmoptionSepArg,	(caddr_t) NULL},
{"+kt",		"*keyboardType", XrmoptionSepArg,	(caddr_t) NULL},
d991 22
a1012 22
{"-l",		"*logging",	XrmoptionNoArg,		(caddr_t) "on"},
{"+l",		"*logging",	XrmoptionNoArg,		(caddr_t) "off"},
{"-lf",		"*logFile",	XrmoptionSepArg,	(caddr_t) NULL},
{"-ls",		"*loginShell",	XrmoptionNoArg,		(caddr_t) "on"},
{"+ls",		"*loginShell",	XrmoptionNoArg,		(caddr_t) "off"},
{"-mb",		"*marginBell",	XrmoptionNoArg,		(caddr_t) "on"},
{"+mb",		"*marginBell",	XrmoptionNoArg,		(caddr_t) "off"},
{"-mc",		"*multiClickTime", XrmoptionSepArg,	(caddr_t) NULL},
{"-mesg",	"*messages",	XrmoptionNoArg,		(caddr_t) "off"},
{"+mesg",	"*messages",	XrmoptionNoArg,		(caddr_t) "on"},
{"-ms",		"*pointerColor",XrmoptionSepArg,	(caddr_t) NULL},
{"-nb",		"*nMarginBell",	XrmoptionSepArg,	(caddr_t) NULL},
{"-nul",	"*underLine",	XrmoptionNoArg,		(caddr_t) "off"},
{"+nul",	"*underLine",	XrmoptionNoArg,		(caddr_t) "on"},
{"-pc",		"*boldColors",	XrmoptionNoArg,		(caddr_t) "on"},
{"+pc",		"*boldColors",	XrmoptionNoArg,		(caddr_t) "off"},
{"-rw",		"*reverseWrap",	XrmoptionNoArg,		(caddr_t) "on"},
{"+rw",		"*reverseWrap",	XrmoptionNoArg,		(caddr_t) "off"},
{"-s",		"*multiScroll",	XrmoptionNoArg,		(caddr_t) "on"},
{"+s",		"*multiScroll",	XrmoptionNoArg,		(caddr_t) "off"},
{"-sb",		"*scrollBar",	XrmoptionNoArg,		(caddr_t) "on"},
{"+sb",		"*scrollBar",	XrmoptionNoArg,		(caddr_t) "off"},
d1014 2
a1015 2
{"-leftbar",	"*rightScrollBar", XrmoptionNoArg,	(caddr_t) "off"},
{"-rightbar",	"*rightScrollBar", XrmoptionNoArg,	(caddr_t) "on"},
d1017 9
a1025 9
{"-rvc",	"*colorRVMode",	XrmoptionNoArg,		(caddr_t) "off"},
{"+rvc",	"*colorRVMode",	XrmoptionNoArg,		(caddr_t) "on"},
{"-sf",		"*sunFunctionKeys", XrmoptionNoArg,	(caddr_t) "on"},
{"+sf",		"*sunFunctionKeys", XrmoptionNoArg,	(caddr_t) "off"},
{"-si",		"*scrollTtyOutput", XrmoptionNoArg,	(caddr_t) "off"},
{"+si",		"*scrollTtyOutput", XrmoptionNoArg,	(caddr_t) "on"},
{"-sk",		"*scrollKey",	XrmoptionNoArg,		(caddr_t) "on"},
{"+sk",		"*scrollKey",	XrmoptionNoArg,		(caddr_t) "off"},
{"-sl",		"*saveLines",	XrmoptionSepArg,	(caddr_t) NULL},
d1027 2
a1028 2
{"-sp",		"*sunKeyboard", XrmoptionNoArg,		(caddr_t) "on"},
{"+sp",		"*sunKeyboard", XrmoptionNoArg,		(caddr_t) "off"},
d1031 2
a1032 2
{"-t",		"*tekStartup",	XrmoptionNoArg,		(caddr_t) "on"},
{"+t",		"*tekStartup",	XrmoptionNoArg,		(caddr_t) "off"},
d1034 3
a1036 3
{"-ti",		"*decTerminalID",XrmoptionSepArg,	(caddr_t) NULL},
{"-tm",		"*ttyModes",	XrmoptionSepArg,	(caddr_t) NULL},
{"-tn",		"*termName",	XrmoptionSepArg,	(caddr_t) NULL},
d1038 2
a1039 2
{"-u8",		"*utf8",	XrmoptionNoArg,		(caddr_t) "2"},
{"+u8",		"*utf8",	XrmoptionNoArg,		(caddr_t) "0"},
d1042 19
a1060 19
{"-lc",		"*locale",	XrmoptionNoArg,		(caddr_t) "on"},
{"+lc",		"*locale",	XrmoptionNoArg,		(caddr_t) "off"},
{"-lcc",	"*localeFilter",XrmoptionSepArg,	(caddr_t) NULL},
{"-en",		"*locale",	XrmoptionSepArg,	(caddr_t) NULL},
#endif
{"-uc",		"*cursorUnderLine", XrmoptionNoArg,	(caddr_t) "on"},
{"+uc",		"*cursorUnderLine", XrmoptionNoArg,	(caddr_t) "off"},
{"-ulc",	"*colorULMode",	XrmoptionNoArg,		(caddr_t) "off"},
{"+ulc",	"*colorULMode",	XrmoptionNoArg,		(caddr_t) "on"},
{"-ulit",       "*italicULMode", XrmoptionNoArg,        (caddr_t) "off"},
{"+ulit",       "*italicULMode", XrmoptionNoArg,        (caddr_t) "on"},
{"-ut",		"*utmpInhibit",	XrmoptionNoArg,		(caddr_t) "on"},
{"+ut",		"*utmpInhibit",	XrmoptionNoArg,		(caddr_t) "off"},
{"-im",		"*useInsertMode", XrmoptionNoArg,	(caddr_t) "on"},
{"+im",		"*useInsertMode", XrmoptionNoArg,	(caddr_t) "off"},
{"-vb",		"*visualBell",	XrmoptionNoArg,		(caddr_t) "on"},
{"+vb",		"*visualBell",	XrmoptionNoArg,		(caddr_t) "off"},
{"-pob",	"*popOnBell",	XrmoptionNoArg,		(caddr_t) "on"},
{"+pob",	"*popOnBell",	XrmoptionNoArg,		(caddr_t) "off"},
d1062 6
a1067 6
{"-wc",		"*wideChars",	XrmoptionNoArg,		(caddr_t) "on"},
{"+wc",		"*wideChars",	XrmoptionNoArg,		(caddr_t) "off"},
{"-mk_width",	"*mkWidth",	XrmoptionNoArg,		(caddr_t) "on"},
{"+mk_width",	"*mkWidth",	XrmoptionNoArg,		(caddr_t) "off"},
{"-cjk_width",	"*cjkWidth",	XrmoptionNoArg,		(caddr_t) "on"},
{"+cjk_width",	"*cjkWidth",	XrmoptionNoArg,		(caddr_t) "off"},
d1069 2
a1070 2
{"-wf",		"*waitForMap",	XrmoptionNoArg,		(caddr_t) "on"},
{"+wf",		"*waitForMap",	XrmoptionNoArg,		(caddr_t) "off"},
d1072 1
a1072 1
{"-ziconbeep",	"*zIconBeep",	XrmoptionSepArg,	(caddr_t) NULL},
d1075 2
a1076 2
{"-samename",	"*sameName",	XrmoptionNoArg,		(caddr_t) "on"},
{"+samename",	"*sameName",	XrmoptionNoArg,		(caddr_t) "off"},
d1079 2
a1080 2
{"-sm",		"*sessionMgt",	XrmoptionNoArg,		(caddr_t) "on"},
{"+sm",		"*sessionMgt",	XrmoptionNoArg,		(caddr_t) "off"},
d1083 2
a1084 2
{"-tb",		"*"XtNtoolBar,	XrmoptionNoArg,		(caddr_t) "on"},
{"+tb",		"*"XtNtoolBar,	XrmoptionNoArg,		(caddr_t) "off"},
d1087 2
a1088 2
{"-maximized",	"*maximized",	XrmoptionNoArg,		(caddr_t) "on"},
{"+maximized",	"*maximized",	XrmoptionNoArg,		(caddr_t) "off"},
d1091 5
a1095 5
{"-help",	NULL,		XrmoptionSkipNArgs,	(caddr_t) NULL},
{"-version",	NULL,		XrmoptionSkipNArgs,	(caddr_t) NULL},
{"-class",	NULL,		XrmoptionSkipArg,	(caddr_t) NULL},
{"-e",		NULL,		XrmoptionSkipLine,	(caddr_t) NULL},
{"-into",	NULL,		XrmoptionSkipArg,	(caddr_t) NULL},
d1098 9
a1106 9
{"%",		"*tekGeometry",	XrmoptionStickyArg,	(caddr_t) NULL},
{"#",		".iconGeometry",XrmoptionStickyArg,	(caddr_t) NULL},
{"-T",		".title",	XrmoptionSepArg,	(caddr_t) NULL},
{"-n",		"*iconName",	XrmoptionSepArg,	(caddr_t) NULL},
{"-r",		"*reverseVideo",XrmoptionNoArg,		(caddr_t) "on"},
{"+r",		"*reverseVideo",XrmoptionNoArg,		(caddr_t) "off"},
{"-rv",		"*reverseVideo",XrmoptionNoArg,		(caddr_t) "on"},
{"+rv",		"*reverseVideo",XrmoptionNoArg,		(caddr_t) "off"},
{"-w",		".borderWidth", XrmoptionSepArg,	(caddr_t) NULL},
d1268 1
a1268 1
static char *message[] =
d1288 1
a1288 1
    TRACE(("...decode '%s'\n", string));
d1333 1
d1383 1
a1383 1
    char **cpp;
d1467 1
a1467 1
    } else if (term->screen.Vshow)
d2398 2
a2399 2
	   NonNull(term->screen.Tcolors[TEXT_FG].resource),
	   NonNull(term->screen.Tcolors[TEXT_BG].resource)));
d2402 4
a2405 4
	&& ((term->screen.Tcolors[TEXT_FG].resource
	     && !isDefaultForeground(term->screen.Tcolors[TEXT_FG].resource))
	    || (term->screen.Tcolors[TEXT_BG].resource
		&& !isDefaultBackground(term->screen.Tcolors[TEXT_BG].resource))
a3271 1
	newtc = TekScreenOf(tekWidget)->tcapbuf;
a3275 1
	newtc = screen->tcapbuf;
d3285 1
a3285 1
    if (!get_termcap(TermName = resource.term_name, newtc)) {
d3294 1
a3294 1
		if (get_termcap(next, newtc)) {
d3308 1
a3308 1
	resize_termcap(xw, newtc);
d3325 1
a3325 3
	static char name[] = TERMCAP_ERASE;
	char temp[1024], *p = temp;
	char *s = tgetstr(name, &p);
d3328 1
d3331 1
d3359 2
a3360 2
	ts.ws_xpixel = TFullWidth(&(tekWidget->screen));
	ts.ws_ypixel = TFullHeight(&(tekWidget->screen));
d3461 2
a3462 2
		    ts.ws_xpixel = TFullWidth(&(tekWidget->screen));
		    ts.ws_ypixel = TFullHeight(&(tekWidget->screen));
d3895 1
a3895 1
		*newtc = 0;
d4289 18
a4306 17
	    resize_termcap(xw, newtc);
	    if (xw->misc.titeInhibit && !xw->misc.tiXtraScroll) {
		remove_termcap_entry(newtc, "ti=");
		remove_termcap_entry(newtc, "te=");
	    }
	    /*
	     * work around broken termcap entries */
	    if (resource.useInsertMode) {
		remove_termcap_entry(newtc, "ic=");
		/* don't get duplicates */
		remove_termcap_entry(newtc, "im=");
		remove_termcap_entry(newtc, "ei=");
		remove_termcap_entry(newtc, "mi");
		if (*newtc)
		    strcat(newtc, ":im=\\E[4h:ei=\\E[4l:mi:");
	    }
	    if (*newtc) {
d4308 8
a4315 8
		unsigned len;
		remove_termcap_entry(newtc, TERMCAP_ERASE "=");
		len = strlen(newtc);
		if (len != 0 && newtc[len - 1] == ':')
		    len--;
		sprintf(newtc + len, ":%s=\\%03o:",
			TERMCAP_ERASE,
			CharOf(initial_erase));
d4317 2
a4318 1
		xtermSetenv("TERMCAP", newtc);
d4720 1
a4720 1
	    Display *dpy = term->screen.display;
d4750 1
a4750 1
resize_termcap(XtermWidget xw, char *newtc)
d4752 2
d4850 1
a4850 1
	if (pid == term->screen.pid) {
d4960 1
a4960 1
    struct timeval timeout =
d4965 1
a4965 1
    if (Select(fd + 1, &set, NULL, NULL, &timeout) > 0)
@


1.12
log
@update to xterm 247, a small bug fix over version 246.
@
text
@d1 1
a1 1
/* $XTermId: main.c,v 1.594 2009/08/30 21:40:45 Alex.Hornung Exp $ */
d451 1
a451 1
static SIGNAL_T reapchild(int n);
d453 1
a453 1
static void remove_termcap_entry(char *buf, char *str);
d455 1
a455 1
static int pty_search(int *pty);
d643 1
a643 1
    char *name;
d1337 1
a1337 1
abbrev(char *tst, char *cmp, size_t need)
d2309 1
a2309 1
	write(screen->respond, buf, strlen(buf));
d2719 1
a2719 1
static char *tekterm[] =
d2738 1
a2738 1
static char *vtterm[] =
d2855 3
a2857 1
	write(cp_pipe[1], (char *) &handshake, sizeof(handshake));
d2886 3
a2888 1
	    write(pc_pipe[1], (char *) &handshake, sizeof(handshake));
d3047 1
a3047 1
    char **envnew;		/* new environment */
d3287 4
a3290 2
	char *last = NULL;
	TermName = *envnew;
d3293 10
a3302 5
	    if ((last == NULL || strcmp(last, *envnew))
		&& get_termcap(*envnew, newtc)) {
		TermName = *envnew;
		ok_termcap = True;
		break;
d3326 1
d3328 1
a3328 1
	char *s = tgetstr(TERMCAP_ERASE, &p);
d3582 3
a3584 2
			write(cp_pipe[1], (char *) &handshake,
			      sizeof(handshake));
d3930 1
a3930 1
			(void) dup(ttyfd);
d4239 3
a4241 1
		(void) write(cp_pipe[1], (char *) &handshake, sizeof(handshake));
d4345 1
a4345 1
		    ptr = "/bin/sh";
d4408 1
a4408 1
		    command_to_exec_with_luit[u + 1] = "-argv0";
d4471 3
a4473 1
			write(pc_pipe[1], (char *) &handshake, sizeof(handshake));
d4479 3
a4481 1
		    write(pc_pipe[1], (char *) &handshake, sizeof(handshake));
d4863 1
a4863 1
remove_termcap_entry(char *buf, char *str)
@


1.11
log
@update to xterm 246. Has been in snapshots for some time.
@
text
@d1 1
a1 1
/* $XTermId: main.c,v 1.593 2009/08/07 23:14:47 tom Exp $ */
d383 1
a383 1
#ifdef __FreeBSD__
d2423 1
a2423 1
#if defined(__osf__) || (defined(__GLIBC__) && !defined(USE_USG_PTYS)) || defined(__FreeBSD__) || defined(__NetBSD__) || defined(__OpenBSD__) || defined(__APPLE__)
@


1.10
log
@Update to xterm 242. Tested by jsg@@.
@
text
@d1 1
a1 1
/* $XTermId: main.c,v 1.589 2009/01/24 16:08:01 tom Exp $ */
d1354 1
a1354 1
    col = 8 + strlen(ProgramName);
d1356 1
a1356 1
	int len = 3 + strlen(opt->opt);		/* space [ string ] */
d1534 1
a1534 1
	int len = strlen(leaf);
d1575 1
a1575 1
	    size_t len = leaf - option - 1;
d1816 1
a1816 1
	unsigned unique = 2;
d2245 1
a2245 1
	    c = TypeMallocN(char *, n + 3 + u);
d2248 1
a2248 1
	    memcpy(c + 2 + u, command_to_exec, (n + 1) * sizeof(char *));
d2419 1
a2419 1
	    VTRun();
d3249 1
a3249 1
	VTInit();		/* realize now so know window size for tty driver */
d4099 1
a4099 1
		    bzero((char *) &utmp, sizeof(utmp));
d4149 1
a4149 1
		bzero((char *) &lastlogx, sizeof(lastlogx));
d4165 1
a4165 1
		bzero((char *) &lastlog, size);
d4647 1
a4647 1
	    bzero((char *) &utmp, sizeof(utmp));
d4759 1
a4759 1
	strncpy(newtc, oldtc, i = ptr1 - oldtc);
d4766 1
a4766 1
	strncpy(temp, ptr1, i = ptr2 - ptr1);
@


1.9
log
@xterm 237. tested by krw@@ oga@@ and others.
@
text
@d1 1
a1 1
/* $XTermId: main.c,v 1.588 2008/09/14 15:20:31 Paul.Lampert Exp $ */
d18 1
a18 1
Copyright 2002-2007,2008 by Thomas E. Dickey
d891 3
d1086 4
d1262 3
d2409 4
@


1.8
log
@xterm-236. Tested by form@@ and simon@@.
@
text
@d1 1
a1 1
/* $XTermId: main.c,v 1.587 2008/05/26 18:25:54 Marius.Tolzmann Exp $ */
d1044 2
d1216 1
@


1.7
log
@update to xterm 234. tested by merdely@@, 'looks ok' deraadt@@.
@
text
@d1 1
a1 1
/* $XTermId: main.c,v 1.586 2008/02/28 00:28:00 Matthieu.Herrb Exp $ */
d2244 1
a2244 1
	    static char *luit[4];
d4329 1
a4329 1
	    if (command_to_exec_with_luit) {
d4369 16
@


1.6
log
@Fix initialization of vmin. This has caused script(1) to exit immediatly
when started inside an xterm that started with vmin=0 (because it had
no tty to inherit the correct value from). ok kettenis@@, krw@@, oga@@.
@
text
@d1 1
a1 1
/* $XTermId: main.c,v 1.582 2008/01/15 23:58:01 tom Exp $ */
d432 4
d543 1
a543 1
#define CKILL	 CTRL('U')	/* was '@@' */
d823 8
d4026 4
d4091 4
@


1.5
log
@Merge xterm 232.
New local change: default value for pointerMode is 0.
@
text
@a1868 4
#if defined(USE_TERMIOS) || defined(USE_POSIX_TERMIOS)	/* { */
    d_tio.c_cc[VMIN] = 1;
    d_tio.c_cc[VTIME] = 0;
#endif /* } */
d1931 4
@


1.4
log
@update to xterm 229. Tested on various architectures by aanriot@@
@
text
@d1 1
a1 1
/* $XTermId: main.c,v 1.574 2007/07/22 20:02:22 tom Exp $ */
d18 1
a18 1
Copyright 2002-2006,2007 by Thomas E. Dickey
a89 2
/* $XFree86: xc/programs/xterm/main.c,v 3.212 2006/06/20 00:42:38 dickey Exp $ */

d507 4
a510 1
/* allow use of system default characters if defined and reasonable */
d512 4
a515 1
#define CBRK 0
d518 1
a518 1
#define CDSUSP CONTROL('Y')
d521 1
a521 1
#define CEOF CONTROL('D')
d524 7
a530 1
#define CEOL 0
d533 1
a533 1
#define CFLUSH CONTROL('O')
d536 1
a536 1
#define CINTR 0177
d539 1
a539 1
#define CKILL '@@'
d542 1
a542 1
#define CLNEXT CONTROL('V')
d545 1
a545 1
#define CNUL 0
d548 1
a548 1
#define CQUIT CONTROL('\\')
d551 4
a554 1
#define CRPRNT CONTROL('R')
d557 4
a560 1
#define CSTART CONTROL('Q')
d563 1
a563 1
#define CSTOP CONTROL('S')
d566 1
a566 1
#define CSUSP CONTROL('Z')
d569 1
a569 1
#define CSWTCH 0
d572 1
a572 1
#define CWERASE CONTROL('W')
d636 1
a636 1
static int override_tty_modes = 0;
d642 1
a642 1
    Char value;
d684 65
d952 2
d1138 1
d1835 1
d1846 11
a1865 1

a1868 12

    d_tio.c_cc[VINTR] = CINTR;
    d_tio.c_cc[VQUIT] = CQUIT;
    d_tio.c_cc[VERASE] = CERASE;
    d_tio.c_cc[VKILL] = CKILL;
    d_tio.c_cc[VEOF] = CEOF;
    d_tio.c_cc[VEOL] = CNUL;
    d_tio.c_cc[VEOL2] = CNUL;
#ifdef VSWTCH
    d_tio.c_cc[VSWTCH] = CNUL;
#endif

a1869 8
    d_tio.c_cc[VSUSP] = CSUSP;
#ifdef VDSUSP
    d_tio.c_cc[VDSUSP] = CDSUSP;
#endif
    d_tio.c_cc[VREPRINT] = CRPRNT;
    d_tio.c_cc[VDISCARD] = CFLUSH;
    d_tio.c_cc[VWERASE] = CWERASE;
    d_tio.c_cc[VLNEXT] = CLNEXT;
a1916 45
    d_tio.c_cc[VINTR] = CONTROL('C');	/* '^C' */
    d_tio.c_cc[VERASE] = ANSI_DEL;	/* DEL  */
    d_tio.c_cc[VKILL] = CONTROL('U');	/* '^U' */
    d_tio.c_cc[VQUIT] = CQUIT;	/* '^\' */
    d_tio.c_cc[VEOF] = CEOF;	/* '^D' */
    d_tio.c_cc[VEOL] = CEOL;	/* '^@@' */
    d_tio.c_cc[VMIN] = 1;
    d_tio.c_cc[VTIME] = 0;
#ifdef VSWTCH
    d_tio.c_cc[VSWTCH] = CSWTCH;	/* usually '^Z' */
#endif
#ifdef VLNEXT
    d_tio.c_cc[VLNEXT] = CLNEXT;
#endif
#ifdef VWERASE
    d_tio.c_cc[VWERASE] = CWERASE;
#endif
#ifdef VREPRINT
    d_tio.c_cc[VREPRINT] = CRPRNT;
#endif
#ifdef VRPRNT
    d_tio.c_cc[VRPRNT] = CRPRNT;
#endif
#ifdef VDISCARD
    d_tio.c_cc[VDISCARD] = CFLUSH;
#endif
#ifdef VFLUSHO
    d_tio.c_cc[VFLUSHO] = CFLUSH;
#endif
#ifdef VSTOP
    d_tio.c_cc[VSTOP] = CSTOP;
#endif
#ifdef VSTART
    d_tio.c_cc[VSTART] = CSTART;
#endif
#ifdef VSUSP
    d_tio.c_cc[VSUSP] = CSUSP;
#endif
#ifdef VDSUSP
    d_tio.c_cc[VDSUSP] = CDSUSP;
#endif
#ifdef VSTATUS
    d_tio.c_cc[VSTATUS] = CSTATUS;
#endif
    /* now, try to inherit tty settings */
d1918 1
d1921 1
d1925 6
a1930 45
		d_tio.c_cc[VINTR] = deftio.c_cc[VINTR];
		d_tio.c_cc[VQUIT] = deftio.c_cc[VQUIT];
		d_tio.c_cc[VERASE] = deftio.c_cc[VERASE];
		d_tio.c_cc[VKILL] = deftio.c_cc[VKILL];
		d_tio.c_cc[VEOF] = deftio.c_cc[VEOF];
		d_tio.c_cc[VEOL] = deftio.c_cc[VEOL];
#ifdef VSWTCH
		d_tio.c_cc[VSWTCH] = deftio.c_cc[VSWTCH];
#endif
#ifdef VEOL2
		d_tio.c_cc[VEOL2] = deftio.c_cc[VEOL2];
#endif
#ifdef VLNEXT
		d_tio.c_cc[VLNEXT] = deftio.c_cc[VLNEXT];
#endif
#ifdef VWERASE
		d_tio.c_cc[VWERASE] = deftio.c_cc[VWERASE];
#endif
#ifdef VREPRINT
		d_tio.c_cc[VREPRINT] = deftio.c_cc[VREPRINT];
#endif
#ifdef VRPRNT
		d_tio.c_cc[VRPRNT] = deftio.c_cc[VRPRNT];
#endif
#ifdef VDISCARD
		d_tio.c_cc[VDISCARD] = deftio.c_cc[VDISCARD];
#endif
#ifdef VFLUSHO
		d_tio.c_cc[VFLUSHO] = deftio.c_cc[VFLUSHO];
#endif
#ifdef VSTOP
		d_tio.c_cc[VSTOP] = deftio.c_cc[VSTOP];
#endif
#ifdef VSTART
		d_tio.c_cc[VSTART] = deftio.c_cc[VSTART];
#endif
#ifdef VSUSP
		d_tio.c_cc[VSUSP] = deftio.c_cc[VSUSP];
#endif
#ifdef VDSUSP
		d_tio.c_cc[VDSUSP] = deftio.c_cc[VDSUSP];
#endif
#ifdef VSTATUS
		d_tio.c_cc[VSTATUS] = deftio.c_cc[VSTATUS];
#endif
d1943 1
a1943 21
#if defined(USE_TERMIOS) || defined(USE_POSIX_TERMIOS)	/* { */
    d_tio.c_cc[VSUSP] = CSUSP;
#ifdef VDSUSP
    d_tio.c_cc[VDSUSP] = CharOf('\000');
#endif
#ifdef VSTATUS
    d_tio.c_cc[VSTATUS] = CharOf('\377');
#endif
#ifdef VREPRINT
    d_tio.c_cc[VREPRINT] = CharOf('\377');
#endif
#ifdef VDISCARD
    d_tio.c_cc[VDISCARD] = CharOf('\377');
#endif
#ifdef VWERASE
    d_tio.c_cc[VWERASE] = CharOf('\377');
#endif
#ifdef VLNEXT
    d_tio.c_cc[VLNEXT] = CharOf('\377');
#endif
#endif /* } USE_TERMIOS */
d2011 1
a2011 1
	    override_tty_modes = 1;
d2377 1
a2377 3
	     && (x_strcasecmp(term->screen.Tcolors[TEXT_FG].resource,
			      XtDefaultForeground) != 0)
	    )
d2379 1
a2379 3
		&& (x_strcasecmp(term->screen.Tcolors[TEXT_BG].resource,
				 XtDefaultBackground) != 0)
	    )
d2973 1
d3668 11
a3678 40
#ifndef __MVS__
		/* reset EOL to default value */
		tio.c_cc[VEOL] = CEOL;	/* '^@@' */
		/* certain shells (ksh & csh) change EOF as well */
		tio.c_cc[VEOF] = CEOF;	/* '^D' */
#else
		if (tio.c_cc[VEOL] == 0)
		    tio.c_cc[VEOL] = CEOL;	/* '^@@' */
		if (tio.c_cc[VEOF] == 0)
		    tio.c_cc[VEOF] = CEOF;	/* '^D' */
#endif
#ifdef VLNEXT
		tio.c_cc[VLNEXT] = CLNEXT;
#endif
#ifdef VWERASE
		tio.c_cc[VWERASE] = CWERASE;
#endif
#ifdef VREPRINT
		tio.c_cc[VREPRINT] = CRPRNT;
#endif
#ifdef VRPRNT
		tio.c_cc[VRPRNT] = CRPRNT;
#endif
#ifdef VDISCARD
		tio.c_cc[VDISCARD] = CFLUSH;
#endif
#ifdef VFLUSHO
		tio.c_cc[VFLUSHO] = CFLUSH;
#endif
#ifdef VSTOP
		tio.c_cc[VSTOP] = CSTOP;
#endif
#ifdef VSTART
		tio.c_cc[VSTART] = CSTART;
#endif
#ifdef VSUSP
		tio.c_cc[VSUSP] = CSUSP;
#endif
#ifdef VDSUSP
		tio.c_cc[VDSUSP] = CDSUSP;
d3680 4
d3685 6
a3690 49
		    /* sysv-specific */
		    TMODE(XTTYMODE_intr, tio.c_cc[VINTR]);
		    TMODE(XTTYMODE_quit, tio.c_cc[VQUIT]);
		    TMODE(XTTYMODE_erase, tio.c_cc[VERASE]);
		    TMODE(XTTYMODE_kill, tio.c_cc[VKILL]);
		    TMODE(XTTYMODE_eof, tio.c_cc[VEOF]);
		    TMODE(XTTYMODE_eol, tio.c_cc[VEOL]);
#ifdef VSWTCH
		    TMODE(XTTYMODE_swtch, tio.c_cc[VSWTCH]);
#endif
#ifdef VSUSP
		    TMODE(XTTYMODE_susp, tio.c_cc[VSUSP]);
#endif
#ifdef VDSUSP
		    TMODE(XTTYMODE_dsusp, tio.c_cc[VDSUSP]);
#endif
#ifdef VREPRINT
		    TMODE(XTTYMODE_rprnt, tio.c_cc[VREPRINT]);
#endif
#ifdef VRPRNT
		    TMODE(XTTYMODE_rprnt, tio.c_cc[VRPRNT]);
#endif
#ifdef VDISCARD
		    TMODE(XTTYMODE_flush, tio.c_cc[VDISCARD]);
#endif
#ifdef VFLUSHO
		    TMODE(XTTYMODE_flush, tio.c_cc[VFLUSHO]);
#endif
#ifdef VWERASE
		    TMODE(XTTYMODE_weras, tio.c_cc[VWERASE]);
#endif
#ifdef VLNEXT
		    TMODE(XTTYMODE_lnext, tio.c_cc[VLNEXT]);
#endif
#ifdef VSTART
		    TMODE(XTTYMODE_start, tio.c_cc[VSTART]);
#endif
#ifdef VSTOP
		    TMODE(XTTYMODE_stop, tio.c_cc[VSTOP]);
#endif
#ifdef VSTATUS
		    TMODE(XTTYMODE_status, tio.c_cc[VSTATUS]);
#endif
#ifdef VERASE2
		    TMODE(XTTYMODE_erase2, tio.c_cc[VERASE2]);
#endif
#ifdef VEOL2
		    TMODE(XTTYMODE_eol2, tio.c_cc[VEOL2]);
#endif
@


1.3
log
@Merge xterm version 225
@
text
@d1 1
a1 1
/* $XTermId: main.c,v 1.557 2007/03/24 15:26:47 tom Exp $ */
d563 1
d568 1
d674 1
a683 1
#ifndef USE_UTEMPTER
a779 1
    Bres("waitForMap", "WaitForMap", wait_for_map, False),
d785 1
d787 1
d1323 16
d1993 1
d2007 3
d2606 1
d2762 5
a2766 4
/*
 * declared outside OPT_PTY_HANDSHAKE so HsSysError() callers can use
 */
static int cp_pipe[2];		/* this pipe is used for child to parent transfer */
a2767 2
#if OPT_PTY_HANDSHAKE
static int pc_pipe[2];		/* this pipe is used for parent to child transfer */
d2789 43
d2841 1
a2841 1
HsSysError(int pf, int error)
d2845 1
d2850 18
a2867 1
    write(pf, (char *) &handshake, sizeof(handshake));
d2874 18
a2891 10
    handshake_t handshake;
    TScreen *screen = TScreenOf(term);

    handshake.status = PTY_EXEC;
    handshake.rows = screen->max_row;
    handshake.cols = screen->max_col;
    write(pc_pipe[1], (char *) &handshake, sizeof(handshake));
    close(cp_pipe[0]);
    close(pc_pipe[1]);
    resource.wait_for_map = False;
d2898 1
a2898 1
HsSysError(int pf GCC_UNUSED, int error)
d2901 1
a2901 1
	    xterm_name, error, errno, ttydev);
a2903 6

void
first_map_occurred(void)
{
    return;
}
d2912 1
d3005 1
a3044 1
    int envsize;		/* elements in new environment */
d3081 4
d3114 3
d3426 1
a3426 1
		if (!getenv("CONSEM") && ioctl(ptyfd, I_PUSH, "consem") < 0) {
d3570 1
d3807 1
a3807 1
		    HsSysError(cp_pipe[1], ERROR_TIOCSETC);
d3811 1
a3811 1
		    HsSysError(cp_pipe[1], ERROR_TIOCLSET);
d3814 1
a3814 1
		    HsSysError(cp_pipe[1], ERROR_TIOCSETP);
d3863 1
a3863 1
		    HsSysError(cp_pipe[1], ERROR_TIOCSETP);
d3865 1
a3865 1
		    HsSysError(cp_pipe[1], ERROR_TIOCSETC);
d3867 1
a3867 1
		    HsSysError(cp_pipe[1], ERROR_TIOCSETD);
d3869 1
a3869 1
		    HsSysError(cp_pipe[1], ERROR_TIOCSLTC);
d3871 1
a3871 1
		    HsSysError(cp_pipe[1], ERROR_TIOCLSET);
d3874 1
a3874 1
		    HsSysError(cp_pipe[1], ERROR_TIOCKSET);
d3876 1
a3876 1
		    HsSysError(cp_pipe[1], ERROR_TIOCKSETC);
d3885 1
a3885 1
				xterm_name, strerror(errno));
d3891 1
a3891 1
				xterm_name, strerror(errno));
d3948 3
a3950 23
	    /* copy the environment before Setenv'ing */
	    for (i = 0; environ[i] != NULL; i++) ;
	    /* compute number of xtermSetenv() calls below */
	    envsize = 1;	/* (NULL terminating entry) */
	    envsize += 5;	/* TERM, WINDOWID, DISPLAY, _SHELL, _VERSION */
#ifdef HAVE_UTMP
	    envsize += 1;	/* LOGNAME */
#endif /* HAVE_UTMP */
#ifdef USE_SYSV_ENVVARS
	    envsize += 2;	/* COLUMNS, LINES */
#ifdef HAVE_UTMP
	    envsize += 2;	/* HOME, SHELL */
#endif /* HAVE_UTMP */
#ifdef OWN_TERMINFO_DIR
	    envsize += 1;	/* TERMINFO */
#endif
#else /* USE_SYSV_ENVVARS */
	    envsize += 1;	/* TERMCAP */
#endif /* USE_SYSV_ENVVARS */
	    envnew = TypeCallocN(char *, (unsigned) i + envsize);
	    memmove((char *) envnew, (char *) environ, i * sizeof(char *));
	    environ = envnew;
	    xtermSetenv("TERM=", TermName);
d3956 1
a3956 1
	    xtermSetenv("WINDOWID=", buf);
d3959 1
a3959 1
	    xtermSetenv("DISPLAY=", XDisplayString(screen->display));
d3961 2
a3962 1
	    xtermSetenv("XTERM_VERSION=", xtermVersion());
d4038 2
a4039 2
		     || (login_name = getenv("LOGNAME")) != NULL
		     || (login_name = getenv("USER")) != NULL)
d4058 1
a4058 1
		xtermSetenv("LOGNAME=", login_name);	/* for POSIX */
d4252 1
d4286 1
d4298 2
d4303 1
d4320 1
a4320 1
		xtermSetenv("COLUMNS=", numbuf);
d4322 1
a4322 1
		xtermSetenv("LINES=", numbuf);
d4326 4
a4329 4
		if (!getenv("HOME"))
		    xtermSetenv("HOME=", pw->pw_dir);
		if (!getenv("SHELL"))
		    xtermSetenv("SHELL=", pw->pw_shell);
d4333 1
a4333 1
	    xtermSetenv("TERMINFO=", OWN_TERMINFO_DIR);
d4363 1
a4363 1
		xtermSetenv("TERMCAP=", newtc);
a4366 1
	    /* need to reset after all the ioctl bashing we did above */
d4368 9
a4376 1
	    if (resource.ptyHandshake) {
d4379 1
a4379 1
		TRACE(("spawn SET_TTYSIZE %dx%d return %d\n",
d4388 1
a4388 1
		if (((ptr = getenv("SHELL")) == NULL || *ptr == 0) &&
d4394 1
a4394 1
		xtermSetenv("SHELL=", explicit_shname);
d4396 1
a4396 1
	    xtermSetenv("XTERM_SHELL=", ptr);
d4408 1
a4408 1
		xtermSetenv("XTERM_SHELL=",
d4414 1
a4414 1
			xterm_name, *command_to_exec_with_luit, strerror(errno));
d4416 1
a4416 1
			xterm_name);
d4420 1
a4420 1
		xtermSetenv("XTERM_SHELL=",
d4428 1
a4428 1
			xterm_name, *command_to_exec, strerror(errno));
d4453 1
a4453 1
	    fprintf(stderr, "%s: Could not exec %s: %s\n", xterm_name,
d4480 1
d4498 1
a4498 1
				xterm_name, strerror(errno));
d4500 1
d4506 1
d4528 4
d4534 1
a4534 1
			    xterm_name,
d4716 5
a4720 5
    close(screen->respond);	/* close explicitly to avoid race with slave side */
#ifdef ALLOWLOGGING
    if (screen->logging)
	CloseLog(screen);
#endif
d4723 1
d4730 11
d4757 1
d4760 3
@


1.2
log
@OpenBSD local changes
@
text
@d1 1
a1 1
/* $XTermId: main.c,v 1.522 2006/08/03 22:20:15 tom Exp $ */
d18 1
a18 1
Copyright 2002-2005,2006 by Thomas E. Dickey
d123 1
d273 2
a274 1
ttyslot()
a447 10
#ifdef __cplusplus
extern "C" {
#endif

    extern int tgetent(char *ptr, char *name);
    extern char *tgetstr(char *name, char **ptr);

#ifdef __cplusplus
}
#endif
d450 1
a450 1
static int spawn(void);
d458 1
a458 2
static void get_terminal(void);
static void resize(TScreen * s, char *oldtc, char *newtc);
d485 1
a485 1
** to 0xffffffff instead of NULL; and subsequent usage, e.g. in spawn() to
d752 1
d766 3
d868 2
d1052 2
a1053 1
{ "-hc color",             "selection background color" },
d1180 1
a1180 1
	    value = A2E(DEL);
a1223 30
/*
 * If we're linked to terminfo, tgetent() will return an empty buffer.  We
 * cannot use that to adjust the $TERMCAP variable.
 */
static Bool
get_termcap(char *name, char *buffer, char *resized)
{
    TScreen *screen = &term->screen;

    *buffer = 0;		/* initialize, in case we're using terminfo's tgetent */

    if (name != 0) {
	if (tgetent(buffer, name) == 1) {
	    TRACE(("get_termcap(%s) succeeded (%s)\n", name,
		   (*buffer
		    ? "ok:termcap, we can update $TERMCAP"
		    : "assuming this is terminfo")));
	    if (*buffer) {
		if (!TEK4014_ACTIVE(screen)) {
		    resize(screen, buffer, resized);
		}
	    }
	    return True;
	} else {
	    *buffer = 0;	/* just in case */
	}
    }
    return False;
}

d1334 1
a1334 1
	if (term->screen.Tshow)
d1559 1
a1559 1
    TRACE(("disableSetUid\n"));
d1566 3
a1568 1
#endif
d1570 1
a1570 1
#if defined(USE_UTMP_SETGID)
d1574 1
a1574 1
    TRACE(("disableSetGid\n"));
d1581 3
a1583 1
#endif /* USE_UTMP_SETGID */
d1585 2
a1586 1
#if defined(HAVE_POSIX_SAVED_IDS) && !defined(USE_UTEMPTER)
d1590 1
d1602 1
d1604 1
a1604 1
#if !defined(USE_UTMP_SETGID)
d1608 1
d1620 1
a1620 1
#endif /* !USE_UTMP_SETGID */
d1632 3
d1646 2
a1647 1
#ifdef DISABLE_SETUID
d1649 4
d1705 8
d1824 1
a1824 1
    d_tio.c_cc[VERASE] = DEL;	/* DEL  */
d1988 3
a1990 1
#if defined(HAVE_POSIX_SAVED_IDS) && !defined(USE_UTMP_SETGID) && !defined(DISABLE_SETUID)
d1992 2
d1995 1
d1998 1
a2000 2
    waiting_for_initial_map = resource.wait_for_map;

d2019 2
a2020 4
    zIconBeep = resource.zIconBeep;
    zIconBeep_flagged = False;
    if (zIconBeep > 100 || zIconBeep < -100) {
	zIconBeep = 0;		/* was 100, but I prefer to defaulting off. */
a2024 3
#if OPT_SAME_NAME
    sameName = resource.sameName;
#endif
d2153 1
a2153 1
    screen = &term->screen;
d2172 1
a2172 1
	screen->TekEmu = False;
d2174 1
a2174 1
    if (screen->TekEmu && !TekInit())
d2271 1
a2271 4
    /* open a terminal for client */
    get_terminal();

    spawn();
d2287 1
a2287 1
	sprintf(buf, "%lx\n", XtWindow(SHELL_OF(CURRENT_EMU(screen))));
d2333 1
d2379 1
a2379 1
    if ((term->misc.re_verse)
d2394 1
a2394 1
	if (screen->TekEmu)
d2456 2
a2457 2
       device we're dealing with in routine spawn().  That's the reason
       for the "if (IsPts)" statement in spawn(); we have two different
a2683 13
 * sets up X and initializes the terminal structure except for term.buf.fildes.
 */
static void
get_terminal(void)
{
    TScreen *screen = &term->screen;

    screen->arrow = make_colored_cursor(XC_left_ptr,
					T_COLOR(screen, MOUSE_FG),
					T_COLOR(screen, MOUSE_BG));
}

/*
d2791 1
a2791 1
    TScreen *screen = &term->screen;
d2799 1
a2799 1
    waiting_for_initial_map = False;
d2914 1
a2914 1
spawn(void)
d2916 1
a2916 1
    TScreen *screen = &term->screen;
d2923 1
d2927 2
a2953 2
    char termcap[TERMCAP_SIZE];
    char newtc[TERMCAP_SIZE];
a2988 3
    termcap[0] = '\0';
    newtc[0] = '\0';

d3022 1
d3150 1
a3150 1
    XtSetMappedWhenManaged(SHELL_OF(CURRENT_EMU(screen)), False);
d3155 1
a3155 1
    if (!TEK4014_ACTIVE(screen))
d3166 1
a3166 1
	XtOwnSelection(SHELL_OF(CURRENT_EMU(screen)),
d3172 1
a3172 1
    if (screen->TekEmu) {
d3174 1
a3174 1
	ptr = newtc;
d3179 1
a3179 1
	ptr = termcap;
d3188 2
a3189 1
    if (!get_termcap(TermName = resource.term_name, ptr, newtc)) {
d3192 1
d3195 1
a3195 1
		&& get_termcap(*envnew, ptr, newtc)) {
d3197 1
d3204 3
d3215 7
a3221 1
    if (!resource.ptyInitialErase) {
d3227 1
d3235 2
a3236 2
	if (initial_erase == DEL) {
	    term->keyboard.flags &= ~MODE_DECBKM;
d3238 2
a3239 2
	    term->keyboard.flags |= MODE_DECBKM;
	    term->keyboard.reset_DECBKM = 1;
d3242 1
a3242 1
	       (term->keyboard.flags & MODE_DECBKM) ? "on" : "off"));
d3244 1
a3244 1
	term->keyboard.reset_DECBKM = 2;
d3251 1
a3251 1
    if (TEK4014_ACTIVE(screen)) {
d3255 2
a3256 2
	ts.ws_xpixel = TFullWidth(screen);
	ts.ws_ypixel = TFullHeight(screen);
d3297 4
d3313 1
a3313 1
	    if (IsPts) {	/* SYSV386 supports both, which did we open? */
d3315 2
a3316 2
		int ptyfd = 0;
		char *pty_name = 0;
d3353 1
a3353 1
		if (TEK4014_ACTIVE(screen)) {
d3357 2
a3358 2
		    ts.ws_xpixel = TFullWidth(screen);
		    ts.ws_ypixel = TFullHeight(screen);
d3449 1
a3449 1
#if defined(__GNU__) && defined(TIOCSCTTY)
d3816 3
a3818 3
	     * If we're not asked to make the parent process set the
	     * terminal's erase mode, and if we had no ttyModes resource,
	     * then set the terminal's erase mode from our best guess.
d3823 1
a3823 4
		   (!resource.ptyInitialErase
		    && !override_tty_modes
		    && !ttymodelist[XTTYMODE_erase].set)
		   ? "YES" : "NO",
d3827 1
a3827 3
	    if (!resource.ptyInitialErase
		&& !override_tty_modes
		&& !ttymodelist[XTTYMODE_erase].set) {
d3880 1
a3880 1
		    ((unsigned long) XtWindow(SHELL_OF(CURRENT_EMU(screen)))));
d4063 1
a4063 1
	    if (term->misc.login_shell)
d4066 1
a4066 1
	    if (term->misc.login_shell)
d4069 1
a4069 1
	    if (term->misc.login_shell &&
d4103 1
a4103 1
		    if (term->misc.login_shell &&
d4110 1
a4110 1
		    if (term->misc.login_shell &&
d4133 1
a4133 1
	    if (term->misc.login_shell) {
d4145 1
a4145 1
	    if (term->misc.login_shell &&
d4211 1
a4211 1
		if (waiting_for_initial_map) {
d4255 2
a4256 5
	    if (!TEK4014_ACTIVE(screen) && *newtc) {
		strcpy(termcap, newtc);
		resize(screen, termcap, newtc);
	    }
	    if (term->misc.titeInhibit && !term->misc.tiXtraScroll) {
d4357 1
a4357 1
	    if (term->misc.login_shell && pw && added_utmp_entry)
d4361 1
a4361 1
		   (term->misc.login_shell ? shname_minus : shname),
d4444 1
a4444 1
	    if (!waiting_for_initial_map) {
d4503 1
a4503 1
}				/* end spawn */
d4508 1
a4508 1
    TScreen *screen = &term->screen;
d4664 1
a4664 1
resize(TScreen * screen, char *oldtc, char *newtc)
d4667 43
a4709 37
    char *ptr1, *ptr2;
    size_t i;
    int li_first = 0;
    char *temp;

    TRACE(("resize %s\n", oldtc));
    if ((ptr1 = x_strindex(oldtc, "co#")) == NULL) {
	strcat(oldtc, "co#80:");
	ptr1 = x_strindex(oldtc, "co#");
    }
    if ((ptr2 = x_strindex(oldtc, "li#")) == NULL) {
	strcat(oldtc, "li#24:");
	ptr2 = x_strindex(oldtc, "li#");
    }
    if (ptr1 > ptr2) {
	li_first++;
	temp = ptr1;
	ptr1 = ptr2;
	ptr2 = temp;
    }
    ptr1 += 3;
    ptr2 += 3;
    strncpy(newtc, oldtc, i = ptr1 - oldtc);
    temp = newtc + i;
    sprintf(temp, "%d", (li_first
			 ? MaxRows(screen)
			 : MaxCols(screen)));
    temp += strlen(temp);
    ptr1 = strchr(ptr1, ':');
    strncpy(temp, ptr1, i = ptr2 - ptr1);
    temp += i;
    sprintf(temp, "%d", (li_first
			 ? MaxCols(screen)
			 : MaxRows(screen)));
    ptr2 = strchr(ptr2, ':');
    strcat(temp, ptr2);
    TRACE(("   ==> %s\n", newtc));
d4768 1
a4768 1
		need_cleanup = TRUE;
@


1.1
log
@Initial revision
@
text
@d775 1
d778 4
@


1.1.1.1
log
@Importing xterm 216
@
text
@@


1.1.1.2
log
@import xterm 225
@
text
@d1 1
a1 1
/* $XTermId: main.c,v 1.557 2007/03/24 15:26:47 tom Exp $ */
d18 1
a18 1
Copyright 2002-2006,2007 by Thomas E. Dickey
a122 1
#include <xtermcap.h>
d272 1
a272 2
int
ttyslot(void)
d446 10
d458 1
a458 1
static int spawnXTerm(XtermWidget /* xw */ );
d466 2
a467 1
static void resize_termcap(XtermWidget xw, char *newtc);
d494 1
a494 1
** to 0xffffffff instead of NULL; and subsequent usage, e.g. in spawnXTerm() to
a760 1
    Sres("menuLocale", "MenuLocale", menuLocale, ""),
a773 3
#if OPT_TCAP_FKEYS
    Bres("tcapFunctionKeys", "TcapFunctionKeys", termcapKeys, False),
#endif
a867 2
{"-selfg",	"*highlightTextColor", XrmoptionSepArg,	(caddr_t) NULL},
{"-selbg",	"*highlightColor", XrmoptionSepArg,	(caddr_t) NULL},
d1050 1
a1050 2
{ "-selbg color",          "selection background color" },
{ "-selfg color",          "selection foreground color" },
d1177 1
a1177 1
	    value = A2E(ANSI_DEL);
d1221 30
d1361 1
a1361 1
	if (TEK4014_SHOWN(term))
d1586 1
a1586 1
    TRACE(("process %d disableSetUid\n", (int) getpid()));
d1593 1
a1593 3
#else
#define disableSetUid()		/* nothing */
#endif /* DISABLE_SETUID */
d1595 1
a1595 1
#if defined(DISABLE_SETGID) || defined(USE_UTMP_SETGID)
d1599 1
a1599 1
    TRACE(("process %d disableSetGid\n", (int) getpid()));
d1606 1
a1606 3
#else
#define disableSetGid()		/* nothing */
#endif /* DISABLE_SETGID */
d1608 1
a1608 2
#if defined(HAVE_POSIX_SAVED_IDS)
#if (!defined(USE_UTEMPTER) || !defined(DISABLE_SETGID))
a1611 1
    TRACE(("process %d setEffectiveGroup(%d)\n", (int) getpid(), (int) group));
a1622 1
#endif
d1624 1
a1624 1
#if !defined(USE_UTMP_SETGID) && (!defined(USE_UTEMPTER) || !defined(DISABLE_SETUID))
a1627 1
    TRACE(("process %d setEffectiveUser(%d)\n", (int) getpid(), (int) user));
d1639 1
a1639 1
#endif
a1650 3
#if OPT_COLOR_RES
    Bool reversed = False;
#endif
d1662 1
a1662 2
#if defined(DISABLE_SETUID) || defined(DISABLE_SETGID)
#if defined(DISABLE_SETUID)
a1663 4
#endif
#if defined(DISABLE_SETGID)
    disableSetGid();
#endif
a1715 8
#if OPT_COLOR_RES
		if (abbrev(argv[n], "-reverse", 2)
		    || !strcmp("-rv", argv[n])) {
		    reversed = True;
		} else if (!strcmp("+rv", argv[n])) {
		    reversed = False;
		}
#endif
d1827 1
a1827 1
    d_tio.c_cc[VERASE] = ANSI_DEL;	/* DEL  */
d1991 1
a1991 3
#if defined(HAVE_POSIX_SAVED_IDS) && !defined(USE_UTMP_SETGID)
#if !defined(DISABLE_SETUID) || !defined(DISABLE_SETGID)
#if !defined(DISABLE_SETUID)
a1992 2
#endif
#if !defined(DISABLE_SETGID)
a1993 1
#endif
a1995 1
#endif
d1998 2
d2018 4
a2021 2
    if (resource.zIconBeep > 100 || resource.zIconBeep < -100) {
	resource.zIconBeep = 0;	/* was 100, but I prefer to defaulting off. */
d2026 3
d2157 1
a2157 1
    screen = TScreenOf(term);
d2176 1
a2176 1
	TEK4014_ACTIVE(term) = False;
d2178 1
a2178 1
    if (TEK4014_ACTIVE(term) && !TekInit())
d2275 4
a2278 1
    spawnXTerm(term);
d2294 1
a2294 1
	sprintf(buf, "%lx\n", XtWindow(SHELL_OF(CURRENT_EMU())));
a2339 1
    TRACE(("set dabbrev erase_char %#x\n", screen->dabbrev_erase_char));
d2385 1
a2385 1
    if ((reversed && term->misc.re_verse0)
d2400 1
a2400 1
	if (TEK4014_ACTIVE(term))
d2462 2
a2463 2
       device we're dealing with in routine spawnXTerm().  That's the reason
       for the "if (IsPts)" statement in spawnXTerm(); we have two different
d2690 13
d2810 1
a2810 1
    TScreen *screen = TScreenOf(term);
d2818 1
a2818 1
    resource.wait_for_map = False;
d2933 1
a2933 1
spawnXTerm(XtermWidget xw)
d2935 1
a2935 1
    TScreen *screen = TScreenOf(xw);
a2941 1
    Bool setInitialErase;
a2944 2
    Bool ok_termcap;
    char *newtc;
d2970 2
d3007 3
a3042 1
	pw = NULL;
d3170 1
a3170 1
    XtSetMappedWhenManaged(SHELL_OF(CURRENT_EMU()), False);
d3175 1
a3175 1
    if (!TEK4014_ACTIVE(xw))
d3186 1
a3186 1
	XtOwnSelection(SHELL_OF(CURRENT_EMU()),
d3192 1
a3192 1
    if (TEK4014_ACTIVE(xw)) {
d3194 1
a3194 1
	newtc = TekScreenOf(tekWidget)->tcapbuf;
d3199 1
a3199 1
	newtc = screen->tcapbuf;
d3208 1
a3208 2
    ok_termcap = True;
    if (!get_termcap(TermName = resource.term_name, newtc)) {
a3210 1
	ok_termcap = False;
d3213 1
a3213 1
		&& get_termcap(*envnew, newtc)) {
a3214 1
		ok_termcap = True;
a3220 3
    if (ok_termcap) {
	resize_termcap(xw, newtc);
    }
d3229 1
a3229 7
    setInitialErase = False;
    if (override_tty_modes && ttymodelist[XTTYMODE_erase].set) {
	initial_erase = ttymodelist[XTTYMODE_erase].value;
	setInitialErase = True;
    } else if (resource.ptyInitialErase) {
	;
    } else if (ok_termcap) {
a3234 1
	    setInitialErase = True;
d3242 2
a3243 2
	if (initial_erase == ANSI_DEL) {
	    xw->keyboard.flags &= ~MODE_DECBKM;
d3245 2
a3246 2
	    xw->keyboard.flags |= MODE_DECBKM;
	    xw->keyboard.reset_DECBKM = 1;
d3249 1
a3249 1
	       (xw->keyboard.flags & MODE_DECBKM) ? "on" : "off"));
d3251 1
a3251 1
	xw->keyboard.reset_DECBKM = 2;
d3258 1
a3258 1
    if (TEK4014_ACTIVE(xw)) {
d3262 2
a3263 2
	ts.ws_xpixel = TFullWidth(&(tekWidget->screen));
	ts.ws_ypixel = TFullHeight(&(tekWidget->screen));
a3303 4
#ifdef USE_USG_PTYS
	    int ptyfd;
	    char *pty_name;
#endif
d3316 1
a3316 1
		if (IsPts) {	/* SYSV386 supports both, which did we open? */
d3318 2
a3319 2
		ptyfd = 0;
		pty_name = 0;
d3356 1
a3356 1
		if (TEK4014_ACTIVE(xw)) {
d3360 2
a3361 2
		    ts.ws_xpixel = TFullWidth(&(tekWidget->screen));
		    ts.ws_ypixel = TFullHeight(&(tekWidget->screen));
d3452 1
a3452 1
#if ((defined(__GLIBC__) && defined(__FreeBSD_kernel__)) || defined(__GNU__)) && defined(TIOCSCTTY)
d3819 3
a3821 3
	     * If we're not asked to let the parent process set the terminal's
	     * erase mode, or if we had the ttyModes erase resource, then set
	     * the terminal's erase mode from our best guess.
d3826 4
a3829 1
		   setInitialErase ? "YES" : "NO",
d3833 3
a3835 1
	    if (setInitialErase) {
d3888 1
a3888 1
		    ((unsigned long) XtWindow(SHELL_OF(CURRENT_EMU()))));
d4071 1
a4071 1
	    if (xw->misc.login_shell)
d4074 1
a4074 1
	    if (xw->misc.login_shell)
d4077 1
a4077 1
	    if (xw->misc.login_shell &&
d4111 1
a4111 1
		    if (xw->misc.login_shell &&
d4118 1
a4118 1
		    if (xw->misc.login_shell &&
d4141 1
a4141 1
	    if (xw->misc.login_shell) {
d4153 1
a4153 1
	    if (xw->misc.login_shell &&
d4219 1
a4219 1
		if (resource.wait_for_map) {
d4263 5
a4267 2
	    resize_termcap(xw, newtc);
	    if (xw->misc.titeInhibit && !xw->misc.tiXtraScroll) {
d4368 1
a4368 1
	    if (xw->misc.login_shell && pw && added_utmp_entry)
d4372 1
a4372 1
		   (xw->misc.login_shell ? shname_minus : shname),
d4455 1
a4455 1
	    if (!resource.wait_for_map) {
d4514 1
a4514 1
}				/* end spawnXTerm */
d4519 1
a4519 1
    TScreen *screen = TScreenOf(term);
d4675 1
a4675 1
resize_termcap(XtermWidget xw, char *newtc)
d4678 37
a4714 43
    if (!TEK4014_ACTIVE(xw) && *newtc) {
	TScreen *screen = TScreenOf(xw);
	char *ptr1, *ptr2;
	size_t i;
	int li_first = 0;
	char *temp;
	char oldtc[TERMCAP_SIZE];

	strcpy(oldtc, newtc);
	TRACE(("resize %s\n", oldtc));
	if ((ptr1 = x_strindex(oldtc, "co#")) == NULL) {
	    strcat(oldtc, "co#80:");
	    ptr1 = x_strindex(oldtc, "co#");
	}
	if ((ptr2 = x_strindex(oldtc, "li#")) == NULL) {
	    strcat(oldtc, "li#24:");
	    ptr2 = x_strindex(oldtc, "li#");
	}
	if (ptr1 > ptr2) {
	    li_first++;
	    temp = ptr1;
	    ptr1 = ptr2;
	    ptr2 = temp;
	}
	ptr1 += 3;
	ptr2 += 3;
	strncpy(newtc, oldtc, i = ptr1 - oldtc);
	temp = newtc + i;
	sprintf(temp, "%d", (li_first
			     ? MaxRows(screen)
			     : MaxCols(screen)));
	temp += strlen(temp);
	ptr1 = strchr(ptr1, ':');
	strncpy(temp, ptr1, i = ptr2 - ptr1);
	temp += i;
	sprintf(temp, "%d", (li_first
			     ? MaxCols(screen)
			     : MaxRows(screen)));
	ptr2 = strchr(ptr2, ':');
	strcat(temp, ptr2);
	TRACE(("   ==> %s\n", newtc));
	TRACE(("   new size %dx%d\n", MaxRows(screen), MaxCols(screen)));
    }
d4773 1
a4773 1
		need_cleanup = True;
@


1.1.1.3
log
@import xterm 229
@
text
@d1 1
a1 1
/* $XTermId: main.c,v 1.574 2007/07/22 20:02:22 tom Exp $ */
a562 1
#define ttyFlush(fd)          ioctl(fd, TCFLSH, 1)
a566 1
#define ttyFlush(fd)          tcflush(fd, TCOFLUSH)
a671 1
#ifndef USE_UTEMPTER
d681 1
d773 1
a778 1
    Bres("waitForMap", "WaitForMap", wait_for_map, False),
a779 1
    Bres("ptySttySize", "PtySttySize", ptySttySize, DEF_PTY_STTY_SIZE),
a1314 16

static void
icewatch(IceConn iceConn,
	 IcePointer clientData GCC_UNUSED,
	 Bool opening,
	 IcePointer * watchData GCC_UNUSED)
{
    if (opening) {
	ice_fd = IceConnectionNumber(iceConn);
	TRACE(("got IceConnectionNumber %d\n", ice_fd));
    } else {
	ice_fd = -1;
	TRACE(("reset IceConnectionNumber\n"));
    }
}

a1968 1
	IceAddConnectionWatch(icewatch, NULL);
a1981 3
#if OPT_PTY_HANDSHAKE
	resource.wait_for_map0 = resource.wait_for_map;
#endif
a2577 1
    TRACE_IDS;
d2733 5
d2739 1
a2739 5
#define NO_FDS {-1, -1}

static int cp_pipe[2] = NO_FDS;	/* this pipe is used for child to parent transfer */
static int pc_pipe[2] = NO_FDS;	/* this pipe is used for parent to child transfer */

a2760 43
#if OPT_TRACE
static void
trace_handshake(const char *tag, handshake_t * data)
{
    const char *status = "?";
    switch (data->status) {
    case PTY_BAD:
	status = "PTY_BAD";
	break;
    case PTY_FATALERROR:
	status = "PTY_FATALERROR";
	break;
    case PTY_GOOD:
	status = "PTY_GOOD";
	break;
    case PTY_NEW:
	status = "PTY_NEW";
	break;
    case PTY_NOMORE:
	status = "PTY_NOMORE";
	break;
    case UTMP_ADDED:
	status = "UTMP_ADDED";
	break;
    case UTMP_TTYSLOT:
	status = "UTMP_TTYSLOT";
	break;
    case PTY_EXEC:
	status = "PTY_EXEC";
	break;
    }
    TRACE(("handshake %s %s errno=%d, error=%d device \"%s\"\n",
	   tag,
	   status,
	   data->error,
	   data->fatal_error,
	   data->buffer));
}
#define TRACE_HANDSHAKE(tag, data) trace_handshake(tag, data)
#else
#define TRACE_HANDSHAKE(tag, data)	/* nothing */
#endif

d2770 1
a2770 1
HsSysError(int error)
a2773 1
    memset(&handshake, 0, sizeof(handshake));
d2778 1
a2778 18

    if (resource.ptyHandshake && (cp_pipe[1] >= 0)) {
	TRACE(("HsSysError errno=%d, error=%d device \"%s\"\n",
	       handshake.error,
	       handshake.fatal_error,
	       handshake.buffer));
	TRACE_HANDSHAKE("writing", &handshake);
	write(cp_pipe[1], (char *) &handshake, sizeof(handshake));
    } else {
	fprintf(stderr,
		"%s: fatal pty error errno=%d, error=%d device \"%s\"\n",
		ProgramName,
		handshake.error,
		handshake.fatal_error,
		handshake.buffer);
	fprintf(stderr, "%s\n", SysErrorMsg(handshake.error));
	fprintf(stderr, "Reason: %s\n", SysReasonMsg(handshake.fatal_error));
    }
d2785 10
a2794 18
    if (resource.wait_for_map) {
	handshake_t handshake;
	TScreen *screen = TScreenOf(term);

	memset(&handshake, 0, sizeof(handshake));
	handshake.status = PTY_EXEC;
	handshake.rows = screen->max_row;
	handshake.cols = screen->max_col;

	if (pc_pipe[1] >= 0) {
	    TRACE(("first_map_occurred: %dx%d\n", handshake.rows, handshake.cols));
	    TRACE_HANDSHAKE("writing", &handshake);
	    write(pc_pipe[1], (char *) &handshake, sizeof(handshake));
	    close(cp_pipe[0]);
	    close(pc_pipe[1]);
	}
	resource.wait_for_map = False;
    }
d2801 1
a2801 1
HsSysError(int error)
d2804 1
a2804 1
	    ProgramName, error, errno, ttydev);
d2807 6
a2820 1
    TRACE_IDS;
a2912 1
    Bool got_handshake_size = False;
d2952 1
a2988 4
#if OPT_PTY_HANDSHAKE
    memset(&handshake, 0, sizeof(handshake));
#endif

a3017 3
#if OPT_PTY_HANDSHAKE
	got_handshake_size = False;
#endif /* OPT_PTY_HANDSHAKE */
d3327 1
a3327 1
		if (!x_getenv("CONSEM") && ioctl(ptyfd, I_PUSH, "consem") < 0) {
a3470 1
			TRACE_HANDSHAKE("writing", &handshake);
d3707 1
a3707 1
		    HsSysError(ERROR_TIOCSETC);
d3711 1
a3711 1
		    HsSysError(ERROR_TIOCLSET);
d3714 1
a3714 1
		    HsSysError(ERROR_TIOCSETP);
d3763 1
a3763 1
		    HsSysError(ERROR_TIOCSETP);
d3765 1
a3765 1
		    HsSysError(ERROR_TIOCSETC);
d3767 1
a3767 1
		    HsSysError(ERROR_TIOCSETD);
d3769 1
a3769 1
		    HsSysError(ERROR_TIOCSLTC);
d3771 1
a3771 1
		    HsSysError(ERROR_TIOCLSET);
d3774 1
a3774 1
		    HsSysError(ERROR_TIOCKSET);
d3776 1
a3776 1
		    HsSysError(ERROR_TIOCKSETC);
d3785 1
a3785 1
				ProgramName, strerror(errno));
d3791 1
a3791 1
				ProgramName, strerror(errno));
d3848 23
a3870 3
	    xtermCopyEnv(environ);

	    xtermSetenv("TERM", TermName);
d3876 1
a3876 1
	    xtermSetenv("WINDOWID", buf);
d3879 1
a3879 1
	    xtermSetenv("DISPLAY", XDisplayString(screen->display));
d3881 1
a3881 2
	    xtermSetenv("XTERM_VERSION", xtermVersion());
	    xtermSetenv("XTERM_LOCALE", xtermEnvLocale());
d3957 2
a3958 2
		     || (login_name = x_getenv("LOGNAME")) != NULL
		     || (login_name = x_getenv("USER")) != NULL)
d3977 1
a3977 1
		xtermSetenv("LOGNAME", login_name);	/* for POSIX */
a4170 1
		TRACE_HANDSHAKE("writing", &handshake);
a4203 1
		TRACE_HANDSHAKE("writing", &handshake);
a4214 2
			TRACE(("handshake ttysize: %dx%d\n",
			       handshake.rows, handshake.cols));
a4217 1
			got_handshake_size = True;
d4234 1
a4234 1
		xtermSetenv("COLUMNS", numbuf);
d4236 1
a4236 1
		xtermSetenv("LINES", numbuf);
d4240 4
a4243 4
		if (!x_getenv("HOME"))
		    xtermSetenv("HOME", pw->pw_dir);
		if (!x_getenv("SHELL"))
		    xtermSetenv("SHELL", pw->pw_shell);
d4247 1
a4247 1
	    xtermSetenv("TERMINFO", OWN_TERMINFO_DIR);
d4277 1
a4277 1
		xtermSetenv("TERMCAP", newtc);
d4281 1
d4283 1
a4283 9
	    /*
	     * Need to reset after all the ioctl bashing we did above.
	     *
	     * If we expect the waitForMap logic to set the handshake-size,
	     * use that to prevent races.
	     */
	    if (resource.ptyHandshake
		&& resource.ptySttySize
		&& (got_handshake_size || !resource.wait_for_map0)) {
d4286 1
a4286 1
		TRACE(("ptyHandshake SET_TTYSIZE %dx%d return %d\n",
d4295 1
a4295 1
		if (((ptr = x_getenv("SHELL")) == NULL) &&
d4301 1
a4301 1
		xtermSetenv("SHELL", explicit_shname);
d4303 1
a4303 1
	    xtermSetenv("XTERM_SHELL", ptr);
d4315 1
a4315 1
		xtermSetenv("XTERM_SHELL",
d4321 1
a4321 1
			ProgramName, *command_to_exec_with_luit, strerror(errno));
d4323 1
a4323 1
			ProgramName);
d4327 1
a4327 1
		xtermSetenv("XTERM_SHELL",
d4335 1
a4335 1
			ProgramName, *command_to_exec, strerror(errno));
d4360 1
a4360 1
	    fprintf(stderr, "%s: Could not exec %s: %s\n", ProgramName,
a4386 1
		TRACE_HANDSHAKE("read", &handshake);
d4404 1
a4404 1
				ProgramName, strerror(errno));
a4405 1
			TRACE_HANDSHAKE("writing", &handshake);
a4410 1
		    TRACE_HANDSHAKE("writing", &handshake);
a4431 4
		case PTY_NEW:
		case PTY_NOMORE:
		case UTMP_TTYSLOT:
		case PTY_EXEC:
d4434 1
a4434 1
			    ProgramName,
d4616 5
a4620 5
    /*
     * Flush pending data before releasing ownership, so nobody else can write
     * in the middle of the data.
     */
    ttyFlush(screen->respond);
a4622 1
	TRACE_IDS;
a4628 11

    /*
     * Close after releasing ownership to avoid race condition: other programs 
     * grabbing it, and *then* having us release ownership....
     */
    close(screen->respond);	/* close explicitly to avoid race with slave side */
#ifdef ALLOWLOGGING
    if (screen->logging)
	CloseLog(screen);
#endif

a4644 1
	    /* XrmSetDatabase(dpy, 0); increases leaks ;-) */
a4646 3
#if OPT_SESSION_MGT
	    IceRemoveConnectionWatch(icewatch, NULL);
#endif
@


1.1.1.4
log
@Import xterm version 232. tested by many.
@
text
@d1 1
a1 1
/* $XTermId: main.c,v 1.582 2008/01/15 23:58:01 tom Exp $ */
d18 1
a18 1
Copyright 2002-2007,2008 by Thomas E. Dickey
d90 2
d509 1
a509 4
/*
 * Allow use of system default characters if defined and reasonable.
 * These are based on the BSD ttydefaults.h
 */
d511 1
a511 4
#define CBRK     0xff		/* was 0 */
#endif
#ifndef CDISCARD
#define CDISCARD CONTROL('O')
d514 1
a514 1
#define CDSUSP   CONTROL('Y')
d517 1
a517 1
#define CEOF     CONTROL('D')
d520 1
a520 7
#define CEOL	 0xff		/* was 0 */
#endif
#ifndef CERASE
#define CERASE   0177
#endif
#ifndef CERASE2
#define	CERASE2  CONTROL('H')
d523 1
a523 1
#define CFLUSH   CONTROL('O')
d526 1
a526 1
#define CINTR    CONTROL('C')
d529 1
a529 1
#define CKILL	 CTRL('U')	/* was '@@' */
d532 1
a532 1
#define CLNEXT   CONTROL('V')
d535 1
a535 1
#define CNUL     0
d538 1
a538 1
#define CQUIT    CONTROL('\\')
d541 1
a541 4
#define CRPRNT   CONTROL('R')
#endif
#ifndef CREPRINT
#define CREPRINT CRPRNT
d544 1
a544 4
#define CSTART   CONTROL('Q')
#endif
#ifndef CSTATUS
#define	CSTATUS  CONTROL('T')
d547 1
a547 1
#define CSTOP    CONTROL('S')
d550 1
a550 1
#define CSUSP    CONTROL('Z')
d553 1
a553 1
#define CSWTCH   0
d556 1
a556 1
#define CWERASE  CONTROL('W')
d620 1
a620 1
static Boolean override_tty_modes = False;
d626 1
a626 1
    int value;
a667 65

#define validTtyChar(data, n) \
	    (known_ttyChars[n].sysMode >= 0 && \
	     known_ttyChars[n].sysMode < (int) XtNumber(data.c_cc))

static const struct {
    int sysMode;
    int myMode;
    int myDefault;
} known_ttyChars[] = {
#ifdef VINTR
    { VINTR,    XTTYMODE_intr,   CINTR },
#endif
#ifdef VQUIT
    { VQUIT,    XTTYMODE_quit,   CQUIT },
#endif
#ifdef VERASE
    { VERASE,   XTTYMODE_erase,  CERASE },
#endif
#ifdef VKILL
    { VKILL,    XTTYMODE_kill,   CKILL },
#endif
#ifdef VEOF
    { VEOF,     XTTYMODE_eof,    CEOF },
#endif
#ifdef VEOL
    { VEOL,     XTTYMODE_eol,    CEOL },
#endif
#ifdef VSWTCH
    { VSWTCH,   XTTYMODE_swtch,  CNUL },
#endif
#ifdef VSTART
    { VSTART,   XTTYMODE_start,  CSTART },
#endif
#ifdef VSTOP
    { VSTOP,    XTTYMODE_stop,   CSTOP },
#endif
#ifdef VSUSP
    { VSUSP,    XTTYMODE_susp,   CSUSP },
#endif
#ifdef VDSUSP
    { VDSUSP,   XTTYMODE_dsusp,  CDSUSP },
#endif
#ifdef VREPRINT
    { VREPRINT, XTTYMODE_rprnt,  CREPRINT },
#endif
#ifdef VDISCARD
    { VDISCARD, XTTYMODE_flush,  CDISCARD },
#endif
#ifdef VWERASE
    { VWERASE,  XTTYMODE_weras,  CWERASE },
#endif
#ifdef VLNEXT
    { VLNEXT,   XTTYMODE_lnext,  CLNEXT },
#endif
#ifdef VSTATUS
    { VSTATUS,  XTTYMODE_status, CSTATUS },
#endif
#ifdef VERASE2
    { VERASE2,  XTTYMODE_erase2, CERASE2 },
#endif
#ifdef VEOL2
    { VEOL2,    XTTYMODE_eol2,   CNUL },
#endif
};
a865 2
{"-hm",		"*highlightColorMode", XrmoptionNoArg,	(caddr_t) "on"},
{"+hm",		"*highlightColorMode", XrmoptionNoArg,	(caddr_t) "off"},
a1049 1
{ "-/+hm",                 "turn on/off selection-color override" },
a1745 1
    memset(&d_tio, 0, sizeof(d_tio));
a1755 11
    {
	Cardinal nn;

	/* fill in default-values */
	for (nn = 0; nn < XtNumber(known_ttyChars); ++nn) {
	    if (validTtyChar(d_tio, nn)) {
		d_tio.c_cc[known_ttyChars[nn].sysMode] =
		    known_ttyChars[nn].myDefault;
	    }
	}
    }
d1765 1
d1769 12
d1782 8
d1837 45
a1882 1
	Cardinal nn;
a1884 1
	/* try to inherit tty settings */
d1888 45
a1932 6
		for (nn = 0; nn < XtNumber(known_ttyChars); ++nn) {
		    if (validTtyChar(d_tio, nn)) {
			d_tio.c_cc[known_ttyChars[nn].sysMode] =
			    deftio.c_cc[known_ttyChars[nn].sysMode];
		    }
		}
d1945 21
a1965 1

d2033 1
a2033 1
	    override_tty_modes = True;
d2399 3
a2401 1
	     && !isDefaultForeground(term->screen.Tcolors[TEXT_FG].resource))
d2403 3
a2405 1
		&& !isDefaultBackground(term->screen.Tcolors[TEXT_BG].resource))
a2998 1
    Cardinal nn;
d3693 40
a3732 11
		for (nn = 0; nn < XtNumber(known_ttyChars); ++nn) {
		    if (validTtyChar(tio, nn)) {
			int sysMode = known_ttyChars[nn].sysMode;
#ifdef __MVS__
			if (tio.c_cc[sysMode] != 0) {
			    switch (sysMode) {
			    case VEOL:
			    case VEOF:
				continue;
			    }
			}
a3733 4
			tio.c_cc[sysMode] = known_ttyChars[nn].myDefault;
		    }
		}

d3735 49
a3783 6
		    for (nn = 0; nn < XtNumber(known_ttyChars); ++nn) {
			if (validTtyChar(tio, nn)) {
			    TMODE(known_ttyChars[nn].myMode,
				  tio.c_cc[known_ttyChars[nn].sysMode]);
			}
		    }
@


