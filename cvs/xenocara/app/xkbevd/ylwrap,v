head	1.2;
access;
symbols
	OPENBSD_6_0:1.2.0.6
	OPENBSD_6_0_BASE:1.2
	OPENBSD_5_9:1.2.0.4
	OPENBSD_5_9_BASE:1.2
	OPENBSD_5_8:1.2.0.2
	OPENBSD_5_8_BASE:1.2
	OPENBSD_5_7:1.1.0.20
	OPENBSD_5_7_BASE:1.1
	OPENBSD_5_6:1.1.0.18
	OPENBSD_5_6_BASE:1.1
	OPENBSD_5_5:1.1.0.16
	OPENBSD_5_5_BASE:1.1
	OPENBSD_5_4:1.1.0.14
	OPENBSD_5_4_BASE:1.1
	OPENBSD_5_3:1.1.0.12
	OPENBSD_5_3_BASE:1.1
	OPENBSD_5_2:1.1.0.10
	OPENBSD_5_2_BASE:1.1
	OPENBSD_5_1_BASE:1.1
	OPENBSD_5_1:1.1.0.8
	OPENBSD_5_0:1.1.0.6
	OPENBSD_5_0_BASE:1.1
	OPENBSD_4_9:1.1.0.2
	OPENBSD_4_9_BASE:1.1
	OPENBSD_4_8:1.1.0.4
	OPENBSD_4_8_BASE:1.1;
locks; strict;
comment	@# @;


1.2
date	2015.05.10.10.14.50;	author matthieu;	state Exp;
branches;
next	1.1;
commitid	Z5KfmJFfPWW2hhCy;

1.1
date	2010.03.28.13.01.26;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.2
log
@Update to xkbevd 1.1.4
@
text
@#! /bin/sh
# ylwrap - wrapper for lex/yacc invocations.

scriptversion=2012-07-14.08; # UTC

# Copyright (C) 1996-2012 Free Software Foundation, Inc.
#
# Written by Tom Tromey <tromey@@cygnus.com>.
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2, or (at your option)
# any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

# As a special exception to the GNU General Public License, if you
# distribute this file as part of a program that contains a
# configuration script generated by Autoconf, you may include it under
# the same distribution terms that you use for the rest of that program.

# This file is maintained in Automake, please report
# bugs to <bug-automake@@gnu.org> or send patches to
# <automake-patches@@gnu.org>.

get_dirname ()
{
  case $1 in
    */*|*\\*) printf '%s\n' "$1" | sed -e 's|\([\\/]\)[^\\/]*$|\1|';;
    # Otherwise,  we want the empty string (not ".").
  esac
}

# guard FILE
# ----------
# The CPP macro used to guard inclusion of FILE.
guard()
{
  printf '%s\n' "$from" \
    | sed \
        -e 'y/abcdefghijklmnopqrstuvwxyz/ABCDEFGHIJKLMNOPQRSTUVWXYZ/'\
        -e 's/[^ABCDEFGHIJKLMNOPQRSTUVWXYZ]/_/g'
}

# quote_for_sed [STRING]
# ----------------------
# Return STRING (or stdin) quoted to be used as a sed pattern.
quote_for_sed ()
{
  case $# in
    0) cat;;
    1) printf '%s\n' "$1";;
  esac \
    | sed -e 's|[][\\.*]|\\&|g'
}

case "$1" in
  '')
    echo "$0: No files given.  Try '$0 --help' for more information." 1>&2
    exit 1
    ;;
  --basedir)
    basedir=$2
    shift 2
    ;;
  -h|--h*)
    cat <<\EOF
Usage: ylwrap [--help|--version] INPUT [OUTPUT DESIRED]... -- PROGRAM [ARGS]...

Wrapper for lex/yacc invocations, renaming files as desired.

  INPUT is the input file
  OUTPUT is one file PROG generates
  DESIRED is the file we actually want instead of OUTPUT
  PROGRAM is program to run
  ARGS are passed to PROG

Any number of OUTPUT,DESIRED pairs may be used.

Report bugs to <bug-automake@@gnu.org>.
EOF
    exit $?
    ;;
  -v|--v*)
    echo "ylwrap $scriptversion"
    exit $?
    ;;
esac


# The input.
input="$1"
shift
# We'll later need for a correct munging of "#line" directives.
input_sub_rx=`get_dirname "$input" | quote_for_sed`
case "$input" in
  [\\/]* | ?:[\\/]*)
    # Absolute path; do nothing.
    ;;
  *)
    # Relative path.  Make it absolute.
    input="`pwd`/$input"
    ;;
esac
input_rx=`get_dirname "$input" | quote_for_sed`

# Since DOS filename conventions don't allow two dots,
# the DOS version of Bison writes out y_tab.c instead of y.tab.c
# and y_tab.h instead of y.tab.h. Test to see if this is the case.
y_tab_nodot=false
if test -f y_tab.c || test -f y_tab.h; then
  y_tab_nodot=true
fi

# The parser itself, the first file, is the destination of the .y.c
# rule in the Makefile.
parser=$1
# A sed program to s/FROM/TO/g for all the FROM/TO so that, for
# instance, we rename #include "y.tab.h" into #include "parse.h"
# during the conversion from y.tab.c to parse.c.
rename_sed=
while test "$#" -ne 0; do
  if test "$1" = "--"; then
    shift
    break
  fi
  from=$1
  # Handle y_tab.c and y_tab.h output by DOS
  if $y_tab_nodot; then
    case $from in
      "y.tab.c") from=y_tab.c;;
      "y.tab.h") from=y_tab.h;;
    esac
  fi
  shift
  to=$1
  shift
  rename_sed="${rename_sed}s|"`quote_for_sed "$from"`"|$to|g;"
done

# The program to run.
prog="$1"
shift
# Make any relative path in $prog absolute.
case "$prog" in
  [\\/]* | ?:[\\/]*) ;;
  *[\\/]*) prog="`pwd`/$prog" ;;
esac

# FIXME: add hostname here for parallel makes that run commands on
# other machines.  But that might take us over the 14-char limit.
dirname=ylwrap$$
do_exit="cd '`pwd`' && rm -rf $dirname > /dev/null 2>&1;"' (exit $ret); exit $ret'
trap "ret=129; $do_exit" 1
trap "ret=130; $do_exit" 2
trap "ret=141; $do_exit" 13
trap "ret=143; $do_exit" 15
mkdir $dirname || exit 1

cd $dirname

case $# in
  0) "$prog" "$input" ;;
  *) "$prog" "$@@" "$input" ;;
esac
ret=$?

if test $ret -eq 0; then
  for from in *
  do
    to=`printf '%s\n' "$from" | sed "$rename_sed"`
    if test -f "$from"; then
      # If $2 is an absolute path name, then just use that,
      # otherwise prepend '../'.
      case $to in
        [\\/]* | ?:[\\/]*) target=$to;;
        *) target="../$to";;
      esac

      # Do not overwrite unchanged header files to avoid useless
      # recompilations.  Always update the parser itself: it is the
      # destination of the .y.c rule in the Makefile.  Divert the
      # output of all other files to a temporary file so we can
      # compare them to existing versions.
      if test $from != $parser; then
        realtarget="$target"
        target=tmp-`printf '%s\n' "$target" | sed 's|.*[\\/]||g'`
      fi

      # Munge "#line" or "#" directives.  Don't let the resulting
      # debug information point at an absolute srcdir.  Use the real
      # output file name, not yy.lex.c for instance.  Adjust the
      # include guards too.
      FROM=`guard "$from"`
      TARGET=`guard "$to"`
      sed -e "/^#/!b" -e "s|$input_rx|$input_sub_rx|" -e "$rename_sed" \
          -e "s|$FROM|$TARGET|" "$from" >"$target" || ret=$?

      # Check whether files must be updated.
      if test "$from" != "$parser"; then
        if test -f "$realtarget" && cmp -s "$realtarget" "$target"; then
          echo "$to is unchanged"
          rm -f "$target"
        else
          echo "updating $to"
          mv -f "$target" "$realtarget"
        fi
      fi
    else
      # A missing file is only an error for the parser.  This is a
      # blatant hack to let us support using "yacc -d".  If -d is not
      # specified, don't fail when the header file is "missing".
      if test "$from" = "$parser"; then
        ret=1
      fi
    fi
  done
fi

# Remove the directory.
cd ..
rm -rf $dirname

exit $ret

# Local Variables:
# mode: shell-script
# sh-indentation: 2
# eval: (add-hook 'write-file-hooks 'time-stamp)
# time-stamp-start: "scriptversion="
# time-stamp-format: "%:y-%02m-%02d.%02H"
# time-stamp-time-zone: "UTC"
# time-stamp-end: "; # UTC"
# End:
@


1.1
log
@update to xkbevd 1.1.0.
@
text
@d4 1
a4 1
scriptversion=2009-04-28.21; # UTC
d6 1
a6 2
# Copyright (C) 1996, 1997, 1998, 1999, 2001, 2002, 2003, 2004, 2005,
# 2007, 2009 Free Software Foundation, Inc.
d32 31
d65 1
a65 1
    echo "$0: No files given.  Try \`$0 --help' for more information." 1>&2
d100 2
d111 1
d113 15
a127 1
pairlist=
d133 10
a142 1
  pairlist="$pairlist $1"
d144 1
d159 5
a163 1
trap "cd '`pwd`'; rm -rf $dirname > /dev/null 2>&1" 1 2 3 15
d175 3
a177 29
  set X $pairlist
  shift
  first=yes
  # Since DOS filename conventions don't allow two dots,
  # the DOS version of Bison writes out y_tab.c instead of y.tab.c
  # and y_tab.h instead of y.tab.h. Test to see if this is the case.
  y_tab_nodot="no"
  if test -f y_tab.c || test -f y_tab.h; then
    y_tab_nodot="yes"
  fi

  # The directory holding the input.
  input_dir=`echo "$input" | sed -e 's,\([\\/]\)[^\\/]*$,\1,'`
  # Quote $INPUT_DIR so we can use it in a regexp.
  # FIXME: really we should care about more than `.' and `\'.
  input_rx=`echo "$input_dir" | sed 's,\\\\,\\\\\\\\,g;s,\\.,\\\\.,g'`

  while test "$#" -ne 0; do
    from="$1"
    # Handle y_tab.c and y_tab.h output by DOS
    if test $y_tab_nodot = "yes"; then
      if test $from = "y.tab.c"; then
    	from="y_tab.c"
      else
    	if test $from = "y.tab.h"; then
    	  from="y_tab.h"
    	fi
      fi
    fi
d180 4
a183 4
      # otherwise prepend `../'.
      case "$2" in
    	[\\/]* | ?:[\\/]*) target="$2";;
    	*) target="../$2";;
d186 8
a193 9
      # We do not want to overwrite a header file if it hasn't
      # changed.  This avoid useless recompilations.  However the
      # parser itself (the first file) should always be updated,
      # because it is the destination of the .y.c rule in the
      # Makefile.  Divert the output of all other files to a temporary
      # file so we can compare them to existing versions.
      if test $first = no; then
	realtarget="$target"
	target="tmp-`echo $target | sed s/.*[\\/]//g`"
d195 17
a211 27
      # Edit out `#line' or `#' directives.
      #
      # We don't want the resulting debug information to point at
      # an absolute srcdir; it is better for it to just mention the
      # .y file with no path.
      #
      # We want to use the real output file name, not yy.lex.c for
      # instance.
      #
      # We want the include guards to be adjusted too.
      FROM=`echo "$from" | sed \
            -e 'y/abcdefghijklmnopqrstuvwxyz/ABCDEFGHIJKLMNOPQRSTUVWXYZ/'\
            -e 's/[^ABCDEFGHIJKLMNOPQRSTUVWXYZ]/_/g'`
      TARGET=`echo "$2" | sed \
            -e 'y/abcdefghijklmnopqrstuvwxyz/ABCDEFGHIJKLMNOPQRSTUVWXYZ/'\
            -e 's/[^ABCDEFGHIJKLMNOPQRSTUVWXYZ]/_/g'`

      sed -e "/^#/!b" -e "s,$input_rx,," -e "s,$from,$2," \
          -e "s,$FROM,$TARGET," "$from" >"$target" || ret=$?

      # Check whether header files must be updated.
      if test $first = no; then
	if test -f "$realtarget" && cmp -s "$realtarget" "$target"; then
	  echo "$2" is unchanged
	  rm -f "$target"
	else
          echo updating "$2"
d216 4
a219 5
      # A missing file is only an error for the first file.  This
      # is a blatant hack to let us support using "yacc -d".  If -d
      # is not specified, we don't want an error when the header
      # file is "missing".
      if test $first = yes; then
a222 3
    shift
    shift
    first=no
a223 2
else
  ret=$?
@

