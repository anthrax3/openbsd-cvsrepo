head	1.5;
access;
symbols
	OPENBSD_6_2:1.5.0.10
	OPENBSD_6_2_BASE:1.5
	OPENBSD_6_1:1.5.0.8
	OPENBSD_6_1_BASE:1.5
	OPENBSD_6_0:1.5.0.6
	OPENBSD_6_0_BASE:1.5
	OPENBSD_5_9:1.5.0.4
	OPENBSD_5_9_BASE:1.5
	OPENBSD_5_8:1.5.0.2
	OPENBSD_5_8_BASE:1.5
	OPENBSD_5_7:1.4.0.12
	OPENBSD_5_7_BASE:1.4
	OPENBSD_5_6:1.4.0.10
	OPENBSD_5_6_BASE:1.4
	OPENBSD_5_5:1.4.0.8
	OPENBSD_5_5_BASE:1.4
	OPENBSD_5_4:1.4.0.6
	OPENBSD_5_4_BASE:1.4
	OPENBSD_5_3:1.4.0.4
	OPENBSD_5_3_BASE:1.4
	OPENBSD_5_2:1.4.0.2
	OPENBSD_5_2_BASE:1.4
	OPENBSD_5_1_BASE:1.3
	OPENBSD_5_1:1.3.0.6
	OPENBSD_5_0:1.3.0.4
	OPENBSD_5_0_BASE:1.3
	OPENBSD_4_9:1.3.0.2
	OPENBSD_4_9_BASE:1.3
	OPENBSD_4_8:1.2.0.6
	OPENBSD_4_8_BASE:1.2
	OPENBSD_4_7:1.2.0.2
	OPENBSD_4_7_BASE:1.2
	OPENBSD_4_6:1.1.1.2.0.8
	OPENBSD_4_6_BASE:1.1.1.2
	OPENBSD_4_5:1.1.1.2.0.6
	OPENBSD_4_5_BASE:1.1.1.2
	OPENBSD_4_4:1.1.1.2.0.4
	OPENBSD_4_4_BASE:1.1.1.2
	OPENBSD_4_3_BASE:1.1.1.2
	OPENBSD_4_3:1.1.1.2.0.2
	v1_0_4:1.1.1.2
	OPENBSD_4_2:1.1.1.1.0.2
	OPENBSD_4_2_BASE:1.1.1.1
	v1_0_2:1.1.1.1
	xorg:1.1.1;
locks; strict;
comment	@ * @;


1.5
date	2015.05.10.09.54.49;	author matthieu;	state Exp;
branches;
next	1.4;
commitid	kBCR0kbwp7ipxM9L;

1.4
date	2012.04.07.15.24.43;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2010.10.06.05.43.08;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2009.10.10.10.33.01;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.25.20.20.22;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.11.25.20.20.22;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2007.09.12.11.09.07;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.5
log
@Update to setxkbmap 1.3.1
@
text
@/************************************************************
 Copyright (c) 1996 by Silicon Graphics Computer Systems, Inc.

 Permission to use, copy, modify, and distribute this
 software and its documentation for any purpose and without
 fee is hereby granted, provided that the above copyright
 notice appear in all copies and that both that copyright
 notice and this permission notice appear in supporting
 documentation, and that the name of Silicon Graphics not be
 used in advertising or publicity pertaining to distribution
 of the software without specific prior written permission.
 Silicon Graphics makes no representation about the suitability
 of this software for any purpose. It is provided "as is"
 without any express or implied warranty.

 SILICON GRAPHICS DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS
 SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
 AND FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT SHALL SILICON
 GRAPHICS BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL
 DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
 DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE
 OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION  WITH
 THE USE OR PERFORMANCE OF THIS SOFTWARE.

 ********************************************************/

#ifdef HAVE_CONFIG_H
#include "config.h"
#endif
#include <stdio.h>
#include <stdlib.h>
#include <locale.h>
#include <limits.h>
#include <ctype.h>
#include <X11/Xlib.h>
#include <X11/Xos.h>
#include <X11/XKBlib.h>
#include <X11/extensions/XKBfile.h>
#include <X11/extensions/XKBconfig.h>
#include <X11/extensions/XKBrules.h>

#ifndef PATH_MAX
#ifdef MAXPATHLEN
#define PATH_MAX MAXPATHLEN
#else
#define PATH_MAX 1024
#endif
#endif

#ifndef DFLT_XKB_CONFIG_ROOT
#define DFLT_XKB_CONFIG_ROOT "/usr/share/X11/xkb"
#endif
#ifndef DFLT_XKB_RULES_FILE
#define DFLT_XKB_RULES_FILE "base"
#endif
#ifndef DFLT_XKB_LAYOUT
#define DFLT_XKB_LAYOUT "us"
#endif
#ifndef DFLT_XKB_MODEL
#define DFLT_XKB_MODEL "pc105"
#endif

/* Constants to state how a value was obtained. The order of these
 * is important, the bigger the higher the priority.
 * e.g. FROM_CONFIG overrides FROM_SERVER */
enum source {
    UNDEFINED = 0,
    FROM_SERVER,          /* Retrieved from server at runtime. */
    FROM_RULES,           /* Xkb rules file. */
    FROM_CONFIG,          /* Command-line specified config file. */
    FROM_CMD_LINE,        /* Specified at the cmdline. */
    NUM_SOURCES
};

/***====================================================================***/
static Bool print = False;
static Bool query = False;
static Bool synch = False;
static int verbose = 5;

static Display *dpy;

/**
 * human-readable versions of FROM_CONFIG, FROM_SERVER, etc. Used for error
 * reporting.
 */
static const char *srcName[NUM_SOURCES] = {
    "undefined", "X server", "rules file", "config file", "command line"
};

struct setting {
    char const  *name;  /* Human-readable setting name. Used for error reporting. */
    char        *value; /* Holds the value. */
    enum source  src;   /* Holds the source. */
};

typedef struct setting setting_t;

struct settings {
    setting_t rules;     /* Rules file */
    setting_t config;    /* Config file (if used) */
    setting_t display;   /* X display name */
    setting_t locale;    /* Machine's locale */
    setting_t model;
    setting_t layout;
    setting_t variant;
    setting_t keycodes;
    setting_t types;
    setting_t compat;
    setting_t symbols;
    setting_t geometry;
    setting_t keymap;
};

typedef struct settings settings_t;

static settings_t settings = {
    { "rules file",         NULL, UNDEFINED },
    { "config file",        NULL, UNDEFINED },
    { "X display",          NULL, UNDEFINED },
    { "locale",             NULL, UNDEFINED },
    { "keyboard model",     NULL, UNDEFINED },
    { "keyboard layout",    NULL, UNDEFINED },
    { "layout variant",     NULL, UNDEFINED },
    { "keycodes",           NULL, UNDEFINED },
    { "types",              NULL, UNDEFINED },
    { "compatibility map",  NULL, UNDEFINED },
    { "symbols",            NULL, UNDEFINED },
    { "geometry",           NULL, UNDEFINED },
    { "keymap",             NULL, UNDEFINED }
};

static XkbConfigRtrnRec cfgResult;

static XkbRF_VarDefsRec rdefs;

static Bool clearOptions = False;

struct list {
    char  **item;   /* Array of items. */
    int     sz;     /* Size of array. */
    int     num;    /* Number of used elements. */
};

typedef struct list list_t;

static list_t options = { NULL, 0, 0 };

static list_t inclPath = { NULL, 0, 0 };

static XkbDescPtr xkb = NULL;

static int deviceSpec = XkbUseCoreKbd;

/***====================================================================***/

#define streq(s1,s2)    (strcmp(s1,s2)==0)
#define strpfx(s1,s2)   (strncmp(s1,s2,strlen(s2))==0)

#define MSG(s)          printf(s)
#define MSG1(s,a)       printf(s,a)
#define MSG2(s,a,b)     printf(s,a,b)
#define MSG3(s,a,b,c)   printf(s,a,b,c)

#define VMSG(l,s)        if (verbose>(l)) printf(s)
#define VMSG1(l,s,a)     if (verbose>(l)) printf(s,a)
#define VMSG2(l,s,a,b)   if (verbose>(l)) printf(s,a,b)
#define VMSG3(l,s,a,b,c) if (verbose>(l)) printf(s,a,b,c)

#define ERR(s)          fprintf(stderr,s)
#define ERR1(s,a)       fprintf(stderr,s,a)
#define ERR2(s,a,b)     fprintf(stderr,s,a,b)
#define ERR3(s,a,b,c)   fprintf(stderr,s,a,b,c)

#define OOM(ptr)        do { if ((ptr) == NULL) { ERR("Out of memory.\n"); exit(-1); } } while (0)

/***====================================================================***/

Bool addToList(list_t *list, const char *newVal);
void usage(int argc, char **argv);
void dumpNames(Bool wantRules, Bool wantCNames);
void trySetString(setting_t * setting, char *newVal, enum source src);
Bool setOptString(int *arg, int argc, char **argv, setting_t *setting, enum source src);
int parseArgs(int argc, char **argv);
Bool getDisplay(int argc, char **argv);
Bool getServerValues(void);
FILE *findFileInPath(char *name);
Bool addStringToOptions(char *opt_str, list_t *opts);
char *stringFromOptions(char *orig, list_t *newOpts);
Bool applyConfig(char *name);
XkbRF_RulesPtr tryLoadRules(char *name, char *locale, Bool wantDesc, Bool wantRules);
Bool applyRules(void);
Bool applyComponentNames(void);
void printKeymap(void);

/***====================================================================***/

/*
    If newVal is NULL or empty string, the list is cleared.
    Otherwise newVal is added to the end of the list (if it is not present in the list yet).
*/

Bool
addToList(list_t *list, const char *newVal)
{
    register int i;

    if ((!newVal) || (!newVal[0]))
    {
        list->num = 0;
        return True;
    }
    for (i = 0; i < list->num; i++)
    {
        if (streq(list->item[i], newVal))
            return True;
    }
    if ((list->item == NULL) || (list->sz < 1))
    {
        list->num = 0;
        list->sz = 4;
        list->item = (char **) calloc(list->sz, sizeof(char *));
        OOM(list->item);
    }
    else if (list->num >= list->sz)
    {
        list->sz *= 2;
        list->item = (char **) realloc(list->item, (list->sz) * sizeof(char *));
        OOM(list->item);
    }
    list->item[list->num] = strdup(newVal);
    OOM(list->item[list->num]);
    list->num += 1;
    return True;
}

/***====================================================================***/

void
usage(int argc, char **argv)
{
    MSG1(
        "Usage: %s [options] [<layout> [<variant> [<option> ... ]]]\n"
        "Options:\n"
        "  -?, -help           Print this message\n"
        "  -compat <name>      Specifies compatibility map component name\n"
        "  -config <file>      Specifies configuration file to use\n"
        "  -device <deviceid>  Specifies the device ID to use\n"
        "  -display <dpy>      Specifies display to use\n"
        "  -geometry <name>    Specifies geometry component name\n"
        "  -I <dir>            Add <dir> to list of directories to be used\n"
        "  -keycodes <name>    Specifies keycodes component name\n"
        "  -keymap <name>      Specifies name of keymap to load\n"
        "  -layout <name>      Specifies layout used to choose component names\n"
        "  -model <name>       Specifies model used to choose component names\n"
        "  -option <name>      Adds an option used to choose component names\n"
        "  -print              Print a complete xkb_keymap description and exit\n"
        "  -query              Print the current layout settings and exit\n"
        "  -rules <name>       Name of rules file to use\n"
        "  -symbols <name>     Specifies symbols component name\n"
        "  -synch              Synchronize request with X server\n"
        "  -types <name>       Specifies types component name\n"
        "  -v[erbose] [<lvl>]  Sets verbosity (1..10); higher values yield more messages\n"
        "  -version            Print the program's version number\n"
        "  -variant <name>     Specifies layout variant used to choose component names\n",
        argv[0]
    );
}

void
dumpNames(Bool wantRules, Bool wantCNames)
{
    if (wantRules)
    {
        if (settings.rules.value)
            MSG1("rules:      %s\n", settings.rules.value);
        if (settings.model.value)
            MSG1("model:      %s\n", settings.model.value);
        if (settings.layout.value)
            MSG1("layout:     %s\n", settings.layout.value);
        if (settings.variant.value)
            MSG1("variant:    %s\n", settings.variant.value);
        if (options.item)
        {
            char *opt_str = stringFromOptions(NULL, &options);
            MSG1("options:    %s\n", opt_str);
            free(opt_str);
        }
    }
    if (wantCNames)
    {
        if (settings.keymap.value)
            MSG1("keymap:     %s\n", settings.keymap.value);
        if (settings.keycodes.value)
            MSG1("keycodes:   %s\n", settings.keycodes.value);
        if (settings.types.value)
            MSG1("types:      %s\n", settings.types.value);
        if (settings.compat.value)
            MSG1("compat:     %s\n", settings.compat.value);
        if (settings.symbols.value)
            MSG1("symbols:    %s\n", settings.symbols.value);
        if (settings.geometry.value)
            MSG1("geometry:   %s\n", settings.geometry.value);
    }
    return;
}

/***====================================================================***/

/**
 * Set the given string (obtained from src) in the svValue/svSrc globals.
 * If the given item is already set, it is overridden if the original source
 * is less significant than the given one.
 *
 * @@param which What value is it (one of RULES_NDX, CONFIG_NDX, ...)
 */
void
trySetString(setting_t *setting, char *newVal, enum source src)
{
    if (setting->value != NULL)
    {
        if (setting->src == src)
        {
            VMSG2(0, "Warning! More than one %s from %s\n",
                  setting->name, srcName[src]);
            VMSG2(0, "         Using \"%s\", ignoring \"%s\"\n",
                  setting->value, newVal);
            return;
        }
        else if (setting->src > src)
        {
            VMSG1(5, "Warning! Multiple definitions of %s\n", setting->name);
            VMSG2(5, "         Using %s, ignoring %s\n",
                  srcName[setting->src], srcName[src]);
            return;
        }
    }
    setting->src = src;
    setting->value = newVal;
    return;
}

Bool
setOptString(int *arg, int argc, char **argv, setting_t *setting, enum source src)
{
    int ndx;
    char *opt;

    ndx = *arg;
    opt = argv[ndx];
    if (ndx >= argc - 1)
    {
        VMSG1(0, "No %s specified on the command line\n", setting->name);
        VMSG1(0, "Trailing %s option ignored\n", opt);
        return True;
    }
    ndx++;
    *arg = ndx;
    if (setting->value != NULL)
    {
        if (setting->src == src)
        {
            VMSG2(0, "More than one %s on %s\n", setting->name, srcName[src]);
            VMSG2(0, "Using \"%s\", ignoring \"%s\"\n", setting->value,
                  argv[ndx]);
            return True;
        }
        else if (setting->src > src)
        {
            VMSG1(5, "Multiple definitions of %s\n", setting->name);
            VMSG2(5, "Using %s, ignoring %s\n", srcName[setting->src],
                  srcName[src]);
            return True;
        }
    }
    setting->src = src;
    setting->value = argv[ndx];
    return True;
}

/***====================================================================***/

/**
 * Parse commandline arguments.
 * Return True on success or False if an unrecognized option has been
 * specified.
 */
int
parseArgs(int argc, char **argv)
{
    int i;
    Bool ok;
    unsigned present;

    ok = True;
    addToList(&inclPath, ".");
    addToList(&inclPath, DFLT_XKB_CONFIG_ROOT);
    for (i = 1; (i < argc) && ok; i++)
    {
        if (argv[i][0] != '-')
        {
            /* Allow a call like "setxkbmap us" to work. Layout is default,
               if -layout is given, then try parsing variant, then options */
            if (!settings.layout.src)
                trySetString(&settings.layout, argv[i], FROM_CMD_LINE);
            else if (!settings.variant.src)
                trySetString(&settings.variant, argv[i], FROM_CMD_LINE);
            else
                ok = addToList(&options, argv[i]);
        }
        else if (streq(argv[i], "-compat"))
            ok = setOptString(&i, argc, argv, &settings.compat, FROM_CMD_LINE);
        else if (streq(argv[i], "-config"))
            ok = setOptString(&i, argc, argv, &settings.config, FROM_CMD_LINE);
        else if (streq(argv[i], "-device"))
        {
            if ( ++i < argc ) {
                deviceSpec = atoi(argv[i]); /* only allow device IDs, not names */
            } else {
                usage(argc, argv);
                exit(-1);
            }
        }
        else if (streq(argv[i], "-display"))
            ok = setOptString(&i, argc, argv, &settings.display, FROM_CMD_LINE);
        else if (streq(argv[i], "-geometry"))
            ok = setOptString(&i, argc, argv, &settings.geometry, FROM_CMD_LINE);
        else if (streq(argv[i], "-help") || streq(argv[i], "-?"))
        {
            usage(argc, argv);
            exit(0);
        }
        else if (streq(argv[i], "-I")) /* space between -I and path */
        {
            if ( ++i < argc )
                ok = addToList(&inclPath, argv[i]);
            else
                VMSG(0, "No directory specified on the command line\n"
                     "Trailing -I option ignored\n");
        }
        else if (strpfx(argv[i], "-I")) /* no space between -I and path */
            ok = addToList(&inclPath, &argv[i][2]);
        else if (streq(argv[i], "-keycodes"))
            ok = setOptString(&i, argc, argv, &settings.keycodes, FROM_CMD_LINE);
        else if (streq(argv[i], "-keymap"))
            ok = setOptString(&i, argc, argv, &settings.keymap, FROM_CMD_LINE);
        else if (streq(argv[i], "-layout"))
            ok = setOptString(&i, argc, argv, &settings.layout, FROM_CMD_LINE);
        else if (streq(argv[i], "-model"))
            ok = setOptString(&i, argc, argv, &settings.model, FROM_CMD_LINE);
        else if (streq(argv[i], "-option"))
        {
            if ((i == argc - 1) || (argv[i + 1][0] == '\0')
                || (argv[i + 1][0] == '-'))
            {
                clearOptions = True;
                ok = addToList(&options, "");
                if (i < argc - 1 && argv[i + 1][0] == '\0')
                    i++;
            }
            else
            {
                ok = addToList(&options, argv[++i]);
            }
        }
        else if (streq(argv[i], "-print"))
            print = True;
        else if (streq(argv[i], "-query"))
            query = True;
        else if (streq(argv[i], "-rules"))
            ok = setOptString(&i, argc, argv, &settings.rules, FROM_CMD_LINE);
        else if (streq(argv[i], "-symbols"))
            ok = setOptString(&i, argc, argv, &settings.symbols, FROM_CMD_LINE);
        else if (streq(argv[i], "-synch"))
            synch = True;
        else if (streq(argv[i], "-types"))
            ok = setOptString(&i, argc, argv, &settings.types, FROM_CMD_LINE);
        else if (streq(argv[i], "-version"))
        {
            MSG1("setxkbmap %s\n", PACKAGE_VERSION);
            exit(0);
        }
        else if (streq(argv[i], "-verbose") || (streq(argv[i], "-v")))
        {
            if ((i < argc - 1) && (isdigit(argv[i + 1][0])))
                verbose = atoi(argv[++i]);
            else
                verbose++;
            if (verbose < 0)
            {
                ERR1("Illegal verbose level %d.  Reset to 0\n", verbose);
                verbose = 0;
            }
            else if (verbose > 10)
            {
                ERR1("Illegal verbose level %d.  Reset to 10\n", verbose);
                verbose = 10;
            }
            VMSG1(7, "Setting verbose level to %d\n", verbose);
        }
        else if (streq(argv[i], "-variant"))
            ok = setOptString(&i, argc, argv, &settings.variant, FROM_CMD_LINE);
        else
        {
            ERR1("Error!   Option \"%s\" not recognized\n", argv[i]);
            ok = False;
        }
    }

    present = 0;
    if (settings.types.value)
        present++;
    if (settings.compat.value)
        present++;
    if (settings.symbols.value)
        present++;
    if (settings.keycodes.value)
        present++;
    if (settings.geometry.value)
        present++;
    if (settings.config.value)
        present++;
    if (settings.model.value)
        present++;
    if (settings.layout.value)
        present++;
    if (settings.variant.value)
        present++;
    if (settings.keymap.value && present)
    {
        ERR("No other components can be specified when a keymap is present\n");
        return False;
    }
    return ok;
}

/**
 * Open a connection to the display and print error if it fails.
 *
 * @@return True on success or False otherwise.
 */
Bool
getDisplay(int argc, char **argv)
{
    int major, minor, why;

    major = XkbMajorVersion;
    minor = XkbMinorVersion;
    dpy =
        XkbOpenDisplay(settings.display.value, NULL, NULL, &major, &minor,
                       &why);
    if (!dpy)
    {
        if (settings.display.value == NULL)
            settings.display.value = getenv("DISPLAY");
        if (settings.display.value == NULL)
            settings.display.value = "default display";
        switch (why)
        {
        case XkbOD_BadLibraryVersion:
            ERR3("%s was compiled with XKB version %d.%02d\n", argv[0],
                 XkbMajorVersion, XkbMinorVersion);
            ERR2("Xlib supports incompatible version %d.%02d\n",
                 major, minor);
            break;
        case XkbOD_ConnectionRefused:
            ERR1("Cannot open display \"%s\"\n", settings.display.value);
            break;
        case XkbOD_NonXkbServer:
            ERR1("XKB extension not present on %s\n", settings.display.value);
            break;
        case XkbOD_BadServerVersion:
            ERR3("%s was compiled with XKB version %d.%02d\n", argv[0],
                 XkbMajorVersion, XkbMinorVersion);
            ERR3("Server %s uses incompatible version %d.%02d\n",
                 settings.display.value, major, minor);
            break;
        default:
            ERR1("Unknown error %d from XkbOpenDisplay\n", why);
            break;
        }
        return False;
    }
    if (synch)
        XSynchronize(dpy, True);
    return True;
}

/***====================================================================***/

/**
 * Retrieve xkb values from the XKB_RULES_NAMES property and store their
 * contents in svValues.
 * If the property cannot be read, the built-in defaults are used.
 *
 * @@return True.
 */
Bool
getServerValues(void)
{
    XkbRF_VarDefsRec vd;
    char *tmp = NULL;

    if (!XkbRF_GetNamesProp(dpy, &tmp, &vd) || !tmp)
    {
        VMSG1(3, "Couldn't interpret %s property\n", _XKB_RF_NAMES_PROP_ATOM);
        tmp = DFLT_XKB_RULES_FILE;
        vd.model = DFLT_XKB_MODEL;
        vd.layout = DFLT_XKB_LAYOUT;
        vd.variant = NULL;
        vd.options = NULL;
        VMSG3(3, "Use defaults: rules - '%s' model - '%s' layout - '%s'\n",
              tmp, vd.model, vd.layout);
    }
    if (tmp)
        trySetString(&settings.rules, tmp, FROM_SERVER);
    if (vd.model)
        trySetString(&settings.model, vd.model, FROM_SERVER);
    if (vd.layout)
        trySetString(&settings.layout, vd.layout, FROM_SERVER);
    if (vd.variant)
        trySetString(&settings.variant, vd.variant, FROM_SERVER);
    if ((vd.options) && (!clearOptions))
    {
        addStringToOptions(vd.options, &options);
        XFree(vd.options);
    }
    return True;
}

/***====================================================================***/

FILE *
findFileInPath(char *name)
{
    register int i;
    char buf[PATH_MAX];
    FILE *fp;

    if (name[0] == '/')
    {
        fp = fopen(name, "r");
        if ((verbose > 7) || ((!fp) && (verbose > 0)))
            MSG2("%s file %s\n", (fp ? "Found" : "Didn't find"), name);
        return fp;
    }
    for (i = 0; (i < inclPath.num); i++)
    {
        if (snprintf(buf, PATH_MAX, "%s/%s", inclPath.item[i], name) >=
            PATH_MAX)
        {
            VMSG2(0, "Path too long (%s/%s). Ignored.\n", inclPath.item[i],
                  name);
            continue;
        }
        fp = fopen(buf, "r");
        if ((verbose > 7) || ((!fp) && (verbose > 5)))
            MSG2("%s file %s\n", (fp ? "Found" : "Didn't find"), buf);
        if (fp != NULL)
            return fp;
    }
    return NULL;
}

/***====================================================================***/

Bool
addStringToOptions(char *opt_str, list_t *opts)
{
    char *tmp, *str, *next;
    Bool ok = True;

    str = strdup(opt_str);
    OOM(str);
    for (tmp = str; (tmp && *tmp != '\0') && ok; tmp = next)
    {
        next = strchr(str, ',');
        if (next)
        {
            *next = '\0';
            next++;
        }
        ok = addToList(opts, tmp) && ok;
    }
    free(str);
    return ok;
}

/***====================================================================***/

char *
stringFromOptions(char *orig, list_t *newOpts)
{
    size_t len;
    int i, nOut;

    if (orig)
        len = strlen(orig) + 1;
    else
        len = 0;
    for (i = 0; i < newOpts->num; i++)
    {
        if (newOpts->item[i])
            len += strlen(newOpts->item[i]) + 1;
    }
    if (len < 1)
        return NULL;
    if (orig)
    {
        orig = (char *) realloc(orig, len);
        OOM(orig);
        nOut = 1;
    }
    else
    {
        orig = (char *) calloc(len, 1);
        OOM(orig);
        nOut = 0;
    }
    for (i = 0; i < newOpts->num; i++)
    {
        if (!newOpts->item[i])
            continue;
        if (nOut > 0)
        {
            strcat(orig, ",");
            strcat(orig, newOpts->item[i]);
        }
        else
            strcpy(orig, newOpts->item[i]);
        nOut++;
    }
    return orig;
}

/***====================================================================***/

Bool
applyConfig(char *name)
{
    FILE *fp;
    Bool ok;

    if ((fp = findFileInPath(name)) == NULL)
        return False;
    ok = XkbCFParse(fp, XkbCFDflts, NULL, &cfgResult);
    fclose(fp);
    if (!ok)
    {
        ERR1("Couldn't find configuration file \"%s\"\n", name);
        return False;
    }
    if (cfgResult.rules_file)
    {
        trySetString(&settings.rules, cfgResult.rules_file, FROM_CONFIG);
        cfgResult.rules_file = NULL;
    }
    if (cfgResult.model)
    {
        trySetString(&settings.model, cfgResult.model, FROM_CONFIG);
        cfgResult.model = NULL;
    }
    if (cfgResult.layout)
    {
        trySetString(&settings.layout, cfgResult.layout, FROM_CONFIG);
        cfgResult.layout = NULL;
    }
    if (cfgResult.variant)
    {
        trySetString(&settings.variant, cfgResult.variant, FROM_CONFIG);
        cfgResult.variant = NULL;
    }
    if (cfgResult.options)
    {
        addStringToOptions(cfgResult.options, &options);
        cfgResult.options = NULL;
    }
    if (cfgResult.keymap)
    {
        trySetString(&settings.keymap, cfgResult.keymap, FROM_CONFIG);
        cfgResult.keymap = NULL;
    }
    if (cfgResult.keycodes)
    {
        trySetString(&settings.keycodes, cfgResult.keycodes, FROM_CONFIG);
        cfgResult.keycodes = NULL;
    }
    if (cfgResult.geometry)
    {
        trySetString(&settings.geometry, cfgResult.geometry, FROM_CONFIG);
        cfgResult.geometry = NULL;
    }
    if (cfgResult.symbols)
    {
        trySetString(&settings.symbols, cfgResult.symbols, FROM_CONFIG);
        cfgResult.symbols = NULL;
    }
    if (cfgResult.types)
    {
        trySetString(&settings.types, cfgResult.types, FROM_CONFIG);
        cfgResult.types = NULL;
    }
    if (cfgResult.compat)
    {
        trySetString(&settings.compat, cfgResult.compat, FROM_CONFIG);
        cfgResult.compat = NULL;
    }
    if (verbose > 5)
    {
        MSG("After config file:\n");
        dumpNames(True, True);
    }
    return True;
}

XkbRF_RulesPtr
tryLoadRules(char *name, char *locale, Bool wantDesc, Bool wantRules)
{
    XkbRF_RulesPtr rules = NULL;
    VMSG1(7, "Trying to load rules file %s...\n", name);
    rules = XkbRF_Load(name, locale, wantDesc, wantRules);
    if (rules)
    {
        VMSG(7, "Success.\n");
    }
    return rules;
}

/**
 * If any of model, layout, variant or options is specified, then compile the
 * options into the
 *
 * @@return True on success or false otherwise.
 */
Bool
applyRules(void)
{
    int i;
    char *rfName;
    XkbRF_RulesPtr rules = NULL;

    if (settings.model.src || settings.layout.src || settings.variant.src
        || options.item)
    {
        char buf[PATH_MAX];
        XkbComponentNamesRec rnames;

        if (settings.variant.src < settings.layout.src)
            settings.variant.value = NULL;

        rdefs.model = settings.model.value;
        rdefs.layout = settings.layout.value;
        rdefs.variant = settings.variant.value;
        if (options.item)
            rdefs.options =
                stringFromOptions(rdefs.options, &options);

        if (settings.rules.src)
            rfName = settings.rules.value;
        else
            rfName = DFLT_XKB_RULES_FILE;

        if (rfName[0] == '/')
        {
            rules = tryLoadRules(rfName, settings.locale.value, True, True);
        }
        else
        {
            /* try to load rules files from all include paths until the first
             * we succeed with */
            for (i = 0; (i < inclPath.num) && (!rules); i++)
            {
                if (snprintf(buf, PATH_MAX, "%s/rules/%s",
                             inclPath.item[i], rfName) >= PATH_MAX)
                {
                    VMSG2(0, "Path too long (%s/rules/%s). Ignored.\n",
                          inclPath.item[i], rfName);
                    continue;
                }
                rules = tryLoadRules(buf, settings.locale.value, True, True);
            }
        }
        if (!rules)
        {
            ERR1("Couldn't find rules file (%s) \n", rfName);
            return False;
        }
        /* Let the rules file to the magic, then update the svValues with
         * those returned after processing the rules */
        XkbRF_GetComponents(rules, &rdefs, &rnames);
        if (rnames.keycodes)
        {
            trySetString(&settings.keycodes, rnames.keycodes, FROM_RULES);
            rnames.keycodes = NULL;
        }
        if (rnames.symbols)
        {
            trySetString(&settings.symbols, rnames.symbols, FROM_RULES);
            rnames.symbols = NULL;
        }
        if (rnames.types)
        {
            trySetString(&settings.types, rnames.types, FROM_RULES);
            rnames.types = NULL;
        }
        if (rnames.compat)
        {
            trySetString(&settings.compat, rnames.compat, FROM_RULES);
            rnames.compat = NULL;
        }
        if (rnames.geometry)
        {
            trySetString(&settings.geometry, rnames.geometry, FROM_RULES);
            rnames.geometry = NULL;
        }
        if (rnames.keymap)
        {
            trySetString(&settings.keymap, rnames.keymap, FROM_RULES);
            rnames.keymap = NULL;
        }
        if (verbose > 6)
        {
            MSG1("Applied rules from %s:\n", rfName);
            dumpNames(True, False);
        }
    }
    else if (verbose > 6)
    {
        MSG("No rules variables specified.  Rules file ignored\n");
    }
    return True;
}

/* Primitive sanity check - filter out 'map names' (inside parenthesis) */
/* that can confuse xkbcomp parser */
static Bool
checkName(char *name, const char *string)
{
    char *i = name, *opar = NULL;
    Bool ret = True;

    if (!name)
        return True;

    while (*i)
    {
        if (opar == NULL)
        {
            if (*i == '(')
                opar = i;
        }
        else
        {
            if ((*i == '(') || (*i == '|') || (*i == '+'))
            {
                ret = False;
                break;
            }
            if (*i == ')')
                opar = NULL;
        }
        i++;
    }
    if (opar)
        ret = False;
    if (!ret)
    {
        char c;
        int n = 1;
        for (i = opar + 1; *i && n; i++)
        {
            if (*i == '(')
                n++;
            if (*i == ')')
                n--;
        }
        if (*i)
            i++;
        c = *i;
        *i = '\0';
        ERR1("Illegal map name '%s' ", opar);
        *i = c;
        ERR2("in %s name '%s'\n", string, name);
    }
    return ret;
}

void
printKeymap(void)
{
    MSG("xkb_keymap {\n");
    if (settings.keycodes.value)
        MSG1("\txkb_keycodes  { include \"%s\"\t};\n", settings.keycodes.value);
    if (settings.types.value)
        MSG1("\txkb_types     { include \"%s\"\t};\n", settings.types.value);
    if (settings.compat.value)
        MSG1("\txkb_compat    { include \"%s\"\t};\n", settings.compat.value);
    if (settings.symbols.value)
        MSG1("\txkb_symbols   { include \"%s\"\t};\n", settings.symbols.value);
    if (settings.geometry.value)
        MSG1("\txkb_geometry  { include \"%s\"\t};\n", settings.geometry.value);
    MSG("};\n");
}

Bool
applyComponentNames(void)
{
    if (!checkName(settings.types.value, "types"))
        return False;
    if (!checkName(settings.compat.value, "compat"))
        return False;
    if (!checkName(settings.symbols.value, "symbols"))
        return False;
    if (!checkName(settings.keycodes.value, "keycodes"))
        return False;
    if (!checkName(settings.geometry.value, "geometry"))
        return False;
    if (!checkName(settings.keymap.value, "keymap"))
        return False;

    if (verbose > 5)
    {
        MSG("Trying to build keymap using the following components:\n");
        dumpNames(False, True);
    }
    /* Upload the new description to the server. */
    if (dpy && !print && !query)
    {
        XkbComponentNamesRec cmdNames = {
            .keymap = settings.keymap.value,
            .keycodes = settings.keycodes.value,
            .types = settings.types.value,
            .compat = settings.compat.value,
            .symbols = settings.symbols.value,
            .geometry = settings.geometry.value
        };

        xkb = XkbGetKeyboardByName(dpy, deviceSpec, &cmdNames,
                                   XkbGBN_AllComponentsMask,
                                   XkbGBN_AllComponentsMask &
                                   (~XkbGBN_GeometryMask), True);
        if (!xkb)
        {
            ERR("Error loading new keyboard description\n");
            return False;
        }
        /* update the XKB root property */
        if (settings.rules.value && (rdefs.model || rdefs.layout))
        {
            if (!XkbRF_SetNamesProp(dpy, settings.rules.value, &rdefs))
            {
                VMSG(0, "Error updating the XKB names property\n");
            }
        }
    }
    if (print)
    {
        printKeymap();
    }
    if (query)
    {
        dumpNames(True, False);
    }
    return True;
}


int
main(int argc, char **argv)
{
    if ((!parseArgs(argc, argv)) || (!getDisplay(argc, argv)))
        exit(-1);
    settings.locale.value = setlocale(LC_ALL, settings.locale.value);
    settings.locale.src = FROM_SERVER;
    VMSG1(7, "locale is %s\n", settings.locale.value);
    if (dpy)
        getServerValues();
    if (settings.config.value && (!applyConfig(settings.config.value)))
        exit(-3);
    if (!applyRules())
        exit(-4);
    if (!applyComponentNames())
        exit(-5);
    if (dpy)
        XCloseDisplay(dpy);
    exit(0);
}
@


1.4
log
@Update to setxkbmap 1.3.0
@
text
@d27 3
a134 1
static XkbRF_RulesPtr rules = NULL;
d251 1
a251 1
        "  -I<dir>             Add <dir> to list of directories to be used\n"
d263 2
a264 2
        "  -v[erbose] [<lvl>]  Sets verbosity (1..10).  Higher values yield\n"
        "                      more messages\n"
d478 5
d694 2
a695 1
    int len, i, nOut;
d840 1
d1029 9
a1037 7
        XkbComponentNamesRec cmdNames;
        cmdNames.types = settings.types.value;
        cmdNames.compat = settings.compat.value;
        cmdNames.symbols = settings.symbols.value;
        cmdNames.keycodes = settings.keycodes.value;
        cmdNames.geometry = settings.geometry.value;
        cmdNames.keymap = settings.keymap.value;
@


1.3
log
@Update to setxkbmap 1.2.0
@
text
@d9 2
a10 2
 documentation, and that the name of Silicon Graphics not be 
 used in advertising or publicity pertaining to distribution 
d12 1
a12 1
 Silicon Graphics makes no representation about the suitability 
d15 3
a17 3
 
 SILICON GRAPHICS DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS 
 SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY 
d19 3
a21 3
 GRAPHICS BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL 
 DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, 
 DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE 
d48 1
a48 1
#define	DFLT_XKB_CONFIG_ROOT "/usr/share/X11/xkb"
d51 1
a51 1
#define	DFLT_XKB_RULES_FILE "xorg"
d54 1
a54 1
#define	DFLT_XKB_LAYOUT "us"
d57 1
a57 1
#define	DFLT_XKB_MODEL "pc105"
d60 1
a60 1
/* Values used in svSrc to state how a value was obtained. The order of these
d63 8
a70 22
#define	UNDEFINED	0
#define	FROM_SERVER	1       /* retrieved from server at runtime */
#define	FROM_RULES	2       /* xkb rules file */
#define	FROM_CONFIG	3       /* command-line specified config file */
#define	FROM_CMD_LINE	4       /* specified at the cmdline */
#define	NUM_SOURCES	5

/* Indices used into svSrc, svNValue */
#define	RULES_NDX	0       /* rules file */
#define	CONFIG_NDX	1       /* config file (if used) */
#define	DISPLAY_NDX	2       /* X display name */
#define	LOCALE_NDX	3       /* machine's locale */
#define	MODEL_NDX	4
#define	LAYOUT_NDX	5
#define	VARIANT_NDX	6
#define KEYCODES_NDX	7
#define	TYPES_NDX	8
#define	COMPAT_NDX	9
#define	SYMBOLS_NDX	10
#define	GEOMETRY_NDX	11
#define	KEYMAP_NDX	12
#define	NUM_STRING_VALS	13
d84 1
a84 1
static char *srcName[NUM_SOURCES] = {
d88 40
a127 9
/**
 * human-readable versions for RULES_NDX, CONFIG_NDX, etc. Used for error
 * reporting.
 */
static char *svName[NUM_STRING_VALS] = {
    "rules file", "config file", "X display", "locale",
    "keyboard model", "keyboard layout", "layout variant",
    "keycodes", "types", "compatibility map", "symbols", "geometry",
    "keymap"
a128 10
/**
 * Holds the source for each of RULES, CONFIG, DISPLAY, etc.
 * i.e. if svSrc[LAYOUT_NDX] == FROM_SERVER, then the layout has been fetched
 * from the server.
 */
static int svSrc[NUM_STRING_VALS];
/**
 * Holds the value for each of RULES, CONFIG, DISPLAY, etc.
 */
static char *svValue[NUM_STRING_VALS];
d136 12
a147 7
static int szOptions = 0;
static int numOptions = 0;
static char **options = NULL;

static int szInclPath = 0;
static int numInclPath = 0;
static char **inclPath = NULL;
d155 17
a171 2
#define	streq(s1,s2)	(strcmp(s1,s2)==0)
#define	strpfx(s1,s2)	(strncmp(s1,s2,strlen(s2))==0)
d173 1
a173 14
#define	MSG(s)		printf(s)
#define	MSG1(s,a)	printf(s,a)
#define	MSG2(s,a,b)	printf(s,a,b)
#define	MSG3(s,a,b,c)	printf(s,a,b,c)

#define	VMSG(l,s)	if (verbose>(l)) printf(s)
#define	VMSG1(l,s,a)	if (verbose>(l)) printf(s,a)
#define	VMSG2(l,s,a,b)	if (verbose>(l)) printf(s,a,b)
#define	VMSG3(l,s,a,b,c) if (verbose>(l)) printf(s,a,b,c)

#define	ERR(s)		fprintf(stderr,s)
#define	ERR1(s,a)	fprintf(stderr,s,a)
#define	ERR2(s,a,b)	fprintf(stderr,s,a,b)
#define	ERR3(s,a,b,c)	fprintf(stderr,s,a,b,c)
d177 1
a177 1
Bool addToList(int *sz, int *num, char ***listIn, char *newVal);
d180 2
a181 2
void trySetString(int which, char *newVal, int src);
Bool setOptString(int *arg, int argc, char **argv, int which, int src);
d185 3
a187 4
FILE *findFileInPath(char *name, char *subdir);
Bool addStringToOptions(char *opt_str, int *sz_opts, int *num_opts,
                        char ***opts);
char *stringFromOptions(char *orig, int numNew, char **newOpts);
d189 1
d196 5
d202 1
a202 1
addToList(int *sz, int *num, char ***listIn, char *newVal)
a204 1
    char **list;
d208 1
a208 1
        *num = 0;
d211 1
a211 2
    list = *listIn;
    for (i = 0; i < *num; i++)
d213 1
a213 1
        if (streq(list[i], newVal))
d216 1
a216 1
    if ((list == NULL) || (*sz < 1))
d218 14
a231 19
        *num = 0;
        *sz = 4;
        list = (char **) calloc(*sz, sizeof(char *));
        *listIn = list;
    }
    else if (*num >= *sz)
    {
        *sz *= 2;
        list = (char **) realloc(list, (*sz) * sizeof(char *));
        *listIn = list;
    }
    if (!list)
    {
        ERR("Internal Error! Allocation failure in add to list!\n");
        ERR("                Exiting.\n");
        exit(-1);
    }
    list[*num] = strdup(newVal);
    (*num) = (*num) + 1;
d240 26
a265 24
    MSG1("Usage: %s [args] [<layout> [<variant> [<option> ... ]]]\n",
         argv[0]);
    MSG("Where legal args are:\n");
    MSG("-?,-help            Print this message\n");
    MSG("-compat <name>      Specifies compatibility map component name\n");
    MSG("-config <file>      Specifies configuration file to use\n");
    MSG("-device <deviceid>  Specifies the device ID to use\n");
    MSG("-display <dpy>      Specifies display to use\n");
    MSG("-geometry <name>    Specifies geometry component name\n");
    MSG("-I[<dir>]           Add <dir> to list of directories to be used\n");
    MSG("-keycodes <name>    Specifies keycodes component name\n");
    MSG("-keymap <name>      Specifies name of keymap to load\n");
    MSG("-layout <name>      Specifies layout used to choose component names\n");
    MSG("-model <name>       Specifies model used to choose component names\n");
    MSG("-option <name>      Adds an option used to choose component names\n");
    MSG("-print              Print a complete xkb_keymap description and exit\n");
    MSG("-query              Print the current layout settings and exit\n");
    MSG("-rules <name>       Name of rules file to use\n");
    MSG("-symbols <name>     Specifies symbols component name\n");
    MSG("-synch              Synchronize request w/X server\n");
    MSG("-types <name>       Specifies types component name\n");
    MSG("-v[erbose] [<lvl>]  Sets verbosity (1..10).  Higher values yield\n");
    MSG("                    more messages\n");
    MSG("-variant <name>     Specifies layout variant used to choose component names\n");
d273 9
a281 9
        if (svValue[RULES_NDX])
            MSG1("rules:      %s\n", svValue[RULES_NDX]);
        if (svValue[MODEL_NDX])
            MSG1("model:      %s\n", svValue[MODEL_NDX]);
        if (svValue[LAYOUT_NDX])
            MSG1("layout:     %s\n", svValue[LAYOUT_NDX]);
        if (svValue[VARIANT_NDX])
            MSG1("variant:    %s\n", svValue[VARIANT_NDX]);
        if (options)
d283 1
a283 1
            char *opt_str = stringFromOptions(NULL, numOptions, options);
d290 12
a301 12
        if (svValue[KEYMAP_NDX])
            MSG1("keymap:     %s\n", svValue[KEYMAP_NDX]);
        if (svValue[KEYCODES_NDX])
            MSG1("keycodes:   %s\n", svValue[KEYCODES_NDX]);
        if (svValue[TYPES_NDX])
            MSG1("types:      %s\n", svValue[TYPES_NDX]);
        if (svValue[COMPAT_NDX])
            MSG1("compat:     %s\n", svValue[COMPAT_NDX]);
        if (svValue[SYMBOLS_NDX])
            MSG1("symbols:    %s\n", svValue[SYMBOLS_NDX]);
        if (svValue[GEOMETRY_NDX])
            MSG1("geometry:   %s\n", svValue[GEOMETRY_NDX]);
d316 1
a316 1
trySetString(int which, char *newVal, int src)
d318 1
a318 1
    if (svValue[which] != NULL)
d320 1
a320 1
        if (svSrc[which] == src)
d323 1
a323 1
                  svName[which], srcName[src]);
d325 1
a325 1
                  svValue[which], newVal);
d328 1
a328 1
        else if (svSrc[which] > src)
d330 1
a330 1
            VMSG1(5, "Warning! Multiple definitions of %s\n", svName[which]);
d332 1
a332 1
                  srcName[svSrc[which]], srcName[src]);
d336 2
a337 2
    svSrc[which] = src;
    svValue[which] = newVal;
d342 1
a342 1
setOptString(int *arg, int argc, char **argv, int which, int src)
d351 1
a351 1
        VMSG1(0, "No %s specified on the command line\n", svName[which]);
d357 1
a357 1
    if (svValue[which] != NULL)
d359 1
a359 1
        if (svSrc[which] == src)
d361 2
a362 2
            VMSG2(0, "More than one %s on %s\n", svName[which], srcName[src]);
            VMSG2(0, "Using \"%s\", ignoring \"%s\"\n", svValue[which],
d366 1
a366 1
        else if (svSrc[which] > src)
d368 2
a369 2
            VMSG1(5, "Multiple definitions of %s\n", svName[which]);
            VMSG2(5, "Using %s, ignoring %s\n", srcName[svSrc[which]],
d374 2
a375 2
    svSrc[which] = src;
    svValue[which] = argv[ndx];
d394 2
a395 2
    addToList(&szInclPath, &numInclPath, &inclPath, ".");
    addToList(&szInclPath, &numInclPath, &inclPath, DFLT_XKB_CONFIG_ROOT);
d402 4
a405 4
            if (!svSrc[LAYOUT_NDX])
                trySetString(LAYOUT_NDX, argv[i], FROM_CMD_LINE);
            else if (!svSrc[VARIANT_NDX])
                trySetString(VARIANT_NDX, argv[i], FROM_CMD_LINE);
d407 1
a407 1
                ok = addToList(&szOptions, &numOptions, &options, argv[i]);
d410 1
a410 1
            ok = setOptString(&i, argc, argv, COMPAT_NDX, FROM_CMD_LINE);
d412 1
a412 1
            ok = setOptString(&i, argc, argv, CONFIG_NDX, FROM_CMD_LINE);
d414 8
a421 1
            deviceSpec = atoi(argv[++i]); /* only allow device IDs, not names */
d423 1
a423 1
            ok = setOptString(&i, argc, argv, DISPLAY_NDX, FROM_CMD_LINE);
d425 1
a425 1
            ok = setOptString(&i, argc, argv, GEOMETRY_NDX, FROM_CMD_LINE);
d431 10
a440 2
        else if (strpfx(argv[i], "-I"))
            ok = addToList(&szInclPath, &numInclPath, &inclPath, &argv[i][2]);
d442 1
a442 1
            ok = setOptString(&i, argc, argv, KEYCODES_NDX, FROM_CMD_LINE);
d444 1
a444 1
            ok = setOptString(&i, argc, argv, KEYMAP_NDX, FROM_CMD_LINE);
d446 1
a446 1
            ok = setOptString(&i, argc, argv, LAYOUT_NDX, FROM_CMD_LINE);
d448 1
a448 1
            ok = setOptString(&i, argc, argv, MODEL_NDX, FROM_CMD_LINE);
d455 1
a455 1
                ok = addToList(&szOptions, &numOptions, &options, "");
d461 1
a461 1
                ok = addToList(&szOptions, &numOptions, &options, argv[++i]);
d469 1
a469 1
            ok = setOptString(&i, argc, argv, RULES_NDX, FROM_CMD_LINE);
d471 1
a471 1
            ok = setOptString(&i, argc, argv, SYMBOLS_NDX, FROM_CMD_LINE);
d475 1
a475 1
            ok = setOptString(&i, argc, argv, TYPES_NDX, FROM_CMD_LINE);
d495 1
a495 1
            ok = setOptString(&i, argc, argv, VARIANT_NDX, FROM_CMD_LINE);
d504 1
a504 1
    if (svValue[TYPES_NDX])
d506 1
a506 1
    if (svValue[COMPAT_NDX])
d508 1
a508 1
    if (svValue[SYMBOLS_NDX])
d510 1
a510 1
    if (svValue[KEYCODES_NDX])
d512 1
a512 1
    if (svValue[GEOMETRY_NDX])
d514 1
a514 1
    if (svValue[CONFIG_NDX])
d516 1
a516 1
    if (svValue[MODEL_NDX])
d518 1
a518 1
    if (svValue[LAYOUT_NDX])
d520 1
a520 1
    if (svValue[VARIANT_NDX])
d522 1
a522 1
    if (svValue[KEYMAP_NDX] && present)
d543 1
a543 1
        XkbOpenDisplay(svValue[DISPLAY_NDX], NULL, NULL, &major, &minor,
d547 4
a550 4
        if (svValue[DISPLAY_NDX] == NULL)
            svValue[DISPLAY_NDX] = getenv("DISPLAY");
        if (svValue[DISPLAY_NDX] == NULL)
            svValue[DISPLAY_NDX] = "default display";
d560 1
a560 1
            ERR1("Cannot open display \"%s\"\n", svValue[DISPLAY_NDX]);
d563 1
a563 1
            ERR1("XKB extension not present on %s\n", svValue[DISPLAY_NDX]);
d569 1
a569 1
                 svValue[DISPLAY_NDX], major, minor);
d609 1
a609 1
        trySetString(RULES_NDX, tmp, FROM_SERVER);
d611 1
a611 1
        trySetString(MODEL_NDX, vd.model, FROM_SERVER);
d613 1
a613 1
        trySetString(LAYOUT_NDX, vd.layout, FROM_SERVER);
d615 1
a615 1
        trySetString(VARIANT_NDX, vd.variant, FROM_SERVER);
d618 1
a618 1
        addStringToOptions(vd.options, &szOptions, &numOptions, &options);
d627 1
a627 1
findFileInPath(char *name, char *subdir)
d640 1
a640 1
    for (i = 0; (i < numInclPath); i++)
d642 1
a642 1
        if ((strlen(inclPath[i]) + strlen(subdir) + strlen(name) + 2) >
d645 2
a646 2
            VMSG3(0, "Path too long (%s/%s%s). Ignored.\n", inclPath[i],
                  subdir, name);
d649 1
a649 2
        sprintf(buf, "%s/%s%s", inclPath[i], subdir, name);
        fp = fopen(name, "r");
d661 1
a661 1
addStringToOptions(char *opt_str, int *sz_opts, int *num_opts, char ***opts)
d666 3
a668 3
    if ((str = strdup(opt_str)) == NULL)
        return False;
    for (tmp = str, next = NULL; (tmp && *tmp != '\0') && ok; tmp = next)
d676 1
a676 1
        ok = addToList(sz_opts, num_opts, opts, tmp) && ok;
d685 1
a685 1
stringFromOptions(char *orig, int numNew, char **newOpts)
d693 1
a693 1
    for (i = 0; i < numNew; i++)
d695 2
a696 2
        if (newOpts[i])
            len += strlen(newOpts[i]) + 1;
d703 1
a703 5
        if (!orig)
        {
            ERR("OOM in stringFromOptions\n");
            return NULL;
        }
d709 1
a709 5
        if (!orig)
        {
            ERR("OOM in stringFromOptions\n");
            return NULL;
        }
d712 1
a712 1
    for (i = 0; i < numNew; i++)
d714 1
a714 1
        if (!newOpts[i])
d719 1
a719 1
            strcat(orig, newOpts[i]);
d722 1
a722 1
            strcpy(orig, newOpts[i]);
d736 1
a736 1
    if ((fp = findFileInPath(name, "")) == NULL)
d747 1
a747 1
        trySetString(RULES_NDX, cfgResult.rules_file, FROM_CONFIG);
d752 1
a752 1
        trySetString(MODEL_NDX, cfgResult.model, FROM_CONFIG);
d757 1
a757 1
        trySetString(LAYOUT_NDX, cfgResult.layout, FROM_CONFIG);
d762 1
a762 1
        trySetString(VARIANT_NDX, cfgResult.variant, FROM_CONFIG);
d767 1
a767 2
        addStringToOptions(cfgResult.options, &szOptions, &numOptions,
                           &options);
d772 1
a772 1
        trySetString(KEYMAP_NDX, cfgResult.keymap, FROM_CONFIG);
d777 1
a777 1
        trySetString(KEYCODES_NDX, cfgResult.keycodes, FROM_CONFIG);
d782 1
a782 1
        trySetString(GEOMETRY_NDX, cfgResult.geometry, FROM_CONFIG);
d787 1
a787 1
        trySetString(SYMBOLS_NDX, cfgResult.symbols, FROM_CONFIG);
d792 1
a792 1
        trySetString(TYPES_NDX, cfgResult.types, FROM_CONFIG);
d797 1
a797 1
        trySetString(COMPAT_NDX, cfgResult.compat, FROM_CONFIG);
d808 13
d833 2
a834 2
    if (svSrc[MODEL_NDX] || svSrc[LAYOUT_NDX] || svSrc[VARIANT_NDX]
        || options)
d839 2
a840 2
        if (svSrc[VARIANT_NDX] < svSrc[LAYOUT_NDX])
            svValue[VARIANT_NDX] = NULL;
d842 4
a845 4
        rdefs.model = svValue[MODEL_NDX];
        rdefs.layout = svValue[LAYOUT_NDX];
        rdefs.variant = svValue[VARIANT_NDX];
        if (options)
d847 1
a847 1
                stringFromOptions(rdefs.options, numOptions, options);
d849 2
a850 2
        if (svSrc[RULES_NDX])
            rfName = svValue[RULES_NDX];
d856 1
a856 1
            rules = XkbRF_Load(rfName, svValue[LOCALE_NDX], True, True);
d862 1
a862 1
            for (i = 0; (i < numInclPath) && (!rules); i++)
d864 2
a865 1
                if ((strlen(inclPath[i]) + strlen(rfName) + 8) > PATH_MAX)
d868 1
a868 1
                          inclPath[i], rfName);
d871 1
a871 2
                sprintf(buf, "%s/rules/%s", inclPath[i], svValue[RULES_NDX]);
                rules = XkbRF_Load(buf, svValue[LOCALE_NDX], True, True);
d876 1
a876 1
            ERR1("Couldn't find rules file (%s) \n", svValue[RULES_NDX]);
d884 1
a884 1
            trySetString(KEYCODES_NDX, rnames.keycodes, FROM_RULES);
d889 1
a889 1
            trySetString(SYMBOLS_NDX, rnames.symbols, FROM_RULES);
d894 1
a894 1
            trySetString(TYPES_NDX, rnames.types, FROM_RULES);
d899 1
a899 1
            trySetString(COMPAT_NDX, rnames.compat, FROM_RULES);
d904 1
a904 1
            trySetString(GEOMETRY_NDX, rnames.geometry, FROM_RULES);
d909 1
a909 1
            trySetString(KEYMAP_NDX, rnames.keymap, FROM_RULES);
d914 1
a914 1
            MSG1("Applied rules from %s:\n", svValue[RULES_NDX]);
d928 1
a928 1
checkName(char *name, char *string)
d983 10
a992 10
    if (svValue[KEYCODES_NDX])
        MSG1("\txkb_keycodes  { include \"%s\"\t};\n", svValue[KEYCODES_NDX]);
    if (svValue[TYPES_NDX])
        MSG1("\txkb_types     { include \"%s\"\t};\n", svValue[TYPES_NDX]);
    if (svValue[COMPAT_NDX])
        MSG1("\txkb_compat    { include \"%s\"\t};\n", svValue[COMPAT_NDX]);
    if (svValue[SYMBOLS_NDX])
        MSG1("\txkb_symbols   { include \"%s\"\t};\n", svValue[SYMBOLS_NDX]);
    if (svValue[GEOMETRY_NDX])
        MSG1("\txkb_geometry  { include \"%s\"\t};\n", svValue[GEOMETRY_NDX]);
d999 1
a999 1
    if (!checkName(svValue[TYPES_NDX], "types"))
d1001 1
a1001 1
    if (!checkName(svValue[COMPAT_NDX], "compat"))
d1003 1
a1003 1
    if (!checkName(svValue[SYMBOLS_NDX], "symbols"))
d1005 1
a1005 1
    if (!checkName(svValue[KEYCODES_NDX], "keycodes"))
d1007 1
a1007 1
    if (!checkName(svValue[GEOMETRY_NDX], "geometry"))
d1009 1
a1009 1
    if (!checkName(svValue[KEYMAP_NDX], "keymap"))
d1021 6
a1026 6
        cmdNames.types = svValue[TYPES_NDX];
        cmdNames.compat = svValue[COMPAT_NDX];
        cmdNames.symbols = svValue[SYMBOLS_NDX];
        cmdNames.keycodes = svValue[KEYCODES_NDX];
        cmdNames.geometry = svValue[GEOMETRY_NDX];
        cmdNames.keymap = svValue[KEYMAP_NDX];
d1037 1
a1037 1
        if (svValue[RULES_NDX] && (rdefs.model || rdefs.layout))
d1039 1
a1039 1
            if (!XkbRF_SetNamesProp(dpy, svValue[RULES_NDX], &rdefs))
d1051 1
a1051 1
	dumpNames(True, False);
d1062 3
a1064 3
    svValue[LOCALE_NDX] = setlocale(LC_ALL, svValue[LOCALE_NDX]);
    svSrc[LOCALE_NDX] = FROM_SERVER;
    VMSG1(7, "locale is %s\n", svValue[LOCALE_NDX]);
d1067 1
a1067 1
    if (svValue[CONFIG_NDX] && (!applyConfig(svValue[CONFIG_NDX])))
@


1.2
log
@update to setxkbmap 1.1.0
@
text
@d51 1
a51 1
#define	DFLT_XKB_RULES_FILE __XKBDEFRULES__
d88 1
d244 1
d259 2
d437 2
d556 1
a556 1
 * Retrieve xkb values from th the XKB_RULES_NAMES property and store their
d986 1
a986 1
    if (dpy && !print)
d1016 4
@


1.1
log
@Initial revision
@
text
@a0 1
/* $XdotOrg: app/setxkbmap/setxkbmap.c,v 1.2 2004/04/23 19:54:37 eich Exp $ */
a25 1
/* $XFree86: xc/programs/setxkbmap/setxkbmap.c,v 3.7 2003/01/20 04:15:08 dawes Exp $ */
d48 1
a48 1
#define	DFLT_XKB_CONFIG_ROOT "/usr/X11R6/lib/X11/xkb"
d57 1
a57 1
#define	DFLT_XKB_MODEL "pc101"
d60 3
d64 4
a67 4
#define	FROM_SERVER	1
#define	FROM_RULES	2
#define	FROM_CONFIG	3
#define	FROM_CMD_LINE	4
d70 5
a74 4
#define	RULES_NDX	0
#define	CONFIG_NDX	1
#define	DISPLAY_NDX	2
#define	LOCALE_NDX	3
d87 12
a98 8
Bool			print= False;
Bool			synch= False;
int			verbose= 5;

Display *		dpy;

char *	srcName[NUM_SOURCES] = {
	"undefined", "X server", "rules file", "config file", "command line"
d101 9
a109 5
char *	svName[NUM_STRING_VALS]= {
	"rules file", "config file", "X display", "locale",
	"keyboard model", "keyboard layout", "layout variant",
	"keycodes", "types", "compatibility map", "symbols", "geometry",
	"keymap"
d111 24
a134 8
int	svSrc[NUM_STRING_VALS];
char *	svValue[NUM_STRING_VALS];

XkbConfigFieldsRec	cfgDflts;
XkbConfigRtrnRec	cfgResult;

XkbRF_RulesPtr		rules= NULL;
XkbRF_VarDefsRec	rdefs;
d136 1
a136 4
Bool			clearOptions= False;
int			szOptions= 0;
int			numOptions= 0;
char **			options= NULL;
d138 1
a138 5
int			szInclPath= 0;
int			numInclPath= 0;
char **			inclPath= NULL;

XkbDescPtr		xkb= NULL;
d162 16
a177 15
Bool addToList ( int *sz, int *num, char ***listIn, char *newVal );
void usage ( int argc, char ** argv );
void dumpNames ( Bool wantRules, Bool wantCNames );
void trySetString ( int which, char * newVal, int src );
Bool setOptString ( int *arg, int argc, char **argv, int which, int src );
int parseArgs ( int argc, char ** argv );
Bool getDisplay ( int argc, char ** argv );
Bool getServerValues ( void );
FILE * findFileInPath ( char * name, char * subdir );
Bool addStringToOptions ( char * opt_str, int * sz_opts, int * num_opts, char *** opts );
char * stringFromOptions ( char * orig, int numNew, char ** newOpts );
Bool applyConfig ( char * name );
Bool applyRules ( void );
Bool applyComponentNames ( void );
void printKeymap( void );
d182 1
a182 1
addToList(int *sz,int *num,char ***listIn,char *newVal)
d184 2
a185 2
register int i;
char **list;
d187 29
a215 24
    if ((!newVal)||(!newVal[0])) {
	*num= 0;
	return True;
    }
    list= *listIn;
    for (i=0;i<*num;i++) {
	if (streq(list[i],newVal))
	    return True;
    }
    if ((list==NULL)||(*sz<1)) {
	*num= 0;
	*sz= 4;
	list= (char **)calloc(*sz,sizeof(char *));
	*listIn= list;
    }
    else if (*num>=*sz) {
	*sz*= 2;
	list= (char **)realloc(list,(*sz)*sizeof(char *));
	*listIn= list;
    }
    if (!list) {
	ERR("Internal Error! Allocation failure in add to list!\n");
	ERR("                Exiting.\n");
	exit(-1);
d217 2
a218 2
    list[*num]= strdup(newVal);
    (*num)= (*num)+1;
d225 1
a225 1
usage(int argc,char **argv)
d227 2
a228 1
    MSG1("Usage: %s [args] [<layout> [<variant> [<option> ... ]]]\n",argv[0]);
d233 1
d253 1
a253 1
dumpNames(Bool wantRules,Bool wantCNames)
d255 29
a283 23
    if (wantRules) {
	if (svValue[MODEL_NDX])	 MSG1("model:      %s\n",svValue[MODEL_NDX]);
	if (svValue[LAYOUT_NDX])  MSG1("layout:     %s\n",svValue[LAYOUT_NDX]);
	if (svValue[VARIANT_NDX]) MSG1("variant:    %s\n",svValue[VARIANT_NDX]);
	if (options) {
	   char *opt_str=stringFromOptions(NULL, numOptions, options);
	   MSG1("options:    %s\n", opt_str);
	   free(opt_str);
	}
    }
    if (wantCNames) {
	if (svValue[KEYMAP_NDX])
	    MSG1("keymap:     %s\n",svValue[KEYMAP_NDX]);
	if (svValue[KEYCODES_NDX])
	    MSG1("keycodes:   %s\n",svValue[KEYCODES_NDX]);
	if (svValue[TYPES_NDX])
	    MSG1("types:      %s\n",svValue[TYPES_NDX]);
	if (svValue[COMPAT_NDX])
	    MSG1("compat:     %s\n",svValue[COMPAT_NDX]);
	if (svValue[SYMBOLS_NDX])
	    MSG1("symbols:    %s\n",svValue[SYMBOLS_NDX]);
	if (svValue[GEOMETRY_NDX])
	    MSG1("geometry:   %s\n",svValue[GEOMETRY_NDX]);
d290 7
d298 1
a298 1
trySetString(int which,char *newVal,int src)
d300 17
a316 14
    if (svValue[which]!=NULL) {
	if (svSrc[which]==src) {
	    VMSG2(0,"Warning! More than one %s from %s\n",
						svName[which],srcName[src]);
	    VMSG2(0,"         Using \"%s\", ignoring \"%s\"\n",
						svValue[which],newVal);
	    return;
	}
	else if (svSrc[which]>src) {
	    VMSG1(5,"Warning! Multiple definitions of %s\n",svName[which]);
	    VMSG2(5,"         Using %s, ignoring %s\n",srcName[svSrc[which]],
						srcName[src]);
	    return;
	}
d318 2
a319 2
    svSrc[which]= src;
    svValue[which]= newVal;
d324 1
a324 1
setOptString(int *arg,int argc,char **argv,int which,int src)
d326 2
a327 2
int	ndx;
char *	opt;
d329 7
a335 6
    ndx= *arg;
    opt= argv[ndx];
    if (ndx>=argc-1) {
	VMSG1(0,"No %s specified on the command line\n",svName[which]);
	VMSG1(0,"Trailing %s option ignored\n",opt);
	return True;
d338 17
a354 13
    *arg= ndx;
    if (svValue[which]!=NULL) {
	if (svSrc[which]==src) {
	    VMSG2(0,"More than one %s on %s\n",svName[which],srcName[src]);
	    VMSG2(0,"Using \"%s\", ignoring \"%s\"\n",svValue[which],argv[ndx]);
	    return True;
	}
	else if (svSrc[which]>src) {
	    VMSG1(5,"Multiple definitions of %s\n",svName[which]);
	    VMSG2(5,"Using %s, ignoring %s\n",srcName[svSrc[which]],
						srcName[src]);
	    return True;
	}
d356 2
a357 2
    svSrc[which]= src;
    svValue[which]= argv[ndx];
d363 5
d369 1
a369 1
parseArgs(int argc,char **argv)
d371 120
a490 93
int 	i;
Bool	ok;
unsigned	present;

    ok= True;
    addToList(&szInclPath,&numInclPath,&inclPath,".");
    addToList(&szInclPath,&numInclPath,&inclPath,DFLT_XKB_CONFIG_ROOT);
    for (i=1;(i<argc)&&ok;i++) {
	if (argv[i][0]!='-') {
	    if (!svSrc[LAYOUT_NDX])
		 trySetString(LAYOUT_NDX,argv[i],FROM_CMD_LINE);
	    else if (!svSrc[VARIANT_NDX])
		 trySetString(VARIANT_NDX,argv[i],FROM_CMD_LINE);
	    else ok= addToList(&szOptions,&numOptions,&options,argv[i]);
	}
	else if (streq(argv[i],"-compat"))
	    ok= setOptString(&i,argc,argv,COMPAT_NDX,FROM_CMD_LINE);
	else if (streq(argv[i],"-config"))
	    ok= setOptString(&i,argc,argv,CONFIG_NDX,FROM_CMD_LINE);
	else if (streq(argv[i],"-display"))
	    ok= setOptString(&i,argc,argv,DISPLAY_NDX,FROM_CMD_LINE);
	else if (streq(argv[i],"-geometry"))
	    ok= setOptString(&i,argc,argv,GEOMETRY_NDX,FROM_CMD_LINE);
	else if (streq(argv[i],"-help")||streq(argv[i],"-?")) {
	    usage(argc,argv);
	    exit(0);
	}
	else if (strpfx(argv[i],"-I")) 
	    ok= addToList(&szInclPath,&numInclPath,&inclPath,&argv[i][2]);
	else if (streq(argv[i],"-keycodes"))
	    ok= setOptString(&i,argc,argv,KEYCODES_NDX,FROM_CMD_LINE);
	else if (streq(argv[i],"-keymap"))
	    ok= setOptString(&i,argc,argv,KEYMAP_NDX,FROM_CMD_LINE);
	else if (streq(argv[i],"-layout"))
	    ok= setOptString(&i,argc,argv,LAYOUT_NDX,FROM_CMD_LINE);
	else if (streq(argv[i],"-model"))
	    ok= setOptString(&i,argc,argv,MODEL_NDX,FROM_CMD_LINE);
	else if (streq(argv[i],"-option")) {
	    if ((i==argc-1)||(argv[i+1][0]=='\0')||(argv[i+1][0]=='-')) {
		clearOptions= True;
		ok= addToList(&szOptions,&numOptions,&options,"");
                if (i<argc-1 && argv[i+1][0]=='\0')
                   i++;
	    }
	    else {
		ok= addToList(&szOptions,&numOptions,&options,argv[++i]);
	    }
	}
	else if (streq(argv[i],"-print"))
	    print= True;
	else if (streq(argv[i],"-rules"))
	    ok= setOptString(&i,argc,argv,RULES_NDX,FROM_CMD_LINE);
	else if (streq(argv[i],"-symbols"))
	    ok= setOptString(&i,argc,argv,SYMBOLS_NDX,FROM_CMD_LINE);
	else if (streq(argv[i],"-synch"))
	    synch= True;
	else if (streq(argv[i],"-types"))
	    ok= setOptString(&i,argc,argv,TYPES_NDX,FROM_CMD_LINE);
	else if (streq(argv[i],"-verbose")||(streq(argv[i],"-v"))) {
	    if ((i<argc-1)&&(isdigit(argv[i+1][0])))
	 	 verbose= atoi(argv[++i]);
	    else verbose++;
	    if (verbose<0) {
		ERR1("Illegal verbose level %d.  Reset to 0\n",verbose);
		verbose=0;
	    }
	    else if (verbose>10) {
		ERR1("Illegal verbose level %d.  Reset to 10\n",verbose);
		verbose= 10;
	    }
	    VMSG1(7,"Setting verbose level to %d\n",verbose);
	}
	else if (streq(argv[i],"-variant"))
	    ok= setOptString(&i,argc,argv,VARIANT_NDX,FROM_CMD_LINE);
	else {
	    ERR1("Error!   Option \"%s\" not recognized\n",argv[i]);
	    ok= False;
	}
    }

    present= 0;
    if (svValue[TYPES_NDX])	present++;
    if (svValue[COMPAT_NDX])	present++;
    if (svValue[SYMBOLS_NDX])	present++;
    if (svValue[KEYCODES_NDX])	present++;
    if (svValue[GEOMETRY_NDX])	present++;
    if (svValue[CONFIG_NDX])	present++;
    if (svValue[MODEL_NDX])	present++;
    if (svValue[LAYOUT_NDX])	present++;
    if (svValue[VARIANT_NDX])	present++;
    if (svValue[KEYMAP_NDX] && present) {
	ERR("No other components can be specified when a keymap is present\n");
	return False;
d495 5
d501 1
a501 1
getDisplay(int argc,char **argv)
d503 1
a503 1
int	major,minor,why;
d505 36
a540 32
    major= XkbMajorVersion;
    minor= XkbMinorVersion;
    dpy= XkbOpenDisplay(svValue[DISPLAY_NDX],NULL,NULL,&major,&minor,&why);
    if (!dpy) {
	if (svValue[DISPLAY_NDX]==NULL)	
	    svValue[DISPLAY_NDX]= getenv("DISPLAY");
	if (svValue[DISPLAY_NDX]==NULL)
	    svValue[DISPLAY_NDX]= "default display";
	switch (why) {
	    case XkbOD_BadLibraryVersion:
		ERR3("%s was compiled with XKB version %d.%02d\n",argv[0],
					XkbMajorVersion,XkbMinorVersion);
		ERR2("Xlib supports incompatible version %d.%02d\n",
					major,minor);
		break;
	    case XkbOD_ConnectionRefused:
                ERR1("Cannot open display \"%s\"\n",svValue[DISPLAY_NDX]);
		break;
	    case XkbOD_NonXkbServer:
		ERR1("XKB extension not present on %s\n",svValue[DISPLAY_NDX]);
		break;
	    case XkbOD_BadServerVersion:
                ERR3("%s was compiled with XKB version %d.%02d\n",argv[0],
				XkbMajorVersion,XkbMinorVersion);
		ERR3("Server %s uses incompatible version %d.%02d\n",
				svValue[DISPLAY_NDX],major,minor);
		break;
	    default:
		ERR1("Unknown error %d from XkbOpenDisplay\n",why);
		break;
	}
	return False;
d543 1
a543 1
	XSynchronize(dpy,True);
d549 7
d559 2
a560 2
XkbRF_VarDefsRec 	vd;
char *			tmp= NULL;
d562 3
a564 2
    if (!XkbRF_GetNamesProp(dpy,&tmp,&vd) || !tmp) {
	VMSG1(3,"Couldn't interpret %s property\n",_XKB_RF_NAMES_PROP_ATOM);
d570 2
a571 2
        VMSG3(3,"Use defaults: rules - '%s' model - '%s' layout - '%s'\n",
                tmp, vd.model, vd.layout);
d574 1
a574 1
	trySetString(RULES_NDX,tmp,FROM_SERVER);
d576 1
a576 1
	trySetString(MODEL_NDX,vd.model,FROM_SERVER);
d578 1
a578 1
	trySetString(LAYOUT_NDX,vd.layout,FROM_SERVER);
d580 5
a584 4
	trySetString(VARIANT_NDX,vd.variant,FROM_SERVER);
    if ((vd.options)&&(!clearOptions)) {
	addStringToOptions(vd.options,&szOptions,&numOptions,&options);
	XFree(vd.options);
d592 1
a592 1
findFileInPath(char *name,char *subdir)
d594 26
a619 22
register int	i;
char		buf[PATH_MAX];
FILE *		fp;

    if (name[0]=='/') {
	fp= fopen(name,"r");
	if ((verbose>7)||((!fp)&&(verbose>0)))
	    MSG2("%s file %s\n",(fp?"Found":"Didn't find"),name);
	return fp;
    }
    for (i=0;(i<numInclPath);i++) {
	if ((strlen(inclPath[i])+strlen(subdir)+strlen(name)+2)>PATH_MAX) {
	    VMSG3(0,"Path too long (%s/%s%s). Ignored.\n",inclPath[i],subdir,
									name);
	    continue;
	}
	sprintf(buf,"%s/%s%s",inclPath[i],subdir,name);
	fp= fopen(name,"r");
	if ((verbose>7)||((!fp)&&(verbose>5)))
	    MSG2("%s file %s\n",(fp?"Found":"Didn't find"),buf);
	if (fp!=NULL)
	    return fp;
d627 1
a627 1
addStringToOptions(char *opt_str,int *sz_opts,int *num_opts,char ***opts)
d629 2
a630 2
char 	*tmp,*str,*next;
Bool	ok= True;
d632 11
a642 10
    if ((str= malloc(strlen(opt_str)+1))!=NULL)
	 strcpy(str,opt_str);
    else return False;
    for (tmp= str,next=NULL;(tmp && *tmp!='\0')&&ok;tmp=next) {
	next= strchr(str,',');
	if (next) {
	    *next= '\0';
	    next++;
	}
	ok= addToList(sz_opts,num_opts,opts,tmp)&&ok;
d651 1
a651 1
stringFromOptions(char *orig,int numNew,char **newOpts)
d653 1
a653 1
int	len,i,nOut;
d655 43
a697 25
    if (orig)	len= strlen(orig)+1;
    else	len= 0;
    for (i=0;i<numNew;i++) {
	if (newOpts[i])
	    len+= strlen(newOpts[i])+1;
    }
    if (len<1)
	return NULL;
    if (orig) {
	orig= (char *)realloc(orig,len);
	nOut= 1;
    }
    else {
	orig= (char *)calloc(len,1);
	nOut= 0;
    }
    for (i=0;i<numNew;i++) {
	if (!newOpts[i])
	    continue;
	if (nOut>0) {
	     strcat(orig,",");
	     strcat(orig,newOpts[i]);
	}
	else strcpy(orig,newOpts[i]);
	nOut++;
d707 6
a712 6
FILE *	fp;
Bool	ok;
    
    if ((fp=findFileInPath(name,""))==NULL)
	return False;
    ok= XkbCFParse(fp,XkbCFDflts,NULL,&cfgResult);
d714 65
a778 51
    if (!ok) {
	ERR1("Couldn't find configuration file \"%s\"\n", name);
	return False;
    }
    if (cfgResult.rules_file) {
	trySetString(RULES_NDX,cfgResult.rules_file,FROM_CONFIG);
	cfgResult.rules_file= NULL;
    }
    if (cfgResult.model) {
	trySetString(MODEL_NDX,cfgResult.model,FROM_CONFIG);
	cfgResult.model= NULL;
    }
    if (cfgResult.layout) {
	trySetString(LAYOUT_NDX,cfgResult.layout,FROM_CONFIG);
	cfgResult.layout= NULL;
    }
    if (cfgResult.variant) {
	trySetString(VARIANT_NDX,cfgResult.variant,FROM_CONFIG);
	cfgResult.variant= NULL;
    }
    if (cfgResult.options) {
	addStringToOptions(cfgResult.options,&szOptions,&numOptions,&options);
	cfgResult.options= NULL;
    }
    if (cfgResult.keymap) {
	trySetString(KEYMAP_NDX,cfgResult.keymap,FROM_CONFIG);
	cfgResult.keymap= NULL;
    }
    if (cfgResult.keycodes) {
	trySetString(KEYCODES_NDX,cfgResult.keycodes,FROM_CONFIG);
	cfgResult.keycodes= NULL;
    }
    if (cfgResult.geometry) {
	trySetString(GEOMETRY_NDX,cfgResult.geometry,FROM_CONFIG);
	cfgResult.geometry= NULL;
    }
    if (cfgResult.symbols) {
	trySetString(SYMBOLS_NDX,cfgResult.symbols,FROM_CONFIG);
	cfgResult.symbols= NULL;
    }
    if (cfgResult.types) {
	trySetString(TYPES_NDX,cfgResult.types,FROM_CONFIG);
	cfgResult.types= NULL;
    }
    if (cfgResult.compat) {
	trySetString(COMPAT_NDX,cfgResult.compat,FROM_CONFIG);
	cfgResult.compat= NULL;
    }
    if (verbose>5) {
	MSG("After config file:\n");
	dumpNames(True,True);
d783 6
d792 2
a793 2
int	i;
char *	rfName;
d795 5
a799 3
    if (svSrc[MODEL_NDX]||svSrc[LAYOUT_NDX]||svSrc[VARIANT_NDX]||options) {
	char 			buf[PATH_MAX];
	XkbComponentNamesRec	rnames;
d801 1
a801 1
        if(svSrc[VARIANT_NDX] < svSrc[LAYOUT_NDX])
d804 79
a882 60
	rdefs.model= svValue[MODEL_NDX];
	rdefs.layout= svValue[LAYOUT_NDX];
	rdefs.variant= svValue[VARIANT_NDX];
	if (options)
	    rdefs.options=stringFromOptions(rdefs.options,numOptions,options);

	if (svSrc[RULES_NDX])
	     rfName= svValue[RULES_NDX];
	else rfName= DFLT_XKB_RULES_FILE;

	if (rfName[0]=='/') {
	    rules= XkbRF_Load(rfName,svValue[LOCALE_NDX],True,True);
	}
	else {
	    for (i=0;(i<numInclPath)&&(!rules);i++) {
		if ((strlen(inclPath[i])+strlen(rfName)+8)>PATH_MAX) {
		    VMSG2(0,"Path too long (%s/rules/%s). Ignored.\n",
						inclPath[i],rfName);
		    continue;
		}
		sprintf(buf,"%s/rules/%s",inclPath[i],svValue[RULES_NDX]);
		rules= XkbRF_Load(buf,svValue[LOCALE_NDX],True,True);
	    }
	}
	if (!rules) {
	    ERR1("Couldn't find rules file (%s) \n",svValue[RULES_NDX]);
	    return False;
	}
	XkbRF_GetComponents(rules,&rdefs,&rnames);
	if (rnames.keycodes) {
	    trySetString(KEYCODES_NDX,rnames.keycodes,FROM_RULES);
	    rnames.keycodes= NULL;
	}
	if (rnames.symbols) {
	    trySetString(SYMBOLS_NDX,rnames.symbols,FROM_RULES);
	    rnames.symbols= NULL;
	}
	if (rnames.types) {
	    trySetString(TYPES_NDX,rnames.types,FROM_RULES);
	    rnames.types= NULL;
	}
	if (rnames.compat) {
	    trySetString(COMPAT_NDX,rnames.compat,FROM_RULES);
	    rnames.compat= NULL;
	}
	if (rnames.geometry) {
	    trySetString(GEOMETRY_NDX,rnames.geometry,FROM_RULES);
	    rnames.geometry= NULL;
	}
	if (rnames.keymap) {
	    trySetString(KEYMAP_NDX,rnames.keymap,FROM_RULES);
	    rnames.keymap= NULL;
	}
	if (verbose>6) {
	    MSG1("Applied rules from %s:\n",svValue[RULES_NDX]);
	    dumpNames(True,False);
	}
    }
    else if (verbose>6) {
	MSG("No rules variables specified.  Rules file ignored\n");
d889 2
a890 2
Bool
checkName(char *name, char* string)
d892 2
a893 2
   char *i = name, *opar = NULL;
   Bool ret = True;
d895 2
a896 2
   if(!name)
      return True;
d898 41
a938 31
   while (*i){
      if (opar == NULL) {
         if (*i == '(')
         opar = i;
      } else {
         if ((*i == '(') || (*i == '|') || (*i == '+')) {
             ret = False;
             break;
         }
         if (*i == ')')
             opar = NULL;
      }
      i++;
   }
   if (opar)
      ret = False;
   if (!ret) {
      char c;
      int n = 1;
      for(i = opar+1; *i && n; i++) {
         if (*i == '(') n++;
         if (*i == ')') n--;
      }
      if (*i) i++;
      c = *i;
      *i = '\0';
      ERR1("Illegal map name '%s' ", opar);
      *i = c;
      ERR2("in %s name '%s'\n", string, name);
   }
   return ret;
d946 1
a946 1
	MSG1("\txkb_keycodes  { include \"%s\"\t};\n",svValue[KEYCODES_NDX]);
d948 1
a948 1
	MSG1("\txkb_types     { include \"%s\"\t};\n",svValue[TYPES_NDX]);
d950 1
a950 1
	MSG1("\txkb_compat    { include \"%s\"\t};\n",svValue[COMPAT_NDX]);
d952 1
a952 1
	MSG1("\txkb_symbols   { include \"%s\"\t};\n",svValue[SYMBOLS_NDX]);
d954 1
a954 1
	MSG1("\txkb_geometry  { include \"%s\"\t};\n",svValue[GEOMETRY_NDX]);
d961 45
a1005 38
    if(!checkName(svValue[TYPES_NDX],    "types"))
	return False;
    if(!checkName(svValue[COMPAT_NDX],   "compat"))
	return False;
    if(!checkName(svValue[SYMBOLS_NDX],  "symbols"))
	return False;
    if(!checkName(svValue[KEYCODES_NDX], "keycodes"))
	return False;
    if(!checkName(svValue[GEOMETRY_NDX], "geometry"))
	return False;
    if(!checkName(svValue[KEYMAP_NDX],   "keymap"))
	return False;

    if (verbose>5) {
	MSG("Trying to build keymap using the following components:\n");
	dumpNames(False,True);
    }
    if (dpy && !print) {
	XkbComponentNamesRec	cmdNames;
	cmdNames.types= svValue[TYPES_NDX];
	cmdNames.compat= svValue[COMPAT_NDX];
	cmdNames.symbols= svValue[SYMBOLS_NDX];
	cmdNames.keycodes= svValue[KEYCODES_NDX];
	cmdNames.geometry= svValue[GEOMETRY_NDX];
	cmdNames.keymap= svValue[KEYMAP_NDX];
	xkb= XkbGetKeyboardByName(dpy,XkbUseCoreKbd,&cmdNames,
			XkbGBN_AllComponentsMask, 
			XkbGBN_AllComponentsMask&(~XkbGBN_GeometryMask),
			True);
	if (!xkb) {
	    ERR("Error loading new keyboard description\n");
	    return False;
	}
	if (svValue[RULES_NDX] && (rdefs.model || rdefs.layout)) {
	    if (!XkbRF_SetNamesProp(dpy,svValue[RULES_NDX],&rdefs)) {
		VMSG(0,"Error updating the XKB names property\n");
	    }
	}
d1007 2
a1008 1
    if (print) {
d1016 1
a1016 1
main(int argc,char **argv)
d1018 5
a1022 5
    if ((!parseArgs(argc,argv))||(!getDisplay(argc,argv)))
	exit(-1);
    svValue[LOCALE_NDX]= setlocale(LC_ALL,svValue[LOCALE_NDX]);
    svSrc[LOCALE_NDX]= FROM_SERVER;
    VMSG1(7,"locale is %s\n",svValue[LOCALE_NDX]);
d1026 1
a1026 1
	exit(-3);
d1028 1
a1028 1
	exit(-4);
d1030 1
a1030 1
	exit(-5);
d1032 1
a1032 1
	XCloseDisplay(dpy);
@


1.1.1.1
log
@Importing from X.Org 7.2RC2
@
text
@@


1.1.1.2
log
@setxkbmap 1.0.4
@
text
@d50 1
a50 1
#define	DFLT_XKB_CONFIG_ROOT "/usr/share/X11/xkb"
d59 1
a59 1
#define	DFLT_XKB_MODEL "pc105"
d104 1
a120 2
int                     deviceSpec = XkbUseCoreKbd;

a206 1
    MSG("-device <deviceid>  Specifies the device ID to use\n");
a336 2
        else if (streq(argv[i],"-device"))
            deviceSpec= atoi(argv[++i]);
d530 3
a532 2
    if ((str = strdup(opt_str)) == NULL)
	return False;
d814 1
a814 1
	xkb= XkbGetKeyboardByName(dpy,deviceSpec,&cmdNames,
@

