head	1.3;
access;
symbols
	OPENBSD_6_2:1.3.0.16
	OPENBSD_6_2_BASE:1.3
	OPENBSD_6_1:1.3.0.14
	OPENBSD_6_1_BASE:1.3
	OPENBSD_6_0:1.3.0.12
	OPENBSD_6_0_BASE:1.3
	OPENBSD_5_9:1.3.0.10
	OPENBSD_5_9_BASE:1.3
	OPENBSD_5_8:1.3.0.8
	OPENBSD_5_8_BASE:1.3
	OPENBSD_5_7:1.3.0.6
	OPENBSD_5_7_BASE:1.3
	OPENBSD_5_6:1.3.0.4
	OPENBSD_5_6_BASE:1.3
	OPENBSD_5_5:1.3.0.2
	OPENBSD_5_5_BASE:1.3
	OPENBSD_5_4:1.2.0.6
	OPENBSD_5_4_BASE:1.2
	OPENBSD_5_3:1.2.0.4
	OPENBSD_5_3_BASE:1.2
	OPENBSD_5_2:1.2.0.2
	OPENBSD_5_2_BASE:1.2
	OPENBSD_5_1_BASE:1.1.1.1
	OPENBSD_5_1:1.1.1.1.0.20
	OPENBSD_5_0:1.1.1.1.0.18
	OPENBSD_5_0_BASE:1.1.1.1
	OPENBSD_4_9:1.1.1.1.0.14
	OPENBSD_4_9_BASE:1.1.1.1
	OPENBSD_4_8:1.1.1.1.0.16
	OPENBSD_4_8_BASE:1.1.1.1
	OPENBSD_4_7:1.1.1.1.0.12
	OPENBSD_4_7_BASE:1.1.1.1
	OPENBSD_4_6:1.1.1.1.0.10
	OPENBSD_4_6_BASE:1.1.1.1
	OPENBSD_4_5:1.1.1.1.0.8
	OPENBSD_4_5_BASE:1.1.1.1
	OPENBSD_4_4:1.1.1.1.0.6
	OPENBSD_4_4_BASE:1.1.1.1
	OPENBSD_4_3_BASE:1.1.1.1
	OPENBSD_4_3:1.1.1.1.0.4
	v1_0_2:1.1.1.1
	OPENBSD_4_2:1.1.1.1.0.2
	OPENBSD_4_2_BASE:1.1.1.1
	v1_0_1:1.1.1.1
	xorg:1.1.1;
locks; strict;
comment	@ * @;


1.3
date	2013.08.17.16.00.55;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2012.04.07.15.57.21;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.25.20.46.59;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.11.25.20.46.59;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.3
log
@Update to xload 1.1.2
@
text
@/*

Copyright (c) 1989  X Consortium

Permission is hereby granted, free of charge, to any person obtaining
a copy of this software and associated documentation files (the
"Software"), to deal in the Software without restriction, including
without limitation the rights to use, copy, modify, merge, publish,
distribute, sublicense, and/or sell copies of the Software, and to
permit persons to whom the Software is furnished to do so, subject to
the following conditions:

The above copyright notice and this permission notice shall be included
in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
IN NO EVENT SHALL THE X CONSORTIUM BE LIABLE FOR ANY CLAIM, DAMAGES OR
OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
OTHER DEALINGS IN THE SOFTWARE.

Except as contained in this notice, the name of the X Consortium shall
not be used in advertising or otherwise to promote the sale, use or
other dealings in this Software without prior written authorization
from the X Consortium.

*/

/*
 * get_load - get system load
 *
 * Authors:  Many and varied...
 *
 * Call InitLoadPoint() to initialize.
 * GetLoadPoint() is a callback for the StripChart widget.
 */

#ifdef HAVE_CONFIG_H
# include "config.h"
#endif

#include <X11/Xos.h>
#include <X11/Intrinsic.h>
#include <X11/Xlocale.h>
#include <stdio.h>
#include <stdlib.h>
#include "xload.h"

#if defined(__CYGWIN__)
# define WIN32_LEAN_AND_MEAN
# include <windows.h>
typedef struct {
  DWORD stat;
  union {
    LONG vLong;
    double vDouble;
    LONGLONG vLongLong;
    void *string;
  } u;
} COUNTER;
static HANDLE query;
static HANDLE counter;
static HINSTANCE hdll;
static long (__stdcall *pdhopen)(LPCSTR, DWORD, HANDLE);
static long (__stdcall *pdhaddcounter)(HANDLE, LPCSTR, DWORD, HANDLE*);
static long (__stdcall *pdhcollectquerydata)(HANDLE);
static long (__stdcall *pdhgetformattedcountervalue)(HANDLE, DWORD, LPDWORD, COUNTER*);
# define CYGWIN_PERF
void InitLoadPoint(void)
{
  long ret;
  hdll=LoadLibrary("pdh.dll");
  if (!hdll) exit(-1);
  pdhopen=(void*)GetProcAddress(hdll, "PdhOpenQueryA");
  if (!pdhopen) exit(-1);
  pdhaddcounter=(void*)GetProcAddress(hdll, "PdhAddCounterA");
  if (!pdhaddcounter) exit(-1);
  pdhcollectquerydata=(void*)GetProcAddress(hdll, "PdhCollectQueryData");
  if (!pdhcollectquerydata) exit(-1);
  pdhgetformattedcountervalue=(void*)GetProcAddress(hdll, "PdhGetFormattedCounterValue");
  if (!pdhgetformattedcountervalue) exit(-1);
  ret = pdhopen( NULL , 0, &query );
  if (ret!=0) exit(-1);
  ret = pdhaddcounter(query, "\\Processor(_Total)\\% Processor Time", 0, &counter);
  if (ret!=0) exit(-1);
}
void GetLoadPoint(
     Widget  w,              /* unused */
     XtPointer    closure,        /* unused */
     XtPointer    call_data)      /* pointer to (double) return value */
{
  double *loadavg = (double *)call_data;
  COUNTER fmtvalue;
  long ret;
  *loadavg = 0.0;
  ret = pdhcollectquerydata(query);
  if (ret!=0) return;
  ret = pdhgetformattedcountervalue(counter, 0x200, NULL, &fmtvalue);
  if (ret!=0) return;
  *loadavg = (fmtvalue.u.vDouble-0.01)/100.0;
}
#else /* not CYGWIN */

static void xload_error(const char *, const char *) _X_NORETURN;

# ifdef HAVE_GETLOADAVG
#  include <stdlib.h>
#  ifdef HAVE_SYS_LOADAVG_H
#   include <sys/loadavg.h>	/* Solaris definition of getloadavg */
#  endif

void InitLoadPoint(void)
{
}

void GetLoadPoint(
    Widget w,            /* unused */
    XtPointer closure,   /* unused */
    XtPointer call_data) /* ptr to (double) return value */
{
    double *loadavg = (double *)call_data;

    if (getloadavg(loadavg, 1) < 0)
        xload_error("couldn't obtain load average", "");
}

# else /* not HAVE_GETLOADAVG */

#  if defined(att) || defined(QNX4)
#   define LOADSTUB
#  endif

#  ifndef LOADSTUB
#   if !defined(linux) && !defined(__GLIBC__)
#    include <nlist.h>
#   endif /* !linux && ... */
#  endif /* LOADSTUB */

#  ifdef CSRG_BASED
#   include <sys/param.h>
#  endif

#  ifdef sgi
#   define FSCALE	1024.0
#  endif

#  ifdef __osf__
/*
 * Use the table(2) interface; it doesn't require setuid root.
 *
 * Select 0, 1, or 2 for 5, 30, or 60 second load averages.
 */
#   ifndef WHICH_AVG
#    define WHICH_AVG 1
#   endif
#   include <sys/table.h>
#  endif

#  ifdef SVR4
#   ifndef FSCALE
#    define FSCALE	(1 << 8)
#   endif
#  endif

#  if defined(SYSV) && defined(i386)
/*
 * inspired by 'avgload' by John F. Haugh II
 */
#   include <sys/param.h>
#   include <sys/buf.h>
#   include <sys/immu.h>
#   include <sys/region.h>
#   include <sys/var.h>
#   include <sys/proc.h>
#   define KERNEL_FILE "/unix"
#   define KMEM_FILE "/dev/kmem"
#   define VAR_NAME "v"
#   define PROC_NAME "proc"
#   define BUF_NAME "buf"
#   define DECAY 0.8
struct nlist namelist[] = {
  {VAR_NAME},
  {PROC_NAME},
  {BUF_NAME},
  {0},
};

static int kmem;
static struct var v;
static struct proc *p;
static XtPointer first_buf, last_buf;

void InitLoadPoint()				/* SYSV386 version */
{
    int i;

    nlist( KERNEL_FILE, namelist);

    for (i=0; namelist[i].n_name; i++)
	if (namelist[i].n_value == 0)
	    xload_error("cannot get name list from", KERNEL_FILE);

    if ((kmem = open(KMEM_FILE, O_RDONLY)) < 0)
	xload_error("cannot open", KMEM_FILE);

    if (lseek(kmem, namelist[0].n_value, 0) == -1)
	xload_error("cannot seek", VAR_NAME);

    if (read(kmem, &v, sizeof(v)) != sizeof(v))
	xload_error("cannot read", VAR_NAME);

    if ((p=(struct proc *)malloc(v.v_proc*sizeof(*p))) == NULL)
	xload_error("cannot allocat space for", PROC_NAME);

    first_buf = (XtPointer) namelist[2].n_value;
    last_buf  = (char *)first_buf + v.v_buf * sizeof(struct buf);
}

/* ARGSUSED */
void GetLoadPoint( w, closure, call_data )	/* SYSV386 version */
Widget	w;		/* unused */
XtPointer	closure;	/* unused */
XtPointer	call_data;	/* pointer to (double) return value */
{
    double *loadavg = (double *)call_data;
    static double avenrun = 0.0;
    int i, nproc, size;

    (void) lseek(kmem, namelist[0].n_value, 0);
    (void) read(kmem, &v, sizeof(v));

    size = (struct proc *)v.ve_proc - (struct proc *)namelist[1].n_value;

    (void) lseek(kmem, namelist[1].n_value, 0);
    (void) read(kmem, p, size * sizeof(struct proc));

    for (nproc = 0, i=0; i<size; i++)
	  if ((p[i].p_stat == SRUN) ||
	      (p[i].p_stat == SIDL) ||
	      (p[i].p_stat == SXBRK) ||
	      (p[i].p_stat == SSLEEP && (p[i].p_pri < PZERO) &&
	       (p[i].p_wchan >= (char *)first_buf) && (p[i].p_wchan < (char *)last_buf)))
	    nproc++;

    /* update the load average using a decay filter */
    avenrun = DECAY * avenrun + nproc * (1.0 - DECAY);
    *loadavg = avenrun;

    return;
}
#  else /* not (SYSV && i386) */

#   if defined(linux) || (defined(__FreeBSD_kernel__) && defined(__GLIBC__))

void InitLoadPoint(void)
{
      return;
}

void GetLoadPoint(
    Widget	w,		/* unused */
    XtPointer	closure,	/* unused */
    XtPointer	call_data)      /* pointer to (double) return value */
{
      static int fd = -1;
      int n;
      char buf[10] = {0, };
#    ifndef X_LOCALE
      char *dp;
      static char ldp = 0;
#    endif


      if (fd < 0)
      {
              if (fd == -2 ||
                  (fd = open("/proc/loadavg", O_RDONLY)) < 0)
              {
                      fd = -2;
                      *(double *)call_data = 0.0;
                      return;
              }
#    ifndef X_LOCALE
	      ldp = *localeconv()->decimal_point;
#    endif
      }
      else
              lseek(fd, 0, 0);

      if ((n = read(fd, buf, sizeof(buf)-1)) > 0) {
#    ifndef X_LOCALE
	  if (ldp != '.')
	      while ((dp = memchr(buf,'.',sizeof(buf)-1)) != NULL) {
		  *(char *)dp = ldp;
	      }

#    endif
	  if (sscanf(buf, "%lf", (double *)call_data) == 1)
	      return;
      }


      *(double *)call_data = 0.0;     /* temporary hiccup */

      return;
}

#   else /* linux */

#    ifdef __GNU__

#     include <mach.h>

static processor_set_t default_set;

void InitLoadPoint(void)
{
  if (processor_set_default (mach_host_self (), &default_set) != KERN_SUCCESS)
    xload_error("cannot get processor_set_default", "");
}

/* ARGSUSED */
void GetLoadPoint(
    Widget	w,		/* unused */
    XtPointer	closure,	/* unused */
    XtPointer	call_data)	/* pointer to (double) return value */
{
  host_t host;
  struct processor_set_basic_info info;
  unsigned info_count;

  info_count = PROCESSOR_SET_BASIC_INFO_COUNT;
  if (processor_set_info (default_set, PROCESSOR_SET_BASIC_INFO, &host,
			  (processor_set_info_t) &info, &info_count)
      != KERN_SUCCESS)
    {
      InitLoadPoint();
      info.load_average = 0;
    }

  *(double *)call_data = info.load_average * 1000 / LOAD_SCALE;

  return;
}

#    else /* __GNU__ */

#     ifdef __APPLE__

#      include <mach/mach.h>

static mach_port_t host_priv_port;

void InitLoadPoint(void)
{
    host_priv_port = mach_host_self();
}

/* ARGSUSED */
void GetLoadPoint(
    Widget	w,		/* unused */
    XtPointer	closure,	/* unused */
    XtPointer	call_data)	/* pointer to (double) return value */
{
    double *loadavg = (double *)call_data;

    struct host_load_info load_data;
    int host_count;
    kern_return_t kr;

    host_count = sizeof(load_data)/sizeof(integer_t);
    kr = host_statistics(host_priv_port, HOST_LOAD_INFO,
                        (host_info_t)&load_data, &host_count);
    if (kr != KERN_SUCCESS)
        xload_error("cannot get host statistics", "");
    *loadavg = (double)load_data.avenrun[0]/LOAD_SCALE;
    return;
}

#     else /* __APPLE__ */

#      ifdef LOADSTUB

void InitLoadPoint()
{
}

/* ARGSUSED */
void GetLoadPoint( w, closure, call_data )
     Widget	w;		/* unused */
     XtPointer	closure;	/* unused */
     XtPointer	call_data;	/* pointer to (double) return value */
{
	*(double *)call_data = 1.0;
}

#      else /* not LOADSTUB */

#       ifdef __osf__

void InitLoadPoint()
{
}

/*ARGSUSED*/
void GetLoadPoint( w, closure, call_data )
     Widget   w;              /* unused */
     XtPointer  closure;        /* unused */
     XtPointer  call_data;      /* pointer to (double) return value */
{
    double *loadavg = (double *)call_data;
    struct tbl_loadavg load_data;

    if (table(TBL_LOADAVG, 0, (char *)&load_data, 1, sizeof(load_data)) < 0)
	xload_error("error reading load average", "");
    *loadavg = (load_data.tl_lscale == 0) ?
	load_data.tl_avenrun.d[WHICH_AVG] :
	load_data.tl_avenrun.l[WHICH_AVG] / (double)load_data.tl_lscale;
}

#       else /* not __osf__ */

#        ifdef __QNXNTO__
#         include <time.h>
#         include <sys/neutrino.h>
static _Uint64t          nto_idle = 0, nto_idle_last = 0;
static  int       nto_idle_id;
static  struct timespec nto_now, nto_last;

void
InitLoadPoint(void)
{
  nto_idle_id = ClockId(1, 1); /* Idle thread */
  ClockTime(nto_idle_id, NULL, &nto_idle_last);
  clock_gettime( CLOCK_REALTIME, &nto_last);
}

/* ARGSUSED */
void
GetLoadPoint(			/* QNX NTO version */
    Widget	w,		/* unused */
    XtPointer	closure,	/* unused */
    XtPointer	call_data)	/* pointer to (double) return value */
{
    double *loadavg = (double *)call_data;
    double timediff;
    double temp = 0.0;

    ClockTime(nto_idle_id, NULL, &nto_idle);
    clock_gettime( CLOCK_REALTIME, &nto_now);
    timediff = 1000000000.0 * (nto_now.tv_sec - nto_last.tv_sec)
               + (nto_now.tv_nsec - nto_last.tv_nsec);
    temp = 1.0 - (nto_idle-nto_idle_last)/timediff;
    *loadavg = temp >= 0 ? temp : 0;
    nto_idle_last = nto_idle;
    nto_last = nto_now;
}
#        else /* not __QNXNTO__ */

#         ifdef __bsdi__
#          include <kvm.h>

static struct nlist nl[] = {
  { "_averunnable" },
#          define X_AVERUNNABLE 0
  { "_fscale" },
#          define X_FSCALE      1
  { "" },
};
static kvm_t *kd;
static int fscale;

void InitLoadPoint(void)
{
  fixpt_t averunnable[3];  /* unused really */

  if ((kd = kvm_openfiles(NULL, NULL, NULL, O_RDONLY, NULL)) == NULL)
    xload_error("can't open kvm files", "");

  if (kvm_nlist(kd, nl) != 0)
    xload_error("can't read name list", "");

  if (kvm_read(kd, (off_t)nl[X_AVERUNNABLE].n_value, (char *)averunnable,
	       sizeof(averunnable)) != sizeof(averunnable))
    xload_error("couldn't obtain _averunnable variable", "");

  if (kvm_read(kd, (off_t)nl[X_FSCALE].n_value, (char *)&fscale,
	       sizeof(fscale)) != sizeof(fscale))
    xload_error("couldn't obtain _fscale variable", "");

  return;
}

void GetLoadPoint(
     Widget	w,		/* unused */
     XtPointer	closure,	/* unused */
    XtPointer	call_data)	/* ptr to (double) return value */
{
  double *loadavg = (double *)call_data;
  fixpt_t t;

  if (kvm_read(kd, (off_t)nl[X_AVERUNNABLE].n_value, (char *)&t,
	       sizeof(t)) != sizeof(t))
    xload_error("couldn't obtain load average", "");

  *loadavg = (double)t/fscale;

  return;
}

#         else /* not __bsdi__ */
#          ifndef KMEM_FILE
#           define KMEM_FILE "/dev/kmem"
#          endif

#          ifndef KERNEL_FILE

#           ifdef hpux
#            define KERNEL_FILE "/hp-ux"
#           endif /* hpux */

#           ifdef sgi
#            if (OSMAJORVERSION > 4)
#             define KERNEL_FILE "/unix"
#            endif
#           endif

/*
 * provide default for everyone else
 */
#           ifndef KERNEL_FILE
#            ifdef SVR4
#             define KERNEL_FILE "/stand/unix"
#            else
#             ifdef SYSV
#              define KERNEL_FILE "/unix"
#             else
/* If a BSD system, check in <paths.h> */
#              ifdef BSD
#               include <paths.h>
#               ifdef _PATH_UNIX
#                define KERNEL_FILE _PATH_UNIX
#               else
#                ifdef _PATH_KERNEL
#                 define KERNEL_FILE _PATH_KERNEL
#                else
#                 define KERNEL_FILE "/vmunix"
#                endif
#               endif
#              else /* BSD */
#               define KERNEL_FILE "/vmunix"
#              endif /* BSD */
#             endif /* SYSV */
#            endif /* SVR4 */
#           endif /* KERNEL_FILE */
#          endif /* KERNEL_FILE */


#          ifndef KERNEL_LOAD_VARIABLE
#           if defined(BSD) && (BSD >= 199103)
#            define KERNEL_LOAD_VARIABLE "_averunnable"
#           endif /* BSD >= 199103 */

#           ifdef hpux
#            ifdef __hp9000s800
#             define KERNEL_LOAD_VARIABLE "avenrun"
#            endif /* hp9000s800 */
#           endif /* hpux */

#           ifdef sgi
#	 define KERNEL_LOAD_VARIABLE "avenrun"
#           endif /* sgi */

#          endif /* KERNEL_LOAD_VARIABLE */

/*
 * provide default for everyone else
 */

#          ifndef KERNEL_LOAD_VARIABLE
#           ifdef USG
#            define KERNEL_LOAD_VARIABLE "sysinfo"
#            define SYSINFO
#           else
#            ifdef SVR4
#             define KERNEL_LOAD_VARIABLE "avenrun"
#            else
#             define KERNEL_LOAD_VARIABLE "_avenrun"
#            endif
#           endif
#          endif /* KERNEL_LOAD_VARIABLE */

static struct nlist namelist[] = {	    /* namelist for vmunix grubbing */
#          define LOADAV 0
    {KERNEL_LOAD_VARIABLE},
    {0}
};

static int kmem;
static long loadavg_seek;

void InitLoadPoint()
{
#          if !defined(SVR4) && !defined(sgi) && !defined(AIXV5) && !(BSD >= 199103) && !defined(__APPLE__)
    extern void nlist();
#          endif

    nlist( KERNEL_FILE, namelist);
    /*
     * Some systems appear to set only one of these to Zero if the entry could
     * not be found, I hope no_one returns Zero as a good value, or bad things
     * will happen to you.  (I have a hard time believing the value will
     * ever really be zero anyway).   CDP 5/17/89.
     */
    if (namelist[LOADAV].n_type == 0 ||
	namelist[LOADAV].n_value == 0) {
	xload_error("cannot get name list from", KERNEL_FILE);
	exit(-1);
    }
    loadavg_seek = namelist[LOADAV].n_value;
    kmem = open(KMEM_FILE, O_RDONLY);
    if (kmem < 0) xload_error("cannot open", KMEM_FILE);
}

/* ARGSUSED */
void GetLoadPoint( w, closure, call_data )
     Widget	w;		/* unused */
     XtPointer	closure;	/* unused */
     XtPointer	call_data;	/* pointer to (double) return value */
{
  	double *loadavg = (double *)call_data;

	(void) lseek(kmem, loadavg_seek, 0);

#          if defined(SVR4) || defined(sgi) || (BSD >= 199103)
	{
		long temp;
		(void) read(kmem, (char *)&temp, sizeof(long));
		*loadavg = (double)temp/FSCALE;
	}
#          else /* else not SVR4 or sgi or BSD */
	(void) read(kmem, (char *)loadavg, sizeof(double));
#          endif /* SVR4 or ... else */
	return;
}
#         endif /* __bsdi__ else */
#        endif /* __QNXNTO__ else */
#       endif /* __osf__ else */
#      endif /* LOADSTUB else */
#     endif /* __APPLE__ else */
#    endif /* __GNU__ else */
#   endif /* linux else */
#  endif /* SYSV && i386 else */
# endif /* HAVE_GETLOADAVG else */

static void xload_error(const char *str1, const char *str2)
{
    (void) fprintf(stderr,"xload: %s %s\n", str1, str2);
# ifdef __bsdi__
    if (kd)
	kvm_close(kd);
# endif
    exit(-1);
}

#endif /* END of __CYGWIN__ */
@


1.2
log
@Update to xload 1.1.1
@
text
@d52 2
a53 2
#define WIN32_LEAN_AND_MEAN
#include <windows.h>
d70 1
a70 1
#define CYGWIN_PERF 
d87 1
a87 1
  if (ret!=0) exit(-1);  
d104 30
a133 1
#else
d135 5
d141 3
a143 59
#if defined(att) || defined(QNX4)
#define LOADSTUB
#endif

#ifndef LOADSTUB
#if !defined(linux) && !defined(__UNIXOS2__) && !defined(__GLIBC__)
#include <nlist.h>
#endif /* !linux && ... */
#endif /* LOADSTUB */

#if defined(MOTOROLA) && defined(SYSV)
#include <sys/sysinfo.h>
#endif

#ifdef CSRG_BASED
#include <sys/param.h>
#endif

#if defined(umips) || (defined(ultrix) && defined(mips))
#include <sys/fixpoint.h>
#endif

#if  defined(CRAY) || defined(AIXV3)
#include <sys/param.h>
#define word word_t
#include <sys/sysinfo.h>
#undef word
#undef n_type
#define n_type n_value
#endif	/* CRAY */

#ifdef sequent
#include <sys/vm.h>
#endif /* sequent */


#ifdef hcx
#include <sys/param.h>
#endif /* hcx */

#if defined(UTEK) || defined(alliant) || (defined(MOTOROLA) && defined(SVR4))
#define FSCALE	100.0
#endif

#ifdef sequent
#define FSCALE	1000.0
#endif

#ifdef sgi
#define FSCALE	1024.0
#endif

#if defined(sony) && OSMAJORVERSION == 4
#ifdef mips
#include <sys/fixpoint.h>
#else
#include <sys/param.h>
#endif
#endif
d145 5
a149 1
#ifdef __osf__
d155 11
a165 18
#ifndef WHICH_AVG
#define WHICH_AVG 1
#endif
#include <sys/table.h>
#endif

#ifdef SVR4
#ifndef FSCALE
#define FSCALE	(1 << 8)
#endif
#endif

#ifdef X_NOT_POSIX
extern long lseek();
#endif

static void xload_error(const char *, const char *) _X_NORETURN;

d167 1
a167 1
#if defined(SYSV) && defined(i386)
d171 12
a182 12
#include <sys/param.h>
#include <sys/buf.h>
#include <sys/immu.h>
#include <sys/region.h>
#include <sys/var.h>
#include <sys/proc.h>
#define KERNEL_FILE "/unix"
#define KMEM_FILE "/dev/kmem"
#define VAR_NAME "v"
#define PROC_NAME "proc"
#define BUF_NAME "buf"
#define DECAY 0.8
d201 1
a201 1
    for (i=0; namelist[i].n_name; i++) 
d216 1
a216 1
	  
d220 1
a220 1
	
d230 1
a230 1
	
d239 1
a239 1
    for (nproc = 0, i=0; i<size; i++) 
d253 1
a253 1
#else /* not (SYSV && i386) */
d255 1
a255 1
#if defined(linux) || (defined(__FreeBSD_kernel__) && defined(__GLIBC__))
d270 1
a270 1
#ifndef X_LOCALE
d273 1
a273 1
#endif
d285 1
a285 1
#ifndef X_LOCALE
d287 1
a287 1
#endif
d293 1
a293 1
#ifndef X_LOCALE
d298 2
a299 2
	  
#endif
d303 1
a303 1
      
d310 1
a310 1
#else /* linux */
d312 1
a312 1
#ifdef __GNU__
d314 1
a314 1
#include <mach.h>
d348 1
a348 1
#else /* __GNU__ */
d350 1
a350 1
#ifdef __APPLE__
d352 1
a352 1
#include <mach/mach.h>
d382 1
a382 1
#else /* __APPLE__ */
d384 1
a384 1
#ifdef LOADSTUB
d399 1
a399 1
#else /* not LOADSTUB */
d401 1
a401 1
#ifdef __osf__
d423 1
a423 1
#else /* not __osf__ */
d425 3
a427 3
#ifdef __QNXNTO__
#include <time.h>
#include <sys/neutrino.h>
d460 1
a460 1
#else /* not __QNXNTO__ */
d462 2
a463 2
#ifdef __bsdi__
#include <kvm.h>
d467 1
a467 1
#define X_AVERUNNABLE 0
d469 1
a469 1
#define X_FSCALE      1
d513 16
a528 76
#else /* not __bsdi__ */
#if defined(HAVE_GETLOADAVG)
#include <stdlib.h>
#ifdef HAVE_SYS_LOADAVG_H
#include <sys/loadavg.h>	/* Solaris definition of getloadavg */
#endif

void InitLoadPoint()
{
}

void GetLoadPoint(w, closure, call_data)
     Widget w;          /* unused */
     XtPointer closure;   /* unused */
     XtPointer call_data; /* ptr to (double) return value */
{
  double *loadavg = (double *)call_data;

  if (getloadavg(loadavg, 1) < 0) 
    xload_error("couldn't obtain load average", "");
}

#else /* not HAVE_GETLOADAVG */

#ifndef KMEM_FILE
#define KMEM_FILE "/dev/kmem"
#endif

#ifndef KERNEL_FILE

#ifdef alliant
#define KERNEL_FILE "/vmunix"
#endif /* alliant */

#ifdef CRAY
#define KERNEL_FILE "/unicos"
#endif /* CRAY */

#ifdef hpux
#define KERNEL_FILE "/hp-ux"
#endif /* hpux */


#ifdef umips
# ifdef SYSTYPE_SYSV
# define KERNEL_FILE "/unix"
# else
# define KERNEL_FILE "/vmunix"
# endif /* SYSTYPE_SYSV */
#endif /* umips */

#ifdef sequent
#define KERNEL_FILE "/dynix"
#endif /* sequent */

#ifdef hcx
#define KERNEL_FILE "/unix"
#endif /* hcx */

#ifdef MOTOROLA
#if defined(SYSV) && defined(m68k)
#define KERNEL_FILE "/sysV68"
#endif
#if defined(SYSV) && defined(m88k)
#define KERNEL_FILE "/unix"
#endif
#ifdef SVR4
#define KERNEL_FILE "/unix"
#endif
#endif /* MOTOROLA */

#ifdef sgi
#if (OSMAJORVERSION > 4)
#define KERNEL_FILE "/unix"
#endif
#endif
d533 7
a539 7
#ifndef KERNEL_FILE
#ifdef SVR4
#define KERNEL_FILE "/stand/unix"
#else
#ifdef SYSV
#define KERNEL_FILE "/unix"
#else
d541 30
a570 37
#   ifdef BSD
#    include <paths.h>
#    ifdef _PATH_UNIX
#     define KERNEL_FILE _PATH_UNIX
#    else
#     ifdef _PATH_KERNEL
#      define KERNEL_FILE _PATH_KERNEL
#     else
#      define KERNEL_FILE "/vmunix"
#     endif
#    endif
#   else /* BSD */
#    define KERNEL_FILE "/vmunix"
#   endif /* BSD */
#endif /* SYSV */
#endif /* SVR4 */
#endif /* KERNEL_FILE */
#endif /* KERNEL_FILE */


#ifndef KERNEL_LOAD_VARIABLE
#    if defined(BSD) && (BSD >= 199103)
#        define KERNEL_LOAD_VARIABLE "_averunnable"
#    endif /* BSD >= 199103 */

#    ifdef alliant
#        define KERNEL_LOAD_VARIABLE "_Loadavg"
#    endif /* alliant */

#    ifdef CRAY
#        if defined(CRAY2) && OSMAJORVERSION == 4
#            define KERNEL_LOAD_VARIABLE "avenrun"
#        else
#            define KERNEL_LOAD_VARIABLE "sysinfo"
#            define SYSINFO
#        endif /* defined(CRAY2) && OSMAJORVERSION == 4 */
#    endif /* CRAY */
d572 1
a572 15
#    ifdef hpux
#        ifdef __hp9000s800
#            define KERNEL_LOAD_VARIABLE "avenrun"
#        endif /* hp9000s800 */
#    endif /* hpux */

#    ifdef umips
#        ifdef SYSTYPE_SYSV
#            define KERNEL_LOAD_VARIABLE "avenrun"
#        else
#            define KERNEL_LOAD_VARIABLE "_avenrun"
#        endif /* SYSTYPE_SYSV */
#    endif /* umips */

#    ifdef sgi
d574 1
a574 17
#    endif /* sgi */

#    ifdef AIXV3
#        define KERNEL_LOAD_VARIABLE "sysinfo"
#    endif /* AIXV3 */

#    ifdef MOTOROLA
#        if defined(SYSV) && defined(m68k)
#            define KERNEL_LOAD_VARIABLE "sysinfo"
#        endif
#        if defined(SYSV) && defined(m88k)
#            define KERNEL_LOAD_VARIABLE "_sysinfo"
#        endif
#        ifdef SVR4
#            define KERNEL_LOAD_VARIABLE "avenrun"
#        endif
#    endif /* MOTOROLA */
d576 1
a576 1
#endif /* KERNEL_LOAD_VARIABLE */
d582 12
a593 12
#ifndef KERNEL_LOAD_VARIABLE
#    ifdef USG
#        define KERNEL_LOAD_VARIABLE "sysinfo"
#        define SYSINFO
#    else
#    ifdef SVR4
#        define KERNEL_LOAD_VARIABLE "avenrun"
#    else
#        define KERNEL_LOAD_VARIABLE "_avenrun"
#    endif
#    endif
#endif /* KERNEL_LOAD_VARIABLE */
d596 1
a596 1
#define LOADAV 0
d606 1
a606 1
#if !defined(SVR4) && !defined(sgi) && !defined(MOTOROLA) && !defined(AIXV5) && !(BSD >= 199103) && !defined(__APPLE__)
d608 1
a608 1
#endif
a609 3
#ifdef AIXV3
    knlist( namelist, 1, sizeof(struct nlist));
#else	
a610 1
#endif
a616 3
#ifdef hcx
    if (namelist[LOADAV].n_type == 0 &&
#else
a617 1
#endif /* hcx */
a622 7
#if defined(umips) && defined(SYSTYPE_SYSV)
    loadavg_seek &= 0x7fffffff;
#endif /* umips && SYSTYPE_SYSV */
#if (defined(CRAY) && defined(SYSINFO))
    loadavg_seek += ((char *) (((struct sysinfo *)NULL)->avenrun)) -
	((char *) NULL);
#endif /* CRAY && SYSINFO */
d637 1
a637 125
#if defined (UTEK) || defined(sequent) || defined(alliant) || defined(SVR4) || defined(sgi) || defined(hcx) || (BSD >= 199103)
	{
		long temp;
		(void) read(kmem, (char *)&temp, sizeof(long));
		*loadavg = (double)temp/FSCALE;
	}
#else /* else not UTEK or sequent or alliant or SVR4 or sgi or hcx */
#  if defined(umips) || (defined(ultrix) && defined(mips))
	{
		fix temp;
		(void) read(kmem, (char *)&temp, sizeof(fix));
		*loadavg = FIX_TO_DBL(temp);
	}
#  else /* not umips or ultrix risc */
#    ifdef AIXV3
        {
          struct sysinfo sysinfo_now;
          struct sysinfo sysinfo_last;
          static firsttime = TRUE;
          static double runavg = 0.0, swpavg = 0.0;

          (void) lseek(kmem, loadavg_seek, 0);
          (void) read(kmem, (char *)&sysinfo_last, sizeof(struct sysinfo));
          if (firsttime)
            {
              *loadavg = 0.0;
              firsttime = FALSE;
            }
          else
            {
              sleep(1);
              (void) lseek(kmem, loadavg_seek, 0);
              (void) read(kmem, (char *)&sysinfo_now, sizeof(struct sysinfo));
              runavg *= 0.8; swpavg *= 0.8;
              if (sysinfo_now.runocc != sysinfo_last.runocc)
                runavg += 0.2*((sysinfo_now.runque - sysinfo_last.runque - 1)
                          /(double)(sysinfo_now.runocc - sysinfo_last.runocc));
              if (sysinfo_now.swpocc != sysinfo_last.swpocc)
                swpavg += 0.2*((sysinfo_now.swpque - sysinfo_last.swpque)
                          /(double)(sysinfo_now.swpocc - sysinfo_last.swpocc));
              *loadavg = runavg + swpavg;
              sysinfo_last = sysinfo_now;
            }
          /* otherwise we leave load alone. */
        }
#    else /* not AIXV3 */
#      if defined(MOTOROLA) && defined(SYSV)
	{
        static int init = 0;
        static kmem;
        static long loadavg_seek;

#define CEXP    0.25            /* Constant used for load averaging */

        struct sysinfo sysinfod;
        static double oldloadavg;
        static double cexp = CEXP;
        static long sv_rq, sv_oc;   /* save old values */
        double rq, oc;              /* amount values have changed */

        if (!init)
        {
            if (nlist(KERNEL_FILE,namelist) == -1)
            {
                perror("xload: nlist()");
                xload_error("cannot get name list from", KERNEL_FILE);
            }
            loadavg_seek = namelist[0].n_value;

            kmem = open(KMEM_FILE, O_RDONLY);
            if (kmem < 0)
            {
                perror("xload: open()");
                xload_error("cannot open", KMEM_FILE);
            }
        }

        lseek(kmem, loadavg_seek, 0);
        if (read(kmem, &sysinfod, (int) sizeof (struct sysinfo)) == -1)
        {
             perror("xload: read() SYSINFONL");
             xload_error("read failed from", KMEM_FILE);
        }

        if (!init)
        {
            init = 1;
            sv_rq = sysinfod.runque;
            sv_oc = sysinfod.runocc;
            oldloadavg = *loadavg = 0.0;
            return;
        }
        /*
         * calculate the amount the values have
         * changed since last update
         */
        rq = (double) sysinfod.runque - sv_rq;
        oc = (double) sysinfod.runocc - sv_oc;

        /*
         * save old values for next time
         */
        sv_rq = sysinfod.runque;
        sv_oc = sysinfod.runocc;

        if (oc == 0.0)          /* avoid divide by zero  */
        {
                *loadavg = (1.0 - cexp) * oldloadavg;

        }
        else
        {
                *loadavg = ((1.0 - cexp) * oldloadavg) + ((rq / oc) * cexp);
        }
        oldloadavg = *loadavg;
	}
#      else /* not MOTOROLA */
#     if defined(sony) && OSMAJORVERSION == 4
#      ifdef mips
	{
		fix temp;
		(void) read(kmem, (char *)&temp, sizeof(fix));
		*loadavg = FIX_TO_DBL(temp);
	}
#      else /* not mips */
d643 1
a643 2
#      endif /* mips */
#     else /* not sony NEWSOS4 */
d645 1
a645 5
#      endif /* sony NEWOS4 */
#     endif /* MOTOROLA else */
#    endif /* AIXV3 else */
#  endif /* umips else */
#endif /* SVR4 or ... else */
d648 9
a656 9
#endif /* HAVE_GETLOADAVG else */
#endif /* __bsdi__ else */
#endif /* __QNXNTO__ else */
#endif /* __osf__ else */
#endif /* LOADSTUB else */
#endif /* __APPLE__ else */
#endif /* __GNU__ else */
#endif /* linux else */
#endif /* SYSV && i386 else */
d661 1
a661 1
#ifdef __bsdi__
d664 1
a664 1
#endif
@


1.1
log
@Initial revision
@
text
@a0 3
/* $XdotOrg: xc/programs/xload/get_load.c,v 1.2 2004/04/23 19:54:57 eich Exp $ */
/* $XConsortium: get_load.c /main/37 1996/03/09 09:38:04 kaleb $ */
/* $XFree86: xc/programs/xload/get_load.c,v 1.21tsi Exp $ */
d52 1
d71 1
a71 1
void InitLoadPoint()
d89 4
a92 4
void GetLoadPoint( w, closure, call_data )      /* SYSV386 version */
     Widget  w;              /* unused */
     XtPointer       closure;        /* unused */
     XtPointer       call_data;      /* pointer to (double) return value */
a106 1
#if !defined(DGUX)
a110 2
#ifndef macII
#ifndef apollo
a115 2
#endif /* apollo */
#endif /* macII */
a120 14
#ifdef sun
#    include <sys/param.h>
#    if !defined(HAVE_CONFIG_H) && defined(SVR4) 
# 	define HAVE_LIBKSTAT 1
#    endif
#    ifdef HAVE_LIBKSTAT
#	include <kstat.h>
#	include <errno.h>
#    elif defined(i386) && !defined(SVR4)
#        include <kvm.h>
#        define	KVM_ROUTINES
#    endif /* i386 */
#endif

a141 10
#ifdef macII
#include <a.out.h>
#include <sys/var.h>
#define X_AVENRUN 0
#define fxtod(i) (vec[i].high+(vec[i].low/65536.0))
struct lavnum {
    unsigned short high;
    unsigned short low;
};
#endif /* macII */
d189 1
a189 34
void xload_error(char *, char *);


#ifdef apollo
#include <apollo/base.h>
#include <apollo/time.h>
typedef struct {
	short		state;		/* ready, waiting, etc. */
	pinteger	usr;		/* user sr */
	linteger	upc;		/* user pc */
	linteger	usp;		/* user stack pointer */
	linteger	usb;		/* user sb ptr (A6) */
	time_$clock_t	cpu_total;	/* cumulative cpu used by process */
	unsigned short	priority;	/* process priority */
    } proc1_$info_t;

void proc1_$get_cput(
	time_$clock_t	*cput
);

void proc1_$get_info(
	short		&pid,
	proc1_$info_t	*info,
	status_$t	*sts
);

static int     lastNullCpu;
static int     lastClock;

void InitLoadPoint()				/* Apollo version */
{
     time_$clock_t  timeNow;
     proc1_$info_t  info;
     status_$t      st;
a190 17
     proc1_$get_info( (short) 2, &info, &st );
     time_$clock( &timeNow );

     lastClock = timeNow.low32;
     lastNullCpu = info.cpu_total.low32;
}

/* ARGSUSED */
void GetLoadPoint( w, closure, call_data ) 	/* Apollo version */
     Widget	w;		/* unused */
     XtPointer	closure;	/* unused */
     XtPointer	call_data;	/* pointer to (double) return value */
{
     time_$clock_t  timeNow;
     double         temp;
     proc1_$info_t  info;
     status_$t      st;
a191 10
     proc1_$get_info( (short) 2, &info, &st );
     time_$clock( &timeNow );

     temp = info.cpu_total.low32 - lastNullCpu;
     *(double *)call_data = 1.0 - temp / (timeNow.low32 - lastClock);

     lastClock = timeNow.low32;
     lastNullCpu = info.cpu_total.low32;
}
#else /* not apollo */
a278 45
#ifdef KVM_ROUTINES
/*
 *	Sun 386i Code - abstracted to see the wood for the trees
 */

static struct nlist nl[2];
static kvm_t *kd;

void
InitLoadPoint()					/* Sun 386i version */
{
    kd = kvm_open("/vmunix", NULL, NULL, O_RDONLY, "Load Widget");
    if (kd == (kvm_t *)0) {
	xload_error("cannot get access to kernel address space", "");
    }
	
    nl[0].n_name = "avenrun";
    nl[1].n_name = NULL;
	
    if (kvm_nlist(kd, nl) != 0) {
	xload_error("cannot get name list", "");
    }
    
    if (nl[0].n_value == 0) {
	xload_error("Cannot find address for avenrun in the kernel\n", "");
    }
}

/* ARGSUSED */
void 
GetLoadPoint( w, closure, call_data ) 		/* Sun 386i version */
Widget	w;		/* unused */
XtPointer closure;	/* unused */
XtPointer call_data;	/* pointer to (double) return value */
{
    double *loadavg = (double *)call_data;
    long	temp;

    if (kvm_read(kd, nl[0].n_value, (char *)&temp, sizeof (temp)) != 
	sizeof (temp)) {
	xload_error("Kernel read error", "");
    }
    *loadavg = (double)temp/FSCALE;
}
#else /* not KVM_ROUTINES */
d282 1
a282 1
void InitLoadPoint()
d287 4
a290 4
void GetLoadPoint( w, closure, call_data )
     Widget   w;              /* unused */
     XtPointer  closure;        /* unused */
     XtPointer  call_data;      /* pointer to (double) return value */
d343 1
a343 1
void InitLoadPoint()
d350 4
a353 4
void GetLoadPoint( w, closure, call_data )
     Widget	w;		/* unused */
     XtPointer	closure;	/* unused */
     XtPointer	call_data;	/* pointer to (double) return value */
d375 1
a375 1
#ifdef __DARWIN__
d381 1
a381 1
void InitLoadPoint()
d387 4
a390 4
void GetLoadPoint( w, closure, call_data )
    Widget	w;		/* unused */
    XtPointer	closure;	/* unused */
    XtPointer	call_data;	/* pointer to (double) return value */
d407 1
a407 1
#else /* __DARWIN__ */
d458 1
a458 1
InitLoadPoint()
d467 4
a470 4
GetLoadPoint( w, closure, call_data )           /* QNX NTO version */
Widget  w;              /* unused */
XtPointer closure;      /* unused */
XtPointer call_data;    /* pointer to (double) return value */
d500 1
a500 1
void InitLoadPoint()
d521 4
a524 4
void GetLoadPoint(w, closure, call_data)
     Widget w;          /* unused */
     XtPointer closure;   /* unused */
     XtPointer call_data; /* ptr to (double) return value */
d539 1
a539 1
#if defined(BSD) && (BSD >= 199306)
d541 3
d560 1
a560 31
#else /* not BSD >= 199306 */
#if defined(sun) && defined(HAVE_LIBKSTAT)

static kstat_t		*ksp;
static kstat_ctl_t	*kc;

void
InitLoadPoint(void)
{
	if ((kc = kstat_open()) == NULL)
		xload_error("kstat_open failed:", strerror(errno));

	if ((ksp = kstat_lookup(kc, "unix", 0, "system_misc")) == NULL)
		xload_error("kstat_lookup failed:", strerror(errno));
}

void
GetLoadPoint(Widget w, XtPointer closure, XtPointer call_data)
{
	kstat_named_t *vp;
	double *loadavg = (double *)call_data;

	if (kstat_read(kc, ksp, NULL) == -1)
		xload_error("kstat_read failed:", strerror(errno));

	if ((vp = kstat_data_lookup(ksp, "avenrun_1min")) == NULL)
		xload_error("kstat_data_lookup failed:", strerror(errno));

	*loadavg = (double)vp->value.l / FSCALE;
}
#else /* not Solaris */
a579 3
#ifdef macII
#define KERNEL_FILE "/unix"
#endif /* macII */
a608 4
#if defined(sun) && defined(SVR4)
#define KERNEL_FILE "/kernel/unix"
#endif

a716 10
#ifdef macII
static struct var v;
static int pad[2];	/* This padding is needed if xload compiled on */
			/* a/ux 1.1 is executed on a/ux 1.0, because */
			/* the var structure had too much padding in 1.0, */
			/* so the 1.0 kernel writes past the end of the 1.1 */
			/* var structure in the uvar() call. */
static struct nlist nl[2];
static struct lavnum vec[3];
#else /* not macII */
a721 1
#endif /* macII */
d728 1
a728 23
#ifdef macII
    extern nlist();

    int i;

    strcpy(nl[0].n_name, "avenrun");
    nl[1].n_name[0] = '\0';

    kmem = open(KMEM_FILE, O_RDONLY);
    if (kmem < 0) {
	xload_error("cannot open", KMEM_FILE);
    }

    uvar(&v);

    if (nlist( KERNEL_FILE, nl) != 0) {
	xload_error("cannot get name list from", KERNEL_FILE);
    }
    for (i = 0; i < 2; i++) {
	nl[i].n_value = (int)nl[i].n_value - v.v_kvoffset;
    }
#else /* not macII */
#if !defined(SVR4) && !defined(sgi) && !defined(MOTOROLA) && !defined(AIXV5) && !(BSD >= 199103)
a761 1
#endif /* macII else */
a771 3
#ifdef macII
	lseek(kmem, (long)nl[X_AVENRUN].n_value, 0);
#else
a772 1
#endif
d774 1
a774 1
#if defined(sun) || defined (UTEK) || defined(sequent) || defined(alliant) || defined(SVR4) || defined(sgi) || defined(hcx) || (BSD >= 199103)
d780 1
a780 7
#else /* else not sun or UTEK or sequent or alliant or SVR4 or sgi or hcx */
# ifdef macII
        {
                read(kmem, vec, 3*sizeof(struct lavnum));
                *loadavg = fxtod(0);
        }
# else /* else not macII */
d911 1
a911 2
# endif /* macII else */
#endif /* sun or SVR4 or ... else */	
d914 1
a914 2
#endif /* sun else */
#endif /* BSD >= 199306 else */
d919 1
a919 1
#endif /* __DARWIN__ else */
a921 1
#endif /* KVM_ROUTINES else */
d924 1
a924 2
void xload_error(str1, str2)
char *str1, *str2;
a932 88

#endif /* apollo else */

#else /* !DGUX */

/* INTEL DGUX Release 4.20MU04
 * Copyright 1999 Takis Psarogiannakopoulos
 * Cambridge, UK
 * <takis@@dpmms.cam.ac.uk>
 */

#include <errno.h>
#include <nlist.h>
#include <sys/dg_sys_info.h>

static struct dg_sys_info_load_info load_info;  /* DG/ux */

#define KERNEL_FILE "/dgux"
#define LDAV_SYMBOL "_avenrun"

void InitLoadPoint()
{

}

void GetLoadPoint(w, closure, call_data)
     Widget w;          /* unused */
     XtPointer closure;   /* unused */
     XtPointer call_data; /* ptr to (double) return value */
{
  double *loadavg = (double *)call_data;

  if (getloadavg(loadavg, 1) < 0)
    xload_error("couldn't obtain load average", "");
}

xload_error(str1, str2)
char *str1, *str2;
{
    (void) fprintf(stderr,"xload: %s %s\n", str1, str2);
    exit(-1);
}

#if !defined (LDAV_CVT) && defined (FSCALE)
#define LDAV_CVT(n) (((double) (n)) / FSCALE)
#endif
#if !defined(LDAV_CVT) && defined(LOAD_AVE_CVT)
#define LDAV_CVT(n) (LOAD_AVE_CVT (n) / 100.0)
#endif
#define LOAD_AVE_TYPE double
#ifndef LDAV_CVT
#define LDAV_CVT(n) ((double) (n))
#endif /* !LDAV_CVT */
static int channel;
static int getloadavg_initialized;
static long offset;
static struct nlist nl[2];


/* GETLOADAVG FUNCTION FOR DG/ux R4.20MU04 */

int
getloadavg (double loadavg[], int nelem)
{
  int elem = 0;                 /* Return value.  */
  int result =0 ;

  /* This call can return -1 for an error, but with good args
     it's not supposed to fail.  The first argument is for no
     apparent reason of type `long int *'.  */
  result = dg_sys_info ((long int *) &load_info,
		DG_SYS_INFO_LOAD_INFO_TYPE, DG_SYS_INFO_LOAD_VERSION_0);
  if ( result == -1)
  {
     return(-1);
  }
  if (nelem > 0)
    loadavg[elem++] = load_info.one_minute;
  if (nelem > 1)
    loadavg[elem++] = load_info.five_minute;
  if (nelem > 2)
    loadavg[elem++] = load_info.fifteen_minute;

  return elem;
}

#endif /* END OF DG/ux */

@


1.1.1.1
log
@Importing from X.Org 7.2RC2
@
text
@@
