head	1.6;
access;
symbols
	OPENBSD_6_1:1.6.0.8
	OPENBSD_6_1_BASE:1.6
	OPENBSD_6_0:1.6.0.6
	OPENBSD_6_0_BASE:1.6
	OPENBSD_5_9:1.6.0.4
	OPENBSD_5_9_BASE:1.6
	OPENBSD_5_8:1.6.0.2
	OPENBSD_5_8_BASE:1.6
	OPENBSD_5_7:1.5.0.14
	OPENBSD_5_7_BASE:1.5
	OPENBSD_5_6:1.5.0.12
	OPENBSD_5_6_BASE:1.5
	OPENBSD_5_5:1.5.0.10
	OPENBSD_5_5_BASE:1.5
	OPENBSD_5_4:1.5.0.8
	OPENBSD_5_4_BASE:1.5
	OPENBSD_5_3:1.5.0.6
	OPENBSD_5_3_BASE:1.5
	OPENBSD_5_2:1.5.0.4
	OPENBSD_5_2_BASE:1.5
	OPENBSD_5_1_BASE:1.5
	OPENBSD_5_1:1.5.0.2
	OPENBSD_5_0:1.4.0.6
	OPENBSD_5_0_BASE:1.4
	OPENBSD_4_9:1.4.0.2
	OPENBSD_4_9_BASE:1.4
	OPENBSD_4_8:1.4.0.4
	OPENBSD_4_8_BASE:1.4
	OPENBSD_4_7:1.2.0.10
	OPENBSD_4_7_BASE:1.2
	OPENBSD_4_6:1.2.0.8
	OPENBSD_4_6_BASE:1.2
	OPENBSD_4_5:1.2.0.6
	OPENBSD_4_5_BASE:1.2
	OPENBSD_4_4:1.2.0.4
	OPENBSD_4_4_BASE:1.2
	OPENBSD_4_3_BASE:1.2
	OPENBSD_4_3:1.2.0.2
	v1_1_6:1.1.1.3
	OPENBSD_4_2:1.1.1.2.0.2
	OPENBSD_4_2_BASE:1.1.1.2
	v1_1_4:1.1.1.2
	v1_0_4:1.1.1.1
	xorg:1.1.1;
locks; strict;
comment	@ * @;


1.6
date	2015.03.15.17.20.41;	author matthieu;	state Exp;
branches;
next	1.5;
commitid	wERYjrOEPdlEBpNy;

1.5
date	2011.11.15.20.53.45;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2010.04.06.22.09.09;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2010.03.28.09.33.02;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2008.01.01.21.26.57;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.25.20.32.34;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.11.25.20.32.34;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2007.08.05.19.01.04;	author matthieu;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2007.09.15.15.13.39;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.6
log
@Allow the greeter to set the input fields bg color
A new 'inpColor' resource is added for that.

Already commited upstream.
@
text
@/*

Copyright 1988, 1998  The Open Group

Permission to use, copy, modify, distribute, and sell this software and its
documentation for any purpose is hereby granted without fee, provided that
the above copyright notice appear in all copies and that both that
copyright notice and this permission notice appear in supporting
documentation.

The above copyright notice and this permission notice shall be included
in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
IN NO EVENT SHALL THE OPEN GROUP BE LIABLE FOR ANY CLAIM, DAMAGES OR
OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
OTHER DEALINGS IN THE SOFTWARE.

Except as contained in this notice, the name of The Open Group shall
not be used in advertising or otherwise to promote the sale, use or
other dealings in this Software without prior written authorization
from The Open Group.

*/
/*
 * Copyright (c) 2006, Oracle and/or its affiliates. All rights reserved.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice (including the next
 * paragraph) shall be included in all copies or substantial portions of the
 * Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 */


/*
 * xdm - display manager daemon
 * Author:  Keith Packard, MIT X Consortium
 *
 * Login.c
 */

#include <X11/IntrinsicP.h>
#include <X11/StringDefs.h>
#include <X11/keysym.h>
#include <X11/DECkeysym.h>
#include <X11/Xfuncs.h>

#include <stdio.h>
#include <ctype.h>
#include <time.h>
#include <string.h>

#include "dm.h"
#include "dm_error.h"
#include "greet.h"
#include "LoginP.h"

#ifdef XPM
# include <sys/stat.h>
# include <unistd.h>
# include <X11/Xlib.h>
# include <X11/xpm.h>
# include <X11/extensions/shape.h>
#endif /* XPM */

#include <X11/cursorfont.h>

#ifdef USE_XINERAMA
# include <X11/extensions/Xinerama.h>
#endif

#ifdef USE_XFT
# include <X11/extensions/Xrender.h>
#endif

#ifndef DEBUG
# define XDM_ASSERT(a)	/* do nothing */
#else
# if defined(__STDC__) && __STDC_VERSION__ - 0 >= 199901L
#  define XDM_ASSERT(a)	if (!(a)) { \
	Debug("Assertion failed in %s() at file %s line %d\n", \
	      __func__, __FILE__, __LINE__); }
# else
#  define XDM_ASSERT(a)	if (!(a)) { \
	Debug("Assertion failed at file %s line %d\n", __FILE__, __LINE__); }
# endif
#endif

static void RedrawFail (LoginWidget w);
static void ResetLogin (LoginWidget w);
static void failTimeout (XtPointer client_data, XtIntervalId * id);
static void EraseCursor (LoginWidget w);
static void XorCursor (LoginWidget w);

#define offset(field) XtOffsetOf(LoginRec, login.field)
#define goffset(field) XtOffsetOf(WidgetRec, core.field)


static XtResource resources[] = {
    {XtNwidth, XtCWidth, XtRDimension, sizeof(Dimension),
	goffset(width), XtRImmediate,	(XtPointer) 0},
    {XtNheight, XtCHeight, XtRDimension, sizeof(Dimension),
	goffset(height), XtRImmediate,	(XtPointer) 0},
    {XtNx, XtCX, XtRPosition, sizeof (Position),
	goffset(x), XtRImmediate,	(XtPointer) -1},
    {XtNy, XtCY, XtRPosition, sizeof (Position),
	goffset(y), XtRImmediate,	(XtPointer) -1},
#ifndef USE_XFT
    {XtNforeground, XtCForeground, XtRPixel, sizeof(Pixel),
        offset(textpixel), XtRString,	XtDefaultForeground},
    {XtNpromptColor, XtCForeground, XtRPixel, sizeof(Pixel),
        offset(promptpixel), XtRString,	XtDefaultForeground},
    {XtNgreetColor, XtCForeground, XtRPixel, sizeof(Pixel),
        offset(greetpixel), XtRString,	XtDefaultForeground},
    {XtNfailColor, XtCForeground, XtRPixel, sizeof (Pixel),
	offset(failpixel), XtRString,	XtDefaultForeground},
#endif

#ifdef DANCING
/* added by Caolan McNamara */
	{XtNlastEventTime, XtCLastEventTime, XtRInt , sizeof (int),
	offset(lastEventTime), XtRImmediate,	(XtPointer)0},
/* end (caolan) */
#endif /* DANCING */

#ifdef XPM
/* added by Ivan Griffin (ivan.griffin@@ul.ie) */
        {XtNlogoFileName, XtCLogoFileName, XtRString, sizeof(char*),
        offset(logoFileName), XtRImmediate, (XtPointer)0},
        {XtNuseShape, XtCUseShape, XtRBoolean, sizeof(Boolean),
        offset(useShape), XtRImmediate, (XtPointer) True},
        {XtNlogoPadding, XtCLogoPadding, XtRInt, sizeof(int),
        offset(logoPadding), XtRImmediate, (XtPointer) 5},
/* end (ivan) */
#endif /* XPM */

/* added by Amit Margalit */
    {XtNhiColor, XtCForeground, XtRPixel, sizeof (Pixel),
	offset(hipixel), XtRString,	XtDefaultForeground},
    {XtNshdColor, XtCForeground, XtRPixel, sizeof (Pixel),
	offset(shdpixel), XtRString,	XtDefaultForeground},
    {XtNinpColor, XtCForeground, XtRPixel, sizeof (Pixel),
	offset(inppixel), XtRString,	XtDefaultBackground},
    {XtNframeWidth, XtCFrameWidth, XtRInt, sizeof(int),
        offset(outframewidth), XtRImmediate, (XtPointer) 1},
    {XtNinnerFramesWidth, XtCFrameWidth, XtRInt, sizeof(int),
        offset(inframeswidth), XtRImmediate, (XtPointer) 1},
    {XtNsepWidth, XtCFrameWidth, XtRInt, sizeof(int),
        offset(sepwidth), XtRImmediate, (XtPointer) 1},
/* end (amit) */

#ifndef USE_XFT
    {XtNfont, XtCFont, XtRFontStruct, sizeof (XFontStruct *),
	offset (textFont), XtRString,	"*-new century schoolbook-medium-r-normal-*-180-*"},
    {XtNpromptFont, XtCFont, XtRFontStruct, sizeof (XFontStruct *),
	offset (promptFont), XtRString, "*-new century schoolbook-bold-r-normal-*-180-*"},
    {XtNgreetFont, XtCFont, XtRFontStruct, sizeof (XFontStruct *),
	offset (greetFont), XtRString,	"*-new century schoolbook-bold-i-normal-*-240-*"},
    {XtNfailFont, XtCFont, XtRFontStruct, sizeof (XFontStruct *),
	offset (failFont), XtRString,	"*-new century schoolbook-bold-r-normal-*-180-*"},
#else /* USE_XFT */
    {XtNface, XtCFace, XtRXftFont, sizeof (XftFont *),
        offset (textFace), XtRString, "Serif-18"},
    {XtNpromptFace, XtCFace, XtRXftFont, sizeof (XftFont *),
        offset (promptFace), XtRString, "Serif-18:bold"},
    {XtNgreetFace, XtCFace, XtRXftFont, sizeof (XftFont *),
        offset (greetFace), XtRString, "Serif-24:italic"},
    {XtNfailFace, XtCFace, XtRXftFont, sizeof (XftFont *),
        offset (failFace), XtRString, "Serif-18:bold"},
    {XtNforeground, XtCForeground, XtRXftColor, sizeof(XftColor),
        offset(textcolor), XtRString,	XtDefaultForeground},
    {XtNpromptColor, XtCForeground, XtRXftColor, sizeof(XftColor),
        offset(promptcolor), XtRString,	XtDefaultForeground},
    {XtNgreetColor, XtCForeground, XtRXftColor, sizeof(XftColor),
        offset(greetcolor), XtRString,	XtDefaultForeground},
    {XtNfailColor, XtCForeground, XtRXftColor, sizeof (XftColor),
	offset(failcolor), XtRString,	XtDefaultForeground},
#endif
    {XtNgreeting, XtCGreeting, XtRString, sizeof (char *),
	offset(greeting), XtRString, "X Window System"},
    {XtNunsecureGreeting, XtCGreeting, XtRString, sizeof (char *),
	offset(unsecure_greet), XtRString, "This is an unsecure session"},
    {XtNnamePrompt, XtCNamePrompt, XtRString, sizeof (char *),
	offset(namePrompt), XtRString, "Login:  "},
    {XtNpasswdPrompt, XtCPasswdPrompt, XtRString, sizeof (char *),
	offset(passwdPrompt), XtRString, "Password:  "},
    {XtNfail, XtCFail, XtRString, sizeof (char *),
	offset(failMsg), XtRString,
	"Login incorrect or forbidden by policy"
    },
    {XtNchangePasswdMessage, XtCChangePasswdMessage, XtRString,
	sizeof (char *), offset(passwdChangeMsg), XtRString,
	(XtPointer) "Password Change Required" },
    {XtNfailTimeout, XtCFailTimeout, XtRInt, sizeof (int),
	offset(failTimeout), XtRImmediate, (XtPointer) 10},
    {XtNnotifyDone, XtCCallback, XtRFunction, sizeof (XtPointer),
	offset(notify_done), XtRFunction, (XtPointer) 0},
    {XtNsessionArgument, XtCSessionArgument, XtRString,	sizeof (char *),
	offset(sessionArg), XtRString, (XtPointer) 0 },
    {XtNsecureSession, XtCSecureSession, XtRBoolean, sizeof (Boolean),
	offset(secure_session), XtRImmediate, (XtPointer) False },
    {XtNallowAccess, XtCAllowAccess, XtRBoolean, sizeof (Boolean),
	offset(allow_access), XtRImmediate, (XtPointer) False },
    {XtNallowNullPasswd, XtCAllowNullPasswd, XtRBoolean, sizeof (Boolean),
	offset(allow_null_passwd), XtRImmediate, (XtPointer) False},
    {XtNallowRootLogin, XtCAllowRootLogin, XtRBoolean, sizeof(Boolean),
	offset(allow_root_login), XtRImmediate, (XtPointer) True},
    {XtNechoPasswd, XtCEchoPasswd, XtRBoolean, sizeof(Boolean),
	offset(echo_passwd), XtRImmediate, (XtPointer) False},
    {XtNechoPasswdChar, XtCEchoPasswdChar, XtRString,	sizeof (char *),
	offset(echo_passwd_char), XtRString, (XtPointer) "*" }
};

#undef offset
#undef goffset

#ifdef USE_XFT
# define F_MAX_WIDTH(f)	((w)->login.f##Face->max_advance_width)
# define F_ASCENT(f)	((w)->login.f##Face->ascent)
# define F_DESCENT(f)	((w)->login.f##Face->descent)
#else
# define F_MAX_WIDTH(f)	((w)->login.f##Font->max_bounds.width)
# define F_ASCENT(f)	((w)->login.f##Font->max_bounds.ascent)
# define F_DESCENT(f)	((w)->login.f##Font->max_bounds.descent)
#endif

#define TEXT_X_INC(w)		F_MAX_WIDTH(text)
#define TEXT_Y_INC(w)		(F_ASCENT(text) + F_DESCENT(text))

#define PROMPT_X_INC(w)	F_MAX_WIDTH(prompt)
#define PROMPT_Y_INC(w)	(F_ASCENT(prompt) + F_DESCENT(prompt))

#define GREET_X_INC(w)		F_MAX_WIDTH(greet)
#define GREET_Y_INC(w)		(F_ASCENT(greet) + F_DESCENT(greet))

#define FAIL_X_INC(w)		F_MAX_WIDTH(fail)
#define FAIL_Y_INC(w)		(F_ASCENT(fail) + F_DESCENT(fail))

#define Y_INC(w)	max (TEXT_Y_INC(w), PROMPT_Y_INC(w))


#define PROMPT_TEXT(w,n) 	((w)->login.prompts[n].promptText)
#define DEF_PROMPT_TEXT(w,n) 	((w)->login.prompts[n].defaultPrompt)
#define VALUE_TEXT(w,n) 	((w)->login.prompts[n].valueText)
#define VALUE_TEXT_MAX(w,n)	((w)->login.prompts[n].valueTextMax)
#define VALUE_SHOW_START(w,n)	((w)->login.prompts[n].valueShownStart)
#define VALUE_SHOW_END(w,n)	((w)->login.prompts[n].valueShownEnd)
#define PROMPT_STATE(w,n) 	((w)->login.prompts[n].state)
#define PROMPT_CURSOR(w,n)	((w)->login.prompts[n].cursor)

#define CUR_PROMPT_CURSOR(w)	PROMPT_CURSOR(w,w->login.activePrompt)

#define CUR_PROMPT_TEXT(w, n)	(PROMPT_TEXT(w,n) != NULL ? \
				 PROMPT_TEXT(w,n) : DEF_PROMPT_TEXT(w,n))

#ifdef USE_XFT

# define TEXT_COLOR(f)		(w->login.f##color.pixel)

# define TEXT_WIDTH(f, m, l) 	XmuXftTextWidth(XtDisplay (w), \
					w->login.f##Face, (FcChar8 *) m, l)
static int
XmuXftTextWidth(Display *dpy, XftFont *font, FcChar8 *string, int len);

# define DRAW_STRING(f, x, y, m, l) \
	/* Debug("DRAW_STRING(%s, %d, %d, %s, %d)\n", #f, x, y, m, l); */ \
	XftDrawString8 (w->login.draw, &w->login.f##color, w->login.f##Face, \
			x, y, (FcChar8 *) m, l)

#else

# define TEXT_COLOR(f)		(w->login.f##pixel)

# define TEXT_WIDTH(f, m, l) 	(XTextWidth (w->login.f##Font, m, l))

# define DRAW_STRING(f, x, y, m, l) \
	XDrawString (XtDisplay (w), XtWindow (w), w->login.f##GC, x, y, m, l)

#endif


#define STRING_WIDTH(f, s) 	TEXT_WIDTH (f, s, strlen(s))

/* Padded width of logo image, if compiled with XPM support */
#ifdef XPM
# define LOGO_W(w)     ((w)->login.logoWidth + ((w)->login.logoPadding * 2))
#else
# define LOGO_W(w)     0
#endif

#define TEXT_PROMPT_W(w, m) (STRING_WIDTH(prompt, m) + w->login.inframeswidth)

#define DEF_PROMPT_W(w,n) TEXT_PROMPT_W(w, w->login.prompts[n].defaultPrompt)
#define CUR_PROMPT_W(w,n)  (max(MAX_DEF_PROMPT_W(w), PROMPT_TEXT(w,n) ? \
		     TEXT_PROMPT_W(w, PROMPT_TEXT(w,n)) : 0))

#define MAX_DEF_PROMPT_W(w) (max(DEF_PROMPT_W(w,0), DEF_PROMPT_W(w,1)))

#define GREETING(w)	((w)->login.secure_session  && !(w)->login.allow_access ?\
				(w)->login.greeting : (w)->login.unsecure_greet)
#define GREET_X(w)	((int)((w->core.width - \
			     	STRING_WIDTH (greet, GREETING(w))) / 2))
#define GREET_Y(w)	(GREETING(w)[0] ? 2 * GREET_Y_INC (w) : 0)
#define GREET_W(w)	(max (STRING_WIDTH (greet, w->login.greeting), \
			      STRING_WIDTH (greet, w->login.unsecure_greet)) \
			 + LOGO_W(w))

#define PROMPT_X(w)	(2 * PROMPT_X_INC(w))
#define PROMPT_Y(w,n)	((GREET_Y(w) + GREET_Y_INC(w) +\
			  F_ASCENT(greet) + Y_INC(w)) + \
			 (n * PROMPT_SPACE_Y(w)))
#define PROMPT_W(w)	(w->core.width - (2 * TEXT_X_INC(w)))
#define PROMPT_H(w)	(5 * Y_INC(w) / 4)
#define VALUE_X(w,n)	(PROMPT_X(w) + CUR_PROMPT_W(w,n))
#define CURSOR_W	5
#define MAX_VALUE_W(w,n) (PROMPT_W(w) - VALUE_X (w,n) - CURSOR_W - 1 - \
			  (w->login.inframeswidth * 2) - LOGO_W(w))
#define PROMPT_SPACE_Y(w)	(10 * Y_INC(w) / 5)

#define ERROR_X(w,m)	((int)(w->core.width - LOGO_W(w) - STRING_WIDTH (fail, m)) / 2)
#define FAIL_X(w)	ERROR_X(w, w->login.fail)
#define FAIL_Y(w)	(PROMPT_Y(w,1) + 2 * FAIL_Y_INC (w) + F_ASCENT(fail))

#define ERROR_W(w,m)	(STRING_WIDTH (fail, m) + LOGO_W(w))

#define FAIL_W(w)	max(ERROR_W(w, w->login.failMsg), \
			    ERROR_W(w, w->login.passwdChangeMsg))

#define PAD_X(w)	(2 * (PROMPT_X(w) + max (GREET_X_INC(w), FAIL_X_INC(w))))

#define PAD_Y(w)	(max (max (Y_INC(w), GREET_Y_INC(w)),\
			     FAIL_Y_INC(w)))

#ifndef max
static inline int max (int a, int b) { return a > b ? a : b; }
#endif

static void
realizeValue (LoginWidget w, int cursor, int promptNum, GC gc)
{
    loginPromptState state = PROMPT_STATE(w, promptNum);
    char *text = VALUE_TEXT(w, promptNum);
    int	x, y, height, width, curoff;

    XDM_ASSERT(promptNum >= 0 && promptNum <= LAST_PROMPT);

    /* replace all password characters with asterisks */
    if ((state == LOGIN_PROMPT_ECHO_OFF) && (w->login.echo_passwd == True))
    {
	Cardinal length = strlen(text);
	Cardinal i = 0;

	text = XtMalloc(length + 1);

	if (text == NULL)
	{
	    LogOutOfMem("realizeValue");
	    return;
	}

	while (i < length)
	{
	    text[i++] = w->login.echo_passwd_char[0];
	}

	text[i] = 0;
    }

    x = VALUE_X (w,promptNum);
    y = PROMPT_Y (w,promptNum);

    height = PROMPT_H(w) - (w->login.inframeswidth * 2);
    width = MAX_VALUE_W(w,promptNum);

    if (cursor > VALUE_SHOW_START(w, promptNum))
	curoff = TEXT_WIDTH (text, text, cursor);
    else
	curoff = 0;


    if (gc == w->login.bgGC) {
	if (curoff < width) {
	    XFillRectangle (XtDisplay (w), XtWindow (w), gc,
			    x + curoff, y - TEXT_Y_INC(w),
			    width - curoff, height);
	}
    } else if ((state == LOGIN_PROMPT_ECHO_ON) || (state == LOGIN_TEXT_INFO) ||
	       ((state == LOGIN_PROMPT_ECHO_OFF) && (w->login.echo_passwd == True)))
    {
	int offset = max(cursor, VALUE_SHOW_START(w, promptNum));
	int textlen = strlen (text + offset);

	if (TEXT_WIDTH (text, text + offset, textlen) > (width - curoff)) {
	    /* Recalculate amount of text that can fit in field */
	    offset = VALUE_SHOW_START(w, promptNum);
	    textlen = strlen (text + offset);

	    while ((textlen > 0) &&
		   (TEXT_WIDTH (text, text + offset, textlen) > width))
	    {
		if (offset < PROMPT_CURSOR(w, promptNum)) {
		    offset++;
		}
		textlen--;
	    }

	    VALUE_SHOW_START(w, promptNum) = offset;
	    VALUE_SHOW_END(w, promptNum) = offset + textlen;

	    /* Erase old string */
	    XFillRectangle (XtDisplay (w), XtWindow (w), w->login.bgGC,
			    x, y - TEXT_Y_INC(w), width, height);

	    DRAW_STRING(text, x, y, text + offset, textlen);
	} else {
	    DRAW_STRING(text, x + curoff, y, text + offset, textlen);
	}
    }
    /* free memory */
    if ((state == LOGIN_PROMPT_ECHO_OFF) && (w->login.echo_passwd == True))
    {
	XtFree(text);
    }
}

static void
EraseValue (LoginWidget w, int cursor, int promptNum)
{
    realizeValue(w, cursor, promptNum, w->login.bgGC);
}

static void
DrawValue (LoginWidget w, int cursor, int promptNum)
{
    realizeValue(w, cursor, promptNum, w->login.textGC);
#ifdef DANCING
    /*as good a place as any Caolan begin*/
    w->login.lastEventTime = time(NULL);
    /*as good a place as any Caolan end*/
#endif /* DANCING */
}

static void
realizeCursor (LoginWidget w, GC gc)
{
    int	x, y;
    int height, width;

    if (w->login.state != PROMPTING) {
	return;
    }

    x = VALUE_X (w, w->login.activePrompt);
    y = PROMPT_Y (w, w->login.activePrompt);
    height = (F_ASCENT(text) + F_DESCENT(text));
    width = 1;

    switch (PROMPT_STATE(w, w->login.activePrompt)) {
    case LOGIN_PROMPT_NOT_SHOWN:
    case LOGIN_TEXT_INFO:
	return;
    case LOGIN_PROMPT_ECHO_ON:
	if (CUR_PROMPT_CURSOR(w) > 0) {
	    x += TEXT_WIDTH (text,
			     VALUE_TEXT(w, w->login.activePrompt)
			     + VALUE_SHOW_START(w, w->login.activePrompt),
			     PROMPT_CURSOR(w, w->login.activePrompt)
			     - VALUE_SHOW_START(w, w->login.activePrompt) );
	}
	break;
    case LOGIN_PROMPT_ECHO_OFF:
	if (w->login.echo_passwd == True) {
	    if (w->login.echo_passwd_char[0] != 0) {
		int len = PROMPT_CURSOR(w, w->login.activePrompt) -
		    VALUE_SHOW_START(w, w->login.activePrompt);

		x += len*TEXT_WIDTH(text, w->login.echo_passwd_char, 1);
	    } else {
		/* Move cursor one pixel per character to give some feedback
		   without giving away the password length */
		if (PROMPT_CURSOR(w, w->login.activePrompt) <
		    MAX_VALUE_W(w, w->login.activePrompt))
		    x += PROMPT_CURSOR(w, w->login.activePrompt);
		else
		    x += MAX_VALUE_W(w, w->login.activePrompt);
	    }
	}
	break;
    }

    XFillRectangle (XtDisplay (w), XtWindow (w), gc,
		    x, y+1 - F_ASCENT(text), width, height-1);
    XDrawPoint     (XtDisplay (w), XtWindow (w), gc,
		    x-1 , y - F_ASCENT(text));
    XDrawPoint     (XtDisplay (w), XtWindow (w), gc,
		    x+1 , y - F_ASCENT(text));
    XDrawPoint     (XtDisplay (w), XtWindow (w), gc,
		    x-1 , y - F_ASCENT(text)+height);
    XDrawPoint     (XtDisplay (w), XtWindow (w), gc,
		    x+1 , y - F_ASCENT(text)+height);
    XDrawPoint     (XtDisplay (w), XtWindow (w), gc,
		    x-2 , y - F_ASCENT(text));
    XDrawPoint     (XtDisplay (w), XtWindow (w), gc,
		    x+2 , y - F_ASCENT(text));
    XDrawPoint     (XtDisplay (w), XtWindow (w), gc,
		    x-2 , y - F_ASCENT(text)+height);
    XDrawPoint     (XtDisplay (w), XtWindow (w), gc,
		    x+2 , y - F_ASCENT(text)+height);

    XFlush (XtDisplay(w));
}

static void
EraseFail (LoginWidget w)
{
#ifdef USE_XFT
    w->login.failUp = 0;
    RedrawFail(w);
#else
    XSetForeground (XtDisplay (w), w->login.failGC,
			w->core.background_pixel);
    RedrawFail(w);
    w->login.failUp = 0;
    XSetForeground (XtDisplay (w), w->login.failGC,
			TEXT_COLOR(fail));
#endif
}

static void
XorCursor (LoginWidget w)
{
    realizeCursor (w, w->login.xorGC);
}

static void
RemoveFail (LoginWidget w)
{
    if (w->login.failUp)
	EraseFail (w);
}

static void
EraseCursor (LoginWidget w)
{
    realizeCursor (w, w->login.bgGC);
}

/*ARGSUSED*/
static void failTimeout (XtPointer client_data, XtIntervalId * id)
{
    LoginWidget	w = (LoginWidget)client_data;

    Debug ("failTimeout\n");
    w->login.interval_id = 0;
    EraseFail (w);
}

_X_INTERNAL
void
DrawFail (Widget ctx)
{
    LoginWidget	w;

    w = (LoginWidget) ctx;
    XorCursor (w);
    ResetLogin (w);
    XorCursor (w);
    ErrorMessage(ctx, w->login.failMsg, True);
}

static void
RedrawFail (LoginWidget w)
{
    int x = FAIL_X(w);
    int y = FAIL_Y(w);
    int maxw = w->core.width - PAD_X(w);

#ifndef USE_XFT
    if (w->login.failUp)
#endif
    {
	Debug("RedrawFail('%s', %d)\n", w->login.fail, w->login.failUp);
	if (ERROR_W(w, w->login.fail) > maxw) {
	    /* Too long to fit on one line, break into multiple lines */
	    char *tempCopy = strdup(w->login.fail);
	    if (tempCopy != NULL) {
		char *start, *next;
		char lastspace = ' ';

		y = PROMPT_Y(w,LAST_PROMPT) + (2 * PROMPT_Y_INC(w));

		for (start = next = tempCopy; start != NULL ; start = next) {
		    /* search for longest string broken by whitespace that
		       will fit on a single line */
		    do {
			if (next != start) {
			    *next = lastspace;
			}
			for (next = next + 1;
			     (*next != '\0') && !isspace(*next) ; next++)
			{
			    /* this loop intentionally left blank */
			}
			if (*next != '\0') {
			    lastspace = *next;
			    *next = '\0';
			} else {
			    next = NULL;
			}
		    } while ((next != NULL) && ERROR_W(w, start) < maxw);

		    x = ERROR_X(w, start);
#ifdef USE_XFT
		    if (w->login.failUp == 0) {
			XClearArea(XtDisplay(w), XtWindow(w), x, y - F_ASCENT(fail),
				   ERROR_W(w, start), FAIL_Y_INC(w), False);
		    } else
#endif
			DRAW_STRING (fail, x, y, start, strlen(start));

		    if (next != NULL) {
			next++;
			y += FAIL_Y_INC(w);
		    }
		}
		free(tempCopy);
		return;
	    }
	    /* if strdup failed, fall through to draw all at once, even
	       though we know it can't all fit */
	    LogOutOfMem("RedrawFail");
	}

#ifdef USE_XFT
	if (w->login.failUp == 0) {
	    XClearArea(XtDisplay(w), XtWindow(w), x, y - F_ASCENT(fail),
		       ERROR_W(w, w->login.fail), FAIL_Y_INC(w), False);
	} else
#endif
	    DRAW_STRING (fail, x, y, w->login.fail, strlen (w->login.fail));
    }
}

_X_INTERNAL
void
ErrorMessage(Widget ctx, const char *message, Bool timeout)
{
    LoginWidget	w = (LoginWidget) ctx;

/*  Debug("ErrorMessage: %s\n", message);   */
    if (w->login.interval_id != 0) {
	XtRemoveTimeOut(w->login.interval_id);
	w->login.interval_id = 0;
    }
    RemoveFail(w);
    if (w->login.fail != w->login.failMsg)
	free(w->login.fail);
    w->login.fail = strdup(message);
    if (w->login.fail == NULL)
	w->login.fail = (char *) w->login.failMsg;
    w->login.failUp = 1;
    RedrawFail (w);
    if (timeout && (w->login.failTimeout > 0)) {
	Debug ("failTimeout: %d\n", w->login.failTimeout);
	w->login.interval_id =
	    XtAppAddTimeOut(XtWidgetToApplicationContext ((Widget)w),
			    w->login.failTimeout * 1000,
			    failTimeout, (XtPointer) w);
    }
}

_X_INTERNAL
void
ShowChangePasswdMessage(Widget ctx)
{
    LoginWidget	w = (LoginWidget) ctx;

    ErrorMessage(ctx, w->login.passwdChangeMsg, False);
}

static void
draw_it (LoginWidget w)
{
    int p;
    int i;
    int gr_line_x, gr_line_y, gr_line_w;

    EraseCursor (w);

    /* draw window borders */
    for(i=1;i<=(w->login.outframewidth);i++)
    {
      XDrawLine(XtDisplay (w), XtWindow (w), w->login.hiGC,
		i-1,i-1,w->core.width-i,i-1);
      XDrawLine(XtDisplay (w), XtWindow (w), w->login.hiGC,
		i-1,i-1,i-1,w->core.height-i);
      XDrawLine(XtDisplay (w), XtWindow (w), w->login.shdGC,
		w->core.width-i,i-1,w->core.width-i,w->core.height-i);
      XDrawLine(XtDisplay (w), XtWindow (w), w->login.shdGC,
		i-1,w->core.height-i,w->core.width-i,w->core.height-i);
    }

    /* make separator line */
    gr_line_x = w->login.outframewidth;
    gr_line_y = GREET_Y(w) + GREET_Y_INC(w);
    gr_line_w = w->core.width - 2*(w->login.outframewidth);

#ifdef XPM
    gr_line_x += w->login.logoPadding;
    gr_line_w -= w->login.logoWidth + (3 * (w->login.logoPadding));
#endif /* XPM */

    for(i=1;i<=(w->login.sepwidth);i++)
    {
      XDrawLine(XtDisplay (w), XtWindow (w), w->login.shdGC,
        gr_line_x,           gr_line_y + i-1,
        gr_line_x+gr_line_w, gr_line_y + i-1);
      XDrawLine(XtDisplay (w), XtWindow (w), w->login.hiGC,
        gr_line_x,           gr_line_y + 2*(w->login.inframeswidth) -i,
        gr_line_x+gr_line_w, gr_line_y + 2*(w->login.inframeswidth) -i);
    }

    for (p = 0; p < NUM_PROMPTS ; p++)
    {
	int in_frame_x = VALUE_X(w,p) - w->login.inframeswidth - 3;
	int in_frame_y
	    = PROMPT_Y(w,p) - w->login.inframeswidth - 1 - TEXT_Y_INC(w);

	int in_width = PROMPT_W(w) - VALUE_X(w,p) - LOGO_W(w);
	int in_height = PROMPT_H(w) + w->login.inframeswidth + 2;

	GC topLeftGC, botRightGC, inpGC;

	if ((PROMPT_STATE(w, p) == LOGIN_PROMPT_ECHO_ON) ||
	    (PROMPT_STATE(w, p) == LOGIN_PROMPT_ECHO_OFF)) {
	    topLeftGC = w->login.shdGC;
	    botRightGC = w->login.hiGC;
	    inpGC = w->login.inpGC;
	} else {
	    topLeftGC = botRightGC = inpGC = w->login.bgGC;
	}

	/* draw borders of editboxes */
	for (i=1; i<=(w->login.inframeswidth); i++)
	{
	    /* Make top/left sides */
	    XDrawLine(XtDisplay (w), XtWindow (w), topLeftGC,
		      in_frame_x + i-1,         in_frame_y + i-1,
		      in_frame_x + in_width-i,  in_frame_y + i-1);

	    XDrawLine(XtDisplay (w), XtWindow (w), topLeftGC,
		      in_frame_x + i-1,         in_frame_y + i-1,
		      in_frame_x + i-1,         in_frame_y + in_height-i);

	    /* Make bottom/right sides */
	    XDrawLine(XtDisplay (w), XtWindow (w), botRightGC,
		      in_frame_x + in_width-i,  in_frame_y + i-1,
		      in_frame_x + in_width-i,  in_frame_y + in_height-i);

	    XDrawLine(XtDisplay (w), XtWindow (w), botRightGC,
		      in_frame_x + i-1,         in_frame_y + in_height-i,
		      in_frame_x + in_width-i,  in_frame_y + in_height-i);
	}
	XFillRectangle(XtDisplay (w), XtWindow (w), inpGC,
	    in_frame_x + w->login.inframeswidth,
	    in_frame_y + w->login.inframeswidth,
	    in_width - 2*w->login.inframeswidth,
	    in_height - 2*w->login.inframeswidth);
    }

    if (GREETING(w)[0]) {
	int gx = GREET_X(w);

#ifdef XPM
	gx -= ((w->login.logoWidth/2) + w->login.logoPadding);
#endif
	DRAW_STRING (greet, gx, GREET_Y(w), GREETING(w), strlen (GREETING(w)));
    }
    for (p = 0; p < NUM_PROMPTS ; p++) {
	if (PROMPT_STATE(w, p) != LOGIN_PROMPT_NOT_SHOWN) {
	    DRAW_STRING (prompt, PROMPT_X(w), PROMPT_Y(w,p),
			 CUR_PROMPT_TEXT(w,p), strlen (CUR_PROMPT_TEXT(w,p)));
	    DrawValue (w, 0, p);
	}
    }
    RedrawFail (w);
    XorCursor (w);
    XSetInputFocus (XtDisplay (w), XtWindow (w),
		    RevertToPointerRoot, CurrentTime);
}

/* Returns 0 on success, -1 on failure */
_X_INTERNAL
int
SetPrompt (Widget ctx, int promptNum, const char *message,
	   loginPromptState state, Boolean minimumTime)
{
    LoginWidget	w = (LoginWidget) ctx;
    char *prompt;
    int messageLen, e;
    const char *stateNames[4] = {
	"LOGIN_PROMPT_NOT_SHOWN", "LOGIN_PROMPT_ECHO_ON",
	"LOGIN_PROMPT_ECHO_OFF", "LOGIN_TEXT_INFO" };
    loginPromptState priorState;

    Debug("SetPrompt(%d, %s, %s(%d))\n", promptNum,
	  message ? message : "<NULL>", stateNames[state], state);

    XDM_ASSERT(promptNum >= 0 && promptNum <= LAST_PROMPT);

    if (PROMPT_TEXT(w, promptNum) != NULL) {
	XtFree(PROMPT_TEXT(w, promptNum));
	PROMPT_TEXT(w, promptNum) = NULL;
    }

    priorState = PROMPT_STATE(w, promptNum);
    PROMPT_STATE(w, promptNum) = state;

    if (state == LOGIN_PROMPT_NOT_SHOWN) {
	return 0;
    }

    if (message == NULL) {
	message = DEF_PROMPT_TEXT(w, promptNum);
    }

    messageLen = strlen(message);

    prompt = XtMalloc(messageLen + 3);
    if (prompt == NULL) {
	LogOutOfMem ("SetPrompt");
	return -1;
    }

    strncpy(prompt, message, messageLen);

    /* Make sure text prompts have at least two spaces at end */
    e = messageLen;

    if (!isspace(message[messageLen - 2])) {
	prompt[e] = ' ';
	e++;
    }
    if (!isspace(message[messageLen - 1])) {
	prompt[e] = ' ';
	e++;
    }
    prompt[e] = '\0';

    PROMPT_TEXT(w, promptNum) = prompt;

    if (w->login.state == INITIALIZING) {
	return 0;
    }

    if ((priorState == LOGIN_TEXT_INFO) && (w->login.msgTimeout != 0)) {
	time_t now = time(NULL);
	int timeleft = w->login.msgTimeout - now;

	if (timeleft > 0) {
	    sleep(timeleft);
	}
	w->login.msgTimeout = 0;
    }

    if (state == LOGIN_TEXT_INFO) {
	if (minimumTime) {
	    time_t now = time(NULL);
	    w->login.msgTimeout = now + w->login.failTimeout;
	}
	w->login.state = SHOW_MESSAGE;
    } else {
	w->login.activePrompt = promptNum;
	w->login.state = PROMPTING;
    }

    PROMPT_CURSOR(w, promptNum) = 0;
    XClearArea (XtDisplay(w), XtWindow(w), 0, 0, 0, 0, FALSE);
    draw_it(w);
    return 0;
}

_X_INTERNAL
const char *
GetPrompt(Widget ctx, int promptNum)
{
    LoginWidget	w = (LoginWidget) ctx;

    XDM_ASSERT(promptNum >= 0 && promptNum <= LAST_PROMPT);

    return CUR_PROMPT_TEXT(w,promptNum);
}

_X_INTERNAL
int
SetValue(Widget ctx, int promptNum, char *value)
{
    LoginWidget	w = (LoginWidget) ctx;

    XDM_ASSERT(promptNum >= 0 && promptNum <= LAST_PROMPT);

    if ((promptNum < 0) || (promptNum > LAST_PROMPT))
	return -1;

    XDM_ASSERT(VALUE_TEXT(w, promptNum) != NULL);

    if (VALUE_TEXT(w, promptNum) == NULL)
	return -1;

    if (value == NULL) {
	bzero(VALUE_TEXT(w, promptNum), VALUE_TEXT_MAX(w, promptNum));
    } else {
	strncpy(VALUE_TEXT(w, promptNum), value, VALUE_TEXT_MAX(w, promptNum));
	VALUE_TEXT(w, promptNum)[VALUE_TEXT_MAX(w, promptNum)] = '\0';
    }

    VALUE_SHOW_START(w, promptNum) = 0;
    VALUE_SHOW_END(w, promptNum) = 0;
    PROMPT_CURSOR(w, promptNum) = 0;

    return 0;
}

_X_INTERNAL
const char *
GetValue(Widget ctx, int promptNum)
{
    LoginWidget	w = (LoginWidget) ctx;

    XDM_ASSERT(promptNum >= 0 && promptNum <= LAST_PROMPT);

    if ((promptNum < 0) || (promptNum > LAST_PROMPT))
	return NULL;

    XDM_ASSERT(VALUE_TEXT(w, promptNum) != NULL);

    return VALUE_TEXT(w, promptNum);
}


static void
realizeDeleteChar (LoginWidget ctx)
{
    if (ctx->login.state == PROMPTING) {
	int promptNum = ctx->login.activePrompt;
	int redrawFrom = PROMPT_CURSOR(ctx, promptNum);

	if (PROMPT_CURSOR(ctx,promptNum) <  (int)strlen(VALUE_TEXT(ctx,promptNum))) {
	    if (redrawFrom < VALUE_SHOW_START(ctx, ctx->login.activePrompt)) {
		redrawFrom = 0;
		EraseValue (ctx, redrawFrom, promptNum);
		VALUE_SHOW_START(ctx, ctx->login.activePrompt)
		    = PROMPT_CURSOR(ctx,promptNum);
	    } else {
		EraseValue (ctx, redrawFrom, promptNum);
	    }
	    strcpy(VALUE_TEXT(ctx, promptNum) + PROMPT_CURSOR(ctx, promptNum),
		   VALUE_TEXT(ctx, promptNum) + PROMPT_CURSOR(ctx, promptNum) + 1);
	    DrawValue (ctx, redrawFrom, promptNum);
	}
    }
}

/*ARGSUSED*/
static void
DeleteBackwardChar (Widget ctxw, XEvent *event, String *params, Cardinal *num_params)
{
    LoginWidget ctx = (LoginWidget)ctxw;

    RemoveFail (ctx);

    if (ctx->login.state != PROMPTING) {
	return;
    }

    XorCursor (ctx);
    if (CUR_PROMPT_CURSOR(ctx) > 0) {
	CUR_PROMPT_CURSOR(ctx) -= 1;
	realizeDeleteChar(ctx);
    }
    XorCursor (ctx);
}

/*ARGSUSED*/
static void
DeleteForwardChar (Widget ctxw, XEvent *event, String *params, Cardinal *num_params)
{
    LoginWidget ctx = (LoginWidget)ctxw;

    RemoveFail (ctx);

    if (ctx->login.state != PROMPTING) {
	return;
    }

    XorCursor (ctx);
    realizeDeleteChar(ctx);
    XorCursor (ctx);
}

/*ARGSUSED*/
static void
MoveBackwardChar (
    Widget	ctxw,
    XEvent	*event,
    String	*params,
    Cardinal	*num_params)
{
    LoginWidget	ctx = (LoginWidget)ctxw;

    RemoveFail (ctx);

    if (ctx->login.state != PROMPTING) {
	return;
    }

    XorCursor (ctx);
    if (CUR_PROMPT_CURSOR(ctx) > 0)
	CUR_PROMPT_CURSOR(ctx) -= 1;
    if (CUR_PROMPT_CURSOR(ctx) < VALUE_SHOW_START(ctx, ctx->login.activePrompt)) {
	EraseValue(ctx, 0, ctx->login.activePrompt);
	VALUE_SHOW_START(ctx, ctx->login.activePrompt)
	    = CUR_PROMPT_CURSOR(ctx);
	DrawValue(ctx, 0, ctx->login.activePrompt);
    }
    XorCursor (ctx);
}

/*ARGSUSED*/
static void
MoveForwardChar (
    Widget	ctxw,
    XEvent	*event,
    String	*params,
    Cardinal	*num_params)
{
    LoginWidget ctx = (LoginWidget)ctxw;

    RemoveFail (ctx);

    if (ctx->login.state != PROMPTING) {
	return;
    }

    XorCursor (ctx);
    if (CUR_PROMPT_CURSOR(ctx) <
	(int)strlen(VALUE_TEXT(ctx,ctx->login.activePrompt))) {
	CUR_PROMPT_CURSOR(ctx) += 1;
	if (VALUE_SHOW_END(ctx, ctx->login.activePrompt)
	    < CUR_PROMPT_CURSOR(ctx)) {
	    EraseValue(ctx, 0, ctx->login.activePrompt);
	    DrawValue(ctx, 0, ctx->login.activePrompt);
	}
    }
    XorCursor (ctx);
}

/*ARGSUSED*/
static void
MoveToBegining (
    Widget	ctxw,
    XEvent	*event,
    String	*params,
    Cardinal	*num_params)
{
    LoginWidget ctx = (LoginWidget)ctxw;

    RemoveFail (ctx);

    if (ctx->login.state != PROMPTING) {
	return;
    }

    XorCursor (ctx);
    CUR_PROMPT_CURSOR(ctx) = 0;
    if (VALUE_SHOW_START(ctx, ctx->login.activePrompt) > 0) {
	EraseValue(ctx, 0, ctx->login.activePrompt);
	VALUE_SHOW_START(ctx, ctx->login.activePrompt) = 0;
	DrawValue(ctx, 0, ctx->login.activePrompt);
    }
    XorCursor (ctx);
}

/*ARGSUSED*/
static void
MoveToEnd (
    Widget	ctxw,
    XEvent	*event,
    String	*params,
    Cardinal	*num_params)
{
    LoginWidget ctx = (LoginWidget)ctxw;

    RemoveFail (ctx);

    if (ctx->login.state != PROMPTING) {
	return;
    }

    XorCursor (ctx);
    CUR_PROMPT_CURSOR(ctx) = strlen (VALUE_TEXT(ctx, ctx->login.activePrompt));
    if (VALUE_SHOW_END(ctx, ctx->login.activePrompt) < CUR_PROMPT_CURSOR(ctx)) {
	EraseValue(ctx, 0, ctx->login.activePrompt);
	DrawValue(ctx, 0, ctx->login.activePrompt);
    }
    XorCursor (ctx);
}

/*ARGSUSED*/
static void
EraseToEndOfLine (
    Widget	ctxw,
    XEvent	*event,
    String	*params,
    Cardinal	*num_params)
{
    LoginWidget ctx = (LoginWidget)ctxw;

    RemoveFail (ctx);

    if (ctx->login.state != PROMPTING) {
	return;
    }

    XorCursor (ctx);
    EraseValue (ctx, CUR_PROMPT_CURSOR(ctx), ctx->login.activePrompt);
    bzero(VALUE_TEXT(ctx, ctx->login.activePrompt) +
	  CUR_PROMPT_CURSOR(ctx),
	  VALUE_TEXT_MAX(ctx, ctx->login.activePrompt) -
	  CUR_PROMPT_CURSOR(ctx));
    XorCursor (ctx);
}

/*ARGSUSED*/
static void
EraseLine (
    Widget	ctxw,
    XEvent	*event,
    String	*params,
    Cardinal	*num_params)
{
    MoveToBegining (ctxw, event, params, num_params);
    EraseToEndOfLine (ctxw, event, params, num_params);
}

/*ARGSUSED*/
static void
FinishField (
    Widget	ctxw,
    XEvent	*event,
    String	*params,
    Cardinal	*num_params)
{
    LoginWidget ctx = (LoginWidget)ctxw;
    int promptNum = ctx->login.activePrompt;
    int nextPrompt;

    RemoveFail (ctx);

    if (ctx->login.state != PROMPTING) {
	return;
    }

    XorCursor (ctx);

    for (nextPrompt = promptNum + 1; nextPrompt <= LAST_PROMPT; nextPrompt++) {
	if ((PROMPT_STATE(ctx, nextPrompt) == LOGIN_PROMPT_ECHO_ON) ||
	    (PROMPT_STATE(ctx, nextPrompt) == LOGIN_PROMPT_ECHO_OFF)) {
	    ctx->login.activePrompt = nextPrompt;
	    break;
	}
    }
    if (nextPrompt > LAST_PROMPT) {
	ctx->login.state = DONE;
	(*ctx->login.notify_done) (ctx, &ctx->login.data, NOTIFY_OK);
	Debug("FinishField #%d: now DONE\n", promptNum);
    } else {
	Debug("FinishField #%d: %d next\n", promptNum, nextPrompt);
    }

    XorCursor (ctx);
}

/*ARGSUSED*/
static void
TabField(Widget ctxw, XEvent *event, String *params, Cardinal *num_params)
{
    LoginWidget ctx = (LoginWidget)ctxw;
    int promptNum = ctx->login.activePrompt;
    int nextPrompt;

    RemoveFail (ctx);

    if (ctx->login.state != PROMPTING) {
	return;
    }

    XorCursor (ctx);

    for (nextPrompt = promptNum + 1; nextPrompt != promptNum; nextPrompt++) {
	if (nextPrompt > LAST_PROMPT) {
	    nextPrompt = 0;
	}

	if ((PROMPT_STATE(ctx, nextPrompt) == LOGIN_PROMPT_ECHO_ON) ||
	    (PROMPT_STATE(ctx, nextPrompt) == LOGIN_PROMPT_ECHO_OFF)) {
	    ctx->login.activePrompt = nextPrompt;
	    break;
	}
    }
    XorCursor (ctx);
}

/*ARGSUSED*/
static void
AllowAccess (
    Widget	ctxw,
    XEvent	*event,
    String	*params,
    Cardinal	*num_params)
{
    LoginWidget ctx = (LoginWidget)ctxw;
    Arg	arglist[1];
    Boolean allow;

    RemoveFail (ctx);
    XtSetArg (arglist[0], XtNallowAccess, (char *) &allow);
    XtGetValues ((Widget) ctx, arglist, 1);
    XtSetArg (arglist[0], XtNallowAccess, !allow);
    XtSetValues ((Widget) ctx, arglist, 1);
}

/*ARGSUSED*/
static void
SetSessionArgument (
    Widget	ctxw,
    XEvent	*event,
    String	*params,
    Cardinal	*num_params)
{
    LoginWidget ctx = (LoginWidget)ctxw;

    RemoveFail (ctx);
    if (ctx->login.sessionArg)
	XtFree (ctx->login.sessionArg);
    ctx->login.sessionArg = NULL;
    if (*num_params > 0) {
	ctx->login.sessionArg = XtMalloc (strlen (params[0]) + 1);
	if (ctx->login.sessionArg)
	    strcpy (ctx->login.sessionArg, params[0]);
	else
	    LogOutOfMem ("set session argument");
    }
}

/*ARGSUSED*/
static void
RestartSession (
    Widget	ctxw,
    XEvent	*event,
    String	*params,
    Cardinal	*num_params)
{
    LoginWidget ctx = (LoginWidget)ctxw;

    XorCursor (ctx);
    RemoveFail (ctx);
    ctx->login.state = DONE;
    (*ctx->login.notify_done) (ctx, &ctx->login.data, NOTIFY_RESTART);
    XorCursor (ctx);
}

/*ARGSUSED*/
static void
AbortSession (
    Widget	ctxw,
    XEvent	*event,
    String	*params,
    Cardinal	*num_params)
{
    LoginWidget ctx = (LoginWidget)ctxw;

    XorCursor (ctx);
    RemoveFail (ctx);
    ctx->login.state = DONE;
    (*ctx->login.notify_done) (ctx, &ctx->login.data, NOTIFY_ABORT);
    XorCursor (ctx);
}

/*ARGSUSED*/
static void
AbortDisplay (
    Widget	ctxw,
    XEvent	*event,
    String	*params,
    Cardinal	*num_params)
{
    LoginWidget ctx = (LoginWidget)ctxw;

    XorCursor (ctx);
    RemoveFail (ctx);
    ctx->login.state = DONE;
    (*ctx->login.notify_done) (ctx, &ctx->login.data, NOTIFY_ABORT_DISPLAY);
    XorCursor (ctx);
}

static void
ResetLogin (LoginWidget w)
{
    int i;

    for (i = 0; i < NUM_PROMPTS ; i++) {
	EraseValue(w, 0, i);
	bzero(VALUE_TEXT(w, i), VALUE_TEXT_MAX(w, i));
	VALUE_SHOW_START(w, i) = 0;
	PROMPT_CURSOR(w, i) = 0;
    }
    w->login.state = PROMPTING;
    w->login.activePrompt = 0;
}

static void
InitI18N(Widget ctxw)
{
    LoginWidget ctx = (LoginWidget)ctxw;
    XIM         xim = (XIM) NULL;
    char *p;

    ctx->login.xic = (XIC) NULL;

    if ((p = XSetLocaleModifiers("@@im=none")) != NULL && *p)
	xim = XOpenIM(XtDisplay(ctx), NULL, NULL, NULL);

    if (!xim) {
	LogError("Failed to open input method\n");
	return;
    }

    ctx->login.xic = XCreateIC(xim,
	XNInputStyle, (XIMPreeditNothing|XIMStatusNothing),
	XNClientWindow, ctx->core.window,
	XNFocusWindow,  ctx->core.window, NULL);

    if (!ctx->login.xic) {
	LogError("Failed to create input context\n");
	XCloseIM(xim);
    }
    return;
}

/* ARGSUSED */
static void
InsertChar (
    Widget	ctxw,
    XEvent	*event,
    String	*params,
    Cardinal	*num_params)
{
    LoginWidget ctx = (LoginWidget)ctxw;

    char strbuf[128];
    int  len, promptNum = ctx->login.activePrompt;
    KeySym  keysym = 0;

    if (ctx->login.xic) {
	static Status status;
	len = XmbLookupString(ctx->login.xic, &event->xkey, strbuf,
			      sizeof (strbuf), &keysym, &status);
    } else {
	static XComposeStatus compose_status = {NULL, 0};
	len = XLookupString (&event->xkey, strbuf, sizeof (strbuf),
			     &keysym, &compose_status);
    }
    strbuf[len] = '\0';

    /*
     * Note: You can override this default key handling
     * by the settings in the translation table
     * loginActionsTable at the end of this file.
     */
    switch (keysym) {
    case XK_Return:
    case XK_KP_Enter:
    case XK_Linefeed:
    case XK_Execute:
	FinishField(ctxw, event, params, num_params);
	return;
    case XK_BackSpace:
	DeleteBackwardChar(ctxw, event, params, num_params);
	return;
    case XK_Delete:
    case XK_KP_Delete:
    case DXK_Remove:
	/* Sorry, it's not a telex machine, it's a terminal */
	DeleteForwardChar(ctxw, event, params, num_params);
	return;
    case XK_Left:
    case XK_KP_Left:
	MoveBackwardChar(ctxw, event, params, num_params);
	return;
    case XK_Right:
    case XK_KP_Right:
	MoveForwardChar(ctxw, event, params, num_params);
	return;
    case XK_End:
    case XK_KP_End:
	MoveToEnd(ctxw, event, params, num_params);
	return;
    case XK_Home:
    case XK_KP_Home:
	MoveToBegining(ctxw, event, params, num_params);
	return;
    default:
	if (len == 0) {
	    if (!IsModifierKey(keysym))  /* it's not a modifier */
		XBell(XtDisplay(ctxw), 60);
	    return;
	} else
	    break;
    }

    if (ctx->login.state == PROMPTING) {
	if ((len + (int)strlen(VALUE_TEXT(ctx, promptNum)) >=
	     (VALUE_TEXT_MAX(ctx,promptNum) - 1))) {
	    len = VALUE_TEXT_MAX(ctx,promptNum) -
		strlen(VALUE_TEXT(ctx, promptNum)) - 2;
	}
    }
    EraseCursor (ctx);
    RemoveFail (ctx);
    if (len != 0)
    {
	if (ctx->login.state == PROMPTING) {
	    EraseValue (ctx, PROMPT_CURSOR(ctx, promptNum), promptNum);
	    memmove(VALUE_TEXT(ctx, promptNum) + PROMPT_CURSOR(ctx, promptNum) + len,
		    VALUE_TEXT(ctx, promptNum) + PROMPT_CURSOR(ctx, promptNum),
		    strlen (VALUE_TEXT(ctx, promptNum) + PROMPT_CURSOR(ctx, promptNum))+1);
	    memmove(VALUE_TEXT(ctx, promptNum) + PROMPT_CURSOR(ctx, promptNum),
		     strbuf, len);
	    DrawValue (ctx, PROMPT_CURSOR(ctx, promptNum), promptNum);
	    PROMPT_CURSOR(ctx, promptNum) += len;
	}
    }
    XorCursor (ctx);
}


/**** Copied from xclock.c - original author: Keith Packard ****/
#ifdef USE_XFT
static XtConvertArgRec xftColorConvertArgs[] = {
    {XtWidgetBaseOffset, (XtPointer)XtOffsetOf(WidgetRec, core.screen),
     sizeof(Screen *)},
    {XtWidgetBaseOffset, (XtPointer)XtOffsetOf(WidgetRec, core.colormap),
     sizeof(Colormap)}
};

# define	donestr(type, value, tstr) \
	{							\
	    if (toVal->addr != NULL) {				\
		if (toVal->size < sizeof(type)) {		\
		    toVal->size = sizeof(type);			\
		    XtDisplayStringConversionWarning(dpy, 	\
			(char*) fromVal->addr, tstr);		\
		    return False;				\
		}						\
		*(type*)(toVal->addr) = (value);		\
	    }							\
	    else {						\
		static type static_val;				\
		static_val = (value);				\
		toVal->addr = (XPointer)&static_val;		\
	    }							\
	    toVal->size = sizeof(type);				\
	    return True;					\
	}

static void
XmuFreeXftColor (XtAppContext app, XrmValuePtr toVal, XtPointer closure,
		 XrmValuePtr args, Cardinal *num_args)
{
    Screen	*screen;
    Colormap	colormap;
    XftColor	*color;

    if (*num_args != 2)
    {
	XtAppErrorMsg (app,
		       "freeXftColor", "wrongParameters",
		       "XtToolkitError",
		       "Freeing an XftColor requires screen and colormap arguments",
		       (String *) NULL, (Cardinal *)NULL);
	return;
    }

    screen = *((Screen **) args[0].addr);
    colormap = *((Colormap *) args[1].addr);
    color = (XftColor *) toVal->addr;
    XftColorFree (DisplayOfScreen (screen),
		  DefaultVisual (DisplayOfScreen (screen),
				 XScreenNumberOfScreen (screen)),
		  colormap, color);
}

static Boolean
XmuCvtStringToXftColor(Display *dpy,
		       XrmValue *args, Cardinal *num_args,
		       XrmValue *fromVal, XrmValue *toVal,
		       XtPointer *converter_data)
{
    char	    *spec;
    XRenderColor    renderColor;
    XftColor	    xftColor;
    Screen	    *screen;
    Colormap	    colormap;

    if (*num_args != 2)
    {
	XtAppErrorMsg (XtDisplayToApplicationContext (dpy),
		       "cvtStringToXftColor", "wrongParameters",
		       "XtToolkitError",
		       "String to render color conversion needs screen and colormap arguments",
		       (String *) NULL, (Cardinal *)NULL);
	return False;
    }

    screen = *((Screen **) args[0].addr);
    colormap = *((Colormap *) args[1].addr);

    spec = (char *) fromVal->addr;
    if (strcasecmp (spec, XtDefaultForeground) == 0)
    {
	renderColor.red = 0;
	renderColor.green = 0;
	renderColor.blue = 0;
	renderColor.alpha = 0xffff;
    }
    else if (strcasecmp (spec, XtDefaultBackground) == 0)
    {
	renderColor.red = 0xffff;
	renderColor.green = 0xffff;
	renderColor.blue = 0xffff;
	renderColor.alpha = 0xffff;
    }
    else if (!XRenderParseColor (dpy, spec, &renderColor))
	return False;
    if (!XftColorAllocValue (dpy,
			     DefaultVisual (dpy,
					    XScreenNumberOfScreen (screen)),
			     colormap,
			     &renderColor,
			     &xftColor))
	return False;

    donestr (XftColor, xftColor, XtRXftColor);
}

static void
XmuFreeXftFont (XtAppContext app, XrmValuePtr toVal, XtPointer closure,
		XrmValuePtr args, Cardinal *num_args)
{
    Screen  *screen;
    XftFont *font;

    if (*num_args != 1)
    {
	XtAppErrorMsg (app,
		       "freeXftFont", "wrongParameters",
		       "XtToolkitError",
		       "Freeing an XftFont requires screen argument",
		       (String *) NULL, (Cardinal *)NULL);
	return;
    }

    screen = *((Screen **) args[0].addr);
    font = *((XftFont **) toVal->addr);
    if (font)
	XftFontClose (DisplayOfScreen (screen), font);
}

static Boolean
XmuCvtStringToXftFont(Display *dpy,
		      XrmValue *args, Cardinal *num_args,
		      XrmValue *fromVal, XrmValue *toVal,
		      XtPointer *converter_data)
{
    char    *name;
    XftFont *font;
    Screen  *screen;

    if (*num_args != 1)
    {
	XtAppErrorMsg (XtDisplayToApplicationContext (dpy),
		       "cvtStringToXftFont", "wrongParameters",
		       "XtToolkitError",
		       "String to XftFont conversion needs screen argument",
		       (String *) NULL, (Cardinal *)NULL);
	return False;
    }

    screen = *((Screen **) args[0].addr);
    name = (char *) fromVal->addr;

    font = XftFontOpenName (dpy,
			    XScreenNumberOfScreen (screen),
			    name);
    if (font)
    {
	donestr (XftFont *, font, XtRXftFont);
    }
    XtDisplayStringConversionWarning(dpy, (char *) fromVal->addr, XtRXftFont);
    return False;
}

static XtConvertArgRec xftFontConvertArgs[] = {
    {XtWidgetBaseOffset, (XtPointer)XtOffsetOf(WidgetRec, core.screen),
     sizeof(Screen *)},
};


static int
XmuXftTextWidth(Display *dpy, XftFont *font, FcChar8 *string, int len)
{
    XGlyphInfo  extents;

    XftTextExtents8 (dpy, font, string, len, &extents);

    return extents.xOff;
}

#endif /* USE_XFT */

static void
ClassInitialize(void)
{
#ifdef USE_XFT
    XtSetTypeConverter (XtRString, XtRXftColor,
			XmuCvtStringToXftColor,
			xftColorConvertArgs, XtNumber(xftColorConvertArgs),
			XtCacheByDisplay, XmuFreeXftColor);
    XtSetTypeConverter (XtRString, XtRXftFont,
			XmuCvtStringToXftFont,
			xftFontConvertArgs, XtNumber(xftFontConvertArgs),
			XtCacheByDisplay, XmuFreeXftFont);
#endif /* USE_XFT */
}
/**** End of portion borrowed from xclock ****/

/* ARGSUSED */
static void Initialize (
    Widget greq,
    Widget gnew,
    ArgList args,
    Cardinal *num_args)
{
    LoginWidget w = (LoginWidget)gnew;
    XtGCMask	valuemask, xvaluemask;
    XGCValues	myXGCV;
    Arg		position[2];
    Position	x, y;
#ifdef USE_XINERAMA
    XineramaScreenInfo *screens;
    int                 s_num;
#endif
    int 	rv = 0;

    myXGCV.foreground = w->login.hipixel;
    myXGCV.background = w->core.background_pixel;
    valuemask = GCForeground | GCBackground;
    w->login.hiGC = XtGetGC(gnew, valuemask, &myXGCV);

    myXGCV.foreground = w->login.shdpixel;
    myXGCV.background = w->core.background_pixel;
    valuemask = GCForeground | GCBackground;
    w->login.shdGC = XtGetGC(gnew, valuemask, &myXGCV);

    myXGCV.foreground = w->login.inppixel;
    myXGCV.background = w->core.background_pixel;
    valuemask = GCForeground | GCBackground;
    w->login.inpGC = XtGetGC(gnew, valuemask, &myXGCV);

    myXGCV.foreground = TEXT_COLOR(text);
    myXGCV.background = w->core.background_pixel;
    valuemask = GCForeground | GCBackground;
#ifndef USE_XFT
    if (w->login.textFont) {
	myXGCV.font = w->login.textFont->fid;
	valuemask |= GCFont;
    }
#endif
    w->login.textGC = XtGetGC(gnew, valuemask, &myXGCV);
    myXGCV.foreground = w->login.inppixel;
    w->login.bgGC = XtGetGC(gnew, valuemask, &myXGCV);

    myXGCV.foreground = TEXT_COLOR(text) ^ w->login.inppixel;
    myXGCV.function = GXxor;
    xvaluemask = valuemask | GCFunction;
    w->login.xorGC = XtGetGC (gnew, xvaluemask, &myXGCV);

#ifndef USE_XFT
    /*
     * Note that the second argument is a GCid -- QueryFont accepts a GCid and
     * returns the curently contained font.
     */

    if (w->login.textFont == NULL)
	w->login.textFont = XQueryFont (XtDisplay (w),
		XGContextFromGC (XDefaultGCOfScreen (XtScreen (w))));

    xvaluemask = valuemask;
    if (w->login.promptFont == NULL)
        w->login.promptFont = w->login.textFont;
    else
	xvaluemask |= GCFont;

    myXGCV.foreground = TEXT_COLOR(prompt);
    myXGCV.font = w->login.promptFont->fid;
    w->login.promptGC = XtGetGC (gnew, xvaluemask, &myXGCV);

    xvaluemask = valuemask;
    if (w->login.greetFont == NULL)
	w->login.greetFont = w->login.textFont;
    else
	xvaluemask |= GCFont;

    myXGCV.foreground = TEXT_COLOR(greet);
    myXGCV.font = w->login.greetFont->fid;
    w->login.greetGC = XtGetGC (gnew, xvaluemask, &myXGCV);

    xvaluemask = valuemask;
    if (w->login.failFont == NULL)
	w->login.failFont = w->login.textFont;
    else
	xvaluemask |= GCFont;
    myXGCV.foreground = TEXT_COLOR(fail);
    myXGCV.font = w->login.failFont->fid;
    w->login.failGC = XtGetGC (gnew, xvaluemask, &myXGCV);
#endif /* USE_XFT */

#ifdef XPM
    w->login.logoValid = False;

    if (NULL != w->login.logoFileName)
    {
        XpmAttributes myAttributes = { 0 };
        Window tmpWindow = { 0 };
        struct stat myBuffer = { 0 };
        unsigned int myPixmapDepth = 0;

        if (0 != stat(w->login.logoFileName, &myBuffer))
        {
            LogError("Unable to stat() pixmap file %s\n",
                w->login.logoFileName);
            w->login.logoValid = False;
            goto SkipXpmLoad;
        }

        myAttributes.valuemask |= XpmReturnPixels;
        myAttributes.valuemask |= XpmReturnExtensions;

        rv = XpmReadFileToPixmap(XtDisplay(w),		/* display */
	     RootWindowOfScreen(XtScreen(w)),		/* window */
	     w->login.logoFileName,			/* XPM filename */
	     &(w->login.logoPixmap),			/* pixmap */
	     &(w->login.logoMask),			/* pixmap mask */
	     &myAttributes);				/* XPM attributes */

	if ( rv < 0 )
	{
	    LogError("Cannot load xpm file %s: %s.\n", w->login.logoFileName,
		     XpmGetErrorString(rv));
	    goto SkipXpmLoad;
	}

	w->login.logoValid = True;

        XGetGeometry(XtDisplay(w), w->login.logoPixmap,
            &tmpWindow,
            &(w->login.logoX),
            &(w->login.logoY),
            &(w->login.logoWidth),
            &(w->login.logoHeight),
            &(w->login.logoBorderWidth),
            &myPixmapDepth);
    } else {
	w->login.logoX = 0;
	w->login.logoY = 0;
	w->login.logoWidth = 0;
	w->login.logoHeight = 0;
	w->login.logoBorderWidth = 0;
    }


SkipXpmLoad:
#endif /* XPM */
    w->login.data.name[0] = '\0';
    w->login.data.passwd[0] = '\0';
    w->login.state = INITIALIZING;
    w->login.activePrompt = LOGIN_PROMPT_USERNAME;
    w->login.failUp = 0;
    w->login.fail = (char *) w->login.failMsg;

    /* Set prompt defaults */
    PROMPT_TEXT(w, LOGIN_PROMPT_USERNAME) 	= NULL;
    DEF_PROMPT_TEXT(w, LOGIN_PROMPT_USERNAME) 	= w->login.namePrompt;
    VALUE_TEXT(w, LOGIN_PROMPT_USERNAME) 	= w->login.data.name;
    VALUE_TEXT_MAX(w, LOGIN_PROMPT_USERNAME)	= sizeof(w->login.data.name);
    VALUE_SHOW_START(w, LOGIN_PROMPT_USERNAME)	= 0;

    PROMPT_TEXT(w, LOGIN_PROMPT_PASSWORD) 	= NULL;
    DEF_PROMPT_TEXT(w, LOGIN_PROMPT_PASSWORD) 	= w->login.passwdPrompt;
    VALUE_TEXT(w, LOGIN_PROMPT_PASSWORD) 	= w->login.data.passwd;
    VALUE_TEXT_MAX(w, LOGIN_PROMPT_PASSWORD)	= sizeof(w->login.data.passwd);
    VALUE_SHOW_START(w, LOGIN_PROMPT_PASSWORD)	= 0;

    SetPrompt(gnew, LOGIN_PROMPT_PASSWORD, NULL, LOGIN_PROMPT_ECHO_OFF, False);
    SetPrompt(gnew, LOGIN_PROMPT_USERNAME, NULL, LOGIN_PROMPT_ECHO_ON, False);

    if (w->core.width == 0)
	w->core.width = max (GREET_W(w), FAIL_W(w)) + PAD_X(w);
    if (w->core.height == 0) {
	int fy = FAIL_Y(w);
	int pady = PAD_Y(w);

#ifndef XPM
	w->core.height = fy + pady;	/* for stupid compilers */
#else
/*	w->core.height = fy + pady;	* for stupid compilers */

        w->core.height = max(fy + pady,
            (w->login.logoHeight + (2*w->login.logoPadding)) + pady);

#endif /* XPM */
    }
#ifdef USE_XINERAMA
    if (
	XineramaIsActive(XtDisplay(w)) &&
	(screens = XineramaQueryScreens(XtDisplay(w), &s_num)) != NULL
       )
    {
	if ((x = w->core.x) == -1)
	    x = screens[0].x_org + (int)(screens[0].width - w->core.width) / 2;
	if ((y = w->core.y) == -1)
	    y = screens[0].y_org + (int)(screens[0].height - w->core.height) / 3;

	XFree(screens);
    }
    else
#endif
    {
	if ((x = w->core.x) == -1)
	    x = (int)(XWidthOfScreen (XtScreen (w)) - w->core.width) / 2;
	if ((y = w->core.y) == -1)
	    y = (int)(XHeightOfScreen (XtScreen (w)) - w->core.height) / 3;
    }
    XtSetArg (position[0], XtNx, x);
    XtSetArg (position[1], XtNy, y);
    XtSetValues (XtParent (w), position, (Cardinal) 2);

    w->login.state = PROMPTING;
}


static void Realize (
     Widget gw,
     XtValueMask *valueMask,
     XSetWindowAttributes *attrs)
{
    LoginWidget	w = (LoginWidget) gw;
    Cursor cursor;

    XtCreateWindow( gw, (unsigned)InputOutput, (Visual *)CopyFromParent,
		     *valueMask, attrs );
    InitI18N(gw);

#ifdef USE_XFT
    w->login.draw = XftDrawCreate (XtDisplay (w), XtWindow(w),
	   DefaultVisual (XtDisplay (w), DefaultScreen(XtDisplay (w))),
				   w->core.colormap);

#endif

    cursor = XCreateFontCursor(XtDisplay(gw), XC_left_ptr);
    XDefineCursor(XtDisplay(gw), DefaultRootWindow(XtDisplay(gw)), cursor);

#ifdef XPM
    /*
     * Check if Pixmap was valid
     */
    if (True == w->login.logoValid)
    {
        /*
         * Create pixmap window
         */
        {
            XSetWindowAttributes windowAttributes = {
                .background_pixel = w->core.background_pixel,
                .background_pixmap = None
            };

            w->login.logoWindow = XCreateWindow(XtDisplay(w),
                XtWindow(w),
                w->core.width - w->login.outframewidth -
                    w->login.logoWidth - w->login.logoPadding,
                (w->core.height - w->login.logoHeight) /2,
                w->login.logoWidth, w->login.logoHeight, 0,
                CopyFromParent, InputOutput, CopyFromParent,
                CWBackPixel | CWBackPixmap, &windowAttributes);
        }

        /*
         * check if we can use shape extension
         */
        if (True == w->login.useShape)
        {
            int foo, bar;

            if (XShapeQueryExtension(XtDisplay(w), &foo, &bar) == TRUE)
            {
                XShapeCombineMask(XtDisplay(w), w->login.logoWindow,
                    ShapeBounding, w->login.logoX, w->login.logoY,
                    w->login.logoMask, ShapeSet);
            }
        }

        XSetWindowBackgroundPixmap(XtDisplay(w), w->login.logoWindow,
            w->login.logoPixmap);
        XMapWindow(XtDisplay(w), w->login.logoWindow);
    }
#endif /* XPM */
}

static void Destroy (Widget gw)
{
    LoginWidget w = (LoginWidget)gw;
    bzero (w->login.data.name, NAME_LEN);
    bzero (w->login.data.passwd, PASSWORD_LEN);

    if (PROMPT_TEXT(w,0) != NULL)
	XtFree(PROMPT_TEXT(w,0));
    if (PROMPT_TEXT(w,1) != NULL)
	XtFree(PROMPT_TEXT(w,1));

#ifdef USE_XFT
    if (w->login.draw) {
	XftDrawDestroy(w->login.draw);
	w->login.draw = NULL;
    }
#endif

    XtReleaseGC(gw, w->login.textGC);
    XtReleaseGC(gw, w->login.bgGC);
    XtReleaseGC(gw, w->login.xorGC);
#ifndef USE_XFT
    XtReleaseGC(gw, w->login.promptGC);
    XtReleaseGC(gw, w->login.greetGC);
    XtReleaseGC(gw, w->login.failGC);
#endif
    XtReleaseGC(gw, w->login.hiGC);
    XtReleaseGC(gw, w->login.shdGC);
    XtReleaseGC(gw, w->login.inpGC);

#ifdef XPM
    if (True == w->login.logoValid)
    {
        if (w->login.logoPixmap != 0)
            XFreePixmap(XtDisplay(w), w->login.logoPixmap);

        if (w->login.logoMask != 0)
            XFreePixmap(XtDisplay(w), w->login.logoMask);
    }
#endif /* XPM */
}

/* ARGSUSED */
static void Redisplay(
     Widget gw,
     XEvent *event,
     Region region)
{
    draw_it ((LoginWidget) gw);
}

/*ARGSUSED*/
static Boolean SetValues (
    Widget  current,
    Widget  request,
    Widget  new,
    ArgList args,
    Cardinal *num_args)
{
    LoginWidget currentL, newL;

    currentL = (LoginWidget) current;
    newL = (LoginWidget) new;
    if (GREETING (currentL) != GREETING (newL))
	return True;
    return False;
}

static
char defaultLoginTranslations [] =
"Ctrl<Key>H:	delete-previous-character() \n"
"Ctrl<Key>D:	delete-character() \n"
"Ctrl<Key>B:	move-backward-character() \n"
"Ctrl<Key>F:	move-forward-character() \n"
"Ctrl<Key>A:	move-to-begining() \n"
"Ctrl<Key>E:	move-to-end() \n"
"Ctrl<Key>K:	erase-to-end-of-line() \n"
"Ctrl<Key>U:	erase-line() \n"
"Ctrl<Key>X:	erase-line() \n"
"Ctrl<Key>C:	restart-session() \n"
"Ctrl<Key>\\\\:	abort-session() \n"
":Ctrl<Key>plus:	allow-all-access() \n"
"<Key>BackSpace:	delete-previous-character() \n"
#ifdef linux
"<Key>Delete:	delete-character() \n"
#else
"<Key>Delete:	delete-previous-character() \n"
#endif
"<Key>Return:	finish-field() \n"
"<Key>Tab:	tab-field() \n"
"<KeyPress>:	insert-char()"
;

static
XtActionsRec loginActionsTable [] = {
  {"delete-previous-character",	DeleteBackwardChar},
  {"delete-character",		DeleteForwardChar},
  {"move-backward-character",	MoveBackwardChar},
  {"move-forward-character",	MoveForwardChar},
  {"move-to-begining",		MoveToBegining},
  {"move-to-end",		MoveToEnd},
  {"erase-to-end-of-line",	EraseToEndOfLine},
  {"erase-line",		EraseLine},
  {"finish-field", 		FinishField},
  {"tab-field", 		TabField},
  {"abort-session",		AbortSession},
  {"abort-display",		AbortDisplay},
  {"restart-session",		RestartSession},
  {"insert-char", 		InsertChar},
  {"set-session-argument",	SetSessionArgument},
  {"allow-all-access",		AllowAccess},
};

LoginClassRec loginClassRec = {
    { /* core fields */
    /* superclass		*/	&widgetClassRec,
    /* class_name		*/	"Login",
    /* size			*/	sizeof(LoginRec),
    /* class_initialize		*/	ClassInitialize,
    /* class_part_initialize	*/	NULL,
    /* class_inited		*/	FALSE,
    /* initialize		*/	Initialize,
    /* initialize_hook		*/	NULL,
    /* realize			*/	Realize,
    /* actions			*/	loginActionsTable,
    /* num_actions		*/	XtNumber (loginActionsTable),
    /* resources		*/	resources,
    /* num_resources		*/	XtNumber(resources),
    /* xrm_class		*/	NULLQUARK,
    /* compress_motion		*/	TRUE,
    /* compress_exposure	*/	TRUE,
    /* compress_enterleave	*/	TRUE,
    /* visible_interest		*/	FALSE,
    /* destroy			*/	Destroy,
    /* resize			*/	NULL,
    /* expose			*/	Redisplay,
    /* set_values		*/	SetValues,
    /* set_values_hook		*/	NULL,
    /* set_values_almost	*/	XtInheritSetValuesAlmost,
    /* get_values_hook		*/	NULL,
    /* accept_focus		*/	NULL,
    /* version			*/	XtVersion,
    /* callback_private		*/	NULL,
    /* tm_table			*/	defaultLoginTranslations,
    /* query_geometry		*/	XtInheritQueryGeometry,
    /* display_accelerator	*/	XtInheritDisplayAccelerator,
    /* extension		*/	NULL
    }
};

WidgetClass loginWidgetClass = (WidgetClass) &loginClassRec;
@


1.5
log
@Update to xdm 1.1.11 plus a few patches from git master.
patched to restore static greeter.
Tested by shadchin@@, jasper@@
@
text
@d159 2
d330 1
a330 1
#define PROMPT_H(w)	(3 * Y_INC(w) / 2)
d341 1
a341 1
#define ERROR_W(w,m)	(STRING_WIDTH (fail, m))
d749 1
a749 1
	GC topLeftGC, botRightGC;
d755 1
d757 1
a757 1
	    topLeftGC = botRightGC = w->login.bgGC;
d781 5
d1693 5
d1708 1
a1708 1
    myXGCV.foreground = w->core.background_pixel;
d1711 1
a1711 1
    myXGCV.foreground = TEXT_COLOR(text) ^ w->core.background_pixel;
d1977 1
@


1.4
log
@ifdef out the new code that moves the cursor one pixel to the right
for each char during password input. Requested by deraadt@@.
@
text
@d28 2
a29 1
/* Copyright 2006 Sun Microsystems, Inc.  All rights reserved.
d32 5
a36 8
 * copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, and/or sell copies of the Software, and to permit persons
 * to whom the Software is furnished to do so, provided that the above
 * copyright notice(s) and this permission notice appear in all copies of
 * the Software and that both the above copyright notice(s) and this
 * permission notice appear in supporting documentation.
d38 3
a40 9
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT
 * OF THIRD PARTY RIGHTS. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
 * HOLDERS INCLUDED IN THIS NOTICE BE LIABLE FOR ANY CLAIM, OR ANY SPECIAL
 * INDIRECT OR CONSEQUENTIAL DAMAGES, OR ANY DAMAGES WHATSOEVER RESULTING
 * FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT,
 * NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION
 * WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
d42 7
a48 4
 * Except as contained in this notice, the name of a copyright holder
 * shall not be used in advertising or otherwise to promote the sale, use
 * or other dealings in this Software without prior written authorization
 * of the copyright holder.
d89 4
d169 1
a169 1
    	offset (textFont), XtRString,	"*-new century schoolbook-medium-r-normal-*-180-*"},
d171 1
a171 1
    	offset (promptFont), XtRString, "*-new century schoolbook-bold-r-normal-*-180-*"},
d173 1
a173 1
    	offset (greetFont), XtRString,	"*-new century schoolbook-bold-i-normal-*-240-*"},
d195 1
a195 1
    	offset(greeting), XtRString, "X Window System"},
d204 1
a204 5
#if defined(sun) && defined(SVR4)
     "Login incorrect or not on system console if root"
#else
     "Login incorrect"
#endif
d222 5
a226 1
     offset(allow_root_login), XtRImmediate, (XtPointer) True}
d299 6
a304 1

d319 1
a319 5
#ifndef XPM
# define GREET_W(w)	(max (STRING_WIDTH (greet, w->login.greeting), \
			      STRING_WIDTH (greet, w->login.unsecure_greet)))
#else
# define GREET_W(w)	(max (STRING_WIDTH (greet, w->login.greeting), \
d321 2
a322 2
			 + w->login.logoWidth + (2*w->login.logoPadding))
#endif /* XPM */
d330 3
d335 1
a335 1
#define ERROR_X(w,m)	((int)(w->core.width - STRING_WIDTH (fail, m)) / 2)
d339 1
a339 1
# define ERROR_W(w,m)	STRING_WIDTH (fail, m)
d356 1
a356 1
    loginPromptState state = w->login.prompts[promptNum].state;
d362 22
d387 2
a388 2
    height = PROMPT_H(w);
    width = PROMPT_W(w) - x - 3;
a389 5
    height -= (w->login.inframeswidth * 2);
    width -= (w->login.inframeswidth * 2);
#ifdef XPM
    width -= (w->login.logoWidth + 2*(w->login.logoPadding));
#endif
d402 3
a404 2
    } else if ((state == LOGIN_PROMPT_ECHO_ON) || (state == LOGIN_TEXT_INFO)) {
	int textwidth;
d408 1
a408 3
	textwidth = TEXT_WIDTH (text, text + offset, textlen);

	if (textwidth > (width - curoff)) {
d413 2
a414 1
	    while ((textlen > 0) && (textwidth > width))
a419 1
		textwidth = TEXT_WIDTH (text, text + offset, textlen);
d434 5
d487 16
a502 5
#ifndef __OpenBSD__
	/* Move cursor one pixel per character to give some feedback without
	   giving away the password length */
	x += PROMPT_CURSOR(w, w->login.activePrompt);
#endif
d509 1
a509 1
    		    x-1 , y - F_ASCENT(text));
d511 1
a511 1
    		    x+1 , y - F_ASCENT(text));
d513 1
a513 1
    		    x-1 , y - F_ASCENT(text)+height);
d515 1
a515 1
    		    x+1 , y - F_ASCENT(text)+height);
d517 1
a517 1
    		    x-2 , y - F_ASCENT(text));
d519 1
a519 1
    		    x+2 , y - F_ASCENT(text));
d521 1
a521 1
    		    x-2 , y - F_ASCENT(text)+height);
d523 1
a523 1
    		    x+2 , y - F_ASCENT(text)+height);
d630 1
a630 1
			XClearArea(XtDisplay(w), XtWindow(w), x, y,
d651 1
a651 1
	    XClearArea(XtDisplay(w), XtWindow(w), x, y,
d705 1
a705 2
    if( (w->login.outframewidth) < 1 )
      w->login.outframewidth = 1;
d709 1
a709 1
    		i-1,i-1,w->core.width-i,i-1);
d711 1
a711 1
    		i-1,i-1,i-1,w->core.height-i);
d713 1
a713 1
    		w->core.width-i,i-1,w->core.width-i,w->core.height-i);
d715 1
a715 1
    		i-1,w->core.height-i,w->core.width-i,w->core.height-i);
d744 1
a744 1
	int in_width = PROMPT_W(w) - VALUE_X(w,p);
a748 4
#ifdef XPM
	in_width -= (w->login.logoWidth + 2*(w->login.logoPadding));
#endif /* XPM */

d757 1
d797 2
a798 14
    /*
     * The GrabKeyboard here is needed only because of
     * a bug in the R3 server -- the keyboard is grabbed on
     * the root window, and the server won't dispatch events
     * to the focus window unless the focus window is a ancestor
     * of the grab window.  Bug in server already found and fixed,
     * compatibility until at least R4.
     */
    if (XGrabKeyboard (XtDisplay (w), XtWindow (w), False, GrabModeAsync,
		       GrabModeAsync, CurrentTime) != GrabSuccess)
    {
	XSetInputFocus (XtDisplay (w), XtWindow (w),
			RevertToPointerRoot, CurrentTime);
    }
d1725 1
a1725 1
    	w->login.greetFont = w->login.textFont;
d1899 4
a1902 5
            unsigned long valueMask = CWBackPixel | CWBackPixmap;
            XSetWindowAttributes windowAttributes = { 0 };

            windowAttributes.background_pixel = w->core.background_pixel;
            windowAttributes.background_pixmap = None;
d1911 1
a1911 1
                valueMask, &windowAttributes);
@


1.3
log
@Update to xdm 1.1.9
@
text
@d463 1
d467 1
@


1.2
log
@Fix the computed width of the rectangle to clear when no
error message is present and Xft is used.
@
text
@a0 2
/* $XdotOrg: app/xdm/greeter/Login.c,v 1.6 2006/06/03 00:05:24 alanc Exp $ */
/* $Xorg: Login.c,v 1.4 2001/02/09 02:05:41 xorgcvs Exp $ */
a55 1
/* $XFree86: xc/programs/xdm/greeter/Login.c,v 3.17tsi Exp $ */
d64 15
a78 14
# include <X11/IntrinsicP.h>
# include <X11/StringDefs.h>
# include <X11/keysym.h>
# include <X11/DECkeysym.h>
# include <X11/Xfuncs.h>

# include <stdio.h>
# include <ctype.h>
# include <time.h>

# include "dm.h"
# include "dm_error.h"
# include "greet.h"
# include "LoginP.h"
d81 5
a85 5
#include <sys/stat.h>
#include <unistd.h>
#include <X11/Xlib.h>
#include <X11/xpm.h>
#include <X11/extensions/shape.h>
d91 1
a91 1
#include <X11/extensions/Xinerama.h>
d126 1
a126 1
#ifndef USE_XFT    
d144 1
a144 1
#ifdef XPM    
d168 1
a168 1
#ifndef USE_XFT    
d243 2
a244 2
# define TEXT_X_INC(w)		F_MAX_WIDTH(text)
# define TEXT_Y_INC(w)		(F_ASCENT(text) + F_DESCENT(text))
d246 2
a247 2
# define PROMPT_X_INC(w)	F_MAX_WIDTH(prompt)
# define PROMPT_Y_INC(w)	(F_ASCENT(prompt) + F_DESCENT(prompt))
d249 2
a250 2
# define GREET_X_INC(w)		F_MAX_WIDTH(greet)
# define GREET_Y_INC(w)		(F_ASCENT(greet) + F_DESCENT(greet))
d252 2
a253 2
# define FAIL_X_INC(w)		F_MAX_WIDTH(fail)
# define FAIL_Y_INC(w)		(F_ASCENT(fail) + F_DESCENT(fail))
d255 1
a255 1
# define Y_INC(w)	max (TEXT_Y_INC(w), PROMPT_Y_INC(w))
d258 8
a265 8
# define PROMPT_TEXT(w,n) 	((w)->login.prompts[n].promptText)
# define DEF_PROMPT_TEXT(w,n) 	((w)->login.prompts[n].defaultPrompt)
# define VALUE_TEXT(w,n) 	((w)->login.prompts[n].valueText)
# define VALUE_TEXT_MAX(w,n)	((w)->login.prompts[n].valueTextMax)
# define VALUE_SHOW_START(w,n)	((w)->login.prompts[n].valueShownStart)
# define VALUE_SHOW_END(w,n)	((w)->login.prompts[n].valueShownEnd)
# define PROMPT_STATE(w,n) 	((w)->login.prompts[n].state)
# define PROMPT_CURSOR(w,n)	((w)->login.prompts[n].cursor)
d267 1
a267 1
# define CUR_PROMPT_CURSOR(w)	PROMPT_CURSOR(w,w->login.activePrompt)
d269 1
a269 1
# define CUR_PROMPT_TEXT(w, n)	(PROMPT_TEXT(w,n) != NULL ? \
d298 1
a298 1
# define STRING_WIDTH(f, s) 	TEXT_WIDTH (f, s, strlen(s))
d302 1
a302 1
# define TEXT_PROMPT_W(w, m) (STRING_WIDTH(prompt, m) + w->login.inframeswidth)
d304 2
a305 2
# define DEF_PROMPT_W(w,n) TEXT_PROMPT_W(w, w->login.prompts[n].defaultPrompt)
# define CUR_PROMPT_W(w,n)  (max(MAX_DEF_PROMPT_W(w), PROMPT_TEXT(w,n) ? \
d308 1
a308 1
# define MAX_DEF_PROMPT_W(w) (max(DEF_PROMPT_W(w,0), DEF_PROMPT_W(w,1)))
d310 1
a310 1
# define GREETING(w)	((w)->login.secure_session  && !(w)->login.allow_access ?\
d312 1
a312 1
# define GREET_X(w)	((int)((w->core.width - \
d314 1
a314 1
# define GREET_Y(w)	(GREETING(w)[0] ? 2 * GREET_Y_INC (w) : 0)
d323 2
a324 2
# define PROMPT_X(w)	(2 * PROMPT_X_INC(w))
# define PROMPT_Y(w,n)	((GREET_Y(w) + GREET_Y_INC(w) +\
d327 8
a334 8
# define PROMPT_W(w)	(w->core.width - (2 * TEXT_X_INC(w)))
# define PROMPT_H(w)	(3 * Y_INC(w) / 2)
# define VALUE_X(w,n)	(PROMPT_X(w) + CUR_PROMPT_W(w,n))
# define PROMPT_SPACE_Y(w)	(10 * Y_INC(w) / 5)

# define ERROR_X(w,m)	((int)(w->core.width - STRING_WIDTH (fail, m)) / 2)
# define FAIL_X(w)	ERROR_X(w, w->login.fail)
# define FAIL_Y(w)	(PROMPT_Y(w,1) + 2 * FAIL_Y_INC (w) + F_ASCENT(fail))
d338 1
a338 1
# define FAIL_W(w)	max(ERROR_W(w, w->login.failMsg), \
d341 1
a341 1
# define PAD_X(w)	(2 * (PROMPT_X(w) + max (GREET_X_INC(w), FAIL_X_INC(w))))
d343 1
a343 1
# define PAD_Y(w)	(max (max (Y_INC(w), GREET_Y_INC(w)),\
d345 1
a345 1
	
d386 1
a386 1
	
d401 1
a401 1
	    } 
a439 7
#ifdef FORCE_CURSOR_FLASH    
    static int lastx, lasty;
    static struct timeval  lastFlash;
    struct timeval  now, timeout;
    int sinceLastFlash;
#endif

d443 1
a443 1
    
d463 3
a465 1
	/* Nothing special needed */
d468 1
a468 1
    
d488 1
a488 28
#ifdef FORCE_CURSOR_FLASH
    /* Force cursor to flash briefly to give user feedback */
#define FLASH_MILLIS    100000 /* 0.10 seconds */
#define MILLIS_PER_SEC 1000000    
    X_GETTIMEOFDAY (&now);

    if ((lastx == x) && (lasty == y)) {
	if (lastFlash.tv_sec == 0)
	    sinceLastFlash = 0;
	else if ((lastFlash.tv_sec + 1) == now.tv_sec)
	    sinceLastFlash =
		(now.tv_usec + MILLIS_PER_SEC) - lastFlash.tv_usec;
	else if (lastFlash.tv_sec == now.tv_sec)
	    sinceLastFlash = now.tv_usec - lastFlash.tv_usec;
	else
	    sinceLastFlash = (now.tv_sec - lastFlash.tv_sec) * MILLIS_PER_SEC;

	if (sinceLastFlash < FLASH_MILLIS) {
	    timeout.tv_sec = 0;
	    timeout.tv_usec = FLASH_MILLIS - sinceLastFlash;
	    select(0, NULL, NULL, NULL, &timeout);
	}
    } else {
	lastx = x; lasty = y;
    }
    X_GETTIMEOFDAY (&lastFlash);
#endif /* FORCE_CURSOR_FLASH */
    XFlush (XtDisplay(w));    
d494 1
a494 1
#ifdef USE_XFT 
d497 1
a497 1
#else    
d504 1
a504 1
#endif    
d556 1
a556 1
#ifndef USE_XFT    
d558 1
a558 1
#endif	
d566 1
a566 1
		char lastspace;
d569 1
a569 1
		
d589 1
a589 1
		    
d596 1
a596 1
#endif		    
d617 1
a617 1
#endif		    
d681 1
a681 1
    
d707 1
a707 1
 
d710 1
a710 1
	
d713 1
a713 1
#ifdef XPM	
d716 1
a716 1
	
d730 1
a730 1
		      in_frame_x + in_width-i,  in_frame_y + i-1); 
d734 1
a734 1
		      in_frame_x + i-1,         in_frame_y + in_height-i); 
d739 1
a739 1
		      in_frame_x + in_width-i,  in_frame_y + in_height-i); 
d752 1
a752 1
#endif	
d793 1
a793 1
    
d798 1
a798 1
    
d816 1
a816 1
    
d822 1
a822 1
    
d824 1
a824 1
    
d827 1
a827 1
	    
d843 1
a843 1
    
d847 1
a847 1
	
d864 1
a864 1
    
d878 1
a878 1
    
d889 1
a889 1
    
d894 1
a894 1
    
d908 1
a908 1
    
d919 1
a919 1
    
d935 1
a935 1
	
d969 1
a969 1
    XorCursor (ctx);	
d986 1
a986 1
    XorCursor (ctx);	
d1192 1
a1192 1
    
d1410 1
a1410 1
    if (ctx->login.state == PROMPTING) {	
d1445 1
a1445 1
#define	donestr(type, value, tstr) \
d1472 1
a1472 1
    
d1491 1
a1491 1
    
d1503 1
a1503 1
    
d1534 1
a1534 1
    if (!XftColorAllocValue (dpy, 
d1541 1
a1541 1
    
d1551 1
a1551 1
    
d1577 1
a1577 1
    
d1590 1
a1590 1
    
d1620 1
a1620 1
static void 
d1624 2
a1625 2
    XtSetTypeConverter (XtRString, XtRXftColor, 
			XmuCvtStringToXftColor, 
d1653 1
a1653 1
    
d1672 1
a1672 1
#endif    
d1749 1
a1749 1
       
d1791 1
a1791 1
    
d1800 1
a1800 1
    
d1814 1
a1814 1
        
d1827 1
a1827 1
	
d1845 1
a1845 1
 
d1869 1
a1869 1
    /* 
d1875 1
a1875 1
         * Create pixmap window 
d1932 2
a1933 2
#endif    
    
d1975 1
a1975 1
    
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/* $XdotOrg: app/xdm/greeter/Login.c,v 1.5 2006/04/14 02:52:02 alanc Exp $ */
d30 28
d74 1
a74 1
#ifdef XPM
a75 1
#endif /* XPM */
d88 2
a90 1
#endif /* XPM */
d96 13
d112 2
d128 1
d137 1
d139 1
a139 1
#ifdef XPM
d144 1
d146 1
d155 1
a155 1

a168 1
#endif /* XPM */
d170 1
d172 1
a172 1
    	offset (font), XtRString,	"*-new century schoolbook-medium-r-normal-*-180-*"},
d179 18
d206 1
a206 1
	offset(fail), XtRString, 
d208 1
a208 1
     "Login incorrect or not on system console if root"},
d210 1
a210 1
     "Login incorrect"},
d212 4
d223 1
a223 1
	offset(secure_session), XtRImmediate, False },
d225 1
a225 1
	offset(allow_access), XtRImmediate, False },
d227 1
a227 1
	offset(allow_null_passwd), XtRImmediate, False},
d235 21
a255 12
# define TEXT_X_INC(w)	((w)->login.font->max_bounds.width)
# define TEXT_Y_INC(w)	((w)->login.font->max_bounds.ascent +\
			 (w)->login.font->max_bounds.descent)
# define PROMPT_X_INC(w)	((w)->login.promptFont->max_bounds.width)
# define PROMPT_Y_INC(w)	((w)->login.promptFont->max_bounds.ascent +\
			 (w)->login.promptFont->max_bounds.descent)
# define GREET_X_INC(w)	((w)->login.greetFont->max_bounds.width)
# define GREET_Y_INC(w)	((w)->login.greetFont->max_bounds.ascent +\
			 (w)->login.greetFont->max_bounds.descent)
# define FAIL_X_INC(w)	((w)->login.failFont->max_bounds.width)
# define FAIL_Y_INC(w)	((w)->login.failFont->max_bounds.ascent +\
			 (w)->login.failFont->max_bounds.descent)
d259 29
a287 4
#ifndef XPM
# define LOGIN_PROMPT_W(w) (XTextWidth (w->login.promptFont,\
				 w->login.namePrompt,\
				 strlen (w->login.namePrompt)))
d289 23
a311 16
# define LOGIN_PROMPT_W(w) (XTextWidth (w->login.promptFont,\
				 w->login.namePrompt,\
				 strlen (w->login.namePrompt)) + \
				 w->login.inframeswidth)
#endif /* XPM */
#ifndef XPM
# define PASS_PROMPT_W(w) (XTextWidth (w->login.promptFont,\
				 w->login.passwdPrompt,\
				 strlen (w->login.passwdPrompt)))
#else
# define PASS_PROMPT_W(w) (XTextWidth (w->login.promptFont,\
				 w->login.passwdPrompt,\
				 strlen (w->login.passwdPrompt)) + \
				 w->login.inframeswidth)
#endif /* XPM */
# define PROMPT_W(w)	(max(LOGIN_PROMPT_W(w), PASS_PROMPT_W(w)))
d314 2
a315 2
# define GREET_X(w)	((int)(w->core.width - XTextWidth (w->login.greetFont,\
			  GREETING(w), strlen (GREETING(w)))) / 2)
d318 2
a319 4
# define GREET_W(w)	(max (XTextWidth (w->login.greetFont,\
			      w->login.greeting, strlen (w->login.greeting)), \
			      XTextWidth (w->login.greetFont,\
			      w->login.unsecure_greet, strlen (w->login.unsecure_greet))))
d321 21
a341 31
# define GREET_W(w)	(max (XTextWidth (w->login.greetFont,\
			      w->login.greeting, strlen (w->login.greeting)), \
			      XTextWidth (w->login.greetFont,\
			      w->login.unsecure_greet, strlen (w->login.unsecure_greet)))) + w->login.logoWidth + (2*w->login.logoPadding)
#endif /* XPM */
# define LOGIN_X(w)	(2 * PROMPT_X_INC(w))
# define LOGIN_Y(w)	(GREET_Y(w) + GREET_Y_INC(w) +\
			 w->login.greetFont->max_bounds.ascent + Y_INC(w))
# define LOGIN_W(w)	(w->core.width - 6 * TEXT_X_INC(w))
# define LOGIN_H(w)	(3 * Y_INC(w) / 2)
# define LOGIN_TEXT_X(w)(LOGIN_X(w) + PROMPT_W(w))
# define PASS_X(w)	(LOGIN_X(w))
#ifndef XPM
# define PASS_Y(w)	(LOGIN_Y(w) + 8 * Y_INC(w) / 5)
#else
# define PASS_Y(w)	(LOGIN_Y(w) + 10 * Y_INC(w) / 5)
#endif /* XPM */
# define PASS_W(w)	(LOGIN_W(w))
# define PASS_H(w)	(LOGIN_H(w))
# define PASS_TEXT_X(w)	(PASS_X(w) + PROMPT_W(w))
# define FAIL_X(w)	((int)(w->core.width - XTextWidth (w->login.failFont,\
				w->login.fail, strlen (w->login.fail))) / 2)
# define FAIL_Y(w)	(PASS_Y(w) + 2 * FAIL_Y_INC (w) +\
			w->login.failFont->max_bounds.ascent)
#ifndef XPM
# define FAIL_W(w)	(XTextWidth (w->login.failFont,\
			 w->login.fail, strlen (w->login.fail)))
#else
# define FAIL_W(w)	(XTextWidth (w->login.failFont,\
			 w->login.fail, strlen (w->login.fail))) + w->login.logoWidth + (2*w->login.logoPadding)
#endif /* XPM */
d343 1
a343 1
# define PAD_X(w)	(2 * (LOGIN_X(w) + max (GREET_X_INC(w), FAIL_X_INC(w))))
d353 1
a353 1
EraseName (LoginWidget w, int cursor)
d355 35
a389 1
    int	x;
d391 26
a416 5
    x = LOGIN_TEXT_X (w);
    if (cursor > 0)
	x += XTextWidth (w->login.font, w->login.data.name, cursor);
    XDrawString (XtDisplay(w), XtWindow (w), w->login.bgGC, x, LOGIN_Y(w),
		w->login.data.name + cursor, strlen (w->login.data.name + cursor));
d420 1
a420 1
DrawName (LoginWidget w, int cursor)
d422 2
a423 1
    int	x;
d425 9
a433 11
    x = LOGIN_TEXT_X (w);
    if (cursor > 0)
	x += XTextWidth (w->login.font, w->login.data.name, cursor);
    XDrawString (XtDisplay(w), XtWindow (w), w->login.textGC, x, LOGIN_Y(w),
		w->login.data.name + cursor, strlen (w->login.data.name + cursor));

#ifdef XPM
	/*as good a place as any Caolan begin*/
	w->login.lastEventTime = time(NULL);
	/*as good a place as any Caolan end*/
#endif /* XPM */
d442 28
a469 8
    switch (w->login.state) {
    case GET_NAME:
	x = LOGIN_TEXT_X (w);
	y = LOGIN_Y (w);
	height = w->login.font->max_bounds.ascent + w->login.font->max_bounds.descent;
	width = 1;
	if (w->login.cursor > 0)
	    x += XTextWidth (w->login.font, w->login.data.name, w->login.cursor);
d471 2
a472 5
    case GET_PASSWD:
	x = PASS_TEXT_X (w);
	y = PASS_Y (w);
	height = w->login.font->max_bounds.ascent + w->login.font->max_bounds.descent;
	width = 1;
a473 2
    default:
	return;
d475 1
d477 1
a477 4
#ifndef XPM
		    x, y - w->login.font->max_bounds.ascent, width, height);
#else
		    x, y+1 - w->login.font->max_bounds.ascent, width, height-1);
d479 1
a479 1
    		    x-1 , y - w->login.font->max_bounds.ascent);
d481 1
a481 1
    		    x+1 , y - w->login.font->max_bounds.ascent);
d483 1
a483 1
    		    x-1 , y - w->login.font->max_bounds.ascent+height);
d485 1
a485 1
    		    x+1 , y - w->login.font->max_bounds.ascent+height);
d487 1
a487 1
    		    x-2 , y - w->login.font->max_bounds.ascent);
d489 1
a489 1
    		    x+2 , y - w->login.font->max_bounds.ascent);
d491 1
a491 1
    		    x-2 , y - w->login.font->max_bounds.ascent+height);
d493 30
a522 2
    		    x+2 , y - w->login.font->max_bounds.ascent+height);
#endif /* XPM */
d528 4
a531 3
    int x = FAIL_X(w);
    int y = FAIL_Y(w);

d534 1
a534 3
    XDrawString (XtDisplay (w), XtWindow (w), w->login.failGC,
		x, y,
		w->login.fail, strlen (w->login.fail));
d537 2
a538 1
			w->login.failpixel);
d566 1
d570 1
d580 1
a580 8
    w->login.failUp = 1;
    RedrawFail (w);
    if (w->login.failTimeout > 0) {
	Debug ("failTimeout: %d\n", w->login.failTimeout);
	XtAppAddTimeOut(XtWidgetToApplicationContext ((Widget)w),
			w->login.failTimeout * 1000,
		        failTimeout, (XtPointer) w);
    }
d588 1
d590 1
d592 99
a690 3
        XDrawString (XtDisplay (w), XtWindow (w), w->login.failGC,
		    x, y,
		    w->login.fail, strlen (w->login.fail));
d696 2
a697 2
#ifdef XPM
    int i,in_frame_x,in_login_y,in_pass_y,in_width,in_height;
a698 1
#endif /* XPM */
a701 1
#ifdef XPM
d717 1
a717 1
    gr_line_x = w->login.outframewidth + w->login.logoPadding;
d719 7
a725 3
    gr_line_w = w->core.width - 2*(w->login.outframewidth) -
        (w->login.logoWidth + 3*(w->login.logoPadding));
 
a734 8
    
    in_frame_x = LOGIN_TEXT_X(w) - w->login.inframeswidth - 3;
    in_login_y = LOGIN_Y(w) - w->login.inframeswidth - 1 - TEXT_Y_INC(w);
    in_pass_y  = PASS_Y(w) - w->login.inframeswidth - 1 - TEXT_Y_INC(w);
 
    in_width = LOGIN_W(w) - PROMPT_W(w) -
        (w->login.logoWidth + 2*(w->login.logoPadding));
    in_height = LOGIN_H(w) + w->login.inframeswidth + 2;
d736 1
a736 1
    for(i=1;i<=(w->login.inframeswidth);i++)
d738 8
a745 4
      /* Make top/left sides */
      XDrawLine(XtDisplay (w), XtWindow (w), w->login.shdGC,
	in_frame_x + i-1,             in_login_y + i-1,
	in_frame_x + in_width-i,      in_login_y + i-1); 
d747 11
a757 3
      XDrawLine(XtDisplay (w), XtWindow (w), w->login.shdGC,
	in_frame_x + i-1,             in_login_y + i-1,
	in_frame_x + i-1,             in_login_y + in_height-i); 
d759 21
a779 7
      XDrawLine(XtDisplay (w), XtWindow (w), w->login.hiGC,
        in_frame_x + in_width-i,      in_login_y + i-1,
        in_frame_x + in_width-i,      in_login_y + in_height-i); 
                
      XDrawLine(XtDisplay (w), XtWindow (w), w->login.hiGC,
	in_frame_x + i-1,             in_login_y + in_height-i,
	in_frame_x + in_width-i,      in_login_y + in_height-i);
d781 2
a782 4
      /* Make bottom/right sides */
      XDrawLine(XtDisplay (w), XtWindow (w), w->login.shdGC,
	in_frame_x + i-1,             in_pass_y + i-1,
	in_frame_x + in_width-i,      in_pass_y + i-1); 
d784 11
a794 11
      XDrawLine(XtDisplay (w), XtWindow (w), w->login.shdGC,
	in_frame_x + i-1,             in_pass_y + i-1,
	in_frame_x + i-1,             in_pass_y + in_height-i); 

      XDrawLine(XtDisplay (w), XtWindow (w), w->login.hiGC,
        in_frame_x + in_width-i,      in_pass_y + i-1,
        in_frame_x + in_width-i,      in_pass_y + in_height-i); 
                
      XDrawLine(XtDisplay (w), XtWindow (w), w->login.hiGC,
	in_frame_x + i-1,             in_pass_y + in_height-i,
	in_frame_x + in_width-i,      in_pass_y + in_height-i);
a795 18
#endif /* XPM */

    if (GREETING(w)[0])
	    XDrawString (XtDisplay (w), XtWindow (w), w->login.greetGC,
#ifndef XPM
			GREET_X(w), GREET_Y(w),
#else
			GREET_X(w) -
                            ((w->login.logoWidth/2) + w->login.logoPadding),
                        GREET_Y(w),
#endif /* XPM */
			GREETING(w), strlen (GREETING(w)));
    XDrawString (XtDisplay (w), XtWindow (w), w->login.promptGC,
		LOGIN_X(w), LOGIN_Y(w),
		w->login.namePrompt, strlen (w->login.namePrompt));
    XDrawString (XtDisplay (w), XtWindow (w), w->login.promptGC,
		PASS_X(w), PASS_Y(w),
		w->login.passwdPrompt, strlen (w->login.passwdPrompt));
a796 1
    DrawName (w, 0);
d814 172
d992 6
d999 3
a1001 15
    RemoveFail (ctx);
    if (ctx->login.cursor > 0) {
	ctx->login.cursor--;
	switch (ctx->login.state) {
	case GET_NAME:
	    EraseName (ctx, ctx->login.cursor);
	    strcpy (ctx->login.data.name + ctx->login.cursor,
		    ctx->login.data.name + ctx->login.cursor + 1);
	    DrawName (ctx, ctx->login.cursor);
	    break;
	case GET_PASSWD:
	    strcpy (ctx->login.data.passwd + ctx->login.cursor,
		    ctx->login.data.passwd + ctx->login.cursor + 1);
	    break;
	}
a1011 1
    XorCursor (ctx);
d1013 3
a1015 15
    switch (ctx->login.state) {
    case GET_NAME:
	if (ctx->login.cursor < (int)strlen (ctx->login.data.name)) {
	    EraseName (ctx, ctx->login.cursor);
	    strcpy (ctx->login.data.name + ctx->login.cursor,
		    ctx->login.data.name + ctx->login.cursor + 1);
	    DrawName (ctx, ctx->login.cursor);
	}
	break;
    case GET_PASSWD:
    	if (ctx->login.cursor < (int)strlen (ctx->login.data.passwd)) {
	    strcpy (ctx->login.data.passwd + ctx->login.cursor,
		    ctx->login.data.passwd + ctx->login.cursor + 1);
	}
	break;
d1017 3
d1033 6
d1040 8
a1047 3
    RemoveFail (ctx);
    if (ctx->login.cursor > 0)
    	ctx->login.cursor--;
d1061 6
d1068 8
a1075 10
    RemoveFail (ctx);
    switch (ctx->login.state) {
    case GET_NAME:
    	if (ctx->login.cursor < (int)strlen(ctx->login.data.name))
	    ++ctx->login.cursor;
	break;
    case GET_PASSWD:
    	if (ctx->login.cursor < (int)strlen(ctx->login.data.passwd))
	    ++ctx->login.cursor;
	break;
d1090 6
d1097 6
a1102 2
    RemoveFail (ctx);
    ctx->login.cursor = 0;
d1116 6
d1123 4
a1126 8
    RemoveFail (ctx);
    switch (ctx->login.state) {
    case GET_NAME:
    	ctx->login.cursor = strlen (ctx->login.data.name);
	break;
    case GET_PASSWD:
    	ctx->login.cursor = strlen (ctx->login.data.passwd);
	break;
a1140 1
    XorCursor (ctx);
d1142 3
a1144 8
    switch (ctx->login.state) {
    case GET_NAME:
	EraseName (ctx, ctx->login.cursor);
	bzero (ctx->login.data.name, NAME_LEN);
	break;
    case GET_PASSWD:
	bzero (ctx->login.data.passwd, PASSWORD_LEN);
	break;
d1146 7
d1177 8
d1187 9
a1195 7
    RemoveFail (ctx);
    switch (ctx->login.state) {
    case GET_NAME:
	ctx->login.state = GET_PASSWD;
	ctx->login.cursor = 0;
	break;
    case GET_PASSWD:
a1196 1
	ctx->login.cursor = 0;
d1198 3
a1200 1
	break;
d1202 1
a1205 1
#ifdef XPM
d1211 8
d1221 11
a1231 10
    RemoveFail (ctx);
    switch (ctx->login.state) {
    case GET_NAME:
	ctx->login.state = GET_PASSWD;
	ctx->login.cursor = 0;
	break;
    case GET_PASSWD:
	ctx->login.state = GET_NAME;
	ctx->login.cursor = 0;
	break;
a1234 1
#endif /* XPM */
d1268 1
a1268 1
    ctx->login.sessionArg = 0;
a1290 1
    ctx->login.cursor = 0;
a1307 1
    ctx->login.cursor = 0;
a1324 1
    ctx->login.cursor = 0;
d1332 10
a1341 5
    EraseName (w, 0);
    w->login.cursor = 0;
    bzero (w->login.data.name, NAME_LEN);
    bzero (w->login.data.passwd, PASSWORD_LEN);
    w->login.state = GET_NAME;
d1384 1
a1384 5
#ifndef XPM
    int  len;
#else
    int  len,pixels;
#endif /* XPM */
a1397 8
#ifdef XPM
    pixels = 3 + ctx->login.font->max_bounds.width * len +
    	     XTextWidth(ctx->login.font,
    	     		ctx->login.data.name,
    	     		strlen(ctx->login.data.name));
    	     	/* pixels to be added */
#endif /* XPM */

d1444 114
a1557 14
    switch (ctx->login.state) {
    case GET_NAME:
#ifndef XPM
	if (len + (int)strlen(ctx->login.data.name) >= NAME_LEN - 1)
#else
	if (
	        (len + (int)strlen(ctx->login.data.name) >= NAME_LEN - 1)/* &&
		(pixels <= LOGIN_W(ctx) - PROMPT_W(ctx))*/
	   )
#endif /* XPM */
	    len = NAME_LEN - strlen(ctx->login.data.name) - 2;
    case GET_PASSWD:
	if (len + (int)strlen(ctx->login.data.passwd) >= PASSWORD_LEN - 1)
	    len = PASSWORD_LEN - strlen(ctx->login.data.passwd) - 2;
d1559 34
a1592 5
#ifndef XPM
    if (len == 0)
#else
    if (len == 0 || pixels >= LOGIN_W(ctx) - PROMPT_W(ctx))
#endif /* XPM */
d1594 27
a1620 18
    XorCursor (ctx);
    RemoveFail (ctx);
    switch (ctx->login.state) {
    case GET_NAME:
	EraseName (ctx, ctx->login.cursor);
	memmove( ctx->login.data.name + ctx->login.cursor + len,
	       ctx->login.data.name + ctx->login.cursor,
	       strlen (ctx->login.data.name + ctx->login.cursor) + 1);
	memmove( ctx->login.data.name + ctx->login.cursor, strbuf, len);
	DrawName (ctx, ctx->login.cursor);
	ctx->login.cursor += len;
	break;
    case GET_PASSWD:
	memmove( ctx->login.data.passwd + ctx->login.cursor + len,
	       ctx->login.data.passwd + ctx->login.cursor,
	       strlen (ctx->login.data.passwd + ctx->login.cursor) + 1);
	memmove( ctx->login.data.passwd + ctx->login.cursor, strbuf, len);
	ctx->login.cursor += len;
d1622 9
a1630 6
#ifdef XPM
	/*as good a place as any Caolan begin*/
	ctx->login.lastEventTime = time(NULL);
	/*as good a place as any Caolan end*/
#endif /* XPM */
	break;
d1632 35
a1666 1
    XorCursor (ctx);
d1668 1
a1685 2

#ifdef XPM
a1696 1
#endif /* XPM */
d1698 1
a1698 1
    myXGCV.foreground = w->login.textpixel;
d1701 3
a1703 2
    if (w->login.font) {
	myXGCV.font = w->login.font->fid;
d1706 1
d1711 1
a1711 1
    myXGCV.foreground = w->login.textpixel ^ w->core.background_pixel;
d1716 1
d1722 2
a1723 2
    if (w->login.font == NULL)
	w->login.font = XQueryFont (XtDisplay (w),
d1728 1
a1728 1
        w->login.promptFont = w->login.font;
d1732 1
a1732 1
    myXGCV.foreground = w->login.promptpixel;
d1738 1
a1738 1
    	w->login.greetFont = w->login.font;
d1742 1
a1742 1
    myXGCV.foreground = w->login.greetpixel;
d1748 1
a1748 1
	w->login.failFont = w->login.font;
d1751 1
a1751 2

    myXGCV.foreground = w->login.failpixel;
d1754 1
d1812 4
a1815 4
    bzero (w->login.data.name, NAME_LEN);
    bzero (w->login.data.passwd, PASSWORD_LEN);
    w->login.state = GET_NAME;
    w->login.cursor = 0;
d1817 18
d1875 2
a1884 1
#ifdef XPM
d1887 1
a1887 1
#endif /* XPM */
d1891 8
a1898 1
#ifdef XPM
d1900 1
a1900 1
    XDefineCursor(XtDisplay(gw), XtWindow(gw), cursor);
d1902 1
d1955 13
d1971 1
d1975 1
a1975 1
#ifdef XPM
d1979 1
d2017 1
a2037 3
#ifndef XPM
"<KeyPress>:	insert-char()"
#else
a2039 1
#endif /* XPM */
d2042 1
a2052 1
#ifdef XPM
a2053 1
#endif /* XPM */
d2067 1
a2067 1
    /* class_initialize		*/	NULL,
a2086 3
#ifndef XPM
    /* set_values_almost	*/	NULL,
#else
a2087 1
#endif /* XPM */
@


1.1.1.1
log
@Importing from X.Org 7.2RC2
@
text
@@


1.1.1.2
log
@Import xdm 1.1.4
@
text
@d1 1
a1 1
/* $XdotOrg: app/xdm/greeter/Login.c,v 1.6 2006/06/03 00:05:24 alanc Exp $ */
a29 28
/* Copyright 2006 Sun Microsystems, Inc.  All rights reserved.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, and/or sell copies of the Software, and to permit persons
 * to whom the Software is furnished to do so, provided that the above
 * copyright notice(s) and this permission notice appear in all copies of
 * the Software and that both the above copyright notice(s) and this
 * permission notice appear in supporting documentation.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT
 * OF THIRD PARTY RIGHTS. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
 * HOLDERS INCLUDED IN THIS NOTICE BE LIABLE FOR ANY CLAIM, OR ANY SPECIAL
 * INDIRECT OR CONSEQUENTIAL DAMAGES, OR ANY DAMAGES WHATSOEVER RESULTING
 * FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT,
 * NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION
 * WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 *
 * Except as contained in this notice, the name of a copyright holder
 * shall not be used in advertising or otherwise to promote the sale, use
 * or other dealings in this Software without prior written authorization
 * of the copyright holder.
 */

d46 1
a46 1
# include <ctype.h>
d48 1
a67 13
#ifndef DEBUG
# define XDM_ASSERT(a)	/* do nothing */
#else
# if defined(__STDC__) && __STDC_VERSION__ - 0 >= 199901L
#  define XDM_ASSERT(a)	if (!(a)) { \
	Debug("Assertion failed in %s() at file %s line %d\n", \
	      __func__, __FILE__, __LINE__); }
# else
#  define XDM_ASSERT(a)	if (!(a)) { \
	Debug("Assertion failed at file %s line %d\n", __FILE__, __LINE__); }
# endif
#endif

a70 2
static void EraseCursor (LoginWidget w);
static void XorCursor (LoginWidget w);
a84 1
#ifndef USE_XFT    
a92 1
#endif
a123 1
#ifndef USE_XFT    
d125 1
a125 1
    	offset (textFont), XtRString,	"*-new century schoolbook-medium-r-normal-*-180-*"},
a131 18
#else /* USE_XFT */
    {XtNface, XtCFace, XtRXftFont, sizeof (XftFont *),
        offset (textFace), XtRString, "Serif-18"},
    {XtNpromptFace, XtCFace, XtRXftFont, sizeof (XftFont *),
        offset (promptFace), XtRString, "Serif-18:bold"},
    {XtNgreetFace, XtCFace, XtRXftFont, sizeof (XftFont *),
        offset (greetFace), XtRString, "Serif-24:italic"},
    {XtNfailFace, XtCFace, XtRXftFont, sizeof (XftFont *),
        offset (failFace), XtRString, "Serif-18:bold"},
    {XtNforeground, XtCForeground, XtRXftColor, sizeof(XftColor),
        offset(textcolor), XtRString,	XtDefaultForeground},
    {XtNpromptColor, XtCForeground, XtRXftColor, sizeof(XftColor),
        offset(promptcolor), XtRString,	XtDefaultForeground},
    {XtNgreetColor, XtCForeground, XtRXftColor, sizeof(XftColor),
        offset(greetcolor), XtRString,	XtDefaultForeground},
    {XtNfailColor, XtCForeground, XtRXftColor, sizeof (XftColor),
	offset(failcolor), XtRString,	XtDefaultForeground},
#endif
d141 1
a141 1
	offset(failMsg), XtRString,
d143 1
a143 1
     "Login incorrect or not on system console if root"
d145 1
a145 1
     "Login incorrect"
a146 4
    },
    {XtNchangePasswdMessage, XtCChangePasswdMessage, XtRString,
	sizeof (char *), offset(passwdChangeMsg), XtRString,
	(XtPointer) "Password Change Required" },
d154 1
a154 1
	offset(secure_session), XtRImmediate, (XtPointer) False },
d156 1
a156 1
	offset(allow_access), XtRImmediate, (XtPointer) False },
d158 1
a158 1
	offset(allow_null_passwd), XtRImmediate, (XtPointer) False},
d166 12
a177 21
#ifdef USE_XFT
# define F_MAX_WIDTH(f)	((w)->login.f##Face->max_advance_width)
# define F_ASCENT(f)	((w)->login.f##Face->ascent)
# define F_DESCENT(f)	((w)->login.f##Face->descent)
#else
# define F_MAX_WIDTH(f)	((w)->login.f##Font->max_bounds.width)
# define F_ASCENT(f)	((w)->login.f##Font->max_bounds.ascent)
# define F_DESCENT(f)	((w)->login.f##Font->max_bounds.descent)
#endif

# define TEXT_X_INC(w)		F_MAX_WIDTH(text)
# define TEXT_Y_INC(w)		(F_ASCENT(text) + F_DESCENT(text))

# define PROMPT_X_INC(w)	F_MAX_WIDTH(prompt)
# define PROMPT_Y_INC(w)	(F_ASCENT(prompt) + F_DESCENT(prompt))

# define GREET_X_INC(w)		F_MAX_WIDTH(greet)
# define GREET_Y_INC(w)		(F_ASCENT(greet) + F_DESCENT(greet))

# define FAIL_X_INC(w)		F_MAX_WIDTH(fail)
# define FAIL_Y_INC(w)		(F_ASCENT(fail) + F_DESCENT(fail))
d181 4
a184 29

# define PROMPT_TEXT(w,n) 	((w)->login.prompts[n].promptText)
# define DEF_PROMPT_TEXT(w,n) 	((w)->login.prompts[n].defaultPrompt)
# define VALUE_TEXT(w,n) 	((w)->login.prompts[n].valueText)
# define VALUE_TEXT_MAX(w,n)	((w)->login.prompts[n].valueTextMax)
# define VALUE_SHOW_START(w,n)	((w)->login.prompts[n].valueShownStart)
# define VALUE_SHOW_END(w,n)	((w)->login.prompts[n].valueShownEnd)
# define PROMPT_STATE(w,n) 	((w)->login.prompts[n].state)
# define PROMPT_CURSOR(w,n)	((w)->login.prompts[n].cursor)

# define CUR_PROMPT_CURSOR(w)	PROMPT_CURSOR(w,w->login.activePrompt)

# define CUR_PROMPT_TEXT(w, n)	(PROMPT_TEXT(w,n) != NULL ? \
				 PROMPT_TEXT(w,n) : DEF_PROMPT_TEXT(w,n))

#ifdef USE_XFT

# define TEXT_COLOR(f)		(w->login.f##color.pixel)

# define TEXT_WIDTH(f, m, l) 	XmuXftTextWidth(XtDisplay (w), \
					w->login.f##Face, (FcChar8 *) m, l)
static int
XmuXftTextWidth(Display *dpy, XftFont *font, FcChar8 *string, int len);

# define DRAW_STRING(f, x, y, m, l) \
	/* Debug("DRAW_STRING(%s, %d, %d, %s, %d)\n", #f, x, y, m, l); */ \
	XftDrawString8 (w->login.draw, &w->login.f##color, w->login.f##Face, \
			x, y, (FcChar8 *) m, l)

d186 5
a190 14

# define TEXT_COLOR(f)		(w->login.f##pixel)

# define TEXT_WIDTH(f, m, l) 	(XTextWidth (w->login.f##Font, m, l))

# define DRAW_STRING(f, x, y, m, l) \
	XDrawString (XtDisplay (w), XtWindow (w), w->login.f##GC, x, y, m, l)

#endif


# define STRING_WIDTH(f, s) 	TEXT_WIDTH (f, s, strlen(s))


d192 3
a194 1
# define TEXT_PROMPT_W(w, m) STRING_WIDTH(prompt, m)
d196 4
a199 1
# define TEXT_PROMPT_W(w, m) (STRING_WIDTH(prompt, m) + w->login.inframeswidth)
d201 1
a201 7

# define DEF_PROMPT_W(w,n) TEXT_PROMPT_W(w, w->login.prompts[n].defaultPrompt)
# define CUR_PROMPT_W(w,n)  (max(MAX_DEF_PROMPT_W(w), PROMPT_TEXT(w,n) ? \
		     TEXT_PROMPT_W(w, PROMPT_TEXT(w,n)) : 0))

# define MAX_DEF_PROMPT_W(w) (max(DEF_PROMPT_W(w,0), DEF_PROMPT_W(w,1)))

d204 2
a205 2
# define GREET_X(w)	((int)((w->core.width - \
			     	STRING_WIDTH (greet, GREETING(w))) / 2))
d208 4
a211 2
# define GREET_W(w)	(max (STRING_WIDTH (greet, w->login.greeting), \
			      STRING_WIDTH (greet, w->login.unsecure_greet)))
d213 12
a224 11
# define GREET_W(w)	(max (STRING_WIDTH (greet, w->login.greeting), \
			      STRING_WIDTH (greet, w->login.unsecure_greet)) \
			 + w->login.logoWidth + (2*w->login.logoPadding))
#endif /* XPM */
# define PROMPT_X(w)	(2 * PROMPT_X_INC(w))
# define PROMPT_Y(w,n)	((GREET_Y(w) + GREET_Y_INC(w) +\
			  F_ASCENT(greet) + Y_INC(w)) + \
			 (n * PROMPT_SPACE_Y(w)))
# define PROMPT_W(w)	(w->core.width - (2 * TEXT_X_INC(w)))
# define PROMPT_H(w)	(3 * Y_INC(w) / 2)
# define VALUE_X(w,n)	(PROMPT_X(w) + CUR_PROMPT_W(w,n))
d226 1
a226 1
# define PROMPT_SPACE_Y(w)	(8 * Y_INC(w) / 5)
d228 1
a228 1
# define PROMPT_SPACE_Y(w)	(10 * Y_INC(w) / 5)
d230 7
a236 4
# define ERROR_X(w,m)	((int)(w->core.width - STRING_WIDTH (fail, m)) / 2)
# define FAIL_X(w)	ERROR_X(w, w->login.fail)
# define FAIL_Y(w)	(PROMPT_Y(w,1) + 2 * FAIL_Y_INC (w) + F_ASCENT(fail))

d238 2
a239 1
# define ERROR_W(w,m)	STRING_WIDTH (fail, m)
d241 2
a242 2
# define ERROR_W(w,m)	(STRING_WIDTH (fail, m) \
			 + w->login.logoWidth + (2*w->login.logoPadding))
d245 1
a245 4
# define FAIL_W(w)	max(ERROR_W(w, w->login.failMsg), \
			    ERROR_W(w, w->login.passwdChangeMsg))

# define PAD_X(w)	(2 * (PROMPT_X(w) + max (GREET_X_INC(w), FAIL_X_INC(w))))
d255 1
a255 1
realizeValue (LoginWidget w, int cursor, int promptNum, GC gc)
d257 1
a257 35
    loginPromptState state = w->login.prompts[promptNum].state;
    char *text = VALUE_TEXT(w, promptNum);
    int	x, y, height, width, curoff;

    XDM_ASSERT(promptNum >= 0 && promptNum <= LAST_PROMPT);

    x = VALUE_X (w,promptNum);
    y = PROMPT_Y (w,promptNum);

    height = PROMPT_H(w);
    width = PROMPT_W(w) - x - 3;

#ifdef XPM
    height -= (w->login.inframeswidth * 2);
    width -= (w->login.inframeswidth * 2) +
	(w->login.logoWidth + 2*(w->login.logoPadding));
#endif
    if (cursor > VALUE_SHOW_START(w, promptNum))
	curoff = TEXT_WIDTH (text, text, cursor);
    else
	curoff = 0;


    if (gc == w->login.bgGC) {
	if (curoff < width) {
	    XFillRectangle (XtDisplay (w), XtWindow (w), gc,
			    x + curoff, y - TEXT_Y_INC(w),
			    width - curoff, height);
	}
    } else if ((state == LOGIN_PROMPT_ECHO_ON) || (state == LOGIN_TEXT_INFO)) {
	int textwidth;
	int offset = max(cursor, VALUE_SHOW_START(w, promptNum));
	int textlen = strlen (text + offset);
	
	textwidth = TEXT_WIDTH (text, text + offset, textlen);
d259 5
a263 26
	if (textwidth > (width - curoff)) {
	    /* Recalculate amount of text that can fit in field */
	    offset = VALUE_SHOW_START(w, promptNum);
	    textlen = strlen (text + offset);

	    do
	    {
		if (offset < PROMPT_CURSOR(w, promptNum)) {
		    offset++;
		}
		textlen--;
		textwidth = TEXT_WIDTH (text, text + offset, textlen);
	    } while ((textlen > 0) && (textwidth > width));

	    VALUE_SHOW_START(w, promptNum) = offset;
	    VALUE_SHOW_END(w, promptNum) = offset + textlen;

	    /* Erase old string */
	    XFillRectangle (XtDisplay (w), XtWindow (w), w->login.bgGC,
			    x, y - TEXT_Y_INC(w), width, height);

	    DRAW_STRING(text, x, y, text + offset, textlen);
	} else {
	    DRAW_STRING(text, x + curoff, y, text + offset, textlen);
	}
    }
d267 1
a267 1
EraseValue (LoginWidget w, int cursor, int promptNum)
d269 7
a275 2
    realizeValue(w, cursor, promptNum, w->login.bgGC);
}
a276 4
static void
DrawValue (LoginWidget w, int cursor, int promptNum)
{
    realizeValue(w, cursor, promptNum, w->login.textGC);
d278 3
a280 3
    /*as good a place as any Caolan begin*/
    w->login.lastEventTime = time(NULL);
    /*as good a place as any Caolan end*/
d290 8
a297 28
#ifdef FORCE_CURSOR_FLASH    
    static int lastx, lasty;
    static struct timeval  lastFlash;
    struct timeval  now, timeout;
    int sinceLastFlash;
#endif

    if (w->login.state != PROMPTING) {
	return;
    }
    
    x = VALUE_X (w, w->login.activePrompt);
    y = PROMPT_Y (w, w->login.activePrompt);
    height = (F_ASCENT(text) + F_DESCENT(text));
    width = 1;

    switch (PROMPT_STATE(w, w->login.activePrompt)) {
    case LOGIN_PROMPT_NOT_SHOWN:
    case LOGIN_TEXT_INFO:
	return;
    case LOGIN_PROMPT_ECHO_ON:
	if (CUR_PROMPT_CURSOR(w) > 0) {
	    x += TEXT_WIDTH (text,
			     VALUE_TEXT(w, w->login.activePrompt)
			     + VALUE_SHOW_START(w, w->login.activePrompt),
			     PROMPT_CURSOR(w, w->login.activePrompt)
			     - VALUE_SHOW_START(w, w->login.activePrompt) );
	}
d299 5
a303 2
    case LOGIN_PROMPT_ECHO_OFF:
	/* Nothing special needed */
d305 2
d308 1
a308 1
    
d310 1
a310 2
    XFillRectangle (XtDisplay (w), XtWindow (w), gc,
		    x, y - F_ASCENT(text), width, height);
d312 1
a312 2
    XFillRectangle (XtDisplay (w), XtWindow (w), gc,
		    x, y+1 - F_ASCENT(text), width, height-1);
d314 1
a314 1
    		    x-1 , y - F_ASCENT(text));
d316 1
a316 1
    		    x+1 , y - F_ASCENT(text));
d318 1
a318 1
    		    x-1 , y - F_ASCENT(text)+height);
d320 1
a320 1
    		    x+1 , y - F_ASCENT(text)+height);
d322 1
a322 1
    		    x-2 , y - F_ASCENT(text));
d324 1
a324 1
    		    x+2 , y - F_ASCENT(text));
d326 1
a326 1
    		    x-2 , y - F_ASCENT(text)+height);
d328 1
a328 1
    		    x+2 , y - F_ASCENT(text)+height);
a329 29

#ifdef FORCE_CURSOR_FLASH
    /* Force cursor to flash briefly to give user feedback */
#define FLASH_MILLIS    100000 /* 0.10 seconds */
#define MILLIS_PER_SEC 1000000    
    X_GETTIMEOFDAY (&now);

    if ((lastx == x) && (lasty == y)) {
	if (lastFlash.tv_sec == 0)
	    sinceLastFlash = 0;
	else if ((lastFlash.tv_sec + 1) == now.tv_sec)
	    sinceLastFlash =
		(now.tv_usec + MILLIS_PER_SEC) - lastFlash.tv_usec;
	else if (lastFlash.tv_sec == now.tv_sec)
	    sinceLastFlash = now.tv_usec - lastFlash.tv_usec;
	else
	    sinceLastFlash = (now.tv_sec - lastFlash.tv_sec) * MILLIS_PER_SEC;

	if (sinceLastFlash < FLASH_MILLIS) {
	    timeout.tv_sec = 0;
	    timeout.tv_usec = FLASH_MILLIS - sinceLastFlash;
	    select(0, NULL, NULL, NULL, &timeout);
	}
    } else {
	lastx = x; lasty = y;
    }
    X_GETTIMEOFDAY (&lastFlash);
#endif /* FORCE_CURSOR_FLASH */
    XFlush (XtDisplay(w));    
d335 3
a337 4
#ifdef USE_XFT 
    w->login.failUp = 0;
    RedrawFail(w);
#else    
d340 3
a342 1
    RedrawFail(w);
d345 1
a345 2
			TEXT_COLOR(fail));
#endif    
a372 1
    w->login.interval_id = 0;
a375 1
_X_INTERNAL
d385 8
a392 1
    ErrorMessage(ctx, w->login.failMsg, True);
a399 1
    int maxw = w->core.width - PAD_X(w);
a400 1
#ifndef USE_XFT    
d402 3
a404 99
#endif	
    {
	Debug("RedrawFail('%s', %d)\n", w->login.fail, w->login.failUp);
	if (ERROR_W(w, w->login.fail) > maxw) {
	    /* Too long to fit on one line, break into multiple lines */
	    char *tempCopy = strdup(w->login.fail);
	    if (tempCopy != NULL) {
		char *start, *next;
		char lastspace;

		y = PROMPT_Y(w,LAST_PROMPT) + (2 * PROMPT_Y_INC(w));
		
		for (start = next = tempCopy; start != NULL ; start = next) {
		    /* search for longest string broken by whitespace that
		       will fit on a single line */
		    do {
			if (next != start) {
			    *next = lastspace;
			}
			for (next = next + 1;
			     (*next != '\0') && !isspace(*next) ; next++)
			{
			    /* this loop intentionally left blank */
			}
			if (*next != '\0') {
			    lastspace = *next;
			    *next = '\0';
			} else {
			    next = NULL;
			}
		    } while ((next != NULL) && ERROR_W(w, start) < maxw);
		    
		    x = ERROR_X(w, start);
#ifdef USE_XFT
		    if (w->login.failUp == 0) {
			XClearArea(XtDisplay(w), XtWindow(w), x, y,
				   ERROR_W(w, start), FAIL_Y_INC(w), False);
		    } else
#endif		    
			DRAW_STRING (fail, x, y, start, strlen(start));

		    if (next != NULL) {
			next++;
			y += FAIL_Y_INC(w);
		    }
		}
		free(tempCopy);
		return;
	    }
	    /* if strdup failed, fall through to draw all at once, even
	       though we know it can't all fit */
	    LogOutOfMem("RedrawFail");
	}

#ifdef USE_XFT
	if (w->login.failUp == 0) {
	    XClearArea(XtDisplay(w), XtWindow(w), x, y,
		       ERROR_W(w, w->login.fail), FAIL_Y_INC(w), False);
	} else
#endif		    
	    DRAW_STRING (fail, x, y, w->login.fail, strlen (w->login.fail));
    }
}

_X_INTERNAL
void
ErrorMessage(Widget ctx, const char *message, Bool timeout)
{
    LoginWidget	w = (LoginWidget) ctx;

/*  Debug("ErrorMessage: %s\n", message);   */
    if (w->login.interval_id != 0) {
	XtRemoveTimeOut(w->login.interval_id);
	w->login.interval_id = 0;
    }
    RemoveFail(w);
    if (w->login.fail != w->login.failMsg)
	free(w->login.fail);
    w->login.fail = strdup(message);
    if (w->login.fail == NULL)
	w->login.fail = (char *) w->login.failMsg;
    w->login.failUp = 1;
    RedrawFail (w);
    if (timeout && (w->login.failTimeout > 0)) {
	Debug ("failTimeout: %d\n", w->login.failTimeout);
	w->login.interval_id =
	    XtAppAddTimeOut(XtWidgetToApplicationContext ((Widget)w),
			    w->login.failTimeout * 1000,
			    failTimeout, (XtPointer) w);
    }
}

_X_INTERNAL
void
ShowChangePasswdMessage(Widget ctx)
{
    LoginWidget	w = (LoginWidget) ctx;

    ErrorMessage(ctx, w->login.passwdChangeMsg, False);
a409 1
    int p;
d411 1
a411 1
    int i;
d447 8
d456 1
a456 1
    for (p = 0; p < NUM_PROMPTS ; p++)
d458 25
a482 17
	int in_frame_x = VALUE_X(w,p) - w->login.inframeswidth - 3;
	int in_frame_y
	    = PROMPT_Y(w,p) - w->login.inframeswidth - 1 - TEXT_Y_INC(w);
 
	int in_width = PROMPT_W(w) - VALUE_X(w,p) -
	    (w->login.logoWidth + 2*(w->login.logoPadding));
	int in_height = PROMPT_H(w) + w->login.inframeswidth + 2;
	
	GC topLeftGC, botRightGC;
	
	if ((PROMPT_STATE(w, p) == LOGIN_PROMPT_ECHO_ON) ||
	    (PROMPT_STATE(w, p) == LOGIN_PROMPT_ECHO_OFF)) {
	    topLeftGC = w->login.shdGC;
	    botRightGC = w->login.hiGC;
	} else {
	    topLeftGC = botRightGC = w->login.bgGC;
	}
d484 7
a490 20
	for (i=1; i<=(w->login.inframeswidth); i++)
	{
	    /* Make top/left sides */
	    XDrawLine(XtDisplay (w), XtWindow (w), topLeftGC,
		      in_frame_x + i-1,         in_frame_y + i-1,
		      in_frame_x + in_width-i,  in_frame_y + i-1); 

	    XDrawLine(XtDisplay (w), XtWindow (w), topLeftGC,
		      in_frame_x + i-1,         in_frame_y + i-1,
		      in_frame_x + i-1,         in_frame_y + in_height-i); 

	    /* Make bottom/right sides */
	    XDrawLine(XtDisplay (w), XtWindow (w), botRightGC,
		      in_frame_x + in_width-i,  in_frame_y + i-1,
		      in_frame_x + in_width-i,  in_frame_y + in_height-i); 

	    XDrawLine(XtDisplay (w), XtWindow (w), botRightGC,
		      in_frame_x + i-1,         in_frame_y + in_height-i,
		      in_frame_x + in_width-i,  in_frame_y + in_height-i);
	}
d494 4
a497 5
    if (GREETING(w)[0]) {
	int gx;

#ifdef XPM
	gx = GREET_X(w) - ((w->login.logoWidth/2) + w->login.logoPadding);
d499 11
a509 11
	gx = GREET_X(w);
#endif	
	DRAW_STRING (greet, gx, GREET_Y(w), GREETING(w), strlen (GREETING(w)));
    }
    for (p = 0; p < NUM_PROMPTS ; p++) {
	if (PROMPT_STATE(w, p) != LOGIN_PROMPT_NOT_SHOWN) {
	    DRAW_STRING (prompt, PROMPT_X(w), PROMPT_Y(w,p),
			 CUR_PROMPT_TEXT(w,p), strlen (CUR_PROMPT_TEXT(w,p)));
	    DrawValue (w, 0, p);
	}
    }
d511 1
a528 172
/* Returns 0 on success, -1 on failure */
_X_INTERNAL
int
SetPrompt (Widget ctx, int promptNum, const char *message,
	   loginPromptState state, Boolean minimumTime)
{
    LoginWidget	w = (LoginWidget) ctx;
    char *prompt;
    int messageLen, e;
    const char *stateNames[4] = {
	"LOGIN_PROMPT_NOT_SHOWN", "LOGIN_PROMPT_ECHO_ON",
	"LOGIN_PROMPT_ECHO_OFF", "LOGIN_TEXT_INFO" };
    loginPromptState priorState;
    
    Debug("SetPrompt(%d, %s, %s(%d))\n", promptNum,
	  message ? message : "<NULL>", stateNames[state], state);

    XDM_ASSERT(promptNum >= 0 && promptNum <= LAST_PROMPT);
    
    if (PROMPT_TEXT(w, promptNum) != NULL) {
	XtFree(PROMPT_TEXT(w, promptNum));
	PROMPT_TEXT(w, promptNum) = NULL;
    }

    priorState = PROMPT_STATE(w, promptNum);
    PROMPT_STATE(w, promptNum) = state;

    if (state == LOGIN_PROMPT_NOT_SHOWN) {
	return 0;
    }

    if (message == NULL) {
	message = DEF_PROMPT_TEXT(w, promptNum);
    }

    messageLen = strlen(message);
    
    prompt = XtMalloc(messageLen + 3);
    if (prompt == NULL) {
	LogOutOfMem ("SetPrompt");
	return -1;
    }
    
    strncpy(prompt, message, messageLen);
    
    /* Make sure text prompts have at least two spaces at end */
    e = messageLen;
	    
    if (!isspace(message[messageLen - 2])) {
	prompt[e] = ' ';
	e++;
    }
    if (!isspace(message[messageLen - 1])) {
	prompt[e] = ' ';
	e++;
    }
    prompt[e] = '\0';

    PROMPT_TEXT(w, promptNum) = prompt;

    if (w->login.state == INITIALIZING) {
	return 0;
    }
    
    if ((priorState == LOGIN_TEXT_INFO) && (w->login.msgTimeout != 0)) {
	time_t now = time(NULL);
	int timeleft = w->login.msgTimeout - now;
	
	if (timeleft > 0) {
	    sleep(timeleft);
	}
	w->login.msgTimeout = 0;
    }

    if (state == LOGIN_TEXT_INFO) {
	if (minimumTime) {
	    time_t now = time(NULL);
	    w->login.msgTimeout = now + w->login.failTimeout;
	}
	w->login.state = SHOW_MESSAGE;
    } else {
	w->login.activePrompt = promptNum;
	w->login.state = PROMPTING;
    }
    
    PROMPT_CURSOR(w, promptNum) = 0;
    XClearArea (XtDisplay(w), XtWindow(w), 0, 0, 0, 0, FALSE);
    draw_it(w);
    return 0;
}

_X_INTERNAL
const char *
GetPrompt(Widget ctx, int promptNum)
{
    LoginWidget	w = (LoginWidget) ctx;

    XDM_ASSERT(promptNum >= 0 && promptNum <= LAST_PROMPT);
    
    return CUR_PROMPT_TEXT(w,promptNum);
}

_X_INTERNAL
int
SetValue(Widget ctx, int promptNum, char *value)
{
    LoginWidget	w = (LoginWidget) ctx;

    XDM_ASSERT(promptNum >= 0 && promptNum <= LAST_PROMPT);
    
    if ((promptNum < 0) || (promptNum > LAST_PROMPT))
	return -1;

    XDM_ASSERT(VALUE_TEXT(w, promptNum) != NULL);
    
    if (VALUE_TEXT(w, promptNum) == NULL)
	return -1;

    if (value == NULL) {
	bzero(VALUE_TEXT(w, promptNum), VALUE_TEXT_MAX(w, promptNum));
    } else {
	strncpy(VALUE_TEXT(w, promptNum), value, VALUE_TEXT_MAX(w, promptNum));
	VALUE_TEXT(w, promptNum)[VALUE_TEXT_MAX(w, promptNum)] = '\0';
    }

    VALUE_SHOW_START(w, promptNum) = 0;
    VALUE_SHOW_END(w, promptNum) = 0;
    PROMPT_CURSOR(w, promptNum) = 0;
    
    return 0;
}

_X_INTERNAL
const char *
GetValue(Widget ctx, int promptNum)
{
    LoginWidget	w = (LoginWidget) ctx;

    XDM_ASSERT(promptNum >= 0 && promptNum <= LAST_PROMPT);
    
    if ((promptNum < 0) || (promptNum > LAST_PROMPT))
	return NULL;

    XDM_ASSERT(VALUE_TEXT(w, promptNum) != NULL);

    return VALUE_TEXT(w, promptNum);
}


static void
realizeDeleteChar (LoginWidget ctx)
{
    if (ctx->login.state == PROMPTING) {
	int promptNum = ctx->login.activePrompt;
	int redrawFrom = PROMPT_CURSOR(ctx, promptNum);
	
	if (PROMPT_CURSOR(ctx,promptNum) <  (int)strlen(VALUE_TEXT(ctx,promptNum))) {
	    if (redrawFrom < VALUE_SHOW_START(ctx, ctx->login.activePrompt)) {
		redrawFrom = 0;
		EraseValue (ctx, redrawFrom, promptNum);
		VALUE_SHOW_START(ctx, ctx->login.activePrompt)
		    = PROMPT_CURSOR(ctx,promptNum);
	    } else {
		EraseValue (ctx, redrawFrom, promptNum);
	    }
	    strcpy(VALUE_TEXT(ctx, promptNum) + PROMPT_CURSOR(ctx, promptNum),
		   VALUE_TEXT(ctx, promptNum) + PROMPT_CURSOR(ctx, promptNum) + 1);
	    DrawValue (ctx, redrawFrom, promptNum);
	}
    }
}

d535 1
d537 14
a550 9

    if (ctx->login.state != PROMPTING) {
	return;
    }

    XorCursor (ctx);
    if (CUR_PROMPT_CURSOR(ctx) > 0) {
	CUR_PROMPT_CURSOR(ctx) -= 1;
	realizeDeleteChar(ctx);
d561 1
d563 15
a577 3

    if (ctx->login.state != PROMPTING) {
	return;
a578 3

    XorCursor (ctx);
    realizeDeleteChar(ctx);
d592 1
d594 2
a595 14

    if (ctx->login.state != PROMPTING) {
	return;
    }

    XorCursor (ctx);
    if (CUR_PROMPT_CURSOR(ctx) > 0)
	CUR_PROMPT_CURSOR(ctx) -= 1;
    if (CUR_PROMPT_CURSOR(ctx) < VALUE_SHOW_START(ctx, ctx->login.activePrompt)) {
	EraseValue(ctx, 0, ctx->login.activePrompt);
	VALUE_SHOW_START(ctx, ctx->login.activePrompt)
	    = CUR_PROMPT_CURSOR(ctx);
	DrawValue(ctx, 0, ctx->login.activePrompt);
    }
d609 1
d611 9
a619 14

    if (ctx->login.state != PROMPTING) {
	return;
    }

    XorCursor (ctx);
    if (CUR_PROMPT_CURSOR(ctx) <
	(int)strlen(VALUE_TEXT(ctx,ctx->login.activePrompt))) {
	CUR_PROMPT_CURSOR(ctx) += 1;
	if (VALUE_SHOW_END(ctx, ctx->login.activePrompt)
	    < CUR_PROMPT_CURSOR(ctx)) {
	    EraseValue(ctx, 0, ctx->login.activePrompt);
	    DrawValue(ctx, 0, ctx->login.activePrompt);
	}
d634 1
d636 1
a636 12

    if (ctx->login.state != PROMPTING) {
	return;
    }

    XorCursor (ctx);
    CUR_PROMPT_CURSOR(ctx) = 0;
    if (VALUE_SHOW_START(ctx, ctx->login.activePrompt) > 0) {
	EraseValue(ctx, 0, ctx->login.activePrompt);
	VALUE_SHOW_START(ctx, ctx->login.activePrompt) = 0;
	DrawValue(ctx, 0, ctx->login.activePrompt);
    }
d650 1
d652 7
a658 10

    if (ctx->login.state != PROMPTING) {
	return;
    }

    XorCursor (ctx);
    CUR_PROMPT_CURSOR(ctx) = strlen (VALUE_TEXT(ctx, ctx->login.activePrompt));
    if (VALUE_SHOW_END(ctx, ctx->login.activePrompt) < CUR_PROMPT_CURSOR(ctx)) {
	EraseValue(ctx, 0, ctx->login.activePrompt);
	DrawValue(ctx, 0, ctx->login.activePrompt);
d673 1
d675 8
a682 3

    if (ctx->login.state != PROMPTING) {
	return;
a683 7

    XorCursor (ctx);
    EraseValue (ctx, CUR_PROMPT_CURSOR(ctx), ctx->login.activePrompt);
    bzero(VALUE_TEXT(ctx, ctx->login.activePrompt) +
	  CUR_PROMPT_CURSOR(ctx),
	  VALUE_TEXT_MAX(ctx, ctx->login.activePrompt) -
	  CUR_PROMPT_CURSOR(ctx));
a707 2
    int promptNum = ctx->login.activePrompt;
    int nextPrompt;
d709 1
d711 6
a716 15

    if (ctx->login.state != PROMPTING) {
	return;
    }

    XorCursor (ctx);

    for (nextPrompt = promptNum + 1; nextPrompt <= LAST_PROMPT; nextPrompt++) {
	if ((PROMPT_STATE(ctx, nextPrompt) == LOGIN_PROMPT_ECHO_ON) ||
	    (PROMPT_STATE(ctx, nextPrompt) == LOGIN_PROMPT_ECHO_OFF)) {
	    ctx->login.activePrompt = nextPrompt;
	    break;
	}
    }
    if (nextPrompt > LAST_PROMPT) {
d718 1
d720 1
a720 3
	Debug("FinishField #%d: now DONE\n", promptNum);
    } else {
	Debug("FinishField #%d: %d next\n", promptNum, nextPrompt);
a721 1

d725 1
a730 2
    int promptNum = ctx->login.activePrompt;
    int nextPrompt;
d732 1
d734 9
a742 17

    if (ctx->login.state != PROMPTING) {
	return;
    }

    XorCursor (ctx);

    for (nextPrompt = promptNum + 1; nextPrompt != promptNum; nextPrompt++) {
	if (nextPrompt > LAST_PROMPT) {
	    nextPrompt = 0;
	}
    
	if ((PROMPT_STATE(ctx, nextPrompt) == LOGIN_PROMPT_ECHO_ON) ||
	    (PROMPT_STATE(ctx, nextPrompt) == LOGIN_PROMPT_ECHO_OFF)) {
	    ctx->login.activePrompt = nextPrompt;
	    break;
	}
d746 1
d780 1
a780 1
    ctx->login.sessionArg = NULL;
d803 1
d821 1
d839 1
d847 5
a851 10
    int i;

    for (i = 0; i < NUM_PROMPTS ; i++) {
	EraseValue(w, 0, i);
	bzero(VALUE_TEXT(w, i), VALUE_TEXT_MAX(w, i));
	VALUE_SHOW_START(w, i) = 0;
	PROMPT_CURSOR(w, i) = 0;
    }
    w->login.state = PROMPTING;
    w->login.activePrompt = 0;
d894 5
a898 1
    int  len, promptNum = ctx->login.activePrompt;
d912 8
d966 14
a979 6
    if (ctx->login.state == PROMPTING) {	
	if ((len + (int)strlen(VALUE_TEXT(ctx, promptNum)) >=
	     (VALUE_TEXT_MAX(ctx,promptNum) - 1))) {
	    len = VALUE_TEXT_MAX(ctx,promptNum) -
		strlen(VALUE_TEXT(ctx, promptNum)) - 2;
	}
d981 7
a987 1
    EraseCursor (ctx);
d989 23
a1011 12
    if (len != 0)
    {
	if (ctx->login.state == PROMPTING) {
	    EraseValue (ctx, PROMPT_CURSOR(ctx, promptNum), promptNum);
	    memmove(VALUE_TEXT(ctx, promptNum) + PROMPT_CURSOR(ctx, promptNum) + len,
		    VALUE_TEXT(ctx, promptNum) + PROMPT_CURSOR(ctx, promptNum),
		    strlen (VALUE_TEXT(ctx, promptNum) + PROMPT_CURSOR(ctx, promptNum))+1);
	    memmove(VALUE_TEXT(ctx, promptNum) + PROMPT_CURSOR(ctx, promptNum),
		     strbuf, len);
	    DrawValue (ctx, PROMPT_CURSOR(ctx, promptNum), promptNum);
	    PROMPT_CURSOR(ctx, promptNum) += len;
	}
a1015 201

/**** Copied from xclock.c - original author: Keith Packard ****/
#ifdef USE_XFT
static XtConvertArgRec xftColorConvertArgs[] = {
    {XtWidgetBaseOffset, (XtPointer)XtOffsetOf(WidgetRec, core.screen),
     sizeof(Screen *)},
    {XtWidgetBaseOffset, (XtPointer)XtOffsetOf(WidgetRec, core.colormap),
     sizeof(Colormap)}
};

#define	donestr(type, value, tstr) \
	{							\
	    if (toVal->addr != NULL) {				\
		if (toVal->size < sizeof(type)) {		\
		    toVal->size = sizeof(type);			\
		    XtDisplayStringConversionWarning(dpy, 	\
			(char*) fromVal->addr, tstr);		\
		    return False;				\
		}						\
		*(type*)(toVal->addr) = (value);		\
	    }							\
	    else {						\
		static type static_val;				\
		static_val = (value);				\
		toVal->addr = (XPointer)&static_val;		\
	    }							\
	    toVal->size = sizeof(type);				\
	    return True;					\
	}

static void
XmuFreeXftColor (XtAppContext app, XrmValuePtr toVal, XtPointer closure,
		 XrmValuePtr args, Cardinal *num_args)
{
    Screen	*screen;
    Colormap	colormap;
    XftColor	*color;
    
    if (*num_args != 2)
    {
	XtAppErrorMsg (app,
		       "freeXftColor", "wrongParameters",
		       "XtToolkitError",
		       "Freeing an XftColor requires screen and colormap arguments",
		       (String *) NULL, (Cardinal *)NULL);
	return;
    }

    screen = *((Screen **) args[0].addr);
    colormap = *((Colormap *) args[1].addr);
    color = (XftColor *) toVal->addr;
    XftColorFree (DisplayOfScreen (screen),
		  DefaultVisual (DisplayOfScreen (screen),
				 XScreenNumberOfScreen (screen)),
		  colormap, color);
}
    
static Boolean
XmuCvtStringToXftColor(Display *dpy,
		       XrmValue *args, Cardinal *num_args,
		       XrmValue *fromVal, XrmValue *toVal,
		       XtPointer *converter_data)
{
    char	    *spec;
    XRenderColor    renderColor;
    XftColor	    xftColor;
    Screen	    *screen;
    Colormap	    colormap;
    
    if (*num_args != 2)
    {
	XtAppErrorMsg (XtDisplayToApplicationContext (dpy),
		       "cvtStringToXftColor", "wrongParameters",
		       "XtToolkitError",
		       "String to render color conversion needs screen and colormap arguments",
		       (String *) NULL, (Cardinal *)NULL);
	return False;
    }

    screen = *((Screen **) args[0].addr);
    colormap = *((Colormap *) args[1].addr);

    spec = (char *) fromVal->addr;
    if (strcasecmp (spec, XtDefaultForeground) == 0)
    {
	renderColor.red = 0;
	renderColor.green = 0;
	renderColor.blue = 0;
	renderColor.alpha = 0xffff;
    }
    else if (strcasecmp (spec, XtDefaultBackground) == 0)
    {
	renderColor.red = 0xffff;
	renderColor.green = 0xffff;
	renderColor.blue = 0xffff;
	renderColor.alpha = 0xffff;
    }
    else if (!XRenderParseColor (dpy, spec, &renderColor))
	return False;
    if (!XftColorAllocValue (dpy, 
			     DefaultVisual (dpy,
					    XScreenNumberOfScreen (screen)),
			     colormap,
			     &renderColor,
			     &xftColor))
	return False;
    
    donestr (XftColor, xftColor, XtRXftColor);
}

static void
XmuFreeXftFont (XtAppContext app, XrmValuePtr toVal, XtPointer closure,
		XrmValuePtr args, Cardinal *num_args)
{
    Screen  *screen;
    XftFont *font;
    
    if (*num_args != 1)
    {
	XtAppErrorMsg (app,
		       "freeXftFont", "wrongParameters",
		       "XtToolkitError",
		       "Freeing an XftFont requires screen argument",
		       (String *) NULL, (Cardinal *)NULL);
	return;
    }

    screen = *((Screen **) args[0].addr);
    font = *((XftFont **) toVal->addr);
    if (font)
	XftFontClose (DisplayOfScreen (screen), font);
}

static Boolean
XmuCvtStringToXftFont(Display *dpy,
		      XrmValue *args, Cardinal *num_args,
		      XrmValue *fromVal, XrmValue *toVal,
		      XtPointer *converter_data)
{
    char    *name;
    XftFont *font;
    Screen  *screen;
    
    if (*num_args != 1)
    {
	XtAppErrorMsg (XtDisplayToApplicationContext (dpy),
		       "cvtStringToXftFont", "wrongParameters",
		       "XtToolkitError",
		       "String to XftFont conversion needs screen argument",
		       (String *) NULL, (Cardinal *)NULL);
	return False;
    }

    screen = *((Screen **) args[0].addr);
    name = (char *) fromVal->addr;
    
    font = XftFontOpenName (dpy,
			    XScreenNumberOfScreen (screen),
			    name);
    if (font)
    {
	donestr (XftFont *, font, XtRXftFont);
    }
    XtDisplayStringConversionWarning(dpy, (char *) fromVal->addr, XtRXftFont);
    return False;
}

static XtConvertArgRec xftFontConvertArgs[] = {
    {XtWidgetBaseOffset, (XtPointer)XtOffsetOf(WidgetRec, core.screen),
     sizeof(Screen *)},
};


static int
XmuXftTextWidth(Display *dpy, XftFont *font, FcChar8 *string, int len)
{
    XGlyphInfo  extents;

    XftTextExtents8 (dpy, font, string, len, &extents);

    return extents.xOff;
}

#endif /* USE_XFT */

static void 
ClassInitialize(void)
{
#ifdef USE_XFT
    XtSetTypeConverter (XtRString, XtRXftColor, 
			XmuCvtStringToXftColor, 
			xftColorConvertArgs, XtNumber(xftColorConvertArgs),
			XtCacheByDisplay, XmuFreeXftColor);
    XtSetTypeConverter (XtRString, XtRXftFont,
			XmuCvtStringToXftFont,
			xftFontConvertArgs, XtNumber(xftFontConvertArgs),
			XtCacheByDisplay, XmuFreeXftFont);
#endif /* USE_XFT */
}
/**** End of portion borrowed from xclock ****/

d1047 1
a1047 1
    myXGCV.foreground = TEXT_COLOR(text);
d1050 2
a1051 3
#ifndef USE_XFT
    if (w->login.textFont) {
	myXGCV.font = w->login.textFont->fid;
a1053 1
#endif    
d1058 1
a1058 1
    myXGCV.foreground = TEXT_COLOR(text) ^ w->core.background_pixel;
a1062 1
#ifndef USE_XFT
d1068 2
a1069 2
    if (w->login.textFont == NULL)
	w->login.textFont = XQueryFont (XtDisplay (w),
d1074 1
a1074 1
        w->login.promptFont = w->login.textFont;
d1078 1
a1078 1
    myXGCV.foreground = TEXT_COLOR(prompt);
d1084 1
a1084 1
    	w->login.greetFont = w->login.textFont;
d1088 1
a1088 1
    myXGCV.foreground = TEXT_COLOR(greet);
d1094 1
a1094 1
	w->login.failFont = w->login.textFont;
d1097 2
a1098 1
    myXGCV.foreground = TEXT_COLOR(fail);
a1100 1
#endif /* USE_XFT */
d1158 4
a1161 4
    w->login.data.name[0] = '\0';
    w->login.data.passwd[0] = '\0';
    w->login.state = INITIALIZING;
    w->login.activePrompt = LOGIN_PROMPT_USERNAME;
a1162 18
    w->login.fail = (char *) w->login.failMsg;

    /* Set prompt defaults */
    PROMPT_TEXT(w, LOGIN_PROMPT_USERNAME) 	= NULL;
    DEF_PROMPT_TEXT(w, LOGIN_PROMPT_USERNAME) 	= w->login.namePrompt;
    VALUE_TEXT(w, LOGIN_PROMPT_USERNAME) 	= w->login.data.name;
    VALUE_TEXT_MAX(w, LOGIN_PROMPT_USERNAME)	= sizeof(w->login.data.name);
    VALUE_SHOW_START(w, LOGIN_PROMPT_USERNAME)	= 0;
    
    PROMPT_TEXT(w, LOGIN_PROMPT_PASSWORD) 	= NULL;
    DEF_PROMPT_TEXT(w, LOGIN_PROMPT_PASSWORD) 	= w->login.passwdPrompt;
    VALUE_TEXT(w, LOGIN_PROMPT_PASSWORD) 	= w->login.data.passwd;
    VALUE_TEXT_MAX(w, LOGIN_PROMPT_PASSWORD)	= sizeof(w->login.data.passwd);
    VALUE_SHOW_START(w, LOGIN_PROMPT_PASSWORD)	= 0;

    SetPrompt(gnew, LOGIN_PROMPT_PASSWORD, NULL, LOGIN_PROMPT_ECHO_OFF, False);
    SetPrompt(gnew, LOGIN_PROMPT_USERNAME, NULL, LOGIN_PROMPT_ECHO_ON, False);
    
a1202 2

    w->login.state = PROMPTING;
a1217 8

#ifdef USE_XFT
    w->login.draw = XftDrawCreate (XtDisplay (w), XtWindow(w),
	   DefaultVisual (XtDisplay (w), DefaultScreen(XtDisplay (w))),
				   w->core.colormap);

#endif

a1273 13

    if (PROMPT_TEXT(w,0) != NULL)
	XtFree(PROMPT_TEXT(w,0));
    if (PROMPT_TEXT(w,1) != NULL)
	XtFree(PROMPT_TEXT(w,1));

#ifdef USE_XFT
    if (w->login.draw) {
	XftDrawDestroy(w->login.draw);
	w->login.draw = NULL;
    }
#endif    
    
a1276 1
#ifndef USE_XFT
a1279 1
#endif
a1320 1
static
d1341 3
d1346 1
a1348 1
static
d1359 1
d1361 1
d1375 1
a1375 1
    /* class_initialize		*/	ClassInitialize,
@


1.1.1.3
log
@xdm 1.1.6
@
text
@d88 1
a90 2
#include <X11/cursorfont.h>

d138 1
a138 1
#ifdef DANCING
a142 1
#endif /* DANCING */
a143 1
#ifdef XPM    
d152 1
a152 1
#endif /* XPM */
d166 1
d301 3
a303 1

d305 1
d333 3
d337 1
a337 1

d376 1
d378 2
a379 3
    width -= (w->login.inframeswidth * 2);
#ifdef XPM
    width -= (w->login.logoWidth + 2*(w->login.logoPadding));
d405 1
a405 1
	    while ((textlen > 0) && (textwidth > width))
d412 1
a412 1
	    } 
d438 1
a438 1
#ifdef DANCING
d442 1
a442 1
#endif /* DANCING */
d485 4
d507 1
d711 1
d714 1
d718 1
d734 1
a734 1
    gr_line_x = w->login.outframewidth;
d736 3
a738 7
    gr_line_w = w->core.width - 2*(w->login.outframewidth);

#ifdef XPM
    gr_line_x += w->login.logoPadding;
    gr_line_w -= w->login.logoWidth + (3 * (w->login.logoPadding));
#endif /* XPM */

d755 2
a756 1
	int in_width = PROMPT_W(w) - VALUE_X(w,p);
a759 4

#ifdef XPM	
	in_width -= (w->login.logoWidth + 2*(w->login.logoPadding));
#endif /* XPM */
d790 1
d793 1
a793 1
	int gx = GREET_X(w);
d796 3
a798 1
	gx -= ((w->login.logoWidth/2) + w->login.logoPadding);
d1699 2
d1712 1
d1901 1
d1904 1
a1904 1

d1916 1
d1918 1
a1918 1
    XDefineCursor(XtDisplay(gw), DefaultRootWindow(XtDisplay(gw)), cursor);
a1919 1
#ifdef XPM
d1993 1
a1996 1
#ifdef XPM
d2104 3
d2108 1
@


