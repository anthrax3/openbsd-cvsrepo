head	1.4;
access;
symbols
	OPENBSD_6_1:1.4.0.8
	OPENBSD_6_1_BASE:1.4
	OPENBSD_6_0:1.4.0.6
	OPENBSD_6_0_BASE:1.4
	OPENBSD_5_9:1.4.0.4
	OPENBSD_5_9_BASE:1.4
	OPENBSD_5_8:1.4.0.2
	OPENBSD_5_8_BASE:1.4
	OPENBSD_5_7:1.3.0.6
	OPENBSD_5_7_BASE:1.3
	OPENBSD_5_6:1.3.0.4
	OPENBSD_5_6_BASE:1.3
	OPENBSD_5_5:1.3.0.2
	OPENBSD_5_5_BASE:1.3
	OPENBSD_5_4:1.2.0.16
	OPENBSD_5_4_BASE:1.2
	OPENBSD_5_3:1.2.0.14
	OPENBSD_5_3_BASE:1.2
	OPENBSD_5_2:1.2.0.12
	OPENBSD_5_2_BASE:1.2
	OPENBSD_5_1_BASE:1.2
	OPENBSD_5_1:1.2.0.10
	OPENBSD_5_0:1.2.0.8
	OPENBSD_5_0_BASE:1.2
	OPENBSD_4_9:1.2.0.4
	OPENBSD_4_9_BASE:1.2
	OPENBSD_4_8:1.2.0.6
	OPENBSD_4_8_BASE:1.2
	OPENBSD_4_7:1.2.0.2
	OPENBSD_4_7_BASE:1.2
	OPENBSD_4_6:1.1.1.2.0.8
	OPENBSD_4_6_BASE:1.1.1.2
	OPENBSD_4_5:1.1.1.2.0.6
	OPENBSD_4_5_BASE:1.1.1.2
	OPENBSD_4_4:1.1.1.2.0.4
	OPENBSD_4_4_BASE:1.1.1.2
	OPENBSD_4_3_BASE:1.1.1.2
	OPENBSD_4_3:1.1.1.2.0.2
	v1_0_3:1.1.1.2
	OPENBSD_4_2:1.1.1.1.0.2
	OPENBSD_4_2_BASE:1.1.1.1
	v1_0_2:1.1.1.1
	xorg:1.1.1;
locks; strict;
comment	@ * @;


1.4
date	2015.05.10.10.21.18;	author matthieu;	state Exp;
branches;
next	1.3;
commitid	qbUFIZT2jFahjpQz;

1.3
date	2013.09.28.16.23.01;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2009.10.24.15.00.51;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.25.20.50.30;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.11.25.20.50.30;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2007.09.16.16.51.54;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.4
log
@Update to xman 1.1.4
@
text
@/*

Copyright (c) 1987, 1988  X Consortium

Permission is hereby granted, free of charge, to any person obtaining
a copy of this software and associated documentation files (the
"Software"), to deal in the Software without restriction, including
without limitation the rights to use, copy, modify, merge, publish,
distribute, sublicense, and/or sell copies of the Software, and to
permit persons to whom the Software is furnished to do so, subject to
the following conditions:

The above copyright notice and this permission notice shall be included
in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
IN NO EVENT SHALL THE X CONSORTIUM BE LIABLE FOR ANY CLAIM, DAMAGES OR
OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
OTHER DEALINGS IN THE SOFTWARE.

Except as contained in this notice, the name of the X Consortium shall
not be used in advertising or otherwise to promote the sale, use or
other dealings in this Software without prior written authorization
from the X Consortium.

*/


#include "globals.h"
#include "vendor.h"             /* vendor-specific defines and data */

#include <dirent.h>

#ifdef DEBUG
static char error_buf[BUFSIZ];  /* The buffer for error messages. */
#endif /* DEBUG */

static void AddToCurrentSection(Manual * local_manual, char *path);
static void InitManual(Manual * l_manual, char *label);
static void ReadCurrentSection(Manual * local_manual, char *path);
static void ReadMandescFile(SectionList ** section_list, char *path);
static void SortAndRemove(Manual * man, int number);
static void SortList(SectionList ** list);

#define SECT_ERROR -1

#ifndef       Byte
#define       Byte    unsigned char
#endif

#ifndef       reg
#define       reg     register
#endif

static void sortstrs(Byte * data[], int size, Byte * otherdata[]);
static void sortstrs_block(Byte **, Byte **, int, Byte, Byte **, Byte **);
static void sortstrs_block_oo(Byte **, Byte **, int, Byte, int *, int *,
                              Byte **, Byte **);

/*	Function Name: Man
 *	Description: Builds a list of all manual directories and files.
 *	Arguments: none.
 *	Returns: the number of manual sections.
 */

int
Man(void)
{
    SectionList *list = NULL;

    char *ptr, *lang = NULL, manpath[BUFSIZ], buf[BUFSIZ],
        *path, *current_label;
    int sect, num_alloced;

/*
 * Get the environment variable MANPATH, and if it doesn't exist then use
 * SYSMANPATH and LOCALMANPATH.
 */

    /* if MANPATH variable ends in ':'. So, should extend it's value to the
     * default search path.
     */

    *manpath = '\0';
    if ((ptr = getenv("MANPATH")) != NULL)
        strcpy(manpath, ptr);
    if (ptr == NULL || streq(ptr, "") || ptr[strlen(ptr) - 1] == ':') {
        lang = getenv("LANG");
#ifdef MANCONF
        if (!ReadManConfig(manpath + strlen(manpath)))
#endif
        {
#ifdef MANCONF
            if (manpath[strlen(manpath) - 1] != ':')
                strcat(manpath, ":");
#endif
            strcat(manpath, SYSMANPATH);
#ifdef LOCALMANPATH
            strcat(manpath, ":");
            strcat(manpath, LOCALMANPATH);
#endif
        }
    }

/*
 * Get the list of manual directories in the users MANPATH that we should
 * open to look for manual pages.  The ``mandesc'' file is read here.
 */

    for (path = manpath; (ptr = strchr(path, ':')) != NULL; path = ++ptr) {
        *ptr = '\0';
        if (lang != NULL) {
            strcpy(buf, path);
            strcat(buf, "/");
            strncat(buf, lang, sizeof(buf) - strlen(path) + 1);
            buf[sizeof(buf) - strlen(path) + 1] = '\0';
            ReadMandescFile(&list, buf);
        }
        ReadMandescFile(&list, path);
    }
    if (lang != NULL) {
        strcpy(buf, path);
        strcat(buf, "/");
        strncat(buf, lang, sizeof(buf) - strlen(path) + 1);
        buf[sizeof(buf) - strlen(path) + 1] = '\0';
        ReadMandescFile(&list, buf);
    }
    ReadMandescFile(&list, path);

    SortList(&list);

    sect = 0;
    num_alloced = SECTALLOC;
    manual = (Manual *) XtMalloc(sizeof(Manual) * num_alloced);
    InitManual(manual, list->label);
    manual[sect].flags = list->flags;
    current_label = NULL;

    while (list != NULL) {
        SectionList *old_list;

        if (current_label == NULL || streq(list->label, current_label))
            AddToCurrentSection(manual + sect, list->directory);
        else {
            if (manual[sect].nentries == 0) {   /* empty section, re-use it. */
                XtFree(manual[sect].blabel);
                manual[sect].blabel = list->label;
                manual[sect].flags = list->flags;
            }
            else {
                if (++sect >= num_alloced) {
                    num_alloced += SECTALLOC;
                    manual = (Manual *) XtRealloc((char *) manual,
                                              (sizeof(Manual) * num_alloced));
                    if (manual == NULL)
                        PrintError
                            ("Could not allocate memory for manual sections.");
                }
                InitManual(manual + sect, list->label);
                manual[sect].flags = list->flags;
            }
            AddToCurrentSection(manual + sect, list->directory);
        }
        /* Save label to see if it matches next entry. */
        current_label = list->label;
        old_list = list;
        list = list->next;
        XtFree((char *) old_list);      /* free what you allocate. */
    }
    if (manual[sect].nentries != 0)
        sect++;                 /* don't forget that last section. */

    SortAndRemove(manual, sect);

#ifdef notdef                   /* dump info. */
    DumpManual(sect);
#endif

/*
 * realloc manual to be minimum space necessary.
 */

    if (sect == 0)
        PrintError("No manual pages found.");
    manual = (Manual *) XtRealloc((char *) manual, (sizeof(Manual) * sect));
    if (manual == NULL)
        PrintError("Could not allocate memory for manual sections.");

    return (sect);              /* return the number of man sections. */
}

/*	Function Name: SortList
 *	Description: Sorts the list of sections to search.
 *	Arguments: list - a pointer to the list to sort.
 *	Returns: a sorted list.
 *
 * This is the most complicated part of the entire operation.
 * all sections with the same label must by right next to each other,
 * but the sections that are in the standard list have to come first.
 */

static void
SortList(SectionList ** list)
{
    SectionList *local;
    SectionList *head, *last, *inner, *old;

    if (*list == NULL)
        PrintError("No manual sections to read, exiting.");

/*
 * First step
 *
 * Look for standard list items, and more them to the top of the list.
 */

    last = NULL;                /* keep Saber happy. */
    for (local = *list; local->next != NULL; local = local->next) {
        if (local->flags) {
            if (local == *list) /* top element is already standard. */
                break;
            head = local;

            /* Find end of standard block */
            for (old = NULL; (local->next != NULL) && (local->flags);
                 old = local, local = local->next);

            if (old != NULL) {
                last->next = old->next; /* Move the block. */
                old->next = *list;
                *list = head;
            }

            break;              /* First step accomplished. */
        }
        last = local;
    }

/*
 *  Second step
 *
 *  Move items with duplicate labels right next to each other.
 *
 *  Changed to keep the order of the list entries unchanged.
 */

    for (local = *list; local->next != NULL; local = local->next) {
        head = local;
        old = inner = local->next;
        while (inner != NULL) {
            if (streq(inner->label, local->label)) {
                if (old != inner) {
                    old->next = inner->next;
                    last = inner->next;
                    inner->next = head->next;
                    head->next = inner;
                    head = inner;
                    old = inner = last;
                    continue;
                }
                else
                    head = inner;
            }
            old = inner;
            inner = inner->next;
        }
    }
}

/*	Function Name: ReadMandescFile
 *	Description: Reads the mandesc file, and adds more sections as
 *                   necessary.
 *	Arguments: path - path name if the current search directory.
 *                 section_list - pointer to the list of sections.
 *	Returns: TRUE in we should use default sections
 */

static void
ReadMandescFile(SectionList ** section_list, char *path)
{
    char mandesc_file[BUFSIZ];  /* full path to the mandesc file. */
    FILE *descfile;
    char string[BUFSIZ], local_file[BUFSIZ];
    Boolean use_defaults = TRUE;
    char *cp;

    snprintf(mandesc_file, sizeof(mandesc_file), "%s/%s", path, MANDESC);
    if ((descfile = fopen(mandesc_file, "r")) != NULL) {
        while (fgets(string, BUFSIZ, descfile) != NULL) {
            size_t len = strlen(string);

            if (len == 0)
                continue;
            if (string[len - 1] == '\n')
                string[len - 1] = '\0';  /* Strip off the CR. */

            if (streq(string, NO_SECTION_DEFAULTS)) {
                use_defaults = FALSE;
                continue;
            }

            if ((cp = strchr(string, '\t')) != NULL) {
                char *s;

                *cp++ = '\0';
                strcpy(local_file, MAN);
                strcat(local_file, string);
                if ((s = strchr(cp, '\t')) != NULL) {
                    *s++ = '\0';
                    if (streq(s, SUFFIX))
                        AddNewSection(section_list, path, local_file, cp,
                                      MSUFFIX);
                    else if (streq(s, FOLD))
                        AddNewSection(section_list, path, local_file, cp,
                                      MFOLD);
                    else if (streq(s, FOLDSUFFIX))
                        AddNewSection(section_list, path, local_file, cp,
                                      MFOLDSUFFIX);
                    else
                        AddNewSection(section_list, path, local_file, cp,
                                      MNULL);
                }
                else
                    AddNewSection(section_list, path, local_file, cp, MNULL);
            }
            else {
                snprintf(local_file, sizeof(local_file), "%s%c", MAN,
                         string[0]);
                AddNewSection(section_list, path, local_file, (string + 1),
                              FALSE);
#ifdef SEARCHOTHER
                snprintf(local_file, sizeof(local_file), "%s%c", SEARCHOTHER,
                         string[0]);
                AddNewSection(section_list, path, local_file, (string + 1),
                              FALSE);
#endif
            }
        }

        fclose(descfile);
    }
    if (use_defaults)
        AddStandardSections(section_list, path);
}

/*	Function Name: AddNewSection
 *	Description: Adds the new section onto the current section list.
 *	Arguments: list - pointer to the section list.
 *                 path - the path to the current manual section.
 *                 file - the file to save.
 *                 label - the current section label.
 *                 flags = 1 - add a suffix
 *			 = 2 - fold to lower case
 *	Returns: none.
 */

void
AddNewSection(SectionList ** list, const char *path, const char *file,
              const char *label, int flags)
{
    SectionList *local_list, *end;
    char full_path[BUFSIZ];

/* Allocate a new list element */

    local_list = (SectionList *) XtMalloc(sizeof(SectionList));

    if (*list != NULL) {
        for (end = *list; end->next != NULL; end = end->next);
        end->next = local_list;
    }
    else
        *list = local_list;

    local_list->next = NULL;
    local_list->label = XtNewString(label);
    snprintf(full_path, sizeof(full_path), "%s/%s", path, file);
    local_list->directory = XtNewString(full_path);
    local_list->flags = flags;
}

/*	Function Name: AddToCurrentSection
 *	Description: This function gets the names of the manual page
 *                   directories, then closes the directory.
 *	Arguments:  local_manual - a pointer to a manual pages structure.
 *                  path - the path to this directory.
 *	Returns: none.
 */

static void
AddToCurrentSection(Manual * local_manual, char *path)
{
    char temp_path[BUFSIZ];

#if defined(__OpenBSD__) || defined(__NetBSD__)
    snprintf(temp_path, sizeof(temp_path), "%s/%s", path, MACHINE);
    ReadCurrentSection(local_manual, temp_path);
#endif
    ReadCurrentSection(local_manual, path);
    snprintf(temp_path, sizeof(temp_path), "%s.%s", path,
             COMPRESSION_EXTENSION);
    ReadCurrentSection(local_manual, temp_path);
}

/*	Function Name: ReadCurrentSection
 *	Description: Actually does the work of adding entries to the
 *                   new section
 *	Arguments:  local_manual - a pointer to a manual pages structure.
 *                  path - the path to this directory.
 *                  compressed - Is this a compressed directory?
 *	Returns: TRUE if any entries are found.
 */

static void
ReadCurrentSection(Manual * local_manual, char *path)
{
    DIR *dir;
    register struct dirent *dp;

    register int nentries;
    register int nalloc;
    char full_name[BUFSIZ], *ptr;

    if ((dir = opendir(path)) == NULL) {
#ifdef DEBUG
        snprintf(error_buf, sizeof(error_buf), "Can't open directory %s", path);
        PopupWarning(NULL, error_buf);
#endif /* DEBUG */
        return;
    }

/*
 * Remove the compression extension from the path name.
 */

    if ((ptr = strrchr(path, '.')) != NULL) {
#if !defined(__SCO__) && !defined(ISC)
        if (streq(ptr + 1, COMPRESSION_EXTENSION))
#else
        if (strpbrk(ptr + 1, COMPRESSION_EXTENSIONS) != NULL)
#endif
            *ptr = '\0';
#ifdef GZIP_EXTENSION
        else if (streq(ptr + 1, GZIP_EXTENSION))
            *ptr = '\0';
#endif
#ifdef BZIP2_EXTENSION
        else if (streq(ptr + 1, BZIP2_EXTENSION))
            *ptr = '\0';
#endif
#ifdef LZMA_EXTENSION
        else if (streq(ptr + 1, LZMA_EXTENSION))
            *ptr = '\0';
#endif
    }

    nentries = local_manual->nentries;
    nalloc = local_manual->nalloc;

    while ((dp = readdir(dir)) != NULL) {
        char *name = dp->d_name;

        if (name[0] == '.')
            continue;
        if (strchr(name, '.') == NULL)
            continue;
        if (nentries >= nalloc) {
            nalloc += ENTRYALLOC;
            local_manual->entries =
                (char **) XtRealloc((char *) local_manual->entries,
                                    nalloc * sizeof(char *));
            local_manual->entries_less_paths =
                (char **) XtRealloc((char *) local_manual->entries_less_paths,
                                    nalloc * sizeof(char *));
        }

        snprintf(full_name, sizeof(full_name), "%s/%s", path, name);
/*
 * Remove the compression extension from the entry name.
 */

        if ((ptr = strrchr(full_name, '.')) != NULL) {
#if !defined(__SCO__) && !defined(ISC)
            if (streq(ptr + 1, COMPRESSION_EXTENSION))
#else
            if (strpbrk(ptr + 1, COMPRESSION_EXTENSIONS) != NULL)
#endif
                *ptr = '\0';
#ifdef GZIP_EXTENSION
            else if (streq(ptr + 1, GZIP_EXTENSION))
                *ptr = '\0';
#endif
#ifdef BZIP2_EXTENSION
            else if (streq(ptr + 1, BZIP2_EXTENSION))
                *ptr = '\0';
#endif
#ifdef LZMA_EXTENSION
            else if (streq(ptr + 1, LZMA_EXTENSION))
                *ptr = '\0';
#endif
#ifdef IGNORE_EXTENSION
            /* skip files with specified extension - they're not real man pages */
            else if (streq(ptr + 1, IGNORE_EXTENSION)) {
                continue;
            }
#endif /* IGNORE_EXTENSION */
        }
        local_manual->entries[nentries] = XtNewString(full_name);
        local_manual->entries_less_paths[nentries] =
            strrchr(local_manual->entries[nentries], '/');
        if (local_manual->entries_less_paths[nentries] == NULL)
            PrintError("Internal error while cataloging manual pages.");
        ++nentries;
    }

    local_manual->nentries = nentries;
    local_manual->nalloc = nalloc;

    closedir(dir);
}

/*	Function Name: SortAndRemove
 *	Description: This function sorts all the entry names and
 *                   then removes all the duplicate entries.
 *	Arguments: man - a pointer to the manual structure.
 *                 number - the number of manual sections.
 *	Returns: an improved manual stucure
 */

static void
SortAndRemove(Manual * man, int number)
{
    int i;
    char *l1, *l2, **s1;

    for (i = 0; i < number; man++, i++) {       /* sort each section */
        register int i2 = 0;

#ifdef DEBUG
        printf("sorting section %d - %s\n", i, man->blabel);
#endif /* DEBUG */

        s1 = (char **) malloc(man->nentries * sizeof(char *));

        /* temporarily remove suffixes of entries, preventing them from */
        /* being used in alphabetic comparison ie sccs-delta.1 vs sccs.1 */
        for (i2 = 0; i2 < man->nentries; i2++)
            if ((s1[i2] = strrchr(man->entries_less_paths[i2], '.')) != NULL)
                *s1[i2] = '\0';

        sortstrs((Byte **) man->entries_less_paths, man->nentries,
                 (Byte **) man->entries);

        /* put back suffixes */
        for (i2 = 0; i2 < man->nentries; i2++)
            if (s1[i2] != NULL)
                *s1[i2] = '.';

        free(s1);

#ifdef DEBUG
        printf("removing from section %d.\n", i);
#endif /* DEBUG */

        {
            register int j, k, nent, nentm1;
            int j2;

            nent = man->nentries;
            nentm1 = nent - 1;
            j = 0;
            l2 = man->entries_less_paths[j++];
            if (l2 == NULL)
                PrintError
                    ("Internal error while removing duplicate manual pages.");
            while (j < nentm1) {
                l1 = l2;
                l2 = man->entries_less_paths[j++];
                if (l2 == NULL)
                    PrintError
                        ("Internal error while removing duplicate manual pages.");
                if (streq(l1, l2)) {
                    j2 = j - 1;
                    k = j2;
                    while (j < nent) {
                        man->entries_less_paths[k] = man->entries_less_paths[j];
                        man->entries[k++] = man->entries[j++];
                    }
                    j = j2;
                    --man->nentries;
                    --nent;
                    --nentm1;
                }
            }
        }
    }
}

 /*
  *******  Replacement for qsort to keep
  *******  identical entries in order

  A somewhat ugly hack of something that was once simpler...
  */
 /*
    Sort an array of pointers to strings, keeping it
    in ascending order by (1) string comparison and
    (2) original entry order in the pointer array.

    This is a modified radix exchange algorithm.

    In case there's insufficient memory for a temporary copy
    of the pointer array, the original order of identical strings
    isn't preserved.
  */

static void
sortstrs(Byte * data[], int size, Byte * otherdata[])
{
    Byte **sp, **ep;
    Byte **othersp, **otherep;
    int *origorder;

    origorder = (int *) calloc(size, sizeof(int));
    if (origorder) {
        reg int i;

        for (i = 0; i < size; ++i)
            origorder[i] = i;
    }

    sp = data;
    ep = &data[size - 1];
    othersp = otherdata;
    otherep = &otherdata[size - 1];
    if (origorder) {
        sortstrs_block_oo(sp, ep, 0, 0x80, origorder, &origorder[size - 1],
                          othersp, otherep);
        free(origorder);
    }
    else
        sortstrs_block(sp, ep, 0, 0x80, othersp, otherep);
}



 /*---------------------------------*/
 /*  Sort 1 block of data on 1 bit  */
 /*---------------------------------*/

static void
sortstrs_block(Byte ** start, Byte ** end, int offset, Byte mask,
               Byte ** otherstart, Byte ** otherend)
{
    reg Byte **sp, **ep;
    reg Byte m;
    reg int off;
    reg Byte *t;
    reg int curstrlen;
    int maxstrlen;
    Byte **othersp, **otherep;


#define       newstring(ptr)                    \
 { \
 t = *ptr; \
 curstrlen = 0; \
 while ( *t++ ) ++ curstrlen; \
 if ( curstrlen > maxstrlen ) maxstrlen = curstrlen; \
 t = *ptr; \
 }


    maxstrlen = 0;
    sp = start;
    ep = end;
    off = offset;
    m = mask;
    othersp = otherstart;
    otherep = otherend;

    while (1) {
        newstring(sp)
            while (((sp != ep) && ((curstrlen < off) || ((t[off] & m) == 0)))) {
            ++sp;
            ++othersp;
            newstring(sp)
        }
        if (sp == ep)
            break;

        newstring(ep);
        while (((sp != ep) && (curstrlen >= off) && ((t[off] & m) != 0))) {
            --ep;
            --otherep;
            newstring(ep)
        }
        if (sp == ep)
            break;

        t = *sp;
        *sp = *ep;
        *ep = t;

        t = *othersp;
        *othersp = *otherep;
        *otherep = t;
    }

    t = *sp;
    if ((curstrlen < off) || ((t[off] & m) == 0)) {
        if (ep != end) {
            ++ep;
            ++otherep;
        }
    }
    else {
        if (sp != start) {
            --sp;
            --othersp;
        }
    }

    m >>= 1;
    if (m == 0) {
        m = 0x80;
        if (++off >= maxstrlen)
            return;
    }

    if (sp != start)
        sortstrs_block(start, sp, off, m, otherstart, othersp);
    if (ep != end)
        sortstrs_block(ep, end, off, m, otherep, otherend);
}



 /*-----------------------------------------------------------------*/
 /*  Sort 1 block of data on 1 bit; check for out-of-order entries  */
 /*-----------------------------------------------------------------*/

static void
sortstrs_block_oo(Byte ** start, Byte ** end, int offset, Byte mask,
                  int *ostart, int *oend, Byte ** otherstart, Byte ** otherend)
{
    reg Byte **sp, **ep;
    reg int *osp, *oep;
    reg Byte m;
    reg int off;
    reg Byte *t;
    reg int u;
    reg int curstrlen;
    int maxstrlen;
    Byte **othersp, **otherep;


#define       newstring(ptr) \
 { \
 t = *ptr; \
 curstrlen = 0; \
 while ( *t++ ) ++ curstrlen; \
 if ( curstrlen > maxstrlen ) maxstrlen = curstrlen; \
 t = *ptr; \
 }


    maxstrlen = 0;
    sp = start;
    ep = end;
    osp = ostart;
    oep = oend;
    off = offset;
    m = mask;
    othersp = otherstart;
    otherep = otherend;

    while (1) {
        newstring(sp)
            while (((sp != ep) && ((curstrlen < off) || ((t[off] & m) == 0)))) {
            ++sp;
            ++osp;
            ++othersp;
            newstring(sp)
        }
        if (sp == ep)
            break;

        newstring(ep);
        while (((sp != ep) && (curstrlen >= off) && ((t[off] & m) != 0))) {
            --ep;
            --oep;
            --otherep;
            newstring(ep)
        }
        if (sp == ep)
            break;

        t = *sp;
        *sp = *ep;
        *ep = t;

        t = *othersp;
        *othersp = *otherep;
        *otherep = t;

        u = *osp;
        *osp = *oep;
        *oep = u;
    }

    t = *sp;
    if ((curstrlen < off) || ((t[off] & m) == 0)) {
        if (ep != end) {
            ++ep;
            ++oep;
            ++otherep;
        }
    }
    else {
        if (sp != start) {
            --sp;
            --osp;
            --othersp;
        }
    }

    m >>= 1;
    if (m == 0) {
        m = 0x80;
        if (++off >= maxstrlen) {       /*  Finished sorting block of strings:    *//*  Restore duplicates to original order  */
            reg Byte **cp;
            reg int *ocp;
            Byte **othercp;

            if (sp != start) {
                cp = start;
                ocp = ostart;
                othercp = otherstart;
                while (cp != sp) {
                    if (*ocp > *(ocp + 1)) {
                        t = *(cp + 1);
                        *(cp + 1) = *cp;
                        *cp = t;

                        t = *(othercp + 1);
                        *(othercp + 1) = *othercp;
                        *othercp = t;

                        u = *(ocp + 1);
                        *(ocp + 1) = *ocp;
                        *ocp = u;

                        if (cp != start) {
                            --cp;
                            --ocp;
                            --othercp;
                            continue;
                        }
                    }
                    ++cp;
                    ++ocp;
                    ++othercp;
                }
            }
            if (ep != end) {
                cp = ep;
                ocp = oep;
                othercp = otherep;
                while (cp != end) {
                    if (*ocp > *(ocp + 1)) {
                        t = *(cp + 1);
                        *(cp + 1) = *cp;
                        *cp = t;

                        t = *(othercp + 1);
                        *(othercp + 1) = *othercp;
                        *othercp = t;

                        u = *(ocp + 1);
                        *(ocp + 1) = *ocp;
                        *ocp = u;

                        if (cp != ep) {
                            --cp;
                            --ocp;
                            --othercp;
                            continue;
                        }
                    }
                    ++cp;
                    ++ocp;
                    ++othercp;
                }
            }
            return;
        }
    }

    if (sp != start)
        sortstrs_block_oo(start, sp, off, m, ostart, osp, otherstart, othersp);
    if (ep != end)
        sortstrs_block_oo(ep, end, off, m, oep, oend, otherep, otherend);
}


/*	Function Name: InitManual
 *	Description: Initializes this manual section.
 *	Arguments: l_manual - local copy of the manual structure.
 *                 label - the button label for this section.
 *	Returns: none.
 */

static void
InitManual(Manual * l_manual, char *label)
{
    bzero(l_manual, sizeof(Manual));    /* clear it. */
    l_manual->blabel = label;   /* set label. */
}

#if defined(DEBUG)

/*	Function Name: DumpManual
 *	Description: Debugging function that dumps the entire manual page
 *                   structure.
 *	Arguments: number - the number of sections.
 *	Returns: none.
 */

void
DumpManual(int number)
{
    register int i, j;

    for (i = 0; i < number; i++) {
        printf("label: %s\n", manual[i].blabel);
        for (j = 0; j < manual[i].nentries; j++)
            printf("%s\n", manual[i].entries[j]);
    }
}

#endif /* DEBUG */



#ifdef MANCONF

#if defined(MANCONFIGSTYLE_FreeBSD)

/*    Function Name: ReadManConfig
 *    Description: Reads man.conf file used by FreeBSD man
 *      Argument: manpath - char array to return path in.
 *    Returns: TRUE if read was successful.
 */

Bool
ReadManConfig(char manpath[])
{
    FILE *fp;
    char line[BUFSIZ];
    char *path;
    Bool firstpath = TRUE;

    if (!(fp = fopen(MANCONF, "r")))
        return (FALSE);

    while (fgets(line, sizeof(line), fp)) {
        path = strtok(line, " \t\n");
        if (!path || *path == '#')
            continue;
        if (strcmp(path, "MANPATH_MAP") == 0)
            path = strtok((char *) NULL, " \t\n");
        else if (strcmp(path, "MANDATORY_MANPATH") != 0 &&
                 strcmp(path, "OPTIONAL_MANPATH") != 0)
            return (FALSE);
        path = strtok((char *) NULL, " \t\n");
        if (!path || *path == '#')
            return FALSE;
        if (firstpath) {
            strcpy(manpath, path);
            firstpath = FALSE;
        }
        else if (!strstr(manpath, path)) {
            strcat(manpath, ":");
            strcat(manpath, path);
        }
    }
    fclose(fp);
    return (!firstpath);
}


#elif defined(MANCONFIGSTYLE_Linux)     /* not FreeBSD */

/*    Function Name: ReadManConfig
 *    Description: Reads man.conf file used by Linux man
 *      Argument: manpath - char array to return path in.
 *    Returns: TRUE if read was successful.
 */

Bool
ReadManConfig(char manpath[])
{
    FILE *fp;
    char line[BUFSIZ];
    char *path;
    Bool firstpath = TRUE;

    if (!(fp = fopen(MANCONF, "r")))
        return (FALSE);

    while (fgets(line, sizeof(line), fp)) {
        path = strtok(line, " \t\n");
        if (!path || *path == '#' || (strcmp(path, "MANPATH") != 0))
            continue;
        path = strtok((char *) NULL, " \t\n");
        if (!path || *path == '#')
            return FALSE;
        if (firstpath) {
            strcpy(manpath, path);
            firstpath = FALSE;
        }
        else {
            strcat(manpath, ":");
            strcat(manpath, path);
        }
    }
    fclose(fp);
    return (!firstpath);
}

#elif defined(MANCONFIGSTYLE_OpenBSD)   /* not FreeBSD or Linux */

/*    Function Name: ReadManConfig
 *    Description: Reads man.conf file used by Open/NetBSD
 *      Argument: manpath - char array to return path in.
 *    Returns: TRUE if read was successful.
 *
 *     This version expands the glob pattern that can be found
 *     in man.conf
 */
#include <glob.h>

Bool
ReadManConfig(char manpath[])
{
    FILE *fp;
    char line[BUFSIZ];
    char *path;
    Bool firstpath = TRUE;
    glob_t gs;
    int i;

    if (!(fp = fopen(MANCONF, "r")))
        return (FALSE);

    while (fgets(line, sizeof(line), fp)) {
        path = strtok(line, " \t\n");
        if (!path || *path == '#')
            continue;
        if (strcmp(path, "_default")) {
            /* for now */
            continue;
        }
        memset(&gs, 0, sizeof(glob_t));
        while ((path = strtok((char *) NULL, " \t\n"))) {
            if (glob(path, GLOB_BRACE, NULL, &gs) < 0) {
                fclose(fp);
                return FALSE;
            }
        }                       /* while */
        for (i = 0; i < gs.gl_pathc; i++) {

            if (firstpath) {
                strcpy(manpath, gs.gl_pathv[i]);
                firstpath = FALSE;
            }
            else {
                strcat(manpath, ":");
                strcat(manpath, gs.gl_pathv[i]);
            }
        }                       /* for */
        globfree(&gs);
    }
    fclose(fp);
    return (!firstpath);
}

#elif defined(MANCONFIGSTYLE_BSD)       /* not FreeBSD, Linux, or OpenBSD */

/*    Function Name: ReadManConfig
 *    Description: Reads man.conf file used by BSD 4.4
 *      Argument: manpath - char array to return path in.
 *    Returns: TRUE if read was successful.
 */

Bool
ReadManConfig(char manpath[])
{
    FILE *fp;
    char line[BUFSIZ];
    char *path;
    Bool firstpath = TRUE;

    if (!(fp = fopen(MANCONF, "r")))
        return (FALSE);

    while (fgets(line, sizeof(line), fp)) {
        path = strtok(line, " \t\n");
        if (!path || *path == '#' || strcmp(path, "_default"))
            continue;
        while ((path = strtok((char *) NULL, " \t\n"))) {
            if (firstpath) {
                strcpy(manpath, path);
                firstpath = FALSE;
            }
            else {
                strcat(manpath, ":");
                strcat(manpath, path);
            }
        }
    }
    fclose(fp);
    return (!firstpath);
}

#else /* not BSD */

#error "MANCONF defined (in vendor.h) for unknown operating system."

#endif /* MANCONFIGSTYLE == FreeBSD ... BSD */

#endif /* MANCONF */
@


1.3
log
@Update to xman 1.1.3
@
text
@d293 6
a298 1
            string[strlen(string) - 1] = '\0';  /* Strip off the CR. */
@


1.2
log
@Update to xman 1.1.0
@
text
@a0 2
/* $XConsortium: man.c,v 1.30 94/04/17 20:43:56 rws Exp $ */
/* $XdotOrg: $ */
a29 1
/* $XFree86: xc/programs/xman/man.c,v 1.8 2003/04/09 20:31:31 herrb Exp $ */
d33 1
a33 1
#include "vendor.h"		/* vendor-specific defines and data */
a34 1
#ifndef X_NOT_POSIX
a35 14
#else
#ifdef SYSV
#include <dirent.h>
#else
#ifdef USG
#include <dirent.h>
#else
#include <sys/dir.h>
#ifndef dirent
#define dirent direct
#endif
#endif
#endif
#endif
d38 1
a38 1
static char error_buf[BUFSIZ];		/* The buffer for error messages. */
d41 5
a45 5
static void AddToCurrentSection(Manual * local_manual, char * path);
static void InitManual(Manual * l_manual, char * label);
static void ReadCurrentSection(Manual * local_manual, char * path);
static void ReadMandescFile(SectionList ** section_list, char * path);
static void SortAndRemove(Manual *man, int number);
d53 1
a53 1
 
d57 6
a62 5
 
static void sortstrs (Byte *data[], int size, Byte *otherdata[]);
static void sortstrs_block (Byte **, Byte **, int, Byte, Byte **, Byte **);
static void sortstrs_block_oo (Byte **, Byte **, int, Byte, int *, int *, Byte **, Byte **);
 
d65 1
a65 1
 *	Arguments: none. 
d72 5
a76 3
  SectionList *list = NULL;
  char *ptr, *lang = NULL, manpath[BUFSIZ], buf[BUFSIZ], *path, *current_label;
  int sect, num_alloced;
d78 1
a78 1
/* 
d83 9
a91 9
  /* if MANPATH variable ends in ':'. So, should extend it's value to the
   * default search path.
   */

  *manpath = '\0';
  if ((ptr = getenv("MANPATH")) != NULL)
    strcpy(manpath, ptr);
  if (ptr == NULL || streq(ptr , "") || ptr[strlen(ptr) - 1] == ':') {
    lang = getenv("LANG");
d93 1
a93 1
    if (!ReadManConfig(manpath + strlen(manpath)))
d95 1
a95 1
    {
d97 2
a98 2
      if (manpath[strlen(manpath) - 1] != ':')
	strcat(manpath, ":");
d100 1
a100 1
      strcat(manpath, SYSMANPATH);
d102 2
a103 2
      strcat(manpath, ":");
      strcat(manpath, LOCALMANPATH);
d105 1
a106 1
  }
d113 11
a123 2
  for ( path = manpath ; (ptr = index(path , ':')) != NULL ; path = ++ptr) { 
    *ptr = '\0';
d125 5
a129 5
      strcpy(buf, path);
      strcat(buf, "/");
      strncat(buf, lang, sizeof(buf) - strlen(path) + 1);
      buf[sizeof(buf) - strlen(path) + 1] = '\0';
      ReadMandescFile(&list, buf);
a131 18
  }
  if (lang != NULL) {
    strcpy(buf, path);
    strcat(buf, "/");
    strncat(buf, lang, sizeof(buf) - strlen(path) + 1);
    buf[sizeof(buf) - strlen(path) + 1] = '\0';
    ReadMandescFile(&list, buf);
  }
  ReadMandescFile(&list, path);

  SortList(&list);
  
  sect = 0;
  num_alloced = SECTALLOC;
  manual = (Manual *) XtMalloc( sizeof(Manual) * num_alloced );
  InitManual( manual, list->label );
  manual[sect].flags = list->flags;
  current_label = NULL;
d133 42
a174 2
  while ( list != NULL ) {
    SectionList * old_list;
d176 1
a176 31
    if ( current_label == NULL || streq(list->label, current_label) )
      AddToCurrentSection( manual + sect, list->directory);
    else {
      if (manual[sect].nentries == 0) {	/* empty section, re-use it. */
	XtFree(manual[sect].blabel);
	manual[sect].blabel = list->label;
	manual[sect].flags = list->flags;
      }
      else {
	if ( ++sect >= num_alloced ) {
	  num_alloced += SECTALLOC;
	  manual = (Manual *) XtRealloc ( (char *) manual,
				        (sizeof(Manual) * num_alloced));
	  if (manual == NULL) 
	    PrintError("Could not allocate memory for manual sections.");
	}
	InitManual( manual + sect, list->label );
	manual[sect].flags = list->flags;
      }
      AddToCurrentSection( manual + sect, list->directory);
    }
    /* Save label to see if it matches next entry. */
    current_label = list->label; 
    old_list = list;
    list = list->next;
    XtFree((char *) old_list);		/* free what you allocate. */
  }
  if (manual[sect].nentries != 0)
    sect++;			/* don't forget that last section. */
  
  SortAndRemove(manual, sect);
d178 2
a179 2
#ifdef notdef			/* dump info. */
  DumpManual(sect);
d181 1
a181 1
  
d186 5
a190 5
  if (sect == 0)
    PrintError("No manual pages found.");
  manual = (Manual *) XtRealloc( (char *) manual, (sizeof(Manual) * sect));
  if (manual == NULL) 
    PrintError("Could not allocate memory for manual sections.");
d192 2
a193 2
  return(sect);		/* return the number of man sections. */
}    
d208 9
a216 9
  SectionList * local;
  SectionList *head, *last, *inner, *old;
  
  if (*list == NULL)
    PrintError("No manual sections to read, exiting.");

/* 
 * First step 
 * 
d220 16
a235 16
  last = NULL;			/* keep Saber happy. */
  for ( local = *list ; local->next != NULL ; local = local->next) {
    if ( local->flags ) {
      if ( local == *list )	/* top element is already standard. */
	break;
      head = local;

      /* Find end of standard block */
      for (old = NULL ; (local->next != NULL) && (local->flags) 
	   ; old = local, local = local->next); 

      if (old != NULL) {
          last->next = old->next; /* Move the block. */
          old->next = *list;
          *list = head;
      }
d237 3
a239 1
      break;			/* First step accomplished. */
a240 2
    last = local;
  }
d250 20
a269 19
  for (local = *list; local->next != NULL; local = local->next) {
    head = local;
    old = inner = local->next;
    while (inner != NULL) {
      if (streq(inner->label, local->label)) {
	if (old != inner) {
	  old->next = inner->next;
	  last = inner->next;
	  inner->next = head->next;
	  head->next = inner;
	  head = inner;
	  old = inner = last;
	  continue;
	}
	else
	  head = inner;
      }
      old = inner;
      inner = inner->next;
d271 1
a271 2
  }
}	
d274 1
a274 1
 *	Description: Reads the mandesc file, and adds more sections as 
d280 1
a280 1
  
d282 1
a282 1
ReadMandescFile(SectionList ** section_list, char * path)
d284 45
a328 36
  char mandesc_file[BUFSIZ];	/* full path to the mandesc file. */
  FILE * descfile;
  char string[BUFSIZ], local_file[BUFSIZ];
  Boolean use_defaults = TRUE;
  char *cp;

  snprintf(mandesc_file, sizeof(mandesc_file), "%s/%s", path, MANDESC);
  if ( (descfile = fopen(mandesc_file, "r")) != NULL) {
    while ( fgets(string, BUFSIZ, descfile) != NULL) {
      string[strlen(string)-1] = '\0';        /* Strip off the CR. */

      if ( streq(string, NO_SECTION_DEFAULTS) ) {
	use_defaults = FALSE;
	continue;
      }

      if ((cp = index(string,'\t')) != NULL) {
	char *s;
	*cp++ = '\0';
	strcpy(local_file, MAN);
	strcat(local_file, string);
	if ((s = index(cp,'\t')) != NULL) {
	  *s++ = '\0';
	  if (streq(s, SUFFIX))
	    AddNewSection(section_list, path, local_file, cp, MSUFFIX);
	  else if (streq(s, FOLD))
	    AddNewSection(section_list, path, local_file, cp, MFOLD);
	  else if (streq(s, FOLDSUFFIX))
	    AddNewSection(section_list, path, local_file, cp, MFOLDSUFFIX);
	  else
	    AddNewSection(section_list, path, local_file, cp, MNULL);
        } else
	    AddNewSection(section_list, path, local_file, cp, MNULL);
      } else {
	snprintf(local_file, sizeof(local_file), "%s%c", MAN, string[0]);
	AddNewSection(section_list, path, local_file, (string + 1), FALSE );
d330 4
a333 2
	snprintf(local_file, sizeof(local_file), "%s%c", SEARCHOTHER, string[0]);
	AddNewSection(section_list, path, local_file, (string + 1), FALSE);
d335 4
a338 1
      }
d340 2
a341 5

    fclose(descfile);
  }
  if (use_defaults)
    AddStandardSections(section_list, path);
d356 2
a357 4
AddNewSection(
SectionList **list,
char * path, char * file, char * label, 
int flags)
d359 2
a360 2
  SectionList * local_list, * end;
  char full_path[BUFSIZ];
d364 1
a364 1
  local_list = (SectionList *) XtMalloc(sizeof(SectionList));
d366 13
a378 13
  if (*list != NULL) {
    for ( end = *list ; end->next != NULL ; end = end->next );
    end->next = local_list;
  }
  else 
    *list = local_list;

  local_list->next = NULL;
  local_list->label = StrAlloc(label);
  snprintf(full_path, sizeof(full_path), "%s/%s", path, file);
  local_list->directory = StrAlloc(full_path);
  local_list->flags = flags;
}  
d389 1
a389 1
AddToCurrentSection(Manual * local_manual, char * path)
d391 1
a391 1
  char temp_path[BUFSIZ];
d394 2
a395 2
  snprintf(temp_path, sizeof(temp_path), "%s/%s", path, MACHINE);
  ReadCurrentSection(local_manual, temp_path);
d397 4
a400 3
  ReadCurrentSection(local_manual, path);
  snprintf(temp_path, sizeof(temp_path), "%s.%s", path, COMPRESSION_EXTENSION);
  ReadCurrentSection(local_manual, temp_path);
d404 1
a404 1
 *	Description: Actually does the work of adding entries to the 
d413 1
a413 1
ReadCurrentSection(Manual * local_manual, char * path)
d415 2
a416 1
  DIR * dir;
d418 3
a420 1
  register struct dirent *dp;
d422 1
a422 5
  register int nentries;
  register int nalloc;
  char full_name[BUFSIZ], *ptr;

  if((dir = opendir(path)) == NULL) {
d424 2
a425 2
    snprintf(error_buf, sizeof(error_buf), "Can't open directory %s", path);
    PopupWarning(NULL, error_buf);
d427 2
a428 2
    return;
  }
d434 1
a434 1
  if ( (ptr = rindex(path, '.')) != NULL) {
d436 1
a436 1
    if (streq(ptr + 1, COMPRESSION_EXTENSION)) 
d438 1
a438 1
    if (strpbrk(ptr + 1, COMPRESSION_EXTENSIONS) != NULL)
d440 1
a440 1
      *ptr = '\0';
d442 2
a443 2
    else if (streq(ptr + 1, GZIP_EXTENSION))
      *ptr = '\0';
d446 2
a447 2
    else if (streq(ptr + 1, BZIP2_EXTENSION))
      *ptr = '\0';
d450 2
a451 2
    else if (streq(ptr + 1, LZMA_EXTENSION))
      *ptr = '\0';
a452 20
  }
  
  nentries = local_manual->nentries;
  nalloc = local_manual->nalloc;

  while( (dp = readdir(dir)) != NULL ) {
    char * name = dp->d_name;
    if (name[0] == '.')
      continue;
#ifndef CRAY
    if (index(name, '.') == NULL)
      continue;
#endif
    if( nentries >= nalloc ) {
      nalloc += ENTRYALLOC;
      local_manual->entries =(char **) XtRealloc((char *)local_manual->entries,
						 nalloc * sizeof(char *));
      local_manual->entries_less_paths =
	(char **) XtRealloc((char *)local_manual->entries_less_paths,
			    nalloc * sizeof(char *));
d455 21
a475 1
    snprintf(full_name, sizeof(full_name), "%s/%s", path, name);
d480 1
a480 1
    if ( (ptr = rindex(full_name, '.')) != NULL) {
d482 1
a482 1
      if (streq(ptr + 1, COMPRESSION_EXTENSION)) 
d484 1
a484 1
      if (strpbrk(ptr + 1, COMPRESSION_EXTENSIONS) != NULL)
d486 1
a486 1
	*ptr = '\0';
d488 2
a489 2
      else if (streq(ptr + 1, GZIP_EXTENSION))
	*ptr = '\0';
d492 2
a493 2
      else if (streq(ptr + 1, BZIP2_EXTENSION))
	*ptr = '\0';
d496 2
a497 2
      else if (streq(ptr + 1, LZMA_EXTENSION))
	*ptr = '\0';
d500 4
a503 4
      /* skip files with specified extension - they're not real man pages */
      else if (streq(ptr + 1, IGNORE_EXTENSION)) {
	continue;
      }
d505 7
a512 10
    local_manual->entries[nentries] = StrAlloc(full_name);
    local_manual->entries_less_paths[nentries] = 
      rindex(local_manual->entries[nentries], '/');
    if ( local_manual->entries_less_paths[nentries] == NULL )
      PrintError("Internal error while cataloging manual pages.");
    ++ nentries;
  }
  
  local_manual->nentries = nentries;
  local_manual->nalloc = nalloc;
d514 4
a517 1
  closedir(dir);
d529 1
a529 1
SortAndRemove(Manual *man, int number)
d531 6
a536 6
  int i;
  char *l1, *l2, **s1;
  
  for ( i = 0; i < number; man++, i++) { /* sort each section */
    register int i2 = 0;      
    
d538 1
a538 1
    printf("sorting section %d - %s\n", i, man->blabel);
d541 17
a557 13
    s1 = (char **)malloc(man->nentries * sizeof(char *));
    
    /* temporarily remove suffixes of entries, preventing them from */
    /* being used in alpabetic comparison ie sccs-delta.1 vs sccs.1 */
    for (i2=0; i2<man->nentries; i2++)
      if ((s1[i2] = rindex(man->entries_less_paths[i2], '.')) != NULL)
	*s1[i2] = '\0';  

    sortstrs ( (Byte **)man->entries_less_paths, man->nentries, (Byte **)man->entries );

    /* put back suffixes */
    for (i2=0; i2<man->nentries; i2++) 
      if (s1[i2] != NULL) *s1[i2] = '.';      
a558 2
    free(s1); 
    
d560 1
a560 1
    printf("removing from section %d.\n", i);
d562 29
a590 25
    
    {
      register int   j, k, nent, nentm1;
      int     j2;
      nent   = man -> nentries;
      nentm1 = nent - 1;
      j = 0;
      l2 = man->entries_less_paths[j++];
      if ( l2 == NULL )
        PrintError("Internal error while removing duplicate manual pages.");
      while ( j < nentm1 )
	{
	  l1 = l2;
	  l2 = man->entries_less_paths[j++];
	  if ( l2 == NULL )
	    PrintError("Internal error while removing duplicate manual pages."
		       );
	  if ( streq(l1,l2) )
	    {
	      j2 = j-1;
	      k  = j2;
	      while ( j < nent )
                {
		  man -> entries_less_paths[k] = man -> entries_less_paths[j];
                man -> entries[k++] = man -> entries[j++];
d592 2
a593 6
	      j = j2;
	      -- man -> nentries;
	      -- nent;
	      -- nentm1;
	    }
	}
a594 1
  }
d598 5
a602 5
       *******  Replacement for qsort to keep
       *******  identical entries in order
 
       A somewhat ugly hack of something that was once simpler...
 */
d604 13
a616 13
       Sort an array of pointers to strings, keeping it
       in ascending order by (1) string comparison and
       (2) original entry order in the pointer array.
 
       This is a modified radix exchange algorithm.
 
       In case there's insufficient memory for a temporary copy
       of the pointer array, the original order of identical strings
       isn't preserved.
 */
 
static void 
sortstrs (Byte *data[], int size, Byte *otherdata[])
d618 20
a637 22
       Byte   **sp, **ep;
       Byte   **othersp, **otherep;
       int     *origorder;
 
 origorder = (int *) calloc (size, sizeof(int));
 if ( origorder )
    {
    reg int     i;
 
    for ( i=0; i < size; ++i )
       origorder[i] = i;
    }
 
 sp = data;
 ep = &data[size-1];
 othersp = otherdata;
 otherep = &otherdata[size-1];
 if ( origorder )
    {
    sortstrs_block_oo ( sp, ep, 0, 0x80, origorder, &origorder[size-1],
       othersp, otherep );
    free (origorder);
d639 2
a640 2
 else
    sortstrs_block ( sp, ep, 0, 0x80, othersp, otherep );
a641 1
 
d643 2
a644 1
 
d648 1
a648 1
 
d650 2
a651 8
sortstrs_block (  
       Byte   **start,
       Byte   **end,
       int      offset,
       Byte     mask,
       Byte   **otherstart,
       Byte   **otherend)
 
d653 10
a662 10
 reg   Byte   **sp, **ep;
 reg   Byte     m;
 reg   int      off;
 reg   Byte    *t;
 reg   int      curstrlen;
       int      maxstrlen;
       Byte   **othersp, **otherep;
 
 
#define       newstring(ptr) \
d670 63
a732 72
 
 
 maxstrlen = 0;
 sp  = start;
 ep  = end;
 off = offset;
 m   = mask;
 othersp = otherstart;
 otherep = otherend;
 
 while (1)
     {
     newstring(sp)
     while (((sp != ep) && ((curstrlen < off) || ((t[off] & m) == 0))))
       {
       ++ sp;
       ++ othersp;
       newstring(sp)
       }
     if ( sp == ep )
       break;
 
     newstring(ep);
     while (((sp != ep) && (curstrlen >= off) && ((t[off] & m) != 0)))
       {
       -- ep;
       -- otherep;
       newstring(ep)
       }
     if ( sp == ep )
       break;
 
     t = *sp;
     *sp = *ep;
     *ep = t;
 
     t      = *othersp;
     *othersp = *otherep;
     *otherep = t;
     }
 
 t = *sp;
 if ((curstrlen < off) || ((t[off] & m) == 0))
    {
    if ( ep != end )
       {
       ++ ep;
       ++ otherep;
       }
    }
 else
    {
    if ( sp != start )
       {
       -- sp;
       -- othersp;
       }
    }
 
 m >>= 1;
 if ( m == 0 )
    {
    m = 0x80;
    if ( ++off >= maxstrlen )
       return;
    }
 
 
 if ( sp != start )
    sortstrs_block ( start, sp, off, m, otherstart, othersp );
 if ( ep != end )
    sortstrs_block ( ep, end, off, m, otherep, otherend );
a733 1
 
d735 2
a736 1
 
d740 1
a740 1
 
d742 2
a743 10
 sortstrs_block_oo (
       Byte   **start,
       Byte   **end,
       int      offset,
       Byte     mask,
       int     *ostart,
       int     *oend,
       Byte   **otherstart,
       Byte   **otherend)
 
d745 11
a755 11
 reg   Byte   **sp, **ep;
 reg   int     *osp, *oep;
 reg   Byte     m;
 reg   int      off;
 reg   Byte    *t;
 reg   int      u;
 reg   int      curstrlen;
       int      maxstrlen;
       Byte   **othersp, **otherep;
 
 
d764 131
a894 114
 
 
 maxstrlen = 0;
 sp  = start;
 ep  = end;
 osp = ostart;
 oep = oend;
 off = offset;
 m   = mask;
 othersp = otherstart;
 otherep = otherend;
 
 while (1)
     {
     newstring(sp)
     while (((sp != ep) && ((curstrlen < off) || ((t[off] & m) == 0))))
       {
       ++ sp;
       ++ osp;
       ++ othersp;
       newstring(sp)
       }
     if ( sp == ep )
       break;
 
     newstring(ep);
     while (((sp != ep) && (curstrlen >= off) && ((t[off] & m) != 0)))
       {
       -- ep;
       -- oep;
       -- otherep;
       newstring(ep)
       }
     if ( sp == ep )
       break;
 
     t   = *sp;
     *sp = *ep;
     *ep = t;
 
     t      = *othersp;
     *othersp = *otherep;
     *otherep = t;
 
     u    = *osp;
     *osp = *oep;
     *oep = u;
     }
 
 t = *sp;
 if ((curstrlen < off) || ((t[off] & m) == 0))
    {
    if ( ep != end )
       {
       ++ ep;
       ++ oep;
       ++ otherep;
       }
    }
 else
    {
    if ( sp != start )
       {
       -- sp;
       -- osp;
       -- othersp;
       }
    }
 
 m >>= 1;
 if ( m == 0 )
    {
    m = 0x80;
    if ( ++off >= maxstrlen )  /*  Finished sorting block of strings:    */
       {                               /*  Restore duplicates to
riginal order  */
       reg Byte **cp;
       reg int *ocp;
         Byte **othercp;
 
 
       if ( sp != start )
        {
        cp  = start;
        ocp = ostart;
        othercp = otherstart;
        while ( cp != sp )
           {
           if ( *ocp > *(ocp+1) )
               {
               t       = *(cp+1);
               *(cp+1) = *cp;
               *cp     = t;
 
               t               = *(othercp+1);
               *(othercp+1)    = *othercp;
               *othercp        = t;
 
               u        = *(ocp+1);
               *(ocp+1) = *ocp;
               *ocp     = u;
 
               if ( cp != start )
                  {
                  -- cp;
                  -- ocp;
                  -- othercp;
                  continue;
                  }
               }
           ++ cp;
           ++ ocp;
           ++ othercp;
           }
d896 6
a901 43
       if ( ep != end )
        {
        cp  = ep;
        ocp = oep;
        othercp = otherep;
        while ( cp != end )
           {
           if ( *ocp > *(ocp+1) )
               {
               t       = *(cp+1);
               *(cp+1) = *cp;
               *cp     = t;
 
               t               = *(othercp+1);
               *(othercp+1)    = *othercp;
               *othercp        = t;
 
               u        = *(ocp+1);
               *(ocp+1) = *ocp;
               *ocp     = u;
 
               if ( cp != ep )
                  {
                  -- cp;
                  -- ocp;
                  -- othercp;
                  continue;
                  }
               }
           ++ cp;
           ++ ocp;
           ++ othercp;
           }
        }
       return;
       }
    }
 
 
 if ( sp != start )
    sortstrs_block_oo ( start, sp, off, m, ostart, osp, otherstart, othersp );
 if ( ep != end )
    sortstrs_block_oo ( ep, end, off, m, oep, oend, otherep, otherend );
d913 1
a913 1
InitManual(Manual * l_manual, char * label)
d915 2
a916 2
  bzero( l_manual, sizeof(Manual) );	        /* clear it. */
  l_manual->blabel = label;	                /* set label. */
d918 1
a918 1
  
d931 7
a937 7
  register int i,j;
  
  for ( i = 0; i < number; i++) {
    printf("label: %s\n", manual[i].blabel);
    for (j = 0; j < manual[i].nentries; j++) 
      printf("%s\n", manual[i].entries[j]);
  }
d957 31
a987 31
  FILE        *fp;
  char        line[BUFSIZ];
  char        *path;
  Bool  firstpath = TRUE;

  if (!(fp = fopen(MANCONF, "r")))
    return(FALSE);

  while (fgets(line, sizeof(line), fp)) {
    path = strtok(line, " \t\n");
    if (!path || *path == '#')
      continue;
    if (strcmp(path, "MANPATH_MAP") == 0)
      path = strtok((char *)NULL, " \t\n");
    else if (strcmp(path, "MANDATORY_MANPATH") != 0 &&
	     strcmp(path, "OPTIONAL_MANPATH") != 0)
      return(FALSE);
    path = strtok((char *)NULL, " \t\n");
    if (!path || *path == '#')
      return FALSE;
    if (firstpath) {
      strcpy(manpath, path);
      firstpath = FALSE;
    }
    else if (!strstr(manpath,path)) {
      strcat(manpath, ":");
      strcat(manpath, path);
    }
  }
  fclose(fp);
  return(!firstpath);
d991 1
a991 1
#elif defined(MANCONFIGSTYLE_Linux) /* not FreeBSD */
a998 1

d1002 23
a1024 18
  FILE        *fp;
  char        line[BUFSIZ];
  char        *path;
  Bool  firstpath = TRUE;

  if (!(fp = fopen(MANCONF, "r")))
    return(FALSE);

  while (fgets(line, sizeof(line), fp)) {
    path = strtok(line, " \t\n");
    if (!path || *path == '#' || (strcmp(path, "MANPATH") != 0))
      continue;
    path = strtok((char *)NULL, " \t\n");
    if (!path || *path == '#')
      return FALSE;
    if (firstpath) {
      strcpy(manpath, path);
      firstpath = FALSE;
d1026 2
a1027 7
    else {
      strcat(manpath, ":");
      strcat(manpath, path);
    }
  }
  fclose(fp);
  return(!firstpath);
d1030 1
a1030 1
#elif defined(MANCONFIGSTYLE_OpenBSD) /* not FreeBSD or Linux */
d1037 1
a1037 1
 *     This version expands the glob pattern that can be found 
d1045 7
a1051 7
    FILE        *fp;
    char        line[BUFSIZ];
    char        *path;
    Bool        firstpath = TRUE;
    glob_t      gs;
    int         i;
    
d1053 2
a1054 2
	return(FALSE);
    
d1056 26
a1081 26
	path = strtok(line, " \t\n");
	if (!path || *path == '#')
	    continue;
	if (strcmp(path, "_default")) {
	    /* for now */
	    continue;
	}
	memset(&gs, 0, sizeof(glob_t));
	while ((path = strtok((char *)NULL, " \t\n"))) {
	    if (glob(path, GLOB_BRACE, NULL, &gs) < 0) {
		fclose(fp);
		return FALSE;
	    }
	} /* while */
	for (i = 0; i < gs.gl_pathc; i++) {
	    
	    if (firstpath) {
		strcpy(manpath, gs.gl_pathv[i]);
		firstpath = FALSE;
	    }
	    else {
		strcat(manpath, ":");
		strcat(manpath, gs.gl_pathv[i]);
	    }
	} /* for */
	globfree(&gs);
d1084 1
a1084 1
    return(!firstpath);
d1087 1
a1087 1
#elif defined(MANCONFIGSTYLE_BSD) /* not FreeBSD, Linux, or OpenBSD */
d1096 6
a1101 1
ReadManConfig(manpath)
d1103 2
a1104 1
char  manpath[];
d1106 17
a1122 26
{
  FILE        *fp;
  char        line[BUFSIZ];
  char        *path;
  Bool  firstpath = TRUE;

  if (!(fp = fopen(MANCONF, "r")))
    return(FALSE);

  while (fgets(line, sizeof(line), fp)) {
    path = strtok(line, " \t\n");
    if (!path || *path == '#' || strcmp(path, "_default"))
      continue;
    while ((path = strtok((char *)NULL, " \t\n"))) {
      if (firstpath) {
        strcpy(manpath, path);
        firstpath = FALSE;
      }
      else {
        strcat(manpath, ":");
        strcat(manpath, path);
      }
    }
  }
  fclose(fp);
  return(!firstpath);
@


1.1
log
@Initial revision
@
text
@d2 1
a2 1
/* $XdotOrg: app/xman/man.c,v 1.4 2005/11/08 06:33:33 jkj Exp $ */
d90 1
a90 1
  char *ptr, *lang = 0, manpath[BUFSIZ], buf[BUFSIZ], *path, *current_label;
d130 1
a130 1
    if (lang != 0) {
d139 1
a139 1
  if (lang != 0) {
d242 1
a242 1
      for (old = 0 ; (local->next != NULL) && (local->flags) 
d245 1
a245 1
      if (old != 0) {
d450 8
d494 8
@


1.1.1.1
log
@Importing from X.Org 7.2RC2
@
text
@@


1.1.1.2
log
@xman 1.0.3
@
text
@d2 1
a2 1
/* $XdotOrg: $ */
@

