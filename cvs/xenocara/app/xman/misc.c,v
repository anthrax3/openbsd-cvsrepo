head	1.5;
access;
symbols
	OPENBSD_6_0:1.5.0.6
	OPENBSD_6_0_BASE:1.5
	OPENBSD_5_9:1.5.0.4
	OPENBSD_5_9_BASE:1.5
	OPENBSD_5_8:1.5.0.2
	OPENBSD_5_8_BASE:1.5
	OPENBSD_5_7:1.4.0.6
	OPENBSD_5_7_BASE:1.4
	OPENBSD_5_6:1.4.0.4
	OPENBSD_5_6_BASE:1.4
	OPENBSD_5_5:1.4.0.2
	OPENBSD_5_5_BASE:1.4
	OPENBSD_5_4:1.3.0.8
	OPENBSD_5_4_BASE:1.3
	OPENBSD_5_3:1.3.0.6
	OPENBSD_5_3_BASE:1.3
	OPENBSD_5_2:1.3.0.4
	OPENBSD_5_2_BASE:1.3
	OPENBSD_5_1_BASE:1.3
	OPENBSD_5_1:1.3.0.2
	OPENBSD_5_0:1.2.0.8
	OPENBSD_5_0_BASE:1.2
	OPENBSD_4_9:1.2.0.4
	OPENBSD_4_9_BASE:1.2
	OPENBSD_4_8:1.2.0.6
	OPENBSD_4_8_BASE:1.2
	OPENBSD_4_7:1.2.0.2
	OPENBSD_4_7_BASE:1.2
	OPENBSD_4_6:1.1.1.2.0.8
	OPENBSD_4_6_BASE:1.1.1.2
	OPENBSD_4_5:1.1.1.2.0.6
	OPENBSD_4_5_BASE:1.1.1.2
	OPENBSD_4_4:1.1.1.2.0.4
	OPENBSD_4_4_BASE:1.1.1.2
	OPENBSD_4_3_BASE:1.1.1.2
	OPENBSD_4_3:1.1.1.2.0.2
	v1_0_3:1.1.1.2
	OPENBSD_4_2:1.1.1.1.0.2
	OPENBSD_4_2_BASE:1.1.1.1
	v1_0_2:1.1.1.1
	xorg:1.1.1;
locks; strict;
comment	@ * @;


1.5
date	2015.05.10.10.21.18;	author matthieu;	state Exp;
branches;
next	1.4;
commitid	qbUFIZT2jFahjpQz;

1.4
date	2013.09.28.16.23.01;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2011.08.28.13.15.52;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2009.10.24.15.00.51;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.25.20.50.30;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.11.25.20.50.30;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2007.09.16.16.51.57;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.5
log
@Update to xman 1.1.4
@
text
@/*

Copyright (c) 1987, 1988  X Consortium

Permission is hereby granted, free of charge, to any person obtaining
a copy of this software and associated documentation files (the
"Software"), to deal in the Software without restriction, including
without limitation the rights to use, copy, modify, merge, publish,
distribute, sublicense, and/or sell copies of the Software, and to
permit persons to whom the Software is furnished to do so, subject to
the following conditions:

The above copyright notice and this permission notice shall be included
in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
IN NO EVENT SHALL THE X CONSORTIUM BE LIABLE FOR ANY CLAIM, DAMAGES OR
OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
OTHER DEALINGS IN THE SOFTWARE.

Except as contained in this notice, the name of the X Consortium shall
not be used in advertising or otherwise to promote the sale, use or
other dealings in this Software without prior written authorization
from the X Consortium.

*/

/*
 * xman - X window system manual page display program.
 * Author:    Chris D. Peterson, MIT Project Athena
 * Created:   October 27, 1987
 */

#ifdef HAVE_CONFIG_H
# include "config.h"
#endif

#include "globals.h"
#include "vendor.h"
#include <X11/Xos.h>            /* sys/types.h and unistd.h included in here */
#include <sys/stat.h>
#include <errno.h>
#include <X11/Xaw/Dialog.h>
#include <X11/Shell.h>

static FILE *Uncompress(ManpageGlobals * man_globals, const char *filename);

static Boolean UncompressNamed(ManpageGlobals * man_globals,
                               const char *filename, char *output,
                               FILE ** output_file);
static Boolean UncompressUnformatted(ManpageGlobals * man_globals,
                                     const char *entry, char *filename,
                                     FILE ** file);

#ifdef HANDLE_ROFFSEQ
static Boolean ConstructCommand(char *cmdbuf, const char *path,
                                const char *filename, const char *tempfile);
#endif

#if defined(ISC) || defined(__SCO__) || defined(__UNIXWARE__)
static char *uncompress_format = NULL;

static char *uncompress_formats[] = {
    UNCOMPRESS_FORMAT_1,
    UNCOMPRESS_FORMAT_2,
    UNCOMPRESS_FORMAT_3
};
#endif

/*	Function Name: PopupWarning
 *	Description: This function pops up a warning message.
 *	Arguments: string - the specific warning string.
 *	Returns: none
 */

static Widget warnShell, warnDialog;

static void
PopdownWarning(Widget w, XtPointer client, XtPointer call)
{
    XtPopdown((Widget) client);
}

void
PopupWarning(ManpageGlobals * man_globals, const char *string)
{
    int n;
    Arg wargs[3];
    Dimension topX, topY;
    char buffer[BUFSIZ];
    Boolean hasPosition;

    snprintf(buffer, sizeof(buffer), "Xman Warning: %s", string);
    hasPosition = FALSE;
    if (top) {
        n = 0;
        XtSetArg(wargs[n], XtNx, &topX);
        n++;
        XtSetArg(wargs[n], XtNy, &topY);
        n++;
        XtGetValues(top, wargs, n);
        hasPosition = TRUE;
    }

    if (man_globals != NULL)
        ChangeLabel(man_globals->label, buffer);
    if (man_globals->label == NULL) {
        n = 0;
        if (hasPosition) {
            XtSetArg(wargs[n], XtNx, topX);
            n++;
            XtSetArg(wargs[n], XtNy, topY);
            n++;
        }
        XtSetArg(wargs[n], XtNtransientFor, top);
        n++;
        warnShell = XtCreatePopupShell("warnShell", transientShellWidgetClass,
                                       initial_widget, wargs, n);
        XtSetArg(wargs[0], XtNlabel, buffer);
        warnDialog = XtCreateManagedWidget("warnDialog", dialogWidgetClass,
                                           warnShell, wargs, 1);
        XawDialogAddButton(warnDialog, "dismiss", PopdownWarning,
                           (XtPointer) warnShell);
        XtRealizeWidget(warnShell);
        Popup(warnShell, XtGrabNone);
    }
}

/*	Function Name: PrintError
 *	Description: This Function prints an error message and exits.
 *	Arguments: string - the specific message.
 *	Returns: none. - exits though.
 */

void
PrintError(const char *string)
{
    fprintf(stderr, "Xman Error: %s\n", string);
    exit(EXIT_FAILURE);
}

/*	Function Name: OpenFile
 *	Description: Assigns a file to the manpage.
 *	Arguments: man_globals - global structure.
 *                 file        - the file pointer.
 *	Returns: none
 */

void
OpenFile(ManpageGlobals * man_globals, FILE * file)
{
    Arg arglist[1];
    Cardinal num_args = 0;

    if (man_globals->curr_file) {
#if 0                           /* Ownership rules need to be fixed first */
        fclose(man_globals->curr_file);
#endif
    }
    man_globals->curr_file = file;

    XtSetArg(arglist[num_args], XtNfile, man_globals->curr_file);
    num_args++;
    XtSetValues(man_globals->manpagewidgets.manpage, arglist, num_args);
}


/*	Function Name: FindManualFile
 *	Description: Opens the manual page file given the entry information.
 *	Arguments: man_globals - the globals info for this manpage.
 *                 section_num - section number of the man page.
 *                 entry_num   - entry number of the man page.
 *	Returns: fp - the file pointer
 *
 * NOTES:
 *
 * If there is a uncompressed section it will look there for uncompressed
 * manual pages first and then for individually compressed file in the
 * uncompressed section.
 *
 * If there is a compressed directory then it will also look there for
 * the manual pages.
 *
 * If both of these fail then it will attempt to format the manual page.
 */

FILE *
FindManualFile(ManpageGlobals * man_globals, int section_num, int entry_num)
{
    FILE *file;
    char path[BUFSIZ], page[BUFSIZ], section[BUFSIZ], *temp;
    char filename[BUFSIZ];
    const char *entry = manual[section_num].entries[entry_num];
    int len_cat = strlen(CAT);

#if defined(ISC) || defined(__SCO__) || defined(__UNIXWARE__)
    int i;
#endif

    temp = CreateManpageName(entry, 0, 0);
    snprintf(man_globals->manpage_title, sizeof(man_globals->manpage_title),
             "The current manual page is: %s.", temp);
    XtFree(temp);

    ParseEntry(entry, path, section, page);

/*
 * Look for uncompressed files first.
 */
#if defined(__OpenBSD__) || defined(__NetBSD__)
    /* look in machine subdir first */
    snprintf(filename, sizeof(filename), "%s/%s%s/%s/%s", path, CAT,
             section + len_cat, MACHINE, page);
    if ((file = fopen(filename, "r")) != NULL)
        return (file);
#endif

    snprintf(filename, sizeof(filename), "%s/%s%s/%s",
             path, CAT, section + len_cat, page);
    if ((file = fopen(filename, "r")) != NULL)
        return (file);

/*
 * Then for compressed files in an uncompressed directory.
 */

#if !defined(ISC) && !defined(__UNIXWARE__)
#if defined(__OpenBSD__) || defined(__NetBSD__)
    /* look in machine subdir first */
    snprintf(filename, sizeof(filename), "%s/%s%s/%s/%s.%s", path, CAT,
             section + len_cat, MACHINE, page, COMPRESSION_EXTENSION);
    if ((file = Uncompress(man_globals, filename)) != NULL)
        return (file);
#endif
    snprintf(filename, sizeof(filename), "%s/%s%s/%s.%s", path, CAT,
             section + len_cat, page, COMPRESSION_EXTENSION);
    if ((file = Uncompress(man_globals, filename)) != NULL)
        return (file);
#ifdef GZIP_EXTENSION
    else {
#if defined(__OpenBSD__) || defined(__NetBSD__)
        /* look in machine subdir first */
        snprintf(filename, sizeof(filename), "%s/%s%s/%s/%s.%s", path, CAT,
                 section + len_cat, MACHINE, page, GZIP_EXTENSION);
        if ((file = Uncompress(man_globals, filename)) != NULL)
            return (file);
#endif
        snprintf(filename, sizeof(filename), "%s/%s%s/%s.%s", path, CAT,
                 section + len_cat, page, GZIP_EXTENSION);
        if ((file = Uncompress(man_globals, filename)) != NULL)
            return (file);
    }
#endif
#ifdef BZIP2_EXTENSION
#if defined(__OpenBSD__) || defined(__NetBSD__)
    /* look in machine subdir first */
    snprintf(filename, sizeof(filename), "%s/%s%s/%s/%s.%s", path, CAT,
             section + len_cat, MACHINE, page, BZIP2_EXTENSION);
    if ((file = Uncompress(man_globals, filename)) != NULL)
        return (file);
#endif
    {
        snprintf(filename, sizeof(filename), "%s/%s%s/%s.%s", path, CAT,
                 section + len_cat, page, BZIP2_EXTENSION);
        if ((file = Uncompress(man_globals, filename)) != NULL)
            return (file);
    }
#endif
#ifdef LZMA_EXTENSION
    {
        snprintf(filename, sizeof(filename), "%s/%s%s/%s.%s", path, CAT,
                 section + len_cat, page, LZMA_EXTENSION);
        if ((file = Uncompress(man_globals, filename)) != NULL)
            return (file);
    }
#endif
#else
    for (i = 0; i < strlen(COMPRESSION_EXTENSIONS); i++) {
        snprintf(filename, sizeof(filename), "%s/%s%s/%s.%c", path, CAT,
                 section + len_cat, page, COMPRESSION_EXTENSIONS[i]);
        uncompress_format = uncompress_formats[i];
#ifdef DEBUG
        printf("Trying .%c ...\n", COMPRESSION_EXTENSIONS[i]);
#endif
        if ((file = Uncompress(man_globals, filename)) != NULL)
            return (file);
    }
#endif

/*
 * And lastly files in a compressed directory.
 *
 * The directory is not actually compressed it is just named man#.Z
 * and all files in it are compressed without the .Z extension.
 * HP does it this way (really :-).
 */

    snprintf(filename, sizeof(filename), "%s/%s%s.%s/%s", path, CAT,
             section + len_cat, COMPRESSION_EXTENSION, page);
    if ((file = Uncompress(man_globals, filename)) != NULL)
        return (file);
/*
 * We did not find any preformatted manual pages, try to format it.
 */

    return (Format(man_globals, entry));
}

#ifndef HAVE_MKSTEMP
/* Emulate mkstemp to allow use of a common API in the many calls below */
_X_HIDDEN int
Xmkstemp (char *template)
{
    int fd = 0;
    char tmp[PATH_MAX];

    if (strlen(template) >= sizeof(tmp))
        return -1;
    /* save copy of unmodified template in case we have to try again */
    strcpy(tmp, template);

    do {
        if (fd == -1)
            strcpy(template, tmp);
        if ((mktemp(template) == NULL) || (template[0] == '\0'))
            return -1;
        fd = open(template, O_RDWR | O_CREAT | O_EXCL, 0600);
    } while ((fd == -1) && (errno == EEXIST || errno == EINTR));

    return fd;
}
#endif

/*	Function Namecompress
 *	Description: This function will attempt to find a compressed man
 *                   page and uncompress it.
 *	Arguments: man_globals - the pseudo global info.
 *                 filename - name of file to uncompress.
 *	Returns:; a pointer to the file or NULL.
 */

static FILE *
Uncompress(ManpageGlobals * man_globals, const char *filename)
{
    char tmp_file[BUFSIZ];
    FILE *file;

    if (!UncompressNamed(man_globals, filename, tmp_file, &file)) {
        PopupWarning(man_globals, "Something went wrong in retrieving the "
                     "uncompressed manual page try cleaning up /tmp.");
        return (NULL);
    }

    remove(tmp_file);           /* remove name in tree, it will remain
                                   until we close the fd, however. */
    return (file);
}

/*	Function Name: UncompressNamed
 *	Description: This function will attempt to find a compressed man
 *                   page and uncompress it.
 *	Arguments: man_globals - the pseudo global info.
 *                 filename - name of file to uncompress.
 * RETURNED        output - the file name output (must be an allocated string).
 *	Returns:; TRUE if the file was found.
 */

static Boolean
UncompressNamed(ManpageGlobals * man_globals, const char *filename,
                char *output, FILE ** output_file)
{
    char tmp[BUFSIZ], cmdbuf[BUFSIZ], error_buf[BUFSIZ];
    struct stat junk;
    int fd;

    if (stat(filename, &junk) != 0) {   /* Check for existence of the file. */
        if (errno != ENOENT) {
            snprintf(error_buf, sizeof(error_buf),
                     "Error while stating file %s, errno = %d", filename,
                     errno);
            PopupWarning(man_globals, error_buf);
        }
        return (FALSE);
    }

/*
 * Using stdin is necessary to fool zcat since we cannot guarantee
 * the .Z extension.
 */

    strcpy(tmp, MANTEMP);       /* get a temp file. */
    fd = mkstemp(tmp);
    if (fd < 0) {
        PopupWarning(man_globals, "Error creating a temp file");
        return FALSE;
    }
    *output_file = fdopen(fd, "r");
    if (*output_file == NULL) {
        remove(tmp);
        close(fd);
        PopupWarning(man_globals, "Error opening temp file");
        return FALSE;
    }
    strcpy(output, tmp);

#ifdef GZIP_EXTENSION
    if (streq(filename + strlen(filename) - strlen(GZIP_EXTENSION),
              GZIP_EXTENSION))
        snprintf(cmdbuf, sizeof(cmdbuf), GUNZIP_FORMAT, filename, output);
    else
#endif
#ifdef BZIP2_EXTENSION
    if (streq(filename + strlen(filename) - strlen(BZIP2_EXTENSION),
                  BZIP2_EXTENSION))
        snprintf(cmdbuf, sizeof(cmdbuf), BUNZIP2_FORMAT, filename, output);
    else
#endif
#ifdef LZMA_EXTENSION
    if (streq(filename + strlen(filename) - strlen(LZMA_EXTENSION),
                  LZMA_EXTENSION))
        snprintf(cmdbuf, sizeof(cmdbuf), UNLZMA_FORMAT, filename, output);
    else
#endif
        snprintf(cmdbuf, sizeof(cmdbuf), UNCOMPRESS_FORMAT, filename, output);
    if (system(cmdbuf) == 0)    /* execute search. */
        return (TRUE);

    snprintf(error_buf, sizeof(error_buf),
             "Error while uncompressing, command was: %s", cmdbuf);
    PopupWarning(man_globals, error_buf);
    return (FALSE);
}

#if defined(SMAN) && defined(SFORMAT)
/*	Function Name: SgmlToRoffNamed
 *	Description: This function will attempt to find an SGML man
 *                   page and convert it to roff format.
 *	Arguments: man_globals - the pseudo global info.
 *                 filename - name of file to uncompress.
 * RETURNED        output - the file name output (must be an allocated string).
 *	Returns:; TRUE if the file was found.
 */

static Boolean
SgmlToRoffNamed(ManpageGlobals * man_globals, char *filename, char *output,
                FILE ** output_file)
{
    char tmp[BUFSIZ], cmdbuf[BUFSIZ], error_buf[BUFSIZ];
    struct stat junk;
    int fd;

    if (stat(filename, &junk) != 0) {   /* Check for existence of the file. */
        if (errno != ENOENT) {
            snprintf(error_buf, sizeof(error_buf),
                     "Error while stating file %s, errno = %d", filename,
                     errno);
            PopupWarning(man_globals, error_buf);
        }
        return (FALSE);
    }

    strcpy(tmp, MANTEMP);       /* get a temp file. */
    fd = mkstemp(tmp);
    if (fd < 0) {
        PopupWarning(man_globals, "Error creating a temp file");
        return FALSE;
    }
    *output_file = fdopen(fd, "r");
    if (*output_file == NULL) {
        remove(tmp);
        close(fd);
        PopupWarning(man_globals, "Error opening temp file");
        return FALSE;
    }
    strcpy(output, tmp);

    snprintf(cmdbuf, sizeof(cmdbuf), "%s %s >> %s", SFORMAT, filename, output);
    if (system(cmdbuf) == 0)    /* execute search. */
        return (TRUE);

    snprintf(error_buf, sizeof(error_buf),
             "Error while converting from sgml, command was: %s", cmdbuf);
    PopupWarning(man_globals, error_buf);
    return (FALSE);
}
#endif                          /* defined (SMAN) && defined(SFORMAT) */

/*	Function Name: Format
 *	Description: This function formats the manual pages and interfaces
 *                   with the user.
 *	Arguments: man_globals - the pseudo globals
 *                 file - the file pointer to use and return
 *                 entry - the current entry struct.
 *                 current_box - The current directory being displayed.
 *	Returns: none.
 */

/* ARGSUSED */
FILE *
Format(ManpageGlobals * man_globals, const char *entry)
{
    FILE *file = NULL;
    int fd;

    Widget manpage = man_globals->manpagewidgets.manpage;
    char cmdbuf[BUFSIZ], tmp[BUFSIZ], filename[BUFSIZ], error_buf[BUFSIZ];
    char path[BUFSIZ], sect[BUFSIZ];
    XEvent event;
    Position x, y;              /* location to pop up the
                                   "would you like to save" widget. */

    if (!UncompressUnformatted(man_globals, entry, filename, &file)) {
        /* We Really could not find it, this should never happen, yea right. */
        snprintf(error_buf, sizeof(error_buf),
                 "Could not open manual page, %s", entry);
        PopupWarning(man_globals, error_buf);
        XtPopdown(XtParent(man_globals->standby));
        return (NULL);
    }

    if (file != NULL) {
        char line[BUFSIZ];

        if (fgets(line, sizeof(line), file) != NULL) {
            if (strncmp(line, ".so ", 4) == 0) {
                size_t len = strlen(line); /* must be >= 4 to pass strncmp */
                if (line[len - 1] == '\n')
                    line[len - 1] = '\0';
                fclose(file);
                remove(filename);
                if (line[4] != '/') {
                    char *ptr = NULL;

                    strcpy(tmp, entry);
                    if ((ptr = strrchr(tmp, '/')) != NULL) {
                        *ptr = '\0';
                        if ((ptr = strrchr(tmp, '/')) != NULL)
                            ptr[1] = '\0';
                    }
                }
                else
                    *tmp = '\0';
                snprintf(filename, sizeof(filename), "%s%s", tmp, line + 4);

                return (Format(man_globals, filename));
            }
        }
        fclose(file);
    }

    Popup(XtParent(man_globals->standby), XtGrabExclusive);
    while (!XCheckTypedWindowEvent(XtDisplay(man_globals->standby),
                                   XtWindow(man_globals->standby),
                                   Expose, &event));
    XtDispatchEvent(&event);
    XFlush(XtDisplay(man_globals->standby));

    strcpy(tmp, MANTEMP);       /* Get a temp file. */
    fd = mkstemp(tmp);
    if (fd >= 0) {
        file = fdopen(fd, "r");
        if (file == NULL) {
            remove(tmp);
            close(fd);
        }
    }
    else
        file = NULL;
    if (file == NULL) {
        PopupWarning(man_globals, "Something went wrong in opening the "
                     "temp file, try cleaning up /tmp");
        return NULL;
    }
    strcpy(man_globals->tempfile, tmp);

    ParseEntry(entry, path, sect, NULL);

#ifndef HANDLE_ROFFSEQ
    snprintf(cmdbuf, sizeof(cmdbuf), "cd %s ; %s %s %s >> %s %s", path, TBL,
             filename, FORMAT, man_globals->tempfile, "2> /dev/null");
#else
    /* Handle more flexible way of specifying the formatting pipeline */
    if (!ConstructCommand(cmdbuf, path, filename, man_globals->tempfile)) {
        PopupWarning(man_globals, "Constructed command was too long!");
        fclose(file);
        file = NULL;
    }
    else
#endif                          /* HANDLE_ROFFSEQ */

    if (system(cmdbuf) != 0) {  /* execute search. */
        snprintf(error_buf, sizeof(error_buf),
                 "Something went wrong trying to run the command: %s", cmdbuf);
        PopupWarning(man_globals, error_buf);
        fclose(file);
        file = NULL;
    }
    else {
        if (file != NULL) {
            XtPopdown(XtParent(man_globals->standby));

            if ((man_globals->save == NULL) ||
                (man_globals->manpagewidgets.manpage == NULL))
                remove(man_globals->tempfile);
            else {
                char *ptr, catdir[BUFSIZ];

                /*
                 * If the catdir is writable then ask the user if he/she wants to
                 * write the man page to it.
                 */

                strcpy(catdir, man_globals->save_file);
                if ((ptr = strrchr(catdir, '/')) != NULL) {
                    *ptr = '\0';

                    if (access(catdir, W_OK) != 0)
                        remove(man_globals->tempfile);
                    else {
                        x = (Position) Width(man_globals->manpagewidgets.
                                             manpage) / 2;
                        y = (Position) Height(man_globals->manpagewidgets.
                                              manpage) / 2;
                        XtTranslateCoords(manpage, x, y, &x, &y);
                        PositionCenter(man_globals->save, (int) x, (int) y, 0,
                                       0, 0, 0);
                        XtPopup(man_globals->save, XtGrabExclusive);
                    }
                }
                else
                    remove(man_globals->tempfile);
            }
        }
    }

    /*
     * If the original was compressed or in another format, delete temporary file.
     */
    if (man_globals->deletetempfile)
        remove(filename);

    return (file);
}

#ifdef HANDLE_ROFFSEQ
/*      Function Name: ConstructCommand
 *      Description: Constructs the pipeline of commands necessary to format
 *                   a manual page.
 *      Arguments: cmdbuf - the buffer into which to write the command
 *                 path - the directory in which the original man page resides
 *                 filename - the (uncompressed) manpage source file
 *                 tempfile - the name of a temporary file to direct the final
 *                  output of the pipeline into
 *      Returns: TRUE if the command fit into the buffer, FALSE if it would
 *               be too long (more than BUFSIZ characters)
 */
static Boolean
ConstructCommand(char *cmdbuf, const char *path,
                 const char *filename, const char *tempfile)
{
    /* The original code did the following to produce a command line:
     *   sprintf(cmdbuf,"cd %s ; %s %s %s > %s %s", path, TBL,
     *      filename, FORMAT, man_globals->tempfile, "2> /dev/null");
     * We are more flexible and follow more or less the algorithm used
     * by the Linux man command:
     *  + Obtain a string of letters from the following sources in order
     *    of preference:
     *    + a command line option (not implemented in xman; it's probably not
     *      useful)
     *    + the first line of the manpage source, if it is of the form:
     *      '\" <string>
     *    + the MANROFFSEQ environment variable
     *    + a default string; this is "".
     *  + Interpret the string as a pipeline of filters:
     *    + e = eqn   g = grap   p = pic   t = tbl   v = vgrind   r = refer
     *  + zsoelim is always run as the first preprocessor in any case.
     *
     * Strictly speaking we should save a catpage iff the string comes
     * from the file or is the default.
     *
     * You'll notice that we format a man page into ASCII text output and then
     * attempt to interpret things like L^HL as bold and so forth. This
     * is so obviously the Wrong Thing it's untrue.
     */
    char *c = cmdbuf;           /* current posn in buffer */
    int left = BUFSIZ;          /* space left in buffer */
    int used;
    const char *fmt;
    char fmtbuf[128];

    fmt = NULL;
    /* If you have a command line option that gives a setting for fmt,
       set it here. */

    if (!fmt) {
        /* This is the tricky bit: extract a format string from the source file
         * Annoyingly, filename might be relative or absolute. We cheat and
         * use system to get the thing to a known absolute filename.
         */
        FILE *file;
        int gotfmt = 0;    /* set to 1 if we got a directive from source */
        char fname[PATH_MAX];

        if (filename[0] == '/') {
            snprintf(fname, sizeof(fname), "%s", filename);
        }
        else {
            snprintf(fname, sizeof(fname), "%s/%s", path, filename);
        }
        if ((file = fopen(fname, "r")) != NULL) {
            if ((fgets(fmtbuf, sizeof(fmtbuf), file)) &&
                (!memcmp(fmtbuf, "'\\\" ", 4))) {
                /* that's squote-backslash-dquote-space */
                int len = strlen(fmtbuf);

                if (len && (fmtbuf[len - 1] == '\n')) {
                    fmtbuf[len - 1] = 0;
                    fmt = fmtbuf + 3;
                    gotfmt++;
                }
            }
            fclose(file);
        }
        if (!gotfmt) {          /* not there or some error */
            fmt = getenv("MANROFFSEQ");
        }
    }

    if (!fmt) {
        fmt = DEFAULT_MANROFFSEQ;
    }

    /* Start with the first fixed part of the command line */
    used = snprintf(c, left, "cd %s; %s %s ", path, ZSOELIM, filename);
    left -= used;
    c += used;
    if (left <= 1)
        return (FALSE);

    /* Now add preprocessors of the form '| processor' */
    for (; *fmt; fmt++) {
        const char *filter;

        switch (*fmt) {
        case 'e':
            filter = EQN;
            break;
        case 'g':
            filter = GRAP;
            break;
        case 'p':
            filter = ROFF_PIC;
            break;
        case 't':
            filter = TBL;
            break;
        case 'v':
            filter = VGRIND;
            break;
        case 'r':
            filter = REFER;
            break;
        default:
            filter = NULL;
            break;
        }
        if (filter) {
            used = snprintf(c, left, " | %s ", filter);
            left -= used;
            c += used;
            if (left <= 1)
                return (FALSE);
        }
    }

    /* Now add the fixed trailing part 'formatprog > tempfile 2> /dev/null' */
    used = snprintf(c, left, " | %s >> %s 2>/dev/null", FORMAT, tempfile);
    left -= used;
    if (left <= 1)
        return (FALSE);

    return (TRUE);
}
#endif                          /* HANDLE_ROFFSEQ */

/*	Function Name: UncompressUnformatted
 *	Description: Finds an uncompressed unformatted manual page.
 *	Arguments: man_globals - the pseudo global structure.
 *                 entry - the manual page entry.
 * RETURNED        filename - location to put the name of the file.
 *	Returns: TRUE if the file was found.
 */

static Boolean
UncompressUnformatted(ManpageGlobals * man_globals, const char *entry,
                      char *filename, FILE ** file)
{
    char path[BUFSIZ], page[BUFSIZ], section[BUFSIZ], input[BUFSIZ];
    int len_cat = strlen(CAT), len_man = strlen(MAN);

#if defined(SMAN) && defined(SFORMAT)
    int len_sman = strlen(SMAN);
#endif

    ParseEntry(entry, path, section, page);

    man_globals->bzip2 = FALSE;
    man_globals->lzma = FALSE;

#if defined(__OpenBSD__) || defined(__NetBSD__)
    /*
     * look for uncompressed file in machine subdir first
     */
    snprintf(filename, BUFSIZ, "%s/%s%s/%s/%s", path, MAN,
             section + len_cat, MACHINE, page);
    if (access(filename, R_OK) == 0) {
        man_globals->compress = FALSE;
        man_globals->gzip = FALSE;
        man_globals->deletetempfile = FALSE;
        snprintf(man_globals->save_file, sizeof(man_globals->save_file),
                 "%s/%s%s/%s/%s", path, CAT, section + len_cat, MACHINE, page);
        return (TRUE);
    }
    /*
     * Then for compressed files in an uncompressed directory.
     */
    snprintf(input, sizeof(input), "%s.%s", filename, COMPRESSION_EXTENSION);
    if (UncompressNamed(man_globals, input, filename, file)) {
        man_globals->compress = TRUE;
        man_globals->deletetempfile = TRUE;
        snprintf(man_globals->save_file, sizeof(man_globals->save_file),
                 "%s/%s%s/%s.%s", path, CAT, section + len_cat, page,
                 COMPRESSION_EXTENSION);
        return (TRUE);
    }
#ifdef GZIP_EXTENSION
    else {
        snprintf(input, sizeof(input), "%s.%s", filename, GZIP_EXTENSION);
        if (UncompressNamed(man_globals, input, filename, file)) {
            man_globals->compress = TRUE;
            man_globals->gzip = TRUE;
            man_globals->deletetempfile = TRUE;
            snprintf(man_globals->save_file, sizeof(man_globals->save_file),
                     "%s/%s%s/%s.%s", path, CAT, section + len_cat, page,
                     GZIP_EXTENSION);
            return (TRUE);
        }
    }
#endif                          /* GZIP_EXTENSION */
#endif                          /* __OpenBSD__ || __NetBSD__ */

#ifdef BZIP2_EXTENSION
    {
        snprintf(input, sizeof(input), "%s.%s", filename, BZIP2_EXTENSION);
        if (UncompressNamed(man_globals, input, filename, file)) {
            man_globals->compress = TRUE;
            man_globals->gzip = FALSE;
            man_globals->bzip2 = TRUE;
            snprintf(man_globals->save_file, sizeof(man_globals->save_file),
                     "%s/%s%s/%s.%s", path, CAT, section + len_cat, page,
                     BZIP2_EXTENSION);
            return (TRUE);
        }
    }
#endif                          /* BZIP2_EXTENSION */

#ifdef LZMA_EXTENSION
    {
        snprintf(input, sizeof(input), "%s.%s", filename, LZMA_EXTENSION);
        if (UncompressNamed(man_globals, input, filename, file)) {
            man_globals->compress = TRUE;
            man_globals->gzip = FALSE;
            man_globals->lzma = TRUE;
            snprintf(man_globals->save_file, sizeof(man_globals->save_file),
                     "%s/%s%s/%s.%s", path, CAT, section + len_cat, page,
                     LZMA_EXTENSION);
            return (TRUE);
        }
    }
#endif                          /* LZMA_EXTENSION */

/*
 * Look for uncompressed file first.
 */

    snprintf(filename, BUFSIZ, "%s/%s%s/%s", path, MAN, section + len_man,
             page);
    if (access(filename, R_OK) == 0) {
        man_globals->compress = FALSE;
        man_globals->gzip = FALSE;
        man_globals->deletetempfile = FALSE;
        snprintf(man_globals->save_file, sizeof(man_globals->save_file),
                 "%s/%s%s/%s", path, CAT, section + len_cat, page);
        return (TRUE);
    }

#if defined(SMAN) && defined(SFORMAT)
    /*
     * Look for uncompressed sgml file next.
     */

    snprintf(input, BUFSIZ, "%s/%s%s/%s", path, SMAN, section + len_sman, page);
    if (SgmlToRoffNamed(man_globals, input, filename, file)) {
        man_globals->compress = FALSE;
        man_globals->gzip = FALSE;
        man_globals->deletetempfile = TRUE;
        snprintf(man_globals->save_file, sizeof(man_globals->save_file),
                 "%s/%s%s/%s", path, CAT, section + len_cat, page);
        return (TRUE);
    }
#endif

/*
 * Then for compressed files in an uncompressed directory.
 */

    snprintf(input, sizeof(input), "%s.%s", filename, COMPRESSION_EXTENSION);
    if (UncompressNamed(man_globals, input, filename, file)) {
        man_globals->compress = TRUE;
        man_globals->deletetempfile = TRUE;
        snprintf(man_globals->save_file, sizeof(man_globals->save_file),
                 "%s/%s%s/%s.%s", path, CAT, section + len_cat, page,
                 COMPRESSION_EXTENSION);
        return (TRUE);
    }
#ifdef GZIP_EXTENSION
    else {
        snprintf(input, sizeof(input), "%s.%s", filename, GZIP_EXTENSION);
        if (UncompressNamed(man_globals, input, filename, file)) {
            man_globals->compress = TRUE;
            man_globals->gzip = TRUE;
            man_globals->deletetempfile = TRUE;
            snprintf(man_globals->save_file, sizeof(man_globals->save_file),
                     "%s/%s%s/%s.%s", path, CAT, section + len_cat, page,
                     GZIP_EXTENSION);
            return (TRUE);
        }
    }
#endif

#ifdef BZIP2_EXTENSION
    {
        snprintf(input, sizeof(input), "%s.%s", filename, BZIP2_EXTENSION);
        if (UncompressNamed(man_globals, input, filename, file)) {
            man_globals->compress = TRUE;
            man_globals->gzip = TRUE;
            snprintf(man_globals->save_file, sizeof(man_globals->save_file),
                     "%s/%s%s/%s.%s", path, CAT, section + len_cat, page,
                     BZIP2_EXTENSION);
            return (TRUE);
        }
    }
#endif

#ifdef LZMA_EXTENSION
    {
        snprintf(input, sizeof(input), "%s.%s", filename, LZMA_EXTENSION);
        if (UncompressNamed(man_globals, input, filename, file)) {
            man_globals->compress = TRUE;
            man_globals->lzma = TRUE;
            snprintf(man_globals->save_file, sizeof(man_globals->save_file),
                     "%s/%s%s/%s.%s", path, CAT, section + len_cat, page,
                     LZMA_EXTENSION);
            return (TRUE);
        }
    }
#endif

/*
 * And lastly files in a compressed directory.
 */

    snprintf(input, sizeof(input), "%s/%s%s.%s/%s", path,
             MAN, section + len_man, COMPRESSION_EXTENSION, page);
    if (UncompressNamed(man_globals, input, filename, file)) {
        man_globals->compress = TRUE;
        man_globals->deletetempfile = TRUE;
        snprintf(man_globals->save_file, sizeof(man_globals->save_file),
                 "%s/%s%s.%s/%s", path, CAT, section + len_cat,
                 COMPRESSION_EXTENSION, page);
        return (TRUE);
    }
    return (FALSE);
}

/*	Function Name: AddCursor
 *	Description: This function adds the cursor to the window.
 *	Arguments: w - the widget to add the cursor to.
 *                 cursor - the cursor to add to this widget.
 *	Returns: none
 */

void
AddCursor(Widget w, Cursor cursor)
{
    XColor colors[2];
    Arg args[10];
    Cardinal num_args = 0;
    Colormap c_map;

    if (!XtIsRealized(w)) {
        PopupWarning(NULL, "Widget is not realized, no cursor added.\n");
        return;
    }

    XtSetArg(args[num_args], XtNcolormap, &c_map);
    num_args++;
    XtGetValues(w, args, num_args);

    colors[0].pixel = resources.cursors.fg_color;
    colors[1].pixel = resources.cursors.bg_color;

    XQueryColors(XtDisplay(w), c_map, colors, 2);
    XRecolorCursor(XtDisplay(w), cursor, colors, colors + 1);
    XDefineCursor(XtDisplay(w), XtWindow(w), cursor);
}

/*	Function Name: ChangeLabel
 *	Description: This function changes the label field of the
 *                   given widget to the string in str.
 *	Arguments: w - the widget.
 *                 str - the string to change the label to.
 *	Returns: none
 */

void
ChangeLabel(Widget w, const char *str)
{
    Arg arglist[3];             /* An argument list. */

    if (w == NULL)
        return;

    XtSetArg(arglist[0], XtNlabel, str);

/* shouldn't really have to do this. */
    XtSetArg(arglist[1], XtNwidth, 0);
    XtSetArg(arglist[2], XtNheight, 0);

    XtSetValues(w, arglist, (Cardinal) 1);
}

/*
 * In an ideal world this would be part of the XToolkit, and I would not
 * have to do it, but such is life sometimes.  Perhaps in X11R3.
 */

/*	Function Name: PositionCenter
 *	Description: This function positions the given widgets center
 *                   in the following location.
 *	Arguments: widget - the widget widget to position
 *                 x,y - The location for the center of the widget
 *                 above - number of pixels above center to locate this widget
 *                 left - number of pixels left of center to locate this widget
 *                 h_space, v_space - how close to get to the edges of the
 *                                    parent window.
 *	Returns: none
 *      Note:  This should only be used with a popup widget that has override
 *             redirect set.
 */

void
PositionCenter(Widget widget, int x, int y, int above, int left, int v_space,
               int h_space)
{
    Arg wargs[2];
    int x_temp, y_temp;         /* location of the new window. */
    int parent_height, parent_width;    /* Height and width of the parent widget or
                                           the root window if it has no parent. */

    x_temp = x - left - Width(widget) / 2 + BorderWidth(widget);
    y_temp = y - above - Height(widget) / 2 + BorderWidth(widget);

    parent_height = HeightOfScreen(XtScreen(widget));
    parent_width = WidthOfScreen(XtScreen(widget));

/*
 * Check to make sure that all edges are within the viewable part of the
 * root window, and if not then force them to be.
 */

    if (x_temp < h_space)
        x_temp = v_space;
    if (y_temp < v_space)
        (y_temp = 2);

    if (y_temp + Height(widget) + v_space > parent_height)
        y_temp = parent_height - Height(widget) - v_space;

    if (x_temp + Width(widget) + h_space > parent_width)
        x_temp = parent_width - Width(widget) - h_space;

    XtSetArg(wargs[0], XtNx, x_temp);
    XtSetArg(wargs[1], XtNy, y_temp);
    XtSetValues(widget, wargs, 2);
}

/*	Function Name: ParseEntry(entry, path, sect, page)
 *	Description: Parses the manual pages entry filenames.
 *	Arguments: str - the full path name.
 *                 path - the path name.      RETURNED
 *                 sect - the section name.   RETURNED
 *                 page - the page name.      RETURNED
 *	Returns: none.
 */

void
ParseEntry(const char *entry, char *path, char *sect, char *page)
{
    char *c, temp[BUFSIZ];

    strcpy(temp, entry);

    c = strrchr(temp, '/');
    if (c == NULL)
        PrintError("Failed to find / in ParseEntry.");
    *c++ = '\0';
    if (page != NULL)
        strcpy(page, c);

    c = strrchr(temp, '/');
    if (c == NULL)
        PrintError("Failed to find / in ParseEntry.");
    *c++ = '\0';
#if defined(SFORMAT) && defined(SMAN)
    /* sgmltoroff sometimes puts an extra ./ in the path to .so entries */
    if (strcmp(c, ".") == 0) {
        c = strrchr(temp, '/');
        if (c == NULL)
            PrintError("Failed to find / in ParseEntry.");
        *c++ = '\0';
    }
#endif
#if defined(__OpenBSD__) || defined(__NetBSD__)
    /* Skip machine subdirectory if present */
    if (strcmp(c, MACHINE) == 0) {
        c = strrchr(temp, '/');
        if (c == NULL)
            PrintError("Failed to find / in ParseEntry.");
        *c++ = '\0';
    }
#endif
    if (sect != NULL)
        strcpy(sect, c);

    if (path != NULL)
        strcpy(path, temp);
}

/*      Function Name: GetGlobals
 *      Description: Gets the pseudo globals associated with the
 *                   manpage associated with this widget.
 *      Arguments: w - a widget in the manpage.
 *      Returns: the pseudo globals.
 *      Notes: initial_widget is a globals variable.
 *             manglobals_context is a global variable.
 */

ManpageGlobals *
GetGlobals(Widget w)
{
    Widget temp;
    caddr_t data;

    while ((temp = XtParent(w)) != initial_widget && (temp != NULL))
        w = temp;

    if (temp == NULL)
        XtAppError(XtWidgetToApplicationContext(w),
                   "Xman: Could not locate widget in tree, exiting");

    if (XFindContext(XtDisplay(w), XtWindow(w),
                     manglobals_context, &data) != XCSUCCESS)
        XtAppError(XtWidgetToApplicationContext(w),
                   "Xman: Could not find global data, exiting");

    return ((ManpageGlobals *) data);
}

/*      Function Name: SaveGlobals
 *      Description: Saves the pseudo globals on the widget passed
 *                   to this function, although GetGlobals assumes that
 *                   the data is associated with the popup child of topBox.
 *      Arguments: w - the widget to associate the data with.
 *                 globals - data to associate with this widget.
 *      Returns: none.
 *      Notes: WIDGET MUST BE REALIZED.
 *             manglobals_context is a global variable.
 */

void
SaveGlobals(Widget w, ManpageGlobals * globals)
{
    if (XSaveContext(XtDisplay(w), XtWindow(w), manglobals_context,
                     (caddr_t) globals) != XCSUCCESS)
        XtAppError(XtWidgetToApplicationContext(w),
                   "Xman: Could not save global data, are you out of memory?");
}

/*      Function Name: RemoveGlobals
 *      Description: Removes the pseudo globals from the widget passed
 *                   to this function.
 *      Arguments: w - the widget to remove the data from.
 *      Returns: none.
 *      Notes: WIDGET MUST BE REALIZED.
 *             manglobals_context is a global variable.
 */

void
RemoveGlobals(Widget w)
{
    if (XDeleteContext(XtDisplay(w), XtWindow(w),
                       manglobals_context) != XCSUCCESS)
        XtAppError(XtWidgetToApplicationContext(w),
                   "Xman: Could not remove global data?");
}
@


1.4
log
@Update to xman 1.1.3
@
text
@d529 3
a531 1
                line[strlen(line) - 1] = '\0';
@


1.3
log
@Update to xman 1.1.2
@
text
@a0 2
/* $XConsortium: misc.c,v 1.31 94/12/16 21:36:53 gildea Exp $ */
/* $XdotOrg: xc/programs/xman/misc.c,v 1.6 2004/09/02 08:40:33 kem Exp $ */
a29 1
/* $XFree86: xc/programs/xman/misc.c,v 1.10 2003/08/02 17:35:48 herrb Exp $ */
d43 1
a43 1
#include <X11/Xos.h> 		/* sys/types.h and unistd.h included in here */
d49 5
a53 4
static FILE * Uncompress(ManpageGlobals * man_globals, char * filename);
#ifndef HAS_MKSTEMP
static Boolean UncompressNamed(ManpageGlobals * man_globals, char * filename,
			       char * output);
d55 3
a57 8
				     char * entry, char * filename);
#else
static Boolean UncompressNamed(ManpageGlobals * man_globals, char * filename,
			       char * output, FILE ** output_fd);
static Boolean UncompressUnformatted(ManpageGlobals * man_globals,
				     char * entry, char * filename,
				     FILE **file);
#endif
d59 2
a60 1
static Boolean ConstructCommand(char * cmdbuf, char * path, char * filename, char * tempfile);
d65 6
a70 5
static char *uncompress_formats[] =
      {  UNCOMPRESS_FORMAT_1,
         UNCOMPRESS_FORMAT_2,
         UNCOMPRESS_FORMAT_3
      };
d74 1
a74 1
 *	Description: This function pops upa warning message.
d84 1
a84 1
  XtPopdown((Widget)client);
d88 1
a88 1
PopupWarning(ManpageGlobals * man_globals, const char * string)
d90 39
a128 25
  int n;
  Arg wargs[3];
  Dimension topX, topY;
  char buffer[BUFSIZ];
  Boolean hasPosition;

  snprintf( buffer, sizeof(buffer), "Xman Warning: %s", string);
  hasPosition = FALSE;
  if (top)
  {
    n=0;
    XtSetArg(wargs[n], XtNx, &topX); n++;
    XtSetArg(wargs[n], XtNy, &topY); n++;
    XtGetValues(top, wargs, n);
    hasPosition = TRUE;
  }

  if (man_globals != NULL)
    ChangeLabel(man_globals->label, buffer);
  if (man_globals->label == NULL) {
    n=0;
    if (hasPosition)
    {
      XtSetArg(wargs[n], XtNx, topX); n++;
      XtSetArg(wargs[n], XtNy, topY); n++;
a129 11
    XtSetArg(wargs[n], XtNtransientFor, top); n++;
    warnShell = XtCreatePopupShell("warnShell", transientShellWidgetClass,
				   initial_widget, wargs, n);
    XtSetArg(wargs[0], XtNlabel, buffer);
    warnDialog = XtCreateManagedWidget("warnDialog", dialogWidgetClass,
				       warnShell, wargs, 1);
    XawDialogAddButton(warnDialog, "dismiss", PopdownWarning,
		       (XtPointer)warnShell);
    XtRealizeWidget(warnShell);
    Popup(warnShell, XtGrabNone);
  }
d135 1
a135 1
 *	Returns: none. - exits tho.
d139 1
a139 1
PrintError(char * string)
d141 2
a142 2
  fprintf(stderr,"Xman Error: %s\n",string);
  exit(EXIT_FAILURE);
d146 1
a146 1
 *	Description: Assignes a file to the manpage.
d155 6
a160 6
  Arg arglist[1];
  Cardinal num_args = 0;
  
  if (man_globals->curr_file) {
#if 0 /* Ownership rules need to be fixed first */
    fclose(man_globals->curr_file);
d162 2
a163 2
  }
  man_globals->curr_file = file;
d165 3
a167 2
  XtSetArg(arglist[num_args], XtNfile, man_globals->curr_file); num_args++;
  XtSetValues(man_globals->manpagewidgets.manpage, arglist, num_args);
d180 1
a180 1
 * If there is a uncompressed section it will look there for uncompresed
d193 6
a198 5
  FILE * file;
  char path[BUFSIZ], page[BUFSIZ], section[BUFSIZ], *temp;
  char filename[BUFSIZ];
  char * entry = manual[section_num].entries[entry_num];
  int len_cat = strlen(CAT);
d200 1
a200 1
  int i;
d203 4
a206 4
  temp = CreateManpageName(entry, 0, 0);
  snprintf(man_globals->manpage_title, sizeof(man_globals->manpage_title),
    "The current manual page is: %s.", temp);
  XtFree(temp);
d208 1
a208 1
  ParseEntry(entry, path, section, page);
d214 5
a218 5
  /* look in machine subdir first */
  snprintf(filename, sizeof(filename), "%s/%s%s/%s/%s", path, CAT,
	  section + len_cat, MACHINE, page);
  if ( (file = fopen(filename,"r")) != NULL)
    return(file);
d221 4
a224 4
  snprintf(filename, sizeof(filename), "%s/%s%s/%s", 
    path, CAT, section + len_cat, page);
  if ( (file = fopen(filename,"r")) != NULL)
    return(file);
d232 10
a241 10
  /* look in machine subdir first */
  snprintf(filename, sizeof(filename), "%s/%s%s/%s/%s.%s", path, CAT,
	  section + len_cat, MACHINE, page, COMPRESSION_EXTENSION);
  if ( (file = Uncompress(man_globals, filename)) != NULL)
    return(file);
#endif
  snprintf(filename, sizeof(filename), "%s/%s%s/%s.%s", path, CAT,
	  section + len_cat, page, COMPRESSION_EXTENSION);
  if ( (file = Uncompress(man_globals, filename)) != NULL)
    return(file);
d243 1
a243 1
  else {
d245 11
a255 11
      /* look in machine subdir first */
      snprintf(filename, sizeof(filename), "%s/%s%s/%s/%s.%s", path, CAT,
	      section + len_cat, MACHINE, page, GZIP_EXTENSION);
      if ( (file = Uncompress(man_globals, filename)) != NULL)
	  return(file);
#endif
    snprintf(filename, sizeof(filename), "%s/%s%s/%s.%s", path, CAT,
	    section + len_cat, page, GZIP_EXTENSION);
    if ( (file = Uncompress(man_globals, filename)) != NULL)
      return(file);
  }
d259 5
a263 5
      /* look in machine subdir first */
      snprintf(filename, sizeof(filename), "%s/%s%s/%s/%s.%s", path, CAT,
	      section + len_cat, MACHINE, page, BZIP2_EXTENSION);
      if ( (file = Uncompress(man_globals, filename)) != NULL)
	  return(file);
d265 6
a270 6
  {
    snprintf(filename, sizeof(filename), "%s/%s%s/%s.%s", path, CAT,
	    section + len_cat, page, BZIP2_EXTENSION);
    if ( (file = Uncompress(man_globals, filename)) != NULL)
      return(file);
  }
d273 6
a278 6
  {
    snprintf(filename, sizeof(filename), "%s/%s%s/%s.%s", path, CAT,
	    section + len_cat, page, LZMA_EXTENSION);
    if ( (file = Uncompress(man_globals, filename)) != NULL)
      return(file);
  }
d281 4
a284 4
  for(i = 0; i < strlen(COMPRESSION_EXTENSIONS); i++) {
      snprintf(filename, sizeof(filename), "%s/%s%s/%s.%c", path, CAT,
            section + len_cat, page, COMPRESSION_EXTENSIONS[i]);
      uncompress_format = uncompress_formats[i];
d286 1
a286 1
      printf("Trying .%c ...\n", COMPRESSION_EXTENSIONS[i]);
d288 3
a290 3
      if ( (file = Uncompress(man_globals, filename)) != NULL)
	return(file);
  }
d301 4
a304 4
  snprintf(filename, sizeof(filename), "%s/%s%s.%s/%s", path, CAT, 
	   section + len_cat, COMPRESSION_EXTENSION, page);
  if ( (file = Uncompress(man_globals, filename)) != NULL)
    return(file);
d309 1
a309 1
  return(Format(man_globals, entry));
d312 25
d340 1
a340 1
 *	Arguments: man_globals - the psuedo global info.
d346 1
a346 1
Uncompress(ManpageGlobals * man_globals, char * filename)
d348 2
a349 2
  char tmp_file[BUFSIZ];
  FILE * file;
d351 5
a355 15
#ifndef HAS_MKSTEMP
  if ( !UncompressNamed(man_globals, filename, tmp_file) )
    return(NULL);

  else if ((file = fopen(tmp_file, "r")) == NULL) {
      PopupWarning(man_globals, "Something went wrong in retrieving the "
		   "uncompressed manual page try cleaning up /tmp.");
  }
#else
  if (!UncompressNamed(man_globals, filename, tmp_file, &file)) {
      PopupWarning(man_globals, "Something went wrong in retrieving the "
		   "uncompressed manual page try cleaning up /tmp.");
      return(NULL);
  }
#endif
d357 3
a359 3
  unlink(tmp_file);		/* remove name in tree, it will remain
				   until we close the fd, however. */
  return(file);
d365 1
a365 1
 *	Arguments: man_globals - the psuedo global info.
a370 4
#ifndef HAS_MKSTEMP
static Boolean
UncompressNamed(ManpageGlobals * man_globals, char * filename, char * output)
#else
d372 2
a373 3
UncompressNamed(ManpageGlobals * man_globals, char * filename, char * output,
		FILE ** output_fd)
#endif
d375 12
a386 11
  char tmp[BUFSIZ], cmdbuf[BUFSIZ], error_buf[BUFSIZ];
  struct stat junk;
#ifdef HAS_MKSTEMP
  int fd;
#endif

  if (stat(filename, &junk) != 0) { /* Check for existance of the file. */
    if (errno != ENOENT) {
      snprintf(error_buf, sizeof(error_buf),
	       "Error while stating file %s, errno = %d", filename, errno);
      PopupWarning(man_globals, error_buf);
a387 2
    return(FALSE);
  }
d390 1
a390 1
 * Using stdin is necessary to fool zcat since we cannot guarentee
d394 14
a407 12
  strcpy(tmp, MANTEMP);		/* get a temp file. */
#ifndef HAS_MKSTEMP
  (void) mktemp(tmp);
#else
  fd = mkstemp(tmp);
  if (fd < 0) {
      PopupWarning(man_globals, "Error creating a temp file");
      return FALSE;
  }
  *output_fd = fdopen(fd, "r");
#endif
  strcpy(output, tmp);
d410 4
a413 4
  if (streq(filename + strlen(filename) - strlen(GZIP_EXTENSION),
	    GZIP_EXTENSION))
    snprintf(cmdbuf, sizeof(cmdbuf), GUNZIP_FORMAT, filename, output);
  else
d416 4
a419 4
  if (streq(filename + strlen(filename) - strlen(BZIP2_EXTENSION),
	    BZIP2_EXTENSION))
    snprintf(cmdbuf, sizeof(cmdbuf), BUNZIP2_FORMAT, filename, output);
  else
d422 13
a434 13
  if (streq(filename + strlen(filename) - strlen(LZMA_EXTENSION),
	    LZMA_EXTENSION))
    snprintf(cmdbuf, sizeof(cmdbuf), UNLZMA_FORMAT, filename, output);
  else
#endif
  snprintf(cmdbuf, sizeof(cmdbuf), UNCOMPRESS_FORMAT, filename, output);
  if(system(cmdbuf) == 0) 	/* execute search. */
    return(TRUE);

  snprintf(error_buf, sizeof(error_buf),
	   "Error while uncompressing, command was: %s", cmdbuf);
  PopupWarning(man_globals, error_buf);
  return(FALSE);
d441 1
a441 1
 *	Arguments: man_globals - the psuedo global info.
a446 4
#ifndef HAS_MKSTEMP
static Boolean
SgmlToRoffNamed(ManpageGlobals * man_globals, char * filename, char * output)
#else
d448 2
a449 3
SgmlToRoffNamed(ManpageGlobals * man_globals, char * filename, char * output,
		FILE ** output_fd)
#endif
d451 37
a487 36
  char tmp[BUFSIZ], cmdbuf[BUFSIZ], error_buf[BUFSIZ];
  struct stat junk;
#ifdef HAS_MKSTEMP
  int fd;
#endif

  if (stat(filename, &junk) != 0) { /* Check for existance of the file. */
    if (errno != ENOENT) {
      snprintf(error_buf, sizeof(error_buf),
	       "Error while stating file %s, errno = %d", filename, errno);
      PopupWarning(man_globals, error_buf);
    }
    return(FALSE);
  }

  strcpy(tmp, MANTEMP);		/* get a temp file. */
#ifndef HAS_MKSTEMP
  (void) mktemp(tmp);
#else
  fd = mkstemp(tmp);
  if (fd < 0) {
      PopupWarning(man_globals, "Error creating a temp file");
      return FALSE;
  }
  *output_fd = fdopen(fd, "r");
#endif
  strcpy(output, tmp);

  snprintf(cmdbuf, sizeof(cmdbuf), "%s %s > %s", SFORMAT, filename, output);
  if(system(cmdbuf) == 0) 	/* execute search. */
    return(TRUE);

  snprintf(error_buf, sizeof(error_buf),
	   "Error while converting from sgml, command was: %s", cmdbuf);
  PopupWarning(man_globals, error_buf);
  return(FALSE);
d489 1
a489 1
#endif /* defined (SMAN) && defined(SFORMAT) */
d492 1
a492 1
 *	Description: This funtion formats the manual pages and interfaces
d494 1
a494 1
 *	Arguments: man_globals - the psuedo globals
a501 1

d503 1
a503 1
Format(ManpageGlobals * man_globals, char * entry)
d505 18
a522 10
  FILE * file = NULL;
#ifdef HAS_MKSTEMP
  int fd;
#endif
  Widget manpage = man_globals->manpagewidgets.manpage;
  char cmdbuf[BUFSIZ], tmp[BUFSIZ], filename[BUFSIZ], error_buf[BUFSIZ];
  char path[BUFSIZ], sect[BUFSIZ];
  XEvent event;
  Position x,y;			/* location to pop up the
				   "would you like to save" widget. */
d524 2
a525 12
#ifndef HAS_MKSTEMP
  if ( !UncompressUnformatted(man_globals, entry, filename) ) {
#else
  if ( !UncompressUnformatted(man_globals, entry, filename, &file) ) {
#endif
    /* We Really could not find it, this should never happen, yea right. */
    snprintf(error_buf, sizeof(error_buf),
	     "Could not open manual page, %s", entry);
    PopupWarning(man_globals, error_buf);
    XtPopdown( XtParent(man_globals->standby) );
    return(NULL);
  }
d527 24
a550 6
#ifndef HAS_MKSTEMP
  if ((file = fopen(filename, "r")) != NULL) {
#else
  if (file != NULL) {
#endif
    char line[BUFSIZ];
d552 24
a575 40
    if (fgets(line, sizeof(line), file) != NULL) {
	if (strncmp(line, ".so ", 4) == 0) {
	  line[strlen(line) - 1] = '\0';
	  fclose(file);
	  unlink(filename);
	  if (line[4] != '/') {
	    char *ptr = NULL;

	    strcpy(tmp, entry);
	    if ((ptr = rindex(tmp, '/')) != NULL) {
	      *ptr = '\0';
	      if ((ptr = rindex(tmp, '/')) != NULL)
		ptr[1] = '\0';
	    }
	  }
	  else
	    *tmp = '\0';
	  snprintf(filename, sizeof(filename), "%s%s", tmp, line + 4);

	  return (Format(man_globals, filename));
	}
    }
    fclose(file);
  }

  Popup(XtParent(man_globals->standby), XtGrabExclusive);
  while ( !XCheckTypedWindowEvent(XtDisplay(man_globals->standby),
				  XtWindow(man_globals->standby),
				  Expose, &event) );
  XtDispatchEvent( &event );
  XFlush(XtDisplay(man_globals->standby));

  strcpy(tmp,MANTEMP);		          /* Get a temp file. */
#ifndef HAS_MKSTEMP
  (void) mktemp(tmp);
#else
  fd = mkstemp(tmp);
  file = fdopen(fd, "r");
#endif
  strcpy(man_globals->tempfile, tmp);
d577 1
a577 1
  ParseEntry(entry, path, sect, NULL);
d580 2
a581 3
#ifndef HAS_MKSTEMP
  snprintf(cmdbuf, sizeof(cmdbuf), "cd %s ; %s %s %s > %s %s", path, TBL,
	  filename, FORMAT, man_globals->tempfile, "2> /dev/null");
d583 8
a590 11
  snprintf(cmdbuf, sizeof(cmdbuf), "cd %s ; %s %s %s >> %s %s", path, TBL,
	  filename, FORMAT, man_globals->tempfile, "2> /dev/null");
#endif
#else
  /* Handle more flexible way of specifying the formatting pipeline */
  if (! ConstructCommand(cmdbuf, path, filename, man_globals->tempfile)) {
     PopupWarning(man_globals, "Constructed command was too long!");
     file = NULL;
  }
  else
#endif /* HANDLE_ROFFSEQ */
d592 6
a597 11
  if(system(cmdbuf) != 0) {	/* execute search. */
    snprintf(error_buf, sizeof(error_buf),
	    "Something went wrong trying to run the command: %s", cmdbuf);
    PopupWarning(man_globals, error_buf);
    file = NULL;
  }
  else {
#ifndef HAS_MKSTEMP
    if ((file = fopen(man_globals->tempfile,"r")) == NULL) {
      PopupWarning(man_globals, "Something went wrong in retrieving the "
		   "temp file, try cleaning up /tmp");
d600 2
a601 1
#endif
d603 33
a635 1
      XtPopdown( XtParent(man_globals->standby) );
d637 5
a641 38
      if ( (man_globals->save == NULL) ||
	   (man_globals->manpagewidgets.manpage == NULL) )
	unlink(man_globals->tempfile);
      else {
	char * ptr, catdir[BUFSIZ];

	/*
	 * If the catdir is writeable then ask the user if he/she wants to
	 * write the man page to it.
	 */

	strcpy(catdir, man_globals->save_file);
	if ( (ptr = rindex(catdir, '/')) != NULL) {
	  *ptr = '\0';

	  if ( access(catdir, W_OK) != 0 )
	    unlink(man_globals->tempfile);
	  else {
	    x = (Position) Width(man_globals->manpagewidgets.manpage)/2;
	    y = (Position) Height(man_globals->manpagewidgets.manpage)/2;
	    XtTranslateCoords(manpage, x, y, &x, &y);
	    PositionCenter( man_globals->save, (int) x, (int) y, 0, 0, 0, 0);
	    XtPopup( man_globals->save, XtGrabExclusive);
	  }
	}
	else
	  unlink(man_globals->tempfile);
      }
#ifndef HAS_MKSTEMP
    }
#endif
  }

 /*
  * If the original was compressed or in another format, delete temporary file.
  */
  if (man_globals->deletetempfile) 
    unlink(filename);
d643 1
a643 1
  return(file);
d659 2
a660 2
ConstructCommand(cmdbuf, path, filename, tempfile)
   char *cmdbuf, *path, *filename, *tempfile;
d662 85
a746 96
   /* The original code did the following to produce a command line:
    *   sprintf(cmdbuf,"cd %s ; %s %s %s > %s %s", path, TBL,
    *      filename, FORMAT, man_globals->tempfile, "2> /dev/null");
    * We are more flexible and follow more or less the algorithm used
    * by the Linux man command:
    *  + Obtain a string of letters from the following sources in order
    *    of preference:
    *    + a command line option (not implemented in xman; it's probably not
    *      useful)
    *    + the first line of the manpage source, if it is of the form:
    *      '\" <string>
    *    + the MANROFFSEQ environment variable
    *    + a default string; this is "".
    *  + Interpret the string as a pipeline of filters:
    *    + e = eqn   g = grap   p = pic   t = tbl   v = vgrind   r = refer
    *  + zsoelim is always run as the first preprocessor in any case.
    *
    * Strictly speaking we should save a catpage iff the string comes
    * from the file or is the default.
    *
    * You'll notice that we format a man page into ASCII text output and then
    * attempt to interpret things like L^HL as bold and so forth. This
    * is so obviously the Wrong Thing it's untrue.
    */
   char *c = cmdbuf;           /* current posn in buffer */
   int left = BUFSIZ;          /* space left in buffer */
   int used;
   char *fmt;
   FILE *file;
   char fmtbuf[128];
   int gotfmt = 0;             /* set to 1 if we got a directive from source */
   char fname[PATH_MAX];
#ifdef __UNIXOS2__
   int i;
#endif

   fmt = NULL;
   /* If you have a command line option that gives a setting for fmt,
      set it here. */

   if (!fmt) {
      /* This is the tricky bit: extract a format string from the source file
       * Annoyingly, filename might be relative or absolute. We cheat and
       * use system to get the thing to a known absoute filename.
       */
      if (filename[0] == '/') {
         snprintf(fname, sizeof(fname), "%s", filename);
      } else {
         snprintf(fname, sizeof(fname), "%s/%s", path, filename);
      }
      if ((file = fopen(fname, "r")) &&
          (fgets(fmtbuf, sizeof(fmtbuf), file)) &&
          (!memcmp(fmtbuf, "'\\\" ", 4))) {
                              /* that's squote-backslash-dquote-space */
         int len;
         fmt = fmtbuf + 3;
         len = strlen(fmt);
         if (len && (fmt[len-1] == '\n')) {
            fmt[len-1] = 0;
            gotfmt++;
         }
      }
      if (!gotfmt)                                /* not there or some error */
      {
         fmt = getenv("MANROFFSEQ");
      }
   }

   if (!fmt)
   {
      fmt = DEFAULT_MANROFFSEQ;
   }


   /* Start with the first fixed part of the command line */
#ifdef __UNIXOS2__
   for (i = 0; i < strlen(path); i++) {
     if (path[i] == '/')
       path[i] = '\\';
   }
   used = snprintf(c, left, "cd %s & %s %s ", path, ZSOELIM, filename);
#else
   used = snprintf(c, left, "cd %s; %s %s ", path, ZSOELIM, filename);
#endif
   left -= used;
   c += used;
   if (left <= 1)
      return (FALSE);

   /* Now add preprocessors of the form '| processor' */
   for ( ; *fmt; fmt++)
   {
      char *filter;
      switch (*fmt)
      {
         case 'e':
d749 1
a749 1
         case 'g':
d752 2
a753 2
         case 'p':
            filter = PIC;
d755 1
a755 1
         case 't':
d758 1
a758 1
         case 'v':
d761 1
a761 1
         case 'r':
d764 1
a764 1
         default:
d767 15
a781 24
      }
      if (filter)
      {
         used = snprintf(c, left, " | %s ", filter);
         left -= used;
         c += used;
         if (left <= 1)
            return (FALSE);
      }
   }

   /* Now add the fixed trailing part 'formatprog > tempfile 2> /dev/null' */
#ifdef __UNIXOS2__
   used = snprintf(c, left, " | %s > %s 2>NUL", FORMAT, tempfile);
#else
#ifndef HAS_MKSTEMP
   used = snprintf(c, left, " | %s > %s 2>/dev/null", FORMAT, tempfile);
#else
   used = snprintf(c, left, " | %s >> %s 2>/dev/null", FORMAT, tempfile);
#endif
#endif /* __UNIXOS2__ */
   left -= used;
   if (left <= 1)
      return (FALSE);
d783 1
a783 1
   return (TRUE);
d785 1
a785 1
#endif /* HANDLE_ROFFSEQ */
d789 1
a789 1
 *	Arguments: man_globals - the psuedo global structure.
d796 2
a797 7
#ifndef HAS_MKSTEMP
UncompressUnformatted(ManpageGlobals * man_globals, char * entry,
		      char * filename)
#else
UncompressUnformatted(ManpageGlobals * man_globals, char * entry,
		      char * filename, FILE **file)
#endif
d799 3
a801 2
  char path[BUFSIZ], page[BUFSIZ], section[BUFSIZ], input[BUFSIZ];
  int len_cat = strlen(CAT), len_man = strlen(MAN);
d803 1
a803 1
  int len_sman = strlen(SMAN);
d806 1
a806 1
  ParseEntry(entry, path, section, page);
d808 2
a809 2
  man_globals->bzip2 = FALSE;
  man_globals->lzma = FALSE;
d812 25
a836 29
  /*
   * look for uncompressed file in machine subdir first
   */
  snprintf(filename, BUFSIZ, "%s/%s%s/%s/%s", path, MAN,
	  section + len_cat, MACHINE, page);
  if ( access( filename, R_OK ) == 0 ) {
    man_globals->compress = FALSE;
    man_globals->gzip = FALSE;
    man_globals->deletetempfile = FALSE;
    snprintf(man_globals->save_file, sizeof(man_globals->save_file),
    	     "%s/%s%s/%s/%s", path, CAT, section + len_cat, MACHINE, page);
    return(TRUE);
  }
 /*
  * Then for compressed files in an uncompressed directory.
  */
  snprintf(input, sizeof(input), "%s.%s", filename, COMPRESSION_EXTENSION);
#ifndef HAS_MKSTEMP
  if ( UncompressNamed(man_globals, input, filename) ) {
#else
  if ( UncompressNamed(man_globals, input, filename, file) ) {
#endif
    man_globals->compress = TRUE;
    man_globals->deletetempfile = TRUE;
    snprintf(man_globals->save_file, sizeof(man_globals->save_file),
	     "%s/%s%s/%s.%s", path, CAT, section + len_cat, page, 
	     COMPRESSION_EXTENSION);
    return(TRUE);
  }
d838 14
a851 18
  else {
    snprintf(input, sizeof(input), "%s.%s", filename, GZIP_EXTENSION);
#ifndef HAS_MKSTEMP
    if ( UncompressNamed(man_globals, input, filename) ) {
#else
    if ( UncompressNamed(man_globals, input, filename, file) ) {
#endif
      man_globals->compress = TRUE;
      man_globals->gzip = TRUE;
      man_globals->deletetempfile = TRUE;
      snprintf(man_globals->save_file, sizeof(man_globals->save_file),
	       "%s/%s%s/%s.%s", path, CAT, section + len_cat, page,
	       GZIP_EXTENSION);
      return(TRUE);
    }
  }
#endif /* GZIP_EXTENSION */
#endif /* __OpenBSD__ || __NetBSD__ */
d854 11
a864 14
 {
    snprintf(input, sizeof(input), "%s.%s", filename, BZIP2_EXTENSION);
#ifndef HAS_MKSTEMP
    if ( UncompressNamed(man_globals, input, filename) ) {
#else
    if ( UncompressNamed(man_globals, input, filename, file) ) {
#endif
      man_globals->compress = TRUE;
      man_globals->gzip = FALSE;
      man_globals->bzip2 = TRUE;
      snprintf(man_globals->save_file, sizeof(man_globals->save_file),
	       "%s/%s%s/%s.%s", path, CAT, section + len_cat, page,
	       BZIP2_EXTENSION);
      return(TRUE);
d866 1
a866 2
  }
#endif /* BZIP2_EXTENSION */
d869 11
a879 14
 {
    snprintf(input, sizeof(input), "%s.%s", filename, LZMA_EXTENSION);
#ifndef HAS_MKSTEMP
    if ( UncompressNamed(man_globals, input, filename) ) {
#else
    if ( UncompressNamed(man_globals, input, filename, file) ) {
#endif
      man_globals->compress = TRUE;
      man_globals->gzip = FALSE;
      man_globals->lzma = TRUE;
      snprintf(man_globals->save_file, sizeof(man_globals->save_file),
	       "%s/%s%s/%s.%s", path, CAT, section + len_cat, page,
	       LZMA_EXTENSION);
      return(TRUE);
d881 1
a881 2
  }
#endif /* LZMA_EXTENSION */
d887 10
a896 9
  snprintf(filename, BUFSIZ, "%s/%s%s/%s", path, MAN, section + len_man, page);
  if ( access( filename, R_OK ) == 0 ) {
    man_globals->compress = FALSE;
    man_globals->gzip = FALSE;
    man_globals->deletetempfile = FALSE;
    snprintf(man_globals->save_file, sizeof(man_globals->save_file), 
	     "%s/%s%s/%s", path, CAT, section + len_cat, page);
    return(TRUE);
  }
d899 13
a911 17
 /*
  * Look for uncompressed sgml file next.
  */

  snprintf(input, BUFSIZ, "%s/%s%s/%s", path, SMAN, section + len_sman, page);
#ifndef HAS_MKSTEMP
  if ( SgmlToRoffNamed(man_globals, input, filename) ) {
#else
  if ( SgmlToRoffNamed(man_globals, input, filename, file) ) {
#endif
    man_globals->compress = FALSE;
    man_globals->gzip = FALSE;
    man_globals->deletetempfile = TRUE;
    snprintf(man_globals->save_file, sizeof(man_globals->save_file),
            "%s/%s%s/%s", path, CAT, section + len_cat, page);
    return(TRUE);
  }
d918 9
a926 13
  snprintf(input, sizeof(input), "%s.%s", filename, COMPRESSION_EXTENSION);
#ifndef HAS_MKSTEMP
  if ( UncompressNamed(man_globals, input, filename) ) {
#else
  if ( UncompressNamed(man_globals, input, filename, file) ) {
#endif
    man_globals->compress = TRUE;
    man_globals->deletetempfile = TRUE;
    snprintf(man_globals->save_file, sizeof(man_globals->save_file),
	     "%s/%s%s/%s.%s", path, CAT, section + len_cat, page, 
	     COMPRESSION_EXTENSION);
    return(TRUE);
  }
d928 11
a938 14
  else {
    snprintf(input, sizeof(input), "%s.%s", filename, GZIP_EXTENSION);
#ifndef HAS_MKSTEMP
    if ( UncompressNamed(man_globals, input, filename) ) {
#else
    if ( UncompressNamed(man_globals, input, filename, file) ) {
#endif	
      man_globals->compress = TRUE;
      man_globals->gzip = TRUE;
      man_globals->deletetempfile = TRUE;
      snprintf(man_globals->save_file, sizeof(man_globals->save_file),
	       "%s/%s%s/%s.%s", path, CAT, section + len_cat, page, 
	       GZIP_EXTENSION);
      return(TRUE);
a939 1
  }
d943 10
a952 13
  {
    snprintf(input, sizeof(input), "%s.%s", filename, BZIP2_EXTENSION);
#ifndef HAS_MKSTEMP
    if ( UncompressNamed(man_globals, input, filename) ) {
#else
    if ( UncompressNamed(man_globals, input, filename, file) ) {
#endif	
      man_globals->compress = TRUE;
      man_globals->gzip = TRUE;
      snprintf(man_globals->save_file, sizeof(man_globals->save_file),
	       "%s/%s%s/%s.%s", path, CAT, section + len_cat, page,
	       BZIP2_EXTENSION);
      return(TRUE);
a953 1
  }
d957 10
a966 13
  {
    snprintf(input, sizeof(input), "%s.%s", filename, LZMA_EXTENSION);
#ifndef HAS_MKSTEMP
    if ( UncompressNamed(man_globals, input, filename) ) {
#else
    if ( UncompressNamed(man_globals, input, filename, file) ) {
#endif	
      man_globals->compress = TRUE;
      man_globals->lzma = TRUE;
      snprintf(man_globals->save_file, sizeof(man_globals->save_file),
	       "%s/%s%s/%s.%s", path, CAT, section + len_cat, page,
	       LZMA_EXTENSION);
      return(TRUE);
a967 1
  }
d974 11
a984 15
  snprintf(input, sizeof(input), "%s/%s%s.%s/%s", path,
	  MAN, section + len_man, COMPRESSION_EXTENSION, page);
#ifndef HAS_MKSTEMP
  if ( UncompressNamed(man_globals, input, filename) ) {
#else
  if ( UncompressNamed(man_globals, input, filename, file) ) {
#endif
    man_globals->compress = TRUE;
    man_globals->deletetempfile = TRUE;
    snprintf(man_globals->save_file, sizeof(man_globals->save_file),
	     "%s/%s%s.%s/%s", path, CAT, section + len_cat, 
    	     COMPRESSION_EXTENSION, page);
    return(TRUE);
  }
  return(FALSE);
d997 20
a1016 19
  XColor colors[2];
  Arg args[10];
  Cardinal num_args = 0;
  Colormap c_map;

  if (!XtIsRealized(w)) {
    PopupWarning(NULL, "Widget is not realized, no cursor added.\n");
    return;
  }

  XtSetArg( args[num_args], XtNcolormap, &c_map); num_args++;
  XtGetValues( w, args, num_args);

  colors[0].pixel = resources.cursors.fg_color;
  colors[1].pixel = resources.cursors.bg_color;

  XQueryColors (XtDisplay(w), c_map, colors, 2);
  XRecolorCursor(XtDisplay(w), cursor, colors, colors+1);
  XDefineCursor(XtDisplay(w),XtWindow(w),cursor);
d1028 1
a1028 1
ChangeLabel(Widget w, char * str)
d1030 1
a1030 1
  Arg arglist[3];		/* An argument list. */
d1032 2
a1033 1
  if (w == NULL) return;
d1035 1
a1035 1
  XtSetArg(arglist[0], XtNlabel, str);
d1038 2
a1039 2
  XtSetArg(arglist[1], XtNwidth, 0);
  XtSetArg(arglist[2], XtNheight, 0);
d1041 1
a1041 1
  XtSetValues(w, arglist, (Cardinal) 1);
d1052 1
a1052 1
 *	Arguments: widget - the widget widget to postion
d1064 2
a1065 1
PositionCenter(Widget widget, int x, int y, int above, int left, int v_space, int h_space)
d1067 4
a1070 4
  Arg wargs[2];
  int x_temp,y_temp;		/* location of the new window. */
  int parent_height,parent_width; /* Height and width of the parent widget or
				   the root window if it has no parent. */
d1072 2
a1073 2
  x_temp = x - left - Width(widget) / 2 + BorderWidth(widget);
  y_temp = y - above -  Height(widget) / 2 + BorderWidth(widget);
d1075 2
a1076 2
  parent_height = HeightOfScreen(XtScreen(widget));
  parent_width = WidthOfScreen(XtScreen(widget));
d1083 14
a1096 14
  if (x_temp < h_space)
    x_temp = v_space;
  if (y_temp < v_space)
    (y_temp = 2);

  if ( y_temp + Height(widget) + v_space > parent_height )
      y_temp = parent_height - Height(widget) - v_space;

  if ( x_temp + Width(widget) + h_space > parent_width )
      x_temp = parent_width - Width(widget) - h_space;

  XtSetArg(wargs[0], XtNx, x_temp);
  XtSetArg(wargs[1], XtNy, y_temp);
  XtSetValues(widget, wargs, 2);
d1109 1
a1109 1
ParseEntry(char *entry, char *path, char *sect, char *page)
d1111 1
a1111 1
  char *c, temp[BUFSIZ];
d1113 1
a1113 1
  strcpy(temp, entry);
d1115 11
a1125 11
  c = rindex(temp, '/');
  if (c == NULL)
    PrintError("index failure in ParseEntry.");
  *c++ = '\0';
  if (page != NULL)
    strcpy(page, c);

  c = rindex(temp, '/');
  if (c == NULL)
    PrintError("index failure in ParseEntry.");
  *c++ = '\0';
d1127 8
a1134 8
  /* sgmltoroff sometimes puts an extra ./ in the path to .so entries */
  if (strcmp(c, ".") == 0) {
      c = rindex(temp, '/');
      if (c == NULL)
	  PrintError("index failure in ParseEntry.");
      *c++ = '\0';
  }
#endif      
d1136 7
a1142 7
  /* Skip machine subdirectory if present */
  if (strcmp(c, MACHINE) == 0) {
      c = rindex(temp, '/');
      if (c == NULL)
	  PrintError("index failure in ParseEntry.");
      *c++ = '\0';
  }
d1144 2
a1145 2
  if (sect != NULL)
    strcpy(sect, c);
d1147 2
a1148 2
  if (path != NULL)
    strcpy(path, temp);
d1152 1
a1152 1
 *      Description: Gets the psuedo globals associated with the
d1155 1
a1155 1
 *      Returns: the psuedo globals.
d1163 2
a1164 2
  Widget temp;
  caddr_t data;
d1166 2
a1167 2
  while ( (temp = XtParent(w)) != initial_widget && (temp != NULL))
    w = temp;
d1169 8
a1176 8
  if (temp == NULL)
    XtAppError(XtWidgetToApplicationContext(w),
	       "Xman: Could not locate widget in tree, exiting");

  if (XFindContext(XtDisplay(w), XtWindow(w),
		   manglobals_context, &data) != XCSUCCESS)
    XtAppError(XtWidgetToApplicationContext(w),
	       "Xman: Could not find global data, exiting");
d1178 1
a1178 1
  return( (ManpageGlobals *) data);
d1182 1
a1182 1
 *      Description: Saves the psuedo globals on the widget passed
d1195 4
a1198 4
  if (XSaveContext(XtDisplay(w), XtWindow(w), manglobals_context,
		   (caddr_t) globals) != XCSUCCESS)
    XtAppError(XtWidgetToApplicationContext(w),
	       "Xman: Could not save global data, are you out of memory?");
d1202 1
a1202 1
 *      Description: Removes the psuedo globals from the widget passed
d1213 4
a1216 4
  if (XDeleteContext(XtDisplay(w), XtWindow(w),
		     manglobals_context) != XCSUCCESS)
    XtAppError(XtWidgetToApplicationContext(w),
	       "Xman: Could not remove global data?");
@


1.2
log
@Update to xman 1.1.0
@
text
@d93 1
a93 1
PopupWarning(ManpageGlobals * man_globals, char * string)
d266 1
a266 1
    sprintf(filename, "%s/%s%s/%s.%s", path, CAT,
d274 1
a274 1
    sprintf(filename, "%s/%s%s/%s.%s", path, CAT,
d323 1
a323 1
  char tmp_file[BUFSIZ], error_buf[BUFSIZ];
d331 2
a332 3
      sprintf(error_buf, "Something went wrong in retrieving the %s",
	      "uncompressed manual page try cleaning up /tmp.");
      PopupWarning(man_globals, error_buf);
d336 2
a337 3
      sprintf(error_buf, "Something went wrong in retrieving the %s",
	      "uncompressed manual page try cleaning up /tmp.");
      PopupWarning(man_globals, error_buf);
d407 1
a407 1
    sprintf(cmdbuf, BUNZIP2_FORMAT, filename, output);
d413 1
a413 1
    sprintf(cmdbuf, UNLZMA_FORMAT, filename, output);
d584 1
a584 2
     sprintf(error_buf, "Constructed command was too long!");
     PopupWarning(man_globals, error_buf);
d599 2
a600 3
      sprintf(error_buf, "Something went wrong in retrieving the %s",
	      "temp file, try cleaning up /tmp");
      PopupWarning(man_globals, error_buf);
d696 1
a696 1
   char *fname = NULL;
d711 1
a711 1
         fname = filename;
d713 1
a713 4
         fname = malloc(strlen(path) + 1 + strlen(filename) + 1);
         if (!fname)
            return FALSE;
         sprintf(fname, "%s/%s", path, filename);
a726 2
      if (fname && fname != filename)
         free(fname);
d890 1
a890 1
    sprintf(input, "%s.%s", filename, BZIP2_EXTENSION);
d899 3
a901 2
      sprintf(man_globals->save_file, "%s/%s%s/%s.%s", path,
	      CAT, section + len_cat, page, BZIP2_EXTENSION);
d909 1
a909 1
    sprintf(input, "%s.%s", filename, LZMA_EXTENSION);
d918 3
a920 2
      sprintf(man_globals->save_file, "%s/%s%s/%s.%s", path,
	      CAT, section + len_cat, page, LZMA_EXTENSION);
d998 1
a998 1
    sprintf(input, "%s.%s", filename, BZIP2_EXTENSION);
d1006 3
a1008 2
      sprintf(man_globals->save_file, "%s/%s%s/%s.%s", path,
	      CAT, section + len_cat, page, BZIP2_EXTENSION);
d1016 1
a1016 1
    sprintf(input, "%s.%s", filename, LZMA_EXTENSION);
d1024 3
a1026 2
      sprintf(man_globals->save_file, "%s/%s%s/%s.%s", path,
	      CAT, section + len_cat, page, LZMA_EXTENSION);
@


1.1
log
@Initial revision
@
text
@d2 1
a2 1
/* $XdotOrg: app/xman/misc.c,v 1.8 2005/11/08 06:33:33 jkj Exp $ */
a83 1
extern Widget top;
d257 23
d406 12
d844 3
d896 37
d1002 35
@


1.1.1.1
log
@Importing from X.Org 7.2RC2
@
text
@@


1.1.1.2
log
@xman 1.0.3
@
text
@d2 1
a2 1
/* $XdotOrg: xc/programs/xman/misc.c,v 1.6 2004/09/02 08:40:33 kem Exp $ */
@

