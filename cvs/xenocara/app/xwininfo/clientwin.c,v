head	1.3;
access;
symbols
	OPENBSD_6_1:1.3.0.26
	OPENBSD_6_1_BASE:1.3
	OPENBSD_6_0:1.3.0.24
	OPENBSD_6_0_BASE:1.3
	OPENBSD_5_9:1.3.0.22
	OPENBSD_5_9_BASE:1.3
	OPENBSD_5_8:1.3.0.20
	OPENBSD_5_8_BASE:1.3
	OPENBSD_5_7:1.3.0.18
	OPENBSD_5_7_BASE:1.3
	OPENBSD_5_6:1.3.0.16
	OPENBSD_5_6_BASE:1.3
	OPENBSD_5_5:1.3.0.14
	OPENBSD_5_5_BASE:1.3
	OPENBSD_5_4:1.3.0.12
	OPENBSD_5_4_BASE:1.3
	OPENBSD_5_3:1.3.0.10
	OPENBSD_5_3_BASE:1.3
	OPENBSD_5_2:1.3.0.8
	OPENBSD_5_2_BASE:1.3
	OPENBSD_5_1_BASE:1.3
	OPENBSD_5_1:1.3.0.6
	OPENBSD_5_0:1.3.0.4
	OPENBSD_5_0_BASE:1.3
	OPENBSD_4_9:1.3.0.2
	OPENBSD_4_9_BASE:1.3
	OPENBSD_4_8:1.2.0.6
	OPENBSD_4_8_BASE:1.2
	OPENBSD_4_7:1.2.0.2
	OPENBSD_4_7_BASE:1.2
	OPENBSD_4_6:1.1.0.4
	OPENBSD_4_6_BASE:1.1
	OPENBSD_4_5:1.1.0.2
	OPENBSD_4_5_BASE:1.1;
locks; strict;
comment	@ * @;


1.3
date	2010.11.25.21.55.09;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2009.10.24.15.37.50;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2008.08.27.19.30.04;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.3
log
@Update to xwininfo 1.1.1. rewritten to use XCB.
@
text
@/*
 * Copyright 2007 Kim woelders
 *
 * Permission to use, copy, modify, distribute, and sell this software and its
 * documentation for any purpose is hereby granted without fee, provided that
 * the above copyright notice appear in all copies and that both that copyright
 * notice and this permission notice appear in supporting documentation, and
 * that the name of the copyright holders not be used in advertising or
 * publicity pertaining to distribution of the software without specific,
 * written prior permission.  The copyright holders make no representations
 * about the suitability of this software for any purpose.  It is provided "as
 * is" without express or implied warranty.
 *
 * THE COPYRIGHT HOLDERS DISCLAIM ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
 * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO
 * EVENT SHALL THE COPYRIGHT HOLDERS BE LIABLE FOR ANY SPECIAL, INDIRECT OR
 * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
 * DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
 * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE
 * OF THIS SOFTWARE.
 */
#include <xcb/xcb.h>
#include <xcb/xproto.h>

#include <stdlib.h>
#include <string.h>

#include "clientwin.h"
#include "dsimple.h"

static xcb_atom_t atom_wm_state = XCB_ATOM_NONE;

/*
 * Check if window has given property
 */
static Bool
Window_Has_Property(xcb_connection_t * dpy, xcb_window_t win, xcb_atom_t atom)
{
    xcb_get_property_cookie_t prop_cookie;
    xcb_get_property_reply_t *prop_reply;

    prop_cookie = xcb_get_property (dpy, False, win, atom,
                                    XCB_GET_PROPERTY_TYPE_ANY, 0, 0);

    prop_reply = xcb_get_property_reply (dpy, prop_cookie, NULL);

    if (prop_reply) {
        xcb_atom_t reply_type = prop_reply->type;
        free (prop_reply);
        if (reply_type != XCB_NONE)
            return True;
    }

    return False;
}

/*
 * Check if window is viewable
 */
static Bool
Window_Is_Viewable(xcb_connection_t * dpy, xcb_window_t win)
{
    Bool ok = False;
    xcb_get_window_attributes_cookie_t attr_cookie;
    xcb_get_window_attributes_reply_t *xwa;

    attr_cookie = xcb_get_window_attributes (dpy, win);
    xwa = xcb_get_window_attributes_reply (dpy, attr_cookie, NULL);

    if (xwa) {
        ok = (xwa->_class == XCB_WINDOW_CLASS_INPUT_OUTPUT) &&
            (xwa->map_state == XCB_MAP_STATE_VIEWABLE);
        free (xwa);
    }

    return ok;
}

/*
 * Find a window that has WM_STATE set in the window tree below win.
 * Unmapped/unviewable windows are not considered valid matches.
 * Children are searched in top-down stacking order.
 * The first matching window is returned, None if no match is found.
 */
static xcb_window_t
Find_Client_In_Children(xcb_connection_t * dpy, xcb_window_t win)
{
    xcb_query_tree_cookie_t qt_cookie;
    xcb_query_tree_reply_t *tree;
    xcb_window_t *children;
    unsigned int n_children;
    int i;

    qt_cookie = xcb_query_tree (dpy, win);
    tree = xcb_query_tree_reply (dpy, qt_cookie, NULL);
    if (!tree)
        return XCB_WINDOW_NONE;
    n_children = xcb_query_tree_children_length (tree);
    if (!n_children) {
        free (tree);
        return XCB_WINDOW_NONE;
    }
    children = xcb_query_tree_children (tree);

    /* Check each child for WM_STATE and other validity */
    win = XCB_WINDOW_NONE;
    for (i = (int) n_children - 1; i >= 0; i--) {
        if (!Window_Is_Viewable(dpy, children[i])) {
            /* Don't bother descending into this one */
            children[i] = XCB_WINDOW_NONE;
            continue;
        }
        if (!Window_Has_Property(dpy, children[i], atom_wm_state))
            continue;

        /* Got one */
        win = children[i];
        goto done;
    }

    /* No children matched, now descend into each child */
    for (i = (int) n_children - 1; i >= 0; i--) {
        if (children[i] == XCB_WINDOW_NONE)
            continue;
        win = Find_Client_In_Children(dpy, children[i]);
        if (win != XCB_WINDOW_NONE)
            break;
    }

  done:
    free (tree); /* includes children */

    return win;
}

/*
 * Find virtual roots (_NET_VIRTUAL_ROOTS)
 */
static xcb_window_t *
Find_Roots(xcb_connection_t * dpy, xcb_window_t root, unsigned int *num)
{
    xcb_atom_t atom_virtual_root;

    xcb_get_property_cookie_t prop_cookie;
    xcb_get_property_reply_t *prop_reply;

    xcb_window_t *prop_ret = NULL;

    *num = 0;

    atom_virtual_root = Get_Atom (dpy, "_NET_VIRTUAL_ROOTS");
    if (atom_virtual_root == XCB_ATOM_NONE)
        return NULL;

    prop_cookie = xcb_get_property (dpy, False, root, atom_virtual_root,
                                    XCB_ATOM_WINDOW, 0, 0x7fffffff);
    prop_reply = xcb_get_property_reply (dpy, prop_cookie, NULL);
    if (!prop_reply)
        return NULL;

    if ((prop_reply->value_len > 0) && (prop_reply->type == XCB_ATOM_WINDOW)
        && (prop_reply->format == 32)) {
        int length = xcb_get_property_value_length (prop_reply);
        prop_ret = malloc(length);
        if (prop_ret) {
            memcpy (prop_ret, xcb_get_property_value(prop_reply), length);
            *num = prop_reply->value_len;
        }
    }
    free (prop_reply);

    return prop_ret;
}

/*
 * Find child window at pointer location
 */
static xcb_window_t
Find_Child_At_Pointer(xcb_connection_t * dpy, xcb_window_t win)
{
    xcb_window_t child_return = XCB_WINDOW_NONE;

    xcb_query_pointer_cookie_t qp_cookie;
    xcb_query_pointer_reply_t *qp_reply;

    qp_cookie = xcb_query_pointer (dpy, win);
    qp_reply = xcb_query_pointer_reply (dpy, qp_cookie, NULL);

    if (qp_reply) {
        child_return = qp_reply->child;
        free (qp_reply);
    }

    return child_return;
}

/*
 * Find client window at pointer location
 *
 * root   is the root window.
 * subwin is the subwindow reported by a ButtonPress event on root.
 *
 * If the WM uses virtual roots subwin may be a virtual root.
 * If so, we descend the window stack at the pointer location and assume the
 * child is the client or one of its WM frame windows.
 * This will of course work only if the virtual roots are children of the real
 * root.
 */
xcb_window_t
Find_Client(xcb_connection_t * dpy, xcb_window_t root, xcb_window_t subwin)
{
    xcb_window_t *roots;
    unsigned int i, n_roots;
    xcb_window_t win;

    /* Check if subwin is a virtual root */
    roots = Find_Roots(dpy, root, &n_roots);
    for (i = 0; i < n_roots; i++) {
        if (subwin != roots[i])
            continue;
        win = Find_Child_At_Pointer(dpy, subwin);
        if (win == XCB_WINDOW_NONE)
            return subwin;      /* No child - Return virtual root. */
        subwin = win;
        break;
    }
    free (roots);

    if (atom_wm_state == XCB_ATOM_NONE) {
        atom_wm_state = Get_Atom(dpy, "WM_STATE");
        if (atom_wm_state == XCB_ATOM_NONE)
            return subwin;
    }

    /* Check if subwin has WM_STATE */
    if (Window_Has_Property(dpy, subwin, atom_wm_state))
        return subwin;

    /* Attempt to find a client window in subwin's children */
    win = Find_Client_In_Children(dpy, subwin);
    if (win != XCB_WINDOW_NONE)
        return win;             /* Found a client */

    /* Did not find a client */
    return subwin;
}
@


1.2
log
@Update to xwininfo 1.0.5
@
text
@d22 5
a26 2
#include <X11/Xatom.h>
#include <X11/Xlib.h>
d29 1
d31 1
a31 1
static Atom atom_wm_state = None;
d37 1
a37 1
Window_Has_Property(Display * dpy, Window win, Atom atom)
d39 14
a52 12
    Atom type_ret;
    int format_ret;
    unsigned char *prop_ret;
    unsigned long bytes_after, num_ret;

    type_ret = None;
    prop_ret = NULL;
    XGetWindowProperty(dpy, win, atom, 0, 0, False, AnyPropertyType,
                       &type_ret, &format_ret, &num_ret,
                       &bytes_after, &prop_ret);
    if (prop_ret)
        XFree(prop_ret);
d54 1
a54 1
    return (type_ret != None) ? True : False;
d61 1
a61 1
Window_Is_Viewable(Display * dpy, Window win)
d63 12
a74 6
    Bool ok;
    XWindowAttributes xwa;

    XGetWindowAttributes(dpy, win, &xwa);

    ok = (xwa.class == InputOutput) && (xwa.map_state == IsViewable);
d85 2
a86 2
static Window
Find_Client_In_Children(Display * dpy, Window win)
d88 3
a90 2
    Window root, parent;
    Window *children;
d94 10
a103 4
    if (!XQueryTree(dpy, win, &root, &parent, &children, &n_children))
        return None;
    if (!children)
        return None;
d106 1
a106 1
    win = None;
d109 2
a110 1
            children[i] = None; /* Don't bother descending into this one */
d123 1
a123 1
        if (children[i] == None)
d126 1
a126 1
        if (win != None)
d131 1
a131 1
    XFree(children);
d139 2
a140 2
static unsigned long *
Find_Roots(Display * dpy, Window root, unsigned int *num)
d142 6
a147 5
    Atom type_ret;
    int format_ret;
    unsigned char *prop_ret;
    unsigned long bytes_after, num_ret;
    Atom atom;
d150 3
a152 2
    atom = XInternAtom(dpy, "_NET_VIRTUAL_ROOTS", False);
    if (!atom)
d155 4
a158 5
    type_ret = None;
    prop_ret = NULL;
    if (XGetWindowProperty(dpy, root, atom, 0, 0x7fffffff, False,
                           XA_WINDOW, &type_ret, &format_ret, &num_ret,
                           &bytes_after, &prop_ret) != Success)
d161 8
a168 3
    if (prop_ret && type_ret == XA_WINDOW && format_ret == 32) {
        *num = num_ret;
        return ((unsigned long *) prop_ret);
d170 1
a170 2
    if (prop_ret)
        XFree(prop_ret);
d172 1
a172 1
    return NULL;
d178 2
a179 2
static Window
Find_Child_At_Pointer(Display * dpy, Window win)
d181 4
a184 3
    Window root_return, child_return;
    int dummyi;
    unsigned int dummyu;
d186 7
a192 2
    XQueryPointer(dpy, win, &root_return, &child_return,
                  &dummyi, &dummyi, &dummyi, &dummyi, &dummyu);
d209 2
a210 2
Window
Find_Client(Display * dpy, Window root, Window subwin)
d212 1
a212 1
    unsigned long *roots;
d214 1
a214 1
    Window win;
d222 1
a222 1
        if (win == None)
d227 1
a227 2
    if (roots)
        XFree(roots);
d229 3
a231 3
    if (atom_wm_state == None) {
        atom_wm_state = XInternAtom(dpy, "WM_STATE", False);
        if (!atom_wm_state)
d241 1
a241 1
    if (win != None)
@


1.1
log
@xwininfo 1.0.4
@
text
@d25 2
d73 1
a73 1
Window
d119 1
a119 1
unsigned long *
@

