head	1.7;
access;
symbols
	OPENBSD_6_1_BASE:1.7
	OPENBSD_6_0:1.6.0.12
	OPENBSD_6_0_BASE:1.6
	OPENBSD_5_9:1.6.0.10
	OPENBSD_5_9_BASE:1.6
	OPENBSD_5_8:1.6.0.8
	OPENBSD_5_8_BASE:1.6
	OPENBSD_5_7:1.6.0.6
	OPENBSD_5_7_BASE:1.6
	OPENBSD_5_6:1.6.0.4
	OPENBSD_5_6_BASE:1.6
	OPENBSD_5_5:1.6.0.2
	OPENBSD_5_5_BASE:1.6
	OPENBSD_5_4:1.5.0.6
	OPENBSD_5_4_BASE:1.5
	OPENBSD_5_3:1.5.0.4
	OPENBSD_5_3_BASE:1.5
	OPENBSD_5_2:1.5.0.2
	OPENBSD_5_2_BASE:1.5
	OPENBSD_5_1_BASE:1.4
	OPENBSD_5_1:1.4.0.4
	OPENBSD_5_0:1.4.0.2
	OPENBSD_5_0_BASE:1.4
	OPENBSD_4_9:1.3.0.2
	OPENBSD_4_9_BASE:1.3
	OPENBSD_4_8:1.2.0.8
	OPENBSD_4_8_BASE:1.2
	OPENBSD_4_7:1.2.0.4
	OPENBSD_4_7_BASE:1.2
	OPENBSD_4_6:1.2.0.2
	OPENBSD_4_6_BASE:1.2
	OPENBSD_4_5:1.1.1.2.0.8
	OPENBSD_4_5_BASE:1.1.1.2
	OPENBSD_4_4:1.1.1.2.0.6
	OPENBSD_4_4_BASE:1.1.1.2
	OPENBSD_4_3_BASE:1.1.1.2
	OPENBSD_4_3:1.1.1.2.0.4
	OPENBSD_4_2:1.1.1.2.0.2
	OPENBSD_4_2_BASE:1.1.1.2
	v1_0_2:1.1.1.2
	v1_0_1:1.1.1.1
	xorg:1.1.1;
locks; strict;
comment	@ * @;


1.7
date	2017.02.19.17.30.58;	author matthieu;	state Exp;
branches;
next	1.6;
commitid	2nyW4v2tZVEzTEHM;

1.6
date	2014.01.04.15.53.46;	author matthieu;	state Exp;
branches;
next	1.5;

1.5
date	2012.04.07.15.39.35;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2011.05.31.20.47.24;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2010.10.06.05.56.15;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2009.03.08.09.35.07;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.25.20.24.10;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.11.25.20.24.10;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2006.12.16.21.17.35;	author matthieu;	state Exp;
branches
	1.1.1.2.8.1;
next	;

1.1.1.2.8.1
date	2009.05.01.07.37.21;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.7
log
@Update to xauth 1.0.10
@
text
@/*
 *
Copyright 1989, 1998  The Open Group

Permission to use, copy, modify, distribute, and sell this software and its
documentation for any purpose is hereby granted without fee, provided that
the above copyright notice appear in all copies and that both that
copyright notice and this permission notice appear in supporting
documentation.

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
OPEN GROUP BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

Except as contained in this notice, the name of The Open Group shall not be
used in advertising or otherwise to promote the sale, use or other dealings
in this Software without prior written authorization from The Open Group.
 * *
 * Author:  Jim Fulton, MIT X Consortium
 */

#ifdef HAVE_CONFIG_H
#include "config.h"
#endif

#ifdef WIN32
#include <X11/Xwinsock.h>
#define EPROTOTYPE WSAEPROTOTYPE
#endif
#include <X11/X.h>
#include <signal.h>
#include <setjmp.h>
#include <ctype.h>
#ifndef __TYPES__
#include <sys/types.h>
#define __TYPES__
#endif
#ifndef WIN32
#ifndef Lynx
#include <sys/socket.h>
#else
#include <socket.h>
#endif
#include <netdb.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#ifdef HAVE_NET_ERRNO_H
#include <net/errno.h>
#endif /* HAVE_NET_ERRNO_H */
#endif /* !WIN32 */
#include <errno.h>
#include "xauth.h"

#include <sys/stat.h>
#include <limits.h>

#ifndef WIN32
#include <arpa/inet.h>
#endif

const char *
get_hostname (Xauth *auth)
{
#ifdef TCPCONN
    static struct hostent *hp;
    int af;

    hp = NULL;
#endif

    if (auth->address_length == 0)
	return "Illegal Address";
#ifdef TCPCONN
    if (auth->family == FamilyInternet
#if defined(IPv6) && defined(AF_INET6)
      || auth->family == FamilyInternet6
#endif
	)
    {
#if defined(IPv6) && defined(AF_INET6)
	if (auth->family == FamilyInternet6)
	    af = AF_INET6;
	else
#endif
	    af = AF_INET;
	if (no_name_lookups == False) {
	    hp = gethostbyaddr (auth->address, auth->address_length, af);
	}
	if (hp)
	  return (hp->h_name);
#if defined(IPv6) && defined(AF_INET6)
	else if (af == AF_INET6) {
	  static char addr[INET6_ADDRSTRLEN+2];
	  /* Add [] for clarity to distinguish between address & display,
	     like RFC 2732 for URL's.  Not required, since X display syntax
	     always ends in :<display>, but makes it easier for people to read
	     and less confusing to those who expect the RFC 2732 style. */
	  addr[0] = '[';
	  if (inet_ntop(af, auth->address, addr + 1, INET6_ADDRSTRLEN) == NULL)
	    return NULL;
	  strcat(addr, "]");
          return addr;
	}
#endif
	else {
	  return (inet_ntoa(*((struct in_addr *)(auth->address))));
	}
    }
#endif

    return (NULL);
}

#if defined(TCPCONN) && (!defined(IPv6) || !defined(AF_INET6))
/*
 * cribbed from lib/X/XConnDis.c
 */
static Bool
get_inet_address(char *name, unsigned int *resultp)
{
    unsigned int hostinetaddr = inet_addr (name);
    struct hostent *host_ptr;
    struct sockaddr_in inaddr;		/* dummy variable for size calcs */

#ifndef INADDR_NONE
#define INADDR_NONE -1
#endif

    if (hostinetaddr == INADDR_NONE) {
	if ((host_ptr = gethostbyname (name)) == NULL) {
	    /* No such host! */
	    errno = EINVAL;
	    return False;
	}
	/* Check the address type for an internet host. */
	if (host_ptr->h_addrtype != AF_INET) {
	    /* Not an Internet host! */
	    errno = EPROTOTYPE;
	    return False;
	}

	memmove( (char *)&hostinetaddr, (char *)host_ptr->h_addr,
	      sizeof(inaddr.sin_addr));
    }
    *resultp = hostinetaddr;
    return True;
}
#endif


struct addrlist *get_address_info (
    int family,
    const char *fulldpyname,
    int prefix,
    char *host)
{
    struct addrlist *retval = NULL;
    int len = 0;
    const void *src = NULL;
#ifdef TCPCONN
#if defined(IPv6) && defined(AF_INET6)
    struct addrlist *lastrv = NULL;
    struct addrinfo *firstai = NULL;
    struct addrinfo *ai = NULL;
    struct addrinfo hints;
#else
    unsigned int hostinetaddr;
#endif
#endif
    char buf[255];

    /*
     * based on the family, set the pointer src to the start of the address
     * information to be copied and set len to the number of bytes.
     */
    switch (family) {
      case FamilyLocal:			/* hostname/unix:0 */
					/* handle unix:0 and :0 specially */
	if (prefix == 0 && (strncmp (fulldpyname, "unix:", 5) == 0 ||
			    fulldpyname[0] == ':')) {

	    if (!get_local_hostname (buf, sizeof buf)) {
		len = 0;
	    } else {
		src = buf;
		len = strlen (buf);
	    }
	} else {
	    char path[PATH_MAX];
	    struct stat sbuf;
	    int is_path_to_socket = 0;

#ifdef HAVE_STRLCPY
	    strlcpy(path, fulldpyname, sizeof(path));
#else
	    strncpy(path, fulldpyname, sizeof(path));
	    path[sizeof(path) - 1] = '\0';
#endif
	    if (0 == stat(path, &sbuf)) {
		is_path_to_socket = 1;
	    } else {
		char *dot = strrchr(path, '.');
		if (dot) {
		    *dot = '\0';
		    /* screen = atoi(dot + 1); */
		    if (0 == stat(path, &sbuf)) {
		        is_path_to_socket = 1;
		    }
		}
	    }

	    if (is_path_to_socket) {
		/* Use the bundle id (part preceding : in the basename) as our src id */
		char *c;
#ifdef HAVE_STRLCPY
		strlcpy(buf, strrchr(fulldpyname, '/') + 1, sizeof(buf));
#else
		strncpy(buf, strrchr(fulldpyname, '/') + 1, sizeof(buf));
		buf[sizeof(buf) - 1] = '\0';
#endif

		c = strchr(buf, ':');

		/* In the legacy case with no bundle id, use the full path */
		if(c == buf) {
			src = fulldpyname;
		} else {
			*c = '\0';
			src = buf;
		}

		len = strlen(src);
	    } else {
		src = fulldpyname;
		len = prefix;
            }
	}
	break;
      case FamilyInternet:		/* host:0 */
#ifdef TCPCONN
#if defined(IPv6) && defined(AF_INET6)
      case FamilyInternet6:
	memset(&hints, 0, sizeof(hints));
	hints.ai_family = PF_UNSPEC; /* IPv4 or IPv6 */
	hints.ai_socktype = SOCK_STREAM; /* only interested in TCP */
	hints.ai_protocol = 0;
        if (getaddrinfo(host,NULL,&hints,&firstai) !=0) return NULL;
	for (ai = firstai; ai != NULL; ai = ai->ai_next) {
	    struct addrlist *duplicate;

            len = 0;
	    if (ai->ai_family == AF_INET) {
		struct sockaddr_in *sin = (struct sockaddr_in *)ai->ai_addr;
		src = &(sin->sin_addr);
                if (*(const in_addr_t *) src == htonl(INADDR_LOOPBACK)) {
                    family = FamilyLocal;
                    if (get_local_hostname (buf, sizeof buf)) {
                        src = buf;
                        len = strlen (buf);
                    } else
                        src = NULL;
                } else {
                    len = sizeof(sin->sin_addr);
                    family = FamilyInternet;
                }
	    } else if (ai->ai_family == AF_INET6) {
		struct sockaddr_in6 *sin6 = (struct sockaddr_in6 *)ai->ai_addr;
		src = &(sin6->sin6_addr);
                if (!IN6_IS_ADDR_V4MAPPED((const struct in6_addr *)src)) {
                    if (IN6_IS_ADDR_LOOPBACK((const struct in6_addr *)src)) {
                        family = FamilyLocal;
                        if (get_local_hostname (buf, sizeof buf)) {
                            src = buf;
                            len = strlen (buf);
                        } else
                            src = NULL;
                    } else {
                        len = sizeof(sin6->sin6_addr);
                        family = FamilyInternet6;
                    }
                } else {
                    src = &(sin6->sin6_addr.s6_addr[12]);
                    len = sizeof(((struct sockaddr_in *)
                                  ai->ai_addr)->sin_addr);
                    family = FamilyInternet;
                }
	    }

	    for(duplicate = retval; duplicate != NULL; duplicate = duplicate->next) {
		if(duplicate->family == family && duplicate->len == len &&
                   memcmp(duplicate->address, src, len) == 0) {
		    break;
                }
	    }

	    if (len > 0 && src != NULL && duplicate == NULL) {
		struct addrlist *newrv = malloc (sizeof(struct addrlist));
		if (newrv) {
		    newrv->address = malloc (len);
		    if (newrv->address) {
			memcpy(newrv->address, src, len);
			newrv->next = NULL;
			newrv->family = family;
			newrv->len = len;
			if (retval == NULL) {
			    lastrv = retval = newrv;
			} else {
			    lastrv->next = newrv;
			    lastrv = newrv;
			}
		    } else {
			free(newrv);
		    }
		}
	    }
	    /* reset to avoid copying into list twice */
	    len = 0;
	    src = NULL;
	}
	freeaddrinfo(firstai);
	break;
#else
	if (!get_inet_address (host, &hostinetaddr)) return NULL;
	src = (char *) &hostinetaddr;
        if (*(const in_addr_t *) src == htonl(INADDR_LOOPBACK)) {
            family = FamilyLocal;
            if (get_local_hostname (buf, sizeof buf)) {
                src = buf;
                len = strlen (buf);
            } else {
                len = 0;
                src = NULL;
            }
        } else
            len = 4; /* sizeof inaddr.sin_addr, would fail on Cray */
	break;
#endif /* IPv6 */
#else
	return NULL;
#endif
      case FamilyDECnet:		/* host::0 */
	/* fall through since we don't have code for it */
      default:
	src = NULL;
	len = 0;
    }

    /*
     * if source was provided, allocate space and copy it
     */
    if (len > 0 && src != NULL) {
	retval = malloc (sizeof(struct addrlist));
	if (retval) {
	    retval->address = malloc (len);
	    if (retval->address) {
		memcpy(retval->address, src, len);
		retval->next = NULL;
		retval->family = family;
		retval->len = len;
	    } else {
		free(retval);
		retval = NULL;
	    }
	}
    }
    return retval;
}
@


1.6
log
@Update to xauth 1.0.8
@
text
@d60 2
d194 5
a198 3
	} else if(prefix == 0 && (strncmp (fulldpyname, "/tmp/launch", 11) == 0)) {
        /* Use the bundle id (part preceding : in the basename) as our src id */
        char *c;
d200 1
a200 1
        strlcpy(buf, strrchr(fulldpyname, '/') + 1, sizeof(buf));
d202 2
a203 2
        strncpy(buf, strrchr(fulldpyname, '/') + 1, sizeof(buf));
	buf[sizeof(buf) - 1] = '\0';
d205 12
d218 11
a228 1
        c = strchr(buf, ':');
d230 13
a242 12
        /* In the legacy case with no bundle id, use the full path */
        if(c == buf) {
            src = fulldpyname;
        } else {
            *c = '\0';
            src = buf;
        }

        len = strlen(src);
    } else {
	    src = fulldpyname;
	    len = prefix;
@


1.5
log
@Update to xauth 1.0.7
@
text
@a31 6
/* sorry, streams support does not really work yet */
#if defined(STREAMSCONN) && defined(SVR4)
#undef STREAMSCONN
#define TCPCONN
#endif

a44 1
#ifndef STREAMSCONN
a55 1
#endif /* !STREAMSCONN */
a59 4
#ifdef DNETCONN
#include <netdnet/dn.h>
#include <netdnet/dnetdb.h>
#endif
d68 1
a70 4
#ifdef DNETCONN
    struct nodeent *np;
    static char nodeaddr[4 + 2 * DN_MAXADDL];
#endif /* DNETCONN */
d73 2
a113 13
#ifdef DNETCONN
    if (auth->family == FamilyDECnet) {
	struct dn_naddr *addr_ptr = (struct dn_naddr *) auth->address;

	if ((no_name_lookups == False) &&
	    (np = getnodebyaddr(addr_ptr->a_addr, addr_ptr->a_len, AF_DECnet))) {
	    sprintf(nodeaddr, "%s:", np->n_name);
	} else {
	    sprintf(nodeaddr, "%s:", dnet_htoa(auth->address));
	}
	return(nodeaddr);
    }
#endif
a153 19
#ifdef DNETCONN
static Bool get_dnet_address (name, resultp)
    char *name;
    struct dn_naddr *resultp;
{
    struct dn_naddr *dnaddrp, dnaddr;
    struct nodeent *np;

    if (dnaddrp = dnet_addr (name)) {	/* stolen from xhost */
	dnaddr = *dnaddrp;
    } else {
	if ((np = getnodebyname (name)) == NULL) return False;
	dnaddr.a_len = np->n_length;
	memmove( dnaddr.a_addr, np->n_addr, np->n_length);
    }
    *resultp = dnaddr;
    return True;
}
#endif
a173 3
#ifdef DNETCONN
    struct dn_naddr dnaddr;
#endif
d230 1
d234 11
a244 2
		len = sizeof(sin->sin_addr);
		family = FamilyInternet;
d248 18
a265 2
		len = sizeof(sin6->sin6_addr);
		family = FamilyInternet6;
d304 11
a314 1
	len = 4; /* sizeof inaddr.sin_addr, would fail on Cray */
a320 6
#ifdef DNETCONN
	if (!get_dnet_address (host, &dnaddr)) return NULL;
	src = (char *) &dnaddr;
	len = (sizeof dnaddr);
	break;
#else
a321 1
#endif
@


1.4
log
@Update to xauth 1.0.6
@
text
@d2 1
a2 1
 * 
d77 1
a77 24
#ifdef SIGALRM
static volatile Bool nameserver_timedout = False;


/*
 * get_hostname - Given an internet address, return a name (CHARON.MIT.EDU)
 * or a string representing the address (18.58.0.13) if the name cannot
 * be found.  Stolen from xhost.
 */

static jmp_buf env;
static RETSIGTYPE
nameserver_lost(int sig)
{
  nameserver_timedout = True;
  longjmp (env, -1);
  /* NOTREACHED */
#ifdef SIGNALRETURNSINT
  return -1;				/* for picky compilers */
#endif
}
#endif

char *
d94 1
a94 1
#endif 
a103 12
#ifdef SIGALRM
	/* gethostbyaddr can take a LONG time if the host does not exist.
	   Assume that if it does not respond in NAMESERVER_TIMEOUT seconds
	   that something is wrong and do not make the user wait.
	   gethostbyaddr will continue after a signal, so we have to
	   jump out of it. 
	   */
	nameserver_timedout = False;
	signal (SIGALRM, nameserver_lost);
	alarm (4);
	if (setjmp(env) == 0) {
#endif
a104 4
#ifdef SIGALRM
	}
	alarm (0);
#endif
d148 1
a148 1
static Bool 
d171 2
a172 2
 
	memmove( (char *)&hostinetaddr, (char *)host_ptr->h_addr, 
d202 1
a202 1
    char *fulldpyname,
d208 1
a208 1
    void *src = NULL;
d251 1
a251 1
        
d273 1
a273 1
	hints.ai_protocol = 0;	
@


1.3
log
@update to xauth 1.0.5
@
text
@a1 2
 * $Xorg: gethost.c,v 1.5 2001/02/09 02:05:38 xorgcvs Exp $
 * $XdotOrg: $
a26 2

/* $XFree86: xc/programs/xauth/gethost.c,v 3.20 2003/07/27 12:34:25 herrb Exp $ */
@


1.2
log
@Update to xauth 1.0.3 + fixes from git head. Partially addresses system/6097.
@
text
@d283 22
a304 1
	} else {
@


1.1
log
@Initial revision
@
text
@d64 1
a64 3
#ifdef SYSV
#ifdef i386
#if !defined(SCO325) && !defined(sun)
d66 1
a66 3
#endif /* !SCO325 && !sun */
#endif /* i386 */
#endif /* SYSV */
a90 9
/* defined by autoconf AC_TYPE_SIGNAL, need to define for Imake */
#ifndef RETSIGTYPE 
# ifdef SIGNALRETURNSINT
#  define RETSIGTYPE int
# else
#  define RETSIGTYPE void
# endif
#endif

d105 1
a105 2
get_hostname (auth)
    Xauth *auth;
d298 2
d312 8
a319 1
	    if (len > 0 && src != NULL) {
@


1.1.1.1
log
@Importing from X.Org 7.2RC2
@
text
@@


1.1.1.2
log
@xauth 1.0.2
@
text
@d64 3
a66 1
#ifdef HAVE_NET_ERRNO_H
d68 3
a70 1
#endif /* HAVE_NET_ERRNO_H */
d95 9
d118 2
a119 1
get_hostname (Xauth *auth)
@


1.1.1.2.8.1
log
@MFC: fix segfault if duplicate lines are found in /etc/hosts.
@
text
@a297 2
	    struct addrlist *duplicate;

d310 1
a310 8
	    for(duplicate = retval; duplicate != NULL; duplicate = duplicate->next) {
		if(duplicate->family == family && duplicate->len == len &&
                   memcmp(duplicate->address, src, len) == 0) {
		    break;
                }
	    }

	    if (len > 0 && src != NULL && duplicate == NULL) {
@


