head	1.2;
access;
symbols
	OPENBSD_5_4:1.1.0.8
	OPENBSD_5_4_BASE:1.1
	OPENBSD_5_3:1.1.0.6
	OPENBSD_5_3_BASE:1.1
	OPENBSD_5_2:1.1.0.4
	OPENBSD_5_2_BASE:1.1
	OPENBSD_5_1_BASE:1.1
	OPENBSD_5_1:1.1.0.2;
locks; strict;
comment	@ * @;


1.2
date	2014.02.15.13.55.29;	author matthieu;	state dead;
branches;
next	1.1;

1.1
date	2012.01.25.21.27.07;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.2
log
@Remove radeonold driver. it was deconnected from build  months ago.
@
text
@
#ifdef HAVE_CONFIG_H
#include "config.h"
#endif

/* Driver data structures */
#include "radeon.h"

/* Allocates memory, either by resizing the allocation pointed to by mem_struct,
 * or by freeing mem_struct (if non-NULL) and allocating a new space.  The size
 * is measured in bytes, and the offset from the beginning of card space is
 * returned.
 */
uint32_t
radeon_legacy_allocate_memory(ScrnInfoPtr pScrn,
		       void **mem_struct,
		       int size,
		       int align)
{
    ScreenPtr pScreen = screenInfo.screens[pScrn->scrnIndex];
    RADEONInfoPtr info = RADEONPTR(pScrn);
    uint32_t offset = 0;

#ifdef USE_EXA
    if (info->useEXA) {
	ExaOffscreenArea *area = *mem_struct;

	if (area != NULL) {
	    if (area->size >= size)
		return area->offset;

	    exaOffscreenFree(pScreen, area);
	}

	area = exaOffscreenAlloc(pScreen, size, align, TRUE,
				 NULL, NULL);

	*mem_struct = area;
	if (area == NULL)
	    return 0;
	offset = area->offset;
    }
#endif /* USE_EXA */
#ifdef USE_XAA
    if (!info->useEXA) {
	FBLinearPtr linear = *mem_struct;
	int cpp = info->CurrentLayout.bitsPerPixel / 8;

	/* XAA allocates in units of pixels at the screen bpp, so adjust size
	 * appropriately.
	 */
	size = (size + cpp - 1) / cpp;
	align = (align + cpp - 1) / cpp;

	if (linear) {
	    if(linear->size >= size)
		return linear->offset * cpp;

	    if(xf86ResizeOffscreenLinear(linear, size))
		return linear->offset * cpp;

	    xf86FreeOffscreenLinear(linear);
	}

	linear = xf86AllocateOffscreenLinear(pScreen, size, align,
					     NULL, NULL, NULL);
	*mem_struct = linear;

	if (!linear) {
	    int max_size;

	    xf86QueryLargestOffscreenLinear(pScreen, &max_size, align,
					    PRIORITY_EXTREME);

	    if (max_size < size)
		return 0;

	    xf86PurgeUnlockedOffscreenAreas(pScreen);
	    linear = xf86AllocateOffscreenLinear(pScreen, size, align,
						 NULL, NULL, NULL);
	    *mem_struct = linear;
	    if (!linear)
		return 0;
	}
	offset = linear->offset * cpp;
    }
#endif /* USE_XAA */

    return offset;
}

void
radeon_legacy_free_memory(ScrnInfoPtr pScrn,
		   void *mem_struct)
{
    RADEONInfoPtr info = RADEONPTR(pScrn);
#ifdef USE_EXA
    ScreenPtr pScreen = screenInfo.screens[pScrn->scrnIndex];

    if (info->useEXA) {
	ExaOffscreenArea *area = mem_struct;

	if (area != NULL)
	    exaOffscreenFree(pScreen, area);
	area = NULL;
    }
#endif /* USE_EXA */
#ifdef USE_XAA
    if (!info->useEXA) {
	FBLinearPtr linear = mem_struct;

	if (linear != NULL)
	    xf86FreeOffscreenLinear(linear);
	linear = NULL;
    }
#endif /* USE_XAA */
}
@


1.1
log
@Add radeon driver 6.12.2 renamed as 'radeonold'.

This is the last known working version in 'zaphod' mode (one X
screen per head in multi-head configs). This makes it possible
to update the "real" radeon driver in xf86-video-ati, without
breaking existing zaphod setups.
@
text
@@

