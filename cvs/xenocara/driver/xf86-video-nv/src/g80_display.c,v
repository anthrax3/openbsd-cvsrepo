head	1.8;
access;
symbols
	OPENBSD_6_1:1.8.0.18
	OPENBSD_6_1_BASE:1.8
	OPENBSD_6_0:1.8.0.16
	OPENBSD_6_0_BASE:1.8
	OPENBSD_5_9:1.8.0.14
	OPENBSD_5_9_BASE:1.8
	OPENBSD_5_8:1.8.0.12
	OPENBSD_5_8_BASE:1.8
	OPENBSD_5_7:1.8.0.10
	OPENBSD_5_7_BASE:1.8
	OPENBSD_5_6:1.8.0.8
	OPENBSD_5_6_BASE:1.8
	OPENBSD_5_5:1.8.0.6
	OPENBSD_5_5_BASE:1.8
	OPENBSD_5_4:1.8.0.4
	OPENBSD_5_4_BASE:1.8
	OPENBSD_5_3:1.8.0.2
	OPENBSD_5_3_BASE:1.8
	OPENBSD_5_2:1.7.0.8
	OPENBSD_5_2_BASE:1.7
	OPENBSD_5_1_BASE:1.7
	OPENBSD_5_1:1.7.0.6
	OPENBSD_5_0:1.7.0.4
	OPENBSD_5_0_BASE:1.7
	OPENBSD_4_9:1.7.0.2
	OPENBSD_4_9_BASE:1.7
	OPENBSD_4_8:1.6.0.4
	OPENBSD_4_8_BASE:1.6
	OPENBSD_4_7:1.5.0.2
	OPENBSD_4_7_BASE:1.5
	OPENBSD_4_6:1.4.0.4
	OPENBSD_4_6_BASE:1.4
	OPENBSD_4_5:1.4.0.2
	OPENBSD_4_5_BASE:1.4
	OPENBSD_4_4:1.3.0.2
	OPENBSD_4_4_BASE:1.3
	OPENBSD_4_3_BASE:1.2
	OPENBSD_4_3:1.2.0.2
	v2_1_6:1.1.1.3
	v2_1_5:1.1.1.2
	OPENBSD_4_2:1.1.1.1.0.2
	OPENBSD_4_2_BASE:1.1.1.1
	v2_0_2:1.1.1.1
	xorg:1.1.1;
locks; strict;
comment	@ * @;


1.8
date	2012.08.16.16.35.27;	author matthieu;	state Exp;
branches;
next	1.7;

1.7
date	2010.08.22.12.29.27;	author matthieu;	state Exp;
branches;
next	1.6;

1.6
date	2010.05.24.09.45.40;	author matthieu;	state Exp;
branches;
next	1.5;

1.5
date	2009.10.10.18.17.44;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2008.11.03.20.35.47;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2008.07.29.20.04.57;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2007.10.15.20.13.05;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2007.06.08.22.09.13;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2007.06.08.22.09.13;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2007.09.30.14.18.05;	author matthieu;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2008.01.12.16.29.24;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.8
log
@Update to xf86-video-nv 2.1.20
@
text
@/*
 * Copyright (c) 2007,2010 NVIDIA Corporation
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 *
 * The above copyright notice and this permission notice shall be included
 * in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
 * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
 * CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
 * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
 * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */


#ifdef HAVE_CONFIG_H
#include "config.h"
#endif

#include <float.h>
#include <math.h>
#include <strings.h>
#include <unistd.h>

#include "g80_type.h"
#include "g80_cursor.h"
#include "g80_display.h"
#include "g80_output.h"

typedef struct G80CrtcPrivRec {
    Head head;
    int pclk; /* Target pixel clock in kHz */
    Bool cursorVisible;
    Bool skipModeFixup;
    Bool dither;
    /* Look-up table values to be set when the CRTC is enabled */
    uint16_t lut_r[256], lut_g[256], lut_b[256];
} G80CrtcPrivRec, *G80CrtcPrivPtr;

static void G80CrtcShowHideCursor(xf86CrtcPtr crtc, Bool show, Bool update);

/*
 * PLL calculation.  pclk is in kHz.
 */
static void
G80CalcPLL(float pclk, int *pNA, int *pMA, int *pNB, int *pMB, int *pP)
{
    const float refclk = 27000.0f;
    const float minVcoA = 100000;
    const float maxVcoA = 400000;
    const float minVcoB = 600000;
    float maxVcoB = 1400000;
    const float minUA = 2000;
    const float maxUA = 400000;
    const float minUB = 50000;
    const float maxUB = 200000;
    const int minNA = 1, maxNA = 255;
    const int minNB = 1, maxNB = 31;
    const int minMA = 1, maxMA = 255;
    const int minMB = 1, maxMB = 31;
    const int minP = 0, maxP = 6;
    int lowP, highP;
    float vcoB;

    int na, ma, nb, mb, p;
    float bestError = FLT_MAX;

    *pNA = *pMA = *pNB = *pMB = *pP = 0;

    if(maxVcoB < pclk + pclk / 200)
        maxVcoB = pclk + pclk / 200;
    if(minVcoB / (1 << maxP) > pclk)
        pclk = minVcoB / (1 << maxP);

    vcoB = maxVcoB - maxVcoB / 200;
    lowP = minP;
    vcoB /= 1 << (lowP + 1);

    while(pclk <= vcoB && lowP < maxP)
    {
        vcoB /= 2;
        lowP++;
    }

    vcoB = maxVcoB + maxVcoB / 200;
    highP = lowP;
    vcoB /= 1 << (highP + 1);

    while(pclk <= vcoB && highP < maxP)
    {
        vcoB /= 2;
        highP++;
    }

    for(p = lowP; p <= highP; p++)
    {
        for(ma = minMA; ma <= maxMA; ma++)
        {
            if(refclk / ma < minUA)
                break;
            else if(refclk / ma > maxUA)
                continue;

            for(na = minNA; na <= maxNA; na++)
            {
                if(refclk * na / ma < minVcoA || refclk * na / ma > maxVcoA)
                    continue;

                for(mb = minMB; mb <= maxMB; mb++)
                {
                    if(refclk * na / ma / mb < minUB)
                        break;
                    else if(refclk * na / ma / mb > maxUB)
                        continue;

                    nb = rint(pclk * (1 << p) * (ma / (float)na) * mb / refclk);

                    if(nb > maxNB)
                        break;
                    else if(nb < minNB)
                        continue;
                    else
                    {
                        float freq = refclk * (na / (float)ma) * (nb / (float)mb) / (1 << p);
                        float error = fabsf(pclk - freq);
                        if(error < bestError) {
                            *pNA = na;
                            *pMA = ma;
                            *pNB = nb;
                            *pMB = mb;
                            *pP = p;
                            bestError = error;
                        }
                    }
                }
            }
        }
    }
}

static void
G80CalcPLL2(float pclk, int *pN, int *pM, int *pPL)
{
    const float refclk = 27000.0f;
    const int minN = 8, maxN = 255;
    const int minM = 1, maxM = 255;
    const int minPL = 1, maxPL = 63;
    const int minU = 25000, maxU = 50000;
    const int minVco = 500000;
    int maxVco = 1000000;
    int lowPL, highPL, pl;
    float vco, bestError = FLT_MAX;

    vco = pclk + pclk / 50;

    if(maxVco < vco) maxVco = vco;

    highPL = (maxVco + vco - 1) / pclk;
    if(highPL > maxPL) highPL = maxPL;
    if(highPL < minPL) highPL = minPL;

    lowPL = minVco / vco;
    if(lowPL > maxPL) lowPL = maxPL;
    if(lowPL < minPL) lowPL = minPL;

    for(pl = highPL; pl >= lowPL; pl--) {
        int m;

        for(m = minM; m <= maxM; m++) {
            int n;
            float freq, error;

            if(refclk / m < minU) break;
            if(refclk / m > maxU) continue;

            n = rint(pclk * pl * m / refclk);
            if(n > maxN) break;
            if(n < minN) continue;

            freq = refclk * (n / (float)m) / pl;
            error = fabsf(pclk - freq);
            if(error < bestError) {
                *pN = n;
                *pM = m;
                *pPL = pl;
                bestError = error;
            }
        }
    }
}

static void
G80CrtcSetPClk(xf86CrtcPtr crtc)
{
    G80Ptr pNv = G80PTR(crtc->scrn);
    G80CrtcPrivPtr pPriv = crtc->driver_private;
    xf86CrtcConfigPtr xf86_config = XF86_CRTC_CONFIG_PTR(crtc->scrn);
    const int headOff = 0x800 * pPriv->head;
    int i;

    if(pPriv->pclk == 0)
        return;

    if(pNv->architecture <= 0xa0 ||
       pNv->architecture == 0xaa ||
       pNv->architecture == 0xac) {
        int lo_n, lo_m, hi_n, hi_m, p;
        CARD32 lo = pNv->reg[(0x00614104+headOff)/4];
        CARD32 hi = pNv->reg[(0x00614108+headOff)/4];

        pNv->reg[(0x00614100+headOff)/4] = 0x10000610;
        lo &= 0xff00ff00;
        hi &= 0x8000ff00;

        G80CalcPLL(pPriv->pclk, &lo_n, &lo_m, &hi_n, &hi_m, &p);

        lo |= (lo_m << 16) | lo_n;
        hi |= (p << 28) | (hi_m << 16) | hi_n;
        pNv->reg[(0x00614104+headOff)/4] = lo;
        pNv->reg[(0x00614108+headOff)/4] = hi;
    } else {
        int n, m, pl;
        CARD32 r = pNv->reg[(0x00614104+headOff)/4];

        pNv->reg[(0x00614100+headOff)/4] = 0x50000610;
        r &= 0xffc00000;

        G80CalcPLL2(pPriv->pclk, &n, &m, &pl);
        r |= pl << 16 | m << 8 | n;

        pNv->reg[(0x00614104+headOff)/4] = r;
    }
    pNv->reg[(0x00614200+headOff)/4] = 0;

    for(i = 0; i < xf86_config->num_output; i++) {
        xf86OutputPtr output = xf86_config->output[i];

        if(output->crtc != crtc)
            continue;
        G80OutputSetPClk(output, pPriv->pclk);
    }
}

void
G80DispCommand(ScrnInfoPtr pScrn, CARD32 addr, CARD32 data)
{
    G80Ptr pNv = G80PTR(pScrn);

    pNv->reg[0x00610304/4] = data;
    pNv->reg[0x00610300/4] = addr | 0x80010001;

    while(pNv->reg[0x00610300/4] & 0x80000000) {
        const int super = ffs((pNv->reg[0x00610024/4] >> 4) & 7);

        if(super) {
            if(super == 2) {
                xf86CrtcConfigPtr xf86_config = XF86_CRTC_CONFIG_PTR(pScrn);
                int i;

                for(i = 0; i < xf86_config->num_crtc; i++)
                {
                    xf86CrtcPtr crtc = xf86_config->crtc[i];
                    const int headOff = 0x800 * G80CrtcGetHead(crtc);

                    if((pNv->reg[(0x00614200+headOff)/4] & 0xc0) == 0x80)
                        G80CrtcSetPClk(crtc);
                }
            }

            pNv->reg[0x00610024/4] = 8 << super;
            pNv->reg[0x00610030/4] = 0x80000000;
        }
    }
}

Head
G80CrtcGetHead(xf86CrtcPtr crtc)
{
    G80CrtcPrivPtr pPriv = crtc->driver_private;
    return pPriv->head;
}

Bool
G80DispPreInit(ScrnInfoPtr pScrn)
{
    G80Ptr pNv = G80PTR(pScrn);

    pNv->reg[0x00610184/4] = pNv->reg[0x00614004/4];
    pNv->reg[0x00610190/4] = pNv->reg[0x00616100/4];
    pNv->reg[0x006101a0/4] = pNv->reg[0x00616900/4];
    pNv->reg[0x00610194/4] = pNv->reg[0x00616104/4];
    pNv->reg[0x006101a4/4] = pNv->reg[0x00616904/4];
    pNv->reg[0x00610198/4] = pNv->reg[0x00616108/4];
    pNv->reg[0x006101a8/4] = pNv->reg[0x00616908/4];
    pNv->reg[0x0061019C/4] = pNv->reg[0x0061610C/4];
    pNv->reg[0x006101ac/4] = pNv->reg[0x0061690c/4];
    pNv->reg[0x006101D0/4] = pNv->reg[0x0061A000/4];
    pNv->reg[0x006101D4/4] = pNv->reg[0x0061A800/4];
    pNv->reg[0x006101D8/4] = pNv->reg[0x0061B000/4];
    pNv->reg[0x006101E0/4] = pNv->reg[0x0061C000/4];
    pNv->reg[0x006101E4/4] = pNv->reg[0x0061C800/4];
    pNv->reg[0x006101E8/4] = pNv->reg[0x0061D000/4];
    pNv->reg[0x006101EC/4] = pNv->reg[0x0061D800/4];
    pNv->reg[0x0061A004/4] = 0x80550000;
    pNv->reg[0x0061A010/4] = 0x00000001;
    pNv->reg[0x0061A804/4] = 0x80550000;
    pNv->reg[0x0061A810/4] = 0x00000001;
    pNv->reg[0x0061B004/4] = 0x80550000;
    pNv->reg[0x0061B010/4] = 0x00000001;

    return TRUE;
}

Bool
G80DispInit(ScrnInfoPtr pScrn)
{
    G80Ptr pNv = G80PTR(pScrn);
    CARD32 val;

    if(pNv->reg[0x00610024/4] & 0x100) {
        pNv->reg[0x00610024/4] = 0x100;
        pNv->reg[0x006194E8/4] &= ~1;
        while(pNv->reg[0x006194E8/4] & 2);
    }

    pNv->reg[0x00610200/4] = 0x2b00;
    do {
        val = pNv->reg[0x00610200/4];

        if ((val & 0x9f0000) == 0x20000)
            pNv->reg[0x00610200/4] = val | 0x800000;

        if ((val & 0x3f0000) == 0x30000)
            pNv->reg[0x00610200/4] = val | 0x200000;
    } while ((val & 0x1e0000) != 0);
    pNv->reg[0x00610300/4] = 1;
    pNv->reg[0x00610200/4] = 0x1000b03;
    while(!(pNv->reg[0x00610200/4] & 0x40000000));

    C(0x00000084, 0);
    C(0x00000088, 0);
    C(0x00000874, 0);
    C(0x00000800, 0);
    C(0x00000810, 0);
    C(0x0000082C, 0);

    return TRUE;
}

void
G80DispShutdown(ScrnInfoPtr pScrn)
{
    G80Ptr pNv = G80PTR(pScrn);
    xf86CrtcConfigPtr xf86_config = XF86_CRTC_CONFIG_PTR(pScrn);
    int i;

    for(i = 0; i < xf86_config->num_crtc; i++) {
        xf86CrtcPtr crtc = xf86_config->crtc[i];

        G80CrtcBlankScreen(crtc, TRUE);
    }

    C(0x00000080, 0);

    for(i = 0; i < xf86_config->num_crtc; i++) {
        xf86CrtcPtr crtc = xf86_config->crtc[i];

        if(crtc->enabled) {
            const CARD32 mask = 4 << G80CrtcGetHead(crtc);

            pNv->reg[0x00610024/4] = mask;
            while(!(pNv->reg[0x00610024/4] & mask));
        }
    }

    pNv->reg[0x00610200/4] = 0;
    pNv->reg[0x00610300/4] = 0;
    while((pNv->reg[0x00610200/4] & 0x1e0000) != 0);
    while((pNv->reg[0x61C030/4] & 0x10000000));
    while((pNv->reg[0x61C830/4] & 0x10000000));
}

void
G80CrtcDoModeFixup(DisplayModePtr dst, const DisplayModePtr src)
{
    /* Magic mode timing fudge factor */
    const int fudge = ((src->Flags & V_INTERLACE) && (src->Flags & V_DBLSCAN)) ? 2 : 1;
    const int interlaceDiv = (src->Flags & V_INTERLACE) ? 2 : 1;

    /* Stash the src timings in the Crtc fields in dst */
    dst->CrtcHBlankStart = src->CrtcVTotal << 16 | src->CrtcHTotal;
    dst->CrtcHSyncEnd = ((src->CrtcVSyncEnd - src->CrtcVSyncStart) / interlaceDiv - 1) << 16 |
        (src->CrtcHSyncEnd - src->CrtcHSyncStart - 1);
    dst->CrtcHBlankEnd = ((src->CrtcVBlankEnd - src->CrtcVSyncStart) / interlaceDiv - fudge) << 16 |
        (src->CrtcHBlankEnd - src->CrtcHSyncStart - 1);
    dst->CrtcHTotal = ((src->CrtcVTotal - src->CrtcVSyncStart + src->CrtcVBlankStart) / interlaceDiv - fudge) << 16 |
        (src->CrtcHTotal - src->CrtcHSyncStart + src->CrtcHBlankStart - 1);
    dst->CrtcHSkew = ((src->CrtcVTotal + src->CrtcVBlankEnd - src->CrtcVSyncStart) / 2 - 2) << 16 |
        ((2*src->CrtcVTotal - src->CrtcVSyncStart + src->CrtcVBlankStart) / 2 - 2);
}

static Bool
G80CrtcModeFixup(xf86CrtcPtr crtc,
                 DisplayModePtr mode, DisplayModePtr adjusted_mode)
{
    G80CrtcPrivPtr pPriv = crtc->driver_private;

    if(pPriv->skipModeFixup)
        return TRUE;

    G80CrtcDoModeFixup(adjusted_mode, mode);
    return TRUE;
}

static void
G80CrtcModeSet(xf86CrtcPtr crtc, DisplayModePtr mode,
               DisplayModePtr adjusted_mode, int x, int y)
{
    ScrnInfoPtr pScrn = crtc->scrn;
    G80CrtcPrivPtr pPriv = crtc->driver_private;
    const int HDisplay = adjusted_mode->HDisplay, VDisplay = adjusted_mode->VDisplay;
    const int headOff = 0x400 * G80CrtcGetHead(crtc);

    pPriv->pclk = adjusted_mode->Clock;

    C(0x00000804 + headOff, adjusted_mode->Clock | 0x800000);
    C(0x00000808 + headOff, (adjusted_mode->Flags & V_INTERLACE) ? 2 : 0);
    C(0x00000810 + headOff, 0);
    C(0x0000082C + headOff, 0);
    C(0x00000814 + headOff, adjusted_mode->CrtcHBlankStart);
    C(0x00000818 + headOff, adjusted_mode->CrtcHSyncEnd);
    C(0x0000081C + headOff, adjusted_mode->CrtcHBlankEnd);
    C(0x00000820 + headOff, adjusted_mode->CrtcHTotal);
    if(adjusted_mode->Flags & V_INTERLACE)
        C(0x00000824 + headOff, adjusted_mode->CrtcHSkew);
    C(0x00000868 + headOff, pScrn->virtualY << 16 | pScrn->virtualX);
    C(0x0000086C + headOff, pScrn->displayWidth * (pScrn->bitsPerPixel / 8) | 0x100000);
    switch(pScrn->depth) {
        case  8: C(0x00000870 + headOff, 0x1E00); break;
        case 15: C(0x00000870 + headOff, 0xE900); break;
        case 16: C(0x00000870 + headOff, 0xE800); break;
        case 24: C(0x00000870 + headOff, 0xCF00); break;
    }
    G80CrtcSetDither(crtc, pPriv->dither, FALSE);
    C(0x000008A8 + headOff, 0x40000);
    C(0x000008C0 + headOff, y << 16 | x);
    C(0x000008C8 + headOff, VDisplay << 16 | HDisplay);
    C(0x000008D4 + headOff, 0);

    G80CrtcBlankScreen(crtc, FALSE);
}

void
G80CrtcBlankScreen(xf86CrtcPtr crtc, Bool blank)
{
    ScrnInfoPtr pScrn = crtc->scrn;
    G80Ptr pNv = G80PTR(pScrn);
    G80CrtcPrivPtr pPriv = crtc->driver_private;
    const int headOff = 0x400 * pPriv->head;

    if(blank) {
        G80CrtcShowHideCursor(crtc, FALSE, FALSE);

        C(0x00000840 + headOff, 0);
        C(0x00000844 + headOff, 0);
        if(pNv->architecture != 0x50)
            C(0x0000085C + headOff, 0);
        C(0x00000874 + headOff, 0);
        if(pNv->architecture != 0x50)
            C(0x0000089C + headOff, 0);
    } else {
        C(0x00000860 + headOff, 0);
        C(0x00000864 + headOff, 0);
        pNv->reg[0x00610380/4] = 0;
        pNv->reg[0x00610384/4] = pNv->videoRam * 1024 - 1;
        pNv->reg[0x00610388/4] = 0x150000;
        pNv->reg[0x0061038C/4] = 0;
        C(0x00000884 + headOff, (pNv->videoRam << 2) - 0x40);
        if(pNv->architecture != 0x50)
            C(0x0000089C + headOff, 1);
        if(pPriv->cursorVisible)
            G80CrtcShowHideCursor(crtc, TRUE, FALSE);
        C(0x00000840 + headOff, pScrn->depth == 8 ? 0x80000000 : 0xc0000000);
        C(0x00000844 + headOff, (pNv->videoRam * 1024 - 0x5000 - 0x1000 * pPriv->head) >> 8);
        if(pNv->architecture != 0x50)
            C(0x0000085C + headOff, 1);
        C(0x00000874 + headOff, 1);
    }
}

static void
G80CrtcDPMSSet(xf86CrtcPtr crtc, int mode)
{
}

/******************************** Cursor stuff ********************************/
static void G80CrtcShowHideCursor(xf86CrtcPtr crtc, Bool show, Bool update)
{
    ScrnInfoPtr pScrn = crtc->scrn;
    G80CrtcPrivPtr pPriv = crtc->driver_private;
    const int headOff = 0x400 * G80CrtcGetHead(crtc);

    C(0x00000880 + headOff, show ? 0x85000000 : 0x5000000);
    if(update) {
        pPriv->cursorVisible = show;
        C(0x00000080, 0);
    }
}

static void G80CrtcShowCursor(xf86CrtcPtr crtc)
{
    G80CrtcShowHideCursor(crtc, TRUE, TRUE);
}

static void G80CrtcHideCursor(xf86CrtcPtr crtc)
{
    G80CrtcShowHideCursor(crtc, FALSE, TRUE);
}

/******************************** CRTC stuff ********************************/

static Bool
G80CrtcLock(xf86CrtcPtr crtc)
{
    return FALSE;
}

static void
G80CrtcPrepare(xf86CrtcPtr crtc)
{
    ScrnInfoPtr pScrn = crtc->scrn;
    G80CrtcPrivPtr pPriv = crtc->driver_private;
    xf86CrtcConfigPtr xf86_config = XF86_CRTC_CONFIG_PTR(pScrn);
    int i;

    for(i = 0; i < xf86_config->num_output; i++) {
        xf86OutputPtr output = xf86_config->output[i];

        if(!output->crtc)
            output->funcs->mode_set(output, NULL, NULL);
    }

    pPriv->skipModeFixup = FALSE;
}

void
G80CrtcSkipModeFixup(xf86CrtcPtr crtc)
{
    G80CrtcPrivPtr pPriv = crtc->driver_private;
    pPriv->skipModeFixup = TRUE;
}

void
G80CrtcSetDither(xf86CrtcPtr crtc, Bool dither, Bool update)
{
    ScrnInfoPtr pScrn = crtc->scrn;
    G80CrtcPrivPtr pPriv = crtc->driver_private;
    const int headOff = 0x400 * G80CrtcGetHead(crtc);

    pPriv->dither = dither;

    C(0x000008A0 + headOff, dither ? 0x11 : 0);
    if(update) C(0x00000080, 0);
}

static void ComputeAspectScale(DisplayModePtr mode, int *outX, int *outY)
{
    float scaleX, scaleY, scale;

    scaleX = mode->CrtcHDisplay / (float)mode->HDisplay;
    scaleY = mode->CrtcVDisplay / (float)mode->VDisplay;

    if(scaleX > scaleY)
        scale = scaleY;
    else
        scale = scaleX;

    *outX = mode->HDisplay * scale;
    *outY = mode->VDisplay * scale;
}

void G80CrtcSetScale(xf86CrtcPtr crtc, DisplayModePtr mode,
                     enum G80ScaleMode scale)
{
    ScrnInfoPtr pScrn = crtc->scrn;
    G80CrtcPrivPtr pPriv = crtc->driver_private;
    const int headOff = 0x400 * pPriv->head;
    int outX, outY;

    switch(scale) {
        default:
        case G80_SCALE_ASPECT:
            ComputeAspectScale(mode, &outX, &outY);
            break;

        case G80_SCALE_OFF:
        case G80_SCALE_FILL:
            outX = mode->CrtcHDisplay;
            outY = mode->CrtcVDisplay;
            break;

        case G80_SCALE_CENTER:
            outX = mode->HDisplay;
            outY = mode->VDisplay;
            break;
    }

    if((mode->Flags & V_DBLSCAN) || (mode->Flags & V_INTERLACE) ||
       mode->HDisplay != outX || mode->VDisplay != outY) {
        C(0x000008A4 + headOff, 9);
    } else {
        C(0x000008A4 + headOff, 0);
    }
    C(0x000008D8 + headOff, outY << 16 | outX);
    C(0x000008DC + headOff, outY << 16 | outX);
}

static void
G80CrtcCommit(xf86CrtcPtr crtc)
{
    ScrnInfoPtr pScrn = crtc->scrn;
    xf86CrtcConfigPtr xf86_config = XF86_CRTC_CONFIG_PTR(crtc->scrn);
    int i, crtc_mask = 0;

    /* If any heads are unused, blank them */
    for(i = 0; i < xf86_config->num_output; i++) {
        xf86OutputPtr output = xf86_config->output[i];

        if(output->crtc)
            /* XXXagp: This assumes that xf86_config->crtc[i] is HEADi */
            crtc_mask |= 1 << G80CrtcGetHead(output->crtc);
    }

    for(i = 0; i < xf86_config->num_crtc; i++)
        if(!((1 << i) & crtc_mask))
            G80CrtcBlankScreen(xf86_config->crtc[i], TRUE);

    C(0x00000080, 0);
}

static void
G80CrtcGammaSet(xf86CrtcPtr crtc, CARD16 *red, CARD16 *green, CARD16 *blue,
                int size)
{
    ScrnInfoPtr pScrn = crtc->scrn;
    G80Ptr pNv = G80PTR(pScrn);
    G80CrtcPrivPtr pPriv = crtc->driver_private;
    int i;
    volatile struct {
        uint16_t red, green, blue, unused;
    } *lut = (void*)&pNv->mem[pNv->videoRam * 1024 - 0x5000 - 0x1000 * pPriv->head];

    assert(size == 256);

    for(i = 0; i < size; i++) {
        pPriv->lut_r[i] = lut[i].red   = red[i] >> 2;
        pPriv->lut_g[i] = lut[i].green = green[i] >> 2;
        pPriv->lut_b[i] = lut[i].blue  = blue[i] >> 2;
    }

    lut[256] = lut[255];
}

void
G80LoadPalette(ScrnInfoPtr pScrn, int numColors, int *indices, LOCO *colors,
               VisualPtr pVisual)
{
    xf86CrtcConfigPtr xf86_config = XF86_CRTC_CONFIG_PTR(pScrn);
    int i, j, index;
    int p;
    uint16_t lut_r[256], lut_g[256], lut_b[256];

    for(p = 0; p < xf86_config->num_crtc; p++) {
        xf86CrtcPtr crtc = xf86_config->crtc[p];
        G80CrtcPrivPtr pPriv = crtc->driver_private;

        /* Initialize to the old lookup table values. */
        for(i = 0; i < 256; i++) {
            lut_r[i] = pPriv->lut_r[i] << 2;
            lut_g[i] = pPriv->lut_g[i] << 2;
            lut_b[i] = pPriv->lut_b[i] << 2;
        }

        switch(pScrn->depth) {
            case 15:
                for(i = 0; i < numColors; i++) {
                    index = indices[i];
                    for(j = 0; j < 8; j++) {
                        lut_r[index * 8 + j] =
                            colors[index].red << 8;
                        lut_g[index * 8 + j] =
                            colors[index].green << 8;
                        lut_b[index * 8 + j] =
                            colors[index].blue << 8;
                    }
                }
                break;
            case 16:
                for(i = 0; i < numColors; i++) {
                    index = indices[i];

                    if(index <= 31) {
                        for(j = 0; j < 8; j++) {
                            lut_r[index * 8 + j] =
                                colors[index].red << 8;
                            lut_b[index * 8 + j] =
                                colors[index].blue << 8;
                        }
                    }

                    for(j = 0; j < 4; j++) {
                        lut_g[index * 4 + j] =
                            colors[index].green << 8;
                    }
                }
                break;
            default:
                for(i = 0; i < numColors; i++) {
                    index = indices[i];
                    lut_r[index] = colors[index].red << 8;
                    lut_g[index] = colors[index].green << 8;
                    lut_b[index] = colors[index].blue << 8;
                }
                break;
        }

        /* Make the change through RandR */
        RRCrtcGammaSet(crtc->randr_crtc, lut_r, lut_g, lut_b);
    }
}

static const xf86CrtcFuncsRec g80_crtc_funcs = {
    .dpms = G80CrtcDPMSSet,
    .save = NULL,
    .restore = NULL,
    .lock = G80CrtcLock,
    .unlock = NULL,
    .mode_fixup = G80CrtcModeFixup,
    .prepare = G80CrtcPrepare,
    .mode_set = G80CrtcModeSet,
    .gamma_set = G80CrtcGammaSet,
    .commit = G80CrtcCommit,
    .shadow_create = NULL,
    .shadow_destroy = NULL,
    .set_cursor_position = G80SetCursorPosition,
    .show_cursor = G80CrtcShowCursor,
    .hide_cursor = G80CrtcHideCursor,
    .load_cursor_argb = G80LoadCursorARGB,
    .destroy = NULL,
};

void
G80DispCreateCrtcs(ScrnInfoPtr pScrn)
{
    G80Ptr pNv = G80PTR(pScrn);
    Head head;
    xf86CrtcPtr crtc;
    G80CrtcPrivPtr g80_crtc;

    /* Create a "crtc" object for each head */
    for(head = HEAD0; head <= HEAD1; head++) {
        crtc = xf86CrtcCreate(pScrn, &g80_crtc_funcs);
        if(!crtc) return;

        g80_crtc = xnfcalloc(sizeof(*g80_crtc), 1);
        g80_crtc->head = head;
        g80_crtc->dither = pNv->Dither;
        crtc->driver_private = g80_crtc;
    }
}
@


1.7
log
@Update to xf86-video-nv 2.1.18.

Tested at least by krw@@, benoit@@ and giovanni@@.
@
text
@d216 1
a216 1
        int lo_n, lo_m, hi_n, hi_m, p, i;
@


1.6
log
@Update to xf86-video-nv 2.1.17.
@
text
@a736 1
#ifdef RANDR_12_INTERFACE
a737 3
#else
        crtc->funcs->gamma_set(crtc, lut_r, lut_g, lut_b, 256);
#endif
@


1.5
log
@update to xf86-video-nv 2.1.15. Tested by espie@@ (not better,
but not worse either on his hardware).
@
text
@d2 1
a2 1
 * Copyright (c) 2007 NVIDIA, Corporation
d45 2
d493 1
a493 1
        C(0x00000844 + headOff, (pNv->videoRam * 1024 - 0x5000) >> 8);
d650 95
d754 1
a754 1
    // .gamma_set = G80DispGammaSet,
@


1.4
log
@xf86-video-nv 2.1.12
@
text
@d149 51
d206 34
a239 14
    int lo_n, lo_m, hi_n, hi_m, p, i;
    CARD32 lo = pNv->reg[(0x00614104+headOff)/4];
    CARD32 hi = pNv->reg[(0x00614108+headOff)/4];

    pNv->reg[(0x00614100+headOff)/4] = 0x10000610;
    lo &= 0xff00ff00;
    hi &= 0x8000ff00;

    G80CalcPLL(pPriv->pclk, &lo_n, &lo_m, &hi_n, &hi_m, &p);

    lo |= (lo_m << 16) | lo_n;
    hi |= (p << 28) | (hi_m << 16) | hi_n;
    pNv->reg[(0x00614104+headOff)/4] = lo;
    pNv->reg[(0x00614108+headOff)/4] = hi;
d309 2
@


1.3
log
@update xf86-video-nv to 2.1.10
@
text
@a193 1
                const CARD32 r = pNv->reg[0x00610030/4];
d199 1
a199 1
                    G80CrtcPrivPtr pPriv = crtc->driver_private;
d201 1
a201 1
                    if(r & (0x200 << pPriv->head))
@


1.2
log
@From Aaron Plattner in X.Org git:
G80 bug #12637: Unwedge the hardware if the BIOS left it stuck.
Fixes Thinkpad R61 display lockup for niklas@@ and espie@@.
@
text
@d410 1
a410 1
        pNv->reg[0x00610384/4] = pNv->RamAmountKBytes * 1024 - 1;
d426 1
a426 1
void
d445 1
a445 1
void G80CrtcShowCursor(xf86CrtcPtr crtc)
d450 1
a450 1
void G80CrtcHideCursor(xf86CrtcPtr crtc)
@


1.1
log
@Initial revision
@
text
@d35 1
d37 1
d39 9
a47 2
#define DPMS_SERVER
#include <X11/extensions/dpms.h>
d149 1
a149 1
G80DispCommand(G80Ptr pNv, CARD32 addr, CARD32 data)
d151 34
d193 3
a195 2
                const int headOff = 0x800 * pNv->head;
                const int orOff = 0x800 * pNv->or;
d197 4
a200 16
                if(pNv->reg[0x00610030/4] & 0x600) {
                    int lo_n, lo_m, hi_n, hi_m, p;
                    CARD32 lo = pNv->reg[(0x00614104+headOff)/4];
                    CARD32 hi = pNv->reg[(0x00614108+headOff)/4];

                    pNv->reg[(0x00614100+headOff)/4] = 0x10000610;
                    lo &= 0xff00ff00;
                    hi &= 0x8000ff00;

                    G80CalcPLL(pNv->pclk, &lo_n, &lo_m, &hi_n, &hi_m, &p);

                    lo |= (lo_m << 16) | lo_n;
                    hi |= (p << 28) | (hi_m << 16) | hi_n;
                    pNv->reg[(0x00614104+headOff)/4] = lo;
                    pNv->reg[(0x00614108+headOff)/4] = hi;
                }
d202 2
a203 9
                pNv->reg[(0x00614200+headOff)/4] = 0;
                switch(pNv->orType) {
                case DAC:
                    pNv->reg[(0x00614280+orOff)/4] = 0;
                    break;
                case SOR:
                    pNv->reg[(0x00614300+orOff)/4] =
                        (pNv->pclk > 165000) ? 0x101 : 0;
                    break;
a211 23
#define C(mthd, data) G80DispCommand(pNv, (mthd), (data))

/*
 * Performs load detection on a single DAC.
 */
Bool G80DispDetectLoad(ScrnInfoPtr pScrn, ORNum or)
{
    G80Ptr pNv = G80PTR(pScrn);
    const int dacOff = 2048 * or;
    CARD32 load, tmp;

    pNv->reg[(0x0061A010+dacOff)/4] = 0x00000001;
    pNv->reg[(0x0061A004+dacOff)/4] = 0x80150000;
    while(pNv->reg[(0x0061A004+dacOff)/4] & 0x80000000);
    tmp = pNv->architecture == 0x50 ? 420 : 340;
    pNv->reg[(0x0061A00C+dacOff)/4] = tmp | 0x100000;
    usleep(4500);
    load = pNv->reg[(0x0061A00C+dacOff)/4];
    pNv->reg[(0x0061A00C+dacOff)/4] = 0;
    pNv->reg[(0x0061A004+dacOff)/4] = 0x80550000;

    return (load & 0x38000000) == 0x38000000;
}
d213 2
a214 5
/*
 * Performs load detection on the DACs.  Sets pNv->orType and pNv->or
 * accordingly.
 */
Bool G80LoadDetect(ScrnInfoPtr pScrn)
d216 2
a217 19
    G80Ptr pNv = G80PTR(pScrn);
    const int scrnIndex = pScrn->scrnIndex;
    ORNum or;

    pNv->orType = DAC;

    for(or = DAC0; or <= DAC2; or++) {
        xf86DrvMsg(scrnIndex, X_PROBED, "Trying load detection on DAC%i ... ", or);

        if(G80DispDetectLoad(pScrn, or)) {
            xf86ErrorF("found one!\n");
            pNv->or = or;
            return TRUE;
        }

        xf86ErrorF("nothing.\n");
    }

    return FALSE;
d221 1
a221 1
G80DispInit(ScrnInfoPtr pScrn)
a238 8
    pNv->reg[0x0061c00c/4] = 0x03010700;
    pNv->reg[0x0061c010/4] = 0x0000152f;
    pNv->reg[0x0061c014/4] = 0x00000000;
    pNv->reg[0x0061c018/4] = 0x00245af8;
    pNv->reg[0x0061c80c/4] = 0x03010700;
    pNv->reg[0x0061c810/4] = 0x0000152f;
    pNv->reg[0x0061c814/4] = 0x00000000;
    pNv->reg[0x0061c818/4] = 0x00245af8;
d246 9
d262 9
a270 1
    while((pNv->reg[0x00610200/4] & 0x1e0000) != 0);
d289 16
a304 1
    CARD32 mask;
d306 4
a309 1
    G80DispBlankScreen(pScrn, TRUE);
a310 3
    mask = 4 << pNv->head;
    pNv->reg[0x00610024/4] = mask;
    while(!(pNv->reg[0x00610024/4] & mask));
d314 2
d318 2
a319 2
static void
setupDAC(G80Ptr pNv, Head head, ORNum or, DisplayModePtr mode)
d321 3
a323 1
    const int dacOff = 0x80 * pNv->or;
d325 17
a341 5
    C(0x00000400 + dacOff, (head == HEAD0 ? 1 : 2) | 0x40);
    C(0x00000404 + dacOff,
        (mode->Flags & V_NHSYNC) ? 1 : 0 |
        (mode->Flags & V_NVSYNC) ? 2 : 0);
}
d343 2
a344 4
static void
setupSOR(G80Ptr pNv, Head head, ORNum or, DisplayModePtr mode)
{
    const int sorOff = 0x40 * pNv->or;
d346 2
a347 5
    C(0x00000600 + sorOff,
        (head == HEAD0 ? 1 : 2) |
        (mode->SynthClock > 165000 ? 0x500 : 0x100) |
        ((mode->Flags & V_NHSYNC) ? 0x1000 : 0) |
        ((mode->Flags & V_NVSYNC) ? 0x2000 : 0));
d350 3
a352 2
Bool
G80DispSetMode(ScrnInfoPtr pScrn, DisplayModePtr mode)
d354 4
a357 4
    G80Ptr pNv = G80PTR(pScrn);
    const int HDisplay = mode->HDisplay, VDisplay = mode->VDisplay;
    const int headOff = 0x400 * pNv->head;
    int interlaceDiv, fudge;
d359 1
a359 2
    if(pNv->BackendMode)
        mode = pNv->BackendMode;
d361 2
a362 17
    pNv->pclk = mode->SynthClock;

    /* Magic mode timing fudge factor */
    fudge = ((mode->Flags & V_INTERLACE) && (mode->Flags & V_DBLSCAN)) ? 2 : 1;
    interlaceDiv = (mode->Flags & V_INTERLACE) ? 2 : 1;

    switch(pNv->orType) {
    case DAC:
        setupDAC(pNv, pNv->head, pNv->or, mode);
        break;
    case SOR:
        setupSOR(pNv, pNv->head, pNv->or, mode);
        break;
    }

    C(0x00000804 + headOff, mode->SynthClock | 0x800000);
    C(0x00000808 + headOff, (mode->Flags & V_INTERLACE) ? 2 : 0);
d365 6
a370 15
    C(0x00000814 + headOff, mode->CrtcVTotal << 16 | mode->CrtcHTotal);
    C(0x00000818 + headOff,
        ((mode->CrtcVSyncEnd - mode->CrtcVSyncStart) / interlaceDiv - 1) << 16 |
        (mode->CrtcHSyncEnd - mode->CrtcHSyncStart - 1));
    C(0x0000081C + headOff,
        ((mode->CrtcVBlankEnd - mode->CrtcVSyncStart) / interlaceDiv - fudge) << 16 |
        (mode->CrtcHBlankEnd - mode->CrtcHSyncStart - 1));
    C(0x00000820 + headOff,
        ((mode->CrtcVTotal - mode->CrtcVSyncStart + mode->CrtcVBlankStart) / interlaceDiv - fudge) << 16 |
        (mode->CrtcHTotal - mode->CrtcHSyncStart + mode->CrtcHBlankStart - 1));
    if(mode->Flags & V_INTERLACE) {
        C(0x00000824 + headOff,
            ((mode->CrtcVTotal + mode->CrtcVBlankEnd - mode->CrtcVSyncStart) / 2 - 2) << 16 |
            ((2*mode->CrtcVTotal - mode->CrtcVSyncStart + mode->CrtcVBlankStart) / 2 - 2));
    }
d379 1
a379 7
    C(0x000008A0 + headOff, 0);
    if((mode->Flags & V_DBLSCAN) || (mode->Flags & V_INTERLACE) ||
       mode->CrtcHDisplay != HDisplay || mode->CrtcVDisplay != VDisplay) {
        C(0x000008A4 + headOff, 9);
    } else {
        C(0x000008A4 + headOff, 0);
    }
d381 1
a381 8
    /* Use the screen's panning, but not if it's bogus */
    if(pScrn->frameX0 >= 0 && pScrn->frameY0 >= 0 &&
       pScrn->frameX0 + HDisplay <= pScrn->virtualX &&
       pScrn->frameY0 + VDisplay <= pScrn->virtualY) {
        C(0x000008C0 + headOff, pScrn->frameY0 << 16 | pScrn->frameX0);
    } else {
        C(0x000008C0 + headOff, 0);
    }
a383 12
    C(0x000008D8 + headOff, mode->CrtcVDisplay << 16 | mode->CrtcHDisplay);
    C(0x000008DC + headOff, mode->CrtcVDisplay << 16 | mode->CrtcHDisplay);

    G80DispBlankScreen(pScrn, FALSE);

    return TRUE;
}

void
G80DispAdjustFrame(G80Ptr pNv, int x, int y)
{
    const int headOff = 0x400 * pNv->head;
d385 1
a385 2
    C(0x000008C0 + headOff, y << 16 | x);
    C(0x00000080, 0);
d389 1
a389 1
G80DispBlankScreen(ScrnInfoPtr pScrn, Bool blank)
d391 1
d393 2
a394 1
    const int headOff = 0x400 * pNv->head;
d397 1
a397 1
        G80DispHideCursor(pNv, FALSE);
d416 2
a417 2
        if(pNv->cursorVisible)
            G80DispShowCursor(pNv, FALSE);
d424 6
d431 22
a452 1
    C(0x00000080, 0);
d455 4
a458 2
void
G80DispDPMSSet(ScrnInfoPtr pScrn, int mode, int flags)
d460 2
a461 3
    G80Ptr pNv = G80PTR(pScrn);
    const int off = 0x800 * pNv->or;
    CARD32 tmp;
d463 7
a469 37
    /*
     * DPMSModeOn       everything on
     * DPMSModeStandby  hsync disabled, vsync enabled
     * DPMSModeSuspend  hsync enabled, vsync disabled
     * DPMSModeOff      sync disabled
     */
    switch(pNv->orType) {
    case DAC:
        while(pNv->reg[(0x0061A004+off)/4] & 0x80000000);

        tmp = pNv->reg[(0x0061A004+off)/4];
        tmp &= ~0x7f;
        tmp |= 0x80000000;

        if(mode == DPMSModeStandby || mode == DPMSModeOff)
            tmp |= 1;
        if(mode == DPMSModeSuspend || mode == DPMSModeOff)
            tmp |= 4;
        if(mode != DPMSModeOn)
            tmp |= 0x10;
        if(mode == DPMSModeOff)
            tmp |= 0x40;

        pNv->reg[(0x0061A004+off)/4] = tmp;

        break;

    case SOR:
        while(pNv->reg[(0x0061C004+off)/4] & 0x80000000);

        tmp = pNv->reg[(0x0061C004+off)/4];
        tmp |= 0x80000000;

        if(mode == DPMSModeOn)
            tmp |= 1;
        else
            tmp &= ~1;
d471 2
a472 1
        pNv->reg[(0x0061C004+off)/4] = tmp;
d474 2
a475 1
        break;
d477 2
d481 9
a489 2
/******************************** Cursor stuff ********************************/
void G80DispShowCursor(G80Ptr pNv, Bool update)
d491 5
a495 1
    const int headOff = 0x400 * pNv->head;
d497 1
a497 1
    C(0x00000880 + headOff, 0x85000000);
d501 1
a501 1
void G80DispHideCursor(G80Ptr pNv, Bool update)
d503 1
a503 1
    const int headOff = 0x400 * pNv->head;
d505 109
a613 2
    C(0x00000880 + headOff, 0x5000000);
    if(update) C(0x00000080, 0);
@


1.1.1.1
log
@Import xf86-video-nv version 2.0.2. Adds new chipsets support.
@
text
@@


1.1.1.2
log
@xf86-video-nv 2.1.5
@
text
@a34 1
#include "g80_cursor.h"
a35 1
#include "g80_output.h"
d37 2
a38 9
typedef struct G80CrtcPrivRec {
    Head head;
    int pclk; /* Target pixel clock in kHz */
    Bool cursorVisible;
    Bool skipModeFixup;
    Bool dither;
} G80CrtcPrivRec, *G80CrtcPrivPtr;

static void G80CrtcShowHideCursor(xf86CrtcPtr crtc, Bool show, Bool update);
d140 1
a140 1
G80CrtcSetPClk(xf86CrtcPtr crtc)
a141 34
    G80Ptr pNv = G80PTR(crtc->scrn);
    G80CrtcPrivPtr pPriv = crtc->driver_private;
    xf86CrtcConfigPtr xf86_config = XF86_CRTC_CONFIG_PTR(crtc->scrn);
    const int headOff = 0x800 * pPriv->head;
    int lo_n, lo_m, hi_n, hi_m, p, i;
    CARD32 lo = pNv->reg[(0x00614104+headOff)/4];
    CARD32 hi = pNv->reg[(0x00614108+headOff)/4];

    pNv->reg[(0x00614100+headOff)/4] = 0x10000610;
    lo &= 0xff00ff00;
    hi &= 0x8000ff00;

    G80CalcPLL(pPriv->pclk, &lo_n, &lo_m, &hi_n, &hi_m, &p);

    lo |= (lo_m << 16) | lo_n;
    hi |= (p << 28) | (hi_m << 16) | hi_n;
    pNv->reg[(0x00614104+headOff)/4] = lo;
    pNv->reg[(0x00614108+headOff)/4] = hi;
    pNv->reg[(0x00614200+headOff)/4] = 0;

    for(i = 0; i < xf86_config->num_output; i++) {
        xf86OutputPtr output = xf86_config->output[i];

        if(output->crtc != crtc)
            continue;
        G80OutputSetPClk(output, pPriv->pclk);
    }
}

void
G80DispCommand(ScrnInfoPtr pScrn, CARD32 addr, CARD32 data)
{
    G80Ptr pNv = G80PTR(pScrn);

d150 2
a151 3
                xf86CrtcConfigPtr xf86_config = XF86_CRTC_CONFIG_PTR(pScrn);
                const CARD32 r = pNv->reg[0x00610030/4];
                int i;
d153 16
a168 4
                for(i = 0; i < xf86_config->num_crtc; i++)
                {
                    xf86CrtcPtr crtc = xf86_config->crtc[i];
                    G80CrtcPrivPtr pPriv = crtc->driver_private;
d170 9
a178 2
                    if(r & (0x200 << pPriv->head))
                        G80CrtcSetPClk(crtc);
d187 1
d189 4
a192 2
Head
G80CrtcGetHead(xf86CrtcPtr crtc)
d194 42
a235 2
    G80CrtcPrivPtr pPriv = crtc->driver_private;
    return pPriv->head;
d239 1
a239 1
G80DispPreInit(ScrnInfoPtr pScrn)
d257 8
a271 8
    return TRUE;
}

Bool
G80DispInit(ScrnInfoPtr pScrn)
{
    G80Ptr pNv = G80PTR(pScrn);

d298 1
a298 13
    xf86CrtcConfigPtr xf86_config = XF86_CRTC_CONFIG_PTR(pScrn);
    int i;

    for(i = 0; i < xf86_config->num_crtc; i++) {
        xf86CrtcPtr crtc = xf86_config->crtc[i];

        G80CrtcBlankScreen(crtc, TRUE);
    }

    C(0x00000080, 0);

    for(i = 0; i < xf86_config->num_crtc; i++) {
        xf86CrtcPtr crtc = xf86_config->crtc[i];
d300 1
a300 7
        if(crtc->enabled) {
            const CARD32 mask = 4 << G80CrtcGetHead(crtc);

            pNv->reg[0x00610024/4] = mask;
            while(!(pNv->reg[0x00610024/4] & mask));
        }
    }
d302 3
a307 2
    while((pNv->reg[0x61C030/4] & 0x10000000));
    while((pNv->reg[0x61C830/4] & 0x10000000));
d310 2
a311 2
void
G80CrtcDoModeFixup(DisplayModePtr dst, const DisplayModePtr src)
d313 7
a319 3
    /* Magic mode timing fudge factor */
    const int fudge = ((src->Flags & V_INTERLACE) && (src->Flags & V_DBLSCAN)) ? 2 : 1;
    const int interlaceDiv = (src->Flags & V_INTERLACE) ? 2 : 1;
d321 2
a322 15
    /* Stash the src timings in the Crtc fields in dst */
    dst->CrtcHBlankStart = src->CrtcVTotal << 16 | src->CrtcHTotal;
    dst->CrtcHSyncEnd = ((src->CrtcVSyncEnd - src->CrtcVSyncStart) / interlaceDiv - 1) << 16 |
        (src->CrtcHSyncEnd - src->CrtcHSyncStart - 1);
    dst->CrtcHBlankEnd = ((src->CrtcVBlankEnd - src->CrtcVSyncStart) / interlaceDiv - fudge) << 16 |
        (src->CrtcHBlankEnd - src->CrtcHSyncStart - 1);
    dst->CrtcHTotal = ((src->CrtcVTotal - src->CrtcVSyncStart + src->CrtcVBlankStart) / interlaceDiv - fudge) << 16 |
        (src->CrtcHTotal - src->CrtcHSyncStart + src->CrtcHBlankStart - 1);
    dst->CrtcHSkew = ((src->CrtcVTotal + src->CrtcVBlankEnd - src->CrtcVSyncStart) / 2 - 2) << 16 |
        ((2*src->CrtcVTotal - src->CrtcVSyncStart + src->CrtcVBlankStart) / 2 - 2);
}

static Bool
G80CrtcModeFixup(xf86CrtcPtr crtc,
                 DisplayModePtr mode, DisplayModePtr adjusted_mode)
d324 1
a324 4
    G80CrtcPrivPtr pPriv = crtc->driver_private;

    if(pPriv->skipModeFixup)
        return TRUE;
d326 5
a330 2
    G80CrtcDoModeFixup(adjusted_mode, mode);
    return TRUE;
d333 2
a334 3
static void
G80CrtcModeSet(xf86CrtcPtr crtc, DisplayModePtr mode,
               DisplayModePtr adjusted_mode, int x, int y)
d336 7
a342 4
    ScrnInfoPtr pScrn = crtc->scrn;
    G80CrtcPrivPtr pPriv = crtc->driver_private;
    const int HDisplay = adjusted_mode->HDisplay, VDisplay = adjusted_mode->VDisplay;
    const int headOff = 0x400 * G80CrtcGetHead(crtc);
d344 5
a348 1
    pPriv->pclk = adjusted_mode->Clock;
d350 11
a360 2
    C(0x00000804 + headOff, adjusted_mode->Clock | 0x800000);
    C(0x00000808 + headOff, (adjusted_mode->Flags & V_INTERLACE) ? 2 : 0);
d363 15
a377 6
    C(0x00000814 + headOff, adjusted_mode->CrtcHBlankStart);
    C(0x00000818 + headOff, adjusted_mode->CrtcHSyncEnd);
    C(0x0000081C + headOff, adjusted_mode->CrtcHBlankEnd);
    C(0x00000820 + headOff, adjusted_mode->CrtcHTotal);
    if(adjusted_mode->Flags & V_INTERLACE)
        C(0x00000824 + headOff, adjusted_mode->CrtcHSkew);
d386 7
a392 1
    G80CrtcSetDither(crtc, pPriv->dither, FALSE);
d394 8
a401 1
    C(0x000008C0 + headOff, y << 16 | x);
d404 12
d417 2
a418 1
    G80CrtcBlankScreen(crtc, FALSE);
d422 1
a422 1
G80CrtcBlankScreen(xf86CrtcPtr crtc, Bool blank)
a423 1
    ScrnInfoPtr pScrn = crtc->scrn;
d425 1
a425 2
    G80CrtcPrivPtr pPriv = crtc->driver_private;
    const int headOff = 0x400 * pPriv->head;
d428 1
a428 1
        G80CrtcShowHideCursor(crtc, FALSE, FALSE);
d447 2
a448 2
        if(pPriv->cursorVisible)
            G80CrtcShowHideCursor(crtc, TRUE, FALSE);
d455 2
d460 1
a460 1
G80CrtcDPMSSet(xf86CrtcPtr crtc, int mode)
d462 3
a464 1
}
d466 37
a502 39
/******************************** Cursor stuff ********************************/
static void G80CrtcShowHideCursor(xf86CrtcPtr crtc, Bool show, Bool update)
{
    ScrnInfoPtr pScrn = crtc->scrn;
    G80CrtcPrivPtr pPriv = crtc->driver_private;
    const int headOff = 0x400 * G80CrtcGetHead(crtc);

    C(0x00000880 + headOff, show ? 0x85000000 : 0x5000000);
    if(update) {
        pPriv->cursorVisible = show;
        C(0x00000080, 0);
    }
}

void G80CrtcShowCursor(xf86CrtcPtr crtc)
{
    G80CrtcShowHideCursor(crtc, TRUE, TRUE);
}

void G80CrtcHideCursor(xf86CrtcPtr crtc)
{
    G80CrtcShowHideCursor(crtc, FALSE, TRUE);
}

/******************************** CRTC stuff ********************************/

static Bool
G80CrtcLock(xf86CrtcPtr crtc)
{
    return FALSE;
}

static void
G80CrtcPrepare(xf86CrtcPtr crtc)
{
    ScrnInfoPtr pScrn = crtc->scrn;
    G80CrtcPrivPtr pPriv = crtc->driver_private;
    xf86CrtcConfigPtr xf86_config = XF86_CRTC_CONFIG_PTR(pScrn);
    int i;
d504 1
a504 2
    for(i = 0; i < xf86_config->num_output; i++) {
        xf86OutputPtr output = xf86_config->output[i];
d506 1
a506 2
        if(!output->crtc)
            output->funcs->mode_set(output, NULL, NULL);
a507 2

    pPriv->skipModeFixup = FALSE;
d510 2
a511 2
void
G80CrtcSkipModeFixup(xf86CrtcPtr crtc)
d513 1
a513 3
    G80CrtcPrivPtr pPriv = crtc->driver_private;
    pPriv->skipModeFixup = TRUE;
}
d515 1
a515 10
void
G80CrtcSetDither(xf86CrtcPtr crtc, Bool dither, Bool update)
{
    ScrnInfoPtr pScrn = crtc->scrn;
    G80CrtcPrivPtr pPriv = crtc->driver_private;
    const int headOff = 0x400 * G80CrtcGetHead(crtc);

    pPriv->dither = dither;

    C(0x000008A0 + headOff, dither ? 0x11 : 0);
d519 1
a519 1
static void ComputeAspectScale(DisplayModePtr mode, int *outX, int *outY)
d521 1
a521 1
    float scaleX, scaleY, scale;
d523 2
a524 109
    scaleX = mode->CrtcHDisplay / (float)mode->HDisplay;
    scaleY = mode->CrtcVDisplay / (float)mode->VDisplay;

    if(scaleX > scaleY)
        scale = scaleY;
    else
        scale = scaleX;

    *outX = mode->HDisplay * scale;
    *outY = mode->VDisplay * scale;
}

void G80CrtcSetScale(xf86CrtcPtr crtc, DisplayModePtr mode,
                     enum G80ScaleMode scale)
{
    ScrnInfoPtr pScrn = crtc->scrn;
    G80CrtcPrivPtr pPriv = crtc->driver_private;
    const int headOff = 0x400 * pPriv->head;
    int outX, outY;

    switch(scale) {
        default:
        case G80_SCALE_ASPECT:
            ComputeAspectScale(mode, &outX, &outY);
            break;

        case G80_SCALE_OFF:
        case G80_SCALE_FILL:
            outX = mode->CrtcHDisplay;
            outY = mode->CrtcVDisplay;
            break;

        case G80_SCALE_CENTER:
            outX = mode->HDisplay;
            outY = mode->VDisplay;
            break;
    }

    if((mode->Flags & V_DBLSCAN) || (mode->Flags & V_INTERLACE) ||
       mode->HDisplay != outX || mode->VDisplay != outY) {
        C(0x000008A4 + headOff, 9);
    } else {
        C(0x000008A4 + headOff, 0);
    }
    C(0x000008D8 + headOff, outY << 16 | outX);
    C(0x000008DC + headOff, outY << 16 | outX);
}

static void
G80CrtcCommit(xf86CrtcPtr crtc)
{
    ScrnInfoPtr pScrn = crtc->scrn;
    xf86CrtcConfigPtr xf86_config = XF86_CRTC_CONFIG_PTR(crtc->scrn);
    int i, crtc_mask = 0;

    /* If any heads are unused, blank them */
    for(i = 0; i < xf86_config->num_output; i++) {
        xf86OutputPtr output = xf86_config->output[i];

        if(output->crtc)
            /* XXXagp: This assumes that xf86_config->crtc[i] is HEADi */
            crtc_mask |= 1 << G80CrtcGetHead(output->crtc);
    }

    for(i = 0; i < xf86_config->num_crtc; i++)
        if(!((1 << i) & crtc_mask))
            G80CrtcBlankScreen(xf86_config->crtc[i], TRUE);

    C(0x00000080, 0);
}

static const xf86CrtcFuncsRec g80_crtc_funcs = {
    .dpms = G80CrtcDPMSSet,
    .save = NULL,
    .restore = NULL,
    .lock = G80CrtcLock,
    .unlock = NULL,
    .mode_fixup = G80CrtcModeFixup,
    .prepare = G80CrtcPrepare,
    .mode_set = G80CrtcModeSet,
    // .gamma_set = G80DispGammaSet,
    .commit = G80CrtcCommit,
    .shadow_create = NULL,
    .shadow_destroy = NULL,
    .set_cursor_position = G80SetCursorPosition,
    .show_cursor = G80CrtcShowCursor,
    .hide_cursor = G80CrtcHideCursor,
    .load_cursor_argb = G80LoadCursorARGB,
    .destroy = NULL,
};

void
G80DispCreateCrtcs(ScrnInfoPtr pScrn)
{
    G80Ptr pNv = G80PTR(pScrn);
    Head head;
    xf86CrtcPtr crtc;
    G80CrtcPrivPtr g80_crtc;

    /* Create a "crtc" object for each head */
    for(head = HEAD0; head <= HEAD1; head++) {
        crtc = xf86CrtcCreate(pScrn, &g80_crtc_funcs);
        if(!crtc) return;

        g80_crtc = xnfcalloc(sizeof(*g80_crtc), 1);
        g80_crtc->head = head;
        g80_crtc->dither = pNv->Dither;
        crtc->driver_private = g80_crtc;
    }
@


1.1.1.3
log
@xf86-video-nv 2.1.6
@
text
@a252 1
    CARD32 val;
d261 1
a261 9
    do {
        val = pNv->reg[0x00610200/4];

        if ((val & 0x9f0000) == 0x20000)
            pNv->reg[0x00610200/4] = val | 0x800000;

        if ((val & 0x3f0000) == 0x30000)
            pNv->reg[0x00610200/4] = val | 0x200000;
    } while ((val & 0x1e0000) != 0);
@


