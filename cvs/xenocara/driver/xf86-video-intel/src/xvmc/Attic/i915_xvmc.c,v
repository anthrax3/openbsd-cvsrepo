head	1.7;
access;
symbols
	OPENBSD_5_4:1.6.0.8
	OPENBSD_5_4_BASE:1.6
	OPENBSD_5_3:1.6.0.6
	OPENBSD_5_3_BASE:1.6
	OPENBSD_5_2:1.6.0.4
	OPENBSD_5_2_BASE:1.6
	OPENBSD_5_1_BASE:1.6
	OPENBSD_5_1:1.6.0.2
	OPENBSD_5_0:1.5.0.6
	OPENBSD_5_0_BASE:1.5
	OPENBSD_4_9:1.5.0.2
	OPENBSD_4_9_BASE:1.5
	OPENBSD_4_8:1.5.0.4
	OPENBSD_4_8_BASE:1.5
	OPENBSD_4_7:1.3.0.6
	OPENBSD_4_7_BASE:1.3
	OPENBSD_4_6:1.3.0.4
	OPENBSD_4_6_BASE:1.3
	OPENBSD_4_5:1.3.0.2
	OPENBSD_4_5_BASE:1.3
	OPENBSD_4_4:1.2.0.2
	OPENBSD_4_4_BASE:1.2;
locks; strict;
comment	@ * @;


1.7
date	2014.02.03.15.54.53;	author matthieu;	state dead;
branches;
next	1.6;

1.6
date	2011.11.29.12.39.03;	author oga;	state Exp;
branches;
next	1.5;

1.5
date	2010.05.23.21.28.35;	author oga;	state Exp;
branches;
next	1.4;

1.4
date	2010.05.10.22.32.30;	author oga;	state Exp;
branches;
next	1.3;

1.3
date	2008.10.12.15.20.51;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2008.06.29.20.13.42;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2008.05.21.20.19.52;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.7
log
@Update to xf86-video-intel 2.99.909
Tested by jsg@@, kettenis@@ and myself on a wide range of intel cards.
@
text
@/*
 * Copyright Â© 2006 Intel Corporation
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice (including the next
 * paragraph) shall be included in all copies or substantial portions of the
 * Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 * Authors:
 *    Xiang Haihao <haihao.xiang@@intel.com>
 *
 */

#include <sys/ioctl.h>

#include "i915_xvmc.h"
#include "i915_structs.h"
#include "i915_program.h"

#define ALIGN(i,m)		(((i) + (m) - 1) & ~((m) - 1))

#define STRIDE(w)               (ALIGN((w), 1024))
#define SIZE_Y420(w, h)         (h * STRIDE(w))
#define SIZE_UV420(w, h)        ((h >> 1) * STRIDE(w >> 1))
#define SIZE_YUV420(w, h)       (SIZE_Y420(w,h) + SIZE_UV420(w,h) * 2)
#define UOFFSET(context)        (SIZE_Y420(context->width, context->height))
#define VOFFSET(context)        (SIZE_Y420(context->width, context->height) + \
                                 SIZE_UV420(context->width, context->height))

typedef union {
	int16_t component[2];
	int32_t v;
} vector_t;

static void i915_inst_arith(unsigned int *inst,
			    unsigned int op,
			    unsigned int dest,
			    unsigned int mask,
			    unsigned int saturate,
			    unsigned int src0, unsigned int src1,
			    unsigned int src2)
{
	dest = UREG(GET_UREG_TYPE(dest), GET_UREG_NR(dest));
	*inst = (op | A0_DEST(dest) | mask | saturate | A0_SRC0(src0));
	inst++;
	*inst = (A1_SRC0(src0) | A1_SRC1(src1));
	inst++;
	*inst = (A2_SRC1(src1) | A2_SRC2(src2));
}

static void i915_inst_decl(unsigned int *inst,
			   unsigned int type,
			   unsigned int nr, unsigned int d0_flags)
{
	unsigned int reg = UREG(type, nr);

	*inst = (D0_DCL | D0_DEST(reg) | d0_flags);
	inst++;
	*inst = D1_MBZ;
	inst++;
	*inst = D2_MBZ;
}

static void i915_inst_texld(unsigned int *inst,
			    unsigned int op,
			    unsigned int dest,
			    unsigned int coord, unsigned int sampler)
{
	dest = UREG(GET_UREG_TYPE(dest), GET_UREG_NR(dest));
	*inst = (op | T0_DEST(dest) | T0_SAMPLER(sampler));
	inst++;
	*inst = T1_ADDRESS_REG(coord);
	inst++;
	*inst = T2_MBZ;
}

static void i915_mc_one_time_context_init(XvMCContext * context)
{
	unsigned int dest, src0, src1, src2;
	i915XvMCContext *pI915XvMC = (i915XvMCContext *) context->privData;
	int i;
	struct i915_3dstate_sampler_state *sampler_state;
	struct i915_3dstate_pixel_shader_program *pixel_shader_program;
	struct i915_3dstate_pixel_shader_constants *pixel_shader_constants;

	/* sampler static state */
	drm_intel_gem_bo_map_gtt(pI915XvMC->ssb_bo);
	sampler_state = pI915XvMC->ssb_bo->virtual;

	memset(sampler_state, 0, sizeof(*sampler_state));
	sampler_state->dw0.type = CMD_3D;
	sampler_state->dw0.opcode = OPC_3DSTATE_SAMPLER_STATE;
	sampler_state->dw0.length = 6;
	sampler_state->dw1.sampler_masker = SAMPLER_SAMPLER0 | SAMPLER_SAMPLER1;

	sampler_state->sampler0.ts0.reverse_gamma = 0;
	sampler_state->sampler0.ts0.planar2packet = 0;
	sampler_state->sampler0.ts0.color_conversion = 0;
	sampler_state->sampler0.ts0.chromakey_index = 0;
	sampler_state->sampler0.ts0.base_level = 0;
	sampler_state->sampler0.ts0.mip_filter = MIPFILTER_NONE;	/* NONE */
	sampler_state->sampler0.ts0.mag_filter = MAPFILTER_LINEAR;	/* LINEAR */
	sampler_state->sampler0.ts0.min_filter = MAPFILTER_LINEAR;	/* LINEAR */
	sampler_state->sampler0.ts0.lod_bias = 0;	/* 0.0 */
	sampler_state->sampler0.ts0.shadow_enable = 0;
	sampler_state->sampler0.ts0.max_anisotropy = ANISORATIO_2;
	sampler_state->sampler0.ts0.shadow_function = PREFILTEROP_ALWAYS;
	sampler_state->sampler0.ts1.min_lod = 0;	/* 0.0 Maximum Mip Level */
	sampler_state->sampler0.ts1.kill_pixel = 0;
	sampler_state->sampler0.ts1.keyed_texture_filter = 0;
	sampler_state->sampler0.ts1.chromakey_enable = 0;
	sampler_state->sampler0.ts1.tcx_control = TEXCOORDMODE_CLAMP;
	sampler_state->sampler0.ts1.tcy_control = TEXCOORDMODE_CLAMP;
	sampler_state->sampler0.ts1.tcz_control = TEXCOORDMODE_CLAMP;
	sampler_state->sampler0.ts1.normalized_coor = 0;
	sampler_state->sampler0.ts1.map_index = 0;
	sampler_state->sampler0.ts1.east_deinterlacer = 0;
	sampler_state->sampler0.ts2.default_color = 0;

	sampler_state->sampler1.ts0.reverse_gamma = 0;
	sampler_state->sampler1.ts0.planar2packet = 0;
	sampler_state->sampler1.ts0.color_conversion = 0;
	sampler_state->sampler1.ts0.chromakey_index = 0;
	sampler_state->sampler1.ts0.base_level = 0;
	sampler_state->sampler1.ts0.mip_filter = MIPFILTER_NONE;	/* NONE */
	sampler_state->sampler1.ts0.mag_filter = MAPFILTER_LINEAR;	/* LINEAR */
	sampler_state->sampler1.ts0.min_filter = MAPFILTER_LINEAR;	/* LINEAR */
	sampler_state->sampler1.ts0.lod_bias = 0;	/* 0.0 */
	sampler_state->sampler1.ts0.shadow_enable = 0;
	sampler_state->sampler1.ts0.max_anisotropy = ANISORATIO_2;
	sampler_state->sampler1.ts0.shadow_function = PREFILTEROP_ALWAYS;
	sampler_state->sampler1.ts1.min_lod = 0;	/* 0.0 Maximum Mip Level */
	sampler_state->sampler1.ts1.kill_pixel = 0;
	sampler_state->sampler1.ts1.keyed_texture_filter = 0;
	sampler_state->sampler1.ts1.chromakey_enable = 0;
	sampler_state->sampler1.ts1.tcx_control = TEXCOORDMODE_CLAMP;
	sampler_state->sampler1.ts1.tcy_control = TEXCOORDMODE_CLAMP;
	sampler_state->sampler1.ts1.tcz_control = TEXCOORDMODE_CLAMP;
	sampler_state->sampler1.ts1.normalized_coor = 0;
	sampler_state->sampler1.ts1.map_index = 1;
	sampler_state->sampler1.ts1.east_deinterlacer = 0;
	sampler_state->sampler1.ts2.default_color = 0;

	drm_intel_gem_bo_unmap_gtt(pI915XvMC->ssb_bo);

	/* pixel shader static state */
	drm_intel_gem_bo_map_gtt(pI915XvMC->psp_bo);
	pixel_shader_program = pI915XvMC->psp_bo->virtual;

	memset(pixel_shader_program, 0, sizeof(*pixel_shader_program));
	pixel_shader_program->shader0.type = CMD_3D;
	pixel_shader_program->shader0.opcode = OPC_3DSTATE_PIXEL_SHADER_PROGRAM;
	pixel_shader_program->shader0.retain = 1;
	pixel_shader_program->shader0.length = 2;	/* 1 inst */
	i = 0;

	dest = UREG(REG_TYPE_OC, 0);
	src0 = UREG(REG_TYPE_CONST, 0);
	src1 = 0;
	src2 = 0;
	i915_inst_arith(&pixel_shader_program->inst0[i], A0_MOV,
			dest, A0_DEST_CHANNEL_ALL, A0_DEST_SATURATE, src0, src1,
			src2);

	pixel_shader_program->shader1.type = CMD_3D;
	pixel_shader_program->shader1.opcode = OPC_3DSTATE_PIXEL_SHADER_PROGRAM;
	pixel_shader_program->shader1.retain = 1;
	pixel_shader_program->shader1.length = 14;	/* 5 inst */
	i = 0;
	/* dcl t0.xy */
	i915_inst_decl(&pixel_shader_program->inst1[i], REG_TYPE_T, T_TEX0,
		       D0_CHANNEL_XY);
	i += 3;
	/* dcl t1.xy */
	i915_inst_decl(&pixel_shader_program->inst1[i], REG_TYPE_T, T_TEX1,
		       D0_CHANNEL_XY);
	/* dcl_2D s0 */
	i += 3;
	i915_inst_decl(&pixel_shader_program->inst1[i], REG_TYPE_S, 0,
		       D0_SAMPLE_TYPE_2D);
	/* texld r0, t0, s0 */
	i += 3;
	dest = UREG(REG_TYPE_R, 0);
	src0 = UREG(REG_TYPE_T, 0);	/* COORD */
	src1 = UREG(REG_TYPE_S, 0);	/* SAMPLER */
	i915_inst_texld(&pixel_shader_program->inst1[i], T0_TEXLD, dest, src0,
			src1);
	/* mov oC, r0 */
	i += 3;
	dest = UREG(REG_TYPE_OC, 0);
	src0 = UREG(REG_TYPE_R, 0);
	src1 = src2 = 0;
	i915_inst_arith(&pixel_shader_program->inst1[i], A0_MOV, dest,
			A0_DEST_CHANNEL_ALL, A0_DEST_SATURATE, src0, src1,
			src2);

	pixel_shader_program->shader2.type = CMD_3D;
	pixel_shader_program->shader2.opcode = OPC_3DSTATE_PIXEL_SHADER_PROGRAM;
	pixel_shader_program->shader2.retain = 1;
	pixel_shader_program->shader2.length = 14;	/* 5 inst */
	i = 0;
	/* dcl t2.xy */
	i915_inst_decl(&pixel_shader_program->inst2[i], REG_TYPE_T, T_TEX2,
		       D0_CHANNEL_XY);
	/* dcl t3.xy */
	i += 3;
	i915_inst_decl(&pixel_shader_program->inst2[i], REG_TYPE_T, T_TEX3,
		       D0_CHANNEL_XY);
	/* dcl_2D s1 */
	i += 3;
	i915_inst_decl(&pixel_shader_program->inst2[i], REG_TYPE_S, 1,
		       D0_SAMPLE_TYPE_2D);
	/* texld r0, t2, s1 */
	i += 3;
	dest = UREG(REG_TYPE_R, 0);
	src0 = UREG(REG_TYPE_T, 2);	/* COORD */
	src1 = UREG(REG_TYPE_S, 1);	/* SAMPLER */
	i915_inst_texld(&pixel_shader_program->inst2[i], T0_TEXLD, dest, src0,
			src1);
	/* mov oC, r0 */
	i += 3;
	dest = UREG(REG_TYPE_OC, 0);
	src0 = UREG(REG_TYPE_R, 0);
	src1 = src2 = 0;
	i915_inst_arith(&pixel_shader_program->inst2[i], A0_MOV, dest,
			A0_DEST_CHANNEL_ALL, A0_DEST_SATURATE, src0, src1,
			src2);

	/* Shader 3 */
	pixel_shader_program->shader3.type = CMD_3D;
	pixel_shader_program->shader3.opcode = OPC_3DSTATE_PIXEL_SHADER_PROGRAM;
	pixel_shader_program->shader3.retain = 1;
	pixel_shader_program->shader3.length = 29;	/* 10 inst */
	i = 0;
	/* dcl t0.xy */
	i915_inst_decl(&pixel_shader_program->inst3[i], REG_TYPE_T, T_TEX0,
		       D0_CHANNEL_XY);
	/* dcl t1.xy */
	i += 3;
	i915_inst_decl(&pixel_shader_program->inst3[i], REG_TYPE_T, T_TEX1,
		       D0_CHANNEL_XY);
	/* dcl t2.xy */
	i += 3;
	i915_inst_decl(&pixel_shader_program->inst3[i], REG_TYPE_T, T_TEX2,
		       D0_CHANNEL_XY);
	/* dcl t3.xy */
	i += 3;
	i915_inst_decl(&pixel_shader_program->inst3[i], REG_TYPE_T, T_TEX3,
		       D0_CHANNEL_XY);
	/* dcl_2D s0 */
	i += 3;
	i915_inst_decl(&pixel_shader_program->inst3[i], REG_TYPE_S, 0,
		       D0_SAMPLE_TYPE_2D);
	/* dcl_2D s1 */
	i += 3;
	i915_inst_decl(&pixel_shader_program->inst3[i], REG_TYPE_S, 1,
		       D0_SAMPLE_TYPE_2D);
	/* texld r0, t0, s0 */
	i += 3;
	dest = UREG(REG_TYPE_R, 0);
	src0 = UREG(REG_TYPE_T, 0);	/* COORD */
	src1 = UREG(REG_TYPE_S, 0);	/* SAMPLER */
	i915_inst_texld(&pixel_shader_program->inst3[i], T0_TEXLD, dest, src0,
			src1);
	/* texld r1, t2, s1 */
	i += 3;
	dest = UREG(REG_TYPE_R, 1);
	src0 = UREG(REG_TYPE_T, 2);	/* COORD */
	src1 = UREG(REG_TYPE_S, 1);	/* SAMPLER */
	i915_inst_texld(&pixel_shader_program->inst3[i], T0_TEXLD, dest, src0,
			src1);
	/* add r0, r0, r1 */
	i += 3;
	dest = UREG(REG_TYPE_R, 0);
	src0 = UREG(REG_TYPE_R, 0);
	src1 = UREG(REG_TYPE_R, 1);
	src2 = 0;
	i915_inst_arith(&pixel_shader_program->inst3[i], A0_ADD, dest,
			A0_DEST_CHANNEL_ALL, 0 /* A0_DEST_SATURATE */ , src0,
			src1, src2);
	/* mul oC, r0, c0 */
	i += 3;
	dest = UREG(REG_TYPE_OC, 0);
	src0 = UREG(REG_TYPE_R, 0);
	src1 = UREG(REG_TYPE_CONST, 0);
	src2 = 0;
	i915_inst_arith(&pixel_shader_program->inst3[i], A0_MUL, dest,
			A0_DEST_CHANNEL_ALL, A0_DEST_SATURATE, src0, src1,
			src2);

	drm_intel_gem_bo_unmap_gtt(pI915XvMC->psp_bo);

	/* pixel shader contant static state */
	drm_intel_gem_bo_map_gtt(pI915XvMC->psc_bo);
	pixel_shader_constants = pI915XvMC->psc_bo->virtual;

	memset(pixel_shader_constants, 0, sizeof(*pixel_shader_constants));
	pixel_shader_constants->dw0.type = CMD_3D;
	pixel_shader_constants->dw0.opcode = OPC_3DSTATE_PIXEL_SHADER_CONSTANTS;
	pixel_shader_constants->dw0.length = 4;
	pixel_shader_constants->dw1.reg_mask = REG_CR0;
	pixel_shader_constants->value.x = 0.5;
	pixel_shader_constants->value.y = 0.5;
	pixel_shader_constants->value.z = 0.5;
	pixel_shader_constants->value.w = 0.5;

	drm_intel_gem_bo_unmap_gtt(pI915XvMC->psc_bo);
}

static void i915_mc_one_time_state_emit(XvMCContext * context)
{
	i915XvMCContext *pI915XvMC = (i915XvMCContext *) context->privData;
	uint32_t load_state_immediate_1, load_indirect, s3_dword, s6_dword;
	int mem_select;
	BATCH_LOCALS;

	/* 3DSTATE_LOAD_STATE_IMMEDIATE_1 */
	BEGIN_BATCH(3 + 8);
	load_state_immediate_1 = OP_3D_LOAD_STATE_IMMEDIATE_1;
	load_state_immediate_1 |= OP_3D_LOAD_STATE_IMM_LOAD_S3;
	load_state_immediate_1 |= OP_3D_LOAD_STATE_IMM_LOAD_S6;
	load_state_immediate_1 |= 3 - 2; /* length */
	OUT_BATCH(load_state_immediate_1);

	s3_dword = S3_SET0_PCD | S3_SET1_PCD |
		   S3_SET2_PCD | S3_SET3_PCD |
		   S3_SET4_PCD | S3_SET5_PCD |
		   S3_SET6_PCD | S3_SET7_PCD;
	OUT_BATCH(s3_dword);

	s6_dword = S6_COLOR_BUFFER_WRITE | S6_DEPTH_TEST_ENABLE;
	s6_dword |= 1 << S6_SRC_BLEND_FACTOR_SHIFT;
	s6_dword |= 1 << S6_DST_BLEND_FACTOR_SHIFT;
	OUT_BATCH(s6_dword);

	/* 3DSTATE_LOAD_INDIRECT */
	load_indirect = OP_3D_LOAD_INDIRECT;
	load_indirect |= (BLOCK_DIS | BLOCK_SSB | BLOCK_PSP | BLOCK_PSC)
				<< BLOCK_MASK_SHIFT;
	load_indirect |= 8 - 2; /* length */

	if (pI915XvMC->use_phys_addr)
		mem_select = 0;	/* use physical address */
	else {
		load_indirect |= OP_3D_LOAD_INDIRECT_GFX_ADDR;
		mem_select = 1;	/* use gfx address */
	}

	OUT_BATCH(load_indirect);

	/* Dynamic indirect state buffer */
	OUT_BATCH(0); /* no dynamic indirect state */

	/* Sample state buffer */
	OUT_RELOC(pI915XvMC->ssb_bo, I915_GEM_DOMAIN_INSTRUCTION, 0,
			STATE_VALID | STATE_FORCE);
	OUT_BATCH(7);	/* 8 - 1 */

	/* Pixel shader program buffer */
	OUT_RELOC(pI915XvMC->psp_bo, I915_GEM_DOMAIN_INSTRUCTION, 0,
			STATE_VALID | STATE_FORCE);
	OUT_BATCH(66);	/* 4 + 16 + 16 + 31 - 1 */

	/* Pixel shader constant buffer */
	OUT_RELOC(pI915XvMC->psc_bo, I915_GEM_DOMAIN_INSTRUCTION, 0,
			STATE_VALID | STATE_FORCE);
	OUT_BATCH(5);	/* 6 - 1 */
	ADVANCE_BATCH();
}

static void i915_mc_static_indirect_state_set(XvMCContext * context,
					      XvMCSurface * dest,
					      unsigned int picture_structure,
					      unsigned int flags,
					      unsigned int picture_coding_type)
{
	i915XvMCContext *pI915XvMC = (i915XvMCContext *) context->privData;
	struct intel_xvmc_surface *intel_surf = dest->privData;
	struct i915_mc_static_indirect_state_buffer *buffer_info;

	drm_intel_gem_bo_map_gtt(pI915XvMC->sis_bo);
	buffer_info = pI915XvMC->sis_bo->virtual;

	memset(buffer_info, 0, sizeof(*buffer_info));

	/* dest Y */
	buffer_info->dest_y.dw0.type = CMD_3D;
	buffer_info->dest_y.dw0.opcode = OPC_3DSTATE_BUFFER_INFO;
	buffer_info->dest_y.dw0.length = 1;
	buffer_info->dest_y.dw1.aux_id = 0;
	buffer_info->dest_y.dw1.buffer_id = BUFFERID_COLOR_BACK;
	buffer_info->dest_y.dw1.fence_regs = 0;	/* disabled *//* FIXME: tiled y for performance */
	buffer_info->dest_y.dw1.tiled_surface = 0;	/* linear */
	buffer_info->dest_y.dw1.walk = TILEWALK_XMAJOR;
	buffer_info->dest_y.dw1.pitch = (pI915XvMC->yStride >> 2);	/* in DWords */
	buffer_info->dest_y.dw2.base_address = intel_surf->bo->offset >> 2;	/* starting DWORD address */
	drm_intel_bo_emit_reloc(pI915XvMC->sis_bo,
				offsetof(typeof(*buffer_info),dest_y.dw2),
				intel_surf->bo, 0,
				I915_GEM_DOMAIN_RENDER,
				I915_GEM_DOMAIN_RENDER);

	/* dest U */
	buffer_info->dest_u.dw0.type = CMD_3D;
	buffer_info->dest_u.dw0.opcode = OPC_3DSTATE_BUFFER_INFO;
	buffer_info->dest_u.dw0.length = 1;
	buffer_info->dest_u.dw1.aux_id = 0;
	buffer_info->dest_u.dw1.buffer_id = BUFFERID_COLOR_AUX;
	buffer_info->dest_u.dw1.fence_regs = 0;
	buffer_info->dest_u.dw1.tiled_surface = 0;
	buffer_info->dest_u.dw1.walk = TILEWALK_XMAJOR;
	buffer_info->dest_u.dw1.pitch = (pI915XvMC->uvStride >> 2);	/* in DWords */
	buffer_info->dest_u.dw2.base_address =
		(intel_surf->bo->offset + UOFFSET(context)) >> 2;
	drm_intel_bo_emit_reloc(pI915XvMC->sis_bo,
				offsetof(typeof(*buffer_info),dest_u.dw2),
				intel_surf->bo, UOFFSET(context),
				I915_GEM_DOMAIN_RENDER,
				I915_GEM_DOMAIN_RENDER);

	/* dest V */
	buffer_info->dest_v.dw0.type = CMD_3D;
	buffer_info->dest_v.dw0.opcode = OPC_3DSTATE_BUFFER_INFO;
	buffer_info->dest_v.dw0.length = 1;
	buffer_info->dest_v.dw1.aux_id = 1;
	buffer_info->dest_v.dw1.buffer_id = BUFFERID_COLOR_AUX;
	buffer_info->dest_v.dw1.fence_regs = 0;
	buffer_info->dest_v.dw1.tiled_surface = 0;
	buffer_info->dest_v.dw1.walk = TILEWALK_XMAJOR;
	buffer_info->dest_v.dw1.pitch = (pI915XvMC->uvStride >> 2);	/* in Dwords */
	buffer_info->dest_v.dw2.base_address =
		(intel_surf->bo->offset + VOFFSET(context)) >> 2;
	drm_intel_bo_emit_reloc(pI915XvMC->sis_bo,
				offsetof(typeof(*buffer_info),dest_v.dw2),
				intel_surf->bo, VOFFSET(context),
				I915_GEM_DOMAIN_RENDER,
				I915_GEM_DOMAIN_RENDER);

	/* Dest buffer parameters */
	buffer_info->dest_buf.dw0.type = CMD_3D;
	buffer_info->dest_buf.dw0.opcode = OPC_3DSTATE_DEST_BUFFER_VARIABLES;
	buffer_info->dest_buf.dw0.length = 0;
	buffer_info->dest_buf.dw1.dest_v_bias = 8;	/* 0.5 */
	buffer_info->dest_buf.dw1.dest_h_bias = 8;	/* 0.5 */
	buffer_info->dest_buf.dw1.color_fmt = COLORBUFFER_8BIT;
	buffer_info->dest_buf.dw1.v_ls = 0;	/* fill later */
	buffer_info->dest_buf.dw1.v_ls_offset = 0;	/* fill later */
	if ((picture_structure & XVMC_FRAME_PICTURE) == XVMC_FRAME_PICTURE) {
		;
	} else if ((picture_structure & XVMC_FRAME_PICTURE) == XVMC_TOP_FIELD) {
		buffer_info->dest_buf.dw1.v_ls = 1;
	} else if ((picture_structure & XVMC_FRAME_PICTURE) ==
		   XVMC_BOTTOM_FIELD) {
		buffer_info->dest_buf.dw1.v_ls = 1;
		buffer_info->dest_buf.dw1.v_ls_offset = 1;
	}

	/* MPEG buffer parameters */
	buffer_info->dest_buf_mpeg.dw0.type = CMD_3D;
	buffer_info->dest_buf_mpeg.dw0.opcode =
	    OPC_3DSTATE_DEST_BUFFER_VARIABLES_MPEG;
	buffer_info->dest_buf_mpeg.dw0.length = 1;
	buffer_info->dest_buf_mpeg.dw1.decode_mode = MPEG_DECODE_MC;
	buffer_info->dest_buf_mpeg.dw1.rcontrol = 0;	/* for MPEG-1/MPEG-2 */
	buffer_info->dest_buf_mpeg.dw1.bidir_avrg_control = 0;	/* for MPEG-1/MPEG-2/MPEG-4 */
	buffer_info->dest_buf_mpeg.dw1.abort_on_error = 1;
	buffer_info->dest_buf_mpeg.dw1.intra8 = 0;	/* 16-bit formatted correction data */
	buffer_info->dest_buf_mpeg.dw1.tff = 1;	/* fill later */

	buffer_info->dest_buf_mpeg.dw1.v_subsample_factor = MC_SUB_1V;
	buffer_info->dest_buf_mpeg.dw1.h_subsample_factor = MC_SUB_1H;

	if (picture_structure & XVMC_FRAME_PICTURE) {
		;
	} else if (picture_structure & XVMC_TOP_FIELD) {
		if (flags & XVMC_SECOND_FIELD)
			buffer_info->dest_buf_mpeg.dw1.tff = 0;
		else
			buffer_info->dest_buf_mpeg.dw1.tff = 1;
	} else if (picture_structure & XVMC_BOTTOM_FIELD) {
		if (flags & XVMC_SECOND_FIELD)
			buffer_info->dest_buf_mpeg.dw1.tff = 1;
		else
			buffer_info->dest_buf_mpeg.dw1.tff = 0;
	}

	buffer_info->dest_buf_mpeg.dw1.picture_width = (dest->width >> 4);	/* in macroblocks */
	buffer_info->dest_buf_mpeg.dw2.picture_coding_type =
	    picture_coding_type;

	buffer_info->corr.dw0.type = CMD_3D;
	buffer_info->corr.dw0.opcode = OPC_3DSTATE_BUFFER_INFO;
	buffer_info->corr.dw0.length = 1;
	buffer_info->corr.dw1.aux_id = 0;
	buffer_info->corr.dw1.buffer_id = BUFFERID_MC_INTRA_CORR;
	buffer_info->corr.dw1.aux_id = 0;
	buffer_info->corr.dw1.fence_regs = 0;
	buffer_info->corr.dw1.tiled_surface = 0;
	buffer_info->corr.dw1.walk = 0;
	buffer_info->corr.dw1.pitch = 0;
	buffer_info->corr.dw2.base_address = pI915XvMC->corrdata_bo->offset >> 2;	/* starting DWORD address */
	drm_intel_bo_emit_reloc(pI915XvMC->sis_bo,
				offsetof(typeof(*buffer_info),corr.dw2),
				pI915XvMC->corrdata_bo, 0,
				I915_GEM_DOMAIN_RENDER, 0);

	drm_intel_gem_bo_unmap_gtt(pI915XvMC->sis_bo);
}

static void i915_mc_map_state_set(XvMCContext * context,
				  struct intel_xvmc_surface * privPast,
				  struct intel_xvmc_surface * privFuture)
{
	i915XvMCContext *pI915XvMC = (i915XvMCContext *) context->privData;
	struct i915_mc_map_state *map_state;
	unsigned int w = context->width;
	unsigned int h = context->height;

	drm_intel_gem_bo_map_gtt(pI915XvMC->msb_bo);
	map_state = pI915XvMC->msb_bo->virtual;

	memset(map_state, 0, sizeof(*map_state));

	/* 3DSATE_MAP_STATE: Y */
	map_state->y_map.dw0.type = CMD_3D;
	map_state->y_map.dw0.opcode = OPC_3DSTATE_MAP_STATE;
	map_state->y_map.dw0.retain = 1;
	map_state->y_map.dw0.length = 6;
	map_state->y_map.dw1.map_mask = MAP_MAP0 | MAP_MAP1;

	/* Y Forward (Past) */
	map_state->y_forward.tm0.v_ls_offset = 0;
	map_state->y_forward.tm0.v_ls = 0;
	map_state->y_forward.tm1.tile_walk = TILEWALK_XMAJOR;
	map_state->y_forward.tm1.tiled_surface = 0;
	map_state->y_forward.tm1.utilize_fence_regs = 0;
	map_state->y_forward.tm1.texel_fmt = 0;	/* 8bit */
	map_state->y_forward.tm1.surface_fmt = 1;	/* 8bit */
	map_state->y_forward.tm1.width = w - 1;
	map_state->y_forward.tm1.height = h - 1;
	map_state->y_forward.tm2.depth = 0;
	map_state->y_forward.tm2.max_lod = 0;
	map_state->y_forward.tm2.cube_face = 0;
	map_state->y_forward.tm0.base_address = privPast->bo->offset >> 2;
	drm_intel_bo_emit_reloc(pI915XvMC->msb_bo,
				offsetof(typeof(*map_state),y_forward.tm0),
				privPast->bo, 0,
				I915_GEM_DOMAIN_SAMPLER, 0);
	map_state->y_forward.tm2.pitch = (pI915XvMC->yStride >> 2) - 1;	/* in DWords - 1 */

	/* Y Backward (Future) */
	map_state->y_backward.tm0.v_ls_offset = 0;
	map_state->y_backward.tm0.v_ls = 0;
	map_state->y_backward.tm1.tile_walk = TILEWALK_XMAJOR;
	map_state->y_backward.tm1.tiled_surface = 0;
	map_state->y_backward.tm1.utilize_fence_regs = 0;
	map_state->y_backward.tm1.texel_fmt = 0;	/* 8bit */
	map_state->y_backward.tm1.surface_fmt = 1;	/* 8bit */
	map_state->y_backward.tm1.width = w - 1;
	map_state->y_backward.tm1.height = h - 1;
	map_state->y_backward.tm2.depth = 0;
	map_state->y_backward.tm2.max_lod = 0;
	map_state->y_backward.tm2.cube_face = 0;
	map_state->y_backward.tm0.base_address = privFuture->bo->offset >> 2;
	drm_intel_bo_emit_reloc(pI915XvMC->msb_bo,
				offsetof(typeof(*map_state),y_backward.tm0),
				privFuture->bo, 0,
				I915_GEM_DOMAIN_SAMPLER, 0);
	map_state->y_backward.tm2.pitch = (pI915XvMC->yStride >> 2) - 1;

	/* 3DSATE_MAP_STATE: U */
	map_state->u_map.dw0.type = CMD_3D;
	map_state->u_map.dw0.opcode = OPC_3DSTATE_MAP_STATE;
	map_state->u_map.dw0.retain = 1;
	map_state->u_map.dw0.length = 6;
	map_state->u_map.dw1.map_mask = MAP_MAP0 | MAP_MAP1;

	/* U Forward */
	map_state->u_forward.tm0.v_ls_offset = 0;
	map_state->u_forward.tm0.v_ls = 0;
	map_state->u_forward.tm1.tile_walk = TILEWALK_XMAJOR;
	map_state->u_forward.tm1.tiled_surface = 0;
	map_state->u_forward.tm1.utilize_fence_regs = 0;
	map_state->u_forward.tm1.texel_fmt = 0;	/* 8bit */
	map_state->u_forward.tm1.surface_fmt = 1;	/* 8bit */
	map_state->u_forward.tm1.width = (w >> 1) - 1;
	map_state->u_forward.tm1.height = (h >> 1) - 1;
	map_state->u_forward.tm2.depth = 0;
	map_state->u_forward.tm2.max_lod = 0;
	map_state->u_forward.tm2.cube_face = 0;
	map_state->u_forward.tm0.base_address =
		(privPast->bo->offset + UOFFSET(context)) >> 2;
	drm_intel_bo_emit_reloc(pI915XvMC->msb_bo,
				offsetof(typeof(*map_state),u_forward.tm0),
				privPast->bo, UOFFSET(context),
				I915_GEM_DOMAIN_SAMPLER, 0);
	map_state->u_forward.tm2.pitch = (pI915XvMC->uvStride >> 2) - 1;	/* in DWords - 1 */

	/* U Backward */
	map_state->u_backward.tm0.v_ls_offset = 0;
	map_state->u_backward.tm0.v_ls = 0;
	map_state->u_backward.tm1.tile_walk = TILEWALK_XMAJOR;
	map_state->u_backward.tm1.tiled_surface = 0;
	map_state->u_backward.tm1.utilize_fence_regs = 0;
	map_state->u_backward.tm1.texel_fmt = 0;
	map_state->u_backward.tm1.surface_fmt = 1;
	map_state->u_backward.tm1.width = (w >> 1) - 1;
	map_state->u_backward.tm1.height = (h >> 1) - 1;
	map_state->u_backward.tm2.depth = 0;
	map_state->u_backward.tm2.max_lod = 0;
	map_state->u_backward.tm2.cube_face = 0;
	map_state->u_backward.tm0.base_address =
		(privFuture->bo->offset + UOFFSET(context)) >> 2;
	drm_intel_bo_emit_reloc(pI915XvMC->msb_bo,
				offsetof(typeof(*map_state),u_backward.tm0),
				privFuture->bo, UOFFSET(context),
				I915_GEM_DOMAIN_SAMPLER, 0);
	map_state->u_backward.tm2.pitch = (pI915XvMC->uvStride >> 2) - 1;

	/* 3DSATE_MAP_STATE: V */
	map_state->v_map.dw0.type = CMD_3D;
	map_state->v_map.dw0.opcode = OPC_3DSTATE_MAP_STATE;
	map_state->v_map.dw0.retain = 1;
	map_state->v_map.dw0.length = 6;
	map_state->v_map.dw1.map_mask = MAP_MAP0 | MAP_MAP1;

	/* V Forward */
	map_state->v_forward.tm0.v_ls_offset = 0;
	map_state->v_forward.tm0.v_ls = 0;
	map_state->v_forward.tm1.tile_walk = TILEWALK_XMAJOR;
	map_state->v_forward.tm1.tiled_surface = 0;
	map_state->v_forward.tm1.utilize_fence_regs = 0;
	map_state->v_forward.tm1.texel_fmt = 0;
	map_state->v_forward.tm1.surface_fmt = 1;
	map_state->v_forward.tm1.width = (w >> 1) - 1;
	map_state->v_forward.tm1.height = (h >> 1) - 1;
	map_state->v_forward.tm2.depth = 0;
	map_state->v_forward.tm2.max_lod = 0;
	map_state->v_forward.tm2.cube_face = 0;
	map_state->v_forward.tm0.base_address =
		(privPast->bo->offset + VOFFSET(context)) >> 2;
	drm_intel_bo_emit_reloc(pI915XvMC->msb_bo,
				offsetof(typeof(*map_state),v_forward.tm0),
				privPast->bo, VOFFSET(context),
				I915_GEM_DOMAIN_SAMPLER, 0);
	map_state->v_forward.tm2.pitch = (pI915XvMC->uvStride >> 2) - 1;	/* in DWords - 1 */

	/* V Backward */
	map_state->v_backward.tm0.v_ls_offset = 0;
	map_state->v_backward.tm0.v_ls = 0;
	map_state->v_backward.tm1.tile_walk = TILEWALK_XMAJOR;
	map_state->v_backward.tm1.tiled_surface = 0;
	map_state->v_backward.tm1.utilize_fence_regs = 0;
	map_state->v_backward.tm1.texel_fmt = 0;
	map_state->v_backward.tm1.surface_fmt = 1;
	map_state->v_backward.tm1.width = (w >> 1) - 1;
	map_state->v_backward.tm1.height = (h >> 1) - 1;
	map_state->v_backward.tm2.depth = 0;
	map_state->v_backward.tm2.max_lod = 0;
	map_state->v_backward.tm2.cube_face = 0;
	map_state->v_backward.tm0.base_address =
		(privFuture->bo->offset + VOFFSET(context)) >> 2;
	drm_intel_bo_emit_reloc(pI915XvMC->msb_bo,
				offsetof(typeof(*map_state),v_backward.tm0),
				privFuture->bo, VOFFSET(context),
				I915_GEM_DOMAIN_SAMPLER, 0);
	map_state->v_backward.tm2.pitch = (pI915XvMC->uvStride >> 2) - 1;

	drm_intel_gem_bo_unmap_gtt(pI915XvMC->msb_bo);
}

static void i915_mc_load_indirect_render_emit(XvMCContext * context)
{
	i915XvMCContext *pI915XvMC = (i915XvMCContext *) context->privData;
	int mem_select;
	uint32_t load_indirect;
	BATCH_LOCALS;

	BEGIN_BATCH(5);
	load_indirect = OP_3D_LOAD_INDIRECT;
	load_indirect |= (BLOCK_SIS | BLOCK_MSB) << BLOCK_MASK_SHIFT;
	load_indirect |= 5 - 2; /* length */

	if (pI915XvMC->use_phys_addr)
		mem_select = 0;	/* use physical address */
	else {
		load_indirect |= OP_3D_LOAD_INDIRECT_GFX_ADDR;
		mem_select = 1;	/* use gfx address */
	}
	OUT_BATCH(load_indirect);

	/* Static Indirect state buffer (dest buffer info) */
	OUT_RELOC(pI915XvMC->sis_bo, I915_GEM_DOMAIN_INSTRUCTION, 0,
			STATE_VALID | STATE_FORCE);
	OUT_BATCH(16);	/* 4 * 3 + 2 + 3 - 1 */

	/* Map state buffer (reference buffer info) */
	OUT_RELOC(pI915XvMC->msb_bo, I915_GEM_DOMAIN_INSTRUCTION, 0,
			STATE_VALID | STATE_FORCE);
	OUT_BATCH(23);	/* 3 * 8 - 1 */
	ADVANCE_BATCH();
}

static void i915_mc_mpeg_set_origin(XvMCContext * context, XvMCMacroBlock * mb)
{
	struct i915_3dmpeg_set_origin set_origin;

	/* 3DMPEG_SET_ORIGIN */
	memset(&set_origin, 0, sizeof(set_origin));
	set_origin.dw0.type = CMD_3D;
	set_origin.dw0.opcode = OPC_3DMPEG_SET_ORIGIN;
	set_origin.dw0.length = 0;
	set_origin.dw1.h_origin = mb->x;
	set_origin.dw1.v_origin = mb->y;

	intelBatchbufferData(&set_origin, sizeof(set_origin), 0);
}

static void i915_mc_mpeg_macroblock_ipicture(XvMCContext * context,
					     XvMCMacroBlock * mb)
{
	struct i915_3dmpeg_macroblock_ipicture macroblock_ipicture;

	/* 3DMPEG_MACROBLOCK_IPICTURE */
	memset(&macroblock_ipicture, 0, sizeof(macroblock_ipicture));
	macroblock_ipicture.dw0.type = CMD_3D;
	macroblock_ipicture.dw0.opcode = OPC_3DMPEG_MACROBLOCK_IPICTURE;
	macroblock_ipicture.dw0.dct_type =
	    (mb->dct_type == XVMC_DCT_TYPE_FIELD);

	intelBatchbufferData(&macroblock_ipicture, sizeof(macroblock_ipicture),
			     0);
}

static void i915_mc_mpeg_macroblock_1fbmv(XvMCContext * context,
					  XvMCMacroBlock * mb)
{
	struct i915_3dmpeg_macroblock_1fbmv macroblock_1fbmv;
	vector_t mv0[2];

	/* 3DMPEG_MACROBLOCK(1fbmv) */
	memset(&macroblock_1fbmv, 0, sizeof(macroblock_1fbmv));
	macroblock_1fbmv.header.dw0.type = CMD_3D;
	macroblock_1fbmv.header.dw0.opcode = OPC_3DMPEG_MACROBLOCK;
	macroblock_1fbmv.header.dw0.length = 2;
	macroblock_1fbmv.header.dw1.mb_intra = 0;	/* should be 0 */
	macroblock_1fbmv.header.dw1.forward =
	    ((mb->macroblock_type & XVMC_MB_TYPE_MOTION_FORWARD) ? 1 : 0);
	macroblock_1fbmv.header.dw1.backward =
	    ((mb->macroblock_type & XVMC_MB_TYPE_MOTION_BACKWARD) ? 1 : 0);
	macroblock_1fbmv.header.dw1.h263_4mv = 0;	/* should be 0 */
	macroblock_1fbmv.header.dw1.dct_type =
	    (mb->dct_type == XVMC_DCT_TYPE_FIELD);

	if (!(mb->coded_block_pattern & 0x3f))
		macroblock_1fbmv.header.dw1.dct_type = XVMC_DCT_TYPE_FRAME;

	macroblock_1fbmv.header.dw1.motion_type = (mb->motion_type & 0x03);
	macroblock_1fbmv.header.dw1.vertical_field_select =
	    (mb->motion_vertical_field_select & 0x0f);
	macroblock_1fbmv.header.dw1.coded_block_pattern =
	    mb->coded_block_pattern;
	macroblock_1fbmv.header.dw1.skipped_macroblocks = 0;

	mv0[0].component[0] = mb->PMV[0][0][0];
	mv0[0].component[1] = mb->PMV[0][0][1];
	mv0[1].component[0] = mb->PMV[0][1][0];
	mv0[1].component[1] = mb->PMV[0][1][1];

	macroblock_1fbmv.dw2 = mv0[0].v;
	macroblock_1fbmv.dw3 = mv0[1].v;

	intelBatchbufferData(&macroblock_1fbmv, sizeof(macroblock_1fbmv), 0);
}

static void i915_mc_mpeg_macroblock_2fbmv(XvMCContext * context,
					  XvMCMacroBlock * mb, unsigned int ps)
{
	struct i915_3dmpeg_macroblock_2fbmv macroblock_2fbmv;
	vector_t mv0[2];
	vector_t mv1[2];

	/* 3DMPEG_MACROBLOCK(2fbmv) */
	memset(&macroblock_2fbmv, 0, sizeof(macroblock_2fbmv));
	macroblock_2fbmv.header.dw0.type = CMD_3D;
	macroblock_2fbmv.header.dw0.opcode = OPC_3DMPEG_MACROBLOCK;
	macroblock_2fbmv.header.dw0.length = 4;
	macroblock_2fbmv.header.dw1.mb_intra = 0;	/* should be 0 */
	macroblock_2fbmv.header.dw1.forward =
	    ((mb->macroblock_type & XVMC_MB_TYPE_MOTION_FORWARD) ? 1 : 0);
	macroblock_2fbmv.header.dw1.backward =
	    ((mb->macroblock_type & XVMC_MB_TYPE_MOTION_BACKWARD) ? 1 : 0);
	macroblock_2fbmv.header.dw1.h263_4mv = 0;	/* should be 0 */
	macroblock_2fbmv.header.dw1.dct_type =
	    (mb->dct_type == XVMC_DCT_TYPE_FIELD);

	if (!(mb->coded_block_pattern & 0x3f))
		macroblock_2fbmv.header.dw1.dct_type = XVMC_DCT_TYPE_FRAME;

	macroblock_2fbmv.header.dw1.motion_type = (mb->motion_type & 0x03);
	macroblock_2fbmv.header.dw1.vertical_field_select =
	    (mb->motion_vertical_field_select & 0x0f);
	macroblock_2fbmv.header.dw1.coded_block_pattern =
	    mb->coded_block_pattern;
	macroblock_2fbmv.header.dw1.skipped_macroblocks = 0;

	mv0[0].component[0] = mb->PMV[0][0][0];
	mv0[0].component[1] = mb->PMV[0][0][1];
	mv0[1].component[0] = mb->PMV[0][1][0];
	mv0[1].component[1] = mb->PMV[0][1][1];
	mv1[0].component[0] = mb->PMV[1][0][0];
	mv1[0].component[1] = mb->PMV[1][0][1];
	mv1[1].component[0] = mb->PMV[1][1][0];
	mv1[1].component[1] = mb->PMV[1][1][1];

	if ((ps & XVMC_FRAME_PICTURE) == XVMC_FRAME_PICTURE) {
		if ((mb->motion_type & 3) == XVMC_PREDICTION_FIELD) {
			mv0[0].component[1] = mb->PMV[0][0][1] >> 1;
			mv0[1].component[1] = mb->PMV[0][1][1] >> 1;
			mv1[0].component[1] = mb->PMV[1][0][1] >> 1;
			mv1[1].component[1] = mb->PMV[1][1][1] >> 1;
		} else if ((mb->motion_type & 3) == XVMC_PREDICTION_DUAL_PRIME) {
			mv0[0].component[1] = mb->PMV[0][0][1] >> 1;
			mv0[1].component[1] = mb->PMV[0][1][1] >> 1;	// MPEG2 MV[0][1] isn't used
			mv1[0].component[1] = mb->PMV[1][0][1] >> 1;
			mv1[1].component[1] = mb->PMV[1][1][1] >> 1;
		}
	}

	macroblock_2fbmv.dw2 = mv0[0].v;
	macroblock_2fbmv.dw3 = mv0[1].v;
	macroblock_2fbmv.dw4 = mv1[0].v;
	macroblock_2fbmv.dw5 = mv1[1].v;

	intelBatchbufferData(&macroblock_2fbmv, sizeof(macroblock_2fbmv), 0);
}

static int i915_xvmc_alloc_one_time_buffers(i915XvMCContext *pI915XvMC)
{
	pI915XvMC->ssb_bo = drm_intel_bo_alloc(xvmc_driver->bufmgr,
					       "ssb",
					       GTT_PAGE_SIZE,
					       GTT_PAGE_SIZE);
	if (!pI915XvMC->ssb_bo)
		return 0;

	pI915XvMC->psp_bo = drm_intel_bo_alloc(xvmc_driver->bufmgr,
					       "psp",
					       GTT_PAGE_SIZE,
					       GTT_PAGE_SIZE);
	if (!pI915XvMC->psp_bo)
		return 0;

	pI915XvMC->psc_bo = drm_intel_bo_alloc(xvmc_driver->bufmgr,
					       "psc",
					       GTT_PAGE_SIZE,
					       GTT_PAGE_SIZE);
	if (!pI915XvMC->psc_bo)
		return 0;

	return 1;
}

static void i915_xvmc_free_one_time_buffers(i915XvMCContext *pI915XvMC)
{
	drm_intel_bo_unreference(pI915XvMC->ssb_bo);
	drm_intel_bo_unreference(pI915XvMC->psp_bo);
	drm_intel_bo_unreference(pI915XvMC->psc_bo);
}

/*
 * Function: i915_release_resource
 */
static void i915_release_resource(Display * display, XvMCContext * context)
{
	i915XvMCContext *pI915XvMC;

	if (!(pI915XvMC = context->privData))
		return;

	i915_xvmc_free_one_time_buffers(pI915XvMC);

	free(pI915XvMC);
	context->privData = NULL;
}

static Status i915_xvmc_mc_create_context(Display * display,
					  XvMCContext * context, int priv_count,
					  CARD32 * priv_data)
{
	i915XvMCContext *pI915XvMC = NULL;
	struct intel_xvmc_hw_context *tmpComm = NULL;

	if (priv_count != (sizeof(struct intel_xvmc_hw_context) >> 2)) {
		XVMC_ERR
		    ("_xvmc_create_context() returned incorrect data size!");
		XVMC_INFO("\tExpected %d, got %d",
			  (int)(sizeof(struct intel_xvmc_hw_context) >> 2),
			  priv_count);
		_xvmc_destroy_context(display, context);
		XFree(priv_data);
		context->privData = NULL;
		return BadValue;
	}

	context->privData = (void *)calloc(1, sizeof(i915XvMCContext));
	if (!context->privData) {
		XVMC_ERR("Unable to allocate resources for XvMC context.");
		return BadAlloc;
	}
	pI915XvMC = (i915XvMCContext *) context->privData;

	tmpComm = (struct intel_xvmc_hw_context *) priv_data;
	pI915XvMC->use_phys_addr = tmpComm->i915.use_phys_addr;
	pI915XvMC->comm.surface_bo_size = SIZE_YUV420(context->width,
						      context->height);

	/* Must free the private data we were passed from X */
	XFree(priv_data);
	priv_data = NULL;

	if (!i915_xvmc_alloc_one_time_buffers(pI915XvMC))
		goto free_one_time_buffers;

	/* Initialize private context values */
	pI915XvMC->yStride = STRIDE(context->width);
	pI915XvMC->uvStride = STRIDE(context->width >> 1);

	/* pre-init state buffers */
	i915_mc_one_time_context_init(context);

	return Success;

free_one_time_buffers:
	i915_xvmc_free_one_time_buffers(pI915XvMC);
	free(pI915XvMC);
	context->privData = NULL;
	return BadAlloc;
}

static int i915_xvmc_mc_destroy_context(Display * display,
					XvMCContext * context)
{
	i915XvMCContext *pI915XvMC;

	if (!(pI915XvMC = context->privData))
		return XvMCBadContext;

	/* Pass Control to the X server to destroy the drm_context_t */
	i915_release_resource(display, context);

	return Success;
}

static int i915_xvmc_alloc_render_state_buffers(i915XvMCContext *pI915XvMC)
{
	pI915XvMC->sis_bo = drm_intel_bo_alloc(xvmc_driver->bufmgr,
					       "sis",
					       GTT_PAGE_SIZE,
					       GTT_PAGE_SIZE);
	if (!pI915XvMC->sis_bo)
		return 0;

	pI915XvMC->msb_bo = drm_intel_bo_alloc(xvmc_driver->bufmgr,
					       "msb",
					       GTT_PAGE_SIZE,
					       GTT_PAGE_SIZE);
	if (!pI915XvMC->msb_bo)
		return 0;

	pI915XvMC->corrdata_bo = drm_intel_bo_alloc(xvmc_driver->bufmgr,
					       "corrdata",
					       CORRDATA_SIZE,
					       GTT_PAGE_SIZE);
	if (!pI915XvMC->corrdata_bo)
		return 0;

	return 1;
}

static void i915_xvmc_free_render_state_buffers(i915XvMCContext *pI915XvMC)
{
	drm_intel_bo_unreference(pI915XvMC->sis_bo);
	drm_intel_bo_unreference(pI915XvMC->msb_bo);
	drm_intel_bo_unreference(pI915XvMC->corrdata_bo);
}

static int i915_xvmc_mc_render_surface(Display * display, XvMCContext * context,
				       unsigned int picture_structure,
				       XvMCSurface * target_surface,
				       XvMCSurface * past_surface,
				       XvMCSurface * future_surface,
				       unsigned int flags,
				       unsigned int num_macroblocks,
				       unsigned int first_macroblock,
				       XvMCMacroBlockArray * macroblock_array,
				       XvMCBlockArray * blocks)
{
	int i;
	int picture_coding_type = MPEG_I_PICTURE;
	/* correction data buffer */
	char *corrdata_ptr;
	int corrdata_size = 0;

	/* Block Pointer */
	short *block_ptr;
	/* Current Macroblock Pointer */
	XvMCMacroBlock *mb;

	intel_xvmc_context_ptr intel_ctx;

	struct intel_xvmc_surface *privTarget = NULL;
	struct intel_xvmc_surface *privFuture = NULL;
	struct intel_xvmc_surface *privPast = NULL;
	i915XvMCContext *pI915XvMC = NULL;

	/* Check Parameters for validity */
	if (!display || !context || !target_surface) {
		XVMC_ERR("Invalid Display, Context or Target!");
		return BadValue;
	}

	if (!num_macroblocks)
		return Success;

	if (!macroblock_array || !blocks) {
		XVMC_ERR("Invalid block data!");
		return BadValue;
	}

	if (macroblock_array->num_blocks < (num_macroblocks + first_macroblock)) {
		XVMC_ERR("Too many macroblocks requested for MB array size.");
		return BadValue;
	}

	if (!(pI915XvMC = context->privData))
		return XvMCBadContext;

	if (!(privTarget = target_surface->privData))
		return XvMCBadSurface;

	if (!i915_xvmc_alloc_render_state_buffers(pI915XvMC))
		return BadAlloc;

	intel_ctx = context->privData;
	if (!intel_ctx) {
		XVMC_ERR("Can't find intel xvmc context\n");
		return BadValue;
	}

	/* P Frame Test */
	if (!past_surface) {
		/* Just to avoid some ifs later. */
		privPast = privTarget;
	} else {
		if (!(privPast = past_surface->privData)) {
			return XvMCBadSurface;
		}
		picture_coding_type = MPEG_P_PICTURE;
	}

	/* B Frame Test */
	if (!future_surface) {
		privFuture = privPast;	// privTarget;
	} else {
		if (!past_surface) {
			XVMC_ERR("No Past Surface!");
			return BadValue;
		}

		if (!(privFuture = future_surface->privData)) {
			XVMC_ERR("Invalid Future Surface!");
			return XvMCBadSurface;
		}

		picture_coding_type = MPEG_B_PICTURE;
	}

	LOCK_HARDWARE(intel_ctx->hw_context);
	drm_intel_gem_bo_map_gtt(pI915XvMC->corrdata_bo);
	corrdata_ptr = pI915XvMC->corrdata_bo->virtual;
	corrdata_size = 0;

	for (i = first_macroblock; i < (num_macroblocks + first_macroblock);
	     i++) {
		int bspm = 0;
		mb = &macroblock_array->macro_blocks[i];
		block_ptr = &(blocks->blocks[mb->index << 6]);

		/* Lockup can happen if the coordinates are too far out of range */
		if (mb->x > (target_surface->width >> 4)) {
			mb->x = 0;
			XVMC_INFO("reset x");
		}

		if (mb->y > (target_surface->height >> 4)) {
			mb->y = 0;
			XVMC_INFO("reset y");
		}

		/* Catch no pattern case */
		if (!(mb->macroblock_type & XVMC_MB_TYPE_PATTERN) &&
		    !(mb->macroblock_type & XVMC_MB_TYPE_INTRA) &&
		    mb->coded_block_pattern) {
			mb->coded_block_pattern = 0;
			XVMC_INFO("no coded blocks present!");
		}

		bspm = mb_bytes_420[mb->coded_block_pattern];

		if (!bspm)
			continue;

		corrdata_size += bspm;

		if (corrdata_size > CORRDATA_SIZE) {
			XVMC_ERR("correction data buffer overflow.");
			break;
		}
		memcpy(corrdata_ptr, block_ptr, bspm);
		corrdata_ptr += bspm;
	}

	drm_intel_gem_bo_unmap_gtt(pI915XvMC->corrdata_bo);

	// i915_mc_invalidate_subcontext_buffers(context, BLOCK_SIS | BLOCK_DIS | BLOCK_SSB
	// | BLOCK_MSB | BLOCK_PSP | BLOCK_PSC);

	i915_mc_one_time_state_emit(context);

	i915_mc_static_indirect_state_set(context, target_surface,
					  picture_structure, flags,
					  picture_coding_type);
	/* setup reference surfaces */
	i915_mc_map_state_set(context, privPast, privFuture);

	i915_mc_load_indirect_render_emit(context);

	i915_mc_mpeg_set_origin(context,
				&macroblock_array->macro_blocks
				[first_macroblock]);

	for (i = first_macroblock; i < (num_macroblocks + first_macroblock);
	     i++) {
		mb = &macroblock_array->macro_blocks[i];

		/* Intra Blocks */
		if (mb->macroblock_type & XVMC_MB_TYPE_INTRA) {
			i915_mc_mpeg_macroblock_ipicture(context, mb);
		} else if ((picture_structure & XVMC_FRAME_PICTURE) ==
			   XVMC_FRAME_PICTURE) {
			/* Frame Picture */
			switch (mb->motion_type & 3) {
			case XVMC_PREDICTION_FIELD:	/* Field Based */
				i915_mc_mpeg_macroblock_2fbmv(context, mb,
							      picture_structure);
				break;

			case XVMC_PREDICTION_FRAME:	/* Frame Based */
				i915_mc_mpeg_macroblock_1fbmv(context, mb);
				break;

			case XVMC_PREDICTION_DUAL_PRIME:	/* Dual Prime */
				i915_mc_mpeg_macroblock_2fbmv(context, mb,
							      picture_structure);
				break;

			default:	/* No Motion Type */
				XVMC_ERR
				    ("Invalid Macroblock Parameters found.");
				break;
			}
		} else {	/* Field Picture */
			switch (mb->motion_type & 3) {
			case XVMC_PREDICTION_FIELD:	/* Field Based */
				i915_mc_mpeg_macroblock_1fbmv(context, mb);
				break;

			case XVMC_PREDICTION_16x8:	/* 16x8 MC */
				i915_mc_mpeg_macroblock_2fbmv(context, mb,
							      picture_structure);
				break;

			case XVMC_PREDICTION_DUAL_PRIME:	/* Dual Prime */
				i915_mc_mpeg_macroblock_1fbmv(context, mb);
				break;

			default:	/* No Motion Type */
				XVMC_ERR
				    ("Invalid Macroblock Parameters found.");
				break;
			}
		}
	}

	intelFlushBatch(TRUE);

	i915_xvmc_free_render_state_buffers(pI915XvMC);

	UNLOCK_HARDWARE(intel_ctx->hw_context);
	return 0;
}

struct _intel_xvmc_driver i915_xvmc_mc_driver = {
	.type = XVMC_I915_MPEG2_MC,
	.num_ctx = 0,
	.ctx_list = NULL,
	.create_context = i915_xvmc_mc_create_context,
	.destroy_context = i915_xvmc_mc_destroy_context,
	.render_surface = i915_xvmc_mc_render_surface,
};
@


1.6
log
@Update the intel driver to a more recent version based on more recent
upsteam code.

Backporting keeping UMS changes by me, some bugfixes from kettenis@@.

Has been in snapshots for a while, committed on request so we can be
sure what people are running. This is a prerequesite for sandybridge
support but has those chipsets disabled for now until the correct code
has been added.
@
text
@@


1.5
log
@Pull in the changes in rendering that I skipped when i backported
changes from later intel versions (after the UMS removal). 95% of this
is the xvmc reworks that makes that code even halfway sane. xvmc is now
enabled by default on 965+.

Tested by many on tech@@, thanks!

ok matthieu@@
@
text
@d34 3
a36 1
#define STRIDE(w)               (((w) + 0x3ff) & ~0x3ff)
a393 1
	unsigned int w = dest->width;
d690 1
a690 1
	uint32_t load_indirect, buffer_address;
@


1.4
log
@Update the intel driver to 2.9.1 plus backports.

2.9.1 is the last version of the intel DDX that supports UMS (User
modesetting), with 2.10 onwards being purely KMS only. As such, this
driver contains backports of almost every correctness or performance
related fix to the rendering layer in later intel drivers. This driver
*REQUIRES* a GEM enabled kernel. it claims to support non-gem mode but
this is essentially unmaintained and due to the way the abstraciton
works is slow, if it works at all (it often does not). You have been
warned.

tested by many many people on tech over the last few weeks.
@
text
@d34 7
a40 6
#define YOFFSET(surface)        (surface->srf.offset)
#define UOFFSET(surface)        (surface->srf.offset + \
                                 SIZE_Y420(surface->width, surface->height) + \
                                 SIZE_UV420(surface->width, surface->height))
#define VOFFSET(surface)        (surface->srf.offset + \
                                 SIZE_Y420(surface->width, surface->height))
a46 38
#if 0
static int findOverlap(unsigned int width, unsigned int height,
		       short *dstX, short *dstY,
		       short *srcX, short *srcY,
		       unsigned short *areaW, unsigned short *areaH)
{
	int w, h;
	unsigned int mWidth, mHeight;

	w = *areaW;
	h = *areaH;

	if ((*dstX >= width) || (*dstY >= height))
		return 1;

	if (*dstX < 0) {
		w += *dstX;
		*srcX -= *dstX;
		*dstX = 0;
	}

	if (*dstY < 0) {
		h += *dstY;
		*srcY -= *dstY;
		*dstY = 0;
	}

	if ((w <= 0) || ((h <= 0)))
		return 1;

	mWidth = width - *dstX;
	mHeight = height - *dstY;
	*areaW = (w <= mWidth) ? w : mWidth;
	*areaH = (h <= mHeight) ? h : mHeight;
	return 0;
}
#endif

a88 14
static void i915_emit_batch(void *data, int size, int flag)
{
	intelBatchbufferData(data, size, flag);
}

/* one time context initialization buffer */
static uint32_t *one_time_load_state_imm1;
static uint32_t *one_time_load_indirect;
static int one_time_load_state_imm1_size, one_time_load_indirect_size;

/* load indirect buffer for mc rendering */
static uint32_t *mc_render_load_indirect;
static int mc_render_load_indirect_size;

d99 2
a100 7
	sampler_state = (struct i915_3dstate_sampler_state *)pI915XvMC->ssb.map;
	/* pixel shader static state */
	pixel_shader_program =
	    (struct i915_3dstate_pixel_shader_program *)pI915XvMC->psp.map;
	/* pixel shader contant static state */
	pixel_shader_constants =
	    (struct i915_3dstate_pixel_shader_constants *)pI915XvMC->psc.map;
d156 6
d303 6
d319 1
d322 1
a322 1
static void i915_mc_one_time_state_init(XvMCContext * context)
a323 6
	struct s3_dword *s3 = NULL;
	struct s6_dword *s6 = NULL;
	dis_state *dis = NULL;
	ssb_state *ssb = NULL;
	psp_state *psp = NULL;
	psc_state *psc = NULL;
d325 1
a325 2
	struct i915_3dstate_load_state_immediate_1 *load_state_immediate_1;
	struct i915_3dstate_load_indirect *load_indirect;
d327 1
d330 17
a346 35
	one_time_load_state_imm1_size =
	    sizeof(*load_state_immediate_1) + sizeof(*s3) + sizeof(*s6);
	one_time_load_state_imm1 = calloc(1, one_time_load_state_imm1_size);
	load_state_immediate_1 = (struct i915_3dstate_load_state_immediate_1 *)
	    one_time_load_state_imm1;
	load_state_immediate_1->dw0.type = CMD_3D;
	load_state_immediate_1->dw0.opcode = OPC_3DSTATE_LOAD_STATE_IMMEDIATE_1;
	load_state_immediate_1->dw0.load_s3 = 1;
	load_state_immediate_1->dw0.load_s6 = 1;
	load_state_immediate_1->dw0.length =
	    (one_time_load_state_imm1_size >> 2) - 2;

	s3 = (struct s3_dword *)(++load_state_immediate_1);
	s3->set0_pcd = 1;
	s3->set1_pcd = 1;
	s3->set2_pcd = 1;
	s3->set3_pcd = 1;
	s3->set4_pcd = 1;
	s3->set5_pcd = 1;
	s3->set6_pcd = 1;
	s3->set7_pcd = 1;

	s6 = (struct s6_dword *)(++s3);
	s6->alpha_test_enable = 0;
	s6->alpha_test_function = 0;
	s6->alpha_reference_value = 0;
	s6->depth_test_enable = 1;
	s6->depth_test_function = 0;
	s6->color_buffer_blend = 0;
	s6->color_blend_function = 0;
	s6->src_blend_factor = 1;
	s6->dest_blend_factor = 1;
	s6->depth_buffer_write = 0;
	s6->color_buffer_write = 1;
	s6->triangle_pv = 0;
d349 4
a352 11
	one_time_load_indirect_size =
	    sizeof(*load_indirect) + sizeof(*dis) + sizeof(*ssb) +
	    sizeof(*psp) + sizeof(*psc);
	one_time_load_indirect = calloc(1, one_time_load_indirect_size);
	load_indirect =
	    (struct i915_3dstate_load_indirect *)one_time_load_indirect;
	load_indirect->dw0.type = CMD_3D;
	load_indirect->dw0.opcode = OPC_3DSTATE_LOAD_INDIRECT;
	load_indirect->dw0.block_mask =
	    BLOCK_DIS | BLOCK_SSB | BLOCK_PSP | BLOCK_PSC;
	load_indirect->dw0.length = (one_time_load_indirect_size >> 2) - 2;
d354 1
a354 2
	if (pI915XvMC->deviceID == PCI_CHIP_I915_G ||
	    pI915XvMC->deviceID == PCI_CHIP_I915_GM)
d356 2
a357 1
	else
d359 1
d361 1
a361 1
	load_indirect->dw0.mem_select = mem_select;
d364 1
a364 4
	dis = (dis_state *) (++load_indirect);
	dis->dw0.valid = 0;
	dis->dw0.reset = 0;
	dis->dw0.buffer_address = 0;
d367 3
a369 9
	ssb = (ssb_state *) (++dis);
	ssb->dw0.valid = 1;
	ssb->dw0.force = 1;
	ssb->dw1.length = 7;	/* 8 - 1 */

	if (mem_select)
		ssb->dw0.buffer_address = (pI915XvMC->ssb.offset >> 2);
	else
		ssb->dw0.buffer_address = (pI915XvMC->ssb.bus_addr >> 2);
d372 3
a374 9
	psp = (psp_state *) (++ssb);
	psp->dw0.valid = 1;
	psp->dw0.force = 1;
	psp->dw1.length = 66;	/* 4 + 16 + 16 + 31 - 1 */

	if (mem_select)
		psp->dw0.buffer_address = (pI915XvMC->psp.offset >> 2);
	else
		psp->dw0.buffer_address = (pI915XvMC->psp.bus_addr >> 2);
d377 4
a380 9
	psc = (psc_state *) (++psp);
	psc->dw0.valid = 1;
	psc->dw0.force = 1;
	psc->dw1.length = 5;	/* 6 - 1 */

	if (mem_select)
		psc->dw0.buffer_address = (pI915XvMC->psc.offset >> 2);
	else
		psc->dw0.buffer_address = (pI915XvMC->psc.bus_addr >> 2);
d383 5
a387 1
static void i915_mc_one_time_state_emit(void)
d389 4
a392 4
	i915_emit_batch(one_time_load_state_imm1, one_time_load_state_imm1_size,
			0);
	i915_emit_batch(one_time_load_indirect, one_time_load_indirect_size, 0);
}
d394 2
a395 5
static void i915_mc_static_indirect_state_init(XvMCContext * context)
{
	i915XvMCContext *pI915XvMC = (i915XvMCContext *) context->privData;
	struct i915_mc_static_indirect_state_buffer *buffer_info =
	    (struct i915_mc_static_indirect_state_buffer *)pI915XvMC->sis.map;
d398 1
d408 7
d425 8
d443 8
d452 1
d461 9
d471 1
a485 42
	buffer_info->corr.dw0.type = CMD_3D;
	buffer_info->corr.dw0.opcode = OPC_3DSTATE_BUFFER_INFO;
	buffer_info->corr.dw0.length = 1;
	buffer_info->corr.dw1.aux_id = 0;
	buffer_info->corr.dw1.buffer_id = BUFFERID_MC_INTRA_CORR;
	buffer_info->corr.dw1.aux_id = 0;
	buffer_info->corr.dw1.fence_regs = 0;
	buffer_info->corr.dw1.tiled_surface = 0;
	buffer_info->corr.dw1.walk = 0;
	buffer_info->corr.dw1.pitch = 0;
	buffer_info->corr.dw2.base_address = (pI915XvMC->corrdata.offset >> 2);	/* starting DWORD address */
}

static void i915_mc_static_indirect_state_set(XvMCContext * context,
					      XvMCSurface * dest,
					      unsigned int picture_structure,
					      unsigned int flags,
					      unsigned int picture_coding_type)
{
	i915XvMCContext *pI915XvMC = (i915XvMCContext *) context->privData;
	i915XvMCSurface *pI915Surface = (i915XvMCSurface *) dest->privData;
	struct i915_mc_static_indirect_state_buffer *buffer_info =
	    (struct i915_mc_static_indirect_state_buffer *)pI915XvMC->sis.map;
	unsigned int w = dest->width;

	buffer_info->dest_y.dw1.pitch = (pI915Surface->yStride >> 2);	/* in DWords */
	buffer_info->dest_y.dw2.base_address = (YOFFSET(pI915Surface) >> 2);	/* starting DWORD address */
	buffer_info->dest_u.dw1.pitch = (pI915Surface->uvStride >> 2);	/* in DWords */
	buffer_info->dest_u.dw2.base_address = (UOFFSET(pI915Surface) >> 2);	/* starting DWORD address */
	buffer_info->dest_v.dw1.pitch = (pI915Surface->uvStride >> 2);	/* in Dwords */
	buffer_info->dest_v.dw2.base_address = (VOFFSET(pI915Surface) >> 2);	/* starting DWORD address */

	if ((picture_structure & XVMC_FRAME_PICTURE) == XVMC_FRAME_PICTURE) {
		;
	} else if ((picture_structure & XVMC_FRAME_PICTURE) == XVMC_TOP_FIELD) {
		buffer_info->dest_buf.dw1.v_ls = 1;
	} else if ((picture_structure & XVMC_FRAME_PICTURE) ==
		   XVMC_BOTTOM_FIELD) {
		buffer_info->dest_buf.dw1.v_ls = 1;
		buffer_info->dest_buf.dw1.v_ls_offset = 1;
	}

d503 18
d523 3
a525 1
static void i915_mc_map_state_init(XvMCContext * context)
d528 1
a530 1
	struct i915_mc_map_state *map_state;
d532 2
a533 1
	map_state = (struct i915_mc_map_state *)pI915XvMC->msb.map;
d557 6
d577 6
d604 7
d625 7
d653 7
d674 7
a680 34
}

static void i915_mc_map_state_set(XvMCContext * context,
				  i915XvMCSurface * privPast,
				  i915XvMCSurface * privFuture)
{
	i915XvMCContext *pI915XvMC = (i915XvMCContext *) context->privData;
	struct i915_mc_map_state *map_state;

	map_state = (struct i915_mc_map_state *)pI915XvMC->msb.map;

	map_state->y_forward.tm0.base_address = (YOFFSET(privPast) >> 2);
	map_state->y_forward.tm2.pitch = (privPast->yStride >> 2) - 1;	/* in DWords - 1 */
	map_state->y_backward.tm0.base_address = (YOFFSET(privFuture) >> 2);
	map_state->y_backward.tm2.pitch = (privFuture->yStride >> 2) - 1;
	map_state->u_forward.tm0.base_address = (UOFFSET(privPast) >> 2);
	map_state->u_forward.tm2.pitch = (privPast->uvStride >> 2) - 1;	/* in DWords - 1 */
	map_state->u_backward.tm0.base_address = (UOFFSET(privFuture) >> 2);
	map_state->u_backward.tm2.pitch = (privFuture->uvStride >> 2) - 1;
	map_state->v_forward.tm0.base_address = (VOFFSET(privPast) >> 2);
	map_state->v_forward.tm2.pitch = (privPast->uvStride >> 2) - 1;	/* in DWords - 1 */
	map_state->v_backward.tm0.base_address = (VOFFSET(privFuture) >> 2);
	map_state->v_backward.tm2.pitch = (privFuture->uvStride >> 2) - 1;
}

static void i915_flush(int map, int render)
{
	struct i915_mi_flush mi_flush;

	memset(&mi_flush, 0, sizeof(mi_flush));
	mi_flush.dw0.type = CMD_MI;
	mi_flush.dw0.opcode = OPC_MI_FLUSH;
	mi_flush.dw0.map_cache_invalidate = map;
	mi_flush.dw0.render_cache_flush_inhibit = render;
d682 1
a682 1
	intelBatchbufferData(&mi_flush, sizeof(mi_flush), 0);
d685 1
a685 1
static void i915_mc_load_indirect_render_init(XvMCContext * context)
a687 3
	sis_state *sis;
	msb_state *msb;
	struct i915_3dstate_load_indirect *load_indirect;
d689 2
d692 4
a695 16
	mc_render_load_indirect_size = sizeof(*load_indirect) + sizeof(*sis)
	    + sizeof(*msb);
	mc_render_load_indirect = calloc(1, mc_render_load_indirect_size);

	load_indirect =
	    (struct i915_3dstate_load_indirect *)mc_render_load_indirect;
	load_indirect->dw0.type = CMD_3D;
	load_indirect->dw0.opcode = OPC_3DSTATE_LOAD_INDIRECT;
	load_indirect->dw0.block_mask = BLOCK_SIS | BLOCK_MSB;
	load_indirect->dw0.length = (mc_render_load_indirect_size >> 2) - 2;

	if (pI915XvMC->deviceID == PCI_CHIP_I915_G ||
	    pI915XvMC->deviceID == PCI_CHIP_I915_GM)
		mem_select = 0;
	else
		mem_select = 1;
d697 7
a703 1
	load_indirect->dw0.mem_select = mem_select;
d706 3
a708 9
	sis = (sis_state *) (++load_indirect);
	sis->dw0.valid = 1;
	sis->dw0.force = 1;
	sis->dw1.length = 16;	/* 4 * 3 + 2 + 3 - 1 */

	if (mem_select)
		sis->dw0.buffer_address = (pI915XvMC->sis.offset >> 2);
	else
		sis->dw0.buffer_address = (pI915XvMC->sis.bus_addr >> 2);
d711 4
a714 15
	msb = (msb_state *) (++sis);
	msb->dw0.valid = 1;
	msb->dw0.force = 1;
	msb->dw1.length = 23;	/* 3 * 8 - 1 */

	if (mem_select)
		msb->dw0.buffer_address = (pI915XvMC->msb.offset >> 2);
	else
		msb->dw0.buffer_address = (pI915XvMC->msb.bus_addr >> 2);
}

static void i915_mc_load_indirect_render_emit(void)
{
	i915_emit_batch(mc_render_load_indirect, mc_render_load_indirect_size,
			0);
a747 32
#if 0
static void i915_mc_mpeg_macroblock_0mv(XvMCContext * context,
					XvMCMacroBlock * mb)
{
	struct i915_3dmpeg_macroblock_0mv macroblock_0mv;

	/* 3DMPEG_MACROBLOCK(0mv) */
	memset(&macroblock_0mv, 0, sizeof(macroblock_0mv));
	macroblock_0mv.header.dw0.type = CMD_3D;
	macroblock_0mv.header.dw0.opcode = OPC_3DMPEG_MACROBLOCK;
	macroblock_0mv.header.dw0.length = 0;
	macroblock_0mv.header.dw1.mb_intra = 1;	/* should be 1 */
	macroblock_0mv.header.dw1.forward = 0;	/* should be 0 */
	macroblock_0mv.header.dw1.backward = 0;	/* should be 0 */
	macroblock_0mv.header.dw1.h263_4mv = 0;	/* should be 0 */
	macroblock_0mv.header.dw1.dct_type =
	    (mb->dct_type == XVMC_DCT_TYPE_FIELD);

/*
    if (!mb->coded_block_pattern)
        macroblock_0mv.header.dw1.dct_type = XVMC_DCT_TYPE_FRAME;
*/

	macroblock_0mv.header.dw1.motion_type = 0;	// (mb->motion_type & 0x3);
	macroblock_0mv.header.dw1.vertical_field_select = 0;	// mb->motion_vertical_field_select & 0xf;
	macroblock_0mv.header.dw1.coded_block_pattern = mb->coded_block_pattern;
	macroblock_0mv.header.dw1.skipped_macroblocks = 0;

	intelBatchbufferData(&macroblock_0mv, sizeof(macroblock_0mv), 0);
}
#endif

d851 1
a851 3
#if 0
static void i915_mc_invalidate_subcontext_buffers(XvMCContext * context,
						  unsigned int mask)
d853 29
a881 104
	struct i915_3dstate_load_indirect *load_indirect = NULL;
	sis_state *sis = NULL;
	dis_state *dis = NULL;
	ssb_state *ssb = NULL;
	msb_state *msb = NULL;
	psp_state *psp = NULL;
	psc_state *psc = NULL;
	i915XvMCContext *pI915XvMC = (i915XvMCContext *) context->privData;
	unsigned int size;
	void *base = NULL, *ptr = NULL;

	size = sizeof(*load_indirect);
	if (mask & BLOCK_SIS)
		size += sizeof(*sis);
	if (mask & BLOCK_DIS)
		size += sizeof(*dis);
	if (mask & BLOCK_SSB)
		size += sizeof(*ssb);
	if (mask & BLOCK_MSB)
		size += sizeof(*msb);
	if (mask & BLOCK_PSP)
		size += sizeof(*psp);
	if (mask & BLOCK_PSC)
		size += sizeof(*psc);

	if (size == sizeof(*load_indirect)) {
		XVMC_ERR("There must be at least one bit set\n");
		return;
	}

	/* 3DSTATE_LOAD_INDIRECT */
	base = calloc(1, size);
	load_indirect = (struct i915_3dstate_load_indirect *)base;
	load_indirect->dw0.type = CMD_3D;
	load_indirect->dw0.opcode = OPC_3DSTATE_LOAD_INDIRECT;

	if (pI915XvMC->deviceID == PCI_CHIP_I915_G ||
	    pI915XvMC->deviceID == PCI_CHIP_I915_GM ||
	    pI915XvMC->deviceID == PCI_CHIP_I945_G ||
	    pI915XvMC->deviceID == PCI_CHIP_I945_GM)
		load_indirect->dw0.mem_select = 0;
	else
		load_indirect->dw0.mem_select = 1;

	load_indirect->dw0.block_mask = mask;
	load_indirect->dw0.length = (size >> 2) - 2;
	ptr = ++load_indirect;

	/* SIS */
	if (mask & BLOCK_SIS) {
		sis = (sis_state *) ptr;
		sis->dw0.valid = 0;
		sis->dw0.buffer_address = 0;
		sis->dw1.length = 0;
		ptr = ++sis;
	}

	/* DIS */
	if (mask & BLOCK_DIS) {
		dis = (dis_state *) ptr;
		dis->dw0.valid = 0;
		dis->dw0.reset = 0;
		dis->dw0.buffer_address = 0;
		ptr = ++dis;
	}

	/* SSB */
	if (mask & BLOCK_SSB) {
		ssb = (ssb_state *) ptr;
		ssb->dw0.valid = 0;
		ssb->dw0.buffer_address = 0;
		ssb->dw1.length = 0;
		ptr = ++ssb;
	}

	/* MSB */
	if (mask & BLOCK_MSB) {
		msb = (msb_state *) ptr;
		msb->dw0.valid = 0;
		msb->dw0.buffer_address = 0;
		msb->dw1.length = 0;
		ptr = ++msb;
	}

	/* PSP */
	if (mask & BLOCK_PSP) {
		psp = (psp_state *) ptr;
		psp->dw0.valid = 0;
		psp->dw0.buffer_address = 0;
		psp->dw1.length = 0;
		ptr = ++psp;
	}

	/* PSC */
	if (mask & BLOCK_PSC) {
		psc = (psc_state *) ptr;
		psc->dw0.valid = 0;
		psc->dw0.buffer_address = 0;
		psc->dw1.length = 0;
		ptr = ++psc;
	}

	intelBatchbufferData(base, size, 0);
	free(base);
a882 519
#endif

static int i915_xvmc_map_buffers(i915XvMCContext * pI915XvMC)
{
	if (drmMap(xvmc_driver->fd,
		   pI915XvMC->sis.handle,
		   pI915XvMC->sis.size,
		   (drmAddress *) & pI915XvMC->sis.map) != 0) {
		return -1;
	}

	if (drmMap(xvmc_driver->fd,
		   pI915XvMC->ssb.handle,
		   pI915XvMC->ssb.size,
		   (drmAddress *) & pI915XvMC->ssb.map) != 0) {
		return -1;
	}

	if (drmMap(xvmc_driver->fd,
		   pI915XvMC->msb.handle,
		   pI915XvMC->msb.size,
		   (drmAddress *) & pI915XvMC->msb.map) != 0) {
		return -1;
	}

	if (drmMap(xvmc_driver->fd,
		   pI915XvMC->psp.handle,
		   pI915XvMC->psp.size,
		   (drmAddress *) & pI915XvMC->psp.map) != 0) {
		return -1;
	}

	if (drmMap(xvmc_driver->fd,
		   pI915XvMC->psc.handle,
		   pI915XvMC->psc.size,
		   (drmAddress *) & pI915XvMC->psc.map) != 0) {
		return -1;
	}

	if (drmMap(xvmc_driver->fd,
		   pI915XvMC->corrdata.handle,
		   pI915XvMC->corrdata.size,
		   (drmAddress *) & pI915XvMC->corrdata.map) != 0) {
		return -1;
	}

	return 0;
}

static void i915_xvmc_unmap_buffers(i915XvMCContext * pI915XvMC)
{
	if (pI915XvMC->sis.map) {
		drmUnmap(pI915XvMC->sis.map, pI915XvMC->sis.size);
		pI915XvMC->sis.map = NULL;
	}

	if (pI915XvMC->ssb.map) {
		drmUnmap(pI915XvMC->ssb.map, pI915XvMC->ssb.size);
		pI915XvMC->ssb.map = NULL;
	}

	if (pI915XvMC->msb.map) {
		drmUnmap(pI915XvMC->msb.map, pI915XvMC->msb.size);
		pI915XvMC->msb.map = NULL;
	}

	if (pI915XvMC->psp.map) {
		drmUnmap(pI915XvMC->psp.map, pI915XvMC->psp.size);
		pI915XvMC->psp.map = NULL;
	}

	if (pI915XvMC->psc.map) {
		drmUnmap(pI915XvMC->psc.map, pI915XvMC->psc.size);
		pI915XvMC->psc.map = NULL;
	}

	if (pI915XvMC->corrdata.map) {
		drmUnmap(pI915XvMC->corrdata.map, pI915XvMC->corrdata.size);
		pI915XvMC->corrdata.map = NULL;
	}
}

#if 0
/*
 * Video post processing
 */
static void i915_yuv2rgb_map_state_buffer(XvMCSurface * target_surface)
{
	struct i915_3dstate_map_state *map_state;
	struct texture_map *tm;
	i915XvMCSurface *privTarget = NULL;
	i915XvMCContext *pI915XvMC = NULL;
	unsigned int w = target_surface->width, h = target_surface->height;

	privTarget = (i915XvMCSurface *) target_surface->privData;
	pI915XvMC = (i915XvMCContext *) privTarget->privContext;
	/* 3DSATE_MAP_STATE */
	map_state = (struct i915_3dstate_map_state *)pI915XvMC->msb.map;
	memset(map_state, 0, sizeof(*map_state));
	map_state->dw0.type = CMD_3D;
	map_state->dw0.opcode = OPC_3DSTATE_MAP_STATE;
	map_state->dw0.retain = 0;
	map_state->dw0.length = 9;
	map_state->dw1.map_mask = MAP_MAP0 | MAP_MAP1 | MAP_MAP2;

	/* texture map 0: V Plane */
	tm = (struct texture_map *)(++map_state);
	memset(tm, 0, sizeof(*tm));
	tm->tm0.v_ls_offset = 0;
	tm->tm0.v_ls = 0;
	tm->tm0.base_address = VOFFSET(privTarget);
	tm->tm1.tile_walk = TILEWALK_XMAJOR;
	tm->tm1.tiled_surface = 0;
	tm->tm1.utilize_fence_regs = 1;
	tm->tm1.texel_fmt = 0;
	tm->tm1.surface_fmt = 1;
	tm->tm1.width = (w >> 1) - 1;
	tm->tm1.height = (h >> 1) - 1;
	tm->tm2.depth = 0;
	tm->tm2.max_lod = 0;
	tm->tm2.cube_face = 0;
	tm->tm2.pitch = (privTarget->uvStride >> 2) - 1;	/* in DWords - 1 */

	/* texture map 1: Y Plane */
	++tm;
	memset(tm, 0, sizeof(*tm));
	tm->tm0.v_ls_offset = 0;
	tm->tm0.v_ls = 0;
	tm->tm0.base_address = YOFFSET(privTarget);
	tm->tm1.tile_walk = TILEWALK_XMAJOR;
	tm->tm1.tiled_surface = 0;
	tm->tm1.utilize_fence_regs = 1;
	tm->tm1.texel_fmt = 0;
	tm->tm1.surface_fmt = 1;
	tm->tm1.width = w - 1;
	tm->tm1.height = h - 1;
	tm->tm2.depth = 0;
	tm->tm2.max_lod = 0;
	tm->tm2.cube_face = 0;
	tm->tm2.pitch = (privTarget->yStride >> 2) - 1;	/* in DWords - 1 */

	/* texture map 2: U Plane */
	++tm;
	memset(tm, 0, sizeof(*tm));
	tm->tm0.v_ls_offset = 0;
	tm->tm0.v_ls = 0;
	tm->tm0.base_address = UOFFSET(privTarget);
	tm->tm1.tile_walk = TILEWALK_XMAJOR;
	tm->tm1.tiled_surface = 0;
	tm->tm1.utilize_fence_regs = 1;
	tm->tm1.texel_fmt = 0;
	tm->tm1.surface_fmt = 1;
	tm->tm1.width = (w >> 1) - 1;
	tm->tm1.height = (h >> 1) - 1;
	tm->tm2.depth = 0;
	tm->tm2.max_lod = 0;
	tm->tm2.cube_face = 0;
	tm->tm2.pitch = (privTarget->uvStride >> 2) - 1;	/* in DWords - 1 */
}
#endif

#if 0
static void i915_yuv2rgb_sampler_state_buffer(XvMCSurface * surface)
{
	struct i915_3dstate_sampler_state *sampler_state;
	struct texture_sampler *ts;
	i915XvMCSurface *privSurface = (i915XvMCSurface *) surface->privData;
	i915XvMCContext *pI915XvMC =
	    (i915XvMCContext *) privSurface->privContext;

	/* 3DSATE_SAMPLER_STATE */
	sampler_state = (struct i915_3dstate_sampler_state *)pI915XvMC->ssb.map;
	memset(sampler_state, 0, sizeof(*sampler_state));
	sampler_state->dw0.type = CMD_3D;
	sampler_state->dw0.opcode = OPC_3DSTATE_SAMPLER_STATE;
	sampler_state->dw0.length = 9;
	sampler_state->dw1.sampler_masker =
	    SAMPLER_SAMPLER0 | SAMPLER_SAMPLER1 | SAMPLER_SAMPLER2;

	/* Sampler 0 */
	ts = (struct texture_sampler *)(++sampler_state);
	memset(ts, 0, sizeof(*ts));
	ts->ts0.reverse_gamma = 0;
	ts->ts0.planar2packet = 1;
	ts->ts0.color_conversion = 1;
	ts->ts0.chromakey_index = 0;
	ts->ts0.base_level = 0;
	ts->ts0.mip_filter = MIPFILTER_NONE;	/* NONE */
	ts->ts0.mag_filter = MAPFILTER_LINEAR;	/* LINEAR */
	ts->ts0.min_filter = MAPFILTER_LINEAR;	/* LINEAR */
	ts->ts0.lod_bias = 0;
	ts->ts0.shadow_enable = 0;
	ts->ts0.max_anisotropy = ANISORATIO_2;
	ts->ts0.shadow_function = PREFILTEROP_ALWAYS;
	ts->ts1.min_lod = 0;	/* Maximum Mip Level */
	ts->ts1.kill_pixel = 0;
	ts->ts1.keyed_texture_filter = 0;
	ts->ts1.chromakey_enable = 0;
	ts->ts1.tcx_control = TEXCOORDMODE_CLAMP;
	ts->ts1.tcy_control = TEXCOORDMODE_CLAMP;
	ts->ts1.tcz_control = TEXCOORDMODE_CLAMP;
	ts->ts1.normalized_coor = 0;
	ts->ts1.map_index = 0;
	ts->ts1.east_deinterlacer = 0;
	ts->ts2.default_color = 0;

	/* Sampler 1 */
	++ts;
	memset(ts, 0, sizeof(*ts));
	ts->ts0.reverse_gamma = 0;
	ts->ts0.planar2packet = 1;
	ts->ts0.color_conversion = 1;
	ts->ts0.chromakey_index = 0;
	ts->ts0.base_level = 0;
	ts->ts0.mip_filter = MIPFILTER_NONE;	/* NONE */
	ts->ts0.mag_filter = MAPFILTER_LINEAR;	/* LINEAR */
	ts->ts0.min_filter = MAPFILTER_LINEAR;	/* LINEAR */
	ts->ts0.lod_bias = 0;
	ts->ts0.shadow_enable = 0;
	ts->ts0.max_anisotropy = ANISORATIO_2;
	ts->ts0.shadow_function = PREFILTEROP_ALWAYS;
	ts->ts1.min_lod = 0;	/* Maximum Mip Level */
	ts->ts1.kill_pixel = 0;
	ts->ts1.keyed_texture_filter = 0;
	ts->ts1.chromakey_enable = 0;
	ts->ts1.tcx_control = TEXCOORDMODE_CLAMP;
	ts->ts1.tcy_control = TEXCOORDMODE_CLAMP;
	ts->ts1.tcz_control = TEXCOORDMODE_CLAMP;
	ts->ts1.normalized_coor = 0;
	ts->ts1.map_index = 1;
	ts->ts1.east_deinterlacer = 0;
	ts->ts2.default_color = 0;

	/* Sampler 2 */
	++ts;
	memset(ts, 0, sizeof(*ts));
	ts->ts0.reverse_gamma = 0;
	ts->ts0.planar2packet = 1;
	ts->ts0.color_conversion = 1;
	ts->ts0.chromakey_index = 0;
	ts->ts0.base_level = 0;
	ts->ts0.mip_filter = MIPFILTER_NONE;	/* NONE */
	ts->ts0.mag_filter = MAPFILTER_LINEAR;	/* LINEAR */
	ts->ts0.min_filter = MAPFILTER_LINEAR;	/* LINEAR */
	ts->ts0.lod_bias = 0;
	ts->ts0.shadow_enable = 0;
	ts->ts0.max_anisotropy = ANISORATIO_2;
	ts->ts0.shadow_function = PREFILTEROP_ALWAYS;
	ts->ts1.min_lod = 0;	/* Maximum Mip Level */
	ts->ts1.kill_pixel = 0;
	ts->ts1.keyed_texture_filter = 0;
	ts->ts1.chromakey_enable = 0;
	ts->ts1.tcx_control = TEXCOORDMODE_CLAMP;
	ts->ts1.tcy_control = TEXCOORDMODE_CLAMP;
	ts->ts1.tcz_control = TEXCOORDMODE_CLAMP;
	ts->ts1.normalized_coor = 0;
	ts->ts1.map_index = 2;
	ts->ts1.east_deinterlacer = 0;
	ts->ts2.default_color = 0;
}
#endif

#if 0
static void i915_yuv2rgb_static_indirect_state_buffer(XvMCSurface * surface,
						      unsigned int dstaddr,
						      int dstpitch)
{
	struct i915_3dstate_buffer_info *buffer_info;
	struct i915_3dstate_dest_buffer_variables *dest_buffer_variables;
	i915XvMCSurface *privSurface = (i915XvMCSurface *) surface->privData;
	i915XvMCContext *pI915XvMC =
	    (i915XvMCContext *) privSurface->privContext;

	/* 3DSTATE_BUFFER_INFO */
	buffer_info = (struct i915_3dstate_buffer_info *)pI915XvMC->sis.map;
	memset(buffer_info, 0, sizeof(*buffer_info));
	buffer_info->dw0.type = CMD_3D;
	buffer_info->dw0.opcode = OPC_3DSTATE_BUFFER_INFO;
	buffer_info->dw0.length = 1;
	buffer_info->dw1.aux_id = 0;
	buffer_info->dw1.buffer_id = BUFFERID_COLOR_BACK;
	buffer_info->dw1.fence_regs = 1;
	buffer_info->dw1.tiled_surface = 0;	/* linear */
	buffer_info->dw1.walk = TILEWALK_XMAJOR;
	buffer_info->dw1.pitch = dstpitch;
	buffer_info->dw2.base_address = dstaddr;

	/* 3DSTATE_DEST_BUFFER_VARIABLES */
	dest_buffer_variables =
	    (struct i915_3dstate_dest_buffer_variables *)(++buffer_info);
	memset(dest_buffer_variables, 0, sizeof(*dest_buffer_variables));
	dest_buffer_variables->dw0.type = CMD_3D;
	dest_buffer_variables->dw0.opcode = OPC_3DSTATE_DEST_BUFFER_VARIABLES;
	dest_buffer_variables->dw0.length = 0;
	dest_buffer_variables->dw1.dest_v_bias = 8;	/* FIXME 0x1000 .5 ??? */
	dest_buffer_variables->dw1.dest_h_bias = 8;
	dest_buffer_variables->dw1.color_fmt = COLORBUFFER_A8R8G8B8;	/* FIXME */
}
#endif

#if 0
static void i915_yuv2rgb_pixel_shader_program_buffer(XvMCSurface * surface)
{
	struct i915_3dstate_pixel_shader_program *pixel_shader_program;
	i915XvMCSurface *privSurface = (i915XvMCSurface *) surface->privData;
	i915XvMCContext *pI915XvMC =
	    (i915XvMCContext *) privSurface->privContext;
	unsigned int *inst;
	unsigned int dest, src0, src1;

	/* Shader 0 */
	pixel_shader_program =
	    (struct i915_3dstate_pixel_shader_program *)pI915XvMC->psp.map;
	memset(pixel_shader_program, 0, sizeof(*pixel_shader_program));
	pixel_shader_program->dw0.type = CMD_3D;
	pixel_shader_program->dw0.opcode = OPC_3DSTATE_PIXEL_SHADER_PROGRAM;
	pixel_shader_program->dw0.retain = 0;
	pixel_shader_program->dw0.length = 23;
	/* dcl      t0.xy */
	inst = (unsigned int *)(++pixel_shader_program);
	i915_inst_decl(inst, REG_TYPE_T, T_TEX0, D0_CHANNEL_XY);
	/* dcl         t1.xy */
	inst += 3;
	i915_inst_decl(inst, REG_TYPE_T, T_TEX1, D0_CHANNEL_XY);
	/* dcl_2D   s0 */
	inst += 3;
	i915_inst_decl(inst, REG_TYPE_S, 0, D0_SAMPLE_TYPE_2D);
	/* dcl_2D   s1 */
	inst += 3;
	i915_inst_decl(inst, REG_TYPE_S, 1, D0_SAMPLE_TYPE_2D);
	/* dcl_2D   s2 */
	inst += 3;
	i915_inst_decl(inst, REG_TYPE_S, 2, D0_SAMPLE_TYPE_2D);
	/* texld    r0 t1 s0 */
	inst += 3;
	dest = UREG(REG_TYPE_R, 0);
	src0 = UREG(REG_TYPE_T, 1);	/* COORD */
	src1 = UREG(REG_TYPE_S, 0);	/* SAMPLER */
	i915_inst_texld(inst, T0_TEXLD, dest, src0, src1);
	/* texld    r0 t0 s1 */
	inst += 3;
	dest = UREG(REG_TYPE_R, 0);
	src0 = UREG(REG_TYPE_T, 0);	/* COORD */
	src1 = UREG(REG_TYPE_S, 1);	/* SAMPLER */
	i915_inst_texld(inst, T0_TEXLD, dest, src0, src1);
	/* texld    oC t1 s2 */
	inst += 3;
	dest = UREG(REG_TYPE_OC, 0);
	src0 = UREG(REG_TYPE_T, 1);	/* COORD */
	src1 = UREG(REG_TYPE_S, 2);	/* SAMPLER */
	i915_inst_texld(inst, T0_TEXLD, dest, src0, src1);
}
#endif

#if 0
static void i915_yuv2rgb_proc(XvMCSurface * surface)
{
	i915XvMCSurface *privSurface = (i915XvMCSurface *) surface->privData;
	i915XvMCContext *pI915XvMC =
	    (i915XvMCContext *) privSurface->privContext;
	struct i915_3dstate_load_state_immediate_1 *load_state_immediate_1 =
	    NULL;
	struct s2_dword *s2 = NULL;
	struct s3_dword *s3 = NULL;
	struct s4_dword *s4 = NULL;
	struct s5_dword *s5 = NULL;
	struct s6_dword *s6 = NULL;
	struct s7_dword *s7 = NULL;
	struct i915_3dstate_scissor_rectangle scissor_rectangle;
	struct i915_3dstate_load_indirect *load_indirect = NULL;
	sis_state *sis = NULL;
	ssb_state *ssb = NULL;
	msb_state *msb = NULL;
	psp_state *psp = NULL;
	struct i915_3dprimitive *_3dprimitive = NULL;
	struct vertex_data *vd = NULL;
	unsigned int size;
	void *base = NULL;

	/* 3DSTATE_LOAD_STATE_IMMEDIATE_1 */
	size = sizeof(*load_state_immediate_1) + sizeof(*s2) + sizeof(*s3) +
	    sizeof(*s4) + sizeof(*s5) + sizeof(*s6) + sizeof(*s7);
	base = calloc(1, size);
	load_state_immediate_1 =
	    (struct i915_3dstate_load_state_immediate_1 *)base;
	load_state_immediate_1->dw0.type = CMD_3D;
	load_state_immediate_1->dw0.opcode = OPC_3DSTATE_LOAD_STATE_IMMEDIATE_1;
	load_state_immediate_1->dw0.load_s2 = 1;
	load_state_immediate_1->dw0.load_s3 = 1;
	load_state_immediate_1->dw0.load_s4 = 1;
	load_state_immediate_1->dw0.load_s5 = 1;
	load_state_immediate_1->dw0.load_s6 = 1;
	load_state_immediate_1->dw0.load_s7 = 1;
	load_state_immediate_1->dw0.length = 5;

	s2 = (struct s2_dword *)(++load_state_immediate_1);
	s2->set0_texcoord_fmt = TEXCOORDFMT_2FP;
	s2->set1_texcoord_fmt = TEXCOORDFMT_2FP;
	s2->set2_texcoord_fmt = TEXCOORDFMT_NOT_PRESENT;
	s2->set3_texcoord_fmt = TEXCOORDFMT_NOT_PRESENT;
	s2->set4_texcoord_fmt = TEXCOORDFMT_NOT_PRESENT;
	s2->set5_texcoord_fmt = TEXCOORDFMT_NOT_PRESENT;
	s2->set6_texcoord_fmt = TEXCOORDFMT_NOT_PRESENT;
	s2->set7_texcoord_fmt = TEXCOORDFMT_NOT_PRESENT;

	s3 = (struct s3_dword *)(++s2);
	s4 = (struct s4_dword *)(++s3);
	s4->position_mask = VERTEXHAS_XY;
	s4->cull_mode = CULLMODE_NONE;
	s4->color_shade_mode = SHADEMODE_FLAT;
	s4->specular_shade_mode = SHADEMODE_FLAT;
	s4->fog_shade_mode = SHADEMODE_FLAT;
	s4->alpha_shade_mode = SHADEMODE_FLAT;
	s4->line_width = 0x2;	/* FIXME: 1.0??? */
	s4->point_width = 0x1;

	s5 = (struct s5_dword *)(++s4);
	s6 = (struct s6_dword *)(++s5);
	s6->src_blend_factor = 1;
	s6->dest_blend_factor = 1;
	s6->color_buffer_write = 1;

	s7 = (struct s7_dword *)(++s6);
	intelBatchbufferData(base, size, 0);
	free(base);

	/* 3DSTATE_3DSTATE_SCISSOR_RECTANGLE */
	scissor_rectangle.dw0.type = CMD_3D;
	scissor_rectangle.dw0.opcode = OPC_3DSTATE_SCISSOR_RECTANGLE;
	scissor_rectangle.dw0.length = 1;
	scissor_rectangle.dw1.min_x = 0;
	scissor_rectangle.dw1.min_y = 0;
	scissor_rectangle.dw2.max_x = 2047;
	scissor_rectangle.dw2.max_y = 2047;
	intelBatchbufferData(&scissor_rectangle, sizeof(scissor_rectangle), 0);

	/* 3DSTATE_LOAD_INDIRECT */
	size =
	    sizeof(*load_indirect) + sizeof(*sis) + sizeof(*ssb) +
	    sizeof(*msb) + sizeof(*psp);
	base = calloc(1, size);
	load_indirect = (struct i915_3dstate_load_indirect *)base;
	load_indirect->dw0.type = CMD_3D;
	load_indirect->dw0.opcode = OPC_3DSTATE_LOAD_INDIRECT;
	load_indirect->dw0.mem_select = 1;	/* Bearlake only */
	load_indirect->dw0.block_mask =
	    BLOCK_SIS | BLOCK_SSB | BLOCK_MSB | BLOCK_PSP;
	load_indirect->dw0.length = 7;

	/* SIS */
	sis = (sis_state *) (++load_indirect);
	sis->dw0.valid = 1;
	sis->dw0.buffer_address = pI915XvMC->sis.offset;
	sis->dw1.length = ((sizeof(struct i915_3dstate_buffer_info) +
			    sizeof(struct i915_3dstate_dest_buffer_variables))
			   >> 2) - 1;

	/* SSB */
	ssb = (ssb_state *) (++sis);
	ssb->dw0.valid = 1;
	ssb->dw0.buffer_address = pI915XvMC->ssb.offset;
	ssb->dw1.length = ((sizeof(struct i915_3dstate_sampler_state) +
			    sizeof(struct texture_sampler) * 3) >> 2) - 1;

	/* MSB */
	msb = (msb_state *) (++ssb);
	msb->dw0.valid = 1;
	msb->dw0.buffer_address = pI915XvMC->msb.offset;
	msb->dw1.length = ((sizeof(struct i915_3dstate_map_state) +
			    sizeof(struct texture_map) * 3) >> 2) - 1;

	/* PSP */
	psp = (psp_state *) (++msb);
	psp->dw0.valid = 1;
	psp->dw0.buffer_address = pI915XvMC->psp.offset;
	psp->dw1.length = ((sizeof(struct i915_3dstate_pixel_shader_program) +
			    sizeof(union shader_inst)) >> 2) - 1;

	intelBatchbufferData(base, size, 0);
	free(base);

	/* 3DPRIMITIVE */
	size = sizeof(*_3dprimitive) + sizeof(*vd) * 3;
	base = calloc(1, size);
	_3dprimitive = (struct i915_3dprimitive *)base;
	_3dprimitive->dw0.inline_prim.type = CMD_3D;
	_3dprimitive->dw0.inline_prim.opcode = OPC_3DPRIMITIVE;
	_3dprimitive->dw0.inline_prim.vertex_location = VERTEX_INLINE;
	_3dprimitive->dw0.inline_prim.prim = PRIM_RECTLIST;
	_3dprimitive->dw0.inline_prim.length = size - 2;

	vd = (struct vertex_data *)(++_3dprimitive);
	vd->x = 0;		/* FIXME!!! */
	vd->x = 0;		/* FIXME */
	vd->tc0.tcx = 0;
	vd->tc0.tcy = 0;
	vd->tc1.tcx = 0;
	vd->tc1.tcy = 0;

	++vd;
	vd->x = 0;		/* FIXME!!! */
	vd->x = 0;		/* FIXME */
	vd->tc0.tcx = 0;
	vd->tc0.tcy = 0;
	vd->tc1.tcx = 0;
	vd->tc1.tcy = 0;

	++vd;
	vd->x = 0;		/* FIXME!!! */
	vd->x = 0;		/* FIXME */
	vd->tc0.tcx = 0;
	vd->tc0.tcy = 0;
	vd->tc1.tcx = 0;
	vd->tc1.tcy = 0;

	intelBatchbufferData(base, size, 0);
	free(base);
}
#endif
d894 1
a894 2
	pI915XvMC->ref--;
	i915_xvmc_unmap_buffers(pI915XvMC);
d905 1
a905 3
	I915XvMCCreateContextRec *tmpComm = NULL;

	XVMC_DBG("%s\n", __FUNCTION__);
d907 1
a907 1
	if (priv_count != (sizeof(I915XvMCCreateContextRec) >> 2)) {
d911 1
a911 1
			  (int)(sizeof(I915XvMCCreateContextRec) >> 2),
d926 4
a929 31
	tmpComm = (I915XvMCCreateContextRec *) priv_data;
	pI915XvMC->ctxno = tmpComm->ctxno;
	pI915XvMC->deviceID = tmpComm->deviceID;
	pI915XvMC->sis.handle = tmpComm->sis.handle;
	pI915XvMC->sis.offset = tmpComm->sis.offset;
	pI915XvMC->sis.size = tmpComm->sis.size;
	pI915XvMC->ssb.handle = tmpComm->ssb.handle;
	pI915XvMC->ssb.offset = tmpComm->ssb.offset;
	pI915XvMC->ssb.size = tmpComm->ssb.size;
	pI915XvMC->msb.handle = tmpComm->msb.handle;
	pI915XvMC->msb.offset = tmpComm->msb.offset;
	pI915XvMC->msb.size = tmpComm->msb.size;
	pI915XvMC->psp.handle = tmpComm->psp.handle;
	pI915XvMC->psp.offset = tmpComm->psp.offset;
	pI915XvMC->psp.size = tmpComm->psp.size;
	pI915XvMC->psc.handle = tmpComm->psc.handle;
	pI915XvMC->psc.offset = tmpComm->psc.offset;
	pI915XvMC->psc.size = tmpComm->psc.size;

	if (pI915XvMC->deviceID == PCI_CHIP_I915_G ||
	    pI915XvMC->deviceID == PCI_CHIP_I915_GM) {
		pI915XvMC->sis.bus_addr = tmpComm->sis.bus_addr;
		pI915XvMC->ssb.bus_addr = tmpComm->ssb.bus_addr;
		pI915XvMC->msb.bus_addr = tmpComm->msb.bus_addr;
		pI915XvMC->psp.bus_addr = tmpComm->psp.bus_addr;
		pI915XvMC->psc.bus_addr = tmpComm->psc.bus_addr;
	}

	pI915XvMC->corrdata.handle = tmpComm->corrdata.handle;
	pI915XvMC->corrdata.offset = tmpComm->corrdata.offset;
	pI915XvMC->corrdata.size = tmpComm->corrdata.size;
d935 2
a936 6
	if (i915_xvmc_map_buffers(pI915XvMC)) {
		i915_xvmc_unmap_buffers(pI915XvMC);
		free(pI915XvMC);
		context->privData = NULL;
		return BadAlloc;
	}
a940 5
	pI915XvMC->haveXv = 0;
	pI915XvMC->dual_prime = 0;
	pI915XvMC->last_flip = 0;
	pI915XvMC->port = context->port;
	pI915XvMC->ref = 1;
a943 1
	i915_mc_one_time_state_init(context);
d945 1
a945 1
	i915_mc_static_indirect_state_init(context);
d947 5
a951 4
	i915_mc_map_state_init(context);

	i915_mc_load_indirect_render_init(context);
	return Success;
a964 3
	free(one_time_load_state_imm1);
	free(one_time_load_indirect);
	free(mc_render_load_indirect);
d968 1
a968 4
static Status i915_xvmc_mc_create_surface(Display * display,
					  XvMCContext * context,
					  XvMCSurface * surface, int priv_count,
					  CARD32 * priv_data)
d970 29
a998 91
	i915XvMCContext *pI915XvMC;
	i915XvMCSurface *pI915Surface;
	I915XvMCCreateSurfaceRec *tmpComm = NULL;

	if (!(pI915XvMC = context->privData))
		return XvMCBadContext;

	XVMC_DBG("%s\n", __FUNCTION__);

	if (priv_count != (sizeof(I915XvMCCreateSurfaceRec) >> 2)) {
		XVMC_ERR
		    ("_xvmc_create_surface() returned incorrect data size!");
		XVMC_INFO("\tExpected %d, got %d",
			  (int)(sizeof(I915XvMCCreateSurfaceRec) >> 2),
			  priv_count);
		_xvmc_destroy_surface(display, surface);
		XFree(priv_data);
		return BadAlloc;
	}

	PPTHREAD_MUTEX_LOCK();
	surface->privData = (i915XvMCSurface *) malloc(sizeof(i915XvMCSurface));

	if (!(pI915Surface = surface->privData)) {
		PPTHREAD_MUTEX_UNLOCK();
		return BadAlloc;
	}

	/* Initialize private values */
	pI915Surface->last_render = 0;
	pI915Surface->last_flip = 0;
	pI915Surface->yStride = pI915XvMC->yStride;
	pI915Surface->uvStride = pI915XvMC->uvStride;
	pI915Surface->width = context->width;
	pI915Surface->height = context->height;
	pI915Surface->privContext = pI915XvMC;
	pI915Surface->privSubPic = NULL;
	pI915Surface->srf.map = NULL;

	tmpComm = (I915XvMCCreateSurfaceRec *) priv_data;

	pI915Surface->srfNo = tmpComm->srfno;
	pI915Surface->srf.handle = tmpComm->srf.handle;
	pI915Surface->srf.offset = tmpComm->srf.offset;
	pI915Surface->srf.size = tmpComm->srf.size;

	XFree(priv_data);

	if (drmMap(xvmc_driver->fd,
		   pI915Surface->srf.handle,
		   pI915Surface->srf.size,
		   (drmAddress *) & pI915Surface->srf.map) != 0) {
		XVMC_ERR("mapping surface memory failed!\n");
		_xvmc_destroy_surface(display, surface);
		free(pI915Surface);
		surface->privData = NULL;
		PPTHREAD_MUTEX_UNLOCK();
		return BadAlloc;
	}

	pI915XvMC->ref++;
	PPTHREAD_MUTEX_UNLOCK();
	return 0;
}

static int i915_xvmc_mc_destroy_surface(Display * display,
					XvMCSurface * surface)
{
	i915XvMCSurface *pI915Surface;
	i915XvMCContext *pI915XvMC;

	if (!display || !surface)
		return BadValue;

	if (!(pI915Surface = surface->privData))
		return XvMCBadSurface;

	if (!(pI915XvMC = pI915Surface->privContext))
		return XvMCBadSurface;

	if (pI915Surface->last_flip)
		XvMCSyncSurface(display, surface);

	if (pI915Surface->srf.map)
		drmUnmap(pI915Surface->srf.map, pI915Surface->srf.size);

	free(pI915Surface);
	surface->privData = NULL;
	pI915XvMC->ref--;

	return Success;
d1025 3
a1027 3
	i915XvMCSurface *privTarget = NULL;
	i915XvMCSurface *privFuture = NULL;
	i915XvMCSurface *privPast = NULL;
a1029 2
	XVMC_DBG("%s\n", __FUNCTION__);

d1055 2
a1056 5
	if (context->surface_type_id >= SURFACE_TYPE_MAX) {
		XVMC_ERR("Unsupprted surface_type_id %d.",
			 context->surface_type_id);
		return BadValue;
	}
d1058 1
a1058 1
	intel_ctx = intel_xvmc_find_context(context->context_id);
a1069 1
			XVMC_ERR("Invalid Past Surface!");
d1093 2
a1094 1
	corrdata_ptr = pI915XvMC->corrdata.map;
d1129 1
a1129 1
		if (corrdata_size > pI915XvMC->corrdata.size) {
d1137 2
a1138 1
	i915_flush(1, 0);
d1142 1
a1142 1
	i915_mc_one_time_state_emit();
d1150 1
a1150 1
	i915_mc_load_indirect_render_emit();
d1210 2
a1211 2
	xvmc_driver->last_render = xvmc_driver->alloc.irq_emitted;
	privTarget->last_render = xvmc_driver->last_render;
a1216 491
static int i915_xvmc_mc_put_surface(Display * display, XvMCSurface * surface,
				    Drawable draw, short srcx, short srcy,
				    unsigned short srcw, unsigned short srch,
				    short destx, short desty,
				    unsigned short destw, unsigned short desth,
				    int flags, struct intel_xvmc_command *data)
{
	i915XvMCContext *pI915XvMC;
	i915XvMCSurface *pI915Surface;
	i915XvMCSubpicture *pI915SubPic;

	if (!(pI915Surface = surface->privData))
		return XvMCBadSurface;

	if (!(pI915XvMC = pI915Surface->privContext))
		return XvMCBadSurface;

	PPTHREAD_MUTEX_LOCK();

	data->command = INTEL_XVMC_COMMAND_DISPLAY;
	data->ctxNo = pI915XvMC->ctxno;
	data->srfNo = pI915Surface->srfNo;
	pI915SubPic = pI915Surface->privSubPic;
	data->subPicNo = (!pI915SubPic ? 0 : pI915SubPic->srfNo);
	data->real_id = FOURCC_YV12;
	data->flags = flags;

	PPTHREAD_MUTEX_UNLOCK();

	return 0;
}

static int i915_xvmc_mc_get_surface_status(Display * display,
					   XvMCSurface * surface, int *stat)
{
	i915XvMCSurface *pI915Surface;
	i915XvMCContext *pI915XvMC;

	if (!display || !surface || !stat)
		return BadValue;

	*stat = 0;

	if (!(pI915Surface = surface->privData))
		return XvMCBadSurface;

	if (!(pI915XvMC = pI915Surface->privContext))
		return XvMCBadSurface;

	PPTHREAD_MUTEX_LOCK();
	if (pI915Surface->last_flip) {
		/* This can not happen */
		if (pI915XvMC->last_flip < pI915Surface->last_flip) {
			XVMC_ERR
			    ("Context last flip is less than surface last flip.");
			PPTHREAD_MUTEX_UNLOCK();
			return BadValue;
		}

		/*
		   If the context has 2 or more flips after this surface it
		   cannot be displaying. Don't bother to check.
		 */
		if (!(pI915XvMC->last_flip > (pI915Surface->last_flip + 1))) {
			/*
			   If this surface was the last flipped it is either displaying
			   or about to be so don't bother checking.
			 */
			if (pI915XvMC->last_flip == pI915Surface->last_flip) {
				*stat |= XVMC_DISPLAYING;
			}
		}
	}

	PPTHREAD_MUTEX_UNLOCK();
	return 0;
}

/* XXX WIP code */
#if 0
Status XvMCHideSurface(Display * display, XvMCSurface * surface)
{
	i915XvMCSurface *pI915Surface;
	i915XvMCContext *pI915XvMC;
	int stat = 0, ret;

	if (!display || !surface)
		return BadValue;

	if (!(pI915Surface = surface->privData))
		return XvMCBadSurface;

	/* Get the associated context pointer */
	if (!(pI915XvMC = pI915Surface->privContext))
		return XvMCBadSurface;

	XvMCSyncSurface(display, surface);

	/*
	   Get the status of the surface, if it is not currently displayed
	   we don't need to worry about it.
	 */
	if ((ret = XvMCGetSurfaceStatus(display, surface, &stat)) != Success)
		return ret;

	if (!(stat & XVMC_DISPLAYING))
		return Success;

	/* FIXME: */
	return Success;
}

Status i915_xvmc_create_subpict(Display * display, XvMCContext * context,
				XvMCSubpicture * subpicture,
				unsigned short width, unsigned short height,
				int xvimage_id)
{
	Status ret;
	i915XvMCContext *pI915XvMC;
	i915XvMCSubpicture *pI915Subpicture;
	I915XvMCCreateSurfaceRec *tmpComm = NULL;
	int priv_count;
	uint *priv_data;

	if (!subpicture || !context || !display)
		return BadValue;

	pI915XvMC = (i915XvMCContext *) context->privData;

	if (!pI915XvMC)
		return XvMCBadContext;

	subpicture->privData =
	    (i915XvMCSubpicture *) malloc(sizeof(i915XvMCSubpicture));

	if (!subpicture->privData)
		return BadAlloc;

	PPTHREAD_MUTEX_LOCK();
	subpicture->context_id = context->context_id;
	subpicture->xvimage_id = xvimage_id;
	subpicture->width = width;
	subpicture->height = height;
	pI915Subpicture = (i915XvMCSubpicture *) subpicture->privData;

	XLockDisplay(display);
	if ((ret = _xvmc_create_subpicture(display, context, subpicture,
					   &priv_count, &priv_data))) {
		XUnlockDisplay(display);
		XVMC_ERR("Unable to create XvMCSubpicture.");
		free(pI915Subpicture);
		subpicture->privData = NULL;
		PPTHREAD_MUTEX_UNLOCK();
		return ret;
	}
	XUnlockDisplay(display);

	if (priv_count != (sizeof(I915XvMCCreateSurfaceRec) >> 2)) {
		XVMC_ERR
		    ("_xvmc_create_subpicture() returned incorrect data size!");
		XVMC_INFO("\tExpected %d, got %d",
			  (int)(sizeof(I915XvMCCreateSurfaceRec) >> 2),
			  priv_count);
		XLockDisplay(display);
		_xvmc_destroy_subpicture(display, subpicture);
		XUnlockDisplay(display);
		XFree(priv_data);
		free(pI915Subpicture);
		subpicture->privData = NULL;
		PPTHREAD_MUTEX_UNLOCK();
		return BadAlloc;
	}

	tmpComm = (I915XvMCCreateSurfaceRec *) priv_data;
	pI915Subpicture->srfNo = tmpComm->srfno;
	pI915Subpicture->srf.handle = tmpComm->srf.handle;
	pI915Subpicture->srf.offset = tmpComm->srf.offset;
	pI915Subpicture->srf.size = tmpComm->srf.size;
	XFree(priv_data);

	if (drmMap(pI915XvMC->fd,
		   pI915Subpicture->srf.handle,
		   pI915Subpicture->srf.size,
		   (drmAddress *) & pI915Subpicture->srf.map) != 0) {
		XLockDisplay(display);
		_xvmc_destroy_subpicture(display, subpicture);
		XUnlockDisplay(display);
		free(pI915Subpicture);
		subpicture->privData = NULL;
		PPTHREAD_MUTEX_UNLOCK();
		return BadAlloc;
	}

	/* subpicture */
	subpicture->num_palette_entries = I915_SUBPIC_PALETTE_SIZE;
	subpicture->entry_bytes = 3;
	strncpy(subpicture->component_order, "YUV", 4);

	/* Initialize private values */
	pI915Subpicture->privContext = pI915XvMC;
	pI915Subpicture->last_render = 0;
	pI915Subpicture->last_flip = 0;
	pI915Subpicture->pitch = ((subpicture->width + 3) & ~3);

	switch (subpicture->xvimage_id) {
	case FOURCC_IA44:
	case FOURCC_AI44:
		break;

	default:
		drmUnmap(pI915Subpicture->srf.map, pI915Subpicture->srf.size);
		XLockDisplay(display);
		_xvmc_destroy_subpicture(display, subpicture);
		XUnlockDisplay(display);
		free(pI915Subpicture);
		subpicture->privData = NULL;
		PPTHREAD_MUTEX_UNLOCK();
		return BadMatch;
	}

	pI915XvMC->ref++;
	PPTHREAD_MUTEX_UNLOCK();
	return Success;
}

Status i915_xvmc_clear_subpict(Display * display, XvMCSubpicture * subpicture,
			       short x, short y,
			       unsigned short width, unsigned short height,
			       unsigned int color)
{
	i915XvMCContext *pI915XvMC;
	i915XvMCSubpicture *pI915Subpicture;

	if (!display || !subpicture)
		return BadValue;

	if (!(pI915Subpicture = subpicture->privData))
		return XvMCBadSubpicture;

	if (!(pI915XvMC = pI915Subpicture->privContext))
		return XvMCBadSubpicture;

	if ((x < 0) || (x + width) > subpicture->width)
		return BadValue;

	if ((y < 0) || (y + height) > subpicture->height)
		return BadValue;

	/* FIXME: clear the area */

	return Success;
}

Status i915_xvmc_composite_subpict(Display * display,
				   XvMCSubpicture * subpicture, XvImage * image,
				   short srcx, short srcy, unsigned short width,
				   unsigned short height, short dstx,
				   short dsty)
{
	i915XvMCContext *pI915XvMC;
	i915XvMCSubpicture *pI915Subpicture;

	if (!display || !subpicture)
		return BadValue;

	if (!(pI915Subpicture = subpicture->privData))
		return XvMCBadSubpicture;

	if (!(pI915XvMC = pI915Subpicture->privContext))
		return XvMCBadSubpicture;

	if ((srcx < 0) || (srcx + width) > subpicture->width)
		return BadValue;

	if ((srcy < 0) || (srcy + height) > subpicture->height)
		return BadValue;

	if ((dstx < 0) || (dstx + width) > subpicture->width)
		return BadValue;

	if ((dsty < 0) || (dsty + width) > subpicture->height)
		return BadValue;

	if (image->id != subpicture->xvimage_id)
		return BadMatch;

	/* FIXME */
	return Success;
}

Status i915_xvmc_destroy_subpict(Display * display, XvMCSubpicture * subpicture)
{
	i915XvMCSubpicture *pI915Subpicture;
	i915XvMCContext *pI915XvMC;

	if (!display || !subpicture)
		return BadValue;

	if (!(pI915Subpicture = subpicture->privData))
		return XvMCBadSubpicture;

	if (!(pI915XvMC = pI915Subpicture->privContext))
		return XvMCBadSubpicture;

	if (pI915Subpicture->last_render)
		XvMCSyncSubpicture(display, subpicture);

	if (pI915Subpicture->srf.map)
		drmUnmap(pI915Subpicture->srf.map, pI915Subpicture->srf.size);

	PPTHREAD_MUTEX_LOCK();
	XLockDisplay(display);
	_xvmc_destroy_subpicture(display, subpicture);
	XUnlockDisplay(display);

	free(pI915Subpicture);
	subpicture->privData = NULL;
	pI915XvMC->ref--;
	PPTHREAD_MUTEX_UNLOCK();

	return Success;
}

Status i915_xvmc_set_subpict_palette(Display * display,
				     XvMCSubpicture * subpicture,
				     unsigned char *palette)
{
	i915XvMCSubpicture *pI915Subpicture;
	int i, j;

	if (!display || !subpicture)
		return BadValue;

	if (!(pI915Subpicture = subpicture->privData))
		return XvMCBadSubpicture;

	j = 0;
	for (i = 0; i < 16; i++) {
		pI915Subpicture->palette[0][i] = palette[j++];
		pI915Subpicture->palette[1][i] = palette[j++];
		pI915Subpicture->palette[2][i] = palette[j++];
	}

	/* FIXME: Update the subpicture with the new palette */
	return Success;
}

Status i915_xvmc_blend_subpict(Display * display, XvMCSurface * target_surface,
			       XvMCSubpicture * subpicture,
			       short subx, short suby,
			       unsigned short subw, unsigned short subh,
			       short surfx, short surfy,
			       unsigned short surfw, unsigned short surfh)
{
	i915XvMCSubpicture *pI915Subpicture;
	i915XvMCSurface *privTargetSurface;

	if (!display || !target_surface)
		return BadValue;

	if (!(privTargetSurface = target_surface->privData))
		return XvMCBadSurface;

	if (subpicture) {
		if (!(pI915Subpicture = subpicture->privData))
			return XvMCBadSubpicture;

		if ((FOURCC_AI44 != subpicture->xvimage_id) &&
		    (FOURCC_IA44 != subpicture->xvimage_id))
			return XvMCBadSubpicture;

		privTargetSurface->privSubPic = pI915Subpicture;
	} else {
		privTargetSurface->privSubPic = NULL;
	}

	return Success;
}

Status i915_xvmc_blend_subpict2(Display * display,
				XvMCSurface * source_surface,
				XvMCSurface * target_surface,
				XvMCSubpicture * subpicture,
				short subx, short suby,
				unsigned short subw, unsigned short subh,
				short surfx, short surfy,
				unsigned short surfw, unsigned short surfh)
{
	i915XvMCContext *pI915XvMC;
	i915XvMCSubpicture *pI915Subpicture;
	i915XvMCSurface *privSourceSurface;
	i915XvMCSurface *privTargetSurface;

	if (!display || !source_surface || !target_surface)
		return BadValue;

	if (!(privSourceSurface = source_surface->privData))
		return XvMCBadSurface;

	if (!(privTargetSurface = target_surface->privData))
		return XvMCBadSurface;

	if (!(pI915XvMC = privTargetSurface->privContext))
		return XvMCBadSurface;

	if (((surfx + surfw) > privTargetSurface->width) ||
	    ((surfy + surfh) > privTargetSurface->height))
		return BadValue;

	if ((privSourceSurface->width != privTargetSurface->width) ||
	    (privTargetSurface->height != privTargetSurface->height))
		return BadValue;

	if (XvMCSyncSurface(display, source_surface))
		return BadValue;

	/* FIXME: update Target Surface */

	if (subpicture) {
		if (((subx + subw) > subpicture->width) ||
		    ((suby + subh) > subpicture->height))
			return BadValue;

		if (!(pI915Subpicture = subpicture->privData))
			return XvMCBadSubpicture;

		if ((FOURCC_AI44 != subpicture->xvimage_id) &&
		    (FOURCC_IA44 != subpicture->xvimage_id))
			return XvMCBadSubpicture;

		privTargetSurface->privSubPic = pI915Subpicture;
	} else {
		privTargetSurface->privSubPic = NULL;
	}

	return Success;
}

Status i915_xvmc_sync_subpict(Display * display, XvMCSubpicture * subpicture)
{
	Status ret;
	int stat = 0;

	if (!display || !subpicture)
		return BadValue;

	do {
		ret = XvMCGetSubpictureStatus(display, subpicture, &stat);
	} while (!ret && (stat & XVMC_RENDERING));

	return ret;
}

Status i915_xvmc_flush_subpict(Display * display, XvMCSubpicture * subpicture)
{
	i915XvMCSubpicture *pI915Subpicture;

	if (!display || !subpicture)
		return BadValue;

	if (!(pI915Subpicture = subpicture->privData))
		return XvMCBadSubpicture;

	return Success;
}

Status i915_xvmc_get_subpict_status(Display * display,
				    XvMCSubpicture * subpicture, int *stat)
{
	i915XvMCSubpicture *pI915Subpicture;
	i915XvMCContext *pI915XvMC;

	if (!display || !subpicture || stat)
		return BadValue;

	*stat = 0;

	if (!(pI915Subpicture = subpicture->privData))
		return XvMCBadSubpicture;

	if (!(pI915XvMC = pI915Subpicture->privContext))
		return XvMCBadSubpicture;

	PPTHREAD_MUTEX_LOCK();

	PPTHREAD_MUTEX_UNLOCK();
	return Success;
}

#endif

a1222 2
	.create_surface = i915_xvmc_mc_create_surface,
	.destroy_surface = i915_xvmc_mc_destroy_surface,
a1223 2
	.put_surface = i915_xvmc_mc_put_surface,
	.get_surface_status = i915_xvmc_mc_get_surface_status,
@


1.3
log
@xf86-video-intel 2.4.2. Has been in snapshots for weeks. Ok oga@@.
@
text
@d42 2
a43 2
    int16_t component[2];
    int32_t v;
d48 33
a80 33
                       short *dstX, short *dstY,
                       short *srcX, short *srcY,
                       unsigned short *areaW, unsigned short *areaH)
{
    int w, h;
    unsigned int mWidth, mHeight;

    w = *areaW;
    h = *areaH;

    if ((*dstX >= width) || (*dstY >= height))
        return 1;

    if (*dstX < 0) {
        w += *dstX;
        *srcX -= *dstX;
        *dstX = 0;
    }

    if (*dstY < 0) {
        h += *dstY;
        *srcY -= *dstY;
        *dstY = 0;
    }

    if ((w <= 0) || ((h <= 0)))
        return 1;

    mWidth = width - *dstX;
    mHeight = height - *dstY;
    *areaW = (w <= mWidth) ? w : mWidth;
    *areaH = (h <= mHeight) ? h : mHeight;
    return 0;
d85 13
a97 12
                            unsigned int op,
                            unsigned int dest,
                            unsigned int mask,
                            unsigned int saturate,
                            unsigned int src0, unsigned int src1, unsigned int src2)
{
    dest = UREG(GET_UREG_TYPE(dest), GET_UREG_NR(dest));
    *inst = (op | A0_DEST(dest) | mask | saturate | A0_SRC0(src0));
    inst++;
    *inst = (A1_SRC0(src0) | A1_SRC1(src1));
    inst++;
    *inst = (A2_SRC1(src1) | A2_SRC2(src2));
d101 10
a110 11
                           unsigned int type,
                           unsigned int nr,
                           unsigned int d0_flags)
{
    unsigned int reg = UREG(type, nr);

    *inst = (D0_DCL | D0_DEST(reg) | d0_flags);
    inst++;
    *inst = D1_MBZ;
    inst++;
    *inst = D2_MBZ;
d114 10
a123 11
                              unsigned int op,
                              unsigned int dest,
                              unsigned int coord,
                              unsigned int sampler)
{
   dest = UREG(GET_UREG_TYPE(dest), GET_UREG_NR(dest));
   *inst = (op | T0_DEST(dest) | T0_SAMPLER(sampler));
   inst++;
   *inst = T1_ADDRESS_REG(coord);
   inst++;
   *inst = T2_MBZ;
d128 1
a128 1
    intelBatchbufferData(data, size, flag);
d140 1
a140 1
static void i915_mc_one_time_context_init(XvMCContext *context)
d142 332
a473 304
    unsigned int dest, src0, src1, src2;
    i915XvMCContext *pI915XvMC = (i915XvMCContext *)context->privData;
    int i;
    struct i915_3dstate_sampler_state *sampler_state;
    struct i915_3dstate_pixel_shader_program *pixel_shader_program;
    struct i915_3dstate_pixel_shader_constants *pixel_shader_constants;

    /* sampler static state */
    sampler_state = (struct i915_3dstate_sampler_state *)pI915XvMC->ssb.map;
    /* pixel shader static state */
    pixel_shader_program = (struct i915_3dstate_pixel_shader_program *)pI915XvMC->psp.map;
    /* pixel shader contant static state */
    pixel_shader_constants = (struct i915_3dstate_pixel_shader_constants *)pI915XvMC->psc.map;

    memset(sampler_state, 0, sizeof(*sampler_state));
    sampler_state->dw0.type = CMD_3D;
    sampler_state->dw0.opcode = OPC_3DSTATE_SAMPLER_STATE;
    sampler_state->dw0.length = 6;
    sampler_state->dw1.sampler_masker = SAMPLER_SAMPLER0 | SAMPLER_SAMPLER1;

    sampler_state->sampler0.ts0.reverse_gamma = 0;
    sampler_state->sampler0.ts0.planar2packet = 0;
    sampler_state->sampler0.ts0.color_conversion = 0;
    sampler_state->sampler0.ts0.chromakey_index = 0;
    sampler_state->sampler0.ts0.base_level = 0;
    sampler_state->sampler0.ts0.mip_filter = MIPFILTER_NONE;        /* NONE */
    sampler_state->sampler0.ts0.mag_filter = MAPFILTER_LINEAR;      /* LINEAR */
    sampler_state->sampler0.ts0.min_filter = MAPFILTER_LINEAR;      /* LINEAR */
    sampler_state->sampler0.ts0.lod_bias = 0;       /* 0.0 */
    sampler_state->sampler0.ts0.shadow_enable = 0;
    sampler_state->sampler0.ts0.max_anisotropy = ANISORATIO_2;
    sampler_state->sampler0.ts0.shadow_function = PREFILTEROP_ALWAYS;
    sampler_state->sampler0.ts1.min_lod = 0;        /* 0.0 Maximum Mip Level */
    sampler_state->sampler0.ts1.kill_pixel = 0;
    sampler_state->sampler0.ts1.keyed_texture_filter = 0;
    sampler_state->sampler0.ts1.chromakey_enable = 0;
    sampler_state->sampler0.ts1.tcx_control = TEXCOORDMODE_CLAMP;
    sampler_state->sampler0.ts1.tcy_control = TEXCOORDMODE_CLAMP;
    sampler_state->sampler0.ts1.tcz_control = TEXCOORDMODE_CLAMP;
    sampler_state->sampler0.ts1.normalized_coor = 0;
    sampler_state->sampler0.ts1.map_index = 0;
    sampler_state->sampler0.ts1.east_deinterlacer = 0;
    sampler_state->sampler0.ts2.default_color = 0;

    sampler_state->sampler1.ts0.reverse_gamma = 0;
    sampler_state->sampler1.ts0.planar2packet = 0;
    sampler_state->sampler1.ts0.color_conversion = 0;
    sampler_state->sampler1.ts0.chromakey_index = 0;
    sampler_state->sampler1.ts0.base_level = 0;
    sampler_state->sampler1.ts0.mip_filter = MIPFILTER_NONE;        /* NONE */
    sampler_state->sampler1.ts0.mag_filter = MAPFILTER_LINEAR;      /* LINEAR */
    sampler_state->sampler1.ts0.min_filter = MAPFILTER_LINEAR;      /* LINEAR */
    sampler_state->sampler1.ts0.lod_bias = 0;       /* 0.0 */
    sampler_state->sampler1.ts0.shadow_enable = 0;
    sampler_state->sampler1.ts0.max_anisotropy = ANISORATIO_2;
    sampler_state->sampler1.ts0.shadow_function = PREFILTEROP_ALWAYS;
    sampler_state->sampler1.ts1.min_lod = 0;        /* 0.0 Maximum Mip Level */
    sampler_state->sampler1.ts1.kill_pixel = 0;
    sampler_state->sampler1.ts1.keyed_texture_filter = 0;
    sampler_state->sampler1.ts1.chromakey_enable = 0;
    sampler_state->sampler1.ts1.tcx_control = TEXCOORDMODE_CLAMP;
    sampler_state->sampler1.ts1.tcy_control = TEXCOORDMODE_CLAMP;
    sampler_state->sampler1.ts1.tcz_control = TEXCOORDMODE_CLAMP;
    sampler_state->sampler1.ts1.normalized_coor = 0;
    sampler_state->sampler1.ts1.map_index = 1;
    sampler_state->sampler1.ts1.east_deinterlacer = 0;
    sampler_state->sampler1.ts2.default_color = 0;

    memset(pixel_shader_program, 0, sizeof(*pixel_shader_program));
    pixel_shader_program->shader0.type = CMD_3D;
    pixel_shader_program->shader0.opcode = OPC_3DSTATE_PIXEL_SHADER_PROGRAM;
    pixel_shader_program->shader0.retain = 1;
    pixel_shader_program->shader0.length = 2; /* 1 inst */
    i = 0;

    dest = UREG(REG_TYPE_OC, 0);
    src0 = UREG(REG_TYPE_CONST, 0);
    src1 = 0;
    src2 = 0;
    i915_inst_arith(&pixel_shader_program->inst0[i], A0_MOV,
	    dest, A0_DEST_CHANNEL_ALL, A0_DEST_SATURATE, src0, src1, src2);

    pixel_shader_program->shader1.type = CMD_3D;
    pixel_shader_program->shader1.opcode = OPC_3DSTATE_PIXEL_SHADER_PROGRAM;
    pixel_shader_program->shader1.retain = 1;
    pixel_shader_program->shader1.length = 14; /* 5 inst */
    i = 0;
    /* dcl t0.xy */
    i915_inst_decl(&pixel_shader_program->inst1[i], REG_TYPE_T, T_TEX0, D0_CHANNEL_XY);
    i+=3;
    /* dcl t1.xy */
    i915_inst_decl(&pixel_shader_program->inst1[i], REG_TYPE_T, T_TEX1, D0_CHANNEL_XY);
    /* dcl_2D s0 */
    i += 3;
    i915_inst_decl(&pixel_shader_program->inst1[i], REG_TYPE_S, 0, D0_SAMPLE_TYPE_2D);
    /* texld r0, t0, s0 */
    i += 3;
    dest = UREG(REG_TYPE_R, 0);
    src0 = UREG(REG_TYPE_T, 0); /* COORD */
    src1 = UREG(REG_TYPE_S, 0); /* SAMPLER */
    i915_inst_texld(&pixel_shader_program->inst1[i], T0_TEXLD, dest, src0, src1);
    /* mov oC, r0 */
    i += 3;
    dest = UREG(REG_TYPE_OC, 0);
    src0 = UREG(REG_TYPE_R, 0);
    src1 = src2 = 0;
    i915_inst_arith(&pixel_shader_program->inst1[i], A0_MOV, dest, A0_DEST_CHANNEL_ALL,
                    A0_DEST_SATURATE, src0, src1, src2);


    pixel_shader_program->shader2.type = CMD_3D;
    pixel_shader_program->shader2.opcode = OPC_3DSTATE_PIXEL_SHADER_PROGRAM;
    pixel_shader_program->shader2.retain = 1;
    pixel_shader_program->shader2.length = 14; /* 5 inst */
    i = 0;
    /* dcl t2.xy */
    i915_inst_decl(&pixel_shader_program->inst2[i], REG_TYPE_T, T_TEX2, D0_CHANNEL_XY);
    /* dcl t3.xy */
    i += 3;
    i915_inst_decl(&pixel_shader_program->inst2[i], REG_TYPE_T, T_TEX3, D0_CHANNEL_XY);
    /* dcl_2D s1 */
    i += 3;
    i915_inst_decl(&pixel_shader_program->inst2[i], REG_TYPE_S, 1, D0_SAMPLE_TYPE_2D);
    /* texld r0, t2, s1 */
    i += 3;
    dest = UREG(REG_TYPE_R, 0);
    src0 = UREG(REG_TYPE_T, 2); /* COORD */
    src1 = UREG(REG_TYPE_S, 1); /* SAMPLER */
    i915_inst_texld(&pixel_shader_program->inst2[i], T0_TEXLD, dest, src0, src1);
    /* mov oC, r0 */
    i += 3;
    dest = UREG(REG_TYPE_OC, 0);
    src0 = UREG(REG_TYPE_R, 0);
    src1 = src2 = 0;
    i915_inst_arith(&pixel_shader_program->inst2[i], A0_MOV, dest, A0_DEST_CHANNEL_ALL,
                    A0_DEST_SATURATE, src0, src1, src2);

    /* Shader 3 */
    pixel_shader_program->shader3.type = CMD_3D;
    pixel_shader_program->shader3.opcode = OPC_3DSTATE_PIXEL_SHADER_PROGRAM;
    pixel_shader_program->shader3.retain = 1;
    pixel_shader_program->shader3.length = 29; /* 10 inst */
    i = 0;
    /* dcl t0.xy */
    i915_inst_decl(&pixel_shader_program->inst3[i], REG_TYPE_T, T_TEX0, D0_CHANNEL_XY);
    /* dcl t1.xy */
    i += 3;
    i915_inst_decl(&pixel_shader_program->inst3[i], REG_TYPE_T, T_TEX1, D0_CHANNEL_XY);
    /* dcl t2.xy */
    i += 3;
    i915_inst_decl(&pixel_shader_program->inst3[i], REG_TYPE_T, T_TEX2, D0_CHANNEL_XY);
    /* dcl t3.xy */
    i += 3;
    i915_inst_decl(&pixel_shader_program->inst3[i], REG_TYPE_T, T_TEX3, D0_CHANNEL_XY);
    /* dcl_2D s0 */
    i += 3;
    i915_inst_decl(&pixel_shader_program->inst3[i], REG_TYPE_S, 0, D0_SAMPLE_TYPE_2D);
    /* dcl_2D s1 */
    i += 3;
    i915_inst_decl(&pixel_shader_program->inst3[i], REG_TYPE_S, 1, D0_SAMPLE_TYPE_2D);
    /* texld r0, t0, s0 */
    i += 3;
    dest = UREG(REG_TYPE_R, 0);
    src0 = UREG(REG_TYPE_T, 0); /* COORD */
    src1 = UREG(REG_TYPE_S, 0); /* SAMPLER */
    i915_inst_texld(&pixel_shader_program->inst3[i], T0_TEXLD, dest, src0, src1);
    /* texld r1, t2, s1 */
    i += 3;
    dest = UREG(REG_TYPE_R, 1);
    src0 = UREG(REG_TYPE_T, 2); /* COORD */
    src1 = UREG(REG_TYPE_S, 1); /* SAMPLER */
    i915_inst_texld(&pixel_shader_program->inst3[i], T0_TEXLD, dest, src0, src1);
    /* add r0, r0, r1 */
    i += 3;
    dest = UREG(REG_TYPE_R, 0);
    src0 = UREG(REG_TYPE_R, 0);
    src1 = UREG(REG_TYPE_R, 1);
    src2 = 0;
    i915_inst_arith(&pixel_shader_program->inst3[i], A0_ADD, dest, A0_DEST_CHANNEL_ALL,
                    0 /* A0_DEST_SATURATE */, src0, src1, src2);
    /* mul oC, r0, c0 */
    i += 3;
    dest = UREG(REG_TYPE_OC, 0);
    src0 = UREG(REG_TYPE_R, 0);
    src1 = UREG(REG_TYPE_CONST, 0);
    src2 = 0;
    i915_inst_arith(&pixel_shader_program->inst3[i], A0_MUL, dest, A0_DEST_CHANNEL_ALL,
                    A0_DEST_SATURATE, src0, src1, src2);

    memset(pixel_shader_constants, 0, sizeof(*pixel_shader_constants));
    pixel_shader_constants->dw0.type = CMD_3D;
    pixel_shader_constants->dw0.opcode = OPC_3DSTATE_PIXEL_SHADER_CONSTANTS;
    pixel_shader_constants->dw0.length = 4;
    pixel_shader_constants->dw1.reg_mask = REG_CR0;
    pixel_shader_constants->value.x = 0.5;
    pixel_shader_constants->value.y = 0.5;
    pixel_shader_constants->value.z = 0.5;
    pixel_shader_constants->value.w = 0.5;

}

static void i915_mc_one_time_state_init(XvMCContext *context)
{
    struct s3_dword *s3 = NULL;
    struct s6_dword *s6 = NULL;
    dis_state *dis = NULL;
    ssb_state *ssb = NULL;
    psp_state *psp = NULL;
    psc_state *psc = NULL;
    i915XvMCContext *pI915XvMC = (i915XvMCContext *)context->privData;
    struct i915_3dstate_load_state_immediate_1 *load_state_immediate_1;
    struct i915_3dstate_load_indirect *load_indirect;
    int mem_select;

    /* 3DSTATE_LOAD_STATE_IMMEDIATE_1 */
    one_time_load_state_imm1_size = sizeof(*load_state_immediate_1) + sizeof(*s3) + sizeof(*s6);
    one_time_load_state_imm1 = calloc(1, one_time_load_state_imm1_size);
    load_state_immediate_1 = (struct i915_3dstate_load_state_immediate_1 *)one_time_load_state_imm1;
    load_state_immediate_1->dw0.type = CMD_3D;
    load_state_immediate_1->dw0.opcode = OPC_3DSTATE_LOAD_STATE_IMMEDIATE_1;
    load_state_immediate_1->dw0.load_s3 = 1;
    load_state_immediate_1->dw0.load_s6 = 1;
    load_state_immediate_1->dw0.length = (one_time_load_state_imm1_size >> 2) - 2;

    s3 = (struct s3_dword *)(++load_state_immediate_1);
    s3->set0_pcd = 1;
    s3->set1_pcd = 1;
    s3->set2_pcd = 1;
    s3->set3_pcd = 1;
    s3->set4_pcd = 1;
    s3->set5_pcd = 1;
    s3->set6_pcd = 1;
    s3->set7_pcd = 1;

    s6 = (struct s6_dword *)(++s3);
    s6->alpha_test_enable = 0;
    s6->alpha_test_function = 0;
    s6->alpha_reference_value = 0;
    s6->depth_test_enable = 1;
    s6->depth_test_function = 0;
    s6->color_buffer_blend = 0;
    s6->color_blend_function = 0;
    s6->src_blend_factor = 1;
    s6->dest_blend_factor = 1;
    s6->depth_buffer_write = 0;
    s6->color_buffer_write = 1;
    s6->triangle_pv = 0;

    /* 3DSTATE_LOAD_INDIRECT */
    one_time_load_indirect_size = sizeof(*load_indirect) + sizeof(*dis) + sizeof(*ssb) + sizeof(*psp) + sizeof(*psc);
    one_time_load_indirect = calloc(1, one_time_load_indirect_size);
    load_indirect = (struct i915_3dstate_load_indirect *)one_time_load_indirect;
    load_indirect->dw0.type = CMD_3D;
    load_indirect->dw0.opcode = OPC_3DSTATE_LOAD_INDIRECT;
    load_indirect->dw0.block_mask = BLOCK_DIS | BLOCK_SSB | BLOCK_PSP | BLOCK_PSC;
    load_indirect->dw0.length = (one_time_load_indirect_size >> 2) - 2;

    if (pI915XvMC->deviceID == PCI_CHIP_I915_G ||
        pI915XvMC->deviceID == PCI_CHIP_I915_GM)
	mem_select = 0; /* use physical address */
    else
	mem_select = 1; /* use gfx address */

    load_indirect->dw0.mem_select = mem_select;


    /* Dynamic indirect state buffer */
    dis = (dis_state *)(++load_indirect);
    dis->dw0.valid = 0;
    dis->dw0.reset = 0;
    dis->dw0.buffer_address = 0;

    /* Sample state buffer */
    ssb = (ssb_state *)(++dis);
    ssb->dw0.valid = 1;
    ssb->dw0.force = 1;
    ssb->dw1.length = 7; /* 8 - 1 */

    if (mem_select)
        ssb->dw0.buffer_address = (pI915XvMC->ssb.offset >> 2);
    else
	ssb->dw0.buffer_address = (pI915XvMC->ssb.bus_addr >> 2);

    /* Pixel shader program buffer */
    psp = (psp_state *)(++ssb);
    psp->dw0.valid = 1;
    psp->dw0.force = 1;
    psp->dw1.length = 66; /* 4 + 16 + 16 + 31 - 1 */

    if (mem_select)
	psp->dw0.buffer_address = (pI915XvMC->psp.offset >> 2);
    else
	psp->dw0.buffer_address = (pI915XvMC->psp.bus_addr >> 2);

    /* Pixel shader constant buffer */
    psc = (psc_state *)(++psp);
    psc->dw0.valid = 1;
    psc->dw0.force = 1;
    psc->dw1.length = 5; /* 6 - 1 */

    if (mem_select)
        psc->dw0.buffer_address = (pI915XvMC->psc.offset >> 2);
    else
        psc->dw0.buffer_address = (pI915XvMC->psc.bus_addr >> 2);
d478 264
a741 257
    i915_emit_batch(one_time_load_state_imm1, one_time_load_state_imm1_size, 0);
    i915_emit_batch(one_time_load_indirect, one_time_load_indirect_size, 0);
}

static void i915_mc_static_indirect_state_init(XvMCContext *context)
{
    i915XvMCContext *pI915XvMC = (i915XvMCContext *)context->privData;
    struct i915_mc_static_indirect_state_buffer *buffer_info =
	(struct i915_mc_static_indirect_state_buffer *)pI915XvMC->sis.map;

    memset(buffer_info, 0, sizeof(*buffer_info));
    /* dest Y */
    buffer_info->dest_y.dw0.type = CMD_3D;
    buffer_info->dest_y.dw0.opcode = OPC_3DSTATE_BUFFER_INFO;
    buffer_info->dest_y.dw0.length = 1;
    buffer_info->dest_y.dw1.aux_id = 0;
    buffer_info->dest_y.dw1.buffer_id = BUFFERID_COLOR_BACK;
    buffer_info->dest_y.dw1.fence_regs = 0;    /* disabled */ /* FIXME: tiled y for performance */
    buffer_info->dest_y.dw1.tiled_surface = 0; /* linear */
    buffer_info->dest_y.dw1.walk = TILEWALK_XMAJOR;

    /* dest U */
    buffer_info->dest_u.dw0.type = CMD_3D;
    buffer_info->dest_u.dw0.opcode = OPC_3DSTATE_BUFFER_INFO;
    buffer_info->dest_u.dw0.length = 1;
    buffer_info->dest_u.dw1.aux_id = 0;
    buffer_info->dest_u.dw1.buffer_id = BUFFERID_COLOR_AUX;
    buffer_info->dest_u.dw1.fence_regs = 0;
    buffer_info->dest_u.dw1.tiled_surface = 0;
    buffer_info->dest_u.dw1.walk = TILEWALK_XMAJOR;

    /* dest V */
    buffer_info->dest_v.dw0.type = CMD_3D;
    buffer_info->dest_v.dw0.opcode = OPC_3DSTATE_BUFFER_INFO;
    buffer_info->dest_v.dw0.length = 1;
    buffer_info->dest_v.dw1.aux_id = 1;
    buffer_info->dest_v.dw1.buffer_id = BUFFERID_COLOR_AUX;
    buffer_info->dest_v.dw1.fence_regs = 0;
    buffer_info->dest_v.dw1.tiled_surface = 0;
    buffer_info->dest_v.dw1.walk = TILEWALK_XMAJOR;

    buffer_info->dest_buf.dw0.type = CMD_3D;
    buffer_info->dest_buf.dw0.opcode = OPC_3DSTATE_DEST_BUFFER_VARIABLES;
    buffer_info->dest_buf.dw0.length = 0;
    buffer_info->dest_buf.dw1.dest_v_bias = 8; /* 0.5 */
    buffer_info->dest_buf.dw1.dest_h_bias = 8; /* 0.5 */
    buffer_info->dest_buf.dw1.color_fmt = COLORBUFFER_8BIT;
    buffer_info->dest_buf.dw1.v_ls = 0; /* fill later */
    buffer_info->dest_buf.dw1.v_ls_offset = 0; /* fill later */

    buffer_info->dest_buf_mpeg.dw0.type = CMD_3D;
    buffer_info->dest_buf_mpeg.dw0.opcode = OPC_3DSTATE_DEST_BUFFER_VARIABLES_MPEG;
    buffer_info->dest_buf_mpeg.dw0.length = 1;
    buffer_info->dest_buf_mpeg.dw1.decode_mode = MPEG_DECODE_MC;
    buffer_info->dest_buf_mpeg.dw1.rcontrol = 0;               /* for MPEG-1/MPEG-2 */
    buffer_info->dest_buf_mpeg.dw1.bidir_avrg_control = 0;     /* for MPEG-1/MPEG-2/MPEG-4 */
    buffer_info->dest_buf_mpeg.dw1.abort_on_error = 1;
    buffer_info->dest_buf_mpeg.dw1.intra8 = 0;         /* 16-bit formatted correction data */
    buffer_info->dest_buf_mpeg.dw1.tff = 1; /* fill later */

    buffer_info->dest_buf_mpeg.dw1.v_subsample_factor = MC_SUB_1V;
    buffer_info->dest_buf_mpeg.dw1.h_subsample_factor = MC_SUB_1H;

    buffer_info->corr.dw0.type = CMD_3D;
    buffer_info->corr.dw0.opcode = OPC_3DSTATE_BUFFER_INFO;
    buffer_info->corr.dw0.length = 1;
    buffer_info->corr.dw1.aux_id = 0;
    buffer_info->corr.dw1.buffer_id = BUFFERID_MC_INTRA_CORR;
    buffer_info->corr.dw1.aux_id = 0;
    buffer_info->corr.dw1.fence_regs = 0;
    buffer_info->corr.dw1.tiled_surface = 0;
    buffer_info->corr.dw1.walk = 0;
    buffer_info->corr.dw1.pitch = 0;
    buffer_info->corr.dw2.base_address = (pI915XvMC->corrdata.offset >> 2);  /* starting DWORD address */
}

static void i915_mc_static_indirect_state_set(XvMCContext *context, XvMCSurface *dest,
	unsigned int picture_structure, unsigned int flags, unsigned int picture_coding_type)
{
    i915XvMCContext *pI915XvMC = (i915XvMCContext *)context->privData;
    i915XvMCSurface *pI915Surface = (i915XvMCSurface *)dest->privData;
    struct i915_mc_static_indirect_state_buffer *buffer_info =
	(struct i915_mc_static_indirect_state_buffer *)pI915XvMC->sis.map;
    unsigned int w = dest->width;

    buffer_info->dest_y.dw1.pitch = (pI915Surface->yStride >> 2);      /* in DWords */
    buffer_info->dest_y.dw2.base_address = (YOFFSET(pI915Surface) >> 2);    /* starting DWORD address */
    buffer_info->dest_u.dw1.pitch = (pI915Surface->uvStride >> 2);      /* in DWords */
    buffer_info->dest_u.dw2.base_address = (UOFFSET(pI915Surface) >> 2);      /* starting DWORD address */
    buffer_info->dest_v.dw1.pitch = (pI915Surface->uvStride >> 2);      /* in Dwords */
    buffer_info->dest_v.dw2.base_address = (VOFFSET(pI915Surface) >> 2);      /* starting DWORD address */

    if ((picture_structure & XVMC_FRAME_PICTURE) == XVMC_FRAME_PICTURE) {
        ;
    } else if ((picture_structure & XVMC_FRAME_PICTURE) == XVMC_TOP_FIELD) {
        buffer_info->dest_buf.dw1.v_ls = 1;
    } else if ((picture_structure & XVMC_FRAME_PICTURE) == XVMC_BOTTOM_FIELD) {
        buffer_info->dest_buf.dw1.v_ls = 1;
        buffer_info->dest_buf.dw1.v_ls_offset = 1;
    }

    if (picture_structure & XVMC_FRAME_PICTURE) {
        ;
    } else if (picture_structure & XVMC_TOP_FIELD) {
        if (flags & XVMC_SECOND_FIELD)
            buffer_info->dest_buf_mpeg.dw1.tff = 0;
        else
            buffer_info->dest_buf_mpeg.dw1.tff = 1;
    } else if (picture_structure & XVMC_BOTTOM_FIELD) {
        if (flags & XVMC_SECOND_FIELD)
            buffer_info->dest_buf_mpeg.dw1.tff = 1;
        else
            buffer_info->dest_buf_mpeg.dw1.tff = 0;
    }

    buffer_info->dest_buf_mpeg.dw1.picture_width = (dest->width >> 4);     /* in macroblocks */
    buffer_info->dest_buf_mpeg.dw2.picture_coding_type = picture_coding_type;
}

static void i915_mc_map_state_init(XvMCContext *context)
{
    i915XvMCContext *pI915XvMC = (i915XvMCContext *)context->privData;
    unsigned int w = context->width;
    unsigned int h = context->height;
    struct i915_mc_map_state *map_state;

    map_state = (struct i915_mc_map_state *)pI915XvMC->msb.map;

    memset(map_state, 0, sizeof(*map_state));

    /* 3DSATE_MAP_STATE: Y */
    map_state->y_map.dw0.type = CMD_3D;
    map_state->y_map.dw0.opcode = OPC_3DSTATE_MAP_STATE;
    map_state->y_map.dw0.retain = 1;
    map_state->y_map.dw0.length = 6;
    map_state->y_map.dw1.map_mask = MAP_MAP0 | MAP_MAP1;

    /* Y Forward (Past) */
    map_state->y_forward.tm0.v_ls_offset = 0;
    map_state->y_forward.tm0.v_ls = 0;
    map_state->y_forward.tm1.tile_walk = TILEWALK_XMAJOR;
    map_state->y_forward.tm1.tiled_surface = 0;
    map_state->y_forward.tm1.utilize_fence_regs = 0;
    map_state->y_forward.tm1.texel_fmt = 0;      /* 8bit */
    map_state->y_forward.tm1.surface_fmt = 1;    /* 8bit */
    map_state->y_forward.tm1.width = w - 1;
    map_state->y_forward.tm1.height = h - 1;
    map_state->y_forward.tm2.depth = 0;
    map_state->y_forward.tm2.max_lod = 0;
    map_state->y_forward.tm2.cube_face = 0;

    /* Y Backward (Future) */
    map_state->y_backward.tm0.v_ls_offset = 0;
    map_state->y_backward.tm0.v_ls = 0;
    map_state->y_backward.tm1.tile_walk = TILEWALK_XMAJOR;
    map_state->y_backward.tm1.tiled_surface = 0;
    map_state->y_backward.tm1.utilize_fence_regs = 0;
    map_state->y_backward.tm1.texel_fmt = 0;      /* 8bit */
    map_state->y_backward.tm1.surface_fmt = 1;    /* 8bit */
    map_state->y_backward.tm1.width = w - 1;
    map_state->y_backward.tm1.height = h - 1;
    map_state->y_backward.tm2.depth = 0;
    map_state->y_backward.tm2.max_lod = 0;
    map_state->y_backward.tm2.cube_face = 0;

    /* 3DSATE_MAP_STATE: U */
    map_state->u_map.dw0.type = CMD_3D;
    map_state->u_map.dw0.opcode = OPC_3DSTATE_MAP_STATE;
    map_state->u_map.dw0.retain = 1;
    map_state->u_map.dw0.length = 6;
    map_state->u_map.dw1.map_mask = MAP_MAP0 | MAP_MAP1;

    /* U Forward */
    map_state->u_forward.tm0.v_ls_offset = 0;
    map_state->u_forward.tm0.v_ls = 0;
    map_state->u_forward.tm1.tile_walk = TILEWALK_XMAJOR;
    map_state->u_forward.tm1.tiled_surface = 0;
    map_state->u_forward.tm1.utilize_fence_regs = 0;
    map_state->u_forward.tm1.texel_fmt = 0;      /* 8bit */
    map_state->u_forward.tm1.surface_fmt = 1;    /* 8bit */
    map_state->u_forward.tm1.width = (w >> 1) - 1;
    map_state->u_forward.tm1.height = (h >> 1) - 1;
    map_state->u_forward.tm2.depth = 0;
    map_state->u_forward.tm2.max_lod = 0;
    map_state->u_forward.tm2.cube_face = 0;

    /* U Backward */
    map_state->u_backward.tm0.v_ls_offset = 0;
    map_state->u_backward.tm0.v_ls = 0;
    map_state->u_backward.tm1.tile_walk = TILEWALK_XMAJOR;
    map_state->u_backward.tm1.tiled_surface = 0;
    map_state->u_backward.tm1.utilize_fence_regs = 0;
    map_state->u_backward.tm1.texel_fmt = 0;
    map_state->u_backward.tm1.surface_fmt = 1;
    map_state->u_backward.tm1.width = (w >> 1) - 1;
    map_state->u_backward.tm1.height = (h >> 1) - 1;
    map_state->u_backward.tm2.depth = 0;
    map_state->u_backward.tm2.max_lod = 0;
    map_state->u_backward.tm2.cube_face = 0;

    /* 3DSATE_MAP_STATE: V */
    map_state->v_map.dw0.type = CMD_3D;
    map_state->v_map.dw0.opcode = OPC_3DSTATE_MAP_STATE;
    map_state->v_map.dw0.retain = 1;
    map_state->v_map.dw0.length = 6;
    map_state->v_map.dw1.map_mask = MAP_MAP0 | MAP_MAP1;

    /* V Forward */
    map_state->v_forward.tm0.v_ls_offset = 0;
    map_state->v_forward.tm0.v_ls = 0;
    map_state->v_forward.tm1.tile_walk = TILEWALK_XMAJOR;
    map_state->v_forward.tm1.tiled_surface = 0;
    map_state->v_forward.tm1.utilize_fence_regs = 0;
    map_state->v_forward.tm1.texel_fmt = 0;
    map_state->v_forward.tm1.surface_fmt = 1;
    map_state->v_forward.tm1.width = (w >> 1) - 1;
    map_state->v_forward.tm1.height = (h >> 1) - 1;
    map_state->v_forward.tm2.depth = 0;
    map_state->v_forward.tm2.max_lod = 0;
    map_state->v_forward.tm2.cube_face = 0;

    /* V Backward */
    map_state->v_backward.tm0.v_ls_offset = 0;
    map_state->v_backward.tm0.v_ls = 0;
    map_state->v_backward.tm1.tile_walk = TILEWALK_XMAJOR;
    map_state->v_backward.tm1.tiled_surface = 0;
    map_state->v_backward.tm1.utilize_fence_regs = 0;
    map_state->v_backward.tm1.texel_fmt = 0;
    map_state->v_backward.tm1.surface_fmt = 1;
    map_state->v_backward.tm1.width = (w >> 1) - 1;
    map_state->v_backward.tm1.height = (h >> 1) - 1;
    map_state->v_backward.tm2.depth = 0;
    map_state->v_backward.tm2.max_lod = 0;
    map_state->v_backward.tm2.cube_face = 0;
}

static void i915_mc_map_state_set(XvMCContext *context,
	i915XvMCSurface *privPast,
	i915XvMCSurface *privFuture)
{
    i915XvMCContext *pI915XvMC = (i915XvMCContext *)context->privData;
    struct i915_mc_map_state *map_state;

    map_state = (struct i915_mc_map_state *)pI915XvMC->msb.map;

    map_state->y_forward.tm0.base_address = (YOFFSET(privPast) >> 2);
    map_state->y_forward.tm2.pitch = (privPast->yStride >> 2) - 1;       /* in DWords - 1 */
    map_state->y_backward.tm0.base_address = (YOFFSET(privFuture) >> 2);
    map_state->y_backward.tm2.pitch = (privFuture->yStride >> 2) - 1;
    map_state->u_forward.tm0.base_address = (UOFFSET(privPast) >> 2);
    map_state->u_forward.tm2.pitch = (privPast->uvStride >> 2) - 1;       /* in DWords - 1 */
    map_state->u_backward.tm0.base_address = (UOFFSET(privFuture) >> 2);
    map_state->u_backward.tm2.pitch = (privFuture->uvStride >> 2) - 1;
    map_state->v_forward.tm0.base_address = (VOFFSET(privPast) >> 2);
    map_state->v_forward.tm2.pitch = (privPast->uvStride >> 2) - 1;       /* in DWords - 1 */
    map_state->v_backward.tm0.base_address = (VOFFSET(privFuture) >> 2);
    map_state->v_backward.tm2.pitch = (privFuture->uvStride >> 2) - 1;
d746 1
a746 1
    struct i915_mi_flush mi_flush;
d748 57
a804 56
    memset(&mi_flush, 0, sizeof(mi_flush));
    mi_flush.dw0.type = CMD_MI;
    mi_flush.dw0.opcode = OPC_MI_FLUSH;
    mi_flush.dw0.map_cache_invalidate = map;
    mi_flush.dw0.render_cache_flush_inhibit = render;

    intelBatchbufferData(&mi_flush, sizeof(mi_flush), 0);
}

static void i915_mc_load_indirect_render_init(XvMCContext *context)
{
    i915XvMCContext *pI915XvMC = (i915XvMCContext *)context->privData;
    sis_state *sis;
    msb_state *msb;
    struct i915_3dstate_load_indirect *load_indirect;
    int mem_select;

    mc_render_load_indirect_size = sizeof(*load_indirect) + sizeof(*sis)
					+ sizeof(*msb);
    mc_render_load_indirect = calloc(1, mc_render_load_indirect_size);

    load_indirect = (struct i915_3dstate_load_indirect *)mc_render_load_indirect;
    load_indirect->dw0.type = CMD_3D;
    load_indirect->dw0.opcode = OPC_3DSTATE_LOAD_INDIRECT;
    load_indirect->dw0.block_mask = BLOCK_SIS | BLOCK_MSB;
    load_indirect->dw0.length = (mc_render_load_indirect_size >> 2) - 2;

    if (pI915XvMC->deviceID == PCI_CHIP_I915_G ||
        pI915XvMC->deviceID == PCI_CHIP_I915_GM)
        mem_select = 0;
    else
	mem_select = 1;

    load_indirect->dw0.mem_select = mem_select;

    /* Static Indirect state buffer (dest buffer info) */
    sis = (sis_state *)(++load_indirect);
    sis->dw0.valid = 1;
    sis->dw0.force = 1;
    sis->dw1.length = 16; /* 4 * 3 + 2 + 3 - 1 */

    if (mem_select)
	sis->dw0.buffer_address = (pI915XvMC->sis.offset >> 2);
    else
	sis->dw0.buffer_address = (pI915XvMC->sis.bus_addr >> 2);

    /* Map state buffer (reference buffer info) */
    msb = (msb_state *)(++sis);
    msb->dw0.valid = 1;
    msb->dw0.force = 1;
    msb->dw1.length = 23; /* 3 * 8 - 1 */

    if (mem_select)
	msb->dw0.buffer_address = (pI915XvMC->msb.offset >> 2);
    else
	msb->dw0.buffer_address = (pI915XvMC->msb.bus_addr >> 2);
d809 2
a810 1
    i915_emit_batch(mc_render_load_indirect, mc_render_load_indirect_size, 0);
d813 1
a813 1
static void i915_mc_mpeg_set_origin(XvMCContext *context, XvMCMacroBlock *mb)
d815 1
a815 1
    struct i915_3dmpeg_set_origin set_origin;
d817 7
a823 7
    /* 3DMPEG_SET_ORIGIN */
    memset(&set_origin, 0, sizeof(set_origin));
    set_origin.dw0.type = CMD_3D;
    set_origin.dw0.opcode = OPC_3DMPEG_SET_ORIGIN;
    set_origin.dw0.length = 0;
    set_origin.dw1.h_origin = mb->x;
    set_origin.dw1.v_origin = mb->y;
d825 1
a825 1
    intelBatchbufferData(&set_origin, sizeof(set_origin), 0);
d828 2
a829 1
static void i915_mc_mpeg_macroblock_ipicture(XvMCContext *context, XvMCMacroBlock *mb)
d831 1
a831 1
    struct i915_3dmpeg_macroblock_ipicture macroblock_ipicture;
d833 6
a838 5
    /* 3DMPEG_MACROBLOCK_IPICTURE */
    memset(&macroblock_ipicture, 0, sizeof(macroblock_ipicture));
    macroblock_ipicture.dw0.type = CMD_3D;
    macroblock_ipicture.dw0.opcode = OPC_3DMPEG_MACROBLOCK_IPICTURE;
    macroblock_ipicture.dw0.dct_type = (mb->dct_type == XVMC_DCT_TYPE_FIELD);
d840 2
a841 1
    intelBatchbufferData(&macroblock_ipicture, sizeof(macroblock_ipicture), 0);
d845 2
a846 1
static void i915_mc_mpeg_macroblock_0mv(XvMCContext *context, XvMCMacroBlock *mb)
d848 1
a848 1
    struct i915_3dmpeg_macroblock_0mv macroblock_0mv;
d850 11
a860 10
    /* 3DMPEG_MACROBLOCK(0mv) */
    memset(&macroblock_0mv, 0, sizeof(macroblock_0mv));
    macroblock_0mv.header.dw0.type = CMD_3D;
    macroblock_0mv.header.dw0.opcode = OPC_3DMPEG_MACROBLOCK;
    macroblock_0mv.header.dw0.length = 0;
    macroblock_0mv.header.dw1.mb_intra = 1;     /* should be 1 */
    macroblock_0mv.header.dw1.forward = 0;      /* should be 0 */
    macroblock_0mv.header.dw1.backward = 0;     /* should be 0 */
    macroblock_0mv.header.dw1.h263_4mv = 0;     /* should be 0 */
    macroblock_0mv.header.dw1.dct_type = (mb->dct_type == XVMC_DCT_TYPE_FIELD);
d867 4
a870 4
    macroblock_0mv.header.dw1.motion_type = 0; // (mb->motion_type & 0x3);
    macroblock_0mv.header.dw1.vertical_field_select = 0; // mb->motion_vertical_field_select & 0xf;
    macroblock_0mv.header.dw1.coded_block_pattern = mb->coded_block_pattern;
    macroblock_0mv.header.dw1.skipped_macroblocks = 0;
d872 1
a872 1
    intelBatchbufferData(&macroblock_0mv, sizeof(macroblock_0mv), 0);
d876 2
a877 1
static void i915_mc_mpeg_macroblock_1fbmv(XvMCContext *context, XvMCMacroBlock *mb)
d879 2
a880 2
    struct i915_3dmpeg_macroblock_1fbmv macroblock_1fbmv;
    vector_t mv0[2];
d882 93
a974 82
    /* 3DMPEG_MACROBLOCK(1fbmv) */
    memset(&macroblock_1fbmv, 0, sizeof(macroblock_1fbmv));
    macroblock_1fbmv.header.dw0.type = CMD_3D;
    macroblock_1fbmv.header.dw0.opcode = OPC_3DMPEG_MACROBLOCK;
    macroblock_1fbmv.header.dw0.length = 2;
    macroblock_1fbmv.header.dw1.mb_intra = 0;   /* should be 0 */
    macroblock_1fbmv.header.dw1.forward = ((mb->macroblock_type & XVMC_MB_TYPE_MOTION_FORWARD) ? 1 : 0);
    macroblock_1fbmv.header.dw1.backward = ((mb->macroblock_type & XVMC_MB_TYPE_MOTION_BACKWARD) ? 1 : 0);
    macroblock_1fbmv.header.dw1.h263_4mv = 0;   /* should be 0 */
    macroblock_1fbmv.header.dw1.dct_type = (mb->dct_type == XVMC_DCT_TYPE_FIELD);

    if (!(mb->coded_block_pattern & 0x3f))
        macroblock_1fbmv.header.dw1.dct_type = XVMC_DCT_TYPE_FRAME;

    macroblock_1fbmv.header.dw1.motion_type = (mb->motion_type & 0x03);
    macroblock_1fbmv.header.dw1.vertical_field_select = (mb->motion_vertical_field_select & 0x0f);
    macroblock_1fbmv.header.dw1.coded_block_pattern = mb->coded_block_pattern;
    macroblock_1fbmv.header.dw1.skipped_macroblocks = 0;

    mv0[0].component[0] = mb->PMV[0][0][0];
    mv0[0].component[1] = mb->PMV[0][0][1];
    mv0[1].component[0] = mb->PMV[0][1][0];
    mv0[1].component[1] = mb->PMV[0][1][1];

    macroblock_1fbmv.dw2 = mv0[0].v;
    macroblock_1fbmv.dw3 = mv0[1].v;

    intelBatchbufferData(&macroblock_1fbmv, sizeof(macroblock_1fbmv), 0);
}

static void i915_mc_mpeg_macroblock_2fbmv(XvMCContext *context, XvMCMacroBlock *mb, unsigned int ps)
{
    struct i915_3dmpeg_macroblock_2fbmv macroblock_2fbmv;
    vector_t mv0[2];
    vector_t mv1[2];

    /* 3DMPEG_MACROBLOCK(2fbmv) */
    memset(&macroblock_2fbmv, 0, sizeof(macroblock_2fbmv));
    macroblock_2fbmv.header.dw0.type = CMD_3D;
    macroblock_2fbmv.header.dw0.opcode = OPC_3DMPEG_MACROBLOCK;
    macroblock_2fbmv.header.dw0.length = 4;
    macroblock_2fbmv.header.dw1.mb_intra = 0;   /* should be 0 */
    macroblock_2fbmv.header.dw1.forward = ((mb->macroblock_type & XVMC_MB_TYPE_MOTION_FORWARD) ? 1 : 0);
    macroblock_2fbmv.header.dw1.backward = ((mb->macroblock_type & XVMC_MB_TYPE_MOTION_BACKWARD) ? 1 : 0);
    macroblock_2fbmv.header.dw1.h263_4mv = 0;   /* should be 0 */
    macroblock_2fbmv.header.dw1.dct_type = (mb->dct_type == XVMC_DCT_TYPE_FIELD);

    if (!(mb->coded_block_pattern & 0x3f))
        macroblock_2fbmv.header.dw1.dct_type = XVMC_DCT_TYPE_FRAME;

    macroblock_2fbmv.header.dw1.motion_type = (mb->motion_type & 0x03);
    macroblock_2fbmv.header.dw1.vertical_field_select = (mb->motion_vertical_field_select & 0x0f);
    macroblock_2fbmv.header.dw1.coded_block_pattern = mb->coded_block_pattern;
    macroblock_2fbmv.header.dw1.skipped_macroblocks = 0;

    mv0[0].component[0] = mb->PMV[0][0][0];
    mv0[0].component[1] = mb->PMV[0][0][1];
    mv0[1].component[0] = mb->PMV[0][1][0];
    mv0[1].component[1] = mb->PMV[0][1][1];
    mv1[0].component[0] = mb->PMV[1][0][0];
    mv1[0].component[1] = mb->PMV[1][0][1];
    mv1[1].component[0] = mb->PMV[1][1][0];
    mv1[1].component[1] = mb->PMV[1][1][1];

    if ((ps & XVMC_FRAME_PICTURE) == XVMC_FRAME_PICTURE) {
        if ((mb->motion_type & 3) == XVMC_PREDICTION_FIELD) {
            mv0[0].component[1] = mb->PMV[0][0][1] >> 1;
            mv0[1].component[1] = mb->PMV[0][1][1] >> 1;
            mv1[0].component[1] = mb->PMV[1][0][1] >> 1;
            mv1[1].component[1] = mb->PMV[1][1][1] >> 1;
        } else if ((mb->motion_type & 3) == XVMC_PREDICTION_DUAL_PRIME) {
            mv0[0].component[1] = mb->PMV[0][0][1] >> 1;
            mv0[1].component[1] = mb->PMV[0][1][1] >> 1;  // MPEG2 MV[0][1] isn't used
            mv1[0].component[1] = mb->PMV[1][0][1] >> 1;
            mv1[1].component[1] = mb->PMV[1][1][1] >> 1;
        }
    }

    macroblock_2fbmv.dw2 = mv0[0].v;
    macroblock_2fbmv.dw3 = mv0[1].v;
    macroblock_2fbmv.dw4 = mv1[0].v;
    macroblock_2fbmv.dw5 = mv1[1].v;
d976 1
a976 1
    intelBatchbufferData(&macroblock_2fbmv, sizeof(macroblock_2fbmv), 0);
d980 2
a981 1
static void i915_mc_invalidate_subcontext_buffers(XvMCContext *context, unsigned int mask)
d983 101
a1083 101
    struct i915_3dstate_load_indirect *load_indirect = NULL;
    sis_state *sis = NULL;
    dis_state *dis = NULL;
    ssb_state *ssb = NULL;
    msb_state *msb = NULL;
    psp_state *psp = NULL;
    psc_state *psc = NULL;
    i915XvMCContext *pI915XvMC = (i915XvMCContext *)context->privData;
    unsigned int size;
    void *base = NULL, *ptr = NULL;

    size = sizeof(*load_indirect);
    if (mask & BLOCK_SIS)
        size += sizeof(*sis);
    if (mask & BLOCK_DIS)
        size += sizeof(*dis);
    if (mask & BLOCK_SSB)
        size += sizeof(*ssb);
    if (mask & BLOCK_MSB)
        size += sizeof(*msb);
    if (mask & BLOCK_PSP)
        size += sizeof(*psp);
    if (mask & BLOCK_PSC)
        size += sizeof(*psc);

    if (size == sizeof(*load_indirect)) {
        XVMC_ERR("There must be at least one bit set\n");
        return;
    }

    /* 3DSTATE_LOAD_INDIRECT */
    base = calloc(1, size);
    load_indirect = (struct i915_3dstate_load_indirect *)base;
    load_indirect->dw0.type = CMD_3D;
    load_indirect->dw0.opcode = OPC_3DSTATE_LOAD_INDIRECT;

    if (pI915XvMC->deviceID == PCI_CHIP_I915_G ||
        pI915XvMC->deviceID == PCI_CHIP_I915_GM ||
        pI915XvMC->deviceID == PCI_CHIP_I945_G ||
        pI915XvMC->deviceID == PCI_CHIP_I945_GM)
        load_indirect->dw0.mem_select = 0;
    else
        load_indirect->dw0.mem_select = 1;

    load_indirect->dw0.block_mask = mask;
    load_indirect->dw0.length = (size >> 2) - 2;
    ptr = ++load_indirect;

    /* SIS */
    if (mask & BLOCK_SIS) {
        sis = (sis_state *)ptr;
        sis->dw0.valid = 0;
        sis->dw0.buffer_address = 0;
        sis->dw1.length = 0;
        ptr = ++sis;
    }

    /* DIS */
    if (mask & BLOCK_DIS) {
        dis = (dis_state *)ptr;
        dis->dw0.valid = 0;
        dis->dw0.reset = 0;
        dis->dw0.buffer_address = 0;
        ptr = ++dis;
    }

    /* SSB */
    if (mask & BLOCK_SSB) {
        ssb = (ssb_state *)ptr;
        ssb->dw0.valid = 0;
        ssb->dw0.buffer_address = 0;
        ssb->dw1.length = 0;
        ptr = ++ssb;
    }

    /* MSB */
    if (mask & BLOCK_MSB) {
        msb = (msb_state *)ptr;
        msb->dw0.valid = 0;
        msb->dw0.buffer_address = 0;
        msb->dw1.length = 0;
        ptr = ++msb;
    }

    /* PSP */
    if (mask & BLOCK_PSP) {
        psp = (psp_state *)ptr;
        psp->dw0.valid = 0;
        psp->dw0.buffer_address = 0;
        psp->dw1.length = 0;
        ptr = ++psp;
    }

    /* PSC */
    if (mask & BLOCK_PSC) {
        psc = (psc_state *)ptr;
        psc->dw0.valid = 0;
        psc->dw0.buffer_address = 0;
        psc->dw1.length = 0;
        ptr = ++psc;
    }
d1085 2
a1086 2
    intelBatchbufferData(base, size, 0);
    free(base);
d1090 1
a1090 1
static int i915_xvmc_map_buffers(i915XvMCContext *pI915XvMC)
d1092 76
a1167 76
    if (drmMap(xvmc_driver->fd,
               pI915XvMC->sis.handle,
               pI915XvMC->sis.size,
               (drmAddress *)&pI915XvMC->sis.map) != 0) {
        return -1;
    }

    if (drmMap(xvmc_driver->fd,
               pI915XvMC->ssb.handle,
               pI915XvMC->ssb.size,
               (drmAddress *)&pI915XvMC->ssb.map) != 0) {
        return -1;
    }

    if (drmMap(xvmc_driver->fd,
               pI915XvMC->msb.handle,
               pI915XvMC->msb.size,
               (drmAddress *)&pI915XvMC->msb.map) != 0) {
        return -1;
    }

    if (drmMap(xvmc_driver->fd,
               pI915XvMC->psp.handle,
               pI915XvMC->psp.size,
               (drmAddress *)&pI915XvMC->psp.map) != 0) {
        return -1;
    }

    if (drmMap(xvmc_driver->fd,
               pI915XvMC->psc.handle,
               pI915XvMC->psc.size,
               (drmAddress *)&pI915XvMC->psc.map) != 0) {
        return -1;
    }

    if (drmMap(xvmc_driver->fd,
               pI915XvMC->corrdata.handle,
               pI915XvMC->corrdata.size,
               (drmAddress *)&pI915XvMC->corrdata.map) != 0) {
        return -1;
    }

    return 0;
}

static void i915_xvmc_unmap_buffers(i915XvMCContext *pI915XvMC)
{
    if (pI915XvMC->sis.map) {
        drmUnmap(pI915XvMC->sis.map, pI915XvMC->sis.size);
        pI915XvMC->sis.map = NULL;
    }

    if (pI915XvMC->ssb.map) {
        drmUnmap(pI915XvMC->ssb.map, pI915XvMC->ssb.size);
        pI915XvMC->ssb.map = NULL;
    }

    if (pI915XvMC->msb.map) {
        drmUnmap(pI915XvMC->msb.map, pI915XvMC->msb.size);
        pI915XvMC->msb.map = NULL;
    }

    if (pI915XvMC->psp.map) {
        drmUnmap(pI915XvMC->psp.map, pI915XvMC->psp.size);
        pI915XvMC->psp.map = NULL;
    }

    if (pI915XvMC->psc.map) {
        drmUnmap(pI915XvMC->psc.map, pI915XvMC->psc.size);
        pI915XvMC->psc.map = NULL;
    }

    if (pI915XvMC->corrdata.map) {
        drmUnmap(pI915XvMC->corrdata.map, pI915XvMC->corrdata.size);
        pI915XvMC->corrdata.map = NULL;
    }
d1174 1
a1174 1
static void i915_yuv2rgb_map_state_buffer(XvMCSurface *target_surface)
d1176 70
a1245 70
    struct i915_3dstate_map_state *map_state;
    struct texture_map *tm;
    i915XvMCSurface *privTarget = NULL;
    i915XvMCContext *pI915XvMC = NULL;
    unsigned int w = target_surface->width, h = target_surface->height;

    privTarget = (i915XvMCSurface *)target_surface->privData;
    pI915XvMC = (i915XvMCContext *)privTarget->privContext;
    /* 3DSATE_MAP_STATE */
    map_state = (struct i915_3dstate_map_state *)pI915XvMC->msb.map;
    memset(map_state, 0, sizeof(*map_state));
    map_state->dw0.type = CMD_3D;
    map_state->dw0.opcode = OPC_3DSTATE_MAP_STATE;
    map_state->dw0.retain = 0;
    map_state->dw0.length = 9;
    map_state->dw1.map_mask = MAP_MAP0 | MAP_MAP1 | MAP_MAP2;

    /* texture map 0: V Plane */
    tm = (struct texture_map *)(++map_state);
    memset(tm, 0, sizeof(*tm));
    tm->tm0.v_ls_offset = 0;
    tm->tm0.v_ls = 0;
    tm->tm0.base_address = VOFFSET(privTarget);
    tm->tm1.tile_walk = TILEWALK_XMAJOR;
    tm->tm1.tiled_surface = 0;
    tm->tm1.utilize_fence_regs = 1;
    tm->tm1.texel_fmt = 0;
    tm->tm1.surface_fmt = 1;
    tm->tm1.width = (w >> 1) - 1;
    tm->tm1.height = (h >> 1) - 1;
    tm->tm2.depth = 0;
    tm->tm2.max_lod = 0;
    tm->tm2.cube_face = 0;
    tm->tm2.pitch = (privTarget->uvStride >> 2) - 1;    /* in DWords - 1 */

    /* texture map 1: Y Plane */
    ++tm;
    memset(tm, 0, sizeof(*tm));
    tm->tm0.v_ls_offset = 0;
    tm->tm0.v_ls = 0;
    tm->tm0.base_address = YOFFSET(privTarget);
    tm->tm1.tile_walk = TILEWALK_XMAJOR;
    tm->tm1.tiled_surface = 0;
    tm->tm1.utilize_fence_regs = 1;
    tm->tm1.texel_fmt = 0;
    tm->tm1.surface_fmt = 1;
    tm->tm1.width = w - 1;
    tm->tm1.height = h - 1;
    tm->tm2.depth = 0;
    tm->tm2.max_lod = 0;
    tm->tm2.cube_face = 0;
    tm->tm2.pitch = (privTarget->yStride >> 2) - 1;     /* in DWords - 1 */

    /* texture map 2: U Plane */
    ++tm;
    memset(tm, 0, sizeof(*tm));
    tm->tm0.v_ls_offset = 0;
    tm->tm0.v_ls = 0;
    tm->tm0.base_address = UOFFSET(privTarget);
    tm->tm1.tile_walk = TILEWALK_XMAJOR;
    tm->tm1.tiled_surface = 0;
    tm->tm1.utilize_fence_regs = 1;
    tm->tm1.texel_fmt = 0;
    tm->tm1.surface_fmt = 1;
    tm->tm1.width = (w >> 1) - 1;
    tm->tm1.height = (h >> 1) - 1;
    tm->tm2.depth = 0;
    tm->tm2.max_lod = 0;
    tm->tm2.cube_face = 0;
    tm->tm2.pitch = (privTarget->uvStride >> 2) - 1;    /* in DWords - 1 */
d1250 1
a1250 1
static void i915_yuv2rgb_sampler_state_buffer(XvMCSurface *surface)
d1252 95
a1346 93
    struct i915_3dstate_sampler_state *sampler_state;
    struct texture_sampler *ts;
    i915XvMCSurface *privSurface = (i915XvMCSurface *)surface->privData;
    i915XvMCContext *pI915XvMC = (i915XvMCContext *)privSurface->privContext;

    /* 3DSATE_SAMPLER_STATE */
    sampler_state = (struct i915_3dstate_sampler_state *)pI915XvMC->ssb.map;
    memset(sampler_state, 0, sizeof(*sampler_state));
    sampler_state->dw0.type = CMD_3D;
    sampler_state->dw0.opcode = OPC_3DSTATE_SAMPLER_STATE;
    sampler_state->dw0.length = 9;
    sampler_state->dw1.sampler_masker = SAMPLER_SAMPLER0 | SAMPLER_SAMPLER1 | SAMPLER_SAMPLER2;

    /* Sampler 0 */
    ts = (struct texture_sampler *)(++sampler_state);
    memset(ts, 0, sizeof(*ts));
    ts->ts0.reverse_gamma = 0;
    ts->ts0.planar2packet = 1;
    ts->ts0.color_conversion = 1;
    ts->ts0.chromakey_index = 0;
    ts->ts0.base_level = 0;
    ts->ts0.mip_filter = MIPFILTER_NONE;        /* NONE */
    ts->ts0.mag_filter = MAPFILTER_LINEAR;      /* LINEAR */
    ts->ts0.min_filter = MAPFILTER_LINEAR;      /* LINEAR */
    ts->ts0.lod_bias = 0;
    ts->ts0.shadow_enable = 0;
    ts->ts0.max_anisotropy = ANISORATIO_2;
    ts->ts0.shadow_function = PREFILTEROP_ALWAYS;
    ts->ts1.min_lod = 0;        /* Maximum Mip Level */
    ts->ts1.kill_pixel = 0;
    ts->ts1.keyed_texture_filter = 0;
    ts->ts1.chromakey_enable = 0;
    ts->ts1.tcx_control = TEXCOORDMODE_CLAMP;
    ts->ts1.tcy_control = TEXCOORDMODE_CLAMP;
    ts->ts1.tcz_control = TEXCOORDMODE_CLAMP;
    ts->ts1.normalized_coor = 0;
    ts->ts1.map_index = 0;
    ts->ts1.east_deinterlacer = 0;
    ts->ts2.default_color = 0;

    /* Sampler 1 */
    ++ts;
    memset(ts, 0, sizeof(*ts));
    ts->ts0.reverse_gamma = 0;
    ts->ts0.planar2packet = 1;
    ts->ts0.color_conversion = 1;
    ts->ts0.chromakey_index = 0;
    ts->ts0.base_level = 0;
    ts->ts0.mip_filter = MIPFILTER_NONE;        /* NONE */
    ts->ts0.mag_filter = MAPFILTER_LINEAR;      /* LINEAR */
    ts->ts0.min_filter = MAPFILTER_LINEAR;      /* LINEAR */
    ts->ts0.lod_bias = 0;
    ts->ts0.shadow_enable = 0;
    ts->ts0.max_anisotropy = ANISORATIO_2;
    ts->ts0.shadow_function = PREFILTEROP_ALWAYS;
    ts->ts1.min_lod = 0;        /* Maximum Mip Level */
    ts->ts1.kill_pixel = 0;
    ts->ts1.keyed_texture_filter = 0;
    ts->ts1.chromakey_enable = 0;
    ts->ts1.tcx_control = TEXCOORDMODE_CLAMP;
    ts->ts1.tcy_control = TEXCOORDMODE_CLAMP;
    ts->ts1.tcz_control = TEXCOORDMODE_CLAMP;
    ts->ts1.normalized_coor = 0;
    ts->ts1.map_index = 1;
    ts->ts1.east_deinterlacer = 0;
    ts->ts2.default_color = 0;

    /* Sampler 2 */
    ++ts;
    memset(ts, 0, sizeof(*ts));
    ts->ts0.reverse_gamma = 0;
    ts->ts0.planar2packet = 1;
    ts->ts0.color_conversion = 1;
    ts->ts0.chromakey_index = 0;
    ts->ts0.base_level = 0;
    ts->ts0.mip_filter = MIPFILTER_NONE;        /* NONE */
    ts->ts0.mag_filter = MAPFILTER_LINEAR;      /* LINEAR */
    ts->ts0.min_filter = MAPFILTER_LINEAR;      /* LINEAR */
    ts->ts0.lod_bias = 0;
    ts->ts0.shadow_enable = 0;
    ts->ts0.max_anisotropy = ANISORATIO_2;
    ts->ts0.shadow_function = PREFILTEROP_ALWAYS;
    ts->ts1.min_lod = 0;        /* Maximum Mip Level */
    ts->ts1.kill_pixel = 0;
    ts->ts1.keyed_texture_filter = 0;
    ts->ts1.chromakey_enable = 0;
    ts->ts1.tcx_control = TEXCOORDMODE_CLAMP;
    ts->ts1.tcy_control = TEXCOORDMODE_CLAMP;
    ts->ts1.tcz_control = TEXCOORDMODE_CLAMP;
    ts->ts1.normalized_coor = 0;
    ts->ts1.map_index = 2;
    ts->ts1.east_deinterlacer = 0;
    ts->ts2.default_color = 0;
d1351 34
a1384 32
static void i915_yuv2rgb_static_indirect_state_buffer(XvMCSurface *surface,
                                                      unsigned int dstaddr,
                                                      int dstpitch)
{
    struct i915_3dstate_buffer_info *buffer_info;
    struct i915_3dstate_dest_buffer_variables *dest_buffer_variables;
    i915XvMCSurface *privSurface = (i915XvMCSurface *)surface->privData;
    i915XvMCContext *pI915XvMC = (i915XvMCContext *)privSurface->privContext;

    /* 3DSTATE_BUFFER_INFO */
    buffer_info = (struct i915_3dstate_buffer_info *)pI915XvMC->sis.map;
    memset(buffer_info, 0, sizeof(*buffer_info));
    buffer_info->dw0.type = CMD_3D;
    buffer_info->dw0.opcode = OPC_3DSTATE_BUFFER_INFO;
    buffer_info->dw0.length = 1;
    buffer_info->dw1.aux_id = 0;
    buffer_info->dw1.buffer_id = BUFFERID_COLOR_BACK;
    buffer_info->dw1.fence_regs = 1;
    buffer_info->dw1.tiled_surface = 0;   /* linear */
    buffer_info->dw1.walk = TILEWALK_XMAJOR;
    buffer_info->dw1.pitch = dstpitch;
    buffer_info->dw2.base_address = dstaddr;

    /* 3DSTATE_DEST_BUFFER_VARIABLES */
    dest_buffer_variables = (struct i915_3dstate_dest_buffer_variables *)(++buffer_info);
    memset(dest_buffer_variables, 0, sizeof(*dest_buffer_variables));
    dest_buffer_variables->dw0.type = CMD_3D;
    dest_buffer_variables->dw0.opcode = OPC_3DSTATE_DEST_BUFFER_VARIABLES;
    dest_buffer_variables->dw0.length = 0;
    dest_buffer_variables->dw1.dest_v_bias = 8; /* FIXME 0x1000 .5 ??? */
    dest_buffer_variables->dw1.dest_h_bias = 8;
    dest_buffer_variables->dw1.color_fmt = COLORBUFFER_A8R8G8B8;  /* FIXME */
d1389 1
a1389 1
static void i915_yuv2rgb_pixel_shader_program_buffer(XvMCSurface *surface)
d1391 48
a1438 46
    struct i915_3dstate_pixel_shader_program *pixel_shader_program;
    i915XvMCSurface *privSurface = (i915XvMCSurface *)surface->privData;
    i915XvMCContext *pI915XvMC = (i915XvMCContext *)privSurface->privContext;
    unsigned int *inst;
    unsigned int dest, src0, src1;

    /* Shader 0 */
    pixel_shader_program = (struct i915_3dstate_pixel_shader_program *)pI915XvMC->psp.map;
    memset(pixel_shader_program, 0, sizeof(*pixel_shader_program));
    pixel_shader_program->dw0.type = CMD_3D;
    pixel_shader_program->dw0.opcode = OPC_3DSTATE_PIXEL_SHADER_PROGRAM;
    pixel_shader_program->dw0.retain = 0;
    pixel_shader_program->dw0.length = 23;
    /* dcl      t0.xy */
    inst = (unsigned int*)(++pixel_shader_program);
    i915_inst_decl(inst, REG_TYPE_T, T_TEX0, D0_CHANNEL_XY);
    /* dcl         t1.xy */
    inst += 3;
    i915_inst_decl(inst, REG_TYPE_T, T_TEX1, D0_CHANNEL_XY);
    /* dcl_2D   s0 */
    inst += 3;
    i915_inst_decl(inst, REG_TYPE_S, 0, D0_SAMPLE_TYPE_2D);
    /* dcl_2D   s1 */
    inst += 3;
    i915_inst_decl(inst, REG_TYPE_S, 1, D0_SAMPLE_TYPE_2D);
    /* dcl_2D   s2 */
    inst += 3;
    i915_inst_decl(inst, REG_TYPE_S, 2, D0_SAMPLE_TYPE_2D);
    /* texld    r0 t1 s0 */
    inst += 3;
    dest = UREG(REG_TYPE_R, 0);
    src0 = UREG(REG_TYPE_T, 1); /* COORD */
    src1 = UREG(REG_TYPE_S, 0); /* SAMPLER */
    i915_inst_texld(inst, T0_TEXLD, dest, src0, src1);
    /* texld    r0 t0 s1 */
    inst += 3;
    dest = UREG(REG_TYPE_R, 0);
    src0 = UREG(REG_TYPE_T, 0); /* COORD */
    src1 = UREG(REG_TYPE_S, 1); /* SAMPLER */
    i915_inst_texld(inst, T0_TEXLD, dest, src0, src1);
    /* texld    oC t1 s2 */
    inst += 3;
    dest = UREG(REG_TYPE_OC, 0);
    src0 = UREG(REG_TYPE_T, 1); /* COORD */
    src1 = UREG(REG_TYPE_S, 2); /* SAMPLER */
    i915_inst_texld(inst, T0_TEXLD, dest, src0, src1);
d1443 1
a1443 1
static void i915_yuv2rgb_proc(XvMCSurface *surface)
d1445 157
a1601 150
    i915XvMCSurface *privSurface = (i915XvMCSurface *)surface->privData;
    i915XvMCContext *pI915XvMC = (i915XvMCContext *)privSurface->privContext;
    struct i915_3dstate_load_state_immediate_1 *load_state_immediate_1 = NULL;
    struct s2_dword *s2 = NULL;
    struct s3_dword *s3 = NULL;
    struct s4_dword *s4 = NULL;
    struct s5_dword *s5 = NULL;
    struct s6_dword *s6 = NULL;
    struct s7_dword *s7 = NULL;
    struct i915_3dstate_scissor_rectangle scissor_rectangle;
    struct i915_3dstate_load_indirect *load_indirect = NULL;
    sis_state *sis = NULL;
    ssb_state *ssb = NULL;
    msb_state *msb = NULL;
    psp_state *psp = NULL;
    struct i915_3dprimitive *_3dprimitive = NULL;
    struct vertex_data *vd = NULL;
    unsigned int size;
    void *base = NULL;

    /* 3DSTATE_LOAD_STATE_IMMEDIATE_1 */
    size = sizeof(*load_state_immediate_1) + sizeof(*s2) + sizeof(*s3) +
        sizeof(*s4) + sizeof(*s5) + sizeof(*s6) + sizeof(*s7);
    base = calloc(1, size);
    load_state_immediate_1 = (struct i915_3dstate_load_state_immediate_1 *)base;
    load_state_immediate_1->dw0.type = CMD_3D;
    load_state_immediate_1->dw0.opcode = OPC_3DSTATE_LOAD_STATE_IMMEDIATE_1;
    load_state_immediate_1->dw0.load_s2 = 1;
    load_state_immediate_1->dw0.load_s3 = 1;
    load_state_immediate_1->dw0.load_s4 = 1;
    load_state_immediate_1->dw0.load_s5 = 1;
    load_state_immediate_1->dw0.load_s6 = 1;
    load_state_immediate_1->dw0.load_s7 = 1;
    load_state_immediate_1->dw0.length = 5;

    s2 = (struct s2_dword *)(++load_state_immediate_1);
    s2->set0_texcoord_fmt = TEXCOORDFMT_2FP;
    s2->set1_texcoord_fmt = TEXCOORDFMT_2FP;
    s2->set2_texcoord_fmt = TEXCOORDFMT_NOT_PRESENT;
    s2->set3_texcoord_fmt = TEXCOORDFMT_NOT_PRESENT;
    s2->set4_texcoord_fmt = TEXCOORDFMT_NOT_PRESENT;
    s2->set5_texcoord_fmt = TEXCOORDFMT_NOT_PRESENT;
    s2->set6_texcoord_fmt = TEXCOORDFMT_NOT_PRESENT;
    s2->set7_texcoord_fmt = TEXCOORDFMT_NOT_PRESENT;

    s3 = (struct s3_dword *)(++s2);
    s4 = (struct s4_dword *)(++s3);
    s4->position_mask = VERTEXHAS_XY;
    s4->cull_mode = CULLMODE_NONE;
    s4->color_shade_mode = SHADEMODE_FLAT;
    s4->specular_shade_mode = SHADEMODE_FLAT;
    s4->fog_shade_mode = SHADEMODE_FLAT;
    s4->alpha_shade_mode = SHADEMODE_FLAT;
    s4->line_width = 0x2;     /* FIXME: 1.0??? */
    s4->point_width = 0x1;

    s5 = (struct s5_dword *)(++s4);
    s6 = (struct s6_dword *)(++s5);
    s6->src_blend_factor = 1;
    s6->dest_blend_factor = 1;
    s6->color_buffer_write = 1;

    s7 = (struct s7_dword *)(++s6);
    intelBatchbufferData(base, size, 0);
    free(base);

    /* 3DSTATE_3DSTATE_SCISSOR_RECTANGLE */
    scissor_rectangle.dw0.type = CMD_3D;
    scissor_rectangle.dw0.opcode = OPC_3DSTATE_SCISSOR_RECTANGLE;
    scissor_rectangle.dw0.length = 1;
    scissor_rectangle.dw1.min_x = 0;
    scissor_rectangle.dw1.min_y = 0;
    scissor_rectangle.dw2.max_x = 2047;
    scissor_rectangle.dw2.max_y = 2047;
    intelBatchbufferData(&scissor_rectangle, sizeof(scissor_rectangle), 0);

    /* 3DSTATE_LOAD_INDIRECT */
    size = sizeof(*load_indirect) + sizeof(*sis) + sizeof(*ssb) + sizeof(*msb) + sizeof(*psp);
    base = calloc(1, size);
    load_indirect = (struct i915_3dstate_load_indirect *)base;
    load_indirect->dw0.type = CMD_3D;
    load_indirect->dw0.opcode = OPC_3DSTATE_LOAD_INDIRECT;
    load_indirect->dw0.mem_select = 1;  /* Bearlake only */
    load_indirect->dw0.block_mask = BLOCK_SIS | BLOCK_SSB | BLOCK_MSB | BLOCK_PSP;
    load_indirect->dw0.length = 7;

    /* SIS */
    sis = (sis_state *)(++load_indirect);
    sis->dw0.valid = 1;
    sis->dw0.buffer_address = pI915XvMC->sis.offset;
    sis->dw1.length = ((sizeof(struct i915_3dstate_buffer_info) +
                        sizeof(struct i915_3dstate_dest_buffer_variables)) >> 2) - 1;

    /* SSB */
    ssb = (ssb_state *)(++sis);
    ssb->dw0.valid = 1;
    ssb->dw0.buffer_address = pI915XvMC->ssb.offset;
    ssb->dw1.length = ((sizeof(struct i915_3dstate_sampler_state) +
                        sizeof(struct texture_sampler) * 3) >> 2) - 1;

    /* MSB */
    msb = (msb_state *)(++ssb);
    msb->dw0.valid = 1;
    msb->dw0.buffer_address = pI915XvMC->msb.offset;
    msb->dw1.length = ((sizeof(struct i915_3dstate_map_state) +
                        sizeof(struct texture_map) * 3) >> 2) - 1;

    /* PSP */
    psp = (psp_state *)(++msb);
    psp->dw0.valid = 1;
    psp->dw0.buffer_address = pI915XvMC->psp.offset;
    psp->dw1.length = ((sizeof(struct i915_3dstate_pixel_shader_program) +
                        sizeof(union shader_inst)) >> 2) - 1;

    intelBatchbufferData(base, size, 0);
    free(base);

    /* 3DPRIMITIVE */
    size = sizeof(*_3dprimitive) + sizeof(*vd) * 3;
    base = calloc(1, size);
    _3dprimitive = (struct i915_3dprimitive *)base;
    _3dprimitive->dw0.inline_prim.type = CMD_3D;
    _3dprimitive->dw0.inline_prim.opcode = OPC_3DPRIMITIVE;
    _3dprimitive->dw0.inline_prim.vertex_location = VERTEX_INLINE;
    _3dprimitive->dw0.inline_prim.prim = PRIM_RECTLIST;
    _3dprimitive->dw0.inline_prim.length = size - 2;

    vd = (struct vertex_data *)(++_3dprimitive);
    vd->x = 0;          /* FIXME!!! */
    vd->x = 0;          /* FIXME */
    vd->tc0.tcx = 0;
    vd->tc0.tcy = 0;
    vd->tc1.tcx = 0;
    vd->tc1.tcy = 0;

    ++vd;
    vd->x = 0;          /* FIXME!!! */
    vd->x = 0;          /* FIXME */
    vd->tc0.tcx = 0;
    vd->tc0.tcy = 0;
    vd->tc1.tcx = 0;
    vd->tc1.tcy = 0;

    ++vd;
    vd->x = 0;          /* FIXME!!! */
    vd->x = 0;          /* FIXME */
    vd->tc0.tcx = 0;
    vd->tc0.tcy = 0;
    vd->tc1.tcx = 0;
    vd->tc1.tcy = 0;
d1603 2
a1604 2
    intelBatchbufferData(base, size, 0);
    free(base);
d1611 1
a1611 1
static void i915_release_resource(Display *display, XvMCContext *context)
d1613 1
a1613 1
    i915XvMCContext *pI915XvMC;
d1615 2
a1616 2
    if (!(pI915XvMC = context->privData))
        return;
d1618 507
a2124 498
    pI915XvMC->ref--;
    i915_xvmc_unmap_buffers(pI915XvMC);

    free(pI915XvMC);
    context->privData = NULL;
}

static Status i915_xvmc_mc_create_context(Display *display, XvMCContext *context,
	int priv_count, CARD32 *priv_data)
{
    i915XvMCContext *pI915XvMC = NULL;
    I915XvMCCreateContextRec *tmpComm = NULL;
    drm_sarea_t *pSAREA;

    XVMC_DBG("%s\n", __FUNCTION__);

    if (priv_count != (sizeof(I915XvMCCreateContextRec) >> 2)) {
        XVMC_ERR("_xvmc_create_context() returned incorrect data size!");
        XVMC_INFO("\tExpected %d, got %d",
               (int)(sizeof(I915XvMCCreateContextRec) >> 2),priv_count);
        _xvmc_destroy_context(display, context);
        XFree(priv_data);
        context->privData = NULL;
        return BadValue;
    }

    context->privData = (void *)calloc(1, sizeof(i915XvMCContext));
    if (!context->privData) {
        XVMC_ERR("Unable to allocate resources for XvMC context.");
        return BadAlloc;
    }
    pI915XvMC = (i915XvMCContext *)context->privData;

    tmpComm = (I915XvMCCreateContextRec *)priv_data;
    pI915XvMC->ctxno = tmpComm->ctxno;
    pI915XvMC->deviceID = tmpComm->deviceID;
    pI915XvMC->sis.handle = tmpComm->sis.handle;
    pI915XvMC->sis.offset = tmpComm->sis.offset;
    pI915XvMC->sis.size = tmpComm->sis.size;
    pI915XvMC->ssb.handle = tmpComm->ssb.handle;
    pI915XvMC->ssb.offset = tmpComm->ssb.offset;
    pI915XvMC->ssb.size = tmpComm->ssb.size;
    pI915XvMC->msb.handle = tmpComm->msb.handle;
    pI915XvMC->msb.offset = tmpComm->msb.offset;
    pI915XvMC->msb.size = tmpComm->msb.size;
    pI915XvMC->psp.handle = tmpComm->psp.handle;
    pI915XvMC->psp.offset = tmpComm->psp.offset;
    pI915XvMC->psp.size = tmpComm->psp.size;
    pI915XvMC->psc.handle = tmpComm->psc.handle;
    pI915XvMC->psc.offset = tmpComm->psc.offset;
    pI915XvMC->psc.size = tmpComm->psc.size;

    if (pI915XvMC->deviceID == PCI_CHIP_I915_G ||
        pI915XvMC->deviceID == PCI_CHIP_I915_GM) {
        pI915XvMC->sis.bus_addr = tmpComm->sis.bus_addr;
        pI915XvMC->ssb.bus_addr = tmpComm->ssb.bus_addr;
        pI915XvMC->msb.bus_addr = tmpComm->msb.bus_addr;
        pI915XvMC->psp.bus_addr = tmpComm->psp.bus_addr;
        pI915XvMC->psc.bus_addr = tmpComm->psc.bus_addr;
    }

    pI915XvMC->corrdata.handle = tmpComm->corrdata.handle;
    pI915XvMC->corrdata.offset = tmpComm->corrdata.offset;
    pI915XvMC->corrdata.size = tmpComm->corrdata.size;
    pI915XvMC->sarea_priv_offset = tmpComm->sarea_priv_offset;

    /* Must free the private data we were passed from X */
    XFree(priv_data);
    priv_data = NULL;

    pSAREA = (drm_sarea_t *)xvmc_driver->sarea_address;
    pI915XvMC->sarea = (drmI830Sarea*)((char*)pSAREA + pI915XvMC->sarea_priv_offset);

    if (i915_xvmc_map_buffers(pI915XvMC)) {
        i915_xvmc_unmap_buffers(pI915XvMC);
        free(pI915XvMC);
        context->privData = NULL;
        return BadAlloc;
    }

    /* Initialize private context values */
    pI915XvMC->yStride = STRIDE(context->width);
    pI915XvMC->uvStride = STRIDE(context->width >> 1);
    pI915XvMC->haveXv = 0;
    pI915XvMC->dual_prime = 0;
    pI915XvMC->last_flip = 0;
    pI915XvMC->port = context->port;
    pI915XvMC->ref = 1;

    /* pre-init state buffers */
    i915_mc_one_time_context_init(context);
    i915_mc_one_time_state_init(context);

    i915_mc_static_indirect_state_init(context);

    i915_mc_map_state_init(context);

    i915_mc_load_indirect_render_init(context);
    return Success;
}

static int i915_xvmc_mc_destroy_context(Display *display, XvMCContext *context)
{
    i915XvMCContext *pI915XvMC;

    if (!(pI915XvMC = context->privData))
        return XvMCBadContext;

    /* Pass Control to the X server to destroy the drm_context_t */
    i915_release_resource(display,context);

    free(one_time_load_state_imm1);
    free(one_time_load_indirect);
    free(mc_render_load_indirect);
    return Success;
}

static Status i915_xvmc_mc_create_surface(Display *display,
	XvMCContext *context, XvMCSurface *surface, int priv_count,
	CARD32 *priv_data)
{
    i915XvMCContext *pI915XvMC;
    i915XvMCSurface *pI915Surface;
    I915XvMCCreateSurfaceRec *tmpComm = NULL;

    if (!(pI915XvMC = context->privData))
        return XvMCBadContext;

    XVMC_DBG("%s\n", __FUNCTION__);

    if (priv_count != (sizeof(I915XvMCCreateSurfaceRec) >> 2)) {
        XVMC_ERR("_xvmc_create_surface() returned incorrect data size!");
        XVMC_INFO("\tExpected %d, got %d",
               (int)(sizeof(I915XvMCCreateSurfaceRec) >> 2), priv_count);
        _xvmc_destroy_surface(display, surface);
        XFree(priv_data);
        return BadAlloc;
    }

    PPTHREAD_MUTEX_LOCK();
    surface->privData = (i915XvMCSurface *)malloc(sizeof(i915XvMCSurface));

    if (!(pI915Surface = surface->privData)) {
        PPTHREAD_MUTEX_UNLOCK();
        return BadAlloc;
    }

    /* Initialize private values */
    pI915Surface->last_render = 0;
    pI915Surface->last_flip = 0;
    pI915Surface->yStride = pI915XvMC->yStride;
    pI915Surface->uvStride = pI915XvMC->uvStride;
    pI915Surface->width = context->width;
    pI915Surface->height = context->height;
    pI915Surface->privContext = pI915XvMC;
    pI915Surface->privSubPic = NULL;
    pI915Surface->srf.map = NULL;

    tmpComm = (I915XvMCCreateSurfaceRec *)priv_data;

    pI915Surface->srfNo = tmpComm->srfno;
    pI915Surface->srf.handle = tmpComm->srf.handle;
    pI915Surface->srf.offset = tmpComm->srf.offset;
    pI915Surface->srf.size = tmpComm->srf.size;

    XFree(priv_data);

    if (drmMap(xvmc_driver->fd,
               pI915Surface->srf.handle,
               pI915Surface->srf.size,
               (drmAddress *)&pI915Surface->srf.map) != 0) {
	XVMC_ERR("mapping surface memory failed!\n");
        _xvmc_destroy_surface(display, surface);
        free(pI915Surface);
        surface->privData = NULL;
        PPTHREAD_MUTEX_UNLOCK();
        return BadAlloc;
    }

    pI915XvMC->ref++;
    PPTHREAD_MUTEX_UNLOCK();
    return 0;
}


static int i915_xvmc_mc_destroy_surface(Display *display, XvMCSurface *surface)
{
    i915XvMCSurface *pI915Surface;
    i915XvMCContext *pI915XvMC;

    if (!display || !surface)
        return BadValue;

    if (!(pI915Surface = surface->privData))
        return XvMCBadSurface;

    if (!(pI915XvMC = pI915Surface->privContext))
        return XvMCBadSurface;

    if (pI915Surface->last_flip)
        XvMCSyncSurface(display,surface);

    if (pI915Surface->srf.map)
        drmUnmap(pI915Surface->srf.map, pI915Surface->srf.size);

    free(pI915Surface);
    surface->privData = NULL;
    pI915XvMC->ref--;

    return Success;
}


static int i915_xvmc_mc_render_surface(Display *display, XvMCContext *context,
                         unsigned int picture_structure,
                         XvMCSurface *target_surface,
                         XvMCSurface *past_surface,
                         XvMCSurface *future_surface,
                         unsigned int flags,
                         unsigned int num_macroblocks,
                         unsigned int first_macroblock,
                         XvMCMacroBlockArray *macroblock_array,
                         XvMCBlockArray *blocks)
{
    int i;
    int picture_coding_type = MPEG_I_PICTURE;
    /* correction data buffer */
    char *corrdata_ptr;
    int corrdata_size = 0;

    /* Block Pointer */
    short *block_ptr;
    /* Current Macroblock Pointer */
    XvMCMacroBlock *mb;

    intel_xvmc_context_ptr intel_ctx;

    i915XvMCSurface *privTarget = NULL;
    i915XvMCSurface *privFuture = NULL;
    i915XvMCSurface *privPast = NULL;
    i915XvMCContext *pI915XvMC = NULL;

    XVMC_DBG("%s\n", __FUNCTION__);

    /* Check Parameters for validity */
    if (!display || !context || !target_surface) {
        XVMC_ERR("Invalid Display, Context or Target!");
        return BadValue;
    }

    if (!num_macroblocks)
        return Success;

    if (!macroblock_array || !blocks) {
        XVMC_ERR("Invalid block data!");
        return BadValue;
    }

    if (macroblock_array->num_blocks < (num_macroblocks + first_macroblock)) {
        XVMC_ERR("Too many macroblocks requested for MB array size.");
        return BadValue;
    }

    if (!(pI915XvMC = context->privData))
        return XvMCBadContext;

    if (!(privTarget = target_surface->privData))
        return XvMCBadSurface;

    if (context->surface_type_id >= SURFACE_TYPE_MAX) {
        XVMC_ERR("Unsupprted surface_type_id %d.", context->surface_type_id);
        return BadValue;
    }

    intel_ctx = intel_xvmc_find_context(context->context_id);
    if (!intel_ctx) {
	XVMC_ERR("Can't find intel xvmc context\n");
	return BadValue;
    }

    /* P Frame Test */
    if (!past_surface) {
        /* Just to avoid some ifs later. */
        privPast = privTarget;
    } else {
        if (!(privPast = past_surface->privData)) {
            XVMC_ERR("Invalid Past Surface!");
            return XvMCBadSurface;
        }
        picture_coding_type = MPEG_P_PICTURE;
    }

    /* B Frame Test */
    if (!future_surface) {
        privFuture = privPast; // privTarget;
    } else {
        if (!past_surface) {
            XVMC_ERR("No Past Surface!");
            return BadValue;
        }

        if (!(privFuture = future_surface->privData)) {
            XVMC_ERR("Invalid Future Surface!");
            return XvMCBadSurface;
        }

        picture_coding_type = MPEG_B_PICTURE;
    }

    LOCK_HARDWARE(intel_ctx->hw_context);
    corrdata_ptr = pI915XvMC->corrdata.map;
    corrdata_size = 0;

    for (i = first_macroblock; i < (num_macroblocks + first_macroblock); i++) {
        int bspm = 0;
        mb = &macroblock_array->macro_blocks[i];
        block_ptr = &(blocks->blocks[mb->index << 6]);

        /* Lockup can happen if the coordinates are too far out of range */
        if (mb->x > (target_surface->width >> 4)) {
            mb->x = 0;
            XVMC_INFO("reset x");
        }

        if (mb->y > (target_surface->height >> 4)) {
            mb->y = 0;
            XVMC_INFO("reset y");
        }

        /* Catch no pattern case */
        if (!(mb->macroblock_type & XVMC_MB_TYPE_PATTERN) &&
            !(mb->macroblock_type & XVMC_MB_TYPE_INTRA) &&
            mb->coded_block_pattern) {
            mb->coded_block_pattern = 0;
            XVMC_INFO("no coded blocks present!");
        }

        bspm = mb_bytes_420[mb->coded_block_pattern];

        if (!bspm)
            continue;

        corrdata_size += bspm;

        if (corrdata_size > pI915XvMC->corrdata.size) {
            XVMC_ERR("correction data buffer overflow.");
            break;
        }
        memcpy(corrdata_ptr, block_ptr, bspm);
        corrdata_ptr += bspm;
    }

    i915_flush(1, 0);
    // i915_mc_invalidate_subcontext_buffers(context, BLOCK_SIS | BLOCK_DIS | BLOCK_SSB
    // | BLOCK_MSB | BLOCK_PSP | BLOCK_PSC);

    i915_mc_one_time_state_emit();

    i915_mc_static_indirect_state_set(context, target_surface, picture_structure,
	    flags, picture_coding_type);
    /* setup reference surfaces */
    i915_mc_map_state_set(context, privPast, privFuture);

    i915_mc_load_indirect_render_emit();

    i915_mc_mpeg_set_origin(context, &macroblock_array->macro_blocks[first_macroblock]);

    for (i = first_macroblock; i < (num_macroblocks + first_macroblock); i++) {
        mb = &macroblock_array->macro_blocks[i];

        /* Intra Blocks */
        if (mb->macroblock_type & XVMC_MB_TYPE_INTRA) {
            i915_mc_mpeg_macroblock_ipicture(context, mb);
        } else if ((picture_structure & XVMC_FRAME_PICTURE) == XVMC_FRAME_PICTURE) {
	    /* Frame Picture */
            switch (mb->motion_type & 3) {
            case XVMC_PREDICTION_FIELD: /* Field Based */
                i915_mc_mpeg_macroblock_2fbmv(context, mb, picture_structure);
                break;

            case XVMC_PREDICTION_FRAME: /* Frame Based */
                i915_mc_mpeg_macroblock_1fbmv(context, mb);
                break;

            case XVMC_PREDICTION_DUAL_PRIME:    /* Dual Prime */
                i915_mc_mpeg_macroblock_2fbmv(context, mb, picture_structure);
                break;

            default:    /* No Motion Type */
		XVMC_ERR("Invalid Macroblock Parameters found.");
                break;
            }
        } else {        /* Field Picture */
            switch (mb->motion_type & 3) {
            case XVMC_PREDICTION_FIELD: /* Field Based */
                i915_mc_mpeg_macroblock_1fbmv(context, mb);
                break;

            case XVMC_PREDICTION_16x8:  /* 16x8 MC */
                i915_mc_mpeg_macroblock_2fbmv(context, mb, picture_structure);
                break;

            case XVMC_PREDICTION_DUAL_PRIME:    /* Dual Prime */
                i915_mc_mpeg_macroblock_1fbmv(context, mb);
                break;

            default:    /* No Motion Type */
		XVMC_ERR("Invalid Macroblock Parameters found.");
                break;
            }
        }
    }

    intelFlushBatch(TRUE);
    xvmc_driver->last_render = xvmc_driver->alloc.irq_emitted;
    privTarget->last_render = xvmc_driver->last_render;

    UNLOCK_HARDWARE(intel_ctx->hw_context);
    return 0;
}

static int i915_xvmc_mc_put_surface(Display *display,XvMCSurface *surface,
                      Drawable draw, short srcx, short srcy,
                      unsigned short srcw, unsigned short srch,
                      short destx, short desty,
                      unsigned short destw, unsigned short desth,
                      int flags, struct intel_xvmc_command *data)
{
    i915XvMCContext *pI915XvMC;
    i915XvMCSurface *pI915Surface;
    i915XvMCSubpicture *pI915SubPic;

    if (!(pI915Surface = surface->privData))
        return XvMCBadSurface;

    if (!(pI915XvMC = pI915Surface->privContext))
        return XvMCBadSurface;

    PPTHREAD_MUTEX_LOCK();

    data->command = INTEL_XVMC_COMMAND_DISPLAY;
    data->ctxNo = pI915XvMC->ctxno;
    data->srfNo = pI915Surface->srfNo;
    pI915SubPic = pI915Surface->privSubPic;
    data->subPicNo = (!pI915SubPic ? 0 : pI915SubPic->srfNo);
    data->real_id = FOURCC_YV12;
    data->flags = flags;

    PPTHREAD_MUTEX_UNLOCK();

    return 0;
}

static int i915_xvmc_mc_get_surface_status(Display *display,
	XvMCSurface *surface, int *stat)
{
    i915XvMCSurface *pI915Surface;
    i915XvMCContext *pI915XvMC;

    if (!display || !surface || !stat)
        return BadValue;

    *stat = 0;

    if (!(pI915Surface = surface->privData))
        return XvMCBadSurface;

    if (!(pI915XvMC = pI915Surface->privContext))
        return XvMCBadSurface;

    PPTHREAD_MUTEX_LOCK();
    if (pI915Surface->last_flip) {
        /* This can not happen */
        if (pI915XvMC->last_flip < pI915Surface->last_flip) {
            XVMC_ERR("Context last flip is less than surface last flip.");
            PPTHREAD_MUTEX_UNLOCK();
            return BadValue;
        }

        /*
          If the context has 2 or more flips after this surface it
          cannot be displaying. Don't bother to check.
        */
        if (!(pI915XvMC->last_flip > (pI915Surface->last_flip + 1))) {
            /*
              If this surface was the last flipped it is either displaying
              or about to be so don't bother checking.
            */
            if (pI915XvMC->last_flip == pI915Surface->last_flip) {
                *stat |= XVMC_DISPLAYING;
            }
        }
    }

    if (pI915Surface->last_render &&
        (pI915Surface->last_render > pI915XvMC->sarea->last_dispatch)) {
        *stat |= XVMC_RENDERING;
    }
d2126 2
a2127 2
    PPTHREAD_MUTEX_UNLOCK();
    return 0;
d2132 1
a2132 1
Status XvMCHideSurface(Display *display, XvMCSurface *surface)
d2134 3
a2136 3
    i915XvMCSurface *pI915Surface;
    i915XvMCContext *pI915XvMC;
    int stat = 0, ret;
d2138 2
a2139 2
    if (!display || !surface)
        return BadValue;
d2141 2
a2142 2
    if (!(pI915Surface = surface->privData))
        return XvMCBadSurface;
d2144 3
a2146 3
    /* Get the associated context pointer */
    if (!(pI915XvMC = pI915Surface->privContext))
        return XvMCBadSurface;
d2148 1
a2148 1
    XvMCSyncSurface(display, surface);
d2150 6
a2155 6
    /*
      Get the status of the surface, if it is not currently displayed
      we don't need to worry about it.
    */
    if ((ret = XvMCGetSurfaceStatus(display, surface, &stat)) != Success)
        return ret;
d2157 2
a2158 2
    if (!(stat & XVMC_DISPLAYING))
        return Success;
d2160 2
a2161 2
    /* FIXME: */
    return Success;
d2164 4
a2167 4
Status i915_xvmc_create_subpict(Display *display, XvMCContext *context,
                            XvMCSubpicture *subpicture,
                            unsigned short width, unsigned short height,
                            int xvimage_id)
d2169 6
a2174 6
    Status ret;
    i915XvMCContext *pI915XvMC;
    i915XvMCSubpicture *pI915Subpicture;
    I915XvMCCreateSurfaceRec *tmpComm = NULL;
    int priv_count;
    uint *priv_data;
d2176 2
a2177 2
    if (!subpicture || !context || !display)
        return BadValue;
d2179 1
a2179 1
    pI915XvMC = (i915XvMCContext *)context->privData;
d2181 2
a2182 2
    if (!pI915XvMC)
        return XvMCBadContext;
d2184 2
a2185 2
    subpicture->privData =
        (i915XvMCSubpicture *)malloc(sizeof(i915XvMCSubpicture));
d2187 2
a2188 2
    if (!subpicture->privData)
        return BadAlloc;
d2190 6
a2195 6
    PPTHREAD_MUTEX_LOCK();
    subpicture->context_id = context->context_id;
    subpicture->xvimage_id = xvimage_id;
    subpicture->width = width;
    subpicture->height = height;
    pI915Subpicture = (i915XvMCSubpicture *)subpicture->privData;
d2197 11
a2207 11
    XLockDisplay(display);
    if ((ret = _xvmc_create_subpicture(display, context, subpicture,
                                       &priv_count, &priv_data))) {
        XUnlockDisplay(display);
        XVMC_ERR("Unable to create XvMCSubpicture.");
        free(pI915Subpicture);
        subpicture->privData = NULL;
        PPTHREAD_MUTEX_UNLOCK();
        return ret;
    }
    XUnlockDisplay(display);
d2209 15
a2223 13
    if (priv_count != (sizeof(I915XvMCCreateSurfaceRec) >> 2)) {
        XVMC_ERR("_xvmc_create_subpicture() returned incorrect data size!");
        XVMC_INFO("\tExpected %d, got %d",
               (int)(sizeof(I915XvMCCreateSurfaceRec) >> 2), priv_count);
        XLockDisplay(display);
        _xvmc_destroy_subpicture(display, subpicture);
        XUnlockDisplay(display);
        XFree(priv_data);
        free(pI915Subpicture);
        subpicture->privData = NULL;
        PPTHREAD_MUTEX_UNLOCK();
        return BadAlloc;
    }
d2225 6
a2230 6
    tmpComm = (I915XvMCCreateSurfaceRec *)priv_data;
    pI915Subpicture->srfNo = tmpComm->srfno;
    pI915Subpicture->srf.handle = tmpComm->srf.handle;
    pI915Subpicture->srf.offset = tmpComm->srf.offset;
    pI915Subpicture->srf.size = tmpComm->srf.size;
    XFree(priv_data);
d2232 12
a2243 12
    if (drmMap(pI915XvMC->fd,
               pI915Subpicture->srf.handle,
               pI915Subpicture->srf.size,
               (drmAddress *)&pI915Subpicture->srf.map) != 0) {
        XLockDisplay(display);
        _xvmc_destroy_subpicture(display, subpicture);
        XUnlockDisplay(display);
        free(pI915Subpicture);
        subpicture->privData = NULL;
        PPTHREAD_MUTEX_UNLOCK();
        return BadAlloc;
    }
d2245 4
a2248 4
    /* subpicture */
    subpicture->num_palette_entries = I915_SUBPIC_PALETTE_SIZE;
    subpicture->entry_bytes = 3;
    strncpy(subpicture->component_order, "YUV", 4);
d2250 5
a2254 5
    /* Initialize private values */
    pI915Subpicture->privContext = pI915XvMC;
    pI915Subpicture->last_render= 0;
    pI915Subpicture->last_flip = 0;
    pI915Subpicture->pitch = ((subpicture->width + 3) & ~3);
d2256 4
a2259 4
    switch(subpicture->xvimage_id) {
    case FOURCC_IA44:
    case FOURCC_AI44:
        break;
d2261 10
a2270 10
    default:
        drmUnmap(pI915Subpicture->srf.map, pI915Subpicture->srf.size);
        XLockDisplay(display);
        _xvmc_destroy_subpicture(display, subpicture);
        XUnlockDisplay(display);
        free(pI915Subpicture);
        subpicture->privData = NULL;
        PPTHREAD_MUTEX_UNLOCK();
        return BadMatch;
    }
d2272 3
a2274 3
    pI915XvMC->ref++;
    PPTHREAD_MUTEX_UNLOCK();
    return Success;
d2277 4
a2280 4
Status i915_xvmc_clear_subpict(Display *display, XvMCSubpicture *subpicture,
                           short x, short y,
                           unsigned short width, unsigned short height,
                           unsigned int color)
d2282 2
a2283 2
    i915XvMCContext *pI915XvMC;
    i915XvMCSubpicture *pI915Subpicture;
d2285 2
a2286 2
    if (!display || !subpicture)
        return BadValue;
d2288 2
a2289 2
    if (!(pI915Subpicture = subpicture->privData))
        return XvMCBadSubpicture;
d2291 2
a2292 2
    if (!(pI915XvMC = pI915Subpicture->privContext))
        return XvMCBadSubpicture;
d2294 2
a2295 2
    if ((x < 0) || (x + width) > subpicture->width)
        return BadValue;
d2297 2
a2298 2
    if ((y < 0) || (y + height) > subpicture->height)
        return BadValue;
d2300 1
a2300 1
    /* FIXME: clear the area */
d2302 1
a2302 1
    return Success;
d2305 5
a2309 5
Status i915_xvmc_composite_subpict(Display *display, XvMCSubpicture *subpicture,
                               XvImage *image,
                               short srcx, short srcy,
                               unsigned short width, unsigned short height,
                               short dstx, short dsty)
d2311 2
a2312 2
    i915XvMCContext *pI915XvMC;
    i915XvMCSubpicture *pI915Subpicture;
d2314 2
a2315 2
    if (!display || !subpicture)
        return BadValue;
d2317 2
a2318 2
    if (!(pI915Subpicture = subpicture->privData))
        return XvMCBadSubpicture;
d2320 2
a2321 2
    if (!(pI915XvMC = pI915Subpicture->privContext))
        return XvMCBadSubpicture;
d2323 2
a2324 2
    if ((srcx < 0) || (srcx + width) > subpicture->width)
        return BadValue;
d2326 2
a2327 2
    if ((srcy < 0) || (srcy + height) > subpicture->height)
        return BadValue;
d2329 2
a2330 2
    if ((dstx < 0) || (dstx + width) > subpicture->width)
        return BadValue;
d2332 2
a2333 2
    if ((dsty < 0) || (dsty + width) > subpicture->height)
        return BadValue;
d2335 2
a2336 2
    if (image->id != subpicture->xvimage_id)
        return BadMatch;
d2338 2
a2339 2
    /* FIXME */
    return Success;
d2342 1
a2342 2

Status i915_xvmc_destroy_subpict(Display *display, XvMCSubpicture *subpicture)
d2344 2
a2345 2
    i915XvMCSubpicture *pI915Subpicture;
    i915XvMCContext *pI915XvMC;
d2347 2
a2348 2
    if (!display || !subpicture)
        return BadValue;
d2350 2
a2351 2
    if (!(pI915Subpicture = subpicture->privData))
        return XvMCBadSubpicture;
d2353 2
a2354 2
    if (!(pI915XvMC = pI915Subpicture->privContext))
        return XvMCBadSubpicture;
d2356 2
a2357 2
    if (pI915Subpicture->last_render)
        XvMCSyncSubpicture(display, subpicture);
d2359 2
a2360 2
    if (pI915Subpicture->srf.map)
        drmUnmap(pI915Subpicture->srf.map, pI915Subpicture->srf.size);
d2362 4
a2365 4
    PPTHREAD_MUTEX_LOCK();
    XLockDisplay(display);
    _xvmc_destroy_subpicture(display,subpicture);
    XUnlockDisplay(display);
d2367 4
a2370 4
    free(pI915Subpicture);
    subpicture->privData = NULL;
    pI915XvMC->ref--;
    PPTHREAD_MUTEX_UNLOCK();
d2372 1
a2372 1
    return Success;
d2375 3
a2377 4

Status i915_xvmc_set_subpict_palette(Display *display,
	XvMCSubpicture *subpicture,
	unsigned char *palette)
d2379 2
a2380 2
    i915XvMCSubpicture *pI915Subpicture;
    int i, j;
d2382 2
a2383 2
    if (!display || !subpicture)
        return BadValue;
d2385 2
a2386 2
    if (!(pI915Subpicture = subpicture->privData))
        return XvMCBadSubpicture;
d2388 6
a2393 6
    j = 0;
    for (i = 0; i < 16; i++) {
        pI915Subpicture->palette[0][i] = palette[j++];
        pI915Subpicture->palette[1][i] = palette[j++];
        pI915Subpicture->palette[2][i] = palette[j++];
    }
d2395 2
a2396 2
    /* FIXME: Update the subpicture with the new palette */
    return Success;
d2399 6
a2404 6
Status i915_xvmc_blend_subpict(Display *display, XvMCSurface *target_surface,
                           XvMCSubpicture *subpicture,
                           short subx, short suby,
                           unsigned short subw, unsigned short subh,
                           short surfx, short surfy,
                           unsigned short surfw, unsigned short surfh)
d2406 2
a2407 2
    i915XvMCSubpicture *pI915Subpicture;
    i915XvMCSurface *privTargetSurface;
d2409 2
a2410 2
    if (!display || !target_surface)
        return BadValue;
d2412 2
a2413 2
    if (!(privTargetSurface = target_surface->privData))
        return XvMCBadSurface;
d2415 3
a2417 3
    if (subpicture) {
        if (!(pI915Subpicture = subpicture->privData))
            return XvMCBadSubpicture;
d2419 3
a2421 3
        if ((FOURCC_AI44 != subpicture->xvimage_id) &&
            (FOURCC_IA44 != subpicture->xvimage_id))
            return XvMCBadSubpicture;
d2423 4
a2426 4
        privTargetSurface->privSubPic = pI915Subpicture;
    } else {
        privTargetSurface->privSubPic = NULL;
    }
d2428 1
a2428 1
    return Success;
d2431 8
a2438 8
Status i915_xvmc_blend_subpict2(Display *display,
                            XvMCSurface *source_surface,
                            XvMCSurface *target_surface,
                            XvMCSubpicture *subpicture,
                            short subx, short suby,
                            unsigned short subw, unsigned short subh,
                            short surfx, short surfy,
                            unsigned short surfw, unsigned short surfh)
d2440 4
a2443 4
    i915XvMCContext *pI915XvMC;
    i915XvMCSubpicture *pI915Subpicture;
    i915XvMCSurface *privSourceSurface;
    i915XvMCSurface *privTargetSurface;
d2445 2
a2446 2
    if (!display || !source_surface || !target_surface)
        return BadValue;
d2448 2
a2449 2
    if (!(privSourceSurface = source_surface->privData))
        return XvMCBadSurface;
d2451 2
a2452 2
    if (!(privTargetSurface = target_surface->privData))
        return XvMCBadSurface;
d2454 2
a2455 2
    if (!(pI915XvMC = privTargetSurface->privContext))
        return XvMCBadSurface;
d2457 3
a2459 3
    if (((surfx + surfw) > privTargetSurface->width) ||
        ((surfy + surfh) > privTargetSurface->height))
        return BadValue;
d2461 3
a2463 3
    if ((privSourceSurface->width != privTargetSurface->width) ||
        (privTargetSurface->height != privTargetSurface->height))
        return BadValue;
d2465 2
a2466 2
    if (XvMCSyncSurface(display, source_surface))
        return BadValue;
d2468 1
a2468 1
    /* FIXME: update Target Surface */
d2470 4
a2473 4
    if (subpicture) {
        if (((subx + subw) > subpicture->width) ||
            ((suby + subh) > subpicture->height))
            return BadValue;
d2475 2
a2476 2
        if (!(pI915Subpicture = subpicture->privData))
            return XvMCBadSubpicture;
d2478 3
a2480 3
        if ((FOURCC_AI44 != subpicture->xvimage_id) &&
            (FOURCC_IA44 != subpicture->xvimage_id))
            return XvMCBadSubpicture;
d2482 4
a2485 4
        privTargetSurface->privSubPic = pI915Subpicture;
    } else {
        privTargetSurface->privSubPic = NULL;
    }
d2487 1
a2487 1
    return Success;
d2490 1
a2490 1
Status i915_xvmc_sync_subpict(Display *display, XvMCSubpicture *subpicture)
d2492 2
a2493 2
    Status ret;
    int stat = 0;
d2495 2
a2496 2
    if (!display || !subpicture)
        return BadValue;
d2498 3
a2500 3
    do {
        ret = XvMCGetSubpictureStatus(display, subpicture, &stat);
    } while(!ret && (stat & XVMC_RENDERING));
d2502 1
a2502 1
    return ret;
d2505 1
a2505 1
Status i915_xvmc_flush_subpict(Display *display, XvMCSubpicture *subpicture)
d2507 1
a2507 1
    i915XvMCSubpicture *pI915Subpicture;
d2509 2
a2510 2
    if (!display || !subpicture)
        return BadValue;
d2512 2
a2513 2
    if (!(pI915Subpicture = subpicture->privData))
        return XvMCBadSubpicture;
d2515 1
a2515 1
    return Success;
d2518 2
a2519 2
Status i915_xvmc_get_subpict_status(Display *display, XvMCSubpicture *subpicture,
                               int *stat)
d2521 2
a2522 2
    i915XvMCSubpicture *pI915Subpicture;
    i915XvMCContext *pI915XvMC;
d2524 2
a2525 2
    if (!display || !subpicture || stat)
        return BadValue;
d2527 1
a2527 1
    *stat = 0;
d2529 2
a2530 2
    if (!(pI915Subpicture = subpicture->privData))
        return XvMCBadSubpicture;
d2532 2
a2533 2
    if (!(pI915XvMC = pI915Subpicture->privContext))
        return XvMCBadSubpicture;
d2535 1
a2535 6
    PPTHREAD_MUTEX_LOCK();
    /* FIXME: */
    if (pI915Subpicture->last_render &&
        (pI915Subpicture->last_render > pI915XvMC->sarea->last_dispatch)) {
        *stat |= XVMC_RENDERING;
    }
d2537 2
a2538 2
    PPTHREAD_MUTEX_UNLOCK();
    return Success;
d2544 10
a2553 10
    .type		= XVMC_I915_MPEG2_MC,
    .num_ctx		= 0,
    .ctx_list		= NULL,
    .create_context	= i915_xvmc_mc_create_context,
    .destroy_context	= i915_xvmc_mc_destroy_context,
    .create_surface	= i915_xvmc_mc_create_surface,
    .destroy_surface	= i915_xvmc_mc_destroy_surface,
    .render_surface	= i915_xvmc_mc_render_surface,
    .put_surface	= i915_xvmc_mc_put_surface,
    .get_surface_status	= i915_xvmc_mc_get_surface_status,
@


1.2
log
@update to xf86-video-intel 2.3.2. Tested among others by okan@@.
@
text
@a40 12
/* Lookup tables to speed common calculations */
static unsigned int mb_bytes[] = {
    000, 128, 128, 256, 128, 256, 256, 384,  // 0
    128, 256, 256, 384, 256, 384, 384, 512,  // 1
    128, 256, 256, 384, 256, 384, 384, 512,  // 10
    256, 384, 384, 512, 384, 512, 512, 640,  // 11
    128, 256, 256, 384, 256, 384, 384, 512,  // 100
    256, 384, 384, 512, 384, 512, 512, 640,  // 101
    256, 384, 384, 512, 384, 512, 512, 640,  // 110
    384, 512, 512, 640, 512, 640, 640, 768   // 111
};

d42 3
a44 3
    short s[4];
    uint  u[2];
} su_t;
a83 571
static void i915_flush(int map, int render)
{
    struct i915_mi_flush mi_flush;

    memset(&mi_flush, 0, sizeof(mi_flush));
    mi_flush.dw0.type = CMD_MI;
    mi_flush.dw0.opcode = OPC_MI_FLUSH;
    mi_flush.dw0.map_cache_invalidate = map;
    mi_flush.dw0.render_cache_flush_inhibit = render;

    intelBatchbufferData(&mi_flush, sizeof(mi_flush), 0);
}

/* for MC picture rendering */
static void i915_mc_static_indirect_state_buffer(XvMCContext *context,
	XvMCSurface *surface,
	unsigned int picture_structure,
	unsigned int flags,
	unsigned int picture_coding_type)
{
    struct i915_3dstate_buffer_info *buffer_info;
    struct i915_3dstate_dest_buffer_variables *dest_buffer_variables;
    struct i915_3dstate_dest_buffer_variables_mpeg *dest_buffer_variables_mpeg;
    i915XvMCSurface *pI915Surface = (i915XvMCSurface *)surface->privData;
    i915XvMCContext *pI915XvMC = (i915XvMCContext *)context->privData;
    unsigned int w = surface->width;

    /* 3DSTATE_BUFFER_INFO */
    /* DEST Y */
    buffer_info = (struct i915_3dstate_buffer_info *)pI915XvMC->sis.map;
    memset(buffer_info, 0, sizeof(*buffer_info));
    buffer_info->dw0.type = CMD_3D;
    buffer_info->dw0.opcode = OPC_3DSTATE_BUFFER_INFO;
    buffer_info->dw0.length = 1;
    buffer_info->dw1.aux_id = 0;
    buffer_info->dw1.buffer_id = BUFFERID_COLOR_BACK;
    buffer_info->dw1.fence_regs = 0;    /* disabled */ /* FIXME: tiled y for performance */
    buffer_info->dw1.tiled_surface = 0; /* linear */
    buffer_info->dw1.walk = TILEWALK_XMAJOR;
    buffer_info->dw1.pitch = (pI915Surface->yStride >> 2);      /* in DWords */
    buffer_info->dw2.base_address = (YOFFSET(pI915Surface) >> 2);    /* starting DWORD address */

    /* DEST U */
    ++buffer_info;
    memset(buffer_info, 0, sizeof(*buffer_info));
    buffer_info->dw0.type = CMD_3D;
    buffer_info->dw0.opcode = OPC_3DSTATE_BUFFER_INFO;
    buffer_info->dw0.length = 1;
    buffer_info->dw1.aux_id = 0;
    buffer_info->dw1.buffer_id = BUFFERID_COLOR_AUX;
    buffer_info->dw1.fence_regs = 0;
    buffer_info->dw1.tiled_surface = 0;
    buffer_info->dw1.walk = TILEWALK_XMAJOR;
    buffer_info->dw1.pitch = (pI915Surface->uvStride >> 2);      /* in DWords */
    buffer_info->dw2.base_address = (UOFFSET(pI915Surface) >> 2);      /* starting DWORD address */

    /* DEST V */
    ++buffer_info;
    memset(buffer_info, 0, sizeof(*buffer_info));
    buffer_info->dw0.type = CMD_3D;
    buffer_info->dw0.opcode = OPC_3DSTATE_BUFFER_INFO;
    buffer_info->dw0.length = 1;
    buffer_info->dw1.aux_id = 1;
    buffer_info->dw1.buffer_id = BUFFERID_COLOR_AUX;
    buffer_info->dw1.fence_regs = 0;
    buffer_info->dw1.tiled_surface = 0;
    buffer_info->dw1.walk = TILEWALK_XMAJOR;
    buffer_info->dw1.pitch = (pI915Surface->uvStride >> 2);      /* in Dwords */
    buffer_info->dw2.base_address = (VOFFSET(pI915Surface) >> 2);      /* starting DWORD address */

    /* 3DSTATE_DEST_BUFFER_VARIABLES */
    dest_buffer_variables = (struct i915_3dstate_dest_buffer_variables *)(++buffer_info);
    memset(dest_buffer_variables, 0, sizeof(*dest_buffer_variables));
    dest_buffer_variables->dw0.type = CMD_3D;
    dest_buffer_variables->dw0.opcode = OPC_3DSTATE_DEST_BUFFER_VARIABLES;
    dest_buffer_variables->dw0.length = 0;
    dest_buffer_variables->dw1.dest_v_bias = 8; /* 0.5 */
    dest_buffer_variables->dw1.dest_h_bias = 8; /* 0.5 */
    dest_buffer_variables->dw1.color_fmt = COLORBUFFER_8BIT;
    dest_buffer_variables->dw1.v_ls = 0;
    dest_buffer_variables->dw1.v_ls_offset = 0;

    if ((picture_structure & XVMC_FRAME_PICTURE) == XVMC_FRAME_PICTURE) {
        ;
    } else if ((picture_structure & XVMC_FRAME_PICTURE) == XVMC_TOP_FIELD) {
        dest_buffer_variables->dw1.v_ls = 1;
    } else if ((picture_structure & XVMC_FRAME_PICTURE) == XVMC_BOTTOM_FIELD) {
        dest_buffer_variables->dw1.v_ls = 1;
        dest_buffer_variables->dw1.v_ls_offset = 1;
    }

    /* 3DSTATE_DEST_BUFFER_VARIABLES_MPEG */
    dest_buffer_variables_mpeg = (struct i915_3dstate_dest_buffer_variables_mpeg *)(++dest_buffer_variables);
    memset(dest_buffer_variables_mpeg, 0, sizeof(*dest_buffer_variables_mpeg));
    dest_buffer_variables_mpeg->dw0.type = CMD_3D;
    dest_buffer_variables_mpeg->dw0.opcode = OPC_3DSTATE_DEST_BUFFER_VARIABLES_MPEG;
    dest_buffer_variables_mpeg->dw0.length = 1;
    dest_buffer_variables_mpeg->dw1.decode_mode = MPEG_DECODE_MC;
    dest_buffer_variables_mpeg->dw1.rcontrol = 0;               /* for MPEG-1/MPEG-2 */
    dest_buffer_variables_mpeg->dw1.bidir_avrg_control = 0;     /* for MPEG-1/MPEG-2/MPEG-4 */
    dest_buffer_variables_mpeg->dw1.abort_on_error = 1;
    dest_buffer_variables_mpeg->dw1.intra8 = 0;         /* 16-bit formatted correction data */
    dest_buffer_variables_mpeg->dw1.tff = 1;

    if (picture_structure & XVMC_FRAME_PICTURE) {
        ;
    } else if (picture_structure & XVMC_TOP_FIELD) {
        if (flags & XVMC_SECOND_FIELD)
            dest_buffer_variables_mpeg->dw1.tff = 0;
        else
            dest_buffer_variables_mpeg->dw1.tff = 1;
    } else if (picture_structure & XVMC_BOTTOM_FIELD) {
        if (flags & XVMC_SECOND_FIELD)
            dest_buffer_variables_mpeg->dw1.tff = 1;
        else
            dest_buffer_variables_mpeg->dw1.tff = 0;
    }

    dest_buffer_variables_mpeg->dw1.v_subsample_factor = MC_SUB_1V;
    dest_buffer_variables_mpeg->dw1.h_subsample_factor = MC_SUB_1H;
    dest_buffer_variables_mpeg->dw1.picture_width = (w >> 4);     /* in macroblocks */
    dest_buffer_variables_mpeg->dw2.picture_coding_type = picture_coding_type;

    /* 3DSATE_BUFFER_INFO */
    /* CORRECTION DATA */
    buffer_info = (struct i915_3dstate_buffer_info *)(++dest_buffer_variables_mpeg);
    memset(buffer_info, 0, sizeof(*buffer_info));
    buffer_info->dw0.type = CMD_3D;
    buffer_info->dw0.opcode = OPC_3DSTATE_BUFFER_INFO;
    buffer_info->dw0.length = 1;
    buffer_info->dw1.aux_id = 0;
    buffer_info->dw1.buffer_id = BUFFERID_MC_INTRA_CORR;
    buffer_info->dw1.aux_id = 0;
    buffer_info->dw1.fence_regs = 0;
    buffer_info->dw1.tiled_surface = 0;
    buffer_info->dw1.walk = 0;
    buffer_info->dw1.pitch = 0;
    buffer_info->dw2.base_address = (pI915XvMC->corrdata.offset >> 2);  /* starting DWORD address */
}

static void i915_mc_map_state_buffer(XvMCContext *context,
                                       i915XvMCSurface *privTarget,
                                       i915XvMCSurface *privPast,
                                       i915XvMCSurface *privFuture)
{
    struct i915_3dstate_map_state *map_state;
    struct texture_map *tm;
    i915XvMCContext *pI915XvMC = (i915XvMCContext *)context->privData;
    unsigned int w = context->width, h = context->height;

    /* 3DSATE_MAP_STATE: Y */
    map_state = (struct i915_3dstate_map_state *)pI915XvMC->msb.map;
    memset(map_state, 0, sizeof(*map_state));
    map_state->dw0.type = CMD_3D;
    map_state->dw0.opcode = OPC_3DSTATE_MAP_STATE;
    map_state->dw0.retain = 1;
    map_state->dw0.length = 6;
    map_state->dw1.map_mask = MAP_MAP0 | MAP_MAP1;

    /* texture map: Forward (Past) */
    tm = (struct texture_map *)(++map_state);
    memset(tm, 0, sizeof(*tm));
    tm->tm0.v_ls_offset = 0;
    tm->tm0.v_ls = 0;
    tm->tm0.base_address = (YOFFSET(privPast) >> 2);
    tm->tm1.tile_walk = TILEWALK_XMAJOR;        /* FIXME: tiled y for performace */
    tm->tm1.tiled_surface = 0;
    tm->tm1.utilize_fence_regs = 0;
    tm->tm1.texel_fmt = 0;      /* 8bit */
    tm->tm1.surface_fmt = 1;    /* 8bit */
    tm->tm1.width = w - 1;
    tm->tm1.height = h - 1;
    tm->tm2.depth = 0;
    tm->tm2.max_lod = 0;
    tm->tm2.cube_face = 0;
    tm->tm2.pitch = (privPast->yStride >> 2) - 1;       /* in DWords - 1 */

    /* texture map: Backward (Future) */
    ++tm;
    memset(tm, 0, sizeof(*tm));
    tm->tm0.v_ls_offset = 0;
    tm->tm0.v_ls = 0;
    tm->tm0.base_address = (YOFFSET(privFuture) >> 2);
    tm->tm1.tile_walk = TILEWALK_XMAJOR;
    tm->tm1.tiled_surface = 0;
    tm->tm1.utilize_fence_regs = 0;
    tm->tm1.texel_fmt = 0;      /* 8bit */
    tm->tm1.surface_fmt = 1;    /* 8bit */
    tm->tm1.width = w - 1;
    tm->tm1.height = h - 1;
    tm->tm2.depth = 0;
    tm->tm2.max_lod = 0;
    tm->tm2.cube_face = 0;
    tm->tm2.pitch = (privFuture->yStride >> 2) - 1;

    /* 3DSATE_MAP_STATE: U */
    map_state = (struct i915_3dstate_map_state *)(++tm);
    memset(map_state, 0, sizeof(*map_state));
    map_state->dw0.type = CMD_3D;
    map_state->dw0.opcode = OPC_3DSTATE_MAP_STATE;
    map_state->dw0.retain = 1;
    map_state->dw0.length = 6;
    map_state->dw1.map_mask = MAP_MAP0 | MAP_MAP1;

    /* texture map: Forward */
    tm = (struct texture_map *)(++map_state);
    memset(tm, 0, sizeof(*tm));
    tm->tm0.v_ls_offset = 0;
    tm->tm0.v_ls = 0;
    tm->tm0.base_address = (UOFFSET(privPast) >> 2);
    tm->tm1.tile_walk = TILEWALK_XMAJOR;
    tm->tm1.tiled_surface = 0;
    tm->tm1.utilize_fence_regs = 0;
    tm->tm1.texel_fmt = 0;      /* 8bit */
    tm->tm1.surface_fmt = 1;    /* 8bit */
    tm->tm1.width = (w >> 1) - 1;
    tm->tm1.height = (h >> 1) - 1;
    tm->tm2.depth = 0;
    tm->tm2.max_lod = 0;
    tm->tm2.cube_face = 0;
    tm->tm2.pitch = (privPast->uvStride >> 2) - 1;       /* in DWords - 1 */

    /* texture map: Backward */
    ++tm;
    memset(tm, 0, sizeof(*tm));
    tm->tm0.v_ls_offset = 0;
    tm->tm0.v_ls = 0;
    tm->tm0.base_address = (UOFFSET(privFuture) >> 2);
    tm->tm1.tile_walk = TILEWALK_XMAJOR;
    tm->tm1.tiled_surface = 0;
    tm->tm1.utilize_fence_regs = 0;
    tm->tm1.texel_fmt = 0;
    tm->tm1.surface_fmt = 1;
    tm->tm1.width = (w >> 1) - 1;
    tm->tm1.height = (h >> 1) - 1;
    tm->tm2.depth = 0;
    tm->tm2.max_lod = 0;
    tm->tm2.cube_face = 0;
    tm->tm2.pitch = (privFuture->uvStride >> 2) - 1;

    /* 3DSATE_MAP_STATE: V */
    map_state = (struct i915_3dstate_map_state *)(++tm);
    memset(map_state, 0, sizeof(*map_state));
    map_state->dw0.type = CMD_3D;
    map_state->dw0.opcode = OPC_3DSTATE_MAP_STATE;
    map_state->dw0.retain = 1;
    map_state->dw0.length = 6;
    map_state->dw1.map_mask = MAP_MAP0 | MAP_MAP1;

    /* texture map: Forward */
    tm = (struct texture_map *)(++map_state);
    memset(tm, 0, sizeof(*tm));
    tm->tm0.v_ls_offset = 0;
    tm->tm0.v_ls = 0;
    tm->tm0.base_address = (VOFFSET(privPast) >> 2);
    tm->tm1.tile_walk = TILEWALK_XMAJOR;
    tm->tm1.tiled_surface = 0;
    tm->tm1.utilize_fence_regs = 0;
    tm->tm1.texel_fmt = 0;
    tm->tm1.surface_fmt = 1;
    tm->tm1.width = (w >> 1) - 1;
    tm->tm1.height = (h >> 1) - 1;
    tm->tm2.depth = 0;
    tm->tm2.max_lod = 0;
    tm->tm2.cube_face = 0;
    tm->tm2.pitch = (privPast->uvStride >> 2) - 1;       /* in DWords - 1 */

    /* texture map: Backward */
    ++tm;
    memset(tm, 0, sizeof(*tm));
    tm->tm0.v_ls_offset = 0;
    tm->tm0.v_ls = 0;
    tm->tm0.base_address = (VOFFSET(privFuture) >> 2);
    tm->tm1.tile_walk = TILEWALK_XMAJOR;
    tm->tm1.tiled_surface = 0;
    tm->tm1.utilize_fence_regs = 0;
    tm->tm1.texel_fmt = 0;
    tm->tm1.surface_fmt = 1;
    tm->tm1.width = (w >> 1) - 1;
    tm->tm1.height = (h >> 1) - 1;
    tm->tm2.depth = 0;
    tm->tm2.max_lod = 0;
    tm->tm2.cube_face = 0;
    tm->tm2.pitch = (privFuture->uvStride >> 2) - 1;
}

static void i915_mc_load_sis_msb_buffers(XvMCContext *context)
{
    struct i915_3dstate_load_indirect *load_indirect;
    sis_state *sis = NULL;
    msb_state *msb = NULL;
    i915XvMCContext *pI915XvMC = (i915XvMCContext *)context->privData;
    void *base = NULL;
    unsigned int size;
    int mem_select = 1;

    /* 3DSTATE_LOAD_INDIRECT */
    size = sizeof(*load_indirect) + sizeof(*sis) + sizeof(*msb);
    base = calloc(1, size);
    load_indirect = (struct i915_3dstate_load_indirect *)base;
    load_indirect->dw0.type = CMD_3D;
    load_indirect->dw0.opcode = OPC_3DSTATE_LOAD_INDIRECT;
    load_indirect->dw0.block_mask = BLOCK_SIS | BLOCK_MSB;
    load_indirect->dw0.length = (size >> 2) - 2;

    if (pI915XvMC->deviceID == PCI_CHIP_I915_G ||
        pI915XvMC->deviceID == PCI_CHIP_I915_GM ||
        pI915XvMC->deviceID == PCI_CHIP_I945_G ||
        pI915XvMC->deviceID == PCI_CHIP_I945_GM)
        mem_select = 0;

    load_indirect->dw0.mem_select = mem_select;

    /* SIS */
    sis = (sis_state *)(++load_indirect);
    sis->dw0.valid = 1;
    sis->dw0.force = 1;
    sis->dw1.length = 16; // 4 * 3 + 2 + 3 - 1

    if (mem_select)
        sis->dw0.buffer_address = (pI915XvMC->sis.offset >> 2);
    else
        sis->dw0.buffer_address = (pI915XvMC->sis.bus_addr >> 2);

    /* MSB */
    msb = (msb_state *)(++sis);
    msb->dw0.valid = 1;
    msb->dw0.force = 1;
    msb->dw1.length = 23; // 3 * 8 - 1

    if (mem_select)
        msb->dw0.buffer_address = (pI915XvMC->msb.offset >> 2);
    else
        msb->dw0.buffer_address = (pI915XvMC->msb.bus_addr >> 2);

    intelBatchbufferData(base, size, 0);
    free(base);
}

static void i915_mc_mpeg_set_origin(XvMCContext *context, XvMCMacroBlock *mb)
{
    struct i915_3dmpeg_set_origin set_origin;

    /* 3DMPEG_SET_ORIGIN */
    memset(&set_origin, 0, sizeof(set_origin));
    set_origin.dw0.type = CMD_3D;
    set_origin.dw0.opcode = OPC_3DMPEG_SET_ORIGIN;
    set_origin.dw0.length = 0;
    set_origin.dw1.h_origin = mb->x;
    set_origin.dw1.v_origin = mb->y;

    intelBatchbufferData(&set_origin, sizeof(set_origin), 0);
}

static void i915_mc_mpeg_macroblock_ipicture(XvMCContext *context, XvMCMacroBlock *mb)
{
    struct i915_3dmpeg_macroblock_ipicture macroblock_ipicture;

    /* 3DMPEG_MACROBLOCK_IPICTURE */
    memset(&macroblock_ipicture, 0, sizeof(macroblock_ipicture));
    macroblock_ipicture.dw0.type = CMD_3D;
    macroblock_ipicture.dw0.opcode = OPC_3DMPEG_MACROBLOCK_IPICTURE;
    macroblock_ipicture.dw0.dct_type = (mb->dct_type == XVMC_DCT_TYPE_FIELD);

    intelBatchbufferData(&macroblock_ipicture, sizeof(macroblock_ipicture), 0);
}

#if 0
static void i915_mc_mpeg_macroblock_0mv(XvMCContext *context, XvMCMacroBlock *mb)
{
    struct i915_3dmpeg_macroblock_0mv macroblock_0mv;

    /* 3DMPEG_MACROBLOCK(0mv) */
    memset(&macroblock_0mv, 0, sizeof(macroblock_0mv));
    macroblock_0mv.header.dw0.type = CMD_3D;
    macroblock_0mv.header.dw0.opcode = OPC_3DMPEG_MACROBLOCK;
    macroblock_0mv.header.dw0.length = 0;
    macroblock_0mv.header.dw1.mb_intra = 1;     /* should be 1 */
    macroblock_0mv.header.dw1.forward = 0;      /* should be 0 */
    macroblock_0mv.header.dw1.backward = 0;     /* should be 0 */
    macroblock_0mv.header.dw1.h263_4mv = 0;     /* should be 0 */
    macroblock_0mv.header.dw1.dct_type = (mb->dct_type == XVMC_DCT_TYPE_FIELD);

/*
    if (!mb->coded_block_pattern)
        macroblock_0mv.header.dw1.dct_type = XVMC_DCT_TYPE_FRAME;
*/

    macroblock_0mv.header.dw1.motion_type = 0; // (mb->motion_type & 0x3);
    macroblock_0mv.header.dw1.vertical_field_select = 0; // mb->motion_vertical_field_select & 0xf;
    macroblock_0mv.header.dw1.coded_block_pattern = mb->coded_block_pattern;
    macroblock_0mv.header.dw1.skipped_macroblocks = 0;

    intelBatchbufferData(&macroblock_0mv, sizeof(macroblock_0mv), 0);
}
#endif

static void i915_mc_mpeg_macroblock_1fbmv(XvMCContext *context, XvMCMacroBlock *mb)
{
    struct i915_3dmpeg_macroblock_1fbmv macroblock_1fbmv;

    /* Motion Vectors */
    su_t fmv;
    su_t bmv;

    /* 3DMPEG_MACROBLOCK(1fbmv) */
    memset(&macroblock_1fbmv, 0, sizeof(macroblock_1fbmv));
    macroblock_1fbmv.header.dw0.type = CMD_3D;
    macroblock_1fbmv.header.dw0.opcode = OPC_3DMPEG_MACROBLOCK;
    macroblock_1fbmv.header.dw0.length = 2;
    macroblock_1fbmv.header.dw1.mb_intra = 0;   /* should be 0 */
    macroblock_1fbmv.header.dw1.forward = ((mb->macroblock_type & XVMC_MB_TYPE_MOTION_FORWARD) ? 1 : 0);
    macroblock_1fbmv.header.dw1.backward = ((mb->macroblock_type & XVMC_MB_TYPE_MOTION_BACKWARD) ? 1 : 0);
    macroblock_1fbmv.header.dw1.h263_4mv = 0;   /* should be 0 */
    macroblock_1fbmv.header.dw1.dct_type = (mb->dct_type == XVMC_DCT_TYPE_FIELD);

    if (!(mb->coded_block_pattern & 0x3f))
        macroblock_1fbmv.header.dw1.dct_type = XVMC_DCT_TYPE_FRAME;

    macroblock_1fbmv.header.dw1.motion_type = (mb->motion_type & 0x03);
    macroblock_1fbmv.header.dw1.vertical_field_select = (mb->motion_vertical_field_select & 0x0f);
    macroblock_1fbmv.header.dw1.coded_block_pattern = mb->coded_block_pattern;
    macroblock_1fbmv.header.dw1.skipped_macroblocks = 0;

    fmv.s[0] = mb->PMV[0][0][0];
    fmv.s[1] = mb->PMV[0][0][1];
    bmv.s[0] = mb->PMV[0][1][0];
    bmv.s[1] = mb->PMV[0][1][1];

    macroblock_1fbmv.dw2 = fmv.u[0];
    macroblock_1fbmv.dw3 = bmv.u[0];

    intelBatchbufferData(&macroblock_1fbmv, sizeof(macroblock_1fbmv), 0);
}

static void i915_mc_mpeg_macroblock_2fbmv(XvMCContext *context, XvMCMacroBlock *mb, unsigned int ps)
{
    struct i915_3dmpeg_macroblock_2fbmv macroblock_2fbmv;

    /* Motion Vectors */
    su_t fmv;
    su_t bmv;

    /* 3DMPEG_MACROBLOCK(2fbmv) */
    memset(&macroblock_2fbmv, 0, sizeof(macroblock_2fbmv));
    macroblock_2fbmv.header.dw0.type = CMD_3D;
    macroblock_2fbmv.header.dw0.opcode = OPC_3DMPEG_MACROBLOCK;
    macroblock_2fbmv.header.dw0.length = 4;
    macroblock_2fbmv.header.dw1.mb_intra = 0;   /* should be 0 */
    macroblock_2fbmv.header.dw1.forward = ((mb->macroblock_type & XVMC_MB_TYPE_MOTION_FORWARD) ? 1 : 0);
    macroblock_2fbmv.header.dw1.backward = ((mb->macroblock_type & XVMC_MB_TYPE_MOTION_BACKWARD) ? 1 : 0);
    macroblock_2fbmv.header.dw1.h263_4mv = 0;   /* should be 0 */
    macroblock_2fbmv.header.dw1.dct_type = (mb->dct_type == XVMC_DCT_TYPE_FIELD);

    if (!(mb->coded_block_pattern & 0x3f))
        macroblock_2fbmv.header.dw1.dct_type = XVMC_DCT_TYPE_FRAME;

    macroblock_2fbmv.header.dw1.motion_type = (mb->motion_type & 0x03);
    macroblock_2fbmv.header.dw1.vertical_field_select = (mb->motion_vertical_field_select & 0x0f);
    macroblock_2fbmv.header.dw1.coded_block_pattern = mb->coded_block_pattern;
    macroblock_2fbmv.header.dw1.skipped_macroblocks = 0;

    fmv.s[0] = mb->PMV[0][0][0];
    fmv.s[1] = mb->PMV[0][0][1];
    fmv.s[2] = mb->PMV[1][0][0];
    fmv.s[3] = mb->PMV[1][0][1];
    bmv.s[0] = mb->PMV[0][1][0];
    bmv.s[1] = mb->PMV[0][1][1];
    bmv.s[2] = mb->PMV[1][1][0];
    bmv.s[3] = mb->PMV[1][1][1];

    if ((ps & XVMC_FRAME_PICTURE) == XVMC_FRAME_PICTURE) {
        if ((mb->motion_type & 3) == XVMC_PREDICTION_FIELD) {
            fmv.s[0] = mb->PMV[0][0][0];
            fmv.s[1] = mb->PMV[0][0][1] >> 1;
            fmv.s[2] = mb->PMV[1][0][0];
            fmv.s[3] = mb->PMV[1][0][1] >> 1;
            bmv.s[0] = mb->PMV[0][1][0];
            bmv.s[1] = mb->PMV[0][1][1] >> 1;
            bmv.s[2] = mb->PMV[1][1][0];
            bmv.s[3] = mb->PMV[1][1][1] >> 1;
        } else if ((mb->motion_type & 3) == XVMC_PREDICTION_DUAL_PRIME) {
            fmv.s[0] = mb->PMV[0][0][0];
            fmv.s[1] = mb->PMV[0][0][1] >> 1;
            fmv.s[2] = mb->PMV[0][0][0];
            fmv.s[3] = mb->PMV[0][0][1] >> 1;  // MPEG2 MV[0][1] isn't used
            bmv.s[0] = mb->PMV[1][0][0];
            bmv.s[1] = mb->PMV[1][0][1] >> 1;
            bmv.s[2] = mb->PMV[1][1][0];
            bmv.s[3] = mb->PMV[1][1][1] >> 1;
        }
    }

    macroblock_2fbmv.dw2 = fmv.u[0];
    macroblock_2fbmv.dw3 = bmv.u[0];
    macroblock_2fbmv.dw4 = fmv.u[1];
    macroblock_2fbmv.dw5 = bmv.u[1];

    intelBatchbufferData(&macroblock_2fbmv, sizeof(macroblock_2fbmv), 0);
}

/* for MC context initialization */
static void i915_mc_sampler_state_buffer(XvMCContext *context)
{
    struct i915_3dstate_sampler_state *sampler_state;
    struct texture_sampler *ts;
    i915XvMCContext *pI915XvMC = (i915XvMCContext *)context->privData;

    /* 3DSATE_SAMPLER_STATE */
    sampler_state = (struct i915_3dstate_sampler_state *)pI915XvMC->ssb.map;
    memset(sampler_state, 0, sizeof(*sampler_state));
    sampler_state->dw0.type = CMD_3D;
    sampler_state->dw0.opcode = OPC_3DSTATE_SAMPLER_STATE;
    sampler_state->dw0.length = 6;
    sampler_state->dw1.sampler_masker = SAMPLER_SAMPLER0 | SAMPLER_SAMPLER1;

    /* Sampler 0 */
    ts = (struct texture_sampler *)(++sampler_state);
    memset(ts, 0, sizeof(*ts));
    ts->ts0.reverse_gamma = 0;
    ts->ts0.planar2packet = 0;
    ts->ts0.color_conversion = 0;
    ts->ts0.chromakey_index = 0;
    ts->ts0.base_level = 0;
    ts->ts0.mip_filter = MIPFILTER_NONE;        /* NONE */
    ts->ts0.mag_filter = MAPFILTER_LINEAR;      /* LINEAR */
    ts->ts0.min_filter = MAPFILTER_LINEAR;      /* LINEAR */
    ts->ts0.lod_bias = 0;       /* 0.0 */
    ts->ts0.shadow_enable = 0;
    ts->ts0.max_anisotropy = ANISORATIO_2;
    ts->ts0.shadow_function = PREFILTEROP_ALWAYS;
    ts->ts1.min_lod = 0;        /* 0.0 Maximum Mip Level */
    ts->ts1.kill_pixel = 0;
    ts->ts1.keyed_texture_filter = 0;
    ts->ts1.chromakey_enable = 0;
    ts->ts1.tcx_control = TEXCOORDMODE_CLAMP;
    ts->ts1.tcy_control = TEXCOORDMODE_CLAMP;
    ts->ts1.tcz_control = TEXCOORDMODE_CLAMP;
    ts->ts1.normalized_coor = 0;
    ts->ts1.map_index = 0;
    ts->ts1.east_deinterlacer = 0;
    ts->ts2.default_color = 0;

    /* Sampler 1 */
    ++ts;
    memset(ts, 0, sizeof(*ts));
    ts->ts0.reverse_gamma = 0;
    ts->ts0.planar2packet = 0;
    ts->ts0.color_conversion = 0;
    ts->ts0.chromakey_index = 0;
    ts->ts0.base_level = 0;
    ts->ts0.mip_filter = MIPFILTER_NONE;        /* NONE */
    ts->ts0.mag_filter = MAPFILTER_LINEAR;      /* LINEAR */
    ts->ts0.min_filter = MAPFILTER_LINEAR;      /* LINEAR */
    ts->ts0.lod_bias = 0;       /* 0.0 */
    ts->ts0.shadow_enable = 0;
    ts->ts0.max_anisotropy = ANISORATIO_2;
    ts->ts0.shadow_function = PREFILTEROP_ALWAYS;
    ts->ts1.min_lod = 0;        /* 0.0 Maximum Mip Level */
    ts->ts1.kill_pixel = 0;
    ts->ts1.keyed_texture_filter = 0;
    ts->ts1.chromakey_enable = 0;
    ts->ts1.tcx_control = TEXCOORDMODE_CLAMP;
    ts->ts1.tcy_control = TEXCOORDMODE_CLAMP;
    ts->ts1.tcz_control = TEXCOORDMODE_CLAMP;
    ts->ts1.normalized_coor = 0;
    ts->ts1.map_index = 1;
    ts->ts1.east_deinterlacer = 0;
    ts->ts2.default_color = 0;
}

d127 1
a127 1
static void i915_mc_pixel_shader_program_buffer(XvMCContext *context)
d129 18
d148 1
a148 3
    i915XvMCContext *pI915XvMC = (i915XvMCContext *)context->privData;
    unsigned int *inst;
    unsigned int dest, src0, src1, src2;
d150 3
a152 1
    /* Shader 0 */
d154 57
d212 6
a217 6
    pixel_shader_program->dw0.type = CMD_3D;
    pixel_shader_program->dw0.opcode = OPC_3DSTATE_PIXEL_SHADER_PROGRAM;
    pixel_shader_program->dw0.retain = 1;
    pixel_shader_program->dw0.length = 2;
    /* mov oC, c0.0000 */
    inst = (unsigned int*)(++pixel_shader_program);
d222 2
a223 3
    i915_inst_arith(inst, A0_MOV, dest, A0_DEST_CHANNEL_ALL,
                    A0_DEST_SATURATE, src0, src1, src2);
    inst += 3;
d225 5
a229 7
    /* Shader 1 */
    pixel_shader_program = (struct i915_3dstate_pixel_shader_program *)inst;
    memset(pixel_shader_program, 0, sizeof(*pixel_shader_program));
    pixel_shader_program->dw0.type = CMD_3D;
    pixel_shader_program->dw0.opcode = OPC_3DSTATE_PIXEL_SHADER_PROGRAM;
    pixel_shader_program->dw0.retain = 1;
    pixel_shader_program->dw0.length = 14;
d231 2
a232 2
    inst = (unsigned int*)(++pixel_shader_program);
    i915_inst_decl(inst, REG_TYPE_T, T_TEX0, D0_CHANNEL_XY);
d234 1
a234 2
    inst += 3;
    i915_inst_decl(inst, REG_TYPE_T, T_TEX1, D0_CHANNEL_XY);
d236 2
a237 2
    inst += 3;
    i915_inst_decl(inst, REG_TYPE_S, 0, D0_SAMPLE_TYPE_2D);
d239 1
a239 1
    inst += 3;
d243 1
a243 1
    i915_inst_texld(inst, T0_TEXLD, dest, src0, src1);
d245 1
a245 1
    inst += 3;
d249 1
a249 1
    i915_inst_arith(inst, A0_MOV, dest, A0_DEST_CHANNEL_ALL,
a250 1
    inst += 3;
d252 6
a257 7
    /* Shader 2 */
    pixel_shader_program = (struct i915_3dstate_pixel_shader_program *)inst;
    memset(pixel_shader_program, 0, sizeof(*pixel_shader_program));
    pixel_shader_program->dw0.type = CMD_3D;
    pixel_shader_program->dw0.opcode = OPC_3DSTATE_PIXEL_SHADER_PROGRAM;
    pixel_shader_program->dw0.retain = 1;
    pixel_shader_program->dw0.length = 14;
d259 1
a259 2
    inst = (unsigned int*)(++pixel_shader_program);
    i915_inst_decl(inst, REG_TYPE_T, T_TEX2, D0_CHANNEL_XY);
d261 2
a262 2
    inst += 3;
    i915_inst_decl(inst, REG_TYPE_T, T_TEX3, D0_CHANNEL_XY);
d264 2
a265 2
    inst += 3;
    i915_inst_decl(inst, REG_TYPE_S, 1, D0_SAMPLE_TYPE_2D);
d267 1
a267 1
    inst += 3;
d271 1
a271 1
    i915_inst_texld(inst, T0_TEXLD, dest, src0, src1);
d273 1
a273 1
    inst += 3;
d277 1
a277 1
    i915_inst_arith(inst, A0_MOV, dest, A0_DEST_CHANNEL_ALL,
a278 1
    inst += 3;
d281 5
a285 6
    pixel_shader_program = (struct i915_3dstate_pixel_shader_program *)inst;
    memset(pixel_shader_program, 0, sizeof(*pixel_shader_program));
    pixel_shader_program->dw0.type = CMD_3D;
    pixel_shader_program->dw0.opcode = OPC_3DSTATE_PIXEL_SHADER_PROGRAM;
    pixel_shader_program->dw0.retain = 1;
    pixel_shader_program->dw0.length = 29;
d287 1
a287 2
    inst = (unsigned int*)(++pixel_shader_program);
    i915_inst_decl(inst, REG_TYPE_T, T_TEX0, D0_CHANNEL_XY);
d289 2
a290 2
    inst += 3;
    i915_inst_decl(inst, REG_TYPE_T, T_TEX1, D0_CHANNEL_XY);
d292 2
a293 2
    inst += 3;
    i915_inst_decl(inst, REG_TYPE_T, T_TEX2, D0_CHANNEL_XY);
d295 2
a296 2
    inst += 3;
    i915_inst_decl(inst, REG_TYPE_T, T_TEX3, D0_CHANNEL_XY);
d298 2
a299 2
    inst += 3;
    i915_inst_decl(inst, REG_TYPE_S, 0, D0_SAMPLE_TYPE_2D);
d301 2
a302 2
    inst += 3;
    i915_inst_decl(inst, REG_TYPE_S, 1, D0_SAMPLE_TYPE_2D);
d304 1
a304 1
    inst += 3;
d308 1
a308 1
    i915_inst_texld(inst, T0_TEXLD, dest, src0, src1);
d310 1
a310 1
    inst += 3;
d314 1
a314 1
    i915_inst_texld(inst, T0_TEXLD, dest, src0, src1);
d316 1
a316 1
    inst += 3;
d321 1
a321 1
    i915_inst_arith(inst, A0_ADD, dest, A0_DEST_CHANNEL_ALL,
d324 1
a324 1
    inst += 3;
d329 1
a329 1
    i915_inst_arith(inst, A0_MUL, dest, A0_DEST_CHANNEL_ALL,
a330 8
    inst += 3;
}

static void i915_mc_pixel_shader_constants_buffer(XvMCContext *context)
{
    struct i915_3dstate_pixel_shader_constants *pixel_shader_constants;
    i915XvMCContext *pI915XvMC = (i915XvMCContext *)context->privData;
    float *value;
a331 1
    pixel_shader_constants = (struct i915_3dstate_pixel_shader_constants *)pI915XvMC->psc.map;
d337 5
a341 5
    value = (float *)(++pixel_shader_constants);
    *(value++) = 0.5;
    *(value++) = 0.5;
    *(value++) = 0.5;
    *(value++) = 0.5;
d344 1
a344 1
static void i915_mc_one_time_state_initialization(XvMCContext *context)
a345 1
    struct i915_3dstate_load_state_immediate_1 *load_state_immediate_1 = NULL;
a347 1
    struct i915_3dstate_load_indirect *load_indirect = NULL;
d353 3
a355 3
    unsigned int size;
    void *base = NULL;
    int mem_select = 1;
d358 3
a360 3
    size = sizeof(*load_state_immediate_1) + sizeof(*s3) + sizeof(*s6);
    base = calloc(1, size);
    load_state_immediate_1 = (struct i915_3dstate_load_state_immediate_1 *)base;
d365 1
a365 1
    load_state_immediate_1->dw0.length = (size >> 2) - 2;
a390 3
    intelBatchbufferData(base, size, 0);
    free(base);

d392 3
a394 3
    size = sizeof(*load_indirect) + sizeof(*dis) + sizeof(*ssb) + sizeof(*psp) + sizeof(*psc);
    base = calloc(1, size);
    load_indirect = (struct i915_3dstate_load_indirect *)base;
d398 1
a398 1
    load_indirect->dw0.length = (size >> 2) - 2;
d401 4
a404 4
        pI915XvMC->deviceID == PCI_CHIP_I915_GM ||
        pI915XvMC->deviceID == PCI_CHIP_I945_G ||
        pI915XvMC->deviceID == PCI_CHIP_I945_GM)
        mem_select = 0;
d408 2
a409 1
    /* DIS */
d415 1
a415 1
    /* SSB */
d424 1
a424 1
        ssb->dw0.buffer_address = (pI915XvMC->ssb.bus_addr >> 2);
d426 1
a426 1
    /* PSP */
d433 1
a433 1
        psp->dw0.buffer_address = (pI915XvMC->psp.offset >> 2);
d435 1
a435 1
        psp->dw0.buffer_address = (pI915XvMC->psp.bus_addr >> 2);
d437 1
a437 1
    /* PSC */
d447 470
d918 6
a923 2
    intelBatchbufferData(base, size, 0);
    free(base);
d1604 1
a1604 3
        pI915XvMC->deviceID == PCI_CHIP_I915_GM ||
        pI915XvMC->deviceID == PCI_CHIP_I945_G ||
        pI915XvMC->deviceID == PCI_CHIP_I945_GM) {
d1639 10
d1661 4
d1820 2
a1821 3
    /* Test For YV12 Surface */
    if (context->surface_type_id != FOURCC_YV12) {
        XVMC_ERR("HWMC only possible on YV12 Surfaces.");
d1888 1
a1888 1
        bspm = mb_bytes[mb->coded_block_pattern];
d1907 9
a1915 10
    i915_mc_sampler_state_buffer(context);
    i915_mc_pixel_shader_program_buffer(context);
    i915_mc_pixel_shader_constants_buffer(context);
    i915_mc_one_time_state_initialization(context);

    i915_mc_static_indirect_state_buffer(context, target_surface,
                                         picture_structure, flags,
                                         picture_coding_type);
    i915_mc_map_state_buffer(context, privTarget, privPast, privFuture);
    i915_mc_load_sis_msb_buffers(context);
@


1.1
log
@Update to xf86-video-intel 2.3.1. Tested by many.
@
text
@a1610 3
    driDestroyHashContents(pI915XvMC->drawHash);
    drmHashDestroy(pI915XvMC->drawHash);

a1682 7
    if (NULL == (pI915XvMC->drawHash = drmHashCreate())) {
	XVMC_ERR("Could not allocate drawable hash table.");
        free(pI915XvMC);
        context->privData = NULL;
        return BadAlloc;
    }

d1990 1
a1990 1
        } else {        /* Frame Picture */
d2008 1
a2008 1
        }       /* Field Picture */
@

