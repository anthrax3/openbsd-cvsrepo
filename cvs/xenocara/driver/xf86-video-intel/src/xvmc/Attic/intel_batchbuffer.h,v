head	1.6;
access;
symbols
	OPENBSD_5_4:1.5.0.2
	OPENBSD_5_4_BASE:1.5
	OPENBSD_5_3:1.4.0.6
	OPENBSD_5_3_BASE:1.4
	OPENBSD_5_2:1.4.0.4
	OPENBSD_5_2_BASE:1.4
	OPENBSD_5_1_BASE:1.4
	OPENBSD_5_1:1.4.0.2
	OPENBSD_5_0:1.3.0.6
	OPENBSD_5_0_BASE:1.3
	OPENBSD_4_9:1.3.0.2
	OPENBSD_4_9_BASE:1.3
	OPENBSD_4_8:1.3.0.4
	OPENBSD_4_8_BASE:1.3
	OPENBSD_4_7:1.2.0.4
	OPENBSD_4_7_BASE:1.2
	OPENBSD_4_6:1.2.0.2
	OPENBSD_4_6_BASE:1.2
	OPENBSD_4_5:1.1.0.4
	OPENBSD_4_5_BASE:1.1
	OPENBSD_4_4:1.1.0.2
	OPENBSD_4_4_BASE:1.1;
locks; strict;
comment	@ * @;


1.6
date	2014.02.03.15.54.53;	author matthieu;	state dead;
branches;
next	1.5;

1.5
date	2013.03.18.18.38.21;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2011.11.29.12.39.03;	author oga;	state Exp;
branches;
next	1.3;

1.3
date	2010.05.10.22.32.30;	author oga;	state Exp;
branches;
next	1.2;

1.2
date	2009.06.25.20.16.44;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2008.05.21.20.19.52;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.6
log
@Update to xf86-video-intel 2.99.909
Tested by jsg@@, kettenis@@ and myself on a wide range of intel cards.
@
text
@#ifndef _INTEL_BATCHBUFFER_H
#define _INTEL_BATCHBUFFER_H

/* #define VERBOSE 0 */
#ifndef VERBOSE
extern int VERBOSE;
#endif

#define BATCH_LOCALS    unsigned char *batch_ptr;

#define BEGIN_BATCH(n)                                                  \
    do {                                                                \
	assert(xvmc_driver->batch.space >= (n) *4);			\
        if (xvmc_driver->batch.space < (n)*4)                           \
            intelFlushBatch(TRUE);                            		\
        batch_ptr = xvmc_driver->batch.ptr;                             \
    } while (0)

#define OUT_BATCH(n)                                                    \
    do {                                                                \
        *(unsigned int *)batch_ptr = (n);                               \
        batch_ptr += 4;                                                 \
    } while (0)

#define OUT_RELOC(bo,read_domains,write_domains,delta)  \
    do { \
        *(unsigned int *)batch_ptr = (delta) + bo->offset; \
        intel_batch_emit_reloc(bo, read_domains, write_domains, delta, batch_ptr); \
        batch_ptr += 4;                                                 \
    } while (0)

#define OUT_BATCH_SHORT(n)                                              \
    do {                                                                \
        *(short *)batch_ptr = (n);                                      \
        batch_ptr += 2;                                                 \
    } while (0)

#define OUT_BATCH_CHAR(n)                                               \
	do {                                                                \
		*(char *)batch_ptr = (n);                                       \
		batch_ptr ++;                                                   \
	} while (0)
#define ADVANCE_BATCH()                                                  \
    do {                                                                 \
        xvmc_driver->batch.space -= (batch_ptr - xvmc_driver->batch.ptr);\
        xvmc_driver->batch.ptr = batch_ptr;                              \
    } while(0)

extern void intelFlushBatch(Bool);
extern void intelBatchbufferData(const void *, unsigned, unsigned);
extern Bool intelInitBatchBuffer(void);
extern void intelFiniBatchBuffer(void);
extern void intelCmdIoctl(char *, unsigned);
extern void intel_batch_emit_reloc(dri_bo * bo, uint32_t read_domain,
				   uint32_t write_domain, uint32_t delta,
				   unsigned char *);
#endif /* _INTEL_BATCHBUFFER_H */
@


1.5
log
@Update to xf86-video-intel 2.20.19.

A recent kernel with kernel modesetting support is required.
Thanks to jsg@@ and kettenis@@ for their work.
@
text
@@


1.4
log
@Update the intel driver to a more recent version based on more recent
upsteam code.

Backporting keeping UMS changes by me, some bugfixes from kettenis@@.

Has been in snapshots for a while, committed on request so we can be
sure what people are running. This is a prerequesite for sandybridge
support but has those chipsets disabled for now until the correct code
has been added.
@
text
@a46 1
        assert(xvmc_driver->batch.space >= 0);                           \
@


1.3
log
@Update the intel driver to 2.9.1 plus backports.

2.9.1 is the last version of the intel DDX that supports UMS (User
modesetting), with 2.10 onwards being purely KMS only. As such, this
driver contains backports of almost every correctness or performance
related fix to the rendering layer in later intel drivers. This driver
*REQUIRES* a GEM enabled kernel. it claims to support non-gem mode but
this is essentially unmaintained and due to the way the abstraciton
works is slow, if it works at all (it often does not). You have been
warned.

tested by many many people on tech over the last few weeks.
@
text
@d27 1
a27 1
        *(unsigned int *)batch_ptr = delta + bo->offset; \
@


1.2
log
@update to xf86-video-intel 2.7.1. Tested by many.
@
text
@d13 1
d25 7
d55 3
@


1.1
log
@Update to xf86-video-intel 2.3.1. Tested by many.
@
text
@d9 1
a9 1
#define BATCH_LOCALS    char *batch_ptr;
d13 3
a15 7
        if (VERBOSE) fprintf(stderr,                                    \
                             "BEGIN_BATCH(%ld) in %s, %d dwords free\n", \
                             ((unsigned long)n), __FUNCTION__,          \
                             xvmc_driver->batch.space/4);                     \
        if (xvmc_driver->batch.space < (n)*4)                                 \
            intelFlushBatch(TRUE);                            \
        batch_ptr = xvmc_driver->batch.ptr;                                   \
d20 1
a20 2
        *(GLuint *)batch_ptr = (n);                                     \
        if (VERBOSE) fprintf(stderr, " -- %08x at %s/%d\n", (n), __FILE__, __LINE__); \
d24 16
a39 6
#define ADVANCE_BATCH()                                        \
    do {                                                       \
        if (VERBOSE) fprintf(stderr, "ADVANCE_BATCH()\n");     \
        xvmc_driver->batch.space -= (batch_ptr - xvmc_driver->batch.ptr);  \
        xvmc_driver->batch.ptr = batch_ptr;                          \
        assert(xvmc_driver->batch.space >= 0);                       \
@

