head	1.9;
access;
symbols
	OPENBSD_5_4:1.8.0.2
	OPENBSD_5_4_BASE:1.8
	OPENBSD_5_3:1.7.0.6
	OPENBSD_5_3_BASE:1.7
	OPENBSD_5_2:1.7.0.4
	OPENBSD_5_2_BASE:1.7
	OPENBSD_5_1_BASE:1.7
	OPENBSD_5_1:1.7.0.2
	OPENBSD_5_0:1.6.0.6
	OPENBSD_5_0_BASE:1.6
	OPENBSD_4_9:1.6.0.2
	OPENBSD_4_9_BASE:1.6
	OPENBSD_4_8:1.6.0.4
	OPENBSD_4_8_BASE:1.6
	OPENBSD_4_7:1.4.0.4
	OPENBSD_4_7_BASE:1.4
	OPENBSD_4_6:1.4.0.2
	OPENBSD_4_6_BASE:1.4
	OPENBSD_4_5:1.3.0.2
	OPENBSD_4_5_BASE:1.3
	OPENBSD_4_4:1.2.0.2
	OPENBSD_4_4_BASE:1.2;
locks; strict;
comment	@ * @;


1.9
date	2014.02.03.15.54.53;	author matthieu;	state dead;
branches;
next	1.8;

1.8
date	2013.03.18.18.38.21;	author matthieu;	state Exp;
branches;
next	1.7;

1.7
date	2011.11.29.12.39.03;	author oga;	state Exp;
branches;
next	1.6;

1.6
date	2010.05.23.21.28.35;	author oga;	state Exp;
branches;
next	1.5;

1.5
date	2010.05.10.22.32.30;	author oga;	state Exp;
branches;
next	1.4;

1.4
date	2009.06.25.20.16.44;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2008.10.12.15.20.51;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2008.06.29.20.13.42;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2008.05.21.20.19.52;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.9
log
@Update to xf86-video-intel 2.99.909
Tested by jsg@@, kettenis@@ and myself on a wide range of intel cards.
@
text
@/*
 * Copyright Â© 2007 Intel Corporation
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice (including the next
 * paragraph) shall be included in all copies or substantial portions of the
 * Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 * Authors:
 *    Zhenyu Wang <zhenyu.z.wang@@intel.com>
 *
 */
#include "intel_xvmc.h"
#include <xcb/xcb.h>
#include <xcb/xcb_aux.h>
#include <xcb/dri2.h>
#include <X11/Xlib-xcb.h>
#include <X11/extensions/dri2tokens.h>

/* global */
struct _intel_xvmc_driver *xvmc_driver = NULL;

/* Lookup tables to speed common calculations for coded_block_pattern */
/* each block is ((8*8) * sizeof(short)) */
unsigned int mb_bytes_420[] = {
	0,			/* 0 */
	128,			/* 1 */
	128,			/* 10 */
	256,			/* 11 */
	128,			/* 100 */
	256,			/* 101 */
	256,			/* 110 */
	384,			/* 111 */
	128,			/* 1000 */
	256,			/* 1001 */
	256,			/* 1010 */
	384,			/* 1011 */
	256,			/* 1100 */
	384,			/* 1101 */
	384,			/* 1110 */
	512,			/* 1111 */
	128,			/* 10000 */
	256,			/* 10001 */
	256,			/* 10010 */
	384,			/* 10011 */
	256,			/* 10100 */
	384,			/* 10101 */
	384,			/* 10110 */
	512,			/* 10111 */
	256,			/* 11000 */
	384,			/* 11001 */
	384,			/* 11010 */
	512,			/* 11011 */
	384,			/* 11100 */
	512,			/* 11101 */
	512,			/* 11110 */
	640,			/* 11111 */
	128,			/* 100000 */
	256,			/* 100001 */
	256,			/* 100010 */
	384,			/* 100011 */
	256,			/* 100100 */
	384,			/* 100101 */
	384,			/* 100110 */
	512,			/* 100111 */
	256,			/* 101000 */
	384,			/* 101001 */
	384,			/* 101010 */
	512,			/* 101011 */
	384,			/* 101100 */
	512,			/* 101101 */
	512,			/* 101110 */
	640,			/* 101111 */
	256,			/* 110000 */
	384,			/* 110001 */
	384,			/* 110010 */
	512,			/* 110011 */
	384,			/* 110100 */
	512,			/* 110101 */
	512,			/* 110110 */
	640,			/* 110111 */
	384,			/* 111000 */
	512,			/* 111001 */
	512,			/* 111010 */
	640,			/* 111011 */
	512,			/* 111100 */
	640,			/* 111101 */
	640,			/* 111110 */
	768			/* 111111 */
};

void LOCK_HARDWARE(drm_context_t ctx)
{
	PPTHREAD_MUTEX_LOCK();
	assert(!xvmc_driver->locked);

	xvmc_driver->locked = 1;
}

void UNLOCK_HARDWARE(drm_context_t ctx)
{
	xvmc_driver->locked = 0;

	PPTHREAD_MUTEX_UNLOCK();
}

static int
dri2_connect(Display *display)
{
	xcb_dri2_query_version_cookie_t query_version_cookie;
	xcb_dri2_query_version_reply_t *query_version_reply;
	xcb_dri2_connect_cookie_t connect_cookie;
	xcb_dri2_connect_reply_t *connect_reply;
	xcb_dri2_authenticate_cookie_t auth_cookie;
	xcb_dri2_authenticate_reply_t *auth_reply;
	xcb_screen_t *root;
	xcb_connection_t *c = XGetXCBConnection(display);
	drm_magic_t magic;
	const xcb_query_extension_reply_t *dri2_reply;
	char *device_name;
	int len;

	root = xcb_aux_get_screen(c, DefaultScreen(display));

	dri2_reply = xcb_get_extension_data(c, &xcb_dri2_id);

	if (!dri2_reply) {
		XVMC_ERR("DRI2 required");
		return BadValue;
	}

	/* Query the extension and make our first use of it at the same time. */
	query_version_cookie = xcb_dri2_query_version(c, 1, 0);
	connect_cookie = xcb_dri2_connect(c, root->root, DRI2DriverDRI);

	query_version_reply =
		xcb_dri2_query_version_reply(c, query_version_cookie, NULL);
	connect_reply = xcb_dri2_connect_reply(c, connect_cookie, NULL);

	if (!query_version_reply) {
		XVMC_ERR("DRI2 required");
		return BadValue;
	}
	free(query_version_reply);

	len = xcb_dri2_connect_device_name_length(connect_reply);
	device_name = malloc(len + 1);
	if (!device_name) {
		XVMC_ERR("malloc failure");
		return BadAlloc;
	}
	strncpy(device_name, xcb_dri2_connect_device_name(connect_reply), len);
	device_name[len] = 0;
	xvmc_driver->fd = open(device_name, O_RDWR);
	free(device_name);
	free(connect_reply);
	if (xvmc_driver->fd < 0) {
		XVMC_ERR("Failed to open drm device: %s\n", strerror(errno));
		return BadValue;
	}

	if (drmGetMagic(xvmc_driver->fd, &magic)) {
		XVMC_ERR("Failed to get magic\n");
		return BadValue;
	}

	auth_cookie = xcb_dri2_authenticate(c, root->root, magic);
	auth_reply = xcb_dri2_authenticate_reply(c, auth_cookie, NULL);
	if (!auth_reply) {
		XVMC_ERR("Failed to authenticate magic %d\n", magic);
		return BadValue;
	}
	free(auth_reply);

	return Success;
}

/*
* Function: XvMCCreateContext
* Description: Create a XvMC context for the given surface parameters.
* Arguments:
*   display - Connection to the X server.
*   port - XvPortID to use as avertised by the X connection.
*   surface_type_id - Unique identifier for the Surface type.
*   width - Width of the surfaces.
*   height - Height of the surfaces.
*   flags - one or more of the following
*      XVMC_DIRECT - A direct rendered context is requested.
*
* Notes: surface_type_id and width/height parameters must match those
*        returned by XvMCListSurfaceTypes.
* Returns: Status
*/
_X_EXPORT Status XvMCCreateContext(Display * display, XvPortID port,
				   int surface_type_id, int width, int height,
				   int flags, XvMCContext * context)
{
	Status ret;
	CARD32 *priv_data = NULL;
	struct intel_xvmc_hw_context *comm;
	int major, minor;
	int error_base;
	int event_base;
	int priv_count;

	/* Verify Obvious things first */
	if (!display || !context)
		return BadValue;

	if (!(flags & XVMC_DIRECT)) {
		XVMC_ERR("Indirect Rendering not supported! Using Direct.");
		return BadValue;
	}

	/*
	   Width, Height, and flags are checked against surface_type_id
	   and port for validity inside the X server, no need to check
	   here.
	 */
	context->surface_type_id = surface_type_id;
	context->width = (unsigned short)((width + 15) & ~15);
	context->height = (unsigned short)((height + 15) & ~15);
	context->flags = flags;
	context->port = port;

	if (!XvMCQueryExtension(display, &event_base, &error_base)) {
		XVMC_ERR("XvMCExtension is not available!");
		return BadValue;
	}

	ret = XvMCQueryVersion(display, &major, &minor);
	if (ret) {
		XVMC_ERR
		    ("XvMCQueryVersion Failed, unable to determine protocol version.");
		return ret;
	}

	/* XXX: major and minor could be checked in future for XvMC
	 * protocol capability (i.e H.264/AVC decode available)
	 */

	/*
	   Pass control to the X server to create a drm_context_t for us and
	   validate the with/height and flags.
	 */
	if ((ret =
	     _xvmc_create_context(display, context, &priv_count, &priv_data))) {
		XVMC_ERR("Unable to create XvMC Context.");
		return ret;
	}

	comm = (struct intel_xvmc_hw_context *)priv_data;

	if (xvmc_driver == NULL || xvmc_driver->type != comm->type) {
		switch (comm->type) {
		case XVMC_I915_MPEG2_MC:
			xvmc_driver = &i915_xvmc_mc_driver;
			break;
		case XVMC_I965_MPEG2_MC:
			xvmc_driver = &i965_xvmc_mc_driver;
			break;
		case XVMC_I965_MPEG2_VLD:
			xvmc_driver = &xvmc_vld_driver;
			break;
		case XVMC_I945_MPEG2_VLD:
		default:
			XVMC_ERR("unimplemented xvmc type %d", comm->type);
			XFree(priv_data);
			priv_data = NULL;
			return BadValue;
		}
	}

	if (xvmc_driver == NULL || xvmc_driver->type != comm->type) {
		XVMC_ERR("fail to load xvmc driver for type %d\n", comm->type);
		return BadValue;
	}

	XVMC_INFO("decoder type is %s", intel_xvmc_decoder_string(comm->type));

	/* check DRI2 */
	ret = Success;
	xvmc_driver->fd = -1;

	ret = dri2_connect(display);
	if (ret != Success) {
		XFree(priv_data);
		context->privData = NULL;
		if (xvmc_driver->fd >= 0)
			close(xvmc_driver->fd);
		xvmc_driver = NULL;
		return ret;
	}

	if ((xvmc_driver->bufmgr =
	     intel_bufmgr_gem_init(xvmc_driver->fd, 1024 * 64)) == NULL) {
		XVMC_ERR("Can't init bufmgr\n");
		return BadAlloc;
	}
	drm_intel_bufmgr_gem_enable_reuse(xvmc_driver->bufmgr);

	/* call driver hook.
	 * driver hook should free priv_data after return if success.*/
	ret =
	    (xvmc_driver->create_context) (display, context, priv_count,
					   priv_data);
	if (ret) {
		XVMC_ERR("driver create context failed\n");
		XFree(priv_data);
		context->privData = NULL;
		xvmc_driver = NULL;
		return ret;
	}

	pthread_mutex_init(&xvmc_driver->ctxmutex, NULL);
	intelInitBatchBuffer();
	intel_xvmc_dump_open();

	return Success;
}

/*
 * Function: XvMCDestroyContext
 * Description: Destorys the specified context.
 *
 * Arguments:
 *   display - Specifies the connection to the server.
 *   context - The context to be destroyed.
 *
 */
_X_EXPORT Status XvMCDestroyContext(Display * display, XvMCContext * context)
{
	Status ret;
	int screen;

	if (!display || !context)
		return XvMCBadContext;
	screen = DefaultScreen(display);
	ret = (xvmc_driver->destroy_context) (display, context);
	if (ret) {
		XVMC_ERR("destroy context fail\n");
		return ret;
	}

	intelFiniBatchBuffer();

	dri_bufmgr_destroy(xvmc_driver->bufmgr);

	ret = _xvmc_destroy_context(display, context);
	if (ret != Success) {
		XVMC_ERR("_xvmc_destroy_context fail\n");
		return ret;
	}

	if (xvmc_driver->num_ctx == 0) {
		pthread_mutex_destroy(&xvmc_driver->ctxmutex);

		if (xvmc_driver->fd >= 0)
			close(xvmc_driver->fd);

		xvmc_driver->fd = -1;
		intel_xvmc_dump_close();
	}
	return Success;
}

/*
 * Function: XvMCCreateSurface
 */
_X_EXPORT Status XvMCCreateSurface(Display * display, XvMCContext * context,
				   XvMCSurface * surface)
{
	Status ret;
	int priv_count;
	CARD32 *priv_data;
	intel_xvmc_surface_ptr intel_surf = NULL;
	struct intel_xvmc_context *intel_ctx;

	if (!display || !context)
		return XvMCBadContext;

	if (!surface)
		return XvMCBadSurface;

	intel_ctx = context->privData;

	if ((ret = _xvmc_create_surface(display, context, surface,
					&priv_count, &priv_data))) {
		XVMC_ERR("Unable to create XvMCSurface.");
		return ret;
	}

	XFree(priv_data);

	surface->privData = calloc(1, sizeof(struct intel_xvmc_surface));

	if (!(intel_surf = surface->privData)) {
		PPTHREAD_MUTEX_UNLOCK();
		return BadAlloc;
	}

	intel_surf->bo = drm_intel_bo_alloc(xvmc_driver->bufmgr,
					      "surface",
					      intel_ctx->surface_bo_size,
					      GTT_PAGE_SIZE);
	if (!intel_surf->bo) {
		free(intel_surf);
		return BadAlloc;
	}

	drm_intel_bo_disable_reuse(intel_surf->bo);

	intel_surf = surface->privData;
	intel_surf->context = context;

	intel_surf->image = XvCreateImage(display, context->port,
					  FOURCC_XVMC,
					  (char *) &intel_surf->gem_handle,
					  surface->width, surface->height);
	if (!intel_surf->image) {
		XVMC_ERR("Can't create XvImage for surface\n");
		free(intel_surf);
		_xvmc_destroy_surface(display, surface);
		return BadAlloc;
	}

	return Success;
}

/*
 * Function: XvMCDestroySurface
 */
_X_EXPORT Status XvMCDestroySurface(Display * display, XvMCSurface * surface)
{
	intel_xvmc_surface_ptr intel_surf;

	if (!display || !surface)
		return XvMCBadSurface;

	intel_surf = surface->privData;
	if (!intel_surf)
		return XvMCBadSurface;

	XFree(intel_surf->image);
	if (intel_surf->gc_init)
		XFreeGC(display, intel_surf->gc);

	drm_intel_bo_unreference(intel_surf->bo);

	free(intel_surf);

	_xvmc_destroy_surface(display, surface);

	return Success;
}

/*
 * Function: XvMCCreateBlocks
 */
_X_EXPORT Status XvMCCreateBlocks(Display * display, XvMCContext * context,
				  unsigned int num_blocks,
				  XvMCBlockArray * block)
{
	if (!display || !context || !num_blocks || !block)
		return BadValue;

	memset(block, 0, sizeof(XvMCBlockArray));

	if (!
	    (block->blocks =
	     (short *)malloc((num_blocks << 6) * sizeof(short))))
		return BadAlloc;

	block->num_blocks = num_blocks;
	block->context_id = context->context_id;
	block->privData = NULL;

	return Success;
}

/*
 * Function: XvMCDestroyBlocks
 */
_X_EXPORT Status XvMCDestroyBlocks(Display * display, XvMCBlockArray * block)
{
	if (!display || !block)
		return BadValue;

	if (block->blocks)
		free(block->blocks);

	block->context_id = 0;
	block->num_blocks = 0;
	block->blocks = NULL;
	block->privData = NULL;

	return Success;
}

/*
 * Function: XvMCCreateMacroBlocks
 */
_X_EXPORT Status XvMCCreateMacroBlocks(Display * display, XvMCContext * context,
				       unsigned int num_blocks,
				       XvMCMacroBlockArray * blocks)
{
	if (!display || !context || !blocks || !num_blocks)
		return BadValue;

	memset(blocks, 0, sizeof(XvMCMacroBlockArray));
	blocks->macro_blocks =
	    (XvMCMacroBlock *) malloc(num_blocks * sizeof(XvMCMacroBlock));

	if (!blocks->macro_blocks)
		return BadAlloc;

	blocks->num_blocks = num_blocks;
	blocks->context_id = context->context_id;
	blocks->privData = NULL;

	return Success;
}

/*
 * Function: XvMCDestroyMacroBlocks
 */
_X_EXPORT Status XvMCDestroyMacroBlocks(Display * display,
					XvMCMacroBlockArray * block)
{
	if (!display || !block)
		return BadValue;
	if (block->macro_blocks)
		free(block->macro_blocks);

	block->context_id = 0;
	block->num_blocks = 0;
	block->macro_blocks = NULL;
	block->privData = NULL;

	return Success;
}

/*
 * Function: XvMCRenderSurface
 *
 * Description: This function does the actual HWMC. Given a list of
 *  macroblock structures it dispatched the hardware commands to execute
 *  them.
 */
_X_EXPORT Status XvMCRenderSurface(Display * display, XvMCContext * context,
				   unsigned int picture_structure,
				   XvMCSurface * target_surface,
				   XvMCSurface * past_surface,
				   XvMCSurface * future_surface,
				   unsigned int flags,
				   unsigned int num_macroblocks,
				   unsigned int first_macroblock,
				   XvMCMacroBlockArray * macroblock_array,
				   XvMCBlockArray * blocks)
{
	Status ret;

	if (!display || !context) {
		XVMC_ERR("Invalid Display, Context or Target!");
		return XvMCBadContext;
	}
	if (!target_surface)
		return XvMCBadSurface;

	intel_xvmc_dump_render(context, picture_structure, target_surface,
			       past_surface, future_surface, flags,
			       num_macroblocks, first_macroblock,
			       macroblock_array, blocks);

	ret =
	    (xvmc_driver->render_surface) (display, context, picture_structure,
					   target_surface, past_surface,
					   future_surface, flags,
					   num_macroblocks, first_macroblock,
					   macroblock_array, blocks);

	if (ret) {
		XVMC_ERR("render surface fail\n");
		return ret;
	}
	return Success;
}

/*
 * Function: XvMCPutSurface
 *
 * Description:
 * Arguments:
 *  display: Connection to X server
 *  surface: Surface to be displayed
 *  draw: X Drawable on which to display the surface
 *  srcx: X coordinate of the top left corner of the region to be
 *          displayed within the surface.
 *  srcy: Y coordinate of the top left corner of the region to be
 *          displayed within the surface.
 *  srcw: Width of the region to be displayed.
 *  srch: Height of the region to be displayed.
 *  destx: X cordinate of the top left corner of the destination region
 *         in the drawable coordinates.
 *  desty: Y cordinate of the top left corner of the destination region
 *         in the drawable coordinates.
 *  destw: Width of the destination region.
 *  desth: Height of the destination region.
 *  flags: One or more of the following.
 *	XVMC_TOP_FIELD - Display only the Top field of the surface.
 *	XVMC_BOTTOM_FIELD - Display only the Bottom Field of the surface.
 *	XVMC_FRAME_PICTURE - Display both fields or frame.
 */
_X_EXPORT Status XvMCPutSurface(Display * display, XvMCSurface * surface,
				Drawable draw, short srcx, short srcy,
				unsigned short srcw, unsigned short srch,
				short destx, short desty,
				unsigned short destw, unsigned short desth,
				int flags)
{
	Status ret = Success;
	XvMCContext *context;
	intel_xvmc_surface_ptr intel_surf;

	if (!display || !surface)
		return XvMCBadSurface;

	intel_surf = surface->privData;
	context = intel_surf->context;
	if (!context || !intel_surf)
		return XvMCBadSurface;

	if (intel_surf->gc_init == FALSE) {
		intel_surf->gc = XCreateGC(display, draw, 0, NULL);
		intel_surf->gc_init = TRUE;
	} else if (draw != intel_surf->last_draw) {
		XFreeGC(display, intel_surf->gc);
		intel_surf->gc = XCreateGC(display, draw, 0, NULL);
	}
	intel_surf->last_draw = draw;

	drm_intel_bo_flink(intel_surf->bo, &intel_surf->gem_handle);

	ret = XvPutImage(display, context->port, draw, intel_surf->gc,
			 intel_surf->image, srcx, srcy, srcw, srch, destx,
			 desty, destw, desth);
	return ret;
}

/*
 * Function: XvMCSyncSurface
 * Arguments:
 *   display - Connection to the X server
 *   surface - The surface to synchronize
 */
_X_EXPORT Status XvMCSyncSurface(Display * display, XvMCSurface * surface)
{
	if (!display || !surface)
		return XvMCBadSurface;

	return Success;
}

/*
 * Function: XvMCFlushSurface
 * Description:
 *   This function commits pending rendering requests to ensure that they
 *   wll be completed in a finite amount of time.
 * Arguments:
 *   display - Connection to X server
 *   surface - Surface to flush
 * Returns: Status
 */
_X_EXPORT Status XvMCFlushSurface(Display * display, XvMCSurface * surface)
{
	if (!display || !surface)
		return XvMCBadSurface;

	return Success;
}

/*
 * Function: XvMCGetSurfaceStatus
 * Description:
 * Arguments:
 *  display: connection to X server
 *  surface: The surface to query
 *  stat: One of the Following
 *    XVMC_RENDERING - The last XvMCRenderSurface command has not
 *                     completed.
 *    XVMC_DISPLAYING - The surface is currently being displayed or a
 *                     display is pending.
 */
_X_EXPORT Status XvMCGetSurfaceStatus(Display * display, XvMCSurface * surface,
				      int *stat)
{
	if (!display || !surface || !stat)
		return XvMCBadSurface;

	*stat = 0;

	return Success;
}

/*
 * Function: XvMCHideSurface
 * Description: Stops the display of a surface.
 * Arguments:
 *   display - Connection to the X server.
 *   surface - surface to be hidden.
 *
 * Returns: Status
 */
_X_EXPORT Status XvMCHideSurface(Display * display, XvMCSurface * surface)
{
	if (!display || !surface)
		return XvMCBadSurface;

	return Success;
}

/*
 * Function: XvMCCreateSubpicture
 * Description: This creates a subpicture by filling out the XvMCSubpicture
 *              structure passed to it and returning Success.
 * Arguments:
 *   display - Connection to the X server.
 *   context - The context to create the subpicture for.
 *   subpicture - Pre-allocated XvMCSubpicture structure to be filled in.
 *   width - of subpicture
 *   height - of subpicture
 *   xvimage_id - The id describing the XvImage format.
 *
 * Returns: Status
 */
_X_EXPORT Status XvMCCreateSubpicture(Display * display, XvMCContext * context,
				      XvMCSubpicture * subpicture,
				      unsigned short width,
				      unsigned short height, int xvimage_id)
{
	XVMC_ERR("XvMCCreateSubpicture not implemented!\n");
	return BadValue;
}

/*
 * Function: XvMCClearSubpicture
 * Description: Clear the area of the given subpicture to "color".
 *              structure passed to it and returning Success.
 * Arguments:
 *   display - Connection to the X server.
 *   subpicture - Subpicture to clear.
 *   x, y, width, height - rectangle in the subpicture to clear.
 *   color - The data to file the rectangle with.
 *
 * Returns: Status
 */
_X_EXPORT Status XvMCClearSubpicture(Display * display,
				     XvMCSubpicture * subpicture, short x,
				     short y, unsigned short width,
				     unsigned short height, unsigned int color)
{
	XVMC_ERR("XvMCClearSubpicture not implemented!");
	return BadValue;
}

/*
 * Function: XvMCCompositeSubpicture
 * Description: Composite the XvImae on the subpicture. This composit uses
 *              non-premultiplied alpha. Destination alpha is utilized
 *              except for with indexed subpictures. Indexed subpictures
 *              use a simple "replace".
 * Arguments:
 *   display - Connection to the X server.
 *   subpicture - Subpicture to clear.
 *   image - the XvImage to be used as the source of the composite.
 *   srcx, srcy, width, height - The rectangle from the image to be used.
 *   dstx, dsty - location in the subpicture to composite the source.
 *
 * Returns: Status
 */
_X_EXPORT Status XvMCCompositeSubpicture(Display * display,
					 XvMCSubpicture * subpicture,
					 XvImage * image, short srcx,
					 short srcy, unsigned short width,
					 unsigned short height, short dstx,
					 short dsty)
{
	XVMC_ERR("XvMCCompositeSubpicture not implemented!");
	return BadValue;
}

/*
 * Function: XvMCDestroySubpicture
 * Description: Destroys the specified subpicture.
 * Arguments:
 *   display - Connection to the X server.
 *   subpicture - Subpicture to be destroyed.
 *
 * Returns: Status
 */
_X_EXPORT Status XvMCDestroySubpicture(Display * display,
				       XvMCSubpicture * subpicture)
{
	XVMC_ERR("XvMCDestroySubpicture not implemented!");
	return BadValue;
}

/*
 * Function: XvMCSetSubpicturePalette
 * Description: Set the subpictures palette
 * Arguments:
 *   display - Connection to the X server.
 *   subpicture - Subpiture to set palette for.
 *   palette - A pointer to an array holding the palette data. The array
 *     is num_palette_entries * entry_bytes in size.
 * Returns: Status
 */
_X_EXPORT Status XvMCSetSubpicturePalette(Display * display,
					  XvMCSubpicture * subpicture,
					  unsigned char *palette)
{
	XVMC_ERR("XvMCSetSubpicturePalette not implemented!");
	return BadValue;
}

/*
 * Function: XvMCBlendSubpicture
 * Description:
 *    The behavior of this function is different depending on whether
 *    or not the XVMC_BACKEND_SUBPICTURE flag is set in the XvMCSurfaceInfo.
 *    i915 only support frontend behavior.
 *
 *    XVMC_BACKEND_SUBPICTURE not set ("frontend" behavior):
 *
 *    XvMCBlendSubpicture is a no-op in this case.
 *
 * Arguments:
 *   display - Connection to the X server.
 *   subpicture - The subpicture to be blended into the video.
 *   target_surface - The surface to be displayed with the blended subpic.
 *   source_surface - Source surface prior to blending.
 *   subx, suby, subw, subh - The rectangle from the subpicture to use.
 *   surfx, surfy, surfw, surfh - The rectangle in the surface to blend
 *      blend the subpicture rectangle into. Scaling can ocure if
 *      XVMC_SUBPICTURE_INDEPENDENT_SCALING is set.
 *
 * Returns: Status
 */
_X_EXPORT Status XvMCBlendSubpicture(Display * display,
				     XvMCSurface * target_surface,
				     XvMCSubpicture * subpicture, short subx,
				     short suby, unsigned short subw,
				     unsigned short subh, short surfx,
				     short surfy, unsigned short surfw,
				     unsigned short surfh)
{
	XVMC_ERR("XvMCBlendSubpicture not implemented!");
	return BadValue;
}

/*
 * Function: XvMCBlendSubpicture2
 * Description:
 *    The behavior of this function is different depending on whether
 *    or not the XVMC_BACKEND_SUBPICTURE flag is set in the XvMCSurfaceInfo.
 *    i915 only supports frontend blending.
 *
 *    XVMC_BACKEND_SUBPICTURE not set ("frontend" behavior):
 *
 *    XvMCBlendSubpicture2 blends the source_surface and subpicture and
 *    puts it in the target_surface.  This does not effect the status of
 *    the source surface but will cause the target_surface to query
 *    XVMC_RENDERING until the blend is completed.
 *
 * Arguments:
 *   display - Connection to the X server.
 *   subpicture - The subpicture to be blended into the video.
 *   target_surface - The surface to be displayed with the blended subpic.
 *   source_surface - Source surface prior to blending.
 *   subx, suby, subw, subh - The rectangle from the subpicture to use.
 *   surfx, surfy, surfw, surfh - The rectangle in the surface to blend
 *      blend the subpicture rectangle into. Scaling can ocure if
 *      XVMC_SUBPICTURE_INDEPENDENT_SCALING is set.
 *
 * Returns: Status
 */
_X_EXPORT Status XvMCBlendSubpicture2(Display * display,
				      XvMCSurface * source_surface,
				      XvMCSurface * target_surface,
				      XvMCSubpicture * subpicture,
				      short subx, short suby,
				      unsigned short subw, unsigned short subh,
				      short surfx, short surfy,
				      unsigned short surfw,
				      unsigned short surfh)
{
	XVMC_ERR("XvMCBlendSubpicture2 not implemented!");
	return BadValue;
}

/*
 * Function: XvMCSyncSubpicture
 * Description: This function blocks until all composite/clear requests on
 *              the subpicture have been complete.
 * Arguments:
 *   display - Connection to the X server.
 *   subpicture - The subpicture to synchronize
 *
 * Returns: Status
 */
_X_EXPORT Status XvMCSyncSubpicture(Display * display,
				    XvMCSubpicture * subpicture)
{
	XVMC_ERR("XvMCSyncSubpicture not implemented!");
	return BadValue;
}

/*
 * Function: XvMCFlushSubpicture
 * Description: This function commits pending composite/clear requests to
 *              ensure that they will be completed in a finite amount of
 *              time.
 * Arguments:
 *   display - Connection to the X server.
 *   subpicture - The subpicture whos compsiting should be flushed
 *
 * Returns: Status
 */
_X_EXPORT Status XvMCFlushSubpicture(Display * display,
				     XvMCSubpicture * subpicture)
{
	XVMC_ERR("XvMCFlushSubpicture not implemented!");
	return BadValue;
}

/*
 * Function: XvMCGetSubpictureStatus
 * Description: This function gets the current status of a subpicture
 *
 * Arguments:
 *   display - Connection to the X server.
 *   subpicture - The subpicture whos status is being queried
 *   stat - The status of the subpicture. It can be any of the following
 *          OR'd together:
 *          XVMC_RENDERING  - Last composite or clear request not completed
 *          XVMC_DISPLAYING - Suppicture currently being displayed.
 *
 * Returns: Status
 */
_X_EXPORT Status XvMCGetSubpictureStatus(Display * display,
					 XvMCSubpicture * subpicture, int *stat)
{
	XVMC_ERR("XvMCGetSubpictureStatus not implemented!");
	return BadValue;
}

/*
 * Function: XvMCQueryAttributes
 * Description: An array of XvAttributes of size "number" is returned by
 *   this function. If there are no attributes, NULL is returned and number
 *   is set to 0. The array may be freed with free().
 *
 * Arguments:
 *   display - Connection to the X server.
 *   context - The context whos attributes we are querying.
 *   number - The returned number of recognized atoms
 *
 * Returns:
 *  An array of XvAttributes.
 */
_X_EXPORT XvAttribute *XvMCQueryAttributes(Display * display,
					   XvMCContext * context, int *number)
{
	/* now XvMC has no extra attribs than Xv */
	*number = 0;
	return NULL;
}

/*
 * Function: XvMCSetAttribute
 * Description: This function sets a context-specific attribute.
 *
 * Arguments:
 *   display - Connection to the X server.
 *   context - The context whos attributes we are querying.
 *   attribute - The X atom of the attribute to be changed.
 *   value - The new value for the attribute.
 *
 * Returns:
 *  Status
 */
_X_EXPORT Status XvMCSetAttribute(Display * display, XvMCContext * context,
				  Atom attribute, int value)
{
	return Success;
}

/*
 * Function: XvMCGetAttribute
 * Description: This function queries a context-specific attribute and
 *   returns the value.
 *
 * Arguments:
 *   display - Connection to the X server.
 *   context - The context whos attributes we are querying.
 *   attribute - The X atom of the attribute to be queried
 *   value - The returned attribute value
 *
 * Returns:
 *  Status
 */
_X_EXPORT Status XvMCGetAttribute(Display * display, XvMCContext * context,
				  Atom attribute, int *value)
{
	return Success;
}

_X_EXPORT Status XvMCBeginSurface(Display * display, XvMCContext * context,
				  XvMCSurface * target,
				  XvMCSurface * past,
				  XvMCSurface * future,
				  const XvMCMpegControl * control)
{
	if (xvmc_driver->begin_surface(display, context,
				       target, past, future, control)) {
		XVMC_ERR("BeginSurface fail\n");
		return BadValue;
	}
	return Success;
}

_X_EXPORT Status XvMCLoadQMatrix(Display * display, XvMCContext * context,
				 const XvMCQMatrix * qmx)
{
	if (xvmc_driver->load_qmatrix(display, context, qmx)) {
		XVMC_ERR("LoadQMatrix fail\n");
		return BadValue;
	}
	return Success;
}

_X_EXPORT Status XvMCPutSlice(Display * display, XvMCContext * context,
			      char *slice, int nbytes)
{
	if (xvmc_driver->put_slice(display, context, (unsigned char *) slice, nbytes)) {
		XVMC_ERR("PutSlice fail\n");
		return BadValue;
	}
	return Success;
}

_X_EXPORT Status XvMCPutSlice2(Display * display, XvMCContext * context,
			       char *slice, int nbytes, int slice_code)
{
	if (xvmc_driver->put_slice2
	    (display, context, (unsigned char *) slice, nbytes, slice_code)) {
		XVMC_ERR("PutSlice2 fail\n");
		return BadValue;
	}
	return Success;
}
@


1.8
log
@Update to xf86-video-intel 2.20.19.

A recent kernel with kernel modesetting support is required.
Thanks to jsg@@ and kettenis@@ for their work.
@
text
@@


1.7
log
@Update the intel driver to a more recent version based on more recent
upsteam code.

Backporting keeping UMS changes by me, some bugfixes from kettenis@@.

Has been in snapshots for a while, committed on request so we can be
sure what people are running. This is a prerequesite for sandybridge
support but has those chipsets disabled for now until the correct code
has been added.
@
text
@d975 1
a975 1
 *   is set to 0. The array may be freed with xfree().
@


1.6
log
@Pull in the changes in rendering that I skipped when i backported
changes from later intel versions (after the UMS removal). 95% of this
is the xvmc reworks that makes that code even halfway sane. xvmc is now
enabled by default on 965+.

Tested by many on tech@@, thanks!

ok matthieu@@
@
text
@a107 2
	char __ret = 0;

a218 5
	int isCapable;
	int screen = DefaultScreen(display);
	intel_xvmc_context_ptr intel_ctx;
	int fd;
	char *driverName = NULL, *deviceName = NULL;
a477 1
	Status ret;
a499 1
	Status ret;
a671 3
	Status ret;
	int stat = 0;

d675 1
a675 1
	return ret;
a729 3
	int stat = 0;
	Status ret;

d1059 1
a1059 1
	if (xvmc_driver->put_slice(display, context, slice, nbytes)) {
d1070 1
a1070 1
	    (display, context, slice, nbytes, slice_code)) {
@


1.5
log
@Update the intel driver to 2.9.1 plus backports.

2.9.1 is the last version of the intel DDX that supports UMS (User
modesetting), with 2.10 onwards being purely KMS only. As such, this
driver contains backports of almost every correctness or performance
related fix to the rendering layer in later intel drivers. This driver
*REQUIRES* a GEM enabled kernel. it claims to support non-gem mode but
this is essentially unmaintained and due to the way the abstraciton
works is slow, if it works at all (it often does not). You have been
warned.

tested by many many people on tech over the last few weeks.
@
text
@d28 5
a32 1
#include "dri2.h"
a105 8
int DEBUG;

static void intel_xvmc_debug_init(void)
{
	if (getenv("INTEL_XVMC_DEBUG"))
		DEBUG = 1;
}

d123 2
a124 1
static intel_xvmc_context_ptr intel_xvmc_new_context(Display * dpy)
d126 12
a137 1
	intel_xvmc_context_ptr ret;
d139 1
a139 10
	ret = (intel_xvmc_context_ptr) calloc(1, sizeof(intel_xvmc_context_t));
	if (!ret)
		return NULL;

	if (!xvmc_driver->ctx_list)
		ret->next = NULL;
	else
		ret->next = xvmc_driver->ctx_list;
	xvmc_driver->ctx_list = ret;
	xvmc_driver->num_ctx++;
d141 1
a141 1
	return ret;
d143 4
a146 1
}
d148 7
a154 4
static void intel_xvmc_free_context(XID id)
{
	intel_xvmc_context_ptr p = xvmc_driver->ctx_list;
	intel_xvmc_context_ptr pre = p;
d156 3
a158 10
	while (p) {
		if (p->context && p->context->context_id == id) {
			if (p == xvmc_driver->ctx_list)
				xvmc_driver->ctx_list = p->next;
			else
				pre->next = p->next;
			break;
		}
		pre = p;
		p = p->next;
d160 1
d162 5
a166 3
	if (p) {
		free(p);
		xvmc_driver->num_ctx--;
d168 8
a175 10
}

intel_xvmc_context_ptr intel_xvmc_find_context(XID id)
{
	intel_xvmc_context_ptr p = xvmc_driver->ctx_list;

	while (p) {
		if (p->context && p->context->context_id == id)
			return p;
		p = p->next;
a176 2
	return NULL;
}
d178 3
a180 37
static intel_xvmc_surface_ptr intel_xvmc_new_surface(Display * dpy)
{
	intel_xvmc_surface_ptr ret;

	ret = (intel_xvmc_surface_ptr) calloc(1, sizeof(intel_xvmc_surface_t));
	if (!ret)
		return NULL;

	if (!xvmc_driver->surf_list)
		ret->next = NULL;
	else
		ret->next = xvmc_driver->surf_list;
	xvmc_driver->surf_list = ret;
	xvmc_driver->num_surf++;

	ret->image = NULL;
	ret->gc_init = FALSE;

	return ret;

}

static void intel_xvmc_free_surface(XID id)
{
	intel_xvmc_surface_ptr p = xvmc_driver->surf_list;
	intel_xvmc_surface_ptr pre = p;

	while (p) {
		if (p->surface && p->surface->surface_id == id) {
			if (p == xvmc_driver->surf_list)
				xvmc_driver->surf_list = p->next;
			else
				pre->next = p->next;
			break;
		}
		pre = p;
		p = p->next;
d183 5
a187 3
	if (p) {
		free(p);
		xvmc_driver->num_surf--;
d189 1
a189 1
}
d191 1
a191 10
intel_xvmc_surface_ptr intel_xvmc_find_surface(XID id)
{
	intel_xvmc_surface_ptr p = xvmc_driver->surf_list;

	while (p) {
		if (p->surface && p->surface->surface_id == id)
			return p;
		p = p->next;
	}
	return NULL;
d216 1
a216 2
	struct _intel_xvmc_common *comm;
	drm_magic_t magic;
a235 2
	intel_xvmc_debug_init();

d251 1
a271 1
	XVMC_DBG("new context %d created\n", (int)context->context_id);
d273 1
a273 1
	comm = (struct _intel_xvmc_common *)priv_data;
a301 10
	xvmc_driver->kernel_exec_fencing = comm->kernel_exec_fencing;

	/* assign local ctx info */
	intel_ctx = intel_xvmc_new_context(display);
	if (!intel_ctx) {
		XVMC_ERR("Intel XvMC context create fail\n");
		return BadAlloc;
	}
	intel_ctx->context = context;

d306 1
a306 43
	do {
		if (!DRI2QueryExtension(display, &event_base, &error_base)) {
			ret = BadValue;
			break;
		}

		if (!DRI2QueryVersion(display, &major, &minor)) {
			ret = BadValue;
			break;
		}

		if (!DRI2Connect(display, RootWindow(display, screen),
				 &driverName, &deviceName)) {
			ret = BadValue;
			break;
		}

		xvmc_driver->fd = open(deviceName, O_RDWR);

		if (xvmc_driver->fd < 0) {
			XVMC_ERR("Failed to open drm device: %s\n",
				 strerror(errno));
			ret = BadValue;
			break;
		}

		if (drmGetMagic(xvmc_driver->fd, &magic)) {
			XVMC_ERR("Failed to get magic\n");
			ret = BadValue;
			break;
		}

		if (!DRI2Authenticate
		    (display, RootWindow(display, screen), magic)) {
			XVMC_ERR("Failed to authenticate magic %d\n", magic);
			ret = BadValue;
			break;
		}
	} while (0);

	XFree(driverName);
	XFree(deviceName);

a309 1

a311 1

a369 2
	intel_xvmc_free_context(context->context_id);

d398 1
d406 1
a406 4
	intel_surf = intel_xvmc_new_surface(display);
	if (!intel_surf)
		return BadAlloc;
	intel_surf->surface = surface;
d414 23
d439 1
a439 1
					  (char *)&intel_surf->data,
d443 1
a444 1
		intel_xvmc_free_surface(surface->surface_id);
a446 9
	intel_surf->image->data = (char *)&intel_surf->data;

	ret =
	    (xvmc_driver->create_surface) (display, context, surface,
					   priv_count, priv_data);
	if (ret) {
		XVMC_ERR("create surface failed\n");
		return ret;
	}
d461 1
a461 1
	intel_surf = intel_xvmc_find_surface(surface->surface_id);
a467 1
	intel_xvmc_free_surface(surface->surface_id);
d469 3
a471 1
	(xvmc_driver->destroy_surface) (display, surface);
a645 1
	intel_xvmc_context_ptr intel_ctx;
d651 3
a653 3
	intel_ctx = intel_xvmc_find_context(surface->context_id);
	intel_surf = intel_xvmc_find_surface(surface->surface_id);
	if (!intel_ctx || !intel_surf)
a654 1
	context = intel_ctx->context;
d664 3
a666 8
	/* fill intel_surf->data */
	ret = (xvmc_driver->put_surface) (display, surface, draw, srcx, srcy,
					  srcw, srch, destx, desty, destw,
					  desth, flags, &intel_surf->data);
	if (ret) {
		XVMC_ERR("put surface fail\n");
		return ret;
	}
a686 4
	do {
		ret = XvMCGetSurfaceStatus(display, surface, &stat);
	} while (!ret && (stat & XVMC_RENDERING));

d704 1
a722 2
	Status ret;

d726 1
a726 5
	ret = (xvmc_driver->get_surface_status) (display, surface, stat);
	if (ret) {
		XVMC_ERR("get surface status fail\n");
		return ret;
	}
d748 1
a748 15
	XvMCSyncSurface(display, surface);

	/*
	   Get the status of the surface, if it is not currently displayed
	   we don't need to worry about it.
	 */
	if ((ret = XvMCGetSurfaceStatus(display, surface, &stat)) != Success)
		return ret;

	if (!(stat & XVMC_DISPLAYING))
		return Success;

	/* FIXME: */
	XVMC_ERR("XvMCHideSurface not implemented!\n");
	return BadValue;
@


1.4
log
@update to xf86-video-intel 2.7.1. Tested by many.
@
text
@d28 1
d36 64
a99 64
    0, /* 0 */
    128, /* 1 */
    128, /* 10 */
    256, /* 11 */
    128, /* 100 */
    256, /* 101 */
    256, /* 110 */
    384, /* 111 */
    128, /* 1000 */
    256, /* 1001 */
    256, /* 1010 */
    384, /* 1011 */
    256, /* 1100 */
    384, /* 1101 */
    384, /* 1110 */
    512, /* 1111 */
    128, /* 10000 */
    256, /* 10001 */
    256, /* 10010 */
    384, /* 10011 */
    256, /* 10100 */
    384, /* 10101 */
    384, /* 10110 */
    512, /* 10111 */
    256, /* 11000 */
    384, /* 11001 */
    384, /* 11010 */
    512, /* 11011 */
    384, /* 11100 */
    512, /* 11101 */
    512, /* 11110 */
    640, /* 11111 */
    128, /* 100000 */
    256, /* 100001 */
    256, /* 100010 */
    384, /* 100011 */
    256, /* 100100 */
    384, /* 100101 */
    384, /* 100110 */
    512, /* 100111 */
    256, /* 101000 */
    384, /* 101001 */
    384, /* 101010 */
    512, /* 101011 */
    384, /* 101100 */
    512, /* 101101 */
    512, /* 101110 */
    640, /* 101111 */
    256, /* 110000 */
    384, /* 110001 */
    384, /* 110010 */
    512, /* 110011 */
    384, /* 110100 */
    512, /* 110101 */
    512, /* 110110 */
    640, /* 110111 */
    384, /* 111000 */
    512, /* 111001 */
    512, /* 111010 */
    640, /* 111011 */
    512, /* 111100 */
    640, /* 111101 */
    640, /* 111110 */
    768  /* 111111 */
a103 3
static int error_base;
static int event_base;

d106 2
a107 8
    if (getenv("INTEL_XVMC_DEBUG"))
	DEBUG = 1;
}

/* locking */
static void intel_xvmc_try_heavy_lock(drm_context_t ctx)
{
    drmGetLock(xvmc_driver->fd, ctx, 0);
d112 1
a112 1
    char __ret = 0;
d114 2
a115 2
    PPTHREAD_MUTEX_LOCK();
    assert(!xvmc_driver->locked);
d117 1
a117 7
    DRM_CAS(xvmc_driver->driHwLock, ctx,
            (DRM_LOCK_HELD | ctx), __ret);

    if (__ret)
	intel_xvmc_try_heavy_lock(ctx);

    xvmc_driver->locked = 1;
d122 3
a124 3
    xvmc_driver->locked = 0;
    DRM_UNLOCK(xvmc_driver->fd, xvmc_driver->driHwLock, ctx);
    PPTHREAD_MUTEX_UNLOCK();
d127 1
a127 1
static intel_xvmc_context_ptr intel_xvmc_new_context(Display *dpy)
d129 1
a129 1
    intel_xvmc_context_ptr ret;
d131 3
a133 3
    ret = (intel_xvmc_context_ptr)calloc(1, sizeof(intel_xvmc_context_t));
    if (!ret)
	return NULL;
d135 6
a140 6
    if (!xvmc_driver->ctx_list)
	ret->next = NULL;
    else
	ret->next = xvmc_driver->ctx_list;
    xvmc_driver->ctx_list = ret;
    xvmc_driver->num_ctx++;
d142 1
a142 1
    return ret;
d148 14
a161 2
    intel_xvmc_context_ptr p = xvmc_driver->ctx_list;
    intel_xvmc_context_ptr pre = p;
d163 4
a166 16
    while(p) {
	if (p->context && p->context->context_id == id) {
	    if (p == xvmc_driver->ctx_list)
		xvmc_driver->ctx_list = p->next;
	    else
		pre->next = p->next;
	    break;
	}
	pre = p;
	p = p->next;
    }

    if (p) {
	free(p);
	xvmc_driver->num_ctx--;
    }
d171 1
a171 1
    intel_xvmc_context_ptr p = xvmc_driver->ctx_list;
d173 6
a178 6
    while(p) {
	if (p->context && p->context->context_id == id)
	    return p;
	p = p->next;
    }
    return NULL;
d181 1
a181 1
static intel_xvmc_surface_ptr intel_xvmc_new_surface(Display *dpy)
d183 1
a183 1
    intel_xvmc_surface_ptr ret;
d185 10
a194 3
    ret = (intel_xvmc_surface_ptr)calloc(1, sizeof(intel_xvmc_surface_t));
    if (!ret)
	return NULL;
d196 2
a197 6
    if (!xvmc_driver->surf_list)
	ret->next = NULL;
    else
	ret->next = xvmc_driver->surf_list;
    xvmc_driver->surf_list = ret;
    xvmc_driver->num_surf++;
d199 1
a199 4
    ret->image = NULL;
    ret->gc_init = FALSE;

    return ret;
d205 14
a218 2
    intel_xvmc_surface_ptr p = xvmc_driver->surf_list;
    intel_xvmc_surface_ptr pre = p;
d220 4
a223 16
    while(p) {
	if (p->surface && p->surface->surface_id == id) {
	    if (p == xvmc_driver->surf_list)
		xvmc_driver->surf_list = p->next;
	    else
		pre->next = p->next;
	    break;
	}
	pre = p;
	p = p->next;
    }

    if (p) {
	free(p);
	xvmc_driver->num_surf--;
    }
d228 1
a228 1
    intel_xvmc_surface_ptr p = xvmc_driver->surf_list;
d230 6
a235 6
    while(p) {
	if (p->surface && p->surface->surface_id == id)
	    return p;
	p = p->next;
    }
    return NULL;
d237 1
d254 87
a340 48
_X_EXPORT Status XvMCCreateContext(Display *display, XvPortID port,
                         int surface_type_id, int width, int height,
                         int flags, XvMCContext *context)
{
    Status ret;
    drm_sarea_t *pSAREA;
    char *curBusID;
    CARD32 *priv_data = NULL;
    struct _intel_xvmc_common *comm;
    drm_magic_t magic;
    int major, minor;
    int priv_count;
    int isCapable;
    int screen = DefaultScreen(display);
    intel_xvmc_context_ptr intel_ctx;
    int fd;

    /* Verify Obvious things first */
    if (!display || !context)
        return BadValue;

    if (!(flags & XVMC_DIRECT)) {
        XVMC_ERR("Indirect Rendering not supported! Using Direct.");
        return BadValue;
    }

    intel_xvmc_debug_init();

    /*
       Width, Height, and flags are checked against surface_type_id
       and port for validity inside the X server, no need to check
       here.
    */
    context->surface_type_id = surface_type_id;
    context->width = (unsigned short)((width + 15) & ~15);
    context->height = (unsigned short)((height + 15) & ~15);
    context->flags = flags;
    context->port = port;

    if (!XvMCQueryExtension(display, &event_base, &error_base)) {
        XVMC_ERR("XvMCExtension is not available!");
        return BadValue;
    }
    ret = XvMCQueryVersion(display, &major, &minor);
    if (ret) {
        XVMC_ERR("XvMCQueryVersion Failed, unable to determine protocol version.");
	return ret;
    }
d342 2
a343 30
    /* XXX: major and minor could be checked in future for XvMC
     * protocol capability (i.e H.264/AVC decode available)
     */

    /*
      Pass control to the X server to create a drm_context_t for us and
      validate the with/height and flags.
    */
    if ((ret = _xvmc_create_context(display, context, &priv_count, &priv_data))) {
        XVMC_ERR("Unable to create XvMC Context.");
        return ret;
    }
    XVMC_DBG("new context %d created\n", (int)context->context_id);

    comm = (struct _intel_xvmc_common *)priv_data;

    if (xvmc_driver == NULL || xvmc_driver->type != comm->type) {
	switch (comm->type) {
	    case XVMC_I915_MPEG2_MC:
		xvmc_driver = &i915_xvmc_mc_driver;
		break;
	    case XVMC_I965_MPEG2_MC:
		xvmc_driver = &i965_xvmc_mc_driver;
		break;
	    case XVMC_I945_MPEG2_VLD:
	    case XVMC_I965_MPEG2_VLD:
	    default:
		XVMC_ERR("unimplemented xvmc type %d", comm->type);
		XFree(priv_data);
		priv_data = NULL;
a345 1
    }
d347 65
a411 4
    if (xvmc_driver == NULL || xvmc_driver->type != comm->type) {
	XVMC_ERR("fail to load xvmc driver for type %d\n", comm->type);
	return BadValue;
    }
d413 3
a415 1
    XVMC_INFO("decoder type is %s", intel_xvmc_decoder_string(comm->type));
d417 6
a422 88
    xvmc_driver->sarea_size = comm->sarea_size;
    xvmc_driver->batchbuffer.handle = comm->batchbuffer.handle;
    xvmc_driver->batchbuffer.offset = comm->batchbuffer.offset;
    xvmc_driver->batchbuffer.size = comm->batchbuffer.size;

    /* assign local ctx info */
    intel_ctx = intel_xvmc_new_context(display);
    if (!intel_ctx) {
	XVMC_ERR("Intel XvMC context create fail\n");
	return BadAlloc;
    }
    intel_ctx->context = context;

    ret = uniDRIQueryDirectRenderingCapable(display, screen,
                                            &isCapable);
    if (!ret || !isCapable) {
	XVMC_ERR("Direct Rendering is not available on this system!");
	XFree(priv_data);
        return BadValue;
    }

    if (!uniDRIOpenConnection(display, screen,
                              &xvmc_driver->hsarea, &curBusID)) {
        XVMC_ERR("Could not open DRI connection to X server!");
	XFree(priv_data);
        return BadValue;
    }

    /* Open DRI Device */
    if((fd = drmOpen("i915", curBusID)) < 0) {
        XVMC_ERR("DRM Device could not be opened.");
        XFree(priv_data);
        XFree(curBusID);
        return BadValue;
    }

    xvmc_driver->fd = fd;

    strncpy(xvmc_driver->busID, curBusID, 20);
    xvmc_driver->busID[20] = '\0';
    XFree(curBusID);

    /* Get magic number */
    drmGetMagic(xvmc_driver->fd, &magic);
    // context->flags = (unsigned long)magic;

    if (!uniDRIAuthConnection(display, screen, magic)) {
	XVMC_ERR("[XvMC]: X server did not allow DRI. Check permissions.");
	xvmc_driver = NULL;
	XFree(priv_data);
        return BadAlloc;
    }

    /*
     * Map DRI Sarea. we always want it right?
     */
    if (drmMap(xvmc_driver->fd, xvmc_driver->hsarea,
               xvmc_driver->sarea_size, &xvmc_driver->sarea_address) < 0) {
        XVMC_ERR("Unable to map DRI SAREA.\n");
	xvmc_driver = NULL;
	XFree(priv_data);
        return BadAlloc;
    }
    pSAREA = (drm_sarea_t *)xvmc_driver->sarea_address;
    xvmc_driver->driHwLock = (drmLock *)&pSAREA->lock;
    pthread_mutex_init(&xvmc_driver->ctxmutex, NULL);

    /* context_id is alloc in _xvmc_create_context */
    if (!uniDRICreateContext(display, screen, DefaultVisual(display, screen),
			     context->context_id,
                             &intel_ctx->hw_context)) {
        XVMC_ERR("Could not create DRI context for xvmc ctx %d.",
		 (int)context->context_id);
	XFree(priv_data);
        context->privData = NULL;
        drmUnmap(xvmc_driver->sarea_address, xvmc_driver->sarea_size);
        return BadAlloc;
    }

    /* call driver hook.
     * driver hook should free priv_data after return if success.*/
    ret = (xvmc_driver->create_context)(display, context, priv_count, priv_data);
    if (ret) {
	XVMC_ERR("driver create context failed\n");
	XFree(priv_data);
	drmUnmap(xvmc_driver->sarea_address, xvmc_driver->sarea_size);
	return ret;
    }
d424 12
a435 1
    intelInitBatchBuffer();
d437 3
a439 1
    intel_xvmc_dump_open();
d441 1
a441 1
    return Success;
d453 1
a453 1
_X_EXPORT Status XvMCDestroyContext(Display *display, XvMCContext *context)
d455 2
a456 2
    Status ret;
    int screen;
d458 8
a465 8
    if (!display || !context)
        return XvMCBadContext;
    screen = DefaultScreen(display);
    ret = (xvmc_driver->destroy_context)(display, context);
    if (ret) {
	XVMC_ERR("destroy context fail\n");
	return ret;
    }
d467 1
a467 2
    uniDRIDestroyContext(display, screen, context->context_id);
    intel_xvmc_free_context(context->context_id);
d469 1
a469 5
    ret = _xvmc_destroy_context(display, context);
    if (ret != Success) {
	XVMC_ERR("_xvmc_destroy_context fail\n");
	return ret;
    }
d471 1
a471 2
    if (xvmc_driver->num_ctx == 0) {
	uniDRICloseConnection(display, screen);
d473 5
a477 1
	pthread_mutex_destroy(&xvmc_driver->ctxmutex);
d479 2
a480 1
	drmUnmap(xvmc_driver->sarea_address, xvmc_driver->sarea_size);
d482 2
a483 3
	if (xvmc_driver->fd >= 0)
	    drmClose(xvmc_driver->fd);
	xvmc_driver->fd = -1;
d485 4
a488 5
	intelFiniBatchBuffer();

	intel_xvmc_dump_close();
    }
    return Success;
d494 2
a495 1
_X_EXPORT Status XvMCCreateSurface(Display *display, XvMCContext *context, XvMCSurface *surface)
d497 41
a537 39
    Status ret;
    int priv_count;
    CARD32 *priv_data;
    intel_xvmc_surface_ptr intel_surf = NULL;

    if (!display || !context)
        return XvMCBadContext;

    if (!surface)
	return XvMCBadSurface;

    intel_surf = intel_xvmc_new_surface(display);
    if (!intel_surf)
	return BadAlloc;
    intel_surf->surface = surface;

    if ((ret = _xvmc_create_surface(display, context, surface,
                                    &priv_count, &priv_data))) {
        XVMC_ERR("Unable to create XvMCSurface.");
        return ret;
    }

    intel_surf->image = XvCreateImage(display, context->port,
	    FOURCC_XVMC, (char *)&intel_surf->data, surface->width,
	    surface->height);
    if (!intel_surf->image) {
	XVMC_ERR("Can't create XvImage for surface\n");
	_xvmc_destroy_surface(display, surface);
	intel_xvmc_free_surface(surface->surface_id);
	return BadAlloc;
    }
    intel_surf->image->data = (char *)&intel_surf->data;

    ret = (xvmc_driver->create_surface)(display, context, surface, priv_count,
	    priv_data);
    if (ret) {
	XVMC_ERR("create surface failed\n");
	return ret;
    }
d539 1
a539 1
    return Success;
a541 1

d545 1
a545 1
_X_EXPORT Status XvMCDestroySurface(Display *display, XvMCSurface *surface)
d547 1
a547 1
    intel_xvmc_surface_ptr intel_surf;
d549 2
a550 2
    if (!display || !surface)
        return XvMCBadSurface;
d552 3
a554 3
    intel_surf = intel_xvmc_find_surface(surface->surface_id);
    if (!intel_surf)
	return XvMCBadSurface;
d556 4
a559 4
    XFree(intel_surf->image);
    if (intel_surf->gc_init)
	XFreeGC(display, intel_surf->gc);
    intel_xvmc_free_surface(surface->surface_id);
d561 1
a561 1
    (xvmc_driver->destroy_surface)(display, surface);
d563 1
a563 1
    _xvmc_destroy_surface(display, surface);
d565 1
a565 1
    return Success;
d571 3
a573 3
_X_EXPORT Status XvMCCreateBlocks(Display *display, XvMCContext *context,
                        unsigned int num_blocks,
                        XvMCBlockArray *block)
d575 3
a577 3
    Status ret;
    if (!display || !context || !num_blocks || !block)
        return BadValue;
d579 1
a579 1
    memset(block, 0, sizeof(XvMCBlockArray));
d581 8
a588 2
    if (!(block->blocks = (short *)malloc((num_blocks << 6) * sizeof(short))))
        return BadAlloc;
d590 1
a590 5
    block->num_blocks = num_blocks;
    block->context_id = context->context_id;
    block->privData = NULL;

    return Success;
d596 1
a596 1
_X_EXPORT Status XvMCDestroyBlocks(Display *display, XvMCBlockArray *block)
d598 3
a600 3
    Status ret;
    if (!display || !block)
        return BadValue;
d602 2
a603 2
    if (block->blocks)
        free(block->blocks);
d605 4
a608 4
    block->context_id = 0;
    block->num_blocks = 0;
    block->blocks = NULL;
    block->privData = NULL;
d610 1
a610 1
    return Success;
d616 3
a618 3
_X_EXPORT Status XvMCCreateMacroBlocks(Display *display, XvMCContext *context,
                             unsigned int num_blocks,
                             XvMCMacroBlockArray *blocks)
d620 2
a621 5
    if (!display || !context || !blocks || !num_blocks)
        return BadValue;

    memset(blocks, 0, sizeof(XvMCMacroBlockArray));
    blocks->macro_blocks = (XvMCMacroBlock *)malloc(num_blocks * sizeof(XvMCMacroBlock));
d623 10
a632 2
    if (!blocks->macro_blocks)
        return BadAlloc;
d634 1
a634 5
    blocks->num_blocks = num_blocks;
    blocks->context_id = context->context_id;
    blocks->privData = NULL;

    return Success;
d640 2
a641 1
_X_EXPORT Status XvMCDestroyMacroBlocks(Display *display, XvMCMacroBlockArray *block)
d643 4
a646 9
    if (!display || !block)
        return BadValue;
    if (block->macro_blocks)
        free(block->macro_blocks);

    block->context_id = 0;
    block->num_blocks = 0;
    block->macro_blocks = NULL;
    block->privData = NULL;
d648 6
a653 1
    return Success;
d663 19
a681 28
_X_EXPORT Status XvMCRenderSurface(Display *display, XvMCContext *context,
                         unsigned int picture_structure,
                         XvMCSurface *target_surface,
                         XvMCSurface *past_surface,
                         XvMCSurface *future_surface,
                         unsigned int flags,
                         unsigned int num_macroblocks,
                         unsigned int first_macroblock,
                         XvMCMacroBlockArray *macroblock_array,
                         XvMCBlockArray *blocks)
{
    Status ret;

    if (!display || !context) {
        XVMC_ERR("Invalid Display, Context or Target!");
        return XvMCBadContext;
    }
    if (!target_surface)
	return XvMCBadSurface;

    intel_xvmc_dump_render(context, picture_structure, target_surface,
	    past_surface, future_surface, flags, num_macroblocks,
	    first_macroblock, macroblock_array, blocks);

    ret = (xvmc_driver->render_surface)(display, context, picture_structure,
	    target_surface, past_surface, future_surface, flags,
	    num_macroblocks, first_macroblock, macroblock_array,
	    blocks);
d683 17
a699 5
    if (ret) {
	XVMC_ERR("render surface fail\n");
	return ret;
    }
    return Success;
d727 40
a766 34
_X_EXPORT Status XvMCPutSurface(Display *display,XvMCSurface *surface,
                      Drawable draw, short srcx, short srcy,
                      unsigned short srcw, unsigned short srch,
                      short destx, short desty,
                      unsigned short destw, unsigned short desth,
                      int flags)
{
    Status ret = Success;
    XvMCContext *context;
    intel_xvmc_context_ptr intel_ctx;
    intel_xvmc_surface_ptr intel_surf;

    if (!display || !surface)
        return XvMCBadSurface;

    intel_ctx = intel_xvmc_find_context(surface->context_id);
    intel_surf = intel_xvmc_find_surface(surface->surface_id);
    if (!intel_ctx || !intel_surf)
	return XvMCBadSurface;
    context = intel_ctx->context;

    if (intel_surf->gc_init == FALSE) {
	intel_surf->gc = XCreateGC(display, draw, 0, NULL);
	intel_surf->gc_init = TRUE;
    } else if (draw != intel_surf->last_draw) {
	XFreeGC(display, intel_surf->gc);
	intel_surf->gc = XCreateGC(display, draw, 0, NULL);
    }
    intel_surf->last_draw = draw;
    /* fill intel_surf->data */
    ret = (xvmc_driver->put_surface)(display, surface, draw, srcx, srcy,
	    srcw, srch, destx, desty, destw, desth, flags, &intel_surf->data);
    if (ret) {
	XVMC_ERR("put surface fail\n");
a767 5
    }
    ret = XvPutImage(display, context->port, draw, intel_surf->gc,
	    intel_surf->image, srcx, srcy, srcw, srch, destx, desty,
	    destw, desth);
    return ret;
d776 1
a776 1
_X_EXPORT Status XvMCSyncSurface(Display *display, XvMCSurface *surface)
d778 2
a779 2
    Status ret;
    int stat = 0;
d781 2
a782 2
    if (!display || !surface)
	return XvMCBadSurface;
d784 3
a786 3
    do {
        ret = XvMCGetSurfaceStatus(display, surface, &stat);
    } while (!ret && (stat & XVMC_RENDERING));
d788 1
a788 1
    return ret;
d801 1
a801 1
_X_EXPORT Status XvMCFlushSurface(Display * display, XvMCSurface *surface)
d803 3
a805 3
    if (!display || !surface)
	return XvMCBadSurface;
    return Success;
d820 2
a821 1
_X_EXPORT Status XvMCGetSurfaceStatus(Display *display, XvMCSurface *surface, int *stat)
d823 1
a823 1
    Status ret;
d825 2
a826 2
    if (!display || !surface || !stat)
        return XvMCBadSurface;
d828 5
a832 5
    ret = (xvmc_driver->get_surface_status)(display, surface, stat);
    if (ret) {
	XVMC_ERR("get surface status fail\n");
	return ret;
    }
d834 1
a834 1
    return Success;
d846 1
a846 1
_X_EXPORT Status XvMCHideSurface(Display *display, XvMCSurface *surface)
d848 2
a849 2
    int stat = 0;
    Status ret;
d851 2
a852 2
    if (!display || !surface)
        return XvMCBadSurface;
d854 1
a854 1
    XvMCSyncSurface(display, surface);
d856 6
a861 6
    /*
      Get the status of the surface, if it is not currently displayed
      we don't need to worry about it.
    */
    if ((ret = XvMCGetSurfaceStatus(display, surface, &stat)) != Success)
        return ret;
d863 2
a864 2
    if (!(stat & XVMC_DISPLAYING))
        return Success;
d866 3
a868 3
    /* FIXME: */
    XVMC_ERR("XvMCHideSurface not implemented!\n");
    return BadValue;
d885 4
a888 4
_X_EXPORT Status XvMCCreateSubpicture(Display *display, XvMCContext *context,
                            XvMCSubpicture *subpicture,
                            unsigned short width, unsigned short height,
                            int xvimage_id)
d890 2
a891 2
    XVMC_ERR("XvMCCreateSubpicture not implemented!\n");
    return BadValue;
d906 4
a909 4
_X_EXPORT Status XvMCClearSubpicture(Display *display, XvMCSubpicture *subpicture,
                           short x, short y,
                           unsigned short width, unsigned short height,
                           unsigned int color)
d911 2
a912 2
    XVMC_ERR("XvMCClearSubpicture not implemented!");
    return BadValue;
d930 6
a935 5
_X_EXPORT Status XvMCCompositeSubpicture(Display *display, XvMCSubpicture *subpicture,
                               XvImage *image,
                               short srcx, short srcy,
                               unsigned short width, unsigned short height,
                               short dstx, short dsty)
d937 2
a938 2
    XVMC_ERR("XvMCCompositeSubpicture not implemented!");
    return BadValue;
a940 1

d950 2
a951 1
_X_EXPORT Status XvMCDestroySubpicture(Display *display, XvMCSubpicture *subpicture)
d953 2
a954 2
    XVMC_ERR("XvMCDestroySubpicture not implemented!");
    return BadValue;
a956 1

d967 3
a969 2
_X_EXPORT Status XvMCSetSubpicturePalette(Display *display, XvMCSubpicture *subpicture,
                                unsigned char *palette)
d971 2
a972 2
    XVMC_ERR("XvMCSetSubpicturePalette not implemented!");
    return BadValue;
d998 7
a1004 6
_X_EXPORT Status XvMCBlendSubpicture(Display *display, XvMCSurface *target_surface,
                           XvMCSubpicture *subpicture,
                           short subx, short suby,
                           unsigned short subw, unsigned short subh,
                           short surfx, short surfy,
                           unsigned short surfw, unsigned short surfh)
d1006 2
a1007 2
    XVMC_ERR("XvMCBlendSubpicture not implemented!");
    return BadValue;
d1036 9
a1044 8
_X_EXPORT Status XvMCBlendSubpicture2(Display *display,
                            XvMCSurface *source_surface,
                            XvMCSurface *target_surface,
                            XvMCSubpicture *subpicture,
                            short subx, short suby,
                            unsigned short subw, unsigned short subh,
                            short surfx, short surfy,
                            unsigned short surfw, unsigned short surfh)
d1046 2
a1047 2
    XVMC_ERR("XvMCBlendSubpicture2 not implemented!");
    return BadValue;
d1060 2
a1061 1
_X_EXPORT Status XvMCSyncSubpicture(Display *display, XvMCSubpicture *subpicture)
d1063 2
a1064 2
    XVMC_ERR("XvMCSyncSubpicture not implemented!");
    return BadValue;
d1078 2
a1079 1
_X_EXPORT Status XvMCFlushSubpicture(Display *display, XvMCSubpicture *subpicture)
d1081 2
a1082 2
    XVMC_ERR("XvMCFlushSubpicture not implemented!");
    return BadValue;
d1099 2
a1100 2
_X_EXPORT Status XvMCGetSubpictureStatus(Display *display, XvMCSubpicture *subpicture,
                               int *stat)
d1102 2
a1103 2
    XVMC_ERR("XvMCGetSubpictureStatus not implemented!");
    return BadValue;
d1120 2
a1121 2
_X_EXPORT XvAttribute *XvMCQueryAttributes(Display *display, XvMCContext *context,
                                 int *number)
d1123 3
a1125 3
    /* now XvMC has no extra attribs than Xv */
    *number = 0;
    return NULL;
d1141 2
a1142 2
_X_EXPORT Status XvMCSetAttribute(Display *display, XvMCContext *context,
                        Atom attribute, int value)
d1144 1
a1144 1
    return Success;
d1161 11
a1171 2
_X_EXPORT Status XvMCGetAttribute(Display *display, XvMCContext *context,
                        Atom attribute, int *value)
d1173 37
a1209 1
    return Success;
@


1.3
log
@xf86-video-intel 2.4.2. Has been in snapshots for weeks. Ok oga@@.
@
text
@d267 1
a267 1
Status XvMCCreateContext(Display *display, XvPortID port,
a294 6
    /* Open DRI Device */
    if((fd = drmOpen("i915", NULL)) < 0) {
        XVMC_ERR("DRM Device could not be opened.");
        return BadValue;
    }

d338 2
a354 2
    xvmc_driver->fd = fd;

d385 10
d462 1
a462 1
Status XvMCDestroyContext(Display *display, XvMCContext *context)
d506 1
a506 1
Status XvMCCreateSurface(Display *display, XvMCContext *context, XvMCSurface *surface)
d555 1
a555 1
Status XvMCDestroySurface(Display *display, XvMCSurface *surface)
d581 1
a581 1
Status XvMCCreateBlocks(Display *display, XvMCContext *context,
d585 1
d591 1
a591 1
    if (!(block->blocks = (short *)malloc(num_blocks << 6 * sizeof(short))))
d604 1
a604 1
Status XvMCDestroyBlocks(Display *display, XvMCBlockArray *block)
d606 1
d624 1
a624 1
Status XvMCCreateMacroBlocks(Display *display, XvMCContext *context,
d647 1
a647 1
Status XvMCDestroyMacroBlocks(Display *display, XvMCMacroBlockArray *block)
d669 1
a669 1
Status XvMCRenderSurface(Display *display, XvMCContext *context,
d730 1
a730 1
Status XvMCPutSurface(Display *display,XvMCSurface *surface,
a758 1

a765 1

a768 1

d778 1
a778 1
Status XvMCSyncSurface(Display *display, XvMCSurface *surface)
d803 1
a803 1
Status XvMCFlushSurface(Display * display, XvMCSurface *surface)
d822 1
a822 1
Status XvMCGetSurfaceStatus(Display *display, XvMCSurface *surface, int *stat)
d847 1
a847 1
Status XvMCHideSurface(Display *display, XvMCSurface *surface)
d886 1
a886 1
Status XvMCCreateSubpicture(Display *display, XvMCContext *context,
d907 1
a907 1
Status XvMCClearSubpicture(Display *display, XvMCSubpicture *subpicture,
d931 1
a931 1
Status XvMCCompositeSubpicture(Display *display, XvMCSubpicture *subpicture,
d951 1
a951 1
Status XvMCDestroySubpicture(Display *display, XvMCSubpicture *subpicture)
d968 1
a968 1
Status XvMCSetSubpicturePalette(Display *display, XvMCSubpicture *subpicture,
d998 1
a998 1
Status XvMCBlendSubpicture(Display *display, XvMCSurface *target_surface,
d1035 1
a1035 1
Status XvMCBlendSubpicture2(Display *display,
d1058 1
a1058 1
Status XvMCSyncSubpicture(Display *display, XvMCSubpicture *subpicture)
d1075 1
a1075 1
Status XvMCFlushSubpicture(Display *display, XvMCSubpicture *subpicture)
d1095 1
a1095 1
Status XvMCGetSubpictureStatus(Display *display, XvMCSubpicture *subpicture,
d1116 1
a1116 1
XvAttribute *XvMCQueryAttributes(Display *display, XvMCContext *context,
d1137 1
a1137 1
Status XvMCSetAttribute(Display *display, XvMCContext *context,
d1157 1
a1157 1
Status XvMCGetAttribute(Display *display, XvMCContext *context,
@


1.2
log
@update to xf86-video-intel 2.3.2. Tested among others by okan@@.
@
text
@d29 1
d31 72
d106 6
d293 2
d444 2
d461 1
a461 1
    int screen = DefaultScreen(display);
d465 1
a465 1

d493 2
d682 4
@


1.1
log
@Update to xf86-video-intel 2.3.1. Tested by many.
@
text
@d516 1
a516 1
    if (!display || block)
@

