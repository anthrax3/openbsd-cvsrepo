head	1.10;
access;
symbols
	OPENBSD_5_0:1.9.0.6
	OPENBSD_5_0_BASE:1.9
	OPENBSD_4_9:1.9.0.2
	OPENBSD_4_9_BASE:1.9
	OPENBSD_4_8:1.9.0.4
	OPENBSD_4_8_BASE:1.9
	OPENBSD_4_7:1.7.0.4
	OPENBSD_4_7_BASE:1.7
	OPENBSD_4_6:1.7.0.2
	OPENBSD_4_6_BASE:1.7
	OPENBSD_4_5:1.6.0.4
	OPENBSD_4_5_BASE:1.6
	OPENBSD_4_4:1.6.0.2
	OPENBSD_4_4_BASE:1.6
	OPENBSD_4_3_BASE:1.4
	OPENBSD_4_3:1.4.0.2
	v2_2_0_90:1.1.1.2
	v2_2_0:1.1.1.2
	OPENBSD_4_2:1.2.0.2
	OPENBSD_4_2_BASE:1.2
	v1_7_4:1.1.1.1
	v1_7_3:1.1.1.1
	v1_7_2:1.1.1.1
	xorg:1.1.1;
locks; strict;
comment	@ * @;


1.10
date	2011.11.29.12.39.02;	author oga;	state dead;
branches;
next	1.9;

1.9
date	2010.07.18.14.47.47;	author oga;	state Exp;
branches;
next	1.8;

1.8
date	2010.05.10.22.32.29;	author oga;	state Exp;
branches;
next	1.7;

1.7
date	2009.06.25.20.16.43;	author matthieu;	state Exp;
branches;
next	1.6;

1.6
date	2008.06.29.20.13.42;	author matthieu;	state Exp;
branches;
next	1.5;

1.5
date	2008.05.21.20.19.51;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2007.11.25.18.44.17;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2007.11.24.20.08.18;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2007.08.04.19.55.21;	author reyk;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.26.20.06.46;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.11.26.20.06.46;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2007.11.24.19.44.45;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.10
log
@Update the intel driver to a more recent version based on more recent
upsteam code.

Backporting keeping UMS changes by me, some bugfixes from kettenis@@.

Has been in snapshots for a while, committed on request so we can be
sure what people are running. This is a prerequesite for sandybridge
support but has those chipsets disabled for now until the correct code
has been added.
@
text
@/**************************************************************************

Copyright 1998-1999 Precision Insight, Inc., Cedar Park, Texas.
All Rights Reserved.

Permission is hereby granted, free of charge, to any person obtaining a
copy of this software and associated documentation files (the
"Software"), to deal in the Software without restriction, including
without limitation the rights to use, copy, modify, merge, publish,
distribute, sub license, and/or sell copies of the Software, and to
permit persons to whom the Software is furnished to do so, subject to
the following conditions:

The above copyright notice and this permission notice (including the
next paragraph) shall be included in all copies or substantial portions
of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT.
IN NO EVENT SHALL PRECISION INSIGHT AND/OR ITS SUPPLIERS BE LIABLE FOR
ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

**************************************************************************/

/*
 * Authors:
 *   Keith Whitwell <keith@@tungstengraphics.com>
 *
 */

/*
 * XXX So far, for GXxor this is about 40% of the speed of SW, but CPU
 * utilisation falls from 95% to < 5%.
 */

#ifdef HAVE_CONFIG_H
#include "config.h"
#endif

#include "xf86.h"
#include "i830.h"
#include "i810_reg.h"
#include "i830_ring.h"
#include "i915_drm.h"

unsigned long intel_get_pixmap_pitch(PixmapPtr pixmap)
{
	return (unsigned long)pixmap->devKind;
}

void i830_debug_flush(ScrnInfoPtr scrn)
{
	intel_screen_private *intel = intel_get_screen_private(scrn);

	if (intel->debug_flush & DEBUG_FLUSH_CACHES)
		intel_batch_emit_flush(scrn);

	if (intel->debug_flush & DEBUG_FLUSH_BATCHES)
		intel_batch_submit(scrn, FALSE);
}

/* The following function sets up the supported acceleration. Call it
 * from the FbInit() function in the SVGA driver, or before ScreenInit
 * in a monolithic server.
 */
Bool I830AccelInit(ScreenPtr screen)
{
	ScrnInfoPtr scrn = xf86Screens[screen->myNum];
	intel_screen_private *intel = intel_get_screen_private(scrn);

	/* Limits are described in the BLT engine chapter under Graphics Data Size
	 * Limitations, and the descriptions of SURFACE_STATE, 3DSTATE_BUFFER_INFO,
	 * 3DSTATE_DRAWING_RECTANGLE, 3DSTATE_MAP_INFO, and 3DSTATE_MAP_INFO.
	 *
	 * i845 through i965 limits 2D rendering to 65536 lines and pitch of 32768.
	 *
	 * i965 limits 3D surface to (2*element size)-aligned offset if un-tiled.
	 * i965 limits 3D surface to 4kB-aligned offset if tiled.
	 * i965 limits 3D surfaces to w,h of ?,8192.
	 * i965 limits 3D surface to pitch of 1B - 128kB.
	 * i965 limits 3D surface pitch alignment to 1 or 2 times the element size.
	 * i965 limits 3D surface pitch alignment to 512B if tiled.
	 * i965 limits 3D destination drawing rect to w,h of 8192,8192.
	 *
	 * i915 limits 3D textures to 4B-aligned offset if un-tiled.
	 * i915 limits 3D textures to ~4kB-aligned offset if tiled.
	 * i915 limits 3D textures to width,height of 2048,2048.
	 * i915 limits 3D textures to pitch of 16B - 8kB, in dwords.
	 * i915 limits 3D destination to ~4kB-aligned offset if tiled.
	 * i915 limits 3D destination to pitch of 16B - 8kB, in dwords, if un-tiled.
	 * i915 limits 3D destination to pitch 64B-aligned if used with depth.
	 * i915 limits 3D destination to pitch of 512B - 8kB, in tiles, if tiled.
	 * i915 limits 3D destination to POT aligned pitch if tiled.
	 * i915 limits 3D destination drawing rect to w,h of 2048,2048.
	 *
	 * i845 limits 3D textures to 4B-aligned offset if un-tiled.
	 * i845 limits 3D textures to ~4kB-aligned offset if tiled.
	 * i845 limits 3D textures to width,height of 2048,2048.
	 * i845 limits 3D textures to pitch of 4B - 8kB, in dwords.
	 * i845 limits 3D destination to 4B-aligned offset if un-tiled.
	 * i845 limits 3D destination to ~4kB-aligned offset if tiled.
	 * i845 limits 3D destination to pitch of 8B - 8kB, in dwords.
	 * i845 limits 3D destination drawing rect to w,h of 2048,2048.
	 *
	 * For the tiled issues, the only tiled buffer we draw to should be
	 * the front, which will have an appropriate pitch/offset already set up,
	 * so UXA doesn't need to worry.
	 */
	if (IS_I965G(intel)) {
		intel->accel_pixmap_offset_alignment = 4 * 2;
		intel->accel_pixmap_pitch_alignment = 64;
		intel->accel_max_x = 8192;
		intel->accel_max_y = 8192;
	} else {
		intel->accel_pixmap_offset_alignment = 4;
		intel->accel_pixmap_pitch_alignment = 64;
		intel->accel_max_x = 2048;
		intel->accel_max_y = 2048;
	}

	return i830_uxa_init(screen);
}
@


1.9
log
@Update the intel driver to (mostly) a backport of 2.12.

It is missing a few commits that I have yet to verify (ones that try and
continue if we lock the gpu rendering engine and can't reset it, for
example) taht will be verified and sent out for extra testing soon.

Should contain a bunch of speedups and some correctness improvements
(though rendercheck still gives some errors that I am looking into).

This has been in snaps since the first day of c2k10, any known issues
with just this driver have (to my knowledge) been fixed since. A problem
with macbooks pointed out by otto happens with both this and the in-tree
driver and thus doesn't stop this moving forward.

As well as the 2.12 improvements, this driver also has a backport
(partially aided by the backports in RHEL 5 kindly provided by Dave
Airlie) from the kms code of modesetting support for ironlake (arrandale
and clarkdale: the IGDs build into intel nehalem cpu dies) which has
been tested on a number of chipsets. Note that Display port and eDP
displays have not yet been worked on (and probably won't until I can
find a displayport monitor), but VGA and lvds at least are known to
work, sure beats vesa.

"no objection on my side" matthieu@@, prodding (as always) from princess
marco.
@
text
@@


1.8
log
@Update the intel driver to 2.9.1 plus backports.

2.9.1 is the last version of the intel DDX that supports UMS (User
modesetting), with 2.10 onwards being purely KMS only. As such, this
driver contains backports of almost every correctness or performance
related fix to the rendering layer in later intel drivers. This driver
*REQUIRES* a GEM enabled kernel. it claims to support non-gem mode but
this is essentially unmaintained and due to the way the abstraciton
works is slow, if it works at all (it often does not). You have been
warned.

tested by many many people on tech over the last few weeks.
@
text
@a48 10
unsigned long intel_get_pixmap_offset(PixmapPtr pixmap)
{
	ScreenPtr pScreen = pixmap->drawable.pScreen;
	ScrnInfoPtr scrn = xf86Screens[pScreen->myNum];
	intel_screen_private *intel = intel_get_screen_private(scrn);

	return (unsigned long)pixmap->devPrivate.ptr -
	    (unsigned long)intel->FbBase;
}

a53 59
int
I830WaitLpRing(ScrnInfoPtr scrn, int n, int timeout_millis)
{
   intel_screen_private *intel = intel_get_screen_private(scrn);
   I830RingBuffer *ring = &intel->ring;
   int iters = 0;
   unsigned int start = 0;
   unsigned int now = 0;
   int last_head = 0;
   unsigned int first = 0;

   /* If your system hasn't moved the head pointer in 2 seconds, I'm going to
    * call it crashed.
    */
   if (timeout_millis == 0)
      timeout_millis = 2000;

   if (I810_DEBUG & DEBUG_VERBOSE_ACCEL) {
      ErrorF("I830WaitLpRing %d\n", n);
      first = GetTimeInMillis();
   }

   while (ring->space < n) {
      ring->head = INREG(LP_RING + RING_HEAD) & I830_HEAD_MASK;
      ring->space = ring->head - (ring->tail + 8);

      if (ring->space < 0)
	 ring->space += ring->mem->size;

      iters++;
      now = GetTimeInMillis();
      if (start == 0 || now < start || ring->head != last_head) {
	 if (I810_DEBUG & DEBUG_VERBOSE_ACCEL)
	    if (now > start)
	       ErrorF("space: %d wanted %d\n", ring->space, n);
	 start = now;
	 last_head = ring->head;
      } else if (now - start > timeout_millis) {
	 ErrorF("Error in I830WaitLpRing(), timeout for %d seconds\n",
		timeout_millis/1000);
	 ErrorF("space: %d wanted %d\n", ring->space, n);
	 intel->uxa_driver = NULL;
	 FatalError("lockup\n");
      }

      DELAY(10);
   }

   if (I810_DEBUG & DEBUG_VERBOSE_ACCEL) {
      now = GetTimeInMillis();
      if (now - first) {
	 ErrorF("Elapsed %u ms\n", now - first);
	 ErrorF("space: %d wanted %d\n", ring->space, n);
      }
   }

   return iters;
}

d62 1
a62 1
		intel_batch_submit(scrn);
@


1.7
log
@update to xf86-video-intel 2.7.1. Tested by many.
@
text
@a0 9
/*
 * XXX So far, for GXxor this is about 40% of the speed of SW, but CPU
 * utilisation falls from 95% to < 5%.
 */

#ifdef HAVE_CONFIG_H
#include "config.h"
#endif

a26 1
/* $XFree86: xc/programs/Xserver/hw/xfree86/drivers/i810/i830_accel.c,v 1.8 2003/04/24 18:00:24 eich Exp $ */
d29 2
a30 1
 * Reformatted with GNU indent (2.2.8), using the following options:
a31 8
 *    -bad -bap -c41 -cd0 -ncdb -ci6 -cli0 -cp0 -ncs -d0 -di3 -i3 -ip3 -l78
 *    -lp -npcs -psl -sob -ss -br -ce -sc -hnl
 *
 * This provides a good match with the original i810 code and preferred
 * XFree86 formatting conventions.
 *
 * When editing this driver, please follow the existing formatting, and edit
 * with <TAB> characters expanded at 8-column intervals.
d35 2
a36 3
 * Authors:
 *   Keith Whitwell <keith@@tungstengraphics.com>
 *
d39 3
a41 1
#include <errno.h>
a43 1
#include "xaarop.h"
a45 1
#include "i830_debug.h"
d49 1
a49 2
unsigned long
intel_get_pixmap_offset(PixmapPtr pPix)
d51 3
a53 4
#if defined(I830_USE_EXA) || defined(I830_USE_UXA)
    ScreenPtr pScreen = pPix->drawable.pScreen;
    ScrnInfoPtr pScrn = xf86Screens[pScreen->myNum];
    I830Ptr pI830 = I830PTR(pScrn);
d55 2
a56 4
    if (pI830->accel == ACCEL_EXA)
	return exaGetPixmapOffset(pPix);
#endif
    return (unsigned long)pPix->devPrivate.ptr - (unsigned long)pI830->FbBase;
d59 1
a59 2
unsigned long
intel_get_pixmap_pitch(PixmapPtr pPix)
d61 1
a61 9
#ifdef I830_USE_EXA
    ScreenPtr pScreen = pPix->drawable.pScreen;
    ScrnInfoPtr pScrn = xf86Screens[pScreen->myNum];
    I830Ptr pI830 = I830PTR(pScrn);

    if (pI830->accel == ACCEL_EXA)
	return exaGetPixmapPitch(pPix);
#endif
    return (unsigned long)pPix->devKind;
d65 1
a65 1
I830WaitLpRing(ScrnInfoPtr pScrn, int n, int timeout_millis)
d67 2
a68 2
   I830Ptr pI830 = I830PTR(pScrn);
   I830RingBuffer *ring = &pI830->ring;
a103 4
	 if (IS_I965G(pI830))
	     i965_dump_error_state(pScrn);
	 else
	     i830_dump_error_state(pScrn);
d105 1
a105 15
#ifdef XF86DRI
	 if (pI830->directRenderingType == DRI_XF86DRI) {
	    DRIUnlock(screenInfo.screens[pScrn->scrnIndex]);
	    DRICloseScreen(screenInfo.screens[pScrn->scrnIndex]);
	 }
#endif
#ifdef I830_USE_XAA
	 pI830->AccelInfoRec = NULL;	/* Stops recursive behavior */
#endif
#ifdef I830_USE_EXA
	 pI830->EXADriverPtr = NULL;
#endif
#ifdef I830_USE_UXA
	pI830->uxa_driver = NULL;
#endif
d123 1
a123 2
void
I830Sync(ScrnInfoPtr pScrn)
d125 1
a125 15
   I830Ptr pI830 = I830PTR(pScrn);

   if (I810_DEBUG & (DEBUG_VERBOSE_ACCEL | DEBUG_VERBOSE_SYNC))
      ErrorF("I830Sync\n");

   if (pI830->accel == ACCEL_NONE)
       return;

#ifdef XF86DRI
   /* VT switching tries to do this.
    */
   if (!pI830->LockHeld && pI830->directRenderingType == DRI_XF86DRI) {
      return;
   }
#endif
d127 2
a128 1
   I830EmitFlush(pScrn);
d130 2
a131 79
   intel_batch_flush(pScrn, TRUE);

   if (pI830->directRenderingType > DRI_NONE) {
       struct drm_i915_irq_emit emit;
       struct drm_i915_irq_wait wait;
       int ret;

       /* Most of the uses of I830Sync while using GEM should actually be
	* using set_domain on a specific buffer.  We're not there yet, so fake
	* it up using irq_emit/wait.  It's still better than spinning on
	* register reads for idle.
	*/
       emit.irq_seq = &wait.irq_seq;
       ret = drmCommandWriteRead(pI830->drmSubFD, DRM_I830_IRQ_EMIT, &emit,
			    sizeof(emit));
       if (ret != 0)
	   FatalError("Failure to emit IRQ: %s\n", strerror(-ret));

       do {
	   ret = drmCommandWrite(pI830->drmSubFD, DRM_I830_IRQ_WAIT, &wait,
				 sizeof(wait));
       } while (ret == -EINTR);

       if (ret != 0)
	   FatalError("Failure to wait for IRQ: %s\n", strerror(-ret));

       if (!pI830->memory_manager)
	   i830_refresh_ring(pScrn);
   } else if (!pI830->use_drm_mode) {
       i830_wait_ring_idle(pScrn);
   }

   pI830->nextColorExpandBuf = 0;
}

void
I830EmitFlush(ScrnInfoPtr pScrn)
{
   I830Ptr pI830 = I830PTR(pScrn);
   int flags = MI_WRITE_DIRTY_STATE | MI_INVALIDATE_MAP_CACHE;

   if (IS_I965G(pI830))
      flags = 0;

   {
       BEGIN_BATCH(1);
       OUT_BATCH(MI_FLUSH | flags);
       ADVANCE_BATCH();
   }
}

Bool
I830SelectBuffer(ScrnInfoPtr pScrn, int buffer)
{
   I830Ptr pI830 = I830PTR(pScrn);

   switch (buffer) {
#ifdef XF86DRI
   case I830_SELECT_BACK:
      pI830->bufferOffset = pI830->back_buffer->offset;
      if (pI830->back_buffer->tiling == TILE_YMAJOR)
	 return FALSE;
      break;
   case I830_SELECT_DEPTH:
      pI830->bufferOffset = pI830->depth_buffer->offset;
      if (pI830->depth_buffer->tiling == TILE_YMAJOR)
	 return FALSE;
      break;
#endif
   default:
   case I830_SELECT_FRONT:
      pI830->bufferOffset = pScrn->fbOffset;
      break;
   }

   if (I810_DEBUG & DEBUG_VERBOSE_ACCEL)
      ErrorF("I830SelectBuffer %d --> offset %x\n",
	     buffer, pI830->bufferOffset);
   return TRUE;
d138 1
a138 2
Bool
I830AccelInit(ScreenPtr pScreen)
d140 52
a191 2
    ScrnInfoPtr pScrn = xf86Screens[pScreen->myNum];
    I830Ptr pI830 = I830PTR(pScrn);
d193 1
a193 75
    /* Limits are described in the BLT engine chapter under Graphics Data Size
     * Limitations, and the descriptions of SURFACE_STATE, 3DSTATE_BUFFER_INFO,
     * 3DSTATE_DRAWING_RECTANGLE, 3DSTATE_MAP_INFO, and 3DSTATE_MAP_INFO.
     *
     * i845 through i965 limits 2D rendering to 65536 lines and pitch of 32768.
     *
     * i965 limits 3D surface to (2*element size)-aligned offset if un-tiled.
     * i965 limits 3D surface to 4kB-aligned offset if tiled.
     * i965 limits 3D surfaces to w,h of ?,8192.
     * i965 limits 3D surface to pitch of 1B - 128kB.
     * i965 limits 3D surface pitch alignment to 1 or 2 times the element size.
     * i965 limits 3D surface pitch alignment to 512B if tiled.
     * i965 limits 3D destination drawing rect to w,h of 8192,8192.
     *
     * i915 limits 3D textures to 4B-aligned offset if un-tiled.
     * i915 limits 3D textures to ~4kB-aligned offset if tiled.
     * i915 limits 3D textures to width,height of 2048,2048.
     * i915 limits 3D textures to pitch of 16B - 8kB, in dwords.
     * i915 limits 3D destination to ~4kB-aligned offset if tiled.
     * i915 limits 3D destination to pitch of 16B - 8kB, in dwords, if un-tiled.
     * i915 limits 3D destination to pitch 64B-aligned if used with depth.
     * i915 limits 3D destination to pitch of 512B - 8kB, in tiles, if tiled.
     * i915 limits 3D destination to POT aligned pitch if tiled.
     * i915 limits 3D destination drawing rect to w,h of 2048,2048.
     *
     * i845 limits 3D textures to 4B-aligned offset if un-tiled.
     * i845 limits 3D textures to ~4kB-aligned offset if tiled.
     * i845 limits 3D textures to width,height of 2048,2048.
     * i845 limits 3D textures to pitch of 4B - 8kB, in dwords.
     * i845 limits 3D destination to 4B-aligned offset if un-tiled.
     * i845 limits 3D destination to ~4kB-aligned offset if tiled.
     * i845 limits 3D destination to pitch of 8B - 8kB, in dwords.
     * i845 limits 3D destination drawing rect to w,h of 2048,2048.
     *
     * For the tiled issues, the only tiled buffer we draw to should be
     * the front, which will have an appropriate pitch/offset already set up,
     * so EXA doesn't need to worry.
     */
    if (IS_I965G(pI830)) {
	pI830->accel_pixmap_offset_alignment = 4 * 2;
	pI830->accel_pixmap_pitch_alignment = 64;
	pI830->accel_max_x = 8192;
	pI830->accel_max_y = 8192;
    } else {
	pI830->accel_pixmap_offset_alignment = 4;
	pI830->accel_pixmap_pitch_alignment = 64;
	pI830->accel_max_x = 2048;
	pI830->accel_max_y = 2048;
    }
    /* Bump the pitch so that we can tile any pixmap we create. */
    if (pI830->directRenderingType >= DRI_DRI2)
	pI830->accel_pixmap_pitch_alignment = 512;

    switch (pI830->accel) {
    case ACCEL_UXA:
#ifdef I830_USE_UXA
	return i830_uxa_init(pScreen);
#else
	xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
		   "UXA not built in, falling back to EXA.\n");
	return I830EXAInit(pScreen);
#endif
#ifdef I830_USE_EXA
    case ACCEL_EXA:
	return I830EXAInit(pScreen);
#endif
#ifdef I830_USE_XAA
    case ACCEL_XAA:
	return I830XAAInit(pScreen);
#endif
    case ACCEL_UNINIT:
    case ACCEL_NONE:
	break;
    }
    return FALSE;
@


1.6
log
@update to xf86-video-intel 2.3.2. Tested among others by okan@@.
@
text
@d57 2
d64 2
d70 1
d75 1
a75 2
#ifdef I830_USE_EXA
    if (pI830->useEXA)
d84 1
d89 1
a89 2
#ifdef I830_USE_EXA
    if (pI830->useEXA)
a91 1
#ifdef I830_USE_XAA
a92 1
#endif
d99 1
a99 1
   I830RingBuffer *ring = pI830->LpRing;
d141 1
a141 1
	 if (pI830->directRenderingEnabled) {
d152 3
a175 1
   int flags = MI_WRITE_DIRTY_STATE | MI_INVALIDATE_MAP_CACHE;
d180 1
a180 1
   if (pI830->noAccel)
d186 1
a186 1
   if (!pI830->LockHeld && pI830->directRenderingEnabled) {
d191 1
a191 1
   if (pI830->entityPrivate && !pI830->entityPrivate->RingRunning) return;
d193 1
a193 2
   if (IS_I965G(pI830))
      flags = 0;
d195 28
a222 10
   /* Send a flush instruction and then wait till the ring is empty.
    * This is stronger than waiting for the blitter to finish as it also
    * flushes the internal graphics caches.
    */
   
   {
      BEGIN_BATCH(2);
      OUT_BATCH(MI_FLUSH | flags);
      OUT_BATCH(MI_NOOP);		/* pad to quadword */
      ADVANCE_BATCH();
a224 3
   i830_wait_ring_idle(pScrn);

   pI830->LpRing->space = pI830->LpRing->mem->size - 8;
d238 1
a238 1
       BEGIN_BATCH(2);
a239 1
       OUT_BATCH(MI_NOOP);		/* pad to quadword */
d244 1
a244 1
void
d253 2
a254 3
      break;
   case I830_SELECT_THIRD:
      pI830->bufferOffset = pI830->third_buffer->offset;
d258 2
d271 1
a280 1
#ifdef I830_USE_EXA
d284 64
a347 1
    if (pI830->useEXA)
d351 2
a352 1
    return I830XAAInit(pScreen);
d354 4
@


1.5
log
@Update to xf86-video-intel 2.3.1. Tested by many.
@
text
@d204 1
a204 1
   I830WaitLpRing(pScrn, pI830->LpRing->mem->size - 8, 0);
@


1.4
log
@- disable dri support explicitely for now.
- fix some merge botches. Long live CVS.
@
text
@d176 3
d198 4
a201 4
      BEGIN_LP_RING(2);
      OUT_RING(MI_FLUSH | flags);
      OUT_RING(MI_NOOP);		/* pad to quadword */
      ADVANCE_LP_RING();
d220 4
a223 4
       BEGIN_LP_RING(2);
       OUT_RING(MI_FLUSH | flags);
       OUT_RING(MI_NOOP);		/* pad to quadword */
       ADVANCE_LP_RING();
@


1.3
log
@merge xf86-video-intel 2.2.0
@
text
@d186 1
a186 1
   if (IS_I96X(pI830))
d213 1
a213 1
   if (IS_I96X(pI830))
@


1.2
log
@Add support for the mobile i965GM chipset.

tested by many
ok matthieu@@
@
text
@a9 4
#ifndef DO_SCANLINE_IMAGE_WRITE
#define DO_SCANLINE_IMAGE_WRITE 0
#endif

d61 31
d99 2
a100 2
   int start = 0;
   int now = 0;
d102 1
a102 1
   int first = 0;
d120 1
a120 1
	 ring->space += ring->mem.Size;
d131 6
a136 3
	 ErrorF("Error in I830WaitLpRing(), now is %d, start is %d\n", now,
		start);
	 I830PrintErrorState(pScrn);
d144 1
d146 4
d159 1
a159 1
	 ErrorF("Elapsed %d ms\n", now - first);
d201 1
a201 1
   I830WaitLpRing(pScrn, pI830->LpRing->mem.Size - 8, 0);
d203 1
a203 1
   pI830->LpRing->space = pI830->LpRing->mem.Size - 8;
d216 6
a221 4
   BEGIN_LP_RING(2);
   OUT_RING(MI_FLUSH | flags);
   OUT_RING(MI_NOOP);		/* pad to quadword */
   ADVANCE_LP_RING();
d232 4
a235 1
      pI830->bufferOffset = pI830->BackBuffer.Start;
d238 1
a238 1
      pI830->bufferOffset = pI830->DepthBuffer.Start;
a251 51
void
I830RefreshRing(ScrnInfoPtr pScrn)
{
   I830Ptr pI830 = I830PTR(pScrn);

   pI830->LpRing->head = INREG(LP_RING + RING_HEAD) & I830_HEAD_MASK;
   pI830->LpRing->tail = INREG(LP_RING + RING_TAIL);
   pI830->LpRing->space = pI830->LpRing->head - (pI830->LpRing->tail + 8);
   if (pI830->LpRing->space < 0)
      pI830->LpRing->space += pI830->LpRing->mem.Size;

   if (pI830->AccelInfoRec)
      pI830->AccelInfoRec->NeedToSync = TRUE;
}

/* I830 Accel Functions */

static void I830SetupForMono8x8PatternFill(ScrnInfoPtr pScrn,
					   int pattx, int patty,
					   int fg, int bg, int rop,
					   unsigned int planemask);
static void I830SubsequentMono8x8PatternFillRect(ScrnInfoPtr pScrn,
						 int pattx, int patty,
						 int x, int y, int w, int h);

static void I830SetupForScanlineCPUToScreenColorExpandFill(ScrnInfoPtr pScrn,
							   int fg, int bg,
							   int rop,
							   unsigned int mask);

static void I830SubsequentScanlineCPUToScreenColorExpandFill(ScrnInfoPtr
							     pScrn, int x,
							     int y, int w,
							     int h,
							     int skipleft);

static void I830SubsequentColorExpandScanline(ScrnInfoPtr pScrn, int bufno);

#if DO_SCANLINE_IMAGE_WRITE
static void I830SetupForScanlineImageWrite(ScrnInfoPtr pScrn, int rop,
					   unsigned int planemask,
					   int trans_color, int bpp,
					   int depth);
static void I830SubsequentScanlineImageWriteRect(ScrnInfoPtr pScrn,
						 int x, int y, int w, int h,
						 int skipleft);
static void I830SubsequentImageWriteScanline(ScrnInfoPtr pScrn, int bufno);
#endif
static void I830RestoreAccelState(ScrnInfoPtr pScrn);


d259 3
a261 14
   XAAInfoRecPtr infoPtr;
   ScrnInfoPtr pScrn = xf86Screens[pScreen->myNum];
   I830Ptr pI830 = I830PTR(pScrn);
   int i;
   int width = 0;
   int nr_buffers = 0;
   unsigned char *ptr = NULL;

   if (I810_DEBUG & DEBUG_VERBOSE_ACCEL)
      ErrorF("I830AccelInit\n");

   pI830->AccelInfoRec = infoPtr = XAACreateInfoRec();
   if (!infoPtr)
      return FALSE;
d263 2
a264 93
   pI830->bufferOffset = 0;
   infoPtr->Flags = LINEAR_FRAMEBUFFER | OFFSCREEN_PIXMAPS | PIXMAP_CACHE;

   /* Use the same sync function as the I830.
    */
   infoPtr->Sync = I830Sync;

   /* Everything else is different enough to justify different functions */
   {
      infoPtr->SolidFillFlags = NO_PLANEMASK;
      infoPtr->SetupForSolidFill = I830SetupForSolidFill;
      infoPtr->SubsequentSolidFillRect = I830SubsequentSolidFillRect;
   }

   {
      infoPtr->ScreenToScreenCopyFlags = (NO_PLANEMASK | NO_TRANSPARENCY);

      infoPtr->SetupForScreenToScreenCopy = I830SetupForScreenToScreenCopy;
      infoPtr->SubsequentScreenToScreenCopy =
	    I830SubsequentScreenToScreenCopy;
   }

   {
      infoPtr->SetupForMono8x8PatternFill = I830SetupForMono8x8PatternFill;
      infoPtr->SubsequentMono8x8PatternFillRect =
	    I830SubsequentMono8x8PatternFillRect;

      infoPtr->Mono8x8PatternFillFlags = (HARDWARE_PATTERN_PROGRAMMED_BITS |
					  HARDWARE_PATTERN_SCREEN_ORIGIN |
					  HARDWARE_PATTERN_PROGRAMMED_ORIGIN |
					  BIT_ORDER_IN_BYTE_MSBFIRST |
					  NO_PLANEMASK);

   }

   /* On the primary screen */
   if (pI830->init == 0) {
      if (pI830->Scratch.Size != 0) {
         width = ((pScrn->displayWidth + 31) & ~31) / 8;
         nr_buffers = pI830->Scratch.Size / width;
         ptr = pI830->FbBase + pI830->Scratch.Start;
      }
   } else {
   /* On the secondary screen */
      I830Ptr pI8301 = I830PTR(pI830->entityPrivate->pScrn_1);
      if (pI8301->Scratch2.Size != 0) {
         width = ((pScrn->displayWidth + 31) & ~31) / 8;
         nr_buffers = pI8301->Scratch2.Size / width;
         /* We have to use the primary screen's FbBase, as that's where
          * we allocated Scratch2, so we get the correct pointer */
         ptr = pI8301->FbBase + pI8301->Scratch2.Start;
      }
   }

   if (nr_buffers) {
      pI830->NumScanlineColorExpandBuffers = nr_buffers;
      pI830->ScanlineColorExpandBuffers = (unsigned char **)
	    xnfcalloc(nr_buffers, sizeof(unsigned char *));

      for (i = 0; i < nr_buffers; i++, ptr += width)
	 pI830->ScanlineColorExpandBuffers[i] = ptr;

      infoPtr->ScanlineCPUToScreenColorExpandFillFlags =
	    (NO_PLANEMASK | ROP_NEEDS_SOURCE | BIT_ORDER_IN_BYTE_MSBFIRST);

      infoPtr->ScanlineColorExpandBuffers = (unsigned char **)
	    xnfcalloc(1, sizeof(unsigned char *));
      infoPtr->NumScanlineColorExpandBuffers = 1;

      infoPtr->ScanlineColorExpandBuffers[0] =
	    pI830->ScanlineColorExpandBuffers[0];
      pI830->nextColorExpandBuf = 0;

      infoPtr->SetupForScanlineCPUToScreenColorExpandFill =
	    I830SetupForScanlineCPUToScreenColorExpandFill;

      infoPtr->SubsequentScanlineCPUToScreenColorExpandFill =
	    I830SubsequentScanlineCPUToScreenColorExpandFill;

      infoPtr->SubsequentColorExpandScanline =
	    I830SubsequentColorExpandScanline;

#if DO_SCANLINE_IMAGE_WRITE
      infoPtr->NumScanlineImageWriteBuffers = 1;
      infoPtr->ScanlineImageWriteBuffers = infoPtr->ScanlineColorExpandBuffers;
      infoPtr->SetupForScanlineImageWrite = I830SetupForScanlineImageWrite;
      infoPtr->SubsequentScanlineImageWriteRect =
	    I830SubsequentScanlineImageWriteRect;
      infoPtr->SubsequentImageWriteScanline = I830SubsequentImageWriteScanline;
      infoPtr->ScanlineImageWriteFlags = NO_GXCOPY |
					 NO_PLANEMASK |
					 ROP_NEEDS_SOURCE |
					 SCANLINE_PAD_DWORD;
d266 2
a267 483
   }

   {
      Bool shared_accel = FALSE;
      int i;

      for(i = 0; i < pScrn->numEntities; i++) {
         if(xf86IsEntityShared(pScrn->entityList[i]))
            shared_accel = TRUE;
      }
      if(shared_accel == TRUE)
         infoPtr->RestoreAccelState = I830RestoreAccelState;
   }

   I830SelectBuffer(pScrn, I830_SELECT_FRONT);

   return XAAInit(pScreen, infoPtr);
}

#ifdef XF86DRI
static unsigned int
CheckTiling(ScrnInfoPtr pScrn)
{
   I830Ptr pI830 = I830PTR(pScrn);
   unsigned int tiled = 0;

    /* Check tiling */
   if (IS_I96X(pI830)) {
      if (pI830->bufferOffset == pScrn->fbOffset && pI830->front_tiled == FENCE_XMAJOR)
         tiled = 1;
      if (pI830->bufferOffset == pI830->RotatedMem.Start && pI830->rotated_tiled == FENCE_XMAJOR)
         tiled = 1;
      if (pI830->bufferOffset == pI830->BackBuffer.Start && pI830->back_tiled == FENCE_XMAJOR)
         tiled = 1;
      /* not really supported as it's always YMajor tiled */
      if (pI830->bufferOffset == pI830->DepthBuffer.Start && pI830->depth_tiled == FENCE_XMAJOR)
         tiled = 1;
   }

   return tiled;
}
#else
#define CheckTiling(pScrn) 0
#endif

void
I830SetupForSolidFill(ScrnInfoPtr pScrn, int color, int rop,
		      unsigned int planemask)
{
   I830Ptr pI830 = I830PTR(pScrn);

   if (I810_DEBUG & DEBUG_VERBOSE_ACCEL)
      ErrorF("I830SetupForFillRectSolid color: %x rop: %x mask: %x\n",
	     color, rop, planemask);

   pI830->BR[13] = ((XAAGetPatternROP(rop) << 16) |
		    (pScrn->displayWidth * pI830->cpp));

   pI830->BR[16] = color;

   switch (pScrn->bitsPerPixel) {
   case 8:
      break;
   case 16:
      pI830->BR[13] |= (1 << 24);
      break;
   case 32:
      pI830->BR[13] |= ((1 << 25) | (1 << 24));
      break;
   }
}

void
I830SubsequentSolidFillRect(ScrnInfoPtr pScrn, int x, int y, int w, int h)
{
   I830Ptr pI830 = I830PTR(pScrn);

   if (I810_DEBUG & DEBUG_VERBOSE_ACCEL)
      ErrorF("I830SubsequentFillRectSolid %d,%d %dx%d\n", x, y, w, h);

   {
      BEGIN_LP_RING(6);

      if (pScrn->bitsPerPixel == 32) {
	 OUT_RING(COLOR_BLT_CMD | COLOR_BLT_WRITE_ALPHA |
		  COLOR_BLT_WRITE_RGB);
      } else {
	 OUT_RING(COLOR_BLT_CMD);
      }
      OUT_RING(pI830->BR[13]);
      OUT_RING((h << 16) | (w * pI830->cpp));
      OUT_RING(pI830->bufferOffset + (y * pScrn->displayWidth + x) *
	       pI830->cpp);
      OUT_RING(pI830->BR[16]);
      OUT_RING(0);

      ADVANCE_LP_RING();
   }

   if (IS_I96X(pI830))
      I830EmitFlush(pScrn);
}

void
I830SetupForScreenToScreenCopy(ScrnInfoPtr pScrn, int xdir, int ydir, int rop,
			       unsigned int planemask, int transparency_color)
{
   I830Ptr pI830 = I830PTR(pScrn);

   if (I810_DEBUG & DEBUG_VERBOSE_ACCEL)
      ErrorF("I830SetupForScreenToScreenCopy %d %d %x %x %d\n",
	     xdir, ydir, rop, planemask, transparency_color);

   pI830->BR[13] = (pScrn->displayWidth * pI830->cpp);
   pI830->BR[13] |= XAAGetCopyROP(rop) << 16;

   switch (pScrn->bitsPerPixel) {
   case 8:
      break;
   case 16:
      pI830->BR[13] |= (1 << 24);
      break;
   case 32:
      pI830->BR[13] |= ((1 << 25) | (1 << 24));
      break;
   }

}

void
I830SubsequentScreenToScreenCopy(ScrnInfoPtr pScrn, int src_x1, int src_y1,
				 int dst_x1, int dst_y1, int w, int h)
{
   I830Ptr pI830 = I830PTR(pScrn);
   int dst_x2, dst_y2;
   unsigned int tiled = CheckTiling(pScrn);

   if (I810_DEBUG & DEBUG_VERBOSE_ACCEL)
      ErrorF("I830SubsequentScreenToScreenCopy %d,%d - %d,%d %dx%d\n",
	     src_x1, src_y1, dst_x1, dst_y1, w, h);

   dst_x2 = dst_x1 + w;
   dst_y2 = dst_y1 + h;

   if (tiled)
      pI830->BR[13] = ((pI830->BR[13] & 0xFFFF) >> 2) | 
					(pI830->BR[13] & 0xFFFF0000);

   {
      BEGIN_LP_RING(8);

      if (pScrn->bitsPerPixel == 32) {
	 OUT_RING(XY_SRC_COPY_BLT_CMD | XY_SRC_COPY_BLT_WRITE_ALPHA |
		  XY_SRC_COPY_BLT_WRITE_RGB | tiled << 15 | tiled << 11);
      } else {
	 OUT_RING(XY_SRC_COPY_BLT_CMD | tiled << 15 | tiled << 11);
      }
      OUT_RING(pI830->BR[13]);
      OUT_RING((dst_y1 << 16) | (dst_x1 & 0xffff));
      OUT_RING((dst_y2 << 16) | (dst_x2 & 0xffff));
      OUT_RING(pI830->bufferOffset);
      OUT_RING((src_y1 << 16) | (src_x1 & 0xffff));
      OUT_RING(pI830->BR[13] & 0xFFFF);
      OUT_RING(pI830->bufferOffset);

      ADVANCE_LP_RING();
   }

   if (IS_I96X(pI830))
      I830EmitFlush(pScrn);
}

static void
I830SetupForMono8x8PatternFill(ScrnInfoPtr pScrn, int pattx, int patty,
			       int fg, int bg, int rop,
			       unsigned int planemask)
{
   I830Ptr pI830 = I830PTR(pScrn);

   if (I810_DEBUG & DEBUG_VERBOSE_ACCEL)
      ErrorF("I830SetupForMono8x8PatternFill\n");

   pI830->BR[16] = pattx;
   pI830->BR[17] = patty;
   pI830->BR[18] = bg;
   pI830->BR[19] = fg;

   pI830->BR[13] = (pScrn->displayWidth * pI830->cpp);	/* In bytes */
   pI830->BR[13] |= XAAGetPatternROP(rop) << 16;
   if (bg == -1)
      pI830->BR[13] |= (1 << 28);

   switch (pScrn->bitsPerPixel) {
   case 8:
      break;
   case 16:
      pI830->BR[13] |= (1 << 24);
      break;
   case 32:
      pI830->BR[13] |= ((1 << 25) | (1 << 24));
      break;
   }

}

static void
I830SubsequentMono8x8PatternFillRect(ScrnInfoPtr pScrn, int pattx, int patty,
				     int x, int y, int w, int h)
{
   I830Ptr pI830 = I830PTR(pScrn);
   int x1, x2, y1, y2;
   unsigned int tiled = CheckTiling(pScrn);

   x1 = x;
   x2 = x + w;
   y1 = y;
   y2 = y + h;

   if (I810_DEBUG & DEBUG_VERBOSE_ACCEL)
      ErrorF("I830SubsequentMono8x8PatternFillRect\n");

   if (tiled)
      pI830->BR[13] = ((pI830->BR[13] & 0xFFFF) >> 2) | 
					(pI830->BR[13] & 0xFFFF0000);

   {
      BEGIN_LP_RING(10);

      if (pScrn->bitsPerPixel == 32) {
	 OUT_RING(XY_MONO_PAT_BLT_CMD | XY_MONO_PAT_BLT_WRITE_ALPHA |
		  XY_MONO_PAT_BLT_WRITE_RGB |
		  tiled << 11 |
		  ((patty << 8) & XY_MONO_PAT_VERT_SEED) |
		  ((pattx << 12) & XY_MONO_PAT_HORT_SEED));
      } else {
	 OUT_RING(XY_MONO_PAT_BLT_CMD |
		  tiled << 11 |
		  ((patty << 8) & XY_MONO_PAT_VERT_SEED) |
		  ((pattx << 12) & XY_MONO_PAT_HORT_SEED));
      }
      OUT_RING(pI830->BR[13]);
      OUT_RING((y1 << 16) | x1);
      OUT_RING((y2 << 16) | x2);
      OUT_RING(pI830->bufferOffset);
      OUT_RING(pI830->BR[18]);		/* bg */
      OUT_RING(pI830->BR[19]);		/* fg */
      OUT_RING(pI830->BR[16]);		/* pattern data */
      OUT_RING(pI830->BR[17]);
      OUT_RING(0);
      ADVANCE_LP_RING();
   }

   if (IS_I96X(pI830))
      I830EmitFlush(pScrn);
}

static void
I830GetNextScanlineColorExpandBuffer(ScrnInfoPtr pScrn)
{
   I830Ptr pI830 = I830PTR(pScrn);
   XAAInfoRecPtr infoPtr = pI830->AccelInfoRec;

   if (pI830->nextColorExpandBuf == pI830->NumScanlineColorExpandBuffers)
      I830Sync(pScrn);

   infoPtr->ScanlineColorExpandBuffers[0] =
	 pI830->ScanlineColorExpandBuffers[pI830->nextColorExpandBuf];

   if (I810_DEBUG & DEBUG_VERBOSE_ACCEL)
      ErrorF("using color expand buffer %d\n", pI830->nextColorExpandBuf);

   pI830->nextColorExpandBuf++;
}

static void
I830SetupForScanlineCPUToScreenColorExpandFill(ScrnInfoPtr pScrn,
					       int fg, int bg, int rop,
					       unsigned int planemask)
{
   I830Ptr pI830 = I830PTR(pScrn);

   if (I810_DEBUG & DEBUG_VERBOSE_ACCEL)
      ErrorF("I830SetupForScanlineScreenToScreenColorExpand %d %d %x %x\n",
	     fg, bg, rop, planemask);

   /* Fill out register values */
   pI830->BR[13] = (pScrn->displayWidth * pI830->cpp);
   pI830->BR[13] |= XAAGetCopyROP(rop) << 16;
   if (bg == -1)
      pI830->BR[13] |= (1 << 29);

   switch (pScrn->bitsPerPixel) {
   case 8:
      break;
   case 16:
      pI830->BR[13] |= (1 << 24);
      break;
   case 32:
      pI830->BR[13] |= ((1 << 25) | (1 << 24));
      break;
   }

   pI830->BR[18] = bg;
   pI830->BR[19] = fg;

   I830GetNextScanlineColorExpandBuffer(pScrn);
}

static void
I830SubsequentScanlineCPUToScreenColorExpandFill(ScrnInfoPtr pScrn,
						 int x, int y,
						 int w, int h, int skipleft)
{
   I830Ptr pI830 = I830PTR(pScrn);

   if (I810_DEBUG & DEBUG_VERBOSE_ACCEL)
      ErrorF("I830SubsequentScanlineCPUToScreenColorExpandFill "
	     "%d,%d %dx%x %d\n", x, y, w, h, skipleft);

   /* Fill out register values */
   pI830->BR[9] = (pI830->bufferOffset +
		   (y * pScrn->displayWidth + x) * pI830->cpp);
   pI830->BR[11] = ((1 << 16) | w);
}

static void
I830SubsequentColorExpandScanline(ScrnInfoPtr pScrn, int bufno)
{
   I830Ptr pI830 = I830PTR(pScrn);
   unsigned int tiled = CheckTiling(pScrn);

   if (pI830->init == 0) {
      pI830->BR[12] = (pI830->AccelInfoRec->ScanlineColorExpandBuffers[0] -
		       pI830->FbBase);
   } else {
      I830Ptr pI8301 = I830PTR(pI830->entityPrivate->pScrn_1);

      /* We have to use the primary screen's FbBase, as that's where
       * we allocated Scratch2, so we get the correct pointer */
      pI830->BR[12] = (pI830->AccelInfoRec->ScanlineColorExpandBuffers[0] -
		       pI8301->FbBase);
   }

   if (I810_DEBUG & DEBUG_VERBOSE_ACCEL)
      ErrorF("I830SubsequentColorExpandScanline %d (addr %x)\n",
	     bufno, pI830->BR[12]);

   if (tiled)
      pI830->BR[13] = ((pI830->BR[13] & 0xFFFF) >> 2) | 
					(pI830->BR[13] & 0xFFFF0000);

   {
      BEGIN_LP_RING(8);

      if (pScrn->bitsPerPixel == 32) {
	 OUT_RING(XY_MONO_SRC_BLT_CMD | XY_MONO_SRC_BLT_WRITE_ALPHA |
		  tiled << 11 |
		  XY_MONO_SRC_BLT_WRITE_RGB);
      } else {
	 OUT_RING(XY_MONO_SRC_BLT_CMD | tiled << 11);
      }
      OUT_RING(pI830->BR[13]);
      OUT_RING(0);			/* x1 = 0, y1 = 0 */
      OUT_RING(pI830->BR[11]);		/* x2 = w, y2 = 1 */
      OUT_RING(pI830->BR[9]);		/* dst addr */
      OUT_RING(pI830->BR[12]);		/* src addr */
      OUT_RING(pI830->BR[18]);		/* bg */
      OUT_RING(pI830->BR[19]);		/* fg */

      ADVANCE_LP_RING();
   }

   /* Advance to next scanline.
    */
   pI830->BR[9] += pScrn->displayWidth * pI830->cpp;
   I830GetNextScanlineColorExpandBuffer(pScrn);

   if (IS_I96X(pI830))
      I830EmitFlush(pScrn);
}

#if DO_SCANLINE_IMAGE_WRITE
static void
I830SetupForScanlineImageWrite(ScrnInfoPtr pScrn, int rop,
			       unsigned int planemask, int trans_color,
			       int bpp, int depth)
{
   I830Ptr pI830 = I830PTR(pScrn);

   if (I810_DEBUG & DEBUG_VERBOSE_ACCEL)
      ErrorF("I830SetupForScanlineImageWrite %x %x\n", rop, planemask);

   /* Fill out register values */
   pI830->BR[13] = (pScrn->displayWidth * pI830->cpp);
   pI830->BR[13] |= XAAGetCopyROP(rop) << 16;

   switch (pScrn->bitsPerPixel) {
   case 8:
      break;
   case 16:
      pI830->BR[13] |= (1 << 24);
      break;
   case 32:
      pI830->BR[13] |= ((1 << 25) | (1 << 24));
      break;
   }

   I830GetNextScanlineColorExpandBuffer(pScrn);
}

static void
I830SubsequentScanlineImageWriteRect(ScrnInfoPtr pScrn, int x, int y,
				     int w, int h, int skipleft)
{
   I830Ptr pI830 = I830PTR(pScrn);

   if (I810_DEBUG & DEBUG_VERBOSE_ACCEL)
      ErrorF("I830SubsequentScanlineImageWriteRect "
	     "%d,%d %dx%x %d\n", x, y, w, h, skipleft);

   /* Fill out register values */
   pI830->BR[9] = (pI830->bufferOffset +
		   (y * pScrn->displayWidth + x) * pI830->cpp);
   pI830->BR[11] = ((1 << 16) | w);
}

static void
I830SubsequentImageWriteScanline(ScrnInfoPtr pScrn, int bufno)
{
   I830Ptr pI830 = I830PTR(pScrn);
   unsigned int tiled = CheckTiling(pScrn);

   if (pI830->init == 0) {
      pI830->BR[12] = (pI830->AccelInfoRec->ScanlineColorExpandBuffers[0] -
		       pI830->FbBase);
   } else {
      I830Ptr pI8301 = I830PTR(pI830->entityPrivate->pScrn_1);

      /* We have to use the primary screen's FbBase, as that's where
       * we allocated Scratch2, so we get the correct pointer */
      pI830->BR[12] = (pI830->AccelInfoRec->ScanlineColorExpandBuffers[0] -
		       pI8301->FbBase);
   }

   if (I810_DEBUG & DEBUG_VERBOSE_ACCEL)
      ErrorF("I830SubsequentImageWriteScanline %d (addr %x)\n",
	     bufno, pI830->BR[12]);

   {
      BEGIN_LP_RING(8);

      if (pScrn->bitsPerPixel == 32) {
	 OUT_RING(XY_SRC_COPY_BLT_CMD | XY_SRC_COPY_BLT_WRITE_ALPHA |
		  tiled << 11 |
		  XY_SRC_COPY_BLT_WRITE_RGB);
      } else {
	 OUT_RING(XY_SRC_COPY_BLT_CMD | tiled << 11);
      }
      OUT_RING(pI830->BR[13]);
      OUT_RING(0);			/* x1 = 0, y1 = 0 */
      OUT_RING(pI830->BR[11]);		/* x2 = w, y2 = 1 */
      OUT_RING(pI830->BR[9]);		/* dst addr */
      OUT_RING(0);			/* source origin (0,0) */
      OUT_RING(pI830->BR[11] & 0xffff);	/* source pitch */
      OUT_RING(pI830->BR[12]);		/* src addr */

      ADVANCE_LP_RING();
   }

   /* Advance to next scanline.
    */
   pI830->BR[9] += pScrn->displayWidth * pI830->cpp;
   I830GetNextScanlineColorExpandBuffer(pScrn);
}
#endif

/* Support for multiscreen */
static void
I830RestoreAccelState(ScrnInfoPtr pScrn)
{
#if 0
   /* might be needed, but everything is on a ring, so I don't think so */
   I830Sync(pScrn);
d269 1
@


1.1
log
@Initial revision
@
text
@d151 1
a151 1
   if (IS_I965G(pI830))
d178 1
a178 1
   if (IS_I965G(pI830))
d406 1
a406 1
   if (IS_I965G(pI830)) {
d478 1
a478 1
   if (IS_I965G(pI830))
d547 1
a547 1
   if (IS_I965G(pI830))
d631 1
a631 1
   if (IS_I965G(pI830))
d756 1
a756 1
   if (IS_I965G(pI830))
@


1.1.1.1
log
@Importing xf86-video-i810 1.7.2
@
text
@@


1.1.1.2
log
@xf86-video-intel 2.2.0
@
text
@d10 4
a64 31
#include "i830_debug.h"

unsigned long
intel_get_pixmap_offset(PixmapPtr pPix)
{
    ScreenPtr pScreen = pPix->drawable.pScreen;
    ScrnInfoPtr pScrn = xf86Screens[pScreen->myNum];
    I830Ptr pI830 = I830PTR(pScrn);

#ifdef I830_USE_EXA
    if (pI830->useEXA)
	return exaGetPixmapOffset(pPix);
#endif
    return (unsigned long)pPix->devPrivate.ptr - (unsigned long)pI830->FbBase;
}

unsigned long
intel_get_pixmap_pitch(PixmapPtr pPix)
{
    ScreenPtr pScreen = pPix->drawable.pScreen;
    ScrnInfoPtr pScrn = xf86Screens[pScreen->myNum];
    I830Ptr pI830 = I830PTR(pScrn);

#ifdef I830_USE_EXA
    if (pI830->useEXA)
	return exaGetPixmapPitch(pPix);
#endif
#ifdef I830_USE_XAA
    return (unsigned long)pPix->devKind;
#endif
}
d72 2
a73 2
   unsigned int start = 0;
   unsigned int now = 0;
d75 1
a75 1
   unsigned int first = 0;
d93 1
a93 1
	 ring->space += ring->mem->size;
d104 3
a106 6
	 ErrorF("Error in I830WaitLpRing(), timeout for %d seconds\n",
		timeout_millis/1000);
	 if (IS_I965G(pI830))
	     i965_dump_error_state(pScrn);
	 else
	     i830_dump_error_state(pScrn);
a113 1
#ifdef I830_USE_XAA
a114 4
#endif
#ifdef I830_USE_EXA
	 pI830->EXADriverPtr = NULL;
#endif
d124 1
a124 1
	 ErrorF("Elapsed %u ms\n", now - first);
d166 1
a166 1
   I830WaitLpRing(pScrn, pI830->LpRing->mem->size - 8, 0);
d168 1
a168 1
   pI830->LpRing->space = pI830->LpRing->mem->size - 8;
d181 4
a184 6
   {
       BEGIN_LP_RING(2);
       OUT_RING(MI_FLUSH | flags);
       OUT_RING(MI_NOOP);		/* pad to quadword */
       ADVANCE_LP_RING();
   }
d195 1
a195 4
      pI830->bufferOffset = pI830->back_buffer->offset;
      break;
   case I830_SELECT_THIRD:
      pI830->bufferOffset = pI830->third_buffer->offset;
d198 1
a198 1
      pI830->bufferOffset = pI830->depth_buffer->offset;
d212 51
d270 14
a283 3
#ifdef I830_USE_EXA
    ScrnInfoPtr pScrn = xf86Screens[pScreen->myNum];
    I830Ptr pI830 = I830PTR(pScrn);
d285 93
a377 2
    if (pI830->useEXA)
	return I830EXAInit(pScreen);
d379 483
a861 2
#ifdef I830_USE_XAA
    return I830XAAInit(pScreen);
a862 1
    return FALSE;
@

