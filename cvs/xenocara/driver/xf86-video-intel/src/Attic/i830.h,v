head	1.13;
access;
symbols
	OPENBSD_5_0:1.12.0.6
	OPENBSD_5_0_BASE:1.12
	OPENBSD_4_9:1.12.0.2
	OPENBSD_4_9_BASE:1.12
	OPENBSD_4_8:1.12.0.4
	OPENBSD_4_8_BASE:1.12
	OPENBSD_4_7:1.8.0.2
	OPENBSD_4_7_BASE:1.8
	OPENBSD_4_6:1.7.0.2
	OPENBSD_4_6_BASE:1.7
	OPENBSD_4_5:1.6.0.2
	OPENBSD_4_5_BASE:1.6
	OPENBSD_4_4:1.4.0.2
	OPENBSD_4_4_BASE:1.4
	OPENBSD_4_3_BASE:1.1.1.4
	OPENBSD_4_3:1.1.1.4.0.2
	v2_2_0_90:1.1.1.4
	v2_2_0:1.1.1.3
	OPENBSD_4_2:1.1.1.2.0.2
	OPENBSD_4_2_BASE:1.1.1.2
	v1_7_4:1.1.1.2
	v1_7_3:1.1.1.2
	v1_7_2:1.1.1.1
	xorg:1.1.1;
locks; strict;
comment	@ * @;


1.13
date	2011.11.29.12.39.02;	author oga;	state dead;
branches;
next	1.12;

1.12
date	2010.07.18.14.47.47;	author oga;	state Exp;
branches;
next	1.11;

1.11
date	2010.05.23.21.28.34;	author oga;	state Exp;
branches;
next	1.10;

1.10
date	2010.05.22.23.53.55;	author oga;	state Exp;
branches;
next	1.9;

1.9
date	2010.05.10.22.32.28;	author oga;	state Exp;
branches;
next	1.8;

1.8
date	2009.08.06.16.02.07;	author oga;	state Exp;
branches;
next	1.7;

1.7
date	2009.06.25.20.16.43;	author matthieu;	state Exp;
branches;
next	1.6;

1.6
date	2008.12.01.20.51.41;	author matthieu;	state Exp;
branches;
next	1.5;

1.5
date	2008.10.12.15.20.50;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2008.06.29.20.13.42;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2008.05.21.20.19.51;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2008.03.30.13.51.30;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.26.20.06.38;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.11.26.20.06.38;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2006.12.16.21.01.47;	author matthieu;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2007.11.24.19.44.59;	author matthieu;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2008.02.11.20.10.24;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.13
log
@Update the intel driver to a more recent version based on more recent
upsteam code.

Backporting keeping UMS changes by me, some bugfixes from kettenis@@.

Has been in snapshots for a while, committed on request so we can be
sure what people are running. This is a prerequesite for sandybridge
support but has those chipsets disabled for now until the correct code
has been added.
@
text
@/**************************************************************************

Copyright 1998-1999 Precision Insight, Inc., Cedar Park, Texas.
Copyright Â© 2002 David Dawes

All Rights Reserved.

Permission is hereby granted, free of charge, to any person obtaining a
copy of this software and associated documentation files (the
"Software"), to deal in the Software without restriction, including
without limitation the rights to use, copy, modify, merge, publish,
distribute, sub license, and/or sell copies of the Software, and to
permit persons to whom the Software is furnished to do so, subject to
the following conditions:

The above copyright notice and this permission notice (including the
next paragraph) shall be included in all copies or substantial portions
of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT.
IN NO EVENT SHALL PRECISION INSIGHT AND/OR ITS SUPPLIERS BE LIABLE FOR
ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

**************************************************************************/

/*
 * Authors:
 *   Keith Whitwell <keith@@tungstengraphics.com>
 *   David Dawes <dawes@@xfree86.org>
 *
 */

#if 0
#define I830DEBUG
#endif

#include <stdint.h>

#ifndef REMAP_RESERVED
#define REMAP_RESERVED 0
#endif

#ifndef _I830_H_
#define _I830_H_

#include "xf86_OSproc.h"
#include "compiler.h"
#include "xf86PciInfo.h"
#include "xf86Pci.h"
#include "i810_reg.h"
#include "xf86Cursor.h"
#include "xf86xv.h"
#include "vgaHW.h"
#include "xf86Crtc.h"
#include "xf86RandR12.h"

#include "xf86int10.h"

#include "xorg-server.h"
#include <pciaccess.h>

#include "xf86drm.h"
#include "sarea.h"
#define _XF86DRI_SERVER_
#include "dri.h"
#include "GL/glxint.h"
#include "intel_bufmgr.h"
#include "i915_drm.h"

#include "uxa.h"
Bool i830_uxa_init(ScreenPtr pScreen);
void i830_uxa_create_screen_resources(ScreenPtr pScreen);
void i830_uxa_block_handler(ScreenPtr pScreen);
Bool i830_get_aperture_space(ScrnInfoPtr scrn, drm_intel_bo ** bo_table,
			     int num_bos);

/* XXX
 * The X server gained an *almost* identical implementation in 1.9.
 *
 * Remove this duplicate code either in 2.16 (when we can depend upon 1.9)
 * or the drivers are merged back into the xserver tree, whichever happens
 * earlier.
 */

#ifndef _LIST_H_
/* classic doubly-link circular list */
struct list {
	struct list *next, *prev;
};

static void
list_init(struct list *list)
{
	list->next = list->prev = list;
}

static inline void
__list_add(struct list *entry,
	    struct list *prev,
	    struct list *next)
{
	next->prev = entry;
	entry->next = next;
	entry->prev = prev;
	prev->next = entry;
}

static inline void
list_add(struct list *entry, struct list *head)
{
	__list_add(entry, head, head->next);
}

static inline void
__list_del(struct list *prev, struct list *next)
{
	next->prev = prev;
	prev->next = next;
}

static inline void
list_del(struct list *entry)
{
	__list_del(entry->prev, entry->next);
	list_init(entry);
}

static inline Bool
list_is_empty(struct list *head)
{
	return head->next == head;
}
#endif

#ifndef container_of
#define container_of(ptr, type, member) \
	(type *)((char *)(ptr) - (char *) &((type *)0)->member)
#endif

#ifndef list_entry
#define list_entry(ptr, type, member) \
	container_of(ptr, type, member)
#endif

#ifndef list_first_entry
#define list_first_entry(ptr, type, member) \
	list_entry((ptr)->next, type, member)
#endif

#ifndef list_foreach
#define list_foreach(pos, head)			\
	for (pos = (head)->next; pos != (head);	pos = pos->next)
#endif

/* XXX list.h from xserver-1.9 uses a GCC-ism to avoid having to pass type */
#ifndef list_foreach_entry
#define list_foreach_entry(pos, type, head, member)		\
	for (pos = list_entry((head)->next, type, member);\
	     &pos->member != (head);					\
	     pos = list_entry(pos->member.next, type, member))
#endif

struct intel_pixmap {
	dri_bo *bo;

	struct list flush, batch, in_flight;

	uint16_t stride;
	uint8_t tiling;
	int8_t busy :2;
	int8_t batch_write :1;
};

#if HAS_DEVPRIVATEKEYREC
extern DevPrivateKeyRec uxa_pixmap_index;
#else
extern int uxa_pixmap_index;
#endif

static inline struct intel_pixmap *i830_get_pixmap_intel(PixmapPtr pixmap)
{
#if HAS_DEVPRIVATEKEYREC
	return dixGetPrivate(&pixmap->devPrivates, &uxa_pixmap_index);
#else
	return dixLookupPrivate(&pixmap->devPrivates, &uxa_pixmap_index);
#endif
}

static inline Bool intel_pixmap_is_busy(struct intel_pixmap *priv)
{
	if (priv->busy == -1)
		priv->busy = drm_intel_bo_busy(priv->bo);
	return priv->busy;
}

static inline void i830_set_pixmap_intel(PixmapPtr pixmap, struct intel_pixmap *intel)
{
	dixSetPrivate(&pixmap->devPrivates, &uxa_pixmap_index, intel);
}

static inline Bool i830_uxa_pixmap_is_dirty(PixmapPtr pixmap)
{
	return !list_is_empty(&i830_get_pixmap_intel(pixmap)->flush);
}

static inline Bool i830_pixmap_tiled(PixmapPtr pixmap)
{
	return i830_get_pixmap_intel(pixmap)->tiling != I915_TILING_NONE;
}

dri_bo *i830_get_pixmap_bo(PixmapPtr pixmap);
void i830_set_pixmap_bo(PixmapPtr pixmap, dri_bo * bo);

typedef struct _I830OutputRec I830OutputRec, *I830OutputPtr;

#include "common.h"
#include "i830_sdvo.h"
#include "i2c_vid.h"

#ifdef XvMCExtension
#ifdef ENABLE_XVMC
#define INTEL_XVMC 1
#endif
#endif

#define ALWAYS_SYNC 0
#define ALWAYS_FLUSH 0

struct intel_screen_private;

typedef void (*I830WriteIndexedByteFunc) (struct intel_screen_private  *intel,
					  IOADDRESS addr, uint8_t index,
					  uint8_t value);
typedef uint8_t(*I830ReadIndexedByteFunc) (struct intel_screen_private *intel,
					   IOADDRESS addr, uint8_t index);
typedef void (*I830WriteByteFunc) (struct intel_screen_private *intel,
				   IOADDRESS addr, uint8_t value);
typedef uint8_t(*I830ReadByteFunc) (struct intel_screen_private *intel,
				    IOADDRESS addr);

enum tile_format {
	TILE_NONE,
	TILE_XMAJOR,
	TILE_YMAJOR
};

#define PITCH_NONE 0

/** Record of a linear allocation in the aperture. */
typedef struct _i830_memory i830_memory;
struct _i830_memory {
	/** Offset of the allocation in card VM */
	unsigned long offset;
	/** End of the allocation in card VM */
	unsigned long end;
	/**
	 * Requested size of the allocation: doesn't count padding.
	 *
	 * Any bound memory will cover offset to (offset + size).
	 */
	unsigned long size;
	/**
	 * Allocated aperture size, taking into account padding to allow for
	 * tiling.
	 */
	unsigned long allocated_size;
	/**
	 * Physical (or more properly, bus) address of the allocation.
	 * Only set if requested during allocation.
	 */
	uint64_t bus_addr;
	/** AGP memory handle */
	int key;
	/**
	 * Whether or not the AGP memory (if any) is currently bound.
	 */
	Bool bound;
	/**
	 * Offset that the AGP-allocated memory (if any) is to be bound to.
	 *
	 * This is either @@offset or intel->stolen_size
	 */
	unsigned long agp_offset;

	enum tile_format tiling;
    	/**
	 * Index of the fence register representing the tiled surface, when
	 * bound.
	 */
	int fence_nr;
	/** Pitch value in bytes for tiled surfaces */
	unsigned int pitch;

	/** Description of the allocation, for logging */
	char *name;

	/** @@{
	 * Memory allocator linked list pointers
	 */
	i830_memory *next;
	i830_memory *prev;
	/** @@} */

	dri_bo *bo;
	uint32_t alignment;
	uint32_t gem_name;
	Bool lifetime_fixed_offset;
};

/* store information about an Ixxx DVO */
/* The i830->i865 use multiple DVOs with multiple i2cs */
/* the i915, i945 have a single sDVO i2c bus - which is different */
#define MAX_OUTPUTS 6

#define I830_I2C_BUS_DVO 1
#define I830_I2C_BUS_SDVO 2

/* these are outputs from the chip - integrated only 
   external chips are via DVO or SDVO output */
#define I830_OUTPUT_UNUSED 0
#define I830_OUTPUT_ANALOG 1
#define I830_OUTPUT_DVO_TMDS 2
#define I830_OUTPUT_DVO_LVDS 3
#define I830_OUTPUT_DVO_TVOUT 4
#define I830_OUTPUT_SDVO 5
#define I830_OUTPUT_LVDS 6
#define I830_OUTPUT_TVOUT 7
#define I830_OUTPUT_HDMI 8

struct _I830DVODriver {
	int type;
	char *modulename;
	char *fntablename;
	unsigned int dvo_reg;
	uint32_t gpio;
	int address;
	I830I2CVidOutputRec *vid_rec;
	void *dev_priv;
	pointer modhandle;
};

typedef struct _I830CrtcPrivateRec {
	int pipe;
	int plane;

	Bool enabled;

	int dpms_mode;

	int x, y;

	/* Lookup table values to be set when the CRTC is enabled */
	uint8_t lut_r[256], lut_g[256], lut_b[256];

	i830_memory *rotate_mem;
	/* Card virtual address of the cursor */
	unsigned long cursor_offset;
	unsigned long cursor_argb_offset;
	/* Physical or virtual addresses of the cursor for setting in the cursor
	 * registers.
	 */
	uint64_t cursor_addr;
	unsigned long cursor_argb_addr;
	Bool	cursor_is_argb;
	int	bpc;
} I830CrtcPrivateRec, *I830CrtcPrivatePtr;

#define I830CrtcPrivate(c) ((I830CrtcPrivatePtr) (c)->driver_private)

typedef struct _I830OutputPrivateRec {
   int			    type;
   I2CBusPtr		    pI2CBus;
   I2CBusPtr		    pDDCBus;
   struct _I830DVODriver    *i2c_drv;
   Bool			    load_detect_temp;
   Bool			    needs_tv_clock;
   uint32_t		    lvds_bits;
   int                      pipe_mask;
   int			    clone_mask;
   /** Output-private structure.  Should replace i2c_drv */
   void			    *dev_priv;
} I830OutputPrivateRec, *I830OutputPrivatePtr;

#define I830OutputPrivate(o) ((I830OutputPrivatePtr) (o)->driver_private)

/** enumeration of 3d consumers so some can maintain invariant state. */
enum last_3d {
	LAST_3D_OTHER,
	LAST_3D_VIDEO,
	LAST_3D_RENDER,
	LAST_3D_ROTATION
};

/*
 * Backlight control has some unfortunate properties:
 *   - many machines won't give us brightness change notifications
 *     o brightness hotkeys
 *     o events like AC plug/unplug (can be controlled via _DOS setting)
 *     o ambient light sensor triggered changes
 *   - some machines use the so-called "legacy" backlight interface
 *     o resulting brightness is a combo of LBB and PWM values
 *     o LBB sits in config space
 *   - some machines have ACPI methods for changing brightness
 *     o one of the few ways the X server and firmware can stay in sync
 *   - new machines have the IGD OpRegion interface available
 *     o a reliable way of keeping the firmware and X in sync
 *
 * So the real problem is on machines where ACPI or OpRegion methods aren't
 * available.  In that case, problems can occur:
 *   1) the BIOS and X will have different ideas of what the brightness is,
 *      leading to unexpected results when the brightness is increased or
 *      decreased via hotkey or X protocol
 *   2) unless X takes the legacy register into account, machines using it
 *      may prevent X from raising the brightness above 0 if the firmware
 *      set LBB to 0
 * Given these problems, we provide the user with a selection of methods,
 * so they can choose an ideal one for their platform (assuming our quirk
 * code picks the wrong one).
 *
 * Four different backlight control methods are available:
 *   BCM_NATIVE:  only ever touch the native backlight control registers
 *     This method may be susceptible to problem (2) above if the firmware
 *     modifies the legacy registers.
 *   BCM_LEGACY:  only ever touch the legacy backlight control registers
 *     This method may be susceptible to problem (1) above if the firmware
 *     also modifies the legacy registers.
 *   BCM_COMBO:  try to use both sets
 *     In this case, the driver will try to modify both sets of registers
 *     if needed.  To avoid problem (2) above it may set the LBB register
 *     to a non-zero value if the brightness is to be increased.  It's still
 *     susceptible to problem (1), but to a lesser extent than the LEGACY only
 *     method.
 *   BCM_KERNEL:  use kernel methods for controlling the backlight
 *     This is only available on some platforms, but where present this can
 *     provide the best user experience.
 *
 * And, if you're in EL5, a fifth!
 *   BCM_IRONLAKE_NULL: just don't do anything and be quiet about it.  This is
 *     a workaround for an RHGB interaction; you won't hit this at runtime.
 */

enum backlight_control {
    BCM_NATIVE = 0,
    BCM_LEGACY,
    BCM_COMBO,
    BCM_KERNEL,
    BCM_IRONLAKE_NULL
};

enum dri_type {
	DRI_DISABLED,
	DRI_NONE,
	DRI_DRI2
};
struct sdvo_device_mapping {
   uint8_t dvo_port;
   uint8_t slave_addr;
   uint8_t dvo_wiring;
   uint8_t initialized;
};

typedef struct intel_screen_private {
	unsigned char *MMIOBase;
	unsigned char *GTTBase;
	unsigned char *FbBase;
	int cpp;

	unsigned int bufferOffset;	/* for I830SelectBuffer */

	/* These are set in PreInit and never changed. */
	long FbMapSize;
	long GTTMapSize;

	/**
	 * Linked list of video memory allocations.  The head and tail are
	 * dummy entries that bound the allocation area.
	 */
	i830_memory *memory_list;
	/** Linked list of buffer object memory allocations */
	i830_memory *bo_list;
	long stolen_size;		/**< bytes of pre-bound stolen memory */
	int gtt_acquired;		/**< whether we currently own the AGP */


	i830_memory *front_buffer;
	i830_memory *compressed_front_buffer;
	i830_memory *compressed_ll_buffer;
	/* One big buffer for all cursors for kernels that support this */
	i830_memory *cursor_mem;
	/* separate small buffers for kernels that support this */
	i830_memory *cursor_mem_classic[2];
	/* One big buffer for all cursors for kernels that support this */
	i830_memory *cursor_mem_argb[2];

	dri_bufmgr *bufmgr;

	uint32_t batch_ptr[4096];
	/** Byte offset in batch_ptr for the next dword to be emitted. */
	unsigned int batch_used;
	/** Position in batch_ptr at the start of the current BEGIN_BATCH */
	unsigned int batch_emit_start;
	/** Number of bytes to be emitted in the current BEGIN_BATCH. */
	uint32_t batch_emitting;
	dri_bo *batch_bo;
	dri_bo *last_batch_bo;
	/** Whether we're in a section of code that can't tolerate flushing */
	Bool in_batch_atomic;
	/** Ending batch_used that was verified by i830_start_batch_atomic() */
	int batch_atomic_limit;
	struct list batch_pixmaps;
	struct list flush_pixmaps;
	struct list in_flight;

	/* For Xvideo */
	i830_memory *overlay_regs;
	void *offscreenImages;	/**< remembered memory block for release */
	Bool use_drmmode_overlay;
#ifdef INTEL_XVMC
	/* For XvMC */
	Bool XvMCEnabled;
#endif

	XF86ModReqInfo shadowReq; /* to test for later libshadow */

	CreateScreenResourcesProcPtr CreateScreenResources;

	i830_memory *power_context;

	i830_memory *memory_manager;	/**< DRI memory manager aperture */

	Bool need_mi_flush;

	Bool tiling;
	Bool fb_compression;
	Bool swapbuffers_wait;

	Bool CursorNeedsPhysical;

	int Chipset;
	unsigned long LinearAddr;
	unsigned long MMIOAddr;
	unsigned int MMIOSize;
	IOADDRESS ioBase;
	EntityInfoPtr pEnt;
	struct pci_device *PciInfo;
	uint8_t variant;

	unsigned int BR[20];

	Bool fence_used[FENCE_NEW_NR];

	CloseScreenProcPtr CloseScreen;

	void (*vertex_flush) (struct intel_screen_private *intel);
	void (*batch_flush_notify) (ScrnInfoPtr scrn);

	uxa_driver_t *uxa_driver;
	Bool need_flush;
	int accel_pixmap_pitch_alignment;
	int accel_pixmap_offset_alignment;
	int accel_max_x;
	int accel_max_y;
	int max_bo_size;
	int max_gtt_map_size;
	int max_tiling_size;

	I830WriteIndexedByteFunc writeControl;
	I830ReadIndexedByteFunc readControl;
	I830WriteByteFunc writeStandard;
	I830ReadByteFunc readStandard;

	Bool XvDisabled;	/* Xv disabled in PreInit. */
	Bool XvEnabled;		/* Xv enabled for this generation. */
	Bool XvPreferOverlay;

	int colorKey;
	XF86VideoAdaptorPtr adaptor;
	ScreenBlockHandlerProcPtr BlockHandler;
	Bool overlayOn;

	struct {
		drm_intel_bo *gen4_vs_bo;
		drm_intel_bo *gen4_sf_bo;
		drm_intel_bo *gen4_wm_packed_bo;
		drm_intel_bo *gen4_wm_planar_bo;
		drm_intel_bo *gen4_cc_bo;
		drm_intel_bo *gen4_cc_vp_bo;
		drm_intel_bo *gen4_sampler_bo;
		drm_intel_bo *gen4_sip_kernel_bo;
	} video;

	/* Render accel state */
	float scale_units[2][2];
	/** Transform pointers for src/mask, or NULL if identity */
	PictTransform *transform[2];

	PixmapPtr render_source, render_mask, render_dest;
	PicturePtr render_source_picture, render_mask_picture, render_dest_picture;
	CARD32 render_source_solid;
	CARD32 render_mask_solid;
	PixmapPtr render_current_dest;
	Bool render_source_is_solid;
	Bool render_mask_is_solid;
	Bool needs_render_state_emit;
	Bool needs_render_vertex_emit;
	Bool needs_render_ca_pass;

	/* i830 render accel state */
	uint32_t render_dest_format;
	uint32_t cblend, ablend, s8_blendctl;

	/* i915 render accel state */
	PixmapPtr texture[2];
	uint32_t mapstate[6];
	uint32_t samplerstate[6];

	struct {
		int op;
		uint32_t dst_format;
	} i915_render_state;

	uint32_t prim_offset;
	void (*prim_emit)(PixmapPtr dest,
			  int srcX, int srcY,
			  int maskX, int maskY,
			  int dstX, int dstY,
			  int w, int h);
	int floats_per_vertex;
	int last_floats_per_vertex;
	uint32_t vertex_count;
	uint32_t vertex_index;
	uint32_t vertex_used;
	float vertex_ptr[4*1024];
	dri_bo *vertex_bo;

	/* 965 render acceleration state */
	struct gen4_render_state *gen4_render_state;

	enum dri_type directRenderingType;	/* DRI enabled this generation. */

	Bool directRenderingOpen;
	int drmSubFD;
#ifdef notyet
	drmEventContext event_context;
#endif
	char *deviceName;

	/* Broken-out options. */
	OptionInfoPtr Options;

	Bool lvds_24_bit_mode;
	Bool lvds_use_ssc;
	int lvds_ssc_freq; /* in MHz */
	Bool lvds_dither;
	DisplayModePtr lvds_fixed_mode;
	DisplayModePtr sdvo_lvds_fixed_mode;
	Bool skip_panel_detect;
	Bool integrated_lvds; /* LVDS config from driver feature BDB */

	Bool tv_present; /* TV connector present (from VBIOS) */

	/* Driver phase/state information */
	Bool preinit;
	Bool starting;
	Bool closing;
	Bool suspended;
	Bool leaving;

	unsigned int SaveGeneration;

	int ddc2;

	enum backlight_control backlight_control_method;

	uint32_t saveDSPARB;
	uint32_t saveDSPACNTR;
	uint32_t saveDSPBCNTR;
	uint32_t savePIPEACONF;
	uint32_t savePIPEBCONF;
	uint32_t savePIPEASRC;
	uint32_t savePIPEBSRC; uint32_t saveFPA0;
	uint32_t saveFPA1;
	uint32_t saveDPLL_A;
	uint32_t saveDPLL_A_MD;
	uint32_t saveHTOTAL_A;
	uint32_t saveHBLANK_A;
	uint32_t saveHSYNC_A;
	uint32_t saveVTOTAL_A;
	uint32_t saveVBLANK_A;
	uint32_t saveVSYNC_A;
	uint32_t saveBCLRPAT_A;
	uint32_t saveDSPASTRIDE;
	uint32_t saveDSPASIZE;
	uint32_t saveDSPAPOS;
	uint32_t saveDSPABASE;
	uint32_t saveDSPASURF;
	uint32_t saveDSPATILEOFF;
	uint32_t saveFPB0;
	uint32_t saveFPB1;
	uint32_t saveDPLL_B;
	uint32_t saveDPLL_B_MD;
	uint32_t saveHTOTAL_B;
	uint32_t saveHBLANK_B;
	uint32_t saveHSYNC_B;
	uint32_t saveVTOTAL_B;
	uint32_t saveVBLANK_B;
	uint32_t saveVSYNC_B;
	uint32_t saveBCLRPAT_B;
	uint32_t saveDSPBSTRIDE;
	uint32_t saveDSPBSIZE;
	uint32_t saveDSPBPOS;
	uint32_t saveDSPBBASE;
	uint32_t saveDSPBSURF;
	uint32_t saveDSPBTILEOFF;
	uint32_t saveVCLK_DIVISOR_VGA0;
	uint32_t saveVCLK_DIVISOR_VGA1;
	uint32_t saveVCLK_POST_DIV;
	uint32_t saveVGACNTRL;
	uint32_t saveCURSOR_A_CONTROL;
	uint32_t saveCURSOR_A_BASE;
	uint32_t saveCURSOR_A_POSITION;
	uint32_t saveCURSOR_B_CONTROL;
	uint32_t saveCURSOR_B_BASE;
	uint32_t saveCURSOR_B_POSITION;
	uint32_t saveADPA;
	uint32_t saveLVDS;
	uint32_t saveDVOA;
	uint32_t saveDVOB;
	uint32_t saveDVOC;
	uint32_t savePP_ON;
	uint32_t savePP_OFF;
	uint32_t savePP_CONTROL;
	uint32_t savePP_DIVISOR;
	uint32_t savePFIT_CONTROL;
	uint32_t savePaletteA[256];
	uint32_t savePaletteB[256];
	uint32_t saveSWF[17];
	uint32_t saveBLC_PWM_CTL;
	uint32_t saveBLC_PWM_CTL2;
	uint32_t saveFBC_CFB_BASE;
	uint32_t saveFBC_LL_BASE;
	uint32_t saveFBC_CONTROL2;
	uint32_t saveFBC_CONTROL;
	uint32_t saveFBC_FENCE_OFF;
	uint32_t saveRENCLK_GATE_D1;
	uint32_t saveRENCLK_GATE_D2;
	uint32_t saveDSPCLK_GATE_D;
	uint32_t saveRAMCLK_GATE_D;
	uint32_t savePWRCTXA;

	enum last_3d last_3d;

	Bool use_drm_mode;

	/** Enables logging of debug output related to mode switching. */
	Bool debug_modes;
	unsigned int quirk_flag;

	/**
	 * User option to print acceleration fallback info to the server log.
	 */
	Bool fallback_debug;
	struct sdvo_device_mapping sdvo_mappings[2];
	unsigned debug_flush;

	   /* ironlake vt restore hack */
	   xf86Int10InfoPtr int10;
	   int int10Mode;
} intel_screen_private;

enum {
	DEBUG_FLUSH_BATCHES = 0x1,
	DEBUG_FLUSH_CACHES = 0x2,
	DEBUG_FLUSH_WAIT = 0x4,
};


static inline intel_screen_private *
intel_get_screen_private(ScrnInfoPtr scrn)
{
	return (intel_screen_private *)(scrn->driverPrivate);
}

#define ARRAY_SIZE(x) (sizeof(x) / sizeof(x[0]))
#define ALIGN(i,m)	(((i) + (m) - 1) & ~((m) - 1))
#define MIN(a,b)	((a) < (b) ? (a) : (b))

#define I830_SELECT_FRONT	0
#define I830_SELECT_BACK	1
#define I830_SELECT_DEPTH	2
#define I830_SELECT_THIRD	3

unsigned long intel_get_pixmap_offset(PixmapPtr pixmap);
unsigned long intel_get_pixmap_pitch(PixmapPtr pixmap);

/* Batchbuffer support macros and functions */
#include "i830_batchbuffer.h"

/* I830 specific functions */
extern void I830SetPIOAccess(intel_screen_private *intel);
extern void I830SetMMIOAccess(intel_screen_private *intel);
extern void I830InitHWCursor(ScrnInfoPtr scrn);
extern void I830SetPipeCursor (xf86CrtcPtr crtc, Bool force);
extern Bool I830CursorInit(ScreenPtr pScreen);
extern void IntelEmitInvarientState(ScrnInfoPtr scrn);
extern void I830EmitInvarientState(ScrnInfoPtr scrn);
extern void I915EmitInvarientState(ScrnInfoPtr scrn);
extern Bool I830SelectBuffer(ScrnInfoPtr scrn, int buffer);
void i830_update_cursor_offsets(ScrnInfoPtr scrn);

/* CRTC-based cursor functions */
void
i830_crtc_load_cursor_image (xf86CrtcPtr crtc, unsigned char *src);

#ifdef ARGB_CURSOR
void
i830_crtc_load_cursor_argb (xf86CrtcPtr crtc, CARD32 *image);
#endif

void
i830_crtc_set_cursor_position (xf86CrtcPtr crtc, int x, int y);

void
i830_crtc_show_cursor (xf86CrtcPtr crtc);

void
i830_crtc_hide_cursor (xf86CrtcPtr crtc);

void
i830_crtc_set_cursor_colors (xf86CrtcPtr crtc, int bg, int fg);

extern void i830_refresh_ring(ScrnInfoPtr scrn);
extern void I830EmitFlush(ScrnInfoPtr scrn);

extern void I830InitVideo(ScreenPtr pScreen);
extern void i830_crtc_dpms_video(xf86CrtcPtr crtc, Bool on);
extern xf86CrtcPtr i830_covering_crtc(ScrnInfoPtr scrn, BoxPtr box,
				      xf86CrtcPtr desired, BoxPtr crtc_box_ret);
int
i830_crtc_pipe (xf86CrtcPtr crtc);

extern xf86CrtcPtr i830_pipe_to_crtc(ScrnInfoPtr scrn, int pipe);

Bool
i830_pipe_a_require_activate (ScrnInfoPtr scrn);

void
i830_pipe_a_require_deactivate (ScrnInfoPtr scrn);

Bool I830DRI2ScreenInit(ScreenPtr pScreen);
void I830DRI2CloseScreen(ScreenPtr pScreen);
void I830DRI2FrameEventHandler(unsigned int frame, unsigned int tv_sec,
			       unsigned int tv_usec, void *user_data);

extern Bool drmmode_pre_init(ScrnInfoPtr scrn, int fd, int cpp);
extern int drmmode_get_pipe_from_crtc_id(drm_intel_bufmgr * bufmgr,
					 xf86CrtcPtr crtc);
extern void drmmode_closefb(ScrnInfoPtr scrn);
extern int drmmode_output_dpms_status(xf86OutputPtr output);
extern int drmmode_crtc_id(xf86CrtcPtr crtc);
void drmmode_crtc_set_cursor_bo(xf86CrtcPtr crtc, dri_bo * cursor);

extern Bool i830_crtc_on(xf86CrtcPtr crtc);
extern int i830_crtc_to_pipe(xf86CrtcPtr crtc);
extern Bool I830AccelInit(ScreenPtr pScreen);
extern void I830SetupForScreenToScreenCopy(ScrnInfoPtr scrn, int xdir,
					   int ydir, int rop,
					   unsigned int planemask,
					   int trans_color);
extern void I830SubsequentScreenToScreenCopy(ScrnInfoPtr scrn, int srcX,
					     int srcY, int dstX, int dstY,
					     int w, int h);
extern void I830SetupForSolidFill(ScrnInfoPtr scrn, int color, int rop,
				  unsigned int planemask);
extern void I830SubsequentSolidFillRect(ScrnInfoPtr scrn, int x, int y,
					int w, int h);

Bool i830_allocator_init(ScrnInfoPtr scrn, unsigned long size);
void i830_allocator_fini(ScrnInfoPtr scrn);
i830_memory *i830_allocate_memory(ScrnInfoPtr scrn, const char *name,
				  unsigned long size, unsigned long pitch,
				  unsigned long alignment, int flags,
				  enum tile_format tile_format);
void i830_describe_allocations(ScrnInfoPtr scrn, int verbosity,
			       const char *prefix);
void i830_reset_allocations(ScrnInfoPtr scrn);
void i830_free_3d_memory(ScrnInfoPtr scrn);
void i830_free_memory(ScrnInfoPtr scrn, i830_memory *mem);
extern long I830CheckAvailableMemory(ScrnInfoPtr scrn);
Bool i830_allocate_2d_memory(ScrnInfoPtr scrn);
Bool i830_allocate_pwrctx(ScrnInfoPtr scrn);
Bool i830_allocate_3d_memory(ScrnInfoPtr scrn);
void i830_init_bufmgr(ScrnInfoPtr scrn);
#ifdef INTEL_XVMC
Bool i830_allocate_xvmc_buffer(ScrnInfoPtr scrn, const char *name,
			       i830_memory ** buffer, unsigned long size,
			       int flags);
void i830_free_xvmc_buffer(ScrnInfoPtr scrn, i830_memory * buffer);
#endif
extern uint32_t i830_create_new_fb(ScrnInfoPtr scrn, int width, int height,
				   int *pitch);

Bool i830_tiled_width(intel_screen_private *intel, int *width, int cpp);

extern Bool I830I2CInit(ScrnInfoPtr scrn, I2CBusPtr *bus_ptr, int i2c_reg,
			char *name);

/* i830_display.c */
Bool
i830PipeHasType (xf86CrtcPtr crtc, int type);

/* i830_crt.c */
void i830_crt_init(ScrnInfoPtr scrn);

/* i830_dvo.c */
void i830_dvo_init(ScrnInfoPtr scrn);

/* i830_hdmi.c */
void i830_hdmi_init(ScrnInfoPtr scrn, int output_reg);

/* i830_lvds.c */
void i830_lvds_init(ScrnInfoPtr scrn);

/* i830_memory.c */
Bool i830_bind_all_memory(ScrnInfoPtr scrn);
Bool i830_unbind_all_memory(ScrnInfoPtr scrn);
unsigned long i830_get_fence_size(intel_screen_private *intel, unsigned long size);
unsigned long i830_get_fence_pitch(intel_screen_private *intel, unsigned long pitch,
				   int format);
void i830_set_gem_max_sizes(ScrnInfoPtr scrn);

i830_memory *i830_allocate_framebuffer(ScrnInfoPtr scrn);

/* i830_modes.c */
DisplayModePtr i830_ddc_get_modes(xf86OutputPtr output);

/* i830_tv.c */
void i830_tv_init(ScrnInfoPtr scrn);

/* i830_render.c */
Bool i830_check_composite(int op,
			  PicturePtr sourcec, PicturePtr mask, PicturePtr dest,
			  int width, int height);
Bool i830_check_composite_target(PixmapPtr pixmap);
Bool i830_check_composite_texture(ScreenPtr screen, PicturePtr picture);
Bool i830_prepare_composite(int op, PicturePtr sourcec, PicturePtr mask,
			    PicturePtr dest, PixmapPtr sourcecPixmap,
			    PixmapPtr maskPixmap, PixmapPtr destPixmap);
Bool i830_transform_is_affine(PictTransformPtr t);

void i830_composite(PixmapPtr dest, int srcX, int srcY,
		    int maskX, int maskY, int dstX, int dstY, int w, int h);
void i830_done_composite(PixmapPtr dest);
/* i915_render.c */
Bool i915_check_composite(int op,
			  PicturePtr sourcec, PicturePtr mask, PicturePtr dest,
			  int width, int height);
Bool i915_check_composite_target(PixmapPtr pixmap);
Bool i915_check_composite_texture(ScreenPtr screen, PicturePtr picture);
Bool i915_prepare_composite(int op, PicturePtr sourcec, PicturePtr mask,
			    PicturePtr dest, PixmapPtr sourcecPixmap,
			    PixmapPtr maskPixmap, PixmapPtr destPixmap);
void i915_composite(PixmapPtr dest, int srcX, int srcY,
		    int maskX, int maskY, int dstX, int dstY, int w, int h);
void i915_vertex_flush(intel_screen_private *intel);
void i915_batch_flush_notify(ScrnInfoPtr scrn);
void i830_batch_flush_notify(ScrnInfoPtr scrn);
/* i965_render.c */
unsigned int gen4_render_state_size(ScrnInfoPtr scrn);
void gen4_render_state_init(ScrnInfoPtr scrn);
void gen4_render_state_cleanup(ScrnInfoPtr scrn);
Bool i965_check_composite(int op,
			  PicturePtr sourcec, PicturePtr mask, PicturePtr dest,
			  int width, int height);
Bool i965_check_composite_texture(ScreenPtr screen, PicturePtr picture);
Bool i965_prepare_composite(int op, PicturePtr sourcec, PicturePtr mask,
			    PicturePtr dest, PixmapPtr sourcecPixmap,
			    PixmapPtr maskPixmap, PixmapPtr destPixmap);
void i965_composite(PixmapPtr dest, int srcX, int srcY,
		    int maskX, int maskY, int dstX, int dstY, int w, int h);

void i965_batch_flush_notify(ScrnInfoPtr scrn);

Bool
i830_get_transformed_coordinates(int x, int y, PictTransformPtr transform,
				 float *x_out, float *y_out);

Bool
i830_get_transformed_coordinates_3d(int x, int y, PictTransformPtr transform,
				    float *x_out, float *y_out, float *z_out);

void i830_enter_render(ScrnInfoPtr);

extern void intel_sync(ScrnInfoPtr scrn);

static inline int i830_fb_compression_supported(intel_screen_private *intel)
{
    if (!IS_MOBILE(intel))
	return FALSE;
    if (IS_I810(intel) || IS_I815(intel) || IS_I830(intel))
	return FALSE;
    if (IS_IGD(intel))
	return FALSE;
    if (IS_IGDNG(intel))
	return FALSE;
    /* fbc depends on tiled surface.
     */
    if (!intel->tiling)
	return FALSE;
    /* We have not gotten FBC to work consistently on 965GM. Our best
     * working theory right now is that FBC simply isn't reliable on
     * that device. See this bug report for more details:
     * https://bugs.freedesktop.org/show_bug.cgi?id=16257
     */
    if (IS_I965GM(intel) || IS_I915GM(intel) || IS_I945GM(intel))
	return FALSE;
    return TRUE;
}

static inline void
intel_debug_fallback(ScrnInfoPtr scrn, char *format, ...)
{
	intel_screen_private *intel = intel_get_screen_private(scrn);
	va_list ap;

	va_start(ap, format);
	if (intel->fallback_debug) {
		xf86DrvMsg(scrn->scrnIndex, X_INFO, "fallback: ");
		LogVMessageVerb(X_INFO, 1, format, ap);
	}
	va_end(ap);
}

Bool i830_pixmap_tiled(PixmapPtr p);

static inline Bool
intel_check_pitch_2d(PixmapPtr pixmap)
{
	uint32_t pitch = intel_get_pixmap_pitch(pixmap);
	if (pitch > KB(32)) {
		ScrnInfoPtr scrn = xf86Screens[pixmap->drawable.pScreen->myNum];
		intel_debug_fallback(scrn, "pitch exceeds 2d limit 32K\n");
		return FALSE;
	}
	return TRUE;
}

/* For pre-965 chip only, as they have 8KB limit for 3D */
static inline Bool
intel_check_pitch_3d(PixmapPtr pixmap)
{
	uint32_t pitch = intel_get_pixmap_pitch(pixmap);
	if (pitch > KB(8)) {
		ScrnInfoPtr scrn = xf86Screens[pixmap->drawable.pScreen->myNum];
		intel_debug_fallback(scrn, "pitch exceeds 3d limit 8K\n");
		return FALSE;
	}
	return TRUE;
}

/**
 * Little wrapper around drm_intel_bo_reloc to return the initial value you
 * should stuff into the relocation entry.
 *
 * If only we'd done this before settling on the library API.
 */
static inline uint32_t
intel_emit_reloc(drm_intel_bo * bo, uint32_t offset,
		 drm_intel_bo * target_bo, uint32_t target_offset,
		 uint32_t read_domains, uint32_t write_domain)
{
	drm_intel_bo_emit_reloc(bo, offset, target_bo, target_offset,
				read_domains, write_domain);

	return target_bo->offset + target_offset;
}

static inline drm_intel_bo *intel_bo_alloc_for_data(ScrnInfoPtr scrn,
						    void *data,
						    unsigned int size,
						    char *name)
{
	intel_screen_private *intel = intel_get_screen_private(scrn);
	drm_intel_bo *bo;

	bo = drm_intel_bo_alloc(intel->bufmgr, name, size, 4096);
	if (!bo)
		return NULL;
	drm_intel_bo_subdata(bo, 0, size, data);

	return bo;
}

extern const int I830PatternROP[16];
extern const int I830CopyROP[16];

/* Flags for memory allocation function */
#define NEED_PHYSICAL_ADDR		0x00000001
#define ALIGN_BOTH_ENDS			0x00000002
#define NEED_NON_STOLEN			0x00000004
#define NEED_LIFETIME_FIXED		0x00000008
#define ALLOW_SHARING			0x00000010
#define DISABLE_REUSE			0x00000020

/* Chipset registers for VIDEO BIOS memory RW access */
#define _855_DRAM_RW_CONTROL 0x58
#define _845_DRAM_RW_CONTROL 0x90
#define DRAM_WRITE    0x33330000

/* quirk flag definition */
#define QUIRK_IGNORE_TV			0x00000001
#define QUIRK_IGNORE_LVDS		0x00000002
#define QUIRK_IGNORE_MACMINI_LVDS 	0x00000004
#define QUIRK_PIPEA_FORCE		0x00000008
#define QUIRK_IVCH_NEED_DVOB		0x00000010
#define QUIRK_RESET_MODES		0x00000020
#define QUIRK_PFIT_SAFE			0x00000040
#define QUIRK_IGNORE_CRT		0x00000080
#define QUIRK_BROKEN_ACPI_LID		0x00000100
extern void i830_fixup_devices(ScrnInfoPtr);

void i830_debug_flush(ScrnInfoPtr scrn);

static inline PixmapPtr get_drawable_pixmap(DrawablePtr drawable)
{
	ScreenPtr screen = drawable->pScreen;

	if (drawable->type == DRAWABLE_PIXMAP)
		return (PixmapPtr) drawable;
	else
		return screen->GetWindowPixmap((WindowPtr) drawable);
}

static inline Bool pixmap_is_scanout(PixmapPtr pixmap)
{
	ScreenPtr screen = pixmap->drawable.pScreen;

	return pixmap == screen->GetScreenPixmap(screen);
}

/*
 * Pad to accelerator requirement
 */
static inline int i830_pad_drawable_width(int width)
{
	return (width + 63) & ~63;
}


#endif /* _I830_H_ */
@


1.12
log
@Update the intel driver to (mostly) a backport of 2.12.

It is missing a few commits that I have yet to verify (ones that try and
continue if we lock the gpu rendering engine and can't reset it, for
example) taht will be verified and sent out for extra testing soon.

Should contain a bunch of speedups and some correctness improvements
(though rendercheck still gives some errors that I am looking into).

This has been in snaps since the first day of c2k10, any known issues
with just this driver have (to my knowledge) been fixed since. A problem
with macbooks pointed out by otto happens with both this and the in-tree
driver and thus doesn't stop this moving forward.

As well as the 2.12 improvements, this driver also has a backport
(partially aided by the backports in RHEL 5 kindly provided by Dave
Airlie) from the kms code of modesetting support for ironlake (arrandale
and clarkdale: the IGDs build into intel nehalem cpu dies) which has
been tested on a number of chipsets. Note that Display port and eDP
displays have not yet been worked on (and probably won't until I can
find a displayport monitor), but VGA and lvds at least are known to
work, sure beats vesa.

"no objection on my side" matthieu@@, prodding (as always) from princess
marco.
@
text
@@


1.11
log
@Pull in the changes in rendering that I skipped when i backported
changes from later intel versions (after the UMS removal). 95% of this
is the xvmc reworks that makes that code even halfway sane. xvmc is now
enabled by default on 965+.

Tested by many on tech@@, thanks!

ok matthieu@@
@
text
@d61 2
d81 9
d137 1
d144 1
d147 1
d149 1
d152 1
d154 1
d157 1
d159 2
d165 1
d169 1
a169 5
	uint32_t tiling, stride;
	uint32_t flush_write_domain;
	uint32_t flush_read_domains;
	uint32_t batch_write_domain;
	uint32_t batch_read_domains;
d171 5
d178 26
a203 1
struct intel_pixmap *i830_get_pixmap_intel(PixmapPtr pixmap);
d207 1
a207 1
	return i830_get_pixmap_intel(pixmap)->flush_write_domain != 0;
a313 9
typedef struct {
	int tail_mask;
	i830_memory *mem;
	unsigned char *virtual_start;
	int head;
	int tail;
	int space;
} I830RingBuffer;

d369 1
d440 4
d451 1
a497 12
	i830_memory *fake_bufmgr_mem;

	/* Regions allocated either from the above pools, or from agpgart. */
	I830RingBuffer ring;

	/** Number of bytes being emitted in the current BEGIN_LP_RING */
	unsigned int ring_emitting;
	/** Number of bytes that have been emitted in the current BEGIN_LP_RING */
	unsigned int ring_used;
	/** Offset in the ring for the next DWORD emit */
	uint32_t ring_next;

d501 1
a501 1
	uint8_t *batch_ptr;
a534 2
	Bool have_gem;

d558 1
d567 1
a599 3
	float dst_coord_adjust;
	float src_coord_adjust;
	float mask_coord_adjust;
d605 1
d609 2
d626 14
d647 3
a674 2
	OsTimerPtr devicesTimer;

a757 1
	Bool kernel_exec_fencing;
d769 4
a803 1
extern int I830WaitLpRing(ScrnInfoPtr scrn, int n, int timeout_millis);
d856 2
d945 5
a949 2
Bool i830_check_composite(int op, PicturePtr sourcec, PicturePtr mask,
			  PicturePtr dest);
d959 5
a963 2
Bool i915_check_composite(int op, PicturePtr sourcec, PicturePtr mask,
			  PicturePtr dest);
d969 1
d976 4
a979 2
Bool i965_check_composite(int op, PicturePtr sourcec, PicturePtr mask,
			  PicturePtr dest);
a998 8

static inline void
i830_wait_ring_idle(ScrnInfoPtr scrn)
{
   intel_screen_private *intel = intel_get_screen_private(scrn);

   I830WaitLpRing(scrn, intel->ring.mem->size - 8, 0);
}
@


1.10
log
@Disable Framebuffer Compression on 915GM and 945GM.

While this feature at best can save 05w idle power, it is very flakey. Disabling
it fixes (or at the least masks) the problem that some 915 and 945 users were
seeing where they ended up with a blank screen (it turns out that no problems
fired because everything was still working, just FBC screwed up and never
actually scanned out the framebuffer).

As some examples for reliability linux with kms has disabled fbc on these
chipsets due to some unreliability issues (especially over suspend). and the
window driver apparently also does not used it.

Tested by kettenis@@, Tom Murphy, edd@@ and myself.

ok matthieu@@
@
text
@a68 1
#include "i830_dri.h"
d601 1
a601 1
	char deviceName[64];
@


1.9
log
@Update the intel driver to 2.9.1 plus backports.

2.9.1 is the last version of the intel DDX that supports UMS (User
modesetting), with 2.10 onwards being purely KMS only. As such, this
driver contains backports of almost every correctness or performance
related fix to the rendering layer in later intel drivers. This driver
*REQUIRES* a GEM enabled kernel. it claims to support non-gem mode but
this is essentially unmaintained and due to the way the abstraciton
works is slow, if it works at all (it often does not). You have been
warned.

tested by many many people on tech over the last few weeks.
@
text
@d968 1
a968 1
    if (IS_I965GM(intel))
@


1.8
log
@Pull in some code from 2.8 and current so that dri2 works correctly with
xserver 1.6.2. When dri2 is not in use, this commit does nothing.

ok matthieu@@
@
text
@a28 1
/* $XFree86: xc/programs/Xserver/hw/xfree86/drivers/i810/i830.h,v 1.12 2004/01/07 03:43:19 dawes Exp $ */
a54 1
#include "xaa.h"
a61 1
#ifdef XSERVER_LIBPCIACCESS
a62 1
#endif
a63 1
#ifdef XF86DRI
a69 1
#endif
a72 7
#ifdef I830_USE_EXA
#include "exa.h"
Bool I830EXAInit(ScreenPtr pScreen);
unsigned long long I830TexOffsetStart(PixmapPtr pPix);
#endif

#ifdef I830_USE_UXA
d76 2
a77 2
void i830_uxa_block_handler (ScreenPtr pScreen);
Bool i830_get_aperture_space(ScrnInfoPtr pScrn, drm_intel_bo **bo_table,
a78 1
#endif
d80 88
a167 4
#if defined(I830_USE_UXA) || defined(I830_USE_EXA)
dri_bo *i830_get_pixmap_bo (PixmapPtr pixmap);
void i830_set_pixmap_bo(PixmapPtr pixmap, dri_bo *bo);
#endif
d169 2
a170 3
#ifdef I830_USE_XAA
Bool I830XAAInit(ScreenPtr pScreen);
#endif
a177 12
/*
 * The mode handling is based upon the VESA driver written by
 * Paulo CÃ©sar Pereira de Andrade <pcpa@@conectiva.com.br>.
 */

#ifdef XF86DRI
#define I830_MM_MINPAGES 512
#define I830_MM_MAXSIZE  (32*1024)
#define I830_KERNEL_MM  (1 << 0) /* Initialize the kernel memory manager*/
#define I830_KERNEL_TEX (1 << 1) /* Allocate texture memory pool */
#endif

d184 4
a187 1
typedef struct _I830Rec *I830Ptr;
d189 9
a197 7
typedef void (*I830WriteIndexedByteFunc)(I830Ptr pI830, IOADDRESS addr,
                                         uint8_t index, uint8_t value);
typedef uint8_t(*I830ReadIndexedByteFunc)(I830Ptr pI830, IOADDRESS addr,
					  uint8_t index);
typedef void (*I830WriteByteFunc)(I830Ptr pI830, IOADDRESS addr,
				  uint8_t value);
typedef uint8_t(*I830ReadByteFunc)(I830Ptr pI830, IOADDRESS addr);
d200 3
a202 3
    TILE_NONE,
    TILE_XMAJOR,
    TILE_YMAJOR
d210 56
a265 56
    /** Offset of the allocation in card VM */
    unsigned long offset;
    /** End of the allocation in card VM */
    unsigned long end;
    /**
     * Requested size of the allocation: doesn't count padding.
     *
     * Any bound memory will cover offset to (offset + size).
     */
    unsigned long size;
    /**
     * Allocated aperture size, taking into account padding to allow for
     * tiling.
     */
    unsigned long allocated_size;
    /**
     * Physical (or more properly, bus) address of the allocation.
     * Only set if requested during allocation.
     */
    uint64_t bus_addr;
    /** AGP memory handle */
    int key;
    /**
     * Whether or not the AGP memory (if any) is currently bound.
     */
    Bool bound;
    /**
     * Offset that the AGP-allocated memory (if any) is to be bound to.
     *
     * This is either @@offset or pI830->stolen_size
     */
    unsigned long agp_offset;

    enum tile_format tiling;
    /**
     * Index of the fence register representing the tiled surface, when
     * bound.
     */
    int fence_nr;
    /** Pitch value in bytes for tiled surfaces */
    unsigned int pitch;

    /** Description of the allocation, for logging */
    char *name;

    /** @@{
     * Memory allocator linked list pointers
     */
    i830_memory *next;
    i830_memory *prev;
    /** @@} */

    dri_bo *bo;
    uint32_t alignment;
    uint32_t gem_name;
    Bool lifetime_fixed_offset;
d269 6
a274 6
   int tail_mask;
   i830_memory *mem;
   unsigned char *virtual_start;
   int head;
   int tail;
   int space;
d298 9
a306 10
   int type;
   char *modulename;
   char *fntablename;
   unsigned int dvo_reg;
   uint32_t gpio;
   int address;
   const char **symbols;
   I830I2CVidOutputRec *vid_rec;
   void *dev_priv;
   pointer modhandle;
d309 5
a313 1
extern const char *i830_output_type_names[];
d315 3
a317 3
typedef struct _I830CrtcPrivateRec {
    int			    pipe;
    int			    plane;
d319 13
a331 19
    Bool    		    enabled;
    
    int			    dpms_mode;
    
    int			    x, y;

    /* Lookup table values to be set when the CRTC is enabled */
    uint8_t lut_r[256], lut_g[256], lut_b[256];

    i830_memory *rotate_mem;
    /* Card virtual address of the cursor */
    unsigned long cursor_offset;
    unsigned long cursor_argb_offset;
    /* Physical or virtual addresses of the cursor for setting in the cursor
     * registers.
     */
    uint64_t cursor_addr;
    unsigned long cursor_argb_addr;
    Bool	cursor_is_argb;
d354 4
a357 4
    LAST_3D_OTHER,
    LAST_3D_VIDEO,
    LAST_3D_RENDER,
    LAST_3D_ROTATION
a410 8
typedef enum accel_method {
    ACCEL_UNINIT = 0,
    ACCEL_NONE,
    ACCEL_XAA,
    ACCEL_EXA,
    ACCEL_UXA
} accel_method_t;

d412 9
a420 4
    DRI_DISABLED,
    DRI_NONE,
    DRI_XF86DRI,
    DRI_DRI2
d423 68
a490 67
typedef struct _I830Rec {
   unsigned char *MMIOBase;
   unsigned char *GTTBase;
   unsigned char *FbBase;
   int cpp;

   unsigned int bufferOffset;		/* for I830SelectBuffer */
   BoxRec FbMemBox;
   int CacheLines;

   /* These are set in PreInit and never changed. */
   long FbMapSize;
   long GTTMapSize;

   /**
    * Linked list of video memory allocations.  The head and tail are
    * dummy entries that bound the allocation area.
    */
   i830_memory *memory_list;
   /** Linked list of buffer object memory allocations */
   i830_memory *bo_list;
   long stolen_size;		/**< bytes of pre-bound stolen memory */
   int gtt_acquired;		/**< whether we currently own the AGP */

   i830_memory *front_buffer;
   i830_memory *compressed_front_buffer;
   i830_memory *compressed_ll_buffer;
   /* One big buffer for all cursors for kernels that support this */
   i830_memory *cursor_mem;
   /* separate small buffers for kernels that support this */
   i830_memory *cursor_mem_classic[2];
   i830_memory *cursor_mem_argb[2];
   i830_memory *xaa_scratch;
#ifdef I830_USE_EXA
   i830_memory *exa_offscreen;
#endif
   i830_memory *fake_bufmgr_mem;

   /* Regions allocated either from the above pools, or from agpgart. */
   I830RingBuffer ring;

   /** Number of bytes being emitted in the current BEGIN_LP_RING */
   unsigned int ring_emitting;
   /** Number of bytes that have been emitted in the current BEGIN_LP_RING */
   unsigned int ring_used;
   /** Offset in the ring for the next DWORD emit */
   uint32_t ring_next;

   dri_bufmgr *bufmgr;

   uint8_t *batch_ptr;
   /** Byte offset in batch_ptr for the next dword to be emitted. */
   unsigned int batch_used;
   /** Position in batch_ptr at the start of the current BEGIN_BATCH */
   unsigned int batch_emit_start;
   /** Number of bytes to be emitted in the current BEGIN_BATCH. */
   uint32_t batch_emitting;
   dri_bo *batch_bo;
   /** Whether we're in a section of code that can't tolerate flushing */
   Bool in_batch_atomic;
   /** Ending batch_used that was verified by i830_start_batch_atomic() */
   int batch_atomic_limit;

#ifdef I830_XV
   /* For Xvideo */
   i830_memory *overlay_regs;
#endif
d492 2
a493 2
   /* For XvMC */
   Bool XvMCEnabled;
d496 1
a496 17
   XF86ModReqInfo shadowReq; /* to test for later libshadow */
   Rotation rotation;
   void (*PointerMoved)(int, int, int);
   CreateScreenResourcesProcPtr    CreateScreenResources;

   i830_memory *power_context;

#ifdef XF86DRI
   i830_memory *back_buffer;
   i830_memory *depth_buffer;
   i830_memory *textures;		/**< Compatibility texture memory */
   i830_memory *memory_manager;		/**< DRI memory manager aperture */
   i830_memory *hw_status;		/* for G33 hw status page alloc */

   int TexGranularity;
   int drmMinor;
   Bool allocate_classic_textures;
d498 1
a498 1
   Bool can_resize;
d500 225
a724 2
   Bool want_vblank_interrupts;
#endif
d726 5
a730 1
   Bool need_mi_flush;
a731 25
   Bool NeedRingBufferLow;
   Bool tiling;
   Bool fb_compression;

   int backPitch;

   Bool CursorNeedsPhysical;
 
   DGAModePtr DGAModes;
   int numDGAModes;
   Bool DGAactive;
   int DGAViewportStatus;

   int Chipset;
   unsigned long LinearAddr;
   unsigned long MMIOAddr;
   IOADDRESS ioBase;
   EntityInfoPtr pEnt;
#if XSERVER_LIBPCIACCESS
   struct pci_device *PciInfo;
#else
   pciVideoPtr PciInfo;
   PCITAG PciTag;
#endif
   uint8_t variant;
d733 5
a737 230
   unsigned int BR[20];

   unsigned char **ScanlineColorExpandBuffers;
   int NumScanlineColorExpandBuffers;
   int nextColorExpandBuf;

   Bool fence_used[FENCE_NEW_NR];

   accel_method_t accel;
#ifdef I830_USE_XAA
   XAAInfoRecPtr AccelInfoRec;

   /* additional XAA accelerated Composite support */
   CompositeProcPtr saved_composite;
   Bool (*xaa_check_composite)(int op, PicturePtr pSrc, PicturePtr pMask,
			       PicturePtr pDst);
   Bool (*xaa_prepare_composite)(int op, PicturePtr pSrc, PicturePtr pMask,
				 PicturePtr pDst, PixmapPtr pSrcPixmap,
				 PixmapPtr pMaskPixmap, PixmapPtr pDstPixmap);
   void (*xaa_composite)(PixmapPtr pDst, int xSrc, int ySrc,
			 int xMask, int yMask, int xDst, int yDst,
			 int w, int h);
   void (*xaa_done_composite)(PixmapPtr pDst);
#endif
   CloseScreenProcPtr CloseScreen;

   void (*batch_flush_notify)(ScrnInfoPtr pScrn);

#ifdef I830_USE_EXA
   ExaDriverPtr	EXADriverPtr;
#endif
#ifdef I830_USE_UXA
   uxa_driver_t *uxa_driver;
   Bool need_flush;
#endif
   Bool need_sync;
#if defined(I830_USE_EXA) || defined(I830_USE_UXA)
   PixmapPtr pSrcPixmap;
#endif
   int accel_pixmap_pitch_alignment;
   int accel_pixmap_offset_alignment;
   int accel_max_x;
   int accel_max_y;

   I830WriteIndexedByteFunc writeControl;
   I830ReadIndexedByteFunc readControl;
   I830WriteByteFunc writeStandard;
   I830ReadByteFunc readStandard;

   Bool XvDisabled;			/* Xv disabled in PreInit. */
   Bool XvEnabled;			/* Xv enabled for this generation. */
   Bool XvPreferOverlay;

#ifdef I830_XV
   int colorKey;
   XF86VideoAdaptorPtr adaptor;
   ScreenBlockHandlerProcPtr BlockHandler;
   Bool overlayOn;

   struct {
      drm_intel_bo *gen4_vs_bo;
      drm_intel_bo *gen4_sf_bo;
      drm_intel_bo *gen4_wm_packed_bo;
      drm_intel_bo *gen4_wm_planar_bo;
      drm_intel_bo *gen4_cc_bo;
      drm_intel_bo *gen4_cc_vp_bo;
      drm_intel_bo *gen4_sampler_bo;
      drm_intel_bo *gen4_sip_kernel_bo;
   } video;
#endif

   /* EXA render state */
   float scale_units[2][2];
  /** Transform pointers for src/mask, or NULL if identity */
   PictTransform *transform[2];
   float coord_adjust;
   /* i915 EXA render state */
   uint32_t mapstate[6];
   uint32_t samplerstate[6];

   struct {
      int op;
      PicturePtr pSrcPicture, pMaskPicture, pDstPicture;
      PixmapPtr pSrc, pMask, pDst;
      uint32_t dst_format;
      Bool is_nearest;
      Bool needs_emit;
   } i915_render_state;

   /* 965 render acceleration state */
   struct gen4_render_state *gen4_render_state;

   enum dri_type directRenderingType;	/* DRI enabled this generation. */

#ifdef XF86DRI
   Bool directRenderingOpen;
   int LockHeld;
   DRIInfoPtr pDRIInfo;
   int drmSubFD;
   int numVisualConfigs;
   __GLXvisualConfig *pVisualConfigs;
   I830ConfigPrivPtr pVisualConfigsPriv;
   drm_handle_t buffer_map;
   drm_handle_t ring_map;
   char deviceName[64];
#endif

   /* Broken-out options. */
   OptionInfoPtr Options;

   Bool lvds_24_bit_mode;
   Bool lvds_use_ssc;
   int lvds_ssc_freq; /* in MHz */
   Bool lvds_dither;
   DisplayModePtr lvds_fixed_mode;
   Bool skip_panel_detect;
   Bool integrated_lvds; /* LVDS config from driver feature BDB */

   Bool tv_present; /* TV connector present (from VBIOS) */

   /* Driver phase/state information */
   Bool preinit;
   Bool starting;
   Bool closing;
   Bool suspended;
   Bool leaving;

   /* fbOffset converted to (x, y). */
   int xoffset;
   int yoffset;

   unsigned int SaveGeneration;

   OsTimerPtr devicesTimer;

   int ddc2;

   enum backlight_control backlight_control_method;

   uint32_t saveDSPARB;
   uint32_t saveDSPACNTR;
   uint32_t saveDSPBCNTR;
   uint32_t savePIPEACONF;
   uint32_t savePIPEBCONF;
   uint32_t savePIPEASRC;
   uint32_t savePIPEBSRC;
   uint32_t saveFPA0;
   uint32_t saveFPA1;
   uint32_t saveDPLL_A;
   uint32_t saveDPLL_A_MD;
   uint32_t saveHTOTAL_A;
   uint32_t saveHBLANK_A;
   uint32_t saveHSYNC_A;
   uint32_t saveVTOTAL_A;
   uint32_t saveVBLANK_A;
   uint32_t saveVSYNC_A;
   uint32_t saveBCLRPAT_A;
   uint32_t saveDSPASTRIDE;
   uint32_t saveDSPASIZE;
   uint32_t saveDSPAPOS;
   uint32_t saveDSPABASE;
   uint32_t saveDSPASURF;
   uint32_t saveDSPATILEOFF;
   uint32_t saveFPB0;
   uint32_t saveFPB1;
   uint32_t saveDPLL_B;
   uint32_t saveDPLL_B_MD;
   uint32_t saveHTOTAL_B;
   uint32_t saveHBLANK_B;
   uint32_t saveHSYNC_B;
   uint32_t saveVTOTAL_B;
   uint32_t saveVBLANK_B;
   uint32_t saveVSYNC_B;
   uint32_t saveBCLRPAT_B;
   uint32_t saveDSPBSTRIDE;
   uint32_t saveDSPBSIZE;
   uint32_t saveDSPBPOS;
   uint32_t saveDSPBBASE;
   uint32_t saveDSPBSURF;
   uint32_t saveDSPBTILEOFF;
   uint32_t saveVCLK_DIVISOR_VGA0;
   uint32_t saveVCLK_DIVISOR_VGA1;
   uint32_t saveVCLK_POST_DIV;
   uint32_t saveVGACNTRL;
   uint32_t saveCURSOR_A_CONTROL;
   uint32_t saveCURSOR_A_BASE;
   uint32_t saveCURSOR_A_POSITION;
   uint32_t saveCURSOR_B_CONTROL;
   uint32_t saveCURSOR_B_BASE;
   uint32_t saveCURSOR_B_POSITION;
   uint32_t saveADPA;
   uint32_t saveLVDS;
   uint32_t saveDVOA;
   uint32_t saveDVOB;
   uint32_t saveDVOC;
   uint32_t savePP_ON;
   uint32_t savePP_OFF;
   uint32_t savePP_CONTROL;
   uint32_t savePP_DIVISOR;
   uint32_t savePFIT_CONTROL;
   uint32_t savePaletteA[256];
   uint32_t savePaletteB[256];
   uint32_t saveSWF[17];
   uint32_t saveBLC_PWM_CTL;
   uint32_t saveBLC_PWM_CTL2;
   uint32_t saveFBC_CFB_BASE;
   uint32_t saveFBC_LL_BASE;
   uint32_t saveFBC_CONTROL2;
   uint32_t saveFBC_CONTROL;
   uint32_t saveFBC_FENCE_OFF;
   uint32_t saveRENCLK_GATE_D1;
   uint32_t saveRENCLK_GATE_D2;
   uint32_t saveDSPCLK_GATE_D;
   uint32_t saveRAMCLK_GATE_D;
   uint32_t savePWRCTXA;

   enum last_3d last_3d;

   Bool use_drm_mode;
   Bool kernel_exec_fencing;

   /** Enables logging of debug output related to mode switching. */
   Bool debug_modes;
   unsigned int quirk_flag;

    /** User option to print acceleration fallback info to the server log. */
   Bool fallback_debug;
} I830Rec;

#define I830PTR(p) ((I830Ptr)((p)->driverPrivate))
d740 2
d748 2
a749 6
unsigned long intel_get_pixmap_offset(PixmapPtr pPix);
unsigned long intel_get_pixmap_pitch(PixmapPtr pPix);

struct i830_exa_pixmap_priv {
    dri_bo *bo;
};
d755 4
a758 5
extern int I830WaitLpRing(ScrnInfoPtr pScrn, int n, int timeout_millis);
extern void I830SetPIOAccess(I830Ptr pI830);
extern void I830SetMMIOAccess(I830Ptr pI830);
extern void I830Sync(ScrnInfoPtr pScrn);
extern void I830InitHWCursor(ScrnInfoPtr pScrn);
d761 5
a765 5
extern void IntelEmitInvarientState(ScrnInfoPtr pScrn);
extern void I830EmitInvarientState(ScrnInfoPtr pScrn);
extern void I915EmitInvarientState(ScrnInfoPtr pScrn);
extern Bool I830SelectBuffer(ScrnInfoPtr pScrn, int buffer);
void i830_update_cursor_offsets(ScrnInfoPtr pScrn);
d788 2
a789 2
extern void i830_refresh_ring(ScrnInfoPtr pScrn);
extern void I830EmitFlush(ScrnInfoPtr pScrn);
a790 1
#ifdef I830_XV
d793 2
a794 2
#endif

d798 1
a798 1
extern xf86CrtcPtr i830_pipe_to_crtc(ScrnInfoPtr pScrn, int pipe);
a805 18
#ifdef XF86DRI
extern Bool I830Allocate3DMemory(ScrnInfoPtr pScrn, const int flags);
extern void I830SetupMemoryTiling(ScrnInfoPtr pScrn);
extern Bool I830DRIScreenInit(ScreenPtr pScreen);
extern Bool I830CheckDRIAvailable(ScrnInfoPtr pScrn);
extern Bool I830DRIDoMappings(ScreenPtr pScreen);
extern Bool I830DRIResume(ScreenPtr pScreen);
extern void I830DRICloseScreen(ScreenPtr pScreen);
extern Bool I830DRIFinishScreenInit(ScreenPtr pScreen);
extern void I830DRIUnlock(ScrnInfoPtr pScrn);
extern Bool I830DRILock(ScrnInfoPtr pScrn);
extern Bool I830DRISetVBlankInterrupt (ScrnInfoPtr pScrn, Bool on);
extern Bool i830_update_dri_buffers(ScrnInfoPtr pScrn);
extern Bool I830DRISetHWS(ScrnInfoPtr pScrn);
extern Bool I830DRIInstIrqHandler(ScrnInfoPtr pScrn);
#endif

#ifdef DRI2
a807 1
#endif
d809 7
a815 5
#ifdef XF86DRM_MODE
extern Bool drmmode_pre_init(ScrnInfoPtr pScrn, int fd, int cpp);
extern Bool drmmode_is_rotate_pixmap(ScrnInfoPtr pScrn, pointer pPixData,
				     dri_bo **bo);
#endif
d817 2
d820 1
a820 1
extern void I830SetupForScreenToScreenCopy(ScrnInfoPtr pScrn, int xdir,
d824 1
a824 1
extern void I830SubsequentScreenToScreenCopy(ScrnInfoPtr pScrn, int srcX,
d827 1
a827 1
extern void I830SetupForSolidFill(ScrnInfoPtr pScrn, int color, int rop,
d829 1
a829 1
extern void I830SubsequentSolidFillRect(ScrnInfoPtr pScrn, int x, int y,
d832 7
a838 8
Bool i830_allocator_init(ScrnInfoPtr pScrn, unsigned long offset,
			 unsigned long size);
void i830_allocator_fini(ScrnInfoPtr pScrn);
i830_memory * i830_allocate_memory(ScrnInfoPtr pScrn, const char *name,
				   unsigned long size, unsigned long pitch,
				   unsigned long alignment, int flags,
				   enum tile_format tile_format);
void i830_describe_allocations(ScrnInfoPtr pScrn, int verbosity,
d840 8
a847 9
void i830_reset_allocations(ScrnInfoPtr pScrn);
void i830_free_3d_memory(ScrnInfoPtr pScrn);
void i830_free_memory(ScrnInfoPtr pScrn, i830_memory *mem);
extern long I830CheckAvailableMemory(ScrnInfoPtr pScrn);
Bool i830_allocate_2d_memory(ScrnInfoPtr pScrn);
Bool i830_allocate_texture_memory(ScrnInfoPtr pScrn);
Bool i830_allocate_pwrctx(ScrnInfoPtr pScrn);
Bool i830_allocate_3d_memory(ScrnInfoPtr pScrn);
void i830_init_bufmgr(ScrnInfoPtr pScrn);
d849 4
a852 2
Bool i830_allocate_xvmc_buffer(ScrnInfoPtr pScrn, const char *name,
                               i830_memory **buffer, unsigned long size, int flags);
d854 1
a854 2
extern void i830_update_front_offset(ScrnInfoPtr pScrn);
extern uint32_t i830_create_new_fb(ScrnInfoPtr pScrn, int width, int height,
d857 1
a857 6
Bool
i830_tiled_width(I830Ptr i830, int *width, int cpp);

int
i830_pad_drawable_width(int width, int cpp);

d859 1
a859 1
extern Bool I830I2CInit(ScrnInfoPtr pScrn, I2CBusPtr *bus_ptr, int i2c_reg,
a861 3
/* return a mask of output indices matching outputs against type_mask */
int i830_output_clones (ScrnInfoPtr pScrn, int type_mask);

d867 1
a867 1
void i830_crt_init(ScrnInfoPtr pScrn);
d870 1
a870 1
void i830_dvo_init(ScrnInfoPtr pScrn);
d873 1
a873 1
void i830_hdmi_init(ScrnInfoPtr pScrn, int output_reg);
d876 1
a876 4
void i830_lvds_init(ScrnInfoPtr pScrn);

extern void i830MarkSync(ScrnInfoPtr pScrn);
extern void i830WaitSync(ScrnInfoPtr pScrn);
d879 6
a884 5
Bool i830_bind_all_memory(ScrnInfoPtr pScrn);
Bool i830_unbind_all_memory(ScrnInfoPtr pScrn);
unsigned long i830_get_fence_size(I830Ptr pI830, unsigned long size);
unsigned long i830_get_fence_pitch(I830Ptr pI830, unsigned long pitch, int format);
unsigned long i830_get_fence_alignment(I830Ptr pI830, unsigned long size);
d886 1
a886 5
Bool I830BindAGPMemory(ScrnInfoPtr pScrn);
Bool I830UnbindAGPMemory(ScrnInfoPtr pScrn);

i830_memory *
i830_allocate_framebuffer(ScrnInfoPtr pScrn);
d892 1
a892 1
void i830_tv_init(ScrnInfoPtr pScrn);
d895 6
a900 7
Bool i830_check_composite(int op, PicturePtr pSrc, PicturePtr pMask,
			  PicturePtr pDst);
Bool i830_prepare_composite(int op, PicturePtr pSrc, PicturePtr pMask,
			    PicturePtr pDst, PixmapPtr pSrcPixmap,
			    PixmapPtr pMaskPixmap, PixmapPtr pDstPixmap);
Bool
i830_transform_is_affine (PictTransformPtr t);
d902 1
a902 1
void i830_composite(PixmapPtr pDst, int srcX, int srcY,
d904 1
a904 1
void i830_done_composite(PixmapPtr pDst);
d906 6
a911 6
Bool i915_check_composite(int op, PicturePtr pSrc, PicturePtr pMask,
			  PicturePtr pDst);
Bool i915_prepare_composite(int op, PicturePtr pSrc, PicturePtr pMask,
			    PicturePtr pDst, PixmapPtr pSrcPixmap,
			    PixmapPtr pMaskPixmap, PixmapPtr pDstPixmap);
void i915_composite(PixmapPtr pDst, int srcX, int srcY,
d913 2
a914 1
void i915_batch_flush_notify(ScrnInfoPtr pScrn);
d916 9
a924 9
unsigned int gen4_render_state_size(ScrnInfoPtr pScrn);
void gen4_render_state_init(ScrnInfoPtr pScrn);
void gen4_render_state_cleanup(ScrnInfoPtr pScrn);
Bool i965_check_composite(int op, PicturePtr pSrc, PicturePtr pMask,
			  PicturePtr pDst);
Bool i965_prepare_composite(int op, PicturePtr pSrc, PicturePtr pMask,
			    PicturePtr pDst, PixmapPtr pSrcPixmap,
			    PixmapPtr pMaskPixmap, PixmapPtr pDstPixmap);
void i965_composite(PixmapPtr pDst, int srcX, int srcY,
d927 1
a927 2
void
i965_batch_flush_notify(ScrnInfoPtr pScrn);
d939 1
a939 3
#ifndef SERVER_1_5
Bool xf86MonitorIsHDMI(xf86MonPtr mon);
#endif
d942 1
a942 1
i830_wait_ring_idle(ScrnInfoPtr pScrn)
d944 1
a944 1
   I830Ptr pI830 = I830PTR(pScrn);
d946 1
a946 2
   if (pI830->accel != ACCEL_NONE)
       I830WaitLpRing(pScrn, pI830->ring.mem->size - 8, 0);
d949 1
a949 1
static inline int i830_fb_compression_supported(I830Ptr pI830)
d951 1
a951 1
    if (!IS_MOBILE(pI830))
d953 1
a953 1
    if (IS_I810(pI830) || IS_I815(pI830) || IS_I830(pI830))
d955 5
a959 2
    /* fbc depends on tiled surface. And we don't support tiled
     * front buffer with XAA now.
d961 1
a961 1
    if (!pI830->tiling || (IS_I965G(pI830) && pI830->accel <= ACCEL_XAA))
d968 1
a968 1
    if (IS_I965GM(pI830))
d973 13
a985 8
#define I830FALLBACK(s, arg...)				\
do {							\
    if (I830PTR(pScrn)->fallback_debug) {		\
	xf86DrvMsg(pScrn->scrnIndex, X_INFO,		\
		   "EXA fallback: " s "\n", ##arg);	\
    }							\
    return FALSE;					\
} while(0)
d989 11
a999 4
#define i830_exa_check_pitch_2d(p) do {\
    uint32_t pitch = intel_get_pixmap_pitch(p);\
    if (pitch > KB(32)) I830FALLBACK("pitch exceeds 2d limit 32K\n");\
} while(0)
d1002 11
a1012 4
#define i830_exa_check_pitch_3d(p) do {\
    uint32_t pitch = intel_get_pixmap_pitch(p);\
    if (pitch > KB(8)) I830FALLBACK("pitch exceeds 3d limit 8K\n");\
} while(0)
d1021 2
a1022 2
intel_emit_reloc(drm_intel_bo *bo, uint32_t offset,
		 drm_intel_bo *target_bo, uint32_t target_offset,
d1025 2
a1026 2
    drm_intel_bo_emit_reloc(bo, offset, target_bo, target_offset,
			    read_domains, write_domain);
d1028 1
a1028 1
    return target_bo->offset + target_offset;
d1031 4
a1034 3
static inline drm_intel_bo *
intel_bo_alloc_for_data(ScrnInfoPtr scrn, void *data, unsigned int size,
			char *name)
d1036 2
a1037 2
    I830Ptr pI830 = I830PTR(scrn);
    drm_intel_bo *bo;
d1039 4
a1042 4
    bo = drm_intel_bo_alloc(pI830->bufmgr, name, size, 4096);
    if (!bo)
	return NULL;
    drm_intel_bo_subdata(bo, 0, size, data);
d1044 1
a1044 1
    return bo;
d1056 1
d1075 1
a1075 10
/**
 * Hints to CreatePixmap to tell the driver how the pixmap is going to be
 * used.
 *
 * Compare to CREATE_PIXMAP_USAGE_* in the server.
 */
enum {
    INTEL_CREATE_PIXMAP_TILING_X = 0x10000000,
    INTEL_CREATE_PIXMAP_TILING_Y,
};
d1077 1
a1077 2
static inline PixmapPtr
get_drawable_pixmap(DrawablePtr drawable)
d1079 1
a1079 1
    ScreenPtr screen = drawable->pScreen;
d1081 4
a1084 4
    if (drawable->type == DRAWABLE_PIXMAP)
	return (PixmapPtr)drawable;
    else
	return screen->GetWindowPixmap((WindowPtr)drawable);
d1087 1
a1087 2
static inline Bool
pixmap_is_scanout(PixmapPtr pixmap)
d1089 4
a1092 1
    ScreenPtr screen = pixmap->drawable.pScreen;
d1094 6
a1099 1
    return pixmap == screen->GetScreenPixmap(screen);
d1101 1
@


1.7
log
@update to xf86-video-intel 2.7.1. Tested by many.
@
text
@d1082 19
@


1.6
log
@xf86-video-intel 2.4.3. Tested by many.
@
text
@a58 2
#include "xf86int10.h"
#include "vbe.h"
a69 3
#ifdef XF86DRI_MM
#include "xf86mm.h"
#endif
a74 3
#ifdef DAMAGE
#include "damage.h"
#endif
d76 2
d85 14
a105 1
#include "i830_ring.h"
a108 6
/* I830 Video support */
#define NEED_REPLIES				/* ? */
#define EXTENSION_PROC_ARGS void *
#include "extnsionst.h" 			/* required */
#include <X11/extensions/panoramiXproto.h> 	/* required */

d143 2
d200 3
a202 2
#ifdef XF86DRI_MM
    drmBO bo;
a203 1
#endif
a214 11
typedef struct {
   int            lastInstance;
   int            refCount;
   ScrnInfoPtr    pScrn_1;
   ScrnInfoPtr    pScrn_2;
   int            RingRunning;
#ifdef I830_XV
   int            XvInUse;
#endif
} I830EntRec, *I830EntPtr;

d258 2
d352 15
a372 3
   I830EntPtr entityPrivate;	
   int init;

a374 1
   BoxRec FbMemBox2;
a391 1
   i830_memory *front_buffer_2;
a399 1
   i830_memory *xaa_scratch_2;
a401 1
   i830_memory *gen4_render_state_mem;
d403 2
d406 1
a406 1
   I830RingBuffer *LpRing;
d415 15
a443 2
   i830_memory *logical_context;

a447 1
   i830_memory *third_buffer;
d457 2
a459 4
#ifdef DAMAGE
   DamagePtr pDamage;
   RegionRec driRegion;
#endif
d461 2
a464 2
   Bool allowPageFlip;
   Bool TripleBuffer;
d498 1
a498 3
   Bool useEXA;
   Bool noAccel;
   Bool SWCursor;
d516 2
d520 7
d529 4
d541 1
d547 12
a558 1
   Bool *overlayOn;
d570 9
d582 1
a582 2
   Bool directRenderingDisabled;	/* DRI disabled in PreInit. */
   Bool directRenderingEnabled;		/* DRI enabled this generation. */
d594 1
d606 1
a609 4
   Bool StolenOnly;

   Bool checkDevices;

d688 1
a688 1
   uint32_t savePP_CYCLE;
d706 4
a709 1
   enum last_3d *last_3d;
d714 3
d728 10
d749 1
a749 1
extern void I830SelectBuffer(ScrnInfoPtr pScrn, int buffer);
d809 11
a819 2
unsigned long intel_get_pixmap_offset(PixmapPtr pPix);
unsigned long intel_get_pixmap_pitch(PixmapPtr pPix);
d837 3
a839 7
				   unsigned long size, unsigned long alignment,
				   int flags);
i830_memory *i830_allocate_memory_tiled(ScrnInfoPtr pScrn, const char *name,
					unsigned long size,
					unsigned long pitch,
					unsigned long alignment, int flags,
					enum tile_format tile_format);
d850 1
d855 9
a864 1
extern Bool I830IsPrimary(ScrnInfoPtr pScrn);
d894 3
d901 3
d928 3
d943 3
d956 4
d965 2
a966 1
   I830WaitLpRing(pScrn, pI830->LpRing->mem->size - 8, 0);
d978 1
a978 1
    if (!pI830->tiling || (IS_I965G(pI830) && !pI830->useEXA))
d990 9
d1012 31
a1042 6
/* Batchbuffer compatibility handling */
#define BEGIN_BATCH(n) BEGIN_LP_RING(n)
#define ENSURE_BATCH(n)
#define OUT_BATCH(d) OUT_RING(d)
#define OUT_BATCH_F(x) OUT_RING_F(x)
#define ADVANCE_BATCH() ADVANCE_LP_RING()
d1066 3
d1070 11
@


1.5
log
@xf86-video-intel 2.4.2. Has been in snapshots for weeks. Ok oga@@.
@
text
@d890 7
@


1.4
log
@update to xf86-video-intel 2.3.2. Tested among others by okan@@.
@
text
@a87 1
#define EXA_LINEAR_EXTRA	(64*1024)
d241 1
a253 2
   DisplayModePtr panel_fixed_mode;
   Bool panel_wants_dither;
d289 1
d399 1
a399 1
   i830_memory *exa_965_state;
a417 1
   Bool IsXvMCSurface;
d533 3
d555 7
d586 1
a666 1
   Bool lvds_fixed_mode;
d809 3
d850 3
@


1.3
log
@Update to xf86-video-intel 2.3.1. Tested by many.
@
text
@d429 2
a556 4
   Bool swfSaved;
   uint32_t saveSWF0;
   uint32_t saveSWF4;

d648 5
d664 2
d776 1
d856 8
@


1.2
log
@Update to Intel driver 2.2.1. But change default accelmethod to XAA.
Tested by landry@@, oga@@, steven@@, jakemsr@@.
@
text
@a0 1

d99 1
d121 6
d130 6
a135 5
                                         CARD8 index, CARD8 value);
typedef CARD8(*I830ReadIndexedByteFunc)(I830Ptr pI830, IOADDRESS addr,
                                        CARD8 index);
typedef void (*I830WriteByteFunc)(I830Ptr pI830, IOADDRESS addr, CARD8 value);
typedef CARD8(*I830ReadByteFunc)(I830Ptr pI830, IOADDRESS addr);
d269 1
a269 1
    CARD8 lut_r[256], lut_g[256], lut_b[256];
d291 1
d405 7
d416 6
d474 1
a474 1
   CARD8 variant;
d528 1
d530 2
a531 2
   CARD32 mapstate[6];
   CARD32 samplerstate[6];
d551 2
d556 2
a557 2
   CARD32 saveSWF0;
   CARD32 saveSWF4;
d580 70
a649 64
   CARD32 saveDSPACNTR;
   CARD32 saveDSPBCNTR;
   CARD32 savePIPEACONF;
   CARD32 savePIPEBCONF;
   CARD32 savePIPEASRC;
   CARD32 savePIPEBSRC;
   CARD32 saveFPA0;
   CARD32 saveFPA1;
   CARD32 saveDPLL_A;
   CARD32 saveDPLL_A_MD;
   CARD32 saveHTOTAL_A;
   CARD32 saveHBLANK_A;
   CARD32 saveHSYNC_A;
   CARD32 saveVTOTAL_A;
   CARD32 saveVBLANK_A;
   CARD32 saveVSYNC_A;
   CARD32 saveBCLRPAT_A;
   CARD32 saveDSPASTRIDE;
   CARD32 saveDSPASIZE;
   CARD32 saveDSPAPOS;
   CARD32 saveDSPABASE;
   CARD32 saveDSPASURF;
   CARD32 saveDSPATILEOFF;
   CARD32 saveFPB0;
   CARD32 saveFPB1;
   CARD32 saveDPLL_B;
   CARD32 saveDPLL_B_MD;
   CARD32 saveHTOTAL_B;
   CARD32 saveHBLANK_B;
   CARD32 saveHSYNC_B;
   CARD32 saveVTOTAL_B;
   CARD32 saveVBLANK_B;
   CARD32 saveVSYNC_B;
   CARD32 saveBCLRPAT_B;
   CARD32 saveDSPBSTRIDE;
   CARD32 saveDSPBSIZE;
   CARD32 saveDSPBPOS;
   CARD32 saveDSPBBASE;
   CARD32 saveDSPBSURF;
   CARD32 saveDSPBTILEOFF;
   CARD32 saveVCLK_DIVISOR_VGA0;
   CARD32 saveVCLK_DIVISOR_VGA1;
   CARD32 saveVCLK_POST_DIV;
   CARD32 saveVGACNTRL;
   CARD32 saveADPA;
   CARD32 saveLVDS;
   CARD32 saveDVOA;
   CARD32 saveDVOB;
   CARD32 saveDVOC;
   CARD32 savePP_ON;
   CARD32 savePP_OFF;
   CARD32 savePP_CONTROL;
   CARD32 savePP_CYCLE;
   CARD32 savePFIT_CONTROL;
   CARD32 savePaletteA[256];
   CARD32 savePaletteB[256];
   CARD32 saveSWF[17];
   CARD32 saveBLC_PWM_CTL;
   CARD32 saveBLC_PWM_CTL2;
   CARD32 saveFBC_CFB_BASE;
   CARD32 saveFBC_LL_BASE;
   CARD32 saveFBC_CONTROL2;
   CARD32 saveFBC_CONTROL;
   CARD32 saveFBC_FENCE_OFF;
d655 1
d712 2
d772 4
d820 3
d841 1
a841 1
void
d845 4
d867 18
d906 1
@


1.1
log
@Initial revision
@
text
@d43 2
a61 1
#include "vbeModes.h"
d63 7
a69 1
#include "randrstr.h"
d73 3
d81 14
d97 2
d100 2
d103 1
a108 2
/* I830 Video BIOS support */

d114 6
a119 22
#define PIPE_NONE	0<<0
#define PIPE_CRT	1<<0
#define PIPE_TV		1<<1
#define PIPE_DFP	1<<2
#define PIPE_LFP	1<<3
#define PIPE_CRT2	1<<4
#define PIPE_TV2	1<<5
#define PIPE_DFP2	1<<6
#define PIPE_LFP2	1<<7

typedef struct _VESARec {
   /* SVGA state */
   pointer state, pstate;
   int statePage, stateSize, stateMode, stateRefresh;
   CARD32 *savedPal;
   int savedScanlinePitch;
   /* Don't try to set the refresh rate for any modes. */
   Bool useDefaultRefresh;
   /* display start */
   int x, y;
} VESARec, *VESAPtr;

d130 66
a195 20
/* Linear region allocated in framebuffer. */
typedef struct _I830MemPool *I830MemPoolPtr;
typedef struct _I830MemRange *I830MemRangePtr;
typedef struct _I830MemRange {
   long Start;
   long End;
   long Size;
   unsigned long Physical;
   unsigned long Offset;		/* Offset of AGP-allocated portion */
   unsigned long Alignment;
   int Key;
   I830MemPoolPtr Pool;
} I830MemRange;

typedef struct _I830MemPool {
   I830MemRange Total;
   I830MemRange Free;
   I830MemRange Fixed;
   I830MemRange Allocated;
} I830MemPool;
d199 1
a199 1
   I830MemRange mem;
a206 4
   unsigned int Fence[FENCE_NEW_NR * 2];
} I830RegRec, *I830RegPtr;

typedef struct {
d217 126
a342 21
typedef struct _MergedDisplayModeRec {
    DisplayModePtr First;
    DisplayModePtr Second;
    int    SecondPosition;
} I830MergedDisplayModeRec, *I830MergedDisplayModePtr;

typedef struct _I830XineramaData {
    int x;
    int y;
    int width;
    int height;
} I830XineramaData;

typedef struct _ModePrivateRec {
    I830MergedDisplayModeRec merged;
    VbeModeInfoData vbeData;
} I830ModePrivateRec, *I830ModePrivatePtr;

typedef struct _region {
    int x0,x1,y0,y1;
} region;
d344 6
d353 1
a356 15
   unsigned int bios_version;

   Bool newPipeSwitch;

   Bool fakeSwitch;
   
   int fixedPipe;

   DisplayModePtr currentMode;

   Bool Clone;
   int CloneRefresh;
   int CloneHDisplay;
   int CloneVDisplay;

a357 1
   int pipe, origPipe;
d367 1
a367 17
   long TotalVideoRam;
   I830MemRange StolenMemory;		/* pre-allocated memory */
   long BIOSMemorySize;			/* min stolen pool size */
   int BIOSMemSizeLoc;

   /* These change according to what has been allocated. */
   long FreeMemory;
   I830MemRange MemoryAperture;
   I830MemPool StolenPool;
   long allocatedMemory;

   /* Regions allocated either from the above pools, or from agpgart. */
   /* for single and dual head configurations */
   I830MemRange FrontBuffer;
   I830MemRange FrontBuffer2;
   I830MemRange Scratch;
   I830MemRange Scratch2;
d369 25
a394 2
   I830MemRange	*CursorMem;
   I830MemRange	*CursorMemARGB;
a396 4
#if REMAP_RESERVED
   I830MemRange Dummy;
#endif

d399 1
a399 2
   I830MemRange *OverlayMem;
   I830MemRange LinearMem;
a400 20
   int LinearAlloc;

   Bool MergedFB;
   ScrnInfoPtr pScrn_2;
   char	*SecondHSync;
   char	*SecondVRefresh;
   char	*MetaModes;
   int SecondPosition;
   int FirstXOffs, FirstYOffs, SecondXOffs, SecondYOffs;
   int FirstframeX0, FirstframeX1, FirstframeY0, FirstframeY1;
   int MBXNR1XMAX, MBXNR1YMAX, MBXNR2XMAX, MBXNR2YMAX;
   Bool	NonRect, HaveNonRect, HaveOffsRegions, MouseRestrictions;
   int maxFirst_X1, maxFirst_X2, maxFirst_Y1, maxFirst_Y2;
   int maxSecond_X1, maxSecond_X2, maxSecond_Y1, maxSecond_Y2;
   region NonRectDead, OffDead1, OffDead2;
   Bool	IntelXinerama;
   Bool	SecondIsScrn0;
   ExtensionEntry *XineramaExtEntry;
   int I830XineramaVX, I830XineramaVY;
  
a401 2
   I830MemRange RotatedMem;
   I830MemRange RotatedMem2;
a402 2
   int InitialRotation;
   int displayWidth;
a404 1
   int *used3D;
d406 2
a407 1
   I830MemRange ContextMem;
d409 7
a415 3
   I830MemRange BackBuffer;
   I830MemRange DepthBuffer;
   I830MemRange TexMem;
d418 1
a418 1
   Bool have3DWindows;
d420 5
a424 5
   unsigned int front_tiled;
   unsigned int back_tiled;
   unsigned int depth_tiled;
   unsigned int rotated_tiled;
   unsigned int rotated2_tiled;
d429 3
a431 1
   Bool disableTiling;
d436 1
a436 7
   Bool CursorIsARGB;
   CursorPtr pCurs;

   int MonType1;
   int MonType2;
   Bool specifiedMonitor;

d447 3
d452 1
a456 2
   int GttBound;

d461 1
a461 2
   I830RegRec SavedReg;
   I830RegRec ModeReg;
d463 1
d466 1
a466 1
   Bool cursorOn;
d468 13
a480 1
   xf86CursorInfoPtr CursorInfoRec;
d483 5
d503 8
a528 1
   /* Stolen memory support */
a530 11
   /* Video BIOS support. */
   vbeInfoPtr pVbe;
   VbeInfoBlock *vbeInfo;
   VESAPtr vesa;

   Bool overrideBIOSMemSize;
   int saveBIOSMemSize;
   int newBIOSMemSize;
   Bool useSWF1;
   int saveSWF1;

a534 3
   /* Use BIOS call 0x5f05 to set the refresh rate. */
   Bool useExtendedRefresh;

a535 18
   int monitorSwitch;
   int operatingDevices;
   int toggleDevices;
   int savedDevices;
   int lastDevice0, lastDevice1, lastDevice2;

   /* These are indexed by the display types */
   Bool displayAttached[NumDisplayTypes];
   Bool displayPresent[NumDisplayTypes];
   BoxRec displaySize[NumDisplayTypes];

   /* [0] is Pipe A, [1] is Pipe B. */
   int availablePipes;
   int pipeDevices[MAX_DISPLAY_PIPES];
   /* [0] is display plane A, [1] is display plane B. */
   Bool pipeEnabled[MAX_DISPLAY_PIPES];
   BoxRec pipeDisplaySize[MAX_DISPLAY_PIPES];
   int planeEnabled[MAX_DISPLAY_PIPES];
a548 3
   Bool vbeRestoreWorkaround;
   Bool displayInfo;
   Bool devicePresence;
d552 74
a625 2
   CARD32 savedAsurf;
   CARD32 savedBsurf;
a628 1
#define I830REGPTR(p) (&(I830PTR(p)->ModeReg))
d633 1
a638 2
extern void I830PrintErrorState(ScrnInfoPtr pScrn);
extern void I965PrintErrorState(ScrnInfoPtr pScrn);
d641 1
d647 13
d661 10
a670 1
extern void I830RefreshRing(ScrnInfoPtr pScrn);
a672 2
extern Bool I830DGAInit(ScreenPtr pScreen);

d675 1
a675 2
extern void I830VideoSwitchModeBefore(ScrnInfoPtr pScrn, DisplayModePtr mode);
extern void I830VideoSwitchModeAfter(ScrnInfoPtr pScrn, DisplayModePtr mode);
d678 9
a686 2
extern Bool I830AllocateRotatedBuffer(ScrnInfoPtr pScrn, const int flags);
extern Bool I830AllocateRotated2Buffer(ScrnInfoPtr pScrn, const int flags);
a688 3
extern Bool I830AllocateBackBuffer(ScrnInfoPtr pScrn, const int flags);
extern Bool I830AllocateDepthBuffer(ScrnInfoPtr pScrn, const int flags);
extern Bool I830AllocateTextureMemory(ScrnInfoPtr pScrn, const int flags);
a695 3
extern Bool I830UpdateDRIBuffers(ScrnInfoPtr pScrn, drmI830Sarea *sarea);
extern void I830DRIUnmapScreenRegions(ScrnInfoPtr pScrn, drmI830Sarea *sarea);
extern Bool I830DRIMapScreenRegions(ScrnInfoPtr pScrn, drmI830Sarea *sarea);
d699 3
d704 2
d719 16
a734 1
extern void I830ResetAllocations(ScrnInfoPtr pScrn, const int flags);
d736 18
a753 10
extern long I830GetExcessMemoryAllocations(ScrnInfoPtr pScrn);
extern Bool I830Allocate2DMemory(ScrnInfoPtr pScrn, const int flags);
extern Bool I830DoPoolAllocation(ScrnInfoPtr pScrn, I830MemPool *pool);
extern Bool I830FixupOffsets(ScrnInfoPtr pScrn);
extern Bool I830BindAGPMemory(ScrnInfoPtr pScrn);
extern Bool I830UnbindAGPMemory(ScrnInfoPtr pScrn);
extern unsigned long I830AllocVidMem(ScrnInfoPtr pScrn, I830MemRange *result,
				     I830MemPool *pool, long size,
				     unsigned long alignment, int flags);
extern void I830FreeVidMem(ScrnInfoPtr pScrn, I830MemRange *range);
d755 2
a756 2
extern void I830PrintAllRegisters(I830RegPtr i830Reg);
extern void I830ReadAllRegisters(I830Ptr pI830, I830RegPtr i830Reg);
d758 2
a759 2
extern void I830ChangeFrontbuffer(ScrnInfoPtr pScrn,int buffer);
extern Bool I830IsPrimary(ScrnInfoPtr pScrn);
d761 2
a762 9
extern DisplayModePtr I830GetModePool(ScrnInfoPtr pScrn, vbeInfoPtr pVbe,
					VbeInfoBlock *vbe);
extern void I830SetModeParameters(ScrnInfoPtr pScrn, vbeInfoPtr pVbe);
extern void I830UnsetModeParameters(ScrnInfoPtr pScrn, vbeInfoPtr pVbe);
extern void I830PrintModes(ScrnInfoPtr pScrn);
extern int I830GetBestRefresh(ScrnInfoPtr pScrn, int refresh);
extern Bool I830CheckModeSupport(ScrnInfoPtr pScrn, int x, int y, int mode);
extern Bool I830Rotate(ScrnInfoPtr pScrn, DisplayModePtr mode);
extern Bool I830FixOffset(ScrnInfoPtr pScrn, I830MemRange *mem);
d765 3
d771 2
a772 5
/* i830_randr.c */
Bool I830RandRInit(ScreenPtr pScreen, int rotation);
Bool I830RandRSetConfig(ScreenPtr pScreen, Rotation rotation, int rate,
			RRScreenSizePtr pSize);
Rotation I830GetRotation(ScreenPtr pScreen);
d774 46
a819 7
/*
 * 12288 is set as the maximum, chosen because it is enough for
 * 1920x1440@@32bpp with a 2048 pixel line pitch with some to spare.
 */
#define I830_MAXIMUM_VBIOS_MEM		12288
#define I830_DEFAULT_VIDEOMEM_2D	(MB(32) / 1024)
#define I830_DEFAULT_VIDEOMEM_3D	(MB(64) / 1024)
d821 1
a821 13
/* Flags for memory allocation function */
#define FROM_ANYWHERE			0x00000000
#define FROM_POOL_ONLY			0x00000001
#define FROM_NEW_ONLY			0x00000002
#define FROM_MASK			0x0000000f

#define ALLOCATE_AT_TOP			0x00000010
#define ALLOCATE_AT_BOTTOM		0x00000020
#define FORCE_GAPS			0x00000040

#define NEED_PHYSICAL_ADDR		0x00000100
#define ALIGN_BOTH_ENDS			0x00000200
#define FORCE_LOW			0x00000400
d823 2
a824 2
#define ALLOC_NO_TILING			0x00001000
#define ALLOC_INITIAL			0x00002000
d826 6
a831 1
#define ALLOCATE_DRY_RUN		0x80000000
d837 8
@


1.1.1.1
log
@Importing xf86-video-i810 1.7.2
@
text
@@


1.1.1.2
log
@xf86-video-intel 1.7.3
@
text
@a109 7
#ifdef XF86DRI
#define I830_MM_MINPAGES 512
#define I830_MM_MAXSIZE  (32*1024)
#define I830_KERNEL_MM  (1 << 0) /* Initialize the kernel memory manager*/
#define I830_KERNEL_TEX (1 << 1) /* Allocate texture memory pool */
#endif

a287 2
   int mmModeFlags;
   int mmSize;
a574 6

/* 
 * Xserver MM compatibility. Remove code guarded by this when the
 * XServer contains the libdrm mm code
 */
#undef XSERVER_LIBDRM_MM
@


1.1.1.3
log
@xf86-video-intel 2.2.0
@
text
@d60 1
d62 1
a62 7
#include "xf86Crtc.h"
#include "xf86RandR12.h"

#include "xorg-server.h"
#ifdef XSERVER_LIBPCIACCESS
#include <pciaccess.h>
#endif
a65 3
#ifdef XF86DRI_MM
#include "xf86mm.h"
#endif
a70 2
#ifdef DAMAGE
#include "damage.h"
a71 14
#endif

#ifdef I830_USE_EXA
#include "exa.h"
Bool I830EXAInit(ScreenPtr pScreen);
#define EXA_LINEAR_EXTRA	(64*1024)
unsigned long long I830TexOffsetStart(PixmapPtr pPix);
#endif

#ifdef I830_USE_XAA
Bool I830XAAInit(ScreenPtr pScreen);
#endif

typedef struct _I830OutputRec I830OutputRec, *I830OutputPtr;
a73 2
#include "i830_sdvo.h"
#include "i2c_vid.h"
a74 1
/* I830 Video support */
d80 2
d87 23
d126 20
a145 66
enum tile_format {
    TILE_NONE,
    TILE_XMAJOR,
    TILE_YMAJOR
};

/** Record of a linear allocation in the aperture. */
typedef struct _i830_memory i830_memory;
struct _i830_memory {
    /** Offset of the allocation in card VM */
    unsigned long offset;
    /** End of the allocation in card VM */
    unsigned long end;
    /**
     * Requested size of the allocation: doesn't count padding.
     *
     * Any bound memory will cover offset to (offset + size).
     */
    unsigned long size;
    /**
     * Allocated aperture size, taking into account padding to allow for
     * tiling.
     */
    unsigned long allocated_size;
    /**
     * Physical (or more properly, bus) address of the allocation.
     * Only set if requested during allocation.
     */
    uint64_t bus_addr;
    /** AGP memory handle */
    int key;
    /**
     * Whether or not the AGP memory (if any) is currently bound.
     */
    Bool bound;
    /**
     * Offset that the AGP-allocated memory (if any) is to be bound to.
     *
     * This is either @@offset or pI830->stolen_size
     */
    unsigned long agp_offset;

    enum tile_format tiling;
    /**
     * Index of the fence register representing the tiled surface, when
     * bound.
     */
    int fence_nr;
    /** Pitch value in bytes for tiled surfaces */
    unsigned int pitch;

    /** Description of the allocation, for logging */
    char *name;

    /** @@{
     * Memory allocator linked list pointers
     */
    i830_memory *next;
    i830_memory *prev;
    /** @@} */

#ifdef XF86DRI_MM
    drmBO bo;
    Bool lifetime_fixed_offset;
#endif
};
d149 1
a149 1
   i830_memory *mem;
d157 4
d171 21
a191 126
/* store information about an Ixxx DVO */
/* The i830->i865 use multiple DVOs with multiple i2cs */
/* the i915, i945 have a single sDVO i2c bus - which is different */
#define MAX_OUTPUTS 6

#define I830_I2C_BUS_DVO 1
#define I830_I2C_BUS_SDVO 2

/* these are outputs from the chip - integrated only 
   external chips are via DVO or SDVO output */
#define I830_OUTPUT_UNUSED 0
#define I830_OUTPUT_ANALOG 1
#define I830_OUTPUT_DVO_TMDS 2
#define I830_OUTPUT_DVO_LVDS 3
#define I830_OUTPUT_DVO_TVOUT 4
#define I830_OUTPUT_SDVO 5
#define I830_OUTPUT_LVDS 6
#define I830_OUTPUT_TVOUT 7

struct _I830DVODriver {
   int type;
   char *modulename;
   char *fntablename;
   unsigned int dvo_reg;
   uint32_t gpio;
   int address;
   const char **symbols;
   I830I2CVidOutputRec *vid_rec;
   void *dev_priv;
   pointer modhandle;
   DisplayModePtr panel_fixed_mode;
   Bool panel_wants_dither;
};

extern const char *i830_output_type_names[];

typedef struct _I830CrtcPrivateRec {
    int			    pipe;
    int			    plane;

    Bool    		    enabled;
    
    int			    dpms_mode;
    
    /* Lookup table values to be set when the CRTC is enabled */
    CARD8 lut_r[256], lut_g[256], lut_b[256];

    i830_memory *rotate_mem;
    /* Card virtual address of the cursor */
    unsigned long cursor_offset;
    unsigned long cursor_argb_offset;
    /* Physical or virtual addresses of the cursor for setting in the cursor
     * registers.
     */
    uint64_t cursor_addr;
    unsigned long cursor_argb_addr;
    Bool	cursor_is_argb;
} I830CrtcPrivateRec, *I830CrtcPrivatePtr;

#define I830CrtcPrivate(c) ((I830CrtcPrivatePtr) (c)->driver_private)

typedef struct _I830OutputPrivateRec {
   int			    type;
   I2CBusPtr		    pI2CBus;
   I2CBusPtr		    pDDCBus;
   struct _I830DVODriver    *i2c_drv;
   Bool			    load_detect_temp;
   int                      pipe_mask;
   int			    clone_mask;
   /** Output-private structure.  Should replace i2c_drv */
   void			    *dev_priv;
} I830OutputPrivateRec, *I830OutputPrivatePtr;

#define I830OutputPrivate(o) ((I830OutputPrivatePtr) (o)->driver_private)

/** enumeration of 3d consumers so some can maintain invariant state. */
enum last_3d {
    LAST_3D_OTHER,
    LAST_3D_VIDEO,
    LAST_3D_RENDER,
    LAST_3D_ROTATION
};

/*
 * Backlight control has some unfortunate properties:
 *   - many machines won't give us brightness change notifications
 *     o brightness hotkeys
 *     o events like AC plug/unplug (can be controlled via _DOS setting)
 *     o ambient light sensor triggered changes
 *   - some machines use the so-called "legacy" backlight interface
 *     o resulting brightness is a combo of LBB and PWM values
 *     o LBB sits in config space
 *   - some machines have ACPI methods for changing brightness
 *     o one of the few ways the X server and firmware can stay in sync
 *   - new machines have the IGD OpRegion interface available
 *     o a reliable way of keeping the firmware and X in sync
 *
 * So the real problem is on machines where ACPI or OpRegion methods aren't
 * available.  In that case, problems can occur:
 *   1) the BIOS and X will have different ideas of what the brightness is,
 *      leading to unexpected results when the brightness is increased or
 *      decreased via hotkey or X protocol
 *   2) unless X takes the legacy register into account, machines using it
 *      may prevent X from raising the brightness above 0 if the firmware
 *      set LBB to 0
 * Given these problems, we provide the user with a selection of methods,
 * so they can choose an ideal one for their platform (assuming our quirk
 * code picks the wrong one).
 *
 * Four different methods are available:
 *   NATIVE:  only ever touch the native backlight control registers
 *     This method may be susceptible to problem (2) above if the firmware
 *     modifies the legacy registers.
 *   LEGACY:  only ever touch the legacy backlight control registers
 *     This method may be susceptible to problem (1) above if the firmware
 *     also modifies the legacy registers.
 *   COMBO:  try to use both sets
 *     In this case, the driver will try to modify both sets of registers
 *     if needed.  To avoid problem (2) above it may set the LBB register
 *     to a non-zero value if the brightness is to be increased.  It's still
 *     susceptible to problem (1), but to a lesser extent than the LEGACY only
 *     method.
 *   KERNEL:  use kernel methods for controlling the backlight
 *     This is only available on some platforms, but where present this can
 *     provide the best user experience.
 */
a192 6
enum backlight_control {
    NATIVE = 0,
    LEGACY,
    COMBO,
    KERNEL,
};
a195 1
   unsigned char *GTTBase;
d199 15
d215 1
d225 17
a241 1
   long GTTMapSize;
a242 25
   /**
    * Linked list of video memory allocations.  The head and tail are
    * dummy entries that bound the allocation area.
    */
   i830_memory *memory_list;
   /** Linked list of buffer object memory allocations */
   i830_memory *bo_list;
   long stolen_size;		/**< bytes of pre-bound stolen memory */
   int gtt_acquired;		/**< whether we currently own the AGP */

   i830_memory *front_buffer;
   i830_memory *front_buffer_2;
   i830_memory *compressed_front_buffer;
   i830_memory *compressed_ll_buffer;
   /* One big buffer for all cursors for kernels that support this */
   i830_memory *cursor_mem;
   /* separate small buffers for kernels that support this */
   i830_memory *cursor_mem_classic[2];
   i830_memory *cursor_mem_argb[2];
   i830_memory *xaa_scratch;
   i830_memory *xaa_scratch_2;
#ifdef I830_USE_EXA
   i830_memory *exa_offscreen;
   i830_memory *exa_965_state;
#endif
d244 2
d248 4
d254 2
a255 1
   i830_memory *overlay_regs;
d257 20
d278 2
d281 2
d285 1
d287 1
a287 2
   i830_memory *logical_context;

d289 3
a291 7
   i830_memory *back_buffer;
   i830_memory *third_buffer;
   i830_memory *depth_buffer;
   i830_memory *textures;		/**< Compatibility texture memory */
   i830_memory *memory_manager;		/**< DRI memory manager aperture */
   i830_memory *hw_status;		/* for G33 hw status page alloc */

d294 9
a302 7
   Bool allocate_classic_textures;

   Bool want_vblank_interrupts;
#ifdef DAMAGE
   DamagePtr pDamage;
   RegionRec driRegion;
#endif
d307 1
a307 3
   Bool TripleBuffer;
   Bool tiling;
   Bool fb_compression;
d312 7
a318 1
 
a328 3
#if XSERVER_LIBPCIACCESS
   struct pci_device *PciInfo;
#else
a330 1
#endif
d335 2
d341 2
a342 1
   Bool fence_used[FENCE_NEW_NR];
a343 1
   Bool useEXA;
d346 1
a346 1
#ifdef I830_USE_XAA
d348 1
a348 13

   /* additional XAA accelerated Composite support */
   CompositeProcPtr saved_composite;
   Bool (*xaa_check_composite)(int op, PicturePtr pSrc, PicturePtr pMask,
			       PicturePtr pDst);
   Bool (*xaa_prepare_composite)(int op, PicturePtr pSrc, PicturePtr pMask,
				 PicturePtr pDst, PixmapPtr pSrcPixmap,
				 PixmapPtr pMaskPixmap, PixmapPtr pDstPixmap);
   void (*xaa_composite)(PixmapPtr pDst, int xSrc, int ySrc,
			 int xMask, int yMask, int xDst, int yDst,
			 int w, int h);
   void (*xaa_done_composite)(PixmapPtr pDst);
#endif
a350 5
#ifdef I830_USE_EXA
   ExaDriverPtr	EXADriverPtr;
   PixmapPtr pSrcPixmap;
#endif

a365 8
   /* EXA render state */
   float scale_units[2][2];
  /** Transform pointers for src/mask, or NULL if identity */
   PictTransform *transform[2];
   /* i915 EXA render state */
   CARD32 mapstate[6];
   CARD32 samplerstate[6];

d384 1
d387 11
d402 3
d406 18
d437 3
d443 2
a444 73
   int ddc2;

   enum backlight_control backlight_control_method;

   CARD32 saveDSPACNTR;
   CARD32 saveDSPBCNTR;
   CARD32 savePIPEACONF;
   CARD32 savePIPEBCONF;
   CARD32 savePIPEASRC;
   CARD32 savePIPEBSRC;
   CARD32 saveFPA0;
   CARD32 saveFPA1;
   CARD32 saveDPLL_A;
   CARD32 saveDPLL_A_MD;
   CARD32 saveHTOTAL_A;
   CARD32 saveHBLANK_A;
   CARD32 saveHSYNC_A;
   CARD32 saveVTOTAL_A;
   CARD32 saveVBLANK_A;
   CARD32 saveVSYNC_A;
   CARD32 saveBCLRPAT_A;
   CARD32 saveDSPASTRIDE;
   CARD32 saveDSPASIZE;
   CARD32 saveDSPAPOS;
   CARD32 saveDSPABASE;
   CARD32 saveDSPASURF;
   CARD32 saveDSPATILEOFF;
   CARD32 saveFPB0;
   CARD32 saveFPB1;
   CARD32 saveDPLL_B;
   CARD32 saveDPLL_B_MD;
   CARD32 saveHTOTAL_B;
   CARD32 saveHBLANK_B;
   CARD32 saveHSYNC_B;
   CARD32 saveVTOTAL_B;
   CARD32 saveVBLANK_B;
   CARD32 saveVSYNC_B;
   CARD32 saveBCLRPAT_B;
   CARD32 saveDSPBSTRIDE;
   CARD32 saveDSPBSIZE;
   CARD32 saveDSPBPOS;
   CARD32 saveDSPBBASE;
   CARD32 saveDSPBSURF;
   CARD32 saveDSPBTILEOFF;
   CARD32 saveVCLK_DIVISOR_VGA0;
   CARD32 saveVCLK_DIVISOR_VGA1;
   CARD32 saveVCLK_POST_DIV;
   CARD32 saveVGACNTRL;
   CARD32 saveADPA;
   CARD32 saveLVDS;
   CARD32 saveDVOA;
   CARD32 saveDVOB;
   CARD32 saveDVOC;
   CARD32 savePP_ON;
   CARD32 savePP_OFF;
   CARD32 savePP_CONTROL;
   CARD32 savePP_CYCLE;
   CARD32 savePFIT_CONTROL;
   CARD32 savePaletteA[256];
   CARD32 savePaletteB[256];
   CARD32 saveSWF[17];
   CARD32 saveBLC_PWM_CTL;
   CARD32 saveBLC_PWM_CTL2;
   CARD32 saveFBC_CFB_BASE;
   CARD32 saveFBC_LL_BASE;
   CARD32 saveFBC_CONTROL2;
   CARD32 saveFBC_CONTROL;

   enum last_3d *last_3d;

   /** Enables logging of debug output related to mode switching. */
   Bool debug_modes;
   unsigned int quirk_flag;
d448 1
a452 1
#define I830_SELECT_THIRD	3
d458 2
a461 1
extern void I830SetPipeCursor (xf86CrtcPtr crtc, Bool force);
a466 1
void i830_update_cursor_offsets(ScrnInfoPtr pScrn);
d468 2
a469 11
/* CRTC-based cursor functions */
void
i830_crtc_load_cursor_image (xf86CrtcPtr crtc, unsigned char *src);

#ifdef ARGB_CURSOR
void
i830_crtc_load_cursor_argb (xf86CrtcPtr crtc, CARD32 *image);
#endif

void
i830_crtc_set_cursor_position (xf86CrtcPtr crtc, int x, int y);
d471 1
a471 11
void
i830_crtc_show_cursor (xf86CrtcPtr crtc);

void
i830_crtc_hide_cursor (xf86CrtcPtr crtc);

void
i830_crtc_set_cursor_colors (xf86CrtcPtr crtc, int bg, int fg);

extern void i830_refresh_ring(ScrnInfoPtr pScrn);
extern void I830EmitFlush(ScrnInfoPtr pScrn);
d475 2
a476 1
extern void i830_crtc_dpms_video(xf86CrtcPtr crtc, Bool on);
d479 2
a480 9
int
i830_crtc_pipe (xf86CrtcPtr crtc);

Bool
i830_pipe_a_require_activate (ScrnInfoPtr scrn);

void
i830_pipe_a_require_deactivate (ScrnInfoPtr scrn);

d483 3
d493 3
a498 1
Bool i830_update_dri_buffers(ScrnInfoPtr pScrn);
a500 2
unsigned long intel_get_pixmap_offset(PixmapPtr pPix);
unsigned long intel_get_pixmap_pitch(PixmapPtr pPix);
d514 1
a514 16
Bool i830_allocator_init(ScrnInfoPtr pScrn, unsigned long offset,
			 unsigned long size);
void i830_allocator_fini(ScrnInfoPtr pScrn);
i830_memory * i830_allocate_memory(ScrnInfoPtr pScrn, const char *name,
				   unsigned long size, unsigned long alignment,
				   int flags);
i830_memory *i830_allocate_memory_tiled(ScrnInfoPtr pScrn, const char *name,
					unsigned long size,
					unsigned long pitch,
					unsigned long alignment, int flags,
					enum tile_format tile_format);
void i830_describe_allocations(ScrnInfoPtr pScrn, int verbosity,
			       const char *prefix);
void i830_reset_allocations(ScrnInfoPtr pScrn);
void i830_free_3d_memory(ScrnInfoPtr pScrn);
void i830_free_memory(ScrnInfoPtr pScrn, i830_memory *mem);
d516 10
a525 3
Bool i830_allocate_2d_memory(ScrnInfoPtr pScrn);
Bool i830_allocate_texture_memory(ScrnInfoPtr pScrn);
Bool i830_allocate_3d_memory(ScrnInfoPtr pScrn);
d527 4
d533 9
a541 21
extern Bool I830I2CInit(ScrnInfoPtr pScrn, I2CBusPtr *bus_ptr, int i2c_reg,
			char *name);

/* return a mask of output indices matching outputs against type_mask */
int i830_output_clones (ScrnInfoPtr pScrn, int type_mask);

/* i830_display.c */
Bool
i830PipeHasType (xf86CrtcPtr crtc, int type);

/* i830_crt.c */
void i830_crt_init(ScrnInfoPtr pScrn);

/* i830_dvo.c */
void i830_dvo_init(ScrnInfoPtr pScrn);

/* i830_lvds.c */
void i830_lvds_init(ScrnInfoPtr pScrn);

extern void i830MarkSync(ScrnInfoPtr pScrn);
extern void i830WaitSync(ScrnInfoPtr pScrn);
a543 3
Bool i830_bind_all_memory(ScrnInfoPtr pScrn);
Bool i830_unbind_all_memory(ScrnInfoPtr pScrn);

d547 5
a551 2
/* i830_modes.c */
DisplayModePtr i830_ddc_get_modes(xf86OutputPtr output);
d553 7
a559 2
/* i830_tv.c */
void i830_tv_init(ScrnInfoPtr pScrn);
d561 13
a573 45
/* i830_render.c */
Bool i830_check_composite(int op, PicturePtr pSrc, PicturePtr pMask,
			  PicturePtr pDst);
Bool i830_prepare_composite(int op, PicturePtr pSrc, PicturePtr pMask,
			    PicturePtr pDst, PixmapPtr pSrcPixmap,
			    PixmapPtr pMaskPixmap, PixmapPtr pDstPixmap);
void i830_composite(PixmapPtr pDst, int srcX, int srcY,
		    int maskX, int maskY, int dstX, int dstY, int w, int h);
void i830_done_composite(PixmapPtr pDst);
/* i915_render.c */
Bool i915_check_composite(int op, PicturePtr pSrc, PicturePtr pMask,
			  PicturePtr pDst);
Bool i915_prepare_composite(int op, PicturePtr pSrc, PicturePtr pMask,
			    PicturePtr pDst, PixmapPtr pSrcPixmap,
			    PixmapPtr pMaskPixmap, PixmapPtr pDstPixmap);
/* i965_render.c */
Bool i965_check_composite(int op, PicturePtr pSrc, PicturePtr pMask,
			  PicturePtr pDst);
Bool i965_prepare_composite(int op, PicturePtr pSrc, PicturePtr pMask,
			    PicturePtr pDst, PixmapPtr pSrcPixmap,
			    PixmapPtr pMaskPixmap, PixmapPtr pDstPixmap);
void i965_composite(PixmapPtr pDst, int srcX, int srcY,
		    int maskX, int maskY, int dstX, int dstY, int w, int h);

void
i830_get_transformed_coordinates(int x, int y, PictTransformPtr transform,
				 float *x_out, float *y_out);

void i830_enter_render(ScrnInfoPtr);

static inline int i830_fb_compression_supported(I830Ptr pI830)
{
    if (!IS_MOBILE(pI830))
	return FALSE;
    if (IS_I810(pI830) || IS_I815(pI830) || IS_I830(pI830))
	return FALSE;
    /* fbc depends on tiled surface. And we don't support tiled
     * front buffer with XAA now.
     */
    if (!pI830->tiling || (IS_I965G(pI830) && !pI830->useEXA))
	return FALSE;
    return TRUE;
}

Bool i830_pixmap_tiled(PixmapPtr p);
d575 2
a576 2
extern const int I830PatternROP[16];
extern const int I830CopyROP[16];
d578 1
a578 6
/* Flags for memory allocation function */
#define NEED_PHYSICAL_ADDR		0x00000001
#define ALIGN_BOTH_ENDS			0x00000002
#define NEED_NON_STOLEN			0x00000004
#define NEED_LIFETIME_FIXED		0x00000008
#define ALLOW_SHARING			0x00000010
d585 5
a589 5
/* quirk flag definition */
#define QUIRK_IGNORE_TV			0x00000001
#define QUIRK_IGNORE_LVDS		0x00000002
#define QUIRK_IGNORE_MACMINI_LVDS 	0x00000004
extern void i830_fixup_devices(ScrnInfoPtr);
@


1.1.1.4
log
@Import intel driver v 2.2.0.90. tested by many, including krw@@ kettenis@@,
jakemsr@@, landry@@, beck@@ and oga@@. Thanks.
@
text
@a42 2
#include <stdint.h>

d324 2
a325 2
 * Four different backlight control methods are available:
 *   BCM_NATIVE:  only ever touch the native backlight control registers
d328 1
a328 1
 *   BCM_LEGACY:  only ever touch the legacy backlight control registers
d331 1
a331 1
 *   BCM_COMBO:  try to use both sets
d337 1
a337 1
 *   BCM_KERNEL:  use kernel methods for controlling the backlight
d343 4
a346 4
    BCM_NATIVE = 0,
    BCM_LEGACY,
    BCM_COMBO,
    BCM_KERNEL,
a616 1
   CARD32 saveFBC_FENCE_OFF;
a836 1
#define QUIRK_PIPEA_FORCE		0x00000008
@


