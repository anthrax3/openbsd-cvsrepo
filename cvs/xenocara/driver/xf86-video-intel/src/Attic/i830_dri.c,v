head	1.14;
access;
symbols
	OPENBSD_5_0:1.13.0.6
	OPENBSD_5_0_BASE:1.13
	OPENBSD_4_9:1.13.0.2
	OPENBSD_4_9_BASE:1.13
	OPENBSD_4_8:1.13.0.4
	OPENBSD_4_8_BASE:1.13
	OPENBSD_4_7:1.10.0.2
	OPENBSD_4_7_BASE:1.10
	OPENBSD_4_6:1.9.0.2
	OPENBSD_4_6_BASE:1.9
	OPENBSD_4_5:1.8.0.2
	OPENBSD_4_5_BASE:1.8
	OPENBSD_4_4:1.6.0.2
	OPENBSD_4_4_BASE:1.6
	OPENBSD_4_3_BASE:1.4
	OPENBSD_4_3:1.4.0.2
	v2_2_0_90:1.1.1.4
	v2_2_0:1.1.1.3
	OPENBSD_4_2:1.2.0.2
	OPENBSD_4_2_BASE:1.2
	v1_7_4:1.1.1.2
	v1_7_3:1.1.1.2
	v1_7_2:1.1.1.1
	xorg:1.1.1;
locks; strict;
comment	@ * @;


1.14
date	2011.11.29.12.39.02;	author oga;	state dead;
branches;
next	1.13;

1.13
date	2010.07.18.14.47.47;	author oga;	state Exp;
branches;
next	1.12;

1.12
date	2010.05.23.21.28.34;	author oga;	state Exp;
branches;
next	1.11;

1.11
date	2010.05.10.22.32.29;	author oga;	state Exp;
branches;
next	1.10;

1.10
date	2009.08.06.16.02.07;	author oga;	state Exp;
branches;
next	1.9;

1.9
date	2009.06.25.20.16.43;	author matthieu;	state Exp;
branches;
next	1.8;

1.8
date	2009.01.10.15.06.18;	author oga;	state Exp;
branches;
next	1.7;

1.7
date	2008.10.12.15.20.50;	author matthieu;	state Exp;
branches;
next	1.6;

1.6
date	2008.05.21.20.19.52;	author matthieu;	state Exp;
branches;
next	1.5;

1.5
date	2008.03.30.13.51.30;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2008.02.11.20.16.03;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2007.11.24.20.08.18;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2007.08.04.19.55.21;	author reyk;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.26.20.06.47;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.11.26.20.06.47;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2006.12.16.21.02.00;	author matthieu;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2007.11.24.19.44.48;	author matthieu;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2008.02.11.20.10.11;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.14
log
@Update the intel driver to a more recent version based on more recent
upsteam code.

Backporting keeping UMS changes by me, some bugfixes from kettenis@@.

Has been in snapshots for a while, committed on request so we can be
sure what people are running. This is a prerequesite for sandybridge
support but has those chipsets disabled for now until the correct code
has been added.
@
text
@/**************************************************************************

Copyright 2001 VA Linux Systems Inc., Fremont, California.
Copyright Â© 2002 by David Dawes

All Rights Reserved.

Permission is hereby granted, free of charge, to any person obtaining a
copy of this software and associated documentation files (the "Software"),
to deal in the Software without restriction, including without limitation
on the rights to use, copy, modify, merge, publish, distribute, sub
license, and/or sell copies of the Software, and to permit persons to whom
the Software is furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice (including the next
paragraph) shall be included in all copies or substantial portions of the
Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT. IN NO EVENT SHALL
ATI, VA LINUX SYSTEMS AND/OR THEIR SUPPLIERS BE LIABLE FOR ANY CLAIM,
DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
USE OR OTHER DEALINGS IN THE SOFTWARE.

**************************************************************************/

/*
 * Authors: Jeff Hartmann <jhartmann@@valinux.com>
 *          David Dawes <dawes@@xfree86.org>
 *          Keith Whitwell <keith@@tungstengraphics.com>
 */

#ifdef HAVE_CONFIG_H
#include "config.h"
#endif

#include <stdio.h>
#include <string.h>
#include <assert.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <sys/ioctl.h>
#include <unistd.h>
#include <fcntl.h>
#include <sys/time.h>
#include <time.h>
#include <errno.h>

#include "xf86.h"
#include "xf86_OSproc.h"
#include "xf86Priv.h"

#include "xf86PciInfo.h"
#include "xf86Pci.h"

#include "windowstr.h"
#include "shadow.h"

#include "GL/glxtokens.h"

#include "i830.h"

#include "i915_drm.h"

#include "dri2.h"

#ifdef DRI2
#if DRI2INFOREC_VERSION >= 1
#define USE_DRI2_1_1_0
#endif

extern XF86ModuleData dri2ModuleData;
#endif

typedef struct {
	int refcnt;
	PixmapPtr pixmap;
	unsigned int attachment;
} I830DRI2BufferPrivateRec, *I830DRI2BufferPrivatePtr;

#ifndef USE_DRI2_1_1_0
static DRI2BufferPtr
I830DRI2CreateBuffers(DrawablePtr drawable, unsigned int *attachments,
		      int count)
{
	ScreenPtr screen = drawable->pScreen;
	ScrnInfoPtr scrn = xf86Screens[screen->myNum];
	intel_screen_private *intel = intel_get_screen_private(scrn);
	DRI2BufferPtr buffers;
	dri_bo *bo;
	int i;
	I830DRI2BufferPrivatePtr privates;
	PixmapPtr pixmap, pDepthPixmap;

	buffers = calloc(count, sizeof *buffers);
	if (buffers == NULL)
		return NULL;
	privates = calloc(count, sizeof *privates);
	if (privates == NULL) {
		free(buffers);
		return NULL;
	}

	pDepthPixmap = NULL;
	for (i = 0; i < count; i++) {
		if (attachments[i] == DRI2BufferFrontLeft) {
			pixmap = get_drawable_pixmap(drawable);
			pixmap->refcnt++;
		} else if (attachments[i] == DRI2BufferStencil && pDepthPixmap) {
			pixmap = pDepthPixmap;
			pixmap->refcnt++;
		} else {
			unsigned int hint = 0;

			switch (attachments[i]) {
			case DRI2BufferDepth:
				if (SUPPORTS_YTILING(intel))
					hint = INTEL_CREATE_PIXMAP_TILING_Y;
				else
					hint = INTEL_CREATE_PIXMAP_TILING_X;
				break;
			case DRI2BufferFakeFrontLeft:
			case DRI2BufferFakeFrontRight:
			case DRI2BufferBackLeft:
			case DRI2BufferBackRight:
				hint = INTEL_CREATE_PIXMAP_TILING_X;
				break;
			}

			if (!intel->tiling)
				hint = 0;

			pixmap = screen->CreatePixmap(screen,
						      drawable->width,
						      drawable->height,
						      drawable->depth,
						      hint);

		}

		if (attachments[i] == DRI2BufferDepth)
			pDepthPixmap = pixmap;

		buffers[i].attachment = attachments[i];
		buffers[i].pitch = pixmap->devKind;
		buffers[i].cpp = pixmap->drawable.bitsPerPixel / 8;
		buffers[i].driverPrivate = &privates[i];
		buffers[i].flags = 0;	/* not tiled */
		privates[i].refcnt = 1;
		privates[i].pixmap = pixmap;
		privates[i].attachment = attachments[i];

		bo = i830_get_pixmap_bo(pixmap);
		if (bo != NULL && dri_bo_flink(bo, &buffers[i].name) != 0) {
			/* failed to name buffer */
		}
	}

	return buffers;
}

#else

static DRI2Buffer2Ptr
I830DRI2CreateBuffer(DrawablePtr drawable, unsigned int attachment,
		     unsigned int format)
{
	ScreenPtr screen = drawable->pScreen;
	ScrnInfoPtr scrn = xf86Screens[screen->myNum];
	intel_screen_private *intel = intel_get_screen_private(scrn);
	DRI2Buffer2Ptr buffer;
	dri_bo *bo;
	I830DRI2BufferPrivatePtr privates;
	PixmapPtr pixmap;

	buffer = calloc(1, sizeof *buffer);
	if (buffer == NULL)
		return NULL;
	privates = calloc(1, sizeof *privates);
	if (privates == NULL) {
		free(buffer);
		return NULL;
	}

	if (attachment == DRI2BufferFrontLeft) {
		pixmap = get_drawable_pixmap(drawable);
		pixmap->refcnt++;
	} else {
		unsigned int hint = 0;

		switch (attachment) {
		case DRI2BufferDepth:
		case DRI2BufferDepthStencil:
			if (SUPPORTS_YTILING(intel))
				hint = INTEL_CREATE_PIXMAP_TILING_Y;
			else
				hint = INTEL_CREATE_PIXMAP_TILING_X;
			break;
		case DRI2BufferFakeFrontLeft:
		case DRI2BufferFakeFrontRight:
		case DRI2BufferBackLeft:
		case DRI2BufferBackRight:
			hint = INTEL_CREATE_PIXMAP_TILING_X;
			break;
		}

		if (!intel->tiling)
			hint = 0;

		pixmap = screen->CreatePixmap(screen,
					      drawable->width,
					      drawable->height,
					      (format != 0) ? format :
							      drawable->depth,
					      hint);
		if (pixmap == NULL) {
			free(privates);
			free(buffer);
			return NULL;
		}

	}

	buffer->attachment = attachment;
	buffer->pitch = pixmap->devKind;
	buffer->cpp = pixmap->drawable.bitsPerPixel / 8;
	buffer->driverPrivate = privates;
	buffer->format = format;
	buffer->flags = 0;	/* not tiled */
	privates->refcnt = 1;
	privates->pixmap = pixmap;
	privates->attachment = attachment;

	bo = i830_get_pixmap_bo(pixmap);
	if (bo == NULL || dri_bo_flink(bo, &buffer->name) != 0) {
		/* failed to name buffer */
		screen->DestroyPixmap(pixmap);
		free(privates);
		free(buffer);
		return NULL;
	}

	return buffer;
}

#endif

#ifndef USE_DRI2_1_1_0

static void
I830DRI2DestroyBuffers(DrawablePtr drawable, DRI2BufferPtr buffers, int count)
{
	ScreenPtr screen = drawable->pScreen;
	I830DRI2BufferPrivatePtr private;
	int i;

	for (i = 0; i < count; i++) {
		private = buffers[i].driverPrivate;
		screen->DestroyPixmap(private->pixmap);
	}

	if (buffers) {
		free(buffers[0].driverPrivate);
		free(buffers);
	}
}

#else

static void I830DRI2DestroyBuffer(DrawablePtr drawable, DRI2Buffer2Ptr buffer)
{
	if (buffer) {
		I830DRI2BufferPrivatePtr private = buffer->driverPrivate;
		if (--private->refcnt == 0) {
			ScreenPtr screen = private->pixmap->drawable.pScreen;

			screen->DestroyPixmap(private->pixmap);

			free(private);
			free(buffer);
		}
	}
}

#endif

static void I830DRI2ReferenceBuffer(DRI2Buffer2Ptr buffer)
{
	if (buffer) {
		I830DRI2BufferPrivatePtr private = buffer->driverPrivate;
		private->refcnt++;
	}
}

static void
I830DRI2CopyRegion(DrawablePtr drawable, RegionPtr pRegion,
		   DRI2BufferPtr destBuffer, DRI2BufferPtr sourceBuffer)
{
	I830DRI2BufferPrivatePtr srcPrivate = sourceBuffer->driverPrivate;
	I830DRI2BufferPrivatePtr dstPrivate = destBuffer->driverPrivate;
	ScreenPtr screen = drawable->pScreen;
	ScrnInfoPtr scrn = xf86Screens[screen->myNum];
	intel_screen_private *intel = intel_get_screen_private(scrn);
	DrawablePtr src = (srcPrivate->attachment == DRI2BufferFrontLeft)
	    ? drawable : &srcPrivate->pixmap->drawable;
	DrawablePtr dst = (dstPrivate->attachment == DRI2BufferFrontLeft)
	    ? drawable : &dstPrivate->pixmap->drawable;
	RegionPtr pCopyClip;
	GCPtr gc;

	gc = GetScratchGC(dst->depth, screen);
	if (!gc)
		return;

	pCopyClip = REGION_CREATE(screen, NULL, 0);
	REGION_COPY(screen, pCopyClip, pRegion);
	(*gc->funcs->ChangeClip) (gc, CT_REGION, pCopyClip, 0);
	ValidateGC(dst, gc);

	/* Wait for the scanline to be outside the region to be copied */
	if (pixmap_is_scanout(get_drawable_pixmap(dst))
	    && intel->swapbuffers_wait) {
		BoxPtr box;
		BoxRec crtcbox;
		int y1, y2;
		int pipe = -1, event, load_scan_lines_pipe;
		xf86CrtcPtr crtc;
		Bool full_height = FALSE;

		box = REGION_EXTENTS(unused, gc->pCompositeClip);
		crtc = i830_covering_crtc(scrn, box, NULL, &crtcbox);

		/*
		 * Make sure the CRTC is valid and this is the real front
		 * buffer
		 */
		if (crtc != NULL && !crtc->rotatedData) {
			pipe = i830_crtc_to_pipe(crtc);

			/*
			 * Make sure we don't wait for a scanline that will
			 * never occur
			 */
			y1 = (crtcbox.y1 <= box->y1) ? box->y1 - crtcbox.y1 : 0;
			y2 = (box->y2 <= crtcbox.y2) ?
			    box->y2 - crtcbox.y1 : crtcbox.y2 - crtcbox.y1;

			if (y1 == 0 && y2 == (crtcbox.y2 - crtcbox.y1))
			    full_height = TRUE;

			/*
			 * Pre-965 doesn't have SVBLANK, so we need a bit
			 * of extra time for the blitter to start up and
			 * do its job for a full height blit
			 */
			if (full_height && !IS_I965G(intel))
			    y2 -= 2;

			if (pipe == 0) {
				event = MI_WAIT_FOR_PIPEA_SCAN_LINE_WINDOW;
				load_scan_lines_pipe =
				    MI_LOAD_SCAN_LINES_DISPLAY_PIPEA;
				if (full_height && IS_I965G(intel))
				    event = MI_WAIT_FOR_PIPEA_SVBLANK;
			} else {
				event = MI_WAIT_FOR_PIPEB_SCAN_LINE_WINDOW;
				load_scan_lines_pipe =
				    MI_LOAD_SCAN_LINES_DISPLAY_PIPEB;
				if (full_height && IS_I965G(intel))
				    event = MI_WAIT_FOR_PIPEB_SVBLANK;
			}

			BEGIN_BATCH(5);
			/*
			 * The documentation says that the LOAD_SCAN_LINES
			 * command always comes in pairs. Don't ask me why.
			 */
			OUT_BATCH(MI_LOAD_SCAN_LINES_INCL |
				  load_scan_lines_pipe);
			OUT_BATCH((y1 << 16) | y2);
			OUT_BATCH(MI_LOAD_SCAN_LINES_INCL |
				  load_scan_lines_pipe);
			OUT_BATCH((y1 << 16) | y2);
			OUT_BATCH(MI_WAIT_FOR_EVENT | event);
			ADVANCE_BATCH();
		}
	}

	(*gc->ops->CopyArea) (src, dst,
			       gc,
			       0, 0,
			       drawable->width, drawable->height,
			       0, 0);
	FreeScratchGC(gc);

	/* Emit a flush of the rendering cache, or on the 965 and beyond
	 * rendering results may not hit the framebuffer until significantly
	 * later.
	 *
	 * We can't rely on getting into the block handler before the DRI
	 * client gets to run again so flush now.
	 */
	intel_batch_submit(scrn, TRUE);
	drmCommandNone(intel->drmSubFD, DRM_I915_GEM_THROTTLE);
}

#if DRI2INFOREC_VERSION >= 4

enum DRI2FrameEventType {
	DRI2_SWAP,
	DRI2_FLIP,
	DRI2_WAITMSC,
};

typedef struct _DRI2FrameEvent {
	XID drawable_id;
	ClientPtr client;
	enum DRI2FrameEventType type;
	int frame;

	/* for swaps & flips only */
	DRI2SwapEventPtr event_complete;
	void *event_data;
	DRI2BufferPtr front;
	DRI2BufferPtr back;
} DRI2FrameEventRec, *DRI2FrameEventPtr;

static int
I830DRI2DrawablePipe(DrawablePtr pDraw)
{
	ScreenPtr pScreen = pDraw->pScreen;
	ScrnInfoPtr pScrn = xf86Screens[pScreen->myNum];
	BoxRec box, crtcbox;
	xf86CrtcPtr crtc;
	int pipe = -1;

	box.x1 = pDraw->x;
	box.y1 = pDraw->y;
	box.x2 = box.x1 + pDraw->width;
	box.y2 = box.y1 + pDraw->height;

	crtc = i830_covering_crtc(pScrn, &box, NULL, &crtcbox);

	/* Make sure the CRTC is valid and this is the real front buffer */
	if (crtc != NULL && !crtc->rotatedData)
		pipe = i830_crtc_to_pipe(crtc);

	return pipe;
}

static void
I830DRI2ExchangeBuffers(DrawablePtr draw, DRI2BufferPtr front,
			DRI2BufferPtr back)
{
	I830DRI2BufferPrivatePtr front_priv, back_priv;
	struct intel_pixmap *front_intel, *back_intel;
	ScreenPtr screen;
	intel_screen_private *intel;
	int tmp;

	front_priv = front->driverPrivate;
	back_priv = back->driverPrivate;

	/* Swap BO names so DRI works */
	tmp = front->name;
	front->name = back->name;
	back->name = tmp;

	/* Swap pixmap bos */
	front_intel = i830_get_pixmap_intel(front_priv->pixmap);
	back_intel = i830_get_pixmap_intel(back_priv->pixmap);
	i830_set_pixmap_intel(front_priv->pixmap, back_intel);
	i830_set_pixmap_intel(back_priv->pixmap, front_intel); /* should be screen */

	/* Do we need to update the Screen? */
	screen = draw->pScreen;
	intel = intel_get_screen_private(xf86Screens[screen->myNum]);
	if (front_intel->bo == intel->front_buffer->bo) {
	    dri_bo_unreference (intel->front_buffer->bo);
	    intel->front_buffer->bo = back_intel->bo;
	    dri_bo_reference (intel->front_buffer->bo);
	    i830_set_pixmap_intel(screen->GetScreenPixmap(screen),
				  back_intel);
	}
}

#ifdef notyet
void I830DRI2FrameEventHandler(unsigned int frame, unsigned int tv_sec,
			       unsigned int tv_usec, void *event_data)
{
	DRI2FrameEventPtr event = event_data;
	DrawablePtr drawable;
	ScreenPtr screen;
	ScrnInfoPtr scrn;
	intel_screen_private *intel;
	int status;

	status = dixLookupDrawable(&drawable, event->drawable_id, serverClient,
				   M_ANY, DixWriteAccess);
	if (status != Success) {
		I830DRI2DestroyBuffer(NULL, event->front);
		I830DRI2DestroyBuffer(NULL, event->back);
		free(event);
		return;
	}

	screen = drawable->pScreen;
	scrn = xf86Screens[screen->myNum];
	intel = intel_get_screen_private(scrn);

	switch (event->type) {
	case DRI2_SWAP: {
		int swap_type;

		if (DRI2CanExchange(drawable)) {
			I830DRI2ExchangeBuffers(drawable,
						event->front, event->back);
			swap_type = DRI2_EXCHANGE_COMPLETE;
		} else {
			BoxRec	    box;
			RegionRec	    region;

			box.x1 = 0;
			box.y1 = 0;
			box.x2 = drawable->width;
			box.y2 = drawable->height;
			REGION_INIT(pScreen, &region, &box, 0);

			I830DRI2CopyRegion(drawable,
					   &region, event->front, event->back);
			swap_type = DRI2_BLIT_COMPLETE;
		}
		DRI2SwapComplete(event->client, drawable, frame, tv_sec, tv_usec,
				 swap_type,
				 event->event_complete, event->event_data);
		break;
	}
	case DRI2_WAITMSC:
		DRI2WaitMSCComplete(event->client, drawable,
				    frame, tv_sec, tv_usec);
		break;
	default:
		xf86DrvMsg(scrn->scrnIndex, X_WARNING,
			   "%s: unknown vblank event received\n", __func__);
		/* Unknown type */
		break;
	}

	I830DRI2DestroyBuffer(drawable, event->front);
	I830DRI2DestroyBuffer(drawable, event->back);
	free(event);
}

void I830DRI2FlipEventHandler(unsigned int frame, unsigned int tv_sec,
			      unsigned int tv_usec, void *event_data)
{
	DRI2FrameEventPtr flip = event_data;
	DrawablePtr drawable;
	ScreenPtr screen;
	ScrnInfoPtr scrn;
	int status;

	status = dixLookupDrawable(&drawable, flip->drawable_id, serverClient,
				     M_ANY, DixWriteAccess);
	if (status != Success) {
		free(flip);
		return;
	}

	screen = drawable->pScreen;
	scrn = xf86Screens[screen->myNum];

	/* We assume our flips arrive in order, so we don't check the frame */
	switch (flip->type) {
	case DRI2_SWAP:
		DRI2SwapComplete(flip->client, drawable, frame, tv_sec, tv_usec,
				 DRI2_FLIP_COMPLETE, flip->event_complete,
				 flip->event_data);
	break;
	default:
		xf86DrvMsg(scrn->scrnIndex, X_WARNING,
			   "%s: unknown vblank event received\n", __func__);
		/* Unknown type */
		break;
	}

	free(flip);
}

/*
 * ScheduleSwap is responsible for requesting a DRM vblank event for the
 * appropriate frame.
 *
 * In the case of a blit (e.g. for a windowed swap) or buffer exchange,
 * the vblank requested can simply be the last queued swap frame + the swap
 * interval for the drawable.
 *
 * In the case of a page flip, we request an event for the last queued swap
 * frame + swap interval - 1, since we'll need to queue the flip for the frame
 * immediately following the received event.
 *
 * The client will be blocked if it tries to perform further GL commands
 * after queueing a swap, though in the Intel case after queueing a flip, the
 * client is free to queue more commands; they'll block in the kernel if
 * they access buffers busy with the flip.
 *
 * When the swap is complete, the driver should call into the server so it
 * can send any swap complete events that have been requested.
 */
static int
I830DRI2ScheduleSwap(ClientPtr client, DrawablePtr draw, DRI2BufferPtr front,
		     DRI2BufferPtr back, CARD64 *target_msc, CARD64 divisor,
		     CARD64 remainder, DRI2SwapEventPtr func, void *data)
{
	ScreenPtr screen = draw->pScreen;
	ScrnInfoPtr scrn = xf86Screens[screen->myNum];
	intel_screen_private *intel = intel_get_screen_private(scrn);
	drmVBlank vbl;
	int ret, pipe = I830DRI2DrawablePipe(draw), flip = 0;
	DRI2FrameEventPtr swap_info;
	enum DRI2FrameEventType swap_type = DRI2_SWAP;
	CARD64 current_msc;
	BoxRec box;
	RegionRec region;

	/* Truncate to match kernel interfaces; means occasional overflow
	 * misses, but that's generally not a big deal */
	*target_msc &= 0xffffffff;
	divisor &= 0xffffffff;
	remainder &= 0xffffffff;

	swap_info = calloc(1, sizeof(DRI2FrameEventRec));

	/* Drawable not displayed... just complete the swap */
	if (pipe == -1 || !swap_info)
	    goto blit_fallback;

	swap_info->drawable_id = draw->id;
	swap_info->client = client;
	swap_info->event_complete = func;
	swap_info->event_data = data;
	swap_info->front = front;
	swap_info->back = back;
	I830DRI2ReferenceBuffer(front);
	I830DRI2ReferenceBuffer(back);

	/* Get current count */
	vbl.request.type = DRM_VBLANK_RELATIVE;
	if (pipe > 0)
		vbl.request.type |= DRM_VBLANK_SECONDARY;
	vbl.request.sequence = 0;
	ret = drmWaitVBlank(intel->drmSubFD, &vbl);
	if (ret) {
		xf86DrvMsg(scrn->scrnIndex, X_WARNING,
			   "first get vblank counter failed: %s\n",
			   strerror(errno));
		goto blit_fallback;
	}

	current_msc = vbl.reply.sequence;

	swap_info->type = swap_type;

	/* Correct target_msc by 'flip' if swap_type == DRI2_FLIP.
	 * Do it early, so handling of different timing constraints
	 * for divisor, remainder and msc vs. target_msc works.
	 */
	if (*target_msc > 0)
		*target_msc -= flip;

	/*
	 * If divisor is zero, or current_msc is smaller than target_msc
	 * we just need to make sure target_msc passes before initiating
	 * the swap.
	 */
	if (divisor == 0 || current_msc < *target_msc) {
		vbl.request.type =  DRM_VBLANK_ABSOLUTE | DRM_VBLANK_EVENT;
		if (pipe > 0)
			vbl.request.type |= DRM_VBLANK_SECONDARY;

		/* If non-pageflipping, but blitting/exchanging, we need to use
		 * DRM_VBLANK_NEXTONMISS to avoid unreliable timestamping later
		 * on.
		 */
		if (flip == 0)
			vbl.request.type |= DRM_VBLANK_NEXTONMISS;
		if (pipe > 0)
			vbl.request.type |= DRM_VBLANK_SECONDARY;

		/* If target_msc already reached or passed, set it to
		 * current_msc to ensure we return a reasonable value back
		 * to the caller. This makes swap_interval logic more robust.
		 */
		if (current_msc >= *target_msc)
			*target_msc = current_msc;

		vbl.request.sequence = *target_msc;
		vbl.request.signal = (unsigned long)swap_info;
		ret = drmWaitVBlank(intel->drmSubFD, &vbl);
		if (ret) {
			xf86DrvMsg(scrn->scrnIndex, X_WARNING,
				   "divisor 0 get vblank counter failed: %s\n",
				   strerror(errno));
			goto blit_fallback;
		}

		*target_msc = vbl.reply.sequence + flip;
		swap_info->frame = *target_msc;

		return TRUE;
	}

	/*
	 * If we get here, target_msc has already passed or we don't have one,
	 * and we need to queue an event that will satisfy the divisor/remainder
	 * equation.
	 */
	vbl.request.type = DRM_VBLANK_ABSOLUTE | DRM_VBLANK_EVENT;
	if (flip == 0)
		vbl.request.type |= DRM_VBLANK_NEXTONMISS;
	if (pipe > 0)
		vbl.request.type |= DRM_VBLANK_SECONDARY;

	vbl.request.sequence = current_msc - (current_msc % divisor) +
		remainder;

	/*
	 * If the calculated deadline vbl.request.sequence is smaller than
	 * or equal to current_msc, it means we've passed the last point
	 * when effective onset frame seq could satisfy
	 * seq % divisor == remainder, so we need to wait for the next time
	 * this will happen.

	 * This comparison takes the 1 frame swap delay in pageflipping mode
	 * into account, as well as a potential DRM_VBLANK_NEXTONMISS delay
	 * if we are blitting/exchanging instead of flipping.
	 */
	if (vbl.request.sequence <= current_msc)
		vbl.request.sequence += divisor;

	/* Account for 1 frame extra pageflip delay if flip > 0 */
	vbl.request.sequence -= flip;

	vbl.request.signal = (unsigned long)swap_info;
	ret = drmWaitVBlank(intel->drmSubFD, &vbl);
	if (ret) {
		xf86DrvMsg(scrn->scrnIndex, X_WARNING,
			   "final get vblank counter failed: %s\n",
			   strerror(errno));
		goto blit_fallback;
	}

	/* Adjust returned value for 1 fame pageflip offset of flip > 0 */
	*target_msc = vbl.reply.sequence + flip;
	swap_info->frame = *target_msc;

	return TRUE;

blit_fallback:
	box.x1 = 0;
	box.y1 = 0;
	box.x2 = draw->width;
	box.y2 = draw->height;
	REGION_INIT(pScreen, &region, &box, 0);

	I830DRI2CopyRegion(draw, &region, front, back);

	DRI2SwapComplete(client, draw, 0, 0, 0, DRI2_BLIT_COMPLETE, func, data);
	if (swap_info) {
	    I830DRI2DestroyBuffer(draw, swap_info->front);
	    I830DRI2DestroyBuffer(draw, swap_info->back);
	    free(swap_info);
	}
	*target_msc = 0; /* offscreen, so zero out target vblank count */
	return TRUE;
}

/*
 * Get current frame count and frame count timestamp, based on drawable's
 * crtc.
 */
static int
I830DRI2GetMSC(DrawablePtr draw, CARD64 *ust, CARD64 *msc)
{
	ScreenPtr screen = draw->pScreen;
	ScrnInfoPtr scrn = xf86Screens[screen->myNum];
	intel_screen_private *intel = intel_get_screen_private(scrn);
	drmVBlank vbl;
	int ret, pipe = I830DRI2DrawablePipe(draw);

	/* Drawable not displayed, make up a value */
	if (pipe == -1) {
		*ust = 0;
		*msc = 0;
		return TRUE;
	}

	vbl.request.type = DRM_VBLANK_RELATIVE;
	if (pipe > 0)
		vbl.request.type |= DRM_VBLANK_SECONDARY;
	vbl.request.sequence = 0;

	ret = drmWaitVBlank(intel->drmSubFD, &vbl);
	if (ret) {
		xf86DrvMsg(scrn->scrnIndex, X_WARNING,
			   "get vblank counter failed: %s\n", strerror(errno));
		return FALSE;
	}

	*ust = ((CARD64)vbl.reply.tval_sec * 1000000) + vbl.reply.tval_usec;
	*msc = vbl.reply.sequence;

	return TRUE;
}

/*
 * Request a DRM event when the requested conditions will be satisfied.
 *
 * We need to handle the event and ask the server to wake up the client when
 * we receive it.
 */
static int
I830DRI2ScheduleWaitMSC(ClientPtr client, DrawablePtr draw, CARD64 target_msc,
			CARD64 divisor, CARD64 remainder)
{
	ScreenPtr screen = draw->pScreen;
	ScrnInfoPtr scrn = xf86Screens[screen->myNum];
	intel_screen_private *intel = intel_get_screen_private(scrn);
	DRI2FrameEventPtr wait_info;
	drmVBlank vbl;
	int ret, pipe = I830DRI2DrawablePipe(draw);
	CARD64 current_msc;

	/* Truncate to match kernel interfaces; means occasional overflow
	 * misses, but that's generally not a big deal */
	target_msc &= 0xffffffff;
	divisor &= 0xffffffff;
	remainder &= 0xffffffff;

	/* Drawable not visible, return immediately */
	if (pipe == -1)
		goto out_complete;

	wait_info = calloc(1, sizeof(DRI2FrameEventRec));
	if (!wait_info)
		goto out_complete;

	wait_info->drawable_id = draw->id;
	wait_info->client = client;
	wait_info->type = DRI2_WAITMSC;

	/* Get current count */
	vbl.request.type = DRM_VBLANK_RELATIVE;
	if (pipe > 0)
		vbl.request.type |= DRM_VBLANK_SECONDARY;
	vbl.request.sequence = 0;
	ret = drmWaitVBlank(intel->drmSubFD, &vbl);
	if (ret) {
		xf86DrvMsg(scrn->scrnIndex, X_WARNING,
			   "get vblank counter failed: %s\n", strerror(errno));
		goto out_complete;
	}

	current_msc = vbl.reply.sequence;

	/*
	 * If divisor is zero, or current_msc is smaller than target_msc,
	 * we just need to make sure target_msc passes  before waking up the
	 * client.
	 */
	if (divisor == 0 || current_msc < target_msc) {
		/* If target_msc already reached or passed, set it to
		 * current_msc to ensure we return a reasonable value back
		 * to the caller. This keeps the client from continually
		 * sending us MSC targets from the past by forcibly updating
		 * their count on this call.
		 */
		if (current_msc >= target_msc)
			target_msc = current_msc;
		vbl.request.type = DRM_VBLANK_ABSOLUTE | DRM_VBLANK_EVENT;
		if (pipe > 0)
			vbl.request.type |= DRM_VBLANK_SECONDARY;
		vbl.request.sequence = target_msc;
		vbl.request.signal = (unsigned long)wait_info;
		ret = drmWaitVBlank(intel->drmSubFD, &vbl);
		if (ret) {
			xf86DrvMsg(scrn->scrnIndex, X_WARNING,
				   "get vblank counter failed: %s\n", strerror(errno));
			goto out_complete;
		}

		wait_info->frame = vbl.reply.sequence;
		DRI2BlockClient(client, draw);
		return TRUE;
	}

	/*
	 * If we get here, target_msc has already passed or we don't have one,
	 * so we queue an event that will satisfy the divisor/remainder equation.
	 */
	vbl.request.type = DRM_VBLANK_ABSOLUTE | DRM_VBLANK_EVENT;
	if (pipe > 0)
		vbl.request.type |= DRM_VBLANK_SECONDARY;

	vbl.request.sequence = current_msc - (current_msc % divisor) +
	    remainder;

	/*
	 * If calculated remainder is larger than requested remainder,
	 * it means we've passed the last point where
	 * seq % divisor == remainder, so we need to wait for the next time
	 * that will happen.
	 */
	if ((current_msc % divisor) >= remainder)
	    vbl.request.sequence += divisor;

	vbl.request.signal = (unsigned long)wait_info;
	ret = drmWaitVBlank(intel->drmSubFD, &vbl);
	if (ret) {
		xf86DrvMsg(scrn->scrnIndex, X_WARNING,
			   "get vblank counter failed: %s\n", strerror(errno));
		goto out_complete;
	}

	wait_info->frame = vbl.reply.sequence;
	DRI2BlockClient(client, draw);

	return TRUE;

out_complete:
	DRI2WaitMSCComplete(client, draw, target_msc, 0, 0);
	return TRUE;
}
#endif
#endif

Bool I830DRI2ScreenInit(ScreenPtr screen)
{
	ScrnInfoPtr scrn = xf86Screens[screen->myNum];
	intel_screen_private *intel = intel_get_screen_private(scrn);
	DRI2InfoRec info;
#ifdef USE_DRI2_1_1_0
	int dri2_major = 1;
	int dri2_minor = 0;
#endif
#if DRI2INFOREC_VERSION >= 4
	const char *driverNames[1];
#endif

#ifdef USE_DRI2_1_1_0
	if (xf86LoaderCheckSymbol("DRI2Version")) {
		DRI2Version(&dri2_major, &dri2_minor);
	}

	if (dri2_minor < 1) {
		xf86DrvMsg(scrn->scrnIndex, X_WARNING,
			   "DRI2 requires DRI2 module version 1.1.0 or later\n");
		return FALSE;
	}
#endif

	intel->deviceName = drmGetDeviceNameFromFd(intel->drmSubFD);
	memset(&info, '\0', sizeof(info));
	info.fd = intel->drmSubFD;
	info.driverName = IS_I965G(intel) ? "i965" : "i915";
	info.deviceName = intel->deviceName;

#if DRI2INFOREC_VERSION >= 3
	info.version = 3;
	info.CreateBuffer = I830DRI2CreateBuffer;
	info.DestroyBuffer = I830DRI2DestroyBuffer;
#else
# ifdef USE_DRI2_1_1_0
	info.version = 2;
	info.CreateBuffers = NULL;
	info.DestroyBuffers = NULL;
	info.CreateBuffer = I830DRI2CreateBuffer;
	info.DestroyBuffer = I830DRI2DestroyBuffer;
# else
	info.version = 1;
	info.CreateBuffers = I830DRI2CreateBuffers;
	info.DestroyBuffers = I830DRI2DestroyBuffers;
# endif
#endif

	info.CopyRegion = I830DRI2CopyRegion;
#if DRI2INFOREC_VERSION >= 4
#ifdef notyet
	info.version = 4;
	info.ScheduleSwap = I830DRI2ScheduleSwap;
	info.GetMSC = I830DRI2GetMSC;
	info.ScheduleWaitMSC = I830DRI2ScheduleWaitMSC;
	info.numDrivers = 1;
	info.driverNames = driverNames;
	driverNames[0] = info.driverName;
#endif
#endif

	return DRI2ScreenInit(screen, &info);
}

void I830DRI2CloseScreen(ScreenPtr screen)
{
	ScrnInfoPtr scrn = xf86Screens[screen->myNum];
	intel_screen_private *intel = intel_get_screen_private(scrn);

	DRI2CloseScreen(screen);
	intel->directRenderingType = DRI_NONE;
	drmFree(intel->deviceName);
}
@


1.13
log
@Update the intel driver to (mostly) a backport of 2.12.

It is missing a few commits that I have yet to verify (ones that try and
continue if we lock the gpu rendering engine and can't reset it, for
example) taht will be verified and sent out for extra testing soon.

Should contain a bunch of speedups and some correctness improvements
(though rendercheck still gives some errors that I am looking into).

This has been in snaps since the first day of c2k10, any known issues
with just this driver have (to my knowledge) been fixed since. A problem
with macbooks pointed out by otto happens with both this and the in-tree
driver and thus doesn't stop this moving forward.

As well as the 2.12 improvements, this driver also has a backport
(partially aided by the backports in RHEL 5 kindly provided by Dave
Airlie) from the kms code of modesetting support for ironlake (arrandale
and clarkdale: the IGDs build into intel nehalem cpu dies) which has
been tested on a number of chipsets. Note that Display port and eDP
displays have not yet been worked on (and probably won't until I can
find a displayport monitor), but VGA and lvds at least are known to
work, sure beats vesa.

"no objection on my side" matthieu@@, prodding (as always) from princess
marco.
@
text
@@


1.12
log
@Pull in the changes in rendering that I skipped when i backported
changes from later intel versions (after the UMS removal). 95% of this
is the xvmc reworks that makes that code even halfway sane. xvmc is now
enabled by default on 965+.

Tested by many on tech@@, thanks!

ok matthieu@@
@
text
@d47 3
d78 1
d97 1
a97 1
	buffers = xcalloc(count, sizeof *buffers);
d100 1
a100 1
	privates = xcalloc(count, sizeof *privates);
d102 1
a102 1
		xfree(buffers);
d132 1
a132 2
			if (!intel->tiling ||
			    (!IS_I965G(intel) && !intel->kernel_exec_fencing))
d151 1
d156 1
a156 1
		if (dri_bo_flink(bo, &buffers[i].name) != 0) {
a158 1

d178 1
a178 1
	buffer = xcalloc(1, sizeof *buffer);
d181 1
a181 1
	privates = xcalloc(1, sizeof *privates);
d183 1
a183 1
		xfree(buffer);
d209 1
a209 2
		if (!intel->tiling ||
		    (!IS_I965G(intel) && !intel->kernel_exec_fencing))
d218 5
d232 1
d237 1
a237 1
	if (dri_bo_flink(bo, &buffer->name) != 0) {
d239 4
d265 2
a266 2
		xfree(buffers[0].driverPrivate);
		xfree(buffers);
d276 2
a277 1
		ScreenPtr screen = drawable->pScreen;
d279 1
a279 1
		screen->DestroyPixmap(private->pixmap);
d281 3
a283 2
		xfree(private);
		xfree(buffer);
d289 8
d313 4
a316 1
	gc = GetScratchGC(drawable->depth, screen);
d403 3
a405 5
	 * client gets to run again so flush now. */
	intel_batch_submit(scrn);
#if ALWAYS_SYNC
	intel_sync(scrn);
#endif
d407 407
d815 1
d818 121
d948 3
d965 1
d989 11
@


1.11
log
@Update the intel driver to 2.9.1 plus backports.

2.9.1 is the last version of the intel DDX that supports UMS (User
modesetting), with 2.10 onwards being purely KMS only. As such, this
driver contains backports of almost every correctness or performance
related fix to the rendering layer in later intel drivers. This driver
*REQUIRES* a GEM enabled kernel. it claims to support non-gem mode but
this is essentially unmaintained and due to the way the abstraciton
works is slow, if it works at all (it often does not). You have been
warned.

tested by many many people on tech over the last few weeks.
@
text
@a60 1
#include "i830_dri.h"
a391 4
	char *p;
	int i;
	struct stat sbuf;
	dev_t d;
d409 1
a410 21

	/* The whole drmOpen thing is a fiasco and we need to find a way
	 * back to just using open(2).  For now, however, lets just make
	 * things worse with even more ad hoc directory walking code to
	 * discover the device file name. */

	fstat(info.fd, &sbuf);
	d = sbuf.st_rdev;

	p = intel->deviceName;
	for (i = 0; i < DRM_MAX_MINOR; i++) {
		sprintf(p, DRM_DEV_NAME, DRM_DIR_NAME, i);
		if (stat(p, &sbuf) == 0 && sbuf.st_rdev == d)
			break;
	}
	if (i == DRM_MAX_MINOR) {
		xf86DrvMsg(scrn->scrnIndex, X_WARNING,
			   "DRI2: failed to open drm device\n");
		return FALSE;
	}

d412 1
a412 1
	info.deviceName = p;
d444 1
@


1.10
log
@Pull in some code from 2.8 and current so that dri2 works correctly with
xserver 1.6.2. When dri2 is not in use, this commit does nothing.

ok matthieu@@
@
text
@a0 1
/* $xfree86: xc/programs/Xserver/hw/xfree86/drivers/i810/i830_dri.c,v 1.15 2003/06/18 13:14:17 dawes Exp $ */
a29 13
 * Reformatted with GNU indent (2.2.8), using the following options:
 *
 *    -bad -bap -c41 -cd0 -ncdb -ci6 -cli0 -cp0 -ncs -d0 -di3 -i3 -ip3 -l78
 *    -lp -npcs -psl -sob -ss -br -ce -sc -hnl
 *
 * This provides a good match with the original i810 code and preferred
 * XFree86 formatting conventions.
 *
 * When editing this driver, please follow the existing formatting, and edit
 * with <TAB> characters expanded at 8-column intervals.
 */

/*
a34 12
/*
 * This driver does AGP memory allocation a little differently from most
 * others.  The 2D and 3D allocations have been unified (see i830_memory.c).
 * The driver does the AGP allocations and binding directly, then passes
 * on the mappings to the DRM module.  The DRM's AGP interfaces are not used.
 * The main difference with this is that the offsets need to include
 * the AGP aperture base address because that won't be known or added on
 * by the DRM module.
 *
 * DHD 07/2002
 */

a44 1
#include <errno.h>
d65 1
a65 1
#include "dristruct.h"
a67 2
#include "dri2.h"

a74 1432
static Bool I830InitVisualConfigs(ScreenPtr pScreen);
static Bool I830CreateContext(ScreenPtr pScreen, VisualPtr visual,
			      drm_context_t hwContext, void *pVisualConfigPriv,
			      DRIContextType contextStore);
static void I830DestroyContext(ScreenPtr pScreen, drm_context_t hwContext,
			       DRIContextType contextStore);
static void I830DRISwapContext(ScreenPtr pScreen, DRISyncType syncType,
			       DRIContextType readContextType,
			       void *readContextStore,
			       DRIContextType writeContextType,
			       void *writeContextStore);
static void I830DRIInitBuffers(WindowPtr pWin, RegionPtr prgn, CARD32 index);
static void I830DRIMoveBuffers(WindowPtr pParent, DDXPointRec ptOldOrg,
			       RegionPtr prgnSrc, CARD32 index);

static void I830DRITransitionTo2d(ScreenPtr pScreen);
static void I830DRITransitionTo3d(ScreenPtr pScreen);

#if (DRIINFO_MAJOR_VERSION > 5 || \
     (DRIINFO_MAJOR_VERSION == 5 && DRIINFO_MINOR_VERSION >= 4))
#define DRI_DRIVER_FRAMEBUFFER_MAP 1
#else
#define DRI_DRIVER_FRAMEBUFFER_MAP 0
#endif

extern void GlxSetVisualConfigs(int nconfigs,
				__GLXvisualConfig * configs,
				void **configprivs);

static Bool
I830CleanupDma(ScrnInfoPtr pScrn)
{
   I830Ptr pI830 = I830PTR(pScrn);
   drmI830Init info;

   memset(&info, 0, sizeof(drmI830Init));
   info.func = I830_CLEANUP_DMA;

   if (drmCommandWrite(pI830->drmSubFD, DRM_I830_INIT,
		       &info, sizeof(drmI830Init))) {
      xf86DrvMsg(pScrn->scrnIndex, X_ERROR, "I830 Dma Cleanup Failed\n");
      return FALSE;
   }

   return TRUE;
}

static Bool
I830InitDma(ScrnInfoPtr pScrn)
{
   I830Ptr pI830 = I830PTR(pScrn);
   I830RingBuffer *ring = &pI830->ring;
   I830DRIPtr pI830DRI = (I830DRIPtr) pI830->pDRIInfo->devPrivate;
   drmI830Init info;

   memset(&info, 0, sizeof(drmI830Init));
   info.func = I830_INIT_DMA;

   /* Initialize fields that are used in the absence of GEM */
   if (!pI830->memory_manager && !pI830->use_drm_mode) {
       info.ring_start = ring->mem->offset + pI830->LinearAddr;
       info.ring_end = ring->mem->end + pI830->LinearAddr;
       info.ring_size = ring->mem->size;

       /* Not used as of the middle of GEM development. */
       info.mmio_offset = (unsigned int)pI830DRI->regs;

       /* Not used as of before GEM development */
       info.front_offset = pI830->front_buffer->offset;
       info.back_offset = pI830->back_buffer->offset;
       info.depth_offset = pI830->depth_buffer->offset;
       info.pitch = pScrn->displayWidth;
       info.back_pitch = pScrn->displayWidth;
       info.depth_pitch = pScrn->displayWidth;
       info.w = pScrn->virtualX;
       info.h = pScrn->virtualY;
   }


   info.sarea_priv_offset = sizeof(XF86DRISAREARec);

   /* This should probably have been moved alongside offset/pitch in the sarea.
    */
   info.cpp = pI830->cpp;

   if (drmCommandWrite(pI830->drmSubFD, DRM_I830_INIT,
		       &info, sizeof(drmI830Init))) {
      xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
		 "I830 Dma Initialization Failed\n");
      return FALSE;
   }

   return TRUE;
}

static Bool
I830ResumeDma(ScrnInfoPtr pScrn)
{
   I830Ptr pI830 = I830PTR(pScrn);
   drmI830Init info;

   memset(&info, 0, sizeof(drmI830Init));
   info.func = I830_RESUME_DMA;

   if (drmCommandWrite(pI830->drmSubFD, DRM_I830_INIT,
		       &info, sizeof(drmI830Init))) {
      xf86DrvMsg(pScrn->scrnIndex, X_ERROR, "I830 Dma Resume Failed\n");
      return FALSE;
   }

   return TRUE;
}

static Bool
I830SetParam(ScrnInfoPtr pScrn, int param, int value)
{
   I830Ptr pI830 = I830PTR(pScrn);
   drmI830SetParam sp;

   memset(&sp, 0, sizeof(sp));
   sp.param = param;
   sp.value = value;

   if (drmCommandWrite(pI830->drmSubFD, DRM_I830_SETPARAM, &sp, sizeof(sp))) {
      xf86DrvMsg(pScrn->scrnIndex, X_ERROR, "I830 SetParam Failed\n");
      return FALSE;
   }

   return TRUE;
}

Bool
I830DRISetHWS(ScrnInfoPtr pScrn)
{
    I830Ptr pI830 = I830PTR(pScrn);
    drmI830HWS hws;

    hws.addr = pI830->hw_status->offset;

    if (drmCommandWrite(pI830->drmSubFD, DRM_I830_HWS_PAGE_ADDR,
		&hws, sizeof(drmI830HWS))) {
	xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
		"hw status page initialization Failed\n");
	return FALSE;
    }
    return TRUE;
}

static Bool
I830InitVisualConfigs(ScreenPtr pScreen)
{
   ScrnInfoPtr pScrn = xf86Screens[pScreen->myNum];
   I830Ptr pI830 = I830PTR(pScrn);
   int numConfigs = 0;
   __GLXvisualConfig *pConfigs = NULL;
   I830ConfigPrivPtr pI830Configs = NULL;
   I830ConfigPrivPtr *pI830ConfigPtrs = NULL;
   int accum, stencil, db, depth;
   int i;

   switch (pScrn->bitsPerPixel) {
   case 8:
   case 24:
      break;

   case 16:
      numConfigs = 8;

      pConfigs =
	    (__GLXvisualConfig *) xcalloc(sizeof(__GLXvisualConfig),
					  numConfigs);
      if (!pConfigs)
	 return FALSE;

      pI830Configs =
	    (I830ConfigPrivPtr) xcalloc(sizeof(I830ConfigPrivRec),
					numConfigs);
      if (!pI830Configs) {
	 xfree(pConfigs);
	 return FALSE;
      }

      pI830ConfigPtrs =
	    (I830ConfigPrivPtr *) xcalloc(sizeof(I830ConfigPrivPtr),
					  numConfigs);
      if (!pI830ConfigPtrs) {
	 xfree(pConfigs);
	 xfree(pI830Configs);
	 return FALSE;
      }

      for (i = 0; i < numConfigs; i++)
	 pI830ConfigPtrs[i] = &pI830Configs[i];

      i = 0;
      depth = 1;
      for (accum = 0; accum <= 1; accum++) {
	 for (stencil = 0; stencil <= 1; stencil++) {
	    for (db = 1; db >= 0; db--) {
	       pConfigs[i].vid = -1;
	       pConfigs[i].class = -1;
	       pConfigs[i].rgba = TRUE;
	       pConfigs[i].redSize = 5;
	       pConfigs[i].greenSize = 6;
	       pConfigs[i].blueSize = 5;
	       pConfigs[i].alphaSize = 0;
	       pConfigs[i].redMask = 0x0000F800;
	       pConfigs[i].greenMask = 0x000007E0;
	       pConfigs[i].blueMask = 0x0000001F;
	       pConfigs[i].alphaMask = 0;
	       if (accum) {
		  pConfigs[i].accumRedSize = 16;
		  pConfigs[i].accumGreenSize = 16;
		  pConfigs[i].accumBlueSize = 16;
		  pConfigs[i].accumAlphaSize = 0;
	       } else {
		  pConfigs[i].accumRedSize = 0;
		  pConfigs[i].accumGreenSize = 0;
		  pConfigs[i].accumBlueSize = 0;
		  pConfigs[i].accumAlphaSize = 0;
	       }
	       pConfigs[i].doubleBuffer = db ? TRUE : FALSE;
	       pConfigs[i].stereo = FALSE;
	       pConfigs[i].bufferSize = 16;
	       if (depth)
		  pConfigs[i].depthSize = 16;
	       else
		  pConfigs[i].depthSize = 0;
	       if (stencil)
		  pConfigs[i].stencilSize = 8;
	       else
		  pConfigs[i].stencilSize = 0;
	       pConfigs[i].auxBuffers = 0;
	       pConfigs[i].level = 0;
	       if (stencil || accum)
		  pConfigs[i].visualRating = GLX_SLOW_VISUAL_EXT;
	       else
		  pConfigs[i].visualRating = GLX_NONE_EXT;
	       pConfigs[i].transparentPixel = GLX_NONE_EXT;
	       pConfigs[i].transparentRed = 0;
	       pConfigs[i].transparentGreen = 0;
	       pConfigs[i].transparentBlue = 0;
	       pConfigs[i].transparentAlpha = 0;
	       pConfigs[i].transparentIndex = 0;
	       i++;
	    }
	 }
      }
      assert(i == numConfigs);
      break;

   case 32:
      numConfigs = 8;

      pConfigs = (__GLXvisualConfig *) xcalloc(sizeof(__GLXvisualConfig),
					       numConfigs);
      if (!pConfigs) {
	 return FALSE;
      }

      pI830Configs = (I830ConfigPrivPtr) xcalloc(sizeof(I830ConfigPrivRec),
						 numConfigs);
      if (!pI830Configs) {
	 xfree(pConfigs);
	 return FALSE;
      }

      pI830ConfigPtrs = (I830ConfigPrivPtr *)
	    xcalloc(sizeof(I830ConfigPrivPtr), numConfigs);
      if (!pI830ConfigPtrs) {
	 xfree(pConfigs);
	 xfree(pI830Configs);
	 return FALSE;
      }

      for (i = 0; i < numConfigs; i++) {
	 pI830ConfigPtrs[i] = &pI830Configs[i];
      }

      i = 0;
      for (accum = 0; accum <= 1; accum++) {
	 for (depth = 1; depth >= 0; depth--) {	/* and stencil */
	    for (db = 1; db >= 0; db--) {
	       pConfigs[i].vid = -1;
	       pConfigs[i].class = -1;
	       pConfigs[i].rgba = TRUE;
	       pConfigs[i].redSize = 8;
	       pConfigs[i].greenSize = 8;
	       pConfigs[i].blueSize = 8;
	       pConfigs[i].alphaSize = 8;
	       pConfigs[i].redMask = 0x00FF0000;
	       pConfigs[i].greenMask = 0x0000FF00;
	       pConfigs[i].blueMask = 0x000000FF;
	       pConfigs[i].alphaMask = 0xFF000000;
	       if (accum) {
		  pConfigs[i].accumRedSize = 16;
		  pConfigs[i].accumGreenSize = 16;
		  pConfigs[i].accumBlueSize = 16;
		  pConfigs[i].accumAlphaSize = 16;
	       } else {
		  pConfigs[i].accumRedSize = 0;
		  pConfigs[i].accumGreenSize = 0;
		  pConfigs[i].accumBlueSize = 0;
		  pConfigs[i].accumAlphaSize = 0;
	       }
	       if (db) {
		  pConfigs[i].doubleBuffer = TRUE;
	       } else {
		  pConfigs[i].doubleBuffer = FALSE;
	       }
	       pConfigs[i].stereo = FALSE;
	       pConfigs[i].bufferSize = 32;
	       if (depth) {
		  pConfigs[i].depthSize = 24;
		  pConfigs[i].stencilSize = 8;
	       } else {
		  pConfigs[i].depthSize = 0;
		  pConfigs[i].stencilSize = 0;
	       }
	       pConfigs[i].auxBuffers = 0;
	       pConfigs[i].level = 0;
	       if (accum) {
		  pConfigs[i].visualRating = GLX_SLOW_VISUAL_EXT;
	       } else {
		  pConfigs[i].visualRating = GLX_NONE_EXT;
	       }
	       pConfigs[i].transparentPixel = GLX_NONE_EXT;
	       pConfigs[i].transparentRed = 0;
	       pConfigs[i].transparentGreen = 0;
	       pConfigs[i].transparentBlue = 0;
	       pConfigs[i].transparentAlpha = 0;
	       pConfigs[i].transparentIndex = 0;
	       i++;
	    }
	 }
      }
      if (i != numConfigs) {
	 xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
		    "[drm] Incorrect initialization of visuals\n");
	 return FALSE;
      }
      break;

   }
   pI830->numVisualConfigs = numConfigs;
   pI830->pVisualConfigs = pConfigs;
   pI830->pVisualConfigsPriv = pI830Configs;
   GlxSetVisualConfigs(numConfigs, pConfigs, (void **)pI830ConfigPtrs);
   return TRUE;
}

Bool
I830CheckDRIAvailable(ScrnInfoPtr pScrn)
{
   /* Hardware 3D rendering only implemented for 16bpp and 32 bpp */
   if (((pScrn->bitsPerPixel / 8) != 2 && pScrn->depth != 16) &&
       (pScrn->bitsPerPixel / 8) != 4) {
      xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
		 "[drm] Direct rendering only supported in 16 and 32 bpp modes\n");
      return FALSE;
   }

   /* Check that the GLX, DRI, and DRM modules have been loaded by testing
    * for known symbols in each module. */
   if (!xf86LoaderCheckSymbol("GlxSetVisualConfigs")) {
      xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
		 "[dri] %s failed: glx not loaded\n", __FUNCTION__);
      return FALSE;
   }
   if (!xf86LoaderCheckSymbol("DRIScreenInit")) {
      xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
		 "[dri] %s failed: dri not loaded\n", __FUNCTION__);
      return FALSE;
   }
   if (!xf86LoaderCheckSymbol("drmAvailable")) {
      xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
		 "[dri] %s failed: libdrm not loaded\n", __FUNCTION__);
      return FALSE;
   }
   if (!xf86LoaderCheckSymbol("DRIQueryVersion")) {
      xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
		 "[dri] %s failed (libdri.a too old)\n", __FUNCTION__);
      return FALSE;
   }

   /* Check the DRI version */
   {
      int major, minor, patch;

      DRIQueryVersion(&major, &minor, &patch);
      if (major != DRIINFO_MAJOR_VERSION || minor < DRIINFO_MINOR_VERSION ||
	  major < 5) {
	 xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
		    "[dri] %s failed because of a version mismatch.\n"
		    "[dri] libDRI version is %d.%d.%d but version %d.%d.x is needed.\n"
		    "[dri] Disabling DRI.\n",
		    "I830CheckDRIAvailable", major, minor, patch,
		     DRIINFO_MAJOR_VERSION, DRIINFO_MINOR_VERSION);
	 return FALSE;
      }
   }

   return TRUE;
}

Bool
I830DRIScreenInit(ScreenPtr pScreen)
{
   ScrnInfoPtr pScrn = xf86Screens[pScreen->myNum];
   I830Ptr pI830 = I830PTR(pScrn);
   DRIInfoPtr pDRIInfo;
   I830DRIPtr pI830DRI;

   DPRINTF(PFX, "I830DRIScreenInit\n");

   if (!I830CheckDRIAvailable(pScrn))
      return FALSE;

   pDRIInfo = DRICreateInfoRec();
   if (!pDRIInfo) {
      xf86DrvMsg(pScreen->myNum, X_ERROR,
		 "[dri] DRICreateInfoRec failed. Disabling DRI.\n");
      return FALSE;
   }

   pI830->pDRIInfo = pDRIInfo;
   pI830->LockHeld = 0;

   pDRIInfo->drmDriverName = "i915";
   if (IS_I965G(pI830))
      pDRIInfo->clientDriverName = "i965";
   else
      pDRIInfo->clientDriverName = "i915";

   if (xf86LoaderCheckSymbol("DRICreatePCIBusID")) {
      pDRIInfo->busIdString = DRICreatePCIBusID(pI830->PciInfo);
   } else {
      pDRIInfo->busIdString = xalloc(64);
      sprintf(pDRIInfo->busIdString, "PCI:%d:%d:%d",
#if XSERVER_LIBPCIACCESS
	      ((pI830->PciInfo->domain << 8) | pI830->PciInfo->bus),
	      pI830->PciInfo->dev, pI830->PciInfo->func
#else
	      ((pciConfigPtr) pI830->PciInfo->thisCard)->busnum,
	      ((pciConfigPtr) pI830->PciInfo->thisCard)->devnum,
	      ((pciConfigPtr) pI830->PciInfo->thisCard)->funcnum
#endif
	      );
   }
   pDRIInfo->ddxDriverMajorVersion = I830_MAJOR_VERSION;
   pDRIInfo->ddxDriverMinorVersion = I830_MINOR_VERSION;
   pDRIInfo->ddxDriverPatchVersion = I830_PATCHLEVEL;
   pDRIInfo->ddxDrawableTableEntry = I830_MAX_DRAWABLES;

   if (SAREA_MAX_DRAWABLES < I830_MAX_DRAWABLES)
      pDRIInfo->maxDrawableTableEntry = SAREA_MAX_DRAWABLES;
   else
      pDRIInfo->maxDrawableTableEntry = I830_MAX_DRAWABLES;

   if (sizeof(XF86DRISAREARec) + sizeof(drmI830Sarea) > SAREA_MAX) {
      xf86DrvMsg(pScreen->myNum, X_ERROR,
		 "[dri] Data does not fit in SAREA\n");
      return FALSE;
   }
   /* This is a hack for now.  We have to have more than a 4k page here
    * because of the size of the state.  However, the state should be
    * in a per-context mapping.  This will be added in the Mesa 3.5 port
    * of the I830 driver.
    */
   pDRIInfo->SAREASize = SAREA_MAX;

   if (!(pI830DRI = (I830DRIPtr) xcalloc(sizeof(I830DRIRec), 1))) {
      DRIDestroyInfoRec(pI830->pDRIInfo);
      pI830->pDRIInfo = NULL;
      return FALSE;
   }
   pDRIInfo->devPrivate = pI830DRI;
   pDRIInfo->devPrivateSize = sizeof(I830DRIRec);
   pDRIInfo->contextSize = sizeof(I830DRIContextRec);

   pDRIInfo->CreateContext = I830CreateContext;
   pDRIInfo->DestroyContext = I830DestroyContext;
   pDRIInfo->SwapContext = I830DRISwapContext;
   pDRIInfo->InitBuffers = I830DRIInitBuffers;
   pDRIInfo->MoveBuffers = I830DRIMoveBuffers;
   pDRIInfo->bufferRequests = DRI_ALL_WINDOWS;

#if DRIINFO_MAJOR_VERSION > 5 || \
    (DRIINFO_MAJOR_VERSION == 5 && DRIINFO_MINOR_VERSION >= 3)
      if (pI830->accel == ACCEL_EXA)
	 pDRIInfo->texOffsetStart = I830TexOffsetStart;
#endif

#if DRI_DRIVER_FRAMEBUFFER_MAP
   /* DRI version is high enough that we can get the DRI code to not
    * try to manage the framebuffer.
    */
   pDRIInfo->frameBufferPhysicalAddress = 0;
   pDRIInfo->frameBufferSize = 0;
   pDRIInfo->frameBufferStride = 0;
   pDRIInfo->dontMapFrameBuffer = TRUE;
#else
   /* Supply a dummy mapping info required by DRI setup.
    */
   pDRIInfo->frameBufferPhysicalAddress = (char *) pI830->LinearAddr;
   pDRIInfo->frameBufferSize = GTT_PAGE_SIZE;
   pDRIInfo->frameBufferStride = 1;
#endif

   pDRIInfo->TransitionTo2d = I830DRITransitionTo2d;
   pDRIInfo->TransitionTo3d = I830DRITransitionTo3d;

   /* do driver-independent DRI screen initialization here */
   if (!DRIScreenInit(pScreen, pDRIInfo, &pI830->drmSubFD)) {
      xf86DrvMsg(pScreen->myNum, X_ERROR,
		 "[dri] DRIScreenInit failed. Disabling DRI.\n");
      xfree(pDRIInfo->devPrivate);
      pDRIInfo->devPrivate = NULL;
      DRIDestroyInfoRec(pI830->pDRIInfo);
      pI830->pDRIInfo = NULL;
      return FALSE;
   }

   /* Now, nuke dri.c's dummy frontbuffer map setup if we did that. */
   if (pDRIInfo->frameBufferSize != 0) {
       int tmp;
       drm_handle_t fb_handle;
       void *ptmp;

       /* With the compat method, it will continue to report
	* the wrong map out of GetDeviceInfo, which will break AIGLX.
	*/
       DRIGetDeviceInfo(pScreen, &fb_handle, &tmp, &tmp, &tmp, &tmp, &ptmp);
       drmRmMap(pI830->drmSubFD, fb_handle);

       xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
		  "Removed DRI frontbuffer mapping in compatibility mode.\n");
       xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
		  "DRIGetDeviceInfo will report incorrect frontbuffer "
		  "handle.\n");
   }

   /* Check the i915 DRM versioning */
   {
      drmVersionPtr version;

      /* Check the DRM lib version.
       * drmGetLibVersion was not supported in version 1.0, so check for
       * symbol first to avoid possible crash or hang.
       */
      if (xf86LoaderCheckSymbol("drmGetLibVersion")) {
	 version = drmGetLibVersion(pI830->drmSubFD);
      } else
      {
	 /* drmlib version 1.0.0 didn't have the drmGetLibVersion
	  * entry point.  Fake it by allocating a version record
	  * via drmGetVersion and changing it to version 1.0.0
	  */
	 version = drmGetVersion(pI830->drmSubFD);
	 version->version_major = 1;
	 version->version_minor = 0;
	 version->version_patchlevel = 0;
      }

#define REQ_MAJ 1
#define REQ_MIN 1
      if (version) {
	 if (version->version_major != REQ_MAJ ||
	     version->version_minor < REQ_MIN) {
	    /* incompatible drm library version */
	    xf86DrvMsg(pScreen->myNum, X_ERROR,
		       "[dri] I830DRIScreenInit failed because of a version mismatch.\n"
		       "[dri] libdrm.a module version is %d.%d.%d but version %d.%d.x is needed.\n"
		       "[dri] Disabling DRI.\n",
		       version->version_major,
		       version->version_minor, version->version_patchlevel,
		       REQ_MAJ, REQ_MIN);
	    drmFreeVersion(version);
	    I830DRICloseScreen(pScreen);
	    return FALSE;
	 }
	 drmFreeVersion(version);
      }

      /* Check the i915 DRM version */
      version = drmGetVersion(pI830->drmSubFD);
      if (version) {
	 if (version->version_major != 1 || version->version_minor < 3) {
	    /* incompatible drm version */
	    xf86DrvMsg(pScreen->myNum, X_ERROR,
		       "[dri] %s failed because of a version mismatch.\n"
		       "[dri] i915 kernel module version is %d.%d.%d but version 1.3 or greater is needed.\n"
		       "[dri] Disabling DRI.\n",
		       "I830DRIScreenInit",
		       version->version_major,
		       version->version_minor, version->version_patchlevel);
	    I830DRICloseScreen(pScreen);
	    drmFreeVersion(version);
	    return FALSE;
	 }
	 /* Check whether the kernel module attached to the device isn't the
	  * one we expected (meaning it's the old i830 module).
	  */
	 if (strncmp(version->name, pDRIInfo->drmDriverName,
		     strlen(pDRIInfo->drmDriverName)))
	 {
	    xf86DrvMsg(pScreen->myNum, X_WARNING,
		       "Detected i830 kernel module.  The i915 kernel module "
		       "is required for DRI.  Aborting.\n");
	    I830DRICloseScreen(pScreen);
	    drmFreeVersion(version);
	    return FALSE;
	 }
	 pI830->drmMinor = version->version_minor;
	 drmFreeVersion(version);
      }
   }

   return TRUE;
}

static void
I830InitTextureHeap(ScrnInfoPtr pScrn)
{
   I830Ptr pI830 = I830PTR(pScrn);
   drmI830MemInitHeap drmHeap;

   if (pI830->textures == NULL)
       return;

   /* Start up the simple memory manager for agp space */
   drmHeap.region = I830_MEM_REGION_AGP;
   drmHeap.start  = 0;
   drmHeap.size   = pI830->textures->size;

   if (drmCommandWrite(pI830->drmSubFD, DRM_I830_INIT_HEAP,
			  &drmHeap, sizeof(drmHeap))) {
      xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
		    "[drm] Failed to initialized agp heap manager\n");
   } else {
      xf86DrvMsg(pScrn->scrnIndex, X_INFO,
		    "[drm] Initialized kernel agp heap manager, %ld\n",
		    pI830->textures->size);

      I830SetParam(pScrn, I830_SETPARAM_TEX_LRU_LOG_GRANULARITY, 
		   pI830->TexGranularity);
   }
}

/*
 * Map registers & ring buffer
 */
static Bool
I830DRIMapHW(ScreenPtr pScreen)
{
   ScrnInfoPtr pScrn = xf86Screens[pScreen->myNum];
   I830Ptr pI830 = I830PTR(pScrn);
   DRIInfoPtr pDRIInfo = pI830->pDRIInfo;
   I830DRIPtr pI830DRI = pDRIInfo->devPrivate;

   /* Kernel deals with direct hw access in this case */
   if (pI830->use_drm_mode)
       return TRUE;

   DPRINTF(PFX, "I830DRIMapHW\n");
   pI830DRI->regsSize = I830_REG_SIZE;
   if (drmAddMap(pI830->drmSubFD, (drm_handle_t)pI830->MMIOAddr,
		 pI830DRI->regsSize, DRM_REGISTERS, 0,
		 (drmAddress) &pI830DRI->regs) < 0) {
      xf86DrvMsg(pScreen->myNum, X_ERROR, "[drm] drmAddMap(regs) failed\n");
      DRICloseScreen(pScreen);
      return FALSE;
   }
   xf86DrvMsg(pScreen->myNum, X_INFO, "[drm] Registers = 0x%08x\n",
	      (int)pI830DRI->regs);

   if (!pI830->memory_manager) {
       if (drmAddMap(pI830->drmSubFD,
		     (drm_handle_t)pI830->ring.mem->offset +
		     pI830->LinearAddr,
		     pI830->ring.mem->size, DRM_AGP, 0,
		     (drmAddress) &pI830->ring_map) < 0) {
	   xf86DrvMsg(pScreen->myNum, X_ERROR,
		      "[drm] drmAddMap(ring_map) failed. Disabling DRI\n");
	   DRICloseScreen(pScreen);
	   return FALSE;
       }
       xf86DrvMsg(pScreen->myNum, X_INFO, "[drm] ring buffer = 0x%08x\n",
		  (int)pI830->ring_map);
   }

   return TRUE;
}

/**
 * Sets up mappings for static, lifetime-fixed allocations, and inital SAREA
 * setup.
 */
Bool
I830DRIDoMappings(ScreenPtr pScreen)
{
   ScrnInfoPtr pScrn = xf86Screens[pScreen->myNum];
   I830Ptr pI830 = I830PTR(pScrn);
   DRIInfoPtr pDRIInfo = pI830->pDRIInfo;
   I830DRIPtr pI830DRI = pDRIInfo->devPrivate;
   drmI830Sarea *sarea = (drmI830Sarea *) DRIGetSAREAPrivate(pScreen);

   if (!I830DRIMapHW(pScreen)) {
       DRICloseScreen(pScreen);
       return FALSE;
   }

   if (!I830InitDma(pScrn)) {
      DRICloseScreen(pScreen);
      return FALSE;
   }

   if (pI830->memory_manager == NULL)
       intel_bufmgr_fake_set_last_dispatch(pI830->bufmgr,
					   (volatile unsigned int *)
					   &sarea->last_dispatch);

   /* init to zero to be safe */
   sarea->front_handle = 0;
   sarea->back_handle = 0;
   sarea->depth_handle = 0;
   sarea->tex_handle = 0;

   /* Assign pScreen */
   pScrn->pScreen = pScreen;

   /* Need to initialize pScreen now to let RandR know. */
   pScrn->pScreen->width = pScrn->virtualX;
   pScrn->pScreen->height = pScrn->virtualY;

   /* If we are using the kernel memory manager, we have to delay SAREA and
    * mapping setup until our buffers are pinned at EnterVT, losing the
    * opportunity to fail cleanly early on.
    */
   if (pI830->memory_manager == NULL) {
      if (!i830_update_dri_buffers(pScrn)) {
	 /* screen mappings probably failed */
	 xf86DrvMsg(pScreen->myNum, X_ERROR,
		    "[drm] drmAddMap(screen mappings) failed. "
		    "Disabling DRI\n");
	 DRICloseScreen(pScreen);
	 return FALSE;
      }
   }

   if (pI830->allocate_classic_textures)
      I830InitTextureHeap(pScrn);

   if (DEVICE_ID(pI830->PciInfo) != PCI_CHIP_845_G &&
       DEVICE_ID(pI830->PciInfo) != PCI_CHIP_I830_M) {
      I830SetParam(pScrn, I830_SETPARAM_USE_MI_BATCHBUFFER_START, 1 );
   }

   pI830DRI = (I830DRIPtr) pI830->pDRIInfo->devPrivate;
   pI830DRI->deviceID = DEVICE_ID(pI830->PciInfo);
   pI830DRI->width = pScrn->virtualX;
   pI830DRI->height = pScrn->virtualY;
   pI830DRI->mem = pScrn->videoRam * 1024;
   pI830DRI->cpp = pI830->cpp;

   pI830DRI->bitsPerPixel = pScrn->bitsPerPixel;

   pI830DRI->sarea_priv_offset = sizeof(XF86DRISAREARec);

   if (!(I830InitVisualConfigs(pScreen))) {
      xf86DrvMsg(pScreen->myNum, X_ERROR,
		 "[dri] I830InitVisualConfigs failed. Disabling DRI\n");
      DRICloseScreen(pScreen);
      return FALSE;
   }

   xf86DrvMsg(pScrn->scrnIndex, X_INFO, "[dri] visual configs initialized\n");
   pI830->pDRIInfo->driverSwapMethod = DRI_HIDE_X_CONTEXT;

   return TRUE;
}

Bool
I830DRIInstIrqHandler(ScrnInfoPtr pScrn)
{
   I830Ptr pI830 = I830PTR(pScrn);
   I830DRIPtr pI830DRI = (I830DRIPtr) pI830->pDRIInfo->devPrivate;

   pI830DRI->irq = drmGetInterruptFromBusID(pI830->drmSubFD,
#if XSERVER_LIBPCIACCESS
					       ((pI830->PciInfo->domain << 8) |
						pI830->PciInfo->bus),
					       pI830->PciInfo->dev,
					       pI830->PciInfo->func
#else
					       ((pciConfigPtr) pI830->
						PciInfo->thisCard)->busnum,
					       ((pciConfigPtr) pI830->
						PciInfo->thisCard)->devnum,
					       ((pciConfigPtr) pI830->
						PciInfo->thisCard)->funcnum
#endif
					       );

   if (drmCtlInstHandler(pI830->drmSubFD, pI830DRI->irq)) {
       xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
	       "[drm] failure adding irq handler\n");
       pI830DRI->irq = 0;
       return FALSE;
   } else
       xf86DrvMsg(pScrn->scrnIndex, X_INFO,
	       "[drm] dma control initialized, using IRQ %d\n",
	       pI830DRI->irq);

   return TRUE;
}

Bool
I830DRIResume(ScreenPtr pScreen)
{
   ScrnInfoPtr pScrn = xf86Screens[pScreen->myNum];
   I830Ptr pI830 = I830PTR(pScrn);

   DPRINTF(PFX, "I830DRIResume\n");

   I830ResumeDma(pScrn);

   if (!pI830->memory_manager)
       I830DRIInstIrqHandler(pScrn);

   return TRUE;
}

void
I830DRICloseScreen(ScreenPtr pScreen)
{
   ScrnInfoPtr pScrn = xf86Screens[pScreen->myNum];
   I830Ptr pI830 = I830PTR(pScrn);
   I830DRIPtr pI830DRI = (I830DRIPtr) pI830->pDRIInfo->devPrivate;

   DPRINTF(PFX, "I830DRICloseScreen\n");

   if (!pI830->memory_manager && pI830DRI->irq) {
       drmCtlUninstHandler(pI830->drmSubFD);
       pI830DRI->irq = 0;
   }

   I830CleanupDma(pScrn);

   DRICloseScreen(pScreen);

   if (pI830->pDRIInfo) {
      if (pI830->pDRIInfo->devPrivate) {
	 xfree(pI830->pDRIInfo->devPrivate);
	 pI830->pDRIInfo->devPrivate = NULL;
      }
      DRIDestroyInfoRec(pI830->pDRIInfo);
      pI830->pDRIInfo = NULL;
   }
   if (pI830->pVisualConfigs)
      xfree(pI830->pVisualConfigs);
   if (pI830->pVisualConfigsPriv)
      xfree(pI830->pVisualConfigsPriv);
   pI830->directRenderingType = DRI_NONE;
}

static Bool
I830CreateContext(ScreenPtr pScreen, VisualPtr visual,
		  drm_context_t hwContext, void *pVisualConfigPriv,
		  DRIContextType contextStore)
{
   return TRUE;
}

static void
I830DestroyContext(ScreenPtr pScreen, drm_context_t hwContext,
		   DRIContextType contextStore)
{
}

Bool
I830DRIFinishScreenInit(ScreenPtr pScreen)
{
   DPRINTF(PFX, "I830DRIFinishScreenInit\n");

   if (!DRIFinishScreenInit(pScreen))
      return FALSE;

   /* move irq initialize later in EnterVT, as then we
    * would finish binding possible hw status page, which
    * requires irq ctrl ioctl not be called that early.
    */
   return TRUE;
}

static void
I830DRISwapContext(ScreenPtr pScreen, DRISyncType syncType,
		   DRIContextType oldContextType, void *oldContext,
		   DRIContextType newContextType, void *newContext)
{
   ScrnInfoPtr pScrn = xf86Screens[pScreen->myNum];
   I830Ptr pI830 = I830PTR(pScrn);

   if (syncType == DRI_3D_SYNC &&
       oldContextType == DRI_2D_CONTEXT && newContextType == DRI_2D_CONTEXT) {

      if (I810_DEBUG & DEBUG_VERBOSE_DRI)
	 ErrorF("i830DRISwapContext (in)\n");

      pI830->last_3d = LAST_3D_OTHER;

      if (!pScrn->vtSema)
     	 return;
      pI830->LockHeld = 1;
      if (!pI830->memory_manager)
	  i830_refresh_ring(pScrn);

   } else if (syncType == DRI_2D_SYNC &&
	      oldContextType == DRI_NO_CONTEXT &&
	      newContextType == DRI_2D_CONTEXT) {
      if (I810_DEBUG & DEBUG_VERBOSE_DRI)
	 ErrorF("i830DRISwapContext (out)\n");

      if (!pScrn->vtSema)
     	 return;
      pI830->LockHeld = 0;
   } else if (I810_DEBUG & DEBUG_VERBOSE_DRI)
      ErrorF("i830DRISwapContext (other)\n");
}

static void
I830DRIInitBuffers(WindowPtr pWin, RegionPtr prgn, CARD32 index)
{
   ScreenPtr pScreen = pWin->drawable.pScreen;
   ScrnInfoPtr pScrn = xf86Screens[pScreen->myNum];
   BoxPtr pbox;
   int nbox;
   int buffer, first_buffer, last_buffer;

   if (I810_DEBUG & DEBUG_VERBOSE_DRI)
      ErrorF("I830DRIInitBuffers\n");

   first_buffer = I830_SELECT_BACK;
   last_buffer = I830_SELECT_DEPTH;

   for (buffer = first_buffer; buffer <= last_buffer; buffer++) {
      pbox = REGION_RECTS(prgn);
      nbox = REGION_NUM_RECTS(prgn);

      if (!I830SelectBuffer(pScrn, buffer))
	 continue;

      if (buffer == I830_SELECT_DEPTH) {
	 switch (pScrn->bitsPerPixel) {
	 case 16:
	    I830SetupForSolidFill(pScrn, 0xffff, GXcopy, -1);
	    break;
	 case 32:
	    I830SetupForSolidFill(pScrn, 0xffffff, GXcopy, -1);
	    break;
	 }
      } else
	 I830SetupForSolidFill(pScrn, 0, GXcopy, -1);
      while (nbox--) {
	 I830SubsequentSolidFillRect(pScrn, pbox->x1, pbox->y1,
				     pbox->x2 - pbox->x1, pbox->y2 - pbox->y1);
	 pbox++;
      }
   }

   I830SelectBuffer(pScrn, I830_SELECT_FRONT);
   i830MarkSync(pScrn);
}

/* This routine is a modified form of XAADoBitBlt with the calls to
 * ScreenToScreenBitBlt built in. My routine has the prgnSrc as source
 * instead of destination. My origin is upside down so the ydir cases
 * are reversed.
 */
static void
I830DRIMoveBuffers(WindowPtr pParent, DDXPointRec ptOldOrg,
		   RegionPtr prgnSrc, CARD32 index)
{
   ScreenPtr pScreen = pParent->drawable.pScreen;
   ScrnInfoPtr pScrn = xf86Screens[pScreen->myNum];
   BoxPtr pboxTmp, pboxNext, pboxBase;
   DDXPointPtr pptTmp, pptNew2 = NULL;
   int xdir, ydir;

#if 0
   int screenwidth = pScrn->virtualX;
   int screenheight = pScrn->virtualY;
#else
   int screenwidth = pScreen->width;
   int screenheight = pScreen->height;
#endif

   BoxPtr pbox = REGION_RECTS(prgnSrc);
   int nbox = REGION_NUM_RECTS(prgnSrc);

   BoxPtr pboxNew1 = NULL;
   BoxPtr pboxNew2 = NULL;
   DDXPointPtr pptNew1 = NULL;
   DDXPointPtr pptSrc = &ptOldOrg;

   int dx = pParent->drawable.x - ptOldOrg.x;
   int dy = pParent->drawable.y - ptOldOrg.y;
   int buffer, first_buffer, last_buffer;

   /* If the copy will overlap in Y, reverse the order */
   if (dy > 0) {
      ydir = -1;

      if (nbox > 1) {
	 /* Keep ordering in each band, reverse order of bands */
	 pboxNew1 = (BoxPtr) xalloc(sizeof(BoxRec) * nbox);
	 if (!pboxNew1)
	    return;
	 pptNew1 = (DDXPointPtr) xalloc(sizeof(DDXPointRec) * nbox);
	 if (!pptNew1) {
	    xfree(pboxNew1);
	    return;
	 }
	 pboxBase = pboxNext = pbox + nbox - 1;
	 while (pboxBase >= pbox) {
	    while ((pboxNext >= pbox) && (pboxBase->y1 == pboxNext->y1))
	       pboxNext--;
	    pboxTmp = pboxNext + 1;
	    pptTmp = pptSrc + (pboxTmp - pbox);
	    while (pboxTmp <= pboxBase) {
	       *pboxNew1++ = *pboxTmp++;
	       *pptNew1++ = *pptTmp++;
	    }
	    pboxBase = pboxNext;
	 }
	 pboxNew1 -= nbox;
	 pbox = pboxNew1;
	 pptNew1 -= nbox;
	 pptSrc = pptNew1;
      }
   } else {
      /* No changes required */
      ydir = 1;
   }

   /* If the regions will overlap in X, reverse the order */
   if (dx > 0) {
      xdir = -1;

      if (nbox > 1) {
	 /*reverse orderof rects in each band */
	 pboxNew2 = (BoxPtr) xalloc(sizeof(BoxRec) * nbox);
	 pptNew2 = (DDXPointPtr) xalloc(sizeof(DDXPointRec) * nbox);
	 if (!pboxNew2 || !pptNew2) {
	    if (pptNew2)
	       xfree(pptNew2);
	    if (pboxNew2)
	       xfree(pboxNew2);
	    if (pboxNew1) {
	       xfree(pptNew1);
	       xfree(pboxNew1);
	    }
	    return;
	 }
	 pboxBase = pboxNext = pbox;
	 while (pboxBase < pbox + nbox) {
	    while ((pboxNext < pbox + nbox) && (pboxNext->y1 == pboxBase->y1))
	       pboxNext++;
	    pboxTmp = pboxNext;
	    pptTmp = pptSrc + (pboxTmp - pbox);
	    while (pboxTmp != pboxBase) {
	       *pboxNew2++ = *--pboxTmp;
	       *pptNew2++ = *--pptTmp;
	    }
	    pboxBase = pboxNext;
	 }
	 pboxNew2 -= nbox;
	 pbox = pboxNew2;
	 pptNew2 -= nbox;
	 pptSrc = pptNew2;
      }
   } else {
      /* No changes are needed */
      xdir = 1;
   }

   /* SelectBuffer isn't really a good concept for the i810.
    */
   I830EmitFlush(pScrn);
   first_buffer = I830_SELECT_BACK;
   last_buffer = I830_SELECT_DEPTH;

   for (buffer = first_buffer; buffer <= last_buffer; buffer++) {
      if (!I830SelectBuffer(pScrn, buffer))
	 continue;
      I830SetupForScreenToScreenCopy(pScrn, xdir, ydir, GXcopy, -1, -1);
      pbox = REGION_RECTS(prgnSrc);
      nbox = REGION_NUM_RECTS(prgnSrc);
      for (; nbox--; pbox++) {

	 int x1 = pbox->x1;
	 int y1 = pbox->y1;
	 int destx = x1 + dx;
	 int desty = y1 + dy;
	 int w = pbox->x2 - x1 + 1;
	 int h = pbox->y2 - y1 + 1;

	 if (destx < 0)
	    x1 -= destx, w += destx, destx = 0;
	 if (desty < 0)
	    y1 -= desty, h += desty, desty = 0;
	 if (destx + w > screenwidth)
	    w = screenwidth - destx;
	 if (desty + h > screenheight)
	    h = screenheight - desty;
	 if (w <= 0)
	    continue;
	 if (h <= 0)
	    continue;

	 if (I810_DEBUG & DEBUG_VERBOSE_DRI)
	    ErrorF("MoveBuffers %d,%d %dx%d dx: %d dy: %d\n",
		   x1, y1, w, h, dx, dy);

	 I830SubsequentScreenToScreenCopy(pScrn, x1, y1, destx, desty, w, h);
      }
   }

   I830SelectBuffer(pScrn, I830_SELECT_FRONT);
   I830EmitFlush(pScrn);

   if (pboxNew2) {
      xfree(pptNew2);
      xfree(pboxNew2);
   }
   if (pboxNew1) {
      xfree(pptNew1);
      xfree(pboxNew1);
   }
   i830MarkSync(pScrn);
}

static void
I830DRITransitionTo3d(ScreenPtr pScreen)
{
   ScrnInfoPtr pScrn = xf86Screens[pScreen->myNum];
   I830Ptr pI830 = I830PTR(pScrn);

   pI830->want_vblank_interrupts = TRUE;
   I830DRISetVBlankInterrupt(pScrn, TRUE);
}

static void
I830DRITransitionTo2d(ScreenPtr pScreen)
{
   ScrnInfoPtr pScrn = xf86Screens[pScreen->myNum];
   I830Ptr pI830 = I830PTR(pScrn);

   pI830->want_vblank_interrupts = FALSE;
   I830DRISetVBlankInterrupt(pScrn, FALSE);
}

static int
i830_name_buffer (ScrnInfoPtr pScrn, i830_memory *mem)
{
    if (mem && mem->bo)
    {
	if (!mem->gem_name)
	{
	    int ret;
	    ret = dri_bo_flink(mem->bo, &mem->gem_name);
	    if (ret != 0)
	    {
		xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
			   "[drm] failed to name buffer %d\n", -errno);
		return -1;
	    }
	}
	return mem->gem_name;
    }
    return -1;
}

/**
 * Update the SAREA fields with current buffer information.
 *
 * Most of the SAREA fields are already updated by i830_do_addmap().
 *
 * This does include other SAREA initialization which will actually be constant
 * over the lifetime of the server.
 */
static void
i830_update_sarea(ScrnInfoPtr pScrn, drmI830Sarea *sarea)
{
   ScreenPtr pScreen = pScrn->pScreen;
   I830Ptr pI830 = I830PTR(pScrn);

   if (pI830->directRenderingType == DRI_DRI2)
       return;

   sarea->width = pScreen->width;
   sarea->height = pScreen->height;
   sarea->pitch = pScrn->displayWidth;
   sarea->virtualX = pScrn->virtualX;
   sarea->virtualY = pScrn->virtualY;

   sarea->front_tiled = (pI830->front_buffer->tiling != TILE_NONE);
   sarea->back_tiled = (pI830->back_buffer->tiling != TILE_NONE);
   sarea->depth_tiled = (pI830->depth_buffer->tiling != TILE_NONE);
   sarea->rotated_tiled = FALSE;

   sarea->log_tex_granularity = pI830->TexGranularity;

   sarea->front_bo_handle = i830_name_buffer (pScrn, pI830->front_buffer);
   sarea->back_bo_handle = i830_name_buffer (pScrn, pI830->back_buffer);
   sarea->depth_bo_handle = i830_name_buffer (pScrn, pI830->depth_buffer);

   /* The rotation is now handled entirely by the X Server, so just leave the
    * DRI unaware.
    */
   sarea->rotation = 0;
   sarea->rotated_offset = -1;
   sarea->rotated_size = 0;
   sarea->rotated_pitch = pScrn->displayWidth;
}

/**
 * Updates the DRI mapping for the given i830_memory struct, with the given
 * flags.
 */
static int
i830_do_addmap(ScrnInfoPtr pScrn, i830_memory *mem,
	       drm_handle_t *sarea_handle, int *sarea_size, int *sarea_offset)
{
    I830Ptr pI830 = I830PTR(pScrn);
    int size = mem->size;

    if (mem == pI830->front_buffer) {
	/* Workaround for XAA pixmap cache: Don't use front_buffer->size
	 * and instead, calculate the visible frontbuffer size and round to
	 * avoid irritating the assertions of older DRI drivers.
	 */
	size = ROUND_TO_PAGE(pScrn->displayWidth * pScrn->virtualY *
			     pI830->cpp);
    }

    if (*sarea_handle != 0 &&
	(*sarea_size != size || *sarea_offset != mem->offset))
    {
	drmRmMap(pI830->drmSubFD, *sarea_handle);
	*sarea_handle = 0;
	*sarea_size = 0;
	*sarea_offset = 0;
    }

    if (*sarea_handle == 0) {
	int ret;

	ret = drmAddMap(pI830->drmSubFD,
			(drm_handle_t)(mem->offset + pI830->LinearAddr),
			size, DRM_AGP, 0,
			(drmAddress) sarea_handle);
	if (ret == 0) {
	    xf86DrvMsg(pScrn->scrnIndex, X_INFO,
		       "[drm] mapped %s at 0x%08lx, handle = 0x%08x\n",
		       mem->name, mem->offset + pI830->LinearAddr,
		       (int)*sarea_handle);
	    *sarea_size = size;
	    *sarea_offset = mem->offset;
	} else {
	    xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
		       "[drm] failed to map %s at 0x%08lx\n",
		       mem->name, mem->offset + pI830->LinearAddr);
	    return FALSE;
	}
    }

    return TRUE;
}

/**
 * Updates the DRM mappings with the current buffer information.
 *
 * Some old DRI drivers may be unprepared for buffers actually moving at
 * runtime, which would likely result in bus errors on software fallbacks or
 * hangs or misrendering on hardware rendering.
 */
static Bool
i830_update_dri_mappings(ScrnInfoPtr pScrn, drmI830Sarea *sarea)
{
   I830Ptr pI830 = I830PTR(pScrn);

   if (!i830_do_addmap(pScrn, pI830->front_buffer, &sarea->front_handle,
		       &sarea->front_size, &sarea->front_offset)) {
       xf86DrvMsg(pScrn->scrnIndex, X_INFO, "Disabling DRI.\n");
       return FALSE;
   }

   if (!i830_do_addmap(pScrn, pI830->back_buffer, &sarea->back_handle,
		       &sarea->back_size, &sarea->back_offset)) {
       xf86DrvMsg(pScrn->scrnIndex, X_INFO, "Disabling DRI.\n");
       return FALSE;
   }

   sarea->third_handle = 0;
   sarea->third_offset = 0;
   sarea->third_size = 0;

   if (!i830_do_addmap(pScrn, pI830->depth_buffer, &sarea->depth_handle,
		       &sarea->depth_size, &sarea->depth_offset)) {
       xf86DrvMsg(pScrn->scrnIndex, X_INFO, "Disabling DRI.\n");
       return FALSE;
   }

   if (pI830->allocate_classic_textures) {
       if (!i830_do_addmap(pScrn, pI830->textures, &sarea->tex_handle,
			   &sarea->tex_size, &sarea->tex_offset)) {
	   xf86DrvMsg(pScrn->scrnIndex, X_INFO, "Disabling DRI.\n");
	   return FALSE;
       }
   }

   return TRUE;
}

static void
i830_update_screen_private(ScrnInfoPtr pScrn, drmI830Sarea *sarea)
{
   I830Ptr pI830 = I830PTR(pScrn);

   pI830->pDRIInfo->frameBufferPhysicalAddress = (char *) pI830->LinearAddr;
   pI830->pDRIInfo->frameBufferStride = pScrn->displayWidth * pI830->cpp;
   pI830->pDRIInfo->frameBufferSize = sarea->front_size;
#if DRI_DRIVER_FRAMEBUFFER_MAP
   pI830->pDRIInfo->hFrameBuffer = sarea->front_handle;
#endif
}

/**
 * Update the SAREA fields, DRI mappings, and screen info passed through the
 * protocol.
 *
 * This gets called both at startup and after any of the buffers might have
 * been relocated.
 */
Bool
i830_update_dri_buffers(ScrnInfoPtr pScrn)
{
   ScreenPtr pScreen = pScrn->pScreen;
   I830Ptr pI830 = I830PTR(pScrn);
   drmI830Sarea *sarea;
   Bool success;

   if (pI830->directRenderingType != DRI_XF86DRI)
       return TRUE;

   sarea = (drmI830Sarea *) DRIGetSAREAPrivate(pScreen);

   success = i830_update_dri_mappings(pScrn, sarea);
   if (!success)
       return FALSE;
   i830_update_sarea(pScrn, sarea);
   i830_update_screen_private(pScrn, sarea);

   return TRUE;
}

Bool
I830DRISetVBlankInterrupt (ScrnInfoPtr pScrn, Bool on)
{
    I830Ptr pI830 = I830PTR(pScrn);
    xf86CrtcConfigPtr   xf86_config = XF86_CRTC_CONFIG_PTR(pScrn);
    drmI830VBlankPipe pipe;

    /* If we have no 3d running, then don't bother enabling the vblank
     * interrupt.
     */
    if (!pI830->want_vblank_interrupts)
	on = FALSE;

    if (pI830->directRenderingType == DRI_XF86DRI && pI830->drmMinor >= 5) {
	if (on) {
	    if (xf86_config->num_crtc > 1 && xf86_config->crtc[1]->enabled)
		if (pI830->drmMinor >= 6)
		    pipe.pipe = DRM_I830_VBLANK_PIPE_A | DRM_I830_VBLANK_PIPE_B;
		else
		    pipe.pipe = DRM_I830_VBLANK_PIPE_B;
	    else
		pipe.pipe = DRM_I830_VBLANK_PIPE_A;
	} else {
	    pipe.pipe = 0;
	}
	if (drmCommandWrite(pI830->drmSubFD, DRM_I830_SET_VBLANK_PIPE,
			    &pipe, sizeof (pipe))) {
	    return FALSE;
	}
    }

    return TRUE;
}

Bool
I830DRILock(ScrnInfoPtr pScrn)
{
   I830Ptr pI830 = I830PTR(pScrn);

   if (pI830->directRenderingType == DRI_XF86DRI && !pI830->LockHeld) {
      DRILock(screenInfo.screens[pScrn->scrnIndex], 0);
      pI830->LockHeld = 1;
      if (!pI830->memory_manager)
	  i830_refresh_ring(pScrn);
      return TRUE;
   }
   else
      return FALSE;
}



void
I830DRIUnlock(ScrnInfoPtr pScrn)
{
   I830Ptr pI830 = I830PTR(pScrn);

   if (pI830->directRenderingType == DRI_XF86DRI && pI830->LockHeld) {
      DRIUnlock(screenInfo.screens[pScrn->scrnIndex]);
      pI830->LockHeld = 0;
   }
}

#ifdef DRI2

d76 2
a77 2
    PixmapPtr pPixmap;
    unsigned int attachment;
d82 2
a83 1
I830DRI2CreateBuffers(DrawablePtr pDraw, unsigned int *attachments, int count)
d85 16
a100 54
    ScreenPtr pScreen = pDraw->pScreen;
    ScrnInfoPtr pScrn = xf86Screens[pScreen->myNum];
    I830Ptr pI830 = I830PTR(pScrn);
    DRI2BufferPtr buffers;
    dri_bo *bo;
    int i;
    I830DRI2BufferPrivatePtr privates;
    PixmapPtr pPixmap, pDepthPixmap;

    buffers = xcalloc(count, sizeof *buffers);
    if (buffers == NULL)
	return NULL;
    privates = xcalloc(count, sizeof *privates);
    if (privates == NULL) {
	xfree(buffers);
	return NULL;
    }

    pDepthPixmap = NULL;
    for (i = 0; i < count; i++) {
	if (attachments[i] == DRI2BufferFrontLeft) {
	    pPixmap = get_drawable_pixmap(pDraw);
	    pPixmap->refcnt++;
	} else if (attachments[i] == DRI2BufferStencil && pDepthPixmap) {
	    pPixmap = pDepthPixmap;
	    pPixmap->refcnt++;
	} else {
	    unsigned int hint = 0;

	    switch (attachments[i]) {
	    case DRI2BufferDepth:
		if (SUPPORTS_YTILING(pI830))
		    hint = INTEL_CREATE_PIXMAP_TILING_Y;
		else
		    hint = INTEL_CREATE_PIXMAP_TILING_X;
		break;
	    case DRI2BufferFakeFrontLeft:
	    case DRI2BufferFakeFrontRight:
	    case DRI2BufferBackLeft:
	    case DRI2BufferBackRight:
		    hint = INTEL_CREATE_PIXMAP_TILING_X;
		break;
	    }

	    if (!pI830->tiling ||
		(!IS_I965G(pI830) && !pI830->kernel_exec_fencing))
		hint = 0;

	    pPixmap = (*pScreen->CreatePixmap)(pScreen,
					       pDraw->width,
					       pDraw->height,
					       pDraw->depth,
					       hint);

d103 53
a155 2
	if (attachments[i] == DRI2BufferDepth)
	    pDepthPixmap = pPixmap;
a156 11
	buffers[i].attachment = attachments[i];
	buffers[i].pitch = pPixmap->devKind;
	buffers[i].cpp = pPixmap->drawable.bitsPerPixel / 8;
	buffers[i].driverPrivate = &privates[i];
	buffers[i].flags = 0; /* not tiled */
	privates[i].pPixmap = pPixmap;
	privates[i].attachment = attachments[i];

	bo = i830_get_pixmap_bo (pPixmap);
	if (dri_bo_flink(bo, &buffers[i].name) != 0) {
	    /* failed to name buffer */
d159 1
a159 3
    }

    return buffers;
d165 1
a165 1
I830DRI2CreateBuffer(DrawablePtr pDraw, unsigned int attachment,
d168 50
a217 37
    ScreenPtr pScreen = pDraw->pScreen;
    ScrnInfoPtr pScrn = xf86Screens[pScreen->myNum];
    I830Ptr pI830 = I830PTR(pScrn);
    DRI2Buffer2Ptr buffer;
    dri_bo *bo;
    I830DRI2BufferPrivatePtr privates;
    PixmapPtr pPixmap;

    buffer = xcalloc(1, sizeof *buffer);
    if (buffer == NULL)
	return NULL;
    privates = xcalloc(1, sizeof *privates);
    if (privates == NULL) {
	xfree(buffer);
	return NULL;
    }

    if (attachment == DRI2BufferFrontLeft) {
	pPixmap = get_drawable_pixmap(pDraw);
	pPixmap->refcnt++;
    } else {
	unsigned int hint = 0;

	switch (attachment) {
	case DRI2BufferDepth:
	case DRI2BufferDepthStencil:
	    if (SUPPORTS_YTILING(pI830))
		hint = INTEL_CREATE_PIXMAP_TILING_Y;
	    else
		hint = INTEL_CREATE_PIXMAP_TILING_X;
	    break;
	case DRI2BufferFakeFrontLeft:
	case DRI2BufferFakeFrontRight:
	case DRI2BufferBackLeft:
	case DRI2BufferBackRight:
	    hint = INTEL_CREATE_PIXMAP_TILING_X;
	    break;
d220 13
a232 26
	if (!pI830->tiling ||
	    (!IS_I965G(pI830) && !pI830->kernel_exec_fencing))
	    hint = 0;

	pPixmap = (*pScreen->CreatePixmap)(pScreen,
					   pDraw->width,
					   pDraw->height,
					   (format != 0)?format:pDraw->depth,
					   hint);

    }


    buffer->attachment = attachment;
    buffer->pitch = pPixmap->devKind;
    buffer->cpp = pPixmap->drawable.bitsPerPixel / 8;
    buffer->driverPrivate = privates;
    buffer->format = format;
    buffer->flags = 0; /* not tiled */
    privates->pPixmap = pPixmap;
    privates->attachment = attachment;

    bo = i830_get_pixmap_bo (pPixmap);
    if (dri_bo_flink(bo, &buffer->name) != 0) {
	/* failed to name buffer */
    }
d234 1
a234 1
    return buffer;
d242 1
a242 1
I830DRI2DestroyBuffers(DrawablePtr pDraw, DRI2BufferPtr buffers, int count)
d244 13
a256 15
    ScreenPtr pScreen = pDraw->pScreen;
    I830DRI2BufferPrivatePtr private;
    int i;

    for (i = 0; i < count; i++)
    {
	private = buffers[i].driverPrivate;
	(*pScreen->DestroyPixmap)(private->pPixmap);
    }

    if (buffers)
    {
	xfree(buffers[0].driverPrivate);
	xfree(buffers);
    }
d261 1
a261 2
static void
I830DRI2DestroyBuffer(DrawablePtr pDraw, DRI2Buffer2Ptr buffer)
d263 9
a271 9
    if (buffer) {
	I830DRI2BufferPrivatePtr private = buffer->driverPrivate;
	ScreenPtr pScreen = pDraw->pScreen;

	(*pScreen->DestroyPixmap)(private->pPixmap);

	xfree(private);
	xfree(buffer);
    }
d277 2
a278 2
I830DRI2CopyRegion(DrawablePtr pDraw, RegionPtr pRegion,
		   DRI2BufferPtr pDstBuffer, DRI2BufferPtr pSrcBuffer)
d280 85
a364 56
    I830DRI2BufferPrivatePtr srcPrivate = pSrcBuffer->driverPrivate;
    I830DRI2BufferPrivatePtr dstPrivate = pDstBuffer->driverPrivate;
    ScreenPtr pScreen = pDraw->pScreen;
    ScrnInfoPtr pScrn = xf86Screens[pScreen->myNum];
    I830Ptr pI830 = I830PTR(pScrn);
    DrawablePtr src = (srcPrivate->attachment == DRI2BufferFrontLeft)
	? pDraw : &srcPrivate->pPixmap->drawable;
    DrawablePtr dst = (dstPrivate->attachment == DRI2BufferFrontLeft)
	? pDraw : &dstPrivate->pPixmap->drawable;
    RegionPtr pCopyClip;
    GCPtr pGC;

    pGC = GetScratchGC(pDraw->depth, pScreen);
    pCopyClip = REGION_CREATE(pScreen, NULL, 0);
    REGION_COPY(pScreen, pCopyClip, pRegion);
    (*pGC->funcs->ChangeClip) (pGC, CT_REGION, pCopyClip, 0);
    ValidateGC(dst, pGC);

#if 0 /* not yet */
    /* Wait for the scanline to be outside the region to be copied */
    if (pixmap_is_scanout(get_drawable_pixmap(dst)) && pI830->swapbuffers_wait) {
	BoxPtr box;
	BoxRec crtcbox;
	int y1, y2;
	int pipe = -1, event, load_scan_lines_pipe;
	xf86CrtcPtr crtc;

	box = REGION_EXTENTS(unused, pGC->pCompositeClip);
	crtc = i830_covering_crtc(pScrn, box, NULL, &crtcbox);

	/* Make sure the CRTC is valid and this is the real front buffer */
	if (crtc != NULL && !crtc->rotatedData) {
	    pipe = i830_crtc_to_pipe(crtc);

	    if (pipe == 0) {
		event = MI_WAIT_FOR_PIPEA_SCAN_LINE_WINDOW;
		load_scan_lines_pipe = MI_LOAD_SCAN_LINES_DISPLAY_PIPEA;
	    } else {
		event = MI_WAIT_FOR_PIPEB_SCAN_LINE_WINDOW;
		load_scan_lines_pipe = MI_LOAD_SCAN_LINES_DISPLAY_PIPEB;
	    }

	    /* Make sure we don't wait for a scanline that will never occur */
	    y1 = (crtcbox.y1 <= box->y1) ? box->y1 - crtcbox.y1 : 0;
	    y2 = (box->y2 <= crtcbox.y2) ?
		box->y2 - crtcbox.y1 : crtcbox.y2 - crtcbox.y1;

	    BEGIN_BATCH(5);
	    /* The documentation says that the LOAD_SCAN_LINES command
	     * always comes in pairs. Don't ask me why. */
	    OUT_BATCH(MI_LOAD_SCAN_LINES_INCL | load_scan_lines_pipe);
	    OUT_BATCH((y1 << 16) | y2);
	    OUT_BATCH(MI_LOAD_SCAN_LINES_INCL | load_scan_lines_pipe);
	    OUT_BATCH((y1 << 16) | y2);
	    OUT_BATCH(MI_WAIT_FOR_EVENT | event);
	    ADVANCE_BATCH();
a365 2
    }
#endif
d367 14
a380 14
    (*pGC->ops->CopyArea)(src, dst,
			  pGC, 0, 0, pDraw->width, pDraw->height, 0, 0);
    FreeScratchGC(pGC);

    /* Emit a flush of the rendering cache, or on the 965 and beyond
     * rendering results may not hit the framebuffer until significantly
     * later.
     */
    I830EmitFlush(pScrn);
    pI830->need_mi_flush = FALSE;

    /* We can't rely on getting into the block handler before the DRI
     * client gets to run again so flush now. */
    intel_batch_flush(pScrn, TRUE);
d382 1
a382 1
    I830Sync(pScrn);
d384 1
a384 1
    drmCommandNone(pI830->drmSubFD, DRM_I915_GEM_THROTTLE);
d388 1
a388 1
Bool I830DRI2ScreenInit(ScreenPtr pScreen)
d390 7
a396 7
    ScrnInfoPtr pScrn = xf86Screens[pScreen->myNum];
    I830Ptr pI830 = I830PTR(pScrn);
    DRI2InfoRec info;
    char *p, buf[64];
    int i;
    struct stat sbuf;
    dev_t d;
d398 2
a399 2
    int dri2_major = 1;
    int dri2_minor = 0;
a401 5
    if (pI830->accel != ACCEL_UXA) {
	xf86DrvMsg(pScrn->scrnIndex, X_WARNING, "DRI2 requires UXA\n");
	return FALSE;
    }

d403 3
a405 9
    if (xf86LoaderCheckSymbol("DRI2Version")) {
	DRI2Version(& dri2_major, & dri2_minor);
    }
    if (dri2_minor < 1) {
	xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
		   "DRI2 requires DRI2 module version 1.1.0 or later\n");
 	return FALSE;
     }
#endif
d407 5
a411 12
    sprintf(buf, "pci:%04x:%02x:%02x.%d",
	    pI830->PciInfo->domain,
	    pI830->PciInfo->bus,
	    pI830->PciInfo->dev,
	    pI830->PciInfo->func);

    info.fd = -1;

#ifdef XF86DRM_MODE
    /* Use the already opened (master) fd from modesetting */
    if (pI830->use_drm_mode)
	info.fd = pI830->drmSubFD;
d414 1
a414 2
    if (info.fd < 0)
	info.fd = drmOpen("i915", buf);
d416 19
a434 24
    if (info.fd < 0) {
	xf86DrvMsg(pScrn->scrnIndex, X_WARNING, "Failed to open DRM device\n");
	return FALSE;
    }

    /* The whole drmOpen thing is a fiasco and we need to find a way
     * back to just using open(2).  For now, however, lets just make
     * things worse with even more ad hoc directory walking code to
     * discover the device file name. */

    fstat(info.fd, &sbuf);
    d = sbuf.st_rdev;

    p = pI830->deviceName;
    for (i = 0; i < DRM_MAX_MINOR; i++) {
	sprintf(p, DRM_DEV_NAME, DRM_DIR_NAME, i);
	if (stat(p, &sbuf) == 0 && sbuf.st_rdev == d)
	    break;
    }
    if (i == DRM_MAX_MINOR) {
	xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
		   "DRI2: failed to open drm device\n");
	return FALSE;
    }
d436 2
a437 2
    info.driverName = IS_I965G(pI830) ? "i965" : "i915";
    info.deviceName = p;
d440 3
a442 3
    info.version = 3;
    info.CreateBuffer = I830DRI2CreateBuffer;
    info.DestroyBuffer = I830DRI2DestroyBuffer;
d445 5
a449 5
    info.version = 2;
    info.CreateBuffers = NULL;
    info.DestroyBuffers = NULL;
    info.CreateBuffer = I830DRI2CreateBuffer;
    info.DestroyBuffer = I830DRI2DestroyBuffer;
d451 3
a453 3
    info.version = 1;
    info.CreateBuffers = I830DRI2CreateBuffers;
    info.DestroyBuffers = I830DRI2DestroyBuffers;
d457 1
a457 1
    info.CopyRegion = I830DRI2CopyRegion;
d459 1
a459 3
    pI830->drmSubFD = info.fd;

    return DRI2ScreenInit(pScreen, &info);
d462 1
a462 1
void I830DRI2CloseScreen(ScreenPtr pScreen)
d464 2
a465 2
    ScrnInfoPtr pScrn = xf86Screens[pScreen->myNum];
    I830Ptr pI830 = I830PTR(pScrn);
d467 2
a468 2
    DRI2CloseScreen(pScreen);
    pI830->directRenderingType = DRI_NONE;
a469 2

#endif
@


1.9
log
@update to xf86-video-intel 2.7.1. Tested by many.
@
text
@d96 6
d1538 1
d1541 1
d1566 1
a1566 4
	    if (pDraw->type == DRAWABLE_PIXMAP)
		pPixmap = (PixmapPtr) pDraw;
	    else
		pPixmap = (*pScreen->GetWindowPixmap)((WindowPtr) pDraw);
d1610 1
d1622 79
d1721 18
d1741 1
a1741 1
		   DRI2BufferPtr pDestBuffer, DRI2BufferPtr pSrcBuffer)
d1743 2
a1744 1
    I830DRI2BufferPrivatePtr private = pSrcBuffer->driverPrivate;
d1748 4
a1751 1
    PixmapPtr pPixmap = private->pPixmap;
d1759 46
a1804 3
    ValidateGC(pDraw, pGC);
    (*pGC->ops->CopyArea)(&pPixmap->drawable,
			  pDraw, pGC, 0, 0, pDraw->width, pDraw->height, 0, 0);
d1833 4
d1843 11
d1898 13
a1911 1

d1914 3
@


1.8
log
@Don't map the mmio region via the drm. This was only passed onto the
mesa dri driver, which hasn't needed this for a while.

ok matthieu@@.
@
text
@d68 6
d92 1
a92 14
/* This block and the corresponding configure test can be removed when
 * libdrm >= 2.3.1 is required.
 */
#ifndef HAVE_I915_FLIP

#define DRM_VBLANK_FLIP 0x8000000

typedef struct drm_i915_flip {
   int pipes;
} drm_i915_flip_t;

#undef DRM_IOCTL_I915_FLIP
#define DRM_IOCTL_I915_FLIP DRM_IOW(DRM_COMMAND_BASE + DRM_I915_FLIP, \
				    drm_i915_flip_t)
d94 2
a97 2
#include "dristruct.h"

a114 8
#if defined(DAMAGE) && (DRIINFO_MAJOR_VERSION > 5 ||		\
			(DRIINFO_MAJOR_VERSION == 5 && DRIINFO_MINOR_VERSION >= 1))
#define DRI_SUPPORTS_CLIP_NOTIFY 1
#else
#define DRI_SUPPORTS_CLIP_NOTIFY 0
static void I830DRITransitionMultiToSingle3d(ScreenPtr pScreen);
static void I830DRITransitionSingleToMulti3d(ScreenPtr pScreen);
#endif
a122 4
#if DRI_SUPPORTS_CLIP_NOTIFY
static void I830DRIClipNotify(ScreenPtr pScreen, WindowPtr *ppWin, int num);
#endif

d149 1
a149 1
   I830RingBuffer *ring = pI830->LpRing;
d156 19
a174 3
   info.ring_start = ring->mem->offset + pI830->LinearAddr;
   info.ring_end = ring->mem->end + pI830->LinearAddr;
   info.ring_size = ring->mem->size;
a175 1
   info.mmio_offset = -1;
d179 2
a180 8
   info.front_offset = pI830->front_buffer->offset;
   info.back_offset = pI830->back_buffer->offset;
   info.depth_offset = pI830->depth_buffer->offset;
   info.w = pScrn->virtualX;
   info.h = pScrn->virtualY;
   info.pitch = pScrn->displayWidth;
   info.back_pitch = pScrn->displayWidth;
   info.depth_pitch = pScrn->displayWidth;
d587 1
a587 1
      if (pI830->useEXA)
a590 4
#if DRI_SUPPORTS_CLIP_NOTIFY
      pDRIInfo->ClipNotify = I830DRIClipNotify;
#endif

a609 5
#if !DRI_SUPPORTS_CLIP_NOTIFY
   pDRIInfo->TransitionSingleToMulti3D = I830DRITransitionSingleToMulti3d;
   pDRIInfo->TransitionMultiToSingle3D = I830DRITransitionMultiToSingle3d;
#endif

a711 8
#ifdef DAMAGE
	 if (pI830->allowPageFlip && pI830->drmMinor < 9) {
	    xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
		       "DRM version 1.9 or newer required for Page flipping. "
		       "Disabling.\n");
	    pI830->allowPageFlip = FALSE;
	 }
#endif	 
d747 45
d805 3
a807 10
   DPRINTF(PFX, "I830DRIDoMappings\n");

   if (drmAddMap(pI830->drmSubFD,
		 (drm_handle_t)pI830->LpRing->mem->offset + pI830->LinearAddr,
		 pI830->LpRing->mem->size, DRM_AGP, 0,
		 (drmAddress) &pI830->ring_map) < 0) {
      xf86DrvMsg(pScreen->myNum, X_ERROR,
		 "[drm] drmAddMap(ring_map) failed. Disabling DRI\n");
      DRICloseScreen(pScreen);
      return FALSE;
a808 2
   xf86DrvMsg(pScreen->myNum, X_INFO, "[drm] ring buffer = 0x%08x\n",
	      (int)pI830->ring_map);
d815 5
a822 1
   sarea->third_handle = 0;
d919 1
d925 2
a926 1
   I830DRIInstIrqHandler(pScrn);
d940 1
a940 5
#ifdef DAMAGE
   REGION_UNINIT(pScreen, &pI830->driRegion);
#endif

   if (pI830DRI->irq) {
d961 1
a992 55
#ifdef DAMAGE
/* This should be done *before* XAA syncs,
 * Otherwise will have to sync again???
 */
static void
I830DRIDoRefreshArea (ScrnInfoPtr pScrn, int num, BoxPtr pbox, uint32_t dst)
{
   I830Ptr pI830 = I830PTR(pScrn);
   int i, cmd, br13 = (pScrn->displayWidth * pI830->cpp) | (0xcc << 16);

   if (pScrn->bitsPerPixel == 32) {
      cmd = (XY_SRC_COPY_BLT_CMD | XY_SRC_COPY_BLT_WRITE_ALPHA |
	     XY_SRC_COPY_BLT_WRITE_RGB);
      br13 |= 3 << 24;
   } else {
      cmd = (XY_SRC_COPY_BLT_CMD);
      br13 |= 1 << 24;
   }

   for (i = 0 ; i < num ; i++, pbox++) {
      BEGIN_BATCH(8);
      OUT_BATCH(cmd);
      OUT_BATCH(br13);
      OUT_BATCH((pbox->y1 << 16) | pbox->x1);
      OUT_BATCH((pbox->y2 << 16) | pbox->x2);
      OUT_BATCH(dst);
      OUT_BATCH((pbox->y1 << 16) | pbox->x1);
      OUT_BATCH(br13 & 0xffff);
      OUT_BATCH(pI830->front_buffer->offset);
      ADVANCE_BATCH();
   }
}

static void
I830DRIRefreshArea (ScrnInfoPtr pScrn, int num, BoxPtr pbox)
{
   I830Ptr pI830 = I830PTR(pScrn);
   drmI830Sarea *pSAREAPriv = DRIGetSAREAPrivate(pScrn->pScreen);

   /* Don't want to do this when no 3d is active and pages are
    * right-way-round :
    */
   if (!pSAREAPriv->pf_active && pSAREAPriv->pf_current_page == 0)
      return;

   I830DRIDoRefreshArea(pScrn, num, pbox, pI830->back_buffer->offset);

   if (pI830->third_buffer) {
      I830DRIDoRefreshArea(pScrn, num, pbox, pI830->third_buffer->offset);
   }

   DamageEmpty(pI830->pDamage);
}
#endif

d1007 1
a1007 1
      *pI830->last_3d = LAST_3D_OTHER;
d1012 2
a1013 9
      i830_refresh_ring(pScrn);

      I830EmitFlush(pScrn);

#ifdef DAMAGE
      if (!pI830->pDamage && pI830->allowPageFlip) {
	 PixmapPtr pPix  = pScreen->GetScreenPixmap(pScreen);
	 pI830->pDamage = DamageCreate(NULL, NULL, DamageReportNone, TRUE,
				       pScreen, pPix);
a1014 15
	 if (pI830->pDamage == NULL) {
	    xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
                       "No screen damage record, page flipping disabled\n");
            pI830->allowPageFlip = FALSE;
	 } else {
	    DamageRegister(&pPix->drawable, pI830->pDamage);

	    DamageDamageRegion(&pPix->drawable,
			       &WindowTable[pScreen->myNum]->winSize);

            xf86DrvMsg(pScrn->scrnIndex, X_INFO,
                       "Damage tracking initialized for page flipping\n");
	 }
    }
#endif
a1017 4
#ifdef DAMAGE
      drmI830Sarea *sPriv = (drmI830Sarea *) DRIGetSAREAPrivate(pScreen);
#endif

a1022 49

#ifdef DAMAGE
      if (pI830->pDamage) {
	 RegionPtr pDamageReg = DamageRegion(pI830->pDamage);

	 if (pDamageReg) {
	    RegionRec region;
	    int nrects;

	    REGION_NULL(pScreen, &region);
	    REGION_SUBTRACT(pScreen, &region, pDamageReg, &pI830->driRegion);

	    if ((nrects = REGION_NUM_RECTS(&region)))
	       I830DRIRefreshArea(pScrn, nrects, REGION_RECTS(&region));

	    REGION_UNINIT(pScreen, &region);
	 }
      }
#endif

      I830EmitFlush(pScrn);

#ifdef DAMAGE
      /* Try flipping back to the front page if necessary */
      if (sPriv && !sPriv->pf_enabled && sPriv->pf_current_page != 0) {
	 drm_i915_flip_t flip = { .pipes = 0 };

	 if (sPriv->pf_current_page & (0x3 << 2)) {
	    sPriv->pf_current_page = sPriv->pf_current_page & 0x3;
	    sPriv->pf_current_page |= (sPriv->third_handle ? 2 : 1) << 2;

	    flip.pipes |= 0x2;
	 }

	 if (sPriv->pf_current_page & 0x3) {
	    sPriv->pf_current_page = sPriv->pf_current_page & (0x3 << 2);
	    sPriv->pf_current_page |= sPriv->third_handle ? 2 : 1;

	    flip.pipes |= 0x1;
	 }

	 drmCommandWrite(pI830->drmSubFD, DRM_I915_FLIP, &flip, sizeof(flip));

	 if (sPriv->pf_current_page != 0)
	    xf86DrvMsg(pScreen->myNum, X_WARNING,
		       "[dri] %s: kernel failed to unflip buffers.\n", __func__);
      }
#endif

d1033 3
a1035 2
   BoxPtr pbox = REGION_RECTS(prgn);
   int nbox = REGION_NUM_RECTS(prgn);
d1040 9
a1048 5
   I830SetupForSolidFill(pScrn, 0, GXcopy, -1);
   while (nbox--) {
      I830SelectBuffer(pScrn, I830_SELECT_BACK);
      I830SubsequentSolidFillRect(pScrn, pbox->x1, pbox->y1,
				  pbox->x2 - pbox->x1, pbox->y2 - pbox->y1);
d1050 12
a1061 2
      if (I830PTR(pScrn)->third_buffer) {
	 I830SelectBuffer(pScrn, I830_SELECT_THIRD);
d1064 1
a1065 24

      pbox++;
   }

   /* Clear the depth buffer - uses 0xffff rather than 0.
    */
   pbox = REGION_RECTS(prgn);
   nbox = REGION_NUM_RECTS(prgn);

   I830SelectBuffer(pScrn, I830_SELECT_DEPTH);

   switch (pScrn->bitsPerPixel) {
   case 16:
      I830SetupForSolidFill(pScrn, 0xffff, GXcopy, -1);
      break;
   case 32:
      I830SetupForSolidFill(pScrn, 0xffffff, GXcopy, -1);
      break;
   }

   while (nbox--) {
      I830SubsequentSolidFillRect(pScrn, pbox->x1, pbox->y1,
				  pbox->x2 - pbox->x1, pbox->y2 - pbox->y1);
      pbox++;
a1082 1
   I830Ptr pI830 = I830PTR(pScrn);
d1105 1
d1187 2
a1188 2
   I830SetupForScreenToScreenCopy(pScrn, xdir, ydir, GXcopy, -1, -1);
   for (; nbox--; pbox++) {
d1190 2
a1191 16
      int x1 = pbox->x1;
      int y1 = pbox->y1;
      int destx = x1 + dx;
      int desty = y1 + dy;
      int w = pbox->x2 - x1 + 1;
      int h = pbox->y2 - y1 + 1;

      if (destx < 0)
	 x1 -= destx, w += destx, destx = 0;
      if (desty < 0)
	 y1 -= desty, h += desty, desty = 0;
      if (destx + w > screenwidth)
	 w = screenwidth - destx;
      if (desty + h > screenheight)
	 h = screenheight - desty;
      if (w <= 0)
d1193 28
a1220 6
      if (h <= 0)
	 continue;

      if (I810_DEBUG & DEBUG_VERBOSE_DRI)
	 ErrorF("MoveBuffers %d,%d %dx%d dx: %d dy: %d\n",
		x1, y1, w, h, dx, dy);
a1221 4
      I830SelectBuffer(pScrn, I830_SELECT_BACK);
      I830SubsequentScreenToScreenCopy(pScrn, x1, y1, destx, desty, w, h);
      if (pI830->third_buffer) {
	 I830SelectBuffer(pScrn, I830_SELECT_THIRD);
a1223 4
      if (!IS_I965G(pI830)) {
         I830SelectBuffer(pScrn, I830_SELECT_DEPTH);
         I830SubsequentScreenToScreenCopy(pScrn, x1, y1, destx, desty, w, h);
      }
d1225 1
a1239 56
/* Use callbacks from dri.c to support pageflipping mode for a single
 * 3d context without need for any specific full-screen extension.
 *
 * Also see tdfx driver for example of using these callbacks to
 * allocate and free 3d-specific memory on demand.
 */

/* Use the miext/shadow module to maintain a list of dirty rectangles.
 * These are blitted to the back buffer to keep both buffers clean
 * during page-flipping when the 3d application isn't fullscreen.
 *
 * Unlike most use of the shadow code, both buffers are in video
 * memory.
 *
 * An alternative to this would be to organize for all on-screen
 * drawing operations to be duplicated for the two buffers.  That
 * might be faster, but seems like a lot more work...
 */

static void
I830DRISetPfMask(ScreenPtr pScreen, int pfMask)
{
   ScrnInfoPtr pScrn = xf86Screens[pScreen->myNum];
   I830Ptr pI830 = I830PTR(pScrn);
   drmI830Sarea *pSAREAPriv = DRIGetSAREAPrivate(pScreen);

   if (pI830->allowPageFlip && pfMask) {
      pSAREAPriv->pf_enabled = pI830->allowPageFlip;
      pSAREAPriv->pf_active = pfMask;
   } else
      pSAREAPriv->pf_active = 0;
}

#if !DRI_SUPPORTS_CLIP_NOTIFY
static void
I830DRITransitionSingleToMulti3d(ScreenPtr pScreen)
{
   /* Tell the clients not to pageflip.  How?
    *   -- Field in sarea, plus bumping the window counters.
    *   -- DRM needs to cope with Front-to-Back swapbuffers.
    */
   I830DRISetPfMask(pScreen, 0);
}

static void
I830DRITransitionMultiToSingle3d(ScreenPtr pScreen)
{
   ScrnInfoPtr pScrn = xf86Screens[pScreen->myNum];
   I830Ptr pI830 = I830PTR(pScrn);

   /* Let the remaining 3d app start page flipping again.
    */
   I830DRISetPfMask(pScreen, pI830->allowPageFlip ? 0x3 : 0);
}
#endif /* !DRI_SUPPORTS_CLIP_NOTIFY */

a1245 2
   I830DRISetPfMask(pScreen, pI830->allowPageFlip ? 0x3 : 0);

a1254 5
   drmI830Sarea *sPriv = (drmI830Sarea *) DRIGetSAREAPrivate(pScreen);

   I830DRISetPfMask(pScreen, 0);

   sPriv->pf_enabled = 0;
d1260 2
a1261 3
#if DRI_SUPPORTS_CLIP_NOTIFY
static void
I830DRIClipNotify(ScreenPtr pScreen, WindowPtr *ppWin, int num)
d1263 11
a1273 34
   ScrnInfoPtr pScrn = xf86Screens[pScreen->myNum];
   I830Ptr pI830 = I830PTR(pScrn);
   unsigned pfMask = 0;

   REGION_UNINIT(pScreen, &pI830->driRegion);
   REGION_NULL(pScreen, &pI830->driRegion);

   if (num > 0) {
      drmI830Sarea *sPriv = (drmI830Sarea *) DRIGetSAREAPrivate(pScreen);
      BoxRec crtcBox[2];
      unsigned numvisible[2] = { 0, 0 };
      int i, j;

      crtcBox[0].x1 = sPriv->planeA_x;
      crtcBox[0].y1 = sPriv->planeA_y;
      crtcBox[0].x2 = crtcBox[0].x1 + sPriv->planeA_w;
      crtcBox[0].y2 = crtcBox[0].y1 + sPriv->planeA_h;
      crtcBox[1].x1 = sPriv->planeB_x;
      crtcBox[1].y1 = sPriv->planeB_y;
      crtcBox[1].x2 = crtcBox[1].x1 + sPriv->planeB_w;
      crtcBox[1].y2 = crtcBox[1].y1 + sPriv->planeB_h;

      for (i = 0; i < 2; i++) {
	 for (j = 0; j < num; j++) {
	    WindowPtr pWin = ppWin[j];

	    if (pWin) {
	       if (RECT_IN_REGION(pScreen, &pWin->clipList, &crtcBox[i]) !=
		   rgnOUT)
		  numvisible[i]++;

	       if (i == 0)
		  REGION_UNION(pScreen, &pI830->driRegion, &pWin->clipList,
			       &pI830->driRegion);
d1275 4
a1278 9
	 }

	 if (numvisible[i] == 1)
	    pfMask |= 1 << i;
      }
   } else
      REGION_NULL(pScreen, &pI830->driRegion);

   I830DRISetPfMask(pScreen, pfMask);
a1279 1
#endif /* DRI_SUPPORTS_CLIP_NOTIFY */
d1295 3
a1305 4
   if (pI830->third_buffer != NULL)
       sarea->third_tiled = (pI830->third_buffer->tiling != TILE_NONE);
   else
       sarea->third_tiled = FALSE;
d1311 3
a1313 14
   sarea->front_bo_handle = -1;
   sarea->back_bo_handle = -1;
   sarea->third_bo_handle = -1;
   sarea->depth_bo_handle = -1;
#ifdef XF86DRI_MM
   if (pI830->front_buffer->bo.size)
       sarea->front_bo_handle = pI830->front_buffer->bo.handle;
   if (pI830->back_buffer->bo.size)
       sarea->back_bo_handle = pI830->back_buffer->bo.handle;
   if (pI830->third_buffer != NULL && pI830->third_buffer->bo.size)
       sarea->third_bo_handle = pI830->third_buffer->bo.handle;
   if (pI830->depth_buffer->bo.size)
       sarea->depth_bo_handle = pI830->depth_buffer->bo.handle;
#endif
d1402 3
a1404 11
   if (pI830->third_buffer) {
       if (!i830_do_addmap(pScrn, pI830->third_buffer, &sarea->third_handle,
			   &sarea->third_size, &sarea->third_offset)) {
	   xf86DrvMsg(pScrn->scrnIndex, X_INFO, "Disabling DRI.\n");
	   return FALSE;
       }
   } else {
       sarea->third_handle = 0;
       sarea->third_offset = 0;
       sarea->third_size = 0;
   }
d1447 2
a1448 1
   drmI830Sarea *sarea = (drmI830Sarea *) DRIGetSAREAPrivate(pScreen);
d1451 5
d1478 1
a1478 1
    if (pI830->directRenderingEnabled && pI830->drmMinor >= 5) {
d1504 1
a1504 1
   if (pI830->directRenderingEnabled && !pI830->LockHeld) {
d1507 2
a1508 1
      i830_refresh_ring(pScrn);
d1522 1
a1522 1
   if (pI830->directRenderingEnabled && pI830->LockHeld) {
d1527 227
@


1.7
log
@xf86-video-intel 2.4.2. Has been in snapshots for weeks. Ok oga@@.
@
text
@d179 1
a179 1
   info.mmio_offset = (unsigned int)pI830DRI->regs;
a787 10
   pI830DRI->regsSize = I830_REG_SIZE;
   if (drmAddMap(pI830->drmSubFD, (drm_handle_t)pI830->MMIOAddr,
		 pI830DRI->regsSize, DRM_REGISTERS, 0,
		 (drmAddress) &pI830DRI->regs) < 0) {
      xf86DrvMsg(pScreen->myNum, X_ERROR, "[drm] drmAddMap(regs) failed\n");
      DRICloseScreen(pScreen);
      return FALSE;
   }
   xf86DrvMsg(pScreen->myNum, X_INFO, "[drm] Registers = 0x%08x\n",
	      (int)pI830DRI->regs);
@


1.6
log
@Update to xf86-video-intel 2.3.1. Tested by many.
@
text
@d389 1
a389 1
	 for (depth = 0; depth <= 1; depth++) {	/* and stencil */
@


1.5
log
@Update to Intel driver 2.2.1. But change default accelmethod to XAA.
Tested by landry@@, oga@@, steven@@, jakemsr@@.
@
text
@d138 1
a138 1
#ifdef DRI_SUPPORTS_CLIP_NOTIFY
d750 1
a755 1
   drmI830MemInitHeap drmHeap;
d996 1
a996 1
I830DRIDoRefreshArea (ScrnInfoPtr pScrn, int num, BoxPtr pbox, CARD32 dst)
d1011 10
a1020 10
      BEGIN_LP_RING(8);
      OUT_RING(cmd);
      OUT_RING(br13);
      OUT_RING((pbox->y1 << 16) | pbox->x1);
      OUT_RING((pbox->y2 << 16) | pbox->x2);
      OUT_RING(dst);
      OUT_RING((pbox->y1 << 16) | pbox->x1);
      OUT_RING(br13 & 0xffff);
      OUT_RING(pI830->front_buffer->offset);
      ADVANCE_LP_RING();
@


1.4
log
@Merge intel driver version 2.2.0.90.
@
text
@d239 2
a240 2
static Bool
I830SetHWS(ScrnInfoPtr pScrn, int addr)
d245 1
a245 1
    hws.addr = addr;
d250 1
a250 1
		"G33 status page initialization Failed\n");
a815 6
   if (IS_G33CLASS(pI830)) {
       if (!I830SetHWS(pScrn, pI830->hw_status->offset)) {
	   DRICloseScreen(pScreen);
	   return FALSE;
       }
   }
d878 1
a878 1
I830DRIResume(ScreenPtr pScreen)
a879 1
   ScrnInfoPtr pScrn = xf86Screens[pScreen->myNum];
d883 1
a883 6
   DPRINTF(PFX, "I830DRIResume\n");

   I830ResumeDma(pScrn);

   {
      pI830DRI->irq = drmGetInterruptFromBusID(pI830->drmSubFD,
d899 9
a907 11
      if (drmCtlInstHandler(pI830->drmSubFD, pI830DRI->irq)) {
	 xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
		    "[drm] failure adding irq handler\n");
	 pI830DRI->irq = 0;
	 return FALSE;
      }
      else
	 xf86DrvMsg(pScrn->scrnIndex, X_INFO,
		    "[drm] dma control initialized, using IRQ %d\n",
		    pI830DRI->irq);
   }
d909 15
a923 1
   return FALSE;
a978 3
   ScrnInfoPtr        pScrn = xf86Screens[pScreen->myNum];
   I830Ptr pI830 = I830PTR(pScrn);

d984 5
a988 33
   /* Okay now initialize the dma engine */
   {
      I830DRIPtr pI830DRI = (I830DRIPtr) pI830->pDRIInfo->devPrivate;

      pI830DRI->irq = drmGetInterruptFromBusID(pI830->drmSubFD,
#if XSERVER_LIBPCIACCESS
					       ((pI830->PciInfo->domain << 8) |
						pI830->PciInfo->bus),
					       pI830->PciInfo->dev,
					       pI830->PciInfo->func
#else
					       ((pciConfigPtr) pI830->
						PciInfo->thisCard)->busnum,
					       ((pciConfigPtr) pI830->
						PciInfo->thisCard)->devnum,
					       ((pciConfigPtr) pI830->
						PciInfo->thisCard)->funcnum
#endif
					       );

      if (drmCtlInstHandler(pI830->drmSubFD, pI830DRI->irq)) {
	 xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
		    "[drm] failure adding irq handler\n");
	 pI830DRI->irq = 0;
	 DRICloseScreen(pScreen);
	 return FALSE;
      }
      else
	 xf86DrvMsg(pScrn->scrnIndex, X_INFO,
		    "[drm] dma control initialized, using IRQ %d\n",
		    pI830DRI->irq);
	 return TRUE;
   }
@


1.3
log
@merge xf86-video-intel 2.2.0
@
text
@d1252 1
a1252 1
   DDXPointPtr pptTmp, pptNew2;
d1280 1
a1280 1
	 pboxNew1 = (BoxPtr) ALLOCATE_LOCAL(sizeof(BoxRec) * nbox);
d1283 1
a1283 1
	 pptNew1 = (DDXPointPtr) ALLOCATE_LOCAL(sizeof(DDXPointRec) * nbox);
d1285 1
a1285 1
	    DEALLOCATE_LOCAL(pboxNew1);
d1316 2
a1317 2
	 pboxNew2 = (BoxPtr) ALLOCATE_LOCAL(sizeof(BoxRec) * nbox);
	 pptNew2 = (DDXPointPtr) ALLOCATE_LOCAL(sizeof(DDXPointRec) * nbox);
d1320 1
a1320 1
	       DEALLOCATE_LOCAL(pptNew2);
d1322 1
a1322 1
	       DEALLOCATE_LOCAL(pboxNew2);
d1324 2
a1325 2
	       DEALLOCATE_LOCAL(pptNew1);
	       DEALLOCATE_LOCAL(pboxNew1);
d1396 2
a1397 2
      DEALLOCATE_LOCAL(pptNew2);
      DEALLOCATE_LOCAL(pboxNew2);
d1400 2
a1401 2
      DEALLOCATE_LOCAL(pptNew1);
      DEALLOCATE_LOCAL(pboxNew1);
@


1.2
log
@Add support for the mobile i965GM chipset.

tested by many
ok matthieu@@
@
text
@d84 19
a104 5
static char I830KernelDriverName[] = "i915";
static char I830ClientDriverName[] = "i915tex";
static char I965ClientDriverName[] = "i965";
static char I830LegacyClientDriverName[] = "i915";

d122 5
d129 8
d138 2
a139 2
#if 0
static void I830DRIShadowUpdate (ScreenPtr pScreen, shadowBufPtr pBuf);
d175 3
a177 3
   info.ring_start = ring->mem.Start + pI830->LinearAddr;
   info.ring_end = ring->mem.End + pI830->LinearAddr;
   info.ring_size = ring->mem.Size;
d183 3
a185 3
   info.front_offset = pI830->FrontBuffer.Start;
   info.back_offset = pI830->BackBuffer.Start;
   info.depth_offset = pI830->DepthBuffer.Start;
d188 3
a190 3
   info.pitch = pI830->displayWidth;
   info.back_pitch = pI830->displayWidth;
   info.depth_pitch = pI830->displayWidth;
d239 16
d262 3
a264 3
   __GLXvisualConfig *pConfigs = 0;
   I830ConfigPrivPtr pI830Configs = 0;
   I830ConfigPrivPtr *pI830ConfigPtrs = 0;
d472 3
a474 1
   if (!xf86LoaderCheckSymbol("GlxSetVisualConfigs"))
d476 4
a479 1
   if (!xf86LoaderCheckSymbol("DRIScreenInit"))
d481 4
a484 1
   if (!xf86LoaderCheckSymbol("drmAvailable"))
d486 1
d489 1
a489 1
		 "[dri] %s failed (libdri.a too old)\n", "I830CheckDRIAvailable");
d498 2
a499 1
      if (major != DRIINFO_MAJOR_VERSION || minor < DRIINFO_MINOR_VERSION) {
d536 5
a540 5
   pDRIInfo->drmDriverName = I830KernelDriverName;
   if (IS_I96X(pI830))
      pDRIInfo->clientDriverName = I965ClientDriverName;
   else 
      pDRIInfo->clientDriverName = I830ClientDriverName;
d547 4
d553 3
a555 1
	      ((pciConfigPtr) pI830->PciInfo->thisCard)->funcnum);
a559 10
#if 1 /* Remove this soon - see bug 5714 */
   pDRIInfo->frameBufferPhysicalAddress = (char *) pI830->LinearAddr +
					  pI830->FrontBuffer.Start;
   pDRIInfo->frameBufferSize = ROUND_TO_PAGE(pScrn->displayWidth *
					     pScrn->virtualY * pI830->cpp);
#else
   /* For rotation we map a 0 length framebuffer as we remap ourselves later */
   pDRIInfo->frameBufferSize = 0;
#endif
   pDRIInfo->frameBufferStride = pScrn->displayWidth * pI830->cpp;
d581 1
a581 1
      pI830->pDRIInfo = 0;
d594 27
d623 2
d627 1
d634 1
a634 1
      pDRIInfo->devPrivate = 0;
d636 1
a636 1
      pI830->pDRIInfo = 0;
d640 17
a656 14
#if 0 /* disabled now, see frameBufferSize above being set to 0 */
   /* for this driver, get rid of the front buffer mapping now */
   if (xf86LoaderCheckSymbol("DRIGetScreenPrivate")) {
      DRIScreenPrivPtr pDRIPriv 
         = (DRIScreenPrivPtr) DRIGetScreenPrivate(pScreen);

      if (pDRIPriv && pDRIPriv->drmFD && pDRIPriv->hFrameBuffer) {
         xf86DrvMsg(pScreen->myNum, X_ERROR,
                    "[intel] removing original screen mapping\n");
         drmRmMap(pDRIPriv->drmFD, pDRIPriv->hFrameBuffer);
         pDRIPriv->hFrameBuffer = 0;
         xf86DrvMsg(pScreen->myNum, X_ERROR,
                    "[intel] done removing original screen mapping\n");
      }
a657 5
   else {
      xf86DrvMsg(pScreen->myNum, X_ERROR,
                 "[intel] DRIGetScreenPrivate not found!!!!\n");
   }      
#endif
d717 9
a725 3
	 if (strncmp(version->name, I830KernelDriverName, strlen(I830KernelDriverName))) {
	    xf86DrvMsg(pScreen->myNum, X_WARNING, 
			"i830 Kernel module detected, Use the i915 Kernel module instead, aborting DRI init.\n");
d731 8
a738 12
	 if (!(pI830->mmModeFlags & I830_KERNEL_TEX)) {
	    if ((version->version_major > 1) ||
		((version->version_minor >= 7) && 
		 (version->version_major == 1))) {
	       pI830->mmModeFlags |= I830_KERNEL_MM;
	    } else {
	       pI830->mmModeFlags |= I830_KERNEL_TEX;
	    }		
	 } else {
	    xf86DrvMsg(pScreen->myNum, X_INFO, 
		       "Not enabling the DRM memory manager.\n");
	 } 
a742 9
   /*
    * Backwards compatibility
    */

   if ((pDRIInfo->clientDriverName == I830ClientDriverName) && 
       (pI830->mmModeFlags & I830_KERNEL_TEX)) {
      pDRIInfo->clientDriverName = I830LegacyClientDriverName;
   }

d746 2
a747 76
Bool
I830DRIMapScreenRegions(ScrnInfoPtr pScrn, drmI830Sarea *sarea)
{
   ScreenPtr pScreen = pScrn->pScreen;
   I830Ptr pI830 = I830PTR(pScrn);

#if 1 /* Remove this soon - see bug 5714 */
   pI830->pDRIInfo->frameBufferSize = ROUND_TO_PAGE(pScrn->displayWidth *
					     pScrn->virtualY * pI830->cpp);
#endif

   /* The I965 isn't ready for the front buffer mapping to be moved around,
    * because of issues with rmmap, it seems.
    */
   if (!IS_I96X(pI830)) {
      xf86DrvMsg(pScrn->scrnIndex, X_INFO,
		 "[drm] Mapping front buffer\n");
      if (drmAddMap(pI830->drmSubFD,
		    (drm_handle_t)(sarea->front_offset + pI830->LinearAddr),
		    sarea->front_size,
		    DRM_AGP,
		    0,
		    (drmAddress) &sarea->front_handle) < 0) {
	 xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
		    "[drm] drmAddMap(front_handle) failed. Disabling DRI\n");
	 DRICloseScreen(pScreen);
	 return FALSE;
      }
      xf86DrvMsg(pScrn->scrnIndex, X_INFO, "[drm] Front Buffer = 0x%08x\n",
		 (int)sarea->front_handle);
   }

   if (drmAddMap(pI830->drmSubFD,
                 (drm_handle_t)(sarea->back_offset + pI830->LinearAddr),
                 sarea->back_size, DRM_AGP, 0,
                 (drmAddress) &sarea->back_handle) < 0) {
      xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
                 "[drm] drmAddMap(back_handle) failed. Disabling DRI\n");
      DRICloseScreen(pScreen);
      return FALSE;
   }
   xf86DrvMsg(pScrn->scrnIndex, X_INFO, "[drm] Back Buffer = 0x%08x\n",
              (int)sarea->back_handle);

   if (drmAddMap(pI830->drmSubFD,
                 (drm_handle_t)sarea->depth_offset + pI830->LinearAddr,
                 sarea->depth_size, DRM_AGP, 0,
                 (drmAddress) &sarea->depth_handle) < 0) {
      xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
                 "[drm] drmAddMap(depth_handle) failed. Disabling DRI\n");
      DRICloseScreen(pScreen);
      return FALSE;
   }
   xf86DrvMsg(pScrn->scrnIndex, X_INFO, "[drm] Depth Buffer = 0x%08x\n",
              (int)sarea->depth_handle);

   if (pI830->mmModeFlags & I830_KERNEL_TEX) {
      if (drmAddMap(pI830->drmSubFD,
		    (drm_handle_t)sarea->tex_offset + pI830->LinearAddr,
		    sarea->tex_size, DRM_AGP, 0,
		    (drmAddress) &sarea->tex_handle) < 0) {
	 xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
		    "[drm] drmAddMap(tex_handle) failed. Disabling DRI\n");
	 DRICloseScreen(pScreen);
	 return FALSE;
      }

      xf86DrvMsg(pScrn->scrnIndex, X_INFO, "[drm] textures = 0x%08x\n",
		 (int)sarea->tex_handle);
   }
   return TRUE;
}


void
I830DRIUnmapScreenRegions(ScrnInfoPtr pScrn, drmI830Sarea *sarea)
d751 2
a752 22
   if (sarea->front_handle) {
      drmRmMap(pI830->drmSubFD, sarea->front_handle);
      sarea->front_handle = 0;
   }
   if (sarea->back_handle) {
      drmRmMap(pI830->drmSubFD, sarea->back_handle);
      sarea->back_handle = 0;
   }
   if (sarea->depth_handle) {
      drmRmMap(pI830->drmSubFD, sarea->depth_handle);
      sarea->depth_handle = 0;
   }
   if (sarea->tex_handle) {
      drmRmMap(pI830->drmSubFD, sarea->tex_handle);
      sarea->tex_handle = 0;
   }
}

static void
I830InitTextureHeap(ScrnInfoPtr pScrn, drmI830Sarea *sarea)
{
   I830Ptr pI830 = I830PTR(pScrn);
d758 2
a759 2
   drmHeap.size   = sarea->tex_size;
      
d766 2
a767 2
		    "[drm] Initialized kernel agp heap manager, %d\n",
		    sarea->tex_size);
d770 1
a770 1
		      sarea->log_tex_granularity);
d774 4
d800 2
a801 2
		 (drm_handle_t)pI830->LpRing->mem.Start + pI830->LinearAddr,
		 pI830->LpRing->mem.Size, DRM_AGP, 0,
d816 6
d825 1
d836 13
a848 6
   /* this will map the screen regions */
   if (!I830UpdateDRIBuffers(pScrn, sarea)) {
      /* screen mappings probably failed */
      xf86DrvMsg(pScreen->myNum, X_ERROR,
		 "[drm] drmAddMap(screen mappings) failed. Disabling DRI\n");
      return FALSE;
d851 5
a855 2
   if (pI830->PciInfo->chipType != PCI_CHIP_845_G &&
       pI830->PciInfo->chipType != PCI_CHIP_I830_M) {
d860 1
a860 1
   pI830DRI->deviceID = pI830->PciInfo->chipType;
d896 6
d907 3
a909 1
						PciInfo->thisCard)->funcnum);
d935 4
d951 1
a951 1
	 pI830->pDRIInfo->devPrivate = 0;
d954 1
a954 1
      pI830->pDRIInfo = 0;
a983 11
   /* Have shadow run only while there is 3d active.
    */
#if 0
   if (pI830->allowPageFlip && pI830->drmMinor >= 1) {
      shadowAdd(pScreen, 0, I830DRIShadowUpdate, 0, 0, 0);
   }
   else
#endif
      pI830->allowPageFlip = 0;


d992 6
d1003 3
a1005 1
						PciInfo->thisCard)->funcnum);
d1022 56
a1077 1
void
a1086 1
      ScrnInfoPtr pScrn = xf86Screens[pScreen->myNum];
d1091 2
d1096 25
a1120 1
      I830RefreshRing(pScrn);
d1124 4
a1127 1
      pI830->LockHeld = 0;
d1130 53
a1191 1
   I830Ptr pI830 = I830PTR(pScrn);
d1203 7
d1236 1
a1236 1
   pI830->AccelInfoRec->NeedToSync = TRUE;
d1266 3
a1268 3
   BoxPtr pboxNew1 = 0;
   BoxPtr pboxNew2 = 0;
   DDXPointPtr pptNew1 = 0;
d1383 5
a1387 1
      if (!IS_I96X(pI830)) {
d1403 1
a1403 2

   pI830->AccelInfoRec->NeedToSync = TRUE;
a1412 4




a1424 5

#if 0
/* This should be done *before* XAA syncs,
 * Otherwise will have to sync again???
 */
d1426 1
a1426 1
I830DRIShadowUpdate (ScreenPtr pScreen, shadowBufPtr pBuf)
a1429 3
   RegionPtr damage = &pBuf->damage;
   int i, num =  REGION_NUM_RECTS(damage);
   BoxPtr pbox = REGION_RECTS(damage);
a1430 7
   int cmd, br13;

   /* Don't want to do this when no 3d is active and pages are
    * right-way-round :
    */
   if (!pSAREAPriv->pf_active && pSAREAPriv->pf_current_page == 0)
      return;
d1432 5
a1436 60
   br13 = (pScrn->displayWidth * pI830->cpp) | (0xcc << 16);

   if (pScrn->bitsPerPixel == 32) {
      cmd = (XY_SRC_COPY_BLT_CMD | XY_SRC_COPY_BLT_WRITE_ALPHA |
	     XY_SRC_COPY_BLT_WRITE_RGB);
      br13 |= 3 << 24;
   } else {
      cmd = (XY_SRC_COPY_BLT_CMD);
      br13 |= 1 << 24;
   }

   for (i = 0 ; i < num ; i++, pbox++) {
      BEGIN_LP_RING(8);
      OUT_RING(cmd);
      OUT_RING(br13);
      OUT_RING((pbox->y1 << 16) | pbox->x1);
      OUT_RING((pbox->y2 << 16) | pbox->x2);
      OUT_RING(pI830->BackBuffer.Start);
      OUT_RING((pbox->y1 << 16) | pbox->x1);
      OUT_RING(br13 & 0xffff);
      OUT_RING(pI830->FrontBuffer.Start);
      ADVANCE_LP_RING();
   }
}
#endif

static void
I830EnablePageFlip(ScreenPtr pScreen)
{
   ScrnInfoPtr pScrn = xf86Screens[pScreen->myNum];
   I830Ptr pI830 = I830PTR(pScrn);
   drmI830Sarea *pSAREAPriv = DRIGetSAREAPrivate(pScreen);

   pSAREAPriv->pf_enabled = pI830->allowPageFlip;
   pSAREAPriv->pf_active = 0;

   if (pI830->allowPageFlip) {
      int br13 = (pScrn->displayWidth * pI830->cpp) | (0xcc << 16);

      BEGIN_LP_RING(8);
      if (pScrn->bitsPerPixel == 32) {
	 OUT_RING(XY_SRC_COPY_BLT_CMD | XY_SRC_COPY_BLT_WRITE_ALPHA |
		  XY_SRC_COPY_BLT_WRITE_RGB);
	 br13 |= 3 << 24;
      } else {
	 OUT_RING(XY_SRC_COPY_BLT_CMD);
	 br13 |= 1 << 24;
      }

      OUT_RING(br13);
      OUT_RING(0);
      OUT_RING((pScrn->virtualY << 16) | pScrn->virtualX);
      OUT_RING(pI830->BackBuffer.Start);
      OUT_RING(0);
      OUT_RING(br13 & 0xffff);
      OUT_RING(pI830->FrontBuffer.Start);
      ADVANCE_LP_RING();

      pSAREAPriv->pf_active = 1;
   }
d1439 1
a1439 9
static void
I830DisablePageFlip(ScreenPtr pScreen)
{
   drmI830Sarea *pSAREAPriv = DRIGetSAREAPrivate(pScreen);

   pSAREAPriv->pf_active = 0;
}


d1447 1
a1447 1
   I830DisablePageFlip(pScreen);
d1453 3
d1458 1
a1458 1
   I830EnablePageFlip(pScreen);
d1460 1
d1468 4
a1471 2
   I830EnablePageFlip(pScreen);
   pI830->have3DWindows = 1;
a1473 1

d1481 58
a1538 3
   /* Try flipping back to the front page if necessary */
   if (sPriv->pf_current_page == 1)
      drmCommandNone(pI830->drmSubFD, DRM_I830_FLIP);
d1540 48
a1587 1
   /* Shut down shadowing if we've made it back to the front page:
d1589 37
a1625 3
   if (sPriv->pf_current_page == 0) {
      I830DisablePageFlip(pScreen);
   }
d1627 18
a1644 1
   pI830->have3DWindows = 0;
d1646 1
a1648 1

d1650 5
a1654 2
 * Update the SAREA fields with the most recent values.
 * This gets called after the screen orientation/rotation changes.
d1656 2
a1657 2
Bool
I830UpdateDRIBuffers(ScrnInfoPtr pScrn, drmI830Sarea *sarea)
a1659 2
   ScreenPtr pScreen = pScrn->pScreen;
   Bool success;
d1661 5
a1665 1
   I830DRIUnmapScreenRegions(pScrn, sarea);
d1667 5
a1671 7
   sarea->front_tiled = pI830->front_tiled;
   sarea->back_tiled = pI830->back_tiled;
   sarea->depth_tiled = pI830->depth_tiled;
   sarea->rotated_tiled = pI830->rotated_tiled;
#if 0
   sarea->rotated2_tiled = pI830->rotated2_tiled;
#endif
d1673 6
a1678 6
   if (pI830->rotation == RR_Rotate_0) {
      sarea->front_offset = pI830->FrontBuffer.Start;
      /* Don't use FrontBuffer.Size here as it includes the pixmap cache area
       * Instead, calculate the entire framebuffer.
       */
      sarea->front_size = pI830->displayWidth * pScrn->virtualY * pI830->cpp;
d1680 17
a1696 3
      /* Need to deal with rotated2 once we have dual head DRI */
      sarea->front_offset = pI830->RotatedMem.Start;
      sarea->front_size = pI830->RotatedMem.Size;
d1699 2
a1700 3
   xf86DrvMsg(pScrn->scrnIndex, X_INFO,
              "[drm] init sarea width,height = %d x %d (pitch %d)\n",
              pScreen->width, pScreen->height,pScrn->displayWidth);
d1702 4
a1705 12
   sarea->width = pScreen->width;
   sarea->height = pScreen->height;
   sarea->back_offset = pI830->BackBuffer.Start;
   sarea->back_size = pI830->BackBuffer.Size;
   sarea->depth_offset = pI830->DepthBuffer.Start;
   sarea->depth_size = pI830->DepthBuffer.Size;
   sarea->tex_offset = pI830->TexMem.Start;
   sarea->tex_size = pI830->TexMem.Size;
   sarea->log_tex_granularity = pI830->TexGranularity;
   sarea->pitch = pScrn->displayWidth;
   sarea->virtualX = pScrn->virtualX;
   sarea->virtualY = pScrn->virtualY;
d1707 7
a1713 27
   switch (pI830->rotation) {
      case RR_Rotate_0:
         sarea->rotation = 0;
         break;
      case RR_Rotate_90:
         sarea->rotation = 90;
         break;
      case RR_Rotate_180:
         sarea->rotation = 180;
         break;
      case RR_Rotate_270:
         sarea->rotation = 270;
         break;
      default:
         sarea->rotation = 0;
   }
   if (pI830->rotation == RR_Rotate_0) {
      sarea->rotated_offset = -1;
      sarea->rotated_size = 0;
   }
   else {
      sarea->rotated_offset = pI830->FrontBuffer.Start;
      sarea->rotated_size = pI830->FrontBuffer.Size;
   }

   /* This is the original pitch */
   sarea->rotated_pitch = pI830->displayWidth;
d1715 13
a1727 1
   success = I830DRIMapScreenRegions(pScrn, sarea);
d1729 5
a1733 2
   if (success && (pI830->mmModeFlags & I830_KERNEL_TEX))
      I830InitTextureHeap(pScrn, sarea);
d1735 1
a1735 1
   return success;
d1742 1
d1745 6
d1753 1
a1753 1
	    if (pI830->planeEnabled[1]) {
d1758 1
a1758 1
	    } else
a1764 1
	    xf86DrvMsg(pScrn->scrnIndex, X_ERROR, "I830 Vblank Pipe Setup Failed\n");
d1780 1
a1780 1
      I830RefreshRing(pScrn);
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/* $XFree86: xc/programs/Xserver/hw/xfree86/drivers/i810/i830_dri.c,v 1.15 2003/06/18 13:14:17 dawes Exp $ */
d87 1
a87 1
static char I830ClientDriverName[] = "i915";
d89 1
d484 1
a484 1
   if (IS_I965G(pI830))
d648 12
d664 9
d687 1
a687 1
   /* The I965G isn't ready for the front buffer mapping to be moved around,
d690 1
a690 1
   if (!IS_I965G(pI830)) {
d732 13
a744 8
   if (drmAddMap(pI830->drmSubFD,
		 (drm_handle_t)sarea->tex_offset + pI830->LinearAddr,
		 sarea->tex_size, DRM_AGP, 0,
		 (drmAddress) &sarea->tex_handle) < 0) {
      xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
		 "[drm] drmAddMap(tex_handle) failed. Disabling DRI\n");
      DRICloseScreen(pScreen);
      return FALSE;
a745 3
   xf86DrvMsg(pScrn->scrnIndex, X_INFO, "[drm] textures = 0x%08x\n",
	      (int)sarea->tex_handle);

d1235 1
a1235 1
      if (!IS_I965G(pI830)) {
d1502 1
a1502 1
   if (success)
@


1.1.1.1
log
@Importing xf86-video-i810 1.7.2
@
text
@@


1.1.1.2
log
@xf86-video-intel 1.7.3
@
text
@d1 1
a1 1
/* $xfree86: xc/programs/Xserver/hw/xfree86/drivers/i810/i830_dri.c,v 1.15 2003/06/18 13:14:17 dawes Exp $ */
d87 1
a87 1
static char I830ClientDriverName[] = "i915tex";
a88 1
static char I830LegacyClientDriverName[] = "i915";
a646 12
	 if (!(pI830->mmModeFlags & I830_KERNEL_TEX)) {
	    if ((version->version_major > 1) ||
		((version->version_minor >= 7) && 
		 (version->version_major == 1))) {
	       pI830->mmModeFlags |= I830_KERNEL_MM;
	    } else {
	       pI830->mmModeFlags |= I830_KERNEL_TEX;
	    }		
	 } else {
	    xf86DrvMsg(pScreen->myNum, X_INFO, 
		       "Not enabling the DRM memory manager.\n");
	 } 
a650 9
   /*
    * Backwards compatibility
    */

   if ((pDRIInfo->clientDriverName == I830ClientDriverName) && 
       (pI830->mmModeFlags & I830_KERNEL_TEX)) {
      pDRIInfo->clientDriverName = I830LegacyClientDriverName;
   }

d710 11
a720 10
   if (pI830->mmModeFlags & I830_KERNEL_TEX) {
      if (drmAddMap(pI830->drmSubFD,
		    (drm_handle_t)sarea->tex_offset + pI830->LinearAddr,
		    sarea->tex_size, DRM_AGP, 0,
		    (drmAddress) &sarea->tex_handle) < 0) {
	 xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
		    "[drm] drmAddMap(tex_handle) failed. Disabling DRI\n");
	 DRICloseScreen(pScreen);
	 return FALSE;
      }
a721 3
      xf86DrvMsg(pScrn->scrnIndex, X_INFO, "[drm] textures = 0x%08x\n",
		 (int)sarea->tex_handle);
   }
d1478 1
a1478 1
   if (success && (pI830->mmModeFlags & I830_KERNEL_TEX))
@


1.1.1.3
log
@xf86-video-intel 2.2.0
@
text
@d84 1
a84 16
#include "i915_drm.h"

/* This block and the corresponding configure test can be removed when
 * libdrm >= 2.3.1 is required.
 */
#ifndef HAVE_I915_FLIP

#define DRM_VBLANK_FLIP 0x8000000

typedef struct drm_i915_flip {
   int pipes;
} drm_i915_flip_t;

#undef DRM_IOCTL_I915_FLIP
#define DRM_IOCTL_I915_FLIP DRM_IOW(DRM_COMMAND_BASE + DRM_I915_FLIP, \
				    drm_i915_flip_t)
d86 4
a89 3
#endif

#include "dristruct.h"
a107 5
#if defined(DAMAGE) && (DRIINFO_MAJOR_VERSION > 5 ||		\
			(DRIINFO_MAJOR_VERSION == 5 && DRIINFO_MINOR_VERSION >= 1))
#define DRI_SUPPORTS_CLIP_NOTIFY 1
#else
#define DRI_SUPPORTS_CLIP_NOTIFY 0
a109 1
#endif
d111 2
a112 9
#if (DRIINFO_MAJOR_VERSION > 5 || \
     (DRIINFO_MAJOR_VERSION == 5 && DRIINFO_MINOR_VERSION >= 4))
#define DRI_DRIVER_FRAMEBUFFER_MAP 1
#else
#define DRI_DRIVER_FRAMEBUFFER_MAP 0
#endif

#ifdef DRI_SUPPORTS_CLIP_NOTIFY
static void I830DRIClipNotify(ScreenPtr pScreen, WindowPtr *ppWin, int num);
d148 3
a150 3
   info.ring_start = ring->mem->offset + pI830->LinearAddr;
   info.ring_end = ring->mem->end + pI830->LinearAddr;
   info.ring_size = ring->mem->size;
d156 3
a158 3
   info.front_offset = pI830->front_buffer->offset;
   info.back_offset = pI830->back_buffer->offset;
   info.depth_offset = pI830->depth_buffer->offset;
d161 3
a163 3
   info.pitch = pScrn->displayWidth;
   info.back_pitch = pScrn->displayWidth;
   info.depth_pitch = pScrn->displayWidth;
a211 16
static Bool
I830SetHWS(ScrnInfoPtr pScrn, int addr)
{
    I830Ptr pI830 = I830PTR(pScrn);
    drmI830HWS hws;

    hws.addr = addr;

    if (drmCommandWrite(pI830->drmSubFD, DRM_I830_HWS_PAGE_ADDR,
		&hws, sizeof(drmI830HWS))) {
	xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
		"G33 status page initialization Failed\n");
	return FALSE;
    }
    return TRUE;
}
d219 3
a221 3
   __GLXvisualConfig *pConfigs = NULL;
   I830ConfigPrivPtr pI830Configs = NULL;
   I830ConfigPrivPtr *pI830ConfigPtrs = NULL;
d429 1
a429 3
   if (!xf86LoaderCheckSymbol("GlxSetVisualConfigs")) {
      xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
		 "[dri] %s failed: glx not loaded\n", __FUNCTION__);
d431 1
a431 4
   }
   if (!xf86LoaderCheckSymbol("DRIScreenInit")) {
      xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
		 "[dri] %s failed: dri not loaded\n", __FUNCTION__);
d433 1
a433 4
   }
   if (!xf86LoaderCheckSymbol("drmAvailable")) {
      xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
		 "[dri] %s failed: libdrm not loaded\n", __FUNCTION__);
a434 1
   }
d437 1
a437 1
		 "[dri] %s failed (libdri.a too old)\n", __FUNCTION__);
d446 1
a446 2
      if (major != DRIINFO_MAJOR_VERSION || minor < DRIINFO_MINOR_VERSION ||
	  major < 5) {
d483 1
a483 1
   pDRIInfo->drmDriverName = "i915";
d485 3
a487 3
      pDRIInfo->clientDriverName = "i965";
   else
      pDRIInfo->clientDriverName = "i915";
a493 4
#if XSERVER_LIBPCIACCESS
	      ((pI830->PciInfo->domain << 8) | pI830->PciInfo->bus),
	      pI830->PciInfo->dev, pI830->PciInfo->func
#else
d496 1
a496 3
	      ((pciConfigPtr) pI830->PciInfo->thisCard)->funcnum
#endif
	      );
d501 10
d532 1
a532 1
      pI830->pDRIInfo = NULL;
a544 27

#if DRIINFO_MAJOR_VERSION > 5 || \
    (DRIINFO_MAJOR_VERSION == 5 && DRIINFO_MINOR_VERSION >= 3)
      if (pI830->useEXA)
	 pDRIInfo->texOffsetStart = I830TexOffsetStart;
#endif

#if DRI_SUPPORTS_CLIP_NOTIFY
      pDRIInfo->ClipNotify = I830DRIClipNotify;
#endif

#if DRI_DRIVER_FRAMEBUFFER_MAP
   /* DRI version is high enough that we can get the DRI code to not
    * try to manage the framebuffer.
    */
   pDRIInfo->frameBufferPhysicalAddress = 0;
   pDRIInfo->frameBufferSize = 0;
   pDRIInfo->frameBufferStride = 0;
   pDRIInfo->dontMapFrameBuffer = TRUE;
#else
   /* Supply a dummy mapping info required by DRI setup.
    */
   pDRIInfo->frameBufferPhysicalAddress = (char *) pI830->LinearAddr;
   pDRIInfo->frameBufferSize = GTT_PAGE_SIZE;
   pDRIInfo->frameBufferStride = 1;
#endif

a546 2

#if !DRI_SUPPORTS_CLIP_NOTIFY
a548 1
#endif
d555 1
a555 1
      pDRIInfo->devPrivate = NULL;
d557 1
a557 1
      pI830->pDRIInfo = NULL;
d561 14
a574 17
   /* Now, nuke dri.c's dummy frontbuffer map setup if we did that. */
   if (pDRIInfo->frameBufferSize != 0) {
       int tmp;
       drm_handle_t fb_handle;
       void *ptmp;

       /* With the compat method, it will continue to report
	* the wrong map out of GetDeviceInfo, which will break AIGLX.
	*/
       DRIGetDeviceInfo(pScreen, &fb_handle, &tmp, &tmp, &tmp, &tmp, &ptmp);
       drmRmMap(pI830->drmSubFD, fb_handle);

       xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
		  "Removed DRI frontbuffer mapping in compatibility mode.\n");
       xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
		  "DRIGetDeviceInfo will report incorrect frontbuffer "
		  "handle.\n");
d576 5
d640 3
a642 9
	 /* Check whether the kernel module attached to the device isn't the
	  * one we expected (meaning it's the old i830 module).
	  */
	 if (strncmp(version->name, pDRIInfo->drmDriverName,
		     strlen(pDRIInfo->drmDriverName)))
	 {
	    xf86DrvMsg(pScreen->myNum, X_WARNING,
		       "Detected i830 kernel module.  The i915 kernel module "
		       "is required for DRI.  Aborting.\n");
d648 12
a659 8
#ifdef DAMAGE
	 if (pI830->allowPageFlip && pI830->drmMinor < 9) {
	    xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
		       "DRM version 1.9 or newer required for Page flipping. "
		       "Disabling.\n");
	    pI830->allowPageFlip = FALSE;
	 }
#endif	 
d664 82
d749 24
d774 1
a774 1
I830InitTextureHeap(ScrnInfoPtr pScrn)
a777 3
   if (pI830->textures == NULL)
       return;

d782 2
a783 2
   drmHeap.size   = pI830->textures->size;

d790 2
a791 2
		    "[drm] Initialized kernel agp heap manager, %ld\n",
		    pI830->textures->size);
d794 1
a794 1
		   pI830->TexGranularity);
a797 4
/**
 * Sets up mappings for static, lifetime-fixed allocations, and inital SAREA
 * setup.
 */
d820 2
a821 2
		 (drm_handle_t)pI830->LpRing->mem->offset + pI830->LinearAddr,
		 pI830->LpRing->mem->size, DRM_AGP, 0,
a835 6
   if (IS_G33CLASS(pI830)) {
       if (!I830SetHWS(pScrn, pI830->hw_status->offset)) {
	   DRICloseScreen(pScreen);
	   return FALSE;
       }
   }
a838 1
   sarea->third_handle = 0;
d849 6
a854 13
   /* If we are using the kernel memory manager, we have to delay SAREA and
    * mapping setup until our buffers are pinned at EnterVT, losing the
    * opportunity to fail cleanly early on.
    */
   if (pI830->memory_manager == NULL) {
      if (!i830_update_dri_buffers(pScrn)) {
	 /* screen mappings probably failed */
	 xf86DrvMsg(pScreen->myNum, X_ERROR,
		    "[drm] drmAddMap(screen mappings) failed. "
		    "Disabling DRI\n");
	 DRICloseScreen(pScreen);
	 return FALSE;
      }
d857 2
a858 5
   if (pI830->allocate_classic_textures)
      I830InitTextureHeap(pScrn);

   if (DEVICE_ID(pI830->PciInfo) != PCI_CHIP_845_G &&
       DEVICE_ID(pI830->PciInfo) != PCI_CHIP_I830_M) {
d863 1
a863 1
   pI830DRI->deviceID = DEVICE_ID(pI830->PciInfo);
a898 6
#if XSERVER_LIBPCIACCESS
					       ((pI830->PciInfo->domain << 8) |
						pI830->PciInfo->bus),
					       pI830->PciInfo->dev,
					       pI830->PciInfo->func
#else
d904 1
a904 3
						PciInfo->thisCard)->funcnum
#endif
					       );
a929 4
#ifdef DAMAGE
   REGION_UNINIT(pScreen, &pI830->driRegion);
#endif

d942 1
a942 1
	 pI830->pDRIInfo->devPrivate = NULL;
d945 1
a945 1
      pI830->pDRIInfo = NULL;
d975 11
a993 6
#if XSERVER_LIBPCIACCESS
					       ((pI830->PciInfo->domain << 8) |
						pI830->PciInfo->bus),
					       pI830->PciInfo->dev,
					       pI830->PciInfo->func
#else
d999 1
a999 3
						PciInfo->thisCard)->funcnum
#endif
					       );
d1016 1
a1016 56
#ifdef DAMAGE
/* This should be done *before* XAA syncs,
 * Otherwise will have to sync again???
 */
static void
I830DRIDoRefreshArea (ScrnInfoPtr pScrn, int num, BoxPtr pbox, CARD32 dst)
{
   I830Ptr pI830 = I830PTR(pScrn);
   int i, cmd, br13 = (pScrn->displayWidth * pI830->cpp) | (0xcc << 16);

   if (pScrn->bitsPerPixel == 32) {
      cmd = (XY_SRC_COPY_BLT_CMD | XY_SRC_COPY_BLT_WRITE_ALPHA |
	     XY_SRC_COPY_BLT_WRITE_RGB);
      br13 |= 3 << 24;
   } else {
      cmd = (XY_SRC_COPY_BLT_CMD);
      br13 |= 1 << 24;
   }

   for (i = 0 ; i < num ; i++, pbox++) {
      BEGIN_LP_RING(8);
      OUT_RING(cmd);
      OUT_RING(br13);
      OUT_RING((pbox->y1 << 16) | pbox->x1);
      OUT_RING((pbox->y2 << 16) | pbox->x2);
      OUT_RING(dst);
      OUT_RING((pbox->y1 << 16) | pbox->x1);
      OUT_RING(br13 & 0xffff);
      OUT_RING(pI830->front_buffer->offset);
      ADVANCE_LP_RING();
   }
}

static void
I830DRIRefreshArea (ScrnInfoPtr pScrn, int num, BoxPtr pbox)
{
   I830Ptr pI830 = I830PTR(pScrn);
   drmI830Sarea *pSAREAPriv = DRIGetSAREAPrivate(pScrn->pScreen);

   /* Don't want to do this when no 3d is active and pages are
    * right-way-round :
    */
   if (!pSAREAPriv->pf_active && pSAREAPriv->pf_current_page == 0)
      return;

   I830DRIDoRefreshArea(pScrn, num, pbox, pI830->back_buffer->offset);

   if (pI830->third_buffer) {
      I830DRIDoRefreshArea(pScrn, num, pbox, pI830->third_buffer->offset);
   }

   DamageEmpty(pI830->pDamage);
}
#endif

static void
d1026 1
a1030 2
      *pI830->last_3d = LAST_3D_OTHER;

d1034 1
a1034 25
      i830_refresh_ring(pScrn);

      I830EmitFlush(pScrn);

#ifdef DAMAGE
      if (!pI830->pDamage && pI830->allowPageFlip) {
	 PixmapPtr pPix  = pScreen->GetScreenPixmap(pScreen);
	 pI830->pDamage = DamageCreate(NULL, NULL, DamageReportNone, TRUE,
				       pScreen, pPix);

	 if (pI830->pDamage == NULL) {
	    xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
                       "No screen damage record, page flipping disabled\n");
            pI830->allowPageFlip = FALSE;
	 } else {
	    DamageRegister(&pPix->drawable, pI830->pDamage);

	    DamageDamageRegion(&pPix->drawable,
			       &WindowTable[pScreen->myNum]->winSize);

            xf86DrvMsg(pScrn->scrnIndex, X_INFO,
                       "Damage tracking initialized for page flipping\n");
	 }
    }
#endif
d1038 1
a1038 4
#ifdef DAMAGE
      drmI830Sarea *sPriv = (drmI830Sarea *) DRIGetSAREAPrivate(pScreen);
#endif

a1040 53

      if (!pScrn->vtSema)
     	 return;

#ifdef DAMAGE
      if (pI830->pDamage) {
	 RegionPtr pDamageReg = DamageRegion(pI830->pDamage);

	 if (pDamageReg) {
	    RegionRec region;
	    int nrects;

	    REGION_NULL(pScreen, &region);
	    REGION_SUBTRACT(pScreen, &region, pDamageReg, &pI830->driRegion);

	    if ((nrects = REGION_NUM_RECTS(&region)))
	       I830DRIRefreshArea(pScrn, nrects, REGION_RECTS(&region));

	    REGION_UNINIT(pScreen, &region);
	 }
      }
#endif

      I830EmitFlush(pScrn);

#ifdef DAMAGE
      /* Try flipping back to the front page if necessary */
      if (sPriv && !sPriv->pf_enabled && sPriv->pf_current_page != 0) {
	 drm_i915_flip_t flip = { .pipes = 0 };

	 if (sPriv->pf_current_page & (0x3 << 2)) {
	    sPriv->pf_current_page = sPriv->pf_current_page & 0x3;
	    sPriv->pf_current_page |= (sPriv->third_handle ? 2 : 1) << 2;

	    flip.pipes |= 0x2;
	 }

	 if (sPriv->pf_current_page & 0x3) {
	    sPriv->pf_current_page = sPriv->pf_current_page & (0x3 << 2);
	    sPriv->pf_current_page |= sPriv->third_handle ? 2 : 1;

	    flip.pipes |= 0x1;
	 }

	 drmCommandWrite(pI830->drmSubFD, DRM_I915_FLIP, &flip, sizeof(flip));

	 if (sPriv->pf_current_page != 0)
	    xf86DrvMsg(pScreen->myNum, X_WARNING,
		       "[dri] %s: kernel failed to unflip buffers.\n", __func__);
      }
#endif

      pI830->LockHeld = 0;
d1050 1
a1061 7

      if (I830PTR(pScrn)->third_buffer) {
	 I830SelectBuffer(pScrn, I830_SELECT_THIRD);
	 I830SubsequentSolidFillRect(pScrn, pbox->x1, pbox->y1,
				     pbox->x2 - pbox->x1, pbox->y2 - pbox->y1);
      }

d1088 1
a1088 1
   i830MarkSync(pScrn);
d1118 3
a1120 3
   BoxPtr pboxNew1 = NULL;
   BoxPtr pboxNew2 = NULL;
   DDXPointPtr pptNew1 = NULL;
a1234 4
      if (pI830->third_buffer) {
	 I830SelectBuffer(pScrn, I830_SELECT_THIRD);
	 I830SubsequentScreenToScreenCopy(pScrn, x1, y1, destx, desty, w, h);
      }
d1251 2
a1252 1
   i830MarkSync(pScrn);
d1262 4
d1278 5
d1284 1
a1284 1
I830DRISetPfMask(ScreenPtr pScreen, int pfMask)
d1288 3
d1292 7
d1300 60
a1359 5
   if (pI830->allowPageFlip && pfMask) {
      pSAREAPriv->pf_enabled = pI830->allowPageFlip;
      pSAREAPriv->pf_active = pfMask;
   } else
      pSAREAPriv->pf_active = 0;
d1362 9
a1370 1
#if !DRI_SUPPORTS_CLIP_NOTIFY
d1378 1
a1378 1
   I830DRISetPfMask(pScreen, 0);
a1383 3
   ScrnInfoPtr pScrn = xf86Screens[pScreen->myNum];
   I830Ptr pI830 = I830PTR(pScrn);

d1386 1
a1386 1
   I830DRISetPfMask(pScreen, pI830->allowPageFlip ? 0x3 : 0);
a1387 1
#endif /* !DRI_SUPPORTS_CLIP_NOTIFY */
d1395 3
a1397 1
   I830DRISetPfMask(pScreen, pI830->allowPageFlip ? 0x3 : 0);
a1398 3
   pI830->want_vblank_interrupts = TRUE;
   I830DRISetVBlankInterrupt(pScrn, TRUE);
}
d1407 9
a1415 1
   I830DRISetPfMask(pScreen, 0);
d1417 1
a1417 1
   sPriv->pf_enabled = 0;
a1418 2
   pI830->want_vblank_interrupts = FALSE;
   I830DRISetVBlankInterrupt(pScrn, FALSE);
a1420 50
#if DRI_SUPPORTS_CLIP_NOTIFY
static void
I830DRIClipNotify(ScreenPtr pScreen, WindowPtr *ppWin, int num)
{
   ScrnInfoPtr pScrn = xf86Screens[pScreen->myNum];
   I830Ptr pI830 = I830PTR(pScrn);
   unsigned pfMask = 0;

   REGION_UNINIT(pScreen, &pI830->driRegion);
   REGION_NULL(pScreen, &pI830->driRegion);

   if (num > 0) {
      drmI830Sarea *sPriv = (drmI830Sarea *) DRIGetSAREAPrivate(pScreen);
      BoxRec crtcBox[2];
      unsigned numvisible[2] = { 0, 0 };
      int i, j;

      crtcBox[0].x1 = sPriv->planeA_x;
      crtcBox[0].y1 = sPriv->planeA_y;
      crtcBox[0].x2 = crtcBox[0].x1 + sPriv->planeA_w;
      crtcBox[0].y2 = crtcBox[0].y1 + sPriv->planeA_h;
      crtcBox[1].x1 = sPriv->planeB_x;
      crtcBox[1].y1 = sPriv->planeB_y;
      crtcBox[1].x2 = crtcBox[1].x1 + sPriv->planeB_w;
      crtcBox[1].y2 = crtcBox[1].y1 + sPriv->planeB_h;

      for (i = 0; i < 2; i++) {
	 for (j = 0; j < num; j++) {
	    WindowPtr pWin = ppWin[j];

	    if (pWin) {
	       if (RECT_IN_REGION(pScreen, &pWin->clipList, &crtcBox[i]) !=
		   rgnOUT)
		  numvisible[i]++;

	       if (i == 0)
		  REGION_UNION(pScreen, &pI830->driRegion, &pWin->clipList,
			       &pI830->driRegion);
	    }
	 }

	 if (numvisible[i] == 1)
	    pfMask |= 1 << i;
      }
   } else
      REGION_NULL(pScreen, &pI830->driRegion);

   I830DRISetPfMask(pScreen, pfMask);
}
#endif /* DRI_SUPPORTS_CLIP_NOTIFY */
d1423 2
a1424 6
 * Update the SAREA fields with current buffer information.
 *
 * Most of the SAREA fields are already updated by i830_do_addmap().
 *
 * This does include other SAREA initialization which will actually be constant
 * over the lifetime of the server.
d1426 2
a1427 2
static void
i830_update_sarea(ScrnInfoPtr pScrn, drmI830Sarea *sarea)
d1429 1
d1431 1
a1431 7
   I830Ptr pI830 = I830PTR(pScrn);

   sarea->width = pScreen->width;
   sarea->height = pScreen->height;
   sarea->pitch = pScrn->displayWidth;
   sarea->virtualX = pScrn->virtualX;
   sarea->virtualY = pScrn->virtualY;
d1433 1
a1433 8
   sarea->front_tiled = (pI830->front_buffer->tiling != TILE_NONE);
   sarea->back_tiled = (pI830->back_buffer->tiling != TILE_NONE);
   if (pI830->third_buffer != NULL)
       sarea->third_tiled = (pI830->third_buffer->tiling != TILE_NONE);
   else
       sarea->third_tiled = FALSE;
   sarea->depth_tiled = (pI830->depth_buffer->tiling != TILE_NONE);
   sarea->rotated_tiled = FALSE;
d1435 6
a1440 15
   sarea->log_tex_granularity = pI830->TexGranularity;

   sarea->front_bo_handle = -1;
   sarea->back_bo_handle = -1;
   sarea->third_bo_handle = -1;
   sarea->depth_bo_handle = -1;
#ifdef XF86DRI_MM
   if (pI830->front_buffer->bo.size)
       sarea->front_bo_handle = pI830->front_buffer->bo.handle;
   if (pI830->back_buffer->bo.size)
       sarea->back_bo_handle = pI830->back_buffer->bo.handle;
   if (pI830->third_buffer != NULL && pI830->third_buffer->bo.size)
       sarea->third_bo_handle = pI830->third_buffer->bo.handle;
   if (pI830->depth_buffer->bo.size)
       sarea->depth_bo_handle = pI830->depth_buffer->bo.handle;
d1443 6
a1448 93
   /* The rotation is now handled entirely by the X Server, so just leave the
    * DRI unaware.
    */
   sarea->rotation = 0;
   sarea->rotated_offset = -1;
   sarea->rotated_size = 0;
   sarea->rotated_pitch = pScrn->displayWidth;
}

/**
 * Updates the DRI mapping for the given i830_memory struct, with the given
 * flags.
 */
static int
i830_do_addmap(ScrnInfoPtr pScrn, i830_memory *mem,
	       drm_handle_t *sarea_handle, int *sarea_size, int *sarea_offset)
{
    I830Ptr pI830 = I830PTR(pScrn);
    int size = mem->size;

    if (mem == pI830->front_buffer) {
	/* Workaround for XAA pixmap cache: Don't use front_buffer->size
	 * and instead, calculate the visible frontbuffer size and round to
	 * avoid irritating the assertions of older DRI drivers.
	 */
	size = ROUND_TO_PAGE(pScrn->displayWidth * pScrn->virtualY *
			     pI830->cpp);
    }

    if (*sarea_handle != 0 &&
	(*sarea_size != size || *sarea_offset != mem->offset))
    {
	drmRmMap(pI830->drmSubFD, *sarea_handle);
	*sarea_handle = 0;
	*sarea_size = 0;
	*sarea_offset = 0;
    }

    if (*sarea_handle == 0) {
	int ret;

	ret = drmAddMap(pI830->drmSubFD,
			(drm_handle_t)(mem->offset + pI830->LinearAddr),
			size, DRM_AGP, 0,
			(drmAddress) sarea_handle);
	if (ret == 0) {
	    xf86DrvMsg(pScrn->scrnIndex, X_INFO,
		       "[drm] mapped %s at 0x%08lx, handle = 0x%08x\n",
		       mem->name, mem->offset + pI830->LinearAddr,
		       (int)*sarea_handle);
	    *sarea_size = size;
	    *sarea_offset = mem->offset;
	} else {
	    xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
		       "[drm] failed to map %s at 0x%08lx\n",
		       mem->name, mem->offset + pI830->LinearAddr);
	    return FALSE;
	}
    }

    return TRUE;
}

/**
 * Updates the DRM mappings with the current buffer information.
 *
 * Some old DRI drivers may be unprepared for buffers actually moving at
 * runtime, which would likely result in bus errors on software fallbacks or
 * hangs or misrendering on hardware rendering.
 */
static Bool
i830_update_dri_mappings(ScrnInfoPtr pScrn, drmI830Sarea *sarea)
{
   I830Ptr pI830 = I830PTR(pScrn);

   if (!i830_do_addmap(pScrn, pI830->front_buffer, &sarea->front_handle,
		       &sarea->front_size, &sarea->front_offset)) {
       xf86DrvMsg(pScrn->scrnIndex, X_INFO, "Disabling DRI.\n");
       return FALSE;
   }

   if (!i830_do_addmap(pScrn, pI830->back_buffer, &sarea->back_handle,
		       &sarea->back_size, &sarea->back_offset)) {
       xf86DrvMsg(pScrn->scrnIndex, X_INFO, "Disabling DRI.\n");
       return FALSE;
   }

   if (pI830->third_buffer) {
       if (!i830_do_addmap(pScrn, pI830->third_buffer, &sarea->third_handle,
			   &sarea->third_size, &sarea->third_offset)) {
	   xf86DrvMsg(pScrn->scrnIndex, X_INFO, "Disabling DRI.\n");
	   return FALSE;
       }
d1450 3
a1452 17
       sarea->third_handle = 0;
       sarea->third_offset = 0;
       sarea->third_size = 0;
   }

   if (!i830_do_addmap(pScrn, pI830->depth_buffer, &sarea->depth_handle,
		       &sarea->depth_size, &sarea->depth_offset)) {
       xf86DrvMsg(pScrn->scrnIndex, X_INFO, "Disabling DRI.\n");
       return FALSE;
   }

   if (pI830->allocate_classic_textures) {
       if (!i830_do_addmap(pScrn, pI830->textures, &sarea->tex_handle,
			   &sarea->tex_size, &sarea->tex_offset)) {
	   xf86DrvMsg(pScrn->scrnIndex, X_INFO, "Disabling DRI.\n");
	   return FALSE;
       }
d1455 3
a1457 2
   return TRUE;
}
d1459 12
a1470 4
static void
i830_update_screen_private(ScrnInfoPtr pScrn, drmI830Sarea *sarea)
{
   I830Ptr pI830 = I830PTR(pScrn);
d1472 27
a1498 7
   pI830->pDRIInfo->frameBufferPhysicalAddress = (char *) pI830->LinearAddr;
   pI830->pDRIInfo->frameBufferStride = pScrn->displayWidth * pI830->cpp;
   pI830->pDRIInfo->frameBufferSize = sarea->front_size;
#if DRI_DRIVER_FRAMEBUFFER_MAP
   pI830->pDRIInfo->hFrameBuffer = sarea->front_handle;
#endif
}
d1500 1
a1500 13
/**
 * Update the SAREA fields, DRI mappings, and screen info passed through the
 * protocol.
 *
 * This gets called both at startup and after any of the buffers might have
 * been relocated.
 */
Bool
i830_update_dri_buffers(ScrnInfoPtr pScrn)
{
   ScreenPtr pScreen = pScrn->pScreen;
   drmI830Sarea *sarea = (drmI830Sarea *) DRIGetSAREAPrivate(pScreen);
   Bool success;
d1502 2
a1503 5
   success = i830_update_dri_mappings(pScrn, sarea);
   if (!success)
       return FALSE;
   i830_update_sarea(pScrn, sarea);
   i830_update_screen_private(pScrn, sarea);
d1505 1
a1505 1
   return TRUE;
a1511 1
    xf86CrtcConfigPtr   xf86_config = XF86_CRTC_CONFIG_PTR(pScrn);
a1513 6
    /* If we have no 3d running, then don't bother enabling the vblank
     * interrupt.
     */
    if (!pI830->want_vblank_interrupts)
	on = FALSE;

d1516 1
a1516 1
	    if (xf86_config->num_crtc > 1 && xf86_config->crtc[1]->enabled)
d1521 1
a1521 1
	    else
d1528 1
d1544 1
a1544 1
      i830_refresh_ring(pScrn);
@


1.1.1.4
log
@Import intel driver v 2.2.0.90. tested by many, including krw@@ kettenis@@,
jakemsr@@, landry@@, beck@@ and oga@@. Thanks.
@
text
@d1252 1
a1252 1
   DDXPointPtr pptTmp, pptNew2 = NULL;
d1280 1
a1280 1
	 pboxNew1 = (BoxPtr) xalloc(sizeof(BoxRec) * nbox);
d1283 1
a1283 1
	 pptNew1 = (DDXPointPtr) xalloc(sizeof(DDXPointRec) * nbox);
d1285 1
a1285 1
	    xfree(pboxNew1);
d1316 2
a1317 2
	 pboxNew2 = (BoxPtr) xalloc(sizeof(BoxRec) * nbox);
	 pptNew2 = (DDXPointPtr) xalloc(sizeof(DDXPointRec) * nbox);
d1320 1
a1320 1
	       xfree(pptNew2);
d1322 1
a1322 1
	       xfree(pboxNew2);
d1324 2
a1325 2
	       xfree(pptNew1);
	       xfree(pboxNew1);
d1396 2
a1397 2
      xfree(pptNew2);
      xfree(pboxNew2);
d1400 2
a1401 2
      xfree(pptNew1);
      xfree(pboxNew1);
@


