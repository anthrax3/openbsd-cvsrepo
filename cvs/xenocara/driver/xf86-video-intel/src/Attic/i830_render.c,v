head	1.8;
access;
symbols
	OPENBSD_5_4:1.7.0.2
	OPENBSD_5_4_BASE:1.7
	OPENBSD_5_3:1.6.0.6
	OPENBSD_5_3_BASE:1.6
	OPENBSD_5_2:1.6.0.4
	OPENBSD_5_2_BASE:1.6
	OPENBSD_5_1_BASE:1.6
	OPENBSD_5_1:1.6.0.2
	OPENBSD_5_0:1.5.0.6
	OPENBSD_5_0_BASE:1.5
	OPENBSD_4_9:1.5.0.2
	OPENBSD_4_9_BASE:1.5
	OPENBSD_4_8:1.5.0.4
	OPENBSD_4_8_BASE:1.5
	OPENBSD_4_7:1.3.0.4
	OPENBSD_4_7_BASE:1.3
	OPENBSD_4_6:1.3.0.2
	OPENBSD_4_6_BASE:1.3
	OPENBSD_4_5:1.2.0.4
	OPENBSD_4_5_BASE:1.2
	OPENBSD_4_4:1.2.0.2
	OPENBSD_4_4_BASE:1.2
	OPENBSD_4_3_BASE:1.1.1.1
	OPENBSD_4_3:1.1.1.1.0.2
	v2_2_0_90:1.1.1.1
	v2_2_0:1.1.1.1
	xorg:1.1.1;
locks; strict;
comment	@ * @;


1.8
date	2014.02.03.15.54.51;	author matthieu;	state dead;
branches;
next	1.7;

1.7
date	2013.03.18.18.38.20;	author matthieu;	state Exp;
branches;
next	1.6;

1.6
date	2011.11.29.12.39.03;	author oga;	state Exp;
branches;
next	1.5;

1.5
date	2010.07.18.14.47.47;	author oga;	state Exp;
branches;
next	1.4;

1.4
date	2010.05.10.22.32.29;	author oga;	state Exp;
branches;
next	1.3;

1.3
date	2009.06.25.20.16.43;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2008.05.21.20.19.52;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2007.11.24.19.44.58;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2007.11.24.19.44.58;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.8
log
@Update to xf86-video-intel 2.99.909
Tested by jsg@@, kettenis@@ and myself on a wide range of intel cards.
@
text
@/*
 * Copyright Â© 2006 Intel Corporation
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice (including the next
 * paragraph) shall be included in all copies or substantial portions of the
 * Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 * Authors:
 *    Wang Zhenyu <zhenyu.z.wang@@intel.com>
 *    Eric Anholt <eric@@anholt.net>
 *
 */

#ifdef HAVE_CONFIG_H
#include "config.h"
#endif

#include "xf86.h"
#include "intel.h"
#include "i830_reg.h"

struct blendinfo {
	Bool dst_alpha;
	Bool src_alpha;
	uint32_t src_blend;
	uint32_t dst_blend;
};

struct formatinfo {
	int fmt;
	uint32_t card_fmt;
};

#define TB0C_LAST_STAGE	(1 << 31)
#define TB0C_RESULT_SCALE_1X		(0 << 29)
#define TB0C_RESULT_SCALE_2X		(1 << 29)
#define TB0C_RESULT_SCALE_4X		(2 << 29)
#define TB0C_OP_MODULE			(3 << 25)
#define TB0C_OUTPUT_WRITE_CURRENT	(0 << 24)
#define TB0C_OUTPUT_WRITE_ACCUM		(1 << 24)
#define TB0C_ARG3_REPLICATE_ALPHA 	(1<<23)
#define TB0C_ARG3_INVERT		(1<<22)
#define TB0C_ARG3_SEL_XXX
#define TB0C_ARG2_REPLICATE_ALPHA 	(1<<17)
#define TB0C_ARG2_INVERT		(1<<16)
#define TB0C_ARG2_SEL_ONE		(0 << 12)
#define TB0C_ARG2_SEL_FACTOR		(1 << 12)
#define TB0C_ARG2_SEL_TEXEL0		(6 << 12)
#define TB0C_ARG2_SEL_TEXEL1		(7 << 12)
#define TB0C_ARG2_SEL_TEXEL2		(8 << 12)
#define TB0C_ARG2_SEL_TEXEL3		(9 << 12)
#define TB0C_ARG1_REPLICATE_ALPHA 	(1<<11)
#define TB0C_ARG1_INVERT		(1<<10)
#define TB0C_ARG1_SEL_ONE		(0 << 6)
#define TB0C_ARG1_SEL_TEXEL0		(6 << 6)
#define TB0C_ARG1_SEL_TEXEL1		(7 << 6)
#define TB0C_ARG1_SEL_TEXEL2		(8 << 6)
#define TB0C_ARG1_SEL_TEXEL3		(9 << 6)
#define TB0C_ARG0_REPLICATE_ALPHA 	(1<<5)
#define TB0C_ARG0_SEL_XXX

#define TB0A_CTR_STAGE_ENABLE 		(1<<31)
#define TB0A_RESULT_SCALE_1X		(0 << 29)
#define TB0A_RESULT_SCALE_2X		(1 << 29)
#define TB0A_RESULT_SCALE_4X		(2 << 29)
#define TB0A_OP_MODULE			(3 << 25)
#define TB0A_OUTPUT_WRITE_CURRENT	(0<<24)
#define TB0A_OUTPUT_WRITE_ACCUM		(1<<24)
#define TB0A_CTR_STAGE_SEL_BITS_XXX
#define TB0A_ARG3_SEL_XXX
#define TB0A_ARG3_INVERT		(1<<17)
#define TB0A_ARG2_INVERT		(1<<16)
#define TB0A_ARG2_SEL_ONE		(0 << 12)
#define TB0A_ARG2_SEL_TEXEL0		(6 << 12)
#define TB0A_ARG2_SEL_TEXEL1		(7 << 12)
#define TB0A_ARG2_SEL_TEXEL2		(8 << 12)
#define TB0A_ARG2_SEL_TEXEL3		(9 << 12)
#define TB0A_ARG1_INVERT		(1<<10)
#define TB0A_ARG1_SEL_ONE		(0 << 6)
#define TB0A_ARG1_SEL_TEXEL0		(6 << 6)
#define TB0A_ARG1_SEL_TEXEL1		(7 << 6)
#define TB0A_ARG1_SEL_TEXEL2		(8 << 6)
#define TB0A_ARG1_SEL_TEXEL3		(9 << 6)

static struct blendinfo i830_blend_op[] = {
	/* Clear */
	{0, 0, BLENDFACTOR_ZERO, BLENDFACTOR_ZERO},
	/* Src */
	{0, 0, BLENDFACTOR_ONE, BLENDFACTOR_ZERO},
	/* Dst */
	{0, 0, BLENDFACTOR_ZERO, BLENDFACTOR_ONE},
	/* Over */
	{0, 1, BLENDFACTOR_ONE, BLENDFACTOR_INV_SRC_ALPHA},
	/* OverReverse */
	{1, 0, BLENDFACTOR_INV_DST_ALPHA, BLENDFACTOR_ONE},
	/* In */
	{1, 0, BLENDFACTOR_DST_ALPHA, BLENDFACTOR_ZERO},
	/* InReverse */
	{0, 1, BLENDFACTOR_ZERO, BLENDFACTOR_SRC_ALPHA},
	/* Out */
	{1, 0, BLENDFACTOR_INV_DST_ALPHA, BLENDFACTOR_ZERO},
	/* OutReverse */
	{0, 1, BLENDFACTOR_ZERO, BLENDFACTOR_INV_SRC_ALPHA},
	/* Atop */
	{1, 1, BLENDFACTOR_DST_ALPHA, BLENDFACTOR_INV_SRC_ALPHA},
	/* AtopReverse */
	{1, 1, BLENDFACTOR_INV_DST_ALPHA, BLENDFACTOR_SRC_ALPHA},
	/* Xor */
	{1, 1, BLENDFACTOR_INV_DST_ALPHA, BLENDFACTOR_INV_SRC_ALPHA},
	/* Add */
	{0, 0, BLENDFACTOR_ONE, BLENDFACTOR_ONE},
};

static struct formatinfo i830_tex_formats[] = {
	{PICT_a8, MAPSURF_8BIT | MT_8BIT_A8},
	{PICT_a8r8g8b8, MAPSURF_32BIT | MT_32BIT_ARGB8888},
	{PICT_a8b8g8r8, MAPSURF_32BIT | MT_32BIT_ABGR8888},
	{PICT_r5g6b5, MAPSURF_16BIT | MT_16BIT_RGB565},
	{PICT_a1r5g5b5, MAPSURF_16BIT | MT_16BIT_ARGB1555},
	{PICT_a4r4g4b4, MAPSURF_16BIT | MT_16BIT_ARGB4444},
};

static struct formatinfo i855_tex_formats[] = {
	{PICT_x8r8g8b8, MAPSURF_32BIT | MT_32BIT_XRGB8888},
	{PICT_x8b8g8r8, MAPSURF_32BIT | MT_32BIT_XBGR8888},
};

static Bool i830_get_dest_format(PicturePtr dest_picture, uint32_t * dst_format)
{
	ScrnInfoPtr scrn;

	switch (dest_picture->format) {
	case PICT_a8r8g8b8:
	case PICT_x8r8g8b8:
		*dst_format = COLR_BUF_ARGB8888;
		break;
	case PICT_r5g6b5:
		*dst_format = COLR_BUF_RGB565;
		break;
	case PICT_a1r5g5b5:
	case PICT_x1r5g5b5:
		*dst_format = COLR_BUF_ARGB1555;
		break;
	case PICT_a8:
		*dst_format = COLR_BUF_8BIT;
		break;
	case PICT_a4r4g4b4:
	case PICT_x4r4g4b4:
		*dst_format = COLR_BUF_ARGB4444;
		break;
	default:
		scrn = xf86ScreenToScrn(dest_picture->pDrawable->pScreen);
		intel_debug_fallback(scrn, "Unsupported dest format 0x%x\n",
				     (int)dest_picture->format);
		return FALSE;
	}
	*dst_format |= DSTORG_HORT_BIAS(0x8) | DSTORG_VERT_BIAS(0x8);
	return TRUE;
}

static Bool i830_get_blend_cntl(ScrnInfoPtr scrn, int op, PicturePtr mask,
				uint32_t dst_format, uint32_t * blendctl)
{
	uint32_t sblend, dblend;

	sblend = i830_blend_op[op].src_blend;
	dblend = i830_blend_op[op].dst_blend;

	/* If there's no dst alpha channel, adjust the blend op so that we'll treat
	 * it as always 1.
	 */
	if (PICT_FORMAT_A(dst_format) == 0 && i830_blend_op[op].dst_alpha) {
		if (sblend == BLENDFACTOR_DST_ALPHA)
			sblend = BLENDFACTOR_ONE;
		else if (sblend == BLENDFACTOR_INV_DST_ALPHA)
			sblend = BLENDFACTOR_ZERO;
	}

	/* For blending purposes, COLR_BUF_8BIT values show up in the green
	 * channel.  So we can't use the alpha channel.
	 */
	if (dst_format == PICT_a8 && ((sblend == BLENDFACTOR_DST_ALPHA ||
				       sblend == BLENDFACTOR_INV_DST_ALPHA))) {
		intel_debug_fallback(scrn, "Can't do dst alpha blending with "
				     "PICT_a8 dest.\n");
		return FALSE;
	}

	/* If the source alpha is being used, then we should only be in a case
	 * where the source blend factor is 0, and the source blend value is the
	 * mask channels multiplied by the source picture's alpha.
	 */
	if (mask && mask->componentAlpha && PICT_FORMAT_RGB(mask->format)
	    && i830_blend_op[op].src_alpha) {
		if (dblend == BLENDFACTOR_SRC_ALPHA) {
			dblend = BLENDFACTOR_SRC_COLR;
		} else if (dblend == BLENDFACTOR_INV_SRC_ALPHA) {
			dblend = BLENDFACTOR_INV_SRC_COLR;
		}
	}

	*blendctl = (sblend << S8_SRC_BLEND_FACTOR_SHIFT) |
	    (dblend << S8_DST_BLEND_FACTOR_SHIFT);

	return TRUE;
}

static uint32_t i8xx_get_card_format(intel_screen_private *intel,
				     PicturePtr picture)
{
	int i;

	for (i = 0; i < sizeof(i830_tex_formats) / sizeof(i830_tex_formats[0]);
	     i++) {
		if (i830_tex_formats[i].fmt == picture->format)
			return i830_tex_formats[i].card_fmt;
	}

	if (!(IS_I830(intel) || IS_845G(intel))) {
		for (i = 0; i < sizeof(i855_tex_formats) / sizeof(i855_tex_formats[0]);
		     i++) {
			if (i855_tex_formats[i].fmt == picture->format)
				return i855_tex_formats[i].card_fmt;
		}
	}

	return 0;
}

static void i830_texture_setup(PicturePtr picture, PixmapPtr pixmap, int unit)
{

	ScrnInfoPtr scrn = xf86ScreenToScrn(picture->pDrawable->pScreen);
	intel_screen_private *intel = intel_get_screen_private(scrn);
	uint32_t format, tiling_bits, pitch, filter;
	uint32_t wrap_mode;
	uint32_t texcoordtype;

	pitch = intel_pixmap_pitch(pixmap);
	intel->scale_units[unit][0] = pixmap->drawable.width;
	intel->scale_units[unit][1] = pixmap->drawable.height;
	intel->transform[unit] = picture->transform;

	if (intel_transform_is_affine(intel->transform[unit]))
		texcoordtype = TEXCOORDTYPE_CARTESIAN;
	else
		texcoordtype = TEXCOORDTYPE_HOMOGENEOUS;

	switch (picture->repeatType) {
	case RepeatNone:
		wrap_mode = TEXCOORDMODE_CLAMP_BORDER;
		break;
	case RepeatNormal:
		wrap_mode = TEXCOORDMODE_WRAP;
		break;
	case RepeatPad:
		wrap_mode = TEXCOORDMODE_CLAMP;
		break;
	case RepeatReflect:
		wrap_mode = TEXCOORDMODE_MIRROR;
		break;
	default:
		FatalError("Unknown repeat type %d\n", picture->repeatType);
	}

	switch (picture->filter) {
	case PictFilterNearest:
		filter = ((FILTER_NEAREST << TM0S3_MAG_FILTER_SHIFT) |
			  (FILTER_NEAREST << TM0S3_MIN_FILTER_SHIFT));
		break;
	case PictFilterBilinear:
		filter = ((FILTER_LINEAR << TM0S3_MAG_FILTER_SHIFT) |
			  (FILTER_LINEAR << TM0S3_MIN_FILTER_SHIFT));
		break;
	default:
		FatalError("Bad filter 0x%x\n", picture->filter);
	}
	filter |= (MIPFILTER_NONE << TM0S3_MIP_FILTER_SHIFT);

	if (intel_pixmap_tiled(pixmap)) {
		tiling_bits = TM0S1_TILED_SURFACE;
		if (intel_get_pixmap_private(pixmap)->tiling
				== I915_TILING_Y)
			tiling_bits |= TM0S1_TILE_WALK;
	} else
		tiling_bits = 0;

	format = i8xx_get_card_format(intel, picture);

	assert(intel->in_batch_atomic);

	OUT_BATCH(_3DSTATE_LOAD_STATE_IMMEDIATE_2 |
		  LOAD_TEXTURE_MAP(unit) | 4);
	OUT_RELOC_PIXMAP(pixmap, I915_GEM_DOMAIN_SAMPLER, 0, 0);
	OUT_BATCH(((pixmap->drawable.height -
		    1) << TM0S1_HEIGHT_SHIFT) | ((pixmap->drawable.width -
						  1) <<
						 TM0S1_WIDTH_SHIFT) |
		  format | tiling_bits);
	OUT_BATCH((pitch / 4 - 1) << TM0S2_PITCH_SHIFT | TM0S2_MAP_2D);
	OUT_BATCH(filter);
	OUT_BATCH(0);	/* default color */
	OUT_BATCH(_3DSTATE_MAP_COORD_SET_CMD | TEXCOORD_SET(unit) |
		  ENABLE_TEXCOORD_PARAMS | TEXCOORDS_ARE_NORMAL |
		  texcoordtype | ENABLE_ADDR_V_CNTL |
		  TEXCOORD_ADDR_V_MODE(wrap_mode) |
		  ENABLE_ADDR_U_CNTL | TEXCOORD_ADDR_U_MODE(wrap_mode));
	/* map texel stream */
	OUT_BATCH(_3DSTATE_MAP_COORD_SETBIND_CMD);
	if (unit == 0)
		OUT_BATCH(TEXBIND_SET0(TEXCOORDSRC_VTXSET_0) |
			  TEXBIND_SET1(TEXCOORDSRC_KEEP) |
			  TEXBIND_SET2(TEXCOORDSRC_KEEP) |
			  TEXBIND_SET3(TEXCOORDSRC_KEEP));
	else
		OUT_BATCH(TEXBIND_SET0(TEXCOORDSRC_VTXSET_0) |
			  TEXBIND_SET1(TEXCOORDSRC_VTXSET_1) |
			  TEXBIND_SET2(TEXCOORDSRC_KEEP) |
			  TEXBIND_SET3(TEXCOORDSRC_KEEP));
	OUT_BATCH(_3DSTATE_MAP_TEX_STREAM_CMD | (unit << 16) |
		  DISABLE_TEX_STREAM_BUMP |
		  ENABLE_TEX_STREAM_COORD_SET |
		  TEX_STREAM_COORD_SET(unit) |
		  ENABLE_TEX_STREAM_MAP_IDX | TEX_STREAM_MAP_IDX(unit));
}

Bool
i830_check_composite(int op,
		     PicturePtr source_picture,
		     PicturePtr mask_picture,
		     PicturePtr dest_picture,
		     int width, int height)
{
	ScrnInfoPtr scrn = xf86ScreenToScrn(dest_picture->pDrawable->pScreen);
	uint32_t tmp1;

	/* Check for unsupported compositing operations. */
	if (op >= sizeof(i830_blend_op) / sizeof(i830_blend_op[0])) {
		intel_debug_fallback(scrn, "Unsupported Composite op 0x%x\n",
				     op);
		return FALSE;
	}

	if (mask_picture != NULL && mask_picture->componentAlpha &&
	    PICT_FORMAT_RGB(mask_picture->format)) {
		/* Check if it's component alpha that relies on a source alpha and on
		 * the source value.  We can only get one of those into the single
		 * source value that we get to blend with.
		 */
		if (i830_blend_op[op].src_alpha &&
		    (i830_blend_op[op].src_blend != BLENDFACTOR_ZERO)) {
			intel_debug_fallback(scrn, "Component alpha not "
					     "supported with source alpha and "
					     "source value blending.\n");
			return FALSE;
		}
	}

	if (!i830_get_dest_format(dest_picture, &tmp1)) {
		intel_debug_fallback(scrn, "Get Color buffer format\n");
		return FALSE;
	}

	if (width > 2048 || height > 2048) {
		intel_debug_fallback(scrn, "Operation is too large (%d, %d)\n", width, height);
		return FALSE;
	}

	return TRUE;
}

Bool
i830_check_composite_target(PixmapPtr pixmap)
{
	if (pixmap->drawable.width > 2048 || pixmap->drawable.height > 2048)
		return FALSE;

	if(!intel_check_pitch_3d(pixmap))
		return FALSE;

	return TRUE;
}

Bool
i830_check_composite_texture(ScreenPtr screen, PicturePtr picture)
{
	ScrnInfoPtr scrn = xf86ScreenToScrn(screen);
	intel_screen_private *intel = intel_get_screen_private(scrn);

	if (picture->repeatType > RepeatReflect) {
		intel_debug_fallback(scrn, "Unsupported picture repeat %d\n",
			     picture->repeatType);
		return FALSE;
	}

	if (picture->filter != PictFilterNearest &&
	    picture->filter != PictFilterBilinear) {
		intel_debug_fallback(scrn, "Unsupported filter 0x%x\n",
				     picture->filter);
		return FALSE;
	}

	if (picture->pDrawable) {
		int w, h;

		w = picture->pDrawable->width;
		h = picture->pDrawable->height;
		if ((w > 2048) || (h > 2048)) {
			intel_debug_fallback(scrn,
					     "Picture w/h too large (%dx%d)\n",
					     w, h);
			return FALSE;
		}

		/* XXX we can use the xrgb32 types if there the picture covers the clip */
		if (!i8xx_get_card_format(intel, picture)) {
			intel_debug_fallback(scrn, "Unsupported picture format "
					     "0x%x\n",
					     (int)picture->format);
			return FALSE;
		}

		return TRUE;
	}

	return FALSE;
}

Bool
i830_prepare_composite(int op, PicturePtr source_picture,
		       PicturePtr mask_picture, PicturePtr dest_picture,
		       PixmapPtr source, PixmapPtr mask, PixmapPtr dest)
{
	ScrnInfoPtr scrn = xf86ScreenToScrn(dest_picture->pDrawable->pScreen);
	intel_screen_private *intel = intel_get_screen_private(scrn);
	drm_intel_bo *bo_table[] = {
		NULL,		/* batch_bo */
		intel_get_pixmap_bo(source),
		mask ? intel_get_pixmap_bo(mask) : NULL,
		intel_get_pixmap_bo(dest),
	};

	intel->render_source_picture = source_picture;
	intel->render_source = source;
	intel->render_mask_picture = mask_picture;
	intel->render_mask = mask;
	intel->render_dest_picture = dest_picture;
	intel->render_dest = dest;

	if (!intel_check_pitch_3d(source))
		return FALSE;
	if (mask) {
		if (mask_picture->componentAlpha &&
		    PICT_FORMAT_RGB(mask_picture->format)) {
			/* Check if it's component alpha that relies on a source alpha and on
			 * the source value.  We can only get one of those into the single
			 * source value that we get to blend with.
			 */
			if (i830_blend_op[op].src_alpha &&
			    (i830_blend_op[op].src_blend != BLENDFACTOR_ZERO)) {
				intel_debug_fallback(scrn, "Component alpha not "
						     "supported with source alpha and "
						     "source value blending.\n");
				return FALSE;
			}
		}
		if (!intel_check_pitch_3d(mask))
			return FALSE;
	}
	if (!intel_check_pitch_3d(dest))
		return FALSE;

	if (!i830_get_dest_format(dest_picture, &intel->render_dest_format))
		return FALSE;

	if (!intel_get_aperture_space(scrn, bo_table, ARRAY_SIZE(bo_table)))
		return FALSE;

	if (mask) {
		intel->transform[1] = NULL;
		intel->scale_units[1][0] = -1;
		intel->scale_units[1][1] = -1;
	}

	{
		uint32_t cblend, ablend, blendctl;

		/* If component alpha is active in the mask and the blend operation
		 * uses the source alpha, then we know we don't need the source
		 * value (otherwise we would have hit a fallback earlier), so we
		 * provide the source alpha (src.A * mask.X) as output color.
		 * Conversely, if CA is set and we don't need the source alpha, then
		 * we produce the source value (src.X * mask.X) and the source alpha
		 * is unused..  Otherwise, we provide the non-CA source value
		 * (src.X * mask.A).
		 *
		 * The PICT_FORMAT_RGB(pict) == 0 fixups are not needed on 855+'s a8
		 * pictures, but we need to implement it for 830/845 and there's no
		 * harm done in leaving it in.
		 */
		cblend =
		    TB0C_LAST_STAGE | TB0C_RESULT_SCALE_1X | TB0C_OP_MODULE |
		    TB0C_OUTPUT_WRITE_CURRENT;
		ablend =
		    TB0A_RESULT_SCALE_1X | TB0A_OP_MODULE |
		    TB0A_OUTPUT_WRITE_CURRENT;

		/* Get the source picture's channels into TBx_ARG1 */
		if ((mask_picture != NULL &&
		     mask_picture->componentAlpha &&
		     PICT_FORMAT_RGB(mask_picture->format) &&
		     i830_blend_op[op].src_alpha)
		    || dest_picture->format == PICT_a8) {
			/* Producing source alpha value, so the first set of channels
			 * is src.A instead of src.X.  We also do this if the destination
			 * is a8, in which case src.G is what's written, and the other
			 * channels are ignored.
			 */
			ablend |= TB0A_ARG1_SEL_TEXEL0;
			cblend |= TB0C_ARG1_SEL_TEXEL0 | TB0C_ARG1_REPLICATE_ALPHA;
		} else {
			if (PICT_FORMAT_RGB(source_picture->format) != 0)
				cblend |= TB0C_ARG1_SEL_TEXEL0;
			else
				cblend |= TB0C_ARG1_SEL_ONE | TB0C_ARG1_INVERT;	/* 0.0 */
			ablend |= TB0A_ARG1_SEL_TEXEL0;
		}

		if (mask) {
			cblend |= TB0C_ARG2_SEL_TEXEL1;
			if (dest_picture->format == PICT_a8 ||
			    ! mask_picture->componentAlpha ||
			    ! PICT_FORMAT_RGB(mask_picture->format))
				cblend |= TB0C_ARG2_REPLICATE_ALPHA;
			ablend |= TB0A_ARG2_SEL_TEXEL1;
		} else {
			cblend |= TB0C_ARG2_SEL_ONE;
			ablend |= TB0A_ARG2_SEL_ONE;
		}

		if (!i830_get_blend_cntl
		    (scrn, op, mask_picture, dest_picture->format, &blendctl)) {
			return FALSE;
		}

		intel->cblend = cblend;
		intel->ablend = ablend;
		intel->s8_blendctl = blendctl;
	}

	if (intel_pixmap_is_dirty(source) || intel_pixmap_is_dirty(mask))
		intel_batch_emit_flush(scrn);

	intel->needs_render_state_emit = TRUE;

	return TRUE;
}

static void i830_emit_composite_state(ScrnInfoPtr scrn)
{
	intel_screen_private *intel = intel_get_screen_private(scrn);
	uint32_t vf2, tiling_bits;
	uint32_t texcoordfmt = 0;

	intel->needs_render_state_emit = FALSE;

	IntelEmitInvarientState(scrn);
	intel->last_3d = LAST_3D_RENDER;

	assert(intel->in_batch_atomic);

	if (intel_pixmap_tiled(intel->render_dest)) {
		tiling_bits = BUF_3D_TILED_SURFACE;
		if (intel_get_pixmap_private(intel->render_dest)->tiling
				== I915_TILING_Y)
			tiling_bits |= BUF_3D_TILE_WALK_Y;
	} else
		tiling_bits = 0;

	OUT_BATCH(_3DSTATE_BUF_INFO_CMD);
	OUT_BATCH(BUF_3D_ID_COLOR_BACK | tiling_bits |
		  BUF_3D_PITCH(intel_pixmap_pitch(intel->render_dest)));
	OUT_RELOC_PIXMAP(intel->render_dest,
			 I915_GEM_DOMAIN_RENDER, I915_GEM_DOMAIN_RENDER, 0);

	OUT_BATCH(_3DSTATE_DST_BUF_VARS_CMD);
	OUT_BATCH(intel->render_dest_format);

	OUT_BATCH(_3DSTATE_DRAW_RECT_CMD);
	OUT_BATCH(0);
	OUT_BATCH(0);		/* ymin, xmin */
	OUT_BATCH(DRAW_YMAX(intel->render_dest->drawable.height - 1) |
		  DRAW_XMAX(intel->render_dest->drawable.width - 1));
	OUT_BATCH(0);		/* yorig, xorig */

	OUT_BATCH(_3DSTATE_LOAD_STATE_IMMEDIATE_1 |
		  I1_LOAD_S(2) | I1_LOAD_S(3) | I1_LOAD_S(8) | 2);
	if (intel->render_mask)
		vf2 = 2 << 12;	/* 2 texture coord sets */
	else
		vf2 = 1 << 12;
	OUT_BATCH(vf2);		/* number of coordinate sets */
	OUT_BATCH(S3_CULLMODE_NONE | S3_VERTEXHAS_XY);
	OUT_BATCH(S8_ENABLE_COLOR_BLEND | S8_BLENDFUNC_ADD | intel->
		  s8_blendctl | S8_ENABLE_COLOR_BUFFER_WRITE);

	OUT_BATCH(_3DSTATE_INDPT_ALPHA_BLEND_CMD | DISABLE_INDPT_ALPHA_BLEND);

	OUT_BATCH(_3DSTATE_LOAD_STATE_IMMEDIATE_2 |
		  LOAD_TEXTURE_BLEND_STAGE(0) | 1);
	OUT_BATCH(intel->cblend);
	OUT_BATCH(intel->ablend);

	OUT_BATCH(_3DSTATE_ENABLES_1_CMD | DISABLE_LOGIC_OP |
		  DISABLE_STENCIL_TEST | DISABLE_DEPTH_BIAS |
		  DISABLE_SPEC_ADD | DISABLE_FOG | DISABLE_ALPHA_TEST |
		  ENABLE_COLOR_BLEND | DISABLE_DEPTH_TEST);
	/* We have to explicitly say we don't want write disabled */
	OUT_BATCH(_3DSTATE_ENABLES_2_CMD | ENABLE_COLOR_MASK |
		  DISABLE_STENCIL_WRITE | ENABLE_TEX_CACHE |
		  DISABLE_DITHER | ENABLE_COLOR_WRITE | DISABLE_DEPTH_WRITE);

	if (intel_transform_is_affine(intel->render_source_picture->transform))
		texcoordfmt |= (TEXCOORDFMT_2D << 0);
	else
		texcoordfmt |= (TEXCOORDFMT_3D << 0);
	if (intel->render_mask) {
		if (intel_transform_is_affine
		    (intel->render_mask_picture->transform))
			texcoordfmt |= (TEXCOORDFMT_2D << 2);
		else
			texcoordfmt |= (TEXCOORDFMT_3D << 2);
	}
	OUT_BATCH(_3DSTATE_VERTEX_FORMAT_2_CMD | texcoordfmt);

	i830_texture_setup(intel->render_source_picture, intel->render_source, 0);
	if (intel->render_mask) {
		i830_texture_setup(intel->render_mask_picture,
				   intel->render_mask, 1);
	}
}

/* Emit the vertices for a single composite rectangle.
 *
 * This function is no longer shared between i830 and i915 generation code.
 */
static void
i830_emit_composite_primitive(PixmapPtr dest,
			      int srcX, int srcY,
			      int maskX, int maskY,
			      int dstX, int dstY, int w, int h)
{
	ScrnInfoPtr scrn = xf86ScreenToScrn(dest->drawable.pScreen);
	intel_screen_private *intel = intel_get_screen_private(scrn);
	Bool is_affine_src, is_affine_mask = TRUE;
	int per_vertex;
	float src_x[3], src_y[3], src_w[3], mask_x[3], mask_y[3], mask_w[3];

	per_vertex = 2;		/* dest x/y */

	{
		float x = srcX, y = srcY;

		is_affine_src = intel_transform_is_affine(intel->transform[0]);
		if (is_affine_src) {
			if (!intel_get_transformed_coordinates(x, y,
							      intel->
							      transform[0],
							      &src_x[0],
							      &src_y[0]))
				return;

			if (!intel_get_transformed_coordinates(x, y + h,
							      intel->
							      transform[0],
							      &src_x[1],
							      &src_y[1]))
				return;

			if (!intel_get_transformed_coordinates(x + w, y + h,
							      intel->
							      transform[0],
							      &src_x[2],
							      &src_y[2]))
				return;

			per_vertex += 2;	/* src x/y */
		} else {
			if (!intel_get_transformed_coordinates_3d(x, y,
								 intel->
								 transform[0],
								 &src_x[0],
								 &src_y[0],
								 &src_w[0]))
				return;

			if (!intel_get_transformed_coordinates_3d(x, y + h,
								 intel->
								 transform[0],
								 &src_x[1],
								 &src_y[1],
								 &src_w[1]))
				return;

			if (!intel_get_transformed_coordinates_3d(x + w, y + h,
								 intel->
								 transform[0],
								 &src_x[2],
								 &src_y[2],
								 &src_w[2]))
				return;

			per_vertex += 3;	/* src x/y/w */
		}
	}

	if (intel->render_mask) {
		float x = maskX, y = maskY;

		is_affine_mask = intel_transform_is_affine(intel->transform[1]);
		if (is_affine_mask) {
			if (!intel_get_transformed_coordinates(x, y,
							      intel->
							      transform[1],
							      &mask_x[0],
							      &mask_y[0]))
				return;

			if (!intel_get_transformed_coordinates(x, y + h,
							      intel->
							      transform[1],
							      &mask_x[1],
							      &mask_y[1]))
				return;

			if (!intel_get_transformed_coordinates(x + w, y + h,
							      intel->
							      transform[1],
							      &mask_x[2],
							      &mask_y[2]))
				return;

			per_vertex += 2;	/* mask x/y */
		} else {
			if (!intel_get_transformed_coordinates_3d(x, y,
								 intel->
								 transform[1],
								 &mask_x[0],
								 &mask_y[0],
								 &mask_w[0]))
				return;

			if (!intel_get_transformed_coordinates_3d(x, y + h,
								 intel->
								 transform[1],
								 &mask_x[1],
								 &mask_y[1],
								 &mask_w[1]))
				return;

			if (!intel_get_transformed_coordinates_3d(x + w, y + h,
								 intel->
								 transform[1],
								 &mask_x[2],
								 &mask_y[2],
								 &mask_w[2]))
				return;

			per_vertex += 3;	/* mask x/y/w */
		}
	}

	if (intel->vertex_count == 0) {
		intel->vertex_index = intel->batch_used;
		OUT_BATCH(PRIM3D_INLINE | PRIM3D_RECTLIST);
	}
	OUT_BATCH_F(dstX + w);
	OUT_BATCH_F(dstY + h);
	OUT_BATCH_F(src_x[2] / intel->scale_units[0][0]);
	OUT_BATCH_F(src_y[2] / intel->scale_units[0][1]);
	if (!is_affine_src) {
		OUT_BATCH_F(src_w[2]);
	}
	if (intel->render_mask) {
		OUT_BATCH_F(mask_x[2] / intel->scale_units[1][0]);
		OUT_BATCH_F(mask_y[2] / intel->scale_units[1][1]);
		if (!is_affine_mask) {
			OUT_BATCH_F(mask_w[2]);
		}
	}

	OUT_BATCH_F(dstX);
	OUT_BATCH_F(dstY + h);
	OUT_BATCH_F(src_x[1] / intel->scale_units[0][0]);
	OUT_BATCH_F(src_y[1] / intel->scale_units[0][1]);
	if (!is_affine_src) {
		OUT_BATCH_F(src_w[1]);
	}
	if (intel->render_mask) {
		OUT_BATCH_F(mask_x[1] / intel->scale_units[1][0]);
		OUT_BATCH_F(mask_y[1] / intel->scale_units[1][1]);
		if (!is_affine_mask) {
			OUT_BATCH_F(mask_w[1]);
		}
	}

	OUT_BATCH_F(dstX);
	OUT_BATCH_F(dstY);
	OUT_BATCH_F(src_x[0] / intel->scale_units[0][0]);
	OUT_BATCH_F(src_y[0] / intel->scale_units[0][1]);
	if (!is_affine_src) {
		OUT_BATCH_F(src_w[0]);
	}
	if (intel->render_mask) {
		OUT_BATCH_F(mask_x[0] / intel->scale_units[1][0]);
		OUT_BATCH_F(mask_y[0] / intel->scale_units[1][1]);
		if (!is_affine_mask) {
			OUT_BATCH_F(mask_w[0]);
		}
	}

	intel->vertex_count += 3 * per_vertex;

}

void i830_vertex_flush(intel_screen_private *intel)
{
	if (intel->vertex_count) {
		intel->batch_ptr[intel->vertex_index] |= intel->vertex_count - 1;
		intel->vertex_count = 0;
	}
}

/**
 * Do a single rectangle composite operation.
 */
void
i830_composite(PixmapPtr dest, int srcX, int srcY, int maskX, int maskY,
	       int dstX, int dstY, int w, int h)
{
	ScrnInfoPtr scrn = xf86ScreenToScrn(dest->drawable.pScreen);
	intel_screen_private *intel = intel_get_screen_private(scrn);

	intel_batch_start_atomic(scrn, 58 +	/* invarient */
				 22 +	/* setup */
				 20 +	/* 2 * setup_texture */
				 1 + 30 /* verts */ );

	if (intel->needs_render_state_emit)
		i830_emit_composite_state(scrn);

	i830_emit_composite_primitive(dest, srcX, srcY, maskX, maskY, dstX,
				      dstY, w, h);

	intel_batch_end_atomic(scrn);
}

void i830_batch_commit_notify(intel_screen_private *intel)
{
	intel->needs_render_state_emit = TRUE;
}
@


1.7
log
@Update to xf86-video-intel 2.20.19.

A recent kernel with kernel modesetting support is required.
Thanks to jsg@@ and kettenis@@ for their work.
@
text
@@


1.6
log
@Update the intel driver to a more recent version based on more recent
upsteam code.

Backporting keeping UMS changes by me, some bugfixes from kettenis@@.

Has been in snapshots for a while, committed on request so we can be
sure what people are running. This is a prerequesite for sandybridge
support but has those chipsets disabled for now until the correct code
has been added.
@
text
@d167 1
a167 1
		scrn = xf86Screens[dest_picture->pDrawable->pScreen->myNum];
d248 1
a248 1
	ScrnInfoPtr scrn = xf86Screens[picture->pDrawable->pScreen->myNum];
a290 1
		filter = 0;
d349 1
a349 1
	ScrnInfoPtr scrn = xf86Screens[dest_picture->pDrawable->pScreen->myNum];
d402 1
a402 1
	ScrnInfoPtr scrn = xf86Screens[screen->myNum];
d449 1
a449 1
	ScrnInfoPtr scrn = xf86Screens[dest_picture->pDrawable->pScreen->myNum];
d566 1
a566 2
	if(intel_pixmap_is_dirty(source) ||
	   (mask && intel_pixmap_is_dirty(mask)))
d668 1
a668 1
	ScrnInfoPtr scrn = xf86Screens[dest->drawable.pScreen->myNum];
d856 1
a856 1
	ScrnInfoPtr scrn = xf86Screens[dest->drawable.pScreen->myNum];
@


1.5
log
@Update the intel driver to (mostly) a backport of 2.12.

It is missing a few commits that I have yet to verify (ones that try and
continue if we lock the gpu rendering engine and can't reset it, for
example) taht will be verified and sent out for extra testing soon.

Should contain a bunch of speedups and some correctness improvements
(though rendercheck still gives some errors that I am looking into).

This has been in snaps since the first day of c2k10, any known issues
with just this driver have (to my knowledge) been fixed since. A problem
with macbooks pointed out by otto happens with both this and the in-tree
driver and thus doesn't stop this moving forward.

As well as the 2.12 improvements, this driver also has a backport
(partially aided by the backports in RHEL 5 kindly provided by Dave
Airlie) from the kms code of modesetting support for ironlake (arrandale
and clarkdale: the IGDs build into intel nehalem cpu dies) which has
been tested on a number of chipsets. Note that Display port and eDP
displays have not yet been worked on (and probably won't until I can
find a displayport monitor), but VGA and lvds at least are known to
work, sure beats vesa.

"no objection on my side" matthieu@@, prodding (as always) from princess
marco.
@
text
@d34 1
a34 1
#include "i830.h"
d234 1
a234 1
	if (IS_I85X(intel) || IS_I865G(intel)) {
d254 1
a254 1
	pitch = intel_get_pixmap_pitch(pixmap);
d259 1
a259 1
	if (i830_transform_is_affine(intel->transform[unit]))
d296 1
a296 1
	if (i830_pixmap_tiled(pixmap)) {
d298 1
a298 1
		if (i830_get_pixmap_intel(pixmap)->tiling
d454 3
a456 3
		i830_get_pixmap_bo(source),
		mask ? i830_get_pixmap_bo(mask) : NULL,
		i830_get_pixmap_bo(dest),
d492 1
a492 1
	if (!i830_get_aperture_space(scrn, bo_table, ARRAY_SIZE(bo_table)))
d567 2
a568 2
	if(i830_uxa_pixmap_is_dirty(source) ||
	   (mask && i830_uxa_pixmap_is_dirty(mask)))
d589 1
a589 1
	if (i830_pixmap_tiled(intel->render_dest)) {
d591 1
a591 1
		if (i830_get_pixmap_intel(intel->render_dest)->tiling
d599 1
a599 1
		  BUF_3D_PITCH(intel_get_pixmap_pitch(intel->render_dest)));
d640 1
a640 1
	if (i830_transform_is_affine(intel->render_source_picture->transform))
d645 1
a645 1
		if (i830_transform_is_affine
d673 1
a673 1
	int per_vertex, num_floats;
d681 1
a681 1
		is_affine_src = i830_transform_is_affine(intel->transform[0]);
d683 1
a683 1
			if (!i830_get_transformed_coordinates(x, y,
d690 1
a690 1
			if (!i830_get_transformed_coordinates(x, y + h,
d697 1
a697 1
			if (!i830_get_transformed_coordinates(x + w, y + h,
d706 1
a706 1
			if (!i830_get_transformed_coordinates_3d(x, y,
d714 1
a714 1
			if (!i830_get_transformed_coordinates_3d(x, y + h,
d722 1
a722 1
			if (!i830_get_transformed_coordinates_3d(x + w, y + h,
d737 1
a737 1
		is_affine_mask = i830_transform_is_affine(intel->transform[1]);
d739 1
a739 1
			if (!i830_get_transformed_coordinates(x, y,
d746 1
a746 1
			if (!i830_get_transformed_coordinates(x, y + h,
d753 1
a753 1
			if (!i830_get_transformed_coordinates(x + w, y + h,
d762 1
a762 1
			if (!i830_get_transformed_coordinates_3d(x, y,
d770 1
a770 1
			if (!i830_get_transformed_coordinates_3d(x, y + h,
d778 1
a778 1
			if (!i830_get_transformed_coordinates_3d(x + w, y + h,
d790 4
a793 3
	num_floats = 3 * per_vertex;

	OUT_BATCH(PRIM3D_INLINE | PRIM3D_RECTLIST | (num_floats - 1));
d838 11
d875 1
a875 1
void i830_batch_flush_notify(ScrnInfoPtr scrn)
a876 2
	intel_screen_private *intel = intel_get_screen_private(scrn);

@


1.4
log
@Update the intel driver to 2.9.1 plus backports.

2.9.1 is the last version of the intel DDX that supports UMS (User
modesetting), with 2.10 onwards being purely KMS only. As such, this
driver contains backports of almost every correctness or performance
related fix to the rendering layer in later intel drivers. This driver
*REQUIRES* a GEM enabled kernel. it claims to support non-gem mode but
this is essentially unmaintained and due to the way the abstraciton
works is slow, if it works at all (it often does not). You have been
warned.

tested by many many people on tech over the last few weeks.
@
text
@a128 4
/* The x8* formats could use MT_32BIT_X* on 855+, but since we implement
 * workarounds for 830/845 anyway, we just rely on those whether the hardware
 * could handle it for us or not.
 */
d130 11
a140 8
	{PICT_a8r8g8b8, MT_32BIT_ARGB8888},
	{PICT_x8r8g8b8, MT_32BIT_ARGB8888},
	{PICT_a8b8g8r8, MT_32BIT_ABGR8888},
	{PICT_x8b8g8r8, MT_32BIT_ABGR8888},
	{PICT_r5g6b5, MT_16BIT_RGB565},
	{PICT_a1r5g5b5, MT_16BIT_ARGB1555},
	{PICT_x1r5g5b5, MT_16BIT_ARGB1555},
	{PICT_a8, MT_8BIT_A8},
d223 2
a224 2
static Bool i830_check_composite_texture(ScrnInfoPtr scrn, PicturePtr picture,
					 int unit)
d226 1
a226 5
	if (picture->repeatType > RepeatReflect) {
		intel_debug_fallback(scrn, "Unsupported picture repeat %d\n",
			     picture->repeatType);
		return FALSE;
	}
d228 4
a231 5
	if (picture->filter != PictFilterNearest &&
	    picture->filter != PictFilterBilinear) {
		intel_debug_fallback(scrn, "Unsupported filter 0x%x\n",
				     picture->filter);
		return FALSE;
d234 2
a235 14
	if (picture->pDrawable) {
		int w, h, i;

		w = picture->pDrawable->width;
		h = picture->pDrawable->height;
		if ((w > 2048) || (h > 2048)) {
			intel_debug_fallback(scrn,
					     "Picture w/h too large (%dx%d)\n",
					     w, h);
			return FALSE;
		}

		for (i = 0;
		     i < sizeof(i830_tex_formats) / sizeof(i830_tex_formats[0]);
d237 2
a238 9
			if (i830_tex_formats[i].fmt == picture->format)
				break;
		}
		if (i == sizeof(i830_tex_formats) / sizeof(i830_tex_formats[0]))
		{
			intel_debug_fallback(scrn, "Unsupported picture format "
					     "0x%x\n",
					     (int)picture->format);
			return FALSE;
d242 1
a242 12
	return TRUE;
}

static uint32_t i8xx_get_card_format(PicturePtr picture)
{
	int i;
	for (i = 0; i < sizeof(i830_tex_formats) / sizeof(i830_tex_formats[0]);
	     i++) {
		if (i830_tex_formats[i].fmt == picture->format)
			return i830_tex_formats[i].card_fmt;
	}
	FatalError("Unsupported format type %d\n", picture->format);
a263 2
	format = i8xx_get_card_format(picture);

d296 11
a306 7
	{
		if (pixmap->drawable.bitsPerPixel == 8)
			format |= MAPSURF_8BIT;
		else if (pixmap->drawable.bitsPerPixel == 16)
			format |= MAPSURF_16BIT;
		else
			format |= MAPSURF_32BIT;
d308 33
a340 44
		if (i830_pixmap_tiled(pixmap)) {
			tiling_bits = TM0S1_TILED_SURFACE;
			if (i830_get_pixmap_intel(pixmap)->tiling
					== I915_TILING_Y)
				tiling_bits |= TM0S1_TILE_WALK;
		} else
			tiling_bits = 0;

		ATOMIC_BATCH(10);
		OUT_BATCH(_3DSTATE_LOAD_STATE_IMMEDIATE_2 |
			  LOAD_TEXTURE_MAP(unit) | 4);
		OUT_RELOC_PIXMAP(pixmap, I915_GEM_DOMAIN_SAMPLER, 0, 0);
		OUT_BATCH(((pixmap->drawable.height -
			    1) << TM0S1_HEIGHT_SHIFT) | ((pixmap->drawable.width -
							  1) <<
							 TM0S1_WIDTH_SHIFT) |
			  format | tiling_bits);
		OUT_BATCH((pitch / 4 - 1) << TM0S2_PITCH_SHIFT | TM0S2_MAP_2D);
		OUT_BATCH(filter);
		OUT_BATCH(0);	/* default color */
		OUT_BATCH(_3DSTATE_MAP_COORD_SET_CMD | TEXCOORD_SET(unit) |
			  ENABLE_TEXCOORD_PARAMS | TEXCOORDS_ARE_NORMAL |
			  texcoordtype | ENABLE_ADDR_V_CNTL |
			  TEXCOORD_ADDR_V_MODE(wrap_mode) |
			  ENABLE_ADDR_U_CNTL | TEXCOORD_ADDR_U_MODE(wrap_mode));
		/* map texel stream */
		OUT_BATCH(_3DSTATE_MAP_COORD_SETBIND_CMD);
		if (unit == 0)
			OUT_BATCH(TEXBIND_SET0(TEXCOORDSRC_VTXSET_0) |
				  TEXBIND_SET1(TEXCOORDSRC_KEEP) |
				  TEXBIND_SET2(TEXCOORDSRC_KEEP) |
				  TEXBIND_SET3(TEXCOORDSRC_KEEP));
		else
			OUT_BATCH(TEXBIND_SET0(TEXCOORDSRC_VTXSET_0) |
				  TEXBIND_SET1(TEXCOORDSRC_VTXSET_1) |
				  TEXBIND_SET2(TEXCOORDSRC_KEEP) |
				  TEXBIND_SET3(TEXCOORDSRC_KEEP));
		OUT_BATCH(_3DSTATE_MAP_TEX_STREAM_CMD | (unit << 16) |
			  DISABLE_TEX_STREAM_BUMP |
			  ENABLE_TEX_STREAM_COORD_SET |
			  TEX_STREAM_COORD_SET(unit) |
			  ENABLE_TEX_STREAM_MAP_IDX | TEX_STREAM_MAP_IDX(unit));
		ADVANCE_BATCH();
	}
d344 5
a348 2
i830_check_composite(int op, PicturePtr source_picture, PicturePtr mask_picture,
		     PicturePtr dest_picture)
d375 2
a376 2
	if (!i830_check_composite_texture(scrn, source_picture, 0)) {
		intel_debug_fallback(scrn, "Check Src picture texture\n");
d379 30
a408 3
	if (mask_picture != NULL
	    && !i830_check_composite_texture(scrn, mask_picture, 1)) {
		intel_debug_fallback(scrn, "Check Mask picture texture\n");
d412 4
a415 2
	if (!i830_get_dest_format(dest_picture, &tmp1)) {
		intel_debug_fallback(scrn, "Get Color buffer format\n");
d419 24
a442 1
	return TRUE;
d469 14
d587 1
a587 1
	ATOMIC_BATCH(21);
a652 2
	ADVANCE_BATCH();

a791 2
	ATOMIC_BATCH(1 + num_floats);

a836 2

	ADVANCE_BATCH();
@


1.3
log
@update to xf86-video-intel 2.7.1. Tested by many.
@
text
@d38 4
a41 4
    Bool dst_alpha;
    Bool src_alpha;
    uint32_t src_blend;
    uint32_t dst_blend;
d45 2
a46 2
    int fmt;
    uint32_t card_fmt;
d101 26
a126 26
    /* Clear */
    {0, 0, BLENDFACTOR_ZERO, 		BLENDFACTOR_ZERO},
    /* Src */
    {0, 0, BLENDFACTOR_ONE, 		BLENDFACTOR_ZERO},
    /* Dst */
    {0, 0, BLENDFACTOR_ZERO,		BLENDFACTOR_ONE},
    /* Over */
    {0, 1, BLENDFACTOR_ONE,		BLENDFACTOR_INV_SRC_ALPHA},
    /* OverReverse */
    {1, 0, BLENDFACTOR_INV_DST_ALPHA,	BLENDFACTOR_ONE},
    /* In */
    {1, 0, BLENDFACTOR_DST_ALPHA,	BLENDFACTOR_ZERO},
    /* InReverse */
    {0, 1, BLENDFACTOR_ZERO,		BLENDFACTOR_SRC_ALPHA},
    /* Out */
    {1, 0, BLENDFACTOR_INV_DST_ALPHA,	BLENDFACTOR_ZERO},
    /* OutReverse */
    {0, 1, BLENDFACTOR_ZERO,		BLENDFACTOR_INV_SRC_ALPHA},
    /* Atop */
    {1, 1, BLENDFACTOR_DST_ALPHA,	BLENDFACTOR_INV_SRC_ALPHA},
    /* AtopReverse */
    {1, 1, BLENDFACTOR_INV_DST_ALPHA,	BLENDFACTOR_SRC_ALPHA},
    /* Xor */
    {1, 1, BLENDFACTOR_INV_DST_ALPHA,	BLENDFACTOR_INV_SRC_ALPHA},
    /* Add */
    {0, 0, BLENDFACTOR_ONE, 		BLENDFACTOR_ONE},
d134 8
a141 8
    {PICT_a8r8g8b8, MT_32BIT_ARGB8888 },
    {PICT_x8r8g8b8, MT_32BIT_ARGB8888 },
    {PICT_a8b8g8r8, MT_32BIT_ABGR8888 },
    {PICT_x8b8g8r8, MT_32BIT_ABGR8888 },
    {PICT_r5g6b5,   MT_16BIT_RGB565   },
    {PICT_a1r5g5b5, MT_16BIT_ARGB1555 },
    {PICT_x1r5g5b5, MT_16BIT_ARGB1555 },
    {PICT_a8,       MT_8BIT_A8        },
d144 1
a144 1
static Bool i830_get_dest_format(PicturePtr pDstPicture, uint32_t *dst_format)
d146 1
a146 1
    ScrnInfoPtr pScrn = xf86Screens[pDstPicture->pDrawable->pScreen->myNum];
d148 28
a175 25
    switch (pDstPicture->format) {
    case PICT_a8r8g8b8:
    case PICT_x8r8g8b8:
        *dst_format = COLR_BUF_ARGB8888;
        break;
    case PICT_r5g6b5:
        *dst_format = COLR_BUF_RGB565;
        break;
    case PICT_a1r5g5b5:
    case PICT_x1r5g5b5:
        *dst_format = COLR_BUF_ARGB1555;
        break;
	/*
    case PICT_a8:
        *dst_format = COLR_BUF_8BIT;
        break;
	*/
    case PICT_a4r4g4b4:
    case PICT_x4r4g4b4:
	*dst_format = COLR_BUF_ARGB4444;
	break;
    default:
        I830FALLBACK("Unsupported dest format 0x%x\n",
		     (int)pDstPicture->format);
    }
d177 4
a180 2
    return TRUE;
}
d182 2
d185 9
a193 4
static uint32_t i830_get_blend_cntl(int op, PicturePtr pMask,
				    uint32_t dst_format)
{
    uint32_t sblend, dblend;
d195 9
a203 2
    sblend = i830_blend_op[op].src_blend;
    dblend = i830_blend_op[op].dst_blend;
d205 5
a209 15
    /* If there's no dst alpha channel, adjust the blend op so that we'll treat
     * it as always 1.
     */
    if (PICT_FORMAT_A(dst_format) == 0 && i830_blend_op[op].dst_alpha) {
        if (sblend == BLENDFACTOR_DST_ALPHA)
            sblend = BLENDFACTOR_ONE;
        else if (sblend == BLENDFACTOR_INV_DST_ALPHA)
            sblend = BLENDFACTOR_ZERO;
    }

    /* If the source alpha is being used, then we should only be in a case
     * where the source blend factor is 0, and the source blend value is the
     * mask channels multiplied by the source picture's alpha.
     */
    if (pMask && pMask->componentAlpha && PICT_FORMAT_RGB(pMask->format) 
d211 6
a216 6
        if (dblend == BLENDFACTOR_SRC_ALPHA) {
            dblend = BLENDFACTOR_SRC_COLR;
        } else if (dblend == BLENDFACTOR_INV_SRC_ALPHA) {
            dblend = BLENDFACTOR_INV_SRC_COLR;
        }
    }
d218 4
a221 2
    return (sblend << S8_SRC_BLEND_FACTOR_SHIFT) |
	(dblend << S8_DST_BLEND_FACTOR_SHIFT);
d224 2
a225 1
static Bool i830_check_composite_texture(PicturePtr pPict, int unit)
d227 5
a231 26
    ScrnInfoPtr pScrn = xf86Screens[pPict->pDrawable->pScreen->myNum];
    int w = pPict->pDrawable->width;
    int h = pPict->pDrawable->height;
    int i;

    if ((w > 2048) || (h > 2048))
        I830FALLBACK("Picture w/h too large (%dx%d)\n", w, h);

    for (i = 0; i < sizeof(i830_tex_formats) / sizeof(i830_tex_formats[0]);
	 i++)
    {
        if (i830_tex_formats[i].fmt == pPict->format)
            break;
    }
    if (i == sizeof(i830_tex_formats) / sizeof(i830_tex_formats[0]))
        I830FALLBACK("Unsupported picture format 0x%x\n",
		     (int)pPict->format);

    if (pPict->repeatType > RepeatReflect)
        I830FALLBACK("Unsupported picture repeat %d\n", pPict->repeatType);

    if (pPict->filter != PictFilterNearest &&
        pPict->filter != PictFilterBilinear)
    {
        I830FALLBACK("Unsupported filter 0x%x\n", pPict->filter);
    }
d233 35
a267 1
    return TRUE;
d270 1
a270 2
static uint32_t
i8xx_get_card_format(PicturePtr pPict)
d272 7
a278 8
    int i;
    for (i = 0; i < sizeof(i830_tex_formats) / sizeof(i830_tex_formats[0]);
	    i++)
    {
	if (i830_tex_formats[i].fmt == pPict->format)
	    break;
    }
    return i830_tex_formats[i].card_fmt;
d281 1
a281 2
static Bool
i830_texture_setup(PicturePtr pPict, PixmapPtr pPix, int unit)
d284 13
a296 49
    ScrnInfoPtr pScrn = xf86Screens[pPict->pDrawable->pScreen->myNum];
    I830Ptr pI830 = I830PTR(pScrn);
    uint32_t format, pitch, filter;
    uint32_t wrap_mode;

    pitch = intel_get_pixmap_pitch(pPix);
    pI830->scale_units[unit][0] = pPix->drawable.width;
    pI830->scale_units[unit][1] = pPix->drawable.height;
    pI830->transform[unit] = pPict->transform;

    format = i8xx_get_card_format(pPict);

    switch (pPict->repeatType) {
    case RepeatNone:
	wrap_mode = TEXCOORDMODE_CLAMP_BORDER;
	break;
    case RepeatNormal:
	wrap_mode = TEXCOORDMODE_WRAP;
	break;
    case RepeatPad:
	wrap_mode = TEXCOORDMODE_CLAMP;
	break;
    case RepeatReflect:
	wrap_mode = TEXCOORDMODE_MIRROR;
	break;
    default:
	FatalError("Unkown repeat type %d\n", pPict->repeatType);
    }

    switch (pPict->filter) {
    case PictFilterNearest:
        filter = ((FILTER_NEAREST<<TM0S3_MAG_FILTER_SHIFT) |
		  (FILTER_NEAREST<<TM0S3_MIN_FILTER_SHIFT));
        break;
    case PictFilterBilinear:
        filter = ((FILTER_LINEAR<<TM0S3_MAG_FILTER_SHIFT) |
		  (FILTER_LINEAR<<TM0S3_MIN_FILTER_SHIFT));
        break;
    default:
	filter = 0;
        I830FALLBACK("Bad filter 0x%x\n", pPict->filter);
    }
    filter |= (MIPFILTER_NONE << TM0S3_MIP_FILTER_SHIFT); 

    {
	if (pPix->drawable.bitsPerPixel == 8)
	    format |= MAPSURF_8BIT;
	else if (pPix->drawable.bitsPerPixel == 16)
	    format |= MAPSURF_16BIT;
d298 3
a300 1
	    format |= MAPSURF_32BIT;
d302 16
a317 33
	BEGIN_BATCH(10);
	OUT_BATCH(_3DSTATE_LOAD_STATE_IMMEDIATE_2 | LOAD_TEXTURE_MAP(unit) | 4);
	OUT_RELOC_PIXMAP(pPix, I915_GEM_DOMAIN_SAMPLER, 0, TM0S0_USE_FENCE);
	OUT_BATCH(((pPix->drawable.height - 1) << TM0S1_HEIGHT_SHIFT) |
		  ((pPix->drawable.width - 1) << TM0S1_WIDTH_SHIFT) | format);
	OUT_BATCH((pitch/4 - 1) << TM0S2_PITCH_SHIFT | TM0S2_MAP_2D);
	OUT_BATCH(filter);
	OUT_BATCH(0); /* default color */
	OUT_BATCH(_3DSTATE_MAP_COORD_SET_CMD | TEXCOORD_SET(unit) |
		  ENABLE_TEXCOORD_PARAMS | TEXCOORDS_ARE_NORMAL |
		  TEXCOORDTYPE_CARTESIAN | ENABLE_ADDR_V_CNTL |
		  TEXCOORD_ADDR_V_MODE(wrap_mode) |
		  ENABLE_ADDR_U_CNTL | TEXCOORD_ADDR_U_MODE(wrap_mode));
	/* map texel stream */
	OUT_BATCH(_3DSTATE_MAP_COORD_SETBIND_CMD);
	if (unit == 0)
	    OUT_BATCH(TEXBIND_SET0(TEXCOORDSRC_VTXSET_0) |
		      TEXBIND_SET1(TEXCOORDSRC_KEEP) |
		      TEXBIND_SET2(TEXCOORDSRC_KEEP) |
		      TEXBIND_SET3(TEXCOORDSRC_KEEP));
	else
	    OUT_BATCH(TEXBIND_SET0(TEXCOORDSRC_VTXSET_0) |
		      TEXBIND_SET1(TEXCOORDSRC_VTXSET_1) |
		      TEXBIND_SET2(TEXCOORDSRC_KEEP) |
		      TEXBIND_SET3(TEXCOORDSRC_KEEP));
	OUT_BATCH(_3DSTATE_MAP_TEX_STREAM_CMD | (unit << 16) |
		  DISABLE_TEX_STREAM_BUMP |
		  ENABLE_TEX_STREAM_COORD_SET |
		  TEX_STREAM_COORD_SET(unit) |
		  ENABLE_TEX_STREAM_MAP_IDX |
		  TEX_STREAM_MAP_IDX(unit));
	ADVANCE_BATCH();
     }
d319 14
a332 4
#ifdef I830DEBUG
    ErrorF("try to sync to show any errors...");
    I830Sync(pScrn);
#endif
d334 52
a385 1
    return TRUE;
d389 2
a390 2
i830_check_composite(int op, PicturePtr pSrcPicture, PicturePtr pMaskPicture,
		     PicturePtr pDstPicture)
d392 2
a393 2
    ScrnInfoPtr pScrn = xf86Screens[pDstPicture->pDrawable->pScreen->myNum];
    uint32_t tmp1;
d395 6
a400 20
    /* Check for unsupported compositing operations. */
    if (op >= sizeof(i830_blend_op) / sizeof(i830_blend_op[0]))
        I830FALLBACK("Unsupported Composite op 0x%x\n", op);

    if (pMaskPicture != NULL && pMaskPicture->componentAlpha &&
	    PICT_FORMAT_RGB(pMaskPicture->format)) {
        /* Check if it's component alpha that relies on a source alpha and on
         * the source value.  We can only get one of those into the single
         * source value that we get to blend with.
         */
        if (i830_blend_op[op].src_alpha &&
            (i830_blend_op[op].src_blend != BLENDFACTOR_ZERO))
            	I830FALLBACK("Component alpha not supported with source "
			     "alpha and source value blending.\n");
    }

    if (!i830_check_composite_texture(pSrcPicture, 0))
        I830FALLBACK("Check Src picture texture\n");
    if (pMaskPicture != NULL && !i830_check_composite_texture(pMaskPicture, 1))
        I830FALLBACK("Check Mask picture texture\n");
d402 14
a415 2
    if (!i830_get_dest_format(pDstPicture, &tmp1))
	I830FALLBACK("Get Color buffer format\n");
d417 16
a432 1
    return TRUE;
d436 31
a466 47
i830_prepare_composite(int op, PicturePtr pSrcPicture,
		       PicturePtr pMaskPicture, PicturePtr pDstPicture,
		       PixmapPtr pSrc, PixmapPtr pMask, PixmapPtr pDst)
{
    ScrnInfoPtr pScrn = xf86Screens[pSrcPicture->pDrawable->pScreen->myNum];
    I830Ptr pI830 = I830PTR(pScrn);
    uint32_t dst_format, dst_pitch;
    Bool is_affine_src, is_affine_mask;
    Bool is_nearest = FALSE;

    i830_exa_check_pitch_3d(pSrc);
    if (pMask)
	i830_exa_check_pitch_3d(pMask);
    i830_exa_check_pitch_3d(pDst);

    IntelEmitInvarientState(pScrn);
    pI830->last_3d = LAST_3D_RENDER;

    if (!i830_get_dest_format(pDstPicture, &dst_format))
	return FALSE;
    dst_pitch = intel_get_pixmap_pitch(pDst);

    if (!i830_texture_setup(pSrcPicture, pSrc, 0))
	I830FALLBACK("fail to setup src texture\n");
    if (pSrcPicture->filter == PictFilterNearest)
	is_nearest = TRUE;
    if (pMask != NULL) {
	if (!i830_texture_setup(pMaskPicture, pMask, 1))
	    I830FALLBACK("fail to setup mask texture\n");
	if (pMaskPicture->filter == PictFilterNearest)
	    is_nearest = TRUE;
    } else {
	pI830->transform[1] = NULL;
	pI830->scale_units[1][0] = -1;
	pI830->scale_units[1][1] = -1;
    }

    is_affine_src = i830_transform_is_affine (pI830->transform[0]);
    is_affine_mask = i830_transform_is_affine (pI830->transform[1]);

    if (is_nearest)
	pI830->coord_adjust = -0.125;
    else
	pI830->coord_adjust = 0;

    if (!is_affine_src || !is_affine_mask)
	I830FALLBACK("non-affine transform unsupported on 8xx hardware\n");
d468 2
a469 2
    {
	uint32_t cblend, ablend, blendctl, vf2;
d471 8
a478 1
	BEGIN_BATCH(30);
d480 68
a547 6
	/* color buffer */
	OUT_BATCH(_3DSTATE_BUF_INFO_CMD);
	OUT_BATCH(BUF_3D_ID_COLOR_BACK| BUF_3D_USE_FENCE |
		  BUF_3D_PITCH(dst_pitch));
	OUT_RELOC_PIXMAP(pDst, I915_GEM_DOMAIN_RENDER, I915_GEM_DOMAIN_RENDER, 0);
	OUT_BATCH(MI_NOOP);
d549 2
a550 2
	OUT_BATCH(_3DSTATE_DST_BUF_VARS_CMD);
	OUT_BATCH(dst_format);
d552 20
a571 3
	/* defaults */
	OUT_BATCH(_3DSTATE_DFLT_Z_CMD);
	OUT_BATCH(0);
d573 5
a577 2
	OUT_BATCH(_3DSTATE_DFLT_DIFFUSE_CMD);
	OUT_BATCH(0);
d579 2
a580 2
	OUT_BATCH(_3DSTATE_DFLT_SPEC_CMD);
	OUT_BATCH(0);
d584 9
a592 9
	OUT_BATCH(0); /* ymin, xmin */
	OUT_BATCH(DRAW_YMAX(pDst->drawable.height - 1) |
		  DRAW_XMAX(pDst->drawable.width - 1));
	OUT_BATCH(0); /* yorig, xorig */

	OUT_BATCH(_3DSTATE_LOAD_STATE_IMMEDIATE_1 | I1_LOAD_S(2) |
		  I1_LOAD_S(3) | 1);
	if (pMask)
	    vf2 = 2 << 12; /* 2 texture coord sets */
d594 2
a595 2
	    vf2 = 1 << 12;
	OUT_BATCH(vf2); /* TEXCOORDFMT_2D */
d597 2
d600 1
a600 66
	/* If component alpha is active in the mask and the blend operation
	 * uses the source alpha, then we know we don't need the source
	 * value (otherwise we would have hit a fallback earlier), so we
	 * provide the source alpha (src.A * mask.X) as output color.
	 * Conversely, if CA is set and we don't need the source alpha, then
	 * we produce the source value (src.X * mask.X) and the source alpha
	 * is unused..  Otherwise, we provide the non-CA source value
	 * (src.X * mask.A).
	 *
	 * The PICT_FORMAT_RGB(pict) == 0 fixups are not needed on 855+'s a8
	 * pictures, but we need to implement it for 830/845 and there's no
	 * harm done in leaving it in.
	 */
	cblend = TB0C_LAST_STAGE | TB0C_RESULT_SCALE_1X | TB0C_OP_MODULE |
		 TB0C_OUTPUT_WRITE_CURRENT;
	ablend = TB0A_RESULT_SCALE_1X | TB0A_OP_MODULE |
		 TB0A_OUTPUT_WRITE_CURRENT;

	/* Get the source picture's channels into TBx_ARG1 */
	if (pMaskPicture != NULL &&
	    pMaskPicture->componentAlpha &&
	    PICT_FORMAT_RGB(pMaskPicture->format) &&
	    i830_blend_op[op].src_alpha)
	{
	    /* Producing source alpha value, so the first set of channels
	     * is src.A instead of src.X
	     */
	    if (PICT_FORMAT_A(pSrcPicture->format) != 0) {
		ablend |= TB0A_ARG1_SEL_TEXEL0;
		cblend |= TB0C_ARG1_SEL_TEXEL0 | TB0C_ARG1_REPLICATE_ALPHA;
	    } else {
		ablend |= TB0A_ARG1_SEL_ONE;
		cblend |= TB0C_ARG1_SEL_ONE;
	    }
	} else {
	    if (PICT_FORMAT_A(pSrcPicture->format) != 0) {
		ablend |= TB0A_ARG1_SEL_TEXEL0;
	    } else {
		ablend |= TB0A_ARG1_SEL_ONE;
	    }
	    if (PICT_FORMAT_RGB(pSrcPicture->format) != 0)
		cblend |= TB0C_ARG1_SEL_TEXEL0;
	    else
		cblend |= TB0C_ARG1_SEL_ONE | TB0C_ARG1_INVERT; /* 0.0 */
	}

	if (pMask) {
	    if (pMaskPicture->componentAlpha &&
		PICT_FORMAT_RGB(pMaskPicture->format))
	    {
		cblend |= TB0C_ARG2_SEL_TEXEL1;
	    } else {
		if (PICT_FORMAT_A(pMaskPicture->format) != 0)
		    cblend |= TB0C_ARG2_SEL_TEXEL1 |
			TB0C_ARG2_REPLICATE_ALPHA;
		else
		    cblend |= TB0C_ARG2_SEL_ONE;
	    }
	    if (PICT_FORMAT_A(pMaskPicture->format) != 0)
		ablend |= TB0A_ARG2_SEL_TEXEL1;
	    else
		ablend |= TB0A_ARG2_SEL_ONE;
	} else {
	    cblend |= TB0C_ARG2_SEL_ONE;
	    ablend |= TB0A_ARG2_SEL_ONE;
	}
d603 3
a605 11
		  LOAD_TEXTURE_BLEND_STAGE(0)|1);
	OUT_BATCH(cblend);
	OUT_BATCH(ablend);
	OUT_BATCH(0);

	blendctl = i830_get_blend_cntl(op, pMaskPicture, pDstPicture->format);
	OUT_BATCH(_3DSTATE_INDPT_ALPHA_BLEND_CMD | DISABLE_INDPT_ALPHA_BLEND);
	OUT_BATCH(MI_NOOP);
	OUT_BATCH(_3DSTATE_LOAD_STATE_IMMEDIATE_1 | I1_LOAD_S(8) | 0);
	OUT_BATCH(S8_ENABLE_COLOR_BLEND | S8_BLENDFUNC_ADD | blendctl |
		  S8_ENABLE_COLOR_BUFFER_WRITE);
d614 15
a628 2
		  DISABLE_DITHER | ENABLE_COLOR_WRITE |
		  DISABLE_DEPTH_WRITE);
a629 1
    }
d631 171
a801 4
#ifdef I830DEBUG
    Error("try to sync to show any errors...");
    I830Sync(pScrn);
#endif
d803 16
a818 1
    return TRUE;
a822 2
 *
 * This function is shared between i830 and i915 generation code.
d825 1
a825 1
i830_composite(PixmapPtr pDst, int srcX, int srcY, int maskX, int maskY,
d828 20
a847 145
    ScrnInfoPtr pScrn = xf86Screens[pDst->drawable.pScreen->myNum];
    I830Ptr pI830 = I830PTR(pScrn);
    Bool has_mask;
    Bool is_affine_src, is_affine_mask;
    int per_vertex, num_floats;
    float src_x[3], src_y[3], src_w[3], mask_x[3], mask_y[3], mask_w[3];

    is_affine_src = i830_transform_is_affine (pI830->transform[0]);
    is_affine_mask = i830_transform_is_affine (pI830->transform[1]);

    if (pI830->scale_units[1][0] == -1 || pI830->scale_units[1][1] == -1) {
	has_mask = FALSE;
    } else {
	has_mask = TRUE;
    }

    per_vertex = 2; /* dest x/y */
    if (is_affine_src)
    {
	if (!i830_get_transformed_coordinates(srcX, srcY,
					      pI830->transform[0],
					      &src_x[0], &src_y[0]))
	    return;
	if (!i830_get_transformed_coordinates(srcX, srcY + h,
					      pI830->transform[0],
					      &src_x[1], &src_y[1]))
	    return;
	if (!i830_get_transformed_coordinates(srcX + w, srcY + h,
					      pI830->transform[0],
					      &src_x[2], &src_y[2]))
	    return;
	per_vertex += 2;    /* src x/y */
    } else {
	if (!i830_get_transformed_coordinates_3d(srcX, srcY,
						 pI830->transform[0],
						 &src_x[0], &src_y[0],
						 &src_w[0]))
	    return;
	if (!i830_get_transformed_coordinates_3d(srcX, srcY + h,
						 pI830->transform[0],
						 &src_x[1], &src_y[1],
						 &src_w[1]))
	    return;
	if (!i830_get_transformed_coordinates_3d(srcX + w, srcY + h,
						 pI830->transform[0],
						 &src_x[2], &src_y[2],
						 &src_w[2]))
	    return;
	per_vertex += 4;    /* src x/y/z/w */
    }
    if (has_mask) {
	if (is_affine_mask) {
	    if (!i830_get_transformed_coordinates(maskX, maskY,
						  pI830->transform[1],
						  &mask_x[0], &mask_y[0]))
		return;
	    if (!i830_get_transformed_coordinates(maskX, maskY + h,
						  pI830->transform[1],
						  &mask_x[1], &mask_y[1]))
		return;
	    if (!i830_get_transformed_coordinates(maskX + w, maskY + h,
						  pI830->transform[1],
						  &mask_x[2], &mask_y[2]))
		return;
	    per_vertex += 2;	/* mask x/y */
	} else {
	    if (!i830_get_transformed_coordinates_3d(maskX, maskY,
						     pI830->transform[1],
						     &mask_x[0], &mask_y[0],
						     &mask_w[0]))
		return;
	    if (!i830_get_transformed_coordinates_3d(maskX, maskY + h,
						     pI830->transform[1],
						     &mask_x[1], &mask_y[1],
						     &mask_w[1]))
		return;
	    if (!i830_get_transformed_coordinates_3d(maskX + w, maskY + h,
						     pI830->transform[1],
						     &mask_x[2], &mask_y[2],
						     &mask_w[2]))
		return;
	    per_vertex += 4;	/* mask x/y/z/w */
	}
    }

    num_floats = 3 * per_vertex;
    BEGIN_BATCH(6 + num_floats);

    OUT_BATCH(MI_NOOP);
    OUT_BATCH(MI_NOOP);
    OUT_BATCH(MI_NOOP);
    OUT_BATCH(MI_NOOP);
    OUT_BATCH(MI_NOOP);

    OUT_BATCH(PRIM3D_INLINE | PRIM3D_RECTLIST | (num_floats-1));
    OUT_BATCH_F(pI830->coord_adjust + dstX + w);
    OUT_BATCH_F(pI830->coord_adjust + dstY + h);
    OUT_BATCH_F(src_x[2] / pI830->scale_units[0][0]);
    OUT_BATCH_F(src_y[2] / pI830->scale_units[0][1]);
    if (!is_affine_src) {
	OUT_BATCH_F(0.0);
	OUT_BATCH_F(src_w[2]);
    }
    if (has_mask) {
	OUT_BATCH_F(mask_x[2] / pI830->scale_units[1][0]);
	OUT_BATCH_F(mask_y[2] / pI830->scale_units[1][1]);
	if (!is_affine_mask) {
	    OUT_BATCH_F(0.0);
	    OUT_BATCH_F(mask_w[2]);
	}
    }

    OUT_BATCH_F(pI830->coord_adjust + dstX);
    OUT_BATCH_F(pI830->coord_adjust + dstY + h);
    OUT_BATCH_F(src_x[1] / pI830->scale_units[0][0]);
    OUT_BATCH_F(src_y[1] / pI830->scale_units[0][1]);
    if (!is_affine_src) {
	OUT_BATCH_F(0.0);
	OUT_BATCH_F(src_w[1]);
    }
    if (has_mask) {
	OUT_BATCH_F(mask_x[1] / pI830->scale_units[1][0]);
	OUT_BATCH_F(mask_y[1] / pI830->scale_units[1][1]);
	if (!is_affine_mask) {
	    OUT_BATCH_F(0.0);
	    OUT_BATCH_F(mask_w[1]);
	}
    }

    OUT_BATCH_F(pI830->coord_adjust + dstX);
    OUT_BATCH_F(pI830->coord_adjust + dstY);
    OUT_BATCH_F(src_x[0] / pI830->scale_units[0][0]);
    OUT_BATCH_F(src_y[0] / pI830->scale_units[0][1]);
    if (!is_affine_src) {
	OUT_BATCH_F(0.0);
	OUT_BATCH_F(src_w[0]);
    }
    if (has_mask) {
	OUT_BATCH_F(mask_x[0] / pI830->scale_units[1][0]);
	OUT_BATCH_F(mask_y[0] / pI830->scale_units[1][1]);
	if (!is_affine_mask) {
	    OUT_BATCH_F(0.0);
	    OUT_BATCH_F(mask_w[0]);
	}
    }
d849 1
a849 1
    ADVANCE_BATCH();
@


1.2
log
@Update to xf86-video-intel 2.3.1. Tested by many.
@
text
@a36 17
#ifdef I830DEBUG
#define DEBUG_I830FALLBACK 1
#endif

#ifdef DEBUG_I830FALLBACK
#define I830FALLBACK(s, arg...)				\
do {							\
	DPRINTF(PFX, "EXA fallback: " s "\n", ##arg); 	\
	return FALSE;					\
} while(0)
#else
#define I830FALLBACK(s, arg...) 			\
do { 							\
	return FALSE;					\
} while(0)
#endif

d146 2
d215 1
d233 2
a234 2
    if (pPict->repeat && pPict->repeatType != RepeatNormal)
	I830FALLBACK("unsupport repeat type\n");
d264 2
a265 2
    uint32_t format, offset, pitch, filter;
    uint32_t wrap_mode = TEXCOORDMODE_CLAMP_BORDER;
a266 1
    offset = intel_get_pixmap_offset(pPix);
d274 5
a278 1
    if (pPict->repeat)
d280 10
d316 1
a316 1
	OUT_BATCH((offset & TM0S0_ADDRESS_MASK) | TM0S0_USE_FENCE);
d360 1
d397 1
a397 1
    uint32_t dst_format, dst_offset, dst_pitch;
d407 1
a407 1
    *pI830->last_3d = LAST_3D_RENDER;
a410 1
    dst_offset = intel_get_pixmap_offset(pDst);
d448 1
a448 1
	OUT_BATCH(BUF_3D_ADDR(dst_offset));
a735 11
}

/**
 * Do any cleanup from the Composite operation.
 *
 * This is shared between i830 through i965.
 */
void
i830_done_composite(PixmapPtr pDst)
{
    /* NO-OP */
@


1.1
log
@Initial revision
@
text
@d57 2
a58 2
    CARD32 src_blend;
    CARD32 dst_blend;
d63 1
a63 1
    CARD32 card_fmt;
d146 4
d152 1
a152 1
    {PICT_x8r8g8b8, MT_32BIT_XRGB8888 },
d154 1
a154 1
    {PICT_x8b8g8r8, MT_32BIT_XBGR8888 },
d161 1
a161 1
static Bool i830_get_dest_format(PicturePtr pDstPicture, CARD32 *dst_format)
d193 2
a194 1
static CARD32 i830_get_blend_cntl(int op, PicturePtr pMask, CARD32 dst_format)
d196 1
a196 1
    CARD32 sblend, dblend;
a229 2
    ScrnInfoPtr pScrn = xf86Screens[pPict->pDrawable->pScreen->myNum];
    I830Ptr pI830 = I830PTR(pScrn);
d234 1
a234 1
    if ((w > 0x7ff) || (h > 0x7ff))
a246 7
    if (IS_I830(pI830) || IS_845G(pI830)) {
	if (pPict->format == PICT_x8r8g8b8 || 
		pPict->format == PICT_x8b8g8r8 || 
		pPict->format == PICT_a8)
	    I830FALLBACK("830/845G don't support a8, x8r8g8b8, x8b8g8r8\n");
    }

d259 1
a259 1
static CARD32
d278 2
a279 2
    CARD32 format, offset, pitch, filter;
    CARD32 wrap_mode = TEXCOORDMODE_CLAMP_BORDER;
d315 13
a327 13
	BEGIN_LP_RING(10);
	OUT_RING(_3DSTATE_LOAD_STATE_IMMEDIATE_2 | LOAD_TEXTURE_MAP(unit) | 4);
	OUT_RING((offset & TM0S0_ADDRESS_MASK) | TM0S0_USE_FENCE); 
	OUT_RING(((pPix->drawable.height - 1) << TM0S1_HEIGHT_SHIFT) |
		((pPix->drawable.width - 1) << TM0S1_WIDTH_SHIFT) | format);
	OUT_RING((pitch/4 - 1) << TM0S2_PITCH_SHIFT | TM0S2_MAP_2D);
	OUT_RING(filter);
	OUT_RING(0); /* default color */
	OUT_RING(_3DSTATE_MAP_COORD_SET_CMD | TEXCOORD_SET(unit) |
		 ENABLE_TEXCOORD_PARAMS | TEXCOORDS_ARE_NORMAL |
		 TEXCOORDTYPE_CARTESIAN | ENABLE_ADDR_V_CNTL |
		 TEXCOORD_ADDR_V_MODE(wrap_mode) |
		 ENABLE_ADDR_U_CNTL | TEXCOORD_ADDR_U_MODE(wrap_mode));
d329 1
a329 1
	OUT_RING(_3DSTATE_MAP_COORD_SETBIND_CMD);
d331 4
a334 4
	    OUT_RING(TEXBIND_SET0(TEXCOORDSRC_VTXSET_0) |
		    TEXBIND_SET1(TEXCOORDSRC_KEEP) |
		    TEXBIND_SET2(TEXCOORDSRC_KEEP) |
		    TEXBIND_SET3(TEXCOORDSRC_KEEP));
d336 11
a346 11
	    OUT_RING(TEXBIND_SET0(TEXCOORDSRC_VTXSET_0) |
		    TEXBIND_SET1(TEXCOORDSRC_VTXSET_1) |
		    TEXBIND_SET2(TEXCOORDSRC_KEEP) |
		    TEXBIND_SET3(TEXCOORDSRC_KEEP));
	OUT_RING(_3DSTATE_MAP_TEX_STREAM_CMD | (unit << 16) |
		DISABLE_TEX_STREAM_BUMP | 
		ENABLE_TEX_STREAM_COORD_SET |
		TEX_STREAM_COORD_SET(unit) |
		ENABLE_TEX_STREAM_MAP_IDX |
		TEX_STREAM_MAP_IDX(unit));
	ADVANCE_LP_RING();
d361 1
a361 1
    CARD32 tmp1;
d397 8
a404 1
    CARD32 dst_format, dst_offset, dst_pitch;
d409 2
a410 1
    i830_get_dest_format(pDstPicture, &dst_format);
d416 2
d421 2
d429 11
d441 1
a441 1
	CARD32 cblend, ablend, blendctl, vf2;
d443 1
a443 1
	BEGIN_LP_RING(30);
d446 5
a450 5
	OUT_RING(_3DSTATE_BUF_INFO_CMD);
	OUT_RING(BUF_3D_ID_COLOR_BACK| BUF_3D_USE_FENCE |
			BUF_3D_PITCH(dst_pitch));
	OUT_RING(BUF_3D_ADDR(dst_offset));
	OUT_RING(MI_NOOP);
d452 2
a453 2
	OUT_RING(_3DSTATE_DST_BUF_VARS_CMD);
	OUT_RING(dst_format);
d456 2
a457 2
	OUT_RING(_3DSTATE_DFLT_Z_CMD);
	OUT_RING(0);
d459 2
a460 2
	OUT_RING(_3DSTATE_DFLT_DIFFUSE_CMD);
	OUT_RING(0);
d462 2
a463 2
	OUT_RING(_3DSTATE_DFLT_SPEC_CMD);
	OUT_RING(0);
d465 6
a470 6
	OUT_RING(_3DSTATE_DRAW_RECT_CMD);
	OUT_RING(0);
	OUT_RING(0); /* ymin, xmin */
	OUT_RING(DRAW_YMAX(pDst->drawable.height - 1) |
		DRAW_XMAX(pDst->drawable.width - 1));
	OUT_RING(0); /* yorig, xorig */
d472 2
a473 2
	OUT_RING(_3DSTATE_LOAD_STATE_IMMEDIATE_1 | I1_LOAD_S(2) | 
		I1_LOAD_S(3) | 1);
d478 2
a479 2
	OUT_RING(vf2); /* TEXCOORDFMT_2D */
	OUT_RING(S3_CULLMODE_NONE | S3_VERTEXHAS_XY);
d481 12
a492 3
	/* We use two pipes for color and alpha, and do (src In mask)
	   in one stage. Arg1 is from src pict, and arg2 is from mask pict.
	   Be sure to force 1.0 when src or mask pict has no alpha channel.
d499 16
a514 3
	if (PICT_FORMAT_A(pSrcPicture->format) != 0) {
	    ablend |= TB0A_ARG1_SEL_TEXEL0;
	    cblend |= TB0C_ARG1_SEL_TEXEL0;
d516 7
a522 5
	    ablend |= TB0A_ARG1_SEL_ONE;
	    if (pMask && pMaskPicture->componentAlpha 
		    && PICT_FORMAT_RGB(pMaskPicture->format)
		    && i830_blend_op[op].src_alpha)
		cblend |= TB0C_ARG1_SEL_ONE;
d524 1
a524 1
		cblend |= TB0C_ARG1_SEL_TEXEL0;
d528 4
a531 7
	    if (pMaskPicture->componentAlpha && 
		    PICT_FORMAT_RGB(pMaskPicture->format)) {
		if (i830_blend_op[op].src_alpha)
		    cblend |= (TB0C_ARG2_SEL_TEXEL1 | 
			    TB0C_ARG1_REPLICATE_ALPHA);
		else 
		    cblend |= TB0C_ARG2_SEL_TEXEL1;
d534 2
a535 2
		    cblend |= (TB0C_ARG2_SEL_TEXEL1 | 
			    TB0C_ARG2_REPLICATE_ALPHA);
d548 5
a552 5
	OUT_RING(_3DSTATE_LOAD_STATE_IMMEDIATE_2 |
		 LOAD_TEXTURE_BLEND_STAGE(0)|1);
	OUT_RING(cblend);
	OUT_RING(ablend);
	OUT_RING(0);
d555 10
a564 10
	OUT_RING(_3DSTATE_INDPT_ALPHA_BLEND_CMD | DISABLE_INDPT_ALPHA_BLEND);
	OUT_RING(MI_NOOP);
	OUT_RING(_3DSTATE_LOAD_STATE_IMMEDIATE_1 | I1_LOAD_S(8) | 0);
	OUT_RING(S8_ENABLE_COLOR_BLEND | S8_BLENDFUNC_ADD | blendctl | 
		 S8_ENABLE_COLOR_BUFFER_WRITE);

	OUT_RING(_3DSTATE_ENABLES_1_CMD | DISABLE_LOGIC_OP | 
		DISABLE_STENCIL_TEST | DISABLE_DEPTH_BIAS | 
		DISABLE_SPEC_ADD | DISABLE_FOG | DISABLE_ALPHA_TEST | 
		ENABLE_COLOR_BLEND | DISABLE_DEPTH_TEST);
d566 5
a570 5
	OUT_RING(_3DSTATE_ENABLES_2_CMD | ENABLE_COLOR_MASK |
		DISABLE_STENCIL_WRITE | ENABLE_TEX_CACHE |
		DISABLE_DITHER | ENABLE_COLOR_WRITE |
		DISABLE_DEPTH_WRITE);
	ADVANCE_LP_RING();
a580 1

d593 3
a595 1
    float src_x[3], src_y[3], mask_x[3], mask_y[3];
d597 2
a598 9
    i830_get_transformed_coordinates(srcX, srcY,
				     pI830->transform[0],
				     &src_x[0], &src_y[0]);
    i830_get_transformed_coordinates(srcX, srcY + h,
				     pI830->transform[0],
				     &src_x[1], &src_y[1]);
    i830_get_transformed_coordinates(srcX + w, srcY + h,
				     pI830->transform[0],
				     &src_x[2], &src_y[2]);
a603 9
	i830_get_transformed_coordinates(maskX, maskY,
					 pI830->transform[1],
					 &mask_x[0], &mask_y[0]);
	i830_get_transformed_coordinates(maskX, maskY + h,
					 pI830->transform[1],
					 &mask_x[1], &mask_y[1]);
	i830_get_transformed_coordinates(maskX + w, maskY + h,
					 pI830->transform[1],
					 &mask_x[2], &mask_y[2]);
d606 2
d609 65
a673 6
	int vertex_count;

	if (has_mask)
		vertex_count = 3*6;
	else
		vertex_count = 3*4;
d675 2
a676 1
	BEGIN_LP_RING(6+vertex_count);
d678 21
a698 15
	OUT_RING(MI_NOOP);
	OUT_RING(MI_NOOP);
	OUT_RING(MI_NOOP);
	OUT_RING(MI_NOOP);
	OUT_RING(MI_NOOP);

	OUT_RING(PRIM3D_INLINE | PRIM3D_RECTLIST | (vertex_count-1));

	OUT_RING_F(-0.125 + dstX + w);
	OUT_RING_F(-0.125 + dstY + h);
	OUT_RING_F(src_x[2] / pI830->scale_units[0][0]);
	OUT_RING_F(src_y[2] / pI830->scale_units[0][1]);
	if (has_mask) {
	    OUT_RING_F(mask_x[2] / pI830->scale_units[1][0]);
	    OUT_RING_F(mask_y[2] / pI830->scale_units[1][1]);
d700 1
d702 14
a715 7
	OUT_RING_F(-0.125 + dstX);
	OUT_RING_F(-0.125 + dstY + h);
	OUT_RING_F(src_x[1] / pI830->scale_units[0][0]);
	OUT_RING_F(src_y[1] / pI830->scale_units[0][1]);
	if (has_mask) {
	    OUT_RING_F(mask_x[1] / pI830->scale_units[1][0]);
	    OUT_RING_F(mask_y[1] / pI830->scale_units[1][1]);
d717 1
d719 14
a732 7
	OUT_RING_F(-0.125 + dstX);
	OUT_RING_F(-0.125 + dstY);
	OUT_RING_F(src_x[0] / pI830->scale_units[0][0]);
	OUT_RING_F(src_y[0] / pI830->scale_units[0][1]);
	if (has_mask) {
	    OUT_RING_F(mask_x[0] / pI830->scale_units[1][0]);
	    OUT_RING_F(mask_y[0] / pI830->scale_units[1][1]);
a733 1
	ADVANCE_LP_RING();
d735 2
@


1.1.1.1
log
@xf86-video-intel 2.2.0
@
text
@@
