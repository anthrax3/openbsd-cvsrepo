head	1.8;
access;
symbols
	OPENBSD_5_3:1.7.0.2
	OPENBSD_5_3_BASE:1.7
	OPENBSD_5_2:1.6.0.4
	OPENBSD_5_2_BASE:1.6
	OPENBSD_5_1_BASE:1.6
	OPENBSD_5_1:1.6.0.2
	OPENBSD_5_0:1.4.0.6
	OPENBSD_5_0_BASE:1.4
	OPENBSD_4_9:1.4.0.2
	OPENBSD_4_9_BASE:1.4
	OPENBSD_4_8:1.4.0.4
	OPENBSD_4_8_BASE:1.4
	OPENBSD_4_7:1.2.0.4
	OPENBSD_4_7_BASE:1.2
	OPENBSD_4_6:1.2.0.2
	OPENBSD_4_6_BASE:1.2
	OPENBSD_4_5:1.1.0.2
	OPENBSD_4_5_BASE:1.1;
locks; strict;
comment	@ * @;


1.8
date	2013.03.18.18.38.20;	author matthieu;	state dead;
branches;
next	1.7;

1.7
date	2012.10.20.03.01.40;	author jsg;	state Exp;
branches;
next	1.6;

1.6
date	2011.12.21.21.25.02;	author kettenis;	state Exp;
branches;
next	1.5;

1.5
date	2011.11.29.12.39.02;	author oga;	state Exp;
branches;
next	1.4;

1.4
date	2010.07.18.14.47.47;	author oga;	state Exp;
branches;
next	1.3;

1.3
date	2010.05.10.22.32.29;	author oga;	state Exp;
branches;
next	1.2;

1.2
date	2009.06.25.20.16.43;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2008.10.12.15.20.50;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.8
log
@Update to xf86-video-intel 2.20.19.

A recent kernel with kernel modesetting support is required.
Thanks to jsg@@ and kettenis@@ for their work.
@
text
@/*
 * Copyright Â© 2007 Intel Corporation
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice (including the next
 * paragraph) shall be included in all copies or substantial portions of the
 * Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
 * IN THE SOFTWARE.
 *
 * Authors:
 *    Eric Anholt <eric@@anholt.net>
 *
 */

#ifdef HAVE_CONFIG_H
#include "config.h"
#endif

#include "xf86.h"
#include "intel.h"
#include "xf86Modes.h"
#include "i830_display.h"
#include "i830_reg.h"
#include "X11/Xatom.h"

struct i830_hdmi_priv {
    uint32_t output_reg;

    uint32_t save_SDVO;

    Bool has_hdmi_sink;
    /* Default 0 for full RGB range 0-255, 1 is for RGB range 16-235 */
    uint32_t broadcast_rgb;
};

static Atom broadcast_atom;

static int
i830_hdmi_mode_valid(xf86OutputPtr output, DisplayModePtr mode)
{
    if (mode->Clock > 165000)
	return MODE_CLOCK_HIGH;

    if (mode->Clock < 20000)
	return MODE_CLOCK_LOW;

    return MODE_OK;
}

static Bool
i830_hdmi_mode_fixup(xf86OutputPtr output, DisplayModePtr mode,
		     DisplayModePtr adjusted_mode)
{
    /* The HDMI output doesn't need the pixel multiplication that SDVO does,
     * so no fixup.
     */
    return TRUE;
}

static void
i830_hdmi_mode_set(xf86OutputPtr output, DisplayModePtr mode,
		   DisplayModePtr adjusted_mode)
{
    ScrnInfoPtr scrn = output->scrn;
    I830OutputPrivatePtr intel_output = output->driver_private;
    struct i830_hdmi_priv *dev_priv = intel_output->dev_priv;
    intel_screen_private *intel = intel_get_screen_private(scrn);
    xf86CrtcPtr crtc = output->crtc;
    I830CrtcPrivatePtr intel_crtc = crtc->driver_private;
    uint32_t sdvox;

    sdvox = SDVO_ENCODING_HDMI |
	SDVO_BORDER_ENABLE |
	SDVO_VSYNC_ACTIVE_HIGH |
	SDVO_HSYNC_ACTIVE_HIGH;

    /* Required on CPT */
    if (dev_priv->has_hdmi_sink && HAS_PCH_CPT(intel))
	    sdvox |= HDMI_MODE_SELECT;

    if (dev_priv->has_hdmi_sink)
	    sdvox |= SDVO_AUDIO_ENABLE;

    if (HAS_PCH_CPT(intel))
	    sdvox |= PORT_TRANS_SEL_CPT(intel_crtc->pipe);
    else if (intel_crtc->pipe == 1)
	    sdvox |= SDVO_PIPE_B_SELECT;

    OUTREG(dev_priv->output_reg, sdvox);
    POSTING_READ(dev_priv->output_reg);
}

static void
i830_hdmi_dpms(xf86OutputPtr output, int mode)
{
    ScrnInfoPtr scrn = output->scrn;
    I830OutputPrivatePtr intel_output = output->driver_private;
    struct i830_hdmi_priv *dev_priv = intel_output->dev_priv;
    intel_screen_private *intel = intel_get_screen_private(scrn);
    uint32_t  temp;

    if (mode == DPMSModeOff) {
	temp = INREG(dev_priv->output_reg);
	OUTREG(dev_priv->output_reg, temp & ~SDVO_ENABLE);
    } else {
	temp = INREG(dev_priv->output_reg);
	OUTREG(dev_priv->output_reg, temp | SDVO_ENABLE);
    }
}

static void
i830_hdmi_save(xf86OutputPtr output)
{
    ScrnInfoPtr scrn = output->scrn;
    I830OutputPrivatePtr intel_output = output->driver_private;
    struct i830_hdmi_priv *dev_priv = intel_output->dev_priv;
    intel_screen_private *intel = intel_get_screen_private(scrn);

    dev_priv->save_SDVO = INREG(dev_priv->output_reg);
}

static void
i830_hdmi_restore(xf86OutputPtr output)
{
    ScrnInfoPtr scrn = output->scrn;
    I830OutputPrivatePtr intel_output = output->driver_private;
    struct i830_hdmi_priv *dev_priv = intel_output->dev_priv;
    intel_screen_private *intel = intel_get_screen_private(scrn);

    OUTREG(dev_priv->output_reg, dev_priv->save_SDVO);
}

static xf86OutputStatus
ironlake_hdmi_detect(xf86OutputPtr output)
{
    DisplayModePtr modes;
    xf86OutputStatus status;

    modes = i830_ddc_get_modes(output);

    if (modes == NULL)
	status = XF86OutputStatusDisconnected;
    else
	status = XF86OutputStatusConnected;

    return status;
}

/**
 * Uses CRT_HOTPLUG_EN and CRT_HOTPLUG_STAT to detect HDMI connection.
 *
 * \return TRUE if HDMI port is connected.
 * \return FALSE if HDMI port is disconnected.
 */
static xf86OutputStatus
i830_hdmi_detect(xf86OutputPtr output)
{
    ScrnInfoPtr	scrn = output->scrn;
    I830OutputPrivatePtr intel_output = output->driver_private;
    struct i830_hdmi_priv *dev_priv = intel_output->dev_priv;
    intel_screen_private *intel = intel_get_screen_private(scrn);
    uint32_t temp, bit;
    xf86OutputStatus status;
    xf86MonPtr edid_mon;

    dev_priv->has_hdmi_sink = FALSE;

    if (HAS_PCH_SPLIT(intel))
	return ironlake_hdmi_detect(output);

    /* For G4X desktop chip, PEG_BAND_GAP_DATA 3:0 must first be written 0xd.
     * Failure to do so will result in spurious interrupts being
     * generated on the port when a cable is not attached.
     */
    if (IS_G4X(intel) && !IS_GM45(intel)) {
	temp = INREG(PEG_BAND_GAP_DATA);
	OUTREG(PEG_BAND_GAP_DATA, (temp & ~0xf) | 0xd);
    }

    temp = INREG(PORT_HOTPLUG_EN);

    switch (dev_priv->output_reg) {
    case SDVOB:
	temp |= HDMIB_HOTPLUG_INT_EN;
	break;
    case SDVOC:
	temp |= HDMIC_HOTPLUG_INT_EN;
	break;
    default:
	return XF86OutputStatusUnknown;
    }

    OUTREG(PORT_HOTPLUG_EN, temp);

    POSTING_READ(PORT_HOTPLUG_EN);

    i830WaitForVblank(scrn);
    switch (dev_priv->output_reg) {
    case SDVOB:
	bit = HDMIB_HOTPLUG_INT_STATUS;
	break;
    case SDVOC:
	bit = HDMIC_HOTPLUG_INT_STATUS;
	break;
    default:
	return XF86OutputStatusUnknown;
    }

    if ((INREG(PORT_HOTPLUG_STAT) & bit) != 0)
	status = XF86OutputStatusConnected;
    else
	return XF86OutputStatusDisconnected;

    edid_mon = xf86OutputGetEDID (output, intel_output->pDDCBus);
    if (!edid_mon || !DIGITAL(edid_mon->features.input_type))
	status = XF86OutputStatusDisconnected;

    if (xf86LoaderCheckSymbol("xf86MonitorIsHDMI") &&
	    xf86MonitorIsHDMI(edid_mon))
	dev_priv->has_hdmi_sink = TRUE;

    if (intel->debug_modes)
	xf86DrvMsg(scrn->scrnIndex, X_INFO,
			"%s monitor detected on HDMI-%d\n",
			dev_priv->has_hdmi_sink ? "HDMI" : "DVI",
			(dev_priv->output_reg == SDVOB) ? 1 : 2);

    free(edid_mon);
    return status;
}

static void
i830_hdmi_destroy (xf86OutputPtr output)
{
    I830OutputPrivatePtr intel_output = output->driver_private;

    if (intel_output != NULL) {
	xf86DestroyI2CBusRec(intel_output->pDDCBus, FALSE, FALSE);
	free(intel_output);
    }
}

static void
i830_hdmi_create_resources(xf86OutputPtr output)
{
    ScrnInfoPtr                 scrn = output->scrn;
    intel_screen_private        *intel = intel_get_screen_private(scrn);
    I830OutputPrivatePtr        intel_output = output->driver_private;
    struct i830_hdmi_priv       *dev_priv = intel_output->dev_priv;
    INT32			broadcast_range[2];
    int                         err;

    /* only R G B are 8bit color mode */
    if (scrn->depth != 24 ||
        /* only 965G and G4X platform */
        !(IS_I965G(intel) || IS_G4X(intel)))
        return;

    broadcast_atom =
        MakeAtom("BROADCAST_RGB", sizeof("BROADCAST_RGB") - 1, TRUE);

    broadcast_range[0] = 0;
    broadcast_range[1] = 1;
    err = RRConfigureOutputProperty(output->randr_output,
                                    broadcast_atom,
                                    FALSE, TRUE, FALSE, 2, broadcast_range);
    if (err != 0) {
        xf86DrvMsg(scrn->scrnIndex, X_ERROR,
                   "RRConfigureOutputProperty error, %d\n", err);
        return;
    }
    /* Set the current value of the broadcast property as full range */
    dev_priv->broadcast_rgb = 0;
    err = RRChangeOutputProperty(output->randr_output,
                                 broadcast_atom,
                                 XA_INTEGER, 32, PropModeReplace,
                                 1, &dev_priv->broadcast_rgb,
                                 FALSE, TRUE);
    if (err != 0) {
        xf86DrvMsg(scrn->scrnIndex, X_ERROR,
                   "RRChangeOutputProperty error, %d\n", err);
        return;
    }
}

static Bool
i830_hdmi_set_property(xf86OutputPtr output, Atom property,
                       RRPropertyValuePtr value)
{
    ScrnInfoPtr             scrn = output->scrn;
    intel_screen_private    *intel = intel_get_screen_private(scrn);
    I830OutputPrivatePtr    intel_output = output->driver_private;
    struct i830_hdmi_priv   *dev_priv = intel_output->dev_priv;
    uint32_t temp;

    if (property == broadcast_atom) {
        uint32_t val;

        if (value->type != XA_INTEGER || value->format != 32 ||
            value->size != 1)
        {
            return FALSE;
        }

        val = *(INT32 *)value->data;
        if (val < 0 || val > 1)
        {
            return FALSE;
        }
        if (val == dev_priv->broadcast_rgb)
            return TRUE;

        temp = INREG(dev_priv->output_reg);

        if (val == 1)
            temp |= SDVO_COLOR_NOT_FULL_RANGE;
        else if (val == 0)
            temp &= ~SDVO_COLOR_NOT_FULL_RANGE;

        OUTREG(dev_priv->output_reg, temp);
        dev_priv->broadcast_rgb = val;
    }
    return TRUE;
}

static const xf86OutputFuncsRec i830_hdmi_output_funcs = {
    .create_resources = i830_hdmi_create_resources,
    .dpms = i830_hdmi_dpms,
    .save = i830_hdmi_save,
    .restore = i830_hdmi_restore,
    .mode_valid = i830_hdmi_mode_valid,
    .mode_fixup = i830_hdmi_mode_fixup,
    .prepare = i830_output_prepare,
    .mode_set = i830_hdmi_mode_set,
    .commit = i830_output_commit,
    .detect = i830_hdmi_detect,
    .get_modes = i830_ddc_get_modes,
    .set_property = i830_hdmi_set_property,
    .destroy = i830_hdmi_destroy
};

void
i830_hdmi_init(ScrnInfoPtr scrn, int output_reg)
{
    xf86OutputPtr output;
    I830OutputPrivatePtr intel_output;
    struct i830_hdmi_priv *dev_priv;
    const char *name;

    switch (output_reg) {
    case SDVOB:
	name = "HDMI-1";
	break;
    case SDVOC:
	name = "HDMI-2";
	break;
    case HDMIB:
	name = "HDMI-3";
	break;
    case HDMIC:
	name = "HDMI-4";
	break;
    case HDMID:
	name = "HDMI-5";
	break;
    }

    output = xf86OutputCreate(scrn, &i830_hdmi_output_funcs, name);
    if (!output)
	return;
    intel_output = xnfcalloc(sizeof (I830OutputPrivateRec) +
			     sizeof (struct i830_hdmi_priv), 1);
    if (intel_output == NULL) {
	xf86OutputDestroy(output);
	return;
    }
    output->driver_private = intel_output;
    output->interlaceAllowed = FALSE;
    output->doubleScanAllowed = FALSE;

    dev_priv = (struct i830_hdmi_priv *)(intel_output + 1);
    dev_priv->output_reg = output_reg;
    dev_priv->has_hdmi_sink = FALSE;

    intel_output->dev_priv = dev_priv;
    intel_output->type = I830_OUTPUT_HDMI;
    intel_output->pipe_mask = ((1 << 0) | (1 << 1));
    intel_output->clone_mask = (1 << I830_OUTPUT_HDMI);

    /* Set up the DDC bus. */
    if (output_reg == SDVOB)
	I830I2CInit(scrn, &intel_output->pDDCBus, GPIOE, "HDMIDDC_B");
    else if (output_reg == SDVOC)
	I830I2CInit(scrn, &intel_output->pDDCBus, GPIOD, "HDMIDDC_C");
    else if (output_reg == HDMIB)
	I830I2CInit(scrn, &intel_output->pDDCBus, PCH_GPIOE, "HDMIB");
    else if (output_reg == HDMIC)
	I830I2CInit(scrn, &intel_output->pDDCBus, PCH_GPIOD, "HDMIC");
    else if (output_reg == HDMID)
	I830I2CInit(scrn, &intel_output->pDDCBus, PCH_GPIOF, "HDMID");

    xf86DrvMsg(scrn->scrnIndex, X_INFO,
	       "%s output detected\n", output->name);
}
@


1.7
log
@Make the hdmi modesetting code handle multiple display pipes.
Problem noticed by by rivo nurges and blambert@@ after ivy bridge
support enabled multiple pipes for pch devices.

Fix based on what the upstream drm code does and
tested by rivo nurges, blambert@@ and sthen@@

ok kettenis@@
@
text
@@


1.6
log
@Add support for Sandy Bridge.  Not perfect yet.  Most notably 3D acceleration
is completely absent, and playing video doesn't work yet.  But support for
"normal" 2D stuff is pretty solid and it is really nice to be able to use
my laptop at the panel's native resolution and be able to suspend and resume
the machine.

tested by some
@
text
@d90 4
d97 4
a100 2
    if (intel_crtc->pipe == 1)
	sdvox |= SDVO_PIPE_B_SELECT;
@


1.5
log
@Update the intel driver to a more recent version based on more recent
upsteam code.

Backporting keeping UMS changes by me, some bugfixes from kettenis@@.

Has been in snapshots for a while, committed on request so we can be
sure what people are running. This is a prerequesite for sandybridge
support but has those chipsets disabled for now until the correct code
has been added.
@
text
@d141 1
a141 1
igdng_hdmi_detect(xf86OutputPtr output)
d175 2
a176 2
    if (IS_IGDNG(intel))
	return igdng_hdmi_detect(output);
@


1.4
log
@Update the intel driver to (mostly) a backport of 2.12.

It is missing a few commits that I have yet to verify (ones that try and
continue if we lock the gpu rendering engine and can't reset it, for
example) taht will be verified and sent out for extra testing soon.

Should contain a bunch of speedups and some correctness improvements
(though rendercheck still gives some errors that I am looking into).

This has been in snaps since the first day of c2k10, any known issues
with just this driver have (to my knowledge) been fixed since. A problem
with macbooks pointed out by otto happens with both this and the in-tree
driver and thus doesn't stop this moving forward.

As well as the 2.12 improvements, this driver also has a backport
(partially aided by the backports in RHEL 5 kindly provided by Dave
Airlie) from the kms code of modesetting support for ironlake (arrandale
and clarkdale: the IGDs build into intel nehalem cpu dies) which has
been tested on a number of chipsets. Note that Display port and eDP
displays have not yet been worked on (and probably won't until I can
find a displayport monitor), but VGA and lvds at least are known to
work, sure beats vesa.

"no objection on my side" matthieu@@, prodding (as always) from princess
marco.
@
text
@d33 1
a33 1
#include "i830.h"
d36 1
@


1.3
log
@Update the intel driver to 2.9.1 plus backports.

2.9.1 is the last version of the intel DDX that supports UMS (User
modesetting), with 2.10 onwards being purely KMS only. As such, this
driver contains backports of almost every correctness or performance
related fix to the rendering layer in later intel drivers. This driver
*REQUIRES* a GEM enabled kernel. it claims to support non-gem mode but
this is essentially unmaintained and due to the way the abstraciton
works is slow, if it works at all (it often does not). You have been
warned.

tested by many many people on tech over the last few weeks.
@
text
@d139 16
d174 3
d234 1
a234 1
    xfree(edid_mon);
d245 1
a245 1
	xfree(intel_output);
d354 1
d356 19
a374 2
    output = xf86OutputCreate(scrn, &i830_hdmi_output_funcs,
			      (output_reg == SDVOB) ? "HDMI-1" : "HDMI-2");
d399 1
a399 1
    else
d401 6
d409 1
a409 2
	       "HDMI output %d detected\n",
	       (output_reg == SDVOB) ? 1 : 2);
@


1.2
log
@update to xf86-video-intel 2.7.1. Tested by many.
@
text
@d76 1
a76 1
    ScrnInfoPtr pScrn = output->scrn;
d79 1
a79 1
    I830Ptr pI830 = I830PTR(pScrn);
d102 1
a102 1
    ScrnInfoPtr pScrn = output->scrn;
d105 1
a105 1
    I830Ptr pI830 = I830PTR(pScrn);
d120 1
a120 1
    ScrnInfoPtr pScrn = output->scrn;
d123 1
a123 1
    I830Ptr pI830 = I830PTR(pScrn);
d131 1
a131 1
    ScrnInfoPtr pScrn = output->scrn;
d134 1
a134 1
    I830Ptr pI830 = I830PTR(pScrn);
d148 1
a148 1
    ScrnInfoPtr	pScrn = output->scrn;
d151 1
a151 1
    I830Ptr pI830 = I830PTR(pScrn);
d162 1
a162 1
    if (IS_G4X(pI830) && !IS_GM45(pI830)) {
d169 12
a180 5
    OUTREG(PORT_HOTPLUG_EN,
	   temp |
	   HDMIB_HOTPLUG_INT_EN |
	   HDMIC_HOTPLUG_INT_EN |
	   HDMID_HOTPLUG_INT_EN);
d184 1
d209 2
a210 2
    if (pI830->debug_modes)
	xf86DrvMsg(pScrn->scrnIndex, X_INFO,
d233 2
a234 2
    ScrnInfoPtr                 pScrn = output->scrn;
    I830Ptr                     pI830 = I830PTR(pScrn);
d241 1
a241 1
    if (pScrn->depth != 24 ||
d243 1
a243 1
        !(IS_I965G(pI830) || IS_G4X(pI830)))
d255 1
a255 1
        xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
d267 1
a267 1
        xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
d277 2
a278 2
    ScrnInfoPtr             pScrn = output->scrn;
    I830Ptr                 pI830 = I830PTR(pScrn);
d330 1
a330 1
i830_hdmi_init(ScrnInfoPtr pScrn, int output_reg)
d336 1
a336 1
    output = xf86OutputCreate(pScrn, &i830_hdmi_output_funcs,
d361 1
a361 1
	I830I2CInit(pScrn, &intel_output->pDDCBus, GPIOE, "HDMIDDC_B");
d363 1
a363 1
	I830I2CInit(pScrn, &intel_output->pDDCBus, GPIOD, "HDMIDDC_C");
d365 1
a365 1
    xf86DrvMsg(pScrn->scrnIndex, X_INFO,
@


1.1
log
@xf86-video-intel 2.4.2. Has been in snapshots for weeks. Ok oga@@.
@
text
@d36 1
d42 4
d48 2
d88 4
d153 4
d158 1
a158 1
    /* For G4X, PEG_BAND_GAP_DATA 3:0 must first be written 0xd.
d162 1
a162 1
    if (IS_G4X(pI830)) {
d189 1
a189 1
	return XF86OutputStatusConnected;
d192 17
d222 83
d306 1
d317 1
d344 1
@

