head	1.9;
access;
symbols
	OPENBSD_5_3:1.8.0.4
	OPENBSD_5_3_BASE:1.8
	OPENBSD_5_2:1.8.0.2
	OPENBSD_5_2_BASE:1.8
	OPENBSD_5_1_BASE:1.7
	OPENBSD_5_1:1.7.0.2
	OPENBSD_5_0:1.6.0.6
	OPENBSD_5_0_BASE:1.6
	OPENBSD_4_9:1.6.0.2
	OPENBSD_4_9_BASE:1.6
	OPENBSD_4_8:1.6.0.4
	OPENBSD_4_8_BASE:1.6
	OPENBSD_4_7:1.4.0.6
	OPENBSD_4_7_BASE:1.4
	OPENBSD_4_6:1.4.0.4
	OPENBSD_4_6_BASE:1.4
	OPENBSD_4_5:1.4.0.2
	OPENBSD_4_5_BASE:1.4
	OPENBSD_4_4:1.3.0.2
	OPENBSD_4_4_BASE:1.3
	OPENBSD_4_3_BASE:1.1.1.2
	OPENBSD_4_3:1.1.1.2.0.2
	v2_2_0_90:1.1.1.2
	v2_2_0:1.1.1.1
	xorg:1.1.1;
locks; strict;
comment	@ * @;


1.9
date	2013.03.18.18.38.20;	author matthieu;	state dead;
branches;
next	1.8;

1.8
date	2012.06.07.20.48.44;	author matthieu;	state Exp;
branches;
next	1.7;

1.7
date	2011.11.29.12.39.02;	author oga;	state Exp;
branches;
next	1.6;

1.6
date	2010.07.18.14.47.47;	author oga;	state Exp;
branches;
next	1.5;

1.5
date	2010.05.10.22.32.29;	author oga;	state Exp;
branches;
next	1.4;

1.4
date	2008.10.12.15.20.50;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2008.05.21.20.19.52;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2008.03.30.13.51.30;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2007.11.24.19.44.43;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2007.11.24.19.44.43;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2008.02.11.20.10.06;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.9
log
@Update to xf86-video-intel 2.20.19.

A recent kernel with kernel modesetting support is required.
Thanks to jsg@@ and kettenis@@ for their work.
@
text
@/**************************************************************************

Copyright 2006 Dave Airlie <airlied@@linux.ie>

All Rights Reserved.

Permission is hereby granted, free of charge, to any person obtaining a
copy of this software and associated documentation files (the "Software"),
to deal in the Software without restriction, including without limitation
on the rights to use, copy, modify, merge, publish, distribute, sub
license, and/or sell copies of the Software, and to permit persons to whom
the Software is furnished to do so, subject to the following conditions:
The above copyright notice and this permission notice (including the next
paragraph) shall be included in all copies or substantial portions of the
Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT. IN NO EVENT SHALL
THE COPYRIGHT HOLDERS AND/OR THEIR SUPPLIERS BE LIABLE FOR ANY CLAIM,
DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
USE OR OTHER DEALINGS IN THE SOFTWARE.

******
********************************************************************/

#ifdef HAVE_CONFIG_H
#include "config.h"
#endif

#include "xf86.h"
#include "intel.h"
#include "i830_display.h"
#include "i830_reg.h"

#include "sil164/sil164.h"
#include "ch7xxx/ch7xxx.h"
#include "tfp410/tfp410.h"

/* driver list */
static struct _I830DVODriver i830_dvo_drivers[] =
{
    {
	.type = I830_OUTPUT_DVO_TMDS,
	.modulename = "sil164",
	.fntablename = "SIL164VidOutput",
	.dvo_reg = DVOC,
	.address = (SIL164_ADDR_1<<1),
    },
    {
	.type = I830_OUTPUT_DVO_TMDS,
	.modulename = "ch7xxx",
	.fntablename = "CH7xxxVidOutput",
	.dvo_reg = DVOC,
	.address = (CH7xxx_ADDR_1<<1),
    },
    {
	.type = I830_OUTPUT_DVO_LVDS,
	.modulename = "ivch",
	.fntablename = "ivch_methods",
	.dvo_reg = DVOA,
	.address = 0x04, /* Might also be 0x44, 0x84, 0xc4 */
    },
    {
	.type = I830_OUTPUT_DVO_TMDS,
	.modulename = "tfp410",
	.fntablename = "TFP410VidOutput",
	.dvo_reg = DVOC,
	.address = (TFP410_ADDR_1<<1),
    },
    {
	.type = I830_OUTPUT_DVO_LVDS,
	.modulename = "ch7017",
	.fntablename = "ch7017_methods",
	.dvo_reg = DVOC,
	.address = 0xea,
	.gpio = GPIOE,
    }
};

#define I830_NUM_DVO_DRIVERS (sizeof(i830_dvo_drivers)/sizeof(struct _I830DVODriver))

static void
i830_dvo_dpms(xf86OutputPtr output, int mode)
{
    ScrnInfoPtr		    scrn = output->scrn;
    intel_screen_private    *intel = intel_get_screen_private(scrn);
    I830OutputPrivatePtr    intel_output = output->driver_private;
    struct _I830DVODriver   *drv = intel_output->i2c_drv;
    void *		    dev_priv = drv->dev_priv;
    unsigned int	    dvo_reg = drv->dvo_reg;

    if (mode == DPMSModeOn) {
	OUTREG(dvo_reg, INREG(dvo_reg) | DVO_ENABLE);
	POSTING_READ(dvo_reg);
	(*intel_output->i2c_drv->vid_rec->dpms)(dev_priv, mode);
    } else {
	(*intel_output->i2c_drv->vid_rec->dpms)(dev_priv, mode);
	OUTREG(dvo_reg, INREG(dvo_reg) & ~DVO_ENABLE);
	POSTING_READ(dvo_reg);
    }
}

static void
i830_dvo_save(xf86OutputPtr output)
{
    ScrnInfoPtr		    scrn = output->scrn;
    intel_screen_private    *intel = intel_get_screen_private(scrn);
    I830OutputPrivatePtr    intel_output = output->driver_private;
    void *		    dev_priv = intel_output->i2c_drv->dev_priv;

    /* Each output should probably just save the registers it touches, but for
     * now, use more overkill.
     */
    intel->saveDVOA = INREG(DVOA);
    intel->saveDVOB = INREG(DVOB);
    intel->saveDVOC = INREG(DVOC);

    (*intel_output->i2c_drv->vid_rec->save)(dev_priv);
}

static void
i830_dvo_restore(xf86OutputPtr output)
{
    ScrnInfoPtr		    scrn = output->scrn;
    intel_screen_private    *intel = intel_get_screen_private(scrn);
    I830OutputPrivatePtr    intel_output = output->driver_private;
    void *		    dev_priv = intel_output->i2c_drv->dev_priv;

    (*intel_output->i2c_drv->vid_rec->restore)(dev_priv);

    OUTREG(DVOA, intel->saveDVOA);
    OUTREG(DVOB, intel->saveDVOB);
    OUTREG(DVOC, intel->saveDVOC);
}

static int
i830_dvo_mode_valid(xf86OutputPtr output, DisplayModePtr pMode)
{
    ScrnInfoPtr		    scrn = output->scrn;
    intel_screen_private    *intel = intel_get_screen_private(scrn);
    I830OutputPrivatePtr    intel_output = output->driver_private;
    void		    *dev_priv = intel_output->i2c_drv->dev_priv;

    if (pMode->Flags & V_DBLSCAN)
	return MODE_NO_DBLESCAN;

    /* XXX: Validate clock range */

    if (intel->lvds_fixed_mode) {
	if (pMode->HDisplay > intel->lvds_fixed_mode->HDisplay)
	    return MODE_PANEL;
	if (pMode->VDisplay > intel->lvds_fixed_mode->VDisplay)
	    return MODE_PANEL;
    }

    return intel_output->i2c_drv->vid_rec->mode_valid(dev_priv, pMode);
}

static Bool
i830_dvo_mode_fixup(xf86OutputPtr output, DisplayModePtr mode,
		    DisplayModePtr adjusted_mode)
{
    ScrnInfoPtr		    scrn = output->scrn;
    intel_screen_private    *intel = intel_get_screen_private(scrn);
    I830OutputPrivatePtr    intel_output = output->driver_private;

    /* If we have timings from the BIOS for the panel, put them in
     * to the adjusted mode.  The CRTC will be set up for this mode,
     * with the panel scaling set up to source from the H/VDisplay
     * of the original mode.
     */
    if (intel->lvds_fixed_mode != NULL) {
	adjusted_mode->HDisplay = intel->lvds_fixed_mode->HDisplay;
	adjusted_mode->HSyncStart = intel->lvds_fixed_mode->HSyncStart;
	adjusted_mode->HSyncEnd = intel->lvds_fixed_mode->HSyncEnd;
	adjusted_mode->HTotal = intel->lvds_fixed_mode->HTotal;
	adjusted_mode->VDisplay = intel->lvds_fixed_mode->VDisplay;
	adjusted_mode->VSyncStart = intel->lvds_fixed_mode->VSyncStart;
	adjusted_mode->VSyncEnd = intel->lvds_fixed_mode->VSyncEnd;
	adjusted_mode->VTotal = intel->lvds_fixed_mode->VTotal;
	adjusted_mode->Clock = intel->lvds_fixed_mode->Clock;
	xf86SetModeCrtc(adjusted_mode, INTERLACE_HALVE_V);
    }

    if (intel_output->i2c_drv->vid_rec->mode_fixup)
	return intel_output->i2c_drv->vid_rec->mode_fixup (intel_output->i2c_drv->dev_priv,
							   mode, adjusted_mode);
    return TRUE;
}

static void
i830_dvo_mode_set(xf86OutputPtr output, DisplayModePtr mode,
		  DisplayModePtr adjusted_mode)
{
    ScrnInfoPtr		    scrn = output->scrn;
    intel_screen_private    *intel = intel_get_screen_private(scrn);
    xf86CrtcPtr	    crtc = output->crtc;
    I830CrtcPrivatePtr	    intel_crtc = crtc->driver_private;
    I830OutputPrivatePtr    intel_output = output->driver_private;
    struct _I830DVODriver   *drv = intel_output->i2c_drv;
    int			    pipe = intel_crtc->pipe;
    uint32_t		    dvo;
    unsigned int	    dvo_reg = drv->dvo_reg, dvo_srcdim_reg;
    int			    dpll_reg = (pipe == 0) ? DPLL_A : DPLL_B;

    switch (dvo_reg) {
    case DVOA:
    default:
	dvo_srcdim_reg = DVOA_SRCDIM;
	break;
    case DVOB:
	dvo_srcdim_reg = DVOB_SRCDIM;
	break;
    case DVOC:
	dvo_srcdim_reg = DVOC_SRCDIM;
	break;
    }

    intel_output->i2c_drv->vid_rec->mode_set(intel_output->i2c_drv->dev_priv,
					     mode, adjusted_mode);

    /* Save the data order, since I don't know what it should be set to. */
    dvo = INREG(dvo_reg) & (DVO_PRESERVE_MASK | DVO_DATA_ORDER_GBRG);
    dvo |= DVO_DATA_ORDER_FP | DVO_BORDER_ENABLE | DVO_BLANK_ACTIVE_HIGH;

    if (pipe == 1)
	dvo |= DVO_PIPE_B_SELECT;
    dvo |= DVO_PIPE_STALL;
    if (adjusted_mode->Flags & V_PHSYNC)
	dvo |= DVO_HSYNC_ACTIVE_HIGH;
    if (adjusted_mode->Flags & V_PVSYNC)
	dvo |= DVO_VSYNC_ACTIVE_HIGH;

    OUTREG(dpll_reg, INREG(dpll_reg) | DPLL_DVO_HIGH_SPEED);

    /*OUTREG(DVOB_SRCDIM,
      (adjusted_mode->HDisplay << DVO_SRCDIM_HORIZONTAL_SHIFT) |
      (adjusted_mode->VDisplay << DVO_SRCDIM_VERTICAL_SHIFT));*/
    OUTREG(dvo_srcdim_reg,
	   (adjusted_mode->HDisplay << DVO_SRCDIM_HORIZONTAL_SHIFT) |
	   (adjusted_mode->VDisplay << DVO_SRCDIM_VERTICAL_SHIFT));
    /*OUTREG(DVOB, dvo);*/
    OUTREG(dvo_reg, dvo);
}

/**
 * Detect the output connection on our DVO device.
 *
 * Unimplemented.
 */
static xf86OutputStatus
i830_dvo_detect(xf86OutputPtr output)
{
    I830OutputPrivatePtr    intel_output = output->driver_private;
    void *dev_priv = intel_output->i2c_drv->dev_priv;

    return intel_output->i2c_drv->vid_rec->detect(dev_priv);
}

static DisplayModePtr
i830_dvo_get_modes(xf86OutputPtr output)
{
    ScrnInfoPtr	scrn = output->scrn;
    intel_screen_private    *intel = intel_get_screen_private(scrn);
    I830OutputPrivatePtr    intel_output = output->driver_private;
    DisplayModePtr	    modes;

    /* We should probably have an i2c driver get_modes function for those
     * devices which will have a fixed set of modes determined by the chip
     * (TV-out, for example), but for now with just TMDS and LVDS, that's not
     * the case.
     */
    modes = i830_ddc_get_modes(output);
    if (modes != NULL)
	return modes;

    if (intel_output->i2c_drv->vid_rec->get_modes)
    {
	modes = intel_output->i2c_drv->vid_rec->get_modes (intel_output->i2c_drv->dev_priv);
	if (modes != NULL)
	    return modes;
    }

    if (intel->lvds_fixed_mode != NULL)
	return xf86DuplicateMode(intel->lvds_fixed_mode);

    return NULL;
}

static void
i830_dvo_destroy (xf86OutputPtr output)
{
    I830OutputPrivatePtr    intel_output = output->driver_private;

    if (intel_output)
    {
	if (intel_output->i2c_drv->vid_rec->destroy)
	    intel_output->i2c_drv->vid_rec->destroy (intel_output->i2c_drv->dev_priv);
	if (intel_output->pI2CBus)
	    xf86DestroyI2CBusRec (intel_output->pI2CBus, TRUE, TRUE);
	if (intel_output->pDDCBus)
	    xf86DestroyI2CBusRec (intel_output->pDDCBus, TRUE, TRUE);
	free (intel_output);
    }
}

#ifdef RANDR_GET_CRTC_INTERFACE
static xf86CrtcPtr
i830_dvo_get_crtc(xf86OutputPtr output)
{
    ScrnInfoPtr	scrn = output->scrn;
    intel_screen_private *intel = intel_get_screen_private(scrn);
    I830OutputPrivatePtr intel_output = output->driver_private;
    struct _I830DVODriver *drv = intel_output->i2c_drv;
    int pipe = !!(INREG(drv->dvo_reg) & SDVO_PIPE_B_SELECT);
   
    return intel_pipe_to_crtc(scrn, pipe);
}
#endif

static const xf86OutputFuncsRec i830_dvo_output_funcs = {
    .dpms = i830_dvo_dpms,
    .save = i830_dvo_save,
    .restore = i830_dvo_restore,
    .mode_valid = i830_dvo_mode_valid,
    .mode_fixup = i830_dvo_mode_fixup,
    .prepare = i830_output_prepare,
    .mode_set = i830_dvo_mode_set,
    .commit = i830_output_commit,
    .detect = i830_dvo_detect,
    .get_modes = i830_dvo_get_modes,
    .destroy = i830_dvo_destroy,
#ifdef RANDR_GET_CRTC_INTERFACE
    .get_crtc = i830_dvo_get_crtc,
#endif
};

/**
 * Attempts to get a fixed panel timing for LVDS (currently only the i830).
 *
 * Other chips with DVO LVDS will need to extend this to deal with the LVDS
 * chip being on DVOB/C and having multiple pipes.
 */
static DisplayModePtr
i830_dvo_get_current_mode (xf86OutputPtr output)
{
    ScrnInfoPtr		    scrn = output->scrn;
    I830OutputPrivatePtr    intel_output = output->driver_private;
    intel_screen_private *intel = intel_get_screen_private(scrn);
    struct _I830DVODriver   *drv = intel_output->i2c_drv;
    unsigned int	    dvo_reg = drv->dvo_reg;
    uint32_t		    dvo = INREG(dvo_reg);
    DisplayModePtr    	    mode = NULL;

    /* If the DVO port is active, that'll be the LVDS, so we can pull out
     * its timings to get how the BIOS set up the panel.
     */
    if (dvo & DVO_ENABLE) 
    {
	xf86CrtcConfigPtr   xf86_config = XF86_CRTC_CONFIG_PTR(scrn);
	int		    pipe = (dvo & DVO_PIPE_B_SELECT) ? 1 : 0;
	int		    c;

	for (c = 0; c < xf86_config->num_crtc; c++)
	{
	    xf86CrtcPtr		crtc = xf86_config->crtc[c];
	    I830CrtcPrivatePtr	intel_crtc = crtc->driver_private;

	    if (intel_crtc->pipe == pipe)
	    {
		mode = i830_crtc_mode_get(scrn, crtc);

		if (mode)
		{
		    mode->type |= M_T_PREFERRED;

		    if (dvo & DVO_HSYNC_ACTIVE_HIGH)
			mode->Flags |= V_PHSYNC;
		    if (dvo & DVO_VSYNC_ACTIVE_HIGH)
			mode->Flags |= V_PVSYNC;
		}
		break;
	    }
	}
    }
    return mode;
}

void
i830_dvo_init(ScrnInfoPtr scrn)
{
    intel_screen_private *intel = intel_get_screen_private(scrn);
    I830OutputPrivatePtr intel_output;
    int ret;
    int i;
    void *ret_ptr;
    struct _I830DVODriver *drv;
    int gpio_inited = 0;
    I2CBusPtr pI2CBus = NULL;

    intel_output = xnfcalloc (sizeof (I830OutputPrivateRec), 1);
    if (!intel_output)
	return;

    /* Set up the DDC bus */
    ret = I830I2CInit(scrn, &intel_output->pDDCBus, GPIOD, "DVODDC_D");
    if (!ret) {
	free(intel_output);
	return;
    }

    /* Now, try to find a controller */
    for (i = 0; i < I830_NUM_DVO_DRIVERS; i++) {
	int gpio;

	drv = &i830_dvo_drivers[i];
	drv->modhandle = xf86LoadSubModule(scrn, drv->modulename);
	if (drv->modhandle == NULL)
	    continue;

	ret_ptr = NULL;
	drv->vid_rec = LoaderSymbol(drv->fntablename);

	if (!strcmp(drv->modulename, "ivch") &&
	    intel->quirk_flag & QUIRK_IVCH_NEED_DVOB) {
	    drv->dvo_reg = DVOB;
	}

	/* Allow the I2C driver info to specify the GPIO to be used in
	 * special cases, but otherwise default to what's defined in the spec.
	 */
	if (drv->gpio != 0)
	    gpio = drv->gpio;
	else if (drv->type == I830_OUTPUT_DVO_LVDS)
	    gpio = GPIOB;
	else
	    gpio = GPIOE;

	/* Set up the I2C bus necessary for the chip we're probing.  It appears
	 * that everything is on GPIOE except for panels on i830 laptops, which
	 * are on GPIOB (DVOA).
	 */
	if (gpio_inited != gpio) {
	    if (pI2CBus != NULL)
		xf86DestroyI2CBusRec(pI2CBus, TRUE, TRUE);
	    if (!I830I2CInit(scrn, &pI2CBus, gpio,
			     gpio == GPIOB ? "DVOI2C_B" : "DVOI2C_E")) {
		continue;
	    }
	}

	if (drv->vid_rec != NULL)
	    ret_ptr = drv->vid_rec->init(pI2CBus, drv->address);

	if (ret_ptr != NULL) {
	    xf86OutputPtr output = NULL;

	    intel_output->type = drv->type;
	    switch (drv->type) {
	    case I830_OUTPUT_DVO_TMDS:
		intel_output->pipe_mask = ((1 << 0) | (1 << 1));
		intel_output->clone_mask = ((1 << I830_OUTPUT_ANALOG) |
					    (1 << I830_OUTPUT_DVO_TMDS));
		output = xf86OutputCreate(scrn, &i830_dvo_output_funcs,
					  "TMDS");
		break;
	    case I830_OUTPUT_DVO_LVDS:
		intel_output->pipe_mask = ((1 << 0) | (1 << 1));
		intel_output->clone_mask = (1 << I830_OUTPUT_DVO_LVDS);
		output = xf86OutputCreate(scrn, &i830_dvo_output_funcs,
					  "LVDS");
		break;
	    case I830_OUTPUT_DVO_TVOUT:
		intel_output->pipe_mask = ((1 << 0) | (1 << 1));
		intel_output->clone_mask = (1 << I830_OUTPUT_DVO_TVOUT);
		output = xf86OutputCreate(scrn, &i830_dvo_output_funcs,
					  "TV");
		break;
	    }
	    if (output == NULL) {
		xf86DestroyI2CBusRec(pI2CBus, TRUE, TRUE);
		xf86DestroyI2CBusRec(intel_output->pDDCBus, TRUE, TRUE);
		free(intel_output);
#if GET_ABI_MAJOR(ABI_VIDEODRV_VERSION) < 12
		xf86UnloadSubModule(drv->modhandle);
#endif
		return;
	    }

	    output->driver_private = intel_output;
	    output->subpixel_order = SubPixelHorizontalRGB;
	    output->interlaceAllowed = FALSE;
	    output->doubleScanAllowed = FALSE;

	    drv->dev_priv = ret_ptr;
	    intel_output->i2c_drv = drv;
	    intel_output->pI2CBus = pI2CBus;

	    if (intel_output->type == I830_OUTPUT_DVO_LVDS) {
		/* For our LVDS chipsets, we should hopefully be able to
		 * dig the fixed panel mode out of the BIOS data.  However,
		 * it's in a different format from the BIOS data on chipsets
		 * with integrated LVDS (stored in AIM headers, liekly),
		 * so for now, just get the current mode being output through
		 * DVO.
		 */
		intel->lvds_fixed_mode = i830_dvo_get_current_mode(output);
		intel->lvds_dither = TRUE;
	    }

	    return;
	}
#if GET_ABI_MAJOR(ABI_VIDEODRV_VERSION) < 12
	xf86UnloadSubModule(drv->modhandle);
#endif
    }

    /* Didn't find a chip, so tear down. */
    if (pI2CBus != NULL)
	xf86DestroyI2CBusRec(pI2CBus, TRUE, TRUE);
    xf86DestroyI2CBusRec(intel_output->pDDCBus, TRUE, TRUE);
    free(intel_output);
}
@


1.8
log
@Don't unload sub-modules in xserver 1.12. Its implementation is broken.

xf86UnloadSubModule() was a no-op in earlier versions.
@
text
@@


1.7
log
@Update the intel driver to a more recent version based on more recent
upsteam code.

Backporting keeping UMS changes by me, some bugfixes from kettenis@@.

Has been in snapshots for a while, committed on request so we can be
sure what people are running. This is a prerequesite for sandybridge
support but has those chipsets disabled for now until the correct code
has been added.
@
text
@d486 1
d488 1
d515 1
d517 1
@


1.6
log
@Update the intel driver to (mostly) a backport of 2.12.

It is missing a few commits that I have yet to verify (ones that try and
continue if we lock the gpu rendering engine and can't reset it, for
example) taht will be verified and sent out for extra testing soon.

Should contain a bunch of speedups and some correctness improvements
(though rendercheck still gives some errors that I am looking into).

This has been in snaps since the first day of c2k10, any known issues
with just this driver have (to my knowledge) been fixed since. A problem
with macbooks pointed out by otto happens with both this and the in-tree
driver and thus doesn't stop this moving forward.

As well as the 2.12 improvements, this driver also has a backport
(partially aided by the backports in RHEL 5 kindly provided by Dave
Airlie) from the kms code of modesetting support for ironlake (arrandale
and clarkdale: the IGDs build into intel nehalem cpu dies) which has
been tested on a number of chipsets. Note that Display port and eDP
displays have not yet been worked on (and probably won't until I can
find a displayport monitor), but VGA and lvds at least are known to
work, sure beats vesa.

"no objection on my side" matthieu@@, prodding (as always) from princess
marco.
@
text
@d33 1
a33 1
#include "i830.h"
d35 1
a35 1
#include "i810_reg.h"
d319 1
a319 1
    return i830_pipe_to_crtc(scrn, pipe);
@


1.5
log
@Update the intel driver to 2.9.1 plus backports.

2.9.1 is the last version of the intel DDX that supports UMS (User
modesetting), with 2.10 onwards being purely KMS only. As such, this
driver contains backports of almost every correctness or performance
related fix to the rendering layer in later intel drivers. This driver
*REQUIRES* a GEM enabled kernel. it claims to support non-gem mode but
this is essentially unmaintained and due to the way the abstraciton
works is slow, if it works at all (it often does not). You have been
warned.

tested by many many people on tech over the last few weeks.
@
text
@d305 1
a305 1
	xfree (intel_output);
d410 1
a410 1
	xfree(intel_output);
d485 1
a485 1
		xfree(intel_output);
d520 1
a520 1
    xfree(intel_output);
@


1.4
log
@xf86-video-intel 2.4.2. Has been in snapshots for weeks. Ok oga@@.
@
text
@a40 22
static const char *SIL164Symbols[] = {
    "Sil164VidOutput",
    NULL
};
static const char *TFP410Symbols[] = {
    "Tfp410VidOutput",
    NULL
};
static const char *CH7xxxSymbols[] = {
    "CH7xxxVidOutput",
    NULL
};
static const char *ivch_symbols[] = {
    "ivch_methods",
    NULL
};

static const char *ch7017_symbols[] = {
    "ch7017_methods",
    NULL
};

d42 1
a42 1
struct _I830DVODriver i830_dvo_drivers[] =
a49 1
	.symbols = SIL164Symbols
a56 1
	.symbols = CH7xxxSymbols
a63 1
	.symbols = ivch_symbols
a70 1
	.symbols = TFP410Symbols
a77 1
	.symbols = ch7017_symbols,
d87 2
a88 2
    ScrnInfoPtr		    pScrn = output->scrn;
    I830Ptr		    pI830 = I830PTR(pScrn);
d108 2
a109 2
    ScrnInfoPtr		    pScrn = output->scrn;
    I830Ptr		    pI830 = I830PTR(pScrn);
d116 3
a118 3
    pI830->saveDVOA = INREG(DVOA);
    pI830->saveDVOB = INREG(DVOB);
    pI830->saveDVOC = INREG(DVOC);
d126 2
a127 2
    ScrnInfoPtr		    pScrn = output->scrn;
    I830Ptr		    pI830 = I830PTR(pScrn);
d133 3
a135 3
    OUTREG(DVOA, pI830->saveDVOA);
    OUTREG(DVOB, pI830->saveDVOB);
    OUTREG(DVOC, pI830->saveDVOC);
d141 2
a142 2
    ScrnInfoPtr		    pScrn = output->scrn;
    I830Ptr		    pI830 = I830PTR(pScrn);
d151 2
a152 2
    if (pI830->lvds_fixed_mode) {
	if (pMode->HDisplay > pI830->lvds_fixed_mode->HDisplay)
d154 1
a154 1
	if (pMode->VDisplay > pI830->lvds_fixed_mode->VDisplay)
d165 2
a166 2
    ScrnInfoPtr		    pScrn = output->scrn;
    I830Ptr		    pI830 = I830PTR(pScrn);
d174 10
a183 10
    if (pI830->lvds_fixed_mode != NULL) {
	adjusted_mode->HDisplay = pI830->lvds_fixed_mode->HDisplay;
	adjusted_mode->HSyncStart = pI830->lvds_fixed_mode->HSyncStart;
	adjusted_mode->HSyncEnd = pI830->lvds_fixed_mode->HSyncEnd;
	adjusted_mode->HTotal = pI830->lvds_fixed_mode->HTotal;
	adjusted_mode->VDisplay = pI830->lvds_fixed_mode->VDisplay;
	adjusted_mode->VSyncStart = pI830->lvds_fixed_mode->VSyncStart;
	adjusted_mode->VSyncEnd = pI830->lvds_fixed_mode->VSyncEnd;
	adjusted_mode->VTotal = pI830->lvds_fixed_mode->VTotal;
	adjusted_mode->Clock = pI830->lvds_fixed_mode->Clock;
d197 2
a198 2
    ScrnInfoPtr		    pScrn = output->scrn;
    I830Ptr		    pI830 = I830PTR(pScrn);
d265 2
a266 2
    ScrnInfoPtr	pScrn = output->scrn;
    I830Ptr pI830 = I830PTR(pScrn);
d286 2
a287 2
    if (pI830->lvds_fixed_mode != NULL)
	return xf86DuplicateMode(pI830->lvds_fixed_mode);
d313 2
a314 2
    ScrnInfoPtr	pScrn = output->scrn;
    I830Ptr pI830 = I830PTR(pScrn);
d319 1
a319 1
    return i830_pipe_to_crtc(pScrn, pipe);
d346 1
a346 1
DisplayModePtr
d349 1
a349 1
    ScrnInfoPtr		    pScrn = output->scrn;
d351 1
a351 1
    I830Ptr		    pI830 = I830PTR(pScrn);
d362 1
a362 1
	xf86CrtcConfigPtr   xf86_config = XF86_CRTC_CONFIG_PTR(pScrn);
d373 1
a373 1
		mode = i830_crtc_mode_get(pScrn, crtc);
d392 1
a392 1
i830_dvo_init(ScrnInfoPtr pScrn)
d394 1
a394 1
    I830Ptr pI830 = I830PTR(pScrn);
d408 1
a408 1
    ret = I830I2CInit(pScrn, &intel_output->pDDCBus, GPIOD, "DVODDC_D");
d419 1
a419 1
	drv->modhandle = xf86LoadSubModule(pScrn, drv->modulename);
a422 2
	xf86LoaderReqSymLists(drv->symbols, NULL);

d427 1
a427 1
	    pI830->quirk_flag & QUIRK_IVCH_NEED_DVOB) {
d448 1
a448 1
	    if (!I830I2CInit(pScrn, &pI2CBus, gpio,
d466 1
a466 1
		output = xf86OutputCreate(pScrn, &i830_dvo_output_funcs,
d472 1
a472 1
		output = xf86OutputCreate(pScrn, &i830_dvo_output_funcs,
d478 1
a478 1
		output = xf86OutputCreate(pScrn, &i830_dvo_output_funcs,
d507 2
a508 2
		pI830->lvds_fixed_mode = i830_dvo_get_current_mode(output);
		pI830->lvds_dither = TRUE;
@


1.3
log
@Update to xf86-video-intel 2.3.1. Tested by many.
@
text
@d168 2
a170 1
    struct _I830DVODriver   *drv = intel_output->i2c_drv;
d178 2
a179 2
    if (drv->panel_fixed_mode) {
	if (pMode->HDisplay > drv->panel_fixed_mode->HDisplay)
d181 1
a181 1
	if (pMode->VDisplay > drv->panel_fixed_mode->VDisplay)
d192 2
a194 1
    struct _I830DVODriver   *drv = intel_output->i2c_drv;
d201 10
a210 10
    if (drv->panel_fixed_mode != NULL) {
	adjusted_mode->HDisplay = drv->panel_fixed_mode->HDisplay;
	adjusted_mode->HSyncStart = drv->panel_fixed_mode->HSyncStart;
	adjusted_mode->HSyncEnd = drv->panel_fixed_mode->HSyncEnd;
	adjusted_mode->HTotal = drv->panel_fixed_mode->HTotal;
	adjusted_mode->VDisplay = drv->panel_fixed_mode->VDisplay;
	adjusted_mode->VSyncStart = drv->panel_fixed_mode->VSyncStart;
	adjusted_mode->VSyncEnd = drv->panel_fixed_mode->VSyncEnd;
	adjusted_mode->VTotal = drv->panel_fixed_mode->VTotal;
	adjusted_mode->Clock = drv->panel_fixed_mode->Clock;
d292 2
a294 1
    struct _I830DVODriver   *drv = intel_output->i2c_drv;
d313 2
a314 2
    if (drv->panel_fixed_mode != NULL)
	return xf86DuplicateMode(drv->panel_fixed_mode);
d536 2
a537 2
		drv->panel_fixed_mode = i830_dvo_get_current_mode(output);
		drv->panel_wants_dither = TRUE;
@


1.2
log
@Update to Intel driver 2.2.1. But change default accelmethod to XAA.
Tested by landry@@, oga@@, steven@@, jakemsr@@.
@
text
@d229 1
a229 1
    CARD32		    dvo;
d333 14
d358 4
a361 1
    .destroy = i830_dvo_destroy
d378 1
a378 1
    CARD32		    dvo = INREG(dvo_reg);
@


1.1
log
@Initial revision
@
text
@d401 1
d434 5
@


1.1.1.1
log
@xf86-video-intel 2.2.0
@
text
@@


1.1.1.2
log
@Import intel driver v 2.2.0.90. tested by many, including krw@@ kettenis@@,
jakemsr@@, landry@@, beck@@ and oga@@. Thanks.
@
text
@d86 1
a86 1
	.dvo_reg = DVOB,
@

