head	1.8;
access;
symbols
	OPENBSD_5_4:1.7.0.2
	OPENBSD_5_4_BASE:1.7
	OPENBSD_5_3:1.6.0.6
	OPENBSD_5_3_BASE:1.6
	OPENBSD_5_2:1.6.0.4
	OPENBSD_5_2_BASE:1.6
	OPENBSD_5_1_BASE:1.6
	OPENBSD_5_1:1.6.0.2
	OPENBSD_5_0:1.5.0.6
	OPENBSD_5_0_BASE:1.5
	OPENBSD_4_9:1.5.0.2
	OPENBSD_4_9_BASE:1.5
	OPENBSD_4_8:1.5.0.4
	OPENBSD_4_8_BASE:1.5
	OPENBSD_4_7:1.3.0.4
	OPENBSD_4_7_BASE:1.3
	OPENBSD_4_6:1.3.0.2
	OPENBSD_4_6_BASE:1.3
	OPENBSD_4_5:1.2.0.4
	OPENBSD_4_5_BASE:1.2
	OPENBSD_4_4:1.2.0.2
	OPENBSD_4_4_BASE:1.2
	OPENBSD_4_3_BASE:1.1.1.1
	OPENBSD_4_3:1.1.1.1.0.2
	v2_2_0_90:1.1.1.1
	v2_2_0:1.1.1.1
	xorg:1.1.1;
locks; strict;
comment	@ * @;


1.8
date	2014.02.03.15.54.51;	author matthieu;	state dead;
branches;
next	1.7;

1.7
date	2013.03.18.18.38.20;	author matthieu;	state Exp;
branches;
next	1.6;

1.6
date	2011.11.29.12.39.03;	author oga;	state Exp;
branches;
next	1.5;

1.5
date	2010.07.18.14.47.47;	author oga;	state Exp;
branches;
next	1.4;

1.4
date	2010.05.10.22.32.29;	author oga;	state Exp;
branches;
next	1.3;

1.3
date	2009.06.25.20.16.43;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2008.05.21.20.19.52;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2007.11.24.19.44.43;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2007.11.24.19.44.43;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.8
log
@Update to xf86-video-intel 2.99.909
Tested by jsg@@, kettenis@@ and myself on a wide range of intel cards.
@
text
@/*
 * Copyright Â© 2006 Intel Corporation
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice (including the next
 * paragraph) shall be included in all copies or substantial portions of the
 * Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 * Authors:
 *    Wang Zhenyu <zhenyu.z.wang@@intel.com>
 *    Eric Anholt <eric@@anholt.net>
 *
 */

#ifdef HAVE_CONFIG_H
#include "config.h"
#endif

#include "xf86.h"
#include "intel.h"
#include "i915_reg.h"
#include "i915_3d.h"

struct formatinfo {
	int fmt;
	uint32_t card_fmt;
};

struct blendinfo {
	Bool dst_alpha;
	Bool src_alpha;
	uint32_t src_blend;
	uint32_t dst_blend;
};

static struct blendinfo i915_blend_op[] = {
	/* Clear */
	{0, 0, BLENDFACT_ZERO, BLENDFACT_ZERO},
	/* Src */
	{0, 0, BLENDFACT_ONE, BLENDFACT_ZERO},
	/* Dst */
	{0, 0, BLENDFACT_ZERO, BLENDFACT_ONE},
	/* Over */
	{0, 1, BLENDFACT_ONE, BLENDFACT_INV_SRC_ALPHA},
	/* OverReverse */
	{1, 0, BLENDFACT_INV_DST_ALPHA, BLENDFACT_ONE},
	/* In */
	{1, 0, BLENDFACT_DST_ALPHA, BLENDFACT_ZERO},
	/* InReverse */
	{0, 1, BLENDFACT_ZERO, BLENDFACT_SRC_ALPHA},
	/* Out */
	{1, 0, BLENDFACT_INV_DST_ALPHA, BLENDFACT_ZERO},
	/* OutReverse */
	{0, 1, BLENDFACT_ZERO, BLENDFACT_INV_SRC_ALPHA},
	/* Atop */
	{1, 1, BLENDFACT_DST_ALPHA, BLENDFACT_INV_SRC_ALPHA},
	/* AtopReverse */
	{1, 1, BLENDFACT_INV_DST_ALPHA, BLENDFACT_SRC_ALPHA},
	/* Xor */
	{1, 1, BLENDFACT_INV_DST_ALPHA, BLENDFACT_INV_SRC_ALPHA},
	/* Add */
	{0, 0, BLENDFACT_ONE, BLENDFACT_ONE},
};

static struct formatinfo i915_tex_formats[] = {
	{PICT_a8, MAPSURF_8BIT | MT_8BIT_A8},
	{PICT_a8r8g8b8, MAPSURF_32BIT | MT_32BIT_ARGB8888},
	{PICT_x8r8g8b8, MAPSURF_32BIT | MT_32BIT_XRGB8888},
	{PICT_a8b8g8r8, MAPSURF_32BIT | MT_32BIT_ABGR8888},
	{PICT_x8b8g8r8, MAPSURF_32BIT | MT_32BIT_XBGR8888},
#if XORG_VERSION_CURRENT >= 10699900
	{PICT_a2r10g10b10, MAPSURF_32BIT | MT_32BIT_ARGB2101010},
	{PICT_a2b10g10r10, MAPSURF_32BIT | MT_32BIT_ABGR2101010},
#endif
	{PICT_r5g6b5, MAPSURF_16BIT | MT_16BIT_RGB565},
	{PICT_a1r5g5b5, MAPSURF_16BIT | MT_16BIT_ARGB1555},
	{PICT_a4r4g4b4, MAPSURF_16BIT | MT_16BIT_ARGB4444},
};

static uint32_t i915_get_blend_cntl(int op, PicturePtr mask,
				    uint32_t dst_format)
{
	uint32_t sblend, dblend;

	sblend = i915_blend_op[op].src_blend;
	dblend = i915_blend_op[op].dst_blend;

	/* If there's no dst alpha channel, adjust the blend op so that we'll
	 * treat it as always 1.
	 */
	if (PICT_FORMAT_A(dst_format) == 0 && i915_blend_op[op].dst_alpha) {
		if (sblend == BLENDFACT_DST_ALPHA)
			sblend = BLENDFACT_ONE;
		else if (sblend == BLENDFACT_INV_DST_ALPHA)
			sblend = BLENDFACT_ZERO;
	}

	/* i915 engine reads 8bit color buffer into green channel in cases
	   like color buffer blending .etc, and also writes back green channel.
	   So with dst_alpha blend we should use color factor. See spec on
	   "8-bit rendering" */
	if ((dst_format == PICT_a8) && i915_blend_op[op].dst_alpha) {
		if (sblend == BLENDFACT_DST_ALPHA)
			sblend = BLENDFACT_DST_COLR;
		else if (sblend == BLENDFACT_INV_DST_ALPHA)
			sblend = BLENDFACT_INV_DST_COLR;
	}

	/* If the source alpha is being used, then we should only be in a case
	 * where the source blend factor is 0, and the source blend value is the
	 * mask channels multiplied by the source picture's alpha.
	 */
	if (mask && mask->componentAlpha && PICT_FORMAT_RGB(mask->format) &&
	    i915_blend_op[op].src_alpha) {
		if (dblend == BLENDFACT_SRC_ALPHA) {
			dblend = BLENDFACT_SRC_COLR;
		} else if (dblend == BLENDFACT_INV_SRC_ALPHA) {
			dblend = BLENDFACT_INV_SRC_COLR;
		}
	}

	return S6_CBUF_BLEND_ENABLE | S6_COLOR_WRITE_ENABLE |
		(BLENDFUNC_ADD << S6_CBUF_BLEND_FUNC_SHIFT) |
		(sblend << S6_CBUF_SRC_BLEND_FACT_SHIFT) |
		(dblend << S6_CBUF_DST_BLEND_FACT_SHIFT);
}

#define DSTORG_HORT_BIAS(x)             ((x)<<20)
#define DSTORG_VERT_BIAS(x)             ((x)<<16)

static Bool i915_get_dest_format(PicturePtr dest_picture, uint32_t * dst_format)
{
	ScrnInfoPtr scrn;

	switch (dest_picture->format) {
	case PICT_a8r8g8b8:
	case PICT_x8r8g8b8:
		*dst_format = COLR_BUF_ARGB8888;
		break;
	case PICT_r5g6b5:
		*dst_format = COLR_BUF_RGB565;
		break;
	case PICT_a1r5g5b5:
	case PICT_x1r5g5b5:
		*dst_format = COLR_BUF_ARGB1555;
		break;
#if XORG_VERSION_CURRENT >= 10699900
	case PICT_a2r10g10b10:
	case PICT_x2r10g10b10:
		*dst_format = COLR_BUF_ARGB2AAA;
		break;
#endif
	case PICT_a8:
		*dst_format = COLR_BUF_8BIT;
		break;
	case PICT_a4r4g4b4:
	case PICT_x4r4g4b4:
		*dst_format = COLR_BUF_ARGB4444;
		break;
	default:
		scrn = xf86ScreenToScrn(dest_picture->pDrawable->pScreen);
		intel_debug_fallback(scrn,
				     "Unsupported dest format 0x%x\n",
				     (int)dest_picture->format);
		return FALSE;
	}
	*dst_format |= DSTORG_HORT_BIAS(0x8) | DSTORG_VERT_BIAS(0x8);
	return TRUE;
}

Bool
i915_check_composite(int op,
		     PicturePtr source_picture,
		     PicturePtr mask_picture,
		     PicturePtr dest_picture,
		     int width, int height)
{
	ScrnInfoPtr scrn = xf86ScreenToScrn(dest_picture->pDrawable->pScreen);
	uint32_t tmp1;

	/* Check for unsupported compositing operations. */
	if (op >= sizeof(i915_blend_op) / sizeof(i915_blend_op[0])) {
		intel_debug_fallback(scrn, "Unsupported Composite op 0x%x\n",
				     op);
		return FALSE;
	}
	if (mask_picture != NULL && mask_picture->componentAlpha &&
	    PICT_FORMAT_RGB(mask_picture->format)) {
		/* Check if it's component alpha that relies on a source alpha
		 * and on the source value.  We can only get one of those
		 * into the single source value that we get to blend with.
		 */
		if (i915_blend_op[op].src_alpha &&
		    (i915_blend_op[op].src_blend != BLENDFACT_ZERO)) {
			if (op != PictOpOver) {
				intel_debug_fallback(scrn,
						     "Component alpha not supported "
						     "with source alpha and source "
						     "value blending.\n");
				return FALSE;
			}
		}
	}

	if (!i915_get_dest_format(dest_picture, &tmp1)) {
		intel_debug_fallback(scrn, "Get Color buffer format\n");
		return FALSE;
	}

	if (width > 2048 || height > 2048)
		return FALSE;

	return TRUE;
}

Bool
i915_check_composite_target(PixmapPtr pixmap)
{
	if (pixmap->drawable.width > 2048 || pixmap->drawable.height > 2048)
		return FALSE;

	if(!intel_check_pitch_3d(pixmap))
		return FALSE;

	return TRUE;
}

Bool
i915_check_composite_texture(ScreenPtr screen, PicturePtr picture)
{
	if (picture->repeatType > RepeatReflect) {
		ScrnInfoPtr scrn = xf86ScreenToScrn(screen);
		intel_debug_fallback(scrn, "Unsupported picture repeat %d\n",
			     picture->repeatType);
		return FALSE;
	}

	if (picture->filter != PictFilterNearest &&
	    picture->filter != PictFilterBilinear) {
		ScrnInfoPtr scrn = xf86ScreenToScrn(screen);
		intel_debug_fallback(scrn, "Unsupported filter 0x%x\n",
				     picture->filter);
		return FALSE;
	}

	if (picture->pSourcePict)
		return FALSE;

	if (picture->pDrawable) {
		int w, h, i;

		w = picture->pDrawable->width;
		h = picture->pDrawable->height;
		if ((w > 2048) || (h > 2048)) {
			ScrnInfoPtr scrn = xf86ScreenToScrn(screen);
			intel_debug_fallback(scrn,
					     "Picture w/h too large (%dx%d)\n",
					     w, h);
			return FALSE;
		}

		for (i = 0;
		     i < sizeof(i915_tex_formats) / sizeof(i915_tex_formats[0]);
		     i++) {
			if (i915_tex_formats[i].fmt == picture->format)
				break;
		}
		if (i == sizeof(i915_tex_formats) / sizeof(i915_tex_formats[0]))
		{
			ScrnInfoPtr scrn = xf86ScreenToScrn(screen);
			intel_debug_fallback(scrn, "Unsupported picture format "
					     "0x%x\n",
					     (int)picture->format);
			return FALSE;
		}

		return TRUE;
	}

	return FALSE;
}

static Bool i915_texture_setup(PicturePtr picture, PixmapPtr pixmap, int unit)
{
	ScrnInfoPtr scrn = xf86ScreenToScrn(picture->pDrawable->pScreen);
	intel_screen_private *intel = intel_get_screen_private(scrn);
	uint32_t format, pitch, filter;
	uint32_t wrap_mode, tiling_bits;
	int i;

	pitch = intel_pixmap_pitch(pixmap);
	intel->scale_units[unit][0] = 1. / pixmap->drawable.width;
	intel->scale_units[unit][1] = 1. / pixmap->drawable.height;

	for (i = 0; i < sizeof(i915_tex_formats) / sizeof(i915_tex_formats[0]);
	     i++) {
		if (i915_tex_formats[i].fmt == picture->format)
			break;
	}
	if (i == sizeof(i915_tex_formats) / sizeof(i915_tex_formats[0])) {
		intel_debug_fallback(scrn, "unknown texture format\n");
		return FALSE;
	}
	format = i915_tex_formats[i].card_fmt;

	switch (picture->repeatType) {
	case RepeatNone:
		wrap_mode = TEXCOORDMODE_CLAMP_BORDER;
		break;
	case RepeatNormal:
		wrap_mode = TEXCOORDMODE_WRAP;
		break;
	case RepeatPad:
		wrap_mode = TEXCOORDMODE_CLAMP_EDGE;
		break;
	case RepeatReflect:
		wrap_mode = TEXCOORDMODE_MIRROR;
		break;
	default:
		FatalError("Unknown repeat type %d\n", picture->repeatType);
	}

	switch (picture->filter) {
	case PictFilterNearest:
		filter = (FILTER_NEAREST << SS2_MAG_FILTER_SHIFT) |
		    (FILTER_NEAREST << SS2_MIN_FILTER_SHIFT);
		break;
	case PictFilterBilinear:
		filter = (FILTER_LINEAR << SS2_MAG_FILTER_SHIFT) |
		    (FILTER_LINEAR << SS2_MIN_FILTER_SHIFT);
		break;
	default:
		intel_debug_fallback(scrn, "Bad filter 0x%x\n",
				     picture->filter);
		return FALSE;
	}

	/* offset filled in at emit time */
	if (intel_pixmap_tiled(pixmap)) {
		tiling_bits = MS3_TILED_SURFACE;
		if (intel_get_pixmap_private(pixmap)->tiling
				== I915_TILING_Y)
			tiling_bits |= MS3_TILE_WALK;
	} else
		tiling_bits = 0;

	intel->texture[unit] = pixmap;
	intel->mapstate[unit * 3 + 0] = 0;
	intel->mapstate[unit * 3 + 1] = format |
	    tiling_bits |
	    ((pixmap->drawable.height - 1) << MS3_HEIGHT_SHIFT) |
	    ((pixmap->drawable.width - 1) << MS3_WIDTH_SHIFT);
	intel->mapstate[unit * 3 + 2] = ((pitch / 4) - 1) << MS4_PITCH_SHIFT;

	intel->samplerstate[unit * 3 + 0] = (MIPFILTER_NONE <<
					     SS2_MIP_FILTER_SHIFT);
	intel->samplerstate[unit * 3 + 0] |= filter;
	intel->samplerstate[unit * 3 + 1] = SS3_NORMALIZED_COORDS;
	intel->samplerstate[unit * 3 + 1] |=
	    wrap_mode << SS3_TCX_ADDR_MODE_SHIFT;
	intel->samplerstate[unit * 3 + 1] |=
	    wrap_mode << SS3_TCY_ADDR_MODE_SHIFT;
	intel->samplerstate[unit * 3 + 1] |= unit << SS3_TEXTUREMAP_INDEX_SHIFT;
	intel->samplerstate[unit * 3 + 2] = 0x00000000;	/* border color */

	intel->transform[unit] = picture->transform;

	return TRUE;
}

static void
i915_emit_composite_primitive_identity_source(intel_screen_private *intel,
					      int srcX, int srcY,
					      int maskX, int maskY,
					      int dstX, int dstY,
					      int w, int h)
{
	OUT_VERTEX(dstX + w);
	OUT_VERTEX(dstY + h);
	OUT_VERTEX((srcX + w) * intel->scale_units[0][0]);
	OUT_VERTEX((srcY + h) * intel->scale_units[0][1]);

	OUT_VERTEX(dstX);
	OUT_VERTEX(dstY + h);
	OUT_VERTEX(srcX * intel->scale_units[0][0]);
	OUT_VERTEX((srcY + h) * intel->scale_units[0][1]);

	OUT_VERTEX(dstX);
	OUT_VERTEX(dstY);
	OUT_VERTEX(srcX * intel->scale_units[0][0]);
	OUT_VERTEX(srcY * intel->scale_units[0][1]);
}

static void
i915_emit_composite_primitive_affine_source(intel_screen_private *intel,
					    int srcX, int srcY,
					    int maskX, int maskY,
					    int dstX, int dstY,
					    int w, int h)
{
	float src_x[3], src_y[3];

	if (!intel_get_transformed_coordinates(srcX, srcY,
					      intel->transform[0],
					      &src_x[0],
					      &src_y[0]))
		return;

	if (!intel_get_transformed_coordinates(srcX, srcY + h,
					      intel->transform[0],
					      &src_x[1],
					      &src_y[1]))
		return;

	if (!intel_get_transformed_coordinates(srcX + w, srcY + h,
					      intel->transform[0],
					      &src_x[2],
					      &src_y[2]))
		return;

	OUT_VERTEX(dstX + w);
	OUT_VERTEX(dstY + h);
	OUT_VERTEX(src_x[2] * intel->scale_units[0][0]);
	OUT_VERTEX(src_y[2] * intel->scale_units[0][1]);

	OUT_VERTEX(dstX);
	OUT_VERTEX(dstY + h);
	OUT_VERTEX(src_x[1] * intel->scale_units[0][0]);
	OUT_VERTEX(src_y[1] * intel->scale_units[0][1]);

	OUT_VERTEX(dstX);
	OUT_VERTEX(dstY);
	OUT_VERTEX(src_x[0] * intel->scale_units[0][0]);
	OUT_VERTEX(src_y[0] * intel->scale_units[0][1]);
}

static void
i915_emit_composite_primitive_identity_source_mask(intel_screen_private *intel,
						   int srcX, int srcY,
						   int maskX, int maskY,
						   int dstX, int dstY,
						   int w, int h)
{
	OUT_VERTEX(dstX + w);
	OUT_VERTEX(dstY + h);
	OUT_VERTEX((srcX + w) * intel->scale_units[0][0]);
	OUT_VERTEX((srcY + h) * intel->scale_units[0][1]);
	OUT_VERTEX((maskX + w) * intel->scale_units[1][0]);
	OUT_VERTEX((maskY + h) * intel->scale_units[1][1]);

	OUT_VERTEX(dstX);
	OUT_VERTEX(dstY + h);
	OUT_VERTEX(srcX * intel->scale_units[0][0]);
	OUT_VERTEX((srcY + h) * intel->scale_units[0][1]);
	OUT_VERTEX(maskX * intel->scale_units[1][0]);
	OUT_VERTEX((maskY + h) * intel->scale_units[1][1]);

	OUT_VERTEX(dstX);
	OUT_VERTEX(dstY);
	OUT_VERTEX(srcX * intel->scale_units[0][0]);
	OUT_VERTEX(srcY * intel->scale_units[0][1]);
	OUT_VERTEX(maskX * intel->scale_units[1][0]);
	OUT_VERTEX(maskY * intel->scale_units[1][1]);
}

static void
i915_emit_composite_primitive(intel_screen_private *intel,
			      int srcX, int srcY,
			      int maskX, int maskY,
			      int dstX, int dstY,
			      int w, int h)
{
	Bool is_affine_src = TRUE, is_affine_mask = TRUE;
	int tex_unit = 0;
	int src_unit = -1, mask_unit = -1;
	float src_x[3], src_y[3], src_w[3], mask_x[3], mask_y[3], mask_w[3];

	src_unit = tex_unit++;

	is_affine_src = intel_transform_is_affine(intel->transform[src_unit]);
	if (is_affine_src) {
		if (!intel_get_transformed_coordinates(srcX, srcY,
						      intel->
						      transform[src_unit],
						      &src_x[0],
						      &src_y[0]))
			return;

		if (!intel_get_transformed_coordinates(srcX, srcY + h,
						      intel->
						      transform[src_unit],
						      &src_x[1],
						      &src_y[1]))
			return;

		if (!intel_get_transformed_coordinates(srcX + w, srcY + h,
						      intel->
						      transform[src_unit],
						      &src_x[2],
						      &src_y[2]))
			return;
	} else {
		if (!intel_get_transformed_coordinates_3d(srcX, srcY,
							 intel->
							 transform[src_unit],
							 &src_x[0],
							 &src_y[0],
							 &src_w[0]))
			return;

		if (!intel_get_transformed_coordinates_3d(srcX, srcY + h,
							 intel->
							 transform[src_unit],
							 &src_x[1],
							 &src_y[1],
							 &src_w[1]))
			return;

		if (!intel_get_transformed_coordinates_3d(srcX + w, srcY + h,
							 intel->
							 transform[src_unit],
							 &src_x[2],
							 &src_y[2],
							 &src_w[2]))
			return;
	}

	if (intel->render_mask) {
		mask_unit = tex_unit++;

		is_affine_mask = intel_transform_is_affine(intel->transform[mask_unit]);
		if (is_affine_mask) {
			if (!intel_get_transformed_coordinates(maskX, maskY,
							      intel->
							      transform[mask_unit],
							      &mask_x[0],
							      &mask_y[0]))
				return;

			if (!intel_get_transformed_coordinates(maskX, maskY + h,
							      intel->
							      transform[mask_unit],
							      &mask_x[1],
							      &mask_y[1]))
				return;

			if (!intel_get_transformed_coordinates(maskX + w, maskY + h,
							      intel->
							      transform[mask_unit],
							      &mask_x[2],
							      &mask_y[2]))
				return;
		} else {
			if (!intel_get_transformed_coordinates_3d(maskX, maskY,
								 intel->
								 transform[mask_unit],
								 &mask_x[0],
								 &mask_y[0],
								 &mask_w[0]))
				return;

			if (!intel_get_transformed_coordinates_3d(maskX, maskY + h,
								 intel->
								 transform[mask_unit],
								 &mask_x[1],
								 &mask_y[1],
								 &mask_w[1]))
				return;

			if (!intel_get_transformed_coordinates_3d(maskX + w, maskY + h,
								 intel->
								 transform[mask_unit],
								 &mask_x[2],
								 &mask_y[2],
								 &mask_w[2]))
				return;
		}
	}

	OUT_VERTEX(dstX + w);
	OUT_VERTEX(dstY + h);
	OUT_VERTEX(src_x[2] * intel->scale_units[src_unit][0]);
	OUT_VERTEX(src_y[2] * intel->scale_units[src_unit][1]);
	if (!is_affine_src) {
		OUT_VERTEX(0.0);
		OUT_VERTEX(src_w[2]);
	}
	if (intel->render_mask) {
		OUT_VERTEX(mask_x[2] * intel->scale_units[mask_unit][0]);
		OUT_VERTEX(mask_y[2] * intel->scale_units[mask_unit][1]);
		if (!is_affine_mask) {
			OUT_VERTEX(0.0);
			OUT_VERTEX(mask_w[2]);
		}
	}

	OUT_VERTEX(dstX);
	OUT_VERTEX(dstY + h);
	OUT_VERTEX(src_x[1] * intel->scale_units[src_unit][0]);
	OUT_VERTEX(src_y[1] * intel->scale_units[src_unit][1]);
	if (!is_affine_src) {
		OUT_VERTEX(0.0);
		OUT_VERTEX(src_w[1]);
	}
	if (intel->render_mask) {
		OUT_VERTEX(mask_x[1] * intel->scale_units[mask_unit][0]);
		OUT_VERTEX(mask_y[1] * intel->scale_units[mask_unit][1]);
		if (!is_affine_mask) {
			OUT_VERTEX(0.0);
			OUT_VERTEX(mask_w[1]);
		}
	}

	OUT_VERTEX(dstX);
	OUT_VERTEX(dstY);
	OUT_VERTEX(src_x[0] * intel->scale_units[src_unit][0]);
	OUT_VERTEX(src_y[0] * intel->scale_units[src_unit][1]);
	if (!is_affine_src) {
		OUT_VERTEX(0.0);
		OUT_VERTEX(src_w[0]);
	}
	if (intel->render_mask) {
		OUT_VERTEX(mask_x[0] * intel->scale_units[mask_unit][0]);
		OUT_VERTEX(mask_y[0] * intel->scale_units[mask_unit][1]);
		if (!is_affine_mask) {
			OUT_VERTEX(0.0);
			OUT_VERTEX(mask_w[0]);
		}
	}
}

Bool
i915_prepare_composite(int op, PicturePtr source_picture,
		       PicturePtr mask_picture, PicturePtr dest_picture,
		       PixmapPtr source, PixmapPtr mask, PixmapPtr dest)
{
	ScrnInfoPtr scrn = xf86ScreenToScrn(dest_picture->pDrawable->pScreen);
	intel_screen_private *intel = intel_get_screen_private(scrn);
	drm_intel_bo *bo_table[] = {
		NULL,		/* batch_bo */
		intel_get_pixmap_bo(dest),
		intel_get_pixmap_bo(source),
		mask ? intel_get_pixmap_bo(mask) : NULL,
	};
	int tex_unit = 0;
	int floats_per_vertex;

	intel->render_source_picture = source_picture;
	intel->render_source = source;
	intel->render_mask_picture = mask_picture;
	intel->render_mask = mask;
	intel->render_dest_picture = dest_picture;
	intel->render_dest = dest;

	if (!intel_check_pitch_3d(source))
		return FALSE;

	if (mask && !intel_check_pitch_3d(mask))
		return FALSE;

	if (!intel_check_pitch_3d(dest))
		return FALSE;

	if (!i915_get_dest_format(dest_picture,
				  &intel->i915_render_state.dst_format))
		return FALSE;

	if (!intel_get_aperture_space(scrn, bo_table, ARRAY_SIZE(bo_table)))
		return FALSE;

	if (mask_picture != NULL && mask_picture->componentAlpha &&
	    PICT_FORMAT_RGB(mask_picture->format)) {
		/* Check if it's component alpha that relies on a source alpha
		 * and on the source value.  We can only get one of those
		 * into the single source value that we get to blend with.
		 */
		if (i915_blend_op[op].src_alpha &&
		    (i915_blend_op[op].src_blend != BLENDFACT_ZERO))
			return FALSE;
	}

	intel->transform[0] = NULL;
	intel->scale_units[0][0] = -1;
	intel->scale_units[0][1] = -1;
	intel->transform[1] = NULL;
	intel->scale_units[1][0] = -1;
	intel->scale_units[1][1] = -1;

	floats_per_vertex = 2;		/* dest x/y */
	if (!i915_texture_setup(source_picture, source, tex_unit++)) {
		intel_debug_fallback(scrn, "fail to setup src texture\n");
		return FALSE;
	}

	if (intel_transform_is_affine(source_picture->transform))
		floats_per_vertex += 2;	/* src x/y */
	else
		floats_per_vertex += 4;	/* src x/y/z/w */

	if (mask_picture != NULL) {
		assert(mask != NULL);
		if (!i915_texture_setup(mask_picture, mask, tex_unit++)) {
			intel_debug_fallback(scrn,
					     "fail to setup mask texture\n");
			return FALSE;
		}

		if (intel_transform_is_affine(mask_picture->transform))
			floats_per_vertex += 2;	/* mask x/y */
		else
			floats_per_vertex += 4;	/* mask x/y/z/w */
	}

	intel->i915_render_state.op = op;

	if (intel_pixmap_is_dirty(source) || intel_pixmap_is_dirty(mask))
		intel_batch_emit_flush(scrn);

	intel->needs_render_state_emit = TRUE;

	intel->prim_emit = i915_emit_composite_primitive;
	if (!mask) {
		if (intel->transform[0] == NULL)
			intel->prim_emit = i915_emit_composite_primitive_identity_source;
		else if (intel_transform_is_affine(intel->transform[0]))
			intel->prim_emit = i915_emit_composite_primitive_affine_source;
	} else {
		if (intel->transform[0] == NULL) {
			if (intel->transform[1] == NULL)
				intel->prim_emit = i915_emit_composite_primitive_identity_source_mask;
		}
	}

	if (floats_per_vertex != intel->floats_per_vertex) {
		intel->floats_per_vertex = floats_per_vertex;
		intel->needs_render_vertex_emit = TRUE;
	}

	return TRUE;
}

static void
i915_composite_emit_shader(intel_screen_private *intel, CARD8 op)
{
	PicturePtr mask_picture = intel->render_mask_picture;
	PixmapPtr mask = intel->render_mask;
	int src_reg, mask_reg;
	Bool dest_is_alpha = PIXMAN_FORMAT_RGB(intel->render_dest_picture->format) == 0;
	FS_LOCALS();

	FS_BEGIN();

	/* Declare the registers necessary for our program.  */
	i915_fs_dcl(FS_T0);
	i915_fs_dcl(FS_S0);
	if (!mask) {
		/* No mask, so load directly to output color */
		if (dest_is_alpha)
			src_reg = FS_R0;
		else
			src_reg = FS_OC;

		if (intel_transform_is_affine(intel->transform[0]))
			i915_fs_texld(src_reg, FS_S0, FS_T0);
		else
			i915_fs_texldp(src_reg, FS_S0, FS_T0);

		if (src_reg != FS_OC)
			i915_fs_mov(FS_OC, i915_fs_operand(src_reg, W, W, W, W));
	} else {
		i915_fs_dcl(FS_T1);
		i915_fs_dcl(FS_S1);

		/* Load the source_picture texel */
		if (intel_transform_is_affine(intel->transform[0]))
			i915_fs_texld(FS_R0, FS_S0, FS_T0);
		else
			i915_fs_texldp(FS_R0, FS_S0, FS_T0);

		src_reg = FS_R0;

		/* Load the mask_picture texel */
		if (intel_transform_is_affine(intel->transform[1]))
			i915_fs_texld(FS_R1, FS_S1, FS_T1);
		else
			i915_fs_texldp(FS_R1, FS_S1, FS_T1);

		mask_reg = FS_R1;

		if (dest_is_alpha) {
			i915_fs_mul(FS_OC,
				    i915_fs_operand(src_reg, W, W, W, W),
				    i915_fs_operand(mask_reg, W, W, W, W));
		} else {
			/* If component alpha is active in the mask and the blend
			 * operation uses the source alpha, then we know we don't
			 * need the source value (otherwise we would have hit a
			 * fallback earlier), so we provide the source alpha (src.A *
			 * mask.X) as output color.
			 * Conversely, if CA is set and we don't need the source alpha,
			 * then we produce the source value (src.X * mask.X) and the
			 * source alpha is unused.  Otherwise, we provide the non-CA
			 * source value (src.X * mask.A).
			 */
			if (mask_picture->componentAlpha &&
			    PICT_FORMAT_RGB(mask_picture->format)) {
				if (i915_blend_op[op].src_alpha) {
					i915_fs_mul(FS_OC,
						    i915_fs_operand(src_reg, W, W, W, W),
						    i915_fs_operand_reg(mask_reg));
				} else {
					i915_fs_mul(FS_OC,
						    i915_fs_operand_reg(src_reg),
						    i915_fs_operand_reg(mask_reg));
				}
			} else {
				i915_fs_mul(FS_OC,
					    i915_fs_operand_reg(src_reg),
					    i915_fs_operand(mask_reg, W, W, W, W));
			}
		}
	}

	FS_END();
}

static void i915_emit_composite_setup(ScrnInfoPtr scrn)
{
	intel_screen_private *intel = intel_get_screen_private(scrn);
	int op = intel->i915_render_state.op;
	PicturePtr mask_picture = intel->render_mask_picture;
	PicturePtr dest_picture = intel->render_dest_picture;
	PixmapPtr mask = intel->render_mask;
	PixmapPtr dest = intel->render_dest;
	int tex_count, t;

	intel->needs_render_state_emit = FALSE;

	IntelEmitInvarientState(scrn);
	intel->last_3d = LAST_3D_RENDER;

	tex_count = 1 + (mask != NULL);

	assert(intel->in_batch_atomic);

	if (tex_count != 0) {
	    OUT_BATCH(_3DSTATE_MAP_STATE | (3 * tex_count));
	    OUT_BATCH((1 << tex_count) - 1);
	    for (t = 0; t < tex_count; t++) {
		OUT_RELOC_PIXMAP(intel->texture[t], I915_GEM_DOMAIN_SAMPLER, 0, 0);
		OUT_BATCH(intel->mapstate[3*t + 1]);
		OUT_BATCH(intel->mapstate[3*t + 2]);
	    }

	    OUT_BATCH(_3DSTATE_SAMPLER_STATE | (3 * tex_count));
	    OUT_BATCH((1 << tex_count) - 1);
	    for (t = 0; t < tex_count; t++) {
		OUT_BATCH(intel->samplerstate[3*t + 0]);
		OUT_BATCH(intel->samplerstate[3*t + 1]);
		OUT_BATCH(intel->samplerstate[3*t + 2]);
	    }
	}

	/* BUF_INFO is an implicit flush, so avoid if the target has not changed.
	 * XXX However for reasons unfathomed, correct rendering in KDE requires
	 * at least a MI_FLUSH | INHIBIT_RENDER_CACHE_FLUSH here.
	 */
	if (1) {
		uint32_t tiling_bits;

		if (intel_pixmap_tiled(dest)) {
			tiling_bits = BUF_3D_TILED_SURFACE;
			if (intel_get_pixmap_private(dest)->tiling
			    == I915_TILING_Y)
				tiling_bits |= BUF_3D_TILE_WALK_Y;
		} else
			tiling_bits = 0;

		OUT_BATCH(_3DSTATE_BUF_INFO_CMD);
		OUT_BATCH(BUF_3D_ID_COLOR_BACK | tiling_bits |
			  BUF_3D_PITCH(intel_pixmap_pitch(dest)));
		OUT_RELOC_PIXMAP(dest, I915_GEM_DOMAIN_RENDER,
				 I915_GEM_DOMAIN_RENDER, 0);

		OUT_BATCH(_3DSTATE_DST_BUF_VARS_CMD);
		OUT_BATCH(intel->i915_render_state.dst_format);

		/* draw rect is unconditional */
		OUT_BATCH(_3DSTATE_DRAW_RECT_CMD);
		OUT_BATCH(0x00000000);
		OUT_BATCH(0x00000000);	/* ymin, xmin */
		OUT_BATCH(DRAW_YMAX(dest->drawable.height - 1) |
			  DRAW_XMAX(dest->drawable.width - 1));
		/* yorig, xorig (relate to color buffer?) */
		OUT_BATCH(0x00000000);
	}

	{
		uint32_t ss2;

		ss2 = ~0;
		ss2 &= ~S2_TEXCOORD_FMT(0, TEXCOORDFMT_NOT_PRESENT);
		ss2 |= S2_TEXCOORD_FMT(0,
				       intel_transform_is_affine(intel->transform[0]) ?
				       TEXCOORDFMT_2D : TEXCOORDFMT_4D);
		if (mask) {
		    ss2 &= ~S2_TEXCOORD_FMT(1, TEXCOORDFMT_NOT_PRESENT);
		    ss2 |= S2_TEXCOORD_FMT(1,
					   intel_transform_is_affine(intel->transform[1]) ?
					   TEXCOORDFMT_2D : TEXCOORDFMT_4D);
		}

		OUT_BATCH(_3DSTATE_LOAD_STATE_IMMEDIATE_1 | I1_LOAD_S(2) | I1_LOAD_S(6) | 1);
		OUT_BATCH(ss2);
		OUT_BATCH(i915_get_blend_cntl(op, mask_picture, dest_picture->format));
	}

	i915_composite_emit_shader(intel, op);
}

void
i915_composite(PixmapPtr dest, int srcX, int srcY, int maskX, int maskY,
	       int dstX, int dstY, int w, int h)
{
	ScrnInfoPtr scrn = xf86ScreenToScrn(dest->drawable.pScreen);
	intel_screen_private *intel = intel_get_screen_private(scrn);

	/* 28 + 16 + 10 + 20 + 32 + 16 */
	intel_batch_start_atomic(scrn, 150);

	if (intel->needs_render_state_emit)
		i915_emit_composite_setup(scrn);

	if (intel->needs_render_vertex_emit ||
	    intel_vertex_space(intel) < 3*4*intel->floats_per_vertex) {
		i915_vertex_flush(intel);

		if (intel_vertex_space(intel) < 256) {
			intel_next_vertex(intel);

			OUT_BATCH(_3DSTATE_LOAD_STATE_IMMEDIATE_1 |
				  I1_LOAD_S(0) | I1_LOAD_S(1) | 1);
			OUT_RELOC(intel->vertex_bo, I915_GEM_DOMAIN_VERTEX, 0, 0);
			OUT_BATCH((intel->floats_per_vertex << S1_VERTEX_WIDTH_SHIFT) |
				  (intel->floats_per_vertex << S1_VERTEX_PITCH_SHIFT));
			intel->vertex_index = 0;
		} else if (intel->floats_per_vertex != intel->last_floats_per_vertex){
			OUT_BATCH(_3DSTATE_LOAD_STATE_IMMEDIATE_1 |
				  I1_LOAD_S(1) | 0);
			OUT_BATCH((intel->floats_per_vertex << S1_VERTEX_WIDTH_SHIFT) |
				  (intel->floats_per_vertex << S1_VERTEX_PITCH_SHIFT));

			intel->vertex_index =
				(intel->vertex_used + intel->floats_per_vertex - 1) /  intel->floats_per_vertex;
			intel->vertex_used = intel->vertex_index * intel->floats_per_vertex;
		}

		intel->last_floats_per_vertex = intel->floats_per_vertex;
		intel->needs_render_vertex_emit = FALSE;
	}

	if (intel->prim_offset == 0) {
		intel->prim_offset = intel->batch_used;
		OUT_BATCH(PRIM3D_RECTLIST | PRIM3D_INDIRECT_SEQUENTIAL);
		OUT_BATCH(intel->vertex_index);
	}
	intel->vertex_count += 3;

	intel->prim_emit(intel,
			 srcX, srcY,
			 maskX, maskY,
			 dstX, dstY,
			 w, h);

	intel_batch_end_atomic(scrn);
}

void
i915_vertex_flush(intel_screen_private *intel)
{
	if (intel->prim_offset == 0)
		return;

	intel->batch_ptr[intel->prim_offset] |= intel->vertex_count;
	intel->prim_offset = 0;

	intel->vertex_index += intel->vertex_count;
	intel->vertex_count = 0;
}

void
i915_batch_commit_notify(intel_screen_private *intel)
{
	intel->needs_render_state_emit = TRUE;
	intel->last_floats_per_vertex = 0;
}
@


1.7
log
@Update to xf86-video-intel 2.20.19.

A recent kernel with kernel modesetting support is required.
Thanks to jsg@@ and kettenis@@ for their work.
@
text
@@


1.6
log
@Update the intel driver to a more recent version based on more recent
upsteam code.

Backporting keeping UMS changes by me, some bugfixes from kettenis@@.

Has been in snapshots for a while, committed on request so we can be
sure what people are running. This is a prerequesite for sandybridge
support but has those chipsets disabled for now until the correct code
has been added.
@
text
@d85 1
d88 1
d161 1
d166 1
d175 1
a175 1
		scrn = xf86Screens[dest_picture->pDrawable->pScreen->myNum];
d192 1
a192 1
	ScrnInfoPtr scrn = xf86Screens[dest_picture->pDrawable->pScreen->myNum];
d246 1
a246 1
		ScrnInfoPtr scrn = xf86Screens[screen->myNum];
d254 1
a254 1
		ScrnInfoPtr scrn = xf86Screens[screen->myNum];
d260 2
a261 5
	if (picture->pSourcePict) {
		SourcePict *source = picture->pSourcePict;
		if (source->type == SourcePictTypeSolidFill)
			return TRUE;
	}
d269 1
a269 1
			ScrnInfoPtr scrn = xf86Screens[screen->myNum];
d284 1
a284 1
			ScrnInfoPtr scrn = xf86Screens[screen->myNum];
d299 1
a299 1
	ScrnInfoPtr scrn = xf86Screens[picture->pDrawable->pScreen->myNum];
a346 1
		filter = 0;
a385 17
i915_emit_composite_primitive_constant(intel_screen_private *intel,
				       int srcX, int srcY,
				       int maskX, int maskY,
				       int dstX, int dstY,
				       int w, int h)
{
	OUT_VERTEX(dstX + w);
	OUT_VERTEX(dstY + h);

	OUT_VERTEX(dstX);
	OUT_VERTEX(dstY + h);

	OUT_VERTEX(dstX);
	OUT_VERTEX(dstY);
}

static void
a451 23
i915_emit_composite_primitive_constant_identity_mask(intel_screen_private *intel,
						     int srcX, int srcY,
						     int maskX, int maskY,
						     int dstX, int dstY,
						     int w, int h)
{
	OUT_VERTEX(dstX + w);
	OUT_VERTEX(dstY + h);
	OUT_VERTEX((maskX + w) * intel->scale_units[0][0]);
	OUT_VERTEX((maskY + h) * intel->scale_units[0][1]);

	OUT_VERTEX(dstX);
	OUT_VERTEX(dstY + h);
	OUT_VERTEX(maskX * intel->scale_units[0][0]);
	OUT_VERTEX((maskY + h) * intel->scale_units[0][1]);

	OUT_VERTEX(dstX);
	OUT_VERTEX(dstY);
	OUT_VERTEX(maskX * intel->scale_units[0][0]);
	OUT_VERTEX(maskY * intel->scale_units[0][1]);
}

static void
a487 1
	int per_vertex;
d492 1
a492 1
	per_vertex = 2;		/* dest x/y */
d494 46
a539 54
	if (! intel->render_source_is_solid) {
		src_unit = tex_unit++;

		is_affine_src = intel_transform_is_affine(intel->transform[src_unit]);
		if (is_affine_src) {
			if (!intel_get_transformed_coordinates(srcX, srcY,
							      intel->
							      transform[src_unit],
							      &src_x[0],
							      &src_y[0]))
				return;

			if (!intel_get_transformed_coordinates(srcX, srcY + h,
							      intel->
							      transform[src_unit],
							      &src_x[1],
							      &src_y[1]))
				return;

			if (!intel_get_transformed_coordinates(srcX + w, srcY + h,
							      intel->
							      transform[src_unit],
							      &src_x[2],
							      &src_y[2]))
				return;

			per_vertex += 2;	/* src x/y */
		} else {
			if (!intel_get_transformed_coordinates_3d(srcX, srcY,
								 intel->
								 transform[src_unit],
								 &src_x[0],
								 &src_y[0],
								 &src_w[0]))
				return;

			if (!intel_get_transformed_coordinates_3d(srcX, srcY + h,
								 intel->
								 transform[src_unit],
								 &src_x[1],
								 &src_y[1],
								 &src_w[1]))
				return;

			if (!intel_get_transformed_coordinates_3d(srcX + w, srcY + h,
								 intel->
								 transform[src_unit],
								 &src_x[2],
								 &src_y[2],
								 &src_w[2]))
				return;

			per_vertex += 4;	/* src x/y/z/w */
		}
d542 1
a542 1
	if (intel->render_mask && ! intel->render_mask_is_solid) {
a566 2

			per_vertex += 2;	/* mask x/y */
a590 2

			per_vertex += 4;	/* mask x/y/z/w */
d596 3
a598 4
	if (! intel->render_source_is_solid) {
	    OUT_VERTEX(src_x[2] * intel->scale_units[src_unit][0]);
	    OUT_VERTEX(src_y[2] * intel->scale_units[src_unit][1]);
	    if (!is_affine_src) {
a600 1
	    }
d602 1
a602 1
	if (intel->render_mask && ! intel->render_mask_is_solid) {
d613 3
a615 4
	if (! intel->render_source_is_solid) {
	    OUT_VERTEX(src_x[1] * intel->scale_units[src_unit][0]);
	    OUT_VERTEX(src_y[1] * intel->scale_units[src_unit][1]);
	    if (!is_affine_src) {
a617 1
	    }
d619 1
a619 1
	if (intel->render_mask && ! intel->render_mask_is_solid) {
d630 3
a632 4
	if (! intel->render_source_is_solid) {
	    OUT_VERTEX(src_x[0] * intel->scale_units[src_unit][0]);
	    OUT_VERTEX(src_y[0] * intel->scale_units[src_unit][1]);
	    if (!is_affine_src) {
a634 1
	    }
d636 1
a636 1
	if (intel->render_mask && ! intel->render_mask_is_solid) {
d651 1
a651 1
	ScrnInfoPtr scrn = xf86Screens[dest_picture->pDrawable->pScreen->myNum];
d656 1
a656 1
		source ? intel_get_pixmap_bo(source) : NULL,
d669 1
a669 9
	intel->render_source_is_solid = FALSE;
	if (source_picture->pSourcePict) {
		SourcePict *source = source_picture->pSourcePict;
		if (source->type == SourcePictTypeSolidFill) {
			intel->render_source_is_solid = TRUE;
			intel->render_source_solid = source->solidFill.color;
		}
	}
	if (!intel->render_source_is_solid && !intel_check_pitch_3d(source))
d672 2
a673 12
	intel->render_mask_is_solid = FALSE;
	if (mask) {
		if (mask_picture->pSourcePict) {
			SourcePict *source = mask_picture->pSourcePict;
			if (source->type == SourcePictTypeSolidFill) {
				intel->render_mask_is_solid = TRUE;
				intel->render_mask_solid = source->solidFill.color;
			}
		}
		if (!intel->render_mask_is_solid && !intel_check_pitch_3d(mask))
			return FALSE;
	}
a684 1
	intel->needs_render_ca_pass = FALSE;
d692 2
a693 6
		    (i915_blend_op[op].src_blend != BLENDFACT_ZERO)) {
			if (op != PictOpOver)
				return FALSE;

			intel->needs_render_ca_pass = TRUE;
		}
d704 15
a718 3
	if (! intel->render_source_is_solid) {
		if (!i915_texture_setup(source_picture, source, tex_unit++)) {
			intel_debug_fallback(scrn, "fail to setup src texture\n");
d722 2
a723 2
		if (intel_transform_is_affine(source_picture->transform))
			floats_per_vertex += 2;	/* src x/y */
d725 1
a725 16
			floats_per_vertex += 4;	/* src x/y/z/w */
	}

	if (mask != NULL) {
		if (! intel->render_mask_is_solid) {
			if (!i915_texture_setup(mask_picture, mask, tex_unit++)) {
				intel_debug_fallback(scrn,
						"fail to setup mask texture\n");
				return FALSE;
			}

			if (intel_transform_is_affine(mask_picture->transform))
				floats_per_vertex += 2;	/* mask x/y */
			else
				floats_per_vertex += 4;	/* mask x/y/z/w */
		}
d730 1
a730 5
	/* BUF_INFO is an implicit flush */
	if (dest != intel->render_current_dest)
		intel_batch_do_flush(scrn);
	else if((source && intel_pixmap_is_dirty(source)) ||
		(mask && intel_pixmap_is_dirty(mask)))
d737 1
a737 3
		if (intel->render_source_is_solid)
			intel->prim_emit = i915_emit_composite_primitive_constant;
		else if (intel->transform[0] == NULL)
d743 1
a743 3
			if (intel->render_source_is_solid)
				intel->prim_emit = i915_emit_composite_primitive_constant_identity_mask;
			else if (intel->transform[1] == NULL)
a761 1
	Bool is_solid_src, is_solid_mask;
a762 1
	int tex_unit, t;
a764 3
	is_solid_src = intel->render_source_is_solid;
	is_solid_mask = intel->render_mask_is_solid;

d768 2
a769 9
	t = 0;
	if (is_solid_src) {
		i915_fs_dcl(FS_T8);
		src_reg = FS_T8;
	} else {
		i915_fs_dcl(FS_T0);
		i915_fs_dcl(FS_S0);
		t++;
	}
d772 9
a780 11
		if (! is_solid_src) {
			if (dest_is_alpha)
				src_reg = FS_R0;
			else
				src_reg = FS_OC;

			if (intel_transform_is_affine(intel->transform[0]))
				i915_fs_texld(src_reg, FS_S0, FS_T0);
			else
				i915_fs_texldp(src_reg, FS_S0, FS_T0);
		}
d782 2
a783 6
		if (src_reg != FS_OC) {
			if (dest_is_alpha)
				i915_fs_mov(FS_OC, i915_fs_operand(src_reg, W, W, W, W));
			else
				i915_fs_mov(FS_OC, i915_fs_operand_reg(src_reg));
		}
d785 2
a786 7
		if (is_solid_mask) {
			i915_fs_dcl(FS_T9);
			mask_reg = FS_T9;
		} else {
			i915_fs_dcl(FS_T0 + t);
			i915_fs_dcl(FS_S0 + t);
		}
d788 5
a792 7
		tex_unit = 0;
		if (! is_solid_src) {
			/* Load the source_picture texel */
			if (intel_transform_is_affine(intel->transform[tex_unit]))
				i915_fs_texld(FS_R0, FS_S0, FS_T0);
			else
				i915_fs_texldp(FS_R0, FS_S0, FS_T0);
d794 1
a794 3
			src_reg = FS_R0;
			tex_unit++;
		}
d796 5
a800 6
		if (! is_solid_mask) {
			/* Load the mask_picture texel */
			if (intel_transform_is_affine(intel->transform[tex_unit]))
				i915_fs_texld(FS_R1, FS_S0 + t, FS_T0 + t);
			else
				i915_fs_texldp(FS_R1, FS_S0 + t, FS_T0 + t);
d802 1
a802 2
			mask_reg = FS_R1;
		}
a848 1
	Bool is_solid_src, is_solid_mask;
d856 1
a856 6
	is_solid_src = intel->render_source_is_solid;
	is_solid_mask = intel->render_mask_is_solid;

	tex_count = 0;
	tex_count += ! is_solid_src;
	tex_count += mask && ! is_solid_mask;
a877 9
	if (is_solid_src) {
	    OUT_BATCH (_3DSTATE_DFLT_DIFFUSE_CMD);
	    OUT_BATCH (intel->render_source_solid);
	}
	if (mask && is_solid_mask) {
	    OUT_BATCH (_3DSTATE_DFLT_SPEC_CMD);
	    OUT_BATCH (intel->render_mask_solid);
	}

d882 1
a882 1
	if (1 || dest != intel->render_current_dest) {
a884 2
		intel_batch_do_flush(scrn);

a909 2

		intel->render_current_dest = dest;
d916 8
a923 5
		t = 0;
		if (! is_solid_src) {
		    ss2 &= ~S2_TEXCOORD_FMT(t, TEXCOORDFMT_NOT_PRESENT);
		    ss2 |= S2_TEXCOORD_FMT(t,
					   intel_transform_is_affine(intel->transform[t]) ?
a924 8
		    t++;
		}
		if (mask && ! is_solid_mask) {
		    ss2 &= ~S2_TEXCOORD_FMT(t, TEXCOORDFMT_NOT_PRESENT);
		    ss2 |= S2_TEXCOORD_FMT(t,
					   intel_transform_is_affine(intel->transform[t]) ?
					   TEXCOORDFMT_2D : TEXCOORDFMT_4D);
		    t++;
d927 3
a929 8
		if (intel->needs_render_ca_pass) {
			OUT_BATCH(_3DSTATE_LOAD_STATE_IMMEDIATE_1 | I1_LOAD_S(2) | 0);
			OUT_BATCH(ss2);
		} else {
			OUT_BATCH(_3DSTATE_LOAD_STATE_IMMEDIATE_1 | I1_LOAD_S(2) | I1_LOAD_S(6) | 1);
			OUT_BATCH(ss2);
			OUT_BATCH(i915_get_blend_cntl(op, mask_picture, dest_picture->format));
		}
d932 1
a932 2
	if (! intel->needs_render_ca_pass)
		i915_composite_emit_shader(intel, op);
d939 1
a939 1
	ScrnInfoPtr scrn = xf86Screens[dest->drawable.pScreen->myNum];
a976 8
		if (intel->needs_render_ca_pass) {
			OUT_BATCH(_3DSTATE_LOAD_STATE_IMMEDIATE_1 | I1_LOAD_S(6) | 0);
			OUT_BATCH(i915_get_blend_cntl(PictOpOutReverse,
						      intel->render_mask_picture,
						      intel->render_dest_picture->format));
			i915_composite_emit_shader(intel, PictOpOutReverse);
		}

a1000 10
	if (intel->needs_render_ca_pass) {
		OUT_BATCH(_3DSTATE_LOAD_STATE_IMMEDIATE_1 | I1_LOAD_S(6) | 0);
		OUT_BATCH(i915_get_blend_cntl(PictOpAdd,
					      intel->render_mask_picture,
					      intel->render_dest_picture->format));
		i915_composite_emit_shader(intel, PictOpAdd);
		OUT_BATCH(PRIM3D_RECTLIST | PRIM3D_INDIRECT_SEQUENTIAL | intel->vertex_count);
		OUT_BATCH(intel->vertex_index);
	}

a1008 1
	intel->render_current_dest = NULL;
@


1.5
log
@Update the intel driver to (mostly) a backport of 2.12.

It is missing a few commits that I have yet to verify (ones that try and
continue if we lock the gpu rendering engine and can't reset it, for
example) taht will be verified and sent out for extra testing soon.

Should contain a bunch of speedups and some correctness improvements
(though rendercheck still gives some errors that I am looking into).

This has been in snaps since the first day of c2k10, any known issues
with just this driver have (to my knowledge) been fixed since. A problem
with macbooks pointed out by otto happens with both this and the in-tree
driver and thus doesn't stop this moving forward.

As well as the 2.12 improvements, this driver also has a backport
(partially aided by the backports in RHEL 5 kindly provided by Dave
Airlie) from the kms code of modesetting support for ironlake (arrandale
and clarkdale: the IGDs build into intel nehalem cpu dies) which has
been tested on a number of chipsets. Note that Display port and eDP
displays have not yet been worked on (and probably won't until I can
find a displayport monitor), but VGA and lvds at least are known to
work, sure beats vesa.

"no objection on my side" matthieu@@, prodding (as always) from princess
marco.
@
text
@d34 1
a34 1
#include "i830.h"
d80 1
d85 2
a88 1
	{PICT_x1r5g5b5, MAPSURF_16BIT | MT_16BIT_ARGB1555},
a89 2
	{PICT_x4r4g4b4, MAPSURF_16BIT | MT_16BIT_ARGB4444},
	{PICT_a8, MAPSURF_8BIT | MT_8BIT_A8},
d159 4
a300 1
	int w, h, i;
d302 1
d304 1
a304 3
	pitch = intel_get_pixmap_pitch(pixmap);
	w = picture->pDrawable->width;
	h = picture->pDrawable->height;
d353 1
a353 1
	if (i830_pixmap_tiled(pixmap)) {
d355 1
a355 1
		if (i830_get_pixmap_intel(pixmap)->tiling
d386 1
a386 1
i915_emit_composite_primitive_constant(PixmapPtr dest,
a391 3
	ScrnInfoPtr scrn = xf86Screens[dest->drawable.pScreen->myNum];
	intel_screen_private *intel = intel_get_screen_private(scrn);

d403 1
a403 1
i915_emit_composite_primitive_identity_source(PixmapPtr dest,
a408 3
	ScrnInfoPtr scrn = xf86Screens[dest->drawable.pScreen->myNum];
	intel_screen_private *intel = intel_get_screen_private(scrn);

d426 1
a426 1
i915_emit_composite_primitive_affine_source(PixmapPtr dest,
a431 2
	ScrnInfoPtr scrn = xf86Screens[dest->drawable.pScreen->myNum];
	intel_screen_private *intel = intel_get_screen_private(scrn);
d434 1
a434 1
	if (!i830_get_transformed_coordinates(srcX, srcY,
d440 1
a440 1
	if (!i830_get_transformed_coordinates(srcX, srcY + h,
d446 1
a446 1
	if (!i830_get_transformed_coordinates(srcX + w, srcY + h,
d469 1
a469 1
i915_emit_composite_primitive_constant_identity_mask(PixmapPtr dest,
a474 3
	ScrnInfoPtr scrn = xf86Screens[dest->drawable.pScreen->myNum];
	intel_screen_private *intel = intel_get_screen_private(scrn);

d492 1
a492 1
i915_emit_composite_primitive_identity_source_mask(PixmapPtr dest,
a497 3
	ScrnInfoPtr scrn = xf86Screens[dest->drawable.pScreen->myNum];
	intel_screen_private *intel = intel_get_screen_private(scrn);

d521 1
a521 1
i915_emit_composite_primitive(PixmapPtr dest,
d527 2
a528 4
	ScrnInfoPtr scrn = xf86Screens[dest->drawable.pScreen->myNum];
	intel_screen_private *intel = intel_get_screen_private(scrn);
	Bool is_affine_src, is_affine_mask = TRUE;
	int per_vertex, num_floats;
d538 1
a538 1
		is_affine_src = i830_transform_is_affine(intel->transform[src_unit]);
d540 1
a540 1
			if (!i830_get_transformed_coordinates(srcX, srcY,
d547 1
a547 1
			if (!i830_get_transformed_coordinates(srcX, srcY + h,
d554 1
a554 1
			if (!i830_get_transformed_coordinates(srcX + w, srcY + h,
d563 1
a563 1
			if (!i830_get_transformed_coordinates_3d(srcX, srcY,
d571 1
a571 1
			if (!i830_get_transformed_coordinates_3d(srcX, srcY + h,
d579 1
a579 1
			if (!i830_get_transformed_coordinates_3d(srcX + w, srcY + h,
d594 1
a594 1
		is_affine_mask = i830_transform_is_affine(intel->transform[mask_unit]);
d596 1
a596 1
			if (!i830_get_transformed_coordinates(maskX, maskY,
d603 1
a603 1
			if (!i830_get_transformed_coordinates(maskX, maskY + h,
d610 1
a610 1
			if (!i830_get_transformed_coordinates(maskX + w, maskY + h,
d619 1
a619 1
			if (!i830_get_transformed_coordinates_3d(maskX, maskY,
d627 1
a627 1
			if (!i830_get_transformed_coordinates_3d(maskX, maskY + h,
d635 1
a635 1
			if (!i830_get_transformed_coordinates_3d(maskX + w, maskY + h,
a646 2
	num_floats = 3 * per_vertex;

d714 3
a716 3
		i830_get_pixmap_bo(dest),
		source ? i830_get_pixmap_bo(source) : NULL,
		mask ? i830_get_pixmap_bo(mask) : NULL,
d759 1
a759 1
	if (!i830_get_aperture_space(scrn, bo_table, ARRAY_SIZE(bo_table)))
d792 1
a792 1
		if (i830_transform_is_affine(source_picture->transform))
d806 1
a806 1
			if (i830_transform_is_affine(mask_picture->transform))
d818 2
a819 2
	else if((source && i830_uxa_pixmap_is_dirty(source)) ||
		(mask && i830_uxa_pixmap_is_dirty(mask)))
d830 1
a830 1
		else if (i830_transform_is_affine(intel->transform[0]))
d883 1
a883 1
			if (i830_transform_is_affine(intel->transform[0]))
d907 1
a907 1
			if (i830_transform_is_affine(intel->transform[tex_unit]))
d918 1
a918 1
			if (i830_transform_is_affine(intel->transform[tex_unit]))
d1024 1
a1024 1
		if (i830_pixmap_tiled(dest)) {
d1026 1
a1026 1
			if (i830_get_pixmap_intel(dest)->tiling
d1034 1
a1034 1
			  BUF_3D_PITCH(intel_get_pixmap_pitch(dest)));
d1061 1
a1061 1
					   i830_transform_is_affine(intel->transform[t]) ?
d1068 1
a1068 1
					   i830_transform_is_affine(intel->transform[t]) ?
d1143 1
a1143 1
	intel->prim_emit(dest,
d1176 1
a1176 1
i915_batch_flush_notify(ScrnInfoPtr scrn)
a1177 2
	intel_screen_private *intel = intel_get_screen_private(scrn);

@


1.4
log
@Update the intel driver to 2.9.1 plus backports.

2.9.1 is the last version of the intel DDX that supports UMS (User
modesetting), with 2.10 onwards being purely KMS only. As such, this
driver contains backports of almost every correctness or performance
related fix to the rendering layer in later intel drivers. This driver
*REQUIRES* a GEM enabled kernel. it claims to support non-gem mode but
this is essentially unmaintained and due to the way the abstraciton
works is slow, if it works at all (it often does not). You have been
warned.

tested by many many people on tech over the last few weeks.
@
text
@a37 2
#define PIXEL_CENTRE_SAMPLE 0

d134 4
a137 2
	return (sblend << S6_CBUF_SRC_BLEND_FACT_SHIFT) |
	    (dblend << S6_CBUF_DST_BLEND_FACT_SHIFT);
a172 1
#if PIXEL_CENTRE_SAMPLE
a173 1
#endif
d177 59
a235 2
static Bool i915_check_composite_texture(ScrnInfoPtr scrn, PicturePtr picture,
					 int unit)
d238 1
d246 1
d252 6
d264 1
d279 1
a284 43
	}

	return TRUE;
}

Bool
i915_check_composite(int op, PicturePtr source_picture, PicturePtr mask_picture,
		     PicturePtr dest_picture)
{
	ScrnInfoPtr scrn = xf86Screens[dest_picture->pDrawable->pScreen->myNum];
	uint32_t tmp1;

	/* Check for unsupported compositing operations. */
	if (op >= sizeof(i915_blend_op) / sizeof(i915_blend_op[0])) {
		intel_debug_fallback(scrn, "Unsupported Composite op 0x%x\n",
				     op);
		return FALSE;
	}
	if (mask_picture != NULL && mask_picture->componentAlpha &&
	    PICT_FORMAT_RGB(mask_picture->format)) {
		/* Check if it's component alpha that relies on a source alpha
		 * and on the source value.  We can only get one of those
		 * into the single source value that we get to blend with.
		 */
		if (i915_blend_op[op].src_alpha &&
		    (i915_blend_op[op].src_blend != BLENDFACT_ZERO)) {
			intel_debug_fallback(scrn,
					     "Component alpha not supported "
					     "with source alpha and source "
					     "value blending.\n");
			return FALSE;
		}
	}

	if (!i915_check_composite_texture(scrn, source_picture, 0)) {
		intel_debug_fallback(scrn, "Check Src picture texture\n");
		return FALSE;
	}
	if (mask_picture != NULL
	    && !i915_check_composite_texture(scrn, mask_picture, 1)) {
		intel_debug_fallback(scrn, "Check Mask picture texture\n");
		return FALSE;
	}
d286 1
a286 3
	if (!i915_get_dest_format(dest_picture, &tmp1)) {
		intel_debug_fallback(scrn, "Get Color buffer format\n");
		return FALSE;
d289 1
a289 1
	return TRUE;
d303 2
a304 2
	intel->scale_units[unit][0] = pixmap->drawable.width;
	intel->scale_units[unit][1] = pixmap->drawable.height;
d383 6
a388 4
Bool
i915_prepare_composite(int op, PicturePtr source_picture,
		       PicturePtr mask_picture, PicturePtr dest_picture,
		       PixmapPtr source, PixmapPtr mask, PixmapPtr dest)
d390 1
a390 1
	ScrnInfoPtr scrn = xf86Screens[source_picture->pDrawable->pScreen->myNum];
a391 7
	drm_intel_bo *bo_table[] = {
		NULL,		/* batch_bo */
		i830_get_pixmap_bo(source),
		mask ? i830_get_pixmap_bo(mask) : NULL,
		i830_get_pixmap_bo(dest),
	};
	int tex_unit = 0;
d393 2
a394 6
	intel->render_source_picture = source_picture;
	intel->render_source = source;
	intel->render_mask_picture = mask_picture;
	intel->render_mask = mask;
	intel->render_dest_picture = dest_picture;
	intel->render_dest = dest;
d396 2
a397 15
	intel->render_source_is_solid =
	    source_picture->pDrawable &&
	    source_picture->pDrawable->width == 1 &&
	    source_picture->pDrawable->height == 1 &&
	    source_picture->repeat;

	if (intel->render_source_is_solid) {
	    if (! uxa_get_color_for_pixmap (source,
					    source_picture->format,
					    PICT_a8r8g8b8,
					    &intel->render_source_solid))
		intel->render_source_is_solid = FALSE;
	}
	if (!intel->render_source_is_solid && !intel_check_pitch_3d(source))
		return FALSE;
d399 3
d403 9
a411 17
	intel->render_mask_is_solid = TRUE; /* mask == NULL => opaque */
	if (mask) {
	    intel->render_mask_is_solid =
		mask_picture->pDrawable &&
		mask_picture->pDrawable->width == 1 &&
		mask_picture->pDrawable->height == 1 &&
		mask_picture->repeat;
	    if (intel->render_mask_is_solid) {
		if (! uxa_get_color_for_pixmap (mask,
						mask_picture->format,
						PICT_a8r8g8b8,
						&intel->render_mask_solid))
		    intel->render_mask_is_solid = FALSE;
	    }
	    if (!intel->render_mask_is_solid && !intel_check_pitch_3d(mask))
		    return FALSE;
	}
d413 15
a427 2
	if (!intel_check_pitch_3d(dest))
		return FALSE;
d429 10
a438 3
	if (!i915_get_dest_format(dest_picture,
				  &intel->i915_render_state.dst_format))
		return FALSE;
d440 33
a472 5
	if (!i830_get_aperture_space(scrn, bo_table, ARRAY_SIZE(bo_table)))
		return FALSE;
	intel->dst_coord_adjust = 0;
	intel->src_coord_adjust = 0;
	intel->mask_coord_adjust = 0;
d474 9
a482 6
	intel->transform[0] = NULL;
	intel->scale_units[0][0] = -1;
	intel->scale_units[0][1] = -1;
	intel->transform[1] = NULL;
	intel->scale_units[1][0] = -1;
	intel->scale_units[1][1] = -1;
d484 15
a498 5
	if (! intel->render_source_is_solid) {
		if (!i915_texture_setup(source_picture, source, tex_unit++)) {
			intel_debug_fallback(scrn, "fail to setup src texture\n");
			return FALSE;
		}
d500 9
a508 34
		if (source_picture->filter == PictFilterNearest) {
#if PIXEL_CENTRE_SAMPLE
			intel->src_coord_adjust = 0.375;
#else
			intel->dst_coord_adjust = -0.125;
#endif
		}
	}

	if (mask != NULL) {
		if (! intel->render_mask_is_solid) {
			if (!i915_texture_setup(mask_picture, mask, tex_unit++)) {
				intel_debug_fallback(scrn,
						"fail to setup mask texture\n");
				return FALSE;
			}

			if (mask_picture->filter == PictFilterNearest) {
#if PIXEL_CENTRE_SAMPLE
			    intel->mask_coord_adjust = 0.375;
#else
			    intel->dst_coord_adjust = -0.125;
#endif
			}
		}
	}

	intel->i915_render_state.op = op;

	if(i830_uxa_pixmap_is_dirty(source) ||
	   (mask && i830_uxa_pixmap_is_dirty(mask)))
		intel_batch_emit_flush(scrn);

	intel->needs_render_state_emit = TRUE;
d510 20
a529 1
	return TRUE;
d532 6
a537 1
static void i915_emit_composite_setup(ScrnInfoPtr scrn)
d539 1
d541 5
a545 10
	int op = intel->i915_render_state.op;
	PicturePtr mask_picture = intel->render_mask_picture;
	PicturePtr dest_picture = intel->render_dest_picture;
	PixmapPtr mask = intel->render_mask;
	PixmapPtr dest = intel->render_dest;
	uint32_t dst_format = intel->i915_render_state.dst_format, dst_pitch;
	uint32_t blendctl, tiling_bits;
	Bool is_affine_src, is_affine_mask;
	Bool is_solid_src, is_solid_mask;
	int tex_count, t;
d547 1
a547 1
	intel->needs_render_state_emit = FALSE;
d549 2
a550 2
	IntelEmitInvarientState(scrn);
	intel->last_3d = LAST_3D_RENDER;
d552 8
a559 1
	dst_pitch = intel_get_pixmap_pitch(dest);
d561 6
a566 2
	is_affine_src = i830_transform_is_affine(intel->transform[0]);
	is_affine_mask = i830_transform_is_affine(intel->transform[1]);
d568 6
a573 2
	is_solid_src = intel->render_source_is_solid;
	is_solid_mask = intel->render_mask_is_solid;
d575 9
a583 3
	tex_count = 0;
	tex_count += ! is_solid_src;
	tex_count += mask && ! is_solid_mask;
d585 7
a591 8
	t = 15;
	if (tex_count)
	    t += 6 * tex_count + 4;
	if (is_solid_src)
	    t += 2;
	if (mask && is_solid_mask)
	    t += 2;
	ATOMIC_BATCH (t);
d593 7
a599 8
	if (tex_count != 0) {
	    OUT_BATCH(_3DSTATE_MAP_STATE | (3 * tex_count));
	    OUT_BATCH((1 << tex_count) - 1);
	    for (t = 0; t < tex_count; t++) {
		OUT_RELOC_PIXMAP(intel->texture[t], I915_GEM_DOMAIN_SAMPLER, 0, 0);
		OUT_BATCH(intel->mapstate[3*t + 1]);
		OUT_BATCH(intel->mapstate[3*t + 2]);
	    }
d601 2
a602 7
	    OUT_BATCH(_3DSTATE_SAMPLER_STATE | (3 * tex_count));
	    OUT_BATCH((1 << tex_count) - 1);
	    for (t = 0; t < tex_count; t++) {
		OUT_BATCH(intel->samplerstate[3*t + 0]);
		OUT_BATCH(intel->samplerstate[3*t + 1]);
		OUT_BATCH(intel->samplerstate[3*t + 2]);
	    }
d605 6
a610 246
	if (is_solid_src) {
	    OUT_BATCH (_3DSTATE_DFLT_DIFFUSE_CMD);
	    OUT_BATCH (intel->render_source_solid);
	}
	if (mask && is_solid_mask) {
	    OUT_BATCH (_3DSTATE_DFLT_SPEC_CMD);
	    OUT_BATCH (intel->render_mask_solid);
	}

	if (i830_pixmap_tiled(dest)) {
		tiling_bits = BUF_3D_TILED_SURFACE;
		if (i830_get_pixmap_intel(dest)->tiling
				== I915_TILING_Y)
			tiling_bits |= BUF_3D_TILE_WALK_Y;
	} else
		tiling_bits = 0;

	OUT_BATCH(_3DSTATE_BUF_INFO_CMD);
	OUT_BATCH(BUF_3D_ID_COLOR_BACK | tiling_bits |
		  BUF_3D_PITCH(dst_pitch));
	OUT_RELOC_PIXMAP(dest, I915_GEM_DOMAIN_RENDER,
			 I915_GEM_DOMAIN_RENDER, 0);

	OUT_BATCH(_3DSTATE_DST_BUF_VARS_CMD);
	OUT_BATCH(dst_format);

	{
		uint32_t ss2;

		OUT_BATCH(_3DSTATE_LOAD_STATE_IMMEDIATE_1 | I1_LOAD_S(2) |
			  I1_LOAD_S(4) | I1_LOAD_S(5) | I1_LOAD_S(6) | 3);
		ss2 = ~0;
		t = 0;
		if (! is_solid_src) {
		    ss2 &= ~S2_TEXCOORD_FMT(t, TEXCOORDFMT_NOT_PRESENT);
		    ss2 |= S2_TEXCOORD_FMT(t,
					   is_affine_src ? TEXCOORDFMT_2D :
					   TEXCOORDFMT_4D);
		    t++;
		}
		if (mask && ! is_solid_mask) {
		    ss2 &= ~S2_TEXCOORD_FMT(t, TEXCOORDFMT_NOT_PRESENT);
		    ss2 |= S2_TEXCOORD_FMT(t,
			    is_affine_mask ? TEXCOORDFMT_2D :
			    TEXCOORDFMT_4D);
		    t++;
		}
		OUT_BATCH(ss2);
		OUT_BATCH((1 << S4_POINT_WIDTH_SHIFT) | S4_LINE_WIDTH_ONE |
			  S4_CULLMODE_NONE | S4_VFMT_XY);
		blendctl =
		    i915_get_blend_cntl(op, mask_picture, dest_picture->format);
		OUT_BATCH(0x00000000);	/* Disable stencil buffer */
		OUT_BATCH(S6_CBUF_BLEND_ENABLE | S6_COLOR_WRITE_ENABLE |
			  (BLENDFUNC_ADD << S6_CBUF_BLEND_FUNC_SHIFT) |
			  blendctl);

		/* draw rect is unconditional */
		OUT_BATCH(_3DSTATE_DRAW_RECT_CMD);
		OUT_BATCH(0x00000000);
		OUT_BATCH(0x00000000);	/* ymin, xmin */
		OUT_BATCH(DRAW_YMAX(dest->drawable.height - 1) |
			  DRAW_XMAX(dest->drawable.width - 1));
		/* yorig, xorig (relate to color buffer?) */
		OUT_BATCH(0x00000000);
	}

	ADVANCE_BATCH();

	{
	    FS_LOCALS(20);
	    int src_reg, mask_reg, out_reg = FS_OC;

	    FS_BEGIN();

	    if (dst_format == COLR_BUF_8BIT)
		out_reg = FS_U0;

	    /* Declare the registers necessary for our program.  */
	    t = 0;
	    if (is_solid_src) {
		i915_fs_dcl(FS_T8);
		src_reg = FS_T8;
	    } else {
		i915_fs_dcl(FS_T0);
		i915_fs_dcl(FS_S0);
		t++;
	    }
	    if (mask) {
		if (is_solid_mask) {
		    i915_fs_dcl(FS_T9);
		    mask_reg = FS_T9;
		} else {
		    i915_fs_dcl(FS_T0 + t);
		    i915_fs_dcl(FS_S0 + t);
		}
	    }

	    /* Load the source_picture texel */
	    if (! is_solid_src) {
		if (is_affine_src) {
		    i915_fs_texld(FS_R0, FS_S0, FS_T0);
		} else {
		    i915_fs_texldp(FS_R0, FS_S0, FS_T0);
		}

		src_reg = FS_R0;
	    }

	    if (!mask) {
		/* No mask, so move to output color */
		i915_fs_mov(out_reg, i915_fs_operand_reg(src_reg));
	    } else {
		if (! is_solid_mask) {
		    /* Load the mask_picture texel */
		    if (is_affine_mask) {
			i915_fs_texld(FS_R1, FS_S0 + t, FS_T0 + t);
		    } else {
			i915_fs_texldp(FS_R1, FS_S0 + t, FS_T0 + t);
		    }

		    mask_reg = FS_R1;
		}

		/* If component alpha is active in the mask and the blend
		 * operation uses the source alpha, then we know we don't
		 * need the source value (otherwise we would have hit a
		 * fallback earlier), so we provide the source alpha (src.A *
		 * mask.X) as output color.
		 * Conversely, if CA is set and we don't need the source alpha,
		 * then we produce the source value (src.X * mask.X) and the
		 * source alpha is unused.  Otherwise, we provide the non-CA
		 * source value (src.X * mask.A).
		 */
		if (mask_picture->componentAlpha &&
			PICT_FORMAT_RGB(mask_picture->format)) {
		    if (i915_blend_op[op].src_alpha) {
			i915_fs_mul(out_reg,
				    i915_fs_operand(src_reg, W, W, W, W),
				    i915_fs_operand_reg(mask_reg));
		    } else {
			    i915_fs_mul(out_reg,
					i915_fs_operand_reg(src_reg),
					i915_fs_operand_reg(mask_reg));
		    }
		} else {
		    i915_fs_mul(out_reg,
				i915_fs_operand_reg(src_reg),
				i915_fs_operand(mask_reg, W, W, W, W));
		}
	    }
	    if (dst_format == COLR_BUF_8BIT)
		i915_fs_mov(FS_OC, i915_fs_operand(out_reg, W, W, W, W));

	    FS_END();
	}
}

/* Emit the vertices for a single composite rectangle.
 *
 * This function is no longer shared between i830 and i915 generation code.
 */
static void
i915_emit_composite_primitive(PixmapPtr dest,
			      int srcX, int srcY,
			      int maskX, int maskY,
			      int dstX, int dstY, int w, int h)
{
	ScrnInfoPtr scrn = xf86Screens[dest->drawable.pScreen->myNum];
	intel_screen_private *intel = intel_get_screen_private(scrn);
	Bool is_affine_src, is_affine_mask = TRUE;
	int per_vertex, num_floats;
	int tex_unit = 0;
	int src_unit = -1, mask_unit = -1;
	float src_x[3], src_y[3], src_w[3], mask_x[3], mask_y[3], mask_w[3];

	per_vertex = 2;		/* dest x/y */

	if (! intel->render_source_is_solid) {
		float x = srcX + intel->src_coord_adjust;
		float y = srcY + intel->src_coord_adjust;

		src_unit = tex_unit++;

		is_affine_src = i830_transform_is_affine(intel->transform[src_unit]);
		if (is_affine_src) {
			if (!i830_get_transformed_coordinates(x, y,
							      intel->
							      transform[src_unit],
							      &src_x[0],
							      &src_y[0]))
				return;

			if (!i830_get_transformed_coordinates(x, y + h,
							      intel->
							      transform[src_unit],
							      &src_x[1],
							      &src_y[1]))
				return;

			if (!i830_get_transformed_coordinates(x + w, y + h,
							      intel->
							      transform[src_unit],
							      &src_x[2],
							      &src_y[2]))
				return;

			per_vertex += 2;	/* src x/y */
		} else {
			if (!i830_get_transformed_coordinates_3d(x, y,
								 intel->
								 transform[src_unit],
								 &src_x[0],
								 &src_y[0],
								 &src_w[0]))
				return;

			if (!i830_get_transformed_coordinates_3d(x, y + h,
								 intel->
								 transform[src_unit],
								 &src_x[1],
								 &src_y[1],
								 &src_w[1]))
				return;

			if (!i830_get_transformed_coordinates_3d(x + w, y + h,
								 intel->
								 transform[src_unit],
								 &src_x[2],
								 &src_y[2],
								 &src_w[2]))
				return;

			per_vertex += 4;	/* src x/y/z/w */
		}
	}

	if (intel->render_mask && ! intel->render_mask_is_solid) {
		float x = maskX + intel->mask_coord_adjust;
		float y = maskY + intel->mask_coord_adjust;

		mask_unit = tex_unit++;

		is_affine_mask = i830_transform_is_affine(intel->transform[mask_unit]);
		if (is_affine_mask) {
			if (!i830_get_transformed_coordinates(x, y,
d617 1
a617 1
			if (!i830_get_transformed_coordinates(x, y + h,
d624 1
a624 1
			if (!i830_get_transformed_coordinates(x + w, y + h,
d633 1
a633 1
			if (!i830_get_transformed_coordinates_3d(x, y,
d641 1
a641 1
			if (!i830_get_transformed_coordinates_3d(x, y + h,
d649 1
a649 1
			if (!i830_get_transformed_coordinates_3d(x + w, y + h,
d663 2
a664 5
	ATOMIC_BATCH(1 + num_floats);

	OUT_BATCH(PRIM3D_INLINE | PRIM3D_RECTLIST | (num_floats - 1));
	OUT_BATCH_F(intel->dst_coord_adjust + dstX + w);
	OUT_BATCH_F(intel->dst_coord_adjust + dstY + h);
d666 2
a667 2
	    OUT_BATCH_F(src_x[2] / intel->scale_units[src_unit][0]);
	    OUT_BATCH_F(src_y[2] / intel->scale_units[src_unit][1]);
d669 2
a670 2
		OUT_BATCH_F(0.0);
		OUT_BATCH_F(src_w[2]);
d674 2
a675 2
		OUT_BATCH_F(mask_x[2] / intel->scale_units[mask_unit][0]);
		OUT_BATCH_F(mask_y[2] / intel->scale_units[mask_unit][1]);
d677 2
a678 2
			OUT_BATCH_F(0.0);
			OUT_BATCH_F(mask_w[2]);
d682 2
a683 2
	OUT_BATCH_F(intel->dst_coord_adjust + dstX);
	OUT_BATCH_F(intel->dst_coord_adjust + dstY + h);
d685 2
a686 2
	    OUT_BATCH_F(src_x[1] / intel->scale_units[src_unit][0]);
	    OUT_BATCH_F(src_y[1] / intel->scale_units[src_unit][1]);
d688 2
a689 2
		OUT_BATCH_F(0.0);
		OUT_BATCH_F(src_w[1]);
d693 2
a694 2
		OUT_BATCH_F(mask_x[1] / intel->scale_units[mask_unit][0]);
		OUT_BATCH_F(mask_y[1] / intel->scale_units[mask_unit][1]);
d696 2
a697 2
			OUT_BATCH_F(0.0);
			OUT_BATCH_F(mask_w[1]);
d701 2
a702 2
	OUT_BATCH_F(intel->dst_coord_adjust + dstX);
	OUT_BATCH_F(intel->dst_coord_adjust + dstY);
d704 2
a705 2
	    OUT_BATCH_F(src_x[0] / intel->scale_units[src_unit][0]);
	    OUT_BATCH_F(src_y[0] / intel->scale_units[src_unit][1]);
d707 2
a708 2
		OUT_BATCH_F(0.0);
		OUT_BATCH_F(src_w[0]);
d712 2
a713 2
		OUT_BATCH_F(mask_x[0] / intel->scale_units[mask_unit][0]);
		OUT_BATCH_F(mask_y[0] / intel->scale_units[mask_unit][1]);
d715 48
a762 2
			OUT_BATCH_F(0.0);
			OUT_BATCH_F(mask_w[0]);
d764 2
d768 333
a1100 1
	ADVANCE_BATCH();
d1116 48
a1163 2
	i915_emit_composite_primitive(dest, srcX, srcY, maskX, maskY, dstX,
				      dstY, w, h);
d1168 25
a1192 1
void i915_batch_flush_notify(ScrnInfoPtr scrn)
d1197 2
@


1.3
log
@update to xf86-video-intel 2.7.1. Tested by many.
@
text
@d38 2
d41 2
a42 2
    int fmt;
    uint32_t card_fmt;
d46 4
a49 4
    Bool dst_alpha;
    Bool src_alpha;
    uint32_t src_blend;
    uint32_t dst_blend;
d53 26
a78 26
    /* Clear */
    {0, 0, BLENDFACT_ZERO,          BLENDFACT_ZERO},
    /* Src */
    {0, 0, BLENDFACT_ONE,           BLENDFACT_ZERO},
    /* Dst */
    {0, 0, BLENDFACT_ZERO,          BLENDFACT_ONE},
    /* Over */
    {0, 1, BLENDFACT_ONE,           BLENDFACT_INV_SRC_ALPHA},
    /* OverReverse */
    {1, 0, BLENDFACT_INV_DST_ALPHA, BLENDFACT_ONE},
    /* In */
    {1, 0, BLENDFACT_DST_ALPHA,     BLENDFACT_ZERO},
    /* InReverse */
    {0, 1, BLENDFACT_ZERO,          BLENDFACT_SRC_ALPHA},
    /* Out */
    {1, 0, BLENDFACT_INV_DST_ALPHA, BLENDFACT_ZERO},
    /* OutReverse */
    {0, 1, BLENDFACT_ZERO,          BLENDFACT_INV_SRC_ALPHA},
    /* Atop */
    {1, 1, BLENDFACT_DST_ALPHA,     BLENDFACT_INV_SRC_ALPHA},
    /* AtopReverse */
    {1, 1, BLENDFACT_INV_DST_ALPHA, BLENDFACT_SRC_ALPHA},
    /* Xor */
    {1, 1, BLENDFACT_INV_DST_ALPHA, BLENDFACT_INV_SRC_ALPHA},
    /* Add */
    {0, 0, BLENDFACT_ONE,           BLENDFACT_ONE},
d82 10
a91 10
    {PICT_a8r8g8b8, MAPSURF_32BIT | MT_32BIT_ARGB8888 },
    {PICT_x8r8g8b8, MAPSURF_32BIT | MT_32BIT_XRGB8888 },
    {PICT_a8b8g8r8, MAPSURF_32BIT | MT_32BIT_ABGR8888 },
    {PICT_x8b8g8r8, MAPSURF_32BIT | MT_32BIT_XBGR8888 },
    {PICT_r5g6b5,   MAPSURF_16BIT | MT_16BIT_RGB565   },
    {PICT_a1r5g5b5, MAPSURF_16BIT | MT_16BIT_ARGB1555 },
    {PICT_x1r5g5b5, MAPSURF_16BIT | MT_16BIT_ARGB1555 },
    {PICT_a4r4g4b4, MAPSURF_16BIT | MT_16BIT_ARGB4444 },
    {PICT_x4r4g4b4, MAPSURF_16BIT | MT_16BIT_ARGB4444 },
    {PICT_a8,       MAPSURF_8BIT | MT_8BIT_A8 	  },
d94 1
a94 1
static uint32_t i915_get_blend_cntl(int op, PicturePtr pMask,
d97 14
a110 1
    uint32_t sblend, dblend;
d112 10
a121 2
    sblend = i915_blend_op[op].src_blend;
    dblend = i915_blend_op[op].dst_blend;
d123 12
a134 34
    /* If there's no dst alpha channel, adjust the blend op so that we'll treat
     * it as always 1.
     */
    if (PICT_FORMAT_A(dst_format) == 0 && i915_blend_op[op].dst_alpha) {
        if (sblend == BLENDFACT_DST_ALPHA)
            sblend = BLENDFACT_ONE;
        else if (sblend == BLENDFACT_INV_DST_ALPHA)
            sblend = BLENDFACT_ZERO;
    }

    /* i915 engine reads 8bit color buffer into green channel in cases
       like color buffer blending .etc, and also writes back green channel.
       So with dst_alpha blend we should use color factor. See spec on
       "8-bit rendering" */
    if ((dst_format == PICT_a8) && i915_blend_op[op].dst_alpha) {
        if (sblend == BLENDFACT_DST_ALPHA)
            sblend = BLENDFACT_DST_COLR;
        else if (sblend == BLENDFACT_INV_DST_ALPHA)
            sblend = BLENDFACT_INV_DST_COLR;
    }

    /* If the source alpha is being used, then we should only be in a case
     * where the source blend factor is 0, and the source blend value is the
     * mask channels multiplied by the source picture's alpha.
     */
    if (pMask && pMask->componentAlpha && PICT_FORMAT_RGB(pMask->format) &&
	i915_blend_op[op].src_alpha)
    {
        if (dblend == BLENDFACT_SRC_ALPHA) {
	    dblend = BLENDFACT_SRC_COLR;
        } else if (dblend == BLENDFACT_INV_SRC_ALPHA) {
	    dblend = BLENDFACT_INV_SRC_COLR;
        }
    }
d136 2
a137 2
    return (sblend << S6_CBUF_SRC_BLEND_FACT_SHIFT) |
	(dblend << S6_CBUF_DST_BLEND_FACT_SHIFT);
d140 4
a143 1
static Bool i915_get_dest_format(PicturePtr pDstPicture, uint32_t *dst_format)
d145 1
a145 1
    ScrnInfoPtr pScrn = xf86Screens[pDstPicture->pDrawable->pScreen->myNum];
d147 30
a176 25
    switch (pDstPicture->format) {
    case PICT_a8r8g8b8:
    case PICT_x8r8g8b8:
        *dst_format = COLR_BUF_ARGB8888;
        break;
    case PICT_r5g6b5:
        *dst_format = COLR_BUF_RGB565;
        break;
    case PICT_a1r5g5b5:
    case PICT_x1r5g5b5:
        *dst_format = COLR_BUF_ARGB1555;
        break;
    case PICT_a8:
        *dst_format = COLR_BUF_8BIT;
        break;
    case PICT_a4r4g4b4:
    case PICT_x4r4g4b4:
	*dst_format = COLR_BUF_ARGB4444;
	break;
    default:
        I830FALLBACK("Unsupported dest format 0x%x\n",
		     (int)pDstPicture->format);
    }

    return TRUE;
d179 2
a180 1
static Bool i915_check_composite_texture(PicturePtr pPict, int unit)
d182 5
a186 24
    ScrnInfoPtr pScrn = xf86Screens[pPict->pDrawable->pScreen->myNum];
    int w = pPict->pDrawable->width;
    int h = pPict->pDrawable->height;
    int i;

    if ((w > 2048) || (h > 2048))
        I830FALLBACK("Picture w/h too large (%dx%d)\n", w, h);

    for (i = 0; i < sizeof(i915_tex_formats) / sizeof(i915_tex_formats[0]);
	 i++)
    {
        if (i915_tex_formats[i].fmt == pPict->format)
            break;
    }
    if (i == sizeof(i915_tex_formats) / sizeof(i915_tex_formats[0]))
        I830FALLBACK("Unsupported picture format 0x%x\n",
		     (int)pPict->format);

    if (pPict->repeatType > RepeatReflect)
        I830FALLBACK("Unsupported picture repeat %d\n", pPict->repeatType);

    if (pPict->filter != PictFilterNearest &&
        pPict->filter != PictFilterBilinear)
        I830FALLBACK("Unsupported filter 0x%x\n", pPict->filter);
d188 35
a222 1
    return TRUE;
d226 2
a227 2
i915_check_composite(int op, PicturePtr pSrcPicture, PicturePtr pMaskPicture,
		     PicturePtr pDstPicture)
d229 24
a252 2
    ScrnInfoPtr pScrn = xf86Screens[pDstPicture->pDrawable->pScreen->myNum];
    uint32_t tmp1;
d254 9
a262 20
    /* Check for unsupported compositing operations. */
    if (op >= sizeof(i915_blend_op) / sizeof(i915_blend_op[0]))
        I830FALLBACK("Unsupported Composite op 0x%x\n", op);
    if (pMaskPicture != NULL && pMaskPicture->componentAlpha &&
	PICT_FORMAT_RGB(pMaskPicture->format))
    {
        /* Check if it's component alpha that relies on a source alpha and on
         * the source value.  We can only get one of those into the single
         * source value that we get to blend with.
         */
        if (i915_blend_op[op].src_alpha &&
            (i915_blend_op[op].src_blend != BLENDFACT_ZERO))
            	I830FALLBACK("Component alpha not supported with source "
			     "alpha and source value blending.\n");
    }

    if (!i915_check_composite_texture(pSrcPicture, 0))
        I830FALLBACK("Check Src picture texture\n");
    if (pMaskPicture != NULL && !i915_check_composite_texture(pMaskPicture, 1))
        I830FALLBACK("Check Mask picture texture\n");
d264 4
a267 2
    if (!i915_get_dest_format(pDstPicture, &tmp1))
	I830FALLBACK("Get Color buffer format\n");
d269 1
a269 1
    return TRUE;
d272 1
a272 2
static Bool
i915_texture_setup(PicturePtr pPict, PixmapPtr pPix, int unit)
d274 83
a356 68
    ScrnInfoPtr pScrn = xf86Screens[pPict->pDrawable->pScreen->myNum];
    I830Ptr pI830 = I830PTR(pScrn);
    uint32_t format, pitch, filter;
    int w, h, i;
    uint32_t wrap_mode;

    pitch = intel_get_pixmap_pitch(pPix);
    w = pPict->pDrawable->width;
    h = pPict->pDrawable->height;
    pI830->scale_units[unit][0] = pPix->drawable.width;
    pI830->scale_units[unit][1] = pPix->drawable.height;

    for (i = 0; i < sizeof(i915_tex_formats) / sizeof(i915_tex_formats[0]);
	 i++)
    {
        if (i915_tex_formats[i].fmt == pPict->format)
	    break;
    }
    if (i == sizeof(i915_tex_formats)/ sizeof(i915_tex_formats[0]))
	I830FALLBACK("unknown texture format\n");
    format = i915_tex_formats[i].card_fmt;

    switch (pPict->repeatType) {
    case RepeatNone:
	wrap_mode = TEXCOORDMODE_CLAMP_BORDER;
	break;
    case RepeatNormal:
	wrap_mode = TEXCOORDMODE_WRAP;
	break;
    case RepeatPad:
	wrap_mode = TEXCOORDMODE_CLAMP_EDGE;
	break;
    case RepeatReflect:
	wrap_mode = TEXCOORDMODE_MIRROR;
	break;
    default:
	FatalError("Unkown repeat type %d\n", pPict->repeatType);
    }

    switch (pPict->filter) {
    case PictFilterNearest:
        filter = (FILTER_NEAREST << SS2_MAG_FILTER_SHIFT) |
	    (FILTER_NEAREST << SS2_MIN_FILTER_SHIFT);
        break;
    case PictFilterBilinear:
        filter = (FILTER_LINEAR << SS2_MAG_FILTER_SHIFT) |
	    (FILTER_LINEAR << SS2_MIN_FILTER_SHIFT);
        break;
    default:
	filter = 0;
        I830FALLBACK("Bad filter 0x%x\n", pPict->filter);
    }

    pI830->mapstate[unit * 3 + 0] = 0; /* offset filled in at emit time */
    pI830->mapstate[unit * 3 + 1] = format |
	MS3_USE_FENCE_REGS |
	((pPix->drawable.height - 1) << MS3_HEIGHT_SHIFT) |
	((pPix->drawable.width - 1) << MS3_WIDTH_SHIFT);
    pI830->mapstate[unit * 3 + 2] = ((pitch / 4) - 1) << MS4_PITCH_SHIFT;

    pI830->samplerstate[unit * 3 + 0] = (MIPFILTER_NONE <<
					 SS2_MIP_FILTER_SHIFT);
    pI830->samplerstate[unit * 3 + 0] |= filter;
    pI830->samplerstate[unit * 3 + 1] = SS3_NORMALIZED_COORDS;
    pI830->samplerstate[unit * 3 + 1] |= wrap_mode << SS3_TCX_ADDR_MODE_SHIFT;
    pI830->samplerstate[unit * 3 + 1] |= wrap_mode << SS3_TCY_ADDR_MODE_SHIFT;
    pI830->samplerstate[unit * 3 + 1] |= unit << SS3_TEXTUREMAP_INDEX_SHIFT;
    pI830->samplerstate[unit * 3 + 2] = 0x00000000; /* border color */
d358 1
a358 1
    pI830->transform[unit] = pPict->transform;
d360 1
a360 1
    return TRUE;
d364 3
a366 3
i915_prepare_composite(int op, PicturePtr pSrcPicture,
		       PicturePtr pMaskPicture, PicturePtr pDstPicture,
		       PixmapPtr pSrc, PixmapPtr pMask, PixmapPtr pDst)
d368 54
a421 45
    ScrnInfoPtr pScrn = xf86Screens[pSrcPicture->pDrawable->pScreen->myNum];
    I830Ptr pI830 = I830PTR(pScrn);
    drm_intel_bo *bo_table[] = {
	NULL, /* batch_bo */
	i830_get_pixmap_bo(pSrc),
	pMask ? i830_get_pixmap_bo(pMask) : NULL,
	i830_get_pixmap_bo(pDst),
    };

    i830_exa_check_pitch_3d(pSrc);
    if (pMask)
	i830_exa_check_pitch_3d(pMask);
    i830_exa_check_pitch_3d(pDst);

    if (!i915_get_dest_format(pDstPicture,
			      &pI830->i915_render_state.dst_format))
	return FALSE;

    if (!i830_get_aperture_space(pScrn, bo_table, ARRAY_SIZE(bo_table)))
	return FALSE;

    pI830->i915_render_state.is_nearest = FALSE;
    if (!i915_texture_setup(pSrcPicture, pSrc, 0))
	I830FALLBACK("fail to setup src texture\n");
    if (pSrcPicture->filter == PictFilterNearest)
	pI830->i915_render_state.is_nearest = TRUE;
    if (pMask != NULL) {
	if (!i915_texture_setup(pMaskPicture, pMask, 1))
	    I830FALLBACK("fail to setup mask texture\n");
	if (pMaskPicture->filter == PictFilterNearest)
	    pI830->i915_render_state.is_nearest = TRUE;
    } else {
	pI830->transform[1] = NULL;
	pI830->scale_units[1][0] = -1;
	pI830->scale_units[1][1] = -1;
    }

    pI830->i915_render_state.op = op;
    pI830->i915_render_state.pSrcPicture = pSrcPicture;
    pI830->i915_render_state.pMaskPicture = pMaskPicture;
    pI830->i915_render_state.pDstPicture = pDstPicture;
    pI830->i915_render_state.pSrc = pSrc;
    pI830->i915_render_state.pMask = pMask;
    pI830->i915_render_state.pDst = pDst;
    pI830->i915_render_state.needs_emit = TRUE;
d423 59
a481 1
    return TRUE;
d484 1
a484 2
static void
i915_emit_composite_setup(ScrnInfoPtr pScrn)
d486 72
a557 67
    I830Ptr pI830 = I830PTR(pScrn);
    int op = pI830->i915_render_state.op;
    PicturePtr pSrcPicture = pI830->i915_render_state.pSrcPicture;
    PicturePtr pMaskPicture = pI830->i915_render_state.pMaskPicture;
    PicturePtr pDstPicture = pI830->i915_render_state.pDstPicture;
    PixmapPtr pSrc = pI830->i915_render_state.pSrc;
    PixmapPtr pMask = pI830->i915_render_state.pMask;
    PixmapPtr pDst = pI830->i915_render_state.pDst;
    uint32_t dst_format = pI830->i915_render_state.dst_format, dst_pitch;
    uint32_t blendctl;
    int out_reg = FS_OC;
    FS_LOCALS(20);
    Bool is_affine_src, is_affine_mask;
    Bool is_nearest = pI830->i915_render_state.is_nearest;

    pI830->i915_render_state.needs_emit = FALSE;

    IntelEmitInvarientState(pScrn);
    pI830->last_3d = LAST_3D_RENDER;

    dst_pitch = intel_get_pixmap_pitch(pDst);

    is_affine_src = i830_transform_is_affine (pI830->transform[0]);
    is_affine_mask = i830_transform_is_affine (pI830->transform[1]);

    if (is_nearest)
	pI830->coord_adjust = -0.125;
    else
	pI830->coord_adjust = 0;

    if (pMask == NULL) {
	BEGIN_BATCH(10);
	OUT_BATCH(_3DSTATE_MAP_STATE | 3);
	OUT_BATCH(0x00000001); /* map 0 */
	OUT_RELOC_PIXMAP(pSrc, I915_GEM_DOMAIN_SAMPLER, 0, 0);
	OUT_BATCH(pI830->mapstate[1]);
	OUT_BATCH(pI830->mapstate[2]);

	OUT_BATCH(_3DSTATE_SAMPLER_STATE | 3);
	OUT_BATCH(0x00000001); /* sampler 0 */
	OUT_BATCH(pI830->samplerstate[0]);
	OUT_BATCH(pI830->samplerstate[1]);
	OUT_BATCH(pI830->samplerstate[2]);
	ADVANCE_BATCH();
    } else {
	BEGIN_BATCH(16);
	OUT_BATCH(_3DSTATE_MAP_STATE | 6);
	OUT_BATCH(0x00000003); /* map 0,1 */
	OUT_RELOC_PIXMAP(pSrc, I915_GEM_DOMAIN_SAMPLER, 0, 0);
	OUT_BATCH(pI830->mapstate[1]);
	OUT_BATCH(pI830->mapstate[2]);
	OUT_RELOC_PIXMAP(pMask, I915_GEM_DOMAIN_SAMPLER, 0, 0);
	OUT_BATCH(pI830->mapstate[4]);
	OUT_BATCH(pI830->mapstate[5]);

	OUT_BATCH(_3DSTATE_SAMPLER_STATE | 6);
	OUT_BATCH(0x00000003); /* sampler 0,1 */
	OUT_BATCH(pI830->samplerstate[0]);
	OUT_BATCH(pI830->samplerstate[1]);
	OUT_BATCH(pI830->samplerstate[2]);
	OUT_BATCH(pI830->samplerstate[3]);
	OUT_BATCH(pI830->samplerstate[4]);
	OUT_BATCH(pI830->samplerstate[5]);
	ADVANCE_BATCH();
    }
    {
	uint32_t ss2;
a558 1
	BEGIN_BATCH(16);
d560 1
a560 1
	OUT_BATCH(BUF_3D_ID_COLOR_BACK| BUF_3D_USE_FENCE|
d562 2
a563 1
	OUT_RELOC_PIXMAP(pDst, I915_GEM_DOMAIN_RENDER, I915_GEM_DOMAIN_RENDER, 0);
d568 41
a608 29
	OUT_BATCH(_3DSTATE_LOAD_STATE_IMMEDIATE_1 | I1_LOAD_S(2) |
		  I1_LOAD_S(4) | I1_LOAD_S(5) | I1_LOAD_S(6) | 3);
	ss2 = S2_TEXCOORD_FMT(0, is_affine_src ? TEXCOORDFMT_2D : TEXCOORDFMT_4D);
	if (pMask)
		ss2 |= S2_TEXCOORD_FMT(1, is_affine_mask ? TEXCOORDFMT_2D : TEXCOORDFMT_4D);
	else
		ss2 |= S2_TEXCOORD_FMT(1, TEXCOORDFMT_NOT_PRESENT);
	ss2 |= S2_TEXCOORD_FMT(2, TEXCOORDFMT_NOT_PRESENT);
	ss2 |= S2_TEXCOORD_FMT(3, TEXCOORDFMT_NOT_PRESENT);
	ss2 |= S2_TEXCOORD_FMT(4, TEXCOORDFMT_NOT_PRESENT);
	ss2 |= S2_TEXCOORD_FMT(5, TEXCOORDFMT_NOT_PRESENT);
	ss2 |= S2_TEXCOORD_FMT(6, TEXCOORDFMT_NOT_PRESENT);
	ss2 |= S2_TEXCOORD_FMT(7, TEXCOORDFMT_NOT_PRESENT);
	OUT_BATCH(ss2);
	OUT_BATCH((1 << S4_POINT_WIDTH_SHIFT) | S4_LINE_WIDTH_ONE |
		  S4_CULLMODE_NONE| S4_VFMT_XY);
	blendctl = i915_get_blend_cntl(op, pMaskPicture, pDstPicture->format);
	OUT_BATCH(0x00000000); /* Disable stencil buffer */
	OUT_BATCH(S6_CBUF_BLEND_ENABLE | S6_COLOR_WRITE_ENABLE |
		  (BLENDFUNC_ADD << S6_CBUF_BLEND_FUNC_SHIFT) | blendctl);

	/* draw rect is unconditional */
	OUT_BATCH(_3DSTATE_DRAW_RECT_CMD);
	OUT_BATCH(0x00000000);
	OUT_BATCH(0x00000000);  /* ymin, xmin*/
	OUT_BATCH(DRAW_YMAX(pDst->drawable.height - 1) |
		  DRAW_XMAX(pDst->drawable.width - 1));
	OUT_BATCH(0x00000000);  /* yorig, xorig (relate to color buffer?)*/
	OUT_BATCH(MI_NOOP);
a609 1
    }
d611 5
a615 2
    if (dst_format == COLR_BUF_8BIT)
	out_reg = FS_U0;
d617 2
a618 1
    FS_BEGIN();
d620 34
a653 50
    /* Declare the registers necessary for our program.  I don't think the
     * S then T ordering is necessary.
     */
    i915_fs_dcl(FS_S0);
    if (pMask)
	i915_fs_dcl(FS_S1);
    i915_fs_dcl(FS_T0);
    if (pMask)
	i915_fs_dcl(FS_T1);

    /* Load the pSrcPicture texel */
    if (is_affine_src) {
	i915_fs_texld(FS_R0, FS_S0, FS_T0);
    } else {
	i915_fs_texldp(FS_R0, FS_S0, FS_T0);
    }

    /* If the texture lacks an alpha channel, force the alpha to 1. */
    if (PICT_FORMAT_A(pSrcPicture->format) == 0)
	i915_fs_mov_masked(FS_R0, MASK_W, i915_fs_operand_one());

    if (!pMask) {
	/* No mask, so move to output color */
	i915_fs_mov(out_reg, i915_fs_operand_reg(FS_R0));
    } else {
	/* Load the pMaskPicture texel */
	if (is_affine_mask) {
	    i915_fs_texld(FS_R1, FS_S1, FS_T1);
	} else {
	    i915_fs_texldp(FS_R1, FS_S1, FS_T1);
	}
	/* If the texture lacks an alpha channel, force the alpha to 1. */
	if (PICT_FORMAT_A(pMaskPicture->format) == 0)
	    i915_fs_mov_masked(FS_R1, MASK_W, i915_fs_operand_one());

	/* If component alpha is active in the mask and the blend operation
	 * uses the source alpha, then we know we don't need the source
	 * value (otherwise we would have hit a fallback earlier), so we
	 * provide the source alpha (src.A * mask.X) as output color.
	 * Conversely, if CA is set and we don't need the source alpha, then
	 * we produce the source value (src.X * mask.X) and the source alpha
	 * is unused..  Otherwise, we provide the non-CA source value
	 * (src.X * mask.A).
	 */
	if (pMaskPicture->componentAlpha &&
	    PICT_FORMAT_RGB(pMaskPicture->format))
	{
	    if (i915_blend_op[op].src_alpha) {
		i915_fs_mul(out_reg, i915_fs_operand(FS_R0, W, W, W, W),
			    i915_fs_operand_reg(FS_R1));
d655 196
a850 2
		i915_fs_mul(out_reg, i915_fs_operand_reg(FS_R0),
			    i915_fs_operand_reg(FS_R1));
d852 28
a879 7
	} else {
	    i915_fs_mul(out_reg, i915_fs_operand_reg(FS_R0),
			i915_fs_operand(FS_R1, W, W, W, W));
	}
    }
    if (dst_format == COLR_BUF_8BIT)
	i915_fs_mov(FS_OC, i915_fs_operand(out_reg, W, W, W, W));
d881 20
a900 1
    FS_END();
d904 1
a904 1
i915_composite(PixmapPtr pDst, int srcX, int srcY, int maskX, int maskY,
d907 2
a908 2
    ScrnInfoPtr pScrn = xf86Screens[pDst->drawable.pScreen->myNum];
    I830Ptr pI830 = I830PTR(pScrn);
d910 2
a911 1
    intel_batch_start_atomic(pScrn, 150);
d913 2
a914 2
    if (pI830->i915_render_state.needs_emit)
	i915_emit_composite_setup(pScrn);
d916 2
a917 1
    i830_composite(pDst, srcX, srcY, maskX, maskY, dstX, dstY, w, h);
d919 1
a919 1
    intel_batch_end_atomic(pScrn);
d922 1
a922 2
void
i915_batch_flush_notify(ScrnInfoPtr pScrn)
d924 1
a924 1
    I830Ptr pI830 = I830PTR(pScrn);
d926 1
a926 1
    pI830->i915_render_state.needs_emit = TRUE;
@


1.2
log
@Update to xf86-video-intel 2.3.1. Tested by many.
@
text
@a37 17
#ifdef I830DEBUG
#define DEBUG_I830FALLBACK 1
#endif

#ifdef DEBUG_I830FALLBACK
#define I830FALLBACK(s, arg...)				\
do {							\
	DPRINTF(PFX, "EXA fallback: " s "\n", ##arg); 	\
	return FALSE;					\
} while(0)
#else
#define I830FALLBACK(s, arg...) 			\
do { 							\
	return FALSE;					\
} while(0)
#endif

d141 2
d172 1
d190 2
a191 3
    if (pPict->repeat && pPict->repeatType != RepeatNormal)
	I830FALLBACK("extended repeat (%d) not supported\n",
		     pPict->repeatType);
d204 1
d239 1
a239 1
    uint32_t format, offset, pitch, filter;
d241 1
a241 1
    uint32_t wrap_mode = TEXCOORDMODE_CLAMP_BORDER;
a242 1
    offset = intel_get_pixmap_offset(pPix);
d259 5
a263 1
    if (pPict->repeat)
d265 10
d290 1
a290 1
    pI830->mapstate[unit * 3 + 0] = offset;
d318 6
a323 6
    uint32_t dst_format, dst_offset, dst_pitch;
    uint32_t blendctl;
    int out_reg = FS_OC;
    FS_LOCALS(20);
    Bool is_affine_src, is_affine_mask;
    Bool is_nearest = FALSE;
d330 3
a332 2
    IntelEmitInvarientState(pScrn);
    *pI830->last_3d = LAST_3D_RENDER;
d334 1
a334 1
    if (!i915_get_dest_format(pDstPicture, &dst_format))
a335 2
    dst_offset = intel_get_pixmap_offset(pDst);
    dst_pitch = intel_get_pixmap_pitch(pDst);
d337 1
d341 1
a341 1
	is_nearest = TRUE;
d346 1
a346 1
	    is_nearest = TRUE;
d352 38
d402 1
a402 1
	OUT_BATCH(pI830->mapstate[0]);
d416 1
a416 1
	OUT_BATCH(pI830->mapstate[0]);
d419 1
a419 1
	OUT_BATCH(pI830->mapstate[3]);
d440 1
a440 1
	OUT_BATCH(BUF_3D_ADDR(dst_offset));
d545 1
d547 23
a569 1
    return TRUE;
@


1.1
log
@Initial revision
@
text
@d57 1
a57 1
    CARD32 card_fmt;
d63 2
a64 2
    CARD32 src_blend;
    CARD32 dst_blend;
d109 2
a110 1
static CARD32 i915_get_blend_cntl(int op, PicturePtr pMask, CARD32 dst_format)
d112 1
a112 1
    CARD32 sblend, dblend;
d156 1
a156 1
static Bool i915_get_dest_format(PicturePtr pDstPicture, CARD32 *dst_format)
d191 1
a191 1
    if ((w > 0x7ff) || (h > 0x7ff))
d219 1
a219 1
    CARD32 tmp1;
d253 1
a253 1
    CARD32 format, offset, pitch, filter;
d255 1
a255 1
    CARD32 wrap_mode = TEXCOORDMODE_CLAMP_BORDER;
d319 2
a320 2
    CARD32 dst_format, dst_offset, dst_pitch;
    CARD32 blendctl;
d322 8
d334 2
a335 1
    i915_get_dest_format(pDstPicture, &dst_format);
a337 1
    FS_LOCALS(20);
d341 2
d346 2
d353 7
d362 13
a374 13
	BEGIN_LP_RING(10);
	OUT_RING(_3DSTATE_MAP_STATE | 3);
	OUT_RING(0x00000001); /* map 0 */
	OUT_RING(pI830->mapstate[0]);
	OUT_RING(pI830->mapstate[1]);
	OUT_RING(pI830->mapstate[2]);

	OUT_RING(_3DSTATE_SAMPLER_STATE | 3);
	OUT_RING(0x00000001); /* sampler 0 */
	OUT_RING(pI830->samplerstate[0]);
	OUT_RING(pI830->samplerstate[1]);
	OUT_RING(pI830->samplerstate[2]);
	ADVANCE_LP_RING();
d376 19
a394 19
	BEGIN_LP_RING(16);
	OUT_RING(_3DSTATE_MAP_STATE | 6);
	OUT_RING(0x00000003); /* map 0,1 */
	OUT_RING(pI830->mapstate[0]);
	OUT_RING(pI830->mapstate[1]);
	OUT_RING(pI830->mapstate[2]);
	OUT_RING(pI830->mapstate[3]);
	OUT_RING(pI830->mapstate[4]);
	OUT_RING(pI830->mapstate[5]);

	OUT_RING(_3DSTATE_SAMPLER_STATE | 6);
	OUT_RING(0x00000003); /* sampler 0,1 */
	OUT_RING(pI830->samplerstate[0]);
	OUT_RING(pI830->samplerstate[1]);
	OUT_RING(pI830->samplerstate[2]);
	OUT_RING(pI830->samplerstate[3]);
	OUT_RING(pI830->samplerstate[4]);
	OUT_RING(pI830->samplerstate[5]);
	ADVANCE_LP_RING();
d397 1
a397 1
	CARD32 ss2;
d399 12
a410 12
	BEGIN_LP_RING(16);
	OUT_RING(_3DSTATE_BUF_INFO_CMD);
	OUT_RING(BUF_3D_ID_COLOR_BACK| BUF_3D_USE_FENCE|
		BUF_3D_PITCH(dst_pitch));
	OUT_RING(BUF_3D_ADDR(dst_offset));

	OUT_RING(_3DSTATE_DST_BUF_VARS_CMD);
	OUT_RING(dst_format);

	OUT_RING(_3DSTATE_LOAD_STATE_IMMEDIATE_1 | I1_LOAD_S(2) |
		 I1_LOAD_S(4) | I1_LOAD_S(5) | I1_LOAD_S(6) | 3);
	ss2 = S2_TEXCOORD_FMT(0, TEXCOORDFMT_2D);
d412 1
a412 1
		ss2 |= S2_TEXCOORD_FMT(1, TEXCOORDFMT_2D);
d421 3
a423 3
	OUT_RING(ss2);
	OUT_RING((1 << S4_POINT_WIDTH_SHIFT) | S4_LINE_WIDTH_ONE |
		 S4_CULLMODE_NONE| S4_VFMT_XY);
d425 3
a427 3
	OUT_RING(0x00000000); /* Disable stencil buffer */
	OUT_RING(S6_CBUF_BLEND_ENABLE | S6_COLOR_WRITE_ENABLE |
		 (BLENDFUNC_ADD << S6_CBUF_BLEND_FUNC_SHIFT) | blendctl);
d430 8
a437 8
	OUT_RING(_3DSTATE_DRAW_RECT_CMD);
	OUT_RING(0x00000000);
	OUT_RING(0x00000000);  /* ymin, xmin*/
	OUT_RING(DRAW_YMAX(pDst->drawable.height - 1) |
		 DRAW_XMAX(pDst->drawable.width - 1));
	OUT_RING(0x00000000);  /* yorig, xorig (relate to color buffer?)*/
	OUT_RING(MI_NOOP);
	ADVANCE_LP_RING();
d456 6
a461 1
    i915_fs_texld(FS_R0, FS_S0, FS_T0);
d471 5
a475 1
	i915_fs_texld(FS_R1, FS_S1, FS_T1);
@


1.1.1.1
log
@xf86-video-intel 2.2.0
@
text
@@
