head	1.11;
access;
symbols
	OPENBSD_5_4:1.10.0.2
	OPENBSD_5_4_BASE:1.10
	OPENBSD_5_3:1.9.0.2
	OPENBSD_5_3_BASE:1.9
	OPENBSD_5_2:1.8.0.4
	OPENBSD_5_2_BASE:1.8
	OPENBSD_5_1_BASE:1.8
	OPENBSD_5_1:1.8.0.2
	OPENBSD_5_0:1.7.0.6
	OPENBSD_5_0_BASE:1.7
	OPENBSD_4_9:1.7.0.2
	OPENBSD_4_9_BASE:1.7
	OPENBSD_4_8:1.7.0.4
	OPENBSD_4_8_BASE:1.7
	OPENBSD_4_7:1.4.0.4
	OPENBSD_4_7_BASE:1.4
	OPENBSD_4_6:1.4.0.2
	OPENBSD_4_6_BASE:1.4
	OPENBSD_4_5:1.3.0.2
	OPENBSD_4_5_BASE:1.3
	OPENBSD_4_4:1.2.0.2
	OPENBSD_4_4_BASE:1.2
	OPENBSD_4_3_BASE:1.1.1.2
	OPENBSD_4_3:1.1.1.2.0.2
	v2_2_0_90:1.1.1.2
	v2_2_0:1.1.1.1
	xorg:1.1.1;
locks; strict;
comment	@ * @;


1.11
date	2014.02.03.15.54.51;	author matthieu;	state dead;
branches;
next	1.10;

1.10
date	2013.03.18.18.38.20;	author matthieu;	state Exp;
branches;
next	1.9;

1.9
date	2012.10.06.03.51.23;	author jsg;	state Exp;
branches;
next	1.8;

1.8
date	2011.11.29.12.39.03;	author oga;	state Exp;
branches;
next	1.7;

1.7
date	2010.07.18.14.47.47;	author oga;	state Exp;
branches;
next	1.6;

1.6
date	2010.05.23.21.28.35;	author oga;	state Exp;
branches;
next	1.5;

1.5
date	2010.05.10.22.32.29;	author oga;	state Exp;
branches;
next	1.4;

1.4
date	2009.06.25.20.16.43;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2008.10.12.15.20.50;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2008.05.21.20.19.52;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2007.11.24.19.44.45;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2007.11.24.19.44.45;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2008.02.11.20.10.08;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.11
log
@Update to xf86-video-intel 2.99.909
Tested by jsg@@, kettenis@@ and myself on a wide range of intel cards.
@
text
@/*
 * Copyright © 2006 Intel Corporation
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice (including the next
 * paragraph) shall be included in all copies or substantial portions of the
 * Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *
 * Authors:
 *    Eric Anholt <eric@@anholt.net>
 *    Keith Packard <keithp@@keithp.com>
 *
 */

#ifdef HAVE_CONFIG_H
#include "config.h"
#endif

#include "xf86.h"
#include "xf86_OSproc.h"
#include "xf86xv.h"
#include "fourcc.h"

#include "intel.h"
#include "intel_hwmc.h"
#include "intel_video.h"
#include "i830_reg.h"
#include "i965_reg.h"
#include "brw_defines.h"
#include "brw_structs.h"
#include <string.h>


/* Make assert() work. */
#undef NDEBUG
#include <assert.h>

static const uint32_t sip_kernel_static[][4] = {
/*    wait (1) a0<1>UW a145<0,1,0>UW { align1 +  } */
	{0x00000030, 0x20000108, 0x00001220, 0x00000000},
/*    nop (4) g0<1>UD { align1 +  } */
	{0x0040007e, 0x20000c21, 0x00690000, 0x00000000},
/*    nop (4) g0<1>UD { align1 +  } */
	{0x0040007e, 0x20000c21, 0x00690000, 0x00000000},
/*    nop (4) g0<1>UD { align1 +  } */
	{0x0040007e, 0x20000c21, 0x00690000, 0x00000000},
/*    nop (4) g0<1>UD { align1 +  } */
	{0x0040007e, 0x20000c21, 0x00690000, 0x00000000},
/*    nop (4) g0<1>UD { align1 +  } */
	{0x0040007e, 0x20000c21, 0x00690000, 0x00000000},
/*    nop (4) g0<1>UD { align1 +  } */
	{0x0040007e, 0x20000c21, 0x00690000, 0x00000000},
/*    nop (4) g0<1>UD { align1 +  } */
	{0x0040007e, 0x20000c21, 0x00690000, 0x00000000},
/*    nop (4) g0<1>UD { align1 +  } */
	{0x0040007e, 0x20000c21, 0x00690000, 0x00000000},
/*    nop (4) g0<1>UD { align1 +  } */
	{0x0040007e, 0x20000c21, 0x00690000, 0x00000000},
};

/*
 * this program computes dA/dx and dA/dy for the texture coordinates along
 * with the base texture coordinate. It was extracted from the Mesa driver.
 * It uses about 10 GRF registers.
 */

#define SF_KERNEL_NUM_GRF  16
#define SF_MAX_THREADS	   1

static const uint32_t sf_kernel_static[][4] = {
#include "exa_sf.g4b"
};

/*
 * Ok, this kernel picks up the required data flow values in g0 and g1
 * and passes those along in m0 and m1. In m2-m9, it sticks constant
 * values (bright pink).
 */

/* Our PS kernel uses less than 32 GRF registers (about 20) */
#define PS_KERNEL_NUM_GRF   32
#define PS_MAX_THREADS	   32

#define BRW_GRF_BLOCKS(nreg)	((nreg + 15) / 16 - 1)

static const uint32_t ps_kernel_packed_static[][4] = {
#include "exa_wm_xy.g4b"
#include "exa_wm_src_affine.g4b"
#include "exa_wm_src_sample_argb.g4b"
#include "exa_wm_yuv_rgb.g4b"
#include "exa_wm_write.g4b"
};

static const uint32_t ps_kernel_planar_static[][4] = {
#include "exa_wm_xy.g4b"
#include "exa_wm_src_affine.g4b"
#include "exa_wm_src_sample_planar.g4b"
#include "exa_wm_yuv_rgb.g4b"
#include "exa_wm_write.g4b"
};

/* new program for Ironlake */
static const uint32_t sf_kernel_static_gen5[][4] = {
#include "exa_sf.g4b.gen5"
};

static const uint32_t ps_kernel_packed_static_gen5[][4] = {
#include "exa_wm_xy.g4b.gen5"
#include "exa_wm_src_affine.g4b.gen5"
#include "exa_wm_src_sample_argb.g4b.gen5"
#include "exa_wm_yuv_rgb.g4b.gen5"
#include "exa_wm_write.g4b.gen5"
};

static const uint32_t ps_kernel_planar_static_gen5[][4] = {
#include "exa_wm_xy.g4b.gen5"
#include "exa_wm_src_affine.g4b.gen5"
#include "exa_wm_src_sample_planar.g4b.gen5"
#include "exa_wm_yuv_rgb.g4b.gen5"
#include "exa_wm_write.g4b.gen5"
};

/* programs for Sandybridge */
static const uint32_t ps_kernel_packed_static_gen6[][4] = {
#include "exa_wm_src_affine.g6b"
#include "exa_wm_src_sample_argb.g6b"
#include "exa_wm_yuv_rgb.g6b"
#include "exa_wm_write.g6b"
};

static const uint32_t ps_kernel_planar_static_gen6[][4] = {
#include "exa_wm_src_affine.g6b"
#include "exa_wm_src_sample_planar.g6b"
#include "exa_wm_yuv_rgb.g6b"
#include "exa_wm_write.g6b"
};

/* programs for Ivybridge */
static const uint32_t ps_kernel_packed_static_gen7[][4] = {
#include "exa_wm_src_affine.g7b"
#include "exa_wm_src_sample_argb.g7b"
#include "exa_wm_yuv_rgb.g7b"
#include "exa_wm_write.g7b"
};

static const uint32_t ps_kernel_planar_static_gen7[][4] = {
#include "exa_wm_src_affine.g7b"
#include "exa_wm_src_sample_planar.g7b"
#include "exa_wm_yuv_rgb.g7b"
#include "exa_wm_write.g7b"
};

#ifndef MAX2
#define MAX2(a,b) ((a) > (b) ? (a) : (b))
#endif

#define SURFACE_STATE_PADDED_SIZE_I965  ALIGN(sizeof(struct brw_surface_state), 32)
#define SURFACE_STATE_PADDED_SIZE_GEN7  ALIGN(sizeof(struct gen7_surface_state), 32)
#define SURFACE_STATE_PADDED_SIZE       MAX2(SURFACE_STATE_PADDED_SIZE_I965, SURFACE_STATE_PADDED_SIZE_GEN7)
#define SURFACE_STATE_OFFSET(index)     (SURFACE_STATE_PADDED_SIZE * index)

static uint32_t float_to_uint(float f)
{
	union {
		uint32_t i;
		float f;
	} x;
	x.f = f;
	return x.i;
}

#if 0
static struct {
	uint32_t svg_ctl;
	char *name;
} svg_ctl_bits[] = {
	{
	BRW_SVG_CTL_GS_BA, "General State Base Address"}, {
	BRW_SVG_CTL_SS_BA, "Surface State Base Address"}, {
	BRW_SVG_CTL_IO_BA, "Indirect Object Base Address"}, {
	BRW_SVG_CTL_GS_AUB, "Generate State Access Upper Bound"}, {
	BRW_SVG_CTL_IO_AUB, "Indirect Object Access Upper Bound"}, {
	BRW_SVG_CTL_SIP, "System Instruction Pointer"}, {
0, 0},};

static void brw_debug(ScrnInfoPtr scrn, char *when)
{
	intel_screen_private *intel = intel_get_screen_private(scrn);
	int i;
	uint32_t v;

	ErrorF("brw_debug: %s\n", when);
	for (i = 0; svg_ctl_bits[i].name; i++) {
		OUTREG(BRW_SVG_CTL, svg_ctl_bits[i].svg_ctl);
		v = INREG(BRW_SVG_RDATA);
		ErrorF("\t%34.34s: 0x%08x\n", svg_ctl_bits[i].name, v);
	}
}
#endif

#define WATCH_SF 0
#define WATCH_WIZ 0
#define WATCH_STATS 0

static void i965_pre_draw_debug(ScrnInfoPtr scrn)
{
#if 0
	intel_screen_private *intel = intel_get_screen_private(scrn);
#endif

#if 0
	ErrorF("before EU_ATT 0x%08x%08x EU_ATT_DATA 0x%08x%08x\n",
	       INREG(BRW_EU_ATT_1), INREG(BRW_EU_ATT_0),
	       INREG(BRW_EU_ATT_DATA_1), INREG(BRW_EU_ATT_DATA_0));

	OUTREG(BRW_VF_CTL,
	       BRW_VF_CTL_SNAPSHOT_MUX_SELECT_THREADID |
	       BRW_VF_CTL_SNAPSHOT_TYPE_VERTEX_INDEX |
	       BRW_VF_CTL_SNAPSHOT_ENABLE);
	OUTREG(BRW_VF_STRG_VAL, 0);
#endif

#if 0
	OUTREG(BRW_VS_CTL,
	       BRW_VS_CTL_SNAPSHOT_ALL_THREADS |
	       BRW_VS_CTL_SNAPSHOT_MUX_VALID_COUNT |
	       BRW_VS_CTL_THREAD_SNAPSHOT_ENABLE);

	OUTREG(BRW_VS_STRG_VAL, 0);
#endif

#if WATCH_SF
	OUTREG(BRW_SF_CTL,
	       BRW_SF_CTL_SNAPSHOT_MUX_VERTEX_COUNT |
	       BRW_SF_CTL_SNAPSHOT_ALL_THREADS |
	       BRW_SF_CTL_THREAD_SNAPSHOT_ENABLE);
	OUTREG(BRW_SF_STRG_VAL, 0);
#endif

#if WATCH_WIZ
	OUTREG(BRW_WIZ_CTL,
	       BRW_WIZ_CTL_SNAPSHOT_MUX_SUBSPAN_INSTANCE |
	       BRW_WIZ_CTL_SNAPSHOT_ALL_THREADS | BRW_WIZ_CTL_SNAPSHOT_ENABLE);
	OUTREG(BRW_WIZ_STRG_VAL, (box_x1) | (box_y1 << 16));
#endif

#if 0
	OUTREG(BRW_TS_CTL,
	       BRW_TS_CTL_SNAPSHOT_MESSAGE_ERROR |
	       BRW_TS_CTL_SNAPSHOT_ALL_CHILD_THREADS |
	       BRW_TS_CTL_SNAPSHOT_ALL_ROOT_THREADS |
	       BRW_TS_CTL_SNAPSHOT_ENABLE);
#endif
}

static void i965_post_draw_debug(ScrnInfoPtr scrn)
{
#if 0
	intel_screen_private *intel = intel_get_screen_private(scrn);
#endif

#if 0
	for (j = 0; j < 100000; j++) {
		ctl = INREG(BRW_VF_CTL);
		if (ctl & BRW_VF_CTL_SNAPSHOT_COMPLETE)
			break;
	}

	rdata = INREG(BRW_VF_RDATA);
	OUTREG(BRW_VF_CTL, 0);
	ErrorF("VF_CTL: 0x%08x VF_RDATA: 0x%08x\n", ctl, rdata);
#endif

#if 0
	for (j = 0; j < 1000000; j++) {
		ctl = INREG(BRW_VS_CTL);
		if (ctl & BRW_VS_CTL_SNAPSHOT_COMPLETE)
			break;
	}

	rdata = INREG(BRW_VS_RDATA);
	for (k = 0; k <= 3; k++) {
		OUTREG(BRW_VS_CTL, BRW_VS_CTL_SNAPSHOT_COMPLETE | (k << 8));
		rdata = INREG(BRW_VS_RDATA);
		ErrorF("VS_CTL: 0x%08x VS_RDATA(%d): 0x%08x\n", ctl, k, rdata);
	}

	OUTREG(BRW_VS_CTL, 0);
#endif

#if WATCH_SF
	for (j = 0; j < 1000000; j++) {
		ctl = INREG(BRW_SF_CTL);
		if (ctl & BRW_SF_CTL_SNAPSHOT_COMPLETE)
			break;
	}

	for (k = 0; k <= 7; k++) {
		OUTREG(BRW_SF_CTL, BRW_SF_CTL_SNAPSHOT_COMPLETE | (k << 8));
		rdata = INREG(BRW_SF_RDATA);
		ErrorF("SF_CTL: 0x%08x SF_RDATA(%d): 0x%08x\n", ctl, k, rdata);
	}

	OUTREG(BRW_SF_CTL, 0);
#endif

#if WATCH_WIZ
	for (j = 0; j < 100000; j++) {
		ctl = INREG(BRW_WIZ_CTL);
		if (ctl & BRW_WIZ_CTL_SNAPSHOT_COMPLETE)
			break;
	}

	rdata = INREG(BRW_WIZ_RDATA);
	OUTREG(BRW_WIZ_CTL, 0);
	ErrorF("WIZ_CTL: 0x%08x WIZ_RDATA: 0x%08x\n", ctl, rdata);
#endif

#if 0
	for (j = 0; j < 100000; j++) {
		ctl = INREG(BRW_TS_CTL);
		if (ctl & BRW_TS_CTL_SNAPSHOT_COMPLETE)
			break;
	}

	rdata = INREG(BRW_TS_RDATA);
	OUTREG(BRW_TS_CTL, 0);
	ErrorF("TS_CTL: 0x%08x TS_RDATA: 0x%08x\n", ctl, rdata);

	ErrorF("after EU_ATT 0x%08x%08x EU_ATT_DATA 0x%08x%08x\n",
	       INREG(BRW_EU_ATT_1), INREG(BRW_EU_ATT_0),
	       INREG(BRW_EU_ATT_DATA_1), INREG(BRW_EU_ATT_DATA_0));
#endif

#if 0
	for (j = 0; j < 256; j++) {
		OUTREG(BRW_TD_CTL, j << BRW_TD_CTL_MUX_SHIFT);
		rdata = INREG(BRW_TD_RDATA);
		ErrorF("TD_RDATA(%d): 0x%08x\n", j, rdata);
	}
#endif
}

/* For 3D, the VS must have 8, 12, 16, 24, or 32 VUEs allocated to it.
 * A VUE consists of a 256-bit vertex header followed by the vertex data,
 * which in our case is 4 floats (128 bits), thus a single 512-bit URB
 * entry.
 */
#define URB_VS_ENTRIES	      8
#define URB_VS_ENTRY_SIZE     1

#define URB_GS_ENTRIES	      0
#define URB_GS_ENTRY_SIZE     0

#define URB_CLIP_ENTRIES      0
#define URB_CLIP_ENTRY_SIZE   0

/* The SF kernel we use outputs only 4 256-bit registers, leading to an
 * entry size of 2 512-bit URBs.  We don't need to have many entries to
 * output as we're generally working on large rectangles and don't care
 * about having WM threads running on different rectangles simultaneously.
 */
#define URB_SF_ENTRIES	      1
#define URB_SF_ENTRY_SIZE     2

#define URB_CS_ENTRIES	      0
#define URB_CS_ENTRY_SIZE     0

static void i965_create_dst_surface_state(ScrnInfoPtr scrn,
					PixmapPtr pixmap,
					drm_intel_bo *surf_bo,
					uint32_t offset)
{
	intel_screen_private *intel = intel_get_screen_private(scrn);
	struct brw_surface_state dest_surf_state;
	drm_intel_bo *pixmap_bo = intel_get_pixmap_bo(pixmap);
	assert(pixmap_bo != NULL);

	memset(&dest_surf_state, 0, sizeof(dest_surf_state));

	dest_surf_state.ss0.surface_type = BRW_SURFACE_2D;
	dest_surf_state.ss0.data_return_format =
	    BRW_SURFACERETURNFORMAT_FLOAT32;
	if (intel->cpp == 2) {
		dest_surf_state.ss0.surface_format =
		    BRW_SURFACEFORMAT_B5G6R5_UNORM;
	} else {
		dest_surf_state.ss0.surface_format =
		    BRW_SURFACEFORMAT_B8G8R8A8_UNORM;
	}
	dest_surf_state.ss0.writedisable_alpha = 0;
	dest_surf_state.ss0.writedisable_red = 0;
	dest_surf_state.ss0.writedisable_green = 0;
	dest_surf_state.ss0.writedisable_blue = 0;
	dest_surf_state.ss0.color_blend = 1;
	dest_surf_state.ss0.vert_line_stride = 0;
	dest_surf_state.ss0.vert_line_stride_ofs = 0;
	dest_surf_state.ss0.mipmap_layout_mode = 0;
	dest_surf_state.ss0.render_cache_read_mode = 0;

	dest_surf_state.ss1.base_addr =
	    intel_emit_reloc(surf_bo, offset + offsetof(struct brw_surface_state, ss1),
			     pixmap_bo, 0, I915_GEM_DOMAIN_RENDER, I915_GEM_DOMAIN_RENDER);

	dest_surf_state.ss2.height = pixmap->drawable.height - 1;
	dest_surf_state.ss2.width = pixmap->drawable.width - 1;
	dest_surf_state.ss2.mip_count = 0;
	dest_surf_state.ss2.render_target_rotation = 0;
	dest_surf_state.ss3.pitch = intel_pixmap_pitch(pixmap) - 1;
	dest_surf_state.ss3.tiled_surface = intel_pixmap_tiled(pixmap);
	dest_surf_state.ss3.tile_walk = 0;	/* TileX */

	dri_bo_subdata(surf_bo,
		       offset, sizeof(dest_surf_state),
		       &dest_surf_state);
}

static void i965_create_src_surface_state(ScrnInfoPtr scrn,
					drm_intel_bo * src_bo,
					uint32_t src_offset,
					int src_width,
					int src_height,
					int src_pitch,
					uint32_t src_surf_format,
					drm_intel_bo *surface_bo,
					uint32_t offset)
{
	struct brw_surface_state src_surf_state;

	memset(&src_surf_state, 0, sizeof(src_surf_state));

	/* Set up the source surface state buffer */
	src_surf_state.ss0.surface_type = BRW_SURFACE_2D;
	src_surf_state.ss0.surface_format = src_surf_format;
	src_surf_state.ss0.writedisable_alpha = 0;
	src_surf_state.ss0.writedisable_red = 0;
	src_surf_state.ss0.writedisable_green = 0;
	src_surf_state.ss0.writedisable_blue = 0;
	src_surf_state.ss0.color_blend = 1;
	src_surf_state.ss0.vert_line_stride = 0;
	src_surf_state.ss0.vert_line_stride_ofs = 0;
	src_surf_state.ss0.mipmap_layout_mode = 0;
	src_surf_state.ss0.render_cache_read_mode = 0;

	src_surf_state.ss2.width = src_width - 1;
	src_surf_state.ss2.height = src_height - 1;
	src_surf_state.ss2.mip_count = 0;
	src_surf_state.ss2.render_target_rotation = 0;
	src_surf_state.ss3.pitch = src_pitch - 1;

	if (src_bo) {
		src_surf_state.ss1.base_addr =
		    intel_emit_reloc(surface_bo,
				     offset + offsetof(struct brw_surface_state, ss1),
				     src_bo, src_offset,
				     I915_GEM_DOMAIN_SAMPLER, 0);
	} else {
		src_surf_state.ss1.base_addr = src_offset;
	}

	dri_bo_subdata(surface_bo,
		       offset, sizeof(src_surf_state),
		       &src_surf_state);
}

static void gen7_create_dst_surface_state(ScrnInfoPtr scrn,
					PixmapPtr pixmap,
					drm_intel_bo *surf_bo,
					uint32_t offset)
{
	intel_screen_private *intel = intel_get_screen_private(scrn);
	struct gen7_surface_state dest_surf_state;
	drm_intel_bo *pixmap_bo = intel_get_pixmap_bo(pixmap);
	assert(pixmap_bo != NULL);

	memset(&dest_surf_state, 0, sizeof(dest_surf_state));

	dest_surf_state.ss0.surface_type = BRW_SURFACE_2D;
	dest_surf_state.ss0.tiled_surface = intel_pixmap_tiled(pixmap);
	dest_surf_state.ss0.tile_walk = 0;	/* TileX */

	if (intel->cpp == 2) {
		dest_surf_state.ss0.surface_format = BRW_SURFACEFORMAT_B5G6R5_UNORM;
	} else {
		dest_surf_state.ss0.surface_format = BRW_SURFACEFORMAT_B8G8R8A8_UNORM;
	}

	dest_surf_state.ss1.base_addr =
		intel_emit_reloc(surf_bo,
				offset + offsetof(struct gen7_surface_state, ss1),
				pixmap_bo, 0,
				I915_GEM_DOMAIN_SAMPLER, 0);

	dest_surf_state.ss2.height = pixmap->drawable.height - 1;
	dest_surf_state.ss2.width = pixmap->drawable.width - 1;

	dest_surf_state.ss3.pitch = intel_pixmap_pitch(pixmap) - 1;

	if (IS_HSW(intel)) {
		dest_surf_state.ss7.shader_chanel_select_r = HSW_SCS_RED;
		dest_surf_state.ss7.shader_chanel_select_g = HSW_SCS_GREEN;
		dest_surf_state.ss7.shader_chanel_select_b = HSW_SCS_BLUE;
		dest_surf_state.ss7.shader_chanel_select_a = HSW_SCS_ALPHA;
	}

	dri_bo_subdata(surf_bo,
		       offset, sizeof(dest_surf_state),
		       &dest_surf_state);
}

static void gen7_create_src_surface_state(ScrnInfoPtr scrn,
					drm_intel_bo * src_bo,
					uint32_t src_offset,
					int src_width,
					int src_height,
					int src_pitch,
					uint32_t src_surf_format,
					drm_intel_bo *surface_bo,
					uint32_t offset)
{
	intel_screen_private * const intel = intel_get_screen_private(scrn);
	struct gen7_surface_state src_surf_state;

	memset(&src_surf_state, 0, sizeof(src_surf_state));

	src_surf_state.ss0.surface_type = BRW_SURFACE_2D;
	src_surf_state.ss0.surface_format = src_surf_format;

	if (src_bo) {
		src_surf_state.ss1.base_addr =
			intel_emit_reloc(surface_bo,
					offset + offsetof(struct gen7_surface_state, ss1),
					src_bo, src_offset,
					I915_GEM_DOMAIN_SAMPLER, 0);
	} else {
		src_surf_state.ss1.base_addr = src_offset;
	}

	src_surf_state.ss2.width = src_width - 1;
	src_surf_state.ss2.height = src_height - 1;

	src_surf_state.ss3.pitch = src_pitch - 1;

	if (IS_HSW(intel)) {
		src_surf_state.ss7.shader_chanel_select_r = HSW_SCS_RED;
		src_surf_state.ss7.shader_chanel_select_g = HSW_SCS_GREEN;
		src_surf_state.ss7.shader_chanel_select_b = HSW_SCS_BLUE;
		src_surf_state.ss7.shader_chanel_select_a = HSW_SCS_ALPHA;
	}

	dri_bo_subdata(surface_bo,
		       offset, sizeof(src_surf_state),
		       &src_surf_state);
}

static void i965_create_binding_table(ScrnInfoPtr scrn,
				      drm_intel_bo *bind_bo,
				      int n_surf)
{
	uint32_t binding_table[n_surf];
	int i;

	/* Set up a binding table for our surfaces.  Only the PS will use it */
	for (i = 0; i < n_surf; i++)
		binding_table[i] = i * SURFACE_STATE_PADDED_SIZE;

	dri_bo_subdata(bind_bo,
		       n_surf * SURFACE_STATE_PADDED_SIZE,
		       sizeof(binding_table), binding_table);
}

static drm_intel_bo *i965_create_sampler_state(ScrnInfoPtr scrn)
{
	intel_screen_private *intel = intel_get_screen_private(scrn);
	struct brw_sampler_state sampler_state;

	memset(&sampler_state, 0, sizeof(sampler_state));
	sampler_state.ss0.min_filter = BRW_MAPFILTER_LINEAR;
	sampler_state.ss0.mag_filter = BRW_MAPFILTER_LINEAR;
	sampler_state.ss1.r_wrap_mode = BRW_TEXCOORDMODE_CLAMP;
	sampler_state.ss1.s_wrap_mode = BRW_TEXCOORDMODE_CLAMP;
	sampler_state.ss1.t_wrap_mode = BRW_TEXCOORDMODE_CLAMP;

	return intel_bo_alloc_for_data(intel,
				       &sampler_state, sizeof(sampler_state),
				       "textured video sampler state");
}

static drm_intel_bo *gen7_create_sampler_state(ScrnInfoPtr scrn)
{
	intel_screen_private *intel = intel_get_screen_private(scrn);
	struct gen7_sampler_state sampler_state;

	memset(&sampler_state, 0, sizeof(sampler_state));
	sampler_state.ss0.min_filter = BRW_MAPFILTER_LINEAR;
	sampler_state.ss0.mag_filter = BRW_MAPFILTER_LINEAR;
	sampler_state.ss3.r_wrap_mode = BRW_TEXCOORDMODE_CLAMP;
	sampler_state.ss3.s_wrap_mode = BRW_TEXCOORDMODE_CLAMP;
	sampler_state.ss3.t_wrap_mode = BRW_TEXCOORDMODE_CLAMP;

	return intel_bo_alloc_for_data(intel,
				       &sampler_state, sizeof(sampler_state),
				       "textured video sampler state");
}

static drm_intel_bo *i965_create_vs_state(ScrnInfoPtr scrn)
{
	intel_screen_private *intel = intel_get_screen_private(scrn);
	struct brw_vs_unit_state vs_state;

	/* Set up the vertex shader to be disabled (passthrough) */
	memset(&vs_state, 0, sizeof(vs_state));
	if (IS_GEN5(intel))
		vs_state.thread4.nr_urb_entries = URB_VS_ENTRIES >> 2;
	else
		vs_state.thread4.nr_urb_entries = URB_VS_ENTRIES;
	vs_state.thread4.urb_entry_allocation_size = URB_VS_ENTRY_SIZE - 1;
	vs_state.vs6.vs_enable = 0;
	vs_state.vs6.vert_cache_disable = 1;

	return intel_bo_alloc_for_data(intel,
				       &vs_state, sizeof(vs_state),
				       "textured video vs state");
}

static drm_intel_bo *i965_create_program(ScrnInfoPtr scrn,
					 const uint32_t * program,
					 unsigned int program_size)
{
	intel_screen_private *intel = intel_get_screen_private(scrn);
	return intel_bo_alloc_for_data(intel,
				       program, program_size,
				       "textured video program");
}

static drm_intel_bo *i965_create_sf_state(ScrnInfoPtr scrn)
{
	intel_screen_private *intel = intel_get_screen_private(scrn);
	drm_intel_bo *sf_bo, *kernel_bo;
	struct brw_sf_unit_state sf_state;

	if (IS_GEN5(intel))
		kernel_bo = i965_create_program(scrn,
						&sf_kernel_static_gen5[0][0],
						sizeof(sf_kernel_static_gen5));
	else
		kernel_bo = i965_create_program(scrn,
						&sf_kernel_static[0][0],
						sizeof(sf_kernel_static));
	if (!kernel_bo)
		return NULL;

	sf_bo = drm_intel_bo_alloc(intel->bufmgr,
				   "textured video sf state", 4096,
				   sizeof(sf_state));
	if (sf_bo == NULL) {
		drm_intel_bo_unreference(kernel_bo);
		return NULL;
	}

	/* Set up the SF kernel to do coord interp: for each attribute,
	 * calculate dA/dx and dA/dy.  Hand these interpolation coefficients
	 * back to SF which then hands pixels off to WM.
	 */
	memset(&sf_state, 0, sizeof(sf_state));
	sf_state.thread0.grf_reg_count = BRW_GRF_BLOCKS(SF_KERNEL_NUM_GRF);
	sf_state.thread0.kernel_start_pointer =
	    intel_emit_reloc(sf_bo, offsetof(struct brw_sf_unit_state, thread0),
			     kernel_bo, sf_state.thread0.grf_reg_count << 1,
			     I915_GEM_DOMAIN_INSTRUCTION, 0) >> 6;
	sf_state.sf1.single_program_flow = 1;	/* XXX */
	sf_state.sf1.binding_table_entry_count = 0;
	sf_state.sf1.thread_priority = 0;
	sf_state.sf1.floating_point_mode = 0;	/* Mesa does this */
	sf_state.sf1.illegal_op_exception_enable = 1;
	sf_state.sf1.mask_stack_exception_enable = 1;
	sf_state.sf1.sw_exception_enable = 1;
	sf_state.thread2.per_thread_scratch_space = 0;
	/* scratch space is not used in our kernel */
	sf_state.thread2.scratch_space_base_pointer = 0;
	sf_state.thread3.const_urb_entry_read_length = 0;	/* no const URBs */
	sf_state.thread3.const_urb_entry_read_offset = 0;	/* no const URBs */
	sf_state.thread3.urb_entry_read_length = 1;	/* 1 URB per vertex */
	sf_state.thread3.urb_entry_read_offset = 0;
	sf_state.thread3.dispatch_grf_start_reg = 3;
	sf_state.thread4.max_threads = SF_MAX_THREADS - 1;
	sf_state.thread4.urb_entry_allocation_size = URB_SF_ENTRY_SIZE - 1;
	sf_state.thread4.nr_urb_entries = URB_SF_ENTRIES;
	sf_state.thread4.stats_enable = 1;
	sf_state.sf5.viewport_transform = FALSE;	/* skip viewport */
	sf_state.sf6.cull_mode = BRW_CULLMODE_NONE;
	sf_state.sf6.scissor = 0;
	sf_state.sf7.trifan_pv = 2;
	sf_state.sf6.dest_org_vbias = 0x8;
	sf_state.sf6.dest_org_hbias = 0x8;

	dri_bo_subdata(sf_bo, 0, sizeof(sf_state), &sf_state);
	return sf_bo;
}

static drm_intel_bo *i965_create_wm_state(ScrnInfoPtr scrn,
					  drm_intel_bo * sampler_bo,
					  Bool is_packed)
{
	intel_screen_private *intel = intel_get_screen_private(scrn);
	drm_intel_bo *wm_bo, *kernel_bo;
	struct brw_wm_unit_state wm_state;

	if (is_packed) {
		if (IS_GEN5(intel))
			kernel_bo =
			    i965_create_program(scrn,
						&ps_kernel_packed_static_gen5[0]
						[0],
						sizeof
						(ps_kernel_packed_static_gen5));
		else
			kernel_bo =
			    i965_create_program(scrn,
						&ps_kernel_packed_static[0][0],
						sizeof
						(ps_kernel_packed_static));
	} else {
		if (IS_GEN5(intel))
			kernel_bo =
			    i965_create_program(scrn,
						&ps_kernel_planar_static_gen5[0]
						[0],
						sizeof
						(ps_kernel_planar_static_gen5));
		else
			kernel_bo =
			    i965_create_program(scrn,
						&ps_kernel_planar_static[0][0],
						sizeof
						(ps_kernel_planar_static));
	}
	if (!kernel_bo)
		return NULL;

	wm_bo = drm_intel_bo_alloc(intel->bufmgr,
				   "textured video wm state",
				   sizeof(wm_state), 0);
	if (wm_bo == NULL) {
		drm_intel_bo_unreference(kernel_bo);
		return NULL;
	}

	memset(&wm_state, 0, sizeof(wm_state));
	wm_state.thread0.grf_reg_count = BRW_GRF_BLOCKS(PS_KERNEL_NUM_GRF);
	wm_state.thread0.kernel_start_pointer =
	    intel_emit_reloc(wm_bo, offsetof(struct brw_wm_unit_state, thread0),
			     kernel_bo, wm_state.thread0.grf_reg_count << 1,
			     I915_GEM_DOMAIN_INSTRUCTION, 0) >> 6;
	wm_state.thread1.single_program_flow = 1;	/* XXX */
	if (is_packed)
		wm_state.thread1.binding_table_entry_count = 2;
	else
		wm_state.thread1.binding_table_entry_count = 7;

	/* binding table entry count is only used for prefetching, and it has to
	 * be set 0 for Ironlake
	 */
	if (IS_GEN5(intel))
		wm_state.thread1.binding_table_entry_count = 0;

	/* Though we never use the scratch space in our WM kernel, it has to be
	 * set, and the minimum allocation is 1024 bytes.
	 */
	wm_state.thread2.scratch_space_base_pointer = 0;
	wm_state.thread2.per_thread_scratch_space = 0;	/* 1024 bytes */
	wm_state.thread3.dispatch_grf_start_reg = 3;	/* XXX */
	wm_state.thread3.const_urb_entry_read_length = 0;
	wm_state.thread3.const_urb_entry_read_offset = 0;
	wm_state.thread3.urb_entry_read_length = 1;	/* XXX */
	wm_state.thread3.urb_entry_read_offset = 0;	/* XXX */
	wm_state.wm4.stats_enable = 1;
	wm_state.wm4.sampler_state_pointer =
	    intel_emit_reloc(wm_bo, offsetof(struct brw_wm_unit_state, wm4),
			     sampler_bo, 0,
			     I915_GEM_DOMAIN_INSTRUCTION, 0) >> 5;
	if (IS_GEN5(intel))
		wm_state.wm4.sampler_count = 0;
	else
		wm_state.wm4.sampler_count = 1;	/* 1-4 samplers used */
	wm_state.wm5.max_threads = PS_MAX_THREADS - 1;
	wm_state.wm5.thread_dispatch_enable = 1;
	wm_state.wm5.enable_16_pix = 1;
	wm_state.wm5.enable_8_pix = 0;
	wm_state.wm5.early_depth_test = 1;

	dri_bo_subdata(wm_bo, 0, sizeof(wm_state), &wm_state);
	drm_intel_bo_unreference(kernel_bo);
	return wm_bo;
}

static drm_intel_bo *i965_create_cc_vp_state(ScrnInfoPtr scrn)
{
	intel_screen_private *intel = intel_get_screen_private(scrn);
	struct brw_cc_viewport cc_viewport;

	memset(&cc_viewport, 0, sizeof(cc_viewport));
	cc_viewport.min_depth = -1.e35;
	cc_viewport.max_depth = 1.e35;

	return intel_bo_alloc_for_data(intel,
				       &cc_viewport, sizeof(cc_viewport),
				       "textured video cc viewport");
}

static drm_intel_bo *i965_create_cc_state(ScrnInfoPtr scrn)
{
	intel_screen_private *intel = intel_get_screen_private(scrn);
	drm_intel_bo *cc_bo, *cc_vp_bo;
	struct brw_cc_unit_state cc_state;

	cc_vp_bo = i965_create_cc_vp_state(scrn);
	if (!cc_vp_bo)
		return NULL;

	cc_bo = drm_intel_bo_alloc(intel->bufmgr,
				   "textured video cc state",
				   sizeof(cc_state), 0);
	if (cc_bo == NULL){
		drm_intel_bo_unreference(cc_vp_bo);
		return NULL;
	}

	/* Color calculator state */
	memset(&cc_state, 0, sizeof(cc_state));
	cc_state.cc0.stencil_enable = 0;	/* disable stencil */
	cc_state.cc2.depth_test = 0;	/* disable depth test */
	cc_state.cc2.logicop_enable = 1;	/* enable logic op */
	cc_state.cc3.ia_blend_enable = 1;	/* blend alpha just like colors */
	cc_state.cc3.blend_enable = 0;	/* disable color blend */
	cc_state.cc3.alpha_test = 0;	/* disable alpha test */
	cc_state.cc4.cc_viewport_state_offset =
	    intel_emit_reloc(cc_bo, offsetof(struct brw_cc_unit_state, cc4),
			     cc_vp_bo, 0, I915_GEM_DOMAIN_INSTRUCTION, 0) >> 5;
	cc_state.cc5.dither_enable = 0;	/* disable dither */
	cc_state.cc5.logicop_func = 0xc;	/* WHITE */
	cc_state.cc5.statistics_enable = 1;
	cc_state.cc5.ia_blend_function = BRW_BLENDFUNCTION_ADD;
	cc_state.cc5.ia_src_blend_factor = BRW_BLENDFACTOR_ONE;
	cc_state.cc5.ia_dest_blend_factor = BRW_BLENDFACTOR_ONE;

	dri_bo_subdata(cc_bo, 0, sizeof(cc_state), &cc_state);
	drm_intel_bo_unreference(cc_vp_bo);

	return cc_bo;
}

static void
i965_emit_video_setup(ScrnInfoPtr scrn, drm_intel_bo * surface_state_binding_table_bo, int n_src_surf, PixmapPtr pixmap)
{
	intel_screen_private *intel = intel_get_screen_private(scrn);
	int urb_vs_start, urb_vs_size;
	int urb_gs_start, urb_gs_size;
	int urb_clip_start, urb_clip_size;
	int urb_sf_start, urb_sf_size;
	int urb_cs_start, urb_cs_size;
	int pipe_ctl;

	IntelEmitInvarientState(scrn);
	intel->last_3d = LAST_3D_VIDEO;
	intel->needs_3d_invariant = TRUE;

	urb_vs_start = 0;
	urb_vs_size = URB_VS_ENTRIES * URB_VS_ENTRY_SIZE;
	urb_gs_start = urb_vs_start + urb_vs_size;
	urb_gs_size = URB_GS_ENTRIES * URB_GS_ENTRY_SIZE;
	urb_clip_start = urb_gs_start + urb_gs_size;
	urb_clip_size = URB_CLIP_ENTRIES * URB_CLIP_ENTRY_SIZE;
	urb_sf_start = urb_clip_start + urb_clip_size;
	urb_sf_size = URB_SF_ENTRIES * URB_SF_ENTRY_SIZE;
	urb_cs_start = urb_sf_start + urb_sf_size;
	urb_cs_size = URB_CS_ENTRIES * URB_CS_ENTRY_SIZE;

	OUT_BATCH(MI_FLUSH |
		  MI_STATE_INSTRUCTION_CACHE_FLUSH |
		  BRW_MI_GLOBAL_SNAPSHOT_RESET);
	OUT_BATCH(MI_NOOP);

	/* brw_debug (scrn, "before base address modify"); */
	/* Match Mesa driver setup */
	if (INTEL_INFO(intel)->gen >= 045)
		OUT_BATCH(NEW_PIPELINE_SELECT | PIPELINE_SELECT_3D);
	else
		OUT_BATCH(BRW_PIPELINE_SELECT | PIPELINE_SELECT_3D);

	/* Mesa does this. Who knows... */
	OUT_BATCH(BRW_CS_URB_STATE | 0);
	OUT_BATCH((0 << 4) |	/* URB Entry Allocation Size */
		  (0 << 0));	/* Number of URB Entries */

	/* Zero out the two base address registers so all offsets are
	 * absolute
	 */
	if (IS_GEN5(intel)) {
		OUT_BATCH(BRW_STATE_BASE_ADDRESS | 6);
		OUT_BATCH(0 | BASE_ADDRESS_MODIFY);	/* Generate state base address */
		OUT_RELOC(surface_state_binding_table_bo, I915_GEM_DOMAIN_INSTRUCTION, 0, BASE_ADDRESS_MODIFY); /* Surface state base address */
		OUT_BATCH(0 | BASE_ADDRESS_MODIFY);	/* media base addr, don't care */
		OUT_BATCH(0 | BASE_ADDRESS_MODIFY);	/* Instruction base address */
		/* general state max addr, disabled */
		OUT_BATCH(0 | BASE_ADDRESS_MODIFY);
		/* media object state max addr, disabled */
		OUT_BATCH(0 | BASE_ADDRESS_MODIFY);
		/* Instruction max addr, disabled */
		OUT_BATCH(0 | BASE_ADDRESS_MODIFY);
	} else {
		OUT_BATCH(BRW_STATE_BASE_ADDRESS | 4);
		OUT_BATCH(0 | BASE_ADDRESS_MODIFY);	/* Generate state base address */
		OUT_RELOC(surface_state_binding_table_bo, I915_GEM_DOMAIN_INSTRUCTION, 0, BASE_ADDRESS_MODIFY); /* Surface state base address */
		OUT_BATCH(0 | BASE_ADDRESS_MODIFY);	/* media base addr, don't care */
		/* general state max addr, disabled */
		OUT_BATCH(0 | BASE_ADDRESS_MODIFY);
		/* media object state max addr, disabled */
		OUT_BATCH(0 | BASE_ADDRESS_MODIFY);
	}

	/* Set system instruction pointer */
	OUT_BATCH(BRW_STATE_SIP | 0);
	/* system instruction pointer */
	OUT_RELOC(intel->video.gen4_sip_kernel_bo,
		  I915_GEM_DOMAIN_INSTRUCTION, 0, 0);

	/* brw_debug (scrn, "after base address modify"); */

	if (IS_GEN5(intel))
		pipe_ctl = BRW_PIPE_CONTROL_NOWRITE;
	else
		pipe_ctl = BRW_PIPE_CONTROL_NOWRITE | BRW_PIPE_CONTROL_IS_FLUSH;

	/* Pipe control */
	OUT_BATCH(BRW_PIPE_CONTROL | pipe_ctl | 2);
	OUT_BATCH(0);		/* Destination address */
	OUT_BATCH(0);		/* Immediate data low DW */
	OUT_BATCH(0);		/* Immediate data high DW */

	/* Binding table pointers */
	OUT_BATCH(BRW_3DSTATE_BINDING_TABLE_POINTERS | 4);
	OUT_BATCH(0);		/* vs */
	OUT_BATCH(0);		/* gs */
	OUT_BATCH(0);		/* clip */
	OUT_BATCH(0);		/* sf */
	/* Only the PS uses the binding table */
	OUT_BATCH((n_src_surf + 1) * SURFACE_STATE_PADDED_SIZE);

	/* Blend constant color (magenta is fun) */
	OUT_BATCH(BRW_3DSTATE_CONSTANT_COLOR | 3);
	OUT_BATCH(float_to_uint(1.0));
	OUT_BATCH(float_to_uint(0.0));
	OUT_BATCH(float_to_uint(1.0));
	OUT_BATCH(float_to_uint(1.0));

	/* The drawing rectangle clipping is always on.  Set it to values that
	 * shouldn't do any clipping.
	 */
	OUT_BATCH(BRW_3DSTATE_DRAWING_RECTANGLE | 2);	/* XXX 3 for BLC or CTG */
	OUT_BATCH(0x00000000);	/* ymin, xmin */
	OUT_BATCH((pixmap->drawable.width - 1) | (pixmap->drawable.height - 1) << 16);	/* ymax, xmax */
	OUT_BATCH(0x00000000);	/* yorigin, xorigin */

	/* skip the depth buffer */
	/* skip the polygon stipple */
	/* skip the polygon stipple offset */
	/* skip the line stipple */

	/* Set the pointers to the 3d pipeline state */
	OUT_BATCH(BRW_3DSTATE_PIPELINED_POINTERS | 5);
	OUT_RELOC(intel->video.gen4_vs_bo, I915_GEM_DOMAIN_INSTRUCTION, 0, 0);
	/* disable GS, resulting in passthrough */
	OUT_BATCH(BRW_GS_DISABLE);
	/* disable CLIP, resulting in passthrough */
	OUT_BATCH(BRW_CLIP_DISABLE);
	OUT_RELOC(intel->video.gen4_sf_bo, I915_GEM_DOMAIN_INSTRUCTION, 0, 0);
	if (n_src_surf == 1)
		OUT_RELOC(intel->video.gen4_wm_packed_bo,
			  I915_GEM_DOMAIN_INSTRUCTION, 0, 0);
	else
		OUT_RELOC(intel->video.gen4_wm_planar_bo,
			  I915_GEM_DOMAIN_INSTRUCTION, 0, 0);
	OUT_RELOC(intel->video.gen4_cc_bo, I915_GEM_DOMAIN_INSTRUCTION, 0, 0);

	/* URB fence */
	OUT_BATCH(BRW_URB_FENCE |
		  UF0_CS_REALLOC |
		  UF0_SF_REALLOC |
		  UF0_CLIP_REALLOC | UF0_GS_REALLOC | UF0_VS_REALLOC | 1);
	OUT_BATCH(((urb_clip_start + urb_clip_size) << UF1_CLIP_FENCE_SHIFT) |
		  ((urb_gs_start + urb_gs_size) << UF1_GS_FENCE_SHIFT) |
		  ((urb_vs_start + urb_vs_size) << UF1_VS_FENCE_SHIFT));
	OUT_BATCH(((urb_cs_start + urb_cs_size) << UF2_CS_FENCE_SHIFT) |
		  ((urb_sf_start + urb_sf_size) << UF2_SF_FENCE_SHIFT));

	/* Constant buffer state */
	OUT_BATCH(BRW_CS_URB_STATE | 0);
	OUT_BATCH(((URB_CS_ENTRY_SIZE - 1) << 4) | (URB_CS_ENTRIES << 0));

	/* Set up our vertex elements, sourced from the single vertex buffer. */

	if (IS_GEN5(intel)) {
		OUT_BATCH(BRW_3DSTATE_VERTEX_ELEMENTS | 3);
		/* offset 0: X,Y -> {X, Y, 1.0, 1.0} */
		OUT_BATCH((0 << VE0_VERTEX_BUFFER_INDEX_SHIFT) |
			  VE0_VALID |
			  (BRW_SURFACEFORMAT_R32G32_FLOAT << VE0_FORMAT_SHIFT) |
			  (0 << VE0_OFFSET_SHIFT));
		OUT_BATCH((BRW_VFCOMPONENT_STORE_SRC << VE1_VFCOMPONENT_0_SHIFT)
			  | (BRW_VFCOMPONENT_STORE_SRC <<
			     VE1_VFCOMPONENT_1_SHIFT) |
			  (BRW_VFCOMPONENT_STORE_1_FLT <<
			   VE1_VFCOMPONENT_2_SHIFT) |
			  (BRW_VFCOMPONENT_STORE_1_FLT <<
			   VE1_VFCOMPONENT_3_SHIFT));
		/* offset 8: S0, T0 -> {S0, T0, 1.0, 1.0} */
		OUT_BATCH((0 << VE0_VERTEX_BUFFER_INDEX_SHIFT) |
			  VE0_VALID |
			  (BRW_SURFACEFORMAT_R32G32_FLOAT << VE0_FORMAT_SHIFT) |
			  (8 << VE0_OFFSET_SHIFT));
		OUT_BATCH((BRW_VFCOMPONENT_STORE_SRC << VE1_VFCOMPONENT_0_SHIFT)
			  | (BRW_VFCOMPONENT_STORE_SRC <<
			     VE1_VFCOMPONENT_1_SHIFT) |
			  (BRW_VFCOMPONENT_STORE_1_FLT <<
			   VE1_VFCOMPONENT_2_SHIFT) |
			  (BRW_VFCOMPONENT_STORE_1_FLT <<
			   VE1_VFCOMPONENT_3_SHIFT));
	} else {
		OUT_BATCH(BRW_3DSTATE_VERTEX_ELEMENTS | 3);
		/* offset 0: X,Y -> {X, Y, 1.0, 1.0} */
		OUT_BATCH((0 << VE0_VERTEX_BUFFER_INDEX_SHIFT) |
			  VE0_VALID |
			  (BRW_SURFACEFORMAT_R32G32_FLOAT << VE0_FORMAT_SHIFT) |
			  (0 << VE0_OFFSET_SHIFT));
		OUT_BATCH((BRW_VFCOMPONENT_STORE_SRC << VE1_VFCOMPONENT_0_SHIFT)
			  | (BRW_VFCOMPONENT_STORE_SRC <<
			     VE1_VFCOMPONENT_1_SHIFT) |
			  (BRW_VFCOMPONENT_STORE_1_FLT <<
			   VE1_VFCOMPONENT_2_SHIFT) |
			  (BRW_VFCOMPONENT_STORE_1_FLT <<
			   VE1_VFCOMPONENT_3_SHIFT) | (0 <<
						       VE1_DESTINATION_ELEMENT_OFFSET_SHIFT));
		/* offset 8: S0, T0 -> {S0, T0, 1.0, 1.0} */
		OUT_BATCH((0 << VE0_VERTEX_BUFFER_INDEX_SHIFT) |
			  VE0_VALID |
			  (BRW_SURFACEFORMAT_R32G32_FLOAT << VE0_FORMAT_SHIFT) |
			  (8 << VE0_OFFSET_SHIFT));
		OUT_BATCH((BRW_VFCOMPONENT_STORE_SRC << VE1_VFCOMPONENT_0_SHIFT)
			  | (BRW_VFCOMPONENT_STORE_SRC <<
			     VE1_VFCOMPONENT_1_SHIFT) |
			  (BRW_VFCOMPONENT_STORE_1_FLT <<
			   VE1_VFCOMPONENT_2_SHIFT) |
			  (BRW_VFCOMPONENT_STORE_1_FLT <<
			   VE1_VFCOMPONENT_3_SHIFT) | (4 <<
						       VE1_DESTINATION_ELEMENT_OFFSET_SHIFT));
	}
}

void
I965DisplayVideoTextured(ScrnInfoPtr scrn,
			 intel_adaptor_private *adaptor_priv, int id,
			 RegionPtr dstRegion,
			 short width, short height,
			 int video_pitch, int video_pitch2,
			 short src_w, short src_h,
			 short drw_w, short drw_h, PixmapPtr pixmap)
{
	intel_screen_private *intel = intel_get_screen_private(scrn);
	BoxPtr pbox;
	int nbox, dxo, dyo, pix_xoff, pix_yoff;
	float src_scale_x, src_scale_y;
	int src_surf;
	int n_src_surf;
	uint32_t src_surf_format;
	uint32_t src_surf_base[6];
	int src_width[6];
	int src_height[6];
	int src_pitch[6];
	drm_intel_bo *surface_state_binding_table_bo;

#if 0
	ErrorF("BroadwaterDisplayVideoTextured: %dx%d (pitch %d)\n", width,
	       height, video_pitch);
#endif

#if 0
	/* enable debug */
	OUTREG(INST_PM, (1 << (16 + 4)) | (1 << 4));
	ErrorF("INST_PM 0x%08x\n", INREG(INST_PM));
#endif

	src_surf_base[0] = adaptor_priv->YBufOffset;
	src_surf_base[1] = adaptor_priv->YBufOffset;
	src_surf_base[2] = adaptor_priv->VBufOffset;
	src_surf_base[3] = adaptor_priv->VBufOffset;
	src_surf_base[4] = adaptor_priv->UBufOffset;
	src_surf_base[5] = adaptor_priv->UBufOffset;
#if 0
	ErrorF("base 0 0x%x base 1 0x%x base 2 0x%x\n",
	       src_surf_base[0], src_surf_base[1], src_surf_base[2]);
#endif

	if (is_planar_fourcc(id)) {
		src_surf_format = BRW_SURFACEFORMAT_R8_UNORM;
		src_width[1] = src_width[0] = width;
		src_height[1] = src_height[0] = height;
		src_pitch[1] = src_pitch[0] = video_pitch2;
		src_width[4] = src_width[5] = src_width[2] = src_width[3] =
		    width / 2;
		src_height[4] = src_height[5] = src_height[2] = src_height[3] =
		    height / 2;
		src_pitch[4] = src_pitch[5] = src_pitch[2] = src_pitch[3] =
		    video_pitch;
		n_src_surf = 6;
	} else {
		if (id == FOURCC_UYVY)
			src_surf_format = BRW_SURFACEFORMAT_YCRCB_SWAPY;
		else
			src_surf_format = BRW_SURFACEFORMAT_YCRCB_NORMAL;

		src_width[0] = width;
		src_height[0] = height;
		src_pitch[0] = video_pitch;
		n_src_surf = 1;
	}

#if 0
	ErrorF("dst surf:      0x%08x\n", state_base_offset + dest_surf_offset);
	ErrorF("src surf:      0x%08x\n", state_base_offset + src_surf_offset);
#endif

	/* We'll be poking the state buffers that could be in use by the 3d
	 * hardware here, but we should have synced the 3D engine already in
	 * I830PutImage.
	 */

	surface_state_binding_table_bo = 
		drm_intel_bo_alloc(intel->bufmgr,
				"surface state & binding table",
				(n_src_surf + 1) * (SURFACE_STATE_PADDED_SIZE + sizeof(uint32_t)),
				4096);

	if (!surface_state_binding_table_bo)
		return;
				
	i965_create_dst_surface_state(scrn, pixmap, surface_state_binding_table_bo, 0);

	for (src_surf = 0; src_surf < n_src_surf; src_surf++) {
		i965_create_src_surface_state(scrn,
					adaptor_priv->buf,
					src_surf_base[src_surf],
					src_width[src_surf],
					src_height[src_surf],
					src_pitch[src_surf],
					src_surf_format,
					surface_state_binding_table_bo,
					(src_surf + 1) * SURFACE_STATE_PADDED_SIZE);
	}

	i965_create_binding_table(scrn, surface_state_binding_table_bo, n_src_surf + 1);

	if (intel->video.gen4_sampler_bo == NULL)
		intel->video.gen4_sampler_bo = i965_create_sampler_state(scrn);
	if (intel->video.gen4_sip_kernel_bo == NULL) {
		intel->video.gen4_sip_kernel_bo =
		    i965_create_program(scrn, &sip_kernel_static[0][0],
					sizeof(sip_kernel_static));
		if (!intel->video.gen4_sip_kernel_bo) {
			drm_intel_bo_unreference(surface_state_binding_table_bo);
			return;
		}
	}

	if (intel->video.gen4_vs_bo == NULL) {
		intel->video.gen4_vs_bo = i965_create_vs_state(scrn);
		if (!intel->video.gen4_vs_bo) {
			drm_intel_bo_unreference(surface_state_binding_table_bo);
			return;
		}
	}
	if (intel->video.gen4_sf_bo == NULL) {
		intel->video.gen4_sf_bo = i965_create_sf_state(scrn);
		if (!intel->video.gen4_sf_bo) {
			drm_intel_bo_unreference(surface_state_binding_table_bo);
			return;
		}
	}
	if (intel->video.gen4_wm_packed_bo == NULL) {
		intel->video.gen4_wm_packed_bo =
		    i965_create_wm_state(scrn, intel->video.gen4_sampler_bo,
					 TRUE);
		if (!intel->video.gen4_wm_packed_bo) {
			drm_intel_bo_unreference(surface_state_binding_table_bo);
			return;
		}
	}

	if (intel->video.gen4_wm_planar_bo == NULL) {
		intel->video.gen4_wm_planar_bo =
		    i965_create_wm_state(scrn, intel->video.gen4_sampler_bo,
					 FALSE);
		if (!intel->video.gen4_wm_planar_bo) {
			drm_intel_bo_unreference(surface_state_binding_table_bo);
			return;
		}
	}

	if (intel->video.gen4_cc_bo == NULL) {
		intel->video.gen4_cc_bo = i965_create_cc_state(scrn);
		if (!intel->video.gen4_cc_bo) {
			drm_intel_bo_unreference(surface_state_binding_table_bo);
			return;
		}
	}

	/* Set up the offset for translating from the given region (in screen
	 * coordinates) to the backing pixmap.
	 */
#ifdef COMPOSITE
	pix_xoff = -pixmap->screen_x + pixmap->drawable.x;
	pix_yoff = -pixmap->screen_y + pixmap->drawable.y;
#else
	pix_xoff = 0;
	pix_yoff = 0;
#endif

	dxo = dstRegion->extents.x1;
	dyo = dstRegion->extents.y1;

	/* Use normalized texture coordinates */
	src_scale_x = ((float)src_w / width) / (float)drw_w;
	src_scale_y = ((float)src_h / height) / (float)drw_h;

	pbox = REGION_RECTS(dstRegion);
	nbox = REGION_NUM_RECTS(dstRegion);
	while (nbox--) {
		int box_x1 = pbox->x1;
		int box_y1 = pbox->y1;
		int box_x2 = pbox->x2;
		int box_y2 = pbox->y2;
		int i;
		float vb[12];
		drm_intel_bo *bo_table[] = {
			NULL,	/* vb_bo */
			intel->batch_bo,
			surface_state_binding_table_bo,
			intel->video.gen4_sampler_bo,
			intel->video.gen4_sip_kernel_bo,
			intel->video.gen4_vs_bo,
			intel->video.gen4_sf_bo,
			intel->video.gen4_wm_packed_bo,
			intel->video.gen4_wm_planar_bo,
			intel->video.gen4_cc_bo,
		};

		pbox++;

		i = 0;
		vb[i++] = (box_x2 - dxo) * src_scale_x;
		vb[i++] = (box_y2 - dyo) * src_scale_y;
		vb[i++] = (float)box_x2 + pix_xoff;
		vb[i++] = (float)box_y2 + pix_yoff;

		vb[i++] = (box_x1 - dxo) * src_scale_x;
		vb[i++] = (box_y2 - dyo) * src_scale_y;
		vb[i++] = (float)box_x1 + pix_xoff;
		vb[i++] = (float)box_y2 + pix_yoff;

		vb[i++] = (box_x1 - dxo) * src_scale_x;
		vb[i++] = (box_y1 - dyo) * src_scale_y;
		vb[i++] = (float)box_x1 + pix_xoff;
		vb[i++] = (float)box_y1 + pix_yoff;

		bo_table[0] = intel_bo_alloc_for_data(intel,
						      vb, sizeof(vb),
						      "textured video vbo");

		if (IS_GEN4(intel))
			i965_pre_draw_debug(scrn);

		/* If this command won't fit in the current batch, flush.
		 * Assume that it does after being flushed.
		 */
		if (drm_intel_bufmgr_check_aperture_space(bo_table,
							  ARRAY_SIZE(bo_table))
		    < 0) {
			intel_batch_submit(scrn);
		}

		intel_batch_start_atomic(scrn, 150);

		i965_emit_video_setup(scrn, surface_state_binding_table_bo, n_src_surf, pixmap);

		/* Set up the pointer to our vertex buffer */
		OUT_BATCH(BRW_3DSTATE_VERTEX_BUFFERS | 3);
		/* four 32-bit floats per vertex */
		OUT_BATCH((0 << VB0_BUFFER_INDEX_SHIFT) |
			  VB0_VERTEXDATA | ((4 * 4) << VB0_BUFFER_PITCH_SHIFT));
		OUT_RELOC(bo_table[0], I915_GEM_DOMAIN_VERTEX, 0, 0);
		if (IS_GEN5(intel))
			OUT_RELOC(bo_table[0], I915_GEM_DOMAIN_VERTEX, 0,
				  i * 4);
		else
			OUT_BATCH(3);	/* four corners to our rectangle */
		OUT_BATCH(0);	/* reserved */

		OUT_BATCH(BRW_3DPRIMITIVE | BRW_3DPRIMITIVE_VERTEX_SEQUENTIAL | (_3DPRIM_RECTLIST << BRW_3DPRIMITIVE_TOPOLOGY_SHIFT) | (0 << 9) |	/* CTG - indirect vertex count */
			  4);
		OUT_BATCH(3);	/* vertex count per instance */
		OUT_BATCH(0);	/* start vertex offset */
		OUT_BATCH(1);	/* single instance */
		OUT_BATCH(0);	/* start instance location */
		OUT_BATCH(0);	/* index buffer offset, ignored */
		OUT_BATCH(MI_NOOP);

		intel_batch_end_atomic(scrn);

		drm_intel_bo_unreference(bo_table[0]);

		if (IS_GEN4(intel))
			i965_post_draw_debug(scrn);

	}

	/* release reference once we're finished */
	drm_intel_bo_unreference(surface_state_binding_table_bo);

	intel_debug_flush(scrn);
}

void i965_free_video(ScrnInfoPtr scrn)
{
	intel_screen_private *intel = intel_get_screen_private(scrn);

	drm_intel_bo_unreference(intel->video.gen4_vs_bo);
	intel->video.gen4_vs_bo = NULL;
	drm_intel_bo_unreference(intel->video.gen4_sf_bo);
	intel->video.gen4_sf_bo = NULL;
	drm_intel_bo_unreference(intel->video.gen4_cc_bo);
	intel->video.gen4_cc_bo = NULL;
	drm_intel_bo_unreference(intel->video.gen4_wm_packed_bo);
	intel->video.gen4_wm_packed_bo = NULL;
	drm_intel_bo_unreference(intel->video.gen4_wm_planar_bo);
	intel->video.gen4_wm_planar_bo = NULL;
	drm_intel_bo_unreference(intel->video.gen4_cc_vp_bo);
	intel->video.gen4_cc_vp_bo = NULL;
	drm_intel_bo_unreference(intel->video.gen4_sampler_bo);
	intel->video.gen4_sampler_bo = NULL;
	drm_intel_bo_unreference(intel->video.gen4_sip_kernel_bo);
	intel->video.gen4_sip_kernel_bo = NULL;
	drm_intel_bo_unreference(intel->video.wm_prog_packed_bo);
	intel->video.wm_prog_packed_bo = NULL;
	drm_intel_bo_unreference(intel->video.wm_prog_planar_bo);
	intel->video.wm_prog_planar_bo = NULL;
	drm_intel_bo_unreference(intel->video.gen6_blend_bo);
	intel->video.gen6_blend_bo = NULL;
	drm_intel_bo_unreference(intel->video.gen6_depth_stencil_bo);
	intel->video.gen6_depth_stencil_bo = NULL;
}

/* for GEN6+ */
static drm_intel_bo *
gen6_create_cc_state(ScrnInfoPtr scrn)
{
	intel_screen_private *intel = intel_get_screen_private(scrn);
	struct gen6_color_calc_state cc_state;

	memset(&cc_state, 0, sizeof(cc_state));
	cc_state.constant_r = 1.0;
	cc_state.constant_g = 0.0;
	cc_state.constant_b = 1.0;
	cc_state.constant_a = 1.0;

	return intel_bo_alloc_for_data(intel,
				       &cc_state, sizeof(cc_state),
				       "textured video cc state");
}

static drm_intel_bo *
gen6_create_blend_state(ScrnInfoPtr scrn)
{
	intel_screen_private *intel = intel_get_screen_private(scrn);
	struct gen6_blend_state blend_state;

	memset(&blend_state, 0, sizeof(blend_state));
	blend_state.blend1.logic_op_enable = 1;
	blend_state.blend1.logic_op_func = 0xc;
	blend_state.blend1.pre_blend_clamp_enable = 1;

	return intel_bo_alloc_for_data(intel,
				       &blend_state, sizeof(blend_state),
				       "textured video blend state");
}

static drm_intel_bo *
gen6_create_depth_stencil_state(ScrnInfoPtr scrn)
{
	intel_screen_private *intel = intel_get_screen_private(scrn);
	struct gen6_depth_stencil_state depth_stencil_state;

	memset(&depth_stencil_state, 0, sizeof(depth_stencil_state));
	return intel_bo_alloc_for_data(intel,
				       &depth_stencil_state,
				       sizeof(depth_stencil_state),
				       "textured video blend state");
}

static Bool
gen6_create_vidoe_objects(ScrnInfoPtr scrn)
{
	intel_screen_private *intel = intel_get_screen_private(scrn);
	drm_intel_bo *(*create_sampler_state)(ScrnInfoPtr);
	const uint32_t *packed_ps_kernel, *planar_ps_kernel;
	unsigned int packed_ps_size, planar_ps_size;
	
	if (INTEL_INFO(intel)->gen >= 070) {
		create_sampler_state = gen7_create_sampler_state;
		packed_ps_kernel = &ps_kernel_packed_static_gen7[0][0];
		packed_ps_size = sizeof(ps_kernel_packed_static_gen7);
		planar_ps_kernel = &ps_kernel_planar_static_gen7[0][0];
		planar_ps_size = sizeof(ps_kernel_planar_static_gen7);
	} else {
		create_sampler_state = i965_create_sampler_state;
		packed_ps_kernel = &ps_kernel_packed_static_gen6[0][0];
		packed_ps_size = sizeof(ps_kernel_packed_static_gen6);
		planar_ps_kernel = &ps_kernel_planar_static_gen6[0][0];
		planar_ps_size = sizeof(ps_kernel_planar_static_gen6);
	}

	if (intel->video.gen4_sampler_bo == NULL)
		intel->video.gen4_sampler_bo = create_sampler_state(scrn);
		
	if (intel->video.wm_prog_packed_bo == NULL)
		intel->video.wm_prog_packed_bo =
			i965_create_program(scrn,
					packed_ps_kernel,
					packed_ps_size);
		
	if (intel->video.wm_prog_planar_bo == NULL)
		intel->video.wm_prog_planar_bo =
			i965_create_program(scrn,
					planar_ps_kernel,
					planar_ps_size);

	if (intel->video.gen4_cc_vp_bo == NULL)
		intel->video.gen4_cc_vp_bo = i965_create_cc_vp_state(scrn);

	if (intel->video.gen4_cc_bo == NULL)
		intel->video.gen4_cc_bo = gen6_create_cc_state(scrn);

	if (intel->video.gen6_blend_bo == NULL)
		intel->video.gen6_blend_bo = gen6_create_blend_state(scrn);

	if (intel->video.gen6_depth_stencil_bo == NULL)
		intel->video.gen6_depth_stencil_bo = gen6_create_depth_stencil_state(scrn);


	return (intel->video.gen4_sampler_bo != NULL &&
		intel->video.wm_prog_packed_bo != NULL &&
		intel->video.wm_prog_planar_bo != NULL &&
		intel->video.gen4_cc_vp_bo != NULL &&
		intel->video.gen4_cc_bo != NULL &&
		intel->video.gen6_blend_bo != NULL &&
		intel->video.gen6_depth_stencil_bo != NULL);
}

static void
gen6_upload_state_base_address(ScrnInfoPtr scrn, drm_intel_bo *surface_state_binding_table_bo)
{
	intel_screen_private *intel = intel_get_screen_private(scrn);

	OUT_BATCH(BRW_STATE_BASE_ADDRESS | (10 - 2));
	OUT_BATCH(BASE_ADDRESS_MODIFY); /* General state base address */
	OUT_RELOC(surface_state_binding_table_bo, I915_GEM_DOMAIN_INSTRUCTION, 0, BASE_ADDRESS_MODIFY); /* Surface state base address */
	OUT_BATCH(BASE_ADDRESS_MODIFY); /* Dynamic state base address */
	OUT_BATCH(BASE_ADDRESS_MODIFY); /* Indirect object base address */
	OUT_BATCH(BASE_ADDRESS_MODIFY); /* Instruction base address */
	OUT_BATCH(BASE_ADDRESS_MODIFY); /* General state upper bound */
	OUT_BATCH(BASE_ADDRESS_MODIFY); /* Dynamic state upper bound */
	OUT_BATCH(BASE_ADDRESS_MODIFY); /* Indirect object upper bound */
	OUT_BATCH(BASE_ADDRESS_MODIFY); /* Instruction access upper bound */
}

static void
gen6_upload_drawing_rectangle(ScrnInfoPtr scrn, PixmapPtr pixmap)
{
	intel_screen_private *intel = intel_get_screen_private(scrn);

	OUT_BATCH(BRW_3DSTATE_DRAWING_RECTANGLE | 2);
	OUT_BATCH(0x00000000);	/* ymin, xmin */
	OUT_BATCH((pixmap->drawable.width - 1) | (pixmap->drawable.height - 1) << 16);	/* ymax, xmax */
	OUT_BATCH(0x00000000);	/* yorigin, xorigin */
}

static void 
gen6_upload_wm_state(ScrnInfoPtr scrn, Bool is_packed)
{
	intel_screen_private *intel = intel_get_screen_private(scrn);

	/* disable WM constant buffer */
	OUT_BATCH(GEN6_3DSTATE_CONSTANT_PS | (5 - 2));
	OUT_BATCH(0);
	OUT_BATCH(0);
	OUT_BATCH(0);
	OUT_BATCH(0);

	OUT_BATCH(GEN6_3DSTATE_WM | (9 - 2));
	if (is_packed) {
		OUT_RELOC(intel->video.wm_prog_packed_bo, 
			I915_GEM_DOMAIN_INSTRUCTION, 0,
			0);
		OUT_BATCH((1 << GEN6_3DSTATE_WM_SAMPLER_COUNT_SHITF) |
			(2 << GEN6_3DSTATE_WM_BINDING_TABLE_ENTRY_COUNT_SHIFT));
	} else {
		OUT_RELOC(intel->video.wm_prog_planar_bo,
			I915_GEM_DOMAIN_INSTRUCTION, 0,
			0);
		OUT_BATCH((1 << GEN6_3DSTATE_WM_SAMPLER_COUNT_SHITF) |
			(7 << GEN6_3DSTATE_WM_BINDING_TABLE_ENTRY_COUNT_SHIFT));
	}
	OUT_BATCH(0);
	OUT_BATCH((6 << GEN6_3DSTATE_WM_DISPATCH_START_GRF_0_SHIFT)); /* DW4 */
	OUT_BATCH(((40 - 1) << GEN6_3DSTATE_WM_MAX_THREADS_SHIFT) |
		GEN6_3DSTATE_WM_DISPATCH_ENABLE |
		GEN6_3DSTATE_WM_16_DISPATCH_ENABLE);
	OUT_BATCH((1 << GEN6_3DSTATE_WM_NUM_SF_OUTPUTS_SHIFT) |
		GEN6_3DSTATE_WM_PERSPECTIVE_PIXEL_BARYCENTRIC);
	OUT_BATCH(0);
	OUT_BATCH(0);
}

static void
gen6_upload_vertex_element_state(ScrnInfoPtr scrn)
{
	intel_screen_private *intel = intel_get_screen_private(scrn);

	/* Set up our vertex elements, sourced from the single vertex buffer. */
	OUT_BATCH(BRW_3DSTATE_VERTEX_ELEMENTS | (5 - 2));
	/* offset 0: X,Y -> {X, Y, 1.0, 1.0} */
	OUT_BATCH((0 << GEN6_VE0_VERTEX_BUFFER_INDEX_SHIFT) |
		GEN6_VE0_VALID |
		(BRW_SURFACEFORMAT_R32G32_FLOAT << VE0_FORMAT_SHIFT) |
		(0 << VE0_OFFSET_SHIFT));
	OUT_BATCH((BRW_VFCOMPONENT_STORE_SRC << VE1_VFCOMPONENT_0_SHIFT) |
		(BRW_VFCOMPONENT_STORE_SRC << VE1_VFCOMPONENT_1_SHIFT) |
		(BRW_VFCOMPONENT_STORE_1_FLT << VE1_VFCOMPONENT_2_SHIFT) |
		(BRW_VFCOMPONENT_STORE_1_FLT << VE1_VFCOMPONENT_3_SHIFT));
	/* offset 8: S0, T0 -> {S0, T0, 1.0, 1.0} */
	OUT_BATCH((0 << GEN6_VE0_VERTEX_BUFFER_INDEX_SHIFT) |
		GEN6_VE0_VALID |
		(BRW_SURFACEFORMAT_R32G32_FLOAT << VE0_FORMAT_SHIFT) |
		(8 << VE0_OFFSET_SHIFT));
	OUT_BATCH((BRW_VFCOMPONENT_STORE_SRC << VE1_VFCOMPONENT_0_SHIFT) | 
		(BRW_VFCOMPONENT_STORE_SRC << VE1_VFCOMPONENT_1_SHIFT) |
		(BRW_VFCOMPONENT_STORE_1_FLT << VE1_VFCOMPONENT_2_SHIFT) |
		(BRW_VFCOMPONENT_STORE_1_FLT << VE1_VFCOMPONENT_3_SHIFT));
}

static void 
gen6_upload_vertex_buffer(ScrnInfoPtr scrn, drm_intel_bo *vertex_bo, uint32_t end_address_offset)
{
	intel_screen_private *intel = intel_get_screen_private(scrn);

	/* Set up the pointer to our vertex buffer */
	OUT_BATCH(BRW_3DSTATE_VERTEX_BUFFERS | (5 - 2));
	/* four 32-bit floats per vertex */
	OUT_BATCH((0 << GEN6_VB0_BUFFER_INDEX_SHIFT) |
		GEN6_VB0_VERTEXDATA | 
		((4 * 4) << VB0_BUFFER_PITCH_SHIFT));
	OUT_RELOC(vertex_bo, I915_GEM_DOMAIN_VERTEX, 0, 0);
	OUT_RELOC(vertex_bo, I915_GEM_DOMAIN_VERTEX, 0, end_address_offset);
	OUT_BATCH(0);	/* reserved */
}

static void
gen6_upload_primitive(ScrnInfoPtr scrn)
{
	intel_screen_private *intel = intel_get_screen_private(scrn);

	OUT_BATCH(BRW_3DPRIMITIVE | 
		BRW_3DPRIMITIVE_VERTEX_SEQUENTIAL | 
		(_3DPRIM_RECTLIST << BRW_3DPRIMITIVE_TOPOLOGY_SHIFT) | 
		(0 << 9) | /* Internal Vertex Count */
		(6 - 2));
	OUT_BATCH(3);	/* vertex count per instance */
	OUT_BATCH(0);	/* start vertex offset */
	OUT_BATCH(1);	/* single instance */
	OUT_BATCH(0);	/* start instance location */
	OUT_BATCH(0);	/* index buffer offset, ignored */
}

static void
gen6_emit_video_setup(ScrnInfoPtr scrn,
		drm_intel_bo *surface_state_binding_table_bo, int n_src_surf,
		PixmapPtr pixmap,
		drm_intel_bo *vertex_bo, uint32_t end_address_offset)
{
	intel_screen_private *intel = intel_get_screen_private(scrn);

	assert(n_src_surf == 1 || n_src_surf == 6);
	IntelEmitInvarientState(scrn);
	intel->last_3d = LAST_3D_VIDEO;
	intel->needs_3d_invariant = TRUE;

	gen6_upload_invariant_states(intel);
	gen6_upload_state_base_address(scrn, surface_state_binding_table_bo);
	gen6_upload_viewport_state_pointers(intel, intel->video.gen4_cc_vp_bo);
	gen6_upload_urb(intel);
	gen6_upload_cc_state_pointers(intel, intel->video.gen6_blend_bo, intel->video.gen4_cc_bo, intel->video.gen6_depth_stencil_bo, 0);
	gen6_upload_sampler_state_pointers(intel, intel->video.gen4_sampler_bo);
	gen6_upload_vs_state(intel);
	gen6_upload_gs_state(intel);
	gen6_upload_clip_state(intel);
	gen6_upload_sf_state(intel, 1, 0);
	gen6_upload_wm_state(scrn, n_src_surf == 1 ? TRUE : FALSE);
	gen6_upload_binding_table(intel, (n_src_surf + 1) * SURFACE_STATE_PADDED_SIZE);
	gen6_upload_depth_buffer_state(intel);
	gen6_upload_drawing_rectangle(scrn, pixmap);
	gen6_upload_vertex_element_state(scrn);
	gen6_upload_vertex_buffer(scrn, vertex_bo, end_address_offset);
	gen6_upload_primitive(scrn);
}

static void 
gen7_upload_wm_state(ScrnInfoPtr scrn, Bool is_packed)
{
	intel_screen_private *intel = intel_get_screen_private(scrn);
	unsigned int max_threads_shift = GEN7_PS_MAX_THREADS_SHIFT_IVB;
	unsigned int num_samples = 0;

	if (IS_HSW(intel)) {
		max_threads_shift = GEN7_PS_MAX_THREADS_SHIFT_HSW;
		num_samples = 1 << GEN7_PS_SAMPLE_MASK_SHIFT_HSW;
	}

	/* disable WM constant buffer */
	OUT_BATCH(GEN6_3DSTATE_CONSTANT_PS | (7 - 2));
	OUT_BATCH(0);
	OUT_BATCH(0);
	OUT_BATCH(0);
	OUT_BATCH(0);
	OUT_BATCH(0);
	OUT_BATCH(0);

	OUT_BATCH(GEN6_3DSTATE_WM | (3 - 2));
	OUT_BATCH(GEN7_WM_DISPATCH_ENABLE |
		GEN7_WM_PERSPECTIVE_PIXEL_BARYCENTRIC);
	OUT_BATCH(0);

	OUT_BATCH(GEN7_3DSTATE_PS | (8 - 2));

	if (is_packed) {
		OUT_RELOC(intel->video.wm_prog_packed_bo,
			I915_GEM_DOMAIN_INSTRUCTION, 0,
			0);
		OUT_BATCH((1 << GEN7_PS_SAMPLER_COUNT_SHIFT) |
			(2 << GEN7_PS_BINDING_TABLE_ENTRY_COUNT_SHIFT));
	} else {
		OUT_RELOC(intel->video.wm_prog_planar_bo,
			I915_GEM_DOMAIN_INSTRUCTION, 0,
			0);
		OUT_BATCH((1 << GEN7_PS_SAMPLER_COUNT_SHIFT) |
			(7 << GEN7_PS_BINDING_TABLE_ENTRY_COUNT_SHIFT));
	}

	OUT_BATCH(0); /* scratch space base offset */
	OUT_BATCH(
		((48 - 1) << max_threads_shift) | num_samples |
		GEN7_PS_ATTRIBUTE_ENABLE |
		GEN7_PS_16_DISPATCH_ENABLE);
	OUT_BATCH(
		(6 << GEN7_PS_DISPATCH_START_GRF_SHIFT_0));
	OUT_BATCH(0); /* kernel 1 pointer */
	OUT_BATCH(0); /* kernel 2 pointer */
}

static void 
gen7_upload_vertex_buffer(ScrnInfoPtr scrn, drm_intel_bo *vertex_bo, uint32_t end_address_offset)
{
	intel_screen_private *intel = intel_get_screen_private(scrn);

	/* Set up the pointer to our vertex buffer */
	OUT_BATCH(BRW_3DSTATE_VERTEX_BUFFERS | (5 - 2));
	/* four 32-bit floats per vertex */
	OUT_BATCH((0 << GEN6_VB0_BUFFER_INDEX_SHIFT) |
		GEN6_VB0_VERTEXDATA | 
		GEN7_VB0_ADDRESS_MODIFYENABLE |
		((4 * 4) << VB0_BUFFER_PITCH_SHIFT));
	OUT_RELOC(vertex_bo, I915_GEM_DOMAIN_VERTEX, 0, 0);
	OUT_RELOC(vertex_bo, I915_GEM_DOMAIN_VERTEX, 0, end_address_offset);
	OUT_BATCH(0);	/* reserved */
}

static void
gen7_upload_primitive(ScrnInfoPtr scrn)
{
	intel_screen_private *intel = intel_get_screen_private(scrn);

	OUT_BATCH(BRW_3DPRIMITIVE | (7 - 2));
	OUT_BATCH(_3DPRIM_RECTLIST |
		GEN7_3DPRIM_VERTEXBUFFER_ACCESS_SEQUENTIAL);
	OUT_BATCH(3); /* vertex count per instance */
	OUT_BATCH(0); /* start vertex offset */
	OUT_BATCH(1); /* single instance */
	OUT_BATCH(0); /* start instance location */
	OUT_BATCH(0);
}

static void
gen7_emit_video_setup(ScrnInfoPtr scrn,
		drm_intel_bo *surface_state_binding_table_bo, int n_src_surf,
		PixmapPtr pixmap,
		drm_intel_bo *vertex_bo, uint32_t end_address_offset)
{
	intel_screen_private *intel = intel_get_screen_private(scrn);

	assert(n_src_surf == 1 || n_src_surf == 6);
	IntelEmitInvarientState(scrn);
	intel->last_3d = LAST_3D_VIDEO;
	intel->needs_3d_invariant = TRUE;

	gen6_upload_invariant_states(intel);
	gen6_upload_state_base_address(scrn, surface_state_binding_table_bo);
	gen7_upload_viewport_state_pointers(intel, intel->video.gen4_cc_vp_bo);
	gen7_upload_urb(intel);
	gen7_upload_cc_state_pointers(intel, intel->video.gen6_blend_bo, intel->video.gen4_cc_bo, intel->video.gen6_depth_stencil_bo, 0);
	gen7_upload_sampler_state_pointers(intel, intel->video.gen4_sampler_bo);
	gen7_upload_bypass_states(intel);
	gen6_upload_vs_state(intel);
	gen6_upload_clip_state(intel);
	gen7_upload_sf_state(intel, 1, 0);
	gen7_upload_wm_state(scrn, n_src_surf == 1 ? TRUE : FALSE);
	gen7_upload_binding_table(intel, (n_src_surf + 1) * SURFACE_STATE_PADDED_SIZE);
	gen7_upload_depth_buffer_state(intel);
	gen6_upload_drawing_rectangle(scrn, pixmap);
	gen6_upload_vertex_element_state(scrn);
	gen7_upload_vertex_buffer(scrn, vertex_bo, end_address_offset);
	gen7_upload_primitive(scrn);
}

void Gen6DisplayVideoTextured(ScrnInfoPtr scrn,
			intel_adaptor_private *adaptor_priv, int id,
			RegionPtr dstRegion,
			short width, short height,
			int video_pitch, int video_pitch2,
			short src_w, short src_h,
			short drw_w, short drw_h, PixmapPtr pixmap)
{
	intel_screen_private *intel = intel_get_screen_private(scrn);
	BoxPtr pbox;
	int nbox, dxo, dyo, pix_xoff, pix_yoff;
	float src_scale_x, src_scale_y;
	int src_surf;
	int n_src_surf;
	uint32_t src_surf_format;
	uint32_t src_surf_base[6];
	int src_width[6];
	int src_height[6];
	int src_pitch[6];
	drm_intel_bo *surface_state_binding_table_bo;
	void (*create_dst_surface_state)(ScrnInfoPtr,
					PixmapPtr, 
					drm_intel_bo *, 
					uint32_t);
	void (*create_src_surface_state)(ScrnInfoPtr,
					drm_intel_bo *,
					uint32_t, int, 
					int, int, uint32_t, 
					drm_intel_bo *, uint32_t);
	void (*emit_video_setup)(ScrnInfoPtr,
				drm_intel_bo *, int,
				PixmapPtr,
				drm_intel_bo *, uint32_t);

	if (INTEL_INFO(intel)->gen >= 070) {
		create_dst_surface_state = gen7_create_dst_surface_state;
		create_src_surface_state = gen7_create_src_surface_state;
		emit_video_setup = gen7_emit_video_setup;
	} else {
		create_dst_surface_state = i965_create_dst_surface_state;
		create_src_surface_state = i965_create_src_surface_state;
		emit_video_setup = gen6_emit_video_setup;
	}

	src_surf_base[0] = adaptor_priv->YBufOffset;
	src_surf_base[1] = adaptor_priv->YBufOffset;
	src_surf_base[2] = adaptor_priv->VBufOffset;
	src_surf_base[3] = adaptor_priv->VBufOffset;
	src_surf_base[4] = adaptor_priv->UBufOffset;
	src_surf_base[5] = adaptor_priv->UBufOffset;

	if (is_planar_fourcc(id)) {
		src_surf_format = BRW_SURFACEFORMAT_R8_UNORM;
		src_width[1] = src_width[0] = width;
		src_height[1] = src_height[0] = height;
		src_pitch[1] = src_pitch[0] = video_pitch2;
		src_width[4] = src_width[5] = src_width[2] = src_width[3] =
			width / 2;
		src_height[4] = src_height[5] = src_height[2] = src_height[3] =
			height / 2;
		src_pitch[4] = src_pitch[5] = src_pitch[2] = src_pitch[3] =
			video_pitch;
		n_src_surf = 6;
	} else {
		if (id == FOURCC_UYVY)
			src_surf_format = BRW_SURFACEFORMAT_YCRCB_SWAPY;
		else
			src_surf_format = BRW_SURFACEFORMAT_YCRCB_NORMAL;

		src_width[0] = width;
		src_height[0] = height;
		src_pitch[0] = video_pitch;
		n_src_surf = 1;
	}

	surface_state_binding_table_bo = 
		drm_intel_bo_alloc(intel->bufmgr,
				"surface state & binding table",
				(n_src_surf + 1) * (SURFACE_STATE_PADDED_SIZE + sizeof(uint32_t)),
				4096);

	if (!surface_state_binding_table_bo)
		return;
				
	create_dst_surface_state(scrn, pixmap, surface_state_binding_table_bo, 0);

	for (src_surf = 0; src_surf < n_src_surf; src_surf++) {
		create_src_surface_state(scrn,
					adaptor_priv->buf,
					src_surf_base[src_surf],
					src_width[src_surf],
					src_height[src_surf],
					src_pitch[src_surf],
					src_surf_format,
					surface_state_binding_table_bo,
					(src_surf + 1) * SURFACE_STATE_PADDED_SIZE);
	}

	i965_create_binding_table(scrn, surface_state_binding_table_bo, n_src_surf + 1);

	if (!gen6_create_vidoe_objects(scrn)) {
		drm_intel_bo_unreference(surface_state_binding_table_bo);
		return;
	}

	/* Set up the offset for translating from the given region (in screen
	 * coordinates) to the backing pixmap.
	 */
#ifdef COMPOSITE
	pix_xoff = -pixmap->screen_x + pixmap->drawable.x;
	pix_yoff = -pixmap->screen_y + pixmap->drawable.y;
#else
	pix_xoff = 0;
	pix_yoff = 0;
#endif

	dxo = dstRegion->extents.x1;
	dyo = dstRegion->extents.y1;

	/* Use normalized texture coordinates */
	src_scale_x = ((float)src_w / width) / (float)drw_w;
	src_scale_y = ((float)src_h / height) / (float)drw_h;

	pbox = REGION_RECTS(dstRegion);
	nbox = REGION_NUM_RECTS(dstRegion);
	while (nbox--) {
		int box_x1 = pbox->x1;
		int box_y1 = pbox->y1;
		int box_x2 = pbox->x2;
		int box_y2 = pbox->y2;
		int i;
		float vb[12];
		drm_intel_bo *bo_table[] = {
			NULL,	/* vb_bo */
			intel->batch_bo,
			surface_state_binding_table_bo,
			intel->video.gen4_sampler_bo,
			intel->video.wm_prog_packed_bo,
			intel->video.wm_prog_planar_bo,
			intel->video.gen4_cc_vp_bo,
			intel->video.gen4_cc_bo,
			intel->video.gen6_blend_bo,
			intel->video.gen6_depth_stencil_bo,
		};

		pbox++;

		i = 0;
		vb[i++] = (box_x2 - dxo) * src_scale_x;
		vb[i++] = (box_y2 - dyo) * src_scale_y;
		vb[i++] = (float)box_x2 + pix_xoff;
		vb[i++] = (float)box_y2 + pix_yoff;

		vb[i++] = (box_x1 - dxo) * src_scale_x;
		vb[i++] = (box_y2 - dyo) * src_scale_y;
		vb[i++] = (float)box_x1 + pix_xoff;
		vb[i++] = (float)box_y2 + pix_yoff;

		vb[i++] = (box_x1 - dxo) * src_scale_x;
		vb[i++] = (box_y1 - dyo) * src_scale_y;
		vb[i++] = (float)box_x1 + pix_xoff;
		vb[i++] = (float)box_y1 + pix_yoff;

		bo_table[0] = intel_bo_alloc_for_data(intel,
						      vb, sizeof(vb),
						      "video vbo");

		/* If this command won't fit in the current batch, flush.
		 * Assume that it does after being flushed.
		 */
		if (drm_intel_bufmgr_check_aperture_space(bo_table, ARRAY_SIZE(bo_table)) < 0)
			intel_batch_submit(scrn);

		intel_batch_start_atomic(scrn, 200);
		emit_video_setup(scrn, surface_state_binding_table_bo, n_src_surf, pixmap, bo_table[0], i * 4);
		intel_batch_end_atomic(scrn);

		drm_intel_bo_unreference(bo_table[0]);
	}

	/* release reference once we're finished */
	drm_intel_bo_unreference(surface_state_binding_table_bo);
	intel_debug_flush(scrn);
}
@


1.10
log
@Update to xf86-video-intel 2.20.19.

A recent kernel with kernel modesetting support is required.
Thanks to jsg@@ and kettenis@@ for their work.
@
text
@@


1.9
log
@Add basic support for ivy bridge and fix several cases of register
access not being adjusted for the pch split, one of which prevented
multiple display pipes from working.  The third pipe on ivy bridge
remains disabled for now.

ok kettenis@@ thanks to everyone who tested
@
text
@d116 1
a116 1
/* new program for IGDNG */
a205 1
	intel_sync(scrn);
a382 19
static int
intel_alloc_and_map(intel_screen_private *intel, char *name, int size,
		    drm_intel_bo ** bop, void *virtualp)
{
	drm_intel_bo *bo;

	bo = drm_intel_bo_alloc(intel->bufmgr, name, size, 4096);
	if (!bo)
		return -1;
	if (drm_intel_bo_map(bo, TRUE) != 0) {
		drm_intel_bo_unreference(bo);
		return -1;
	}
	*bop = bo;
	*(void **)virtualp = bo->virtual;
	memset(bo->virtual, 0, size);
	return 0;
}

d389 1
a389 1
	struct brw_surface_state *dest_surf_state;
d391 1
d393 1
a393 5
	if (drm_intel_bo_map(surf_bo, TRUE) != 0)
		return;

	dest_surf_state = (struct brw_surface_state *)((char *)surf_bo->virtual + offset);
	memset(dest_surf_state, 0, sizeof(*dest_surf_state));
d395 2
a396 2
	dest_surf_state->ss0.surface_type = BRW_SURFACE_2D;
	dest_surf_state->ss0.data_return_format =
d399 1
a399 1
		dest_surf_state->ss0.surface_format =
d402 1
a402 1
		dest_surf_state->ss0.surface_format =
d405 9
a413 9
	dest_surf_state->ss0.writedisable_alpha = 0;
	dest_surf_state->ss0.writedisable_red = 0;
	dest_surf_state->ss0.writedisable_green = 0;
	dest_surf_state->ss0.writedisable_blue = 0;
	dest_surf_state->ss0.color_blend = 1;
	dest_surf_state->ss0.vert_line_stride = 0;
	dest_surf_state->ss0.vert_line_stride_ofs = 0;
	dest_surf_state->ss0.mipmap_layout_mode = 0;
	dest_surf_state->ss0.render_cache_read_mode = 0;
d415 1
a415 1
	dest_surf_state->ss1.base_addr =
d417 1
a417 1
			     pixmap_bo, 0, I915_GEM_DOMAIN_SAMPLER, 0);
d419 11
a429 9
	dest_surf_state->ss2.height = pixmap->drawable.height - 1;
	dest_surf_state->ss2.width = pixmap->drawable.width - 1;
	dest_surf_state->ss2.mip_count = 0;
	dest_surf_state->ss2.render_target_rotation = 0;
	dest_surf_state->ss3.pitch = intel_pixmap_pitch(pixmap) - 1;
	dest_surf_state->ss3.tiled_surface = intel_pixmap_tiled(pixmap);
	dest_surf_state->ss3.tile_walk = 0;	/* TileX */

	drm_intel_bo_unmap(surf_bo);
d442 1
a442 4
	struct brw_surface_state *src_surf_state;

	if (drm_intel_bo_map(surface_bo, TRUE) != 0)
		return;
d444 1
a444 2
	src_surf_state = (struct brw_surface_state *)((char *)surface_bo->virtual + offset);
	memset(src_surf_state, 0, sizeof(*src_surf_state));
d447 17
a463 17
	src_surf_state->ss0.surface_type = BRW_SURFACE_2D;
	src_surf_state->ss0.surface_format = src_surf_format;
	src_surf_state->ss0.writedisable_alpha = 0;
	src_surf_state->ss0.writedisable_red = 0;
	src_surf_state->ss0.writedisable_green = 0;
	src_surf_state->ss0.writedisable_blue = 0;
	src_surf_state->ss0.color_blend = 1;
	src_surf_state->ss0.vert_line_stride = 0;
	src_surf_state->ss0.vert_line_stride_ofs = 0;
	src_surf_state->ss0.mipmap_layout_mode = 0;
	src_surf_state->ss0.render_cache_read_mode = 0;

	src_surf_state->ss2.width = src_width - 1;
	src_surf_state->ss2.height = src_height - 1;
	src_surf_state->ss2.mip_count = 0;
	src_surf_state->ss2.render_target_rotation = 0;
	src_surf_state->ss3.pitch = src_pitch - 1;
d466 1
a466 1
		src_surf_state->ss1.base_addr =
d472 1
a472 1
		src_surf_state->ss1.base_addr = src_offset;
d475 3
a477 1
	drm_intel_bo_unmap(surface_bo);
d486 1
a486 1
	struct gen7_surface_state *dest_surf_state;
d488 1
d490 1
a490 5
	if (drm_intel_bo_map(surf_bo, TRUE) != 0)
		return;

	dest_surf_state = (struct gen7_surface_state *)((char *)surf_bo->virtual + offset);
	memset(dest_surf_state, 0, sizeof(*dest_surf_state));
d492 3
a494 3
	dest_surf_state->ss0.surface_type = BRW_SURFACE_2D;
	dest_surf_state->ss0.tiled_surface = intel_pixmap_tiled(pixmap);
	dest_surf_state->ss0.tile_walk = 0;	/* TileX */
d497 1
a497 1
		dest_surf_state->ss0.surface_format = BRW_SURFACEFORMAT_B5G6R5_UNORM;
d499 1
a499 1
		dest_surf_state->ss0.surface_format = BRW_SURFACEFORMAT_B8G8R8A8_UNORM;
d502 2
a503 2
	dest_surf_state->ss1.base_addr =
		intel_emit_reloc(surf_bo, 
d505 1
a505 1
				pixmap_bo, 0, 
d508 2
a509 2
	dest_surf_state->ss2.height = pixmap->drawable.height - 1;
	dest_surf_state->ss2.width = pixmap->drawable.width - 1;
d511 8
a518 1
	dest_surf_state->ss3.pitch = intel_pixmap_pitch(pixmap) - 1;
d520 3
a522 1
	drm_intel_bo_unmap(surf_bo); 
d535 2
a536 1
	struct gen7_surface_state *src_surf_state;
d538 1
a538 5
	if (drm_intel_bo_map(surface_bo, TRUE) != 0)
		return;

	src_surf_state = (struct gen7_surface_state *)((char *)surface_bo->virtual + offset);
	memset(src_surf_state, 0, sizeof(*src_surf_state));
d540 2
a541 2
	src_surf_state->ss0.surface_type = BRW_SURFACE_2D;
	src_surf_state->ss0.surface_format = src_surf_format;
d544 1
a544 1
		src_surf_state->ss1.base_addr =
d550 1
a550 1
		src_surf_state->ss1.base_addr = src_offset;
d553 2
a554 2
	src_surf_state->ss2.width = src_width - 1;
	src_surf_state->ss2.height = src_height - 1;
d556 1
a556 1
	src_surf_state->ss3.pitch = src_pitch - 1;
d558 10
a567 1
	drm_intel_bo_unmap(surface_bo);
d571 2
a572 2
				drm_intel_bo *bind_bo,
				int n_surf)
d574 1
a574 1
	uint32_t *binding_table;
a577 5
	if (drm_intel_bo_map(bind_bo, TRUE) != 0)
		return;

	binding_table = (uint32_t*)((char *)bind_bo->virtual + n_surf * SURFACE_STATE_PADDED_SIZE);

d581 3
a583 1
	drm_intel_bo_unmap(bind_bo);
d589 1
a589 12
	drm_intel_bo *sampler_bo;
	struct brw_sampler_state *sampler_state;

	if (intel_alloc_and_map(intel, "textured video sampler state", 4096,
				&sampler_bo, &sampler_state) != 0)
		return NULL;

	sampler_state->ss0.min_filter = BRW_MAPFILTER_LINEAR;
	sampler_state->ss0.mag_filter = BRW_MAPFILTER_LINEAR;
	sampler_state->ss1.r_wrap_mode = BRW_TEXCOORDMODE_CLAMP;
	sampler_state->ss1.s_wrap_mode = BRW_TEXCOORDMODE_CLAMP;
	sampler_state->ss1.t_wrap_mode = BRW_TEXCOORDMODE_CLAMP;
d591 10
a600 2
	drm_intel_bo_unmap(sampler_bo);
	return sampler_bo;
d606 1
a606 2
	drm_intel_bo *sampler_bo;
	struct gen7_sampler_state *sampler_state;
d608 10
a617 12
	if (intel_alloc_and_map(intel, "textured video sampler state", 4096,
				&sampler_bo, &sampler_state) != 0)
		return NULL;

	sampler_state->ss0.min_filter = BRW_MAPFILTER_LINEAR;
	sampler_state->ss0.mag_filter = BRW_MAPFILTER_LINEAR;
	sampler_state->ss3.r_wrap_mode = BRW_TEXCOORDMODE_CLAMP;
	sampler_state->ss3.s_wrap_mode = BRW_TEXCOORDMODE_CLAMP;
	sampler_state->ss3.t_wrap_mode = BRW_TEXCOORDMODE_CLAMP;

	drm_intel_bo_unmap(sampler_bo);
	return sampler_bo;
d623 1
a623 6
	drm_intel_bo *vs_bo;
	struct brw_vs_unit_state *vs_state;

	if (intel_alloc_and_map(intel, "textured video vs state", 4096,
				&vs_bo, &vs_state) != 0)
		return NULL;
d626 1
d628 1
a628 1
		vs_state->thread4.nr_urb_entries = URB_VS_ENTRIES >> 2;
d630 8
a637 7
		vs_state->thread4.nr_urb_entries = URB_VS_ENTRIES;
	vs_state->thread4.urb_entry_allocation_size = URB_VS_ENTRY_SIZE - 1;
	vs_state->vs6.vs_enable = 0;
	vs_state->vs6.vert_cache_disable = 1;

	drm_intel_bo_unmap(vs_bo);
	return vs_bo;
d645 3
a647 10
	drm_intel_bo *prog_bo;

	prog_bo = drm_intel_bo_alloc(intel->bufmgr, "textured video program",
				     program_size, 4096);
	if (!prog_bo)
		return NULL;

	drm_intel_bo_subdata(prog_bo, 0, program_size, program);

	return prog_bo;
d654 1
a654 1
	struct brw_sf_unit_state *sf_state;
d657 3
a659 3
		kernel_bo =
		    i965_create_program(scrn, &sf_kernel_static_gen5[0][0],
					sizeof(sf_kernel_static_gen5));
d661 2
a662 1
		kernel_bo = i965_create_program(scrn, &sf_kernel_static[0][0],
a663 1

d667 4
a670 2
	if (intel_alloc_and_map(intel, "textured video sf state", 4096,
				&sf_bo, &sf_state) != 0) {
d679 3
a681 2
	sf_state->thread0.grf_reg_count = BRW_GRF_BLOCKS(SF_KERNEL_NUM_GRF);
	sf_state->thread0.kernel_start_pointer =
d683 1
a683 1
			     kernel_bo, sf_state->thread0.grf_reg_count << 1,
d685 8
a692 8
	sf_state->sf1.single_program_flow = 1;	/* XXX */
	sf_state->sf1.binding_table_entry_count = 0;
	sf_state->sf1.thread_priority = 0;
	sf_state->sf1.floating_point_mode = 0;	/* Mesa does this */
	sf_state->sf1.illegal_op_exception_enable = 1;
	sf_state->sf1.mask_stack_exception_enable = 1;
	sf_state->sf1.sw_exception_enable = 1;
	sf_state->thread2.per_thread_scratch_space = 0;
d694 16
a709 16
	sf_state->thread2.scratch_space_base_pointer = 0;
	sf_state->thread3.const_urb_entry_read_length = 0;	/* no const URBs */
	sf_state->thread3.const_urb_entry_read_offset = 0;	/* no const URBs */
	sf_state->thread3.urb_entry_read_length = 1;	/* 1 URB per vertex */
	sf_state->thread3.urb_entry_read_offset = 0;
	sf_state->thread3.dispatch_grf_start_reg = 3;
	sf_state->thread4.max_threads = SF_MAX_THREADS - 1;
	sf_state->thread4.urb_entry_allocation_size = URB_SF_ENTRY_SIZE - 1;
	sf_state->thread4.nr_urb_entries = URB_SF_ENTRIES;
	sf_state->thread4.stats_enable = 1;
	sf_state->sf5.viewport_transform = FALSE;	/* skip viewport */
	sf_state->sf6.cull_mode = BRW_CULLMODE_NONE;
	sf_state->sf6.scissor = 0;
	sf_state->sf7.trifan_pv = 2;
	sf_state->sf6.dest_org_vbias = 0x8;
	sf_state->sf6.dest_org_hbias = 0x8;
d711 1
a711 1
	drm_intel_bo_unmap(sf_bo);
d721 1
a721 1
	struct brw_wm_unit_state *wm_state;
d755 4
a758 3
	if (intel_alloc_and_map
	    (intel, "textured video wm state", sizeof(*wm_state), &wm_bo,
	     &wm_state)) {
d763 3
a765 2
	wm_state->thread0.grf_reg_count = BRW_GRF_BLOCKS(PS_KERNEL_NUM_GRF);
	wm_state->thread0.kernel_start_pointer =
d767 1
a767 1
			     kernel_bo, wm_state->thread0.grf_reg_count << 1,
d769 1
a769 1
	wm_state->thread1.single_program_flow = 1;	/* XXX */
d771 1
a771 1
		wm_state->thread1.binding_table_entry_count = 2;
d773 1
a773 1
		wm_state->thread1.binding_table_entry_count = 7;
d776 1
a776 1
	 * be set 0 for IGDNG
d779 1
a779 1
		wm_state->thread1.binding_table_entry_count = 0;
d784 9
a792 9
	wm_state->thread2.scratch_space_base_pointer = 0;
	wm_state->thread2.per_thread_scratch_space = 0;	/* 1024 bytes */
	wm_state->thread3.dispatch_grf_start_reg = 3;	/* XXX */
	wm_state->thread3.const_urb_entry_read_length = 0;
	wm_state->thread3.const_urb_entry_read_offset = 0;
	wm_state->thread3.urb_entry_read_length = 1;	/* XXX */
	wm_state->thread3.urb_entry_read_offset = 0;	/* XXX */
	wm_state->wm4.stats_enable = 1;
	wm_state->wm4.sampler_state_pointer =
d797 1
a797 1
		wm_state->wm4.sampler_count = 0;
d799 6
a804 6
		wm_state->wm4.sampler_count = 1;	/* 1-4 samplers used */
	wm_state->wm5.max_threads = PS_MAX_THREADS - 1;
	wm_state->wm5.thread_dispatch_enable = 1;
	wm_state->wm5.enable_16_pix = 1;
	wm_state->wm5.enable_8_pix = 0;
	wm_state->wm5.early_depth_test = 1;
d806 1
a807 2

	drm_intel_bo_unmap(wm_bo);
d814 1
a814 2
	drm_intel_bo *cc_vp_bo;
	struct brw_cc_viewport *cc_viewport;
d816 7
a822 9
	if (intel_alloc_and_map(intel, "textured video cc viewport", 4096,
				&cc_vp_bo, &cc_viewport) != 0)
		return NULL;

	cc_viewport->min_depth = -1.e35;
	cc_viewport->max_depth = 1.e35;

	drm_intel_bo_unmap(cc_vp_bo);
	return cc_vp_bo;
d829 1
a829 1
	struct brw_cc_unit_state *cc_state;
d835 4
a838 3
	if (intel_alloc_and_map
	    (intel, "textured video cc state", sizeof(*cc_state), &cc_bo,
	     &cc_state) != 0) {
d844 8
a851 8
	memset(cc_state, 0, sizeof(*cc_state));
	cc_state->cc0.stencil_enable = 0;	/* disable stencil */
	cc_state->cc2.depth_test = 0;	/* disable depth test */
	cc_state->cc2.logicop_enable = 1;	/* enable logic op */
	cc_state->cc3.ia_blend_enable = 1;	/* blend alpha just like colors */
	cc_state->cc3.blend_enable = 0;	/* disable color blend */
	cc_state->cc3.alpha_test = 0;	/* disable alpha test */
	cc_state->cc4.cc_viewport_state_offset =
d854 6
a859 6
	cc_state->cc5.dither_enable = 0;	/* disable dither */
	cc_state->cc5.logicop_func = 0xc;	/* WHITE */
	cc_state->cc5.statistics_enable = 1;
	cc_state->cc5.ia_blend_function = BRW_BLENDFUNCTION_ADD;
	cc_state->cc5.ia_src_blend_factor = BRW_BLENDFACTOR_ONE;
	cc_state->cc5.ia_dest_blend_factor = BRW_BLENDFACTOR_ONE;
d861 2
a862 1
	drm_intel_bo_unmap(cc_bo);
a863 1
	drm_intel_bo_unreference(cc_vp_bo);
d880 1
d900 1
a900 1
	if (INTEL_INFO(intel)->gen >= 45)
d1257 1
a1257 2
		drm_intel_bo *vb_bo;
		float *vb;
a1272 5
		if (intel_alloc_and_map(intel, "textured video vb", 4096,
					&vb_bo, &vb) != 0)
			break;
		bo_table[0] = vb_bo;

d1289 3
a1291 1
		drm_intel_bo_unmap(vb_bo);
d1314 1
a1314 1
		OUT_RELOC(vb_bo, I915_GEM_DOMAIN_VERTEX, 0, 0);
d1316 1
a1316 1
			OUT_RELOC(vb_bo, I915_GEM_DOMAIN_VERTEX, 0,
d1333 1
a1333 1
		drm_intel_bo_unreference(vb_bo);
d1381 1
a1381 2
	struct gen6_color_calc_state *cc_state;
	drm_intel_bo *cc_bo;
d1383 9
a1391 15
	if (intel_alloc_and_map(
			intel,
			"textured video cc state", 
			sizeof(*cc_state), 
			&cc_bo,
			&cc_state) != 0)
		return NULL;

	cc_state->constant_r = 1.0;
	cc_state->constant_g = 0.0;
	cc_state->constant_b = 1.0;
	cc_state->constant_a = 1.0;

	drm_intel_bo_unmap(cc_bo);
	return cc_bo;
d1398 1
a1398 14
	struct gen6_blend_state *blend_state;
	drm_intel_bo *blend_bo;

	if (intel_alloc_and_map(
			intel,
			"textured video blend state",
			sizeof(*blend_state),
			&blend_bo,
			&blend_state) != 0)
		return NULL;

	blend_state->blend1.logic_op_enable = 1;
	blend_state->blend1.logic_op_func = 0xc;
	blend_state->blend1.pre_blend_clamp_enable = 1;
d1400 8
a1407 2
	drm_intel_bo_unmap(blend_bo);
	return blend_bo;
d1414 1
a1414 2
	struct gen6_depth_stencil_state *depth_stencil_state;
	drm_intel_bo *depth_stencil_bo;
d1416 5
a1420 10
	if (intel_alloc_and_map(
			intel,
			"textured video blend state",
			sizeof(*depth_stencil_state),
			&depth_stencil_bo,
			&depth_stencil_state) != 0)
		return NULL;

	drm_intel_bo_unmap(depth_stencil_bo);
	return depth_stencil_bo;
d1431 1
a1431 1
	if (INTEL_INFO(intel)->gen >= 70) {
d1618 1
d1643 7
d1683 1
a1683 1
		((48 - 1) << GEN7_PS_MAX_THREADS_SHIFT) |
d1735 1
d1790 1
a1790 1
	if (INTEL_INFO(intel)->gen >= 70) {
d1887 1
a1887 2
		drm_intel_bo *vb_bo;
		float *vb;
a1902 5
		if (intel_alloc_and_map(intel, "textured video vb", 4096,
						&vb_bo, &vb) != 0)
			break;
		bo_table[0] = vb_bo;

d1919 3
a1921 1
		drm_intel_bo_unmap(vb_bo);
d1930 1
a1930 1
		emit_video_setup(scrn, surface_state_binding_table_bo, n_src_surf, pixmap, vb_bo, i * 4);
d1933 1
a1933 1
		drm_intel_bo_unreference(vb_bo);
@


1.8
log
@Update the intel driver to a more recent version based on more recent
upsteam code.

Backporting keeping UMS changes by me, some bugfixes from kettenis@@.

Has been in snapshots for a while, committed on request so we can be
sure what people are running. This is a prerequesite for sandybridge
support but has those chipsets disabled for now until the correct code
has been added.
@
text
@d1726 1
a1726 1
		((86 - 1) << GEN7_PS_MAX_THREADS_SHIFT) |
@


1.7
log
@Update the intel driver to (mostly) a backport of 2.12.

It is missing a few commits that I have yet to verify (ones that try and
continue if we lock the gpu rendering engine and can't reset it, for
example) taht will be verified and sent out for extra testing soon.

Should contain a bunch of speedups and some correctness improvements
(though rendercheck still gives some errors that I am looking into).

This has been in snaps since the first day of c2k10, any known issues
with just this driver have (to my knowledge) been fixed since. A problem
with macbooks pointed out by otto happens with both this and the in-tree
driver and thus doesn't stop this moving forward.

As well as the 2.12 improvements, this driver also has a backport
(partially aided by the backports in RHEL 5 kindly provided by Dave
Airlie) from the kms code of modesetting support for ironlake (arrandale
and clarkdale: the IGDs build into intel nehalem cpu dies) which has
been tested on a number of chipsets. Note that Display port and eDP
displays have not yet been worked on (and probably won't until I can
find a displayport monitor), but VGA and lvds at least are known to
work, sure beats vesa.

"no objection on my side" matthieu@@, prodding (as always) from princess
marco.
@
text
@d38 5
a42 3
#include "i830.h"
#include "i830_video.h"
#include "i830_hwmc.h"
d47 1
d137 39
d403 4
a406 2
static drm_intel_bo *i965_create_dst_surface_state(ScrnInfoPtr scrn,
						   PixmapPtr pixmap)
d410 1
a410 2
	drm_intel_bo *pixmap_bo = i830_get_pixmap_bo(pixmap);
	drm_intel_bo *surf_bo;
d412 5
a416 3
	if (intel_alloc_and_map(intel, "textured video surface state", 4096,
				&surf_bo, &dest_surf_state) != 0)
		return NULL;
d439 1
a439 1
	    intel_emit_reloc(surf_bo, offsetof(struct brw_surface_state, ss1),
d442 2
a443 2
	dest_surf_state->ss2.height = scrn->virtualY - 1;
	dest_surf_state->ss2.width = scrn->virtualX - 1;
d446 2
a447 2
	dest_surf_state->ss3.pitch = intel_get_pixmap_pitch(pixmap) - 1;
	dest_surf_state->ss3.tiled_surface = i830_pixmap_tiled(pixmap);
a450 1
	return surf_bo;
d453 9
a461 7
static drm_intel_bo *i965_create_src_surface_state(ScrnInfoPtr scrn,
						   drm_intel_bo * src_bo,
						   uint32_t src_offset,
						   int src_width,
						   int src_height,
						   int src_pitch,
						   uint32_t src_surf_format)
a462 2
	intel_screen_private *intel = intel_get_screen_private(scrn);
	drm_intel_bo *surface_bo;
d465 5
a469 3
	if (intel_alloc_and_map(intel, "textured video surface state", 4096,
				&surface_bo, &src_surf_state) != 0)
		return NULL;
d493 1
a493 1
				     offsetof(struct brw_surface_state, ss1),
a500 1
	return surface_bo;
d503 4
a506 3
static drm_intel_bo *i965_create_binding_table(ScrnInfoPtr scrn,
					       drm_intel_bo ** surf_bos,
					       int n_surf)
d509 76
a584 1
	drm_intel_bo *bind_bo;
d589 2
d592 1
a592 3
	if (intel_alloc_and_map(intel, "textured video binding table", 4096,
				&bind_bo, &binding_table) != 0)
		return NULL;
d595 1
a595 3
		binding_table[i] =
		    intel_emit_reloc(bind_bo, i * sizeof(uint32_t), surf_bos[i],
				     0, I915_GEM_DOMAIN_INSTRUCTION, 0);
a597 1
	return bind_bo;
d620 20
d651 1
a651 1
	if (IS_IGDNG(intel))
d686 1
a686 1
	if (IS_IGDNG(intel))
d751 1
a751 1
		if (IS_IGDNG(intel))
d765 1
a765 1
		if (IS_IGDNG(intel))
d803 1
a803 1
	if (IS_IGDNG(intel))
d821 1
a821 1
	if (IS_IGDNG(intel))
d896 1
a896 1
i965_emit_video_setup(ScrnInfoPtr scrn, drm_intel_bo * bind_bo, int n_src_surf)
d927 1
a927 1
	if (IS_G4X(intel) || IS_IGDNG(intel))
d940 1
a940 1
	if (IS_IGDNG(intel)) {
d943 1
a943 1
		OUT_BATCH(0 | BASE_ADDRESS_MODIFY);	/* Surface state base address */
d947 1
a947 1
		OUT_BATCH(0x10000000 | BASE_ADDRESS_MODIFY);
d949 1
a949 1
		OUT_BATCH(0x10000000 | BASE_ADDRESS_MODIFY);
d951 1
a951 1
		OUT_BATCH(0x10000000 | BASE_ADDRESS_MODIFY);
d955 1
a955 1
		OUT_BATCH(0 | BASE_ADDRESS_MODIFY);	/* Surface state base address */
d958 1
a958 1
		OUT_BATCH(0x10000000 | BASE_ADDRESS_MODIFY);
d960 1
a960 1
		OUT_BATCH(0x10000000 | BASE_ADDRESS_MODIFY);
d971 1
a971 1
	if (IS_IGDNG(intel))
d989 1
a989 1
	OUT_RELOC(bind_bo, I915_GEM_DOMAIN_SAMPLER, 0, 0);
d1003 1
a1003 1
	OUT_BATCH((scrn->virtualX - 1) | (scrn->virtualY - 1) << 16);	/* ymax, xmax */
d1044 1
a1044 1
	if (IS_IGDNG(intel)) {
d1114 1
a1114 1
	int src_surf, i;
d1121 1
a1121 1
	drm_intel_bo *bind_bo, *surf_bos[7];
d1179 7
a1185 3
	/* Upload kernels */
	surf_bos[0] = i965_create_dst_surface_state(scrn, pixmap);
	if (!surf_bos[0])
d1187 2
d1191 9
a1199 15
		drm_intel_bo *surf_bo =
			i965_create_src_surface_state(scrn,
						      adaptor_priv->buf,
						      src_surf_base[src_surf],
						      src_width[src_surf],
						      src_height[src_surf],
						      src_pitch[src_surf],
						      src_surf_format);
		if (!surf_bo) {
			int q;
			for (q = 0; q < src_surf + 1; q++)
				drm_intel_bo_unreference(surf_bos[q]);
			return;
		}
		surf_bos[src_surf + 1] = surf_bo;
d1201 2
a1202 7
	bind_bo = i965_create_binding_table(scrn, surf_bos, n_src_surf + 1);
	for (i = 0; i < n_src_surf + 1; i++) {
		drm_intel_bo_unreference(surf_bos[i]);
		surf_bos[i] = NULL;
	}
	if (!bind_bo)
		return;
d1211 1
a1211 1
			drm_intel_bo_unreference(bind_bo);
d1219 1
a1219 1
			drm_intel_bo_unreference(bind_bo);
d1226 1
a1226 1
			drm_intel_bo_unreference(bind_bo);
d1235 1
a1235 1
			drm_intel_bo_unreference(bind_bo);
d1245 1
a1245 1
			drm_intel_bo_unreference(bind_bo);
d1253 1
a1253 1
			drm_intel_bo_unreference(bind_bo);
d1289 1
a1289 1
			bind_bo,
d1324 1
a1324 1
		if (!IS_IGDNG(intel))
d1333 1
a1333 1
			intel_batch_submit(scrn, FALSE);
d1336 1
a1336 1
		intel_batch_start_atomic(scrn, 100);
d1338 1
a1338 1
		i965_emit_video_setup(scrn, bind_bo, n_src_surf);
d1346 1
a1346 1
		if (IS_IGDNG(intel))
d1366 1
a1366 1
		if (!IS_IGDNG(intel))
d1372 1
a1372 5
	drm_intel_bo_unreference(bind_bo);

#if WATCH_STATS
	/* i830_dump_error_state(scrn); */
#endif
d1374 1
a1374 1
	i830_debug_flush(scrn);
d1397 588
@


1.6
log
@Pull in the changes in rendering that I skipped when i backported
changes from later intel versions (after the UMS removal). 95% of this
is the xvmc reworks that makes that code even halfway sane. xvmc is now
enabled by default on 965+.

Tested by many on tech@@, thanks!

ok matthieu@@
@
text
@a781 1
	ATOMIC_BATCH(2);
a785 1
	ADVANCE_BATCH();
a787 4
	if (IS_IGDNG(intel))
		ATOMIC_BATCH(14);
	else
		ATOMIC_BATCH(12);
a830 3
	OUT_BATCH(MI_NOOP);
	ADVANCE_BATCH();

a837 4
	ATOMIC_BATCH(38);

	OUT_BATCH(MI_NOOP);

a960 3

	OUT_BATCH(MI_NOOP);	/* pad to quadword */
	ADVANCE_BATCH();
d1200 1
a1200 1
			intel_batch_submit(scrn);
a1206 1
		ATOMIC_BATCH(12);
a1227 1
		ADVANCE_BATCH();
@


1.5
log
@Update the intel driver to 2.9.1 plus backports.

2.9.1 is the last version of the intel DDX that supports UMS (User
modesetting), with 2.10 onwards being purely KMS only. As such, this
driver contains backports of almost every correctness or performance
related fix to the rendering layer in later intel drivers. This driver
*REQUIRES* a GEM enabled kernel. it claims to support non-gem mode but
this is essentially unmaintained and due to the way the abstraciton
works is slow, if it works at all (it often does not). You have been
warned.

tested by many many people on tech over the last few weeks.
@
text
@d983 2
a984 2
			 short width, short height, int video_pitch,
			 int x1, int y1, int x2, int y2,
d1027 1
a1027 1
		src_pitch[1] = src_pitch[0] = video_pitch * 2;
@


1.4
log
@update to xf86-video-intel 2.7.1. Tested by many.
@
text
@d51 1
a51 1
    { 0x00000030, 0x20000108, 0x00001220, 0x00000000 },
d53 1
a53 1
    { 0x0040007e, 0x20000c21, 0x00690000, 0x00000000 },
d55 1
a55 1
    { 0x0040007e, 0x20000c21, 0x00690000, 0x00000000 },
d57 1
a57 1
    { 0x0040007e, 0x20000c21, 0x00690000, 0x00000000 },
d59 1
a59 1
    { 0x0040007e, 0x20000c21, 0x00690000, 0x00000000 },
d61 1
a61 1
    { 0x0040007e, 0x20000c21, 0x00690000, 0x00000000 },
d63 1
a63 1
    { 0x0040007e, 0x20000c21, 0x00690000, 0x00000000 },
d65 1
a65 1
    { 0x0040007e, 0x20000c21, 0x00690000, 0x00000000 },
d67 1
a67 1
    { 0x0040007e, 0x20000c21, 0x00690000, 0x00000000 },
d69 1
a69 1
    { 0x0040007e, 0x20000c21, 0x00690000, 0x00000000 },
d113 12
a124 2
#define ALIGN(i,m)    (((i) + (m) - 1) & ~((m) - 1))
#define MIN(a,b) ((a) < (b) ? (a) : (b))
d126 16
a141 4
static uint32_t float_to_uint (float f) {
    union {uint32_t i; float f;} x;
    x.f = f;
    return x.i;
d146 2
a147 2
    uint32_t svg_ctl;
    char *name;
d149 8
a156 8
    { BRW_SVG_CTL_GS_BA, "General State Base Address" },
    { BRW_SVG_CTL_SS_BA, "Surface State Base Address" },
    { BRW_SVG_CTL_IO_BA, "Indirect Object Base Address" },
    { BRW_SVG_CTL_GS_AUB, "Generate State Access Upper Bound" },
    { BRW_SVG_CTL_IO_AUB, "Indirect Object Access Upper Bound" },
    { BRW_SVG_CTL_SIP, "System Instruction Pointer" },
    { 0, 0 },
};
d158 1
a158 2
static void
brw_debug (ScrnInfoPtr pScrn, char *when)
d160 11
a170 11
    I830Ptr pI830 = I830PTR(pScrn);
    int	i;
    uint32_t v;

    I830Sync (pScrn);
    ErrorF("brw_debug: %s\n", when);
    for (i = 0; svg_ctl_bits[i].name; i++) {
	OUTREG(BRW_SVG_CTL, svg_ctl_bits[i].svg_ctl);
	v = INREG(BRW_SVG_RDATA);
	ErrorF("\t%34.34s: 0x%08x\n", svg_ctl_bits[i].name, v);
    }
d178 1
a178 2
static void
i965_pre_draw_debug(ScrnInfoPtr scrn)
d181 1
a181 1
    I830Ptr pI830 = I830PTR(scrn);
d185 9
a193 9
    ErrorF ("before EU_ATT 0x%08x%08x EU_ATT_DATA 0x%08x%08x\n",
	    INREG(BRW_EU_ATT_1), INREG(BRW_EU_ATT_0),
	    INREG(BRW_EU_ATT_DATA_1), INREG(BRW_EU_ATT_DATA_0));

    OUTREG(BRW_VF_CTL,
	   BRW_VF_CTL_SNAPSHOT_MUX_SELECT_THREADID |
	   BRW_VF_CTL_SNAPSHOT_TYPE_VERTEX_INDEX |
	   BRW_VF_CTL_SNAPSHOT_ENABLE);
    OUTREG(BRW_VF_STRG_VAL, 0);
d197 4
a200 4
    OUTREG(BRW_VS_CTL,
	   BRW_VS_CTL_SNAPSHOT_ALL_THREADS |
	   BRW_VS_CTL_SNAPSHOT_MUX_VALID_COUNT |
	   BRW_VS_CTL_THREAD_SNAPSHOT_ENABLE);
d202 1
a202 1
    OUTREG(BRW_VS_STRG_VAL, 0);
d206 5
a210 5
    OUTREG(BRW_SF_CTL,
	   BRW_SF_CTL_SNAPSHOT_MUX_VERTEX_COUNT |
	   BRW_SF_CTL_SNAPSHOT_ALL_THREADS |
	   BRW_SF_CTL_THREAD_SNAPSHOT_ENABLE);
    OUTREG(BRW_SF_STRG_VAL, 0);
d214 4
a217 6
    OUTREG(BRW_WIZ_CTL,
	   BRW_WIZ_CTL_SNAPSHOT_MUX_SUBSPAN_INSTANCE |
	   BRW_WIZ_CTL_SNAPSHOT_ALL_THREADS |
	   BRW_WIZ_CTL_SNAPSHOT_ENABLE);
    OUTREG(BRW_WIZ_STRG_VAL,
	   (box_x1) | (box_y1 << 16));
d221 5
a225 5
    OUTREG(BRW_TS_CTL,
	   BRW_TS_CTL_SNAPSHOT_MESSAGE_ERROR |
	   BRW_TS_CTL_SNAPSHOT_ALL_CHILD_THREADS |
	   BRW_TS_CTL_SNAPSHOT_ALL_ROOT_THREADS |
	   BRW_TS_CTL_SNAPSHOT_ENABLE);
d229 1
a229 2
static void
i965_post_draw_debug(ScrnInfoPtr scrn)
d232 1
a232 1
    I830Ptr pI830 = I830PTR(scrn);
d236 9
a244 9
    for (j = 0; j < 100000; j++) {
	ctl = INREG(BRW_VF_CTL);
	if (ctl & BRW_VF_CTL_SNAPSHOT_COMPLETE)
	    break;
    }

    rdata = INREG(BRW_VF_RDATA);
    OUTREG(BRW_VF_CTL, 0);
    ErrorF ("VF_CTL: 0x%08x VF_RDATA: 0x%08x\n", ctl, rdata);
d248 5
a252 5
    for (j = 0; j < 1000000; j++) {
	ctl = INREG(BRW_VS_CTL);
	if (ctl & BRW_VS_CTL_SNAPSHOT_COMPLETE)
	    break;
    }
a253 5
    rdata = INREG(BRW_VS_RDATA);
    for (k = 0; k <= 3; k++) {
	OUTREG(BRW_VS_CTL,
	       BRW_VS_CTL_SNAPSHOT_COMPLETE |
	       (k << 8));
d255 5
a259 2
	ErrorF ("VS_CTL: 0x%08x VS_RDATA(%d): 0x%08x\n", ctl, k, rdata);
    }
d261 1
a261 1
    OUTREG(BRW_VS_CTL, 0);
d265 5
a269 5
    for (j = 0; j < 1000000; j++) {
	ctl = INREG(BRW_SF_CTL);
	if (ctl & BRW_SF_CTL_SNAPSHOT_COMPLETE)
	    break;
    }
d271 5
a275 7
    for (k = 0; k <= 7; k++) {
	OUTREG(BRW_SF_CTL,
	       BRW_SF_CTL_SNAPSHOT_COMPLETE |
	       (k << 8));
	rdata = INREG(BRW_SF_RDATA);
	ErrorF("SF_CTL: 0x%08x SF_RDATA(%d): 0x%08x\n", ctl, k, rdata);
    }
d277 1
a277 1
    OUTREG(BRW_SF_CTL, 0);
d281 9
a289 9
    for (j = 0; j < 100000; j++) {
	ctl = INREG(BRW_WIZ_CTL);
	if (ctl & BRW_WIZ_CTL_SNAPSHOT_COMPLETE)
	    break;
    }

    rdata = INREG(BRW_WIZ_RDATA);
    OUTREG(BRW_WIZ_CTL, 0);
    ErrorF("WIZ_CTL: 0x%08x WIZ_RDATA: 0x%08x\n", ctl, rdata);
d293 13
a305 13
    for (j = 0; j < 100000; j++) {
	ctl = INREG(BRW_TS_CTL);
	if (ctl & BRW_TS_CTL_SNAPSHOT_COMPLETE)
	    break;
    }

    rdata = INREG(BRW_TS_RDATA);
    OUTREG(BRW_TS_CTL, 0);
    ErrorF("TS_CTL: 0x%08x TS_RDATA: 0x%08x\n", ctl, rdata);

    ErrorF("after EU_ATT 0x%08x%08x EU_ATT_DATA 0x%08x%08x\n",
	   INREG(BRW_EU_ATT_1), INREG(BRW_EU_ATT_0),
	   INREG(BRW_EU_ATT_DATA_1), INREG(BRW_EU_ATT_DATA_0));
d309 5
a313 5
    for (j = 0; j < 256; j++) {
	OUTREG(BRW_TD_CTL, j << BRW_TD_CTL_MUX_SHIFT);
	rdata = INREG(BRW_TD_RDATA);
	ErrorF ("TD_RDATA(%d): 0x%08x\n", j, rdata);
    }
d343 2
a344 2
intel_alloc_and_map(I830Ptr i830, char *name, int size,
		    drm_intel_bo **bop, void *virtualp)
d346 1
a346 1
    drm_intel_bo    *bo;
d348 11
a358 11
    bo = drm_intel_bo_alloc(i830->bufmgr, name, size, 4096);
    if (!bo)
	return -1;
    if (drm_intel_bo_map(bo, TRUE) != 0) {
	drm_intel_bo_unreference(bo);
	return -1;
    }
    *bop = bo;
    *(void **) virtualp = bo->virtual;
    memset (bo->virtual, 0, size);
    return 0;
d361 2
a362 3
static drm_intel_bo *
i965_create_dst_surface_state(ScrnInfoPtr scrn,
			      PixmapPtr pixmap)
d364 28
a391 25
    I830Ptr pI830 = I830PTR(scrn);
    struct brw_surface_state *dest_surf_state;
    drm_intel_bo *pixmap_bo = i830_get_pixmap_bo(pixmap);
    drm_intel_bo *surf_bo;

    if (intel_alloc_and_map(pI830, "textured video surface state", 4096,
			    &surf_bo, &dest_surf_state) != 0)
	return NULL;

    dest_surf_state->ss0.surface_type = BRW_SURFACE_2D;
    dest_surf_state->ss0.data_return_format = BRW_SURFACERETURNFORMAT_FLOAT32;
    if (pI830->cpp == 2) {
	dest_surf_state->ss0.surface_format = BRW_SURFACEFORMAT_B5G6R5_UNORM;
    } else {
	dest_surf_state->ss0.surface_format = BRW_SURFACEFORMAT_B8G8R8A8_UNORM;
    }
    dest_surf_state->ss0.writedisable_alpha = 0;
    dest_surf_state->ss0.writedisable_red = 0;
    dest_surf_state->ss0.writedisable_green = 0;
    dest_surf_state->ss0.writedisable_blue = 0;
    dest_surf_state->ss0.color_blend = 1;
    dest_surf_state->ss0.vert_line_stride = 0;
    dest_surf_state->ss0.vert_line_stride_ofs = 0;
    dest_surf_state->ss0.mipmap_layout_mode = 0;
    dest_surf_state->ss0.render_cache_read_mode = 0;
a392 1
    if (pixmap_bo != NULL)
d395 9
a403 12
			     pixmap_bo, 0,
			     I915_GEM_DOMAIN_SAMPLER, 0);
    else
	dest_surf_state->ss1.base_addr = intel_get_pixmap_offset(pixmap);

    dest_surf_state->ss2.height = scrn->virtualY - 1;
    dest_surf_state->ss2.width = scrn->virtualX - 1;
    dest_surf_state->ss2.mip_count = 0;
    dest_surf_state->ss2.render_target_rotation = 0;
    dest_surf_state->ss3.pitch = intel_get_pixmap_pitch(pixmap) - 1;
    dest_surf_state->ss3.tiled_surface = i830_pixmap_tiled(pixmap);
    dest_surf_state->ss3.tile_walk = 0; /* TileX */
d405 2
a406 2
    drm_intel_bo_unmap(surf_bo);
    return surf_bo;
d409 7
a415 8
static drm_intel_bo *
i965_create_src_surface_state(ScrnInfoPtr scrn,
			      drm_intel_bo *src_bo,
			      uint32_t src_offset,
			      int src_width,
			      int src_height,
			      int src_pitch,
			      uint32_t src_surf_format)
d417 36
a452 36
    I830Ptr pI830 = I830PTR(scrn);
    drm_intel_bo *surface_bo;
    struct brw_surface_state *src_surf_state;

    if (intel_alloc_and_map(pI830, "textured video surface state", 4096,
			    &surface_bo, &src_surf_state) != 0)
	return NULL;

    /* Set up the source surface state buffer */
    src_surf_state->ss0.surface_type = BRW_SURFACE_2D;
    src_surf_state->ss0.surface_format = src_surf_format;
    src_surf_state->ss0.writedisable_alpha = 0;
    src_surf_state->ss0.writedisable_red = 0;
    src_surf_state->ss0.writedisable_green = 0;
    src_surf_state->ss0.writedisable_blue = 0;
    src_surf_state->ss0.color_blend = 1;
    src_surf_state->ss0.vert_line_stride = 0;
    src_surf_state->ss0.vert_line_stride_ofs = 0;
    src_surf_state->ss0.mipmap_layout_mode = 0;
    src_surf_state->ss0.render_cache_read_mode = 0;

    src_surf_state->ss2.width = src_width - 1;
    src_surf_state->ss2.height = src_height - 1;
    src_surf_state->ss2.mip_count = 0;
    src_surf_state->ss2.render_target_rotation = 0;
    src_surf_state->ss3.pitch = src_pitch - 1;

    if (src_bo) {
        src_surf_state->ss1.base_addr =
            intel_emit_reloc(surface_bo,
                             offsetof(struct brw_surface_state, ss1),
                             src_bo, src_offset,
                             I915_GEM_DOMAIN_SAMPLER, 0);
    } else {
        src_surf_state->ss1.base_addr = src_offset;
    }
d454 2
a455 2
    drm_intel_bo_unmap(surface_bo);
    return surface_bo;
d458 3
a460 2
static drm_intel_bo *
i965_create_binding_table(ScrnInfoPtr scrn, drm_intel_bo **surf_bos, int n_surf)
d462 6
a467 15
    I830Ptr pI830 = I830PTR(scrn);
    drm_intel_bo *bind_bo;
    uint32_t *binding_table;
    int i;

    /* Set up a binding table for our surfaces.  Only the PS will use it */

    if (intel_alloc_and_map(pI830, "textured video binding table", 4096,
			    &bind_bo, &binding_table) != 0)
	return NULL;

    for (i = 0; i < n_surf; i++)
	binding_table[i] = intel_emit_reloc(bind_bo, i * sizeof(uint32_t),
					    surf_bos[i], 0,
					    I915_GEM_DOMAIN_INSTRUCTION, 0);
d469 11
a479 2
    drm_intel_bo_unmap(bind_bo);
    return bind_bo;
d482 1
a482 2
static drm_intel_bo *
i965_create_sampler_state(ScrnInfoPtr scrn)
d484 13
a496 13
    I830Ptr pI830 = I830PTR(scrn);
    drm_intel_bo *sampler_bo;
    struct brw_sampler_state *sampler_state;

    if (intel_alloc_and_map(pI830, "textured video sampler state", 4096,
			    &sampler_bo, &sampler_state) != 0)
	return NULL;

    sampler_state->ss0.min_filter = BRW_MAPFILTER_LINEAR;
    sampler_state->ss0.mag_filter = BRW_MAPFILTER_LINEAR;
    sampler_state->ss1.r_wrap_mode = BRW_TEXCOORDMODE_CLAMP;
    sampler_state->ss1.s_wrap_mode = BRW_TEXCOORDMODE_CLAMP;
    sampler_state->ss1.t_wrap_mode = BRW_TEXCOORDMODE_CLAMP;
d498 2
a499 2
    drm_intel_bo_unmap(sampler_bo);
    return sampler_bo;
d502 1
a502 2
static drm_intel_bo *
i965_create_vs_state(ScrnInfoPtr scrn)
d504 16
a519 13
    I830Ptr pI830 = I830PTR(scrn);
    drm_intel_bo *vs_bo;
    struct brw_vs_unit_state *vs_state;

    if (intel_alloc_and_map(pI830, "textured video vs state", 4096,
			    &vs_bo, &vs_state) != 0)
	return NULL;

    /* Set up the vertex shader to be disabled (passthrough) */
    vs_state->thread4.nr_urb_entries = URB_VS_ENTRIES;
    vs_state->thread4.urb_entry_allocation_size = URB_VS_ENTRY_SIZE - 1;
    vs_state->vs6.vs_enable = 0;
    vs_state->vs6.vert_cache_disable = 1;
d521 2
a522 2
    drm_intel_bo_unmap(vs_bo);
    return vs_bo;
d525 3
a527 3
static drm_intel_bo *
i965_create_program(ScrnInfoPtr scrn, const uint32_t *program,
		    unsigned int program_size)
d529 2
a530 2
    I830Ptr pI830 = I830PTR(scrn);
    drm_intel_bo *prog_bo;
d532 4
a535 4
    prog_bo = drm_intel_bo_alloc(pI830->bufmgr, "textured video program",
				 program_size, 4096);
    if (!prog_bo)
	return NULL;
d537 1
a537 1
    drm_intel_bo_subdata(prog_bo, 0, program_size, program);
d539 1
a539 1
    return prog_bo;
d542 1
a542 2
static drm_intel_bo *
i965_create_sf_state(ScrnInfoPtr scrn)
d544 20
a563 16
    I830Ptr pI830 = I830PTR(scrn);
    drm_intel_bo *sf_bo, *kernel_bo;
    struct brw_sf_unit_state *sf_state;

    kernel_bo = i965_create_program(scrn, &sf_kernel_static[0][0],
				    sizeof(sf_kernel_static));

    if (!kernel_bo)
	return NULL;

    if (intel_alloc_and_map(pI830, "textured video sf state", 4096,
			    &sf_bo, &sf_state) != 0)
    {
	drm_intel_bo_unreference(kernel_bo);
	return NULL;
    }
d565 34
a598 34
    /* Set up the SF kernel to do coord interp: for each attribute,
     * calculate dA/dx and dA/dy.  Hand these interpolation coefficients
     * back to SF which then hands pixels off to WM.
     */
    sf_state->thread0.grf_reg_count = BRW_GRF_BLOCKS(SF_KERNEL_NUM_GRF);
    sf_state->thread0.kernel_start_pointer =
	intel_emit_reloc(sf_bo, offsetof(struct brw_sf_unit_state, thread0),
			 kernel_bo, sf_state->thread0.grf_reg_count << 1,
			 I915_GEM_DOMAIN_INSTRUCTION, 0) >> 6;
    sf_state->sf1.single_program_flow = 1; /* XXX */
    sf_state->sf1.binding_table_entry_count = 0;
    sf_state->sf1.thread_priority = 0;
    sf_state->sf1.floating_point_mode = 0; /* Mesa does this */
    sf_state->sf1.illegal_op_exception_enable = 1;
    sf_state->sf1.mask_stack_exception_enable = 1;
    sf_state->sf1.sw_exception_enable = 1;
    sf_state->thread2.per_thread_scratch_space = 0;
    /* scratch space is not used in our kernel */
    sf_state->thread2.scratch_space_base_pointer = 0;
    sf_state->thread3.const_urb_entry_read_length = 0; /* no const URBs */
    sf_state->thread3.const_urb_entry_read_offset = 0; /* no const URBs */
    sf_state->thread3.urb_entry_read_length = 1; /* 1 URB per vertex */
    sf_state->thread3.urb_entry_read_offset = 0;
    sf_state->thread3.dispatch_grf_start_reg = 3;
    sf_state->thread4.max_threads = SF_MAX_THREADS - 1;
    sf_state->thread4.urb_entry_allocation_size = URB_SF_ENTRY_SIZE - 1;
    sf_state->thread4.nr_urb_entries = URB_SF_ENTRIES;
    sf_state->thread4.stats_enable = 1;
    sf_state->sf5.viewport_transform = FALSE; /* skip viewport */
    sf_state->sf6.cull_mode = BRW_CULLMODE_NONE;
    sf_state->sf6.scissor = 0;
    sf_state->sf7.trifan_pv = 2;
    sf_state->sf6.dest_org_vbias = 0x8;
    sf_state->sf6.dest_org_hbias = 0x8;
d600 2
a601 2
    drm_intel_bo_unmap(sf_bo);
    return sf_bo;
d604 3
a606 2
static drm_intel_bo *
i965_create_wm_state(ScrnInfoPtr scrn, drm_intel_bo *sampler_bo, Bool is_packed)
d608 53
a660 13
    I830Ptr pI830 = I830PTR(scrn);
    drm_intel_bo *wm_bo, *kernel_bo;
    struct brw_wm_unit_state *wm_state;

    if (is_packed) {
	kernel_bo = i965_create_program(scrn, &ps_kernel_packed_static[0][0],
					sizeof(ps_kernel_packed_static));
    } else {
	kernel_bo = i965_create_program(scrn, &ps_kernel_planar_static[0][0],
					sizeof(ps_kernel_planar_static));
    }
    if (!kernel_bo)
	return NULL;
d662 5
a666 5
    if (intel_alloc_and_map(pI830, "textured video wm state", sizeof (*wm_state),
			    &wm_bo, &wm_state)) {
	drm_intel_bo_unreference(kernel_bo);
	return NULL;
    }
d668 24
a691 31
    wm_state->thread0.grf_reg_count = BRW_GRF_BLOCKS(PS_KERNEL_NUM_GRF);
    wm_state->thread0.kernel_start_pointer =
	intel_emit_reloc(wm_bo, offsetof(struct brw_wm_unit_state, thread0),
			 kernel_bo, wm_state->thread0.grf_reg_count << 1,
			 I915_GEM_DOMAIN_INSTRUCTION, 0) >> 6;
    wm_state->thread1.single_program_flow = 1; /* XXX */
    if (is_packed)
	wm_state->thread1.binding_table_entry_count = 2;
    else
	wm_state->thread1.binding_table_entry_count = 7;
    /* Though we never use the scratch space in our WM kernel, it has to be
     * set, and the minimum allocation is 1024 bytes.
     */
    wm_state->thread2.scratch_space_base_pointer = 0;
    wm_state->thread2.per_thread_scratch_space = 0; /* 1024 bytes */
    wm_state->thread3.dispatch_grf_start_reg = 3; /* XXX */
    wm_state->thread3.const_urb_entry_read_length = 0;
    wm_state->thread3.const_urb_entry_read_offset = 0;
    wm_state->thread3.urb_entry_read_length = 1; /* XXX */
    wm_state->thread3.urb_entry_read_offset = 0; /* XXX */
    wm_state->wm4.stats_enable = 1;
    wm_state->wm4.sampler_state_pointer =
	intel_emit_reloc(wm_bo, offsetof(struct brw_wm_unit_state, wm4),
			 sampler_bo, 0,
			 I915_GEM_DOMAIN_INSTRUCTION, 0) >> 5;
    wm_state->wm4.sampler_count = 1; /* 1-4 samplers used */
    wm_state->wm5.max_threads = PS_MAX_THREADS - 1;
    wm_state->wm5.thread_dispatch_enable = 1;
    wm_state->wm5.enable_16_pix = 1;
    wm_state->wm5.enable_8_pix = 0;
    wm_state->wm5.early_depth_test = 1;
d693 1
a693 1
    drm_intel_bo_unreference(kernel_bo);
d695 2
a696 2
    drm_intel_bo_unmap(wm_bo);
    return wm_bo;
d699 1
a699 2
static drm_intel_bo *
i965_create_cc_vp_state(ScrnInfoPtr scrn)
d701 7
a707 7
    I830Ptr pI830 = I830PTR(scrn);
    drm_intel_bo *cc_vp_bo;
    struct brw_cc_viewport *cc_viewport;

    if (intel_alloc_and_map(pI830, "textured video cc viewport", 4096,
			    &cc_vp_bo, &cc_viewport) != 0)
	return NULL;
d709 2
a710 2
    cc_viewport->min_depth = -1.e35;
    cc_viewport->max_depth = 1.e35;
d712 2
a713 2
    drm_intel_bo_unmap(cc_vp_bo);
    return cc_vp_bo;
d716 1
a716 2
static drm_intel_bo *
i965_create_cc_state(ScrnInfoPtr scrn)
d718 14
a731 7
    I830Ptr pI830 = I830PTR(scrn);
    drm_intel_bo *cc_bo, *cc_vp_bo;
    struct brw_cc_unit_state *cc_state;

    cc_vp_bo = i965_create_cc_vp_state(scrn);
    if (!cc_vp_bo)
	return NULL;
d733 17
a749 5
    if (intel_alloc_and_map(pI830, "textured video cc state", sizeof(*cc_state),
			    &cc_bo, &cc_state) != 0) {
	drm_intel_bo_unreference(cc_vp_bo);
	return NULL;
    }
d751 1
a751 18
    /* Color calculator state */
    memset(cc_state, 0, sizeof(*cc_state));
    cc_state->cc0.stencil_enable = 0;   /* disable stencil */
    cc_state->cc2.depth_test = 0;       /* disable depth test */
    cc_state->cc2.logicop_enable = 1;   /* enable logic op */
    cc_state->cc3.ia_blend_enable = 1;  /* blend alpha just like colors */
    cc_state->cc3.blend_enable = 0;     /* disable color blend */
    cc_state->cc3.alpha_test = 0;       /* disable alpha test */
    cc_state->cc4.cc_viewport_state_offset =
	intel_emit_reloc(cc_bo, offsetof(struct brw_cc_unit_state, cc4),
			 cc_vp_bo, 0,
			 I915_GEM_DOMAIN_INSTRUCTION, 0) >> 5;
    cc_state->cc5.dither_enable = 0;    /* disable dither */
    cc_state->cc5.logicop_func = 0xc;   /* WHITE */
    cc_state->cc5.statistics_enable = 1;
    cc_state->cc5.ia_blend_function = BRW_BLENDFUNCTION_ADD;
    cc_state->cc5.ia_src_blend_factor = BRW_BLENDFACTOR_ONE;
    cc_state->cc5.ia_dest_blend_factor = BRW_BLENDFACTOR_ONE;
d753 2
a754 4
    drm_intel_bo_unmap(cc_bo);

    drm_intel_bo_unreference(cc_vp_bo);
    return cc_bo;
d758 1
a758 1
i965_emit_video_setup(ScrnInfoPtr pScrn, drm_intel_bo *bind_bo, int n_src_surf)
d760 75
a834 117
    I830Ptr pI830 = I830PTR(pScrn);
    int urb_vs_start, urb_vs_size;
    int urb_gs_start, urb_gs_size;
    int urb_clip_start, urb_clip_size;
    int urb_sf_start, urb_sf_size;
    int urb_cs_start, urb_cs_size;

    IntelEmitInvarientState(pScrn);
    pI830->last_3d = LAST_3D_VIDEO;

    urb_vs_start = 0;
    urb_vs_size = URB_VS_ENTRIES * URB_VS_ENTRY_SIZE;
    urb_gs_start = urb_vs_start + urb_vs_size;
    urb_gs_size = URB_GS_ENTRIES * URB_GS_ENTRY_SIZE;
    urb_clip_start = urb_gs_start + urb_gs_size;
    urb_clip_size = URB_CLIP_ENTRIES * URB_CLIP_ENTRY_SIZE;
    urb_sf_start = urb_clip_start + urb_clip_size;
    urb_sf_size = URB_SF_ENTRIES * URB_SF_ENTRY_SIZE;
    urb_cs_start = urb_sf_start + urb_sf_size;
    urb_cs_size = URB_CS_ENTRIES * URB_CS_ENTRY_SIZE;

    BEGIN_BATCH(2);
    OUT_BATCH(MI_FLUSH |
	      MI_STATE_INSTRUCTION_CACHE_FLUSH |
	      BRW_MI_GLOBAL_SNAPSHOT_RESET);
    OUT_BATCH(MI_NOOP);
    ADVANCE_BATCH();

    /* brw_debug (pScrn, "before base address modify"); */
    BEGIN_BATCH(12);
    /* Match Mesa driver setup */
    if (IS_G4X(pI830))
	OUT_BATCH(NEW_PIPELINE_SELECT | PIPELINE_SELECT_3D);
    else
	OUT_BATCH(BRW_PIPELINE_SELECT | PIPELINE_SELECT_3D);

    /* Mesa does this. Who knows... */
    OUT_BATCH(BRW_CS_URB_STATE | 0);
    OUT_BATCH((0 << 4) |	/* URB Entry Allocation Size */
	      (0 << 0));	/* Number of URB Entries */

    /* Zero out the two base address registers so all offsets are
     * absolute
     */
    OUT_BATCH(BRW_STATE_BASE_ADDRESS | 4);
    OUT_BATCH(0 | BASE_ADDRESS_MODIFY);  /* Generate state base address */
    OUT_BATCH(0 | BASE_ADDRESS_MODIFY);  /* Surface state base address */
    OUT_BATCH(0 | BASE_ADDRESS_MODIFY);  /* media base addr, don't care */
    /* general state max addr, disabled */
    OUT_BATCH(0x10000000 | BASE_ADDRESS_MODIFY);
    /* media object state max addr, disabled */
    OUT_BATCH(0x10000000 | BASE_ADDRESS_MODIFY);

    /* Set system instruction pointer */
    OUT_BATCH(BRW_STATE_SIP | 0);
    /* system instruction pointer */
    OUT_RELOC(pI830->video.gen4_sip_kernel_bo,
	      I915_GEM_DOMAIN_INSTRUCTION, 0, 0);

    OUT_BATCH(MI_NOOP);
    ADVANCE_BATCH();

    /* brw_debug (pScrn, "after base address modify"); */

    BEGIN_BATCH(38);
    /* Enable VF statistics */
    OUT_BATCH(BRW_3DSTATE_VF_STATISTICS | 1);

    /* Pipe control */
    OUT_BATCH(BRW_PIPE_CONTROL |
	      BRW_PIPE_CONTROL_NOWRITE |
	      BRW_PIPE_CONTROL_IS_FLUSH |
	      2);
    OUT_BATCH(0);			/* Destination address */
    OUT_BATCH(0);			/* Immediate data low DW */
    OUT_BATCH(0);			/* Immediate data high DW */

    /* Binding table pointers */
    OUT_BATCH(BRW_3DSTATE_BINDING_TABLE_POINTERS | 4);
    OUT_BATCH(0); /* vs */
    OUT_BATCH(0); /* gs */
    OUT_BATCH(0); /* clip */
    OUT_BATCH(0); /* sf */
    /* Only the PS uses the binding table */
    OUT_RELOC(bind_bo, I915_GEM_DOMAIN_INSTRUCTION, 0, 0);

    /* Blend constant color (magenta is fun) */
    OUT_BATCH(BRW_3DSTATE_CONSTANT_COLOR | 3);
    OUT_BATCH(float_to_uint (1.0));
    OUT_BATCH(float_to_uint (0.0));
    OUT_BATCH(float_to_uint (1.0));
    OUT_BATCH(float_to_uint (1.0));

    /* The drawing rectangle clipping is always on.  Set it to values that
     * shouldn't do any clipping.
     */
    OUT_BATCH(BRW_3DSTATE_DRAWING_RECTANGLE | 2); /* XXX 3 for BLC or CTG */
    OUT_BATCH(0x00000000);			/* ymin, xmin */
    OUT_BATCH((pScrn->virtualX - 1) |
	      (pScrn->virtualY - 1) << 16);	/* ymax, xmax */
    OUT_BATCH(0x00000000);			/* yorigin, xorigin */

    /* skip the depth buffer */
    /* skip the polygon stipple */
    /* skip the polygon stipple offset */
    /* skip the line stipple */

    /* Set the pointers to the 3d pipeline state */
    OUT_BATCH(BRW_3DSTATE_PIPELINED_POINTERS | 5);
    OUT_RELOC(pI830->video.gen4_vs_bo, I915_GEM_DOMAIN_INSTRUCTION, 0, 0);
    /* disable GS, resulting in passthrough */
    OUT_BATCH(BRW_GS_DISABLE);
    /* disable CLIP, resulting in passthrough */
    OUT_BATCH(BRW_CLIP_DISABLE);
    OUT_RELOC(pI830->video.gen4_sf_bo, I915_GEM_DOMAIN_INSTRUCTION, 0, 0);
    if (n_src_surf == 1)
	OUT_RELOC(pI830->video.gen4_wm_packed_bo,
a835 4
    else
	OUT_RELOC(pI830->video.gen4_wm_planar_bo,
		  I915_GEM_DOMAIN_INSTRUCTION, 0, 0);
    OUT_RELOC(pI830->video.gen4_cc_bo, I915_GEM_DOMAIN_INSTRUCTION, 0, 0);
d837 137
a973 41
    /* URB fence */
    OUT_BATCH(BRW_URB_FENCE |
	      UF0_CS_REALLOC |
	      UF0_SF_REALLOC |
	      UF0_CLIP_REALLOC |
	      UF0_GS_REALLOC |
	      UF0_VS_REALLOC |
	      1);
    OUT_BATCH(((urb_clip_start + urb_clip_size) << UF1_CLIP_FENCE_SHIFT) |
	      ((urb_gs_start + urb_gs_size) << UF1_GS_FENCE_SHIFT) |
	      ((urb_vs_start + urb_vs_size) << UF1_VS_FENCE_SHIFT));
    OUT_BATCH(((urb_cs_start + urb_cs_size) << UF2_CS_FENCE_SHIFT) |
	      ((urb_sf_start + urb_sf_size) << UF2_SF_FENCE_SHIFT));

    /* Constant buffer state */
    OUT_BATCH(BRW_CS_URB_STATE | 0);
    OUT_BATCH(((URB_CS_ENTRY_SIZE - 1) << 4) |
	      (URB_CS_ENTRIES << 0));

    /* Set up our vertex elements, sourced from the single vertex buffer. */
    OUT_BATCH(BRW_3DSTATE_VERTEX_ELEMENTS | 3);
    /* offset 0: X,Y -> {X, Y, 1.0, 1.0} */
    OUT_BATCH((0 << VE0_VERTEX_BUFFER_INDEX_SHIFT) |
	      VE0_VALID |
	      (BRW_SURFACEFORMAT_R32G32_FLOAT << VE0_FORMAT_SHIFT) |
	      (0 << VE0_OFFSET_SHIFT));
    OUT_BATCH((BRW_VFCOMPONENT_STORE_SRC << VE1_VFCOMPONENT_0_SHIFT) |
	      (BRW_VFCOMPONENT_STORE_SRC << VE1_VFCOMPONENT_1_SHIFT) |
	      (BRW_VFCOMPONENT_STORE_1_FLT << VE1_VFCOMPONENT_2_SHIFT) |
	      (BRW_VFCOMPONENT_STORE_1_FLT << VE1_VFCOMPONENT_3_SHIFT) |
	      (0 << VE1_DESTINATION_ELEMENT_OFFSET_SHIFT));
    /* offset 8: S0, T0 -> {S0, T0, 1.0, 1.0} */
    OUT_BATCH((0 << VE0_VERTEX_BUFFER_INDEX_SHIFT) |
	      VE0_VALID |
	      (BRW_SURFACEFORMAT_R32G32_FLOAT << VE0_FORMAT_SHIFT) |
	      (8 << VE0_OFFSET_SHIFT));
    OUT_BATCH((BRW_VFCOMPONENT_STORE_SRC << VE1_VFCOMPONENT_0_SHIFT) |
	      (BRW_VFCOMPONENT_STORE_SRC << VE1_VFCOMPONENT_1_SHIFT) |
	      (BRW_VFCOMPONENT_STORE_1_FLT << VE1_VFCOMPONENT_2_SHIFT) |
	      (BRW_VFCOMPONENT_STORE_1_FLT << VE1_VFCOMPONENT_3_SHIFT) |
	      (4 << VE1_DESTINATION_ELEMENT_OFFSET_SHIFT));
d975 2
a976 2
    OUT_BATCH(MI_NOOP);			/* pad to quadword */
    ADVANCE_BATCH();
d980 2
a981 1
I965DisplayVideoTextured(ScrnInfoPtr pScrn, I830PortPrivPtr pPriv, int id,
d986 1
a986 2
			 short drw_w, short drw_h,
			 PixmapPtr pPixmap)
d988 12
a999 12
    I830Ptr pI830 = I830PTR(pScrn);
    BoxPtr pbox;
    int nbox, dxo, dyo, pix_xoff, pix_yoff;
    float src_scale_x, src_scale_y;
    int src_surf, i;
    int n_src_surf;
    uint32_t	src_surf_format;
    uint32_t	src_surf_base[6];
    int		src_width[6];
    int		src_height[6];
    int		src_pitch[6];
    drm_intel_bo *bind_bo, *surf_bos[7];
d1002 2
a1003 2
    ErrorF("BroadwaterDisplayVideoTextured: %dx%d (pitch %d)\n", width, height,
	   video_pitch);
d1007 3
a1009 5
    /* enable debug */
    OUTREG (INST_PM,
	    (1 << (16 + 4)) |
	    (1 << 4));
    ErrorF ("INST_PM 0x%08x\n", INREG(INST_PM));
d1012 6
a1017 6
    src_surf_base[0] = pPriv->YBuf0offset;
    src_surf_base[1] = pPriv->YBuf0offset;
    src_surf_base[2] = pPriv->VBuf0offset;
    src_surf_base[3] = pPriv->VBuf0offset;
    src_surf_base[4] = pPriv->UBuf0offset;
    src_surf_base[5] = pPriv->UBuf0offset;
d1019 2
a1020 2
    ErrorF ("base 0 0x%x base 1 0x%x base 2 0x%x\n",
	    src_surf_base[0], src_surf_base[1], src_surf_base[2]);
d1022 24
a1045 33
    
    switch (id) {
    case FOURCC_UYVY:
	src_surf_format = BRW_SURFACEFORMAT_YCRCB_SWAPY;
	n_src_surf = 1;
	src_width[0] = width;
	src_height[0] = height;
	src_pitch[0] = video_pitch;
	break;
    case FOURCC_YUY2:
	src_surf_format = BRW_SURFACEFORMAT_YCRCB_NORMAL;
	src_width[0] = width;
	src_height[0] = height;
	src_pitch[0] = video_pitch;
	n_src_surf = 1;
	break;
#ifdef INTEL_XVMC
    case FOURCC_XVMC:
#endif
    case FOURCC_I420:
    case FOURCC_YV12:
	src_surf_format = BRW_SURFACEFORMAT_R8_UNORM;
	src_width[1] = src_width[0] = width;
	src_height[1] = src_height[0] = height;
	src_pitch[1] = src_pitch[0] = video_pitch * 2;
	src_width[4] = src_width[5] = src_width[2] = src_width[3] = width / 2;
	src_height[4] = src_height[5] = src_height[2] = src_height[3] = height / 2;
	src_pitch[4] = src_pitch[5] = src_pitch[2] = src_pitch[3] = video_pitch;
	n_src_surf = 6;
	break;
    default:
	return;
    }    
d1048 2
a1049 2
    ErrorF("dst surf:      0x%08x\n", state_base_offset + dest_surf_offset);
    ErrorF("src surf:      0x%08x\n", state_base_offset + src_surf_offset);
d1052 34
a1085 97
    /* We'll be poking the state buffers that could be in use by the 3d
     * hardware here, but we should have synced the 3D engine already in
     * I830PutImage.
     */

    /* Upload kernels */
    surf_bos[0] = i965_create_dst_surface_state(pScrn, pPixmap);
    if (!surf_bos[0])
	return;

    for (src_surf = 0; src_surf < n_src_surf; src_surf++) {
	drm_intel_bo *surf_bo =
	    i965_create_src_surface_state(pScrn,
					  pPriv->buf,
					  src_surf_base[src_surf],
					  src_width[src_surf],
					  src_height[src_surf],
					  src_pitch[src_surf],
					  src_surf_format);
	if (!surf_bo) {
	    int	q;
	    for(q = 0; q < src_surf + 1; q++)
		drm_intel_bo_unreference(surf_bos[q]);
	    return;
	}
	surf_bos[src_surf + 1] = surf_bo;
    }
    bind_bo = i965_create_binding_table(pScrn, surf_bos, n_src_surf + 1);
    for (i = 0; i < n_src_surf + 1; i++) {
	drm_intel_bo_unreference(surf_bos[i]);
	surf_bos[i] = NULL;
    }
    if (!bind_bo)
	return;

    if (pI830->video.gen4_sampler_bo == NULL)
	pI830->video.gen4_sampler_bo = i965_create_sampler_state(pScrn);
    if (pI830->video.gen4_sip_kernel_bo == NULL) {
	pI830->video.gen4_sip_kernel_bo =
	    i965_create_program(pScrn, &sip_kernel_static[0][0],
				sizeof(sip_kernel_static));
	if (!pI830->video.gen4_sip_kernel_bo) {
	    drm_intel_bo_unreference(bind_bo);
	    return;
	}
    }

    if (pI830->video.gen4_vs_bo == NULL) {
	pI830->video.gen4_vs_bo = i965_create_vs_state(pScrn);
	if (!pI830->video.gen4_vs_bo) {
	    drm_intel_bo_unreference(bind_bo);
	    return;
	}
    }
    if (pI830->video.gen4_sf_bo == NULL) {
	pI830->video.gen4_sf_bo = i965_create_sf_state(pScrn);
	if (!pI830->video.gen4_sf_bo) {
	    drm_intel_bo_unreference(bind_bo);
	    return;
	}
    }
    if (pI830->video.gen4_wm_packed_bo == NULL) {
	pI830->video.gen4_wm_packed_bo =
	    i965_create_wm_state(pScrn, pI830->video.gen4_sampler_bo, TRUE);
	if (!pI830->video.gen4_wm_packed_bo) {
	    drm_intel_bo_unreference(bind_bo);
	    return;
	}
    }

    if (pI830->video.gen4_wm_planar_bo == NULL) {
	pI830->video.gen4_wm_planar_bo =
	    i965_create_wm_state(pScrn, pI830->video.gen4_sampler_bo, FALSE);
	if (!pI830->video.gen4_wm_planar_bo) {
	    drm_intel_bo_unreference(bind_bo);
	    return;
	}
    }

    if (pI830->video.gen4_cc_bo == NULL) {
	pI830->video.gen4_cc_bo = i965_create_cc_state(pScrn);
	if (!pI830->video.gen4_cc_bo) {
	    drm_intel_bo_unreference(bind_bo);
	    return;
	}
    }

   /* Set up the offset for translating from the given region (in screen
    * coordinates) to the backing pixmap.
    */
#ifdef COMPOSITE
    pix_xoff = -pPixmap->screen_x + pPixmap->drawable.x;
    pix_yoff = -pPixmap->screen_y + pPixmap->drawable.y;
#else
    pix_xoff = 0;
    pix_yoff = 0;
#endif
d1087 11
a1097 2
    dxo = dstRegion->extents.x1;
    dyo = dstRegion->extents.y1;
d1099 23
a1121 49
    /* Use normalized texture coordinates */
    src_scale_x = ((float)src_w / width) / (float)drw_w;
    src_scale_y = ((float)src_h / height) / (float)drw_h;

    pbox = REGION_RECTS(dstRegion);
    nbox = REGION_NUM_RECTS(dstRegion);
    while (nbox--) {
	int box_x1 = pbox->x1;
	int box_y1 = pbox->y1;
	int box_x2 = pbox->x2;
	int box_y2 = pbox->y2;
	int i;
	drm_intel_bo *vb_bo;
	float *vb;
	drm_intel_bo *bo_table[] = {
	    NULL, /* vb_bo */
	    pI830->batch_bo,
	    bind_bo,
	    pI830->video.gen4_sampler_bo,
	    pI830->video.gen4_sip_kernel_bo,
	    pI830->video.gen4_vs_bo,
	    pI830->video.gen4_sf_bo,
	    pI830->video.gen4_wm_packed_bo,
	    pI830->video.gen4_wm_planar_bo,
	    pI830->video.gen4_cc_bo,
	};

	pbox++;

	if (intel_alloc_and_map(pI830, "textured video vb", 4096,
				&vb_bo, &vb) != 0)
	    break;
	bo_table[0] = vb_bo;

	i = 0;
	vb[i++] = (box_x2 - dxo) * src_scale_x;
	vb[i++] = (box_y2 - dyo) * src_scale_y;
	vb[i++] = (float) box_x2 + pix_xoff;
	vb[i++] = (float) box_y2 + pix_yoff;

	vb[i++] = (box_x1 - dxo) * src_scale_x;
	vb[i++] = (box_y2 - dyo) * src_scale_y;
	vb[i++] = (float) box_x1 + pix_xoff;
	vb[i++] = (float) box_y2 + pix_yoff;

	vb[i++] = (box_x1 - dxo) * src_scale_x;
	vb[i++] = (box_y1 - dyo) * src_scale_y;
	vb[i++] = (float) box_x1 + pix_xoff;
	vb[i++] = (float) box_y1 + pix_yoff;
d1123 9
a1131 1
	drm_intel_bo_unmap(vb_bo);
d1133 7
a1139 1
	i965_pre_draw_debug(pScrn);
d1141 2
a1142 2
	/* If this command won't fit in the current batch, flush.
	 * Assume that it does after being flushed.
d1144 102
a1245 32
	if (drm_intel_bufmgr_check_aperture_space(bo_table,
						  ARRAY_SIZE(bo_table)) < 0) {
	    intel_batch_flush(pScrn, FALSE);
	}

	intel_batch_start_atomic(pScrn, 100);

	i965_emit_video_setup(pScrn, bind_bo, n_src_surf);

	BEGIN_BATCH(12);
	/* Set up the pointer to our vertex buffer */
	OUT_BATCH(BRW_3DSTATE_VERTEX_BUFFERS | 3);
	/* four 32-bit floats per vertex */
	OUT_BATCH((0 << VB0_BUFFER_INDEX_SHIFT) |
		  VB0_VERTEXDATA |
		  ((4 * 4) << VB0_BUFFER_PITCH_SHIFT));
	OUT_RELOC(vb_bo, I915_GEM_DOMAIN_VERTEX, 0, 0);
	OUT_BATCH(3); /* four corners to our rectangle */
	OUT_BATCH(0); /* reserved */

	OUT_BATCH(BRW_3DPRIMITIVE |
		  BRW_3DPRIMITIVE_VERTEX_SEQUENTIAL |
		  (_3DPRIM_RECTLIST << BRW_3DPRIMITIVE_TOPOLOGY_SHIFT) |
		  (0 << 9) |  /* CTG - indirect vertex count */
		  4);
	OUT_BATCH(3); /* vertex count per instance */
	OUT_BATCH(0); /* start vertex offset */
	OUT_BATCH(1); /* single instance */
	OUT_BATCH(0); /* start instance location */
	OUT_BATCH(0); /* index buffer offset, ignored */
	OUT_BATCH(MI_NOOP);
	ADVANCE_BATCH();
d1247 1
a1247 1
	intel_batch_end_atomic(pScrn);
d1249 1
a1249 1
	drm_intel_bo_unreference(vb_bo);
d1251 2
a1252 2
	i965_post_draw_debug(pScrn);
    }
d1254 1
a1254 1
    i830MarkSync(pScrn);
d1256 2
a1257 2
    /* release reference once we're finished */
    drm_intel_bo_unreference(bind_bo);
d1260 1
a1260 1
    i830_dump_error_state(pScrn);
d1262 2
d1266 1
a1266 2
void
i965_free_video(ScrnInfoPtr scrn)
d1268 1
a1268 1
    I830Ptr pI830 = I830PTR(scrn);
d1270 16
a1285 16
    drm_intel_bo_unreference(pI830->video.gen4_vs_bo);
    pI830->video.gen4_vs_bo = NULL;
    drm_intel_bo_unreference(pI830->video.gen4_sf_bo);
    pI830->video.gen4_sf_bo = NULL;
    drm_intel_bo_unreference(pI830->video.gen4_cc_bo);
    pI830->video.gen4_cc_bo = NULL;
    drm_intel_bo_unreference(pI830->video.gen4_wm_packed_bo);
    pI830->video.gen4_wm_packed_bo = NULL;
    drm_intel_bo_unreference(pI830->video.gen4_wm_planar_bo);
    pI830->video.gen4_wm_planar_bo = NULL;
    drm_intel_bo_unreference(pI830->video.gen4_cc_vp_bo);
    pI830->video.gen4_cc_vp_bo = NULL;
    drm_intel_bo_unreference(pI830->video.gen4_sampler_bo);
    pI830->video.gen4_sampler_bo = NULL;
    drm_intel_bo_unreference(pI830->video.gen4_sip_kernel_bo);
    pI830->video.gen4_sip_kernel_bo = NULL;
@


1.3
log
@xf86-video-intel 2.4.2. Has been in snapshots for weeks. Ok oga@@.
@
text
@d40 1
d157 2
a158 8
void
I965DisplayVideoTextured(ScrnInfoPtr pScrn, I830PortPrivPtr pPriv, int id,
			 RegionPtr dstRegion,
			 short width, short height, int video_pitch,
			 int x1, int y1, int x2, int y2,
			 short src_w, short src_h,
			 short drw_w, short drw_h,
			 PixmapPtr pPixmap)
d160 41
a200 42
    I830Ptr pI830 = I830PTR(pScrn);
    BoxPtr pbox;
    int nbox, dxo, dyo, pix_xoff, pix_yoff;
    int urb_vs_start, urb_vs_size;
    int urb_gs_start, urb_gs_size;
    int urb_clip_start, urb_clip_size;
    int urb_sf_start, urb_sf_size;
    int urb_cs_start, urb_cs_size;
    struct brw_surface_state *dest_surf_state;
    struct brw_surface_state *src_surf_state[6];
    struct brw_sampler_state *src_sampler_state[6];
    struct brw_vs_unit_state *vs_state;
    struct brw_sf_unit_state *sf_state;
    struct brw_wm_unit_state *wm_state;
    struct brw_cc_unit_state *cc_state;
    struct brw_cc_viewport *cc_viewport;
    struct brw_instruction *sf_kernel;
    struct brw_instruction *ps_kernel;
    struct brw_instruction *sip_kernel;
    float *vb;
    float src_scale_x, src_scale_y;
    uint32_t *binding_table;
    Bool first_output = TRUE;
    int dest_surf_offset, src_surf_offset[6], src_sampler_offset[6], vs_offset;
    int sf_offset, wm_offset, cc_offset, vb_offset, cc_viewport_offset;
    int wm_scratch_offset;
    int sf_kernel_offset, ps_kernel_offset, sip_kernel_offset;
    int binding_table_offset;
    int next_offset, total_state_size;
    int vb_size = (4 * 4) * 4; /* 4 DWORDS per vertex */
    char *state_base;
    int state_base_offset;
    int src_surf;
    int n_src_surf;
    uint32_t	src_surf_format;
    uint32_t	src_surf_base[6];
    int		src_width[6];
    int		src_height[6];
    int		src_pitch[6];
    int wm_binding_table_entries;
    const uint32_t	*ps_kernel_static;
    int		ps_kernel_static_size;
d203 5
a207 2
    ErrorF("BroadwaterDisplayVideoTextured: %dx%d (pitch %d)\n", width, height,
	   video_pitch);
d209 1
d211 3
a213 4
    /* enable debug */
    OUTREG (INST_PM,
	    (1 << (16 + 4)) |
	    (1 << 4));
d215 1
a215 1
    ErrorF ("INST_PM 0x%08x\n", INREG(INST_PM));
a217 6
    src_surf_base[0] = pPriv->YBuf0offset;
    src_surf_base[1] = pPriv->YBuf0offset;
    src_surf_base[2] = pPriv->VBuf0offset;
    src_surf_base[3] = pPriv->VBuf0offset;
    src_surf_base[4] = pPriv->UBuf0offset;
    src_surf_base[5] = pPriv->UBuf0offset;
d219 9
a227 2
    ErrorF ("base 0 0x%x base 1 0x%x base 2 0x%x\n",
	    src_surf_base[0], src_surf_base[1], src_surf_base[2]);
a228 37
    
    switch (id) {
    case FOURCC_UYVY:
	src_surf_format = BRW_SURFACEFORMAT_YCRCB_SWAPY;
	n_src_surf = 1;
	ps_kernel_static = &ps_kernel_packed_static[0][0];
	ps_kernel_static_size = sizeof (ps_kernel_packed_static);
	src_width[0] = width;
	src_height[0] = height;
	src_pitch[0] = video_pitch;
	break;
    case FOURCC_YUY2:
	src_surf_format = BRW_SURFACEFORMAT_YCRCB_NORMAL;
	ps_kernel_static = &ps_kernel_packed_static[0][0];
	ps_kernel_static_size = sizeof (ps_kernel_packed_static);
	src_width[0] = width;
	src_height[0] = height;
	src_pitch[0] = video_pitch;
	n_src_surf = 1;
	break;
    case FOURCC_I420:
    case FOURCC_YV12:
	src_surf_format = BRW_SURFACEFORMAT_R8_UNORM;
	ps_kernel_static = &ps_kernel_planar_static[0][0];
	ps_kernel_static_size = sizeof (ps_kernel_planar_static);
	src_width[1] = src_width[0] = width;
	src_width[1] = src_height[0] = height;
	src_pitch[1] = src_pitch[0] = video_pitch * 2;
	src_width[4] = src_width[5] = src_width[2] = src_width[3] = width / 2;
	src_height[4] = src_height[5] = src_height[2] = src_height[3] = height / 2;
	src_pitch[4] = src_pitch[5] = src_pitch[2] = src_pitch[3] = video_pitch;
	n_src_surf = 6;
	break;
    default:
	return;
    }    
    wm_binding_table_entries = 1 + n_src_surf;
d230 15
a244 2
    IntelEmitInvarientState(pScrn);
    *pI830->last_3d = LAST_3D_VIDEO;
d246 2
a247 1
    next_offset = 0;
d249 5
a253 24
    /* Set up our layout of state in framebuffer.  First the general state: */
    vs_offset = ALIGN(next_offset, 64);
    next_offset = vs_offset + sizeof(*vs_state);
    sf_offset = ALIGN(next_offset, 32);
    next_offset = sf_offset + sizeof(*sf_state);
    wm_offset = ALIGN(next_offset, 32);
    next_offset = wm_offset + sizeof(*wm_state);
    wm_scratch_offset = ALIGN(next_offset, 1024);
    next_offset = wm_scratch_offset + 1024 * PS_MAX_THREADS;
    cc_offset = ALIGN(next_offset, 32);
    next_offset = cc_offset + sizeof(*cc_state);

    sf_kernel_offset = ALIGN(next_offset, 64);
    next_offset = sf_kernel_offset + sizeof (sf_kernel_static);
    ps_kernel_offset = ALIGN(next_offset, 64);
    next_offset = ps_kernel_offset + ps_kernel_static_size;
    sip_kernel_offset = ALIGN(next_offset, 64);
    next_offset = sip_kernel_offset + sizeof (sip_kernel_static);
    cc_viewport_offset = ALIGN(next_offset, 32);
    next_offset = cc_viewport_offset + sizeof(*cc_viewport);

    for (src_surf = 0; src_surf < n_src_surf; src_surf++) {    
	src_sampler_offset[src_surf] = ALIGN(next_offset, 32);
	next_offset = src_sampler_offset[src_surf] + sizeof(struct brw_sampler_state);
d255 7
a261 12
    
    /* Align VB to native size of elements, for safety */
    vb_offset = ALIGN(next_offset, 8);
    next_offset = vb_offset + vb_size;

    /* And then the general state: */
    dest_surf_offset = ALIGN(next_offset, 32);
    next_offset = dest_surf_offset + sizeof(*dest_surf_state);
    
    for (src_surf = 0; src_surf < n_src_surf; src_surf++) {
	src_surf_offset[src_surf] = ALIGN(next_offset, 32);
	next_offset = src_surf_offset[src_surf] + sizeof(struct brw_surface_state);
a262 3
    
    binding_table_offset = ALIGN(next_offset, 32);
    next_offset = binding_table_offset + (wm_binding_table_entries * 4);
d264 2
a265 3
    /* Allocate an area in framebuffer for our state layout we just set up */
    total_state_size = next_offset;
    assert (total_state_size < BRW_LINEAR_EXTRA);
d267 6
a272 5
    /*
     * Use the extra space allocated at the end of the Xv buffer
     */
    state_base_offset = pPriv->extra_offset;
    state_base_offset = ALIGN(state_base_offset, 64);
d274 4
a277 12
    state_base = (char *)(pI830->FbBase + state_base_offset);
    /* Set up our pointers to state structures in framebuffer.  It would
     * probably be a good idea to fill these structures out in system memory
     * and then dump them there, instead.
     */
    vs_state = (void *)(state_base + vs_offset);
    sf_state = (void *)(state_base + sf_offset);
    wm_state = (void *)(state_base + wm_offset);
    cc_state = (void *)(state_base + cc_offset);
    sf_kernel = (void *)(state_base + sf_kernel_offset);
    ps_kernel = (void *)(state_base + ps_kernel_offset);
    sip_kernel = (void *)(state_base + sip_kernel_offset);
d279 5
a283 7
    cc_viewport = (void *)(state_base + cc_viewport_offset);
    dest_surf_state = (void *)(state_base + dest_surf_offset);
    
    for (src_surf = 0; src_surf < n_src_surf; src_surf++) 
    {
	src_surf_state[src_surf] = (void *)(state_base + src_surf_offset[src_surf]);
	src_sampler_state[src_surf] = (void *)(state_base + src_sampler_offset[src_surf]);
d285 9
a293 2
    binding_table = (void *)(state_base + binding_table_offset);
    vb = (void *)(state_base + vb_offset);
d296 5
a300 13
    ErrorF("vs:            0x%08x\n", state_base_offset + vs_offset);
    ErrorF("wm:            0x%08x\n", state_base_offset + wm_offset);
    ErrorF("sf:            0x%08x\n", state_base_offset + sf_offset);
    ErrorF("cc:            0x%08x\n", state_base_offset + cc_offset);
    ErrorF("sf kernel:     0x%08x\n", state_base_offset + sf_kernel_offset);
    ErrorF("ps kernel:     0x%08x\n", state_base_offset + ps_kernel_offset);
    ErrorF("sip kernel:    0x%08x\n", state_base_offset + sip_kernel_offset);
    ErrorF("cc_vp:         0x%08x\n", state_base_offset + cc_viewport_offset);
    ErrorF("src sampler:   0x%08x\n", state_base_offset + src_sampler_offset);
    ErrorF("vb:            0x%08x\n", state_base_offset + vb_offset);
    ErrorF("dst surf:      0x%08x\n", state_base_offset + dest_surf_offset);
    ErrorF("src surf:      0x%08x\n", state_base_offset + src_surf_offset);
    ErrorF("binding table: 0x%08x\n", state_base_offset + binding_table_offset);
d302 1
d304 5
a308 5
    /* For 3D, the VS must have 8, 12, 16, 24, or 32 VUEs allocated to it.
     * A VUE consists of a 256-bit vertex header followed by the vertex data,
     * which in our case is 4 floats (128 bits), thus a single 512-bit URB
     * entry.
     */
d318 5
a322 5
    /* The SF kernel we use outputs only 4 256-bit registers, leading to an
     * entry size of 2 512-bit URBs.  We don't need to have many entries to
     * output as we're generally working on large rectangles and don't care
     * about having WM threads running on different rectangles simultaneously.
     */
d329 5
a333 10
    urb_vs_start = 0;
    urb_vs_size = URB_VS_ENTRIES * URB_VS_ENTRY_SIZE;
    urb_gs_start = urb_vs_start + urb_vs_size;
    urb_gs_size = URB_GS_ENTRIES * URB_GS_ENTRY_SIZE;
    urb_clip_start = urb_gs_start + urb_gs_size;
    urb_clip_size = URB_CLIP_ENTRIES * URB_CLIP_ENTRY_SIZE;
    urb_sf_start = urb_clip_start + urb_clip_size;
    urb_sf_size = URB_SF_ENTRIES * URB_SF_ENTRY_SIZE;
    urb_cs_start = urb_sf_start + urb_sf_size;
    urb_cs_size = URB_CS_ENTRIES * URB_CS_ENTRY_SIZE;
d335 12
a346 4
    /* We'll be poking the state buffers that could be in use by the 3d
     * hardware here, but we should have synced the 3D engine already in
     * I830PutImage.
     */
d348 8
a355 20
    memset (cc_viewport, 0, sizeof (*cc_viewport));
    cc_viewport->min_depth = -1.e35;
    cc_viewport->max_depth = 1.e35;

    /* Color calculator state */
    memset(cc_state, 0, sizeof(*cc_state));
    cc_state->cc0.stencil_enable = 0;   /* disable stencil */
    cc_state->cc2.depth_test = 0;       /* disable depth test */
    cc_state->cc2.logicop_enable = 1;   /* enable logic op */
    cc_state->cc3.ia_blend_enable = 1;  /* blend alpha just like colors */
    cc_state->cc3.blend_enable = 0;     /* disable color blend */
    cc_state->cc3.alpha_test = 0;       /* disable alpha test */
    cc_state->cc4.cc_viewport_state_offset = (state_base_offset +
					      cc_viewport_offset) >> 5;
    cc_state->cc5.dither_enable = 0;    /* disable dither */
    cc_state->cc5.logicop_func = 0xc;   /* WHITE */
    cc_state->cc5.statistics_enable = 1;
    cc_state->cc5.ia_blend_function = BRW_BLENDFUNCTION_ADD;
    cc_state->cc5.ia_src_blend_factor = BRW_BLENDFACTOR_ONE;
    cc_state->cc5.ia_dest_blend_factor = BRW_BLENDFACTOR_ONE;
d357 3
a359 2
    /* Upload system kernel */
    memcpy (sip_kernel, sip_kernel_static, sizeof (sip_kernel_static));
a360 2
    /* Set up the state buffer for the destination surface */
    memset(dest_surf_state, 0, sizeof(*dest_surf_state));
d378 10
a387 3
    dest_surf_state->ss1.base_addr = intel_get_pixmap_offset(pPixmap);
    dest_surf_state->ss2.height = pScrn->virtualY - 1;
    dest_surf_state->ss2.width = pScrn->virtualX - 1;
d390 2
a391 2
    dest_surf_state->ss3.pitch = intel_get_pixmap_pitch(pPixmap) - 1;
    dest_surf_state->ss3.tiled_surface = i830_pixmap_tiled(pPixmap);
d394 3
a396 31
    for (src_surf = 0; src_surf < n_src_surf; src_surf++)
    {
	/* Set up the source surface state buffer */
	memset(src_surf_state[src_surf], 0, sizeof(struct brw_surface_state));
	src_surf_state[src_surf]->ss0.surface_type = BRW_SURFACE_2D;
	src_surf_state[src_surf]->ss0.surface_format = src_surf_format;
	src_surf_state[src_surf]->ss0.writedisable_alpha = 0;
	src_surf_state[src_surf]->ss0.writedisable_red = 0;
	src_surf_state[src_surf]->ss0.writedisable_green = 0;
	src_surf_state[src_surf]->ss0.writedisable_blue = 0;
	src_surf_state[src_surf]->ss0.color_blend = 1;
	src_surf_state[src_surf]->ss0.vert_line_stride = 0;
	src_surf_state[src_surf]->ss0.vert_line_stride_ofs = 0;
	src_surf_state[src_surf]->ss0.mipmap_layout_mode = 0;
	src_surf_state[src_surf]->ss0.render_cache_read_mode = 0;
    
	src_surf_state[src_surf]->ss1.base_addr = src_surf_base[src_surf];
	src_surf_state[src_surf]->ss2.width = src_width[src_surf] - 1;
	src_surf_state[src_surf]->ss2.height = src_height[src_surf] - 1;
	src_surf_state[src_surf]->ss2.mip_count = 0;
	src_surf_state[src_surf]->ss2.render_target_rotation = 0;
	src_surf_state[src_surf]->ss3.pitch = src_pitch[src_surf] - 1;
    }
    /* FIXME: account for tiling if we ever do it */

    /* Set up a binding table for our two surfaces.  Only the PS will use it */
    /* XXX: are these offset from the right place? */
    binding_table[0] = state_base_offset + dest_surf_offset;
    
    for (src_surf = 0; src_surf < n_src_surf; src_surf++)
	binding_table[1 + src_surf] = state_base_offset + src_surf_offset[src_surf];
d398 44
a441 10
    /* Set up the packed YUV source sampler.  Doesn't do colorspace conversion.
     */
    for (src_surf = 0; src_surf < n_src_surf; src_surf++)
    {
	memset(src_sampler_state[src_surf], 0, sizeof(struct brw_sampler_state));
	src_sampler_state[src_surf]->ss0.min_filter = BRW_MAPFILTER_LINEAR;
	src_sampler_state[src_surf]->ss0.mag_filter = BRW_MAPFILTER_LINEAR;
	src_sampler_state[src_surf]->ss1.r_wrap_mode = BRW_TEXCOORDMODE_CLAMP;
	src_sampler_state[src_surf]->ss1.s_wrap_mode = BRW_TEXCOORDMODE_CLAMP;
	src_sampler_state[src_surf]->ss1.t_wrap_mode = BRW_TEXCOORDMODE_CLAMP;
d444 59
a503 1
    memset(vs_state, 0, sizeof(*vs_state));
d509 41
d554 1
a554 3

    memcpy (sf_kernel, sf_kernel_static, sizeof (sf_kernel_static));
    memset(sf_state, 0, sizeof(*sf_state));
d556 3
a558 2
	(state_base_offset + sf_kernel_offset) >> 6;
    sf_state->thread0.grf_reg_count = BRW_GRF_BLOCKS(SF_KERNEL_NUM_GRF);
d585 28
a612 2
    memcpy (ps_kernel, ps_kernel_static, ps_kernel_static_size);
    memset (wm_state, 0, sizeof (*wm_state));
d614 3
a616 2
	(state_base_offset + ps_kernel_offset) >> 6;
    wm_state->thread0.grf_reg_count = BRW_GRF_BLOCKS(PS_KERNEL_NUM_GRF);
d618 4
a621 1
    wm_state->thread1.binding_table_entry_count = 1 + n_src_surf;
d625 1
a625 2
    wm_state->thread2.scratch_space_base_pointer = (state_base_offset +
						    wm_scratch_offset) >> 10;
d633 4
a636 2
    wm_state->wm4.sampler_state_pointer = (state_base_offset +
					   src_sampler_offset[0]) >> 5;
d644 39
a682 7
    {
	BEGIN_BATCH(2);
	OUT_BATCH(MI_FLUSH |
		  MI_STATE_INSTRUCTION_CACHE_FLUSH |
		  BRW_MI_GLOBAL_SNAPSHOT_RESET);
	OUT_BATCH(MI_NOOP);
	ADVANCE_BATCH();
d685 56
d742 233
a974 12
    {
	BEGIN_BATCH(12);
	/* Match Mesa driver setup */
	if (IS_GM45(pI830) || IS_G4X(pI830))
	    OUT_BATCH(NEW_PIPELINE_SELECT | PIPELINE_SELECT_3D);
	else
	    OUT_BATCH(BRW_PIPELINE_SELECT | PIPELINE_SELECT_3D);

	/* Mesa does this. Who knows... */
	OUT_BATCH(BRW_CS_URB_STATE | 0);
	OUT_BATCH((0 << 4) |	/* URB Entry Allocation Size */
		  (0 << 0));	/* Number of URB Entries */
d976 24
a999 16
	/* Zero out the two base address registers so all offsets are
	 * absolute
	 */
	OUT_BATCH(BRW_STATE_BASE_ADDRESS | 4);
	OUT_BATCH(0 | BASE_ADDRESS_MODIFY);  /* Generate state base address */
	OUT_BATCH(0 | BASE_ADDRESS_MODIFY);  /* Surface state base address */
	OUT_BATCH(0 | BASE_ADDRESS_MODIFY);  /* media base addr, don't care */
	/* general state max addr, disabled */
	OUT_BATCH(0x10000000 | BASE_ADDRESS_MODIFY);
	/* media object state max addr, disabled */
	OUT_BATCH(0x10000000 | BASE_ADDRESS_MODIFY);

	/* Set system instruction pointer */
	OUT_BATCH(BRW_STATE_SIP | 0);
	/* system instruction pointer */
	OUT_BATCH(state_base_offset + sip_kernel_offset);
d1001 10
a1010 2
	OUT_BATCH(MI_NOOP);
	ADVANCE_BATCH();
d1013 22
a1034 1
    /* brw_debug (pScrn, "after base address modify"); */
d1036 8
a1043 105
    {
       BEGIN_BATCH(42);
       /* Enable VF statistics */
       OUT_BATCH(BRW_3DSTATE_VF_STATISTICS | 1);

       /* Pipe control */
       OUT_BATCH(BRW_PIPE_CONTROL |
		 BRW_PIPE_CONTROL_NOWRITE |
		 BRW_PIPE_CONTROL_IS_FLUSH |
		 2);
       OUT_BATCH(0);			/* Destination address */
       OUT_BATCH(0);			/* Immediate data low DW */
       OUT_BATCH(0);			/* Immediate data high DW */

       /* Binding table pointers */
       OUT_BATCH(BRW_3DSTATE_BINDING_TABLE_POINTERS | 4);
       OUT_BATCH(0); /* vs */
       OUT_BATCH(0); /* gs */
       OUT_BATCH(0); /* clip */
       OUT_BATCH(0); /* sf */
       /* Only the PS uses the binding table */
       OUT_BATCH(state_base_offset + binding_table_offset); /* ps */

       /* Blend constant color (magenta is fun) */
       OUT_BATCH(BRW_3DSTATE_CONSTANT_COLOR | 3);
       OUT_BATCH(float_to_uint (1.0));
       OUT_BATCH(float_to_uint (0.0));
       OUT_BATCH(float_to_uint (1.0));
       OUT_BATCH(float_to_uint (1.0));

       /* The drawing rectangle clipping is always on.  Set it to values that
	* shouldn't do any clipping.
	*/
       OUT_BATCH(BRW_3DSTATE_DRAWING_RECTANGLE | 2); /* XXX 3 for BLC or CTG */
       OUT_BATCH(0x00000000);			/* ymin, xmin */
       OUT_BATCH((pScrn->virtualX - 1) |
		 (pScrn->virtualY - 1) << 16);	/* ymax, xmax */
       OUT_BATCH(0x00000000);			/* yorigin, xorigin */

       /* skip the depth buffer */
       /* skip the polygon stipple */
       /* skip the polygon stipple offset */
       /* skip the line stipple */

       /* Set the pointers to the 3d pipeline state */
       OUT_BATCH(BRW_3DSTATE_PIPELINED_POINTERS | 5);
       OUT_BATCH(state_base_offset + vs_offset);  /* 32 byte aligned */
       /* disable GS, resulting in passthrough */
       OUT_BATCH(BRW_GS_DISABLE);
       /* disable CLIP, resulting in passthrough */
       OUT_BATCH(BRW_CLIP_DISABLE);
       OUT_BATCH(state_base_offset + sf_offset);  /* 32 byte aligned */
       OUT_BATCH(state_base_offset + wm_offset);  /* 32 byte aligned */
       OUT_BATCH(state_base_offset + cc_offset);  /* 64 byte aligned */

       /* URB fence */
       OUT_BATCH(BRW_URB_FENCE |
		 UF0_CS_REALLOC |
		 UF0_SF_REALLOC |
		 UF0_CLIP_REALLOC |
		 UF0_GS_REALLOC |
		 UF0_VS_REALLOC |
		 1);
       OUT_BATCH(((urb_clip_start + urb_clip_size) << UF1_CLIP_FENCE_SHIFT) |
		 ((urb_gs_start + urb_gs_size) << UF1_GS_FENCE_SHIFT) |
		 ((urb_vs_start + urb_vs_size) << UF1_VS_FENCE_SHIFT));
       OUT_BATCH(((urb_cs_start + urb_cs_size) << UF2_CS_FENCE_SHIFT) |
		 ((urb_sf_start + urb_sf_size) << UF2_SF_FENCE_SHIFT));

       /* Constant buffer state */
       OUT_BATCH(BRW_CS_URB_STATE | 0);
       OUT_BATCH(((URB_CS_ENTRY_SIZE - 1) << 4) |
		 (URB_CS_ENTRIES << 0));

       /* Set up the pointer to our vertex buffer */
       OUT_BATCH(BRW_3DSTATE_VERTEX_BUFFERS | 2);
       /* four 32-bit floats per vertex */
       OUT_BATCH((0 << VB0_BUFFER_INDEX_SHIFT) |
		 VB0_VERTEXDATA |
		 ((4 * 4) << VB0_BUFFER_PITCH_SHIFT));
       OUT_BATCH(state_base_offset + vb_offset);
       OUT_BATCH(3); /* four corners to our rectangle */

       /* Set up our vertex elements, sourced from the single vertex buffer. */
       OUT_BATCH(BRW_3DSTATE_VERTEX_ELEMENTS | 3);
       /* offset 0: X,Y -> {X, Y, 1.0, 1.0} */
       OUT_BATCH((0 << VE0_VERTEX_BUFFER_INDEX_SHIFT) |
		 VE0_VALID |
		 (BRW_SURFACEFORMAT_R32G32_FLOAT << VE0_FORMAT_SHIFT) |
		 (0 << VE0_OFFSET_SHIFT));
       OUT_BATCH((BRW_VFCOMPONENT_STORE_SRC << VE1_VFCOMPONENT_0_SHIFT) |
		 (BRW_VFCOMPONENT_STORE_SRC << VE1_VFCOMPONENT_1_SHIFT) |
		 (BRW_VFCOMPONENT_STORE_1_FLT << VE1_VFCOMPONENT_2_SHIFT) |
		 (BRW_VFCOMPONENT_STORE_1_FLT << VE1_VFCOMPONENT_3_SHIFT) |
		 (0 << VE1_DESTINATION_ELEMENT_OFFSET_SHIFT));
       /* offset 8: S0, T0 -> {S0, T0, 1.0, 1.0} */
       OUT_BATCH((0 << VE0_VERTEX_BUFFER_INDEX_SHIFT) |
		 VE0_VALID |
		 (BRW_SURFACEFORMAT_R32G32_FLOAT << VE0_FORMAT_SHIFT) |
		 (8 << VE0_OFFSET_SHIFT));
       OUT_BATCH((BRW_VFCOMPONENT_STORE_SRC << VE1_VFCOMPONENT_0_SHIFT) |
		 (BRW_VFCOMPONENT_STORE_SRC << VE1_VFCOMPONENT_1_SHIFT) |
		 (BRW_VFCOMPONENT_STORE_1_FLT << VE1_VFCOMPONENT_2_SHIFT) |
		 (BRW_VFCOMPONENT_STORE_1_FLT << VE1_VFCOMPONENT_3_SHIFT) |
		 (4 << VE1_DESTINATION_ELEMENT_OFFSET_SHIFT));
d1045 6
a1050 2
       OUT_BATCH(MI_NOOP);			/* pad to quadword */
       ADVANCE_BATCH();
d1079 14
d1094 1
a1094 6
	if (!first_output) {
	    /* Since we use the same little vertex buffer over and over, sync
	     * for subsequent rectangles.
	     */
	    i830WaitSync(pScrn);
	}
d1096 4
a1099 1
	pbox++;
d1117 1
a1117 11
#if 0
	ErrorF ("before EU_ATT 0x%08x%08x EU_ATT_DATA 0x%08x%08x\n",
		INREG(BRW_EU_ATT_1), INREG(BRW_EU_ATT_0),
		INREG(BRW_EU_ATT_DATA_1), INREG(BRW_EU_ATT_DATA_0));

	OUTREG(BRW_VF_CTL,
	       BRW_VF_CTL_SNAPSHOT_MUX_SELECT_THREADID |
	       BRW_VF_CTL_SNAPSHOT_TYPE_VERTEX_INDEX |
	       BRW_VF_CTL_SNAPSHOT_ENABLE);
	OUTREG(BRW_VF_STRG_VAL, 0);
#endif
d1119 1
a1119 5
#if 0
	OUTREG(BRW_VS_CTL,
	       BRW_VS_CTL_SNAPSHOT_ALL_THREADS |
	       BRW_VS_CTL_SNAPSHOT_MUX_VALID_COUNT |
	       BRW_VS_CTL_THREAD_SNAPSHOT_ENABLE);
d1121 7
a1127 2
	OUTREG(BRW_VS_STRG_VAL, 0);
#endif
d1129 1
a1129 7
#if WATCH_SF
	OUTREG(BRW_SF_CTL,
	       BRW_SF_CTL_SNAPSHOT_MUX_VERTEX_COUNT |
	       BRW_SF_CTL_SNAPSHOT_ALL_THREADS |
	       BRW_SF_CTL_THREAD_SNAPSHOT_ENABLE);
	OUTREG(BRW_SF_STRG_VAL, 0);
#endif
d1131 1
a1131 8
#if WATCH_WIZ
	OUTREG(BRW_WIZ_CTL,
	       BRW_WIZ_CTL_SNAPSHOT_MUX_SUBSPAN_INSTANCE |
	       BRW_WIZ_CTL_SNAPSHOT_ALL_THREADS |
	       BRW_WIZ_CTL_SNAPSHOT_ENABLE);
	OUTREG(BRW_WIZ_STRG_VAL,
	       (box_x1) | (box_y1 << 16));
#endif
d1133 10
a1142 7
#if 0
	OUTREG(BRW_TS_CTL,
	       BRW_TS_CTL_SNAPSHOT_MESSAGE_ERROR |
	       BRW_TS_CTL_SNAPSHOT_ALL_CHILD_THREADS |
	       BRW_TS_CTL_SNAPSHOT_ALL_ROOT_THREADS |
	       BRW_TS_CTL_SNAPSHOT_ENABLE);
#endif
a1143 1
	BEGIN_BATCH(6);
d1154 1
d1157 1
a1157 6
#if 0
	for (j = 0; j < 100000; j++) {
	    ctl = INREG(BRW_VF_CTL);
	    if (ctl & BRW_VF_CTL_SNAPSHOT_COMPLETE)
		break;
	}
d1159 1
a1159 4
	rdata = INREG(BRW_VF_RDATA);
	OUTREG(BRW_VF_CTL, 0);
	ErrorF ("VF_CTL: 0x%08x VF_RDATA: 0x%08x\n", ctl, rdata);
#endif
d1161 2
a1162 6
#if 0
	for (j = 0; j < 1000000; j++) {
	    ctl = INREG(BRW_VS_CTL);
	    if (ctl & BRW_VS_CTL_SNAPSHOT_COMPLETE)
		break;
	}
d1164 1
a1164 8
	rdata = INREG(BRW_VS_RDATA);
	for (k = 0; k <= 3; k++) {
	    OUTREG(BRW_VS_CTL,
		   BRW_VS_CTL_SNAPSHOT_COMPLETE |
		   (k << 8));
	    rdata = INREG(BRW_VS_RDATA);
	    ErrorF ("VS_CTL: 0x%08x VS_RDATA(%d): 0x%08x\n", ctl, k, rdata);
	}
d1166 2
a1167 2
	OUTREG(BRW_VS_CTL, 0);
#endif
d1169 2
a1170 16
#if WATCH_SF
	for (j = 0; j < 1000000; j++) {
	    ctl = INREG(BRW_SF_CTL);
	    if (ctl & BRW_SF_CTL_SNAPSHOT_COMPLETE)
		break;
	}

	for (k = 0; k <= 7; k++) {
	    OUTREG(BRW_SF_CTL,
		   BRW_SF_CTL_SNAPSHOT_COMPLETE |
		   (k << 8));
	    rdata = INREG(BRW_SF_RDATA);
	    ErrorF("SF_CTL: 0x%08x SF_RDATA(%d): 0x%08x\n", ctl, k, rdata);
	}

	OUTREG(BRW_SF_CTL, 0);
d1172 1
d1174 4
a1177 11
#if WATCH_WIZ
	for (j = 0; j < 100000; j++) {
	    ctl = INREG(BRW_WIZ_CTL);
	    if (ctl & BRW_WIZ_CTL_SNAPSHOT_COMPLETE)
		break;
	}

	rdata = INREG(BRW_WIZ_RDATA);
	OUTREG(BRW_WIZ_CTL, 0);
	ErrorF("WIZ_CTL: 0x%08x WIZ_RDATA: 0x%08x\n", ctl, rdata);
#endif
d1179 16
a1194 30
#if 0
	for (j = 0; j < 100000; j++) {
	    ctl = INREG(BRW_TS_CTL);
	    if (ctl & BRW_TS_CTL_SNAPSHOT_COMPLETE)
		break;
	}

	rdata = INREG(BRW_TS_RDATA);
	OUTREG(BRW_TS_CTL, 0);
	ErrorF("TS_CTL: 0x%08x TS_RDATA: 0x%08x\n", ctl, rdata);

	ErrorF("after EU_ATT 0x%08x%08x EU_ATT_DATA 0x%08x%08x\n",
	       INREG(BRW_EU_ATT_1), INREG(BRW_EU_ATT_0),
	       INREG(BRW_EU_ATT_DATA_1), INREG(BRW_EU_ATT_DATA_0));
#endif

#if 0
	for (j = 0; j < 256; j++) {
	    OUTREG(BRW_TD_CTL, j << BRW_TD_CTL_MUX_SHIFT);
	    rdata = INREG(BRW_TD_RDATA);
	    ErrorF ("TD_RDATA(%d): 0x%08x\n", j, rdata);
	}
#endif
	first_output = FALSE;
	i830MarkSync(pScrn);
    }

#if WATCH_STATS
    i830_dump_error_state(pScrn);
#endif
@


1.2
log
@Update to xf86-video-intel 2.3.1. Tested by many.
@
text
@d81 1
a81 1
#include "packed_yuv_sf.g4b"
d96 14
a109 2
static const uint32_t ps_kernel_static[][4] = {
#include "packed_yuv_wm.g4b"
a114 2
#define WM_BINDING_TABLE_ENTRIES    2

d174 2
a175 2
    struct brw_surface_state *src_surf_state;
    struct brw_sampler_state *src_sampler_state;
d188 1
a188 1
    int dest_surf_offset, src_surf_offset, src_sampler_offset, vs_offset;
d197 10
d221 47
a267 1
    assert((id == FOURCC_UYVY) || (id == FOURCC_YUY2));
d289 1
a289 1
    next_offset = ps_kernel_offset + sizeof (ps_kernel_static);
d295 5
a299 3
    src_sampler_offset = ALIGN(next_offset, 32);
    next_offset = src_sampler_offset + sizeof(*src_sampler_state);

d307 6
a312 2
    src_surf_offset = ALIGN(next_offset, 32);
    next_offset = src_surf_offset + sizeof(*src_surf_state);
d314 1
a314 1
    next_offset = binding_table_offset + (WM_BINDING_TABLE_ENTRIES * 4);
d341 6
a346 2
    src_surf_state = (void *)(state_base + src_surf_offset);
    src_sampler_state = (void *)(state_base + src_sampler_offset);
d459 22
a480 12
    /* Set up the source surface state buffer */
    memset(src_surf_state, 0, sizeof(*src_surf_state));
    src_surf_state->ss0.surface_type = BRW_SURFACE_2D;
    /* src_surf_state->ss0.data_return_format =
       BRW_SURFACERETURNFORMAT_FLOAT32; */
    switch (id) {
    case FOURCC_YUY2:
	src_surf_state->ss0.surface_format = BRW_SURFACEFORMAT_YCRCB_NORMAL;
	break;
    case FOURCC_UYVY:
	src_surf_state->ss0.surface_format = BRW_SURFACEFORMAT_YCRCB_SWAPY;
	break;
a481 16
    src_surf_state->ss0.writedisable_alpha = 0;
    src_surf_state->ss0.writedisable_red = 0;
    src_surf_state->ss0.writedisable_green = 0;
    src_surf_state->ss0.writedisable_blue = 0;
    src_surf_state->ss0.color_blend = 1;
    src_surf_state->ss0.vert_line_stride = 0;
    src_surf_state->ss0.vert_line_stride_ofs = 0;
    src_surf_state->ss0.mipmap_layout_mode = 0;
    src_surf_state->ss0.render_cache_read_mode = 0;

    src_surf_state->ss1.base_addr = pPriv->YBuf0offset;
    src_surf_state->ss2.width = width - 1;
    src_surf_state->ss2.height = height - 1;
    src_surf_state->ss2.mip_count = 0;
    src_surf_state->ss2.render_target_rotation = 0;
    src_surf_state->ss3.pitch = video_pitch - 1;
d487 3
a489 1
    binding_table[1] = state_base_offset + src_surf_offset;
d493 9
a501 6
    memset(src_sampler_state, 0, sizeof(*src_sampler_state));
    src_sampler_state->ss0.min_filter = BRW_MAPFILTER_LINEAR;
    src_sampler_state->ss0.mag_filter = BRW_MAPFILTER_LINEAR;
    src_sampler_state->ss1.r_wrap_mode = BRW_TEXCOORDMODE_CLAMP;
    src_sampler_state->ss1.s_wrap_mode = BRW_TEXCOORDMODE_CLAMP;
    src_sampler_state->ss1.t_wrap_mode = BRW_TEXCOORDMODE_CLAMP;
d546 1
a546 1
    memcpy (ps_kernel, ps_kernel_static, sizeof (ps_kernel_static));
d552 1
a552 1
    wm_state->thread1.binding_table_entry_count = 2;
d566 1
a566 1
					   src_sampler_offset) >> 5;
d587 1
a587 1
	if (IS_IGD_GM(pI830))
@


1.1
log
@Initial revision
@
text
@d48 1
a48 1
static const CARD32 sip_kernel_static[][4] = {
d80 2
a81 2
static const CARD32 sf_kernel_static[][4] = {
#include "sf_prog.h"
d96 2
a97 2
static const CARD32 ps_kernel_static[][4] = {
#include "wm_prog.h"
d105 2
a106 2
static CARD32 float_to_uint (float f) {
    union {CARD32 i; float f;} x;
d113 1
a113 1
    CARD32 svg_ctl;
d130 1
a130 1
    CARD32 v;
d176 1
a176 1
    CARD32 *binding_table;
d500 6
a505 6
	BEGIN_LP_RING(2);
	OUT_RING(MI_FLUSH |
		 MI_STATE_INSTRUCTION_CACHE_FLUSH |
		 BRW_MI_GLOBAL_SNAPSHOT_RESET);
	OUT_RING(MI_NOOP);
	ADVANCE_LP_RING();
d510 1
a510 1
	BEGIN_LP_RING(12);
d512 4
a515 1
	OUT_RING(BRW_PIPELINE_SELECT | PIPELINE_SELECT_3D);
d518 3
a520 3
	OUT_RING(BRW_CS_URB_STATE | 0);
	OUT_RING((0 << 4) |	/* URB Entry Allocation Size */
		 (0 << 0));	/* Number of URB Entries */
d525 4
a528 4
	OUT_RING(BRW_STATE_BASE_ADDRESS | 4);
	OUT_RING(0 | BASE_ADDRESS_MODIFY);  /* Generate state base address */
	OUT_RING(0 | BASE_ADDRESS_MODIFY);  /* Surface state base address */
	OUT_RING(0 | BASE_ADDRESS_MODIFY);  /* media base addr, don't care */
d530 1
a530 1
	OUT_RING(0x10000000 | BASE_ADDRESS_MODIFY);
d532 1
a532 1
	OUT_RING(0x10000000 | BASE_ADDRESS_MODIFY);
d535 1
a535 1
	OUT_RING(BRW_STATE_SIP | 0);
d537 1
a537 1
	OUT_RING(state_base_offset + sip_kernel_offset);
d539 2
a540 2
	OUT_RING(MI_NOOP);
	ADVANCE_LP_RING();
d546 1
a546 1
       BEGIN_LP_RING(42);
d548 1
a548 1
       OUT_RING(BRW_3DSTATE_VF_STATISTICS | 1);
d551 7
a557 7
       OUT_RING(BRW_PIPE_CONTROL |
		BRW_PIPE_CONTROL_NOWRITE |
		BRW_PIPE_CONTROL_IS_FLUSH |
		2);
       OUT_RING(0);			/* Destination address */
       OUT_RING(0);			/* Immediate data low DW */
       OUT_RING(0);			/* Immediate data high DW */
d560 5
a564 5
       OUT_RING(BRW_3DSTATE_BINDING_TABLE_POINTERS | 4);
       OUT_RING(0); /* vs */
       OUT_RING(0); /* gs */
       OUT_RING(0); /* clip */
       OUT_RING(0); /* sf */
d566 1
a566 1
       OUT_RING(state_base_offset + binding_table_offset); /* ps */
d569 5
a573 5
       OUT_RING(BRW_3DSTATE_CONSTANT_COLOR | 3);
       OUT_RING(float_to_uint (1.0));
       OUT_RING(float_to_uint (0.0));
       OUT_RING(float_to_uint (1.0));
       OUT_RING(float_to_uint (1.0));
d578 5
a582 5
       OUT_RING(BRW_3DSTATE_DRAWING_RECTANGLE | 2); /* XXX 3 for BLC or CTG */
       OUT_RING(0x00000000);			/* ymin, xmin */
       OUT_RING((pScrn->virtualX - 1) |
		(pScrn->virtualY - 1) << 16);	/* ymax, xmax */
       OUT_RING(0x00000000);			/* yorigin, xorigin */
d590 2
a591 2
       OUT_RING(BRW_3DSTATE_PIPELINED_POINTERS | 5);
       OUT_RING(state_base_offset + vs_offset);  /* 32 byte aligned */
d593 1
a593 1
       OUT_RING(BRW_GS_DISABLE);
d595 4
a598 4
       OUT_RING(BRW_CLIP_DISABLE);
       OUT_RING(state_base_offset + sf_offset);  /* 32 byte aligned */
       OUT_RING(state_base_offset + wm_offset);  /* 32 byte aligned */
       OUT_RING(state_base_offset + cc_offset);  /* 64 byte aligned */
d601 12
a612 12
       OUT_RING(BRW_URB_FENCE |
		UF0_CS_REALLOC |
		UF0_SF_REALLOC |
		UF0_CLIP_REALLOC |
		UF0_GS_REALLOC |
		UF0_VS_REALLOC |
		1);
       OUT_RING(((urb_clip_start + urb_clip_size) << UF1_CLIP_FENCE_SHIFT) |
		((urb_gs_start + urb_gs_size) << UF1_GS_FENCE_SHIFT) |
		((urb_vs_start + urb_vs_size) << UF1_VS_FENCE_SHIFT));
       OUT_RING(((urb_cs_start + urb_cs_size) << UF2_CS_FENCE_SHIFT) |
		((urb_sf_start + urb_sf_size) << UF2_SF_FENCE_SHIFT));
d615 3
a617 3
       OUT_RING(BRW_CS_URB_STATE | 0);
       OUT_RING(((URB_CS_ENTRY_SIZE - 1) << 4) |
		(URB_CS_ENTRIES << 0));
d620 1
a620 1
       OUT_RING(BRW_3DSTATE_VERTEX_BUFFERS | 2);
d622 5
a626 5
       OUT_RING((0 << VB0_BUFFER_INDEX_SHIFT) |
		VB0_VERTEXDATA |
		((4 * 4) << VB0_BUFFER_PITCH_SHIFT));
       OUT_RING(state_base_offset + vb_offset);
       OUT_RING(3); /* four corners to our rectangle */
d629 1
a629 1
       OUT_RING(BRW_3DSTATE_VERTEX_ELEMENTS | 3);
d631 9
a639 9
       OUT_RING((0 << VE0_VERTEX_BUFFER_INDEX_SHIFT) |
		VE0_VALID |
		(BRW_SURFACEFORMAT_R32G32_FLOAT << VE0_FORMAT_SHIFT) |
		(0 << VE0_OFFSET_SHIFT));
       OUT_RING((BRW_VFCOMPONENT_STORE_SRC << VE1_VFCOMPONENT_0_SHIFT) |
		(BRW_VFCOMPONENT_STORE_SRC << VE1_VFCOMPONENT_1_SHIFT) |
		(BRW_VFCOMPONENT_STORE_1_FLT << VE1_VFCOMPONENT_2_SHIFT) |
		(BRW_VFCOMPONENT_STORE_1_FLT << VE1_VFCOMPONENT_3_SHIFT) |
		(0 << VE1_DESTINATION_ELEMENT_OFFSET_SHIFT));
d641 9
a649 9
       OUT_RING((0 << VE0_VERTEX_BUFFER_INDEX_SHIFT) |
		VE0_VALID |
		(BRW_SURFACEFORMAT_R32G32_FLOAT << VE0_FORMAT_SHIFT) |
		(8 << VE0_OFFSET_SHIFT));
       OUT_RING((BRW_VFCOMPONENT_STORE_SRC << VE1_VFCOMPONENT_0_SHIFT) |
		(BRW_VFCOMPONENT_STORE_SRC << VE1_VFCOMPONENT_1_SHIFT) |
		(BRW_VFCOMPONENT_STORE_1_FLT << VE1_VFCOMPONENT_2_SHIFT) |
		(BRW_VFCOMPONENT_STORE_1_FLT << VE1_VFCOMPONENT_3_SHIFT) |
		(4 << VE1_DESTINATION_ELEMENT_OFFSET_SHIFT));
d651 2
a652 2
       OUT_RING(MI_NOOP);			/* pad to quadword */
       ADVANCE_LP_RING();
d753 12
a764 12
	BEGIN_LP_RING(6);
	OUT_RING(BRW_3DPRIMITIVE |
		 BRW_3DPRIMITIVE_VERTEX_SEQUENTIAL |
		 (_3DPRIM_RECTLIST << BRW_3DPRIMITIVE_TOPOLOGY_SHIFT) |
		 (0 << 9) |  /* CTG - indirect vertex count */
		 4);
	OUT_RING(3); /* vertex count per instance */
	OUT_RING(0); /* start vertex offset */
	OUT_RING(1); /* single instance */
	OUT_RING(0); /* start instance location */
	OUT_RING(0); /* index buffer offset, ignored */
	ADVANCE_LP_RING();
a853 1
    i830WaitSync(pScrn);
@


1.1.1.1
log
@xf86-video-intel 2.2.0
@
text
@@


1.1.1.2
log
@Import intel driver v 2.2.0.90. tested by many, including krw@@ kettenis@@,
jakemsr@@, landry@@, beck@@ and oga@@. Thanks.
@
text
@d512 1
a512 4
	if (IS_IGD_GM(pI830))
	    OUT_RING(NEW_PIPELINE_SELECT | PIPELINE_SELECT_3D);
	else
	    OUT_RING(BRW_PIPELINE_SELECT | PIPELINE_SELECT_3D);
@

