head	1.10;
access;
symbols
	OPENBSD_5_4:1.9.0.2
	OPENBSD_5_4_BASE:1.9
	OPENBSD_5_3:1.8.0.6
	OPENBSD_5_3_BASE:1.8
	OPENBSD_5_2:1.8.0.4
	OPENBSD_5_2_BASE:1.8
	OPENBSD_5_1_BASE:1.8
	OPENBSD_5_1:1.8.0.2
	OPENBSD_5_0:1.7.0.6
	OPENBSD_5_0_BASE:1.7
	OPENBSD_4_9:1.7.0.2
	OPENBSD_4_9_BASE:1.7
	OPENBSD_4_8:1.7.0.4
	OPENBSD_4_8_BASE:1.7
	OPENBSD_4_7:1.4.0.4
	OPENBSD_4_7_BASE:1.4
	OPENBSD_4_6:1.4.0.2
	OPENBSD_4_6_BASE:1.4
	OPENBSD_4_5:1.3.0.2
	OPENBSD_4_5_BASE:1.3
	OPENBSD_4_4:1.2.0.2
	OPENBSD_4_4_BASE:1.2
	OPENBSD_4_3_BASE:1.1.1.3
	OPENBSD_4_3:1.1.1.3.0.2
	v2_2_0_90:1.1.1.3
	v2_2_0:1.1.1.3
	OPENBSD_4_2:1.1.1.2.0.2
	OPENBSD_4_2_BASE:1.1.1.2
	v1_7_4:1.1.1.2
	v1_7_3:1.1.1.2
	v1_7_2:1.1.1.1
	xorg:1.1.1;
locks; strict;
comment	@ * @;


1.10
date	2014.02.03.15.54.51;	author matthieu;	state dead;
branches;
next	1.9;

1.9
date	2013.03.18.18.38.20;	author matthieu;	state Exp;
branches;
next	1.8;

1.8
date	2011.11.29.12.39.03;	author oga;	state Exp;
branches;
next	1.7;

1.7
date	2010.07.18.14.47.47;	author oga;	state Exp;
branches;
next	1.6;

1.6
date	2010.05.23.21.28.35;	author oga;	state Exp;
branches;
next	1.5;

1.5
date	2010.05.10.22.32.29;	author oga;	state Exp;
branches;
next	1.4;

1.4
date	2009.06.25.20.16.43;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2008.10.12.15.20.50;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2008.05.21.20.19.52;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.26.20.06.50;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.11.26.20.06.50;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2006.12.16.21.02.04;	author matthieu;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2007.11.24.19.44.52;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.10
log
@Update to xf86-video-intel 2.99.909
Tested by jsg@@, kettenis@@ and myself on a wide range of intel cards.
@
text
@/*
 * Copyright Â© 2006 Intel Corporation
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice (including the next
 * paragraph) shall be included in all copies or substantial portions of the
 * Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 * Authors:
 *    Eric Anholt <eric@@anholt.net>
 *
 */

#ifdef HAVE_CONFIG_H
#include "config.h"
#endif

#include "xf86.h"
#include "xf86_OSproc.h"
#include "xf86xv.h"
#include "fourcc.h"
#include "gcstruct.h"

#include "intel.h"
#include "intel_video.h"
#include "i915_reg.h"
#include "i915_3d.h"

void
I915DisplayVideoTextured(ScrnInfoPtr scrn,
			 intel_adaptor_private *adaptor_priv, int id,
			 RegionPtr dstRegion,
			 short width, short height, int video_pitch,
			 int video_pitch2,
			 short src_w, short src_h, short drw_w, short drw_h,
			 PixmapPtr pixmap)
{
	intel_screen_private *intel = intel_get_screen_private(scrn);
	uint32_t format, ms3, s5, tiling;
	BoxPtr pbox = REGION_RECTS(dstRegion);
	int nbox_total = REGION_NUM_RECTS(dstRegion);
	int nbox_this_time;
	int dxo, dyo, pix_xoff, pix_yoff;
	PixmapPtr target;

#if 0
	ErrorF("I915DisplayVideo: %dx%d (pitch %d)\n", width, height,
	       video_pitch);
#endif

	dxo = dstRegion->extents.x1;
	dyo = dstRegion->extents.y1;

	if (pixmap->drawable.width > 2048 || pixmap->drawable.height > 2048 ||
	    !intel_check_pitch_3d(pixmap)) {
		ScreenPtr screen = pixmap->drawable.pScreen;

		target = screen->CreatePixmap(screen,
					      dstRegion->extents.x2 - dxo,
					      dstRegion->extents.y2 - dyo,
					      pixmap->drawable.depth,
					      CREATE_PIXMAP_USAGE_SCRATCH);
		if (target == NULL)
			return;

		pix_xoff = -dxo;
		pix_yoff = -dyo;
	} else {
		target = pixmap;

		/* Set up the offset for translating from the given region
		 * (in screen coordinates) to the backing pixmap.
		 */
#ifdef COMPOSITE
		pix_xoff = -target->screen_x + target->drawable.x;
		pix_yoff = -target->screen_y + target->drawable.y;
#else
		pix_xoff = 0;
		pix_yoff = 0;
#endif
	}

#define BYTES_FOR_BOXES(n)	((200 + (n) * 20) * 4)
#define BOXES_IN_BYTES(s)	((((s)/4) - 200) / 20)
#define BATCH_BYTES(p)		((p)->batch_bo->size - 16)

	while (nbox_total) {
		nbox_this_time = nbox_total;
		if (BYTES_FOR_BOXES(nbox_this_time) > BATCH_BYTES(intel))
			nbox_this_time = BOXES_IN_BYTES(BATCH_BYTES(intel));
		nbox_total -= nbox_this_time;

		intel_batch_start_atomic(scrn, 200 + 20 * nbox_this_time);

		IntelEmitInvarientState(scrn);
		intel->last_3d = LAST_3D_VIDEO;

		/* draw rect -- just clipping */
		OUT_BATCH(_3DSTATE_DRAW_RECT_CMD);
		OUT_BATCH(DRAW_DITHER_OFS_X(pixmap->drawable.x & 3) |
			  DRAW_DITHER_OFS_Y(pixmap->drawable.y & 3));
		OUT_BATCH(0x00000000);	/* ymin, xmin */
		/* ymax, xmax */
		OUT_BATCH((target->drawable.width - 1) |
			  (target->drawable.height - 1) << 16);
		OUT_BATCH(0x00000000);	/* yorigin, xorigin */

		OUT_BATCH(_3DSTATE_LOAD_STATE_IMMEDIATE_1 | I1_LOAD_S(2) |
			  I1_LOAD_S(5) | I1_LOAD_S(6) | 2);
		OUT_BATCH(S2_TEXCOORD_FMT(0, TEXCOORDFMT_2D) |
			  S2_TEXCOORD_FMT(1, TEXCOORDFMT_NOT_PRESENT) |
			  S2_TEXCOORD_FMT(2, TEXCOORDFMT_NOT_PRESENT) |
			  S2_TEXCOORD_FMT(3, TEXCOORDFMT_NOT_PRESENT) |
			  S2_TEXCOORD_FMT(4, TEXCOORDFMT_NOT_PRESENT) |
			  S2_TEXCOORD_FMT(5, TEXCOORDFMT_NOT_PRESENT) |
			  S2_TEXCOORD_FMT(6, TEXCOORDFMT_NOT_PRESENT) |
			  S2_TEXCOORD_FMT(7, TEXCOORDFMT_NOT_PRESENT));
		s5 = 0x0;
		if (intel->cpp == 2)
			s5 |= S5_COLOR_DITHER_ENABLE;
		OUT_BATCH(s5);	/* S5 - enable bits */
		OUT_BATCH((2 << S6_DEPTH_TEST_FUNC_SHIFT) |
			  (2 << S6_CBUF_SRC_BLEND_FACT_SHIFT) |
			  (1 << S6_CBUF_DST_BLEND_FACT_SHIFT) |
			  S6_COLOR_WRITE_ENABLE | (2 << S6_TRISTRIP_PV_SHIFT));

		OUT_BATCH(_3DSTATE_CONST_BLEND_COLOR_CMD);
		OUT_BATCH(0x00000000);

		OUT_BATCH(_3DSTATE_DST_BUF_VARS_CMD);
		if (intel->cpp == 2)
			format = COLR_BUF_RGB565;
		else
			format =
			    COLR_BUF_ARGB8888 | DEPTH_FRMT_24_FIXED_8_OTHER;

		OUT_BATCH(LOD_PRECLAMP_OGL |
			  DSTORG_HORT_BIAS(0x8) |
			  DSTORG_VERT_BIAS(0x8) | format);

		/* front buffer, pitch, offset */
		if (intel_pixmap_tiled(target)) {
			tiling = BUF_3D_TILED_SURFACE;
			if (intel_get_pixmap_private(target)->tiling == I915_TILING_Y)
				tiling |= BUF_3D_TILE_WALK_Y;
		} else
			tiling = 0;
		OUT_BATCH(_3DSTATE_BUF_INFO_CMD);
		OUT_BATCH(BUF_3D_ID_COLOR_BACK | tiling |
			  BUF_3D_PITCH(intel_pixmap_pitch(target)));
		OUT_RELOC_PIXMAP(target, I915_GEM_DOMAIN_RENDER,
				 I915_GEM_DOMAIN_RENDER, 0);

		if (!is_planar_fourcc(id)) {
			FS_LOCALS();

			OUT_BATCH(_3DSTATE_PIXEL_SHADER_CONSTANTS | 4);
			OUT_BATCH(0x0000001);	/* constant 0 */
			/* constant 0: brightness/contrast */
			OUT_BATCH_F(adaptor_priv->brightness / 128.0);
			OUT_BATCH_F(adaptor_priv->contrast / 255.0);
			OUT_BATCH_F(0.0);
			OUT_BATCH_F(0.0);

			OUT_BATCH(_3DSTATE_SAMPLER_STATE | 3);
			OUT_BATCH(0x00000001);
			OUT_BATCH(SS2_COLORSPACE_CONVERSION |
				  (FILTER_LINEAR << SS2_MAG_FILTER_SHIFT) |
				  (FILTER_LINEAR << SS2_MIN_FILTER_SHIFT));
			OUT_BATCH((TEXCOORDMODE_CLAMP_EDGE <<
				   SS3_TCX_ADDR_MODE_SHIFT) |
				  (TEXCOORDMODE_CLAMP_EDGE <<
				   SS3_TCY_ADDR_MODE_SHIFT) |
				  (0 << SS3_TEXTUREMAP_INDEX_SHIFT) |
				  SS3_NORMALIZED_COORDS);
			OUT_BATCH(0x00000000);

			OUT_BATCH(_3DSTATE_MAP_STATE | 3);
			OUT_BATCH(0x00000001);	/* texture map #1 */
			if (adaptor_priv->buf)
				OUT_RELOC(adaptor_priv->buf,
					  I915_GEM_DOMAIN_SAMPLER, 0,
					  adaptor_priv->YBufOffset);
			else
				OUT_BATCH(adaptor_priv->YBufOffset);

			ms3 = MAPSURF_422;
			switch (id) {
			case FOURCC_YUY2:
				ms3 |= MT_422_YCRCB_NORMAL;
				break;
			case FOURCC_UYVY:
				ms3 |= MT_422_YCRCB_SWAPY;
				break;
			}
			ms3 |= (height - 1) << MS3_HEIGHT_SHIFT;
			ms3 |= (width - 1) << MS3_WIDTH_SHIFT;
			OUT_BATCH(ms3);
			OUT_BATCH(((video_pitch / 4) - 1) << MS4_PITCH_SHIFT);

			FS_BEGIN();
			i915_fs_dcl(FS_S0);
			i915_fs_dcl(FS_T0);
			i915_fs_texld(FS_OC, FS_S0, FS_T0);
			if (adaptor_priv->brightness != 0) {
				i915_fs_add(FS_OC,
					    i915_fs_operand_reg(FS_OC),
					    i915_fs_operand(FS_C0, X, X, X,
							    ZERO));
			}
			FS_END();
		} else {
			FS_LOCALS();

			/* For the planar formats, we set up three samplers --
			 * one for each plane, in a Y8 format.  Because I
			 * couldn't get the special PLANAR_TO_PACKED
			 * shader setup to work, I did the manual pixel shader:
			 *
			 * y' = y - .0625
			 * u' = u - .5
			 * v' = v - .5;
			 *
			 * r = 1.1643 * y' + 0.0     * u' + 1.5958  * v'
			 * g = 1.1643 * y' - 0.39173 * u' - 0.81290 * v'
			 * b = 1.1643 * y' + 2.017   * u' + 0.0     * v'
			 *
			 * register assignment:
			 * r0 = (y',u',v',0)
			 * r1 = (y,y,y,y)
			 * r2 = (u,u,u,u)
			 * r3 = (v,v,v,v)
			 * OC = (r,g,b,1)
			 */
			OUT_BATCH(_3DSTATE_PIXEL_SHADER_CONSTANTS | (22 - 2));
			OUT_BATCH(0x000001f);	/* constants 0-4 */
			/* constant 0: normalization offsets */
			OUT_BATCH_F(-0.0625);
			OUT_BATCH_F(-0.5);
			OUT_BATCH_F(-0.5);
			OUT_BATCH_F(0.0);
			/* constant 1: r coefficients */
			OUT_BATCH_F(1.1643);
			OUT_BATCH_F(0.0);
			OUT_BATCH_F(1.5958);
			OUT_BATCH_F(0.0);
			/* constant 2: g coefficients */
			OUT_BATCH_F(1.1643);
			OUT_BATCH_F(-0.39173);
			OUT_BATCH_F(-0.81290);
			OUT_BATCH_F(0.0);
			/* constant 3: b coefficients */
			OUT_BATCH_F(1.1643);
			OUT_BATCH_F(2.017);
			OUT_BATCH_F(0.0);
			OUT_BATCH_F(0.0);
			/* constant 4: brightness/contrast */
			OUT_BATCH_F(adaptor_priv->brightness / 128.0);
			OUT_BATCH_F(adaptor_priv->contrast / 255.0);
			OUT_BATCH_F(0.0);
			OUT_BATCH_F(0.0);

			OUT_BATCH(_3DSTATE_SAMPLER_STATE | 9);
			OUT_BATCH(0x00000007);
			/* sampler 0 */
			OUT_BATCH((FILTER_LINEAR << SS2_MAG_FILTER_SHIFT) |
				  (FILTER_LINEAR << SS2_MIN_FILTER_SHIFT));
			OUT_BATCH((TEXCOORDMODE_CLAMP_EDGE <<
				   SS3_TCX_ADDR_MODE_SHIFT) |
				  (TEXCOORDMODE_CLAMP_EDGE <<
				   SS3_TCY_ADDR_MODE_SHIFT) |
				  (0 << SS3_TEXTUREMAP_INDEX_SHIFT) |
				  SS3_NORMALIZED_COORDS);
			OUT_BATCH(0x00000000);
			/* sampler 1 */
			OUT_BATCH((FILTER_LINEAR << SS2_MAG_FILTER_SHIFT) |
				  (FILTER_LINEAR << SS2_MIN_FILTER_SHIFT));
			OUT_BATCH((TEXCOORDMODE_CLAMP_EDGE <<
				   SS3_TCX_ADDR_MODE_SHIFT) |
				  (TEXCOORDMODE_CLAMP_EDGE <<
				   SS3_TCY_ADDR_MODE_SHIFT) |
				  (1 << SS3_TEXTUREMAP_INDEX_SHIFT) |
				  SS3_NORMALIZED_COORDS);
			OUT_BATCH(0x00000000);
			/* sampler 2 */
			OUT_BATCH((FILTER_LINEAR << SS2_MAG_FILTER_SHIFT) |
				  (FILTER_LINEAR << SS2_MIN_FILTER_SHIFT));
			OUT_BATCH((TEXCOORDMODE_CLAMP_EDGE <<
				   SS3_TCX_ADDR_MODE_SHIFT) |
				  (TEXCOORDMODE_CLAMP_EDGE <<
				   SS3_TCY_ADDR_MODE_SHIFT) |
				  (2 << SS3_TEXTUREMAP_INDEX_SHIFT) |
				  SS3_NORMALIZED_COORDS);
			OUT_BATCH(0x00000000);

			OUT_BATCH(_3DSTATE_MAP_STATE | 9);
			OUT_BATCH(0x00000007);

			if (adaptor_priv->buf)
				OUT_RELOC(adaptor_priv->buf,
					  I915_GEM_DOMAIN_SAMPLER, 0,
					  adaptor_priv->YBufOffset);
			else
				OUT_BATCH(adaptor_priv->YBufOffset);

			ms3 = MAPSURF_8BIT | MT_8BIT_I8;
			ms3 |= (height - 1) << MS3_HEIGHT_SHIFT;
			ms3 |= (width - 1) << MS3_WIDTH_SHIFT;
			OUT_BATCH(ms3);
			/* check to see if Y has special pitch than normal
			 * double u/v pitch, e.g i915 XvMC hw requires at
			 * least 1K alignment, so Y pitch might
			 * be same as U/V's.*/
			if (video_pitch2)
				OUT_BATCH(((video_pitch2 / 4) -
					   1) << MS4_PITCH_SHIFT);
			else
				OUT_BATCH(((video_pitch * 2 / 4) -
					   1) << MS4_PITCH_SHIFT);

			if (adaptor_priv->buf)
				OUT_RELOC(adaptor_priv->buf,
					  I915_GEM_DOMAIN_SAMPLER, 0,
					  adaptor_priv->UBufOffset);
			else
				OUT_BATCH(adaptor_priv->UBufOffset);

			ms3 = MAPSURF_8BIT | MT_8BIT_I8;
			ms3 |= (height / 2 - 1) << MS3_HEIGHT_SHIFT;
			ms3 |= (width / 2 - 1) << MS3_WIDTH_SHIFT;
			OUT_BATCH(ms3);
			OUT_BATCH(((video_pitch / 4) - 1) << MS4_PITCH_SHIFT);

			if (adaptor_priv->buf)
				OUT_RELOC(adaptor_priv->buf,
					  I915_GEM_DOMAIN_SAMPLER, 0,
					  adaptor_priv->VBufOffset);
			else
				OUT_BATCH(adaptor_priv->VBufOffset);

			ms3 = MAPSURF_8BIT | MT_8BIT_I8;
			ms3 |= (height / 2 - 1) << MS3_HEIGHT_SHIFT;
			ms3 |= (width / 2 - 1) << MS3_WIDTH_SHIFT;
			OUT_BATCH(ms3);
			OUT_BATCH(((video_pitch / 4) - 1) << MS4_PITCH_SHIFT);

			FS_BEGIN();
			/* Declare samplers */
			i915_fs_dcl(FS_S0);	/* Y */
			i915_fs_dcl(FS_S1);	/* U */
			i915_fs_dcl(FS_S2);	/* V */
			i915_fs_dcl(FS_T0);	/* normalized coords */

			/* Load samplers to temporaries. */
			i915_fs_texld(FS_R1, FS_S0, FS_T0);
			i915_fs_texld(FS_R2, FS_S1, FS_T0);
			i915_fs_texld(FS_R3, FS_S2, FS_T0);

			/* Move the sampled YUV data in R[123] to the first
			 * 3 channels of R0.
			 */
			i915_fs_mov_masked(FS_R0, MASK_X,
					   i915_fs_operand_reg(FS_R1));
			i915_fs_mov_masked(FS_R0, MASK_Y,
					   i915_fs_operand_reg(FS_R2));
			i915_fs_mov_masked(FS_R0, MASK_Z,
					   i915_fs_operand_reg(FS_R3));

			/* Normalize the YUV data */
			i915_fs_add(FS_R0, i915_fs_operand_reg(FS_R0),
				    i915_fs_operand_reg(FS_C0));
			/* dot-product the YUV data in R0 by the vectors of
			 * coefficients for calculating R, G, and B, storing
			 * the results in the R, G, or B channels of the output
			 * color.  The OC results are implicitly clamped
			 * at the end of the program.
			 */
			i915_fs_dp3(FS_OC, MASK_X,
				    i915_fs_operand_reg(FS_R0),
				    i915_fs_operand_reg(FS_C1));
			i915_fs_dp3(FS_OC, MASK_Y,
				    i915_fs_operand_reg(FS_R0),
				    i915_fs_operand_reg(FS_C2));
			i915_fs_dp3(FS_OC, MASK_Z,
				    i915_fs_operand_reg(FS_R0),
				    i915_fs_operand_reg(FS_C3));
			/* Set alpha of the output to 1.0, by wiring W to 1
			 * and not actually using the source.
			 */
			i915_fs_mov_masked(FS_OC, MASK_W,
					   i915_fs_operand_one());

			if (adaptor_priv->brightness != 0) {
				i915_fs_add(FS_OC,
					    i915_fs_operand_reg(FS_OC),
					    i915_fs_operand(FS_C4, X, X, X,
							    ZERO));
			}
			FS_END();
		}

		OUT_BATCH(PRIM3D_RECTLIST | (12 * nbox_this_time - 1));
		while (nbox_this_time--) {
			int box_x1 = pbox->x1;
			int box_y1 = pbox->y1;
			int box_x2 = pbox->x2;
			int box_y2 = pbox->y2;
			float src_scale_x, src_scale_y;

			pbox++;

			src_scale_x = ((float)src_w / width) / drw_w;
			src_scale_y = ((float)src_h / height) / drw_h;

			/* vertex data - rect list consists of bottom right,
			 * bottom left, and top left vertices.
			 */

			/* bottom right */
			OUT_BATCH_F(box_x2 + pix_xoff);
			OUT_BATCH_F(box_y2 + pix_yoff);
			OUT_BATCH_F((box_x2 - dxo) * src_scale_x);
			OUT_BATCH_F((box_y2 - dyo) * src_scale_y);

			/* bottom left */
			OUT_BATCH_F(box_x1 + pix_xoff);
			OUT_BATCH_F(box_y2 + pix_yoff);
			OUT_BATCH_F((box_x1 - dxo) * src_scale_x);
			OUT_BATCH_F((box_y2 - dyo) * src_scale_y);

			/* top left */
			OUT_BATCH_F(box_x1 + pix_xoff);
			OUT_BATCH_F(box_y1 + pix_yoff);
			OUT_BATCH_F((box_x1 - dxo) * src_scale_x);
			OUT_BATCH_F((box_y1 - dyo) * src_scale_y);
		}

		intel_batch_end_atomic(scrn);
	}

	if (target != pixmap) {
		GCPtr gc;

		gc = GetScratchGC(pixmap->drawable.depth,
				  pixmap->drawable.pScreen);
		if (gc) {
			gc->subWindowMode = ClipByChildren;

			if (REGION_NUM_RECTS(dstRegion) > 1) {
				RegionPtr tmp;

				tmp = REGION_CREATE(pixmap->drawable.pScreen, NULL, 0);
				if (tmp) {
					REGION_COPY(pixmap->drawable.pScreen, tmp, dstRegion);
					gc->funcs->ChangeClip(gc, CT_REGION, tmp, 0);
				}
			}

			ValidateGC(&pixmap->drawable, gc);
			gc->ops->CopyArea(&target->drawable, &pixmap->drawable, gc,
					  0, 0,
					  target->drawable.width,
					  target->drawable.height,
					  -pix_xoff, -pix_yoff);
			FreeScratchGC(gc);
		}

		target->drawable.pScreen->DestroyPixmap(target);
	}

	intel_debug_flush(scrn);
}
@


1.9
log
@Update to xf86-video-intel 2.20.19.

A recent kernel with kernel modesetting support is required.
Thanks to jsg@@ and kettenis@@ for their work.
@
text
@@


1.8
log
@Update the intel driver to a more recent version based on more recent
upsteam code.

Backporting keeping UMS changes by me, some bugfixes from kettenis@@.

Has been in snapshots for a while, committed on request so we can be
sure what people are running. This is a prerequesite for sandybridge
support but has those chipsets disabled for now until the correct code
has been added.
@
text
@d36 1
d77 2
@


1.7
log
@Update the intel driver to (mostly) a backport of 2.12.

It is missing a few commits that I have yet to verify (ones that try and
continue if we lock the gpu rendering engine and can't reset it, for
example) taht will be verified and sent out for extra testing soon.

Should contain a bunch of speedups and some correctness improvements
(though rendercheck still gives some errors that I am looking into).

This has been in snaps since the first day of c2k10, any known issues
with just this driver have (to my knowledge) been fixed since. A problem
with macbooks pointed out by otto happens with both this and the in-tree
driver and thus doesn't stop this moving forward.

As well as the 2.12 improvements, this driver also has a backport
(partially aided by the backports in RHEL 5 kindly provided by Dave
Airlie) from the kms code of modesetting support for ironlake (arrandale
and clarkdale: the IGDs build into intel nehalem cpu dies) which has
been tested on a number of chipsets. Note that Display port and eDP
displays have not yet been worked on (and probably won't until I can
find a displayport monitor), but VGA and lvds at least are known to
work, sure beats vesa.

"no objection on my side" matthieu@@, prodding (as always) from princess
marco.
@
text
@d37 2
a38 2
#include "i830.h"
#include "i830_video.h"
d72 2
a73 1
					      drw_w, drw_h,
d153 1
a153 1
		if (i830_pixmap_tiled(target)) {
d155 1
a155 1
			if (i830_get_pixmap_intel(target)->tiling == I915_TILING_Y)
d161 1
a161 1
			  BUF_3D_PITCH(intel_get_pixmap_pitch(target)));
d458 1
a458 1
			RegionPtr tmp;
d460 2
a461 1
			ValidateGC(&pixmap->drawable, gc);
a462 1
			if (REGION_NUM_RECTS(dstRegion) > 1) {
d470 1
d482 1
a482 1
	i830_debug_flush(scrn);
@


1.6
log
@Pull in the changes in rendering that I skipped when i backported
changes from later intel versions (after the UMS removal). 95% of this
is the xvmc reworks that makes that code even halfway sane. xvmc is now
enabled by default on 965+.

Tested by many on tech@@, thanks!

ok matthieu@@
@
text
@d52 1
a52 1
	uint32_t format, ms3, s5;
d57 1
d64 29
a107 7
		ATOMIC_BATCH(20);

		/* flush map & render cache */
		OUT_BATCH(MI_FLUSH | MI_WRITE_DIRTY_STATE |
			  MI_INVALIDATE_MAP_CACHE);
		OUT_BATCH(0x00000000);

d114 2
a115 2
		OUT_BATCH((pixmap->drawable.width - 1) |
			  (pixmap->drawable.height - 1) << 16);
a116 1
		OUT_BATCH(MI_NOOP);
d119 1
a119 1
			  I1_LOAD_S(4) | I1_LOAD_S(5) | I1_LOAD_S(6) | 3);
a127 2
		OUT_BATCH((1 << S4_POINT_WIDTH_SHIFT) | S4_LINE_WIDTH_ONE |
			  S4_CULLMODE_NONE | S4_VFMT_XY);
d152 6
d159 3
a161 3
		OUT_BATCH(BUF_3D_ID_COLOR_BACK | BUF_3D_USE_FENCE |
			  BUF_3D_PITCH(intel_get_pixmap_pitch(pixmap)));
		OUT_RELOC_PIXMAP(pixmap, I915_GEM_DOMAIN_RENDER,
a162 1
		ADVANCE_BATCH();
d165 1
a165 1
			FS_LOCALS(10);
a166 1
			ATOMIC_BATCH(16);
d197 1
a197 1
			ms3 = MAPSURF_422 | MS3_USE_FENCE_REGS;
a210 2
			ADVANCE_BATCH();

d223 1
a223 1
			FS_LOCALS(16);
a224 1
			ATOMIC_BATCH(22 + 11 + 11);
d316 1
a316 1
			ms3 = MAPSURF_8BIT | MT_8BIT_I8 | MS3_USE_FENCE_REGS;
d338 1
a338 1
			ms3 = MAPSURF_8BIT | MT_8BIT_I8 | MS3_USE_FENCE_REGS;
d351 1
a351 1
			ms3 = MAPSURF_8BIT | MT_8BIT_I8 | MS3_USE_FENCE_REGS;
a355 1
			ADVANCE_BATCH();
d388 9
a396 9
			i915_fs_dp3_masked(FS_OC, MASK_X,
					   i915_fs_operand_reg(FS_R0),
					   i915_fs_operand_reg(FS_C1));
			i915_fs_dp3_masked(FS_OC, MASK_Y,
					   i915_fs_operand_reg(FS_R0),
					   i915_fs_operand_reg(FS_C2));
			i915_fs_dp3_masked(FS_OC, MASK_Z,
					   i915_fs_operand_reg(FS_R0),
					   i915_fs_operand_reg(FS_C3));
d412 1
a412 22
		{
			ATOMIC_BATCH(2);
			OUT_BATCH(MI_FLUSH | MI_WRITE_DIRTY_STATE |
				  MI_INVALIDATE_MAP_CACHE);
			OUT_BATCH(0x00000000);
			ADVANCE_BATCH();
		}

		/* Set up the offset for translating from the given region
		 * (in screen coordinates) to the backing pixmap.
		 */
#ifdef COMPOSITE
		pix_xoff = -pixmap->screen_x + pixmap->drawable.x;
		pix_yoff = -pixmap->screen_y + pixmap->drawable.y;
#else
		pix_xoff = 0;
		pix_yoff = 0;
#endif

		dxo = dstRegion->extents.x1;
		dyo = dstRegion->extents.y1;

a424 9
			ATOMIC_BATCH(8 + 12);
			OUT_BATCH(MI_NOOP);
			OUT_BATCH(MI_NOOP);
			OUT_BATCH(MI_NOOP);
			OUT_BATCH(MI_NOOP);
			OUT_BATCH(MI_NOOP);
			OUT_BATCH(MI_NOOP);
			OUT_BATCH(MI_NOOP);

a427 1
			OUT_BATCH(PRIM3D_INLINE | PRIM3D_RECTLIST | (12 - 1));
d446 4
d451 24
a474 1
			ADVANCE_BATCH();
d477 1
a477 1
		intel_batch_end_atomic(scrn);
@


1.5
log
@Update the intel driver to 2.9.1 plus backports.

2.9.1 is the last version of the intel DDX that supports UMS (User
modesetting), with 2.10 onwards being purely KMS only. As such, this
driver contains backports of almost every correctness or performance
related fix to the rendering layer in later intel drivers. This driver
*REQUIRES* a GEM enabled kernel. it claims to support non-gem mode but
this is essentially unmaintained and due to the way the abstraciton
works is slow, if it works at all (it often does not). You have been
warned.

tested by many many people on tech over the last few weeks.
@
text
@d47 1
a47 1
			 int video_pitch2, int x1, int y1, int x2, int y2,
@


1.4
log
@update to xf86-video-intel 2.7.1. Tested by many.
@
text
@d43 2
a44 1
I915DisplayVideoTextured(ScrnInfoPtr pScrn, I830PortPrivPtr pPriv, int id,
d46 2
a47 2
			 short width, short height, int video_pitch, int video_pitch2,
			 int x1, int y1, int x2, int y2,
d49 1
a49 1
			 PixmapPtr pPixmap)
d51 6
a56 7
   I830Ptr pI830 = I830PTR(pScrn);
   uint32_t format, ms3, s5;
   BoxPtr pbox = REGION_RECTS(dstRegion);
   int nbox_total = REGION_NUM_RECTS(dstRegion);
   int nbox_this_time;
   int dxo, dyo, pix_xoff, pix_yoff;
   Bool planar;
d59 2
a60 2
   ErrorF("I915DisplayVideo: %dx%d (pitch %d)\n", width, height,
	  video_pitch);
a62 14
   switch (id) {
   case FOURCC_UYVY:
   case FOURCC_YUY2:
      planar = FALSE;
      break;
   case FOURCC_YV12:
   case FOURCC_I420:
      planar = TRUE;
      break;
   default:
      ErrorF("Unknown format 0x%x\n", id);
      return;
   }

d67 336
a402 288
   while (nbox_total) {
	nbox_this_time = nbox_total;
	if (BYTES_FOR_BOXES(nbox_this_time) > BATCH_BYTES(pI830))
		nbox_this_time = BOXES_IN_BYTES(BATCH_BYTES(pI830));
	nbox_total -= nbox_this_time;

   intel_batch_start_atomic(pScrn, 200 + 20 * nbox_this_time);

   IntelEmitInvarientState(pScrn);
   pI830->last_3d = LAST_3D_VIDEO;

   BEGIN_BATCH(20);

   /* flush map & render cache */
   OUT_BATCH(MI_FLUSH | MI_WRITE_DIRTY_STATE | MI_INVALIDATE_MAP_CACHE);
   OUT_BATCH(0x00000000);

   /* draw rect -- just clipping */
   OUT_BATCH(_3DSTATE_DRAW_RECT_CMD);
   OUT_BATCH(DRAW_DITHER_OFS_X(pPixmap->drawable.x & 3) |
	     DRAW_DITHER_OFS_Y(pPixmap->drawable.y & 3));
   OUT_BATCH(0x00000000);	/* ymin, xmin */
   OUT_BATCH((pPixmap->drawable.width - 1) |
	     (pPixmap->drawable.height - 1) << 16); /* ymax, xmax */
   OUT_BATCH(0x00000000);	/* yorigin, xorigin */
   OUT_BATCH(MI_NOOP);

   OUT_BATCH(_3DSTATE_LOAD_STATE_IMMEDIATE_1 | I1_LOAD_S(2) |
	     I1_LOAD_S(4) | I1_LOAD_S(5) | I1_LOAD_S(6) | 3);
   OUT_BATCH(S2_TEXCOORD_FMT(0, TEXCOORDFMT_2D) |
	     S2_TEXCOORD_FMT(1, TEXCOORDFMT_NOT_PRESENT) |
	     S2_TEXCOORD_FMT(2, TEXCOORDFMT_NOT_PRESENT) |
	     S2_TEXCOORD_FMT(3, TEXCOORDFMT_NOT_PRESENT) |
	     S2_TEXCOORD_FMT(4, TEXCOORDFMT_NOT_PRESENT) |
	     S2_TEXCOORD_FMT(5, TEXCOORDFMT_NOT_PRESENT) |
	     S2_TEXCOORD_FMT(6, TEXCOORDFMT_NOT_PRESENT) |
	     S2_TEXCOORD_FMT(7, TEXCOORDFMT_NOT_PRESENT));
   OUT_BATCH((1 << S4_POINT_WIDTH_SHIFT) | S4_LINE_WIDTH_ONE |
	     S4_CULLMODE_NONE | S4_VFMT_XY);
   s5 = 0x0;
   if (pI830->cpp == 2)
      s5 |= S5_COLOR_DITHER_ENABLE;
   OUT_BATCH(s5); /* S5 - enable bits */
   OUT_BATCH((2 << S6_DEPTH_TEST_FUNC_SHIFT) |
	     (2 << S6_CBUF_SRC_BLEND_FACT_SHIFT) |
	     (1 << S6_CBUF_DST_BLEND_FACT_SHIFT) | S6_COLOR_WRITE_ENABLE |
	     (2 << S6_TRISTRIP_PV_SHIFT));

   OUT_BATCH(_3DSTATE_CONST_BLEND_COLOR_CMD);
   OUT_BATCH(0x00000000);

   OUT_BATCH(_3DSTATE_DST_BUF_VARS_CMD);
   if (pI830->cpp == 2)
      format = COLR_BUF_RGB565;
   else
      format = COLR_BUF_ARGB8888 | DEPTH_FRMT_24_FIXED_8_OTHER;

   OUT_BATCH(LOD_PRECLAMP_OGL |
	     DSTORG_HORT_BIAS(0x80) |
	     DSTORG_VERT_BIAS(0x80) |
	     format);

   /* front buffer, pitch, offset */
   OUT_BATCH(_3DSTATE_BUF_INFO_CMD);
   OUT_BATCH(BUF_3D_ID_COLOR_BACK | BUF_3D_USE_FENCE |
	     BUF_3D_PITCH(intel_get_pixmap_pitch(pPixmap)));
   OUT_RELOC_PIXMAP(pPixmap, I915_GEM_DOMAIN_RENDER, I915_GEM_DOMAIN_RENDER, 0);
   ADVANCE_BATCH();

   if (!planar) {
      FS_LOCALS(10);

      BEGIN_BATCH(16);
      OUT_BATCH(_3DSTATE_PIXEL_SHADER_CONSTANTS | 4);
      OUT_BATCH(0x0000001);	/* constant 0 */
      /* constant 0: brightness/contrast */
      OUT_BATCH_F(pPriv->brightness / 128.0);
      OUT_BATCH_F(pPriv->contrast / 255.0);
      OUT_BATCH_F(0.0);
      OUT_BATCH_F(0.0);

      OUT_BATCH(_3DSTATE_SAMPLER_STATE | 3);
      OUT_BATCH(0x00000001);
      OUT_BATCH(SS2_COLORSPACE_CONVERSION |
		(FILTER_LINEAR << SS2_MAG_FILTER_SHIFT) |
		(FILTER_LINEAR << SS2_MIN_FILTER_SHIFT));
      OUT_BATCH((TEXCOORDMODE_CLAMP_EDGE << SS3_TCX_ADDR_MODE_SHIFT) |
		(TEXCOORDMODE_CLAMP_EDGE << SS3_TCY_ADDR_MODE_SHIFT) |
		(0 << SS3_TEXTUREMAP_INDEX_SHIFT) |
		SS3_NORMALIZED_COORDS);
      OUT_BATCH(0x00000000);

      OUT_BATCH(_3DSTATE_MAP_STATE | 3);
      OUT_BATCH(0x00000001);	/* texture map #1 */
      OUT_RELOC(pPriv->buf, I915_GEM_DOMAIN_SAMPLER, 0, pPriv->YBuf0offset);

      ms3 = MAPSURF_422 | MS3_USE_FENCE_REGS;
      switch (id) {
      case FOURCC_YUY2:
	 ms3 |= MT_422_YCRCB_NORMAL;
	 break;
      case FOURCC_UYVY:
	 ms3 |= MT_422_YCRCB_SWAPY;
	 break;
      }
      ms3 |= (height - 1) << MS3_HEIGHT_SHIFT;
      ms3 |= (width - 1) << MS3_WIDTH_SHIFT;
      OUT_BATCH(ms3);
      OUT_BATCH(((video_pitch / 4) - 1) << MS4_PITCH_SHIFT);

      ADVANCE_BATCH();

      FS_BEGIN();
      i915_fs_dcl(FS_S0);
      i915_fs_dcl(FS_T0);
      i915_fs_texld(FS_OC, FS_S0, FS_T0);
      if (pPriv->brightness != 0) {
	  i915_fs_add(FS_OC,
		      i915_fs_operand_reg(FS_OC),
		      i915_fs_operand(FS_C0, X, X, X, ZERO));
      }
      FS_END();
   } else {
      FS_LOCALS(16);

      BEGIN_BATCH(22 + 11 + 11);
      /* For the planar formats, we set up three samplers -- one for each plane,
       * in a Y8 format.  Because I couldn't get the special PLANAR_TO_PACKED
       * shader setup to work, I did the manual pixel shader:
       *
       * y' = y - .0625
       * u' = u - .5
       * v' = v - .5;
       *
       * r = 1.1643 * y' + 0.0     * u' + 1.5958  * v'
       * g = 1.1643 * y' - 0.39173 * u' - 0.81290 * v'
       * b = 1.1643 * y' + 2.017   * u' + 0.0     * v'
       *
       * register assignment:
       * r0 = (y',u',v',0)
       * r1 = (y,y,y,y)
       * r2 = (u,u,u,u)
       * r3 = (v,v,v,v)
       * OC = (r,g,b,1)
       */
      OUT_BATCH(_3DSTATE_PIXEL_SHADER_CONSTANTS | (22 - 2));
      OUT_BATCH(0x000001f);	/* constants 0-4 */
      /* constant 0: normalization offsets */
      OUT_BATCH_F(-0.0625);
      OUT_BATCH_F(-0.5);
      OUT_BATCH_F(-0.5);
      OUT_BATCH_F(0.0);
      /* constant 1: r coefficients*/
      OUT_BATCH_F(1.1643);
      OUT_BATCH_F(0.0);
      OUT_BATCH_F(1.5958);
      OUT_BATCH_F(0.0);
      /* constant 2: g coefficients */
      OUT_BATCH_F(1.1643);
      OUT_BATCH_F(-0.39173);
      OUT_BATCH_F(-0.81290);
      OUT_BATCH_F(0.0);
      /* constant 3: b coefficients */
      OUT_BATCH_F(1.1643);
      OUT_BATCH_F(2.017);
      OUT_BATCH_F(0.0);
      OUT_BATCH_F(0.0);
      /* constant 4: brightness/contrast */
      OUT_BATCH_F(pPriv->brightness / 128.0);
      OUT_BATCH_F(pPriv->contrast / 255.0);
      OUT_BATCH_F(0.0);
      OUT_BATCH_F(0.0);

      OUT_BATCH(_3DSTATE_SAMPLER_STATE | 9);
      OUT_BATCH(0x00000007);
      /* sampler 0 */
      OUT_BATCH((FILTER_LINEAR << SS2_MAG_FILTER_SHIFT) |
	       (FILTER_LINEAR << SS2_MIN_FILTER_SHIFT));
      OUT_BATCH((TEXCOORDMODE_CLAMP_EDGE << SS3_TCX_ADDR_MODE_SHIFT) |
	       (TEXCOORDMODE_CLAMP_EDGE << SS3_TCY_ADDR_MODE_SHIFT) |
	       (0 << SS3_TEXTUREMAP_INDEX_SHIFT) |
	       SS3_NORMALIZED_COORDS);
      OUT_BATCH(0x00000000);
      /* sampler 1 */
      OUT_BATCH((FILTER_LINEAR << SS2_MAG_FILTER_SHIFT) |
	       (FILTER_LINEAR << SS2_MIN_FILTER_SHIFT));
      OUT_BATCH((TEXCOORDMODE_CLAMP_EDGE << SS3_TCX_ADDR_MODE_SHIFT) |
	       (TEXCOORDMODE_CLAMP_EDGE << SS3_TCY_ADDR_MODE_SHIFT) |
	       (1 << SS3_TEXTUREMAP_INDEX_SHIFT) |
	       SS3_NORMALIZED_COORDS);
      OUT_BATCH(0x00000000);
      /* sampler 2 */
      OUT_BATCH((FILTER_LINEAR << SS2_MAG_FILTER_SHIFT) |
		(FILTER_LINEAR << SS2_MIN_FILTER_SHIFT));
      OUT_BATCH((TEXCOORDMODE_CLAMP_EDGE << SS3_TCX_ADDR_MODE_SHIFT) |
		(TEXCOORDMODE_CLAMP_EDGE << SS3_TCY_ADDR_MODE_SHIFT) |
		(2 << SS3_TEXTUREMAP_INDEX_SHIFT) |
		SS3_NORMALIZED_COORDS);
      OUT_BATCH(0x00000000);

      OUT_BATCH(_3DSTATE_MAP_STATE | 9);
      OUT_BATCH(0x00000007);

      OUT_RELOC(pPriv->buf, I915_GEM_DOMAIN_SAMPLER, 0, pPriv->YBuf0offset);
      ms3 = MAPSURF_8BIT | MT_8BIT_I8 | MS3_USE_FENCE_REGS;
      ms3 |= (height - 1) << MS3_HEIGHT_SHIFT;
      ms3 |= (width - 1) << MS3_WIDTH_SHIFT;
      OUT_BATCH(ms3);
      /* check to see if Y has special pitch than normal double u/v pitch,
       * e.g i915 XvMC hw requires at least 1K alignment, so Y pitch might
       * be same as U/V's.*/
      if (video_pitch2)
	  OUT_BATCH(((video_pitch2 / 4) - 1) << MS4_PITCH_SHIFT);
      else
	  OUT_BATCH(((video_pitch * 2 / 4) - 1) << MS4_PITCH_SHIFT);

      OUT_RELOC(pPriv->buf, I915_GEM_DOMAIN_SAMPLER, 0, pPriv->UBuf0offset);
      ms3 = MAPSURF_8BIT | MT_8BIT_I8 | MS3_USE_FENCE_REGS;
      ms3 |= (height / 2 - 1) << MS3_HEIGHT_SHIFT;
      ms3 |= (width / 2 - 1) << MS3_WIDTH_SHIFT;
      OUT_BATCH(ms3);
      OUT_BATCH(((video_pitch / 4) - 1) << MS4_PITCH_SHIFT);

      OUT_RELOC(pPriv->buf, I915_GEM_DOMAIN_SAMPLER, 0, pPriv->VBuf0offset);
      ms3 = MAPSURF_8BIT | MT_8BIT_I8 | MS3_USE_FENCE_REGS;
      ms3 |= (height / 2 - 1) << MS3_HEIGHT_SHIFT;
      ms3 |= (width / 2 - 1) << MS3_WIDTH_SHIFT;
      OUT_BATCH(ms3);
      OUT_BATCH(((video_pitch / 4) - 1) << MS4_PITCH_SHIFT);
      ADVANCE_BATCH();

      FS_BEGIN();
      /* Declare samplers */
      i915_fs_dcl(FS_S0); /* Y */
      i915_fs_dcl(FS_S1); /* U */
      i915_fs_dcl(FS_S2); /* V */
      i915_fs_dcl(FS_T0); /* normalized coords */

      /* Load samplers to temporaries. */
      i915_fs_texld(FS_R1, FS_S0, FS_T0);
      i915_fs_texld(FS_R2, FS_S1, FS_T0);
      i915_fs_texld(FS_R3, FS_S2, FS_T0);

      /* Move the sampled YUV data in R[123] to the first 3 channels of R0. */
      i915_fs_mov_masked(FS_R0, MASK_X, i915_fs_operand_reg(FS_R1));
      i915_fs_mov_masked(FS_R0, MASK_Y, i915_fs_operand_reg(FS_R2));
      i915_fs_mov_masked(FS_R0, MASK_Z, i915_fs_operand_reg(FS_R3));

      /* Normalize the YUV data */
      i915_fs_add(FS_R0, i915_fs_operand_reg(FS_R0),
                 i915_fs_operand_reg(FS_C0));
      /* dot-product the YUV data in R0 by the vectors of coefficients for
       * calculating R, G, and B, storing the results in the R, G, or B
       * channels of the output color.  The OC results are implicitly clamped
       * at the end of the program.
       */
      i915_fs_dp3_masked(FS_OC, MASK_X,
                        i915_fs_operand_reg(FS_R0),
                        i915_fs_operand_reg(FS_C1));
      i915_fs_dp3_masked(FS_OC, MASK_Y,
                        i915_fs_operand_reg(FS_R0),
                        i915_fs_operand_reg(FS_C2));
      i915_fs_dp3_masked(FS_OC, MASK_Z,
                        i915_fs_operand_reg(FS_R0),
                        i915_fs_operand_reg(FS_C3));
      /* Set alpha of the output to 1.0, by wiring W to 1 and not actually using
       * the source.
       */
      i915_fs_mov_masked(FS_OC, MASK_W, i915_fs_operand_one());

      if (pPriv->brightness != 0) {
	  i915_fs_add(FS_OC,
		      i915_fs_operand_reg(FS_OC),
		      i915_fs_operand(FS_C4, X, X, X, ZERO));
      }
      FS_END();
   }
   
   {
      BEGIN_BATCH(2);
      OUT_BATCH(MI_FLUSH | MI_WRITE_DIRTY_STATE | MI_INVALIDATE_MAP_CACHE);
      OUT_BATCH(0x00000000);
      ADVANCE_BATCH();
   }

   /* Set up the offset for translating from the given region (in screen
    * coordinates) to the backing pixmap.
    */
d404 2
a405 2
   pix_xoff = -pPixmap->screen_x + pPixmap->drawable.x;
   pix_yoff = -pPixmap->screen_y + pPixmap->drawable.y;
d407 2
a408 2
   pix_xoff = 0;
   pix_yoff = 0;
d411 2
a412 2
   dxo = dstRegion->extents.x1;
   dyo = dstRegion->extents.y1;
d414 43
a456 44
   while (nbox_this_time--)
   {
      int box_x1 = pbox->x1;
      int box_y1 = pbox->y1;
      int box_x2 = pbox->x2;
      int box_y2 = pbox->y2;
      float src_scale_x, src_scale_y;

      pbox++;

      src_scale_x = ((float)src_w / width) / drw_w;
      src_scale_y  = ((float)src_h / height) / drw_h;

      BEGIN_BATCH(8 + 12);
      OUT_BATCH(MI_NOOP);
      OUT_BATCH(MI_NOOP);
      OUT_BATCH(MI_NOOP);
      OUT_BATCH(MI_NOOP);
      OUT_BATCH(MI_NOOP);
      OUT_BATCH(MI_NOOP);
      OUT_BATCH(MI_NOOP);

      /* vertex data - rect list consists of bottom right, bottom left, and top
       * left vertices.
       */
      OUT_BATCH(PRIM3D_INLINE | PRIM3D_RECTLIST | (12 - 1));

      /* bottom right */
      OUT_BATCH_F(box_x2 + pix_xoff);
      OUT_BATCH_F(box_y2 + pix_yoff);
      OUT_BATCH_F((box_x2 - dxo) * src_scale_x);
      OUT_BATCH_F((box_y2 - dyo) * src_scale_y);

      /* bottom left */
      OUT_BATCH_F(box_x1 + pix_xoff);
      OUT_BATCH_F(box_y2 + pix_yoff);
      OUT_BATCH_F((box_x1 - dxo) * src_scale_x);
      OUT_BATCH_F((box_y2 - dyo) * src_scale_y);

      /* top left */
      OUT_BATCH_F(box_x1 + pix_xoff);
      OUT_BATCH_F(box_y1 + pix_yoff);
      OUT_BATCH_F((box_x1 - dxo) * src_scale_x);
      OUT_BATCH_F((box_y1 - dyo) * src_scale_y);
d458 2
a459 2
      ADVANCE_BATCH();
   }
d461 2
a462 2
   intel_batch_end_atomic(pScrn);
   }
d464 1
a464 1
   i830MarkSync(pScrn);
a465 1

@


1.3
log
@xf86-video-intel 2.4.2. Has been in snapshots for weeks. Ok oga@@.
@
text
@d52 4
a55 2
   BoxPtr pbox;
   int nbox, dxo, dyo, pix_xoff, pix_yoff;
d77 12
d90 1
a90 1
   *pI830->last_3d = LAST_3D_VIDEO;
d147 1
a147 1
   OUT_BATCH(BUF_3D_ADDR(intel_get_pixmap_offset(pPixmap)));
d175 2
a176 1
      OUT_BATCH(pPriv->YBuf0offset);
d284 1
a284 1
      OUT_BATCH(pPriv->YBuf0offset);
d297 1
a297 1
      OUT_BATCH(pPriv->UBuf0offset);
d304 1
a304 1
      OUT_BATCH(pPriv->VBuf0offset);
d380 1
a380 3
   pbox = REGION_RECTS(dstRegion);
   nbox = REGION_NUM_RECTS(dstRegion);
   while (nbox--)
d426 3
@


1.2
log
@Update to xf86-video-intel 2.3.1. Tested by many.
@
text
@d45 1
a45 1
			 short width, short height, int video_pitch,
d274 7
a280 1
      OUT_BATCH(((video_pitch * 2 / 4) - 1) << MS4_PITCH_SHIFT);
@


1.1
log
@Initial revision
@
text
@a41 12
union intfloat {
   CARD32 ui;
   float f;
};

#define OUT_RING_F(x) do {						\
   union intfloat _tmp;							\
   _tmp.f = x;								\
   OUT_RING(_tmp.ui);							\
} while (0)


d48 1
a48 1
			 DrawablePtr pDraw)
d51 1
a51 1
   CARD32 format, ms3, s2;
d53 1
a53 1
   int nbox, dxo, dyo;
d56 1
d59 1
d72 1
a72 2
      planar = FALSE;
      break;
d75 2
a76 16
   /* Tell the rotation code that we have stomped its invariant state by
    * setting a high bit.  We don't use any invariant 3D state for video, so we
    * don't have to worry about it ourselves.
    */
   *pI830->used3D |= 1 << 30;

   BEGIN_LP_RING(44);

   /* invarient state */
   OUT_RING(MI_NOOP);
   OUT_RING(_3DSTATE_AA_CMD |
	    AA_LINE_ECAAR_WIDTH_ENABLE | AA_LINE_ECAAR_WIDTH_1_0 |
	    AA_LINE_REGION_WIDTH_ENABLE | AA_LINE_REGION_WIDTH_1_0);

   OUT_RING(_3DSTATE_DFLT_DIFFUSE_CMD);
   OUT_RING(0x00000000);
d78 1
a78 18
   OUT_RING(_3DSTATE_DFLT_SPEC_CMD);
   OUT_RING(0x00000000);

   OUT_RING(_3DSTATE_DFLT_Z_CMD);
   OUT_RING(0x00000000);

   OUT_RING(_3DSTATE_COORD_SET_BINDINGS | CSB_TCB(0, 0) | CSB_TCB(1, 1) |
	    CSB_TCB(2,2) | CSB_TCB(3,3) | CSB_TCB(4,4) | CSB_TCB(5,5) |
	    CSB_TCB(6,6) | CSB_TCB(7,7));

   OUT_RING(_3DSTATE_RASTER_RULES_CMD |
	    ENABLE_TRI_FAN_PROVOKE_VRTX | TRI_FAN_PROVOKE_VRTX(2) |
	    ENABLE_LINE_STRIP_PROVOKE_VRTX | LINE_STRIP_PROVOKE_VRTX(1) |
	    ENABLE_TEXKILL_3D_4D | TEXKILL_4D |
	    ENABLE_POINT_RASTER_RULE | OGL_POINT_RASTER_RULE);

   OUT_RING(_3DSTATE_LOAD_STATE_IMMEDIATE_1 | I1_LOAD_S(3) | 1);
   OUT_RING(0x00000000); /* texture coordinate wrap */
d81 2
a82 2
   OUT_RING(MI_FLUSH | MI_WRITE_DIRTY_STATE | MI_INVALIDATE_MAP_CACHE);
   OUT_RING(0x00000000);
d85 29
a113 52
   OUT_RING(_3DSTATE_DRAW_RECT_CMD);
   OUT_RING(0x00000000);	/* flags */
   OUT_RING(0x00000000);	/* ymin, xmin */
   OUT_RING((pScrn->virtualX - 1) |
	    (pScrn->virtualY - 1) << 16); /* ymax, xmax */
   OUT_RING(0x00000000);	/* yorigin, xorigin */
   OUT_RING(MI_NOOP);

   /* scissor */
   OUT_RING(_3DSTATE_SCISSOR_ENABLE_CMD | DISABLE_SCISSOR_RECT);
   OUT_RING(_3DSTATE_SCISSOR_RECT_0_CMD);
   OUT_RING(0x00000000);	/* ymin, xmin */
   OUT_RING(0x00000000);	/* ymax, xmax */

   OUT_RING(0x7c000003);	/* unknown command */
   OUT_RING(0x7d070000);
   OUT_RING(0x00000000);
   OUT_RING(0x68000002);

   /* context setup */
   OUT_RING(_3DSTATE_MODES_4_CMD |
	    ENABLE_LOGIC_OP_FUNC | LOGIC_OP_FUNC(LOGICOP_COPY) |
	    ENABLE_STENCIL_WRITE_MASK | STENCIL_WRITE_MASK(0xff) |
	    ENABLE_STENCIL_TEST_MASK | STENCIL_TEST_MASK(0xff));

   OUT_RING(_3DSTATE_LOAD_STATE_IMMEDIATE_1 | I1_LOAD_S(2) |
	    I1_LOAD_S(4) | I1_LOAD_S(5) | I1_LOAD_S(6) | 4);
   s2 = S2_TEXCOORD_FMT(0, TEXCOORDFMT_2D);
   if (planar)
      s2 |= S2_TEXCOORD_FMT(1, TEXCOORDFMT_2D);
   else
      s2 |= S2_TEXCOORD_FMT(1, TEXCOORDFMT_NOT_PRESENT);
   s2 |= S2_TEXCOORD_FMT(2, TEXCOORDFMT_NOT_PRESENT) |
      S2_TEXCOORD_FMT(3, TEXCOORDFMT_NOT_PRESENT) |
      S2_TEXCOORD_FMT(4, TEXCOORDFMT_NOT_PRESENT) |
      S2_TEXCOORD_FMT(5, TEXCOORDFMT_NOT_PRESENT) |
      S2_TEXCOORD_FMT(6, TEXCOORDFMT_NOT_PRESENT) |
      S2_TEXCOORD_FMT(7, TEXCOORDFMT_NOT_PRESENT);
   OUT_RING(s2);
   OUT_RING((1 << S4_POINT_WIDTH_SHIFT) | S4_LINE_WIDTH_ONE |
	    S4_CULLMODE_NONE | S4_VFMT_XY);
   OUT_RING(0x00000000); /* S5 - enable bits */
   OUT_RING((2 << S6_DEPTH_TEST_FUNC_SHIFT) |
	    (2 << S6_CBUF_SRC_BLEND_FACT_SHIFT) |
	    (1 << S6_CBUF_DST_BLEND_FACT_SHIFT) | S6_COLOR_WRITE_ENABLE |
	    (2 << S6_TRISTRIP_PV_SHIFT));

   OUT_RING(_3DSTATE_INDEPENDENT_ALPHA_BLEND_CMD |
	    IAB_MODIFY_ENABLE |
	    IAB_MODIFY_FUNC | (BLENDFUNC_ADD << IAB_FUNC_SHIFT) |
	    IAB_MODIFY_SRC_FACTOR | (BLENDFACT_ONE << IAB_SRC_FACTOR_SHIFT) |
	    IAB_MODIFY_DST_FACTOR | (BLENDFACT_ZERO << IAB_DST_FACTOR_SHIFT));
d115 2
a116 2
   OUT_RING(_3DSTATE_CONST_BLEND_COLOR_CMD);
   OUT_RING(0x00000000);
d118 1
a118 1
   OUT_RING(_3DSTATE_DST_BUF_VARS_CMD);
d124 4
a127 5
   OUT_RING(LOD_PRECLAMP_OGL |
     DSTORG_HORT_BIAS(0x80) | DSTORG_VERT_BIAS(0x80) | format);

   OUT_RING(_3DSTATE_STIPPLE);
   OUT_RING(0x00000000);
d130 5
a134 5
   OUT_RING(_3DSTATE_BUF_INFO_CMD);
   OUT_RING(BUF_3D_ID_COLOR_BACK | BUF_3D_USE_FENCE |
	    (((pI830->displayWidth * pI830->cpp) / 4) << 2));
   OUT_RING(pI830->bufferOffset);
   ADVANCE_LP_RING();
d137 1
a137 1
      FS_LOCALS(3);
d139 24
a162 14
      BEGIN_LP_RING(10);
      OUT_RING(_3DSTATE_SAMPLER_STATE | 3);
      OUT_RING(0x00000001);
      OUT_RING(SS2_COLORSPACE_CONVERSION |
	       (FILTER_LINEAR << SS2_MAG_FILTER_SHIFT) |
	       (FILTER_LINEAR << SS2_MIN_FILTER_SHIFT));
      OUT_RING((TEXCOORDMODE_CLAMP_EDGE << SS3_TCX_ADDR_MODE_SHIFT) |
	       (TEXCOORDMODE_CLAMP_EDGE << SS3_TCY_ADDR_MODE_SHIFT));
      OUT_RING(0x00000000);

      OUT_RING(_3DSTATE_MAP_STATE | 3);
      OUT_RING(0x00000001);	/* texture map #1 */
      OUT_RING(pPriv->YBuf0offset);
      ms3 = MAPSURF_422;
d173 4
a176 5
      if (!pI830->disableTiling)
	 ms3 |= MS3_USE_FENCE_REGS;
      OUT_RING(ms3);
      OUT_RING(((video_pitch / 4) - 1) << 21);
      ADVANCE_LP_RING();
d182 5
d191 1
a191 2
      BEGIN_LP_RING(1 + 18 + 11 + 11);
      OUT_RING(MI_NOOP);
d211 2
a212 2
      OUT_RING(_3DSTATE_PIXEL_SHADER_CONSTANTS | 16);
      OUT_RING(0x000000f);	/* constants 0-3 */
d214 4
a217 4
      OUT_RING_F(-0.0625);
      OUT_RING_F(-0.5);
      OUT_RING_F(-0.5);
      OUT_RING_F(0.0);
d219 4
a222 4
      OUT_RING_F(1.1643);
      OUT_RING_F(0.0);
      OUT_RING_F(1.5958);
      OUT_RING_F(0.0);
d224 4
a227 4
      OUT_RING_F(1.1643);
      OUT_RING_F(-0.39173);
      OUT_RING_F(-0.81290);
      OUT_RING_F(0.0);
d229 9
a237 4
      OUT_RING_F(1.1643);
      OUT_RING_F(2.017);
      OUT_RING_F(0.0);
      OUT_RING_F(0.0);
d239 2
a240 2
      OUT_RING(_3DSTATE_SAMPLER_STATE | 9);
      OUT_RING(0x00000007);
d242 1
a242 2
      OUT_RING(0x00000000);
      OUT_RING((FILTER_LINEAR << SS2_MAG_FILTER_SHIFT) |
d244 5
a248 2
      OUT_RING((TEXCOORDMODE_CLAMP_EDGE << SS3_TCX_ADDR_MODE_SHIFT) |
	       (TEXCOORDMODE_CLAMP_EDGE << SS3_TCY_ADDR_MODE_SHIFT));
d250 1
a250 2
      OUT_RING(0x00000000);
      OUT_RING((FILTER_LINEAR << SS2_MAG_FILTER_SHIFT) |
d252 5
a256 2
      OUT_RING((TEXCOORDMODE_CLAMP_EDGE << SS3_TCX_ADDR_MODE_SHIFT) |
	       (TEXCOORDMODE_CLAMP_EDGE << SS3_TCY_ADDR_MODE_SHIFT));
d258 7
a264 5
      OUT_RING(0x00000000);
      OUT_RING((FILTER_LINEAR << SS2_MAG_FILTER_SHIFT) |
	       (FILTER_LINEAR << SS2_MIN_FILTER_SHIFT));
      OUT_RING((TEXCOORDMODE_CLAMP_EDGE << SS3_TCX_ADDR_MODE_SHIFT) |
	       (TEXCOORDMODE_CLAMP_EDGE << SS3_TCY_ADDR_MODE_SHIFT));
d266 2
a267 2
      OUT_RING(_3DSTATE_MAP_STATE | 9);
      OUT_RING(0x00000007);
d269 2
a270 2
      OUT_RING(pPriv->YBuf0offset);
      ms3 = MAPSURF_8BIT | MT_8BIT_I8;
d273 2
a274 2
      OUT_RING(ms3);
      OUT_RING(((video_pitch * 2 / 4) - 1) << 21);
d276 2
a277 2
      OUT_RING(pPriv->UBuf0offset);
      ms3 = MAPSURF_8BIT | MT_8BIT_I8;
d280 2
a281 2
      OUT_RING(ms3);
      OUT_RING(((video_pitch / 4) - 1) << 21);
d283 2
a284 2
      OUT_RING(pPriv->VBuf0offset);
      ms3 = MAPSURF_8BIT | MT_8BIT_I8;
d287 3
a289 3
      OUT_RING(ms3);
      OUT_RING(((video_pitch / 4) - 1) << 21);
      ADVANCE_LP_RING();
d293 4
a296 5
      i915_fs_dcl(FS_S0);
      i915_fs_dcl(FS_S1);
      i915_fs_dcl(FS_S2);
      i915_fs_dcl(FS_T0);
      i915_fs_dcl(FS_T1);
d298 2
a299 4
      /* Load samplers to temporaries.  Y (sampler 0) gets the un-halved coords-
       * from t1.
       */
      i915_fs_texld(FS_R1, FS_S0, FS_T1);
d312 3
a314 2
       * calculating R, G, and B, storing the results in the R, G, or B channels
       * of the output color.
d316 1
a316 1
      i915_fs_dp3_masked(FS_OC, MASK_X | MASK_SATURATE,
d319 1
a319 1
      i915_fs_dp3_masked(FS_OC, MASK_Y | MASK_SATURATE,
d322 1
a322 1
      i915_fs_dp3_masked(FS_OC, MASK_Z | MASK_SATURATE,
d329 6
d339 4
a342 4
      BEGIN_LP_RING(2);
      OUT_RING(MI_FLUSH | MI_WRITE_DIRTY_STATE | MI_INVALIDATE_MAP_CACHE);
      OUT_RING(0x00000000);
      ADVANCE_LP_RING();
d345 11
a367 1
      int vert_data_count;
d371 2
a372 2
      src_scale_x = (float)src_w / (float)drw_w;
      src_scale_y  = (float)src_h / (float)drw_h;
d374 8
a381 13
      if (!planar)
	 vert_data_count = 12;
      else
	 vert_data_count = 18;

      BEGIN_LP_RING(vert_data_count + 8);
      OUT_RING(MI_NOOP);
      OUT_RING(MI_NOOP);
      OUT_RING(MI_NOOP);
      OUT_RING(MI_NOOP);
      OUT_RING(MI_NOOP);
      OUT_RING(MI_NOOP);
      OUT_RING(MI_NOOP);
d386 1
a386 2
      OUT_RING(PRIM3D_INLINE | PRIM3D_RECTLIST |
	       (vert_data_count - 1));
d389 4
a392 11
      OUT_RING_F(box_x2);
      OUT_RING_F(box_y2);
      if (!planar) {
	 OUT_RING_F((box_x2 - dxo) * src_scale_x);
	 OUT_RING_F((box_y2 - dyo) * src_scale_y);
      } else {
	 OUT_RING_F((box_x2 - dxo) * src_scale_x / 2.0);
	 OUT_RING_F((box_y2 - dyo) * src_scale_y / 2.0);
	 OUT_RING_F((box_x2 - dxo) * src_scale_x);
	 OUT_RING_F((box_y2 - dyo) * src_scale_y);
      }
d395 4
a398 11
      OUT_RING_F(box_x1);
      OUT_RING_F(box_y2);
      if (!planar) {
	 OUT_RING_F((box_x1 - dxo) * src_scale_x);
	 OUT_RING_F((box_y2 - dyo) * src_scale_y);
      } else {
	 OUT_RING_F((box_x1 - dxo) * src_scale_x / 2.0);
	 OUT_RING_F((box_y2 - dyo) * src_scale_y / 2.0);
	 OUT_RING_F((box_x1 - dxo) * src_scale_x);
	 OUT_RING_F((box_y2 - dyo) * src_scale_y);
      }
d401 4
a404 11
      OUT_RING_F(box_x1);
      OUT_RING_F(box_y1);
      if (!planar) {
	 OUT_RING_F((box_x1 - dxo) * src_scale_x);
	 OUT_RING_F((box_y1 - dyo) * src_scale_y);
      } else {
	 OUT_RING_F((box_x1 - dxo) * src_scale_x / 2.0);
	 OUT_RING_F((box_y1 - dyo) * src_scale_y / 2.0);
	 OUT_RING_F((box_x1 - dxo) * src_scale_x);
	 OUT_RING_F((box_y1 - dyo) * src_scale_y);
      }
d406 1
a406 1
      ADVANCE_LP_RING();
d409 1
a409 2
   if (pI830->AccelInfoRec)
      pI830->AccelInfoRec->NeedToSync = TRUE;
@


1.1.1.1
log
@Importing xf86-video-i810 1.7.2
@
text
@@


1.1.1.2
log
@xf86-video-intel 1.7.3
@
text
@a67 1
#if 0
a69 1
#endif
a80 1
#if 0
a81 1
#endif
@


1.1.1.3
log
@xf86-video-intel 2.2.0
@
text
@d42 12
d60 1
a60 1
			 PixmapPtr pPixmap)
d63 1
a63 1
   CARD32 format, ms3, s5;
d65 1
a65 1
   int nbox, dxo, dyo, pix_xoff, pix_yoff;
d83 1
d85 3
a87 1
      return;
d90 32
a121 2
   IntelEmitInvarientState(pScrn);
   *pI830->last_3d = LAST_3D_VIDEO;
d123 2
a124 1
   BEGIN_LP_RING(20);
d132 1
a132 2
   OUT_RING(DRAW_DITHER_OFS_X(pPixmap->drawable.x & 3) |
	    DRAW_DITHER_OFS_Y(pPixmap->drawable.y & 3));
d134 2
a135 2
   OUT_RING((pPixmap->drawable.width - 1) |
	    (pPixmap->drawable.height - 1) << 16); /* ymax, xmax */
d139 17
d157 13
a169 9
	    I1_LOAD_S(4) | I1_LOAD_S(5) | I1_LOAD_S(6) | 3);
   OUT_RING(S2_TEXCOORD_FMT(0, TEXCOORDFMT_2D) |
	    S2_TEXCOORD_FMT(1, TEXCOORDFMT_NOT_PRESENT) |
	    S2_TEXCOORD_FMT(2, TEXCOORDFMT_NOT_PRESENT) |
	    S2_TEXCOORD_FMT(3, TEXCOORDFMT_NOT_PRESENT) |
	    S2_TEXCOORD_FMT(4, TEXCOORDFMT_NOT_PRESENT) |
	    S2_TEXCOORD_FMT(5, TEXCOORDFMT_NOT_PRESENT) |
	    S2_TEXCOORD_FMT(6, TEXCOORDFMT_NOT_PRESENT) |
	    S2_TEXCOORD_FMT(7, TEXCOORDFMT_NOT_PRESENT));
d172 1
a172 4
   s5 = 0x0;
   if (pI830->cpp == 2)
      s5 |= S5_COLOR_DITHER_ENABLE;
   OUT_RING(s5); /* S5 - enable bits */
d178 6
d196 3
d202 2
a203 2
	    BUF_3D_PITCH(intel_get_pixmap_pitch(pPixmap)));
   OUT_RING(BUF_3D_ADDR(intel_get_pixmap_offset(pPixmap)));
d216 1
a216 3
	       (TEXCOORDMODE_CLAMP_EDGE << SS3_TCY_ADDR_MODE_SHIFT) |
	       (0 << SS3_TEXTUREMAP_INDEX_SHIFT) |
	       SS3_NORMALIZED_COORDS);
d222 1
a222 1
      ms3 = MAPSURF_422 | MS3_USE_FENCE_REGS;
d233 2
d236 1
a236 1
      OUT_RING(((video_pitch / 4) - 1) << MS4_PITCH_SHIFT);
d247 2
a248 1
      BEGIN_LP_RING(18 + 11 + 11);
d294 1
d298 2
a299 3
	       (TEXCOORDMODE_CLAMP_EDGE << SS3_TCY_ADDR_MODE_SHIFT) |
	       (0 << SS3_TEXTUREMAP_INDEX_SHIFT) |
	       SS3_NORMALIZED_COORDS);
a300 1
      /* sampler 1 */
d304 2
a305 3
	       (TEXCOORDMODE_CLAMP_EDGE << SS3_TCY_ADDR_MODE_SHIFT) |
	       (1 << SS3_TEXTUREMAP_INDEX_SHIFT) |
	       SS3_NORMALIZED_COORDS);
a306 1
      /* sampler 2 */
d310 1
a310 4
	       (TEXCOORDMODE_CLAMP_EDGE << SS3_TCY_ADDR_MODE_SHIFT) |
	       (2 << SS3_TEXTUREMAP_INDEX_SHIFT) |
	       SS3_NORMALIZED_COORDS);
      OUT_RING(0x00000000);
d316 1
a316 1
      ms3 = MAPSURF_8BIT | MT_8BIT_I8 | MS3_USE_FENCE_REGS;
d320 1
a320 1
      OUT_RING(((video_pitch * 2 / 4) - 1) << MS4_PITCH_SHIFT);
d323 1
a323 1
      ms3 = MAPSURF_8BIT | MT_8BIT_I8 | MS3_USE_FENCE_REGS;
d327 1
a327 1
      OUT_RING(((video_pitch / 4) - 1) << MS4_PITCH_SHIFT);
d330 1
a330 1
      ms3 = MAPSURF_8BIT | MT_8BIT_I8 | MS3_USE_FENCE_REGS;
d334 1
a334 1
      OUT_RING(((video_pitch / 4) - 1) << MS4_PITCH_SHIFT);
d339 5
a343 4
      i915_fs_dcl(FS_S0); /* Y */
      i915_fs_dcl(FS_S1); /* U */
      i915_fs_dcl(FS_S2); /* V */
      i915_fs_dcl(FS_T0); /* normalized coords */
d345 4
a348 2
      /* Load samplers to temporaries. */
      i915_fs_texld(FS_R1, FS_S0, FS_T0);
d361 2
a362 3
       * calculating R, G, and B, storing the results in the R, G, or B
       * channels of the output color.  The OC results are implicitly clamped
       * at the end of the program.
d364 1
a364 1
      i915_fs_dp3_masked(FS_OC, MASK_X,
d367 1
a367 1
      i915_fs_dp3_masked(FS_OC, MASK_Y,
d370 1
a370 1
      i915_fs_dp3_masked(FS_OC, MASK_Z,
a386 11
   /* Set up the offset for translating from the given region (in screen
    * coordinates) to the backing pixmap.
    */
#ifdef COMPOSITE
   pix_xoff = -pPixmap->screen_x + pPixmap->drawable.x;
   pix_yoff = -pPixmap->screen_y + pPixmap->drawable.y;
#else
   pix_xoff = 0;
   pix_yoff = 0;
#endif

d399 1
d403 7
a409 2
      src_scale_x = ((float)src_w / width) / drw_w;
      src_scale_y  = ((float)src_h / height) / drw_h;
d411 1
a411 1
      BEGIN_LP_RING(8 + 12);
d423 2
a424 1
      OUT_RING(PRIM3D_INLINE | PRIM3D_RECTLIST | (12 - 1));
d427 11
a437 4
      OUT_RING_F(box_x2 + pix_xoff);
      OUT_RING_F(box_y2 + pix_yoff);
      OUT_RING_F((box_x2 - dxo) * src_scale_x);
      OUT_RING_F((box_y2 - dyo) * src_scale_y);
d440 11
a450 4
      OUT_RING_F(box_x1 + pix_xoff);
      OUT_RING_F(box_y2 + pix_yoff);
      OUT_RING_F((box_x1 - dxo) * src_scale_x);
      OUT_RING_F((box_y2 - dyo) * src_scale_y);
d453 11
a463 4
      OUT_RING_F(box_x1 + pix_xoff);
      OUT_RING_F(box_y1 + pix_yoff);
      OUT_RING_F((box_x1 - dxo) * src_scale_x);
      OUT_RING_F((box_y1 - dyo) * src_scale_y);
d468 2
a469 1
   i830MarkSync(pScrn);
@


