head	1.18;
access;
symbols
	OPENBSD_5_3:1.17.0.2
	OPENBSD_5_3_BASE:1.17
	OPENBSD_5_2:1.14.0.2
	OPENBSD_5_2_BASE:1.14
	OPENBSD_5_1_BASE:1.13
	OPENBSD_5_1:1.13.0.2
	OPENBSD_5_0:1.11.0.4
	OPENBSD_5_0_BASE:1.11
	OPENBSD_4_9:1.11.0.2
	OPENBSD_4_9_BASE:1.11
	OPENBSD_4_8:1.10.0.4
	OPENBSD_4_8_BASE:1.10
	OPENBSD_4_7:1.8.0.2
	OPENBSD_4_7_BASE:1.8
	OPENBSD_4_6:1.7.0.2
	OPENBSD_4_6_BASE:1.7
	OPENBSD_4_5:1.6.0.2
	OPENBSD_4_5_BASE:1.6
	OPENBSD_4_4:1.4.0.2
	OPENBSD_4_4_BASE:1.4
	OPENBSD_4_3_BASE:1.1.1.2
	OPENBSD_4_3:1.1.1.2.0.2
	v2_2_0_90:1.1.1.2
	v2_2_0:1.1.1.1
	xorg:1.1.1;
locks; strict;
comment	@ * @;


1.18
date	2013.03.18.18.38.20;	author matthieu;	state dead;
branches;
next	1.17;

1.17
date	2013.02.01.11.09.26;	author jsg;	state Exp;
branches;
next	1.16;

1.16
date	2013.01.15.06.31.43;	author martynas;	state Exp;
branches;
next	1.15;

1.15
date	2012.10.06.03.51.23;	author jsg;	state Exp;
branches;
next	1.14;

1.14
date	2012.03.13.22.44.44;	author oga;	state Exp;
branches;
next	1.13;

1.13
date	2011.12.21.21.25.02;	author kettenis;	state Exp;
branches;
next	1.12;

1.12
date	2011.11.29.12.39.02;	author oga;	state Exp;
branches;
next	1.11;

1.11
date	2010.08.25.20.29.35;	author martynas;	state Exp;
branches;
next	1.10;

1.10
date	2010.07.18.14.47.47;	author oga;	state Exp;
branches;
next	1.9;

1.9
date	2010.05.10.22.32.29;	author oga;	state Exp;
branches;
next	1.8;

1.8
date	2009.09.10.02.30.26;	author oga;	state Exp;
branches;
next	1.7;

1.7
date	2009.06.25.20.16.43;	author matthieu;	state Exp;
branches;
next	1.6;

1.6
date	2008.10.12.15.20.50;	author matthieu;	state Exp;
branches;
next	1.5;

1.5
date	2008.08.26.19.00.32;	author oga;	state Exp;
branches;
next	1.4;

1.4
date	2008.06.29.20.13.42;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2008.05.21.20.19.52;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2008.03.30.13.51.30;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2007.11.24.19.44.51;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2007.11.24.19.44.51;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2008.02.11.20.10.16;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.18
log
@Update to xf86-video-intel 2.20.19.

A recent kernel with kernel modesetting support is required.
Thanks to jsg@@ and kettenis@@ for their work.
@
text
@/* -*- c-basic-offset: 4 -*- */
/*
 * Copyright © 2006 Intel Corporation
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice (including the next
 * paragraph) shall be included in all copies or substantial portions of the
 * Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 * Authors:
 *    Eric Anholt <eric@@anholt.net>
 *
 */

#ifdef HAVE_CONFIG_H
#include "config.h"
#endif

#include <unistd.h>
#include <string.h>
#include <assert.h>
#include <stdlib.h>
#include <math.h>
#include <sys/ioctl.h>

#include "xf86.h"
#include "intel.h"
#include "i830_bios.h"
#include "i830_display.h"
#include "xf86Modes.h"
#include "i830_reg.h"

typedef struct {
    /* given values */    
    int n;
    int m1, m2;
    int p1, p2;
    /* derived values */
    int	dot;
    int	vco;
    int	m;
    int	p;
} intel_clock_t;

typedef struct {
    int	min, max;
} intel_range_t;

typedef struct {
    int	dot_limit;
    int	p2_slow, p2_fast;
} intel_p2_t;

#define INTEL_P2_NUM		      2

typedef struct intel_limit intel_limit_t;
struct intel_limit {
    intel_range_t   dot, vco, n, m, m1, m2, p, p1;
    intel_p2_t	    p2;
    Bool (* find_pll)(const intel_limit_t *, xf86CrtcPtr,
                      int, int, intel_clock_t *);
};

#define I8XX_DOT_MIN		  25000
#define I8XX_DOT_MAX		 350000
#define I8XX_VCO_MIN		 930000
#define I8XX_VCO_MAX		1400000
#define I8XX_N_MIN		      3
#define I8XX_N_MAX		     16
#define I8XX_M_MIN		     96
#define I8XX_M_MAX		    140
#define I8XX_M1_MIN		     18
#define I8XX_M1_MAX		     26
#define I8XX_M2_MIN		      6
#define I8XX_M2_MAX		     16
#define I8XX_P_MIN		      4
#define I8XX_P_MAX		    128
#define I8XX_P1_MIN		      2
#define I8XX_P1_MAX		     33
#define I8XX_P1_LVDS_MIN	      1
#define I8XX_P1_LVDS_MAX	      6
#define I8XX_P2_SLOW		      4
#define I8XX_P2_FAST		      2
#define I8XX_P2_LVDS_SLOW	      14
#define I8XX_P2_LVDS_FAST	      7
#define I8XX_P2_SLOW_LIMIT	 165000

#define I9XX_DOT_MIN		  20000
#define I9XX_DOT_MAX		 400000
#define I9XX_VCO_MIN		1400000
#define I9XX_VCO_MAX		2800000
#define IGD_VCO_MIN		1700000
#define IGD_VCO_MAX		3500000

/* Haven't found any reason to go this fast, but newer chips support it */
#define I96X_VCO_MAX		3200000

/*
 * These values are taken from the broadwater/crestline PLL spreadsheet.
 * All of the defines here are for the programmed register value, not
 * the 'counter' value (e.g. Ncounter = Nregister + 2)
 */
#define I9XX_N_MIN		      1
#define I9XX_N_MAX		      6
/* IGD's Ncounter is a ring counter */
#define IGD_N_MIN		      3
#define IGD_N_MAX		      6
#define I9XX_M_MIN		     70
#define I9XX_M_MAX		    120
#define IGD_M_MIN		      2
#define IGD_M_MAX		    256

/* these two come from the calm1 macro */
#define I9XX_M1_MIN		     10
#define I9XX_M1_MAX		     22
#define I9XX_M2_MIN		      5
#define I9XX_M2_MAX		      9
/* IGD M1 is reserved, and must be 0 */
#define IGD_M1_MIN		      0
#define IGD_M1_MAX		      0
#define IGD_M2_MIN		      0
#define IGD_M2_MAX		      254

#define I9XX_P_SDVO_DAC_MIN	      5
#define I9XX_P_SDVO_DAC_MAX	     80
#define I9XX_P_LVDS_MIN		      7
#define I9XX_P_LVDS_MAX		     98
#define IGD_P_LVDS_MIN		      7
#define IGD_P_LVDS_MAX		     112
#define I9XX_P1_MIN		      1
#define I9XX_P1_MAX		      8
#define I9XX_P2_SDVO_DAC_SLOW		     10
#define I9XX_P2_SDVO_DAC_FAST		      5
#define I9XX_P2_SDVO_DAC_SLOW_LIMIT	 200000
#define I9XX_P2_LVDS_SLOW		     14
#define I9XX_P2_LVDS_FAST		      7
#define I9XX_P2_LVDS_SLOW_LIMIT		 112000

#define IRONLAKE_P2_DOT_LIMIT    225000 /* 225Mhz */
#define IRONLAKE_DOT_MIN         25000
#define IRONLAKE_DOT_MAX         350000
#define IRONLAKE_VCO_MIN         1760000
#define IRONLAKE_VCO_MAX         3510000
#define IRONLAKE_M1_MIN          12
#define IRONLAKE_M1_MAX          22
#define IRONLAKE_M2_MIN          5
#define IRONLAKE_M2_MAX          9

#define INTEL_LIMIT_I8XX_DVO_DAC    0
#define INTEL_LIMIT_I8XX_LVDS	    1
#define INTEL_LIMIT_I9XX_SDVO_DAC   2
#define INTEL_LIMIT_I9XX_LVDS	    3
#define INTEL_LIMIT_IGD_SDVO_DAC    4
#define INTEL_LIMIT_IGD_LVDS	    5
#define INTEL_LIMIT_G4X_SDVO	    6
#define INTEL_LIMIT_G4X_HDMI_DAC    7
#define INTEL_LIMIT_G4X_SINGLE_LVDS 8
#define INTEL_LIMIT_G4X_DUAL_LVDS   9

/*The parameter is for SDVO on G4x platform*/
#define G4X_VCO_MIN                1750000
#define G4X_VCO_MAX                3500000
#define G4X_DOT_SDVO_MIN           25000
#define G4X_DOT_SDVO_MAX           270000
#define G4X_N_SDVO_MIN             1
#define G4X_N_SDVO_MAX             4
#define G4X_M_SDVO_MIN             104
#define G4X_M_SDVO_MAX             138
#define G4X_M1_SDVO_MIN            17
#define G4X_M1_SDVO_MAX            23
#define G4X_M2_SDVO_MIN            5
#define G4X_M2_SDVO_MAX            11
#define G4X_P_SDVO_MIN             10
#define G4X_P_SDVO_MAX             30
#define G4X_P1_SDVO_MIN            1
#define G4X_P1_SDVO_MAX            3
#define G4X_P2_SDVO_SLOW           10
#define G4X_P2_SDVO_FAST           10
#define G4X_P2_SDVO_LIMIT          270000

/*The parameter is for HDMI_DAC on G4x platform*/
#define G4X_DOT_HDMI_DAC_MIN           22000
#define G4X_DOT_HDMI_DAC_MAX           400000
#define G4X_N_HDMI_DAC_MIN             1
#define G4X_N_HDMI_DAC_MAX             4
#define G4X_M_HDMI_DAC_MIN             104
#define G4X_M_HDMI_DAC_MAX             138
#define G4X_M1_HDMI_DAC_MIN            16
#define G4X_M1_HDMI_DAC_MAX            23
#define G4X_M2_HDMI_DAC_MIN            5
#define G4X_M2_HDMI_DAC_MAX            11
#define G4X_P_HDMI_DAC_MIN             5
#define G4X_P_HDMI_DAC_MAX             80
#define G4X_P1_HDMI_DAC_MIN            1
#define G4X_P1_HDMI_DAC_MAX            8
#define G4X_P2_HDMI_DAC_SLOW           10
#define G4X_P2_HDMI_DAC_FAST           5
#define G4X_P2_HDMI_DAC_LIMIT          165000

/*The parameter is for SINGLE_LVDS on G4x platform*/
#define G4X_DOT_SINGLE_LVDS_MIN           20000
#define G4X_DOT_SINGLE_LVDS_MAX           115000
#define G4X_N_SINGLE_LVDS_MIN             1
#define G4X_N_SINGLE_LVDS_MAX             3
#define G4X_M_SINGLE_LVDS_MIN             104
#define G4X_M_SINGLE_LVDS_MAX             138
#define G4X_M1_SINGLE_LVDS_MIN            17
#define G4X_M1_SINGLE_LVDS_MAX            23
#define G4X_M2_SINGLE_LVDS_MIN            5
#define G4X_M2_SINGLE_LVDS_MAX            11
#define G4X_P_SINGLE_LVDS_MIN             28
#define G4X_P_SINGLE_LVDS_MAX             112
#define G4X_P1_SINGLE_LVDS_MIN            2
#define G4X_P1_SINGLE_LVDS_MAX            8
#define G4X_P2_SINGLE_LVDS_SLOW           14
#define G4X_P2_SINGLE_LVDS_FAST           14
#define G4X_P2_SINGLE_LVDS_LIMIT          0

/*The parameter is for DUAL_LVDS on G4x platform*/
#define G4X_DOT_DUAL_LVDS_MIN           80000
#define G4X_DOT_DUAL_LVDS_MAX           224000
#define G4X_N_DUAL_LVDS_MIN             1
#define G4X_N_DUAL_LVDS_MAX             3
#define G4X_M_DUAL_LVDS_MIN             104
#define G4X_M_DUAL_LVDS_MAX             138
#define G4X_M1_DUAL_LVDS_MIN            17
#define G4X_M1_DUAL_LVDS_MAX            23
#define G4X_M2_DUAL_LVDS_MIN            5
#define G4X_M2_DUAL_LVDS_MAX            11
#define G4X_P_DUAL_LVDS_MIN             14
#define G4X_P_DUAL_LVDS_MAX             42
#define G4X_P1_DUAL_LVDS_MIN            2
#define G4X_P1_DUAL_LVDS_MAX            6
#define G4X_P2_DUAL_LVDS_SLOW           7
#define G4X_P2_DUAL_LVDS_FAST           7
#define G4X_P2_DUAL_LVDS_LIMIT          0

/* DAC & HDMI Refclk 120Mhz */
#define IRONLAKE_DAC_N_MIN     1
#define IRONLAKE_DAC_N_MAX     5
#define IRONLAKE_DAC_M_MIN     79
#define IRONLAKE_DAC_M_MAX     127
#define IRONLAKE_DAC_P_MIN     5
#define IRONLAKE_DAC_P_MAX     80
#define IRONLAKE_DAC_P1_MIN    1
#define IRONLAKE_DAC_P1_MAX    8
#define IRONLAKE_DAC_P2_SLOW   10
#define IRONLAKE_DAC_P2_FAST   5

/* LVDS single-channel 120Mhz refclk */
#define IRONLAKE_LVDS_S_N_MIN  1
#define IRONLAKE_LVDS_S_N_MAX  3
#define IRONLAKE_LVDS_S_M_MIN  79
#define IRONLAKE_LVDS_S_M_MAX  118
#define IRONLAKE_LVDS_S_P_MIN  28
#define IRONLAKE_LVDS_S_P_MAX  112
#define IRONLAKE_LVDS_S_P1_MIN 2
#define IRONLAKE_LVDS_S_P1_MAX 8
#define IRONLAKE_LVDS_S_P2_SLOW        14
#define IRONLAKE_LVDS_S_P2_FAST        14

/* LVDS dual-channel 120Mhz refclk */
#define IRONLAKE_LVDS_D_N_MIN  1
#define IRONLAKE_LVDS_D_N_MAX  3
#define IRONLAKE_LVDS_D_M_MIN  79
#define IRONLAKE_LVDS_D_M_MAX  127
#define IRONLAKE_LVDS_D_P_MIN  14
#define IRONLAKE_LVDS_D_P_MAX  56
#define IRONLAKE_LVDS_D_P1_MIN 2
#define IRONLAKE_LVDS_D_P1_MAX 8
#define IRONLAKE_LVDS_D_P2_SLOW        7
#define IRONLAKE_LVDS_D_P2_FAST        7

/* LVDS single-channel 100Mhz refclk */
#define IRONLAKE_LVDS_S_SSC_N_MIN      1
#define IRONLAKE_LVDS_S_SSC_N_MAX      2
#define IRONLAKE_LVDS_S_SSC_M_MIN      79
#define IRONLAKE_LVDS_S_SSC_M_MAX      126
#define IRONLAKE_LVDS_S_SSC_P_MIN      28
#define IRONLAKE_LVDS_S_SSC_P_MAX      112
#define IRONLAKE_LVDS_S_SSC_P1_MIN     2
#define IRONLAKE_LVDS_S_SSC_P1_MAX     8
#define IRONLAKE_LVDS_S_SSC_P2_SLOW    14
#define IRONLAKE_LVDS_S_SSC_P2_FAST    14

/* LVDS dual-channel 100Mhz refclk */
#define IRONLAKE_LVDS_D_SSC_N_MIN      1
#define IRONLAKE_LVDS_D_SSC_N_MAX      3
#define IRONLAKE_LVDS_D_SSC_M_MIN      79
#define IRONLAKE_LVDS_D_SSC_M_MAX      126
#define IRONLAKE_LVDS_D_SSC_P_MIN      14
#define IRONLAKE_LVDS_D_SSC_P_MAX      42
#define IRONLAKE_LVDS_D_SSC_P1_MIN     2
#define IRONLAKE_LVDS_D_SSC_P1_MAX     6
#define IRONLAKE_LVDS_D_SSC_P2_SLOW    7
#define IRONLAKE_LVDS_D_SSC_P2_FAST    7

static Bool
intel_find_pll_i8xx_and_i9xx(const intel_limit_t *, xf86CrtcPtr,
                             int, int, intel_clock_t *);
static Bool
intel_find_pll_g4x(const intel_limit_t *, xf86CrtcPtr,
                   int, int, intel_clock_t *);
static Bool
intel_igdng_find_best_PLL(const intel_limit_t *, xf86CrtcPtr,
			  int, int, intel_clock_t *);
static void
i830_crtc_load_lut(xf86CrtcPtr crtc);

static const intel_limit_t intel_limits[] = {
    { /* INTEL_LIMIT_I8XX_DVO_DAC */
        .dot = { .min = I8XX_DOT_MIN,		.max = I8XX_DOT_MAX },
        .vco = { .min = I8XX_VCO_MIN,		.max = I8XX_VCO_MAX },
        .n   = { .min = I8XX_N_MIN,		.max = I8XX_N_MAX },
        .m   = { .min = I8XX_M_MIN,		.max = I8XX_M_MAX },
        .m1  = { .min = I8XX_M1_MIN,		.max = I8XX_M1_MAX },
        .m2  = { .min = I8XX_M2_MIN,		.max = I8XX_M2_MAX },
        .p   = { .min = I8XX_P_MIN,		.max = I8XX_P_MAX },
        .p1  = { .min = I8XX_P1_MIN,		.max = I8XX_P1_MAX },
	.p2  = { .dot_limit = I8XX_P2_SLOW_LIMIT,
		 .p2_slow = I8XX_P2_SLOW,	.p2_fast = I8XX_P2_FAST },
        .find_pll = intel_find_pll_i8xx_and_i9xx,
    },
    { /* INTEL_LIMIT_I8XX_LVDS */
        .dot = { .min = I8XX_DOT_MIN,		.max = I8XX_DOT_MAX },
        .vco = { .min = I8XX_VCO_MIN,		.max = I8XX_VCO_MAX },
        .n   = { .min = I8XX_N_MIN,		.max = I8XX_N_MAX },
        .m   = { .min = I8XX_M_MIN,		.max = I8XX_M_MAX },
        .m1  = { .min = I8XX_M1_MIN,		.max = I8XX_M1_MAX },
        .m2  = { .min = I8XX_M2_MIN,		.max = I8XX_M2_MAX },
        .p   = { .min = I8XX_P_MIN,		.max = I8XX_P_MAX },
        .p1  = { .min = I8XX_P1_LVDS_MIN,	.max = I8XX_P1_LVDS_MAX },
	.p2  = { .dot_limit = I8XX_P2_SLOW_LIMIT,
		 .p2_slow = I8XX_P2_LVDS_SLOW,	.p2_fast = I8XX_P2_LVDS_FAST },
        .find_pll = intel_find_pll_i8xx_and_i9xx,
    },
    { /* INTEL_LIMIT_I9XX_SDVO_DAC */
        .dot = { .min = I9XX_DOT_MIN,		.max = I9XX_DOT_MAX },
        .vco = { .min = I9XX_VCO_MIN,		.max = I9XX_VCO_MAX },
        .n   = { .min = I9XX_N_MIN,		.max = I9XX_N_MAX },
        .m   = { .min = I9XX_M_MIN,		.max = I9XX_M_MAX },
        .m1  = { .min = I9XX_M1_MIN,		.max = I9XX_M1_MAX },
        .m2  = { .min = I9XX_M2_MIN,		.max = I9XX_M2_MAX },
        .p   = { .min = I9XX_P_SDVO_DAC_MIN,	.max = I9XX_P_SDVO_DAC_MAX },
        .p1  = { .min = I9XX_P1_MIN,		.max = I9XX_P1_MAX },
	.p2  = { .dot_limit = I9XX_P2_SDVO_DAC_SLOW_LIMIT,
		 .p2_slow = I9XX_P2_SDVO_DAC_SLOW,	.p2_fast = I9XX_P2_SDVO_DAC_FAST },
        .find_pll = intel_find_pll_i8xx_and_i9xx,
    },
    { /* INTEL_LIMIT_I9XX_LVDS */
        .dot = { .min = I9XX_DOT_MIN,		.max = I9XX_DOT_MAX },
        .vco = { .min = I9XX_VCO_MIN,		.max = I9XX_VCO_MAX },
        .n   = { .min = I9XX_N_MIN,		.max = I9XX_N_MAX },
        .m   = { .min = I9XX_M_MIN,		.max = I9XX_M_MAX },
        .m1  = { .min = I9XX_M1_MIN,		.max = I9XX_M1_MAX },
        .m2  = { .min = I9XX_M2_MIN,		.max = I9XX_M2_MAX },
        .p   = { .min = I9XX_P_LVDS_MIN,	.max = I9XX_P_LVDS_MAX },
        .p1  = { .min = I9XX_P1_MIN,		.max = I9XX_P1_MAX },
	/* The single-channel range is 25-112Mhz, and dual-channel
	 * is 80-224Mhz.  Prefer single channel as much as possible.
	 */
	.p2  = { .dot_limit = I9XX_P2_LVDS_SLOW_LIMIT,
		 .p2_slow = I9XX_P2_LVDS_SLOW,	.p2_fast = I9XX_P2_LVDS_FAST },
        .find_pll = intel_find_pll_i8xx_and_i9xx,
    },
    { /* INTEL_LIMIT_IGD_SDVO */
        .dot = { .min = I9XX_DOT_MIN,		.max = I9XX_DOT_MAX},
        .vco = { .min = IGD_VCO_MIN,		.max = IGD_VCO_MAX },
        .n   = { .min = IGD_N_MIN,		.max = IGD_N_MAX },
        .m   = { .min = IGD_M_MIN,		.max = IGD_M_MAX },
        .m1  = { .min = IGD_M1_MIN,		.max = IGD_M1_MAX },
        .m2  = { .min = IGD_M2_MIN,		.max = IGD_M2_MAX },
        .p   = { .min = I9XX_P_SDVO_DAC_MIN,    .max = I9XX_P_SDVO_DAC_MAX },
        .p1  = { .min = I9XX_P1_MIN,		.max = I9XX_P1_MAX },
	.p2  = { .dot_limit = I9XX_P2_SDVO_DAC_SLOW_LIMIT,
		 .p2_slow = I9XX_P2_SDVO_DAC_SLOW,	.p2_fast = I9XX_P2_SDVO_DAC_FAST },
        .find_pll = intel_find_pll_i8xx_and_i9xx,
    },
    { /* INTEL_LIMIT_IGD_LVDS */
        .dot = { .min = I9XX_DOT_MIN,		.max = I9XX_DOT_MAX },
        .vco = { .min = IGD_VCO_MIN,		.max = IGD_VCO_MAX },
        .n   = { .min = IGD_N_MIN,		.max = IGD_N_MAX },
        .m   = { .min = IGD_M_MIN,		.max = IGD_M_MAX },
        .m1  = { .min = IGD_M1_MIN,		.max = IGD_M1_MAX },
        .m2  = { .min = IGD_M2_MIN,		.max = IGD_M2_MAX },
        .p   = { .min = IGD_P_LVDS_MIN,	.max = IGD_P_LVDS_MAX },
        .p1  = { .min = I9XX_P1_MIN,		.max = I9XX_P1_MAX },
	/* IGD only supports single-channel mode. */
	.p2  = { .dot_limit = I9XX_P2_LVDS_SLOW_LIMIT,
		 .p2_slow = I9XX_P2_LVDS_SLOW,	.p2_fast = I9XX_P2_LVDS_SLOW },
        .find_pll = intel_find_pll_i8xx_and_i9xx,
    },
    /* below parameter and function is for G4X Chipset Family*/
    {   /* INTEL_LIMIT_G4X_SDVO */
        .dot = { .min = G4X_DOT_SDVO_MIN,       .max = G4X_DOT_SDVO_MAX },
        .vco = { .min = G4X_VCO_MIN,            .max = G4X_VCO_MAX},
        .n   = { .min = G4X_N_SDVO_MIN,         .max = G4X_N_SDVO_MAX },
        .m   = { .min = G4X_M_SDVO_MIN,         .max = G4X_M_SDVO_MAX },
        .m1  = { .min = G4X_M1_SDVO_MIN,        .max = G4X_M1_SDVO_MAX },
        .m2  = { .min = G4X_M2_SDVO_MIN,        .max = G4X_M2_SDVO_MAX },
        .p   = { .min = G4X_P_SDVO_MIN,         .max = G4X_P_SDVO_MAX },
        .p1  = { .min = G4X_P1_SDVO_MIN,        .max = G4X_P1_SDVO_MAX},
        .p2  = { .dot_limit = G4X_P2_SDVO_LIMIT,
                 .p2_slow = G4X_P2_SDVO_SLOW,
                 .p2_fast = G4X_P2_SDVO_FAST },
        .find_pll = intel_find_pll_g4x,
    },
    {   /* INTEL_LIMIT_G4X_HDMI_DAC */
        .dot = { .min = G4X_DOT_HDMI_DAC_MIN,	.max = G4X_DOT_HDMI_DAC_MAX },
        .vco = { .min = G4X_VCO_MIN,	        .max = G4X_VCO_MAX},
        .n   = { .min = G4X_N_HDMI_DAC_MIN,	.max = G4X_N_HDMI_DAC_MAX },
        .m   = { .min = G4X_M_HDMI_DAC_MIN,	.max = G4X_M_HDMI_DAC_MAX },
        .m1  = { .min = G4X_M1_HDMI_DAC_MIN,	.max = G4X_M1_HDMI_DAC_MAX },
        .m2  = { .min = G4X_M2_HDMI_DAC_MIN,	.max = G4X_M2_HDMI_DAC_MAX },
        .p   = { .min = G4X_P_HDMI_DAC_MIN,	.max = G4X_P_HDMI_DAC_MAX },
        .p1  = { .min = G4X_P1_HDMI_DAC_MIN,	.max = G4X_P1_HDMI_DAC_MAX},
        .p2  = { .dot_limit = G4X_P2_HDMI_DAC_LIMIT,
                 .p2_slow = G4X_P2_HDMI_DAC_SLOW,
                 .p2_fast = G4X_P2_HDMI_DAC_FAST },
        .find_pll = intel_find_pll_g4x,
    },
    {   /* INTEL_LIMIT_G4X_SINGLE_LVDS */
        .dot = { .min = G4X_DOT_SINGLE_LVDS_MIN,
                 .max = G4X_DOT_SINGLE_LVDS_MAX },
        .vco = { .min = G4X_VCO_MIN,
                 .max = G4X_VCO_MAX },
        .n   = { .min = G4X_N_SINGLE_LVDS_MIN,
                 .max = G4X_N_SINGLE_LVDS_MAX },
        .m   = { .min = G4X_M_SINGLE_LVDS_MIN,
                 .max = G4X_M_SINGLE_LVDS_MAX },
        .m1  = { .min = G4X_M1_SINGLE_LVDS_MIN,
                 .max = G4X_M1_SINGLE_LVDS_MAX },
        .m2  = { .min = G4X_M2_SINGLE_LVDS_MIN,
                 .max = G4X_M2_SINGLE_LVDS_MAX },
        .p   = { .min = G4X_P_SINGLE_LVDS_MIN,
                 .max = G4X_P_SINGLE_LVDS_MAX },
        .p1  = { .min = G4X_P1_SINGLE_LVDS_MIN,
                 .max = G4X_P1_SINGLE_LVDS_MAX },
        .p2  = { .dot_limit = G4X_P2_SINGLE_LVDS_LIMIT,
                 .p2_slow = G4X_P2_SINGLE_LVDS_SLOW,
                 .p2_fast = G4X_P2_SINGLE_LVDS_FAST },
        .find_pll = intel_find_pll_g4x,
    },
    {   /* INTEL_LIMIT_G4X_DUAL_LVDS */
        .dot = { .min = G4X_DOT_DUAL_LVDS_MIN,
                 .max = G4X_DOT_DUAL_LVDS_MAX },
        .vco = { .min = G4X_VCO_MIN,
                 .max = G4X_VCO_MAX},
        .n   = { .min = G4X_N_DUAL_LVDS_MIN,
                 .max = G4X_N_DUAL_LVDS_MAX },
        .m   = { .min = G4X_M_DUAL_LVDS_MIN,
                 .max = G4X_M_DUAL_LVDS_MAX },
        .m1  = { .min = G4X_M1_DUAL_LVDS_MIN,
                 .max = G4X_M1_DUAL_LVDS_MAX },
        .m2  = { .min = G4X_M2_DUAL_LVDS_MIN,
                 .max = G4X_M2_DUAL_LVDS_MAX },
        .p   = { .min = G4X_P_DUAL_LVDS_MIN,
                 .max = G4X_P_DUAL_LVDS_MAX },
        .p1  = { .min = G4X_P1_DUAL_LVDS_MIN,
                 .max = G4X_P1_DUAL_LVDS_MAX},
        .p2  = { .dot_limit = G4X_P2_DUAL_LVDS_LIMIT,
                 .p2_slow = G4X_P2_DUAL_LVDS_SLOW,
                 .p2_fast = G4X_P2_DUAL_LVDS_FAST },
        .find_pll = intel_find_pll_g4x,
    },
};

static const intel_limit_t intel_limits_ironlake_dac = {
    .dot = { .min = IRONLAKE_DOT_MIN,          .max = IRONLAKE_DOT_MAX },
    .vco = { .min = IRONLAKE_VCO_MIN,          .max = IRONLAKE_VCO_MAX },
    .n   = { .min = IRONLAKE_DAC_N_MIN,        .max = IRONLAKE_DAC_N_MAX },
    .m   = { .min = IRONLAKE_DAC_M_MIN,        .max = IRONLAKE_DAC_M_MAX },
    .m1  = { .min = IRONLAKE_M1_MIN,           .max = IRONLAKE_M1_MAX },
    .m2  = { .min = IRONLAKE_M2_MIN,           .max = IRONLAKE_M2_MAX },
    .p   = { .min = IRONLAKE_DAC_P_MIN,        .max = IRONLAKE_DAC_P_MAX },
    .p1  = { .min = IRONLAKE_DAC_P1_MIN,       .max = IRONLAKE_DAC_P1_MAX },
    .p2  = { .dot_limit = IRONLAKE_P2_DOT_LIMIT,
	.p2_slow = IRONLAKE_DAC_P2_SLOW,
	.p2_fast = IRONLAKE_DAC_P2_FAST },
    .find_pll = intel_igdng_find_best_PLL,
};

static const intel_limit_t intel_limits_ironlake_single_lvds = {
    .dot = { .min = IRONLAKE_DOT_MIN,          .max = IRONLAKE_DOT_MAX },
    .vco = { .min = IRONLAKE_VCO_MIN,          .max = IRONLAKE_VCO_MAX },
    .n   = { .min = IRONLAKE_LVDS_S_N_MIN,     .max = IRONLAKE_LVDS_S_N_MAX },
    .m   = { .min = IRONLAKE_LVDS_S_M_MIN,     .max = IRONLAKE_LVDS_S_M_MAX },
    .m1  = { .min = IRONLAKE_M1_MIN,           .max = IRONLAKE_M1_MAX },
    .m2  = { .min = IRONLAKE_M2_MIN,           .max = IRONLAKE_M2_MAX },
    .p   = { .min = IRONLAKE_LVDS_S_P_MIN,     .max = IRONLAKE_LVDS_S_P_MAX },
    .p1  = { .min = IRONLAKE_LVDS_S_P1_MIN,    .max = IRONLAKE_LVDS_S_P1_MAX },
    .p2  = { .dot_limit = IRONLAKE_P2_DOT_LIMIT,
	.p2_slow = IRONLAKE_LVDS_S_P2_SLOW,
	.p2_fast = IRONLAKE_LVDS_S_P2_FAST },
    .find_pll = intel_igdng_find_best_PLL,
};

static const intel_limit_t intel_limits_ironlake_dual_lvds = {
    .dot = { .min = IRONLAKE_DOT_MIN,          .max = IRONLAKE_DOT_MAX },
    .vco = { .min = IRONLAKE_VCO_MIN,          .max = IRONLAKE_VCO_MAX },
    .n   = { .min = IRONLAKE_LVDS_D_N_MIN,     .max = IRONLAKE_LVDS_D_N_MAX },
    .m   = { .min = IRONLAKE_LVDS_D_M_MIN,     .max = IRONLAKE_LVDS_D_M_MAX },
    .m1  = { .min = IRONLAKE_M1_MIN,           .max = IRONLAKE_M1_MAX },
    .m2  = { .min = IRONLAKE_M2_MIN,           .max = IRONLAKE_M2_MAX },
    .p   = { .min = IRONLAKE_LVDS_D_P_MIN,     .max = IRONLAKE_LVDS_D_P_MAX },
    .p1  = { .min = IRONLAKE_LVDS_D_P1_MIN,    .max = IRONLAKE_LVDS_D_P1_MAX },
    .p2  = { .dot_limit = IRONLAKE_P2_DOT_LIMIT,
	.p2_slow = IRONLAKE_LVDS_D_P2_SLOW,
	.p2_fast = IRONLAKE_LVDS_D_P2_FAST },
   .find_pll = intel_igdng_find_best_PLL,
};

static const intel_limit_t intel_limits_ironlake_single_lvds_100m = {
    .dot = { .min = IRONLAKE_DOT_MIN,          .max = IRONLAKE_DOT_MAX },
    .vco = { .min = IRONLAKE_VCO_MIN,          .max = IRONLAKE_VCO_MAX },
    .n   = { .min = IRONLAKE_LVDS_S_SSC_N_MIN, .max = IRONLAKE_LVDS_S_SSC_N_MAX },
    .m   = { .min = IRONLAKE_LVDS_S_SSC_M_MIN, .max = IRONLAKE_LVDS_S_SSC_M_MAX },
    .m1  = { .min = IRONLAKE_M1_MIN,           .max = IRONLAKE_M1_MAX },
    .m2  = { .min = IRONLAKE_M2_MIN,           .max = IRONLAKE_M2_MAX },
    .p   = { .min = IRONLAKE_LVDS_S_SSC_P_MIN, .max = IRONLAKE_LVDS_S_SSC_P_MAX },
    .p1  = { .min = IRONLAKE_LVDS_S_SSC_P1_MIN,.max = IRONLAKE_LVDS_S_SSC_P1_MAX },
    .p2  = { .dot_limit = IRONLAKE_P2_DOT_LIMIT,
	.p2_slow = IRONLAKE_LVDS_S_SSC_P2_SLOW,
	.p2_fast = IRONLAKE_LVDS_S_SSC_P2_FAST },
   .find_pll = intel_igdng_find_best_PLL,
};

static const intel_limit_t intel_limits_ironlake_dual_lvds_100m = {
    .dot = { .min = IRONLAKE_DOT_MIN,          .max = IRONLAKE_DOT_MAX },
    .vco = { .min = IRONLAKE_VCO_MIN,          .max = IRONLAKE_VCO_MAX },
    .n   = { .min = IRONLAKE_LVDS_D_SSC_N_MIN, .max = IRONLAKE_LVDS_D_SSC_N_MAX },
    .m   = { .min = IRONLAKE_LVDS_D_SSC_M_MIN, .max = IRONLAKE_LVDS_D_SSC_M_MAX },
    .m1  = { .min = IRONLAKE_M1_MIN,           .max = IRONLAKE_M1_MAX },
    .m2  = { .min = IRONLAKE_M2_MIN,           .max = IRONLAKE_M2_MAX },
    .p   = { .min = IRONLAKE_LVDS_D_SSC_P_MIN, .max = IRONLAKE_LVDS_D_SSC_P_MAX },
    .p1  = { .min = IRONLAKE_LVDS_D_SSC_P1_MIN,.max = IRONLAKE_LVDS_D_SSC_P1_MAX },
    .p2  = { .dot_limit = IRONLAKE_P2_DOT_LIMIT,
	.p2_slow = IRONLAKE_LVDS_D_SSC_P2_SLOW,
	.p2_fast = IRONLAKE_LVDS_D_SSC_P2_FAST },
   .find_pll = intel_igdng_find_best_PLL,
};


static const intel_limit_t *intel_ironlake_limit(xf86CrtcPtr crtc)
{
    ScrnInfoPtr	scrn = crtc->scrn;
    intel_screen_private *intel = intel_get_screen_private(scrn);
    const intel_limit_t *limit;

    if (i830PipeHasType(crtc, I830_OUTPUT_LVDS)) {
	int refclk = 120;

	if (intel->lvds_use_ssc && intel->lvds_ssc_freq)
	    refclk = 100;

	if ((INREG(PCH_LVDS) & LVDS_CLKB_POWER_MASK) == LVDS_CLKB_POWER_UP) {
	    if (refclk == 100)
		limit = &intel_limits_ironlake_dual_lvds_100m;
	    else
		limit = &intel_limits_ironlake_dual_lvds;
	} else {
	    if (refclk == 100)
		limit = &intel_limits_ironlake_single_lvds_100m;
	    else
		limit = &intel_limits_ironlake_single_lvds;
	}
    } else
	limit = &intel_limits_ironlake_dac;

    return limit;
}


static const intel_limit_t *intel_limit_g4x (xf86CrtcPtr crtc)
{
    ScrnInfoPtr	scrn = crtc->scrn;
    intel_screen_private *intel = intel_get_screen_private(scrn);
    const intel_limit_t *limit;

    if (i830PipeHasType (crtc, I830_OUTPUT_LVDS)) {
        if ((INREG(LVDS) & LVDS_CLKB_POWER_MASK) == LVDS_CLKB_POWER_UP) {
            /* LVDS with dual channel */
            limit = &intel_limits[INTEL_LIMIT_G4X_DUAL_LVDS];
        } else /* LVDS with single channel */
            limit = &intel_limits[INTEL_LIMIT_G4X_SINGLE_LVDS];
    } else if (i830PipeHasType (crtc, I830_OUTPUT_HDMI) ||
               i830PipeHasType (crtc, I830_OUTPUT_ANALOG)) {
        limit = &intel_limits[INTEL_LIMIT_G4X_HDMI_DAC];
    } else if (i830PipeHasType (crtc, I830_OUTPUT_SDVO)) {
        limit = &intel_limits[INTEL_LIMIT_G4X_SDVO];
    } else /* The option is for other outputs */
        limit = &intel_limits[INTEL_LIMIT_I9XX_SDVO_DAC];
    return limit;
}

static const intel_limit_t *intel_limit (xf86CrtcPtr crtc)
{
    ScrnInfoPtr	scrn = crtc->scrn;
    intel_screen_private *intel = intel_get_screen_private(scrn);
    const intel_limit_t *limit;

    if (HAS_PCH_SPLIT(intel)) {
	limit = intel_ironlake_limit(crtc);
    } else if (IS_G4X(intel)) {
        limit = intel_limit_g4x(crtc);
    } else if (IS_I9XX(intel) && !IS_IGD(intel)) {
	if (i830PipeHasType (crtc, I830_OUTPUT_LVDS))
	    limit = &intel_limits[INTEL_LIMIT_I9XX_LVDS];
	else
	    limit = &intel_limits[INTEL_LIMIT_I9XX_SDVO_DAC];
    } else if (IS_IGD(intel)) {
	if (i830PipeHasType (crtc, I830_OUTPUT_LVDS))
	    limit = &intel_limits[INTEL_LIMIT_IGD_LVDS];
	else
	    limit = &intel_limits[INTEL_LIMIT_IGD_SDVO_DAC];
    } else {
	if (i830PipeHasType (crtc, I830_OUTPUT_LVDS))
	    limit = &intel_limits[INTEL_LIMIT_I8XX_LVDS];
	else
	    limit = &intel_limits[INTEL_LIMIT_I8XX_DVO_DAC];
    }

    return limit;
}

/** Derive the pixel clock for the given refclk and divisors for 8xx chips. */

static void i8xx_clock(int refclk, intel_clock_t *clock)
{
    clock->m = 5 * (clock->m1 + 2) + (clock->m2 + 2);
    clock->p = clock->p1 * clock->p2;
    clock->vco = refclk * clock->m / (clock->n + 2);
    clock->dot = clock->vco / clock->p;
}

/** Derive the pixel clock for the given refclk and divisors for 9xx chips. */

static void i9xx_clock(int refclk, intel_clock_t *clock)
{
    clock->m = 5 * (clock->m1 + 2) + (clock->m2 + 2);
    clock->p = clock->p1 * clock->p2;
    clock->vco = refclk * clock->m / (clock->n + 2);
    clock->dot = clock->vco / clock->p;
}

/* m1 is reserved as 0 in IGD, n is a ring counter */
static void igd_clock(int refclk, intel_clock_t *clock)
{
    clock->m = clock->m2 + 2;
    clock->p = clock->p1 * clock->p2;
    clock->vco = refclk * clock->m / clock->n;
    clock->dot = clock->vco / clock->p;
}

static void intel_clock(intel_screen_private *intel, int refclk, intel_clock_t *clock)
{
    if (IS_I9XX(intel)) {
	if (IS_IGD(intel))
	    igd_clock(refclk, clock);
	else
	    i9xx_clock (refclk, clock);
    } else
	i8xx_clock (refclk, clock);
}

static void
i830PrintPll(ScrnInfoPtr scrn, char *prefix, intel_clock_t *clock)
{
    xf86DrvMsg(scrn->scrnIndex, X_INFO,
	       "%s: dotclock %d vco %d ((m %d, m1 %d, m2 %d), n %d, "
	       "(p %d, p1 %d, p2 %d))\n",
	       prefix, clock->dot, clock->vco,
	       clock->m, clock->m1, clock->m2,
	       clock->n,
	       clock->p, clock->p1, clock->p2);
}

static Bool
i830PllIsValid(xf86CrtcPtr crtc, intel_clock_t *clock);

static Bool
intel_igdng_find_best_PLL(const intel_limit_t *limit, xf86CrtcPtr crtc,
			  int target, int refclk, intel_clock_t *best_clock)
{
    ScrnInfoPtr scrn = crtc->scrn;
    intel_screen_private *intel = intel_get_screen_private(scrn);
    intel_clock_t clock;
    int max_n;
    Bool found = FALSE;
    /* Approximately equals target * 0.00585 */
    int err_most = (target >> 8) + (target >> 9);

    if (i830PipeHasType(crtc, I830_OUTPUT_LVDS)) {
	if ((INREG(PCH_LVDS) & LVDS_CLKB_POWER_MASK) == LVDS_CLKB_POWER_UP)
	    clock.p2 = limit->p2.p2_fast;
	else
	    clock.p2 = limit->p2.p2_slow;
    } else {
	if (target < limit->p2.dot_limit)
	    clock.p2 = limit->p2.p2_slow;
	else
	    clock.p2 = limit->p2.p2_fast;
    }

    memset(best_clock, 0, sizeof(*best_clock));
    max_n = limit->n.max;
    /* based on hardware requriment prefer smaller n to precision */
    for (clock.n = limit->n.min; clock.n <= max_n; clock.n++) {
	/* based on hardware requirment prefere larger m1,m2 */
	for (clock.m1 = limit->m1.max; clock.m1 >= limit->m1.min; clock.m1--) {
	    for (clock.m2 = limit->m2.max;
		 clock.m2 >= limit->m2.min; clock.m2--) {
		for (clock.p1 = limit->p1.max;
		     clock.p1 >= limit->p1.min; clock.p1--) {
		    int this_err;

		    intel_clock(intel, refclk, &clock);
		    if (!i830PllIsValid(crtc, &clock))
			continue;
		    this_err = abs(clock.dot - target) ;
		    if (this_err < err_most) {
			*best_clock = clock;
			err_most = this_err;
			max_n = clock.n;
			found = TRUE;
		    }
		}
	    }
	}
    }
    return found;
}

/**
 * Returns whether any output on the specified pipe is of the specified type
 */
Bool
i830PipeHasType (xf86CrtcPtr crtc, int type)
{
    ScrnInfoPtr	scrn = crtc->scrn;
    xf86CrtcConfigPtr   xf86_config = XF86_CRTC_CONFIG_PTR(scrn);
    int		i;

    for (i = 0; i < xf86_config->num_output; i++)
    {
	xf86OutputPtr  output = xf86_config->output[i];
	if (output->crtc == crtc)
	{
	    I830OutputPrivatePtr    intel_output = output->driver_private;
	    if (intel_output->type == type)
		return TRUE;
	}
    }
    return FALSE;
}

#if 1
#define i830PllInvalid(s)   { /* ErrorF (s) */; return FALSE; }
#else
#define i830PllInvalid(s)   { ErrorF (s) ; return FALSE; }
#endif
/**
 * Returns whether the given set of divisors are valid for a given refclk with
 * the given outputs.
 */

static Bool
i830PllIsValid(xf86CrtcPtr crtc, intel_clock_t *clock)
{
    const intel_limit_t *limit = intel_limit (crtc);
    ScrnInfoPtr scrn = crtc->scrn;
    intel_screen_private *intel = intel_get_screen_private(scrn);

    if (clock->p1  < limit->p1.min  || limit->p1.max  < clock->p1)
	i830PllInvalid ("p1 out of range\n");
    if (clock->p   < limit->p.min   || limit->p.max   < clock->p)
	i830PllInvalid ("p out of range\n");
    if (clock->m2  < limit->m2.min  || limit->m2.max  < clock->m2)
	i830PllInvalid ("m2 out of range\n");
    if (clock->m1  < limit->m1.min  || limit->m1.max  < clock->m1)
	i830PllInvalid ("m1 out of range\n");
    if (clock->m1 <= clock->m2 && !IS_IGD(intel))
	i830PllInvalid ("m1 <= m2\n");
    if (clock->m   < limit->m.min   || limit->m.max   < clock->m)
	i830PllInvalid ("m out of range\n");
    if (clock->n   < limit->n.min   || limit->n.max   < clock->n)
	i830PllInvalid ("n out of range\n");
    if (clock->vco < limit->vco.min || limit->vco.max < clock->vco)
	i830PllInvalid ("vco out of range\n");
    /* XXX: We may need to be checking "Dot clock" depending on the multiplier,
     * output, etc., rather than just a single range.
     */
    if (clock->dot < limit->dot.min || limit->dot.max < clock->dot)
	i830PllInvalid ("dot out of range\n");

    return TRUE;
}

static Bool
intel_find_pll_i8xx_and_i9xx(const intel_limit_t * limit, xf86CrtcPtr crtc,
	                     int target, int refclk, intel_clock_t *best_clock)
{
    ScrnInfoPtr scrn = crtc->scrn;
    intel_screen_private *intel = intel_get_screen_private(scrn);
    intel_clock_t clock;
    int err = target;

    if (i830PipeHasType(crtc, I830_OUTPUT_LVDS))
    {
	/* For LVDS, if the panel is on, just rely on its current settings for
	 * dual-channel.  We haven't figured out how to reliably set up
	 * different single/dual channel state, if we even can.
	 */
	if ((INREG(LVDS) & LVDS_CLKB_POWER_MASK) == LVDS_CLKB_POWER_UP)
	    clock.p2 = limit->p2.p2_fast;
	else
	    clock.p2 = limit->p2.p2_slow;
    } else {
	if (target < limit->p2.dot_limit)
	    clock.p2 = limit->p2.p2_slow;
	else
	    clock.p2 = limit->p2.p2_fast;
    }

    memset (best_clock, 0, sizeof (*best_clock));

    for (clock.m1 = limit->m1.min; clock.m1 <= limit->m1.max; clock.m1++) 
    {
	for (clock.m2 = limit->m2.min; clock.m2 <= limit->m2.max; clock.m2++)
	{
	    /* m1 is always 0 in IGD */
	    if (clock.m2 >= clock.m1 && !IS_IGD(intel))
		break;
	    for (clock.n = limit->n.min; clock.n <= limit->n.max; clock.n++) 
	    {
		for (clock.p1 = limit->p1.min; clock.p1 <= limit->p1.max; clock.p1++) 
		{
		    int this_err;

		    intel_clock (intel, refclk, &clock);
		    
		    if (!i830PllIsValid(crtc, &clock))
			continue;

		    this_err = abs(clock.dot - target);
		    if (this_err < err) {
			*best_clock = clock;
			err = this_err;
		    }
		}
	    }
	}
    }
    return (err != target);
}

static Bool
intel_find_pll_g4x(const intel_limit_t * limit, xf86CrtcPtr crtc,
                   int target, int refclk, intel_clock_t *best_clock)
{
    ScrnInfoPtr scrn = crtc->scrn;
    intel_screen_private *intel = intel_get_screen_private(scrn);
    intel_clock_t clock;
    int  max_n;
    Bool found = FALSE;
    int err_most = target * 0.0048;

    if (i830PipeHasType(crtc, I830_OUTPUT_LVDS))
    {
        /* For LVDS, if the panel is on, just rely on its current settings for
         * dual-channel.  We haven't figured out how to reliably set up
         * different single/dual channel state, if we even can.
         */
        if ((INREG(LVDS) & LVDS_CLKB_POWER_MASK) == LVDS_CLKB_POWER_UP)
            clock.p2 = limit->p2.p2_fast;
        else
            clock.p2 = limit->p2.p2_slow;
    } else {
        if (target < limit->p2.dot_limit)
            clock.p2 = limit->p2.p2_slow;
        else
            clock.p2 = limit->p2.p2_fast;
    }

    max_n = limit->n.max;
    /* based on hardware requirement prefer smaller n to precision */
    for (clock.n = limit->n.min; clock.n <= max_n; clock.n++) {
        /* based on hardware requirement prefere larger m1,m2, p1*/
        for (clock.m1 = limit->m1.max;
            clock.m1 >= limit->m1.min; clock.m1--) {
            for (clock.m2 = limit->m2.max;
                clock.m2 >= limit->m2.min; clock.m2--) {
                for (clock.p1 = limit->p1.max;
                    clock.p1 >= limit->p1.min; clock.p1--) {
                    int this_err;

                    intel_clock (intel, refclk, &clock);
                    if (!i830PllIsValid(crtc, &clock))
                        continue;
                    this_err = abs(clock.dot - target) ;
                    if (this_err < err_most) {
                        memcpy(best_clock, &clock, sizeof(intel_clock_t));
                        err_most = this_err;
                        /* prefer smaller n to precision */
                        max_n = clock.n;
                        found = TRUE;
                    }
                }
            }
        }
    }
    return found;
}

void
i830WaitForVblank(ScrnInfoPtr pScreen)
{
    /* Wait for 20ms, i.e. one cycle at 50hz. */
    usleep(30000);
}

void
i830PipeSetBase(xf86CrtcPtr crtc, int x, int y)
{
    ScrnInfoPtr scrn = crtc->scrn;
    intel_screen_private *intel = intel_get_screen_private(scrn);
    I830CrtcPrivatePtr	intel_crtc = crtc->driver_private;
    int plane = intel_crtc->plane;
    unsigned long Start, Offset, Stride;
    drm_intel_bo *bo;
    int dspbase = (plane == 0 ? DSPABASE : DSPBBASE);
    int dspsurf = (plane == 0 ? DSPASURF : DSPBSURF);
    int dsptileoff = (plane == 0 ? DSPATILEOFF : DSPBTILEOFF);
    int dspstride = (plane == 0) ? DSPASTRIDE : DSPBSTRIDE;

    crtc->x = x;
    crtc->y = y;

    Stride = intel->front_pitch;
    bo = intel->front_buffer;
    Offset = y * Stride + x * intel->cpp;
    if (intel_crtc->rotate_bo != NULL) {
	Stride = intel_crtc->rotate_pitch;
	bo = intel_crtc->rotate_bo;
	Offset = 0;
	x = y = 0;
    }

    /*
     * During startup we may be called as part of monitor detection while
     * there is no memory allocation done, so just supply a dummy base
     * address.
     */
    if (bo == NULL) {
	Start = 0;
    } else {
	Start = bo->offset;
    }

    OUTREG(dspstride, Stride);
    if (IS_I965G(intel)) {
        OUTREG(dspbase, Offset);
	POSTING_READ(dspbase);
        OUTREG(dspsurf, Start);
	POSTING_READ(dspsurf);
	OUTREG(dsptileoff, (y << 16) | x);
    } else {
	OUTREG(dspbase, Start + Offset);
	POSTING_READ(dspbase);
    }
}

/*
 * Both crtc activation and video overlay enablement on pipe B
 * will fail on i830 if pipe A is not running. This function
 * makes sure pipe A is active for these cases
 */

int
i830_crtc_pipe (xf86CrtcPtr crtc)
{
    if (crtc == NULL)
	return 0;
    return ((I830CrtcPrivatePtr) crtc->driver_private)->pipe;
}

static xf86CrtcPtr
i830_crtc_for_pipe (ScrnInfoPtr scrn, int pipe)
{
    xf86CrtcConfigPtr   xf86_config = XF86_CRTC_CONFIG_PTR(scrn);
    int			c;

    for (c = 0; c < xf86_config->num_crtc; c++)
    {
	xf86CrtcPtr crtc = xf86_config->crtc[c];
	if (i830_crtc_pipe (crtc) == pipe)
	    return crtc;
    }
    return NULL;
}

Bool
i830_pipe_a_require_activate (ScrnInfoPtr scrn)
{
    xf86CrtcPtr	crtc = i830_crtc_for_pipe (scrn, 0);
    intel_screen_private *intel = intel_get_screen_private(scrn);
    /* VESA 640x480x72Hz mode to set on the pipe */
    static DisplayModeRec   mode = {
	NULL, NULL, "640x480", MODE_OK, M_T_DEFAULT,
	31500,
	640, 664, 704, 832, 0,
	480, 489, 491, 520, 0,
	V_NHSYNC | V_NVSYNC,
	0, 0,
	0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0,
	FALSE, FALSE, 0, NULL, 0, 0.0, 0.0
    };

    if (HAS_PCH_SPLIT(intel))
	return FALSE;

    if (!crtc)
	return FALSE;
    if (crtc->enabled)
	return FALSE;
    xf86SetModeCrtc (&mode, INTERLACE_HALVE_V);
    crtc->funcs->mode_set (crtc, &mode, &mode, 0, 0);
    crtc->funcs->dpms (crtc, DPMSModeOn);
    return TRUE;
}

void
i830_pipe_a_require_deactivate (ScrnInfoPtr scrn)
{
    xf86CrtcPtr	crtc = i830_crtc_for_pipe (scrn, 0);

    if (!crtc)
	return;
    if (crtc->enabled)
	return;
    crtc->funcs->dpms (crtc, DPMSModeOff);
    return;
}

/* FIXME: use pixmap private instead if possible */
static Bool
i830_display_tiled(xf86CrtcPtr crtc)
{
    ScrnInfoPtr scrn = crtc->scrn;
    I830CrtcPrivatePtr intel_crtc = crtc->driver_private;
    intel_screen_private *intel = intel_get_screen_private(scrn);
    drm_intel_bo *bo = intel->front_buffer;

    if (intel_crtc->rotate_bo != NULL)
	bo = intel_crtc->rotate_bo;

    if (bo != NULL) {
        uint32_t tiling_mode, swizzle;
	if (drm_intel_bo_get_tiling(bo, &tiling_mode, &swizzle) == 0 &&
	    tiling_mode != I915_TILING_NONE)
		return TRUE;
    }

    return FALSE;
}

#if defined(DRM_IOCTL_MODESET_CTL)
static void i830_modeset_ctl(xf86CrtcPtr crtc, int pre)
{
    ScrnInfoPtr scrn = crtc->scrn;
    intel_screen_private *intel = intel_get_screen_private(scrn);
    I830CrtcPrivatePtr intel_crtc = crtc->driver_private;
    struct drm_modeset_ctl modeset;

    if (intel->directRenderingType <= DRI_NONE)
      return;

    modeset.crtc = intel_crtc->pipe;

    /*
     * DPMS will be called many times (especially off), but we only
     * want to catch the transition from on->off and off->on.
     */
    if (pre && intel_crtc->dpms_mode != DPMSModeOff) {
	/* On -> off is a pre modeset */
	modeset.cmd = _DRM_PRE_MODESET;
	ioctl(intel->drmSubFD, DRM_IOCTL_MODESET_CTL, &modeset);
    } else if (!pre && intel_crtc->dpms_mode == DPMSModeOff) {
	/* Off -> on means post modeset */
	modeset.cmd = _DRM_POST_MODESET;
	ioctl(intel->drmSubFD, DRM_IOCTL_MODESET_CTL, &modeset);
    }
}
#else
static void i830_modeset_ctl(xf86CrtcPtr crtc, int dpms_state)
{
    return;
}
#endif /* DRM_IOCTL_MODESET_CTL */

static void
i830_disable_vga_plane (xf86CrtcPtr crtc)
{
    ScrnInfoPtr scrn = crtc->scrn;
    intel_screen_private *intel = intel_get_screen_private(scrn);
    uint8_t sr01 = 0;
    uint32_t vga_reg, vgacntrl;

    if (HAS_PCH_SPLIT(intel))
	vga_reg = CPU_VGACNTRL;
    else
	vga_reg = VGACNTRL;

    vgacntrl = INREG(vga_reg);
    if (vgacntrl & VGA_DISP_DISABLE)
	return;

    /*
     * Bug #17235: G4X machine needs following steps
     * for disable VGA.
     * - set bit 5 of SR01;
     * - Wait 30us;
     * - disable vga plane;
     * - restore SR01;
     */
    if (IS_G4X(intel)) {
	OUTREG8(SRX, 1);
	sr01 = INREG8(SRX + 1);
	OUTREG8(SRX + 1, sr01 | (1 << 5));
	usleep(30);
    }

    while (!(INREG(vga_reg) & VGA_DISP_DISABLE)) {
	vgacntrl |= VGA_DISP_DISABLE;
	OUTREG(vga_reg, vgacntrl);
	i830WaitForVblank(scrn);
    }

    /* restore SR01 */
    if (IS_G4X(intel)) {
	OUTREG8(SRX, 1);
	OUTREG8(SRX + 1, sr01);
    }
}

static void
i830_crtc_enable(xf86CrtcPtr crtc)
{
    ScrnInfoPtr scrn = crtc->scrn;
    intel_screen_private *intel = intel_get_screen_private(scrn);
    I830CrtcPrivatePtr intel_crtc = crtc->driver_private;
    int pipe = intel_crtc->pipe;
    int plane = intel_crtc->plane;
    int dpll_reg = (pipe == 0) ? DPLL_A : DPLL_B;
    int pipeconf_reg = (pipe == 0) ? PIPEACONF : PIPEBCONF;
    int dspcntr_reg = (plane == 0) ? DSPACNTR : DSPBCNTR;
    int dspbase_reg = (plane == 0) ? DSPABASE : DSPBBASE;
    uint32_t temp;

    /* Enable the DPLL */
    temp = INREG(dpll_reg);
    if ((temp & DPLL_VCO_ENABLE) == 0)
    {
	OUTREG(dpll_reg, temp);
	POSTING_READ(dpll_reg);
	/* Wait for the clocks to stabilize. */
	usleep(150);
	OUTREG(dpll_reg, temp | DPLL_VCO_ENABLE);
	POSTING_READ(dpll_reg);
	/* Wait for the clocks to stabilize. */
	usleep(150);
	OUTREG(dpll_reg, temp | DPLL_VCO_ENABLE);
	POSTING_READ(dpll_reg);
	/* Wait for the clocks to stabilize. */
	usleep(150);
    }

    /* Enable the pipe */
    temp = INREG(pipeconf_reg);
    if ((temp & PIPEACONF_ENABLE) == 0)
	OUTREG(pipeconf_reg, temp | PIPEACONF_ENABLE);

    /* Enable the plane */
    temp = INREG(dspcntr_reg);
    if ((temp & DISPLAY_PLANE_ENABLE) == 0)
    {
	OUTREG(dspcntr_reg, temp | DISPLAY_PLANE_ENABLE);
	/* Flush the plane changes */
	OUTREG(dspbase_reg, INREG(dspbase_reg));
    }

    i830_crtc_load_lut(crtc);

    /* Give the overlay scaler a chance to enable if it's on this pipe */
    i830_crtc_dpms_video(crtc, TRUE);

    i830_modeset_ctl(crtc, 0);
}

void
i830_crtc_disable(xf86CrtcPtr crtc, Bool disable_pipe)
{
    ScrnInfoPtr scrn = crtc->scrn;
    intel_screen_private *intel = intel_get_screen_private(scrn);
    I830CrtcPrivatePtr intel_crtc = crtc->driver_private;
    int pipe = intel_crtc->pipe;
    int plane = intel_crtc->plane;
    int dpll_reg = (pipe == 0) ? DPLL_A : DPLL_B;
    int pipeconf_reg = (pipe == 0) ? PIPEACONF : PIPEBCONF;
    int dspcntr_reg = (plane == 0) ? DSPACNTR : DSPBCNTR;
    int dspbase_reg = (plane == 0) ? DSPABASE : DSPBBASE;
    uint32_t temp;

    i830_modeset_ctl(crtc, 1);

    /* Give the overlay scaler a chance to disable if it's on this pipe */
    i830_crtc_dpms_video(crtc, FALSE);

    /* 
     * The documentation says :
     * - Disable planes (VGA or hires)
     * - Disable pipe
     * - Disable VGA display
     */

    /* Disable display plane */
    temp = INREG(dspcntr_reg);
    if ((temp & DISPLAY_PLANE_ENABLE) != 0)
    {
	OUTREG(dspcntr_reg, temp & ~DISPLAY_PLANE_ENABLE);
	/* Flush the plane changes */
	OUTREG(dspbase_reg, INREG(dspbase_reg));
	POSTING_READ(dspbase_reg);
    }

    if (!IS_I9XX(intel)) {
	/* Wait for vblank for the disable to take effect */
	i830WaitForVblank(scrn);
    }

    /* May need to leave pipe A on */
    if (disable_pipe)
    {
	/* Next, disable display pipes */
	temp = INREG(pipeconf_reg);
	if ((temp & PIPEACONF_ENABLE) != 0) {
	    OUTREG(pipeconf_reg, temp & ~PIPEACONF_ENABLE);
	    POSTING_READ(pipeconf_reg);
	}

	/* Wait for vblank for the disable to take effect. */
	i830WaitForVblank(scrn);

	temp = INREG(dpll_reg);
	if ((temp & DPLL_VCO_ENABLE) != 0) {
	    OUTREG(dpll_reg, temp & ~DPLL_VCO_ENABLE);
	    POSTING_READ(dpll_reg);
	}

	/* Wait for the clocks to turn off. */
	usleep(150);
    }

    /* Disable the VGA plane that we never use. */
    i830_disable_vga_plane (crtc);
}

static void ironlake_fdi_link_train(xf86CrtcPtr crtc)
{
    ScrnInfoPtr scrn = crtc->scrn;
    intel_screen_private *intel = intel_get_screen_private(scrn);
    I830CrtcPrivatePtr intel_crtc = crtc->driver_private;
    int pipe = intel_crtc->pipe;
    int fdi_tx_reg = (pipe == 0) ? FDI_TXA_CTL : FDI_TXB_CTL;
    int fdi_rx_reg = (pipe == 0) ? FDI_RXA_CTL : FDI_RXB_CTL;
    int fdi_rx_iir_reg = (pipe == 0) ? FDI_RXA_IIR : FDI_RXB_IIR;
    int fdi_rx_imr_reg = (pipe == 0) ? FDI_RXA_IMR : FDI_RXB_IMR;
    uint32_t temp, tries = 0;
    
    /* enable CPU FDI TX and PCH FDI RX */
    temp = INREG(fdi_tx_reg);
    temp |= FDI_TX_ENABLE;
    temp &= ~(7 << 19);
    temp |= /*(intel_crtc->fdi_lanes - 1)*/3 << 19;
    temp &= ~FDI_LINK_TRAIN_NONE;
    temp |= FDI_LINK_TRAIN_PATTERN_1;
    OUTREG(fdi_tx_reg, temp);
    INREG(fdi_tx_reg);
    
    temp = INREG(fdi_rx_reg);
    temp &= ~FDI_LINK_TRAIN_NONE;
    temp |= FDI_LINK_TRAIN_PATTERN_1;
    OUTREG(fdi_rx_reg, temp | FDI_RX_ENABLE);
    INREG(fdi_rx_reg);
    usleep(150);
    
    /* Train 1: umask FDI RX Interrupt symbol_lock and bit_lock bit
       for train result */
    temp = INREG(fdi_rx_imr_reg);
    temp &= ~FDI_RX_SYMBOL_LOCK;
    temp &= ~FDI_RX_BIT_LOCK;
    OUTREG(fdi_rx_imr_reg, temp);
    INREG(fdi_rx_imr_reg);
    usleep(150);

    for (;;) {
	temp = INREG(fdi_rx_iir_reg);
	ErrorF("FDI_RX_IIR 0x%x\n", temp);
	
	if ((temp & FDI_RX_BIT_LOCK)) {
	    ErrorF("FDI train 1 done.\n");
	    OUTREG(fdi_rx_iir_reg,
		       temp | FDI_RX_BIT_LOCK);
	    break;
	}
	
	tries++;

	if (tries > 5) {
	    ErrorF("FDI train 1 fail!\n");
	    break;
	}
    }
    
    /* Train 2 */
    temp = INREG(fdi_tx_reg);
    temp &= ~FDI_LINK_TRAIN_NONE;
    temp |= FDI_LINK_TRAIN_PATTERN_2;
    OUTREG(fdi_tx_reg, temp);

    temp = INREG(fdi_rx_reg);
    temp &= ~FDI_LINK_TRAIN_NONE;
    temp |= FDI_LINK_TRAIN_PATTERN_2;
    OUTREG(fdi_rx_reg, temp);
    usleep(150);

    tries = 0;

    for (;;) {
	temp = INREG(fdi_rx_iir_reg);
	ErrorF("FDI_RX_IIR 0x%x\n", temp);
	
	if (temp & FDI_RX_SYMBOL_LOCK) {
	    OUTREG(fdi_rx_iir_reg,
		       temp | FDI_RX_SYMBOL_LOCK);
	    ErrorF("FDI train 2 done.\n");
	    break;
	}

	tries++;

	if (tries > 5) {
	    ErrorF("FDI train 2 fail!\n");
	    break;
	}
    }
    
    ErrorF("FDI train done\n");
}

static const int snb_b_fdi_train_param [] = {
        FDI_LINK_TRAIN_400MV_0DB_SNB_B,
        FDI_LINK_TRAIN_400MV_6DB_SNB_B,
        FDI_LINK_TRAIN_600MV_3_5DB_SNB_B,
        FDI_LINK_TRAIN_800MV_0DB_SNB_B,
};

static void gen6_fdi_link_train(xf86CrtcPtr crtc)
{
    ScrnInfoPtr scrn = crtc->scrn;
    intel_screen_private *intel = intel_get_screen_private(scrn);
    I830CrtcPrivatePtr intel_crtc = crtc->driver_private;
    int pipe = intel_crtc->pipe;
    int fdi_tx_reg = (pipe == 0) ? FDI_TXA_CTL : FDI_TXB_CTL;
    int fdi_rx_reg = (pipe == 0) ? FDI_RXA_CTL : FDI_RXB_CTL;
    int fdi_rx_iir_reg = (pipe == 0) ? FDI_RXA_IIR : FDI_RXB_IIR;
    int fdi_rx_imr_reg = (pipe == 0) ? FDI_RXA_IMR : FDI_RXB_IMR;
    uint32_t temp, i = 0;
    
    /* Train 1: umask FDI RX Interrupt symbol_lock and bit_lock bit
       for train result */
    temp = INREG(fdi_rx_imr_reg);
    temp &= ~FDI_RX_SYMBOL_LOCK;
    temp &= ~FDI_RX_BIT_LOCK;
    OUTREG(fdi_rx_imr_reg, temp);
    INREG(fdi_rx_imr_reg);
    usleep(150);

    /* enable CPU FDI TX and PCH FDI RX */
    temp = INREG(fdi_tx_reg);
    temp |= FDI_TX_ENABLE;
    temp &= ~(7 << 19);
    temp |= /*(intel_crtc->fdi_lanes - 1)*/3 << 19;
    temp &= ~FDI_LINK_TRAIN_NONE;
    temp |= FDI_LINK_TRAIN_PATTERN_1;
    temp &= ~FDI_LINK_TRAIN_VOL_EMP_MASK;
    /* SNB-B */
    temp |= FDI_LINK_TRAIN_400MV_0DB_SNB_B;
    OUTREG(fdi_tx_reg, temp);
    INREG(fdi_tx_reg);
    
    temp = INREG(fdi_rx_reg);
    if (HAS_PCH_CPT(intel)) {
        temp &= ~FDI_LINK_TRAIN_PATTERN_MASK_CPT;
        temp |= FDI_LINK_TRAIN_PATTERN_1_CPT;
    } else {
        temp &= ~FDI_LINK_TRAIN_NONE;
        temp |= FDI_LINK_TRAIN_PATTERN_1;
    }
    OUTREG(fdi_rx_reg, temp | FDI_RX_ENABLE);
    INREG(fdi_rx_reg);
    usleep(150);
    
    for (i = 0; i < 4; i++) {
        temp = INREG(fdi_tx_reg);
        temp &= ~FDI_LINK_TRAIN_VOL_EMP_MASK;
        temp |= snb_b_fdi_train_param[i];
        OUTREG(fdi_tx_reg, temp);
        INREG(fdi_tx_reg);
	
        temp = INREG(fdi_rx_iir_reg);
	ErrorF("FDI_RX_IIR 0x%x\n", temp);

	if ((temp & FDI_RX_BIT_LOCK)) {
	    ErrorF("FDI train 1 done.\n");
	    OUTREG(fdi_rx_iir_reg,
		       temp | FDI_RX_BIT_LOCK);
	    break;
	}
    }
    if (i == 4)
	ErrorF("FDI train 1 fail!\n");

    /* Train 2 */
    temp = INREG(fdi_tx_reg);
    temp &= ~FDI_LINK_TRAIN_NONE;
    temp |= FDI_LINK_TRAIN_PATTERN_2;
    if (IS_GEN6(intel)) {
	temp &= ~FDI_LINK_TRAIN_VOL_EMP_MASK;
	/* SNB-B */
	temp |= FDI_LINK_TRAIN_400MV_0DB_SNB_B;
    }
    OUTREG(fdi_tx_reg, temp);

    temp = INREG(fdi_rx_reg);
    if (HAS_PCH_CPT(intel)) {
	temp &= ~FDI_LINK_TRAIN_PATTERN_MASK_CPT;
	temp |= FDI_LINK_TRAIN_PATTERN_2_CPT;
    } else {
	temp &= ~FDI_LINK_TRAIN_NONE;
	temp |= FDI_LINK_TRAIN_PATTERN_2;
    }
    OUTREG(fdi_rx_reg, temp);
    usleep(150);

    for (i = 0; i < 4; i++) {
        temp = INREG(fdi_tx_reg);
        temp &= ~FDI_LINK_TRAIN_VOL_EMP_MASK;
        temp |= snb_b_fdi_train_param[i];
        OUTREG(fdi_tx_reg, temp);
        INREG(fdi_tx_reg);
	
        temp = INREG(fdi_rx_iir_reg);
	ErrorF("FDI_RX_IIR 0x%x\n", temp);

	if ((temp & FDI_RX_SYMBOL_LOCK)) {
	    ErrorF("FDI train 2 done.\n");
	    OUTREG(fdi_rx_iir_reg,
		       temp | FDI_RX_SYMBOL_LOCK);
	    break;
	}
    }
    if (i == 4)
   	ErrorF("FDI train 2 fail!\n");

    ErrorF("FDI train done\n");
}

/* Manual link training for Ivy Bridge A0 parts */
static void ivb_manual_fdi_link_train(xf86CrtcPtr crtc)
{
	ScrnInfoPtr scrn = crtc->scrn;
	intel_screen_private *intel = intel_get_screen_private(scrn);
	I830CrtcPrivatePtr intel_crtc = crtc->driver_private;
	int pipe = intel_crtc->pipe;
	int fdi_tx_reg = (pipe == 0) ? FDI_TXA_CTL : FDI_TXB_CTL;
	int fdi_rx_reg = (pipe == 0) ? FDI_RXA_CTL : FDI_RXB_CTL;
	int fdi_rx_iir_reg = (pipe == 0) ? FDI_RXA_IIR : FDI_RXB_IIR;
	int fdi_rx_imr_reg = (pipe == 0) ? FDI_RXA_IMR : FDI_RXB_IMR;

	uint32_t temp, i;

	/* Train 1: umask FDI RX Interrupt symbol_lock and bit_lock bit
	   for train result */
	temp = INREG(fdi_rx_imr_reg);
	temp &= ~FDI_RX_SYMBOL_LOCK;
	temp &= ~FDI_RX_BIT_LOCK;
	OUTREG(fdi_rx_imr_reg, temp);
	INREG(fdi_rx_imr_reg);
	usleep(150);

	/* enable CPU FDI TX and PCH FDI RX */
	temp = INREG(fdi_tx_reg);
	temp &= ~(7 << 19);
	temp |= /*(intel_crtc->fdi_lanes - 1)*/3 << 19;
	temp &= ~(FDI_LINK_TRAIN_AUTO | FDI_LINK_TRAIN_NONE_IVB);
	temp |= FDI_LINK_TRAIN_PATTERN_1_IVB;
	temp &= ~FDI_LINK_TRAIN_VOL_EMP_MASK;
	temp |= FDI_LINK_TRAIN_400MV_0DB_SNB_B;
	temp |= FDI_COMPOSITE_SYNC;
	OUTREG(fdi_tx_reg, temp | FDI_TX_ENABLE);
	INREG(fdi_tx_reg);

	temp = INREG(fdi_rx_reg);
	temp &= ~FDI_LINK_TRAIN_AUTO;
	temp &= ~FDI_LINK_TRAIN_PATTERN_MASK_CPT;
	temp |= FDI_LINK_TRAIN_PATTERN_1_CPT;
	temp |= FDI_COMPOSITE_SYNC;
	OUTREG(fdi_rx_reg, temp | FDI_RX_ENABLE);
	INREG(fdi_rx_reg);

	usleep(150);
		
	for (i = 0; i < 4; i++) {
		temp = INREG(fdi_tx_reg);
		temp &= ~FDI_LINK_TRAIN_VOL_EMP_MASK;
		temp |= snb_b_fdi_train_param[i];
		OUTREG(fdi_tx_reg, temp);
		INREG(fdi_tx_reg);

		usleep(500);

		temp = INREG(fdi_rx_iir_reg);
		ErrorF("FDI_RX_IIR 0x%x\n", temp);

		if (temp & FDI_RX_BIT_LOCK) {
			OUTREG(fdi_rx_iir_reg,
			           temp | FDI_RX_BIT_LOCK);
			ErrorF("FDI train 1 done.\n");
			break;
		}
	}
	if (i == 4)
		ErrorF("FDI train 1 fail!\n");

	/* Train 2 */
	temp = INREG(fdi_tx_reg);
	temp &= ~FDI_LINK_TRAIN_NONE_IVB;
	temp |= FDI_LINK_TRAIN_PATTERN_2_IVB;
	temp &= ~FDI_LINK_TRAIN_VOL_EMP_MASK;
	temp |= FDI_LINK_TRAIN_400MV_0DB_SNB_B;
	OUTREG(fdi_tx_reg, temp);

	temp = INREG(fdi_rx_reg);
	temp &= ~FDI_LINK_TRAIN_PATTERN_MASK_CPT;
	temp |= FDI_LINK_TRAIN_PATTERN_2_CPT;
	OUTREG(fdi_rx_reg, temp);

	usleep(150);

	for (i = 0; i < 4; i++) {
		temp = INREG(fdi_tx_reg);
		temp &= ~FDI_LINK_TRAIN_VOL_EMP_MASK;
		temp |= snb_b_fdi_train_param[i];
		OUTREG(fdi_tx_reg, temp);
		INREG(fdi_tx_reg);

		usleep(500);

		temp = INREG(fdi_rx_iir_reg);
		ErrorF("FDI_RX_IIR 0x%x\n", temp);

		if (temp & FDI_RX_SYMBOL_LOCK) {
			OUTREG(fdi_rx_iir_reg,
			           temp | FDI_RX_SYMBOL_LOCK);
			ErrorF("FDI train 2 done.\n");
			break;
		}
	}
	if (i == 4)
		ErrorF("FDI train 2 fail!\n");

	ErrorF("FDI train done\n");
}

static void
ironlake_crtc_enable(xf86CrtcPtr crtc)
{
	ScrnInfoPtr scrn = crtc->scrn;
	intel_screen_private *intel = intel_get_screen_private(scrn);
	I830CrtcPrivatePtr intel_crtc = crtc->driver_private;
	int pipe = intel_crtc->pipe;
	int plane = intel_crtc->plane;
	int pch_dpll_reg = (pipe == 0) ? PCH_DPLL_A : PCH_DPLL_B;
	int pipeconf_reg = (pipe == 0) ? PIPEACONF : PIPEBCONF;
	int dspcntr_reg = (plane == 0) ? DSPACNTR : DSPBCNTR;
	int dspbase_reg = (plane == 0) ? DSPABASE : DSPBBASE;
	int fdi_tx_reg = (pipe == 0) ? FDI_TXA_CTL : FDI_TXB_CTL;
	int fdi_rx_reg = (pipe == 0) ? FDI_RXA_CTL : FDI_RXB_CTL;
	int transconf_reg = (pipe == 0) ? TRANSACONF : TRANSBCONF;
	int pf_ctl_reg = (pipe == 0) ? PFA_CTL_1 : PFB_CTL_1;
	int pf_win_size = (pipe == 0) ? PFA_WIN_SZ : PFB_WIN_SZ;
	int pf_win_pos = (pipe == 0) ? PFA_WIN_POS : PFB_WIN_POS;
	int cpu_htot_reg = (pipe == 0) ? HTOTAL_A : HTOTAL_B;
	int cpu_hblank_reg = (pipe == 0) ? HBLANK_A : HBLANK_B;
	int cpu_hsync_reg = (pipe == 0) ? HSYNC_A : HSYNC_B;
	int cpu_vtot_reg = (pipe == 0) ? VTOTAL_A : VTOTAL_B;
	int cpu_vblank_reg = (pipe == 0) ? VBLANK_A : VBLANK_B;
	int cpu_vsync_reg = (pipe == 0) ? VSYNC_A : VSYNC_B;
	int trans_htot_reg = (pipe == 0) ? TRANS_HTOTAL_A : TRANS_HTOTAL_B;
	int trans_hblank_reg = (pipe == 0) ? TRANS_HBLANK_A : TRANS_HBLANK_B;
	int trans_hsync_reg = (pipe == 0) ? TRANS_HSYNC_A : TRANS_HSYNC_B;
	int trans_vtot_reg = (pipe == 0) ? TRANS_VTOTAL_A : TRANS_VTOTAL_B;
	int trans_vblank_reg = (pipe == 0) ? TRANS_VBLANK_A : TRANS_VBLANK_B;
	int trans_vsync_reg = (pipe == 0) ? TRANS_VSYNC_A : TRANS_VSYNC_B;
	uint32_t temp, pipe_bpc;

	temp = INREG(pipeconf_reg);
	pipe_bpc = temp & PIPE_BPC_MASK;

	/* XXX no LVDS port force */
	if (i830PipeHasType(crtc, I830_OUTPUT_LVDS)) {
	    temp = INREG(PCH_LVDS);
	    if ((temp & LVDS_PORT_EN) == 0) {
		OUTREG(PCH_LVDS, temp | LVDS_PORT_EN);
		INREG(PCH_LVDS);
	    }
	}

	ErrorF("PCH FDI RX PLL enable\n");
	temp = INREG(fdi_rx_reg);
	temp &= ~(0x7 << 16);
	temp |= (pipe_bpc << 11);
	temp &= ~(FDI_DP_PORT_WIDTH_MASK);
	temp |= FDI_DP_PORT_WIDTH_X4;

	OUTREG(fdi_rx_reg, temp | FDI_RX_PLL_ENABLE); /* default 4 lanes */
	INREG(fdi_rx_reg);
	usleep(200);

	/* Switch from Rawclk to PCDclk */
	temp = INREG(fdi_rx_reg);
	OUTREG(fdi_rx_reg, temp | FDI_SEL_PCDCLK); 
	temp = INREG(fdi_rx_reg);
	usleep(200);

	ErrorF("PCH FDI TX PLL enable %08x\n", temp);
	temp = INREG(fdi_tx_reg);
	if ((temp & FDI_TX_PLL_ENABLE) == 0) {
	    OUTREG(fdi_tx_reg, temp | FDI_TX_PLL_ENABLE);
	    INREG(fdi_tx_reg);
	    usleep(100);
	}

	i830WaitForVblank(scrn);


	/* Enable panel fitting for LVDS */
#define PF_FILTER_MASK		(3<<23)
#define PF_FILTER_MED_3x3	(1<<23)
	if (i830PipeHasType(crtc, I830_OUTPUT_LVDS)) {
	    temp = INREG(pf_ctl_reg);
	    temp &= ~PF_FILTER_MASK;
	    OUTREG(pf_ctl_reg, temp | PF_ENABLE | PF_FILTER_MED_3x3);
	    /* currently full aspect */
	    OUTREG(pf_win_pos, 0);
	    OUTREG(pf_win_size, (intel->lvds_fixed_mode->HDisplay << 16) |
		(intel->lvds_fixed_mode->VDisplay));
	}

	ErrorF("Pipe enable\n");
	/* Enable CPU pipe */
	temp = INREG(pipeconf_reg);
	if ((temp & PIPEACONF_ENABLE) == 0) {
	    OUTREG(pipeconf_reg, temp | PIPEACONF_ENABLE);
	    INREG(pipeconf_reg);
	    usleep(100);
	}

	ErrorF("Plane enable\n");
	/* configure and enable CPU plane */
	temp = INREG(dspcntr_reg);
	if ((temp & DISPLAY_PLANE_ENABLE) == 0) {
	    OUTREG(dspcntr_reg, temp | DISPLAY_PLANE_ENABLE);
	    /* Flush the plane changes */
	    OUTREG(dspbase_reg, INREG(dspbase_reg));
	    usleep(10);
	}
	/* twice, like the BIOS */
	OUTREG(dspcntr_reg, temp | DISPLAY_PLANE_ENABLE);

	/* Train FDI. */
	if (IS_GEN6(intel))
		gen6_fdi_link_train(crtc);
	else if (IS_IVYBRIDGE(intel))
		ivb_manual_fdi_link_train(crtc);
	else
		ironlake_fdi_link_train(crtc);

	/* enable PCH DPLL */
	temp = INREG(pch_dpll_reg);
	if ((temp & DPLL_VCO_ENABLE) == 0) {
	    OUTREG(pch_dpll_reg, temp | DPLL_VCO_ENABLE);
	    INREG(pch_dpll_reg);
	}
	usleep(200);

	if (HAS_PCH_CPT(intel)) {
		/* Be sure PCH DPLL SEL is set */
		temp = INREG(PCH_DPLL_SEL);
		if (pipe == 0 && (temp & TRANSA_DPLL_ENABLE) == 0)
			temp |= (TRANSA_DPLL_ENABLE | TRANSA_DPLLA_SEL);
		else if (pipe == 1 && (temp & TRANSB_DPLL_ENABLE) == 0)
			temp |= (TRANSB_DPLL_ENABLE | TRANSB_DPLLB_SEL);
		OUTREG(PCH_DPLL_SEL, temp);
	}

	/* set transcoder timing */
	OUTREG(trans_htot_reg, INREG(cpu_htot_reg));
	OUTREG(trans_hblank_reg, INREG(cpu_hblank_reg));
	OUTREG(trans_hsync_reg, INREG(cpu_hsync_reg));

	OUTREG(trans_vtot_reg, INREG(cpu_vtot_reg));
	OUTREG(trans_vblank_reg, INREG(cpu_vblank_reg));
	OUTREG(trans_vsync_reg, INREG(cpu_vsync_reg));

	/* enable normal train */

	ErrorF("FDI TX link normal\n");
	temp = INREG(fdi_tx_reg);
	if (IS_IVYBRIDGE(intel)) {
		temp &= ~FDI_LINK_TRAIN_NONE_IVB;
		temp |= FDI_LINK_TRAIN_NONE_IVB | FDI_TX_ENHANCE_FRAME_ENABLE;
	} else {
		temp &= ~FDI_LINK_TRAIN_NONE;
		temp |= FDI_LINK_TRAIN_NONE | FDI_TX_ENHANCE_FRAME_ENABLE;
	}
	OUTREG(fdi_tx_reg, temp);
	INREG(fdi_tx_reg);

	temp = INREG(fdi_rx_reg);
        if (HAS_PCH_CPT(intel)) {
                temp &= ~FDI_LINK_TRAIN_PATTERN_MASK_CPT;
                temp |= FDI_LINK_TRAIN_NORMAL_CPT;
        } else {
                temp &= ~FDI_LINK_TRAIN_NONE;
                temp |= FDI_LINK_TRAIN_NONE;
        }
	OUTREG(fdi_rx_reg, temp | FDI_RX_ENHANCE_FRAME_ENABLE);
	INREG(fdi_rx_reg);

	usleep(100);

	ErrorF("transcoder enable\n");
	/* enable transcoder */
	temp = INREG(transconf_reg);
	temp &= ~PIPE_BPC_MASK;
	temp |= pipe_bpc;
	OUTREG(transconf_reg, temp | TRANS_ENABLE);
	INREG(transconf_reg);

	while ((INREG(transconf_reg) & TRANS_STATE_ENABLE) == 0)
	    ;

	ErrorF("LUT load\n");
	i830_crtc_load_lut(crtc);

	ErrorF("DPMS on done\n");

	i830_modeset_ctl(crtc, 0);
}

void
ironlake_crtc_disable(xf86CrtcPtr crtc)
{
	ScrnInfoPtr scrn = crtc->scrn;
	intel_screen_private *intel = intel_get_screen_private(scrn);
	I830CrtcPrivatePtr intel_crtc = crtc->driver_private;
	int pipe = intel_crtc->pipe;
	int plane = intel_crtc->plane;
	int pch_dpll_reg = (pipe == 0) ? PCH_DPLL_A : PCH_DPLL_B;
	int pipeconf_reg = (pipe == 0) ? PIPEACONF : PIPEBCONF;
	int dspcntr_reg = (plane == 0) ? DSPACNTR : DSPBCNTR;
	int dspbase_reg = (plane == 0) ? DSPABASE : DSPBBASE;
	int fdi_tx_reg = (pipe == 0) ? FDI_TXA_CTL : FDI_TXB_CTL;
	int fdi_rx_reg = (pipe == 0) ? FDI_RXA_CTL : FDI_RXB_CTL;
	int transconf_reg = (pipe == 0) ? TRANSACONF : TRANSBCONF;
	int pf_ctl_reg = (pipe == 0) ? PFA_CTL_1 : PFB_CTL_1;
	int pf_win_size = (pipe == 0) ? PFA_WIN_SZ : PFB_WIN_SZ;
	uint32_t temp, pipe_bpc;
	int n;

	i830_modeset_ctl(crtc, 1);

	temp = INREG(pipeconf_reg);
	pipe_bpc = temp & PIPE_BPC_MASK;

	ErrorF("Plane disable\n");
	temp = INREG(dspcntr_reg);
	if ((temp & DISPLAY_PLANE_ENABLE) != 0) {
		OUTREG(dspcntr_reg, temp & ~DISPLAY_PLANE_ENABLE);
		/* flush plane changes */
		OUTREG(dspbase_reg, INREG(dspbase_reg));
		INREG(dspbase_reg);
	}

	i830_disable_vga_plane (crtc);

	ErrorF("Pipe disable\n");
	/* disable cpu pipe, disable after all planes disabled */
	temp = INREG(pipeconf_reg);
	if ((temp & PIPEACONF_ENABLE) != 0) {
	    OUTREG(pipeconf_reg, temp & ~PIPEACONF_ENABLE);
	    INREG(pipeconf_reg);
	    n = 0;
	    /* wait for cpu pipe off, pipe state */
	    while ((INREG(pipeconf_reg) & I965_PIPECONF_ACTIVE) != 0) {
		n++;
		if (n < 60) {
		    usleep(500);
		    continue;
		} else {
		    ErrorF("aborting pipeconf disable early\n");
		    break;
		}
	    }
	}

	usleep(100);

	ErrorF("PFIT disable\n");
	temp = INREG(pf_ctl_reg);
	if ((temp & PF_ENABLE) != 0) {
		OUTREG(pf_ctl_reg, temp & ~PF_ENABLE);
		INREG(pf_ctl_reg);
	}
	OUTREG(pf_win_size, 0);
	INREG(pf_win_size);

	ErrorF("FDI RX disable\n");
	temp = INREG(fdi_rx_reg);
	temp &= ~(0x07 << 16);
	temp |= pipe_bpc << 11;
	OUTREG(fdi_rx_reg, temp & ~FDI_RX_ENABLE);
	INREG(fdi_rx_reg);

	usleep(100);

	ErrorF("FDI TX disable\n");
	temp = INREG(fdi_tx_reg);
	OUTREG(fdi_tx_reg, temp & ~FDI_TX_ENABLE);
	INREG(fdi_tx_reg);

	usleep(100);

	ErrorF("FDI RX train 1 preload\n");
	temp = INREG(fdi_rx_reg);
	if (HAS_PCH_CPT(intel)) {
		temp &= ~FDI_LINK_TRAIN_PATTERN_MASK_CPT;
		temp |= FDI_LINK_TRAIN_PATTERN_1_CPT;
	} else {
		temp &= ~FDI_LINK_TRAIN_NONE;
		temp |= FDI_LINK_TRAIN_PATTERN_1;
	}
	OUTREG(fdi_rx_reg, temp);
	INREG(fdi_rx_reg);

	usleep(100);

	ErrorF("FDI TX train 1 preload\n");
	/* still set train pattern 1 */
	temp = INREG(fdi_tx_reg);
	temp &= ~FDI_LINK_TRAIN_NONE;
	temp |= FDI_LINK_TRAIN_PATTERN_1;
	OUTREG(fdi_tx_reg, temp);
	INREG(fdi_tx_reg);

	usleep(100);

	if (i830PipeHasType(crtc, I830_OUTPUT_LVDS)) {
	    ErrorF("LVDS port force off\n");
	    while ((temp = INREG(PCH_LVDS)) & PORT_ENABLE) {
		OUTREG(PCH_LVDS, temp & ~LVDS_PORT_EN);
		INREG(PCH_LVDS);
		usleep(100);
	    }
	}

	ErrorF("Transcoder disable\n");
	/* disable PCH transcoder */
	temp = INREG(transconf_reg);
	if ((temp & TRANS_STATE_ENABLE) != 0) {
	    OUTREG(transconf_reg, temp & ~TRANS_ENABLE);
	    INREG(transconf_reg);
	    n = 0;
	    /* wait for PCH transcoder off, transcoder state */
	    while ((INREG(transconf_reg) & TRANS_STATE_ENABLE) != 0) {
		n++;
		if (n < 600) {
		    usleep(500);
		    continue;
		} else {
		    ErrorF("aborting transcoder disable early, 0x%08x\n", INREG(transconf_reg));
		    break;
		}
	    }
	}

	temp = INREG(transconf_reg);
	temp &= ~PIPE_BPC_MASK;
	temp |= pipe_bpc;
	OUTREG(transconf_reg, temp);
	INREG(transconf_reg);
	usleep(100);

	if (HAS_PCH_CPT(intel)) {
		/* disable DPLL_SEL */
		temp = INREG(PCH_DPLL_SEL);
		switch (pipe) {
		case 0:
			temp &= ~(TRANSA_DPLL_ENABLE | TRANSA_DPLLB_SEL);
			break;
		case 1:
			temp &= ~(TRANSB_DPLL_ENABLE | TRANSB_DPLLB_SEL);
			break;
		case 2:
			/* C shares PLL A or B */
			temp &= ~(TRANSC_DPLL_ENABLE | TRANSC_DPLLB_SEL);
			break;
		}
		OUTREG(PCH_DPLL_SEL, temp);
		INREG(PCH_DPLL_SEL);
	}

	ErrorF("PCH DPLL disable\n");
	/* disable PCH DPLL */
	temp = INREG(pch_dpll_reg);
	OUTREG(pch_dpll_reg, temp & ~DPLL_VCO_ENABLE);
	INREG(pch_dpll_reg);

	ErrorF("FDI RX PLL PCD disable\n");
	/* Switch from PCDclk to Rawclk */
	temp = INREG(fdi_rx_reg);
	temp &= ~FDI_SEL_PCDCLK;
	OUTREG(fdi_rx_reg, temp);
	temp = INREG(fdi_rx_reg);

	ErrorF("FDI TX PLL disable %08x\n", temp);
	temp = INREG(fdi_tx_reg);
	temp &= ~FDI_TX_PLL_ENABLE;
	OUTREG(fdi_tx_reg, temp);
	temp = INREG(fdi_tx_reg);
	usleep(100);

	ErrorF("FDI RX PLL disable %08x\n", temp);
	temp = INREG(fdi_tx_reg);
	OUTREG(fdi_tx_reg, temp & ~FDI_TX_PLL_ENABLE);
	INREG(fdi_tx_reg);
	usleep(100);

	ErrorF("DPMS off done\n");
	/* Wait for the clocks to turn off. */
	usleep(150);
}

static void ironlake_crtc_dpms(xf86CrtcPtr crtc, int mode)
{
    I830CrtcPrivatePtr intel_crtc = crtc->driver_private;

    if (intel_crtc->pipe != intel_crtc->plane)
	FatalError("pipe/plane mismatch, aborting\n");

    /* XXX: When our outputs are all unaware of DPMS modes other than off
     * and on, we should map those modes to DRM_MODE_DPMS_OFF in the CRTC.
     */
    switch (mode) {
    case DPMSModeOn:
    case DPMSModeStandby:
    case DPMSModeSuspend:
	ironlake_crtc_enable(crtc);
	break;
    case DPMSModeOff:
	ironlake_crtc_disable(crtc);
	intel_crtc->enabled = FALSE;
	break;
    }
}

/**
 * Sets the power management mode of the pipe and plane.
 *
 * This code should probably grow support for turning the cursor off and back
 * on appropriately at the same time as we're turning the pipe off/on.
 */
static void
i9xx_crtc_dpms(xf86CrtcPtr crtc, int mode)
{
    ScrnInfoPtr scrn = crtc->scrn;
    intel_screen_private *intel = intel_get_screen_private(scrn);
    I830CrtcPrivatePtr intel_crtc = crtc->driver_private;
    int pipe = intel_crtc->pipe;
    Bool disable_pipe = TRUE;

    /* XXX: When our outputs are all unaware of DPMS modes other than off and
     * on, we should map those modes to DPMSModeOff in the CRTC.
     */
    switch (mode) {
    case DPMSModeOn:
    case DPMSModeStandby:
    case DPMSModeSuspend:
	i830_crtc_enable(crtc);
	break;
    case DPMSModeOff:
	if ((pipe == 0) && (intel->quirk_flag & QUIRK_PIPEA_FORCE))
	    disable_pipe = FALSE;
	i830_crtc_disable(crtc, disable_pipe);
	intel_crtc->enabled = FALSE;
	break;
    }
}

static void
i830_crtc_dpms(xf86CrtcPtr crtc, int mode)
{
    ScrnInfoPtr scrn = crtc->scrn;
    intel_screen_private *intel = intel_get_screen_private(scrn);
    I830CrtcPrivatePtr intel_crtc = crtc->driver_private;

    if (HAS_PCH_SPLIT(intel))
	ironlake_crtc_dpms(crtc, mode);
    else
	i9xx_crtc_dpms(crtc, mode);

    intel_crtc->dpms_mode = mode;
}

static Bool
i830_crtc_lock (xf86CrtcPtr crtc)
{
    /* Sync the engine before mode switch, to finish any outstanding
     * WAIT_FOR_EVENTS that may rely on CRTC state.
     */
    intel_sync(crtc->scrn);

    return FALSE;
}

static void
i830_crtc_unlock (xf86CrtcPtr crtc)
{
}

static void
i830_crtc_prepare (xf86CrtcPtr crtc)
{
    I830CrtcPrivatePtr	intel_crtc = crtc->driver_private;
    if (intel_crtc->enabled)
	crtc->funcs->hide_cursor (crtc);
    crtc->funcs->dpms (crtc, DPMSModeOff);
}

static void
i830_crtc_commit (xf86CrtcPtr crtc)
{
    I830CrtcPrivatePtr	intel_crtc = crtc->driver_private;
    Bool		deactivate = FALSE;

    if (!intel_crtc->enabled && intel_crtc->pipe != 0)
	deactivate = i830_pipe_a_require_activate (crtc->scrn);
    
    intel_crtc->enabled = TRUE;
    
    crtc->funcs->dpms (crtc, DPMSModeOn);
    if (crtc->scrn->pScreen != NULL)
	xf86_reload_cursors (crtc->scrn->pScreen);
    if (deactivate)
	i830_pipe_a_require_deactivate (crtc->scrn);
}

void
i830_output_prepare (xf86OutputPtr output)
{
    output->funcs->dpms (output, DPMSModeOff);
}

void
i830_output_commit (xf86OutputPtr output)
{
    output->funcs->dpms (output, DPMSModeOn);
}

static Bool
i830_crtc_mode_fixup(xf86CrtcPtr crtc, DisplayModePtr mode,
		     DisplayModePtr adjusted_mode)
{
    ScrnInfoPtr scrn = crtc->scrn;
    intel_screen_private *intel = intel_get_screen_private(scrn);

    if (HAS_PCH_SPLIT(intel)) {
	/* FDI link clock is fixed at 2.7G */
	if (mode->Clock * 3 > 27000 * 4)
	    return MODE_CLOCK_HIGH;
    }

    return TRUE;
}

/** Returns the core display clock speed for i830 - i945 */
static int
i830_get_core_clock_speed(ScrnInfoPtr scrn)
{
    intel_screen_private *intel = intel_get_screen_private(scrn);

    /* Core clock values taken from the published datasheets.
     * The 830 may go up to 166 Mhz, which we should check.
     */
    if (IS_I945G(intel) || (IS_G33CLASS(intel) && !IS_IGDGM(intel)))
	return 400000;
    else if (IS_I915G(intel))
	return 333000;
    else if (IS_I945GM(intel) || IS_845G(intel) || IS_IGDGM(intel))
	return 200000;
    else if (IS_I915GM(intel)) {
	uint16_t gcfgc;

      pci_device_cfg_read_u16 (intel->PciInfo, &gcfgc, I915_GCFGC);
      if (gcfgc & I915_LOW_FREQUENCY_ENABLE)
	    return 133000;
	else {
	    switch (gcfgc & I915_DISPLAY_CLOCK_MASK) {
	    case I915_DISPLAY_CLOCK_333_MHZ:
		return 333000;
	    default:
	    case I915_DISPLAY_CLOCK_190_200_MHZ:
		return 190000;
	    }
	}
    } else if (IS_I865G(intel))
	return 266000;
    else if (IS_I855(intel)) {
        struct pci_device *bridge = intel_host_bridge ();
	uint16_t hpllcc;
	pci_device_cfg_read_u16 (bridge, &hpllcc, I855_HPLLCC);

	/* Assume that the hardware is in the high speed state.  This
	 * should be the default.
	 */
	switch (hpllcc & I855_CLOCK_CONTROL_MASK) {
	case I855_CLOCK_133_200:
	case I855_CLOCK_100_200:
	    return 200000;
	case I855_CLOCK_166_250:
	    return 250000;
	case I855_CLOCK_100_133:
	    return 133000;
	}
    } else /* 852, 830 */
	return 133000;

    return 0; /* Silence gcc warning */
}

/**
 * Return the pipe currently connected to the panel fitter,
 * or -1 if the panel fitter is not present or not in use
 */
static int
i830_panel_fitter_pipe(intel_screen_private *intel)
{
    uint32_t pfit_control;

    /* i830 doesn't have a panel fitter */
    if (IS_I830(intel))
	return -1;

    pfit_control = INREG(PFIT_CONTROL);

    /* See if the panel fitter is in use */
    if ((pfit_control & PFIT_ENABLE) == 0)
	return -1;

    /* 965 can place panel fitter on either pipe */
    if (IS_I965G(intel))
	return (pfit_control & PFIT_PIPE_MASK) >> PFIT_PIPE_SHIFT;

    /* older chips can only use pipe 1 */
    return 1;
}

/**
 * Sets up the DSPARB register to split the display fifo appropriately between
 * the display planes.
 *
 * Adjusting this register requires that the planes be off.
 */
static void
i830_update_dsparb(ScrnInfoPtr scrn)
{
   xf86CrtcConfigPtr xf86_config = XF86_CRTC_CONFIG_PTR(scrn);
   intel_screen_private *intel = intel_get_screen_private(scrn);
   int total_hdisplay = 0, planea_hdisplay = 0, planeb_hdisplay = 0;
   int fifo_entries = 0, planea_entries = 0, planeb_entries = 0, i;

   if ((INREG(DSPACNTR) & DISPLAY_PLANE_ENABLE) &&
       (INREG(DSPBCNTR) & DISPLAY_PLANE_ENABLE))
       xf86DrvMsg(scrn->scrnIndex, X_ERROR,
		  "tried to update DSPARB with both planes enabled!\n");

  /*
    * FIFO entries will be split based on programmed modes
    */
   if (IS_I965GM(intel))
       fifo_entries = 127;
   else if (IS_I9XX(intel))
       fifo_entries = 95;
   else if (IS_MOBILE(intel)) {
       fifo_entries = 255;
   } else {
	/* The 845/865 only have a AEND field.  Though the field size would
	* allow 128 entries, the 865 rendered the cursor wrong then.
	* The BIOS set it up for 96.
	*/
	fifo_entries = 95;
   }

   for (i = 0; i < xf86_config->num_crtc; i++) {
      xf86CrtcPtr crtc = xf86_config->crtc[i];
      I830CrtcPrivatePtr intel_crtc = crtc->driver_private;
      if (crtc->enabled) {
	  total_hdisplay += crtc->mode.HDisplay;
	  if (intel_crtc->plane == 0)
	      planea_hdisplay = crtc->mode.HDisplay;
	  else
	      planeb_hdisplay = crtc->mode.HDisplay;
      }
   }

   planea_entries = fifo_entries * planea_hdisplay / total_hdisplay;
   planeb_entries = fifo_entries * planeb_hdisplay / total_hdisplay;

   if (IS_I9XX(intel))
       OUTREG(DSPARB,
	      ((planea_entries + planeb_entries) << DSPARB_CSTART_SHIFT) |
	      (planea_entries << DSPARB_BSTART_SHIFT));
   else if (IS_MOBILE(intel))
       OUTREG(DSPARB,
	      ((planea_entries + planeb_entries) << DSPARB_BEND_SHIFT) |
	      (planea_entries << DSPARB_AEND_SHIFT));
   else
       OUTREG(DSPARB, planea_entries << DSPARB_AEND_SHIFT);
}

struct fdi_m_n {
    CARD32        tu;
    CARD32        gmch_m;
    CARD32        gmch_n;
    CARD32        link_m;
    CARD32        link_n;
};

static void
fdi_reduce_ratio(CARD32 *num, CARD32 *den)
{
    while (*num > 0xffffff || *den > 0xffffff) {
	*num >>= 1;
	*den >>= 1;
    }
}

#define DATA_N 0x800000
#define LINK_N 0x80000

static void
igdng_compute_m_n(int bits_per_pixel, int nlanes,
		  int pixel_clock, int link_clock,
		  struct fdi_m_n *m_n)
{
    uint64_t temp;

    m_n->tu = 64; /* default size */

    temp = (uint64_t) DATA_N * pixel_clock;
    temp = temp / link_clock;
    m_n->gmch_m = (temp * bits_per_pixel) / nlanes;
    m_n->gmch_m >>= 3; /* convert to bytes per pixel */
    m_n->gmch_n = DATA_N;
    fdi_reduce_ratio(&m_n->gmch_m, &m_n->gmch_n);

    temp = (uint64_t) LINK_N * pixel_clock;
    m_n->link_m = temp / link_clock;
    m_n->link_n = LINK_N;
    fdi_reduce_ratio(&m_n->link_m, &m_n->link_n);
}

/**
 * Sets up registers for the given mode/adjusted_mode pair.
 *
 * The clocks, CRTCs and outputs attached to this CRTC must be off.
 *
 * This shouldn't enable any clocks, CRTCs, or outputs, but they should
 * be easily turned on/off after this.
 */
static void
i830_crtc_mode_set(xf86CrtcPtr crtc, DisplayModePtr mode,
		   DisplayModePtr adjusted_mode,
		   int x, int y)
{
    ScrnInfoPtr scrn = crtc->scrn;
    xf86CrtcConfigPtr   xf86_config = XF86_CRTC_CONFIG_PTR(scrn);
    intel_screen_private *intel = intel_get_screen_private(scrn);
    I830CrtcPrivatePtr intel_crtc = crtc->driver_private;
    I830OutputPrivatePtr intel_output;
    int pipe = intel_crtc->pipe;
    int plane = intel_crtc->plane;
    int fp_reg = (pipe == 0) ? FPA0 : FPB0;
    int dpll_reg = (pipe == 0) ? DPLL_A : DPLL_B;
    int dpll_md_reg = (pipe == 0) ? DPLL_A_MD : DPLL_B_MD;
    int pipeconf_reg = (pipe == 0) ? PIPEACONF : PIPEBCONF;
    int htot_reg = (pipe == 0) ? HTOTAL_A : HTOTAL_B;
    int hblank_reg = (pipe == 0) ? HBLANK_A : HBLANK_B;
    int hsync_reg = (pipe == 0) ? HSYNC_A : HSYNC_B;
    int vtot_reg = (pipe == 0) ? VTOTAL_A : VTOTAL_B;
    int vblank_reg = (pipe == 0) ? VBLANK_A : VBLANK_B;
    int vsync_reg = (pipe == 0) ? VSYNC_A : VSYNC_B;
    int pipesrc_reg = (pipe == 0) ? PIPEASRC : PIPEBSRC;
    int dspcntr_reg = (plane == 0) ? DSPACNTR : DSPBCNTR;
    int dsppos_reg = (plane == 0) ? DSPAPOS : DSPBPOS;
    int dspsize_reg = (plane == 0) ? DSPASIZE : DSPBSIZE;
    int i, num_outputs = 0;
    int refclk;
    intel_clock_t clock;
    uint32_t dpll = 0, fp = 0, dspcntr, pipeconf, lvds_bits = 0;
    Bool ok, is_sdvo = FALSE, is_dvo = FALSE;
    Bool is_crt = FALSE, is_lvds = FALSE, is_tv = FALSE;
    const intel_limit_t *limit;

    struct fdi_m_n m_n = {0};
    int data_m1_reg = (pipe == 0) ? PIPEA_DATA_M1 : PIPEB_DATA_M1;
    int data_n1_reg = (pipe == 0) ? PIPEA_DATA_N1 : PIPEB_DATA_N1;
    int link_m1_reg = (pipe == 0) ? PIPEA_LINK_M1 : PIPEB_LINK_M1;
    int link_n1_reg = (pipe == 0) ? PIPEA_LINK_N1 : PIPEB_LINK_N1;
    int pch_fp_reg = (pipe == 0) ? PCH_FPA0 : PCH_FPB0;
    int pch_dpll_reg = (pipe == 0) ? PCH_DPLL_A : PCH_DPLL_B;
    int fdi_rx_reg = (pipe == 0) ? FDI_RXA_CTL : FDI_RXB_CTL;
    int fdi_tx_reg = (pipe == 0) ? FDI_TXA_CTL : FDI_TXB_CTL;
    int lvds_reg = LVDS;
    uint32_t temp;
    int sdvo_pixel_multiply;

    /* Set up some convenient bools for what outputs are connected to
     * our pipe, used in DPLL setup.
     */
    for (i = 0; i < xf86_config->num_output; i++) {
	xf86OutputPtr  output = xf86_config->output[i];
	intel_output = output->driver_private;

	if (output->crtc != crtc)
	    continue;

	switch (intel_output->type) {
	case I830_OUTPUT_LVDS:
	    is_lvds = TRUE;
	    lvds_bits = intel_output->lvds_bits;
	    break;
	case I830_OUTPUT_SDVO:
	case I830_OUTPUT_HDMI:
	    is_sdvo = TRUE;
	    if (intel_output->needs_tv_clock)
		is_tv = TRUE;
	    break;
	case I830_OUTPUT_DVO_TMDS:
	case I830_OUTPUT_DVO_LVDS:
	case I830_OUTPUT_DVO_TVOUT:
	    is_dvo = TRUE;
	    break;
	case I830_OUTPUT_TVOUT:
	    is_tv = TRUE;
	    break;
	case I830_OUTPUT_ANALOG:
	    is_crt = TRUE;
	    break;
	}

	num_outputs++;
    }

    if (num_outputs > 1)
	xf86DrvMsg(scrn->scrnIndex, X_INFO, "clone detected, disabling SSC\n");

    /* Don't use SSC when cloned */
    if (is_lvds && intel->lvds_use_ssc && num_outputs < 2) {
	refclk = intel->lvds_ssc_freq * 1000;
	xf86DrvMsg(scrn->scrnIndex, X_INFO,
		   "using SSC reference clock of %d MHz\n", refclk / 1000);
    } else if (IS_I9XX(intel)) {
	refclk = 96000;
	if (HAS_PCH_SPLIT(intel))
	    refclk = 120000; /* 120Mhz refclk */
    } else {
	refclk = 48000;
    }

    /*
     * Returns a set of divisors for the desired target clock with the given
     * refclk, or FALSE.  The returned values represent the clock equation:
     * reflck * (5 * (m1 + 2) + (m2 + 2)) / (n + 2) / p1 / p2.
     */
    limit = intel_limit (crtc);
    ok = limit->find_pll(limit, crtc, adjusted_mode->Clock, refclk, &clock);
    if (!ok)
	FatalError("Couldn't find PLL settings for mode!\n");

    if (fabs(adjusted_mode->Clock - clock.dot) / clock.dot > .02) {
	xf86DrvMsg(scrn->scrnIndex, X_WARNING,
		   "Chosen PLL clock of %.1f Mhz more than 2%% away from "
		   "desired %.1f Mhz\n",
		   (float)clock.dot / 1000,
		   (float)adjusted_mode->Clock / 1000);
    }

    /* SDVO TV has fixed PLL values depends on its clock range,
       this mirrors vbios setting. */
    if (is_sdvo && is_tv) {
	if (adjusted_mode->Clock >= 100000 &&
		adjusted_mode->Clock < 140500) {
	    clock.p1 = 2;
	    clock.p2 = 10;
	    clock.n = 3;
	    clock.m1 = 16;
	    clock.m2 = 8;
	} else if (adjusted_mode->Clock >= 140500 &&
		adjusted_mode->Clock <= 200000) {
	    clock.p1 = 1;
	    clock.p2 = 10;
	    clock.n = 6;
	    clock.m1 = 12;
	    clock.m2 = 8;
	}
    }

    if (HAS_PCH_SPLIT(intel)) {
	int bpp = 24;
	if (is_lvds) {
	    uint32_t lvds_reg = INREG(PCH_LVDS);

	    if (!((lvds_reg & LVDS_A3_POWER_MASK) == LVDS_A3_POWER_UP))
		bpp = 18;
	}

	igdng_compute_m_n(bpp, 4, /* lane num 4 */
			  adjusted_mode->Clock,
			  270000, /* lane clock */
			  &m_n);
	ErrorF("bpp %d\n", bpp / 3);
	intel_crtc->bpc = bpp / 3;
    }

    if (HAS_PCH_SPLIT(intel)) {
	uint32_t temp;

	temp = INREG(PCH_DREF_CONTROL);
	/* Always enable nonspread source */
	temp &= ~DREF_NONSPREAD_SOURCE_MASK;
	temp |= DREF_NONSPREAD_SOURCE_ENABLE;
	OUTREG(PCH_DREF_CONTROL, temp);
	temp = INREG(PCH_DREF_CONTROL);

	temp &= ~DREF_SSC_SOURCE_MASK;
	temp |= DREF_SSC_SOURCE_ENABLE;
	OUTREG(PCH_DREF_CONTROL, temp);
	temp = INREG(PCH_DREF_CONTROL);
    }

    if (IS_IGD(intel))
	fp = (1 << clock.n) << 16 | clock.m1 << 8 | clock.m2;
    else
	fp = clock.n << 16 | clock.m1 << 8 | clock.m2;

    if (!HAS_PCH_SPLIT(intel))
	dpll = DPLL_VGA_MODE_DIS;
    if (IS_I9XX(intel)) {
	if (is_lvds)
	    dpll |= DPLLB_MODE_LVDS;
	else
	    dpll |= DPLLB_MODE_DAC_SERIAL;
	if (is_sdvo)
	{
	    dpll |= DPLL_DVO_HIGH_SPEED;
	    sdvo_pixel_multiply = adjusted_mode->Clock / mode->Clock;
	    if ((IS_I945G(intel) || IS_I945GM(intel) || IS_G33CLASS(intel)))
		dpll |= (sdvo_pixel_multiply - 1) << SDVO_MULTIPLIER_SHIFT_HIRES;
	    else if (HAS_PCH_SPLIT(intel))
		dpll |= (sdvo_pixel_multiply - 1) << PLL_REF_SDVO_HDMI_MULTIPLIER_SHIFT;
		
	}
	
	/* compute bitmask from p1 value */
	if (IS_IGD(intel))
	    dpll |= (1 << (clock.p1 - 1)) << DPLL_FPA01_P1_POST_DIV_SHIFT_IGD;
	else
	    dpll |= (1 << (clock.p1 - 1)) << DPLL_FPA01_P1_POST_DIV_SHIFT;
	switch (clock.p2) {
	case 5:
	    dpll |= DPLL_DAC_SERIAL_P2_CLOCK_DIV_5;
	    break;
	case 7:
	    dpll |= DPLLB_LVDS_P2_CLOCK_DIV_7;
	    break;
	case 10:
	    dpll |= DPLL_DAC_SERIAL_P2_CLOCK_DIV_10;
	    break;
	case 14:
	    dpll |= DPLLB_LVDS_P2_CLOCK_DIV_14;
	    break;
	}
	if (IS_I965G(intel) && !IS_GM45(intel) && !HAS_PCH_SPLIT(intel))
	    dpll |= (6 << PLL_LOAD_PULSE_PHASE_SHIFT);
    } else {
	if (is_lvds) {
	    dpll |= (1 << (clock.p1 - 1)) << DPLL_FPA01_P1_POST_DIV_SHIFT;
	} else {
	    if (clock.p1 == 2)
		dpll |= PLL_P1_DIVIDE_BY_TWO;
	    else
		dpll |= (clock.p1 - 2) << DPLL_FPA01_P1_POST_DIV_SHIFT;
	    if (clock.p2 == 4)
		dpll |= PLL_P2_DIVIDE_BY_4;
	}
    }

    if (is_sdvo && is_tv)
	dpll |= PLL_REF_INPUT_TVCLKINBC;
    else if (is_tv)
    {
	/* XXX: just matching BIOS for now */
/*	dpll |= PLL_REF_INPUT_TVCLKINBC; */
	dpll |= 3;
    }
    else if (is_lvds && intel->lvds_use_ssc && num_outputs < 2)
	dpll |= PLLB_REF_INPUT_SPREADSPECTRUMIN;
    else
	dpll |= PLL_REF_INPUT_DREFCLK;

    /* Set up the display plane register */
    dspcntr = DISPPLANE_GAMMA_ENABLE;
    /* this is "must be enabled" in the docs, but not set by bios */
    if (HAS_PCH_SPLIT(intel))
	dspcntr |= DISPPLANE_TRICKLE_FEED_DISABLE;

    switch (scrn->bitsPerPixel) {
    case 8:
	dspcntr |= DISPPLANE_8BPP;
	break;
    case 16:
	if (scrn->depth == 15)
	    dspcntr |= DISPPLANE_15_16BPP;
	else
	    dspcntr |= DISPPLANE_16BPP;
	break;
    case 32:
	dspcntr |= DISPPLANE_32BPP_NO_ALPHA;
	break;
    default:
	FatalError("unknown display bpp\n");
    }

    /* Ironlake's plane is forced to pipe, bit 24 is to
       enable color space conversion */
    if (!HAS_PCH_SPLIT(intel)) {
	if (pipe == 0)
	    dspcntr |= DISPPLANE_SEL_PIPE_A;
	else
	    dspcntr |= DISPPLANE_SEL_PIPE_B;
    }

    if (IS_I965G(intel) && i830_display_tiled(crtc))
	dspcntr |= DISPLAY_PLANE_TILED;

    pipeconf = INREG(pipeconf_reg);
    if (pipe == 0 && !IS_I965G(intel))
    {
	/* Enable pixel doubling when the dot clock is > 90% of the (display)
	 * core speed.
	 *
	 * XXX: No double-wide on 915GM pipe B. Is that the only reason for the
	 * pipe == 0 check?
	 */
	if (mode->Clock > i830_get_core_clock_speed(scrn) * 9 / 10)
	    pipeconf |= PIPEACONF_DOUBLE_WIDE;
	else
	    pipeconf &= ~PIPEACONF_DOUBLE_WIDE;
    }

    if (HAS_PCH_SPLIT(intel)) {
	pipeconf &= ~(7 << 5);
	if (intel_crtc->bpc == 6)
	    pipeconf |= (1 << 6); /* 0 is 8bpc */
	if (intel_crtc->bpc != 8)
	    pipeconf |= (1 << 4); /* enable dithering */
    }

    /*
     * This "shouldn't" be needed as the dpms on code
     * will be run after the mode is set. On 9xx, it helps.
     * On 855, it can lock up the chip (and the entire machine)
     */
    if (!IS_I85X (intel) && !HAS_PCH_SPLIT(intel))
    {
	dspcntr |= DISPLAY_PLANE_ENABLE;
	pipeconf |= PIPEACONF_ENABLE;
	dpll |= DPLL_VCO_ENABLE;
    }
    
    /* Disable the panel fitter if it was on our pipe */
    if (!HAS_PCH_SPLIT(intel) && i830_panel_fitter_pipe (intel) == pipe)
	OUTREG(PFIT_CONTROL, 0);

    if (intel->debug_modes) {
	xf86DrvMsg(scrn->scrnIndex, X_INFO,
		   "Mode for pipe %c:\n", pipe == 0 ? 'A' : 'B');
	xf86PrintModeline(scrn->scrnIndex, mode);
	if (!xf86ModesEqual(mode, adjusted_mode)) {
	    xf86DrvMsg(scrn->scrnIndex, X_INFO,
		       "Adjusted mode for pipe %c:\n", pipe == 0 ? 'A' : 'B');
	    xf86PrintModeline(scrn->scrnIndex, adjusted_mode);
	}
	i830PrintPll(scrn, "chosen", &clock);
    }

    /* assign to PCH registers */
    if (HAS_PCH_SPLIT(intel)) {
	fp_reg = pch_fp_reg;
	dpll_reg = pch_dpll_reg;
    }

    if (dpll & DPLL_VCO_ENABLE)
    {
	OUTREG(fp_reg, fp);
	OUTREG(dpll_reg, dpll & ~DPLL_VCO_ENABLE);
	POSTING_READ(dpll_reg);
	usleep(150);
    }

    /* The LVDS pin pair needs to be on before the DPLLs are enabled.
     * This is an exception to the general rule that mode_set doesn't turn
     * things on.
     */
    if (is_lvds)
    {
	uint32_t lvds;

	if (HAS_PCH_SPLIT(intel))
	    lvds_reg = PCH_LVDS;

	lvds = INREG(lvds_reg);
	lvds |= LVDS_PORT_EN | LVDS_A0A2_CLKA_POWER_UP;
	if (HAS_PCH_CPT(intel)) {
	    lvds &= ~PORT_TRANS_SEL_MASK;
	    lvds |= PORT_TRANS_SEL_CPT(pipe);
	} else {
	    if (pipe == 1)
		lvds |= LVDS_PIPEB_SELECT;	
	    else
		lvds &= ~LVDS_PIPEB_SELECT;
	}

	/* Set the B0-B3 data pairs corresponding to whether we're going to
	 * set the DPLLs for dual-channel mode or not.
	 */
	if (clock.p2 == I9XX_P2_LVDS_FAST)
	    lvds |= LVDS_B0B3_POWER_UP | LVDS_CLKB_POWER_UP;
	else
	    lvds &= ~(LVDS_B0B3_POWER_UP | LVDS_CLKB_POWER_UP);

	if (intel->lvds_24_bit_mode) {
	    /* Option set which requests 24-bit mode
	     * (LVDS_A3_POWER_UP, as opposed to 18-bit mode) here; we
	     * still need to look more thoroughly into how panels
	     * behave in the two modes.  This option enables that
	     * experimentation.
	     */
	    xf86DrvMsg(scrn->scrnIndex, X_INFO,
		       "Selecting less common 24 bit TMDS pixel format.\n");
	    lvds |= LVDS_A3_POWER_UP;
	    lvds |= LVDS_DATA_FORMAT_DOT_ONE;
	} else {
	    xf86DrvMsg(scrn->scrnIndex, X_INFO,
		       "Selecting standard 18 bit TMDS pixel format.\n");
	}

	/* Enable dithering if we're in 18-bit mode. */
	if (IS_I965G(intel))
	{
	    if ((lvds & LVDS_A3_POWER_MASK) == LVDS_A3_POWER_UP)
		lvds &= ~LVDS_DITHER_ENABLE;
	    else
		lvds |= LVDS_DITHER_ENABLE;
	}

	lvds |= lvds_bits;

	OUTREG(lvds_reg, lvds);
	POSTING_READ(lvds_reg);
    }

    if (HAS_PCH_SPLIT(intel)) {
	    /* For non-DP output, clear any trans DP clock recovery setting.*/
	    if (pipe == 0) {
		    OUTREG(TRANSA_DATA_M1, 0);
		    OUTREG(TRANSA_DATA_N1, 0);
		    OUTREG(TRANSA_DP_LINK_M1, 0);
		    OUTREG(TRANSA_DP_LINK_N1, 0);
	    } else {
		    OUTREG(TRANSB_DATA_M1, 0);
		    OUTREG(TRANSB_DATA_N1, 0);
		    OUTREG(TRANSB_DP_LINK_M1, 0);
		    OUTREG(TRANSB_DP_LINK_N1, 0);
	    }
    }

    OUTREG(fp_reg, fp);
/*    OUTREG(fp_reg + 4, fp); RHEL had this... wtf? */
    OUTREG(dpll_reg, dpll);
    POSTING_READ(dpll_reg);
    /* Wait for the clocks to stabilize. */
    usleep(150);
    
    if (IS_I965G(intel) && !HAS_PCH_SPLIT(intel)) {
	int sdvo_pixel_multiply = adjusted_mode->Clock / mode->Clock;
	OUTREG(dpll_md_reg, (0 << DPLL_MD_UDI_DIVIDER_SHIFT) |
	       ((sdvo_pixel_multiply - 1) << DPLL_MD_UDI_MULTIPLIER_SHIFT));
    } else {
	/* write it again -- the BIOS does, after all */
	OUTREG(dpll_reg, dpll);
    }
    POSTING_READ(dpll_reg);
    /* Wait for the clocks to stabilize. */
    usleep(150);

    if (!DSPARB_HWCONTROL(intel))
	i830_update_dsparb(scrn);

    OUTREG(htot_reg, (adjusted_mode->CrtcHDisplay - 1) |
	((adjusted_mode->CrtcHTotal - 1) << 16));
    OUTREG(hblank_reg, (adjusted_mode->CrtcHBlankStart - 1) |
	((adjusted_mode->CrtcHBlankEnd - 1) << 16));
    OUTREG(hsync_reg, (adjusted_mode->CrtcHSyncStart - 1) |
	((adjusted_mode->CrtcHSyncEnd - 1) << 16));
    OUTREG(vtot_reg, (adjusted_mode->CrtcVDisplay - 1) |
	((adjusted_mode->CrtcVTotal - 1) << 16));

    OUTREG(vblank_reg, (adjusted_mode->CrtcVBlankStart - 1) |
	((adjusted_mode->CrtcVBlankEnd - 1) << 16));
    OUTREG(vsync_reg, (adjusted_mode->CrtcVSyncStart - 1) |
	((adjusted_mode->CrtcVSyncEnd - 1) << 16));
    /* pipesrc and dspsize control the size that is scaled from, which should
     * always be the user's requested size.
     */
    if (!HAS_PCH_SPLIT(intel)) {
	    OUTREG(dspsize_reg, ((mode->VDisplay - 1) << 16) | (mode->HDisplay - 1));
	    OUTREG(dsppos_reg, 0);
    }
    OUTREG(pipesrc_reg, ((mode->HDisplay - 1) << 16) | (mode->VDisplay - 1));

    if (HAS_PCH_SPLIT(intel)) {
	OUTREG(data_m1_reg, TU_SIZE(m_n.tu) | m_n.gmch_m);
	OUTREG(data_n1_reg, m_n.gmch_n);
	OUTREG(link_m1_reg, m_n.link_m);
	OUTREG(link_n1_reg, m_n.link_n);

	/* enable FDI RX PLL too */
	temp = INREG(fdi_rx_reg);
	OUTREG(fdi_rx_reg, temp | FDI_RX_PLL_ENABLE);
	INREG(fdi_rx_reg);
	usleep(200);

	temp = INREG(fdi_tx_reg);
	OUTREG(fdi_tx_reg, temp | FDI_TX_PLL_ENABLE);
	INREG(fdi_tx_reg);

	temp = INREG(fdi_rx_reg);
	OUTREG(fdi_rx_reg, temp | FDI_RX_PLL_ENABLE);
	INREG(fdi_rx_reg);
	usleep(200);
    }

    OUTREG(pipeconf_reg, pipeconf);
    POSTING_READ(pipeconf_reg);
    i830WaitForVblank(scrn);

    if (IS_GEN5(intel)) {
	/* enable address swizzle for tiling buffer */
	temp = INREG(DISP_ARB_CTL);
	OUTREG(DISP_ARB_CTL, temp | DISP_TILE_SURFACE_SWIZZLING);
    }

    OUTREG(dspcntr_reg, dspcntr);
    /* Flush the plane changes */
    i830PipeSetBase(crtc, x, y);

    i830WaitForVblank(scrn);
}


/** Loads the palette/gamma unit for the CRTC with the prepared values */
static void
i830_crtc_load_lut(xf86CrtcPtr crtc)
{
    ScrnInfoPtr scrn = crtc->scrn;
    intel_screen_private *intel = intel_get_screen_private(scrn);
    I830CrtcPrivatePtr intel_crtc = crtc->driver_private;
    int palreg = (intel_crtc->pipe == 0) ? PALETTE_A : PALETTE_B;
    int i;

    /* The clocks have to be on to load the palette. */
    if (!crtc->enabled)
	return;

    /* use legacy palette for Ironlake */
    if (HAS_PCH_SPLIT(intel))
	palreg = (intel_crtc->pipe == 0) ? LGC_PALETTE_A : LGC_PALETTE_B;

    for (i = 0; i < 256; i++) {
	OUTREG(palreg + 4 * i,
	       (intel_crtc->lut_r[i] << 16) |
	       (intel_crtc->lut_g[i] << 8) |
	       intel_crtc->lut_b[i]);
    }
}

/** Sets the color ramps on behalf of RandR */
static void
i830_crtc_gamma_set(xf86CrtcPtr crtc, CARD16 *red, CARD16 *green, CARD16 *blue,
		    int size)
{
    ScrnInfoPtr scrn = crtc->scrn;
    intel_screen_private *intel = intel_get_screen_private(scrn);
    I830CrtcPrivatePtr intel_crtc = crtc->driver_private;
    int i;

    assert(size == 256);

    for (i = 0; i < 256; i++) {
	intel_crtc->lut_r[i] = red[i] >> 8;
	intel_crtc->lut_g[i] = green[i] >> 8;
	intel_crtc->lut_b[i] = blue[i] >> 8;
    }

    /*
     * 855 at least really doesn't seem like like you poking its
     * pallette registers other than at mode set time. so just disable
     * this for now on 8xx. Stops hard machine lockups for me.
     */
    if (IS_I9XX(intel))
	i830_crtc_load_lut(crtc);
}

/**
 * Allocates memory for a locked-in-framebuffer shadow of the given
 * width and height for this CRTC's rotated shadow framebuffer.
 */
 
static void *
i830_crtc_shadow_allocate (xf86CrtcPtr crtc, int width, int height)
{
    ScrnInfoPtr scrn = crtc->scrn;
    intel_screen_private *intel = intel_get_screen_private(scrn);
    I830CrtcPrivatePtr intel_crtc = crtc->driver_private;
    unsigned long rotate_pitch;
    uint32_t tiling;

    assert(intel_crtc->rotate_bo == NULL);
    intel_crtc->rotate_bo = intel_allocate_framebuffer(scrn, width, height,
        intel->cpp, &rotate_pitch, &tiling);
    if (intel_crtc->rotate_bo == NULL) {
	xf86DrvMsg(scrn->scrnIndex, X_ERROR,
		   "Couldn't allocate shadow memory for rotated CRTC\n");
	return NULL;
    }

    intel_crtc->rotate_pitch = rotate_pitch;
    return intel_crtc->rotate_bo;
}
    
/**
 * Creates a pixmap for this CRTC's rotated shadow framebuffer.
 */
static PixmapPtr
i830_crtc_shadow_create(xf86CrtcPtr crtc, void *data, int width, int height)
{
    ScrnInfoPtr scrn = crtc->scrn;
    intel_screen_private *intel = intel_get_screen_private(scrn);
    I830CrtcPrivatePtr intel_crtc = crtc->driver_private;
    PixmapPtr rotate_pixmap;

    if (!data) {
	data = i830_crtc_shadow_allocate (crtc, width, height);
	if (!data) {
	    xf86DrvMsg(scrn->scrnIndex, X_ERROR,
		"Couldn't allocate shadow pixmap for rotated CRTC\n");
		return NULL;
	}
    }

    if (intel_crtc->rotate_bo == NULL) {
	xf86DrvMsg(scrn->scrnIndex, X_ERROR,
		   "Couldn't allocate shadow pixmap for rotated CRTC\n");
	return NULL;
    }
    
    rotate_pixmap = GetScratchPixmapHeader(scrn->pScreen,
					   width, height,
					   scrn->depth,
					   scrn->bitsPerPixel,
					   intel_crtc->rotate_pitch,
					   NULL);

    if (rotate_pixmap == NULL) {
	xf86DrvMsg(scrn->scrnIndex, X_ERROR,
		   "Couldn't allocate shadow pixmap for rotated CRTC\n");
        return NULL;
    }
    intel_set_pixmap_bo(rotate_pixmap, intel_crtc->rotate_bo);

    intel->shadow_present = TRUE;

    return rotate_pixmap;
}

static void
i830_crtc_shadow_destroy(xf86CrtcPtr crtc, PixmapPtr rotate_pixmap, void *data)
{
    ScrnInfoPtr scrn = crtc->scrn;
    intel_screen_private *intel = intel_get_screen_private(scrn);
    I830CrtcPrivatePtr intel_crtc = crtc->driver_private;

    if (rotate_pixmap) {
	intel_set_pixmap_bo(rotate_pixmap, NULL);
	FreeScratchPixmapHeader(rotate_pixmap);
    }

    if (data) {
	/* Be sure to sync acceleration before the memory gets unbound. */
	intel_sync(scrn);
	if (scrn->vtSema)
		(void)dri_bo_unpin(intel_crtc->rotate_bo);
	drm_intel_bo_unreference(intel_crtc->rotate_bo);
	intel_crtc->rotate_bo = NULL;
    }

    intel->shadow_present = intel->use_shadow;
}

#if RANDR_13_INTERFACE
static void
i830_crtc_set_origin(xf86CrtcPtr crtc, int x, int y)
{
    if (crtc->enabled)
	i830PipeSetBase(crtc, x, y);
}
#endif

/* The screen bo has changed, reset each active crtc to point at
 * the same location that it currently points at, but in the new bo
 */
void
i830_set_new_crtc_bo(ScrnInfoPtr scrn)
{
    xf86CrtcConfigPtr   xf86_config = XF86_CRTC_CONFIG_PTR(scrn);
    int			i;

    for (i = 0; i < xf86_config->num_crtc; i++) {
	xf86CrtcPtr crtc = xf86_config->crtc[i];

	if (crtc->enabled && !crtc->transform_in_use)
	    i830PipeSetBase(crtc, crtc->x, crtc->y);
    }
}

void
i830DescribeOutputConfiguration(ScrnInfoPtr scrn)
{
    xf86CrtcConfigPtr   xf86_config = XF86_CRTC_CONFIG_PTR(scrn);
    intel_screen_private *intel = intel_get_screen_private(scrn);
    int i;

    xf86DrvMsg(scrn->scrnIndex, X_INFO, "Output configuration:\n");

    for (i = 0; i < xf86_config->num_crtc; i++) {
	xf86CrtcPtr crtc = xf86_config->crtc[i];
	I830CrtcPrivatePtr intel_crtc = crtc ? crtc->driver_private : NULL;
	uint32_t dspcntr = intel_crtc->plane == 0 ? INREG(DSPACNTR) :
	    INREG(DSPBCNTR);
	uint32_t pipeconf = i == 0 ? INREG(PIPEACONF) :
	    INREG(PIPEBCONF);
	Bool hw_plane_enable = (dspcntr & DISPLAY_PLANE_ENABLE) != 0;
	Bool hw_pipe_enable = (pipeconf & PIPEACONF_ENABLE) != 0;
	int pipe;

	if (HAS_PCH_SPLIT(intel))
	    pipe = intel_crtc->plane;
	else
	    pipe = !!(dspcntr & DISPPLANE_SEL_PIPE_MASK);

	xf86DrvMsg(scrn->scrnIndex, X_INFO,
		   "  Pipe %c is %s\n",
		   'A' + i, crtc->enabled ? "on" : "off");
	xf86DrvMsg(scrn->scrnIndex, X_INFO,
		   "  Display plane %c is now %s and connected to pipe %c.\n",
		   'A' + intel_crtc->plane,
		   hw_plane_enable ? "enabled" : "disabled",
		   'A' + pipe);
	if (hw_pipe_enable != crtc->enabled) {
	    xf86DrvMsg(scrn->scrnIndex, X_WARNING,
		       "  Hardware claims pipe %c is %s while software "
		       "believes it is %s\n",
		       'A' + i, hw_pipe_enable ? "on" : "off",
		       crtc->enabled ? "on" : "off");
	}
	if (hw_plane_enable != crtc->enabled) {
	    xf86DrvMsg(scrn->scrnIndex, X_WARNING,
		       "  Hardware claims plane %c is %s while software "
		       "believes it is %s\n",
		       'A' + i, hw_plane_enable ? "on" : "off",
		       crtc->enabled ? "on" : "off");
	}
    }

    for (i = 0; i < xf86_config->num_output; i++) {
	xf86OutputPtr	output = xf86_config->output[i];
	xf86CrtcPtr	crtc = output->crtc;
	I830CrtcPrivatePtr	intel_crtc = crtc ? crtc->driver_private : NULL;
	
	xf86DrvMsg(scrn->scrnIndex, X_INFO,
		   "  Output %s is connected to pipe %s\n",
		   output->name, intel_crtc == NULL ? "none" :
		   (intel_crtc->pipe == 0 ? "A" : "B"));
    }
}

/**
 * Get a pipe with a simple mode set on it for doing load-based monitor
 * detection.
 *
 * It will be up to the load-detect code to adjust the pipe as appropriate for
 * its requirements.  The pipe will be connected to no other outputs.
 *
 * Currently this code will only succeed if there is a pipe with no outputs
 * configured for it.  In the future, it could choose to temporarily disable
 * some outputs to free up a pipe for its use.
 *
 * \return crtc, or NULL if no pipes are available.
 */
    
/* VESA 640x480x72Hz mode to set on the pipe */
static DisplayModeRec   load_detect_mode = {
    NULL, NULL, "640x480", MODE_OK, M_T_DEFAULT,
    31500,
    640, 664, 704, 832, 0,
    480, 489, 491, 520, 0,
    V_NHSYNC | V_NVSYNC,
    0, 0,

    640, 640, 664, 704, 832, 832, 0,
    480, 489, 489, 491, 520, 520,
    FALSE, FALSE, 0, NULL, 0, 0.0, 0.0
};

xf86CrtcPtr
i830GetLoadDetectPipe(xf86OutputPtr output, DisplayModePtr mode, int *dpms_mode)
{
    ScrnInfoPtr		    scrn = output->scrn;
    xf86CrtcConfigPtr	    xf86_config = XF86_CRTC_CONFIG_PTR(scrn);
    I830OutputPrivatePtr    intel_output = output->driver_private;
    I830CrtcPrivatePtr	    intel_crtc;
    xf86CrtcPtr		    supported_crtc =NULL;
    xf86CrtcPtr		    crtc = NULL;
    int			    i;

    if (output->crtc) 
    {
	crtc = output->crtc;
	/*
	 * Make sure the crtc and output are running
	 */
	intel_crtc = crtc->driver_private;
	*dpms_mode = intel_crtc->dpms_mode;
	if (intel_crtc->dpms_mode != DPMSModeOn)
	{
	    crtc->funcs->dpms (crtc, DPMSModeOn);
	    output->funcs->dpms (output, DPMSModeOn);
	}
	return crtc;
    }

    for (i = 0; i < xf86_config->num_crtc; i++)
    {
	xf86CrtcPtr possible_crtc;
	if (!(output->possible_crtcs & (1 << i)))
	    continue;
	possible_crtc = xf86_config->crtc[i];
	if (!possible_crtc->enabled)
	{
	    crtc = possible_crtc;
	    break;
	}
	if (!supported_crtc)
	    supported_crtc = possible_crtc;
    }
    if (!crtc)
    {
	crtc = supported_crtc;
	if (!crtc)
	    return NULL;
    }

    output->crtc = crtc;
    intel_output->load_detect_temp = TRUE;
    
    intel_crtc = crtc->driver_private;
    *dpms_mode = intel_crtc->dpms_mode;

    if (!crtc->enabled)
    {
	if (!mode)
	    mode = &load_detect_mode;
	xf86CrtcSetMode (crtc, mode, RR_Rotate_0, 0, 0);
    }
    else
    {
	if (intel_crtc->dpms_mode != DPMSModeOn)
	    crtc->funcs->dpms (crtc, DPMSModeOn);

	/* Add this output to the crtc */
	output->funcs->mode_set (output, &crtc->mode, &crtc->mode);
	output->funcs->commit (output);
    }
    /* let the output get through one full cycle before testing */
    i830WaitForVblank (scrn);

    return crtc;
}

void
i830ReleaseLoadDetectPipe(xf86OutputPtr output, int dpms_mode)
{
    ScrnInfoPtr		    scrn = output->scrn;
    I830OutputPrivatePtr    intel_output = output->driver_private;
    xf86CrtcPtr		    crtc = output->crtc;
    
    if (intel_output->load_detect_temp) 
    {
	output->crtc = NULL;
	intel_output->load_detect_temp = FALSE;
	crtc->enabled = xf86CrtcInUse (crtc);
	xf86DisableUnusedFunctions(scrn);
    }
    /*
     * Switch crtc and output back off if necessary
     */
    if (crtc->enabled && dpms_mode != DPMSModeOn)
    {
	if (output->crtc == crtc)
	    output->funcs->dpms (output, dpms_mode);
	crtc->funcs->dpms (crtc, dpms_mode);
    }
}

/* Returns the clock of the currently programmed mode of the given pipe. */
static int
i830_crtc_clock_get(ScrnInfoPtr scrn, xf86CrtcPtr crtc)
{
    intel_screen_private *intel = intel_get_screen_private(scrn);
    I830CrtcPrivatePtr	intel_crtc = crtc->driver_private;
    int pipe = intel_crtc->pipe;
    uint32_t dpll = INREG((pipe == 0) ? DPLL_A : DPLL_B);
    uint32_t fp;
    intel_clock_t clock;

    if ((dpll & DISPLAY_RATE_SELECT_FPA1) == 0)
	fp = INREG((pipe == 0) ? FPA0 : FPB0);
    else
	fp = INREG((pipe == 0) ? FPA1 : FPB1);

    clock.m1 = (fp & FP_M1_DIV_MASK) >> FP_M1_DIV_SHIFT;
    if (IS_IGD(intel)) {
	clock.n = ffs((fp & FP_N_IGD_DIV_MASK) >> FP_N_DIV_SHIFT) - 1;
	clock.m2 = (fp & FP_M2_IGD_DIV_MASK) >> FP_M2_DIV_SHIFT;
    } else {
	clock.n = (fp & FP_N_DIV_MASK) >> FP_N_DIV_SHIFT;
	clock.m2 = (fp & FP_M2_DIV_MASK) >> FP_M2_DIV_SHIFT;
    }
    if (IS_I9XX(intel)) {
	if (IS_IGD(intel))
	    clock.p1 = ffs((dpll & DPLL_FPA01_P1_POST_DIV_MASK_IGD) >>
			   DPLL_FPA01_P1_POST_DIV_SHIFT_IGD);
	else
	    clock.p1 = ffs((dpll & DPLL_FPA01_P1_POST_DIV_MASK) >>
			   DPLL_FPA01_P1_POST_DIV_SHIFT);

	switch (dpll & DPLL_MODE_MASK) {
	case DPLLB_MODE_DAC_SERIAL:
	    clock.p2 = dpll & DPLL_DAC_SERIAL_P2_CLOCK_DIV_5 ? 5 : 10;
	    break;
	case DPLLB_MODE_LVDS:
	    clock.p2 = dpll & DPLLB_LVDS_P2_CLOCK_DIV_7 ? 7 : 14;
	    break;
	default:
	    xf86DrvMsg(scrn->scrnIndex, X_WARNING,
		       "Unknown DPLL mode %08x in programmed mode\n",
		       (int)(dpll & DPLL_MODE_MASK));
	    return 0;
	}

	if ((dpll & PLL_REF_INPUT_MASK) == PLLB_REF_INPUT_SPREADSPECTRUMIN)
	    intel_clock(intel, 100000, &clock);
	else
	    intel_clock(intel, 96000, &clock);
    } else {
	Bool is_lvds = (pipe == 1) && (INREG(LVDS) & LVDS_PORT_EN);

	if (is_lvds) {
	    clock.p1 = ffs((dpll & DPLL_FPA01_P1_POST_DIV_MASK_I830_LVDS) >>
			   DPLL_FPA01_P1_POST_DIV_SHIFT);

	    /* if LVDS is dual-channel, p2 = 7 */
	    if ((INREG(LVDS) & LVDS_CLKB_POWER_MASK) == LVDS_CLKB_POWER_UP)
		clock.p2 = 7;
	    else
		clock.p2 = 14;

	    if ((dpll & PLL_REF_INPUT_MASK) == PLLB_REF_INPUT_SPREADSPECTRUMIN)
		intel_clock(intel, 66000, &clock); /* XXX: might not be 66MHz */
	    else
		intel_clock(intel, 48000, &clock);
	} else {
	    if (dpll & PLL_P1_DIVIDE_BY_TWO) {
		clock.p1 = 2;
	    } else {
		clock.p1 = ((dpll & DPLL_FPA01_P1_POST_DIV_MASK_I830) >>
		    DPLL_FPA01_P1_POST_DIV_SHIFT) + 2;
	    }
	    if (dpll & PLL_P2_DIVIDE_BY_4)
		clock.p2 = 4;
	    else
		clock.p2 = 2;

	    intel_clock(intel, 48000, &clock);
	}
    }

    /* XXX: It would be nice to validate the clocks, but we can't reuse
     * i830PllIsValid() because it relies on the xf86_config output
     * configuration being accurate, which it isn't necessarily.
     */
    if (0)
	i830PrintPll(scrn, "probed", &clock);

    return clock.dot;
}

/** Returns the currently programmed mode of the given pipe. */
DisplayModePtr
i830_crtc_mode_get(ScrnInfoPtr scrn, xf86CrtcPtr crtc)
{
    intel_screen_private *intel = intel_get_screen_private(scrn);
    I830CrtcPrivatePtr	intel_crtc = crtc->driver_private;
    int pipe = intel_crtc->pipe;
    DisplayModePtr mode;
    int htot = INREG((pipe == 0) ? HTOTAL_A : HTOTAL_B);
    int hsync = INREG((pipe == 0) ? HSYNC_A : HSYNC_B);
    int vtot = INREG((pipe == 0) ? VTOTAL_A : VTOTAL_B);
    int vsync = INREG((pipe == 0) ? VSYNC_A : VSYNC_B);

    mode = calloc(1, sizeof(DisplayModeRec));
    if (mode == NULL)
	return NULL;

    mode->Clock = i830_crtc_clock_get(scrn, crtc);
    mode->HDisplay = (htot & 0xffff) + 1;
    mode->HTotal = ((htot & 0xffff0000) >> 16) + 1;
    mode->HSyncStart = (hsync & 0xffff) + 1;
    mode->HSyncEnd = ((hsync & 0xffff0000) >> 16) + 1;
    mode->VDisplay = (vtot & 0xffff) + 1;
    mode->VTotal = ((vtot & 0xffff0000) >> 16) + 1;
    mode->VSyncStart = (vsync & 0xffff) + 1;
    mode->VSyncEnd = ((vsync & 0xffff0000) >> 16) + 1;
    xf86SetModeDefaultName(mode);
    xf86SetModeCrtc(mode, 0);

    return mode;
}

static const xf86CrtcFuncsRec i830_crtc_funcs = {
    .dpms = i830_crtc_dpms,
    .save = NULL, /* XXX */
    .restore = NULL, /* XXX */
    .lock = i830_crtc_lock,
    .unlock = i830_crtc_unlock,
    .mode_fixup = i830_crtc_mode_fixup,
    .prepare = i830_crtc_prepare,
    .mode_set = i830_crtc_mode_set,
    .commit = i830_crtc_commit,
    .gamma_set = i830_crtc_gamma_set,
    .shadow_create = i830_crtc_shadow_create,
    .shadow_allocate = i830_crtc_shadow_allocate,
    .shadow_destroy = i830_crtc_shadow_destroy,
    .set_cursor_colors = i830_crtc_set_cursor_colors,
    .set_cursor_position = i830_crtc_set_cursor_position,
    .show_cursor = i830_crtc_show_cursor,
    .hide_cursor = i830_crtc_hide_cursor,
    .load_cursor_argb = i830_crtc_load_cursor_argb,
    .destroy = NULL, /* XXX */
#if RANDR_13_INTERFACE
    .set_origin = i830_crtc_set_origin,
#endif
};

void
i830_crtc_init(ScrnInfoPtr scrn, int pipe)
{
    xf86CrtcPtr crtc;
    I830CrtcPrivatePtr intel_crtc;
    int i;

    crtc = xf86CrtcCreate (scrn, &i830_crtc_funcs);
    if (crtc == NULL)
	return;

    intel_crtc = xnfcalloc (sizeof (I830CrtcPrivateRec), 1);
    intel_crtc->pipe = pipe;
    intel_crtc->dpms_mode = DPMSModeOff;
    intel_crtc->plane = pipe;

    /* Initialize the LUTs for when we turn on the CRTC. */
    for (i = 0; i < 256; i++) {
	intel_crtc->lut_r[i] = i;
	intel_crtc->lut_g[i] = i;
	intel_crtc->lut_b[i] = i;
    }
    crtc->driver_private = intel_crtc;
}

@


1.17
log
@Several changes to resolve screen corruption sometimes seen with dpms
on ivy bridge, mostly based on upstream drm code:

- remove a workaround which was in itself causing issues
- switch the order of disabling fdi rx & tx
- disable DPLL_SEL when disabling the crtc
- add a few extra delays

Most of this concerns the gen5+ crtc disable function, and thanks
to a bunch of testers this is known to still work fine on gen 5/6/7.

ok kettenis@@ matthieu@@
@
text
@@


1.16
log
@Remove annoying is lvds, is crt debug stuff.  OK jsg@@.
@
text
@a1537 10

	if (HAS_PCH_CPT(intel)) {
		temp = INREG(SOUTH_CHICKEN1);
		temp |= FDI_PHASE_SYNC_OVR(pipe);
		OUTREG(SOUTH_CHICKEN1, temp); /* once to unlock... */
		temp |= FDI_PHASE_SYNC_EN(pipe);
		OUTREG(SOUTH_CHICKEN1, temp); /* then again to enable */
		INREG(SOUTH_CHICKEN1);
		usleep(150);
	}
a1854 5
	ErrorF("FDI TX disable\n");
	temp = INREG(fdi_tx_reg);
	OUTREG(fdi_tx_reg, temp & ~FDI_TX_ENABLE);
	INREG(fdi_tx_reg);

d1864 1
a1864 2
	ErrorF("FDI TX train 1 preload\n");
	/* still set train pattern 1 */
d1866 1
a1866 3
	temp &= ~FDI_LINK_TRAIN_NONE;
	temp |= FDI_LINK_TRAIN_PATTERN_1;
	OUTREG(fdi_tx_reg, temp);
d1869 2
d1885 10
d1930 19
@


1.15
log
@Add basic support for ivy bridge and fix several cases of register
access not being adjusted for the pch split, one of which prevented
multiple display pipes from working.  The third pipe on ivy bridge
remains disabled for now.

ok kettenis@@ thanks to everyone who tested
@
text
@a2363 1
	    ErrorF("is lvds\n");
a2381 1
	    ErrorF("is crt\n");
@


1.14
log
@Mostly fix rotation in the intel driver.

Since recent(ish) changes we can allocate roatated framebuffers with tiling.
This was not taken into account. Fix this for the most part:
1) i830_display_tiled needs to check tiling on rotated buffers too.
2) PipeSetBase needs to not only set offset to 0 for roated shadow buffers, it
also needs to 0 DSPTILEOFF x/y too.

There seems to be a remaining issue with damage or similar causing some latency
on rotated screens, I have not managed to find this yet.

Tested by sereral on tech@@ ok matthieu a couple of weeks ago (his mail slipped
though the cracks, hence late commit).
@
text
@d1494 117
d1720 2
d1756 8
a1763 3
	temp &= ~FDI_LINK_TRAIN_NONE;
	OUTREG(fdi_tx_reg, temp | FDI_LINK_TRAIN_NONE |
		   FDI_TX_ENHANCE_FRAME_ENABLE);
d2661 3
a2663 5
	if (pipe == 1) {
	    if (HAS_PCH_CPT(intel))
		lvds |= PORT_TRANS_B_SEL_CPT;
	    else
		lvds |= LVDS_PIPEB_SELECT;
d2665 2
a2666 2
	    if (HAS_PCH_CPT(intel))
		lvds &= ~PORT_TRANS_SEL_MASK;
d2668 1
a2668 1
	    	lvds &= ~LVDS_PIPEB_SELECT;
d2771 1
a2771 1
	OUTREG(data_n1_reg, TU_SIZE(m_n.tu) | m_n.gmch_n);
@


1.13
log
@Add support for Sandy Bridge.  Not perfect yet.  Most notably 3D acceleration
is completely absent, and playing video doesn't work yet.  But support for
"normal" 2D stuff is pretty solid and it is really nice to be able to use
my laptop at the panel's native resolution and be able to suspend and resume
the machine.

tested by some
@
text
@d944 1
d950 3
a952 1
    Offset = y * intel->front_pitch + x * intel->cpp;
d954 15
a968 5
    if (intel->front_buffer == NULL) {
	/* During startup we may be called as part of monitor detection while
	 * there is no memory allocation done, so just supply a dummy base
	 * address.
	 */
a969 5
    } else if (crtc->rotatedData != NULL) {
	/* offset is done by shadow painting code, not here */
	Start = (char *)crtc->rotatedData - (char *)intel->FbBase;
	Offset = 0;
	Stride = intel_crtc->rotate_pitch;
d971 1
a971 1
	Start = intel->front_buffer->offset;
a973 3
    crtc->x = x;
    crtc->y = y;

d1065 1
d1067 1
d1069 2
a1070 3
    /* Rotated data is currently linear, allocated either via XAA or EXA */
    if (crtc->rotatedData)
	return FALSE;
d1072 1
a1072 1
    if (intel->front_buffer) {
d1074 2
a1075 2
	if (drm_intel_bo_get_tiling(intel->front_buffer,
	    &tiling_mode, &swizzle) == 0 && tiling_mode != I915_TILING_NONE)
d2764 1
a2764 1
    return intel->FbBase + intel_crtc->rotate_bo->offset;
d2778 1
a2778 1
    if (!data)
d2780 6
d2790 1
d2798 1
a2798 1
					   data);
d2803 1
@


1.12
log
@Update the intel driver to a more recent version based on more recent
upsteam code.

Backporting keeping UMS changes by me, some bugfixes from kettenis@@.

Has been in snapshots for a while, committed on request so we can be
sure what people are running. This is a prerequesite for sandybridge
support but has those chipsets disabled for now until the correct code
has been added.
@
text
@d558 1
a558 1
static const intel_limit_t *intel_igdng_limit(xf86CrtcPtr crtc)
d616 2
a617 2
    if (IS_IGDNG(intel)) {
	limit = intel_igdng_limit(crtc);
d1029 1
a1029 1
    if (IS_IGDNG(intel))
d1118 1
a1118 1
    if (IS_IGDNG(intel))
d1370 118
d1543 1
d1557 1
d1560 1
d1595 4
a1598 1
	ironlake_fdi_link_train(crtc);
d1608 10
d1627 1
a1627 1
	/* enable normal */
d1637 8
a1644 4
	temp &= ~FDI_LINK_TRAIN_NONE;
	temp |= FDI_LINK_TRAIN_NONE;
	
	OUTREG(fdi_rx_reg, temp | FDI_LINK_TRAIN_NONE);
d1759 7
a1765 2
	temp &= ~FDI_LINK_TRAIN_NONE;
	temp |= FDI_LINK_TRAIN_PATTERN_1;
a1770 1
	ErrorF("LVDS port force off\n");
d1772 1
d1814 1
d1838 1
a1838 1
static void igdng_crtc_dpms(xf86CrtcPtr crtc, int mode)
d1901 2
a1902 2
    if (IS_IGDNG(intel))
	igdng_crtc_dpms(crtc, mode);
d1971 1
a1971 1
    if (IS_IGDNG(intel)) {
d2271 1
a2271 1
	if (IS_IGDNG(intel))
d2315 1
a2315 1
    if (IS_IGDNG(intel)) {
d2332 1
a2332 1
    if (IS_IGDNG(intel)) {
d2353 1
a2353 1
    if (!IS_IGDNG(intel))
d2366 1
a2366 1
	    else if (IS_IGDNG(intel))
d2390 1
a2390 1
	if (IS_I965G(intel) && !IS_GM45(intel) && !IS_IGDNG(intel))
d2421 1
a2421 1
    if (IS_IGDNG(intel))
d2441 1
a2441 1
    /* IGDNG's plane is forced to pipe, bit 24 is to
d2443 1
a2443 1
    if (!IS_IGDNG(intel)) {
d2468 1
a2468 1
    if (IS_IGDNG(intel)) {
d2481 1
a2481 1
    if (!IS_I85X (intel) && !IS_IGDNG(intel))
d2489 1
a2489 1
    if (!IS_IGDNG(intel) && i830_panel_fitter_pipe (intel) == pipe)
d2504 2
a2505 2
    /* assign to IGDNG registers */
    if (IS_IGDNG(intel)) {
d2526 1
a2526 1
	if (IS_IGDNG(intel))
d2531 12
a2542 4
	if (IS_IGDNG(intel))
	    lvds |= (pipe == 1) ? LVDS_PIPEB_SELECT : 0; 
	else
	    lvds |= LVDS_PIPEB_SELECT;
d2582 15
d2604 1
a2604 1
    if (IS_I965G(intel) && !IS_IGDNG(intel)) {
d2635 1
a2635 1
    if (!IS_IGDNG(intel)) {
d2641 1
a2641 1
    if (IS_IGDNG(intel)) {
d2667 1
a2667 1
    if (IS_IGDNG(intel)) {
d2695 3
a2697 4
    /* use legacy palette for IGDNG */
    if (IS_IGDNG(intel))
	palreg = (intel_crtc->pipe == 0) ? LGC_PALETTE_A :
	    LGC_PALETTE_B;
d2868 1
a2868 1
	if (IS_IGDNG(intel))
d3083 1
a3083 3
	if (IS_IGDNG(intel))
	    i9xx_clock(120000, &clock);
	else if ((dpll & PLL_REF_INPUT_MASK) == PLLB_REF_INPUT_SPREADSPECTRUMIN)
d3088 1
a3088 2
	CARD32 lvds = IS_IGDNG(intel) ? PCH_LVDS : LVDS;
	Bool is_lvds = (pipe == 1) && (INREG(lvds) & LVDS_PORT_EN);
d3095 1
a3095 1
	    if ((INREG(lvds) & LVDS_CLKB_POWER_MASK) == LVDS_CLKB_POWER_UP)
@


1.11
log
@remove annoying is lvds / is crt errorf calls
ok fgs@@ matthieu@@ oga@@
@
text
@d41 1
a41 1
#include "i830.h"
d45 1
a45 1
#include "i810_reg.h"
d949 2
a950 2
    Offset = ((y * scrn->displayWidth + x) * intel->cpp);
    Stride = scrn->displayWidth * intel->cpp;
d961 1
a961 1
	Stride = intel_crtc->rotate_mem->pitch;
d1066 6
a1071 2
    if (intel->front_buffer && intel->front_buffer->tiling != TILE_NONE)
	return TRUE;
a1075 213
/*
 * Several restrictions:
 *   - DSP[AB]CNTR - no line duplication && no pixel multiplier
 *   - pixel format == 15 bit, 16 bit, or 32 bit xRGB_8888
 *   - no alpha buffer discard
 *   - no dual wide display
 *   - progressive mode only (DSP[AB]CNTR)
 *   - uncompressed fb is <= 2048 in width, 0 mod 8
 *   - uncompressed fb is <= 1536 in height, 0 mod 2
 *   - SR display watermarks must be equal between 16bpp and 32bpp?
 *
 * FIXME: verify above conditions are true
 *
 * Enable 8xx style FB compression
 */
static void
i830_enable_fb_compression_8xx(xf86CrtcPtr crtc)
{
    ScrnInfoPtr scrn = crtc->scrn;
    intel_screen_private *intel = intel_get_screen_private(scrn);
    I830CrtcPrivatePtr	intel_crtc = crtc->driver_private;
    uint32_t fbc_ctl = 0;
    unsigned long compressed_stride;
    int plane = (intel_crtc->plane == 0 ? FBC_CTL_PLANEA : FBC_CTL_PLANEB);
    unsigned long uncompressed_stride = scrn->displayWidth * intel->cpp;
    unsigned long interval = 1000;

    if (INREG(FBC_CONTROL) & FBC_CTL_EN)
	return;

    compressed_stride = intel->compressed_front_buffer->size /
	FBC_LL_SIZE;

    if (uncompressed_stride < compressed_stride)
	compressed_stride = uncompressed_stride;

    /* FBC_CTL wants 64B units */
    compressed_stride = (compressed_stride / 64) - 1;

    /* Set it up... */
    /* Wait for compressing bit to clear */
    while (INREG(FBC_STATUS) & FBC_STAT_COMPRESSING)
	; /* nothing */
    i830WaitForVblank(scrn);
    OUTREG(FBC_CFB_BASE, intel->compressed_front_buffer->bus_addr);
    OUTREG(FBC_LL_BASE, intel->compressed_ll_buffer->bus_addr + 6);
    OUTREG(FBC_CONTROL2, FBC_CTL_FENCE_DBL | FBC_CTL_IDLE_IMM |
	   FBC_CTL_CPU_FENCE | plane);
    OUTREG(FBC_FENCE_OFF, crtc->y);

    /* Zero buffers */
    memset(intel->FbBase + intel->compressed_front_buffer->offset, 0,
	   intel->compressed_front_buffer->size);
    memset(intel->FbBase + intel->compressed_ll_buffer->offset, 0,
	   intel->compressed_ll_buffer->size);

    /* enable it... */
    fbc_ctl |= FBC_CTL_EN | FBC_CTL_PERIODIC;
    fbc_ctl |= (compressed_stride & 0xff) << FBC_CTL_STRIDE_SHIFT;
    fbc_ctl |= (interval & 0x2fff) << FBC_CTL_INTERVAL_SHIFT;
    fbc_ctl |= FBC_CTL_UNCOMPRESSIBLE;
    fbc_ctl |= intel->front_buffer->fence_nr;
    OUTREG(FBC_CONTROL, fbc_ctl);
}

/*
 * Disable 8xx style FB compression
 */
static void
i830_disable_fb_compression_8xx(xf86CrtcPtr crtc)
{
    ScrnInfoPtr scrn = crtc->scrn;
    intel_screen_private *intel = intel_get_screen_private(scrn);
    uint32_t fbc_ctl;

    /* Disable compression */
    fbc_ctl = INREG(FBC_CONTROL);
    fbc_ctl &= ~FBC_CTL_EN;
    OUTREG(FBC_CONTROL, fbc_ctl);

    /* Wait for compressing bit to clear */
    while (INREG(FBC_STATUS) & FBC_STAT_COMPRESSING)
	; /* nothing */
}

static void
i830_disable_fb_compression2(xf86CrtcPtr crtc)
{
    ScrnInfoPtr scrn = crtc->scrn;
    intel_screen_private *intel = intel_get_screen_private(scrn);
    uint32_t dpfc_ctl;

    /* Disable compression */
    dpfc_ctl = INREG(DPFC_CONTROL);
    dpfc_ctl &= ~DPFC_CTL_EN;
    OUTREG(DPFC_CONTROL, dpfc_ctl);
    i830WaitForVblank(scrn);
}

static void
i830_enable_fb_compression2(xf86CrtcPtr crtc)
{
    ScrnInfoPtr scrn = crtc->scrn;
    intel_screen_private *intel = intel_get_screen_private(scrn);
    I830CrtcPrivatePtr	intel_crtc = crtc->driver_private;
    int plane = (intel_crtc->plane == 0 ? DPFC_CTL_PLANEA : DPFC_CTL_PLANEB);
    unsigned long stall_watermark = 200, frames = 50;

    if (INREG(DPFC_CONTROL) & DPFC_CTL_EN)
	return;

    /* Set it up... */
    i830_disable_fb_compression2(crtc);
    OUTREG(DPFC_CB_BASE, intel->compressed_front_buffer->offset);
    /* Update i830_memory.c too if compression ratio changes */
    OUTREG(DPFC_CONTROL, plane | DPFC_CTL_FENCE_EN | DPFC_CTL_LIMIT_4X |
	   intel->front_buffer->fence_nr);
    OUTREG(DPFC_RECOMP_CTL, DPFC_RECOMP_STALL_EN |
	   (stall_watermark << DPFC_RECOMP_STALL_WM_SHIFT) |
	   (frames << DPFC_RECOMP_TIMER_COUNT_SHIFT));
    OUTREG(DPFC_FENCE_YOFF, crtc->y);

    /* Zero buffers */
    memset(intel->FbBase + intel->compressed_front_buffer->offset, 0,
	   intel->compressed_front_buffer->size);

    /* enable it... */
    OUTREG(DPFC_CONTROL, INREG(DPFC_CONTROL) | DPFC_CTL_EN);
}

static void
i830_enable_fb_compression(xf86CrtcPtr crtc)
{
    ScrnInfoPtr scrn = crtc->scrn;
    intel_screen_private *intel = intel_get_screen_private(scrn);

    if (IS_GM45(intel))
	return i830_enable_fb_compression2(crtc);

    i830_enable_fb_compression_8xx(crtc);
}

static void
i830_disable_fb_compression(xf86CrtcPtr crtc)
{
    ScrnInfoPtr scrn = crtc->scrn;
    intel_screen_private *intel = intel_get_screen_private(scrn);

    if (IS_GM45(intel))
	return i830_disable_fb_compression2(crtc);

    i830_disable_fb_compression_8xx(crtc);
}

static Bool
i830_use_fb_compression(xf86CrtcPtr crtc)
{
    ScrnInfoPtr scrn = crtc->scrn;
    xf86CrtcConfigPtr xf86_config = XF86_CRTC_CONFIG_PTR(scrn);
    intel_screen_private *intel = intel_get_screen_private(scrn);
    I830CrtcPrivatePtr	intel_crtc = crtc->driver_private;
    unsigned long uncompressed_size;
    int plane = (intel_crtc->plane == 0 ? FBC_CTL_PLANEA : FBC_CTL_PLANEB);
    int i, count = 0;

    /* Only available on one pipe at a time */
    for (i = 0; i < xf86_config->num_crtc; i++) {
	if (xf86_config->crtc[i]->enabled)
	    count++;
    }

    /* Here we disable it to catch one->two pipe enabled configs */
    if (count > 1) {
	if (i830_fb_compression_supported(intel))
	    i830_disable_fb_compression(crtc);
	return FALSE;
    }

    if (!intel->fb_compression)
	return FALSE;

    if (!i830_display_tiled(crtc))
	return FALSE;

    /* Pre-965 only supports plane A */
    if (!IS_I965GM(intel) && plane != FBC_CTL_PLANEA)
	return FALSE;

    /* Need 15, 16, or 32 (w/alpha) pixel format */
    if (!(scrn->bitsPerPixel == 16 || /* covers 15 bit mode as well */
	  scrn->bitsPerPixel == 32)) /* mode_set dtrt if fbc is in use */
	return FALSE;

    /* Can't cache more lines than we can track */
    if (crtc->mode.VDisplay > FBC_LL_SIZE)
	return FALSE;

    /*
     * Make sure the compressor doesn't go past the end of our compressed
     * buffer if the uncompressed size is large.
     */
    uncompressed_size = crtc->mode.HDisplay * crtc->mode.VDisplay *
	intel->cpp;
    if (intel->compressed_front_buffer->size < uncompressed_size)
	return FALSE;

    /*
     * No checks for pixel multiply, incl. horizontal, or interlaced modes
     * since they're currently unused.
     */
    return TRUE;
}

d1115 1
a1115 1
    uint8_t sr01;
a1205 3
    /* Reenable compression if needed */
    if (i830_use_fb_compression(crtc))
	i830_enable_fb_compression(crtc);
a1223 3
    /* Shut off compression if in use */
    if (i830_use_fb_compression(crtc))
	i830_disable_fb_compression(crtc);
a1784 3
    /* Temporarily turn off FB compression during modeset */
    if (i830_use_fb_compression(crtc))
        i830_disable_fb_compression(crtc);
a1805 4

    /* Reenable FB compression if possible */
    if (i830_use_fb_compression(crtc))
	i830_enable_fb_compression(crtc);
d2090 1
d2109 1
d2337 1
a2337 1
    if (!IS_I85X (intel))
d2580 1
a2580 1
    int align = KB(4), size;
d2582 4
a2585 9
    width = i830_pad_drawable_width(width);
    rotate_pitch = width * intel->cpp;
    size = rotate_pitch * height;

    assert(intel_crtc->rotate_mem == NULL);
    intel_crtc->rotate_mem = i830_allocate_memory(scrn, "rotated crtc",
						  size, rotate_pitch, align,
						  0, TILE_NONE);
    if (intel_crtc->rotate_mem == NULL) {
a2589 1
    memset(intel->FbBase + intel_crtc->rotate_mem->offset, 0, size);
d2591 2
a2592 1
    return intel->FbBase + intel_crtc->rotate_mem->offset;
d2602 1
a2603 2
    intel_screen_private *intel = intel_get_screen_private(scrn);
    int rotate_pitch;
d2608 5
a2613 2
    rotate_pitch = i830_pad_drawable_width(width) * intel->cpp;

d2618 1
a2618 1
					   rotate_pitch,
d2625 4
a2628 2
    if (intel_crtc->rotate_mem && intel_crtc->rotate_mem->bo)
	i830_set_pixmap_bo(rotate_pixmap, intel_crtc->rotate_mem->bo);
d2636 1
d2640 1
a2640 1
	i830_set_pixmap_bo(rotate_pixmap, NULL);
d2647 4
a2650 2
	i830_free_memory(scrn, intel_crtc->rotate_mem);
	intel_crtc->rotate_mem = NULL;
d2652 2
@


1.10
log
@Update the intel driver to (mostly) a backport of 2.12.

It is missing a few commits that I have yet to verify (ones that try and
continue if we lock the gpu rendering engine and can't reset it, for
example) taht will be verified and sent out for extra testing soon.

Should contain a bunch of speedups and some correctness improvements
(though rendercheck still gives some errors that I am looking into).

This has been in snaps since the first day of c2k10, any known issues
with just this driver have (to my knowledge) been fixed since. A problem
with macbooks pointed out by otto happens with both this and the in-tree
driver and thus doesn't stop this moving forward.

As well as the 2.12 improvements, this driver also has a backport
(partially aided by the backports in RHEL 5 kindly provided by Dave
Airlie) from the kms code of modesetting support for ironlake (arrandale
and clarkdale: the IGDs build into intel nehalem cpu dies) which has
been tested on a number of chipsets. Note that Display port and eDP
displays have not yet been worked on (and probably won't until I can
find a displayport monitor), but VGA and lvds at least are known to
work, sure beats vesa.

"no objection on my side" matthieu@@, prodding (as always) from princess
marco.
@
text
@a2311 1
	    ErrorF("is lvds\n");
a2329 1
	    ErrorF("is crt\n");
@


1.9
log
@Update the intel driver to 2.9.1 plus backports.

2.9.1 is the last version of the intel DDX that supports UMS (User
modesetting), with 2.10 onwards being purely KMS only. As such, this
driver contains backports of almost every correctness or performance
related fix to the rendering layer in later intel drivers. This driver
*REQUIRES* a GEM enabled kernel. it claims to support non-gem mode but
this is essentially unmaintained and due to the way the abstraciton
works is slow, if it works at all (it often does not). You have been
warned.

tested by many many people on tech over the last few weeks.
@
text
@d45 1
d153 10
d252 60
d318 3
d482 106
d616 3
a618 1
    if (IS_G4X(intel)) {
d692 56
d771 1
d773 3
d1015 1
d1029 3
d1325 10
d1351 5
a1355 2
    OUTREG(VGACNTRL, VGA_DISP_DISABLE);
    i830WaitForVblank(scrn);
d1492 440
d1939 1
a1939 1
i830_crtc_dpms(xf86CrtcPtr crtc, int mode)
d1963 13
d2046 9
d2203 42
d2287 13
d2312 1
d2331 1
d2349 2
d2393 33
d2431 2
a2432 1
    dpll = DPLL_VGA_MODE_DIS;
d2441 1
a2442 2
	    {
		int sdvo_pixel_multiply = adjusted_mode->Clock / mode->Clock;
d2444 3
a2446 1
	    }
d2468 1
a2468 1
	if (IS_I965G(intel) && !IS_GM45(intel))
d2498 4
d2519 8
a2526 4
    if (pipe == 0)
	dspcntr |= DISPPLANE_SEL_PIPE_A;
    else
	dspcntr |= DISPPLANE_SEL_PIPE_B;
d2545 9
d2567 1
a2567 1
    if (i830_panel_fitter_pipe (intel) == pipe)
d2582 6
d2602 4
a2605 1
	uint32_t lvds = INREG(LVDS);
d2607 6
a2612 1
	lvds |= LVDS_PORT_EN | LVDS_A0A2_CLKA_POWER_UP | LVDS_PIPEB_SELECT;
d2648 2
a2649 2
	OUTREG(LVDS, lvds);
	POSTING_READ(LVDS);
d2653 1
d2659 1
a2659 1
    if (IS_I965G(intel)) {
d2682 1
a2682 1
    
d2690 4
a2693 2
    OUTREG(dspsize_reg, ((mode->VDisplay - 1) << 16) | (mode->HDisplay - 1));
    OUTREG(dsppos_reg, 0);
d2695 23
d2722 6
d2750 5
d2768 2
d2781 7
a2787 1
    i830_crtc_load_lut(crtc);
d2918 6
d2932 1
a2932 1
		   dspcntr & DISPPLANE_SEL_PIPE_MASK ? 'B' : 'A');
d3135 3
a3137 1
	if ((dpll & PLL_REF_INPUT_MASK) == PLLB_REF_INPUT_SPREADSPECTRUMIN)
d3142 2
a3143 1
	Bool is_lvds = (pipe == 1) && (INREG(LVDS) & LVDS_PORT_EN);
d3150 1
a3150 1
	    if ((INREG(LVDS) & LVDS_CLKB_POWER_MASK) == LVDS_CLKB_POWER_UP)
d3198 1
a3198 1
    mode = xcalloc(1, sizeof(DisplayModeRec));
@


1.8
log
@backport a bugfix from upstream:

	Fix 945GM VT switch in UMS

	Bug #19578. We should set private intel_crtc state according to
	current, as fail to do so pipe A needs active won't be taken
	care of. Also make sure pipe swap operation always set during VT
	switch.

This also fixes the *other* x40 lid problem (which happens when you suspend,
then you shut the lid in dont'-suspend-on-lid mode.

the reasoning for the PipeA quirk I finally found:

	On some platforms, the firmware may read & write GPU registers
	on lid close, suspend/resume time or during various SMM events.
	If one of the graphics pipes is disabled at that time, the GPU
	may hang due to the programming dependencies of the various
	registers.

So essentially, without this patch, if you have this quirk and you shut
the lid, you're hosed, but y'know drivers in userland are great. So are
BIOS writers.

requested by deraadt@@, who keeps getting this issue when he's on a plane.
@
text
@a43 1
#include "i830_debug.h"
d247 2
d410 2
a411 2
    ScrnInfoPtr	pScrn = crtc->scrn;
    I830Ptr	pI830 = I830PTR(pScrn);
d432 2
a433 2
    ScrnInfoPtr	pScrn = crtc->scrn;
    I830Ptr	pI830 = I830PTR(pScrn);
d436 1
a436 1
    if (IS_G4X(pI830)) {
d438 1
a438 1
    } else if (IS_I9XX(pI830) && !IS_IGD(pI830)) {
d443 1
a443 1
    } else if (IS_IGD(pI830)) {
d487 1
a487 1
static void intel_clock(I830Ptr pI830, int refclk, intel_clock_t *clock)
d489 2
a490 2
    if (IS_I9XX(pI830)) {
	if (IS_IGD(pI830))
d499 1
a499 1
i830PrintPll(ScrnInfoPtr pScrn, char *prefix, intel_clock_t *clock)
d501 1
a501 1
    xf86DrvMsg(pScrn->scrnIndex, X_INFO,
d516 2
a517 2
    ScrnInfoPtr	pScrn = crtc->scrn;
    xf86CrtcConfigPtr   xf86_config = XF86_CRTC_CONFIG_PTR(pScrn);
d543 2
a544 2
    ScrnInfoPtr pScrn = crtc->scrn;
    I830Ptr pI830 = I830PTR(pScrn);
d554 1
a554 1
    if (clock->m1 <= clock->m2 && !IS_IGD(pI830))
d575 2
a576 2
    ScrnInfoPtr pScrn = crtc->scrn;
    I830Ptr pI830 = I830PTR(pScrn);
d604 1
a604 1
	    if (clock.m2 >= clock.m1 && !IS_IGD(pI830))
d612 1
a612 1
		    intel_clock (pI830, refclk, &clock);
d633 2
a634 2
    ScrnInfoPtr pScrn = crtc->scrn;
    I830Ptr pI830 = I830PTR(pScrn);
d669 1
a669 1
                    intel_clock (pI830, refclk, &clock);
d697 2
a698 2
    ScrnInfoPtr pScrn = crtc->scrn;
    I830Ptr pI830 = I830PTR(pScrn);
a699 1
    int pipe = intel_crtc->pipe;
d707 3
a709 3
    Offset = ((y * pScrn->displayWidth + x) * pI830->cpp);
    Stride = pScrn->displayWidth * pI830->cpp;
    if (pI830->front_buffer == NULL) {
d717 1
a717 1
	Start = (char *)crtc->rotatedData - (char *)pI830->FbBase;
d721 1
a721 1
	Start = pI830->front_buffer->offset;
d728 1
a728 1
    if (IS_I965G(pI830)) {
a737 24

#ifdef XF86DRI
    if (pI830->directRenderingType == DRI_XF86DRI) {
	drmI830Sarea *sPriv = (drmI830Sarea *) DRIGetSAREAPrivate(pScrn->pScreen);

	if (!sPriv)
	    return;

	switch (pipe) {
	case 0:
	    sPriv->pipeA_x = x;
	    sPriv->pipeA_y = y;
	    break;
	case 1:
	    sPriv->pipeB_x = x;
	    sPriv->pipeB_y = y;
	    break;
	default:
	    xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
		       "Can't update pipe %d in SAREA\n", pipe);
	    break;
	}
    }
#endif
d813 2
a814 2
    ScrnInfoPtr pScrn = crtc->scrn;
    I830Ptr pI830 = I830PTR(pScrn);
d820 1
a820 1
    if (pI830->front_buffer && pI830->front_buffer->tiling != TILE_NONE)
d844 2
a845 2
    ScrnInfoPtr pScrn = crtc->scrn;
    I830Ptr pI830 = I830PTR(pScrn);
d850 1
a850 1
    unsigned long uncompressed_stride = pScrn->displayWidth * pI830->cpp;
d856 1
a856 1
    compressed_stride = pI830->compressed_front_buffer->size /
d869 3
a871 3
    i830WaitForVblank(pScrn);
    OUTREG(FBC_CFB_BASE, pI830->compressed_front_buffer->bus_addr);
    OUTREG(FBC_LL_BASE, pI830->compressed_ll_buffer->bus_addr + 6);
d877 4
a880 4
    memset(pI830->FbBase + pI830->compressed_front_buffer->offset, 0,
	   pI830->compressed_front_buffer->size);
    memset(pI830->FbBase + pI830->compressed_ll_buffer->offset, 0,
	   pI830->compressed_ll_buffer->size);
d887 1
a887 1
    fbc_ctl |= pI830->front_buffer->fence_nr;
d897 2
a898 2
    ScrnInfoPtr pScrn = crtc->scrn;
    I830Ptr pI830 = I830PTR(pScrn);
d914 2
a915 2
    ScrnInfoPtr pScrn = crtc->scrn;
    I830Ptr pI830 = I830PTR(pScrn);
d922 1
a922 1
    i830WaitForVblank(pScrn);
d928 2
a929 2
    ScrnInfoPtr pScrn = crtc->scrn;
    I830Ptr pI830 = I830PTR(pScrn);
d939 1
a939 1
    OUTREG(DPFC_CB_BASE, pI830->compressed_front_buffer->offset);
d942 1
a942 1
	   pI830->front_buffer->fence_nr);
d949 2
a950 2
    memset(pI830->FbBase + pI830->compressed_front_buffer->offset, 0,
	   pI830->compressed_front_buffer->size);
d959 2
a960 2
    ScrnInfoPtr pScrn = crtc->scrn;
    I830Ptr pI830 = I830PTR(pScrn);
d962 1
a962 1
    if (IS_GM45(pI830))
d971 2
a972 2
    ScrnInfoPtr pScrn = crtc->scrn;
    I830Ptr pI830 = I830PTR(pScrn);
d974 1
a974 1
    if (IS_GM45(pI830))
d983 3
a985 3
    ScrnInfoPtr pScrn = crtc->scrn;
    xf86CrtcConfigPtr xf86_config = XF86_CRTC_CONFIG_PTR(pScrn);
    I830Ptr pI830 = I830PTR(pScrn);
d999 1
a999 1
	if (i830_fb_compression_supported(pI830))
d1004 1
a1004 1
    if (!pI830->fb_compression)
d1011 1
a1011 1
    if (!IS_I965GM(pI830) && plane != FBC_CTL_PLANEA)
d1015 2
a1016 2
    if (!(pScrn->bitsPerPixel == 16 || /* covers 15 bit mode as well */
	  pScrn->bitsPerPixel == 32)) /* mode_set dtrt if fbc is in use */
d1028 2
a1029 2
	pI830->cpp;
    if (pI830->compressed_front_buffer->size < uncompressed_size)
d1039 1
a1039 1
#if defined(DRM_IOCTL_MODESET_CTL) && (defined(XF86DRI) || defined(DRI2))
d1042 2
a1043 2
    ScrnInfoPtr pScrn = crtc->scrn;
    I830Ptr pI830 = I830PTR(pScrn);
d1047 1
a1047 1
    if (pI830->directRenderingType <= DRI_NONE)
d1059 1
a1059 1
	ioctl(pI830->drmSubFD, DRM_IOCTL_MODESET_CTL, &modeset);
d1063 1
a1063 1
	ioctl(pI830->drmSubFD, DRM_IOCTL_MODESET_CTL, &modeset);
d1071 1
a1071 1
#endif /* DRM_IOCTL_MODESET_CTL && (XF86DRI || DRI2) */
d1076 2
a1077 3
    ScrnInfoPtr pScrn = crtc->scrn;
    I830Ptr pI830 = I830PTR(pScrn);
    uint32_t vgacntrl = INREG(VGACNTRL);
a1079 3
    if (vgacntrl & VGA_DISP_DISABLE)
	return;

d1081 13
a1093 15
       Set bit 5 of SR01;
       Wait 30us;
       */
    OUTREG8(SRX, 1);
    sr01 = INREG8(SRX + 1);
    OUTREG8(SRX + 1, sr01 | (1 << 5));
    usleep(30);
    /* disable center mode on 965GM and G4X platform */
    if (IS_I965GM(pI830) || IS_G4X(pI830))
        vgacntrl &= ~(3 << 24);

    vgacntrl |= VGA_DISP_DISABLE;

    OUTREG(VGACNTRL, vgacntrl);
    i830WaitForVblank(pScrn);
d1095 8
d1105 1
a1105 1
void
d1108 2
a1109 2
    ScrnInfoPtr pScrn = crtc->scrn;
    I830Ptr pI830 = I830PTR(pScrn);
d1165 2
a1166 2
    ScrnInfoPtr pScrn = crtc->scrn;
    I830Ptr pI830 = I830PTR(pScrn);
d1201 1
a1201 1
    if (!IS_I9XX(pI830)) {
d1203 1
a1203 1
	i830WaitForVblank(pScrn);
d1217 1
a1217 1
	i830WaitForVblank(pScrn);
d1242 2
a1243 2
    ScrnInfoPtr pScrn = crtc->scrn;
    I830Ptr pI830 = I830PTR(pScrn);
d1258 1
a1258 1
	if ((pipe == 0) && (pI830->quirk_flag & QUIRK_PIPEA_FORCE))
a1265 27

#ifdef XF86DRI
    if (pI830->directRenderingType == DRI_XF86DRI) {
	drmI830Sarea *sPriv = (drmI830Sarea *) DRIGetSAREAPrivate(pScrn->pScreen);
	Bool enabled = crtc->enabled && mode != DPMSModeOff;

	I830DRISetVBlankInterrupt (pScrn, TRUE);

	if (!sPriv)
	    return;

	switch (pipe) {
	case 0:
	    sPriv->pipeA_w = enabled ? crtc->mode.HDisplay : 0;
	    sPriv->pipeA_h = enabled ? crtc->mode.VDisplay : 0;
	    break;
	case 1:
	    sPriv->pipeB_w = enabled ? crtc->mode.HDisplay : 0;
	    sPriv->pipeB_h = enabled ? crtc->mode.VDisplay : 0;
	    break;
	default:
	    xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
		       "Can't update pipe %d in SAREA\n", pipe);
	    break;
	}
    }
#endif
d1271 4
a1274 2
   /* Sync the engine before mode switch */
   i830WaitSync(crtc->scrn);
a1275 3
#ifdef XF86DRI
    return I830DRILock(crtc->scrn);
#else
a1276 1
#endif
a1281 3
#ifdef XF86DRI
    I830DRIUnlock (crtc->scrn);
#endif
a1315 5

#ifdef XF86DRI
    /* Tell DRI1 the news about new output config */
    i830_update_dri_buffers(crtc->scrn);
#endif
d1339 1
a1339 1
i830_get_core_clock_speed(ScrnInfoPtr pScrn)
d1341 1
a1341 1
    I830Ptr pI830 = I830PTR(pScrn);
d1346 1
a1346 1
    if (IS_I945G(pI830) || (IS_G33CLASS(pI830) && !IS_IGDGM(pI830)))
d1348 1
a1348 1
    else if (IS_I915G(pI830))
d1350 1
a1350 1
    else if (IS_I945GM(pI830) || IS_845G(pI830) || IS_IGDGM(pI830))
d1352 1
a1352 1
    else if (IS_I915GM(pI830)) {
d1355 1
a1355 5
#if XSERVER_LIBPCIACCESS
      pci_device_cfg_read_u16 (pI830->PciInfo, &gcfgc, I915_GCFGC);
#else
      gcfgc = pciReadWord(pI830->PciTag, I915_GCFGC);
#endif
d1367 1
a1367 1
    } else if (IS_I865G(pI830))
d1369 1
a1369 2
    else if (IS_I855(pI830)) {
#if XSERVER_LIBPCIACCESS
a1372 4
#else
	PCITAG bridge = pciTag(0, 0, 0); /* This is always the host bridge */
	uint16_t hpllcc = pciReadWord(bridge, I855_HPLLCC);
#endif
d1397 1
a1397 1
i830_panel_fitter_pipe(I830Ptr pI830)
d1402 1
a1402 1
    if (IS_I830(pI830))
d1412 1
a1412 1
    if (IS_I965G(pI830))
d1426 1
a1426 1
i830_update_dsparb(ScrnInfoPtr pScrn)
d1428 2
a1429 2
   xf86CrtcConfigPtr xf86_config = XF86_CRTC_CONFIG_PTR(pScrn);
   I830Ptr pI830 = I830PTR(pScrn);
d1435 1
a1435 1
       xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
d1441 1
a1441 1
   if (IS_I965GM(pI830))
d1443 1
a1443 1
   else if (IS_I9XX(pI830))
d1445 1
a1445 1
   else if (IS_MOBILE(pI830)) {
d1470 1
a1470 1
   if (IS_I9XX(pI830))
d1474 1
a1474 1
   else if (IS_MOBILE(pI830))
d1495 3
a1497 3
    ScrnInfoPtr pScrn = crtc->scrn;
    xf86CrtcConfigPtr   xf86_config = XF86_CRTC_CONFIG_PTR(pScrn);
    I830Ptr pI830 = I830PTR(pScrn);
d1562 1
a1562 1
	xf86DrvMsg(pScrn->scrnIndex, X_INFO, "clone detected, disabling SSC\n");
d1565 3
a1567 3
    if (is_lvds && pI830->lvds_use_ssc && num_outputs < 2) {
	refclk = pI830->lvds_ssc_freq * 1000;
	xf86DrvMsg(pScrn->scrnIndex, X_INFO,
d1569 1
a1569 1
    } else if (IS_I9XX(pI830)) {
d1586 1
a1586 1
	xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
d1613 1
a1613 1
    if (IS_IGD(pI830))
d1619 1
a1619 1
    if (IS_I9XX(pI830)) {
d1627 1
a1627 1
	    if ((IS_I945G(pI830) || IS_I945GM(pI830) || IS_G33CLASS(pI830)))
d1635 1
a1635 1
	if (IS_IGD(pI830))
d1653 1
a1653 1
	if (IS_I965G(pI830) && !IS_GM45(pI830))
d1676 1
a1676 1
    else if (is_lvds && pI830->lvds_use_ssc && num_outputs < 2)
d1683 1
a1683 1
    switch (pScrn->bitsPerPixel) {
d1688 1
a1688 1
	if (pScrn->depth == 15)
d1705 1
a1705 1
    if (IS_I965G(pI830) && i830_display_tiled(crtc))
d1709 1
a1709 1
    if (pipe == 0 && !IS_I965G(pI830))
d1717 1
a1717 1
	if (mode->Clock > i830_get_core_clock_speed(pScrn) * 9 / 10)
d1727 1
a1727 1
    if (!IS_I85X (pI830))
d1735 1
a1735 1
    if (i830_panel_fitter_pipe (pI830) == pipe)
d1738 2
a1739 2
    if (pI830->debug_modes) {
	xf86DrvMsg(pScrn->scrnIndex, X_INFO,
d1741 1
a1741 1
	xf86PrintModeline(pScrn->scrnIndex, mode);
d1743 1
a1743 1
	    xf86DrvMsg(pScrn->scrnIndex, X_INFO,
d1745 1
a1745 1
	    xf86PrintModeline(pScrn->scrnIndex, adjusted_mode);
d1747 1
a1747 1
	i830PrintPll(pScrn, "chosen", &clock);
d1775 1
a1775 1
	if (pI830->lvds_24_bit_mode) {
d1782 1
a1782 1
	    xf86DrvMsg(pScrn->scrnIndex, X_INFO,
d1787 1
a1787 1
	    xf86DrvMsg(pScrn->scrnIndex, X_INFO,
d1792 1
a1792 1
	if (IS_I965G(pI830))
d1812 1
a1812 1
    if (IS_I965G(pI830)) {
d1824 2
a1825 2
    if (!DSPARB_HWCONTROL(pI830))
	i830_update_dsparb(pScrn);
d1848 1
a1848 1
    i830WaitForVblank(pScrn);
d1853 2
a1854 5
#ifdef XF86DRI
   I830DRISetVBlankInterrupt (pScrn, TRUE);
#endif
    
    i830WaitForVblank(pScrn);
d1859 1
a1859 1
void
d1862 2
a1863 2
    ScrnInfoPtr pScrn = crtc->scrn;
    I830Ptr pI830 = I830PTR(pScrn);
d1907 2
a1908 2
    ScrnInfoPtr pScrn = crtc->scrn;
    I830Ptr pI830 = I830PTR(pScrn);
d1913 2
a1914 2
    width = i830_pad_drawable_width(width, pI830->cpp);
    rotate_pitch = width * pI830->cpp;
d1918 1
a1918 1
    intel_crtc->rotate_mem = i830_allocate_memory(pScrn, "rotated crtc",
d1922 1
a1922 1
	xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
d1926 1
a1926 1
    memset(pI830->FbBase + intel_crtc->rotate_mem->offset, 0, size);
d1928 1
a1928 1
    return pI830->FbBase + intel_crtc->rotate_mem->offset;
d1937 1
a1937 1
    ScrnInfoPtr pScrn = crtc->scrn;
d1939 1
a1939 1
    I830Ptr pI830 = I830PTR(pScrn);
d1946 1
a1946 1
    rotate_pitch = i830_pad_drawable_width(width, pI830->cpp) * pI830->cpp;
d1948 1
a1948 1
    rotate_pixmap = GetScratchPixmapHeader(pScrn->pScreen,
d1950 2
a1951 2
					   pScrn->depth,
					   pScrn->bitsPerPixel,
d1956 1
a1956 1
	xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
d1967 1
a1967 1
    ScrnInfoPtr pScrn = crtc->scrn;
d1970 2
a1971 1
    if (rotate_pixmap)
d1973 1
d1977 2
a1978 2
	I830Sync(pScrn);
	i830_free_memory(pScrn, intel_crtc->rotate_mem);
d1996 1
a1996 1
i830_set_new_crtc_bo(ScrnInfoPtr pScrn)
d1998 1
a1998 1
    xf86CrtcConfigPtr   xf86_config = XF86_CRTC_CONFIG_PTR(pScrn);
d2010 1
a2010 1
i830DescribeOutputConfiguration(ScrnInfoPtr pScrn)
d2012 2
a2013 2
    xf86CrtcConfigPtr   xf86_config = XF86_CRTC_CONFIG_PTR(pScrn);
    I830Ptr pI830 = I830PTR(pScrn);
d2016 1
a2016 1
    xf86DrvMsg(pScrn->scrnIndex, X_INFO, "Output configuration:\n");
d2028 1
a2028 1
	xf86DrvMsg(pScrn->scrnIndex, X_INFO,
d2031 1
a2031 1
	xf86DrvMsg(pScrn->scrnIndex, X_INFO,
d2037 1
a2037 1
	    xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
d2044 1
a2044 1
	    xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
d2057 1
a2057 1
	xf86DrvMsg(pScrn->scrnIndex, X_INFO,
d2095 2
a2096 2
    ScrnInfoPtr		    pScrn = output->scrn;
    xf86CrtcConfigPtr	    xf86_config = XF86_CRTC_CONFIG_PTR(pScrn);
d2162 1
a2162 1
    i830WaitForVblank (pScrn);
d2170 1
a2170 1
    ScrnInfoPtr		    pScrn = output->scrn;
d2179 1
a2179 1
	xf86DisableUnusedFunctions(pScrn);
d2194 1
a2194 1
i830_crtc_clock_get(ScrnInfoPtr pScrn, xf86CrtcPtr crtc)
d2196 1
a2196 1
    I830Ptr pI830 = I830PTR(pScrn);
d2209 1
a2209 1
    if (IS_IGD(pI830)) {
d2216 2
a2217 2
    if (IS_I9XX(pI830)) {
	if (IS_IGD(pI830))
d2232 1
a2232 1
	    xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
d2239 1
a2239 1
	    intel_clock(pI830, 100000, &clock);
d2241 1
a2241 1
	    intel_clock(pI830, 96000, &clock);
d2256 1
a2256 1
		intel_clock(pI830, 66000, &clock); /* XXX: might not be 66MHz */
d2258 1
a2258 1
		intel_clock(pI830, 48000, &clock);
d2271 1
a2271 1
	    intel_clock(pI830, 48000, &clock);
d2280 1
a2280 1
	i830PrintPll(pScrn, "probed", &clock);
d2287 1
a2287 1
i830_crtc_mode_get(ScrnInfoPtr pScrn, xf86CrtcPtr crtc)
d2289 1
a2289 1
    I830Ptr pI830 = I830PTR(pScrn);
d2302 1
a2302 1
    mode->Clock = i830_crtc_clock_get(pScrn, crtc);
a2334 1
/*    .load_cursor_image = i830_crtc_load_cursor_image, */
d2343 1
a2343 1
i830_crtc_init(ScrnInfoPtr pScrn, int pipe)
d2349 1
a2349 1
    crtc = xf86CrtcCreate (pScrn, &i830_crtc_funcs);
@


1.7
log
@update to xf86-video-intel 2.7.1. Tested by many.
@
text
@d1283 1
@


1.6
log
@xf86-video-intel 2.4.2. Has been in snapshots for weeks. Ok oga@@.
@
text
@d70 2
a71 1
typedef struct {
d74 3
a76 1
} intel_limit_t;
d106 2
d119 3
d124 2
d132 5
d142 2
d157 91
d261 1
d274 1
d287 1
d303 101
d407 22
d435 3
a437 1
    if (IS_I9XX(pI830)) {
d442 5
d477 9
d488 6
a493 3
    if (IS_I9XX(pI830))
	i9xx_clock (refclk, clock);
    else
d542 2
d553 1
a553 1
    if (clock->m1 <= clock->m2)
a569 5
/**
 * Returns a set of divisors for the desired target clock with the given
 * refclk, or FALSE.  The returned values represent the clock equation:
 * reflck * (5 * (m1 + 2) + (m2 + 2)) / (n + 2) / p1 / p2.
 */
d571 2
a572 1
i830FindBestPLL(xf86CrtcPtr crtc, int target, int refclk, intel_clock_t *best_clock)
d576 1
a576 2
    intel_clock_t   clock;
    const intel_limit_t   *limit = intel_limit (crtc);
d600 1
a600 1
	for (clock.m2 = limit->m2.min; clock.m2 < clock.m1 && clock.m2 <= limit->m2.max; clock.m2++) 
d602 3
d628 58
d701 1
a701 1
    unsigned long Start, Offset;
d705 1
d708 1
d719 2
a720 1
    } else if (I830IsPrimary(pScrn)) {
a721 3
    } else {
	I830Ptr pI8301 = I830PTR(pI830->entityPrivate->pScrn_1);
	Start = pI8301->front_buffer_2->offset;
d724 4
d740 1
a740 1
    if (pI830->directRenderingEnabled) {
d746 1
a746 1
	switch (plane) {
d748 2
a749 2
	    sPriv->planeA_x = x;
	    sPriv->planeA_y = y;
d752 2
a753 2
	    sPriv->planeB_x = x;
	    sPriv->planeB_y = y;
d1063 1
a1063 1
#if defined(DRM_IOCTL_MODESET_CTL) && defined(XF86DRI)
d1071 2
a1072 2
    if (!pI830->directRenderingEnabled)
	return;
d1074 1
a1074 1
    modeset.crtc = intel_crtc->plane;
d1095 1
a1095 1
#endif /* DRM_IOCTL_MODESET_CTL && XF86DRI */
a1096 6
/**
 * Sets the power management mode of the pipe and plane.
 *
 * This code should probably grow support for turning the cursor off and back
 * on appropriately at the same time as we're turning the pipe off/on.
 */
d1098 31
a1128 1
i830_crtc_dpms(xf86CrtcPtr crtc, int mode)
d1141 31
a1171 24
    /* XXX: When our outputs are all unaware of DPMS modes other than off and
     * on, we should map those modes to DPMSModeOff in the CRTC.
     */
    switch (mode) {
    case DPMSModeOn:
    case DPMSModeStandby:
    case DPMSModeSuspend:
	/* Enable the DPLL */
	temp = INREG(dpll_reg);
	if ((temp & DPLL_VCO_ENABLE) == 0)
	{
	    OUTREG(dpll_reg, temp);
	    POSTING_READ(dpll_reg);
	    /* Wait for the clocks to stabilize. */
	    usleep(150);
	    OUTREG(dpll_reg, temp | DPLL_VCO_ENABLE);
	    POSTING_READ(dpll_reg);
	    /* Wait for the clocks to stabilize. */
	    usleep(150);
	    OUTREG(dpll_reg, temp | DPLL_VCO_ENABLE);
	    POSTING_READ(dpll_reg);
	    /* Wait for the clocks to stabilize. */
	    usleep(150);
	}
d1173 1
a1173 4
	/* Enable the pipe */
	temp = INREG(pipeconf_reg);
	if ((temp & PIPEACONF_ENABLE) == 0)
	    OUTREG(pipeconf_reg, temp | PIPEACONF_ENABLE);
d1175 2
a1176 8
	/* Enable the plane */
	temp = INREG(dspcntr_reg);
	if ((temp & DISPLAY_PLANE_ENABLE) == 0)
	{
	    OUTREG(dspcntr_reg, temp | DISPLAY_PLANE_ENABLE);
	    /* Flush the plane changes */
	    OUTREG(dspbase_reg, INREG(dspbase_reg));
	}
d1178 5
a1182 1
	i830_crtc_load_lut(crtc);
d1184 13
a1196 2
	/* Give the overlay scaler a chance to enable if it's on this pipe */
	i830_crtc_dpms_video(crtc, TRUE);
d1198 4
a1201 10
	/* Reenable compression if needed */
	if (i830_use_fb_compression(crtc))
	    i830_enable_fb_compression(crtc);
	i830_modeset_ctl(crtc, 0);
	break;
    case DPMSModeOff:
	i830_modeset_ctl(crtc, 1);
	/* Shut off compression if in use */
	if (i830_use_fb_compression(crtc))
	    i830_disable_fb_compression(crtc);
d1203 2
a1204 2
	/* Give the overlay scaler a chance to disable if it's on this pipe */
	i830_crtc_dpms_video(crtc, FALSE);
d1206 6
a1211 2
	/* Disable the VGA plane that we never use */
	OUTREG(VGACNTRL, VGA_DISP_DISABLE);
d1213 9
a1221 12
	/* May need to leave pipe A on */
	if ((pipe != 0) || !(pI830->quirk_flag & QUIRK_PIPEA_FORCE))
	{
		/* Disable display plane */
		temp = INREG(dspcntr_reg);
		if ((temp & DISPLAY_PLANE_ENABLE) != 0)
		{
		    OUTREG(dspcntr_reg, temp & ~DISPLAY_PLANE_ENABLE);
		    /* Flush the plane changes */
		    OUTREG(dspbase_reg, INREG(dspbase_reg));
		    POSTING_READ(dspbase_reg);
		}
d1223 4
a1226 4
		if (!IS_I9XX(pI830)) {
		    /* Wait for vblank for the disable to take effect */
		    i830WaitForVblank(pScrn);
		}
d1228 9
a1236 6
		/* Next, disable display pipes */
		temp = INREG(pipeconf_reg);
		if ((temp & PIPEACONF_ENABLE) != 0) {
		    OUTREG(pipeconf_reg, temp & ~PIPEACONF_ENABLE);
		    POSTING_READ(pipeconf_reg);
		}
d1238 2
a1239 2
		/* Wait for vblank for the disable to take effect. */
		i830WaitForVblank(pScrn);
d1241 4
a1244 5
		temp = INREG(dpll_reg);
		if ((temp & DPLL_VCO_ENABLE) != 0) {
		    OUTREG(dpll_reg, temp & ~DPLL_VCO_ENABLE);
		    POSTING_READ(dpll_reg);
		}
d1246 1
d1249 34
d1289 1
a1289 1
    if (pI830->directRenderingEnabled) {
d1298 1
a1298 1
	switch (plane) {
d1300 2
a1301 2
	    sPriv->planeA_w = enabled ? crtc->mode.HDisplay : 0;
	    sPriv->planeA_h = enabled ? crtc->mode.VDisplay : 0;
d1304 2
a1305 2
	    sPriv->planeB_w = enabled ? crtc->mode.HDisplay : 0;
	    sPriv->planeB_h = enabled ? crtc->mode.VDisplay : 0;
d1369 5
d1404 1
a1404 1
    if (IS_I945G(pI830) || IS_G33CLASS(pI830))
d1408 1
a1408 1
    else if (IS_I945GM(pI830) || IS_845G(pI830))
d1508 1
a1508 1
   if (IS_I965GM(pI830) || IS_GM45(pI830))
a1580 1
    int dspstride_reg = (plane == 0) ? DSPASTRIDE : DSPBSTRIDE;
a1582 1
    int pipestat_reg = (pipe == 0) ? PIPEASTAT : PIPEBSTAT;
d1589 1
d1642 7
a1648 1
    ok = i830FindBestPLL(crtc, adjusted_mode->Clock, refclk, &clock);
d1660 24
a1683 1
    fp = clock.n << 16 | clock.m1 << 8 | clock.m2;
d1694 1
a1694 2
	    if ((IS_I945G(pI830) || IS_I945GM(pI830) || IS_G33CLASS(pI830)) &&
		!is_tv)
d1702 4
a1705 1
	dpll |= (1 << (clock.p1 - 1)) << 16;
a1906 1
    OUTREG(dspstride_reg, pScrn->displayWidth * pI830->cpp);
a1924 3

    /* Clear any FIFO underrun status that may have occurred normally */
    OUTREG(pipestat_reg, INREG(pipestat_reg) | FIFO_UNDERRUN);
d1983 2
a1984 1
    rotate_pitch = pScrn->displayWidth * pI830->cpp;
d1989 2
a1990 1
						  size, align, 0);
d2008 1
d2010 1
a2010 1
    unsigned long rotate_pitch;
d2016 1
a2016 1
    rotate_pitch = pScrn->displayWidth * pI830->cpp;
d2029 2
d2051 25
d2277 7
a2283 2
    clock.m2 = (fp & FP_M2_DIV_MASK) >> FP_M2_DIV_SHIFT;
    clock.n = (fp & FP_N_DIV_MASK) >> FP_N_DIV_SHIFT;
d2285 6
a2290 2
	clock.p1 = ffs((dpll & DPLL_FPA01_P1_POST_DIV_MASK) >>
		       DPLL_FPA01_P1_POST_DIV_SHIFT);
d2307 1
a2307 1
	    i9xx_clock(100000, &clock);
d2309 1
a2309 1
	    i9xx_clock(96000, &clock);
d2324 1
a2324 1
		i8xx_clock(66000, &clock); /* XXX: might not be 66MHz */
d2326 1
a2326 1
		i8xx_clock(48000, &clock);		
d2339 1
a2339 1
	    i8xx_clock(48000, &clock);
d2406 3
@


1.5
log
@Use the modeset_ctl ioctl to let the drm know that we're setting the
mode from userland. This means we can switch of the vblank ioctl when no
3d client is using it. Backported from newer ddxen to make use of the
new libdrm.

ok matthieu@@
@
text
@d671 1
a671 1
    if (IS_IGD_GM(pI830))
d683 1
a683 1
    if (IS_IGD_GM(pI830))
d696 1
d728 13
a768 1
	ErrorF("modeset: on -> off on plane %d\n", modeset.crtc);
a772 1
	ErrorF("modeset: off -> on on plane %d\n", modeset.crtc);
a781 1

a859 4
	/* May need to leave pipe A on */
	if ((pipe == 0) && (pI830->quirk_flag & QUIRK_PIPEA_FORCE))
	    return;

d863 2
a864 3
	/* Disable display plane */
	temp = INREG(dspcntr_reg);
	if ((temp & DISPLAY_PLANE_ENABLE) != 0)
d866 30
a895 25
	    OUTREG(dspcntr_reg, temp & ~DISPLAY_PLANE_ENABLE);
	    /* Flush the plane changes */
	    OUTREG(dspbase_reg, INREG(dspbase_reg));
	    POSTING_READ(dspbase_reg);
	}

	if (!IS_I9XX(pI830)) {
	    /* Wait for vblank for the disable to take effect */
	    i830WaitForVblank(pScrn);
	}

	/* Next, disable display pipes */
	temp = INREG(pipeconf_reg);
	if ((temp & PIPEACONF_ENABLE) != 0) {
	    OUTREG(pipeconf_reg, temp & ~PIPEACONF_ENABLE);
	    POSTING_READ(pipeconf_reg);
	}

	/* Wait for vblank for the disable to take effect. */
	i830WaitForVblank(pScrn);

	temp = INREG(dpll_reg);
	if ((temp & DPLL_VCO_ENABLE) != 0) {
	    OUTREG(dpll_reg, temp & ~DPLL_VCO_ENABLE);
	    POSTING_READ(dpll_reg);
a896 1

d1098 63
d1195 2
a1196 1
    int i;
d1219 1
d1221 2
d1236 2
d1240 9
a1248 1
    if (IS_I9XX(pI830)) {
d1277 2
a1278 1
	    if (IS_I945G(pI830) || IS_I945GM(pI830) || IS_G33CLASS(pI830))
d1301 1
a1301 1
	if (IS_I965G(pI830))
d1316 3
a1318 1
    if (is_tv)
d1324 1
a1324 2
#if 0
    else if (is_lvds)
a1325 1
#endif
d1472 3
d1507 3
@


1.4
log
@update to xf86-video-intel 2.3.2. Tested among others by okan@@.
@
text
@d38 1
d734 37
d838 1
d841 1
@


1.3
log
@Update to xf86-video-intel 2.3.1. Tested by many.
@
text
@d244 1
a244 1
i830PrintPll(char *prefix, intel_clock_t *clock)
d246 7
a252 5
    ErrorF("%s: dotclock %d vco %d ((m %d, m1 %d, m2 %d), n %d, (p %d, p1 %d, p2 %d))\n",
	   prefix, clock->dot, clock->vco,
	   clock->m, clock->m1, clock->m2,
	   clock->n, 
	   clock->p, clock->p1, clock->p2);
d1267 1
a1267 1
	i830PrintPll("chosen", &clock);
d1760 1
a1760 1
	i830PrintPll("probed", &clock);
@


1.2
log
@Update to Intel driver 2.2.1. But change default accelmethod to XAA.
Tested by landry@@, oga@@, steven@@, jakemsr@@.
@
text
@d544 2
d548 1
a548 1
i830_enable_fb_compression(xf86CrtcPtr crtc)
d559 1
a559 5
    if (INREG(FBC_CONTROL) & FBC_CTL_EN) {
	char cur_plane = (INREG(FBC_CONTROL2) & 1) ? 'b' : 'a';
	xf86DrvMsg(pScrn->scrnIndex, X_WARNING, "fbc already enabled on "
		   "plane %c, not enabling on plane %c\n", cur_plane,
		   plane ? 'b' : 'a');
a560 1
    }
d578 1
a578 1
    OUTREG(FBC_CONTROL2, FBC_CTL_FENCE_DBL | FBC_CTL_IDLE_FULL |
a594 3

    xf86DrvMsg(pScrn->scrnIndex, X_INFO, "fbc enabled on plane %c\n", plane ?
	       'b' : 'a');
d597 3
d601 1
a601 1
i830_disable_fb_compression(xf86CrtcPtr crtc)
a605 1
    char plane = (INREG(FBC_CONTROL2) & 1) ? 'b' : 'a';
d615 69
a683 1
    xf86DrvMsg(pScrn->scrnIndex, X_INFO, "fbc disabled on plane %c\n", plane);
d749 1
a749 1
    CARD32 temp;
d904 1
d908 2
d997 1
a997 1
	CARD16 hpllcc = pciReadWord(bridge, I855_HPLLCC);
d1025 1
a1025 1
    CARD32  pfit_control;
d1062 1
d1083 1
a1083 1
    CARD32 dpll = 0, fp = 0, dspcntr, pipeconf;
d1092 1
a1092 1
	I830OutputPrivatePtr intel_output = output->driver_private;
d1100 1
d1263 1
a1263 1
	    xf86PrintModeline(pScrn->scrnIndex, mode);
d1268 8
d1282 1
a1282 9
	CARD32 lvds = INREG(LVDS);

	if (dpll & DPLL_VCO_ENABLE)
	{
	    OUTREG(fp_reg, fp);
	    OUTREG(dpll_reg, dpll & ~DPLL_VCO_ENABLE);
	    POSTING_READ(dpll_reg);
	    usleep(150);
	}
d1293 15
a1307 4
	/* It would be nice to set 24 vs 18-bit mode (LVDS_A3_POWER_UP)
	 * appropriately here, but we need to look more thoroughly into how
	 * panels behave in the two modes.
	 */
d1318 2
d1508 1
a1508 1
	CARD32 dspcntr = intel_crtc->plane == 0 ? INREG(DSPACNTR) :
d1510 1
a1510 1
	CARD32 pipeconf = i == 0 ? INREG(PIPEACONF) :
d1686 2
a1687 2
    CARD32 dpll = INREG((pipe == 0) ? DPLL_A : DPLL_B);
    CARD32 fp;
d1716 4
a1719 2
	/* XXX: Handle the 100Mhz refclk */
	i9xx_clock(96000, &clock);
@


1.1
log
@Initial revision
@
text
@a531 30
static Bool
i830_use_fb_compression(xf86CrtcPtr crtc)
{
    ScrnInfoPtr pScrn = crtc->scrn;
    I830Ptr pI830 = I830PTR(pScrn);
    I830CrtcPrivatePtr	intel_crtc = crtc->driver_private;
    int plane = (intel_crtc->plane == 0 ? FBC_CTL_PLANEA : FBC_CTL_PLANEB);

    if (!pI830->fb_compression)
	return FALSE;

    if (!i830_display_tiled(crtc))
	return FALSE;

    /* Pre-965 only supports plane A */
    if (!IS_I965GM(pI830) && plane != FBC_CTL_PLANEA)
	return FALSE;

    /* Need 15, 16, or 32 (w/alpha) pixel format */
    if (!(pScrn->bitsPerPixel == 16 || /* covers 15 bit mode as well */
	  pScrn->bitsPerPixel == 32)) /* mode_set dtrt if fbc is in use */
	return FALSE;

    /*
     * No checks for pixel multiply, incl. horizontal, or interlaced modes
     * since they're currently unused.
     */
    return TRUE;
}

d583 1
d622 45
d743 4
a1198 8
    if (dpll & DPLL_VCO_ENABLE)
    {
	OUTREG(fp_reg, fp);
	OUTREG(dpll_reg, dpll & ~DPLL_VCO_ENABLE);
	POSTING_READ(dpll_reg);
	usleep(150);
    }

d1207 8
d1361 1
d1642 6
a1647 1
	    clock.p2 = 14;
@


1.1.1.1
log
@xf86-video-intel 2.2.0
@
text
@@


1.1.1.2
log
@Import intel driver v 2.2.0.90. tested by many, including krw@@ kettenis@@,
jakemsr@@, landry@@, beck@@ and oga@@. Thanks.
@
text
@d532 30
a612 1
    OUTREG(FBC_FENCE_OFF, crtc->y);
a650 44
static Bool
i830_use_fb_compression(xf86CrtcPtr crtc)
{
    ScrnInfoPtr pScrn = crtc->scrn;
    xf86CrtcConfigPtr xf86_config = XF86_CRTC_CONFIG_PTR(pScrn);
    I830Ptr pI830 = I830PTR(pScrn);
    I830CrtcPrivatePtr	intel_crtc = crtc->driver_private;
    int plane = (intel_crtc->plane == 0 ? FBC_CTL_PLANEA : FBC_CTL_PLANEB);
    int i, count = 0;

    /* Only available on one pipe at a time */
    for (i = 0; i < xf86_config->num_crtc; i++) {
	if (xf86_config->crtc[i]->enabled)
	    count++;
    }

    /* Here we disable it to catch one->two pipe enabled configs */
    if (count > 1) {
	i830_disable_fb_compression(crtc);
	return FALSE;
    }

    if (!pI830->fb_compression)
	return FALSE;

    if (!i830_display_tiled(crtc))
	return FALSE;

    /* Pre-965 only supports plane A */
    if (!IS_I965GM(pI830) && plane != FBC_CTL_PLANEA)
	return FALSE;

    /* Need 15, 16, or 32 (w/alpha) pixel format */
    if (!(pScrn->bitsPerPixel == 16 || /* covers 15 bit mode as well */
	  pScrn->bitsPerPixel == 32)) /* mode_set dtrt if fbc is in use */
	return FALSE;

    /*
     * No checks for pixel multiply, incl. horizontal, or interlaced modes
     * since they're currently unused.
     */
    return TRUE;
}

a726 4
	/* May need to leave pipe A on */
	if ((pipe == 0) && (pI830->quirk_flag & QUIRK_PIPEA_FORCE))
	    return;

d1179 8
a1194 8
	if (dpll & DPLL_VCO_ENABLE)
	{
	    OUTREG(fp_reg, fp);
	    OUTREG(dpll_reg, dpll & ~DPLL_VCO_ENABLE);
	    POSTING_READ(dpll_reg);
	    usleep(150);
	}

a1340 1
    memset(pI830->FbBase + intel_crtc->rotate_mem->offset, 0, size);
d1621 1
a1621 5

	    if ((INREG(LVDS) & LVDS_CLKB_POWER_MASK) == LVDS_CLKB_POWER_UP)
		clock.p2 = I8XX_P2_LVDS_SLOW;
	    else
		clock.p2 = I8XX_P2_LVDS_FAST;
@

