head	1.12;
access;
symbols
	OPENBSD_5_0:1.11.0.6
	OPENBSD_5_0_BASE:1.11
	OPENBSD_4_9:1.11.0.2
	OPENBSD_4_9_BASE:1.11
	OPENBSD_4_8:1.11.0.4
	OPENBSD_4_8_BASE:1.11
	OPENBSD_4_7:1.9.0.4
	OPENBSD_4_7_BASE:1.9
	OPENBSD_4_6:1.9.0.2
	OPENBSD_4_6_BASE:1.9
	OPENBSD_4_5:1.8.0.2
	OPENBSD_4_5_BASE:1.8
	OPENBSD_4_4:1.7.0.2
	OPENBSD_4_4_BASE:1.7
	OPENBSD_4_3_BASE:1.4
	OPENBSD_4_3:1.4.0.2
	v2_2_0_90:1.1.1.4
	v2_2_0:1.1.1.3
	OPENBSD_4_2:1.2.0.2
	OPENBSD_4_2_BASE:1.2
	v1_7_4:1.1.1.2
	v1_7_3:1.1.1.2
	v1_7_2:1.1.1.1
	xorg:1.1.1;
locks; strict;
comment	@ * @;


1.12
date	2011.11.29.12.39.03;	author oga;	state dead;
branches;
next	1.11;

1.11
date	2010.07.18.14.47.47;	author oga;	state Exp;
branches;
next	1.10;

1.10
date	2010.05.10.22.32.29;	author oga;	state Exp;
branches;
next	1.9;

1.9
date	2009.06.25.20.16.43;	author matthieu;	state Exp;
branches;
next	1.8;

1.8
date	2008.10.12.15.20.50;	author matthieu;	state Exp;
branches;
next	1.7;

1.7
date	2008.06.29.20.13.42;	author matthieu;	state Exp;
branches;
next	1.6;

1.6
date	2008.05.21.20.19.52;	author matthieu;	state Exp;
branches;
next	1.5;

1.5
date	2008.03.30.13.51.30;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2008.02.11.20.16.03;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2007.11.24.20.08.18;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2007.08.04.19.55.21;	author reyk;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.26.20.06.35;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.11.26.20.06.35;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2006.12.16.21.01.43;	author matthieu;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2007.11.24.19.44.39;	author matthieu;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2008.02.11.20.09.59;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.12
log
@Update the intel driver to a more recent version based on more recent
upsteam code.

Backporting keeping UMS changes by me, some bugfixes from kettenis@@.

Has been in snapshots for a while, committed on request so we can be
sure what people are running. This is a prerequesite for sandybridge
support but has those chipsets disabled for now until the correct code
has been added.
@
text
@/**************************************************************************

Copyright 1998-1999 Precision Insight, Inc., Cedar Park, Texas.
Copyright Â© 2002 by David Dawes.

All Rights Reserved.

Permission is hereby granted, free of charge, to any person obtaining a
copy of this software and associated documentation files (the
"Software"), to deal in the Software without restriction, including
without limitation the rights to use, copy, modify, merge, publish,
distribute, sub license, and/or sell copies of the Software, and to
permit persons to whom the Software is furnished to do so, subject to
the following conditions:

The above copyright notice and this permission notice (including the
next paragraph) shall be included in all copies or substantial portions
of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT.
IN NO EVENT SHALL THE COPYRIGHT HOLDERS AND/OR THEIR SUPPLIERS BE LIABLE FOR
ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

**************************************************************************/

/*
 * Authors:
 *   Keith Whitwell <keith@@tungstengraphics.com>
 *   David Dawes <dawes@@xfree86.org>
 *
 * Updated for Dual Head capabilities:
 *   Alan Hourihane <alanh@@tungstengraphics.com>
 */

/**
 * @@file i830_memory.c
 *
 * This is the video memory allocator.  Our memory allocation is different from
 * other graphics chips, where you have a fixed amount of graphics memory
 * available that you want to put to the best use.  Instead, we have almost no
 * memory pre-allocated, and we have to choose an appropriate amount of sytem
 * memory to use.
 *
 * The allocations we might do:
 *
 * - Ring buffer
 * - HW cursor block (either one block or four)
 * - Overlay registers
 * - Front buffer (screen 1)
 * - Front buffer (screen 2, only in zaphod mode)
 * - Back/depth buffer (3D only)
 * - Compatibility texture pool (optional, more is always better)
 * - New texture pool (optional, more is always better.  aperture allocation
 *     only)
 *
 * The user may request a specific amount of memory to be used
 * (intel->pEnt->videoRam != 0), in which case allocations have to fit within
 * that much aperture.  If not, the individual allocations will be
 * automatically sized, and will be fit within the maximum aperture size.
 * Only the actual memory used (not alignment padding) will get actual AGP
 * memory allocated.
 *
 * Given that the allocations listed are generally a page or more than a page,
 * our allocator will only return page-aligned offsets, simplifying the memory
 * binding process.  For smaller allocations, the acceleration architecture's
 * linear allocator is preferred.
 */

#ifdef HAVE_CONFIG_H
#include "config.h"
#endif

#include <assert.h>
#include <inttypes.h>
#include <string.h>
#include <sys/types.h>
#include <sys/ioctl.h>
#include <errno.h>

#include "xf86.h"
#include "xf86_OSproc.h"

#include "i830.h"
#include "i810_reg.h"
#include "i915_drm.h"

/* Our hardware status area is just a single page */
#define HWSTATUS_PAGE_SIZE GTT_PAGE_SIZE
#define PWRCTX_SIZE GTT_PAGE_SIZE

static i830_memory *
i830_allocate_aperture(ScrnInfoPtr scrn, const char *name,
		       unsigned long size, unsigned long pitch,
		       unsigned long alignment, int flags,
		       enum tile_format tile_format);

static int i830_set_tiling(ScrnInfoPtr scrn, unsigned int offset,
			   unsigned int pitch, unsigned int size,
			   enum tile_format tile_format);

static void i830_clear_tiling(ScrnInfoPtr scrn, unsigned int fence_nr);

/**
 * Returns the fence size for a tiled area of the given size.
 */
unsigned long i830_get_fence_size(intel_screen_private *intel, unsigned long size)
{
	unsigned long i;
	unsigned long start;

	if (IS_I965G(intel)) {
		/* The 965 can have fences at any page boundary. */
		return ALIGN(size, GTT_PAGE_SIZE);
	} else {
		/* Align the size to a power of two greater than the smallest fence
		 * size.
		 */
		if (IS_I9XX(intel))
			start = MB(1);
		else
			start = KB(512);

		for (i = start; i < size; i <<= 1) ;

		return i;
	}
}

/**
 * On some chips, pitch width has to be a power of two tile width, so
 * calculate that here.
 */
unsigned long
i830_get_fence_pitch(intel_screen_private *intel, unsigned long pitch, int format)
{
	unsigned long i;
	unsigned long tile_width = (format == I915_TILING_Y) ? 128 : 512;

	if (format == TILE_NONE)
		return pitch;

	/* 965 is flexible */
	if (IS_I965G(intel))
		return ROUND_TO(pitch, tile_width);

	/* Pre-965 needs power of two tile width */
	for (i = tile_width; i < pitch; i <<= 1) ;

	return i;
}

/**
 * On some chips, pitch width has to be a power of two tile width, so
 * calculate that here.
 */
static unsigned long i830_get_fence_alignment(intel_screen_private *intel, unsigned long size)
{
	if (IS_I965G(intel))
		return 4096;
	else
		return i830_get_fence_size(intel, size);
}

static Bool
i830_check_display_stride(ScrnInfoPtr scrn, int stride, Bool tiling)
{
	intel_screen_private *intel = intel_get_screen_private(scrn);
	int limit = KB(32);

	/* 8xx spec has always 8K limit, but tests show larger limit in
	   non-tiling mode, which makes large monitor work. */
	if ((IS_845G(intel) || IS_I85X(intel)) && tiling)
		limit = KB(8);

	if (IS_I915(intel) && tiling)
		limit = KB(8);

	if (IS_I965G(intel) && tiling)
		limit = KB(16);

	if (IS_IGDNG(intel) && tiling)
		limit = KB(32);

	if (stride <= limit)
		return TRUE;
	else
		return FALSE;
}

static Bool i830_bind_memory(ScrnInfoPtr scrn, i830_memory *mem)
{
	intel_screen_private *intel = intel_get_screen_private(scrn);

	if (mem == NULL || mem->bound || intel->use_drm_mode)
		return TRUE;

	if (mem->bo != NULL) {

		if (dri_bo_pin(mem->bo, mem->alignment) != 0) {
			xf86DrvMsg(scrn->scrnIndex, X_ERROR,
			    "Failed to pin %s: %s\n",
			    mem->name, strerror(errno));
			return FALSE;
		}

		mem->bound = TRUE;
		mem->offset = mem->bo->offset;
		mem->end = mem->offset + mem->size;
	} else {
		if (!intel->gtt_acquired)
			return TRUE;

		if (mem->key != -1 &&
			!xf86BindGARTMemory(scrn->scrnIndex, mem->key,
			    mem->agp_offset)) {
			return FALSE;
		}

		mem->bound = TRUE;
	}

	return TRUE;
}

static Bool i830_unbind_memory(ScrnInfoPtr scrn, i830_memory *mem)
{
	intel_screen_private *intel = intel_get_screen_private(scrn);

	if (mem == NULL || !mem->bound)
		return TRUE;

	if (mem->bo != NULL && !intel->use_drm_mode) {
		if (dri_bo_unpin(mem->bo) == 0) {
			mem->bound = FALSE;
			/* Give buffer obviously wrong offset/end until
			 * it's re-pinned.
			 */
			mem->offset = -1;
			mem->end = -1;
			return TRUE;
		} else {
			return FALSE;
		}
	}

	if (mem->key == -1 || xf86UnbindGARTMemory(scrn->scrnIndex, mem->key)) {
		mem->bound = FALSE;
		return TRUE;
	} else {
		return FALSE;
	}
}

void i830_free_memory(ScrnInfoPtr scrn, i830_memory * mem)
{
	if (mem == NULL)
		return;

	/* Free any AGP memory. */
	i830_unbind_memory(scrn, mem);

	if (mem->bo != NULL) {
		intel_screen_private *intel = intel_get_screen_private(scrn);
		dri_bo_unreference(mem->bo);
		if (intel->bo_list == mem) {
			intel->bo_list = mem->next;
			if (mem->next)
				mem->next->prev = NULL;
		} else {
			if (mem->prev)
				mem->prev->next = mem->next;
			if (mem->next)
				mem->next->prev = mem->prev;
		}
		free(mem->name);
		free(mem);
		return;
	}
	/* Disconnect from the list of allocations */
	if (mem->prev != NULL)
		mem->prev->next = mem->next;
	if (mem->next != NULL)
		mem->next->prev = mem->prev;

	if (mem->key != -1) {
		xf86DeallocateGARTMemory(scrn->scrnIndex, mem->key);
		mem->key = -1;
	}

	free(mem->name);
	free(mem);
}

/* Resets the state of the aperture allocator, freeing all memory that had
 * been allocated.
 */
void i830_reset_allocations(ScrnInfoPtr scrn)
{
	intel_screen_private *intel = intel_get_screen_private(scrn);
	int p;

	/* While there is any memory between the start and end markers, free it. */
	while (intel->memory_list->next->next != NULL) {
		i830_memory *mem = intel->memory_list->next;

		/* Don't reset BO allocator, which we set up at init. */
		if (intel->memory_manager == mem) {
			mem = mem->next;
			if (mem->next == NULL)
				break;
		}

		i830_free_memory(scrn, mem);
	}

	/* Free any allocations in buffer objects */
	while (intel->bo_list != NULL)
		i830_free_memory(scrn, intel->bo_list);

	/* Null out the pointers for all the allocations we just freed.  This is
	 * kind of gross, but at least it's just one place now.
	 */
	intel->cursor_mem = NULL;
	for (p = 0; p < 2; p++) {
		intel->cursor_mem_classic[p] = NULL;
		intel->cursor_mem_argb[p] = NULL;
	}
	intel->front_buffer = NULL;
	intel->overlay_regs = NULL;
	intel->power_context = NULL;
}

/**
 * Initialize's the driver's video memory allocator to allocate in the
 * given range.
 *
 * This sets up the kernel memory manager to manage as much of the memory
 * as we think it can, while leaving enough to us to fulfill our non-GEM
 * static allocations.  Some of these exist because of the need for physical
 * addresses to reference.
 */
Bool i830_allocator_init(ScrnInfoPtr scrn, unsigned long size)
{
	intel_screen_private *intel = intel_get_screen_private(scrn);
	i830_memory *start, *end;
	struct drm_i915_setparam sp;

	start = calloc(1, sizeof(*start));
	if (start == NULL)
		return FALSE;
	start->name = xstrdup("start marker");
	if (start->name == NULL) {
		free(start);
		return FALSE;
	}
	end = calloc(1, sizeof(*end));
	if (end == NULL) {
		free(start->name);
		free(start);
		return FALSE;
	}
	end->name = xstrdup("end marker");
	if (end->name == NULL) {
		free(start->name);
		free(start);
		free(end);
		return FALSE;
	}

	start->key = -1;
	start->offset = 0;
	start->end = start->offset;
	start->size = 0;
	start->next = end;
	end->key = -1;
	end->offset = size;
	end->end = end->offset;
	end->size = 0;
	end->prev = start;

	intel->memory_list = start;

	/* Now that we have our manager set up, give the kernel a piece of the
	 * aperture for GEM buffer object mapping. This is only needed for UXA
	 * and/or DRI2 when the kernel hasn't already managed this itself under
	 * KMS.  We need libdri interface5.4 or newer so we can rely on the lock
	 * being held after DRIScreenInit, rather than after DRIFinishScreenInit.
	 */

	if (!intel->use_drm_mode) {
		int mmsize;

		/* Take over all of the graphics aperture minus enough to for
		 * physical-address allocations of cursor/overlay registers.
		 */
		mmsize = size;

		/* Overlay and cursors, if physical, need to be allocated
		 * outside of the kernel memory manager.
		 */
		if (!OVERLAY_NOPHYSICAL(intel) && !OVERLAY_NOEXIST(intel)) {
			mmsize -= ROUND_TO(OVERLAY_SIZE, GTT_PAGE_SIZE);
		}
		if (intel->CursorNeedsPhysical) {
			mmsize -= 2 * (ROUND_TO(HWCURSOR_SIZE, GTT_PAGE_SIZE) +
			ROUND_TO(HWCURSOR_SIZE_ARGB, GTT_PAGE_SIZE));
		}
		if (intel->fb_compression)
			mmsize -= MB(6) + ROUND_TO_PAGE(FBC_LL_SIZE +
			    FBC_LL_PAD);

		/* Can't do GEM on stolen memory */
		mmsize -= intel->stolen_size;

		/* Create the aperture allocation */
		intel->memory_manager =
		   i830_allocate_aperture(scrn, "DRI memory manager",
	           mmsize, 0, GTT_PAGE_SIZE, ALIGN_BOTH_ENDS | NEED_NON_STOLEN,
	           TILE_NONE);

		if (intel->memory_manager != NULL) {
			struct drm_i915_gem_init init;
			int ret;

			sp.param = I915_SETPARAM_NUM_USED_FENCES;
			sp.value = 0; /* kernel gets them all */

			ret = drmCommandWrite(intel->drmSubFD,
			    DRM_I915_SETPARAM, &sp, sizeof(sp));
			if (ret != 0)
				ErrorF("no kernel exec fencing, wtf?");
			init.gtt_start = intel->memory_manager->offset;
			init.gtt_end = intel->memory_manager->offset +
			    intel->memory_manager->size;

			/* Tell the kernel to manage it */
			ret = ioctl(intel->drmSubFD, DRM_IOCTL_I915_GEM_INIT,
			    &init);
			if (ret != 0) {
				xf86DrvMsg(scrn->scrnIndex, X_ERROR,
				    "Failed to initialize kernel memory manager\n");
				i830_free_memory(scrn, intel->memory_manager);
				intel->memory_manager = NULL;
				return FALSE;
			}
			i830_init_bufmgr(scrn);
		} else {
			xf86DrvMsg(scrn->scrnIndex, X_ERROR,
			    "Failed to allocate space for kernel memory manager\n");
		}
	}

	return TRUE;
}

void i830_allocator_fini(ScrnInfoPtr scrn)
{
	intel_screen_private *intel = intel_get_screen_private(scrn);

	/* The memory manager is more special */
	if (intel->memory_manager) {
		i830_free_memory(scrn, intel->memory_manager);
		intel->memory_manager = NULL;
	}

	/* Free the start/end markers */
	free(intel->memory_list->next);
	free(intel->memory_list);
	intel->memory_list = NULL;
}

/**
 * Reads a GTT entry for the memory at the given offset and returns the
 * physical address.
 *
 * \return physical address if successful.
 * \return (uint64_t)-1 if unsuccessful.
 */
static uint64_t i830_get_gtt_physical(ScrnInfoPtr scrn, unsigned long offset)
{
	intel_screen_private *intel = intel_get_screen_private(scrn);
	uint32_t gttentry;

	/* We don't have GTTBase set up on i830 yet. */
	if (intel->GTTBase == NULL)
		return -1;

	gttentry = INGTT(offset / 1024);

	/* Mask out these reserved bits on this hardware. */
	if (!IS_I9XX(intel) || IS_I915G(intel) || IS_I915GM(intel) ||
	    IS_I945G(intel) || IS_I945GM(intel)) {
		gttentry &= ~PTE_ADDRESS_MASK_HIGH;
	}

	/* If it's not a mapping type we know, then bail. */
	if ((gttentry & PTE_MAPPING_TYPE_MASK) != PTE_MAPPING_TYPE_UNCACHED &&
	    (gttentry & PTE_MAPPING_TYPE_MASK) != PTE_MAPPING_TYPE_CACHED) {
		xf86DrvMsg(scrn->scrnIndex, X_ERROR,
		    "Unusable physical mapping type 0x%08x\n",
		    (unsigned int)(gttentry & PTE_MAPPING_TYPE_MASK));
		return -1;
	}
	assert((gttentry & PTE_VALID) != 0);

	return (gttentry & PTE_ADDRESS_MASK) |
	    ((uint64_t)(gttentry & PTE_ADDRESS_MASK_HIGH) << (32 - 4));
}

/**
 * Reads the GTT entries for stolen memory at the given offset, returning the
 * physical address.
 *
 * \return physical address if successful.
 * \return (uint64_t)-1 if unsuccessful.
 */
static uint64_t i830_get_stolen_physical(ScrnInfoPtr scrn,
    unsigned long offset, unsigned long size)
{
	intel_screen_private *intel = intel_get_screen_private(scrn);
	uint64_t physical;
	unsigned long scan;

	/* Check that the requested region is within stolen memory. */
	if (offset + size >= intel->stolen_size)
		return -1;

	physical = i830_get_gtt_physical(scrn, offset);
	if (physical == -1)
		return -1;

	/* Check that the following pages in our allocation follow the first
	 * page contiguously.
	 */
	for (scan = offset + 4096; scan < offset + size; scan += 4096) {
		uint64_t scan_physical = i830_get_gtt_physical(scrn, scan);

		if ((scan - offset) != (scan_physical - physical)) {
			xf86DrvMsg(scrn->scrnIndex, X_ERROR,
			    "Non-contiguous GTT entries: (%ld,0x16%"
			    PRIx64 ") vs  (%ld,0x%" PRIx64 ")\n",
			    scan, scan_physical, offset, physical);
			return -1;
		}
	}

    return physical;
}

/* Allocate aperture space for the given size and alignment, and returns the
 * memory allocation.
 *
 * Allocations are a minimum of a page, and will be at least page-aligned.
 */
static i830_memory *
i830_allocate_aperture(ScrnInfoPtr scrn, const char *name, unsigned long size,
    unsigned long pitch, unsigned long alignment, int flags,
    enum tile_format tile_format)
{
	intel_screen_private *intel = intel_get_screen_private(scrn);
	i830_memory *mem, *scan;

	mem = calloc(1, sizeof(*mem));
	if (mem == NULL)
		return NULL;

	/* No memory allocated to back the region */
	mem->key = -1;

	mem->name = xstrdup(name);
	if (mem->name == NULL) {
		free(mem);
		return NULL;
	}
	/* Only allocate page-sized increments. */
	size = ALIGN(size, GTT_PAGE_SIZE);
	mem->size = size;
	mem->allocated_size = size;
	mem->alignment = alignment;
	mem->tiling = tile_format;
	mem->pitch = pitch;
	mem->fence_nr = -1;

	if (alignment < GTT_PAGE_SIZE)
		alignment = GTT_PAGE_SIZE;

	for (scan = intel->memory_list; scan->next != NULL; scan = scan->next) {
		mem->offset = ROUND_TO(scan->end, alignment);
		if ((flags & NEED_PHYSICAL_ADDR) &&
		    mem->offset < intel->stolen_size) {
			/* If the allocation is entirely within stolen memory,
			 * and we're able to get the physical addresses out of
			 * the GTT and check that it's contiguous (it ought to
			 * be), then we can do our physical allocations there
			 * and not bother the kernel about it.  This helps
			 * avoid aperture fragmentation from our
			 * physical allocations.
			 */
			mem->bus_addr = i830_get_stolen_physical(scrn,
			    mem->offset, mem->size);

			if (mem->bus_addr == ((uint64_t)-1)) {
				/* Move the start of the allocation to just
				 * past the end of stolen memory.
				 */
				mem->offset = ROUND_TO(intel->stolen_size,
				    alignment);
			}
		}
		if ((flags & NEED_NON_STOLEN) &&
		    mem->offset < intel->stolen_size) {
			mem->offset = ROUND_TO(intel->stolen_size, alignment);
		}

		mem->end = mem->offset + size;
		if (flags & ALIGN_BOTH_ENDS)
		    mem->end = ROUND_TO(mem->end, alignment);
		if (mem->end <= scan->next->offset)
		    break;
	    }
	if (scan->next == NULL) {
		/* Reached the end of the list, and didn't find space */
		free(mem->name);
		free(mem);
		return NULL;
	}
	/* Insert new allocation into the list */
	mem->prev = scan;
	mem->next = scan->next;
	scan->next = mem;
	mem->next->prev = mem;

	return mem;
}

/**
 * Allocates the AGP memory necessary for the part of a memory allocation not
 * already covered by the stolen memory.
 *
 * The memory is automatically bound if we have the VT.
 */
static Bool
i830_allocate_agp_memory(ScrnInfoPtr scrn, i830_memory *mem, int flags)
{
	intel_screen_private *intel = intel_get_screen_private(scrn);
	unsigned long size;

	if (mem->key != -1)
		return TRUE;

	if (mem->offset + mem->size <= intel->stolen_size)
		return TRUE;

	if (mem->offset < intel->stolen_size)
		mem->agp_offset = intel->stolen_size;
	else
		mem->agp_offset = mem->offset;

	size = mem->size - (mem->agp_offset - mem->offset);

	if (flags & NEED_PHYSICAL_ADDR) {
		unsigned long agp_bus_addr;

		mem->key = xf86AllocateGARTMemory(scrn->scrnIndex, size, 2,
		    &agp_bus_addr);
		mem->bus_addr = agp_bus_addr;
	} else {
		mem->key = xf86AllocateGARTMemory(scrn->scrnIndex,
		    size, 0, NULL);
	}
	if (mem->key == -1 || ((flags & NEED_PHYSICAL_ADDR) &&
	    mem->bus_addr == 0)) {
		return FALSE;
	}

	return TRUE;
}

static i830_memory *i830_allocate_memory_bo(ScrnInfoPtr scrn, const char *name,
					    unsigned long size,
					    unsigned long pitch,
					    unsigned long align, int flags,
					    enum tile_format tile_format)
{
	intel_screen_private *intel = intel_get_screen_private(scrn);
	i830_memory *mem;
	uint32_t bo_tiling_mode = I915_TILING_NONE;
	int ret;

	assert((flags & NEED_PHYSICAL_ADDR) == 0);

	/* Only allocate page-sized increments. */
	size = ALIGN(size, GTT_PAGE_SIZE);
	align = i830_get_fence_alignment(intel, size);

	mem = calloc(1, sizeof(*mem));
	if (mem == NULL)
		return NULL;

	mem->name = xstrdup(name);
	if (mem->name == NULL) {
		free(mem);
		return NULL;
	}

	mem->bo = dri_bo_alloc(intel->bufmgr, name, size, align);

	if (!mem->bo) {
		free(mem->name);
		free(mem);
		return NULL;
	}

	/* Give buffer obviously wrong offset/end until it's pinned. */
	mem->offset = -1;
	mem->end = -1;
	mem->size = size;
	mem->allocated_size = size;
	mem->alignment = align;
	mem->tiling = tile_format;
	mem->pitch = pitch;
	mem->fence_nr = -1;

	/* Give buffer obviously wrong offset/end until it's pinned. */
	if (flags & NEED_LIFETIME_FIXED)
		mem->lifetime_fixed_offset = TRUE;

	switch (tile_format) {
	case TILE_XMAJOR:
		bo_tiling_mode = I915_TILING_X;
		break;
	case TILE_YMAJOR:
		bo_tiling_mode = I915_TILING_Y;
		break;
	case TILE_NONE:
	default:
		bo_tiling_mode = I915_TILING_NONE;
		break;
	}

	ret = drm_intel_bo_set_tiling(mem->bo, &bo_tiling_mode, pitch);
	if (ret != 0
	    || (bo_tiling_mode == I915_TILING_NONE
		&& tile_format != TILE_NONE)) {
		xf86DrvMsg(scrn->scrnIndex, X_ERROR,
			   "Failed to set tiling on %s: %s\n", mem->name,
			   ret == 0 ? "rejected by kernel" : strerror(-ret));
	}

	/* Bind it if we currently control the VT */
	if (scrn->vtSema || intel->use_drm_mode) {
		if (!i830_bind_memory(scrn, mem)) {
			dri_bo_unreference (mem->bo);
			free(mem->name);
			free(mem);
			return NULL;
		}
	}


	if (flags & DISABLE_REUSE)
		drm_intel_bo_disable_reuse(mem->bo);

	/* Insert new allocation into the list */
	mem->prev = NULL;
	mem->next = intel->bo_list;
	if (intel->bo_list != NULL)
		intel->bo_list->prev = mem;
	intel->bo_list = mem;

	return mem;
}

/* Allocates video memory at the given size, pitch, alignment and tile format.
 *
 * The memory will be bound automatically when the driver is in control of the
 * VT.  When the kernel memory manager is available and compatible with flags
 * (that is, flags doesn't say that the allocation must include a physical
 * address), that will be used for the allocation.
 *
 * flags:
 * - NEED_PHYSICAL_ADDR: Allocates the memory physically contiguous, and return
 *   the bus address for that memory.
 * - ALIGN_BOTH_ENDS: after choosing the alignment, align the end offset to
 *   @@alignment as well.
 * - NEED_NON-STOLEN: don't allow any part of the memory allocation to lie
 *   within stolen memory
 * - NEED_LIFETIME_FIXED: don't allow the buffer object to move throughout
 *   the entire Screen lifetime.  This means not using buffer objects, which
 *   get their offsets chosen at each EnterVT time.
 */
i830_memory *i830_allocate_memory(ScrnInfoPtr scrn, const char *name,
				  unsigned long size, unsigned long pitch,
				  unsigned long alignment, int flags,
				  enum tile_format tile_format)
{
	i830_memory *mem;
	intel_screen_private *intel = intel_get_screen_private(scrn);

	/* Manage tile alignment and size constraints */
	if (tile_format != TILE_NONE) {
		/* Only allocate page-sized increments. */
		size = ALIGN(size, GTT_PAGE_SIZE);

		/* Check for maximum tiled region size */
		if (IS_I9XX(intel)) {
			if (size > MB(128))
				return NULL;
		} else {
			if (size > MB(64))
				return NULL;
		}

		/* round to size necessary for the fence register to work */
		size = i830_get_fence_size(intel, size);
		alignment = i830_get_fence_alignment(intel, size);
	}

	/*
	 * Create a kernel buffer object when suitable.
	 * Under KMS, all graphics memory must be managed by the
	 * kernel. Under UMS, we separately reserve space for
	 *  a few objects (overlays, power context, cursors, etc).
	 */
	if ((intel->use_drm_mode ||
	    !(flags & (NEED_PHYSICAL_ADDR|NEED_LIFETIME_FIXED)))) {
		return i830_allocate_memory_bo(scrn, name, size, pitch,
		    alignment, flags, tile_format);
	} else {
		mem = i830_allocate_aperture(scrn, name, size, pitch,
		    alignment, flags, tile_format);
		if (mem == NULL)
			return NULL;

		if (!i830_allocate_agp_memory(scrn, mem, flags)) {
			i830_free_memory(scrn, mem);
			return NULL;
		}

		if (!i830_bind_memory(scrn, mem)) {
			i830_free_memory(scrn, mem);
			return NULL;
		}
	}

	return mem;
}

void
i830_describe_allocations(ScrnInfoPtr scrn, int verbosity, const char *prefix)
{
	intel_screen_private *intel = intel_get_screen_private(scrn);
	i830_memory *mem;

	if (intel->memory_list == NULL) {
		xf86DrvMsgVerb(scrn->scrnIndex, X_INFO, verbosity,
			       "%sMemory allocator not initialized\n", prefix);
		return;
	}

	if (intel->memory_list->next->next == NULL) {
		xf86DrvMsgVerb(scrn->scrnIndex, X_INFO, verbosity,
			       "%sNo memory allocations\n", prefix);
		return;
	}

	xf86DrvMsgVerb(scrn->scrnIndex, X_INFO, verbosity,
		       "%sFixed memory allocation layout:\n", prefix);

	for (mem = intel->memory_list->next; mem->next != NULL; mem = mem->next) {
		char phys_suffix[32] = "";
		char *tile_suffix = "";

		if (mem->offset >= intel->stolen_size &&
		    mem->prev->offset < intel->stolen_size) {
			xf86DrvMsgVerb(scrn->scrnIndex, X_INFO, verbosity,
			    "%s0x%08lx:            end of stolen memory\n",
			    prefix, intel->stolen_size);
		}

		if (mem->bus_addr != 0)
			snprintf(phys_suffix, sizeof(phys_suffix),
			    ", 0x%016" PRIx64 " physical\n", mem->bus_addr);
		if (mem->tiling == TILE_XMAJOR)
			tile_suffix = " X tiled";
		else if (mem->tiling == TILE_YMAJOR)
			tile_suffix = " Y tiled";

		xf86DrvMsgVerb(scrn->scrnIndex, X_INFO, verbosity,
			       "%s0x%08lx-0x%08lx: %s (%ld kB%s)%s\n", prefix,
			       mem->offset, mem->end - 1, mem->name,
			       mem->size / 1024, phys_suffix, tile_suffix);
	}
	xf86DrvMsgVerb(scrn->scrnIndex, X_INFO, verbosity,
	    "%s0x%08lx:            end of aperture\n", prefix, intel->FbMapSize);

	xf86DrvMsgVerb(scrn->scrnIndex, X_INFO, verbosity,
	    "%sBO memory allocation layout:\n", prefix);
	if (intel->memory_manager) {
		xf86DrvMsgVerb(scrn->scrnIndex, X_INFO, verbosity,
		    "%s0x%08lx:            start of memory manager\n",
		    prefix, intel->memory_manager->offset);
	}
	for (mem = intel->bo_list; mem != NULL; mem = mem->next) {
		char *tile_suffix = "";

		if (mem->tiling == TILE_XMAJOR)
			tile_suffix = " X tiled";
		else if (mem->tiling == TILE_YMAJOR)
			tile_suffix = " Y tiled";

		if (mem->bound) {
			xf86DrvMsgVerb(scrn->scrnIndex, X_INFO, verbosity,
			   "%s0x%08lx-0x%08lx: %s (%ld kB)%s\n", prefix,
			   mem->offset, mem->end - 1, mem->name,
			   mem->size / 1024, tile_suffix);
		} else {
			xf86DrvMsgVerb(scrn->scrnIndex, X_INFO, verbosity,
			    "%sunpinned          : %s (%ld kB)%s\n", prefix,
			    mem->name, mem->size / 1024, tile_suffix);
		}
	}
	if (intel->memory_manager) {
		xf86DrvMsgVerb(scrn->scrnIndex, X_INFO, verbosity,
		    "%s0x%08lx:            end of memory manager\n",
		    prefix, intel->memory_manager->end);
	}
}

/**
 * Allocate space for overlay registers.
 */
static Bool i830_allocate_overlay(ScrnInfoPtr scrn)
{
	intel_screen_private *intel = intel_get_screen_private(scrn);
	int flags = 0;

	/* Only allocate if overlay is going to be enabled. */
	if (!intel->XvEnabled)
		return TRUE;

	if (OVERLAY_NOEXIST(intel))
		return TRUE;

	if (!OVERLAY_NOPHYSICAL(intel)) {
		if (intel->use_drm_mode)
			return TRUE;
		flags |= NEED_PHYSICAL_ADDR;
	}

	intel->overlay_regs = i830_allocate_memory(scrn, "overlay registers",
	    OVERLAY_SIZE, PITCH_NONE, GTT_PAGE_SIZE, flags, TILE_NONE);
	if (intel->overlay_regs == NULL) {
		xf86DrvMsg(scrn->scrnIndex, X_WARNING,
		    "Failed to allocate Overlay register space.\n");
		/* This failure isn't fatal. */
	}

	if (flags & NEED_PHYSICAL_ADDR)
		if (intel->use_drm_mode)
			; /* need physical addr */

	return TRUE;
}

static Bool IsTileable(ScrnInfoPtr scrn, int pitch)
{
	intel_screen_private *intel = intel_get_screen_private(scrn);

	if (IS_I965G(intel)) {
		if (pitch / 512 * 512 == pitch && pitch <= KB(128))
			return TRUE;
		else
			return FALSE;
	}

	/*
	 * Allow tiling for pitches that are a power of 2 multiple of 128 bytes,
	 * up to 64 * 128 (= 8192) bytes.
	 */
	switch (pitch) {
	case 128:
	case 256:
		if (IS_I945G(intel) || IS_I945GM(intel) || IS_G33CLASS(intel))
			return TRUE;
		else
			return FALSE;
	case 512:
	case KB(1):
	case KB(2):
	case KB(4):
	case KB(8):
		return TRUE;
	default:
		return FALSE;
	}
}

/**
 * Allocates a framebuffer for a screen.
 *
 * Used once for each X screen, so once with RandR 1.2 and twice with classic
 * dualhead.
 */
i830_memory *i830_allocate_framebuffer(ScrnInfoPtr scrn)
{
	intel_screen_private *intel = intel_get_screen_private(scrn);
	unsigned int pitch = scrn->displayWidth * intel->cpp;
	unsigned long minspace;
	int align;
	long size, fb_height;
	int flags;
	i830_memory *front_buffer = NULL;
	enum tile_format tile_format = TILE_NONE;

	flags = ALLOW_SHARING | DISABLE_REUSE;

	/* We'll allocate the fb such that the root window will fit regardless of
	 * rotation.
	 */
	fb_height = scrn->virtualY;

	/* Calculate how much framebuffer memory to allocate.  For the
	 * initial allocation, calculate a reasonable minimum.  This is
	 * enough for the virtual screen size.
	 */
	minspace = pitch * scrn->virtualY;

	size = ROUND_TO_PAGE(pitch * fb_height);

	if (intel->tiling)
		tile_format = TILE_XMAJOR;

	if (!IsTileable(scrn, pitch))
		tile_format = TILE_NONE;

	if (!i830_check_display_stride(scrn, pitch, tile_format != TILE_NONE)) {
		xf86DrvMsg(scrn->scrnIndex, X_ERROR,
			   "Front buffer stride %d kB "
			   "exceed display limit\n", pitch / 1024);
		return NULL;
	}

	/* Attempt to allocate it tiled first if we have page flipping on. */
	if (tile_format != TILE_NONE) {
		/* XXX: probably not the case on 965 */
		if (IS_I9XX(intel))
			align = MB(1);
		else
			align = KB(512);
	} else
		align = KB(64);
	front_buffer = i830_allocate_memory(scrn, "front buffer", size,
					    pitch, align, flags, tile_format);

	if (front_buffer == NULL) {
		xf86DrvMsg(scrn->scrnIndex, X_ERROR,
			   "Failed to allocate framebuffer.\n");
		return NULL;
	}

	if (intel->FbBase && front_buffer->bound)
		memset (intel->FbBase + front_buffer->offset, 0, size);
	i830_set_gem_max_sizes(scrn);

	return front_buffer;
}

static Bool i830_allocate_cursor_buffers(ScrnInfoPtr scrn)
{
	intel_screen_private *intel = intel_get_screen_private(scrn);
	xf86CrtcConfigPtr xf86_config = XF86_CRTC_CONFIG_PTR(scrn);
	int flags, i;
	long size;

	if (intel->use_drm_mode)
		intel->CursorNeedsPhysical = FALSE;

	flags = intel->CursorNeedsPhysical ? NEED_PHYSICAL_ADDR : 0;

	flags |= DISABLE_REUSE;


	if (!intel->use_drm_mode) {
		/* Try to allocate one big blob for our cursor memory.
		 * This works around a limitation in the FreeBSD AGP driver
		 * that allows only one physical allocation larger than a page,
		 * and could allow us to pack the cursors smaller.
		 */
		size = xf86_config->num_crtc * (HWCURSOR_SIZE +
		    HWCURSOR_SIZE_ARGB);

		intel->cursor_mem = i830_allocate_memory(scrn, "HW cursors",
		    size, PITCH_NONE, GTT_PAGE_SIZE, flags, TILE_NONE);
		if (intel->cursor_mem != NULL)
			return TRUE;
	}

	/*
	 * Allocate four separate buffers when the kernel doesn't support
	 * large allocations as on Linux. If any of these fail, just
	 * bail back to software cursors everywhere
	 */
	for (i = 0; i < xf86_config->num_crtc; i++) {
		if (!intel->use_drm_mode) {
			intel->cursor_mem_classic[i] =
			    i830_allocate_memory(scrn, "Core cursor",
			        HWCURSOR_SIZE, PITCH_NONE, GTT_PAGE_SIZE,
			        flags, TILE_NONE);
		if (!intel->cursor_mem_classic[i])
			return FALSE;
		}
		intel->cursor_mem_argb[i] =
		    i830_allocate_memory(scrn, "ARGB cursor",
					 HWCURSOR_SIZE_ARGB, PITCH_NONE,
					 GTT_PAGE_SIZE, flags, TILE_NONE);
		if (!intel->cursor_mem_argb[i])
			return FALSE;

	}
	return TRUE;
}

static void i830_setup_fb_compression(ScrnInfoPtr scrn)
{
    intel_screen_private *intel = intel_get_screen_private(scrn);
    unsigned long compressed_size;
    unsigned long fb_height;

    if (scrn->virtualX > scrn->virtualY)
	fb_height = scrn->virtualX;
    else
	fb_height = scrn->virtualY;

    /* Only mobile chips since 845 support this feature */
    if (!IS_MOBILE(intel)) {
	intel->fb_compression = FALSE;
	goto out;
    }

    if (IS_GM45(intel)) {
	/* Update i830_display.c too if compression ratio changes */
	compressed_size = fb_height * (scrn->displayWidth / 4);
    } else {
	compressed_size = MB(6);
    }

    /*
     * Compressed framebuffer limitations:
     *   - contiguous, physical, uncached memory
     *   - ideally as large as the front buffer(s), smaller sizes cache less
     *   - uncompressed buffer must be tiled w/pitch 2k-16k
     *   - uncompressed fb is <= 2048 in width, 0 mod 8
     *   - uncompressed fb is <= 1536 in height, 0 mod 2
     *   - compressed fb stride is <= uncompressed stride
     *   - SR display watermarks must be equal between 16bpp and 32bpp?
     *   - both compressed and line buffers must be in stolen memory
     */
    intel->compressed_front_buffer =
	i830_allocate_memory(scrn, "compressed frame buffer",
			     compressed_size, PITCH_NONE,
			     KB(4), NEED_PHYSICAL_ADDR,
			     TILE_NONE);

    if (!intel->compressed_front_buffer) {
	intel->fb_compression = FALSE;
	goto out;
    }

    if (!IS_GM45(intel)) {
	intel->compressed_ll_buffer =
	    i830_allocate_memory(scrn, "compressed ll buffer",
				 FBC_LL_SIZE + FBC_LL_PAD,
				 PITCH_NONE, KB(4),
				 NEED_PHYSICAL_ADDR,
				 TILE_NONE);
	if (!intel->compressed_ll_buffer) {
	    i830_free_memory(scrn, intel->compressed_front_buffer);
	    intel->fb_compression = FALSE;
	    goto out;
	}
    }

out:
    if (!intel->fb_compression)
	xf86DrvMsg(scrn->scrnIndex, X_WARNING, "Allocation error, framebuffer"
		   " compression disabled\n");
	
    return;
}
/*
 * Allocate memory for 2D operation.  This includes the (front) framebuffer,
 * ring buffer, scratch memory, HW cursor.
 */
Bool i830_allocate_2d_memory(ScrnInfoPtr scrn)
{
	intel_screen_private *intel = intel_get_screen_private(scrn);

	if (!intel->use_drm_mode) {
		if (!xf86AgpGARTSupported() ||
		    !xf86AcquireGART(scrn->scrnIndex)) {
			xf86DrvMsg(scrn->scrnIndex, X_ERROR,
			    "AGP GART support is either not available or "
			    "cannot be used.\n"
			    "\tMake sure your kernel has agpgart support or has\n"
			    "\tthe agpgart module loaded.\n");
			return FALSE;
		}
	}

	if (intel->fb_compression)
		i830_setup_fb_compression(scrn);

	/* Next, allocate other fixed-size allocations we have. */
	if (!i830_allocate_cursor_buffers(scrn)) {
		xf86DrvMsg(scrn->scrnIndex, X_ERROR,
			   "Failed to allocate HW cursor space.\n");
		return FALSE;
	}

	if (!intel->use_drm_mode)
		i830_allocate_overlay(scrn);

	intel->front_buffer = i830_allocate_framebuffer(scrn);
	if (intel->front_buffer == NULL)
		return FALSE;

	return TRUE;
}

Bool
i830_allocate_pwrctx(ScrnInfoPtr scrn)
{
    intel_screen_private *intel = intel_get_screen_private(scrn);

    if (intel->use_drm_mode)
	return TRUE;

    intel->power_context = i830_allocate_memory(scrn, "power context",
						PWRCTX_SIZE, PITCH_NONE,
						GTT_PAGE_SIZE,
						NEED_LIFETIME_FIXED,
						TILE_NONE);
    if (!intel->power_context) {
	xf86DrvMsg(scrn->scrnIndex, X_WARNING,
		"Failed to allocate power context.\n");
	return FALSE;
    }
    return TRUE;
}

/**
 * Sets up tiled surface registers ("fences") for the hardware.
 *
 * The fences control automatic tiled address swizzling for CPU access of the
 * framebuffer, and may be used in many rendering operations instead of
 * manually supplying tiling enables per surface.
 */
static int
i830_set_tiling(ScrnInfoPtr scrn, unsigned int offset,
		unsigned int pitch, unsigned int size,
		enum tile_format tile_format)
{
    intel_screen_private *intel = intel_get_screen_private(scrn);
    uint32_t val;
    uint32_t fence_mask = 0;
    unsigned int fence_pitch;
    unsigned int max_fence;
    unsigned int fence_nr;

    DPRINTF(PFX, "i830_set_tiling(): 0x%08x, %d, %d kByte\n",
	    offset, pitch, size / 1024);

    assert(tile_format != TILE_NONE);

    intel_sync(scrn);

    if (IS_I965G(intel))
	max_fence = FENCE_NEW_NR;
    else
	max_fence = FENCE_NR;

    for (fence_nr = 0; fence_nr < max_fence; fence_nr++) {
	if (!intel->fence_used[fence_nr])
	    break;
    }
    if (fence_nr == max_fence)
	FatalError("Ran out of fence registers at %d\n", fence_nr);

    intel->fence_used[fence_nr] = TRUE;

    if (IS_I965G(intel)) {
	uint32_t fence_start, fence_end;

	switch (tile_format) {
	case TILE_XMAJOR:
	    fence_start = (((pitch / 128) - 1) << 2) | offset | 1;
	    fence_start |= I965_FENCE_X_MAJOR;
            break;
	case TILE_YMAJOR:
            /* YMajor can be 128B aligned but the current code dictates
             * otherwise. This isn't a problem apart from memory waste.
             * FIXME */
	    fence_start = (((pitch / 128) - 1) << 2) | offset | 1;
	    fence_start |= I965_FENCE_Y_MAJOR;
            break;
	default:
	    return -1;
	}

	/* The end marker is the address of the last page in the allocation. */
	fence_end = offset + size - 4096;

	OUTREG(FENCE_NEW + fence_nr * 8, fence_start);
	OUTREG(FENCE_NEW + fence_nr * 8 + 4, fence_end);
    } else {
	if (IS_I9XX(intel))
	    fence_mask = ~I915G_FENCE_START_MASK;
	else
	    fence_mask = ~I830_FENCE_START_MASK;

	if (offset & fence_mask) {
	    FatalError("i830_set_tiling(): %d: offset (0x%08x) is not %s "
		       "aligned\n",
		       fence_nr, offset, (IS_I9XX(intel)) ? "1MB" : "512k");
	}

	if (offset % size) {
	    FatalError("i830_set_tiling(): %d: offset (0x%08x) is not "
		       "size (%dk) aligned\n",
		       fence_nr, offset, size / 1024);
	}

	if (pitch & 127) {
	    FatalError("i830_set_tiling(): %d: pitch (%d) not a multiple of "
		       "128 bytes\n",
		       fence_nr, pitch);
	}

	val = offset | FENCE_VALID;

	switch (tile_format) {
	case TILE_XMAJOR:
	    val |= FENCE_X_MAJOR;
	    break;
	case TILE_YMAJOR:
	    val |= FENCE_Y_MAJOR;
	    break;
	case TILE_NONE:
	    break;
	}

	if (IS_I9XX(intel)) {
	    switch (size) {
	    case MB(1):
		val |= I915G_FENCE_SIZE_1M;
		break;
	    case MB(2):
		val |= I915G_FENCE_SIZE_2M;
		break;
	    case MB(4):
		val |= I915G_FENCE_SIZE_4M;
		break;
	    case MB(8):
		val |= I915G_FENCE_SIZE_8M;
		break;
	    case MB(16):
		val |= I915G_FENCE_SIZE_16M;
		break;
	    case MB(32):
		val |= I915G_FENCE_SIZE_32M;
		break;
	    case MB(64):
		val |= I915G_FENCE_SIZE_64M;
		break;
	    default:
		FatalError("i830_set_tiling(): %d: illegal size (%d kByte)\n",
			   fence_nr, size / 1024);
	    }
	} else {
	    switch (size) {
	    case KB(512):
		val |= FENCE_SIZE_512K;
		break;
	    case MB(1):
		val |= FENCE_SIZE_1M;
		break;
	    case MB(2):
		val |= FENCE_SIZE_2M;
		break;
	    case MB(4):
		val |= FENCE_SIZE_4M;
		break;
	    case MB(8):
		val |= FENCE_SIZE_8M;
		break;
	    case MB(16):
		val |= FENCE_SIZE_16M;
		break;
	    case MB(32):
		val |= FENCE_SIZE_32M;
		break;
	    case MB(64):
		val |= FENCE_SIZE_64M;
		break;
	    default:
		FatalError("i830_set_tiling(): %d: illegal size (%d kByte)\n",
			   fence_nr, size / 1024);
	    }
	}

	if ((IS_I945G(intel) || IS_I945GM(intel) || IS_G33CLASS(intel)) &&
	    tile_format == TILE_YMAJOR)
	    fence_pitch = pitch / 128;
	else if (IS_I9XX(intel))
	    fence_pitch = pitch / 512;
	else
	    fence_pitch = pitch / 128;

	switch (fence_pitch) {
	case 1:
	    val |= FENCE_PITCH_1;
	    break;
	case 2:
	    val |= FENCE_PITCH_2;
	    break;
	case 4:
	    val |= FENCE_PITCH_4;
	    break;
	case 8:
	    val |= FENCE_PITCH_8;
	    break;
	case 16:
	    val |= FENCE_PITCH_16;
	    break;
	case 32:
	    val |= FENCE_PITCH_32;
	    break;
	case 64:
	    val |= FENCE_PITCH_64;
	    break;
	default:
	    FatalError("i830_set_tiling(): %d: illegal pitch (%d)\n",
		       fence_nr, pitch);
	}

	OUTREG(FENCE + fence_nr * 4, val);
    }

    return fence_nr;
}

static void
i830_clear_tiling(ScrnInfoPtr scrn, unsigned int fence_nr)
{
    intel_screen_private *intel = intel_get_screen_private(scrn);

    if (IS_I965G(intel)) {
	OUTREG(FENCE_NEW + fence_nr * 8, 0);
	OUTREG(FENCE_NEW + fence_nr * 8 + 4, 0);
    } else {
	OUTREG(FENCE + fence_nr * 4, 0);
    }
    intel->fence_used[fence_nr] = FALSE;
}

/**
 * Called at EnterVT to grab the AGP GART and bind our allocations.
 *
 * In zaphod mode, this will walk the list trying to bind twice, since each
 * intel points to the same allocation list, but the bind_memory will just
 * no-op then.
 */
Bool i830_bind_all_memory(ScrnInfoPtr scrn)
{
	intel_screen_private *intel = intel_get_screen_private(scrn);

	if (intel->memory_list == NULL)
		return TRUE;

	if (intel->use_drm_mode || (xf86AgpGARTSupported() &&
	    !intel->gtt_acquired)) {
		i830_memory *mem;

		if (!intel->use_drm_mode) {
			if (!xf86AcquireGART(scrn->scrnIndex))
				return FALSE;
			intel->gtt_acquired = TRUE;
		}

		for (mem = intel->memory_list->next; mem->next != NULL;
		    mem = mem->next) {
			if (!mem->bound && !i830_bind_memory(scrn, mem)) {
				/* This shouldn't happen */
				FatalError("Couldn't bind memory for %s\n",
				    mem->name);
			}
		}
		for (mem = intel->bo_list; mem != NULL; mem = mem->next) {
			if (mem->bound)
				continue;
			if (!mem->lifetime_fixed_offset &&
			    !i830_bind_memory(scrn, mem))
			FatalError("Couldn't bind memory for BO %s\n",
			    mem->name);
		}
	}
	if (intel->use_drm_mode) {
		int	i;
		xf86CrtcConfigPtr xf86_config = XF86_CRTC_CONFIG_PTR(scrn);
		for (i = 0; i < xf86_config->num_crtc; i++)
			drmmode_crtc_set_cursor_bo(xf86_config->crtc[i],
			    intel->cursor_mem_argb[i]->bo);
	} else
		i830_update_cursor_offsets(scrn);
	i830_set_gem_max_sizes(scrn);

	if (intel->front_buffer)
		scrn->fbOffset = intel->front_buffer->offset;

	return TRUE;
}

/** Called at LeaveVT, to unbind all of our AGP allocations. */
Bool
i830_unbind_all_memory(ScrnInfoPtr scrn)
{
    intel_screen_private *intel = intel_get_screen_private(scrn);

    if (intel->use_drm_mode || (xf86AgpGARTSupported() &&
				intel->gtt_acquired)) {
	i830_memory *mem;

	for (mem = intel->memory_list->next; mem->next != NULL;
	     mem = mem->next)
	{
	    i830_unbind_memory(scrn, mem);
	}
	for (mem = intel->bo_list; mem != NULL; mem = mem->next) {
	    /* Don't unpin objects which require that their offsets never
	     * change.
	     */
	    if (!mem->lifetime_fixed_offset)
		i830_unbind_memory(scrn, mem);
	}

	if (!intel->use_drm_mode) {
	    intel->gtt_acquired = FALSE;

	    if (!xf86ReleaseGART(scrn->scrnIndex))
		return FALSE;
	}
    }

    return TRUE;
}

/**
 * Returns the amount of system memory that could potentially be allocated
 * from AGP, in kB.
 */
long
I830CheckAvailableMemory(ScrnInfoPtr scrn)
{
    AgpInfoPtr agpinf;
    int maxPages;

    if (!xf86AgpGARTSupported() ||
	!xf86AcquireGART(scrn->scrnIndex) ||
	(agpinf = xf86GetAGPInfo(scrn->scrnIndex)) == NULL ||
	!xf86ReleaseGART(scrn->scrnIndex))
	return -1;

    maxPages = agpinf->totalPages - agpinf->usedPages;
    xf86DrvMsgVerb(scrn->scrnIndex, X_INFO, 2, "%s: %d kB available\n",
		   "I830CheckAvailableMemory", maxPages * 4);

    return maxPages * 4;
}

#ifdef INTEL_XVMC
/*
 * Allocate memory for MC compensation
 */
Bool i830_allocate_xvmc_buffer(ScrnInfoPtr scrn, const char *name,
			       i830_memory ** buffer, unsigned long size,
			       int flags)
{
	intel_screen_private *intel = intel_get_screen_private(scrn);

	*buffer = i830_allocate_memory(scrn, name, size, PITCH_NONE,
				       GTT_PAGE_SIZE, flags, TILE_NONE);

	if (!*buffer) {
		xf86DrvMsg(scrn->scrnIndex, X_ERROR,
			   "Failed to allocate memory for %s.\n", name);
		return FALSE;
	}

	if (intel->use_drm_mode && (*buffer)->bo) {
		if (drm_intel_bo_pin((*buffer)->bo, GTT_PAGE_SIZE)) {
			i830_free_memory(scrn, *buffer);
			xf86DrvMsg(scrn->scrnIndex, X_ERROR,
				   "Failed to bind XvMC buffer bo!\n");
			return FALSE;
		}

		(*buffer)->offset = (*buffer)->bo->offset;
	}

	return TRUE;
}

void i830_free_xvmc_buffer(ScrnInfoPtr scrn, i830_memory * buffer)
{
	intel_screen_private *intel = intel_get_screen_private(scrn);

	if (intel->use_drm_mode && buffer->bo)
		drm_intel_bo_unpin(buffer->bo);

	i830_free_memory(scrn, buffer);
}

#endif

static void i830_set_max_bo_size(intel_screen_private *intel,
				 const struct drm_i915_gem_get_aperture *aperture)
{
	if (aperture->aper_available_size)
		/* Large BOs will tend to hit SW fallbacks frequently, and also will
		 * tend to fail to successfully map when doing SW fallbacks because we
		 * overcommit address space for BO access, or worse cause aperture
		 * thrashing.
		 */
		intel->max_bo_size = aperture->aper_available_size / 2;
	else
		intel->max_bo_size = 64 * 1024 * 1024;
}

static void i830_set_max_gtt_map_size(intel_screen_private *intel,
				      const struct drm_i915_gem_get_aperture *aperture)
{
	if (aperture->aper_available_size)
		/* Let objects up get bound up to the size where only 2 would fit in
		 * the aperture, but then leave slop to account for alignment like
		 * libdrm does.
		 */
		intel->max_gtt_map_size =
			aperture->aper_available_size * 3 / 4 / 2;
	else
		intel->max_gtt_map_size = 16 * 1024 * 1024;
}

static void i830_set_max_tiling_size(intel_screen_private *intel,
				     const struct drm_i915_gem_get_aperture *aperture)
{
	if (aperture->aper_available_size)
		/* Let objects be tiled up to the size where only 4 would fit in
		 * the aperture, presuming worst case alignment.
		 */
		intel->max_tiling_size = aperture->aper_available_size / 4;
	else
		intel->max_tiling_size = 4 * 1024 * 1024;
}

void i830_set_gem_max_sizes(ScrnInfoPtr scrn)
{
	intel_screen_private *intel = intel_get_screen_private(scrn);
	struct drm_i915_gem_get_aperture aperture;

	aperture.aper_available_size = 0;
	ioctl(intel->drmSubFD, DRM_IOCTL_I915_GEM_GET_APERTURE, &aperture);

	i830_set_max_bo_size(intel, &aperture);
	i830_set_max_gtt_map_size(intel, &aperture);
	i830_set_max_tiling_size(intel, &aperture);
}
@


1.11
log
@Update the intel driver to (mostly) a backport of 2.12.

It is missing a few commits that I have yet to verify (ones that try and
continue if we lock the gpu rendering engine and can't reset it, for
example) taht will be verified and sent out for extra testing soon.

Should contain a bunch of speedups and some correctness improvements
(though rendercheck still gives some errors that I am looking into).

This has been in snaps since the first day of c2k10, any known issues
with just this driver have (to my knowledge) been fixed since. A problem
with macbooks pointed out by otto happens with both this and the in-tree
driver and thus doesn't stop this moving forward.

As well as the 2.12 improvements, this driver also has a backport
(partially aided by the backports in RHEL 5 kindly provided by Dave
Airlie) from the kms code of modesetting support for ironlake (arrandale
and clarkdale: the IGDs build into intel nehalem cpu dies) which has
been tested on a number of chipsets. Note that Display port and eDP
displays have not yet been worked on (and probably won't until I can
find a displayport monitor), but VGA and lvds at least are known to
work, sure beats vesa.

"no objection on my side" matthieu@@, prodding (as always) from princess
marco.
@
text
@@


1.10
log
@Update the intel driver to 2.9.1 plus backports.

2.9.1 is the last version of the intel DDX that supports UMS (User
modesetting), with 2.10 onwards being purely KMS only. As such, this
driver contains backports of almost every correctness or performance
related fix to the rendering layer in later intel drivers. This driver
*REQUIRES* a GEM enabled kernel. it claims to support non-gem mode but
this is essentially unmaintained and due to the way the abstraciton
works is slow, if it works at all (it often does not). You have been
warned.

tested by many many people on tech over the last few weeks.
@
text
@d201 1
a201 1
	if (intel->have_gem && mem->bo != NULL) {
a225 5
	if (mem->tiling != TILE_NONE && !intel->kernel_exec_fencing) {
		mem->fence_nr = i830_set_tiling(scrn, mem->offset, mem->pitch,
		    mem->allocated_size, mem->tiling);
	}

a235 4
	if (mem->tiling != TILE_NONE && !intel->use_drm_mode &&
	    !intel->kernel_exec_fencing)
		i830_clear_tiling(scrn, mem->fence_nr);

d279 2
a280 2
		xfree(mem->name);
		xfree(mem);
d294 2
a295 2
	xfree(mem->name);
	xfree(mem);
a334 2
	intel->ring.mem = NULL;
	intel->fake_bufmgr_mem = NULL;
d352 1
a352 1
	start = xcalloc(1, sizeof(*start));
d357 1
a357 1
		xfree(start);
d360 1
a360 1
	end = xcalloc(1, sizeof(*end));
d362 2
a363 2
		xfree(start->name);
		xfree(start);
d368 3
a370 3
		xfree(start->name);
		xfree(start);
		xfree(end);
d434 2
a435 2
			if (ret == 0)
				intel->kernel_exec_fencing = TRUE;
d443 1
a443 4
			if (ret == 0) {
				intel->have_gem = TRUE;
				i830_init_bufmgr(scrn);
			} else {
d448 1
d450 1
d464 2
a465 2
	/* The memory manager is more special */ if
	(intel->memory_manager) {
d567 1
a567 1
	mem = xcalloc(1, sizeof(*mem));
d576 1
a576 1
		xfree(mem);
d627 2
a628 2
		xfree(mem->name);
		xfree(mem);
d700 1
a700 1
	mem = xcalloc(1, sizeof(*mem));
d706 1
a706 1
		xfree(mem);
d713 2
a714 2
		xfree(mem->name);
		xfree(mem);
d758 2
a759 2
			xfree(mem->name);
			xfree(mem);
d829 1
a829 1
	if (intel->have_gem && (intel->use_drm_mode ||
a933 25
static Bool i830_allocate_ringbuffer(ScrnInfoPtr scrn)
{
	intel_screen_private *intel = intel_get_screen_private(scrn);

	if (intel->have_gem || intel->ring.mem != NULL)
		return TRUE;

	/* We don't have any mechanism in the DRM yet to alert it that we've
	 * moved the ringbuffer since init time, so allocate it fixed for its
	 * lifetime.
	 */
	intel->ring.mem = i830_allocate_memory(scrn, "ring buffer",
	    PRIMARY_RINGBUFFER_SIZE, PITCH_NONE, GTT_PAGE_SIZE,
	    NEED_LIFETIME_FIXED, TILE_NONE);
	if (intel->ring.mem == NULL) {
		xf86DrvMsg(scrn->scrnIndex, X_ERROR,
		    "Failed to allocate Ring Buffer space\n");
		return FALSE;
	}

	intel->ring.tail_mask = intel->ring.mem->size - 1;
	intel->ring.virtual_start = intel->FbBase + intel->ring.mem->offset;
	return TRUE;
}

a1212 4

		/* Allocate the ring buffer first, so it ends up in stolen mem. */
		if (!i830_allocate_ringbuffer(scrn))
			return FALSE;
a1224 12
	if (!intel->have_gem) {
		intel->fake_bufmgr_mem = i830_allocate_memory(scrn,
		    "fake bufmgr", MB(8), PITCH_NONE, GTT_PAGE_SIZE, 0,
		    TILE_NONE);
		if (intel->fake_bufmgr_mem == NULL) {
			xf86DrvMsg(scrn->scrnIndex, X_WARNING,
			    "Failed to allocate fake bufmgr space.\n");
			return FALSE;
		}
		i830_init_bufmgr(scrn);
	    }

d1630 2
a1631 1
static void i830_set_max_gtt_map_size(ScrnInfoPtr scrn)
d1633 10
a1642 3
	intel_screen_private *intel = intel_get_screen_private(scrn);
	struct drm_i915_gem_get_aperture aperture;
	int ret;
d1644 7
a1650 12
	/* Default low value in case it gets used during server init. */
	intel->max_gtt_map_size = 16 * 1024 * 1024;

	if (!intel->have_gem)
		return;

	ret =
	    ioctl(intel->drmSubFD, DRM_IOCTL_I915_GEM_GET_APERTURE, &aperture);
	if (ret == 0) {
		/* Let objects up get bound up to the size where only 2 would
		 * fit in the aperture, but then leave slop to account for
		 * alignment like libdrm does.
d1653 3
a1655 2
		    aperture.aper_available_size * 3 / 4 / 2;
	}
d1658 2
a1659 1
static void i830_set_max_tiling_size(ScrnInfoPtr scrn)
d1661 1
a1661 10
	intel_screen_private *intel = intel_get_screen_private(scrn);
	struct drm_i915_gem_get_aperture aperture;
	int ret;

	/* Default low value in case it gets used during server init. */
	intel->max_tiling_size = 4 * 1024 * 1024;

	ret =
	    ioctl(intel->drmSubFD, DRM_IOCTL_I915_GEM_GET_APERTURE, &aperture);
	if (ret == 0) {
d1665 3
a1667 4
		intel->max_tiling_size = aperture.aper_available_size / 4;
		if (!IS_I965G(intel))
			intel->max_tiling_size /= 2;
	}
d1672 9
a1680 2
	i830_set_max_gtt_map_size(scrn);
	i830_set_max_tiling_size(scrn);
@


1.9
log
@update to xf86-video-intel 2.7.1. Tested by many.
@
text
@a0 1
/* $XFree86: xc/programs/Xserver/hw/xfree86/drivers/i810/i830_memory.c,v 1.9 2003/09/24 03:16:54 dawes Exp $ */
a30 13
 * Reformatted with GNU indent (2.2.8), using the following options:
 *
 *    -bad -bap -c41 -cd0 -ncdb -ci6 -cli0 -cp0 -ncs -d0 -di3 -i3 -ip3 -l78
 *    -lp -npcs -psl -sob -ss -br -ce -sc -hnl
 *
 * This provides a good match with the original i810 code and preferred
 * XFree86 formatting conventions.
 *
 * When editing this driver, please follow the existing formatting, and edit
 * with <TAB> characters expanded at 8-column intervals.
 */

/*
d53 2
a54 5
 * - XAA linear allocator (optional)
 * - XAA scratch (screen 1)
 * - XAA scratch (screen 2, only in zaphod mode)
 * - Front buffer (screen 1, more is better for XAA)
 * - Front buffer (screen 2, only in zaphod mode, more is better for XAA)
a58 4
 * - EXA offscreen pool (more is always better)
 *
 * We also want to be able to resize the front/back/depth buffers, and then
 * resize the EXA and texture memory pools appropriately.
d61 1
a61 1
 * (pI830->pEnt->videoRam != 0), in which case allocations have to fit within
a79 1
#include <errno.h>
d82 1
a88 1
#ifdef XF86DRI
a89 3
#endif

#define ALIGN(i,m)    (((i) + (m) - 1) & ~((m) - 1))
d96 1
a96 1
i830_allocate_aperture(ScrnInfoPtr pScrn, const char *name,
d101 1
a101 1
static int i830_set_tiling(ScrnInfoPtr pScrn, unsigned int offset,
d105 1
a105 1
static void i830_clear_tiling(ScrnInfoPtr pScrn, unsigned int fence_nr);
d110 1
a110 2
unsigned long
i830_get_fence_size(I830Ptr pI830, unsigned long size)
d112 2
a113 2
    unsigned long i;
    unsigned long start;
d115 11
a125 11
    if (IS_I965G(pI830)) {
	/* The 965 can have fences at any page boundary. */
	return ALIGN(size, GTT_PAGE_SIZE);
    } else {
	/* Align the size to a power of two greater than the smallest fence
	 * size.
	 */
	if (IS_I9XX(pI830))
	    start = MB(1);
	else
	    start = KB(512);
d127 1
a127 2
	for (i = start; i < size; i <<= 1)
	    ;
d129 2
a130 2
	return i;
    }
d138 1
a138 1
i830_get_fence_pitch(I830Ptr pI830, unsigned long pitch, int format)
d140 2
a141 2
    unsigned long i;
    unsigned long tile_width = (format == I915_TILING_Y) ? 128 : 512;
d143 2
a144 2
    if (format == TILE_NONE)
	return pitch;
d146 3
a148 3
    /* 965 is flexible */
    if (IS_I965G(pI830))
	return ROUND_TO(pitch, tile_width);
d150 2
a151 3
    /* Pre-965 needs power of two tile width */
    for (i = tile_width; i < pitch; i <<= 1)
	;
d153 1
a153 1
    return i;
d160 1
a160 2
unsigned long
i830_get_fence_alignment(I830Ptr pI830, unsigned long size)
d162 4
a165 4
    if (IS_I965G(pI830))
	return 4096;
    else
	return i830_get_fence_size(pI830, size);
d169 1
a169 1
i830_check_display_stride(ScrnInfoPtr pScrn, int stride, Bool tiling)
d171 2
a172 2
    I830Ptr pI830 = I830PTR(pScrn);
    int limit = KB(32);
d174 4
a177 4
    /* 8xx spec has always 8K limit, but tests show larger limit in
       non-tiling mode, which makes large monitor work. */
    if ((IS_845G(pI830) || IS_I85X(pI830)) && tiling)
	limit = KB(8);
d179 2
a180 2
    if (IS_I915(pI830) && tiling)
	limit = KB(8);
d182 2
a183 2
    if (IS_I965G(pI830) && tiling)
	limit = KB(16);
d185 7
a191 4
    if (stride <= limit)
	return TRUE;
    else
	return FALSE;
d194 1
a194 2
static Bool
i830_bind_memory(ScrnInfoPtr pScrn, i830_memory *mem)
d196 1
a196 1
    I830Ptr pI830 = I830PTR(pScrn);
d198 4
a201 2
    if (mem == NULL || mem->bound)
	return TRUE;
d203 6
a208 8
#ifdef XF86DRI
    if (mem->bo != NULL) {
	if (dri_bo_pin(mem->bo, mem->alignment) != 0) {
	    xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
		       "Failed to pin %s: %s\n",
		       mem->name, strerror(errno));
	    return FALSE;
	}
d210 6
a215 5
	mem->bound = TRUE;
	mem->offset = mem->bo->offset;
	mem->end = mem->offset + mem->size;
    }
#endif
d217 5
a221 3
    if (!mem->bound) {
	if (!pI830->gtt_acquired)
	    return TRUE;
d223 1
a223 4
	if (mem->key != -1 &&
	    !xf86BindGARTMemory(pScrn->scrnIndex, mem->key, mem->agp_offset))
	{
	    return FALSE;
d226 4
a229 2
	mem->bound = TRUE;
    }
d231 1
a231 7
    if (mem->tiling != TILE_NONE && !pI830->use_drm_mode &&
	!pI830->kernel_exec_fencing) {
	mem->fence_nr = i830_set_tiling(pScrn, mem->offset, mem->pitch,
					mem->allocated_size, mem->tiling);
    }

    return TRUE;
d234 1
a234 2
static Bool
i830_unbind_memory(ScrnInfoPtr pScrn, i830_memory *mem)
d236 1
a236 1
    I830Ptr pI830 = I830PTR(pScrn);
d238 20
a257 2
    if (mem == NULL || !mem->bound)
	return TRUE;
d259 3
a261 12
    if (mem->tiling != TILE_NONE && !pI830->use_drm_mode &&
	!pI830->kernel_exec_fencing)
	i830_clear_tiling(pScrn, mem->fence_nr);

#ifdef XF86DRI
    if (mem->bo != NULL) {
	if (dri_bo_unpin(mem->bo) == 0) {
	    mem->bound = FALSE;
	    /* Give buffer obviously wrong offset/end until it's re-pinned. */
	    mem->offset = -1;
	    mem->end = -1;
	    return TRUE;
d263 1
a263 1
	    return FALSE;
a264 9
    }
#endif

    if (mem->key == -1 || xf86UnbindGARTMemory(pScrn->scrnIndex, mem->key)) {
	mem->bound = FALSE;
	return TRUE;
    } else {
	return FALSE;
    }
d267 1
a267 2
void
i830_free_memory(ScrnInfoPtr pScrn, i830_memory *mem)
d269 2
a270 2
    if (mem == NULL)
	return;
d272 2
a273 2
    /* Free any AGP memory. */
    i830_unbind_memory(pScrn, mem);
d275 19
a293 10
#ifdef XF86DRI
    if (mem->bo != NULL) {
	I830Ptr pI830 = I830PTR(pScrn);
	dri_bo_unreference (mem->bo);
	if (pI830->bo_list == mem) {
	    pI830->bo_list = mem->next;
	    if (mem->next)
		mem->next->prev = NULL;
	} else {
	    if (mem->prev)
d295 1
a295 1
	    if (mem->next)
d297 4
d302 1
a304 16
	return;
    }
#endif
	    /* Disconnect from the list of allocations */
    if (mem->prev != NULL)
	mem->prev->next = mem->next;
    if (mem->next != NULL)
	mem->next->prev = mem->prev;

    if (mem->key != -1) {
	xf86DeallocateGARTMemory(pScrn->scrnIndex, mem->key);
	mem->key = -1;
    }

    xfree(mem->name);
    xfree(mem);
d310 1
a310 2
void
i830_reset_allocations(ScrnInfoPtr pScrn)
d312 13
a324 2
    I830Ptr pI830 = I830PTR(pScrn);
    int	    p;
d326 1
a326 10
    /* While there is any memory between the start and end markers, free it. */
    while (pI830->memory_list->next->next != NULL) {
	i830_memory *mem = pI830->memory_list->next;

#ifdef XF86DRI
	/* Don't reset BO allocator, which we set up at init. */
	if (pI830->memory_manager == mem) {
	    mem = mem->next;
	    if (mem->next == NULL)
		break;
a327 1
#endif	
d329 3
a331 2
	i830_free_memory(pScrn, mem);
    }
d333 13
a345 41
    /* Free any allocations in buffer objects */
    if (pI830->memory_manager) {
	while (pI830->bo_list != NULL)
	    i830_free_memory(pScrn, pI830->bo_list);
    }

    /* Null out the pointers for all the allocations we just freed.  This is
     * kind of gross, but at least it's just one place now.
     */
    pI830->cursor_mem = NULL;
    for (p = 0; p < 2; p++) {
	pI830->cursor_mem_classic[p] = NULL;
	pI830->cursor_mem_argb[p] = NULL;
    }
    pI830->front_buffer = NULL;
    pI830->xaa_scratch = NULL;
    pI830->exa_offscreen = NULL;
    pI830->overlay_regs = NULL;
    pI830->power_context = NULL;
#ifdef XF86DRI
    pI830->back_buffer = NULL;
    pI830->depth_buffer = NULL;
    pI830->textures = NULL;
#endif
    pI830->ring.mem = NULL;
    pI830->fake_bufmgr_mem = NULL;
}

void
i830_free_3d_memory(ScrnInfoPtr pScrn)
{
    I830Ptr pI830 = I830PTR(pScrn);

#ifdef XF86DRI
    i830_free_memory(pScrn, pI830->back_buffer);
    pI830->back_buffer = NULL;
    i830_free_memory(pScrn, pI830->depth_buffer);
    pI830->depth_buffer = NULL;
    i830_free_memory(pScrn, pI830->textures);
    pI830->textures = NULL;
#endif
d357 1
a357 2
Bool
i830_allocator_init(ScrnInfoPtr pScrn, unsigned long offset, unsigned long size)
d359 3
a361 9
    I830Ptr pI830 = I830PTR(pScrn);
    i830_memory *start, *end;
#ifdef XF86DRI
    int dri_major, dri_minor, dri_patch;
    struct drm_i915_getparam gp;
    struct drm_i915_setparam sp;
    int has_gem;
    int has_dri;
#endif
d363 21
a383 21
    start = xcalloc(1, sizeof(*start));
    if (start == NULL)
	return FALSE;
    start->name = xstrdup("start marker");
    if (start->name == NULL) {
	xfree(start);
	return FALSE;
    }
    end = xcalloc(1, sizeof(*end));
    if (end == NULL) {
	xfree(start->name);
	xfree(start);
	return FALSE;
    }
    end->name = xstrdup("end marker");
    if (end->name == NULL) {
	xfree(start->name);
	xfree(start);
	xfree(end);
	return FALSE;
    }
d385 19
a403 23
    start->key = -1;
    start->offset = offset;
    start->end = start->offset;
    start->size = 0;
    start->next = end;
    end->key = -1;
    end->offset = offset + size;
    end->end = end->offset;
    end->size = 0;
    end->prev = start;

    pI830->memory_list = start;

#ifdef XF86DRI
    has_gem = FALSE;
    has_dri = FALSE;
    
    if (pI830->directRenderingType == DRI_XF86DRI &&
	xf86LoaderCheckSymbol ("DRIQueryVersion"))
    {
	DRIQueryVersion(&dri_major, &dri_minor, &dri_patch);
	has_dri = TRUE;
    }
d405 2
a406 9
    if (pI830->directRenderingType >= DRI_XF86DRI)
    {
	has_gem = FALSE;
	gp.param = I915_PARAM_HAS_GEM;
	gp.value = &has_gem;
    
	(void)drmCommandWriteRead(pI830->drmSubFD, DRM_I915_GETPARAM,
				  &gp, sizeof(gp));
    }
d408 4
a411 10
    /* Now that we have our manager set up, initialize the kernel MM if
     * possible, covering almost all of the aperture.  We need libdri interface
     * 5.4 or newer so we can rely on the lock being held after DRIScreenInit,
     * rather than after DRIFinishScreenInit.
     */
    if ((pI830->directRenderingType == DRI_XF86DRI && has_gem && has_dri &&
	(dri_major > 5 || (dri_major == 5 && dri_minor >= 4))) ||
	(pI830->directRenderingType == DRI_DRI2 && has_gem))
    {
	int mmsize;
d413 53
a465 57
	/* Take over all of the graphics aperture minus enough to for
	 * physical-address allocations of cursor/overlay registers.
	 */
	mmsize = size;

	/* EXA area is fixed. */
	if (pI830->accel == ACCEL_EXA) {
	    mmsize -= ROUND_TO_PAGE(3 * pScrn->displayWidth * pI830->cpp *
				    pScrn->virtualY);
	}
	/* Overlay and cursors, if physical, need to be allocated outside
	 * of the kernel memory manager.
	 */
	if (!OVERLAY_NOPHYSICAL(pI830) && !OVERLAY_NOEXIST(pI830)) {
	    mmsize -= ROUND_TO(OVERLAY_SIZE, GTT_PAGE_SIZE);
	}
	if (pI830->CursorNeedsPhysical) {
	    mmsize -= 2 * (ROUND_TO(HWCURSOR_SIZE, GTT_PAGE_SIZE) +
		    ROUND_TO(HWCURSOR_SIZE_ARGB, GTT_PAGE_SIZE));
	}
	if (pI830->fb_compression)
	    mmsize -= MB(6) + ROUND_TO_PAGE(FBC_LL_SIZE + FBC_LL_PAD);
	/* Can't do GEM on stolen memory */
	mmsize -= pI830->stolen_size;

	/* Create the aperture allocation */
	pI830->memory_manager =
	    i830_allocate_aperture(pScrn, "DRI memory manager",
				   mmsize, 0, GTT_PAGE_SIZE,
				   ALIGN_BOTH_ENDS | NEED_NON_STOLEN,
				   TILE_NONE);

	if (pI830->memory_manager != NULL) {
	    if (!pI830->use_drm_mode) {
		struct drm_i915_gem_init init;
		int ret;

		if (pI830->accel == ACCEL_UXA) {
		    sp.param = I915_SETPARAM_NUM_USED_FENCES;
		    sp.value = 0; /* kernel gets them all */

		    ret = drmCommandWrite(pI830->drmSubFD, DRM_I915_SETPARAM,
					  &sp, sizeof(sp));
		    if (ret == 0)
			pI830->kernel_exec_fencing = TRUE;
		}
		init.gtt_start = pI830->memory_manager->offset;
		init.gtt_end = pI830->memory_manager->offset +
		    pI830->memory_manager->size;

		/* Tell the kernel to manage it */
		ret = ioctl(pI830->drmSubFD, DRM_IOCTL_I915_GEM_INIT, &init);
		if (ret != 0) {
		    xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
			       "Failed to initialize kernel memory manager\n");
		    i830_free_memory(pScrn, pI830->memory_manager);
		    pI830->memory_manager = NULL;
a466 7
		i830_init_bufmgr(pScrn);
	    }
	} else {
	    xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
		       "Failed to allocate space for kernel memory manager\n");
	    i830_free_memory(pScrn, pI830->memory_manager);
	    pI830->memory_manager = NULL;
a467 4
    } else {
	pI830->allocate_classic_textures = TRUE;
    }
#endif /* XF86DRI */
d469 1
a469 1
    return TRUE;
d472 1
a472 2
void
i830_allocator_fini(ScrnInfoPtr pScrn)
d474 1
a474 1
    I830Ptr pI830 = I830PTR(pScrn);
d476 5
a480 2
    /* Free most of the allocations */
    i830_reset_allocations(pScrn);
d482 4
a485 11
    /* The memory manager is more special */
    if (pI830->memory_manager) {
	 /* XXX drmMMTakedown(pI830->drmSubFD, DRM_BO_MEM_TT);*/
	 i830_free_memory(pScrn, pI830->memory_manager);
	 pI830->memory_manager = NULL;
    }

    /* Free the start/end markers */
    free(pI830->memory_list->next);
    free(pI830->memory_list);
    pI830->memory_list = NULL;
d495 1
a495 2
static uint64_t
i830_get_gtt_physical(ScrnInfoPtr pScrn, unsigned long offset)
d497 2
a498 2
    I830Ptr pI830 = I830PTR(pScrn);
    uint32_t gttentry;
d500 3
a502 3
    /* We don't have GTTBase set up on i830 yet. */
    if (pI830->GTTBase == NULL)
	return -1;
d504 1
a504 1
    gttentry = INGTT(offset / 1024);
d506 5
a510 6
    /* Mask out these reserved bits on this hardware. */
    if (!IS_I9XX(pI830) || IS_I915G(pI830) || IS_I915GM(pI830) ||
	IS_I945G(pI830) || IS_I945GM(pI830))
    {
	gttentry &= ~PTE_ADDRESS_MASK_HIGH;
    }
d512 9
a520 10
    /* If it's not a mapping type we know, then bail. */
    if ((gttentry & PTE_MAPPING_TYPE_MASK) != PTE_MAPPING_TYPE_UNCACHED &&
	(gttentry & PTE_MAPPING_TYPE_MASK) != PTE_MAPPING_TYPE_CACHED)
    {
	xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
		   "Unusable physical mapping type 0x%08x\n",
		   (unsigned int)(gttentry & PTE_MAPPING_TYPE_MASK));
	return -1;
    }
    assert((gttentry & PTE_VALID) != 0);
d522 2
a523 2
    return (gttentry & PTE_ADDRESS_MASK) |
	((uint64_t)(gttentry & PTE_ADDRESS_MASK_HIGH) << (32 - 4));
d533 14
a546 7
static uint64_t
i830_get_stolen_physical(ScrnInfoPtr pScrn, unsigned long offset,
			 unsigned long size)
{
    I830Ptr pI830 = I830PTR(pScrn);
    uint64_t physical;
    unsigned long scan;
d548 5
a552 3
    /* Check that the requested region is within stolen memory. */
    if (offset + size >= pI830->stolen_size)
	return -1;
d554 7
a560 16
    physical = i830_get_gtt_physical(pScrn, offset);
    if (physical == -1)
	return -1;

    /* Check that the following pages in our allocation follow the first page
     * contiguously.
     */
    for (scan = offset + 4096; scan < offset + size; scan += 4096) {
	uint64_t scan_physical = i830_get_gtt_physical(pScrn, scan);

	if ((scan - offset) != (scan_physical - physical)) {
	    xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
		       "Non-contiguous GTT entries: (%ld,0x16%" PRIx64 ") vs "
		       "(%ld,0x%" PRIx64 ")\n",
		       scan, scan_physical, offset, physical);
	    return -1;
a561 1
    }
d572 3
a574 4
i830_allocate_aperture(ScrnInfoPtr pScrn, const char *name,
		       unsigned long size, unsigned long pitch,
		       unsigned long alignment, int flags,
		       enum tile_format tile_format)
d576 2
a577 2
    I830Ptr pI830 = I830PTR(pScrn);
    i830_memory *mem, *scan;
d579 3
a581 3
    mem = xcalloc(1, sizeof(*mem));
    if (mem == NULL)
	return NULL;
d583 2
a584 2
    /* No memory allocated to back the region */
    mem->key = -1;
d586 44
a629 29
    mem->name = xstrdup(name);
    if (mem->name == NULL) {
	xfree(mem);
	return NULL;
    }
    /* Only allocate page-sized increments. */
    size = ALIGN(size, GTT_PAGE_SIZE);
    mem->size = size;
    mem->allocated_size = size;
    mem->alignment = alignment;
    mem->tiling = tile_format;
    mem->pitch = pitch;
    mem->fence_nr = -1;

    if (alignment < GTT_PAGE_SIZE)
	alignment = GTT_PAGE_SIZE;

    for (scan = pI830->memory_list; scan->next != NULL; scan = scan->next) {
	mem->offset = ROUND_TO(scan->end, alignment);
	if ((flags & NEED_PHYSICAL_ADDR) && mem->offset < pI830->stolen_size) {
	    /* If the allocation is entirely within stolen memory, and we're
	     * able to get the physical addresses out of the GTT and check that
	     * it's contiguous (it ought to be), then we can do our physical
	     * allocations there and not bother the kernel about it.  This
	     * helps avoid aperture fragmentation from our physical
	     * allocations.
	     */
	    mem->bus_addr = i830_get_stolen_physical(pScrn, mem->offset,
						     mem->size);
d631 5
a635 5
	    if (mem->bus_addr == ((uint64_t)-1)) {
		/* Move the start of the allocation to just past the end of
		 * stolen memory.
		 */
		mem->offset = ROUND_TO(pI830->stolen_size, alignment);
d637 5
d643 5
a647 21
	if ((flags & NEED_NON_STOLEN) && mem->offset < pI830->stolen_size) {
	    mem->offset = ROUND_TO(pI830->stolen_size, alignment);
	}

	mem->end = mem->offset + size;
	if (flags & ALIGN_BOTH_ENDS)
	    mem->end = ROUND_TO(mem->end, alignment);
	if (mem->end <= scan->next->offset)
	    break;
    }
    if (scan->next == NULL) {
	/* Reached the end of the list, and didn't find space */
	xfree(mem->name);
	xfree(mem);
	return NULL;
    }
    /* Insert new allocation into the list */
    mem->prev = scan;
    mem->next = scan->next;
    scan->next = mem;
    mem->next->prev = mem;
d649 1
a649 1
    return mem;
d659 1
a659 1
i830_allocate_agp_memory(ScrnInfoPtr pScrn, i830_memory *mem, int flags)
d661 2
a662 2
    I830Ptr pI830 = I830PTR(pScrn);
    unsigned long size;
d664 2
a665 2
    if (mem->key != -1)
	return TRUE;
d667 2
a668 2
    if (mem->offset + mem->size <= pI830->stolen_size)
	return TRUE;
d670 4
a673 4
    if (mem->offset < pI830->stolen_size)
	mem->agp_offset = pI830->stolen_size;
    else
	mem->agp_offset = mem->offset;
d675 1
a675 1
    size = mem->size - (mem->agp_offset - mem->offset);
d677 2
a678 2
    if (flags & NEED_PHYSICAL_ADDR) {
	unsigned long agp_bus_addr;
d680 11
a690 10
	mem->key = xf86AllocateGARTMemory(pScrn->scrnIndex, size, 2,
					  &agp_bus_addr);
	mem->bus_addr = agp_bus_addr;
    } else {
	mem->key = xf86AllocateGARTMemory(pScrn->scrnIndex, size, 0, NULL);
    }
    if (mem->key == -1 || ((flags & NEED_PHYSICAL_ADDR) && mem->bus_addr == 0))
    {
	return FALSE;
    }
d692 1
a692 1
    return TRUE;
d695 26
a720 21
#ifdef XF86DRI
static i830_memory *
i830_allocate_memory_bo(ScrnInfoPtr pScrn, const char *name,
			unsigned long size, unsigned long pitch,
			unsigned long align, int flags,
			enum tile_format tile_format)
{
    I830Ptr pI830 = I830PTR(pScrn);
    i830_memory *mem;
    uint32_t bo_tiling_mode = I915_TILING_NONE;
    int	    ret;

    assert((flags & NEED_PHYSICAL_ADDR) == 0);

    /* Only allocate page-sized increments. */
    size = ALIGN(size, GTT_PAGE_SIZE);
    align = i830_get_fence_alignment(pI830, size);

    mem = xcalloc(1, sizeof(*mem));
    if (mem == NULL)
	return NULL;
d722 1
a722 5
    mem->name = xstrdup(name);
    if (mem->name == NULL) {
	xfree(mem);
	return NULL;
    }
d724 5
a728 1
    mem->bo = dri_bo_alloc (pI830->bufmgr, name, size, align);
d730 13
a742 5
    if (!mem->bo) {
	xfree(mem->name);
	xfree(mem);
	return NULL;
    }
d744 12
a755 24
    /* Give buffer obviously wrong offset/end until it's pinned. */
    mem->offset = -1;
    mem->end = -1;
    mem->size = size;
    mem->allocated_size = size;
    mem->alignment = align;
    mem->tiling = tile_format;
    mem->pitch = pitch;
    mem->fence_nr = -1;
    if (flags & NEED_LIFETIME_FIXED)
	mem->lifetime_fixed_offset = TRUE;

    switch (tile_format) {
    case TILE_XMAJOR:
	bo_tiling_mode = I915_TILING_X;
	break;
    case TILE_YMAJOR:
	bo_tiling_mode = I915_TILING_Y;
	break;
    case TILE_NONE:
    default:
	bo_tiling_mode = I915_TILING_NONE;
	break;
    }
d757 17
a773 15
    ret = drm_intel_bo_set_tiling(mem->bo, &bo_tiling_mode, pitch);
    if (ret != 0 || (bo_tiling_mode == I915_TILING_NONE && tile_format != TILE_NONE)) {
	xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
		   "Failed to set tiling on %s: %s\n",
		   mem->name,
		   ret == 0 ? "rejected by kernel" : strerror(errno));
	mem->tiling = TILE_NONE;
    }
    /* Bind it if we currently control the VT */
    if (pScrn->vtSema || pI830->use_drm_mode) {
	if (!i830_bind_memory(pScrn, mem)) {
	    dri_bo_unreference (mem->bo);
	    xfree(mem->name);
	    xfree(mem);
	    return NULL;
a774 1
    }
a775 6
    /* Insert new allocation into the list */
    mem->prev = NULL;
    mem->next = pI830->bo_list;
    if (pI830->bo_list != NULL)
	pI830->bo_list->prev = mem;
    pI830->bo_list = mem;
d777 11
a787 1
    return mem;
a788 1
#endif /* XF86DRI */
d808 7
a814 10
i830_memory *
i830_allocate_memory(ScrnInfoPtr pScrn, const char *name,
		     unsigned long size, unsigned long pitch,
		     unsigned long alignment, int flags,
		     enum tile_format tile_format)
{
    i830_memory *mem;
#ifdef XF86DRI
    I830Ptr pI830 = I830PTR(pScrn);
#endif
d816 13
a828 4
    /* Manage tile alignment and size constraints */
    if (tile_format != TILE_NONE) {
	/* Only allocate page-sized increments. */
	size = ALIGN(size, GTT_PAGE_SIZE);
d830 3
a832 7
	/* Check for maximum tiled region size */
	if (IS_I9XX(pI830)) {
	    if (size > MB(128))
		return NULL;
	} else {
	    if (size > MB(64))
		return NULL;
d835 20
a854 16
	/* round to size necessary for the fence register to work */
	size = i830_get_fence_size(pI830, size);
	alignment = i830_get_fence_alignment(pI830, size);
    }
#ifdef XF86DRI
    if (pI830->use_drm_mode || (pI830->memory_manager &&
				!(flags & NEED_PHYSICAL_ADDR) &&
				!(flags & NEED_LIFETIME_FIXED)))
    {
	return i830_allocate_memory_bo(pScrn, name, size, pitch, alignment, flags, tile_format);
    } else
#endif /* XF86DRI */
    {
	mem = i830_allocate_aperture(pScrn, name, size, pitch, alignment, flags, tile_format);
	if (mem == NULL)
	    return NULL;
d856 4
a859 8
	if (!i830_allocate_agp_memory(pScrn, mem, flags)) {
	    i830_free_memory(pScrn, mem);
	    return NULL;
	}

	if (!i830_bind_memory(pScrn, mem)) {
	    i830_free_memory(pScrn, mem);
	    return NULL;
a860 1
    }
d862 1
a862 1
    return mem;
d866 1
a866 1
i830_describe_allocations(ScrnInfoPtr pScrn, int verbosity, const char *prefix)
d868 2
a869 2
    I830Ptr pI830 = I830PTR(pScrn);
    i830_memory *mem;
d871 25
a895 5
    if (pI830->memory_list == NULL) {
	xf86DrvMsgVerb(pScrn->scrnIndex, X_INFO, verbosity,
		       "%sMemory allocator not initialized\n", prefix);
	return;
    }
d897 7
a903 5
    if (pI830->memory_list->next->next == NULL) {
	xf86DrvMsgVerb(pScrn->scrnIndex, X_INFO, verbosity,
		       "%sNo memory allocations\n", prefix);
	return;
    }
d905 7
a911 2
    xf86DrvMsgVerb(pScrn->scrnIndex, X_INFO, verbosity,
		   "%sFixed memory allocation layout:\n", prefix);
d913 30
a942 53
    for (mem = pI830->memory_list->next; mem->next != NULL; mem = mem->next) {
	char phys_suffix[32] = "";
	char *tile_suffix = "";

	if (mem->offset >= pI830->stolen_size &&
	    mem->prev->offset < pI830->stolen_size)
	{
	    xf86DrvMsgVerb(pScrn->scrnIndex, X_INFO, verbosity,
			   "%s0x%08lx:            end of stolen memory\n",
			   prefix, pI830->stolen_size);
	}

	if (mem->bus_addr != 0)
	    snprintf(phys_suffix, sizeof(phys_suffix),
		    ", 0x%016" PRIx64 " physical\n", mem->bus_addr);
	if (mem->tiling == TILE_XMAJOR)
	    tile_suffix = " X tiled";
	else if (mem->tiling == TILE_YMAJOR)
	    tile_suffix = " Y tiled";

	xf86DrvMsgVerb(pScrn->scrnIndex, X_INFO, verbosity,
		       "%s0x%08lx-0x%08lx: %s (%ld kB%s)%s\n", prefix,
		       mem->offset, mem->end - 1, mem->name,
		       mem->size / 1024, phys_suffix, tile_suffix);
    }
    xf86DrvMsgVerb(pScrn->scrnIndex, X_INFO, verbosity,
		   "%s0x%08lx:            end of aperture\n",
		   prefix, pI830->FbMapSize);

    if (pI830->memory_manager) {
	xf86DrvMsgVerb(pScrn->scrnIndex, X_INFO, verbosity,
		       "%sBO memory allocation layout:\n", prefix);
	xf86DrvMsgVerb(pScrn->scrnIndex, X_INFO, verbosity,
		       "%s0x%08lx:            start of memory manager\n",
		       prefix, pI830->memory_manager->offset);
	for (mem = pI830->bo_list; mem != NULL; mem = mem->next) {
	    char *tile_suffix = "";

	    if (mem->tiling == TILE_XMAJOR)
		tile_suffix = " X tiled";
	    else if (mem->tiling == TILE_YMAJOR)
		tile_suffix = " Y tiled";

	    if (mem->bound) {
		xf86DrvMsgVerb(pScrn->scrnIndex, X_INFO, verbosity,
			       "%s0x%08lx-0x%08lx: %s (%ld kB)%s\n", prefix,
			       mem->offset, mem->end - 1, mem->name,
			       mem->size / 1024, tile_suffix);
	    } else {
		xf86DrvMsgVerb(pScrn->scrnIndex, X_INFO, verbosity,
			       "%sunpinned          : %s (%ld kB)%s\n", prefix,
			       mem->name, mem->size / 1024, tile_suffix);
	    }
a943 4
	xf86DrvMsgVerb(pScrn->scrnIndex, X_INFO, verbosity,
		       "%s0x%08lx:            end of memory manager\n",
		       prefix, pI830->memory_manager->end);
    }
d946 1
a946 2
static Bool
i830_allocate_ringbuffer(ScrnInfoPtr pScrn)
d948 1
a948 1
    I830Ptr pI830 = I830PTR(pScrn);
d950 2
a951 2
    if (pI830->accel == ACCEL_NONE || pI830->memory_manager || pI830->ring.mem != NULL)
	return TRUE;
d953 12
a964 12
    /* We don't have any mechanism in the DRM yet to alert it that we've moved
     * the ringbuffer since init time, so allocate it fixed for its lifetime.
     */
    pI830->ring.mem = i830_allocate_memory(pScrn, "ring buffer",
					   PRIMARY_RINGBUFFER_SIZE, PITCH_NONE,
					   GTT_PAGE_SIZE,
					   NEED_LIFETIME_FIXED, TILE_NONE);
    if (pI830->ring.mem == NULL) {
	xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
		   "Failed to allocate Ring Buffer space\n");
	return FALSE;
    }
d966 3
a968 2
    pI830->ring.tail_mask = pI830->ring.mem->size - 1;
    return TRUE;
a970 1
#ifdef I830_XV
d972 1
a972 2
 * Allocate space for overlay registers and XAA linear allocator (if
 * requested)
d974 1
a974 2
static Bool
i830_allocate_overlay(ScrnInfoPtr pScrn)
d976 2
a977 2
    I830Ptr pI830 = I830PTR(pScrn);
    int flags = 0;
d979 3
a981 3
    /* Only allocate if overlay is going to be enabled. */
    if (!pI830->XvEnabled)
	return TRUE;
d983 2
a984 2
    if (OVERLAY_NOEXIST(pI830))
	return TRUE;
d986 5
a990 5
    if (!OVERLAY_NOPHYSICAL(pI830)) {
	if (pI830->use_drm_mode)
            return TRUE;
	flags |= NEED_PHYSICAL_ADDR;
    }
d992 7
a998 8
    pI830->overlay_regs = i830_allocate_memory(pScrn, "overlay registers",
					       OVERLAY_SIZE, PITCH_NONE, GTT_PAGE_SIZE,
					       flags, TILE_NONE);
    if (pI830->overlay_regs == NULL) {
	xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
		   "Failed to allocate Overlay register space.\n");
	/* This failure isn't fatal. */
    }
d1000 3
a1002 3
    if (flags & NEED_PHYSICAL_ADDR)
	if (pI830->use_drm_mode)
	    ; /* need physical addr */
d1004 1
a1004 1
    return TRUE;
a1005 1
#endif
d1007 1
a1007 2
static Bool
IsTileable(ScrnInfoPtr pScrn, int pitch)
d1009 1
a1009 1
    I830Ptr pI830 = I830PTR(pScrn);
d1011 6
a1016 6
    if (IS_I965G(pI830)) {
	if (pitch / 512 * 512 == pitch && pitch <= KB(128))
	    return TRUE;
	else
	    return FALSE;
    }
d1018 20
a1037 20
    /*
     * Allow tiling for pitches that are a power of 2 multiple of 128 bytes,
     * up to 64 * 128 (= 8192) bytes.
     */
    switch (pitch) {
    case 128:
    case 256:
	if (IS_I945G(pI830) || IS_I945GM(pI830) || IS_G33CLASS(pI830))
	    return TRUE;
	else
	    return FALSE;
    case 512:
    case KB(1):
    case KB(2):
    case KB(4):
    case KB(8):
	return TRUE;
    default:
	return FALSE;
    }
a1039 7
/* This is the 2D rendering vertical coordinate limit.  We can ignore
 * the 3D rendering limits in our 2d pixmap cache allocation, because XAA
 * doesn't do any 3D rendering to/from the cache lines when using an offset
 * at the start of framebuffer.
 */
#define MAX_2D_HEIGHT		65536

d1046 1
a1046 2
i830_memory *
i830_allocate_framebuffer(ScrnInfoPtr pScrn)
d1048 10
a1057 9
    I830Ptr pI830 = I830PTR(pScrn);
    unsigned int pitch = pScrn->displayWidth * pI830->cpp;
    unsigned long minspace, avail;
    int cacheLines, maxCacheLines;
    int align;
    long size, fb_height;
    int flags;
    i830_memory *front_buffer = NULL;
    enum tile_format tile_format = TILE_NONE;
d1059 4
a1062 1
    flags = ALLOW_SHARING;
d1064 5
a1068 11
    /* We'll allocate the fb such that the root window will fit regardless of
     * rotation.
     */
    fb_height = pScrn->virtualY;
    if (!pI830->can_resize)
    {
	if (!pI830->use_drm_mode && pScrn->virtualX > pScrn->virtualY)
	    fb_height = pScrn->virtualX;
	else
	    fb_height = pScrn->virtualY;
    }
d1070 1
a1070 12
    pI830->FbMemBox.x1 = 0;
    pI830->FbMemBox.x2 = pScrn->displayWidth;
    pI830->FbMemBox.y1 = 0;
    pI830->FbMemBox.y2 = fb_height;

    /* Calculate how much framebuffer memory to allocate.  For the
     * initial allocation, calculate a reasonable minimum.  This is
     * enough for the virtual screen size, plus some pixmap cache
     * space if we're using XAA.
     */
    minspace = pitch * pScrn->virtualY;
    avail = pScrn->videoRam * 1024;
d1072 2
a1073 11
    if (pI830->accel == ACCEL_XAA) {
	maxCacheLines = (avail - minspace) / pitch;
	/* This shouldn't happen. */
	if (maxCacheLines < 0) {
	    xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
		       "Internal Error: "
		       "maxCacheLines < 0 in i830_allocate_2d_memory()\n");
	    maxCacheLines = 0;
	}
	if (maxCacheLines > (MAX_2D_HEIGHT - pScrn->virtualY))
	    maxCacheLines = MAX_2D_HEIGHT - pScrn->virtualY;
d1075 2
a1076 4
	if (pI830->CacheLines >= 0) {
	    cacheLines = pI830->CacheLines;
	} else {
	    int size;
d1078 6
a1083 2
	    size = 3 * pitch * pScrn->virtualY;
	    size = ROUND_TO_PAGE(size);
d1085 16
a1100 1
	    cacheLines = (size + pitch - 1) / pitch;
a1101 2
	if (cacheLines > maxCacheLines)
	    cacheLines = maxCacheLines;
d1103 3
a1105 1
	pI830->FbMemBox.y2 += cacheLines;
d1107 2
a1108 9
	xf86DrvMsg(pScrn->scrnIndex, X_INFO,
		   "Allocating %d scanlines for pixmap cache\n",
		   cacheLines);
    } else {
	/* For non-XAA, we have a separate allocation for the linear allocator
	 * which also does the pixmap cache.
	 */
	cacheLines = 0;
    }
d1110 6
a1115 2
    size = pitch * (fb_height + cacheLines);
    size = ROUND_TO_PAGE(size);
d1117 2
a1118 17
    /* Front buffer tiling has to be disabled with G965 XAA because some of the
     * acceleration operations (non-XY COLOR_BLT) can't be done to tiled
     * buffers.
     */
    if (pI830->tiling)
	tile_format = TILE_XMAJOR;
    if (pI830->accel == ACCEL_XAA && IS_I965G(pI830))
	tile_format = TILE_NONE;

    if (!IsTileable(pScrn, pitch))
	tile_format = TILE_NONE;

    if (!i830_check_display_stride(pScrn, pitch, tile_format != TILE_NONE)) {
	xf86DrvMsg(pScrn->scrnIndex, X_ERROR, "Front buffer stride %d kB "
		"exceed display limit\n", pitch/1024);
	return NULL;
    }
d1120 1
a1120 18
    /* Attempt to allocate it tiled first if we have page flipping on. */
    if (tile_format != TILE_NONE) {
	/* XXX: probably not the case on 965 */
	if (IS_I9XX(pI830))
	    align = MB(1);
	else
	    align = KB(512);
    } else
	align = KB(64);
    front_buffer = i830_allocate_memory(pScrn, "front buffer", size,
					pitch, align, flags,
					tile_format);

    if (front_buffer == NULL) {
	xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
		   "Failed to allocate framebuffer.\n");
	return NULL;
    }
d1122 1
a1122 2
    if (!pI830->use_drm_mode && pI830->FbBase)
	memset (pI830->FbBase + front_buffer->offset, 0, size);
a1123 2
    return front_buffer;
}
d1125 8
a1132 20
static Bool
i830_allocate_cursor_buffers(ScrnInfoPtr pScrn)
{
    I830Ptr pI830 = I830PTR(pScrn);
    xf86CrtcConfigPtr xf86_config = XF86_CRTC_CONFIG_PTR(pScrn);
    int flags;
    int i;
    long size;

    if (pI830->use_drm_mode)
	pI830->CursorNeedsPhysical = FALSE;

    flags = pI830->CursorNeedsPhysical ? NEED_PHYSICAL_ADDR : 0;

    /* Try to allocate one big blob for our cursor memory.  This works
     * around a limitation in the FreeBSD AGP driver that allows only one
     * physical allocation larger than a page, and could allow us
     * to pack the cursors smaller.
     */
    size = xf86_config->num_crtc * (HWCURSOR_SIZE + HWCURSOR_SIZE_ARGB);
d1134 5
a1138 5
    pI830->cursor_mem = i830_allocate_memory(pScrn, "HW cursors",
					     size, PITCH_NONE, GTT_PAGE_SIZE,
					     flags, TILE_NONE);
    if (pI830->cursor_mem != NULL)
	return TRUE;
d1140 20
a1159 24
    /*
     * Allocate four separate buffers when the kernel doesn't support
     * large allocations as on Linux. If any of these fail, just
     * bail back to software cursors everywhere
     */
    for (i = 0; i < xf86_config->num_crtc; i++)
    {
	pI830->cursor_mem_classic[i] = i830_allocate_memory (pScrn, 
							     "Core cursor",
							     HWCURSOR_SIZE,
							     PITCH_NONE,
							     GTT_PAGE_SIZE,
							     flags,
							     TILE_NONE);
	if (!pI830->cursor_mem_classic[i])
	    return FALSE;
	pI830->cursor_mem_argb[i] = i830_allocate_memory (pScrn, "ARGB cursor",
							  HWCURSOR_SIZE_ARGB,
							  PITCH_NONE,
							  GTT_PAGE_SIZE,
							  flags,
							  TILE_NONE);
	if (!pI830->cursor_mem_argb[i])
	    return FALSE;
d1161 2
a1162 2
    }
    return TRUE;
d1165 1
a1165 1
static void i830_setup_fb_compression(ScrnInfoPtr pScrn)
d1167 1
a1167 1
    I830Ptr pI830 = I830PTR(pScrn);
d1171 2
a1172 2
    if (pScrn->virtualX > pScrn->virtualY)
	fb_height = pScrn->virtualX;
d1174 1
a1174 1
	fb_height = pScrn->virtualY;
d1177 2
a1178 2
    if (!IS_MOBILE(pI830)) {
	pI830->fb_compression = FALSE;
d1182 1
a1182 1
    if (IS_GM45(pI830)) {
d1184 1
a1184 1
	compressed_size = fb_height * (pScrn->displayWidth / 4);
d1200 2
a1201 2
    pI830->compressed_front_buffer =
	i830_allocate_memory(pScrn, "compressed frame buffer",
d1206 2
a1207 2
    if (!pI830->compressed_front_buffer) {
	pI830->fb_compression = FALSE;
d1211 3
a1213 3
    if (!IS_GM45(pI830)) {
	pI830->compressed_ll_buffer =
	    i830_allocate_memory(pScrn, "compressed ll buffer",
d1218 3
a1220 3
	if (!pI830->compressed_ll_buffer) {
	    i830_free_memory(pScrn, pI830->compressed_front_buffer);
	    pI830->fb_compression = FALSE;
d1226 2
a1227 2
    if (!pI830->fb_compression)
	xf86DrvMsg(pScrn->scrnIndex, X_WARNING, "Allocation error, framebuffer"
d1236 1
a1236 2
Bool
i830_allocate_2d_memory(ScrnInfoPtr pScrn)
d1238 1
a1238 13
    I830Ptr pI830 = I830PTR(pScrn);
    unsigned int pitch = pScrn->displayWidth * pI830->cpp;
    long size;

    if (!pI830->use_drm_mode) {
	if (!xf86AgpGARTSupported() || !xf86AcquireGART(pScrn->scrnIndex)) {
	    xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
		       "AGP GART support is either not available or cannot "
		       "be used.\n"
		       "\tMake sure your kernel has agpgart support or has\n"
		       "\tthe agpgart module loaded.\n");
	    return FALSE;
	}
d1240 10
a1249 13
	/* Allocate the ring buffer first, so it ends up in stolen mem. */
	i830_allocate_ringbuffer(pScrn);
    }

    if (pI830->fb_compression)
	i830_setup_fb_compression(pScrn);

    /* Next, allocate other fixed-size allocations we have. */
    if (!i830_allocate_cursor_buffers(pScrn)) {
	xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
		   "Failed to allocate HW cursor space.\n");
	return FALSE;
    }
d1251 3
a1253 8
    if (pI830->memory_manager == NULL) {
	pI830->fake_bufmgr_mem = i830_allocate_memory(pScrn, "fake bufmgr",
						      MB(8), PITCH_NONE, GTT_PAGE_SIZE, 0,
						      TILE_NONE);
	if (pI830->fake_bufmgr_mem == NULL) {
	    xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
		       "Failed to allocate fake bufmgr space.\n");
	    return FALSE;
a1254 26
    }

#ifdef I830_XV
    /* Allocate overlay register space and optional XAA linear allocator
     * space.  The second head in zaphod mode will share the space.
     */
    if (!pI830->use_drm_mode)
	i830_allocate_overlay(pScrn);
#endif

    pI830->front_buffer = i830_allocate_framebuffer(pScrn);
    if (pI830->front_buffer == NULL)
	return FALSE;

#ifdef I830_USE_EXA
    if (pI830->accel == ACCEL_EXA && !pI830->use_drm_mode) {
	if (pI830->exa_offscreen == NULL) {
	    /* Default EXA to having 3 screens worth of offscreen memory space
	     * (for pixmaps).
	     *
	     * XXX: It would be nice to auto-size it larger if the user
	     * specified a larger size, or to fit along with texture and FB
	     * memory if a low videoRam is specified.
	     */
	    size = 3 * pitch * pScrn->virtualY;
	    size = ROUND_TO_PAGE(size);
d1256 7
a1262 11
	    /* EXA has no way to tell it that the offscreen memory manager has
	     * moved its base and all the contents with it, so we have to have
	     * it locked in place for the whole driver instance.
	     */
	    pI830->exa_offscreen =
		i830_allocate_memory(pScrn, "exa offscreen",
				     size, PITCH_NONE, 1, NEED_LIFETIME_FIXED,
				     TILE_NONE);
	    if (pI830->exa_offscreen == NULL) {
		xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
			   "Failed to allocate EXA offscreen memory.\n");
a1263 1
	    }
a1264 2
    }
#endif /* I830_USE_EXA */
d1266 10
a1275 19
    if (pI830->accel == ACCEL_XAA) {
	/* The lifetime fixed offset of xaa scratch is probably not required,
	 * but we do some setup using it at XAAInit() time.  And XAA may not
	 * end up being supported with GEM anyway.
	 */
	pI830->xaa_scratch =
	    i830_allocate_memory(pScrn, "xaa scratch", MAX_SCRATCH_BUFFER_SIZE,
				 PITCH_NONE, GTT_PAGE_SIZE, NEED_LIFETIME_FIXED,
				 TILE_NONE);
	if (pI830->xaa_scratch == NULL) {
	    pI830->xaa_scratch =
		i830_allocate_memory(pScrn, "xaa scratch",
				     MIN_SCRATCH_BUFFER_SIZE, PITCH_NONE,
				     GTT_PAGE_SIZE, NEED_LIFETIME_FIXED,
				     TILE_NONE);
	    if (pI830->xaa_scratch == NULL) {
		xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
			   "Failed to allocate scratch buffer space\n");
		return FALSE;
a1276 2
	}
    }
d1278 2
a1279 2
    return TRUE;
}
d1281 3
a1283 12
#ifdef XF86DRI
static unsigned int
myLog2(unsigned int n)
{
    unsigned int log2 = 1;

    while (n > 1) {
	n >>= 1;
	log2++;
    }
    return log2;
}
d1285 1
a1285 146
static Bool
i830_allocate_backbuffer(ScrnInfoPtr pScrn, i830_memory **buffer,
			 const char *name)
{
    I830Ptr pI830 = I830PTR(pScrn);
    unsigned int pitch = pScrn->displayWidth * pI830->cpp;
    unsigned long size;
    int height;
    enum tile_format tile_format = TILE_NONE;;

    if (pI830->rotation & (RR_Rotate_0 | RR_Rotate_180))
	height = pScrn->virtualY;
    else
	height = pScrn->virtualX;

    /* Try to allocate on the best tile-friendly boundaries. */
    if (pI830->tiling && IsTileable(pScrn, pitch))
    {
	size = ROUND_TO_PAGE(pitch * ALIGN(height, 16));
	tile_format = TILE_XMAJOR;
    }
    else
    {
	size = ROUND_TO_PAGE(pitch * height);
	tile_format = TILE_NONE;
    }
    *buffer = i830_allocate_memory(pScrn, name, size, pitch,
				   GTT_PAGE_SIZE,
				   ALIGN_BOTH_ENDS |
				   ALLOW_SHARING,
				   tile_format);

    if (*buffer == NULL) {
	xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
		   "Failed to allocate %s space.\n", name);
	return FALSE;
    }

    return TRUE;
}

static Bool
i830_allocate_depthbuffer(ScrnInfoPtr pScrn)
{
    I830Ptr pI830 = I830PTR(pScrn);
    unsigned long size;
    unsigned int pitch = pScrn->displayWidth * pI830->cpp;
    int height;
    int flags;
    enum tile_format tile_format = TILE_NONE;

    height = pScrn->virtualY;

    /* First try allocating it tiled */
    flags = ALLOW_SHARING;
    if (pI830->tiling && IsTileable(pScrn, pitch))
    {
	/* The 965 requires that the depth buffer be in Y Major format, while
	 * the rest appear to fail when handed that format.
	 */
	tile_format = IS_I965G(pI830) ? TILE_YMAJOR: TILE_XMAJOR;
	height = ALIGN(height, 16);
	flags |= ALIGN_BOTH_ENDS;
    }
    size = ROUND_TO_PAGE(pitch * height);

    pI830->depth_buffer =
	    i830_allocate_memory(pScrn, "depth buffer", size, pitch,
				 GTT_PAGE_SIZE, flags, tile_format);

    if (pI830->depth_buffer == NULL) {
	xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
		   "Failed to allocate depth buffer space.\n");
	return FALSE;
    }

    return TRUE;
}

Bool
i830_allocate_texture_memory(ScrnInfoPtr pScrn)
{
    I830Ptr pI830 = I830PTR(pScrn);
    unsigned long size;
    int i;

    if (pI830->allocate_classic_textures) {
	/* XXX: auto-sizing */
	size = MB(32);
	i = myLog2(size / I830_NR_TEX_REGIONS);
	if (i < I830_LOG_MIN_TEX_REGION_SIZE)
	    i = I830_LOG_MIN_TEX_REGION_SIZE;
	pI830->TexGranularity = i;
	/* Truncate size */
	size >>= i;
	size <<= i;
	if (size < KB(512)) {
	    xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
		       "Less than 512 kBytes for texture space (real %ld"
		       "kBytes).\n",
		       size / 1024);
	    return FALSE;
	}
	/* Now that the DRM uses the sarea to get the offsets of the buffers,
	 * and we update the classic DRM mappings and the sarea contents on
	 * changes, the NEED_LIFETIME_FIXED is no longer true and should be
	 * made conditional on DRM version.
	 */
	pI830->textures = i830_allocate_memory(pScrn, "classic textures", size,
					       PITCH_NONE,
					       GTT_PAGE_SIZE,
					       ALLOW_SHARING |
					       NEED_LIFETIME_FIXED,
					       TILE_NONE);
	if (pI830->textures == NULL) {
	    xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
		       "Failed to allocate texture space.\n");
	    return FALSE;
	}
    }

    return TRUE;
}

static Bool
i830_allocate_hwstatus(ScrnInfoPtr pScrn)
{
    I830Ptr pI830 = I830PTR(pScrn);
    int flags;

    /* The current DRM will leak the HWS mapping if we update the address
     * after init (at best), so allocate it fixed for its lifetime
     * (i.e. not through buffer objects).
     */
    flags = NEED_LIFETIME_FIXED;
    if (HWS_NEED_NONSTOLEN(pI830))
	    flags |= NEED_NON_STOLEN;
    pI830->hw_status = i830_allocate_memory(pScrn, "HW status",
	    HWSTATUS_PAGE_SIZE, PITCH_NONE, GTT_PAGE_SIZE, flags,
					    TILE_NONE);
    if (pI830->hw_status == NULL) {
	xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
		"Failed to allocate hw status page.\n");
	return FALSE;
    }
    return TRUE;
d1289 1
a1289 1
i830_allocate_pwrctx(ScrnInfoPtr pScrn)
d1291 1
a1291 1
    I830Ptr pI830 = I830PTR(pScrn);
d1293 1
a1293 1
    if (pI830->use_drm_mode)
d1296 1
a1296 1
    pI830->power_context = i830_allocate_memory(pScrn, "power context",
d1301 2
a1302 2
    if (!pI830->power_context) {
	xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
a1308 25
Bool
i830_allocate_3d_memory(ScrnInfoPtr pScrn)
{
    I830Ptr pI830 = I830PTR(pScrn);

    DPRINTF(PFX, "i830_allocate_3d_memory\n");

    if (!pI830->memory_manager && HWS_NEED_GFX(pI830)) {
	if (!i830_allocate_hwstatus(pScrn))
	    return FALSE;
    }

    if (!i830_allocate_backbuffer(pScrn, &pI830->back_buffer, "back buffer"))
	return FALSE;

    if (!i830_allocate_depthbuffer(pScrn))
	return FALSE;

    if (!i830_allocate_texture_memory(pScrn))
	return FALSE;

    return TRUE;
}
#endif

d1317 1
a1317 1
i830_set_tiling(ScrnInfoPtr pScrn, unsigned int offset,
d1321 1
a1321 1
    I830Ptr pI830 = I830PTR(pScrn);
d1333 1
a1333 4
    if (pI830->need_sync) {
	I830Sync(pScrn);
	pI830->need_sync = FALSE;
    }
d1335 1
a1335 1
    if (IS_I965G(pI830))
d1341 1
a1341 1
	if (!pI830->fence_used[fence_nr])
d1347 1
a1347 1
    pI830->fence_used[fence_nr] = TRUE;
d1349 1
a1349 1
    if (IS_I965G(pI830)) {
d1374 1
a1374 1
	if (IS_I9XX(pI830))
d1382 1
a1382 1
		       fence_nr, offset, (IS_I9XX(pI830)) ? "1MB" : "512k");
d1410 1
a1410 1
	if (IS_I9XX(pI830)) {
d1469 1
a1469 1
	if ((IS_I945G(pI830) || IS_I945GM(pI830) || IS_G33CLASS(pI830)) &&
d1472 1
a1472 1
	else if (IS_I9XX(pI830))
d1511 1
a1511 1
i830_clear_tiling(ScrnInfoPtr pScrn, unsigned int fence_nr)
d1513 1
a1513 1
    I830Ptr pI830 = I830PTR(pScrn);
d1515 1
a1515 1
    if (IS_I965G(pI830)) {
d1521 1
a1521 1
    pI830->fence_used[fence_nr] = FALSE;
d1528 1
a1528 1
 * pI830 points to the same allocation list, but the bind_memory will just
d1531 1
a1531 2
Bool
i830_bind_all_memory(ScrnInfoPtr pScrn)
d1533 1
a1533 1
    I830Ptr pI830 = I830PTR(pScrn);
d1535 6
a1540 2
    if (pI830->memory_list == NULL)
	return TRUE;
d1542 5
a1546 3
    if (pI830->use_drm_mode || (xf86AgpGARTSupported() &&
				!pI830->gtt_acquired)) {
	i830_memory *mem;
d1548 16
a1563 4
	if (!pI830->use_drm_mode) {
	    if (!xf86AcquireGART(pScrn->scrnIndex))
		return FALSE;
	    pI830->gtt_acquired = TRUE;
d1565 9
d1575 2
a1576 17
	for (mem = pI830->memory_list->next; mem->next != NULL;
	     mem = mem->next)
	{
	    if (!mem->bound && !i830_bind_memory(pScrn, mem)) {
		/* This shouldn't happen */
		FatalError("Couldn't bind memory for %s\n", mem->name);
	    }
	}
	for (mem = pI830->bo_list; mem != NULL; mem = mem->next) {
	    if (mem->bound)
		continue;
	    if (!mem->lifetime_fixed_offset && !i830_bind_memory(pScrn, mem))
		FatalError("Couldn't bind memory for BO %s\n", mem->name);
	}
    }
    if (!pI830->use_drm_mode)
	i830_update_cursor_offsets(pScrn);
d1578 1
a1578 1
    return TRUE;
d1583 1
a1583 1
i830_unbind_all_memory(ScrnInfoPtr pScrn)
d1585 1
a1585 1
    I830Ptr pI830 = I830PTR(pScrn);
d1587 2
a1588 2
    if (pI830->use_drm_mode || (xf86AgpGARTSupported() &&
				pI830->gtt_acquired)) {
d1591 1
a1591 1
	for (mem = pI830->memory_list->next; mem->next != NULL;
d1594 1
a1594 1
	    i830_unbind_memory(pScrn, mem);
d1596 1
a1596 1
	for (mem = pI830->bo_list; mem != NULL; mem = mem->next) {
d1601 1
a1601 1
		i830_unbind_memory(pScrn, mem);
d1604 2
a1605 2
	if (!pI830->use_drm_mode) {
	    pI830->gtt_acquired = FALSE;
d1607 1
a1607 1
	    if (!xf86ReleaseGART(pScrn->scrnIndex))
d1620 1
a1620 1
I830CheckAvailableMemory(ScrnInfoPtr pScrn)
d1626 3
a1628 3
	!xf86AcquireGART(pScrn->scrnIndex) ||
	(agpinf = xf86GetAGPInfo(pScrn->scrnIndex)) == NULL ||
	!xf86ReleaseGART(pScrn->scrnIndex))
d1632 1
a1632 1
    xf86DrvMsgVerb(pScrn->scrnIndex, X_INFO, 2, "%s: %d kB available\n",
d1642 32
a1673 12
Bool i830_allocate_xvmc_buffer(ScrnInfoPtr pScrn, const char *name,
                               i830_memory **buffer, unsigned long size,
                               int flags)
{
    *buffer = i830_allocate_memory(pScrn, name, size, PITCH_NONE,
                                   GTT_PAGE_SIZE, flags, TILE_NONE);

    if (!*buffer) {
        xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
                   "Failed to allocate memory for %s.\n", name);
        return FALSE;
    }
d1675 2
a1676 2
    if (!i830_bind_memory(pScrn, *buffer))
	return FALSE;
d1678 1
a1678 1
    return TRUE;
d1680 1
d1682 51
@


1.8
log
@xf86-video-intel 2.4.2. Has been in snapshots for weeks. Ok oga@@.
@
text
@a67 1
 * - EXA 965 state buffer
d103 1
d110 3
d122 3
a124 1
		       long size, unsigned long alignment, int flags);
d135 2
a136 2
static unsigned long
i830_get_fence_size(ScrnInfoPtr pScrn, unsigned long size)
a137 1
    I830Ptr pI830 = I830PTR(pScrn);
d160 60
d228 6
a233 17
#ifdef XF86DRI_MM
    if (mem->bo.size != 0) {
	I830Ptr pI830 = I830PTR(pScrn);
	int ret;

	ret = drmBOSetStatus(pI830->drmSubFD, &mem->bo,
			     DRM_BO_FLAG_MEM_VRAM |
			     DRM_BO_FLAG_MEM_TT |
			     DRM_BO_FLAG_READ |
			     DRM_BO_FLAG_WRITE |
			     DRM_BO_FLAG_NO_EVICT,
			     DRM_BO_MASK_MEM |
			     DRM_BO_FLAG_READ |
			     DRM_BO_FLAG_WRITE |
			     DRM_BO_FLAG_NO_EVICT,
			     0, 0, 0);
	if (ret != 0)
d235 1
d238 2
a239 2
	mem->offset = mem->bo.offset;
	mem->end = mem->bo.offset + mem->size;
d247 1
a247 1
	if (mem->key != -1 && 
d256 2
a257 1
    if (mem->tiling != TILE_NONE) {
d268 2
d273 2
a274 1
    if (mem->tiling != TILE_NONE)
d277 3
a279 10
#ifdef XF86DRI_MM
    if (mem->bo.size != 0) {
	I830Ptr pI830 = I830PTR(pScrn);
	int ret;

	ret = drmBOSetStatus(pI830->drmSubFD, &mem->bo,
			     0, DRM_BO_FLAG_NO_EVICT,
			     0, 0, 0);

	if (ret == 0) {
d308 2
a309 2
#ifdef XF86DRI_MM
    if (mem->bo.size != 0) {
d311 1
a311 2

	drmBOUnreference(pI830->drmSubFD, &mem->bo);
a367 1
#ifdef XF86DRI_MM
a371 1
#endif
a381 1
    pI830->front_buffer_2 = NULL;
a382 1
    pI830->xaa_scratch_2 = NULL;
a383 1
    pI830->gen4_render_state_mem = NULL;
a384 1
    pI830->logical_context = NULL;
a387 1
    pI830->third_buffer = NULL;
d391 2
a392 1
    pI830->LpRing->mem = NULL;
a402 2
    i830_free_memory(pScrn, pI830->third_buffer);
    pI830->third_buffer = NULL;
d415 1
a415 1
 * as we think it can, while leaving enough to us to fulfill our non-TTM
d424 1
a424 1
#ifdef XF86DRI_MM
d426 4
d467 20
a486 2
#ifdef XF86DRI_MM
    DRIQueryVersion(&dri_major, &dri_minor, &dri_patch);
d493 3
a495 2
    if (pI830->directRenderingEnabled && pI830->drmMinor >= 7 &&
	(dri_major > 5 || (dri_major == 5 && dri_minor >= 4)))
d505 1
a505 1
	if (pI830->useEXA) {
a508 3
	/* Classic textures are fixed. */
	if (pI830->allocate_classic_textures)
	    mmsize -= MB(32);
d521 1
a521 1
	/* Can't do TTM on stolen memory */
a523 4
	/* new chipsets need non-stolen status page */
	if (HWS_NEED_GFX(pI830) && HWS_NEED_NONSTOLEN(pI830))
	    mmsize -= HWSTATUS_PAGE_SIZE;

d527 3
a529 2
				   mmsize, GTT_PAGE_SIZE,
				   ALIGN_BOTH_ENDS | NEED_NON_STOLEN);
d532 26
a557 12
	    int ret;

	    /* Tell the kernel to manage it */
	    ret = drmMMInit(pI830->drmSubFD,
			    pI830->memory_manager->offset / GTT_PAGE_SIZE,
			    pI830->memory_manager->size / GTT_PAGE_SIZE,
			    DRM_BO_MEM_TT);
	    if (ret != 0) {
		xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
			   "Failed to initialize kernel memory manager\n");
		i830_free_memory(pScrn, pI830->memory_manager);
		pI830->memory_manager = NULL;
d565 2
d568 1
a568 1
#endif /* XF86DRI_MM */
a580 1
#ifdef XF86DRI_MM
d583 1
a583 1
	 drmMMTakedown(pI830->drmSubFD, DRM_BO_MEM_TT);
a586 1
#endif /* XF86DRI_MM */
d683 3
a685 1
		       long size, unsigned long alignment, int flags)
d706 4
d801 1
a801 1
#ifdef XF86DRI_MM
d804 3
a806 1
			unsigned long size, unsigned long align, int flags)
d810 2
a811 2
    unsigned long mask;
    int ret;
d817 1
a817 1
    align = ROUND_TO(align, GTT_PAGE_SIZE);
d824 1
a824 1
    if (name == NULL) {
d829 1
a829 6
    /*
     * Create buffers in local memory to avoid having the creation order
     * determine the TT offset. Driver acceleration
     * cannot handle changed front buffer TT offsets yet ,
     * so let's keep our fingers crossed.
     */
d831 1
a831 8
    mask = DRM_BO_FLAG_READ | DRM_BO_FLAG_WRITE | DRM_BO_FLAG_MAPPABLE |
	DRM_BO_FLAG_MEM_LOCAL;
    if (flags & ALLOW_SHARING)
	mask |= DRM_BO_FLAG_SHAREABLE;

    ret = drmBOCreate(pI830->drmSubFD, size, align / GTT_PAGE_SIZE, NULL,
		      mask, 0, &mem->bo);
    if (ret) {
d836 1
d842 4
d849 21
d871 1
a871 1
    if (pScrn->vtSema) {
d873 1
a873 1
	    drmBOUnreference(pI830->drmSubFD, &mem->bo);
d889 1
a889 1
#endif /* XF86DRI_MM */
d891 1
a891 1
/* Allocates video memory at the given size and alignment.
d911 3
a913 1
		     unsigned long size, unsigned long alignment, int flags)
d916 3
d920 13
a932 2
#ifdef XF86DRI_MM
    I830Ptr pI830 = I830PTR(pScrn);
d934 8
a941 2
    if (pI830->memory_manager && !(flags & NEED_PHYSICAL_ADDR) &&
	!(flags & NEED_LIFETIME_FIXED))
d943 1
a943 1
	return i830_allocate_memory_bo(pScrn, name, size, alignment, flags);
d945 1
a945 1
#endif	
d947 1
a947 1
	mem = i830_allocate_aperture(pScrn, name, size, alignment, flags);
a961 60
    mem->tiling = TILE_NONE;

    return mem;
}

/* Allocate a tiled region with the given size and pitch.
 *
 * As is, we might miss out on tiling some allocations on older hardware with
 * large framebuffer size and a small aperture size, where the first
 * allocations use a large alignment even though we've got fences to spare, and
 * the later allocations can't find enough aperture space left.  We could do
 * some search across all allocation options to fix this, probably, but that
 * would be another rewrite.
 */
i830_memory *
i830_allocate_memory_tiled(ScrnInfoPtr pScrn, const char *name,
			   unsigned long size, unsigned long pitch,
			   unsigned long alignment, int flags,
			   enum tile_format tile_format)
{
    I830Ptr pI830 = I830PTR(pScrn);
    unsigned long aper_size;
    unsigned long aper_align;
    i830_memory *mem;

    if (tile_format == TILE_NONE)
	return i830_allocate_memory(pScrn, name, size, alignment, flags);

    /* Only allocate page-sized increments. */
    size = ALIGN(size, GTT_PAGE_SIZE);

    /* Check for maximum tiled region size */
    if (IS_I9XX(pI830)) {
	if (size > MB(128))
	    return NULL;
    } else {
	if (size > MB(64))
	    return NULL;
    }

    aper_size = i830_get_fence_size(pScrn, size);
    if (IS_I965G(pI830)) {
	aper_align = GTT_PAGE_SIZE;
    } else {
	/* The offset has to be aligned to at least the size of the fence
	 * region.
	 */
	aper_align = aper_size;
    }
    if (aper_align < alignment)
	aper_align = alignment;

    mem = i830_allocate_memory(pScrn, name, aper_size, aper_align, flags);
    if (mem == NULL)
	return NULL;
    mem->size = size;
    mem->tiling = tile_format;
    mem->pitch = pitch;
    mem->fence_nr = -1;

a1014 1
#ifdef XF86DRI_MM
a1043 1
#endif /* XF86DRI_MM */
d1051 1
a1051 1
    if (pI830->noAccel || pI830->LpRing->mem != NULL)
d1057 5
a1061 5
    pI830->LpRing->mem = i830_allocate_memory(pScrn, "ring buffer",
					      PRIMARY_RINGBUFFER_SIZE,
					      GTT_PAGE_SIZE,
					      NEED_LIFETIME_FIXED);
    if (pI830->LpRing->mem == NULL) {
d1067 1
a1067 1
    pI830->LpRing->tail_mask = pI830->LpRing->mem->size - 1;
d1089 3
a1091 1
    if (!OVERLAY_NOPHYSICAL(pI830))
d1093 1
d1096 2
a1097 2
					       OVERLAY_SIZE, GTT_PAGE_SIZE,
					       flags);
d1104 4
a1157 4
 *
 * \param pScrn ScrnInfoPtr for the screen being allocated
 * \param pI830 I830Ptr for the screen being allocated.
 * \param FbMemBox
d1159 2
a1160 3
static i830_memory *
i830_allocate_framebuffer(ScrnInfoPtr pScrn, I830Ptr pI830, BoxPtr FbMemBox,
			  Bool secondary)
d1162 1
a1167 1
    char *name;
d1170 1
a1170 1
    Bool tiling;
a1173 3
    /* Clear everything first. */
    memset(FbMemBox, 0, sizeof(*FbMemBox));

d1177 8
a1184 4
    if (pScrn->virtualX > pScrn->virtualY)
	fb_height = pScrn->virtualX;
    else
	fb_height = pScrn->virtualY;
d1186 4
a1189 4
    FbMemBox->x1 = 0;
    FbMemBox->x2 = pScrn->displayWidth;
    FbMemBox->y1 = 0;
    FbMemBox->y2 = fb_height;
d1199 1
a1199 1
    if (!pI830->useEXA) {
d1224 1
a1224 1
	FbMemBox->y2 += cacheLines;
d1230 1
a1230 1
	/* For EXA, we have a separate allocation for the linear allocator
a1238 2
    name = secondary ? "secondary front buffer" : "front buffer";

d1243 13
a1255 4
    if (!pI830->useEXA && IS_I965G(pI830))
	tiling = FALSE;
    else
	tiling = pI830->tiling;
d1258 1
a1258 1
    if (tiling && IsTileable(pScrn, pitch)) {
d1264 5
a1268 4
	front_buffer = i830_allocate_memory_tiled(pScrn, name, size,
						  pitch, align, flags,
						  TILE_XMAJOR);
    }
a1269 1
    /* If not, attempt it linear */
d1271 2
a1272 7
	front_buffer = i830_allocate_memory(pScrn, name, size, KB(64), flags);
    }

    if (front_buffer == NULL) {
	xf86DrvMsg(pScrn->scrnIndex, X_ERROR, "Failed to allocate "
		   "%sframebuffer. Is your VideoRAM set too low?\n",
		   secondary ? "secondary " : "");
d1276 1
a1276 1
    if (pI830->FbBase)
d1278 1
d1287 1
a1287 1
    int flags = pI830->CursorNeedsPhysical ? NEED_PHYSICAL_ADDR : 0;
d1291 5
d1304 2
a1305 2
					     size, GTT_PAGE_SIZE,
					     flags);
d1319 1
d1321 2
a1322 1
							     flags);
d1327 1
d1329 2
a1330 1
							  flags);
d1375 3
a1377 1
			     compressed_size, KB(4), NEED_PHYSICAL_ADDR);
d1387 4
a1390 2
				 FBC_LL_SIZE + FBC_LL_PAD, KB(4),
				 NEED_PHYSICAL_ADDR);
d1416 12
a1427 8
    if (!pI830->StolenOnly &&
	(!xf86AgpGARTSupported() || !xf86AcquireGART(pScrn->scrnIndex))) {
	xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
		   "AGP GART support is either not available or cannot "
		   "be used.\n"
		   "\tMake sure your kernel has agpgart support or has\n"
		   "\tthe agpgart module loaded.\n");
	return FALSE;
a1429 3
    /* Allocate the ring buffer first, so it ends up in stolen mem. */
    i830_allocate_ringbuffer(pScrn);

d1434 3
a1436 13
    if (!pI830->SWCursor && !i830_allocate_cursor_buffers(pScrn)) {
	xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
		   "Disabling HW cursor because the cursor memory "
		   "allocation failed.\n");
	pI830->SWCursor = TRUE;
    }

    /* Space for the X Server's 3D context.  32k is fine for right now. */
    pI830->logical_context = i830_allocate_memory(pScrn, "logical 3D context",
						  KB(32), GTT_PAGE_SIZE, 0);
    if (pI830->logical_context == NULL) {
	xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
		   "Failed to allocate logical context space.\n");
d1440 5
a1444 9
    /* even in XAA, 965G needs state mem buffer for rendering */
    if (IS_I965G(pI830) && !pI830->noAccel &&
	pI830->gen4_render_state_mem == NULL)
    {
	pI830->gen4_render_state_mem =
	    i830_allocate_memory(pScrn, "exa G965 state buffer",
				 gen4_render_state_size(pScrn),
				 GTT_PAGE_SIZE, 0);
	if (pI830->gen4_render_state_mem == NULL) {
d1446 1
a1446 1
		    "Failed to allocate exa state buffer for 965.\n");
d1455 1
a1455 1
    if (I830IsPrimary(pScrn))
d1459 1
a1459 12
    if (pI830->entityPrivate && pI830->entityPrivate->pScrn_2) {
	I830EntPtr pI830Ent = pI830->entityPrivate;
	I830Ptr pI8302 = I830PTR(pI830Ent->pScrn_2);

	pI830->front_buffer_2 =
	    i830_allocate_framebuffer(pI830Ent->pScrn_2, pI8302,
				      &pI830->FbMemBox2, TRUE);
	if (pI830->front_buffer_2 == NULL)
	    return FALSE;
    }
    pI830->front_buffer =
	i830_allocate_framebuffer(pScrn, pI830, &pI830->FbMemBox, FALSE);
d1464 1
a1464 1
    if (pI830->useEXA) {
d1482 2
a1483 1
				     size, 1, NEED_LIFETIME_FIXED);
d1493 1
a1493 1
    if (!pI830->noAccel && !pI830->useEXA) {
d1496 1
a1496 1
	 * end up being supported with TTM anyway.
d1500 2
a1501 1
				 GTT_PAGE_SIZE, NEED_LIFETIME_FIXED);
d1505 3
a1507 2
				     MIN_SCRATCH_BUFFER_SIZE, GTT_PAGE_SIZE,
				     NEED_LIFETIME_FIXED);
a1513 22

	/* Let's allocate another scratch buffer for the second head */
	/* Again, this code won't execute on the dry run pass */
	if (pI830->entityPrivate && pI830->entityPrivate->pScrn_2)
	{
	    pI830->xaa_scratch_2 =
		i830_allocate_memory(pScrn, "xaa scratch 2",
				     MAX_SCRATCH_BUFFER_SIZE, GTT_PAGE_SIZE,
				     NEED_LIFETIME_FIXED);
	    if (pI830->xaa_scratch_2 == NULL) {
		pI830->xaa_scratch_2 =
		    i830_allocate_memory(pScrn, "xaa scratch 2",
					 MIN_SCRATCH_BUFFER_SIZE,
					 GTT_PAGE_SIZE, NEED_LIFETIME_FIXED);
		if (pI830->xaa_scratch_2 == NULL) {
		    xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
			       "Failed to allocate secondary scratch "
			       "buffer space\n");
		    return FALSE;
		}
	    }
	}
d1540 1
d1551 1
a1551 5
	*buffer = i830_allocate_memory_tiled(pScrn, name, size, pitch,
					     GTT_PAGE_SIZE,
					     ALIGN_BOTH_ENDS |
					     ALLOW_SHARING,
					     TILE_XMAJOR);
d1553 2
a1554 5

    /* Otherwise, just allocate it linear.  The offset must stay constant
     * currently because we don't ever update the DRI maps after screen init.
     */
    if (*buffer == NULL) {
d1556 1
a1556 3
	*buffer = i830_allocate_memory(pScrn, name, size, GTT_PAGE_SIZE,
				       ALIGN_BOTH_ENDS |
				       ALLOW_SHARING);
d1558 5
d1580 2
d1583 1
a1583 5
    /* XXX: this rotation stuff is bogus */
    if (pI830->rotation & (RR_Rotate_0 | RR_Rotate_180))
	height = pScrn->virtualY;
    else
	height = pScrn->virtualX;
d1586 1
a1588 4
	enum tile_format tile_format;

	size = ROUND_TO_PAGE(pitch * ALIGN(height, 16));

d1593 2
a1594 7

	pI830->depth_buffer =
	    i830_allocate_memory_tiled(pScrn, "depth buffer", size, pitch,
				       GTT_PAGE_SIZE,
				       ALIGN_BOTH_ENDS |
				       ALLOW_SHARING,
				       tile_format);
d1596 1
d1598 3
a1600 9
    /* Otherwise, allocate it linear. The offset must stay constant
     * currently because we don't ever update the DRI maps after screen init.
     */
    if (pI830->depth_buffer == NULL) {
	size = ROUND_TO_PAGE(pitch * height);
	pI830->depth_buffer =
	    i830_allocate_memory(pScrn, "depth buffer", size, GTT_PAGE_SIZE,
				 ALLOW_SHARING);
    }
d1635 4
a1638 2
	/* The offset must stay constant currently because we don't ever update
	 * the DRI maps after screen init.
d1641 1
d1644 2
a1645 1
					       NEED_LIFETIME_FIXED);
d1670 2
a1671 1
	    HWSTATUS_PAGE_SIZE, GTT_PAGE_SIZE, flags);
d1685 3
d1689 4
a1692 2
						PWRCTX_SIZE, GTT_PAGE_SIZE,
						NEED_LIFETIME_FIXED);
d1708 1
a1708 1
    if (HWS_NEED_GFX(pI830)) {
a1715 8
    if (pI830->TripleBuffer && !i830_allocate_backbuffer(pScrn,
							 &pI830->third_buffer,
							 "third buffer")) {
       xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
		  "Failed to allocate third buffer, triple buffering "
		  "inactive\n");
    }

d1750 5
d1956 1
a1956 1
    if (pI830->StolenOnly == TRUE || pI830->memory_list == NULL)
d1959 2
a1960 1
    if (xf86AgpGARTSupported() && !pI830->gtt_acquired) {
d1963 5
a1967 4
	if (!xf86AcquireGART(pScrn->scrnIndex))
	    return FALSE;

	pI830->gtt_acquired = TRUE;
d1972 1
a1972 1
	    if (!i830_bind_memory(pScrn, mem)) {
a1976 1
#ifdef XF86DRI_MM
d1978 2
a1982 1
#endif
d1984 1
a1984 1
    if (!pI830->SWCursor)
d1996 2
a1997 4
    if (pI830->StolenOnly == TRUE)
	return TRUE;

    if (xf86AgpGARTSupported() && pI830->gtt_acquired) {
a2004 1
#ifdef XF86DRI_MM
a2011 1
#endif
d2013 2
a2014 1
	pI830->gtt_acquired = FALSE;
d2016 3
a2018 2
	if (!xf86ReleaseGART(pScrn->scrnIndex))
	    return FALSE;
d2055 2
a2056 2
    *buffer = i830_allocate_memory(pScrn, name, size,
                                   GTT_PAGE_SIZE, flags);
@


1.7
log
@update to xf86-video-intel 2.3.2. Tested among others by okan@@.
@
text
@d338 1
a338 1
    pI830->exa_965_state = NULL;
d450 1
a450 1
	if (!OVERLAY_NOPHYSICAL(pI830) && !IS_IGD_GM(pI830)) {
d462 2
a463 1
	if (HWS_NEED_GFX(pI830) && IS_IGD_GM(pI830))
d1031 1
a1031 1
    if (IS_IGD_GM(pI830))
d1285 1
a1285 1
    if (IS_IGD_GM(pI830)) {
d1312 1
a1312 1
    if (!IS_IGD_GM(pI830)) {
d1376 4
a1379 2
    if (IS_I965G(pI830) && !pI830->noAccel && pI830->exa_965_state == NULL) {
	pI830->exa_965_state =
d1381 3
a1383 2
		    EXA_LINEAR_EXTRA, GTT_PAGE_SIZE, 0);
	if (pI830->exa_965_state == NULL) {
d1650 1
a1650 1
    if (IS_IGD_GM(pI830))
@


1.6
log
@Update to xf86-video-intel 2.3.1. Tested by many.
@
text
@d115 1
d341 1
d1659 16
d2023 1
d2045 1
@


1.5
log
@Update to Intel driver 2.2.1. But change default accelmethod to XAA.
Tested by landry@@, oga@@, steven@@, jakemsr@@.
@
text
@a103 1
#include <sys/mman.h>
a205 7
    /* Mark the pages accessible now that they're bound. */
    if (mprotect(pI830->FbBase + mem->offset, ALIGN(mem->size, GTT_PAGE_SIZE),
		 PROT_READ | PROT_WRITE) != 0) {
	xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
		   "Failed to mprotect %s: %s\n", mem->name, strerror(errno));
    }

a211 2
    I830Ptr pI830 = I830PTR(pScrn);

a214 7
    /* Mark the pages accessible now that they're bound. */
    if (mprotect(pI830->FbBase + mem->offset, ALIGN(mem->size, GTT_PAGE_SIZE),
		 PROT_NONE) != 0) {
	xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
		   "Failed to mprotect %s: %s\n", mem->name, strerror(errno));
    }

d448 1
a448 1
	if (!OVERLAY_NOPHYSICAL(pI830) && !IS_I965G(pI830)) {
d456 1
a456 1
	    mmsize -= MB(6);
d529 1
a529 1
    CARD32 gttentry;
a715 4
    if (!i830_bind_memory(pScrn, mem)) {
	return FALSE;
    }

d835 5
d1028 3
d1034 7
a1040 9
    if (!IS_I965G(pI830)) {
	pI830->overlay_regs = i830_allocate_memory(pScrn, "overlay registers",
						   OVERLAY_SIZE, GTT_PAGE_SIZE,
						   flags);
	if (pI830->overlay_regs == NULL) {
	    xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
		       "Failed to allocate Overlay register space.\n");
	    /* This failure isn't fatal. */
	}
d1268 7
d1282 6
a1287 5
    /* Clear out any stale state */
    OUTREG(FBC_CFB_BASE, 0);
    OUTREG(FBC_LL_BASE, 0);
    OUTREG(FBC_CONTROL2, 0);
    OUTREG(FBC_CONTROL, 0);
d1302 1
a1302 1
			     MB(6), KB(4), NEED_PHYSICAL_ADDR);
d1309 10
a1318 8
    pI830->compressed_ll_buffer =
	i830_allocate_memory(pScrn, "compressed ll buffer",
			     FBC_LL_SIZE + FBC_LL_PAD, KB(4),
			     NEED_PHYSICAL_ADDR);
    if (!pI830->compressed_ll_buffer) {
	i830_free_memory(pScrn, pI830->compressed_front_buffer);
	pI830->fb_compression = FALSE;
	goto out;
d1702 2
a1703 2
    CARD32 val;
    CARD32 fence_mask = 0;
d2003 22
@


1.4
log
@Merge intel driver version 2.2.0.90.
@
text
@d477 3
d1642 1
d1648 5
a1652 2
    pI830->hw_status = i830_allocate_memory(pScrn, "G33 hw status",
	    HWSTATUS_PAGE_SIZE, GTT_PAGE_SIZE, NEED_LIFETIME_FIXED);
d1655 1
a1655 1
		"Failed to allocate hw status page for G33.\n");
d1668 1
a1668 1
    if (IS_G33CLASS(pI830)) {
@


1.3
log
@merge xf86-video-intel 2.2.0
@
text
@d100 1
d278 1
a278 1
	if (pI830->bo_list == mem)
d280 8
a287 4
	if (mem->next)
	    mem->next->prev = NULL;
	if (mem->prev)
	    mem->prev->next = NULL;
d604 2
a605 2
		       "Non-contiguous GTT entries: (%ld,0x16%llx) vs "
		       "(%ld,0x%16llx)\n",
d953 1
a953 1
		    ", 0x%016llx physical\n", mem->bus_addr);
d1938 2
a1939 1
    i830_update_cursor_offsets(pScrn);
@


1.2
log
@Add support for the mobile i965GM chipset.

tested by many
ok matthieu@@
@
text
@d53 42
d99 1
d101 3
d111 4
a114 2
static int nextTile = 0;
static unsigned int tileGeneration = -1;
d116 9
a124 3
#ifndef ALLOCATE_ALL_BIOSMEM
#define ALLOCATE_ALL_BIOSMEM 1
#endif
d126 3
d130 1
a130 1
GetBestTileAlignment(unsigned long size)
d132 15
a146 1
   unsigned long i;
d148 2
a149 2
   for (i = KB(512); i < size; i <<= 1)
      ;
d151 2
a152 4
   if (i > MB(64))
      i = MB(64);

   return i;
d155 2
a156 7
/*
 * Allocate memory from the given pool.  Grow the pool if needed and if
 * possible.
 */
static unsigned long
AllocFromPool(ScrnInfoPtr pScrn, I830MemRange *result, I830MemPool *pool,
	      long size, unsigned long alignment, int flags)
d158 56
a213 67
   I830Ptr pI830 = I830PTR(pScrn);
   long needed, start, end;
   Bool dryrun = ((flags & ALLOCATE_DRY_RUN) != 0);

   if (!result || !pool || !size)
      return 0;

   /* Calculate how much space is needed. */
   if (alignment <= GTT_PAGE_SIZE)
      needed = size;
   else {
      if (flags & ALLOCATE_AT_BOTTOM) {
	 start = ROUND_TO(pool->Free.Start, alignment);
	 if (flags & ALIGN_BOTH_ENDS)
	    end = ROUND_TO(start + size, alignment);
	 else
	    end = start + size;
	 needed = end - pool->Free.Start;
      } else {				/* allocate at top */
	 if (flags & ALIGN_BOTH_ENDS)
	    end = ROUND_DOWN_TO(pool->Free.End, alignment);
	 else
	    end = pool->Free.End;

	 start = ROUND_DOWN_TO(end - size, alignment);
	 needed = end - start;
      }
   }
   if (needed > pool->Free.Size) {
      long extra;
      /* See if the pool can be grown. */
      if (pI830->StolenOnly && !dryrun)
	 return 0;
      extra = needed - pool->Free.Size;
      extra = ROUND_TO_PAGE(extra);
      if (extra > pI830->FreeMemory) {
	 if (dryrun)
	    pI830->FreeMemory = extra;
	 else
	    return 0;
      }

      if (!dryrun && ((long)extra > pI830->MemoryAperture.Size))
	 return 0;

      pool->Free.Size += extra;
      pool->Free.End += extra;
      pool->Total.Size += extra;
      pool->Total.End += extra;
      pI830->FreeMemory -= extra;
      pI830->MemoryAperture.Start += extra;
      pI830->MemoryAperture.Size -= extra;
   }
   if (flags & ALLOCATE_AT_BOTTOM) {
      result->Start = ROUND_TO(pool->Free.Start, alignment);
      pool->Free.Start += needed;
      result->End = pool->Free.Start;
   } else {
      result->Start = ROUND_DOWN_TO(pool->Free.End - size, alignment);
      pool->Free.End -= needed;
      result->End = result->Start + needed;
   }
   pool->Free.Size = pool->Free.End - pool->Free.Start;
   result->Size = result->End - result->Start;
   result->Pool = pool;
   result->Alignment = alignment;
   return needed;
d216 2
a217 3
static unsigned long
AllocFromAGP(ScrnInfoPtr pScrn, I830MemRange *result, long size,
	     unsigned long alignment, int flags)
d219 4
a222 66
   I830Ptr pI830 = I830PTR(pScrn);
   unsigned long start, end;
   unsigned long newApStart, newApEnd;
   Bool dryrun = ((flags & ALLOCATE_DRY_RUN) != 0);

   if (!result || !size)
      return 0;

   if ((flags & ALLOCATE_AT_BOTTOM) && pI830->StolenMemory.Size != 0) {
      xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
		 "AllocFromAGP(): can't allocate from "
		 "bottom when there is stolen memory\n");
      return 0;
   }

   if (size > pI830->FreeMemory) {
      if (dryrun)
	 pI830->FreeMemory = size;
      else
	 return 0;
   }

   /* Calculate offset */
   if (flags & ALLOCATE_AT_BOTTOM) {
      start = ROUND_TO(pI830->MemoryAperture.Start, alignment);
      if (flags & ALIGN_BOTH_ENDS)
	 end = ROUND_TO(start + size, alignment);
      else
	 end = start + size;
      newApStart = end;
      newApEnd = pI830->MemoryAperture.End;
   } else {
      if (flags & ALIGN_BOTH_ENDS)
	 end = ROUND_DOWN_TO(pI830->MemoryAperture.End, alignment);
      else
	 end = pI830->MemoryAperture.End;
      start = ROUND_DOWN_TO(end - size, alignment);
      newApStart = pI830->MemoryAperture.Start;
      newApEnd = start;
   }

   if (!dryrun) {
      if (newApStart > newApEnd)
	 return 0;

      if (flags & NEED_PHYSICAL_ADDR) 
	 result->Key = xf86AllocateGARTMemory(pScrn->scrnIndex, size, 2,
					      &(result->Physical));
      else 
	 result->Key = xf86AllocateGARTMemory(pScrn->scrnIndex, size, 0, NULL);

      if (result->Key == -1)
	 return 0;
   }

   pI830->allocatedMemory += size;
   pI830->MemoryAperture.Start = newApStart;
   pI830->MemoryAperture.End = newApEnd;
   pI830->MemoryAperture.Size = newApEnd - newApStart;
   pI830->FreeMemory -= size;
   result->Start = start;
   result->End = start + size;
   result->Size = size;
   result->Offset = start;
   result->Alignment = alignment;
   result->Pool = NULL;
d224 37
a260 1
   return size;
d264 1
a264 1
I830FreeVidMem(ScrnInfoPtr pScrn, I830MemRange *range)
d266 2
a267 1
   I830Ptr pI830 = I830PTR(pScrn);
d269 2
a270 2
   if (!range || range->Size == 0)
      return;
d272 26
a297 82
   if (range->Key != -1)
      xf86DeallocateGARTMemory(pScrn->scrnIndex, range->Key);

   if (range->Pool) {
      /* 
       * This code essentially resets what I830DoPoolAllocation() did.
       * And if things are freed in the wrong order this can break wildly!
       * USE CAUTION when changing anything here...
       */
      I830MemPool *Pool = range->Pool;
      if (pI830->overrideBIOSMemSize &&
          pI830->BIOSMemorySize > pI830->StolenMemory.Size) 
         Pool->Total.End = pI830->BIOSMemorySize;
      else 
         Pool->Total.End = pI830->StolenMemory.End;

      if (pI830->StolenOnly)
         Pool->Free.End += range->Size;
      else
         Pool->Free.End = Pool->Total.End;

      if (Pool->Free.End < Pool->Free.Start) {
         Pool->Free.End = Pool->Free.Start;
      }

      Pool->Free.Size = Pool->Free.End - Pool->Free.Start;
      Pool->Total.Size = Pool->Total.End - Pool->Total.Start;

      if (!pI830->StolenOnly) {
         pI830->FreeMemory -= Pool->Free.Size;
         pI830->MemoryAperture.Start -= (range->Size - Pool->Free.Size);
         pI830->MemoryAperture.Size += (range->Size - Pool->Free.Size);
      }
   } else {
      if (range->Alignment == GTT_PAGE_SIZE)
         pI830->MemoryAperture.End = range->End;
      else
         pI830->MemoryAperture.End = range->End - range->Size + range->Alignment;
      pI830->MemoryAperture.Size = pI830->MemoryAperture.End - pI830->MemoryAperture.Start;
   }

   if (!pI830->StolenOnly)
      pI830->FreeMemory += range->Size;
   pI830->allocatedMemory -= range->Size;
}

unsigned long
I830AllocVidMem(ScrnInfoPtr pScrn, I830MemRange *result, I830MemPool *pool,
		long size, unsigned long alignment, int flags)
{
   I830Ptr pI830 = I830PTR(pScrn);
   Bool dryrun = ((flags & ALLOCATE_DRY_RUN) != 0);

   if (!result)
      return 0;

   /* Make sure these are initialised. */
   result->Size = 0;
   result->Key = -1;

   if (!size) {
      return 0;
   }

   switch (flags & FROM_MASK) {
   case FROM_POOL_ONLY:
      return AllocFromPool(pScrn, result, pool, size, alignment, flags);
   case FROM_NEW_ONLY:
      if (!dryrun && (pI830->StolenOnly || (pI830->FreeMemory <= 0)))
	 return 0;
      return AllocFromAGP(pScrn, result, size, alignment, flags);
   case FROM_ANYWHERE:
      if ((!(flags & ALLOCATE_AT_BOTTOM) && (pI830->FreeMemory >= size)) ||
	  (flags & NEED_PHYSICAL_ADDR))
	 return AllocFromAGP(pScrn, result, size, alignment, flags);
      else
	 return AllocFromPool(pScrn, result, pool, size, alignment, flags);
   default:
      /* Shouldn't happen. */
      return 0;
   }
}
d299 2
a300 38
static Bool
AllocateRingBuffer(ScrnInfoPtr pScrn, int flags)
{
   I830Ptr pI830 = I830PTR(pScrn);
   unsigned long size, alloced;
   Bool dryrun = ((flags & ALLOCATE_DRY_RUN) != 0);
   int verbosity = dryrun ? 4 : 1;
   const char *s = dryrun ? "[dryrun] " : "";

   /* Clear ring buffer  info */
   memset(pI830->LpRing, 0, sizeof(I830RingBuffer));
   pI830->LpRing->mem.Key = -1;

   if (pI830->noAccel)
      return TRUE;

   /* Ring buffer */
   size = PRIMARY_RINGBUFFER_SIZE;
   if (flags & FORCE_LOW)
      flags |= FROM_POOL_ONLY | ALLOCATE_AT_BOTTOM;
   else
      flags |= FROM_ANYWHERE | ALLOCATE_AT_TOP;

   alloced = I830AllocVidMem(pScrn, &(pI830->LpRing->mem),
				&(pI830->StolenPool), size,
				GTT_PAGE_SIZE, flags);
   if (alloced < size) {
      if (!dryrun) {
	 xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
		    "Failed to allocate Ring Buffer space\n");
      }
      return FALSE;
   }
   xf86DrvMsgVerb(pScrn->scrnIndex, X_INFO, verbosity,
		  "%sAllocated %ld kB for the ring buffer at 0x%lx\n", s,
		  alloced / 1024, pI830->LpRing->mem.Start);
   pI830->LpRing->tail_mask = pI830->LpRing->mem.Size - 1;
   return TRUE;
d303 2
a304 3
#ifdef I830_XV
/*
 * Note, the FORCE_LOW flag is currently not used or supported.
d306 2
a307 2
static Bool
AllocateOverlay(ScrnInfoPtr pScrn, int flags)
d309 2
a310 68
   I830Ptr pI830 = I830PTR(pScrn);
   unsigned long size, alloced;
   Bool dryrun = ((flags & ALLOCATE_DRY_RUN) != 0);
   int verbosity = dryrun ? 4 : 1;
   const char *s = dryrun ? "[dryrun] " : "";

   /* Clear overlay info */
   memset(pI830->OverlayMem, 0, sizeof(I830MemRange));
   pI830->OverlayMem->Key = -1;

   if (!pI830->XvEnabled)
      return TRUE;

   /*
    * The overlay register space needs a physical address in
    * system memory.  We get this from the agpgart module using
    * a special memory type.
    */

   size = OVERLAY_SIZE;
   if (flags & FORCE_LOW)
      flags |= FROM_POOL_ONLY | ALLOCATE_AT_BOTTOM | NEED_PHYSICAL_ADDR;
   else
      flags |= FROM_ANYWHERE | ALLOCATE_AT_TOP | NEED_PHYSICAL_ADDR;

   alloced = I830AllocVidMem(pScrn, pI830->OverlayMem,
			     &(pI830->StolenPool), size, GTT_PAGE_SIZE, flags);

   /*
    * XXX For testing only.  Don't enable this unless you know how to set
    * physBase.
    */
   if (flags & FORCE_LOW) {
      ErrorF("AllocateOverlay() doesn't support setting FORCE_LOW\n");
      return FALSE;
   }

   if (!dryrun && (alloced < size)) {
      xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
		 "Failed to allocate Overlay register space.\n");
	 /* This failure isn't fatal. */
   } else {
      xf86DrvMsgVerb(pScrn->scrnIndex, X_INFO, verbosity,
		     "%sAllocated %ld kB for Overlay registers at 0x%lx "
		     "(0x%08lx).\n", s,
		     alloced / 1024, pI830->OverlayMem->Start,
		     pI830->OverlayMem->Physical);
   }

   /* Clear linearmem info */
   if (pI830->LinearAlloc) {
      memset(&(pI830->LinearMem), 0, sizeof(I830MemRange));
      pI830->LinearMem.Key = -1;

      size = KB(pI830->LinearAlloc);
      alloced = I830AllocVidMem(pScrn, &(pI830->LinearMem), &(pI830->StolenPool),
				size, GTT_PAGE_SIZE,
				FROM_ANYWHERE | ALLOCATE_AT_TOP);
      if (alloced < size) {
         if (!dryrun) {
            xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
		       "Failed to allocate linear buffer space\n");
         }
      } else
         xf86DrvMsgVerb(pScrn->scrnIndex, X_INFO, verbosity,
		    "%sAllocated %ld kB for the linear buffer at 0x%lx\n", s,
		    alloced / 1024, pI830->LinearMem.Start);
   }
d312 47
a358 1
   return TRUE;
a359 1
#endif
d361 2
a362 2
static Bool
IsTileable(int pitch)
d364 12
a375 16
   /*
    * Allow tiling for pitches that are a power of 2 multiple of 128 bytes,
    * up to 64 * 128 (= 8192) bytes.
    */
   switch (pitch) {
   case 128 * 1:
   case 128 * 2:
   case 128 * 4:
   case 128 * 8:
   case 128 * 16:
   case 128 * 32:
   case 128 * 64:
      return TRUE;
   default:
      return FALSE;
   }
d378 9
d388 1
a388 1
I830AllocateRotatedBuffer(ScrnInfoPtr pScrn, int flags)
d390 112
a501 58
   I830Ptr pI830 = I830PTR(pScrn);
   unsigned long size, alloced;
   Bool dryrun = ((flags & ALLOCATE_DRY_RUN) != 0);
   int verbosity = dryrun ? 4 : 1;
   const char *s = dryrun ? "[dryrun] " : "";
   int align;
   Bool tileable;
   int lines;
   int height = (pI830->rotation & (RR_Rotate_0 | RR_Rotate_180)) ? pScrn->virtualY : pScrn->virtualX;

   /* Rotated Buffer */
   memset(&(pI830->RotatedMem), 0, sizeof(I830MemRange));
   pI830->RotatedMem.Key = -1;
   tileable = !(flags & ALLOC_NO_TILING) &&
	      IsTileable(pScrn->displayWidth * pI830->cpp);
   if (tileable) {
      /* Make the height a multiple of the tile height (16) */
      lines = (height + 15) / 16 * 16;
   } else {
      lines = height;
   }

   size = ROUND_TO_PAGE(pScrn->displayWidth * lines * pI830->cpp);
   /*
    * Try to allocate on the best tile-friendly boundaries.
    */
   alloced = 0;
   if (tileable) {
      align = GetBestTileAlignment(size);
      for (align = GetBestTileAlignment(size); align >= (IS_I9XX(pI830) ? MB(1) : KB(512)); align >>= 1) {
	 alloced = I830AllocVidMem(pScrn, &(pI830->RotatedMem),
				   &(pI830->StolenPool), size, align,
				   flags | FROM_ANYWHERE | ALLOCATE_AT_TOP |
				   ALIGN_BOTH_ENDS);
	 if (alloced >= size)
	    break;
      }
   }
   if (alloced < size) {
      /* Give up on trying to tile */
      tileable = FALSE;
      size = ROUND_TO_PAGE(pScrn->displayWidth * height * pI830->cpp);
      align = GTT_PAGE_SIZE;
      alloced = I830AllocVidMem(pScrn, &(pI830->RotatedMem),
				&(pI830->StolenPool), size, align,
				flags | FROM_ANYWHERE | ALLOCATE_AT_TOP);
   }
   if (alloced < size) {
      if (!dryrun) {
	 xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
		    "Failed to allocate rotated buffer space.\n");
      }
      return FALSE;
   }
   xf86DrvMsgVerb(pScrn->scrnIndex, X_INFO, verbosity,
		  "%sAllocated %ld kB for the rotated buffer at 0x%lx.\n", s,
		  alloced / 1024, pI830->RotatedMem.Start);
   return TRUE;
d504 2
a505 2
Bool
I830AllocateRotated2Buffer(ScrnInfoPtr pScrn, int flags)
d507 4
a510 61
   I830Ptr pI830 = I830PTR(pScrn);
   unsigned long size, alloced;
   Bool dryrun = ((flags & ALLOCATE_DRY_RUN) != 0);
   int verbosity = dryrun ? 4 : 1;
   const char *s = dryrun ? "[dryrun] " : "";
   int align;
   Bool tileable;
   int lines;
   I830EntPtr pI830Ent = pI830->entityPrivate;
   I830Ptr pI8302 = I830PTR(pI830Ent->pScrn_2);
   int height = (pI8302->rotation & (RR_Rotate_0 | RR_Rotate_180)) ? pI830Ent->pScrn_2->virtualY : pI830Ent->pScrn_2->virtualX;

   /* Rotated Buffer */
   memset(&(pI830->RotatedMem2), 0, sizeof(I830MemRange));
   pI830->RotatedMem2.Key = -1;
   tileable = !(flags & ALLOC_NO_TILING) &&
	      IsTileable(pI830Ent->pScrn_2->displayWidth * pI8302->cpp);
   if (tileable) {
      /* Make the height a multiple of the tile height (16) */
      lines = (height + 15) / 16 * 16;
   } else {
      lines = height;
   }

   size = ROUND_TO_PAGE(pI830Ent->pScrn_2->displayWidth * lines * pI8302->cpp);
   /*
    * Try to allocate on the best tile-friendly boundaries.
    */
   alloced = 0;
   if (tileable) {
      align = GetBestTileAlignment(size);
      for (align = GetBestTileAlignment(size); align >= (IS_I9XX(pI830) ? MB(1) : KB(512)); align >>= 1) {
	 alloced = I830AllocVidMem(pScrn, &(pI830->RotatedMem2),
				   &(pI830->StolenPool), size, align,
				   flags | FROM_ANYWHERE | ALLOCATE_AT_TOP |
				   ALIGN_BOTH_ENDS);
	 if (alloced >= size)
	    break;
      }
   }
   if (alloced < size) {
      /* Give up on trying to tile */
      tileable = FALSE;
      size = ROUND_TO_PAGE(pI830Ent->pScrn_2->displayWidth * height * pI8302->cpp);
      align = GTT_PAGE_SIZE;
      alloced = I830AllocVidMem(pScrn, &(pI830->RotatedMem2),
				&(pI830->StolenPool), size, align,
				flags | FROM_ANYWHERE | ALLOCATE_AT_TOP);
   }
   if (alloced < size) {
      if (!dryrun) {
	 xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
		    "Failed to allocate rotated2 buffer space.\n");
      }
      return FALSE;
   }
   xf86DrvMsgVerb(pScrn->scrnIndex, X_INFO, verbosity,
		  "%sAllocated %ld kB for the rotated2 buffer at 0x%lx.\n", s,
		  alloced / 1024, pI830->RotatedMem2.Start);
   return TRUE;
}
d512 24
a535 2
static unsigned long
GetFreeSpace(ScrnInfoPtr pScrn)
d537 2
a538 2
   I830Ptr pI830 = I830PTR(pScrn);
   unsigned long extra = 0;
d540 65
a604 6
   /* First check for free space in StolenPool. */
   if (pI830->StolenPool.Free.Size > 0)
      extra = pI830->StolenPool.Free.Size;
   /* Next check for unallocated space. */
   if (pI830->FreeMemory > 0)
      extra += pI830->FreeMemory;
d606 1
a606 1
   return extra;
d609 4
a612 3
/*
 * Allocate memory for 2D operation.  This includes the (front) framebuffer,
 * ring buffer, scratch memory, HW cursor.
d614 39
d654 40
a693 2
Bool
I830Allocate2DMemory(ScrnInfoPtr pScrn, const int flags)
d695 13
a707 69
   I830Ptr pI830 = I830PTR(pScrn);
   long size, alloced;
   Bool dryrun = ((flags & ALLOCATE_DRY_RUN) != 0);
   int verbosity = dryrun ? 4 : 1;
   const char *s = dryrun ? "[dryrun] " : "";
   Bool tileable;
   int align, alignflags;

   DPRINTF(PFX, "I830Allocate2DMemory: inital is %s\n",
	   BOOLTOSTRING(flags & ALLOC_INITIAL));

   if (!pI830->StolenOnly &&
       (!xf86AgpGARTSupported() || !xf86AcquireGART(pScrn->scrnIndex))) {
      if (!dryrun) {
	 xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
		    "AGP GART support is either not available or cannot "
		    "be used.\n"
		    "\tMake sure your kernel has agpgart support or has the\n"
		    "\tagpgart module loaded.\n");
      }
      return FALSE;
   }


   /*
    * The I830 is slightly different from the I830/I815, it has no
    * dcache and it has stolen memory by default in its gtt.  All
    * additional memory must go after it.
    */

   DPRINTF(PFX,
	   "size == %luk (%lu bytes == pScrn->videoRam)\n"
	   "pI830->StolenSize == %luk (%lu bytes)\n",
	   pScrn->videoRam, pScrn->videoRam * 1024,
	   pI830->StolenPool.Free.Size / 1024,
	   pI830->StolenPool.Free.Size);

   if (flags & ALLOC_INITIAL) {
      unsigned long minspace, avail, lineSize;
      int cacheLines, maxCacheLines;

      if (pI830->NeedRingBufferLow)
	 AllocateRingBuffer(pScrn, flags | FORCE_LOW);

      /* Unfortunately this doesn't run on the DRY_RUN pass because our
       * second head hasn't been created yet..... */
      if (pI830->entityPrivate && pI830->entityPrivate->pScrn_2) {
         I830EntPtr pI830Ent = pI830->entityPrivate;
         I830Ptr pI8302 = I830PTR(pI830Ent->pScrn_2);

         /* Clear everything first. */
         memset(&(pI830->FbMemBox2), 0, sizeof(pI830->FbMemBox2));
         memset(&(pI830->FrontBuffer2), 0, sizeof(pI830->FrontBuffer2));
         pI830->FrontBuffer2.Key = -1;

#if 1 /* ROTATION */
         pI830->FbMemBox2.x1 = 0;
         pI830->FbMemBox2.x2 = pI830Ent->pScrn_2->displayWidth;
         pI830->FbMemBox2.y1 = 0;
         if (pI830Ent->pScrn_2->virtualX > pI830Ent->pScrn_2->virtualY)
            pI830->FbMemBox2.y2 = pI830Ent->pScrn_2->virtualX;
         else
            pI830->FbMemBox2.y2 = pI830Ent->pScrn_2->virtualY;
#else
         pI830->FbMemBox2.x1 = 0;
         pI830->FbMemBox2.x2 = pI830Ent->pScrn_2->displayWidth;
         pI830->FbMemBox2.y1 = 0;
         pI830->FbMemBox2.y2 = pI830Ent->pScrn_2->virtualY;
#endif
d709 1
a709 40
         /*
          * Calculate how much framebuffer memory to allocate.  For the
          * initial allocation, calculate a reasonable minimum.  This is
          * enough for the virtual screen size, plus some pixmap cache
          * space.
          */

         lineSize = pI830Ent->pScrn_2->displayWidth * pI8302->cpp;
         minspace = lineSize * pI830Ent->pScrn_2->virtualY;
         avail = pI830Ent->pScrn_2->videoRam * 1024;
         maxCacheLines = (avail - minspace) / lineSize;
         /* This shouldn't happen. */
         if (maxCacheLines < 0) {
	    xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
		    "Internal Error: "
		    "maxCacheLines < 0 in I830Allocate2DMemory()\n");
	    maxCacheLines = 0;
         }
         if (maxCacheLines > (MAX_DISPLAY_HEIGHT - pI830Ent->pScrn_2->virtualY))
	    maxCacheLines = MAX_DISPLAY_HEIGHT - pI830Ent->pScrn_2->virtualY;

         if (pI8302->CacheLines >= 0) {
	    cacheLines = pI8302->CacheLines;
         } else {
#if 1
	    /* Make sure there is enough for two DVD sized YUV buffers */
	    cacheLines = (pI830Ent->pScrn_2->depth == 24) ? 256 : 384;
	    if (pI830Ent->pScrn_2->displayWidth <= 1024)
	       cacheLines *= 2;
#else
	    /*
	     * Make sure there is enough for two DVD sized YUV buffers.
	     * Make that 1.5MB, which is around what was allocated with
	     * the old algorithm
	     */
	    cacheLines = (MB(1) + KB(512)) / pI8302->cpp / pI830Ent->pScrn_2->displayWidth;
#endif
         }
         if (cacheLines > maxCacheLines)
	    cacheLines = maxCacheLines;
d711 2
a712 1
         pI830->FbMemBox2.y2 += cacheLines;
d714 87
a800 62
         xf86DrvMsgVerb(pScrn->scrnIndex, X_INFO, verbosity,
		     "%sAllocating at least %d scanlines for pixmap cache\n",
		     s, cacheLines);

         tileable = !(flags & ALLOC_NO_TILING) && pI8302->allowPageFlip &&
		 IsTileable(pI830Ent->pScrn_2->displayWidth * pI8302->cpp);
         if (tileable) {
            if (IS_I9XX(pI830))
               align = MB(1);
            else
	       align = KB(512);
	    alignflags = ALIGN_BOTH_ENDS;
         } else {
	    align = KB(64);
	    alignflags = 0;
         }

#if 1 /* ROTATION */
         if (pI830Ent->pScrn_2->virtualX > pI830Ent->pScrn_2->virtualY)
            size = lineSize * (pI830Ent->pScrn_2->virtualX + cacheLines);
         else 
            size = lineSize * (pI830Ent->pScrn_2->virtualY + cacheLines);
         size = ROUND_TO_PAGE(size);
#else
         size = lineSize * (pI830Ent->pScrn_2->virtualY + cacheLines);
         size = ROUND_TO_PAGE(size);
#endif
         xf86DrvMsgVerb(pScrn->scrnIndex, X_INFO, verbosity,
		     "%sSecondary framebuffer allocation size: %ld kByte\n", s,
		     size / 1024);
         alloced = I830AllocVidMem(pScrn, &(pI830->FrontBuffer2),
				&(pI830->StolenPool), size, align,
				flags | alignflags |
				FROM_ANYWHERE | ALLOCATE_AT_BOTTOM);
         if (alloced < size) {
	    if (!dryrun) {
	       xf86DrvMsg(pI830Ent->pScrn_2->scrnIndex, X_ERROR,
		       "Failed to allocate secondary framebuffer.\n");
	    }
            return FALSE;
         }
      }

      /* Clear everything first. */
      memset(&(pI830->FbMemBox), 0, sizeof(pI830->FbMemBox));
      memset(&(pI830->FrontBuffer), 0, sizeof(pI830->FrontBuffer));
      pI830->FrontBuffer.Key = -1;

#if 1 /* ROTATION */
      pI830->FbMemBox.x1 = 0;
      pI830->FbMemBox.x2 = pScrn->displayWidth;
      pI830->FbMemBox.y1 = 0;
      if (!pI830->MergedFB && pScrn->virtualX > pScrn->virtualY)
         pI830->FbMemBox.y2 = pScrn->virtualX;
      else
         pI830->FbMemBox.y2 = pScrn->virtualY;
#else
      pI830->FbMemBox.x1 = 0;
      pI830->FbMemBox.x2 = pScrn->displayWidth;
      pI830->FbMemBox.y1 = 0;
      pI830->FbMemBox.y2 = pScrn->virtualY;
#endif
d802 3
a804 178
      /*
       * Calculate how much framebuffer memory to allocate.  For the
       * initial allocation, calculate a reasonable minimum.  This is
       * enough for the virtual screen size, plus some pixmap cache
       * space.
       */

      lineSize = pScrn->displayWidth * pI830->cpp;
      minspace = lineSize * pScrn->virtualY;
      avail = pScrn->videoRam * 1024;
      maxCacheLines = (avail - minspace) / lineSize;
      /* This shouldn't happen. */
      if (maxCacheLines < 0) {
	 xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
		    "Internal Error: "
		    "maxCacheLines < 0 in I830Allocate2DMemory()\n");
	 maxCacheLines = 0;
      }
      if (maxCacheLines > (MAX_DISPLAY_HEIGHT - pScrn->virtualY))
	 maxCacheLines = MAX_DISPLAY_HEIGHT - pScrn->virtualY;

      if (pI830->CacheLines >= 0) {
	 cacheLines = pI830->CacheLines;
      } else {
#if 1
	 /* Make sure there is enough for two DVD sized YUV buffers */
	 cacheLines = (pScrn->depth == 24) ? 256 : 384;
	 if (pScrn->displayWidth <= 1024)
	    cacheLines *= 2;
#else
	 /*
	  * Make sure there is enough for two DVD sized YUV buffers.
	  * Make that 1.5MB, which is around what was allocated with
	  * the old algorithm
	  */
	 cacheLines = (MB(1) + KB(512)) / pI830->cpp / pScrn->displayWidth;
#endif
      }
      if (cacheLines > maxCacheLines)
	 cacheLines = maxCacheLines;

      pI830->FbMemBox.y2 += cacheLines;

      xf86DrvMsgVerb(pScrn->scrnIndex, X_INFO, verbosity,
		     "%sAllocating at least %d scanlines for pixmap cache\n",
		     s, cacheLines);

      tileable = !(flags & ALLOC_NO_TILING) && pI830->allowPageFlip &&
		 IsTileable(pScrn->displayWidth * pI830->cpp);
      if (tileable) {
         if (IS_I9XX(pI830))
            align = MB(1);
         else
	    align = KB(512);
	 alignflags = ALIGN_BOTH_ENDS;
      } else {
	 align = KB(64);
	 alignflags = 0;
      }

#if 1 /* ROTATION */
      if (!pI830->MergedFB && pScrn->virtualX > pScrn->virtualY)
         size = lineSize * (pScrn->virtualX + cacheLines);
      else 
         size = lineSize * (pScrn->virtualY + cacheLines);
      size = ROUND_TO_PAGE(size);
#else
      size = lineSize * (pScrn->virtualY + cacheLines);
      size = ROUND_TO_PAGE(size);
#endif
      xf86DrvMsgVerb(pScrn->scrnIndex, X_INFO, verbosity,
		     "%sInitial framebuffer allocation size: %ld kByte\n", s,
		     size / 1024);
      alloced = I830AllocVidMem(pScrn, &(pI830->FrontBuffer),
				&(pI830->StolenPool), size, align,
				flags | alignflags |
				FROM_ANYWHERE | ALLOCATE_AT_BOTTOM);
      if (alloced < size) {
	 if (!dryrun) {
	    xf86DrvMsg(pScrn->scrnIndex, X_ERROR, "Failed to allocate "
	    		"framebuffer. Is your VideoRAM set too low ??\n");
	 }
	 return FALSE;
      }
   } else {
      long lineSize;
      long extra = 0;
      long maxFb = 0;

      /*
       * XXX Need to "free" up any 3D allocations if the DRI ended up
       * and make them available for 2D.  The best way to do this would
       * be position all of those regions contiguously at the end of the
       * StolenPool.
       */
      extra = GetFreeSpace(pScrn);

      if (extra == 0)
	 return TRUE;

      maxFb = pI830->FrontBuffer.Size + extra;
      lineSize = pScrn->displayWidth * pI830->cpp;
      maxFb = ROUND_DOWN_TO(maxFb, lineSize);
      if (maxFb > lineSize * MAX_DISPLAY_HEIGHT)
	 maxFb = lineSize * MAX_DISPLAY_HEIGHT;
      if (0/*maxFb > pI830->FrontBuffer.Size*/) {
	 unsigned long oldsize;
	 /*
	  * Sanity check -- the fb should be the last thing allocated at
	  * the bottom of the stolen pool.
	  */
	 if (pI830->StolenPool.Free.Start != pI830->FrontBuffer.End) {
	    xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
		       "Internal error in I830Allocate2DMemory():\n\t"
		       "Framebuffer isn't the last allocation at the bottom"
		       " of StolenPool\n\t(%lx != %lx).\n",
		       pI830->FrontBuffer.End,
		       pI830->StolenPool.Free.Start);
	    return FALSE;
	 }
	 /*
	  * XXX Maybe should have a "Free" function.  This should be
	  * the only place where a region is resized, and we know that
	  * the fb is always at the bottom of the aperture/stolen pool,
	  * and is the only region that is allocated bottom-up.
	  * Allowing for more general realloction would require a smarter
	  * allocation system.
	  */
	 oldsize = pI830->FrontBuffer.Size;
	 pI830->StolenPool.Free.Size += pI830->FrontBuffer.Size;
	 pI830->StolenPool.Free.Start -= pI830->FrontBuffer.Size;
	 xf86DrvMsgVerb(pScrn->scrnIndex, X_INFO, verbosity,
			"%sUpdated framebuffer allocation size from %ld "
			"to %ld kByte\n", s, oldsize / 1024, maxFb / 1024);
	 xf86DrvMsgVerb(pScrn->scrnIndex, X_INFO, verbosity,
			"%sUpdated pixmap cache from %ld scanlines to %ld "
			"scanlines\n", s,
			oldsize / lineSize - pScrn->virtualY,
			maxFb / lineSize - pScrn->virtualY);
	 pI830->FbMemBox.y2 = maxFb / lineSize;
	 tileable = !(flags & ALLOC_NO_TILING) && pI830->allowPageFlip &&
		 IsTileable(pScrn->displayWidth * pI830->cpp);
	 if (tileable) {
            if (IS_I9XX(pI830))
               align = MB(1);
            else
	       align = KB(512);
	    alignflags = ALIGN_BOTH_ENDS;
	 } else {
	    align = KB(64);
	    alignflags = 0;
	 }
	 alloced = I830AllocVidMem(pScrn, &(pI830->FrontBuffer),
				   &(pI830->StolenPool), maxFb, align,
				   flags | alignflags |
				   FROM_ANYWHERE | ALLOCATE_AT_BOTTOM);
	 if (alloced < maxFb) {
	    if (!dryrun) {
	       xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
			  "Failed to re-allocate framebuffer\n");
	    }
	    return FALSE;
	 }
      }
      return TRUE;
   }

#if REMAP_RESERVED
   /*
    * Allocate a dummy page to pass when attempting to rebind the
    * pre-allocated region.
    */
   if (!dryrun) {
      memset(&(pI830->Dummy), 0, sizeof(pI830->Dummy));
      pI830->Dummy.Key = xf86AllocateGARTMemory(pScrn->scrnIndex, size, 0, NULL);
      pI830->Dummy.Offset = 0;
   }
#endif
d806 43
a848 58
   /* Clear cursor info */
   memset(pI830->CursorMem, 0, sizeof(I830MemRange));
   pI830->CursorMem->Key = -1;
   memset(pI830->CursorMemARGB, 0, sizeof(I830MemRange));
   pI830->CursorMemARGB->Key = -1;

   if (!pI830->SWCursor) {
      int cursFlags = 0;
      /*
       * Mouse cursor -- The i810-i830 need a physical address in system
       * memory from which to upload the cursor.  We get this from
       * the agpgart module using a special memory type.
       */

      size = HWCURSOR_SIZE;
      cursFlags = FROM_ANYWHERE | ALLOCATE_AT_TOP;
      if (pI830->CursorNeedsPhysical)
	 cursFlags |= NEED_PHYSICAL_ADDR;

      alloced = I830AllocVidMem(pScrn, pI830->CursorMem,
				&(pI830->StolenPool), size,
				GTT_PAGE_SIZE, flags | cursFlags);
      if (alloced < size) {
	 if (!dryrun) {
	    xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
		       "Failed to allocate HW cursor space.\n");
	 }
      } else {
	 xf86DrvMsgVerb(pScrn->scrnIndex, X_INFO, verbosity,
			"%sAllocated %ld kB for HW cursor at 0x%lx", s,
			alloced / 1024, pI830->CursorMem->Start);
	 if (pI830->CursorNeedsPhysical)
	    xf86ErrorFVerb(verbosity, " (0x%08lx)", pI830->CursorMem->Physical);
	 xf86ErrorFVerb(verbosity, "\n");
      }

      size = HWCURSOR_SIZE_ARGB;
      cursFlags = FROM_ANYWHERE | ALLOCATE_AT_TOP;
      if (pI830->CursorNeedsPhysical)
	 cursFlags |= NEED_PHYSICAL_ADDR;

      alloced = I830AllocVidMem(pScrn, pI830->CursorMemARGB,
				&(pI830->StolenPool), size,
				GTT_PAGE_SIZE, flags | cursFlags);
      if (alloced < size) {
	 if (!dryrun) {
	    xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
		       "Failed to allocate HW (ARGB) cursor space.\n");
	 }
      } else {
	 xf86DrvMsgVerb(pScrn->scrnIndex, X_INFO, verbosity,
			"%sAllocated %ld kB for HW (ARGB) cursor at 0x%lx", s,
			alloced / 1024, pI830->CursorMemARGB->Start);
	 if (pI830->CursorNeedsPhysical)
	    xf86ErrorFVerb(verbosity, " (0x%08lx)", pI830->CursorMemARGB->Physical);
	 xf86ErrorFVerb(verbosity, "\n");
      }
   }
d850 1
a850 3
#ifdef I830_XV
   AllocateOverlay(pScrn, flags);
#endif
d852 2
a853 2
   if (!pI830->NeedRingBufferLow)
      AllocateRingBuffer(pScrn, flags);
d855 54
a908 56
   /* Clear scratch info */
   memset(&(pI830->Scratch), 0, sizeof(I830MemRange));
   pI830->Scratch.Key = -1;
   memset(&(pI830->Scratch2), 0, sizeof(I830MemRange));
   pI830->Scratch2.Key = -1;

   if (!pI830->noAccel) {
      size = MAX_SCRATCH_BUFFER_SIZE;
      alloced = I830AllocVidMem(pScrn, &(pI830->Scratch), &(pI830->StolenPool),
				size, GTT_PAGE_SIZE,
				flags | FROM_ANYWHERE | ALLOCATE_AT_TOP);
      if (alloced < size) {
	 size = MIN_SCRATCH_BUFFER_SIZE;
         alloced = I830AllocVidMem(pScrn, &(pI830->Scratch),
				   &(pI830->StolenPool), size,
				   GTT_PAGE_SIZE,
				   flags | FROM_ANYWHERE | ALLOCATE_AT_TOP);
      }
      if (alloced < size) {
	 if (!dryrun) {
	    xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
		       "Failed to allocate scratch buffer space\n");
	 }
	 return FALSE;
      }
      xf86DrvMsgVerb(pScrn->scrnIndex, X_INFO, verbosity,
		    "%sAllocated %ld kB for the scratch buffer at 0x%lx\n", s,
		    alloced / 1024, pI830->Scratch.Start);

      /* Let's allocate another scratch buffer for the second head */
      /* Again, this code won't execute on the dry run pass */
      if (pI830->entityPrivate && pI830->entityPrivate->pScrn_2) {
         size = MAX_SCRATCH_BUFFER_SIZE;
         alloced = I830AllocVidMem(pScrn, &(pI830->Scratch2), 
				&(pI830->StolenPool),
				size, GTT_PAGE_SIZE,
				flags | FROM_ANYWHERE | ALLOCATE_AT_TOP);
         if (alloced < size) {
	    size = MIN_SCRATCH_BUFFER_SIZE;
            alloced = I830AllocVidMem(pScrn, &(pI830->Scratch2),
				   &(pI830->StolenPool), size,
				   GTT_PAGE_SIZE,
				   flags | FROM_ANYWHERE | ALLOCATE_AT_TOP);
         }
         if (alloced < size) {
	    if (!dryrun) {
	       xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
		       "Failed to allocate second scratch buffer space\n");
	    }
	    return FALSE;
         }
         xf86DrvMsgVerb(pScrn->scrnIndex, X_INFO, verbosity,
	      "%sAllocated %ld kB for the second scratch buffer at 0x%lx\n", s,
	      alloced / 1024, pI830->Scratch2.Start);
      }
   }
d910 1
a910 1
   return TRUE;
d914 1
a914 1
I830ResetAllocations(ScrnInfoPtr pScrn, const int flags)
d916 2
a917 1
   I830Ptr pI830 = I830PTR(pScrn);
d919 75
a993 21
   pI830->MemoryAperture.Start = pI830->StolenMemory.End;
   pI830->MemoryAperture.End = pI830->FbMapSize;
   pI830->MemoryAperture.Size = pI830->FbMapSize - pI830->StolenMemory.Size;
#ifdef XF86DRI
   if (!pI830->directRenderingDisabled) {
      pI830->MemoryAperture.End -= KB(pI830->mmSize);
      pI830->MemoryAperture.Size -= KB(pI830->mmSize);
   }
#endif
   pI830->StolenPool.Fixed = pI830->StolenMemory;
   pI830->StolenPool.Total = pI830->StolenMemory;
#if ALLOCATE_ALL_BIOSMEM
   if (pI830->overrideBIOSMemSize &&
       pI830->BIOSMemorySize > pI830->StolenMemory.Size) {
      pI830->StolenPool.Total.End = pI830->BIOSMemorySize;
      pI830->StolenPool.Total.Size = pI830->BIOSMemorySize;
   }
#endif
   pI830->StolenPool.Free = pI830->StolenPool.Total;
   pI830->FreeMemory = pI830->TotalVideoRam - pI830->StolenPool.Total.Size;
   pI830->allocatedMemory = 0;
d996 2
a997 2
long
I830GetExcessMemoryAllocations(ScrnInfoPtr pScrn)
d999 1
a999 2
   I830Ptr pI830 = I830PTR(pScrn);
   long allocated;
d1001 2
a1002 6
   allocated = pI830->StolenPool.Total.Size + pI830->allocatedMemory;
   if (allocated > pI830->TotalVideoRam)
      return allocated - pI830->TotalVideoRam;
   else
      return 0;
}
d1004 12
a1015 5
#ifdef XF86DRI
static unsigned int
myLog2(unsigned int n)
{
   unsigned int log2 = 1;
d1017 2
a1018 5
   while (n > 1) {
      n >>= 1;
      log2++;
   }
   return log2;
d1021 7
a1027 2
Bool
I830AllocateBackBuffer(ScrnInfoPtr pScrn, const int flags)
d1029 20
a1048 56
   I830Ptr pI830 = I830PTR(pScrn);
   unsigned long size, alloced, align = 0;
   Bool tileable;
   Bool dryrun = ((flags & ALLOCATE_DRY_RUN) != 0);
   int verbosity = dryrun ? 4 : 1;
   const char *s = dryrun ? "[dryrun] " : "";
   int lines;
   int height = (pI830->rotation & (RR_Rotate_0 | RR_Rotate_180)) ? pScrn->virtualY : pScrn->virtualX;

   /* Back Buffer */
   memset(&(pI830->BackBuffer), 0, sizeof(pI830->BackBuffer));
   pI830->BackBuffer.Key = -1;
   tileable = !(flags & ALLOC_NO_TILING) &&
	      IsTileable(pScrn->displayWidth * pI830->cpp);
   if (tileable) {
      /* Make the height a multiple of the tile height (16) */
      lines = (height + 15) / 16 * 16;
   } else {
      lines = height;
   }

   size = ROUND_TO_PAGE(pScrn->displayWidth * lines * pI830->cpp);
   /*
    * Try to allocate on the best tile-friendly boundaries.
    */
   alloced = 0;
   if (tileable) {
      align = GetBestTileAlignment(size);
      for (align = GetBestTileAlignment(size); align >= (IS_I9XX(pI830) ? MB(1) : KB(512)); align >>= 1) {
	 alloced = I830AllocVidMem(pScrn, &(pI830->BackBuffer),
				   &(pI830->StolenPool), size, align,
				   flags | FROM_ANYWHERE | ALLOCATE_AT_TOP |
				   ALIGN_BOTH_ENDS);
	 if (alloced >= size)
	    break;
      }
   }
   if (alloced < size) {
      /* Give up on trying to tile */
      tileable = FALSE;
      size = ROUND_TO_PAGE(pScrn->displayWidth * height * pI830->cpp);
      align = GTT_PAGE_SIZE;
      alloced = I830AllocVidMem(pScrn, &(pI830->BackBuffer),
				&(pI830->StolenPool), size, align,
				flags | FROM_ANYWHERE | ALLOCATE_AT_TOP);
   }
   if (alloced < size) {
      if (!dryrun) {
	 xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
		    "Failed to allocate back buffer space.\n");
      }
      return FALSE;
   }
   xf86DrvMsgVerb(pScrn->scrnIndex, X_INFO, verbosity,
		  "%sAllocated %ld kB for the back buffer at 0x%lx.\n", s,
		  alloced / 1024, pI830->BackBuffer.Start);
d1050 1
a1050 1
   return TRUE;
d1052 1
d1054 2
a1055 2
Bool
I830AllocateDepthBuffer(ScrnInfoPtr pScrn, const int flags)
d1057 1
a1057 56
   I830Ptr pI830 = I830PTR(pScrn);
   unsigned long size, alloced, align = 0;
   Bool tileable;
   Bool dryrun = ((flags & ALLOCATE_DRY_RUN) != 0);
   int verbosity = dryrun ? 4 : 1;
   const char *s = dryrun ? "[dryrun] " : "";
   int lines;
   int height = (pI830->rotation & (RR_Rotate_0 | RR_Rotate_180)) ? pScrn->virtualY : pScrn->virtualX;

   /* Depth Buffer -- same size as the back buffer */
   memset(&(pI830->DepthBuffer), 0, sizeof(pI830->DepthBuffer));
   pI830->DepthBuffer.Key = -1;
   tileable = !(flags & ALLOC_NO_TILING) &&
	      IsTileable(pScrn->displayWidth * pI830->cpp);
   if (tileable) {
      /* Make the height a multiple of the tile height (16) */
      lines = (height + 15) / 16 * 16;
   } else {
      lines = height;
   }

   size = ROUND_TO_PAGE(pScrn->displayWidth * lines * pI830->cpp);
   /*
    * Try to allocate on the best tile-friendly boundaries.
    */
   alloced = 0;
   if (tileable) {
      align = GetBestTileAlignment(size);
      for (align = GetBestTileAlignment(size); align >= (IS_I9XX(pI830) ? MB(1) : KB(512)); align >>= 1) {
	 alloced = I830AllocVidMem(pScrn, &(pI830->DepthBuffer),
				   &(pI830->StolenPool), size, align,
				   flags | FROM_ANYWHERE | ALLOCATE_AT_TOP |
				   ALIGN_BOTH_ENDS);
	 if (alloced >= size)
	    break;
      }
   }
   if (alloced < size) {
      /* Give up on trying to tile */
      tileable = FALSE;
      size = ROUND_TO_PAGE(pScrn->displayWidth * height * pI830->cpp);
      align = GTT_PAGE_SIZE;
      alloced = I830AllocVidMem(pScrn, &(pI830->DepthBuffer),
				&(pI830->StolenPool), size, align,
				flags | FROM_ANYWHERE | ALLOCATE_AT_TOP);
   }
   if (alloced < size) {
      if (!dryrun) {
	 xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
		    "Failed to allocate depth buffer space.\n");
      }
      return FALSE;
   }
   xf86DrvMsgVerb(pScrn->scrnIndex, X_INFO, verbosity,
		  "%sAllocated %ld kB for the depth buffer at 0x%lx.\n", s,
		  alloced / 1024, pI830->DepthBuffer.Start);
d1059 35
a1093 2
   return TRUE;
}
d1095 54
a1148 28
Bool
I830AllocateTextureMemory(ScrnInfoPtr pScrn, const int flags)
{
   I830Ptr pI830 = I830PTR(pScrn);
   unsigned long size, alloced;
   int i;
   Bool dryrun = ((flags & ALLOCATE_DRY_RUN) != 0);
   int verbosity = dryrun ? 4 : 1;
   const char *s = dryrun ? "[dryrun] " : "";

   /* Allocate the remaining space for textures. */
   memset(&(pI830->TexMem), 0, sizeof(pI830->TexMem));
   pI830->TexMem.Key = -1;

   if (pI830->mmModeFlags & I830_KERNEL_TEX) {

      size = GetFreeSpace(pScrn);
      if (dryrun && (size < MB(1)))
	 size = MB(1);
      i = myLog2(size / I830_NR_TEX_REGIONS);
      if (i < I830_LOG_MIN_TEX_REGION_SIZE)
	 i = I830_LOG_MIN_TEX_REGION_SIZE;
      pI830->TexGranularity = i;
      /* Truncate size */
      size >>= i;
      size <<= i;
      if (size < KB(512)) {
	 if (!dryrun) {
d1150 21
a1170 19
		       "Less than 512 kBytes for texture space (real %ld kBytes).\n", 
		       size / 1024);
	 }
	 return FALSE;
      }
      alloced = I830AllocVidMem(pScrn, &(pI830->TexMem),
				&(pI830->StolenPool), size, GTT_PAGE_SIZE,
				flags | FROM_ANYWHERE | ALLOCATE_AT_TOP);
      if (alloced < size) {
	 if (!dryrun) {
	    xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
		       "Failed to allocate texture space.\n");
	 }
	 return FALSE;
      }
      xf86DrvMsgVerb(pScrn->scrnIndex, X_INFO, verbosity,
		     "%sAllocated %ld kB for textures at 0x%lx\n", s,
		     alloced / 1024, pI830->TexMem.Start);
   }
d1172 51
a1222 1
   return TRUE;
d1225 104
d1330 1
a1330 1
I830Allocate3DMemory(ScrnInfoPtr pScrn, const int flags)
d1332 48
a1379 28
   I830Ptr pI830 = I830PTR(pScrn);
   unsigned long size, alloced;
   Bool dryrun = ((flags & ALLOCATE_DRY_RUN) != 0);
   int verbosity = dryrun ? 4 : 1;
   const char *s = dryrun ? "[dryrun] " : "";

   DPRINTF(PFX, "I830Allocate3DMemory\n");

   /* Space for logical context.  32k is fine for right now. */
   memset(&(pI830->ContextMem), 0, sizeof(pI830->ContextMem));
   pI830->ContextMem.Key = -1;
   size = KB(32);
   alloced = I830AllocVidMem(pScrn, &(pI830->ContextMem),
			     &(pI830->StolenPool), size, GTT_PAGE_SIZE,
			     flags | FROM_ANYWHERE | ALLOCATE_AT_TOP);
   if (alloced < size) {
      if (!dryrun) {
	 xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
		    "Failed to allocate logical context space.\n");
      }
      return FALSE;
   }
   xf86DrvMsgVerb(pScrn->scrnIndex, X_INFO, verbosity,
		  "%sAllocated %ld kB for the logical context at 0x%lx.\n", s,
		  alloced / 1024, pI830->ContextMem.Start);

   if (!I830AllocateBackBuffer(pScrn, flags))
      return FALSE;
d1381 35
a1415 2
   if (!I830AllocateDepthBuffer(pScrn, flags))
      return FALSE;
d1417 35
a1451 2
   if (!I830AllocateTextureMemory(pScrn, flags))
      return FALSE;
d1453 24
a1476 1
   return TRUE;
a1477 1
#endif
d1479 3
a1481 3
/* Allocate pool space that isn't pre-allocated */
Bool
I830DoPoolAllocation(ScrnInfoPtr pScrn, I830MemPool *pool)
d1483 1
a1483 1
   I830Ptr pI830 = I830PTR(pScrn);
d1485 6
a1490 1
   DPRINTF(PFX, "I830DoPoolAllocation\n");
d1492 40
a1531 2
   if (!pool)
      return FALSE;
d1533 1
a1533 26
   /*
    * Sanity check: there shouldn't be an allocation required when
    * there is only stolen memory.
    */
   if (pI830->StolenOnly && (pool->Total.Size > pool->Fixed.Size)) {
      xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
		 "I830DoPoolAllocation(): pool size is greater than the "
		 "preallocated size,\n\t"
		 "and there is no allocatable memory.\n");
      return FALSE;
   }

   if (pool->Total.Size > pool->Fixed.Size) {
      pool->Allocated.Size = pool->Total.Size - pool->Fixed.Size;
      pool->Allocated.Key = xf86AllocateGARTMemory(pScrn->scrnIndex, 
				   pool->Allocated.Size, 0, NULL);
      if (pool->Allocated.Key == -1) {
	 xf86DrvMsg(pScrn->scrnIndex, X_ERROR, "Pool allocation failed\n");
	 return FALSE;
      }
      pool->Allocated.Start = pool->Fixed.End;
      pool->Allocated.End = pool->Total.Size;
      pool->Allocated.Offset = pool->Allocated.Start;
   } else
      pool->Allocated.Key = -1;
   return TRUE;
d1536 49
a1584 1
static unsigned long topOfMem = 0;
d1586 2
a1587 18
/*
 * These modify the way memory is positioned within the aperture.
 *
 * By default, memory allocated from the bottom or specifically within
 * the pool at the bottom gets allocated from the "stolen pool", which is
 * actually the stolen memory plus any extra allocated to make it a larger
 * contiguous region.  Memory allocated from the AGP is allocated top-down
 * from the end of the aperture space.  Memory allocated "from top" defaults
 * to AGP if there is enough "free space".  The total allocation (stolen +
 * extra) doesn't exceed the orignal pScrn->videoRam amount (this isn't true
 * when memory allocated from AGP gets moved into the pool by one of the
 * following options.
 *
 * XXX Write a better description.
 *
 */
#define PACK_RANGES 0
#define POOL_RANGES 0
d1590 1
a1590 1
I830FixOffset(ScrnInfoPtr pScrn, I830MemRange *mem)
d1592 37
a1628 3
#if POOL_RANGES
   I830Ptr pI830 = I830PTR(pScrn);
#endif
d1630 4
a1633 2
   if (!mem)
      return FALSE;
d1635 12
a1646 50
   if (mem->Pool && mem->Key == -1 && mem->Start < 0) {
      mem->Start = mem->Pool->Total.End + mem->Start;
      mem->End = mem->Start + mem->Size;
   }
#if PACK_RANGES
   /*
    * Map AGP-allocated areas at the top of the stolen area, resulting in
    * a contiguous region in the aperture.  Normally most AGP-allocated areas
    * will be at the top of the aperture, making alignment requirements
    * easier to achieve.  This optin is primarily for debugging purposes,
    * and using this option can break any special alignment requirements.
    */
   if (!mem->Pool && mem->Start != 0 && mem->Key != -1 && mem->Physical == 0 &&
	mem->Offset != 0) {
      long diff;
      if (mem->Offset != mem->Start)
	 ErrorF("mem %p, Offset != Start\n", mem);
      diff = mem->Offset - topOfMem;
      mem->Start -= diff;
      mem->End -= diff;
      mem->Offset -= diff;
      topOfMem += mem->Size;
   }
#elif POOL_RANGES
   /*
    * Move AGP-allocated regions (that don't need a physical address) into
    * the pre-allocated pool when there's enough space to do so.  Note: the
    * AGP-allocated areas aren't freed.  This option is primarily for
    * debugging purposes, and using it can break any special alignment
    * requirements.
    */
   if (!mem->Pool && mem->Start >= pI830->StolenPool.Free.End &&
       mem->Key != -1 && mem->Physical == 0 && mem->Offset != 0 &&
       pI830->StolenPool.Free.Size >= mem->Size) {
      long diff;
      if (mem->Offset != mem->Start)
	 ErrorF("mem %p, Offset != Start\n", mem);
      diff = mem->Offset - pI830->StolenPool.Free.Start;
      mem->Start -= diff;
      mem->End -= diff;
      mem->Offset -= diff;
      mem->Key = -1;
      pI830->StolenPool.Free.Start += mem->Size;
      pI830->StolenPool.Free.Size -= mem->Size;
   }
#endif
   xf86DrvMsg(pScrn->scrnIndex, X_INFO,
	      "%p: Memory at offset 0x%08lx, size %ld kBytes\n", (void *)mem,
	      mem->Start, mem->Size / 1024);
   return TRUE;
d1650 1
a1650 1
I830FixupOffsets(ScrnInfoPtr pScrn)
d1652 3
a1654 1
   I830Ptr pI830 = I830PTR(pScrn);
d1656 4
a1659 1
   DPRINTF(PFX, "I830FixupOffsets\n");
d1661 2
a1662 29
   topOfMem = pI830->StolenPool.Total.End;
   if (pI830->entityPrivate && pI830->entityPrivate->pScrn_2)
      I830FixOffset(pScrn, &(pI830->FrontBuffer2));
   I830FixOffset(pScrn, &(pI830->FrontBuffer));
   I830FixOffset(pScrn, pI830->CursorMem);
   I830FixOffset(pScrn, pI830->CursorMemARGB);
   I830FixOffset(pScrn, &(pI830->LpRing->mem));
   I830FixOffset(pScrn, &(pI830->Scratch));
   if (pI830->entityPrivate && pI830->entityPrivate->pScrn_2)
      I830FixOffset(pScrn, &(pI830->Scratch2));
#ifdef I830_XV
   if (pI830->XvEnabled) {
      I830FixOffset(pScrn, pI830->OverlayMem);
      if (pI830->LinearAlloc)
         I830FixOffset(pScrn, &(pI830->LinearMem));
   }
#endif
#ifdef XF86DRI
   if (pI830->directRenderingEnabled) {
      I830FixOffset(pScrn, &(pI830->ContextMem));
      I830FixOffset(pScrn, &(pI830->BackBuffer));
      I830FixOffset(pScrn, &(pI830->DepthBuffer));
      if (pI830->mmModeFlags & I830_KERNEL_TEX) {
	 I830FixOffset(pScrn, &(pI830->TexMem));
      }
   }
#endif
   return TRUE;
}
d1664 7
a1670 150
#ifdef XF86DRI
/* Tiled memory is good... really, really good...
 *
 * Need to make it less likely that we miss out on this - probably
 * need to move the frontbuffer away from the 'guarenteed' alignment
 * of the first memory segment, or perhaps allocate a discontigous
 * framebuffer to get more alignment 'sweet spots'.
 */
static void
SetFence(ScrnInfoPtr pScrn, int nr, unsigned int start, unsigned int pitch,
         unsigned int size)
{
   I830Ptr pI830 = I830PTR(pScrn);
   I830RegPtr i830Reg = &pI830->ModeReg;
   CARD32 val;
   CARD32 fence_mask = 0;
   unsigned int fence_pitch;

   DPRINTF(PFX, "SetFence: %d, 0x%08x, %d, %d kByte\n",
	   nr, start, pitch, size / 1024);

   if (nr < 0 || nr > 7) {
      xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
		 "SetFence: fence %d out of range\n",nr);
      return;
   }

   i830Reg->Fence[nr] = 0;

   if (IS_I9XX(pI830))
   	fence_mask = ~I915G_FENCE_START_MASK;
   else
   	fence_mask = ~I830_FENCE_START_MASK;

   if (start & fence_mask) {
      xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
		 "SetFence: %d: start (0x%08x) is not %s aligned\n",
		 nr, start, (IS_I9XX(pI830)) ? "1MB" : "512k");
      return;
   }

   if (start % size) {
      xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
		 "SetFence: %d: start (0x%08x) is not size (%dk) aligned\n",
		 nr, start, size / 1024);
      return;
   }

   if (pitch & 127) {
      xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
		 "SetFence: %d: pitch (%d) not a multiple of 128 bytes\n",
		 nr, pitch);
      return;
   }

   val = (start | FENCE_X_MAJOR | FENCE_VALID);

   if (IS_I9XX(pI830)) {
   	switch (size) {
	   case MB(1):
      		val |= I915G_FENCE_SIZE_1M;
      		break;
   	   case MB(2):
      		val |= I915G_FENCE_SIZE_2M;
      		break;
   	   case MB(4):
      		val |= I915G_FENCE_SIZE_4M;
      		break;
   	   case MB(8):
      		val |= I915G_FENCE_SIZE_8M;
      		break;
   	   case MB(16):
      		val |= I915G_FENCE_SIZE_16M;
      		break;
   	   case MB(32):
      		val |= I915G_FENCE_SIZE_32M;
      		break;
   	   case MB(64):
      		val |= I915G_FENCE_SIZE_64M;
      		break;
   	   default:
      		xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
		 "SetFence: %d: illegal size (%d kByte)\n", nr, size / 1024);
      		return;
   	}
    } else {
   	switch (size) {
	   case KB(512):
      		val |= FENCE_SIZE_512K;
      		break;
	   case MB(1):
      		val |= FENCE_SIZE_1M;
      		break;
   	   case MB(2):
      		val |= FENCE_SIZE_2M;
      		break;
   	   case MB(4):
      		val |= FENCE_SIZE_4M;
      		break;
   	   case MB(8):
      		val |= FENCE_SIZE_8M;
      		break;
   	   case MB(16):
      		val |= FENCE_SIZE_16M;
      		break;
   	   case MB(32):
      		val |= FENCE_SIZE_32M;
      		break;
   	   case MB(64):
      		val |= FENCE_SIZE_64M;
      		break;
   	   default:
      		xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
		 "SetFence: %d: illegal size (%d kByte)\n", nr, size / 1024);
      		return;
   	}
   }

   if (IS_I9XX(pI830))
	fence_pitch = pitch / 512;
   else
	fence_pitch = pitch / 128;

   switch (fence_pitch) {
   case 1:
      val |= FENCE_PITCH_1;
      break;
   case 2:
      val |= FENCE_PITCH_2;
      break;
   case 4:
      val |= FENCE_PITCH_4;
      break;
   case 8:
      val |= FENCE_PITCH_8;
      break;
   case 16:
      val |= FENCE_PITCH_16;
      break;
   case 32:
      val |= FENCE_PITCH_32;
      break;
   case 64:
      val |= FENCE_PITCH_64;
      break;
   default:
      xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
		 "SetFence: %d: illegal pitch (%d)\n", nr, pitch);
      return;
   }
d1672 2
a1673 2
   i830Reg->Fence[nr] = val;
}
d1675 2
a1676 5
static Bool
MakeTiles(ScrnInfoPtr pScrn, I830MemRange *pMem, unsigned int fence)
{
   I830Ptr pI830 = I830PTR(pScrn);
   int pitch, ntiles, i;
d1678 2
a1679 5
#if 0
   /* Hack to "improve" the alignment of the front buffer.
    */
   while (!(pMem->Start & ~pMem->Alignment) && pMem->Alignment < 0x00400000 )
      pMem->Alignment <<= 1;
d1682 45
a1726 13
   if (tileGeneration != serverGeneration) {
      tileGeneration = serverGeneration;
      nextTile = 0;
   }

   pitch = pScrn->displayWidth * pI830->cpp;

   if (IS_I96X(pI830)) {
      I830RegPtr i830Reg = &pI830->ModeReg;

      switch (fence) {
         case FENCE_XMAJOR:
            i830Reg->Fence[nextTile] = (((pitch / 128) - 1) << 2) | pMem->Start | 1;
d1728 1
a1728 1
         case FENCE_YMAJOR:
d1732 2
a1733 2
            i830Reg->Fence[nextTile] = (((pitch / 128) - 1) << 2) | pMem->Start | 1;
	    i830Reg->Fence[nextTile] |= (1<<1);
d1735 104
a1838 4
         default:
         case FENCE_LINEAR:
            break;
      }
d1840 34
a1873 20
      i830Reg->Fence[nextTile+FENCE_NEW_NR] = pMem->End;
      nextTile++;
      return TRUE;
   }

   /*
    * Simply try to break the region up into at most four pieces of size
    * equal to the alignment.
    */
   ntiles = ROUND_TO(pMem->Size, pMem->Alignment) / pMem->Alignment;
   if (ntiles >= 4) {
      return FALSE;
   }

   for (i = 0; i < ntiles; i++, nextTile++) {
      SetFence(pScrn, nextTile, pMem->Start + i * pMem->Alignment,
	       pitch, pMem->Alignment);
   }
   return TRUE;
}
d1875 2
a1876 5
void
I830SetupMemoryTiling(ScrnInfoPtr pScrn)
{
   I830Ptr pI830 = I830PTR(pScrn);
   int i;
d1878 1
a1878 95
   /* Clear out */
   for (i = 0; i < 8; i++)
      pI830->ModeReg.Fence[i] = 0;

   nextTile = 0;
   tileGeneration = -1;

   /* We currently only attempt to tile the back and depth buffers. */
   if (!pI830->directRenderingEnabled)
      return;

   if (!IsTileable(pScrn->displayWidth * pI830->cpp)) {
      xf86DrvMsg(pScrn->scrnIndex, X_INFO,
		 "I830SetupMemoryTiling: Not tileable 0x%x\n",
		 pScrn->displayWidth * pI830->cpp);
      pI830->allowPageFlip = FALSE;
      return;
   }

   pI830->front_tiled = FENCE_LINEAR;
   pI830->back_tiled = FENCE_LINEAR;
   pI830->depth_tiled = FENCE_LINEAR;
   pI830->rotated_tiled = FENCE_LINEAR;
   pI830->rotated2_tiled = FENCE_LINEAR;

   if (pI830->allowPageFlip) {
      if (pI830->allowPageFlip && pI830->FrontBuffer.Alignment >= KB(512)) {
	 if (MakeTiles(pScrn, &(pI830->FrontBuffer), FENCE_XMAJOR)) {
	    xf86DrvMsg(pScrn->scrnIndex, X_INFO,
		       "Activating tiled memory for the front buffer\n");
            pI830->front_tiled = FENCE_XMAJOR;
	 } else {
	    pI830->allowPageFlip = FALSE;
	    xf86DrvMsg(pScrn->scrnIndex, X_INFO,
		       "MakeTiles failed for the front buffer\n");
	 }
      } else {
	 pI830->allowPageFlip = FALSE;
	 xf86DrvMsg(pScrn->scrnIndex, X_INFO,
		 "Alignment bad for the front buffer\n");
      }
   }

   /*
    * We tried to get the best alignment during the allocation.  Check
    * the alignment values to tell.  If well-aligned allocations were
    * successful, the address range reserved is a multiple of the align
    * value.
    */
   if (pI830->BackBuffer.Alignment >= KB(512)) {
      if (MakeTiles(pScrn, &(pI830->BackBuffer), FENCE_XMAJOR)) {
	 xf86DrvMsg(pScrn->scrnIndex, X_INFO,
		    "Activating tiled memory for the back buffer.\n");
         pI830->back_tiled = FENCE_XMAJOR;
      } else {
	 xf86DrvMsg(pScrn->scrnIndex, X_INFO,
		    "MakeTiles failed for the back buffer.\n");
	 pI830->allowPageFlip = FALSE;
      }
   }

   if (pI830->DepthBuffer.Alignment >= KB(512)) {
      if (MakeTiles(pScrn, &(pI830->DepthBuffer), FENCE_YMAJOR)) {
	 xf86DrvMsg(pScrn->scrnIndex, X_INFO,
	 	    "Activating tiled memory for the depth buffer.\n");
         pI830->depth_tiled = FENCE_YMAJOR;
      } else {
	 xf86DrvMsg(pScrn->scrnIndex, X_INFO,
		    "MakeTiles failed for the depth buffer.\n");
      }
   }
	
   if (pI830->RotatedMem.Alignment >= KB(512)) {
      if (MakeTiles(pScrn, &(pI830->RotatedMem), FENCE_XMAJOR)) {
	 xf86DrvMsg(pScrn->scrnIndex, X_INFO,
		    "Activating tiled memory for the rotated buffer.\n");
         pI830->rotated_tiled = FENCE_XMAJOR;
      } else {
	 xf86DrvMsg(pScrn->scrnIndex, X_INFO,
		    "MakeTiles failed for the rotated buffer.\n");
      }
   }

#if 0
   if (pI830->RotatedMem2.Alignment >= KB(512)) {
      if (MakeTiles(pScrn, &(pI830->RotatedMem2), FENCE_XMAJOR)) {
	 xf86DrvMsg(pScrn->scrnIndex, X_INFO,
		    "Activating tiled memory for the rotated2 buffer.\n");
         pI830->rotated2_tiled = FENCE_XMAJOR;
      } else {
	 xf86DrvMsg(pScrn->scrnIndex, X_INFO,
		    "MakeTiles failed for the rotated buffer.\n");
      }
   }
#endif
a1879 1
#endif /* XF86DRI */
d1881 2
a1882 2
static Bool
BindMemRange(ScrnInfoPtr pScrn, I830MemRange *mem)
d1884 1
a1884 2
   if (!mem)
      return FALSE;
d1886 7
a1892 4
   if (mem->Key == -1)
      return TRUE;

   return xf86BindGARTMemory(pScrn->scrnIndex, mem->Key, mem->Offset);
d1895 7
d1903 1
a1903 1
I830BindAGPMemory(ScrnInfoPtr pScrn)
d1905 1
a1905 1
   I830Ptr pI830 = I830PTR(pScrn);
d1907 2
a1908 3
   DPRINTF(PFX,
	   "I830BindAGPMemory: StolenOnly is %s, pI830->GttBound is %s\n",
	   BOOLTOSTRING(pI830->StolenOnly), BOOLTOSTRING(pI830->GttBound));
d1910 2
a1911 2
   if (pI830->StolenOnly == TRUE)
      return TRUE;
d1913 2
a1914 3
   if (xf86AgpGARTSupported() && !pI830->GttBound) {
      if (!xf86AcquireGART(pScrn->scrnIndex))
	 return FALSE;
d1916 1
a1916 4
#if REMAP_RESERVED
      /* Rebind the pre-allocated region. */
      BindMemRange(pScrn, &(pI830->Dummy));
#endif
d1918 13
a1930 46
      if (!BindMemRange(pScrn, &(pI830->StolenPool.Allocated)))
	 return FALSE;
      if (pI830->entityPrivate && pI830->entityPrivate->pScrn_2)
         if (!BindMemRange(pScrn, &(pI830->FrontBuffer2)))
	    return FALSE;
      if (!BindMemRange(pScrn, &(pI830->FrontBuffer)))
	 return FALSE;
      if (!BindMemRange(pScrn, pI830->CursorMem))
	 return FALSE;
      if (!BindMemRange(pScrn, pI830->CursorMemARGB))
	 return FALSE;
      if (!BindMemRange(pScrn, &(pI830->LpRing->mem)))
	 return FALSE;
      if (!BindMemRange(pScrn, &(pI830->Scratch)))
	 return FALSE;
      if (pI830->entityPrivate && pI830->entityPrivate->pScrn_2)
         if (!BindMemRange(pScrn, &(pI830->Scratch2)))
	    return FALSE;
#ifdef I830_XV
      if (pI830->XvEnabled) {
         if (!BindMemRange(pScrn, pI830->OverlayMem))
	    return FALSE;
         if (pI830->LinearAlloc)
            if (!BindMemRange(pScrn, &(pI830->LinearMem)))
	       return FALSE;
      }
#endif
      if (pI830->RotatedMem.Start)
         if (!BindMemRange(pScrn, &(pI830->RotatedMem)))
	    return FALSE;
      if (pI830->entityPrivate && pI830->entityPrivate->pScrn_2 &&
	  pI830->RotatedMem2.Start)
         if (!BindMemRange(pScrn, &(pI830->RotatedMem2)))
	    return FALSE;
#ifdef XF86DRI
      if (pI830->directRenderingEnabled) {
	 if (!BindMemRange(pScrn, &(pI830->ContextMem)))
	    return FALSE;
	 if (!BindMemRange(pScrn, &(pI830->BackBuffer)))
	    return FALSE;
	 if (!BindMemRange(pScrn, &(pI830->DepthBuffer)))
	    return FALSE;
	 if ((pI830->mmModeFlags & I830_KERNEL_TEX) && 
	     !BindMemRange(pScrn, &(pI830->TexMem)))
	    return FALSE;
      }
d1932 2
a1933 2
      pI830->GttBound = 1;
   }
d1935 1
a1935 1
   return TRUE;
d1938 1
a1938 13
static Bool
UnbindMemRange(ScrnInfoPtr pScrn, I830MemRange *mem)
{
   if (!mem)
      return FALSE;

   if (mem->Key == -1)
      return TRUE;

   return xf86UnbindGARTMemory(pScrn->scrnIndex, mem->Key);
}


d1940 1
a1940 1
I830UnbindAGPMemory(ScrnInfoPtr pScrn)
d1942 1
a1942 1
   I830Ptr pI830 = I830PTR(pScrn);
d1944 2
a1945 3
   DPRINTF(PFX,
	   "I830UnbindAGPMemory: StolenOnly is %s, pI830->GttBound is %s\n",
	   BOOLTOSTRING(pI830->StolenOnly), BOOLTOSTRING(pI830->GttBound));
d1947 17
a1963 4
   if (pI830->StolenOnly == TRUE)
      return TRUE;

   if (xf86AgpGARTSupported() && pI830->GttBound) {
d1965 1
a1965 4
#if REMAP_RESERVED
      /* "unbind" the pre-allocated region. */
      UnbindMemRange(pScrn, &(pI830->Dummy));
#endif
d1967 1
a1967 33
      if (!UnbindMemRange(pScrn, &(pI830->StolenPool.Allocated)))
	 return FALSE;
      if (pI830->entityPrivate && pI830->entityPrivate->pScrn_2)
         if (!UnbindMemRange(pScrn, &(pI830->FrontBuffer2)))
	    return FALSE;
      if (!UnbindMemRange(pScrn, &(pI830->FrontBuffer)))
	 return FALSE;
      if (!UnbindMemRange(pScrn, pI830->CursorMem))
	 return FALSE;
      if (!UnbindMemRange(pScrn, pI830->CursorMemARGB))
	 return FALSE;
      if (!UnbindMemRange(pScrn, &(pI830->LpRing->mem)))
	 return FALSE;
      if (!UnbindMemRange(pScrn, &(pI830->Scratch)))
	 return FALSE;
      if (pI830->entityPrivate && pI830->entityPrivate->pScrn_2)
         if (!UnbindMemRange(pScrn, &(pI830->Scratch2)))
	    return FALSE;
#ifdef I830_XV
      if (pI830->XvEnabled) {
         if (!UnbindMemRange(pScrn, pI830->OverlayMem))
	    return FALSE;
         if (pI830->LinearAlloc)
            if (!UnbindMemRange(pScrn, &(pI830->LinearMem)))
   	       return FALSE;
      }
#endif
      if (pI830->RotatedMem.Start)
         if (!UnbindMemRange(pScrn, &(pI830->RotatedMem)))
	    return FALSE;
      if (pI830->entityPrivate && pI830->entityPrivate->pScrn_2 &&
	  pI830->RotatedMem2.Start)
         if (!UnbindMemRange(pScrn, &(pI830->RotatedMem2)))
d1969 1
a1969 15
#ifdef XF86DRI
      if (pI830->directRenderingEnabled) {
	 if (!UnbindMemRange(pScrn, &(pI830->ContextMem)))
	    return FALSE;
	 if (!UnbindMemRange(pScrn, &(pI830->BackBuffer)))
	    return FALSE;
	 if (!UnbindMemRange(pScrn, &(pI830->DepthBuffer)))
	    return FALSE;
	 if ((pI830->mmModeFlags & I830_KERNEL_TEX) && 
	     !UnbindMemRange(pScrn, &(pI830->TexMem)))
	    return FALSE;
      }
#endif
      if (!xf86ReleaseGART(pScrn->scrnIndex))
	 return FALSE;
d1971 1
a1971 4
      pI830->GttBound = 0;
   }

   return TRUE;
d1974 4
d1981 2
a1982 2
   AgpInfoPtr agpinf;
   int maxPages;
d1984 9
a1992 9
   if (!xf86AgpGARTSupported() ||
       !xf86AcquireGART(pScrn->scrnIndex) ||
       (agpinf = xf86GetAGPInfo(pScrn->scrnIndex)) == NULL ||
       !xf86ReleaseGART(pScrn->scrnIndex))
      return -1;

   maxPages = agpinf->totalPages - agpinf->usedPages;
   xf86DrvMsgVerb(pScrn->scrnIndex, X_INFO, 2, "%s: %d kB available\n",
		  "I830CheckAvailableMemory", maxPages * 4);
d1994 1
a1994 1
   return maxPages * 4;
@


1.1
log
@Initial revision
@
text
@d1110 6
d1295 20
a1314 15
   size = GetFreeSpace(pScrn);
   if (dryrun && (size < MB(1)))
      size = MB(1);
   i = myLog2(size / I830_NR_TEX_REGIONS);
   if (i < I830_LOG_MIN_TEX_REGION_SIZE)
      i = I830_LOG_MIN_TEX_REGION_SIZE;
   pI830->TexGranularity = i;
   /* Truncate size */
   size >>= i;
   size <<= i;
   if (size < KB(512)) {
      if (!dryrun) {
	 xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
		"Less than 512 kBytes for texture space (real %ld kBytes).\n", 
		size / 1024);
d1316 9
a1324 9
      return FALSE;
   }
   alloced = I830AllocVidMem(pScrn, &(pI830->TexMem),
			     &(pI830->StolenPool), size, GTT_PAGE_SIZE,
			     flags | FROM_ANYWHERE | ALLOCATE_AT_TOP);
   if (alloced < size) {
      if (!dryrun) {
	 xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
		    "Failed to allocate texture space.\n");
d1326 3
a1328 1
      return FALSE;
a1329 3
   xf86DrvMsgVerb(pScrn->scrnIndex, X_INFO, verbosity,
		  "%sAllocated %ld kB for textures at 0x%lx\n", s,
		  alloced / 1024, pI830->TexMem.Start);
d1527 3
a1529 1
      I830FixOffset(pScrn, &(pI830->TexMem));
d1709 1
a1709 1
   if (IS_I965G(pI830)) {
d1928 2
a1929 1
	 if (!BindMemRange(pScrn, &(pI830->TexMem)))
d2013 2
a2014 1
	 if (!UnbindMemRange(pScrn, &(pI830->TexMem)))
@


1.1.1.1
log
@Importing xf86-video-i810 1.7.2
@
text
@@


1.1.1.2
log
@xf86-video-intel 1.7.3
@
text
@a1109 6
#ifdef XF86DRI
   if (!pI830->directRenderingDisabled) {
      pI830->MemoryAperture.End -= KB(pI830->mmSize);
      pI830->MemoryAperture.Size -= KB(pI830->mmSize);
   }
#endif
d1289 15
a1303 20

   if (pI830->mmModeFlags & I830_KERNEL_TEX) {

      size = GetFreeSpace(pScrn);
      if (dryrun && (size < MB(1)))
	 size = MB(1);
      i = myLog2(size / I830_NR_TEX_REGIONS);
      if (i < I830_LOG_MIN_TEX_REGION_SIZE)
	 i = I830_LOG_MIN_TEX_REGION_SIZE;
      pI830->TexGranularity = i;
      /* Truncate size */
      size >>= i;
      size <<= i;
      if (size < KB(512)) {
	 if (!dryrun) {
	    xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
		       "Less than 512 kBytes for texture space (real %ld kBytes).\n", 
		       size / 1024);
	 }
	 return FALSE;
d1305 9
a1313 9
      alloced = I830AllocVidMem(pScrn, &(pI830->TexMem),
				&(pI830->StolenPool), size, GTT_PAGE_SIZE,
				flags | FROM_ANYWHERE | ALLOCATE_AT_TOP);
      if (alloced < size) {
	 if (!dryrun) {
	    xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
		       "Failed to allocate texture space.\n");
	 }
	 return FALSE;
d1315 1
a1315 3
      xf86DrvMsgVerb(pScrn->scrnIndex, X_INFO, verbosity,
		     "%sAllocated %ld kB for textures at 0x%lx\n", s,
		     alloced / 1024, pI830->TexMem.Start);
d1317 3
d1517 1
a1517 3
      if (pI830->mmModeFlags & I830_KERNEL_TEX) {
	 I830FixOffset(pScrn, &(pI830->TexMem));
      }
d1916 1
a1916 2
	 if ((pI830->mmModeFlags & I830_KERNEL_TEX) && 
	     !BindMemRange(pScrn, &(pI830->TexMem)))
d2000 1
a2000 2
	 if ((pI830->mmModeFlags & I830_KERNEL_TEX) && 
	     !UnbindMemRange(pScrn, &(pI830->TexMem)))
@


1.1.1.3
log
@xf86-video-intel 2.2.0
@
text
@a52 42
/**
 * @@file i830_memory.c
 *
 * This is the video memory allocator.  Our memory allocation is different from
 * other graphics chips, where you have a fixed amount of graphics memory
 * available that you want to put to the best use.  Instead, we have almost no
 * memory pre-allocated, and we have to choose an appropriate amount of sytem
 * memory to use.
 *
 * The allocations we might do:
 *
 * - Ring buffer
 * - HW cursor block (either one block or four)
 * - Overlay registers
 * - XAA linear allocator (optional)
 * - EXA 965 state buffer
 * - XAA scratch (screen 1)
 * - XAA scratch (screen 2, only in zaphod mode)
 * - Front buffer (screen 1, more is better for XAA)
 * - Front buffer (screen 2, only in zaphod mode, more is better for XAA)
 * - Back/depth buffer (3D only)
 * - Compatibility texture pool (optional, more is always better)
 * - New texture pool (optional, more is always better.  aperture allocation
 *     only)
 * - EXA offscreen pool (more is always better)
 *
 * We also want to be able to resize the front/back/depth buffers, and then
 * resize the EXA and texture memory pools appropriately.
 *
 * The user may request a specific amount of memory to be used
 * (pI830->pEnt->videoRam != 0), in which case allocations have to fit within
 * that much aperture.  If not, the individual allocations will be
 * automatically sized, and will be fit within the maximum aperture size.
 * Only the actual memory used (not alignment padding) will get actual AGP
 * memory allocated.
 *
 * Given that the allocations listed are generally a page or more than a page,
 * our allocator will only return page-aligned offsets, simplifying the memory
 * binding process.  For smaller allocations, the acceleration architecture's
 * linear allocator is preferred.
 */

a56 1
#include <assert.h>
a57 2
#include <errno.h>
#include <sys/mman.h>
d65 6
a70 1
#define ALIGN(i,m)    (((i) + (m) - 1) & ~((m) - 1))
d72 4
a75 2
/* Our hardware status area is just a single page */
#define HWSTATUS_PAGE_SIZE GTT_PAGE_SIZE
d77 2
a78 3
static i830_memory *
i830_allocate_aperture(ScrnInfoPtr pScrn, const char *name,
		       long size, unsigned long alignment, int flags);
d80 2
a81 3
static int i830_set_tiling(ScrnInfoPtr pScrn, unsigned int offset,
			   unsigned int pitch, unsigned int size,
			   enum tile_format tile_format);
d83 2
a84 1
static void i830_clear_tiling(ScrnInfoPtr pScrn, unsigned int fence_nr);
d86 3
a88 2
/**
 * Returns the fence size for a tiled area of the given size.
d91 2
a92 1
i830_get_fence_size(ScrnInfoPtr pScrn, unsigned long size)
d94 67
a160 21
    I830Ptr pI830 = I830PTR(pScrn);
    unsigned long i;
    unsigned long start;

    if (IS_I965G(pI830)) {
	/* The 965 can have fences at any page boundary. */
	return ALIGN(size, GTT_PAGE_SIZE);
    } else {
	/* Align the size to a power of two greater than the smallest fence
	 * size.
	 */
	if (IS_I9XX(pI830))
	    start = MB(1);
	else
	    start = KB(512);

	for (i = start; i < size; i <<= 1)
	    ;

	return i;
    }
d163 3
a165 2
static Bool
i830_bind_memory(ScrnInfoPtr pScrn, i830_memory *mem)
d167 66
a232 54
    I830Ptr pI830 = I830PTR(pScrn);

    if (mem == NULL || mem->bound)
	return TRUE;

#ifdef XF86DRI_MM
    if (mem->bo.size != 0) {
	I830Ptr pI830 = I830PTR(pScrn);
	int ret;

	ret = drmBOSetStatus(pI830->drmSubFD, &mem->bo,
			     DRM_BO_FLAG_MEM_VRAM |
			     DRM_BO_FLAG_MEM_TT |
			     DRM_BO_FLAG_READ |
			     DRM_BO_FLAG_WRITE |
			     DRM_BO_FLAG_NO_EVICT,
			     DRM_BO_MASK_MEM |
			     DRM_BO_FLAG_READ |
			     DRM_BO_FLAG_WRITE |
			     DRM_BO_FLAG_NO_EVICT,
			     0, 0, 0);
	if (ret != 0)
	    return FALSE;

	mem->bound = TRUE;
	mem->offset = mem->bo.offset;
	mem->end = mem->bo.offset + mem->size;
    }
#endif

    if (!mem->bound) {
	if (!pI830->gtt_acquired)
	    return TRUE;

	if (mem->key != -1 && 
	    !xf86BindGARTMemory(pScrn->scrnIndex, mem->key, mem->agp_offset))
	{
	    return FALSE;
	}

	mem->bound = TRUE;
    }

    if (mem->tiling != TILE_NONE) {
	mem->fence_nr = i830_set_tiling(pScrn, mem->offset, mem->pitch,
					mem->allocated_size, mem->tiling);
    }

    /* Mark the pages accessible now that they're bound. */
    if (mprotect(pI830->FbBase + mem->offset, ALIGN(mem->size, GTT_PAGE_SIZE),
		 PROT_READ | PROT_WRITE) != 0) {
	xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
		   "Failed to mprotect %s: %s\n", mem->name, strerror(errno));
    }
d234 1
a234 1
    return TRUE;
d237 2
a238 2
static Bool
i830_unbind_memory(ScrnInfoPtr pScrn, i830_memory *mem)
d240 1
a240 1
    I830Ptr pI830 = I830PTR(pScrn);
d242 2
a243 2
    if (mem == NULL || !mem->bound)
	return TRUE;
d245 81
a325 37
    /* Mark the pages accessible now that they're bound. */
    if (mprotect(pI830->FbBase + mem->offset, ALIGN(mem->size, GTT_PAGE_SIZE),
		 PROT_NONE) != 0) {
	xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
		   "Failed to mprotect %s: %s\n", mem->name, strerror(errno));
    }

    if (mem->tiling != TILE_NONE)
	i830_clear_tiling(pScrn, mem->fence_nr);

#ifdef XF86DRI_MM
    if (mem->bo.size != 0) {
	I830Ptr pI830 = I830PTR(pScrn);
	int ret;

	ret = drmBOSetStatus(pI830->drmSubFD, &mem->bo,
			     0, DRM_BO_FLAG_NO_EVICT,
			     0, 0, 0);

	if (ret == 0) {
	    mem->bound = FALSE;
	    /* Give buffer obviously wrong offset/end until it's re-pinned. */
	    mem->offset = -1;
	    mem->end = -1;
	    return TRUE;
	} else {
	    return FALSE;
	}
    }
#endif

    if (mem->key == -1 || xf86UnbindGARTMemory(pScrn->scrnIndex, mem->key)) {
	mem->bound = FALSE;
	return TRUE;
    } else {
	return FALSE;
    }
d328 2
a329 2
void
i830_free_memory(ScrnInfoPtr pScrn, i830_memory *mem)
d331 35
a365 35
    if (mem == NULL)
	return;

    /* Free any AGP memory. */
    i830_unbind_memory(pScrn, mem);

#ifdef XF86DRI_MM
    if (mem->bo.size != 0) {
	I830Ptr pI830 = I830PTR(pScrn);

	drmBOUnreference(pI830->drmSubFD, &mem->bo);
	if (pI830->bo_list == mem)
	    pI830->bo_list = mem->next;
	if (mem->next)
	    mem->next->prev = NULL;
	if (mem->prev)
	    mem->prev->next = NULL;
	xfree(mem->name);
	xfree(mem);
	return;
    }
#endif
	    /* Disconnect from the list of allocations */
    if (mem->prev != NULL)
	mem->prev->next = mem->next;
    if (mem->next != NULL)
	mem->next->prev = mem->prev;

    if (mem->key != -1) {
	xf86DeallocateGARTMemory(pScrn->scrnIndex, mem->key);
	mem->key = -1;
    }

    xfree(mem->name);
    xfree(mem);
d368 3
a370 2
/* Resets the state of the aperture allocator, freeing all memory that had
 * been allocated.
d372 2
a373 2
void
i830_reset_allocations(ScrnInfoPtr pScrn)
d375 68
a442 2
    I830Ptr pI830 = I830PTR(pScrn);
    int	    p;
d444 2
a445 45
    /* While there is any memory between the start and end markers, free it. */
    while (pI830->memory_list->next->next != NULL) {
	i830_memory *mem = pI830->memory_list->next;

#ifdef XF86DRI
	/* Don't reset BO allocator, which we set up at init. */
	if (pI830->memory_manager == mem) {
	    mem = mem->next;
	    if (mem->next == NULL)
		break;
	}
#endif	

	i830_free_memory(pScrn, mem);
    }

    /* Free any allocations in buffer objects */
#ifdef XF86DRI_MM
    if (pI830->memory_manager) {
	while (pI830->bo_list != NULL)
	    i830_free_memory(pScrn, pI830->bo_list);
    }
#endif

    /* Null out the pointers for all the allocations we just freed.  This is
     * kind of gross, but at least it's just one place now.
     */
    pI830->cursor_mem = NULL;
    for (p = 0; p < 2; p++) {
	pI830->cursor_mem_classic[p] = NULL;
	pI830->cursor_mem_argb[p] = NULL;
    }
    pI830->front_buffer = NULL;
    pI830->front_buffer_2 = NULL;
    pI830->xaa_scratch = NULL;
    pI830->xaa_scratch_2 = NULL;
    pI830->exa_offscreen = NULL;
    pI830->exa_965_state = NULL;
    pI830->overlay_regs = NULL;
    pI830->logical_context = NULL;
#ifdef XF86DRI
    pI830->back_buffer = NULL;
    pI830->third_buffer = NULL;
    pI830->depth_buffer = NULL;
    pI830->textures = NULL;
a446 2
    pI830->LpRing->mem = NULL;
}
d448 2
a449 2
void
i830_free_3d_memory(ScrnInfoPtr pScrn)
d451 16
a466 12
    I830Ptr pI830 = I830PTR(pScrn);

#ifdef XF86DRI
    i830_free_memory(pScrn, pI830->back_buffer);
    pI830->back_buffer = NULL;
    i830_free_memory(pScrn, pI830->third_buffer);
    pI830->third_buffer = NULL;
    i830_free_memory(pScrn, pI830->depth_buffer);
    pI830->depth_buffer = NULL;
    i830_free_memory(pScrn, pI830->textures);
    pI830->textures = NULL;
#endif
a468 9
/**
 * Initialize's the driver's video memory allocator to allocate in the
 * given range.
 *
 * This sets up the kernel memory manager to manage as much of the memory
 * as we think it can, while leaving enough to us to fulfill our non-TTM
 * static allocations.  Some of these exist because of the need for physical
 * addresses to reference.
 */
d470 1
a470 1
i830_allocator_init(ScrnInfoPtr pScrn, unsigned long offset, unsigned long size)
d472 58
a529 112
    I830Ptr pI830 = I830PTR(pScrn);
    i830_memory *start, *end;
#ifdef XF86DRI_MM
    int dri_major, dri_minor, dri_patch;
#endif

    start = xcalloc(1, sizeof(*start));
    if (start == NULL)
	return FALSE;
    start->name = xstrdup("start marker");
    if (start->name == NULL) {
	xfree(start);
	return FALSE;
    }
    end = xcalloc(1, sizeof(*end));
    if (end == NULL) {
	xfree(start->name);
	xfree(start);
	return FALSE;
    }
    end->name = xstrdup("end marker");
    if (end->name == NULL) {
	xfree(start->name);
	xfree(start);
	xfree(end);
	return FALSE;
    }

    start->key = -1;
    start->offset = offset;
    start->end = start->offset;
    start->size = 0;
    start->next = end;
    end->key = -1;
    end->offset = offset + size;
    end->end = end->offset;
    end->size = 0;
    end->prev = start;

    pI830->memory_list = start;

#ifdef XF86DRI_MM
    DRIQueryVersion(&dri_major, &dri_minor, &dri_patch);

    /* Now that we have our manager set up, initialize the kernel MM if
     * possible, covering almost all of the aperture.  We need libdri interface
     * 5.4 or newer so we can rely on the lock being held after DRIScreenInit,
     * rather than after DRIFinishScreenInit.
     */
    if (pI830->directRenderingEnabled && pI830->drmMinor >= 7 &&
	(dri_major > 5 || (dri_major == 5 && dri_minor >= 4)))
    {
	int mmsize;

	/* Take over all of the graphics aperture minus enough to for
	 * physical-address allocations of cursor/overlay registers.
	 */
	mmsize = size;

	/* EXA area is fixed. */
	if (pI830->useEXA) {
	    mmsize -= ROUND_TO_PAGE(3 * pScrn->displayWidth * pI830->cpp *
				    pScrn->virtualY);
	}
	/* Classic textures are fixed. */
	if (pI830->allocate_classic_textures)
	    mmsize -= MB(32);
	/* Overlay and cursors, if physical, need to be allocated outside
	 * of the kernel memory manager.
	 */
	if (!OVERLAY_NOPHYSICAL(pI830) && !IS_I965G(pI830)) {
	    mmsize -= ROUND_TO(OVERLAY_SIZE, GTT_PAGE_SIZE);
	}
	if (pI830->CursorNeedsPhysical) {
	    mmsize -= 2 * (ROUND_TO(HWCURSOR_SIZE, GTT_PAGE_SIZE) +
		    ROUND_TO(HWCURSOR_SIZE_ARGB, GTT_PAGE_SIZE));
	}
	if (pI830->fb_compression)
	    mmsize -= MB(6);
	/* Can't do TTM on stolen memory */
	mmsize -= pI830->stolen_size;

	/* Create the aperture allocation */
	pI830->memory_manager =
	    i830_allocate_aperture(pScrn, "DRI memory manager",
				   mmsize, GTT_PAGE_SIZE,
				   ALIGN_BOTH_ENDS | NEED_NON_STOLEN);

	if (pI830->memory_manager != NULL) {
	    int ret;

	    /* Tell the kernel to manage it */
	    ret = drmMMInit(pI830->drmSubFD,
			    pI830->memory_manager->offset / GTT_PAGE_SIZE,
			    pI830->memory_manager->size / GTT_PAGE_SIZE,
			    DRM_BO_MEM_TT);
	    if (ret != 0) {
		xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
			   "Failed to initialize kernel memory manager\n");
		i830_free_memory(pScrn, pI830->memory_manager);
		pI830->memory_manager = NULL;
	    }
	} else {
	    xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
		       "Failed to allocate space for kernel memory manager\n");
	    i830_free_memory(pScrn, pI830->memory_manager);
	    pI830->memory_manager = NULL;
	}
    }
#endif /* XF86DRI_MM */

    return TRUE;
d532 2
a533 2
void
i830_allocator_fini(ScrnInfoPtr pScrn)
d535 61
a595 1
    I830Ptr pI830 = I830PTR(pScrn);
d597 2
a598 27
    /* Free most of the allocations */
    i830_reset_allocations(pScrn);

#ifdef XF86DRI_MM
    /* The memory manager is more special */
    if (pI830->memory_manager) {
	 drmMMTakedown(pI830->drmSubFD, DRM_BO_MEM_TT);
	 i830_free_memory(pScrn, pI830->memory_manager);
	 pI830->memory_manager = NULL;
    }
#endif /* XF86DRI_MM */

    /* Free the start/end markers */
    free(pI830->memory_list->next);
    free(pI830->memory_list);
    pI830->memory_list = NULL;
}

/**
 * Reads a GTT entry for the memory at the given offset and returns the
 * physical address.
 *
 * \return physical address if successful.
 * \return (uint64_t)-1 if unsuccessful.
 */
static uint64_t
i830_get_gtt_physical(ScrnInfoPtr pScrn, unsigned long offset)
d600 2
a601 2
    I830Ptr pI830 = I830PTR(pScrn);
    CARD32 gttentry;
d603 6
a608 65
    /* We don't have GTTBase set up on i830 yet. */
    if (pI830->GTTBase == NULL)
	return -1;

    gttentry = INGTT(offset / 1024);

    /* Mask out these reserved bits on this hardware. */
    if (!IS_I9XX(pI830) || IS_I915G(pI830) || IS_I915GM(pI830) ||
	IS_I945G(pI830) || IS_I945GM(pI830))
    {
	gttentry &= ~PTE_ADDRESS_MASK_HIGH;
    }

    /* If it's not a mapping type we know, then bail. */
    if ((gttentry & PTE_MAPPING_TYPE_MASK) != PTE_MAPPING_TYPE_UNCACHED &&
	(gttentry & PTE_MAPPING_TYPE_MASK) != PTE_MAPPING_TYPE_CACHED)
    {
	xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
		   "Unusable physical mapping type 0x%08x\n",
		   (unsigned int)(gttentry & PTE_MAPPING_TYPE_MASK));
	return -1;
    }
    assert((gttentry & PTE_VALID) != 0);

    return (gttentry & PTE_ADDRESS_MASK) |
	((uint64_t)(gttentry & PTE_ADDRESS_MASK_HIGH) << (32 - 4));
}

/**
 * Reads the GTT entries for stolen memory at the given offset, returning the
 * physical address.
 *
 * \return physical address if successful.
 * \return (uint64_t)-1 if unsuccessful.
 */
static uint64_t
i830_get_stolen_physical(ScrnInfoPtr pScrn, unsigned long offset,
			 unsigned long size)
{
    I830Ptr pI830 = I830PTR(pScrn);
    uint64_t physical;
    unsigned long scan;

    /* Check that the requested region is within stolen memory. */
    if (offset + size >= pI830->stolen_size)
	return -1;

    physical = i830_get_gtt_physical(pScrn, offset);
    if (physical == -1)
	return -1;

    /* Check that the following pages in our allocation follow the first page
     * contiguously.
     */
    for (scan = offset + 4096; scan < offset + size; scan += 4096) {
	uint64_t scan_physical = i830_get_gtt_physical(pScrn, scan);

	if ((scan - offset) != (scan_physical - physical)) {
	    xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
		       "Non-contiguous GTT entries: (%ld,0x16%llx) vs "
		       "(%ld,0x%16llx)\n",
		       scan, scan_physical, offset, physical);
	    return -1;
	}
    }
d610 1
a610 1
    return physical;
d613 3
a615 4
/* Allocate aperture space for the given size and alignment, and returns the
 * memory allocation.
 *
 * Allocations are a minimum of a page, and will be at least page-aligned.
a616 39
static i830_memory *
i830_allocate_aperture(ScrnInfoPtr pScrn, const char *name,
		       long size, unsigned long alignment, int flags)
{
    I830Ptr pI830 = I830PTR(pScrn);
    i830_memory *mem, *scan;

    mem = xcalloc(1, sizeof(*mem));
    if (mem == NULL)
	return NULL;

    /* No memory allocated to back the region */
    mem->key = -1;

    mem->name = xstrdup(name);
    if (mem->name == NULL) {
	xfree(mem);
	return NULL;
    }
    /* Only allocate page-sized increments. */
    size = ALIGN(size, GTT_PAGE_SIZE);
    mem->size = size;
    mem->allocated_size = size;

    if (alignment < GTT_PAGE_SIZE)
	alignment = GTT_PAGE_SIZE;

    for (scan = pI830->memory_list; scan->next != NULL; scan = scan->next) {
	mem->offset = ROUND_TO(scan->end, alignment);
	if ((flags & NEED_PHYSICAL_ADDR) && mem->offset < pI830->stolen_size) {
	    /* If the allocation is entirely within stolen memory, and we're
	     * able to get the physical addresses out of the GTT and check that
	     * it's contiguous (it ought to be), then we can do our physical
	     * allocations there and not bother the kernel about it.  This
	     * helps avoid aperture fragmentation from our physical
	     * allocations.
	     */
	    mem->bus_addr = i830_get_stolen_physical(pScrn, mem->offset,
						     mem->size);
d618 2
a619 40
	    if (mem->bus_addr == ((uint64_t)-1)) {
		/* Move the start of the allocation to just past the end of
		 * stolen memory.
		 */
		mem->offset = ROUND_TO(pI830->stolen_size, alignment);
	    }
	}
	if ((flags & NEED_NON_STOLEN) && mem->offset < pI830->stolen_size) {
	    mem->offset = ROUND_TO(pI830->stolen_size, alignment);
	}

	mem->end = mem->offset + size;
	if (flags & ALIGN_BOTH_ENDS)
	    mem->end = ROUND_TO(mem->end, alignment);
	if (mem->end <= scan->next->offset)
	    break;
    }
    if (scan->next == NULL) {
	/* Reached the end of the list, and didn't find space */
	xfree(mem->name);
	xfree(mem);
	return NULL;
    }
    /* Insert new allocation into the list */
    mem->prev = scan;
    mem->next = scan->next;
    scan->next = mem;
    mem->next->prev = mem;

    return mem;
}

/**
 * Allocates the AGP memory necessary for the part of a memory allocation not
 * already covered by the stolen memory.
 *
 * The memory is automatically bound if we have the VT.
 */
static Bool
i830_allocate_agp_memory(ScrnInfoPtr pScrn, i830_memory *mem, int flags)
d621 69
a689 2
    I830Ptr pI830 = I830PTR(pScrn);
    unsigned long size;
d691 40
a730 2
    if (mem->key != -1)
	return TRUE;
d732 1
a732 2
    if (mem->offset + mem->size <= pI830->stolen_size)
	return TRUE;
d734 62
a795 4
    if (mem->offset < pI830->stolen_size)
	mem->agp_offset = pI830->stolen_size;
    else
	mem->agp_offset = mem->offset;
d797 178
a974 1
    size = mem->size - (mem->agp_offset - mem->offset);
d976 58
a1033 2
    if (flags & NEED_PHYSICAL_ADDR) {
	unsigned long agp_bus_addr;
d1035 3
a1037 87
	mem->key = xf86AllocateGARTMemory(pScrn->scrnIndex, size, 2,
					  &agp_bus_addr);
	mem->bus_addr = agp_bus_addr;
    } else {
	mem->key = xf86AllocateGARTMemory(pScrn->scrnIndex, size, 0, NULL);
    }
    if (mem->key == -1 || ((flags & NEED_PHYSICAL_ADDR) && mem->bus_addr == 0))
    {
	return FALSE;
    }

    if (!i830_bind_memory(pScrn, mem)) {
	return FALSE;
    }

    return TRUE;
}

#ifdef XF86DRI_MM
static i830_memory *
i830_allocate_memory_bo(ScrnInfoPtr pScrn, const char *name,
			unsigned long size, unsigned long align, int flags)
{
    I830Ptr pI830 = I830PTR(pScrn);
    i830_memory *mem;
    unsigned long mask;
    int ret;

    assert((flags & NEED_PHYSICAL_ADDR) == 0);

    /* Only allocate page-sized increments. */
    size = ALIGN(size, GTT_PAGE_SIZE);
    align = ROUND_TO(align, GTT_PAGE_SIZE);

    mem = xcalloc(1, sizeof(*mem));
    if (mem == NULL)
	return NULL;

    mem->name = xstrdup(name);
    if (name == NULL) {
	xfree(mem);
	return NULL;
    }

    /*
     * Create buffers in local memory to avoid having the creation order
     * determine the TT offset. Driver acceleration
     * cannot handle changed front buffer TT offsets yet ,
     * so let's keep our fingers crossed.
     */

    mask = DRM_BO_FLAG_READ | DRM_BO_FLAG_WRITE | DRM_BO_FLAG_MAPPABLE |
	DRM_BO_FLAG_MEM_LOCAL;
    if (flags & ALLOW_SHARING)
	mask |= DRM_BO_FLAG_SHAREABLE;

    ret = drmBOCreate(pI830->drmSubFD, size, align / GTT_PAGE_SIZE, NULL,
		      mask, 0, &mem->bo);
    if (ret) {
	xfree(mem->name);
	xfree(mem);
	return NULL;
    }
    /* Give buffer obviously wrong offset/end until it's pinned. */
    mem->offset = -1;
    mem->end = -1;
    mem->size = size;
    mem->allocated_size = size;
    if (flags & NEED_LIFETIME_FIXED)
	mem->lifetime_fixed_offset = TRUE;

    /* Bind it if we currently control the VT */
    if (pScrn->vtSema) {
	if (!i830_bind_memory(pScrn, mem)) {
	    drmBOUnreference(pI830->drmSubFD, &mem->bo);
	    xfree(mem->name);
	    xfree(mem);
	    return NULL;
	}
    }

    /* Insert new allocation into the list */
    mem->prev = NULL;
    mem->next = pI830->bo_list;
    if (pI830->bo_list != NULL)
	pI830->bo_list->prev = mem;
    pI830->bo_list = mem;
d1039 2
a1040 3
    return mem;
}
#endif /* XF86DRI_MM */
d1042 56
a1097 43
/* Allocates video memory at the given size and alignment.
 *
 * The memory will be bound automatically when the driver is in control of the
 * VT.  When the kernel memory manager is available and compatible with flags
 * (that is, flags doesn't say that the allocation must include a physical
 * address), that will be used for the allocation.
 *
 * flags:
 * - NEED_PHYSICAL_ADDR: Allocates the memory physically contiguous, and return
 *   the bus address for that memory.
 * - ALIGN_BOTH_ENDS: after choosing the alignment, align the end offset to
 *   @@alignment as well.
 * - NEED_NON-STOLEN: don't allow any part of the memory allocation to lie
 *   within stolen memory
 * - NEED_LIFETIME_FIXED: don't allow the buffer object to move throughout
 *   the entire Screen lifetime.  This means not using buffer objects, which
 *   get their offsets chosen at each EnterVT time.
 */
i830_memory *
i830_allocate_memory(ScrnInfoPtr pScrn, const char *name,
		     unsigned long size, unsigned long alignment, int flags)
{
    i830_memory *mem;

#ifdef XF86DRI_MM
    I830Ptr pI830 = I830PTR(pScrn);

    if (pI830->memory_manager && !(flags & NEED_PHYSICAL_ADDR) &&
	!(flags & NEED_LIFETIME_FIXED))
    {
	return i830_allocate_memory_bo(pScrn, name, size, alignment, flags);
    } else
#endif	
    {
	mem = i830_allocate_aperture(pScrn, name, size, alignment, flags);
	if (mem == NULL)
	    return NULL;

	if (!i830_allocate_agp_memory(pScrn, mem, flags)) {
	    i830_free_memory(pScrn, mem);
	    return NULL;
	}
    }
d1099 1
a1099 3
    mem->tiling = TILE_NONE;

    return mem;
d1102 4
a1105 54
/* Allocate a tiled region with the given size and pitch.
 *
 * As is, we might miss out on tiling some allocations on older hardware with
 * large framebuffer size and a small aperture size, where the first
 * allocations use a large alignment even though we've got fences to spare, and
 * the later allocations can't find enough aperture space left.  We could do
 * some search across all allocation options to fix this, probably, but that
 * would be another rewrite.
 */
i830_memory *
i830_allocate_memory_tiled(ScrnInfoPtr pScrn, const char *name,
			   unsigned long size, unsigned long pitch,
			   unsigned long alignment, int flags,
			   enum tile_format tile_format)
{
    I830Ptr pI830 = I830PTR(pScrn);
    unsigned long aper_size;
    unsigned long aper_align;
    i830_memory *mem;

    if (tile_format == TILE_NONE)
	return i830_allocate_memory(pScrn, name, size, alignment, flags);

    /* Only allocate page-sized increments. */
    size = ALIGN(size, GTT_PAGE_SIZE);

    /* Check for maximum tiled region size */
    if (IS_I9XX(pI830)) {
	if (size > MB(128))
	    return NULL;
    } else {
	if (size > MB(64))
	    return NULL;
    }

    aper_size = i830_get_fence_size(pScrn, size);
    if (IS_I965G(pI830)) {
	aper_align = GTT_PAGE_SIZE;
    } else {
	/* The offset has to be aligned to at least the size of the fence
	 * region.
	 */
	aper_align = aper_size;
    }
    if (aper_align < alignment)
	aper_align = alignment;

    mem = i830_allocate_memory(pScrn, name, aper_size, aper_align, flags);
    if (mem == NULL)
	return NULL;
    mem->size = size;
    mem->tiling = tile_format;
    mem->pitch = pitch;
    mem->fence_nr = -1;
d1107 21
a1127 1
    return mem;
d1130 2
a1131 2
void
i830_describe_allocations(ScrnInfoPtr pScrn, int verbosity, const char *prefix)
d1133 2
a1134 2
    I830Ptr pI830 = I830PTR(pScrn);
    i830_memory *mem;
d1136 5
a1140 75
    if (pI830->memory_list == NULL) {
	xf86DrvMsgVerb(pScrn->scrnIndex, X_INFO, verbosity,
		       "%sMemory allocator not initialized\n", prefix);
	return;
    }

    if (pI830->memory_list->next->next == NULL) {
	xf86DrvMsgVerb(pScrn->scrnIndex, X_INFO, verbosity,
		       "%sNo memory allocations\n", prefix);
	return;
    }

    xf86DrvMsgVerb(pScrn->scrnIndex, X_INFO, verbosity,
		   "%sFixed memory allocation layout:\n", prefix);

    for (mem = pI830->memory_list->next; mem->next != NULL; mem = mem->next) {
	char phys_suffix[32] = "";
	char *tile_suffix = "";

	if (mem->offset >= pI830->stolen_size &&
	    mem->prev->offset < pI830->stolen_size)
	{
	    xf86DrvMsgVerb(pScrn->scrnIndex, X_INFO, verbosity,
			   "%s0x%08lx:            end of stolen memory\n",
			   prefix, pI830->stolen_size);
	}

	if (mem->bus_addr != 0)
	    snprintf(phys_suffix, sizeof(phys_suffix),
		    ", 0x%016llx physical\n", mem->bus_addr);
	if (mem->tiling == TILE_XMAJOR)
	    tile_suffix = " X tiled";
	else if (mem->tiling == TILE_YMAJOR)
	    tile_suffix = " Y tiled";

	xf86DrvMsgVerb(pScrn->scrnIndex, X_INFO, verbosity,
		       "%s0x%08lx-0x%08lx: %s (%ld kB%s)%s\n", prefix,
		       mem->offset, mem->end - 1, mem->name,
		       mem->size / 1024, phys_suffix, tile_suffix);
    }
    xf86DrvMsgVerb(pScrn->scrnIndex, X_INFO, verbosity,
		   "%s0x%08lx:            end of aperture\n",
		   prefix, pI830->FbMapSize);

#ifdef XF86DRI_MM
    if (pI830->memory_manager) {
	xf86DrvMsgVerb(pScrn->scrnIndex, X_INFO, verbosity,
		       "%sBO memory allocation layout:\n", prefix);
	xf86DrvMsgVerb(pScrn->scrnIndex, X_INFO, verbosity,
		       "%s0x%08lx:            start of memory manager\n",
		       prefix, pI830->memory_manager->offset);
	for (mem = pI830->bo_list; mem != NULL; mem = mem->next) {
	    char *tile_suffix = "";

	    if (mem->tiling == TILE_XMAJOR)
		tile_suffix = " X tiled";
	    else if (mem->tiling == TILE_YMAJOR)
		tile_suffix = " Y tiled";

	    if (mem->bound) {
		xf86DrvMsgVerb(pScrn->scrnIndex, X_INFO, verbosity,
			       "%s0x%08lx-0x%08lx: %s (%ld kB)%s\n", prefix,
			       mem->offset, mem->end - 1, mem->name,
			       mem->size / 1024, tile_suffix);
	    } else {
		xf86DrvMsgVerb(pScrn->scrnIndex, X_INFO, verbosity,
			       "%sunpinned          : %s (%ld kB)%s\n", prefix,
			       mem->name, mem->size / 1024, tile_suffix);
	    }
	}
	xf86DrvMsgVerb(pScrn->scrnIndex, X_INFO, verbosity,
		       "%s0x%08lx:            end of memory manager\n",
		       prefix, pI830->memory_manager->end);
    }
#endif /* XF86DRI_MM */
d1143 3
a1145 2
static Bool
i830_allocate_ringbuffer(ScrnInfoPtr pScrn)
d1147 1
a1147 1
    I830Ptr pI830 = I830PTR(pScrn);
d1149 6
a1154 2
    if (pI830->noAccel || pI830->LpRing->mem != NULL)
	return TRUE;
d1156 59
a1214 12
    /* We don't have any mechanism in the DRM yet to alert it that we've moved
     * the ringbuffer since init time, so allocate it fixed for its lifetime.
     */
    pI830->LpRing->mem = i830_allocate_memory(pScrn, "ring buffer",
					      PRIMARY_RINGBUFFER_SIZE,
					      GTT_PAGE_SIZE,
					      NEED_LIFETIME_FIXED);
    if (pI830->LpRing->mem == NULL) {
	xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
		   "Failed to allocate Ring Buffer space\n");
	return FALSE;
    }
d1216 1
a1216 2
    pI830->LpRing->tail_mask = pI830->LpRing->mem->size - 1;
    return TRUE;
d1219 2
a1220 7
#ifdef I830_XV
/**
 * Allocate space for overlay registers and XAA linear allocator (if
 * requested)
 */
static Bool
i830_allocate_overlay(ScrnInfoPtr pScrn)
d1222 56
a1277 2
    I830Ptr pI830 = I830PTR(pScrn);
    int flags = 0;
d1279 1
a1279 19
    /* Only allocate if overlay is going to be enabled. */
    if (!pI830->XvEnabled)
	return TRUE;

    if (!OVERLAY_NOPHYSICAL(pI830))
	flags |= NEED_PHYSICAL_ADDR;

    if (!IS_I965G(pI830)) {
	pI830->overlay_regs = i830_allocate_memory(pScrn, "overlay registers",
						   OVERLAY_SIZE, GTT_PAGE_SIZE,
						   flags);
	if (pI830->overlay_regs == NULL) {
	    xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
		       "Failed to allocate Overlay register space.\n");
	    /* This failure isn't fatal. */
	}
    }

    return TRUE;
a1280 1
#endif
d1282 2
a1283 2
static Bool
IsTileable(ScrnInfoPtr pScrn, int pitch)
d1285 36
a1320 92
    I830Ptr pI830 = I830PTR(pScrn);

    if (IS_I965G(pI830)) {
	if (pitch / 512 * 512 == pitch && pitch <= KB(128))
	    return TRUE;
	else
	    return FALSE;
    }

    /*
     * Allow tiling for pitches that are a power of 2 multiple of 128 bytes,
     * up to 64 * 128 (= 8192) bytes.
     */
    switch (pitch) {
    case 128:
    case 256:
	if (IS_I945G(pI830) || IS_I945GM(pI830) || IS_G33CLASS(pI830))
	    return TRUE;
	else
	    return FALSE;
    case 512:
    case KB(1):
    case KB(2):
    case KB(4):
    case KB(8):
	return TRUE;
    default:
	return FALSE;
    }
}

/* This is the 2D rendering vertical coordinate limit.  We can ignore
 * the 3D rendering limits in our 2d pixmap cache allocation, because XAA
 * doesn't do any 3D rendering to/from the cache lines when using an offset
 * at the start of framebuffer.
 */
#define MAX_2D_HEIGHT		65536

/**
 * Allocates a framebuffer for a screen.
 *
 * Used once for each X screen, so once with RandR 1.2 and twice with classic
 * dualhead.
 *
 * \param pScrn ScrnInfoPtr for the screen being allocated
 * \param pI830 I830Ptr for the screen being allocated.
 * \param FbMemBox
 */
static i830_memory *
i830_allocate_framebuffer(ScrnInfoPtr pScrn, I830Ptr pI830, BoxPtr FbMemBox,
			  Bool secondary)
{
    unsigned int pitch = pScrn->displayWidth * pI830->cpp;
    unsigned long minspace, avail;
    int cacheLines, maxCacheLines;
    int align;
    long size, fb_height;
    char *name;
    int flags;
    i830_memory *front_buffer = NULL;
    Bool tiling;

    flags = ALLOW_SHARING;

    /* Clear everything first. */
    memset(FbMemBox, 0, sizeof(*FbMemBox));

    /* We'll allocate the fb such that the root window will fit regardless of
     * rotation.
     */
    if (pScrn->virtualX > pScrn->virtualY)
	fb_height = pScrn->virtualX;
    else
	fb_height = pScrn->virtualY;

    FbMemBox->x1 = 0;
    FbMemBox->x2 = pScrn->displayWidth;
    FbMemBox->y1 = 0;
    FbMemBox->y2 = fb_height;

    /* Calculate how much framebuffer memory to allocate.  For the
     * initial allocation, calculate a reasonable minimum.  This is
     * enough for the virtual screen size, plus some pixmap cache
     * space if we're using XAA.
     */
    minspace = pitch * pScrn->virtualY;
    avail = pScrn->videoRam * 1024;

    if (!pI830->useEXA) {
	maxCacheLines = (avail - minspace) / pitch;
	/* This shouldn't happen. */
	if (maxCacheLines < 0) {
d1322 8
a1329 19
		       "Internal Error: "
		       "maxCacheLines < 0 in i830_allocate_2d_memory()\n");
	    maxCacheLines = 0;
	}
	if (maxCacheLines > (MAX_2D_HEIGHT - pScrn->virtualY))
	    maxCacheLines = MAX_2D_HEIGHT - pScrn->virtualY;

	if (pI830->CacheLines >= 0) {
	    cacheLines = pI830->CacheLines;
	} else {
	    int size;

	    size = 3 * pitch * pScrn->virtualY;
	    size = ROUND_TO_PAGE(size);

	    cacheLines = (size + pitch - 1) / pitch;
	}
	if (cacheLines > maxCacheLines)
	    cacheLines = maxCacheLines;
d1331 1
a1331 53
	FbMemBox->y2 += cacheLines;

	xf86DrvMsg(pScrn->scrnIndex, X_INFO,
		   "Allocating %d scanlines for pixmap cache\n",
		   cacheLines);
    } else {
	/* For EXA, we have a separate allocation for the linear allocator
	 * which also does the pixmap cache.
	 */
	cacheLines = 0;
    }

    size = pitch * (fb_height + cacheLines);
    size = ROUND_TO_PAGE(size);

    name = secondary ? "secondary front buffer" : "front buffer";

    /* Front buffer tiling has to be disabled with G965 XAA because some of the
     * acceleration operations (non-XY COLOR_BLT) can't be done to tiled
     * buffers.
     */
    if (!pI830->useEXA && IS_I965G(pI830))
	tiling = FALSE;
    else
	tiling = pI830->tiling;

    /* Attempt to allocate it tiled first if we have page flipping on. */
    if (tiling && IsTileable(pScrn, pitch)) {
	/* XXX: probably not the case on 965 */
	if (IS_I9XX(pI830))
	    align = MB(1);
	else
	    align = KB(512);
	front_buffer = i830_allocate_memory_tiled(pScrn, name, size,
						  pitch, align, flags,
						  TILE_XMAJOR);
    }

    /* If not, attempt it linear */
    if (front_buffer == NULL) {
	front_buffer = i830_allocate_memory(pScrn, name, size, KB(64), flags);
    }

    if (front_buffer == NULL) {
	xf86DrvMsg(pScrn->scrnIndex, X_ERROR, "Failed to allocate "
		   "%sframebuffer. Is your VideoRAM set too low?\n",
		   secondary ? "secondary " : "");
	return NULL;
    }

    if (pI830->FbBase)
	memset (pI830->FbBase + front_buffer->offset, 0, size);
    return front_buffer;
a1333 104
static Bool
i830_allocate_cursor_buffers(ScrnInfoPtr pScrn)
{
    I830Ptr pI830 = I830PTR(pScrn);
    xf86CrtcConfigPtr xf86_config = XF86_CRTC_CONFIG_PTR(pScrn);
    int flags = pI830->CursorNeedsPhysical ? NEED_PHYSICAL_ADDR : 0;
    int i;
    long size;

    /* Try to allocate one big blob for our cursor memory.  This works
     * around a limitation in the FreeBSD AGP driver that allows only one
     * physical allocation larger than a page, and could allow us
     * to pack the cursors smaller.
     */
    size = xf86_config->num_crtc * (HWCURSOR_SIZE + HWCURSOR_SIZE_ARGB);

    pI830->cursor_mem = i830_allocate_memory(pScrn, "HW cursors",
					     size, GTT_PAGE_SIZE,
					     flags);
    if (pI830->cursor_mem != NULL)
	return TRUE;

    /*
     * Allocate four separate buffers when the kernel doesn't support
     * large allocations as on Linux. If any of these fail, just
     * bail back to software cursors everywhere
     */
    for (i = 0; i < xf86_config->num_crtc; i++)
    {
	pI830->cursor_mem_classic[i] = i830_allocate_memory (pScrn, 
							     "Core cursor",
							     HWCURSOR_SIZE,
							     GTT_PAGE_SIZE,
							     flags);
	if (!pI830->cursor_mem_classic[i])
	    return FALSE;
	pI830->cursor_mem_argb[i] = i830_allocate_memory (pScrn, "ARGB cursor",
							  HWCURSOR_SIZE_ARGB,
							  GTT_PAGE_SIZE,
							  flags);
	if (!pI830->cursor_mem_argb[i])
	    return FALSE;

    }
    return TRUE;
}

static void i830_setup_fb_compression(ScrnInfoPtr pScrn)
{
    I830Ptr pI830 = I830PTR(pScrn);

    /* Only mobile chips since 845 support this feature */
    if (!IS_MOBILE(pI830)) {
	pI830->fb_compression = FALSE;
	goto out;
    }

    /* Clear out any stale state */
    OUTREG(FBC_CFB_BASE, 0);
    OUTREG(FBC_LL_BASE, 0);
    OUTREG(FBC_CONTROL2, 0);
    OUTREG(FBC_CONTROL, 0);

    /*
     * Compressed framebuffer limitations:
     *   - contiguous, physical, uncached memory
     *   - ideally as large as the front buffer(s), smaller sizes cache less
     *   - uncompressed buffer must be tiled w/pitch 2k-16k
     *   - uncompressed fb is <= 2048 in width, 0 mod 8
     *   - uncompressed fb is <= 1536 in height, 0 mod 2
     *   - compressed fb stride is <= uncompressed stride
     *   - SR display watermarks must be equal between 16bpp and 32bpp?
     *   - both compressed and line buffers must be in stolen memory
     */
    pI830->compressed_front_buffer =
	i830_allocate_memory(pScrn, "compressed frame buffer",
			     MB(6), KB(4), NEED_PHYSICAL_ADDR);

    if (!pI830->compressed_front_buffer) {
	pI830->fb_compression = FALSE;
	goto out;
    }

    pI830->compressed_ll_buffer =
	i830_allocate_memory(pScrn, "compressed ll buffer",
			     FBC_LL_SIZE + FBC_LL_PAD, KB(4),
			     NEED_PHYSICAL_ADDR);
    if (!pI830->compressed_ll_buffer) {
	i830_free_memory(pScrn, pI830->compressed_front_buffer);
	pI830->fb_compression = FALSE;
	goto out;
    }

out:
    if (!pI830->fb_compression)
	xf86DrvMsg(pScrn->scrnIndex, X_WARNING, "Allocation error, framebuffer"
		   " compression disabled\n");
	
    return;
}
/*
 * Allocate memory for 2D operation.  This includes the (front) framebuffer,
 * ring buffer, scratch memory, HW cursor.
 */
d1335 1
a1335 1
i830_allocate_2d_memory(ScrnInfoPtr pScrn)
d1337 28
a1364 48
    I830Ptr pI830 = I830PTR(pScrn);
    unsigned int pitch = pScrn->displayWidth * pI830->cpp;
    long size;

    if (!pI830->StolenOnly &&
	(!xf86AgpGARTSupported() || !xf86AcquireGART(pScrn->scrnIndex))) {
	xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
		   "AGP GART support is either not available or cannot "
		   "be used.\n"
		   "\tMake sure your kernel has agpgart support or has\n"
		   "\tthe agpgart module loaded.\n");
	return FALSE;
    }

    /* Allocate the ring buffer first, so it ends up in stolen mem. */
    i830_allocate_ringbuffer(pScrn);

    if (pI830->fb_compression)
	i830_setup_fb_compression(pScrn);

    /* Next, allocate other fixed-size allocations we have. */
    if (!pI830->SWCursor && !i830_allocate_cursor_buffers(pScrn)) {
	xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
		   "Disabling HW cursor because the cursor memory "
		   "allocation failed.\n");
	pI830->SWCursor = TRUE;
    }

    /* Space for the X Server's 3D context.  32k is fine for right now. */
    pI830->logical_context = i830_allocate_memory(pScrn, "logical 3D context",
						  KB(32), GTT_PAGE_SIZE, 0);
    if (pI830->logical_context == NULL) {
	xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
		   "Failed to allocate logical context space.\n");
	return FALSE;
    }

    /* even in XAA, 965G needs state mem buffer for rendering */
    if (IS_I965G(pI830) && !pI830->noAccel && pI830->exa_965_state == NULL) {
	pI830->exa_965_state =
	    i830_allocate_memory(pScrn, "exa G965 state buffer",
		    EXA_LINEAR_EXTRA, GTT_PAGE_SIZE, 0);
	if (pI830->exa_965_state == NULL) {
	    xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
		    "Failed to allocate exa state buffer for 965.\n");
	    return FALSE;
	}
    }
d1366 2
a1367 35
#ifdef I830_XV
    /* Allocate overlay register space and optional XAA linear allocator
     * space.  The second head in zaphod mode will share the space.
     */
    if (I830IsPrimary(pScrn))
	i830_allocate_overlay(pScrn);
#endif

    if (pI830->entityPrivate && pI830->entityPrivate->pScrn_2) {
	I830EntPtr pI830Ent = pI830->entityPrivate;
	I830Ptr pI8302 = I830PTR(pI830Ent->pScrn_2);

	pI830->front_buffer_2 =
	    i830_allocate_framebuffer(pI830Ent->pScrn_2, pI8302,
				      &pI830->FbMemBox2, TRUE);
	if (pI830->front_buffer_2 == NULL)
	    return FALSE;
    }
    pI830->front_buffer =
	i830_allocate_framebuffer(pScrn, pI830, &pI830->FbMemBox, FALSE);
    if (pI830->front_buffer == NULL)
	return FALSE;

#ifdef I830_USE_EXA
    if (pI830->useEXA) {
	if (pI830->exa_offscreen == NULL) {
	    /* Default EXA to having 3 screens worth of offscreen memory space
	     * (for pixmaps).
	     *
	     * XXX: It would be nice to auto-size it larger if the user
	     * specified a larger size, or to fit along with texture and FB
	     * memory if a low videoRam is specified.
	     */
	    size = 3 * pitch * pScrn->virtualY;
	    size = ROUND_TO_PAGE(size);
d1369 2
a1370 35
	    /* EXA has no way to tell it that the offscreen memory manager has
	     * moved its base and all the contents with it, so we have to have
	     * it locked in place for the whole driver instance.
	     */
	    pI830->exa_offscreen =
		i830_allocate_memory(pScrn, "exa offscreen",
				     size, 1, NEED_LIFETIME_FIXED);
	    if (pI830->exa_offscreen == NULL) {
		xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
			   "Failed to allocate EXA offscreen memory.\n");
		return FALSE;
	    }
	}
    }
#endif /* I830_USE_EXA */

    if (!pI830->noAccel && !pI830->useEXA) {
	/* The lifetime fixed offset of xaa scratch is probably not required,
	 * but we do some setup using it at XAAInit() time.  And XAA may not
	 * end up being supported with TTM anyway.
	 */
	pI830->xaa_scratch =
	    i830_allocate_memory(pScrn, "xaa scratch", MAX_SCRATCH_BUFFER_SIZE,
				 GTT_PAGE_SIZE, NEED_LIFETIME_FIXED);
	if (pI830->xaa_scratch == NULL) {
	    pI830->xaa_scratch =
		i830_allocate_memory(pScrn, "xaa scratch",
				     MIN_SCRATCH_BUFFER_SIZE, GTT_PAGE_SIZE,
				     NEED_LIFETIME_FIXED);
	    if (pI830->xaa_scratch == NULL) {
		xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
			   "Failed to allocate scratch buffer space\n");
		return FALSE;
	    }
	}
d1372 1
a1372 24
	/* Let's allocate another scratch buffer for the second head */
	/* Again, this code won't execute on the dry run pass */
	if (pI830->entityPrivate && pI830->entityPrivate->pScrn_2)
	{
	    pI830->xaa_scratch_2 =
		i830_allocate_memory(pScrn, "xaa scratch 2",
				     MAX_SCRATCH_BUFFER_SIZE, GTT_PAGE_SIZE,
				     NEED_LIFETIME_FIXED);
	    if (pI830->xaa_scratch_2 == NULL) {
		pI830->xaa_scratch_2 =
		    i830_allocate_memory(pScrn, "xaa scratch 2",
					 MIN_SCRATCH_BUFFER_SIZE,
					 GTT_PAGE_SIZE, NEED_LIFETIME_FIXED);
		if (pI830->xaa_scratch_2 == NULL) {
		    xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
			       "Failed to allocate secondary scratch "
			       "buffer space\n");
		    return FALSE;
		}
	    }
	}
    }

    return TRUE;
d1374 1
d1376 3
a1378 3
#ifdef XF86DRI
static unsigned int
myLog2(unsigned int n)
d1380 1
a1380 1
    unsigned int log2 = 1;
d1382 1
a1382 6
    while (n > 1) {
	n >>= 1;
	log2++;
    }
    return log2;
}
d1384 2
a1385 40
static Bool
i830_allocate_backbuffer(ScrnInfoPtr pScrn, i830_memory **buffer,
			 const char *name)
{
    I830Ptr pI830 = I830PTR(pScrn);
    unsigned int pitch = pScrn->displayWidth * pI830->cpp;
    unsigned long size;
    int height;

    if (pI830->rotation & (RR_Rotate_0 | RR_Rotate_180))
	height = pScrn->virtualY;
    else
	height = pScrn->virtualX;

    /* Try to allocate on the best tile-friendly boundaries. */
    if (pI830->tiling && IsTileable(pScrn, pitch))
    {
	size = ROUND_TO_PAGE(pitch * ALIGN(height, 16));
	*buffer = i830_allocate_memory_tiled(pScrn, name, size, pitch,
					     GTT_PAGE_SIZE,
					     ALIGN_BOTH_ENDS |
					     ALLOW_SHARING,
					     TILE_XMAJOR);
    }

    /* Otherwise, just allocate it linear.  The offset must stay constant
     * currently because we don't ever update the DRI maps after screen init.
     */
    if (*buffer == NULL) {
	size = ROUND_TO_PAGE(pitch * height);
	*buffer = i830_allocate_memory(pScrn, name, size, GTT_PAGE_SIZE,
				       ALIGN_BOTH_ENDS |
				       ALLOW_SHARING);
    }

    if (*buffer == NULL) {
	xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
		   "Failed to allocate %s space.\n", name);
	return FALSE;
    }
d1387 26
a1412 1
    return TRUE;
d1415 1
a1415 49
static Bool
i830_allocate_depthbuffer(ScrnInfoPtr pScrn)
{
    I830Ptr pI830 = I830PTR(pScrn);
    unsigned long size;
    unsigned int pitch = pScrn->displayWidth * pI830->cpp;
    int height;

    /* XXX: this rotation stuff is bogus */
    if (pI830->rotation & (RR_Rotate_0 | RR_Rotate_180))
	height = pScrn->virtualY;
    else
	height = pScrn->virtualX;

    /* First try allocating it tiled */
    if (pI830->tiling && IsTileable(pScrn, pitch))
    {
	enum tile_format tile_format;

	size = ROUND_TO_PAGE(pitch * ALIGN(height, 16));

	/* The 965 requires that the depth buffer be in Y Major format, while
	 * the rest appear to fail when handed that format.
	 */
	tile_format = IS_I965G(pI830) ? TILE_YMAJOR: TILE_XMAJOR;

	pI830->depth_buffer =
	    i830_allocate_memory_tiled(pScrn, "depth buffer", size, pitch,
				       GTT_PAGE_SIZE,
				       ALIGN_BOTH_ENDS |
				       ALLOW_SHARING,
				       tile_format);
    }

    /* Otherwise, allocate it linear. The offset must stay constant
     * currently because we don't ever update the DRI maps after screen init.
     */
    if (pI830->depth_buffer == NULL) {
	size = ROUND_TO_PAGE(pitch * height);
	pI830->depth_buffer =
	    i830_allocate_memory(pScrn, "depth buffer", size, GTT_PAGE_SIZE,
				 ALLOW_SHARING);
    }

    if (pI830->depth_buffer == NULL) {
	xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
		   "Failed to allocate depth buffer space.\n");
	return FALSE;
    }
d1417 18
a1434 2
    return TRUE;
}
d1437 1
a1437 1
i830_allocate_texture_memory(ScrnInfoPtr pScrn)
d1439 3
a1441 34
    I830Ptr pI830 = I830PTR(pScrn);
    unsigned long size;
    int i;

    if (pI830->allocate_classic_textures) {
	/* XXX: auto-sizing */
	size = MB(32);
	i = myLog2(size / I830_NR_TEX_REGIONS);
	if (i < I830_LOG_MIN_TEX_REGION_SIZE)
	    i = I830_LOG_MIN_TEX_REGION_SIZE;
	pI830->TexGranularity = i;
	/* Truncate size */
	size >>= i;
	size <<= i;
	if (size < KB(512)) {
	    xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
		       "Less than 512 kBytes for texture space (real %ld"
		       "kBytes).\n",
		       size / 1024);
	    return FALSE;
	}
	/* The offset must stay constant currently because we don't ever update
	 * the DRI maps after screen init.
	 */
	pI830->textures = i830_allocate_memory(pScrn, "classic textures", size,
					       GTT_PAGE_SIZE,
					       ALLOW_SHARING |
					       NEED_LIFETIME_FIXED);
	if (pI830->textures == NULL) {
	    xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
		       "Failed to allocate texture space.\n");
	    return FALSE;
	}
    }
d1443 2
a1444 2
    return TRUE;
}
d1446 50
a1495 17
static Bool
i830_allocate_hwstatus(ScrnInfoPtr pScrn)
{
    I830Ptr pI830 = I830PTR(pScrn);

    /* The current DRM will leak the HWS mapping if we update the address
     * after init (at best), so allocate it fixed for its lifetime
     * (i.e. not through buffer objects).
     */
    pI830->hw_status = i830_allocate_memory(pScrn, "G33 hw status",
	    HWSTATUS_PAGE_SIZE, GTT_PAGE_SIZE, NEED_LIFETIME_FIXED);
    if (pI830->hw_status == NULL) {
	xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
		"Failed to allocate hw status page for G33.\n");
	return FALSE;
    }
    return TRUE;
d1499 1
a1499 1
i830_allocate_3d_memory(ScrnInfoPtr pScrn)
d1501 1
a1501 1
    I830Ptr pI830 = I830PTR(pScrn);
d1503 1
a1503 1
    DPRINTF(PFX, "i830_allocate_3d_memory\n");
d1505 29
a1533 4
    if (IS_G33CLASS(pI830)) {
	if (!i830_allocate_hwstatus(pScrn))
	    return FALSE;
    }
d1535 150
a1684 2
    if (!i830_allocate_backbuffer(pScrn, &pI830->back_buffer, "back buffer"))
	return FALSE;
d1686 2
a1687 7
    if (pI830->TripleBuffer && !i830_allocate_backbuffer(pScrn,
							 &pI830->third_buffer,
							 "third buffer")) {
       xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
		  "Failed to allocate third buffer, triple buffering "
		  "inactive\n");
    }
d1689 5
a1693 5
    if (!i830_allocate_depthbuffer(pScrn))
	return FALSE;

    if (!i830_allocate_texture_memory(pScrn))
	return FALSE;
d1695 5
a1699 2
    return TRUE;
}
d1702 13
a1714 45
/**
 * Sets up tiled surface registers ("fences") for the hardware.
 *
 * The fences control automatic tiled address swizzling for CPU access of the
 * framebuffer, and may be used in many rendering operations instead of
 * manually supplying tiling enables per surface.
 */
static int
i830_set_tiling(ScrnInfoPtr pScrn, unsigned int offset,
		unsigned int pitch, unsigned int size,
		enum tile_format tile_format)
{
    I830Ptr pI830 = I830PTR(pScrn);
    CARD32 val;
    CARD32 fence_mask = 0;
    unsigned int fence_pitch;
    unsigned int max_fence;
    unsigned int fence_nr;

    DPRINTF(PFX, "i830_set_tiling(): 0x%08x, %d, %d kByte\n",
	    offset, pitch, size / 1024);

    assert(tile_format != TILE_NONE);

    if (IS_I965G(pI830))
	max_fence = FENCE_NEW_NR;
    else
	max_fence = FENCE_NR;

    for (fence_nr = 0; fence_nr < max_fence; fence_nr++) {
	if (!pI830->fence_used[fence_nr])
	    break;
    }
    if (fence_nr == max_fence)
	FatalError("Ran out of fence registers at %d\n", fence_nr);

    pI830->fence_used[fence_nr] = TRUE;

    if (IS_I965G(pI830)) {
	uint32_t fence_start, fence_end;

	switch (tile_format) {
	case TILE_XMAJOR:
	    fence_start = (((pitch / 128) - 1) << 2) | offset | 1;
	    fence_start |= I965_FENCE_X_MAJOR;
d1716 1
a1716 1
	case TILE_YMAJOR:
d1720 5
a1724 2
	    fence_start = (((pitch / 128) - 1) << 2) | offset | 1;
	    fence_start |= I965_FENCE_Y_MAJOR;
d1726 1
a1726 3
	default:
	    return -1;
	}
d1728 20
a1747 2
	/* The end marker is the address of the last page in the allocation. */
	fence_end = offset + size - 4096;
d1749 5
a1753 38
	OUTREG(FENCE_NEW + fence_nr * 8, fence_start);
	OUTREG(FENCE_NEW + fence_nr * 8 + 4, fence_end);
    } else {
	if (IS_I9XX(pI830))
	    fence_mask = ~I915G_FENCE_START_MASK;
	else
	    fence_mask = ~I830_FENCE_START_MASK;

	if (offset & fence_mask) {
	    FatalError("i830_set_tiling(): %d: offset (0x%08x) is not %s "
		       "aligned\n",
		       fence_nr, offset, (IS_I9XX(pI830)) ? "1MB" : "512k");
	}

	if (offset % size) {
	    FatalError("i830_set_tiling(): %d: offset (0x%08x) is not "
		       "size (%dk) aligned\n",
		       fence_nr, offset, size / 1024);
	}

	if (pitch & 127) {
	    FatalError("i830_set_tiling(): %d: pitch (%d) not a multiple of "
		       "128 bytes\n",
		       fence_nr, pitch);
	}

	val = offset | FENCE_VALID;

	switch (tile_format) {
	case TILE_XMAJOR:
	    val |= FENCE_X_MAJOR;
	    break;
	case TILE_YMAJOR:
	    val |= FENCE_Y_MAJOR;
	    break;
	case TILE_NONE:
	    break;
	}
d1755 97
a1851 58
	if (IS_I9XX(pI830)) {
	    switch (size) {
	    case MB(1):
		val |= I915G_FENCE_SIZE_1M;
		break;
	    case MB(2):
		val |= I915G_FENCE_SIZE_2M;
		break;
	    case MB(4):
		val |= I915G_FENCE_SIZE_4M;
		break;
	    case MB(8):
		val |= I915G_FENCE_SIZE_8M;
		break;
	    case MB(16):
		val |= I915G_FENCE_SIZE_16M;
		break;
	    case MB(32):
		val |= I915G_FENCE_SIZE_32M;
		break;
	    case MB(64):
		val |= I915G_FENCE_SIZE_64M;
		break;
	    default:
		FatalError("i830_set_tiling(): %d: illegal size (%d kByte)\n",
			   fence_nr, size / 1024);
	    }
	} else {
	    switch (size) {
	    case KB(512):
		val |= FENCE_SIZE_512K;
		break;
	    case MB(1):
		val |= FENCE_SIZE_1M;
		break;
	    case MB(2):
		val |= FENCE_SIZE_2M;
		break;
	    case MB(4):
		val |= FENCE_SIZE_4M;
		break;
	    case MB(8):
		val |= FENCE_SIZE_8M;
		break;
	    case MB(16):
		val |= FENCE_SIZE_16M;
		break;
	    case MB(32):
		val |= FENCE_SIZE_32M;
		break;
	    case MB(64):
		val |= FENCE_SIZE_64M;
		break;
	    default:
		FatalError("i830_set_tiling(): %d: illegal size (%d kByte)\n",
			   fence_nr, size / 1024);
	    }
	}
d1853 5
a1857 34
	if ((IS_I945G(pI830) || IS_I945GM(pI830) || IS_G33CLASS(pI830)) &&
	    tile_format == TILE_YMAJOR)
	    fence_pitch = pitch / 128;
	else if (IS_I9XX(pI830))
	    fence_pitch = pitch / 512;
	else
	    fence_pitch = pitch / 128;

	switch (fence_pitch) {
	case 1:
	    val |= FENCE_PITCH_1;
	    break;
	case 2:
	    val |= FENCE_PITCH_2;
	    break;
	case 4:
	    val |= FENCE_PITCH_4;
	    break;
	case 8:
	    val |= FENCE_PITCH_8;
	    break;
	case 16:
	    val |= FENCE_PITCH_16;
	    break;
	case 32:
	    val |= FENCE_PITCH_32;
	    break;
	case 64:
	    val |= FENCE_PITCH_64;
	    break;
	default:
	    FatalError("i830_set_tiling(): %d: illegal pitch (%d)\n",
		       fence_nr, pitch);
	}
d1859 2
a1860 2
	OUTREG(FENCE + fence_nr * 4, val);
    }
d1862 1
a1862 1
    return fence_nr;
d1865 2
a1866 2
static void
i830_clear_tiling(ScrnInfoPtr pScrn, unsigned int fence_nr)
d1868 1
a1868 1
    I830Ptr pI830 = I830PTR(pScrn);
d1870 3
a1872 8
    if (IS_I965G(pI830)) {
	OUTREG(FENCE_NEW + fence_nr * 8, 0);
	OUTREG(FENCE_NEW + fence_nr * 8 + 4, 0);
    } else {
	OUTREG(FENCE + fence_nr * 4, 0);
    }
    pI830->fence_used[fence_nr] = FALSE;
}
d1874 2
a1875 11
/**
 * Called at EnterVT to grab the AGP GART and bind our allocations.
 *
 * In zaphod mode, this will walk the list trying to bind twice, since each
 * pI830 points to the same allocation list, but the bind_memory will just
 * no-op then.
 */
Bool
i830_bind_all_memory(ScrnInfoPtr pScrn)
{
    I830Ptr pI830 = I830PTR(pScrn);
d1877 3
a1879 2
    if (pI830->StolenOnly == TRUE || pI830->memory_list == NULL)
	return TRUE;
d1881 4
a1884 2
    if (xf86AgpGARTSupported() && !pI830->gtt_acquired) {
	i830_memory *mem;
d1886 21
a1906 1
	if (!xf86AcquireGART(pScrn->scrnIndex))
d1908 27
d1936 8
a1943 1
	pI830->gtt_acquired = TRUE;
d1945 2
a1946 16
	for (mem = pI830->memory_list->next; mem->next != NULL;
	     mem = mem->next)
	{
	    if (!i830_bind_memory(pScrn, mem)) {
		/* This shouldn't happen */
		FatalError("Couldn't bind memory for %s\n", mem->name);
	    }
	}
#ifdef XF86DRI_MM
	for (mem = pI830->bo_list; mem != NULL; mem = mem->next) {
	    if (!mem->lifetime_fixed_offset && !i830_bind_memory(pScrn, mem))
		FatalError("Couldn't bind memory for BO %s\n", mem->name);
	}
#endif
    }
    i830_update_cursor_offsets(pScrn);
d1948 1
a1948 1
    return TRUE;
d1951 1
a1951 1
/** Called at LeaveVT, to unbind all of our AGP allocations. */
d1953 1
a1953 1
i830_unbind_all_memory(ScrnInfoPtr pScrn)
d1955 5
a1959 1
    I830Ptr pI830 = I830PTR(pScrn);
d1961 2
a1962 2
    if (pI830->StolenOnly == TRUE)
	return TRUE;
d1964 5
a1968 16
    if (xf86AgpGARTSupported() && pI830->gtt_acquired) {
	i830_memory *mem;

	for (mem = pI830->memory_list->next; mem->next != NULL;
	     mem = mem->next)
	{
	    i830_unbind_memory(pScrn, mem);
	}
#ifdef XF86DRI_MM
	for (mem = pI830->bo_list; mem != NULL; mem = mem->next) {
	    /* Don't unpin objects which require that their offsets never
	     * change.
	     */
	    if (!mem->lifetime_fixed_offset)
		i830_unbind_memory(pScrn, mem);
	}
d1971 49
a2019 1
	pI830->gtt_acquired = FALSE;
d2021 2
a2022 3
	if (!xf86ReleaseGART(pScrn->scrnIndex))
	    return FALSE;
    }
d2024 1
a2024 1
    return TRUE;
a2026 4
/**
 * Returns the amount of system memory that could potentially be allocated
 * from AGP, in kB.
 */
d2030 2
a2031 2
    AgpInfoPtr agpinf;
    int maxPages;
d2033 9
a2041 9
    if (!xf86AgpGARTSupported() ||
	!xf86AcquireGART(pScrn->scrnIndex) ||
	(agpinf = xf86GetAGPInfo(pScrn->scrnIndex)) == NULL ||
	!xf86ReleaseGART(pScrn->scrnIndex))
	return -1;

    maxPages = agpinf->totalPages - agpinf->usedPages;
    xf86DrvMsgVerb(pScrn->scrnIndex, X_INFO, 2, "%s: %d kB available\n",
		   "I830CheckAvailableMemory", maxPages * 4);
d2043 1
a2043 1
    return maxPages * 4;
@


1.1.1.4
log
@Import intel driver v 2.2.0.90. tested by many, including krw@@ kettenis@@,
jakemsr@@, landry@@, beck@@ and oga@@. Thanks.
@
text
@a99 1
#include <inttypes.h>
a101 1
#include <sys/types.h>
d276 1
a276 1
	if (pI830->bo_list == mem) {
d278 4
a281 8
	    if (mem->next)
		mem->next->prev = NULL;
	} else {
	    if (mem->prev)
		mem->prev->next = mem->next;
	    if (mem->next)
		mem->next->prev = mem->prev;
	}
d598 2
a599 2
		       "Non-contiguous GTT entries: (%ld,0x16%" PRIx64 ") vs "
		       "(%ld,0x%" PRIx64 ")\n",
d947 1
a947 1
		    ", 0x%016" PRIx64 " physical\n", mem->bus_addr);
d1932 1
a1932 2
    if (!pI830->SWCursor)
	i830_update_cursor_offsets(pScrn);
@


