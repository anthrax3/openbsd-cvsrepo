head	1.21;
access;
symbols
	OPENBSD_5_0:1.19.0.6
	OPENBSD_5_0_BASE:1.19
	OPENBSD_4_9:1.19.0.2
	OPENBSD_4_9_BASE:1.19
	OPENBSD_4_8:1.19.0.4
	OPENBSD_4_8_BASE:1.19
	OPENBSD_4_7:1.15.0.2
	OPENBSD_4_7_BASE:1.15
	OPENBSD_4_6:1.14.0.2
	OPENBSD_4_6_BASE:1.14
	OPENBSD_4_5:1.13.0.2
	OPENBSD_4_5_BASE:1.13
	OPENBSD_4_4:1.9.0.2
	OPENBSD_4_4_BASE:1.9
	OPENBSD_4_3_BASE:1.6
	OPENBSD_4_3:1.6.0.2
	v2_2_0_90:1.1.1.5
	v2_2_0:1.1.1.4
	OPENBSD_4_2:1.2.0.2
	OPENBSD_4_2_BASE:1.2
	v1_7_4:1.1.1.3
	v1_7_3:1.1.1.2
	v1_7_2:1.1.1.1
	xorg:1.1.1;
locks; strict;
comment	@ * @;


1.21
date	2011.11.29.12.39.02;	author oga;	state dead;
branches;
next	1.20;

1.20
date	2011.09.13.19.31.42;	author matthieu;	state Exp;
branches;
next	1.19;

1.19
date	2010.07.18.14.47.47;	author oga;	state Exp;
branches;
next	1.18;

1.18
date	2010.05.23.21.28.34;	author oga;	state Exp;
branches;
next	1.17;

1.17
date	2010.05.10.22.32.29;	author oga;	state Exp;
branches;
next	1.16;

1.16
date	2010.04.07.18.22.00;	author oga;	state Exp;
branches;
next	1.15;

1.15
date	2009.09.10.02.30.26;	author oga;	state Exp;
branches;
next	1.14;

1.14
date	2009.06.25.20.16.43;	author matthieu;	state Exp;
branches;
next	1.13;

1.13
date	2008.12.01.20.51.41;	author matthieu;	state Exp;
branches;
next	1.12;

1.12
date	2008.11.06.22.30.11;	author matthieu;	state Exp;
branches;
next	1.11;

1.11
date	2008.10.12.15.25.43;	author matthieu;	state Exp;
branches;
next	1.10;

1.10
date	2008.10.12.15.20.50;	author matthieu;	state Exp;
branches;
next	1.9;

1.9
date	2008.06.29.20.13.42;	author matthieu;	state Exp;
branches;
next	1.8;

1.8
date	2008.05.21.20.19.52;	author matthieu;	state Exp;
branches;
next	1.7;

1.7
date	2008.03.30.13.51.30;	author matthieu;	state Exp;
branches;
next	1.6;

1.6
date	2008.02.11.20.16.03;	author matthieu;	state Exp;
branches;
next	1.5;

1.5
date	2007.12.08.17.53.07;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2007.11.25.18.44.17;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2007.11.24.20.08.18;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2007.08.04.19.55.21;	author reyk;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.26.20.06.42;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.11.26.20.06.42;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2006.12.16.21.01.54;	author matthieu;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2007.03.03.09.49.32;	author matthieu;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2007.11.24.19.44.58;	author matthieu;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2008.02.11.20.10.22;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.21
log
@Update the intel driver to a more recent version based on more recent
upsteam code.

Backporting keeping UMS changes by me, some bugfixes from kettenis@@.

Has been in snapshots for a while, committed on request so we can be
sure what people are running. This is a prerequesite for sandybridge
support but has those chipsets disabled for now until the correct code
has been added.
@
text
@/**************************************************************************

Copyright 2001 VA Linux Systems Inc., Fremont, California.
Copyright Â© 2002 by David Dawes

All Rights Reserved.

Permission is hereby granted, free of charge, to any person obtaining a
copy of this software and associated documentation files (the "Software"),
to deal in the Software without restriction, including without limitation
on the rights to use, copy, modify, merge, publish, distribute, sub
license, and/or sell copies of the Software, and to permit persons to whom
the Software is furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice (including the next
paragraph) shall be included in all copies or substantial portions of the
Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT. IN NO EVENT SHALL
THE COPYRIGHT HOLDERS AND/OR THEIR SUPPLIERS BE LIABLE FOR ANY CLAIM,
DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
USE OR OTHER DEALINGS IN THE SOFTWARE.

**************************************************************************/

/*
 * Authors: Jeff Hartmann <jhartmann@@valinux.com>
 *          Abraham van der Merwe <abraham@@2d3d.co.za>
 *          David Dawes <dawes@@xfree86.org>
 *          Alan Hourihane <alanh@@tungstengraphics.com>
 */

#ifdef HAVE_CONFIG_H
#include "config.h"
#endif

#ifndef PRINT_MODE_INFO
#define PRINT_MODE_INFO 0
#endif

#include <assert.h>
#include <string.h>
#include <stdio.h>
#include <unistd.h>
#include <stdlib.h>
#include <stdio.h>
#include <errno.h>
#include <poll.h>

#include "xf86.h"
#include "xf86_OSproc.h"
#include "xf86Priv.h"
#include "xf86cmap.h"
#include "compiler.h"
#include "mibstore.h"
#include "vgaHW.h"
#include "mipointer.h"
#include "micmap.h"
#include "shadowfb.h"
#include <X11/extensions/randr.h>
#include "fb.h"
#include "miscstruct.h"
#include "dixstruct.h"
#include "xf86xv.h"
#include <X11/extensions/Xv.h>
#include "shadow.h"
#include "i830.h"
#include "i830_display.h"
#include "i830_bios.h"
#include "i830_video.h"
#if HAVE_SYS_MMAN_H && HAVE_MPROTECT
#include <sys/mman.h>
#endif

#ifdef INTEL_XVMC
#define _INTEL_XVMC_SERVER_
#include "i830_hwmc.h"
#endif

#include <sys/ioctl.h>
#include "i915_drm.h"
#include <xf86drmMode.h>

#define BIT(x) (1 << (x))
#define MAX(a,b) ((a) > (b) ? (a) : (b))
#define NB_OF(x) (sizeof (x) / sizeof (*x))

/* *INDENT-OFF* */
static SymTabRec I830Chipsets[] = {
   {PCI_CHIP_I830_M,		"i830"},
   {PCI_CHIP_845_G,		"845G"},
   {PCI_CHIP_I855_GM,		"852GM/855GM"},
   {PCI_CHIP_I865_G,		"865G"},
   {PCI_CHIP_I915_G,		"915G"},
   {PCI_CHIP_E7221_G,		"E7221 (i915)"},
   {PCI_CHIP_I915_GM,		"915GM"},
   {PCI_CHIP_I945_G,		"945G"},
   {PCI_CHIP_I945_GM,		"945GM"},
   {PCI_CHIP_I945_GME,		"945GME"},
   {PCI_CHIP_IGD_GM,		"Pineview GM"},
   {PCI_CHIP_IGD_G,		"Pineview G"},
   {PCI_CHIP_I965_G,		"965G"},
   {PCI_CHIP_G35_G,		"G35"},
   {PCI_CHIP_I965_Q,		"965Q"},
   {PCI_CHIP_I946_GZ,		"946GZ"},
   {PCI_CHIP_I965_GM,		"965GM"},
   {PCI_CHIP_I965_GME,		"965GME/GLE"},
   {PCI_CHIP_G33_G,		"G33"},
   {PCI_CHIP_Q35_G,		"Q35"},
   {PCI_CHIP_Q33_G,		"Q33"},
   {PCI_CHIP_GM45_GM,		"GM45"},
   {PCI_CHIP_IGD_E_G,		"4 Series"},
   {PCI_CHIP_G45_G,		"G45/G43"},
   {PCI_CHIP_Q45_G,		"Q45/Q43"},
   {PCI_CHIP_G41_G,		"G41"},
   {PCI_CHIP_B43_G,		"B43"},
   {PCI_CHIP_IGDNG_D_G,		"Clarkdale"},
   {PCI_CHIP_IGDNG_M_G,		"Arrandale"},
   {-1,				NULL}
};

static PciChipsets I830PciChipsets[] = {
   {PCI_CHIP_I830_M,		PCI_CHIP_I830_M,	NULL},
   {PCI_CHIP_845_G,		PCI_CHIP_845_G,		NULL},
   {PCI_CHIP_I855_GM,		PCI_CHIP_I855_GM,	NULL},
   {PCI_CHIP_I865_G,		PCI_CHIP_I865_G,	NULL},
   {PCI_CHIP_I915_G,		PCI_CHIP_I915_G,	NULL},
   {PCI_CHIP_E7221_G,		PCI_CHIP_E7221_G,	NULL},
   {PCI_CHIP_I915_GM,		PCI_CHIP_I915_GM,	NULL},
   {PCI_CHIP_I945_G,		PCI_CHIP_I945_G,	NULL},
   {PCI_CHIP_I945_GM,		PCI_CHIP_I945_GM,	NULL},
   {PCI_CHIP_I945_GME,		PCI_CHIP_I945_GME,	NULL},
   {PCI_CHIP_IGD_GM,		PCI_CHIP_IGD_GM,	NULL},
   {PCI_CHIP_IGD_G,		PCI_CHIP_IGD_G,		NULL},
   {PCI_CHIP_I965_G,		PCI_CHIP_I965_G,	NULL},
   {PCI_CHIP_G35_G,		PCI_CHIP_G35_G,		NULL},
   {PCI_CHIP_I965_Q,		PCI_CHIP_I965_Q,	NULL},
   {PCI_CHIP_I946_GZ,		PCI_CHIP_I946_GZ,	NULL},
   {PCI_CHIP_I965_GM,		PCI_CHIP_I965_GM,	NULL},
   {PCI_CHIP_I965_GME,		PCI_CHIP_I965_GME,	NULL},
   {PCI_CHIP_G33_G,		PCI_CHIP_G33_G,		NULL},
   {PCI_CHIP_Q35_G,		PCI_CHIP_Q35_G,		NULL},
   {PCI_CHIP_Q33_G,		PCI_CHIP_Q33_G,		NULL},
   {PCI_CHIP_GM45_GM,		PCI_CHIP_GM45_GM,	NULL},
   {PCI_CHIP_IGD_E_G,		PCI_CHIP_IGD_E_G,	NULL},
   {PCI_CHIP_G45_G,		PCI_CHIP_G45_G,		NULL},
   {PCI_CHIP_Q45_G,		PCI_CHIP_Q45_G,		NULL},
   {PCI_CHIP_G41_G,		PCI_CHIP_G41_G,		NULL},
   {PCI_CHIP_B43_G,		PCI_CHIP_B43_G,		NULL},
   {PCI_CHIP_IGDNG_D_G,		PCI_CHIP_IGDNG_D_G,		NULL},
   {PCI_CHIP_IGDNG_M_G,		PCI_CHIP_IGDNG_M_G,		NULL},
   {-1,				-1,			NULL}
};

/*
 * Note: "ColorKey" is provided for compatibility with the i810 driver.
 * However, the correct option name is "VideoKey".  "ColorKey" usually
 * refers to the tranparency key for 8+24 overlays, not for video overlays.
 */

typedef enum {
   OPTION_DRI,
   OPTION_VIDEO_KEY,
   OPTION_COLOR_KEY,
   OPTION_MODEDEBUG,
   OPTION_FALLBACKDEBUG,
   OPTION_LVDS24BITMODE,
   OPTION_FBC,
   OPTION_TILING,
   OPTION_SWAPBUFFERS_WAIT,
   OPTION_LVDSFIXEDMODE,
   OPTION_FORCEENABLEPIPEA,
#ifdef INTEL_XVMC
   OPTION_XVMC,
#endif
   OPTION_PREFER_OVERLAY,
   OPTION_DEBUG_FLUSH_BATCHES,
   OPTION_DEBUG_FLUSH_CACHES,
   OPTION_DEBUG_WAIT,
} I830Opts;

static OptionInfoRec I830Options[] = {
   {OPTION_DRI,		"DRI",		OPTV_BOOLEAN,	{0},	TRUE},
   {OPTION_COLOR_KEY,	"ColorKey",	OPTV_INTEGER,	{0},	FALSE},
   {OPTION_VIDEO_KEY,	"VideoKey",	OPTV_INTEGER,	{0},	FALSE},
   {OPTION_MODEDEBUG,	"ModeDebug",	OPTV_BOOLEAN,	{0},	FALSE},
   {OPTION_FALLBACKDEBUG, "FallbackDebug", OPTV_BOOLEAN, {0},	FALSE},
   {OPTION_LVDS24BITMODE, "LVDS24Bit",	OPTV_BOOLEAN,	{0},	FALSE},
   {OPTION_FBC,		"FramebufferCompression", OPTV_BOOLEAN, {0}, TRUE},
   {OPTION_TILING,	"Tiling",	OPTV_BOOLEAN,	{0},	TRUE},
   {OPTION_SWAPBUFFERS_WAIT, "SwapbuffersWait", OPTV_BOOLEAN,	{0},	TRUE},
   {OPTION_LVDSFIXEDMODE, "LVDSFixedMode", OPTV_BOOLEAN,	{0},	FALSE},
   {OPTION_FORCEENABLEPIPEA, "ForceEnablePipeA", OPTV_BOOLEAN,	{0},	FALSE},
#ifdef INTEL_XVMC
   {OPTION_XVMC,	"XvMC",		OPTV_BOOLEAN,	{0},	TRUE},
#endif
   {OPTION_PREFER_OVERLAY, "XvPreferOverlay", OPTV_BOOLEAN, {0}, FALSE},
   {OPTION_DEBUG_FLUSH_BATCHES, "DebugFlushBatches", OPTV_BOOLEAN, {0}, FALSE},
   {OPTION_DEBUG_FLUSH_CACHES, "DebugFlushCaches", OPTV_BOOLEAN, {0}, FALSE},
   {OPTION_DEBUG_WAIT, "DebugWait", OPTV_BOOLEAN, {0}, FALSE},
   {-1,			NULL,		OPTV_NONE,	{0},	FALSE}
};
/* *INDENT-ON* */

static void i830AdjustFrame(int scrnIndex, int x, int y, int flags);
static Bool I830CloseScreen(int scrnIndex, ScreenPtr screen);
static Bool I830EnterVT(int scrnIndex, int flags);
static Bool SaveHWState(ScrnInfoPtr scrn);
static Bool RestoreHWState(ScrnInfoPtr scrn);

/* temporary */
extern void xf86SetCursor(ScreenPtr screen, CursorPtr pCurs, int x, int y);

#ifdef I830DEBUG
void
I830DPRINTF(const char *filename, int line, const char *function,
	    const char *fmt, ...)
{
	va_list ap;

	ErrorF("\n##############################################\n"
	       "*** In function %s, on line %d, in file %s ***\n",
	       function, line, filename);
	va_start(ap, fmt);
	VErrorF(fmt, ap);
	va_end(ap);
	ErrorF("##############################################\n\n");
}
#endif /* #ifdef I830DEBUG */

/* Export I830 options to i830 driver where necessary */
const OptionInfoRec *I830AvailableOptions(int chipid, int busid)
{
	int i;

	for (i = 0; I830PciChipsets[i].PCIid > 0; i++) {
		if (chipid == I830PciChipsets[i].PCIid)
			return I830Options;
	}
	return NULL;
}

static Bool I830GetRec(ScrnInfoPtr scrn)
{
	intel_screen_private *intel;

	if (scrn->driverPrivate)
		return TRUE;
	intel = scrn->driverPrivate = xnfcalloc(sizeof(intel_screen_private), 1);
	return TRUE;
}

static void I830FreeRec(ScrnInfoPtr scrn)
{
	if (!scrn)
		return;
	if (!scrn->driverPrivate)
		return;

	free(scrn->driverPrivate);
	scrn->driverPrivate = NULL;
}

static int
I830DetectMemory(ScrnInfoPtr scrn)
{
   intel_screen_private *intel = intel_get_screen_private(scrn);
   uint16_t gmch_ctrl;
   int memsize = 0, gtt_size;
   int range;
   struct pci_device *bridge = intel_host_bridge ();
   pci_device_cfg_read_u16(bridge, & gmch_ctrl, I830_GMCH_CTRL);

   if (IS_I965G(intel)) {
      /* The 965 may have a GTT that is actually larger than is necessary
       * to cover the aperture, so check the hardware's reporting of the
       * GTT size.
       */
      switch (INREG(PGETBL_CTL) & PGETBL_SIZE_MASK) {
      case PGETBL_SIZE_512KB:
	 gtt_size = 512;
	 break;
      case PGETBL_SIZE_256KB:
	 gtt_size = 256;
	 break;
      case PGETBL_SIZE_128KB:
	 gtt_size = 128;
	 break;
      case PGETBL_SIZE_1MB:
	 gtt_size = 1024;
	 break;
      case PGETBL_SIZE_2MB:
	 gtt_size = 2048;
	 break;
      case PGETBL_SIZE_1_5MB:
	 gtt_size = 1024 + 512;
	 break;
      default:
	 FatalError("Unknown GTT size value: %08x\n", (int)INREG(PGETBL_CTL));
      }
   } else if (IS_G33CLASS(intel)) {
      /* G33's GTT size is detect in GMCH_CTRL */
      switch (gmch_ctrl & G33_PGETBL_SIZE_MASK) {
      case G33_PGETBL_SIZE_1M:
	 gtt_size = 1024;
	 break;
      case G33_PGETBL_SIZE_2M:
	 gtt_size = 2048;
	 break;
      default:
	 FatalError("Unknown GTT size value: %08x\n",
		    (int)(gmch_ctrl & G33_PGETBL_SIZE_MASK));
      }
   } else {
      /* Older chipsets only had GTT appropriately sized for the aperture. */
      gtt_size = intel->FbMapSize / (1024*1024);
   }

   xf86DrvMsg(scrn->scrnIndex, X_INFO, "detected %d kB GTT.\n", gtt_size);

   /* The stolen memory has the GTT at the top, and the 4KB popup below that.
    * Everything else can be freely used by the graphics driver.
    */
   range = gtt_size + 4;

   /* new 4 series hardware has seperate GTT stolen with GFX stolen */
   if (IS_G4X(intel) || IS_IGD(intel) || IS_IGDNG(intel))
       range = 4;

   if (IS_I85X(intel) || IS_I865G(intel) || IS_I9XX(intel)) {
      switch (gmch_ctrl & I855_GMCH_GMS_MASK) {
      case I855_GMCH_GMS_STOLEN_1M:
	 memsize = MB(1) - KB(range);
	 break;
      case I855_GMCH_GMS_STOLEN_4M:
	 memsize = MB(4) - KB(range);
	 break;
      case I855_GMCH_GMS_STOLEN_8M:
	 memsize = MB(8) - KB(range);
	 break;
      case I855_GMCH_GMS_STOLEN_16M:
	 memsize = MB(16) - KB(range);
	 break;
      case I855_GMCH_GMS_STOLEN_32M:
	 memsize = MB(32) - KB(range);
	 break;
      case I915G_GMCH_GMS_STOLEN_48M:
	 if (IS_I9XX(intel))
	    memsize = MB(48) - KB(range);
	 break;
      case I915G_GMCH_GMS_STOLEN_64M:
	 if (IS_I9XX(intel))
	    memsize = MB(64) - KB(range);
	 break;
      case G33_GMCH_GMS_STOLEN_128M:
	 if (IS_I9XX(intel))
	     memsize = MB(128) - KB(range);
	 break;
      case G33_GMCH_GMS_STOLEN_256M:
	 if (IS_I9XX(intel))
	     memsize = MB(256) - KB(range);
	 break;
      case INTEL_GMCH_GMS_STOLEN_96M:
	 if (IS_I9XX(intel))
	     memsize = MB(96) - KB(range);
	 break;
      case INTEL_GMCH_GMS_STOLEN_160M:
	 if (IS_I9XX(intel))
	     memsize = MB(160) - KB(range);
	 break;
      case INTEL_GMCH_GMS_STOLEN_224M:
	 if (IS_I9XX(intel))
	     memsize = MB(224) - KB(range);
	 break;
      case INTEL_GMCH_GMS_STOLEN_352M:
	 if (IS_I9XX(intel))
	     memsize = MB(352) - KB(range);
	 break;
      }
   } else {
      switch (gmch_ctrl & I830_GMCH_GMS_MASK) {
      case I830_GMCH_GMS_STOLEN_512:
	 memsize = KB(512) - KB(range);
	 break;
      case I830_GMCH_GMS_STOLEN_1024:
	 memsize = MB(1) - KB(range);
	 break;
      case I830_GMCH_GMS_STOLEN_8192:
	 memsize = MB(8) - KB(range);
	 break;
      case I830_GMCH_GMS_LOCAL:
	 memsize = 0;
	 xf86DrvMsg(scrn->scrnIndex, X_WARNING,
		    "Local memory found, but won't be used.\n");
	 break;
      }
   }

#if 0
   /* And 64KB page aligned */
   memsize &= ~0xFFFF;
#endif

   if (memsize > 0) {
      xf86DrvMsg(scrn->scrnIndex, X_INFO,
		 "detected %d kB stolen memory.\n", memsize / 1024);
   } else {
      xf86DrvMsg(scrn->scrnIndex, X_INFO, "no video memory detected.\n");
   }

   return memsize;
}

static Bool
I830MapMMIO(ScrnInfoPtr scrn)
{
   int err;
   struct pci_device *device;
   intel_screen_private *intel = intel_get_screen_private(scrn);

   device = intel->PciInfo;
   err = pci_device_map_range (device,
			       intel->MMIOAddr,
			       intel->MMIOSize,
			       PCI_DEV_MAP_FLAG_WRITABLE,
			       (void **) &intel->MMIOBase);
   if (err) 
   {
      xf86DrvMsg (scrn->scrnIndex, X_ERROR,
		  "Unable to map mmio range. %s (%d)\n",
		  strerror (err), err);
      return FALSE;
   }

   /* Set up the GTT mapping for the various places it has been moved over
    * time.
    */
   if (IS_I9XX(intel)) {
      uint32_t gttaddr;

      if (IS_I965G(intel)) 
      {
	 if (IS_G4X(intel) || IS_IGDNG(intel)) {
	     gttaddr = intel->MMIOAddr + MB(2);
	     intel->GTTMapSize = MB(2);
	 } else {
	     gttaddr = intel->MMIOAddr + KB(512);
	     intel->GTTMapSize = KB(512);
	 }
      }
      else
      {
	 gttaddr = I810_MEMBASE(intel->PciInfo, 3) & 0xFFFFFF00;
	 intel->GTTMapSize = intel->FbMapSize / 1024;
      }
      err = pci_device_map_range (device,
				  gttaddr, intel->GTTMapSize,
				  PCI_DEV_MAP_FLAG_WRITABLE,
				  (void **) &intel->GTTBase);
      if (err)
      {
	 xf86DrvMsg (scrn->scrnIndex, X_ERROR,
		     "Unable to map GTT range. %s (%d)\n",
		     strerror (err), err);
	 return FALSE;
      }
   } else {
      /* The GTT aperture on i830 is write-only.  We could probably map the
       * actual physical pages that back it, but leave it alone for now.
       */
      intel->GTTBase = NULL;
      intel->GTTMapSize = 0;
   }

   return TRUE;
}

static Bool
I830MapMem(ScrnInfoPtr scrn)
{
   intel_screen_private *intel = intel_get_screen_private(scrn);
   long i;
   struct pci_device *const device = intel->PciInfo;
   int err;

   for (i = 2; i < intel->FbMapSize; i <<= 1) ;
   intel->FbMapSize = i;

   err = pci_device_map_range (device, intel->LinearAddr, intel->FbMapSize,
			       PCI_DEV_MAP_FLAG_WRITABLE | PCI_DEV_MAP_FLAG_WRITE_COMBINE,
			       (void **) &intel->FbBase);
    if (err)
	return FALSE;

   return TRUE;
}

static void
I830UnmapMMIO(ScrnInfoPtr scrn)
{
   intel_screen_private *intel = intel_get_screen_private(scrn);

   pci_device_unmap_range (intel->PciInfo, intel->MMIOBase, intel->MMIOSize);
   intel->MMIOBase = NULL;

   if (IS_I9XX(intel)) {
      pci_device_unmap_range (intel->PciInfo, intel->GTTBase, intel->GTTMapSize);
      intel->GTTBase = NULL;
   }
}

static Bool
I830UnmapMem(ScrnInfoPtr scrn)
{
   intel_screen_private *intel = intel_get_screen_private(scrn);

   pci_device_unmap_range (intel->PciInfo, intel->FbBase, intel->FbMapSize);
   intel->FbBase = NULL;
   I830UnmapMMIO(scrn);
   return TRUE;
}

static void
I830LoadPalette(ScrnInfoPtr scrn, int numColors, int *indices,
		LOCO * colors, VisualPtr pVisual)
{
	xf86CrtcConfigPtr xf86_config = XF86_CRTC_CONFIG_PTR(scrn);
	int i, j, index;
	int p;
	uint16_t lut_r[256], lut_g[256], lut_b[256];

	DPRINTF(PFX, "I830LoadPalette: numColors: %d\n", numColors);

	for (p = 0; p < xf86_config->num_crtc; p++) {
		xf86CrtcPtr crtc = xf86_config->crtc[p];
		I830CrtcPrivatePtr intel_crtc = crtc->driver_private;

		/* Initialize to the old lookup table values. */
		for (i = 0; i < 256; i++) {
			lut_r[i] = intel_crtc->lut_r[i] << 8;
			lut_g[i] = intel_crtc->lut_g[i] << 8;
			lut_b[i] = intel_crtc->lut_b[i] << 8;
		}

		switch (scrn->depth) {
		case 15:
			for (i = 0; i < numColors; i++) {
				index = indices[i];
				for (j = 0; j < 8; j++) {
					lut_r[index * 8 + j] =
					    colors[index].red << 8;
					lut_g[index * 8 + j] =
					    colors[index].green << 8;
					lut_b[index * 8 + j] =
					    colors[index].blue << 8;
				}
			}
			break;
		case 16:
			for (i = 0; i < numColors; i++) {
				index = indices[i];

				if (index <= 31) {
					for (j = 0; j < 8; j++) {
						lut_r[index * 8 + j] =
						    colors[index].red << 8;
						lut_b[index * 8 + j] =
						    colors[index].blue << 8;
					}
				}

				for (j = 0; j < 4; j++) {
					lut_g[index * 4 + j] =
					    colors[index].green << 8;
				}
			}
			break;
		default:
			for (i = 0; i < numColors; i++) {
				index = indices[i];
				lut_r[index] = colors[index].red << 8;
				lut_g[index] = colors[index].green << 8;
				lut_b[index] = colors[index].blue << 8;
			}
			break;
		}

		/* Make the change through RandR */
#ifdef RANDR_12_INTERFACE
		RRCrtcGammaSet(crtc->randr_crtc, lut_r, lut_g, lut_b);
#else
		crtc->funcs->gamma_set(crtc, lut_r, lut_g, lut_b, 256);
#endif
	}
}

/**
 * Adjust the screen pixmap for the current location of the front buffer.
 * This is done at EnterVT when buffers are bound as long as the resources
 * have already been created, but the first EnterVT happens before
 * CreateScreenResources.
 */
static Bool i830CreateScreenResources(ScreenPtr screen)
{
	ScrnInfoPtr scrn = xf86Screens[screen->myNum];
	intel_screen_private *intel = intel_get_screen_private(scrn);

	screen->CreateScreenResources = intel->CreateScreenResources;
	if (!(*screen->CreateScreenResources) (screen))
		return FALSE;

	i830_uxa_create_screen_resources(screen);

	return TRUE;
}

static int i830_output_clones (ScrnInfoPtr scrn, int type_mask)
{
	xf86CrtcConfigPtr	config = XF86_CRTC_CONFIG_PTR (scrn);
	int			o;
	int			index_mask = 0;

	for (o = 0; o < config->num_output; o++) {
		xf86OutputPtr		output = config->output[o];
		I830OutputPrivatePtr	intel_output = output->driver_private;
		if (type_mask & (1 << intel_output->type))
			index_mask |= (1 << o);
	}
	return index_mask;
}

/**
 * Set up the outputs according to what type of chip we are.
 *
 * Some outputs may not initialize, due to allocation failure or because a
 * controller chip isn't found.
 */
static void I830SetupOutputs(ScrnInfoPtr scrn)
{
	xf86CrtcConfigPtr	config = XF86_CRTC_CONFIG_PTR (scrn);
	intel_screen_private *intel = intel_get_screen_private(scrn);
	int	    o, c;
	Bool	    lvds_detected = FALSE;

	/* everyone has at least a single analog output */
	i830_crt_init(scrn);

	/* Set up integrated LVDS */
	if (IS_MOBILE(intel) && !IS_I830(intel))
	i830_lvds_init(scrn);

	if (IS_IGDNG(intel)) {
		int found;

		if (INREG(HDMIB) & PORT_DETECTED) {
			/* check SDVOB */
			/* found = intel_sdvo_init(dev, HDMIB); */
			found = 0;
			if (!found)
				i830_hdmi_init(scrn, HDMIB);
		}

		if (INREG(HDMIC) & PORT_DETECTED)
			i830_hdmi_init(scrn, HDMIC);

		if (INREG(HDMID) & PORT_DETECTED)
			i830_hdmi_init(scrn, HDMID);

		/* Disable DP by force */
		OUTREG(PCH_DP_B, INREG(PCH_DP_B) & ~PORT_ENABLE);
		OUTREG(PCH_DP_C, INREG(PCH_DP_C) & ~PORT_ENABLE);
		OUTREG(PCH_DP_D, INREG(PCH_DP_D) & ~PORT_ENABLE);

	} else if (IS_I9XX(intel)) {
		Bool found = FALSE;
		if ((INREG(SDVOB) & SDVO_DETECTED)) {
			found = i830_sdvo_init(scrn, SDVOB);

			if (!found && SUPPORTS_INTEGRATED_HDMI(intel))
			i830_hdmi_init(scrn, SDVOB);
		}

		if ((INREG(SDVOB) & SDVO_DETECTED))
			found = i830_sdvo_init(scrn, SDVOC);

		if ((INREG(SDVOC) & SDVO_DETECTED) &&
		    !found && SUPPORTS_INTEGRATED_HDMI(intel))
			i830_hdmi_init(scrn, SDVOC);

	} else {
		i830_dvo_init(scrn);
	}
	if (IS_I9XX(intel) && IS_MOBILE(intel) && !IS_IGDNG(intel))
		i830_tv_init(scrn);
   
	for (o = 0; o < config->num_output; o++) {
		xf86OutputPtr	   output = config->output[o];
		I830OutputPrivatePtr intel_output = output->driver_private;
		int		   crtc_mask;

		if (intel_output->type == I830_OUTPUT_LVDS)
			lvds_detected = TRUE;
      
		crtc_mask = 0;
		for (c = 0; c < config->num_crtc; c++) {
			xf86CrtcPtr	      crtc = config->crtc[c];
			I830CrtcPrivatePtr   intel_crtc = crtc->driver_private;

			if (intel_output->pipe_mask & (1 << intel_crtc->pipe))
				crtc_mask |= (1 << c);
		}
		output->possible_crtcs = crtc_mask;
		output->possible_clones =
		    i830_output_clones(scrn, intel_output->clone_mask);
	}
}

static void i830_init_clock_gating(ScrnInfoPtr scrn)
{
    intel_screen_private *intel = intel_get_screen_private(scrn);

    /* Disable clock gating reported to work incorrectly according to the specs.
     */
	if (IS_G4X(intel)) {
		uint32_t dspclk_gate;
		OUTREG(RENCLK_GATE_D1, 0);
		OUTREG(RENCLK_GATE_D2, VF_UNIT_CLOCK_GATE_DISABLE |
		    GS_UNIT_CLOCK_GATE_DISABLE | CL_UNIT_CLOCK_GATE_DISABLE);
		OUTREG(RAMCLK_GATE_D, 0);
		dspclk_gate = VRHUNIT_CLOCK_GATE_DISABLE |
		    OVRUNIT_CLOCK_GATE_DISABLE | OVCUNIT_CLOCK_GATE_DISABLE;
		if (IS_GM45(intel))
			dspclk_gate |= DSSUNIT_CLOCK_GATE_DISABLE;
		OUTREG(DSPCLK_GATE_D, dspclk_gate);
	} else if (IS_I965GM(intel)) {
		OUTREG(RENCLK_GATE_D1, I965_RCC_CLOCK_GATE_DISABLE);
		OUTREG(RENCLK_GATE_D2, 0);
		OUTREG(DSPCLK_GATE_D, 0);
		OUTREG(RAMCLK_GATE_D, 0);
		OUTREG16(DEUC, 0);
	} else if (IS_I965G(intel)) {
		OUTREG(RENCLK_GATE_D1, I965_RCZ_CLOCK_GATE_DISABLE |
		    I965_RCC_CLOCK_GATE_DISABLE | I965_RCPB_CLOCK_GATE_DISABLE |
		    I965_ISC_CLOCK_GATE_DISABLE | I965_FBC_CLOCK_GATE_DISABLE);
		OUTREG(RENCLK_GATE_D2, 0);
	} else if (IS_I855(intel) || IS_I865G(intel)) {
		OUTREG(RENCLK_GATE_D1, SV_CLOCK_GATE_DISABLE);
	} else if (IS_I830(intel)) {
		OUTREG(DSPCLK_GATE_D, OVRUNIT_CLOCK_GATE_DISABLE);
	}
}

static void i830_init_bios_control(ScrnInfoPtr scrn)
{
	intel_screen_private *intel = intel_get_screen_private(scrn);

	/* Set "extended desktop" */
	OUTREG(SWF0, INREG(SWF0) | (1 << 21));

	/* Set "driver loaded",  "OS unknown", "APM 1.2" */
	OUTREG(SWF4, (INREG(SWF4) & ~((3 << 19) | (7 << 16))) |
	    (1 << 23) | (2 << 16));
}

static int
I830LVDSPresent(ScrnInfoPtr scrn)
{
	xf86CrtcConfigPtr config = XF86_CRTC_CONFIG_PTR (scrn);
	int o, lvds_detected = FALSE;

	for (o = 0; o < config->num_output; o++) {
		xf86OutputPtr	   output = config->output[o];
		I830OutputPrivatePtr intel_output = output->driver_private;

		if (intel_output->type == I830_OUTPUT_LVDS)
			lvds_detected = TRUE;
	}

	return lvds_detected;
}

/**
 * Setup the CRTCs
 */

static void 
I830PreInitDDC(ScrnInfoPtr scrn)
{
	intel_screen_private *intel = intel_get_screen_private(scrn);

	if (!xf86LoadSubModule(scrn, "ddc")) {
		intel->ddc2 = FALSE;
	} else {
		intel->ddc2 = TRUE;
	}

	/* DDC can use I2C bus */
	/* Load I2C if we have the code to use it */
	if (intel->ddc2) {
		if (xf86LoadSubModule(scrn, "i2c")) {
			intel->ddc2 = TRUE;
		} else {
			intel->ddc2 = FALSE;
		}
	}
}

static void PreInitCleanup(ScrnInfoPtr scrn)
{
	intel_screen_private *intel = intel_get_screen_private(scrn);

	if (intel->MMIOBase)
		I830UnmapMMIO(scrn);
	I830FreeRec(scrn);
}

/*
 * Adjust *width to allow for tiling if possible
 */
Bool i830_tiled_width(intel_screen_private *intel, int *width, int cpp)
{
	Bool tiled = FALSE;

	/*
	 * Adjust the display width to allow for front buffer tiling if possible
	 */
	if (intel->tiling) {
		if (IS_I965G(intel)) {
			int tile_pixels = 512 / cpp;
			*width = (*width + tile_pixels - 1) &
			    ~(tile_pixels - 1);
			tiled = TRUE;
		} else {
			/* Good pitches to allow tiling.  Don't care about pitches < 1024
			 * pixels.
			 */
			static const int pitches[] = {
				1024,
				2048,
				4096,
				8192,
				0
			};
			int pitch;
			int i;

			pitch = *width * cpp;
			for (i = 0; pitches[i] != 0; i++) {
				if (pitches[i] >= pitch) {
					*width = pitches[i] / cpp;
					tiled = TRUE;
					break;
				}
			}
		}
	}
	return tiled;
}

static Bool i830_xf86crtc_resize(ScrnInfoPtr scrn, int width, int height)
{
#ifdef DRI2
	intel_screen_private *intel = intel_get_screen_private(scrn);
	int old_width = scrn->displayWidth;
#endif
	int old_x = scrn->virtualX;
	int old_y = scrn->virtualY;

	if (old_x == width && old_y == height)
		return TRUE;

	scrn->virtualX = width;
	scrn->virtualY = height;
#ifdef DRI2
	if (intel->front_buffer) {
		i830_memory *new_front, *old_front;
		Bool tiled;
		ScreenPtr screen = screenInfo.screens[scrn->scrnIndex];

		scrn->displayWidth = i830_pad_drawable_width(width);
		tiled = i830_tiled_width(intel, &scrn->displayWidth, intel->cpp);
		xf86DrvMsg(scrn->scrnIndex, X_INFO,
			   "Allocate new frame buffer %dx%d stride %d\n", width,
			   height, scrn->displayWidth);
		intel_sync(scrn);
		i830WaitForVblank(scrn);
		new_front = i830_allocate_framebuffer(scrn);
		if (!new_front) {
			scrn->virtualX = old_x;
			scrn->virtualY = old_y;
			scrn->displayWidth = old_width;
			return FALSE;
		}
		old_front = intel->front_buffer;
		intel->front_buffer = new_front;
		i830_set_pixmap_bo(screen->GetScreenPixmap(screen),
				   new_front->bo);
		scrn->fbOffset = intel->front_buffer->offset;

		screen->ModifyPixmapHeader(screen->GetScreenPixmap(screen),
					   width, height, -1, -1,
					   scrn->displayWidth * intel->cpp,
					   intel->FbBase + scrn->fbOffset);

		/* ick. xf86EnableDisableFBAccess smashes the screen pixmap devPrivate,
		 * so update the value it uses
		 */
#if XORG_VERSION_CURRENT < XORG_VERSION_NUMERIC(1,9,99,1,0)
		scrn->pixmapPrivate.ptr = intel->FbBase + scrn->fbOffset;
#endif
		xf86DrvMsg(scrn->scrnIndex, X_INFO,
			   "New front buffer at 0x%lx\n",
			   intel->front_buffer->offset);
		i830_set_new_crtc_bo(scrn);
		intel_sync(scrn);
		i830WaitForVblank(scrn);
		i830_free_memory(scrn, old_front);
	}
#endif
	return TRUE;
}

static const xf86CrtcConfigFuncsRec i830_xf86crtc_config_funcs = {
	i830_xf86crtc_resize
};

#define HOTKEY_BIOS_SWITCH	0
#define HOTKEY_DRIVER_NOTIFY	1

/**
 * Controls the BIOS's behavior on hotkey switch.
 *
 * If the mode is HOTKEY_BIOS_SWITCH, the BIOS will be set to do a mode switch
 * on its own and update the state in the scratch register.
 * If the mode is HOTKEY_DRIVER_NOTIFY, the BIOS won't do a mode switch and
 * will just update the state to represent what it would have been switched to.
 */
static void
i830SetHotkeyControl(ScrnInfoPtr scrn, int mode)
{
   intel_screen_private *intel = intel_get_screen_private(scrn);
   uint8_t gr18;

   /* Don't mess with kernel settings... */
   if (intel->use_drm_mode)
       return;

   gr18 = intel->readControl(intel, GRX, 0x18);
   if (mode == HOTKEY_BIOS_SWITCH)
      gr18 &= ~HOTKEY_VBIOS_SWITCH_BLOCK;
   else
      gr18 |= HOTKEY_VBIOS_SWITCH_BLOCK;
   intel->writeControl(intel, GRX, 0x18, gr18);
}

/*
 * DRM mode setting Linux only at this point... later on we could
 * add a wrapper here.
 */
static Bool i830_kernel_mode_enabled(ScrnInfoPtr scrn)
{
	struct pci_device *PciInfo;
	EntityInfoPtr pEnt;
	char *busIdString;
	int ret;

	pEnt = xf86GetEntityInfo(scrn->entityList[0]);
	PciInfo = xf86GetPciInfoForEntity(pEnt->index);

	if (!xf86LoaderCheckSymbol("DRICreatePCIBusID"))
		return FALSE;

	busIdString = DRICreatePCIBusID(PciInfo);

	ret = drmCheckModesettingSupported(busIdString);
	if (ret) {
		if (xf86LoadKernelModule("i915"))
			ret = drmCheckModesettingSupported(busIdString);
	}
	/* Be nice to the user and load fbcon too */
	if (!ret)
		(void)xf86LoadKernelModule("fbcon");
	free(busIdString);
	if (ret)
		return FALSE;

	return TRUE;
}

static Bool i830_detect_chipset(ScrnInfoPtr scrn)
{
	intel_screen_private *intel = intel_get_screen_private(scrn);
	MessageType from = X_PROBED;
	const char *chipname;
	uint32_t capid;
	int fb_bar, mmio_bar;

	/* We have to use PIO to probe, because we haven't mapped yet. */
	if (!intel->use_drm_mode)
		I830SetPIOAccess(intel);

	switch (DEVICE_ID(intel->PciInfo)) {
	case PCI_CHIP_I830_M:
		chipname = "830M";
		break;
	case PCI_CHIP_845_G:
		chipname = "845G";
		break;
	case PCI_CHIP_I855_GM:
		/* Check capid register to find the chipset variant */
		pci_device_cfg_read_u32(intel->PciInfo, &capid, I85X_CAPID);
		intel->variant =
		    (capid >> I85X_VARIANT_SHIFT) & I85X_VARIANT_MASK;
		switch (intel->variant) {
		case I855_GM:
			chipname = "855GM";
			break;
		case I855_GME:
			chipname = "855GME";
			break;
		case I852_GM:
			chipname = "852GM";
			break;
		case I852_GME:
			chipname = "852GME";
			break;
		default:
			xf86DrvMsg(scrn->scrnIndex, X_INFO,
				   "Unknown 852GM/855GM variant: 0x%x)\n",
				   intel->variant);
			chipname = "852GM/855GM (unknown variant)";
			break;
		}
		break;
	case PCI_CHIP_I865_G:
		chipname = "865G";
		break;
	case PCI_CHIP_I915_G:
		chipname = "915G";
		break;
	case PCI_CHIP_E7221_G:
		chipname = "E7221 (i915)";
		break;
	case PCI_CHIP_I915_GM:
		chipname = "915GM";
		break;
	case PCI_CHIP_I945_G:
		chipname = "945G";
		break;
	case PCI_CHIP_I945_GM:
		chipname = "945GM";
		break;
	case PCI_CHIP_I945_GME:
		chipname = "945GME";
		break;
	case PCI_CHIP_IGD_GM:
		chipname = "Pineview GM";
		break;
	case PCI_CHIP_IGD_G:
		chipname = "Pineview G";
		break;
	case PCI_CHIP_I965_G:
		chipname = "965G";
		break;
	case PCI_CHIP_G35_G:
		chipname = "G35";
		break;
	case PCI_CHIP_I965_Q:
		chipname = "965Q";
		break;
	case PCI_CHIP_I946_GZ:
		chipname = "946GZ";
		break;
	case PCI_CHIP_I965_GM:
		chipname = "965GM";
		break;
	case PCI_CHIP_I965_GME:
		chipname = "965GME/GLE";
		break;
	case PCI_CHIP_G33_G:
		chipname = "G33";
		break;
	case PCI_CHIP_Q35_G:
		chipname = "Q35";
		break;
	case PCI_CHIP_Q33_G:
		chipname = "Q33";
		break;
	case PCI_CHIP_GM45_GM:
		chipname = "GM45";
		break;
	case PCI_CHIP_IGD_E_G:
		chipname = "4 Series";
		break;
	case PCI_CHIP_G45_G:
		chipname = "G45/G43";
		break;
	case PCI_CHIP_Q45_G:
		chipname = "Q45/Q43";
		break;
	case PCI_CHIP_G41_G:
		chipname = "G41";
		break;
	case PCI_CHIP_B43_G:
		chipname = "B43";
		break;
	case PCI_CHIP_IGDNG_D_G:
		chipname = "Clarkdale";
		break;
	case PCI_CHIP_IGDNG_M_G:
		chipname = "Arrandale";
		break;
	default:
		chipname = "unknown chipset";
		break;
	}

	xf86DrvMsg(scrn->scrnIndex, X_INFO,
		   "Integrated Graphics Chipset: Intel(R) %s\n", chipname);

	/* Set the Chipset and ChipRev, allowing config file entries to override. */
	if (intel->pEnt->device->chipset && *intel->pEnt->device->chipset) {
		scrn->chipset = intel->pEnt->device->chipset;
		from = X_CONFIG;
	} else if (intel->pEnt->device->chipID >= 0) {
		scrn->chipset = (char *)xf86TokenToString(I830Chipsets,
							   intel->pEnt->device->
							   chipID);
		from = X_CONFIG;
		xf86DrvMsg(scrn->scrnIndex, X_CONFIG,
			   "ChipID override: 0x%04X\n",
			   intel->pEnt->device->chipID);
		DEVICE_ID(intel->PciInfo) = intel->pEnt->device->chipID;
	} else {
		from = X_PROBED;
		scrn->chipset = (char *)xf86TokenToString(I830Chipsets,
							   DEVICE_ID(intel->
								     PciInfo));
	}

	if (intel->pEnt->device->chipRev >= 0) {
		xf86DrvMsg(scrn->scrnIndex, X_CONFIG, "ChipRev override: %d\n",
			   intel->pEnt->device->chipRev);
	}

	xf86DrvMsg(scrn->scrnIndex, from, "Chipset: \"%s\"\n",
		   (scrn->chipset != NULL) ? scrn->chipset : "Unknown i8xx");
	/* Check if the HW cursor needs physical address. */
	if (IS_MOBILE(intel) || IS_I9XX(intel))
		intel->CursorNeedsPhysical = TRUE;
	else
		intel->CursorNeedsPhysical = FALSE;

	if (IS_I965G(intel) || IS_G33CLASS(intel))
		intel->CursorNeedsPhysical = FALSE;

	/* Skip the rest if the kernel is taking care of things */
	if (intel->use_drm_mode)
		return TRUE;

	/* Now that we know the chipset, figure out the resource base addrs */
	if (IS_I9XX(intel)) {
		fb_bar = 2;
		mmio_bar = 0;
	} else {
		fb_bar = 0;
		mmio_bar = 1;
	}

	if (intel->pEnt->device->MemBase != 0) {
		intel->LinearAddr = intel->pEnt->device->MemBase;
		from = X_CONFIG;
	} else {
		intel->LinearAddr = I810_MEMBASE (intel->PciInfo, fb_bar);
		if (intel->LinearAddr == 0) {
			xf86DrvMsg(scrn->scrnIndex, X_ERROR,
			    "No valid FB address in PCI config space\n");
			PreInitCleanup(scrn);
			return FALSE;
		}
	}

	xf86DrvMsg(scrn->scrnIndex, from, "Linear framebuffer at 0x%lX\n",
	    (unsigned long)intel->LinearAddr);

	if (intel->pEnt->device->IOBase != 0) {
		intel->MMIOAddr = intel->pEnt->device->IOBase;
		from = X_CONFIG;
		intel->MMIOSize = I810_REG_SIZE;
	} else {
		intel->MMIOAddr = I810_MEMBASE (intel->PciInfo, mmio_bar);
		if (intel->MMIOAddr == 0) {
			xf86DrvMsg(scrn->scrnIndex, X_ERROR,
			    "No valid MMIO address in PCI config space\n");
			PreInitCleanup(scrn);
			return FALSE;
		}
		intel->MMIOSize = intel->PciInfo->regions[mmio_bar].size;
	}

	xf86DrvMsg(scrn->scrnIndex, from,
	    "IO registers at addr 0x%lX size %u\n",
	    (unsigned long)intel->MMIOAddr, intel->MMIOSize);

	/* Now figure out mapsize on 8xx chips */
	if (IS_I830(intel) || IS_845G(intel)) {
		uint16_t		gmch_ctrl;
		struct pci_device *bridge;

		bridge = intel_host_bridge ();
		pci_device_cfg_read_u16 (bridge, &gmch_ctrl, I830_GMCH_CTRL);
		if ((gmch_ctrl & I830_GMCH_MEM_MASK) == I830_GMCH_MEM_128M) {
			intel->FbMapSize = 0x8000000;
		} else {
			/* 64MB - has this been tested ?? */
			intel->FbMapSize = 0x4000000;
		}
	} else {
		if (IS_I9XX(intel)) {
			intel->FbMapSize = intel->PciInfo->regions[fb_bar].size;
		} else {
			/* 128MB aperture for later i8xx series. */
			intel->FbMapSize = 0x8000000;
		}
	}

    return TRUE;
}

static Bool I830LoadSyms(ScrnInfoPtr scrn)
{
	intel_screen_private *intel = intel_get_screen_private(scrn);

	if (intel->use_drm_mode)
		return TRUE;

	/* The vgahw module should be loaded here when needed */
	if (!xf86LoadSubModule(scrn, "vgahw"))
		return FALSE;

	if (!xf86LoadSubModule(scrn, "ramdac"))
		return FALSE;

	return TRUE;
}

static Bool I830GetEarlyOptions(ScrnInfoPtr scrn)
{
	intel_screen_private *intel = intel_get_screen_private(scrn);

	/* Process the options */
	xf86CollectOptions(scrn, NULL);
	if (!(intel->Options = malloc(sizeof(I830Options))))
		return FALSE;
	memcpy(intel->Options, I830Options, sizeof(I830Options));
	xf86ProcessOptions(scrn->scrnIndex, scrn->options, intel->Options);

	intel->fallback_debug = xf86ReturnOptValBool(intel->Options,
						     OPTION_FALLBACKDEBUG,
						     FALSE);

	if (xf86ReturnOptValBool(intel->Options, OPTION_MODEDEBUG, FALSE)) {
		intel->debug_modes = TRUE;
	} else {
		intel->debug_modes = FALSE;
	}

	if (xf86ReturnOptValBool(intel->Options, OPTION_LVDS24BITMODE, FALSE)) {
		intel->lvds_24_bit_mode = TRUE;
	} else {
		intel->lvds_24_bit_mode = FALSE;
	}

	if (xf86ReturnOptValBool(intel->Options, OPTION_LVDSFIXEDMODE, TRUE)) {
		intel->skip_panel_detect = FALSE;
	} else {
		intel->skip_panel_detect = TRUE;
	}

	if (xf86ReturnOptValBool(intel->Options,
	    OPTION_FORCEENABLEPIPEA, FALSE))
		intel->quirk_flag |= QUIRK_PIPEA_FORCE;
	intel->debug_flush = 0;

	if (xf86ReturnOptValBool(intel->Options,
				 OPTION_DEBUG_FLUSH_BATCHES,
				 FALSE))
		intel->debug_flush |= DEBUG_FLUSH_BATCHES;

	if (xf86ReturnOptValBool(intel->Options,
				 OPTION_DEBUG_FLUSH_CACHES,
				 FALSE))
		intel->debug_flush |= DEBUG_FLUSH_CACHES;

	if (xf86ReturnOptValBool(intel->Options,
				 OPTION_DEBUG_WAIT,
				 FALSE))
		intel->debug_flush |= DEBUG_FLUSH_WAIT;

	return TRUE;
}

static void
I830PreInitCrtcConfig(ScrnInfoPtr scrn)
{
	xf86CrtcConfigPtr   xf86_config;
	intel_screen_private *intel = intel_get_screen_private(scrn);
	int max_width, max_height;

	/* check quirks */
	i830_fixup_devices(scrn);

	/* Allocate an xf86CrtcConfig */
	xf86CrtcConfigInit (scrn, &i830_xf86crtc_config_funcs);
	xf86_config = XF86_CRTC_CONFIG_PTR(scrn);

	/* See i830_exa.c comments for why we limit the framebuffer size like
	 * this.
	 */
	if (IS_I965G(intel)) {
		max_height = max_width = min(16384 / intel->cpp, 8192);
	} else {
		max_width = 2048;
		max_height = 2048;
	}
	xf86CrtcSetSizeRange (scrn, 320, 200, max_width, max_height);
}

static void i830_check_dri_option(ScrnInfoPtr scrn)
{
	intel_screen_private *intel = intel_get_screen_private(scrn);
	intel->directRenderingType = DRI_NONE;
	if (!xf86ReturnOptValBool(intel->Options, OPTION_DRI, TRUE))
		intel->directRenderingType = DRI_DISABLED;

	if (scrn->depth != 16 && scrn->depth != 24) {
		xf86DrvMsg(scrn->scrnIndex, X_CONFIG,
			   "DRI is disabled because it "
			   "runs only at depths 16 and 24.\n");
		intel->directRenderingType = DRI_DISABLED;
	}
}

#ifdef notyet
static void
drm_vblank_handler(int fd, unsigned int frame, unsigned int tv_sec,
    unsigned int tv_usec, void *event_data)
{
	I830DRI2FrameEventHandler(frame, tv_sec, tv_usec, event_data);
}

static void
drm_wakeup_handler(pointer data, int err, pointer p)
{
	intel_screen_private *intel = data;
	fd_set *read_mask = p;

	if (err >= 0 && FD_ISSET(intel->drmSubFD, read_mask))
	    drmHandleEvent(intel->drmSubFD, &intel->event_context);
}
#endif

static Bool i830_user_modesetting_init(ScrnInfoPtr scrn)
{
	intel_screen_private *intel = intel_get_screen_private(scrn);
	int i, num_pipe;

	I830MapMMIO(scrn);

	if (DEVICE_ID(intel->PciInfo) == PCI_CHIP_E7221_G)
		num_pipe = 1;
	else
		if (IS_MOBILE(intel) || IS_I9XX(intel))
			num_pipe = 2;
		else
			num_pipe = 1;
	xf86DrvMsg(scrn->scrnIndex, X_INFO, "%d display pipe%s available.\n",
	    num_pipe, num_pipe > 1 ? "s" : "");

	I830PreInitDDC(scrn);
	for (i = 0; i < num_pipe; i++) {
		i830_crtc_init(scrn, i);
	}
	I830SetupOutputs(scrn);

	SaveHWState(scrn);

	if (!xf86InitialConfiguration (scrn, TRUE)) {
		xf86DrvMsg(scrn->scrnIndex, X_ERROR, "No valid modes.\n");
		RestoreHWState(scrn);
		PreInitCleanup(scrn);
		return FALSE;
	}
	RestoreHWState(scrn);

	intel->stolen_size = I830DetectMemory(scrn);
#ifdef notyet
	intel->event_context.version = DRM_EVENT_CONTEXT_VERSION;
	intel->event_context.vblank_handler = drm_vblank_handler;
	AddGeneralSocket(intel->drmSubFD);
	RegisterBlockAndWakeupHandlers((BlockHandlerProcPtr)NoopDDA,
	    drm_wakeup_handler, intel);
#endif


	return TRUE;
}

static Bool i830_open_drm_master(ScrnInfoPtr scrn)
{
	intel_screen_private *intel = intel_get_screen_private(scrn);
	struct pci_device *dev = intel->PciInfo;
	char *busid;
	drmSetVersion sv;
	struct drm_i915_getparam gp;
	int err, has_gem;

	/* We wish we had asprintf, but all we get is XNFprintf. */
	busid = XNFprintf("pci:%04x:%02x:%02x.%d",
			  dev->domain, dev->bus, dev->dev, dev->func);

	intel->drmSubFD = drmOpen("i915", busid);
	if (intel->drmSubFD == -1) {
		xf86DrvMsg(scrn->scrnIndex, X_ERROR,
			   "[drm] Failed to open DRM device for %s: %s\n",
			   busid, strerror(errno));
		free(busid);
		return FALSE;
	}

	free(busid);

	/* Check that what we opened was a master or a master-capable FD,
	 * by setting the version of the interface we'll use to talk to it.
	 * (see DRIOpenDRMMaster() in DRI1)
	 */
	sv.drm_di_major = 1;
	sv.drm_di_minor = 1;
	sv.drm_dd_major = -1;
	sv.drm_dd_minor = -1;
	err = drmSetInterfaceVersion(intel->drmSubFD, &sv);
	if (err != 0) {
		xf86DrvMsg(scrn->scrnIndex, X_ERROR,
			   "[drm] failed to set drm interface version.\n");
		drmClose(intel->drmSubFD);
		intel->drmSubFD = -1;
		return FALSE;
	}

	has_gem = FALSE;
	gp.param = I915_PARAM_HAS_GEM;
	gp.value = &has_gem;
	(void)drmCommandWriteRead(intel->drmSubFD, DRM_I915_GETPARAM,
				  &gp, sizeof(gp));
	if (!has_gem) {
		xf86DrvMsg(scrn->scrnIndex, X_ERROR,
			   "[drm] Failed to detect GEM.  Kernel 2.6.28 required.\n");
		drmClose(intel->drmSubFD);
		intel->drmSubFD = -1;
		return FALSE;
	}

	return TRUE;
}

static void i830_close_drm_master(ScrnInfoPtr scrn)
{
	intel_screen_private *intel = intel_get_screen_private(scrn);
	if (intel && intel->drmSubFD > 0) {
		drmClose(intel->drmSubFD);
		intel->drmSubFD = -1;
	}
}

static Bool I830DrmModeInit(ScrnInfoPtr scrn)
{
	intel_screen_private *intel = intel_get_screen_private(scrn);

	if (drmmode_pre_init(scrn, intel->drmSubFD, intel->cpp) == FALSE) {
		xf86DrvMsg(scrn->scrnIndex, X_ERROR,
			   "Kernel modesetting setup failed\n");
		PreInitCleanup(scrn);
		return FALSE;
	}

	i830_init_bufmgr(scrn);

	return TRUE;
}

static void I830XvInit(ScrnInfoPtr scrn)
{
	intel_screen_private *intel = intel_get_screen_private(scrn);
	MessageType from = X_PROBED;

	intel->XvPreferOverlay =
	    xf86ReturnOptValBool(intel->Options, OPTION_PREFER_OVERLAY, FALSE);

	if (xf86GetOptValInteger(intel->Options, OPTION_VIDEO_KEY,
				 &(intel->colorKey))) {
		from = X_CONFIG;
	} else if (xf86GetOptValInteger(intel->Options, OPTION_COLOR_KEY,
					&(intel->colorKey))) {
		from = X_CONFIG;
	} else {
		intel->colorKey =
		    (1 << scrn->offset.red) | (1 << scrn->offset.green) |
		    (((scrn->mask.blue >> scrn->offset.blue) - 1) <<
		     scrn->offset.blue);
		from = X_DEFAULT;
	}
	xf86DrvMsg(scrn->scrnIndex, from, "video overlay key set to 0x%x\n",
		   intel->colorKey);
}

/**
 * This is called before ScreenInit to do any require probing of screen
 * configuration.
 *
 * This code generally covers probing, module loading, option handling
 * card mapping, and RandR setup.
 *
 * Since xf86InitialConfiguration ends up requiring that we set video modes
 * in order to detect configuration, we end up having to do a lot of driver
 * setup (talking to the DRM, mapping the device, etc.) in this function.
 * As a result, we want to set up that server initialization once rather
 * that doing it per generation.
 */
static Bool I830PreInit(ScrnInfoPtr scrn, int flags)
{
	vgaHWPtr hwp;
	intel_screen_private *intel;
	rgb defaultWeight = { 0, 0, 0 };
	EntityInfoPtr pEnt;
	int flags24;
	Gamma zeros = { 0.0, 0.0, 0.0 };
	int drm_mode_setting;

	if (scrn->numEntities != 1)
		return FALSE;

	drm_mode_setting = i830_kernel_mode_enabled(scrn);

	pEnt = xf86GetEntityInfo(scrn->entityList[0]);

	if (flags & PROBE_DETECT)
		return TRUE;

	/* Allocate driverPrivate */
	if (!I830GetRec(scrn))
		return FALSE;

	intel = intel_get_screen_private(scrn);
	intel->SaveGeneration = -1;
	intel->pEnt = pEnt;
	intel->use_drm_mode = drm_mode_setting;

	if (!I830LoadSyms(scrn))
		return FALSE;

	if (!drm_mode_setting) {
		/* Allocate a vgaHWRec */
		if (!vgaHWGetHWRec(scrn))
			return FALSE;
		hwp = VGAHWPTR(scrn);
	}

	scrn->displayWidth = 640;	/* default it */

	if (intel->pEnt->location.type != BUS_PCI)
		return FALSE;

	intel->PciInfo = xf86GetPciInfoForEntity(intel->pEnt->index);

	if (!i830_open_drm_master(scrn))
		xf86DrvMsg(scrn->scrnIndex, X_ERROR,
			   "Failed to become DRM master.\n");

	scrn->monitor = scrn->confScreen->monitor;
	scrn->progClock = TRUE;
	scrn->rgbBits = 8;

	flags24 = Support32bppFb | PreferConvert24to32 | SupportConvert24to32;

	if (!xf86SetDepthBpp(scrn, 0, 0, 0, flags24))
		return FALSE;

	switch (scrn->depth) {
	case 8:
	case 15:
	case 16:
	case 24:
		break;
	default:
		xf86DrvMsg(scrn->scrnIndex, X_ERROR,
			   "Given depth (%d) is not supported by I830 driver\n",
			   scrn->depth);
		return FALSE;
	}
	xf86PrintDepthBpp(scrn);

	if (!xf86SetWeight(scrn, defaultWeight, defaultWeight))
		return FALSE;
	if (!xf86SetDefaultVisual(scrn, -1))
		return FALSE;

	if (!intel->use_drm_mode)
		hwp = VGAHWPTR(scrn);

	intel->cpp = scrn->bitsPerPixel / 8;

	intel->preinit = TRUE;

	if (!I830GetEarlyOptions(scrn))
		return FALSE;

	if (!i830_detect_chipset(scrn))
		return FALSE;

	i830_check_dri_option(scrn);

	if (intel->use_drm_mode) {
		if (!I830DrmModeInit(scrn))
			return FALSE;
	} else {
		if (i830_bios_init(scrn))
			xf86DrvMsg(scrn->scrnIndex, X_WARNING,
			    "VBIOS initialization failed.\n");
		I830PreInitCrtcConfig(scrn);
		if (!i830_user_modesetting_init(scrn))
			return FALSE;
	}

	I830XvInit(scrn);

	if (!xf86SetGamma(scrn, zeros)) {
		PreInitCleanup(scrn);
		return FALSE;
	}

	if (scrn->modes == NULL) {
		xf86DrvMsg(scrn->scrnIndex, X_ERROR, "No modes.\n");
		PreInitCleanup(scrn);
		return FALSE;
	}
	scrn->currentMode = scrn->modes;

	/* Set display resolution */
	xf86SetDpi(scrn, 0, 0);

	/* Load the required sub modules */
	if (!xf86LoadSubModule(scrn, "fb")) {
		PreInitCleanup(scrn);
		return FALSE;
	}

	if (!intel->use_drm_mode) {
   /* console hack, stolen from G80 */
	   if (IS_IGDNG(intel)) {
	       if (xf86LoadSubModule(scrn, "int10")) {
	       intel->int10 = xf86InitInt10(pEnt->index);
	       if (intel->int10) {
		       intel->int10->num = 0x10;
		       intel->int10->ax = 0x4f03;
		       intel->int10->bx =
		       intel->int10->cx =
		       intel->int10->dx = 0;
		       xf86ExecX86int10(intel->int10);
		       intel->int10Mode = intel->int10->bx & 0x3fff;
		       xf86DrvMsg(scrn->scrnIndex, X_PROBED,
			  "Console VGA mode is 0x%x\n", intel->int10Mode);
		   } else {
		       xf86DrvMsg(scrn->scrnIndex, X_WARNING,
			      "Failed int10 setup, VT switch won't work\n");
		   }
	       } else {
		   xf86DrvMsg(scrn->scrnIndex, X_WARNING,
		       "Failed to load int10module, ironlake vt switch broken");
	       }
	       }

		I830UnmapMMIO(scrn);

		/*  We won't be using the VGA access after the probe. */
		I830SetMMIOAccess(intel);
	}

	/* Load the dri2 module if requested. */
	if (xf86ReturnOptValBool(intel->Options, OPTION_DRI, FALSE) &&
	    intel->directRenderingType != DRI_DISABLED) {
		xf86LoadSubModule(scrn, "dri2");
	}

	intel->preinit = FALSE;

	return TRUE;
}

enum pipe {
	PIPE_A = 0,
	PIPE_B,
};

static Bool i830_pipe_enabled(intel_screen_private *intel, enum pipe pipe)
{
	uint32_t dpll_reg;

	if (IS_IGDNG(intel)) {
		dpll_reg = (pipe == PIPE_A) ? PCH_DPLL_A : PCH_DPLL_B;
	} else {
		dpll_reg = (pipe == PIPE_A) ? DPLL_A : DPLL_B;
	}

	return (INREG(dpll_reg) & DPLL_VCO_ENABLE);
}

static void i830_save_palette(intel_screen_private *intel, enum pipe pipe)
{
	uint32_t reg = (pipe == PIPE_A ? PALETTE_A : PALETTE_B);
	uint32_t *array;
	int i;

	if (!i830_pipe_enabled(intel, pipe))
		return;

	if (IS_IGDNG(intel))
		reg = (pipe == PIPE_A) ? LGC_PALETTE_A : LGC_PALETTE_B;

	if (pipe == PIPE_A)
		array = intel->savePaletteA;
	else
		array = intel->savePaletteB;

	for (i = 0; i < 256; i++)
		array[i] = INREG(reg + (i << 2));
}

static void i830_restore_palette(intel_screen_private *intel, enum pipe pipe)
{
	uint32_t reg = (pipe == PIPE_A ? PALETTE_A : PALETTE_B);
	uint32_t *array;
	int i;

	if (!i830_pipe_enabled(intel, pipe))
		return;

	if (IS_IGDNG(intel))
		reg = (pipe == PIPE_A) ? LGC_PALETTE_A : LGC_PALETTE_B;

	if (pipe == PIPE_A)
		array = intel->savePaletteA;
	else
		array = intel->savePaletteB;

	for (i = 0; i < 256; i++)
		OUTREG(reg + (i << 2), array[i]);
}

static Bool SaveHWState(ScrnInfoPtr scrn)
{
	xf86CrtcConfigPtr   xf86_config = XF86_CRTC_CONFIG_PTR(scrn);
	intel_screen_private *intel = intel_get_screen_private(scrn);
	vgaHWPtr hwp = VGAHWPTR(scrn);
	vgaRegPtr vgaReg = &hwp->SavedReg;
	int i;

       if (IS_IGDNG(intel))
	   return TRUE;

	if (intel->fb_compression) {
		intel->saveFBC_CFB_BASE = INREG(FBC_CFB_BASE);
		intel->saveFBC_LL_BASE = INREG(FBC_LL_BASE);
		intel->saveFBC_CONTROL2 = INREG(FBC_CONTROL2);
		intel->saveFBC_CONTROL = INREG(FBC_CONTROL);
		intel->saveFBC_FENCE_OFF = INREG(FBC_FENCE_OFF);
	}

	/* Save video mode information for native mode-setting. */
	if (!DSPARB_HWCONTROL(intel))
		intel->saveDSPARB = INREG(DSPARB);

	intel->saveDSPACNTR = INREG(DSPACNTR);
	intel->savePIPEACONF = INREG(PIPEACONF);
	intel->savePIPEASRC = INREG(PIPEASRC);
	intel->saveFPA0 = INREG(FPA0);
	intel->saveFPA1 = INREG(FPA1);
	intel->saveDPLL_A = INREG(DPLL_A);
	if (IS_I965G(intel))
		intel->saveDPLL_A_MD = INREG(DPLL_A_MD);
	intel->saveHTOTAL_A = INREG(HTOTAL_A);
	intel->saveHBLANK_A = INREG(HBLANK_A);
	intel->saveHSYNC_A = INREG(HSYNC_A);
	intel->saveVTOTAL_A = INREG(VTOTAL_A);
	intel->saveVBLANK_A = INREG(VBLANK_A);
	intel->saveVSYNC_A = INREG(VSYNC_A);
	intel->saveBCLRPAT_A = INREG(BCLRPAT_A);
	intel->saveDSPASTRIDE = INREG(DSPASTRIDE);
	intel->saveDSPASIZE = INREG(DSPASIZE);
	intel->saveDSPAPOS = INREG(DSPAPOS);
	intel->saveDSPABASE = INREG(DSPABASE);

	i830_save_palette(intel, PIPE_A);

	if(xf86_config->num_crtc == 2) {
	intel->savePIPEBCONF = INREG(PIPEBCONF);
	intel->savePIPEBSRC = INREG(PIPEBSRC);
	intel->saveDSPBCNTR = INREG(DSPBCNTR);
	intel->saveFPB0 = INREG(FPB0);
	intel->saveFPB1 = INREG(FPB1);
	intel->saveDPLL_B = INREG(DPLL_B);
	if (IS_I965G(intel))
		intel->saveDPLL_B_MD = INREG(DPLL_B_MD);
	intel->saveHTOTAL_B = INREG(HTOTAL_B);
	intel->saveHBLANK_B = INREG(HBLANK_B);
	intel->saveHSYNC_B = INREG(HSYNC_B);
	intel->saveVTOTAL_B = INREG(VTOTAL_B);
	intel->saveVBLANK_B = INREG(VBLANK_B);
	intel->saveVSYNC_B = INREG(VSYNC_B);
	intel->saveBCLRPAT_B = INREG(BCLRPAT_B);
	intel->saveDSPBSTRIDE = INREG(DSPBSTRIDE);
	intel->saveDSPBSIZE = INREG(DSPBSIZE);
	intel->saveDSPBPOS = INREG(DSPBPOS);
	intel->saveDSPBBASE = INREG(DSPBBASE);

	i830_save_palette(intel, PIPE_B);
	}

	if (IS_I965G(intel)) {
		intel->saveDSPASURF = INREG(DSPASURF);
		intel->saveDSPBSURF = INREG(DSPBSURF);
		intel->saveDSPATILEOFF = INREG(DSPATILEOFF);
		intel->saveDSPBTILEOFF = INREG(DSPBTILEOFF);
	}

	intel->saveVCLK_DIVISOR_VGA0 = INREG(VCLK_DIVISOR_VGA0);
	intel->saveVCLK_DIVISOR_VGA1 = INREG(VCLK_DIVISOR_VGA1);
	intel->saveVCLK_POST_DIV = INREG(VCLK_POST_DIV);
	intel->saveVGACNTRL = INREG(VGACNTRL);

	intel->saveCURSOR_A_CONTROL = INREG(CURSOR_A_CONTROL);
	intel->saveCURSOR_A_POSITION = INREG(CURSOR_A_POSITION);
	intel->saveCURSOR_A_BASE = INREG(CURSOR_A_BASE);
	intel->saveCURSOR_B_CONTROL = INREG(CURSOR_B_CONTROL);
	intel->saveCURSOR_B_POSITION = INREG(CURSOR_B_POSITION);
	intel->saveCURSOR_B_BASE = INREG(CURSOR_B_BASE);

	for(i = 0; i < 7; i++) {
		intel->saveSWF[i] = INREG(SWF0 + (i << 2));
		intel->saveSWF[i+7] = INREG(SWF00 + (i << 2));
	}
	intel->saveSWF[14] = INREG(SWF30);
	intel->saveSWF[15] = INREG(SWF31);
	intel->saveSWF[16] = INREG(SWF32);

	intel->saveDSPCLK_GATE_D = INREG(DSPCLK_GATE_D);
	intel->saveRENCLK_GATE_D1 = INREG(RENCLK_GATE_D1);

	if (IS_I965G(intel)) {
		intel->saveRENCLK_GATE_D2 = INREG(RENCLK_GATE_D2);
		intel->saveRAMCLK_GATE_D = INREG(RAMCLK_GATE_D);
	}

	if (IS_I965GM(intel) || IS_GM45(intel))
		intel->savePWRCTXA = INREG(PWRCTXA);

	if (IS_MOBILE(intel) && !IS_I830(intel))
		intel->saveLVDS = INREG(LVDS);
	intel->savePFIT_CONTROL = INREG(PFIT_CONTROL);

	for (i = 0; i < xf86_config->num_output; i++) {
		xf86OutputPtr   output = xf86_config->output[i];
		if (output->funcs->save)
			(*output->funcs->save) (output);
	}

	vgaHWUnlock(hwp);
	vgaHWSave(scrn, vgaReg, VGA_SR_FONTS);

	return TRUE;
}

/* Wait for the PLL to settle down after programming */
static void i830_dpll_settle(void)
{
	usleep(10000); /* 10 ms *should* be plenty */
}

static Bool RestoreHWState(ScrnInfoPtr scrn)
{
	xf86CrtcConfigPtr   xf86_config = XF86_CRTC_CONFIG_PTR(scrn);
	intel_screen_private *intel = intel_get_screen_private(scrn);
	vgaHWPtr hwp = VGAHWPTR(scrn);
	vgaRegPtr vgaReg = &hwp->SavedReg;
	int i;

       if (IS_IGDNG(intel))
	   return TRUE;

	DPRINTF(PFX, "RestoreHWState\n");

	/* Disable outputs */
	for (i = 0; i < xf86_config->num_output; i++) {
		xf86OutputPtr   output = xf86_config->output[i];
		output->funcs->dpms(output, DPMSModeOff);
	}
	i830WaitForVblank(scrn);
   
	/* Disable pipes */
	for (i = 0; i < xf86_config->num_crtc; i++) {
		xf86CrtcPtr crtc = xf86_config->crtc[i];
		i830_crtc_disable(crtc, TRUE);
	}
	i830WaitForVblank(scrn);

	if (IS_MOBILE(intel) && !IS_I830(intel))
		OUTREG(LVDS, intel->saveLVDS);

	if (!IS_I830(intel) && !IS_845G(intel))
		OUTREG(PFIT_CONTROL, intel->savePFIT_CONTROL);

	if (!DSPARB_HWCONTROL(intel))
		OUTREG(DSPARB, intel->saveDSPARB);

	OUTREG(DSPCLK_GATE_D, intel->saveDSPCLK_GATE_D);
	OUTREG(RENCLK_GATE_D1, intel->saveRENCLK_GATE_D1);

	if (IS_I965G(intel)) {
		OUTREG(RENCLK_GATE_D2, intel->saveRENCLK_GATE_D2);
		OUTREG(RAMCLK_GATE_D, intel->saveRAMCLK_GATE_D);
	}

	if (IS_I965GM(intel) || IS_GM45(intel))
		OUTREG(PWRCTXA, intel->savePWRCTXA);

	/*
	 * Pipe regs
	 * To restore the saved state, we first need to program the PLL regs,
	 * followed by the pipe configuration and finally the display plane
	 * configuration.  The VGA registers can program one, both or neither
	 * of the PLL regs, depending on their VGA_MOD_DIS bit value.
	 */

	/*
	 * Since either or both pipes may use the VGA clocks, make sure the
	 * regs are valid.
	 */
	OUTREG(VCLK_DIVISOR_VGA0, intel->saveVCLK_DIVISOR_VGA0);
	OUTREG(VCLK_DIVISOR_VGA1, intel->saveVCLK_DIVISOR_VGA1);
	OUTREG(VCLK_POST_DIV, intel->saveVCLK_POST_DIV);

	/* If the pipe A PLL is active, we can restore the pipe & plane config */
	if (intel->saveDPLL_A & DPLL_VCO_ENABLE) {
		OUTREG(FPA0, intel->saveFPA0);
		OUTREG(DPLL_A, intel->saveDPLL_A & ~DPLL_VCO_ENABLE);
		POSTING_READ(DPLL_A);
		usleep(150);
	}
	OUTREG(FPA0, intel->saveFPA0);
	OUTREG(FPA1, intel->saveFPA1);
	OUTREG(DPLL_A, intel->saveDPLL_A);
	POSTING_READ(DPLL_A);
	i830_dpll_settle();
	if (IS_I965G(intel))
		OUTREG(DPLL_A_MD, intel->saveDPLL_A_MD);
	else
		OUTREG(DPLL_A, intel->saveDPLL_A);
	POSTING_READ(DPLL_A);
	i830_dpll_settle();

	/* Restore mode config */
	OUTREG(HTOTAL_A, intel->saveHTOTAL_A);
	OUTREG(HBLANK_A, intel->saveHBLANK_A);
	OUTREG(HSYNC_A, intel->saveHSYNC_A);
	OUTREG(VTOTAL_A, intel->saveVTOTAL_A);
	OUTREG(VBLANK_A, intel->saveVBLANK_A);
	OUTREG(VSYNC_A, intel->saveVSYNC_A);
	OUTREG(BCLRPAT_A, intel->saveBCLRPAT_A);

	OUTREG(DSPASTRIDE, intel->saveDSPASTRIDE);
	OUTREG(DSPASIZE, intel->saveDSPASIZE);
	OUTREG(DSPAPOS, intel->saveDSPAPOS);
	OUTREG(PIPEASRC, intel->savePIPEASRC);
	OUTREG(DSPABASE, intel->saveDSPABASE);
	if (IS_I965G(intel)) {
		OUTREG(DSPASURF, intel->saveDSPASURF);
		OUTREG(DSPATILEOFF, intel->saveDSPATILEOFF);
	}

	OUTREG(PIPEACONF, intel->savePIPEACONF);
	POSTING_READ(PIPEACONF);
	i830WaitForVblank(scrn);

	/*
	 * Program Pipe A's plane
	 * The corresponding display plane may be disabled, and should only be
	 * enabled if pipe A is actually on (otherwise we have a bug in the initial
	 * state).
	 */
	if ((intel->saveDSPACNTR & DISPPLANE_SEL_PIPE_MASK) ==
		DISPPLANE_SEL_PIPE_A) {
		OUTREG(DSPACNTR, intel->saveDSPACNTR);
		OUTREG(DSPABASE, INREG(DSPABASE));
		POSTING_READ(DSPABASE);
		i830WaitForVblank(scrn);
	}
	if ((intel->saveDSPBCNTR & DISPPLANE_SEL_PIPE_MASK) ==
	    DISPPLANE_SEL_PIPE_A) {
		OUTREG(DSPBCNTR, intel->saveDSPBCNTR);
		OUTREG(DSPBBASE, INREG(DSPBBASE));
		POSTING_READ(DSPBBASE);
		i830WaitForVblank(scrn);
	}

	/* See note about pipe programming above */
	if(xf86_config->num_crtc == 2) {
		/* If the pipe B PLL is active, we can restore the pipe
		 * & plane config
		 */
		if (intel->saveDPLL_B & DPLL_VCO_ENABLE) {
			OUTREG(FPB0, intel->saveFPB0);
			OUTREG(DPLL_B, intel->saveDPLL_B & ~DPLL_VCO_ENABLE);
			POSTING_READ(DPLL_B);
			usleep(150);
		}
		OUTREG(FPB0, intel->saveFPB0);
		OUTREG(FPB1, intel->saveFPB1);
		OUTREG(DPLL_B, intel->saveDPLL_B);
		POSTING_READ(DPLL_B);
		i830_dpll_settle();
		if (IS_I965G(intel))
			OUTREG(DPLL_B_MD, intel->saveDPLL_B_MD);
		else
			OUTREG(DPLL_B, intel->saveDPLL_B);
		POSTING_READ(DPLL_B);
		i830_dpll_settle();
   
		/* Restore mode config */
		OUTREG(HTOTAL_B, intel->saveHTOTAL_B);
		OUTREG(HBLANK_B, intel->saveHBLANK_B);
		OUTREG(HSYNC_B, intel->saveHSYNC_B);
		OUTREG(VTOTAL_B, intel->saveVTOTAL_B);
		OUTREG(VBLANK_B, intel->saveVBLANK_B);
		OUTREG(VSYNC_B, intel->saveVSYNC_B);
		OUTREG(BCLRPAT_B, intel->saveBCLRPAT_B);
		OUTREG(DSPBSTRIDE, intel->saveDSPBSTRIDE);
		OUTREG(DSPBSIZE, intel->saveDSPBSIZE);
		OUTREG(DSPBPOS, intel->saveDSPBPOS);
		OUTREG(PIPEBSRC, intel->savePIPEBSRC);
		OUTREG(DSPBBASE, intel->saveDSPBBASE);
		if (IS_I965G(intel)) {
			OUTREG(DSPBSURF, intel->saveDSPBSURF);
			OUTREG(DSPBTILEOFF, intel->saveDSPBTILEOFF);
		}

		OUTREG(PIPEBCONF, intel->savePIPEBCONF);
		POSTING_READ(PIPEBCONF);
		i830WaitForVblank(scrn);

		/*
		 * Program Pipe B's plane
		 * Note that pipe B may be disabled, and in that case, the plane
		 * should also be disabled or we must have had a bad initial state.
		 */
		if ((intel->saveDSPACNTR & DISPPLANE_SEL_PIPE_MASK) ==
		    DISPPLANE_SEL_PIPE_B) {
			OUTREG(DSPACNTR, intel->saveDSPACNTR);
			OUTREG(DSPABASE, INREG(DSPABASE));
			i830WaitForVblank(scrn);
		}
		if ((intel->saveDSPBCNTR & DISPPLANE_SEL_PIPE_MASK) ==
		    DISPPLANE_SEL_PIPE_B) {
			OUTREG(DSPBCNTR, intel->saveDSPBCNTR);
			OUTREG(DSPBBASE, INREG(DSPBBASE));
			i830WaitForVblank(scrn);
		}
	}

	OUTREG(VGACNTRL, intel->saveVGACNTRL);

	/*
	 * Restore cursors
	 * Even though the X cursor is hidden before we restore the hw state,
	 * we probably only disabled one cursor plane.  If we're going from
	 * e.g. plane b to plane a here in RestoreHWState, we need to restore
	 * both cursor plane settings.
	 */
	OUTREG(CURSOR_A_POSITION, intel->saveCURSOR_A_POSITION);
	OUTREG(CURSOR_A_BASE, intel->saveCURSOR_A_BASE);
	OUTREG(CURSOR_A_CONTROL, intel->saveCURSOR_A_CONTROL);
	OUTREG(CURSOR_B_POSITION, intel->saveCURSOR_B_POSITION);
	OUTREG(CURSOR_B_BASE, intel->saveCURSOR_B_BASE);
	OUTREG(CURSOR_B_CONTROL, intel->saveCURSOR_B_CONTROL);

	/* Restore outputs */
	for (i = 0; i < xf86_config->num_output; i++) {
		xf86OutputPtr   output = xf86_config->output[i];
		if (output->funcs->restore)
			output->funcs->restore(output);
	}

	i830_restore_palette(intel, PIPE_A);
	i830_restore_palette(intel, PIPE_B);

	for(i = 0; i < 7; i++) {
		OUTREG(SWF0 + (i << 2), intel->saveSWF[i]);
		OUTREG(SWF00 + (i << 2), intel->saveSWF[i+7]);
	}

	OUTREG(SWF30, intel->saveSWF[14]);
	OUTREG(SWF31, intel->saveSWF[15]);
	OUTREG(SWF32, intel->saveSWF[16]);

	if (intel->fb_compression) {
		OUTREG(FBC_CFB_BASE, intel->saveFBC_CFB_BASE);
		OUTREG(FBC_LL_BASE, intel->saveFBC_LL_BASE);
		OUTREG(FBC_FENCE_OFF, intel->saveFBC_FENCE_OFF);
		OUTREG(FBC_CONTROL2, intel->saveFBC_CONTROL2);
		OUTREG(FBC_CONTROL, intel->saveFBC_CONTROL);
	}

	vgaHWRestore(scrn, vgaReg, VGA_SR_FONTS);
	vgaHWLock(hwp);

	return TRUE;
}

/**
 * Intialiazes the hardware for the 3D pipeline use in the 2D driver.
 *
 * Some state caching is performed to avoid redundant state emits.  This
 * function is also responsible for marking the state as clobbered for DRI
 * clients.
 */
void IntelEmitInvarientState(ScrnInfoPtr scrn)
{
	intel_screen_private *intel = intel_get_screen_private(scrn);

	/* If we've emitted our state since the last clobber by another client,
	 * skip it.
	 */
	if (intel->last_3d != LAST_3D_OTHER)
		return;

	if (!IS_I965G(intel)) {
		if (IS_I9XX(intel))
			I915EmitInvarientState(scrn);
		else
			I830EmitInvarientState(scrn);
	}
}

static void
I830BlockHandler(int i, pointer blockData, pointer pTimeout, pointer pReadmask)
{
	ScreenPtr screen = screenInfo.screens[i];
	ScrnInfoPtr scrn = xf86Screens[i];
	intel_screen_private *intel = intel_get_screen_private(scrn);

	screen->BlockHandler = intel->BlockHandler;

	(*screen->BlockHandler) (i, blockData, pTimeout, pReadmask);

	intel->BlockHandler = screen->BlockHandler;
	screen->BlockHandler = I830BlockHandler;

	if (scrn->vtSema) {
		/* Emit a flush of the rendering cache, or on the 965 and beyond
		 * rendering results may not hit the framebuffer until significantly
		 * later.
		 */
		intel_batch_submit(scrn,
				   intel->need_mi_flush ||
				   !list_is_empty(&intel->flush_pixmaps));
		drmCommandNone(intel->drmSubFD, DRM_I915_GEM_THROTTLE);
	}

	i830_uxa_block_handler(screen);

	I830VideoBlockHandler(i, blockData, pTimeout, pReadmask);
}

static void i830_fixup_mtrrs(ScrnInfoPtr scrn)
{
#ifdef HAS_MTRR_SUPPORT
	intel_screen_private *intel = intel_get_screen_private(scrn);
	int fd;
	struct mtrr_gentry gentry;
	struct mtrr_sentry sentry;

	if ((fd = open("/proc/mtrr", O_RDONLY, 0)) != -1) {
		for (gentry.regnum = 0;
		     ioctl(fd, MTRRIOC_GET_ENTRY, &gentry) == 0;
		     ++gentry.regnum) {

			if (gentry.size < 1) {
				/* DISABLED */
				continue;
			}

			/* Check the MTRR range is one we like and if not - remove it.
			 * The Xserver common layer will then setup the right range
			 * for us.
			 */
			if (gentry.base == intel->LinearAddr &&
			    gentry.size < intel->FbMapSize) {

				xf86DrvMsg(scrn->scrnIndex, X_INFO,
					   "Removing bad MTRR range (base 0x%lx, size 0x%x)\n",
					   gentry.base, gentry.size);

				sentry.base = gentry.base;
				sentry.size = gentry.size;
				sentry.type = gentry.type;

				if (ioctl(fd, MTRRIOC_DEL_ENTRY, &sentry) == -1) {
					xf86DrvMsg(scrn->scrnIndex, X_ERROR,
						   "Failed to remove bad MTRR range\n");
				}
			}
		}
		close(fd);
	}
#endif
}

static Bool i830_try_memory_allocation(ScrnInfoPtr scrn)
{
	intel_screen_private *intel = intel_get_screen_private(scrn);
	Bool tiled = intel->tiling;

	xf86DrvMsg(scrn->scrnIndex, X_INFO,
		   "Attempting memory allocation with %stiled buffers.\n",
		   tiled ? "" : "un");

	if (!i830_allocate_2d_memory(scrn))
		goto failed;

	if (IS_I965GM(intel) || IS_GM45(intel))
		if (!i830_allocate_pwrctx(scrn))
			goto failed;
	xf86DrvMsg(scrn->scrnIndex, X_INFO, "%siled allocation successful.\n",
		   tiled ? "T" : "Unt");
	return TRUE;

failed:
	xf86DrvMsg(scrn->scrnIndex, X_INFO, "%siled allocation failed.\n",
		   tiled ? "T" : "Unt");
	return FALSE;
}

/*
 * Try to allocate memory in several ways:
 *  1) If direct rendering is enabled, try to allocate enough memory for tiled
 *     surfaces by rounding up the display width to a tileable one.
 *  2) If that fails or the allocations themselves fail, try again with untiled
 *     allocations (if this works DRI will stay enabled).
 *  3) And if all else fails, disable DRI and try just 2D allocations.
 *  4) Give up and fail ScreenInit.
 */
static Bool i830_memory_init(ScrnInfoPtr scrn)
{
	intel_screen_private *intel = intel_get_screen_private(scrn);
	int savedDisplayWidth = scrn->displayWidth;
	Bool tiled = FALSE;

	tiled = i830_tiled_width(intel, &scrn->displayWidth, intel->cpp);
	/* Set up our video memory allocator for the chosen videoRam */
	if (!i830_allocator_init(scrn, scrn->videoRam * KB(1))) {
		xf86DrvMsg(scrn->scrnIndex, X_ERROR,
			   "Couldn't initialize video memory allocator\n");
		PreInitCleanup(scrn);
		return FALSE;
	}

	xf86DrvMsg(scrn->scrnIndex,
		   intel->pEnt->device->videoRam ? X_CONFIG : X_DEFAULT,
		   "VideoRam: %d KB\n", scrn->videoRam);

	/* Tiled first if we got a good displayWidth */
	if (tiled) {
		if (i830_try_memory_allocation(scrn))
			return TRUE;
		else {
			i830_reset_allocations(scrn);
			intel->tiling = FALSE;
		}
	}

	/* If tiling fails we have to disable FBC */
	scrn->displayWidth = savedDisplayWidth;
	if (intel->fb_compression)
		xf86DrvMsg(scrn->scrnIndex, X_WARNING,
		    "Couldn't allocate tiled memory, fb compression "
		    "disabled\n");
	intel->fb_compression = FALSE;

	if (i830_try_memory_allocation(scrn))
		return TRUE;

	return FALSE;
}

void i830_init_bufmgr(ScrnInfoPtr scrn)
{
	intel_screen_private *intel = intel_get_screen_private(scrn);
	int batch_size;

	if (intel->bufmgr)
		return;

	batch_size = 4096 * 4;

	/* The 865 has issues with larger-than-page-sized batch buffers. */
	if (IS_I865G(intel))
		batch_size = 4096;

	intel->bufmgr = intel_bufmgr_gem_init(intel->drmSubFD, batch_size);
	intel_bufmgr_gem_enable_reuse(intel->bufmgr);
	drm_intel_bufmgr_gem_enable_fenced_relocs(intel->bufmgr);

	list_init(&intel->batch_pixmaps);
	list_init(&intel->flush_pixmaps);
	list_init(&intel->in_flight);
}

Bool i830_crtc_on(xf86CrtcPtr crtc)
{
	ScrnInfoPtr scrn = crtc->scrn;
	xf86CrtcConfigPtr xf86_config = XF86_CRTC_CONFIG_PTR(scrn);
	intel_screen_private *intel = intel_get_screen_private(scrn);

	if (intel->use_drm_mode) {
		int i, active_outputs = 0;

		/* Kernel manages CRTC status based out output config */
		for (i = 0; i < xf86_config->num_output; i++) {
			xf86OutputPtr output = xf86_config->output[i];
			if (output->crtc == crtc &&
			    drmmode_output_dpms_status(output) == DPMSModeOn)
				active_outputs++;
		}

		if (active_outputs)
			return TRUE;
		return FALSE;
	} else {
		I830CrtcPrivatePtr intel_crtc = crtc->driver_private;

		if (intel_crtc->dpms_mode == DPMSModeOn)
			return TRUE;
		return FALSE;
	}
}

int i830_crtc_to_pipe(xf86CrtcPtr crtc)
{
	ScrnInfoPtr scrn = crtc->scrn;
	intel_screen_private *intel = intel_get_screen_private(scrn);
	int pipe;

	if (intel->use_drm_mode) {
		pipe = drmmode_get_pipe_from_crtc_id(intel->bufmgr, crtc);
	} else {
		I830CrtcPrivatePtr intel_crtc = crtc->driver_private;
		pipe = intel_crtc->pipe;
	}

	return pipe;
}

static void
I830AdjustMemory(ScreenPtr screen)
{
	ScrnInfoPtr scrn;
	intel_screen_private *intel;
	unsigned long sys_mem;
	MessageType from;

	scrn = xf86Screens[screen->myNum];
	intel = intel_get_screen_private(scrn);

	/* Limit videoRam to how much we might be able to allocate from AGP */
	sys_mem = I830CheckAvailableMemory(scrn);
	if (sys_mem == -1) {
		xf86DrvMsg(scrn->scrnIndex, X_ERROR,
		    "/dev/agpgart is either not available, or no memory "
		    "is available\nfor allocation.  Please enable agpgart\n.");
		scrn->videoRam = intel->stolen_size / KB(1);
	}
	if (sys_mem + (intel->stolen_size / 1024) < scrn->videoRam) {
		scrn->videoRam = sys_mem + (intel->stolen_size / 1024);
		from = X_PROBED;
		if (sys_mem + (intel->stolen_size / 1024) <
		    intel->pEnt->device->videoRam) {
			xf86DrvMsg(scrn->scrnIndex, X_WARNING,
			    "VideoRAM reduced to %d kByte "
			    "(limited to available sysmem)\n", scrn->videoRam);
		}
	}

	/* Limit video RAM to the actual aperture size */
	if (scrn->videoRam > intel->FbMapSize / 1024) {
		scrn->videoRam = intel->FbMapSize / 1024;
		if (intel->FbMapSize / 1024 < intel->pEnt->device->videoRam) {
			xf86DrvMsg(scrn->scrnIndex, X_WARNING,
			    "VideoRam reduced to %d kByte (limited to aperture "
			    "size)\n", scrn->videoRam);
		}
	}

	/* Make sure it's on a page boundary */
	if (scrn->videoRam & 3) {
		xf86DrvMsg(scrn->scrnIndex, X_WARNING, "VideoRam reduced to "
		    "%d KB (page aligned - was %d KB)\n", scrn->videoRam & ~3,
		    scrn->videoRam);
		scrn->videoRam &= ~3;
	}

	if (!IS_I965G(intel) && scrn->displayWidth > 2048) {
		xf86DrvMsg(scrn->scrnIndex, X_ERROR,
		    "Cannot support DRI with frame buffer width > 2048.\n");
		intel->directRenderingType = DRI_DISABLED;
	}
}

static void
I830SwapPipes(ScrnInfoPtr scrn)
{
	intel_screen_private *intel = intel_get_screen_private(scrn);
	xf86CrtcConfigPtr config;
	int c;

	config = XF86_CRTC_CONFIG_PTR(scrn);

	/*
	 * If an LVDS display is present, swap the plane/pipe mappings so we can
	 * use FBC on the builtin display.
	 * Note: 965+ chips can compress either plane, so we leave the mapping
	 *       alone in that case.
	 * Also make sure the DRM can handle the swap.
	 */
	if (I830LVDSPresent(scrn) && !IS_I965GM(intel) && !IS_GM45(intel) &&
	    !IS_IGDNG(intel)) {
		xf86DrvMsg(scrn->scrnIndex, X_INFO, "adjusting plane->pipe "
		    "mappings to allow for framebuffer compression\n");
		for (c = 0; c < config->num_crtc; c++) {
			xf86CrtcPtr	      crtc = config->crtc[c];
			I830CrtcPrivatePtr   intel_crtc = crtc->driver_private;

			if (intel_crtc->pipe == 0)
				intel_crtc->plane = 1;
			else if (intel_crtc->pipe == 1)
				intel_crtc->plane = 0;
		}
	}
}

static void
i830_disable_render_standby(ScrnInfoPtr scrn)
{
	intel_screen_private *intel = intel_get_screen_private(scrn);
	uint32_t render_standby;

	/* Render Standby might cause hang issue, try always disable it.*/
	if (IS_I965GM(intel) || IS_GM45(intel)) {
		render_standby = INREG(MCHBAR_RENDER_STANDBY);
		if (render_standby & RENDER_STANDBY_ENABLE) {
			xf86DrvMsg(scrn->scrnIndex, X_INFO, "Disable render standby.\n");
			    OUTREG(MCHBAR_RENDER_STANDBY,
			    (render_standby & (~RENDER_STANDBY_ENABLE)));
	       }
	}
}

static Bool
I830ScreenInit(int scrnIndex, ScreenPtr screen, int argc, char **argv)
{
	ScrnInfoPtr scrn = xf86Screens[screen->myNum];
	vgaHWPtr hwp = NULL;
	intel_screen_private *intel = intel_get_screen_private(scrn);
	VisualPtr visual;
	MessageType from;

	if (!intel->use_drm_mode)
		hwp = VGAHWPTR(scrn);

	scrn->displayWidth = i830_pad_drawable_width(scrn->virtualX);

	/*
	 * The "VideoRam" config file parameter specifies the maximum amount of
	 * memory that will be used/allocated.  When not present, we allow the
	 * driver to allocate as much memory as it wishes to satisfy its
	 * allocations, but if agpgart support isn't available, it gets limited
	 * to the amount of pre-allocated ("stolen") memory.
	 *
	 * Note that in using this value for allocator initialization, we're
	 * limiting aperture allocation to the VideoRam option, rather than limiting
	 * actual memory allocation, so alignment and things will cause less than
	 * VideoRam to be actually used.
	 */
	if (intel->pEnt->device->videoRam == 0) {
		from = X_DEFAULT;
		scrn->videoRam = intel->FbMapSize / KB(1);
	} else {
#if 0
		from = X_CONFIG;
		scrn->videoRam = intel->pEnt->device->videoRam;
#else
		/* Disable VideoRam configuration, at least for now.  Previously,
		 * VideoRam was necessary to avoid overly low limits on allocated
		 * memory, so users created larger, yet still small, fixed allocation
		 * limits in their config files.  Now, the driver wants to allocate more,
		 * and the old intention of the VideoRam lines that had been entered is
		 * obsolete.
		 */
		from = X_DEFAULT;
		scrn->videoRam = intel->FbMapSize / KB(1);

		if (scrn->videoRam != intel->pEnt->device->videoRam) {
			xf86DrvMsg(scrn->scrnIndex, X_WARNING,
				   "VideoRam configuration found, which is no longer "
				   "recommended.\n");
			xf86DrvMsg(scrn->scrnIndex, X_INFO,
				   "Continuing with default %dkB VideoRam instead of %d "
				   "kB.\n",
				   scrn->videoRam,
				   intel->pEnt->device->videoRam);
		}
#endif
	}

	if (intel->use_drm_mode) {
		struct pci_device *const device = intel->PciInfo;
		int fb_bar = IS_I9XX(intel) ? 2 : 0;

		scrn->videoRam = device->regions[fb_bar].size / 1024;
	} else {
		I830AdjustMemory(screen);
	}

#ifdef DRI2
	if (intel->directRenderingType == DRI_NONE
	    && I830DRI2ScreenInit(screen))
		intel->directRenderingType = DRI_DRI2;
#endif

	/* Enable tiling by default */
	intel->tiling = TRUE;

	/* Allow user override if they set a value */
	if (xf86IsOptionSet(intel->Options, OPTION_TILING)) {
		if (xf86ReturnOptValBool(intel->Options, OPTION_TILING, FALSE))
			intel->tiling = TRUE;
		else
			intel->tiling = FALSE;
	}

	/* Enable FB compression if possible */
	if (i830_fb_compression_supported(intel))
		intel->fb_compression = TRUE;
	else
		intel->fb_compression = FALSE;

	/* Again, allow user override if set */
	if (xf86IsOptionSet(intel->Options, OPTION_FBC)) {
		if (xf86ReturnOptValBool(intel->Options, OPTION_FBC, FALSE))
			intel->fb_compression = TRUE;
	else
		intel->fb_compression = FALSE;
	}

	if (intel->use_drm_mode && intel->fb_compression == TRUE) {
		xf86DrvMsg(scrn->scrnIndex, X_CONFIG,
		    "Kernel mode setting active, disabling FBC.\n");
		intel->fb_compression = FALSE;
	}

	/* SwapBuffers delays to avoid tearing */
	intel->swapbuffers_wait = TRUE;

	/* Allow user override if they set a value */
	if (xf86IsOptionSet(intel->Options, OPTION_SWAPBUFFERS_WAIT)) {
		if (xf86ReturnOptValBool
		    (intel->Options, OPTION_SWAPBUFFERS_WAIT, FALSE))
			intel->swapbuffers_wait = TRUE;
		else
			intel->swapbuffers_wait = FALSE;
	}

	xf86DrvMsg(scrn->scrnIndex, X_CONFIG, "Framebuffer compression %sabled\n",
		   intel->fb_compression ? "en" : "dis");
	xf86DrvMsg(scrn->scrnIndex, X_CONFIG, "Tiling %sabled\n",
		   intel->tiling ? "en" : "dis");
	xf86DrvMsg(scrn->scrnIndex, X_CONFIG, "SwapBuffers wait %sabled\n",
		   intel->swapbuffers_wait ? "en" : "dis");

	intel->last_3d = LAST_3D_OTHER;
	intel->overlayOn = FALSE;

	/*
	 * Set this so that the overlay allocation is factored in when
	 * appropriate.
	 */
	intel->XvEnabled = TRUE;

	/* Need MMIO mapped to do GTT lookups during memory allocation. */
	if (!intel->use_drm_mode)
		I830MapMMIO(scrn);

	/* Need FB mapped to access non-GEM objects like
	 * a UMS frame buffer, or the fake bufmgr.
	 */
	if (!intel->use_drm_mode) {
		if (!I830MapMem(scrn))
			return FALSE;
		scrn->memPhysBase = (unsigned long)intel->FbBase;
	}

	if (!i830_memory_init(scrn)) {
		xf86DrvMsg(scrn->scrnIndex, X_ERROR,
			   "Couldn't allocate video memory\n");
		return FALSE;
	}

	i830_fixup_mtrrs(scrn);

	intel->starting = TRUE;

	miClearVisualTypes();
	if (!miSetVisualTypes(scrn->depth,
			      miGetDefaultVisualMask(scrn->depth),
			      scrn->rgbBits, scrn->defaultVisual))
		return FALSE;
	if (!miSetPixmapDepths())
		return FALSE;

	if (!intel->use_drm_mode) {
		vgaHWSetMmioFuncs(hwp, intel->MMIOBase, 0);
		vgaHWGetIOBase(hwp);
		DPRINTF(PFX, "assert( if(!vgaHWMapMem(scrn)) )\n");
		if (!vgaHWMapMem(scrn))
			return FALSE;
	}

	DPRINTF(PFX, "assert( if(!I830EnterVT(scrnIndex, 0)) )\n");

	if (scrn->virtualX > scrn->displayWidth)
		scrn->displayWidth = scrn->virtualX;

	/* If the front buffer is not a BO, we need to
	 * set the initial framebuffer pixmap to point at
	 * it
	 */
	scrn->fbOffset = intel->front_buffer->offset;

	DPRINTF(PFX, "assert( if(!fbScreenInit(screen, ...) )\n");
	if (!fbScreenInit(screen, NULL,
			  scrn->virtualX, scrn->virtualY,
			  scrn->xDpi, scrn->yDpi,
			  scrn->displayWidth, scrn->bitsPerPixel))
		return FALSE;

	if (scrn->bitsPerPixel > 8) {
		/* Fixup RGB ordering */
		visual = screen->visuals + screen->numVisuals;
		while (--visual >= screen->visuals) {
			if ((visual->class | DynamicClass) == DirectColor) {
				visual->offsetRed = scrn->offset.red;
				visual->offsetGreen = scrn->offset.green;
				visual->offsetBlue = scrn->offset.blue;
				visual->redMask = scrn->mask.red;
				visual->greenMask = scrn->mask.green;
				visual->blueMask = scrn->mask.blue;
			}
		}
	}

	fbPictureInit(screen, NULL, 0);

	xf86SetBlackWhitePixels(screen);

	if (!I830AccelInit(screen)) {
		xf86DrvMsg(scrn->scrnIndex, X_ERROR,
			   "Hardware acceleration initialization failed\n");
		return FALSE;
	}

	if (IS_I965G(intel)) {
		intel->batch_flush_notify = i965_batch_flush_notify;
	} else if (IS_I9XX(intel)) {
		intel->vertex_flush = i915_vertex_flush;
		intel->batch_flush_notify = i915_batch_flush_notify;
	} else
		intel->batch_flush_notify = i830_batch_flush_notify;

	miInitializeBackingStore(screen);
	xf86SetBackingStore(screen);
	xf86SetSilkenMouse(screen);
	miDCInitialize(screen, xf86GetPointerScreenFuncs());

	xf86DrvMsg(scrn->scrnIndex, X_INFO, "Initializing HW Cursor\n");
	if (!I830CursorInit(screen))
		xf86DrvMsg(scrn->scrnIndex, X_ERROR,
		    "Hardware cursor initialization failed\n");

	/* Must force it before EnterVT, so we are in control of VT and
	 * later memory should be bound when allocating, e.g rotate_mem */
	scrn->vtSema = TRUE;

	if (!I830EnterVT(scrnIndex, 0))
		return FALSE;

	intel->BlockHandler = screen->BlockHandler;
	screen->BlockHandler = I830BlockHandler;

	screen->SaveScreen = xf86SaveScreen;
	intel->CloseScreen = screen->CloseScreen;
	screen->CloseScreen = I830CloseScreen;
	intel->CreateScreenResources = screen->CreateScreenResources;
	screen->CreateScreenResources = i830CreateScreenResources;

	if (!xf86CrtcScreenInit(screen))
		return FALSE;

	DPRINTF(PFX, "assert( if(!miCreateDefColormap(screen)) )\n");
	if (!miCreateDefColormap(screen))
		return FALSE;

	DPRINTF(PFX, "assert( if(!xf86HandleColormaps(screen, ...)) )\n");
	if (!xf86HandleColormaps(screen, 256, 8, I830LoadPalette, NULL,
				 CMAP_RELOAD_ON_MODE_SWITCH |
				 CMAP_PALETTED_TRUECOLOR)) {
		return FALSE;
	}

	xf86DPMSInit(screen, xf86DPMSSet, 0);

#ifdef INTEL_XVMC
	if (IS_I965G(intel))
		intel->XvMCEnabled = TRUE;
	from = ((intel->directRenderingType == DRI_DRI2) &&
		xf86GetOptValBool(intel->Options, OPTION_XVMC,
				  &intel->XvMCEnabled) ? X_CONFIG : X_DEFAULT);
	xf86DrvMsg(scrn->scrnIndex, from, "Intel XvMC decoder %sabled\n",
		   intel->XvMCEnabled ? "en" : "dis");
#endif
	/* Init video */
	if (intel->XvEnabled)
		I830InitVideo(screen);

#if defined(DRI2)
	switch (intel->directRenderingType) {
	case DRI_DRI2:
		intel->directRenderingOpen = TRUE;
		xf86DrvMsg(scrn->scrnIndex, X_INFO,
			   "direct rendering: DRI2 Enabled\n");
		break;
	case DRI_DISABLED:
		xf86DrvMsg(scrn->scrnIndex, X_INFO,
			   "direct rendering: Disabled\n");
		break;
	case DRI_NONE:
		xf86DrvMsg(scrn->scrnIndex, X_INFO,
			   "direct rendering: Failed\n");
		break;
	}
#else
	xf86DrvMsg(scrn->scrnIndex, X_INFO,
		   "direct rendering: Not available\n");
#endif

	if (serverGeneration == 1)
		xf86ShowUnusedOptions(scrn->scrnIndex, scrn->options);

	intel->starting = FALSE;
	intel->closing = FALSE;
	intel->suspended = FALSE;

	return uxa_resources_init(screen);
}

static void i830AdjustFrame(int scrnIndex, int x, int y, int flags)
{
   ScrnInfoPtr scrn = xf86Screens[scrnIndex];
   xf86CrtcConfigPtr	config = XF86_CRTC_CONFIG_PTR(scrn);
   intel_screen_private *intel = intel_get_screen_private(scrn);
   xf86OutputPtr  output = config->output[config->compat_output];
   xf86CrtcPtr	crtc = output->crtc;

   DPRINTF(PFX, "i830AdjustFrame: y = %d (+ %d), x = %d (+ %d)\n",
	   x, crtc->desiredX, y, crtc->desiredY);

   if (intel->use_drm_mode)
      return;

   if (crtc && crtc->enabled)
   {
      /* Sync the engine before adjust frame */
      intel_sync(scrn);
      i830PipeSetBase(crtc, crtc->desiredX + x, crtc->desiredY + y);
      crtc->x = output->initial_x + x;
      crtc->y = output->initial_y + y;
   }
}

static void I830FreeScreen(int scrnIndex, int flags)
{
	ScrnInfoPtr scrn = xf86Screens[scrnIndex];

	i830_close_drm_master(scrn);

	I830FreeRec(xf86Screens[scrnIndex]);
	if (xf86LoaderCheckSymbol("vgaHWFreeHWRec"))
		vgaHWFreeHWRec(xf86Screens[scrnIndex]);
}

static void I830LeaveVT(int scrnIndex, int flags)
{
	ScrnInfoPtr scrn = xf86Screens[scrnIndex];
	intel_screen_private *intel = intel_get_screen_private(scrn);
	int ret;

	DPRINTF(PFX, "Leave VT\n");

	intel->leaving = TRUE;

	i830SetHotkeyControl(scrn, HOTKEY_BIOS_SWITCH);

	xf86RotateFreeShadow(scrn);

	xf86_hide_cursors(scrn);

	if (!intel->use_drm_mode) {
		RestoreHWState(scrn);

		/* console restore hack */
		if (IS_IGDNG(intel) && intel->int10 && intel->int10Mode) {
		    xf86Int10InfoPtr int10 = intel->int10;

		    /* Use int10 to restore the console mode */
		    int10->num = 0x10;
		    int10->ax = 0x4f02;
		    int10->bx = intel->int10Mode | 0x8000;
		    int10->cx = int10->dx = 0;
		    xf86ExecX86int10(int10);
		}

	}

	intel_batch_teardown(scrn);

	i830_unbind_all_memory(scrn);

	if (!intel->use_drm_mode) {
		int ret;

		/* Tell the kernel to evict all buffer objects and block GTT
		 * usage while we're no longer in control of the chip.
		 */
		ret = drmCommandNone(intel->drmSubFD, DRM_I915_GEM_LEAVEVT);
		if (ret != 0)
			FatalError("DRM_I915_LEAVEVT failed: %s\n",
			    strerror(ret));
		}

	if (IS_I965G(intel))
		gen4_render_state_cleanup(scrn);

	ret = drmDropMaster(intel->drmSubFD);
	if (ret)
		xf86DrvMsg(scrn->scrnIndex, X_WARNING,
			   "drmDropMaster failed: %s\n", strerror(errno));
}

/*
 * This gets called when gaining control of the VT, and from ScreenInit().
 */
static Bool I830EnterVT(int scrnIndex, int flags)
{
	ScrnInfoPtr scrn = xf86Screens[scrnIndex];
	xf86CrtcConfigPtr xf86_config = XF86_CRTC_CONFIG_PTR(scrn);
	intel_screen_private *intel = intel_get_screen_private(scrn);
	int i, ret;

	DPRINTF(PFX, "Enter VT\n");

	ret = drmSetMaster(intel->drmSubFD);
	if (ret) {
		if (errno == EINVAL) {
			xf86DrvMsg(scrn->scrnIndex, X_WARNING,
				   "drmSetMaster failed: 2.6.29 or newer kernel required for "
				   "multi-server DRI\n");
		} else {
			xf86DrvMsg(scrn->scrnIndex, X_WARNING,
				   "drmSetMaster failed: %s\n",
				   strerror(errno));
		}
	}

	/*
	 * Only save state once per server generation since that's what most
	 * drivers do.  Could change this to save state at each VT enter.
	 */
	if (intel->SaveGeneration != serverGeneration) {
		intel->SaveGeneration = serverGeneration;
		if (!intel->use_drm_mode)
			SaveHWState(scrn);
	}

	/* Get the hardware into a known state if needed */
	if (!intel->use_drm_mode) {

		I830SwapPipes(scrn);

		/* Disable outputs */
		for (i = 0; i < xf86_config->num_output; i++) {
			xf86OutputPtr   output = xf86_config->output[i];
			output->funcs->dpms(output, DPMSModeOff);
		}
		i830WaitForVblank(scrn);

		/* Disable pipes */
		for (i = 0; i < xf86_config->num_crtc; i++) {
			xf86CrtcPtr crtc = xf86_config->crtc[i];
			if (IS_IGDNG(intel))
			    ironlake_crtc_disable(crtc);
			else
			    i830_crtc_disable(crtc, TRUE);
		}
		i830WaitForVblank(scrn);
	}

	intel->leaving = FALSE;

	if (!intel->use_drm_mode) {
		int ret;

		i830_disable_render_standby(scrn);

		/* Tell the kernel that we're back in control and ready for GTT
		 * usage.
		 */
		ret = drmCommandNone(intel->drmSubFD, DRM_I915_GEM_ENTERVT);
		if (ret != 0)
			FatalError("DRM_I915_ENTERVT failed: %s\n",
			    strerror(ret));
	}

	if (!i830_bind_all_memory(scrn))
		return FALSE;

	i830_describe_allocations(scrn, 1, "");

	intel_batch_init(scrn);

	if (IS_I965G(intel))
		gen4_render_state_init(scrn);

	if (!intel->use_drm_mode) {
		I830InitHWCursor(scrn);

		/* Tell the BIOS that we're in control of mode setting now. */
		i830_init_bios_control(scrn);

		i830_init_clock_gating(scrn);

		if (intel->power_context)
			OUTREG(PWRCTXA, intel->power_context->offset |
			    PWRCTX_EN);
		/* Clear the framebuffer */
		memset(intel->FbBase + scrn->fbOffset, 0,
			scrn->virtualY * scrn->displayWidth * intel->cpp);
	}

	if (!xf86SetDesiredModes(scrn))
		return FALSE;

	if (!intel->use_drm_mode) {
		i830DescribeOutputConfiguration(scrn);
	}

	/* Set the hotkey to just notify us.  We could check its results
	 * periodically and attempt to do something, but it seems like we
	 * basically never get results when we should, and this should all
	 * be better handled through ACPI putting the key events out through
	 * evdev and your desktop environment picking it up.
	*/
	i830SetHotkeyControl(scrn, HOTKEY_DRIVER_NOTIFY);

	return TRUE;
}

static Bool I830SwitchMode(int scrnIndex, DisplayModePtr mode, int flags)
{
	ScrnInfoPtr scrn = xf86Screens[scrnIndex];

	return xf86SetSingleMode(scrn, mode, RR_Rotate_0);
}

static Bool I830CloseScreen(int scrnIndex, ScreenPtr screen)
{
	ScrnInfoPtr scrn = xf86Screens[scrnIndex];
	intel_screen_private *intel = intel_get_screen_private(scrn);

	intel->closing = TRUE;

	if (scrn->vtSema == TRUE) {
		I830LeaveVT(scrnIndex, 0);
	}

	if (!intel->use_drm_mode) {
		DPRINTF(PFX, "\nUnmapping memory\n");
		I830UnmapMem(scrn);
		vgaHWUnmapMem(scrn);
	}

	if (intel->uxa_driver) {
		uxa_driver_fini(screen);
		free(intel->uxa_driver);
		intel->uxa_driver = NULL;
	}
	if (intel->front_buffer) {
		i830_set_pixmap_bo(screen->GetScreenPixmap(screen), NULL);
		if (intel->use_drm_mode)
			drmmode_closefb(scrn);
		i830_free_memory(scrn, intel->front_buffer);
		intel->front_buffer = NULL;
	}

	xf86_cursors_fini(screen);

	i830_allocator_fini(scrn);

	i965_free_video(scrn);
	free(intel->offscreenImages);
	intel->offscreenImages = NULL;

	screen->CloseScreen = intel->CloseScreen;
	(*screen->CloseScreen) (scrnIndex, screen);

	if (intel->directRenderingOpen
	    && intel->directRenderingType == DRI_DRI2) {
		intel->directRenderingOpen = FALSE;
		I830DRI2CloseScreen(screen);
	}

	xf86GARTCloseScreen(scrnIndex);

	scrn->vtSema = FALSE;
	intel->closing = FALSE;
	return TRUE;
}

static ModeStatus
I830ValidMode(int scrnIndex, DisplayModePtr mode, Bool verbose, int flags)
{
	if (mode->Flags & V_INTERLACE) {
		if (verbose) {
			xf86DrvMsg(scrnIndex, X_PROBED,
				   "Removing interlaced mode \"%s\"\n",
				   mode->name);
		}
		return MODE_BAD;
	}
	return MODE_OK;
}

#ifndef SUSPEND_SLEEP
#define SUSPEND_SLEEP 0
#endif
#ifndef RESUME_SLEEP
#define RESUME_SLEEP 0
#endif

/*
 * This function is only required if we need to do anything differently from
 * DoApmEvent() in common/xf86PM.c, including if we want to see events other
 * than suspend/resume.
 */
static Bool I830PMEvent(int scrnIndex, pmEvent event, Bool undo)
{
	ScrnInfoPtr scrn = xf86Screens[scrnIndex];
	intel_screen_private *intel = intel_get_screen_private(scrn);

	DPRINTF(PFX, "Enter VT, event %d, undo: %s\n", event,
		BOOLTOSTRING(undo));

	switch (event) {
	case XF86_APM_SYS_SUSPEND:
	case XF86_APM_CRITICAL_SUSPEND:	/*do we want to delay a critical suspend? */
	case XF86_APM_USER_SUSPEND:
	case XF86_APM_SYS_STANDBY:
	case XF86_APM_USER_STANDBY:
		if (!undo && !intel->suspended) {
			scrn->LeaveVT(scrnIndex, 0);
			intel->suspended = TRUE;
			sleep(SUSPEND_SLEEP);
		} else if (undo && intel->suspended) {
			sleep(RESUME_SLEEP);
			scrn->EnterVT(scrnIndex, 0);
			intel->suspended = FALSE;
		}
		break;
	case XF86_APM_STANDBY_RESUME:
	case XF86_APM_NORMAL_RESUME:
	case XF86_APM_CRITICAL_RESUME:
		if (intel->suspended) {
			sleep(RESUME_SLEEP);
			scrn->EnterVT(scrnIndex, 0);
			intel->suspended = FALSE;
			/*
			 * Turn the screen saver off when resuming.  This seems to be
			 * needed to stop xscreensaver kicking in (when used).
			 *
			 * XXX DoApmEvent() should probably call this just like
			 * xf86VTSwitch() does.  Maybe do it here only in 4.2
			 * compatibility mode.
			 */
			SaveScreens(SCREEN_SAVER_FORCER, ScreenSaverReset);
		}
		break;
		/* This is currently used for ACPI */
	case XF86_APM_CAPABILITY_CHANGED:
		ErrorF("I830PMEvent: Capability change\n");

		SaveScreens(SCREEN_SAVER_FORCER, ScreenSaverReset);
		if (intel->quirk_flag & QUIRK_RESET_MODES)
			xf86SetDesiredModes(scrn);

		break;
	default:
		ErrorF("I830PMEvent: received APM event %d\n", event);
	}
	return TRUE;
}

xf86CrtcPtr i830_pipe_to_crtc(ScrnInfoPtr scrn, int pipe)
{
	xf86CrtcConfigPtr config = XF86_CRTC_CONFIG_PTR(scrn);
	int c;

	for (c = 0; c < config->num_crtc; c++) {
		xf86CrtcPtr crtc = config->crtc[c];
		I830CrtcPrivatePtr intel_crtc = crtc->driver_private;

		if (intel_crtc->pipe == pipe)
			return crtc;
	}

	return NULL;
}

void intel_init_scrn(ScrnInfoPtr scrn)
{
	scrn->PreInit = I830PreInit;
	scrn->ScreenInit = I830ScreenInit;
	scrn->SwitchMode = I830SwitchMode;
	scrn->AdjustFrame = i830AdjustFrame;
	scrn->EnterVT = I830EnterVT;
	scrn->LeaveVT = I830LeaveVT;
	scrn->FreeScreen = I830FreeScreen;
	scrn->ValidMode = I830ValidMode;
	scrn->PMEvent = I830PMEvent;
}
@


1.20
log
@Let the intel driver build with xserver >= 1.10.
Reminded by shadchin@@ ok oga@@
@
text
@@


1.19
log
@Update the intel driver to (mostly) a backport of 2.12.

It is missing a few commits that I have yet to verify (ones that try and
continue if we lock the gpu rendering engine and can't reset it, for
example) taht will be verified and sent out for extra testing soon.

Should contain a bunch of speedups and some correctness improvements
(though rendercheck still gives some errors that I am looking into).

This has been in snaps since the first day of c2k10, any known issues
with just this driver have (to my knowledge) been fixed since. A problem
with macbooks pointed out by otto happens with both this and the in-tree
driver and thus doesn't stop this moving forward.

As well as the 2.12 improvements, this driver also has a backport
(partially aided by the backports in RHEL 5 kindly provided by Dave
Airlie) from the kms code of modesetting support for ironlake (arrandale
and clarkdale: the IGDs build into intel nehalem cpu dies) which has
been tested on a number of chipsets. Note that Display port and eDP
displays have not yet been worked on (and probably won't until I can
find a displayport monitor), but VGA and lvds at least are known to
work, sure beats vesa.

"no objection on my side" matthieu@@, prodding (as always) from princess
marco.
@
text
@d911 1
d913 1
@


1.18
log
@Pull in the changes in rendering that I skipped when i backported
changes from later intel versions (after the UMS removal). 95% of this
is the xvmc reworks that makes that code even halfway sane. xvmc is now
enabled by default on 965+.

Tested by many on tech@@, thanks!

ok matthieu@@
@
text
@d51 1
a257 2
	intel_screen_private *intel;

d263 1
a263 3
	intel = intel_get_screen_private(scrn);

	xfree(scrn->driverPrivate);
a497 4
   if (intel->ring.mem != NULL) {
      intel->ring.virtual_start = intel->FbBase + intel->ring.mem->offset;
   }

d655 23
a677 1
	if (IS_I9XX(intel)) {
d696 1
a696 1
	if (IS_I9XX(intel) && IS_MOBILE(intel))
d984 1
a984 1
	xfree(busIdString);
d1254 1
a1254 1
	if (!(intel->Options = xalloc(sizeof(I830Options))))
d1345 19
d1398 8
d1428 1
a1428 1
		xfree(busid);
d1432 1
a1432 1
	xfree(busid);
a1486 2
	intel->have_gem = TRUE;

a1557 1
	intel->kernel_exec_fencing = intel->use_drm_mode;
d1659 24
a1699 75
/*
 * Reset registers that it doesn't make sense to save/restore to a sane state.
 * This is basically the ring buffer and fence registers.  Restoring these
 * doesn't make sense without restoring GTT mappings.  This is something that
 * whoever gets control next should do.
 */
static void i830_stop_ring(ScrnInfoPtr scrn, Bool flush)
{
	intel_screen_private *intel = intel_get_screen_private(scrn);
	unsigned long temp;

	DPRINTF(PFX, "ResetState: flush is %s\n", BOOLTOSTRING(flush));

	/* Flush the ring buffer, then disable it. */
	temp = INREG(LP_RING + RING_LEN);
	if (temp & RING_VALID) {
		i830_refresh_ring(scrn);
		i830_wait_ring_idle(scrn);
	}

	OUTREG(LP_RING + RING_LEN, 0);
	OUTREG(LP_RING + RING_HEAD, 0);
	OUTREG(LP_RING + RING_TAIL, 0);
	OUTREG(LP_RING + RING_START, 0);
}

static void i830_start_ring(ScrnInfoPtr scrn)
{
	intel_screen_private *intel = intel_get_screen_private(scrn);
	unsigned int itemp;

	DPRINTF(PFX, "SetRingRegs\n");

	OUTREG(LP_RING + RING_LEN, 0);
	OUTREG(LP_RING + RING_TAIL, 0);
	OUTREG(LP_RING + RING_HEAD, 0);

	assert((intel->ring.mem->offset & I830_RING_START_MASK) ==
	    intel->ring.mem->offset);

	/* Don't care about the old value. Reserved bits must be zero anyway. */
	itemp = intel->ring.mem->offset;
	OUTREG(LP_RING + RING_START, itemp);

	if (((intel->ring.mem->size - 4096) & I830_RING_NR_PAGES) !=
	    intel->ring.mem->size - 4096) {
		xf86DrvMsg(scrn->scrnIndex, X_ERROR,
		    "I830SetRingRegs: Ring buffer size - 4096 (%lx) violates "
		    "its mask (%x)\n", intel->ring.mem->size - 4096,
		    I830_RING_NR_PAGES);
	}
	/* Don't care about the old value. Reserved bits must be zero anyway. */
	itemp = (intel->ring.mem->size - 4096) & I830_RING_NR_PAGES;
	itemp |= (RING_NO_REPORT | RING_VALID);
	OUTREG(LP_RING + RING_LEN, itemp);
	i830_refresh_ring(scrn);
}

void i830_refresh_ring(ScrnInfoPtr scrn)
{
	intel_screen_private *intel = intel_get_screen_private(scrn);

	/* If we're reaching RefreshRing as a result of grabbing the DRI lock
	 * before we've set up the ringbuffer, don't bother.
	 */
	if (intel->ring.mem == NULL)
		return;

	intel->ring.head = INREG(LP_RING + RING_HEAD) & I830_HEAD_MASK;
	intel->ring.tail = INREG(LP_RING + RING_TAIL);
	intel->ring.space = intel->ring.head - (intel->ring.tail + 8);
	if (intel->ring.space < 0)
		intel->ring.space += intel->ring.mem->size;
}

d1707 9
a1715 4
	if (pipe == PIPE_A)
		return (INREG(PIPEACONF) & PIPEACONF_ENABLE);
	else
		return (INREG(PIPEBCONF) & PIPEBCONF_ENABLE);
d1720 2
d1727 10
a1736 6
	for(i= 0; i < 256; i++) {
		if (pipe == PIPE_A)
			intel->savePaletteA[i] = INREG(PALETTE_A + (i << 2));
		else
			intel->savePaletteB[i] = INREG(PALETTE_B + (i << 2));
	}
d1741 2
d1748 10
a1757 6
	for(i= 0; i < 256; i++) {
		if (pipe == PIPE_A)
			OUTREG(PALETTE_A + (i << 2), intel->savePaletteA[i]);
		else
			OUTREG(PALETTE_B + (i << 2), intel->savePaletteB[i]);
	}
d1768 3
d1897 3
d2101 1
a2101 1
    
a2170 5
		 *
		 * XXX Under KMS this is only required because tfp does not have
		 * the appropriate synchronisation points, so that outstanding updates
		 * to the pixmap are flushed prior to use as a texture. The framebuffer
		 * should be handled by the kernel domain management...
d2172 3
a2174 4
		if (intel->need_mi_flush || !list_is_empty(&intel->flush_pixmaps))
			intel_batch_emit_flush(scrn);

		intel_batch_submit(scrn);
d2312 1
a2312 1
	if (intel->have_gem) {
d2314 7
a2320 1
		batch_size = 4096 * 4;
a2321 14
		/* The 865 has issues with larger-than-page-sized batch buffers. */
		if (IS_I865G(intel))
			batch_size = 4096;

		intel->bufmgr = intel_bufmgr_gem_init(intel->drmSubFD, batch_size);
		intel_bufmgr_gem_enable_reuse(intel->bufmgr);
		drm_intel_bufmgr_gem_enable_fenced_relocs(intel->bufmgr);
	} else {
		assert(intel->FbBase != NULL);
		intel->bufmgr = intel_bufmgr_fake_init(intel->drmSubFD,
		    intel->fake_bufmgr_mem->offset, intel->FbBase +
		        intel->fake_bufmgr_mem->offset,
		        intel->fake_bufmgr_mem->size, NULL);
	}
d2443 2
a2444 1
	if (I830LVDSPresent(scrn) && !IS_I965GM(intel) && !IS_GM45(intel)) {
d2479 1
a2479 1
	ScrnInfoPtr scrn = xf86Screens[screen->myNum];;
d2689 1
a2689 1
	if (IS_I965G(intel))
d2691 2
a2692 1
	else if (IS_I9XX(intel))
d2694 1
a2694 1
	else
d2780 1
a2780 1
	return TRUE;
a2827 4
	if (intel->devicesTimer)
		TimerFree(intel->devicesTimer);
	intel->devicesTimer = NULL;

a2833 2
	intel_sync(scrn);

d2836 11
a2846 6
		/* Evict everything from the bufmgr, as we're about to lose
		 * ownership of the graphics memory.
		 */
		if (!intel->have_gem) {
			intel_bufmgr_fake_evict_all(intel->bufmgr);
			i830_stop_ring(scrn, TRUE);
d2855 1
a2855 1
	if (intel->have_gem && !intel->use_drm_mode) {
d2926 4
a2929 1
			i830_crtc_disable(crtc, TRUE);
d2936 3
a2938 1
	if (!intel->use_drm_mode)
a2940 3
	if (intel->have_gem && !intel->use_drm_mode) {
		int ret;

a2960 5
		/* Re-set up the ring. */
		if (!intel->have_gem) {
			i830_stop_ring(scrn, FALSE);
			i830_start_ring(scrn);
		}
a3011 4
	if (intel->devicesTimer)
		TimerFree(intel->devicesTimer);
	intel->devicesTimer = NULL;

d3020 1
a3020 1
		xfree(intel->uxa_driver);
@


1.17
log
@Update the intel driver to 2.9.1 plus backports.

2.9.1 is the last version of the intel DDX that supports UMS (User
modesetting), with 2.10 onwards being purely KMS only. As such, this
driver contains backports of almost every correctness or performance
related fix to the rendering layer in later intel drivers. This driver
*REQUIRES* a GEM enabled kernel. it claims to support non-gem mode but
this is essentially unmaintained and due to the way the abstraciton
works is slow, if it works at all (it often does not). You have been
warned.

tested by many many people on tech over the last few weeks.
@
text
@d2741 2
a2742 1
	intel->XvMCEnabled = FALSE;
a2810 5
#ifdef INTEL_XVMC
	intel_screen_private *intel = intel_get_screen_private(scrn);
	if (intel && intel->XvMCEnabled)
		intel_xvmc_finish(xf86Screens[scrnIndex]);
#endif
@


1.16
log
@Here's a really good idea: when preparing for a vt switch the intel
driver idles the ringbuffer, stops it, unbinds all memory, then hands
back off.

Now here's the clever bit: just before we call to idle the ringbuffer
(which sleeps waiting for an interrupt) let's TURN OFF THE FUCKING
INTERRUPT. That's a great idea, really, isn't it?

Move the interrupt disable to *after* stop_ring. Theo's T61 VT switches
again.  everyone elses' intel stuff worked by magic (or shared
interrupts) before now.

Fixed after discussion with deraadt@@, thanks to miod for suggestions.
@
text
@a0 1
/* $XFree86: xc/programs/Xserver/hw/xfree86/drivers/i810/i830_driver.c,v 1.50 2004/02/20 00:06:00 alanh Exp $ */
a29 13
 * Reformatted with GNU indent (2.2.8), using the following options:
 *
 *    -bad -bap -c41 -cd0 -ncdb -ci6 -cli0 -cp0 -ncs -d0 -di3 -i3 -ip3 -l78
 *    -lp -npcs -psl -sob -ss -br -ce -sc -hnl
 *
 * This provides a good match with the original i810 code and preferred
 * XFree86 formatting conventions.
 *
 * When editing this driver, please follow the existing formatting, and edit
 * with <TAB> characters expanded at 8-column intervals.
 */

/*
a35 110
/*
 * Mode handling is based on the VESA driver written by:
 * Paulo CÃ©sar Pereira de Andrade <pcpa@@conectiva.com.br>
 */

/*
 * Changes:
 *
 *    23/08/2001 Abraham van der Merwe <abraham@@2d3d.co.za>
 *        - Fixed display timing bug (mode information for some
 *          modes were not initialized correctly)
 *        - Added workarounds for GTT corruptions (I don't adjust
 *          the pitches for 1280x and 1600x modes so we don't
 *          need extra memory)
 *        - The code will now default to 60Hz if LFP is connected
 *        - Added different refresh rate setting code to work
 *          around 0x4f02 BIOS bug
 *        - BIOS workaround for some mode sets (I use legacy BIOS
 *          calls for setting those)
 *        - Removed 0x4f04, 0x01 (save state) BIOS call which causes
 *          LFP to malfunction (do some house keeping and restore
 *          modes ourselves instead - not perfect, but at least the
 *          LFP is working now)
 *        - Several other smaller bug fixes
 *
 *    06/09/2001 Abraham van der Merwe <abraham@@2d3d.co.za>
 *        - Preliminary local memory support (works without agpgart)
 *        - DGA fixes (the code were still using i810 mode sets, etc.)
 *        - agpgart fixes
 *
 *    18/09/2001
 *        - Proper local memory support (should work correctly now
 *          with/without agpgart module)
 *        - more agpgart fixes
 *        - got rid of incorrect GTT adjustments
 *
 *    09/10/2001
 *        - Changed the DPRINTF() variadic macro to an ANSI C compatible
 *          version
 *
 *    10/10/2001
 *        - Fixed DPRINTF_stub(). I forgot the __...__ macros in there
 *          instead of the function arguments :P
 *        - Added a workaround for the 1600x1200 bug (Text mode corrupts
 *          when you exit from any 1600x1200 mode and 1280x1024@@85Hz. I
 *          suspect this is a BIOS bug (hence the 1280x1024@@85Hz case)).
 *          For now I'm switching to 800x600@@60Hz then to 80x25 text mode
 *          and then restoring the registers - very ugly indeed.
 *
 *    15/10/2001
 *        - Improved 1600x1200 mode set workaround. The previous workaround
 *          was causing mode set problems later on.
 *
 *    18/10/2001
 *        - Fixed a bug in I830BIOSLeaveVT() which caused a bug when you
 *          switched VT's
 */
/*
 *    07/2002 David Dawes
 *        - Add Intel(R) 855GM/852GM support.
 */
/*
 *    07/2002 David Dawes
 *        - Cleanup code formatting.
 *        - Improve VESA mode selection, and fix refresh rate selection.
 *        - Don't duplicate functions provided in 4.2 vbe modules.
 *        - Don't duplicate functions provided in the vgahw module.
 *        - Rewrite memory allocation.
 *        - Rewrite initialisation and save/restore state handling.
 *        - Decouple the i810 support from i830 and later.
 *        - Remove various unnecessary hacks and workarounds.
 *        - Fix an 845G problem with the ring buffer not in pre-allocated
 *          memory.
 *        - Fix screen blanking.
 *        - Clear the screen at startup so you don't see the previous session.
 *        - Fix some HW cursor glitches, and turn HW cursor off at VT switch
 *          and exit.
 *
 *    08/2002 Keith Whitwell
 *        - Fix DRI initialisation.
 *
 *
 *    08/2002 Alan Hourihane and David Dawes
 *        - Add XVideo support.
 *
 *
 *    10/2002 David Dawes
 *        - Add Intel(R) 865G support.
 *
 *
 *    01/2004 Alan Hourihane
 *        - Add Intel(R) 915G support.
 *        - Add Dual Head and Clone capabilities.
 *        - Add lid status checking
 *        - Fix Xvideo with high-res LFP's
 *        - Add ARGB HW cursor support
 *
 *    05/2005 Alan Hourihane
 *        - Add Intel(R) 945G support.
 *
 *    09/2005 Alan Hourihane
 *        - Add Intel(R) 945GM support.
 *
 *    10/2005 Alan Hourihane, Keith Whitwell, Brian Paul
 *        - Added Rotation support
 *
 *    12/2005 Alan Hourihane, Keith Whitwell
 *        - Add Intel(R) 965G support.
 */

a53 2
#include "xf86Resources.h"
#include "xf86RAC.h"
a70 1
#include "i830_debug.h"
a81 2
#ifdef XF86DRI
#include "dri.h"
a83 3
#endif

#ifdef XF86DRM_MODE
a84 13
#endif

#ifdef I830_USE_EXA
const char *I830exaSymbols[] = {
    "exaGetVersion",
    "exaDriverInit",
    "exaDriverFini",
    "exaOffscreenAlloc",
    "exaOffscreenFree",
    "exaWaitSync",
    NULL
};
#endif
d102 2
a103 2
   {PCI_CHIP_IGD_GM,		"IGD"},
   {PCI_CHIP_IGD_G,		"IGD"},
d113 2
a114 2
   {PCI_CHIP_GM45_GM,		"Mobile IntelÂ® GM45 Express Chipset"},
   {PCI_CHIP_IGD_E_G,		"Intel Integrated Graphics Device"},
d118 3
d125 30
a154 27
   {PCI_CHIP_I830_M,		PCI_CHIP_I830_M,	RES_SHARED_VGA},
   {PCI_CHIP_845_G,		PCI_CHIP_845_G,		RES_SHARED_VGA},
   {PCI_CHIP_I855_GM,		PCI_CHIP_I855_GM,	RES_SHARED_VGA},
   {PCI_CHIP_I865_G,		PCI_CHIP_I865_G,	RES_SHARED_VGA},
   {PCI_CHIP_I915_G,		PCI_CHIP_I915_G,	RES_SHARED_VGA},
   {PCI_CHIP_E7221_G,		PCI_CHIP_E7221_G,	RES_SHARED_VGA},
   {PCI_CHIP_I915_GM,		PCI_CHIP_I915_GM,	RES_SHARED_VGA},
   {PCI_CHIP_I945_G,		PCI_CHIP_I945_G,	RES_SHARED_VGA},
   {PCI_CHIP_I945_GM,		PCI_CHIP_I945_GM,	RES_SHARED_VGA},
   {PCI_CHIP_I945_GME,		PCI_CHIP_I945_GME,	RES_SHARED_VGA},
   {PCI_CHIP_IGD_GM,		PCI_CHIP_IGD_GM,	RES_SHARED_VGA},
   {PCI_CHIP_IGD_G,		PCI_CHIP_IGD_G,		RES_SHARED_VGA},
   {PCI_CHIP_I965_G,		PCI_CHIP_I965_G,	RES_SHARED_VGA},
   {PCI_CHIP_G35_G,		PCI_CHIP_G35_G,		RES_SHARED_VGA},
   {PCI_CHIP_I965_Q,		PCI_CHIP_I965_Q,	RES_SHARED_VGA},
   {PCI_CHIP_I946_GZ,		PCI_CHIP_I946_GZ,	RES_SHARED_VGA},
   {PCI_CHIP_I965_GM,		PCI_CHIP_I965_GM,	RES_SHARED_VGA},
   {PCI_CHIP_I965_GME,		PCI_CHIP_I965_GME,	RES_SHARED_VGA},
   {PCI_CHIP_G33_G,		PCI_CHIP_G33_G,		RES_SHARED_VGA},
   {PCI_CHIP_Q35_G,		PCI_CHIP_Q35_G,		RES_SHARED_VGA},
   {PCI_CHIP_Q33_G,		PCI_CHIP_Q33_G,		RES_SHARED_VGA},
   {PCI_CHIP_GM45_GM,		PCI_CHIP_GM45_GM,	RES_SHARED_VGA},
   {PCI_CHIP_IGD_E_G,		PCI_CHIP_IGD_E_G,	RES_SHARED_VGA},
   {PCI_CHIP_G45_G,		PCI_CHIP_G45_G,		RES_SHARED_VGA},
   {PCI_CHIP_Q45_G,		PCI_CHIP_Q45_G,		RES_SHARED_VGA},
   {PCI_CHIP_G41_G,		PCI_CHIP_G41_G,		RES_SHARED_VGA},
   {-1,				-1,			RES_UNDEFINED}
a163 3
   OPTION_ACCELMETHOD,
   OPTION_NOACCEL,
   OPTION_CACHE_LINES,
d172 1
d179 3
a184 3
   {OPTION_ACCELMETHOD,	"AccelMethod",	OPTV_ANYSTR,	{0},	FALSE},
   {OPTION_NOACCEL,	"NoAccel",	OPTV_BOOLEAN,	{0},	FALSE},
   {OPTION_CACHE_LINES,	"CacheLines",	OPTV_INTEGER,	{0},	FALSE},
d193 1
d200 3
a206 9
const char *i830_output_type_names[] = {
   "Unused",
   "Analog",
   "DVO",
   "SDVO",
   "LVDS",
   "TVOUT",
};

d208 1
a208 1
static Bool I830CloseScreen(int scrnIndex, ScreenPtr pScreen);
d210 2
a211 2
static Bool SaveHWState(ScrnInfoPtr pScrn);
static Bool RestoreHWState(ScrnInfoPtr pScrn);
d214 1
a214 1
extern void xf86SetCursor(ScreenPtr pScreen, CursorPtr pCurs, int x, int y);
d218 2
a219 2
I830DPRINTF_stub(const char *filename, int line, const char *function,
		 const char *fmt, ...)
d221 1
a221 1
   va_list ap;
d223 7
a229 14
   ErrorF("\n##############################################\n"
	  "*** In function %s, on line %d, in file %s ***\n",
	  function, line, filename);
   va_start(ap, fmt);
   VErrorF(fmt, ap);
   va_end(ap);
   ErrorF("##############################################\n\n");
}
#else /* #ifdef I830DEBUG */
void
I830DPRINTF_stub(const char *filename, int line, const char *function,
		 const char *fmt, ...)
{
   /* do nothing */
d234 1
a234 2
const OptionInfoRec *
I830AvailableOptions(int chipid, int busid)
d236 1
a236 1
   int i;
d238 5
a242 5
   for (i = 0; I830PciChipsets[i].PCIid > 0; i++) {
      if (chipid == I830PciChipsets[i].PCIid)
	 return I830Options;
   }
   return NULL;
d245 1
a245 2
static Bool
I830GetRec(ScrnInfoPtr pScrn)
d247 1
a247 1
   I830Ptr pI830;
d249 4
a252 4
   if (pScrn->driverPrivate)
      return TRUE;
   pI830 = pScrn->driverPrivate = xnfcalloc(sizeof(I830Rec), 1);
   return TRUE;
d255 1
a255 2
static void
I830FreeRec(ScrnInfoPtr pScrn)
d257 1
a257 1
   I830Ptr pI830;
d259 4
a262 4
   if (!pScrn)
      return;
   if (!pScrn->driverPrivate)
      return;
d264 1
a264 1
   pI830 = I830PTR(pScrn);
d266 2
a267 2
   xfree(pScrn->driverPrivate);
   pScrn->driverPrivate = NULL;
d271 1
a271 1
I830DetectMemory(ScrnInfoPtr pScrn)
d273 1
a273 4
   I830Ptr pI830 = I830PTR(pScrn);
#if !XSERVER_LIBPCIACCESS
   PCITAG bridge;
#endif
a276 2

#if XSERVER_LIBPCIACCESS
a278 4
#else
   bridge = pciTag(0, 0, 0);		/* This is always the host bridge */
   gmch_ctrl = pciReadWord(bridge, I830_GMCH_CTRL);
#endif
d280 1
a280 1
   if (IS_I965G(pI830)) {
d307 1
a307 1
   } else if (IS_G33CLASS(pI830)) {
d322 1
a322 1
      gtt_size = pI830->FbMapSize / (1024*1024);
d325 1
a325 1
   xf86DrvMsg(pScrn->scrnIndex, X_INFO, "detected %d kB GTT.\n", gtt_size);
d333 1
a333 1
   if (IS_G4X(pI830) || IS_IGD(pI830))
d336 1
a336 1
   if (IS_I85X(pI830) || IS_I865G(pI830) || IS_I9XX(pI830)) {
d354 1
a354 1
	 if (IS_I9XX(pI830))
d358 1
a358 1
	 if (IS_I9XX(pI830))
d362 1
a362 1
	 if (IS_I9XX(pI830))
d366 1
a366 1
	 if (IS_I9XX(pI830))
d370 1
a370 1
	 if (IS_I9XX(pI830))
d374 1
a374 1
	 if (IS_I9XX(pI830))
d378 1
a378 1
	 if (IS_I9XX(pI830))
d382 1
a382 1
	 if (IS_I9XX(pI830))
d399 1
a399 1
	 xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
d411 1
a411 1
      xf86DrvMsg(pScrn->scrnIndex, X_INFO,
d414 1
a414 1
      xf86DrvMsg(pScrn->scrnIndex, X_INFO, "no video memory detected.\n");
d421 1
a421 1
I830MapMMIO(ScrnInfoPtr pScrn)
a422 1
#if XSERVER_LIBPCIACCESS
d425 1
a425 4
#else
   int mmioFlags;
#endif
   I830Ptr pI830 = I830PTR(pScrn);
d427 1
a427 2
#if XSERVER_LIBPCIACCESS
   device = pI830->PciInfo;
d429 2
a430 2
			       pI830->MMIOAddr,
			       I810_REG_SIZE,
d432 1
a432 1
			       (void **) &pI830->MMIOBase);
d435 1
a435 1
      xf86DrvMsg (pScrn->scrnIndex, X_ERROR,
a439 14
#else

#if !defined(__alpha__)
   mmioFlags = VIDMEM_MMIO | VIDMEM_READSIDEEFFECT;
#else
   mmioFlags = VIDMEM_MMIO | VIDMEM_READSIDEEFFECT | VIDMEM_SPARSE;
#endif

   pI830->MMIOBase = xf86MapPciMem(pScrn->scrnIndex, mmioFlags,
				   pI830->PciTag,
				   pI830->MMIOAddr, I810_REG_SIZE);
   if (!pI830->MMIOBase)
      return FALSE;
#endif
d444 1
a444 1
   if (IS_I9XX(pI830)) {
d447 1
a447 1
      if (IS_I965G(pI830)) 
d449 3
a451 3
	 if (IS_G4X(pI830)) {
	     gttaddr = pI830->MMIOAddr + MB(2);
	     pI830->GTTMapSize = MB(2);
d453 2
a454 2
	     gttaddr = pI830->MMIOAddr + KB(512);
	     pI830->GTTMapSize = KB(512);
d459 2
a460 2
	 gttaddr = I810_MEMBASE(pI830->PciInfo, 3) & 0xFFFFFF00;
	 pI830->GTTMapSize = pI830->FbMapSize / 1024;
a461 1
#if XSERVER_LIBPCIACCESS
d463 1
a463 1
				  gttaddr, pI830->GTTMapSize,
d465 1
a465 1
				  (void **) &pI830->GTTBase);
d468 1
a468 1
	 xf86DrvMsg (pScrn->scrnIndex, X_ERROR,
a472 7
#else
      pI830->GTTBase = xf86MapPciMem(pScrn->scrnIndex, mmioFlags,
				     pI830->PciTag,
				     gttaddr, pI830->GTTMapSize);
      if (pI830->GTTBase == NULL)
	 return FALSE;
#endif
d477 2
a478 2
      pI830->GTTBase = NULL;
      pI830->GTTMapSize = 0;
d485 1
a485 1
I830MapMem(ScrnInfoPtr pScrn)
d487 1
a487 1
   I830Ptr pI830 = I830PTR(pScrn);
d489 1
a489 2
#if XSERVER_LIBPCIACCESS
   struct pci_device *const device = pI830->PciInfo;
a490 1
#endif
d492 2
a493 5
   for (i = 2; i < pI830->FbMapSize; i <<= 1) ;
   pI830->FbMapSize = i;

   if (!I830MapMMIO(pScrn))
      return FALSE;
d495 1
a495 2
#if XSERVER_LIBPCIACCESS
   err = pci_device_map_range (device, pI830->LinearAddr, pI830->FbMapSize,
d497 1
a497 1
			       (void **) &pI830->FbBase);
a499 7
#else
   pI830->FbBase = xf86MapPciMem(pScrn->scrnIndex, VIDMEM_FRAMEBUFFER,
				 pI830->PciTag,
				 pI830->LinearAddr, pI830->FbMapSize);
   if (!pI830->FbBase)
      return FALSE;
#endif
d501 2
a502 2
   if (pI830->ring.mem != NULL) {
      pI830->ring.virtual_start = pI830->FbBase + pI830->ring.mem->offset;
d509 1
a509 1
I830UnmapMMIO(ScrnInfoPtr pScrn)
d511 1
a511 1
   I830Ptr pI830 = I830PTR(pScrn);
d513 2
a514 7
#if XSERVER_LIBPCIACCESS
   pci_device_unmap_range (pI830->PciInfo, pI830->MMIOBase, I810_REG_SIZE);
#else
   xf86UnMapVidMem(pScrn->scrnIndex, (pointer) pI830->MMIOBase,
		   I810_REG_SIZE);
#endif
   pI830->MMIOBase = NULL;
d516 3
a518 7
   if (IS_I9XX(pI830)) {
#if XSERVER_LIBPCIACCESS
      pci_device_unmap_range (pI830->PciInfo, pI830->GTTBase, pI830->GTTMapSize);
#else
      xf86UnMapVidMem(pScrn->scrnIndex, pI830->GTTBase, pI830->GTTMapSize);
#endif
      pI830->GTTBase = NULL;
d523 1
a523 1
I830UnmapMem(ScrnInfoPtr pScrn)
d525 1
a525 1
   I830Ptr pI830 = I830PTR(pScrn);
d527 3
a529 8
#if XSERVER_LIBPCIACCESS
   pci_device_unmap_range (pI830->PciInfo, pI830->FbBase, pI830->FbMapSize);
#else
   xf86UnMapVidMem(pScrn->scrnIndex, (pointer) pI830->FbBase,
		   pI830->FbMapSize);
#endif
   pI830->FbBase = NULL;
   I830UnmapMMIO(pScrn);
d534 1
a534 1
I830LoadPalette(ScrnInfoPtr pScrn, int numColors, int *indices,
d537 17
a553 17
   xf86CrtcConfigPtr   xf86_config = XF86_CRTC_CONFIG_PTR(pScrn);
   int i,j, index;
   int p;
   uint16_t lut_r[256], lut_g[256], lut_b[256];

   DPRINTF(PFX, "I830LoadPalette: numColors: %d\n", numColors);

   for(p = 0; p < xf86_config->num_crtc; p++) {
      xf86CrtcPtr	   crtc = xf86_config->crtc[p];
      I830CrtcPrivatePtr   intel_crtc = crtc->driver_private;

      /* Initialize to the old lookup table values. */
      for (i = 0; i < 256; i++) {
	 lut_r[i] = intel_crtc->lut_r[i] << 8;
	 lut_g[i] = intel_crtc->lut_g[i] << 8;
	 lut_b[i] = intel_crtc->lut_b[i] << 8;
      }
d555 42
a596 36
      switch(pScrn->depth) {
      case 15:
	 for (i = 0; i < numColors; i++) {
	    index = indices[i];
	    for (j = 0; j < 8; j++) {
	       lut_r[index * 8 + j] = colors[index].red << 8;
	       lut_g[index * 8 + j] = colors[index].green << 8;
	       lut_b[index * 8 + j] = colors[index].blue << 8;
	    }
         }
	 break;
      case 16:
	 for (i = 0; i < numColors; i++) {
	    index = indices[i];

	    if (index <= 31) {
	       for (j = 0; j < 8; j++) {
		  lut_r[index * 8 + j] = colors[index].red << 8;
		  lut_b[index * 8 + j] = colors[index].blue << 8;
	       }
	    }

	    for (j = 0; j < 4; j++) {
	       lut_g[index * 4 + j] = colors[index].green << 8;
	    }
         }
        break;
      default:
	 for (i = 0; i < numColors; i++) {
	    index = indices[i];
	    lut_r[index] = colors[index].red << 8;
	    lut_g[index] = colors[index].green << 8;
	    lut_b[index] = colors[index].blue << 8;
	 }
	 break;
      }
d598 1
a598 1
      /* Make the change through RandR */
d600 1
a600 1
      RRCrtcGammaSet(crtc->randr_crtc, lut_r, lut_g, lut_b);
d602 1
a602 1
      crtc->funcs->gamma_set(crtc, lut_r, lut_g, lut_b, 256);
d604 1
a604 44
   }
}

void
i830_update_front_offset(ScrnInfoPtr pScrn)
{
   ScreenPtr pScreen = pScrn->pScreen;
   I830Ptr pI830 = I830PTR(pScrn);
   int pitch = pScrn->displayWidth * pI830->cpp;
   pointer data = NULL;

   /* Update buffer locations, which may have changed as a result of
    * i830_bind_all_memory().
    */
   pScrn->fbOffset = pI830->front_buffer->offset;

   if (pI830->starting || pI830->accel == ACCEL_UXA)
       return;

   /* If we are still in ScreenInit, there is no screen pixmap to be updated
    * yet.  We'll fix it up at CreateScreenResources.
    */
   if (!pI830->memory_manager) {
       data = pI830->FbBase + pScrn->fbOffset; /* default to legacy */
   } else {
      dri_bo *bo = pI830->front_buffer->bo;

      if (bo) {
	  if (pI830->kernel_exec_fencing) {
	      if (drm_intel_gem_bo_map_gtt(bo))
		  xf86DrvMsg(pScrn->scrnIndex, X_WARNING, "%s: bo map failed\n",
			     __FUNCTION__);
	      data = bo->virtual;
	  } else {
	      /* Will already be pinned by bind_all_memory in this case */
	      drm_intel_gem_bo_start_gtt_access(bo, 1);
	      data = pI830->FbBase + bo->offset;
	  }
      }
   }
   if (!pScreen->ModifyPixmapHeader(pScreen->GetScreenPixmap(pScreen),
				       pScrn->virtualX, pScrn->virtualY, -1, -1,
				       pitch, data))
       FatalError("Couldn't adjust screen pixmap\n");
d613 1
a613 2
static Bool
i830CreateScreenResources(ScreenPtr pScreen)
d615 2
a616 2
   ScrnInfoPtr pScrn = xf86Screens[pScreen->myNum];
   I830Ptr pI830 = I830PTR(pScrn);
d618 3
a620 3
   pScreen->CreateScreenResources = pI830->CreateScreenResources;
   if (!(*pScreen->CreateScreenResources)(pScreen))
      return FALSE;
d622 1
a622 1
   i830_update_front_offset(pScrn);
d624 1
a624 5
#ifdef I830_USE_UXA
   if (pI830->accel == ACCEL_UXA)
      i830_uxa_create_screen_resources(pScreen);
#endif
   return TRUE;
d627 1
a627 2
int
i830_output_clones (ScrnInfoPtr pScrn, int type_mask)
d629 11
a639 12
    xf86CrtcConfigPtr	config = XF86_CRTC_CONFIG_PTR (pScrn);
    int			o;
    int			index_mask = 0;

    for (o = 0; o < config->num_output; o++)
    {
	xf86OutputPtr		output = config->output[o];
	I830OutputPrivatePtr	intel_output = output->driver_private;
	if (type_mask & (1 << intel_output->type))
	    index_mask |= (1 << o);
    }
    return index_mask;
d648 1
a648 2
static void
I830SetupOutputs(ScrnInfoPtr pScrn)
d650 16
a665 16
   xf86CrtcConfigPtr	config = XF86_CRTC_CONFIG_PTR (pScrn);
   I830Ptr  pI830 = I830PTR(pScrn);
   int	    o, c;
   Bool	    lvds_detected = FALSE;

   /* everyone has at least a single analog output */
   i830_crt_init(pScrn);

   /* Set up integrated LVDS */
   if (IS_MOBILE(pI830) && !IS_I830(pI830))
      i830_lvds_init(pScrn);

   if (IS_I9XX(pI830)) {
      Bool found = FALSE;
      if ((INREG(SDVOB) & SDVO_DETECTED)) {
	 found = i830_sdvo_init(pScrn, SDVOB);
d667 3
a669 3
	 if (!found && SUPPORTS_INTEGRATED_HDMI(pI830))
	    i830_hdmi_init(pScrn, SDVOB);
      }
d671 2
a672 2
      if ((INREG(SDVOB) & SDVO_DETECTED))
	 found = i830_sdvo_init(pScrn, SDVOC);
d674 3
a676 3
      if ((INREG(SDVOC) & SDVO_DETECTED) &&
	    !found && SUPPORTS_INTEGRATED_HDMI(pI830))
	 i830_hdmi_init(pScrn, SDVOC);
d678 5
a682 5
   } else {
      i830_dvo_init(pScrn);
   }
   if (IS_I9XX(pI830) && IS_MOBILE(pI830))
      i830_tv_init(pScrn);
d684 4
a687 5
   for (o = 0; o < config->num_output; o++)
   {
      xf86OutputPtr	   output = config->output[o];
      I830OutputPrivatePtr intel_output = output->driver_private;
      int		   crtc_mask;
d689 2
a690 2
      if (intel_output->type == I830_OUTPUT_LVDS)
	  lvds_detected = TRUE;
d692 4
a695 5
      crtc_mask = 0;
      for (c = 0; c < config->num_crtc; c++)
      {
	 xf86CrtcPtr	      crtc = config->crtc[c];
	 I830CrtcPrivatePtr   intel_crtc = crtc->driver_private;
d697 7
a703 6
	 if (intel_output->pipe_mask & (1 << intel_crtc->pipe))
	    crtc_mask |= (1 << c);
      }
      output->possible_crtcs = crtc_mask;
      output->possible_clones = i830_output_clones (pScrn, intel_output->clone_mask);
   }
d706 1
a706 2
static void
i830_init_clock_gating(ScrnInfoPtr pScrn)
d708 1
a708 1
    I830Ptr pI830 = I830PTR(pScrn);
d712 27
a738 31
    if (IS_G4X(pI830)) {
	uint32_t dspclk_gate;
	OUTREG(RENCLK_GATE_D1, 0);
	OUTREG(RENCLK_GATE_D2, VF_UNIT_CLOCK_GATE_DISABLE |
		GS_UNIT_CLOCK_GATE_DISABLE |
		CL_UNIT_CLOCK_GATE_DISABLE);
	OUTREG(RAMCLK_GATE_D, 0);
	dspclk_gate = VRHUNIT_CLOCK_GATE_DISABLE |
	    OVRUNIT_CLOCK_GATE_DISABLE |
	    OVCUNIT_CLOCK_GATE_DISABLE;
	if (IS_GM45(pI830))
	    dspclk_gate |= DSSUNIT_CLOCK_GATE_DISABLE;
	OUTREG(DSPCLK_GATE_D, dspclk_gate);
    } else if (IS_I965GM(pI830)) {
	OUTREG(RENCLK_GATE_D1, I965_RCC_CLOCK_GATE_DISABLE);
	OUTREG(RENCLK_GATE_D2, 0);
	OUTREG(DSPCLK_GATE_D, 0);
	OUTREG(RAMCLK_GATE_D, 0);
	OUTREG16(DEUC, 0);
    } else if (IS_I965G(pI830)) {
	OUTREG(RENCLK_GATE_D1, I965_RCZ_CLOCK_GATE_DISABLE |
	       I965_RCC_CLOCK_GATE_DISABLE |
	       I965_RCPB_CLOCK_GATE_DISABLE |
	       I965_ISC_CLOCK_GATE_DISABLE |
	       I965_FBC_CLOCK_GATE_DISABLE);
	OUTREG(RENCLK_GATE_D2, 0);
    } else if (IS_I855(pI830) || IS_I865G(pI830)) {
	OUTREG(RENCLK_GATE_D1, SV_CLOCK_GATE_DISABLE);
    } else if (IS_I830(pI830)) {
	OUTREG(DSPCLK_GATE_D, OVRUNIT_CLOCK_GATE_DISABLE);
    }
d741 1
a741 2
static void
i830_init_bios_control(ScrnInfoPtr pScrn)
d743 1
a743 1
   I830Ptr pI830 = I830PTR(pScrn);
d745 2
a746 2
   /* Set "extended desktop" */
   OUTREG(SWF0, INREG(SWF0) | (1 << 21));
d748 3
a750 3
   /* Set "driver loaded",  "OS unknown", "APM 1.2" */
   OUTREG(SWF4, (INREG(SWF4) & ~((3 << 19) | (7 << 16))) |
		(1 << 23) | (2 << 16));
d754 1
a754 1
I830LVDSPresent(ScrnInfoPtr pScrn)
d756 2
a757 2
   xf86CrtcConfigPtr config = XF86_CRTC_CONFIG_PTR (pScrn);
   int o, lvds_detected = FALSE;
d759 3
a761 3
   for (o = 0; o < config->num_output; o++) {
      xf86OutputPtr	   output = config->output[o];
      I830OutputPrivatePtr intel_output = output->driver_private;
d763 3
a765 3
      if (intel_output->type == I830_OUTPUT_LVDS)
	  lvds_detected = TRUE;
   }
d767 1
a767 1
   return lvds_detected;
d769 1
a773 1

d775 1
a775 1
I830PreInitDDC(ScrnInfoPtr pScrn)
d777 1
a777 1
   I830Ptr pI830 = I830PTR(pScrn);
d779 5
a783 6
   if (!xf86LoadSubModule(pScrn, "ddc")) {
      pI830->ddc2 = FALSE;
   } else {
      xf86LoaderReqSymLists(I810ddcSymbols, NULL);
      pI830->ddc2 = TRUE;
   }
d785 9
a793 11
   /* DDC can use I2C bus */
   /* Load I2C if we have the code to use it */
   if (pI830->ddc2) {
      if (xf86LoadSubModule(pScrn, "i2c")) {
	 xf86LoaderReqSymLists(I810i2cSymbols, NULL);

	 pI830->ddc2 = TRUE;
      } else {
	 pI830->ddc2 = FALSE;
      }
   }
d796 1
a796 2
static void
PreInitCleanup(ScrnInfoPtr pScrn)
d798 1
a798 1
   I830Ptr pI830 = I830PTR(pScrn);
d800 3
a802 3
   if (pI830->MMIOBase)
      I830UnmapMMIO(pScrn);
   I830FreeRec(pScrn);
d808 1
a808 2
Bool
i830_tiled_width(I830Ptr i830, int *width, int cpp)
d810 1
a810 1
    Bool    tiled = FALSE;
d812 31
a842 27
    /*
     * Adjust the display width to allow for front buffer tiling if possible
     */
    if (i830->tiling) {
	if (IS_I965G(i830)) {
	    int tile_pixels = 512 / cpp;
	    *width = (*width + tile_pixels - 1) &
		~(tile_pixels - 1);
	    tiled = TRUE;
	} else {
	    /* Good pitches to allow tiling.  Don't care about pitches < 1024
	     * pixels.
	     */
	    static const int pitches[] = {
		1024,
		2048,
		4096,
		8192,
		0
	    };
	    int i;

	    for (i = 0; pitches[i] != 0; i++) {
		if (pitches[i] >= *width) {
		    *width = pitches[i];
		    tiled = TRUE;
		    break;
a843 1
	    }
d845 1
a845 11
    }
    return tiled;
}

/*
 * Pad to accelerator requirement
 */
int
i830_pad_drawable_width(int width, int cpp)
{
    return (width + 63) & ~63;
d848 1
a848 2
static Bool
i830_xf86crtc_resize (ScrnInfoPtr scrn, int width, int height)
d851 2
a852 2
    I830Ptr	i830 = I830PTR(scrn);
    int		old_width = scrn->displayWidth;
d854 2
a855 2
    int		old_x = scrn->virtualX;
    int		old_y = scrn->virtualY;
d857 2
a858 2
    if (old_x == width && old_y == height)
	return TRUE;
d860 2
a861 2
    scrn->virtualX = width;
    scrn->virtualY = height;
d863 42
a904 34
    if (i830->can_resize && i830->front_buffer)
    {
	i830_memory *new_front, *old_front;
	Bool	    tiled;
	ScreenPtr   screen = screenInfo.screens[scrn->scrnIndex];

	scrn->displayWidth = i830_pad_drawable_width(width, i830->cpp);
	tiled = i830_tiled_width(i830, &scrn->displayWidth, i830->cpp);
	xf86DrvMsg(scrn->scrnIndex, X_INFO, "Allocate new frame buffer %dx%d stride %d\n",
		   width, height, scrn->displayWidth);
	I830Sync(scrn);
	i830WaitForVblank(scrn);
	new_front = i830_allocate_framebuffer(scrn);
	if (!new_front) {
	    scrn->virtualX = old_x;
	    scrn->virtualY = old_y;
	    scrn->displayWidth = old_width;
	    return FALSE;
	}
	old_front = i830->front_buffer;
	i830->front_buffer = new_front;
	i830_set_pixmap_bo(screen->GetScreenPixmap(screen),
			   new_front->bo);
	scrn->fbOffset = i830->front_buffer->offset;
	screen->ModifyPixmapHeader(screen->GetScreenPixmap(screen),
				   width, height, -1, -1, scrn->displayWidth * i830->cpp,
				   NULL);
	xf86DrvMsg(scrn->scrnIndex, X_INFO, "New front buffer at 0x%lx\n",
		   i830->front_buffer->offset);
	i830_set_new_crtc_bo(scrn);
	I830Sync(scrn);
	i830WaitForVblank(scrn);
	i830_free_memory(scrn, old_front);
    }
d906 1
a906 1
    return TRUE;
d910 1
a910 1
    i830_xf86crtc_resize
d925 1
a925 1
i830SetHotkeyControl(ScrnInfoPtr pScrn, int mode)
d927 1
a927 1
   I830Ptr pI830 = I830PTR(pScrn);
d931 1
a931 1
   if (pI830->use_drm_mode)
d934 1
a934 1
   gr18 = pI830->readControl(pI830, GRX, 0x18);
d939 1
a939 1
   pI830->writeControl(pI830, GRX, 0x18, gr18);
a941 1
#ifdef XF86DRM_MODE
d946 1
a946 1
static Bool i830_kernel_mode_enabled(ScrnInfoPtr pScrn)
d948 4
a951 8
#if XSERVER_LIBPCIACCESS
    struct pci_device *PciInfo;
#else
    pciVideoPtr PciInfo;
#endif
    EntityInfoPtr pEnt;
    char *busIdString;
    int ret;
d953 2
a954 2
    pEnt = xf86GetEntityInfo(pScrn->entityList[0]);
    PciInfo = xf86GetPciInfoForEntity(pEnt->index);
d956 2
a957 2
    if (!xf86LoaderCheckSymbol("DRICreatePCIBusID"))
	return FALSE;
d959 1
a959 1
    busIdString = DRICreatePCIBusID(PciInfo);
d961 11
a971 4
    ret = drmCheckModesettingSupported(busIdString);
    xfree(busIdString);
    if (ret)
	return FALSE;
d973 1
a973 1
    return TRUE;
a974 3
#else
#define i830_kernel_mode_enabled(x) FALSE
#endif
d976 1
a976 2
static Bool
i830_detect_chipset(ScrnInfoPtr pScrn)
d978 121
a1098 39
    I830Ptr pI830 = I830PTR(pScrn);
    MessageType from = X_PROBED;
    const char *chipname;
    uint32_t capid;
    int fb_bar, mmio_bar;


    /* We have to use PIO to probe, because we haven't mapped yet. */
    if (!pI830->use_drm_mode)
	I830SetPIOAccess(pI830);

    switch (DEVICE_ID(pI830->PciInfo)) {
    case PCI_CHIP_I830_M:
	chipname = "830M";
	break;
    case PCI_CHIP_845_G:
	chipname = "845G";
	break;
    case PCI_CHIP_I855_GM:
	/* Check capid register to find the chipset variant */
#if XSERVER_LIBPCIACCESS
	pci_device_cfg_read_u32 (pI830->PciInfo, &capid, I85X_CAPID);
#else
	capid = pciReadLong (pI830->PciTag, I85X_CAPID);
#endif
	pI830->variant = (capid >> I85X_VARIANT_SHIFT) & I85X_VARIANT_MASK;
	switch (pI830->variant) {
	case I855_GM:
	    chipname = "855GM";
	    break;
	case I855_GME:
	    chipname = "855GME";
	    break;
	case I852_GM:
	    chipname = "852GM";
	    break;
	case I852_GME:
	    chipname = "852GME";
	    break;
d1100 26
a1125 112
	    xf86DrvMsg(pScrn->scrnIndex, X_INFO,
		       "Unknown 852GM/855GM variant: 0x%x)\n", pI830->variant);
	    chipname = "852GM/855GM (unknown variant)";
	    break;
	}
	break;
    case PCI_CHIP_I865_G:
	chipname = "865G";
	break;
    case PCI_CHIP_I915_G:
	chipname = "915G";
	break;
    case PCI_CHIP_E7221_G:
	chipname = "E7221 (i915)";
	break;
    case PCI_CHIP_I915_GM:
	chipname = "915GM";
	break;
    case PCI_CHIP_I945_G:
	chipname = "945G";
	break;
    case PCI_CHIP_I945_GM:
	chipname = "945GM";
	break;
    case PCI_CHIP_I945_GME:
	chipname = "945GME";
	break;
    case PCI_CHIP_IGD_GM:
	chipname = "IGD";
	break;
    case PCI_CHIP_IGD_G:
	chipname = "IGD";
	break;
    case PCI_CHIP_I965_G:
	chipname = "965G";
	break;
    case PCI_CHIP_G35_G:
	chipname = "G35";
	break;
    case PCI_CHIP_I965_Q:
	chipname = "965Q";
	break;
    case PCI_CHIP_I946_GZ:
	chipname = "946GZ";
	break;
    case PCI_CHIP_I965_GM:
	chipname = "965GM";
	break;
    case PCI_CHIP_I965_GME:
	chipname = "965GME/GLE";
	break;
    case PCI_CHIP_G33_G:
	chipname = "G33";
	break;
    case PCI_CHIP_Q35_G:
	chipname = "Q35";
	break;
    case PCI_CHIP_Q33_G:
	chipname = "Q33";
	break;
    case PCI_CHIP_GM45_GM:
	chipname = "Mobile IntelÂ® GM45 Express Chipset";
	break;
    case PCI_CHIP_IGD_E_G:
	chipname = "Intel Integrated Graphics Device";
	break;
    case PCI_CHIP_G45_G:
	chipname = "G45/G43";
	break;
    case PCI_CHIP_Q45_G:
	chipname = "Q45/Q43";
	break;
    case PCI_CHIP_G41_G:
	chipname = "G41";
	break;
   default:
	chipname = "unknown chipset";
	break;
    }
    xf86DrvMsg(pScrn->scrnIndex, X_INFO,
	       "Integrated Graphics Chipset: Intel(R) %s\n", chipname);

    /* Set the Chipset and ChipRev, allowing config file entries to override. */
    if (pI830->pEnt->device->chipset && *pI830->pEnt->device->chipset) {
	pScrn->chipset = pI830->pEnt->device->chipset;
	from = X_CONFIG;
    } else if (pI830->pEnt->device->chipID >= 0) {
	pScrn->chipset = (char *)xf86TokenToString(I830Chipsets,
						   pI830->pEnt->device->chipID);
	from = X_CONFIG;
	xf86DrvMsg(pScrn->scrnIndex, X_CONFIG, "ChipID override: 0x%04X\n",
		   pI830->pEnt->device->chipID);
	DEVICE_ID(pI830->PciInfo) = pI830->pEnt->device->chipID;
    } else {
	from = X_PROBED;
	pScrn->chipset = (char *)xf86TokenToString(I830Chipsets,
						   DEVICE_ID(pI830->PciInfo));
    }

    if (pI830->pEnt->device->chipRev >= 0) {
	xf86DrvMsg(pScrn->scrnIndex, X_CONFIG, "ChipRev override: %d\n",
		   pI830->pEnt->device->chipRev);
    }

    xf86DrvMsg(pScrn->scrnIndex, from, "Chipset: \"%s\"\n",
	       (pScrn->chipset != NULL) ? pScrn->chipset : "Unknown i8xx");

    /* Check if the HW cursor needs physical address. */
    if (IS_MOBILE(pI830) || IS_I9XX(pI830))
	pI830->CursorNeedsPhysical = TRUE;
    else
	pI830->CursorNeedsPhysical = FALSE;
d1127 15
a1141 2
    if (IS_I965G(pI830) || IS_G33CLASS(pI830))
	pI830->CursorNeedsPhysical = FALSE;
d1143 12
a1154 3
    /* Skip the rest if the kernel is taking care of things */
    if (pI830->use_drm_mode)
	return TRUE;
d1156 12
a1167 46
    /* Now that we know the chipset, figure out the resource base addrs */
    if (IS_I9XX(pI830)) {
	fb_bar = 2;
	mmio_bar = 0;
    } else {
	fb_bar = 0;
	mmio_bar = 1;
    }

    if (pI830->pEnt->device->MemBase != 0) {
	pI830->LinearAddr = pI830->pEnt->device->MemBase;
	from = X_CONFIG;
    } else {
	pI830->LinearAddr = I810_MEMBASE (pI830->PciInfo, fb_bar);
	if (pI830->LinearAddr == 0) {
	    xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
		       "No valid FB address in PCI config space\n");
	    PreInitCleanup(pScrn);
	    return FALSE;
	}
    }

    xf86DrvMsg(pScrn->scrnIndex, from, "Linear framebuffer at 0x%lX\n",
	       (unsigned long)pI830->LinearAddr);

    if (pI830->pEnt->device->IOBase != 0) {
	pI830->MMIOAddr = pI830->pEnt->device->IOBase;
	from = X_CONFIG;
    } else {
	pI830->MMIOAddr = I810_MEMBASE (pI830->PciInfo, mmio_bar);
	if (pI830->MMIOAddr == 0) {
	    xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
		       "No valid MMIO address in PCI config space\n");
	    PreInitCleanup(pScrn);
	    return FALSE;
	}
    }

    xf86DrvMsg(pScrn->scrnIndex, from, "IO registers at addr 0x%lX\n",
	       (unsigned long)pI830->MMIOAddr);

    /* Now figure out mapsize on 8xx chips */
    if (IS_I830(pI830) || IS_845G(pI830)) {
#if XSERVER_LIBPCIACCESS
	uint16_t		gmch_ctrl;
	struct pci_device *bridge;
d1169 2
a1170 5
	bridge = intel_host_bridge ();
	pci_device_cfg_read_u16 (bridge, &gmch_ctrl, I830_GMCH_CTRL);
#else
	PCITAG bridge;
	uint16_t gmch_ctrl;
d1172 4
a1175 5
	bridge = pciTag(0, 0, 0);		/* This is always the host bridge */
	gmch_ctrl = pciReadWord(bridge, I830_GMCH_CTRL);
#endif
	if ((gmch_ctrl & I830_GMCH_MEM_MASK) == I830_GMCH_MEM_128M) {
	    pI830->FbMapSize = 0x8000000;
d1177 8
a1184 1
	    pI830->FbMapSize = 0x4000000; /* 64MB - has this been tested ?? */
d1186 18
a1203 8
    } else {
	if (IS_I9XX(pI830)) {
#if XSERVER_LIBPCIACCESS
	    pI830->FbMapSize = pI830->PciInfo->regions[fb_bar].size;
#else
	    pI830->FbMapSize = 1UL << pciGetBaseSize(pI830->PciTag, 2, TRUE,
						     NULL);
#endif
d1205 6
a1210 2
	    /* 128MB aperture for later i8xx series. */
	    pI830->FbMapSize = 0x8000000;
a1211 1
    }
d1216 1
a1216 11
static const char *accel_name[] = 
{
   "unspecified",
   "no",
   "XAA",
   "EXA",
   "UXA",
};

static Bool
I830LoadSyms(ScrnInfoPtr pScrn)
d1218 1
a1218 1
    I830Ptr pI830 = I830PTR(pScrn);
d1220 2
a1221 2
    if (pI830->use_drm_mode)
	return TRUE;
d1223 3
a1225 4
    /* The vgahw module should be loaded here when needed */
    if (!xf86LoadSubModule(pScrn, "vgahw"))
	return FALSE;
    xf86LoaderReqSymLists(I810vgahwSymbols, NULL);
d1227 2
a1228 3
    if (!xf86LoadSubModule(pScrn, "ramdac"))
       return FALSE;
    xf86LoaderReqSymLists(I810ramdacSymbols, NULL);
d1230 1
a1230 1
    return TRUE;
d1233 1
a1233 2
static Bool
I830GetEarlyOptions(ScrnInfoPtr pScrn)
d1235 12
a1246 1
    I830Ptr pI830 = I830PTR(pScrn);
d1248 5
a1252 6
    /* Process the options */
    xf86CollectOptions(pScrn, NULL);
    if (!(pI830->Options = xalloc(sizeof(I830Options))))
	return FALSE;
    memcpy(pI830->Options, I830Options, sizeof(I830Options));
    xf86ProcessOptions(pScrn->scrnIndex, pScrn->options, pI830->Options);
d1254 5
a1258 2
    pI830->fallback_debug = xf86ReturnOptValBool(pI830->Options,
						 OPTION_FALLBACKDEBUG, FALSE);
d1260 5
a1264 17
    if (xf86ReturnOptValBool(pI830->Options, OPTION_MODEDEBUG, FALSE)) {
	pI830->debug_modes = TRUE;
    } else {
	pI830->debug_modes = FALSE;
    }

    if (xf86ReturnOptValBool(pI830->Options, OPTION_LVDS24BITMODE, FALSE)) {
	pI830->lvds_24_bit_mode = TRUE;
    } else {
	pI830->lvds_24_bit_mode = FALSE;
    }

    if (xf86ReturnOptValBool(pI830->Options, OPTION_LVDSFIXEDMODE, TRUE)) {
	pI830->skip_panel_detect = FALSE;
    } else {
	pI830->skip_panel_detect = TRUE;
    }
d1266 19
a1284 2
    if (xf86ReturnOptValBool(pI830->Options, OPTION_FORCEENABLEPIPEA, FALSE))
	pI830->quirk_flag |= QUIRK_PIPEA_FORCE;
d1286 1
a1286 1
    return TRUE;
d1290 1
a1290 1
I830PreInitCrtcConfig(ScrnInfoPtr pScrn)
d1292 22
a1313 3
    xf86CrtcConfigPtr   xf86_config;
    I830Ptr pI830 = I830PTR(pScrn);
    int max_width, max_height;
d1315 6
a1320 2
    /* check quirks */
    i830_fixup_devices(pScrn);
d1322 6
a1327 13
    /* Allocate an xf86CrtcConfig */
    xf86CrtcConfigInit (pScrn, &i830_xf86crtc_config_funcs);
    xf86_config = XF86_CRTC_CONFIG_PTR(pScrn);

    /* See i830_exa.c comments for why we limit the framebuffer size like this.
     */
    if (IS_I965G(pI830)) {
	max_height = max_width = min(16384 / pI830->cpp, 8192);
    } else {
	max_width = 2048;
	max_height = 2048;
    }
    xf86CrtcSetSizeRange (pScrn, 320, 200, max_width, max_height);
d1330 1
a1330 2
static Bool
I830AccelMethodInit(ScrnInfoPtr pScrn)
d1332 18
a1349 46
    I830Ptr pI830 = I830PTR(pScrn);
    MessageType from = X_PROBED;
    char *s;
    int i, num_pipe;

    if (xf86ReturnOptValBool(pI830->Options, OPTION_NOACCEL, FALSE)) {
	pI830->accel = ACCEL_NONE;
    }

    /*
     * The ugliness below:
     * If either XAA or EXA (exclusive) is compiled in, default to it.
     *
     * If both are compiled in, and the user didn't specify noAccel, use the
     * config option AccelMethod to determine which to use, defaulting to EXA
     * if none is specified, or if the string was unrecognized.
     *
     * Then, just to make things more confusing, the default EXA will
     * be overridden to UXA if KMS is available. See I830DrmModeInit.
     *
     * All this *will* go away when we remov XAA and EXA support from
     * this driver. (And there will be much rejoicing.)
     */
    if (!(pI830->accel == ACCEL_NONE)) {
#ifdef I830_USE_UXA
	pI830->accel = ACCEL_UXA;
#endif
#ifdef I830_USE_EXA
	pI830->accel = ACCEL_EXA;
#endif
#if I830_USE_XAA + I830_USE_EXA + I830_USE_UXA >= 2
	from = X_DEFAULT;
	if ((s = (char *)xf86GetOptValString(pI830->Options,
					     OPTION_ACCELMETHOD))) {
	    if (!xf86NameCmp(s, "EXA")) {
		from = X_CONFIG;
		pI830->accel = ACCEL_EXA;
	    }
	    else if (!xf86NameCmp(s, "XAA")) {
		from = X_CONFIG;
		pI830->accel = ACCEL_XAA;
	    }
	    else if (!xf86NameCmp(s, "UXA")) {
		from = X_CONFIG;
	       pI830->accel = ACCEL_UXA;
	    }
d1351 1
a1351 55
#endif
	xf86DrvMsg(pScrn->scrnIndex, from, "Using %s for acceleration\n",
		   accel_name[pI830->accel]);
    }

    pI830->directRenderingType = DRI_NONE;
    if (!xf86ReturnOptValBool(pI830->Options, OPTION_DRI, TRUE))
	pI830->directRenderingType = DRI_DISABLED;

#ifdef XF86DRI
    if (pI830->accel == ACCEL_NONE) {
	xf86DrvMsg(pScrn->scrnIndex, X_CONFIG, "DRI is disabled because it "
		"needs 2D acceleration.\n");
	pI830->directRenderingType = DRI_DISABLED;
    } else if (pScrn->depth != 16 && pScrn->depth != 24) {
	xf86DrvMsg(pScrn->scrnIndex, X_CONFIG, "DRI is disabled because it "
		"runs only at depths 16 and 24.\n");
	pI830->directRenderingType = DRI_DISABLED;
    }
#endif /* XF86DRI */

    I830MapMMIO(pScrn);

    if (pI830->debug_modes) {
	xf86DrvMsg(pScrn->scrnIndex, X_INFO,
		   "Hardware state on X startup:\n");
	i830DumpRegs (pScrn);
    }

    i830TakeRegSnapshot(pScrn);

    if (DEVICE_ID(pI830->PciInfo) == PCI_CHIP_E7221_G)
	num_pipe = 1;
    else
	if (IS_MOBILE(pI830) || IS_I9XX(pI830))
	    num_pipe = 2;
	else
	    num_pipe = 1;
    xf86DrvMsg(pScrn->scrnIndex, X_INFO, "%d display pipe%s available.\n",
	       num_pipe, num_pipe > 1 ? "s" : "");

    I830PreInitDDC(pScrn);
    for (i = 0; i < num_pipe; i++) {
	i830_crtc_init(pScrn, i);
    }
    I830SetupOutputs(pScrn);

    SaveHWState(pScrn);
    pI830->can_resize = FALSE;
    if (pI830->accel == ACCEL_UXA && pI830->directRenderingType != DRI_XF86DRI)
	pI830->can_resize = TRUE;
#if !defined(DRI2) && defined(XF86DRI)
    /* Disable resizing so that DRI1 can initialize and give us GEM support. */
    pI830->can_resize = FALSE;
#endif
d1353 1
a1353 13
    xf86DrvMsg(pScrn->scrnIndex, X_INFO,
	       "Resizable framebuffer: %s (%d %d)\n",
	       pI830->can_resize ? "available" : "not available",
	       pI830->directRenderingType, pI830->accel);

    if (!xf86InitialConfiguration (pScrn, pI830->can_resize))
    {
	xf86DrvMsg(pScrn->scrnIndex, X_ERROR, "No valid modes.\n");
	RestoreHWState(pScrn);
	PreInitCleanup(pScrn);
	return FALSE;
    }
    RestoreHWState(pScrn);
d1355 7
a1361 2
    /* XXX This should go away, replaced by xf86Crtc.c support for it */
    pI830->rotation = RR_Rotate_0;
d1363 1
a1363 1
    pI830->stolen_size = I830DetectMemory(pScrn);
d1365 1
a1365 1
    return TRUE;
d1368 1
a1368 2
static Bool
I830DrmModeInit(ScrnInfoPtr pScrn)
d1370 38
a1407 43
#ifdef XF86DRM_MODE
    I830Ptr pI830 = I830PTR(pScrn);
    char *bus_id;
    char *s;
    int ret;

    /* Default to UXA but allow override */
    pI830->accel = ACCEL_UXA;

    if ((s = (char *)xf86GetOptValString(pI830->Options, OPTION_ACCELMETHOD))) {
	if (xf86NameCmp(s, "UXA"))
	    xf86DrvMsg(pScrn->scrnIndex, X_WARNING, "kernel mode setting active,overridding accelmethod and using UXA\n");
    }

    pI830->can_resize = FALSE;
    if (pI830->accel == ACCEL_UXA && pI830->directRenderingType != DRI_XF86DRI)
	pI830->can_resize = TRUE;

    xf86DrvMsg(pScrn->scrnIndex, X_INFO,
	       "Resizable framebuffer: %s (%d %d)\n",
	       pI830->can_resize ? "available" : "not available",
	       pI830->directRenderingType, pI830->accel);

    bus_id = DRICreatePCIBusID(pI830->PciInfo);

    /* Create a bus Id */
    /* Low level DRM open */
    ret = DRIOpenDRMMaster(pScrn, SAREA_MAX, bus_id, "i915");
    xfree(bus_id);
    if (!ret) {
	    xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
		       "[dri] DRIGetVersion failed to open the DRM\n"
		       "[dri] Disabling DRI.\n");
	    return FALSE;
    }

    pI830->drmSubFD = DRIMasterFD(pScrn);
    if (drmmode_pre_init(pScrn, pI830->drmSubFD, pI830->cpp) == FALSE) {
	xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
		   "Kernel modesetting setup failed\n");
	PreInitCleanup(pScrn);
	return FALSE;
    }
d1409 12
a1420 2
    pI830->directRenderingType = DRI_NONE;
    pI830->allocate_classic_textures = FALSE;
d1422 2
a1423 2
    i830_init_bufmgr(pScrn);
#endif
d1425 7
a1431 1
    return TRUE;
d1434 1
a1434 2
static void
I830XvInit(ScrnInfoPtr pScrn)
d1436 1
a1436 2
    I830Ptr pI830 = I830PTR(pScrn);
    MessageType from = X_PROBED;
d1438 6
a1443 1
   pI830->XvPreferOverlay = xf86ReturnOptValBool(pI830->Options, OPTION_PREFER_OVERLAY, FALSE);
d1445 1
a1445 18
#ifdef I830_XV
    if (xf86GetOptValInteger(pI830->Options, OPTION_VIDEO_KEY,
			     &(pI830->colorKey))) {
	from = X_CONFIG;
    } else if (xf86GetOptValInteger(pI830->Options, OPTION_COLOR_KEY,
				    &(pI830->colorKey))) {
	from = X_CONFIG;
    } else {
	pI830->colorKey =
	    (1 << pScrn->offset.red) | (1 << pScrn->offset.green) |
	    (((pScrn->mask.blue >> pScrn->offset.blue) - 1) <<
	     pScrn->offset.blue);
	from = X_DEFAULT;
    }
    xf86DrvMsg(pScrn->scrnIndex, from, "video overlay key set to 0x%x\n",
	       pI830->colorKey);
#endif
}
d1447 1
a1447 17
/**
 * This is called per zaphod head (so usually just once) to do initialization
 * before the Screen is created.
 *
 * This code generally covers probing, module loading, option handling
 * card mapping, and RandR setup.
 */
static Bool
I830PreInit(ScrnInfoPtr pScrn, int flags)
{
   vgaHWPtr hwp;
   I830Ptr pI830;
   rgb defaultWeight = { 0, 0, 0 };
   EntityInfoPtr pEnt;
   int flags24;
   Gamma zeros = { 0.0, 0.0, 0.0 };
   int drm_mode_setting;
d1449 2
a1450 2
   if (pScrn->numEntities != 1)
      return FALSE;
d1452 4
a1455 1
   drm_mode_setting = i830_kernel_mode_enabled(pScrn);
d1457 2
a1458 1
   pEnt = xf86GetEntityInfo(pScrn->entityList[0]);
d1460 16
a1475 2
   if (flags & PROBE_DETECT)
       return TRUE;
d1477 52
a1528 3
   /* Allocate driverPrivate */
   if (!I830GetRec(pScrn))
      return FALSE;
d1530 1
a1530 15
   pI830 = I830PTR(pScrn);
   pI830->SaveGeneration = -1;
   pI830->pEnt = pEnt;
   pI830->use_drm_mode = drm_mode_setting;
   pI830->kernel_exec_fencing = pI830->use_drm_mode;

   if (!I830LoadSyms(pScrn))
       return FALSE;

   if (!drm_mode_setting) {
       /* Allocate a vgaHWRec */
       if (!vgaHWGetHWRec(pScrn))
	   return FALSE;
       hwp = VGAHWPTR(pScrn);
   }
d1532 2
a1533 1
   pScrn->displayWidth = 640; /* default it */
d1535 1
a1535 2
   if (pI830->pEnt->location.type != BUS_PCI)
      return FALSE;
d1537 3
a1539 5
   pI830->PciInfo = xf86GetPciInfoForEntity(pI830->pEnt->index);
#if !XSERVER_LIBPCIACCESS
   pI830->PciTag = pciTag(pI830->PciInfo->bus, pI830->PciInfo->device,
			  pI830->PciInfo->func);
#endif
d1541 3
a1543 4
   if (xf86RegisterResources(pI830->pEnt->index, NULL, ResNone)) {
      PreInitCleanup(pScrn);
      return FALSE;
   }
d1545 1
a1545 4
   pScrn->racMemFlags = RAC_FB | RAC_COLORMAP;
   pScrn->monitor = pScrn->confScreen->monitor;
   pScrn->progClock = TRUE;
   pScrn->rgbBits = 8;
d1547 2
a1548 1
   flags24 = Support32bppFb | PreferConvert24to32 | SupportConvert24to32;
d1550 13
a1562 2
   if (!xf86SetDepthBpp(pScrn, 0, 0, 0, flags24))
      return FALSE;
d1564 4
a1567 13
   switch (pScrn->depth) {
   case 8:
   case 15:
   case 16:
   case 24:
      break;
   default:
      xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
		 "Given depth (%d) is not supported by I830 driver\n",
		 pScrn->depth);
      return FALSE;
   }
   xf86PrintDepthBpp(pScrn);
d1569 2
a1570 4
   if (!xf86SetWeight(pScrn, defaultWeight, defaultWeight))
      return FALSE;
   if (!xf86SetDefaultVisual(pScrn, -1))
      return FALSE;
d1572 1
a1572 2
   if (!pI830->use_drm_mode)
       hwp = VGAHWPTR(pScrn);
d1574 1
a1574 1
   pI830->cpp = pScrn->bitsPerPixel / 8;
d1576 2
a1577 1
   pI830->preinit = TRUE;
d1579 2
a1580 2
   if (!I830GetEarlyOptions(pScrn))
       return FALSE;
d1582 1
a1582 2
   if (!i830_detect_chipset(pScrn))
       return FALSE;
d1584 11
a1594 3
   if (i830_bios_init(pScrn))
       xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
		  "VBIOS initialization failed.\n");
d1596 1
a1596 8
   if (pI830->use_drm_mode) {
       if (!I830DrmModeInit(pScrn))
	   return FALSE;
   } else {
      I830PreInitCrtcConfig(pScrn);
      if (!I830AccelMethodInit(pScrn))
         return FALSE;
   }
d1598 4
a1601 1
   I830XvInit(pScrn);
d1603 6
a1608 4
   if (!xf86SetGamma(pScrn, zeros)) {
       PreInitCleanup(pScrn);
       return FALSE;
   }
d1610 2
a1611 6
   if (pScrn->modes == NULL) {
      xf86DrvMsg(pScrn->scrnIndex, X_ERROR, "No modes.\n");
      PreInitCleanup(pScrn);
      return FALSE;
   }
   pScrn->currentMode = pScrn->modes;
d1613 5
a1617 4
   if (!IS_I965G(pI830) && pScrn->virtualY > 2048) {
      xf86DrvMsg(pScrn->scrnIndex, X_ERROR, "Cannot support > 2048 vertical lines. disabling acceleration.\n");
      pI830->accel = ACCEL_NONE;
   }
d1619 2
a1620 2
   /* Set display resolution */
   xf86SetDpi(pScrn, 0, 0);
d1622 3
a1624 5
   /* Load the required sub modules */
   if (!xf86LoadSubModule(pScrn, "fb")) {
      PreInitCleanup(pScrn);
      return FALSE;
   }
d1626 5
a1630 1
   xf86LoaderReqSymLists(I810fbSymbols, NULL);
d1632 1
a1632 10
   switch (pI830->accel) {
#ifdef I830_USE_XAA
   case ACCEL_XAA:
      if (!xf86LoadSubModule(pScrn, "xaa")) {
	 PreInitCleanup(pScrn);
	 return FALSE;
      }
      xf86LoaderReqSymLists(I810xaaSymbols, NULL);
      break;
#endif
d1634 1
a1634 58
#ifdef I830_USE_EXA
   case ACCEL_EXA: {
      XF86ModReqInfo req;
      int errmaj, errmin;

      memset(&req, 0, sizeof(req));
      req.majorversion = 2;
#if EXA_VERSION_MINOR >= 2
      req.minorversion = 2;
#else
      req.minorversion = 1;
#endif
      if (!LoadSubModule(pScrn->module, "exa", NULL, NULL, NULL, &req,
		&errmaj, &errmin)) {
	 LoaderErrorMsg(NULL, "exa", errmaj, errmin);
	 PreInitCleanup(pScrn);
	 return FALSE;
      }
      xf86LoaderReqSymLists(I830exaSymbols, NULL);
      break;
   }
#endif
   default:
      break;
   }

   if (!pI830->use_drm_mode) {
       i830CompareRegsToSnapshot(pScrn, "After PreInit");

       I830UnmapMMIO(pScrn);

       /*  We won't be using the VGA access after the probe. */
       I830SetMMIOAccess(pI830);
       xf86SetOperatingState(resVgaIo, pI830->pEnt->index, ResUnusedOpr);
       xf86SetOperatingState(resVgaMem, pI830->pEnt->index, ResDisableOpr);
   }

#if defined(XF86DRI)
   /* Load the dri module if requested. */
   if (xf86ReturnOptValBool(pI830->Options, OPTION_DRI, FALSE) &&
       pI830->directRenderingType != DRI_DISABLED) {
      if (xf86LoadSubModule(pScrn, "dri")) {
	 xf86LoaderReqSymLists(I810driSymbols, I810drmSymbols, NULL);
      }
   }
#endif

#if defined(DRI2)
   /* Load the dri2 module if requested. */
   if (xf86ReturnOptValBool(pI830->Options, OPTION_DRI, FALSE) &&
       pI830->directRenderingType != DRI_DISABLED) {
       xf86LoadSubModule(pScrn, "dri2");
   }
#endif

   pI830->preinit = FALSE;

   return TRUE;
d1643 1
a1643 2
static void
i830_stop_ring(ScrnInfoPtr pScrn, Bool flush)
d1645 2
a1646 2
   I830Ptr pI830 = I830PTR(pScrn);
   unsigned long temp;
d1648 1
a1648 1
   DPRINTF(PFX, "ResetState: flush is %s\n", BOOLTOSTRING(flush));
d1650 6
a1655 7
   /* Flush the ring buffer (if enabled), then disable it. */
   if (pI830->accel != ACCEL_NONE) {
      temp = INREG(LP_RING + RING_LEN);
      if (temp & RING_VALID) {
	 i830_refresh_ring(pScrn);
	 i830_wait_ring_idle(pScrn);
      }
d1657 4
a1660 5
      OUTREG(LP_RING + RING_LEN, 0);
      OUTREG(LP_RING + RING_HEAD, 0);
      OUTREG(LP_RING + RING_TAIL, 0);
      OUTREG(LP_RING + RING_START, 0);
   }
d1663 1
a1663 2
static void
i830_start_ring(ScrnInfoPtr pScrn)
d1665 2
a1666 2
   I830Ptr pI830 = I830PTR(pScrn);
   unsigned int itemp;
d1668 1
a1668 1
   DPRINTF(PFX, "SetRingRegs\n");
d1670 3
a1672 2
   if (pI830->accel == ACCEL_NONE)
      return;
d1674 2
a1675 24
   OUTREG(LP_RING + RING_LEN, 0);
   OUTREG(LP_RING + RING_TAIL, 0);
   OUTREG(LP_RING + RING_HEAD, 0);

   assert((pI830->ring.mem->offset & I830_RING_START_MASK) ==
	   pI830->ring.mem->offset);

   /* Don't care about the old value.  Reserved bits must be zero anyway. */
   itemp = pI830->ring.mem->offset;
   OUTREG(LP_RING + RING_START, itemp);

   if (((pI830->ring.mem->size - 4096) & I830_RING_NR_PAGES) !=
       pI830->ring.mem->size - 4096) {
      xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
		 "I830SetRingRegs: Ring buffer size - 4096 (%lx) violates its "
		 "mask (%x)\n", pI830->ring.mem->size - 4096,
		 I830_RING_NR_PAGES);
   }
   /* Don't care about the old value.  Reserved bits must be zero anyway. */
   itemp = (pI830->ring.mem->size - 4096) & I830_RING_NR_PAGES;
   itemp |= (RING_NO_REPORT | RING_VALID);
   OUTREG(LP_RING + RING_LEN, itemp);
   i830_refresh_ring(pScrn);
}
d1677 3
a1679 4
void
i830_refresh_ring(ScrnInfoPtr pScrn)
{
   I830Ptr pI830 = I830PTR(pScrn);
d1681 29
a1709 12
   /* If we're reaching RefreshRing as a result of grabbing the DRI lock
    * before we've set up the ringbuffer, don't bother.
    */
   if (pI830->ring.mem == NULL)
       return;

   pI830->ring.head = INREG(LP_RING + RING_HEAD) & I830_HEAD_MASK;
   pI830->ring.tail = INREG(LP_RING + RING_TAIL);
   pI830->ring.space = pI830->ring.head - (pI830->ring.tail + 8);
   if (pI830->ring.space < 0)
      pI830->ring.space += pI830->ring.mem->size;
   i830MarkSync(pScrn);
d1713 2
a1714 2
    PIPE_A = 0,
    PIPE_B,
d1717 1
a1717 2
static Bool
i830_pipe_enabled(I830Ptr pI830, enum pipe pipe)
d1719 4
a1722 4
    if (pipe == PIPE_A)
	return (INREG(PIPEACONF) & PIPEACONF_ENABLE);
    else
	return (INREG(PIPEBCONF) & PIPEBCONF_ENABLE);
d1725 1
a1725 2
static void
i830_save_palette(I830Ptr pI830, enum pipe pipe)
d1727 1
a1727 1
    int i;
d1729 2
a1730 2
    if (!i830_pipe_enabled(pI830, pipe))
	return;
d1732 6
a1737 6
    for(i= 0; i < 256; i++) {
	if (pipe == PIPE_A)
	    pI830->savePaletteA[i] = INREG(PALETTE_A + (i << 2));
	else
	    pI830->savePaletteB[i] = INREG(PALETTE_B + (i << 2));
    }
d1740 1
a1740 2
static void
i830_restore_palette(I830Ptr pI830, enum pipe pipe)
d1742 1
a1742 1
    int i;
d1744 2
a1745 2
    if (!i830_pipe_enabled(pI830, pipe))
	return;
d1747 6
a1752 6
    for(i= 0; i < 256; i++) {
	if (pipe == PIPE_A)
	    OUTREG(PALETTE_A + (i << 2), pI830->savePaletteA[i]);
	else
	    OUTREG(PALETTE_B + (i << 2), pI830->savePaletteB[i]);
    }
d1755 1
a1755 2
static Bool
SaveHWState(ScrnInfoPtr pScrn)
d1757 13
a1769 13
   xf86CrtcConfigPtr   xf86_config = XF86_CRTC_CONFIG_PTR(pScrn);
   I830Ptr pI830 = I830PTR(pScrn);
   vgaHWPtr hwp = VGAHWPTR(pScrn);
   vgaRegPtr vgaReg = &hwp->SavedReg;
   int i;

   if (pI830->fb_compression) {
       pI830->saveFBC_CFB_BASE = INREG(FBC_CFB_BASE);
       pI830->saveFBC_LL_BASE = INREG(FBC_LL_BASE);
       pI830->saveFBC_CONTROL2 = INREG(FBC_CONTROL2);
       pI830->saveFBC_CONTROL = INREG(FBC_CONTROL);
       pI830->saveFBC_FENCE_OFF = INREG(FBC_FENCE_OFF);
   }
d1771 46
a1816 46
   /* Save video mode information for native mode-setting. */
   if (!DSPARB_HWCONTROL(pI830))
       pI830->saveDSPARB = INREG(DSPARB);

   pI830->saveDSPACNTR = INREG(DSPACNTR);
   pI830->savePIPEACONF = INREG(PIPEACONF);
   pI830->savePIPEASRC = INREG(PIPEASRC);
   pI830->saveFPA0 = INREG(FPA0);
   pI830->saveFPA1 = INREG(FPA1);
   pI830->saveDPLL_A = INREG(DPLL_A);
   if (IS_I965G(pI830))
      pI830->saveDPLL_A_MD = INREG(DPLL_A_MD);
   pI830->saveHTOTAL_A = INREG(HTOTAL_A);
   pI830->saveHBLANK_A = INREG(HBLANK_A);
   pI830->saveHSYNC_A = INREG(HSYNC_A);
   pI830->saveVTOTAL_A = INREG(VTOTAL_A);
   pI830->saveVBLANK_A = INREG(VBLANK_A);
   pI830->saveVSYNC_A = INREG(VSYNC_A);
   pI830->saveBCLRPAT_A = INREG(BCLRPAT_A);
   pI830->saveDSPASTRIDE = INREG(DSPASTRIDE);
   pI830->saveDSPASIZE = INREG(DSPASIZE);
   pI830->saveDSPAPOS = INREG(DSPAPOS);
   pI830->saveDSPABASE = INREG(DSPABASE);

   i830_save_palette(pI830, PIPE_A);

   if(xf86_config->num_crtc == 2) {
      pI830->savePIPEBCONF = INREG(PIPEBCONF);
      pI830->savePIPEBSRC = INREG(PIPEBSRC);
      pI830->saveDSPBCNTR = INREG(DSPBCNTR);
      pI830->saveFPB0 = INREG(FPB0);
      pI830->saveFPB1 = INREG(FPB1);
      pI830->saveDPLL_B = INREG(DPLL_B);
      if (IS_I965G(pI830))
	 pI830->saveDPLL_B_MD = INREG(DPLL_B_MD);
      pI830->saveHTOTAL_B = INREG(HTOTAL_B);
      pI830->saveHBLANK_B = INREG(HBLANK_B);
      pI830->saveHSYNC_B = INREG(HSYNC_B);
      pI830->saveVTOTAL_B = INREG(VTOTAL_B);
      pI830->saveVBLANK_B = INREG(VBLANK_B);
      pI830->saveVSYNC_B = INREG(VSYNC_B);
      pI830->saveBCLRPAT_B = INREG(BCLRPAT_B);
      pI830->saveDSPBSTRIDE = INREG(DSPBSTRIDE);
      pI830->saveDSPBSIZE = INREG(DSPBSIZE);
      pI830->saveDSPBPOS = INREG(DSPBPOS);
      pI830->saveDSPBBASE = INREG(DSPBBASE);
d1818 2
a1819 2
      i830_save_palette(pI830, PIPE_B);
   }
d1821 6
a1826 6
   if (IS_I965G(pI830)) {
      pI830->saveDSPASURF = INREG(DSPASURF);
      pI830->saveDSPBSURF = INREG(DSPBSURF);
      pI830->saveDSPATILEOFF = INREG(DSPATILEOFF);
      pI830->saveDSPBTILEOFF = INREG(DSPBTILEOFF);
   }
d1828 27
a1854 27
   pI830->saveVCLK_DIVISOR_VGA0 = INREG(VCLK_DIVISOR_VGA0);
   pI830->saveVCLK_DIVISOR_VGA1 = INREG(VCLK_DIVISOR_VGA1);
   pI830->saveVCLK_POST_DIV = INREG(VCLK_POST_DIV);
   pI830->saveVGACNTRL = INREG(VGACNTRL);

   pI830->saveCURSOR_A_CONTROL = INREG(CURSOR_A_CONTROL);
   pI830->saveCURSOR_A_POSITION = INREG(CURSOR_A_POSITION);
   pI830->saveCURSOR_A_BASE = INREG(CURSOR_A_BASE);
   pI830->saveCURSOR_B_CONTROL = INREG(CURSOR_B_CONTROL);
   pI830->saveCURSOR_B_POSITION = INREG(CURSOR_B_POSITION);
   pI830->saveCURSOR_B_BASE = INREG(CURSOR_B_BASE);

   for(i = 0; i < 7; i++) {
      pI830->saveSWF[i] = INREG(SWF0 + (i << 2));
      pI830->saveSWF[i+7] = INREG(SWF00 + (i << 2));
   }
   pI830->saveSWF[14] = INREG(SWF30);
   pI830->saveSWF[15] = INREG(SWF31);
   pI830->saveSWF[16] = INREG(SWF32);

   pI830->saveDSPCLK_GATE_D = INREG(DSPCLK_GATE_D);
   pI830->saveRENCLK_GATE_D1 = INREG(RENCLK_GATE_D1);

   if (IS_I965G(pI830)) {
      pI830->saveRENCLK_GATE_D2 = INREG(RENCLK_GATE_D2);
      pI830->saveRAMCLK_GATE_D = INREG(RAMCLK_GATE_D);
   }
d1856 2
a1857 2
   if (IS_I965GM(pI830) || IS_GM45(pI830))
      pI830->savePWRCTXA = INREG(PWRCTXA);
d1859 9
a1867 9
   if (IS_MOBILE(pI830) && !IS_I830(pI830))
      pI830->saveLVDS = INREG(LVDS);
   pI830->savePFIT_CONTROL = INREG(PFIT_CONTROL);

   for (i = 0; i < xf86_config->num_output; i++) {
      xf86OutputPtr   output = xf86_config->output[i];
      if (output->funcs->save)
	 (*output->funcs->save) (output);
   }
d1869 2
a1870 2
   vgaHWUnlock(hwp);
   vgaHWSave(pScrn, vgaReg, VGA_SR_FONTS);
d1872 1
a1872 1
   return TRUE;
d1876 1
a1876 2
static void
i830_dpll_settle(void)
d1878 1
a1878 1
    usleep(10000); /* 10 ms *should* be plenty */
d1881 1
a1881 2
static Bool
RestoreHWState(ScrnInfoPtr pScrn)
d1883 5
a1887 5
   xf86CrtcConfigPtr   xf86_config = XF86_CRTC_CONFIG_PTR(pScrn);
   I830Ptr pI830 = I830PTR(pScrn);
   vgaHWPtr hwp = VGAHWPTR(pScrn);
   vgaRegPtr vgaReg = &hwp->SavedReg;
   int i;
d1889 1
a1889 1
   DPRINTF(PFX, "RestoreHWState\n");
d1891 6
a1896 9
#ifdef XF86DRI
   I830DRISetVBlankInterrupt (pScrn, FALSE);
#endif
   /* Disable outputs */
   for (i = 0; i < xf86_config->num_output; i++) {
      xf86OutputPtr   output = xf86_config->output[i];
      output->funcs->dpms(output, DPMSModeOff);
   }
   i830WaitForVblank(pScrn);
d1898 6
a1903 6
   /* Disable pipes */
   for (i = 0; i < xf86_config->num_crtc; i++) {
      xf86CrtcPtr crtc = xf86_config->crtc[i];
      i830_crtc_disable(crtc, TRUE);
   }
   i830WaitForVblank(pScrn);
d1905 2
a1906 2
   if (IS_MOBILE(pI830) && !IS_I830(pI830))
      OUTREG(LVDS, pI830->saveLVDS);
d1908 2
a1909 2
   if (!IS_I830(pI830) && !IS_845G(pI830))
     OUTREG(PFIT_CONTROL, pI830->savePFIT_CONTROL);
d1911 2
a1912 2
   if (!DSPARB_HWCONTROL(pI830))
       OUTREG(DSPARB, pI830->saveDSPARB);
d1914 2
a1915 2
   OUTREG(DSPCLK_GATE_D, pI830->saveDSPCLK_GATE_D);
   OUTREG(RENCLK_GATE_D1, pI830->saveRENCLK_GATE_D1);
d1917 4
a1920 4
   if (IS_I965G(pI830)) {
      OUTREG(RENCLK_GATE_D2, pI830->saveRENCLK_GATE_D2);
      OUTREG(RAMCLK_GATE_D, pI830->saveRAMCLK_GATE_D);
   }
d1922 2
a1923 2
   if (IS_I965GM(pI830) || IS_GM45(pI830))
      OUTREG(PWRCTXA, pI830->savePWRCTXA);
d1925 53
a1977 7
   /*
    * Pipe regs
    * To restore the saved state, we first need to program the PLL regs,
    * followed by the pipe configuration and finally the display plane
    * configuration.  The VGA registers can program one, both or neither
    * of the PLL regs, depending on their VGA_MOD_DIS bit value.
    */
d1979 3
a1981 7
   /*
    * Since either or both pipes may use the VGA clocks, make sure the
    * regs are valid.
    */
   OUTREG(VCLK_DIVISOR_VGA0, pI830->saveVCLK_DIVISOR_VGA0);
   OUTREG(VCLK_DIVISOR_VGA1, pI830->saveVCLK_DIVISOR_VGA1);
   OUTREG(VCLK_POST_DIV, pI830->saveVCLK_POST_DIV);
d1983 20
a2002 39
   /* If the pipe A PLL is active, we can restore the pipe & plane config */
   if (pI830->saveDPLL_A & DPLL_VCO_ENABLE)
   {
      OUTREG(FPA0, pI830->saveFPA0);
      OUTREG(DPLL_A, pI830->saveDPLL_A & ~DPLL_VCO_ENABLE);
      POSTING_READ(DPLL_A);
      usleep(150);
   }
   OUTREG(FPA0, pI830->saveFPA0);
   OUTREG(FPA1, pI830->saveFPA1);
   OUTREG(DPLL_A, pI830->saveDPLL_A);
   POSTING_READ(DPLL_A);
   i830_dpll_settle();
   if (IS_I965G(pI830))
      OUTREG(DPLL_A_MD, pI830->saveDPLL_A_MD);
   else
      OUTREG(DPLL_A, pI830->saveDPLL_A);
   POSTING_READ(DPLL_A);
   i830_dpll_settle();

   /* Restore mode config */
   OUTREG(HTOTAL_A, pI830->saveHTOTAL_A);
   OUTREG(HBLANK_A, pI830->saveHBLANK_A);
   OUTREG(HSYNC_A, pI830->saveHSYNC_A);
   OUTREG(VTOTAL_A, pI830->saveVTOTAL_A);
   OUTREG(VBLANK_A, pI830->saveVBLANK_A);
   OUTREG(VSYNC_A, pI830->saveVSYNC_A);
   OUTREG(BCLRPAT_A, pI830->saveBCLRPAT_A);
   
   OUTREG(DSPASTRIDE, pI830->saveDSPASTRIDE);
   OUTREG(DSPASIZE, pI830->saveDSPASIZE);
   OUTREG(DSPAPOS, pI830->saveDSPAPOS);
   OUTREG(PIPEASRC, pI830->savePIPEASRC);
   OUTREG(DSPABASE, pI830->saveDSPABASE);
   if (IS_I965G(pI830))
   {
      OUTREG(DSPASURF, pI830->saveDSPASURF);
      OUTREG(DSPATILEOFF, pI830->saveDSPATILEOFF);
   }
d2004 22
a2025 47
   OUTREG(PIPEACONF, pI830->savePIPEACONF);
   POSTING_READ(PIPEACONF);
   i830WaitForVblank(pScrn);

   /*
    * Program Pipe A's plane
    * The corresponding display plane may be disabled, and should only be
    * enabled if pipe A is actually on (otherwise we have a bug in the initial
    * state).
    */
   if ((pI830->saveDSPACNTR & DISPPLANE_SEL_PIPE_MASK) ==
       DISPPLANE_SEL_PIPE_A) {
       OUTREG(DSPACNTR, pI830->saveDSPACNTR);
       OUTREG(DSPABASE, INREG(DSPABASE));
       POSTING_READ(DSPABASE);
       i830WaitForVblank(pScrn);
   }
   if ((pI830->saveDSPBCNTR & DISPPLANE_SEL_PIPE_MASK) ==
       DISPPLANE_SEL_PIPE_A) {
       OUTREG(DSPBCNTR, pI830->saveDSPBCNTR);
       OUTREG(DSPBBASE, INREG(DSPBBASE));
       POSTING_READ(DSPBBASE);
       i830WaitForVblank(pScrn);
   }

   /* See note about pipe programming above */
   if(xf86_config->num_crtc == 2) 
   {
      /* If the pipe B PLL is active, we can restore the pipe & plane config */
      if (pI830->saveDPLL_B & DPLL_VCO_ENABLE)
      {
	 OUTREG(FPB0, pI830->saveFPB0);
	 OUTREG(DPLL_B, pI830->saveDPLL_B & ~DPLL_VCO_ENABLE);
	 POSTING_READ(DPLL_B);
	 usleep(150);
      }
      OUTREG(FPB0, pI830->saveFPB0);
      OUTREG(FPB1, pI830->saveFPB1);
      OUTREG(DPLL_B, pI830->saveDPLL_B);
      POSTING_READ(DPLL_B);
      i830_dpll_settle();
      if (IS_I965G(pI830))
	 OUTREG(DPLL_B_MD, pI830->saveDPLL_B_MD);
      else
	 OUTREG(DPLL_B, pI830->saveDPLL_B);
      POSTING_READ(DPLL_B);
      i830_dpll_settle();
d2027 17
a2043 18
      /* Restore mode config */
      OUTREG(HTOTAL_B, pI830->saveHTOTAL_B);
      OUTREG(HBLANK_B, pI830->saveHBLANK_B);
      OUTREG(HSYNC_B, pI830->saveHSYNC_B);
      OUTREG(VTOTAL_B, pI830->saveVTOTAL_B);
      OUTREG(VBLANK_B, pI830->saveVBLANK_B);
      OUTREG(VSYNC_B, pI830->saveVSYNC_B);
      OUTREG(BCLRPAT_B, pI830->saveBCLRPAT_B);
      OUTREG(DSPBSTRIDE, pI830->saveDSPBSTRIDE);
      OUTREG(DSPBSIZE, pI830->saveDSPBSIZE);
      OUTREG(DSPBPOS, pI830->saveDSPBPOS);
      OUTREG(PIPEBSRC, pI830->savePIPEBSRC);
      OUTREG(DSPBBASE, pI830->saveDSPBBASE);
      if (IS_I965G(pI830))
      {
	 OUTREG(DSPBSURF, pI830->saveDSPBSURF);
	 OUTREG(DSPBTILEOFF, pI830->saveDSPBTILEOFF);
      }
d2045 22
a2066 22
      OUTREG(PIPEBCONF, pI830->savePIPEBCONF);
      POSTING_READ(PIPEBCONF);
      i830WaitForVblank(pScrn);

      /*
       * Program Pipe B's plane
       * Note that pipe B may be disabled, and in that case, the plane
       * should also be disabled or we must have had a bad initial state.
       */
      if ((pI830->saveDSPACNTR & DISPPLANE_SEL_PIPE_MASK) ==
	  DISPPLANE_SEL_PIPE_B) {
	  OUTREG(DSPACNTR, pI830->saveDSPACNTR);
	  OUTREG(DSPABASE, INREG(DSPABASE));
	  i830WaitForVblank(pScrn);
      }
      if ((pI830->saveDSPBCNTR & DISPPLANE_SEL_PIPE_MASK) ==
	  DISPPLANE_SEL_PIPE_B) {
	  OUTREG(DSPBCNTR, pI830->saveDSPBCNTR);
	  OUTREG(DSPBBASE, INREG(DSPBBASE));
	  i830WaitForVblank(pScrn);
      }
   }
d2068 1
a2068 1
   OUTREG(VGACNTRL, pI830->saveVGACNTRL);
d2070 20
a2089 20
   /*
    * Restore cursors
    * Even though the X cursor is hidden before we restore the hw state,
    * we probably only disabled one cursor plane.  If we're going from
    * e.g. plane b to plane a here in RestoreHWState, we need to restore
    * both cursor plane settings.
    */
   OUTREG(CURSOR_A_POSITION, pI830->saveCURSOR_A_POSITION);
   OUTREG(CURSOR_A_BASE, pI830->saveCURSOR_A_BASE);
   OUTREG(CURSOR_A_CONTROL, pI830->saveCURSOR_A_CONTROL);
   OUTREG(CURSOR_B_POSITION, pI830->saveCURSOR_B_POSITION);
   OUTREG(CURSOR_B_BASE, pI830->saveCURSOR_B_BASE);
   OUTREG(CURSOR_B_CONTROL, pI830->saveCURSOR_B_CONTROL);

   /* Restore outputs */
   for (i = 0; i < xf86_config->num_output; i++) {
      xf86OutputPtr   output = xf86_config->output[i];
      if (output->funcs->restore)
	 output->funcs->restore(output);
   }
d2091 2
a2092 2
   i830_restore_palette(pI830, PIPE_A);
   i830_restore_palette(pI830, PIPE_B);
d2094 4
a2097 4
   for(i = 0; i < 7; i++) {
      OUTREG(SWF0 + (i << 2), pI830->saveSWF[i]);
      OUTREG(SWF00 + (i << 2), pI830->saveSWF[i+7]);
   }
d2099 11
a2109 11
   OUTREG(SWF30, pI830->saveSWF[14]);
   OUTREG(SWF31, pI830->saveSWF[15]);
   OUTREG(SWF32, pI830->saveSWF[16]);

   if (pI830->fb_compression) {
       OUTREG(FBC_CFB_BASE, pI830->saveFBC_CFB_BASE);
       OUTREG(FBC_LL_BASE, pI830->saveFBC_LL_BASE);
       OUTREG(FBC_FENCE_OFF, pI830->saveFBC_FENCE_OFF);
       OUTREG(FBC_CONTROL2, pI830->saveFBC_CONTROL2);
       OUTREG(FBC_CONTROL, pI830->saveFBC_CONTROL);
   }
d2111 2
a2112 2
   vgaHWRestore(pScrn, vgaReg, VGA_SR_FONTS);
   vgaHWLock(hwp);
d2114 1
a2114 68
   return TRUE;
}

static void
I830PointerMoved(int index, int x, int y)
{
   ScrnInfoPtr pScrn = xf86Screens[index];
   I830Ptr pI830 = I830PTR(pScrn);
   int newX = x, newY = y;

   switch (pI830->rotation) {
      case RR_Rotate_0:
         break;
      case RR_Rotate_90:
         newX = y;
         newY = pScrn->pScreen->width - x - 1;
         break;
      case RR_Rotate_180:
         newX = pScrn->pScreen->width - x - 1;
         newY = pScrn->pScreen->height - y - 1;
         break;
      case RR_Rotate_270:
         newX = pScrn->pScreen->height - y - 1;
         newY = x;
         break;
   }

   (*pI830->PointerMoved)(index, newX, newY);
}

static Bool
I830InitFBManager(
    ScreenPtr pScreen,  
    BoxPtr FullBox
){
   ScrnInfoPtr pScrn = xf86Screens[pScreen->myNum];
   RegionRec ScreenRegion;
   RegionRec FullRegion;
   BoxRec ScreenBox;
   Bool ret;

   ScreenBox.x1 = 0;
   ScreenBox.y1 = 0;
   ScreenBox.x2 = pScrn->displayWidth;
   if (pScrn->virtualX > pScrn->virtualY)
      ScreenBox.y2 = pScrn->virtualX;
   else
      ScreenBox.y2 = pScrn->virtualY;

   if((FullBox->x1 >  ScreenBox.x1) || (FullBox->y1 >  ScreenBox.y1) ||
      (FullBox->x2 <  ScreenBox.x2) || (FullBox->y2 <  ScreenBox.y2)) {
	return FALSE;   
   }

   if (FullBox->y2 < FullBox->y1) return FALSE;
   if (FullBox->x2 < FullBox->x2) return FALSE;

   REGION_INIT(pScreen, &ScreenRegion, &ScreenBox, 1); 
   REGION_INIT(pScreen, &FullRegion, FullBox, 1); 

   REGION_SUBTRACT(pScreen, &FullRegion, &FullRegion, &ScreenRegion);

   ret = xf86InitFBManagerRegion(pScreen, &FullRegion);

   REGION_UNINIT(pScreen, &ScreenRegion);
   REGION_UNINIT(pScreen, &FullRegion);
    
   return ret;
d2124 1
a2124 2
void
IntelEmitInvarientState(ScrnInfoPtr pScrn)
d2126 1
a2126 1
   I830Ptr pI830 = I830PTR(pScrn);
d2128 12
a2139 26
   if (pI830->accel == ACCEL_NONE)
      return;

#ifdef XF86DRI
   if (pI830->directRenderingType == DRI_XF86DRI) {
      drmI830Sarea *sarea = DRIGetSAREAPrivate(pScrn->pScreen);

      /* Mark that the X Server was the last holder of the context */
      if (sarea)
	 sarea->ctxOwner = DRIGetContext(pScrn->pScreen);
   }
#endif

   /* If we've emitted our state since the last clobber by another client,
    * skip it.
    */
   if (pI830->last_3d != LAST_3D_OTHER)
      return;

   if (!IS_I965G(pI830))
   {
      if (IS_I9XX(pI830))
         I915EmitInvarientState(pScrn);
      else
         I830EmitInvarientState(pScrn);
   }
d2143 1
a2143 2
I830BlockHandler(int i,
		 pointer blockData, pointer pTimeout, pointer pReadmask)
d2145 23
a2167 3
    ScreenPtr pScreen = screenInfo.screens[i];
    ScrnInfoPtr pScrn = xf86Screens[i];
    I830Ptr pI830 = I830PTR(pScrn);
d2169 3
a2171 1
    pScreen->BlockHandler = pI830->BlockHandler;
d2173 1
a2173 1
    (*pScreen->BlockHandler) (i, blockData, pTimeout, pReadmask);
d2175 1
a2175 33
    pI830->BlockHandler = pScreen->BlockHandler;
    pScreen->BlockHandler = I830BlockHandler;

    if (pScrn->vtSema && pI830->accel != ACCEL_NONE) {
       Bool flushed = FALSE;
       /* Emit a flush of the rendering cache, or on the 965 and beyond
	* rendering results may not hit the framebuffer until significantly
	* later.
	*/
       if (pI830->accel != ACCEL_NONE && (pI830->need_mi_flush || pI830->batch_used))
       {
	  flushed = TRUE;
	  I830EmitFlush(pScrn);
       }

       /* Flush the batch, so that any rendering is executed in a timely
	* fashion.
	*/
       intel_batch_flush(pScrn, flushed);
#ifdef XF86DRI
       if (pI830->memory_manager)
	 drmCommandNone(pI830->drmSubFD, DRM_I915_GEM_THROTTLE);
#endif

       pI830->need_mi_flush = FALSE;
    }

#ifdef I830_USE_UXA
    if (pI830->accel == ACCEL_UXA)
	i830_uxa_block_handler (pScreen);
#endif

    I830VideoBlockHandler(i, blockData, pTimeout, pReadmask);
d2178 1
a2178 2
static void
i830_fixup_mtrrs(ScrnInfoPtr pScrn)
d2181 35
a2215 32
    I830Ptr pI830 = I830PTR(pScrn);
    int fd;
    struct mtrr_gentry gentry;
    struct mtrr_sentry sentry;

    if ( ( fd = open ("/proc/mtrr", O_RDONLY, 0) ) != -1 ) {
	for (gentry.regnum = 0; ioctl (fd, MTRRIOC_GET_ENTRY, &gentry) == 0;
		++gentry.regnum) {

	    if (gentry.size < 1) {
		/* DISABLED */
		continue;
	    }

	    /* Check the MTRR range is one we like and if not - remove it.
	     * The Xserver common layer will then setup the right range
	     * for us.
	     */
	    if (gentry.base == pI830->LinearAddr && 
		    gentry.size < pI830->FbMapSize) {

		xf86DrvMsg(pScrn->scrnIndex, X_INFO,
			"Removing bad MTRR range (base 0x%lx, size 0x%x)\n",
			gentry.base, gentry.size);

		sentry.base = gentry.base;
		sentry.size = gentry.size;
		sentry.type = gentry.type;

		if (ioctl (fd, MTRRIOC_DEL_ENTRY, &sentry) == -1) {
		    xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
			    "Failed to remove bad MTRR range\n");
d2217 1
a2217 1
	    }
a2218 2
	close(fd);
    }
d2222 1
a2222 2
static Bool
i830_try_memory_allocation(ScrnInfoPtr pScrn)
d2224 2
a2225 3
    I830Ptr pI830 = I830PTR(pScrn);
    Bool tiled = pI830->tiling;
    Bool xf86dri = pI830->directRenderingType == DRI_XF86DRI;
d2227 13
a2239 17
    xf86DrvMsg(pScrn->scrnIndex, X_INFO,
	    "Attempting memory allocation with %stiled buffers.\n",
	    tiled ? "" : "un");

    if (!i830_allocate_2d_memory(pScrn))
	goto failed;

    if (IS_I965GM(pI830) || IS_GM45(pI830))
	if (!i830_allocate_pwrctx(pScrn))
	    goto failed;

    if (xf86dri && !i830_allocate_3d_memory(pScrn))
	goto failed;

    xf86DrvMsg(pScrn->scrnIndex, X_INFO, "%siled allocation successful.\n",
	    tiled ? "T" : "Unt");
    return TRUE;
d2242 3
a2244 3
    xf86DrvMsg(pScrn->scrnIndex, X_INFO, "%siled allocation failed.\n",
	    tiled ? "T" : "Unt");
    return FALSE;
d2246 1
d2256 1
a2256 2
static Bool
i830_memory_init(ScrnInfoPtr pScrn)
d2258 12
a2269 12
    I830Ptr pI830 = I830PTR(pScrn);
    int savedDisplayWidth = pScrn->displayWidth;
    Bool tiled = FALSE;

    tiled = i830_tiled_width(pI830, &pScrn->displayWidth, pI830->cpp);
    /* Set up our video memory allocator for the chosen videoRam */
    if (!i830_allocator_init(pScrn, 0, pScrn->videoRam * KB(1))) {
	xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
		"Couldn't initialize video memory allocator\n");
	PreInitCleanup(pScrn);
	return FALSE;
    }
d2271 12
a2282 39
    xf86DrvMsg(pScrn->scrnIndex,
	    pI830->pEnt->device->videoRam ? X_CONFIG : X_DEFAULT,
	    "VideoRam: %d KB\n", pScrn->videoRam);

    if (xf86GetOptValInteger(pI830->Options, OPTION_CACHE_LINES,
		&(pI830->CacheLines))) {
	xf86DrvMsg(pScrn->scrnIndex, X_CONFIG, "Requested %d cache lines\n",
		pI830->CacheLines);
    } else {
	pI830->CacheLines = -1;
    }

    /* Tiled first if we got a good displayWidth */
    if (tiled) {
	if (i830_try_memory_allocation(pScrn))
	    return TRUE;
	else {
	    i830_reset_allocations(pScrn);
	    pI830->tiling = FALSE;
	}
    }

    /* If tiling fails we have to disable FBC */
    pScrn->displayWidth = savedDisplayWidth;
    if (pI830->fb_compression)
	xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
		"Couldn't allocate tiled memory, fb compression "
		"disabled\n");
    pI830->fb_compression = FALSE;

    /* Try again, but leave DRI enabled */
    if (pI830->directRenderingType == DRI_XF86DRI) {
	if (i830_try_memory_allocation(pScrn))
	    return TRUE;
	else {
	    i830_reset_allocations(pScrn);
	    xf86DrvMsg(pScrn->scrnIndex, X_INFO, "Couldn't allocate 3D memory, "
		    "disabling DRI.\n");
	    pI830->directRenderingType = DRI_NONE;
a2283 1
    }
d2285 10
a2294 2
    if (i830_try_memory_allocation(pScrn))
	return TRUE;
d2296 1
a2296 1
    return FALSE;
d2299 1
a2299 2
void
i830_init_bufmgr(ScrnInfoPtr pScrn)
d2301 2
a2302 1
   I830Ptr pI830 = I830PTR(pScrn);
d2304 4
a2307 2
   if (pI830->bufmgr)
       return;
d2309 1
a2309 2
   if (pI830->memory_manager || pI830->use_drm_mode) {
      int batch_size;
d2311 3
a2313 1
      batch_size = 4096 * 4;
d2315 31
a2345 3
      /* The 865 has issues with larger-than-page-sized batch buffers. */
      if (IS_I865G(pI830))
	 batch_size = 4096;
d2347 10
a2356 11
      pI830->bufmgr = intel_bufmgr_gem_init(pI830->drmSubFD, batch_size);
      intel_bufmgr_gem_enable_reuse(pI830->bufmgr);
   } else {
      assert(pI830->FbBase != NULL);
      pI830->bufmgr = intel_bufmgr_fake_init(pI830->drmSubFD,
					     pI830->fake_bufmgr_mem->offset,
					     pI830->FbBase +
					     pI830->fake_bufmgr_mem->offset,
					     pI830->fake_bufmgr_mem->size,
					     NULL);
   }
d2359 15
d2376 1
a2376 1
I830AdjustMemory(ScreenPtr pScreen)
d2378 26
a2403 26
   ScrnInfoPtr pScrn;
   I830Ptr pI830;
   unsigned long sys_mem;
   MessageType from;

   pScrn = xf86Screens[pScreen->myNum];
   pI830 = I830PTR(pScrn);

   /* Limit videoRam to how much we might be able to allocate from AGP */
   sys_mem = I830CheckAvailableMemory(pScrn);
   if (sys_mem == -1) {
      xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
		 "/dev/agpgart is either not available, or no memory "
		 "is available\nfor allocation.  Please enable agpgart\n.");
      pScrn->videoRam = pI830->stolen_size / KB(1);
   }
   if (sys_mem + (pI830->stolen_size / 1024) < pScrn->videoRam) {
      pScrn->videoRam = sys_mem + (pI830->stolen_size / 1024);
      from = X_PROBED;
      if (sys_mem + (pI830->stolen_size / 1024) <
	  pI830->pEnt->device->videoRam) {
	 xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
		    "VideoRAM reduced to %d kByte "
		    "(limited to available sysmem)\n", pScrn->videoRam);
      }
   }
d2405 9
a2413 10
   /* Limit video RAM to the actual aperture size */
   if (pScrn->videoRam > pI830->FbMapSize / 1024) {
      pScrn->videoRam = pI830->FbMapSize / 1024;
      if (pI830->FbMapSize / 1024 < pI830->pEnt->device->videoRam) {
	 xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
		    "VideoRam reduced to %d kByte (limited to aperture "
		    "size)\n",
		    pScrn->videoRam);
      }
   }
d2415 7
a2421 7
   /* Make sure it's on a page boundary */
   if (pScrn->videoRam & 3) {
      xf86DrvMsg(pScrn->scrnIndex, X_WARNING, "VideoRam reduced to %d KB "
		 "(page aligned - was %d KB)\n",
		 pScrn->videoRam & ~3, pScrn->videoRam);
      pScrn->videoRam &= ~3;
   }
d2423 5
a2427 5
   if (!IS_I965G(pI830) && pScrn->displayWidth > 2048) {
      xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
		 "Cannot support DRI with frame buffer width > 2048.\n");
      pI830->directRenderingType = DRI_DISABLED;
   }
d2431 1
a2431 1
I830SwapPipes(ScrnInfoPtr pScrn)
d2433 26
a2458 28
   I830Ptr pI830 = I830PTR(pScrn);
   xf86CrtcConfigPtr config;
   int c;

   config = XF86_CRTC_CONFIG_PTR(pScrn);

   /*
    * If an LVDS display is present, swap the plane/pipe mappings so we can
    * use FBC on the builtin display.
    * Note: 965+ chips can compress either plane, so we leave the mapping
    *       alone in that case.
    * Also make sure the DRM can handle the swap.
    */
   if (I830LVDSPresent(pScrn) && !IS_I965GM(pI830) && !IS_GM45(pI830) &&
       (pI830->directRenderingType != DRI_XF86DRI ||
	(pI830->directRenderingType == DRI_XF86DRI && pI830->drmMinor >= 10))) {
       xf86DrvMsg(pScrn->scrnIndex, X_INFO, "adjusting plane->pipe mappings "
		  "to allow for framebuffer compression\n");
       for (c = 0; c < config->num_crtc; c++) {
	   xf86CrtcPtr	      crtc = config->crtc[c];
	   I830CrtcPrivatePtr   intel_crtc = crtc->driver_private;

	   if (intel_crtc->pipe == 0)
	       intel_crtc->plane = 1;
	   else if (intel_crtc->pipe == 1)
	       intel_crtc->plane = 0;
      }
   }
d2462 1
a2462 1
i830_disable_render_standby(ScrnInfoPtr pScrn)
d2464 2
a2465 2
   I830Ptr pI830 = I830PTR(pScrn);
   uint32_t render_standby;
d2467 9
a2475 9
   /* Render Standby might cause hang issue, try always disable it.*/
   if (IS_I965GM(pI830) || IS_GM45(pI830)) {
       render_standby = INREG(MCHBAR_RENDER_STANDBY);
       if (render_standby & RENDER_STANDBY_ENABLE) {
	   xf86DrvMsg(pScrn->scrnIndex, X_INFO, "Disable render standby.\n");
	   OUTREG(MCHBAR_RENDER_STANDBY,
		   (render_standby & (~RENDER_STANDBY_ENABLE)));
       }
   }
d2479 1
a2479 1
I830ScreenInit(int scrnIndex, ScreenPtr pScreen, int argc, char **argv)
d2481 27
a2507 30
   ScrnInfoPtr pScrn;
   vgaHWPtr hwp = NULL;
   I830Ptr pI830;
   VisualPtr visual;
   MessageType from;

   pScrn = xf86Screens[pScreen->myNum];
   pI830 = I830PTR(pScrn);

   if (!pI830->use_drm_mode)
       hwp = VGAHWPTR(pScrn);

   pScrn->displayWidth = i830_pad_drawable_width(pScrn->virtualX, pI830->cpp);

   /*
    * The "VideoRam" config file parameter specifies the maximum amount of
    * memory that will be used/allocated.  When not present, we allow the
    * driver to allocate as much memory as it wishes to satisfy its
    * allocations, but if agpgart support isn't available, it gets limited
    * to the amount of pre-allocated ("stolen") memory.
    *
    * Note that in using this value for allocator initialization, we're
    * limiting aperture allocation to the VideoRam option, rather than limiting
    * actual memory allocation, so alignment and things will cause less than
    * VideoRam to be actually used.
    */
   if (pI830->pEnt->device->videoRam == 0) {
      from = X_DEFAULT;
      pScrn->videoRam = pI830->FbMapSize / KB(1);
   } else {
d2509 2
a2510 2
      from = X_CONFIG;
      pScrn->videoRam = pI830->pEnt->device->videoRam;
d2512 22
a2533 9
      /* Disable VideoRam configuration, at least for now.  Previously,
       * VideoRam was necessary to avoid overly low limits on allocated
       * memory, so users created larger, yet still small, fixed allocation
       * limits in their config files.  Now, the driver wants to allocate more,
       * and the old intention of the VideoRam lines that had been entered is
       * obsolete.
       */
      from = X_DEFAULT;
      pScrn->videoRam = pI830->FbMapSize / KB(1);
d2535 3
a2537 11
      if (pScrn->videoRam != pI830->pEnt->device->videoRam) {
	 xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
		    "VideoRam configuration found, which is no longer "
		    "recommended.\n");
	 xf86DrvMsg(pScrn->scrnIndex, X_INFO,
		    "Continuing with default %dkB VideoRam instead of %d "
		    "kB.\n",
		    pScrn->videoRam, pI830->pEnt->device->videoRam);
      }
#endif
   }
d2539 4
a2542 8
   if (pI830->use_drm_mode) {
#ifdef XF86DRM_MODE
       pI830->stolen_size = 0;
       pScrn->videoRam = ~0UL / KB(1);
#endif
   } else {
       I830AdjustMemory(pScreen);
   }
d2545 3
a2547 2
   if (pI830->directRenderingType == DRI_NONE && I830DRI2ScreenInit(pScreen))
       pI830->directRenderingType = DRI_DRI2;
d2550 10
a2559 7
#ifdef XF86DRI
   /* If DRI hasn't been explicitly disabled, try to initialize it.
    * It will be used by the memory allocator.
    */
   if (!pI830->can_resize && pI830->directRenderingType == DRI_NONE && I830DRIScreenInit(pScreen))
       pI830->directRenderingType = DRI_XF86DRI;
#endif
d2561 5
a2565 2
   /* Enable tiling by default */
   pI830->tiling = TRUE;
d2567 7
a2573 7
   /* Allow user override if they set a value */
   if (xf86IsOptionSet(pI830->Options, OPTION_TILING)) {
       if (xf86ReturnOptValBool(pI830->Options, OPTION_TILING, FALSE))
	   pI830->tiling = TRUE;
       else
	   pI830->tiling = FALSE;
   }
d2575 5
a2579 5
   /* Enable FB compression if possible */
   if (i830_fb_compression_supported(pI830))
       pI830->fb_compression = TRUE;
   else
       pI830->fb_compression = FALSE;
d2581 2
a2582 7
   /* Again, allow user override if set */
   if (xf86IsOptionSet(pI830->Options, OPTION_FBC)) {
       if (xf86ReturnOptValBool(pI830->Options, OPTION_FBC, FALSE))
	   pI830->fb_compression = TRUE;
       else
	   pI830->fb_compression = FALSE;
   }
d2584 8
a2591 5
   if (pI830->use_drm_mode && pI830->fb_compression == TRUE) {
       xf86DrvMsg(pScrn->scrnIndex, X_CONFIG,
		  "Kernel mode setting active, disabling FBC.\n");
       pI830->fb_compression = FALSE;
   }
d2593 28
a2620 15
   xf86DrvMsg(pScrn->scrnIndex, X_CONFIG, "Framebuffer compression %sabled\n",
	      pI830->fb_compression ? "en" : "dis");
   xf86DrvMsg(pScrn->scrnIndex, X_CONFIG, "Tiling %sabled\n", pI830->tiling ?
	      "en" : "dis");

   pI830->last_3d = LAST_3D_OTHER;
   pI830->overlayOn = FALSE;

#ifdef I830_XV
    /*
     * Set this so that the overlay allocation is factored in when
     * appropriate.
     */
    pI830->XvEnabled = TRUE;
#endif
d2622 5
d2628 1
a2628 9
   /* Need MMIO mapped to do GTT lookups during memory allocation. */
   if (!pI830->use_drm_mode)
       I830MapMMIO(pScrn);

   if (!i830_memory_init(pScrn)) {
       xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
	       "Couldn't allocate video memory\n");
       return FALSE;
   }
d2630 1
a2630 1
   I830UnmapMMIO(pScrn);
d2632 15
a2646 1
   i830_fixup_mtrrs(pScrn);
d2648 1
a2648 1
   pI830->starting = TRUE;
d2650 2
a2651 7
   miClearVisualTypes();
   if (!miSetVisualTypes(pScrn->depth,
			    miGetDefaultVisualMask(pScrn->depth),
			    pScrn->rgbBits, pScrn->defaultVisual))
	 return FALSE;
   if (!miSetPixmapDepths())
      return FALSE;
d2653 27
a2679 18
#ifdef I830_XV
   if (pI830->accel == ACCEL_NONE) {
      xf86DrvMsg(pScrn->scrnIndex, X_PROBED, "Xv is disabled because it "
		 "needs 2D acceleration.\n");
      pI830->XvEnabled = FALSE;
   }
#else
   pI830->XvEnabled = FALSE;
#endif

   if (pI830->accel != ACCEL_NONE && !pI830->use_drm_mode) {
      if (pI830->memory_manager == NULL && pI830->ring.mem->size == 0) {
	  xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
		     "Disabling acceleration because the ring buffer "
		      "allocation failed.\n");
	   pI830->accel = ACCEL_NONE;
      }
   }
d2681 1
a2681 7
   if (!pI830->use_drm_mode) {
      DPRINTF(PFX, "assert( if(!I830MapMem(pScrn)) )\n");
      if (!I830MapMem(pScrn))
	 return FALSE;
      pScrn->memPhysBase = (unsigned long)pI830->FbBase;
   }
   i830_init_bufmgr(pScrn);
d2683 1
a2683 13
#ifdef XF86DRI
   /*
    * Setup DRI after visuals have been established, but before fbScreenInit
    * is called.   fbScreenInit will eventually call into the drivers
    * InitGLXVisuals call back.
    */
   if (pI830->directRenderingType == DRI_XF86DRI) {
      if (pI830->accel == ACCEL_NONE) {
	 xf86DrvMsg(pScrn->scrnIndex, X_PROBED, "DRI is disabled because it "
		    "needs 2D acceleration.\n");
	 pI830->directRenderingType = DRI_NONE;
      }
   }
d2685 5
a2689 9
   if (pI830->directRenderingType == DRI_XF86DRI &&
       !I830DRIDoMappings(pScreen))
       pI830->directRenderingType = DRI_NONE;

   /* If we failed for any reason, free DRI memory. */
   if (pI830->directRenderingType != DRI_XF86DRI &&
       pI830->back_buffer != NULL)
       i830_free_3d_memory(pScrn);
#endif
d2691 6
a2696 1
   pScrn->fbOffset = pI830->front_buffer->offset;
d2698 39
a2736 96
   pI830->xoffset = (pScrn->fbOffset / pI830->cpp) % pScrn->displayWidth;
   pI830->yoffset = (pScrn->fbOffset / pI830->cpp) / pScrn->displayWidth;

   if (!pI830->use_drm_mode) {
       vgaHWSetMmioFuncs(hwp, pI830->MMIOBase, 0);
       vgaHWGetIOBase(hwp);
       DPRINTF(PFX, "assert( if(!vgaHWMapMem(pScrn)) )\n");
       if (!vgaHWMapMem(pScrn))
	   return FALSE;
   }

   DPRINTF(PFX, "assert( if(!I830EnterVT(scrnIndex, 0)) )\n");

   if (pI830->accel <= ACCEL_XAA) {
      if (!I830InitFBManager(pScreen, &(pI830->FbMemBox))) {
	 xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
		    "Failed to init memory manager\n");
      }
   }

    if (pScrn->virtualX > pScrn->displayWidth)
	pScrn->displayWidth = pScrn->virtualX;

   DPRINTF(PFX, "assert( if(!fbScreenInit(pScreen, ...) )\n");
   if (!fbScreenInit(pScreen, pI830->FbBase + pScrn->fbOffset, 
                     pScrn->virtualX, pScrn->virtualY,
		     pScrn->xDpi, pScrn->yDpi,
		     pScrn->displayWidth, pScrn->bitsPerPixel))
      return FALSE;

   if (pScrn->bitsPerPixel > 8) {
      /* Fixup RGB ordering */
      visual = pScreen->visuals + pScreen->numVisuals;
      while (--visual >= pScreen->visuals) {
	 if ((visual->class | DynamicClass) == DirectColor) {
	    visual->offsetRed = pScrn->offset.red;
	    visual->offsetGreen = pScrn->offset.green;
	    visual->offsetBlue = pScrn->offset.blue;
	    visual->redMask = pScrn->mask.red;
	    visual->greenMask = pScrn->mask.green;
	    visual->blueMask = pScrn->mask.blue;
	 }
      }
   }

   fbPictureInit(pScreen, NULL, 0);

   xf86SetBlackWhitePixels(pScreen);

   xf86DiDGAInit (pScreen, pI830->LinearAddr + pScrn->fbOffset);

   DPRINTF(PFX,
	   "assert( if(!I830InitFBManager(pScreen, &(pI830->FbMemBox))) )\n");

   if (pI830->accel != ACCEL_NONE) {
      if (!I830AccelInit(pScreen)) {
	 xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
		    "Hardware acceleration initialization failed\n");
      }
   }

   if (IS_I965G(pI830))
       pI830->batch_flush_notify = i965_batch_flush_notify;
   else if (IS_I9XX(pI830))
       pI830->batch_flush_notify = i915_batch_flush_notify;
   else
       pI830->batch_flush_notify = NULL;

   miInitializeBackingStore(pScreen);
   xf86SetBackingStore(pScreen);
   xf86SetSilkenMouse(pScreen);
   miDCInitialize(pScreen, xf86GetPointerScreenFuncs());

   xf86DrvMsg(pScrn->scrnIndex, X_INFO, "Initializing HW Cursor\n");
   if (!I830CursorInit(pScreen))
      xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
		 "Hardware cursor initialization failed\n");

#ifdef XF86DRI
   /* Must be called before EnterVT, so we can acquire the DRI lock when
    * binding our memory.
    */
   if (pI830->directRenderingType == DRI_XF86DRI &&
       !I830DRIFinishScreenInit(pScreen))
       pI830->directRenderingType = DRI_NONE;
#endif

   /* Must force it before EnterVT, so we are in control of VT and
    * later memory should be bound when allocating, e.g rotate_mem */
   pScrn->vtSema = TRUE;

   if (!I830EnterVT(scrnIndex, 0))
      return FALSE;

   pI830->BlockHandler = pScreen->BlockHandler;
   pScreen->BlockHandler = I830BlockHandler;
d2738 1
a2738 5
   pScreen->SaveScreen = xf86SaveScreen;
   pI830->CloseScreen = pScreen->CloseScreen;
   pScreen->CloseScreen = I830CloseScreen;
   pI830->CreateScreenResources = pScreen->CreateScreenResources;
   pScreen->CreateScreenResources = i830CreateScreenResources;
a2739 17
   if (!xf86CrtcScreenInit (pScreen))
       return FALSE;

   DPRINTF(PFX, "assert( if(!miCreateDefColormap(pScreen)) )\n");
   if (!miCreateDefColormap(pScreen))
      return FALSE;

   DPRINTF(PFX, "assert( if(!xf86HandleColormaps(pScreen, ...)) )\n");
   if (!xf86HandleColormaps(pScreen, 256, 8, I830LoadPalette, NULL,
			    CMAP_RELOAD_ON_MODE_SWITCH |
			    CMAP_PALETTED_TRUECOLOR)) {
      return FALSE;
   }

   xf86DPMSInit(pScreen, xf86DPMSSet, 0);

#ifdef I830_XV
d2741 10
a2750 11
    pI830->XvMCEnabled = FALSE;
    from =  (pI830->directRenderingType == DRI_XF86DRI &&
	     xf86GetOptValBool(pI830->Options, OPTION_XVMC,
			       &pI830->XvMCEnabled)) ? X_CONFIG : X_DEFAULT;
    xf86DrvMsg(pScrn->scrnIndex, from, "Intel XvMC decoder %sabled\n",
	       pI830->XvMCEnabled ? "en" : "dis");
#endif
   /* Init video */
   if (pI830->XvEnabled)
      I830InitVideo(pScreen);
#endif
d2752 16
a2767 21
   /* Setup 3D engine, needed for rotation too */
   IntelEmitInvarientState(pScrn);

#if defined(XF86DRI) || defined(DRI2)
   switch (pI830->directRenderingType) {
   case DRI_XF86DRI:
      pI830->directRenderingOpen = TRUE;
      xf86DrvMsg(pScrn->scrnIndex, X_INFO,
		 "direct rendering: XF86DRI Enabled\n");
      break;
   case DRI_DRI2:
      pI830->directRenderingOpen = TRUE;
      xf86DrvMsg(pScrn->scrnIndex, X_INFO, "direct rendering: DRI2 Enabled\n");
      break;
   case DRI_DISABLED:
      xf86DrvMsg(pScrn->scrnIndex, X_INFO, "direct rendering: Disabled\n");
      break;
   case DRI_NONE:
      xf86DrvMsg(pScrn->scrnIndex, X_INFO, "direct rendering: Failed\n");
      break;
   }
d2769 2
a2770 1
   xf86DrvMsg(pScrn->scrnIndex, X_INFO, "direct rendering: Not available\n");
d2773 2
d2776 3
a2778 10
   /* Wrap pointer motion to flip touch screen around */
   pI830->PointerMoved = pScrn->PointerMoved;
   pScrn->PointerMoved = I830PointerMoved;

   if (serverGeneration == 1)
      xf86ShowUnusedOptions(pScrn->scrnIndex, pScrn->options);

   pI830->starting = FALSE;
   pI830->closing = FALSE;
   pI830->suspended = FALSE;
d2780 1
a2780 1
   return TRUE;
d2783 1
a2783 2
static void
i830AdjustFrame(int scrnIndex, int x, int y, int flags)
d2785 3
a2787 3
   ScrnInfoPtr pScrn = xf86Screens[scrnIndex];
   xf86CrtcConfigPtr	config = XF86_CRTC_CONFIG_PTR(pScrn);
   I830Ptr pI830 = I830PTR(pScrn);
d2792 1
a2792 1
	   x, pI830->xoffset, y, pI830->yoffset);
d2794 1
a2794 1
   if (pI830->use_drm_mode)
d2800 1
a2800 1
      i830WaitSync(pScrn);
d2807 1
a2807 2
static void
I830FreeScreen(int scrnIndex, int flags)
d2809 1
d2811 3
a2813 4
    ScrnInfoPtr pScrn = xf86Screens[scrnIndex];
    I830Ptr pI830 = I830PTR(pScrn);
    if (pI830 && pI830->XvMCEnabled)
	intel_xvmc_finish(xf86Screens[scrnIndex]);
d2815 6
a2820 3
   I830FreeRec(xf86Screens[scrnIndex]);
   if (xf86LoaderCheckSymbol("vgaHWFreeHWRec"))
      vgaHWFreeHWRec(xf86Screens[scrnIndex]);
d2823 1
a2823 2
static void
I830LeaveVT(int scrnIndex, int flags)
d2825 3
a2827 11
   ScrnInfoPtr pScrn = xf86Screens[scrnIndex];
   I830Ptr pI830 = I830PTR(pScrn);
   int ret;
#ifndef HAVE_FREE_SHADOW
   xf86CrtcConfigPtr config = XF86_CRTC_CONFIG_PTR(pScrn);
   int o;
#endif

   DPRINTF(PFX, "Leave VT\n");

   pI830->leaving = TRUE;
d2829 1
a2829 3
   if (pI830->devicesTimer)
      TimerFree(pI830->devicesTimer);
   pI830->devicesTimer = NULL;
d2831 1
a2831 1
   i830SetHotkeyControl(pScrn, HOTKEY_BIOS_SWITCH);
d2833 3
a2835 4
#ifdef XF86DRI
   if (pI830->directRenderingOpen &&
       pI830->directRenderingType == DRI_XF86DRI) {
      DRILock(screenInfo.screens[pScrn->scrnIndex], 0);
d2837 1
a2837 5
      if (!pI830->memory_manager) {
	  I830DRISetVBlankInterrupt (pScrn, FALSE);
      }
   }
#endif
d2839 1
a2839 14
#ifndef HAVE_FREE_SHADOW
   for (o = 0; o < config->num_crtc; o++) {
       xf86CrtcPtr crtc = config->crtc[o];

       if (crtc->rotatedPixmap || crtc->rotatedData) {
	   crtc->funcs->shadow_destroy(crtc, crtc->rotatedPixmap,
				crtc->rotatedData);
	   crtc->rotatedPixmap = NULL;
	   crtc->rotatedData = NULL;
       }
   }
#else
   xf86RotateFreeShadow(pScrn);
#endif
d2841 1
a2841 1
   xf86_hide_cursors (pScrn);
d2843 1
a2843 1
   I830Sync(pScrn);
d2845 9
a2853 7
   if (!pI830->use_drm_mode) {
       RestoreHWState(pScrn);
       /* Evict everything from the bufmgr, as we're about to lose ownership of
	* the graphics memory.
	*/
       if (!pI830->memory_manager)
	   intel_bufmgr_fake_evict_all(pI830->bufmgr);
a2854 3
       if (!pI830->memory_manager) {
	   i830_stop_ring(pScrn, TRUE);
	   drmCtlUninstHandler(pI830->drmSubFD);
d2857 1
a2857 5
       if (pI830->debug_modes) {
	   i830CompareRegsToSnapshot(pScrn, "After LeaveVT");
	   i830DumpRegs (pScrn);
       }
   }
d2859 1
a2859 1
   intel_batch_teardown(pScrn);
d2861 2
a2862 1
   i830_unbind_all_memory(pScrn);
d2864 8
a2871 15
#ifdef XF86DRI
   if (pI830->memory_manager && !pI830->use_drm_mode) {
      int ret;

      /* Tell the kernel to evict all buffer objects and block GTT usage while
       * we're no longer in control of the chip.
       */
      ret = drmCommandNone(pI830->drmSubFD, DRM_I915_GEM_LEAVEVT);
      if (ret != 0)
	 FatalError("DRM_I915_LEAVEVT failed: %s\n", strerror(ret));
   }
#endif /* XF86DRI */

   if ((pI830->accel == ACCEL_EXA || pI830->accel == ACCEL_UXA) && IS_I965G(pI830))
      gen4_render_state_cleanup(pScrn);
d2873 2
a2874 2
   if (pI830->AccelInfoRec)
      pI830->AccelInfoRec->NeedToSync = FALSE;
d2876 4
a2879 8
#ifdef XF86DRI
#if 0
   ret = drmDropMaster(pI830->drmSubFD);
   if (ret)
      xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
		 "drmDropMaster failed: %s\n", strerror(ret));
#endif 
#endif
d2885 1
a2885 2
static Bool
I830EnterVT(int scrnIndex, int flags)
d2887 19
a2905 4
   ScrnInfoPtr pScrn = xf86Screens[scrnIndex];
   xf86CrtcConfigPtr xf86_config = XF86_CRTC_CONFIG_PTR(pScrn);
   I830Ptr  pI830 = I830PTR(pScrn);
   int i, ret;
d2907 9
a2915 1
   DPRINTF(PFX, "Enter VT\n");
d2917 2
a2918 8
#ifdef XF86DRI
#if 0
   ret = drmSetMaster(pI830->drmSubFD);
   if (ret)
      xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
		 "drmDropMaster failed: %s\n", strerror(ret));
#endif
#endif
d2920 1
a2920 9
   /*
    * Only save state once per server generation since that's what most
    * drivers do.  Could change this to save state at each VT enter.
    */
   if (pI830->SaveGeneration != serverGeneration) {
      pI830->SaveGeneration = serverGeneration;
      if (!pI830->use_drm_mode)
	  SaveHWState(pScrn);
   }
d2922 6
a2927 19
   /* Get the hardware into a known state if needed */
   if (!pI830->use_drm_mode) {
       /* Disable outputs */

       I830SwapPipes(pScrn);

       for (i = 0; i < xf86_config->num_output; i++) {
	   xf86OutputPtr   output = xf86_config->output[i];
	   output->funcs->dpms(output, DPMSModeOff);
       }
       i830WaitForVblank(pScrn);

       /* Disable pipes */
       for (i = 0; i < xf86_config->num_crtc; i++) {
	   xf86CrtcPtr crtc = xf86_config->crtc[i];
	   i830_crtc_disable(crtc, TRUE);
       }
       i830WaitForVblank(pScrn);
   }
d2929 7
a2935 8
   pI830->leaving = FALSE;

   if (!pI830->use_drm_mode)
       i830_disable_render_standby(pScrn);

#ifdef XF86DRI
   if (pI830->memory_manager && !pI830->use_drm_mode) {
      int ret;
d2937 1
a2937 8
      /* Tell the kernel that we're back in control and ready for GTT
       * usage.
       */
      ret = drmCommandNone(pI830->drmSubFD, DRM_I915_GEM_ENTERVT);
      if (ret != 0)
	 FatalError("DRM_I915_ENTERVT failed: %s\n", strerror(ret));
   }
#endif /* XF86DRI */
d2939 2
a2940 2
   if (!i830_bind_all_memory(pScrn))
      return FALSE;
d2942 2
a2943 1
   i830_describe_allocations(pScrn, 1, "");
d2945 8
a2952 2
   /* Update the screen pixmap in case the buffer moved */
   i830_update_front_offset(pScrn);
d2954 2
a2955 1
   intel_batch_init(pScrn);
d2957 1
a2957 28
   if ((pI830->accel == ACCEL_EXA || pI830->accel == ACCEL_UXA) &&
       IS_I965G(pI830))
      gen4_render_state_init(pScrn);

   if (!pI830->use_drm_mode) {
       if (i830_check_error_state(pScrn)) {
	   xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
		      "Existing errors found in hardware state.\n");
       }

       /* Re-set up the ring. */
       if (!pI830->memory_manager) {
	   i830_stop_ring(pScrn, FALSE);
	   i830_start_ring(pScrn);
       }
       I830InitHWCursor(pScrn);

       /* Tell the BIOS that we're in control of mode setting now. */
       i830_init_bios_control(pScrn);

       i830_init_clock_gating(pScrn);

       if (pI830->power_context)
	   OUTREG(PWRCTXA, pI830->power_context->offset | PWRCTX_EN);
       /* Clear the framebuffer */
       memset(pI830->FbBase + pScrn->fbOffset, 0,
	      pScrn->virtualY * pScrn->displayWidth * pI830->cpp);
   }
d2959 1
a2959 2
   if (!xf86SetDesiredModes (pScrn))
      return FALSE;
d2961 2
a2962 7
   if (!pI830->use_drm_mode) {
       if (pI830->debug_modes) {
	   xf86DrvMsg(pScrn->scrnIndex, X_INFO, "Hardware state at EnterVT:\n");
	   i830DumpRegs (pScrn);
       }
       i830DescribeOutputConfiguration(pScrn);
   }
d2964 7
a2970 17
#ifdef XF86DRI
   if (pI830->directRenderingType == DRI_XF86DRI) {
       /* HW status is fixed, we need to set it up before any drm
	* operation which accessing that page, like irq install, etc.
	*/
       if (pI830->starting && !pI830->memory_manager) {
	   if (pI830->hw_status != NULL && !I830DRISetHWS(pScrn)) {
		   xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
			   "Fail to setup hardware status page.\n");
		   I830DRICloseScreen(pScrn->pScreen);
		   return FALSE;
	   }
	   if (!pI830->memory_manager && !I830DRIInstIrqHandler(pScrn)) {
	       I830DRICloseScreen(pScrn->pScreen);
	       return FALSE;
	   }
       }
d2972 2
a2973 5
      /* Update buffer offsets in sarea and mappings, since buffer offsets
       * may have changed.
       */
      if (!i830_update_dri_buffers(pScrn))
	 FatalError("i830_update_dri_buffers() failed\n");
d2975 1
a2975 1
      I830DRISetVBlankInterrupt (pScrn, TRUE);
d2977 7
a2983 4
      if (!pI830->starting) {
         ScreenPtr pScreen = pScrn->pScreen;
         drmI830Sarea *sarea = (drmI830Sarea *) DRIGetSAREAPrivate(pScreen);
         int i;
d2985 2
a2986 1
	 I830DRIResume(screenInfo.screens[scrnIndex]);
d2988 3
a2990 3
	 if (!pI830->memory_manager)
	    i830_refresh_ring(pScrn);
	 I830Sync(pScrn);
d2992 7
a2998 3
	 sarea->texAge++;
	 for(i = 0; i < I830_NR_TEX_REGIONS+1 ; i++)
	    sarea->texList[i].age = sarea->texAge;
d3000 1
a3000 20
	 DPRINTF(PFX, "calling dri unlock\n");
	 DRIUnlock(screenInfo.screens[pScrn->scrnIndex]);
      }
      pI830->LockHeld = 0;
   }
#endif

   /* Set the hotkey to just notify us.  We could check its results
    * periodically and attempt to do something, but it seems like we basically
    * never get results when we should, and this should all be better handled
    * through ACPI putting the key events out through evdev and your desktop
    * environment picking it up.
    */
   i830SetHotkeyControl(pScrn, HOTKEY_DRIVER_NOTIFY);

   /* Mark 3D state as being clobbered and setup the basics */
   pI830->last_3d = LAST_3D_OTHER;
   IntelEmitInvarientState(pScrn);

   return TRUE;
d3003 1
a3003 2
static Bool
I830SwitchMode(int scrnIndex, DisplayModePtr mode, int flags)
d3005 1
a3005 2
   ScrnInfoPtr pScrn = xf86Screens[scrnIndex];
   I830Ptr pI830 = I830PTR(pScrn);
d3007 1
a3007 1
   return xf86SetSingleMode (pScrn, mode, pI830->rotation);
d3010 1
a3010 2
static Bool
I830CloseScreen(int scrnIndex, ScreenPtr pScreen)
d3012 2
a3013 5
   ScrnInfoPtr pScrn = xf86Screens[scrnIndex];
   I830Ptr pI830 = I830PTR(pScrn);
#ifdef I830_USE_XAA
   XAAInfoRecPtr infoPtr = pI830->AccelInfoRec;
#endif
d3015 1
a3015 1
   pI830->closing = TRUE;
d3017 3
a3019 3
   if (pScrn->vtSema == TRUE) {
      I830LeaveVT(scrnIndex, 0);
   }
d3021 9
a3029 9
   if (pI830->devicesTimer)
      TimerFree(pI830->devicesTimer);
   pI830->devicesTimer = NULL;

   if (!pI830->use_drm_mode) {
       DPRINTF(PFX, "\nUnmapping memory\n");
       I830UnmapMem(pScrn);
       vgaHWUnmapMem(pScrn);
   }
d3031 12
a3042 27
   if (pI830->ScanlineColorExpandBuffers) {
      xfree(pI830->ScanlineColorExpandBuffers);
      pI830->ScanlineColorExpandBuffers = NULL;
   }
#ifdef I830_USE_XAA
   if (infoPtr) {
      if (infoPtr->ScanlineColorExpandBuffers)
	 xfree(infoPtr->ScanlineColorExpandBuffers);
      XAADestroyInfoRec(infoPtr);
      pI830->AccelInfoRec = NULL;
   }
#endif
#ifdef I830_USE_EXA
   if (pI830->EXADriverPtr) {
       exaDriverFini(pScreen);
       xfree(pI830->EXADriverPtr);
       pI830->EXADriverPtr = NULL;
   }
#endif
#ifdef I830_USE_UXA
   if (pI830->uxa_driver) {
       uxa_driver_fini (pScreen);
       xfree (pI830->uxa_driver);
       pI830->uxa_driver = NULL;
   }
#endif
   xf86_cursors_fini (pScreen);
d3044 1
a3044 1
   i830_allocator_fini(pScrn);
d3046 1
a3046 3
#ifdef I830_XV
   i965_free_video(pScrn);
#endif
d3048 3
a3050 2
   dri_bufmgr_destroy(pI830->bufmgr);
   pI830->bufmgr = NULL;
d3052 2
a3053 7
#ifdef XF86DRI
   if (pI830->directRenderingOpen &&
       pI830->directRenderingType == DRI_XF86DRI) {
      pI830->directRenderingOpen = FALSE;
      I830DRICloseScreen(pScreen);
   }
#endif
d3055 5
a3059 6
#ifdef DRI2
   if (pI830->directRenderingOpen && pI830->directRenderingType == DRI_DRI2) {
      pI830->directRenderingOpen = FALSE;
      I830DRI2CloseScreen(pScreen);
   }
#endif
d3061 1
a3061 1
   xf86GARTCloseScreen(scrnIndex);
d3063 3
a3065 5
   pScrn->PointerMoved = pI830->PointerMoved;
   pScrn->vtSema = FALSE;
   pI830->closing = FALSE;
   pScreen->CloseScreen = pI830->CloseScreen;
   return (*pScreen->CloseScreen) (scrnIndex, pScreen);
d3071 9
a3079 8
   if (mode->Flags & V_INTERLACE) {
      if (verbose) {
	 xf86DrvMsg(scrnIndex, X_PROBED,
		    "Removing interlaced mode \"%s\"\n", mode->name);
      }
      return MODE_BAD;
   }
   return MODE_OK;
d3094 1
a3094 2
static Bool
I830PMEvent(int scrnIndex, pmEvent event, Bool undo)
d3096 2
a3097 2
   ScrnInfoPtr pScrn = xf86Screens[scrnIndex];
   I830Ptr pI830 = I830PTR(pScrn);
d3099 2
a3100 50
   DPRINTF(PFX, "Enter VT, event %d, undo: %s\n", event, BOOLTOSTRING(undo));
 
   switch(event) {
   case XF86_APM_SYS_SUSPEND:
   case XF86_APM_CRITICAL_SUSPEND: /*do we want to delay a critical suspend?*/
   case XF86_APM_USER_SUSPEND:
   case XF86_APM_SYS_STANDBY:
   case XF86_APM_USER_STANDBY:
      if (!undo && !pI830->suspended) {
	 pScrn->LeaveVT(scrnIndex, 0);
	 pI830->suspended = TRUE;
	 sleep(SUSPEND_SLEEP);
      } else if (undo && pI830->suspended) {
	 sleep(RESUME_SLEEP);
	 pScrn->EnterVT(scrnIndex, 0);
	 pI830->suspended = FALSE;
      }
      break;
   case XF86_APM_STANDBY_RESUME:
   case XF86_APM_NORMAL_RESUME:
   case XF86_APM_CRITICAL_RESUME:
      if (pI830->suspended) {
	 sleep(RESUME_SLEEP);
	 pScrn->EnterVT(scrnIndex, 0);
	 pI830->suspended = FALSE;
	 /*
	  * Turn the screen saver off when resuming.  This seems to be
	  * needed to stop xscreensaver kicking in (when used).
	  *
	  * XXX DoApmEvent() should probably call this just like
	  * xf86VTSwitch() does.  Maybe do it here only in 4.2
	  * compatibility mode.
	  */
	 SaveScreens(SCREEN_SAVER_FORCER, ScreenSaverReset);
      }
      break;
   /* This is currently used for ACPI */
   case XF86_APM_CAPABILITY_CHANGED:
      ErrorF("I830PMEvent: Capability change\n");

      SaveScreens(SCREEN_SAVER_FORCER, ScreenSaverReset);
      if (pI830->quirk_flag & QUIRK_RESET_MODES)
	 xf86SetDesiredModes(pScrn);

      break;
   default:
      ErrorF("I830PMEvent: received APM event %d\n", event);
   }
   return TRUE;
}
d3102 41
a3142 9
xf86CrtcPtr
i830_pipe_to_crtc(ScrnInfoPtr pScrn, int pipe)
{
   xf86CrtcConfigPtr config = XF86_CRTC_CONFIG_PTR (pScrn);
   int c;
   
   for (c = 0; c < config->num_crtc; c++) {
      xf86CrtcPtr crtc = config->crtc[c];
      I830CrtcPrivatePtr intel_crtc = crtc->driver_private;
d3144 5
a3148 40
      if (intel_crtc->pipe == pipe)
	  return crtc;
   }

   return NULL;
} 

#if 0
/**
 * This function is used for testing of the screen detect functions from the
 * periodic timer.
 */
static void
i830MonitorDetectDebugger(ScrnInfoPtr pScrn)
{
   Bool found_crt;
   I830Ptr pI830 = I830PTR(pScrn);
   int start, finish, i;

   if (!pScrn->vtSema)
      return 1000;

   for (i = 0; i < xf86_config->num_output; i++) {
      enum output_status ret;
      char *result;

      start = GetTimeInMillis();
      ret = pI830->output[i].detect(pScrn, &pI830->output[i]);
      finish = GetTimeInMillis();

      if (ret == OUTPUT_STATUS_CONNECTED)
	 result = "connected";
      else if (ret == OUTPUT_STATUS_DISCONNECTED)
	 result = "disconnected";
      else
	 result = "unknown";

      xf86DrvMsg(pScrn->scrnIndex, X_ERROR, "Detected SDVO as %s in %dms\n",
		 result, finish - start);
   }
a3149 1
#endif
d3151 1
a3151 2
void
i830WaitSync(ScrnInfoPtr pScrn)
d3153 2
a3154 1
   I830Ptr pI830 = I830PTR(pScrn);
d3156 3
a3158 29
   switch (pI830->accel) {
#ifdef I830_USE_XAA
   case ACCEL_XAA:
      if (pI830->AccelInfoRec && pI830->AccelInfoRec->NeedToSync) {
	 (*pI830->AccelInfoRec->Sync)(pScrn);
	 pI830->AccelInfoRec->NeedToSync = FALSE;
      }
      break;
#endif
#ifdef I830_USE_EXA
   case ACCEL_EXA:
      if (pI830->EXADriverPtr) {
	 ScreenPtr pScreen = screenInfo.screens[pScrn->scrnIndex];
	 exaWaitSync(pScreen);
      }
      break;
#endif
#ifdef I830_USE_UXA
   case ACCEL_UXA:
      if (pI830->uxa_driver && pI830->need_sync) {
	 pI830->need_sync = FALSE;
	 I830Sync(pScrn);
      }
      break;
#endif
   default:
      break;
   }
}
d3160 3
a3162 4
void
i830MarkSync(ScrnInfoPtr pScrn)
{
   I830Ptr pI830 = I830PTR(pScrn);
d3164 1
a3164 24
   switch (pI830->accel) {
#ifdef I830_USE_XAA
   case ACCEL_XAA:
      if (pI830->AccelInfoRec)
	 pI830->AccelInfoRec->NeedToSync = TRUE;
      break;
#endif
#ifdef I830_USE_EXA
   case ACCEL_EXA:
      if (pI830->EXADriverPtr) {
	 ScreenPtr pScreen = screenInfo.screens[pScrn->scrnIndex];
	 exaMarkSync(pScreen);
      }
      break;
#endif
#ifdef I830_USE_UXA
   case ACCEL_UXA:
      if (pI830->uxa_driver)
	 pI830->need_sync = TRUE;
      break;
#endif
   default:
      break;
   }
d3167 1
a3167 2
void
I830InitpScrn(ScrnInfoPtr pScrn)
d3169 9
a3177 9
   pScrn->PreInit = I830PreInit;
   pScrn->ScreenInit = I830ScreenInit;
   pScrn->SwitchMode = I830SwitchMode;
   pScrn->AdjustFrame = i830AdjustFrame;
   pScrn->EnterVT = I830EnterVT;
   pScrn->LeaveVT = I830LeaveVT;
   pScrn->FreeScreen = I830FreeScreen;
   pScrn->ValidMode = I830ValidMode;
   pScrn->PMEvent = I830PMEvent;
@


1.15
log
@backport a bugfix from upstream:

	Fix 945GM VT switch in UMS

	Bug #19578. We should set private intel_crtc state according to
	current, as fail to do so pipe A needs active won't be taken
	care of. Also make sure pipe swap operation always set during VT
	switch.

This also fixes the *other* x40 lid problem (which happens when you suspend,
then you shut the lid in dont'-suspend-on-lid mode.

the reasoning for the PipeA quirk I finally found:

	On some platforms, the firmware may read & write GPU registers
	on lid close, suspend/resume time or during various SMM events.
	If one of the graphics pipes is disabled at that time, the GPU
	may hang due to the programming dependencies of the various
	registers.

So essentially, without this patch, if you have this quirk and you shut
the lid, you're hosed, but y'know drivers in userland are great. So are
BIOS writers.

requested by deraadt@@, who keeps getting this issue when he's on a plane.
@
text
@a3402 1
	  drmCtlUninstHandler(pI830->drmSubFD);
d3434 1
a3434 1
       if (!pI830->memory_manager)
d3436 2
@


1.14
log
@update to xf86-video-intel 2.7.1. Tested by many.
@
text
@a3158 3

   if (!pI830->use_drm_mode)
       I830SwapPipes(pScrn);
d3512 3
@


1.13
log
@xf86-video-intel 2.4.3. Tested by many.
@
text
@d180 1
a193 1
#include "vbe.h"
d212 1
a212 2
#ifdef XF86DRI_MM
#include "xf86mm.h"
d214 3
d247 2
d262 1
d277 2
d292 1
a302 1
#if defined(I830_USE_XAA) && defined(I830_USE_EXA)
a303 1
#endif
a304 1
   OPTION_SW_CURSOR,
a306 2
   OPTION_PAGEFLIP,
   OPTION_XVIDEO,
a308 1
   OPTION_CHECKDEVICES,
d310 1
a313 3
#ifdef XF86DRI_MM
   OPTION_INTELTEXPOOL,
#endif
a314 1
   OPTION_TRIPLEBUFFER,
d319 1
a322 1
#if defined(I830_USE_XAA) && defined(I830_USE_EXA)
a323 1
#endif
a324 1
   {OPTION_SW_CURSOR,	"SWcursor",	OPTV_BOOLEAN,	{0},	FALSE},
a326 2
   {OPTION_PAGEFLIP,	"PageFlip",	OPTV_BOOLEAN,	{0},	FALSE},
   {OPTION_XVIDEO,	"XVideo",	OPTV_BOOLEAN,	{0},	TRUE},
a328 1
   {OPTION_CHECKDEVICES, "CheckDevices",OPTV_BOOLEAN,	{0},	FALSE},
d330 1
a333 3
#ifdef XF86DRI_MM
   {OPTION_INTELTEXPOOL,"Legacy3D",     OPTV_BOOLEAN,	{0},	FALSE},
#endif
a334 1
   {OPTION_TRIPLEBUFFER, "TripleBuffer", OPTV_BOOLEAN,	{0},	FALSE},
d339 1
a355 1
static CARD32 I830CheckDevicesTimer(OsTimerPtr timer, CARD32 now, pointer arg);
a425 11
static void
I830ProbeDDC(ScrnInfoPtr pScrn, int index)
{
   vbeInfoPtr pVbe;

   /* The vbe module gets loaded in PreInit(), so no need to load it here. */

   pVbe = VBEInit(NULL, index);
   ConfiguredMonitor = vbeDoEDID(pVbe, NULL);
}

a435 3
#if 0
   VbeInfoBlock *vbeInfo;
#endif
d498 1
a498 1
   if (IS_G4X(pI830) || IS_GM45(pI830))
d633 1
a633 1
	 if (IS_GM45(pI830) || IS_G4X(pI830)) {
d706 2
a707 3
   if (I830IsPrimary(pScrn) && pI830->LpRing->mem != NULL) {
      pI830->LpRing->virtual_start =
	 pI830->FbBase + pI830->LpRing->mem->offset;
d820 1
a820 1
static void
d825 2
d833 3
d839 21
a859 5
   if (!pI830->starting) {
      if (!pScreen->ModifyPixmapHeader(pScreen->GetScreenPixmap(pScreen),
				       -1, -1, -1, -1, -1,
				       (pointer)(pI830->FbBase +
						 pScrn->fbOffset)))
a860 1
   }
d881 4
d927 3
a929 2
      if (INREG(SDVOB) & SDVO_DETECTED) {
	 Bool found = i830_sdvo_init(pScrn, SDVOB);
d935 6
a940 2
      if (INREG(SDVOC) & SDVO_DETECTED) {
	 Bool found = i830_sdvo_init(pScrn, SDVOC);
a941 3
	 if (!found && SUPPORTS_INTEGRATED_HDMI(pI830))
	    i830_hdmi_init(pScrn, SDVOC);
      }
d978 2
a979 1
    if (IS_GM45(pI830) || IS_G4X(pI830)) {
d981 3
a983 1
	OUTREG(RENCLK_GATE_D2, 0);
d985 6
a990 3
	OUTREG(DSPCLK_GATE_D, VRHUNIT_CLOCK_GATE_DISABLE |
	       OVRUNIT_CLOCK_GATE_DISABLE |
	       OVCUNIT_CLOCK_GATE_DISABLE);
a1074 7
   if (I830IsPrimary(pScrn)) {
      if (pI830->entityPrivate)
	 pI830->entityPrivate->pScrn_1 = NULL;
   } else {
      if (pI830->entityPrivate)
         pI830->entityPrivate->pScrn_2 = NULL;
   }
d1080 3
d1084 1
a1084 1
I830IsPrimary(ScrnInfoPtr pScrn)
d1086 23
a1108 1
   I830Ptr pI830 = I830PTR(pScrn);
d1110 11
a1120 4
   if (xf86IsEntityShared(pScrn->entityList[0])) {
	if (pI830->init == 0) return TRUE;
	else return FALSE;
   }
d1122 7
a1128 1
   return TRUE;
d1134 10
d1146 36
d1206 4
d1218 35
d1262 5
d1323 6
d1368 3
d1403 13
d1494 304
a1807 1
   xf86CrtcConfigPtr   xf86_config;
a1809 1
   MessageType from = X_PROBED;
a1811 1
   I830EntPtr pI830Ent = NULL;					
d1813 2
a1814 5
   int i;
   char *s;
   pointer pVBEModule = NULL;
   int num_pipe;
   int max_width, max_height;
d1819 1
a1819 9
   /* Load int10 module */
   if (!xf86LoadSubModule(pScrn, "int10"))
      return FALSE;
   xf86LoaderReqSymLists(I810int10Symbols, NULL);

   /* Load vbe module */
   if (!(pVBEModule = xf86LoadSubModule(pScrn, "vbe")))
      return FALSE;
   xf86LoaderReqSymLists(I810vbeSymbols, NULL);
d1823 2
a1824 13
   if (flags & PROBE_DETECT) {
      I830ProbeDDC(pScrn, pEnt->index);
      return TRUE;
   }

   /* The vgahw module should be loaded here when needed */
   if (!xf86LoadSubModule(pScrn, "vgahw"))
      return FALSE;
   xf86LoaderReqSymLists(I810vgahwSymbols, NULL);

   /* Allocate a vgaHWRec */
   if (!vgaHWGetHWRec(pScrn))
      return FALSE;
d1833 12
a1856 8
    /* Allocate an entity private if necessary */
    if (xf86IsEntityShared(pScrn->entityList[0])) {
	pI830Ent = xf86GetEntityPrivate(pScrn->entityList[0],
					I830EntityIndex)->ptr;
        pI830->entityPrivate = pI830Ent;
    } else 
        pI830->entityPrivate = NULL;

a1861 24
   if (xf86IsEntityShared(pScrn->entityList[0])) {
      if (xf86IsPrimInitDone(pScrn->entityList[0])) {
	 pI830->init = 1;

         if (!pI830Ent->pScrn_1) {
            xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
 		 "Failed to setup second head due to primary head failure.\n");
	    return FALSE;
         }
      } else {
         xf86SetPrimInitDone(pScrn->entityList[0]);
	 pI830->init = 0;
      }
   }

   if (xf86IsEntityShared(pScrn->entityList[0])) {
      if (!I830IsPrimary(pScrn)) {
         pI830Ent->pScrn_2 = pScrn;
      } else {
         pI830Ent->pScrn_1 = pScrn;
         pI830Ent->pScrn_2 = NULL;
      }
   }

d1891 3
a1893 1
   hwp = VGAHWPTR(pScrn);
d1898 2
a1899 30
   /* Process the options */
   xf86CollectOptions(pScrn, NULL);
   if (!(pI830->Options = xalloc(sizeof(I830Options))))
      return FALSE;
   memcpy(pI830->Options, I830Options, sizeof(I830Options));
   xf86ProcessOptions(pScrn->scrnIndex, pScrn->options, pI830->Options);

   if (xf86ReturnOptValBool(pI830->Options, OPTION_MODEDEBUG, FALSE)) {
      pI830->debug_modes = TRUE;
   } else {
      pI830->debug_modes = FALSE;
   }

   if (xf86ReturnOptValBool(pI830->Options, OPTION_LVDS24BITMODE, FALSE)) {
      pI830->lvds_24_bit_mode = TRUE;
   } else {
      pI830->lvds_24_bit_mode = FALSE;
   }

   if (xf86ReturnOptValBool(pI830->Options, OPTION_LVDSFIXEDMODE, TRUE)) {
      pI830->skip_panel_detect = FALSE;
   } else {
      pI830->skip_panel_detect = TRUE;
   }

   if (xf86ReturnOptValBool(pI830->Options, OPTION_FORCEENABLEPIPEA, FALSE))
       pI830->quirk_flag |= QUIRK_PIPEA_FORCE;

   /* We have to use PIO to probe, because we haven't mapped yet. */
   I830SetPIOAccess(pI830);
a1903 118
   /* check quirks */
   i830_fixup_devices(pScrn);

   /* Allocate an xf86CrtcConfig */
   xf86CrtcConfigInit (pScrn, &i830_xf86crtc_config_funcs);
   xf86_config = XF86_CRTC_CONFIG_PTR(pScrn);

   /* See i830_exa.c comments for why we limit the framebuffer size like this.
    */
   if (IS_I965G(pI830)) {
      max_width = 8192;
      max_height = 8192;
   } else {
      max_width = 2048;
      max_height = 2048;
   }
   xf86CrtcSetSizeRange (pScrn, 320, 200, max_width, max_height);

   /* Some of the probing needs MMIO access, so map it here. */
   I830MapMMIO(pScrn);

   if (pI830->debug_modes) {
      xf86DrvMsg(pScrn->scrnIndex, X_INFO, "Hardware state on X startup:\n");
      i830DumpRegs (pScrn);
   }

   i830TakeRegSnapshot(pScrn);

   if (DEVICE_ID(pI830->PciInfo) == PCI_CHIP_E7221_G)
      num_pipe = 1;
   else
   if (IS_MOBILE(pI830) || IS_I9XX(pI830))
      num_pipe = 2;
   else
      num_pipe = 1;
   xf86DrvMsg(pScrn->scrnIndex, X_INFO, "%d display pipe%s available.\n",
	      num_pipe, num_pipe > 1 ? "s" : "");

   if (xf86ReturnOptValBool(pI830->Options, OPTION_NOACCEL, FALSE)) {
      pI830->noAccel = TRUE;
   }

   /*
    * The ugliness below:
    * If either XAA or EXA (exclusive) is compiled in, default to it.
    * 
    * If both are compiled in, and the user didn't specify noAccel, use the
    * config option AccelMethod to determine which to use, defaulting to EXA
    * if none is specified, or if the string was unrecognized.
    *
    * All this *could* go away if we removed XAA support from this driver,
    * for example. :)
    */
   if (!pI830->noAccel) {
#ifdef I830_USE_EXA
       pI830->useEXA = TRUE;
#else
       pI830->useEXA = FALSE;
#endif
#if defined(I830_USE_XAA) && defined(I830_USE_EXA)
       from = X_DEFAULT;
       if ((s = (char *)xf86GetOptValString(pI830->Options,
					    OPTION_ACCELMETHOD))) {
	   if (!xf86NameCmp(s, "EXA")) {
	       from = X_CONFIG;
	       pI830->useEXA = TRUE;
	   }
	   else if (!xf86NameCmp(s, "XAA")) {
	       from = X_CONFIG;
	       pI830->useEXA = FALSE;
	   }
       }
#endif
       xf86DrvMsg(pScrn->scrnIndex, from, "Using %s for acceleration\n",
		  pI830->useEXA ? "EXA" : "XAA");
   }

   if (xf86ReturnOptValBool(pI830->Options, OPTION_SW_CURSOR, FALSE)) {
      pI830->SWCursor = TRUE;
   }

   pI830->directRenderingDisabled =
	!xf86ReturnOptValBool(pI830->Options, OPTION_DRI, TRUE);

#ifdef XF86DRI
   if (!pI830->directRenderingDisabled) {
      if (pI830->noAccel || pI830->SWCursor) {
	 xf86DrvMsg(pScrn->scrnIndex, X_CONFIG, "DRI is disabled because it "
		    "needs HW cursor and 2D acceleration.\n");
	 pI830->directRenderingDisabled = TRUE;
      } else if (pScrn->depth != 16 && pScrn->depth != 24) {
	 xf86DrvMsg(pScrn->scrnIndex, X_CONFIG, "DRI is disabled because it "
		    "runs only at depths 16 and 24.\n");
	 pI830->directRenderingDisabled = TRUE;
      }

      if (!pI830->directRenderingDisabled) {
	 pI830->allocate_classic_textures = TRUE;

	 from = X_PROBED;

#ifdef XF86DRI_MM
	 if (!IS_I965G(pI830)) {
	    Bool tmp;

	    if (xf86GetOptValBool(pI830->Options,
				  OPTION_INTELTEXPOOL, &tmp)) {
	       from = X_CONFIG;
	       if (!tmp)
		  pI830->allocate_classic_textures = FALSE;
	    }
	 }
#endif
      }
   } 
   
#endif

d1905 2
a1906 8
      xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
		 "VBIOS initialization failed.\n");

   I830PreInitDDC(pScrn);
   for (i = 0; i < num_pipe; i++) {
       i830_crtc_init(pScrn, i);
   }
   I830SetupOutputs(pScrn);
d1908 3
a1910 46
   SaveHWState(pScrn);
   if (!xf86InitialConfiguration (pScrn, FALSE))
   {
      xf86DrvMsg(pScrn->scrnIndex, X_ERROR, "No valid modes.\n");
      RestoreHWState(pScrn);
      PreInitCleanup(pScrn);
      return FALSE;
   }
   RestoreHWState(pScrn);

   /* XXX This should go away, replaced by xf86Crtc.c support for it */
   pI830->rotation = RR_Rotate_0;

   /*
    * Let's setup the mobile systems to check the lid status
    */
   if (IS_MOBILE(pI830)) {
      pI830->checkDevices = TRUE;

      if (!xf86ReturnOptValBool(pI830->Options, OPTION_CHECKDEVICES, TRUE)) {
         pI830->checkDevices = FALSE;
         xf86DrvMsg(pScrn->scrnIndex, X_INFO, "Monitoring connected displays disabled\n");
      } else
      if (pI830->entityPrivate && !I830IsPrimary(pScrn) &&
          !I830PTR(pI830->entityPrivate->pScrn_1)->checkDevices) {
         /* If checklid is off, on the primary head, then 
          * turn it off on the secondary*/
         xf86DrvMsg(pScrn->scrnIndex, X_INFO, "Monitoring connected displays disabled\n");
         pI830->checkDevices = FALSE;
      } else
         xf86DrvMsg(pScrn->scrnIndex, X_INFO, "Monitoring connected displays enabled\n");
   } else
      pI830->checkDevices = FALSE;

   pI830->stolen_size = I830DetectMemory(pScrn);

   pI830->XvDisabled =
	!xf86ReturnOptValBool(pI830->Options, OPTION_XVIDEO, TRUE);

#ifdef I830_XV
   if (xf86GetOptValInteger(pI830->Options, OPTION_VIDEO_KEY,
			    &(pI830->colorKey))) {
      from = X_CONFIG;
   } else if (xf86GetOptValInteger(pI830->Options, OPTION_COLOR_KEY,
			    &(pI830->colorKey))) {
      from = X_CONFIG;
d1912 3
a1914 5
      pI830->colorKey = (1 << pScrn->offset.red) |
			(1 << pScrn->offset.green) |
			(((pScrn->mask.blue >> pScrn->offset.blue) - 1) <<
			 pScrn->offset.blue);
      from = X_DEFAULT;
a1915 3
   xf86DrvMsg(pScrn->scrnIndex, from, "video overlay key set to 0x%x\n",
	      pI830->colorKey);
#endif
d1917 1
a1917 5
#ifdef XF86DRI
   pI830->allowPageFlip = FALSE;
   from = (!pI830->directRenderingDisabled &&
	   xf86GetOptValBool(pI830->Options, OPTION_PAGEFLIP,
			     &pI830->allowPageFlip)) ? X_CONFIG : X_DEFAULT;
d1919 3
a1921 61
   xf86DrvMsg(pScrn->scrnIndex, from, "Will%s try to enable page flipping\n",
	      pI830->allowPageFlip ? "" : " not");
#endif

#ifdef XF86DRI
   pI830->TripleBuffer = FALSE;
   from =  (!pI830->directRenderingDisabled &&
	    xf86GetOptValBool(pI830->Options, OPTION_TRIPLEBUFFER,
			      &pI830->TripleBuffer)) ? X_CONFIG : X_DEFAULT;

   xf86DrvMsg(pScrn->scrnIndex, from, "Triple buffering %sabled\n",
	      pI830->TripleBuffer ? "en" : "dis");
#endif

#ifdef INTEL_XVMC
   pI830->XvMCEnabled = FALSE;
   from =  (!pI830->directRenderingDisabled &&
	    xf86GetOptValBool(pI830->Options, OPTION_XVMC,
			      &pI830->XvMCEnabled)) ? X_CONFIG : X_DEFAULT;
   xf86DrvMsg(pScrn->scrnIndex, from, "Intel XvMC decoder %sabled\n",
	   pI830->XvMCEnabled ? "en" : "dis");
#endif

   /*
    * If the driver can do gamma correction, it should call xf86SetGamma() here.
    */

   {
      Gamma zeros = { 0.0, 0.0, 0.0 };

      if (!xf86SetGamma(pScrn, zeros)) {
         PreInitCleanup(pScrn);
	 return FALSE;
      }
   }

   /* Check if the HW cursor needs physical address. */
   if (IS_MOBILE(pI830) || IS_I9XX(pI830))
      pI830->CursorNeedsPhysical = TRUE;
   else
      pI830->CursorNeedsPhysical = FALSE;

   if (IS_I965G(pI830) || IS_G33CLASS(pI830))
      pI830->CursorNeedsPhysical = FALSE;

   /*
    * XXX If we knew the pre-initialised GTT format for certain, we could
    * probably figure out the physical address even in the StolenOnly case.
    */
   if (!I830IsPrimary(pScrn)) {
        I830Ptr pI8301 = I830PTR(pI830->entityPrivate->pScrn_1);
	if (!pI8301->SWCursor) {
          xf86DrvMsg(pScrn->scrnIndex, X_PROBED,
		 "Using HW Cursor because it's enabled on primary head.\n");
          pI830->SWCursor = FALSE;
        }
   } else 
   if (pI830->StolenOnly && pI830->CursorNeedsPhysical && !pI830->SWCursor) {
      xf86DrvMsg(pScrn->scrnIndex, X_PROBED,
		 "HW Cursor disabled because it needs agpgart memory.\n");
      pI830->SWCursor = TRUE;
d1933 1
a1933 1
      pI830->noAccel = TRUE;
d1947 1
d1949 1
a1949 1
   if (!pI830->noAccel && !pI830->useEXA) {
d1955 1
a1955 1
   }
d1959 1
a1959 1
   if (!pI830->noAccel && pI830->useEXA) {
d1977 1
d1980 2
a1981 6
   if (!pI830->SWCursor) {
      if (!xf86LoadSubModule(pScrn, "ramdac")) {
	 PreInitCleanup(pScrn);
	 return FALSE;
      }
      xf86LoaderReqSymLists(I810ramdacSymbols, NULL);
d1984 2
a1985 3
   i830CompareRegsToSnapshot(pScrn, "After PreInit");

   I830UnmapMMIO(pScrn);
d1987 1
a1987 4
   /*  We won't be using the VGA access after the probe. */
   I830SetMMIOAccess(pI830);
   xf86SetOperatingState(resVgaIo, pI830->pEnt->index, ResUnusedOpr);
   xf86SetOperatingState(resVgaMem, pI830->pEnt->index, ResDisableOpr);
d1989 4
a1992 3
#if 0
   if (I830IsPrimary(pScrn)) {
      vbeFree(pI830->pVbe);
a1993 2
   pI830->pVbe = NULL;
#endif
d1998 1
a1998 1
       !pI830->directRenderingDisabled) {
d2005 8
a2031 5
   if (!I830IsPrimary(pScrn)) return;

   if (pI830->entityPrivate)
      pI830->entityPrivate->RingRunning = 0;

d2033 1
a2033 1
   if (!pI830->noAccel) {
d2037 1
a2037 1
	 I830Sync(pScrn);
d2055 1
a2055 1
   if (pI830->noAccel)
a2057 5
   if (!I830IsPrimary(pScrn)) return;

   if (pI830->entityPrivate)
      pI830->entityPrivate->RingRunning = 1;

d2062 2
a2063 2
   assert((pI830->LpRing->mem->offset & I830_RING_START_MASK) ==
	   pI830->LpRing->mem->offset);
d2066 1
a2066 1
   itemp = pI830->LpRing->mem->offset;
d2069 2
a2070 2
   if (((pI830->LpRing->mem->size - 4096) & I830_RING_NR_PAGES) !=
       pI830->LpRing->mem->size - 4096) {
d2073 1
a2073 1
		 "mask (%x)\n", pI830->LpRing->mem->size - 4096,
d2077 1
a2077 1
   itemp = (pI830->LpRing->mem->size - 4096) & I830_RING_NR_PAGES;
d2091 1
a2091 1
   if (pI830->LpRing->mem == NULL)
d2094 5
a2098 5
   pI830->LpRing->head = INREG(LP_RING + RING_HEAD) & I830_HEAD_MASK;
   pI830->LpRing->tail = INREG(LP_RING + RING_TAIL);
   pI830->LpRing->space = pI830->LpRing->head - (pI830->LpRing->tail + 8);
   if (pI830->LpRing->space < 0)
      pI830->LpRing->space += pI830->LpRing->mem->size;
d2300 1
a2300 1
      crtc->funcs->dpms(crtc, DPMSModeOff);
d2343 1
d2345 1
d2351 1
d2357 1
d2381 1
d2394 1
d2401 1
d2411 1
d2413 1
d2419 1
d2425 1
d2448 1
a2512 4
   /* Clear any FIFO underrun status that may have occurred normally */
   OUTREG(PIPEASTAT, INREG(PIPEASTAT) | FIFO_UNDERRUN);
   OUTREG(PIPEBSTAT, INREG(PIPEBSTAT) | FIFO_UNDERRUN);

a2596 1
   uint32_t ctx_addr;
d2598 1
a2598 1
   if (pI830->noAccel)
d2602 1
a2602 1
   if (pI830->directRenderingEnabled) {
d2614 1
a2614 1
   if (*pI830->last_3d != LAST_3D_OTHER)
a2616 11
   ctx_addr = pI830->logical_context->offset;
   assert((pI830->logical_context->offset & 2047) == 0);
   {
      BEGIN_BATCH(2);
      OUT_BATCH(MI_SET_CONTEXT);
      OUT_BATCH(pI830->logical_context->offset |
		CTXT_NO_RESTORE |
		CTXT_PALETTE_SAVE_DISABLE | CTXT_PALETTE_RESTORE_DISABLE);
      ADVANCE_BATCH();
   }

a2632 1
    xf86CrtcConfigPtr xf86_config = XF86_CRTC_CONFIG_PTR(pScrn);
d2641 20
a2660 8
    /* Emit a flush of the rendering cache, or on the 965 and beyond
     * rendering results may not hit the framebuffer until significantly
     * later.  In the direct rendering case this is already done just
     * after the page flipping updates, so there's no need to duplicate
     * the effort here.
     */
    if (pScrn->vtSema && !pI830->noAccel && !pI830->directRenderingEnabled)
	I830EmitFlush(pScrn);
d2662 1
a2662 19
    /*
     * Check for FIFO underruns at block time (which amounts to just
     * periodically).  If this happens, it means our DSPARB or some other
     * memory arbitration setting is wrong for the current configuration
     * (except for mode setting, where it may occur naturally).
     * Check & ack the condition.
     */
    if (pScrn->vtSema && !DSPARB_HWCONTROL(pI830)) {
	if (xf86_config->crtc[0]->enabled &&
		(INREG(PIPEASTAT) & FIFO_UNDERRUN)) {
	    xf86DrvMsg(pScrn->scrnIndex, X_ERROR, "underrun on pipe A!\n");
	    OUTREG(PIPEASTAT, INREG(PIPEASTAT) | FIFO_UNDERRUN);
	}
	if (xf86_config->num_crtc > 1 &&
		xf86_config->crtc[1]->enabled &&
		(INREG(PIPEBSTAT) & FIFO_UNDERRUN)) {
	    xf86DrvMsg(pScrn->scrnIndex, X_ERROR, "underrun on pipe B!\n");
	    OUTREG(PIPEBSTAT, INREG(PIPEBSTAT) | FIFO_UNDERRUN);
	}
d2665 5
d2722 1
a2722 1
    Bool dri = pI830->directRenderingEnabled;
d2735 1
a2735 1
    if (dri && !i830_allocate_3d_memory(pScrn))
a2746 1

a2760 1
    int i;
d2763 1
a2763 30
    /*
     * Adjust the display width to allow for front buffer tiling if possible
     */
    if (pI830->tiling) {
	if (IS_I965G(pI830)) {
	    int tile_pixels = 512 / pI830->cpp;
	    pScrn->displayWidth = (pScrn->displayWidth + tile_pixels - 1) &
		~(tile_pixels - 1);
	    tiled = TRUE;
	} else {
	    /* Good pitches to allow tiling.  Don't care about pitches < 1024
	     * pixels.
	     */
	    static const int pitches[] = {
		1024,
		2048,
		4096,
		8192,
		0
	    };

	    for (i = 0; pitches[i] != 0; i++) {
		if (pitches[i] >= pScrn->displayWidth) {
		    pScrn->displayWidth = pitches[i];
		    tiled = TRUE;
		    break;
		}
	    }
	}
    }
d2794 1
a2794 1
    /* If tiling fails we have to disable page flipping & FBC */
a2795 5
    if (pI830->allowPageFlip)
	xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
		"Couldn't allocate tiled memory, page flipping "
		"disabled\n");
    pI830->allowPageFlip = FALSE;
d2803 1
a2803 1
    if (pI830->directRenderingEnabled) {
d2810 1
a2810 1
	    pI830->directRenderingEnabled = FALSE;
d2820 120
d2961 1
a2961 1
   vgaHWPtr hwp;
a2963 3
   I830Ptr pI8301 = NULL;
   unsigned long sys_mem;
   int c;
a2964 3
#ifdef XF86DRI
   xf86CrtcConfigPtr config;
#endif
a2967 1
   hwp = VGAHWPTR(pScrn);
d2969 4
a2972 1
   pScrn->displayWidth = (pScrn->virtualX + 63) & ~63;
d3016 5
a3020 11
   /* Limit videoRam to how much we might be able to allocate from AGP */
   sys_mem = I830CheckAvailableMemory(pScrn);
   if (sys_mem == -1) {
      if (pScrn->videoRam > pI830->stolen_size / KB(1)) {
	 xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
		    "/dev/agpgart is either not available, or no memory "
		    "is available\nfor allocation.  "
		    "Using pre-allocated memory only.\n");
	 pScrn->videoRam = pI830->stolen_size / KB(1);
      }
      pI830->StolenOnly = TRUE;
d3022 1
a3022 11
      if (sys_mem + (pI830->stolen_size / 1024) < pScrn->videoRam) {
	 pScrn->videoRam = sys_mem + (pI830->stolen_size / 1024);
	 from = X_PROBED;
	 if (sys_mem + (pI830->stolen_size / 1024) <
	     pI830->pEnt->device->videoRam)
	 {
	    xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
		       "VideoRAM reduced to %d kByte "
		       "(limited to available sysmem)\n", pScrn->videoRam);
	 }
      }
d3025 4
a3028 24
   /* Limit video RAM to the actual aperture size */
   if (pScrn->videoRam > pI830->FbMapSize / 1024) {
      pScrn->videoRam = pI830->FbMapSize / 1024;
      if (pI830->FbMapSize / 1024 < pI830->pEnt->device->videoRam) {
	 xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
		    "VideoRam reduced to %d kByte (limited to aperture "
		    "size)\n",
		    pScrn->videoRam);
      }
   }

   /* Make sure it's on a page boundary */
   if (pScrn->videoRam & 3) {
      xf86DrvMsg(pScrn->scrnIndex, X_WARNING, "VideoRam reduced to %d KB "
		 "(page aligned - was %d KB)\n",
		 pScrn->videoRam & ~3, pScrn->videoRam);
      pScrn->videoRam &= ~3;
   }

   if (!IS_I965G(pI830) && pScrn->displayWidth > 2048) {
      xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
		 "Cannot support DRI with frame buffer width > 2048.\n");
      pI830->directRenderingDisabled = TRUE;
   }
d3034 2
a3035 6
   if (!pI830->directRenderingDisabled)
      pI830->directRenderingEnabled = I830DRIScreenInit(pScreen);
   else
      pI830->directRenderingEnabled = FALSE;
#else
   pI830->directRenderingEnabled = FALSE;
d3063 6
d3074 2
a3075 25
   if (I830IsPrimary(pScrn)) {
      /* Alloc our pointers for the primary head */
      if (!pI830->LpRing)
         pI830->LpRing = xcalloc(1, sizeof(I830RingBuffer));
      if (!pI830->overlayOn)
         pI830->overlayOn = xalloc(sizeof(Bool));
      if (!pI830->last_3d)
         pI830->last_3d = xalloc(sizeof(enum last_3d));
      if (!pI830->LpRing || !pI830->overlayOn || !pI830->last_3d) {
         xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
		 "Could not allocate primary data structures.\n");
         return FALSE;
      }
      *pI830->last_3d = LAST_3D_OTHER;
      *pI830->overlayOn = FALSE;
      if (pI830->entityPrivate)
         pI830->entityPrivate->XvInUse = -1;
   } else {
      /* Make our second head point to the first heads structures */
      pI8301 = I830PTR(pI830->entityPrivate->pScrn_1);
      pI830->LpRing = pI8301->LpRing;
      pI830->overlay_regs = pI8301->overlay_regs;
      pI830->overlayOn = pI8301->overlayOn;
      pI830->last_3d = pI8301->last_3d;
   }
d3082 1
a3082 1
    pI830->XvEnabled = !pI830->XvDisabled;
d3087 2
a3088 1
   I830MapMMIO(pScrn);
d3111 4
a3114 13
   pI830->XvEnabled = !pI830->XvDisabled;
   if (pI830->XvEnabled) {
      if (!I830IsPrimary(pScrn)) {
         if (!pI8301->XvEnabled || pI830->noAccel) {
            pI830->XvEnabled = FALSE;
	    xf86DrvMsg(pScrn->scrnIndex, X_PROBED, "Xv is disabled.\n");
         }
      } else
      if (pI830->noAccel || pI830->StolenOnly) {
	 xf86DrvMsg(pScrn->scrnIndex, X_PROBED, "Xv is disabled because it "
		    "needs 2D accel and AGPGART.\n");
	 pI830->XvEnabled = FALSE;
      }
d3120 2
a3121 2
   if (!pI830->noAccel) {
      if (pI830->LpRing->mem->size == 0) {
d3125 1
a3125 1
	   pI830->noAccel = TRUE;
d3129 5
a3133 13
#ifdef I830_XV
   if (pI830->XvEnabled) {
      if (pI830->noAccel) {
	 xf86DrvMsg(pScrn->scrnIndex, X_WARNING, "Disabling Xv because it "
		    "needs 2D acceleration.\n");
	 pI830->XvEnabled = FALSE;
      }
      if (!OVERLAY_NOEXIST(pI830) && pI830->overlay_regs == NULL) {
	  xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
		     "Disabling Xv because the overlay register buffer "
		      "allocation failed.\n");
	 pI830->XvEnabled = FALSE;
      }
d3135 1
a3135 1
#endif
d3143 2
a3144 3

   if (pI830->directRenderingEnabled) {
      if (pI830->noAccel || pI830->SWCursor || (pI830->StolenOnly && I830IsPrimary(pScrn))) {
d3146 2
a3147 2
		    "needs HW cursor, 2D accel and AGPGART.\n");
	 pI830->directRenderingEnabled = FALSE;
d3151 3
a3153 2
   if (pI830->directRenderingEnabled)
      pI830->directRenderingEnabled = I830DRIDoMappings(pScreen);
d3156 3
a3158 27
   if (!pI830->directRenderingEnabled)
      i830_free_3d_memory(pScrn);

   config = XF86_CRTC_CONFIG_PTR(pScrn);

   /*
    * If an LVDS display is present, swap the plane/pipe mappings so we can
    * use FBC on the builtin display.
    * Note: 965+ chips can compress either plane, so we leave the mapping
    *       alone in that case.
    * Also make sure the DRM can handle the swap.
    */
   if (I830LVDSPresent(pScrn) && !IS_I965GM(pI830) && !IS_GM45(pI830) &&
       (!pI830->directRenderingEnabled ||
	(pI830->directRenderingEnabled && pI830->drmMinor >= 10))) {
       xf86DrvMsg(pScrn->scrnIndex, X_INFO, "adjusting plane->pipe mappings "
		  "to allow for framebuffer compression\n");
       for (c = 0; c < config->num_crtc; c++) {
	   xf86CrtcPtr	      crtc = config->crtc[c];
	   I830CrtcPrivatePtr   intel_crtc = crtc->driver_private;

	   if (intel_crtc->pipe == 0)
	       intel_crtc->plane = 1;
	   else if (intel_crtc->pipe == 1)
	       intel_crtc->plane = 0;
      }
   }
d3160 2
a3161 2
#else
   pI830->directRenderingEnabled = FALSE;
d3164 1
a3164 17
#ifdef XF86DRI

   xf86DrvMsg(pScrn->scrnIndex, X_INFO, "Page Flipping %sabled\n",
	      pI830->allowPageFlip ? "en" : "dis");
#endif

   DPRINTF(PFX, "assert( if(!I830MapMem(pScrn)) )\n");
   if (!I830MapMem(pScrn))
      return FALSE;

   pScrn->memPhysBase = (unsigned long)pI830->FbBase;

   if (I830IsPrimary(pScrn)) {
      pScrn->fbOffset = pI830->front_buffer->offset;
   } else {
      pScrn->fbOffset = pI8301->front_buffer_2->offset;
   }
d3169 7
a3175 7
   vgaHWSetMmioFuncs(hwp, pI830->MMIOBase, 0);
   vgaHWGetIOBase(hwp);
   DPRINTF(PFX, "assert( if(!vgaHWMapMem(pScrn)) )\n");
   if (!vgaHWMapMem(pScrn))
      return FALSE;

   i830_disable_render_standby(pScrn);
d3179 4
a3182 11
   if (!pI830->useEXA) {
      if (I830IsPrimary(pScrn)) {
	 if (!I830InitFBManager(pScreen, &(pI830->FbMemBox))) {
	    xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
		       "Failed to init memory manager\n");
	 }
      } else {
	 if (!I830InitFBManager(pScreen, &(pI8301->FbMemBox2))) {
	    xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
		       "Failed to init memory manager\n");
	 }
d3220 1
a3220 1
   if (!pI830->noAccel) {
d3227 7
d3239 4
a3242 7
   if (!pI830->SWCursor) {
      xf86DrvMsg(pScrn->scrnIndex, X_INFO, "Initializing HW Cursor\n");
      if (!I830CursorInit(pScreen))
	 xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
		    "Hardware cursor initialization failed\n");
   } else
      xf86DrvMsg(pScrn->scrnIndex, X_INFO, "Initializing SW Cursor!\n");
d3248 3
a3250 2
   if (pI830->directRenderingEnabled)
      pI830->directRenderingEnabled = I830DRIFinishScreenInit(pScreen);
d3286 8
d3302 8
a3309 2
#ifdef XF86DRI
   if (pI830->directRenderingEnabled) {
d3311 8
a3318 6
      xf86DrvMsg(pScrn->scrnIndex, X_INFO, "direct rendering: Enabled\n");
   } else {
      if (pI830->directRenderingDisabled)
	 xf86DrvMsg(pScrn->scrnIndex, X_INFO, "direct rendering: Disabled\n");
      else
	 xf86DrvMsg(pScrn->scrnIndex, X_INFO, "direct rendering: Failed\n");
d3351 3
d3383 1
d3394 1
a3394 1
      TimerCancel(pI830->devicesTimer);
a3398 7
   if (!I830IsPrimary(pScrn)) {
   	I830Ptr pI8301 = I830PTR(pI830->entityPrivate->pScrn_1);
	if (!pI8301->gtt_acquired) {
		return;
	}
   }

d3400 2
a3401 1
   if (pI830->directRenderingOpen) {
d3404 4
a3407 2
      I830DRISetVBlankInterrupt (pScrn, FALSE);
      drmCtlUninstHandler(pI830->drmSubFD);
d3428 9
a3436 1
   RestoreHWState(pScrn);
d3438 2
a3439 1
   i830_stop_ring(pScrn, TRUE);
d3441 4
a3444 3
   if (pI830->debug_modes) {
      i830CompareRegsToSnapshot(pScrn, "After LeaveVT");
      i830DumpRegs (pScrn);
d3447 7
a3453 2
   if (I830IsPrimary(pScrn))
      i830_unbind_all_memory(pScrn);
d3455 6
a3460 8
   /* Tell the kernel to evict all buffer objects and block new buffer
    * allocations until we relese the lock.
    */
#ifdef XF86DRI_MM
   if (pI830->directRenderingOpen) {
      if (pI830->memory_manager != NULL && pScrn->vtSema) {
	 drmMMLock(pI830->drmSubFD, DRM_BO_MEM_TT, 1, 0);
      }
d3462 1
a3462 1
#endif /* XF86DRI_MM */
d3464 1
a3464 1
   if (pI830->useEXA && IS_I965G(pI830))
d3469 9
d3487 1
d3489 1
d3493 9
d3508 19
a3526 1
      SaveHWState(pScrn);
d3531 9
a3539 4
#ifdef XF86DRI_MM
   if (pI830->directRenderingEnabled) {
      /* Unlock the memory manager first of all so that we can pin our
       * buffer objects
d3541 3
a3543 3
      if (pI830->memory_manager != NULL && pScrn->vtSema) {
	 drmMMUnlock(pI830->drmSubFD, DRM_BO_MEM_TT, 1);
      }
d3545 1
a3545 1
#endif /* XF86DRI_MM */
d3547 2
a3548 3
   if (I830IsPrimary(pScrn))
      if (!i830_bind_all_memory(pScrn))
         return FALSE;
d3555 4
a3558 1
   if (pI830->useEXA && IS_I965G(pI830))
d3561 5
a3565 4
   if (i830_check_error_state(pScrn)) {
      xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
		 "Existing errors found in hardware state.\n");
   }
d3567 6
a3572 4
   i830_stop_ring(pScrn, FALSE);
   i830_start_ring(pScrn);
   if (!pI830->SWCursor)
      I830InitHWCursor(pScrn);
d3574 2
a3575 2
   /* Tell the BIOS that we're in control of mode setting now. */
   i830_init_bios_control(pScrn);
d3577 1
a3577 1
   i830_init_clock_gating(pScrn);
d3579 6
a3584 6
   if (pI830->power_context)
       OUTREG(PWRCTXA, pI830->power_context->offset | PWRCTX_EN);

   /* Clear the framebuffer */
   memset(pI830->FbBase + pScrn->fbOffset, 0,
	  pScrn->virtualY * pScrn->displayWidth * pI830->cpp);
d3588 7
a3594 4
   
   if (pI830->debug_modes) {
      xf86DrvMsg(pScrn->scrnIndex, X_INFO, "Hardware state at EnterVT:\n");
      i830DumpRegs (pScrn);
a3595 1
   i830DescribeOutputConfiguration(pScrn);
d3598 1
a3598 1
   if (pI830->directRenderingEnabled) {
d3602 2
a3603 2
       if (pI830->starting) {
	   if (HWS_NEED_GFX(pI830) && !I830DRISetHWS(pScrn)) {
d3609 1
a3609 1
	   if (!I830DRIInstIrqHandler(pScrn)) {
d3630 2
a3631 1
	 i830_refresh_ring(pScrn);
d3645 5
a3649 4
   /* Set the hotkey to just notify us.  We can check its results periodically
    * in the CheckDevicesTimer.  Eventually we want the kernel to just hand us
    * an input event when someone presses the button, but for now we just have
    * to poll.
a3652 3
   if (pI830->checkDevices)
      pI830->devicesTimer = TimerSet(NULL, 0, 1000, I830CheckDevicesTimer, pScrn);

d3654 1
a3654 1
   *pI830->last_3d = LAST_3D_OTHER;
a3681 8
#ifdef XF86DRI_MM
      if (pI830->directRenderingEnabled) {
 	 if (pI830->memory_manager != NULL) {
	    drmMMUnlock(pI830->drmSubFD, DRM_BO_MEM_TT, 1);
	 }
      }
#endif /* XF86DRI_MM */

d3685 1
a3685 1
      TimerCancel(pI830->devicesTimer);
d3688 5
a3692 3
   DPRINTF(PFX, "\nUnmapping memory\n");
   I830UnmapMem(pScrn);
   vgaHWUnmapMem(pScrn);
d3707 1
a3707 1
   if (pI830->useEXA && pI830->EXADriverPtr) {
d3713 7
d3723 8
d3732 2
a3733 10
   if (pI830->directRenderingOpen) {
#ifdef DAMAGE
      if (pI830->pDamage) {
	 PixmapPtr pPix = pScreen->GetScreenPixmap(pScreen);

	 DamageUnregister(&pPix->drawable, pI830->pDamage);
	 DamageDestroy(pI830->pDamage);
	 pI830->pDamage = NULL;
      }
#endif
d3739 6
a3744 2
   if (I830IsPrimary(pScrn)) {
      xf86GARTCloseScreen(scrnIndex);
d3746 1
a3746 7
      xfree(pI830->LpRing);
      pI830->LpRing = NULL;
      xfree(pI830->overlayOn);
      pI830->overlayOn = NULL;
      xfree(pI830->last_3d);
      pI830->last_3d = NULL;
   }
a3823 12
#if 0
      /* If we had status checking turned on, turn it off now */
      if (pI830->checkDevices) {
         if (pI830->devicesTimer)
            TimerCancel(pI830->devicesTimer);
         pI830->devicesTimer = NULL;
         pI830->checkDevices = FALSE; 
      }
#endif
      if (!I830IsPrimary(pScrn))
         return TRUE;

a3825 1
      I830CheckDevicesTimer(NULL, 0, pScrn);
a3889 38
static CARD32
I830CheckDevicesTimer(OsTimerPtr timer, CARD32 now, pointer arg)
{
   ScrnInfoPtr pScrn = (ScrnInfoPtr) arg;
   I830Ptr pI830 = I830PTR(pScrn);
   uint8_t gr18;

   if (!pScrn->vtSema)
      return 1000;

#if 0
   i830MonitorDetectDebugger(pScrn);
#endif

   /* Check for a hotkey press report from the BIOS. */
   gr18 = pI830->readControl(pI830, GRX, 0x18);
   if ((gr18 & (HOTKEY_TOGGLE | HOTKEY_SWITCH)) != 0) {
      /* The user has pressed the hotkey requesting a toggle or switch.
       * Re-probe our connected displays and turn on whatever we find.
       *
       * In the future, we want the hotkey to dump down to a user app which
       * implements a sensible policy using RandR-1.2.  For now, all we get
       * is this.
       */
      
      xf86ProbeOutputModes (pScrn, 0, 0);
      xf86SetScrnInfoModes (pScrn);
      xf86DiDGAReInit (pScrn->pScreen);
      xf86SwitchMode(pScrn->pScreen, pScrn->currentMode);

      /* Clear the BIOS's hotkey press flags */
      gr18 &= ~(HOTKEY_TOGGLE | HOTKEY_SWITCH);
      pI830->writeControl(pI830, GRX, 0x18, gr18);
   }

   return 1000;
}

d3895 1
d3897 6
a3902 5
   if (!pI830->noAccel && !pI830->useEXA && pI830->AccelInfoRec 
	&& pI830->AccelInfoRec->NeedToSync) {
      (*pI830->AccelInfoRec->Sync)(pScrn);
      pI830->AccelInfoRec->NeedToSync = FALSE;
   }
d3905 17
a3921 3
   if (!pI830->noAccel && pI830->useEXA && pI830->EXADriverPtr) {
	ScreenPtr pScreen = screenInfo.screens[pScrn->scrnIndex];
	exaWaitSync(pScreen);
a3922 1
#endif
d3930 1
d3932 4
a3935 2
   if (!pI830->useEXA && pI830->AccelInfoRec)
      pI830->AccelInfoRec->NeedToSync = TRUE;
d3938 15
a3952 3
   if (pI830->useEXA && pI830->EXADriverPtr) {
      ScreenPtr pScreen = screenInfo.screens[pScrn->scrnIndex];
      exaMarkSync(pScreen);
a3953 1
#endif
@


1.12
log
@Set default acceleration method to EXA, like upstreams.
@
text
@d337 1
a337 1
   {OPTION_FBC,		"FramebufferCompression", OPTV_BOOLEAN, {0}, FALSE},
d521 2
a522 2
   if (IS_G4X(pI830))
       range = 0;
d2721 17
a2873 1
#ifdef notyet
a2878 3
#else
   pI830->fb_compression = FALSE;
#endif
d3072 2
@


1.11
log
@Disable framebuffer compression for now. Problems noticed by oga@@
@
text
@d1567 1
a1567 1
    * config option AccelMethod to determine which to use, defaulting to XAA
d1574 3
a1576 1
#ifdef I830_USE_XAA
a1577 2
#else
       pI830->useEXA = TRUE;
@


1.10
log
@xf86-video-intel 2.4.2. Has been in snapshots for weeks. Ok oga@@.
@
text
@d337 1
a337 1
   {OPTION_FBC,		"FramebufferCompression", OPTV_BOOLEAN, {0}, TRUE},
d2857 1
d2863 3
@


1.9
log
@update to xf86-video-intel 2.3.2. Tested among others by okan@@.
@
text
@d254 4
a257 1
   {PCI_CHIP_IGD_GM,		"Intel Integrated Graphics Device"},
d281 4
a284 1
   {PCI_CHIP_IGD_GM,		PCI_CHIP_IGD_GM,	RES_SHARED_VGA},
d520 4
d557 16
d656 1
a656 1
	 if (IS_IGD_GM(pI830)) {
d927 13
a939 2
      i830_sdvo_init(pScrn, SDVOB);
      i830_sdvo_init(pScrn, SDVOC);
d943 1
a943 1
   if (IS_I9XX(pI830) && !IS_I915G(pI830))
d976 1
a976 1
    if (IS_IGD_GM(pI830)) {
d1221 4
a1224 1
    case PCI_CHIP_IGD_GM:
d1227 6
d1506 1
a1506 1
      pI830->lvds_fixed_mode = TRUE;
d1508 1
a1508 1
      pI830->lvds_fixed_mode = FALSE;
d1638 4
a1960 16
/*
 * This should be called everytime the X server gains control of the screen,
 * before any video modes are programmed (ScreenInit, EnterVT).
 */
static void
SetHWOperatingState(ScrnInfoPtr pScrn)
{
   I830Ptr pI830 = I830PTR(pScrn);

   DPRINTF(PFX, "SetHWOperatingState\n");

   i830_start_ring(pScrn);
   if (!pI830->SWCursor)
      I830InitHWCursor(pScrn);
}

d2025 3
d2109 1
a2109 1
   if (IS_I965GM(pI830) || IS_IGD_GM(pI830))
d2169 3
d2180 1
a2180 1
   if (IS_I965GM(pI830) || IS_IGD_GM(pI830))
d2360 4
d2496 1
d2514 21
d2596 1
a2596 1
    if (IS_I965GM(pI830) || IS_IGD_GM(pI830))
d2858 1
a2858 2
   if (i830_fb_compression_supported(pI830) && !IS_I965GM(pI830)
	   && !IS_IGD_GM(pI830))
d2969 1
a2969 1
      if (!IS_IGD_GM(pI830) && pI830->overlay_regs == NULL) {
d3009 1
a3009 1
   if (I830LVDSPresent(pScrn) && !IS_I965GM(pI830) && !IS_IGD_GM(pI830) &&
d3245 1
a3246 1
#ifndef HAVE_FREE_SHADOW
d3316 3
d3365 3
d3374 3
a3376 1
   SetHWOperatingState(pScrn);
@


1.8
log
@Update to xf86-video-intel 2.3.1. Tested by many.
@
text
@a694 5
    /* KLUDGE ALERT -- rewrite the PTEs to turn off the CD and WT bits */
#if HAVE_MPROTECT
    mprotect (pI830->FbBase, pI830->FbMapSize, PROT_NONE);
    mprotect (pI830->FbBase, pI830->FbMapSize, PROT_READ|PROT_WRITE);
#endif
d932 47
a1036 4
   if (pI830->swfSaved) {
      OUTREG(SWF0, pI830->saveSWF0);
      OUTREG(SWF4, pI830->saveSWF4);
   }
a1501 13
#if 1
   pI830->saveSWF0 = INREG(SWF0);
   pI830->saveSWF4 = INREG(SWF4);
   pI830->swfSaved = TRUE;

   /* Set "extended desktop" */
   OUTREG(SWF0, pI830->saveSWF0 | (1 << 21));

   /* Set "driver loaded",  "OS unknown", "APM 1.2" */
   OUTREG(SWF4, (pI830->saveSWF4 & ~((3 << 19) | (7 << 16))) |
		(1 << 23) | (2 << 16));
#endif

a1735 6
   /* Don't need MMIO access anymore. */
   if (pI830->swfSaved) {
      OUTREG(SWF0, pI830->saveSWF0);
      OUTREG(SWF4, pI830->saveSWF4);
   }

a1841 1
	 DO_RING_IDLE();
a1921 13
   /* Disable clock gating reported to work incorrectly according to the specs.
    */
   if (IS_I965GM(pI830)) {
      OUTREG(RENCLK_GATE_D1, I965_RCC_CLOCK_GATE_DISABLE);
   } else if (IS_I965G(pI830)) {
      OUTREG(RENCLK_GATE_D1,
	     I965_RCC_CLOCK_GATE_DISABLE | I965_ISC_CLOCK_GATE_DISABLE);
   } else if (IS_I855(pI830) || IS_I865G(pI830)) {
      OUTREG(RENCLK_GATE_D1, SV_CLOCK_GATE_DISABLE);
   } else if (IS_I830(pI830)) {
      OUTREG(DSPCLK_GATE_D, OVRUNIT_CLOCK_GATE_DISABLE);
   }

d2064 11
d2132 11
d2530 4
a3131 14
   if (IS_I965G(pI830)) {
      /* turn off clock gating */
#if 0
      OUTREG(0x6204, 0x70804000);
      OUTREG(0x6208, 0x00000001);
#else
      OUTREG(0x6204, 0x70000000);
#endif
      /* Enable DAP stateless accesses.  
       * Required for all i965 steppings.
       */
      OUTREG(SVG_WORK_CTL, 0x00000010);
   }

d3305 8
a3325 3
   i830_stop_ring(pScrn, TRUE);
   SetHWOperatingState(pScrn);

d3358 1
a3358 1
      
a3360 1
	 DO_RING_IDLE();
@


1.7
log
@Update to Intel driver 2.2.1. But change default accelmethod to XAA.
Tested by landry@@, oga@@, steven@@, jakemsr@@.
@
text
@a173 1
#include <sys/mman.h>
d200 8
d302 1
d308 1
d310 4
a313 1
   OPTION_FORCEENABLEPIPEA
d330 1
d336 1
d339 3
d626 2
a627 2
      CARD32   gttaddr;
      
d693 7
a712 9
   /* Mark the pages we haven't yet bound into AGP as inaccessible. */
   if (pI830->FbMapSize > pI830->stolen_size) {
      if (mprotect(pI830->FbBase + pI830->stolen_size,
		   pI830->FbMapSize - pI830->stolen_size, PROT_NONE) != 0) {
	 xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
		    "Failed to mprotect unbound AGP: %s\n", strerror(errno));
      }
   }

d762 1
a762 1
   CARD16 lut_r[256], lut_g[256], lut_b[256];
d1044 1
a1044 1
   CARD8 gr18;
d1054 205
a1279 1
   const char *chipname;
a1281 2
   uint32_t	capid;
   int fb_bar, mmio_bar;
d1415 2
a1416 110
   if (xf86ReturnOptValBool(pI830->Options, OPTION_FORCEENABLEPIPEA, FALSE))
       pI830->quirk_flag |= QUIRK_PIPEA_FORCE;

   /* We have to use PIO to probe, because we haven't mapped yet. */
   I830SetPIOAccess(pI830);

   switch (DEVICE_ID(pI830->PciInfo)) {
   case PCI_CHIP_I830_M:
      chipname = "830M";
      break;
   case PCI_CHIP_845_G:
      chipname = "845G";
      break;
   case PCI_CHIP_I855_GM:
      /* Check capid register to find the chipset variant */
#if XSERVER_LIBPCIACCESS
      pci_device_cfg_read_u32 (pI830->PciInfo, &capid, I85X_CAPID);
#else
      capid = pciReadLong (pI830->PciTag, I85X_CAPID);
#endif
      pI830->variant = (capid >> I85X_VARIANT_SHIFT) & I85X_VARIANT_MASK;
      switch (pI830->variant) {
      case I855_GM:
	 chipname = "855GM";
	 break;
      case I855_GME:
	 chipname = "855GME";
	 break;
      case I852_GM:
	 chipname = "852GM";
	 break;
      case I852_GME:
	 chipname = "852GME";
	 break;
      default:
	 xf86DrvMsg(pScrn->scrnIndex, X_INFO,
		    "Unknown 852GM/855GM variant: 0x%x)\n", pI830->variant);
	 chipname = "852GM/855GM (unknown variant)";
	 break;
      }
      break;
   case PCI_CHIP_I865_G:
      chipname = "865G";
      break;
   case PCI_CHIP_I915_G:
      chipname = "915G";
      break;
   case PCI_CHIP_E7221_G:
      chipname = "E7221 (i915)";
      break;
   case PCI_CHIP_I915_GM:
      chipname = "915GM";
      break;
   case PCI_CHIP_I945_G:
      chipname = "945G";
      break;
   case PCI_CHIP_I945_GM:
      chipname = "945GM";
      break;
   case PCI_CHIP_I945_GME:
      chipname = "945GME";
      break;
   case PCI_CHIP_I965_G:
      chipname = "965G";
      break;
   case PCI_CHIP_G35_G:
      chipname = "G35";
      break;
   case PCI_CHIP_I965_Q:
      chipname = "965Q";
      break;
   case PCI_CHIP_I946_GZ:
      chipname = "946GZ";
      break;
   case PCI_CHIP_I965_GM:
      chipname = "965GM";
      break;
   case PCI_CHIP_I965_GME:
      chipname = "965GME/GLE";
      break;
   case PCI_CHIP_G33_G:
      chipname = "G33";
      break;
   case PCI_CHIP_Q35_G:
      chipname = "Q35";
      break;
   case PCI_CHIP_Q33_G:
      chipname = "Q33";
      break;
   case PCI_CHIP_IGD_GM:
      chipname = "Intel Integrated Graphics Device";
      break;
   default:
      chipname = "unknown chipset";
      break;
   }
   xf86DrvMsg(pScrn->scrnIndex, X_INFO,
	      "Integrated Graphics Chipset: Intel(R) %s\n", chipname);

   /* Set the Chipset and ChipRev, allowing config file entries to override. */
   if (pI830->pEnt->device->chipset && *pI830->pEnt->device->chipset) {
      pScrn->chipset = pI830->pEnt->device->chipset;
      from = X_CONFIG;
   } else if (pI830->pEnt->device->chipID >= 0) {
      pScrn->chipset = (char *)xf86TokenToString(I830Chipsets,
						 pI830->pEnt->device->chipID);
      from = X_CONFIG;
      xf86DrvMsg(pScrn->scrnIndex, X_CONFIG, "ChipID override: 0x%04X\n",
		 pI830->pEnt->device->chipID);
      DEVICE_ID(pI830->PciInfo) = pI830->pEnt->device->chipID;
d1418 1
a1418 22
      from = X_PROBED;
      pScrn->chipset = (char *)xf86TokenToString(I830Chipsets,
						 DEVICE_ID(pI830->PciInfo));
   }

   if (pI830->pEnt->device->chipRev >= 0) {
      xf86DrvMsg(pScrn->scrnIndex, X_CONFIG, "ChipRev override: %d\n",
		 pI830->pEnt->device->chipRev);
   }

   xf86DrvMsg(pScrn->scrnIndex, from, "Chipset: \"%s\"\n",
	      (pScrn->chipset != NULL) ? pScrn->chipset : "Unknown i8xx");

   if (IS_I9XX(pI830))
   {
      fb_bar = 2;
      mmio_bar = 0;
   }
   else
   {
      fb_bar = 0;
      mmio_bar = 1;
d1421 2
a1422 3
   if (pI830->pEnt->device->MemBase != 0) {
      pI830->LinearAddr = pI830->pEnt->device->MemBase;
      from = X_CONFIG;
d1424 1
a1424 7
      pI830->LinearAddr = I810_MEMBASE (pI830->PciInfo, fb_bar);
      if (pI830->LinearAddr == 0) {
	 xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
		    "No valid FB address in PCI config space\n");
	 PreInitCleanup(pScrn);
	 return FALSE;
      }
d1427 2
a1428 2
   xf86DrvMsg(pScrn->scrnIndex, from, "Linear framebuffer at 0x%lX\n",
	      (unsigned long)pI830->LinearAddr);
d1430 2
a1431 12
   if (pI830->pEnt->device->IOBase != 0) {
      pI830->MMIOAddr = pI830->pEnt->device->IOBase;
      from = X_CONFIG;
   } else {
      pI830->MMIOAddr = I810_MEMBASE (pI830->PciInfo, mmio_bar);
      if (pI830->MMIOAddr == 0) {
	 xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
		    "No valid MMIO address in PCI config space\n");
	 PreInitCleanup(pScrn);
	 return FALSE;
      }
   }
d1433 2
a1434 2
   xf86DrvMsg(pScrn->scrnIndex, from, "IO registers at addr 0x%lX\n",
	      (unsigned long)pI830->MMIOAddr);
a1453 33
   if (IS_I830(pI830) || IS_845G(pI830)) {
#if XSERVER_LIBPCIACCESS
      uint16_t		gmch_ctrl;
      struct pci_device *bridge;

      bridge = intel_host_bridge ();
      pci_device_cfg_read_u16 (bridge, &gmch_ctrl, I830_GMCH_CTRL);
#else
      PCITAG bridge;
      CARD16 gmch_ctrl;

      bridge = pciTag(0, 0, 0);		/* This is always the host bridge */
      gmch_ctrl = pciReadWord(bridge, I830_GMCH_CTRL);
#endif
      if ((gmch_ctrl & I830_GMCH_MEM_MASK) == I830_GMCH_MEM_128M) {
	 pI830->FbMapSize = 0x8000000;
      } else {
	 pI830->FbMapSize = 0x4000000; /* 64MB - has this been tested ?? */
      }
   } else {
      if (IS_I9XX(pI830)) {
#if XSERVER_LIBPCIACCESS
	 pI830->FbMapSize = pI830->PciInfo->regions[fb_bar].size;
#else
	 pI830->FbMapSize = 1UL << pciGetBaseSize(pI830->PciTag, 2, TRUE,
						  NULL);
#endif
      } else {
	 /* 128MB aperture for later i8xx series. */
	 pI830->FbMapSize = 0x8000000;
      }
   }

d1509 1
a1509 1
       int from = X_DEFAULT;
d1650 9
d2044 7
d2252 14
d2377 1
a2377 1
   CARD32 ctx_addr;
d2401 6
a2406 6
      BEGIN_LP_RING(2);
      OUT_RING(MI_SET_CONTEXT);
      OUT_RING(pI830->logical_context->offset |
	       CTXT_NO_RESTORE |
	       CTXT_PALETTE_SAVE_DISABLE | CTXT_PALETTE_RESTORE_DISABLE);
      ADVANCE_LP_RING();
d2433 9
d2445 179
d2633 1
a2633 2
   int i, c;
   Bool allocation_done = FALSE;
d2731 3
a2733 3
#ifdef XF86DRI
   /* Check for appropriate bpp and module support to initialize DRI. */
   if (!I830CheckDRIAvailable(pScrn)) {
d2737 1
a2748 20
   /* Set up our video memory allocator for the chosen videoRam */
   if (!i830_allocator_init(pScrn, 0, pScrn->videoRam * KB(1))) {
      xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
		 "Couldn't initialize video memory allocator\n");
      PreInitCleanup(pScrn);
      return FALSE;
   }

   xf86DrvMsg(pScrn->scrnIndex,
	      pI830->pEnt->device->videoRam ? X_CONFIG : X_DEFAULT,
	      "VideoRam: %d KB\n", pScrn->videoRam);

   if (xf86GetOptValInteger(pI830->Options, OPTION_CACHE_LINES,
			    &(pI830->CacheLines))) {
      xf86DrvMsg(pScrn->scrnIndex, X_CONFIG, "Requested %d cache lines\n",
		 pI830->CacheLines);
   } else {
      pI830->CacheLines = -1;
   }

a2805 10
   /* Need MMIO mapped to do GTT lookups during memory allocation. */
   I830MapMMIO(pScrn);

#if defined(XF86DRI)
   /*
    * If DRI is potentially usable, check if there is enough memory available
    * for it, and if there's also enough to allow tiling to be enabled.
    */


a2813 3
   if (pI830->directRenderingEnabled) {
      int savedDisplayWidth = pScrn->displayWidth;
      Bool tiled = FALSE;
d2815 2
a2816 25
      if (IS_I965G(pI830)) {
	 int tile_pixels = 512 / pI830->cpp;
	 pScrn->displayWidth = (pScrn->displayWidth + tile_pixels - 1) &
	    ~(tile_pixels - 1);
	 tiled = TRUE;
      } else {
	 /* Good pitches to allow tiling.  Don't care about pitches < 1024
	  * pixels.
	  */
	 static const int pitches[] = {
	    1024,
	    2048,
	    4096,
	    8192,
	    0
	 };

	 for (i = 0; pitches[i] != 0; i++) {
	    if (pitches[i] >= pScrn->displayWidth) {
	       pScrn->displayWidth = pitches[i];
	       tiled = TRUE;
	       break;
	    }
	 }
      }
d2818 4
a2821 63
      /* Attempt two rounds of allocation to get 2d and 3d memory to fit:
       *
       * 0: untiled
       * 1: tiled
       */

#define MM_TURNS 2
      for (i = 0; i < MM_TURNS; i++) {
	 if (!tiled && i == 0)
	    continue;

	 if (i >= 1) {
	    /* For further allocations, disable tiling */
	    pI830->tiling = FALSE;
	    pScrn->displayWidth = savedDisplayWidth;
	    if (pI830->allowPageFlip)
	       xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
			  "Couldn't allocate tiled memory, page flipping "
			  "disabled\n");
	    pI830->allowPageFlip = FALSE;
	    if (pI830->fb_compression)
	       xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
			  "Couldn't allocate tiled memory, fb compression "
			  "disabled\n");
	    pI830->fb_compression = FALSE;
	 }

	 xf86DrvMsg(pScrn->scrnIndex, X_INFO,
		    "Attempting memory allocation with %s buffers.\n",
		    (i & 1) ? "untiled" : "tiled");

	 if (i830_allocate_2d_memory(pScrn) &&
	     i830_allocate_3d_memory(pScrn))
	 {
	    xf86DrvMsg(pScrn->scrnIndex, X_INFO, "Success.\n");
	    if (pScrn->displayWidth != savedDisplayWidth) {
	       xf86DrvMsg(pScrn->scrnIndex, X_INFO,
			  "Increasing the scanline pitch to allow tiling mode "
			  "(%d -> %d).\n",
			  savedDisplayWidth, pScrn->displayWidth);
	    }
	    allocation_done = TRUE;
	    break;
	 }

	 i830_reset_allocations(pScrn);
      }

      if (i == MM_TURNS) {
	 xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
		    "Not enough video memory.  Disabling DRI.\n");
	 pI830->directRenderingEnabled = FALSE;
      }
   }
#endif

   if (!allocation_done) {
      if (!i830_allocate_2d_memory(pScrn)) {
	 xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
		    "Couldn't allocate video memory\n");
	 return FALSE;
      }
      allocation_done = TRUE;
d2826 1
a2826 47
   if (!IS_I965G(pI830) && pScrn->displayWidth > 2048) {
      xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
		 "Cannot support DRI with frame buffer width > 2048.\n");
      pI830->tiling = FALSE;
      pI830->directRenderingEnabled = FALSE;
   }

#ifdef HAS_MTRR_SUPPORT
   {
      int fd;
      struct mtrr_gentry gentry;
      struct mtrr_sentry sentry;

      if ( ( fd = open ("/proc/mtrr", O_RDONLY, 0) ) != -1 ) {
         for (gentry.regnum = 0; ioctl (fd, MTRRIOC_GET_ENTRY, &gentry) == 0;
	      ++gentry.regnum) {

	    if (gentry.size < 1) {
	       /* DISABLED */
	       continue;
	    }

            /* Check the MTRR range is one we like and if not - remove it.
             * The Xserver common layer will then setup the right range
             * for us.
             */
	    if (gentry.base == pI830->LinearAddr && 
	        gentry.size < pI830->FbMapSize) {

               xf86DrvMsg(pScrn->scrnIndex, X_INFO,
		  "Removing bad MTRR range (base 0x%lx, size 0x%x)\n",
		  gentry.base, gentry.size);

    	       sentry.base = gentry.base;
               sentry.size = gentry.size;
               sentry.type = gentry.type;

               if (ioctl (fd, MTRRIOC_DEL_ENTRY, &sentry) == -1) {
                  xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
		     "Failed to remove bad MTRR range\n");
               }
	    }
         }
         close(fd);
      }
   }
#endif
d2873 1
a2873 1
      if (!IS_I9XX(pI830) && pI830->overlay_regs == NULL) {
d3147 6
d3163 4
d3194 15
a3245 2
   xf86CrtcConfigPtr	config = XF86_CRTC_CONFIG_PTR(pScrn);
   int o;
a3291 5
   for (o = 0; o < config->num_output; o++) {
   	xf86OutputPtr  output = config->output[o];
	output->funcs->dpms(output, DPMSModeOff);
   }

d3550 3
d3560 17
d3618 1
a3618 1
   CARD8 gr18;
@


1.6
log
@Merge intel driver version 2.2.0.90.
@
text
@d498 1
a498 1
      switch (gmch_ctrl & I830_GMCH_GMS_MASK) {
d2123 2
a2124 1
   if (pI830->saveDSPACNTR & DISPPLANE_SEL_PIPE_A) {
d2129 2
a2130 1
   if (pI830->saveDSPBCNTR & DISPPLANE_SEL_PIPE_A) {
d2182 2
a2183 1
      if (pI830->saveDSPACNTR & DISPPLANE_SEL_PIPE_B) {
d2188 2
a2189 1
      if (pI830->saveDSPBCNTR & DISPPLANE_SEL_PIPE_B) {
d3193 16
@


1.5
log
@Default to XAA acceleration since EXA produces stack overflows for now.
@
text
@d239 1
a239 1
   {PCI_CHIP_I965_G_1,		"965G"},
d247 1
d263 1
a263 1
   {PCI_CHIP_I965_G_1,		PCI_CHIP_I965_G_1,	RES_SHARED_VGA},
d271 1
d301 1
d324 1
d460 9
d523 1
a523 1
	 if (IS_G33CLASS(pI830))
d527 1
a527 1
	 if (IS_G33CLASS(pI830))
d613 7
a619 2
	 gttaddr = pI830->MMIOAddr + (512 * 1024);
	 pI830->GTTMapSize = 512 * 1024;
d1198 3
a1260 1
   case PCI_CHIP_I965_G_1:
d1263 3
d1287 3
d1935 1
d2021 7
d2062 17
d2087 1
a2087 1
   usleep(150);
d2092 1
a2092 1
   usleep(150);
d2094 1
d2113 4
d2118 4
a2121 2
    * Make sure the DPLL is active and not in VGA mode or the
    * write of PIPEnCONF may cause a crash
d2123 12
a2134 8
   if ((pI830->saveDPLL_A & DPLL_VCO_ENABLE) &&
       (pI830->saveDPLL_A & DPLL_VGA_MODE_DIS))
	   OUTREG(PIPEACONF, pI830->savePIPEACONF);
   i830WaitForVblank(pScrn);
   OUTREG(DSPACNTR, pI830->saveDSPACNTR);
   OUTREG(DSPABASE, INREG(DSPABASE));
   i830WaitForVblank(pScrn);
   
d2137 1
d2146 1
a2146 1
      usleep(150);
d2151 1
a2151 1
      usleep(150);
d2153 1
d2172 3
d2176 3
a2178 1
       * See PIPEnCONF note above
d2180 10
a2189 7
      if ((pI830->saveDPLL_B & DPLL_VCO_ENABLE) &&
	  (pI830->saveDPLL_B & DPLL_VGA_MODE_DIS))
	      OUTREG(PIPEBCONF, pI830->savePIPEBCONF);
      i830WaitForVblank(pScrn);
      OUTREG(DSPBCNTR, pI830->saveDSPBCNTR);
      OUTREG(DSPBBASE, INREG(DSPBBASE));
      i830WaitForVblank(pScrn);
d2192 2
a2200 6
   OUTREG(VGACNTRL, pI830->saveVGACNTRL);

   OUTREG(VCLK_DIVISOR_VGA0, pI830->saveVCLK_DIVISOR_VGA0);
   OUTREG(VCLK_DIVISOR_VGA1, pI830->saveVCLK_DIVISOR_VGA1);
   OUTREG(VCLK_POST_DIV, pI830->saveVCLK_POST_DIV);

d2216 1
d2358 1
d2521 2
a2522 1
   if (i830_fb_compression_supported(pI830) && !IS_I965GM(pI830))
d2814 1
a2814 1
   if (I830LVDSPresent(pScrn) && !IS_I965GM(pI830) &&
d2939 4
d2946 12
a2993 2
   pI830->BlockHandler = pScreen->BlockHandler;
   pScreen->BlockHandler = I830BlockHandler;
a2994 9
   pScreen->SaveScreen = xf86SaveScreen;
   pI830->CloseScreen = pScreen->CloseScreen;
   pScreen->CloseScreen = I830CloseScreen;
   pI830->CreateScreenResources = pScreen->CreateScreenResources;
   pScreen->CreateScreenResources = i830CreateScreenResources;

   if (!xf86CrtcScreenInit (pScreen))
       return FALSE;
       
@


1.4
log
@- disable dri support explicitely for now.
- fix some merge botches. Long live CVS.
@
text
@d1432 1
a1432 1
    * config option AccelMethod to determine which to use, defaulting to EXA
d1439 3
a1441 1
#ifdef I830_USE_EXA
a1442 2
#else
       pI830->useEXA = FALSE;
@


1.3
log
@merge xf86-video-intel 2.2.0
@
text
@d2268 1
a2268 1
   if (!IS_I96X(pI830))
@


1.2
log
@Add support for the mobile i965GM chipset.

tested by many
ok matthieu@@
@
text
@d168 1
d173 3
d197 4
a200 4

#ifdef HAS_MTRR_SUPPORT
#include <asm/mtrr.h>
#endif
d205 15
a219 1
#include <errno.h>
d227 1
a227 1
static SymTabRec I830BIOSChipsets[] = {
d237 1
d243 4
d250 1
a250 1
static PciChipsets I830BIOSPciChipsets[] = {
d260 1
d266 4
d280 3
a290 6
   OPTION_VBE_RESTORE,
   OPTION_DISPLAY_INFO,
   OPTION_DEVICE_PRESENCE,
   OPTION_MONITOR_LAYOUT,
   OPTION_CLONE,
   OPTION_CLONE_REFRESH,
d292 4
a295 9
   OPTION_FIXEDPIPE,
   OPTION_ROTATE,
   OPTION_LINEARALLOC,
   OPTION_MERGEDFB,
   OPTION_METAMODES,
   OPTION_SECONDHSYNC,
   OPTION_SECONDVREFRESH,
   OPTION_SECONDPOSITION,
   OPTION_INTELXINERAMA,
d297 2
a298 1
   OPTION_INTELMMSIZE
d301 4
a304 1
static OptionInfoRec I830BIOSOptions[] = {
a312 6
   {OPTION_VBE_RESTORE,	"VBERestore",	OPTV_BOOLEAN,	{0},	FALSE},
   {OPTION_DISPLAY_INFO,"DisplayInfo",	OPTV_BOOLEAN,	{0},	FALSE},
   {OPTION_DEVICE_PRESENCE,"DevicePresence",OPTV_BOOLEAN,{0},	FALSE},
   {OPTION_MONITOR_LAYOUT, "MonitorLayout", OPTV_ANYSTR,{0},	FALSE},
   {OPTION_CLONE,	"Clone",	OPTV_BOOLEAN,	{0},	FALSE},
   {OPTION_CLONE_REFRESH,"CloneRefresh",OPTV_INTEGER,	{0},	FALSE},
d314 4
a317 9
   {OPTION_FIXEDPIPE,   "FixedPipe",    OPTV_ANYSTR, 	{0},	FALSE},
   {OPTION_ROTATE,      "Rotate",       OPTV_ANYSTR,    {0},    FALSE},
   {OPTION_LINEARALLOC, "LinearAlloc",  OPTV_INTEGER,   {0},    FALSE},
   {OPTION_MERGEDFB, 	"MergedFB",	OPTV_BOOLEAN,	{0},	FALSE},
   {OPTION_METAMODES, 	"MetaModes",	OPTV_STRING,	{0},	FALSE},
   {OPTION_SECONDHSYNC,	"SecondMonitorHorizSync",OPTV_STRING,	{0}, FALSE },
   {OPTION_SECONDVREFRESH,"SecondMonitorVertRefresh",OPTV_STRING,{0}, FALSE },
   {OPTION_SECONDPOSITION,"SecondPosition",OPTV_STRING,	{0},	FALSE },
   {OPTION_INTELXINERAMA,"MergedXinerama",OPTV_BOOLEAN,	{0},	TRUE},
d319 2
a320 1
   {OPTION_INTELMMSIZE, "AperTexSize",  OPTV_INTEGER,	{0},	FALSE},
d325 12
a336 8
static void I830DisplayPowerManagementSet(ScrnInfoPtr pScrn,
					  int PowerManagementMode, int flags);
static void I830AdjustFrame(int scrnIndex, int x, int y, int flags);
static Bool I830BIOSCloseScreen(int scrnIndex, ScreenPtr pScreen);
static Bool I830BIOSSaveScreen(ScreenPtr pScreen, int unblack);
static Bool I830BIOSEnterVT(int scrnIndex, int flags);
static Bool I830VESASetVBEMode(ScrnInfoPtr pScrn, int mode,
			       VbeCRTCInfoBlock *block);
d338 2
a339 16
static Bool SetPipeAccess(ScrnInfoPtr pScrn);

extern int I830EntityIndex;

static Bool 		I830noPanoramiXExtension = TRUE;
static int		I830XineramaNumScreens = 0;
static I830XineramaData	*I830XineramadataPtr = NULL;
static int		I830XineramaGeneration;

static int I830ProcXineramaQueryVersion(ClientPtr client);
static int I830ProcXineramaGetState(ClientPtr client);
static int I830ProcXineramaGetScreenCount(ClientPtr client);
static int I830ProcXineramaGetScreenSize(ClientPtr client);
static int I830ProcXineramaIsActive(ClientPtr client);
static int I830ProcXineramaQueryScreens(ClientPtr client);
static int I830SProcXineramaDispatch(ClientPtr client);
a343 3
static const char *SecondMonitorName = "MergedFBMonitor";


d368 1
a368 1
/* XXX Check if this is still needed. */
d370 1
a370 1
I830BIOSAvailableOptions(int chipid, int busid)
d374 3
a376 3
   for (i = 0; I830BIOSPciChipsets[i].PCIid > 0; i++) {
      if (chipid == I830BIOSPciChipsets[i].PCIid)
	 return I830BIOSOptions;
d382 1
a382 1
I830BIOSGetRec(ScrnInfoPtr pScrn)
a388 1
   pI830->vesa = xnfcalloc(sizeof(VESARec), 1);
d393 1
a393 1
I830BIOSFreeRec(ScrnInfoPtr pScrn)
a395 2
   VESAPtr pVesa;
   DisplayModePtr mode;
a402 25
   mode = pScrn->modes;

   if (mode) {
      do {
	 if (mode->Private) {
	    I830ModePrivatePtr mp = (I830ModePrivatePtr) mode->Private;

	    xfree(mp);
	    mode->Private = NULL;
	 }
	 mode = mode->next;
      } while (mode && mode != pScrn->modes);
   }

   if (I830IsPrimary(pScrn)) {
      if (pI830->vbeInfo)
         VBEFreeVBEInfo(pI830->vbeInfo);
      if (pI830->pVbe)
         vbeFree(pI830->pVbe);
   }

   pVesa = pI830->vesa;
   if (pVesa->savedPal)
      xfree(pVesa->savedPal);
   xfree(pVesa);
d408 2
a409 2
static Bool
InRegion(int x, int y, region r)
d411 1
a411 2
    return (r.x0 <= x) && (x <= r.x1) && (r.y0 <= y) && (y <= r.y1);
}
d413 1
a413 46
static int
I830StrToRanges(range *r, char *s, int max)
{
   float num = 0.0;
   int rangenum = 0;
   Bool gotdash = FALSE;
   Bool nextdash = FALSE;
   char *strnum = NULL;
   do {
      switch(*s) {
      case '0':
      case '1':
      case '2':
      case '3':
      case '4':
      case '5':
      case '6':
      case '7':
      case '8':
      case '9':
      case '.':
         if(strnum == NULL) {
            strnum = s;
            gotdash = nextdash;
            nextdash = FALSE;
         }
         break;
      case '-':
      case ' ':
      case 0:
         if(strnum == NULL) break;
         sscanf(strnum, "%f", &num);
	 strnum = NULL;
         if(gotdash) {
            r[rangenum - 1].hi = num;
         } else {
            r[rangenum].lo = num;
            r[rangenum].hi = num;
            rangenum++;
         }
         if(*s == '-') nextdash = (rangenum != 0);
	 else if(rangenum >= max) return rangenum;
         break;
      default:
         return 0;
      }
d415 2
a416 3
   } while(*(s++) != 0);

   return rangenum;
d419 2
a420 3
/* Calculate the vertical refresh rate from a mode */
static float
I830CalcVRate(DisplayModePtr mode)
d422 10
a431 1
   float hsync, refresh = 0;
d433 7
a439 6
   if(mode->HSync > 0.0)
       	hsync = mode->HSync;
   else if(mode->HTotal > 0)
       	hsync = (float)mode->Clock / (float)mode->HTotal;
   else
       	hsync = 0.0;
d441 35
a475 2
   if(mode->VTotal > 0)
       	refresh = hsync * 1000.0 / mode->VTotal;
d477 1
a477 2
   if(mode->Flags & V_INTERLACE)
       	refresh *= 2.0;
d479 4
a482 2
   if(mode->Flags & V_DBLSCAN)
       	refresh /= 2.0;
d484 52
a535 2
   if(mode->VScan > 1)
        refresh /= mode->VScan;
d537 4
a540 2
   if(mode->VRefresh > 0.0)
	refresh = mode->VRefresh;
d542 6
a547 1
   if(hsync == 0.0 || refresh == 0.0) return 0.0;
d549 1
a549 1
   return refresh;
d552 10
a561 38
/* Copy and link two modes (i, j) for mergedfb mode
 * (Code base taken from mga driver)
 *
 * - Copy mode i, merge j to copy of i, link the result to dest
 * - Link i and j in private record.
 * - If dest is NULL, return value is copy of i linked to itself.
 * - For mergedfb auto-config, we only check the dimension
 *   against virtualX/Y, if they were user-provided.
 * - No special treatment required for CRTxxOffs.
 * - Provide fake dotclock in order to distinguish between similar
 *   looking MetaModes (for RandR and VidMode extensions)
 * - Set unique VRefresh of dest mode for RandR
 */
static DisplayModePtr
I830CopyModeNLink(ScrnInfoPtr pScrn, DisplayModePtr dest,
                 DisplayModePtr i, DisplayModePtr j,
		 int pos)
{
    DisplayModePtr mode;
    int dx = 0,dy = 0;

    if(!((mode = xalloc(sizeof(DisplayModeRec))))) return dest;
    memcpy(mode, i, sizeof(DisplayModeRec));
    if(!((mode->Private = xalloc(sizeof(I830ModePrivateRec))))) {
       xfree(mode);
       return dest;
    }
    ((I830ModePrivatePtr)mode->Private)->merged.First = i;
    ((I830ModePrivatePtr)mode->Private)->merged.Second = j;
    ((I830ModePrivatePtr)mode->Private)->merged.SecondPosition = pos;
    if (((I830ModePrivatePtr)i->Private)->vbeData.mode > 0x30) {
       ((I830ModePrivatePtr)mode->Private)->vbeData.mode = ((I830ModePrivatePtr)i->Private)->vbeData.mode;
       ((I830ModePrivatePtr)mode->Private)->vbeData.data = ((I830ModePrivatePtr)i->Private)->vbeData.data;
    } else {
       ((I830ModePrivatePtr)mode->Private)->vbeData.mode = ((I830ModePrivatePtr)j->Private)->vbeData.mode;
       ((I830ModePrivatePtr)mode->Private)->vbeData.data = ((I830ModePrivatePtr)j->Private)->vbeData.data;
    }
    mode->PrivSize = sizeof(I830ModePrivateRec);
d563 15
a577 48
    switch(pos) {
    case PosLeftOf:
    case PosRightOf:
       if(!(pScrn->display->virtualX)) {
          dx = i->HDisplay + j->HDisplay;
       } else {
          dx = min(pScrn->virtualX, i->HDisplay + j->HDisplay);
       }
       dx -= mode->HDisplay;
       if(!(pScrn->display->virtualY)) {
          dy = max(i->VDisplay, j->VDisplay);
       } else {
          dy = min(pScrn->virtualY, max(i->VDisplay, j->VDisplay));
       }
       dy -= mode->VDisplay;
       break;
    case PosAbove:
    case PosBelow:
       if(!(pScrn->display->virtualY)) {
          dy = i->VDisplay + j->VDisplay;
       } else {
          dy = min(pScrn->virtualY, i->VDisplay + j->VDisplay);
       }
       dy -= mode->VDisplay;
       if(!(pScrn->display->virtualX)) {
          dx = max(i->HDisplay, j->HDisplay);
       } else {
          dx = min(pScrn->virtualX, max(i->HDisplay, j->HDisplay));
       }
       dx -= mode->HDisplay;
       break;
    }
    mode->HDisplay += dx;
    mode->HSyncStart += dx;
    mode->HSyncEnd += dx;
    mode->HTotal += dx;
    mode->VDisplay += dy;
    mode->VSyncStart += dy;
    mode->VSyncEnd += dy;
    mode->VTotal += dy;

    mode->type = M_T_DEFAULT;

    /* Set up as user defined (ie fake that the mode has been named in the
     * Modes-list in the screen section; corrects cycling with CTRL-ALT-[-+]
     * when source mode has not been listed there.)
     */
    mode->type |= M_T_USERDEF;
d579 5
a583 5
    /* Set the VRefresh field (in order to make RandR use it for the rates). We
     * simply set this to the refresh rate for the First mode (since Second will
     * mostly be LCD or TV anyway).
     */
    mode->VRefresh = I830CalcVRate(i);
d585 6
a590 9
    if( ((mode->HDisplay * ((pScrn->bitsPerPixel + 7) / 8) * mode->VDisplay) > (pScrn->videoRam * 1024)) ||
	(mode->HDisplay > 4088) ||
	(mode->VDisplay > 4096) ) {

       xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
		"Skipped \"%s\" (%dx%d), not enough video RAM or beyond hardware specs\n",
		mode->name, mode->HDisplay, mode->VDisplay);
       xfree(mode->Private);
       xfree(mode);
d592 42
a633 2
       return dest;
    }
d635 1
a635 37
    /* Now see if the resulting mode would be discarded as a "size" by the
     * RandR extension, and increase its clock by 1000 in case it does.
     */
    if(dest) {
       DisplayModePtr t = dest;
       do {
          if((t->HDisplay == mode->HDisplay) &&
	     (t->VDisplay == mode->VDisplay) &&
	     ((int)(t->VRefresh + .5) == (int)(mode->VRefresh + .5))) {
	     mode->VRefresh += 1000.0;
	  }
	  t = t->next;
       } while((t) && (t != dest));
    }

    /* Provide a fake but unique DotClock in order to trick the vidmode
     * extension to allow selecting among a number of modes whose merged result
     * looks identical but consists of different modes for First and Second
     */
    mode->Clock = (int)(mode->VRefresh * 1000.0);

    xf86DrvMsg(pScrn->scrnIndex, X_INFO,
	"Merged \"%s\" (%dx%d) and \"%s\" (%dx%d) to %dx%d (%d)\n",
	i->name, i->HDisplay, i->VDisplay, j->name, j->HDisplay, j->VDisplay,
	mode->HDisplay, mode->VDisplay, (int)mode->VRefresh);

    mode->next = mode;
    mode->prev = mode;

    if(dest) {
       mode->next = dest->next; 	/* Insert node after "dest" */
       dest->next->prev = mode;
       mode->prev = dest;
       dest->next = mode;
    }

    return mode;
d638 2
a639 5
/* Helper function to find a mode from a given name
 * (Code base taken from mga driver)
 */
static DisplayModePtr
I830GetModeFromName(char* str, DisplayModePtr i)
d641 6
a646 31
    DisplayModePtr c = i;
    if(!i) return NULL;
    do {
       if(strcmp(str, c->name) == 0) return c;
       c = c->next;
    } while(c != i);
    return NULL;
}

static DisplayModePtr
I830FindWidestTallestMode(DisplayModePtr i, Bool tallest)
{
    DisplayModePtr c = i, d = NULL;
    int max = 0;
    if(!i) return NULL;
    do {
       if(tallest) {
          if(c->VDisplay > max) {
	     max = c->VDisplay;
	     d = c;
          }
       } else {
          if(c->HDisplay > max) {
	     max = c->HDisplay;
	     d = c;
          }
       }
       c = c->next;
    } while(c != i);
    return d;
}
d648 2
a649 41
static void
I830FindWidestTallestCommonMode(DisplayModePtr i, DisplayModePtr j, Bool tallest,
				DisplayModePtr *a, DisplayModePtr *b)
{
    DisplayModePtr c = i, d;
    int max = 0;
    Bool foundone;

    (*a) = (*b) = NULL;

    if(!i || !j) return;

    do {
       d = j;
       foundone = FALSE;
       do {
	  if( (c->HDisplay == d->HDisplay) &&
	      (c->VDisplay == d->VDisplay) ) {
	     foundone = TRUE;
	     break;
	  }
	  d = d->next;
       } while(d != j);
       if(foundone) {
	  if(tallest) {
	     if(c->VDisplay > max) {
		max = c->VDisplay;
		(*a) = c;
		(*b) = d;
	     }
	  } else {
	     if(c->HDisplay > max) {
		max = c->HDisplay;
		(*a) = c;
		(*b) = d;
	     }
	  }
       }
       c = c->next;
    } while(c != i);
}
d651 2
a652 19
static DisplayModePtr
I830GenerateModeListFromLargestModes(ScrnInfoPtr pScrn,
		    DisplayModePtr i, DisplayModePtr j,
		    int pos)
{
    I830Ptr pI830 = I830PTR(pScrn);
    DisplayModePtr mode1 = NULL;
    DisplayModePtr mode2 = NULL;
    DisplayModePtr mode3 = NULL;
    DisplayModePtr mode4 = NULL;
    DisplayModePtr result = NULL;

    /* Now build a default list of MetaModes.
     * - Non-clone: If the user enabled NonRectangular, we use the
     * largest mode for each First and Second. If not, we use the largest
     * common mode for First and Second (if available). Additionally, and
     * regardless if the above, we produce a clone mode consisting of
     * the largest common mode (if available) in order to use DGA.
     */
d654 11
a664 14
    switch(pos) {
    case PosLeftOf:
    case PosRightOf:
       mode1 = I830FindWidestTallestMode(i, FALSE);
       mode2 = I830FindWidestTallestMode(j, FALSE);
       I830FindWidestTallestCommonMode(i, j, FALSE, &mode3, &mode4);
       break;
    case PosAbove:
    case PosBelow:
       mode1 = I830FindWidestTallestMode(i, TRUE);
       mode2 = I830FindWidestTallestMode(j, TRUE);
       I830FindWidestTallestCommonMode(i, j, TRUE, &mode3, &mode4);
       break;
    }
d666 4
a669 4
    if(mode3 && mode4 && !pI830->NonRect) {
       mode1 = mode3;
       mode2 = mode2;
    }
d671 8
a678 3
    if(mode1 && mode2) {
       result = I830CopyModeNLink(pScrn, result, mode1, mode2, pos);
    }
d680 1
a680 1
    return result;
d683 4
a686 101
/* Generate the merged-fb mode modelist
 * (Taken from mga driver)
 */
static DisplayModePtr
I830GenerateModeListFromMetaModes(ScrnInfoPtr pScrn, char* str,
		    DisplayModePtr i, DisplayModePtr j,
		    int pos)
{
    char* strmode = str;
    char modename[256];
    Bool gotdash = FALSE;
    char gotsep = 0;
    int p; 
    DisplayModePtr mode1 = NULL;
    DisplayModePtr mode2 = NULL;
    DisplayModePtr result = NULL;
    int myslen;

    do {
        switch(*str) {
        case 0:
        case '-':
	case '+':
        case ' ':
	case ',':
	case ';':
           if(strmode != str) {

              myslen = str - strmode;
              if(myslen > 255) myslen = 255;
  	      strncpy(modename, strmode, myslen);
  	      modename[myslen] = 0;

              if(gotdash) {
                 if(mode1 == NULL) {
  	             xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
  	                        "Error parsing MetaModes parameter\n");
  	             return NULL;
  	         }
                 mode2 = I830GetModeFromName(modename, j);
                 if(!mode2) {
                    xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
                        "Mode \"%s\" is not a supported mode for Second\n", modename);
                    xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
                        "\t(Skipping metamode \"%s%c%s\")\n", mode1->name, gotsep, modename);
                    mode1 = NULL;
		    gotsep = 0;
                 }
              } else {
                 mode1 = I830GetModeFromName(modename, i);
                 if(!mode1) {
                    char* tmps = str;
                    xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
                        "Mode \"%s\" is not a supported mode for First\n", modename);
                    while(*tmps == ' ' || *tmps == ';') tmps++;
                    /* skip the next mode */
  	            if(*tmps == '-' || *tmps == '+' || *tmps == ',') {
                       tmps++;
		       /* skip spaces */
		       while(*tmps == ' ' || *tmps == ';') tmps++;
		       /* skip modename */
		       while(*tmps && *tmps != ' ' && *tmps != ';' && *tmps != '-' && *tmps != '+' && *tmps != ',') tmps++;
  	               myslen = tmps - strmode;
  	               if(myslen > 255) myslen = 255;
  	               strncpy(modename,strmode,myslen);
  	               modename[myslen] = 0;
                       str = tmps - 1;
                    }
                    xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
                        "\t(Skipping metamode \"%s\")\n", modename);
                    mode1 = NULL;
		    gotsep = 0;
                 }
              }
              gotdash = FALSE;
           }
           strmode = str + 1;
           gotdash |= (*str == '-' || *str == '+' || *str == ',');
	   if (*str == '-' || *str == '+' || *str == ',')
  	      gotsep = *str;

           if(*str != 0) break;
	   /* Fall through otherwise */

        default:
           if(!gotdash && mode1) {
              p = pos ;
              if(!mode2) {
                 xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
                     "Mode \"%s\" is not a supported mode for Second\n", mode1->name);
                 xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
                     "\t(Skipping metamode \"%s\")\n", modename);
                 mode1 = NULL;
              } else {
                 result = I830CopyModeNLink(pScrn, result, mode1, mode2, p);
                 mode1 = NULL;
                 mode2 = NULL;
              }
	      gotsep = 0;
           }
           break;
d688 7
a694 1
        }
d696 8
a703 3
    } while(*(str++) != 0);
     
    return result;
d706 2
a707 4
static DisplayModePtr
I830GenerateModeList(ScrnInfoPtr pScrn, char* str,
		    DisplayModePtr i, DisplayModePtr j,
		    int pos)
d711 9
a719 11
   if(str != NULL) {
      return(I830GenerateModeListFromMetaModes(pScrn, str, i, j, pos));
   } else {
      xf86DrvMsg(pScrn->scrnIndex, X_INFO,
	"No MetaModes given, linking %s modes by default\n",
	   (pI830->NonRect ?
		(((pos == PosLeftOf) || (pos == PosRightOf)) ? "widest" :  "tallest")
		:
		(((pos == PosLeftOf) || (pos == PosRightOf)) ? "widest common" :  "tallest common")) );
      return(I830GenerateModeListFromLargestModes(pScrn, i, j, pos));
   }
d723 2
a724 1
I830RecalcDefaultVirtualSize(ScrnInfoPtr pScrn)
d726 4
a729 33
    I830Ptr pI830 = I830PTR(pScrn);
    DisplayModePtr mode, bmode;
    int maxh, maxv;
    static const char *str = "MergedFB: Virtual %s %d\n";
    static const char *errstr = "Virtual %s to small for given SecondPosition offset\n";

    mode = bmode = pScrn->modes;
    maxh = maxv = 0;
    do {
       if(mode->HDisplay > maxh) maxh = mode->HDisplay;
       if(mode->VDisplay > maxv) maxv = mode->VDisplay;
       mode = mode->next;
    } while(mode != bmode);

    maxh += pI830->FirstXOffs + pI830->SecondXOffs;
    maxv += pI830->FirstYOffs + pI830->SecondYOffs;

    if(!(pScrn->display->virtualX)) {
       if(maxh > 4088) {
	  xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
		"Virtual width with SecondPosition offset beyond hardware specs\n");
	  pI830->FirstXOffs = pI830->SecondXOffs = 0;
	  maxh -= (pI830->FirstXOffs + pI830->SecondXOffs);
       }
       pScrn->virtualX = maxh;
       pScrn->displayWidth = maxh;
       xf86DrvMsg(pScrn->scrnIndex, X_PROBED, str, "width", maxh);
    } else {
       if(maxh < pScrn->display->virtualX) {
	  xf86DrvMsg(pScrn->scrnIndex, X_ERROR, errstr, "width");
	  pI830->FirstXOffs = pI830->SecondXOffs = 0;
       }
    }
d731 1
a731 10
    if(!(pScrn->display->virtualY)) {
       pScrn->virtualY = maxv;
       xf86DrvMsg(pScrn->scrnIndex, X_PROBED, str, "height", maxv);
    } else {
       if(maxv < pScrn->display->virtualY) {
	  xf86DrvMsg(pScrn->scrnIndex, X_ERROR, errstr, "height");
	  pI830->FirstYOffs = pI830->SecondYOffs = 0;
       }
    }
}
d733 10
a742 2
#define SDMPTR(x) ((I830ModePrivatePtr)x->currentMode->Private)->merged
#define CDMPTR    ((I830ModePrivatePtr)pI830->currentMode->Private)->merged
d744 14
a757 5
#define BOUND(test,low,hi) 			\
    {						\
	if((test) < (low)) (test) = (low);	\
	if((test) > (hi))  (test) = (hi);	\
    }
d759 6
a764 11
#define REBOUND(low,hi,test)		\
    {					\
	if((test) < (low)) {		\
		(hi) += (test)-(low);	\
		(low) = (test); 	\
	}				\
	if((test) > (hi)) {		\
		(low) += (test)-(hi);	\
		(hi) = (test); 		\
	}				\
    }
d766 4
a769 105

static void
I830MergedPointerMoved(int scrnIndex, int x, int y)
{
  ScrnInfoPtr	pScrn1 = xf86Screens[scrnIndex];
  I830Ptr	pI830 = I830PTR(pScrn1);
  ScrnInfoPtr	pScrn2 = pI830->pScrn_2;
  region	out, in1, in2, f2, f1;
  int		deltax, deltay;
  int		temp1, temp2;
  int		old1x0, old1y0, old2x0, old2y0;
  int		FirstXOffs = 0, FirstYOffs = 0, SecondXOffs = 0, SecondYOffs = 0;
  int		HVirt = pScrn1->virtualX;
  int		VVirt = pScrn1->virtualY;
  int		sigstate;
  Bool		doit = FALSE, HaveNonRect = FALSE, HaveOffsRegions = FALSE;
  int           pos = ((I830MergedDisplayModePtr)pI830->currentMode->Private)->SecondPosition;

  if(pI830->DGAactive) {
     return;
     /* DGA: There is no cursor and no panning while DGA is active. */
  } else {
     FirstXOffs = pI830->FirstXOffs;
     FirstYOffs = pI830->FirstYOffs;
     SecondXOffs = pI830->SecondXOffs;
     SecondYOffs = pI830->SecondYOffs;
     HaveNonRect = pI830->HaveNonRect;
     HaveOffsRegions = pI830->HaveOffsRegions;
  }

  /* Check if the pointer is inside our dead areas */
  if((pI830->MouseRestrictions) && !I830noPanoramiXExtension) {
     if(HaveNonRect) {
	if(InRegion(x, y, pI830->NonRectDead)) {
	   switch(pos) {
	   case PosLeftOf:
	   case PosRightOf: y = pI830->NonRectDead.y0 - 1;
			    doit = TRUE;
			    break;
	   case PosAbove:
	   case PosBelow:   x = pI830->NonRectDead.x0 - 1;
			    doit = TRUE;
	   default:	    break;
	   }
	}
     }
     if(HaveOffsRegions) {
	if(InRegion(x, y, pI830->OffDead1)) {
	   switch(pos) {
	   case PosLeftOf:
	   case PosRightOf: y = pI830->OffDead1.y1;
			    doit = TRUE;
			    break;
	   case PosAbove:
	   case PosBelow:   x = pI830->OffDead1.x1;
			    doit = TRUE;
	   default:	    break;
	   }
	} else if(InRegion(x, y, pI830->OffDead2)) {
	   switch(pos) {
	   case PosLeftOf:
	   case PosRightOf: y = pI830->OffDead2.y0 - 1;
			    doit = TRUE;
			    break;
	   case PosAbove:
	   case PosBelow:   x = pI830->OffDead2.x0 - 1;
			    doit = TRUE;
	   default:	    break;
	   }
	}
     }
     if(doit) {
	UpdateCurrentTime();
	sigstate = xf86BlockSIGIO();
	miPointerAbsoluteCursor(x, y, currentTime.milliseconds);
	xf86UnblockSIGIO(sigstate);
	return;
     }
  }

  f1.x0 = old1x0 = pI830->FirstframeX0;
  f1.x1 = pI830->FirstframeX1;
  f1.y0 = old1y0 = pI830->FirstframeY0;
  f1.y1 = pI830->FirstframeY1;
  f2.x0 = old2x0 = pScrn2->frameX0;
  f2.x1 = pScrn2->frameX1;
  f2.y0 = old2y0 = pScrn2->frameY0;
  f2.y1 = pScrn2->frameY1;

  /* Define the outer region. Crossing this causes all frames to move */
  out.x0 = pScrn1->frameX0;
  out.x1 = pScrn1->frameX1;
  out.y0 = pScrn1->frameY0;
  out.y1 = pScrn1->frameY1;

  /*
   * Define the inner sliding window. Being outsize both frames but
   * inside the outer clipping window will slide corresponding frame
   */
  in1 = out;
  in2 = out;
  switch(pos) {
     case PosLeftOf:
        in1.x0 = f1.x0;
        in2.x1 = f2.x1;
d771 9
a779 13
     case PosRightOf:
        in1.x1 = f1.x1;
        in2.x0 = f2.x0;
        break;
     case PosBelow:
        in1.y1 = f1.y1;
        in2.y0 = f2.y0;
        break;
     case PosAbove:
        in1.y0 = f1.y0;
        in2.y1 = f2.y1;
        break;
  }
d781 7
a787 138
  deltay = 0;
  deltax = 0;

  if(InRegion(x, y, out)) {	/* inside outer region */

     if(InRegion(x, y, in1) && !InRegion(x, y, f1)) {
	REBOUND(f1.x0, f1.x1, x);
	REBOUND(f1.y0, f1.y1, y);
	deltax = 1;
     }
     if(InRegion(x, y, in2) && !InRegion(x, y, f2)) {
	REBOUND(f2.x0, f2.x1, x);
	REBOUND(f2.y0, f2.y1, y);
	deltax = 1;
     }

  } else {			/* outside outer region */

     if(out.x0 > x) {
	deltax = x - out.x0;
     }
     if(out.x1 < x) {
	deltax = x - out.x1;
     }
     if(deltax) {
	pScrn1->frameX0 += deltax;
	pScrn1->frameX1 += deltax;
	f1.x0 += deltax;
	f1.x1 += deltax;
	f2.x0 += deltax;
	f2.x1 += deltax;
     }

     if(out.y0 > y) {
	deltay = y - out.y0;
     }
     if(out.y1 < y) {
	deltay = y - out.y1;
     }
     if(deltay) {
	pScrn1->frameY0 += deltay;
	pScrn1->frameY1 += deltay;
	f1.y0 += deltay;
	f1.y1 += deltay;
	f2.y0 += deltay;
	f2.y1 += deltay;
     }

     switch(pos) {
	case PosLeftOf:
	   if(x >= f1.x0) { REBOUND(f1.y0, f1.y1, y); }
	   if(x <= f2.x1) { REBOUND(f2.y0, f2.y1, y); }
	   break;
	case PosRightOf:
	   if(x <= f1.x1) { REBOUND(f1.y0, f1.y1, y); }
	   if(x >= f2.x0) { REBOUND(f2.y0, f2.y1, y); }
	   break;
	case PosBelow:
	   if(y <= f1.y1) { REBOUND(f1.x0, f1.x1, x); }
	   if(y >= f2.y0) { REBOUND(f2.x0, f2.x1, x); }
	   break;
	case PosAbove:
	   if(y >= f1.y0) { REBOUND(f1.x0, f1.x1, x); }
	   if(y <= f2.y1) { REBOUND(f2.x0, f2.x1, x); }
	   break;
     }

  }

  if(deltax || deltay) {
     pI830->FirstframeX0 = f1.x0;
     pI830->FirstframeY0 = f1.y0;
     pScrn2->frameX0 = f2.x0;
     pScrn2->frameY0 = f2.y0;

     switch(pos) {
	case PosLeftOf:
	case PosRightOf:
	   if(FirstYOffs || SecondYOffs || HaveNonRect) {
	      if(pI830->FirstframeY0 != old1y0) {
	         if(pI830->FirstframeY0 < FirstYOffs)
	            pI830->FirstframeY0 = FirstYOffs;

	         temp1 = pI830->FirstframeY0 + CDMPTR.First->VDisplay;
	         temp2 = min((VVirt - SecondYOffs), (FirstYOffs + pI830->MBXNR1YMAX));
	         if(temp1 > temp2)
	            pI830->FirstframeY0 -= (temp1 - temp2);
	      }
	      if(pScrn2->frameY0 != old2y0) {
	         if(pScrn2->frameY0 < SecondYOffs)
	            pScrn2->frameY0 = SecondYOffs;

	         temp1 = pScrn2->frameY0 + CDMPTR.Second->VDisplay;
	         temp2 = min((VVirt - FirstYOffs), (SecondYOffs + pI830->MBXNR2YMAX));
	         if(temp1 > temp2)
	            pScrn2->frameY0 -= (temp1 - temp2);
	      }
	   }
	   break;
	case PosBelow:
	case PosAbove:
	   if(FirstXOffs || SecondXOffs || HaveNonRect) {
	      if(pI830->FirstframeX0 != old1x0) {
	         if(pI830->FirstframeX0 < FirstXOffs)
	            pI830->FirstframeX0 = FirstXOffs;

	         temp1 = pI830->FirstframeX0 + CDMPTR.First->HDisplay;
	         temp2 = min((HVirt - SecondXOffs), (FirstXOffs + pI830->MBXNR1XMAX));
	         if(temp1 > temp2)
	            pI830->FirstframeX0 -= (temp1 - temp2);
	      }
	      if(pScrn2->frameX0 != old2x0) {
	         if(pScrn2->frameX0 < SecondXOffs)
	            pScrn2->frameX0 = SecondXOffs;

	         temp1 = pScrn2->frameX0 + CDMPTR.Second->HDisplay;
	         temp2 = min((HVirt - FirstXOffs), (SecondXOffs + pI830->MBXNR2XMAX));
	         if(temp1 > temp2)
	            pScrn2->frameX0 -= (temp1 - temp2);
	      }
	   }
	   break;
     }

     pI830->FirstframeX1 = pI830->FirstframeX0 + CDMPTR.First->HDisplay - 1;
     pI830->FirstframeY1 = pI830->FirstframeY0 + CDMPTR.First->VDisplay - 1;
     pScrn2->frameX1   = pScrn2->frameX0   + CDMPTR.Second->HDisplay - 1;
     pScrn2->frameY1   = pScrn2->frameY0   + CDMPTR.Second->VDisplay - 1;

     /* No need to update pScrn1->frame?1, done above */
    if (pI830->pipe == 0) {
       OUTREG(DSPABASE, pI830->FrontBuffer.Start + ((pI830->FirstframeY0 * pScrn1->displayWidth + pI830->FirstframeX0) * pI830->cpp));
       OUTREG(DSPBBASE, pI830->FrontBuffer.Start + ((pScrn2->frameY0 * pScrn1->displayWidth + pScrn2->frameX0) * pI830->cpp));
    } else {
       OUTREG(DSPBBASE, pI830->FrontBuffer.Start + ((pI830->FirstframeY0 * pScrn1->displayWidth + pI830->FirstframeX0) * pI830->cpp));
       OUTREG(DSPABASE, pI830->FrontBuffer.Start + ((pScrn2->frameY0 * pScrn1->displayWidth + pScrn2->frameX0) * pI830->cpp));
    }
  }
d791 1
a791 1
I830AdjustFrameMerged(int scrnIndex, int x, int y, int flags)
d793 2
a794 27
    ScrnInfoPtr pScrn1 = xf86Screens[scrnIndex];
    I830Ptr pI830 = I830PTR(pScrn1);
    ScrnInfoPtr pScrn2 = pI830->pScrn_2;
    int HTotal = pI830->currentMode->HDisplay;
    int VTotal = pI830->currentMode->VDisplay;
    int HMax = HTotal;
    int VMax = VTotal;
    int HVirt = pScrn1->virtualX;
    int VVirt = pScrn1->virtualY;
    int x1 = x, x2 = x;
    int y1 = y, y2 = y;
    int FirstXOffs = 0, FirstYOffs = 0, SecondXOffs = 0, SecondYOffs = 0;
    int MBXNR1XMAX = 65536, MBXNR1YMAX = 65536, MBXNR2XMAX = 65536, MBXNR2YMAX = 65536;

    if(pI830->DGAactive) {
       HVirt = pScrn1->displayWidth;
       VVirt = pScrn1->virtualY;
    } else {
       FirstXOffs = pI830->FirstXOffs;
       FirstYOffs = pI830->FirstYOffs;
       SecondXOffs = pI830->SecondXOffs;
       SecondYOffs = pI830->SecondYOffs;
       MBXNR1XMAX = pI830->MBXNR1XMAX;
       MBXNR1YMAX = pI830->MBXNR1YMAX;
       MBXNR2XMAX = pI830->MBXNR2XMAX;
       MBXNR2YMAX = pI830->MBXNR2YMAX;
    }
d796 4
a799 33
    BOUND(x, 0, HVirt - HTotal);
    BOUND(y, 0, VVirt - VTotal);
    BOUND(x1, FirstXOffs, min(HVirt, MBXNR1XMAX + FirstXOffs) - min(HTotal, MBXNR1XMAX) - SecondXOffs);
    BOUND(y1, FirstYOffs, min(VVirt, MBXNR1YMAX + FirstYOffs) - min(VTotal, MBXNR1YMAX) - SecondYOffs);
    BOUND(x2, SecondXOffs, min(HVirt, MBXNR2XMAX + SecondXOffs) - min(HTotal, MBXNR2XMAX) - FirstXOffs);
    BOUND(y2, SecondYOffs, min(VVirt, MBXNR2YMAX + SecondYOffs) - min(VTotal, MBXNR2YMAX) - FirstYOffs);

    switch(SDMPTR(pScrn1).SecondPosition) {
        case PosLeftOf:
            pScrn2->frameX0 = x2;
            BOUND(pScrn2->frameY0,   y2, y2 + min(VMax, MBXNR2YMAX) - CDMPTR.Second->VDisplay);
            pI830->FirstframeX0 = x1 + CDMPTR.Second->HDisplay;
            BOUND(pI830->FirstframeY0, y1, y1 + min(VMax, MBXNR1YMAX) - CDMPTR.First->VDisplay);
            break;
        case PosRightOf:
            pI830->FirstframeX0 = x1;
            BOUND(pI830->FirstframeY0, y1, y1 + min(VMax, MBXNR1YMAX) - CDMPTR.First->VDisplay);
            pScrn2->frameX0 = x2 + CDMPTR.First->HDisplay;
            BOUND(pScrn2->frameY0,   y2, y2 + min(VMax, MBXNR2YMAX) - CDMPTR.Second->VDisplay);
            break;
        case PosAbove:
            BOUND(pScrn2->frameX0,   x2, x2 + min(HMax, MBXNR2XMAX) - CDMPTR.Second->HDisplay);
            pScrn2->frameY0 = y2;
            BOUND(pI830->FirstframeX0, x1, x1 + min(HMax, MBXNR1XMAX) - CDMPTR.First->HDisplay);
            pI830->FirstframeY0 = y1 + CDMPTR.Second->VDisplay;
            break;
        case PosBelow:
            BOUND(pI830->FirstframeX0, x1, x1 + min(HMax, MBXNR1XMAX) - CDMPTR.First->HDisplay);
            pI830->FirstframeY0 = y1;
            BOUND(pScrn2->frameX0,   x2, x2 + min(HMax, MBXNR2XMAX) - CDMPTR.Second->HDisplay);
            pScrn2->frameY0 = y2 + CDMPTR.First->VDisplay;
            break;
    }
d801 10
a810 17
    BOUND(pI830->FirstframeX0, 0, HVirt - CDMPTR.First->HDisplay);
    BOUND(pI830->FirstframeY0, 0, VVirt - CDMPTR.First->VDisplay);
    BOUND(pScrn2->frameX0,   0, HVirt - CDMPTR.Second->HDisplay);
    BOUND(pScrn2->frameY0,   0, VVirt - CDMPTR.Second->VDisplay);

    pScrn1->frameX0 = x;
    pScrn1->frameY0 = y;

    pI830->FirstframeX1 = pI830->FirstframeX0 + CDMPTR.First->HDisplay - 1;
    pI830->FirstframeY1 = pI830->FirstframeY0 + CDMPTR.First->VDisplay - 1;
    pScrn2->frameX1   = pScrn2->frameX0   + CDMPTR.Second->HDisplay - 1;
    pScrn2->frameY1   = pScrn2->frameY0   + CDMPTR.Second->VDisplay - 1;

    pScrn1->frameX1   = pScrn1->frameX0   + pI830->currentMode->HDisplay  - 1;
    pScrn1->frameY1   = pScrn1->frameY0   + pI830->currentMode->VDisplay  - 1;
    pScrn1->frameX1 += FirstXOffs + SecondXOffs;
    pScrn1->frameY1 += FirstYOffs + SecondYOffs;
d813 8
a820 3
/* Pseudo-Xinerama extension for MergedFB mode */
static void
I830UpdateXineramaScreenInfo(ScrnInfoPtr pScrn1)
d822 2
a823 10
    I830Ptr pI830 = I830PTR(pScrn1);
    int scrnnum1 = 0, scrnnum2 = 1;
    int x1=0, x2=0, y1=0, y2=0, h1=0, h2=0, w1=0, w2=0;
    int realvirtX, realvirtY;
    DisplayModePtr currentMode, firstMode;
    Bool infochanged = FALSE;
    Bool usenonrect = pI830->NonRect;
    const char *rectxine = "\t... setting up rectangular Xinerama layout\n";
#ifdef XF86DRI
    drmI830Sarea *sarea = NULL;
d825 3
a827 4
    if (pI830->directRenderingEnabled) {
       sarea = (drmI830Sarea *) DRIGetSAREAPrivate(pScrn1->pScreen);
    }
#endif
d829 1
a829 2
    pI830->MBXNR1XMAX = pI830->MBXNR1YMAX = pI830->MBXNR2XMAX = pI830->MBXNR2YMAX = 65536;
    pI830->HaveNonRect = pI830->HaveOffsRegions = FALSE;
d831 1
a831 366
    if(!pI830->MergedFB) {
#ifdef XF86DRI
       if (pI830->directRenderingEnabled) {
          sarea->pipeA_x = sarea->pipeA_y = sarea->pipeB_x = sarea->pipeB_y = 0;

          if (pI830->planeEnabled[0]) {
             sarea->pipeA_w = pScrn1->virtualX;
             sarea->pipeA_h = pScrn1->virtualY;
          } else {
             sarea->pipeA_w = 0;
             sarea->pipeA_h = 0;
          }

          if (pI830->planeEnabled[1]) {
             sarea->pipeB_w = pScrn1->virtualX;
             sarea->pipeB_h = pScrn1->virtualY;
          } else {
             sarea->pipeB_w = 0;
             sarea->pipeB_h = 0;
          }
       }
#endif

       return;
    }

    if (I830noPanoramiXExtension || !I830XineramadataPtr) {
#ifdef XF86DRI
       if (!pI830->directRenderingEnabled)
#endif
	  return;
    }

    if(pI830->SecondIsScrn0) {
       scrnnum1 = 1;
       scrnnum2 = 0;
    }

    /* Attention: Usage of RandR may lead to virtual X and Y dimensions
     * actually smaller than our MetaModes. To avoid this, we calculate
     * the max* fields here (and not somewhere else, like in CopyNLink)
     *
     * *** Note: RandR is disabled if one of CRTxxOffs is non-zero.
     */

    /* "Real" virtual: Virtual without the Offset */
    realvirtX = pScrn1->virtualX - pI830->FirstXOffs - pI830->SecondXOffs;
    realvirtY = pScrn1->virtualY - pI830->FirstYOffs - pI830->SecondYOffs;

    if((pI830->I830XineramaVX != pScrn1->virtualX) || (pI830->I830XineramaVY != pScrn1->virtualY)) {

       if(!(pScrn1->modes)) return;

       pI830->maxFirst_X1 = pI830->maxFirst_X2 = 0;
       pI830->maxFirst_Y1 = pI830->maxFirst_Y2 = 0;
       pI830->maxSecond_X1 = pI830->maxSecond_X2 = 0;
       pI830->maxSecond_Y1 = pI830->maxSecond_Y2 = 0;

       currentMode = firstMode = pScrn1->modes;

       do {

          DisplayModePtr p = currentMode->next;
          DisplayModePtr i = ((I830ModePrivatePtr)currentMode->Private)->merged.First;
          DisplayModePtr j = ((I830ModePrivatePtr)currentMode->Private)->merged.Second;

          if((currentMode->HDisplay <= realvirtX) && (currentMode->VDisplay <= realvirtY) &&
	     (i->HDisplay <= realvirtX) && (j->HDisplay <= realvirtX) &&
	     (i->VDisplay <= realvirtY) && (j->VDisplay <= realvirtY)) {

		if(pI830->maxFirst_X1 == i->HDisplay) {
		   if(pI830->maxFirst_X2 < j->HDisplay) {
		      pI830->maxFirst_X2 = j->HDisplay;   /* Widest Second mode displayed with widest CRT1 mode */
		   }
		} else if(pI830->maxFirst_X1 < i->HDisplay) {
		   pI830->maxFirst_X1 = i->HDisplay;      /* Widest CRT1 mode */
		   pI830->maxFirst_X2 = j->HDisplay;
		}
		if(pI830->maxSecond_X2 == j->HDisplay) {
		   if(pI830->maxSecond_X1 < i->HDisplay) {
		      pI830->maxSecond_X1 = i->HDisplay;   /* Widest First mode displayed with widest Second mode */
		   }
		} else if(pI830->maxSecond_X2 < j->HDisplay) {
		   pI830->maxSecond_X2 = j->HDisplay;      /* Widest Second mode */
		   pI830->maxSecond_X1 = i->HDisplay;
		}
		if(pI830->maxFirst_Y1 == i->VDisplay) {   /* Same as above, but tallest instead of widest */
		   if(pI830->maxFirst_Y2 < j->VDisplay) {
		      pI830->maxFirst_Y2 = j->VDisplay;
		   }
		} else if(pI830->maxFirst_Y1 < i->VDisplay) {
		   pI830->maxFirst_Y1 = i->VDisplay;
		   pI830->maxFirst_Y2 = j->VDisplay;
		}
		if(pI830->maxSecond_Y2 == j->VDisplay) {
		   if(pI830->maxSecond_Y1 < i->VDisplay) {
		      pI830->maxSecond_Y1 = i->VDisplay;
		   }
		} else if(pI830->maxSecond_Y2 < j->VDisplay) {
		   pI830->maxSecond_Y2 = j->VDisplay;
		   pI830->maxSecond_Y1 = i->VDisplay;
		}
	  }
	  currentMode = p;

       } while((currentMode) && (currentMode != firstMode));

       pI830->I830XineramaVX = pScrn1->virtualX;
       pI830->I830XineramaVY = pScrn1->virtualY;
       infochanged = TRUE;

    }

    if((usenonrect) && pI830->maxFirst_X1) {
       switch(pI830->SecondPosition) {
       case PosLeftOf:
       case PosRightOf:
	  if((pI830->maxFirst_Y1 != realvirtY) && (pI830->maxSecond_Y2 != realvirtY)) {
	     usenonrect = FALSE;
	  }
	  break;
       case PosAbove:
       case PosBelow:
	  if((pI830->maxFirst_X1 != realvirtX) && (pI830->maxSecond_X2 != realvirtX)) {
	     usenonrect = FALSE;
	  }
	  break;
       }
       if(infochanged && !usenonrect) {
	  xf86DrvMsg(pScrn1->scrnIndex, X_INFO,
			"Virtual screen size does not match maximum display modes...\n");
	  xf86DrvMsg(pScrn1->scrnIndex, X_INFO, rectxine);

       }
    } else if(infochanged && usenonrect) {
       usenonrect = FALSE;
       xf86DrvMsg(pScrn1->scrnIndex, X_INFO,
		"Only clone modes available for this virtual screen size...\n");
       xf86DrvMsg(pScrn1->scrnIndex, X_INFO, rectxine);
    }

    if(pI830->maxFirst_X1) {		/* Means we have at least one non-clone mode */
       switch(pI830->SecondPosition) {
       case PosLeftOf:
	  x1 = min(pI830->maxFirst_X2, pScrn1->virtualX - pI830->maxFirst_X1);
	  if(x1 < 0) x1 = 0;
	  y1 = pI830->FirstYOffs;
	  w1 = pScrn1->virtualX - x1;
	  h1 = realvirtY;
	  if((usenonrect) && (pI830->maxFirst_Y1 != realvirtY)) {
	     h1 = pI830->MBXNR1YMAX = pI830->maxFirst_Y1;
	     pI830->NonRectDead.x0 = x1;
	     pI830->NonRectDead.x1 = x1 + w1 - 1;
	     pI830->NonRectDead.y0 = y1 + h1;
	     pI830->NonRectDead.y1 = pScrn1->virtualY - 1;
	     pI830->HaveNonRect = TRUE;
	  }
	  x2 = 0;
	  y2 = pI830->SecondYOffs;
	  w2 = max(pI830->maxSecond_X2, pScrn1->virtualX - pI830->maxSecond_X1);
	  if(w2 > pScrn1->virtualX) w2 = pScrn1->virtualX;
	  h2 = realvirtY;
	  if((usenonrect) && (pI830->maxSecond_Y2 != realvirtY)) {
	     h2 = pI830->MBXNR2YMAX = pI830->maxSecond_Y2;
	     pI830->NonRectDead.x0 = x2;
	     pI830->NonRectDead.x1 = x2 + w2 - 1;
	     pI830->NonRectDead.y0 = y2 + h2;
	     pI830->NonRectDead.y1 = pScrn1->virtualY - 1;
	     pI830->HaveNonRect = TRUE;
	  }
	  break;
       case PosRightOf:
	  x1 = 0;
	  y1 = pI830->FirstYOffs;
	  w1 = max(pI830->maxFirst_X1, pScrn1->virtualX - pI830->maxFirst_X2);
	  if(w1 > pScrn1->virtualX) w1 = pScrn1->virtualX;
	  h1 = realvirtY;
	  if((usenonrect) && (pI830->maxFirst_Y1 != realvirtY)) {
	     h1 = pI830->MBXNR1YMAX = pI830->maxFirst_Y1;
	     pI830->NonRectDead.x0 = x1;
	     pI830->NonRectDead.x1 = x1 + w1 - 1;
	     pI830->NonRectDead.y0 = y1 + h1;
	     pI830->NonRectDead.y1 = pScrn1->virtualY - 1;
	     pI830->HaveNonRect = TRUE;
	  }
	  x2 = min(pI830->maxSecond_X1, pScrn1->virtualX - pI830->maxSecond_X2);
	  if(x2 < 0) x2 = 0;
	  y2 = pI830->SecondYOffs;
	  w2 = pScrn1->virtualX - x2;
	  h2 = realvirtY;
	  if((usenonrect) && (pI830->maxSecond_Y2 != realvirtY)) {
	     h2 = pI830->MBXNR2YMAX = pI830->maxSecond_Y2;
	     pI830->NonRectDead.x0 = x2;
	     pI830->NonRectDead.x1 = x2 + w2 - 1;
	     pI830->NonRectDead.y0 = y2 + h2;
	     pI830->NonRectDead.y1 = pScrn1->virtualY - 1;
	     pI830->HaveNonRect = TRUE;
	  }
	  break;
       case PosAbove:
	  x1 = pI830->FirstXOffs;
	  y1 = min(pI830->maxFirst_Y2, pScrn1->virtualY - pI830->maxFirst_Y1);
	  if(y1 < 0) y1 = 0;
	  w1 = realvirtX;
	  h1 = pScrn1->virtualY - y1;
	  if((usenonrect) && (pI830->maxFirst_X1 != realvirtX)) {
	     w1 = pI830->MBXNR1XMAX = pI830->maxFirst_X1;
	     pI830->NonRectDead.x0 = x1 + w1;
	     pI830->NonRectDead.x1 = pScrn1->virtualX - 1;
	     pI830->NonRectDead.y0 = y1;
	     pI830->NonRectDead.y1 = y1 + h1 - 1;
	     pI830->HaveNonRect = TRUE;
	  }
	  x2 = pI830->SecondXOffs;
	  y2 = 0;
	  w2 = realvirtX;
	  h2 = max(pI830->maxSecond_Y2, pScrn1->virtualY - pI830->maxSecond_Y1);
	  if(h2 > pScrn1->virtualY) h2 = pScrn1->virtualY;
	  if((usenonrect) && (pI830->maxSecond_X2 != realvirtX)) {
	     w2 = pI830->MBXNR2XMAX = pI830->maxSecond_X2;
	     pI830->NonRectDead.x0 = x2 + w2;
	     pI830->NonRectDead.x1 = pScrn1->virtualX - 1;
	     pI830->NonRectDead.y0 = y2;
	     pI830->NonRectDead.y1 = y2 + h2 - 1;
	     pI830->HaveNonRect = TRUE;
	  }
	  break;
       case PosBelow:
	  x1 = pI830->FirstXOffs;
	  y1 = 0;
	  w1 = realvirtX;
	  h1 = max(pI830->maxFirst_Y1, pScrn1->virtualY - pI830->maxFirst_Y2);
	  if(h1 > pScrn1->virtualY) h1 = pScrn1->virtualY;
	  if((usenonrect) && (pI830->maxFirst_X1 != realvirtX)) {
	     w1 = pI830->MBXNR1XMAX = pI830->maxFirst_X1;
	     pI830->NonRectDead.x0 = x1 + w1;
	     pI830->NonRectDead.x1 = pScrn1->virtualX - 1;
	     pI830->NonRectDead.y0 = y1;
	     pI830->NonRectDead.y1 = y1 + h1 - 1;
	     pI830->HaveNonRect = TRUE;
	  }
	  x2 = pI830->SecondXOffs;
	  y2 = min(pI830->maxSecond_Y1, pScrn1->virtualY - pI830->maxSecond_Y2);
	  if(y2 < 0) y2 = 0;
	  w2 = realvirtX;
	  h2 = pScrn1->virtualY - y2;
	  if((usenonrect) && (pI830->maxSecond_X2 != realvirtX)) {
	     w2 = pI830->MBXNR2XMAX = pI830->maxSecond_X2;
	     pI830->NonRectDead.x0 = x2 + w2;
	     pI830->NonRectDead.x1 = pScrn1->virtualX - 1;
	     pI830->NonRectDead.y0 = y2;
	     pI830->NonRectDead.y1 = y2 + h2 - 1;
	     pI830->HaveNonRect = TRUE;
	  }
       default:
	  break;
       }

       switch(pI830->SecondPosition) {
       case PosLeftOf:
       case PosRightOf:
	  if(pI830->FirstYOffs) {
	     pI830->OffDead1.x0 = x1;
	     pI830->OffDead1.x1 = x1 + w1 - 1;
	     pI830->OffDead1.y0 = 0;
	     pI830->OffDead1.y1 = y1 - 1;
	     pI830->OffDead2.x0 = x2;
	     pI830->OffDead2.x1 = x2 + w2 - 1;
	     pI830->OffDead2.y0 = y2 + h2;
	     pI830->OffDead2.y1 = pScrn1->virtualY - 1;
	     pI830->HaveOffsRegions = TRUE;
	  } else if(pI830->SecondYOffs) {
	     pI830->OffDead1.x0 = x2;
	     pI830->OffDead1.x1 = x2 + w2 - 1;
	     pI830->OffDead1.y0 = 0;
	     pI830->OffDead1.y1 = y2 - 1;
	     pI830->OffDead2.x0 = x1;
	     pI830->OffDead2.x1 = x1 + w1 - 1;
	     pI830->OffDead2.y0 = y1 + h1;
	     pI830->OffDead2.y1 = pScrn1->virtualY - 1;
	     pI830->HaveOffsRegions = TRUE;
	  }
	  break;
       case PosAbove:
       case PosBelow:
	  if(pI830->FirstXOffs) {
	     pI830->OffDead1.x0 = x2 + w2;
	     pI830->OffDead1.x1 = pScrn1->virtualX - 1;
	     pI830->OffDead1.y0 = y2;
	     pI830->OffDead1.y1 = y2 + h2 - 1;
	     pI830->OffDead2.x0 = 0;
	     pI830->OffDead2.x1 = x1 - 1;
	     pI830->OffDead2.y0 = y1;
	     pI830->OffDead2.y1 = y1 + h1 - 1;
	     pI830->HaveOffsRegions = TRUE;
	  } else if(pI830->SecondXOffs) {
	     pI830->OffDead1.x0 = x1 + w1;
	     pI830->OffDead1.x1 = pScrn1->virtualX - 1;
	     pI830->OffDead1.y0 = y1;
	     pI830->OffDead1.y1 = y1 + h1 - 1;
	     pI830->OffDead2.x0 = 0;
	     pI830->OffDead2.x1 = x2 - 1;
	     pI830->OffDead2.y0 = y2;
	     pI830->OffDead2.y1 = y2 + h2 - 1;
	     pI830->HaveOffsRegions = TRUE;
	  }
       default:
	  break;
       }

    }

#ifdef XF86DRI
    if (pI830->directRenderingEnabled) {
       sarea->pipeA_x = x1;
       sarea->pipeA_y = y1;
       sarea->pipeA_w = w1;
       sarea->pipeA_h = h1;
       sarea->pipeB_x = x2;
       sarea->pipeB_y = y2;
       sarea->pipeB_w = w2;
       sarea->pipeB_h = h2;
    }
#endif

    if (I830XineramadataPtr && !I830noPanoramiXExtension) {
       I830XineramadataPtr[scrnnum1].x = x1;
       I830XineramadataPtr[scrnnum1].y = y1;
       I830XineramadataPtr[scrnnum1].width = w1;
       I830XineramadataPtr[scrnnum1].height = h1;
       I830XineramadataPtr[scrnnum2].x = x2;
       I830XineramadataPtr[scrnnum2].y = y2;
       I830XineramadataPtr[scrnnum2].width = w2;
       I830XineramadataPtr[scrnnum2].height = h2;
    } else
       return;

    if(infochanged) {
       xf86DrvMsg(pScrn1->scrnIndex, X_INFO,
	  "Pseudo-Xinerama: First (Screen %d) (%d,%d)-(%d,%d)\n",
	  scrnnum1, x1, y1, w1+x1-1, h1+y1-1);
       xf86DrvMsg(pScrn1->scrnIndex, X_INFO,
	  "Pseudo-Xinerama: Second (Screen %d) (%d,%d)-(%d,%d)\n",
	  scrnnum2, x2, y2, w2+x2-1, h2+y2-1);
       if(pI830->HaveNonRect) {
	  xf86DrvMsg(pScrn1->scrnIndex, X_INFO,
		"Pseudo-Xinerama: Inaccessible area (%d,%d)-(%d,%d)\n",
		pI830->NonRectDead.x0, pI830->NonRectDead.y0,
		pI830->NonRectDead.x1, pI830->NonRectDead.y1);
       }
       if(pI830->HaveOffsRegions) {
	  xf86DrvMsg(pScrn1->scrnIndex, X_INFO,
		"Pseudo-Xinerama: Inaccessible offset area (%d,%d)-(%d,%d)\n",
		pI830->OffDead1.x0, pI830->OffDead1.y0,
		pI830->OffDead1.x1, pI830->OffDead1.y1);
	  xf86DrvMsg(pScrn1->scrnIndex, X_INFO,
		"Pseudo-Xinerama: Inaccessible offset area (%d,%d)-(%d,%d)\n",
		pI830->OffDead2.x0, pI830->OffDead2.y0,
		pI830->OffDead2.x1, pI830->OffDead2.y1);
       }
       if(pI830->HaveNonRect || pI830->HaveOffsRegions) {
	  xf86DrvMsg(pScrn1->scrnIndex, X_INFO,
		"Mouse restriction for inaccessible areas is %s\n",
		pI830->MouseRestrictions ? "enabled" : "disabled");
       }
    }
a833 2
/* Proc */

d835 1
a835 1
I830ProcXineramaQueryVersion(ClientPtr client)
d837 3
a839 2
    xPanoramiXQueryVersionReply	  rep;
    register int		  n;
d841 6
a846 11
    REQUEST_SIZE_MATCH(xPanoramiXQueryVersionReq);
    rep.type = X_Reply;
    rep.length = 0;
    rep.sequenceNumber = client->sequence;
    rep.majorVersion = 1;
    rep.minorVersion = 0;
    if(client->swapped) {
        swaps(&rep.sequenceNumber, n);
        swapl(&rep.length, n);
        swaps(&rep.majorVersion, n);
        swaps(&rep.minorVersion, n);
d848 1
a848 2
    WriteToClient(client, sizeof(xPanoramiXQueryVersionReply), (char *)&rep);
    return (client->noClientException);
d851 8
a858 2
int
I830ProcXineramaGetState(ClientPtr client)
d860 4
a863 21
    REQUEST(xPanoramiXGetStateReq);
    WindowPtr			pWin;
    xPanoramiXGetStateReply	rep;
    register int		n;

    REQUEST_SIZE_MATCH(xPanoramiXGetStateReq);
    pWin = LookupWindow(stuff->window, client);
    if(!pWin) return BadWindow;

    rep.type = X_Reply;
    rep.length = 0;
    rep.sequenceNumber = client->sequence;
    rep.state = !I830noPanoramiXExtension;
    if(client->swapped) {
       swaps (&rep.sequenceNumber, n);
       swapl (&rep.length, n);
       swaps (&rep.state, n);
    }
    WriteToClient(client, sizeof(xPanoramiXGetStateReply), (char *)&rep);
    return client->noClientException;
}
d865 2
a866 24
int
I830ProcXineramaGetScreenCount(ClientPtr client)
{
    REQUEST(xPanoramiXGetScreenCountReq);
    WindowPtr				pWin;
    xPanoramiXGetScreenCountReply	rep;
    register int			n;

    REQUEST_SIZE_MATCH(xPanoramiXGetScreenCountReq);
    pWin = LookupWindow(stuff->window, client);
    if(!pWin) return BadWindow;

    rep.type = X_Reply;
    rep.length = 0;
    rep.sequenceNumber = client->sequence;
    rep.ScreenCount = I830XineramaNumScreens;
    if(client->swapped) {
       swaps(&rep.sequenceNumber, n);
       swapl(&rep.length, n);
       swaps(&rep.ScreenCount, n);
    }
    WriteToClient(client, sizeof(xPanoramiXGetScreenCountReply), (char *)&rep);
    return client->noClientException;
}
d868 3
a870 26
int
I830ProcXineramaGetScreenSize(ClientPtr client)
{
    REQUEST(xPanoramiXGetScreenSizeReq);
    WindowPtr				pWin;
    xPanoramiXGetScreenSizeReply	rep;
    register int			n;

    REQUEST_SIZE_MATCH(xPanoramiXGetScreenSizeReq);
    pWin = LookupWindow (stuff->window, client);
    if(!pWin)  return BadWindow;

    rep.type = X_Reply;
    rep.length = 0;
    rep.sequenceNumber = client->sequence;
    rep.width  = I830XineramadataPtr[stuff->screen].width;
    rep.height = I830XineramadataPtr[stuff->screen].height;
    if(client->swapped) {
       swaps(&rep.sequenceNumber, n);
       swapl(&rep.length, n);
       swaps(&rep.width, n);
       swaps(&rep.height, n);
    }
    WriteToClient(client, sizeof(xPanoramiXGetScreenSizeReply), (char *)&rep);
    return client->noClientException;
}
d872 14
a885 4
int
I830ProcXineramaIsActive(ClientPtr client)
{
    xXineramaIsActiveReply	rep;
d887 8
a894 1
    REQUEST_SIZE_MATCH(xXineramaIsActiveReq);
d896 6
a901 12
    rep.type = X_Reply;
    rep.length = 0;
    rep.sequenceNumber = client->sequence;
    rep.state = !I830noPanoramiXExtension;
    if(client->swapped) {
	register int n;
	swaps(&rep.sequenceNumber, n);
	swapl(&rep.length, n);
	swapl(&rep.state, n);
    }
    WriteToClient(client, sizeof(xXineramaIsActiveReply), (char *) &rep);
    return client->noClientException;
d904 2
a905 2
int
I830ProcXineramaQueryScreens(ClientPtr client)
d907 2
a908 1
    xXineramaQueryScreensReply	rep;
d910 3
a912 1
    REQUEST_SIZE_MATCH(xXineramaQueryScreensReq);
d914 3
a916 11
    rep.type = X_Reply;
    rep.sequenceNumber = client->sequence;
    rep.number = (I830noPanoramiXExtension) ? 0 : I830XineramaNumScreens;
    rep.length = rep.number * sz_XineramaScreenInfo >> 2;
    if(client->swapped) {
       register int n;
       swaps(&rep.sequenceNumber, n);
       swapl(&rep.length, n);
       swapl(&rep.number, n);
    }
    WriteToClient(client, sizeof(xXineramaQueryScreensReply), (char *)&rep);
d918 5
a922 19
    if(!I830noPanoramiXExtension) {
       xXineramaScreenInfo scratch;
       int i;

       for(i = 0; i < I830XineramaNumScreens; i++) {
	  scratch.x_org  = I830XineramadataPtr[i].x;
	  scratch.y_org  = I830XineramadataPtr[i].y;
	  scratch.width  = I830XineramadataPtr[i].width;
	  scratch.height = I830XineramadataPtr[i].height;
	  if(client->swapped) {
	     register int n;
	     swaps(&scratch.x_org, n);
	     swaps(&scratch.y_org, n);
	     swaps(&scratch.width, n);
	     swaps(&scratch.height, n);
	  }
	  WriteToClient(client, sz_XineramaScreenInfo, (char *)&scratch);
       }
    }
a923 2
    return client->noClientException;
}
d925 2
a926 2
static int
I830ProcXineramaDispatch(ClientPtr client)
d928 8
a935 17
    REQUEST(xReq);
    switch (stuff->data) {
	case X_PanoramiXQueryVersion:
	     return I830ProcXineramaQueryVersion(client);
	case X_PanoramiXGetState:
	     return I830ProcXineramaGetState(client);
	case X_PanoramiXGetScreenCount:
	     return I830ProcXineramaGetScreenCount(client);
	case X_PanoramiXGetScreenSize:
	     return I830ProcXineramaGetScreenSize(client);
	case X_XineramaIsActive:
	     return I830ProcXineramaIsActive(client);
	case X_XineramaQueryScreens:
	     return I830ProcXineramaQueryScreens(client);
    }
    return BadRequest;
}
d937 5
a941 1
/* SProc */
d943 5
a947 8
static int
I830SProcXineramaQueryVersion (ClientPtr client)
{
    REQUEST(xPanoramiXQueryVersionReq);
    register int n;
    swaps(&stuff->length,n);
    REQUEST_SIZE_MATCH (xPanoramiXQueryVersionReq);
    return I830ProcXineramaQueryVersion(client);
d950 2
a951 2
static int
I830SProcXineramaGetState(ClientPtr client)
d953 16
a968 5
    REQUEST(xPanoramiXGetStateReq);
    register int n;
    swaps (&stuff->length, n);
    REQUEST_SIZE_MATCH(xPanoramiXGetStateReq);
    return I830ProcXineramaGetState(client);
d971 2
a972 2
static int
I830SProcXineramaGetScreenCount(ClientPtr client)
d974 6
a979 6
    REQUEST(xPanoramiXGetScreenCountReq);
    register int n;
    swaps (&stuff->length, n);
    REQUEST_SIZE_MATCH(xPanoramiXGetScreenCountReq);
    return I830ProcXineramaGetScreenCount(client);
}
d981 1
a981 8
static int
I830SProcXineramaGetScreenSize(ClientPtr client)
{
    REQUEST(xPanoramiXGetScreenSizeReq);
    register int n;
    swaps (&stuff->length, n);
    REQUEST_SIZE_MATCH(xPanoramiXGetScreenSizeReq);
    return I830ProcXineramaGetScreenSize(client);
d984 2
a985 2
static int
I830SProcXineramaIsActive(ClientPtr client)
d987 3
a989 5
    REQUEST(xXineramaIsActiveReq);
    register int n;
    swaps (&stuff->length, n);
    REQUEST_SIZE_MATCH(xXineramaIsActiveReq);
    return I830ProcXineramaIsActive(client);
d992 3
a994 9
static int
I830SProcXineramaQueryScreens(ClientPtr client)
{
    REQUEST(xXineramaQueryScreensReq);
    register int n;
    swaps (&stuff->length, n);
    REQUEST_SIZE_MATCH(xXineramaQueryScreensReq);
    return I830ProcXineramaQueryScreens(client);
}
d996 2
a997 20
int
I830SProcXineramaDispatch(ClientPtr client)
{
    REQUEST(xReq);
    switch (stuff->data) {
	case X_PanoramiXQueryVersion:
	     return I830SProcXineramaQueryVersion(client);
	case X_PanoramiXGetState:
	     return I830SProcXineramaGetState(client);
	case X_PanoramiXGetScreenCount:
	     return I830SProcXineramaGetScreenCount(client);
	case X_PanoramiXGetScreenSize:
	     return I830SProcXineramaGetScreenSize(client);
	case X_XineramaIsActive:
	     return I830SProcXineramaIsActive(client);
	case X_XineramaQueryScreens:
	     return I830SProcXineramaQueryScreens(client);
    }
    return BadRequest;
}
d999 8
d1008 1
a1008 1
I830XineramaResetProc(ExtensionEntry* extEntry)
d1010 9
a1018 5
    /* Called by CloseDownExtensions() */
    if(I830XineramadataPtr) {
       Xfree(I830XineramadataPtr);
       I830XineramadataPtr = NULL;
    }
d1021 9
a1029 2
static void
I830XineramaExtensionInit(ScrnInfoPtr pScrn)
d1031 16
a1046 2
    I830Ptr	pI830 = I830PTR(pScrn);
    Bool	success = FALSE;
d1048 2
a1049 1
    if(!(I830XineramadataPtr)) {
d1051 4
a1054 5
       if(!pI830->MergedFB) {
	  I830noPanoramiXExtension = TRUE;
	  pI830->MouseRestrictions = FALSE;
	  return;
       }
d1056 4
a1059 9
#ifdef PANORAMIX
       if(!noPanoramiXExtension) {
	  xf86DrvMsg(pScrn->scrnIndex, X_INFO,
	     "Xinerama active, not initializing Intel Pseudo-Xinerama\n");
	  I830noPanoramiXExtension = TRUE;
	  pI830->MouseRestrictions = FALSE;
	  return;
       }
#endif
d1061 1
a1061 6
       if(I830noPanoramiXExtension) {
	  xf86DrvMsg(pScrn->scrnIndex, X_INFO,
	      "Intel Pseudo-Xinerama disabled\n");
	  pI830->MouseRestrictions = FALSE;
	  return;
       }
d1063 4
a1066 1
       I830XineramaNumScreens = 2;
d1068 4
a1071 1
       while(I830XineramaGeneration != serverGeneration) {
d1073 3
a1075 5
	  pI830->XineramaExtEntry = AddExtension(PANORAMIX_PROTOCOL_NAME, 0,0,
					I830ProcXineramaDispatch,
					I830SProcXineramaDispatch,
					I830XineramaResetProc,
					StandardMinorOpcode);
d1077 3
a1079 1
	  if(!pI830->XineramaExtEntry) break;
d1081 3
a1083 2
	  if(!(I830XineramadataPtr = (I830XineramaData *)
	        xcalloc(I830XineramaNumScreens, sizeof(I830XineramaData)))) break;
d1085 1
a1085 3
	  I830XineramaGeneration = serverGeneration;
	  success = TRUE;
       }
d1087 2
a1088 7
       if(!success) {
          xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
	      "Failed to initialize Intel Pseudo-Xinerama extension\n");
	  I830noPanoramiXExtension = TRUE;
	  pI830->MouseRestrictions = FALSE;
	  return;
       }
d1090 5
a1094 2
       xf86DrvMsg(pScrn->scrnIndex, X_INFO,
	  "Intel Pseudo-Xinerama extension initialized\n");
d1096 7
a1102 2
       pI830->I830XineramaVX = 0;
       pI830->I830XineramaVY = 0;
d1104 4
a1107 2
    }
}
d1109 3
a1111 1869
static void
I830BIOSProbeDDC(ScrnInfoPtr pScrn, int index)
{
   vbeInfoPtr pVbe;

   /* The vbe module gets loaded in PreInit(), so no need to load it here. */

   pVbe = VBEInit(NULL, index);
   ConfiguredMonitor = vbeDoEDID(pVbe, NULL);
}

/* Various extended video BIOS functions. 
 * 100 and 120Hz aren't really supported, they work but only get close
 * to the requested refresh, and really not close enough.
 * I've seen 100Hz come out at 104Hz, and 120Hz come out at 128Hz */
const int i830refreshes[] = {
   43, 56, 60, 70, 72, 75, 85 /* 100, 120 */
};
static const int nrefreshes = sizeof(i830refreshes) / sizeof(i830refreshes[0]);

static Bool
Check5fStatus(ScrnInfoPtr pScrn, int func, int ax)
{
   if (ax == 0x005f)
      return TRUE;
   else if (ax == 0x015f) {
      xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
		 "Extended BIOS function 0x%04x failed.\n", func);
      return FALSE;
   } else if ((ax & 0xff) != 0x5f) {
      xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
		 "Extended BIOS function 0x%04x not supported.\n", func);
      return FALSE;
   } else {
      xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
		 "Extended BIOS function 0x%04x returns 0x%04x.\n",
		 func, ax & 0xffff);
      return FALSE;
   }
}

static int
GetToggleList(ScrnInfoPtr pScrn, int toggle)
{
   vbeInfoPtr pVbe = I830PTR(pScrn)->pVbe;

   DPRINTF(PFX, "GetToggleList\n");

   pVbe->pInt10->num = 0x10;
   pVbe->pInt10->ax = 0x5f64;
   pVbe->pInt10->bx = 0x500;
 
   pVbe->pInt10->bx |= toggle;

   xf86ExecX86int10_wrapper(pVbe->pInt10, pScrn);
   if (Check5fStatus(pScrn, 0x5f64, pVbe->pInt10->ax)) {
      xf86DrvMsg(pScrn->scrnIndex, X_INFO, "Toggle (%d) 0x%x\n", toggle, pVbe->pInt10->cx);
      return pVbe->pInt10->cx & 0xffff;
   }

   return 0;
}

static int
GetNextDisplayDeviceList(ScrnInfoPtr pScrn, int toggle)
{
   vbeInfoPtr pVbe = I830PTR(pScrn)->pVbe;
   int devices = 0;
   int pipe = 0;
   int i;

   DPRINTF(PFX, "GetNextDisplayDeviceList\n");

   pVbe->pInt10->num = 0x10;
   pVbe->pInt10->ax = 0x5f64;
   pVbe->pInt10->bx = 0xA00;
   pVbe->pInt10->bx |= toggle;
   pVbe->pInt10->es = SEG_ADDR(pVbe->real_mode_base);
   pVbe->pInt10->di = SEG_OFF(pVbe->real_mode_base);

   xf86ExecX86int10_wrapper(pVbe->pInt10, pScrn);
   if (!Check5fStatus(pScrn, 0x5f64, pVbe->pInt10->ax))
      return 0;

   for (i=0; i<(pVbe->pInt10->cx & 0xff); i++) {
      CARD32 VODA = (CARD32)((CARD32*)pVbe->memory)[i];

      xf86DrvMsg(pScrn->scrnIndex, X_INFO, "Next ACPI _DGS [%d] 0x%lx\n",
		i, VODA);

      /* Check if it's a custom Video Output Device Attribute */
      if (!(VODA & 0x80000000)) 
         continue;

      pipe = (VODA & 0x000000F0) >> 4;

      if (pipe != 0 && pipe != 1) {
         pipe = 0;
#if 0
         ErrorF("PIPE %d\n",pipe);
#endif
      }

      switch ((VODA & 0x00000F00) >> 8) {
      case 0x0:
      case 0x1: /* CRT */
         devices |= PIPE_CRT << (pipe == 1 ? 8 : 0);
         break;
      case 0x2: /* TV/HDTV */
         devices |= PIPE_TV << (pipe == 1 ? 8 : 0);
         break;
      case 0x3: /* DFP */
         devices |= PIPE_DFP << (pipe == 1 ? 8 : 0);
         break;
      case 0x4: /* LFP */
         devices |= PIPE_LFP << (pipe == 1 ? 8 : 0);
         break;
      }
   }

   xf86DrvMsg(pScrn->scrnIndex, X_INFO, "ACPI Toggle devices 0x%x\n", devices);

   return devices;
}

static int
GetAttachableDisplayDeviceList(ScrnInfoPtr pScrn)
{
   vbeInfoPtr pVbe = I830PTR(pScrn)->pVbe;
   int i;

   DPRINTF(PFX, "GetAttachableDisplayDeviceList\n");

   pVbe->pInt10->num = 0x10;
   pVbe->pInt10->ax = 0x5f64;
   pVbe->pInt10->bx = 0x900;
   pVbe->pInt10->es = SEG_ADDR(pVbe->real_mode_base);
   pVbe->pInt10->di = SEG_OFF(pVbe->real_mode_base);

   xf86ExecX86int10_wrapper(pVbe->pInt10, pScrn);
   if (!Check5fStatus(pScrn, 0x5f64, pVbe->pInt10->ax))
      return 0;

   for (i=0; i<(pVbe->pInt10->cx & 0xff); i++)
        xf86DrvMsg(pScrn->scrnIndex, X_INFO, 
		"Attachable device 0x%lx.\n", ((CARD32*)pVbe->memory)[i]);

   return pVbe->pInt10->cx & 0xffff;
}

static int
BitToRefresh(int bits)
{
   int i;

   for (i = 0; i < nrefreshes; i++)
      if (bits & (1 << i))
	 return i830refreshes[i];
   return 0;
}

static int
GetRefreshRate(ScrnInfoPtr pScrn, int mode, int *availRefresh)
{
   vbeInfoPtr pVbe = I830PTR(pScrn)->pVbe;

   DPRINTF(PFX, "GetRefreshRate\n");

   /* Only 8-bit mode numbers are supported. */
   if (mode & 0x100)
      return 0;

   pVbe->pInt10->num = 0x10;
   pVbe->pInt10->ax = 0x5f05;
   pVbe->pInt10->bx = (mode & 0xff) | 0x100;

   xf86ExecX86int10_wrapper(pVbe->pInt10, pScrn);
   if (Check5fStatus(pScrn, 0x5f05, pVbe->pInt10->ax)) {
      if (availRefresh)
         *availRefresh = pVbe->pInt10->bx;
      return BitToRefresh(pVbe->pInt10->cx);
   } else
      return 0;
}

struct panelid {
	short hsize;
	short vsize;
	short fptype;
	char redbpp;
	char greenbpp;
	char bluebpp;
	char reservedbpp;
	int rsvdoffscrnmemsize;
	int rsvdoffscrnmemptr;
	char reserved[14];
};

static void
I830InterpretPanelID(int scrnIndex, unsigned char *tmp)
{
    ScrnInfoPtr pScrn = xf86Screens[scrnIndex];
    struct panelid *block = (struct panelid *)tmp;

#define PANEL_DEFAULT_HZ 60

   xf86DrvMsg(pScrn->scrnIndex, X_INFO,
	 "PanelID returned panel resolution : %dx%d\n", 
						block->hsize, block->vsize);

   /* If we get bogus values from this, don't accept it */
   if (block->hsize == 0 || block->vsize == 0) {
   	xf86DrvMsg(pScrn->scrnIndex, X_INFO,
	 "Bad Panel resolution - ignoring panelID\n");
	
	return;
   }

   /* If we have monitor timings then don't overwrite them */
   if (pScrn->monitor->nHsync > 0 &&
	pScrn->monitor->nVrefresh > 0)
	return;

   /* With panels, we're always assuming a refresh of 60Hz */

   pScrn->monitor->nHsync = 1;
   pScrn->monitor->nVrefresh = 1;

   /* Give a little tolerance for the selected panel */
   pScrn->monitor->hsync[0].lo = (float)((PANEL_DEFAULT_HZ/1.05)*block->vsize)/1000;
   pScrn->monitor->hsync[0].hi = (float)((PANEL_DEFAULT_HZ/0.95)*block->vsize)/1000;
   pScrn->monitor->vrefresh[0].lo = (float)PANEL_DEFAULT_HZ;
   pScrn->monitor->vrefresh[0].hi = (float)PANEL_DEFAULT_HZ;
}

/* This should probably go into the VBE layer */
static unsigned char *
vbeReadPanelID(vbeInfoPtr pVbe)
{
    int RealOff = pVbe->real_mode_base;
    pointer page = pVbe->memory;
    unsigned char *tmp = NULL;
    int screen = pVbe->pInt10->scrnIndex;

    pVbe->pInt10->ax = 0x4F11;
    pVbe->pInt10->bx = 0x01;
    pVbe->pInt10->cx = 0;
    pVbe->pInt10->dx = 0;
    pVbe->pInt10->es = SEG_ADDR(RealOff);
    pVbe->pInt10->di = SEG_OFF(RealOff);
    pVbe->pInt10->num = 0x10;

    xf86ExecX86int10(pVbe->pInt10);

    if ((pVbe->pInt10->ax & 0xff) != 0x4f) {
        xf86DrvMsgVerb(screen,X_INFO,3,"VESA VBE PanelID invalid\n");
	goto error;
    }
    switch (pVbe->pInt10->ax & 0xff00) {
    case 0x0:
	xf86DrvMsgVerb(screen,X_INFO,3,"VESA VBE PanelID read successfully\n");
  	tmp = (unsigned char *)xnfalloc(32); 
  	memcpy(tmp,page,32); 
	break;
    case 0x100:
	xf86DrvMsgVerb(screen,X_INFO,3,"VESA VBE PanelID read failed\n");	
	break;
    default:
	xf86DrvMsgVerb(screen,X_INFO,3,"VESA VBE PanelID unknown failure %i\n",
		       pVbe->pInt10->ax & 0xff00);
	break;
    }

 error:
    return tmp;
}

static void
vbeDoPanelID(vbeInfoPtr pVbe)
{
    unsigned char *PanelID_data;
    
    if (!pVbe) return;

    PanelID_data = vbeReadPanelID(pVbe);

    if (!PanelID_data) 
	return;
    
    I830InterpretPanelID(pVbe->pInt10->scrnIndex, PanelID_data);
}

int 
I830GetBestRefresh(ScrnInfoPtr pScrn, int refresh)
{
   int i;

   for (i = nrefreshes - 1; i >= 0; i--) {
      /*
       * Look for the highest value that the requested (refresh + 2) is
       * greater than or equal to.
       */
      if (i830refreshes[i] <= (refresh + 2))
	 break;
   }
   /* i can be 0 if the requested refresh was higher than the max. */
   if (i == 0) {
      if (refresh >= i830refreshes[nrefreshes - 1])
         i = nrefreshes - 1;
   }

   return i;
}

static int
SetRefreshRate(ScrnInfoPtr pScrn, int mode, int refresh)
{
   vbeInfoPtr pVbe = I830PTR(pScrn)->pVbe;
   int i = I830GetBestRefresh(pScrn, refresh);

   DPRINTF(PFX, "SetRefreshRate: mode 0x%x, refresh: %d\n", mode, refresh);

   DPRINTF(PFX, "Setting refresh rate to %dHz for mode 0x%02x\n",
	   i830refreshes[i], mode & 0xff);

   /* Only 8-bit mode numbers are supported. */
   if (mode & 0x100)
      return 0;

   pVbe->pInt10->num = 0x10;
   pVbe->pInt10->ax = 0x5f05;
   pVbe->pInt10->bx = mode & 0xff;

   pVbe->pInt10->cx = 1 << i;
   xf86ExecX86int10_wrapper(pVbe->pInt10, pScrn);
   if (Check5fStatus(pScrn, 0x5f05, pVbe->pInt10->ax))
      return i830refreshes[i];
   else
      return 0;
}

#if 0
static Bool
SetPowerStatus(ScrnInfoPtr pScrn, int mode)
{
   vbeInfoPtr pVbe = I830PTR(pScrn)->pVbe;

   pVbe->pInt10->num = 0x10;
   pVbe->pInt10->ax = 0x5f64;
   pVbe->pInt10->bx = 0x0800 | mode;
   pVbe->pInt10->cx = 0x0000;

   xf86ExecX86int10_wrapper(pVbe->pInt10, pScrn);
   if (Check5fStatus(pScrn, 0x5f64, pVbe->pInt10->ax))
      return TRUE;
  
   return FALSE;
}
#endif

static Bool
GetModeSupport(ScrnInfoPtr pScrn, int modePipeA, int modePipeB,
	       int devicesPipeA, int devicesPipeB, int *maxBandwidth,
	       int *bandwidthPipeA, int *bandwidthPipeB)
{
   vbeInfoPtr pVbe = I830PTR(pScrn)->pVbe;

   DPRINTF(PFX, "GetModeSupport: modes 0x%x, 0x%x, devices: 0x%x, 0x%x\n",
	   modePipeA, modePipeB, devicesPipeA, devicesPipeB);

   /* Only 8-bit mode numbers are supported. */
   if ((modePipeA & 0x100) || (modePipeB & 0x100))
      return FALSE;

   pVbe->pInt10->num = 0x10;
   pVbe->pInt10->ax = 0x5f28;
   pVbe->pInt10->bx = (modePipeA & 0xff) | ((modePipeB & 0xff) << 8);
   if ((devicesPipeA & 0x80) || (devicesPipeB & 0x80))
      pVbe->pInt10->cx = 0x8000;
   else
      pVbe->pInt10->cx = (devicesPipeA & 0xff) | ((devicesPipeB & 0xff) << 8);

   xf86ExecX86int10_wrapper(pVbe->pInt10, pScrn);
   if (Check5fStatus(pScrn, 0x5f28, pVbe->pInt10->ax)) {
      if (maxBandwidth)
	 *maxBandwidth = pVbe->pInt10->cx;
      if (bandwidthPipeA)
	 *bandwidthPipeA = pVbe->pInt10->dx & 0xffff;
      /* XXX For XFree86 4.2.0 and earlier, ->dx is truncated to 16 bits. */
      if (bandwidthPipeB)
	 *bandwidthPipeB = (pVbe->pInt10->dx >> 16) & 0xffff;
      return TRUE;
   } else
      return FALSE;
}

#if 0
static int
GetLFPCompMode(ScrnInfoPtr pScrn)
{
   vbeInfoPtr pVbe = I830PTR(pScrn)->pVbe;

   DPRINTF(PFX, "GetLFPCompMode\n");

   pVbe->pInt10->num = 0x10;
   pVbe->pInt10->ax = 0x5f61;
   pVbe->pInt10->bx = 0x100;

   xf86ExecX86int10_wrapper(pVbe->pInt10, pScrn);
   if (Check5fStatus(pScrn, 0x5f61, pVbe->pInt10->ax))
      return pVbe->pInt10->cx & 0xffff;
   else
      return -1;
}

static Bool
SetLFPCompMode(ScrnInfoPtr pScrn, int compMode)
{
   vbeInfoPtr pVbe = I830PTR(pScrn)->pVbe;

   DPRINTF(PFX, "SetLFPCompMode: compMode %d\n", compMode);

   pVbe->pInt10->num = 0x10;
   pVbe->pInt10->ax = 0x5f61;
   pVbe->pInt10->bx = 0;
   pVbe->pInt10->cx = compMode;

   xf86ExecX86int10_wrapper(pVbe->pInt10, pScrn);
   return Check5fStatus(pScrn, 0x5f61, pVbe->pInt10->ax);
}
#endif

static int
GetDisplayDevices(ScrnInfoPtr pScrn)
{
   I830Ptr pI830 = I830PTR(pScrn);
   vbeInfoPtr pVbe = pI830->pVbe;

   DPRINTF(PFX, "GetDisplayDevices\n");

#if 0
   {
      CARD32 temp;
      ErrorF("ADPA is 0x%08x\n", INREG(ADPA));
      ErrorF("DVOA is 0x%08x\n", INREG(DVOA));
      ErrorF("DVOB is 0x%08x\n", INREG(DVOB));
      ErrorF("DVOC is 0x%08x\n", INREG(DVOC));
      ErrorF("LVDS is 0x%08x\n", INREG(LVDS));
      temp = INREG(DVOA_SRCDIM);
      ErrorF("DVOA_SRCDIM is 0x%08x (%d x %d)\n", temp,
	     (temp >> 12) & 0xfff, temp & 0xfff);
      temp = INREG(DVOB_SRCDIM);
      ErrorF("DVOB_SRCDIM is 0x%08x (%d x %d)\n", temp,
	     (temp >> 12) & 0xfff, temp & 0xfff);
      temp = INREG(DVOC_SRCDIM);
      ErrorF("DVOC_SRCDIM is 0x%08x (%d x %d)\n", temp,
	     (temp >> 12) & 0xfff, temp & 0xfff);
      ErrorF("SWF0 is 0x%08x\n", INREG(SWF0));
      ErrorF("SWF4 is 0x%08x\n", INREG(SWF4));
   }
#endif

   pVbe->pInt10->num = 0x10;
   pVbe->pInt10->ax = 0x5f64;
   pVbe->pInt10->bx = 0x100;

   xf86ExecX86int10_wrapper(pVbe->pInt10, pScrn);
   if (Check5fStatus(pScrn, 0x5f64, pVbe->pInt10->ax)) {
      return pVbe->pInt10->cx & 0xffff;
   } else {
      if (pI830->PciInfo->chipType == PCI_CHIP_E7221_G) /* FIXED CONFIG */
         return PIPE_CRT;
      else
         return -1;
   }
}

static int
GetBIOSPipe(ScrnInfoPtr pScrn)
{
   I830Ptr pI830 = I830PTR(pScrn);
   vbeInfoPtr pVbe = pI830->pVbe;
   int pipe;

   DPRINTF(PFX, "GetBIOSPipe:\n");

   /* single pipe machines should always return Pipe A */
   if (pI830->availablePipes == 1) return 0;

   pVbe->pInt10->num = 0x10;
   pVbe->pInt10->ax = 0x5f1c;
   pVbe->pInt10->bx = 0x100;

   xf86ExecX86int10_wrapper(pVbe->pInt10, pScrn);
   if (Check5fStatus(pScrn, 0x5f1c, pVbe->pInt10->ax)) {
      if (pI830->newPipeSwitch) {
         pipe = ((pVbe->pInt10->bx & 0x0001));
      } else {
         pipe = ((pVbe->pInt10->cx & 0x0100) >> 8);
      }
      return pipe;
   }

   /* failed, assume pipe A */
   return 0;
}

static Bool
SetBIOSPipe(ScrnInfoPtr pScrn, int pipe)
{
   I830Ptr pI830 = I830PTR(pScrn);
   vbeInfoPtr pVbe = pI830->pVbe;

   DPRINTF(PFX, "SetBIOSPipe: pipe 0x%x\n", pipe);

   /* single pipe machines should always return TRUE */
   if (pI830->availablePipes == 1) return TRUE;

   pVbe->pInt10->num = 0x10;
   pVbe->pInt10->ax = 0x5f1c;
   if (pI830->newPipeSwitch) {
      pVbe->pInt10->bx = pipe;
      pVbe->pInt10->cx = 0;
   } else {
      pVbe->pInt10->bx = 0x0;
      pVbe->pInt10->cx = pipe << 8;
   }

   xf86ExecX86int10_wrapper(pVbe->pInt10, pScrn);
   if (Check5fStatus(pScrn, 0x5f1c, pVbe->pInt10->ax)) {
      return TRUE;
   }
	
   return FALSE;
}

static Bool
SetPipeAccess(ScrnInfoPtr pScrn)
{
   I830Ptr pI830 = I830PTR(pScrn);

   /* Don't try messing with the pipe, unless we're dual head */
   if (xf86IsEntityShared(pScrn->entityList[0]) || pI830->Clone || pI830->MergedFB || pI830->origPipe != pI830->pipe) {
      if (!SetBIOSPipe(pScrn, pI830->pipe))
         return FALSE;
   }
   
   return TRUE;
}

static Bool
I830Set640x480(ScrnInfoPtr pScrn)
{
   I830Ptr pI830 = I830PTR(pScrn);
   int m;

   /* 640x480 8bpp */
   m = 0x30 | (1 << 15) | (1 << 14);
   if (VBESetVBEMode(pI830->pVbe, m, NULL))
	   return TRUE;

   /* if the first failed, let's try the next - usually 800x600 */
   m = 0x32 | (1 << 15) | (1 << 14);

   if (VBESetVBEMode(pI830->pVbe, m, NULL))
	   return TRUE;

   return FALSE;
}

/* This is needed for SetDisplayDevices to work correctly on I915G.
 * Enable for all chipsets now as it has no bad side effects, apart
 * from slightly longer startup time.
 */
#define I915G_WORKAROUND

static Bool
SetDisplayDevices(ScrnInfoPtr pScrn, int devices)
{
   I830Ptr pI830 = I830PTR(pScrn);
   vbeInfoPtr pVbe = pI830->pVbe;
   CARD32 temp;
   int singlepipe = 0;
#ifdef I915G_WORKAROUND
   int getmode1;
   Bool setmode = FALSE;
#endif

   DPRINTF(PFX, "SetDisplayDevices: devices 0x%x\n", devices);

   if (!pI830->specifiedMonitor)
      return TRUE;

#ifdef I915G_WORKAROUND
   if (pI830->preinit)
      setmode = TRUE;
   if (pI830->leaving)
      setmode = FALSE;
   if (pI830->closing)
      setmode = FALSE;

   if (setmode) {
      VBEGetVBEMode(pVbe, &getmode1);
      I830Set640x480(pScrn);
   }
#endif

   pVbe->pInt10->num = 0x10;
   pVbe->pInt10->ax = 0x5f64;
   pVbe->pInt10->bx = 0x1;
   pVbe->pInt10->cx = devices;

   xf86ExecX86int10_wrapper(pVbe->pInt10, pScrn);
   if (Check5fStatus(pScrn, 0x5f64, pVbe->pInt10->ax)) {
#ifdef I915G_WORKAROUND
      if (setmode) {
  	 VBESetVBEMode(pI830->pVbe, getmode1 | 1<<15, NULL);
      }
#endif
      pI830->pipeEnabled[0] = (devices & 0xff) ? TRUE : FALSE;
      pI830->pipeEnabled[1] = (devices & 0xff00) ? TRUE : FALSE;

      return TRUE;
   }

#ifdef I915G_WORKAROUND
   if (setmode)
      VBESetVBEMode(pI830->pVbe, getmode1 | 1<<15, NULL);
#endif

   if (devices & 0xff) {
      pVbe->pInt10->num = 0x10;
      pVbe->pInt10->ax = 0x5f64;
      pVbe->pInt10->bx = 0x1;
      pVbe->pInt10->cx = devices & 0xff;

      xf86ExecX86int10_wrapper(pVbe->pInt10, pScrn);
      if (Check5fStatus(pScrn, 0x5f64, pVbe->pInt10->ax)) {
         xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
	 	"Successfully set display devices to 0x%x.\n",devices & 0xff);
         singlepipe = devices & 0xff00; /* set alternate */
      } else {
         xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
	 	"Failed to set display devices to 0x%x.\n",devices & 0xff);
         singlepipe = devices;
      }
   } else
      singlepipe = devices; 

   if (singlepipe == devices && devices & 0xff00) {
      pVbe->pInt10->num = 0x10;
      pVbe->pInt10->ax = 0x5f64;
      pVbe->pInt10->bx = 0x1;
      pVbe->pInt10->cx = devices & 0xff00;

      xf86ExecX86int10_wrapper(pVbe->pInt10, pScrn);
      if (Check5fStatus(pScrn, 0x5f64, pVbe->pInt10->ax)) {
         xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
	 	"Successfully set display devices to 0x%x.\n",devices & 0xff00);
         singlepipe = devices & 0xff; /* set alternate */
      } else {
         xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
	 	"Failed to set display devices to 0x%x.\n",devices & 0xff00);
         singlepipe = devices;
      }
   } 

   /* LVDS doesn't exist on these */
   if (IS_I830(pI830) || IS_845G(pI830) || IS_I865G(pI830) || IS_I915G(pI830) || IS_I945G(pI830) || IS_I965G(pI830))
      singlepipe &= ~(PIPE_LFP | (PIPE_LFP<<8));

   if (pI830->availablePipes == 1) 
      singlepipe &= 0xFF;

   /* Disable LVDS */
   if (singlepipe & PIPE_LFP)  {
      /* LFP on PipeA is unlikely! */
      OUTREG(0x61200, INREG(0x61200) & ~0x80000000);
      OUTREG(0x61204, INREG(0x61204) & ~0x00000001);
      while ((INREG(0x61200) & 0x80000000) || (INREG(0x61204) & 1));
      /* Fix up LVDS */
      OUTREG(LVDS, (INREG(LVDS) & ~1<<30) | 0x80000300);
      /* Enable LVDS */
      OUTREG(0x61200, INREG(0x61200) | 0x80000000);
      OUTREG(0x61204, INREG(0x61204) | 0x00000001);
      while (!(INREG(0x61200) & 0x80000000) && !(INREG(0x61204) & 1));
      xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
	 	"Enabling LVDS directly. Pipe A.\n");
   } else
   if (singlepipe & (PIPE_LFP << 8))  {
      OUTREG(0x61200, INREG(0x61200) & ~0x80000000);
      OUTREG(0x61204, INREG(0x61204) & ~0x00000001);
      while ((INREG(0x61200) & 0x80000000) || (INREG(0x61204) & 1));
      /* Fix up LVDS */
      OUTREG(LVDS, (INREG(LVDS) | 1<<30) | 0x80000300);
      /* Enable LVDS */
      OUTREG(0x61200, INREG(0x61200) | 0x80000000);
      OUTREG(0x61204, INREG(0x61204) | 0x00000001);
      while (!(INREG(0x61200) & 0x80000000) && !(INREG(0x61204) & 1));
      xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
	 	"Enabling LVDS directly. Pipe B.\n");
   }
   else if (!(IS_I830(pI830) || IS_845G(pI830) || IS_I865G(pI830))) {
      if (!(devices & (PIPE_LFP | PIPE_LFP<<8))) {
         OUTREG(0x61200, INREG(0x61200) & ~0x80000000);
         OUTREG(0x61204, INREG(0x61204) & ~0x00000001);
         while ((INREG(0x61200) & 0x80000000) || (INREG(0x61204) & 1));
         /* Fix up LVDS */
         OUTREG(LVDS, (INREG(LVDS) | 1<<30) & ~0x80000300);
         xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
	 	"Disabling LVDS directly.\n");
      }
   }

   /* Now try to program the registers directly if the BIOS failed. */
   temp = INREG(ADPA);
   temp &= ~(ADPA_DAC_ENABLE | ADPA_PIPE_SELECT_MASK);
   temp &= ~(ADPA_VSYNC_CNTL_DISABLE | ADPA_HSYNC_CNTL_DISABLE);
   /* Turn on ADPA */
   if (singlepipe & PIPE_CRT)  {
      xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
	 	"Enabling ADPA directly. Pipe A.\n");
      temp |= ADPA_DAC_ENABLE | ADPA_PIPE_A_SELECT;
      OUTREG(ADPA, temp);
   } else
   if (singlepipe & (PIPE_CRT << 8)) {
      xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
	 	"Enabling ADPA directly. Pipe B.\n");
      temp |= ADPA_DAC_ENABLE | ADPA_PIPE_B_SELECT;
      OUTREG(ADPA, temp);
   } 
   else {
      if (!(devices & (PIPE_CRT | PIPE_CRT<<8))) {
         xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
	 	"Disabling ADPA directly.\n");
         temp |= ADPA_VSYNC_CNTL_DISABLE | ADPA_HSYNC_CNTL_DISABLE;
         OUTREG(ADPA, temp);
      }
   }

   xf86DrvMsg(pScrn->scrnIndex, X_WARNING,"Writing config directly to SWF0.\n");
   temp = INREG(SWF0);
   OUTREG(SWF0, (temp & ~(0xffff)) | (devices & 0xffff));

   if (GetDisplayDevices(pScrn) != devices) {
      xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
		 "SetDisplayDevices failed with devices 0x%x instead of 0x%x\n",
	         GetDisplayDevices(pScrn), devices);
      return FALSE;
   }

   pI830->pipeEnabled[0] = (devices & 0xff) ? TRUE : FALSE;
   pI830->pipeEnabled[1] = (devices & 0xff00) ? TRUE : FALSE;

   return TRUE;
}

static Bool
GetBIOSVersion(ScrnInfoPtr pScrn, unsigned int *version)
{
   vbeInfoPtr pVbe = I830PTR(pScrn)->pVbe;

   DPRINTF(PFX, "GetBIOSVersion\n");

   pVbe->pInt10->num = 0x10;
   pVbe->pInt10->ax = 0x5f01;

   xf86ExecX86int10_wrapper(pVbe->pInt10, pScrn);
   if (Check5fStatus(pScrn, 0x5f01, pVbe->pInt10->ax)) {
      *version = pVbe->pInt10->bx;
      return TRUE;
   }

   *version = 0;
   return FALSE;
}

static Bool
GetDevicePresence(ScrnInfoPtr pScrn, Bool *required, int *attached,
		  int *encoderPresent)
{
   vbeInfoPtr pVbe = I830PTR(pScrn)->pVbe;

   DPRINTF(PFX, "GetDevicePresence\n");

   pVbe->pInt10->num = 0x10;
   pVbe->pInt10->ax = 0x5f64;
   pVbe->pInt10->bx = 0x200;

   xf86ExecX86int10_wrapper(pVbe->pInt10, pScrn);
   if (Check5fStatus(pScrn, 0x5f64, pVbe->pInt10->ax)) {
      if (required)
	 *required = ((pVbe->pInt10->bx & 0x1) == 0);
      if (attached)
	 *attached = (pVbe->pInt10->cx >> 8) & 0xff;
      if (encoderPresent)
	 *encoderPresent = pVbe->pInt10->cx & 0xff;
      return TRUE;
   } else
      return FALSE;
}

static Bool
GetDisplayInfo(ScrnInfoPtr pScrn, int device, Bool *attached, Bool *present,
	       short *x, short *y)
{
   vbeInfoPtr pVbe = I830PTR(pScrn)->pVbe;

   DPRINTF(PFX, "GetDisplayInfo: device: 0x%x\n", device);

   switch (device & 0xff) {
   case PIPE_CRT:
   case PIPE_TV:
   case PIPE_DFP:
   case PIPE_LFP:
   case PIPE_CRT2:
   case PIPE_TV2:
   case PIPE_DFP2:
   case PIPE_LFP2:
      break;
   default:
      xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
		 "GetDisplayInfo: invalid device: 0x%x\n", device & 0xff);
      return FALSE;
   }

   pVbe->pInt10->num = 0x10;
   pVbe->pInt10->ax = 0x5f64;
   pVbe->pInt10->bx = 0x300;
   pVbe->pInt10->cx = device & 0xff;

   xf86ExecX86int10_wrapper(pVbe->pInt10, pScrn);
   if (Check5fStatus(pScrn, 0x5f64, pVbe->pInt10->ax)) {
      if (attached)
	 *attached = ((pVbe->pInt10->bx & 0x2) != 0);
      if (present)
	 *present = ((pVbe->pInt10->bx & 0x1) != 0);
      if (pVbe->pInt10->cx != (device & 0xff)) {
	 if (y) {
	    *y = pVbe->pInt10->cx & 0xffff;
	 }
	 if (x) {
	    *x = (pVbe->pInt10->cx >> 16) & 0xffff;
	 }
      }
      return TRUE;
   } else
      return FALSE;
}

/*
 * Returns a string matching the device corresponding to the first bit set
 * in "device".  savedDevice is then set to device with that bit cleared.
 * Subsequent calls with device == -1 will use savedDevice.
 */

static const char *displayDevices[] = {
   "CRT",
   "TV",
   "DFP (digital flat panel)",
   "LFP (local flat panel)",
   "Second (second CRT)",
   "TV2 (second TV)",
   "DFP2 (second digital flat panel)",
   "LFP2 (second local flat panel)",
   NULL
};

static const char *
DeviceToString(int device)
{
   static int savedDevice = -1;
   int bit = 0;
   const char *name;

   if (device == -1) {
      device = savedDevice;
      bit = 0;
   }

   if (device == -1)
      return NULL;

   while (displayDevices[bit]) {
      if (device & (1 << bit)) {
	 name = displayDevices[bit];
	 savedDevice = device & ~(1 << bit);
	 bit++;
	 return name;
      }
      bit++;
   }
   return NULL;
}

static void
PrintDisplayDeviceInfo(ScrnInfoPtr pScrn)
{
   I830Ptr pI830 = I830PTR(pScrn);
   int pipe, n;
   int displays;

   DPRINTF(PFX, "PrintDisplayDeviceInfo\n");

   displays = pI830->operatingDevices;
   if (displays == -1) {
      xf86DrvMsg(pScrn->scrnIndex, X_INFO,
		 "No active display devices.\n");
      return;
   }

   /* Check for active devices connected to each display pipe. */
   for (n = 0; n < pI830->availablePipes; n++) {
      pipe = ((displays >> PIPE_SHIFT(n)) & PIPE_ACTIVE_MASK);
      if (pipe) {
	 const char *name;

	 xf86DrvMsg(pScrn->scrnIndex, X_INFO,
		    "Currently active displays on Pipe %c:\n", PIPE_NAME(n));
	 name = DeviceToString(pipe);
	 do {
	    xf86DrvMsg(pScrn->scrnIndex, X_INFO, "\t%s\n", name);
	    name = DeviceToString(-1);
	 } while (name);

      } else {
	 xf86DrvMsg(pScrn->scrnIndex, X_INFO,
		    "No active displays on Pipe %c.\n", PIPE_NAME(n));
      }

      if (pI830->pipeDisplaySize[n].x2 != 0) {
	 xf86DrvMsg(pScrn->scrnIndex, X_INFO,
		    "Lowest common panel size for pipe %c is %d x %d\n",
		    PIPE_NAME(n), pI830->pipeDisplaySize[n].x2,
		    pI830->pipeDisplaySize[n].y2);
      } else if (pI830->pipeEnabled[n] && pipe & ~PIPE_CRT_ACTIVE) {
	 xf86DrvMsg(pScrn->scrnIndex, X_INFO,
		    "No display size information available for pipe %c.\n",
		    PIPE_NAME(n));
      }
   }
}

static void
GetPipeSizes(ScrnInfoPtr pScrn)
{
   I830Ptr pI830 = I830PTR(pScrn);
   int pipe, n;
   DisplayType i;

   DPRINTF(PFX, "GetPipeSizes\n");


   for (n = 0; n < pI830->availablePipes; n++) {
      pipe = (pI830->operatingDevices >> PIPE_SHIFT(n)) & PIPE_ACTIVE_MASK;
      pI830->pipeDisplaySize[n].x1 = pI830->pipeDisplaySize[n].y1 = 0;
      pI830->pipeDisplaySize[n].x2 = pI830->pipeDisplaySize[n].y2 = 4096;
      for (i = 0; i < NumDisplayTypes; i++) {
         if (pipe & (1 << i) & PIPE_SIZED_DISP_MASK) {
	    if (pI830->displaySize[i].x2 != 0) {
	       xf86DrvMsg(pScrn->scrnIndex, X_INFO,
		          "Size of device %s is %d x %d\n",
		          displayDevices[i],
		          pI830->displaySize[i].x2,
		          pI830->displaySize[i].y2);
	       if (pI830->displaySize[i].x2 < pI830->pipeDisplaySize[n].x2)
	          pI830->pipeDisplaySize[n].x2 = pI830->displaySize[i].x2;
	       if (pI830->displaySize[i].y2 < pI830->pipeDisplaySize[n].y2)
	          pI830->pipeDisplaySize[n].y2 = pI830->displaySize[i].y2;
	    }
         }
      }

      if (pI830->pipeDisplaySize[n].x2 == 4096)
         pI830->pipeDisplaySize[n].x2 = 0;
      if (pI830->pipeDisplaySize[n].y2 == 4096)
         pI830->pipeDisplaySize[n].y2 = 0;
   }
}

static Bool
I830DetectDisplayDevice(ScrnInfoPtr pScrn)
{
   I830Ptr pI830 = I830PTR(pScrn);
   int pipe, n;
   DisplayType i;
   
   /* This seems to lockup some Dell BIOS'. So it's on option to turn on */
   if (pI830->displayInfo) {
       xf86DrvMsg(pScrn->scrnIndex, X_INFO,
		  "Broken BIOSes cause the system to hang here.\n"
		  "\t      If you encounter this problem please add \n"
		  "\t\t Option \"DisplayInfo\" \"FALSE\"\n"
		  "\t      to the Device section of your XF86Config file.\n");
      for (i = 0; i < NumDisplayTypes; i++) {
         if (GetDisplayInfo(pScrn, 1 << i, &pI830->displayAttached[i],
			 &pI830->displayPresent[i],
			 &pI830->displaySize[i].x2,
			 &pI830->displaySize[i].y2)) {
	    xf86DrvMsg(pScrn->scrnIndex, X_INFO,
		    "Display Info: %s: attached: %s, present: %s, size: "
		    "(%d,%d)\n", displayDevices[i],
		    BOOLTOSTRING(pI830->displayAttached[i]),
		    BOOLTOSTRING(pI830->displayPresent[i]),
		    pI830->displaySize[i].x2, pI830->displaySize[i].y2);
         }
      }
   }

   /* Check for active devices connected to each display pipe. */
   for (n = 0; n < pI830->availablePipes; n++) {
      pipe = ((pI830->operatingDevices >> PIPE_SHIFT(n)) & PIPE_ACTIVE_MASK);
      if (pipe)
	 pI830->pipeEnabled[n] = TRUE;
      else
	 pI830->pipeEnabled[n] = FALSE;
   }

   GetPipeSizes(pScrn);

   return TRUE;
}

static int
I830DetectMemory(ScrnInfoPtr pScrn)
{
   I830Ptr pI830 = I830PTR(pScrn);
   PCITAG bridge;
   CARD16 gmch_ctrl;
   int memsize = 0;
   int range;

   bridge = pciTag(0, 0, 0);		/* This is always the host bridge */
   gmch_ctrl = pciReadWord(bridge, I830_GMCH_CTRL);

   /* We need to reduce the stolen size, by the GTT and the popup.
    * The GTT varying according the the FbMapSize and the popup is 4KB. */
   if (IS_I96X(pI830))
      range = 512 + 4; /* Fixed 512KB size for i965 */
   else
      range = (pI830->FbMapSize / MB(1)) + 4;

   if (IS_I85X(pI830) || IS_I865G(pI830) || IS_I9XX(pI830)) {
      switch (gmch_ctrl & I830_GMCH_GMS_MASK) {
      case I855_GMCH_GMS_STOLEN_1M:
	 memsize = MB(1) - KB(range);
	 break;
      case I855_GMCH_GMS_STOLEN_4M:
	 memsize = MB(4) - KB(range);
	 break;
      case I855_GMCH_GMS_STOLEN_8M:
	 memsize = MB(8) - KB(range);
	 break;
      case I855_GMCH_GMS_STOLEN_16M:
	 memsize = MB(16) - KB(range);
	 break;
      case I855_GMCH_GMS_STOLEN_32M:
	 memsize = MB(32) - KB(range);
	 break;
      case I915G_GMCH_GMS_STOLEN_48M:
	 if (IS_I9XX(pI830))
	    memsize = MB(48) - KB(range);
	 break;
      case I915G_GMCH_GMS_STOLEN_64M:
	 if (IS_I9XX(pI830))
	    memsize = MB(64) - KB(range);
	 break;
      }
   } else {
      switch (gmch_ctrl & I830_GMCH_GMS_MASK) {
      case I830_GMCH_GMS_STOLEN_512:
	 memsize = KB(512) - KB(range);
	 break;
      case I830_GMCH_GMS_STOLEN_1024:
	 memsize = MB(1) - KB(range);
	 break;
      case I830_GMCH_GMS_STOLEN_8192:
	 memsize = MB(8) - KB(range);
	 break;
      case I830_GMCH_GMS_LOCAL:
	 memsize = 0;
	 xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
		    "Local memory found, but won't be used.\n");
	 break;
      }
   }

#if 0
   /* And 64KB page aligned */
   memsize &= ~0xFFFF;
#endif

   if (memsize > 0) {
      xf86DrvMsg(pScrn->scrnIndex, X_INFO,
		 "detected %d kB stolen memory.\n", memsize / 1024);
   } else {
      xf86DrvMsg(pScrn->scrnIndex, X_INFO, "no video memory detected.\n");
   }
   return memsize;
}

static Bool
I830MapMMIO(ScrnInfoPtr pScrn)
{
   int mmioFlags;
   I830Ptr pI830 = I830PTR(pScrn);

#if !defined(__alpha__)
   mmioFlags = VIDMEM_MMIO | VIDMEM_READSIDEEFFECT;
#else
   mmioFlags = VIDMEM_MMIO | VIDMEM_READSIDEEFFECT | VIDMEM_SPARSE;
#endif

   pI830->MMIOBase = xf86MapPciMem(pScrn->scrnIndex, mmioFlags,
				   pI830->PciTag,
				   pI830->MMIOAddr, I810_REG_SIZE);
   if (!pI830->MMIOBase)
      return FALSE;
   return TRUE;
}

static Bool
I830MapMem(ScrnInfoPtr pScrn)
{
   I830Ptr pI830 = I830PTR(pScrn);
   long i;

   for (i = 2; i < pI830->FbMapSize; i <<= 1) ;
   pI830->FbMapSize = i;

   if (!I830MapMMIO(pScrn))
      return FALSE;

   pI830->FbBase = xf86MapPciMem(pScrn->scrnIndex, VIDMEM_FRAMEBUFFER,
				 pI830->PciTag,
				 pI830->LinearAddr, pI830->FbMapSize);
   if (!pI830->FbBase)
      return FALSE;

   if (I830IsPrimary(pScrn))
   pI830->LpRing->virtual_start = pI830->FbBase + pI830->LpRing->mem.Start;

   return TRUE;
}

static void
I830UnmapMMIO(ScrnInfoPtr pScrn)
{
   I830Ptr pI830 = I830PTR(pScrn);

   xf86UnMapVidMem(pScrn->scrnIndex, (pointer) pI830->MMIOBase,
		   I810_REG_SIZE);
   pI830->MMIOBase = 0;
}

static Bool
I830UnmapMem(ScrnInfoPtr pScrn)
{
   I830Ptr pI830 = I830PTR(pScrn);

   xf86UnMapVidMem(pScrn->scrnIndex, (pointer) pI830->FbBase,
		   pI830->FbMapSize);
   pI830->FbBase = 0;
   I830UnmapMMIO(pScrn);
   return TRUE;
}

#ifndef HAVE_GET_PUT_BIOSMEMSIZE
#define HAVE_GET_PUT_BIOSMEMSIZE 1
#endif

#if HAVE_GET_PUT_BIOSMEMSIZE
/*
 * Tell the BIOS how much video memory is available.  The BIOS call used
 * here won't always be available.
 */
static Bool
PutBIOSMemSize(ScrnInfoPtr pScrn, int memSize)
{
   vbeInfoPtr pVbe = I830PTR(pScrn)->pVbe;

   DPRINTF(PFX, "PutBIOSMemSize: %d kB\n", memSize / 1024);

   pVbe->pInt10->num = 0x10;
   pVbe->pInt10->ax = 0x5f11;
   pVbe->pInt10->bx = 0;
   pVbe->pInt10->cx = memSize / GTT_PAGE_SIZE;

   xf86ExecX86int10_wrapper(pVbe->pInt10, pScrn);
   return Check5fStatus(pScrn, 0x5f11, pVbe->pInt10->ax);
}

/*
 * This reports what the previous VBEGetVBEInfo() found.  Be sure to call
 * VBEGetVBEInfo() after changing the BIOS memory size view.  If
 * a separate BIOS call is added for this, it can be put here.  Only
 * return a valid value if the funtionality for PutBIOSMemSize()
 * is available.
 */
static int
GetBIOSMemSize(ScrnInfoPtr pScrn)
{
   I830Ptr pI830 = I830PTR(pScrn);
   int memSize = KB(pI830->vbeInfo->TotalMemory * 64);

   DPRINTF(PFX, "GetBIOSMemSize\n");

   if (PutBIOSMemSize(pScrn, memSize))
      return memSize;
   else
      return -1;
}
#endif

/*
 * These three functions allow the video BIOS's view of the available video
 * memory to be changed.  This is currently implemented only for the 830
 * and 845G, which can do this via a BIOS scratch register that holds the
 * BIOS's view of the (pre-reserved) memory size.  If another mechanism
 * is available in the future, it can be plugged in here.  
 *
 * The mapping used for the 830/845G scratch register's low 4 bits is:
 *
 *             320k => 0
 *             832k => 1
 *            8000k => 8
 *
 * The "unusual" values are the 512k, 1M, 8M pre-reserved memory, less
 * overhead, rounded down to the BIOS-reported 64k granularity.
 */

static Bool
SaveBIOSMemSize(ScrnInfoPtr pScrn)
{
   I830Ptr pI830 = I830PTR(pScrn);

   DPRINTF(PFX, "SaveBIOSMemSize\n");

   if (!I830IsPrimary(pScrn))
      return FALSE;

   pI830->useSWF1 = FALSE;

#if HAVE_GET_PUT_BIOSMEMSIZE
   if ((pI830->saveBIOSMemSize = GetBIOSMemSize(pScrn)) != -1)
      return TRUE;
#endif

   if (IS_I830(pI830) || IS_845G(pI830)) {
      pI830->useSWF1 = TRUE;
      pI830->saveSWF1 = INREG(SWF1) & 0x0f;

      /*
       * This is for sample purposes only.  pI830->saveBIOSMemSize isn't used
       * when pI830->useSWF1 is TRUE.
       */
      switch (pI830->saveSWF1) {
      case 0:
	 pI830->saveBIOSMemSize = KB(320);
	 break;
      case 1:
	 pI830->saveBIOSMemSize = KB(832);
	 break;
      case 8:
	 pI830->saveBIOSMemSize = KB(8000);
	 break;
      default:
	 pI830->saveBIOSMemSize = 0;
	 break;
      }
      return TRUE;
   }
   return FALSE;
}

/*
 * TweakMemorySize() tweaks the BIOS image to set the correct size.
 * Original implementation by Christian Zietz in a stand-alone tool.
 */
static CARD32
TweakMemorySize(ScrnInfoPtr pScrn, CARD32 newsize, Bool preinit)
{
#define SIZE 0x10000
#define _855_IDOFFSET (-23)
#define _845_IDOFFSET (-19)
    
    const char *MAGICstring = "Total time for VGA POST:";
    const int len = strlen(MAGICstring);
    I830Ptr pI830 = I830PTR(pScrn);
    volatile char *position;
    char *biosAddr;
    CARD32 oldsize;
    CARD32 oldpermission;
    CARD32 ret = 0;
    int i,j = 0;
    int reg = (IS_845G(pI830) || IS_I865G(pI830)) ? _845_DRAM_RW_CONTROL
	: _855_DRAM_RW_CONTROL;
    
    PCITAG tag =pciTag(0,0,0);

    if (!I830IsPrimary(pScrn))
       return 0;

    if(!pI830->PciInfo 
       || !(IS_845G(pI830) || IS_I85X(pI830) || IS_I865G(pI830)))
	return 0;

    if (!pI830->pVbe)
	return 0;

    biosAddr = xf86int10Addr(pI830->pVbe->pInt10, 
				    pI830->pVbe->pInt10->BIOSseg << 4);

    if (!pI830->BIOSMemSizeLoc) {
	if (!preinit)
	    return 0;

	/* Search for MAGIC string */
	for (i = 0; i < SIZE; i++) {
	    if (biosAddr[i] == MAGICstring[j]) {
		if (++j == len)
		    break;
	    } else {
		i -= j;
		j = 0;
	    }
	}
	if (j < len) return 0;

	pI830->BIOSMemSizeLoc =  (i - j + 1 + (IS_845G(pI830)
					    ? _845_IDOFFSET : _855_IDOFFSET));
    }
    
    position = biosAddr + pI830->BIOSMemSizeLoc;
    oldsize = *(CARD32 *)position;

    ret = oldsize - 0x21000;
    
    /* verify that register really contains current size */
    if (preinit && ((ret >> 16) !=  pI830->vbeInfo->TotalMemory))
	return 0;

    oldpermission = pciReadLong(tag, reg);
    pciWriteLong(tag, reg, DRAM_WRITE | (oldpermission & 0xffff)); 
    
    *(CARD32 *)position = newsize + 0x21000;

    if (preinit) {
	/* reinitialize VBE for new size */
	if (I830IsPrimary(pScrn)) {
	   VBEFreeVBEInfo(pI830->vbeInfo);
	   vbeFree(pI830->pVbe);
	   pI830->pVbe = VBEInit(NULL, pI830->pEnt->index);
	   pI830->vbeInfo = VBEGetVBEInfo(pI830->pVbe);
	} else {
           I830Ptr pI8301 = I830PTR(pI830->entityPrivate->pScrn_1);
           pI830->pVbe = pI8301->pVbe;
           pI830->vbeInfo = pI8301->vbeInfo;
	}
	
	/* verify that change was successful */
	if (pI830->vbeInfo->TotalMemory != (newsize >> 16)){
	    ret = 0;
	    *(CARD32 *)position = oldsize;
	} else {
	    pI830->BIOSMemorySize = KB(pI830->vbeInfo->TotalMemory * 64);
	    xf86DrvMsg(pScrn->scrnIndex, X_INFO, 
		       "Tweak BIOS image to %d kB VideoRAM\n",
		       (int)(pI830->BIOSMemorySize / 1024));
	}
    }

    pciWriteLong(tag, reg, oldpermission);

     return ret;
}

static void
RestoreBIOSMemSize(ScrnInfoPtr pScrn)
{
   I830Ptr pI830 = I830PTR(pScrn);
   CARD32 swf1;

   DPRINTF(PFX, "RestoreBIOSMemSize\n");

   if (!I830IsPrimary(pScrn))
      return;

   if (TweakMemorySize(pScrn, pI830->saveBIOSMemSize,FALSE))
      return;

   if (!pI830->overrideBIOSMemSize)
      return;

#if HAVE_GET_PUT_BIOSMEMSIZE
   if (!pI830->useSWF1) {
      PutBIOSMemSize(pScrn, pI830->saveBIOSMemSize);
      return;
   }
#endif

   if ((IS_I830(pI830) || IS_845G(pI830)) && pI830->useSWF1) {
      swf1 = INREG(SWF1);
      swf1 &= ~0x0f;
      swf1 |= (pI830->saveSWF1 & 0x0f);
      OUTREG(SWF1, swf1);
   }
}

static void
SetBIOSMemSize(ScrnInfoPtr pScrn, int newSize)
{
   I830Ptr pI830 = I830PTR(pScrn);
   unsigned long swf1;
   Bool mapped;

   DPRINTF(PFX, "SetBIOSMemSize: %d kB\n", newSize / 1024);

   if (!pI830->overrideBIOSMemSize)
      return;

#if HAVE_GET_PUT_BIOSMEMSIZE
   if (!pI830->useSWF1) {
      PutBIOSMemSize(pScrn, newSize);
      return;
   }
#endif

   if ((IS_I830(pI830) || IS_845G(pI830)) && pI830->useSWF1) {
      unsigned long newSWF1;

      /* Need MMIO access here. */
      mapped = (pI830->MMIOBase != NULL);
      if (!mapped)
	 I830MapMMIO(pScrn);

      if (newSize <= KB(832))
	 newSWF1 = 1;
      else
	 newSWF1 = 8;

      swf1 = INREG(SWF1);
      xf86DrvMsg(pScrn->scrnIndex, X_INFO, "Before: SWF1 is 0x%08lx\n", swf1);
      swf1 &= ~0x0f;
      swf1 |= (newSWF1 & 0x0f);
      xf86DrvMsg(pScrn->scrnIndex, X_INFO, "After: SWF1 is 0x%08lx\n", swf1);
      OUTREG(SWF1, swf1);
      if (!mapped)
	 I830UnmapMMIO(pScrn);
   }
}

static CARD32 val8[256];

static void
I830LoadPalette(ScrnInfoPtr pScrn, int numColors, int *indices,
		LOCO * colors, VisualPtr pVisual)
{
   I830Ptr pI830;
   int i,j, index;
   unsigned char r, g, b;
   CARD32 val, temp;
   int palreg;
   int dspreg, dspbase, dspsurf;

   DPRINTF(PFX, "I830LoadPalette: numColors: %d\n", numColors);
   pI830 = I830PTR(pScrn);

   if (pI830->Clone || pI830->MergedFB) {
      if (!pI830->pipe == 0) {
         palreg = PALETTE_A;
         dspreg = DSPACNTR;
         dspbase = DSPABASE;
      } else {
         palreg = PALETTE_B;
         dspreg = DSPBCNTR;
         dspbase = DSPBBASE;
      }
   
      /* To ensure gamma is enabled we need to turn off and on the plane */
      temp = INREG(dspreg);
      OUTREG(dspreg, temp & ~(1<<31));
      OUTREG(dspbase, INREG(dspbase));
      OUTREG(dspreg, temp | DISPPLANE_GAMMA_ENABLE);
      OUTREG(dspbase, INREG(dspbase));

      /* It seems that an initial read is needed. */
      temp = INREG(palreg);

      switch(pScrn->depth) {
      case 15:
       for (i = 0; i < numColors; i++) {
         index = indices[i];
         r = colors[index].red;
         g = colors[index].green;
         b = colors[index].blue;
	 val = (r << 16) | (g << 8) | b;
         for (j = 0; j < 8; j++) {
	    OUTREG(palreg + index * 32 + (j * 4), val);
         }
       }
       break;
      case 16:
       for (i = 0; i < numColors; i++) {
         index = indices[i];
	 r   = colors[index / 2].red;
	 g   = colors[index].green;
	 b   = colors[index / 2].blue;

	 val = (r << 16) | (g << 8) | b;
	 OUTREG(palreg + index * 16, val);
	 OUTREG(palreg + index * 16 + 4, val);
	 OUTREG(palreg + index * 16 + 8, val);
	 OUTREG(palreg + index * 16 + 12, val);

   	 if (index <= 31) {
            r   = colors[index].red;
	    g   = colors[(index * 2) + 1].green;
	    b   = colors[index].blue;

	    val = (r << 16) | (g << 8) | b;
	    OUTREG(palreg + index * 32, val);
	    OUTREG(palreg + index * 32 + 4, val);
	    OUTREG(palreg + index * 32 + 8, val);
	    OUTREG(palreg + index * 32 + 12, val);
	 }
       }
       break;
      default:
       for(i = 0; i < numColors; i++) {
	 index = indices[i];
	 r = colors[index].red;
	 g = colors[index].green;
	 b = colors[index].blue;
	 val = (r << 16) | (g << 8) | b;
	 OUTREG(palreg + index * 4, val);
       }
       break;
      }
   }

   if (pI830->pipe == 0) {
      palreg = PALETTE_A;
      dspreg = DSPACNTR;
      dspbase = DSPABASE;
      dspsurf = DSPASURF;
   } else {
      palreg = PALETTE_B;
      dspreg = DSPBCNTR;
      dspbase = DSPBBASE;
      dspsurf = DSPBSURF;
   }

   /* To ensure gamma is enabled we need to turn off and on the plane */
   temp = INREG(dspreg);
   OUTREG(dspreg, temp & ~(1<<31));
   OUTREG(dspbase, INREG(dspbase));
   OUTREG(dspreg, temp | DISPPLANE_GAMMA_ENABLE);
   OUTREG(dspbase, INREG(dspbase));
   if (IS_I96X(pI830)) 
      OUTREG(dspsurf, INREG(dspsurf));

   /* It seems that an initial read is needed. */
   temp = INREG(palreg);

   switch(pScrn->depth) {
   case 15:
      for (i = 0; i < numColors; i++) {
         index = indices[i];
         r = colors[index].red;
         g = colors[index].green;
         b = colors[index].blue;
	 val = (r << 16) | (g << 8) | b;
         for (j = 0; j < 8; j++) {
	    OUTREG(palreg + index * 32 + (j * 4), val);
         }
      }
      break;
   case 16:
      for (i = 0; i < numColors; i++) {
         index = indices[i];
	 r   = colors[index / 2].red;
	 g   = colors[index].green;
	 b   = colors[index / 2].blue;

	 val = (r << 16) | (g << 8) | b;
	 OUTREG(palreg + index * 16, val);
	 OUTREG(palreg + index * 16 + 4, val);
	 OUTREG(palreg + index * 16 + 8, val);
	 OUTREG(palreg + index * 16 + 12, val);

   	 if (index <= 31) {
            r   = colors[index].red;
	    g   = colors[(index * 2) + 1].green;
	    b   = colors[index].blue;

	    val = (r << 16) | (g << 8) | b;
	    OUTREG(palreg + index * 32, val);
	    OUTREG(palreg + index * 32 + 4, val);
	    OUTREG(palreg + index * 32 + 8, val);
	    OUTREG(palreg + index * 32 + 12, val);
	 }
      }
      break;
   default:
#if 1
      /* Dual head 8bpp modes seem to squish the primary's cmap - reload */
      if (I830IsPrimary(pScrn) && xf86IsEntityShared(pScrn->entityList[0]) &&
          pScrn->depth == 8) {
         for(i = 0; i < numColors; i++) {
	    index = indices[i];
	    r = colors[index].red;
	    g = colors[index].green;
	    b = colors[index].blue;
	    val8[index] = (r << 16) | (g << 8) | b;
        }
      }
#endif
      for(i = 0; i < numColors; i++) {
	 index = indices[i];
	 r = colors[index].red;
	 g = colors[index].green;
	 b = colors[index].blue;
	 val = (r << 16) | (g << 8) | b;
	 OUTREG(palreg + index * 4, val);
#if 1
         /* Dual head 8bpp modes seem to squish the primary's cmap - reload */
         if (!I830IsPrimary(pScrn) && xf86IsEntityShared(pScrn->entityList[0]) &&
             pScrn->depth == 8) {
  	    if (palreg == PALETTE_A)
	       OUTREG(PALETTE_B + index * 4, val8[index]);
	    else
	       OUTREG(PALETTE_A + index * 4, val8[index]);
         }
#endif
      }
      break;
   }
}

static int
I830UseDDC(ScrnInfoPtr pScrn)
{
   xf86MonPtr DDC = (xf86MonPtr)(pScrn->monitor->DDC);
   struct detailed_monitor_section* detMon;
   struct monitor_ranges *mon_range = NULL;
   int i;

   if (!DDC) return 0;

   /* Now change the hsync/vrefresh values of the current monitor to
    * match those of DDC */
   for (i = 0; i < 4; i++) {
      detMon = &DDC->det_mon[i];
      if(detMon->type == DS_RANGES)
         mon_range = &detMon->section.ranges;
   }

   if (!mon_range || mon_range->min_h == 0 || mon_range->max_h == 0 ||
		     mon_range->min_v == 0 || mon_range->max_v == 0)
      return 0;	/* bad ddc */

   xf86DrvMsg(pScrn->scrnIndex, X_INFO, "Using detected DDC timings\n");
   xf86DrvMsg(pScrn->scrnIndex, X_INFO, "\tHorizSync %d-%d\n", 
		mon_range->min_h, mon_range->max_h);
   xf86DrvMsg(pScrn->scrnIndex, X_INFO, "\tVertRefresh %d-%d\n", 
		mon_range->min_v, mon_range->max_v);
#define DDC_SYNC_TOLERANCE SYNC_TOLERANCE
   if (pScrn->monitor->nHsync > 0) {
      for (i = 0; i < pScrn->monitor->nHsync; i++) {
         if ((1.0 - DDC_SYNC_TOLERANCE) * mon_range->min_h >
				pScrn->monitor->hsync[i].lo ||
	     (1.0 + DDC_SYNC_TOLERANCE) * mon_range->max_h <
				pScrn->monitor->hsync[i].hi) {
	    xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
			  "config file hsync range %g-%gkHz not within DDC "
			  "hsync range %d-%dkHz\n",
			  pScrn->monitor->hsync[i].lo, pScrn->monitor->hsync[i].hi,
			  mon_range->min_h, mon_range->max_h);
         }
         pScrn->monitor->hsync[i].lo = mon_range->min_h;
	 pScrn->monitor->hsync[i].hi = mon_range->max_h;
      }
   }

   if (pScrn->monitor->nVrefresh > 0) {
      for (i=0; i<pScrn->monitor->nVrefresh; i++) {
         if ((1.0 - DDC_SYNC_TOLERANCE) * mon_range->min_v >
				pScrn->monitor->vrefresh[i].lo ||
	     (1.0 + DDC_SYNC_TOLERANCE) * mon_range->max_v <
				pScrn->monitor->vrefresh[i].hi) {
   	    xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
			  "config file vrefresh range %g-%gHz not within DDC "
			  "vrefresh range %d-%dHz\n",
			  pScrn->monitor->vrefresh[i].lo, pScrn->monitor->vrefresh[i].hi,
			  mon_range->min_v, mon_range->max_v);
         }
         pScrn->monitor->vrefresh[i].lo = mon_range->min_v;
         pScrn->monitor->vrefresh[i].hi = mon_range->max_v;
      }
   }

   return mon_range->max_clock;
}

static void
PreInitCleanup(ScrnInfoPtr pScrn)
{
   I830Ptr pI830 = I830PTR(pScrn);

   if (I830IsPrimary(pScrn)) {
      SetPipeAccess(pScrn);

      pI830->entityPrivate->pScrn_1 = NULL;
      if (pI830->LpRing)
         xfree(pI830->LpRing);
      pI830->LpRing = NULL;
      if (pI830->CursorMem)
         xfree(pI830->CursorMem);
      pI830->CursorMem = NULL;
      if (pI830->CursorMemARGB) 
         xfree(pI830->CursorMemARGB);
      pI830->CursorMemARGB = NULL;
      if (pI830->OverlayMem)
         xfree(pI830->OverlayMem);
      pI830->OverlayMem = NULL;
      if (pI830->overlayOn)
         xfree(pI830->overlayOn);
      pI830->overlayOn = NULL;
      if (pI830->used3D)
         xfree(pI830->used3D);
      pI830->used3D = NULL;
   } else {
      if (pI830->entityPrivate)
         pI830->entityPrivate->pScrn_2 = NULL;
   }
   RestoreBIOSMemSize(pScrn);
   if (pI830->swfSaved) {
      OUTREG(SWF0, pI830->saveSWF0);
      OUTREG(SWF4, pI830->saveSWF4);
   }
   if (pI830->MMIOBase)
      I830UnmapMMIO(pScrn);
   I830BIOSFreeRec(pScrn);
}

Bool
I830IsPrimary(ScrnInfoPtr pScrn)
{
   I830Ptr pI830 = I830PTR(pScrn);

   if (xf86IsEntityShared(pScrn->entityList[0])) {
	if (pI830->init == 0) return TRUE;
	else return FALSE;
   }

   return TRUE;
}

#ifdef XF86DRI
static void 
I830ReduceMMSize(ScrnInfoPtr pScrn, unsigned long newSize,
		 const char *reason)
{
   I830Ptr pI830 = I830PTR(pScrn);

   newSize = ROUND_DOWN_TO(newSize, GTT_PAGE_SIZE);
   if (newSize / GTT_PAGE_SIZE > I830_MM_MINPAGES) {
      pI830->mmSize = newSize / 1024;
      xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
		 "DRM memory manager aperture size is reduced to %d kiB\n"
		 "\t%s\n", pI830->mmSize, reason);
   } else {
      xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
		 "DRM memory manager will be disabled\n\t%s\n", reason);
      pI830->mmSize = 0;
   }
}
#endif


static Bool
I830BIOSPreInit(ScrnInfoPtr pScrn, int flags)
{
   vgaHWPtr hwp;
   I830Ptr pI830;
   MessageType from = X_PROBED;
   rgb defaultWeight = { 0, 0, 0 };
   EntityInfoPtr pEnt;
   I830EntPtr pI830Ent = NULL;					
   int mem, memsize;
   int flags24;
   int defmon = 0;
   int i, n;
   int DDCclock = 0, DDCclock2 = 0;
   char *s;
   DisplayModePtr p, pMon;
   xf86MonPtr monitor = NULL;
   pointer pDDCModule = NULL, pVBEModule = NULL;
   Bool enable;
   const char *chipname;
   unsigned int ver;
   char v[5];
#ifdef XF86DRI
   unsigned long savedMMSize;
#endif

   if (pScrn->numEntities != 1)
      return FALSE;

   /* Load int10 module */
   if (!xf86LoadSubModule(pScrn, "int10"))
      return FALSE;
   xf86LoaderReqSymLists(I810int10Symbols, NULL);

   /* Load vbe module */
   if (!(pVBEModule = xf86LoadSubModule(pScrn, "vbe")))
      return FALSE;
   xf86LoaderReqSymLists(I810vbeSymbols, NULL);

   pEnt = xf86GetEntityInfo(pScrn->entityList[0]);

   if (flags & PROBE_DETECT) {
      I830BIOSProbeDDC(pScrn, pEnt->index);
      return TRUE;
   }

   /* The vgahw module should be loaded here when needed */
   if (!xf86LoadSubModule(pScrn, "vgahw"))
      return FALSE;
   xf86LoaderReqSymLists(I810vgahwSymbols, NULL);

   /* Allocate a vgaHWRec */
   if (!vgaHWGetHWRec(pScrn))
      return FALSE;

   /* Allocate driverPrivate */
   if (!I830BIOSGetRec(pScrn))
      return FALSE;

   pI830 = I830PTR(pScrn);
   pI830->SaveGeneration = -1;
   pI830->pEnt = pEnt;

   pI830->displayWidth = 640; /* default it */

   if (pI830->pEnt->location.type != BUS_PCI)
      return FALSE;

   pI830->PciInfo = xf86GetPciInfoForEntity(pI830->pEnt->index);
   pI830->PciTag = pciTag(pI830->PciInfo->bus, pI830->PciInfo->device,
			  pI830->PciInfo->func);

    /* Allocate an entity private if necessary */
    if (xf86IsEntityShared(pScrn->entityList[0])) {
	pI830Ent = xf86GetEntityPrivate(pScrn->entityList[0],
					I830EntityIndex)->ptr;
        pI830->entityPrivate = pI830Ent;
    } else 
        pI830->entityPrivate = NULL;

   if (xf86RegisterResources(pI830->pEnt->index, 0, ResNone)) {
      PreInitCleanup(pScrn);
      return FALSE;
   }

   if (xf86IsEntityShared(pScrn->entityList[0])) {
      if (xf86IsPrimInitDone(pScrn->entityList[0])) {
	 pI830->init = 1;
d1119 2
a1120 1708
         xf86SetPrimInitDone(pScrn->entityList[0]);
	 pI830->init = 0;
      }
   }

   if (xf86IsEntityShared(pScrn->entityList[0])) {
      if (!I830IsPrimary(pScrn)) {
         pI830Ent->pScrn_2 = pScrn;
      } else {
         pI830Ent->pScrn_1 = pScrn;
         pI830Ent->pScrn_2 = NULL;
      }
   }

   pScrn->racMemFlags = RAC_FB | RAC_COLORMAP;
   pScrn->monitor = pScrn->confScreen->monitor;
   pScrn->progClock = TRUE;
   pScrn->rgbBits = 8;

   flags24 = Support32bppFb | PreferConvert24to32 | SupportConvert24to32;

   if (!xf86SetDepthBpp(pScrn, 0, 0, 0, flags24))
      return FALSE;

   switch (pScrn->depth) {
   case 8:
   case 15:
   case 16:
   case 24:
      break;
   default:
      xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
		 "Given depth (%d) is not supported by I830 driver\n",
		 pScrn->depth);
      return FALSE;
   }
   xf86PrintDepthBpp(pScrn);

   if (!xf86SetWeight(pScrn, defaultWeight, defaultWeight))
      return FALSE;
   if (!xf86SetDefaultVisual(pScrn, -1))
      return FALSE;

   hwp = VGAHWPTR(pScrn);
   pI830->cpp = pScrn->bitsPerPixel / 8;

   pI830->preinit = TRUE;

   /* Process the options */
   xf86CollectOptions(pScrn, NULL);
   if (!(pI830->Options = xalloc(sizeof(I830BIOSOptions))))
      return FALSE;
   memcpy(pI830->Options, I830BIOSOptions, sizeof(I830BIOSOptions));
   xf86ProcessOptions(pScrn->scrnIndex, pScrn->options, pI830->Options);

   /* We have to use PIO to probe, because we haven't mapped yet. */
   I830SetPIOAccess(pI830);

   /* Initialize VBE record */
   if (I830IsPrimary(pScrn)) {
      if ((pI830->pVbe = VBEInit(NULL, pI830->pEnt->index)) == NULL) {
         xf86DrvMsg(pScrn->scrnIndex, X_ERROR, "VBE initialization failed.\n");
         return FALSE;
      }
   } else {
      I830Ptr pI8301 = I830PTR(pI830->entityPrivate->pScrn_1);
      pI830->pVbe = pI8301->pVbe;
   }

   switch (pI830->PciInfo->chipType) {
   case PCI_CHIP_I830_M:
      chipname = "830M";
      break;
   case PCI_CHIP_845_G:
      chipname = "845G";
      break;
   case PCI_CHIP_I855_GM:
      /* Check capid register to find the chipset variant */
      pI830->variant = (pciReadLong(pI830->PciTag, I85X_CAPID)
				>> I85X_VARIANT_SHIFT) & I85X_VARIANT_MASK;
      switch (pI830->variant) {
      case I855_GM:
	 chipname = "855GM";
	 break;
      case I855_GME:
	 chipname = "855GME";
	 break;
      case I852_GM:
	 chipname = "852GM";
	 break;
      case I852_GME:
	 chipname = "852GME";
	 break;
      default:
	 xf86DrvMsg(pScrn->scrnIndex, X_INFO,
		    "Unknown 852GM/855GM variant: 0x%x)\n", pI830->variant);
	 chipname = "852GM/855GM (unknown variant)";
	 break;
      }
      break;
   case PCI_CHIP_I865_G:
      chipname = "865G";
      break;
   case PCI_CHIP_I915_G:
      chipname = "915G";
      break;
   case PCI_CHIP_E7221_G:
      chipname = "E7221 (i915)";
      break;
   case PCI_CHIP_I915_GM:
      chipname = "915GM";
      break;
   case PCI_CHIP_I945_G:
      chipname = "945G";
      break;
   case PCI_CHIP_I945_GM:
      chipname = "945GM";
      break;
   case PCI_CHIP_I965_G:
   case PCI_CHIP_I965_G_1:
      chipname = "965G";
      break;
   case PCI_CHIP_I965_Q:
      chipname = "965Q";
      break;
   case PCI_CHIP_I946_GZ:
      chipname = "946GZ";
      break;
   case PCI_CHIP_I965_GM:
      chipname = "965GM";
      break;
   default:
      chipname = "unknown chipset";
      break;
   }
   xf86DrvMsg(pScrn->scrnIndex, X_INFO,
	      "Integrated Graphics Chipset: Intel(R) %s\n", chipname);

   if (I830IsPrimary(pScrn)) {
      pI830->vbeInfo = VBEGetVBEInfo(pI830->pVbe);
   } else {
      I830Ptr pI8301 = I830PTR(pI830->entityPrivate->pScrn_1);
      pI830->vbeInfo = pI8301->vbeInfo;
   }

   /* Set the Chipset and ChipRev, allowing config file entries to override. */
   if (pI830->pEnt->device->chipset && *pI830->pEnt->device->chipset) {
      pScrn->chipset = pI830->pEnt->device->chipset;
      from = X_CONFIG;
   } else if (pI830->pEnt->device->chipID >= 0) {
      pScrn->chipset = (char *)xf86TokenToString(I830BIOSChipsets,
						 pI830->pEnt->device->chipID);
      from = X_CONFIG;
      xf86DrvMsg(pScrn->scrnIndex, X_CONFIG, "ChipID override: 0x%04X\n",
		 pI830->pEnt->device->chipID);
      pI830->PciInfo->chipType = pI830->pEnt->device->chipID;
   } else {
      from = X_PROBED;
      pScrn->chipset = (char *)xf86TokenToString(I830BIOSChipsets,
						 pI830->PciInfo->chipType);
   }

   if (pI830->pEnt->device->chipRev >= 0) {
      xf86DrvMsg(pScrn->scrnIndex, X_CONFIG, "ChipRev override: %d\n",
		 pI830->pEnt->device->chipRev);
   }

   xf86DrvMsg(pScrn->scrnIndex, from, "Chipset: \"%s\"\n",
	      (pScrn->chipset != NULL) ? pScrn->chipset : "Unknown i8xx");

   if (pI830->pEnt->device->MemBase != 0) {
      pI830->LinearAddr = pI830->pEnt->device->MemBase;
      from = X_CONFIG;
   } else {
      if (IS_I9XX(pI830)) {
	 pI830->LinearAddr = pI830->PciInfo->memBase[2] & 0xFF000000;
	 from = X_PROBED;
      } else if (pI830->PciInfo->memBase[1] != 0) {
	 /* XXX Check mask. */
	 pI830->LinearAddr = pI830->PciInfo->memBase[0] & 0xFF000000;
	 from = X_PROBED;
      } else {
	 xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
		    "No valid FB address in PCI config space\n");
	 PreInitCleanup(pScrn);
	 return FALSE;
      }
   }

   xf86DrvMsg(pScrn->scrnIndex, from, "Linear framebuffer at 0x%lX\n",
	      (unsigned long)pI830->LinearAddr);

   if (pI830->pEnt->device->IOBase != 0) {
      pI830->MMIOAddr = pI830->pEnt->device->IOBase;
      from = X_CONFIG;
   } else {
      if (IS_I9XX(pI830)) {
	 pI830->MMIOAddr = pI830->PciInfo->memBase[0] & 0xFFF80000;
	 from = X_PROBED;
      } else if (pI830->PciInfo->memBase[1]) {
	 pI830->MMIOAddr = pI830->PciInfo->memBase[1] & 0xFFF80000;
	 from = X_PROBED;
      } else {
	 xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
		    "No valid MMIO address in PCI config space\n");
	 PreInitCleanup(pScrn);
	 return FALSE;
      }
   }

   xf86DrvMsg(pScrn->scrnIndex, from, "IO registers at addr 0x%lX\n",
	      (unsigned long)pI830->MMIOAddr);

   /* Some of the probing needs MMIO access, so map it here. */
   I830MapMMIO(pScrn);

#if 1
   pI830->saveSWF0 = INREG(SWF0);
   pI830->saveSWF4 = INREG(SWF4);
   pI830->swfSaved = TRUE;

   /* Set "extended desktop" */
   OUTREG(SWF0, pI830->saveSWF0 | (1 << 21));

   /* Set "driver loaded",  "OS unknown", "APM 1.2" */
   OUTREG(SWF4, (pI830->saveSWF4 & ~((3 << 19) | (7 << 16))) |
		(1 << 23) | (2 << 16));
#endif

   if (IS_I830(pI830) || IS_845G(pI830)) {
      PCITAG bridge;
      CARD16 gmch_ctrl;

      bridge = pciTag(0, 0, 0);		/* This is always the host bridge */
      gmch_ctrl = pciReadWord(bridge, I830_GMCH_CTRL);
      if ((gmch_ctrl & I830_GMCH_MEM_MASK) == I830_GMCH_MEM_128M) {
	 pI830->FbMapSize = 0x8000000;
      } else {
	 pI830->FbMapSize = 0x4000000; /* 64MB - has this been tested ?? */
      }
   } else {
      if (IS_I9XX(pI830) && !IS_I965GM(pI830) &&
	  pI830->PciInfo->chipType != PCI_CHIP_E7221_G) {
	 if (pI830->PciInfo->memBase[2] & 0x08000000)
	    pI830->FbMapSize = 0x8000000;	/* 128MB aperture */
	 else
	    pI830->FbMapSize = 0x10000000;	/* 256MB aperture */
      } else
	 /* 128MB aperture for later chips */
	 pI830->FbMapSize = 0x8000000;
   }

   if (pI830->PciInfo->chipType == PCI_CHIP_E7221_G)
      pI830->availablePipes = 1;
   else
   if (IS_MOBILE(pI830) || IS_I9XX(pI830))
      pI830->availablePipes = 2;
   else
      pI830->availablePipes = 1;
   xf86DrvMsg(pScrn->scrnIndex, X_INFO, "%d display pipe%s available.\n",
	      pI830->availablePipes, pI830->availablePipes > 1 ? "s" : "");

   /*
    * Get the pre-allocated (stolen) memory size.
    */
   pI830->StolenMemory.Size = I830DetectMemory(pScrn);
   pI830->StolenMemory.Start = 0;
   pI830->StolenMemory.End = pI830->StolenMemory.Size;

   /* Sanity check: compare with what the BIOS thinks. */
   if (pI830->vbeInfo->TotalMemory != pI830->StolenMemory.Size / 1024 / 64) {
      xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
		 "Detected stolen memory (%ld kB) doesn't match what the BIOS"
		 " reports (%d kB)\n",
		 ROUND_DOWN_TO(pI830->StolenMemory.Size / 1024, 64),
		 pI830->vbeInfo->TotalMemory * 64);
   }

   /* Find the maximum amount of agpgart memory available. */
   if (I830IsPrimary(pScrn)) {
      mem = I830CheckAvailableMemory(pScrn);
      pI830->StolenOnly = FALSE;
   } else {
      /* videoRam isn't used on the second head, but faked */
      mem = pI830->entityPrivate->pScrn_1->videoRam;
      pI830->StolenOnly = TRUE;
   }

   if (mem <= 0) {
      if (pI830->StolenMemory.Size <= 0) {
	 /* Shouldn't happen. */
	 xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
		 "/dev/agpgart is either not available, or no memory "
		 "is available\nfor allocation, "
		 "and no pre-allocated memory is available.\n");
	 PreInitCleanup(pScrn);
	 return FALSE;
      }
      xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
		 "/dev/agpgart is either not available, or no memory "
		 "is available\nfor allocation.  "
		 "Using pre-allocated memory only.\n");
      mem = 0;
      pI830->StolenOnly = TRUE;
   }

   if (xf86ReturnOptValBool(pI830->Options, OPTION_NOACCEL, FALSE)) {
      pI830->noAccel = TRUE;
   }
   if (xf86ReturnOptValBool(pI830->Options, OPTION_SW_CURSOR, FALSE)) {
      pI830->SWCursor = TRUE;
   }

   pI830->directRenderingDisabled =
	!xf86ReturnOptValBool(pI830->Options, OPTION_DRI, TRUE);

#ifdef XF86DRI
   if (!pI830->directRenderingDisabled) {
      if (pI830->noAccel || pI830->SWCursor) {
	 xf86DrvMsg(pScrn->scrnIndex, X_CONFIG, "DRI is disabled because it "
		    "needs HW cursor and 2D acceleration.\n");
	 pI830->directRenderingDisabled = TRUE;
      } else if (pScrn->depth != 16 && pScrn->depth != 24) {
	 xf86DrvMsg(pScrn->scrnIndex, X_CONFIG, "DRI is disabled because it "
		    "runs only at depths 16 and 24.\n");
	 pI830->directRenderingDisabled = TRUE;
      }

      pI830->mmModeFlags = 0;

      if (!pI830->directRenderingDisabled) {
	 Bool tmp = FALSE;

	 if (IS_I96X(pI830))
	    pI830->mmModeFlags |= I830_KERNEL_TEX;

	 from = X_PROBED;
	 if (xf86GetOptValBool(pI830->Options, 
			       OPTION_INTELTEXPOOL, &tmp)) {
	    from = X_CONFIG;
	    if (tmp) {
	       pI830->mmModeFlags |= I830_KERNEL_TEX;
	    } else {
	       pI830->mmModeFlags &= ~I830_KERNEL_TEX;
	    }	       
	 }
	 if (from == X_CONFIG || 
	     (pI830->mmModeFlags & I830_KERNEL_TEX)) { 
	    xf86DrvMsg(pScrn->scrnIndex, from, 
		       "Will %stry to allocate texture pool "
		       "for old Mesa 3D driver.\n",
		       (pI830->mmModeFlags & I830_KERNEL_TEX) ? 
		       "" : "not ");
	 }
	 pI830->mmSize = I830_MM_MAXSIZE;
	 from = X_INFO;
	 if (xf86GetOptValInteger(pI830->Options, OPTION_INTELMMSIZE,
				  &(pI830->mmSize))) {
	    from = X_CONFIG;
	 }
	 xf86DrvMsg(pScrn->scrnIndex, from, 
		    "Will try to reserve %d kiB of AGP aperture space\n"
		    "\tfor the DRM memory manager.\n",
		    pI830->mmSize);
      }
   } 
   
#endif

   pI830->LinearAlloc = 0;
   if (xf86GetOptValInteger(pI830->Options, OPTION_LINEARALLOC,
			    &(pI830->LinearAlloc))) {
      if (pI830->LinearAlloc > 0)
         xf86DrvMsg(pScrn->scrnIndex, X_CONFIG, "Allocating %dKbytes of memory\n",
		 pI830->LinearAlloc);
      else 
         pI830->LinearAlloc = 0;
   }

   pI830->fixedPipe = -1;
   if ((s = xf86GetOptValString(pI830->Options, OPTION_FIXEDPIPE)) &&
      I830IsPrimary(pScrn)) {

      if (strstr(s, "A") || strstr(s, "a") || strstr(s, "0"))
         pI830->fixedPipe = 0;
      else if (strstr(s, "B") || strstr(s, "b") || strstr(s, "1"))
         pI830->fixedPipe = 1;
   }

   pI830->MergedFB =
      xf86ReturnOptValBool(pI830->Options, OPTION_MERGEDFB, FALSE);

   pI830->IntelXinerama =
      xf86ReturnOptValBool(pI830->Options, OPTION_INTELXINERAMA, TRUE);

   pI830->MonType1 = PIPE_NONE;
   pI830->MonType2 = PIPE_NONE;
   pI830->specifiedMonitor = FALSE;

   if ((s = xf86GetOptValString(pI830->Options, OPTION_MONITOR_LAYOUT)) &&
      I830IsPrimary(pScrn)) {
      char *Mon1;
      char *Mon2;
      char *sub;
        
      Mon1 = strtok(s, ",");
      Mon2 = strtok(NULL, ",");

      if (Mon1) {
         sub = strtok(Mon1, "+");
         do {
            if (strcmp(sub, "NONE") == 0)
               pI830->MonType1 |= PIPE_NONE;
            else if (strcmp(sub, "CRT") == 0)
               pI830->MonType1 |= PIPE_CRT;
            else if (strcmp(sub, "TV") == 0)
               pI830->MonType1 |= PIPE_TV;
            else if (strcmp(sub, "DFP") == 0)
               pI830->MonType1 |= PIPE_DFP;
            else if (strcmp(sub, "LFP") == 0)
               pI830->MonType1 |= PIPE_LFP;
            else if (strcmp(sub, "Second") == 0)
               pI830->MonType1 |= PIPE_CRT2;
            else if (strcmp(sub, "TV2") == 0)
               pI830->MonType1 |= PIPE_TV2;
            else if (strcmp(sub, "DFP2") == 0)
               pI830->MonType1 |= PIPE_DFP2;
            else if (strcmp(sub, "LFP2") == 0)
               pI830->MonType1 |= PIPE_LFP2;
            else 
               xf86DrvMsg(pScrn->scrnIndex, X_WARNING, 
			       "Invalid Monitor type specified for Pipe A\n"); 

            sub = strtok(NULL, "+");
         } while (sub);
      }

      if (Mon2) {
         sub = strtok(Mon2, "+");
         do {
            if (strcmp(sub, "NONE") == 0)
               pI830->MonType2 |= PIPE_NONE;
            else if (strcmp(sub, "CRT") == 0)
               pI830->MonType2 |= PIPE_CRT;
            else if (strcmp(sub, "TV") == 0)
               pI830->MonType2 |= PIPE_TV;
            else if (strcmp(sub, "DFP") == 0)
               pI830->MonType2 |= PIPE_DFP;
            else if (strcmp(sub, "LFP") == 0)
               pI830->MonType2 |= PIPE_LFP;
            else if (strcmp(sub, "Second") == 0)
               pI830->MonType2 |= PIPE_CRT2;
            else if (strcmp(sub, "TV2") == 0)
               pI830->MonType2 |= PIPE_TV2;
            else if (strcmp(sub, "DFP2") == 0)
               pI830->MonType2 |= PIPE_DFP2;
            else if (strcmp(sub, "LFP2") == 0)
               pI830->MonType2 |= PIPE_LFP2;
            else 
               xf86DrvMsg(pScrn->scrnIndex, X_WARNING, 
			       "Invalid Monitor type specified for Pipe B\n"); 

               sub = strtok(NULL, "+");
            } while (sub);
         }
    
         if (pI830->availablePipes == 1 && pI830->MonType2 != PIPE_NONE) {
	    xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
		    "Monitor 2 cannot be specified on single pipe devices\n");
            return FALSE;
         }

         if (pI830->MonType1 == PIPE_NONE && pI830->MonType2 == PIPE_NONE) {
	    xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
		    "Monitor 1 and 2 cannot be type NONE\n");
            return FALSE;
      }

      pI830->specifiedMonitor = TRUE;
   }

   if (!pI830->MergedFB &&
       xf86ReturnOptValBool(pI830->Options, OPTION_CLONE, FALSE)) {
      if (pI830->availablePipes == 1) {
         xf86DrvMsg(pScrn->scrnIndex, X_ERROR, 
 		 "Can't enable Clone Mode because this is a single pipe device\n");
         PreInitCleanup(pScrn);
         return FALSE;
      }
      if (pI830->entityPrivate) {
         xf86DrvMsg(pScrn->scrnIndex, X_ERROR, 
 		 "Can't enable Clone Mode because second head is configured\n");
         PreInitCleanup(pScrn);
         return FALSE;
      }
      xf86DrvMsg(pScrn->scrnIndex, X_INFO, "Enabling Clone Mode\n");
      pI830->Clone = TRUE;
   }

   pI830->CloneRefresh = 60; /* default to 60Hz */
   if (xf86GetOptValInteger(pI830->Options, OPTION_CLONE_REFRESH,
			    &(pI830->CloneRefresh))) {
      xf86DrvMsg(pScrn->scrnIndex, X_CONFIG, "Clone Monitor Refresh Rate %d\n",
		 pI830->CloneRefresh);
   }

   /* See above i830refreshes on why 120Hz is commented out */
   if (pI830->CloneRefresh < 60 || pI830->CloneRefresh > 85 /* 120 */) {
      xf86DrvMsg(pScrn->scrnIndex, X_ERROR, "Bad Clone Refresh Rate\n");
      PreInitCleanup(pScrn);
      return FALSE;
   }

   if ((pI830->entityPrivate && I830IsPrimary(pScrn)) || pI830->Clone ||
	pI830->MergedFB) {
      if ((!xf86GetOptValString(pI830->Options, OPTION_MONITOR_LAYOUT))) {
	 xf86DrvMsg(pScrn->scrnIndex, X_ERROR, "You must have a MonitorLayout "
	 		"defined for use in a DualHead, Clone or MergedFB setup.\n");
         PreInitCleanup(pScrn);
         return FALSE;
      }
         
      if (pI830->MonType1 == PIPE_NONE || pI830->MonType2 == PIPE_NONE) {
         xf86DrvMsg(pScrn->scrnIndex, X_ERROR, "Monitor 1 or Monitor 2 "
	 		"cannot be type NONE in DualHead, Clone or MergedFB setup.\n");
         PreInitCleanup(pScrn);
         return FALSE;
      }
   }

   pI830->rotation = RR_Rotate_0;
   if ((s = xf86GetOptValString(pI830->Options, OPTION_ROTATE))) {
      pI830->InitialRotation = 0;
      if(!xf86NameCmp(s, "CW") || !xf86NameCmp(s, "270"))
         pI830->InitialRotation = 270;
      if(!xf86NameCmp(s, "CCW") || !xf86NameCmp(s, "90"))
         pI830->InitialRotation = 90;
      if(!xf86NameCmp(s, "180"))
         pI830->InitialRotation = 180;
   }

   /*
    * Let's setup the mobile systems to check the lid status
    */
   if (IS_MOBILE(pI830) && !pI830->MergedFB) {
      pI830->checkDevices = TRUE;

      if (!xf86ReturnOptValBool(pI830->Options, OPTION_CHECKDEVICES, TRUE)) {
         pI830->checkDevices = FALSE;
         xf86DrvMsg(pScrn->scrnIndex, X_INFO, "Monitoring connected displays disabled\n");
      } else
      if (pI830->entityPrivate && !I830IsPrimary(pScrn) &&
          !I830PTR(pI830->entityPrivate->pScrn_1)->checkDevices) {
         /* If checklid is off, on the primary head, then 
          * turn it off on the secondary*/
         xf86DrvMsg(pScrn->scrnIndex, X_INFO, "Monitoring connected displays disabled\n");
         pI830->checkDevices = FALSE;
      } else
         xf86DrvMsg(pScrn->scrnIndex, X_INFO, "Monitoring connected displays enabled\n");
   } else
      pI830->checkDevices = FALSE;

   /*
    * The "VideoRam" config file parameter specifies the total amount of
    * memory that will be used/allocated.  When agpgart support isn't
    * available (StolenOnly == TRUE), this is limited to the amount of
    * pre-allocated ("stolen") memory.
    */

   /*
    * Default to I830_DEFAULT_VIDEOMEM_2D (8192KB) for 2D-only,
    * or I830_DEFAULT_VIDEOMEM_3D (32768KB) for 3D.  If the stolen memory
    * amount is higher, default to it rounded up to the nearest MB.  This
    * guarantees that by default there will be at least some run-time
    * space for things that need a physical address.
    * But, we double the amounts when dual head is enabled, and therefore
    * for 2D-only we use 16384KB, and 3D we use 65536KB. The VideoRAM 
    * for the second head is never used, as the primary head does the 
    * allocation.
    */
   if (!pI830->pEnt->device->videoRam) {
      from = X_DEFAULT;
#ifdef XF86DRI
      if (!pI830->directRenderingDisabled)
	 pScrn->videoRam = I830_DEFAULT_VIDEOMEM_3D;
      else
#endif
	 pScrn->videoRam = I830_DEFAULT_VIDEOMEM_2D;

      if (xf86IsEntityShared(pScrn->entityList[0])) {
         if (I830IsPrimary(pScrn))
            pScrn->videoRam += I830_DEFAULT_VIDEOMEM_2D;
      else
            pScrn->videoRam = I830_MAXIMUM_VBIOS_MEM;
      } 

      if (pI830->StolenMemory.Size / 1024 > pScrn->videoRam)
	 pScrn->videoRam = ROUND_TO(pI830->StolenMemory.Size / 1024, 1024);
   } else {
      from = X_CONFIG;
      pScrn->videoRam = pI830->pEnt->device->videoRam;
   }

   /* Make sure it's on a page boundary */
   if (pScrn->videoRam & (GTT_PAGE_SIZE - 1)) {
      xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
		    "VideoRAM reduced to %d kByte "
		    "(page aligned - was %d)\n", pScrn->videoRam & ~(GTT_PAGE_SIZE - 1), pScrn->videoRam);
      pScrn->videoRam &= ~(GTT_PAGE_SIZE - 1);
   }

   DPRINTF(PFX,
	   "Available memory: %dk\n"
	   "Requested memory: %dk\n", mem, pScrn->videoRam);


   if (mem + (pI830->StolenMemory.Size / 1024) < pScrn->videoRam) {
      pScrn->videoRam = mem + (pI830->StolenMemory.Size / 1024);
      from = X_PROBED;
      if (mem + (pI830->StolenMemory.Size / 1024) <
	  pI830->pEnt->device->videoRam) {
	 xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
		    "VideoRAM reduced to %d kByte "
		    "(limited to available sysmem)\n", pScrn->videoRam);
      }
   }

   if (pScrn->videoRam > pI830->FbMapSize / 1024) {
      pScrn->videoRam = pI830->FbMapSize / 1024;
      if (pI830->FbMapSize / 1024 < pI830->pEnt->device->videoRam)
	 xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
		    "VideoRam reduced to %d kByte (limited to aperture size)\n",
		    pScrn->videoRam);
   }

   if (mem > 0) {
      /*
       * If the reserved (BIOS accessible) memory is less than the desired
       * amount, try to increase it.  So far this is only implemented for
       * the 845G and 830, but those details are handled in SetBIOSMemSize().
       * 
       * The BIOS-accessible amount is only important for setting video
       * modes.  The maximum amount we try to set is limited to what would
       * be enough for 1920x1440 with a 2048 pitch.
       *
       * If ALLOCATE_ALL_BIOSMEM is enabled in i830_memory.c, all of the
       * BIOS-aware memory will get allocated.  If it isn't then it may
       * not be, and in that case there is an assumption that the video
       * BIOS won't attempt to access memory beyond what is needed for
       * modes that are actually used.  ALLOCATE_ALL_BIOSMEM is enabled by
       * default.
       */

      /* Try to keep HW cursor and Overlay amounts separate from this. */
      int reserve = (HWCURSOR_SIZE + HWCURSOR_SIZE_ARGB + OVERLAY_SIZE) / 1024;

      if (pScrn->videoRam - reserve >= I830_MAXIMUM_VBIOS_MEM)
	 pI830->newBIOSMemSize = KB(I830_MAXIMUM_VBIOS_MEM);
      else 
	 pI830->newBIOSMemSize =
			KB(ROUND_DOWN_TO(pScrn->videoRam - reserve, 64));
      if (pI830->vbeInfo->TotalMemory * 64 < pI830->newBIOSMemSize / 1024) {

	 xf86DrvMsg(pScrn->scrnIndex, X_INFO,
		    "Will attempt to tell the BIOS that there is "
		    "%d kB VideoRAM\n", pI830->newBIOSMemSize / 1024);
	 if (SaveBIOSMemSize(pScrn)) {
	    pI830->overrideBIOSMemSize = TRUE;
	    SetBIOSMemSize(pScrn, pI830->newBIOSMemSize);

	    if (I830IsPrimary(pScrn)) {
	       VBEFreeVBEInfo(pI830->vbeInfo);
	       vbeFree(pI830->pVbe);
	       pI830->pVbe = VBEInit(NULL, pI830->pEnt->index);
	       pI830->vbeInfo = VBEGetVBEInfo(pI830->pVbe);
	    } else {
               I830Ptr pI8301 = I830PTR(pI830->entityPrivate->pScrn_1);
	       pI830->pVbe = pI8301->pVbe;
	       pI830->vbeInfo = pI8301->vbeInfo;
	    }

	    pI830->BIOSMemorySize = KB(pI830->vbeInfo->TotalMemory * 64);
	    xf86DrvMsg(pScrn->scrnIndex, X_INFO,
		       "BIOS now sees %ld kB VideoRAM\n",
		       pI830->BIOSMemorySize / 1024);
 	 } else if ((pI830->saveBIOSMemSize
		 = TweakMemorySize(pScrn, pI830->newBIOSMemSize,TRUE)) != 0) 
	     pI830->overrideBIOSMemSize = TRUE;
	 else {
	     xf86DrvMsg(pScrn->scrnIndex, X_INFO,
			"BIOS view of memory size can't be changed "
			"(this is not an error).\n");
	 }
      }
   }

   xf86DrvMsg(pScrn->scrnIndex, X_PROBED,
	      "Pre-allocated VideoRAM: %ld kByte\n",
	      pI830->StolenMemory.Size / 1024);
   xf86DrvMsg(pScrn->scrnIndex, from, "VideoRAM: %d kByte\n",
	      pScrn->videoRam);

   pI830->TotalVideoRam = KB(pScrn->videoRam);

   /*
    * If the requested videoRam amount is less than the stolen memory size,
    * reduce the stolen memory size accordingly.
    */
   if (pI830->StolenMemory.Size > pI830->TotalVideoRam) {
      pI830->StolenMemory.Size = pI830->TotalVideoRam;
      pI830->StolenMemory.End = pI830->TotalVideoRam;
   }

   if (xf86GetOptValInteger(pI830->Options, OPTION_CACHE_LINES,
			    &(pI830->CacheLines))) {
      xf86DrvMsg(pScrn->scrnIndex, X_CONFIG, "Requested %d cache lines\n",
		 pI830->CacheLines);
   } else {
      pI830->CacheLines = -1;
   }

   pI830->XvDisabled =
	!xf86ReturnOptValBool(pI830->Options, OPTION_XVIDEO, TRUE);

#ifdef I830_XV
   if (xf86GetOptValInteger(pI830->Options, OPTION_VIDEO_KEY,
			    &(pI830->colorKey))) {
      from = X_CONFIG;
   } else if (xf86GetOptValInteger(pI830->Options, OPTION_COLOR_KEY,
			    &(pI830->colorKey))) {
      from = X_CONFIG;
   } else {
      pI830->colorKey = (1 << pScrn->offset.red) |
			(1 << pScrn->offset.green) |
			(((pScrn->mask.blue >> pScrn->offset.blue) - 1) <<
			 pScrn->offset.blue);
      from = X_DEFAULT;
   }
   xf86DrvMsg(pScrn->scrnIndex, from, "video overlay key set to 0x%x\n",
	      pI830->colorKey);
#endif

   pI830->allowPageFlip = FALSE;
   enable = xf86ReturnOptValBool(pI830->Options, OPTION_PAGEFLIP, FALSE);
#ifdef XF86DRI
   if (!pI830->directRenderingDisabled) {
      pI830->allowPageFlip = enable;
      xf86DrvMsg(pScrn->scrnIndex, X_CONFIG, "page flipping %s\n",
		 enable ? "enabled" : "disabled");
   }
#endif

   if (pI830->MergedFB) {
      pI830->pScrn_2 = xalloc(sizeof(ScrnInfoRec));

      if(!pI830->pScrn_2) {
	 xf86DrvMsg(pScrn->scrnIndex, X_WARNING, "Failed to allocate memory for MergedFB mode. Disabling.\n");
	 pI830->MergedFB = FALSE;
      } else {
         memcpy(pI830->pScrn_2, pScrn, sizeof(ScrnInfoRec));
      }
      if((s = (char *)xf86GetOptValString(pI830->Options, OPTION_SECONDPOSITION))) {
	 int result;
	 int ival;
	 Bool valid = FALSE;
	 char *tempstr = xalloc(strlen(s) + 1);
	 result = sscanf(s, "%s %d", tempstr, &ival);
	 if(result >= 1) {
 	    if(!xf86NameCmp(tempstr,"LeftOf")) {
	       pI830->SecondPosition = PosLeftOf;
	       valid = TRUE;
	       if(result == 2) {
	          if(ival < 0) pI830->FirstYOffs = -ival;
	          else pI830->SecondYOffs = ival;
	       }
	       pI830->SecondIsScrn0 = TRUE;
	    } else if(!xf86NameCmp(tempstr,"RightOf")) {
	       pI830->SecondPosition = PosRightOf;
	       valid = TRUE;
	       if(result == 2) {
	          if(ival < 0) pI830->FirstYOffs = -ival;
	          else pI830->SecondYOffs = ival;
	       }
	       pI830->SecondIsScrn0 = FALSE;
 	    } else if(!xf86NameCmp(tempstr,"Above")) {
	       pI830->SecondPosition = PosAbove;
	       valid = TRUE;
	       if(result == 2) {
	          if(ival < 0) pI830->FirstXOffs = -ival;
	          else pI830->SecondXOffs = ival;
	       }
	       pI830->SecondIsScrn0 = FALSE;
	    } else if(!xf86NameCmp(tempstr,"Below")) {
	       pI830->SecondPosition = PosBelow;
  	       valid = TRUE;
	       if(result == 2) {
	          if(ival < 0) pI830->FirstXOffs = -ival;
	          else pI830->SecondXOffs = ival;
	       }
	       pI830->SecondIsScrn0 = TRUE;
	    }
         }
         if(!valid) {
  	    xf86DrvMsg(pScrn->scrnIndex, X_INFO,
		    "Valid parameters are: \"RightOf\", \"LeftOf\", \"Above\" or \"Below\"\n");
         }
         xfree(tempstr);
      }
      if((s = (char *)xf86GetOptValString(pI830->Options, OPTION_METAMODES))) {
         pI830->MetaModes = xalloc(strlen(s) + 1);
	 if(pI830->MetaModes) 
	    memcpy(pI830->MetaModes, s, strlen(s) + 1);
      }
      if((s = (char *)xf86GetOptValString(pI830->Options, OPTION_SECONDHSYNC))) {
         pI830->SecondHSync = xalloc(strlen(s) + 1);
	 if(pI830->SecondHSync)
	    memcpy(pI830->SecondHSync, s, strlen(s) + 1);
      }
      if((s = (char *)xf86GetOptValString(pI830->Options, OPTION_SECONDVREFRESH))) {
	 pI830->SecondVRefresh = xalloc(strlen(s) + 1);
	 if(pI830->SecondVRefresh) 
	    memcpy(pI830->SecondVRefresh, s, strlen(s) + 1);
      }
   }


   /*
    * If the driver can do gamma correction, it should call xf86SetGamma() here.
    */

   {
      Gamma zeros = { 0.0, 0.0, 0.0 };

      if (!xf86SetGamma(pScrn, zeros)) {
         PreInitCleanup(pScrn);
	 return FALSE;
      }
   }

   GetBIOSVersion(pScrn, &ver);

   v[0] = (ver & 0xff000000) >> 24;
   v[1] = (ver & 0x00ff0000) >> 16;
   v[2] = (ver & 0x0000ff00) >> 8;
   v[3] = (ver & 0x000000ff) >> 0;
   v[4] = 0;
   
   pI830->bios_version = atoi(v);

   xf86DrvMsg(pScrn->scrnIndex, X_INFO, "BIOS Build: %d\n",pI830->bios_version);

   if (IS_I9XX(pI830))
      pI830->newPipeSwitch = TRUE;
   else
   if (pI830->availablePipes == 2 && pI830->bios_version >= 3062) {
      /* BIOS build 3062 changed the pipe switching functionality */
      pI830->newPipeSwitch = TRUE;
      xf86DrvMsg(pScrn->scrnIndex, X_INFO, "Using new Pipe switch code\n");
   } else
      pI830->newPipeSwitch = FALSE;

   pI830->devicePresence = FALSE;
   from = X_DEFAULT;
   if (xf86ReturnOptValBool(pI830->Options, OPTION_DEVICE_PRESENCE, FALSE)) {
      pI830->devicePresence = TRUE;
      from = X_CONFIG;
   }
   xf86DrvMsg(pScrn->scrnIndex, from, "Device Presence: %s.\n",
	      pI830->devicePresence ? "enabled" : "disabled");

   /* This performs an active detect of the currently attached monitors
    * or, at least it's meant to..... alas it doesn't seem to always work.
    */
   if (pI830->devicePresence) {
      int req, att, enc;
      GetDevicePresence(pScrn, &req, &att, &enc);
      for (i = 0; i < NumDisplayTypes; i++) {
         xf86DrvMsg(pScrn->scrnIndex, X_INFO,
	    "Display Presence: %s: attached: %s, encoder: %s\n",
	    displayDevices[i],
	    BOOLTOSTRING(((1<<i) & att)>>i),
	    BOOLTOSTRING(((1<<i) & enc)>>i));
      }
   }

   /* Save old configuration of detected devices */
   pI830->savedDevices = GetDisplayDevices(pScrn);

   if (I830IsPrimary(pScrn)) {
      pI830->pipe = pI830->origPipe = GetBIOSPipe(pScrn);

      /* Override */
      if (pI830->fixedPipe != -1) {
         if (xf86IsEntityShared(pScrn->entityList[0]) || pI830->Clone || 
	     pI830->MergedFB) {
            pI830->pipe = pI830->fixedPipe; 
            xf86DrvMsg(pScrn->scrnIndex, X_INFO,
	        "Fixed Pipe setting primary to pipe %s.\n", 
                	pI830->fixedPipe ? "B" : "A");
         }
      }
      
      /* If the monitors aren't setup, read from the current config */
      if (pI830->MonType1 == PIPE_NONE && pI830->MonType2 == PIPE_NONE) {
         pI830->MonType1 = pI830->savedDevices & 0xff;
         pI830->MonType2 = (pI830->savedDevices & 0xff00) >> 8;
      } else {
         /* Here, we've switched pipes from our primary */
         if (pI830->MonType1 == PIPE_NONE && pI830->pipe == 0)
            pI830->pipe = 1;
         if (pI830->MonType2 == PIPE_NONE && pI830->pipe == 1)
            pI830->pipe = 0;
      }
   
      pI830->operatingDevices = (pI830->MonType2 << 8) | pI830->MonType1;

      if (!xf86IsEntityShared(pScrn->entityList[0]) && !pI830->Clone &&
	  !pI830->MergedFB) {
	  /* If we're not dual head, clone or mergedfb, turn off the
           * second head if monitorlayout is also specified. 
	   */

         if (pI830->pipe == 0)
            pI830->operatingDevices = pI830->MonType1;
         else
            pI830->operatingDevices = pI830->MonType2 << 8;
      }

      if (pI830->pipe != pI830->origPipe)
         xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
	     "Primary Pipe has been switched from original pipe (%s to %s)\n",
             pI830->origPipe ? "B" : "A", pI830->pipe ? "B" : "A");
   } else {
      I830Ptr pI8301 = I830PTR(pI830->entityPrivate->pScrn_1);
      pI830->operatingDevices = pI8301->operatingDevices;
      pI830->pipe = !pI8301->pipe;
      pI830->MonType1 = pI8301->MonType1;
      pI830->MonType2 = pI8301->MonType2;
   }

   /* Buggy BIOS 3066 is known to cause this, so turn this off */
   if (pI830->bios_version == 3066) {
      pI830->displayInfo = FALSE;
      xf86DrvMsg(pScrn->scrnIndex, X_INFO, "Detected Broken Video BIOS, turning off displayInfo.\n");
   } else
      pI830->displayInfo = TRUE;
   from = X_DEFAULT;
   if (!xf86ReturnOptValBool(pI830->Options, OPTION_DISPLAY_INFO, TRUE)) {
      pI830->displayInfo = FALSE;
      from = X_CONFIG;
   }
   if (xf86ReturnOptValBool(pI830->Options, OPTION_DISPLAY_INFO, FALSE)) {
      pI830->displayInfo = TRUE;
      from = X_CONFIG;
   }
   xf86DrvMsg(pScrn->scrnIndex, from, "Display Info: %s.\n",
	      pI830->displayInfo ? "enabled" : "disabled");

   if (!I830DetectDisplayDevice(pScrn)) {
      xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
		 "Couldn't detect display devices.\n");
      PreInitCleanup(pScrn);
      return FALSE;
   }

   if (I830IsPrimary(pScrn)) {
      if (!SetDisplayDevices(pScrn, pI830->operatingDevices)) {
         xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
 		 "Failed to switch to monitor configuration (0x%x)\n",
                 pI830->operatingDevices);
         xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
		 "Please check the devices specified in your MonitorLayout\n");
         xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
		 "is configured correctly.\n");
         PreInitCleanup(pScrn);
         return FALSE;
      }
   }

   PrintDisplayDeviceInfo(pScrn);

   if (xf86IsEntityShared(pScrn->entityList[0])) {
      if (!I830IsPrimary(pScrn)) {
	 /* This could be made to work with a little more fiddling */
	 pI830->directRenderingDisabled = TRUE;

         xf86DrvMsg(pScrn->scrnIndex, from, "Secondary head is using Pipe %s\n",
		pI830->pipe ? "B" : "A");
      } else {
         xf86DrvMsg(pScrn->scrnIndex, from, "Primary head is using Pipe %s\n",
		pI830->pipe ? "B" : "A");
      }
   } else {
      xf86DrvMsg(pScrn->scrnIndex, from, "Display is using Pipe %s\n",
		pI830->pipe ? "B" : "A");
   }

   /* Alloc our pointers for the primary head */
   if (I830IsPrimary(pScrn)) {
      pI830->LpRing = xalloc(sizeof(I830RingBuffer));
      pI830->CursorMem = xalloc(sizeof(I830MemRange));
      pI830->CursorMemARGB = xalloc(sizeof(I830MemRange));
      pI830->OverlayMem = xalloc(sizeof(I830MemRange));
      pI830->overlayOn = xalloc(sizeof(Bool));
      pI830->used3D = xalloc(sizeof(int));
      if (!pI830->LpRing || !pI830->CursorMem || !pI830->CursorMemARGB ||
          !pI830->OverlayMem || !pI830->overlayOn || !pI830->used3D) {
         xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
		 "Could not allocate primary data structures.\n");
         PreInitCleanup(pScrn);
         return FALSE;
      }
      *pI830->overlayOn = FALSE;
      if (pI830->entityPrivate)
         pI830->entityPrivate->XvInUse = -1;
   }

   /* Check if the HW cursor needs physical address. */
   if (IS_MOBILE(pI830) || IS_I9XX(pI830))
      pI830->CursorNeedsPhysical = TRUE;
   else
      pI830->CursorNeedsPhysical = FALSE;

   if (IS_I96X(pI830))
      pI830->CursorNeedsPhysical = FALSE;

   /* Force ring buffer to be in low memory for all chipsets */
   pI830->NeedRingBufferLow = TRUE;

   /*
    * XXX If we knew the pre-initialised GTT format for certain, we could
    * probably figure out the physical address even in the StolenOnly case.
    */
   if (!I830IsPrimary(pScrn)) {
        I830Ptr pI8301 = I830PTR(pI830->entityPrivate->pScrn_1);
	if (!pI8301->SWCursor) {
          xf86DrvMsg(pScrn->scrnIndex, X_PROBED,
		 "Using HW Cursor because it's enabled on primary head.\n");
          pI830->SWCursor = FALSE;
        }
   } else 
   if (pI830->StolenOnly && pI830->CursorNeedsPhysical && !pI830->SWCursor) {
      xf86DrvMsg(pScrn->scrnIndex, X_PROBED,
		 "HW Cursor disabled because it needs agpgart memory.\n");
      pI830->SWCursor = TRUE;
   }

   /*
    * Reduce the maximum videoram available for video modes by the ring buffer,
    * minimum scratch space and HW cursor amounts.
    */
   if (!pI830->SWCursor) {
      pScrn->videoRam -= (HWCURSOR_SIZE / 1024);
      pScrn->videoRam -= (HWCURSOR_SIZE_ARGB / 1024);
   }
   if (!pI830->XvDisabled)
      pScrn->videoRam -= (OVERLAY_SIZE / 1024);
   if (!pI830->noAccel) {
      pScrn->videoRam -= (PRIMARY_RINGBUFFER_SIZE / 1024);
      pScrn->videoRam -= (MIN_SCRATCH_BUFFER_SIZE / 1024);
   }

   xf86DrvMsg(pScrn->scrnIndex, X_PROBED,
	      "Maximum frambuffer space: %d kByte\n", pScrn->videoRam);

   SetPipeAccess(pScrn);

   /* Check we have an LFP connected, before trying to
    * read PanelID information. */
   if ( (pI830->pipe == 1 && pI830->operatingDevices & (PIPE_LFP << 8)) ||
        (pI830->pipe == 0 && pI830->operatingDevices & PIPE_LFP) )
   	vbeDoPanelID(pI830->pVbe);

   pDDCModule = xf86LoadSubModule(pScrn, "ddc");

   monitor = vbeDoEDID(pI830->pVbe, pDDCModule);

   if ((pScrn->monitor->DDC = monitor) != NULL) {
      xf86PrintEDID(monitor);
      xf86SetDDCproperties(pScrn, monitor);
   }

   if(pI830->MergedFB) {
      pI830->pScrn_2->monitor = xalloc(sizeof(MonRec));
      if(pI830->pScrn_2->monitor) {
	 DisplayModePtr tempm = NULL, currentm = NULL, newm = NULL;
	 memcpy(pI830->pScrn_2->monitor, pScrn->monitor, sizeof(MonRec));
	 pI830->pScrn_2->monitor->DDC = NULL;
	 pI830->pScrn_2->monitor->Modes = NULL;
	 pI830->pScrn_2->monitor->id = (char *)SecondMonitorName;
	 tempm = pScrn->monitor->Modes;
	 while(tempm) {
	    if(!(newm = xalloc(sizeof(DisplayModeRec)))) break;
	    memcpy(newm, tempm, sizeof(DisplayModeRec));
	    if(!(newm->name = xalloc(strlen(tempm->name) + 1))) {
	       xfree(newm);
	       break;
	    }
	    strcpy(newm->name, tempm->name);
	    if(!pI830->pScrn_2->monitor->Modes) 
	       pI830->pScrn_2->monitor->Modes = newm;
	    if(currentm) {
	       currentm->next = newm;
	       newm->prev = currentm;
	    }
	    currentm = newm;
	    tempm = tempm->next;
	 }
	 if(pI830->SecondHSync) {
	    pI830->pScrn_2->monitor->nHsync =
	    	I830StrToRanges(pI830->pScrn_2->monitor->hsync, pI830->SecondHSync, MAX_HSYNC);
	 }
	 if(pI830->SecondVRefresh) {
	    pI830->pScrn_2->monitor->nVrefresh =
		I830StrToRanges(pI830->pScrn_2->monitor->vrefresh, pI830->SecondVRefresh, MAX_VREFRESH);
	 }
         SetBIOSPipe(pScrn, !pI830->pipe);
         pI830->pVbe->ddc = DDC_UNCHECKED;
	 xf86DrvMsg(pScrn->scrnIndex, X_INFO,
		"Probing DDC data for second head\n");
	 if((monitor = vbeDoEDID(pI830->pVbe, pDDCModule))) {
	    xf86PrintEDID(monitor);
	    xf86SetDDCproperties(pI830->pScrn_2, monitor);
	    pI830->pScrn_2->monitor->DDC = monitor;
	    /* use DDC data if no ranges in config file */
	    if(!pI830->SecondHSync) {
	       pI830->pScrn_2->monitor->nHsync = 0;
	    }
	    if(!pI830->SecondVRefresh) {
	       pI830->pScrn_2->monitor->nVrefresh = 0;
	    }
	 }
	 SetPipeAccess(pScrn);
      } else {
         xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
	      "Failed to allocate memory for second monitor.\n");
	 if(pI830->pScrn_2) 
            xfree(pI830->pScrn_2);
	 pI830->pScrn_2 = NULL;
	 pI830->MergedFB = FALSE;
      }
   }

   xf86UnloadSubModule(pDDCModule);

   /* XXX Move this to a header. */
#define VIDEO_BIOS_SCRATCH 0x18

#if 1
   /*
    * XXX This should be in ScreenInit/EnterVT.  PreInit should not leave the
    * state changed.
    */
   /* Enable hot keys by writing the proper value to GR18 */
   {
      CARD8 gr18;

      gr18 = pI830->readControl(pI830, GRX, VIDEO_BIOS_SCRATCH);
      gr18 &= ~0x80;			/*
					 * Clear Hot key bit so that Video
					 * BIOS performs the hot key
					 * servicing
					 */
      pI830->writeControl(pI830, GRX, VIDEO_BIOS_SCRATCH, gr18);
   }
#endif

   pI830->useExtendedRefresh = FALSE;

   if (xf86IsEntityShared(pScrn->entityList[0]) || pI830->Clone || 
       pI830->MergedFB) {
      int pipe =
	  (pI830->operatingDevices >> PIPE_SHIFT(pI830->pipe)) & PIPE_ACTIVE_MASK;
      if (pipe & ~PIPE_CRT_ACTIVE) {
	 xf86DrvMsg(pScrn->scrnIndex, X_PROBED,
		    "A non-CRT device is attached to pipe %c.\n"
		    "\tNo refresh rate overrides will be attempted.\n",
		    PIPE_NAME(pI830->pipe));
	 pI830->vesa->useDefaultRefresh = TRUE;
      }
      /*
       * Some desktop platforms might not have 0x5f05, so useExtendedRefresh
       * would need to be set to FALSE for those cases.
       */
      if (!pI830->vesa->useDefaultRefresh) 
	 pI830->useExtendedRefresh = TRUE;
   } else {
      for (i = 0; i < pI830->availablePipes; i++) {
         int pipe =
	  (pI830->operatingDevices >> PIPE_SHIFT(i)) & PIPE_ACTIVE_MASK;
         if (pipe & ~PIPE_CRT_ACTIVE) {
	    xf86DrvMsg(pScrn->scrnIndex, X_PROBED,
		    "A non-CRT device is attached to pipe %c.\n"
		    "\tNo refresh rate overrides will be attempted.\n",
		    PIPE_NAME(i));
	    pI830->vesa->useDefaultRefresh = TRUE;
         }
         /*
          * Some desktop platforms might not have 0x5f05, so useExtendedRefresh
          * would need to be set to FALSE for those cases.
          */
         if (!pI830->vesa->useDefaultRefresh) 
	    pI830->useExtendedRefresh = TRUE;
      }
   }

   if (pI830->useExtendedRefresh && !pI830->vesa->useDefaultRefresh) {
      xf86DrvMsg(pScrn->scrnIndex, X_INFO,
		 "Will use BIOS call 0x5f05 to set refresh rates for CRTs.\n");
   }

   /*
    * Limit videoram available for mode selection to what the video
    * BIOS can see.
    */
   if (pScrn->videoRam > (pI830->vbeInfo->TotalMemory * 64))
      memsize = pI830->vbeInfo->TotalMemory * 64;
   else
      memsize = pScrn->videoRam;
   xf86DrvMsg(pScrn->scrnIndex, X_PROBED,
	      "Maximum space available for video modes: %d kByte\n", memsize);

   /* By now, we should have had some monitor settings, but if not, we
    * need to setup some defaults. These are used in common/xf86Modes.c
    * so we'll use them here for GetModePool, and that's all. 
    * We unset them after the call, so we can report 'defaults' as being
    * used through the common layer.
    */
#define DEFAULT_HSYNC_LO 28
#define DEFAULT_HSYNC_HI 33
#define DEFAULT_VREFRESH_LO 43
#define DEFAULT_VREFRESH_HI 72

   if (pScrn->monitor->nHsync == 0) {
      pScrn->monitor->hsync[0].lo = DEFAULT_HSYNC_LO;
      pScrn->monitor->hsync[0].hi = DEFAULT_HSYNC_HI;
      pScrn->monitor->nHsync = 1;
      defmon |= 1;
   }

   if (pScrn->monitor->nVrefresh == 0) {
      pScrn->monitor->vrefresh[0].lo = DEFAULT_VREFRESH_LO;
      pScrn->monitor->vrefresh[0].hi = DEFAULT_VREFRESH_HI;
      pScrn->monitor->nVrefresh = 1;
      defmon |= 2;
   }

   DDCclock = I830UseDDC(pScrn);

   if (pI830->MergedFB)
      DDCclock2 = I830UseDDC(pI830->pScrn_2);

   /*
    * Note: VBE modes (> 0x7f) won't work with Intel's extended BIOS
    * functions. 
    */
   pScrn->modePool = I830GetModePool(pScrn, pI830->pVbe, pI830->vbeInfo);

   if (!pScrn->modePool) {
      xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
		 "No Video BIOS modes for chosen depth.\n");
      PreInitCleanup(pScrn);
      return FALSE;
   }

   if (pI830->MergedFB) {
      SetBIOSPipe(pScrn, !pI830->pipe);
      xf86DrvMsg(pScrn->scrnIndex, X_INFO,
		 "Retrieving mode pool for second head.\n");
      pI830->pScrn_2->modePool = I830GetModePool(pI830->pScrn_2, pI830->pVbe, pI830->vbeInfo);

      if (!pI830->pScrn_2->modePool) {
         xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
		 "No Video BIOS modes for chosen depth.\n");
         PreInitCleanup(pScrn);
         return FALSE;
      }
      SetPipeAccess(pScrn);
   }

   /* This may look a little weird, but to notify that we're using the
    * default hsync/vrefresh we need to unset what we just set .....
    */
   if (defmon & 1) {
      pScrn->monitor->hsync[0].lo = 0;
      pScrn->monitor->hsync[0].hi = 0;
      pScrn->monitor->nHsync = 0;
   }

   if (defmon & 2) {
      pScrn->monitor->vrefresh[0].lo = 0;
      pScrn->monitor->vrefresh[0].hi = 0;
      pScrn->monitor->nVrefresh = 0;
   }

   SetPipeAccess(pScrn);
   VBESetModeNames(pScrn->modePool);
   if (pI830->MergedFB)
      VBESetModeNames(pI830->pScrn_2->modePool);


   /*
    * XXX DDC information: There's code in xf86ValidateModes
    * (VBEValidateModes) to set monitor defaults based on DDC information
    * where available.  If we need something that does better than this,
    * there's code in vesa/vesa.c.
    */

   /* XXX Need to get relevant modes and virtual parameters. */
   /* Do the mode validation without regard to special scanline pitches. */
   SetPipeAccess(pScrn);
   n = VBEValidateModes(pScrn, NULL, pScrn->display->modes, NULL,
			NULL, 0, MAX_DISPLAY_PITCH, 1,
			0, MAX_DISPLAY_HEIGHT,
			pScrn->display->virtualX,
			pScrn->display->virtualY,
			memsize, LOOKUP_BEST_REFRESH);
   if (n <= 0) {
      xf86DrvMsg(pScrn->scrnIndex, X_ERROR, "No valid modes.\n");
      PreInitCleanup(pScrn);
      return FALSE;
   }

   if (pI830->MergedFB) {
      n = VBEValidateModes(pI830->pScrn_2, NULL, pI830->pScrn_2->display->modes, NULL,
			NULL, 0, MAX_DISPLAY_PITCH, 1,
			0, MAX_DISPLAY_HEIGHT,
			pScrn->display->virtualX,
			pScrn->display->virtualY,
			memsize, LOOKUP_BEST_REFRESH);
      if (n <= 0) {
         xf86DrvMsg(pScrn->scrnIndex, X_ERROR, "No valid modes.\n");
         PreInitCleanup(pScrn);
         return FALSE;
      }
   }

   /* Only use this if we've got DDC available */
   if (DDCclock > 0) {
      p = pScrn->modes;
      if (p == NULL)
         return FALSE;
      do {
         int Clock = 100000000; /* incredible value */

	 if (p->status == MODE_OK) {
            for (pMon = pScrn->monitor->Modes; pMon != NULL; pMon = pMon->next) {
               if ((pMon->HDisplay != p->HDisplay) ||
                   (pMon->VDisplay != p->VDisplay) ||
                   (pMon->Flags & (V_INTERLACE | V_DBLSCAN | V_CLKDIV2)))
                   continue;

               /* Find lowest supported Clock for this resolution */
               if (Clock > pMon->Clock)
                  Clock = pMon->Clock;
            } 

            if (Clock != 100000000 && DDCclock < 2550 && Clock / 1000.0 > DDCclock) {
               ErrorF("(%s,%s) mode clock %gMHz exceeds DDC maximum %dMHz\n",
		   p->name, pScrn->monitor->id,
		   Clock/1000.0, DDCclock);
               p->status = MODE_BAD;
            } 
 	 }
         p = p->next;
      } while (p != NULL && p != pScrn->modes);
   }

   /* Only use this if we've got DDC available */
   if (DDCclock2 > 0) {
      p = pI830->pScrn_2->modes;
      if (p == NULL)
         return FALSE;
      do {
         int Clock = 100000000; /* incredible value */

	 if (p->status == MODE_OK) {
            for (pMon = pI830->pScrn_2->monitor->Modes; pMon != NULL; pMon = pMon->next) {
               if ((pMon->HDisplay != p->HDisplay) ||
                   (pMon->VDisplay != p->VDisplay) ||
                   (pMon->Flags & (V_INTERLACE | V_DBLSCAN | V_CLKDIV2)))
                   continue;

               /* Find lowest supported Clock for this resolution */
               if (Clock > pMon->Clock)
                  Clock = pMon->Clock;
            } 

            if (Clock != 100000000 && DDCclock2 < 2550 && Clock / 1000.0 > DDCclock2) {
               ErrorF("(%s,%s) mode clock %gMHz exceeds DDC maximum %dMHz\n",
		   p->name, pI830->pScrn_2->monitor->id,
		   Clock/1000.0, DDCclock2);
               p->status = MODE_BAD;
            } 
 	 }
         p = p->next;
      } while (p != NULL && p != pI830->pScrn_2->modes);
   }

   xf86PruneDriverModes(pScrn);

   if (pScrn->modes == NULL) {
      xf86DrvMsg(pScrn->scrnIndex, X_ERROR, "No modes.\n");
      PreInitCleanup(pScrn);
      return FALSE;
   }

   if (pI830->MergedFB) {
      DisplayModePtr old_modes, cur_mode;

      xf86PruneDriverModes(pI830->pScrn_2);

      if (pI830->pScrn_2->modes == NULL) {
         xf86DrvMsg(pScrn->scrnIndex, X_ERROR, "No modes.\n");
         PreInitCleanup(pScrn);
         return FALSE;
      }

      old_modes = pScrn->modes;
      cur_mode = pScrn->currentMode;

      xf86DrvMsg(pScrn->scrnIndex, X_INFO, "MergedFB: Generating mode list\n");

      pScrn->modes = I830GenerateModeList(pScrn, pI830->MetaModes,
					  old_modes, pI830->pScrn_2->modes,
					  pI830->SecondPosition);

      if(!pScrn->modes) {
          xf86DrvMsg(pScrn->scrnIndex, X_ERROR, "No modes. Disabling MergedFB.\n");
	  pScrn->modes = old_modes;
	  pScrn->currentMode = cur_mode;
	  pI830->MergedFB = FALSE;
      }
   }

   /* Now we check the VESA BIOS's displayWidth and reset if necessary */
   p = pScrn->modes;
   do {
      I830ModePrivatePtr mp = (I830ModePrivatePtr) p->Private;
      VbeModeInfoBlock *modeInfo;

      /* Get BytesPerScanline so we can reset displayWidth */
      if ((modeInfo = VBEGetModeInfo(pI830->pVbe, mp->vbeData.mode))) {
         if (pScrn->displayWidth < modeInfo->BytesPerScanline / pI830->cpp) {
            xf86DrvMsg(pScrn->scrnIndex, X_INFO, "Correcting stride (%d -> %d)\n", pScrn->displayWidth, modeInfo->BytesPerScanline);
	    pScrn->displayWidth = modeInfo->BytesPerScanline / pI830->cpp;
	 }
      } 
      p = p->next;
   } while (p != NULL && p != pScrn->modes);

   pScrn->currentMode = pScrn->modes;

   if (pI830->MergedFB) {
      /* If no virtual dimension was given by the user,
       * calculate a sane one now. Adapts pScrn->virtualX,
       * pScrn->virtualY and pScrn->displayWidth.
       */
      I830RecalcDefaultVirtualSize(pScrn);

      pScrn->modes = pScrn->modes->next;  /* We get the last from GenerateModeList(), skip to first */
      pScrn->currentMode = pScrn->modes;
      pI830->currentMode = pScrn->currentMode;
   }

#ifndef USE_PITCHES
#define USE_PITCHES 1
#endif
   pI830->disableTiling = FALSE;

   /*
    * If DRI is potentially usable, check if there is enough memory available
    * for it, and if there's also enough to allow tiling to be enabled.
    */

#if defined(XF86DRI)
   if (!I830CheckDRIAvailable(pScrn)) {
      pI830->directRenderingDisabled = TRUE;
      pI830->mmSize = 0;
   } else if (pScrn->videoRam > pI830->FbMapSize / 1024 - pI830->mmSize) {
      I830ReduceMMSize(pScrn, pI830->FbMapSize - KB(pScrn->videoRam), 
		       "to make room for video memory");
   }

   if (I830IsPrimary(pScrn) && !pI830->directRenderingDisabled) {
      int savedDisplayWidth = pScrn->displayWidth;
      int memNeeded = 0;
      /* Good pitches to allow tiling.  Don't care about pitches < 1024. */
      static const int pitches[] = {
/*
	 128 * 2,
	 128 * 4,
*/
	 128 * 8,
	 128 * 16,
	 128 * 32,
	 128 * 64,
	 0
      };

#ifdef I830_XV
      /*
       * Set this so that the overlay allocation is factored in when
       * appropriate.
       */
      pI830->XvEnabled = !pI830->XvDisabled;
#endif

      for (i = 0; pitches[i] != 0; i++) {
#if USE_PITCHES
	 if (pitches[i] >= pScrn->displayWidth) {
	    pScrn->displayWidth = pitches[i];
	    break;
	 }
#else
	 if (pitches[i] == pScrn->displayWidth)
	    break;
#endif
      }

      /*
       * If the displayWidth is a tilable pitch, test if there's enough
       * memory available to enable tiling.
       */
      savedMMSize = pI830->mmSize;
      if (pScrn->displayWidth == pitches[i]) {
      retry_dryrun:
	 I830ResetAllocations(pScrn, 0);
	 if (I830Allocate2DMemory(pScrn, ALLOCATE_DRY_RUN | ALLOC_INITIAL) &&
	     I830Allocate3DMemory(pScrn, ALLOCATE_DRY_RUN)) {
	    memNeeded = I830GetExcessMemoryAllocations(pScrn);
	    if (memNeeded > 0 || pI830->MemoryAperture.Size < 0) {
	       if (memNeeded > 0) {
		  xf86DrvMsg(pScrn->scrnIndex, X_INFO,
			     "%d kBytes additional video memory is "
			     "required to\n\tenable tiling mode for DRI.\n",
			     (memNeeded + 1023) / 1024);
	       }
	       if (pI830->MemoryAperture.Size < 0) {		  
		  if (KB(pI830->mmSize) > I830_MM_MINPAGES * GTT_PAGE_SIZE) {
		     I830ReduceMMSize(pScrn, I830_MM_MINPAGES * GTT_PAGE_SIZE,
				      "to make room in AGP aperture for tiling.");
		     goto retry_dryrun;
		  }

		  xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
			     "Allocation with DRI tiling enabled would "
			     "exceed the\n"
			     "\tmemory aperture size (%ld kB) by %ld kB.\n"
			     "\tReduce VideoRam amount to avoid this!\n",
			     pI830->FbMapSize / 1024,
			     -pI830->MemoryAperture.Size / 1024);
	       }
	       pScrn->displayWidth = savedDisplayWidth;
	       pI830->allowPageFlip = FALSE;
	    } else if (pScrn->displayWidth != savedDisplayWidth) {
	       xf86DrvMsg(pScrn->scrnIndex, X_INFO,
			  "Increasing the scanline pitch to allow tiling mode "
			  "(%d -> %d).\n",
			  savedDisplayWidth, pScrn->displayWidth);
	    }
	 } else {
	    memNeeded = 0;
	    xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
		       "Unexpected dry run allocation failure (1).\n");
	 }
      }
      if (memNeeded > 0 || pI830->MemoryAperture.Size < 0) {
	 /*
	  * Tiling can't be enabled.  Check if there's enough memory for DRI
	  * without tiling.
	  */
	 pI830->mmSize = savedMMSize;
	 pI830->disableTiling = TRUE;
      retry_dryrun2:
	 I830ResetAllocations(pScrn, 0);
	 if (I830Allocate2DMemory(pScrn, ALLOCATE_DRY_RUN | ALLOC_INITIAL) &&
	     I830Allocate3DMemory(pScrn, ALLOCATE_DRY_RUN | ALLOC_NO_TILING)) {
	    memNeeded = I830GetExcessMemoryAllocations(pScrn);
	    if (memNeeded > 0 || pI830->MemoryAperture.Size < 0) {
	       if (memNeeded > 0) {
		  xf86DrvMsg(pScrn->scrnIndex, X_INFO,
			     "%d kBytes additional video memory is required "
			     "to enable DRI.\n",
			     (memNeeded + 1023) / 1024);
	       }
	       if (pI830->MemoryAperture.Size < 0) {
		  if (KB(pI830->mmSize) > I830_MM_MINPAGES * GTT_PAGE_SIZE) {
		     I830ReduceMMSize(pScrn, I830_MM_MINPAGES * GTT_PAGE_SIZE,
				      "to save AGP aperture space for video memory.");
		     goto retry_dryrun2;
		  }
		  xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
			     "Allocation with DRI enabled would "
			     "exceed the\n"
			     "\tmemory aperture size (%ld kB) by %ld kB.\n"
			     "\tReduce VideoRam amount to avoid this!\n",
			     pI830->FbMapSize / 1024,
			     -pI830->MemoryAperture.Size / 1024);
	       }
	       pI830->mmSize = 0;
	       pI830->directRenderingDisabled = TRUE;
	       xf86DrvMsg(pScrn->scrnIndex, X_INFO, "Disabling DRI.\n");
	    }
	 } else {
	    xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
		       "Unexpected dry run allocation failure (2).\n");
	 }
      }
   } else
#endif
      pI830->disableTiling = TRUE; /* no DRI - so disableTiling */

   if (pScrn->displayWidth >= 4096) {
      xf86DrvMsg(pScrn->scrnIndex, X_ERROR, "Cannot support > 1024x768 in leftof/rightof configurations. disabling DRI.\n");
      pI830->directRenderingDisabled = TRUE;
   }

   if (pScrn->virtualY > 2048) {
      xf86DrvMsg(pScrn->scrnIndex, X_ERROR, "Cannot support > 2048 vertical lines. disabling acceleration.\n");
      pI830->noAccel = TRUE;
   }

   pI830->displayWidth = pScrn->displayWidth;

   SetPipeAccess(pScrn);
   I830PrintModes(pScrn);

   if (!pI830->vesa->useDefaultRefresh) {
      /*
       * This sets the parameters for the VBE modes according to the best
       * usable parameters from the Monitor sections modes (usually the
       * default VESA modes), allowing for better than default refresh rates.
       * This only works for VBE 3.0 and later.  Also, we only do this
       * if there are no non-CRT devices attached.
       */
      SetPipeAccess(pScrn);
      I830SetModeParameters(pScrn, pI830->pVbe);
   }

   /* PreInit shouldn't leave any state changes, so restore this. */
   RestoreBIOSMemSize(pScrn);

   /* Don't need MMIO access anymore. */
   if (pI830->swfSaved) {
      OUTREG(SWF0, pI830->saveSWF0);
      OUTREG(SWF4, pI830->saveSWF4);
   }

   /* Set display resolution */
   xf86SetDpi(pScrn, 0, 0);

   /* Load the required sub modules */
   if (!xf86LoadSubModule(pScrn, "fb")) {
      PreInitCleanup(pScrn);
      return FALSE;
   }

   xf86LoaderReqSymLists(I810fbSymbols, NULL);

   if (!pI830->noAccel) {
      if (!xf86LoadSubModule(pScrn, "xaa")) {
	 PreInitCleanup(pScrn);
	 return FALSE;
      }
      xf86LoaderReqSymLists(I810xaaSymbols, NULL);
   }

   if (!pI830->SWCursor) {
      if (!xf86LoadSubModule(pScrn, "ramdac")) {
	 PreInitCleanup(pScrn);
	 return FALSE;
      }
      xf86LoaderReqSymLists(I810ramdacSymbols, NULL);
   }

   I830UnmapMMIO(pScrn);

   /*  We won't be using the VGA access after the probe. */
   I830SetMMIOAccess(pI830);
   xf86SetOperatingState(resVgaIo, pI830->pEnt->index, ResUnusedOpr);
   xf86SetOperatingState(resVgaMem, pI830->pEnt->index, ResDisableOpr);

#if 0
   if (I830IsPrimary(pScrn)) {
      VBEFreeVBEInfo(pI830->vbeInfo);
      vbeFree(pI830->pVbe);
   }
   pI830->vbeInfo = NULL;
   pI830->pVbe = NULL;
#endif

   /* Use the VBE mode restore workaround by default. */
   pI830->vbeRestoreWorkaround = TRUE;
   from = X_DEFAULT;
   if (xf86ReturnOptValBool(pI830->Options, OPTION_VBE_RESTORE, FALSE)) {
      pI830->vbeRestoreWorkaround = FALSE;
      from = X_CONFIG;
   }
   xf86DrvMsg(pScrn->scrnIndex, from, "VBE Restore workaround: %s.\n",
	      pI830->vbeRestoreWorkaround ? "enabled" : "disabled");
      
#if defined(XF86DRI)
   /* Load the dri module if requested. */
   if (xf86ReturnOptValBool(pI830->Options, OPTION_DRI, FALSE) &&
       !pI830->directRenderingDisabled) {
      if (xf86LoadSubModule(pScrn, "dri")) {
	 xf86LoaderReqSymLists(I810driSymbols, I810drmSymbols, NULL);
a1122 1
#endif
d1124 6
a1129 14
   /* rotation requires the newer libshadow */
   if (I830IsPrimary(pScrn)) {
      int errmaj, errmin;
      pI830->shadowReq.majorversion = 1;
      pI830->shadowReq.minorversion = 1;

      if (!LoadSubModule(pScrn->module, "shadow", NULL, NULL, NULL,
			       &pI830->shadowReq, &errmaj, &errmin)) {
         pI830->shadowReq.minorversion = 0;
         if (!LoadSubModule(pScrn->module, "shadow", NULL, NULL, NULL,
			       &pI830->shadowReq, &errmaj, &errmin)) {
            LoaderErrorMsg(NULL, "shadow", errmaj, errmin);
	    return FALSE;
         }
a1130 5
   } else {
      I830Ptr pI8301 = I830PTR(pI830->entityPrivate->pScrn_1);
      pI830->shadowReq.majorversion = pI8301->shadowReq.majorversion;
      pI830->shadowReq.minorversion = pI8301->shadowReq.minorversion;
      pI830->shadowReq.patchlevel = pI8301->shadowReq.patchlevel;
a1131 1
   xf86LoaderReqSymLists(I810shadowSymbols, NULL);
d1133 4
a1136 1
   pI830->preinit = FALSE;
d1138 1
a1138 2
   return TRUE;
}
d1140 2
a1141 10
/*
 * As the name says.  Check that the initial state is reasonable.
 * If any unrecoverable problems are found, bail out here.
 */
static Bool
CheckInheritedState(ScrnInfoPtr pScrn)
{
   I830Ptr pI830 = I830PTR(pScrn);
   int errors = 0, fatal = 0;
   unsigned long temp, head, tail;
d1143 11
a1153 27
   if (!I830IsPrimary(pScrn)) return TRUE;

   /* Check first for page table errors */
   temp = INREG(PGE_ERR);
   if (temp != 0) {
      xf86DrvMsg(pScrn->scrnIndex, X_WARNING, "PGTBL_ER is 0x%08lx\n", temp);
      errors++;
   }
   temp = INREG(PGETBL_CTL);
   if (!(temp & 1)) {
      xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
		 "PGTBL_CTL (0x%08lx) indicates GTT is disabled\n", temp);
      errors++;
   }
   temp = INREG(LP_RING + RING_LEN);
   if (temp & 1) {
      xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
		 "PRB0_CTL (0x%08lx) indicates ring buffer enabled\n", temp);
      errors++;
   }
   head = INREG(LP_RING + RING_HEAD);
   tail = INREG(LP_RING + RING_TAIL);
   if ((tail & I830_TAIL_MASK) != (head & I830_HEAD_MASK)) {
      xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
		 "PRB0_HEAD (0x%08lx) and PRB0_TAIL (0x%08lx) indicate "
		 "ring buffer not flushed\n", head, tail);
      errors++;
d1155 1
d1157 4
a1160 8
#if 0
   if (errors) {
      if (IS_I96X(pI830))
         I965PrintErrorState(pScrn);
      else
         I830PrintErrorState(pScrn);
   }
#endif
d1162 2
a1163 2
   if (fatal)
      FatalError("CheckInheritedState: can't recover from the above\n");
d1165 1
a1165 2
   return (errors != 0);
}
d1167 6
a1172 19
/*
 * Reset registers that it doesn't make sense to save/restore to a sane state.
 * This is basically the ring buffer and fence registers.  Restoring these
 * doesn't make sense without restoring GTT mappings.  This is something that
 * whoever gets control next should do.
 */
static void
ResetState(ScrnInfoPtr pScrn, Bool flush)
{
   I830Ptr pI830 = I830PTR(pScrn);
   int i;
   unsigned long temp;

   DPRINTF(PFX, "ResetState: flush is %s\n", BOOLTOSTRING(flush));

   if (!I830IsPrimary(pScrn)) return;

   if (pI830->entityPrivate)
      pI830->entityPrivate->RingRunning = 0;
d1174 2
a1175 6
   /* Reset the fence registers to 0 */
   if (IS_I96X(pI830)) {
      for (i = 0; i < FENCE_NEW_NR; i++) {
	 OUTREG(FENCE_NEW + i * 8, 0);
	 OUTREG(FENCE_NEW + 4 + i * 8, 0);
      }
d1177 1
a1177 2
      for (i = 0; i < FENCE_NR; i++)
         OUTREG(FENCE + i * 4, 0);
d1180 36
a1215 7
   /* Flush the ring buffer (if enabled), then disable it. */
   if (pI830->AccelInfoRec != NULL && flush) {
      temp = INREG(LP_RING + RING_LEN);
      if (temp & 1) {
	 I830RefreshRing(pScrn);
	 I830Sync(pScrn);
	 DO_RING_IDLE();
d1217 50
d1268 2
a1269 8
   OUTREG(LP_RING + RING_LEN, 0);
   OUTREG(LP_RING + RING_HEAD, 0);
   OUTREG(LP_RING + RING_TAIL, 0);
   OUTREG(LP_RING + RING_START, 0);
  
   if (pI830->CursorInfoRec && pI830->CursorInfoRec->HideCursor)
      pI830->CursorInfoRec->HideCursor(pScrn);
}
d1271 11
a1281 19
static void
SetFenceRegs(ScrnInfoPtr pScrn)
{
   I830Ptr pI830 = I830PTR(pScrn);
   int i;

   DPRINTF(PFX, "SetFenceRegs\n");

   if (!I830IsPrimary(pScrn)) return;

   if (IS_I96X(pI830)) {
      for (i = 0; i < FENCE_NEW_NR; i++) {
         OUTREG(FENCE_NEW + i * 8, pI830->ModeReg.Fence[i]);
         OUTREG(FENCE_NEW + 4 + i * 8, pI830->ModeReg.Fence[i+FENCE_NEW_NR]);
         if (I810_DEBUG & DEBUG_VERBOSE_VGA) {
	    ErrorF("Fence Start Register : %x\n", pI830->ModeReg.Fence[i]);
	    ErrorF("Fence End Register : %x\n", pI830->ModeReg.Fence[i+FENCE_NEW_NR]);
         }
      }
d1283 3
a1285 5
      for (i = 0; i < FENCE_NR; i++) {
         OUTREG(FENCE + i * 4, pI830->ModeReg.Fence[i]);
         if (I810_DEBUG & DEBUG_VERBOSE_VGA)
	    ErrorF("Fence Register : %x\n", pI830->ModeReg.Fence[i]);
      }
a1286 1
}
d1288 4
a1291 5
static void
SetRingRegs(ScrnInfoPtr pScrn)
{
   I830Ptr pI830 = I830PTR(pScrn);
   unsigned int itemp;
d1293 2
a1294 1
   DPRINTF(PFX, "SetRingRegs\n");
d1296 4
a1299 17
   if (pI830->noAccel)
      return;

   if (!I830IsPrimary(pScrn)) return;

   if (pI830->entityPrivate)
      pI830->entityPrivate->RingRunning = 1;

   OUTREG(LP_RING + RING_LEN, 0);
   OUTREG(LP_RING + RING_TAIL, 0);
   OUTREG(LP_RING + RING_HEAD, 0);

   if ((long)(pI830->LpRing->mem.Start & I830_RING_START_MASK) !=
       pI830->LpRing->mem.Start) {
      xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
		 "I830SetRingRegs: Ring buffer start (%lx) violates its "
		 "mask (%x)\n", pI830->LpRing->mem.Start, I830_RING_START_MASK);
d1301 4
a1304 10
   /* Don't care about the old value.  Reserved bits must be zero anyway. */
   itemp = pI830->LpRing->mem.Start & I830_RING_START_MASK;
   OUTREG(LP_RING + RING_START, itemp);

   if (((pI830->LpRing->mem.Size - 4096) & I830_RING_NR_PAGES) !=
       pI830->LpRing->mem.Size - 4096) {
      xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
		 "I830SetRingRegs: Ring buffer size - 4096 (%lx) violates its "
		 "mask (%x)\n", pI830->LpRing->mem.Size - 4096,
		 I830_RING_NR_PAGES);
a1305 6
   /* Don't care about the old value.  Reserved bits must be zero anyway. */
   itemp = (pI830->LpRing->mem.Size - 4096) & I830_RING_NR_PAGES;
   itemp |= (RING_NO_REPORT | RING_VALID);
   OUTREG(LP_RING + RING_LEN, itemp);
   I830RefreshRing(pScrn);
}
d1307 10
a1316 45
/*
 * This should be called everytime the X server gains control of the screen,
 * before any video modes are programmed (ScreenInit, EnterVT).
 */
static void
SetHWOperatingState(ScrnInfoPtr pScrn)
{
   I830Ptr pI830 = I830PTR(pScrn);

   DPRINTF(PFX, "SetHWOperatingState\n");

   if (!pI830->noAccel)
      SetRingRegs(pScrn);
   SetFenceRegs(pScrn);
   if (!pI830->SWCursor)
      I830InitHWCursor(pScrn);
}

static Bool
SaveHWState(ScrnInfoPtr pScrn)
{
   I830Ptr pI830 = I830PTR(pScrn);
   vbeInfoPtr pVbe = pI830->pVbe;
   vgaHWPtr hwp = VGAHWPTR(pScrn);
   vgaRegPtr vgaReg = &hwp->SavedReg;
   VbeModeInfoBlock *modeInfo;
   VESAPtr pVesa;

   DPRINTF(PFX, "SaveHWState\n");

   if (I830IsPrimary(pScrn) && pI830->pipe != pI830->origPipe)
      SetBIOSPipe(pScrn, pI830->origPipe);
   else
      SetPipeAccess(pScrn);

   pVesa = pI830->vesa;

   /* Make sure we save at least this information in case of failure. */
   VBEGetVBEMode(pVbe, &pVesa->stateMode);
   pVesa->stateRefresh = GetRefreshRate(pScrn, pVesa->stateMode, NULL);
   modeInfo = VBEGetModeInfo(pVbe, pVesa->stateMode);
   pVesa->savedScanlinePitch = 0;
   if (modeInfo) {
      if (VBE_MODE_GRAPHICS(modeInfo)) {
         VBEGetLogicalScanline(pVbe, &pVesa->savedScanlinePitch, NULL, NULL);
a1317 1
      VBEFreeModeInfo(modeInfo);
d1320 2
a1321 2
   vgaHWUnlock(hwp);
   vgaHWSave(pScrn, vgaReg, VGA_SR_FONTS);
d1323 6
a1328 24
   pVesa = pI830->vesa;

   if (IS_I96X(pI830)) {
      pI830->savedAsurf = INREG(DSPASURF);
      pI830->savedBsurf = INREG(DSPBSURF);
   }

   /*
    * This save/restore method doesn't work for 845G BIOS, or for some
    * other platforms.  Enable it in all cases.
    */
   /*
    * KW: This may have been because of the behaviour I've found on my
    * board: The 'save' command actually modifies the interrupt
    * registers, turning off the irq & breaking the kernel module
    * behaviour.
    */
   if (!pI830->vbeRestoreWorkaround) {
      CARD16 imr = INREG16(IMR);
      CARD16 ier = INREG16(IER);
      CARD16 hwstam = INREG16(HWSTAM);

      if (!VBESaveRestore(pVbe, MODE_SAVE, &pVesa->state, &pVesa->stateSize,
			  &pVesa->statePage)) {
d1330 2
a1331 1
		    "SaveHWState: VBESaveRestore(MODE_SAVE) failed.\n");
a1333 4

      OUTREG16(IMR, imr);
      OUTREG16(IER, ier);
      OUTREG16(HWSTAM, hwstam);
d1336 2
a1337 12
   pVesa->savedPal = VBESetGetPaletteData(pVbe, FALSE, 0, 256,
					     NULL, FALSE, FALSE);
   if (!pVesa->savedPal) {
      xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
		 "SaveHWState: VBESetGetPaletteData(GET) failed.\n");
      return FALSE;
   }

   VBEGetDisplayStart(pVbe, &pVesa->x, &pVesa->y);

   return TRUE;
}
d1339 2
a1340 9
static Bool
RestoreHWState(ScrnInfoPtr pScrn)
{
   I830Ptr pI830 = I830PTR(pScrn);
   vbeInfoPtr pVbe = pI830->pVbe;
   vgaHWPtr hwp = VGAHWPTR(pScrn);
   vgaRegPtr vgaReg = &hwp->SavedReg;
   VESAPtr pVesa;
   Bool restored = FALSE;
d1342 3
a1344 1
   DPRINTF(PFX, "RestoreHWState\n");
d1346 10
a1355 4
   if (I830IsPrimary(pScrn) && pI830->pipe != pI830->origPipe)
      SetBIOSPipe(pScrn, pI830->origPipe);
   else
      SetPipeAccess(pScrn);
d1357 4
a1360 1
   pVesa = pI830->vesa;
d1362 5
a1366 7
   /*
    * Workaround for text mode restoration with some flat panels.
    * Temporarily program a 640x480 mode before switching back to
    * text mode.
    */
   if (pVesa->useDefaultRefresh)
      I830Set640x480(pScrn);
d1368 7
a1374 16
   if (pVesa->state && pVesa->stateSize) {
      CARD16 imr = INREG16(IMR);
      CARD16 ier = INREG16(IER);
      CARD16 hwstam = INREG16(HWSTAM);

      /* Make a copy of the state.  Don't rely on it not being touched. */
      if (!pVesa->pstate) {
	 pVesa->pstate = xalloc(pVesa->stateSize);
	 if (pVesa->pstate)
	    memcpy(pVesa->pstate, pVesa->state, pVesa->stateSize);
      }
      restored = VBESaveRestore(pVbe, MODE_RESTORE, &pVesa->state,
				   &pVesa->stateSize, &pVesa->statePage);
      if (!restored) {
	 xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
		    "RestoreHWState: VBESaveRestore failed.\n");
d1376 11
a1386 16
      /* Copy back */
      if (pVesa->pstate)
	 memcpy(pVesa->state, pVesa->pstate, pVesa->stateSize);

      OUTREG16(IMR, imr);
      OUTREG16(IER, ier);
      OUTREG16(HWSTAM, hwstam);
   }
   /* If that failed, restore the original mode. */
   if (!restored) {
      xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
		 "Setting the original video mode instead of restoring\n\t"
		 "the saved state\n");
      I830VESASetVBEMode(pScrn, pVesa->stateMode, NULL);
      if (!pVesa->useDefaultRefresh && pI830->useExtendedRefresh) {
         SetRefreshRate(pScrn, pVesa->stateMode, pVesa->stateRefresh);
a1388 2
   if (pVesa->savedScanlinePitch)
       VBESetLogicalScanline(pVbe, pVesa->savedScanlinePitch);
d1390 2
a1391 4
   if (pVesa->savedPal)
      VBESetGetPaletteData(pVbe, TRUE, 0, 256, pVesa->savedPal, FALSE, TRUE);

   VBESetDisplayStart(pVbe, pVesa->x, pVesa->y, TRUE);
d1393 3
a1395 3
   if (IS_I96X(pI830)) {
      OUTREG(DSPASURF, pI830->savedAsurf);
      OUTREG(DSPBSURF, pI830->savedBsurf);
d1398 1
a1398 2
   vgaHWRestore(pScrn, vgaReg, VGA_SR_FONTS);
   vgaHWLock(hwp);
d1400 4
a1403 2
   return TRUE;
}
d1405 2
a1406 40
static void I830SetCloneVBERefresh(ScrnInfoPtr pScrn, int mode, VbeCRTCInfoBlock * block, int refresh)
{
   I830Ptr pI830 = I830PTR(pScrn);
   DisplayModePtr p = NULL;
   int RefreshRate;
   int clock;

   /* Search for our mode and get a refresh to match */
   for (p = pScrn->monitor->Modes; p != NULL; p = p->next) {
      if ((p->HDisplay != pI830->CloneHDisplay) ||
          (p->VDisplay != pI830->CloneVDisplay) ||
          (p->Flags & (V_INTERLACE | V_DBLSCAN | V_CLKDIV2)))
         continue;
      RefreshRate = ((double)(p->Clock * 1000) /
                     (double)(p->HTotal * p->VTotal)) * 100;
      /* we could probably do better here that 2Hz boundaries */
      if (RefreshRate > (refresh - 200) && RefreshRate < (refresh + 200)) {
         block->HorizontalTotal = p->HTotal;
         block->HorizontalSyncStart = p->HSyncStart;
         block->HorizontalSyncEnd = p->HSyncEnd;
         block->VerticalTotal = p->VTotal;
         block->VerticalSyncStart = p->VSyncStart;
         block->VerticalSyncEnd = p->VSyncEnd;
         block->Flags = ((p->Flags & V_NHSYNC) ? CRTC_NHSYNC : 0) |
                        ((p->Flags & V_NVSYNC) ? CRTC_NVSYNC : 0);
         block->PixelClock = p->Clock * 1000;
         /* XXX May not have this. */
         clock = VBEGetPixelClock(pI830->pVbe, mode, block->PixelClock);
#ifdef DEBUG
         ErrorF("Setting clock %.2fMHz, closest is %.2fMHz\n",
                    (double)data->block->PixelClock / 1000000.0, 
                    (double)clock / 1000000.0);
#endif
         if (clock)
            block->PixelClock = clock;
         block->RefreshRate = RefreshRate;
         return;
      }
   }
}
d1408 4
a1411 6
static Bool
I830VESASetVBEMode(ScrnInfoPtr pScrn, int mode, VbeCRTCInfoBlock * block)
{
   I830Ptr pI830 = I830PTR(pScrn);
   Bool ret = FALSE;
   int Mon;
d1413 5
a1417 7
   DPRINTF(PFX, "Setting mode 0x%.8x\n", mode);

#if 0
   /* Clear the framebuffer (could do this with VBIOS call) */
   if (I830IsPrimary(pScrn))
      memset(pI830->FbBase + pI830->FrontBuffer.Start, 0,
	  pScrn->virtualY * pI830->displayWidth * pI830->cpp);
d1419 3
a1421 3
      memset(pI830->FbBase + pI830->FrontBuffer2.Start, 0,
	  pScrn->virtualY * pI830->displayWidth * pI830->cpp);
#endif
d1423 3
a1425 5
   if (pI830->Clone && 
	pI830->CloneHDisplay && pI830->CloneVDisplay &&
       !pI830->preinit && !pI830->closing) {
      VbeCRTCInfoBlock newblock;
      int newmode = mode;
d1427 34
a1460 4
      if (pI830->pipe == 1)
         Mon = pI830->MonType1;
      else
         Mon = pI830->MonType2;
d1462 3
a1464 1
      SetBIOSPipe(pScrn, !pI830->pipe);
d1466 2
a1467 3
      /* Now recheck refresh operations we can use */
      pI830->useExtendedRefresh = FALSE;
      pI830->vesa->useDefaultRefresh = FALSE;
d1469 10
a1478 6
      if (Mon != PIPE_CRT) {
	 xf86DrvMsg(pScrn->scrnIndex, X_INFO,
		    "A non-CRT device is attached to Clone pipe %c.\n"
		    "\tNo refresh rate overrides will be attempted (0x%x).\n",
		    PIPE_NAME(!pI830->pipe), newmode);
	 pI830->vesa->useDefaultRefresh = TRUE;
a1479 6
      /*
       * Some desktop platforms might not have 0x5f05, so useExtendedRefresh
       * would need to be set to FALSE for those cases.
       */
      if (!pI830->vesa->useDefaultRefresh) 
	 pI830->useExtendedRefresh = TRUE;
d1481 4
a1484 3
      newmode |= 1 << 11;
      if (pI830->vesa->useDefaultRefresh)
            newmode &= ~(1 << 11);
d1486 12
a1497 23
      if (!SetRefreshRate(pScrn, newmode, 60)) {
	 xf86DrvMsg(pScrn->scrnIndex, X_INFO,
		    "BIOS call 0x5f05 not supported on Clone Head, "
		    "setting refresh with VBE 3 method.\n");
	 pI830->useExtendedRefresh = FALSE;
      }

      if (!pI830->vesa->useDefaultRefresh) {
         I830SetCloneVBERefresh(pScrn, newmode, &newblock, pI830->CloneRefresh * 100);

         if (!VBESetVBEMode(pI830->pVbe, newmode, &newblock)) {
            if (!VBESetVBEMode(pI830->pVbe, (newmode & ~(1 << 11)), NULL))
               xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
		 "Failed to set mode for Clone head.\n");
         } else {
            xf86DrvMsg(pScrn->scrnIndex, X_INFO,
		 "Setting refresh on clone head with VBE 3 method.\n");
            pI830->useExtendedRefresh = FALSE;
         }
      } else {
         if (!VBESetVBEMode(pI830->pVbe, (newmode & ~(1 << 11)), NULL))
            xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
		 "Failed to set mode for Clone head.\n");
d1499 3
d1503 3
a1505 11
      if (pI830->useExtendedRefresh && !pI830->vesa->useDefaultRefresh) {
         if (!SetRefreshRate(pScrn, newmode, pI830->CloneRefresh))
	    xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
		    "Failed to set refresh rate to %dHz on Clone head.\n",
		    pI830->CloneRefresh);
         else
	    xf86DrvMsg(pScrn->scrnIndex, X_INFO,
		    "Set refresh rate to %dHz on Clone head.\n",
		    pI830->CloneRefresh);
      }
      SetPipeAccess(pScrn);
d1507 1
d1509 9
a1517 4
   if (pI830->pipe == 0)
      Mon = pI830->MonType1;
   else
      Mon = pI830->MonType2;
d1519 2
a1521 15
   /* Now recheck refresh operations we can use */
   pI830->useExtendedRefresh = FALSE;
   pI830->vesa->useDefaultRefresh = FALSE;

   if (Mon != PIPE_CRT) {
      xf86DrvMsg(pScrn->scrnIndex, X_PROBED,
		    "A non-CRT device is attached to pipe %c.\n"
		    "\tNo refresh rate overrides will be attempted.\n",
		    PIPE_NAME(pI830->pipe));
      pI830->vesa->useDefaultRefresh = TRUE;
   }

   mode |= 1 << 11;
   if (pI830->vesa->useDefaultRefresh)
      mode &= ~(1 << 11);
d1523 1
a1523 2
    * Some desktop platforms might not have 0x5f05, so useExtendedRefresh
    * would need to be set to FALSE for those cases.
d1525 2
a1526 2
   if (!pI830->vesa->useDefaultRefresh) 
      pI830->useExtendedRefresh = TRUE;
d1528 14
a1541 6
   if (!SetRefreshRate(pScrn, mode, 60)) {
      xf86DrvMsg(pScrn->scrnIndex, X_INFO,
		    "BIOS call 0x5f05 not supported, "
		    "setting refresh with VBE 3 method.\n");
      pI830->useExtendedRefresh = FALSE;
   }
d1543 1
a1543 12
   if (!pI830->vesa->useDefaultRefresh && block) {
      ret = VBESetVBEMode(pI830->pVbe, mode, block);
      if (!ret)
         ret = VBESetVBEMode(pI830->pVbe, (mode & ~(1 << 11)), NULL);
      else {
         xf86DrvMsg(pScrn->scrnIndex, X_INFO,
		 "Setting refresh with VBE 3 method.\n");
	 pI830->useExtendedRefresh = FALSE;
      }
   } else {
      ret = VBESetVBEMode(pI830->pVbe, (mode & ~(1 << 11)), NULL);
   }
d1545 2
a1546 2
   /* Might as well bail now if we've failed */
   if (!ret) return FALSE;
d1548 13
a1560 7
   if (pI830->useExtendedRefresh && !pI830->vesa->useDefaultRefresh && block) {
      if (!SetRefreshRate(pScrn, mode, block->RefreshRate / 100)) {
	 xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
		    "Failed to set refresh rate to %dHz.\n",
		    block->RefreshRate / 100);
	 pI830->useExtendedRefresh = FALSE;
      }
d1562 3
d1566 5
a1570 2
   return ret;
}
d1572 2
a1573 11
static Bool
I830VESASetMode(ScrnInfoPtr pScrn, DisplayModePtr pMode)
{
   I830Ptr pI830 = I830PTR(pScrn);
   vbeInfoPtr pVbe = pI830->pVbe;
   I830ModePrivatePtr mp = (I830ModePrivatePtr) pMode->Private;
   int mode, i;
   CARD32 planeA, planeB, temp;
   int refresh = 60;
#ifdef XF86DRI
   Bool didLock = FALSE;
a1575 5
   DPRINTF(PFX, "I830VESASetMode\n");

   /* Always Enable Linear Addressing */
   mode = mp->vbeData.mode | (1 << 15) | (1 << 14);

d1577 4
a1580 7
   didLock = I830DRILock(pScrn);
#endif

   if (pI830->Clone) {
      pI830->CloneHDisplay = pMode->HDisplay;
      pI830->CloneVDisplay = pMode->VDisplay;
   }
d1582 2
a1583 5
#ifndef MODESWITCH_RESET_STATE
#define MODESWITCH_RESET_STATE 0
#endif
#if MODESWITCH_RESET_STATE
   ResetState(pScrn, TRUE);
d1586 3
a1588 1
   SetPipeAccess(pScrn);
d1590 2
a1591 9
   if (!pI830->MergedFB) {
      if (I830VESASetVBEMode(pScrn, mode, mp->vbeData.block) == FALSE) {
         xf86DrvMsg(pScrn->scrnIndex, X_ERROR, "Set VBE Mode failed!\n");
         return FALSE;
      }
   }else {
      I830ModePrivatePtr s = (I830ModePrivatePtr)mp->merged.Second->Private;
      I830ModePrivatePtr f = (I830ModePrivatePtr)mp->merged.First->Private;
      int pipe = pI830->pipe; /* save current pipe */
d1593 3
a1595 8
      SetBIOSPipe(pScrn, !pI830->pipe);

      pI830->pipe = !pI830->pipe;
      xf86DrvMsg(pScrn->scrnIndex, X_INFO, "Setting mode on Pipe %s.\n", pI830->pipe ? "B" : "A");

      if (I830VESASetVBEMode(pScrn, (s->vbeData.mode | 1<<15 | 1<<14), s->vbeData.block) == FALSE) {
         xf86DrvMsg(pScrn->scrnIndex, X_ERROR, "Set VBE Mode failed!\n");
         return FALSE;
d1597 1
d1599 5
a1603 2
      pI830->pipe = pipe; /* restore current pipe */
      xf86DrvMsg(pScrn->scrnIndex, X_INFO, "Setting mode on Pipe %s.\n", pI830->pipe ? "B" : "A");
d1605 2
a1606 1
      SetPipeAccess(pScrn);
d1608 16
a1623 22
      if (I830VESASetVBEMode(pScrn, (f->vbeData.mode | 1<<15 | 1<<14), f->vbeData.block) == FALSE) {
         xf86DrvMsg(pScrn->scrnIndex, X_ERROR, "Set VBE Mode failed!\n");
         return FALSE;
      }
   }

#if 0
   { /* I96X ENABLE TILING */
      planeA = INREG(DSPACNTR) | 1<<10;
      OUTREG(DSPACNTR, planeA);
      /* flush the change. */
      temp = INREG(DSPABASE);
      OUTREG(DSPABASE, temp);
   }
#else
   { /* I96X DISABLE TILING */
      planeA = INREG(DSPACNTR) & ~1<<10;
      OUTREG(DSPACNTR, planeA);
      /* flush the change. */
      temp = INREG(DSPABASE);
      OUTREG(DSPABASE, temp);
      OUTREG(DSPASURF, INREG(DSPASURF));
a1624 1
#endif
d1626 4
a1629 42
   /*
    * The BIOS may not set a scanline pitch that would require more video
    * memory than it's aware of.  We check for this later, and set it
    * explicitly if necessary.
    */
   if (mp->vbeData.data->XResolution != pI830->displayWidth) {
      if (pI830->Clone || pI830->MergedFB) {
         SetBIOSPipe(pScrn, !pI830->pipe);
         VBESetLogicalScanline(pVbe, pI830->displayWidth);
      }
      SetPipeAccess(pScrn);
      VBESetLogicalScanline(pVbe, pI830->displayWidth);
   }

   if (pScrn->bitsPerPixel >= 8 && pI830->vbeInfo->Capabilities[0] & 0x01) {
      if (pI830->Clone || pI830->MergedFB) {
         SetBIOSPipe(pScrn, !pI830->pipe);
         VBESetGetDACPaletteFormat(pVbe, 8);
      }
      SetPipeAccess(pScrn);
      VBESetGetDACPaletteFormat(pVbe, 8);
   }

   /* XXX Fix plane A with pipe A, and plane B with pipe B. */
   planeA = INREG(DSPACNTR);
   planeB = INREG(DSPBCNTR);

   pI830->planeEnabled[0] = ((planeA & DISPLAY_PLANE_ENABLE) != 0);
   pI830->planeEnabled[1] = ((planeB & DISPLAY_PLANE_ENABLE) != 0);

   xf86DrvMsg(pScrn->scrnIndex, X_INFO, "Display plane A is %s and connected to %s.\n",
	      pI830->planeEnabled[0] ? "enabled" : "disabled",
	      planeA & DISPPLANE_SEL_PIPE_MASK ? "Pipe B" : "Pipe A");
   if (pI830->availablePipes == 2)
      xf86DrvMsg(pScrn->scrnIndex, X_INFO, "Display plane B is %s and connected to %s.\n",
	      pI830->planeEnabled[1] ? "enabled" : "disabled",
	      planeB & DISPPLANE_SEL_PIPE_MASK ? "Pipe B" : "Pipe A");
   
   if (pI830->operatingDevices & 0xff) {
      pI830->planeEnabled[0] = 1;
   } else { 
      pI830->planeEnabled[0] = 0;
d1631 1
d1633 3
a1635 4
   if (pI830->operatingDevices & 0xff00) {
      pI830->planeEnabled[1] = 1;
   } else {
      pI830->planeEnabled[1] = 0;
d1637 5
a1641 28
   
   if (pI830->planeEnabled[0]) {
      xf86DrvMsg(pScrn->scrnIndex, X_INFO, "Enabling plane A.\n");
      planeA |= DISPLAY_PLANE_ENABLE;
      planeA &= ~DISPPLANE_SEL_PIPE_MASK;
      planeA |= DISPPLANE_SEL_PIPE_A;
      OUTREG(DSPACNTR, planeA);
      /* flush the change. */
      temp = INREG(DSPABASE);
      OUTREG(DSPABASE, temp);
      if (IS_I96X(pI830)) {
         temp = INREG(DSPASURF);
         OUTREG(DSPASURF, temp);
      }
   }
   if (pI830->planeEnabled[1]) {
      xf86DrvMsg(pScrn->scrnIndex, X_INFO, "Enabling plane B.\n");
      planeB |= DISPLAY_PLANE_ENABLE;
      planeB &= ~DISPPLANE_SEL_PIPE_MASK;
      planeB |= DISPPLANE_SEL_PIPE_B;
      OUTREG(DSPBCNTR, planeB);
      /* flush the change. */
      temp = INREG(DSPBADDR);
      OUTREG(DSPBADDR, temp);
      if (IS_I96X(pI830)) {
         temp = INREG(DSPBSURF);
         OUTREG(DSPBSURF, temp);
      }
d1644 2
a1645 9
   planeA = INREG(DSPACNTR);
   planeB = INREG(DSPBCNTR);
   xf86DrvMsg(pScrn->scrnIndex, X_INFO, "Display plane A is now %s and connected to %s.\n",
	      pI830->planeEnabled[0] ? "enabled" : "disabled",
	      planeA & DISPPLANE_SEL_PIPE_MASK ? "Pipe B" : "Pipe A");
   if (pI830->availablePipes == 2)
      xf86DrvMsg(pScrn->scrnIndex, X_INFO, "Display plane B is now %s and connected to %s.\n",
	      pI830->planeEnabled[1] ? "enabled" : "disabled",
	      planeB & DISPPLANE_SEL_PIPE_MASK ? "Pipe B" : "Pipe A");
d1647 4
a1650 12
   /* XXX Plane C is ignored for now (overlay). */

   /*
    * Print out the PIPEACONF and PIPEBCONF registers.
    */
   temp = INREG(PIPEACONF);
   xf86DrvMsg(pScrn->scrnIndex, X_INFO, "PIPEACONF is 0x%08lx\n", 
	      (unsigned long) temp);
   if (pI830->availablePipes == 2) {
      temp = INREG(PIPEBCONF);
      xf86DrvMsg(pScrn->scrnIndex, X_INFO, "PIPEBCONF is 0x%08lx\n", 
		 (unsigned long) temp);
d1653 1
a1653 24
   if (xf86IsEntityShared(pScrn->entityList[0])) {
      /* Clean this up !! */
      if (I830IsPrimary(pScrn)) {
         CARD32 stridereg = !pI830->pipe ? DSPASTRIDE : DSPBSTRIDE;
         CARD32 basereg = !pI830->pipe ? DSPABASE : DSPBBASE;
         CARD32 sizereg = !pI830->pipe ? DSPASIZE : DSPBSIZE;
         CARD32 surfreg = !pI830->pipe ? DSPASURF : DSPBSURF;
         I830Ptr pI8301 = I830PTR(pI830->entityPrivate->pScrn_1);

         temp = INREG(stridereg);
         if (temp / pI8301->cpp != (CARD32)(pI830->displayWidth)) {
            xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
		    "Correcting plane %c stride (%d -> %d)\n", PIPE_NAME(!pI830->pipe),
		    (int)(temp / pI8301->cpp), pI830->displayWidth);
	    OUTREG(stridereg, pI830->displayWidth * pI8301->cpp);
         }
         OUTREG(sizereg, (pMode->HDisplay - 1) | ((pMode->VDisplay - 1) << 16));
         /* Trigger update */
         temp = INREG(basereg);
         OUTREG(basereg, temp);
         if (IS_I96X(pI830)) {
            temp = INREG(surfreg);
            OUTREG(surfreg, temp);
         }
d1655 5
a1659 67
         if (pI830->entityPrivate && pI830->entityPrivate->pScrn_2) {
            I830Ptr pI8302 = I830PTR(pI830->entityPrivate->pScrn_2);
            stridereg = pI830->pipe ? DSPASTRIDE : DSPBSTRIDE;
            basereg = pI830->pipe ? DSPABASE : DSPBBASE;
            sizereg = pI830->pipe ? DSPASIZE : DSPBSIZE;
            surfreg = pI830->pipe ? DSPASURF : DSPBSURF;

            temp = INREG(stridereg);
            if (temp / pI8302->cpp != (CARD32)(pI8302->displayWidth)) {
	       xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
		    "Correcting plane %c stride (%d -> %d)\n", PIPE_NAME(pI830->pipe),
		    (int)(temp / pI8302->cpp), pI8302->displayWidth);
	       OUTREG(stridereg, pI8302->displayWidth * pI8302->cpp);
            }
            OUTREG(sizereg, (pI830->entityPrivate->pScrn_2->currentMode->HDisplay - 1) | ((pI830->entityPrivate->pScrn_2->currentMode->VDisplay - 1) << 16));
            /* Trigger update */
            temp = INREG(basereg);
            OUTREG(basereg, temp);
            if (IS_I96X(pI830)) {
               temp = INREG(surfreg);
               OUTREG(surfreg, temp);
            }
         }
      } else {
         CARD32 stridereg = pI830->pipe ? DSPASTRIDE : DSPBSTRIDE;
         CARD32 basereg = pI830->pipe ? DSPABASE : DSPBBASE;
         CARD32 sizereg = pI830->pipe ? DSPASIZE : DSPBSIZE;
         CARD32 surfreg = pI830->pipe ? DSPASURF : DSPBSURF;
         I830Ptr pI8301 = I830PTR(pI830->entityPrivate->pScrn_1);
         I830Ptr pI8302 = I830PTR(pI830->entityPrivate->pScrn_2);

         temp = INREG(stridereg);
         if (temp / pI8301->cpp != (CARD32)(pI8301->displayWidth)) {
	    xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
		    "Correcting plane %c stride (%d -> %d)\n", PIPE_NAME(pI830->pipe),
		    (int)(temp / pI8301->cpp), pI8301->displayWidth);
	    OUTREG(stridereg, pI8301->displayWidth * pI8301->cpp);
         }
         OUTREG(sizereg, (pI830->entityPrivate->pScrn_1->currentMode->HDisplay - 1) | ((pI830->entityPrivate->pScrn_1->currentMode->VDisplay - 1) << 16));
         /* Trigger update */
         temp = INREG(basereg);
         OUTREG(basereg, temp);
         if (IS_I96X(pI830)) {
            temp = INREG(surfreg);
            OUTREG(surfreg, temp);
         }

         stridereg = !pI830->pipe ? DSPASTRIDE : DSPBSTRIDE;
         basereg = !pI830->pipe ? DSPABASE : DSPBBASE;
         sizereg = !pI830->pipe ? DSPASIZE : DSPBSIZE;
         surfreg = !pI830->pipe ? DSPASURF : DSPBSURF;

         temp = INREG(stridereg);
         if (temp / pI8302->cpp != ((CARD32)pI8302->displayWidth)) {
	    xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
		    "Correcting plane %c stride (%d -> %d)\n", PIPE_NAME(!pI830->pipe),
		    (int)(temp / pI8302->cpp), pI8302->displayWidth);
	    OUTREG(stridereg, pI8302->displayWidth * pI8302->cpp);
         }
         OUTREG(sizereg, (pMode->HDisplay - 1) | ((pMode->VDisplay - 1) << 16));
         /* Trigger update */
         temp = INREG(basereg);
         OUTREG(basereg, temp);
         if (IS_I96X(pI830)) {
            temp = INREG(surfreg);
            OUTREG(surfreg, temp);
         }
d1661 3
a1663 6
   } else {
      for (i = 0; i < pI830->availablePipes; i++) {
         CARD32 stridereg = i ? DSPBSTRIDE : DSPASTRIDE;
         CARD32 basereg = i ? DSPBBASE : DSPABASE;
         CARD32 sizereg = i ? DSPBSIZE : DSPASIZE;
         CARD32 surfreg = i ? DSPBSURF : DSPASURF;
d1665 4
a1668 2
         if (!pI830->planeEnabled[i])
	    continue;
d1670 12
a1681 30
         temp = INREG(stridereg);
         if (temp / pI830->cpp != (CARD32)pI830->displayWidth) {
	    xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
		    "Correcting plane %c stride (%d -> %d)\n", PIPE_NAME(i),
		    (int)(temp / pI830->cpp), pI830->displayWidth);
	    OUTREG(stridereg, pI830->displayWidth * pI830->cpp);
         }

	 if (pI830->MergedFB) {
	    switch (pI830->SecondPosition) {
	       case PosRightOf:
	       case PosBelow:
                  OUTREG(DSPABASE, (CDMPTR.First->HDisplay - 1) | ((CDMPTR.First->VDisplay - 1) << 16));
                  OUTREG(DSPBBASE, (CDMPTR.Second->HDisplay - 1) | ((CDMPTR.Second->VDisplay - 1) << 16));
	          break;
	       case PosLeftOf:
	       case PosAbove:
                  OUTREG(DSPABASE, (CDMPTR.Second->HDisplay - 1) | ((CDMPTR.Second->VDisplay - 1) << 16));
                  OUTREG(DSPBBASE, (CDMPTR.First->HDisplay - 1) | ((CDMPTR.First->VDisplay - 1) << 16));
	          break;
	    }
         } else
            OUTREG(sizereg, (pMode->HDisplay - 1) | ((pMode->VDisplay - 1) << 16));
	 /* Trigger update */
	 temp = INREG(basereg);
	 OUTREG(basereg, temp);
         if (IS_I96X(pI830)) {
            temp = INREG(surfreg);
            OUTREG(surfreg, temp);
         }
d1683 1
a1684 67

#if 0
   /* Print out some CRTC/display information. */
   temp = INREG(HTOTAL_A);
   ErrorF("Horiz active: %d, Horiz total: %d\n", temp & 0x7ff,
	  (temp >> 16) & 0xfff);
   temp = INREG(HBLANK_A);
   ErrorF("Horiz blank start: %d, Horiz blank end: %d\n", temp & 0xfff,
	  (temp >> 16) & 0xfff);
   temp = INREG(HSYNC_A);
   ErrorF("Horiz sync start: %d, Horiz sync end: %d\n", temp & 0xfff,
	  (temp >> 16) & 0xfff);
   temp = INREG(VTOTAL_A);
   ErrorF("Vert active: %d, Vert total: %d\n", temp & 0x7ff,
	  (temp >> 16) & 0xfff);
   temp = INREG(VBLANK_A);
   ErrorF("Vert blank start: %d, Vert blank end: %d\n", temp & 0xfff,
	  (temp >> 16) & 0xfff);
   temp = INREG(VSYNC_A);
   ErrorF("Vert sync start: %d, Vert sync end: %d\n", temp & 0xfff,
	  (temp >> 16) & 0xfff);
   temp = INREG(PIPEASRC);
   ErrorF("Image size: %dx%d (%dx%d)\n",
          (temp >> 16) & 0x7ff, temp & 0x7ff,
	  (((temp >> 16) & 0x7ff) + 1), ((temp & 0x7ff) + 1));
   ErrorF("Pixel multiply is %d\n", (planeA >> 20) & 0x3);
   temp = INREG(DSPABASE);
   ErrorF("Plane A start offset is %d\n", temp);
   temp = INREG(DSPASTRIDE);
   ErrorF("Plane A stride is %d bytes (%d pixels)\n", temp, temp / pI830->cpp);
   temp = INREG(DSPAPOS);
   ErrorF("Plane A position %d %d\n", temp & 0xffff, (temp & 0xffff0000) >> 16);
   temp = INREG(DSPASIZE);
   ErrorF("Plane A size %d %d\n", temp & 0xffff, (temp & 0xffff0000) >> 16);

   /* Print out some CRTC/display information. */
   temp = INREG(HTOTAL_B);
   ErrorF("Horiz active: %d, Horiz total: %d\n", temp & 0x7ff,
	  (temp >> 16) & 0xfff);
   temp = INREG(HBLANK_B);
   ErrorF("Horiz blank start: %d, Horiz blank end: %d\n", temp & 0xfff,
	  (temp >> 16) & 0xfff);
   temp = INREG(HSYNC_B);
   ErrorF("Horiz sync start: %d, Horiz sync end: %d\n", temp & 0xfff,
	  (temp >> 16) & 0xfff);
   temp = INREG(VTOTAL_B);
   ErrorF("Vert active: %d, Vert total: %d\n", temp & 0x7ff,
	  (temp >> 16) & 0xfff);
   temp = INREG(VBLANK_B);
   ErrorF("Vert blank start: %d, Vert blank end: %d\n", temp & 0xfff,
	  (temp >> 16) & 0xfff);
   temp = INREG(VSYNC_B);
   ErrorF("Vert sync start: %d, Vert sync end: %d\n", temp & 0xfff,
	  (temp >> 16) & 0xfff);
   temp = INREG(PIPEBSRC);
   ErrorF("Image size: %dx%d (%dx%d)\n",
          (temp >> 16) & 0x7ff, temp & 0x7ff,
	  (((temp >> 16) & 0x7ff) + 1), ((temp & 0x7ff) + 1));
   ErrorF("Pixel multiply is %d\n", (planeA >> 20) & 0x3);
   temp = INREG(DSPBBASE);
   ErrorF("Plane B start offset is %d\n", temp);
   temp = INREG(DSPBSTRIDE);
   ErrorF("Plane B stride is %d bytes (%d pixels)\n", temp, temp / pI830->cpp);
   temp = INREG(DSPBPOS);
   ErrorF("Plane B position %d %d\n", temp & 0xffff, (temp & 0xffff0000) >> 16);
   temp = INREG(DSPBSIZE);
   ErrorF("Plane B size %d %d\n", temp & 0xffff, (temp & 0xffff0000) >> 16);
d1686 7
d1694 1
a1694 2
   xf86DrvMsg(pScrn->scrnIndex, X_INFO, "Mode bandwidth is %d Mpixel/s\n",
	      pMode->HDisplay * pMode->VDisplay * refresh / 1000000);
d1696 1
a1696 2
   {
      int maxBandwidth, bandwidthA, bandwidthB;
d1698 4
a1701 7
      if (GetModeSupport(pScrn, 0x80, 0x80, 0x80, 0x80,
			&maxBandwidth, &bandwidthA, &bandwidthB)) {
	 xf86DrvMsg(pScrn->scrnIndex, X_INFO, "maxBandwidth is %d Mbyte/s, "
		    "pipe bandwidths are %d Mbyte/s, %d Mbyte/s\n",
		    maxBandwidth, bandwidthA, bandwidthB);
      }
   }
d1704 5
a1708 2
   {
      int ret;
d1710 6
a1715 4
      ret = GetLFPCompMode(pScrn);
      if (ret != -1) {
	 xf86DrvMsg(pScrn->scrnIndex, X_INFO,
		    "LFP compensation mode: 0x%x\n", ret);
d1720 1
a1720 16
#if MODESWITCH_RESET_STATE
   ResetState(pScrn, TRUE);
   SetHWOperatingState(pScrn);
#endif

#if 0
   if (IS_I96X(pI830))
      I965PrintErrorState(pScrn);
   else
      I830PrintErrorState(pScrn);
#endif

#ifdef XF86DRI
   if (didLock)
      I830DRIUnlock(pScrn);
#endif
a1721 1
   pScrn->vtSema = TRUE;
d1725 6
d1732 1
a1732 1
InitRegisterRec(ScrnInfoPtr pScrn)
d1735 3
a1737 2
   I830RegPtr i830Reg = &pI830->ModeReg;
   int i;
d1741 17
a1757 2
   for (i = 0; i < 8; i++)
      i830Reg->Fence[i] = 0;
d1760 2
a1761 4
/* Famous last words
 */
void
I830PrintErrorState(ScrnInfoPtr pScrn)
d1764 3
d1768 2
a1769 2
   ErrorF("pgetbl_ctl: 0x%lx pgetbl_err: 0x%lx\n",
	  (unsigned long)INREG(PGETBL_CTL), (unsigned long)INREG(PGE_ERR));
d1771 1
a1771 2
   ErrorF("ipeir: %lx iphdr: %lx\n", (unsigned long)INREG(IPEIR), 
	  (unsigned long)INREG(IPEHR));
d1773 2
a1774 5
   ErrorF("LP ring tail: %lx head: %lx len: %lx start %lx\n",
	  (unsigned long)INREG(LP_RING + RING_TAIL),
	  (unsigned long)INREG(LP_RING + RING_HEAD) & HEAD_ADDR,
	  (unsigned long)INREG(LP_RING + RING_LEN), 
	  (unsigned long)INREG(LP_RING + RING_START));
d1776 3
a1778 2
   ErrorF("eir: %x esr: %x emr: %x\n",
	  INREG16(EIR), INREG16(ESR), INREG16(EMR));
d1780 2
a1781 1
   ErrorF("instdone: %x instpm: %x\n", INREG16(INST_DONE), INREG8(INST_PM));
d1783 3
a1785 2
   ErrorF("memmode: %lx instps: %lx\n", (unsigned long)INREG(MEMMODE), 
	  (unsigned long)INREG(INST_PS));
d1787 12
a1798 2
   ErrorF("hwstam: %x ier: %x imr: %x iir: %x\n",
	  INREG16(HWSTAM), INREG16(IER), INREG16(IMR), INREG16(IIR));
d1802 1
a1802 1
I965PrintErrorState(ScrnInfoPtr pScrn)
d1806 5
a1810 57
   ErrorF("pgetbl_ctl: 0x%lx pgetbl_err: 0x%lx\n",
	  INREG(PGETBL_CTL), INREG(PGE_ERR));

   ErrorF("ipeir: %lx iphdr: %lx\n", INREG(IPEIR_I965), INREG(IPEHR_I965));

   ErrorF("LP ring tail: %lx head: %lx len: %lx start %lx\n",
	  INREG(LP_RING + RING_TAIL),
	  INREG(LP_RING + RING_HEAD) & HEAD_ADDR,
	  INREG(LP_RING + RING_LEN), INREG(LP_RING + RING_START));

   ErrorF("Err ID (eir): %x Err Status (esr): %x Err Mask (emr): %x\n",
	  (int)INREG(EIR), (int)INREG(ESR), (int)INREG(EMR));

   ErrorF("instdone: %x instdone_1: %x\n", (int)INREG(INST_DONE_I965),
	  (int)INREG(INST_DONE_1));
   ErrorF("instpm: %x\n", (int)INREG(INST_PM));

   ErrorF("memmode: %lx instps: %lx\n", INREG(MEMMODE), INREG(INST_PS_I965));

   ErrorF("HW Status mask (hwstam): %x\nIRQ enable (ier): %x imr: %x iir: %x\n",
	  (int)INREG(HWSTAM), (int)INREG(IER), (int)INREG(IMR),
	  (int)INREG(IIR));

   ErrorF("acthd: %lx dma_fadd_p: %lx\n", INREG(ACTHD), INREG(DMA_FADD_P));
   ErrorF("ecoskpd: %lx excc: %lx\n", INREG(ECOSKPD), INREG(EXCC));

   ErrorF("cache_mode: %x/%x\n", (int)INREG(CACHE_MODE_0),
	  (int)INREG(CACHE_MODE_1));
   ErrorF("mi_arb_state: %x\n", (int)INREG(MI_ARB_STATE));

   ErrorF("IA_VERTICES_COUNT_QW %x/%x\n", (int)INREG(IA_VERTICES_COUNT_QW),
	  (int)INREG(IA_VERTICES_COUNT_QW+4));
   ErrorF("IA_PRIMITIVES_COUNT_QW %x/%x\n", (int)INREG(IA_PRIMITIVES_COUNT_QW),
	  (int)INREG(IA_PRIMITIVES_COUNT_QW+4));

   ErrorF("VS_INVOCATION_COUNT_QW %x/%x\n", (int)INREG(VS_INVOCATION_COUNT_QW),
	  (int)INREG(VS_INVOCATION_COUNT_QW+4));

   ErrorF("GS_INVOCATION_COUNT_QW %x/%x\n", (int)INREG(GS_INVOCATION_COUNT_QW),
	  (int)INREG(GS_INVOCATION_COUNT_QW+4));
   ErrorF("GS_PRIMITIVES_COUNT_QW %x/%x\n", (int)INREG(GS_PRIMITIVES_COUNT_QW),
	  (int)INREG(GS_PRIMITIVES_COUNT_QW+4));

   ErrorF("CL_INVOCATION_COUNT_QW %x/%x\n", (int)INREG(CL_INVOCATION_COUNT_QW),
	  (int)INREG(CL_INVOCATION_COUNT_QW+4));
   ErrorF("CL_PRIMITIVES_COUNT_QW %x/%x\n", (int)INREG(CL_PRIMITIVES_COUNT_QW),
	  (int)INREG(CL_PRIMITIVES_COUNT_QW+4));

   ErrorF("PS_INVOCATION_COUNT_QW %x/%x\n", (int)INREG(PS_INVOCATION_COUNT_QW),
	  (int)INREG(PS_INVOCATION_COUNT_QW+4));
   ErrorF("PS_DEPTH_COUNT_QW %x/%x\n", (int)INREG(PS_DEPTH_COUNT_QW),
	  (int)INREG(PS_DEPTH_COUNT_QW+4));

   ErrorF("WIZ_CTL %x\n", (int)INREG(WIZ_CTL));
   ErrorF("TS_CTL %x  TS_DEBUG_DATA %x\n", (int)INREG(TS_CTL),
	  (int)INREG(TS_DEBUG_DATA));
   ErrorF("TD_CTL %x / %x\n", (int)INREG(TD_CTL), (int)INREG(TD_CTL2));
d1812 6
a1817 1
   
d1820 4
a1823 1
#ifdef I830DEBUG
d1825 1
a1825 1
dump_DSPACNTR(ScrnInfoPtr pScrn)
a1827 1
   unsigned int tmp;
d1829 19
a1847 3
   /* Display A Control */
   tmp = INREG(0x70180);
   ErrorF("Display A Plane Control Register (0x%.8x)\n", tmp);
d1849 4
a1852 4
   if (tmp & BIT(31))
      ErrorF("   Display Plane A (Primary) Enable\n");
   else
      ErrorF("   Display Plane A (Primary) Disabled\n");
d1854 8
a1861 4
   if (tmp & BIT(30))
      ErrorF("   Display A pixel data is gamma corrected\n");
   else
      ErrorF("   Display A pixel data bypasses gamma correction logic (default)\n");
d1863 4
a1866 24
   switch ((tmp & 0x3c000000) >> 26) {	/* bit 29:26 */
   case 0x00:
   case 0x01:
   case 0x03:
      ErrorF("   Reserved\n");
      break;
   case 0x02:
      ErrorF("   8-bpp Indexed\n");
      break;
   case 0x04:
      ErrorF("   15-bit (5-5-5) pixel format (Targa compatible)\n");
      break;
   case 0x05:
      ErrorF("   16-bit (5-6-5) pixel format (XGA compatible)\n");
      break;
   case 0x06:
      ErrorF("   32-bit format (X:8:8:8)\n");
      break;
   case 0x07:
      ErrorF("   32-bit format (8:8:8:8)\n");
      break;
   default:
      ErrorF("   Unknown - Invalid register value maybe?\n");
   }
d1868 2
a1869 4
   if (tmp & BIT(25))
      ErrorF("   Stereo Enable\n");
   else
      ErrorF("   Stereo Disable\n");
d1871 7
a1877 4
   if (tmp & BIT(24))
      ErrorF("   Display A, Pipe B Select\n");
   else
      ErrorF("   Display A, Pipe A Select\n");
d1879 4
a1882 4
   if (tmp & BIT(22))
      ErrorF("   Source key is enabled\n");
   else
      ErrorF("   Source key is disabled\n");
d1884 2
a1885 12
   switch ((tmp & 0x00300000) >> 20) {	/* bit 21:20 */
   case 0x00:
      ErrorF("   No line duplication\n");
      break;
   case 0x01:
      ErrorF("   Line/pixel Doubling\n");
      break;
   case 0x02:
   case 0x03:
      ErrorF("   Reserved\n");
      break;
   }
d1887 6
a1892 4
   if (tmp & BIT(18))
      ErrorF("   Stereo output is high during second image\n");
   else
      ErrorF("   Stereo output is high during first image\n");
d1895 2
a1896 2
static void
dump_DSPBCNTR(ScrnInfoPtr pScrn)
d1898 1
d1900 90
a1989 1
   unsigned int tmp;
d1991 2
a1992 3
   /* Display B/Sprite Control */
   tmp = INREG(0x71180);
   ErrorF("Display B/Sprite Plane Control Register (0x%.8x)\n", tmp);
d1994 8
a2001 4
   if (tmp & BIT(31))
      ErrorF("   Display B/Sprite Enable\n");
   else
      ErrorF("   Display B/Sprite Disable\n");
d2003 1
a2003 4
   if (tmp & BIT(30))
      ErrorF("   Display B pixel data is gamma corrected\n");
   else
      ErrorF("   Display B pixel data bypasses gamma correction logic (default)\n");
d2005 14
a2018 23
   switch ((tmp & 0x3c000000) >> 26) {	/* bit 29:26 */
   case 0x00:
   case 0x01:
   case 0x03:
      ErrorF("   Reserved\n");
      break;
   case 0x02:
      ErrorF("   8-bpp Indexed\n");
      break;
   case 0x04:
      ErrorF("   15-bit (5-5-5) pixel format (Targa compatible)\n");
      break;
   case 0x05:
      ErrorF("   16-bit (5-6-5) pixel format (XGA compatible)\n");
      break;
   case 0x06:
      ErrorF("   32-bit format (X:8:8:8)\n");
      break;
   case 0x07:
      ErrorF("   32-bit format (8:8:8:8)\n");
      break;
   default:
      ErrorF("   Unknown - Invalid register value maybe?\n");
d2020 1
d2022 2
a2023 4
   if (tmp & BIT(25))
      ErrorF("   Stereo is enabled and both start addresses are used in a two frame sequence\n");
   else
      ErrorF("   Stereo disable and only a single start address is used\n");
d2025 2
a2026 4
   if (tmp & BIT(24))
      ErrorF("   Display B/Sprite, Pipe B Select\n");
   else
      ErrorF("   Display B/Sprite, Pipe A Select\n");
d2028 79
a2106 4
   if (tmp & BIT(22))
      ErrorF("   Sprite source key is enabled\n");
   else
      ErrorF("   Sprite source key is disabled (default)\n");
d2108 10
a2117 11
   switch ((tmp & 0x00300000) >> 20) {	/* bit 21:20 */
   case 0x00:
      ErrorF("   No line duplication\n");
      break;
   case 0x01:
      ErrorF("   Line/pixel Doubling\n");
      break;
   case 0x02:
   case 0x03:
      ErrorF("   Reserved\n");
      break;
d2120 8
a2127 4
   if (tmp & BIT(18))
      ErrorF("   Stereo output is high during second image\n");
   else
      ErrorF("   Stereo output is high during first image\n");
d2129 3
a2131 4
   if (tmp & BIT(15))
      ErrorF("   Alpha transfer mode enabled\n");
   else
      ErrorF("   Alpha transfer mode disabled\n");
d2133 2
a2134 5
   if (tmp & BIT(0))
      ErrorF("   Sprite is above overlay\n");
   else
      ErrorF("   Sprite is above display A (default)\n");
}
d2136 4
a2139 5
void
I830_dump_registers(ScrnInfoPtr pScrn)
{
   I830Ptr pI830 = I830PTR(pScrn);
   unsigned int i;
d2141 3
a2143 1
   ErrorF("%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n");
d2145 6
a2150 2
   dump_DSPACNTR(pScrn);
   dump_DSPBCNTR(pScrn);
d2152 2
a2153 4
   ErrorF("0x71400 == 0x%.8x\n", INREG(0x71400));
   ErrorF("0x70008 == 0x%.8x\n", INREG(0x70008));
   for (i = 0x71410; i <= 0x71428; i += 4)
      ErrorF("0x%x == 0x%.8x\n", i, INREG(i));
d2155 1
a2155 1
   ErrorF("%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n");
a2156 1
#endif
a2185 34
I830CreateScreenResources (ScreenPtr pScreen)
{
   ScrnInfoPtr pScrn = xf86Screens[pScreen->myNum];
   I830Ptr pI830 = I830PTR(pScrn);

   pScreen->CreateScreenResources = pI830->CreateScreenResources;
   if (!(*pScreen->CreateScreenResources)(pScreen))
      return FALSE;

   if (xf86LoaderCheckSymbol("I830RandRSetConfig") && pI830->rotation != RR_Rotate_0) {
      Rotation (*I830RandRSetConfig)(ScreenPtr pScreen, Rotation rr, int rate, RRScreenSizePtr pSize) = NULL;
      RRScreenSize p;
      Rotation requestedRotation = pI830->rotation;

      pI830->rotation = RR_Rotate_0;

      /* Just setup enough for an initial rotate */
      p.width = pScreen->width;
      p.height = pScreen->height;
      p.mmWidth = pScreen->mmWidth;
      p.mmHeight = pScreen->mmHeight;

      I830RandRSetConfig = LoaderSymbol("I830RandRSetConfig");
      if (I830RandRSetConfig) {
         pI830->starting = TRUE; /* abuse this for dual head & rotation */
   	 (*I830RandRSetConfig) (pScreen, requestedRotation, 0, &p);
         pI830->starting = FALSE;
      }
   } 

   return TRUE;
}

static Bool
a2190 1
   I830Ptr pI830 = I830PTR(pScrn);
d2199 1
a2199 1
   if (!pI830->MergedFB && pScrn->virtualX > pScrn->virtualY)
d2225 7
a2231 1
/* Initialize the first context */
d2238 1
a2238 1
   if (pI830->noAccel || !I830IsPrimary(pScrn))
d2241 15
a2255 3
   ctx_addr = pI830->ContextMem.Start;
   /* Align to a 2k boundry */
   ctx_addr = ((ctx_addr + 2048 - 1) / 2048) * 2048;
d2257 2
d2262 1
a2262 1
      OUT_RING(ctx_addr |
d2277 3
a2279 10
#ifdef XF86DRI
#ifndef DRM_BO_MEM_TT
#error "Wrong drm.h file included. You need to compile and install a recent libdrm."
#endif

#ifndef XSERVER_LIBDRM_MM

static int
I830DrmMMInit(int drmFD, unsigned long pageOffs, unsigned long pageSize,
	      unsigned memType)
d2281 3
d2285 1
a2285 49
   drm_mm_init_arg_t arg;
   int ret;
   
   memset(&arg, 0, sizeof(arg));
   arg.req.op = mm_init;
   arg.req.p_offset = pageOffs;
   arg.req.p_size = pageSize;
   arg.req.mem_type = memType;

   ret = ioctl(drmFD, DRM_IOCTL_MM_INIT, &arg);
   
   if (ret)
      return -errno;
   
   return 0;
   
}

static int
I830DrmMMTakedown(int drmFD, unsigned memType)
{
   drm_mm_init_arg_t arg;
   int ret = 0;
   
   memset(&arg, 0, sizeof(arg));
   arg.req.op = mm_takedown;
   arg.req.mem_type = memType;
   if (ioctl(drmFD, DRM_IOCTL_MM_INIT, &arg)) {
      ret = -errno;
   }
   
   return ret;
}

static int I830DrmMMLock(int fd, unsigned memType)
{
    drm_mm_init_arg_t arg;
    int ret;

    memset(&arg, 0, sizeof(arg));
    arg.req.op = mm_lock;
    arg.req.mem_type = memType;

    do{
	ret = ioctl(fd, DRM_IOCTL_MM_INIT, &arg);
    } while (ret && errno == EAGAIN);
    
    return ret;	
}
d2287 1
a2287 4
static int I830DrmMMUnlock(int fd, unsigned memType)
{
    drm_mm_init_arg_t arg;
    int ret;
d2289 1
a2289 3
    memset(&arg, 0, sizeof(arg));
    arg.req.op = mm_unlock;
    arg.req.mem_type = memType;
d2291 1
a2291 5
    do{
	ret = ioctl(fd, DRM_IOCTL_MM_INIT, &arg);
    } while (ret && errno == EAGAIN);
    
    return ret;	
a2293 3
#endif
#endif

d2295 1
a2295 1
I830BIOSScreenInit(int scrnIndex, ScreenPtr pScreen, int argc, char **argv)
d2302 4
d2307 1
a2307 1
   Bool driDisabled;
d2314 154
a2467 1
   pScrn->displayWidth = pI830->displayWidth;
d2470 145
a2614 6
      /* Rotated Buffer */
      memset(&(pI830->RotatedMem), 0, sizeof(pI830->RotatedMem));
      pI830->RotatedMem.Key = -1;
      /* Rotated2 Buffer */
      memset(&(pI830->RotatedMem2), 0, sizeof(pI830->RotatedMem2));
      pI830->RotatedMem2.Key = -1;
d2658 1
a2658 79
   if (xf86IsEntityShared(pScrn->entityList[0])) {
      /* PreInit failed on the second head, so make sure we turn it off */
      if (I830IsPrimary(pScrn) && !pI830->entityPrivate->pScrn_2) {
         if (pI830->pipe == 0) {
            pI830->operatingDevices &= 0xFF;
         } else {
            pI830->operatingDevices &= 0xFF00;
         }
      }
   }

   pI830->starting = TRUE;

   /* Alloc our pointers for the primary head */
   if (I830IsPrimary(pScrn)) {
      if (!pI830->LpRing)
         pI830->LpRing = xalloc(sizeof(I830RingBuffer));
      if (!pI830->CursorMem)
         pI830->CursorMem = xalloc(sizeof(I830MemRange));
      if (!pI830->CursorMemARGB)
         pI830->CursorMemARGB = xalloc(sizeof(I830MemRange));
      if (!pI830->OverlayMem)
         pI830->OverlayMem = xalloc(sizeof(I830MemRange));
      if (!pI830->overlayOn)
         pI830->overlayOn = xalloc(sizeof(Bool));
      if (!pI830->used3D)
         pI830->used3D = xalloc(sizeof(int));
      if (!pI830->LpRing || !pI830->CursorMem || !pI830->CursorMemARGB ||
          !pI830->OverlayMem || !pI830->overlayOn || !pI830->used3D) {
         xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
		 "Could not allocate primary data structures.\n");
         return FALSE;
      }
      *pI830->overlayOn = FALSE;
      if (pI830->entityPrivate)
         pI830->entityPrivate->XvInUse = -1;
   }

   /* Make our second head point to the first heads structures */
   if (!I830IsPrimary(pScrn)) {
      pI8301 = I830PTR(pI830->entityPrivate->pScrn_1);
      pI830->LpRing = pI8301->LpRing;
      pI830->CursorMem = pI8301->CursorMem;
      pI830->CursorMemARGB = pI8301->CursorMemARGB;
      pI830->OverlayMem = pI8301->OverlayMem;
      pI830->overlayOn = pI8301->overlayOn;
      pI830->used3D = pI8301->used3D;
   }

   /*
    * If we're changing the BIOS's view of the video memory size, do that
    * first, then re-initialise the VBE information.
    */
   if (I830IsPrimary(pScrn)) {
      SetPipeAccess(pScrn);
      if (pI830->pVbe)
         vbeFree(pI830->pVbe);
      pI830->pVbe = VBEInit(NULL, pI830->pEnt->index);
   } else {
      pI830->pVbe = pI8301->pVbe;
   }

   if (I830IsPrimary(pScrn)) {
      if (!TweakMemorySize(pScrn, pI830->newBIOSMemSize,FALSE))
         SetBIOSMemSize(pScrn, pI830->newBIOSMemSize);
   }

   if (!pI830->pVbe)
      return FALSE;

   if (I830IsPrimary(pScrn)) {
      if (pI830->vbeInfo)
         VBEFreeVBEInfo(pI830->vbeInfo);
      pI830->vbeInfo = VBEGetVBEInfo(pI830->pVbe);
   } else {
      pI830->vbeInfo = pI8301->vbeInfo;
   }

   SetPipeAccess(pScrn);
a2686 7
   if (I830IsPrimary(pScrn)) {
      I830ResetAllocations(pScrn, 0);

      if (!I830Allocate2DMemory(pScrn, ALLOC_INITIAL))
	return FALSE;
   }

d2688 1
a2688 1
      if (pI830->LpRing->mem.Size == 0) {
a2695 9
   if (!pI830->SWCursor) {
      if (pI830->CursorMem->Size == 0) {
	  xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
		     "Disabling HW cursor because the cursor memory "
		      "allocation failed.\n");
	   pI830->SWCursor = TRUE;
      }
   }

d2703 1
a2703 1
      if (pI830->OverlayMem->Physical == 0) {
a2711 2
   InitRegisterRec(pScrn);

a2713 5
    * pI830->directRenderingDisabled is set once in PreInit.  Reinitialise
    * pI830->directRenderingEnabled based on it each generation.
    */
   pI830->directRenderingEnabled = !pI830->directRenderingDisabled;
   /*
a2726 2
   driDisabled = !pI830->directRenderingEnabled;

d2728 1
a2728 1
      pI830->directRenderingEnabled = I830DRIScreenInit(pScreen);
d2730 27
a2756 6
   if (pI830->directRenderingEnabled) {
      pI830->directRenderingEnabled =
	 I830Allocate3DMemory(pScrn,
			      pI830->disableTiling ? ALLOC_NO_TILING : 0);
      if (!pI830->directRenderingEnabled)
	  I830DRICloseScreen(pScreen);
d2763 1
a2763 15
   /*
    * After the 3D allocations have been done, see if there's any free space
    * that can be added to the framebuffer allocation.
    */
   if (I830IsPrimary(pScrn)) {
      I830Allocate2DMemory(pScrn, 0);

      DPRINTF(PFX, "assert(if(!I830DoPoolAllocation(pScrn, pI830->StolenPool)))\n");
      if (!I830DoPoolAllocation(pScrn, &(pI830->StolenPool)))
         return FALSE;

      DPRINTF(PFX, "assert( if(!I830FixupOffsets(pScrn)) )\n");
      if (!I830FixupOffsets(pScrn))
         return FALSE;
   }
d2765 2
a2766 5
#ifdef XF86DRI
   if (pI830->directRenderingEnabled) {
      I830SetupMemoryTiling(pScrn);
      pI830->directRenderingEnabled = I830DRIDoMappings(pScreen);
   }
d2776 1
a2776 1
      pScrn->fbOffset = pI830->FrontBuffer.Start;
d2778 1
a2778 1
      pScrn->fbOffset = pI8301->FrontBuffer2.Start;
d2790 1
a2790 2
   /* Clear SavedReg */
   memset(&pI830->SavedReg, 0, sizeof(pI830->SavedReg));
d2792 13
a2804 1
   DPRINTF(PFX, "assert( if(!I830BIOSEnterVT(scrnIndex, 0)) )\n");
d2806 2
a2807 2
   if (!I830BIOSEnterVT(scrnIndex, 0))
      return FALSE;
d2831 1
a2831 1
   fbPictureInit(pScreen, 0, 0);
d2835 1
a2835 1
   I830DGAInit(pScreen);
a2838 16
   if (I830IsPrimary(pScrn)) {
      if (!I830InitFBManager(pScreen, &(pI830->FbMemBox))) {
         xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
		 "Failed to init memory manager\n");
      }

      if (pI830->LinearAlloc && xf86InitFBManagerLinear(pScreen, pI830->LinearMem.Offset / pI830->cpp, pI830->LinearMem.Size / pI830->cpp))
            xf86DrvMsg(scrnIndex, X_INFO, 
			"Using %ld bytes of offscreen memory for linear (offset=0x%lx)\n", pI830->LinearMem.Size, pI830->LinearMem.Offset);

   } else {
      if (!I830InitFBManager(pScreen, &(pI8301->FbMemBox2))) {
         xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
		 "Failed to init memory manager\n");
      }
   }
d2860 11
d2876 1
a2876 1
   if (!xf86HandleColormaps(pScreen, 256, 8, I830LoadPalette, 0,
d2882 1
a2882 1
   xf86DPMSInit(pScreen, I830DisplayPowerManagementSet, 0);
a2889 6
#ifdef XF86DRI
   if (pI830->directRenderingEnabled) {
      pI830->directRenderingEnabled = I830DRIFinishScreenInit(pScreen);
   }
#endif

d2898 1
a2898 1
      if (driDisabled)
d2907 4
a2910 1
   pScreen->SaveScreen = I830BIOSSaveScreen;
d2912 10
a2921 40
   pScreen->CloseScreen = I830BIOSCloseScreen;

   if (pI830->MergedFB) {
      pI830->PointerMoved = pScrn->PointerMoved;
      pScrn->PointerMoved = I830MergedPointerMoved;

      if(pI830->IntelXinerama) {
	  I830noPanoramiXExtension = FALSE;
	  I830XineramaExtensionInit(pScrn);
	  if(!I830noPanoramiXExtension) {
	     if(pI830->HaveNonRect) {
		/* Reset the viewport (now eventually non-recangular) */
		I830AdjustFrame(scrnIndex, pScrn->frameX0, pScrn->frameY0, 0);
	     }
	  }
      } else {
	  pI830->MouseRestrictions = FALSE;
      }
   } else if (pI830->shadowReq.minorversion >= 1) {
      /* Rotation */
      xf86DrvMsg(pScrn->scrnIndex, X_INFO, "RandR enabled, ignore the following RandR disabled message.\n");
      xf86DisableRandR(); /* Disable built-in RandR extension */
      shadowSetup(pScreen);
      /* support all rotations */
      if (IS_I96X(pI830)) {
	 I830RandRInit(pScreen, RR_Rotate_0); /* only 0 degrees for I96X */
      } else {
	 I830RandRInit(pScreen, RR_Rotate_0 | RR_Rotate_90 | RR_Rotate_180 | RR_Rotate_270);
      }
      pI830->PointerMoved = pScrn->PointerMoved;
      pScrn->PointerMoved = I830PointerMoved;
      pI830->CreateScreenResources = pScreen->CreateScreenResources;
      pScreen->CreateScreenResources = I830CreateScreenResources;
   } else {
      /* Rotation */
      xf86DrvMsg(pScrn->scrnIndex, X_INFO, "libshadow is version %d.%d.%d, required 1.1.0 or greater for rotation.\n",pI830->shadowReq.majorversion,pI830->shadowReq.minorversion,pI830->shadowReq.patchlevel);
   }

   /* Call this unconditionally, as it also sets some fields in the SAREA */
   I830UpdateXineramaScreenInfo(pScrn);
d2926 1
a2926 5
#ifdef I830DEBUG
   I830_dump_registers(pScrn);
#endif

   if (IS_I96X(pI830)) {
a2943 65
   switch (pI830->InitialRotation) {
      case 0:
         xf86DrvMsg(pScrn->scrnIndex, X_INFO, "Rotating to 0 degrees\n");
         pI830->rotation = RR_Rotate_0;
         break;
      case 90:
         xf86DrvMsg(pScrn->scrnIndex, X_INFO, "Rotating to 90 degrees\n");
         pI830->rotation = RR_Rotate_90;
         break;
      case 180:
         xf86DrvMsg(pScrn->scrnIndex, X_INFO, "Rotating to 180 degrees\n");
         pI830->rotation = RR_Rotate_180;
         break;
      case 270:
         xf86DrvMsg(pScrn->scrnIndex, X_INFO, "Rotating to 270 degrees\n");
         pI830->rotation = RR_Rotate_270;
         break;
      default:
         xf86DrvMsg(pScrn->scrnIndex, X_INFO, "Bad rotation setting - defaulting to 0 degrees\n");
         pI830->rotation = RR_Rotate_0;
         break;
   }


#ifdef XF86DRI
   if (pI830->directRenderingEnabled && (pI830->mmModeFlags & I830_KERNEL_MM)) {
      unsigned long aperEnd = ROUND_DOWN_TO(pI830->FbMapSize, GTT_PAGE_SIZE) 
	 / GTT_PAGE_SIZE;
      unsigned long aperStart = ROUND_TO(pI830->FbMapSize - KB(pI830->mmSize), GTT_PAGE_SIZE) 
	 / GTT_PAGE_SIZE;

      if (aperEnd < aperStart || aperEnd - aperStart < I830_MM_MINPAGES) {
	 xf86DrvMsg(pScrn->scrnIndex, X_ERROR, 
		    "Too little AGP aperture space for DRM memory manager.\n"
		    "\tPlease increase AGP aperture size from BIOS configuration screen\n"
		    "\tor decrease the amount of video RAM using option \"VideoRam\".\n"
		    "\tDisabling DRI.\n");
	 pI830->directRenderingOpen = FALSE;
	 I830DRICloseScreen(pScreen);
	 pI830->directRenderingEnabled = FALSE;
      } else {
#ifndef XSERVER_LIBDRM_MM
	 if (I830DrmMMInit(pI830->drmSubFD, aperStart, aperEnd - aperStart,
			   DRM_BO_MEM_TT)) {
#else
	 if (drmMMInit(pI830->drmSubFD, aperStart, aperEnd - aperStart,
		       DRM_BO_MEM_TT)) {
#endif	   
	    xf86DrvMsg(pScrn->scrnIndex, X_ERROR, 
		       "Could not initialize the DRM memory manager.\n");
	    
	    pI830->directRenderingOpen = FALSE;
	    I830DRICloseScreen(pScreen);
	    pI830->directRenderingEnabled = FALSE;
	 } else {
	    xf86DrvMsg(pScrn->scrnIndex, X_INFO, 
		       "Initialized DRM memory manager, %ld AGP pages\n"
		       "\tat AGP offset 0x%lx\n", 
		       aperEnd - aperStart,
		       aperStart);
	 }
      }
   }
#endif

a2946 119

static void
I830AdjustFrame(int scrnIndex, int x, int y, int flags)
{
   ScrnInfoPtr pScrn;
   I830Ptr pI830;
   vbeInfoPtr pVbe;
   unsigned long Start;

   pScrn = xf86Screens[scrnIndex];
   pI830 = I830PTR(pScrn);
   pVbe = pI830->pVbe;

   DPRINTF(PFX, "I830AdjustFrame: y = %d (+ %d), x = %d (+ %d)\n",
	   x, pI830->xoffset, y, pI830->yoffset);

   /* Sync the engine before adjust frame */
   if (pI830->AccelInfoRec && pI830->AccelInfoRec->NeedToSync) {
      (*pI830->AccelInfoRec->Sync)(pScrn);
      pI830->AccelInfoRec->NeedToSync = FALSE;
   }

   if (pI830->MergedFB) {
      I830AdjustFrameMerged(scrnIndex, x, y, flags);

      if (pI830->pipe == 0) {
         OUTREG(DSPABASE, pI830->FrontBuffer.Start + ((pI830->FirstframeY0 * pScrn->displayWidth + pI830->FirstframeX0) * pI830->cpp));
         OUTREG(DSPBBASE, pI830->FrontBuffer.Start + ((pI830->pScrn_2->frameY0 * pScrn->displayWidth + pI830->pScrn_2->frameX0) * pI830->cpp));
      } else {
         OUTREG(DSPBBASE, pI830->FrontBuffer.Start + ((pI830->FirstframeY0 * pScrn->displayWidth + pI830->FirstframeX0) * pI830->cpp));
         OUTREG(DSPABASE, pI830->FrontBuffer.Start + ((pI830->pScrn_2->frameY0 * pScrn->displayWidth + pI830->pScrn_2->frameX0) * pI830->cpp));
      }

      return;
   }

   if (I830IsPrimary(pScrn))
      Start = pI830->FrontBuffer.Start;
   else {
      I830Ptr pI8301 = I830PTR(pI830->entityPrivate->pScrn_1);
      Start = pI8301->FrontBuffer2.Start;
   }

   /* Sigh...
    * It seems that there are quite a few Video BIOS' that get this wrong.
    * So, we'll bypass the VBE call and hit the hardware directly.
    */

   if (pI830->Clone) {
      if (!pI830->pipe == 0) {
         if (!IS_I96X(pI830)) {
            OUTREG(DSPABASE, Start + ((y * pScrn->displayWidth + x) * pI830->cpp));
         } else {
            OUTREG(DSPABASE, 0);
            OUTREG(DSPASURF, Start + ((y * pScrn->displayWidth + x) * pI830->cpp));
         }
      } else {
         if (!IS_I96X(pI830)) {
            OUTREG(DSPBBASE, Start + ((y * pScrn->displayWidth + x) * pI830->cpp));
         } else {
            OUTREG(DSPBBASE, 0);
            OUTREG(DSPBSURF, Start + ((y * pScrn->displayWidth + x) * pI830->cpp));
         }
      }
   }

   if (pI830->pipe == 0) {
      if (!IS_I96X(pI830)) {
         OUTREG(DSPABASE, Start + ((y * pScrn->displayWidth + x) * pI830->cpp));
      } else {
         OUTREG(DSPABASE, 0);
         OUTREG(DSPASURF, Start + ((y * pScrn->displayWidth + x) * pI830->cpp));
      }
   } else {
      if (!IS_I96X(pI830)) {
         OUTREG(DSPBBASE, Start + ((y * pScrn->displayWidth + x) * pI830->cpp));
      } else {
         OUTREG(DSPBBASE, 0);
         OUTREG(DSPBSURF, Start + ((y * pScrn->displayWidth + x) * pI830->cpp));
      }
   }
}

static void
I830BIOSFreeScreen(int scrnIndex, int flags)
{
   I830BIOSFreeRec(xf86Screens[scrnIndex]);
   if (xf86LoaderCheckSymbol("vgaHWFreeHWRec"))
      vgaHWFreeHWRec(xf86Screens[scrnIndex]);
}

#ifndef SAVERESTORE_HWSTATE
#define SAVERESTORE_HWSTATE 0
#endif

#if SAVERESTORE_HWSTATE
static void
SaveHWOperatingState(ScrnInfoPtr pScrn)
{
   I830Ptr pI830 = I830PTR(pScrn);
   I830RegPtr save = &pI830->SavedReg;

   DPRINTF(PFX, "SaveHWOperatingState\n");

   return;
}

static void
RestoreHWOperatingState(ScrnInfoPtr pScrn)
{
   I830Ptr pI830 = I830PTR(pScrn);
   I830RegPtr save = &pI830->SavedReg;

   DPRINTF(PFX, "RestoreHWOperatingState\n");

   return;
}
#endif

d2948 1
a2948 1
I830BIOSLeaveVT(int scrnIndex, int flags)
d2951 1
d2953 2
d2956 2
a2957 264
   DPRINTF(PFX, "Leave VT\n");

   pI830->leaving = TRUE;

   if (pI830->devicesTimer)
      TimerCancel(pI830->devicesTimer);
   pI830->devicesTimer = NULL;

#ifdef I830_XV
   /* Give the video overlay code a chance to shutdown. */
   I830VideoSwitchModeBefore(pScrn, NULL);
#endif

   if (pI830->Clone || pI830->MergedFB) {
      /* Ensure we don't try and setup modes on a clone head */
      pI830->CloneHDisplay = 0;
      pI830->CloneVDisplay = 0;
   }

   if (!I830IsPrimary(pScrn)) {
   	I830Ptr pI8301 = I830PTR(pI830->entityPrivate->pScrn_1);
	if (!pI8301->GttBound) {
		return;
	}
   }

#ifdef XF86DRI
   if (pI830->directRenderingOpen) {
      DRILock(screenInfo.screens[pScrn->scrnIndex], 0);
      if (pI830->mmModeFlags & I830_KERNEL_MM) {
#ifndef XSERVER_LIBDRM_MM
	 I830DrmMMLock(pI830->drmSubFD, DRM_BO_MEM_TT);
#else
	 drmMMLock(pI830->drmSubFD, DRM_BO_MEM_TT);
#endif
      }
      I830DRISetVBlankInterrupt (pScrn, FALSE);
      
      drmCtlUninstHandler(pI830->drmSubFD);
   }
#endif

#if SAVERESTORE_HWSTATE
   if (!pI830->closing)
      SaveHWOperatingState(pScrn);
#endif

   if (pI830->CursorInfoRec && pI830->CursorInfoRec->HideCursor)
      pI830->CursorInfoRec->HideCursor(pScrn);

   ResetState(pScrn, TRUE);

   if (I830IsPrimary(pScrn)) {
      if (!SetDisplayDevices(pScrn, pI830->savedDevices)) {
         xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
		 "Failed to switch back to original display devices (0x%x)\n",
		 pI830->savedDevices);
      } else {
         xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
		 "Successfully set original devices\n");
      }
   }

   RestoreHWState(pScrn);
   RestoreBIOSMemSize(pScrn);
   if (I830IsPrimary(pScrn))
      I830UnbindAGPMemory(pScrn);
   if (pI830->AccelInfoRec)
      pI830->AccelInfoRec->NeedToSync = FALSE;

   /* DO IT AGAIN! AS IT SEEMS THAT SOME LFPs FLICKER OTHERWISE */
   if (I830IsPrimary(pScrn)) {
      if (!SetDisplayDevices(pScrn, pI830->savedDevices)) {
         xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
		 "Failed to switch back to original display devices (0x%x) (2)\n",
		 pI830->savedDevices);
      } else {
         xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
		 "Successfully set original devices (2)\n");
      }
   }
}

static Bool
I830DetectMonitorChange(ScrnInfoPtr pScrn)
{
   I830Ptr pI830 = I830PTR(pScrn);
   pointer pDDCModule = NULL;
   DisplayModePtr p, pMon;
   int memsize;
   int DDCclock = 0, DDCclock2 = 0;
   int displayWidth = pScrn->displayWidth;
   int curHDisplay = pScrn->currentMode->HDisplay;
   int curVDisplay = pScrn->currentMode->VDisplay;
   xf86MonPtr monitor = NULL;

   DPRINTF(PFX, "Detect Monitor Change\n");
   
   SetPipeAccess(pScrn);

   /* Re-read EDID */
   pDDCModule = xf86LoadSubModule(pScrn, "ddc");

   if (pI830->MergedFB) {
      pI830->pVbe->ddc = DDC_UNCHECKED;
      SetBIOSPipe(pScrn, !pI830->pipe);
      monitor = vbeDoEDID(pI830->pVbe, pDDCModule);
      if ((pI830->pScrn_2->monitor->DDC = monitor) != NULL) {
         xf86PrintEDID(monitor);
         xf86SetDDCproperties(pScrn, monitor);
      } 
      SetPipeAccess(pScrn);
   }

   pI830->pVbe->ddc = DDC_UNCHECKED;
   monitor = vbeDoEDID(pI830->pVbe, pDDCModule);
   xf86UnloadSubModule(pDDCModule);
   if ((pScrn->monitor->DDC = monitor) != NULL) {
      xf86PrintEDID(monitor);
      xf86SetDDCproperties(pScrn, monitor);
   } 

   DDCclock = I830UseDDC(pScrn);

   /* Check if DDC exists on the second head, if not don't abort. */
   if (pI830->MergedFB)
      DDCclock2 = I830UseDDC(pI830->pScrn_2);

   /* Revalidate the modes */

   /*
    * Note: VBE modes (> 0x7f) won't work with Intel's extended BIOS
    * functions.  
    */
   SetPipeAccess(pScrn);

   pScrn->modePool = I830GetModePool(pScrn, pI830->pVbe, pI830->vbeInfo);

   if (!pScrn->modePool) {
      /* This is bad, which would cause the Xserver to exit, maybe
       * we should default to a 640x480 @@ 60Hz mode here ??? */
      xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
		 "No Video BIOS modes for chosen depth.\n");
      return FALSE;
   }

   if (pI830->MergedFB) {
      SetBIOSPipe(pScrn, !pI830->pipe);
      xf86DrvMsg(pScrn->scrnIndex, X_INFO,
		 "Retrieving mode pool for second head.\n");
      pI830->pScrn_2->modePool = I830GetModePool(pI830->pScrn_2, pI830->pVbe, pI830->vbeInfo);

      if (!pI830->pScrn_2->modePool) {
         xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
		 "No Video BIOS modes for chosen depth.\n");
         PreInitCleanup(pScrn);
         return FALSE;
      }
      SetPipeAccess(pScrn);
   }

   VBESetModeNames(pScrn->modePool);
   if (pI830->MergedFB)
      VBESetModeNames(pI830->pScrn_2->modePool);

   if (pScrn->videoRam > (pI830->vbeInfo->TotalMemory * 64))
      memsize = pI830->vbeInfo->TotalMemory * 64;
   else
      memsize = pScrn->videoRam;

   VBEValidateModes(pScrn, pScrn->monitor->Modes, pScrn->display->modes, NULL,
			NULL, 0, MAX_DISPLAY_PITCH, 1,
			0, MAX_DISPLAY_HEIGHT,
			pScrn->display->virtualX,
			pScrn->display->virtualY,
			memsize, LOOKUP_BEST_REFRESH);

   if (pI830->MergedFB) {
      VBEValidateModes(pI830->pScrn_2, pI830->pScrn_2->monitor->Modes, 
		        pI830->pScrn_2->display->modes, NULL,
			NULL, 0, MAX_DISPLAY_PITCH, 1,
			0, MAX_DISPLAY_HEIGHT,
			pScrn->display->virtualX,
			pScrn->display->virtualY,
			memsize, LOOKUP_BEST_REFRESH);
   }

   if (DDCclock > 0) {
      p = pScrn->modes;
      if (p == NULL)
         return FALSE;
      do {
         int Clock = 100000000; /* incredible value */

         if (p->status == MODE_OK) {
            for (pMon = pScrn->monitor->Modes; pMon != NULL; pMon = pMon->next) {
               if ((pMon->HDisplay != p->HDisplay) ||
                   (pMon->VDisplay != p->VDisplay) ||
                   (pMon->Flags & (V_INTERLACE | V_DBLSCAN | V_CLKDIV2)))
                  continue;

               /* Find lowest supported Clock for this resolution */
               if (Clock > pMon->Clock)
                  Clock = pMon->Clock;
            } 

            if (Clock != 100000000 && DDCclock < 2550 && Clock / 1000.0 > DDCclock) {
               ErrorF("(%s,%s) mode clock %gMHz exceeds DDC maximum %dMHz\n",
		   p->name, pScrn->monitor->id,
		   Clock/1000.0, DDCclock);
               p->status = MODE_BAD;
            } 
         }
         p = p->next;
      } while (p != NULL && p != pScrn->modes);
   }

   /* Only use this if we've got DDC available */
   if (pI830->MergedFB && DDCclock2 > 0) {
      p = pI830->pScrn_2->modes;
      if (p == NULL)
         return FALSE;
      do {
         int Clock = 100000000; /* incredible value */

	 if (p->status == MODE_OK) {
            for (pMon = pI830->pScrn_2->monitor->Modes; pMon != NULL; pMon = pMon->next) {
               if ((pMon->HDisplay != p->HDisplay) ||
                   (pMon->VDisplay != p->VDisplay) ||
                   (pMon->Flags & (V_INTERLACE | V_DBLSCAN | V_CLKDIV2)))
                   continue;

               /* Find lowest supported Clock for this resolution */
               if (Clock > pMon->Clock)
                  Clock = pMon->Clock;
            } 

            if (Clock != 100000000 && DDCclock2 < 2550 && Clock / 1000.0 > DDCclock2) {
               ErrorF("(%s,%s) mode clock %gMHz exceeds DDC maximum %dMHz\n",
		   p->name, pI830->pScrn_2->monitor->id,
		   Clock/1000.0, DDCclock2);
               p->status = MODE_BAD;
            } 
 	 }
         p = p->next;
      } while (p != NULL && p != pI830->pScrn_2->modes);
   }

   xf86PruneDriverModes(pScrn);

   if (pI830->MergedFB)
      xf86PruneDriverModes(pI830->pScrn_2);

   if (pI830->MergedFB) {
      DisplayModePtr old_modes, cur_mode;

      old_modes = pScrn->modes;
      cur_mode = pScrn->currentMode;

      xf86DrvMsg(pScrn->scrnIndex, X_INFO, "MergedFB: Generating mode list\n");

      pScrn->modes = I830GenerateModeList(pScrn, pI830->MetaModes,
					  old_modes, pI830->pScrn_2->modes,
					  pI830->SecondPosition);
d2959 7
a2965 6
      if(!pScrn->modes) {
          xf86DrvMsg(pScrn->scrnIndex, X_ERROR, "No modes. Disabling MergedFB.\n");
	  pScrn->modes = old_modes;
	  pScrn->currentMode = cur_mode;
	  pI830->MergedFB = FALSE;
      }
d2967 1
d2969 7
a2975 2
   if (!pI830->vesa->useDefaultRefresh)
      I830SetModeParameters(pScrn, pI830->pVbe);
d2977 5
a2981 3
   /* Now check if the previously used mode is o.k. for the current monitor.
    * This allows VT switching to continue happily when not disconnecting
    * and reconnecting monitors */
d2983 1
a2983 1
   pScrn->currentMode = pScrn->modes;
d2985 1
a2985 6
   if (pI830->MergedFB) {
      /* If no virtual dimension was given by the user,
       * calculate a sane one now. Adapts pScrn->virtualX,
       * pScrn->virtualY and pScrn->displayWidth.
       */
      I830RecalcDefaultVirtualSize(pScrn);
d2987 3
a2989 4
      pScrn->modes = pScrn->modes->next;  /* We get the last from GenerateModeList(), skip to first */
      pScrn->currentMode = pScrn->modes;
      pI830->currentMode = pScrn->currentMode;
   }
d2991 1
a2991 1
   pScrn->displayWidth = displayWidth; /* restore old displayWidth */
d2993 4
a2996 8
   p = pScrn->modes;
   if (p == NULL)
      return FALSE;
   do {
      if ((p->HDisplay == curHDisplay) &&
          (p->VDisplay == curVDisplay) &&
          (!(p->Flags & (V_INTERLACE | V_DBLSCAN | V_CLKDIV2)))) {
   		pScrn->currentMode = p; /* previous mode is o.k. */
d2998 1
a2998 2
      p = p->next;
   } while (p != NULL && p != pScrn->modes);
d3000 3
a3002 1
   I830PrintModes(pScrn);
d3004 4
a3007 3
   /* Now readjust for panning if necessary */
   {
      pScrn->frameX0 = (pScrn->frameX0 + pScrn->frameX1 + 1 - pScrn->currentMode->HDisplay) / 2;
d3009 1
a3009 2
      if (pScrn->frameX0 < 0)
         pScrn->frameX0 = 0;
d3011 1
a3011 5
      pScrn->frameX1 = pScrn->frameX0 + pScrn->currentMode->HDisplay - 1;
      if (pScrn->frameX1 >= pScrn->virtualX) {
         pScrn->frameX0 = pScrn->virtualX - pScrn->currentMode->HDisplay;
         pScrn->frameX1 = pScrn->virtualX - 1;
      }
d3013 1
a3013 1
      pScrn->frameY0 = (pScrn->frameY0 + pScrn->frameY1 + 1 - pScrn->currentMode->VDisplay) / 2;
d3015 3
a3017 8
      if (pScrn->frameY0 < 0)
         pScrn->frameY0 = 0;

      pScrn->frameY1 = pScrn->frameY0 + pScrn->currentMode->VDisplay - 1;
      if (pScrn->frameY1 >= pScrn->virtualY) {
        pScrn->frameY0 = pScrn->virtualY - pScrn->currentMode->VDisplay;
        pScrn->frameY1 = pScrn->virtualY - 1;
      }
d3020 2
a3021 2
   if (pI830->MergedFB)
      I830AdjustFrameMerged(pScrn->scrnIndex, pScrn->frameX0, pScrn->frameY0, 0);
d3023 7
a3029 23
   return TRUE;
}

Bool
I830CheckModeSupport(ScrnInfoPtr pScrn, int x, int y, int mode)
{
   I830Ptr pI830 = I830PTR(pScrn);
   Bool ret = TRUE;

   if (pI830->Clone) {
      if (pI830->pipeDisplaySize[0].x2 != 0) {
	 if (x > pI830->pipeDisplaySize[0].x2 ||
             y > pI830->pipeDisplaySize[0].y2) {
	 	xf86DrvMsg(pScrn->scrnIndex, X_INFO, "Bad Clone Mode removing\n");
		return FALSE;
         }
      }
      if (pI830->pipeDisplaySize[1].x2 != 0) {
	 if (x > pI830->pipeDisplaySize[1].x2 ||
             y > pI830->pipeDisplaySize[1].y2) {
	 	xf86DrvMsg(pScrn->scrnIndex, X_INFO, "Bad Clone Mode removing\n");
		return FALSE;
         }
d3032 1
d3034 2
a3035 1
   return ret;
d3037 1
a3037 1
		
d3042 1
a3042 1
I830BIOSEnterVT(int scrnIndex, int flags)
d3045 3
a3047 1
   I830Ptr pI830 = I830PTR(pScrn);
d3062 7
a3068 36
#if 1
   /* Clear the framebuffer */
   memset(pI830->FbBase + pScrn->fbOffset, 0,
	  pScrn->virtualY * pScrn->displayWidth * pI830->cpp);
#endif

   if (I830IsPrimary(pScrn)) {
     /* 
      * This is needed for restoring from ACPI modes (especially S3)
      * so that we warmboot the Video BIOS. Some platforms have problems,
      * warm booting when we don't need to, so check that we can call
      * the Video BIOS with our saved devices, and only when that fails,
      * we'll warm boot it.
      */
      /* Check Pipe conf registers or possibly HTOTAL/VTOTAL for 0x00000000)*/
      CARD32 temp;
      Bool set = I830Set640x480(pScrn);
      temp = pI830->pipe ? INREG(PIPEBCONF) : INREG(PIPEACONF);
      if (!set || !(temp & 0x80000000)) {
         xf86Int10InfoPtr pInt;

         xf86DrvMsg(pScrn->scrnIndex, X_INFO, 
				"Detected resume, re-POSTing.\n");

         pInt = xf86InitInt10(pI830->pEnt->index);

         /* Now perform our warm boot */
         if (pInt) {
            pInt->num = 0xe6;
            xf86ExecX86int10 (pInt);
            xf86FreeInt10 (pInt);
            xf86DrvMsg(pScrn->scrnIndex, X_INFO, "Re-POSTing via int10.\n");
         } else {
            xf86DrvMsg(pScrn->scrnIndex, X_WARNING, 
		"Re-POSTing via int10 failed, trying to continue.\n");
         }
d3070 2
d3073 2
a3074 4
      /* Finally, re-setup the display devices */
      if (!SetDisplayDevices(pScrn, pI830->operatingDevices)) {
         xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
 		 "Failed to switch to configured display devices\n");
a3075 2
      }
   }
d3077 1
a3077 2
   /* Setup for device monitoring status */
   pI830->monitorSwitch = pI830->toggleDevices = INREG(SWF0) & 0x0000FFFF;
d3079 2
a3080 3
   if (I830IsPrimary(pScrn))
      if (!I830BindAGPMemory(pScrn))
         return FALSE;
d3082 3
a3084 4
   CheckInheritedState(pScrn);
   if (I830IsPrimary(pScrn)) {
      if (!TweakMemorySize(pScrn, pI830->newBIOSMemSize,FALSE))
         SetBIOSMemSize(pScrn, pI830->newBIOSMemSize);
d3087 1
a3087 1
   ResetState(pScrn, FALSE);
d3090 10
a3099 4
   if (!pI830->starting)
      I830DetectMonitorChange(pScrn);
	    
   if (!I830VESASetMode(pScrn, pScrn->currentMode))
d3102 5
a3106 3
#ifdef I830_XV
   I830VideoSwitchModeAfter(pScrn, pScrn->currentMode);
#endif
d3108 1
a3108 1
   ResetState(pScrn, TRUE);
a3110 6
   pScrn->AdjustFrame(scrnIndex, pScrn->frameX0, pScrn->frameY0, 0);

#if SAVERESTORE_HWSTATE
   RestoreHWOperatingState(pScrn);
#endif

d3113 5
d3128 1
a3128 1
	 I830RefreshRing(pScrn);
a3135 8
	 if (pI830->mmModeFlags & I830_KERNEL_MM) {
#ifndef XSERVER_LIBDRM_MM
	    I830DrmMMUnlock(pI830->drmSubFD, DRM_BO_MEM_TT);
#else
	    drmMMUnlock(pI830->drmSubFD, DRM_BO_MEM_TT);
#endif
	 }

d3143 6
a3148 2
   /* Needed for rotation */
   IntelEmitInvarientState(pScrn);
d3153 3
a3155 4
   pI830->currentMode = pScrn->currentMode;

   /* Force invarient state when rotated to be emitted */
   *pI830->used3D = 1<<31;
d3161 1
a3161 1
I830BIOSSwitchMode(int scrnIndex, DisplayModePtr mode, int flags)
a3162 1

a3164 149
   Bool ret = TRUE;
   PixmapPtr pspix = (*pScrn->pScreen->GetScreenPixmap) (pScrn->pScreen);

   DPRINTF(PFX, "I830BIOSSwitchMode: mode == %p\n", mode);

#ifdef I830_XV
   /* Give the video overlay code a chance to see the new mode. */
   I830VideoSwitchModeBefore(pScrn, mode);
#endif

   /* Sync the engine before mode switch */
   if (pI830->AccelInfoRec && pI830->AccelInfoRec->NeedToSync) {
      (*pI830->AccelInfoRec->Sync)(pScrn);
      pI830->AccelInfoRec->NeedToSync = FALSE;
   }

   /* Check if our currentmode is about to change. We do this so if we
    * are rotating, we don't need to call the mode setup again.
    */
   if (pI830->currentMode != mode) {
      if (!I830VESASetMode(pScrn, mode))
         ret = FALSE;
   }

   /* Kludge to detect Rotate or Vidmode switch. Not very elegant, but
    * workable given the implementation currently. We only need to call
    * the rotation function when we know that the framebuffer has been
    * disabled by the EnableDisableFBAccess() function.
    *
    * The extra WindowTable check detects a rotation at startup.
    */
   if ( (!WindowTable[pScrn->scrnIndex] || pspix->devPrivate.ptr == NULL) &&
         !pI830->DGAactive && (pScrn->PointerMoved == I830PointerMoved) &&
	 !IS_I96X(pI830)) {
      if (!I830Rotate(pScrn, mode))
         ret = FALSE;
   }

   /* Either the original setmode or rotation failed, so restore the previous
    * video mode here, as we'll have already re-instated the original rotation.
    */
   if (!ret) {
      if (!I830VESASetMode(pScrn, pI830->currentMode)) {
	 xf86DrvMsg(scrnIndex, X_INFO,
		    "Failed to restore previous mode (SwitchMode)\n");
      }

#ifdef I830_XV
      /* Give the video overlay code a chance to see the new mode. */
      I830VideoSwitchModeAfter(pScrn, pI830->currentMode);
#endif
   } else {
      pI830->currentMode = mode;

#ifdef I830_XV
      /* Give the video overlay code a chance to see the new mode. */
      I830VideoSwitchModeAfter(pScrn, mode);
#endif
   }

   /* Since RandR (indirectly) uses SwitchMode(), we need to
    * update our Xinerama info here, too, in case of resizing
    * Call this unconditionally, as it also sets some fields in the SAREA
    */
   I830UpdateXineramaScreenInfo(pScrn);

   return ret;
}

static Bool
I830BIOSSaveScreen(ScreenPtr pScreen, int mode)
{
   ScrnInfoPtr pScrn = xf86Screens[pScreen->myNum];
   I830Ptr pI830 = I830PTR(pScrn);
   Bool on = xf86IsUnblank(mode);
   CARD32 temp, ctrl, base, surf;

   DPRINTF(PFX, "I830BIOSSaveScreen: %d, on is %s\n", mode, BOOLTOSTRING(on));

   if (pScrn->vtSema) {
      if (pI830->pipe == 0) {
	 ctrl = DSPACNTR;
	 base = DSPABASE;
	 surf = DSPASURF;
      } else {
	 ctrl = DSPBCNTR;
	 base = DSPBADDR;
	 surf = DSPBSURF;
      }
      if (pI830->planeEnabled[pI830->pipe]) {
	 temp = INREG(ctrl);
	 if (on)
	    temp |= DISPLAY_PLANE_ENABLE;
	 else
	    temp &= ~DISPLAY_PLANE_ENABLE;
	 OUTREG(ctrl, temp);
	 /* Flush changes */
	 temp = INREG(base);
	 OUTREG(base, temp);
	 if (IS_I96X(pI830)) {
            temp = INREG(surf);
            OUTREG(surf, temp);
         }
      }

      if (pI830->CursorInfoRec && !pI830->SWCursor && pI830->cursorOn) {
	 if (on)
	    pI830->CursorInfoRec->ShowCursor(pScrn);
	 else
	    pI830->CursorInfoRec->HideCursor(pScrn);
	 pI830->cursorOn = TRUE;
      }
   }
   return TRUE;
}

/* Use the VBE version when available. */
static void
I830DisplayPowerManagementSet(ScrnInfoPtr pScrn, int PowerManagementMode,
			      int flags)
{
   I830Ptr pI830 = I830PTR(pScrn);
   vbeInfoPtr pVbe = pI830->pVbe;

   if (pI830->Clone || pI830->MergedFB) {
      SetBIOSPipe(pScrn, !pI830->pipe);
      if (xf86LoaderCheckSymbol("VBEDPMSSet")) {
         VBEDPMSSet(pVbe, PowerManagementMode);
      } else {
         pVbe->pInt10->num = 0x10;
         pVbe->pInt10->ax = 0x4f10;
         pVbe->pInt10->bx = 0x01;

         switch (PowerManagementMode) {
         case DPMSModeOn:
	    break;
         case DPMSModeStandby:
	    pVbe->pInt10->bx |= 0x0100;
	    break;
         case DPMSModeSuspend:
	    pVbe->pInt10->bx |= 0x0200;
	    break;
         case DPMSModeOff:
	    pVbe->pInt10->bx |= 0x0400;
	    break;
         }
         xf86ExecX86int10_wrapper(pVbe->pInt10, pScrn);
      }
   }
d3166 1
a3166 24
   SetPipeAccess(pScrn);

   if (xf86LoaderCheckSymbol("VBEDPMSSet")) {
      VBEDPMSSet(pVbe, PowerManagementMode);
   } else {
      pVbe->pInt10->num = 0x10;
      pVbe->pInt10->ax = 0x4f10;
      pVbe->pInt10->bx = 0x01;

      switch (PowerManagementMode) {
      case DPMSModeOn:
	 break;
      case DPMSModeStandby:
	 pVbe->pInt10->bx |= 0x0100;
	 break;
      case DPMSModeSuspend:
	 pVbe->pInt10->bx |= 0x0200;
	 break;
      case DPMSModeOff:
	 pVbe->pInt10->bx |= 0x0400;
	 break;
      }
      xf86ExecX86int10_wrapper(pVbe->pInt10, pScrn);
   }
d3170 1
a3170 1
I830BIOSCloseScreen(int scrnIndex, ScreenPtr pScreen)
d3174 1
d3176 1
d3179 8
a3186 8
#ifdef XF86DRI
   if (pI830->directRenderingOpen) {
      if (pI830->mmModeFlags & I830_KERNEL_MM) {
#ifndef XSERVER_LIBDRM_MM
	 I830DrmMMTakedown(pI830->drmSubFD, DRM_BO_MEM_TT);
#else
	 drmMMTakedown(pI830->drmSubFD, DRM_BO_MEM_TT);	 
#endif
d3188 1
a3188 4
      pI830->directRenderingOpen = FALSE;
      I830DRICloseScreen(pScreen);
   }
#endif
a3189 2
   if (pScrn->vtSema == TRUE) {
      I830BIOSLeaveVT(scrnIndex, 0);
d3202 1
a3202 1
      pI830->ScanlineColorExpandBuffers = 0;
d3204 1
a3204 1

d3211 9
d3221 14
a3234 3
   if (pI830->CursorInfoRec) {
      xf86DestroyCursorInfoRec(pI830->CursorInfoRec);
      pI830->CursorInfoRec = 0;
d3236 1
a3242 6
      xfree(pI830->CursorMem);
      pI830->CursorMem = NULL;
      xfree(pI830->CursorMemARGB);
      pI830->CursorMemARGB = NULL;
      xfree(pI830->OverlayMem);
      pI830->OverlayMem = NULL;
d3245 2
a3246 2
      xfree(pI830->used3D);
      pI830->used3D = NULL;
a3338 9
      /* ACPI Toggle */
      pI830->toggleDevices = GetNextDisplayDeviceList(pScrn, 1);
      if (xf86IsEntityShared(pScrn->entityList[0])) {
         I830Ptr pI8302 = I830PTR(pI830->entityPrivate->pScrn_2);
         pI8302->toggleDevices = pI830->toggleDevices;
      }

      xf86DrvMsg(pScrn->scrnIndex, X_INFO, "ACPI Toggle to 0x%x\n",pI830->toggleDevices);

d3348 7
a3354 1
static int CountBits(int a)
d3356 21
a3376 2
   int i;
   int b = 0;
d3378 2
a3379 3
   for (i=0;i<8;i++) {
     if (a & (1<<i))
        b+=1;
a3380 2

   return b;
d3382 1
d3389 1
a3389 67
   int cloned = 0;

   if (pScrn->vtSema) {
      /* Check for monitor lid being closed/opened and act accordingly */
      CARD32 adjust;
      CARD32 temp = INREG(SWF0) & 0x0000FFFF;
      int fixup = 0;
      I830Ptr pI8301;
      I830Ptr pI8302 = NULL;

      if (I830IsPrimary(pScrn))
         pI8301 = pI830;
      else 
         pI8301 = I830PTR(pI830->entityPrivate->pScrn_1);

      if (xf86IsEntityShared(pScrn->entityList[0]))
         pI8302 = I830PTR(pI830->entityPrivate->pScrn_2);

      /* this avoids several BIOS calls if possible */
      if (pI830->monitorSwitch != temp || pI830->monitorSwitch != pI830->toggleDevices) {
         xf86DrvMsg(pScrn->scrnIndex, X_INFO, 
		    "Hotkey switch to 0x%lx.\n", (unsigned long) temp);

         if (pI830->AccelInfoRec && pI830->AccelInfoRec->NeedToSync) {
            (*pI830->AccelInfoRec->Sync)(pScrn);
            pI830->AccelInfoRec->NeedToSync = FALSE;
            if (xf86IsEntityShared(pScrn->entityList[0]))
               pI8302->AccelInfoRec->NeedToSync = FALSE;
         }

         GetAttachableDisplayDeviceList(pScrn);
         
	 pI8301->lastDevice0 = pI8301->lastDevice1;
         pI8301->lastDevice1 = pI8301->lastDevice2;
         pI8301->lastDevice2 = pI8301->monitorSwitch;

	 if (temp != pI8301->lastDevice1 && 
	     temp != pI8301->lastDevice2) {
            xf86DrvMsg(pScrn->scrnIndex, X_INFO, 
			"Detected three device configs.\n");
	 } else
         if (CountBits(temp & 0xff) > 1) {
            xf86DrvMsg(pScrn->scrnIndex, X_INFO, 
			"Detected cloned pipe mode (A).\n");
            if (xf86IsEntityShared(pScrn->entityList[0]) || pI830->Clone)
	       temp = pI8301->MonType2 << 8 | pI8301->MonType1;
         } else
         if (CountBits((temp & 0xff00) >> 8) > 1) {
            xf86DrvMsg(pScrn->scrnIndex, X_INFO, 
			"Detected cloned pipe mode (B).\n");
            if (xf86IsEntityShared(pScrn->entityList[0]) || pI830->Clone)
	       temp = pI8301->MonType2 << 8 | pI8301->MonType1;
         } else
         if (pI8301->lastDevice1 && pI8301->lastDevice2) {
            if ( ((pI8301->lastDevice1 & 0xFF00) == 0) && 
                 ((pI8301->lastDevice2 & 0x00FF) == 0) ) {
               xf86DrvMsg(pScrn->scrnIndex, X_INFO, 
			"Detected last devices (1).\n");
	       cloned = 1;
            } else if ( ((pI8301->lastDevice2 & 0xFF00) == 0) && 
                 ((pI8301->lastDevice1 & 0x00FF) == 0) ) {
               xf86DrvMsg(pScrn->scrnIndex, X_INFO, 
			"Detected last devices (2).\n");
	       cloned = 1;
            } else
               cloned = 0;
         }
d3391 2
a3392 120
         if (cloned &&
             ((CountBits(pI8301->lastDevice1 & 0xff) > 1) ||
             ((CountBits((pI8301->lastDevice1 & 0xff00) >> 8) > 1))) ) {
               xf86DrvMsg(pScrn->scrnIndex, X_INFO, 
			"Detected duplicate (1).\n");
               cloned = 0;
         } else
         if (cloned &&
             ((CountBits(pI8301->lastDevice2 & 0xff) > 1) ||
             ((CountBits((pI8301->lastDevice2 & 0xff00) >> 8) > 1))) ) {
               xf86DrvMsg(pScrn->scrnIndex, X_INFO, 
			"Detected duplicate (2).\n");
               cloned = 0;
         } 

         xf86DrvMsg(pScrn->scrnIndex, X_INFO, 
			"Requested display devices 0x%lx.\n", 
		    (unsigned long) temp);


         /* If the BIOS doesn't flip between CRT, LFP and CRT+LFP we fake
          * it here as it seems some just flip between CRT and LFP. Ugh!
          *
          * So this pushes them onto Pipe B and clones the displays, which
          * is what most BIOS' should be doing.
          *
          * Cloned pipe mode should only be done when running single head.
          */
         if (xf86IsEntityShared(pScrn->entityList[0])) {
            cloned = 0;

	    /* Some BIOS' don't realize we may be in true dual head mode.
	     * And only display the primary output on both when switching.
	     * We detect this here and cycle back to both pipes.
	     */
	    if ((pI830->lastDevice0 == temp) &&
                ((CountBits(pI8301->lastDevice2 & 0xff) > 1) ||
                ((CountBits((pI8301->lastDevice2 & 0xff00) >> 8) > 1))) ) {
               xf86DrvMsg(pScrn->scrnIndex, X_INFO, 
			"Detected cloned pipe mode when dual head on previous switch. (0x%x -> 0x%x)\n", (int)temp, pI8301->MonType2 << 8 | pI8301->MonType1);
	       temp = pI8301->MonType2 << 8 | pI8301->MonType1;
	    }
	    
	 }

         if (cloned) { 
            if (pI830->Clone)
               temp = pI8301->MonType2 << 8 | pI8301->MonType1;
	    else if (pI8301->lastDevice1 & 0xFF)
	       temp = pI8301->lastDevice1 << 8 | pI8301->lastDevice2;
            else
	       temp = pI8301->lastDevice2 << 8 | pI8301->lastDevice1;
         } 

         /* Jump to our next mode if we detect we've been here before */
         if (temp == pI8301->lastDevice1 || temp == pI8301->lastDevice2) {
             temp = GetToggleList(pScrn, 1);
             xf86DrvMsg(pScrn->scrnIndex, X_INFO, 
			"Detected duplicate devices. Toggling (0x%lx)\n", 
			(unsigned long) temp);
         }

         xf86DrvMsg(pScrn->scrnIndex, X_INFO, 
		"Detected display change operation (0x%x, 0x%x, 0x%lx).\n", 
                pI8301->lastDevice1, pI8301->lastDevice2, 
		    (unsigned long) temp);

         /* So that if we close on the wrong config, we restore correctly */
         pI830->specifiedMonitor = TRUE;

         if (!xf86IsEntityShared(pScrn->entityList[0])) {
            if ((temp & 0xFF00) && (temp & 0x00FF)) {
               pI830->Clone = TRUE;
               xf86DrvMsg(pScrn->scrnIndex, X_INFO, "Setting Clone mode\n");
            } else {
               pI830->Clone = FALSE;
               xf86DrvMsg(pScrn->scrnIndex, X_INFO, "Clearing Clone mode\n");
            }
         }

         {
            /* Turn Cursor off before switching */
            Bool on = pI830->cursorOn;
            if (pI830->CursorInfoRec && pI830->CursorInfoRec->HideCursor)
               pI830->CursorInfoRec->HideCursor(pScrn);
            pI830->cursorOn = on;
         }

         /* double check the display devices are what's configured and try
          * not to do it twice because of dual heads with the code above */
         if (!SetDisplayDevices(pScrn, temp)) {
            if ( cloned &&
                    ((CountBits(temp & 0xff) > 1) ||
                     (CountBits((temp & 0xff00) >> 8) > 1)) ) {
	       temp = pI8301->lastDevice2 | pI8301->lastDevice1;
               xf86DrvMsg(pScrn->scrnIndex, X_WARNING, "Cloning failed, "
			  "trying dual pipe clone mode (0x%lx)\n", 
			  (unsigned long) temp);
               if (!SetDisplayDevices(pScrn, temp))
                    xf86DrvMsg(pScrn->scrnIndex, X_WARNING, "Failed to switch "
 		    "to configured display devices (0x%lx).\n", 
			       (unsigned long) temp);
               else {
                 pI830->Clone = TRUE;
                 xf86DrvMsg(pScrn->scrnIndex, X_INFO, "Setting Clone mode\n");
               }
            }
         }

         pI8301->monitorSwitch = temp;
	 pI8301->operatingDevices = temp;
	 pI8301->toggleDevices = temp;

         if (xf86IsEntityShared(pScrn->entityList[0])) {
	    pI8302->operatingDevices = pI8301->operatingDevices;
            pI8302->monitorSwitch = pI8301->monitorSwitch;
	    pI8302->toggleDevices = pI8301->toggleDevices;
         }

         fixup = 1;
d3395 1
a3395 3
         xf86DrvMsg(pScrn->scrnIndex, X_INFO, 
			"ACPI _DGS queried devices is 0x%x, but probed is 0x%x monitorSwitch=0x%x\n", 
			pI830->toggleDevices, INREG(SWF0), pI830->monitorSwitch);
a3396 7
      } else {
         int offset = -1;
         if (I830IsPrimary(pScrn))
            offset = pI8301->FrontBuffer.Start + ((pScrn->frameY0 * pI830->displayWidth + pScrn->frameX0) * pI830->cpp);
         else {
            offset = pI8301->FrontBuffer2.Start + ((pScrn->frameY0 * pI830->displayWidth + pScrn->frameX0) * pI830->cpp);
	 }
d3398 20
a3417 11
         if (IS_I96X(pI830)) {
            if (pI830->pipe == 0)
               adjust = INREG(DSPASURF);
            else 
               adjust = INREG(DSPBSURF);
         } else {
            if (pI830->pipe == 0)
               adjust = INREG(DSPABASE);
            else 
               adjust = INREG(DSPBBASE);
         }
d3419 2
a3420 3
         if (adjust != offset) {
            xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
			                       "Fixing display offsets.\n");
d3422 4
a3425 3
            I830AdjustFrame(pScrn->pScreen->myNum, pScrn->frameX0, pScrn->frameY0, 0);
         }
      }
d3427 14
a3440 17
      if (fixup) {
         ScreenPtr   pCursorScreen;
         int x = 0, y = 0;

         pCursorScreen = miPointerCurrentScreen();
         if (pScrn->pScreen == pCursorScreen)
            miPointerPosition(&x, &y);

         /* Now, when we're single head, make sure we switch pipes */
         if (!(xf86IsEntityShared(pScrn->entityList[0]) || pI830->Clone) || cloned) {
            if (temp & 0xFF00)
               pI830->pipe = 1;
            else 
               pI830->pipe = 0;
	       xf86DrvMsg(pScrn->scrnIndex, X_INFO,
			 "Primary pipe is now %s.\n", pI830->pipe ? "B" : "A");
         } 
d3442 4
a3445 40
         pI830->currentMode = NULL;
         I830BIOSSwitchMode(pScrn->pScreen->myNum, pScrn->currentMode, 0);
         I830AdjustFrame(pScrn->pScreen->myNum, pScrn->frameX0, pScrn->frameY0, 0);

         if (xf86IsEntityShared(pScrn->entityList[0])) {
	    ScrnInfoPtr pScrn2;
            I830Ptr pI8302;

            if (I830IsPrimary(pScrn)) {
	       pScrn2 = pI830->entityPrivate->pScrn_2;
               pI8302 = I830PTR(pI830->entityPrivate->pScrn_2);
            } else {
	       pScrn2 = pI830->entityPrivate->pScrn_1;
               pI8302 = I830PTR(pI830->entityPrivate->pScrn_1);
            }

            if (pScrn2->pScreen == pCursorScreen)
               miPointerPosition(&x, &y);

            pI8302->currentMode = NULL;
            I830BIOSSwitchMode(pScrn2->pScreen->myNum, pScrn2->currentMode, 0);
            I830AdjustFrame(pScrn2->pScreen->myNum, pScrn2->frameX0, pScrn2->frameY0, 0);

 	    (*pScrn2->EnableDisableFBAccess) (pScrn2->pScreen->myNum, FALSE);
 	    (*pScrn2->EnableDisableFBAccess) (pScrn2->pScreen->myNum, TRUE);

            if (pScrn2->pScreen == pCursorScreen) {
               int sigstate = xf86BlockSIGIO ();
               miPointerWarpCursor(pScrn2->pScreen,x,y);

               /* xf86Info.currentScreen = pScrn->pScreen; */
               xf86UnblockSIGIO (sigstate);
               if (pI8302->CursorInfoRec && !pI8302->SWCursor && pI8302->cursorOn) {
                  pI8302->CursorInfoRec->HideCursor(pScrn);
	          xf86SetCursor(pScrn2->pScreen, pI830->pCurs, x, y);
                  pI8302->CursorInfoRec->ShowCursor(pScrn);
                  pI8302->cursorOn = TRUE;
               }
            }
	 }
d3447 8
a3454 17
 	 (*pScrn->EnableDisableFBAccess) (pScrn->pScreen->myNum, FALSE);
 	 (*pScrn->EnableDisableFBAccess) (pScrn->pScreen->myNum, TRUE);

         if (pScrn->pScreen == pCursorScreen) {
            int sigstate = xf86BlockSIGIO ();
            miPointerWarpCursor(pScrn->pScreen,x,y);

            /* xf86Info.currentScreen = pScrn->pScreen; */
            xf86UnblockSIGIO (sigstate);
            if (pI830->CursorInfoRec && !pI830->SWCursor && pI830->cursorOn) {
               pI830->CursorInfoRec->HideCursor(pScrn);
	       xf86SetCursor(pScrn->pScreen, pI830->pCurs, x, y);
               pI830->CursorInfoRec->ShowCursor(pScrn);
               pI830->cursorOn = TRUE;
            }
         }
      }
d3456 1
a3456 3

  
   return 1000;
d3462 7
a3468 7
   pScrn->PreInit = I830BIOSPreInit;
   pScrn->ScreenInit = I830BIOSScreenInit;
   pScrn->SwitchMode = I830BIOSSwitchMode;
   pScrn->AdjustFrame = I830AdjustFrame;
   pScrn->EnterVT = I830BIOSEnterVT;
   pScrn->LeaveVT = I830BIOSLeaveVT;
   pScrn->FreeScreen = I830BIOSFreeScreen;
@


1.1
log
@Initial revision
@
text
@d200 2
d223 1
d241 1
d275 3
a277 1
   OPTION_INTELXINERAMA
d305 2
d3114 1
a3114 1
   if (IS_I965G(pI830))
d3636 1
a3636 1
   if (IS_I965G(pI830)) 
d3836 22
d3880 3
d4081 3
d4194 2
a4195 1
      if (IS_I9XX(pI830)) {
a4199 3

   	 if (pI830->PciInfo->chipType == PCI_CHIP_E7221_G)
	    pI830->FbMapSize = 0x8000000;	/* 128MB aperture */
d4280 40
a4319 1
   }
d4976 1
a4976 1
   if (IS_I965G(pI830))
d5427 1
d5429 1
a5429 1
   if (!I830CheckDRIAvailable(pScrn))
d5431 5
d5477 1
d5479 1
d5491 7
a5497 1
	       if (pI830->MemoryAperture.Size < 0) {
d5525 1
d5527 1
d5540 5
d5553 1
d5566 10
d5735 1
a5735 1
      if (IS_I965G(pI830))
d5769 1
a5769 1
   if (IS_I965G(pI830)) {
d5807 1
a5807 1
   if (IS_I965G(pI830)) {
d5923 1
a5923 1
   if (IS_I965G(pI830)) {
d6038 1
a6038 1
   if (IS_I965G(pI830)) {
d6313 1
a6313 1
   { /* I965G ENABLE TILING */
d6321 1
a6321 1
   { /* I965G DISABLE TILING */
d6390 1
a6390 1
      if (IS_I965G(pI830)) {
d6404 1
a6404 1
      if (IS_I965G(pI830)) {
d6454 1
a6454 1
         if (IS_I965G(pI830)) {
d6477 1
a6477 1
            if (IS_I965G(pI830)) {
d6501 1
a6501 1
         if (IS_I965G(pI830)) {
d6522 1
a6522 1
         if (IS_I965G(pI830)) {
d6563 1
a6563 1
         if (IS_I965G(pI830)) {
d6670 1
a6670 1
   if (IS_I965G(pI830))
d7093 1
a7093 1
   if (pI830->noAccel)
d7109 1
a7109 1
   if (!IS_I965G(pI830))
d7118 81
d7641 2
a7642 2
      if (IS_I965G(pI830)) {
	 I830RandRInit(pScreen, RR_Rotate_0); /* only 0 degrees for I965G */
d7665 1
a7665 1
   if (IS_I965G(pI830)) {
d7706 42
d7751 1
d7801 1
a7801 1
         if (!IS_I965G(pI830)) {
d7808 1
a7808 1
         if (!IS_I965G(pI830)) {
d7818 1
a7818 1
      if (!IS_I965G(pI830)) {
d7825 1
a7825 1
      if (!IS_I965G(pI830)) {
d7905 7
a7911 1
   
d8366 8
d8434 1
a8434 1
	 !IS_I965G(pI830)) {
d8500 1
a8500 1
	 if (IS_I965G(pI830)) {
d8587 7
d8973 1
a8973 1
         if (IS_I965G(pI830)) {
@


1.1.1.1
log
@Importing xf86-video-i810 1.7.2
@
text
@@


1.1.1.2
log
@xf86-video-intel 1.7.3
@
text
@a199 2
#include <sys/ioctl.h>
#include <errno.h>
d271 1
a271 3
   OPTION_INTELXINERAMA,
   OPTION_INTELTEXPOOL,
   OPTION_INTELMMSIZE
a298 2
   {OPTION_INTELTEXPOOL,"Legacy3D",     OPTV_BOOLEAN,	{0},	FALSE},
   {OPTION_INTELMMSIZE, "AperTexSize",  OPTV_INTEGER,	{0},	FALSE},
a3827 22
#ifdef XF86DRI
static void 
I830ReduceMMSize(ScrnInfoPtr pScrn, unsigned long newSize,
		 const char *reason)
{
   I830Ptr pI830 = I830PTR(pScrn);

   newSize = ROUND_DOWN_TO(newSize, GTT_PAGE_SIZE);
   if (newSize / GTT_PAGE_SIZE > I830_MM_MINPAGES) {
      pI830->mmSize = newSize / 1024;
      xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
		 "DRM memory manager aperture size is reduced to %d kiB\n"
		 "\t%s\n", pI830->mmSize, reason);
   } else {
      xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
		 "DRM memory manager will be disabled\n\t%s\n", reason);
      pI830->mmSize = 0;
   }
}
#endif


a3849 3
#ifdef XF86DRI
   unsigned long savedMMSize;
#endif
d4246 1
a4246 40

      pI830->mmModeFlags = 0;

      if (!pI830->directRenderingDisabled) {
	 Bool tmp = FALSE;

	 if (IS_I965G(pI830))
	    pI830->mmModeFlags |= I830_KERNEL_TEX;

	 from = X_PROBED;
	 if (xf86GetOptValBool(pI830->Options, 
			       OPTION_INTELTEXPOOL, &tmp)) {
	    from = X_CONFIG;
	    if (tmp) {
	       pI830->mmModeFlags |= I830_KERNEL_TEX;
	    } else {
	       pI830->mmModeFlags &= ~I830_KERNEL_TEX;
	    }	       
	 }
	 if (from == X_CONFIG || 
	     (pI830->mmModeFlags & I830_KERNEL_TEX)) { 
	    xf86DrvMsg(pScrn->scrnIndex, from, 
		       "Will %stry to allocate texture pool "
		       "for old Mesa 3D driver.\n",
		       (pI830->mmModeFlags & I830_KERNEL_TEX) ? 
		       "" : "not ");
	 }
	 pI830->mmSize = I830_MM_MAXSIZE;
	 from = X_INFO;
	 if (xf86GetOptValInteger(pI830->Options, OPTION_INTELMMSIZE,
				  &(pI830->mmSize))) {
	    from = X_CONFIG;
	 }
	 xf86DrvMsg(pScrn->scrnIndex, from, 
		    "Will try to reserve %d kiB of AGP aperture space\n"
		    "\tfor the DRM memory manager.\n",
		    pI830->mmSize);
      }
   } 
   
a5353 1

d5355 1
a5355 1
   if (!I830CheckDRIAvailable(pScrn)) {
a5356 5
      pI830->mmSize = 0;
   } else if (pScrn->videoRam > pI830->FbMapSize / 1024 - pI830->mmSize) {
      I830ReduceMMSize(pScrn, pI830->FbMapSize - KB(pScrn->videoRam), 
		       "to make room for video memory");
   }
a5397 1
      savedMMSize = pI830->mmSize;
a5398 1
      retry_dryrun:
d5410 1
a5410 7
	       if (pI830->MemoryAperture.Size < 0) {		  
		  if (KB(pI830->mmSize) > I830_MM_MINPAGES * GTT_PAGE_SIZE) {
		     I830ReduceMMSize(pScrn, I830_MM_MINPAGES * GTT_PAGE_SIZE,
				      "to make room in AGP aperture for tiling.");
		     goto retry_dryrun;
		  }

a5437 1
	 pI830->mmSize = savedMMSize;
a5438 1
      retry_dryrun2:
a5450 5
		  if (KB(pI830->mmSize) > I830_MM_MINPAGES * GTT_PAGE_SIZE) {
		     I830ReduceMMSize(pScrn, I830_MM_MINPAGES * GTT_PAGE_SIZE,
				      "to save AGP aperture space for video memory.");
		     goto retry_dryrun2;
		  }
a5458 1
	       pI830->mmSize = 0;
a5470 10
   if (pScrn->displayWidth >= 4096) {
      xf86DrvMsg(pScrn->scrnIndex, X_ERROR, "Cannot support > 1024x768 in leftof/rightof configurations. disabling DRI.\n");
      pI830->directRenderingDisabled = TRUE;
   }

   if (pScrn->virtualY > 2048) {
      xf86DrvMsg(pScrn->scrnIndex, X_ERROR, "Cannot support > 2048 vertical lines. disabling acceleration.\n");
      pI830->noAccel = TRUE;
   }

a7012 81
#ifdef XF86DRI
#ifndef DRM_BO_MEM_TT
#error "Wrong drm.h file included. You need to compile and install a recent libdrm."
#endif

#ifndef XSERVER_LIBDRM_MM

static int
I830DrmMMInit(int drmFD, unsigned long pageOffs, unsigned long pageSize,
	      unsigned memType)
{

   drm_mm_init_arg_t arg;
   int ret;
   
   memset(&arg, 0, sizeof(arg));
   arg.req.op = mm_init;
   arg.req.p_offset = pageOffs;
   arg.req.p_size = pageSize;
   arg.req.mem_type = memType;

   ret = ioctl(drmFD, DRM_IOCTL_MM_INIT, &arg);
   
   if (ret)
      return -errno;
   
   return 0;
   
}

static int
I830DrmMMTakedown(int drmFD, unsigned memType)
{
   drm_mm_init_arg_t arg;
   int ret = 0;
   
   memset(&arg, 0, sizeof(arg));
   arg.req.op = mm_takedown;
   arg.req.mem_type = memType;
   if (ioctl(drmFD, DRM_IOCTL_MM_INIT, &arg)) {
      ret = -errno;
   }
   
   return ret;
}

static int I830DrmMMLock(int fd, unsigned memType)
{
    drm_mm_init_arg_t arg;
    int ret;

    memset(&arg, 0, sizeof(arg));
    arg.req.op = mm_lock;
    arg.req.mem_type = memType;

    do{
	ret = ioctl(fd, DRM_IOCTL_MM_INIT, &arg);
    } while (ret && errno == EAGAIN);
    
    return ret;	
}

static int I830DrmMMUnlock(int fd, unsigned memType)
{
    drm_mm_init_arg_t arg;
    int ret;

    memset(&arg, 0, sizeof(arg));
    arg.req.op = mm_unlock;
    arg.req.mem_type = memType;

    do{
	ret = ioctl(fd, DRM_IOCTL_MM_INIT, &arg);
    } while (ret && errno == EAGAIN);
    
    return ret;	
}

#endif
#endif

a7519 42

#ifdef XF86DRI
   if (pI830->directRenderingEnabled && (pI830->mmModeFlags & I830_KERNEL_MM)) {
      unsigned long aperEnd = ROUND_DOWN_TO(pI830->FbMapSize, GTT_PAGE_SIZE) 
	 / GTT_PAGE_SIZE;
      unsigned long aperStart = ROUND_TO(pI830->FbMapSize - KB(pI830->mmSize), GTT_PAGE_SIZE) 
	 / GTT_PAGE_SIZE;

      if (aperEnd < aperStart || aperEnd - aperStart < I830_MM_MINPAGES) {
	 xf86DrvMsg(pScrn->scrnIndex, X_ERROR, 
		    "Too little AGP aperture space for DRM memory manager.\n"
		    "\tPlease increase AGP aperture size from BIOS configuration screen\n"
		    "\tor decrease the amount of video RAM using option \"VideoRam\".\n"
		    "\tDisabling DRI.\n");
	 pI830->directRenderingOpen = FALSE;
	 I830DRICloseScreen(pScreen);
	 pI830->directRenderingEnabled = FALSE;
      } else {
#ifndef XSERVER_LIBDRM_MM
	 if (I830DrmMMInit(pI830->drmSubFD, aperStart, aperEnd - aperStart,
			   DRM_BO_MEM_TT)) {
#else
	 if (drmMMInit(pI830->drmSubFD, aperStart, aperEnd - aperStart,
		       DRM_BO_MEM_TT)) {
#endif	   
	    xf86DrvMsg(pScrn->scrnIndex, X_ERROR, 
		       "Could not initialize the DRM memory manager.\n");
	    
	    pI830->directRenderingOpen = FALSE;
	    I830DRICloseScreen(pScreen);
	    pI830->directRenderingEnabled = FALSE;
	 } else {
	    xf86DrvMsg(pScrn->scrnIndex, X_INFO, 
		       "Initialized DRM memory manager, %ld AGP pages\n"
		       "\tat AGP offset 0x%lx\n", 
		       aperEnd - aperStart,
		       aperStart);
	 }
      }
   }
#endif

a7522 1

d7676 1
a7676 7
      if (pI830->mmModeFlags & I830_KERNEL_MM) {
#ifndef XSERVER_LIBDRM_MM
	 I830DrmMMLock(pI830->drmSubFD, DRM_BO_MEM_TT);
#else
	 drmMMLock(pI830->drmSubFD, DRM_BO_MEM_TT);
#endif
      }
a8130 8
	 if (pI830->mmModeFlags & I830_KERNEL_MM) {
#ifndef XSERVER_LIBDRM_MM
	    I830DrmMMUnlock(pI830->drmSubFD, DRM_BO_MEM_TT);
#else
	    drmMMUnlock(pI830->drmSubFD, DRM_BO_MEM_TT);
#endif
	 }

a8343 7
      if (pI830->mmModeFlags & I830_KERNEL_MM) {
#ifndef XSERVER_LIBDRM_MM
	 I830DrmMMTakedown(pI830->drmSubFD, DRM_BO_MEM_TT);
#else
	 drmMMTakedown(pI830->drmSubFD, DRM_BO_MEM_TT);	 
#endif
      }
@


1.1.1.3
log
@Import xf86-video-i810 version 1.7.4
@
text
@d7090 1
a7090 1
   if (pI830->noAccel || !I830IsPrimary(pScrn))
@


1.1.1.4
log
@xf86-video-intel 2.2.0
@
text
@a167 1
#include <assert.h>
a171 3
#include <stdio.h>
#include <sys/mman.h>
#include <errno.h>
d193 4
a196 4
#include "i830_display.h"
#include "i830_debug.h"
#include "i830_bios.h"
#include "i830_video.h"
d201 1
a201 15
#ifdef XF86DRI_MM
#include "xf86mm.h"
#endif
#endif

#ifdef I830_USE_EXA
const char *I830exaSymbols[] = {
    "exaGetVersion",
    "exaDriverInit",
    "exaDriverFini",
    "exaOffscreenAlloc",
    "exaOffscreenFree",
    "exaWaitSync",
    NULL
};
d209 1
a209 1
static SymTabRec I830Chipsets[] = {
a218 1
   {PCI_CHIP_I945_GME,		"945GME"},
a222 5
   {PCI_CHIP_I965_GM,		"965GM"},
   {PCI_CHIP_I965_GME,		"965GME/GLE"},
   {PCI_CHIP_G33_G,		"G33"},
   {PCI_CHIP_Q35_G,		"Q35"},
   {PCI_CHIP_Q33_G,		"Q33"},
d226 1
a226 1
static PciChipsets I830PciChipsets[] = {
a235 1
   {PCI_CHIP_I945_GME,		PCI_CHIP_I945_GME,	RES_SHARED_VGA},
a239 5
   {PCI_CHIP_I965_GM,		PCI_CHIP_I965_GM,	RES_SHARED_VGA},
   {PCI_CHIP_I965_GME,		PCI_CHIP_I965_GME,	RES_SHARED_VGA},
   {PCI_CHIP_G33_G,		PCI_CHIP_G33_G,		RES_SHARED_VGA},
   {PCI_CHIP_Q35_G,		PCI_CHIP_Q35_G,		RES_SHARED_VGA},
   {PCI_CHIP_Q33_G,		PCI_CHIP_Q33_G,		RES_SHARED_VGA},
a249 3
#if defined(I830_USE_XAA) && defined(I830_USE_EXA)
   OPTION_ACCELMETHOD,
#endif
d258 6
d265 9
a273 4
   OPTION_MODEDEBUG,
   OPTION_FBC,
   OPTION_TILING,
#ifdef XF86DRI_MM
d275 1
a275 2
#endif
   OPTION_TRIPLEBUFFER,
d278 1
a278 4
static OptionInfoRec I830Options[] = {
#if defined(I830_USE_XAA) && defined(I830_USE_EXA)
   {OPTION_ACCELMETHOD,	"AccelMethod",	OPTV_ANYSTR,	{0},	FALSE},
#endif
d287 6
d294 9
a302 4
   {OPTION_MODEDEBUG,	"ModeDebug",	OPTV_BOOLEAN,	{0},	FALSE},
   {OPTION_FBC,		"FramebufferCompression", OPTV_BOOLEAN, {0}, TRUE},
   {OPTION_TILING,	"Tiling",	OPTV_BOOLEAN,	{0},	TRUE},
#ifdef XF86DRI_MM
d304 1
a304 2
#endif
   {OPTION_TRIPLEBUFFER, "TripleBuffer", OPTV_BOOLEAN,	{0},	FALSE},
d309 12
a320 8
const char *i830_output_type_names[] = {
   "Unused",
   "Analog",
   "DVO",
   "SDVO",
   "LVDS",
   "TVOUT",
};
d322 12
a333 6
static void i830AdjustFrame(int scrnIndex, int x, int y, int flags);
static Bool I830CloseScreen(int scrnIndex, ScreenPtr pScreen);
static Bool I830EnterVT(int scrnIndex, int flags);
static CARD32 I830CheckDevicesTimer(OsTimerPtr timer, CARD32 now, pointer arg);
static Bool SaveHWState(ScrnInfoPtr pScrn);
static Bool RestoreHWState(ScrnInfoPtr pScrn);
d338 3
d365 1
a365 1
/* Export I830 options to i830 driver where necessary */
d367 1
a367 1
I830AvailableOptions(int chipid, int busid)
d371 3
a373 3
   for (i = 0; I830PciChipsets[i].PCIid > 0; i++) {
      if (chipid == I830PciChipsets[i].PCIid)
	 return I830Options;
d379 1
a379 1
I830GetRec(ScrnInfoPtr pScrn)
d386 1
d391 1
a391 1
I830FreeRec(ScrnInfoPtr pScrn)
d394 2
d403 25
d433 8
a440 2
static void
I830ProbeDDC(ScrnInfoPtr pScrn, int index)
d442 43
a484 1
   vbeInfoPtr pVbe;
d486 1
a486 1
   /* The vbe module gets loaded in PreInit(), so no need to load it here. */
d488 1
a488 2
   pVbe = VBEInit(NULL, index);
   ConfiguredMonitor = vbeDoEDID(pVbe, NULL);
d491 3
a493 2
static int
I830DetectMemory(ScrnInfoPtr pScrn)
d495 1
a495 10
   I830Ptr pI830 = I830PTR(pScrn);
#if !XSERVER_LIBPCIACCESS
   PCITAG bridge;
#endif
   uint16_t gmch_ctrl;
   int memsize = 0, gtt_size;
   int range;
#if 0
   VbeInfoBlock *vbeInfo;
#endif
d497 6
a502 7
#if XSERVER_LIBPCIACCESS
   struct pci_device *bridge = intel_host_bridge ();
   pci_device_cfg_read_u16(bridge, & gmch_ctrl, I830_GMCH_CTRL);
#else
   bridge = pciTag(0, 0, 0);		/* This is always the host bridge */
   gmch_ctrl = pciReadWord(bridge, I830_GMCH_CTRL);
#endif
d504 2
a505 35
   if (IS_I965G(pI830)) {
      /* The 965 may have a GTT that is actually larger than is necessary
       * to cover the aperture, so check the hardware's reporting of the
       * GTT size.
       */
      switch (INREG(PGETBL_CTL) & PGETBL_SIZE_MASK) {
      case PGETBL_SIZE_512KB:
	 gtt_size = 512;
	 break;
      case PGETBL_SIZE_256KB:
	 gtt_size = 256;
	 break;
      case PGETBL_SIZE_128KB:
	 gtt_size = 128;
	 break;
      default:
	 FatalError("Unknown GTT size value: %08x\n", (int)INREG(PGETBL_CTL));
      }
   } else if (IS_G33CLASS(pI830)) {
      /* G33's GTT size is detect in GMCH_CTRL */
      switch (gmch_ctrl & G33_PGETBL_SIZE_MASK) {
      case G33_PGETBL_SIZE_1M:
	 gtt_size = 1024;
	 break;
      case G33_PGETBL_SIZE_2M:
	 gtt_size = 2048;
	 break;
      default:
	 FatalError("Unknown GTT size value: %08x\n",
		    (int)(gmch_ctrl & G33_PGETBL_SIZE_MASK));
      }
   } else {
      /* Older chipsets only had GTT appropriately sized for the aperture. */
      gtt_size = pI830->FbMapSize / (1024*1024);
   }
d507 2
a508 1
   xf86DrvMsg(pScrn->scrnIndex, X_INFO, "detected %d kB GTT.\n", gtt_size);
d510 2
a511 4
   /* The stolen memory has the GTT at the top, and the 4KB popup below that.
    * Everything else can be freely used by the graphics driver.
    */
   range = gtt_size + 4;
d513 2
a514 52
   if (IS_I85X(pI830) || IS_I865G(pI830) || IS_I9XX(pI830)) {
      switch (gmch_ctrl & I830_GMCH_GMS_MASK) {
      case I855_GMCH_GMS_STOLEN_1M:
	 memsize = MB(1) - KB(range);
	 break;
      case I855_GMCH_GMS_STOLEN_4M:
	 memsize = MB(4) - KB(range);
	 break;
      case I855_GMCH_GMS_STOLEN_8M:
	 memsize = MB(8) - KB(range);
	 break;
      case I855_GMCH_GMS_STOLEN_16M:
	 memsize = MB(16) - KB(range);
	 break;
      case I855_GMCH_GMS_STOLEN_32M:
	 memsize = MB(32) - KB(range);
	 break;
      case I915G_GMCH_GMS_STOLEN_48M:
	 if (IS_I9XX(pI830))
	    memsize = MB(48) - KB(range);
	 break;
      case I915G_GMCH_GMS_STOLEN_64M:
	 if (IS_I9XX(pI830))
	    memsize = MB(64) - KB(range);
	 break;
      case G33_GMCH_GMS_STOLEN_128M:
	 if (IS_G33CLASS(pI830))
	     memsize = MB(128) - KB(range);
	 break;
      case G33_GMCH_GMS_STOLEN_256M:
	 if (IS_G33CLASS(pI830))
	     memsize = MB(256) - KB(range);
	 break;
      }
   } else {
      switch (gmch_ctrl & I830_GMCH_GMS_MASK) {
      case I830_GMCH_GMS_STOLEN_512:
	 memsize = KB(512) - KB(range);
	 break;
      case I830_GMCH_GMS_STOLEN_1024:
	 memsize = MB(1) - KB(range);
	 break;
      case I830_GMCH_GMS_STOLEN_8192:
	 memsize = MB(8) - KB(range);
	 break;
      case I830_GMCH_GMS_LOCAL:
	 memsize = 0;
	 xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
		    "Local memory found, but won't be used.\n");
	 break;
      }
   }
d516 2
a517 4
#if 0
   /* And 64KB page aligned */
   memsize &= ~0xFFFF;
#endif
d519 1
a519 6
   if (memsize > 0) {
      xf86DrvMsg(pScrn->scrnIndex, X_INFO,
		 "detected %d kB stolen memory.\n", memsize / 1024);
   } else {
      xf86DrvMsg(pScrn->scrnIndex, X_INFO, "no video memory detected.\n");
   }
d521 1
a521 1
   return memsize;
d524 103
a626 10
static Bool
I830MapMMIO(ScrnInfoPtr pScrn)
{
#if XSERVER_LIBPCIACCESS
   int err;
   struct pci_device *device;
#else
   int mmioFlags;
#endif
   I830Ptr pI830 = I830PTR(pScrn);
d628 2
a629 15
#if XSERVER_LIBPCIACCESS
   device = pI830->PciInfo;
   err = pci_device_map_range (device,
			       pI830->MMIOAddr,
			       I810_REG_SIZE,
			       PCI_DEV_MAP_FLAG_WRITABLE,
			       (void **) &pI830->MMIOBase);
   if (err) 
   {
      xf86DrvMsg (pScrn->scrnIndex, X_ERROR,
		  "Unable to map mmio range. %s (%d)\n",
		  strerror (err), err);
      return FALSE;
   }
#else
d631 14
a644 5
#if !defined(__alpha__)
   mmioFlags = VIDMEM_MMIO | VIDMEM_READSIDEEFFECT;
#else
   mmioFlags = VIDMEM_MMIO | VIDMEM_READSIDEEFFECT | VIDMEM_SPARSE;
#endif
d646 5
a650 6
   pI830->MMIOBase = xf86MapPciMem(pScrn->scrnIndex, mmioFlags,
				   pI830->PciTag,
				   pI830->MMIOAddr, I810_REG_SIZE);
   if (!pI830->MMIOBase)
      return FALSE;
#endif
d652 14
a665 42
   /* Set up the GTT mapping for the various places it has been moved over
    * time.
    */
   if (IS_I9XX(pI830)) {
      CARD32   gttaddr;
      
      if (IS_I965G(pI830)) 
      {
	 gttaddr = pI830->MMIOAddr + (512 * 1024);
	 pI830->GTTMapSize = 512 * 1024;
      }
      else
      {
	 gttaddr = I810_MEMBASE(pI830->PciInfo, 3) & 0xFFFFFF00;
	 pI830->GTTMapSize = pI830->FbMapSize / 1024;
      }
#if XSERVER_LIBPCIACCESS
      err = pci_device_map_range (device,
				  gttaddr, pI830->GTTMapSize,
				  PCI_DEV_MAP_FLAG_WRITABLE,
				  (void **) &pI830->GTTBase);
      if (err)
      {
	 xf86DrvMsg (pScrn->scrnIndex, X_ERROR,
		     "Unable to map GTT range. %s (%d)\n",
		     strerror (err), err);
	 return FALSE;
      }
#else
      pI830->GTTBase = xf86MapPciMem(pScrn->scrnIndex, mmioFlags,
				     pI830->PciTag,
				     gttaddr, pI830->GTTMapSize);
      if (pI830->GTTBase == NULL)
	 return FALSE;
#endif
   } else {
      /* The GTT aperture on i830 is write-only.  We could probably map the
       * actual physical pages that back it, but leave it alone for now.
       */
      pI830->GTTBase = NULL;
      pI830->GTTMapSize = 0;
   }
d667 1
a667 1
   return TRUE;
d670 5
a674 2
static Bool
I830MapMem(ScrnInfoPtr pScrn)
d676 31
a706 6
   I830Ptr pI830 = I830PTR(pScrn);
   long i;
#if XSERVER_LIBPCIACCESS
   struct pci_device *const device = pI830->PciInfo;
   int err;
#endif
d708 41
a748 2
   for (i = 2; i < pI830->FbMapSize; i <<= 1) ;
   pI830->FbMapSize = i;
d750 19
a768 2
   if (!I830MapMMIO(pScrn))
      return FALSE;
d770 14
a783 11
#if XSERVER_LIBPCIACCESS
   err = pci_device_map_range (device, pI830->LinearAddr, pI830->FbMapSize,
			       PCI_DEV_MAP_FLAG_WRITABLE | PCI_DEV_MAP_FLAG_WRITE_COMBINE,
			       (void **) &pI830->FbBase);
#else
   pI830->FbBase = xf86MapPciMem(pScrn->scrnIndex, VIDMEM_FRAMEBUFFER,
				 pI830->PciTag,
				 pI830->LinearAddr, pI830->FbMapSize);
   if (!pI830->FbBase)
      return FALSE;
#endif
d785 4
a788 4
   if (I830IsPrimary(pScrn) && pI830->LpRing->mem != NULL) {
      pI830->LpRing->virtual_start =
	 pI830->FbBase + pI830->LpRing->mem->offset;
   }
d790 3
a792 8
   /* Mark the pages we haven't yet bound into AGP as inaccessible. */
   if (pI830->FbMapSize > pI830->stolen_size) {
      if (mprotect(pI830->FbBase + pI830->stolen_size,
		   pI830->FbMapSize - pI830->stolen_size, PROT_NONE) != 0) {
	 xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
		    "Failed to mprotect unbound AGP: %s\n", strerror(errno));
      }
   }
d794 1
a794 1
   return TRUE;
d797 101
a897 4
static void
I830UnmapMMIO(ScrnInfoPtr pScrn)
{
   I830Ptr pI830 = I830PTR(pScrn);
d899 1
a899 7
#if XSERVER_LIBPCIACCESS
   pci_device_unmap_range (pI830->PciInfo, pI830->MMIOBase, I810_REG_SIZE);
#else
   xf86UnMapVidMem(pScrn->scrnIndex, (pointer) pI830->MMIOBase,
		   I810_REG_SIZE);
#endif
   pI830->MMIOBase = NULL;
d901 3
a903 8
   if (IS_I9XX(pI830)) {
#if XSERVER_LIBPCIACCESS
      pci_device_unmap_range (pI830->PciInfo, pI830->GTTBase, pI830->GTTMapSize);
#else
      xf86UnMapVidMem(pScrn->scrnIndex, pI830->GTTBase, pI830->GTTMapSize);
#endif
      pI830->GTTBase = NULL;
   }
d906 4
a909 2
static Bool
I830UnmapMem(ScrnInfoPtr pScrn)
d913 11
a923 9
#if XSERVER_LIBPCIACCESS
   pci_device_unmap_range (pI830->PciInfo, pI830->FbBase, pI830->FbMapSize);
#else
   xf86UnMapVidMem(pScrn->scrnIndex, (pointer) pI830->FbBase,
		   pI830->FbMapSize);
#endif
   pI830->FbBase = NULL;
   I830UnmapMMIO(pScrn);
   return TRUE;
d927 1
a927 2
I830LoadPalette(ScrnInfoPtr pScrn, int numColors, int *indices,
		LOCO * colors, VisualPtr pVisual)
d929 53
a981 4
   xf86CrtcConfigPtr   xf86_config = XF86_CRTC_CONFIG_PTR(pScrn);
   int i,j, index;
   int p;
   CARD16 lut_r[256], lut_g[256], lut_b[256];
d983 11
a993 1
   DPRINTF(PFX, "I830LoadPalette: numColors: %d\n", numColors);
a994 10
   for(p = 0; p < xf86_config->num_crtc; p++) {
      xf86CrtcPtr	   crtc = xf86_config->crtc[p];
      I830CrtcPrivatePtr   intel_crtc = crtc->driver_private;

      /* Initialize to the old lookup table values. */
      for (i = 0; i < 256; i++) {
	 lut_r[i] = intel_crtc->lut_r[i] << 8;
	 lut_g[i] = intel_crtc->lut_g[i] << 8;
	 lut_b[i] = intel_crtc->lut_b[i] << 8;
      }
d996 121
a1116 14
      switch(pScrn->depth) {
      case 15:
	 for (i = 0; i < numColors; i++) {
	    index = indices[i];
	    for (j = 0; j < 8; j++) {
	       lut_r[index * 8 + j] = colors[index].red << 8;
	       lut_g[index * 8 + j] = colors[index].green << 8;
	       lut_b[index * 8 + j] = colors[index].blue << 8;
	    }
         }
	 break;
      case 16:
	 for (i = 0; i < numColors; i++) {
	    index = indices[i];
d1118 1
a1118 6
	    if (index <= 31) {
	       for (j = 0; j < 8; j++) {
		  lut_r[index * 8 + j] = colors[index].red << 8;
		  lut_b[index * 8 + j] = colors[index].blue << 8;
	       }
	    }
d1120 118
a1237 14
	    for (j = 0; j < 4; j++) {
	       lut_g[index * 4 + j] = colors[index].green << 8;
	    }
         }
        break;
      default:
	 for (i = 0; i < numColors; i++) {
	    index = indices[i];
	    lut_r[index] = colors[index].red << 8;
	    lut_g[index] = colors[index].green << 8;
	    lut_b[index] = colors[index].blue << 8;
	 }
	 break;
      }
d1239 14
a1252 7
      /* Make the change through RandR */
#ifdef RANDR_12_INTERFACE
      RRCrtcGammaSet(crtc->randr_crtc, lut_r, lut_g, lut_b);
#else
      crtc->funcs->gamma_set(crtc, lut_r, lut_g, lut_b, 256);
#endif
   }
d1256 1
a1256 1
i830_update_front_offset(ScrnInfoPtr pScrn)
d1258 27
a1284 2
   ScreenPtr pScreen = pScrn->pScreen;
   I830Ptr pI830 = I830PTR(pScrn);
d1286 33
a1318 4
   /* Update buffer locations, which may have changed as a result of
    * i830_bind_all_memory().
    */
   pScrn->fbOffset = pI830->front_buffer->offset;
d1320 17
a1336 10
   /* If we are still in ScreenInit, there is no screen pixmap to be updated
    * yet.  We'll fix it up at CreateScreenResources.
    */
   if (!pI830->starting) {
      if (!pScreen->ModifyPixmapHeader(pScreen->GetScreenPixmap(pScreen),
				       -1, -1, -1, -1, -1,
				       (pointer)(pI830->FbBase +
						 pScrn->fbOffset)))
       FatalError("Couldn't adjust screen pixmap\n");
   }
d1339 3
a1341 8
/**
 * Adjust the screen pixmap for the current location of the front buffer.
 * This is done at EnterVT when buffers are bound as long as the resources
 * have already been created, but the first EnterVT happens before
 * CreateScreenResources.
 */
static Bool
i830CreateScreenResources(ScreenPtr pScreen)
d1343 330
a1672 2
   ScrnInfoPtr pScrn = xf86Screens[pScreen->myNum];
   I830Ptr pI830 = I830PTR(pScrn);
d1674 12
a1685 3
   pScreen->CreateScreenResources = pI830->CreateScreenResources;
   if (!(*pScreen->CreateScreenResources)(pScreen))
      return FALSE;
d1687 11
a1697 1
   i830_update_front_offset(pScrn);
d1699 29
a1727 1
   return TRUE;
d1730 2
d1733 1
a1733 1
i830_output_clones (ScrnInfoPtr pScrn, int type_mask)
d1735 2
a1736 3
    xf86CrtcConfigPtr	config = XF86_CRTC_CONFIG_PTR (pScrn);
    int			o;
    int			index_mask = 0;
d1738 11
a1748 6
    for (o = 0; o < config->num_output; o++)
    {
	xf86OutputPtr		output = config->output[o];
	I830OutputPrivatePtr	intel_output = output->driver_private;
	if (type_mask & (1 << intel_output->type))
	    index_mask |= (1 << o);
d1750 2
a1751 1
    return index_mask;
d1754 2
a1755 8
/**
 * Set up the outputs according to what type of chip we are.
 *
 * Some outputs may not initialize, due to allocation failure or because a
 * controller chip isn't found.
 */
static void
I830SetupOutputs(ScrnInfoPtr pScrn)
d1757 21
a1777 4
   xf86CrtcConfigPtr	config = XF86_CRTC_CONFIG_PTR (pScrn);
   I830Ptr  pI830 = I830PTR(pScrn);
   int	    o, c;
   Bool	    lvds_detected = FALSE;
d1779 24
a1802 2
   /* everyone has at least a single analog output */
   i830_crt_init(pScrn);
d1804 26
a1829 3
   /* Set up integrated LVDS */
   if (IS_MOBILE(pI830) && !IS_I830(pI830))
      i830_lvds_init(pScrn);
d1831 4
a1834 14
   if (IS_I9XX(pI830)) {
      i830_sdvo_init(pScrn, SDVOB);
      i830_sdvo_init(pScrn, SDVOC);
   } else {
      i830_dvo_init(pScrn);
   }
   if (IS_I9XX(pI830) && !IS_I915G(pI830))
      i830_tv_init(pScrn);
   
   for (o = 0; o < config->num_output; o++)
   {
      xf86OutputPtr	   output = config->output[o];
      I830OutputPrivatePtr intel_output = output->driver_private;
      int		   crtc_mask;
d1836 1
a1836 8
      if (intel_output->type == I830_OUTPUT_LVDS)
	  lvds_detected = TRUE;
      
      crtc_mask = 0;
      for (c = 0; c < config->num_crtc; c++)
      {
	 xf86CrtcPtr	      crtc = config->crtc[c];
	 I830CrtcPrivatePtr   intel_crtc = crtc->driver_private;
d1838 12
a1849 6
	 if (intel_output->pipe_mask & (1 << intel_crtc->pipe))
	    crtc_mask |= (1 << c);
      }
      output->possible_crtcs = crtc_mask;
      output->possible_clones = i830_output_clones (pScrn, intel_output->clone_mask);
   }
d1852 2
a1853 2
static int
I830LVDSPresent(ScrnInfoPtr pScrn)
d1855 3
a1857 2
   xf86CrtcConfigPtr config = XF86_CRTC_CONFIG_PTR (pScrn);
   int o, lvds_detected = FALSE;
d1859 11
a1869 3
   for (o = 0; o < config->num_output; o++) {
      xf86OutputPtr	   output = config->output[o];
      I830OutputPrivatePtr intel_output = output->driver_private;
d1871 19
a1889 3
      if (intel_output->type == I830_OUTPUT_LVDS)
	  lvds_detected = TRUE;
   }
d1891 1
a1891 1
   return lvds_detected;
a1892 3
/**
 * Setup the CRTCs
 */
d1894 2
a1895 3

static void 
I830PreInitDDC(ScrnInfoPtr pScrn)
d1897 17
a1913 1
   I830Ptr pI830 = I830PTR(pScrn);
d1915 1
a1915 6
   if (!xf86LoadSubModule(pScrn, "ddc")) {
      pI830->ddc2 = FALSE;
   } else {
      xf86LoaderReqSymLists(I810ddcSymbols, NULL);
      pI830->ddc2 = TRUE;
   }
d1917 9
a1925 5
   /* DDC can use I2C bus */
   /* Load I2C if we have the code to use it */
   if (pI830->ddc2) {
      if (xf86LoadSubModule(pScrn, "i2c")) {
	 xf86LoaderReqSymLists(I810i2cSymbols, NULL);
d1927 8
a1934 5
	 pI830->ddc2 = TRUE;
      } else {
	 pI830->ddc2 = FALSE;
      }
   }
d1937 2
a1938 2
static void
PreInitCleanup(ScrnInfoPtr pScrn)
d1940 6
a1945 1
   I830Ptr pI830 = I830PTR(pScrn);
d1947 8
a1954 14
   if (I830IsPrimary(pScrn)) {
      if (pI830->entityPrivate)
	 pI830->entityPrivate->pScrn_1 = NULL;
   } else {
      if (pI830->entityPrivate)
         pI830->entityPrivate->pScrn_2 = NULL;
   }
   if (pI830->swfSaved) {
      OUTREG(SWF0, pI830->saveSWF0);
      OUTREG(SWF4, pI830->saveSWF4);
   }
   if (pI830->MMIOBase)
      I830UnmapMMIO(pScrn);
   I830FreeRec(pScrn);
d1957 2
a1958 2
Bool
I830IsPrimary(ScrnInfoPtr pScrn)
d1960 6
a1965 1
   I830Ptr pI830 = I830PTR(pScrn);
d1967 8
a1974 6
   if (xf86IsEntityShared(pScrn->entityList[0])) {
	if (pI830->init == 0) return TRUE;
	else return FALSE;
   }

   return TRUE;
d1977 2
a1978 2
static Bool
i830_xf86crtc_resize (ScrnInfoPtr scrn, int width, int height)
d1980 16
a1995 3
    scrn->virtualX = width;
    scrn->virtualY = height;
    return TRUE;
a1997 15
static const xf86CrtcConfigFuncsRec i830_xf86crtc_config_funcs = {
    i830_xf86crtc_resize
};

#define HOTKEY_BIOS_SWITCH	0
#define HOTKEY_DRIVER_NOTIFY	1

/**
 * Controls the BIOS's behavior on hotkey switch.
 *
 * If the mode is HOTKEY_BIOS_SWITCH, the BIOS will be set to do a mode switch
 * on its own and update the state in the scratch register.
 * If the mode is HOTKEY_DRIVER_NOTIFY, the BIOS won't do a mode switch and
 * will just update the state to represent what it would have been switched to.
 */
d1999 1
a1999 1
i830SetHotkeyControl(ScrnInfoPtr pScrn, int mode)
d2001 5
a2005 9
   I830Ptr pI830 = I830PTR(pScrn);
   CARD8 gr18;

   gr18 = pI830->readControl(pI830, GRX, 0x18);
   if (mode == HOTKEY_BIOS_SWITCH)
      gr18 &= ~HOTKEY_VBIOS_SWITCH_BLOCK;
   else
      gr18 |= HOTKEY_VBIOS_SWITCH_BLOCK;
   pI830->writeControl(pI830, GRX, 0x18, gr18);
d2008 2
a2009 9
/**
 * This is called per zaphod head (so usually just once) to do initialization
 * before the Screen is created.
 *
 * This code generally covers probing, module loading, option handling
 * card mapping, and RandR setup.
 */
static Bool
I830PreInit(ScrnInfoPtr pScrn, int flags)
d2011 2
a2012 16
   xf86CrtcConfigPtr   xf86_config;
   vgaHWPtr hwp;
   I830Ptr pI830;
   MessageType from = X_PROBED;
   rgb defaultWeight = { 0, 0, 0 };
   EntityInfoPtr pEnt;
   I830EntPtr pI830Ent = NULL;					
   int flags24;
   int i;
   char *s;
   pointer pVBEModule = NULL;
   const char *chipname;
   int num_pipe;
   int max_width, max_height;
   uint32_t	capid;
   int fb_bar, mmio_bar;
d2014 1
a2014 2
   if (pScrn->numEntities != 1)
      return FALSE;
d2016 5
a2020 4
   /* Load int10 module */
   if (!xf86LoadSubModule(pScrn, "int10"))
      return FALSE;
   xf86LoaderReqSymLists(I810int10Symbols, NULL);
d2022 9
a2030 4
   /* Load vbe module */
   if (!(pVBEModule = xf86LoadSubModule(pScrn, "vbe")))
      return FALSE;
   xf86LoaderReqSymLists(I810vbeSymbols, NULL);
d2032 6
a2037 1
   pEnt = xf86GetEntityInfo(pScrn->entityList[0]);
d2039 1
a2039 4
   if (flags & PROBE_DETECT) {
      I830ProbeDDC(pScrn, pEnt->index);
      return TRUE;
   }
d2041 1
a2041 4
   /* The vgahw module should be loaded here when needed */
   if (!xf86LoadSubModule(pScrn, "vgahw"))
      return FALSE;
   xf86LoaderReqSymLists(I810vgahwSymbols, NULL);
d2043 5
a2047 3
   /* Allocate a vgaHWRec */
   if (!vgaHWGetHWRec(pScrn))
      return FALSE;
d2049 1
a2049 3
   /* Allocate driverPrivate */
   if (!I830GetRec(pScrn))
      return FALSE;
d2051 2
a2052 3
   pI830 = I830PTR(pScrn);
   pI830->SaveGeneration = -1;
   pI830->pEnt = pEnt;
d2054 3
a2056 1
   pScrn->displayWidth = 640; /* default it */
d2058 7
a2064 2
   if (pI830->pEnt->location.type != BUS_PCI)
      return FALSE;
d2066 2
a2067 5
   pI830->PciInfo = xf86GetPciInfoForEntity(pI830->pEnt->index);
#if !XSERVER_LIBPCIACCESS
   pI830->PciTag = pciTag(pI830->PciInfo->bus, pI830->PciInfo->device,
			  pI830->PciInfo->func);
#endif
d2069 2
a2070 7
    /* Allocate an entity private if necessary */
    if (xf86IsEntityShared(pScrn->entityList[0])) {
	pI830Ent = xf86GetEntityPrivate(pScrn->entityList[0],
					I830EntityIndex)->ptr;
        pI830->entityPrivate = pI830Ent;
    } else 
        pI830->entityPrivate = NULL;
d2072 2
a2073 4
   if (xf86RegisterResources(pI830->pEnt->index, NULL, ResNone)) {
      PreInitCleanup(pScrn);
      return FALSE;
   }
d2075 3700
a5774 3
   if (xf86IsEntityShared(pScrn->entityList[0])) {
      if (xf86IsPrimInitDone(pScrn->entityList[0])) {
	 pI830->init = 1;
d5776 7
a5782 8
         if (!pI830Ent->pScrn_1) {
            xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
 		 "Failed to setup second head due to primary head failure.\n");
	    return FALSE;
         }
      } else {
         xf86SetPrimInitDone(pScrn->entityList[0]);
	 pI830->init = 0;
d5785 16
d5802 16
a5817 6
   if (xf86IsEntityShared(pScrn->entityList[0])) {
      if (!I830IsPrimary(pScrn)) {
         pI830Ent->pScrn_2 = pScrn;
      } else {
         pI830Ent->pScrn_1 = pScrn;
         pI830Ent->pScrn_2 = NULL;
d5820 9
d5830 7
a5836 4
   pScrn->racMemFlags = RAC_FB | RAC_COLORMAP;
   pScrn->monitor = pScrn->confScreen->monitor;
   pScrn->progClock = TRUE;
   pScrn->rgbBits = 8;
d5838 3
a5840 1
   flags24 = Support32bppFb | PreferConvert24to32 | SupportConvert24to32;
d5842 9
a5850 2
   if (!xf86SetDepthBpp(pScrn, 0, 0, 0, flags24))
      return FALSE;
d5852 2
a5853 7
   switch (pScrn->depth) {
   case 8:
   case 15:
   case 16:
   case 24:
      break;
   default:
d5855 3
a5857 3
		 "Given depth (%d) is not supported by I830 driver\n",
		 pScrn->depth);
      return FALSE;
d5859 41
a5899 1
   xf86PrintDepthBpp(pScrn);
d5901 1
a5901 4
   if (!xf86SetWeight(pScrn, defaultWeight, defaultWeight))
      return FALSE;
   if (!xf86SetDefaultVisual(pScrn, -1))
      return FALSE;
d5903 11
a5913 2
   hwp = VGAHWPTR(pScrn);
   pI830->cpp = pScrn->bitsPerPixel / 8;
d5915 2
a5916 1
   pI830->preinit = TRUE;
d5918 1
a5918 6
   /* Process the options */
   xf86CollectOptions(pScrn, NULL);
   if (!(pI830->Options = xalloc(sizeof(I830Options))))
      return FALSE;
   memcpy(pI830->Options, I830Options, sizeof(I830Options));
   xf86ProcessOptions(pScrn->scrnIndex, pScrn->options, pI830->Options);
d5920 3
a5922 4
   if (xf86ReturnOptValBool(pI830->Options, OPTION_MODEDEBUG, FALSE)) {
      pI830->debug_modes = TRUE;
   } else {
      pI830->debug_modes = FALSE;
d5925 14
a5938 2
   /* We have to use PIO to probe, because we haven't mapped yet. */
   I830SetPIOAccess(pI830);
d5940 5
a5944 33
   switch (DEVICE_ID(pI830->PciInfo)) {
   case PCI_CHIP_I830_M:
      chipname = "830M";
      break;
   case PCI_CHIP_845_G:
      chipname = "845G";
      break;
   case PCI_CHIP_I855_GM:
      /* Check capid register to find the chipset variant */
#if XSERVER_LIBPCIACCESS
      pci_device_cfg_read_u32 (pI830->PciInfo, &capid, I85X_CAPID);
#else
      capid = pciReadLong (pI830->PciTag, I85X_CAPID);
#endif
      pI830->variant = (capid >> I85X_VARIANT_SHIFT) & I85X_VARIANT_MASK;
      switch (pI830->variant) {
      case I855_GM:
	 chipname = "855GM";
	 break;
      case I855_GME:
	 chipname = "855GME";
	 break;
      case I852_GM:
	 chipname = "852GM";
	 break;
      case I852_GME:
	 chipname = "852GME";
	 break;
      default:
	 xf86DrvMsg(pScrn->scrnIndex, X_INFO,
		    "Unknown 852GM/855GM variant: 0x%x)\n", pI830->variant);
	 chipname = "852GM/855GM (unknown variant)";
	 break;
d5946 4
a5949 50
      break;
   case PCI_CHIP_I865_G:
      chipname = "865G";
      break;
   case PCI_CHIP_I915_G:
      chipname = "915G";
      break;
   case PCI_CHIP_E7221_G:
      chipname = "E7221 (i915)";
      break;
   case PCI_CHIP_I915_GM:
      chipname = "915GM";
      break;
   case PCI_CHIP_I945_G:
      chipname = "945G";
      break;
   case PCI_CHIP_I945_GM:
      chipname = "945GM";
      break;
   case PCI_CHIP_I945_GME:
      chipname = "945GME";
      break;
   case PCI_CHIP_I965_G:
   case PCI_CHIP_I965_G_1:
      chipname = "965G";
      break;
   case PCI_CHIP_I965_Q:
      chipname = "965Q";
      break;
   case PCI_CHIP_I946_GZ:
      chipname = "946GZ";
      break;
   case PCI_CHIP_I965_GM:
      chipname = "965GM";
      break;
   case PCI_CHIP_I965_GME:
      chipname = "965GME/GLE";
      break;
   case PCI_CHIP_G33_G:
      chipname = "G33";
      break;
   case PCI_CHIP_Q35_G:
      chipname = "Q35";
      break;
   case PCI_CHIP_Q33_G:
      chipname = "Q33";
      break;
   default:
      chipname = "unknown chipset";
      break;
a5950 2
   xf86DrvMsg(pScrn->scrnIndex, X_INFO,
	      "Integrated Graphics Chipset: Intel(R) %s\n", chipname);
d5952 6
a5957 15
   /* Set the Chipset and ChipRev, allowing config file entries to override. */
   if (pI830->pEnt->device->chipset && *pI830->pEnt->device->chipset) {
      pScrn->chipset = pI830->pEnt->device->chipset;
      from = X_CONFIG;
   } else if (pI830->pEnt->device->chipID >= 0) {
      pScrn->chipset = (char *)xf86TokenToString(I830Chipsets,
						 pI830->pEnt->device->chipID);
      from = X_CONFIG;
      xf86DrvMsg(pScrn->scrnIndex, X_CONFIG, "ChipID override: 0x%04X\n",
		 pI830->pEnt->device->chipID);
      DEVICE_ID(pI830->PciInfo) = pI830->pEnt->device->chipID;
   } else {
      from = X_PROBED;
      pScrn->chipset = (char *)xf86TokenToString(I830Chipsets,
						 DEVICE_ID(pI830->PciInfo));
d5960 14
a5973 4
   if (pI830->pEnt->device->chipRev >= 0) {
      xf86DrvMsg(pScrn->scrnIndex, X_CONFIG, "ChipRev override: %d\n",
		 pI830->pEnt->device->chipRev);
   }
d5975 1
a5975 2
   xf86DrvMsg(pScrn->scrnIndex, from, "Chipset: \"%s\"\n",
	      (pScrn->chipset != NULL) ? pScrn->chipset : "Unknown i8xx");
d5977 2
a5978 5
   if (IS_I9XX(pI830))
   {
      fb_bar = 2;
      mmio_bar = 0;
   }
d5980 11
a5990 4
   {
      fb_bar = 0;
      mmio_bar = 1;
   }
d5992 16
a6007 10
   if (pI830->pEnt->device->MemBase != 0) {
      pI830->LinearAddr = pI830->pEnt->device->MemBase;
      from = X_CONFIG;
   } else {
      pI830->LinearAddr = I810_MEMBASE (pI830->PciInfo, fb_bar);
      if (pI830->LinearAddr == 0) {
	 xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
		    "No valid FB address in PCI config space\n");
	 PreInitCleanup(pScrn);
	 return FALSE;
d6009 7
d6017 8
a6024 14

   xf86DrvMsg(pScrn->scrnIndex, from, "Linear framebuffer at 0x%lX\n",
	      (unsigned long)pI830->LinearAddr);

   if (pI830->pEnt->device->IOBase != 0) {
      pI830->MMIOAddr = pI830->pEnt->device->IOBase;
      from = X_CONFIG;
   } else {
      pI830->MMIOAddr = I810_MEMBASE (pI830->PciInfo, mmio_bar);
      if (pI830->MMIOAddr == 0) {
	 xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
		    "No valid MMIO address in PCI config space\n");
	 PreInitCleanup(pScrn);
	 return FALSE;
d6027 2
d6030 2
a6031 5
   xf86DrvMsg(pScrn->scrnIndex, from, "IO registers at addr 0x%lX\n",
	      (unsigned long)pI830->MMIOAddr);

   /* check quirks */
   i830_fixup_devices(pScrn);
d6033 1
a6033 3
   /* Allocate an xf86CrtcConfig */
   xf86CrtcConfigInit (pScrn, &i830_xf86crtc_config_funcs);
   xf86_config = XF86_CRTC_CONFIG_PTR(pScrn);
a6034 2
   /* See i830_exa.c comments for why we limit the framebuffer size like this.
    */
d6036 2
a6037 5
      max_width = 8192;
      max_height = 8192;
   } else {
      max_width = 2048;
      max_height = 2048;
a6038 1
   xf86CrtcSetSizeRange (pScrn, 320, 200, max_width, max_height);
d6040 2
a6041 4
   if (IS_I830(pI830) || IS_845G(pI830)) {
#if XSERVER_LIBPCIACCESS
      uint16_t		gmch_ctrl;
      struct pci_device *bridge;
d6043 2
a6044 5
      bridge = intel_host_bridge ();
      pci_device_cfg_read_u16 (bridge, &gmch_ctrl, I830_GMCH_CTRL);
#else
      PCITAG bridge;
      CARD16 gmch_ctrl;
d6046 37
a6082 7
      bridge = pciTag(0, 0, 0);		/* This is always the host bridge */
      gmch_ctrl = pciReadWord(bridge, I830_GMCH_CTRL);
#endif
      if ((gmch_ctrl & I830_GMCH_MEM_MASK) == I830_GMCH_MEM_128M) {
	 pI830->FbMapSize = 0x8000000;
      } else {
	 pI830->FbMapSize = 0x4000000; /* 64MB - has this been tested ?? */
d6084 20
a6103 7
   } else {
      if (IS_I9XX(pI830)) {
#if XSERVER_LIBPCIACCESS
	 pI830->FbMapSize = pI830->PciInfo->regions[fb_bar].size;
#else
	 pI830->FbMapSize = 1UL << pciGetBaseSize(pI830->PciTag, 2, TRUE,
						  NULL);
a6104 5
      } else {
	 /* 128MB aperture for later i8xx series. */
	 pI830->FbMapSize = 0x8000000;
      }
   }
d6106 12
a6117 2
   /* Some of the probing needs MMIO access, so map it here. */
   I830MapMMIO(pScrn);
d6119 3
a6121 4
   if (pI830->debug_modes) {
      xf86DrvMsg(pScrn->scrnIndex, X_INFO, "Hardware state on X startup:\n");
      i830DumpRegs (pScrn);
   }
d6123 13
a6135 1
   i830TakeRegSnapshot(pScrn);
d6137 3
a6139 4
#if 1
   pI830->saveSWF0 = INREG(SWF0);
   pI830->saveSWF4 = INREG(SWF4);
   pI830->swfSaved = TRUE;
d6141 24
a6164 2
   /* Set "extended desktop" */
   OUTREG(SWF0, pI830->saveSWF0 | (1 << 21));
d6166 12
a6177 4
   /* Set "driver loaded",  "OS unknown", "APM 1.2" */
   OUTREG(SWF4, (pI830->saveSWF4 & ~((3 << 19) | (7 << 16))) |
		(1 << 23) | (2 << 16));
#endif
d6179 2
a6180 2
   if (DEVICE_ID(pI830->PciInfo) == PCI_CHIP_E7221_G)
      num_pipe = 1;
d6182 6
a6187 6
   if (IS_MOBILE(pI830) || IS_I9XX(pI830))
      num_pipe = 2;
   else
      num_pipe = 1;
   xf86DrvMsg(pScrn->scrnIndex, X_INFO, "%d display pipe%s available.\n",
	      num_pipe, num_pipe > 1 ? "s" : "");
d6189 6
a6194 2
   if (xf86ReturnOptValBool(pI830->Options, OPTION_NOACCEL, FALSE)) {
      pI830->noAccel = TRUE;
d6197 3
d6201 2
a6202 9
    * The ugliness below:
    * If either XAA or EXA (exclusive) is compiled in, default to it.
    * 
    * If both are compiled in, and the user didn't specify noAccel, use the
    * config option AccelMethod to determine which to use, defaulting to EXA
    * if none is specified, or if the string was unrecognized.
    *
    * All this *could* go away if we removed XAA support from this driver,
    * for example. :)
d6204 21
a6224 22
   if (!pI830->noAccel) {
#ifdef I830_USE_EXA
       pI830->useEXA = TRUE;
#else
       pI830->useEXA = FALSE;
#endif
#if defined(I830_USE_XAA) && defined(I830_USE_EXA)
       int from = X_DEFAULT;
       if ((s = (char *)xf86GetOptValString(pI830->Options,
					    OPTION_ACCELMETHOD))) {
	   if (!xf86NameCmp(s, "EXA")) {
	       from = X_CONFIG;
	       pI830->useEXA = TRUE;
	   }
	   else if (!xf86NameCmp(s, "XAA")) {
	       from = X_CONFIG;
	       pI830->useEXA = FALSE;
	   }
       }
#endif
       xf86DrvMsg(pScrn->scrnIndex, from, "Using %s for acceleration\n",
		  pI830->useEXA ? "EXA" : "XAA");
d6227 10
a6236 2
   if (xf86ReturnOptValBool(pI830->Options, OPTION_SW_CURSOR, FALSE)) {
      pI830->SWCursor = TRUE;
d6239 2
a6240 2
   pI830->directRenderingDisabled =
	!xf86ReturnOptValBool(pI830->Options, OPTION_DRI, TRUE);
d6242 9
d6252 2
a6253 10
   if (!pI830->directRenderingDisabled) {
      if (pI830->noAccel || pI830->SWCursor) {
	 xf86DrvMsg(pScrn->scrnIndex, X_CONFIG, "DRI is disabled because it "
		    "needs HW cursor and 2D acceleration.\n");
	 pI830->directRenderingDisabled = TRUE;
      } else if (pScrn->depth != 16 && pScrn->depth != 24) {
	 xf86DrvMsg(pScrn->scrnIndex, X_CONFIG, "DRI is disabled because it "
		    "runs only at depths 16 and 24.\n");
	 pI830->directRenderingDisabled = TRUE;
      }
d6255 1
a6255 2
      if (!pI830->directRenderingDisabled) {
	 pI830->allocate_classic_textures = TRUE;
d6257 2
a6258 1
	 from = X_PROBED;
d6260 2
a6261 15
#ifdef XF86DRI_MM
	 if (!IS_I965G(pI830)) {
	    Bool tmp;

	    if (xf86GetOptValBool(pI830->Options,
				  OPTION_INTELTEXPOOL, &tmp)) {
	       from = X_CONFIG;
	       if (!tmp)
		  pI830->allocate_classic_textures = FALSE;
	    }
	 }
#endif
      }
   } 
   
d6264 3
a6266 3
   I830PreInitDDC(pScrn);
   for (i = 0; i < num_pipe; i++) {
       i830_crtc_init(pScrn, i);
a6267 1
   I830SetupOutputs(pScrn);
d6269 6
a6274 9
   SaveHWState(pScrn);
   if (!xf86InitialConfiguration (pScrn, FALSE))
   {
      xf86DrvMsg(pScrn->scrnIndex, X_ERROR, "No valid modes.\n");
      RestoreHWState(pScrn);
      PreInitCleanup(pScrn);
      return FALSE;
   }
   RestoreHWState(pScrn);
d6276 1
a6276 2
   /* XXX This should go away, replaced by xf86Crtc.c support for it */
   pI830->rotation = RR_Rotate_0;
d6278 9
a6286 20
   /*
    * Let's setup the mobile systems to check the lid status
    */
   if (IS_MOBILE(pI830)) {
      pI830->checkDevices = TRUE;

      if (!xf86ReturnOptValBool(pI830->Options, OPTION_CHECKDEVICES, TRUE)) {
         pI830->checkDevices = FALSE;
         xf86DrvMsg(pScrn->scrnIndex, X_INFO, "Monitoring connected displays disabled\n");
      } else
      if (pI830->entityPrivate && !I830IsPrimary(pScrn) &&
          !I830PTR(pI830->entityPrivate->pScrn_1)->checkDevices) {
         /* If checklid is off, on the primary head, then 
          * turn it off on the secondary*/
         xf86DrvMsg(pScrn->scrnIndex, X_INFO, "Monitoring connected displays disabled\n");
         pI830->checkDevices = FALSE;
      } else
         xf86DrvMsg(pScrn->scrnIndex, X_INFO, "Monitoring connected displays enabled\n");
   } else
      pI830->checkDevices = FALSE;
d6288 1
a6288 1
   pI830->stolen_size = I830DetectMemory(pScrn);
d6290 2
a6291 2
   pI830->XvDisabled =
	!xf86ReturnOptValBool(pI830->Options, OPTION_XVIDEO, TRUE);
d6293 4
a6296 17
#ifdef I830_XV
   if (xf86GetOptValInteger(pI830->Options, OPTION_VIDEO_KEY,
			    &(pI830->colorKey))) {
      from = X_CONFIG;
   } else if (xf86GetOptValInteger(pI830->Options, OPTION_COLOR_KEY,
			    &(pI830->colorKey))) {
      from = X_CONFIG;
   } else {
      pI830->colorKey = (1 << pScrn->offset.red) |
			(1 << pScrn->offset.green) |
			(((pScrn->mask.blue >> pScrn->offset.blue) - 1) <<
			 pScrn->offset.blue);
      from = X_DEFAULT;
   }
   xf86DrvMsg(pScrn->scrnIndex, from, "video overlay key set to 0x%x\n",
	      pI830->colorKey);
#endif
d6298 2
a6299 5
#ifdef XF86DRI
   pI830->allowPageFlip = FALSE;
   from = (!pI830->directRenderingDisabled &&
	   xf86GetOptValBool(pI830->Options, OPTION_PAGEFLIP,
			     &pI830->allowPageFlip)) ? X_CONFIG : X_DEFAULT;
d6301 1
a6301 3
   xf86DrvMsg(pScrn->scrnIndex, from, "Will%s try to enable page flipping\n",
	      pI830->allowPageFlip ? "" : " not");
#endif
d6303 5
a6307 5
#ifdef XF86DRI
   pI830->TripleBuffer = FALSE;
   from =  (!pI830->directRenderingDisabled &&
	    xf86GetOptValBool(pI830->Options, OPTION_TRIPLEBUFFER,
			      &pI830->TripleBuffer)) ? X_CONFIG : X_DEFAULT;
d6309 17
a6325 2
   xf86DrvMsg(pScrn->scrnIndex, from, "Triple buffering %sabled\n",
	      pI830->TripleBuffer ? "en" : "dis");
d6329 3
a6331 1
    * If the driver can do gamma correction, it should call xf86SetGamma() here.
d6333 38
d6372 32
a6403 6
   {
      Gamma zeros = { 0.0, 0.0, 0.0 };

      if (!xf86SetGamma(pScrn, zeros)) {
         PreInitCleanup(pScrn);
	 return FALSE;
d6407 9
a6415 5
   /* Check if the HW cursor needs physical address. */
   if (IS_MOBILE(pI830) || IS_I9XX(pI830))
      pI830->CursorNeedsPhysical = TRUE;
   else
      pI830->CursorNeedsPhysical = FALSE;
d6417 1
a6417 2
   if (IS_I965G(pI830) || IS_G33CLASS(pI830))
      pI830->CursorNeedsPhysical = FALSE;
d6420 1
a6420 2
    * XXX If we knew the pre-initialised GTT format for certain, we could
    * probably figure out the physical address even in the StolenOnly case.
d6422 7
a6428 18
   if (!I830IsPrimary(pScrn)) {
        I830Ptr pI8301 = I830PTR(pI830->entityPrivate->pScrn_1);
	if (!pI8301->SWCursor) {
          xf86DrvMsg(pScrn->scrnIndex, X_PROBED,
		 "Using HW Cursor because it's enabled on primary head.\n");
          pI830->SWCursor = FALSE;
        }
   } else 
   if (pI830->StolenOnly && pI830->CursorNeedsPhysical && !pI830->SWCursor) {
      xf86DrvMsg(pScrn->scrnIndex, X_PROBED,
		 "HW Cursor disabled because it needs agpgart memory.\n");
      pI830->SWCursor = TRUE;
   }

   if (pScrn->modes == NULL) {
      xf86DrvMsg(pScrn->scrnIndex, X_ERROR, "No modes.\n");
      PreInitCleanup(pScrn);
      return FALSE;
a6429 1
   pScrn->currentMode = pScrn->modes;
d6431 24
a6454 4
   if (!IS_I965G(pI830) && pScrn->virtualY > 2048) {
      xf86DrvMsg(pScrn->scrnIndex, X_ERROR, "Cannot support > 2048 vertical lines. disabling acceleration.\n");
      pI830->noAccel = TRUE;
   }
d6456 6
a6461 5
   /* Don't need MMIO access anymore. */
   if (pI830->swfSaved) {
      OUTREG(SWF0, pI830->saveSWF0);
      OUTREG(SWF4, pI830->saveSWF4);
   }
d6463 23
a6485 2
   /* Set display resolution */
   xf86SetDpi(pScrn, 0, 0);
d6487 15
a6501 5
   /* Load the required sub modules */
   if (!xf86LoadSubModule(pScrn, "fb")) {
      PreInitCleanup(pScrn);
      return FALSE;
   }
d6503 4
a6506 1
   xf86LoaderReqSymLists(I810fbSymbols, NULL);
d6508 15
a6522 5
#ifdef I830_USE_XAA
   if (!pI830->noAccel && !pI830->useEXA) {
      if (!xf86LoadSubModule(pScrn, "xaa")) {
	 PreInitCleanup(pScrn);
	 return FALSE;
d6524 9
a6532 3
      xf86LoaderReqSymLists(I810xaaSymbols, NULL);
   }
#endif
d6534 7
a6540 4
#ifdef I830_USE_EXA
   if (!pI830->noAccel && pI830->useEXA) {
      XF86ModReqInfo req;
      int errmaj, errmin;
d6542 22
a6563 12
      memset(&req, 0, sizeof(req));
      req.majorversion = 2;
#if EXA_VERSION_MINOR >= 2
      req.minorversion = 2;
#else
      req.minorversion = 1;
#endif
      if (!LoadSubModule(pScrn->module, "exa", NULL, NULL, NULL, &req,
		&errmaj, &errmin)) {
	 LoaderErrorMsg(NULL, "exa", errmaj, errmin);
	 PreInitCleanup(pScrn);
	 return FALSE;
a6564 1
      xf86LoaderReqSymLists(I830exaSymbols, NULL);
d6566 67
d6634 12
a6645 4
   if (!pI830->SWCursor) {
      if (!xf86LoadSubModule(pScrn, "ramdac")) {
	 PreInitCleanup(pScrn);
	 return FALSE;
a6646 1
      xf86LoaderReqSymLists(I810ramdacSymbols, NULL);
d6649 3
a6651 1
   i830CompareRegsToSnapshot(pScrn, "After PreInit");
d6653 7
a6659 1
   I830UnmapMMIO(pScrn);
d6661 4
a6664 4
   /*  We won't be using the VGA access after the probe. */
   I830SetMMIOAccess(pI830);
   xf86SetOperatingState(resVgaIo, pI830->pEnt->index, ResUnusedOpr);
   xf86SetOperatingState(resVgaMem, pI830->pEnt->index, ResDisableOpr);
d6667 4
a6670 4
   if (I830IsPrimary(pScrn)) {
      vbeFree(pI830->pVbe);
   }
   pI830->pVbe = NULL;
d6673 3
a6675 8
#if defined(XF86DRI)
   /* Load the dri module if requested. */
   if (xf86ReturnOptValBool(pI830->Options, OPTION_DRI, FALSE) &&
       !pI830->directRenderingDisabled) {
      if (xf86LoadSubModule(pScrn, "dri")) {
	 xf86LoaderReqSymLists(I810driSymbols, I810drmSymbols, NULL);
      }
   }
d6678 1
a6678 2
   pI830->preinit = FALSE;

a6681 6
/*
 * Reset registers that it doesn't make sense to save/restore to a sane state.
 * This is basically the ring buffer and fence registers.  Restoring these
 * doesn't make sense without restoring GTT mappings.  This is something that
 * whoever gets control next should do.
 */
d6683 1
a6683 1
i830_stop_ring(ScrnInfoPtr pScrn, Bool flush)
d6686 2
a6687 3
   unsigned long temp;

   DPRINTF(PFX, "ResetState: flush is %s\n", BOOLTOSTRING(flush));
d6691 2
a6692 17
   if (pI830->entityPrivate)
      pI830->entityPrivate->RingRunning = 0;

   /* Flush the ring buffer (if enabled), then disable it. */
   if (!pI830->noAccel) {
      temp = INREG(LP_RING + RING_LEN);
      if (temp & RING_VALID) {
	 i830_refresh_ring(pScrn);
	 I830Sync(pScrn);
	 DO_RING_IDLE();
      }

      OUTREG(LP_RING + RING_LEN, 0);
      OUTREG(LP_RING + RING_HEAD, 0);
      OUTREG(LP_RING + RING_TAIL, 0);
      OUTREG(LP_RING + RING_START, 0);
   }
d6695 4
a6698 2
static void
i830_start_ring(ScrnInfoPtr pScrn)
a6700 3
   unsigned int itemp;

   DPRINTF(PFX, "SetRingRegs\n");
d6702 2
a6703 2
   if (pI830->noAccel)
      return;
d6705 2
a6706 1
   if (!I830IsPrimary(pScrn)) return;
d6708 5
a6712 2
   if (pI830->entityPrivate)
      pI830->entityPrivate->RingRunning = 1;
d6714 2
a6715 3
   OUTREG(LP_RING + RING_LEN, 0);
   OUTREG(LP_RING + RING_TAIL, 0);
   OUTREG(LP_RING + RING_HEAD, 0);
d6717 1
a6717 2
   assert((pI830->LpRing->mem->offset & I830_RING_START_MASK) ==
	   pI830->LpRing->mem->offset);
d6719 2
a6720 3
   /* Don't care about the old value.  Reserved bits must be zero anyway. */
   itemp = pI830->LpRing->mem->offset;
   OUTREG(LP_RING + RING_START, itemp);
d6722 2
a6723 12
   if (((pI830->LpRing->mem->size - 4096) & I830_RING_NR_PAGES) !=
       pI830->LpRing->mem->size - 4096) {
      xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
		 "I830SetRingRegs: Ring buffer size - 4096 (%lx) violates its "
		 "mask (%x)\n", pI830->LpRing->mem->size - 4096,
		 I830_RING_NR_PAGES);
   }
   /* Don't care about the old value.  Reserved bits must be zero anyway. */
   itemp = (pI830->LpRing->mem->size - 4096) & I830_RING_NR_PAGES;
   itemp |= (RING_NO_REPORT | RING_VALID);
   OUTREG(LP_RING + RING_LEN, itemp);
   i830_refresh_ring(pScrn);
d6727 1
a6727 1
i830_refresh_ring(ScrnInfoPtr pScrn)
d6731 57
a6787 5
   /* If we're reaching RefreshRing as a result of grabbing the DRI lock
    * before we've set up the ringbuffer, don't bother.
    */
   if (pI830->LpRing->mem == NULL)
       return;
d6789 1
a6789 6
   pI830->LpRing->head = INREG(LP_RING + RING_HEAD) & I830_HEAD_MASK;
   pI830->LpRing->tail = INREG(LP_RING + RING_TAIL);
   pI830->LpRing->space = pI830->LpRing->head - (pI830->LpRing->tail + 8);
   if (pI830->LpRing->space < 0)
      pI830->LpRing->space += pI830->LpRing->mem->size;
   i830MarkSync(pScrn);
d6792 1
a6792 4
/*
 * This should be called everytime the X server gains control of the screen,
 * before any video modes are programmed (ScreenInit, EnterVT).
 */
d6794 1
a6794 1
SetHWOperatingState(ScrnInfoPtr pScrn)
d6797 5
d6803 9
a6811 1
   DPRINTF(PFX, "SetHWOperatingState\n");
d6813 23
a6835 11
   /* Disable clock gating reported to work incorrectly according to the specs.
    */
   if (IS_I965GM(pI830)) {
      OUTREG(RENCLK_GATE_D1, I965_RCC_CLOCK_GATE_DISABLE);
   } else if (IS_I965G(pI830)) {
      OUTREG(RENCLK_GATE_D1,
	     I965_RCC_CLOCK_GATE_DISABLE | I965_ISC_CLOCK_GATE_DISABLE);
   } else if (IS_I855(pI830) || IS_I865G(pI830)) {
      OUTREG(RENCLK_GATE_D1, SV_CLOCK_GATE_DISABLE);
   } else if (IS_I830(pI830)) {
      OUTREG(DSPCLK_GATE_D, OVRUNIT_CLOCK_GATE_DISABLE);
d6838 4
a6841 4
   i830_start_ring(pScrn);
   if (!pI830->SWCursor)
      I830InitHWCursor(pScrn);
}
d6843 4
a6846 4
enum pipe {
    PIPE_A = 0,
    PIPE_B,
};
d6848 4
a6851 8
static Bool
i830_pipe_enabled(I830Ptr pI830, enum pipe pipe)
{
    if (pipe == PIPE_A)
	return (INREG(PIPEACONF) & PIPEACONF_ENABLE);
    else
	return (INREG(PIPEBCONF) & PIPEBCONF_ENABLE);
}
d6853 12
a6864 4
static void
i830_save_palette(I830Ptr pI830, enum pipe pipe)
{
    int i;
d6866 4
a6869 9
    if (!i830_pipe_enabled(pI830, pipe))
	return;

    for(i= 0; i < 256; i++) {
	if (pipe == PIPE_A)
	    pI830->savePaletteA[i] = INREG(PALETTE_A + (i << 2));
	else
	    pI830->savePaletteB[i] = INREG(PALETTE_B + (i << 2));
    }
d6873 1
a6873 17
i830_restore_palette(I830Ptr pI830, enum pipe pipe)
{
    int i;

    if (!i830_pipe_enabled(pI830, pipe))
	return;

    for(i= 0; i < 256; i++) {
	if (pipe == PIPE_A)
	    OUTREG(PALETTE_A + (i << 2), pI830->savePaletteA[i]);
	else
	    OUTREG(PALETTE_B + (i << 2), pI830->savePaletteB[i]);
    }
}

static Bool
SaveHWState(ScrnInfoPtr pScrn)
a6874 1
   xf86CrtcConfigPtr   xf86_config = XF86_CRTC_CONFIG_PTR(pScrn);
d6876 1
a6876 3
   vgaHWPtr hwp = VGAHWPTR(pScrn);
   vgaRegPtr vgaReg = &hwp->SavedReg;
   int i;
d6878 3
a6880 6
   if (pI830->fb_compression) {
       pI830->saveFBC_CFB_BASE = INREG(FBC_CFB_BASE);
       pI830->saveFBC_LL_BASE = INREG(FBC_LL_BASE);
       pI830->saveFBC_CONTROL2 = INREG(FBC_CONTROL2);
       pI830->saveFBC_CONTROL = INREG(FBC_CONTROL);
   }
d6882 4
a6885 43
   /* Save video mode information for native mode-setting. */
   pI830->saveDSPACNTR = INREG(DSPACNTR);
   pI830->savePIPEACONF = INREG(PIPEACONF);
   pI830->savePIPEASRC = INREG(PIPEASRC);
   pI830->saveFPA0 = INREG(FPA0);
   pI830->saveFPA1 = INREG(FPA1);
   pI830->saveDPLL_A = INREG(DPLL_A);
   if (IS_I965G(pI830))
      pI830->saveDPLL_A_MD = INREG(DPLL_A_MD);
   pI830->saveHTOTAL_A = INREG(HTOTAL_A);
   pI830->saveHBLANK_A = INREG(HBLANK_A);
   pI830->saveHSYNC_A = INREG(HSYNC_A);
   pI830->saveVTOTAL_A = INREG(VTOTAL_A);
   pI830->saveVBLANK_A = INREG(VBLANK_A);
   pI830->saveVSYNC_A = INREG(VSYNC_A);
   pI830->saveBCLRPAT_A = INREG(BCLRPAT_A);
   pI830->saveDSPASTRIDE = INREG(DSPASTRIDE);
   pI830->saveDSPASIZE = INREG(DSPASIZE);
   pI830->saveDSPAPOS = INREG(DSPAPOS);
   pI830->saveDSPABASE = INREG(DSPABASE);

   i830_save_palette(pI830, PIPE_A);

   if(xf86_config->num_crtc == 2) {
      pI830->savePIPEBCONF = INREG(PIPEBCONF);
      pI830->savePIPEBSRC = INREG(PIPEBSRC);
      pI830->saveDSPBCNTR = INREG(DSPBCNTR);
      pI830->saveFPB0 = INREG(FPB0);
      pI830->saveFPB1 = INREG(FPB1);
      pI830->saveDPLL_B = INREG(DPLL_B);
      if (IS_I965G(pI830))
	 pI830->saveDPLL_B_MD = INREG(DPLL_B_MD);
      pI830->saveHTOTAL_B = INREG(HTOTAL_B);
      pI830->saveHBLANK_B = INREG(HBLANK_B);
      pI830->saveHSYNC_B = INREG(HSYNC_B);
      pI830->saveVTOTAL_B = INREG(VTOTAL_B);
      pI830->saveVBLANK_B = INREG(VBLANK_B);
      pI830->saveVSYNC_B = INREG(VSYNC_B);
      pI830->saveBCLRPAT_B = INREG(BCLRPAT_B);
      pI830->saveDSPBSTRIDE = INREG(DSPBSTRIDE);
      pI830->saveDSPBSIZE = INREG(DSPBSIZE);
      pI830->saveDSPBPOS = INREG(DSPBPOS);
      pI830->saveDSPBBASE = INREG(DSPBBASE);
d6887 4
a6890 2
      i830_save_palette(pI830, PIPE_B);
   }
d6892 23
a6914 28
   if (IS_I965G(pI830)) {
      pI830->saveDSPASURF = INREG(DSPASURF);
      pI830->saveDSPBSURF = INREG(DSPBSURF);
      pI830->saveDSPATILEOFF = INREG(DSPATILEOFF);
      pI830->saveDSPBTILEOFF = INREG(DSPBTILEOFF);
   }

   pI830->saveVCLK_DIVISOR_VGA0 = INREG(VCLK_DIVISOR_VGA0);
   pI830->saveVCLK_DIVISOR_VGA1 = INREG(VCLK_DIVISOR_VGA1);
   pI830->saveVCLK_POST_DIV = INREG(VCLK_POST_DIV);
   pI830->saveVGACNTRL = INREG(VGACNTRL);

   for(i = 0; i < 7; i++) {
      pI830->saveSWF[i] = INREG(SWF0 + (i << 2));
      pI830->saveSWF[i+7] = INREG(SWF00 + (i << 2));
   }
   pI830->saveSWF[14] = INREG(SWF30);
   pI830->saveSWF[15] = INREG(SWF31);
   pI830->saveSWF[16] = INREG(SWF32);

   if (IS_MOBILE(pI830) && !IS_I830(pI830))
      pI830->saveLVDS = INREG(LVDS);
   pI830->savePFIT_CONTROL = INREG(PFIT_CONTROL);

   for (i = 0; i < xf86_config->num_output; i++) {
      xf86OutputPtr   output = xf86_config->output[i];
      if (output->funcs->save)
	 (*output->funcs->save) (output);
d6917 4
a6920 2
   vgaHWUnlock(hwp);
   vgaHWSave(pScrn, vgaReg, VGA_SR_FONTS);
d6922 4
a6925 2
   return TRUE;
}
d6927 4
a6930 8
static Bool
RestoreHWState(ScrnInfoPtr pScrn)
{
   xf86CrtcConfigPtr   xf86_config = XF86_CRTC_CONFIG_PTR(pScrn);
   I830Ptr pI830 = I830PTR(pScrn);
   vgaHWPtr hwp = VGAHWPTR(pScrn);
   vgaRegPtr vgaReg = &hwp->SavedReg;
   int i;
d6932 11
a6942 16
   DPRINTF(PFX, "RestoreHWState\n");

#ifdef XF86DRI
   I830DRISetVBlankInterrupt (pScrn, FALSE);
#endif
   /* Disable outputs */
   for (i = 0; i < xf86_config->num_output; i++) {
      xf86OutputPtr   output = xf86_config->output[i];
      output->funcs->dpms(output, DPMSModeOff);
   }
   i830WaitForVblank(pScrn);
   
   /* Disable pipes */
   for (i = 0; i < xf86_config->num_crtc; i++) {
      xf86CrtcPtr crtc = xf86_config->crtc[i];
      crtc->funcs->dpms(crtc, DPMSModeOff);
a6943 1
   i830WaitForVblank(pScrn);
d6945 4
a6948 2
   if (IS_MOBILE(pI830) && !IS_I830(pI830))
      OUTREG(LVDS, pI830->saveLVDS);
d6950 2
a6951 14
   if (!IS_I830(pI830) && !IS_845G(pI830))
     OUTREG(PFIT_CONTROL, pI830->savePFIT_CONTROL);

   if (pI830->saveDPLL_A & DPLL_VCO_ENABLE)
   {
      OUTREG(DPLL_A, pI830->saveDPLL_A & ~DPLL_VCO_ENABLE);
      usleep(150);
   }
   OUTREG(FPA0, pI830->saveFPA0);
   OUTREG(FPA1, pI830->saveFPA1);
   OUTREG(DPLL_A, pI830->saveDPLL_A);
   usleep(150);
   if (IS_I965G(pI830))
      OUTREG(DPLL_A_MD, pI830->saveDPLL_A_MD);
d6953 1
a6953 92
      OUTREG(DPLL_A, pI830->saveDPLL_A);
   usleep(150);

   OUTREG(HTOTAL_A, pI830->saveHTOTAL_A);
   OUTREG(HBLANK_A, pI830->saveHBLANK_A);
   OUTREG(HSYNC_A, pI830->saveHSYNC_A);
   OUTREG(VTOTAL_A, pI830->saveVTOTAL_A);
   OUTREG(VBLANK_A, pI830->saveVBLANK_A);
   OUTREG(VSYNC_A, pI830->saveVSYNC_A);
   OUTREG(BCLRPAT_A, pI830->saveBCLRPAT_A);
   
   OUTREG(DSPASTRIDE, pI830->saveDSPASTRIDE);
   OUTREG(DSPASIZE, pI830->saveDSPASIZE);
   OUTREG(DSPAPOS, pI830->saveDSPAPOS);
   OUTREG(PIPEASRC, pI830->savePIPEASRC);
   OUTREG(DSPABASE, pI830->saveDSPABASE);
   if (IS_I965G(pI830))
   {
      OUTREG(DSPASURF, pI830->saveDSPASURF);
      OUTREG(DSPATILEOFF, pI830->saveDSPATILEOFF);
   }
   /*
    * Make sure the DPLL is active and not in VGA mode or the
    * write of PIPEnCONF may cause a crash
    */
   if ((pI830->saveDPLL_A & DPLL_VCO_ENABLE) &&
       (pI830->saveDPLL_A & DPLL_VGA_MODE_DIS))
	   OUTREG(PIPEACONF, pI830->savePIPEACONF);
   i830WaitForVblank(pScrn);
   OUTREG(DSPACNTR, pI830->saveDSPACNTR);
   OUTREG(DSPABASE, INREG(DSPABASE));
   i830WaitForVblank(pScrn);
   
   if(xf86_config->num_crtc == 2) 
   {
      if (pI830->saveDPLL_B & DPLL_VCO_ENABLE)
      {
	 OUTREG(DPLL_B, pI830->saveDPLL_B & ~DPLL_VCO_ENABLE);
	 usleep(150);
      }
      OUTREG(FPB0, pI830->saveFPB0);
      OUTREG(FPB1, pI830->saveFPB1);
      OUTREG(DPLL_B, pI830->saveDPLL_B);
      usleep(150);
      if (IS_I965G(pI830))
	 OUTREG(DPLL_B_MD, pI830->saveDPLL_B_MD);
      else
	 OUTREG(DPLL_B, pI830->saveDPLL_B);
      usleep(150);
   
      OUTREG(HTOTAL_B, pI830->saveHTOTAL_B);
      OUTREG(HBLANK_B, pI830->saveHBLANK_B);
      OUTREG(HSYNC_B, pI830->saveHSYNC_B);
      OUTREG(VTOTAL_B, pI830->saveVTOTAL_B);
      OUTREG(VBLANK_B, pI830->saveVBLANK_B);
      OUTREG(VSYNC_B, pI830->saveVSYNC_B);
      OUTREG(BCLRPAT_B, pI830->saveBCLRPAT_B);
      OUTREG(DSPBSTRIDE, pI830->saveDSPBSTRIDE);
      OUTREG(DSPBSIZE, pI830->saveDSPBSIZE);
      OUTREG(DSPBPOS, pI830->saveDSPBPOS);
      OUTREG(PIPEBSRC, pI830->savePIPEBSRC);
      OUTREG(DSPBBASE, pI830->saveDSPBBASE);
      if (IS_I965G(pI830))
      {
	 OUTREG(DSPBSURF, pI830->saveDSPBSURF);
	 OUTREG(DSPBTILEOFF, pI830->saveDSPBTILEOFF);
      }

      /*
       * See PIPEnCONF note above
       */
      if ((pI830->saveDPLL_B & DPLL_VCO_ENABLE) &&
	  (pI830->saveDPLL_B & DPLL_VGA_MODE_DIS))
	      OUTREG(PIPEBCONF, pI830->savePIPEBCONF);
      i830WaitForVblank(pScrn);
      OUTREG(DSPBCNTR, pI830->saveDSPBCNTR);
      OUTREG(DSPBBASE, INREG(DSPBBASE));
      i830WaitForVblank(pScrn);
   }

   /* Restore outputs */
   for (i = 0; i < xf86_config->num_output; i++) {
      xf86OutputPtr   output = xf86_config->output[i];
      if (output->funcs->restore)
	 output->funcs->restore(output);
   }
    
   OUTREG(VGACNTRL, pI830->saveVGACNTRL);

   OUTREG(VCLK_DIVISOR_VGA0, pI830->saveVCLK_DIVISOR_VGA0);
   OUTREG(VCLK_DIVISOR_VGA1, pI830->saveVCLK_DIVISOR_VGA1);
   OUTREG(VCLK_POST_DIV, pI830->saveVCLK_POST_DIV);
d6955 5
a6959 2
   i830_restore_palette(pI830, PIPE_A);
   i830_restore_palette(pI830, PIPE_B);
d6961 5
a6965 4
   for(i = 0; i < 7; i++) {
      OUTREG(SWF0 + (i << 2), pI830->saveSWF[i]);
      OUTREG(SWF00 + (i << 2), pI830->saveSWF[i+7]);
   }
d6967 1
a6967 3
   OUTREG(SWF30, pI830->saveSWF[14]);
   OUTREG(SWF31, pI830->saveSWF[15]);
   OUTREG(SWF32, pI830->saveSWF[16]);
d6969 2
a6970 6
   if (pI830->fb_compression) {
       OUTREG(FBC_CFB_BASE, pI830->saveFBC_CFB_BASE);
       OUTREG(FBC_LL_BASE, pI830->saveFBC_LL_BASE);
       OUTREG(FBC_CONTROL2, pI830->saveFBC_CONTROL2);
       OUTREG(FBC_CONTROL, pI830->saveFBC_CONTROL);
   }
d6972 4
a6975 2
   vgaHWRestore(pScrn, vgaReg, VGA_SR_FONTS);
   vgaHWLock(hwp);
d6977 1
a6977 1
   return TRUE;
d6979 1
d7009 34
d7048 1
d7057 1
a7057 1
   if (pScrn->virtualX > pScrn->virtualY)
d7083 1
a7083 7
/**
 * Intialiazes the hardware for the 3D pipeline use in the 2D driver.
 *
 * Some state caching is performed to avoid redundant state emits.  This
 * function is also responsible for marking the state as clobbered for DRI
 * clients.
 */
d7090 1
a7090 1
   if (pI830->noAccel)
d7093 3
a7095 15
#ifdef XF86DRI
   if (pI830->directRenderingEnabled) {
      drmI830Sarea *sarea = DRIGetSAREAPrivate(pScrn->pScreen);

      /* Mark that the X Server was the last holder of the context */
      if (sarea)
	 sarea->ctxOwner = DRIGetContext(pScrn->pScreen);
   }
#endif

   /* If we've emitted our state since the last clobber by another client,
    * skip it.
    */
   if (*pI830->last_3d != LAST_3D_OTHER)
      return;
a7096 2
   ctx_addr = pI830->logical_context->offset;
   assert((pI830->logical_context->offset & 2047) == 0);
d7100 1
a7100 1
      OUT_RING(pI830->logical_context->offset |
d7115 47
a7161 3
static void
I830BlockHandler(int i,
		 pointer blockData, pointer pTimeout, pointer pReadmask)
d7163 2
a7164 3
    ScreenPtr pScreen = screenInfo.screens[i];
    ScrnInfoPtr pScrn = xf86Screens[i];
    I830Ptr pI830 = I830PTR(pScrn);
d7166 10
a7175 1
    pScreen->BlockHandler = pI830->BlockHandler;
d7177 4
a7180 1
    (*pScreen->BlockHandler) (i, blockData, pTimeout, pReadmask);
d7182 3
a7184 1
    pScreen->BlockHandler = I830BlockHandler;
d7186 5
a7190 1
    I830VideoBlockHandler(i, blockData, pTimeout, pReadmask);
d7193 3
d7197 1
a7197 1
I830ScreenInit(int scrnIndex, ScreenPtr pScreen, int argc, char **argv)
a7203 4
   unsigned long sys_mem;
   int i, c;
   Bool allocation_done = FALSE;
   MessageType from;
d7205 1
a7205 1
   xf86CrtcConfigPtr config;
d7212 1
a7212 154
   pScrn->displayWidth = (pScrn->virtualX + 63) & ~63;

   /*
    * The "VideoRam" config file parameter specifies the maximum amount of
    * memory that will be used/allocated.  When not present, we allow the
    * driver to allocate as much memory as it wishes to satisfy its
    * allocations, but if agpgart support isn't available, it gets limited
    * to the amount of pre-allocated ("stolen") memory.
    *
    * Note that in using this value for allocator initialization, we're
    * limiting aperture allocation to the VideoRam option, rather than limiting
    * actual memory allocation, so alignment and things will cause less than
    * VideoRam to be actually used.
    */
   if (pI830->pEnt->device->videoRam == 0) {
      from = X_DEFAULT;
      pScrn->videoRam = pI830->FbMapSize / KB(1);
   } else {
#if 0
      from = X_CONFIG;
      pScrn->videoRam = pI830->pEnt->device->videoRam;
#else
      /* Disable VideoRam configuration, at least for now.  Previously,
       * VideoRam was necessary to avoid overly low limits on allocated
       * memory, so users created larger, yet still small, fixed allocation
       * limits in their config files.  Now, the driver wants to allocate more,
       * and the old intention of the VideoRam lines that had been entered is
       * obsolete.
       */
      from = X_DEFAULT;
      pScrn->videoRam = pI830->FbMapSize / KB(1);

      if (pScrn->videoRam != pI830->pEnt->device->videoRam) {
	 xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
		    "VideoRam configuration found, which is no longer "
		    "recommended.\n");
	 xf86DrvMsg(pScrn->scrnIndex, X_INFO,
		    "Continuing with default %dkB VideoRam instead of %d "
		    "kB.\n",
		    pScrn->videoRam, pI830->pEnt->device->videoRam);
      }
#endif
   }

   /* Limit videoRam to how much we might be able to allocate from AGP */
   sys_mem = I830CheckAvailableMemory(pScrn);
   if (sys_mem == -1) {
      if (pScrn->videoRam > pI830->stolen_size / KB(1)) {
	 xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
		    "/dev/agpgart is either not available, or no memory "
		    "is available\nfor allocation.  "
		    "Using pre-allocated memory only.\n");
	 pScrn->videoRam = pI830->stolen_size / KB(1);
      }
      pI830->StolenOnly = TRUE;
   } else {
      if (sys_mem + (pI830->stolen_size / 1024) < pScrn->videoRam) {
	 pScrn->videoRam = sys_mem + (pI830->stolen_size / 1024);
	 from = X_PROBED;
	 if (sys_mem + (pI830->stolen_size / 1024) <
	     pI830->pEnt->device->videoRam)
	 {
	    xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
		       "VideoRAM reduced to %d kByte "
		       "(limited to available sysmem)\n", pScrn->videoRam);
	 }
      }
   }

   /* Limit video RAM to the actual aperture size */
   if (pScrn->videoRam > pI830->FbMapSize / 1024) {
      pScrn->videoRam = pI830->FbMapSize / 1024;
      if (pI830->FbMapSize / 1024 < pI830->pEnt->device->videoRam) {
	 xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
		    "VideoRam reduced to %d kByte (limited to aperture "
		    "size)\n",
		    pScrn->videoRam);
      }
   }

   /* Make sure it's on a page boundary */
   if (pScrn->videoRam & 3) {
      xf86DrvMsg(pScrn->scrnIndex, X_WARNING, "VideoRam reduced to %d KB "
		 "(page aligned - was %d KB)\n",
		 pScrn->videoRam & ~3, pScrn->videoRam);
      pScrn->videoRam &= ~3;
   }

#ifdef XF86DRI
   /* Check for appropriate bpp and module support to initialize DRI. */
   if (!I830CheckDRIAvailable(pScrn)) {
      pI830->directRenderingDisabled = TRUE;
   }

   /* If DRI hasn't been explicitly disabled, try to initialize it.
    * It will be used by the memory allocator.
    */
   if (!pI830->directRenderingDisabled)
      pI830->directRenderingEnabled = I830DRIScreenInit(pScreen);
   else
      pI830->directRenderingEnabled = FALSE;
#else
   pI830->directRenderingEnabled = FALSE;
#endif

   /* Set up our video memory allocator for the chosen videoRam */
   if (!i830_allocator_init(pScrn, 0, pScrn->videoRam * KB(1))) {
      xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
		 "Couldn't initialize video memory allocator\n");
      PreInitCleanup(pScrn);
      return FALSE;
   }

   xf86DrvMsg(pScrn->scrnIndex,
	      pI830->pEnt->device->videoRam ? X_CONFIG : X_DEFAULT,
	      "VideoRam: %d KB\n", pScrn->videoRam);

   if (xf86GetOptValInteger(pI830->Options, OPTION_CACHE_LINES,
			    &(pI830->CacheLines))) {
      xf86DrvMsg(pScrn->scrnIndex, X_CONFIG, "Requested %d cache lines\n",
		 pI830->CacheLines);
   } else {
      pI830->CacheLines = -1;
   }

   /* Enable tiling by default */
   pI830->tiling = TRUE;

   /* Allow user override if they set a value */
   if (xf86IsOptionSet(pI830->Options, OPTION_TILING)) {
       if (xf86ReturnOptValBool(pI830->Options, OPTION_TILING, FALSE))
	   pI830->tiling = TRUE;
       else
	   pI830->tiling = FALSE;
   }

   /* Enable FB compression if possible */
   if (i830_fb_compression_supported(pI830) && !IS_I965GM(pI830))
       pI830->fb_compression = TRUE;
   else
       pI830->fb_compression = FALSE;

   /* Again, allow user override if set */
   if (xf86IsOptionSet(pI830->Options, OPTION_FBC)) {
       if (xf86ReturnOptValBool(pI830->Options, OPTION_FBC, FALSE))
	   pI830->fb_compression = TRUE;
       else
	   pI830->fb_compression = FALSE;
   }

   xf86DrvMsg(pScrn->scrnIndex, X_CONFIG, "Framebuffer compression %sabled\n",
	      pI830->fb_compression ? "en" : "dis");
   xf86DrvMsg(pScrn->scrnIndex, X_CONFIG, "Tiling %sabled\n", pI830->tiling ?
	      "en" : "dis");
d7215 6
a7220 145
      /* Alloc our pointers for the primary head */
      if (!pI830->LpRing)
         pI830->LpRing = xcalloc(1, sizeof(I830RingBuffer));
      if (!pI830->overlayOn)
         pI830->overlayOn = xalloc(sizeof(Bool));
      if (!pI830->last_3d)
         pI830->last_3d = xalloc(sizeof(enum last_3d));
      if (!pI830->LpRing || !pI830->overlayOn || !pI830->last_3d) {
         xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
		 "Could not allocate primary data structures.\n");
         return FALSE;
      }
      *pI830->last_3d = LAST_3D_OTHER;
      *pI830->overlayOn = FALSE;
      if (pI830->entityPrivate)
         pI830->entityPrivate->XvInUse = -1;
   } else {
      /* Make our second head point to the first heads structures */
      pI8301 = I830PTR(pI830->entityPrivate->pScrn_1);
      pI830->LpRing = pI8301->LpRing;
      pI830->overlay_regs = pI8301->overlay_regs;
      pI830->overlayOn = pI8301->overlayOn;
      pI830->last_3d = pI8301->last_3d;
   }

   /* Need MMIO mapped to do GTT lookups during memory allocation. */
   I830MapMMIO(pScrn);

#if defined(XF86DRI)
   /*
    * If DRI is potentially usable, check if there is enough memory available
    * for it, and if there's also enough to allow tiling to be enabled.
    */


#ifdef I830_XV
    /*
     * Set this so that the overlay allocation is factored in when
     * appropriate.
     */
    pI830->XvEnabled = !pI830->XvDisabled;
#endif

   if (pI830->directRenderingEnabled) {
      int savedDisplayWidth = pScrn->displayWidth;
      Bool tiled = FALSE;

      if (IS_I965G(pI830)) {
	 int tile_pixels = 512 / pI830->cpp;
	 pScrn->displayWidth = (pScrn->displayWidth + tile_pixels - 1) &
	    ~(tile_pixels - 1);
	 tiled = TRUE;
      } else {
	 /* Good pitches to allow tiling.  Don't care about pitches < 1024
	  * pixels.
	  */
	 static const int pitches[] = {
	    1024,
	    2048,
	    4096,
	    8192,
	    0
	 };

	 for (i = 0; pitches[i] != 0; i++) {
	    if (pitches[i] >= pScrn->displayWidth) {
	       pScrn->displayWidth = pitches[i];
	       tiled = TRUE;
	       break;
	    }
	 }
      }

      /* Attempt two rounds of allocation to get 2d and 3d memory to fit:
       *
       * 0: untiled
       * 1: tiled
       */

#define MM_TURNS 2
      for (i = 0; i < MM_TURNS; i++) {
	 if (!tiled && i == 0)
	    continue;

	 if (i >= 1) {
	    /* For further allocations, disable tiling */
	    pI830->tiling = FALSE;
	    pScrn->displayWidth = savedDisplayWidth;
	    if (pI830->allowPageFlip)
	       xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
			  "Couldn't allocate tiled memory, page flipping "
			  "disabled\n");
	    pI830->allowPageFlip = FALSE;
	    if (pI830->fb_compression)
	       xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
			  "Couldn't allocate tiled memory, fb compression "
			  "disabled\n");
	    pI830->fb_compression = FALSE;
	 }

	 xf86DrvMsg(pScrn->scrnIndex, X_INFO,
		    "Attempting memory allocation with %s buffers.\n",
		    (i & 1) ? "untiled" : "tiled");

	 if (i830_allocate_2d_memory(pScrn) &&
	     i830_allocate_3d_memory(pScrn))
	 {
	    xf86DrvMsg(pScrn->scrnIndex, X_INFO, "Success.\n");
	    if (pScrn->displayWidth != savedDisplayWidth) {
	       xf86DrvMsg(pScrn->scrnIndex, X_INFO,
			  "Increasing the scanline pitch to allow tiling mode "
			  "(%d -> %d).\n",
			  savedDisplayWidth, pScrn->displayWidth);
	    }
	    allocation_done = TRUE;
	    break;
	 }

	 i830_reset_allocations(pScrn);
      }

      if (i == MM_TURNS) {
	 xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
		    "Not enough video memory.  Disabling DRI.\n");
	 pI830->directRenderingEnabled = FALSE;
      }
   }
#endif

   if (!allocation_done) {
      if (!i830_allocate_2d_memory(pScrn)) {
	 xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
		    "Couldn't allocate video memory\n");
	 return FALSE;
      }
      allocation_done = TRUE;
   }

   I830UnmapMMIO(pScrn);

   if (!IS_I965G(pI830) && pScrn->displayWidth > 2048) {
      xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
		 "Cannot support DRI with frame buffer width > 2048.\n");
      pI830->tiling = FALSE;
      pI830->directRenderingEnabled = FALSE;
d7264 11
d7277 67
d7371 7
d7379 1
a7379 1
      if (pI830->LpRing->mem->size == 0) {
d7387 9
d7403 1
a7403 1
      if (!IS_I9XX(pI830) && pI830->overlay_regs == NULL) {
d7412 2
d7416 5
d7434 2
d7437 1
a7437 1
      pI830->directRenderingEnabled = I830DRIDoMappings(pScreen);
d7439 6
a7444 27
   /* If we failed for any reason, free DRI memory. */
   if (!pI830->directRenderingEnabled)
      i830_free_3d_memory(pScrn);

   config = XF86_CRTC_CONFIG_PTR(pScrn);

   /*
    * If an LVDS display is present, swap the plane/pipe mappings so we can
    * use FBC on the builtin display.
    * Note: 965+ chips can compress either plane, so we leave the mapping
    *       alone in that case.
    * Also make sure the DRM can handle the swap.
    */
   if (I830LVDSPresent(pScrn) && !IS_I965GM(pI830) &&
       (!pI830->directRenderingEnabled ||
	(pI830->directRenderingEnabled && pI830->drmMinor >= 10))) {
       xf86DrvMsg(pScrn->scrnIndex, X_INFO, "adjusting plane->pipe mappings "
		  "to allow for framebuffer compression\n");
       for (c = 0; c < config->num_crtc; c++) {
	   xf86CrtcPtr	      crtc = config->crtc[c];
	   I830CrtcPrivatePtr   intel_crtc = crtc->driver_private;

	   if (intel_crtc->pipe == 0)
	       intel_crtc->plane = 1;
	   else if (intel_crtc->pipe == 1)
	       intel_crtc->plane = 0;
      }
d7451 16
d7468 4
a7471 3

   xf86DrvMsg(pScrn->scrnIndex, X_INFO, "Page Flipping %sabled\n",
	      pI830->allowPageFlip ? "en" : "dis");
d7481 1
a7481 1
      pScrn->fbOffset = pI830->front_buffer->offset;
d7483 1
a7483 1
      pScrn->fbOffset = pI8301->front_buffer_2->offset;
d7495 2
a7496 1
   DPRINTF(PFX, "assert( if(!I830EnterVT(scrnIndex, 0)) )\n");
d7498 1
a7498 13
   if (!pI830->useEXA) {
      if (I830IsPrimary(pScrn)) {
	 if (!I830InitFBManager(pScreen, &(pI830->FbMemBox))) {
	    xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
		       "Failed to init memory manager\n");
	 }
      } else {
	 if (!I830InitFBManager(pScreen, &(pI8301->FbMemBox2))) {
	    xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
		       "Failed to init memory manager\n");
	 }
      }
   }
d7500 2
a7501 2
    if (pScrn->virtualX > pScrn->displayWidth)
	pScrn->displayWidth = pScrn->virtualX;
d7525 1
a7525 1
   fbPictureInit(pScreen, NULL, 0);
d7529 1
a7529 1
   xf86DiDGAInit (pScreen, pI830->LinearAddr + pScrn->fbOffset);
d7533 16
a7569 11
#ifdef XF86DRI
   /* Must be called before EnterVT, so we can acquire the DRI lock when
    * binding our memory.
    */
   if (pI830->directRenderingEnabled)
      pI830->directRenderingEnabled = I830DRIFinishScreenInit(pScreen);
#endif

   if (!I830EnterVT(scrnIndex, 0))
      return FALSE;

d7575 1
a7575 1
   if (!xf86HandleColormaps(pScreen, 256, 8, I830LoadPalette, NULL,
d7581 1
a7581 1
   xf86DPMSInit(pScreen, xf86DPMSSet, 0);
d7589 6
d7603 1
a7603 1
      if (pI830->directRenderingDisabled)
d7612 39
a7650 2
   pI830->BlockHandler = pScreen->BlockHandler;
   pScreen->BlockHandler = I830BlockHandler;
d7652 2
a7653 12
   pScreen->SaveScreen = xf86SaveScreen;
   pI830->CloseScreen = pScreen->CloseScreen;
   pScreen->CloseScreen = I830CloseScreen;
   pI830->CreateScreenResources = pScreen->CreateScreenResources;
   pScreen->CreateScreenResources = i830CreateScreenResources;

   if (!xf86CrtcScreenInit (pScreen))
       return FALSE;
       
   /* Wrap pointer motion to flip touch screen around */
   pI830->PointerMoved = pScrn->PointerMoved;
   pScrn->PointerMoved = I830PointerMoved;
d7658 4
d7680 65
d7748 119
d7868 1
a7868 1
i830AdjustFrame(int scrnIndex, int x, int y, int flags)
a7870 1
   xf86CrtcConfigPtr	config = XF86_CRTC_CONFIG_PTR(pScrn);
a7871 2
   xf86OutputPtr  output = config->output[config->compat_output];
   xf86CrtcPtr	crtc = output->crtc;
d7873 264
a8136 2
   DPRINTF(PFX, "i830AdjustFrame: y = %d (+ %d), x = %d (+ %d)\n",
	   x, pI830->xoffset, y, pI830->yoffset);
d8138 6
a8143 7
   if (crtc && crtc->enabled)
   {
      /* Sync the engine before adjust frame */
      i830WaitSync(pScrn);
      i830PipeSetBase(crtc, crtc->desiredX + x, crtc->desiredY + y);
      crtc->x = output->initial_x + x;
      crtc->y = output->initial_y + y;
a8144 1
}
d8146 2
a8147 7
static void
I830FreeScreen(int scrnIndex, int flags)
{
   I830FreeRec(xf86Screens[scrnIndex]);
   if (xf86LoaderCheckSymbol("vgaHWFreeHWRec"))
      vgaHWFreeHWRec(xf86Screens[scrnIndex]);
}
d8149 3
a8151 5
static void
I830LeaveVT(int scrnIndex, int flags)
{
   ScrnInfoPtr pScrn = xf86Screens[scrnIndex];
   I830Ptr pI830 = I830PTR(pScrn);
d8153 1
a8153 1
   DPRINTF(PFX, "Leave VT\n");
d8155 6
a8160 1
   pI830->leaving = TRUE;
d8162 4
a8165 3
   if (pI830->devicesTimer)
      TimerCancel(pI830->devicesTimer);
   pI830->devicesTimer = NULL;
d8167 1
a8167 1
   i830SetHotkeyControl(pScrn, HOTKEY_BIOS_SWITCH);
d8169 8
a8176 4
   if (!I830IsPrimary(pScrn)) {
   	I830Ptr pI8301 = I830PTR(pI830->entityPrivate->pScrn_1);
	if (!pI8301->gtt_acquired) {
		return;
d8178 4
a8181 1
   }
d8183 3
a8185 3
#ifdef XF86DRI
   if (pI830->directRenderingOpen) {
      DRILock(screenInfo.screens[pScrn->scrnIndex], 0);
d8187 2
a8188 4
      I830DRISetVBlankInterrupt (pScrn, FALSE);
      drmCtlUninstHandler(pI830->drmSubFD);
   }
#endif
d8190 5
a8194 1
   xf86_hide_cursors (pScrn);
d8196 1
a8196 1
   RestoreHWState(pScrn);
d8198 2
a8199 1
   i830_stop_ring(pScrn, TRUE);
d8201 5
a8205 3
   if (pI830->debug_modes) {
      i830CompareRegsToSnapshot(pScrn, "After LeaveVT");
      i830DumpRegs (pScrn);
d8208 11
a8218 2
   if (I830IsPrimary(pScrn))
      i830_unbind_all_memory(pScrn);
d8220 14
a8233 7
   /* Tell the kernel to evict all buffer objects and block new buffer
    * allocations until we relese the lock.
    */
#ifdef XF86DRI_MM
   if (pI830->directRenderingOpen) {
      if (pI830->memory_manager != NULL && pScrn->vtSema) {
	 drmMMLock(pI830->drmSubFD, DRM_BO_MEM_TT, 1, 0);
a8235 1
#endif /* XF86DRI_MM */
d8237 1
a8237 2
   if (pI830->AccelInfoRec)
      pI830->AccelInfoRec->NeedToSync = FALSE;
d8239 1
a8239 1

d8244 1
a8244 1
I830EnterVT(int scrnIndex, int flags)
d8247 1
a8247 3
   I830Ptr  pI830 = I830PTR(pScrn);
   xf86CrtcConfigPtr	config = XF86_CRTC_CONFIG_PTR(pScrn);
   int o;
d8262 43
a8304 7
#ifdef XF86DRI_MM
   if (pI830->directRenderingEnabled) {
      /* Unlock the memory manager first of all so that we can pin our
       * buffer objects
       */
      if (pI830->memory_manager != NULL && pScrn->vtSema) {
	 drmMMUnlock(pI830->drmSubFD, DRM_BO_MEM_TT, 1);
d8307 3
a8309 1
#endif /* XF86DRI_MM */
d8312 1
a8312 1
      if (!i830_bind_all_memory(pScrn))
d8315 4
a8318 8
   i830_describe_allocations(pScrn, 1, "");

   /* Update the screen pixmap in case the buffer moved */
   i830_update_front_offset(pScrn);

   if (i830_check_error_state(pScrn)) {
      xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
		 "Existing errors found in hardware state.\n");
d8321 1
a8321 1
   i830_stop_ring(pScrn, FALSE);
d8324 4
a8327 10
   /* Clear the framebuffer */
   memset(pI830->FbBase + pScrn->fbOffset, 0,
	  pScrn->virtualY * pScrn->displayWidth * pI830->cpp);

   for (o = 0; o < config->num_output; o++) {
   	xf86OutputPtr  output = config->output[o];
	output->funcs->dpms(output, DPMSModeOff);
   }

   if (!xf86SetDesiredModes (pScrn))
d8330 3
a8332 5
   if (pI830->debug_modes) {
      xf86DrvMsg(pScrn->scrnIndex, X_INFO, "Hardware state at EnterVT:\n");
      i830DumpRegs (pScrn);
   }
   i830DescribeOutputConfiguration(pScrn);
d8334 1
a8334 1
   i830_stop_ring(pScrn, TRUE);
d8337 6
a8344 5
      /* Update buffer offsets in sarea and mappings, since buffer offsets
       * may have changed.
       */
      if (!i830_update_dri_buffers(pScrn))
	 FatalError("i830_update_dri_buffers() failed\n");
d8355 1
a8355 1
	 i830_refresh_ring(pScrn);
d8363 8
d8378 2
a8379 6
   /* Set the hotkey to just notify us.  We can check its results periodically
    * in the CheckDevicesTimer.  Eventually we want the kernel to just hand us
    * an input event when someone presses the button, but for now we just have
    * to poll.
    */
   i830SetHotkeyControl(pScrn, HOTKEY_DRIVER_NOTIFY);
d8384 4
a8387 3
   /* Mark 3D state as being clobbered and setup the basics */
   *pI830->last_3d = LAST_3D_OTHER;
   IntelEmitInvarientState(pScrn);
d8393 1
a8393 1
I830SwitchMode(int scrnIndex, DisplayModePtr mode, int flags)
d8395 1
d8398 149
d8548 24
a8571 1
   return xf86SetSingleMode (pScrn, mode, pI830->rotation);
d8575 1
a8575 1
I830CloseScreen(int scrnIndex, ScreenPtr pScreen)
a8578 1
#ifdef I830_USE_XAA
a8579 1
#endif
d8582 13
d8597 1
a8597 9
      I830LeaveVT(scrnIndex, 0);
#ifdef XF86DRI_MM
      if (pI830->directRenderingEnabled) {
 	 if (pI830->memory_manager != NULL) {
	    drmMMUnlock(pI830->drmSubFD, DRM_BO_MEM_TT, 1);
	 }
      }
#endif /* XF86DRI_MM */

d8610 1
a8610 1
      pI830->ScanlineColorExpandBuffers = NULL;
d8612 1
a8612 1
#ifdef I830_USE_XAA
a8618 9
#endif
#ifdef I830_USE_EXA
   if (pI830->useEXA && pI830->EXADriverPtr) {
       exaDriverFini(pScreen);
       xfree(pI830->EXADriverPtr);
       pI830->EXADriverPtr = NULL;
   }
#endif
   xf86_cursors_fini (pScreen);
d8620 3
a8622 14
   i830_allocator_fini(pScrn);
#ifdef XF86DRI
   if (pI830->directRenderingOpen) {
#ifdef DAMAGE
      if (pI830->pDamage) {
	 PixmapPtr pPix = pScreen->GetScreenPixmap(pScreen);

	 DamageUnregister(&pPix->drawable, pI830->pDamage);
	 DamageDestroy(pI830->pDamage);
	 pI830->pDamage = NULL;
      }
#endif
      pI830->directRenderingOpen = FALSE;
      I830DRICloseScreen(pScreen);
a8623 1
#endif
d8630 6
d8638 2
a8639 2
      xfree(pI830->last_3d);
      pI830->last_3d = NULL;
d8732 9
d8750 1
a8750 7
#if 0
/**
 * This function is used for testing of the screen detect functions from the
 * periodic timer.
 */
static void
i830MonitorDetectDebugger(ScrnInfoPtr pScrn)
d8752 2
a8753 3
   Bool found_crt;
   I830Ptr pI830 = I830PTR(pScrn);
   int start, finish, i;
d8755 4
a8758 10
   if (!pScrn->vtSema)
      return 1000;

   for (i = 0; i < xf86_config->num_output; i++) {
      enum output_status ret;
      char *result;

      start = GetTimeInMillis();
      ret = pI830->output[i].detect(pScrn, &pI830->output[i]);
      finish = GetTimeInMillis();
d8760 1
a8760 10
      if (ret == OUTPUT_STATUS_CONNECTED)
	 result = "connected";
      else if (ret == OUTPUT_STATUS_DISCONNECTED)
	 result = "disconnected";
      else
	 result = "unknown";

      xf86DrvMsg(pScrn->scrnIndex, X_ERROR, "Detected SDVO as %s in %dms\n",
		 result, finish - start);
   }
a8761 1
#endif
d8768 67
a8834 1
   CARD8 gr18;
d8836 120
a8955 2
   if (!pScrn->vtSema)
      return 1000;
d8958 3
a8960 1
   i830MonitorDetectDebugger(pScrn);
d8962 7
d8970 15
a8984 20
   /* Check for a hotkey press report from the BIOS. */
   gr18 = pI830->readControl(pI830, GRX, 0x18);
   if ((gr18 & (HOTKEY_TOGGLE | HOTKEY_SWITCH)) != 0) {
      /* The user has pressed the hotkey requesting a toggle or switch.
       * Re-probe our connected displays and turn on whatever we find.
       *
       * In the future, we want the hotkey to dump down to a user app which
       * implements a sensible policy using RandR-1.2.  For now, all we get
       * is this.
       */
      
      xf86ProbeOutputModes (pScrn, 0, 0);
      xf86SetScrnInfoModes (pScrn);
      xf86DiDGAReInit (pScrn->pScreen);
      xf86SwitchMode(pScrn->pScreen, pScrn->currentMode);

      /* Clear the BIOS's hotkey press flags */
      gr18 &= ~(HOTKEY_TOGGLE | HOTKEY_SWITCH);
      pI830->writeControl(pI830, GRX, 0x18, gr18);
   }
d8986 3
a8988 2
   return 1000;
}
d8990 17
a9006 4
void
i830WaitSync(ScrnInfoPtr pScrn)
{
   I830Ptr pI830 = I830PTR(pScrn);
d9008 40
a9047 14
#ifdef I830_USE_XAA
   if (!pI830->noAccel && !pI830->useEXA && pI830->AccelInfoRec 
	&& pI830->AccelInfoRec->NeedToSync) {
      (*pI830->AccelInfoRec->Sync)(pScrn);
      pI830->AccelInfoRec->NeedToSync = FALSE;
   }
#endif
#ifdef I830_USE_EXA
   if (!pI830->noAccel && pI830->useEXA && pI830->EXADriverPtr) {
	ScreenPtr pScreen = screenInfo.screens[pScrn->scrnIndex];
	exaWaitSync(pScreen);
   }
#endif
}
d9049 2
a9050 4
void
i830MarkSync(ScrnInfoPtr pScrn)
{
   I830Ptr pI830 = I830PTR(pScrn);
d9052 14
a9065 8
#ifdef I830_USE_XAA
   if (!pI830->useEXA && pI830->AccelInfoRec)
      pI830->AccelInfoRec->NeedToSync = TRUE;
#endif
#ifdef I830_USE_EXA
   if (pI830->useEXA && pI830->EXADriverPtr) {
      ScreenPtr pScreen = screenInfo.screens[pScrn->scrnIndex];
      exaMarkSync(pScreen);
d9067 3
a9069 1
#endif
d9075 7
a9081 7
   pScrn->PreInit = I830PreInit;
   pScrn->ScreenInit = I830ScreenInit;
   pScrn->SwitchMode = I830SwitchMode;
   pScrn->AdjustFrame = i830AdjustFrame;
   pScrn->EnterVT = I830EnterVT;
   pScrn->LeaveVT = I830LeaveVT;
   pScrn->FreeScreen = I830FreeScreen;
@


1.1.1.5
log
@Import intel driver v 2.2.0.90. tested by many, including krw@@ kettenis@@,
jakemsr@@, landry@@, beck@@ and oga@@. Thanks.
@
text
@d239 1
a239 1
   {PCI_CHIP_G35_G,		"G35"},
a246 1
   {PCI_CHIP_IGD_GM,		"Intel Integrated Graphics Device"},
d262 1
a262 1
   {PCI_CHIP_G35_G,		PCI_CHIP_G35_G,		RES_SHARED_VGA},
a269 1
   {PCI_CHIP_IGD_GM,		PCI_CHIP_IGD_GM,	RES_SHARED_VGA},
a298 1
   OPTION_FORCEENABLEPIPEA
a320 1
   {OPTION_FORCEENABLEPIPEA, "ForceEnablePipeA", OPTV_BOOLEAN,	{0},	FALSE},
a455 9
      case PGETBL_SIZE_1MB:
	 gtt_size = 1024;
	 break;
      case PGETBL_SIZE_2MB:
	 gtt_size = 2048;
	 break;
      case PGETBL_SIZE_1_5MB:
	 gtt_size = 1024 + 512;
	 break;
d510 1
a510 1
	 if (IS_I9XX(pI830))
d514 1
a514 1
	 if (IS_I9XX(pI830))
d600 2
a601 7
	 if (IS_IGD_GM(pI830)) {
	     gttaddr = pI830->MMIOAddr + MB(2);
	     pI830->GTTMapSize = MB(2);
	 } else {
	     gttaddr = pI830->MMIOAddr + KB(512);
	     pI830->GTTMapSize = KB(512);
	 }
a1179 3
   if (xf86ReturnOptValBool(pI830->Options, OPTION_FORCEENABLEPIPEA, FALSE))
       pI830->quirk_flag |= QUIRK_PIPEA_FORCE;

d1240 1
a1242 3
   case PCI_CHIP_G35_G:
      chipname = "G35";
      break;
a1263 3
   case PCI_CHIP_IGD_GM:
      chipname = "Intel Integrated Graphics Device";
      break;
a1908 1
       pI830->saveFBC_FENCE_OFF = INREG(FBC_FENCE_OFF);
a1993 7
/* Wait for the PLL to settle down after programming */
static void
i830_dpll_settle(void)
{
    usleep(10000); /* 10 ms *should* be plenty */
}

a2027 17
   /*
    * Pipe regs
    * To restore the saved state, we first need to program the PLL regs,
    * followed by the pipe configuration and finally the display plane
    * configuration.  The VGA registers can program one, both or neither
    * of the PLL regs, depending on their VGA_MOD_DIS bit value.
    */

   /*
    * Since either or both pipes may use the VGA clocks, make sure the
    * regs are valid.
    */
   OUTREG(VCLK_DIVISOR_VGA0, pI830->saveVCLK_DIVISOR_VGA0);
   OUTREG(VCLK_DIVISOR_VGA1, pI830->saveVCLK_DIVISOR_VGA1);
   OUTREG(VCLK_POST_DIV, pI830->saveVCLK_POST_DIV);

   /* If the pipe A PLL is active, we can restore the pipe & plane config */
d2036 1
a2036 1
   i830_dpll_settle();
d2041 1
a2041 1
   i830_dpll_settle();
a2042 1
   /* Restore mode config */
a2060 4

   OUTREG(PIPEACONF, pI830->savePIPEACONF);
   i830WaitForVblank(pScrn);

d2062 2
a2063 4
    * Program Pipe A's plane
    * The corresponding display plane may be disabled, and should only be
    * enabled if pipe A is actually on (otherwise we have a bug in the initial
    * state).
d2065 8
a2072 12
   if (pI830->saveDSPACNTR & DISPPLANE_SEL_PIPE_A) {
       OUTREG(DSPACNTR, pI830->saveDSPACNTR);
       OUTREG(DSPABASE, INREG(DSPABASE));
       i830WaitForVblank(pScrn);
   }
   if (pI830->saveDSPBCNTR & DISPPLANE_SEL_PIPE_A) {
       OUTREG(DSPBCNTR, pI830->saveDSPBCNTR);
       OUTREG(DSPBBASE, INREG(DSPBBASE));
       i830WaitForVblank(pScrn);
   }

   /* See note about pipe programming above */
a2074 1
      /* If the pipe B PLL is active, we can restore the pipe & plane config */
d2083 1
a2083 1
      i830_dpll_settle();
d2088 1
a2088 1
      i830_dpll_settle();
a2089 1
      /* Restore mode config */
a2107 3
      OUTREG(PIPEBCONF, pI830->savePIPEBCONF);
      i830WaitForVblank(pScrn);

d2109 1
a2109 3
       * Program Pipe B's plane
       * Note that pipe B may be disabled, and in that case, the plane
       * should also be disabled or we must have had a bad initial state.
d2111 7
a2117 10
      if (pI830->saveDSPACNTR & DISPPLANE_SEL_PIPE_B) {
	  OUTREG(DSPACNTR, pI830->saveDSPACNTR);
	  OUTREG(DSPABASE, INREG(DSPABASE));
	  i830WaitForVblank(pScrn);
      }
      if (pI830->saveDSPBCNTR & DISPPLANE_SEL_PIPE_B) {
	  OUTREG(DSPBCNTR, pI830->saveDSPBCNTR);
	  OUTREG(DSPBBASE, INREG(DSPBBASE));
	  i830WaitForVblank(pScrn);
      }
a2119 2
   OUTREG(VGACNTRL, pI830->saveVGACNTRL);

d2127 6
a2147 1
       OUTREG(FBC_FENCE_OFF, pI830->saveFBC_FENCE_OFF);
a2288 1
    pI830->BlockHandler = pScreen->BlockHandler;
d2451 1
a2451 2
   if (i830_fb_compression_supported(pI830) && !IS_I965GM(pI830)
	   && !IS_IGD_GM(pI830))
d2743 1
a2743 1
   if (I830LVDSPresent(pScrn) && !IS_I965GM(pI830) && !IS_IGD_GM(pI830) &&
a2867 4
   /* Must force it before EnterVT, so we are in control of VT and
    * later memory should be bound when allocating, e.g rotate_mem */
   pScrn->vtSema = TRUE;

a2870 12
   pI830->BlockHandler = pScreen->BlockHandler;
   pScreen->BlockHandler = I830BlockHandler;

   pScreen->SaveScreen = xf86SaveScreen;
   pI830->CloseScreen = pScreen->CloseScreen;
   pScreen->CloseScreen = I830CloseScreen;
   pI830->CreateScreenResources = pScreen->CreateScreenResources;
   pScreen->CreateScreenResources = i830CreateScreenResources;

   if (!xf86CrtcScreenInit (pScreen))
       return FALSE;

d2907 2
d2910 9
@


