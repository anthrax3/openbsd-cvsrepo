head	1.14;
access;
symbols
	OPENBSD_5_0:1.13.0.6
	OPENBSD_5_0_BASE:1.13
	OPENBSD_4_9:1.13.0.2
	OPENBSD_4_9_BASE:1.13
	OPENBSD_4_8:1.13.0.4
	OPENBSD_4_8_BASE:1.13
	OPENBSD_4_7:1.10.0.2
	OPENBSD_4_7_BASE:1.10
	OPENBSD_4_6:1.9.0.2
	OPENBSD_4_6_BASE:1.9
	OPENBSD_4_5:1.8.0.2
	OPENBSD_4_5_BASE:1.8
	OPENBSD_4_4:1.7.0.2
	OPENBSD_4_4_BASE:1.7
	OPENBSD_4_3_BASE:1.4
	OPENBSD_4_3:1.4.0.2
	v2_2_0_90:1.1.1.4
	v2_2_0:1.1.1.3
	OPENBSD_4_2:1.2.0.2
	OPENBSD_4_2_BASE:1.2
	v1_7_4:1.1.1.2
	v1_7_3:1.1.1.2
	v1_7_2:1.1.1.1
	xorg:1.1.1;
locks; strict;
comment	@ * @;


1.14
date	2011.11.29.12.39.03;	author oga;	state dead;
branches;
next	1.13;

1.13
date	2010.07.18.14.47.47;	author oga;	state Exp;
branches;
next	1.12;

1.12
date	2010.05.23.21.28.35;	author oga;	state Exp;
branches;
next	1.11;

1.11
date	2010.05.10.22.32.29;	author oga;	state Exp;
branches;
next	1.10;

1.10
date	2009.12.14.14.21.54;	author oga;	state Exp;
branches;
next	1.9;

1.9
date	2009.06.25.20.16.43;	author matthieu;	state Exp;
branches;
next	1.8;

1.8
date	2008.10.12.15.20.50;	author matthieu;	state Exp;
branches;
next	1.7;

1.7
date	2008.06.29.20.13.42;	author matthieu;	state Exp;
branches;
next	1.6;

1.6
date	2008.05.21.20.19.52;	author matthieu;	state Exp;
branches;
next	1.5;

1.5
date	2008.03.30.13.51.30;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2008.02.11.20.16.03;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2007.11.24.20.08.18;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2007.08.04.19.55.21;	author reyk;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.26.20.06.49;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.11.26.20.06.49;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2006.12.16.21.02.03;	author matthieu;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2007.11.24.19.44.42;	author matthieu;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2008.02.11.20.10.03;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.14
log
@Update the intel driver to a more recent version based on more recent
upsteam code.

Backporting keeping UMS changes by me, some bugfixes from kettenis@@.

Has been in snapshots for a while, committed on request so we can be
sure what people are running. This is a prerequesite for sandybridge
support but has those chipsets disabled for now until the correct code
has been added.
@
text
@/***************************************************************************

 Copyright 2000 Intel Corporation.  All Rights Reserved. 

 Permission is hereby granted, free of charge, to any person obtaining a 
 copy of this software and associated documentation files (the 
 "Software"), to deal in the Software without restriction, including 
 without limitation the rights to use, copy, modify, merge, publish, 
 distribute, sub license, and/or sell copies of the Software, and to 
 permit persons to whom the Software is furnished to do so, subject to 
 the following conditions: 

 The above copyright notice and this permission notice (including the 
 next paragraph) shall be included in all copies or substantial portions 
 of the Software. 

 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS 
 OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF 
 MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT. 
 IN NO EVENT SHALL INTEL, AND/OR ITS SUPPLIERS BE LIABLE FOR ANY CLAIM, 
 DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR 
 OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR 
 THE USE OR OTHER DEALINGS IN THE SOFTWARE.

 **************************************************************************/

/*
 * i830_video.c: i830/i845 Xv driver. 
 *
 * Copyright Â© 2002 by Alan Hourihane and David Dawes
 *
 * Authors: 
 *	Alan Hourihane <alanh@@tungstengraphics.com>
 *	David Dawes <dawes@@xfree86.org>
 *
 * Derived from i810 Xv driver:
 *
 * Authors of i810 code:
 * 	Jonathan Bian <jonathan.bian@@intel.com>
 *      Offscreen Images:
 *        Matt Sottek <matthew.j.sottek@@intel.com>
 */

/*
 * XXX Could support more formats.
 */

#ifdef HAVE_CONFIG_H
#include "config.h"
#endif

#include <inttypes.h>
#include <math.h>
#include <string.h>
#include <assert.h>

#include "xf86.h"
#include "xf86_OSproc.h"
#include "compiler.h"
#include "xf86PciInfo.h"
#include "xf86Pci.h"
#include "xf86fbman.h"
#include "regionstr.h"
#include "randrstr.h"
#include "windowstr.h"
#include "damage.h"
#include "i830.h"
#include "i830_video.h"
#include "xf86xv.h"
#include <X11/extensions/Xv.h>
#include "dixstruct.h"
#include "fourcc.h"

#ifdef INTEL_XVMC
#define _INTEL_XVMC_SERVER_
#include "i830_hwmc.h"
#endif

#define OFF_DELAY 	250	/* milliseconds */
#define FREE_DELAY 	15000

#define OFF_TIMER 	0x01
#define FREE_TIMER	0x02
#define CLIENT_VIDEO_ON	0x04

#define TIMER_MASK      (OFF_TIMER | FREE_TIMER)

static XF86VideoAdaptorPtr I830SetupImageVideoOverlay(ScreenPtr);
static XF86VideoAdaptorPtr I830SetupImageVideoTextured(ScreenPtr);
static void I830StopVideo(ScrnInfoPtr, pointer, Bool);
static int I830SetPortAttributeOverlay(ScrnInfoPtr, Atom, INT32, pointer);
static int I830SetPortAttributeTextured(ScrnInfoPtr, Atom, INT32, pointer);
static int I830GetPortAttribute(ScrnInfoPtr, Atom, INT32 *, pointer);
static void I830QueryBestSize(ScrnInfoPtr, Bool,
			      short, short, short, short, unsigned int *,
			      unsigned int *, pointer);
static int I830PutImageTextured(ScrnInfoPtr, short, short, short, short, short, short,
			short, short, int, unsigned char *, short, short,
			Bool, RegionPtr, pointer, DrawablePtr);
static int I830PutImageOverlay(ScrnInfoPtr, short, short, short, short, short, short,
			short, short, int, unsigned char *, short, short,
			Bool, RegionPtr, pointer, DrawablePtr);
static int I830QueryImageAttributes(ScrnInfoPtr, int, unsigned short *,
				    unsigned short *, int *, int *);

#define MAKE_ATOM(a) MakeAtom(a, sizeof(a) - 1, TRUE)

static Atom xvBrightness, xvContrast, xvSaturation, xvColorKey, xvPipe;
static Atom xvGamma0, xvGamma1, xvGamma2, xvGamma3, xvGamma4, xvGamma5;
static Atom xvSyncToVblank;

/* Limits for the overlay/textured video source sizes.  The documented hardware
 * limits are 2048x2048 or better for overlay and both of our textured video
 * implementations.  Additionally, on the 830 and 845, larger sizes resulted in
 * the card hanging, so we keep the limits lower there.
 */
#define IMAGE_MAX_WIDTH		2048
#define IMAGE_MAX_HEIGHT	2048
#define IMAGE_MAX_WIDTH_LEGACY	1024
#define IMAGE_MAX_HEIGHT_LEGACY	1088

/* overlay debugging printf function */
#if 0
#define OVERLAY_DEBUG ErrorF
#else
#define OVERLAY_DEBUG if (0) ErrorF
#endif

/*
 * OCMD - Overlay Command Register
 */
#define OCMD_REGISTER		0x30168
#define MIRROR_MODE		(0x3<<17)
#define MIRROR_HORIZONTAL	(0x1<<17)
#define MIRROR_VERTICAL		(0x2<<17)
#define MIRROR_BOTH		(0x3<<17)
#define OV_BYTE_ORDER		(0x3<<14)
#define UV_SWAP			(0x1<<14)
#define Y_SWAP			(0x2<<14)
#define Y_AND_UV_SWAP		(0x3<<14)
#define SOURCE_FORMAT		(0xf<<10)
#define RGB_888			(0x1<<10)
#define	RGB_555			(0x2<<10)
#define	RGB_565			(0x3<<10)
#define	YUV_422			(0x8<<10)
#define	YUV_411			(0x9<<10)
#define	YUV_420			(0xc<<10)
#define	YUV_422_PLANAR		(0xd<<10)
#define	YUV_410			(0xe<<10)
#define TVSYNC_FLIP_PARITY	(0x1<<9)
#define TVSYNC_FLIP_ENABLE	(0x1<<7)
#define BUF_TYPE		(0x1<<5)
#define BUF_TYPE_FRAME		(0x0<<5)
#define BUF_TYPE_FIELD		(0x1<<5)
#define TEST_MODE		(0x1<<4)
#define BUFFER_SELECT		(0x3<<2)
#define BUFFER0			(0x0<<2)
#define BUFFER1			(0x1<<2)
#define FIELD_SELECT		(0x1<<1)
#define FIELD0			(0x0<<1)
#define FIELD1			(0x1<<1)
#define OVERLAY_ENABLE		0x1

#define OFC_UPDATE		0x1

/* OCONFIG register */
#define CC_OUT_8BIT		(0x1<<3)
#define OVERLAY_PIPE_MASK	(0x1<<18)		
#define OVERLAY_PIPE_A		(0x0<<18)		
#define OVERLAY_PIPE_B		(0x1<<18)		
#define GAMMA2_ENBL		(0x1<<16)
#define CSC_MODE_BT709		(0x1<<5)
#define CSC_MODE_BT601		(0x0<<5)
#define THREE_LINE_BUFFERS	(0x1<<0)
#define TWO_LINE_BUFFERS	(0x0<<0)

/* DCLRKM register */
#define DEST_KEY_ENABLE		(0x1<<31)

/* Polyphase filter coefficients */
#define N_HORIZ_Y_TAPS		5
#define N_VERT_Y_TAPS		3
#define N_HORIZ_UV_TAPS		3
#define N_VERT_UV_TAPS		3
#define N_PHASES		17
#define MAX_TAPS		5

/* Filter cutoff frequency limits. */
#define MIN_CUTOFF_FREQ		1.0
#define MAX_CUTOFF_FREQ		3.0

#define RGB16ToColorKey(c) \
(((c & 0xF800) << 8) | ((c & 0x07E0) << 5) | ((c & 0x001F) << 3))

#define RGB15ToColorKey(c) \
(((c & 0x7c00) << 9) | ((c & 0x03E0) << 6) | ((c & 0x001F) << 3))

/* client libraries expect an encoding */
static XF86VideoEncodingRec DummyEncoding[1] = {
	{
	 0,
	 "XV_IMAGE",
	 IMAGE_MAX_WIDTH, IMAGE_MAX_HEIGHT,
	 {1, 1}
	 }
};

#define NUM_FORMATS 3

static XF86VideoFormatRec Formats[NUM_FORMATS] = {
	{15, TrueColor}, {16, TrueColor}, {24, TrueColor}
};

#define CLONE_ATTRIBUTES 1
static XF86AttributeRec CloneAttributes[CLONE_ATTRIBUTES] = {
	{XvSettable | XvGettable, -1, 1, "XV_PIPE"}
};

#define NUM_ATTRIBUTES 4
static XF86AttributeRec Attributes[NUM_ATTRIBUTES] = {
	{XvSettable | XvGettable, 0, (1 << 24) - 1, "XV_COLORKEY"},
	{XvSettable | XvGettable, -128, 127, "XV_BRIGHTNESS"},
	{XvSettable | XvGettable, 0, 255, "XV_CONTRAST"},
	{XvSettable | XvGettable, 0, 1023, "XV_SATURATION"}
};

#define NUM_TEXTURED_ATTRIBUTES 3
static XF86AttributeRec TexturedAttributes[NUM_TEXTURED_ATTRIBUTES] = {
	{XvSettable | XvGettable, -128, 127, "XV_BRIGHTNESS"},
	{XvSettable | XvGettable, 0, 255, "XV_CONTRAST"},
	{XvSettable | XvGettable, -1, 1, "XV_SYNC_TO_VBLANK"},
};

#define GAMMA_ATTRIBUTES 6
static XF86AttributeRec GammaAttributes[GAMMA_ATTRIBUTES] = {
	{XvSettable | XvGettable, 0, 0xffffff, "XV_GAMMA0"},
	{XvSettable | XvGettable, 0, 0xffffff, "XV_GAMMA1"},
	{XvSettable | XvGettable, 0, 0xffffff, "XV_GAMMA2"},
	{XvSettable | XvGettable, 0, 0xffffff, "XV_GAMMA3"},
	{XvSettable | XvGettable, 0, 0xffffff, "XV_GAMMA4"},
	{XvSettable | XvGettable, 0, 0xffffff, "XV_GAMMA5"}
};

#ifdef INTEL_XVMC
#define NUM_IMAGES 5
#define XVMC_IMAGE 1
#else
#define NUM_IMAGES 4
#define XVMC_IMAGE 0
#endif

static XF86ImageRec Images[NUM_IMAGES] = {
	XVIMAGE_YUY2,
	XVIMAGE_YV12,
	XVIMAGE_I420,
	XVIMAGE_UYVY,
#ifdef INTEL_XVMC
	{
	 /*
	  * Below, a dummy picture type that is used in XvPutImage only to do
	  * an overlay update. Introduced for the XvMC client lib.
	  * Defined to have a zero data size.
	  */
	 FOURCC_XVMC,
	 XvYUV,
	 LSBFirst,
	 {'X', 'V', 'M', 'C',
	  0x00, 0x00, 0x00, 0x10, 0x80, 0x00, 0x00, 0xAA, 0x00,
	  0x38, 0x9B, 0x71},
	 12,
	 XvPlanar,
	 3,
	 0, 0, 0, 0,
	 8, 8, 8,
	 1, 2, 2,
	 1, 2, 2,
	 {'Y', 'V', 'U',
	  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	  0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
	 XvTopToBottom},
#endif
};

typedef struct {
    uint32_t OBUF_0Y;
    uint32_t OBUF_1Y;
    uint32_t OBUF_0U;
    uint32_t OBUF_0V;
    uint32_t OBUF_1U;
    uint32_t OBUF_1V;
    uint32_t OSTRIDE;
    uint32_t YRGB_VPH;
    uint32_t UV_VPH;
    uint32_t HORZ_PH;
    uint32_t INIT_PHS;
    uint32_t DWINPOS;
    uint32_t DWINSZ;
    uint32_t SWIDTH;
    uint32_t SWIDTHSW;
    uint32_t SHEIGHT;
    uint32_t YRGBSCALE;
    uint32_t UVSCALE;
    uint32_t OCLRC0;
    uint32_t OCLRC1;
    uint32_t DCLRKV;
    uint32_t DCLRKM;
    uint32_t SCLRKVH;
    uint32_t SCLRKVL;
    uint32_t SCLRKEN;
    uint32_t OCONFIG;
    uint32_t OCMD;
    uint32_t RESERVED1;			/* 0x6C */
    uint32_t OSTART_0Y; 		/* for i965 */
    uint32_t OSTART_1Y;		/* for i965 */
    uint32_t OSTART_0U;
    uint32_t OSTART_0V;
    uint32_t OSTART_1U;
    uint32_t OSTART_1V;
    uint32_t OTILEOFF_0Y;
    uint32_t OTILEOFF_1Y;
    uint32_t OTILEOFF_0U;
    uint32_t OTILEOFF_0V;
    uint32_t OTILEOFF_1U;
    uint32_t OTILEOFF_1V;
    uint32_t FASTHSCALE;			/* 0xA0 */
    uint32_t UVSCALEV;			/* 0xA4 */

    uint32_t RESERVEDC[(0x200 - 0xA8) / 4];		   /* 0xA8 - 0x1FC */
    uint16_t Y_VCOEFS[N_VERT_Y_TAPS * N_PHASES];		   /* 0x200 */
    uint16_t RESERVEDD[0x100 / 2 - N_VERT_Y_TAPS * N_PHASES];
    uint16_t Y_HCOEFS[N_HORIZ_Y_TAPS * N_PHASES];		   /* 0x300 */
    uint16_t RESERVEDE[0x200 / 2 - N_HORIZ_Y_TAPS * N_PHASES];
    uint16_t UV_VCOEFS[N_VERT_UV_TAPS * N_PHASES];		   /* 0x500 */
    uint16_t RESERVEDF[0x100 / 2 - N_VERT_UV_TAPS * N_PHASES];
    uint16_t UV_HCOEFS[N_HORIZ_UV_TAPS * N_PHASES];	   /* 0x600 */
    uint16_t RESERVEDG[0x100 / 2 - N_HORIZ_UV_TAPS * N_PHASES];
} I830OverlayRegRec, *I830OverlayRegPtr;

#define I830OVERLAYREG(intel) ((I830OverlayRegPtr)\
			       ((intel)->FbBase + \
				(intel)->overlay_regs->offset))
#if VIDEO_DEBUG
static void CompareOverlay(intel_screen_private *intel, uint32_t * overlay, int size)
{
	int i;
	uint32_t val;
	int bad = 0;

	for (i = 0; i < size; i += 4) {
		val = INREG(0x30100 + i);
		if (val != overlay[i / 4]) {
			OVERLAY_DEBUG
			    ("0x%05x value doesn't match (0x%lx != 0x%lx)\n",
			     0x30100 + i, val, overlay[i / 4]);
			bad++;
		}
	}
	if (!bad)
		OVERLAY_DEBUG("CompareOverlay: no differences\n");
}
#endif

static void I830SetOneLineModeRatio(ScrnInfoPtr scrn);

static void
i830_overlay_switch_to_crtc (ScrnInfoPtr scrn, xf86CrtcPtr crtc)
{
	intel_screen_private *intel = intel_get_screen_private(scrn);
	intel_adaptor_private *adaptor_priv = intel->adaptor->pPortPrivates[0].ptr;
	I830CrtcPrivatePtr  intel_crtc = crtc->driver_private;
	int			pipeconf_reg = intel_crtc->pipe == 0 ? PIPEACONF : PIPEBCONF;

    /* overlay can't be used on pipe with double wide, and pipe must be enabled. */
    if ((!IS_I965G(intel) && (INREG(pipeconf_reg) & PIPEACONF_DOUBLE_WIDE))
	    || (intel_crtc->dpms_mode == DPMSModeOff))
	adaptor_priv->overlayOK = FALSE;
    else
	adaptor_priv->overlayOK = TRUE;

    if (!adaptor_priv->overlayOK)
	return;

    /* Check we have an LFP connected */
    if (i830PipeHasType(crtc, I830_OUTPUT_LVDS)) 
    {

	int	vtotal_reg = intel_crtc->pipe == 0 ? VTOTAL_A : VTOTAL_B;
	uint32_t size = intel_crtc->pipe ? INREG(PIPEBSRC) : INREG(PIPEASRC);
	uint32_t active;
	uint32_t hsize, vsize;

	hsize = (size >> 16) & 0x7FF;
	vsize = size & 0x7FF;
	active = INREG(vtotal_reg) & 0x7FF;

	if (vsize < active && hsize > 1024)
	    I830SetOneLineModeRatio(scrn);

	if (adaptor_priv->scaleRatio & 0xFFFE0000) 
	{
	    /* Possible bogus ratio, using in-accurate fallback */
	    xf86DrvMsg(scrn->scrnIndex, X_WARNING,
		       "Bogus panel fit register, Xvideo positioning may not "
		       "be accurate.\n");
	    xf86DrvMsg(scrn->scrnIndex, X_WARNING,
		       "Using fallback ratio - was 0x%x, now 0x%x\n",
		       adaptor_priv->scaleRatio,
		       (int)(((float)active * 65536)/(float)vsize));

	    adaptor_priv->scaleRatio = (int)(((float)active * 65536) / (float)vsize);
	}
    }
}

/*
 * This is more or less the correct way to initalise, update, and shut down
 * the overlay.
 *
 * XXX Need to make sure that the overlay engine is cleanly shutdown in
 * all modes of server exit.
 */

static void
i830_overlay_on(ScrnInfoPtr scrn)
{
    intel_screen_private *intel = intel_get_screen_private(scrn);
    I830OverlayRegPtr	overlay = I830OVERLAYREG(intel);
    intel_adaptor_private *adaptor_priv = intel->adaptor->pPortPrivates[0].ptr;
    Bool		deactivate = FALSE;
    
    if (intel->overlayOn)
	return;

    /*
     * On I830, if pipe A is off when the overlayis enabled, it will fail to
     * turn on and blank the entire screen or lock up the ring. Light up pipe
     * A in this case to provide a clock for the overlay hardware
     */
    if (adaptor_priv->current_crtc && i830_crtc_pipe (adaptor_priv->current_crtc) != 0)
	deactivate = i830_pipe_a_require_activate (scrn);

    overlay->OCMD &= ~OVERLAY_ENABLE;
    BEGIN_BATCH(6);
    OUT_BATCH(MI_FLUSH | MI_WRITE_DIRTY_STATE);
    OUT_BATCH(MI_NOOP);
    OUT_BATCH(MI_OVERLAY_FLIP | MI_OVERLAY_FLIP_ON);
    if (OVERLAY_NOPHYSICAL(intel))
	OUT_BATCH(intel->overlay_regs->offset | OFC_UPDATE);
    else
	OUT_BATCH(intel->overlay_regs->bus_addr | OFC_UPDATE);
    /* Wait for the overlay to light up before attempting to use it */
    OUT_BATCH(MI_WAIT_FOR_EVENT | MI_WAIT_FOR_OVERLAY_FLIP);
    OUT_BATCH(MI_NOOP);
    ADVANCE_BATCH();
    intel_sync(scrn);
    
    /*
     * If we turned pipe A on up above, turn it
     * back off
     */
    if (deactivate)
	i830_pipe_a_require_deactivate (scrn);

    OVERLAY_DEBUG("overlay_on\n");
    intel->overlayOn = TRUE;

    overlay->OCMD |= OVERLAY_ENABLE;
}

static void
i830_overlay_continue(ScrnInfoPtr scrn, Bool update_filter)
{
    intel_screen_private *intel = intel_get_screen_private(scrn);
    uint32_t		flip_addr;
    I830OverlayRegPtr	overlay = I830OVERLAYREG(intel);

    if (!intel->overlayOn)
	return;

    if (OVERLAY_NOPHYSICAL(intel))
	flip_addr = intel->overlay_regs->offset;
    else
	flip_addr = intel->overlay_regs->bus_addr;
    if (update_filter)
	flip_addr |= OFC_UPDATE;
    OVERLAY_DEBUG ("overlay_continue cmd 0x%08x  -> 0x%08x sta 0x%08x\n",
		   overlay->OCMD, INREG(OCMD_REGISTER), INREG(DOVSTA));
    BEGIN_BATCH(4);
    OUT_BATCH(MI_FLUSH | MI_WRITE_DIRTY_STATE);
    OUT_BATCH(MI_NOOP);
    OUT_BATCH(MI_OVERLAY_FLIP | MI_OVERLAY_FLIP_CONTINUE);
    OUT_BATCH(flip_addr);
    ADVANCE_BATCH();
    OVERLAY_DEBUG("overlay_continue\n");

    intel_sync(scrn);
}

static void
i830_overlay_off(ScrnInfoPtr scrn)
{
    intel_screen_private *intel = intel_get_screen_private(scrn);
    I830OverlayRegPtr	overlay = I830OVERLAYREG(intel);

    if (!intel->overlayOn)
	return;

    /*
     * Wait for overlay to go idle. This has to be
     * separated from the turning off state by a Sync
     * to ensure the overlay will not read OCMD early and
     * disable the overlay before the commands here are
     * executed
     */
    {
	BEGIN_BATCH(2);
	OUT_BATCH(MI_WAIT_FOR_EVENT | MI_WAIT_FOR_OVERLAY_FLIP);
	OUT_BATCH(MI_NOOP);
	ADVANCE_BATCH();
	intel_sync(scrn);
    }
    
    /*
     * Turn overlay off
     */
    {
	overlay->OCMD &= ~OVERLAY_ENABLE;
	OVERLAY_DEBUG ("overlay_off cmd 0x%08x -> 0x%08x sta 0x%08x\n",
		       overlay->OCMD, INREG(OCMD_REGISTER), INREG(DOVSTA));
	BEGIN_BATCH(6);
	OUT_BATCH(MI_FLUSH | MI_WRITE_DIRTY_STATE);
	OUT_BATCH(MI_NOOP);
	OUT_BATCH(MI_OVERLAY_FLIP | MI_OVERLAY_FLIP_CONTINUE);
	if (OVERLAY_NOPHYSICAL(intel))
	    OUT_BATCH(intel->overlay_regs->offset);
	else
	    OUT_BATCH(intel->overlay_regs->bus_addr);
	OUT_BATCH(MI_WAIT_FOR_EVENT | MI_WAIT_FOR_OVERLAY_FLIP);
	OUT_BATCH(MI_NOOP);
	ADVANCE_BATCH();
	intel_sync(scrn);
    }
    intel->overlayOn = FALSE;
    OVERLAY_DEBUG("overlay_off\n");
}

void I830InitVideo(ScreenPtr screen)
{
	ScrnInfoPtr scrn = xf86Screens[screen->myNum];
	intel_screen_private *intel = intel_get_screen_private(scrn);
	XF86VideoAdaptorPtr *adaptors, *newAdaptors = NULL;
	XF86VideoAdaptorPtr overlayAdaptor = NULL, texturedAdaptor = NULL;
	int num_adaptors;

	num_adaptors = xf86XVListGenericAdaptors(scrn, &adaptors);
	/* Give our adaptor list enough space for the overlay and/or texture video
	 * adaptors.
	 */
	newAdaptors =
	    malloc((num_adaptors + 2) * sizeof(XF86VideoAdaptorPtr *));
	if (newAdaptors == NULL)
		return;

	memcpy(newAdaptors, adaptors,
	       num_adaptors * sizeof(XF86VideoAdaptorPtr));
	adaptors = newAdaptors;

	/* Add the adaptors supported by our hardware.  First, set up the atoms
	 * that will be used by both output adaptors.
	 */
	xvBrightness = MAKE_ATOM("XV_BRIGHTNESS");
	xvContrast = MAKE_ATOM("XV_CONTRAST");

	/* Set up textured video if we can do it at this depth and we are on
	 * supported hardware.
	 */
	if (scrn->bitsPerPixel >= 16 && (IS_I9XX(intel) || IS_I965G(intel))) {
		texturedAdaptor = I830SetupImageVideoTextured(screen);
		if (texturedAdaptor != NULL) {
			xf86DrvMsg(scrn->scrnIndex, X_INFO,
				   "Set up textured video\n");
		} else {
			xf86DrvMsg(scrn->scrnIndex, X_ERROR,
				   "Failed to set up textured video\n");
		}
	}

	/* Set up overlay video if we can do it at this depth. */
	if (!OVERLAY_NOEXIST(intel) && scrn->bitsPerPixel != 8 &&
	    !intel->use_drm_mode && intel->overlay_regs != NULL) {
		overlayAdaptor = I830SetupImageVideoOverlay(screen);
		if (overlayAdaptor != NULL) {
			xf86DrvMsg(scrn->scrnIndex, X_INFO, "Set up overlay video\n");
		} else {
			xf86DrvMsg(scrn->scrnIndex, X_ERROR,
			    "Failed to set up overlay video\n");
		}
	}

	if (overlayAdaptor && intel->XvPreferOverlay)
	adaptors[num_adaptors++] = overlayAdaptor;

	if (texturedAdaptor)
		adaptors[num_adaptors++] = texturedAdaptor;

	if (overlayAdaptor && !intel->XvPreferOverlay)
		adaptors[num_adaptors++] = overlayAdaptor;

	if (num_adaptors) {
		xf86XVScreenInit(screen, adaptors, num_adaptors);
	} else {
		xf86DrvMsg(scrn->scrnIndex, X_WARNING,
			   "Disabling Xv because no adaptors could be initialized.\n");
		intel->XvEnabled = FALSE;
	}

#ifdef INTEL_XVMC
	if (texturedAdaptor)
		intel_xvmc_adaptor_init(screen);
#endif
	free(adaptors);
}

static void
I830ResetVideo(ScrnInfoPtr scrn)
{
    intel_screen_private *intel = intel_get_screen_private(scrn);
    intel_adaptor_private *adaptor_priv = intel->adaptor->pPortPrivates[0].ptr;
    I830OverlayRegPtr	overlay = I830OVERLAYREG(intel);

    OVERLAY_DEBUG("I830ResetVideo: base: %p, offset: 0x%lx, obase: %p\n",
		  intel->FbBase, intel->overlay_regs->offset, overlay);
    /*
     * Default to maximum image size in YV12
     */

    memset(overlay, 0, sizeof(*overlay));
    overlay->YRGB_VPH = 0;
    overlay->UV_VPH = 0;
    overlay->HORZ_PH = 0;
    overlay->INIT_PHS = 0;
    overlay->DWINPOS = 0;
    overlay->DWINSZ = 0;
    overlay->SWIDTH = 0;
    overlay->SWIDTHSW = 0;
    overlay->SHEIGHT = 0;
    overlay->OCLRC0 = (adaptor_priv->contrast << 18) | (adaptor_priv->brightness & 0xff);
    overlay->OCLRC1 = adaptor_priv->saturation;
#if 0
    overlay->AWINPOS = 0;
    overlay->AWINSZ = 0;
#endif
    overlay->FASTHSCALE = 0;

    /*
     * Enable destination color keying
     */
    switch (scrn->depth) {
    case 8:
	overlay->DCLRKV = 0;
	overlay->DCLRKM = 0xffffff | DEST_KEY_ENABLE;
	break;
    case 15:
	overlay->DCLRKV = RGB15ToColorKey(adaptor_priv->colorKey);
	overlay->DCLRKM = 0x070707 | DEST_KEY_ENABLE;
	break;
    case 16:
	overlay->DCLRKV = RGB16ToColorKey(adaptor_priv->colorKey);
	overlay->DCLRKM = 0x070307 | DEST_KEY_ENABLE;
	break;
    default:
	overlay->DCLRKV = adaptor_priv->colorKey;
	overlay->DCLRKM = DEST_KEY_ENABLE;
	break;
    }

    overlay->SCLRKVH = 0;
    overlay->SCLRKVL = 0;
    overlay->SCLRKEN = 0;		/* source color key disable */
    overlay->OCONFIG = CC_OUT_8BIT;
    if (IS_I965GM(intel))
	overlay->OCONFIG |= CSC_MODE_BT709;

    /*
     * Select which pipe the overlay is enabled on.
     */
    overlay->OCONFIG &= ~OVERLAY_PIPE_MASK;
    if (i830_crtc_pipe (adaptor_priv->current_crtc) == 0)
	overlay->OCONFIG |= OVERLAY_PIPE_A;
    else 
	overlay->OCONFIG |= OVERLAY_PIPE_B;

#if 0
    /* 
     * XXX DUMP REGISTER CODE !!!
     * This allows us to dump the complete i845 registers and compare
     * with warm boot situations before we upload our first copy.
     */
    {
	int i;
	for (i = 0x30000; i < 0x31000; i += 4)
	    ErrorF("0x%x 0x%" PRIx32 "\n", i, INREG(i));
    }
#endif
}

#define PFIT_CONTROLS 0x61230
#define PFIT_AUTOVSCALE_MASK 0x200
#define PFIT_ON_MASK 0x80000000
#define PFIT_AUTOSCALE_RATIO 0x61238
#define PFIT_PROGRAMMED_SCALE_RATIO 0x61234

static void
I830SetOneLineModeRatio(ScrnInfoPtr scrn)
{
    intel_screen_private *intel = intel_get_screen_private(scrn);
    intel_adaptor_private *adaptor_priv = intel->adaptor->pPortPrivates[0].ptr;
    uint32_t panelFitControl = INREG(PFIT_CONTROLS);
    int vertScale;

    adaptor_priv->scaleRatio = 0x10000;

    if (panelFitControl & PFIT_ON_MASK) {
	if (panelFitControl & PFIT_AUTOVSCALE_MASK) {
	    vertScale = INREG(PFIT_AUTOSCALE_RATIO) >> 16;
	} else {
	    vertScale = INREG(PFIT_PROGRAMMED_SCALE_RATIO) >> 16;
	}

	if (vertScale != 0)
	    adaptor_priv->scaleRatio = ((double) 0x10000 / (double)vertScale) * 0x10000;

	adaptor_priv->oneLineMode = TRUE;

	xf86DrvMsg(scrn->scrnIndex, X_INFO, "Enabling Xvideo one-line mode\n");
    }

    if (adaptor_priv->scaleRatio == 0x10000)
	adaptor_priv->oneLineMode = FALSE;
}

static uint32_t I830BoundGammaElt (uint32_t elt, uint32_t eltPrev)
{
    elt &= 0xff;
    eltPrev &= 0xff;
    if (elt < eltPrev)
	elt = eltPrev;
    else if ((elt - eltPrev) > 0x7e)
	elt = eltPrev + 0x7e;
    return elt;
}

static uint32_t I830BoundGamma (uint32_t gamma, uint32_t gammaPrev)
{
    return (I830BoundGammaElt (gamma >> 16, gammaPrev >> 16) << 16 |
	    I830BoundGammaElt (gamma >>  8, gammaPrev >>  8) <<  8 |
	    I830BoundGammaElt (gamma      , gammaPrev      ));
}

static uint32_t I830Gamma5Errata(uint32_t gamma)
{
    int i;

    for (i = 0; i < 3; i++) {
	if ((gamma >> i*8 & 0xff) == 0x80) {
	    /* According to Intel docs, overlay fails if GAMMA5 is 0x80.
	     * In this case, change the value to 0x81 */
	    gamma += 1 << i*8;
	}
    }

    return gamma;
}

static void
I830UpdateGamma(ScrnInfoPtr scrn)
{
    intel_screen_private *intel = intel_get_screen_private(scrn);
    intel_adaptor_private *adaptor_priv = intel->adaptor->pPortPrivates[0].ptr;
    uint32_t gamma0 = adaptor_priv->gamma0;
    uint32_t gamma1 = adaptor_priv->gamma1;
    uint32_t gamma2 = adaptor_priv->gamma2;
    uint32_t gamma3 = adaptor_priv->gamma3;
    uint32_t gamma4 = adaptor_priv->gamma4;
    uint32_t gamma5 = adaptor_priv->gamma5;

#if 0
    ErrorF ("Original gamma: 0x%lx 0x%lx 0x%lx 0x%lx 0x%lx 0x%lx\n",
	    gamma0, gamma1, gamma2, gamma3, gamma4, gamma5);
#endif
    gamma1 = I830BoundGamma (gamma1, gamma0);
    gamma2 = I830BoundGamma (gamma2, gamma1);
    gamma3 = I830BoundGamma (gamma3, gamma2);
    gamma4 = I830BoundGamma (gamma4, gamma3);
    gamma5 = I830BoundGamma (gamma5, gamma4);
    gamma5 = I830Gamma5Errata(gamma5);
#if 0
    ErrorF ("Bounded  gamma: 0x%lx 0x%lx 0x%lx 0x%lx 0x%lx 0x%lx\n",
	    gamma0, gamma1, gamma2, gamma3, gamma4, gamma5);
#endif

    OUTREG(OGAMC5, gamma5);
    OUTREG(OGAMC4, gamma4);
    OUTREG(OGAMC3, gamma3);
    OUTREG(OGAMC2, gamma2);
    OUTREG(OGAMC1, gamma1);
    OUTREG(OGAMC0, gamma0);
}

static XF86VideoAdaptorPtr I830SetupImageVideoOverlay(ScreenPtr screen)
{
	ScrnInfoPtr scrn = xf86Screens[screen->myNum];
	intel_screen_private *intel = intel_get_screen_private(scrn);
	XF86VideoAdaptorPtr adapt;
	intel_adaptor_private *adaptor_priv;
	XF86AttributePtr att;

	OVERLAY_DEBUG("I830SetupImageVideoOverlay\n");

	if (!(adapt = calloc(1, sizeof(XF86VideoAdaptorRec) +
			      sizeof(intel_adaptor_private) + sizeof(DevUnion))))
		return NULL;

	adapt->type = XvWindowMask | XvInputMask | XvImageMask;
	adapt->flags = VIDEO_OVERLAID_IMAGES /*| VIDEO_CLIP_TO_VIEWPORT */ ;
	adapt->name = "Intel(R) Video Overlay";
	adapt->nEncodings = 1;
	adapt->pEncodings = DummyEncoding;
	/* update the DummyEncoding for these two chipsets */
	if (IS_845G(intel) || IS_I830(intel)) {
		adapt->pEncodings->width = IMAGE_MAX_WIDTH_LEGACY;
		adapt->pEncodings->height = IMAGE_MAX_HEIGHT_LEGACY;
	}
	adapt->nFormats = NUM_FORMATS;
	adapt->pFormats = Formats;
	adapt->nPorts = 1;
	adapt->pPortPrivates = (DevUnion *) (&adapt[1]);

	adaptor_priv = (intel_adaptor_private *)&adapt->pPortPrivates[1];

	adapt->pPortPrivates[0].ptr = (pointer) (adaptor_priv);
	adapt->nAttributes = NUM_ATTRIBUTES;
	adapt->nAttributes += CLONE_ATTRIBUTES;
	if (IS_I9XX(intel))
		adapt->nAttributes += GAMMA_ATTRIBUTES;	/* has gamma */
	adapt->pAttributes =
	    xnfalloc(sizeof(XF86AttributeRec) * adapt->nAttributes);
	/* Now copy the attributes */
	att = adapt->pAttributes;
	memcpy((char *)att, (char *)Attributes,
	       sizeof(XF86AttributeRec) * NUM_ATTRIBUTES);
	att += NUM_ATTRIBUTES;
	memcpy((char *)att, (char *)CloneAttributes,
	       sizeof(XF86AttributeRec) * CLONE_ATTRIBUTES);
	att += CLONE_ATTRIBUTES;
	if (IS_I9XX(intel)) {
		memcpy((char *)att, (char *)GammaAttributes,
		       sizeof(XF86AttributeRec) * GAMMA_ATTRIBUTES);
		att += GAMMA_ATTRIBUTES;
	}
	adapt->nImages = NUM_IMAGES - XVMC_IMAGE;

	adapt->pImages = Images;
	adapt->PutVideo = NULL;
	adapt->PutStill = NULL;
	adapt->GetVideo = NULL;
	adapt->GetStill = NULL;
	adapt->StopVideo = I830StopVideo;
	adapt->SetPortAttribute = I830SetPortAttributeOverlay;
	adapt->GetPortAttribute = I830GetPortAttribute;
	adapt->QueryBestSize = I830QueryBestSize;
	adapt->PutImage = I830PutImageOverlay;
	adapt->QueryImageAttributes = I830QueryImageAttributes;

	adaptor_priv->textured = FALSE;
	adaptor_priv->colorKey = intel->colorKey & ((1 << scrn->depth) - 1);
	adaptor_priv->videoStatus = 0;
	adaptor_priv->brightness = -19;	/* (255/219) * -16 */
	adaptor_priv->contrast = 75;	/* 255/219 * 64 */
	adaptor_priv->saturation = 146;	/* 128/112 * 128 */
	adaptor_priv->current_crtc = NULL;
	adaptor_priv->desired_crtc = NULL;
	adaptor_priv->buf = NULL;
	adaptor_priv->oldBuf = NULL;
	adaptor_priv->oldBuf_pinned = FALSE;
	adaptor_priv->gamma5 = 0xc0c0c0;
	adaptor_priv->gamma4 = 0x808080;
	adaptor_priv->gamma3 = 0x404040;
	adaptor_priv->gamma2 = 0x202020;
	adaptor_priv->gamma1 = 0x101010;
	adaptor_priv->gamma0 = 0x080808;

	adaptor_priv->rotation = RR_Rotate_0;

	/* gotta uninit this someplace */
	REGION_NULL(screen, &adaptor_priv->clip);

	intel->adaptor = adapt;

	/* With LFP's we need to detect whether we're in One Line Mode, which
	 * essentially means a resolution greater than 1024x768, and fix up
	 * the scaler accordingly. */
	adaptor_priv->scaleRatio = 0x10000;
	adaptor_priv->oneLineMode = FALSE;

	/*
	 * Initialise adaptor_priv->overlayOK.  Set it to TRUE here so that a
	 * warning will be generated if i830_crtc_dpms_video() sets it to
	 * FALSE during mode setup.
	 */
	adaptor_priv->overlayOK = TRUE;

	xvColorKey = MAKE_ATOM("XV_COLORKEY");
	xvBrightness = MAKE_ATOM("XV_BRIGHTNESS");
	xvContrast = MAKE_ATOM("XV_CONTRAST");
	xvSaturation = MAKE_ATOM("XV_SATURATION");

	/* Allow the pipe to be switched from pipe A to B when in clone mode */
	xvPipe = MAKE_ATOM("XV_PIPE");

	if (IS_I9XX(intel)) {
		xvGamma0 = MAKE_ATOM("XV_GAMMA0");
		xvGamma1 = MAKE_ATOM("XV_GAMMA1");
		xvGamma2 = MAKE_ATOM("XV_GAMMA2");
		xvGamma3 = MAKE_ATOM("XV_GAMMA3");
		xvGamma4 = MAKE_ATOM("XV_GAMMA4");
		xvGamma5 = MAKE_ATOM("XV_GAMMA5");
	}

	/* XXX These two acccess the overlay regs, don't call with drmmode */
	I830ResetVideo(scrn);
	I830UpdateGamma(scrn);

	return adapt;
}

static XF86VideoAdaptorPtr I830SetupImageVideoTextured(ScreenPtr screen)
{
	ScrnInfoPtr scrn = xf86Screens[screen->myNum];
	intel_screen_private *intel = intel_get_screen_private(scrn);
	XF86VideoAdaptorPtr adapt;
	XF86AttributePtr attrs;
	intel_adaptor_private *adaptor_privs;
	DevUnion *devUnions;
	int nports = 16, i;
	int nAttributes;

	OVERLAY_DEBUG("I830SetupImageVideoOverlay\n");

	nAttributes = NUM_TEXTURED_ATTRIBUTES;

	adapt = calloc(1, sizeof(XF86VideoAdaptorRec));
	adaptor_privs = calloc(nports, sizeof(intel_adaptor_private));
	devUnions = calloc(nports, sizeof(DevUnion));
	attrs = calloc(nAttributes, sizeof(XF86AttributeRec));
	if (adapt == NULL || adaptor_privs == NULL || devUnions == NULL ||
	    attrs == NULL) {
		free(adapt);
		free(adaptor_privs);
		free(devUnions);
		free(attrs);
		return NULL;
	}

	adapt->type = XvWindowMask | XvInputMask | XvImageMask;
	adapt->flags = 0;
	adapt->name = "Intel(R) Textured Video";
	adapt->nEncodings = 1;
	adapt->pEncodings = DummyEncoding;
	adapt->nFormats = NUM_FORMATS;
	adapt->pFormats = Formats;
	adapt->nPorts = nports;
	adapt->pPortPrivates = devUnions;
	adapt->nAttributes = nAttributes;
	adapt->pAttributes = attrs;
	memcpy(attrs, TexturedAttributes,
	       nAttributes * sizeof(XF86AttributeRec));
	if (IS_I915G(intel) || IS_I915GM(intel))
		adapt->nImages = NUM_IMAGES - XVMC_IMAGE;
	else
		adapt->nImages = NUM_IMAGES;

	adapt->pImages = Images;
	adapt->PutVideo = NULL;
	adapt->PutStill = NULL;
	adapt->GetVideo = NULL;
	adapt->GetStill = NULL;
	adapt->StopVideo = I830StopVideo;
	adapt->SetPortAttribute = I830SetPortAttributeTextured;
	adapt->GetPortAttribute = I830GetPortAttribute;
	adapt->QueryBestSize = I830QueryBestSize;
	adapt->PutImage = I830PutImageTextured;
	adapt->QueryImageAttributes = I830QueryImageAttributes;

	for (i = 0; i < nports; i++) {
		intel_adaptor_private *adaptor_priv = &adaptor_privs[i];

		adaptor_priv->textured = TRUE;
		adaptor_priv->videoStatus = 0;
		adaptor_priv->buf = NULL;
		adaptor_priv->oldBuf = NULL;
		adaptor_priv->oldBuf_pinned = FALSE;

		adaptor_priv->rotation = RR_Rotate_0;
		adaptor_priv->SyncToVblank = 1;

		/* gotta uninit this someplace, XXX: shouldn't be necessary for textured */
		REGION_NULL(screen, &adaptor_priv->clip);

		adapt->pPortPrivates[i].ptr = (pointer) (adaptor_priv);
	}

	xvSyncToVblank = MAKE_ATOM("XV_SYNC_TO_VBLANK");

	return adapt;
}

static void i830_free_video_buffers(intel_adaptor_private *adaptor_priv)
{
	if (adaptor_priv->buf) {
		drm_intel_bo_unreference(adaptor_priv->buf);
		adaptor_priv->buf = NULL;
	}

	if (adaptor_priv->oldBuf) {
		if (adaptor_priv->oldBuf_pinned)
			drm_intel_bo_unpin(adaptor_priv->oldBuf);
		drm_intel_bo_unreference(adaptor_priv->oldBuf);
		adaptor_priv->oldBuf = NULL;
		adaptor_priv->oldBuf_pinned = FALSE;
	}
}

static void
ums_overlay_off(ScrnInfoPtr scrn)
{
    i830_overlay_off (scrn);
}

static void I830StopVideo(ScrnInfoPtr scrn, pointer data, Bool shutdown)
{
	intel_adaptor_private *adaptor_priv = (intel_adaptor_private *) data;

	if (adaptor_priv->textured)
		return;

	OVERLAY_DEBUG("I830StopVideo\n");

	REGION_EMPTY(scrn->screen, &adaptor_priv->clip);

	if (shutdown) {
		if (adaptor_priv->videoStatus & CLIENT_VIDEO_ON)
			ums_overlay_off(scrn);

		i830_free_video_buffers(adaptor_priv);
		adaptor_priv->videoStatus = 0;
	} else {
		if (adaptor_priv->videoStatus & CLIENT_VIDEO_ON) {
			adaptor_priv->videoStatus |= OFF_TIMER;
			adaptor_priv->offTime = currentTime.milliseconds + OFF_DELAY;
		}
	}

}

static int
I830SetPortAttributeTextured(ScrnInfoPtr scrn,
			     Atom attribute, INT32 value, pointer data)
{
	intel_adaptor_private *adaptor_priv = (intel_adaptor_private *) data;

	if (attribute == xvBrightness) {
		if ((value < -128) || (value > 127))
			return BadValue;
		adaptor_priv->brightness = value;
		return Success;
	} else if (attribute == xvContrast) {
		if ((value < 0) || (value > 255))
			return BadValue;
		adaptor_priv->contrast = value;
		return Success;
	} else if (attribute == xvSyncToVblank) {
		if ((value < -1) || (value > 1))
			return BadValue;
		adaptor_priv->SyncToVblank = value;
		return Success;
	} else {
		return BadMatch;
	}
}

static void
ums_overlay_update_attrs(ScrnInfoPtr scrn, intel_adaptor_private * adaptor_priv)
{
    intel_screen_private *intel = intel_get_screen_private(scrn);
    I830OverlayRegPtr overlay;

    overlay = I830OVERLAYREG(intel);

    overlay->OCLRC0 = (adaptor_priv->contrast << 18) | (adaptor_priv->brightness & 0xff);
    overlay->OCLRC0 = (adaptor_priv->contrast << 18) | (adaptor_priv->brightness & 0xff);
    overlay->OCLRC1 = adaptor_priv->saturation;

    switch (scrn->depth) {
    case 16:
	overlay->DCLRKV = RGB16ToColorKey(adaptor_priv->colorKey);
	break;
    case 15:
	overlay->DCLRKV = RGB15ToColorKey(adaptor_priv->colorKey);
	break;
    default:
	overlay->DCLRKV = adaptor_priv->colorKey;
	break;
    }

    I830UpdateGamma(scrn);

    i830_overlay_continue(scrn, FALSE);
}

static int
I830SetPortAttributeOverlay(ScrnInfoPtr scrn,
			    Atom attribute, INT32 value, pointer data)
{
	intel_adaptor_private *adaptor_priv = (intel_adaptor_private *) data;
	intel_screen_private *intel = intel_get_screen_private(scrn);

	if (attribute == xvBrightness) {
		if ((value < -128) || (value > 127))
			return BadValue;
		adaptor_priv->brightness = value;
		OVERLAY_DEBUG("BRIGHTNESS\n");
	} else if (attribute == xvContrast) {
		if ((value < 0) || (value > 255))
			return BadValue;
		adaptor_priv->contrast = value;
		OVERLAY_DEBUG("CONTRAST\n");
	} else if (attribute == xvSaturation) {
		if ((value < 0) || (value > 1023))
			return BadValue;
		adaptor_priv->saturation = value;
	} else if (attribute == xvPipe) {
		xf86CrtcConfigPtr   xf86_config = XF86_CRTC_CONFIG_PTR(scrn);
		if ((value < -1) || (value > xf86_config->num_crtc))
			return BadValue;
		if (value < 0)
			adaptor_priv->desired_crtc = NULL;
		else
			adaptor_priv->desired_crtc = xf86_config->crtc[value];
		/*
		 * Leave this to be updated at the next frame
		 */
	} else if (attribute == xvGamma0 && (IS_I9XX(intel))) {
		adaptor_priv->gamma0 = value;
	} else if (attribute == xvGamma1 && (IS_I9XX(intel))) {
		adaptor_priv->gamma1 = value;
	} else if (attribute == xvGamma2 && (IS_I9XX(intel))) {
		adaptor_priv->gamma2 = value;
	} else if (attribute == xvGamma3 && (IS_I9XX(intel))) {
		adaptor_priv->gamma3 = value;
	} else if (attribute == xvGamma4 && (IS_I9XX(intel))) {
		adaptor_priv->gamma4 = value;
	} else if (attribute == xvGamma5 && (IS_I9XX(intel))) {
		adaptor_priv->gamma5 = value;
	} else if (attribute == xvColorKey) {
		adaptor_priv->colorKey = value;
		OVERLAY_DEBUG("COLORKEY\n");
	} else
		return BadMatch;

	/* Ensure that the overlay is off, ready for updating */
	if ((attribute == xvGamma0 ||
	    attribute == xvGamma1 ||
	    attribute == xvGamma2 ||
	    attribute == xvGamma3 ||
	    attribute == xvGamma4 ||
	    attribute == xvGamma5) && (IS_I9XX(intel))) {
		OVERLAY_DEBUG("GAMMA\n");
	}

	ums_overlay_update_attrs(scrn, adaptor_priv);

	if (attribute == xvColorKey)
		REGION_EMPTY(scrn->screen, &adaptor_priv->clip);

	if (attribute == xvColorKey)
		REGION_EMPTY(scrn->screen, &adaptor_priv->clip);

	return Success;
}

static int
I830GetPortAttribute(ScrnInfoPtr scrn,
		     Atom attribute, INT32 * value, pointer data)
{
	intel_screen_private *intel = intel_get_screen_private(scrn);
	intel_adaptor_private *adaptor_priv = (intel_adaptor_private *) data;

	if (attribute == xvBrightness) {
		*value = adaptor_priv->brightness;
	} else if (attribute == xvContrast) {
		*value = adaptor_priv->contrast;
	} else if (attribute == xvSaturation) {
		*value = adaptor_priv->saturation;
	} else if (attribute == xvPipe) {
		int c;
		xf86CrtcConfigPtr xf86_config = XF86_CRTC_CONFIG_PTR(scrn);
		for (c = 0; c < xf86_config->num_crtc; c++)
			if (xf86_config->crtc[c] == adaptor_priv->desired_crtc)
				break;
		if (c == xf86_config->num_crtc)
			c = -1;
		*value = c;
	} else if (attribute == xvGamma0 && (IS_I9XX(intel))) {
		*value = adaptor_priv->gamma0;
	} else if (attribute == xvGamma1 && (IS_I9XX(intel))) {
		*value = adaptor_priv->gamma1;
	} else if (attribute == xvGamma2 && (IS_I9XX(intel))) {
		*value = adaptor_priv->gamma2;
	} else if (attribute == xvGamma3 && (IS_I9XX(intel))) {
		*value = adaptor_priv->gamma3;
	} else if (attribute == xvGamma4 && (IS_I9XX(intel))) {
		*value = adaptor_priv->gamma4;
	} else if (attribute == xvGamma5 && (IS_I9XX(intel))) {
		*value = adaptor_priv->gamma5;
	} else if (attribute == xvColorKey) {
		*value = adaptor_priv->colorKey;
	} else if (attribute == xvSyncToVblank) {
		*value = adaptor_priv->SyncToVblank;
	} else
		return BadMatch;

	return Success;
}

static void
I830QueryBestSize(ScrnInfoPtr scrn,
		  Bool motion,
		  short vid_w, short vid_h,
		  short drw_w, short drw_h,
		  unsigned int *p_w, unsigned int *p_h, pointer data)
{
	if (vid_w > (drw_w << 1))
		drw_w = vid_w >> 1;
	if (vid_h > (drw_h << 1))
		drw_h = vid_h >> 1;

	*p_w = drw_w;
	*p_h = drw_h;
}

static void
I830CopyPackedData(intel_adaptor_private *adaptor_priv,
		   unsigned char *buf,
		   int srcPitch, int dstPitch, int top, int left, int h, int w)
{
	unsigned char *src, *dst, *dst_base;
	int i, j;
	unsigned char *s;

#if 0
	ErrorF("I830CopyPackedData: (%d,%d) (%d,%d)\n"
	       "srcPitch: %d, dstPitch: %d\n", top, left, h, w,
	       srcPitch, dstPitch);
#endif

	src = buf + (top * srcPitch) + (left << 1);

	drm_intel_bo_map(adaptor_priv->buf, TRUE);
	dst_base = adaptor_priv->buf->virtual;

	dst = dst_base + adaptor_priv->YBufOffset;

	switch (adaptor_priv->rotation) {
	case RR_Rotate_0:
		w <<= 1;
		for (i = 0; i < h; i++) {
			memcpy(dst, src, w);
			src += srcPitch;
			dst += dstPitch;
		}
		break;
	case RR_Rotate_90:
		h <<= 1;
		for (i = 0; i < h; i += 2) {
			s = src;
			for (j = 0; j < w; j++) {
				/* Copy Y */
				dst[(i + 0) + ((w - j - 1) * dstPitch)] = *s++;
				(void)*s++;
			}
			src += srcPitch;
		}
		h >>= 1;
		src = buf + (top * srcPitch) + (left << 1);
		for (i = 0; i < h; i += 2) {
			for (j = 0; j < w; j += 2) {
				/* Copy U */
				dst[((i * 2) + 1) + ((w - j - 1) * dstPitch)] =
				    src[(j * 2) + 1 + (i * srcPitch)];
				dst[((i * 2) + 1) + ((w - j - 2) * dstPitch)] =
				    src[(j * 2) + 1 + ((i + 1) * srcPitch)];
				/* Copy V */
				dst[((i * 2) + 3) + ((w - j - 1) * dstPitch)] =
				    src[(j * 2) + 3 + (i * srcPitch)];
				dst[((i * 2) + 3) + ((w - j - 2) * dstPitch)] =
				    src[(j * 2) + 3 + ((i + 1) * srcPitch)];
			}
		}
		break;
	case RR_Rotate_180:
		w <<= 1;
		for (i = 0; i < h; i++) {
			s = src;
			for (j = 0; j < w; j += 4) {
				dst[(w - j - 4) + ((h - i - 1) * dstPitch)] =
				    *s++;
				dst[(w - j - 3) + ((h - i - 1) * dstPitch)] =
				    *s++;
				dst[(w - j - 2) + ((h - i - 1) * dstPitch)] =
				    *s++;
				dst[(w - j - 1) + ((h - i - 1) * dstPitch)] =
				    *s++;
			}
			src += srcPitch;
		}
		break;
	case RR_Rotate_270:
		h <<= 1;
		for (i = 0; i < h; i += 2) {
			s = src;
			for (j = 0; j < w; j++) {
				/* Copy Y */
				dst[(h - i - 2) + (j * dstPitch)] = *s++;
				(void)*s++;
			}
			src += srcPitch;
		}
		h >>= 1;
		src = buf + (top * srcPitch) + (left << 1);
		for (i = 0; i < h; i += 2) {
			for (j = 0; j < w; j += 2) {
				/* Copy U */
				dst[(((h - i) * 2) - 3) + (j * dstPitch)] =
				    src[(j * 2) + 1 + (i * srcPitch)];
				dst[(((h - i) * 2) - 3) +
				    ((j + 1) * dstPitch)] =
				    src[(j * 2) + 1 + ((i + 1) * srcPitch)];
				/* Copy V */
				dst[(((h - i) * 2) - 1) + (j * dstPitch)] =
				    src[(j * 2) + 3 + (i * srcPitch)];
				dst[(((h - i) * 2) - 1) +
				    ((j + 1) * dstPitch)] =
				    src[(j * 2) + 3 + ((i + 1) * srcPitch)];
			}
		}
		break;
	}

	drm_intel_bo_unmap(adaptor_priv->buf);
}

static void i830_memcpy_plane(unsigned char *dst, unsigned char *src,
			      int height, int width,
			      int dstPitch, int srcPitch, Rotation rotation)
{
	int i, j = 0;
	unsigned char *s;

	switch (rotation) {
	case RR_Rotate_0:
		/* optimise for the case of no clipping */
		if (srcPitch == dstPitch && srcPitch == width)
			memcpy(dst, src, srcPitch * height);
		else
			for (i = 0; i < height; i++) {
				memcpy(dst, src, width);
				src += srcPitch;
				dst += dstPitch;
			}
		break;
	case RR_Rotate_90:
		for (i = 0; i < height; i++) {
			s = src;
			for (j = 0; j < width; j++) {
				dst[(i) + ((width - j - 1) * dstPitch)] = *s++;
			}
			src += srcPitch;
		}
		break;
	case RR_Rotate_180:
		for (i = 0; i < height; i++) {
			s = src;
			for (j = 0; j < width; j++) {
				dst[(width - j - 1) +
				    ((height - i - 1) * dstPitch)] = *s++;
			}
			src += srcPitch;
		}
		break;
	case RR_Rotate_270:
		for (i = 0; i < height; i++) {
			s = src;
			for (j = 0; j < width; j++) {
				dst[(height - i - 1) + (j * dstPitch)] = *s++;
			}
			src += srcPitch;
		}
		break;
	}
}

static void
I830CopyPlanarData(intel_adaptor_private *adaptor_priv,
		   unsigned char *buf, int srcPitch, int srcPitch2,
		   int dstPitch, int dstPitch2,
		   int srcH, int top, int left,
		   int h, int w, int id)
{
	unsigned char *src1, *src2, *src3, *dst_base, *dst1, *dst2, *dst3;

#if 0
	ErrorF("I830CopyPlanarData: srcPitch %d, srcPitch %d, dstPitch %d\n"
	       "nlines %d, npixels %d, top %d, left %d\n",
	       srcPitch, srcPitch2, dstPitch, h, w, top, left);
#endif

	/* Copy Y data */
	src1 = buf + (top * srcPitch) + left;
#if 0
	ErrorF("src1 is %p, offset is %ld\n", src1,
	       (unsigned long)src1 - (unsigned long)buf);
#endif

	drm_intel_bo_map(adaptor_priv->buf, TRUE);
	dst_base = adaptor_priv->buf->virtual;

	dst1 = dst_base + adaptor_priv->YBufOffset;

	i830_memcpy_plane(dst1, src1, h, w, dstPitch2, srcPitch,
			  adaptor_priv->rotation);

	/* Copy V data for YV12, or U data for I420 */
	src2 = buf +		/* start of YUV data */
	    (srcH * srcPitch) +	/* move over Luma plane */
	    ((top * srcPitch) >> 2) +	/* move down from by top lines */
	    (left >> 1);	/* move left by left pixels */

#if 0
	ErrorF("src2 is %p, offset is %ld\n", src2,
	       (unsigned long)src2 - (unsigned long)buf);
#endif
	if (id == FOURCC_I420)
		dst2 = dst_base + adaptor_priv->UBufOffset;
	else
		dst2 = dst_base + adaptor_priv->VBufOffset;

	i830_memcpy_plane(dst2, src2, h / 2, w / 2,
			  dstPitch, srcPitch2, adaptor_priv->rotation);

	/* Copy U data for YV12, or V data for I420 */
	src3 = buf +		/* start of YUV data */
	    (srcH * srcPitch) +	/* move over Luma plane */
	    ((srcH >> 1) * srcPitch2) +	/* move over Chroma plane */
	    ((top * srcPitch) >> 2) +	/* move down from by top lines */
	    (left >> 1);	/* move left by left pixels */
#if 0
	ErrorF("src3 is %p, offset is %ld\n", src3,
	       (unsigned long)src3 - (unsigned long)buf);
#endif
	if (id == FOURCC_I420)
		dst3 = dst_base + adaptor_priv->VBufOffset;
	else
		dst3 = dst_base + adaptor_priv->UBufOffset;

	i830_memcpy_plane(dst3, src3, h / 2, w / 2,
			  dstPitch, srcPitch2, adaptor_priv->rotation);

	drm_intel_bo_unmap(adaptor_priv->buf);
}

typedef struct {
	uint8_t sign;
	uint16_t mantissa;
	uint8_t exponent;
} coeffRec, *coeffPtr;

static Bool
SetCoeffRegs(double *coeff, int mantSize, coeffPtr pCoeff, int pos)
{
    int maxVal, icoeff, res;
    int sign;
    double c;

    sign = 0;
    maxVal = 1 << mantSize;
    c = *coeff;
    if (c < 0.0) {
	sign = 1;
	c = -c;
    }

    res = 12 - mantSize;
    if ((icoeff = (int)(c * 4 * maxVal + 0.5)) < maxVal) {
	pCoeff[pos].exponent = 3;
	pCoeff[pos].mantissa = icoeff << res;
	*coeff = (double)icoeff / (double)(4 * maxVal);
    } else if ((icoeff = (int)(c * 2 * maxVal + 0.5)) < maxVal) {
	pCoeff[pos].exponent = 2;
	pCoeff[pos].mantissa = icoeff << res;
	*coeff = (double)icoeff / (double)(2 * maxVal);
    } else if ((icoeff = (int)(c * maxVal + 0.5)) < maxVal) {
	pCoeff[pos].exponent = 1;
	pCoeff[pos].mantissa = icoeff << res;
	*coeff = (double)icoeff / (double)(maxVal);
    } else if ((icoeff = (int)(c * maxVal * 0.5 + 0.5)) < maxVal) {
	pCoeff[pos].exponent = 0;
	pCoeff[pos].mantissa = icoeff << res;
	*coeff = (double)icoeff / (double)(maxVal / 2);
    } else {
	/* Coeff out of range */
	return FALSE;
    }

    pCoeff[pos].sign = sign;
    if (sign)
	*coeff = -(*coeff);
    return TRUE;
}

static void
UpdateCoeff(int taps, double fCutoff, Bool isHoriz, Bool isY, coeffPtr pCoeff)
{
    int i, j, j1, num, pos, mantSize;
    double pi = 3.1415926535, val, sinc, window, sum;
    double rawCoeff[MAX_TAPS * 32], coeffs[N_PHASES][MAX_TAPS];
    double diff;
    int tapAdjust[MAX_TAPS], tap2Fix;
    Bool isVertAndUV;

    if (isHoriz)
	mantSize = 7;
    else
	mantSize = 6;

    isVertAndUV = !isHoriz && !isY;
    num = taps * 16;
    for (i = 0; i < num  * 2; i++) {
	val = (1.0 / fCutoff) * taps * pi * (i - num) / (2 * num);
	if (val == 0.0)
	    sinc = 1.0;
	else
	    sinc = sin(val) / val;

	/* Hamming window */
	window = (0.5 - 0.5 * cos(i * pi / num));
	rawCoeff[i] = sinc * window;
    }

    for (i = 0; i < N_PHASES; i++) {
	/* Normalise the coefficients. */
	sum = 0.0;
	for (j = 0; j < taps; j++) {
	    pos = i + j * 32;
	    sum += rawCoeff[pos];
	}
	for (j = 0; j < taps; j++) {
	    pos = i + j * 32;
	    coeffs[i][j] = rawCoeff[pos] / sum;
	}

	/* Set the register values. */
	for (j = 0; j < taps; j++) {
	    pos = j + i * taps;
	    if ((j == (taps - 1) / 2) && !isVertAndUV)
		SetCoeffRegs(&coeffs[i][j], mantSize + 2, pCoeff, pos);
	    else
		SetCoeffRegs(&coeffs[i][j], mantSize, pCoeff, pos);
	}

	tapAdjust[0] = (taps - 1) / 2;
	for (j = 1, j1 = 1; j <= tapAdjust[0]; j++, j1++) {
	    tapAdjust[j1] = tapAdjust[0] - j;
	    tapAdjust[++j1] = tapAdjust[0] + j;
	}

	/* Adjust the coefficients. */
	sum = 0.0;
	for (j = 0; j < taps; j++)
	    sum += coeffs[i][j];
	if (sum != 1.0) {
	    for (j1 = 0; j1 < taps; j1++) {
		tap2Fix = tapAdjust[j1];
		diff = 1.0 - sum;
		coeffs[i][tap2Fix] += diff;
		pos = tap2Fix + i * taps;
		if ((tap2Fix == (taps - 1) / 2) && !isVertAndUV)
		    SetCoeffRegs(&coeffs[i][tap2Fix], mantSize + 2, pCoeff, pos);
		else
		    SetCoeffRegs(&coeffs[i][tap2Fix], mantSize, pCoeff, pos);

		sum = 0.0;
		for (j = 0; j < taps; j++)
		    sum += coeffs[i][j];
		if (sum == 1.0)
		    break;
	    }
	}
    }
}

static void i830_box_intersect(BoxPtr dest, BoxPtr a, BoxPtr b)
{
	dest->x1 = a->x1 > b->x1 ? a->x1 : b->x1;
	dest->x2 = a->x2 < b->x2 ? a->x2 : b->x2;
	dest->y1 = a->y1 > b->y1 ? a->y1 : b->y1;
	dest->y2 = a->y2 < b->y2 ? a->y2 : b->y2;
	if (dest->x1 >= dest->x2 || dest->y1 >= dest->y2)
		dest->x1 = dest->x2 = dest->y1 = dest->y2 = 0;
}

static void i830_crtc_box(xf86CrtcPtr crtc, BoxPtr crtc_box)
{
	if (crtc->enabled) {
		crtc_box->x1 = crtc->x;
		crtc_box->x2 =
		    crtc->x + xf86ModeWidth(&crtc->mode, crtc->rotation);
		crtc_box->y1 = crtc->y;
		crtc_box->y2 =
		    crtc->y + xf86ModeHeight(&crtc->mode, crtc->rotation);
	} else
		crtc_box->x1 = crtc_box->x2 = crtc_box->y1 = crtc_box->y2 = 0;
}

static int i830_box_area(BoxPtr box)
{
	return (int)(box->x2 - box->x1) * (int)(box->y2 - box->y1);
}

/*
 * Return the crtc covering 'box'. If two crtcs cover a portion of
 * 'box', then prefer 'desired'. If 'desired' is NULL, then prefer the crtc
 * with greater coverage
 */

xf86CrtcPtr
i830_covering_crtc(ScrnInfoPtr scrn,
		   BoxPtr box, xf86CrtcPtr desired, BoxPtr crtc_box_ret)
{
	xf86CrtcConfigPtr xf86_config = XF86_CRTC_CONFIG_PTR(scrn);
	xf86CrtcPtr crtc, best_crtc;
	int coverage, best_coverage;
	int c;
	BoxRec crtc_box, cover_box;

	best_crtc = NULL;
	best_coverage = 0;
	crtc_box_ret->x1 = 0;
	crtc_box_ret->x2 = 0;
	crtc_box_ret->y1 = 0;
	crtc_box_ret->y2 = 0;
	for (c = 0; c < xf86_config->num_crtc; c++) {
		crtc = xf86_config->crtc[c];

		/* If the CRTC is off, treat it as not covering */
		if (!i830_crtc_on(crtc))
			continue;

		i830_crtc_box(crtc, &crtc_box);
		i830_box_intersect(&cover_box, &crtc_box, box);
		coverage = i830_box_area(&cover_box);
		if (coverage && crtc == desired) {
			*crtc_box_ret = crtc_box;
			return crtc;
		}
		if (coverage > best_coverage) {
			*crtc_box_ret = crtc_box;
			best_crtc = crtc;
			best_coverage = coverage;
		}
	}
	return best_crtc;
}

static int
i830_swidth (intel_screen_private *intel, unsigned int offset,
	     unsigned int width, unsigned int mask, int shift)
{
    int	swidth = ((offset + width + mask) >> shift) - (offset >> shift);
    if (IS_I9XX(intel))
	swidth <<= 1;
    swidth -= 1;
    return swidth << 2;
}

static void
i830_calc_src_regs(intel_screen_private *intel, int planar, short width,
    short height, uint32_t *swidth_out, uint32_t *swidthsw_out,
    uint32_t *sheigth_out)
{
    unsigned int	mask, shift, offsety, offsetu;
    unsigned int	swidth, swidthy, swidthuv;
    intel_adaptor_private *adaptor_priv = intel->adaptor->pPortPrivates[0].ptr;

    if (IS_I9XX(intel)) {
	shift = 6;
	mask = 0x3f;
    } else {
	shift = 5;
	mask = 0x1f;
    }

    offsety = adaptor_priv->YBufOffset;
    offsetu = adaptor_priv->UBufOffset;

    if (planar) {
	*swidth_out = width | ((width/2 & 0x7ff) << 16);
	swidthy  = i830_swidth (intel, offsety, width, mask, shift);
	swidthuv = i830_swidth (intel, offsetu, width/2, mask, shift);
	*swidthsw_out = (swidthy) | (swidthuv << 16);
	*sheigth_out = height | ((height / 2) << 16);
    } else {
	*swidth_out = width;
	swidth = i830_swidth (intel, offsety, width << 1, mask, shift);
	*swidthsw_out = swidth;
	*sheigth_out = height;
    }

    return;
}

static void
i830_update_dst_box_to_crtc_coords(ScrnInfoPtr scrn, xf86CrtcPtr crtc,
				   BoxPtr dstBox)
{
	int tmp;

	/* for overlay, we should take it from crtc's screen
	 * coordinate to current crtc's display mode.
	 * yeah, a bit confusing.
	 */
	switch (crtc->rotation & 0xf) {
	case RR_Rotate_0:
		dstBox->x1 -= crtc->x;
		dstBox->x2 -= crtc->x;
		dstBox->y1 -= crtc->y;
		dstBox->y2 -= crtc->y;
		break;
	case RR_Rotate_90:
		tmp = dstBox->x1;
		dstBox->x1 = dstBox->y1 - crtc->x;
		dstBox->y1 = scrn->virtualX - tmp - crtc->y;
		tmp = dstBox->x2;
		dstBox->x2 = dstBox->y2 - crtc->x;
		dstBox->y2 = scrn->virtualX - tmp - crtc->y;
		tmp = dstBox->y1;
		dstBox->y1 = dstBox->y2;
		dstBox->y2 = tmp;
		break;
	case RR_Rotate_180:
		tmp = dstBox->x1;
		dstBox->x1 = scrn->virtualX - dstBox->x2 - crtc->x;
		dstBox->x2 = scrn->virtualX - tmp - crtc->x;
		tmp = dstBox->y1;
		dstBox->y1 = scrn->virtualY - dstBox->y2 - crtc->y;
		dstBox->y2 = scrn->virtualY - tmp - crtc->y;
		break;
	case RR_Rotate_270:
		tmp = dstBox->x1;
		dstBox->x1 = scrn->virtualY - dstBox->y1 - crtc->x;
		dstBox->y1 = tmp - crtc->y;
		tmp = dstBox->x2;
		dstBox->x2 = scrn->virtualY - dstBox->y2 - crtc->x;
		dstBox->y2 = tmp - crtc->y;
		tmp = dstBox->x1;
		dstBox->x1 = dstBox->x2;
		dstBox->x2 = tmp;
		break;
	}

	return;
}

static void
i830_store_coeffs_in_overlay_regs(uint16_t *reg_coeffs, coeffPtr new_coeffs,
	int max_taps)
{
    int i, j, pos;

    for (i = 0; i < N_PHASES; i++) {
	for (j = 0; j < max_taps; j++) {
	    pos = i * max_taps + j;
	    reg_coeffs[pos] = (new_coeffs[pos].sign << 15 |
				      new_coeffs[pos].exponent << 12 |
				      new_coeffs[pos].mantissa);
	}
    }
}

static uint32_t
i830_overlay_cmd(int id, int planar)
{
    uint32_t OCMD = OVERLAY_ENABLE;

    if (planar) {
	OVERLAY_DEBUG("YUV420\n");
	OCMD &= ~SOURCE_FORMAT;
	OCMD &= ~OV_BYTE_ORDER;
	OCMD |= YUV_420;
    } else {
	OVERLAY_DEBUG("YUV422\n");
	OCMD &= ~SOURCE_FORMAT;
	OCMD |= YUV_422;
	OCMD &= ~OV_BYTE_ORDER;
	if (id == FOURCC_UYVY)
	    OCMD |= Y_SWAP;
    }

    OCMD &= ~(BUFFER_SELECT | FIELD_SELECT);
    OCMD |= BUFFER0;

    OVERLAY_DEBUG("OCMD is 0x%x\n", OCMD);

    return OCMD;
}

static double
i830_limit_coeff(double coeff)
{
    /* Limit to between 1.0 and 3.0. */
    if (coeff < MIN_CUTOFF_FREQ)
	coeff = MIN_CUTOFF_FREQ;
    if (coeff > MAX_CUTOFF_FREQ)
	coeff = MAX_CUTOFF_FREQ;

    return coeff;
}

static void
i830_update_polyphase_coeffs(I830OverlayRegPtr	overlay,
	int xscaleFract, int xscaleFractUV)
{
    /*
     * Only Horizontal coefficients so far.
     */
    double fCutoffY;
    double fCutoffUV;
    coeffRec xcoeffY[N_HORIZ_Y_TAPS * N_PHASES];
    coeffRec xcoeffUV[N_HORIZ_UV_TAPS * N_PHASES];

    fCutoffY = xscaleFract / 4096.0;
    fCutoffUV = xscaleFractUV / 4096.0;

    fCutoffUV = i830_limit_coeff(fCutoffUV);
    fCutoffY = i830_limit_coeff(fCutoffY);

    UpdateCoeff(N_HORIZ_Y_TAPS, fCutoffY, TRUE, TRUE, xcoeffY);
    UpdateCoeff(N_HORIZ_UV_TAPS, fCutoffUV, TRUE, FALSE, xcoeffUV);

    i830_store_coeffs_in_overlay_regs(overlay->Y_HCOEFS, xcoeffY,
		    N_HORIZ_Y_TAPS);
    i830_store_coeffs_in_overlay_regs(overlay->UV_HCOEFS, xcoeffUV,
		    N_HORIZ_UV_TAPS);
}

/*
 * Calculate horizontal and vertical scaling factors and polyphase
 * coefficients.
 */

static Bool
i830_update_scaling_factors(I830OverlayRegPtr overlay,
	short src_w, short src_h, short drw_w, short drw_h)
{
    int xscaleInt, xscaleFract, yscaleInt, yscaleFract;
    int xscaleIntUV, xscaleFractUV;
    int yscaleIntUV, yscaleFractUV;
    uint32_t newval;
    Bool scaleChanged = FALSE;

    /*
     * Y down-scale factor as a multiple of 4096.
     */
    xscaleFract = ((src_w - 1) << 12) / drw_w;
    yscaleFract = ((src_h - 1) << 12) / drw_h;

    /* Calculate the UV scaling factor.
     * UV is half the size of Y -- YUV420 */
    xscaleFractUV = xscaleFract / 2;
    yscaleFractUV = yscaleFract / 2;

    /*
     * To keep the relative Y and UV ratios exact, round the Y scales
     * to a multiple of the Y/UV ratio.
     */
    xscaleFract = xscaleFractUV * 2;
    yscaleFract = yscaleFractUV * 2;

    /* Integer (un-multiplied) values. */
    xscaleInt = xscaleFract >> 12;
    yscaleInt = yscaleFract >> 12;

    xscaleIntUV = xscaleFractUV >> 12;
    yscaleIntUV = yscaleFractUV >> 12;

    OVERLAY_DEBUG("xscale: %x.%03x, yscale: %x.%03x\n", xscaleInt,
		  xscaleFract & 0xFFF, yscaleInt, yscaleFract & 0xFFF);
    OVERLAY_DEBUG("UV xscale: %x.%03x, UV yscale: %x.%03x\n", xscaleIntUV,
		  xscaleFractUV & 0xFFF, yscaleIntUV, yscaleFractUV & 0xFFF);

    /* shouldn't get here */
    if (xscaleInt > 7) {
	OVERLAY_DEBUG("xscale: bad scale\n");
	return FALSE;
    }

    /* shouldn't get here */
    if (xscaleIntUV > 7) {
	OVERLAY_DEBUG("xscaleUV: bad scale\n");
	return FALSE;
    }

    newval = (xscaleInt << 16) |
    ((xscaleFract & 0xFFF) << 3) | ((yscaleFract & 0xFFF) << 20);
    if (newval != overlay->YRGBSCALE) {
	scaleChanged = TRUE;
	overlay->YRGBSCALE = newval;
    }

    newval = (xscaleIntUV << 16) | ((xscaleFractUV & 0xFFF) << 3) |
    ((yscaleFractUV & 0xFFF) << 20);
    if (newval != overlay->UVSCALE) {
	scaleChanged = TRUE;
	overlay->UVSCALE = newval;
    }

    newval = yscaleInt << 16 | yscaleIntUV;
    if (newval != overlay->UVSCALEV) {
	scaleChanged = TRUE;
	overlay->UVSCALEV = newval;
    }

    if (scaleChanged) {
	i830_update_polyphase_coeffs(overlay, xscaleFract, xscaleFractUV);
    }

    return scaleChanged;
}

int is_planar_fourcc(int id)
{
	switch (id) {
	case FOURCC_YV12:
	case FOURCC_I420:
#ifdef INTEL_XVMC
	case FOURCC_XVMC:
#endif
		return 1;
	case FOURCC_UYVY:
	case FOURCC_YUY2:
		return 0;
	default:
		ErrorF("Unknown format 0x%x\n", id);
		return 0;
	}
}

static int xvmc_passthrough(int id)
{
#ifdef INTEL_XVMC
	return id == FOURCC_XVMC;
#else
	return 0;
#endif
}

static Bool
ums_overlay_put_image(ScrnInfoPtr scrn, xf86CrtcPtr crtc,
		   int id, short width, short height,
		   int dstPitch, int dstPitch2,
		   BoxPtr dstBox, short src_w, short src_h, short drw_w,
		   short drw_h)
{
    intel_screen_private *intel = intel_get_screen_private(scrn);
    intel_adaptor_private *adaptor_priv = intel->adaptor->pPortPrivates[0].ptr;
    I830OverlayRegPtr	overlay = I830OVERLAYREG(intel);
    int			planar;
    uint32_t		swidth, swidthsw, sheigth;
    Bool		scaleChanged;
    drm_intel_bo	*tmp_buf;

    if (crtc != adaptor_priv->current_crtc)
    {
	/* this may adjust adaptor_priv->oneLineMode */
	i830_overlay_switch_to_crtc (scrn, crtc);
	if (adaptor_priv->overlayOK) {
	    adaptor_priv->current_crtc = crtc;
	    I830ResetVideo (scrn);
	}
    }

    if (!adaptor_priv->overlayOK)
	return TRUE;

    if (adaptor_priv->oneLineMode) {
	/* change the coordinates with panel fitting active */
	dstBox->y1 = (((dstBox->y1 - 1) * adaptor_priv->scaleRatio) >> 16) + 1;
	dstBox->y2 = ((dstBox->y2 * adaptor_priv->scaleRatio) >> 16) + 1;

	/* Now, alter the height, so we scale to the correct size */
	drw_h = ((drw_h * adaptor_priv->scaleRatio) >> 16) + 1;
    }

    planar = is_planar_fourcc(id);

    i830_calc_src_regs(intel, planar, width, height,
	    &swidth, &swidthsw, &sheigth);

    overlay->SWIDTH = swidth;
    overlay->SWIDTHSW = swidthsw;
    overlay->SHEIGHT = sheigth;

    overlay->DWINPOS = (dstBox->y1 << 16) | dstBox->x1;

    overlay->DWINSZ = (((dstBox->y2 - dstBox->y1) << 16) |
		       (dstBox->x2 - dstBox->x1));

    OVERLAY_DEBUG("dstBox: x1: %d, y1: %d, x2: %d, y2: %d\n",
		  dstBox->x1, dstBox->y1, dstBox->x2, dstBox->y2);

    /* buffer locations */
    if (drm_intel_bo_pin(adaptor_priv->buf, GTT_PAGE_SIZE) != 0)
        return FALSE;
    overlay->OBUF_0Y = adaptor_priv->YBufOffset + adaptor_priv->buf->offset;
    overlay->OBUF_0U = adaptor_priv->UBufOffset + adaptor_priv->buf->offset;
    overlay->OBUF_0V = adaptor_priv->VBufOffset + adaptor_priv->buf->offset;

    OVERLAY_DEBUG("pos: 0x%x, size: 0x%x\n",
		  overlay->DWINPOS, overlay->DWINSZ);
    OVERLAY_DEBUG("dst: %d x %d, src: %d x %d\n", drw_w, drw_h, src_w, src_h);

    scaleChanged = i830_update_scaling_factors(overlay,
	    src_w, src_h, drw_w, drw_h);

    if (planar) {
#if 0
	/* set UV vertical phase to -0.25 */
	overlay->UV_VPH = 0x30003000;
#endif
	overlay->OSTRIDE = (dstPitch2) | (dstPitch << 16);
	OVERLAY_DEBUG("UV stride is %d, Y stride is %d\n",
		      dstPitch, dstPitch * 2);
    } else
	overlay->OSTRIDE = dstPitch;

    overlay->OCMD = i830_overlay_cmd(id, planar);

    /* make sure the overlay is on */
    i830_overlay_on (scrn);
    /* and show this frame */
    i830_overlay_continue (scrn, scaleChanged);

    /* unpin the old buffer and exchange buffers */
    if (adaptor_priv->oldBuf_pinned) {
	drm_intel_bo_unpin(adaptor_priv->oldBuf);
    }
    tmp_buf = adaptor_priv->buf;
    adaptor_priv->buf = adaptor_priv->oldBuf;
    adaptor_priv->oldBuf = tmp_buf;
    adaptor_priv->oldBuf_pinned = TRUE;

    return TRUE;
}

static Bool
i830_display_overlay(ScrnInfoPtr scrn, xf86CrtcPtr crtc,
		     int id, short width, short height,
		     int dstPitch, int dstPitch2,
		     BoxPtr dstBox, short src_w, short src_h, short drw_w,
		     short drw_h)
{
	intel_screen_private *intel = intel_get_screen_private(scrn);
	intel_adaptor_private *adaptor_priv = intel->adaptor->pPortPrivates[0].ptr;
	int tmp;

	OVERLAY_DEBUG("I830DisplayVideo: %dx%d (pitch %d)\n", width, height,
		      dstPitch);

#if VIDEO_DEBUG
	CompareOverlay(intel, (uint32_t *) overlay, 0x100);
#endif

	/*
	 * If the video isn't visible on any CRTC, turn it off
	 */
	if (!crtc) {
		adaptor_priv->current_crtc = NULL;
		ums_overlay_off(scrn);

		return TRUE;
	}

	i830_update_dst_box_to_crtc_coords(scrn, crtc, dstBox);

	if (crtc->rotation & (RR_Rotate_90 | RR_Rotate_270)) {
		tmp = width;
		width = height;
		height = tmp;
		tmp = drw_w;
		drw_w = drw_h;
		drw_h = tmp;
		tmp = src_w;
		src_w = src_h;
		src_h = tmp;
	}

	return ums_overlay_put_image(scrn, crtc, id, width, height, dstPitch,
	    dstPitch2, dstBox, src_w, src_h, drw_w, drw_h);
}

static Bool
i830_clip_video_helper(ScrnInfoPtr scrn,
		       intel_adaptor_private *adaptor_priv,
		       xf86CrtcPtr * crtc_ret,
		       BoxPtr dst,
		       short src_x, short src_y,
		       short drw_x, short drw_y,
		       short src_w, short src_h,
		       short drw_w, short drw_h,
		       int id,
		       int *top, int* left, int* npixels, int *nlines,
		       RegionPtr reg, INT32 width, INT32 height)
{
	Bool ret;
	RegionRec crtc_region_local;
	RegionPtr crtc_region = reg;
	BoxRec crtc_box;
	INT32 x1, x2, y1, y2;
	xf86CrtcPtr crtc;

	x1 = src_x;
	x2 = src_x + src_w;
	y1 = src_y;
	y2 = src_y + src_h;

	dst->x1 = drw_x;
	dst->x2 = drw_x + drw_w;
	dst->y1 = drw_y;
	dst->y2 = drw_y + drw_h;

	/*
	 * For overlay video, compute the relevant CRTC and
	 * clip video to that
	 */
	crtc = i830_covering_crtc(scrn, dst, adaptor_priv->desired_crtc,
					      &crtc_box);

	/* For textured video, we don't actually want to clip at all. */
	if (crtc && !adaptor_priv->textured) {
		REGION_INIT(screen, &crtc_region_local, &crtc_box, 1);
		crtc_region = &crtc_region_local;
		REGION_INTERSECT(screen, crtc_region, crtc_region,
				 reg);
	}
	*crtc_ret = crtc;

	ret = xf86XVClipVideoHelper(dst, &x1, &x2, &y1, &y2,
				    crtc_region, width, height);
	if (crtc_region != reg)
		REGION_UNINIT(screen, &crtc_region_local);

	*top = y1 >> 16;
	*left = (x1 >> 16) & ~1;
	*npixels = ((((x2 + 0xffff) >> 16) + 1) & ~1) - *left;
	if (is_planar_fourcc(id)) {
		*top &= ~1;
		*nlines = ((((y2 + 0xffff) >> 16) + 1) & ~1) - *top;
	} else
		*nlines = ((y2 + 0xffff) >> 16) - *top;

	return ret;
}

static void
i830_wait_for_scanline(ScrnInfoPtr scrn, PixmapPtr pixmap,
		       xf86CrtcPtr crtc, RegionPtr clipBoxes)
{
	intel_screen_private *intel = intel_get_screen_private(scrn);
	BoxPtr box;
	pixman_box16_t box_in_crtc_coordinates;
	int pipe = -1, event, load_scan_lines_pipe;

	if (pixmap_is_scanout(pixmap))
		pipe = i830_crtc_to_pipe(crtc);

	if (pipe >= 0) {
		if (pipe == 0) {
			event = MI_WAIT_FOR_PIPEA_SCAN_LINE_WINDOW;
			load_scan_lines_pipe = MI_LOAD_SCAN_LINES_DISPLAY_PIPEA;
		} else {
			event = MI_WAIT_FOR_PIPEB_SCAN_LINE_WINDOW;
			load_scan_lines_pipe = MI_LOAD_SCAN_LINES_DISPLAY_PIPEB;
		}

		box = REGION_EXTENTS(unused, clipBoxes);
		box_in_crtc_coordinates = *box;
		if (crtc->transform_in_use)
			pixman_f_transform_bounds(&crtc->f_framebuffer_to_crtc,
						  &box_in_crtc_coordinates);

		BEGIN_BATCH(5);
		/* The documentation says that the LOAD_SCAN_LINES command
		 * always comes in pairs. Don't ask me why. */
		OUT_BATCH(MI_LOAD_SCAN_LINES_INCL | load_scan_lines_pipe);
		OUT_BATCH((box_in_crtc_coordinates.
			   y1 << 16) | box_in_crtc_coordinates.y2);
		OUT_BATCH(MI_LOAD_SCAN_LINES_INCL | load_scan_lines_pipe);
		OUT_BATCH((box_in_crtc_coordinates.
			   y1 << 16) | box_in_crtc_coordinates.y2);
		OUT_BATCH(MI_WAIT_FOR_EVENT | event);
		ADVANCE_BATCH();
	}
}

static Bool
i830_setup_video_buffer(ScrnInfoPtr scrn, intel_adaptor_private *adaptor_priv,
			int alloc_size, int id, unsigned char *buf)
{
	intel_screen_private *intel = intel_get_screen_private(scrn);

	/* Free the current buffer if we're going to have to reallocate */
	if (adaptor_priv->buf && adaptor_priv->buf->size < alloc_size) {
		drm_intel_bo_unreference(adaptor_priv->buf);
		adaptor_priv->buf = NULL;
	}

	if (adaptor_priv->buf == NULL) {
		adaptor_priv->buf = drm_intel_bo_alloc(intel->bufmgr,
						"xv buffer", alloc_size,
						4096);
		if (adaptor_priv->buf == NULL)
			return FALSE;
	}

	return TRUE;
}

static void
i830_setup_dst_params(ScrnInfoPtr scrn, intel_adaptor_private *adaptor_priv, short width,
			short height, int *dstPitch, int *dstPitch2, int *size,
			int id)
{
	intel_screen_private *intel = intel_get_screen_private(scrn);
	int pitchAlignMask;

	/* Only needs to be DWORD-aligned for textured on i915, but overlay has
	 * stricter requirements.
	 */
	if (adaptor_priv->textured) {
		pitchAlignMask = 3;
	} else {
		if (IS_I965G(intel))
			/* Actually the alignment is 64 bytes, too. But the
			 * stride must be at least 512 bytes. Take the easy fix
			 * and align on 512 bytes unconditionally. */
			pitchAlignMask = 511;
		else
			pitchAlignMask = 63;
	}

#if INTEL_XVMC
	/* for i915 xvmc, hw requires 1kb aligned surfaces */
	if ((id == FOURCC_XVMC) && IS_I915(intel))
		pitchAlignMask = 0x3ff;
#endif

	/* Determine the desired destination pitch (representing the chroma's pitch,
	 * in the planar case.
	 */
	if (is_planar_fourcc(id)) {
		if (adaptor_priv->rotation & (RR_Rotate_90 | RR_Rotate_270)) {
			*dstPitch =
			    ((height / 2) + pitchAlignMask) & ~pitchAlignMask;
			*dstPitch2 =
			    (height + pitchAlignMask) & ~pitchAlignMask;
			*size = *dstPitch * width * 3;
		} else {
			*dstPitch =
			    ((width / 2) + pitchAlignMask) & ~pitchAlignMask;
			*dstPitch2 =
			    (width + pitchAlignMask) & ~pitchAlignMask;
			*size = *dstPitch * height * 3;
		}
	} else {
		if (adaptor_priv->rotation & (RR_Rotate_90 | RR_Rotate_270)) {
			*dstPitch =
			    ((height << 1) + pitchAlignMask) & ~pitchAlignMask;
			*size = *dstPitch * width;
		} else {
			*dstPitch =
			    ((width << 1) + pitchAlignMask) & ~pitchAlignMask;
			*size = *dstPitch * height;
		}
		*dstPitch2 = 0;
	}
#if 0
	ErrorF("srcPitch: %d, dstPitch: %d, size: %d\n", srcPitch, *dstPitch,
	       size);
#endif

	adaptor_priv->YBufOffset = 0;

	if (adaptor_priv->rotation & (RR_Rotate_90 | RR_Rotate_270)) {
		adaptor_priv->UBufOffset =
		    adaptor_priv->YBufOffset + (*dstPitch2 * width);
		adaptor_priv->VBufOffset =
		    adaptor_priv->UBufOffset + (*dstPitch * width / 2);
	} else {
		adaptor_priv->UBufOffset =
		    adaptor_priv->YBufOffset + (*dstPitch2 * height);
		adaptor_priv->VBufOffset =
		    adaptor_priv->UBufOffset + (*dstPitch * height / 2);
	}
}

static Bool
i830_copy_video_data(ScrnInfoPtr scrn, intel_adaptor_private *adaptor_priv,
		     short width, short height, int *dstPitch, int *dstPitch2,
		     int top, int left, int npixels, int nlines,
		     int id, unsigned char *buf)
{
	int srcPitch = 0, srcPitch2 = 0;
	int size;

	if (is_planar_fourcc(id)) {
		srcPitch = (width + 0x3) & ~0x3;
		srcPitch2 = ((width >> 1) + 0x3) & ~0x3;
	} else {
		srcPitch = width << 1;
	}

	i830_setup_dst_params(scrn, adaptor_priv, width, height, dstPitch,
				dstPitch2, &size, id);

	if (!i830_setup_video_buffer(scrn, adaptor_priv, size, id, buf))
		return FALSE;

	/* copy data */
	if (is_planar_fourcc(id)) {
		I830CopyPlanarData(adaptor_priv, buf, srcPitch, srcPitch2,
				   *dstPitch, *dstPitch2,
				   height, top, left, nlines,
				   npixels, id);
	} else {
		I830CopyPackedData(adaptor_priv, buf, srcPitch, *dstPitch, top, left,
				   nlines, npixels);
	}

	return TRUE;
}

/*
 * The source rectangle of the video is defined by (src_x, src_y, src_w, src_h).
 * The dest rectangle of the video is defined by (drw_x, drw_y, drw_w, drw_h).
 * id is a fourcc code for the format of the video.
 * buf is the pointer to the source data in system memory.
 * width and height are the w/h of the source data.
 * If "sync" is TRUE, then we must be finished with *buf at the point of return
 * (which we always are).
 * clipBoxes is the clipping region in screen space.
 * data is a pointer to our port private.
 * drawable is some Drawable, which might not be the screen in the case of
 * compositing.  It's a new argument to the function in the 1.1 server.
 */
static int
I830PutImageTextured(ScrnInfoPtr scrn,
	     short src_x, short src_y,
	     short drw_x, short drw_y,
	     short src_w, short src_h,
	     short drw_w, short drw_h,
	     int id, unsigned char *buf,
	     short width, short height,
	     Bool sync, RegionPtr clipBoxes, pointer data,
	     DrawablePtr drawable)
{
	intel_screen_private *intel = intel_get_screen_private(scrn);
	intel_adaptor_private *adaptor_priv = (intel_adaptor_private *) data;
	PixmapPtr pixmap = get_drawable_pixmap(drawable);
	int dstPitch, dstPitch2;
	BoxRec dstBox;
	xf86CrtcPtr crtc;
	int top, left, npixels, nlines;

#if 0
	ErrorF("I830PutImage: src: (%d,%d)(%d,%d), dst: (%d,%d)(%d,%d)\n"
	       "width %d, height %d\n", src_x, src_y, src_w, src_h, drw_x,
	       drw_y, drw_w, drw_h, width, height);
#endif

	if (!i830_clip_video_helper(scrn,
				    adaptor_priv,
				    &crtc,
				    &dstBox,
				    src_x, src_y, drw_x, drw_y,
				    src_w, src_h, drw_w, drw_h,
				    id,
				    &top, &left, &npixels, &nlines, clipBoxes,
				    width, height))
		return Success;

	if (xvmc_passthrough(id)) {
		int size;
		uint32_t *gem_handle = (uint32_t *)buf;

		i830_free_video_buffers(adaptor_priv);

		i830_setup_dst_params(scrn, adaptor_priv, width, height,
				&dstPitch, &dstPitch2, &size, id);

		if (IS_I915G(intel) || IS_I915GM(intel)) {
			/* XXX: i915 is not support and needs some
			 * serious care.  grep for KMS in i915_hwmc.c */
			return BadAlloc;
		}

		adaptor_priv->buf =
			drm_intel_bo_gem_create_from_name(intel->bufmgr,
							  "xvmc surface",
							  *gem_handle);
	} else {
		if (!i830_copy_video_data(scrn, adaptor_priv, width, height,
					  &dstPitch, &dstPitch2,
					  top, left, npixels, nlines, id, buf))
			return BadAlloc;
	}

	if (crtc && adaptor_priv->SyncToVblank != 0) {
		i830_wait_for_scanline(scrn, pixmap, crtc, clipBoxes);
	}

	if (IS_I965G(intel)) {
		I965DisplayVideoTextured(scrn, adaptor_priv, id, clipBoxes,
					 width, height, dstPitch, dstPitch2,
					 src_w, src_h,
					 drw_w, drw_h, pixmap);
	} else {
		I915DisplayVideoTextured(scrn, adaptor_priv, id, clipBoxes,
					 width, height, dstPitch, dstPitch2,
					 src_w, src_h, drw_w, drw_h,
					 pixmap);
	}

	DamageDamageRegion(drawable, clipBoxes);

	return Success;
}

static int
I830PutImageOverlay(ScrnInfoPtr scrn,
	     short src_x, short src_y,
	     short drw_x, short drw_y,
	     short src_w, short src_h,
	     short drw_w, short drw_h,
	     int id, unsigned char *buf,
	     short width, short height,
	     Bool sync, RegionPtr clipBoxes, pointer data,
	     DrawablePtr drawable)
{
	intel_adaptor_private *adaptor_priv = (intel_adaptor_private *) data;
	int dstPitch, dstPitch2;
	BoxRec dstBox;
	xf86CrtcPtr crtc;
	int top, left, npixels, nlines;

#if 0
	ErrorF("I830PutImage: src: (%d,%d)(%d,%d), dst: (%d,%d)(%d,%d)\n" "width %d, height %d\n", src_x, src_y, src_w, src_h, drw_x,
	       drw_y, drw_w, drw_h, width, height);
#endif

	/* If dst width and height are less than 1/8th the src size, the
	 * src/dst scale factor becomes larger than 8 and doesn't fit in
	 * the scale register. */
	if (src_w >= (drw_w * 8))
		drw_w = src_w / 7;

	if (src_h >= (drw_h * 8))
		drw_h = src_h / 7;

	if (!i830_clip_video_helper(scrn,
				    adaptor_priv,
				    &crtc,
				    &dstBox,
				    src_x, src_y, drw_x, drw_y,
				    src_w, src_h, drw_w, drw_h,
				    id,
				    &top, &left, &npixels, &nlines, clipBoxes,
				    width, height))
		return Success;

	/* overlay can't handle rotation natively, store it for the copy func */
	if (crtc)
		adaptor_priv->rotation = crtc->rotation;
	else {
		xf86DrvMsg(scrn->scrnIndex, X_WARNING,
			   "Fail to clip video to any crtc!\n");
		return Success;
	}

	if (!i830_copy_video_data(scrn, adaptor_priv, width, height,
				  &dstPitch, &dstPitch2,
				  top, left, npixels, nlines, id, buf))
		return BadAlloc;

	if (!i830_display_overlay
	    (scrn, crtc, id, width, height, dstPitch, dstPitch2,
	     &dstBox, src_w, src_h, drw_w, drw_h))
		return BadAlloc;

	/* update cliplist */
	if (!REGION_EQUAL(scrn->pScreen, &adaptor_priv->clip, clipBoxes)) {
		REGION_COPY(scrn->pScreen, &adaptor_priv->clip, clipBoxes);
		xf86XVFillKeyHelperDrawable(drawable,
					    adaptor_priv->colorKey,
					    clipBoxes);
	}

	adaptor_priv->videoStatus = CLIENT_VIDEO_ON;

	return Success;
}

static int
I830QueryImageAttributes(ScrnInfoPtr scrn,
			 int id,
			 unsigned short *w, unsigned short *h,
			 int *pitches, int *offsets)
{
	intel_screen_private *intel = intel_get_screen_private(scrn);
	int size, tmp;

#if 0
	ErrorF("I830QueryImageAttributes: w is %d, h is %d\n", *w, *h);
#endif

	if (IS_845G(intel) || IS_I830(intel)) {
		if (*w > IMAGE_MAX_WIDTH_LEGACY)
			*w = IMAGE_MAX_WIDTH_LEGACY;
		if (*h > IMAGE_MAX_HEIGHT_LEGACY)
			*h = IMAGE_MAX_HEIGHT_LEGACY;
	} else {
		if (*w > IMAGE_MAX_WIDTH)
			*w = IMAGE_MAX_WIDTH;
		if (*h > IMAGE_MAX_HEIGHT)
			*h = IMAGE_MAX_HEIGHT;
	}

	*w = (*w + 1) & ~1;
	if (offsets)
		offsets[0] = 0;

	switch (id) {
		/* IA44 is for XvMC only */
	case FOURCC_IA44:
	case FOURCC_AI44:
		if (pitches)
			pitches[0] = *w;
		size = *w * *h;
		break;
	case FOURCC_YV12:
	case FOURCC_I420:
		*h = (*h + 1) & ~1;
		size = (*w + 3) & ~3;
		if (pitches)
			pitches[0] = size;
		size *= *h;
		if (offsets)
			offsets[1] = size;
		tmp = ((*w >> 1) + 3) & ~3;
		if (pitches)
			pitches[1] = pitches[2] = tmp;
		tmp *= (*h >> 1);
		size += tmp;
		if (offsets)
			offsets[2] = size;
		size += tmp;
#if 0
		if (pitches)
			ErrorF("pitch 0 is %d, pitch 1 is %d, pitch 2 is %d\n",
			       pitches[0], pitches[1], pitches[2]);
		if (offsets)
			ErrorF("offset 1 is %d, offset 2 is %d\n", offsets[1],
			       offsets[2]);
		if (offsets)
			ErrorF("size is %d\n", size);
#endif
		break;
#ifdef INTEL_XVMC
	case FOURCC_XVMC:
		*h = (*h + 1) & ~1;
		size = sizeof(struct intel_xvmc_command);
		if (pitches)
			pitches[0] = size;
		break;
#endif
	case FOURCC_UYVY:
	case FOURCC_YUY2:
	default:
		size = *w << 1;
		if (pitches)
			pitches[0] = size;
		size *= *h;
		break;
	}

	return size;
}

void
I830VideoBlockHandler(int i, pointer blockData, pointer pTimeout,
		      pointer pReadmask)
{
	ScrnInfoPtr scrn = xf86Screens[i];
	intel_screen_private *intel = intel_get_screen_private(scrn);
	intel_adaptor_private *adaptor_priv;

	/* no overlay */
	if (intel->adaptor == NULL)
		return;

	adaptor_priv = intel_get_adaptor_private(scrn);

	if (adaptor_priv->videoStatus & TIMER_MASK) {
#if 1
		Time now = currentTime.milliseconds;
#else
		UpdateCurrentTime();
#endif
		if (adaptor_priv->videoStatus & OFF_TIMER) {
			if (adaptor_priv->offTime < now) {
				/* Turn off the overlay */
				OVERLAY_DEBUG("BLOCKHANDLER\n");

				ums_overlay_off (scrn);

				adaptor_priv->videoStatus = FREE_TIMER;
				adaptor_priv->freeTime = now + FREE_DELAY;
			    }
		} else {				/* FREE_TIMER */
			if (adaptor_priv->freeTime < now) {
				i830_free_video_buffers(adaptor_priv);
				adaptor_priv->videoStatus = 0;
			}
		}
	}
}

void
i830_crtc_dpms_video(xf86CrtcPtr crtc, Bool on)
{
	ScrnInfoPtr scrn = crtc->scrn;
	intel_screen_private *intel = intel_get_screen_private(scrn);
	intel_adaptor_private *adaptor_priv;

	/* no overlay */
	if (intel->adaptor == NULL)
		return;

	adaptor_priv = intel->adaptor->pPortPrivates[0].ptr;

	if (crtc != adaptor_priv->current_crtc)
		return;

	/* Check if it's the crtc the overlay is off */
	if (!on) {
		/* We stop the video when mode switching, so we don't lock up
		 * the engine. The overlayOK will determine whether we can
		 * re-enable with the current video on completion of the mode
		 * switch.
		 */
		I830StopVideo(scrn, adaptor_priv, TRUE);
		adaptor_priv->current_crtc = NULL;
		adaptor_priv->overlayOK = FALSE;
		adaptor_priv->oneLineMode = FALSE;
	}
}
@


1.13
log
@Update the intel driver to (mostly) a backport of 2.12.

It is missing a few commits that I have yet to verify (ones that try and
continue if we lock the gpu rendering engine and can't reset it, for
example) taht will be verified and sent out for extra testing soon.

Should contain a bunch of speedups and some correctness improvements
(though rendercheck still gives some errors that I am looking into).

This has been in snaps since the first day of c2k10, any known issues
with just this driver have (to my knowledge) been fixed since. A problem
with macbooks pointed out by otto happens with both this and the in-tree
driver and thus doesn't stop this moving forward.

As well as the 2.12 improvements, this driver also has a backport
(partially aided by the backports in RHEL 5 kindly provided by Dave
Airlie) from the kms code of modesetting support for ironlake (arrandale
and clarkdale: the IGDs build into intel nehalem cpu dies) which has
been tested on a number of chipsets. Note that Display port and eDP
displays have not yet been worked on (and probably won't until I can
find a displayport monitor), but VGA and lvds at least are known to
work, sure beats vesa.

"no objection on my side" matthieu@@, prodding (as always) from princess
marco.
@
text
@@


1.12
log
@Pull in the changes in rendering that I skipped when i backported
changes from later intel versions (after the UMS removal). 95% of this
is the xvmc reworks that makes that code even halfway sane. xvmc is now
enabled by default on 965+.

Tested by many on tech@@, thanks!

ok matthieu@@
@
text
@d560 1
a560 1
	    xalloc((num_adaptors + 2) * sizeof(XF86VideoAdaptorPtr *));
d577 1
a577 2
	if (scrn->bitsPerPixel >= 16 && (IS_I9XX(intel) || IS_I965G(intel)) &&
	    !(!IS_I965G(intel) && scrn->displayWidth > 2048)) {
d621 1
a621 1
	xfree(adaptors);
d820 1
a820 1
	if (!(adapt = xcalloc(1, sizeof(XF86VideoAdaptorRec) +
d952 4
a955 4
	adapt = xcalloc(1, sizeof(XF86VideoAdaptorRec));
	adaptor_privs = xcalloc(nports, sizeof(intel_adaptor_private));
	devUnions = xcalloc(nports, sizeof(DevUnion));
	attrs = xcalloc(nAttributes, sizeof(XF86AttributeRec));
d958 4
a961 4
		xfree(adapt);
		xfree(adaptor_privs);
		xfree(devUnions);
		xfree(attrs);
@


1.11
log
@Update the intel driver to 2.9.1 plus backports.

2.9.1 is the last version of the intel DDX that supports UMS (User
modesetting), with 2.10 onwards being purely KMS only. As such, this
driver contains backports of almost every correctness or performance
related fix to the rendering layer in later intel drivers. This driver
*REQUIRES* a GEM enabled kernel. it claims to support non-gem mode but
this is essentially unmaintained and due to the way the abstraciton
works is slow, if it works at all (it often does not). You have been
warned.

tested by many many people on tech over the last few weeks.
@
text
@a76 1
#include "i915_hwmc.h"
d97 4
a100 1
static int I830PutImage(ScrnInfoPtr, short, short, short, short, short, short,
d244 1
d246 5
a553 3
#ifdef INTEL_XVMC
	Bool xvmc_status = FALSE;
#endif
a609 8
#ifdef INTEL_XVMC
	if (intel_xvmc_probe(scrn)) {
		if (texturedAdaptor)
			xvmc_status =
			    intel_xvmc_driver_init(screen, texturedAdaptor);
	}
#endif

d619 2
a620 2
	if (xvmc_status)
		intel_xvmc_screen_init(screen);
d862 2
a863 1
	adapt->nImages = NUM_IMAGES;
d873 1
a873 1
	adapt->PutImage = I830PutImage;
d940 2
d979 5
a983 1
	adapt->nImages = NUM_IMAGES;
d993 1
a993 1
	adapt->PutImage = I830PutImage;
d1416 3
a1418 2
		   unsigned char *buf, int srcPitch,
		   int srcPitch2, int dstPitch, int srcH, int top, int left,
a1421 1
	int dstPitch2 = dstPitch << 1;
d1981 3
a1983 2
		   int dstPitch, int x1, int y1, int x2, int y2, BoxPtr dstBox,
		   short src_w, short src_h, short drw_w, short drw_h)
d2051 1
a2051 1
	overlay->OSTRIDE = (dstPitch * 2) | (dstPitch << 16);
d2079 1
a2079 1
		     int dstPitch, int x1, int y1, int x2, int y2,
d2119 1
a2119 1
	    x1, y1, x2, y2, dstBox, src_w, src_h, drw_w, drw_h);
d2127 7
a2133 4
		       INT32 * xa,
		       INT32 * xb,
		       INT32 * ya,
		       INT32 * yb, RegionPtr reg, INT32 width, INT32 height)
d2138 13
d2156 9
a2164 14
	if (crtc_ret) {
		BoxRec crtc_box;
		xf86CrtcPtr crtc = i830_covering_crtc(scrn, dst,
						      adaptor_priv->desired_crtc,
						      &crtc_box);

		/* For textured video, we don't actually want to clip at all. */
		if (crtc && !adaptor_priv->textured) {
			REGION_INIT(screen, &crtc_region_local, &crtc_box, 1);
			crtc_region = &crtc_region_local;
			REGION_INTERSECT(screen, crtc_region, crtc_region,
					 reg);
		}
		*crtc_ret = crtc;
d2166 3
a2168 1
	ret = xf86XVClipVideoHelper(dst, xa, xb, ya, yb,
a2171 2
	return ret;
}
d2173 8
a2180 9
static void
i830_fill_colorkey(ScreenPtr screen, uint32_t key, RegionPtr clipboxes)
{
	DrawablePtr root = &WindowTable[screen->myNum]->drawable;
	XID pval[2];
	BoxPtr pbox = REGION_RECTS(clipboxes);
	int i, nbox = REGION_NUM_RECTS(clipboxes);
	xRectangle *rects;
	GCPtr gc;
d2182 1
a2182 22
	if (!xf86Screens[screen->myNum]->vtSema)
		return;

	gc = GetScratchGC(root->depth, screen);
	pval[0] = key;
	pval[1] = IncludeInferiors;
	(void)ChangeGC(gc, GCForeground | GCSubwindowMode, pval);
	ValidateGC(root, gc);

	rects = xalloc(nbox * sizeof(xRectangle));

	for (i = 0; i < nbox; i++, pbox++) {
		rects[i].x = pbox->x1;
		rects[i].y = pbox->y1;
		rects[i].width = pbox->x2 - pbox->x1;
		rects[i].height = pbox->y2 - pbox->y1;
	}

	(*gc->ops->PolyFillRect) (root, gc, nbox, rects);

	xfree(rects);
	FreeScratchGC(gc);
d2238 6
a2243 16
	if (xvmc_passthrough(id)) {
		i830_free_video_buffers(adaptor_priv);
		if (IS_I965G(intel)) {
			adaptor_priv->buf =
				drm_intel_bo_gem_create_from_name(intel->bufmgr,
								  "xvmc surface",
								  (uintptr_t)buf);
		}
	} else {
		if (adaptor_priv->buf == NULL) {
			adaptor_priv->buf = drm_intel_bo_alloc(intel->bufmgr,
							"xv buffer", alloc_size,
							4096);
			if (adaptor_priv->buf == NULL)
				return FALSE;
		}
d2250 1
a2250 1
i830_dst_pitch_and_size(ScrnInfoPtr scrn, intel_adaptor_private *adaptor_priv, short width,
a2261 5
#ifdef INTEL_XVMC
		/* for i915 xvmc, hw requires at least 1kb aligned surface */
		if ((id == FOURCC_XVMC) && IS_I915(intel))
			pitchAlignMask = 0x3ff;
#endif
d2264 4
a2267 1
			pitchAlignMask = 255;
d2272 6
d2281 1
a2281 3
	switch (id) {
	case FOURCC_YV12:
	case FOURCC_I420:
d2285 2
d2291 2
d2295 1
a2295 4
		break;
	case FOURCC_UYVY:
	case FOURCC_YUY2:

d2305 1
a2305 12
		break;
#ifdef INTEL_XVMC
	case FOURCC_XVMC:
		*dstPitch = ((width / 2) + pitchAlignMask) & ~pitchAlignMask;
		*dstPitch2 = (width + pitchAlignMask) & ~pitchAlignMask;
		*size = 0;
		break;
#endif
	default:
		*dstPitch = 0;
		*size = 0;
		break;
d2311 14
d2330 1
a2330 1
		     INT32 x1, INT32 y1, INT32 x2, INT32 y2,
a2332 3
#ifdef INTEL_XVMC
	intel_screen_private *intel = intel_get_screen_private(scrn);
#endif
d2334 1
a2334 1
	int top, left, npixels, nlines, size;
d2343 1
a2343 1
	i830_dst_pitch_and_size(scrn, adaptor_priv, width, height, dstPitch,
a2348 26
	/* fixup pointers */
#ifdef INTEL_XVMC
	if (id == FOURCC_XVMC && IS_I915(intel)) {
		adaptor_priv->YBufOffset = (uint32_t) ((uintptr_t) buf);
		adaptor_priv->VBufOffset = adaptor_priv->YBufOffset + (*dstPitch2 * height);
		adaptor_priv->UBufOffset =
		    adaptor_priv->VBufOffset + (*dstPitch * height / 2);
	} else {
#endif
		adaptor_priv->YBufOffset = 0;

		if (adaptor_priv->rotation & (RR_Rotate_90 | RR_Rotate_270)) {
			adaptor_priv->UBufOffset =
			    adaptor_priv->YBufOffset + (*dstPitch * 2 * width);
			adaptor_priv->VBufOffset =
			    adaptor_priv->UBufOffset + (*dstPitch * width / 2);
		} else {
			adaptor_priv->UBufOffset =
			    adaptor_priv->YBufOffset + (*dstPitch * 2 * height);
			adaptor_priv->VBufOffset =
			    adaptor_priv->UBufOffset + (*dstPitch * height / 2);
		}
#ifdef INTEL_XVMC
	}
#endif

a2349 4
	top = y1 >> 16;
	left = (x1 >> 16) & ~1;
	npixels = ((((x2 + 0xffff) >> 16) + 1) & ~1) - left;

d2351 4
a2354 7
		if (!xvmc_passthrough(id)) {
			top &= ~1;
			nlines = ((((y2 + 0xffff) >> 16) + 1) & ~1) - top;
			I830CopyPlanarData(adaptor_priv, buf, srcPitch, srcPitch2,
					   *dstPitch, height, top, left, nlines,
					   npixels, id);
		}
a2355 1
		nlines = ((y2 + 0xffff) >> 16) - top;
d2377 1
a2377 1
I830PutImage(ScrnInfoPtr scrn,
a2388 1
	ScreenPtr screen = screenInfo.screens[scrn->scrnIndex];
d2390 1
a2390 3
	INT32 x1, x2, y1, y2;
	int dstPitch;
	int dstPitch2 = 0;
d2393 1
d2401 36
a2436 6
	if (!adaptor_priv->textured) {
		/* If dst width and height are less than 1/8th the src size, the
		 * src/dst scale factor becomes larger than 8 and doesn't fit in
		 * the scale register. */
		if (src_w >= (drw_w * 8))
			drw_w = src_w / 7;
d2438 2
a2439 2
		if (src_h >= (drw_h * 8))
			drw_h = src_h / 7;
d2442 44
a2485 5
	/* Clip */
	x1 = src_x;
	x2 = src_x + src_w;
	y1 = src_y;
	y2 = src_y + src_h;
d2487 2
a2488 4
	dstBox.x1 = drw_x;
	dstBox.x2 = drw_x + drw_w;
	dstBox.y1 = drw_y;
	dstBox.y2 = drw_y + drw_h;
d2493 5
a2497 1
				    &dstBox, &x1, &x2, &y1, &y2, clipBoxes,
d2501 7
a2507 9
	if (!adaptor_priv->textured) {
		/* texture video handles rotation differently. */
		if (crtc)
			adaptor_priv->rotation = crtc->rotation;
		else {
			xf86DrvMsg(scrn->scrnIndex, X_WARNING,
				   "Fail to clip video to any crtc!\n");
			return Success;
		}
d2512 1
a2512 1
				  x1, y1, x2, y2, id, buf))
d2515 4
a2518 28
	if (!adaptor_priv->textured) {
		if (!i830_display_overlay
		    (scrn, crtc, id, width, height, dstPitch, x1, y1, x2, y2,
		     &dstBox, src_w, src_h, drw_w, drw_h))
			return BadAlloc;

		/* update cliplist */
		if (!REGION_EQUAL(scrn->screen, &adaptor_priv->clip, clipBoxes)) {
			REGION_COPY(scrn->screen, &adaptor_priv->clip, clipBoxes);
			i830_fill_colorkey(screen, adaptor_priv->colorKey, clipBoxes);
		}
	} else {
		if (crtc && adaptor_priv->SyncToVblank != 0) {
			i830_wait_for_scanline(scrn, pixmap, crtc, clipBoxes);
		}

		if (IS_I965G(intel)) {
			I965DisplayVideoTextured(scrn, adaptor_priv, id, clipBoxes,
						 width, height, dstPitch, x1,
						 y1, x2, y2, src_w, src_h,
						 drw_w, drw_h, pixmap);
		} else {
			I915DisplayVideoTextured(scrn, adaptor_priv, id, clipBoxes,
						 width, height, dstPitch,
						 dstPitch2, x1, y1, x2, y2,
						 src_w, src_h, drw_w, drw_h,
						 pixmap);
		}
d2520 6
a2525 1
		DamageDamageRegion(drawable, clipBoxes);
@


1.10
log
@Fix a segfault in X for a clipped movie window.

ok matthieu@@

Original commit message from barry scott to upstream:

 Author: Barry Scott <barry.scott@@onelan.co.uk>
 Date:   Tue Jun 23 14:14:50 2009 +0100

     Fix segv for clipped movie window

     When playing a movie that is clipped on its left and right edges the
     Xorg server will SEGV sometimes. This is because the intel driver
     ignores the clipping info when it copies the planes out of the XV
     data.  The check for the optimised copy was wrong to ignore the
     width required.  Which leads to too much data being copied by the
     memcpy. It the source buffe happens to end exactly on a page
     boundary the server will SEGV.

     As we reviewed the code we checked the calculation of src1, src2 and
     src3.  The patch includes additional comments to make it clear what
     the elements of the calculation are.

     This bug exists in git head and we also see it in 2.4.1.
@
text
@a25 1
/* $XFree86: xc/programs/Xserver/hw/xfree86/drivers/i810/i830_video.c,v 1.11tsi Exp $ */
a58 1
#include "xf86Resources.h"
a70 2
#include "xaa.h"
#include "xaalocal.h"
d80 1
a80 1
#define OFF_DELAY 	250		/* milliseconds */
a88 2
static void I830InitOffscreenImages(ScreenPtr);

d92 1
a92 1
static int I830SetPortAttribute(ScrnInfoPtr, Atom, INT32, pointer);
d101 2
a102 4
static int I830QueryImageAttributesOverlay(ScrnInfoPtr, int, unsigned short *,
					   unsigned short *, int *, int *);
static int I830QueryImageAttributesTextured(ScrnInfoPtr, int, unsigned short *,
					    unsigned short *, int *, int *);
d106 1
a106 1
static Atom xvBrightness, xvContrast, xvSaturation, xvColorKey, xvPipe, xvDoubleBuffer;
d112 2
a113 10
 * implementations.  However, we run into the bigrequests limit of (currently)
 * 4MB, which even the planar format's 2048*2048*1.5 bytes is larger than.
 * Conveniently, the HD resolution, even in packed format, takes
 * (1920*1088*2) bytes, which is just shy of 4MB.  Additionally, on the 830
 * and 845, larger sizes resulted in the card hanging, so we keep the limits
 * lower there.
 *
 * While the HD resolution is actually 1920x1080, we increase our advertised
 * size to 1088 because some software wants to send an image aligned to
 * 16-pixel boundaries.
d115 2
a116 2
#define IMAGE_MAX_WIDTH		1920
#define IMAGE_MAX_HEIGHT	1088
a126 5
/* Oops, I never exported this function in EXA.  I meant to. */
#ifndef exaMoveInPixmap
void exaMoveInPixmap (PixmapPtr pPixmap);
#endif

d198 6
a203 6
    {
	0,
	"XV_IMAGE",
	IMAGE_MAX_WIDTH, IMAGE_MAX_HEIGHT,
	{1, 1}
    }
d209 1
a209 1
    {15, TrueColor}, {16, TrueColor}, {24, TrueColor}
d214 1
a214 1
    {XvSettable | XvGettable, -1, 1, "XV_PIPE"}
d217 1
a217 1
#define NUM_ATTRIBUTES 5
d219 4
a222 5
    {XvSettable | XvGettable, 0, (1 << 24) - 1, "XV_COLORKEY"},
    {XvSettable | XvGettable, -128, 127, "XV_BRIGHTNESS"},
    {XvSettable | XvGettable, 0, 255, "XV_CONTRAST"},
    {XvSettable | XvGettable, 0, 1023, "XV_SATURATION"},
    {XvSettable | XvGettable, 0, 1, "XV_DOUBLE_BUFFER"}
d227 3
a229 3
    {XvSettable | XvGettable, -128, 127, "XV_BRIGHTNESS"},
    {XvSettable | XvGettable, 0, 255, "XV_CONTRAST"},
    {XvSettable | XvGettable, -1, 1, "XV_SYNC_TO_VBLANK"},
d234 6
a239 6
    {XvSettable | XvGettable, 0, 0xffffff, "XV_GAMMA0"},
    {XvSettable | XvGettable, 0, 0xffffff, "XV_GAMMA1"},
    {XvSettable | XvGettable, 0, 0xffffff, "XV_GAMMA2"},
    {XvSettable | XvGettable, 0, 0xffffff, "XV_GAMMA3"},
    {XvSettable | XvGettable, 0, 0xffffff, "XV_GAMMA4"},
    {XvSettable | XvGettable, 0, 0xffffff, "XV_GAMMA5"}
d245 4
a248 4
    XVIMAGE_YUY2,
    XVIMAGE_YV12,
    XVIMAGE_I420,
    XVIMAGE_UYVY,
d250 23
a272 24
    {
        /*
         * Below, a dummy picture type that is used in XvPutImage only to do
         * an overlay update. Introduced for the XvMC client lib.
         * Defined to have a zero data size.
         */
        FOURCC_XVMC,
        XvYUV,
        LSBFirst,
        {'X', 'V', 'M', 'C',
         0x00, 0x00, 0x00, 0x10, 0x80, 0x00, 0x00, 0xAA, 0x00,
         0x38, 0x9B, 0x71},
        12,
        XvPlanar,
        3,
        0, 0, 0, 0,
        8, 8, 8,
        1, 2, 2,
        1, 2, 2,
        {'Y', 'V', 'U',
         0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
         0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
        XvTopToBottom
    },
d331 3
a333 3
#define I830OVERLAYREG(pI830) ((I830OverlayRegPtr)\
			       ((pI830)->FbBase + \
				(pI830)->overlay_regs->offset))
d335 1
a335 2
static void
CompareOverlay(I830Ptr pI830, uint32_t * overlay, int size)
d337 3
a339 3
    int i;
    uint32_t val;
    int bad = 0;
d341 8
a348 6
    for (i = 0; i < size; i += 4) {
	val = INREG(0x30100 + i);
	if (val != overlay[i / 4]) {
	    OVERLAY_DEBUG("0x%05x value doesn't match (0x%lx != 0x%lx)\n",
			  0x30100 + i, val, overlay[i / 4]);
	    bad++;
d350 2
a351 3
    }
    if (!bad)
	OVERLAY_DEBUG("CompareOverlay: no differences\n");
d355 1
a355 2
static void
I830SetOneLineModeRatio(ScrnInfoPtr pScrn);
d358 1
a358 1
i830_overlay_switch_to_crtc (ScrnInfoPtr pScrn, xf86CrtcPtr crtc)
d360 4
a363 4
    I830Ptr		pI830 = I830PTR(pScrn);
    I830PortPrivPtr	pPriv = GET_PORT_PRIVATE(pScrn);
    I830CrtcPrivatePtr  intel_crtc = crtc->driver_private;
    int			pipeconf_reg = intel_crtc->pipe == 0 ? PIPEACONF : PIPEBCONF;
d366 1
a366 1
    if ((!IS_I965G(pI830) && (INREG(pipeconf_reg) & PIPEACONF_DOUBLE_WIDE))
d368 1
a368 1
	pPriv->overlayOK = FALSE;
d370 1
a370 1
	pPriv->overlayOK = TRUE;
d372 1
a372 1
    if (!pPriv->overlayOK)
d389 1
a389 1
	    I830SetOneLineModeRatio(pScrn);
d391 1
a391 1
	if (pPriv->scaleRatio & 0xFFFE0000) 
d394 1
a394 1
	    xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
d397 1
a397 1
	    xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
d399 1
a399 1
		       pPriv->scaleRatio,
d402 1
a402 1
	    pPriv->scaleRatio = (int)(((float)active * 65536) / (float)vsize);
d416 1
a416 1
i830_overlay_on(ScrnInfoPtr pScrn)
d418 3
a420 3
    I830Ptr		pI830 = I830PTR(pScrn);
    I830OverlayRegPtr	overlay = I830OVERLAYREG(pI830);
    I830PortPrivPtr	pPriv = pI830->adaptor->pPortPrivates[0].ptr;
d423 1
a423 1
    if (pI830->overlayOn)
d431 2
a432 2
    if (pPriv->current_crtc && i830_crtc_pipe (pPriv->current_crtc) != 0)
	deactivate = i830_pipe_a_require_activate (pScrn);
d439 2
a440 2
    if (OVERLAY_NOPHYSICAL(pI830))
	OUT_BATCH(pI830->overlay_regs->offset | OFC_UPDATE);
d442 1
a442 1
	OUT_BATCH(pI830->overlay_regs->bus_addr | OFC_UPDATE);
d447 1
a447 1
    i830WaitSync(pScrn);
d454 1
a454 1
	i830_pipe_a_require_deactivate (pScrn);
d457 1
a457 1
    pI830->overlayOn = TRUE;
d463 1
a463 1
i830_overlay_continue(ScrnInfoPtr pScrn, Bool update_filter)
d465 1
a465 1
    I830Ptr		pI830 = I830PTR(pScrn);
d467 1
a467 1
    I830OverlayRegPtr	overlay = I830OVERLAYREG(pI830);
d469 1
a469 1
    if (!pI830->overlayOn)
d472 2
a473 2
    if (OVERLAY_NOPHYSICAL(pI830))
	flip_addr = pI830->overlay_regs->offset;
d475 1
a475 1
	flip_addr = pI830->overlay_regs->bus_addr;
d487 2
d492 1
a492 1
i830_overlay_off(ScrnInfoPtr pScrn)
d494 2
a495 2
    I830Ptr pI830 = I830PTR(pScrn);
    I830OverlayRegPtr	overlay = I830OVERLAYREG(pI830);
d497 1
a497 1
    if (!pI830->overlayOn)
d502 1
a502 1
     * separated from the turning off state by a WaitSync
d512 1
a512 1
	i830WaitSync(pScrn);
d526 2
a527 2
	if (OVERLAY_NOPHYSICAL(pI830))
	    OUT_BATCH(pI830->overlay_regs->offset);
d529 1
a529 1
	    OUT_BATCH(pI830->overlay_regs->bus_addr);
d533 1
a533 1
	i830WaitSync(pScrn);
d535 1
a535 1
    pI830->overlayOn = FALSE;
d539 1
a539 2
void
I830InitVideo(ScreenPtr pScreen)
d541 5
a545 5
    ScrnInfoPtr pScrn = xf86Screens[pScreen->myNum];
    I830Ptr pI830 = I830PTR(pScrn);
    XF86VideoAdaptorPtr *adaptors, *newAdaptors = NULL;
    XF86VideoAdaptorPtr overlayAdaptor = NULL, texturedAdaptor = NULL;
    int num_adaptors;
d547 1
a547 1
    Bool xvmc_status = FALSE;
d550 12
a561 3
#if 0
    {
	I830OverlayRegRec tmp;
d563 5
a567 9
	ErrorF("sizeof I830OverlayRegRec is 0x%x\n", sizeof(I830OverlayRegRec));
	ErrorF("Reserved C, D, E, F, G are %x, %x, %x, %x, %x\n",
	       (unsigned long)&(tmp.RESERVEDC[0]) - (unsigned long)&tmp,
	       (unsigned long)&(tmp.RESERVEDD[0]) - (unsigned long)&tmp,
	       (unsigned long)&(tmp.RESERVEDE[0]) - (unsigned long)&tmp,
	       (unsigned long)&(tmp.RESERVEDF[0]) - (unsigned long)&tmp,
	       (unsigned long)&(tmp.RESERVEDG[0]) - (unsigned long)&tmp);
    }
#endif
d569 13
a581 29
    num_adaptors = xf86XVListGenericAdaptors(pScrn, &adaptors);
    /* Give our adaptor list enough space for the overlay and/or texture video
     * adaptors.
     */
    newAdaptors = xalloc((num_adaptors + 2) * sizeof(XF86VideoAdaptorPtr *));
    if (newAdaptors == NULL)
	return;

    memcpy(newAdaptors, adaptors, num_adaptors * sizeof(XF86VideoAdaptorPtr));
    adaptors = newAdaptors;

    /* Add the adaptors supported by our hardware.  First, set up the atoms
     * that will be used by both output adaptors.
     */
    xvBrightness = MAKE_ATOM("XV_BRIGHTNESS");
    xvContrast = MAKE_ATOM("XV_CONTRAST");

    /* Set up textured video if we can do it at this depth and we are on
     * supported hardware.
     */
    if (pScrn->bitsPerPixel >= 16 && (IS_I9XX(pI830) || IS_I965G(pI830)) &&
	!(!IS_I965G(pI830) && pScrn->displayWidth > 2048))
    {
	texturedAdaptor = I830SetupImageVideoTextured(pScreen);
	if (texturedAdaptor != NULL) {
	    xf86DrvMsg(pScrn->scrnIndex, X_INFO, "Set up textured video\n");
	} else {
	    xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
		       "Failed to set up textured video\n");
a582 1
    }
d584 10
a593 10
    /* Set up overlay video if we can do it at this depth. */
    if (!OVERLAY_NOEXIST(pI830) && pScrn->bitsPerPixel != 8 &&
	!pI830->use_drm_mode && pI830->overlay_regs != NULL)
    {
	overlayAdaptor = I830SetupImageVideoOverlay(pScreen);
	if (overlayAdaptor != NULL) {
	    xf86DrvMsg(pScrn->scrnIndex, X_INFO, "Set up overlay video\n");
	} else {
	    xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
		       "Failed to set up overlay video\n");
a594 2
	I830InitOffscreenImages(pScreen);
    }
d596 2
a597 2
    if (overlayAdaptor && pI830->XvPreferOverlay)
       adaptors[num_adaptors++] = overlayAdaptor;
d599 2
a600 2
    if (texturedAdaptor)
       adaptors[num_adaptors++] = texturedAdaptor;
d602 2
a603 2
    if (overlayAdaptor && !pI830->XvPreferOverlay)
       adaptors[num_adaptors++] = overlayAdaptor;
d606 5
a610 4
    if (intel_xvmc_probe(pScrn)) {
	if (texturedAdaptor)
	    xvmc_status = intel_xvmc_driver_init(pScreen, texturedAdaptor);
    }
d613 7
a619 7
    if (num_adaptors) {
	xf86XVScreenInit(pScreen, adaptors, num_adaptors);
    } else {
	xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
		   "Disabling Xv because no adaptors could be initialized.\n");
	pI830->XvEnabled = FALSE;
    }
d622 2
a623 2
    if (xvmc_status)
	intel_xvmc_screen_init(pScreen);
d625 1
a625 1
    xfree(adaptors);
d629 1
a629 1
I830ResetVideo(ScrnInfoPtr pScrn)
d631 3
a633 3
    I830Ptr pI830 = I830PTR(pScrn);
    I830PortPrivPtr pPriv = pI830->adaptor->pPortPrivates[0].ptr;
    I830OverlayRegPtr	overlay = I830OVERLAYREG(pI830);
d636 1
a636 1
		  pI830->FbBase, pI830->overlay_regs->offset, overlay);
d651 2
a652 2
    overlay->OCLRC0 = (pPriv->contrast << 18) | (pPriv->brightness & 0xff);
    overlay->OCLRC1 = pPriv->saturation;
d662 1
a662 1
    switch (pScrn->depth) {
d668 1
a668 1
	overlay->DCLRKV = RGB15ToColorKey(pPriv->colorKey);
d672 1
a672 1
	overlay->DCLRKV = RGB16ToColorKey(pPriv->colorKey);
d676 1
a676 1
	overlay->DCLRKV = pPriv->colorKey;
d685 1
a685 1
    if (IS_I965GM(pI830))
d692 1
a692 1
    if (i830_crtc_pipe (pPriv->current_crtc) == 0)
d718 1
a718 1
I830SetOneLineModeRatio(ScrnInfoPtr pScrn)
d720 2
a721 2
    I830Ptr pI830 = I830PTR(pScrn);
    I830PortPrivPtr pPriv = pI830->adaptor->pPortPrivates[0].ptr;
d725 1
a725 1
    pPriv->scaleRatio = 0x10000;
d735 1
a735 1
	    pPriv->scaleRatio = ((double) 0x10000 / (double)vertScale) * 0x10000;
d737 1
a737 1
	pPriv->oneLineMode = TRUE;
d739 1
a739 1
	xf86DrvMsg(pScrn->scrnIndex, X_INFO, "Enabling Xvideo one-line mode\n");
d742 2
a743 2
    if (pPriv->scaleRatio == 0x10000)
	pPriv->oneLineMode = FALSE;
d759 1
a759 2
    return (I830BoundGammaElt (gamma >> 24, gammaPrev >> 24) << 24 |
	    I830BoundGammaElt (gamma >> 16, gammaPrev >> 16) << 16 |
d764 15
d780 1
a780 1
I830UpdateGamma(ScrnInfoPtr pScrn)
d782 8
a789 8
    I830Ptr pI830 = I830PTR(pScrn);
    I830PortPrivPtr pPriv = pI830->adaptor->pPortPrivates[0].ptr;
    uint32_t gamma0 = pPriv->gamma0;
    uint32_t gamma1 = pPriv->gamma1;
    uint32_t gamma2 = pPriv->gamma2;
    uint32_t gamma3 = pPriv->gamma3;
    uint32_t gamma4 = pPriv->gamma4;
    uint32_t gamma5 = pPriv->gamma5;
d800 1
d814 1
a814 2
static XF86VideoAdaptorPtr
I830SetupImageVideoOverlay(ScreenPtr pScreen)
d816 92
a907 88
    ScrnInfoPtr pScrn = xf86Screens[pScreen->myNum];
    I830Ptr pI830 = I830PTR(pScrn);
    XF86VideoAdaptorPtr adapt;
    I830PortPrivPtr pPriv;
    XF86AttributePtr att;

    OVERLAY_DEBUG("I830SetupImageVideoOverlay\n");

    if (!(adapt = xcalloc(1, sizeof(XF86VideoAdaptorRec) +
			  sizeof(I830PortPrivRec) + sizeof(DevUnion))))
	return NULL;

    adapt->type = XvWindowMask | XvInputMask | XvImageMask;
    adapt->flags = VIDEO_OVERLAID_IMAGES /*| VIDEO_CLIP_TO_VIEWPORT*/;
    adapt->name = "Intel(R) Video Overlay";
    adapt->nEncodings = 1;
    adapt->pEncodings = DummyEncoding;
    /* update the DummyEncoding for these two chipsets */
    if (IS_845G(pI830) || IS_I830(pI830)) {
	adapt->pEncodings->width = IMAGE_MAX_WIDTH_LEGACY;
	adapt->pEncodings->height = IMAGE_MAX_HEIGHT_LEGACY;
    }
    adapt->nFormats = NUM_FORMATS;
    adapt->pFormats = Formats;
    adapt->nPorts = 1;
    adapt->pPortPrivates = (DevUnion *) (&adapt[1]);

    pPriv = (I830PortPrivPtr) (&adapt->pPortPrivates[1]);

    adapt->pPortPrivates[0].ptr = (pointer) (pPriv);
    adapt->nAttributes = NUM_ATTRIBUTES;
    adapt->nAttributes += CLONE_ATTRIBUTES;
    if (IS_I9XX(pI830))
	adapt->nAttributes += GAMMA_ATTRIBUTES; /* has gamma */
    adapt->pAttributes = xnfalloc(sizeof(XF86AttributeRec) * adapt->nAttributes);
    /* Now copy the attributes */
    att = adapt->pAttributes;
    memcpy((char *)att, (char*)Attributes, sizeof(XF86AttributeRec)* NUM_ATTRIBUTES);
    att+=NUM_ATTRIBUTES;
    memcpy((char*)att, (char*)CloneAttributes, sizeof(XF86AttributeRec) * CLONE_ATTRIBUTES);
    att+=CLONE_ATTRIBUTES;
    if (IS_I9XX(pI830)) {
	memcpy((char*)att, (char*)GammaAttributes, sizeof(XF86AttributeRec) * GAMMA_ATTRIBUTES);
	att+=GAMMA_ATTRIBUTES;
    }
    adapt->nImages = NUM_IMAGES;
    adapt->pImages = Images;
    adapt->PutVideo = NULL;
    adapt->PutStill = NULL;
    adapt->GetVideo = NULL;
    adapt->GetStill = NULL;
    adapt->StopVideo = I830StopVideo;
    adapt->SetPortAttribute = I830SetPortAttribute;
    adapt->GetPortAttribute = I830GetPortAttribute;
    adapt->QueryBestSize = I830QueryBestSize;
    adapt->PutImage = I830PutImage;
    adapt->QueryImageAttributes = I830QueryImageAttributesOverlay;

    pPriv->textured = FALSE;
    pPriv->colorKey = pI830->colorKey & ((1 << pScrn->depth) - 1);
    pPriv->videoStatus = 0;
    pPriv->brightness = -19; /* (255/219) * -16 */
    pPriv->contrast = 75;  /* 255/219 * 64 */
    pPriv->saturation = 146; /* 128/112 * 128 */
    pPriv->current_crtc = NULL;
    pPriv->desired_crtc = NULL;
    pPriv->buf = NULL;
    pPriv->currentBuf = 0;
    pPriv->gamma5 = 0xc0c0c0;
    pPriv->gamma4 = 0x808080;
    pPriv->gamma3 = 0x404040;
    pPriv->gamma2 = 0x202020;
    pPriv->gamma1 = 0x101010;
    pPriv->gamma0 = 0x080808;
    pPriv->doubleBuffer = 1;

    pPriv->rotation = RR_Rotate_0;

    /* gotta uninit this someplace */
    REGION_NULL(pScreen, &pPriv->clip);

    pI830->adaptor = adapt;

    /* With LFP's we need to detect whether we're in One Line Mode, which
     * essentially means a resolution greater than 1024x768, and fix up
     * the scaler accordingly. */
    pPriv->scaleRatio = 0x10000;
    pPriv->oneLineMode = FALSE;
d909 6
a914 6
    /*
     * Initialise pPriv->overlayOK.  Set it to TRUE here so that a warning will
     * be generated if i830_crtc_dpms_video() sets it to FALSE during mode
     * setup.
     */
    pPriv->overlayOK = TRUE;
d916 114
a1029 5
    xvColorKey = MAKE_ATOM("XV_COLORKEY");
    xvBrightness = MAKE_ATOM("XV_BRIGHTNESS");
    xvContrast = MAKE_ATOM("XV_CONTRAST");
    xvSaturation = MAKE_ATOM("XV_SATURATION");
    xvDoubleBuffer = MAKE_ATOM("XV_DOUBLE_BUFFER");
d1031 4
a1034 17
    /* Allow the pipe to be switched from pipe A to B when in clone mode */
    xvPipe = MAKE_ATOM("XV_PIPE");

    if (IS_I9XX(pI830)) {
	xvGamma0 = MAKE_ATOM("XV_GAMMA0");
	xvGamma1 = MAKE_ATOM("XV_GAMMA1");
	xvGamma2 = MAKE_ATOM("XV_GAMMA2");
	xvGamma3 = MAKE_ATOM("XV_GAMMA3");
	xvGamma4 = MAKE_ATOM("XV_GAMMA4");
	xvGamma5 = MAKE_ATOM("XV_GAMMA5");
    }

    I830ResetVideo(pScrn);

    I830UpdateGamma(pScrn);

    return adapt;
d1037 1
a1037 2
static XF86VideoAdaptorPtr
I830SetupImageVideoTextured(ScreenPtr pScreen)
d1039 1
a1039 6
    XF86VideoAdaptorPtr adapt;
    XF86AttributePtr attrs;
    I830PortPrivPtr portPrivs;
    DevUnion *devUnions;
    int nports = 16, i;
    int nAttributes;
d1041 2
a1042 1
    OVERLAY_DEBUG("I830SetupImageVideoOverlay\n");
d1044 1
a1044 1
    nAttributes = NUM_TEXTURED_ATTRIBUTES;
d1046 1
a1046 53
    adapt = xcalloc(1, sizeof(XF86VideoAdaptorRec));
    portPrivs = xcalloc(nports, sizeof(I830PortPrivRec));
    devUnions = xcalloc(nports, sizeof(DevUnion));
    attrs = xcalloc(nAttributes, sizeof(XF86AttributeRec));
    if (adapt == NULL || portPrivs == NULL || devUnions == NULL ||
	attrs == NULL)
    {
	xfree(adapt);
	xfree(portPrivs);
	xfree(devUnions);
	xfree(attrs);
	return NULL;
    }

    adapt->type = XvWindowMask | XvInputMask | XvImageMask;
    adapt->flags = 0;
    adapt->name = "Intel(R) Textured Video";
    adapt->nEncodings = 1;
    adapt->pEncodings = DummyEncoding;
    adapt->nFormats = NUM_FORMATS;
    adapt->pFormats = Formats;
    adapt->nPorts = nports;
    adapt->pPortPrivates = devUnions;
    adapt->nAttributes = nAttributes;
    adapt->pAttributes = attrs;
    memcpy(attrs, TexturedAttributes, nAttributes * sizeof(XF86AttributeRec));
    adapt->nImages = NUM_IMAGES;
    adapt->pImages = Images;
    adapt->PutVideo = NULL;
    adapt->PutStill = NULL;
    adapt->GetVideo = NULL;
    adapt->GetStill = NULL;
    adapt->StopVideo = I830StopVideo;
    adapt->SetPortAttribute = I830SetPortAttributeTextured;
    adapt->GetPortAttribute = I830GetPortAttribute;
    adapt->QueryBestSize = I830QueryBestSize;
    adapt->PutImage = I830PutImage;
    adapt->QueryImageAttributes = I830QueryImageAttributesTextured;

    for (i = 0; i < nports; i++) {
	I830PortPrivPtr pPriv = &portPrivs[i];

	pPriv->textured = TRUE;
	pPriv->videoStatus = 0;
	pPriv->buf = NULL;
	pPriv->currentBuf = 0;
	pPriv->doubleBuffer = 0;

	pPriv->rotation = RR_Rotate_0;
	pPriv->SyncToVblank = 1;

	/* gotta uninit this someplace, XXX: shouldn't be necessary for textured */
	REGION_NULL(pScreen, &pPriv->clip);
d1048 3
a1050 2
	adapt->pPortPrivates[i].ptr = (pointer) (pPriv);
    }
d1052 8
a1059 1
    xvSyncToVblank = MAKE_ATOM("XV_SYNC_TO_VBLANK");
a1060 1
    return adapt;
d1063 3
a1065 2
static void
I830StopVideo(ScrnInfoPtr pScrn, pointer data, Bool shutdown)
d1067 1
a1067 1
    I830PortPrivPtr pPriv = (I830PortPrivPtr) data;
d1069 19
a1087 2
    if (pPriv->textured)
	return;
d1089 5
a1093 1
    OVERLAY_DEBUG("I830StopVideo\n");
d1095 1
a1095 1
    REGION_EMPTY(pScrn->pScreen, &pPriv->clip);
d1097 3
a1099 4
    if (shutdown) {
	if (pPriv->videoStatus & CLIENT_VIDEO_ON) {
	    i830_overlay_off(pScrn);
	}
d1101 10
a1110 12
	if (pPriv->buf) {
	    if (!pPriv->textured)
		drm_intel_bo_unpin(pPriv->buf);
	    drm_intel_bo_unreference(pPriv->buf);
	    pPriv->buf = NULL;
	    pPriv->videoStatus = 0;
	}
    } else {
	if (pPriv->videoStatus & CLIENT_VIDEO_ON) {
	    pPriv->videoStatus |= OFF_TIMER;
	    pPriv->offTime = currentTime.milliseconds + OFF_DELAY;
	}
d1113 3
d1119 2
a1120 2
I830SetPortAttributeTextured(ScrnInfoPtr pScrn,
			     Atom attribute, INT32 value, pointer data)
d1122 2
a1123 1
    I830PortPrivPtr pPriv = (I830PortPrivPtr) data;
d1125 52
a1176 20
    if (attribute == xvBrightness) {
	if ((value < -128) || (value > 127))
	    return BadValue;
	pPriv->brightness = value;
	return Success;
    } else if (attribute == xvContrast) {
	if ((value < 0) || (value > 255))
	    return BadValue;
	pPriv->contrast = value;
	return Success;
    } else if (attribute == xvSyncToVblank) {
        if ((value < -1) || (value > 1))
            return BadValue;
        
        pPriv->SyncToVblank = value;
        return Success;
    } else {
	return BadMatch;
    }
}
d1178 1
a1178 7
static int
I830SetPortAttribute(ScrnInfoPtr pScrn,
		     Atom attribute, INT32 value, pointer data)
{
    I830PortPrivPtr pPriv = (I830PortPrivPtr) data;
    I830Ptr pI830 = I830PTR(pScrn);
    I830OverlayRegPtr overlay;
d1180 2
a1181 1
    overlay = I830OVERLAYREG(pI830);
d1183 2
a1184 67
    if (attribute == xvBrightness) {
	if ((value < -128) || (value > 127))
	    return BadValue;
	pPriv->brightness = value;
	overlay->OCLRC0 = (pPriv->contrast << 18) | (pPriv->brightness & 0xff);
	OVERLAY_DEBUG("BRIGHTNESS\n");
	i830_overlay_continue (pScrn, FALSE);
    } else if (attribute == xvContrast) {
	if ((value < 0) || (value > 255))
	    return BadValue;
	pPriv->contrast = value;
	overlay->OCLRC0 = (pPriv->contrast << 18) | (pPriv->brightness & 0xff);
	OVERLAY_DEBUG("CONTRAST\n");
	i830_overlay_continue (pScrn, FALSE);
    } else if (attribute == xvSaturation) {
	if ((value < 0) || (value > 1023))
	    return BadValue;
	pPriv->saturation = value;
	overlay->OCLRC1 = pPriv->saturation;
	i830_overlay_continue (pScrn, FALSE);
    } else if (attribute == xvPipe) {
	xf86CrtcConfigPtr   xf86_config = XF86_CRTC_CONFIG_PTR(pScrn);
	if ((value < -1) || (value > xf86_config->num_crtc))
	    return BadValue;
	if (value < 0)
	    pPriv->desired_crtc = NULL;
	else
	    pPriv->desired_crtc = xf86_config->crtc[value];
	/*
	 * Leave this to be updated at the next frame
	 */
    } else if (attribute == xvGamma0 && (IS_I9XX(pI830))) {
	pPriv->gamma0 = value; 
    } else if (attribute == xvGamma1 && (IS_I9XX(pI830))) {
	pPriv->gamma1 = value;
    } else if (attribute == xvGamma2 && (IS_I9XX(pI830))) {
	pPriv->gamma2 = value;
    } else if (attribute == xvGamma3 && (IS_I9XX(pI830))) {
	pPriv->gamma3 = value;
    } else if (attribute == xvGamma4 && (IS_I9XX(pI830))) {
	pPriv->gamma4 = value;
    } else if (attribute == xvGamma5 && (IS_I9XX(pI830))) {
	pPriv->gamma5 = value;
    } else if (attribute == xvColorKey) {
	pPriv->colorKey = value;
	switch (pScrn->depth) {
	case 16:
	    overlay->DCLRKV = RGB16ToColorKey(pPriv->colorKey);
	    break;
	case 15:
	    overlay->DCLRKV = RGB15ToColorKey(pPriv->colorKey);
	    break;
	default:
	    overlay->DCLRKV = pPriv->colorKey;
	    break;
	}
	OVERLAY_DEBUG("COLORKEY\n");
	i830_overlay_continue (pScrn, FALSE);
	REGION_EMPTY(pScrn->pScreen, &pPriv->clip);
    } else if(attribute == xvDoubleBuffer) {
	if ((value < 0) || (value > 1))
	    return BadValue;
	/* Do not allow buffer change while playing video */
	if(!pI830->overlayOn)
	    pPriv->doubleBuffer = value;
    } else
	return BadMatch;
d1186 1
a1186 12
    /* Ensure that the overlay is off, ready for updating */
    if ((attribute == xvGamma0 ||
	 attribute == xvGamma1 ||
	 attribute == xvGamma2 ||
	 attribute == xvGamma3 ||
	 attribute == xvGamma4 ||
	 attribute == xvGamma5) && (IS_I9XX(pI830))) {
	OVERLAY_DEBUG("GAMMA\n");
	I830UpdateGamma(pScrn);
    }

    return Success;
d1190 1
a1190 1
I830GetPortAttribute(ScrnInfoPtr pScrn,
d1193 2
a1194 2
    I830Ptr pI830 = I830PTR(pScrn);
    I830PortPrivPtr pPriv = (I830PortPrivPtr) data;
d1196 33
a1228 35
    if (attribute == xvBrightness) {
	*value = pPriv->brightness;
    } else if (attribute == xvContrast) {
	*value = pPriv->contrast;
    } else if (attribute == xvSaturation) {
	*value = pPriv->saturation;
    } else if (attribute == xvPipe) {
	int		c;
	xf86CrtcConfigPtr	xf86_config = XF86_CRTC_CONFIG_PTR(pScrn);
	for (c = 0; c < xf86_config->num_crtc; c++)
	    if (xf86_config->crtc[c] == pPriv->desired_crtc)
		break;
	if (c == xf86_config->num_crtc)
	    c = -1;
	*value = c;
    } else if (attribute == xvGamma0 && (IS_I9XX(pI830))) {
	*value = pPriv->gamma0;
    } else if (attribute == xvGamma1 && (IS_I9XX(pI830))) {
	*value = pPriv->gamma1;
    } else if (attribute == xvGamma2 && (IS_I9XX(pI830))) {
	*value = pPriv->gamma2;
    } else if (attribute == xvGamma3 && (IS_I9XX(pI830))) {
	*value = pPriv->gamma3;
    } else if (attribute == xvGamma4 && (IS_I9XX(pI830))) {
	*value = pPriv->gamma4;
    } else if (attribute == xvGamma5 && (IS_I9XX(pI830))) {
	*value = pPriv->gamma5;
    } else if (attribute == xvColorKey) {
	*value = pPriv->colorKey;
    } else if (attribute == xvDoubleBuffer) {
	*value = pPriv->doubleBuffer;
    } else if (attribute == xvSyncToVblank) {
        *value = pPriv->SyncToVblank;
    } else
	return BadMatch;
d1230 1
a1230 1
    return Success;
d1234 1
a1234 1
I830QueryBestSize(ScrnInfoPtr pScrn,
d1240 4
a1243 4
    if (vid_w > (drw_w << 1))
	drw_w = vid_w >> 1;
    if (vid_h > (drw_h << 1))
	drw_h = vid_h >> 1;
d1245 2
a1246 2
    *p_w = drw_w;
    *p_h = drw_h;
d1250 1
a1250 1
I830CopyPackedData(ScrnInfoPtr pScrn, I830PortPrivPtr pPriv,
d1252 1
a1252 2
		   int srcPitch,
		   int dstPitch, int top, int left, int h, int w)
d1254 3
a1256 4
    I830Ptr pI830 = I830PTR(pScrn);
    unsigned char *src, *dst, *dst_base;
    int i,j;
    unsigned char *s;
d1259 3
a1261 3
    ErrorF("I830CopyPackedData: (%d,%d) (%d,%d)\n"
	   "srcPitch: %d, dstPitch: %d\n", top, left, h, w,
	   srcPitch, dstPitch);
d1264 1
a1264 1
    src = buf + (top * srcPitch) + (left << 1);
d1266 2
a1267 7
    if (pPriv->textured) {
	drm_intel_bo_map(pPriv->buf, TRUE);
	dst_base = pPriv->buf->virtual;
    } else {
	drm_intel_gem_bo_start_gtt_access(pPriv->buf, TRUE);
	dst_base = pI830->FbBase;
    }
d1269 1
a1269 4
    if (pPriv->currentBuf == 0)
	dst = dst_base + pPriv->YBuf0offset;
    else
	dst = dst_base + pPriv->YBuf1offset;
d1271 84
a1354 7
    switch (pPriv->rotation) {
    case RR_Rotate_0:
	w <<= 1;
	for (i = 0; i < h; i++) {
	    memcpy(dst, src, w);
	    src += srcPitch;
	    dst += dstPitch;
d1356 51
a1406 36
	break;
    case RR_Rotate_90:
	h <<= 1;
	for (i = 0; i < h; i+=2) {
	    s = src;
	    for (j = 0; j < w; j++) {
		/* Copy Y */
		dst[(i + 0) + ((w - j - 1) * dstPitch)] = *s++; 
		(void)*s++;
	    }
	    src += srcPitch;
	}
	h >>= 1;
	src = buf + (top * srcPitch) + (left << 1);
	for (i = 0; i < h; i+=2) {
	    for (j = 0; j < w; j+=2) {
		/* Copy U */
		dst[((i*2) + 1) + ((w - j - 1) * dstPitch)] = src[(j*2) + 1 + (i * srcPitch)];
		dst[((i*2) + 1) + ((w - j - 2) * dstPitch)] = src[(j*2) + 1 + ((i+1) * srcPitch)];
		/* Copy V */
		dst[((i*2) + 3) + ((w - j - 1) * dstPitch)] = src[(j*2) + 3 + (i * srcPitch)];
		dst[((i*2) + 3) + ((w - j - 2) * dstPitch)] = src[(j*2) + 3 + ((i+1) * srcPitch)];
	    }
	}
	break;
    case RR_Rotate_180:
	w <<= 1;
	for (i = 0; i < h; i++) {
	    s = src;
	    for (j = 0; j < w; j+=4) {
		dst[(w - j - 4) + ((h - i - 1) * dstPitch)] = *s++;
		dst[(w - j - 3) + ((h - i - 1) * dstPitch)] = *s++;
		dst[(w - j - 2) + ((h - i - 1) * dstPitch)] = *s++;
		dst[(w - j - 1) + ((h - i - 1) * dstPitch)] = *s++;
	    }
	    src += srcPitch;
a1407 29
	break;
    case RR_Rotate_270:
	h <<= 1;
	for (i = 0; i < h; i+=2) {
	    s = src;
	    for (j = 0; j < w; j++) {
		/* Copy Y */
		dst[(h - i - 2) + (j * dstPitch)] = *s++;
		(void)*s++;
	    }
	    src += srcPitch;
	}
	h >>= 1;
	src = buf + (top * srcPitch) + (left << 1);
	for (i = 0; i < h; i+=2) {
	    for (j = 0; j < w; j+=2) {
		/* Copy U */
		dst[(((h - i)*2) - 3) + (j * dstPitch)] = src[(j*2) + 1 + (i * srcPitch)];
		dst[(((h - i)*2) - 3) + ((j - 1) * dstPitch)] = src[(j*2) + 1 + ((i+1) * srcPitch)];
		/* Copy V */
		dst[(((h - i)*2) - 1) + (j * dstPitch)] = src[(j*2) + 3 + (i * srcPitch)];
		dst[(((h - i)*2) - 1) + ((j - 1) * dstPitch)] = src[(j*2) + 3 + ((i+1) * srcPitch)];
	    }
	}
	break;
    }

    if (pPriv->textured)
	drm_intel_bo_unmap(pPriv->buf);
d1411 1
a1411 1
I830CopyPlanarData(ScrnInfoPtr pScrn, I830PortPrivPtr pPriv,
d1416 2
a1417 5
    I830Ptr pI830 = I830PTR(pScrn);
    int i, j = 0;
    unsigned char *src1, *src2, *src3, *dst_base, *dst1, *dst2, *dst3;
    unsigned char *s;
    int dstPitch2 = dstPitch << 1;
d1420 3
a1422 4
    ErrorF("I830CopyPlanarData: srcPitch %d, srcPitch %d, dstPitch %d\n"
	   "nlines %d, npixels %d, top %d, left %d\n",
	   srcPitch, srcPitch2, dstPitch,
	   h, w, top, left);
d1425 2
a1426 2
    /* Copy Y data */
    src1 = buf + (top * srcPitch) + left;
d1428 2
a1429 2
    ErrorF("src1 is %p, offset is %ld\n", src1,
	   (unsigned long)src1 - (unsigned long)buf);
d1432 2
a1433 7
    if (pPriv->textured) {
	drm_intel_bo_map(pPriv->buf, TRUE);
	dst_base = pPriv->buf->virtual;
    } else {
	drm_intel_gem_bo_start_gtt_access(pPriv->buf, TRUE);
	dst_base = pI830->FbBase;
    }
d1435 1
a1435 4
    if (pPriv->currentBuf == 0)
	dst1 = dst_base + pPriv->YBuf0offset;
    else
	dst1 = dst_base + pPriv->YBuf1offset;
d1437 2
a1438 40
    switch (pPriv->rotation) {
    case RR_Rotate_0:
       /* optimise for the case of no clipping */
	if (srcPitch == dstPitch2 && srcPitch == w)
	    memcpy (dst1, src1, srcPitch * h);
	else
	    for (i = 0; i < h; i++) {
		memcpy(dst1, src1, w);
		src1 += srcPitch;
		dst1 += dstPitch2;
	    }
	break;
    case RR_Rotate_90:
	for (i = 0; i < h; i++) {
	    s = src1;
	    for (j = 0; j < w; j++) {
		dst1[(i) + ((w - j - 1) * dstPitch2)] = *s++;
	    }
	    src1 += srcPitch;
	}
	break;
    case RR_Rotate_180:
	for (i = 0; i < h; i++) {
	    s = src1;
	    for (j = 0; j < w; j++) {
		dst1[(w - j - 1) + ((h - i - 1) * dstPitch2)] = *s++;
	    }
	    src1 += srcPitch;
	}
	break;
    case RR_Rotate_270:
	for (i = 0; i < h; i++) {
	    s = src1;
	    for (j = 0; j < w; j++) {
		dst1[(h - i - 1) + (j * dstPitch2)] = *s++;
	    }
	    src1 += srcPitch;
	}
	break;
    }
d1440 5
a1444 5
    /* Copy V data for YV12, or U data for I420 */
    src2 = buf +                            /* start of YUV data */
                (srcH * srcPitch) +         /* move over Luma plane */
                ((top * srcPitch) >> 2) +   /* move down from by top lines */
                    (left >> 1);            /* move left by left pixels */
d1447 2
a1448 2
    ErrorF("src2 is %p, offset is %ld\n", src2,
	   (unsigned long)src2 - (unsigned long)buf);
a1449 6
    if (pPriv->currentBuf == 0) {
	if (id == FOURCC_I420)
	    dst2 = dst_base + pPriv->UBuf0offset;
	else
	    dst2 = dst_base + pPriv->VBuf0offset;
    } else {
d1451 1
a1451 1
	    dst2 = dst_base + pPriv->UBuf1offset;
d1453 1
a1453 2
	    dst2 = dst_base + pPriv->VBuf1offset;
    }
d1455 2
a1456 40
    switch (pPriv->rotation) {
    case RR_Rotate_0:
       /* optimise for the case of no clipping */
	if (srcPitch2 == dstPitch && srcPitch2 == (w/2))
	    memcpy (dst2, src2, h/2 * srcPitch2);
	else
	    for (i = 0; i < h / 2; i++) {
		memcpy(dst2, src2, w / 2);
		src2 += srcPitch2;
		dst2 += dstPitch;
	    }
	break;
    case RR_Rotate_90:
	for (i = 0; i < (h/2); i++) {
	    s = src2;
	    for (j = 0; j < (w/2); j++) {
		dst2[(i) + (((w/2) - j - 1) * (dstPitch))] = *s++;
	    }
	    src2 += srcPitch2;
	}
	break;
    case RR_Rotate_180:
	for (i = 0; i < (h/2); i++) {
	    s = src2;
	    for (j = 0; j < (w/2); j++) {
		dst2[((w/2) - j - 1) + (((h/2) - i - 1) * dstPitch)] = *s++;
	    }
	    src2 += srcPitch2;
	}
	break;
    case RR_Rotate_270:
	for (i = 0; i < (h/2); i++) {
	    s = src2;
	    for (j = 0; j < (w/2); j++) {
		dst2[((h/2) - i - 1) + (j * dstPitch)] = *s++;
	    }
	    src2 += srcPitch2;
	}
	break;
    }
d1458 6
a1463 6
    /* Copy U data for YV12, or V data for I420 */
    src3 = buf +                            /* start of YUV data */
                (srcH * srcPitch) +         /* move over Luma plane */
                ((srcH >> 1) * srcPitch2) + /* move over Chroma plane */
                ((top * srcPitch) >> 2) +   /* move down from by top lines */
                    (left >> 1);            /* move left by left pixels */
d1465 2
a1466 2
    ErrorF("src3 is %p, offset is %ld\n", src3,
	   (unsigned long)src3 - (unsigned long)buf);
a1467 6
    if (pPriv->currentBuf == 0) {
	if (id == FOURCC_I420)
	    dst3 = dst_base + pPriv->VBuf0offset;
	else
	    dst3 = dst_base + pPriv->UBuf0offset;
    } else {
d1469 1
a1469 1
	    dst3 = dst_base + pPriv->VBuf1offset;
d1471 1
a1471 2
	    dst3 = dst_base + pPriv->UBuf1offset;
    }
d1473 2
a1474 40
    switch (pPriv->rotation) {
    case RR_Rotate_0:
       /* optimise for the case of no clipping */
	if (srcPitch2 == dstPitch && srcPitch2 == (w/2))
	    memcpy (dst3, src3, srcPitch2 * h/2);
	else
	    for (i = 0; i < h / 2; i++) {
		memcpy(dst3, src3, w / 2);
		src3 += srcPitch2;
		dst3 += dstPitch;
	    }
	break;
    case RR_Rotate_90:
	for (i = 0; i < (h/2); i++) {
	    s = src3;
	    for (j = 0; j < (w/2); j++) {
		dst3[(i) + (((w/2) - j - 1) * (dstPitch))] = *s++;
	    }
	    src3 += srcPitch2;
	}
	break;
    case RR_Rotate_180:
	for (i = 0; i < (h/2); i++) {
	    s = src3;
	    for (j = 0; j < (w/2); j++) {
		dst3[((w/2) - j - 1) + (((h/2) - i - 1) * dstPitch)] = *s++;
	    }
	    src3 += srcPitch2;
	}
	break;
    case RR_Rotate_270:
	for (i = 0; i < (h/2); i++) {
	    s = src3;
	    for (j = 0; j < (w/2); j++) {
		dst3[((h/2) - i - 1) + (j * dstPitch)] = *s++;
	    }
	    src3 += srcPitch2;
	}
	break;
    }
d1476 1
a1476 2
    if (pPriv->textured)
	drm_intel_bo_unmap(pPriv->buf);
d1480 3
a1482 3
    uint8_t sign;
    uint16_t mantissa;
    uint8_t exponent;
d1609 1
a1609 2
static void
i830_box_intersect (BoxPtr dest, BoxPtr a, BoxPtr b)
d1611 6
a1616 6
    dest->x1 = a->x1 > b->x1 ? a->x1 : b->x1;
    dest->x2 = a->x2 < b->x2 ? a->x2 : b->x2;
    dest->y1 = a->y1 > b->y1 ? a->y1 : b->y1;
    dest->y2 = a->y2 < b->y2 ? a->y2 : b->y2;
    if (dest->x1 >= dest->x2 || dest->y1 >= dest->y2)
	dest->x1 = dest->x2 = dest->y1 = dest->y2 = 0;
d1619 1
a1619 2
static void
i830_crtc_box (xf86CrtcPtr crtc, BoxPtr crtc_box)
d1621 9
a1629 9
    if (crtc->enabled)
    {
	crtc_box->x1 = crtc->x;
	crtc_box->x2 = crtc->x + xf86ModeWidth (&crtc->mode, crtc->rotation);
	crtc_box->y1 = crtc->y;
	crtc_box->y2 = crtc->y + xf86ModeHeight (&crtc->mode, crtc->rotation);
    }
    else
	crtc_box->x1 = crtc_box->x2 = crtc_box->y1 = crtc_box->y2 = 0;
d1632 1
a1632 2
static int
i830_box_area (BoxPtr box)
d1634 1
a1634 1
    return (int) (box->x2 - box->x1) * (int) (box->y2 - box->y1);
d1643 35
a1677 34
static xf86CrtcPtr
i830_covering_crtc (ScrnInfoPtr pScrn,
		    BoxPtr	box,
		    xf86CrtcPtr desired,
		    BoxPtr	crtc_box_ret)
{
    xf86CrtcConfigPtr   xf86_config = XF86_CRTC_CONFIG_PTR(pScrn);
    xf86CrtcPtr		crtc, best_crtc;
    int			coverage, best_coverage;
    int			c;
    BoxRec		crtc_box, cover_box;

    best_crtc = NULL;
    best_coverage = 0;
    crtc_box_ret->x1 = 0;
    crtc_box_ret->x2 = 0;
    crtc_box_ret->y1 = 0;
    crtc_box_ret->y2 = 0;
    for (c = 0; c < xf86_config->num_crtc; c++)
    {
	crtc = xf86_config->crtc[c];
	i830_crtc_box (crtc, &crtc_box);
	i830_box_intersect (&cover_box, &crtc_box, box);
	coverage = i830_box_area (&cover_box);
	if (coverage && crtc == desired)
	{
	    *crtc_box_ret = crtc_box;
	    return crtc;
	}
	if (coverage > best_coverage)
	{
	    *crtc_box_ret = crtc_box;
	    best_crtc = crtc;
	    best_coverage = coverage;
d1679 1
a1679 2
    }
    return best_crtc;
d1683 1
a1683 1
i830_swidth (I830Ptr pI830, unsigned int offset,
d1687 1
a1687 1
    if (IS_I9XX(pI830))
d1694 3
a1696 4
i830_display_video(ScrnInfoPtr pScrn, xf86CrtcPtr crtc,
		   int id, short width, short height,
		   int dstPitch, int x1, int y1, int x2, int y2, BoxPtr dstBox,
		   short src_w, short src_h, short drw_w, short drw_h)
d1698 1
a1698 3
    I830Ptr		pI830 = I830PTR(pScrn);
    I830PortPrivPtr	pPriv = pI830->adaptor->pPortPrivates[0].ptr;
    I830OverlayRegPtr	overlay = I830OVERLAYREG(pI830);
d1700 9
a1708 4
    unsigned int	mask, shift, offsety, offsetu;
    int			tmp;
    uint32_t		OCMD;
    Bool		scaleChanged = FALSE;
d1710 2
a1711 2
    OVERLAY_DEBUG("I830DisplayVideo: %dx%d (pitch %d)\n", width, height,
		  dstPitch);
d1713 11
a1723 21
#if VIDEO_DEBUG
    CompareOverlay(pI830, (uint32_t *) overlay, 0x100);
#endif
    
    /*
     * If the video isn't visible on any CRTC, turn it off
     */
    if (!crtc)
    {
	pPriv->current_crtc = NULL;
	i830_overlay_off (pScrn);
	return;
    }
    
    if (crtc != pPriv->current_crtc)
    {
	i830_overlay_switch_to_crtc (pScrn, crtc);
	if (pPriv->overlayOK) {
	    pPriv->current_crtc = crtc;
	    I830ResetVideo (pScrn);
	}
d1726 8
a1733 2
    if (!pPriv->overlayOK)
	return;
a1734 1
    switch (crtc->rotation & 0xf) {
d1739 179
a1917 36
    case RR_Rotate_0:
	dstBox->x1 -= crtc->x;
	dstBox->x2 -= crtc->x;
	dstBox->y1 -= crtc->y;
	dstBox->y2 -= crtc->y;
	break;
    case RR_Rotate_90:
	tmp = dstBox->x1;
	dstBox->x1 = dstBox->y1 - crtc->x;
	dstBox->y1 = pScrn->virtualX - tmp - crtc->y;
	tmp = dstBox->x2;
	dstBox->x2 = dstBox->y2 - crtc->x;
	dstBox->y2 = pScrn->virtualX - tmp - crtc->y;
	tmp = dstBox->y1;
	dstBox->y1 = dstBox->y2;
	dstBox->y2 = tmp;
	break;
    case RR_Rotate_180:
	tmp = dstBox->x1;
	dstBox->x1 = pScrn->virtualX - dstBox->x2 - crtc->x;
	dstBox->x2 = pScrn->virtualX - tmp - crtc->x;
	tmp = dstBox->y1;
	dstBox->y1 = pScrn->virtualY - dstBox->y2 - crtc->y;
	dstBox->y2 = pScrn->virtualY - tmp - crtc->y;
	break;
    case RR_Rotate_270:
	tmp = dstBox->x1;
	dstBox->x1 = pScrn->virtualY - dstBox->y1 - crtc->x;
	dstBox->y1 = tmp - crtc->y;
	tmp = dstBox->x2;
	dstBox->x2 = pScrn->virtualY - dstBox->y2 - crtc->x;
	dstBox->y2 = tmp - crtc->y;
	tmp = dstBox->x1;
	dstBox->x1 = dstBox->x2;
	dstBox->x2 = tmp;
	break;
d1920 5
a1924 10
    if (crtc->rotation & (RR_Rotate_90 | RR_Rotate_270)) {
	tmp = width;
	width = height;
	height = tmp;
	tmp = drw_w;
	drw_w = drw_h;
	drw_h = tmp;
	tmp = src_w;
	src_w = src_h;
	src_h = tmp;
d1927 6
a1932 4
    if (pPriv->oneLineMode) {
	/* change the coordinates with panel fitting active */
	dstBox->y1 = (((dstBox->y1 - 1) * pPriv->scaleRatio) >> 16) + 1;
	dstBox->y2 = ((dstBox->y2 * pPriv->scaleRatio) >> 16) + 1;
d1934 4
a1937 2
	/* Now, alter the height, so we scale to the correct size */
	drw_h = ((drw_h * pPriv->scaleRatio) >> 16) + 1;
d1940 2
a1941 6
    if (IS_I9XX(pI830)) {
	shift = 6;
	mask = 0x3f;
    } else {
	shift = 5;
	mask = 0x1f;
d1944 52
a1995 6
    if (pPriv->currentBuf == 0) {
	offsety = pPriv->YBuf0offset;
	offsetu = pPriv->UBuf0offset;
    } else {
	offsety = pPriv->YBuf1offset;
	offsetu = pPriv->UBuf1offset;
d1998 7
a2004 27
    switch (id) {
    case FOURCC_YV12:
    case FOURCC_I420:
	overlay->SWIDTH = width | ((width/2 & 0x7ff) << 16);
	swidthy  = i830_swidth (pI830, offsety, width, mask, shift);
	swidthuv = i830_swidth (pI830, offsetu, width/2, mask, shift);
	overlay->SWIDTHSW = (swidthy) | (swidthuv << 16);
	overlay->SHEIGHT = height | ((height / 2) << 16);
	break;
    case FOURCC_UYVY:
    case FOURCC_YUY2:
    default:
	overlay->SWIDTH = width;
	swidth = ((offsety + (width << 1) + mask) >> shift) -
	(offsety >> shift);

	if (IS_I9XX(pI830))
	    swidth <<= 1;

	swidth -= 1;

	swidth <<= 2;
	
	OVERLAY_DEBUG("swidthsw is old %d new %d\n",
		      swidth,
		      i830_swidth (pI830, offsety, width << 1,
				   mask, shift));
d2006 2
a2007 3
	overlay->SWIDTHSW = swidth;
	overlay->SHEIGHT = height;
	break;
d2010 9
d2028 5
a2032 8
    overlay->OBUF_0Y = pPriv->YBuf0offset;
    overlay->OBUF_0U = pPriv->UBuf0offset;
    overlay->OBUF_0V = pPriv->VBuf0offset;
    if(pPriv->doubleBuffer) {
	overlay->OBUF_1Y = pPriv->YBuf1offset;
	overlay->OBUF_1U = pPriv->UBuf1offset;
	overlay->OBUF_1V = pPriv->VBuf1offset;
    }
d2038 46
a2083 4
    /* 
     * Calculate horizontal and vertical scaling factors and polyphase
     * coefficients.
     */
d2085 3
a2087 10
    {
	int xscaleInt, xscaleFract, yscaleInt, yscaleFract;
	int xscaleIntUV, xscaleFractUV;
	int yscaleIntUV, yscaleFractUV;
	/* UV is half the size of Y -- YUV420 */
	int uvratio = 2;
	uint32_t newval;
	coeffRec xcoeffY[N_HORIZ_Y_TAPS * N_PHASES];
	coeffRec xcoeffUV[N_HORIZ_UV_TAPS * N_PHASES];
	int i, j, pos;
d2090 1
a2090 1
	 * Y down-scale factor as a multiple of 4096.
d2092 3
a2094 2
	xscaleFract = ((src_w - 1) << 12) / drw_w;
	yscaleFract = ((src_h - 1) << 12) / drw_h;
d2096 34
a2129 3
	/* Calculate the UV scaling factor. */
	xscaleFractUV = xscaleFract / uvratio;
	yscaleFractUV = yscaleFract / uvratio;
d2132 2
a2133 2
	 * To keep the relative Y and UV ratios exact, round the Y scales
	 * to a multiple of the Y/UV ratio.
d2135 31
a2165 2
	xscaleFract = xscaleFractUV * uvratio;
	yscaleFract = yscaleFractUV * uvratio;
d2167 2
a2168 3
	/* Integer (un-multiplied) values. */
	xscaleInt = xscaleFract >> 12;
	yscaleInt = yscaleFract >> 12;
d2170 5
a2174 2
	xscaleIntUV = xscaleFractUV >> 12;
	yscaleIntUV = yscaleFractUV >> 12;
d2176 1
a2176 4
	OVERLAY_DEBUG("xscale: %x.%03x, yscale: %x.%03x\n", xscaleInt,
		      xscaleFract & 0xFFF, yscaleInt, yscaleFract & 0xFFF);
	OVERLAY_DEBUG("UV xscale: %x.%03x, UV yscale: %x.%03x\n", xscaleIntUV,
		      xscaleFractUV & 0xFFF, yscaleIntUV, yscaleFractUV & 0xFFF);
d2178 5
a2182 4
	/* shouldn't get here */
	if (xscaleInt > 7) {
	    OVERLAY_DEBUG("xscale: bad scale\n");
	    return;
d2185 44
a2228 4
	/* shouldn't get here */
	if (xscaleIntUV > 7) {
	    OVERLAY_DEBUG("xscaleUV: bad scale\n");
	    return;
d2230 7
d2238 22
a2259 5
	newval = (xscaleInt << 16) |
	((xscaleFract & 0xFFF) << 3) | ((yscaleFract & 0xFFF) << 20);
	if (newval != overlay->YRGBSCALE) {
	    scaleChanged = TRUE;
	    overlay->YRGBSCALE = newval;
d2262 10
a2271 6
	newval = (xscaleIntUV << 16) | ((xscaleFractUV & 0xFFF) << 3) |
	((yscaleFractUV & 0xFFF) << 20);
	if (newval != overlay->UVSCALE) {
	    scaleChanged = TRUE;
	    overlay->UVSCALE = newval;
	}
d2273 15
a2287 4
	newval = yscaleInt << 16 | yscaleIntUV;
	if (newval != overlay->UVSCALEV) {
	    scaleChanged = TRUE;
	    overlay->UVSCALEV = newval;
d2290 2
a2291 4
	/* Recalculate coefficients if the scaling changed. */

	/*
	 * Only Horizontal coefficients so far.
d2293 11
a2303 26
	if (scaleChanged) {
	    double fCutoffY;
	    double fCutoffUV;

	    fCutoffY = xscaleFract / 4096.0;
	    fCutoffUV = xscaleFractUV / 4096.0;

	    /* Limit to between 1.0 and 3.0. */
	    if (fCutoffY < MIN_CUTOFF_FREQ)
		fCutoffY = MIN_CUTOFF_FREQ;
	    if (fCutoffY > MAX_CUTOFF_FREQ)
		fCutoffY = MAX_CUTOFF_FREQ;
	    if (fCutoffUV < MIN_CUTOFF_FREQ)
		fCutoffUV = MIN_CUTOFF_FREQ;
	    if (fCutoffUV > MAX_CUTOFF_FREQ)
		fCutoffUV = MAX_CUTOFF_FREQ;

	    UpdateCoeff(N_HORIZ_Y_TAPS, fCutoffY, TRUE, TRUE, xcoeffY);
	    UpdateCoeff(N_HORIZ_UV_TAPS, fCutoffUV, TRUE, FALSE, xcoeffUV);

	    for (i = 0; i < N_PHASES; i++) {
		for (j = 0; j < N_HORIZ_Y_TAPS; j++) {
		    pos = i * N_HORIZ_Y_TAPS + j;
		    overlay->Y_HCOEFS[pos] = (xcoeffY[pos].sign << 15 |
					      xcoeffY[pos].exponent << 12 |
					      xcoeffY[pos].mantissa);
d2305 12
a2316 7
	    }
	    for (i = 0; i < N_PHASES; i++) {
		for (j = 0; j < N_HORIZ_UV_TAPS; j++) {
		    pos = i * N_HORIZ_UV_TAPS + j;
		    overlay->UV_HCOEFS[pos] = (xcoeffUV[pos].sign << 15 |
					       xcoeffUV[pos].exponent << 12 |
					       xcoeffUV[pos].mantissa);
d2318 12
a2329 1
	    }
d2331 5
a2335 1
    }
d2337 6
a2342 5
    OCMD = OVERLAY_ENABLE;
    
    switch (id) {
    case FOURCC_YV12:
    case FOURCC_I420:
d2344 1
a2344 1
    case FOURCC_XVMC:
d2346 12
a2357 23
	OVERLAY_DEBUG("YUV420\n");
#if 0
	/* set UV vertical phase to -0.25 */
	overlay->UV_VPH = 0x30003000;
#endif
	OVERLAY_DEBUG("UV stride is %d, Y stride is %d\n",
		      dstPitch, dstPitch * 2);
	overlay->OSTRIDE = (dstPitch * 2) | (dstPitch << 16);
	OCMD &= ~SOURCE_FORMAT;
	OCMD &= ~OV_BYTE_ORDER;
	OCMD |= YUV_420;
	break;
    case FOURCC_UYVY:
    case FOURCC_YUY2:
	OVERLAY_DEBUG("YUV422\n");
	overlay->OSTRIDE = dstPitch;
	OCMD &= ~SOURCE_FORMAT;
	OCMD |= YUV_422;
	OCMD &= ~OV_BYTE_ORDER;
	if (id == FOURCC_UYVY)
	    OCMD |= Y_SWAP;
	break;
    }
d2359 2
a2360 5
    OCMD &= ~(BUFFER_SELECT | FIELD_SELECT);
    if (pPriv->currentBuf == 0)
	OCMD |= BUFFER0;
    else
	OCMD |= BUFFER1;
d2362 10
a2371 2
    overlay->OCMD = OCMD;
    OVERLAY_DEBUG("OCMD is 0x%x\n", OCMD);
d2373 14
a2386 5
    /* make sure the overlay is on */
    i830_overlay_on (pScrn);
    /* and show this frame */
    i830_overlay_continue (pScrn, scaleChanged);
}
d2388 18
a2405 43
static Bool
i830_clip_video_helper (ScrnInfoPtr pScrn,
			I830PortPrivPtr pPriv,
			xf86CrtcPtr *crtc_ret,
			BoxPtr	    dst,
			INT32	    *xa,
			INT32	    *xb,
			INT32	    *ya,
			INT32	    *yb,
			RegionPtr   reg,
			INT32	    width,
			INT32	    height)
{
    Bool	ret;
    RegionRec	crtc_region_local;
    RegionPtr	crtc_region = reg;
    
    /*
     * For overlay video, compute the relevant CRTC and
     * clip video to that
     */
    if (crtc_ret)
    {
	BoxRec		crtc_box;
	xf86CrtcPtr	crtc = i830_covering_crtc (pScrn, dst,
						   pPriv->desired_crtc,
						   &crtc_box);
	
	/* For textured video, we don't actually want to clip at all. */
	if (crtc && !pPriv->textured)
	{
	    REGION_INIT (pScreen, &crtc_region_local, &crtc_box, 1);
	    crtc_region = &crtc_region_local;
	    REGION_INTERSECT (pScreen, crtc_region, crtc_region, reg);
	}
	*crtc_ret = crtc;
    }
    ret = xf86XVClipVideoHelper (dst, xa, xb, ya, yb, 
				 crtc_region, width, height);
    if (crtc_region != reg)
	REGION_UNINIT (pScreen, &crtc_region_local);
    return ret;
}
d2407 1
a2407 32
static void
i830_fill_colorkey (ScreenPtr pScreen, uint32_t key, RegionPtr clipboxes)
{
   DrawablePtr root = &WindowTable[pScreen->myNum]->drawable;
   XID	       pval[2];
   BoxPtr      pbox = REGION_RECTS(clipboxes);
   int	       i, nbox = REGION_NUM_RECTS(clipboxes);
   xRectangle  *rects;
   GCPtr       gc;

   if(!xf86Screens[pScreen->myNum]->vtSema) return;

   gc = GetScratchGC(root->depth, pScreen);
   pval[0] = key;
   pval[1] = IncludeInferiors;
   (void) ChangeGC(gc, GCForeground|GCSubwindowMode, pval);
   ValidateGC(root, gc);

   rects = xalloc (nbox * sizeof(xRectangle));

   for(i = 0; i < nbox; i++, pbox++) 
   {
      rects[i].x = pbox->x1;
      rects[i].y = pbox->y1;
      rects[i].width = pbox->x2 - pbox->x1;
      rects[i].height = pbox->y2 - pbox->y1;
   }
   
   (*gc->ops->PolyFillRect)(root, gc, nbox, rects);
   
   xfree (rects);
   FreeScratchGC (gc);
d2420 1
a2420 1
 * pDraw is a Drawable, which might not be the screen in the case of
d2424 1
a2424 1
I830PutImage(ScrnInfoPtr pScrn,
d2432 1
a2432 1
	     DrawablePtr pDraw)
d2434 9
a2442 18
    I830Ptr pI830 = I830PTR(pScrn);
    I830PortPrivPtr pPriv = (I830PortPrivPtr) data;
    ScreenPtr pScreen = screenInfo.screens[pScrn->scrnIndex];
    I830OverlayRegPtr overlay;
    PixmapPtr pPixmap;
    INT32 x1, x2, y1, y2;
    int srcPitch = 0, srcPitch2 = 0, dstPitch, destId;
    int dstPitch2 = 0;
    int top, left, npixels, nlines, size;
    BoxRec dstBox;
    int pitchAlignMask;
    int alloc_size;
    xf86CrtcPtr	crtc;

    if (pPriv->textured)
	overlay = NULL;
    else
	overlay = I830OVERLAYREG(pI830);
d2445 43
a2487 94
    ErrorF("I830PutImage: src: (%d,%d)(%d,%d), dst: (%d,%d)(%d,%d)\n"
	   "width %d, height %d\n", src_x, src_y, src_w, src_h, drw_x, drw_y,
	   drw_w, drw_h, width, height);
#endif

    if (!pPriv->textured) {
        /* If dst width and height are less than 1/8th the src size, the
         * src/dst scale factor becomes larger than 8 and doesn't fit in
         * the scale register. */
        if(src_w >= (drw_w * 8))
            drw_w = src_w/7;

        if(src_h >= (drw_h * 8))
            drw_h = src_h/7;
    }

    /* Clip */
    x1 = src_x;
    x2 = src_x + src_w;
    y1 = src_y;
    y2 = src_y + src_h;

    dstBox.x1 = drw_x;
    dstBox.x2 = drw_x + drw_w;
    dstBox.y1 = drw_y;
    dstBox.y2 = drw_y + drw_h;

    if (!i830_clip_video_helper(pScrn, 
				pPriv,
				&crtc,
				&dstBox, &x1, &x2, &y1, &y2, clipBoxes,
				width, height))
	return Success;

     if (!pPriv->textured) {
	 /* texture video handles rotation differently. */
	if (crtc)
	    pPriv->rotation = crtc->rotation;
	else {
	    xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
		    "Fail to clip video to any crtc!\n");
	    return Success;
	}
     }

    destId = id;
    switch (id) {
    case FOURCC_YV12:
    case FOURCC_I420:
	srcPitch = (width + 0x3) & ~0x3;
	srcPitch2 = ((width >> 1) + 0x3) & ~0x3;
	break;
#ifdef INTEL_XVMC
    case FOURCC_XVMC:
	srcPitch = (width + 0x3) & ~0x3;
	srcPitch2 = ((width >> 1) + 0x3) & ~0x3;
	break;
#endif
    case FOURCC_UYVY:
    case FOURCC_YUY2:
    default:
	srcPitch = width << 1;
	break;
    }

    /* Only needs to be DWORD-aligned for textured on i915, but overlay has
     * stricter requirements.
     */
    if (pPriv->textured) {
	pitchAlignMask = 3;
#ifdef INTEL_XVMC
	/* for i915 xvmc, hw requires at least 1kb aligned surface */
	if ((id == FOURCC_XVMC) && IS_I915(pI830))
	    pitchAlignMask = 0x3ff;
#endif
    } else {
	if (IS_I965G(pI830))
	    pitchAlignMask = 255;
	else
	    pitchAlignMask = 63;
    }

    /* Determine the desired destination pitch (representing the chroma's pitch,
     * in the planar case.
     */
    switch (destId) {
    case FOURCC_YV12:
    case FOURCC_I420:
	if (pPriv->rotation & (RR_Rotate_90 | RR_Rotate_270)) {
	    dstPitch = ((height / 2) + pitchAlignMask) & ~pitchAlignMask;
	    size = dstPitch * width * 3;
	} else {
	    dstPitch = ((width / 2) + pitchAlignMask) & ~pitchAlignMask;
	    size = dstPitch * height * 3;
a2488 3
	break;
    case FOURCC_UYVY:
    case FOURCC_YUY2:
d2490 16
a2505 3
	if (pPriv->rotation & (RR_Rotate_90 | RR_Rotate_270)) {
	    dstPitch = ((height << 1) + pitchAlignMask) & ~pitchAlignMask;
	    size = dstPitch * width;
d2507 3
a2509 19
	    dstPitch = ((width << 1) + pitchAlignMask) & ~pitchAlignMask;
	    size = dstPitch * height;
	}
	break;
#ifdef INTEL_XVMC
    case FOURCC_XVMC:
	dstPitch = ((width / 2) + pitchAlignMask ) & ~pitchAlignMask;
	dstPitch2 = (width + pitchAlignMask ) & ~pitchAlignMask;
	size = 0;
	break;
#endif
    default:
	dstPitch = 0;
	size = 0;
	break;
    }
#if 0
    ErrorF("srcPitch: %d, dstPitch: %d, size: %d\n", srcPitch, dstPitch, size);
#endif
d2511 12
a2522 11
    alloc_size = size;
    if (pPriv->doubleBuffer)
	alloc_size *= 2;

    /* Free the current buffer if we're going to have to reallocate */
    if (pPriv->buf && pPriv->buf->size < alloc_size) {
	if (!pPriv->textured)
	    drm_intel_bo_unpin(pPriv->buf);
	drm_intel_bo_unreference(pPriv->buf);
	pPriv->buf = NULL;
    }
d2524 1
a2524 57
#ifdef INTEL_XVMC
    if (id == FOURCC_XVMC && 
        pPriv->rotation == RR_Rotate_0) {
        if (pPriv->buf) {
            assert(pPriv->textured);
            drm_intel_bo_unreference(pPriv->buf);
            pPriv->buf = NULL;
        }
    } else {
#endif
        if (pPriv->buf == NULL) {
            pPriv->buf = drm_intel_bo_alloc(pI830->bufmgr,
                                         "xv buffer", alloc_size, 4096);
            if (pPriv->buf == NULL)
                return BadAlloc;
            if (!pPriv->textured && drm_intel_bo_pin(pPriv->buf, 4096) != 0) {
                drm_intel_bo_unreference(pPriv->buf);
                pPriv->buf = NULL;
                xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
                           "Failed to pin xv buffer\n");
                return BadAlloc;
            }
        }
#ifdef INTEL_XVMC
    }
#endif

    /* fixup pointers */
#ifdef INTEL_XVMC
    if (id == FOURCC_XVMC && IS_I915(pI830)) {
	pPriv->YBuf0offset = (uint32_t)((uintptr_t)buf);
	pPriv->VBuf0offset = pPriv->YBuf0offset + (dstPitch2 * height);
	pPriv->UBuf0offset = pPriv->VBuf0offset + (dstPitch * height / 2);
	destId = FOURCC_YV12;
    } else {
#endif
	if (pPriv->textured)
	    pPriv->YBuf0offset = 0;
	else
	    pPriv->YBuf0offset = pPriv->buf->offset;

	if (pPriv->rotation & (RR_Rotate_90 | RR_Rotate_270)) {
	    pPriv->UBuf0offset = pPriv->YBuf0offset + (dstPitch * 2 * width);
	    pPriv->VBuf0offset = pPriv->UBuf0offset + (dstPitch * width / 2);
	    if(pPriv->doubleBuffer) {
		pPriv->YBuf1offset = pPriv->YBuf0offset + size;
		pPriv->UBuf1offset = pPriv->YBuf1offset + (dstPitch * 2 * width);
		pPriv->VBuf1offset = pPriv->UBuf1offset + (dstPitch * width / 2);
	    }
	} else {
	    pPriv->UBuf0offset = pPriv->YBuf0offset + (dstPitch * 2 * height);
	    pPriv->VBuf0offset = pPriv->UBuf0offset + (dstPitch * height / 2);
	    if(pPriv->doubleBuffer) {
		pPriv->YBuf1offset = pPriv->YBuf0offset + size;
		pPriv->UBuf1offset = pPriv->YBuf1offset + (dstPitch * 2 * height);
		pPriv->VBuf1offset = pPriv->UBuf1offset + (dstPitch * height / 2);
	    }
a2525 3
#ifdef INTEL_XVMC
    }
#endif
d2527 1
a2527 31
    /* Pick the idle buffer */
    if (!pPriv->textured && pI830->overlayOn && pPriv->doubleBuffer)
	pPriv->currentBuf = !((INREG(DOVSTA) & OC_BUF) >> 20);

    /* copy data */
    top = y1 >> 16;
    left = (x1 >> 16) & ~1;
    npixels = ((((x2 + 0xffff) >> 16) + 1) & ~1) - left;

    switch (id) {
    case FOURCC_YV12:
    case FOURCC_I420:
	top &= ~1;
	nlines = ((((y2 + 0xffff) >> 16) + 1) & ~1) - top;
	I830CopyPlanarData(pScrn, pPriv, buf, srcPitch, srcPitch2, dstPitch,
	    	       height, top, left, nlines, npixels, id);
	break;
    case FOURCC_UYVY:
    case FOURCC_YUY2:
	nlines = ((y2 + 0xffff) >> 16) - top;
	I830CopyPackedData(pScrn, pPriv, buf, srcPitch, dstPitch, top, left,
			   nlines, npixels);
	break;
#ifdef INTEL_XVMC
    case FOURCC_XVMC:
	if (pPriv->rotation != RR_Rotate_0) {
	    top &= ~1;
	    nlines = ((((y2 + 0xffff) >> 16) + 1) & ~1) - top;
	    I830CopyPlanarData(pScrn, pPriv, buf, srcPitch, srcPitch2, dstPitch,
		    height, top, left, nlines, npixels, id);
	}
d2529 1
a2529 101
	break;
#endif
    default:
	break;
    }

    if (pDraw->type == DRAWABLE_WINDOW) {
	pPixmap = (*pScreen->GetWindowPixmap)((WindowPtr)pDraw);
    } else {
	pPixmap = (PixmapPtr)pDraw;
    }

#ifdef I830_USE_EXA
    if (pPriv->textured && pI830->accel == ACCEL_EXA) {
	/* Force the pixmap into framebuffer so we can draw to it. */
	exaMoveInPixmap(pPixmap);
    }
#endif

    if (pPriv->textured && pI830->accel <= ACCEL_XAA &&
	    (((char *)pPixmap->devPrivate.ptr < (char *)pI830->FbBase) ||
	     ((char *)pPixmap->devPrivate.ptr >= (char *)pI830->FbBase +
	      pI830->FbMapSize))) {
	/* If the pixmap wasn't in framebuffer, then we have no way in XAA to
	 * force it there.  So, we simply refuse to draw and fail.
	 */
	return BadAlloc;
    }

    if (!pPriv->textured) {
	i830_display_video(pScrn, crtc, destId, width, height, dstPitch,
			   x1, y1, x2, y2, &dstBox, src_w, src_h,
			   drw_w, drw_h);
	
	/* update cliplist */
	if (!REGION_EQUAL(pScrn->pScreen, &pPriv->clip, clipBoxes)) {
	    REGION_COPY(pScrn->pScreen, &pPriv->clip, clipBoxes);
	    i830_fill_colorkey (pScreen, pPriv->colorKey, clipBoxes);
	}
    } else {
        Bool sync = TRUE;
        
        if (crtc == NULL) {
            sync = FALSE;
        } else if (pPriv->SyncToVblank == 0) {
            sync = FALSE;
        }

        if (sync) {
	    BoxPtr box;
	    int y1, y2;
            int event, pipe;
	    I830CrtcPrivatePtr intel_crtc = crtc->driver_private;

	    if (intel_crtc->pipe == 0) {
		event = MI_WAIT_FOR_PIPEA_SCAN_LINE_WINDOW;
		pipe = MI_LOAD_SCAN_LINES_DISPLAY_PIPEA;
	    } else {
		event = MI_WAIT_FOR_PIPEB_SCAN_LINE_WINDOW;
		pipe = MI_LOAD_SCAN_LINES_DISPLAY_PIPEB;
	    }

	    box = REGION_EXTENTS(unused, clipBoxes);
	    y1 = box->y1 - crtc->y;
	    y2 = box->y2 - crtc->y;

            BEGIN_BATCH(5);
	    /* The documentation says that the LOAD_SCAN_LINES command
	     * always comes in pairs. Don't ask me why. */
	    OUT_BATCH(MI_LOAD_SCAN_LINES_INCL | pipe);
	    OUT_BATCH((y1 << 16) | y2);
	    OUT_BATCH(MI_LOAD_SCAN_LINES_INCL | pipe);
	    OUT_BATCH((y1 << 16) | y2);
            OUT_BATCH(MI_WAIT_FOR_EVENT | event);
            ADVANCE_BATCH();
        }

        if (IS_I965G(pI830)) {
#ifdef INTEL_XVMC
            if (id == FOURCC_XVMC && pPriv->rotation == RR_Rotate_0) {
                pPriv->YBuf0offset = buf -  pI830->FbBase;
                pPriv->UBuf0offset = pPriv->YBuf0offset + height*width; 
                pPriv->VBuf0offset = pPriv->UBuf0offset + height*width/4; 
            }
#endif
            I965DisplayVideoTextured(pScrn, pPriv, destId, clipBoxes, width, height,
                                     dstPitch, x1, y1, x2, y2,
                                     src_w, src_h, drw_w, drw_h, pPixmap);
        } else {
            I915DisplayVideoTextured(pScrn, pPriv, destId, clipBoxes, width, height,
                                     dstPitch, dstPitch2, x1, y1, x2, y2,
                                     src_w, src_h, drw_w, drw_h, pPixmap);
        }
    }
    if (pPriv->textured) {
	DamageDamageRegion(pDraw, clipBoxes);
    }

    pPriv->videoStatus = CLIENT_VIDEO_ON;

    return Success;
d2533 1
a2533 1
I830QueryImageAttributes(ScrnInfoPtr pScrn,
d2536 1
a2536 1
			 int *pitches, int *offsets, Bool textured)
d2538 2
a2539 2
    I830Ptr pI830 = I830PTR(pScrn);
    int size, tmp;
d2542 1
a2542 1
    ErrorF("I830QueryImageAttributes: w is %d, h is %d\n", *w, *h);
d2545 13
a2557 31
    if (IS_845G(pI830) || IS_I830(pI830)) {
	if (*w > IMAGE_MAX_WIDTH_LEGACY)
	    *w = IMAGE_MAX_WIDTH_LEGACY;
	if (*h > IMAGE_MAX_HEIGHT_LEGACY)
	    *h = IMAGE_MAX_HEIGHT_LEGACY;
    } else {
	if (*w > IMAGE_MAX_WIDTH)
	    *w = IMAGE_MAX_WIDTH;
	if (*h > IMAGE_MAX_HEIGHT)
	    *h = IMAGE_MAX_HEIGHT;
    }

    *w = (*w + 1) & ~1;
    if (offsets)
	offsets[0] = 0;

    switch (id) {
	/* IA44 is for XvMC only */
    case FOURCC_IA44:
    case FOURCC_AI44:
	if (pitches)
	    pitches[0] = *w;
	size = *w * *h;
	break;
    case FOURCC_YV12:
    case FOURCC_I420:
	*h = (*h + 1) & ~1;
	size = (*w + 3) & ~3;
	if (pitches)
	    pitches[0] = size;
	size *= *h;
d2559 27
a2585 9
	    offsets[1] = size;
	tmp = ((*w >> 1) + 3) & ~3;
	if (pitches)
	    pitches[1] = pitches[2] = tmp;
	tmp *= (*h >> 1);
	size += tmp;
	if (offsets)
	    offsets[2] = size;
	size += tmp;
d2587 8
a2594 7
	if (pitches)
	    ErrorF("pitch 0 is %d, pitch 1 is %d, pitch 2 is %d\n", pitches[0],
		   pitches[1], pitches[2]);
	if (offsets)
	    ErrorF("offset 1 is %d, offset 2 is %d\n", offsets[1], offsets[2]);
	if (offsets)
	    ErrorF("size is %d\n", size);
d2596 1
a2596 1
	break;
d2598 6
a2603 6
    case FOURCC_XVMC:
        *h = (*h + 1) & ~1;
        size = sizeof(struct intel_xvmc_command);
        if (pitches)
            pitches[0] = size;
        break;
d2605 9
a2613 9
    case FOURCC_UYVY:
    case FOURCC_YUY2:
    default:
	size = *w << 1;
	if (pitches)
	    pitches[0] = size;
	size *= *h;
	break;
    }
d2615 1
a2615 19
    return size;
}

static int
I830QueryImageAttributesOverlay(ScrnInfoPtr pScrn,
				int id,
				unsigned short *w, unsigned short *h,
				int *pitches, int *offsets)
{
    return I830QueryImageAttributes(pScrn, id, w, h, pitches, offsets, FALSE);
}

static int
I830QueryImageAttributesTextured(ScrnInfoPtr pScrn,
				 int id,
				 unsigned short *w, unsigned short *h,
				 int *pitches, int *offsets)
{
    return I830QueryImageAttributes(pScrn, id, w, h, pitches, offsets, TRUE);
d2622 3
a2624 3
    ScrnInfoPtr pScrn = xf86Screens[i];
    I830Ptr pI830 = I830PTR(pScrn);
    I830PortPrivPtr pPriv;
d2626 3
a2628 3
    /* no overlay */
    if (pI830->adaptor == NULL)
        return;
d2630 1
a2630 1
    pPriv = GET_PORT_PRIVATE(pScrn);
d2632 1
a2632 1
    if (pPriv->videoStatus & TIMER_MASK) {
d2634 1
a2634 1
	Time now = currentTime.milliseconds;
d2636 1
a2636 1
	UpdateCurrentTime();
d2638 16
a2653 18
	if (pPriv->videoStatus & OFF_TIMER) {
	    if (pPriv->offTime < now) {
		/* Turn off the overlay */
		OVERLAY_DEBUG("BLOCKHANDLER\n");

		i830_overlay_off (pScrn);

		pPriv->videoStatus = FREE_TIMER;
		pPriv->freeTime = now + FREE_DELAY;
	    }
	} else {				/* FREE_TIMER */
	    if (pPriv->freeTime < now) {
		if (!pPriv->textured)
		    drm_intel_bo_unpin(pPriv->buf);
		drm_intel_bo_unreference(pPriv->buf);
		pPriv->buf = NULL;
		pPriv->videoStatus = 0;
	    }
a2654 196
    }
}

/***************************************************************************
 * Offscreen Images
 ***************************************************************************/

typedef struct {
    Bool isOn;
} OffscreenPrivRec, *OffscreenPrivPtr;

static int
I830AllocateSurface(ScrnInfoPtr pScrn,
		    int id,
		    unsigned short w,
		    unsigned short h, XF86SurfacePtr surface)
{
    int pitch, fbpitch, size;
    OffscreenPrivPtr pPriv;
    I830Ptr pI830 = I830PTR(pScrn);

    OVERLAY_DEBUG("I830AllocateSurface\n");

    if (IS_845G(pI830) || IS_I830(pI830)) {
	if ((w > IMAGE_MAX_WIDTH_LEGACY) || (h > IMAGE_MAX_HEIGHT_LEGACY))
	    return BadAlloc;
    } else {
	if ((w > IMAGE_MAX_WIDTH) || (h > IMAGE_MAX_HEIGHT))
	    return BadAlloc;
    }

    /* What to do when rotated ?? */
    if (pI830->rotation != RR_Rotate_0)
	return BadAlloc;

    if (!(surface->pitches = xalloc(sizeof(int))))
	return BadAlloc;
    if (!(surface->offsets = xalloc(sizeof(int)))) {
	xfree(surface->pitches);
	return BadAlloc;
    }
    if (!(pPriv = xalloc(sizeof(OffscreenPrivRec)))) {
	xfree(surface->pitches);
	xfree(surface->offsets);
	return BadAlloc;
    }

    w = (w + 1) & ~1;
    pitch = ((w << 1) + 15) & ~15;
    fbpitch = pI830->cpp * pScrn->displayWidth;
    size = pitch * h;

    surface->width = w;
    surface->height = h;

    pPriv->isOn = FALSE;

    surface->pScrn = pScrn;
    surface->id = id;
    surface->pitches[0] = pitch;
    surface->offsets[0] = 0;
    surface->devPrivate.ptr = (pointer) pPriv;

    return Success;
}

static int
I830StopSurface(XF86SurfacePtr surface)
{
    OffscreenPrivPtr pPriv = (OffscreenPrivPtr) surface->devPrivate.ptr;
    ScrnInfoPtr pScrn = surface->pScrn;

    if (pPriv->isOn) {
	OVERLAY_DEBUG("StopSurface\n");

	i830_overlay_off (pScrn);

	pPriv->isOn = FALSE;
    }

    return Success;
}

static int
I830FreeSurface(XF86SurfacePtr surface)
{
    I830StopSurface(surface);
    xfree(surface->pitches);
    xfree(surface->offsets);
    xfree(surface->devPrivate.ptr);

    return Success;
}

static int
I830GetSurfaceAttribute(ScrnInfoPtr pScrn, Atom attribute, INT32 * value)
{
    return I830GetPortAttribute(pScrn, attribute, value, NULL);
}

static int
I830SetSurfaceAttribute(ScrnInfoPtr pScrn, Atom attribute, INT32 value)
{
    return I830SetPortAttribute(pScrn, attribute, value, NULL);
}

static int
I830DisplaySurface(XF86SurfacePtr surface,
		   short src_x, short src_y,
		   short drw_x, short drw_y,
		   short src_w, short src_h,
		   short drw_w, short drw_h, RegionPtr clipBoxes)
{
    OffscreenPrivPtr pPriv = (OffscreenPrivPtr) surface->devPrivate.ptr;
    ScrnInfoPtr pScrn = surface->pScrn;
    ScreenPtr pScreen = screenInfo.screens[pScrn->scrnIndex];
    I830Ptr pI830 = I830PTR(pScrn);
    I830PortPrivPtr pI830Priv = GET_PORT_PRIVATE(pScrn);
    INT32 x1, y1, x2, y2;
    BoxRec dstBox;
    xf86CrtcPtr crtc;

    OVERLAY_DEBUG("I830DisplaySurface\n");

    x1 = src_x;
    x2 = src_x + src_w;
    y1 = src_y;
    y2 = src_y + src_h;

    dstBox.x1 = drw_x;
    dstBox.x2 = drw_x + drw_w;
    dstBox.y1 = drw_y;
    dstBox.y2 = drw_y + drw_h;

    if (!i830_clip_video_helper (pScrn, pI830Priv, &crtc, &dstBox,
				 &x1, &x2, &y1, &y2, clipBoxes,
				 surface->width, surface->height))
	return Success;

    /* fixup pointers */
    pI830Priv->YBuf0offset = surface->offsets[0];
    pI830Priv->YBuf1offset = pI830Priv->YBuf0offset;

    /* Pick the idle buffer */
    if (!pI830Priv->textured && pI830->overlayOn && pI830Priv->doubleBuffer)
	pI830Priv->currentBuf = !((INREG(DOVSTA) & OC_BUF) >> 20);

    i830_display_video(pScrn, crtc, surface->id, surface->width, surface->height,
		     surface->pitches[0], x1, y1, x2, y2, &dstBox,
		     src_w, src_h, drw_w, drw_h);

    i830_fill_colorkey (pScreen, pI830Priv->colorKey, clipBoxes);

    pPriv->isOn = TRUE;
    /* we've prempted the XvImage stream so set its free timer */
    if (pI830Priv->videoStatus & CLIENT_VIDEO_ON) {
	REGION_EMPTY(pScrn->pScreen, &pI830Priv->clip);
	UpdateCurrentTime();
	pI830Priv->videoStatus = FREE_TIMER;
	pI830Priv->freeTime = currentTime.milliseconds + FREE_DELAY;
    }

    return Success;
}

static void
I830InitOffscreenImages(ScreenPtr pScreen)
{
    XF86OffscreenImagePtr offscreenImages;
    ScrnInfoPtr pScrn = xf86Screens[pScreen->myNum];
    I830Ptr pI830 = I830PTR(pScrn);

    /* need to free this someplace */
    if (!(offscreenImages = xalloc(sizeof(XF86OffscreenImageRec)))) {
	return;
    }

    offscreenImages[0].image = &Images[0];
    offscreenImages[0].flags = VIDEO_OVERLAID_IMAGES /*| VIDEO_CLIP_TO_VIEWPORT*/;
    offscreenImages[0].alloc_surface = I830AllocateSurface;
    offscreenImages[0].free_surface = I830FreeSurface;
    offscreenImages[0].display = I830DisplaySurface;
    offscreenImages[0].stop = I830StopSurface;
    offscreenImages[0].setAttribute = I830SetSurfaceAttribute;
    offscreenImages[0].getAttribute = I830GetSurfaceAttribute;
    if (IS_845G(pI830) || IS_I830(pI830)) {
	offscreenImages[0].max_width = IMAGE_MAX_WIDTH_LEGACY;
	offscreenImages[0].max_height = IMAGE_MAX_HEIGHT_LEGACY;
    } else {
	offscreenImages[0].max_width = IMAGE_MAX_WIDTH;
	offscreenImages[0].max_height = IMAGE_MAX_HEIGHT; 
    }
    offscreenImages[0].num_attributes = 1;
    offscreenImages[0].attributes = Attributes;

    xf86XVRegisterOffscreenImages(pScreen, offscreenImages, 1);
d2660 25
a2684 24
    ScrnInfoPtr pScrn = crtc->scrn;
    I830Ptr pI830 = I830PTR(pScrn);
    I830PortPrivPtr pPriv;

    /* no overlay */
    if (pI830->adaptor == NULL)
	return;

    pPriv = GET_PORT_PRIVATE(pScrn);

    if (crtc != pPriv->current_crtc)
	return;

    /* Check if it's the crtc the overlay is off */
    if (!on) {
	/* We stop the video when mode switching, so we don't lock up
	 * the engine. The overlayOK will determine whether we can re-enable
	 * with the current video on completion of the mode switch.
	 */
	I830StopVideo(pScrn, pPriv, TRUE);
	pPriv->current_crtc = NULL;
	pPriv->overlayOK = FALSE;
	pPriv->oneLineMode = FALSE;
    }
@


1.9
log
@update to xf86-video-intel 2.7.1. Tested by many.
@
text
@d1398 2
a1399 1
	if (srcPitch == dstPitch2)
d1438 5
a1442 1
    src2 = buf + (srcH * srcPitch) + ((top * srcPitch) >> 2) + (left >> 1);
d1461 2
a1462 1
	if (srcPitch2 == dstPitch)
d1501 5
a1505 2
    src3 = buf + (srcH * srcPitch) + ((srcH >> 1) * srcPitch2) +
    ((top * srcPitch) >> 2) + (left >> 1);
d1524 2
a1525 1
	if (srcPitch2 == dstPitch)
@


1.8
log
@xf86-video-intel 2.4.2. Has been in snapshots for weeks. Ok oga@@.
@
text
@a83 4
#ifndef USE_USLEEP_FOR_VIDEO
#define USE_USLEEP_FOR_VIDEO 0
#endif

d116 1
d247 2
a248 2
#define NUM_TEXTURED_ATTRIBUTES 2
static XF86AttributeRec TexturedAttributes[NUM_ATTRIBUTES] = {
d251 1
d447 1
a447 1
    if (*pI830->overlayOn)
d481 1
a481 1
    *pI830->overlayOn = TRUE;
d493 1
a493 1
    if (!*pI830->overlayOn)
d519 1
a519 1
    if (!*pI830->overlayOn)
d557 1
a557 1
    *pI830->overlayOn = FALSE;
a611 1
	    adaptors[num_adaptors++] = texturedAdaptor;
d621 1
a621 1
	    pI830->overlay_regs != NULL)
a624 1
	    adaptors[num_adaptors++] = overlayAdaptor;
d632 10
d649 1
a649 1
    if (num_adaptors)
d651 5
d1022 1
d1030 2
a1034 28
static Bool
RegionsEqual(RegionPtr A, RegionPtr B)
{
    int *dataA, *dataB;
    int num;

    num = REGION_NUM_RECTS(A);
    if (num != REGION_NUM_RECTS(B))
	return FALSE;

    if ((A->extents.x1 != B->extents.x1) ||
	(A->extents.x2 != B->extents.x2) ||
	(A->extents.y1 != B->extents.y1) || (A->extents.y2 != B->extents.y2))
	return FALSE;

    dataA = (int *)REGION_RECTS(A);
    dataB = (int *)REGION_RECTS(B);

    while (num--) {
	if ((dataA[0] != dataB[0]) || (dataA[1] != dataB[1]))
	    return FALSE;
	dataA += 2;
	dataB += 2;
    }

    return TRUE;
}

a1038 1
    I830Ptr pI830 = I830PTR(pScrn);
a1049 2
	    if (pI830->entityPrivate)
		pI830->entityPrivate->XvInUse = -1;
d1051 8
a1058 6
	/* Sync before freeing the buffer, because the pages will be unbound.
	 */
	I830Sync(pScrn);
	i830_free_memory(pScrn, pPriv->buf);
	pPriv->buf = NULL;
	pPriv->videoStatus = 0;
d1084 6
d1168 1
a1168 1
	if(!*pI830->overlayOn)
d1225 3
a1227 1
    } else 
d1256 1
a1256 1
    unsigned char *src, *dst;
d1268 8
d1277 1
a1277 1
	dst = pI830->FbBase + pPriv->YBuf0offset;
d1279 1
a1279 1
	dst = pI830->FbBase + pPriv->YBuf1offset;
d1352 3
d1365 1
a1365 1
    unsigned char *src1, *src2, *src3, *dst1, *dst2, *dst3;
d1382 9
d1392 1
a1392 1
	dst1 = pI830->FbBase + pPriv->YBuf0offset;
d1394 1
a1394 1
	dst1 = pI830->FbBase + pPriv->YBuf1offset;
d1444 1
a1444 1
	    dst2 = pI830->FbBase + pPriv->UBuf0offset;
d1446 1
a1446 1
	    dst2 = pI830->FbBase + pPriv->VBuf0offset;
d1449 1
a1449 1
	    dst2 = pI830->FbBase + pPriv->UBuf1offset;
d1451 1
a1451 1
	    dst2 = pI830->FbBase + pPriv->VBuf1offset;
d1503 1
a1503 1
	    dst3 = pI830->FbBase + pPriv->VBuf0offset;
d1505 1
a1505 1
	    dst3 = pI830->FbBase + pPriv->UBuf0offset;
d1508 1
a1508 1
	    dst3 = pI830->FbBase + pPriv->VBuf1offset;
d1510 1
a1510 1
	    dst3 = pI830->FbBase + pPriv->UBuf1offset;
d1552 3
d2123 1
a2143 2
	I830Ptr		pI830 = I830PTR(pScrn);
	I830PortPrivPtr pPriv = pI830->adaptor->pPortPrivates[0].ptr;
d2149 2
a2150 1
	if (crtc)
d2234 1
a2234 1
    int alloc_size, extraLinear;
d2248 6
a2253 12
    if (pI830->entityPrivate) {
	if (pI830->entityPrivate->XvInUse != -1 &&
	    pI830->entityPrivate->XvInUse != i830_crtc_pipe (pPriv->current_crtc)) {
#ifdef PANORAMIX
	    if (!noPanoramiXExtension) {
		return Success; /* faked for trying to share it */
	    } else
#endif
	    {
		return BadAlloc;
	    }
	}
d2255 2
a2256 1
	pI830->entityPrivate->XvInUse = i830_crtc_pipe (pPriv->current_crtc);;
a2258 7
    /* Clamp dst width & height to 7x of src (overlay limit) */
    if(drw_w > (src_w * 7))
	drw_w = src_w * 7;

    if(drw_h > (src_h * 7))
	drw_h = src_h * 7;

d2271 2
a2272 1
				pPriv->textured ? NULL : &crtc,
d2297 2
a2365 5
    if (IS_I965G(pI830))
	extraLinear = BRW_LINEAR_EXTRA;
    else
	extraLinear = 0;

a2368 9
    alloc_size += extraLinear;

    if (pPriv->buf) {
	/* Wait for any previous acceleration to the buffer to have completed.
	 * When we start using BOs for rendering, we won't have to worry
	 * because mapping or freeing will take care of it automatically.
	 */
	I830Sync(pScrn);
    }
d2372 3
a2374 1
	i830_free_memory(pScrn, pPriv->buf);
d2378 24
a2401 3
    if (pPriv->buf == NULL) {
	pPriv->buf = i830_allocate_memory(pScrn, "xv buffer", alloc_size, 16,
					  0);
d2403 1
a2403 6

    if (pPriv->buf == NULL)
	return BadAlloc;

    pPriv->extra_offset = pPriv->buf->offset +
    (pPriv->doubleBuffer ? size * 2 : size);
d2408 1
a2408 1
	pPriv->YBuf0offset = (uint32_t)buf;
d2414 5
a2418 1
	pPriv->YBuf0offset = pPriv->buf->offset;
d2441 1
a2441 1
    if (!pPriv->textured && *pI830->overlayOn && pPriv->doubleBuffer)
d2465 7
d2485 1
a2485 1
    if (pPriv->textured && pI830->useEXA) {
d2491 1
a2491 1
    if (pPriv->textured && !pI830->useEXA &&
d2507 1
a2507 1
	if (!RegionsEqual(&pPriv->clip, clipBoxes)) {
a2510 4
    } else if (IS_I965G(pI830)) {
	I965DisplayVideoTextured(pScrn, pPriv, destId, clipBoxes, width, height,
				 dstPitch, x1, y1, x2, y2,
				 src_w, src_h, drw_w, drw_h, pPixmap);
d2512 53
a2564 3
	I915DisplayVideoTextured(pScrn, pPriv, destId, clipBoxes, width, height,
				 dstPitch, dstPitch2, x1, y1, x2, y2,
				 src_w, src_h, drw_w, drw_h, pPixmap);
a2706 3

		if (pI830->entityPrivate)
		    pI830->entityPrivate->XvInUse = -1;
d2710 3
a2712 5
		/* Sync before freeing the buffer, because the pages will be
		 * unbound.
		 */
		I830Sync(pScrn);
		i830_free_memory(pScrn, pPriv->buf);
a2724 1
    i830_memory *buf;
a2768 8
    pPriv->buf = i830_allocate_memory(pScrn, "xv surface buffer", size, 16, 0);
    if (pPriv->buf == NULL) {
	xfree(surface->pitches);
	xfree(surface->offsets);
	xfree(pPriv);
	return BadAlloc;
    }

d2777 1
a2777 1
    surface->offsets[0] = pPriv->buf->offset;
a2779 2
    memset(pI830->FbBase + surface->offsets[0], 0, size);

a2789 2
	I830Ptr pI830 = I830PTR(pScrn);

a2793 3
	if (pI830->entityPrivate)
	    pI830->entityPrivate->XvInUse = -1;

a2802 3
    ScrnInfoPtr pScrn = surface->pScrn;
    OffscreenPrivPtr pPriv = (OffscreenPrivPtr) surface->devPrivate.ptr;

a2803 4
    /* Sync before freeing the buffer, because the pages will be unbound. */
    I830Sync(pScrn);
    i830_free_memory(surface->pScrn, pPriv->buf);
    pPriv->buf = NULL;
a2840 16
    if (pI830->entityPrivate) {
	if (pI830->entityPrivate->XvInUse != -1 &&
	    pI830->entityPrivate->XvInUse != i830_crtc_pipe (pI830Priv->current_crtc)) {
#ifdef PANORAMIX
	    if (!noPanoramiXExtension) {
		return Success; /* faked for trying to share it */
	    } else
#endif
	    {
		return BadAlloc;
	    }
	}

	pI830->entityPrivate->XvInUse = i830_crtc_pipe (pI830Priv->current_crtc);
    }

d2851 1
a2851 1
    if (!i830_clip_video_helper (pScrn, &crtc, &dstBox,
d2861 1
a2861 1
    if (!pI830Priv->textured && *pI830->overlayOn && pI830Priv->doubleBuffer) 
@


1.7
log
@update to xf86-video-intel 2.3.2. Tested among others by okan@@.
@
text
@d623 1
a623 1
    if (!IS_IGD_GM(pI830) && pScrn->bitsPerPixel != 8 &&
a1352 59
/* Copies planar data in *buf to UYVY-packed data in the screen atYBufXOffset.
 */
static void
I830CopyPlanarToPackedData(ScrnInfoPtr pScrn, I830PortPrivPtr pPriv,
			   unsigned char *buf, int srcPitch,
			   int srcPitch2, int dstPitch, int srcH,
			   int top, int left, int h, int w, int id)
{
    I830Ptr pI830 = I830PTR(pScrn);
    uint8_t *dst1, *srcy, *srcu, *srcv;
    int y;

    if (pPriv->currentBuf == 0)
	dst1 = pI830->FbBase + pPriv->YBuf0offset;
    else
	dst1 = pI830->FbBase + pPriv->YBuf1offset;

    srcy = buf + (top * srcPitch) + left;
    if (id == FOURCC_YV12) {
	srcu = buf + (srcH * srcPitch) + ((top / 2) * srcPitch2) + (left / 2);
	srcv = buf + (srcH * srcPitch) + ((srcH / 2) * srcPitch2) +
	((top / 2) * srcPitch2) + (left / 2);
    } else {
	srcv = buf + (srcH * srcPitch) + ((top / 2) * srcPitch2) + (left / 2);
	srcu = buf + (srcH * srcPitch) + ((srcH / 2) * srcPitch2) +
	((top / 2) * srcPitch2) + (left / 2);
    }

    for (y = 0; y < h; y++) {
	uint32_t *dst = (uint32_t *)dst1;
	uint8_t *sy = srcy;
	uint8_t *su = srcu;
	uint8_t *sv = srcv;
	int i;

	i = w / 2;
	while(i > 4) {
	    dst[0] = sy[0] | (sy[1] << 16) | (sv[0] << 8) | (su[0] << 24);
	    dst[1] = sy[2] | (sy[3] << 16) | (sv[1] << 8) | (su[1] << 24);
	    dst[2] = sy[4] | (sy[5] << 16) | (sv[2] << 8) | (su[2] << 24);
	    dst[3] = sy[6] | (sy[7] << 16) | (sv[3] << 8) | (su[3] << 24);
	    dst += 4; su += 4; sv += 4; sy += 8;
	    i -= 4;
	}
	while(i--) {
	    dst[0] = sy[0] | (sy[1] << 16) | (sv[0] << 8) | (su[0] << 24);
	    dst++; su++; sv++;
	    sy += 2;
	}

	dst1 += dstPitch;
	srcy += srcPitch;
	if (y & 1) {
	    srcu += srcPitch2;
	    srcv += srcPitch2;
	}	
    }
}

d2213 2
a2214 1
    int srcPitch, srcPitch2 = 0, dstPitch, destId;
d2289 1
d2291 2
a2292 4
        if (pI830->IsXvMCSurface) {
            srcPitch = (width + 0x3ff) & ~0x3ff;
            srcPitch2 = ((width >> 1) + 0x3ff) & ~0x3ff;
        }
a2293 3
	if (pPriv->textured && IS_I965G(pI830))
	    destId = FOURCC_YUY2;
	break;
d2306 5
a2323 3
#ifdef INTEL_XVMC
    case FOURCC_XVMC:
#endif
d2343 8
a2350 1
    default:  
d2395 6
a2400 9
    pPriv->YBuf0offset = pPriv->buf->offset;
    if (pPriv->rotation & (RR_Rotate_90 | RR_Rotate_270)) {
	pPriv->UBuf0offset = pPriv->YBuf0offset + (dstPitch * 2 * width);
	pPriv->VBuf0offset = pPriv->UBuf0offset + (dstPitch * width / 2);
	if(pPriv->doubleBuffer) {
	    pPriv->YBuf1offset = pPriv->YBuf0offset + size;
	    pPriv->UBuf1offset = pPriv->YBuf1offset + (dstPitch * 2 * width);
	    pPriv->VBuf1offset = pPriv->UBuf1offset + (dstPitch * width / 2);
	}
d2402 18
a2419 6
	pPriv->UBuf0offset = pPriv->YBuf0offset + (dstPitch * 2 * height);
	pPriv->VBuf0offset = pPriv->UBuf0offset + (dstPitch * height / 2);
	if(pPriv->doubleBuffer) {
	    pPriv->YBuf1offset = pPriv->YBuf0offset + size;
	    pPriv->UBuf1offset = pPriv->YBuf1offset + (dstPitch * 2 * height);
	    pPriv->VBuf1offset = pPriv->UBuf1offset + (dstPitch * height / 2);
d2421 1
d2423 1
d2439 2
a2440 8
	if (pPriv->textured && IS_I965G(pI830)) {
	    I830CopyPlanarToPackedData(pScrn, pPriv, buf, srcPitch, srcPitch2,
				       dstPitch, height, top, left, nlines,
				       npixels, id);
	} else {
	    I830CopyPlanarData(pScrn, pPriv, buf, srcPitch, srcPitch2, dstPitch,
			       height, top, left, nlines, npixels, id);
	}
d2495 1
a2495 1
				 dstPitch, x1, y1, x2, y2,
@


1.6
log
@Update to xf86-video-intel 2.3.1. Tested by many.
@
text
@d2122 3
a2138 1
    default:
d2381 3
d2394 1
a2394 1
    default:
d2403 4
a2491 1
    default:
d2495 6
@


1.5
log
@Update to Intel driver 2.2.1. But change default accelmethod to XAA.
Tested by landry@@, oga@@, steven@@, jakemsr@@.
@
text
@d78 6
d103 1
d193 3
d266 1
a266 1
#define NUM_IMAGES 4
d272 27
a298 1
    XVIMAGE_UYVY
d302 52
a353 52
    CARD32 OBUF_0Y;
    CARD32 OBUF_1Y;
    CARD32 OBUF_0U;
    CARD32 OBUF_0V;
    CARD32 OBUF_1U;
    CARD32 OBUF_1V;
    CARD32 OSTRIDE;
    CARD32 YRGB_VPH;
    CARD32 UV_VPH;
    CARD32 HORZ_PH;
    CARD32 INIT_PHS;
    CARD32 DWINPOS;
    CARD32 DWINSZ;
    CARD32 SWIDTH;
    CARD32 SWIDTHSW;
    CARD32 SHEIGHT;
    CARD32 YRGBSCALE;
    CARD32 UVSCALE;
    CARD32 OCLRC0;
    CARD32 OCLRC1;
    CARD32 DCLRKV;
    CARD32 DCLRKM;
    CARD32 SCLRKVH;
    CARD32 SCLRKVL;
    CARD32 SCLRKEN;
    CARD32 OCONFIG;
    CARD32 OCMD;
    CARD32 RESERVED1;			/* 0x6C */
    CARD32 OSTART_0Y; 		/* for i965 */
    CARD32 OSTART_1Y;		/* for i965 */
    CARD32 OSTART_0U;
    CARD32 OSTART_0V;
    CARD32 OSTART_1U;
    CARD32 OSTART_1V;
    CARD32 OTILEOFF_0Y;
    CARD32 OTILEOFF_1Y;
    CARD32 OTILEOFF_0U;
    CARD32 OTILEOFF_0V;
    CARD32 OTILEOFF_1U;
    CARD32 OTILEOFF_1V;
    CARD32 FASTHSCALE;			/* 0xA0 */
    CARD32 UVSCALEV;			/* 0xA4 */

    CARD32 RESERVEDC[(0x200 - 0xA8) / 4];		   /* 0xA8 - 0x1FC */
    CARD16 Y_VCOEFS[N_VERT_Y_TAPS * N_PHASES];		   /* 0x200 */
    CARD16 RESERVEDD[0x100 / 2 - N_VERT_Y_TAPS * N_PHASES];
    CARD16 Y_HCOEFS[N_HORIZ_Y_TAPS * N_PHASES];		   /* 0x300 */
    CARD16 RESERVEDE[0x200 / 2 - N_HORIZ_Y_TAPS * N_PHASES];
    CARD16 UV_VCOEFS[N_VERT_UV_TAPS * N_PHASES];		   /* 0x500 */
    CARD16 RESERVEDF[0x100 / 2 - N_VERT_UV_TAPS * N_PHASES];
    CARD16 UV_HCOEFS[N_HORIZ_UV_TAPS * N_PHASES];	   /* 0x600 */
    CARD16 RESERVEDG[0x100 / 2 - N_HORIZ_UV_TAPS * N_PHASES];
d361 1
a361 1
CompareOverlay(I830Ptr pI830, CARD32 * overlay, int size)
d364 1
a364 1
    CARD32 val;
d391 3
a393 1
    if (INREG(pipeconf_reg) & PIPEACONF_DOUBLE_WIDE)
d397 1
a397 1
    
d405 4
a408 4
	int	vtotal_reg = intel_crtc->pipe ? VTOTAL_A : VTOTAL_B;
	CARD32	size = intel_crtc->pipe ? INREG(PIPEBSRC) : INREG(PIPEASRC);
	CARD32	active;
	CARD32	hsize, vsize;
d461 4
a464 4
    BEGIN_LP_RING(6);
    OUT_RING(MI_FLUSH | MI_WRITE_DIRTY_STATE);
    OUT_RING(MI_NOOP);
    OUT_RING(MI_OVERLAY_FLIP | MI_OVERLAY_FLIP_ON);
d466 1
a466 1
	OUT_RING(pI830->overlay_regs->offset | OFC_UPDATE);
d468 1
a468 1
	OUT_RING(pI830->overlay_regs->bus_addr | OFC_UPDATE);
d470 3
a472 3
    OUT_RING(MI_WAIT_FOR_EVENT | MI_WAIT_FOR_OVERLAY_FLIP);
    OUT_RING(MI_NOOP);
    ADVANCE_LP_RING();
d492 1
a492 1
    CARD32		flip_addr;
d504 1
a504 2
    OVERLAY_DEBUG ("overlay_continue cmd 0x%08" PRIx32 " -> 0x%08" PRIx32
		   " sta 0x%08" PRIx32 "\n",
d506 6
a511 6
    BEGIN_LP_RING(4);
    OUT_RING(MI_FLUSH | MI_WRITE_DIRTY_STATE);
    OUT_RING(MI_NOOP);
    OUT_RING(MI_OVERLAY_FLIP | MI_OVERLAY_FLIP_CONTINUE);
    OUT_RING(flip_addr);
    ADVANCE_LP_RING();
d532 4
a535 4
	BEGIN_LP_RING(2);
	OUT_RING(MI_WAIT_FOR_EVENT | MI_WAIT_FOR_OVERLAY_FLIP);
	OUT_RING(MI_NOOP);
	ADVANCE_LP_RING();
d544 1
a544 1
	OVERLAY_DEBUG ("overlay_off cmd 0x%08" PRIx32 " -> 0x%08" PRIx32 " sta 0x%08" PRIx32 "\n",
d546 4
a549 4
	BEGIN_LP_RING(6);
	OUT_RING(MI_FLUSH | MI_WRITE_DIRTY_STATE);
	OUT_RING(MI_NOOP);
	OUT_RING(MI_OVERLAY_FLIP | MI_OVERLAY_FLIP_CONTINUE);
d551 1
a551 1
	    OUT_RING(pI830->overlay_regs->offset);
d553 4
a556 4
	    OUT_RING(pI830->overlay_regs->bus_addr);
	OUT_RING(MI_WAIT_FOR_EVENT | MI_WAIT_FOR_OVERLAY_FLIP);
	OUT_RING(MI_NOOP);
	ADVANCE_LP_RING();
d571 3
d623 2
a624 2
    if (!IS_I965G(pI830) && pScrn->bitsPerPixel != 8 &&
	pI830->overlay_regs != NULL)
d636 6
d646 4
d710 2
d747 1
a747 1
    CARD32 panelFitControl = INREG(PFIT_CONTROLS);
d771 1
a771 1
static CARD32 I830BoundGammaElt (CARD32 elt, CARD32 eltPrev)
d782 1
a782 1
static CARD32 I830BoundGamma (CARD32 gamma, CARD32 gammaPrev)
d795 6
a800 6
    CARD32   gamma0 = pPriv->gamma0;
    CARD32   gamma1 = pPriv->gamma1;
    CARD32   gamma2 = pPriv->gamma2;
    CARD32   gamma3 = pPriv->gamma3;
    CARD32   gamma4 = pPriv->gamma4;
    CARD32   gamma5 = pPriv->gamma5;
d888 3
a890 3
    pPriv->brightness = 0;
    pPriv->contrast = 64;
    pPriv->saturation = 128;
d903 2
d995 1
a995 1
    adapt->SetPortAttribute = I830SetPortAttribute;
d1010 2
d1084 21
a1111 8
    if (pPriv->textured) {
	/* XXX: Currently the brightness/saturation attributes aren't hooked up.
	 * However, apps expect them to be there, and the spec seems to let us
	 * sneak out of actually implementing them for now.
	 */
	return Success;
    }

d1280 1
a1280 1
    switch (pI830->rotation) {
d1362 1
a1362 1
    CARD8 *dst1, *srcy, *srcu, *srcv;
d1382 4
a1385 4
	CARD32 *dst = (CARD32 *)dst1;
	CARD8 *sy = srcy;
	CARD8 *su = srcu;
	CARD8 *sv = srcv;
d1442 1
a1442 1
    switch (pI830->rotation) {
d1444 8
a1451 5
	for (i = 0; i < h; i++) {
	    memcpy(dst1, src1, w);
	    src1 += srcPitch;
	    dst1 += dstPitch2;
	}
d1500 1
a1500 1
    switch (pI830->rotation) {
d1502 8
a1509 5
	for (i = 0; i < h / 2; i++) {
	    memcpy(dst2, src2, w / 2);
	    src2 += srcPitch2;
	    dst2 += dstPitch;
	}
d1559 1
a1559 1
    switch (pI830->rotation) {
d1561 8
a1568 5
	for (i = 0; i < h / 2; i++) {
	    memcpy(dst3, src3, w / 2);
	    src3 += srcPitch2;
	    dst3 += dstPitch;
	}
d1601 3
a1603 3
    CARD8 sign;
    CARD16 mantissa;
    CARD8 exponent;
d1829 1
a1829 1
    CARD32		OCMD;
d1836 1
a1836 1
    CompareOverlay(pI830, (CARD32 *) overlay, 0x100);
a1850 1
        pPriv->current_crtc = crtc;
d1852 2
a1853 1
	if (pPriv->overlayOK)
d1855 1
d1862 4
d1875 1
a1875 1
	dstBox->y1 = pScrn->virtualY - tmp - crtc->y;
d1878 1
a1878 1
	dstBox->y2 = pScrn->virtualY - tmp - crtc->y;
d1893 1
a1893 1
	dstBox->x1 = pScrn->virtualX - dstBox->y1 - crtc->x;
d1896 1
a1896 1
	dstBox->x2 = pScrn->virtualX - dstBox->y2 - crtc->x;
d1992 1
a1992 1
    OVERLAY_DEBUG("pos: 0x%" PRIx32 ", size: 0x%" PRIx32 "\n",
d2007 1
a2007 1
	CARD32 newval;
d2154 1
a2154 1
    OVERLAY_DEBUG("OCMD is 0x%" PRIx32 "\n", OCMD);
d2207 1
a2207 1
i830_fill_colorkey (ScreenPtr pScreen, CARD32 key, RegionPtr clipboxes)
d2328 11
d2343 8
a2350 2
	srcPitch = (width + 3) & ~3;
	srcPitch2 = ((width >> 1) + 3) & ~3;
d2379 1
a2379 1
	if (pI830->rotation & (RR_Rotate_90 | RR_Rotate_270)) {
d2390 1
a2390 1
	if (pI830->rotation & (RR_Rotate_90 | RR_Rotate_270)) {
d2440 1
a2440 1
    if (pI830->rotation & (RR_Rotate_90 | RR_Rotate_270)) {
d2497 1
a2497 1
    if (pI830->useEXA) {
d2503 1
a2503 1
    if (!pI830->useEXA &&
d2605 8
d2652 1
a2655 4
    /* No overlay scaler on the 965. */
    if (IS_I965G(pI830))
        return;

d2932 1
a2933 4
	return;

    /* No overlay scaler on the 965. */
    if (IS_I965G(pI830))
@


1.4
log
@Merge intel driver version 2.2.0.90.
@
text
@a477 1

@


1.3
log
@merge xf86-video-intel 2.2.0
@
text
@d53 1
d466 2
a467 1
    OVERLAY_DEBUG ("overlay_continue cmd 0x%08lx -> 0x%08lx sta 0x%08lx\n",
d508 1
a508 1
	OVERLAY_DEBUG ("overlay_off cmd 0x%08lx -> 0x%08lx sta 0x%08lx\n",
d680 1
a680 1
	    ErrorF("0x%x 0x%lx\n", i, INREG(i));
d1910 1
a1910 1
    OVERLAY_DEBUG("pos: 0x%lx, size: 0x%lx\n",
d2072 1
a2072 1
    OVERLAY_DEBUG("OCMD is 0x%lx\n", OCMD);
d2580 1
d2693 1
@


1.2
log
@Add support for the mobile i965GM chipset.

tested by many
ok matthieu@@
@
text
@a1 2
 
Copyright 2000 Intel Corporation.  All Rights Reserved. 
d3 1
a3 19
Permission is hereby granted, free of charge, to any person obtaining a 
copy of this software and associated documentation files (the 
"Software"), to deal in the Software without restriction, including 
without limitation the rights to use, copy, modify, merge, publish, 
distribute, sub license, and/or sell copies of the Software, and to 
permit persons to whom the Software is furnished to do so, subject to 
the following conditions: 

The above copyright notice and this permission notice (including the 
next paragraph) shall be included in all copies or substantial portions 
of the Software. 

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS 
OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF 
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT. 
IN NO EVENT SHALL INTEL, AND/OR ITS SUPPLIERS BE LIABLE FOR ANY CLAIM, 
DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR 
OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR 
THE USE OR OTHER DEALINGS IN THE SOFTWARE.
d5 21
a25 1
**************************************************************************/
a28 13
 * Reformatted with GNU indent (2.2.8), using the following options:
 *
 *    -bad -bap -c41 -cd0 -ncdb -ci6 -cli0 -cp0 -ncs -d0 -di3 -i3 -ip3 -l78
 *    -lp -npcs -psl -sob -ss -br -ce -sc -hnl
 *
 * This provides a good match with the original i810 code and preferred
 * XFree86 formatting conventions.
 *
 * When editing this driver, please follow the existing formatting, and edit
 * with <TAB> characters expanded at 8-column intervals.
 */

/*
d66 2
a75 2
#include "brw_defines.h"
#include "brw_structs.h"
a107 5
static void I830BlockHandler(int, pointer, pointer, pointer);

static FBLinearPtr
I830AllocateMemory(ScrnInfoPtr pScrn, FBLinearPtr linear, int size);

d110 1
a110 1
static Atom xvBrightness, xvContrast, xvColorKey, xvPipe, xvDoubleBuffer;
d113 13
d131 6
a136 4
/*
 * Broadwater requires a bit of extra video memory for state information
 */
#define BRW_LINEAR_EXTRA	(32*1024)
d138 3
a140 6
#if !VIDEO_DEBUG
#define ErrorF Edummy
static void
Edummy(const char *dummy, ...)
{
}
a143 61
 * This is more or less the correct way to initalise, update, and shut down
 * the overlay.  Note OVERLAY_OFF should be used only after disabling the
 * overlay in OCMD and calling OVERLAY_UPDATE.
 *
 * XXX Need to make sure that the overlay engine is cleanly shutdown in
 * all modes of server exit.
 */

#define OVERLAY_UPDATE						\
   do { 								\
      BEGIN_LP_RING(8);							\
      OUT_RING(MI_FLUSH | MI_WRITE_DIRTY_STATE);                       	\
      OUT_RING(MI_NOOP);    						\
      if (!*pI830->overlayOn) {						\
	 OUT_RING(MI_NOOP);						\
	 OUT_RING(MI_NOOP);						\
	 OUT_RING(MI_OVERLAY_FLIP | MI_OVERLAY_FLIP_ON);		\
	 ErrorF("Overlay goes from off to on\n");			\
	 *pI830->overlayOn = TRUE;					\
      } else {								\
	 OUT_RING(MI_WAIT_FOR_EVENT | MI_WAIT_FOR_OVERLAY_FLIP);	\
	 OUT_RING(MI_NOOP);						\
	 OUT_RING(MI_OVERLAY_FLIP | MI_OVERLAY_FLIP_CONTINUE);		\
      }									\
      if (IS_I96X(pI830)) 						\
         OUT_RING(pI830->OverlayMem->Start | OFC_UPDATE); 		\
      else								\
	 OUT_RING(pI830->OverlayMem->Physical | OFC_UPDATE);		\
      OUT_RING(MI_WAIT_FOR_EVENT | MI_WAIT_FOR_OVERLAY_FLIP);		\
      OUT_RING(MI_NOOP);						\
      ADVANCE_LP_RING();						\
      ErrorF("OVERLAY_UPDATE\n");					\
   } while(0)

#define OVERLAY_OFF							\
   do { 								\
      if (*pI830->overlayOn) {						\
	 int spin = 1000000;						\
	 BEGIN_LP_RING(6);						\
         OUT_RING(MI_FLUSH | MI_WRITE_DIRTY_STATE);                   	\
         OUT_RING(MI_NOOP);    						\
	 OUT_RING(MI_OVERLAY_FLIP | MI_OVERLAY_FLIP_OFF);		\
         if (IS_I96X(pI830)) 						\
            OUT_RING(pI830->OverlayMem->Start | OFC_UPDATE); 		\
         else								\
	    OUT_RING(pI830->OverlayMem->Physical | OFC_UPDATE);		\
	 OUT_RING(MI_WAIT_FOR_EVENT | MI_WAIT_FOR_OVERLAY_FLIP);	\
	 OUT_RING(MI_NOOP);						\
	 ADVANCE_LP_RING();						\
	 *pI830->overlayOn = FALSE;					\
	 ErrorF("Overlay goes from on to off\n");			\
         while (spin != 0 && (INREG(OCMD_REGISTER) & OVERLAY_ENABLE)){	\
		ErrorF("SPIN %d\n",spin);				\
		spin--;							\
 	 }								\
	 if (spin == 0) ErrorF("OVERLAY FAILED TO GO OFF\n");		\
	 ErrorF("OVERLAY_OFF\n");					\
      }									\
   } while(0)

/*
d204 1
a204 1
	(((c & 0xF800) << 8) | ((c & 0x07E0) << 5) | ((c & 0x001F) << 3))
d207 1
a207 1
        (((c & 0x7c00) << 9) | ((c & 0x03E0) << 6) | ((c & 0x001F) << 3))
d211 6
a216 6
   {
      0,
      "XV_IMAGE",
      IMAGE_MAX_WIDTH, IMAGE_MAX_HEIGHT,
      {1, 1}
   }
d222 1
a222 1
   {15, TrueColor}, {16, TrueColor}, {24, TrueColor}
d227 1
a227 1
   {XvSettable | XvGettable, 0, 1, "XV_PIPE"}
d230 1
a230 1
#define NUM_ATTRIBUTES 4
d232 5
a236 4
   {XvSettable | XvGettable, 0, (1 << 24) - 1, "XV_COLORKEY"},
   {XvSettable | XvGettable, -128, 127, "XV_BRIGHTNESS"},
   {XvSettable | XvGettable, 0, 255, "XV_CONTRAST"},
   {XvSettable | XvGettable, 0, 1, "XV_DOUBLE_BUFFER"}
d241 2
a242 2
   {XvSettable | XvGettable, -128, 127, "XV_BRIGHTNESS"},
   {XvSettable | XvGettable, 0, 255, "XV_CONTRAST"},
d247 6
a252 6
   {XvSettable | XvGettable, 0, 0xffffff, "XV_GAMMA0"},
   {XvSettable | XvGettable, 0, 0xffffff, "XV_GAMMA1"},
   {XvSettable | XvGettable, 0, 0xffffff, "XV_GAMMA2"},
   {XvSettable | XvGettable, 0, 0xffffff, "XV_GAMMA3"},
   {XvSettable | XvGettable, 0, 0xffffff, "XV_GAMMA4"},
   {XvSettable | XvGettable, 0, 0xffffff, "XV_GAMMA5"}
d258 4
a261 4
   XVIMAGE_YUY2,
   XVIMAGE_YV12,
   XVIMAGE_I420,
   XVIMAGE_UYVY
d265 52
a316 52
   CARD32 OBUF_0Y;
   CARD32 OBUF_1Y;
   CARD32 OBUF_0U;
   CARD32 OBUF_0V;
   CARD32 OBUF_1U;
   CARD32 OBUF_1V;
   CARD32 OSTRIDE;
   CARD32 YRGB_VPH;
   CARD32 UV_VPH;
   CARD32 HORZ_PH;
   CARD32 INIT_PHS;
   CARD32 DWINPOS;
   CARD32 DWINSZ;
   CARD32 SWIDTH;
   CARD32 SWIDTHSW;
   CARD32 SHEIGHT;
   CARD32 YRGBSCALE;
   CARD32 UVSCALE;
   CARD32 OCLRC0;
   CARD32 OCLRC1;
   CARD32 DCLRKV;
   CARD32 DCLRKM;
   CARD32 SCLRKVH;
   CARD32 SCLRKVL;
   CARD32 SCLRKEN;
   CARD32 OCONFIG;
   CARD32 OCMD;
   CARD32 RESERVED1;			/* 0x6C */
   CARD32 OSTART_0Y; 		/* for i965 */
   CARD32 OSTART_1Y;		/* for i965 */
   CARD32 OSTART_0U;
   CARD32 OSTART_0V;
   CARD32 OSTART_1U;
   CARD32 OSTART_1V;
   CARD32 OTILEOFF_0Y;
   CARD32 OTILEOFF_1Y;
   CARD32 OTILEOFF_0U;
   CARD32 OTILEOFF_0V;
   CARD32 OTILEOFF_1U;
   CARD32 OTILEOFF_1V;
   CARD32 FASTHSCALE;			/* 0xA0 */
   CARD32 UVSCALEV;			/* 0xA4 */

   CARD32 RESERVEDC[(0x200 - 0xA8) / 4];		   /* 0xA8 - 0x1FC */
   CARD16 Y_VCOEFS[N_VERT_Y_TAPS * N_PHASES];		   /* 0x200 */
   CARD16 RESERVEDD[0x100 / 2 - N_VERT_Y_TAPS * N_PHASES];
   CARD16 Y_HCOEFS[N_HORIZ_Y_TAPS * N_PHASES];		   /* 0x300 */
   CARD16 RESERVEDE[0x200 / 2 - N_HORIZ_Y_TAPS * N_PHASES];
   CARD16 UV_VCOEFS[N_VERT_UV_TAPS * N_PHASES];		   /* 0x500 */
   CARD16 RESERVEDF[0x100 / 2 - N_VERT_UV_TAPS * N_PHASES];
   CARD16 UV_HCOEFS[N_HORIZ_UV_TAPS * N_PHASES];	   /* 0x600 */
   CARD16 RESERVEDG[0x100 / 2 - N_HORIZ_UV_TAPS * N_PHASES];
d319 3
d326 14
a339 14
   int i;
   CARD32 val;
   int bad = 0;

   for (i = 0; i < size; i += 4) {
      val = INREG(0x30100 + i);
      if (val != overlay[i / 4]) {
	 ErrorF("0x%05x value doesn't match (0x%lx != 0x%lx)\n",
		0x30100 + i, val, overlay[i / 4]);
	 bad++;
      }
   }
   if (!bad)
      ErrorF("CompareOverlay: no differences\n");
d343 61
a403 2
void
I830InitVideo(ScreenPtr pScreen)
d405 37
a441 5
   ScrnInfoPtr pScrn = xf86Screens[pScreen->myNum];
   I830Ptr pI830 = I830PTR(pScrn);
   XF86VideoAdaptorPtr *adaptors, *newAdaptors = NULL;
   XF86VideoAdaptorPtr overlayAdaptor = NULL, texturedAdaptor = NULL;
   int num_adaptors;
d443 2
a444 1
   ErrorF("I830InitVideo\n");
d446 2
a447 3
#if 0
   {
      I830OverlayRegRec tmp;
d449 26
a474 9
      ErrorF("sizeof I830OverlayRegRec is 0x%x\n", sizeof(I830OverlayRegRec));
      ErrorF("Reserved C, D, E, F, G are %x, %x, %x, %x, %x\n",
	     (unsigned long)&(tmp.RESERVEDC[0]) - (unsigned long)&tmp,
	     (unsigned long)&(tmp.RESERVEDD[0]) - (unsigned long)&tmp,
	     (unsigned long)&(tmp.RESERVEDE[0]) - (unsigned long)&tmp,
	     (unsigned long)&(tmp.RESERVEDF[0]) - (unsigned long)&tmp,
	     (unsigned long)&(tmp.RESERVEDG[0]) - (unsigned long)&tmp);
   }
#endif
a475 29
   num_adaptors = xf86XVListGenericAdaptors(pScrn, &adaptors);
   /* Give our adaptor list enough space for the overlay and/or texture video
    * adaptors.
    */
   newAdaptors = xalloc((num_adaptors + 2) * sizeof(XF86VideoAdaptorPtr *));
   if (newAdaptors == NULL)
      return;

   memcpy(newAdaptors, adaptors, num_adaptors * sizeof(XF86VideoAdaptorPtr));
   adaptors = newAdaptors;

   /* Add the adaptors supported by our hardware.  First, set up the atoms
    * that will be used by both output adaptors.
    */
   xvBrightness = MAKE_ATOM("XV_BRIGHTNESS");
   xvContrast = MAKE_ATOM("XV_CONTRAST");

   /* Set up overlay video if we can do it at this depth. */
   if (!IS_I96X(pI830) && pScrn->bitsPerPixel != 8) {
      overlayAdaptor = I830SetupImageVideoOverlay(pScreen);
      if (overlayAdaptor != NULL) {
	 adaptors[num_adaptors++] = overlayAdaptor;
	 xf86DrvMsg(pScrn->scrnIndex, X_INFO, "Set up overlay video\n");
      } else {
	 xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
		    "Failed to set up overlay video\n");
      }
      I830InitOffscreenImages(pScreen);
   }
d477 5
a481 13
   /* Set up textured video if we can do it at this depth and we are on
    * supported hardware.
    */
   if (pScrn->bitsPerPixel >= 16 && (IS_I9XX(pI830) || IS_I96X(pI830))) {
      texturedAdaptor = I830SetupImageVideoTextured(pScreen);
      if (texturedAdaptor != NULL) {
	 adaptors[num_adaptors++] = texturedAdaptor;
	 xf86DrvMsg(pScrn->scrnIndex, X_INFO, "Set up textured video\n");
      } else {
	 xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
		    "Failed to set up textured video\n");
      }
   }
d483 2
a484 2
   if (num_adaptors)
      xf86XVScreenInit(pScreen, adaptors, num_adaptors);
d486 37
a522 1
   xfree(adaptors);
d525 2
a526 2
static void
I830ResetVideo(ScrnInfoPtr pScrn)
d528 67
a594 50
   I830Ptr pI830 = I830PTR(pScrn);
   I830PortPrivPtr pPriv = pI830->adaptor->pPortPrivates[0].ptr;
   I830OverlayRegPtr overlay =
	 (I830OverlayRegPtr) (pI830->FbBase + pI830->OverlayMem->Start);

   ErrorF("I830ResetVideo: base: %p, offset: 0x%lx, obase: %p\n",
	   pI830->FbBase, pI830->OverlayMem->Start, overlay);
   /*
    * Default to maximum image size in YV12
    */

   memset(overlay, 0, sizeof(*overlay));
   overlay->YRGB_VPH = 0;
   overlay->UV_VPH = 0;
   overlay->HORZ_PH = 0;
   overlay->INIT_PHS = 0;
   overlay->DWINPOS = 0;
   overlay->DWINSZ = 0;
   overlay->SWIDTH = 0;
   overlay->SWIDTHSW = 0;
   overlay->SHEIGHT = 0;
   overlay->OCLRC0 = (pPriv->contrast << 18) | (pPriv->brightness & 0xff);
   overlay->OCLRC1 = 0x00000080;	/* saturation: bypass */
#if 0
   overlay->AWINPOS = 0;
   overlay->AWINSZ = 0;
#endif
   overlay->FASTHSCALE = 0;

   /*
    * Enable destination color keying
    */
   switch (pScrn->depth) {
   case 8:
      overlay->DCLRKV = 0;
      overlay->DCLRKM = 0xffffff | DEST_KEY_ENABLE;
      break;
   case 15:
      overlay->DCLRKV = RGB15ToColorKey(pPriv->colorKey);
      overlay->DCLRKM = 0x070707 | DEST_KEY_ENABLE;
      break;
   case 16:
      overlay->DCLRKV = RGB16ToColorKey(pPriv->colorKey);
      overlay->DCLRKM = 0x070307 | DEST_KEY_ENABLE;
      break;
   default:
      overlay->DCLRKV = pPriv->colorKey;
      overlay->DCLRKM = DEST_KEY_ENABLE;
      break;
   }
d596 2
a597 13
   overlay->SCLRKVH = 0;
   overlay->SCLRKVL = 0;
   overlay->SCLRKEN = 0;		/* source color key disable */
   overlay->OCONFIG = CC_OUT_8BIT;

   /*
    * Select which pipe the overlay is enabled on.
    */
   overlay->OCONFIG &= ~OVERLAY_PIPE_MASK;
   if (pPriv->pipe == 0)
      overlay->OCONFIG |= OVERLAY_PIPE_A;
   else 
      overlay->OCONFIG |= OVERLAY_PIPE_B;
d599 2
a600 1
   overlay->OCMD = YUV_420;
d602 78
a679 11
#if 0
   /* 
    * XXX DUMP REGISTER CODE !!!
    * This allows us to dump the complete i845 registers and compare
    * with warm boot situations before we upload our first copy.
    */
   {
      int i;
      for (i = 0x30000; i < 0x31000; i += 4)
	 ErrorF("0x%x 0x%lx\n", i, INREG(i));
   }
d692 18
a709 18
   I830Ptr pI830 = I830PTR(pScrn);
   I830PortPrivPtr pPriv = pI830->adaptor->pPortPrivates[0].ptr;
   CARD32 panelFitControl = INREG(PFIT_CONTROLS);
   int vertScale;

   pPriv->scaleRatio = 0x10000;

   if (panelFitControl & PFIT_ON_MASK) {
      if (panelFitControl & PFIT_AUTOVSCALE_MASK) {
         vertScale = INREG(PFIT_AUTOSCALE_RATIO) >> 16;
      } else {
         vertScale = INREG(PFIT_PROGRAMMED_SCALE_RATIO) >> 16;
      }

      if (vertScale != 0)
         pPriv->scaleRatio = ((double) 0x10000 / (double)vertScale) * 0x10000;
 
      pPriv->oneLineMode = TRUE;
d711 2
a712 2
      xf86DrvMsg(pScrn->scrnIndex, X_INFO, "Enabling Xvideo one-line mode\n");
   }
d714 2
a715 2
   if (pPriv->scaleRatio == 0x10000)
      pPriv->oneLineMode = FALSE;
d720 7
a726 7
   elt &= 0xff;
   eltPrev &= 0xff;
   if (elt < eltPrev)
      elt = eltPrev;
   else if ((elt - eltPrev) > 0x7e)
      elt = eltPrev + 0x7e;
   return elt;
d731 4
a734 4
   return (I830BoundGammaElt (gamma >> 24, gammaPrev >> 24) << 24 |
	   I830BoundGammaElt (gamma >> 16, gammaPrev >> 16) << 16 |
	   I830BoundGammaElt (gamma >>  8, gammaPrev >>  8) <<  8 |
	   I830BoundGammaElt (gamma      , gammaPrev      ));
d740 29
a768 25
   I830Ptr pI830 = I830PTR(pScrn);
   I830PortPrivPtr pPriv = pI830->adaptor->pPortPrivates[0].ptr;
   CARD32   gamma0 = pPriv->gamma0;
   CARD32   gamma1 = pPriv->gamma1;
   CARD32   gamma2 = pPriv->gamma2;
   CARD32   gamma3 = pPriv->gamma3;
   CARD32   gamma4 = pPriv->gamma4;
   CARD32   gamma5 = pPriv->gamma5;

   ErrorF ("Original gamma: 0x%lx 0x%lx 0x%lx 0x%lx 0x%lx 0x%lx\n",
	   gamma0, gamma1, gamma2, gamma3, gamma4, gamma5);
   gamma1 = I830BoundGamma (gamma1, gamma0);
   gamma2 = I830BoundGamma (gamma2, gamma1);
   gamma3 = I830BoundGamma (gamma3, gamma2);
   gamma4 = I830BoundGamma (gamma4, gamma3);
   gamma5 = I830BoundGamma (gamma5, gamma4);
   ErrorF ("Bounded  gamma: 0x%lx 0x%lx 0x%lx 0x%lx 0x%lx 0x%lx\n",
	   gamma0, gamma1, gamma2, gamma3, gamma4, gamma5);

   OUTREG(OGAMC5, gamma5);
   OUTREG(OGAMC4, gamma4);
   OUTREG(OGAMC3, gamma3);
   OUTREG(OGAMC2, gamma2);
   OUTREG(OGAMC1, gamma1);
   OUTREG(OGAMC0, gamma0);
d774 111
a884 94
   ScrnInfoPtr pScrn = xf86Screens[pScreen->myNum];
   I830Ptr pI830 = I830PTR(pScrn);
   XF86VideoAdaptorPtr adapt;
   I830PortPrivPtr pPriv;
   XF86AttributePtr att;

   ErrorF("I830SetupImageVideoOverlay\n");

   if (!(adapt = xcalloc(1, sizeof(XF86VideoAdaptorRec) +
			 sizeof(I830PortPrivRec) + sizeof(DevUnion))))
      return NULL;

   adapt->type = XvWindowMask | XvInputMask | XvImageMask;
   adapt->flags = VIDEO_OVERLAID_IMAGES /*| VIDEO_CLIP_TO_VIEWPORT*/;
   adapt->name = "Intel(R) Video Overlay";
   adapt->nEncodings = 1;
   adapt->pEncodings = DummyEncoding;
   /* update the DummyEncoding for these two chipsets */
   if (IS_845G(pI830) || IS_I830(pI830)) {
      adapt->pEncodings->width = IMAGE_MAX_WIDTH_LEGACY;
      adapt->pEncodings->height = IMAGE_MAX_HEIGHT_LEGACY;
   }
   adapt->nFormats = NUM_FORMATS;
   adapt->pFormats = Formats;
   adapt->nPorts = 1;
   adapt->pPortPrivates = (DevUnion *) (&adapt[1]);

   pPriv = (I830PortPrivPtr) (&adapt->pPortPrivates[1]);

   adapt->pPortPrivates[0].ptr = (pointer) (pPriv);
   adapt->nAttributes = NUM_ATTRIBUTES;
   adapt->nAttributes += CLONE_ATTRIBUTES;
   if (IS_I9XX(pI830))
      adapt->nAttributes += GAMMA_ATTRIBUTES; /* has gamma */
   adapt->pAttributes = xnfalloc(sizeof(XF86AttributeRec) * adapt->nAttributes);
   /* Now copy the attributes */
   att = adapt->pAttributes;
   memcpy((char *)att, (char*)Attributes, sizeof(XF86AttributeRec)* NUM_ATTRIBUTES);
   att+=NUM_ATTRIBUTES;
   memcpy((char*)att, (char*)CloneAttributes, sizeof(XF86AttributeRec) * CLONE_ATTRIBUTES);
   att+=CLONE_ATTRIBUTES;
   if (IS_I9XX(pI830)) {
      memcpy((char*)att, (char*)GammaAttributes, sizeof(XF86AttributeRec) * GAMMA_ATTRIBUTES);
      att+=GAMMA_ATTRIBUTES;
   }
   adapt->nImages = NUM_IMAGES;
   adapt->pImages = Images;
   adapt->PutVideo = NULL;
   adapt->PutStill = NULL;
   adapt->GetVideo = NULL;
   adapt->GetStill = NULL;
   adapt->StopVideo = I830StopVideo;
   adapt->SetPortAttribute = I830SetPortAttribute;
   adapt->GetPortAttribute = I830GetPortAttribute;
   adapt->QueryBestSize = I830QueryBestSize;
   adapt->PutImage = I830PutImage;
   adapt->QueryImageAttributes = I830QueryImageAttributesOverlay;

   pPriv->textured = FALSE;
   pPriv->colorKey = pI830->colorKey & ((1 << pScrn->depth) - 1);
   pPriv->videoStatus = 0;
   pPriv->brightness = 0;
   pPriv->contrast = 64;
   pPriv->pipe = pI830->pipe; /* default to current pipe */
   pPriv->linear = NULL;
   pPriv->currentBuf = 0;
   pPriv->gamma5 = 0xc0c0c0;
   pPriv->gamma4 = 0x808080;
   pPriv->gamma3 = 0x404040;
   pPriv->gamma2 = 0x202020;
   pPriv->gamma1 = 0x101010;
   pPriv->gamma0 = 0x080808;
   pPriv->doubleBuffer = 1;

   /* gotta uninit this someplace */
   REGION_NULL(pScreen, &pPriv->clip);

   pI830->adaptor = adapt;

   /* With LFP's we need to detect whether we're in One Line Mode, which
    * essentially means a resolution greater than 1024x768, and fix up
    * the scaler accordingly. */
   pPriv->scaleRatio = 0x10000;
   pPriv->oneLineMode = FALSE;

   /*
    * Initialise pPriv->overlayOK.  Set it to TRUE here so that a warning will
    * be generated if I830VideoSwitchModeAfter() sets it to FALSE.
    */
   pPriv->overlayOK = TRUE;
   I830VideoSwitchModeAfter(pScrn, pScrn->currentMode);

   pI830->BlockHandler = pScreen->BlockHandler;
   pScreen->BlockHandler = I830BlockHandler;
d886 1
a886 2
   xvColorKey = MAKE_ATOM("XV_COLORKEY");
   xvDoubleBuffer = MAKE_ATOM("XV_DOUBLE_BUFFER");
d888 1
a888 15
   /* Allow the pipe to be switched from pipe A to B when in clone mode */
   xvPipe = MAKE_ATOM("XV_PIPE");
   
   if (IS_I9XX(pI830)) {
     xvGamma0 = MAKE_ATOM("XV_GAMMA0");
     xvGamma1 = MAKE_ATOM("XV_GAMMA1");
     xvGamma2 = MAKE_ATOM("XV_GAMMA2");
     xvGamma3 = MAKE_ATOM("XV_GAMMA3");
     xvGamma4 = MAKE_ATOM("XV_GAMMA4");
     xvGamma5 = MAKE_ATOM("XV_GAMMA5");
   }

   I830ResetVideo(pScrn);

   I830UpdateGamma(pScrn);
d890 1
a890 1
   return adapt;
d896 58
a953 27
   XF86VideoAdaptorPtr adapt;
   XF86VideoEncodingPtr encoding;
   XF86AttributePtr attrs;
   I830PortPrivPtr portPrivs;
   DevUnion *devUnions;
   int nports = 16, i;
   int nAttributes;

   ErrorF("I830SetupImageVideoOverlay\n");

   nAttributes = NUM_TEXTURED_ATTRIBUTES;

   adapt = xcalloc(1, sizeof(XF86VideoAdaptorRec));
   portPrivs = xcalloc(nports, sizeof(I830PortPrivRec));
   devUnions = xcalloc(nports, sizeof(DevUnion));
   encoding = xcalloc(1, sizeof(XF86VideoEncodingRec));
   attrs = xcalloc(nAttributes, sizeof(XF86AttributeRec));
   if (adapt == NULL || portPrivs == NULL || devUnions == NULL ||
       encoding == NULL || attrs == NULL)
   {
      xfree(adapt);
      xfree(portPrivs);
      xfree(devUnions);
      xfree(encoding);
      xfree(attrs);
      return NULL;
   }
d955 2
a956 39
   adapt->type = XvWindowMask | XvInputMask | XvImageMask;
   adapt->flags = 0;
   adapt->name = "Intel(R) Textured Video";
   adapt->nEncodings = 1;
   adapt->pEncodings = encoding;
   adapt->pEncodings[0].id = 0;
   adapt->pEncodings[0].name = "XV_IMAGE";
   adapt->pEncodings[0].width = 2048;
   adapt->pEncodings[0].height = 2048;
   adapt->pEncodings[0].rate.numerator = 1;
   adapt->pEncodings[0].rate.denominator = 1;
   adapt->nFormats = NUM_FORMATS;
   adapt->pFormats = Formats;
   adapt->nPorts = nports;
   adapt->pPortPrivates = devUnions;
   adapt->nAttributes = nAttributes;
   adapt->pAttributes = attrs;
   memcpy(attrs, TexturedAttributes, nAttributes * sizeof(XF86AttributeRec));
   adapt->nImages = NUM_IMAGES;
   adapt->pImages = Images;
   adapt->PutVideo = NULL;
   adapt->PutStill = NULL;
   adapt->GetVideo = NULL;
   adapt->GetStill = NULL;
   adapt->StopVideo = I830StopVideo;
   adapt->SetPortAttribute = I830SetPortAttribute;
   adapt->GetPortAttribute = I830GetPortAttribute;
   adapt->QueryBestSize = I830QueryBestSize;
   adapt->PutImage = I830PutImage;
   adapt->QueryImageAttributes = I830QueryImageAttributesTextured;

   for (i = 0; i < nports; i++) {
      I830PortPrivPtr pPriv = &portPrivs[i];

      pPriv->textured = TRUE;
      pPriv->videoStatus = 0;
      pPriv->linear = NULL;
      pPriv->currentBuf = 0;
      pPriv->doubleBuffer = 0;
d958 2
a959 2
      /* gotta uninit this someplace, XXX: shouldn't be necessary for textured */
      REGION_NULL(pScreen, &pPriv->clip);
d961 1
a961 4
      adapt->pPortPrivates[i].ptr = (pointer) (pPriv);
   }

   return adapt;
d967 2
a968 2
   int *dataA, *dataB;
   int num;
d970 18
a987 18
   num = REGION_NUM_RECTS(A);
   if (num != REGION_NUM_RECTS(B))
      return FALSE;

   if ((A->extents.x1 != B->extents.x1) ||
       (A->extents.x2 != B->extents.x2) ||
       (A->extents.y1 != B->extents.y1) || (A->extents.y2 != B->extents.y2))
      return FALSE;

   dataA = (int *)REGION_RECTS(A);
   dataB = (int *)REGION_RECTS(B);

   while (num--) {
      if ((dataA[0] != dataB[0]) || (dataA[1] != dataB[1]))
	 return FALSE;
      dataA += 2;
      dataB += 2;
   }
d989 1
a989 1
   return TRUE;
d995 2
a996 2
   I830PortPrivPtr pPriv = (I830PortPrivPtr) data;
   I830Ptr pI830 = I830PTR(pScrn);
d998 2
a999 2
   if (pPriv->textured)
      return;
d1001 1
a1001 1
   ErrorF("I830StopVideo\n");
d1003 20
a1022 23
   REGION_EMPTY(pScrn->pScreen, &pPriv->clip);

   if (shutdown) {
      if (pPriv->videoStatus & CLIENT_VIDEO_ON) {

	 I830ResetVideo(pScrn);
	 OVERLAY_UPDATE;
	 OVERLAY_OFF;

         if (pI830->entityPrivate)
            pI830->entityPrivate->XvInUse = -1;
      }
      if (pPriv->linear) {
	 xf86FreeOffscreenLinear(pPriv->linear);
	 pPriv->linear = NULL;
      }
      pPriv->videoStatus = 0;
   } else {
      if (pPriv->videoStatus & CLIENT_VIDEO_ON) {
	 pPriv->videoStatus |= OFF_TIMER;
	 pPriv->offTime = currentTime.milliseconds + OFF_DELAY;
      }
   }
d1030 90
a1119 90
   I830PortPrivPtr pPriv = (I830PortPrivPtr) data;
   I830Ptr pI830 = I830PTR(pScrn);
   I830OverlayRegPtr overlay =
	 (I830OverlayRegPtr) (pI830->FbBase + pI830->OverlayMem->Start);

   if (pPriv->textured) {
      /* XXX: Currently the brightness/saturation attributes aren't hooked up.
       * However, apps expect them to be there, and the spec seems to let us
       * sneak out of actually implementing them for now.
       */
      return Success;
   }

   if (attribute == xvBrightness) {
      if ((value < -128) || (value > 127))
	 return BadValue;
      pPriv->brightness = value;
      overlay->OCLRC0 = (pPriv->contrast << 18) | (pPriv->brightness & 0xff);
      ErrorF("BRIGHTNESS\n");
      if (*pI830->overlayOn)
         OVERLAY_UPDATE;
   } else if (attribute == xvContrast) {
      if ((value < 0) || (value > 255))
	 return BadValue;
      pPriv->contrast = value;
      overlay->OCLRC0 = (pPriv->contrast << 18) | (pPriv->brightness & 0xff);
      ErrorF("CONTRAST\n");
      if (*pI830->overlayOn)
         OVERLAY_UPDATE;
   } else if (pI830->Clone && attribute == xvPipe) {
      if ((value < 0) || (value > 1))
         return BadValue;
      pPriv->pipe = value;
      /*
       * Select which pipe the overlay is enabled on.
       */
      overlay->OCONFIG &= ~OVERLAY_PIPE_MASK;
      if (pPriv->pipe == 0)
         overlay->OCONFIG |= OVERLAY_PIPE_A;
      else 
         overlay->OCONFIG |= OVERLAY_PIPE_B;
      ErrorF("PIPE CHANGE\n");
      if (*pI830->overlayOn)
         OVERLAY_UPDATE;
   } else if (attribute == xvGamma0 && (IS_I9XX(pI830))) {
      pPriv->gamma0 = value; 
   } else if (attribute == xvGamma1 && (IS_I9XX(pI830))) {
      pPriv->gamma1 = value;
   } else if (attribute == xvGamma2 && (IS_I9XX(pI830))) {
      pPriv->gamma2 = value;
   } else if (attribute == xvGamma3 && (IS_I9XX(pI830))) {
      pPriv->gamma3 = value;
   } else if (attribute == xvGamma4 && (IS_I9XX(pI830))) {
      pPriv->gamma4 = value;
   } else if (attribute == xvGamma5 && (IS_I9XX(pI830))) {
      pPriv->gamma5 = value;
   } else if (attribute == xvColorKey) {
      pPriv->colorKey = value;
      switch (pScrn->depth) {
      case 16:
	 overlay->DCLRKV = RGB16ToColorKey(pPriv->colorKey);
	 break;
      case 15:
	 overlay->DCLRKV = RGB15ToColorKey(pPriv->colorKey);
	 break;
      default:
	 overlay->DCLRKV = pPriv->colorKey;
	 break;
      }
      ErrorF("COLORKEY\n");
      if (*pI830->overlayOn)
         OVERLAY_UPDATE;
      REGION_EMPTY(pScrn->pScreen, &pPriv->clip);
   } else if(attribute == xvDoubleBuffer) {
      if ((value < 0) || (value > 1))
         return BadValue;
      /* Do not allow buffer change while playing video */
      if(!*pI830->overlayOn)
     	 pPriv->doubleBuffer = value;
   } else
      return BadMatch;

   /* Ensure that the overlay is off, ready for updating */
   if ((attribute == xvGamma0 ||
        attribute == xvGamma1 ||
        attribute == xvGamma2 ||
        attribute == xvGamma3 ||
        attribute == xvGamma4 ||
        attribute == xvGamma5) && (IS_I9XX(pI830))) {
        ErrorF("GAMMA\n");
d1121 1
a1121 1
   }
d1123 1
a1123 1
   return Success;
d1130 2
a1131 2
   I830Ptr pI830 = I830PTR(pScrn);
   I830PortPrivPtr pPriv = (I830PortPrivPtr) data;
d1133 33
a1165 24
   if (attribute == xvBrightness) {
      *value = pPriv->brightness;
   } else if (attribute == xvContrast) {
      *value = pPriv->contrast;
   } else if (attribute == xvPipe) {
      *value = pPriv->pipe;
   } else if (attribute == xvGamma0 && (IS_I9XX(pI830))) {
      *value = pPriv->gamma0;
   } else if (attribute == xvGamma1 && (IS_I9XX(pI830))) {
      *value = pPriv->gamma1;
   } else if (attribute == xvGamma2 && (IS_I9XX(pI830))) {
      *value = pPriv->gamma2;
   } else if (attribute == xvGamma3 && (IS_I9XX(pI830))) {
      *value = pPriv->gamma3;
   } else if (attribute == xvGamma4 && (IS_I9XX(pI830))) {
      *value = pPriv->gamma4;
   } else if (attribute == xvGamma5 && (IS_I9XX(pI830))) {
      *value = pPriv->gamma5;
   } else if (attribute == xvColorKey) {
      *value = pPriv->colorKey;
   } else if (attribute == xvDoubleBuffer) {
      *value = pPriv->doubleBuffer;
   } else 
      return BadMatch;
d1167 1
a1167 1
   return Success;
d1177 4
a1180 4
   if (vid_w > (drw_w << 1))
      drw_w = vid_w >> 1;
   if (vid_h > (drw_h << 1))
      drw_h = vid_h >> 1;
d1182 2
a1183 2
   *p_w = drw_w;
   *p_h = drw_h;
d1192 32
a1223 29
   I830Ptr pI830 = I830PTR(pScrn);
   unsigned char *src, *dst;
   int i,j;
   unsigned char *s;

   ErrorF("I830CopyPackedData: (%d,%d) (%d,%d)\n"
	   "srcPitch: %d, dstPitch: %d\n", top, left, h, w, srcPitch, dstPitch);

   src = buf + (top * srcPitch) + (left << 1);

   if (pPriv->currentBuf == 0)
      dst = pI830->FbBase + pPriv->YBuf0offset;
   else
      dst = pI830->FbBase + pPriv->YBuf1offset;

   switch (pI830->rotation) {
      case RR_Rotate_0:
         w <<= 1;
         for (i = 0; i < h; i++) {
            memcpy(dst, src, w);
            src += srcPitch;
            dst += dstPitch;
         }
	 break;
      case RR_Rotate_90:
         h <<= 1;
         for (i = 0; i < h; i+=2) {
            s = src;
            for (j = 0; j < w; j++) {
d1225 1
a1225 1
               dst[(i + 0) + ((w - j - 1) * dstPitch)] = *s++; 
d1227 7
a1233 7
            }
            src += srcPitch;
         }
         h >>= 1;
   	 src = buf + (top * srcPitch) + (left << 1);
         for (i = 0; i < h; i+=2) {
            for (j = 0; j < w; j+=2) {
d1240 21
a1260 21
            }
         }
         break;
      case RR_Rotate_180:
         w <<= 1;
         for (i = 0; i < h; i++) {
            s = src;
            for (j = 0; j < w; j+=4) {
               dst[(w - j - 4) + ((h - i - 1) * dstPitch)] = *s++;
               dst[(w - j - 3) + ((h - i - 1) * dstPitch)] = *s++;
               dst[(w - j - 2) + ((h - i - 1) * dstPitch)] = *s++;
               dst[(w - j - 1) + ((h - i - 1) * dstPitch)] = *s++;
            }
            src += srcPitch;
         }
         break;
      case RR_Rotate_270:
         h <<= 1;
         for (i = 0; i < h; i+=2) {
            s = src;
            for (j = 0; j < w; j++) {
d1262 1
a1262 1
               dst[(h - i - 2) + (j * dstPitch)] = *s++;
d1264 7
a1270 7
            }
            src += srcPitch;
         }
         h >>= 1;
   	 src = buf + (top * srcPitch) + (left << 1);
         for (i = 0; i < h; i+=2) {
            for (j = 0; j < w; j+=2) {
d1277 4
a1280 4
            }
         }
         break;
   }
d1291 49
a1339 49
   I830Ptr pI830 = I830PTR(pScrn);
   CARD8 *dst1, *srcy, *srcu, *srcv;
   int y;

   if (pPriv->currentBuf == 0)
      dst1 = pI830->FbBase + pPriv->YBuf0offset;
   else
      dst1 = pI830->FbBase + pPriv->YBuf1offset;

   srcy = buf + (top * srcPitch) + left;
   if (id == FOURCC_YV12) {
      srcu = buf + (srcH * srcPitch) + ((top / 2) * srcPitch2) + (left / 2);
      srcv = buf + (srcH * srcPitch) + ((srcH / 2) * srcPitch2) +
	    ((top / 2) * srcPitch2) + (left / 2);
   } else {
      srcv = buf + (srcH * srcPitch) + ((top / 2) * srcPitch2) + (left / 2);
      srcu = buf + (srcH * srcPitch) + ((srcH / 2) * srcPitch2) +
	    ((top / 2) * srcPitch2) + (left / 2);
   }

   for (y = 0; y < h; y++) {
      CARD32 *dst = (CARD32 *)dst1;
      CARD8 *sy = srcy;
      CARD8 *su = srcu;
      CARD8 *sv = srcv;
      int i;

      i = w / 2;
      while(i > 4) {
	 dst[0] = sy[0] | (sy[1] << 16) | (sv[0] << 8) | (su[0] << 24);
	 dst[1] = sy[2] | (sy[3] << 16) | (sv[1] << 8) | (su[1] << 24);
	 dst[2] = sy[4] | (sy[5] << 16) | (sv[2] << 8) | (su[2] << 24);
	 dst[3] = sy[6] | (sy[7] << 16) | (sv[3] << 8) | (su[3] << 24);
	 dst += 4; su += 4; sv += 4; sy += 8;
	 i -= 4;
      }
      while(i--) {
	 dst[0] = sy[0] | (sy[1] << 16) | (sv[0] << 8) | (su[0] << 24);
	 dst++; su++; sv++;
	 sy += 2;
      }

      dst1 += dstPitch;
      srcy += srcPitch;
      if (y & 1) {
	 srcu += srcPitch2;
	 srcv += srcPitch2;
      }	
   }
d1348 5
a1352 5
   I830Ptr pI830 = I830PTR(pScrn);
   int i, j = 0;
   unsigned char *src1, *src2, *src3, *dst1, *dst2, *dst3;
   unsigned char *s;
   int dstPitch2 = dstPitch << 1;
d1354 4
a1357 2
   ErrorF("I830CopyPlanarData: srcPitch %d, srcPitch %d, dstPitch %d\n"
	   "nlines %d, npixels %d, top %d, left %d\n", srcPitch, srcPitch2, dstPitch,
d1359 1
d1361 158
a1518 152
   /* Copy Y data */
   src1 = buf + (top * srcPitch) + left;
   ErrorF("src1 is %p, offset is %ld\n", src1,
	  (unsigned long)src1 - (unsigned long)buf);
   if (pPriv->currentBuf == 0)
      dst1 = pI830->FbBase + pPriv->YBuf0offset;
   else
      dst1 = pI830->FbBase + pPriv->YBuf1offset;

   switch (pI830->rotation) {
      case RR_Rotate_0:
         for (i = 0; i < h; i++) {
            memcpy(dst1, src1, w);
            src1 += srcPitch;
            dst1 += dstPitch2;
         }
	 break;
      case RR_Rotate_90:
         for (i = 0; i < h; i++) {
            s = src1;
            for (j = 0; j < w; j++) {
               dst1[(i) + ((w - j - 1) * dstPitch2)] = *s++;
            }
            src1 += srcPitch;
         }
         break;
      case RR_Rotate_180:
         for (i = 0; i < h; i++) {
            s = src1;
            for (j = 0; j < w; j++) {
               dst1[(w - j - 1) + ((h - i - 1) * dstPitch2)] = *s++;
            }
            src1 += srcPitch;
         }
         break;
      case RR_Rotate_270:
         for (i = 0; i < h; i++) {
            s = src1;
            for (j = 0; j < w; j++) {
               dst1[(h - i - 1) + (j * dstPitch2)] = *s++;
            }
            src1 += srcPitch;
         }
         break;
   }

   /* Copy V data for YV12, or U data for I420 */
   src2 = buf + (srcH * srcPitch) + ((top * srcPitch) >> 2) + (left >> 1);
   ErrorF("src2 is %p, offset is %ld\n", src2,
	  (unsigned long)src2 - (unsigned long)buf);
   if (pPriv->currentBuf == 0) {
      if (id == FOURCC_I420)
	 dst2 = pI830->FbBase + pPriv->UBuf0offset;
      else
	 dst2 = pI830->FbBase + pPriv->VBuf0offset;
   } else {
      if (id == FOURCC_I420)
	 dst2 = pI830->FbBase + pPriv->UBuf1offset;
      else
	 dst2 = pI830->FbBase + pPriv->VBuf1offset;
   }

   switch (pI830->rotation) {
      case RR_Rotate_0:
         for (i = 0; i < h / 2; i++) {
            memcpy(dst2, src2, w / 2);
            src2 += srcPitch2;
            dst2 += dstPitch;
         }
         break;
      case RR_Rotate_90:
         for (i = 0; i < (h/2); i++) {
            s = src2;
            for (j = 0; j < (w/2); j++) {
               dst2[(i) + (((w/2) - j - 1) * (dstPitch))] = *s++;
            }
            src2 += srcPitch2;
         }
         break;
      case RR_Rotate_180:
         for (i = 0; i < (h/2); i++) {
            s = src2;
            for (j = 0; j < (w/2); j++) {
               dst2[((w/2) - j - 1) + (((h/2) - i - 1) * dstPitch)] = *s++;
            }
            src2 += srcPitch2;
         }
         break;
      case RR_Rotate_270:
         for (i = 0; i < (h/2); i++) {
            s = src2;
            for (j = 0; j < (w/2); j++) {
               dst2[((h/2) - i - 1) + (j * dstPitch)] = *s++;
            }
            src2 += srcPitch2;
         }
         break;
   }

   /* Copy U data for YV12, or V data for I420 */
   src3 = buf + (srcH * srcPitch) + ((srcH >> 1) * srcPitch2) +
	 ((top * srcPitch) >> 2) + (left >> 1);
   ErrorF("src3 is %p, offset is %ld\n", src3,
	  (unsigned long)src3 - (unsigned long)buf);
   if (pPriv->currentBuf == 0) {
      if (id == FOURCC_I420)
	 dst3 = pI830->FbBase + pPriv->VBuf0offset;
      else
	 dst3 = pI830->FbBase + pPriv->UBuf0offset;
   } else {
      if (id == FOURCC_I420)
	 dst3 = pI830->FbBase + pPriv->VBuf1offset;
      else
	 dst3 = pI830->FbBase + pPriv->UBuf1offset;
   }

   switch (pI830->rotation) {
      case RR_Rotate_0:
         for (i = 0; i < h / 2; i++) {
            memcpy(dst3, src3, w / 2);
            src3 += srcPitch2;
            dst3 += dstPitch;
         }
         break;
      case RR_Rotate_90:
         for (i = 0; i < (h/2); i++) {
            s = src3;
            for (j = 0; j < (w/2); j++) {
               dst3[(i) + (((w/2) - j - 1) * (dstPitch))] = *s++;
            }
            src3 += srcPitch2;
         }
         break;
      case RR_Rotate_180:
         for (i = 0; i < (h/2); i++) {
            s = src3;
            for (j = 0; j < (w/2); j++) {
               dst3[((w/2) - j - 1) + (((h/2) - i - 1) * dstPitch)] = *s++;
            }
            src3 += srcPitch2;
         }
         break;
      case RR_Rotate_270:
         for (i = 0; i < (h/2); i++) {
            s = src3;
            for (j = 0; j < (w/2); j++) {
               dst3[((h/2) - i - 1) + (j * dstPitch)] = *s++;
            }
            src3 += srcPitch2;
         }
         break;
   }
d1522 3
a1524 3
   CARD8 sign;
   CARD16 mantissa;
   CARD8 exponent;
d1530 38
a1567 38
   int maxVal, icoeff, res;
   int sign;
   double c;

   sign = 0;
   maxVal = 1 << mantSize;
   c = *coeff;
   if (c < 0.0) {
      sign = 1;
      c = -c;
   }

   res = 12 - mantSize;
   if ((icoeff = (int)(c * 4 * maxVal + 0.5)) < maxVal) {
      pCoeff[pos].exponent = 3;
      pCoeff[pos].mantissa = icoeff << res;
      *coeff = (double)icoeff / (double)(4 * maxVal);
   } else if ((icoeff = (int)(c * 2 * maxVal + 0.5)) < maxVal) {
      pCoeff[pos].exponent = 2;
      pCoeff[pos].mantissa = icoeff << res;
      *coeff = (double)icoeff / (double)(2 * maxVal);
   } else if ((icoeff = (int)(c * maxVal + 0.5)) < maxVal) {
      pCoeff[pos].exponent = 1;
      pCoeff[pos].mantissa = icoeff << res;
      *coeff = (double)icoeff / (double)(maxVal);
   } else if ((icoeff = (int)(c * maxVal * 0.5 + 0.5)) < maxVal) {
      pCoeff[pos].exponent = 0;
      pCoeff[pos].mantissa = icoeff << res;
      *coeff = (double)icoeff / (double)(maxVal / 2);
   } else {
      /* Coeff out of range */
      return FALSE;
   }

   pCoeff[pos].sign = sign;
   if (sign)
      *coeff = -(*coeff);
   return TRUE;
d1573 43
a1615 65
   int i, j, j1, num, pos, mantSize;
   double pi = 3.1415926535, val, sinc, window, sum;
   double rawCoeff[MAX_TAPS * 32], coeffs[N_PHASES][MAX_TAPS];
   double diff;
   int tapAdjust[MAX_TAPS], tap2Fix;
   Bool isVertAndUV;

   if (isHoriz)
      mantSize = 7;
   else
      mantSize = 6;

   isVertAndUV = !isHoriz && !isY;
   num = taps * 16;
   for (i = 0; i < num  * 2; i++) {
      val = (1.0 / fCutoff) * taps * pi * (i - num) / (2 * num);
      if (val == 0.0)
	 sinc = 1.0;
      else
	 sinc = sin(val) / val;

      /* Hamming window */
      window = (0.5 - 0.5 * cos(i * pi / num));
      rawCoeff[i] = sinc * window;
   }

   for (i = 0; i < N_PHASES; i++) {
      /* Normalise the coefficients. */
      sum = 0.0;
      for (j = 0; j < taps; j++) {
	 pos = i + j * 32;
	 sum += rawCoeff[pos];
      }
      for (j = 0; j < taps; j++) {
	 pos = i + j * 32;
	 coeffs[i][j] = rawCoeff[pos] / sum;
      }

      /* Set the register values. */
      for (j = 0; j < taps; j++) {
	 pos = j + i * taps;
	 if ((j == (taps - 1) / 2) && !isVertAndUV)
	    SetCoeffRegs(&coeffs[i][j], mantSize + 2, pCoeff, pos);
	 else
	    SetCoeffRegs(&coeffs[i][j], mantSize, pCoeff, pos);
      }

      tapAdjust[0] = (taps - 1) / 2;
      for (j = 1, j1 = 1; j <= tapAdjust[0]; j++, j1++) {
	 tapAdjust[j1] = tapAdjust[0] - j;
	 tapAdjust[++j1] = tapAdjust[0] + j;
      }

      /* Adjust the coefficients. */
      sum = 0.0;
      for (j = 0; j < taps; j++)
	 sum += coeffs[i][j];
      if (sum != 1.0) {
	 for (j1 = 0; j1 < taps; j1++) {
	    tap2Fix = tapAdjust[j1];
	    diff = 1.0 - sum;
	    coeffs[i][tap2Fix] += diff;
	    pos = tap2Fix + i * taps;
	    if ((tap2Fix == (taps - 1) / 2) && !isVertAndUV)
	       SetCoeffRegs(&coeffs[i][tap2Fix], mantSize + 2, pCoeff, pos);
d1617 2
a1618 1
	       SetCoeffRegs(&coeffs[i][tap2Fix], mantSize, pCoeff, pos);
d1620 29
a1648 8
	    sum = 0.0;
	    for (j = 0; j < taps; j++)
	       sum += coeffs[i][j];
	    if (sum == 1.0)
	       break;
	 }
      }
   }
d1652 9
a1660 12
I830DisplayVideo(ScrnInfoPtr pScrn, int id, short width, short height,
		 int dstPitch, int x1, int y1, int x2, int y2, BoxPtr dstBox,
		 short src_w, short src_h, short drw_w, short drw_h)
{
   I830Ptr pI830 = I830PTR(pScrn);
   I830PortPrivPtr pPriv = pI830->adaptor->pPortPrivates[0].ptr;
   I830OverlayRegPtr overlay =
	 (I830OverlayRegPtr) (pI830->FbBase + pI830->OverlayMem->Start);
   unsigned int swidth;
   unsigned int mask, shift, offsety, offsetu;
   int tmp;
   BoxRec dstBox2;
d1662 13
a1674 2
   ErrorF("I830DisplayVideo: %dx%d (pitch %d)\n", width, height,
	   dstPitch);
d1676 5
a1680 567
   if (!pPriv->overlayOK)
      return;

#if VIDEO_DEBUG
   CompareOverlay(pI830, (CARD32 *) overlay, 0x100);
#endif

   switch (pI830->rotation) {
	case RR_Rotate_0:
                if (pI830->MergedFB) {
		   memcpy(&dstBox2, dstBox, sizeof(BoxRec));
		   dstBox->x1 -= pI830->FirstframeX0;
		   dstBox->x2 -= pI830->FirstframeX0;
		   dstBox->y1 -= pI830->FirstframeY0;
		   dstBox->y2 -= pI830->FirstframeY0;
		   dstBox2.x1 -= pI830->pScrn_2->frameX0;
		   dstBox2.x2 -= pI830->pScrn_2->frameX0;
		   dstBox2.y1 -= pI830->pScrn_2->frameY0;
		   dstBox2.y2 -= pI830->pScrn_2->frameY0;
                } else {
		   dstBox->x1 -= pScrn->frameX0;
		   dstBox->x2 -= pScrn->frameX0;
		   dstBox->y1 -= pScrn->frameY0;
		   dstBox->y2 -= pScrn->frameY0;
                }
		break;
	case RR_Rotate_90:
		tmp = dstBox->x1;
		dstBox->x1 = dstBox->y1 - pScrn->frameX0;
		dstBox->y1 = pScrn->virtualY - tmp - pScrn->frameY0;
		tmp = dstBox->x2;
		dstBox->x2 = dstBox->y2 - pScrn->frameX0;
		dstBox->y2 = pScrn->virtualY - tmp - pScrn->frameY0;
		tmp = dstBox->y1;
		dstBox->y1 = dstBox->y2;
		dstBox->y2 = tmp;
		break;
	case RR_Rotate_180:
		tmp = dstBox->x1;
		dstBox->x1 = pScrn->virtualX - dstBox->x2 - pScrn->frameX0;
		dstBox->x2 = pScrn->virtualX - tmp - pScrn->frameX0;
		tmp = dstBox->y1;
		dstBox->y1 = pScrn->virtualY - dstBox->y2 - pScrn->frameY0;
		dstBox->y2 = pScrn->virtualY - tmp - pScrn->frameY0;
		break;
	case RR_Rotate_270:
		tmp = dstBox->x1;
		dstBox->x1 = pScrn->virtualX - dstBox->y1 - pScrn->frameX0;
		dstBox->y1 = tmp - pScrn->frameY0;
		tmp = dstBox->x2;
		dstBox->x2 = pScrn->virtualX - dstBox->y2 - pScrn->frameX0;
		dstBox->y2 = tmp - pScrn->frameY0;
		tmp = dstBox->x1;
		dstBox->x1 = dstBox->x2;
		dstBox->x2 = tmp;
		break;
   }

   if (pI830->MergedFB) {
      I830ModePrivatePtr mp = (I830ModePrivatePtr)pScrn->currentMode->Private;
      int w1, h1, w2, h2;

      /* Clip the video to the independent modes of the merged screens */
      if (dstBox->x1 > mp->merged.First->HDisplay) dstBox->x1 = mp->merged.First->HDisplay - 1;
      if (dstBox->x2 > mp->merged.First->HDisplay) dstBox->x2 = mp->merged.First->HDisplay - 1;
      if (dstBox2.x1 > mp->merged.Second->HDisplay) dstBox2.x1 = mp->merged.Second->HDisplay - 1;
      if (dstBox2.x2 > mp->merged.Second->HDisplay) dstBox2.x2 = mp->merged.Second->HDisplay - 1;
      if (dstBox->y1 > mp->merged.First->VDisplay) dstBox->y1 = mp->merged.First->VDisplay - 1;
      if (dstBox->y2 > mp->merged.First->VDisplay) dstBox->y2 = mp->merged.First->VDisplay - 1;
      if (dstBox2.y1 > mp->merged.Second->VDisplay) dstBox2.y1 = mp->merged.Second->VDisplay - 1;
      if (dstBox2.y2 > mp->merged.Second->VDisplay) dstBox2.y2 = mp->merged.Second->VDisplay - 1;
      if (dstBox->y1 < 0) dstBox->y1 = 0;
      if (dstBox->y2 < 0) dstBox->y2 = 0;
      if (dstBox->x1 < 0) dstBox->x1 = 0;
      if (dstBox->x2 < 0) dstBox->x2 = 0;
      if (dstBox2.y1 < 0) dstBox2.y1 = 0;
      if (dstBox2.y2 < 0) dstBox2.y2 = 0;
      if (dstBox2.x1 < 0) dstBox2.x1 = 0;
      if (dstBox2.x2 < 0) dstBox2.x2 = 0;

      w1 = dstBox->x2 - dstBox->x1;
      w2 = dstBox2.x2 - dstBox2.x1;
      h1 = dstBox->y2 - dstBox->y1;
      h2 = dstBox2.y2 - dstBox2.y1;

      switch (pI830->SecondPosition) {
         case PosRightOf:
         case PosBelow:
            if ((w2 > 0 && w1 == 0) ||
                (h2 > 0 && h1 == 0)) {
               pPriv->pipe = !pI830->pipe;
               dstBox->x1 = dstBox2.x1;
               dstBox->y1 = dstBox2.y1;
               dstBox->x2 = dstBox2.x2;
               dstBox->y2 = dstBox2.y2;
            } else 
               pPriv->pipe = pI830->pipe;
            break;
         case PosLeftOf:
         case PosAbove:
            if ((w1 > 0 && w2 == 0) ||
                (h1 > 0 && h2 == 0)) { 
               pPriv->pipe = pI830->pipe;
            } else {
               pPriv->pipe = !pI830->pipe;
               dstBox->x1 = dstBox2.x1;
               dstBox->y1 = dstBox2.y1;
               dstBox->x2 = dstBox2.x2;
               dstBox->y2 = dstBox2.y2;
            }
            break;
      }
   }

   /* When in dual head with different bpp setups we need to refresh the
    * color key, so let's reset the video parameters and refresh here.
    * In MergedFB mode, we may need to flip pipes too. */
   if (pI830->entityPrivate || pI830->MergedFB)
      I830ResetVideo(pScrn);

   /* Ensure overlay is turned on with OVERLAY_ENABLE at 0 */
   if (!*pI830->overlayOn) {
      ErrorF("TURNING ON OVERLAY BEFORE UPDATE\n");
      I830ResetVideo(pScrn);
      OVERLAY_UPDATE;
   }

   /* Fix up the dstBox if outside the visible screen */
   {
      int offset_x = (dstBox->x1 < 0) ? -dstBox->x1 : 0;
      int offset_y = (dstBox->y1 < 0) ? -dstBox->y1 : 0;
      int offset, offset2;

      /* align */
      offset_x = (offset_x + 3) & ~3;
      offset_y = (offset_y + 3) & ~3;

      if (pI830->rotation & (RR_Rotate_90 | RR_Rotate_270)) {
         height -= offset_x;
         width -= offset_y;
      } else {
         height -= offset_y;
         width -= offset_x;
      }

      if (id == FOURCC_I420 || id == FOURCC_YV12) {
         offset = ((offset_x/2) + (dstPitch * offset_y)) * 2;
         offset2 = ((offset_x/2) + ((dstPitch/2) * offset_y));
      } else {
         offset = ((offset_x*2) + (dstPitch * offset_y));
         offset2 = ((offset_x*2) + ((dstPitch/2) * offset_y));
      }

      /* buffer locations */
      pPriv->YBuf0offset += offset;
      pPriv->UBuf0offset += offset2;
      pPriv->VBuf0offset += offset2;

      if(pPriv->doubleBuffer) {
         pPriv->YBuf1offset += offset;
         pPriv->UBuf1offset += offset2;
         pPriv->VBuf1offset += offset2;
      }
   }

   if (pI830->rotation & (RR_Rotate_90 | RR_Rotate_270)) {
      tmp = width;
      width = height;
      height = tmp;
      tmp = drw_w;
      drw_w = drw_h;
      drw_h = tmp;
      tmp = src_w;
      src_w = src_h;
      src_h = tmp;
   }

   if (pPriv->oneLineMode) {
      /* change the coordinates with panel fitting active */
      dstBox->y1 = (((dstBox->y1 - 1) * pPriv->scaleRatio) >> 16) + 1;
      dstBox->y2 = ((dstBox->y2 * pPriv->scaleRatio) >> 16) + 1;
 
      /* Now, alter the height, so we scale to the correct size */
      drw_h = ((drw_h * pPriv->scaleRatio) >> 16) + 1;
   }

   {
      /* Keep the engine happy and clip to the real vertical size just
       * in case an LFP is in use and it's not at it's native resolution.
       */
      int vactive = pPriv->pipe ? (INREG(VTOTAL_B) & 0x7FF) : (INREG(VTOTAL_A) & 0x7FF);

      vactive += 1;

      if (dstBox->y1 < 0) dstBox->y1 = 0;
      if (dstBox->y2 < 0) dstBox->y2 = 0;
      if (dstBox->x1 < 0) dstBox->x1 = 0;
      if (dstBox->x2 < 0) dstBox->x2 = 0;
      if (dstBox->y1 > vactive) dstBox->y1 = vactive;
      if (dstBox->y2 > vactive) dstBox->y2 = vactive;
      if (dstBox->x1 > pScrn->currentMode->HDisplay) dstBox->x1 = pScrn->currentMode->HDisplay - 1;
      if (dstBox->x2 > pScrn->currentMode->HDisplay) dstBox->x2 = pScrn->currentMode->HDisplay - 1;

      /* nothing do to */
      if ((!dstBox->x1 && !dstBox->x2) || (!dstBox->y1 && !dstBox->y2)) {
         ErrorF("NOTHING TO DO\n");
         return;
      }
      if ((dstBox->x1 == (pScrn->currentMode->HDisplay - 1) && 
           dstBox->x2 == (pScrn->currentMode->HDisplay - 1)) || 
          (dstBox->y1 == vactive && 
           dstBox->y2 == vactive)) {
         ErrorF("NOTHING TO DO\n");
         return;
      }
      if ((dstBox->y2 - dstBox->y1) <= N_VERT_Y_TAPS) {
         ErrorF("NOTHING TO DO\n");
         return;
      }
      if ((dstBox->x2 - dstBox->x1) <= 2) {
         ErrorF("NOTHING TO DO\n");
         return;
      }
   }

   if (IS_I9XX(pI830)) {
      shift = 6;
      mask = 0x3f;
   } else {
      shift = 5;
      mask = 0x1f;
   }

   if (pPriv->currentBuf == 0) {
      offsety = pPriv->YBuf0offset;
      offsetu = pPriv->UBuf0offset;
   } else {
      offsety = pPriv->YBuf1offset;
      offsetu = pPriv->UBuf1offset;
   }

   switch (id) {
   case FOURCC_YV12:
   case FOURCC_I420:
      swidth = width;

      overlay->SWIDTH = swidth;
      swidth /= 2;
      overlay->SWIDTH |= (swidth & 0x7ff) << 16;

      swidth = ((offsety + width + mask) >> shift) -
	    (offsety >> shift);

      if (IS_I9XX(pI830))
         swidth <<= 1;

      swidth -= 1;

      ErrorF("Y width is %d, swidth is %d\n", width, swidth);

      overlay->SWIDTHSW = swidth << 2;

      swidth = ((offsetu + (width / 2) + mask) >> shift) -
	    (offsetu >> shift);

      if (IS_I9XX(pI830))
         swidth <<= 1;

      swidth -= 1;

      ErrorF("UV width is %d, swidthsw is %d\n", width / 2, swidth);

      overlay->SWIDTHSW |= swidth << 18;

      ErrorF("HEIGHT is %d\n",height);

      overlay->SHEIGHT = height | ((height / 2) << 16);
      break;
   case FOURCC_UYVY:
   case FOURCC_YUY2:
   default:
      swidth = width;
      overlay->SWIDTH = swidth;

      ErrorF("Y width is %d\n", swidth);

      swidth = ((offsety + (width << 1) + mask) >> shift) -
	    (offsety >> shift);

      if (IS_I9XX(pI830))
         swidth <<= 1;

      swidth -= 1;

      ErrorF("swidthsw is %d\n", swidth);

      overlay->SWIDTHSW = swidth << 2;

      ErrorF("HEIGHT is %d\n",height);

      overlay->SHEIGHT = height;
      break;
   }

   overlay->OCMD = OVERLAY_ENABLE;

   overlay->DWINPOS = (dstBox->y1 << 16) | dstBox->x1;

   overlay->DWINSZ = ((dstBox->y2 - dstBox->y1) << 16) |
	 (dstBox->x2 - dstBox->x1);

   ErrorF("dstBox: x1: %d, y1: %d, x2: %d, y2: %d\n", dstBox->x1, dstBox->y1,
			dstBox->x2, dstBox->y2);

   /* buffer locations */
   if (IS_I96X(pI830))
   {
      overlay->OBUF_0Y = 0;
      overlay->OBUF_0U = 0;
      overlay->OBUF_0V = 0;
      overlay->OSTART_0Y = pPriv->YBuf0offset;
      overlay->OSTART_0U = pPriv->UBuf0offset;
      overlay->OSTART_0V = pPriv->VBuf0offset;
      if(pPriv->doubleBuffer) {
         overlay->OBUF_1Y = 0;
         overlay->OBUF_1U = 0;
         overlay->OBUF_1V = 0;
         overlay->OSTART_1Y = pPriv->YBuf1offset;
         overlay->OSTART_1U = pPriv->UBuf1offset;
         overlay->OSTART_1V = pPriv->VBuf1offset;
      }
   } else {
      overlay->OBUF_0Y = pPriv->YBuf0offset;
      overlay->OBUF_0U = pPriv->UBuf0offset;
      overlay->OBUF_0V = pPriv->VBuf0offset;
      if(pPriv->doubleBuffer) {
         overlay->OBUF_1Y = pPriv->YBuf1offset;
         overlay->OBUF_1U = pPriv->UBuf1offset;
         overlay->OBUF_1V = pPriv->VBuf1offset;
      }
   }

   ErrorF("Buffers: Y0: 0x%lx, U0: 0x%lx, V0: 0x%lx\n", overlay->OBUF_0Y,
	  overlay->OBUF_0U, overlay->OBUF_0V);
   ErrorF("Buffers: Y1: 0x%lx, U1: 0x%lx, V1: 0x%lx\n", overlay->OBUF_1Y,
	  overlay->OBUF_1U, overlay->OBUF_1V);

#if 0
   {
      int i;

      ErrorF("First 32 bytes of Y data:\n");
      for (i = 0; i < 32; i++)
	 ErrorF(" %02x",
		((unsigned char *)pI830->FbBase + pPriv->YBuf0offset)[i]);
      ErrorF("\n");
      ErrorF("First 16 bytes of U data:\n");
      for (i = 0; i < 16; i++)
	 ErrorF(" %02x",
		((unsigned char *)pI830->FbBase + pPriv->UBuf0offset)[i]);
      ErrorF("\n");
      ErrorF("First 16 bytes of V data:\n");
      for (i = 0; i < 16; i++)
	 ErrorF(" %02x",
		((unsigned char *)pI830->FbBase + pPriv->VBuf0offset)[i]);
      ErrorF("\n");
   }
#endif

   ErrorF("pos: 0x%lx, size: 0x%lx\n", overlay->DWINPOS, overlay->DWINSZ);
   ErrorF("dst: %d x %d, src: %d x %d\n", drw_w, drw_h, src_w, src_h);

   /* 
    * Calculate horizontal and vertical scaling factors and polyphase
    * coefficients.
    */

   {
      Bool scaleChanged = FALSE;
      int xscaleInt, xscaleFract, yscaleInt, yscaleFract;
      int xscaleIntUV, xscaleFractUV;
      int yscaleIntUV, yscaleFractUV;
      /* UV is half the size of Y -- YUV420 */
      int uvratio = 2;
      CARD32 newval;
      coeffRec xcoeffY[N_HORIZ_Y_TAPS * N_PHASES];
      coeffRec xcoeffUV[N_HORIZ_UV_TAPS * N_PHASES];
      int i, j, pos;

      /*
       * Y down-scale factor as a multiple of 4096.
       */
      xscaleFract = ((src_w - 1) << 12) / drw_w;
      yscaleFract = ((src_h - 1) << 12) / drw_h;

      /* Calculate the UV scaling factor. */
      xscaleFractUV = xscaleFract / uvratio;
      yscaleFractUV = yscaleFract / uvratio;

      /*
       * To keep the relative Y and UV ratios exact, round the Y scales
       * to a multiple of the Y/UV ratio.
       */
      xscaleFract = xscaleFractUV * uvratio;
      yscaleFract = yscaleFractUV * uvratio;

      /* Integer (un-multiplied) values. */
      xscaleInt = xscaleFract >> 12;
      yscaleInt = yscaleFract >> 12;

      xscaleIntUV = xscaleFractUV >> 12;
      yscaleIntUV = yscaleFractUV >> 12;

      ErrorF("xscale: %x.%03x, yscale: %x.%03x\n", xscaleInt,
	     xscaleFract & 0xFFF, yscaleInt, yscaleFract & 0xFFF);
      ErrorF("UV xscale: %x.%03x, UV yscale: %x.%03x\n", xscaleIntUV,
	     xscaleFractUV & 0xFFF, yscaleIntUV, yscaleFractUV & 0xFFF);

      /* shouldn't get here */
      if (xscaleInt > 7) { 
         ErrorF("xscale: bad scale\n");
	 return;
      }

      /* shouldn't get here */
      if (xscaleIntUV > 7) { 
         ErrorF("xscaleUV: bad scale\n");
         return;
      }

      newval = (xscaleInt << 16) |
	    ((xscaleFract & 0xFFF) << 3) | ((yscaleFract & 0xFFF) << 20);
      if (newval != overlay->YRGBSCALE) {
	 scaleChanged = TRUE;
	 overlay->YRGBSCALE = newval;
      }

      newval = (xscaleIntUV << 16) | ((xscaleFractUV & 0xFFF) << 3) |
	    ((yscaleFractUV & 0xFFF) << 20);
      if (newval != overlay->UVSCALE) {
	 scaleChanged = TRUE;
	 overlay->UVSCALE = newval;
      }

      newval = yscaleInt << 16 | yscaleIntUV;
      if (newval != overlay->UVSCALEV) {
	 scaleChanged = TRUE;
	 overlay->UVSCALEV = newval;
      }

      /* Recalculate coefficients if the scaling changed. */

      /*
       * Only Horizontal coefficients so far.
       */
      if (scaleChanged) {
	 double fCutoffY;
	 double fCutoffUV;

	 fCutoffY = xscaleFract / 4096.0;
	 fCutoffUV = xscaleFractUV / 4096.0;

	 /* Limit to between 1.0 and 3.0. */
	 if (fCutoffY < MIN_CUTOFF_FREQ)
	    fCutoffY = MIN_CUTOFF_FREQ;
	 if (fCutoffY > MAX_CUTOFF_FREQ)
	    fCutoffY = MAX_CUTOFF_FREQ;
	 if (fCutoffUV < MIN_CUTOFF_FREQ)
	    fCutoffUV = MIN_CUTOFF_FREQ;
	 if (fCutoffUV > MAX_CUTOFF_FREQ)
	    fCutoffUV = MAX_CUTOFF_FREQ;

	 UpdateCoeff(N_HORIZ_Y_TAPS, fCutoffY, TRUE, TRUE, xcoeffY);
	 UpdateCoeff(N_HORIZ_UV_TAPS, fCutoffUV, TRUE, FALSE, xcoeffUV);

	 for (i = 0; i < N_PHASES; i++) {
	    for (j = 0; j < N_HORIZ_Y_TAPS; j++) {
	       pos = i * N_HORIZ_Y_TAPS + j;
	       overlay->Y_HCOEFS[pos] = xcoeffY[pos].sign << 15 |
					xcoeffY[pos].exponent << 12 |
					xcoeffY[pos].mantissa;
	    }
	 }
	 for (i = 0; i < N_PHASES; i++) {
	    for (j = 0; j < N_HORIZ_UV_TAPS; j++) {
	       pos = i * N_HORIZ_UV_TAPS + j;
	       overlay->UV_HCOEFS[pos] = xcoeffUV[pos].sign << 15 |
					 xcoeffUV[pos].exponent << 12 |
					 xcoeffUV[pos].mantissa;
	    }
	 }
      }
   }

   switch (id) {
   case FOURCC_YV12:
   case FOURCC_I420:
      ErrorF("YUV420\n");
#if 0
      /* set UV vertical phase to -0.25 */
      overlay->UV_VPH = 0x30003000;
#endif
      ErrorF("UV stride is %d, Y stride is %d\n", dstPitch, dstPitch * 2);
      overlay->OSTRIDE = (dstPitch * 2) | (dstPitch << 16);
      overlay->OCMD &= ~SOURCE_FORMAT;
      overlay->OCMD &= ~OV_BYTE_ORDER;
      overlay->OCMD |= YUV_420;
      break;
   case FOURCC_UYVY:
   case FOURCC_YUY2:
   default:
      ErrorF("YUV422\n");
      overlay->OSTRIDE = dstPitch;
      overlay->OCMD &= ~SOURCE_FORMAT;
      overlay->OCMD |= YUV_422;
      overlay->OCMD &= ~OV_BYTE_ORDER;
      if (id == FOURCC_UYVY)
	 overlay->OCMD |= Y_SWAP;
      break;
   }

   overlay->OCMD &= ~(BUFFER_SELECT | FIELD_SELECT);
   if (pPriv->currentBuf == 0)
      overlay->OCMD |= BUFFER0;
   else
      overlay->OCMD |= BUFFER1;

   ErrorF("OCMD is 0x%lx\n", overlay->OCMD);

   OVERLAY_UPDATE;
}

static const CARD32 sip_kernel_static[][4] = {
/*    wait (1) a0<1>UW a145<0,1,0>UW { align1 +  } */
    { 0x00000030, 0x20000108, 0x00001220, 0x00000000 },
/*    nop (4) g0<1>UD { align1 +  } */
    { 0x0040007e, 0x20000c21, 0x00690000, 0x00000000 },
/*    nop (4) g0<1>UD { align1 +  } */
    { 0x0040007e, 0x20000c21, 0x00690000, 0x00000000 },
/*    nop (4) g0<1>UD { align1 +  } */
    { 0x0040007e, 0x20000c21, 0x00690000, 0x00000000 },
/*    nop (4) g0<1>UD { align1 +  } */
    { 0x0040007e, 0x20000c21, 0x00690000, 0x00000000 },
/*    nop (4) g0<1>UD { align1 +  } */
    { 0x0040007e, 0x20000c21, 0x00690000, 0x00000000 },
/*    nop (4) g0<1>UD { align1 +  } */
    { 0x0040007e, 0x20000c21, 0x00690000, 0x00000000 },
/*    nop (4) g0<1>UD { align1 +  } */
    { 0x0040007e, 0x20000c21, 0x00690000, 0x00000000 },
/*    nop (4) g0<1>UD { align1 +  } */
    { 0x0040007e, 0x20000c21, 0x00690000, 0x00000000 },
/*    nop (4) g0<1>UD { align1 +  } */
    { 0x0040007e, 0x20000c21, 0x00690000, 0x00000000 },
};
   
/*
 * this program computes dA/dx and dA/dy for the texture coordinates along
 * with the base texture coordinate. It was extracted from the Mesa driver.
 * It uses about 10 GRF registers.
 */

#define SF_KERNEL_NUM_GRF  16
#define SF_MAX_THREADS	   1

static const CARD32 sf_kernel_static[][4] = {
#include "sf_prog.h"
};
d1683 3
a1685 3
 * Ok, this kernel picks up the required data flow values in g0 and g1
 * and passes those along in m0 and m1. In m2-m9, it sticks constant
 * values (bright pink).
d1688 37
a1724 19
/* Our PS kernel uses less than 32 GRF registers (about 20) */
#define PS_KERNEL_NUM_GRF   32
#define PS_MAX_THREADS	   32

#define BRW_GRF_BLOCKS(nreg)	((nreg + 15) / 16 - 1)

static const CARD32 ps_kernel_static[][4] = {
#include "wm_prog.h"
};

#define ALIGN(i,m)    (((i) + (m) - 1) & ~((m) - 1))
#define MIN(a,b) ((a) < (b) ? (a) : (b))

#define WM_BINDING_TABLE_ENTRIES    2

static CARD32 float_to_uint (float f) {
   union {CARD32 i; float f;} x;
   x.f = f;
   return x.i;
d1727 3
a1729 16
#if 0
static struct {
   CARD32   svg_ctl;
   char	    *name;
} svg_ctl_bits[] = {
   { BRW_SVG_CTL_GS_BA, "General State Base Address" },
   { BRW_SVG_CTL_SS_BA, "Surface State Base Address" },
   { BRW_SVG_CTL_IO_BA, "Indirect Object Base Address" },
   { BRW_SVG_CTL_GS_AUB, "Generate State Access Upper Bound" },
   { BRW_SVG_CTL_IO_AUB, "Indirect Object Access Upper Bound" },
   { BRW_SVG_CTL_SIP, "System Instruction Pointer" },
   { 0, 0 },
};

static void
brw_debug (ScrnInfoPtr pScrn, char *when)
d1731 5
a1735 11
   I830Ptr pI830 = I830PTR(pScrn);
   int	    i;
   CARD32   v;
   
   I830Sync (pScrn);
   ErrorF("brw_debug: %s\n", when);
   for (i = 0; svg_ctl_bits[i].name; i++) {
      OUTREG(BRW_SVG_CTL, svg_ctl_bits[i].svg_ctl);
      v = INREG(BRW_SVG_RDATA);
      ErrorF("\t%34.34s: 0x%08x\n", svg_ctl_bits[i].name, v);
   }
a1736 5
#endif

#define WATCH_SF 0
#define WATCH_WIZ 0
#define WATCH_STATS 0
d1739 13
a1751 39
BroadwaterDisplayVideoTextured(ScrnInfoPtr pScrn, I830PortPrivPtr pPriv, int id,
			       RegionPtr dstRegion,
			       short width, short height, int video_pitch,
			       int x1, int y1, int x2, int y2,
			       short src_w, short src_h,
			       short drw_w, short drw_h,
			       DrawablePtr pDraw)
{
   I830Ptr pI830 = I830PTR(pScrn);
   BoxPtr pbox;
   int nbox, dxo, dyo;
   int urb_vs_start, urb_vs_size;
   int urb_gs_start, urb_gs_size;
   int urb_clip_start, urb_clip_size;
   int urb_sf_start, urb_sf_size;
   int urb_cs_start, urb_cs_size;
   struct brw_surface_state *dest_surf_state;
   struct brw_surface_state *src_surf_state;
   struct brw_sampler_state *src_sampler_state;
   struct brw_vs_unit_state *vs_state;
   struct brw_sf_unit_state *sf_state;
   struct brw_wm_unit_state *wm_state;
   struct brw_cc_unit_state *cc_state;
   struct brw_cc_viewport *cc_viewport;
   struct brw_instruction *sf_kernel;
   struct brw_instruction *ps_kernel;
   struct brw_instruction *sip_kernel;
   float *vb;
    CARD32 *binding_table;
   Bool first_output = TRUE;
   int dest_surf_offset, src_surf_offset, src_sampler_offset, vs_offset;
   int sf_offset, wm_offset, cc_offset, vb_offset, cc_viewport_offset;
   int wm_scratch_offset;
   int sf_kernel_offset, ps_kernel_offset, sip_kernel_offset;
   int binding_table_offset;
   int next_offset, total_state_size;
   int vb_size = (4 * 4) * 4; /* 4 DWORDS per vertex */
   char *state_base;
   int state_base_offset;
d1753 2
a1754 4
#if 0
   ErrorF("BroadwaterDisplayVideoTextured: %dx%d (pitch %d)\n", width, height,
	  video_pitch);
#endif
d1756 2
a1757 6
   /* enable debug */
   OUTREG (INST_PM,
	   (1 << (16 + 4)) |
	   (1 << 4));
#if 0
   ErrorF ("INST_PM 0x%08x\n", INREG(INST_PM));
d1759 273
a2031 2
   
   assert((id == FOURCC_UYVY) || (id == FOURCC_YUY2));
d2033 44
a2076 10
   /* Tell the rotation code that we have stomped its invariant state by
    * setting a high bit.  We don't use any invariant 3D state for video, so we
    * don't have to worry about it ourselves.
    */
   *pI830->used3D |= 1 << 30;

#ifdef XF86DRI
   /* Tell the DRI that we're smashing its state. */
   if (pI830->directRenderingEnabled) {
     drmI830Sarea *pSAREAPriv = DRIGetSAREAPrivate(pScrn->pScreen);
d2078 43
a2120 3
     pSAREAPriv->ctxOwner = DRIGetContext(pScrn->pScreen);
   }
#endif /* XF86DRI */
d2122 17
a2138 91
   next_offset = 0;

   /* Set up our layout of state in framebuffer.  First the general state: */
   vs_offset = ALIGN(next_offset, 64);
   next_offset = vs_offset + sizeof(*vs_state);
   sf_offset = ALIGN(next_offset, 32);
   next_offset = sf_offset + sizeof(*sf_state);
   wm_offset = ALIGN(next_offset, 32);
   next_offset = wm_offset + sizeof(*wm_state);
   wm_scratch_offset = ALIGN(next_offset, 1024);
   next_offset = wm_scratch_offset + 1024 * PS_MAX_THREADS;
   cc_offset = ALIGN(next_offset, 32);
   next_offset = cc_offset + sizeof(*cc_state);

   sf_kernel_offset = ALIGN(next_offset, 64);
   next_offset = sf_kernel_offset + sizeof (sf_kernel_static);
   ps_kernel_offset = ALIGN(next_offset, 64);
   next_offset = ps_kernel_offset + sizeof (ps_kernel_static);
   sip_kernel_offset = ALIGN(next_offset, 64);
   next_offset = sip_kernel_offset + sizeof (sip_kernel_static);
   cc_viewport_offset = ALIGN(next_offset, 32);
   next_offset = cc_viewport_offset + sizeof(*cc_viewport);

   src_sampler_offset = ALIGN(next_offset, 32);
   next_offset = src_sampler_offset + sizeof(*src_sampler_state);

   /* Align VB to native size of elements, for safety */
   vb_offset = ALIGN(next_offset, 8);
   next_offset = vb_offset + vb_size;

   /* And then the general state: */
   dest_surf_offset = ALIGN(next_offset, 32);
   next_offset = dest_surf_offset + sizeof(*dest_surf_state);
   src_surf_offset = ALIGN(next_offset, 32);
   next_offset = src_surf_offset + sizeof(*src_surf_state);
   binding_table_offset = ALIGN(next_offset, 32);
   next_offset = binding_table_offset + (WM_BINDING_TABLE_ENTRIES * 4);

   /* Allocate an area in framebuffer for our state layout we just set up */
   total_state_size = next_offset;
   assert (total_state_size < BRW_LINEAR_EXTRA);

   /*
    * Use the extra space allocated at the end of the Xv buffer
    */
   state_base_offset = (pPriv->YBuf0offset + 
			pPriv->linear->size * pI830->cpp -
			BRW_LINEAR_EXTRA);
   state_base_offset = ALIGN(state_base_offset, 64);

   state_base = (char *)(pI830->FbBase + state_base_offset);
   /* Set up our pointers to state structures in framebuffer.  It would probably
    * be a good idea to fill these structures out in system memory and then dump
    * them there, instead.
    */
   vs_state = (void *)(state_base + vs_offset);
   sf_state = (void *)(state_base + sf_offset);
   wm_state = (void *)(state_base + wm_offset);
   cc_state = (void *)(state_base + cc_offset);
   sf_kernel = (void *)(state_base + sf_kernel_offset);
   ps_kernel = (void *)(state_base + ps_kernel_offset);
   sip_kernel = (void *)(state_base + sip_kernel_offset);
   
   cc_viewport = (void *)(state_base + cc_viewport_offset);
   dest_surf_state = (void *)(state_base + dest_surf_offset);
   src_surf_state = (void *)(state_base + src_surf_offset);
   src_sampler_state = (void *)(state_base + src_sampler_offset);
   binding_table = (void *)(state_base + binding_table_offset);
   vb = (void *)(state_base + vb_offset);

   /* For 3D, the VS must have 8, 12, 16, 24, or 32 VUEs allocated to it.
    * A VUE consists of a 256-bit vertex header followed by the vertex data,
    * which in our case is 4 floats (128 bits), thus a single 512-bit URB
    * entry.
    */
#define URB_VS_ENTRIES	      8
#define URB_VS_ENTRY_SIZE     1
   
#define URB_GS_ENTRIES	      0
#define URB_GS_ENTRY_SIZE     0
   
#define URB_CLIP_ENTRIES      0
#define URB_CLIP_ENTRY_SIZE   0
   
   /* The SF kernel we use outputs only 4 256-bit registers, leading to an
    * entry size of 2 512-bit URBs.  We don't need to have many entries to
    * output as we're generally working on large rectangles and don't care
    * about having WM threads running on different rectangles simultaneously.
    */
#define URB_SF_ENTRIES	      1
#define URB_SF_ENTRY_SIZE     2
d2140 1
a2140 184
#define URB_CS_ENTRIES	      0
#define URB_CS_ENTRY_SIZE     0
   
   urb_vs_start = 0;
   urb_vs_size = URB_VS_ENTRIES * URB_VS_ENTRY_SIZE;
   urb_gs_start = urb_vs_start + urb_vs_size;
   urb_gs_size = URB_GS_ENTRIES * URB_GS_ENTRY_SIZE;
   urb_clip_start = urb_gs_start + urb_gs_size;
   urb_clip_size = URB_CLIP_ENTRIES * URB_CLIP_ENTRY_SIZE;
   urb_sf_start = urb_clip_start + urb_clip_size;
   urb_sf_size = URB_SF_ENTRIES * URB_SF_ENTRY_SIZE;
   urb_cs_start = urb_sf_start + urb_sf_size;
   urb_cs_size = URB_CS_ENTRIES * URB_CS_ENTRY_SIZE;

   /* We'll be poking the state buffers that could be in use by the 3d hardware
    * here, but we should have synced the 3D engine already in I830PutImage.
    */

   memset (cc_viewport, 0, sizeof (*cc_viewport));
   cc_viewport->min_depth = -1.e35;
   cc_viewport->max_depth = 1.e35;

   /* Color calculator state */
   memset(cc_state, 0, sizeof(*cc_state));
   cc_state->cc0.stencil_enable = 0;   /* disable stencil */
   cc_state->cc2.depth_test = 0;       /* disable depth test */
   cc_state->cc2.logicop_enable = 1;   /* enable logic op */
   cc_state->cc3.ia_blend_enable = 1;  /* blend alpha just like colors */
   cc_state->cc3.blend_enable = 0;     /* disable color blend */
   cc_state->cc3.alpha_test = 0;       /* disable alpha test */
   cc_state->cc4.cc_viewport_state_offset = (state_base_offset + cc_viewport_offset) >> 5;
   cc_state->cc5.dither_enable = 0;    /* disable dither */
   cc_state->cc5.logicop_func = 0xc;   /* WHITE */
   cc_state->cc5.statistics_enable = 1;
   cc_state->cc5.ia_blend_function = BRW_BLENDFUNCTION_ADD;
   cc_state->cc5.ia_src_blend_factor = BRW_BLENDFACTOR_ONE;
   cc_state->cc5.ia_dest_blend_factor = BRW_BLENDFACTOR_ONE;

   /* Upload system kernel */
   memcpy (sip_kernel, sip_kernel_static, sizeof (sip_kernel_static));
   
   /* Set up the state buffer for the destination surface */
   memset(dest_surf_state, 0, sizeof(*dest_surf_state));
   dest_surf_state->ss0.surface_type = BRW_SURFACE_2D;
   dest_surf_state->ss0.data_return_format = BRW_SURFACERETURNFORMAT_FLOAT32;
   if (pI830->cpp == 2) {
      dest_surf_state->ss0.surface_format = BRW_SURFACEFORMAT_B5G6R5_UNORM;
   } else {
      dest_surf_state->ss0.surface_format = BRW_SURFACEFORMAT_B8G8R8A8_UNORM;
   }
   dest_surf_state->ss0.writedisable_alpha = 0;
   dest_surf_state->ss0.writedisable_red = 0;
   dest_surf_state->ss0.writedisable_green = 0;
   dest_surf_state->ss0.writedisable_blue = 0;
   dest_surf_state->ss0.color_blend = 1;
   dest_surf_state->ss0.vert_line_stride = 0;
   dest_surf_state->ss0.vert_line_stride_ofs = 0;
   dest_surf_state->ss0.mipmap_layout_mode = 0;
   dest_surf_state->ss0.render_cache_read_mode = 0;
   
   dest_surf_state->ss1.base_addr = pI830->FrontBuffer.Start;
   dest_surf_state->ss2.height = pScrn->virtualY - 1;
   dest_surf_state->ss2.width = pScrn->virtualX - 1;
   dest_surf_state->ss2.mip_count = 0;
   dest_surf_state->ss2.render_target_rotation = 0;
   dest_surf_state->ss3.pitch = (pI830->displayWidth * pI830->cpp) - 1;

   /* Set up the source surface state buffer */
   memset(src_surf_state, 0, sizeof(*src_surf_state));
   src_surf_state->ss0.surface_type = BRW_SURFACE_2D;
/*   src_surf_state->ss0.data_return_format = BRW_SURFACERETURNFORMAT_FLOAT32; */
   switch (id) {
   case FOURCC_YUY2:
      src_surf_state->ss0.surface_format = BRW_SURFACEFORMAT_YCRCB_NORMAL;
      break;
   case FOURCC_UYVY:
      src_surf_state->ss0.surface_format = BRW_SURFACEFORMAT_YCRCB_SWAPY;
      break;
   }
   src_surf_state->ss0.writedisable_alpha = 0;
   src_surf_state->ss0.writedisable_red = 0;
   src_surf_state->ss0.writedisable_green = 0;
   src_surf_state->ss0.writedisable_blue = 0;
   src_surf_state->ss0.color_blend = 1;
   src_surf_state->ss0.vert_line_stride = 0;
   src_surf_state->ss0.vert_line_stride_ofs = 0;
   src_surf_state->ss0.mipmap_layout_mode = 0;
   src_surf_state->ss0.render_cache_read_mode = 0;
   
   src_surf_state->ss1.base_addr = pPriv->YBuf0offset;
   src_surf_state->ss2.width = width - 1;
   src_surf_state->ss2.height = height - 1;
   src_surf_state->ss2.mip_count = 0;
   src_surf_state->ss2.render_target_rotation = 0;
   src_surf_state->ss3.pitch = video_pitch - 1;

   /* Set up a binding table for our two surfaces.  Only the PS will use it */
   /* XXX: are these offset from the right place? */
   binding_table[0] = state_base_offset + dest_surf_offset;
   binding_table[1] = state_base_offset + src_surf_offset;

   /* Set up the packed YUV source sampler.  Doesn't do colorspace conversion.
    */
   memset(src_sampler_state, 0, sizeof(*src_sampler_state));
   src_sampler_state->ss0.min_filter = BRW_MAPFILTER_LINEAR;
   src_sampler_state->ss0.mag_filter = BRW_MAPFILTER_LINEAR;
   src_sampler_state->ss1.r_wrap_mode = BRW_TEXCOORDMODE_CLAMP;
   src_sampler_state->ss1.s_wrap_mode = BRW_TEXCOORDMODE_CLAMP;
   src_sampler_state->ss1.t_wrap_mode = BRW_TEXCOORDMODE_CLAMP;

   /* Set up the vertex shader to be disabled (passthrough) */
   memset(vs_state, 0, sizeof(*vs_state));
   vs_state->thread4.nr_urb_entries = URB_VS_ENTRIES;
   vs_state->thread4.urb_entry_allocation_size = URB_VS_ENTRY_SIZE - 1;
   vs_state->vs6.vs_enable = 0;
   vs_state->vs6.vert_cache_disable = 1;

   /* Set up the SF kernel to do coord interp: for each attribute,
    * calculate dA/dx and dA/dy.  Hand these interpolation coefficients
    * back to SF which then hands pixels off to WM.
    */

   memcpy (sf_kernel, sf_kernel_static, sizeof (sf_kernel_static));
   memset(sf_state, 0, sizeof(*sf_state));
#if 0
   ErrorF ("sf kernel: 0x%08x\n", state_base_offset + sf_kernel_offset);
#endif
   sf_state->thread0.kernel_start_pointer = 
	       (state_base_offset + sf_kernel_offset) >> 6;
   sf_state->thread0.grf_reg_count = BRW_GRF_BLOCKS(SF_KERNEL_NUM_GRF);
   sf_state->sf1.single_program_flow = 1; /* XXX */
   sf_state->sf1.binding_table_entry_count = 0;
   sf_state->sf1.thread_priority = 0;
   sf_state->sf1.floating_point_mode = 0; /* Mesa does this */
   sf_state->sf1.illegal_op_exception_enable = 1;
   sf_state->sf1.mask_stack_exception_enable = 1;
   sf_state->sf1.sw_exception_enable = 1;
   sf_state->thread2.per_thread_scratch_space = 0;
   sf_state->thread2.scratch_space_base_pointer = 0; /* not used in our kernel */
   sf_state->thread3.const_urb_entry_read_length = 0; /* no const URBs */
   sf_state->thread3.const_urb_entry_read_offset = 0; /* no const URBs */
   sf_state->thread3.urb_entry_read_length = 1; /* 1 URB per vertex */
   sf_state->thread3.urb_entry_read_offset = 0;
   sf_state->thread3.dispatch_grf_start_reg = 3;
   sf_state->thread4.max_threads = SF_MAX_THREADS - 1;
   sf_state->thread4.urb_entry_allocation_size = URB_SF_ENTRY_SIZE - 1;
   sf_state->thread4.nr_urb_entries = URB_SF_ENTRIES;
   sf_state->thread4.stats_enable = 1;
   sf_state->sf5.viewport_transform = FALSE; /* skip viewport */
   sf_state->sf6.cull_mode = BRW_CULLMODE_NONE;
   sf_state->sf6.scissor = 0;
   sf_state->sf7.trifan_pv = 2;
   sf_state->sf6.dest_org_vbias = 0x8;
   sf_state->sf6.dest_org_hbias = 0x8;

   memcpy (ps_kernel, ps_kernel_static, sizeof (ps_kernel_static));
#if 0
   ErrorF ("ps kernel: 0x%08x\n", state_base_offset + ps_kernel_offset);
#endif
   memset (wm_state, 0, sizeof (*wm_state));
   wm_state->thread0.kernel_start_pointer = 
	    (state_base_offset + ps_kernel_offset) >> 6;
   wm_state->thread0.grf_reg_count = BRW_GRF_BLOCKS(PS_KERNEL_NUM_GRF);
   wm_state->thread1.single_program_flow = 1; /* XXX */
   wm_state->thread1.binding_table_entry_count = 2;
   /* Though we never use the scratch space in our WM kernel, it has to be
    * set, and the minimum allocation is 1024 bytes.
    */
   wm_state->thread2.scratch_space_base_pointer = (state_base_offset +
						   wm_scratch_offset) >> 10;
   wm_state->thread2.per_thread_scratch_space = 0; /* 1024 bytes */
   wm_state->thread3.dispatch_grf_start_reg = 3; /* XXX */
   wm_state->thread3.const_urb_entry_read_length = 0;
   wm_state->thread3.const_urb_entry_read_offset = 0;
   wm_state->thread3.urb_entry_read_length = 1; /* XXX */
   wm_state->thread3.urb_entry_read_offset = 0; /* XXX */
   wm_state->wm4.stats_enable = 1;
   wm_state->wm4.sampler_state_pointer = (state_base_offset + src_sampler_offset) >> 5;
   wm_state->wm4.sampler_count = 1; /* 1-4 samplers used */
   wm_state->wm5.max_threads = PS_MAX_THREADS - 1;
   wm_state->wm5.thread_dispatch_enable = 1;
   wm_state->wm5.enable_16_pix = 1;
   wm_state->wm5.enable_8_pix = 0;
   wm_state->wm5.early_depth_test = 1;
d2142 1
d2144 4
a2147 6
      BEGIN_LP_RING(2);
      OUT_RING(MI_FLUSH | 
	       MI_STATE_INSTRUCTION_CACHE_FLUSH |
	       BRW_MI_GLOBAL_SNAPSHOT_RESET);
      OUT_RING(MI_NOOP);
      ADVANCE_LP_RING();
d2150 1
a2150 9
/*    brw_debug (pScrn, "before base address modify"); */
   { BEGIN_LP_RING(12);
   /* Match Mesa driver setup */
   OUT_RING(BRW_PIPELINE_SELECT | PIPELINE_SELECT_3D);

   /* Mesa does this. Who knows... */
   OUT_RING(BRW_CS_URB_STATE | 0);
   OUT_RING((0 << 4) |	/* URB Entry Allocation Size */
	    (0 << 0));	/* Number of URB Entries */
d2152 2
a2153 363
   /* Zero out the two base address registers so all offsets are absolute */
   OUT_RING(BRW_STATE_BASE_ADDRESS | 4);
   OUT_RING(0 | BASE_ADDRESS_MODIFY);  /* Generate state base address */
   OUT_RING(0 | BASE_ADDRESS_MODIFY);  /* Surface state base address */
   OUT_RING(0 | BASE_ADDRESS_MODIFY);  /* media base addr, don't care */
   OUT_RING(0x10000000 | BASE_ADDRESS_MODIFY);  /* general state max addr, disabled */
   OUT_RING(0x10000000 | BASE_ADDRESS_MODIFY);  /* media object state max addr, disabled */

   /* Set system instruction pointer */
   OUT_RING(BRW_STATE_SIP | 0);
   OUT_RING(state_base_offset + sip_kernel_offset); /* system instruction pointer */
      
   OUT_RING(MI_NOOP);
   ADVANCE_LP_RING(); }
   
/*   brw_debug (pScrn, "after base address modify"); */

   { BEGIN_LP_RING(42);
   /* Enable VF statistics */
   OUT_RING(BRW_3DSTATE_VF_STATISTICS | 1);
   
   /* Pipe control */
   OUT_RING(BRW_PIPE_CONTROL |
	    BRW_PIPE_CONTROL_NOWRITE |
	    BRW_PIPE_CONTROL_IS_FLUSH |
	    2);
   OUT_RING(0);			       /* Destination address */
   OUT_RING(0);			       /* Immediate data low DW */
   OUT_RING(0);			       /* Immediate data high DW */

   /* Binding table pointers */
   OUT_RING(BRW_3DSTATE_BINDING_TABLE_POINTERS | 4);
   OUT_RING(0); /* vs */
   OUT_RING(0); /* gs */
   OUT_RING(0); /* clip */
   OUT_RING(0); /* sf */
   /* Only the PS uses the binding table */
   OUT_RING(state_base_offset + binding_table_offset); /* ps */
   
   /* Blend constant color (magenta is fun) */
   OUT_RING(BRW_3DSTATE_CONSTANT_COLOR | 3);
   OUT_RING(float_to_uint (1.0));
   OUT_RING(float_to_uint (0.0));
   OUT_RING(float_to_uint (1.0));
   OUT_RING(float_to_uint (1.0));
   
   /* The drawing rectangle clipping is always on.  Set it to values that
    * shouldn't do any clipping.
    */
   OUT_RING(BRW_3DSTATE_DRAWING_RECTANGLE | 2);	/* XXX 3 for BLC or CTG */
   OUT_RING(0x00000000);	/* ymin, xmin */
   OUT_RING((pScrn->virtualX - 1) |
	    (pScrn->virtualY - 1) << 16); /* ymax, xmax */
   OUT_RING(0x00000000);	/* yorigin, xorigin */

   /* skip the depth buffer */
   /* skip the polygon stipple */
   /* skip the polygon stipple offset */
   /* skip the line stipple */
   
   /* Set the pointers to the 3d pipeline state */
   OUT_RING(BRW_3DSTATE_PIPELINED_POINTERS | 5);
   OUT_RING(state_base_offset + vs_offset);  /* 32 byte aligned */
   OUT_RING(BRW_GS_DISABLE);		     /* disable GS, resulting in passthrough */
   OUT_RING(BRW_CLIP_DISABLE);		     /* disable CLIP, resulting in passthrough */
   OUT_RING(state_base_offset + sf_offset);  /* 32 byte aligned */
   OUT_RING(state_base_offset + wm_offset);  /* 32 byte aligned */
   OUT_RING(state_base_offset + cc_offset);  /* 64 byte aligned */

   /* URB fence */
   OUT_RING(BRW_URB_FENCE |
	    UF0_CS_REALLOC |
	    UF0_SF_REALLOC |
	    UF0_CLIP_REALLOC |
	    UF0_GS_REALLOC |
	    UF0_VS_REALLOC |
	    1);
   OUT_RING(((urb_clip_start + urb_clip_size) << UF1_CLIP_FENCE_SHIFT) |
	    ((urb_gs_start + urb_gs_size) << UF1_GS_FENCE_SHIFT) |
	    ((urb_vs_start + urb_vs_size) << UF1_VS_FENCE_SHIFT));
   OUT_RING(((urb_cs_start + urb_cs_size) << UF2_CS_FENCE_SHIFT) |
	    ((urb_sf_start + urb_sf_size) << UF2_SF_FENCE_SHIFT));

   /* Constant buffer state */
   OUT_RING(BRW_CS_URB_STATE | 0);
   OUT_RING(((URB_CS_ENTRY_SIZE - 1) << 4) | /* URB Entry Allocation Size */
	    (URB_CS_ENTRIES << 0));	     /* Number of URB Entries */
   
   /* Set up the pointer to our vertex buffer */
   OUT_RING(BRW_3DSTATE_VERTEX_BUFFERS | 2);
   OUT_RING((0 << VB0_BUFFER_INDEX_SHIFT) |
	    VB0_VERTEXDATA |
	    ((4 * 4) << VB0_BUFFER_PITCH_SHIFT)); /* four 32-bit floats per vertex */
   OUT_RING(state_base_offset + vb_offset);
   OUT_RING(3); /* four corners to our rectangle */

   /* Set up our vertex elements, sourced from the single vertex buffer. */
   OUT_RING(BRW_3DSTATE_VERTEX_ELEMENTS | 3);
   /* offset 0: X,Y -> {X, Y, 1.0, 1.0} */
   OUT_RING((0 << VE0_VERTEX_BUFFER_INDEX_SHIFT) |
	    VE0_VALID |
	    (BRW_SURFACEFORMAT_R32G32_FLOAT << VE0_FORMAT_SHIFT) |
	    (0 << VE0_OFFSET_SHIFT));
   OUT_RING((BRW_VFCOMPONENT_STORE_SRC << VE1_VFCOMPONENT_0_SHIFT) |
	    (BRW_VFCOMPONENT_STORE_SRC << VE1_VFCOMPONENT_1_SHIFT) |
	    (BRW_VFCOMPONENT_STORE_1_FLT << VE1_VFCOMPONENT_2_SHIFT) |
	    (BRW_VFCOMPONENT_STORE_1_FLT << VE1_VFCOMPONENT_3_SHIFT) |
	    (0 << VE1_DESTINATION_ELEMENT_OFFSET_SHIFT));
   /* offset 8: S0, T0 -> {S0, T0, 1.0, 1.0} */
   OUT_RING((0 << VE0_VERTEX_BUFFER_INDEX_SHIFT) |
	    VE0_VALID |
	    (BRW_SURFACEFORMAT_R32G32_FLOAT << VE0_FORMAT_SHIFT) |
	    (8 << VE0_OFFSET_SHIFT));
   OUT_RING((BRW_VFCOMPONENT_STORE_SRC << VE1_VFCOMPONENT_0_SHIFT) |
	    (BRW_VFCOMPONENT_STORE_SRC << VE1_VFCOMPONENT_1_SHIFT) |
	    (BRW_VFCOMPONENT_STORE_1_FLT << VE1_VFCOMPONENT_2_SHIFT) |
	    (BRW_VFCOMPONENT_STORE_1_FLT << VE1_VFCOMPONENT_3_SHIFT) |
	    (4 << VE1_DESTINATION_ELEMENT_OFFSET_SHIFT));

   OUT_RING(MI_NOOP);			/* pad to quadword */
   ADVANCE_LP_RING(); }

   dxo = dstRegion->extents.x1;
   dyo = dstRegion->extents.y1;

   pbox = REGION_RECTS(dstRegion);
   nbox = REGION_NUM_RECTS(dstRegion);
   while (nbox--)
   {
      int box_x1 = pbox->x1;
      int box_y1 = pbox->y1;
      int box_x2 = pbox->x2;
      int box_y2 = pbox->y2;
      int i;
      float src_scale_x, src_scale_y;

      if (!first_output) {
	 /* Since we use the same little vertex buffer over and over, sync for
	  * subsequent rectangles.
	  */
	 if (pI830->AccelInfoRec && pI830->AccelInfoRec->NeedToSync) {
	    (*pI830->AccelInfoRec->Sync)(pScrn);
	    pI830->AccelInfoRec->NeedToSync = FALSE;
	 }
      }

      pbox++;

      /* Use normalized texture coordinates */
      src_scale_x = (float)1.0 / (float)drw_w;
      src_scale_y  = (float)1.0 / (float)drw_h;

      i = 0;
      vb[i++] = (box_x2 - dxo) * src_scale_x;
      vb[i++] = (box_y2 - dyo) * src_scale_y;
      vb[i++] = (float) box_x2;
      vb[i++] = (float) box_y2;

      vb[i++] = (box_x1 - dxo) * src_scale_x;
      vb[i++] = (box_y2 - dyo) * src_scale_y;
      vb[i++] = (float) box_x1;
      vb[i++] = (float) box_y2;

      vb[i++] = (box_x1 - dxo) * src_scale_x;
      vb[i++] = (box_y1 - dyo) * src_scale_y;
      vb[i++] = (float) box_x1;
      vb[i++] = (float) box_y1;

#if 0
      ErrorF ("before EU_ATT 0x%08x%08x EU_ATT_DATA 0x%08x%08x\n",
	      INREG(BRW_EU_ATT_1), INREG(BRW_EU_ATT_0),
	      INREG(BRW_EU_ATT_DATA_1), INREG(BRW_EU_ATT_DATA_0));

      OUTREG(BRW_VF_CTL,
	     BRW_VF_CTL_SNAPSHOT_MUX_SELECT_THREADID |
	     BRW_VF_CTL_SNAPSHOT_TYPE_VERTEX_INDEX |
	     BRW_VF_CTL_SNAPSHOT_ENABLE);
      OUTREG(BRW_VF_STRG_VAL, 0);
#endif
      
#if 0
      OUTREG(BRW_VS_CTL,
	     BRW_VS_CTL_SNAPSHOT_ALL_THREADS |
	     BRW_VS_CTL_SNAPSHOT_MUX_VALID_COUNT |
	     BRW_VS_CTL_THREAD_SNAPSHOT_ENABLE);
      
      OUTREG(BRW_VS_STRG_VAL, 0);
#endif
      
#if WATCH_SF
      OUTREG(BRW_SF_CTL,
	     BRW_SF_CTL_SNAPSHOT_MUX_VERTEX_COUNT |
	     BRW_SF_CTL_SNAPSHOT_ALL_THREADS |
	     BRW_SF_CTL_THREAD_SNAPSHOT_ENABLE);
      OUTREG(BRW_SF_STRG_VAL, 0);
#endif

#if WATCH_WIZ
      OUTREG(BRW_WIZ_CTL,
	     BRW_WIZ_CTL_SNAPSHOT_MUX_SUBSPAN_INSTANCE |
	     BRW_WIZ_CTL_SNAPSHOT_ALL_THREADS |
	     BRW_WIZ_CTL_SNAPSHOT_ENABLE);
      OUTREG(BRW_WIZ_STRG_VAL,
	     (box_x1) | (box_y1 << 16));
#endif
      
#if 0
      OUTREG(BRW_TS_CTL,
	     BRW_TS_CTL_SNAPSHOT_MESSAGE_ERROR |
	     BRW_TS_CTL_SNAPSHOT_ALL_CHILD_THREADS |
	     BRW_TS_CTL_SNAPSHOT_ALL_ROOT_THREADS |
	     BRW_TS_CTL_SNAPSHOT_ENABLE);
#endif

      BEGIN_LP_RING(6);
      OUT_RING(BRW_3DPRIMITIVE | 
	       BRW_3DPRIMITIVE_VERTEX_SEQUENTIAL |
	       (_3DPRIM_RECTLIST << BRW_3DPRIMITIVE_TOPOLOGY_SHIFT) | 
	       (0 << 9) |  /* CTG - indirect vertex count */
	       4);
      OUT_RING(3); /* vertex count per instance */
      OUT_RING(0); /* start vertex offset */
      OUT_RING(1); /* single instance */
      OUT_RING(0); /* start instance location */
      OUT_RING(0); /* index buffer offset, ignored */
      ADVANCE_LP_RING();

#if 0
      for (j = 0; j < 100000; j++) {
	ctl = INREG(BRW_VF_CTL);
	 if (ctl & BRW_VF_CTL_SNAPSHOT_COMPLETE)
	    break;
      }
      
      rdata = INREG(BRW_VF_RDATA);
      OUTREG(BRW_VF_CTL, 0);
      ErrorF ("VF_CTL: 0x%08x VF_RDATA: 0x%08x\n", ctl, rdata);
#endif

#if 0
      for (j = 0; j < 1000000; j++) {
	ctl = INREG(BRW_VS_CTL);
	 if (ctl & BRW_VS_CTL_SNAPSHOT_COMPLETE)
	    break;
      }

      rdata = INREG(BRW_VS_RDATA);
      for (k = 0; k <= 3; k++) {
	 OUTREG(BRW_VS_CTL,
		BRW_VS_CTL_SNAPSHOT_COMPLETE |
		(k << 8));
	 rdata = INREG(BRW_VS_RDATA);
	 ErrorF ("VS_CTL: 0x%08x VS_RDATA(%d): 0x%08x\n", ctl, k, rdata);
      }
      
      OUTREG(BRW_VS_CTL, 0);
#endif

#if WATCH_SF
      for (j = 0; j < 1000000; j++) {
	ctl = INREG(BRW_SF_CTL);
	 if (ctl & BRW_SF_CTL_SNAPSHOT_COMPLETE)
	    break;
      }

      for (k = 0; k <= 7; k++) {
	 OUTREG(BRW_SF_CTL,
		BRW_SF_CTL_SNAPSHOT_COMPLETE |
		(k << 8));
	 rdata = INREG(BRW_SF_RDATA);
	 ErrorF ("SF_CTL: 0x%08x SF_RDATA(%d): 0x%08x\n", ctl, k, rdata);
      }
      
      OUTREG(BRW_SF_CTL, 0);
#endif

#if WATCH_WIZ
      for (j = 0; j < 100000; j++) {
	ctl = INREG(BRW_WIZ_CTL);
	 if (ctl & BRW_WIZ_CTL_SNAPSHOT_COMPLETE)
	    break;
      }
      
      rdata = INREG(BRW_WIZ_RDATA);
      OUTREG(BRW_WIZ_CTL, 0);
      ErrorF ("WIZ_CTL: 0x%08x WIZ_RDATA: 0x%08x\n", ctl, rdata);
#endif
      
#if 0
      for (j = 0; j < 100000; j++) {
	ctl = INREG(BRW_TS_CTL);
	 if (ctl & BRW_TS_CTL_SNAPSHOT_COMPLETE)
	    break;
      }
      
      rdata = INREG(BRW_TS_RDATA);
      OUTREG(BRW_TS_CTL, 0);
      ErrorF ("TS_CTL: 0x%08x TS_RDATA: 0x%08x\n", ctl, rdata);
      
      ErrorF ("after EU_ATT 0x%08x%08x EU_ATT_DATA 0x%08x%08x\n",
	      INREG(BRW_EU_ATT_1), INREG(BRW_EU_ATT_0),
	      INREG(BRW_EU_ATT_DATA_1), INREG(BRW_EU_ATT_DATA_0));
#endif

#if 0
      for (j = 0; j < 256; j++) {
	 OUTREG(BRW_TD_CTL, j << BRW_TD_CTL_MUX_SHIFT);
	 rdata = INREG(BRW_TD_RDATA);
	 ErrorF ("TD_RDATA(%d): 0x%08x\n", j, rdata);
      }
#endif
      first_output = FALSE;
      if (pI830->AccelInfoRec)
	 pI830->AccelInfoRec->NeedToSync = TRUE;
   }

   if (pI830->AccelInfoRec)
      (*pI830->AccelInfoRec->Sync)(pScrn);
#if WATCH_STATS
   I830PrintErrorState (pScrn);
#endif
}

static FBLinearPtr
I830AllocateMemory(ScrnInfoPtr pScrn, FBLinearPtr linear, int size)
{
   ScreenPtr pScreen;
   FBLinearPtr new_linear = NULL;

   ErrorF("I830AllocateMemory\n");

   if (linear) {
      if (linear->size >= size)
	 return linear;

      if (xf86ResizeOffscreenLinear(linear, size))
	 return linear;

      xf86FreeOffscreenLinear(linear);
   }

   pScreen = screenInfo.screens[pScrn->scrnIndex];

   new_linear = xf86AllocateOffscreenLinear(pScreen, size, 4,
					    NULL, NULL, NULL);

   if (!new_linear) {
      int max_size;

      xf86QueryLargestOffscreenLinear(pScreen, &max_size, 4,
				      PRIORITY_EXTREME);

      if (max_size < size) {
         ErrorF("No memory available\n");
	 return NULL;
      }

      xf86PurgeUnlockedOffscreenAreas(pScreen);
      new_linear = xf86AllocateOffscreenLinear(pScreen, size, 4,
					       NULL, NULL, NULL);
   }

   return new_linear;
d2180 17
a2196 11
   I830Ptr pI830 = I830PTR(pScrn);
   I830PortPrivPtr pPriv = (I830PortPrivPtr) data;
   ScreenPtr pScreen = screenInfo.screens[pScrn->scrnIndex];
   I830OverlayRegPtr overlay =
	 (I830OverlayRegPtr) (pI830->FbBase + pI830->OverlayMem->Start);
   INT32 x1, x2, y1, y2;
   int srcPitch, srcPitch2 = 0, dstPitch, destId;
   int top, left, npixels, nlines, size, loops;
   BoxRec dstBox;
   int pitchAlignMask;
   int extraLinear;
d2198 2
a2199 1
   ErrorF("I830PutImage: src: (%d,%d)(%d,%d), dst: (%d,%d)(%d,%d)\n"
d2202 1
d2204 3
a2206 3
   if (pI830->entityPrivate) {
	 if (pI830->entityPrivate->XvInUse != -1 &&
	     pI830->entityPrivate->XvInUse != pPriv->pipe) {
d2208 3
a2210 3
		if (!noPanoramiXExtension) {
			return Success; /* faked for trying to share it */
		} else
d2212 4
a2215 93
		{
			return BadAlloc;
		}
	 }

      pI830->entityPrivate->XvInUse = pPriv->pipe;
   }

   /* overlay limits */
   if(src_w > (drw_w * 7))
      drw_w = src_w * 7;

   if(src_h > (drw_h * 7))
      drw_h = src_h * 7;

   /* Clip */
   x1 = src_x;
   x2 = src_x + src_w;
   y1 = src_y;
   y2 = src_y + src_h;

   dstBox.x1 = drw_x;
   dstBox.x2 = drw_x + drw_w;
   dstBox.y1 = drw_y;
   dstBox.y2 = drw_y + drw_h;

   if (!xf86XVClipVideoHelper(&dstBox, &x1, &x2, &y1, &y2, clipBoxes,
			      width, height))
      return Success;

   destId = id;
   switch (id) {
   case FOURCC_YV12:
   case FOURCC_I420:
      srcPitch = (width + 3) & ~3;
      srcPitch2 = ((width >> 1) + 3) & ~3;
      if (pPriv->textured) {
	 destId = FOURCC_YUY2;
      }
      break;
   case FOURCC_UYVY:
   case FOURCC_YUY2:
   default:
      srcPitch = width << 1;
      break;
   }

   /* Only needs to be DWORD-aligned for textured on i915, but overlay has
    * stricter requirements.
    */
   if (pPriv->textured) {
      pitchAlignMask = 3;
   } else {
      if (IS_I96X(pI830))
	 pitchAlignMask = 255;
      else
	 pitchAlignMask = 63;
   }

   /* Determine the desired destination pitch (representing the chroma's pitch,
    * in the planar case.
    */
   switch (destId) {
   case FOURCC_YV12:
   case FOURCC_I420:
      if (pI830->rotation & (RR_Rotate_90 | RR_Rotate_270)) {
         dstPitch = ((height / 2) + pitchAlignMask) & ~pitchAlignMask;
         size = dstPitch * width * 3;
      } else {
         dstPitch = ((width / 2) + pitchAlignMask) & ~pitchAlignMask;
         size = dstPitch * height * 3;
      }
      break;
   case FOURCC_UYVY:
   case FOURCC_YUY2:
   default:
      if (pI830->rotation & (RR_Rotate_90 | RR_Rotate_270)) {
         dstPitch = ((height << 1) + pitchAlignMask) & ~pitchAlignMask;
         size = dstPitch * width;
      } else {
         dstPitch = ((width << 1) + pitchAlignMask) & ~pitchAlignMask;
         size = dstPitch * height;
      }
      break;
   }
#if 0
   ErrorF("srcPitch: %d, dstPitch: %d, size: %d\n", srcPitch, dstPitch, size);
#endif

   if (IS_I96X(pI830))
      extraLinear = BRW_LINEAR_EXTRA;
   else
      extraLinear = 0;
d2217 2
a2218 5
   /* size is multiplied by 2 because we have two buffers that are flipping */
   pPriv->linear = I830AllocateMemory(pScrn, pPriv->linear,
				      (extraLinear +
				       (pPriv->doubleBuffer ? size * 2 : size)) /
				      pI830->cpp);
d2220 214
a2433 2
   if(!pPriv->linear || pPriv->linear->offset < (pScrn->virtualX * pScrn->virtualY))
      return BadAlloc;
d2435 1
a2435 90
   /* fixup pointers */
#if 0
   pPriv->YBuf0offset = pScrn->fbOffset + pPriv->linear->offset * pI830->cpp;
#else
   pPriv->YBuf0offset = pI830->FrontBuffer.Start + pPriv->linear->offset * pI830->cpp;
#endif
   if (pI830->rotation & (RR_Rotate_90 | RR_Rotate_270)) {
      pPriv->UBuf0offset = pPriv->YBuf0offset + (dstPitch * 2 * width);
      pPriv->VBuf0offset = pPriv->UBuf0offset + (dstPitch * width / 2);
      if(pPriv->doubleBuffer) {
         pPriv->YBuf1offset = pPriv->YBuf0offset + size;
         pPriv->UBuf1offset = pPriv->YBuf1offset + (dstPitch * 2 * width);
         pPriv->VBuf1offset = pPriv->UBuf1offset + (dstPitch * width / 2);
      }
   } else {
      pPriv->UBuf0offset = pPriv->YBuf0offset + (dstPitch * 2 * height);
      pPriv->VBuf0offset = pPriv->UBuf0offset + (dstPitch * height / 2);
      if(pPriv->doubleBuffer) {
         pPriv->YBuf1offset = pPriv->YBuf0offset + size;
         pPriv->UBuf1offset = pPriv->YBuf1offset + (dstPitch * 2 * height);
         pPriv->VBuf1offset = pPriv->UBuf1offset + (dstPitch * height / 2);
      }
   }

   /* Make sure this buffer isn't in use */
   loops = 0;
   if (!pPriv->textured && *pI830->overlayOn && pPriv->doubleBuffer &&
       (overlay->OCMD & OVERLAY_ENABLE))
   {
      while (loops < 1000000) {
#if USE_USLEEP_FOR_VIDEO
         usleep(10);
#endif
         if (((INREG(DOVSTA) & OC_BUF) >> 20) == pPriv->currentBuf) {
	    break;
         }
         loops++;
      }
      if (loops >= 1000000) {
         ErrorF("loops (1) maxed out for buffer %d\n", pPriv->currentBuf);
#if 0
         pPriv->currentBuf = !pPriv->currentBuf;
#endif
      }

      /* buffer swap */
      if (pPriv->currentBuf == 0)
         pPriv->currentBuf = 1;
      else
         pPriv->currentBuf = 0;
   }

   /* copy data */
   top = y1 >> 16;
   left = (x1 >> 16) & ~1;
   npixels = ((((x2 + 0xffff) >> 16) + 1) & ~1) - left;

   if (pPriv->textured) {
      /* For textured video, we don't double buffer, and instead just wait for
       * acceleration to finish before writing the new video data into
       * framebuffer.
       */
      if (pI830->AccelInfoRec && pI830->AccelInfoRec->NeedToSync) {
	 (*pI830->AccelInfoRec->Sync)(pScrn);
	 pI830->AccelInfoRec->NeedToSync = FALSE;
      }
   }

   switch (id) {
   case FOURCC_YV12:
   case FOURCC_I420:
      top &= ~1;
      nlines = ((((y2 + 0xffff) >> 16) + 1) & ~1) - top;
      if (pPriv->textured) {
	 I830CopyPlanarToPackedData(pScrn, pPriv, buf, srcPitch, srcPitch2,
				    dstPitch, height, top, left, nlines,
				    npixels, id);
      } else {
	 I830CopyPlanarData(pScrn, pPriv, buf, srcPitch, srcPitch2, dstPitch,
			    height, top, left, nlines, npixels, id);
      }
      break;
   case FOURCC_UYVY:
   case FOURCC_YUY2:
   default:
      nlines = ((y2 + 0xffff) >> 16) - top;
      I830CopyPackedData(pScrn, pPriv, buf, srcPitch, dstPitch, top, left,
			 nlines, npixels);
      break;
   }
d2437 1
a2437 21
   if (!pPriv->textured) {
      /* update cliplist */
      if (!RegionsEqual(&pPriv->clip, clipBoxes)) {
 	REGION_COPY(pScrn->pScreen, &pPriv->clip, clipBoxes);
	 xf86XVFillKeyHelper(pScreen, pPriv->colorKey, clipBoxes);
      }

      I830DisplayVideo(pScrn, destId, width, height, dstPitch,
		       x1, y1, x2, y2, &dstBox, src_w, src_h, drw_w, drw_h);
   } else if (IS_I96X(pI830)) {
      BroadwaterDisplayVideoTextured (pScrn, pPriv, destId, clipBoxes, width, height,
				      dstPitch, x1, y1, x2, y2,
				      src_w, src_h, drw_w, drw_h, pDraw);
   } else {
      I915DisplayVideoTextured(pScrn, pPriv, destId, clipBoxes, width, height,
			       dstPitch, x1, y1, x2, y2,
			       src_w, src_h, drw_w, drw_h, pDraw);
   }
   pPriv->videoStatus = CLIENT_VIDEO_ON;

   return Success;
d2446 2
a2447 2
   I830Ptr pI830 = I830PTR(pScrn);
   int size, tmp;
d2450 1
a2450 1
   ErrorF("I830QueryImageAttributes: w is %d, h is %d\n", *w, *h);
d2453 2
a2454 3
   if (!textured) {
      if (IS_845G(pI830) || IS_I830(pI830)) {
	 if (*w > IMAGE_MAX_WIDTH_LEGACY)
d2456 1
a2456 1
	 if (*h > IMAGE_MAX_HEIGHT_LEGACY)
d2458 2
a2459 2
      } else {
	 if (*w > IMAGE_MAX_WIDTH)
d2461 1
a2461 1
	 if (*h > IMAGE_MAX_HEIGHT)
d2463 1
a2463 2
      }
   }
d2465 48
a2512 46
   *w = (*w + 1) & ~1;
   if (offsets)
      offsets[0] = 0;

   switch (id) {
      /* IA44 is for XvMC only */
   case FOURCC_IA44:
   case FOURCC_AI44:
      if (pitches)
	 pitches[0] = *w;
      size = *w * *h;
      break;
   case FOURCC_YV12:
   case FOURCC_I420:
      *h = (*h + 1) & ~1;
      size = (*w + 3) & ~3;
      if (pitches)
	 pitches[0] = size;
      size *= *h;
      if (offsets)
	 offsets[1] = size;
      tmp = ((*w >> 1) + 3) & ~3;
      if (pitches)
	 pitches[1] = pitches[2] = tmp;
      tmp *= (*h >> 1);
      size += tmp;
      if (offsets)
	 offsets[2] = size;
      size += tmp;
      if (pitches)
	 ErrorF("pitch 0 is %d, pitch 1 is %d, pitch 2 is %d\n", pitches[0],
		pitches[1], pitches[2]);
      if (offsets)
	 ErrorF("offset 1 is %d, offset 2 is %d\n", offsets[1], offsets[2]);
      if (offsets)
	 ErrorF("size is %d\n", size);
      break;
   case FOURCC_UYVY:
   case FOURCC_YUY2:
   default:
      size = *w << 1;
      if (pitches)
	 pitches[0] = size;
      size *= *h;
      break;
   }
d2514 1
a2514 1
   return size;
d2523 1
a2523 1
   return I830QueryImageAttributes(pScrn, id, w, h, pitches, offsets, FALSE);
d2532 1
a2532 1
   return I830QueryImageAttributes(pScrn, id, w, h, pitches, offsets, TRUE);
d2535 3
a2537 3
static void
I830BlockHandler(int i,
		 pointer blockData, pointer pTimeout, pointer pReadmask)
d2539 3
a2541 4
   ScreenPtr pScreen = screenInfo.screens[i];
   ScrnInfoPtr pScrn = xf86Screens[i];
   I830Ptr pI830 = I830PTR(pScrn);
   I830PortPrivPtr pPriv = GET_PORT_PRIVATE(pScrn);
d2543 2
a2544 1
   pScreen->BlockHandler = pI830->BlockHandler;
d2546 3
a2548 1
   (*pScreen->BlockHandler) (i, blockData, pTimeout, pReadmask);
d2550 1
a2550 1
   pScreen->BlockHandler = I830BlockHandler;
d2552 1
a2552 1
   if (pPriv->videoStatus & TIMER_MASK) {
d2554 1
a2554 1
      Time now = currentTime.milliseconds;
d2556 1
a2556 1
      UpdateCurrentTime();
d2558 24
a2581 25
      if (pPriv->videoStatus & OFF_TIMER) {
	 if (pPriv->offTime < now) {
	    /* Turn off the overlay */
	    ErrorF("BLOCKHANDLER\n");

	    I830ResetVideo(pScrn);
            OVERLAY_UPDATE;
            OVERLAY_OFF;

	    pPriv->videoStatus = FREE_TIMER;
	    pPriv->freeTime = now + FREE_DELAY;
       
            if (pI830->entityPrivate)
               pI830->entityPrivate->XvInUse = -1;
	 }
      } else {				/* FREE_TIMER */
	 if (pPriv->freeTime < now) {
	    if (pPriv->linear) {
	       xf86FreeOffscreenLinear(pPriv->linear);
	       pPriv->linear = NULL;
	    }
	    pPriv->videoStatus = 0;
	 }
      }
   }
d2589 2
a2590 2
   FBLinearPtr linear;
   Bool isOn;
d2599 53
a2651 46
   FBLinearPtr linear;
   int pitch, fbpitch, size, bpp;
   OffscreenPrivPtr pPriv;
   I830Ptr pI830 = I830PTR(pScrn);

   ErrorF("I830AllocateSurface\n");

   if (IS_845G(pI830) || IS_I830(pI830)) {
      if ((w > IMAGE_MAX_WIDTH_LEGACY) || (h > IMAGE_MAX_HEIGHT_LEGACY))
         return BadAlloc;
   } else {
      if ((w > IMAGE_MAX_WIDTH) || (h > IMAGE_MAX_HEIGHT))
         return BadAlloc;
   }

   /* What to do when rotated ?? */
   if (pI830->rotation != RR_Rotate_0)
      return BadAlloc;

   w = (w + 1) & ~1;
   pitch = ((w << 1) + 15) & ~15;
   bpp = pScrn->bitsPerPixel >> 3;
   fbpitch = bpp * pScrn->displayWidth;
   size = ((pitch * h) + bpp - 1) / bpp;

   if (!(linear = I830AllocateMemory(pScrn, NULL, size)))
      return BadAlloc;

   surface->width = w;
   surface->height = h;

   if (!(surface->pitches = xalloc(sizeof(int)))) {
      xf86FreeOffscreenLinear(linear);
      return BadAlloc;
   }
   if (!(surface->offsets = xalloc(sizeof(int)))) {
      xfree(surface->pitches);
      xf86FreeOffscreenLinear(linear);
      return BadAlloc;
   }
   if (!(pPriv = xalloc(sizeof(OffscreenPrivRec)))) {
      xfree(surface->pitches);
      xfree(surface->offsets);
      xf86FreeOffscreenLinear(linear);
      return BadAlloc;
   }
d2653 1
a2653 2
   pPriv->linear = linear;
   pPriv->isOn = FALSE;
d2655 1
a2655 13
   surface->pScrn = pScrn;
   surface->id = id;
   surface->pitches[0] = pitch;
   surface->offsets[0] = linear->offset * bpp;
   surface->devPrivate.ptr = (pointer) pPriv;

#if 0
   memset(pI830->FbBase + pScrn->fbOffset + surface->offsets[0], 0, size);
#else
   memset(pI830->FbBase + pI830->FrontBuffer.Start + surface->offsets[0], 0, size);
#endif

   return Success;
d2661 2
a2662 2
   OffscreenPrivPtr pPriv = (OffscreenPrivPtr) surface->devPrivate.ptr;
   ScrnInfoPtr pScrn = surface->pScrn;
d2664 2
a2665 2
   if (pPriv->isOn) {
      I830Ptr pI830 = I830PTR(pScrn);
d2667 1
a2667 1
      ErrorF("StopSurface\n");
d2669 1
a2669 3
      I830ResetVideo(pScrn);
      OVERLAY_UPDATE;
      OVERLAY_OFF;
d2671 2
a2672 2
      if (pI830->entityPrivate)
         pI830->entityPrivate->XvInUse = -1;
d2674 2
a2675 2
      pPriv->isOn = FALSE;
   }
d2677 1
a2677 1
   return Success;
d2683 2
a2684 1
   OffscreenPrivPtr pPriv = (OffscreenPrivPtr) surface->devPrivate.ptr;
d2686 7
a2692 7
   if (pPriv->isOn) {
      I830StopSurface(surface);
   }
   xf86FreeOffscreenLinear(pPriv->linear);
   xfree(surface->pitches);
   xfree(surface->offsets);
   xfree(surface->devPrivate.ptr);
d2694 1
a2694 1
   return Success;
d2700 1
a2700 1
   return I830GetPortAttribute(pScrn, attribute, value, 0);
d2706 1
a2706 1
   return I830SetPortAttribute(pScrn, attribute, value, 0);
d2716 14
a2729 16
   OffscreenPrivPtr pPriv = (OffscreenPrivPtr) surface->devPrivate.ptr;
   ScrnInfoPtr pScrn = surface->pScrn;
   ScreenPtr pScreen = screenInfo.screens[pScrn->scrnIndex];
   I830Ptr pI830 = I830PTR(pScrn);
   I830PortPrivPtr pI830Priv = GET_PORT_PRIVATE(pScrn);
   I830OverlayRegPtr overlay =
	 (I830OverlayRegPtr) (pI830->FbBase + pI830->OverlayMem->Start);
   INT32 x1, y1, x2, y2;
   INT32 loops = 0;
   BoxRec dstBox;

   ErrorF("I830DisplaySurface\n");

   if (pI830->entityPrivate) {
	 if (pI830->entityPrivate->XvInUse != -1 &&
	     pI830->entityPrivate->XvInUse != pI830Priv->pipe) {
d2731 3
a2733 3
		if (!noPanoramiXExtension) {
			return Success; /* faked for trying to share it */
		} else
d2735 4
a2738 4
		{
			return BadAlloc;
		}
	 }
d2740 2
a2741 2
      pI830->entityPrivate->XvInUse = pI830Priv->pipe;
   }
d2743 37
a2779 43
   x1 = src_x;
   x2 = src_x + src_w;
   y1 = src_y;
   y2 = src_y + src_h;

   dstBox.x1 = drw_x;
   dstBox.x2 = drw_x + drw_w;
   dstBox.y1 = drw_y;
   dstBox.y2 = drw_y + drw_h;

   if (!xf86XVClipVideoHelper(&dstBox, &x1, &x2, &y1, &y2, clipBoxes,
			      surface->width, surface->height))
      return Success;

   /* fixup pointers */
   pI830Priv->YBuf0offset = surface->offsets[0];
   pI830Priv->YBuf1offset = pI830Priv->YBuf0offset;

   /* Make sure this buffer isn't in use */
   loops = 0;
   if (*pI830->overlayOn && pI830Priv->doubleBuffer && (overlay->OCMD & OVERLAY_ENABLE)) {
      while (loops < 1000000) {
#if USE_USLEEP_FOR_VIDEO
         usleep(10);
#endif
         if (((INREG(DOVSTA) & OC_BUF) >> 20) == pI830Priv->currentBuf) {
	    break;
         }
         loops++;
      }
      if (loops >= 1000000) {
         ErrorF("loops (1) maxed out for buffer %d\n", pI830Priv->currentBuf);
#if 0
         pI830Priv->currentBuf = !pI830Priv->currentBuf;
#endif
      }

      /* buffer swap */
      if (pI830Priv->currentBuf == 0)
         pI830Priv->currentBuf = 1;
      else
         pI830Priv->currentBuf = 0;
   }
d2781 1
a2781 17
   I830DisplayVideo(pScrn, surface->id, surface->width, surface->height,
		    surface->pitches[0], x1, y1, x2, y2, &dstBox,
		    src_w, src_h, drw_w, drw_h);

   xf86XVFillKeyHelper(pScreen, pI830Priv->colorKey, clipBoxes);

   pPriv->isOn = TRUE;
   /* we've prempted the XvImage stream so set its free timer */
   if (pI830Priv->videoStatus & CLIENT_VIDEO_ON) {
      REGION_EMPTY(pScrn->pScreen, &pI830Priv->clip);
      UpdateCurrentTime();
      pI830Priv->videoStatus = FREE_TIMER;
      pI830Priv->freeTime = currentTime.milliseconds + FREE_DELAY;
      pScrn->pScreen->BlockHandler = I830BlockHandler;
   }

   return Success;
d2787 26
a2812 8
   XF86OffscreenImagePtr offscreenImages;
   ScrnInfoPtr pScrn = xf86Screens[pScreen->myNum];
   I830Ptr pI830 = I830PTR(pScrn);

   /* need to free this someplace */
   if (!(offscreenImages = xalloc(sizeof(XF86OffscreenImageRec)))) {
      return;
   }
d2814 1
a2814 19
   offscreenImages[0].image = &Images[0];
   offscreenImages[0].flags = VIDEO_OVERLAID_IMAGES /*| VIDEO_CLIP_TO_VIEWPORT*/;
   offscreenImages[0].alloc_surface = I830AllocateSurface;
   offscreenImages[0].free_surface = I830FreeSurface;
   offscreenImages[0].display = I830DisplaySurface;
   offscreenImages[0].stop = I830StopSurface;
   offscreenImages[0].setAttribute = I830SetSurfaceAttribute;
   offscreenImages[0].getAttribute = I830GetSurfaceAttribute;
   if (IS_845G(pI830) || IS_I830(pI830)) {
      offscreenImages[0].max_width = IMAGE_MAX_WIDTH_LEGACY;
      offscreenImages[0].max_height = IMAGE_MAX_HEIGHT_LEGACY;
   } else {
      offscreenImages[0].max_width = IMAGE_MAX_WIDTH;
      offscreenImages[0].max_height = IMAGE_MAX_HEIGHT; 
   }
   offscreenImages[0].num_attributes = 1;
   offscreenImages[0].attributes = Attributes;

   xf86XVRegisterOffscreenImages(pScreen, offscreenImages, 1);
d2818 1
a2818 1
I830VideoSwitchModeBefore(ScrnInfoPtr pScrn, DisplayModePtr mode)
d2820 27
a2846 98
   I830Ptr pI830 = I830PTR(pScrn);
   I830PortPrivPtr pPriv;

   if (!pI830->adaptor) {
      return;
   }

   pPriv = GET_PORT_PRIVATE(pScrn);

   if (!pPriv) {
      xf86ErrorF("pPriv isn't set\n");
      return;
   }

   /* We stop the video when mode switching, just so we don't lockup
    * the engine. The overlayOK will determine whether we can re-enable
    * with the current video on completion of the mode switch.
    */
   I830StopVideo(pScrn, pPriv, TRUE);

   pPriv->overlayOK = FALSE;

   pPriv->oneLineMode = FALSE;
}

void
I830VideoSwitchModeAfter(ScrnInfoPtr pScrn, DisplayModePtr mode)
{
   I830Ptr pI830 = I830PTR(pScrn);
   I830PortPrivPtr pPriv;
   int size, hsize, vsize, active;

   if (!pI830->adaptor) {
      return;
   }
   pPriv = GET_PORT_PRIVATE(pScrn);
   if (!pPriv)
      return;

   pPriv->overlayOK = TRUE;

   /* ensure pipe is updated on mode switch */
   if (!pI830->Clone) {
      if (pPriv->pipe != pI830->pipe) {
         xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
	   "Changing XVideo pipe (%d to %d).\n", pPriv->pipe, pI830->pipe);
         pPriv->pipe = pI830->pipe;
      }
   }

   if (!IS_I96X(pI830)) {
      if (pPriv->pipe == 0) {
         if (INREG(PIPEACONF) & PIPEACONF_DOUBLE_WIDE) {
            xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
	    "Disabling XVideo output because Pipe A is in double-wide mode.\n");
            pPriv->overlayOK = FALSE;
         } else if (!pPriv->overlayOK) {
            xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
	    "Re-enabling XVideo output because Pipe A is now in single-wide mode.\n");
            pPriv->overlayOK = TRUE;
         }
      }

      if (pPriv->pipe == 1) {
         if (INREG(PIPEBCONF) & PIPEBCONF_DOUBLE_WIDE) {
            xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
   	    "Disabling XVideo output because Pipe B is in double-wide mode.\n");
            pPriv->overlayOK = FALSE;
         } else if (!pPriv->overlayOK) {
            xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
	    "Re-enabling XVideo output because Pipe B is now in single-wide mode.\n");
            pPriv->overlayOK = TRUE;
         }
      }
   }

   /* Check we have an LFP connected */
   if ((pPriv->pipe == 1 && pI830->operatingDevices & (PIPE_LFP << 8)) ||
       (pPriv->pipe == 0 && pI830->operatingDevices & PIPE_LFP) ) {
      size = pPriv->pipe ? INREG(PIPEBSRC) : INREG(PIPEASRC);
      hsize = (size >> 16) & 0x7FF;
      vsize = size & 0x7FF;
      active = pPriv->pipe ? (INREG(VTOTAL_B) & 0x7FF) : (INREG(VTOTAL_A) & 0x7FF);

      if (vsize < active && hsize > 1024)
         I830SetOneLineModeRatio(pScrn);
   
      if (pPriv->scaleRatio & 0xFFFE0000) {
         /* Possible bogus ratio, using in-accurate fallback */
         xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
	    "Bogus panel fit register, Xvideo positioning may not be accurate.\n");
         xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
	    "Using fallback ratio - was 0x%x, now 0x%x\n", pPriv->scaleRatio, (int)(((float)active * 65536)/(float)vsize));
   
   
         pPriv->scaleRatio = (int)(((float)active * 65536) / (float)vsize);
      }
   }
@


1.1
log
@Initial revision
@
text
@a0 1
#define VIDEO_DEBUG 0
d174 1
a174 1
      if (IS_I965G(pI830)) 						\
d192 1
a192 1
         if (IS_I965G(pI830)) 						\
d449 1
a449 1
   if (!IS_I965G(pI830) && pScrn->bitsPerPixel != 8) {
d464 1
a464 1
   if (pScrn->bitsPerPixel >= 16 && (IS_I9XX(pI830) || IS_I965G(pI830))) {
d937 2
a938 1
      OVERLAY_UPDATE;
d945 2
a946 1
      OVERLAY_UPDATE;
d960 2
a961 1
      OVERLAY_UPDATE;
d988 2
a989 1
      OVERLAY_UPDATE;
a1006 1
	CARD32 r = overlay->OCMD & OVERLAY_ENABLE;
a1007 2
        overlay->OCMD &= ~OVERLAY_ENABLE;
        OVERLAY_UPDATE;
a1008 2
        overlay->OCMD |= r;
        OVERLAY_UPDATE;
d1850 1
a1850 1
   if (IS_I965G(pI830))
d2998 1
a2998 1
      if (IS_I965G(pI830))
d3034 1
a3034 1
   if (IS_I965G(pI830))
d3148 1
a3148 1
   } else if (IS_I965G(pI830)) {
d3622 1
a3622 1
   if (!IS_I965G(pI830)) {
@


1.1.1.1
log
@Importing xf86-video-i810 1.7.2
@
text
@@


1.1.1.2
log
@xf86-video-intel 1.7.3
@
text
@d1 1
d938 1
a938 2
      if (*pI830->overlayOn)
         OVERLAY_UPDATE;
d945 1
a945 2
      if (*pI830->overlayOn)
         OVERLAY_UPDATE;
d959 1
a959 2
      if (*pI830->overlayOn)
         OVERLAY_UPDATE;
d986 1
a986 2
      if (*pI830->overlayOn)
         OVERLAY_UPDATE;
d1004 1
d1006 2
d1009 2
@


1.1.1.3
log
@xf86-video-intel 2.2.0
@
text
@d2 2
d5 19
a23 1
 Copyright 2000 Intel Corporation.  All Rights Reserved. 
d25 2
a26 19
 Permission is hereby granted, free of charge, to any person obtaining a 
 copy of this software and associated documentation files (the 
 "Software"), to deal in the Software without restriction, including 
 without limitation the rights to use, copy, modify, merge, publish, 
 distribute, sub license, and/or sell copies of the Software, and to 
 permit persons to whom the Software is furnished to do so, subject to 
 the following conditions: 

 The above copyright notice and this permission notice (including the 
 next paragraph) shall be included in all copies or substantial portions 
 of the Software. 

 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS 
 OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF 
 MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT. 
 IN NO EVENT SHALL INTEL, AND/OR ITS SUPPLIERS BE LIABLE FOR ANY CLAIM, 
 DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR 
 OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR 
 THE USE OR OTHER DEALINGS IN THE SOFTWARE.
d28 12
a39 2
 **************************************************************************/
/* $XFree86: xc/programs/Xserver/hw/xfree86/drivers/i810/i830_video.c,v 1.11tsi Exp $ */
a78 2
#include "windowstr.h"
#include "damage.h"
d87 2
d121 5
d128 1
a128 1
static Atom xvBrightness, xvContrast, xvSaturation, xvColorKey, xvPipe, xvDoubleBuffer;
a130 13
/* Limits for the overlay/textured video source sizes.  The documented hardware
 * limits are 2048x2048 or better for overlay and both of our textured video
 * implementations.  However, we run into the bigrequests limit of (currently)
 * 4MB, which even the planar format's 2048*2048*1.5 bytes is larger than.
 * Conveniently, the HD resolution, even in packed format, takes
 * (1920*1088*2) bytes, which is just shy of 4MB.  Additionally, on the 830
 * and 845, larger sizes resulted in the card hanging, so we keep the limits
 * lower there.
 *
 * While the HD resolution is actually 1920x1080, we increase our advertised
 * size to 1088 because some software wants to send an image aligned to
 * 16-pixel boundaries.
 */
d136 11
a146 5
/* overlay debugging printf function */
#if 0
#define OVERLAY_DEBUG ErrorF
#else
#define OVERLAY_DEBUG if (0) ErrorF
d149 60
a208 4
/* Oops, I never exported this function in EXA.  I meant to. */
#ifndef exaMoveInPixmap
void exaMoveInPixmap (PixmapPtr pPixmap);
#endif
d271 1
a271 1
(((c & 0xF800) << 8) | ((c & 0x07E0) << 5) | ((c & 0x001F) << 3))
d274 1
a274 1
(((c & 0x7c00) << 9) | ((c & 0x03E0) << 6) | ((c & 0x001F) << 3))
d278 6
a283 6
    {
	0,
	"XV_IMAGE",
	IMAGE_MAX_WIDTH, IMAGE_MAX_HEIGHT,
	{1, 1}
    }
d289 1
a289 1
    {15, TrueColor}, {16, TrueColor}, {24, TrueColor}
d294 1
a294 1
    {XvSettable | XvGettable, -1, 1, "XV_PIPE"}
d297 1
a297 1
#define NUM_ATTRIBUTES 5
d299 4
a302 5
    {XvSettable | XvGettable, 0, (1 << 24) - 1, "XV_COLORKEY"},
    {XvSettable | XvGettable, -128, 127, "XV_BRIGHTNESS"},
    {XvSettable | XvGettable, 0, 255, "XV_CONTRAST"},
    {XvSettable | XvGettable, 0, 1023, "XV_SATURATION"},
    {XvSettable | XvGettable, 0, 1, "XV_DOUBLE_BUFFER"}
d307 2
a308 2
    {XvSettable | XvGettable, -128, 127, "XV_BRIGHTNESS"},
    {XvSettable | XvGettable, 0, 255, "XV_CONTRAST"},
d313 6
a318 6
    {XvSettable | XvGettable, 0, 0xffffff, "XV_GAMMA0"},
    {XvSettable | XvGettable, 0, 0xffffff, "XV_GAMMA1"},
    {XvSettable | XvGettable, 0, 0xffffff, "XV_GAMMA2"},
    {XvSettable | XvGettable, 0, 0xffffff, "XV_GAMMA3"},
    {XvSettable | XvGettable, 0, 0xffffff, "XV_GAMMA4"},
    {XvSettable | XvGettable, 0, 0xffffff, "XV_GAMMA5"}
d324 4
a327 4
    XVIMAGE_YUY2,
    XVIMAGE_YV12,
    XVIMAGE_I420,
    XVIMAGE_UYVY
d331 52
a382 52
    CARD32 OBUF_0Y;
    CARD32 OBUF_1Y;
    CARD32 OBUF_0U;
    CARD32 OBUF_0V;
    CARD32 OBUF_1U;
    CARD32 OBUF_1V;
    CARD32 OSTRIDE;
    CARD32 YRGB_VPH;
    CARD32 UV_VPH;
    CARD32 HORZ_PH;
    CARD32 INIT_PHS;
    CARD32 DWINPOS;
    CARD32 DWINSZ;
    CARD32 SWIDTH;
    CARD32 SWIDTHSW;
    CARD32 SHEIGHT;
    CARD32 YRGBSCALE;
    CARD32 UVSCALE;
    CARD32 OCLRC0;
    CARD32 OCLRC1;
    CARD32 DCLRKV;
    CARD32 DCLRKM;
    CARD32 SCLRKVH;
    CARD32 SCLRKVL;
    CARD32 SCLRKEN;
    CARD32 OCONFIG;
    CARD32 OCMD;
    CARD32 RESERVED1;			/* 0x6C */
    CARD32 OSTART_0Y; 		/* for i965 */
    CARD32 OSTART_1Y;		/* for i965 */
    CARD32 OSTART_0U;
    CARD32 OSTART_0V;
    CARD32 OSTART_1U;
    CARD32 OSTART_1V;
    CARD32 OTILEOFF_0Y;
    CARD32 OTILEOFF_1Y;
    CARD32 OTILEOFF_0U;
    CARD32 OTILEOFF_0V;
    CARD32 OTILEOFF_1U;
    CARD32 OTILEOFF_1V;
    CARD32 FASTHSCALE;			/* 0xA0 */
    CARD32 UVSCALEV;			/* 0xA4 */

    CARD32 RESERVEDC[(0x200 - 0xA8) / 4];		   /* 0xA8 - 0x1FC */
    CARD16 Y_VCOEFS[N_VERT_Y_TAPS * N_PHASES];		   /* 0x200 */
    CARD16 RESERVEDD[0x100 / 2 - N_VERT_Y_TAPS * N_PHASES];
    CARD16 Y_HCOEFS[N_HORIZ_Y_TAPS * N_PHASES];		   /* 0x300 */
    CARD16 RESERVEDE[0x200 / 2 - N_HORIZ_Y_TAPS * N_PHASES];
    CARD16 UV_VCOEFS[N_VERT_UV_TAPS * N_PHASES];		   /* 0x500 */
    CARD16 RESERVEDF[0x100 / 2 - N_VERT_UV_TAPS * N_PHASES];
    CARD16 UV_HCOEFS[N_HORIZ_UV_TAPS * N_PHASES];	   /* 0x600 */
    CARD16 RESERVEDG[0x100 / 2 - N_HORIZ_UV_TAPS * N_PHASES];
a384 3
#define I830OVERLAYREG(pI830) ((I830OverlayRegPtr)\
			       ((pI830)->FbBase + \
				(pI830)->overlay_regs->offset))
d389 14
a402 14
    int i;
    CARD32 val;
    int bad = 0;

    for (i = 0; i < size; i += 4) {
	val = INREG(0x30100 + i);
	if (val != overlay[i / 4]) {
	    OVERLAY_DEBUG("0x%05x value doesn't match (0x%lx != 0x%lx)\n",
			  0x30100 + i, val, overlay[i / 4]);
	    bad++;
	}
    }
    if (!bad)
	OVERLAY_DEBUG("CompareOverlay: no differences\n");
d406 10
a415 2
static void
I830SetOneLineModeRatio(ScrnInfoPtr pScrn);
d417 3
a419 47
static void
i830_overlay_switch_to_crtc (ScrnInfoPtr pScrn, xf86CrtcPtr crtc)
{
    I830Ptr		pI830 = I830PTR(pScrn);
    I830PortPrivPtr	pPriv = GET_PORT_PRIVATE(pScrn);
    I830CrtcPrivatePtr  intel_crtc = crtc->driver_private;
    int			pipeconf_reg = intel_crtc->pipe == 0 ? PIPEACONF : PIPEBCONF;

    if (INREG(pipeconf_reg) & PIPEACONF_DOUBLE_WIDE)
	pPriv->overlayOK = FALSE;
    else
	pPriv->overlayOK = TRUE;
    
    if (!pPriv->overlayOK)
	return;

    /* Check we have an LFP connected */
    if (i830PipeHasType(crtc, I830_OUTPUT_LVDS)) 
    {

	int	vtotal_reg = intel_crtc->pipe ? VTOTAL_A : VTOTAL_B;
	CARD32	size = intel_crtc->pipe ? INREG(PIPEBSRC) : INREG(PIPEASRC);
	CARD32	active;
	CARD32	hsize, vsize;

	hsize = (size >> 16) & 0x7FF;
	vsize = size & 0x7FF;
	active = INREG(vtotal_reg) & 0x7FF;

	if (vsize < active && hsize > 1024)
	    I830SetOneLineModeRatio(pScrn);

	if (pPriv->scaleRatio & 0xFFFE0000) 
	{
	    /* Possible bogus ratio, using in-accurate fallback */
	    xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
		       "Bogus panel fit register, Xvideo positioning may not "
		       "be accurate.\n");
	    xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
		       "Using fallback ratio - was 0x%x, now 0x%x\n",
		       pPriv->scaleRatio,
		       (int)(((float)active * 65536)/(float)vsize));

	    pPriv->scaleRatio = (int)(((float)active * 65536) / (float)vsize);
	}
    }
}
d421 9
a429 7
/*
 * This is more or less the correct way to initalise, update, and shut down
 * the overlay.
 *
 * XXX Need to make sure that the overlay engine is cleanly shutdown in
 * all modes of server exit.
 */
d431 29
a459 40
static void
i830_overlay_on(ScrnInfoPtr pScrn)
{
    I830Ptr		pI830 = I830PTR(pScrn);
    I830OverlayRegPtr	overlay = I830OVERLAYREG(pI830);
    I830PortPrivPtr	pPriv = pI830->adaptor->pPortPrivates[0].ptr;
    Bool		deactivate = FALSE;
    
    if (*pI830->overlayOn)
	return;

    /*
     * On I830, if pipe A is off when the overlayis enabled, it will fail to
     * turn on and blank the entire screen or lock up the ring. Light up pipe
     * A in this case to provide a clock for the overlay hardware
     */
    if (pPriv->current_crtc && i830_crtc_pipe (pPriv->current_crtc) != 0)
	deactivate = i830_pipe_a_require_activate (pScrn);

    overlay->OCMD &= ~OVERLAY_ENABLE;
    BEGIN_LP_RING(6);
    OUT_RING(MI_FLUSH | MI_WRITE_DIRTY_STATE);
    OUT_RING(MI_NOOP);
    OUT_RING(MI_OVERLAY_FLIP | MI_OVERLAY_FLIP_ON);
    if (OVERLAY_NOPHYSICAL(pI830))
	OUT_RING(pI830->overlay_regs->offset | OFC_UPDATE);
    else
	OUT_RING(pI830->overlay_regs->bus_addr | OFC_UPDATE);
    /* Wait for the overlay to light up before attempting to use it */
    OUT_RING(MI_WAIT_FOR_EVENT | MI_WAIT_FOR_OVERLAY_FLIP);
    OUT_RING(MI_NOOP);
    ADVANCE_LP_RING();
    i830WaitSync(pScrn);
    
    /*
     * If we turned pipe A on up above, turn it
     * back off
     */
    if (deactivate)
	i830_pipe_a_require_deactivate (pScrn);
d461 13
a473 2
    OVERLAY_DEBUG("overlay_on\n");
    *pI830->overlayOn = TRUE;
d475 2
a476 2
    overlay->OCMD |= OVERLAY_ENABLE;
}
d478 1
a478 25
static void
i830_overlay_continue(ScrnInfoPtr pScrn, Bool update_filter)
{
    I830Ptr		pI830 = I830PTR(pScrn);
    CARD32		flip_addr;
    I830OverlayRegPtr	overlay = I830OVERLAYREG(pI830);

    if (!*pI830->overlayOn)
	return;

    if (OVERLAY_NOPHYSICAL(pI830))
	flip_addr = pI830->overlay_regs->offset;
    else
	flip_addr = pI830->overlay_regs->bus_addr;
    if (update_filter)
	flip_addr |= OFC_UPDATE;
    OVERLAY_DEBUG ("overlay_continue cmd 0x%08lx -> 0x%08lx sta 0x%08lx\n",
		   overlay->OCMD, INREG(OCMD_REGISTER), INREG(DOVSTA));
    BEGIN_LP_RING(4);
    OUT_RING(MI_FLUSH | MI_WRITE_DIRTY_STATE);
    OUT_RING(MI_NOOP);
    OUT_RING(MI_OVERLAY_FLIP | MI_OVERLAY_FLIP_CONTINUE);
    OUT_RING(flip_addr);
    ADVANCE_LP_RING();
    OVERLAY_DEBUG("overlay_continue\n");
d482 1
a482 1
i830_overlay_off(ScrnInfoPtr pScrn)
d484 28
a511 2
    I830Ptr pI830 = I830PTR(pScrn);
    I830OverlayRegPtr	overlay = I830OVERLAYREG(pI830);
d513 21
a533 2
    if (!*pI830->overlayOn)
	return;
d535 13
a547 38
    /*
     * Wait for overlay to go idle. This has to be
     * separated from the turning off state by a WaitSync
     * to ensure the overlay will not read OCMD early and
     * disable the overlay before the commands here are
     * executed
     */
    {
	BEGIN_LP_RING(2);
	OUT_RING(MI_WAIT_FOR_EVENT | MI_WAIT_FOR_OVERLAY_FLIP);
	OUT_RING(MI_NOOP);
	ADVANCE_LP_RING();
	i830WaitSync(pScrn);
    }
    
    /*
     * Turn overlay off
     */
    {
	overlay->OCMD &= ~OVERLAY_ENABLE;
	OVERLAY_DEBUG ("overlay_off cmd 0x%08lx -> 0x%08lx sta 0x%08lx\n",
		       overlay->OCMD, INREG(OCMD_REGISTER), INREG(DOVSTA));
	BEGIN_LP_RING(6);
	OUT_RING(MI_FLUSH | MI_WRITE_DIRTY_STATE);
	OUT_RING(MI_NOOP);
	OUT_RING(MI_OVERLAY_FLIP | MI_OVERLAY_FLIP_CONTINUE);
	if (OVERLAY_NOPHYSICAL(pI830))
	    OUT_RING(pI830->overlay_regs->offset);
	else
	    OUT_RING(pI830->overlay_regs->bus_addr);
	OUT_RING(MI_WAIT_FOR_EVENT | MI_WAIT_FOR_OVERLAY_FLIP);
	OUT_RING(MI_NOOP);
	ADVANCE_LP_RING();
	i830WaitSync(pScrn);
    }
    *pI830->overlayOn = FALSE;
    OVERLAY_DEBUG("overlay_off\n");
}
d549 1
a549 70
void
I830InitVideo(ScreenPtr pScreen)
{
    ScrnInfoPtr pScrn = xf86Screens[pScreen->myNum];
    I830Ptr pI830 = I830PTR(pScrn);
    XF86VideoAdaptorPtr *adaptors, *newAdaptors = NULL;
    XF86VideoAdaptorPtr overlayAdaptor = NULL, texturedAdaptor = NULL;
    int num_adaptors;

#if 0
    {
	I830OverlayRegRec tmp;

	ErrorF("sizeof I830OverlayRegRec is 0x%x\n", sizeof(I830OverlayRegRec));
	ErrorF("Reserved C, D, E, F, G are %x, %x, %x, %x, %x\n",
	       (unsigned long)&(tmp.RESERVEDC[0]) - (unsigned long)&tmp,
	       (unsigned long)&(tmp.RESERVEDD[0]) - (unsigned long)&tmp,
	       (unsigned long)&(tmp.RESERVEDE[0]) - (unsigned long)&tmp,
	       (unsigned long)&(tmp.RESERVEDF[0]) - (unsigned long)&tmp,
	       (unsigned long)&(tmp.RESERVEDG[0]) - (unsigned long)&tmp);
    }
#endif

    num_adaptors = xf86XVListGenericAdaptors(pScrn, &adaptors);
    /* Give our adaptor list enough space for the overlay and/or texture video
     * adaptors.
     */
    newAdaptors = xalloc((num_adaptors + 2) * sizeof(XF86VideoAdaptorPtr *));
    if (newAdaptors == NULL)
	return;

    memcpy(newAdaptors, adaptors, num_adaptors * sizeof(XF86VideoAdaptorPtr));
    adaptors = newAdaptors;

    /* Add the adaptors supported by our hardware.  First, set up the atoms
     * that will be used by both output adaptors.
     */
    xvBrightness = MAKE_ATOM("XV_BRIGHTNESS");
    xvContrast = MAKE_ATOM("XV_CONTRAST");

    /* Set up textured video if we can do it at this depth and we are on
     * supported hardware.
     */
    if (pScrn->bitsPerPixel >= 16 && (IS_I9XX(pI830) || IS_I965G(pI830)) &&
	!(!IS_I965G(pI830) && pScrn->displayWidth > 2048))
    {
	texturedAdaptor = I830SetupImageVideoTextured(pScreen);
	if (texturedAdaptor != NULL) {
	    adaptors[num_adaptors++] = texturedAdaptor;
	    xf86DrvMsg(pScrn->scrnIndex, X_INFO, "Set up textured video\n");
	} else {
	    xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
		       "Failed to set up textured video\n");
	}
    }

    /* Set up overlay video if we can do it at this depth. */
    if (!IS_I965G(pI830) && pScrn->bitsPerPixel != 8 &&
	pI830->overlay_regs != NULL)
    {
	overlayAdaptor = I830SetupImageVideoOverlay(pScreen);
	if (overlayAdaptor != NULL) {
	    adaptors[num_adaptors++] = overlayAdaptor;
	    xf86DrvMsg(pScrn->scrnIndex, X_INFO, "Set up overlay video\n");
	} else {
	    xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
		       "Failed to set up overlay video\n");
	}
	I830InitOffscreenImages(pScreen);
    }
d551 11
a561 84
    if (num_adaptors)
	xf86XVScreenInit(pScreen, adaptors, num_adaptors);

    xfree(adaptors);
}

static void
I830ResetVideo(ScrnInfoPtr pScrn)
{
    I830Ptr pI830 = I830PTR(pScrn);
    I830PortPrivPtr pPriv = pI830->adaptor->pPortPrivates[0].ptr;
    I830OverlayRegPtr	overlay = I830OVERLAYREG(pI830);

    OVERLAY_DEBUG("I830ResetVideo: base: %p, offset: 0x%lx, obase: %p\n",
		  pI830->FbBase, pI830->overlay_regs->offset, overlay);
    /*
     * Default to maximum image size in YV12
     */

    memset(overlay, 0, sizeof(*overlay));
    overlay->YRGB_VPH = 0;
    overlay->UV_VPH = 0;
    overlay->HORZ_PH = 0;
    overlay->INIT_PHS = 0;
    overlay->DWINPOS = 0;
    overlay->DWINSZ = 0;
    overlay->SWIDTH = 0;
    overlay->SWIDTHSW = 0;
    overlay->SHEIGHT = 0;
    overlay->OCLRC0 = (pPriv->contrast << 18) | (pPriv->brightness & 0xff);
    overlay->OCLRC1 = pPriv->saturation;
#if 0
    overlay->AWINPOS = 0;
    overlay->AWINSZ = 0;
#endif
    overlay->FASTHSCALE = 0;

    /*
     * Enable destination color keying
     */
    switch (pScrn->depth) {
    case 8:
	overlay->DCLRKV = 0;
	overlay->DCLRKM = 0xffffff | DEST_KEY_ENABLE;
	break;
    case 15:
	overlay->DCLRKV = RGB15ToColorKey(pPriv->colorKey);
	overlay->DCLRKM = 0x070707 | DEST_KEY_ENABLE;
	break;
    case 16:
	overlay->DCLRKV = RGB16ToColorKey(pPriv->colorKey);
	overlay->DCLRKM = 0x070307 | DEST_KEY_ENABLE;
	break;
    default:
	overlay->DCLRKV = pPriv->colorKey;
	overlay->DCLRKM = DEST_KEY_ENABLE;
	break;
    }

    overlay->SCLRKVH = 0;
    overlay->SCLRKVL = 0;
    overlay->SCLRKEN = 0;		/* source color key disable */
    overlay->OCONFIG = CC_OUT_8BIT;

    /*
     * Select which pipe the overlay is enabled on.
     */
    overlay->OCONFIG &= ~OVERLAY_PIPE_MASK;
    if (i830_crtc_pipe (pPriv->current_crtc) == 0)
	overlay->OCONFIG |= OVERLAY_PIPE_A;
    else 
	overlay->OCONFIG |= OVERLAY_PIPE_B;

#if 0
    /* 
     * XXX DUMP REGISTER CODE !!!
     * This allows us to dump the complete i845 registers and compare
     * with warm boot situations before we upload our first copy.
     */
    {
	int i;
	for (i = 0x30000; i < 0x31000; i += 4)
	    ErrorF("0x%x 0x%lx\n", i, INREG(i));
    }
d574 18
a591 16
    I830Ptr pI830 = I830PTR(pScrn);
    I830PortPrivPtr pPriv = pI830->adaptor->pPortPrivates[0].ptr;
    CARD32 panelFitControl = INREG(PFIT_CONTROLS);
    int vertScale;

    pPriv->scaleRatio = 0x10000;

    if (panelFitControl & PFIT_ON_MASK) {
	if (panelFitControl & PFIT_AUTOVSCALE_MASK) {
	    vertScale = INREG(PFIT_AUTOSCALE_RATIO) >> 16;
	} else {
	    vertScale = INREG(PFIT_PROGRAMMED_SCALE_RATIO) >> 16;
	}

	if (vertScale != 0)
	    pPriv->scaleRatio = ((double) 0x10000 / (double)vertScale) * 0x10000;
d593 2
a594 4
	pPriv->oneLineMode = TRUE;

	xf86DrvMsg(pScrn->scrnIndex, X_INFO, "Enabling Xvideo one-line mode\n");
    }
d596 2
a597 2
    if (pPriv->scaleRatio == 0x10000)
	pPriv->oneLineMode = FALSE;
d602 7
a608 7
    elt &= 0xff;
    eltPrev &= 0xff;
    if (elt < eltPrev)
	elt = eltPrev;
    else if ((elt - eltPrev) > 0x7e)
	elt = eltPrev + 0x7e;
    return elt;
d613 4
a616 4
    return (I830BoundGammaElt (gamma >> 24, gammaPrev >> 24) << 24 |
	    I830BoundGammaElt (gamma >> 16, gammaPrev >> 16) << 16 |
	    I830BoundGammaElt (gamma >>  8, gammaPrev >>  8) <<  8 |
	    I830BoundGammaElt (gamma      , gammaPrev      ));
d622 25
a646 29
    I830Ptr pI830 = I830PTR(pScrn);
    I830PortPrivPtr pPriv = pI830->adaptor->pPortPrivates[0].ptr;
    CARD32   gamma0 = pPriv->gamma0;
    CARD32   gamma1 = pPriv->gamma1;
    CARD32   gamma2 = pPriv->gamma2;
    CARD32   gamma3 = pPriv->gamma3;
    CARD32   gamma4 = pPriv->gamma4;
    CARD32   gamma5 = pPriv->gamma5;

#if 0
    ErrorF ("Original gamma: 0x%lx 0x%lx 0x%lx 0x%lx 0x%lx 0x%lx\n",
	    gamma0, gamma1, gamma2, gamma3, gamma4, gamma5);
#endif
    gamma1 = I830BoundGamma (gamma1, gamma0);
    gamma2 = I830BoundGamma (gamma2, gamma1);
    gamma3 = I830BoundGamma (gamma3, gamma2);
    gamma4 = I830BoundGamma (gamma4, gamma3);
    gamma5 = I830BoundGamma (gamma5, gamma4);
#if 0
    ErrorF ("Bounded  gamma: 0x%lx 0x%lx 0x%lx 0x%lx 0x%lx 0x%lx\n",
	    gamma0, gamma1, gamma2, gamma3, gamma4, gamma5);
#endif

    OUTREG(OGAMC5, gamma5);
    OUTREG(OGAMC4, gamma4);
    OUTREG(OGAMC3, gamma3);
    OUTREG(OGAMC2, gamma2);
    OUTREG(OGAMC1, gamma1);
    OUTREG(OGAMC0, gamma0);
d652 97
a748 111
    ScrnInfoPtr pScrn = xf86Screens[pScreen->myNum];
    I830Ptr pI830 = I830PTR(pScrn);
    XF86VideoAdaptorPtr adapt;
    I830PortPrivPtr pPriv;
    XF86AttributePtr att;

    OVERLAY_DEBUG("I830SetupImageVideoOverlay\n");

    if (!(adapt = xcalloc(1, sizeof(XF86VideoAdaptorRec) +
			  sizeof(I830PortPrivRec) + sizeof(DevUnion))))
	return NULL;

    adapt->type = XvWindowMask | XvInputMask | XvImageMask;
    adapt->flags = VIDEO_OVERLAID_IMAGES /*| VIDEO_CLIP_TO_VIEWPORT*/;
    adapt->name = "Intel(R) Video Overlay";
    adapt->nEncodings = 1;
    adapt->pEncodings = DummyEncoding;
    /* update the DummyEncoding for these two chipsets */
    if (IS_845G(pI830) || IS_I830(pI830)) {
	adapt->pEncodings->width = IMAGE_MAX_WIDTH_LEGACY;
	adapt->pEncodings->height = IMAGE_MAX_HEIGHT_LEGACY;
    }
    adapt->nFormats = NUM_FORMATS;
    adapt->pFormats = Formats;
    adapt->nPorts = 1;
    adapt->pPortPrivates = (DevUnion *) (&adapt[1]);

    pPriv = (I830PortPrivPtr) (&adapt->pPortPrivates[1]);

    adapt->pPortPrivates[0].ptr = (pointer) (pPriv);
    adapt->nAttributes = NUM_ATTRIBUTES;
    adapt->nAttributes += CLONE_ATTRIBUTES;
    if (IS_I9XX(pI830))
	adapt->nAttributes += GAMMA_ATTRIBUTES; /* has gamma */
    adapt->pAttributes = xnfalloc(sizeof(XF86AttributeRec) * adapt->nAttributes);
    /* Now copy the attributes */
    att = adapt->pAttributes;
    memcpy((char *)att, (char*)Attributes, sizeof(XF86AttributeRec)* NUM_ATTRIBUTES);
    att+=NUM_ATTRIBUTES;
    memcpy((char*)att, (char*)CloneAttributes, sizeof(XF86AttributeRec) * CLONE_ATTRIBUTES);
    att+=CLONE_ATTRIBUTES;
    if (IS_I9XX(pI830)) {
	memcpy((char*)att, (char*)GammaAttributes, sizeof(XF86AttributeRec) * GAMMA_ATTRIBUTES);
	att+=GAMMA_ATTRIBUTES;
    }
    adapt->nImages = NUM_IMAGES;
    adapt->pImages = Images;
    adapt->PutVideo = NULL;
    adapt->PutStill = NULL;
    adapt->GetVideo = NULL;
    adapt->GetStill = NULL;
    adapt->StopVideo = I830StopVideo;
    adapt->SetPortAttribute = I830SetPortAttribute;
    adapt->GetPortAttribute = I830GetPortAttribute;
    adapt->QueryBestSize = I830QueryBestSize;
    adapt->PutImage = I830PutImage;
    adapt->QueryImageAttributes = I830QueryImageAttributesOverlay;

    pPriv->textured = FALSE;
    pPriv->colorKey = pI830->colorKey & ((1 << pScrn->depth) - 1);
    pPriv->videoStatus = 0;
    pPriv->brightness = 0;
    pPriv->contrast = 64;
    pPriv->saturation = 128;
    pPriv->current_crtc = NULL;
    pPriv->desired_crtc = NULL;
    pPriv->buf = NULL;
    pPriv->currentBuf = 0;
    pPriv->gamma5 = 0xc0c0c0;
    pPriv->gamma4 = 0x808080;
    pPriv->gamma3 = 0x404040;
    pPriv->gamma2 = 0x202020;
    pPriv->gamma1 = 0x101010;
    pPriv->gamma0 = 0x080808;
    pPriv->doubleBuffer = 1;

    /* gotta uninit this someplace */
    REGION_NULL(pScreen, &pPriv->clip);

    pI830->adaptor = adapt;

    /* With LFP's we need to detect whether we're in One Line Mode, which
     * essentially means a resolution greater than 1024x768, and fix up
     * the scaler accordingly. */
    pPriv->scaleRatio = 0x10000;
    pPriv->oneLineMode = FALSE;

    /*
     * Initialise pPriv->overlayOK.  Set it to TRUE here so that a warning will
     * be generated if i830_crtc_dpms_video() sets it to FALSE during mode
     * setup.
     */
    pPriv->overlayOK = TRUE;

    xvColorKey = MAKE_ATOM("XV_COLORKEY");
    xvBrightness = MAKE_ATOM("XV_BRIGHTNESS");
    xvContrast = MAKE_ATOM("XV_CONTRAST");
    xvSaturation = MAKE_ATOM("XV_SATURATION");
    xvDoubleBuffer = MAKE_ATOM("XV_DOUBLE_BUFFER");

    /* Allow the pipe to be switched from pipe A to B when in clone mode */
    xvPipe = MAKE_ATOM("XV_PIPE");

    if (IS_I9XX(pI830)) {
	xvGamma0 = MAKE_ATOM("XV_GAMMA0");
	xvGamma1 = MAKE_ATOM("XV_GAMMA1");
	xvGamma2 = MAKE_ATOM("XV_GAMMA2");
	xvGamma3 = MAKE_ATOM("XV_GAMMA3");
	xvGamma4 = MAKE_ATOM("XV_GAMMA4");
	xvGamma5 = MAKE_ATOM("XV_GAMMA5");
    }
d750 11
a760 1
    I830ResetVideo(pScrn);
d762 1
a762 1
    I830UpdateGamma(pScrn);
d764 3
a766 1
    return adapt;
d772 67
a838 58
    XF86VideoAdaptorPtr adapt;
    XF86AttributePtr attrs;
    I830PortPrivPtr portPrivs;
    DevUnion *devUnions;
    int nports = 16, i;
    int nAttributes;

    OVERLAY_DEBUG("I830SetupImageVideoOverlay\n");

    nAttributes = NUM_TEXTURED_ATTRIBUTES;

    adapt = xcalloc(1, sizeof(XF86VideoAdaptorRec));
    portPrivs = xcalloc(nports, sizeof(I830PortPrivRec));
    devUnions = xcalloc(nports, sizeof(DevUnion));
    attrs = xcalloc(nAttributes, sizeof(XF86AttributeRec));
    if (adapt == NULL || portPrivs == NULL || devUnions == NULL ||
	attrs == NULL)
    {
	xfree(adapt);
	xfree(portPrivs);
	xfree(devUnions);
	xfree(attrs);
	return NULL;
    }

    adapt->type = XvWindowMask | XvInputMask | XvImageMask;
    adapt->flags = 0;
    adapt->name = "Intel(R) Textured Video";
    adapt->nEncodings = 1;
    adapt->pEncodings = DummyEncoding;
    adapt->nFormats = NUM_FORMATS;
    adapt->pFormats = Formats;
    adapt->nPorts = nports;
    adapt->pPortPrivates = devUnions;
    adapt->nAttributes = nAttributes;
    adapt->pAttributes = attrs;
    memcpy(attrs, TexturedAttributes, nAttributes * sizeof(XF86AttributeRec));
    adapt->nImages = NUM_IMAGES;
    adapt->pImages = Images;
    adapt->PutVideo = NULL;
    adapt->PutStill = NULL;
    adapt->GetVideo = NULL;
    adapt->GetStill = NULL;
    adapt->StopVideo = I830StopVideo;
    adapt->SetPortAttribute = I830SetPortAttribute;
    adapt->GetPortAttribute = I830GetPortAttribute;
    adapt->QueryBestSize = I830QueryBestSize;
    adapt->PutImage = I830PutImage;
    adapt->QueryImageAttributes = I830QueryImageAttributesTextured;

    for (i = 0; i < nports; i++) {
	I830PortPrivPtr pPriv = &portPrivs[i];

	pPriv->textured = TRUE;
	pPriv->videoStatus = 0;
	pPriv->buf = NULL;
	pPriv->currentBuf = 0;
	pPriv->doubleBuffer = 0;
d840 2
a841 2
	/* gotta uninit this someplace, XXX: shouldn't be necessary for textured */
	REGION_NULL(pScreen, &pPriv->clip);
d843 2
a844 2
	adapt->pPortPrivates[i].ptr = (pointer) (pPriv);
    }
d846 1
a846 1
    return adapt;
d852 2
a853 2
    int *dataA, *dataB;
    int num;
d855 18
a872 18
    num = REGION_NUM_RECTS(A);
    if (num != REGION_NUM_RECTS(B))
	return FALSE;

    if ((A->extents.x1 != B->extents.x1) ||
	(A->extents.x2 != B->extents.x2) ||
	(A->extents.y1 != B->extents.y1) || (A->extents.y2 != B->extents.y2))
	return FALSE;

    dataA = (int *)REGION_RECTS(A);
    dataB = (int *)REGION_RECTS(B);

    while (num--) {
	if ((dataA[0] != dataB[0]) || (dataA[1] != dataB[1]))
	    return FALSE;
	dataA += 2;
	dataB += 2;
    }
d874 1
a874 1
    return TRUE;
d880 2
a881 2
    I830PortPrivPtr pPriv = (I830PortPrivPtr) data;
    I830Ptr pI830 = I830PTR(pScrn);
d883 2
a884 2
    if (pPriv->textured)
	return;
d886 1
a886 1
    OVERLAY_DEBUG("I830StopVideo\n");
d888 23
a910 20
    REGION_EMPTY(pScrn->pScreen, &pPriv->clip);

    if (shutdown) {
	if (pPriv->videoStatus & CLIENT_VIDEO_ON) {
	    i830_overlay_off(pScrn);
	    if (pI830->entityPrivate)
		pI830->entityPrivate->XvInUse = -1;
	}
	/* Sync before freeing the buffer, because the pages will be unbound.
	 */
	I830Sync(pScrn);
	i830_free_memory(pScrn, pPriv->buf);
	pPriv->buf = NULL;
	pPriv->videoStatus = 0;
    } else {
	if (pPriv->videoStatus & CLIENT_VIDEO_ON) {
	    pPriv->videoStatus |= OFF_TIMER;
	    pPriv->offTime = currentTime.milliseconds + OFF_DELAY;
	}
    }
d918 90
a1007 90
    I830PortPrivPtr pPriv = (I830PortPrivPtr) data;
    I830Ptr pI830 = I830PTR(pScrn);
    I830OverlayRegPtr overlay;

    if (pPriv->textured) {
	/* XXX: Currently the brightness/saturation attributes aren't hooked up.
	 * However, apps expect them to be there, and the spec seems to let us
	 * sneak out of actually implementing them for now.
	 */
	return Success;
    }

    overlay = I830OVERLAYREG(pI830);

    if (attribute == xvBrightness) {
	if ((value < -128) || (value > 127))
	    return BadValue;
	pPriv->brightness = value;
	overlay->OCLRC0 = (pPriv->contrast << 18) | (pPriv->brightness & 0xff);
	OVERLAY_DEBUG("BRIGHTNESS\n");
	i830_overlay_continue (pScrn, FALSE);
    } else if (attribute == xvContrast) {
	if ((value < 0) || (value > 255))
	    return BadValue;
	pPriv->contrast = value;
	overlay->OCLRC0 = (pPriv->contrast << 18) | (pPriv->brightness & 0xff);
	OVERLAY_DEBUG("CONTRAST\n");
	i830_overlay_continue (pScrn, FALSE);
    } else if (attribute == xvSaturation) {
	if ((value < 0) || (value > 1023))
	    return BadValue;
	pPriv->saturation = value;
	overlay->OCLRC1 = pPriv->saturation;
	i830_overlay_continue (pScrn, FALSE);
    } else if (attribute == xvPipe) {
	xf86CrtcConfigPtr   xf86_config = XF86_CRTC_CONFIG_PTR(pScrn);
	if ((value < -1) || (value > xf86_config->num_crtc))
	    return BadValue;
	if (value < 0)
	    pPriv->desired_crtc = NULL;
	else
	    pPriv->desired_crtc = xf86_config->crtc[value];
	/*
	 * Leave this to be updated at the next frame
	 */
    } else if (attribute == xvGamma0 && (IS_I9XX(pI830))) {
	pPriv->gamma0 = value; 
    } else if (attribute == xvGamma1 && (IS_I9XX(pI830))) {
	pPriv->gamma1 = value;
    } else if (attribute == xvGamma2 && (IS_I9XX(pI830))) {
	pPriv->gamma2 = value;
    } else if (attribute == xvGamma3 && (IS_I9XX(pI830))) {
	pPriv->gamma3 = value;
    } else if (attribute == xvGamma4 && (IS_I9XX(pI830))) {
	pPriv->gamma4 = value;
    } else if (attribute == xvGamma5 && (IS_I9XX(pI830))) {
	pPriv->gamma5 = value;
    } else if (attribute == xvColorKey) {
	pPriv->colorKey = value;
	switch (pScrn->depth) {
	case 16:
	    overlay->DCLRKV = RGB16ToColorKey(pPriv->colorKey);
	    break;
	case 15:
	    overlay->DCLRKV = RGB15ToColorKey(pPriv->colorKey);
	    break;
	default:
	    overlay->DCLRKV = pPriv->colorKey;
	    break;
	}
	OVERLAY_DEBUG("COLORKEY\n");
	i830_overlay_continue (pScrn, FALSE);
	REGION_EMPTY(pScrn->pScreen, &pPriv->clip);
    } else if(attribute == xvDoubleBuffer) {
	if ((value < 0) || (value > 1))
	    return BadValue;
	/* Do not allow buffer change while playing video */
	if(!*pI830->overlayOn)
	    pPriv->doubleBuffer = value;
    } else
	return BadMatch;

    /* Ensure that the overlay is off, ready for updating */
    if ((attribute == xvGamma0 ||
	 attribute == xvGamma1 ||
	 attribute == xvGamma2 ||
	 attribute == xvGamma3 ||
	 attribute == xvGamma4 ||
	 attribute == xvGamma5) && (IS_I9XX(pI830))) {
	OVERLAY_DEBUG("GAMMA\n");
d1009 1
a1009 1
    }
d1011 1
a1011 1
    return Success;
d1018 2
a1019 2
    I830Ptr pI830 = I830PTR(pScrn);
    I830PortPrivPtr pPriv = (I830PortPrivPtr) data;
d1021 24
a1044 33
    if (attribute == xvBrightness) {
	*value = pPriv->brightness;
    } else if (attribute == xvContrast) {
	*value = pPriv->contrast;
    } else if (attribute == xvSaturation) {
	*value = pPriv->saturation;
    } else if (attribute == xvPipe) {
	int		c;
	xf86CrtcConfigPtr	xf86_config = XF86_CRTC_CONFIG_PTR(pScrn);
	for (c = 0; c < xf86_config->num_crtc; c++)
	    if (xf86_config->crtc[c] == pPriv->desired_crtc)
		break;
	if (c == xf86_config->num_crtc)
	    c = -1;
	*value = c;
    } else if (attribute == xvGamma0 && (IS_I9XX(pI830))) {
	*value = pPriv->gamma0;
    } else if (attribute == xvGamma1 && (IS_I9XX(pI830))) {
	*value = pPriv->gamma1;
    } else if (attribute == xvGamma2 && (IS_I9XX(pI830))) {
	*value = pPriv->gamma2;
    } else if (attribute == xvGamma3 && (IS_I9XX(pI830))) {
	*value = pPriv->gamma3;
    } else if (attribute == xvGamma4 && (IS_I9XX(pI830))) {
	*value = pPriv->gamma4;
    } else if (attribute == xvGamma5 && (IS_I9XX(pI830))) {
	*value = pPriv->gamma5;
    } else if (attribute == xvColorKey) {
	*value = pPriv->colorKey;
    } else if (attribute == xvDoubleBuffer) {
	*value = pPriv->doubleBuffer;
    } else 
	return BadMatch;
d1046 1
a1046 1
    return Success;
d1056 4
a1059 4
    if (vid_w > (drw_w << 1))
	drw_w = vid_w >> 1;
    if (vid_h > (drw_h << 1))
	drw_h = vid_h >> 1;
d1061 2
a1062 2
    *p_w = drw_w;
    *p_h = drw_h;
d1071 29
a1099 32
    I830Ptr pI830 = I830PTR(pScrn);
    unsigned char *src, *dst;
    int i,j;
    unsigned char *s;

#if 0
    ErrorF("I830CopyPackedData: (%d,%d) (%d,%d)\n"
	   "srcPitch: %d, dstPitch: %d\n", top, left, h, w,
	   srcPitch, dstPitch);
#endif

    src = buf + (top * srcPitch) + (left << 1);

    if (pPriv->currentBuf == 0)
	dst = pI830->FbBase + pPriv->YBuf0offset;
    else
	dst = pI830->FbBase + pPriv->YBuf1offset;

    switch (pI830->rotation) {
    case RR_Rotate_0:
	w <<= 1;
	for (i = 0; i < h; i++) {
	    memcpy(dst, src, w);
	    src += srcPitch;
	    dst += dstPitch;
	}
	break;
    case RR_Rotate_90:
	h <<= 1;
	for (i = 0; i < h; i+=2) {
	    s = src;
	    for (j = 0; j < w; j++) {
d1101 1
a1101 1
		dst[(i + 0) + ((w - j - 1) * dstPitch)] = *s++; 
d1103 7
a1109 7
	    }
	    src += srcPitch;
	}
	h >>= 1;
	src = buf + (top * srcPitch) + (left << 1);
	for (i = 0; i < h; i+=2) {
	    for (j = 0; j < w; j+=2) {
d1116 21
a1136 21
	    }
	}
	break;
    case RR_Rotate_180:
	w <<= 1;
	for (i = 0; i < h; i++) {
	    s = src;
	    for (j = 0; j < w; j+=4) {
		dst[(w - j - 4) + ((h - i - 1) * dstPitch)] = *s++;
		dst[(w - j - 3) + ((h - i - 1) * dstPitch)] = *s++;
		dst[(w - j - 2) + ((h - i - 1) * dstPitch)] = *s++;
		dst[(w - j - 1) + ((h - i - 1) * dstPitch)] = *s++;
	    }
	    src += srcPitch;
	}
	break;
    case RR_Rotate_270:
	h <<= 1;
	for (i = 0; i < h; i+=2) {
	    s = src;
	    for (j = 0; j < w; j++) {
d1138 1
a1138 1
		dst[(h - i - 2) + (j * dstPitch)] = *s++;
d1140 7
a1146 7
	    }
	    src += srcPitch;
	}
	h >>= 1;
	src = buf + (top * srcPitch) + (left << 1);
	for (i = 0; i < h; i+=2) {
	    for (j = 0; j < w; j+=2) {
d1153 4
a1156 4
	    }
	}
	break;
    }
d1167 49
a1215 49
    I830Ptr pI830 = I830PTR(pScrn);
    CARD8 *dst1, *srcy, *srcu, *srcv;
    int y;

    if (pPriv->currentBuf == 0)
	dst1 = pI830->FbBase + pPriv->YBuf0offset;
    else
	dst1 = pI830->FbBase + pPriv->YBuf1offset;

    srcy = buf + (top * srcPitch) + left;
    if (id == FOURCC_YV12) {
	srcu = buf + (srcH * srcPitch) + ((top / 2) * srcPitch2) + (left / 2);
	srcv = buf + (srcH * srcPitch) + ((srcH / 2) * srcPitch2) +
	((top / 2) * srcPitch2) + (left / 2);
    } else {
	srcv = buf + (srcH * srcPitch) + ((top / 2) * srcPitch2) + (left / 2);
	srcu = buf + (srcH * srcPitch) + ((srcH / 2) * srcPitch2) +
	((top / 2) * srcPitch2) + (left / 2);
    }

    for (y = 0; y < h; y++) {
	CARD32 *dst = (CARD32 *)dst1;
	CARD8 *sy = srcy;
	CARD8 *su = srcu;
	CARD8 *sv = srcv;
	int i;

	i = w / 2;
	while(i > 4) {
	    dst[0] = sy[0] | (sy[1] << 16) | (sv[0] << 8) | (su[0] << 24);
	    dst[1] = sy[2] | (sy[3] << 16) | (sv[1] << 8) | (su[1] << 24);
	    dst[2] = sy[4] | (sy[5] << 16) | (sv[2] << 8) | (su[2] << 24);
	    dst[3] = sy[6] | (sy[7] << 16) | (sv[3] << 8) | (su[3] << 24);
	    dst += 4; su += 4; sv += 4; sy += 8;
	    i -= 4;
	}
	while(i--) {
	    dst[0] = sy[0] | (sy[1] << 16) | (sv[0] << 8) | (su[0] << 24);
	    dst++; su++; sv++;
	    sy += 2;
	}

	dst1 += dstPitch;
	srcy += srcPitch;
	if (y & 1) {
	    srcu += srcPitch2;
	    srcv += srcPitch2;
	}	
    }
d1224 5
a1228 5
    I830Ptr pI830 = I830PTR(pScrn);
    int i, j = 0;
    unsigned char *src1, *src2, *src3, *dst1, *dst2, *dst3;
    unsigned char *s;
    int dstPitch2 = dstPitch << 1;
d1230 2
a1231 4
#if 0
    ErrorF("I830CopyPlanarData: srcPitch %d, srcPitch %d, dstPitch %d\n"
	   "nlines %d, npixels %d, top %d, left %d\n",
	   srcPitch, srcPitch2, dstPitch,
a1232 1
#endif
d1234 152
a1385 158
    /* Copy Y data */
    src1 = buf + (top * srcPitch) + left;
#if 0
    ErrorF("src1 is %p, offset is %ld\n", src1,
	   (unsigned long)src1 - (unsigned long)buf);
#endif
    if (pPriv->currentBuf == 0)
	dst1 = pI830->FbBase + pPriv->YBuf0offset;
    else
	dst1 = pI830->FbBase + pPriv->YBuf1offset;

    switch (pI830->rotation) {
    case RR_Rotate_0:
	for (i = 0; i < h; i++) {
	    memcpy(dst1, src1, w);
	    src1 += srcPitch;
	    dst1 += dstPitch2;
	}
	break;
    case RR_Rotate_90:
	for (i = 0; i < h; i++) {
	    s = src1;
	    for (j = 0; j < w; j++) {
		dst1[(i) + ((w - j - 1) * dstPitch2)] = *s++;
	    }
	    src1 += srcPitch;
	}
	break;
    case RR_Rotate_180:
	for (i = 0; i < h; i++) {
	    s = src1;
	    for (j = 0; j < w; j++) {
		dst1[(w - j - 1) + ((h - i - 1) * dstPitch2)] = *s++;
	    }
	    src1 += srcPitch;
	}
	break;
    case RR_Rotate_270:
	for (i = 0; i < h; i++) {
	    s = src1;
	    for (j = 0; j < w; j++) {
		dst1[(h - i - 1) + (j * dstPitch2)] = *s++;
	    }
	    src1 += srcPitch;
	}
	break;
    }

    /* Copy V data for YV12, or U data for I420 */
    src2 = buf + (srcH * srcPitch) + ((top * srcPitch) >> 2) + (left >> 1);
#if 0
    ErrorF("src2 is %p, offset is %ld\n", src2,
	   (unsigned long)src2 - (unsigned long)buf);
#endif
    if (pPriv->currentBuf == 0) {
	if (id == FOURCC_I420)
	    dst2 = pI830->FbBase + pPriv->UBuf0offset;
	else
	    dst2 = pI830->FbBase + pPriv->VBuf0offset;
    } else {
	if (id == FOURCC_I420)
	    dst2 = pI830->FbBase + pPriv->UBuf1offset;
	else
	    dst2 = pI830->FbBase + pPriv->VBuf1offset;
    }

    switch (pI830->rotation) {
    case RR_Rotate_0:
	for (i = 0; i < h / 2; i++) {
	    memcpy(dst2, src2, w / 2);
	    src2 += srcPitch2;
	    dst2 += dstPitch;
	}
	break;
    case RR_Rotate_90:
	for (i = 0; i < (h/2); i++) {
	    s = src2;
	    for (j = 0; j < (w/2); j++) {
		dst2[(i) + (((w/2) - j - 1) * (dstPitch))] = *s++;
	    }
	    src2 += srcPitch2;
	}
	break;
    case RR_Rotate_180:
	for (i = 0; i < (h/2); i++) {
	    s = src2;
	    for (j = 0; j < (w/2); j++) {
		dst2[((w/2) - j - 1) + (((h/2) - i - 1) * dstPitch)] = *s++;
	    }
	    src2 += srcPitch2;
	}
	break;
    case RR_Rotate_270:
	for (i = 0; i < (h/2); i++) {
	    s = src2;
	    for (j = 0; j < (w/2); j++) {
		dst2[((h/2) - i - 1) + (j * dstPitch)] = *s++;
	    }
	    src2 += srcPitch2;
	}
	break;
    }

    /* Copy U data for YV12, or V data for I420 */
    src3 = buf + (srcH * srcPitch) + ((srcH >> 1) * srcPitch2) +
    ((top * srcPitch) >> 2) + (left >> 1);
#if 0
    ErrorF("src3 is %p, offset is %ld\n", src3,
	   (unsigned long)src3 - (unsigned long)buf);
#endif
    if (pPriv->currentBuf == 0) {
	if (id == FOURCC_I420)
	    dst3 = pI830->FbBase + pPriv->VBuf0offset;
	else
	    dst3 = pI830->FbBase + pPriv->UBuf0offset;
    } else {
	if (id == FOURCC_I420)
	    dst3 = pI830->FbBase + pPriv->VBuf1offset;
	else
	    dst3 = pI830->FbBase + pPriv->UBuf1offset;
    }

    switch (pI830->rotation) {
    case RR_Rotate_0:
	for (i = 0; i < h / 2; i++) {
	    memcpy(dst3, src3, w / 2);
	    src3 += srcPitch2;
	    dst3 += dstPitch;
	}
	break;
    case RR_Rotate_90:
	for (i = 0; i < (h/2); i++) {
	    s = src3;
	    for (j = 0; j < (w/2); j++) {
		dst3[(i) + (((w/2) - j - 1) * (dstPitch))] = *s++;
	    }
	    src3 += srcPitch2;
	}
	break;
    case RR_Rotate_180:
	for (i = 0; i < (h/2); i++) {
	    s = src3;
	    for (j = 0; j < (w/2); j++) {
		dst3[((w/2) - j - 1) + (((h/2) - i - 1) * dstPitch)] = *s++;
	    }
	    src3 += srcPitch2;
	}
	break;
    case RR_Rotate_270:
	for (i = 0; i < (h/2); i++) {
	    s = src3;
	    for (j = 0; j < (w/2); j++) {
		dst3[((h/2) - i - 1) + (j * dstPitch)] = *s++;
	    }
	    src3 += srcPitch2;
	}
	break;
    }
d1389 3
a1391 3
    CARD8 sign;
    CARD16 mantissa;
    CARD8 exponent;
d1397 38
a1434 38
    int maxVal, icoeff, res;
    int sign;
    double c;

    sign = 0;
    maxVal = 1 << mantSize;
    c = *coeff;
    if (c < 0.0) {
	sign = 1;
	c = -c;
    }

    res = 12 - mantSize;
    if ((icoeff = (int)(c * 4 * maxVal + 0.5)) < maxVal) {
	pCoeff[pos].exponent = 3;
	pCoeff[pos].mantissa = icoeff << res;
	*coeff = (double)icoeff / (double)(4 * maxVal);
    } else if ((icoeff = (int)(c * 2 * maxVal + 0.5)) < maxVal) {
	pCoeff[pos].exponent = 2;
	pCoeff[pos].mantissa = icoeff << res;
	*coeff = (double)icoeff / (double)(2 * maxVal);
    } else if ((icoeff = (int)(c * maxVal + 0.5)) < maxVal) {
	pCoeff[pos].exponent = 1;
	pCoeff[pos].mantissa = icoeff << res;
	*coeff = (double)icoeff / (double)(maxVal);
    } else if ((icoeff = (int)(c * maxVal * 0.5 + 0.5)) < maxVal) {
	pCoeff[pos].exponent = 0;
	pCoeff[pos].mantissa = icoeff << res;
	*coeff = (double)icoeff / (double)(maxVal / 2);
    } else {
	/* Coeff out of range */
	return FALSE;
    }

    pCoeff[pos].sign = sign;
    if (sign)
	*coeff = -(*coeff);
    return TRUE;
d1440 65
a1504 43
    int i, j, j1, num, pos, mantSize;
    double pi = 3.1415926535, val, sinc, window, sum;
    double rawCoeff[MAX_TAPS * 32], coeffs[N_PHASES][MAX_TAPS];
    double diff;
    int tapAdjust[MAX_TAPS], tap2Fix;
    Bool isVertAndUV;

    if (isHoriz)
	mantSize = 7;
    else
	mantSize = 6;

    isVertAndUV = !isHoriz && !isY;
    num = taps * 16;
    for (i = 0; i < num  * 2; i++) {
	val = (1.0 / fCutoff) * taps * pi * (i - num) / (2 * num);
	if (val == 0.0)
	    sinc = 1.0;
	else
	    sinc = sin(val) / val;

	/* Hamming window */
	window = (0.5 - 0.5 * cos(i * pi / num));
	rawCoeff[i] = sinc * window;
    }

    for (i = 0; i < N_PHASES; i++) {
	/* Normalise the coefficients. */
	sum = 0.0;
	for (j = 0; j < taps; j++) {
	    pos = i + j * 32;
	    sum += rawCoeff[pos];
	}
	for (j = 0; j < taps; j++) {
	    pos = i + j * 32;
	    coeffs[i][j] = rawCoeff[pos] / sum;
	}

	/* Set the register values. */
	for (j = 0; j < taps; j++) {
	    pos = j + i * taps;
	    if ((j == (taps - 1) / 2) && !isVertAndUV)
		SetCoeffRegs(&coeffs[i][j], mantSize + 2, pCoeff, pos);
d1506 1
a1506 2
		SetCoeffRegs(&coeffs[i][j], mantSize, pCoeff, pos);
	}
d1508 8
a1515 29
	tapAdjust[0] = (taps - 1) / 2;
	for (j = 1, j1 = 1; j <= tapAdjust[0]; j++, j1++) {
	    tapAdjust[j1] = tapAdjust[0] - j;
	    tapAdjust[++j1] = tapAdjust[0] + j;
	}

	/* Adjust the coefficients. */
	sum = 0.0;
	for (j = 0; j < taps; j++)
	    sum += coeffs[i][j];
	if (sum != 1.0) {
	    for (j1 = 0; j1 < taps; j1++) {
		tap2Fix = tapAdjust[j1];
		diff = 1.0 - sum;
		coeffs[i][tap2Fix] += diff;
		pos = tap2Fix + i * taps;
		if ((tap2Fix == (taps - 1) / 2) && !isVertAndUV)
		    SetCoeffRegs(&coeffs[i][tap2Fix], mantSize + 2, pCoeff, pos);
		else
		    SetCoeffRegs(&coeffs[i][tap2Fix], mantSize, pCoeff, pos);

		sum = 0.0;
		for (j = 0; j < taps; j++)
		    sum += coeffs[i][j];
		if (sum == 1.0)
		    break;
	    }
	}
    }
d1519 576
a2094 9
i830_box_intersect (BoxPtr dest, BoxPtr a, BoxPtr b)
{
    dest->x1 = a->x1 > b->x1 ? a->x1 : b->x1;
    dest->x2 = a->x2 < b->x2 ? a->x2 : b->x2;
    dest->y1 = a->y1 > b->y1 ? a->y1 : b->y1;
    dest->y2 = a->y2 < b->y2 ? a->y2 : b->y2;
    if (dest->x1 >= dest->x2 || dest->y1 >= dest->y2)
	dest->x1 = dest->x2 = dest->y1 = dest->y2 = 0;
}
d2096 2
a2097 13
static void
i830_crtc_box (xf86CrtcPtr crtc, BoxPtr crtc_box)
{
    if (crtc->enabled)
    {
	crtc_box->x1 = crtc->x;
	crtc_box->x2 = crtc->x + xf86ModeWidth (&crtc->mode, crtc->rotation);
	crtc_box->y1 = crtc->y;
	crtc_box->y2 = crtc->y + xf86ModeHeight (&crtc->mode, crtc->rotation);
    }
    else
	crtc_box->x1 = crtc_box->x2 = crtc_box->y1 = crtc_box->y2 = 0;
}
d2099 3
a2101 5
static int
i830_box_area (BoxPtr box)
{
    return (int) (box->x2 - box->x1) * (int) (box->y2 - box->y1);
}
d2104 3
a2106 3
 * Return the crtc covering 'box'. If two crtcs cover a portion of
 * 'box', then prefer 'desired'. If 'desired' is NULL, then prefer the crtc
 * with greater coverage
d2109 19
a2127 37
static xf86CrtcPtr
i830_covering_crtc (ScrnInfoPtr pScrn,
		    BoxPtr	box,
		    xf86CrtcPtr desired,
		    BoxPtr	crtc_box_ret)
{
    xf86CrtcConfigPtr   xf86_config = XF86_CRTC_CONFIG_PTR(pScrn);
    xf86CrtcPtr		crtc, best_crtc;
    int			coverage, best_coverage;
    int			c;
    BoxRec		crtc_box, cover_box;

    best_crtc = NULL;
    best_coverage = 0;
    crtc_box_ret->x1 = 0;
    crtc_box_ret->x2 = 0;
    crtc_box_ret->y1 = 0;
    crtc_box_ret->y2 = 0;
    for (c = 0; c < xf86_config->num_crtc; c++)
    {
	crtc = xf86_config->crtc[c];
	i830_crtc_box (crtc, &crtc_box);
	i830_box_intersect (&cover_box, &crtc_box, box);
	coverage = i830_box_area (&cover_box);
	if (coverage && crtc == desired)
	{
	    *crtc_box_ret = crtc_box;
	    return crtc;
	}
	if (coverage > best_coverage)
	{
	    *crtc_box_ret = crtc_box;
	    best_crtc = crtc;
	    best_coverage = coverage;
	}
    }
    return best_crtc;
d2130 16
a2145 3
static int
i830_swidth (I830Ptr pI830, unsigned int offset,
	     unsigned int width, unsigned int mask, int shift)
d2147 11
a2157 5
    int	swidth = ((offset + width + mask) >> shift) - (offset >> shift);
    if (IS_I9XX(pI830))
	swidth <<= 1;
    swidth -= 1;
    return swidth << 2;
d2159 5
d2166 39
a2204 13
i830_display_video(ScrnInfoPtr pScrn, xf86CrtcPtr crtc,
		   int id, short width, short height,
		   int dstPitch, int x1, int y1, int x2, int y2, BoxPtr dstBox,
		   short src_w, short src_h, short drw_w, short drw_h)
{
    I830Ptr		pI830 = I830PTR(pScrn);
    I830PortPrivPtr	pPriv = pI830->adaptor->pPortPrivates[0].ptr;
    I830OverlayRegPtr	overlay = I830OVERLAYREG(pI830);
    unsigned int	swidth, swidthy, swidthuv;
    unsigned int	mask, shift, offsety, offsetu;
    int			tmp;
    CARD32		OCMD;
    Bool		scaleChanged = FALSE;
d2206 4
a2209 2
    OVERLAY_DEBUG("I830DisplayVideo: %dx%d (pitch %d)\n", width, height,
		  dstPitch);
d2211 6
a2216 2
#if VIDEO_DEBUG
    CompareOverlay(pI830, (CARD32 *) overlay, 0x100);
d2218 109
a2326 273
    
    /*
     * If the video isn't visible on any CRTC, turn it off
     */
    if (!crtc)
    {
	pPriv->current_crtc = NULL;
	i830_overlay_off (pScrn);
	return;
    }
    
    if (crtc != pPriv->current_crtc)
    {
        pPriv->current_crtc = crtc;
	i830_overlay_switch_to_crtc (pScrn, crtc);
	if (pPriv->overlayOK)
	    I830ResetVideo (pScrn);
    }

    if (!pPriv->overlayOK)
	return;

    switch (crtc->rotation & 0xf) {
    case RR_Rotate_0:
	dstBox->x1 -= crtc->x;
	dstBox->x2 -= crtc->x;
	dstBox->y1 -= crtc->y;
	dstBox->y2 -= crtc->y;
	break;
    case RR_Rotate_90:
	tmp = dstBox->x1;
	dstBox->x1 = dstBox->y1 - crtc->x;
	dstBox->y1 = pScrn->virtualY - tmp - crtc->y;
	tmp = dstBox->x2;
	dstBox->x2 = dstBox->y2 - crtc->x;
	dstBox->y2 = pScrn->virtualY - tmp - crtc->y;
	tmp = dstBox->y1;
	dstBox->y1 = dstBox->y2;
	dstBox->y2 = tmp;
	break;
    case RR_Rotate_180:
	tmp = dstBox->x1;
	dstBox->x1 = pScrn->virtualX - dstBox->x2 - crtc->x;
	dstBox->x2 = pScrn->virtualX - tmp - crtc->x;
	tmp = dstBox->y1;
	dstBox->y1 = pScrn->virtualY - dstBox->y2 - crtc->y;
	dstBox->y2 = pScrn->virtualY - tmp - crtc->y;
	break;
    case RR_Rotate_270:
	tmp = dstBox->x1;
	dstBox->x1 = pScrn->virtualX - dstBox->y1 - crtc->x;
	dstBox->y1 = tmp - crtc->y;
	tmp = dstBox->x2;
	dstBox->x2 = pScrn->virtualX - dstBox->y2 - crtc->x;
	dstBox->y2 = tmp - crtc->y;
	tmp = dstBox->x1;
	dstBox->x1 = dstBox->x2;
	dstBox->x2 = tmp;
	break;
    }

    if (crtc->rotation & (RR_Rotate_90 | RR_Rotate_270)) {
	tmp = width;
	width = height;
	height = tmp;
	tmp = drw_w;
	drw_w = drw_h;
	drw_h = tmp;
	tmp = src_w;
	src_w = src_h;
	src_h = tmp;
    }

    if (pPriv->oneLineMode) {
	/* change the coordinates with panel fitting active */
	dstBox->y1 = (((dstBox->y1 - 1) * pPriv->scaleRatio) >> 16) + 1;
	dstBox->y2 = ((dstBox->y2 * pPriv->scaleRatio) >> 16) + 1;

	/* Now, alter the height, so we scale to the correct size */
	drw_h = ((drw_h * pPriv->scaleRatio) >> 16) + 1;
    }

    if (IS_I9XX(pI830)) {
	shift = 6;
	mask = 0x3f;
    } else {
	shift = 5;
	mask = 0x1f;
    }

    if (pPriv->currentBuf == 0) {
	offsety = pPriv->YBuf0offset;
	offsetu = pPriv->UBuf0offset;
    } else {
	offsety = pPriv->YBuf1offset;
	offsetu = pPriv->UBuf1offset;
    }

    switch (id) {
    case FOURCC_YV12:
    case FOURCC_I420:
	overlay->SWIDTH = width | ((width/2 & 0x7ff) << 16);
	swidthy  = i830_swidth (pI830, offsety, width, mask, shift);
	swidthuv = i830_swidth (pI830, offsetu, width/2, mask, shift);
	overlay->SWIDTHSW = (swidthy) | (swidthuv << 16);
	overlay->SHEIGHT = height | ((height / 2) << 16);
	break;
    case FOURCC_UYVY:
    case FOURCC_YUY2:
    default:
	overlay->SWIDTH = width;
	swidth = ((offsety + (width << 1) + mask) >> shift) -
	(offsety >> shift);

	if (IS_I9XX(pI830))
	    swidth <<= 1;

	swidth -= 1;

	swidth <<= 2;
	
	OVERLAY_DEBUG("swidthsw is old %d new %d\n",
		      swidth,
		      i830_swidth (pI830, offsety, width << 1,
				   mask, shift));

	overlay->SWIDTHSW = swidth;
	overlay->SHEIGHT = height;
	break;
    }

    overlay->DWINPOS = (dstBox->y1 << 16) | dstBox->x1;

    overlay->DWINSZ = (((dstBox->y2 - dstBox->y1) << 16) |
		       (dstBox->x2 - dstBox->x1));

    OVERLAY_DEBUG("dstBox: x1: %d, y1: %d, x2: %d, y2: %d\n",
		  dstBox->x1, dstBox->y1, dstBox->x2, dstBox->y2);

    /* buffer locations */
    overlay->OBUF_0Y = pPriv->YBuf0offset;
    overlay->OBUF_0U = pPriv->UBuf0offset;
    overlay->OBUF_0V = pPriv->VBuf0offset;
    if(pPriv->doubleBuffer) {
	overlay->OBUF_1Y = pPriv->YBuf1offset;
	overlay->OBUF_1U = pPriv->UBuf1offset;
	overlay->OBUF_1V = pPriv->VBuf1offset;
    }

    OVERLAY_DEBUG("pos: 0x%lx, size: 0x%lx\n",
		  overlay->DWINPOS, overlay->DWINSZ);
    OVERLAY_DEBUG("dst: %d x %d, src: %d x %d\n", drw_w, drw_h, src_w, src_h);

    /* 
     * Calculate horizontal and vertical scaling factors and polyphase
     * coefficients.
     */

    {
	int xscaleInt, xscaleFract, yscaleInt, yscaleFract;
	int xscaleIntUV, xscaleFractUV;
	int yscaleIntUV, yscaleFractUV;
	/* UV is half the size of Y -- YUV420 */
	int uvratio = 2;
	CARD32 newval;
	coeffRec xcoeffY[N_HORIZ_Y_TAPS * N_PHASES];
	coeffRec xcoeffUV[N_HORIZ_UV_TAPS * N_PHASES];
	int i, j, pos;

	/*
	 * Y down-scale factor as a multiple of 4096.
	 */
	xscaleFract = ((src_w - 1) << 12) / drw_w;
	yscaleFract = ((src_h - 1) << 12) / drw_h;

	/* Calculate the UV scaling factor. */
	xscaleFractUV = xscaleFract / uvratio;
	yscaleFractUV = yscaleFract / uvratio;

	/*
	 * To keep the relative Y and UV ratios exact, round the Y scales
	 * to a multiple of the Y/UV ratio.
	 */
	xscaleFract = xscaleFractUV * uvratio;
	yscaleFract = yscaleFractUV * uvratio;

	/* Integer (un-multiplied) values. */
	xscaleInt = xscaleFract >> 12;
	yscaleInt = yscaleFract >> 12;

	xscaleIntUV = xscaleFractUV >> 12;
	yscaleIntUV = yscaleFractUV >> 12;

	OVERLAY_DEBUG("xscale: %x.%03x, yscale: %x.%03x\n", xscaleInt,
		      xscaleFract & 0xFFF, yscaleInt, yscaleFract & 0xFFF);
	OVERLAY_DEBUG("UV xscale: %x.%03x, UV yscale: %x.%03x\n", xscaleIntUV,
		      xscaleFractUV & 0xFFF, yscaleIntUV, yscaleFractUV & 0xFFF);

	/* shouldn't get here */
	if (xscaleInt > 7) {
	    OVERLAY_DEBUG("xscale: bad scale\n");
	    return;
	}

	/* shouldn't get here */
	if (xscaleIntUV > 7) {
	    OVERLAY_DEBUG("xscaleUV: bad scale\n");
	    return;
	}

	newval = (xscaleInt << 16) |
	((xscaleFract & 0xFFF) << 3) | ((yscaleFract & 0xFFF) << 20);
	if (newval != overlay->YRGBSCALE) {
	    scaleChanged = TRUE;
	    overlay->YRGBSCALE = newval;
	}

	newval = (xscaleIntUV << 16) | ((xscaleFractUV & 0xFFF) << 3) |
	((yscaleFractUV & 0xFFF) << 20);
	if (newval != overlay->UVSCALE) {
	    scaleChanged = TRUE;
	    overlay->UVSCALE = newval;
	}

	newval = yscaleInt << 16 | yscaleIntUV;
	if (newval != overlay->UVSCALEV) {
	    scaleChanged = TRUE;
	    overlay->UVSCALEV = newval;
	}

	/* Recalculate coefficients if the scaling changed. */

	/*
	 * Only Horizontal coefficients so far.
	 */
	if (scaleChanged) {
	    double fCutoffY;
	    double fCutoffUV;

	    fCutoffY = xscaleFract / 4096.0;
	    fCutoffUV = xscaleFractUV / 4096.0;

	    /* Limit to between 1.0 and 3.0. */
	    if (fCutoffY < MIN_CUTOFF_FREQ)
		fCutoffY = MIN_CUTOFF_FREQ;
	    if (fCutoffY > MAX_CUTOFF_FREQ)
		fCutoffY = MAX_CUTOFF_FREQ;
	    if (fCutoffUV < MIN_CUTOFF_FREQ)
		fCutoffUV = MIN_CUTOFF_FREQ;
	    if (fCutoffUV > MAX_CUTOFF_FREQ)
		fCutoffUV = MAX_CUTOFF_FREQ;

	    UpdateCoeff(N_HORIZ_Y_TAPS, fCutoffY, TRUE, TRUE, xcoeffY);
	    UpdateCoeff(N_HORIZ_UV_TAPS, fCutoffUV, TRUE, FALSE, xcoeffUV);

	    for (i = 0; i < N_PHASES; i++) {
		for (j = 0; j < N_HORIZ_Y_TAPS; j++) {
		    pos = i * N_HORIZ_Y_TAPS + j;
		    overlay->Y_HCOEFS[pos] = (xcoeffY[pos].sign << 15 |
					      xcoeffY[pos].exponent << 12 |
					      xcoeffY[pos].mantissa);
		}
	    }
	    for (i = 0; i < N_PHASES; i++) {
		for (j = 0; j < N_HORIZ_UV_TAPS; j++) {
		    pos = i * N_HORIZ_UV_TAPS + j;
		    overlay->UV_HCOEFS[pos] = (xcoeffUV[pos].sign << 15 |
					       xcoeffUV[pos].exponent << 12 |
					       xcoeffUV[pos].mantissa);
		}
	    }
	}
    }
d2328 37
a2364 44
    OCMD = OVERLAY_ENABLE;
    
    switch (id) {
    case FOURCC_YV12:
    case FOURCC_I420:
	OVERLAY_DEBUG("YUV420\n");
#if 0
	/* set UV vertical phase to -0.25 */
	overlay->UV_VPH = 0x30003000;
#endif
	OVERLAY_DEBUG("UV stride is %d, Y stride is %d\n",
		      dstPitch, dstPitch * 2);
	overlay->OSTRIDE = (dstPitch * 2) | (dstPitch << 16);
	OCMD &= ~SOURCE_FORMAT;
	OCMD &= ~OV_BYTE_ORDER;
	OCMD |= YUV_420;
	break;
    case FOURCC_UYVY:
    case FOURCC_YUY2:
    default:
	OVERLAY_DEBUG("YUV422\n");
	overlay->OSTRIDE = dstPitch;
	OCMD &= ~SOURCE_FORMAT;
	OCMD |= YUV_422;
	OCMD &= ~OV_BYTE_ORDER;
	if (id == FOURCC_UYVY)
	    OCMD |= Y_SWAP;
	break;
    }

    OCMD &= ~(BUFFER_SELECT | FIELD_SELECT);
    if (pPriv->currentBuf == 0)
	OCMD |= BUFFER0;
    else
	OCMD |= BUFFER1;

    overlay->OCMD = OCMD;
    OVERLAY_DEBUG("OCMD is 0x%lx\n", OCMD);

    /* make sure the overlay is on */
    i830_overlay_on (pScrn);
    /* and show this frame */
    i830_overlay_continue (pScrn, scaleChanged);
}
d2366 83
a2448 43
static Bool
i830_clip_video_helper (ScrnInfoPtr pScrn,
			xf86CrtcPtr *crtc_ret,
			BoxPtr	    dst,
			INT32	    *xa,
			INT32	    *xb,
			INT32	    *ya,
			INT32	    *yb,
			RegionPtr   reg,
			INT32	    width,
			INT32	    height)
{
    Bool	ret;
    RegionRec	crtc_region_local;
    RegionPtr	crtc_region = reg;
    
    /*
     * For overlay video, compute the relevant CRTC and
     * clip video to that
     */
    if (crtc_ret)
    {
	I830Ptr		pI830 = I830PTR(pScrn);
	I830PortPrivPtr pPriv = pI830->adaptor->pPortPrivates[0].ptr;
	BoxRec		crtc_box;
	xf86CrtcPtr	crtc = i830_covering_crtc (pScrn, dst,
						   pPriv->desired_crtc,
						   &crtc_box);
	
	if (crtc)
	{
	    REGION_INIT (pScreen, &crtc_region_local, &crtc_box, 1);
	    crtc_region = &crtc_region_local;
	    REGION_INTERSECT (pScreen, crtc_region, crtc_region, reg);
	}
	*crtc_ret = crtc;
    }
    ret = xf86XVClipVideoHelper (dst, xa, xb, ya, yb, 
				 crtc_region, width, height);
    if (crtc_region != reg)
	REGION_UNINIT (pScreen, &crtc_region_local);
    return ret;
}
d2450 32
a2481 17
static void
i830_fill_colorkey (ScreenPtr pScreen, CARD32 key, RegionPtr clipboxes)
{
   DrawablePtr root = &WindowTable[pScreen->myNum]->drawable;
   XID	       pval[2];
   BoxPtr      pbox = REGION_RECTS(clipboxes);
   int	       i, nbox = REGION_NUM_RECTS(clipboxes);
   xRectangle  *rects;
   GCPtr       gc;

   if(!xf86Screens[pScreen->myNum]->vtSema) return;

   gc = GetScratchGC(root->depth, pScreen);
   pval[0] = key;
   pval[1] = IncludeInferiors;
   (void) ChangeGC(gc, GCForeground|GCSubwindowMode, pval);
   ValidateGC(root, gc);
d2483 29
a2511 1
   rects = xalloc (nbox * sizeof(xRectangle));
a2512 1
   for(i = 0; i < nbox; i++, pbox++) 
d2514 6
a2519 4
      rects[i].x = pbox->x1;
      rects[i].y = pbox->y1;
      rects[i].width = pbox->x2 - pbox->x1;
      rects[i].height = pbox->y2 - pbox->y1;
d2522 24
a2545 1
   (*gc->ops->PolyFillRect)(root, gc, nbox, rects);
d2547 348
a2894 2
   xfree (rects);
   FreeScratchGC (gc);
d2921 11
a2931 17
    I830Ptr pI830 = I830PTR(pScrn);
    I830PortPrivPtr pPriv = (I830PortPrivPtr) data;
    ScreenPtr pScreen = screenInfo.screens[pScrn->scrnIndex];
    I830OverlayRegPtr overlay;
    PixmapPtr pPixmap;
    INT32 x1, x2, y1, y2;
    int srcPitch, srcPitch2 = 0, dstPitch, destId;
    int top, left, npixels, nlines, size;
    BoxRec dstBox;
    int pitchAlignMask;
    int alloc_size, extraLinear;
    xf86CrtcPtr	crtc;

    if (pPriv->textured)
	overlay = NULL;
    else
	overlay = I830OVERLAYREG(pI830);
d2933 1
a2933 2
#if 0
    ErrorF("I830PutImage: src: (%d,%d)(%d,%d), dst: (%d,%d)(%d,%d)\n"
d2936 117
d3054 17
d3072 18
a3089 7
    if (pI830->entityPrivate) {
	if (pI830->entityPrivate->XvInUse != -1 &&
	    pI830->entityPrivate->XvInUse != i830_crtc_pipe (pPriv->current_crtc)) {
#ifdef PANORAMIX
	    if (!noPanoramiXExtension) {
		return Success; /* faked for trying to share it */
	    } else
d3091 8
a3098 4
	    {
		return BadAlloc;
	    }
	}
d3100 15
a3114 2
	pI830->entityPrivate->XvInUse = i830_crtc_pipe (pPriv->current_crtc);;
    }
d3116 22
a3137 214
    /* Clamp dst width & height to 7x of src (overlay limit) */
    if(drw_w > (src_w * 7))
	drw_w = src_w * 7;

    if(drw_h > (src_h * 7))
	drw_h = src_h * 7;

    /* Clip */
    x1 = src_x;
    x2 = src_x + src_w;
    y1 = src_y;
    y2 = src_y + src_h;

    dstBox.x1 = drw_x;
    dstBox.x2 = drw_x + drw_w;
    dstBox.y1 = drw_y;
    dstBox.y2 = drw_y + drw_h;

    if (!i830_clip_video_helper(pScrn, 
				pPriv->textured ? NULL : &crtc,
				&dstBox, &x1, &x2, &y1, &y2, clipBoxes,
				width, height))
	return Success;

    destId = id;
    switch (id) {
    case FOURCC_YV12:
    case FOURCC_I420:
	srcPitch = (width + 3) & ~3;
	srcPitch2 = ((width >> 1) + 3) & ~3;
	if (pPriv->textured && IS_I965G(pI830))
	    destId = FOURCC_YUY2;
	break;
    case FOURCC_UYVY:
    case FOURCC_YUY2:
    default:
	srcPitch = width << 1;
	break;
    }

    /* Only needs to be DWORD-aligned for textured on i915, but overlay has
     * stricter requirements.
     */
    if (pPriv->textured) {
	pitchAlignMask = 3;
    } else {
	if (IS_I965G(pI830))
	    pitchAlignMask = 255;
	else
	    pitchAlignMask = 63;
    }

    /* Determine the desired destination pitch (representing the chroma's pitch,
     * in the planar case.
     */
    switch (destId) {
    case FOURCC_YV12:
    case FOURCC_I420:
	if (pI830->rotation & (RR_Rotate_90 | RR_Rotate_270)) {
	    dstPitch = ((height / 2) + pitchAlignMask) & ~pitchAlignMask;
	    size = dstPitch * width * 3;
	} else {
	    dstPitch = ((width / 2) + pitchAlignMask) & ~pitchAlignMask;
	    size = dstPitch * height * 3;
	}
	break;
    case FOURCC_UYVY:
    case FOURCC_YUY2:
    default:
	if (pI830->rotation & (RR_Rotate_90 | RR_Rotate_270)) {
	    dstPitch = ((height << 1) + pitchAlignMask) & ~pitchAlignMask;
	    size = dstPitch * width;
	} else {
	    dstPitch = ((width << 1) + pitchAlignMask) & ~pitchAlignMask;
	    size = dstPitch * height;
	}
	break;
    }
#if 0
    ErrorF("srcPitch: %d, dstPitch: %d, size: %d\n", srcPitch, dstPitch, size);
#endif

    if (IS_I965G(pI830))
	extraLinear = BRW_LINEAR_EXTRA;
    else
	extraLinear = 0;

    alloc_size = size;
    if (pPriv->doubleBuffer)
	alloc_size *= 2;
    alloc_size += extraLinear;

    if (pPriv->buf) {
	/* Wait for any previous acceleration to the buffer to have completed.
	 * When we start using BOs for rendering, we won't have to worry
	 * because mapping or freeing will take care of it automatically.
	 */
	I830Sync(pScrn);
    }

    /* Free the current buffer if we're going to have to reallocate */
    if (pPriv->buf && pPriv->buf->size < alloc_size) {
	i830_free_memory(pScrn, pPriv->buf);
	pPriv->buf = NULL;
    }

    if (pPriv->buf == NULL) {
	pPriv->buf = i830_allocate_memory(pScrn, "xv buffer", alloc_size, 16,
					  0);
    }

    if (pPriv->buf == NULL)
	return BadAlloc;

    pPriv->extra_offset = pPriv->buf->offset +
    (pPriv->doubleBuffer ? size * 2 : size);

    /* fixup pointers */
    pPriv->YBuf0offset = pPriv->buf->offset;
    if (pI830->rotation & (RR_Rotate_90 | RR_Rotate_270)) {
	pPriv->UBuf0offset = pPriv->YBuf0offset + (dstPitch * 2 * width);
	pPriv->VBuf0offset = pPriv->UBuf0offset + (dstPitch * width / 2);
	if(pPriv->doubleBuffer) {
	    pPriv->YBuf1offset = pPriv->YBuf0offset + size;
	    pPriv->UBuf1offset = pPriv->YBuf1offset + (dstPitch * 2 * width);
	    pPriv->VBuf1offset = pPriv->UBuf1offset + (dstPitch * width / 2);
	}
    } else {
	pPriv->UBuf0offset = pPriv->YBuf0offset + (dstPitch * 2 * height);
	pPriv->VBuf0offset = pPriv->UBuf0offset + (dstPitch * height / 2);
	if(pPriv->doubleBuffer) {
	    pPriv->YBuf1offset = pPriv->YBuf0offset + size;
	    pPriv->UBuf1offset = pPriv->YBuf1offset + (dstPitch * 2 * height);
	    pPriv->VBuf1offset = pPriv->UBuf1offset + (dstPitch * height / 2);
	}
    }

    /* Pick the idle buffer */
    if (!pPriv->textured && *pI830->overlayOn && pPriv->doubleBuffer)
	pPriv->currentBuf = !((INREG(DOVSTA) & OC_BUF) >> 20);

    /* copy data */
    top = y1 >> 16;
    left = (x1 >> 16) & ~1;
    npixels = ((((x2 + 0xffff) >> 16) + 1) & ~1) - left;

    switch (id) {
    case FOURCC_YV12:
    case FOURCC_I420:
	top &= ~1;
	nlines = ((((y2 + 0xffff) >> 16) + 1) & ~1) - top;
	if (pPriv->textured && IS_I965G(pI830)) {
	    I830CopyPlanarToPackedData(pScrn, pPriv, buf, srcPitch, srcPitch2,
				       dstPitch, height, top, left, nlines,
				       npixels, id);
	} else {
	    I830CopyPlanarData(pScrn, pPriv, buf, srcPitch, srcPitch2, dstPitch,
			       height, top, left, nlines, npixels, id);
	}
	break;
    case FOURCC_UYVY:
    case FOURCC_YUY2:
    default:
	nlines = ((y2 + 0xffff) >> 16) - top;
	I830CopyPackedData(pScrn, pPriv, buf, srcPitch, dstPitch, top, left,
			   nlines, npixels);
	break;
    }

    if (pDraw->type == DRAWABLE_WINDOW) {
	pPixmap = (*pScreen->GetWindowPixmap)((WindowPtr)pDraw);
    } else {
	pPixmap = (PixmapPtr)pDraw;
    }

#ifdef I830_USE_EXA
    if (pI830->useEXA) {
	/* Force the pixmap into framebuffer so we can draw to it. */
	exaMoveInPixmap(pPixmap);
    }
#endif

    if (!pI830->useEXA &&
	    (((char *)pPixmap->devPrivate.ptr < (char *)pI830->FbBase) ||
	     ((char *)pPixmap->devPrivate.ptr >= (char *)pI830->FbBase +
	      pI830->FbMapSize))) {
	/* If the pixmap wasn't in framebuffer, then we have no way in XAA to
	 * force it there.  So, we simply refuse to draw and fail.
	 */
	return BadAlloc;
    }

    if (!pPriv->textured) {
	i830_display_video(pScrn, crtc, destId, width, height, dstPitch,
			   x1, y1, x2, y2, &dstBox, src_w, src_h,
			   drw_w, drw_h);
	
	/* update cliplist */
	if (!RegionsEqual(&pPriv->clip, clipBoxes)) {
	    REGION_COPY(pScrn->pScreen, &pPriv->clip, clipBoxes);
	    i830_fill_colorkey (pScreen, pPriv->colorKey, clipBoxes);
	}
    } else if (IS_I965G(pI830)) {
	I965DisplayVideoTextured(pScrn, pPriv, destId, clipBoxes, width, height,
				 dstPitch, x1, y1, x2, y2,
				 src_w, src_h, drw_w, drw_h, pPixmap);
    } else {
	I915DisplayVideoTextured(pScrn, pPriv, destId, clipBoxes, width, height,
				 dstPitch, x1, y1, x2, y2,
				 src_w, src_h, drw_w, drw_h, pPixmap);
    }
    if (pPriv->textured) {
	DamageDamageRegion(pDraw, clipBoxes);
    }
d3139 19
a3157 1
    pPriv->videoStatus = CLIENT_VIDEO_ON;
d3159 1
a3159 1
    return Success;
d3168 2
a3169 2
    I830Ptr pI830 = I830PTR(pScrn);
    int size, tmp;
d3172 1
a3172 1
    ErrorF("I830QueryImageAttributes: w is %d, h is %d\n", *w, *h);
d3175 3
a3177 2
    if (IS_845G(pI830) || IS_I830(pI830)) {
	if (*w > IMAGE_MAX_WIDTH_LEGACY)
d3179 1
a3179 1
	if (*h > IMAGE_MAX_HEIGHT_LEGACY)
d3181 2
a3182 2
    } else {
	if (*w > IMAGE_MAX_WIDTH)
d3184 1
a3184 1
	if (*h > IMAGE_MAX_HEIGHT)
d3186 2
a3187 1
    }
d3189 46
a3234 48
    *w = (*w + 1) & ~1;
    if (offsets)
	offsets[0] = 0;

    switch (id) {
	/* IA44 is for XvMC only */
    case FOURCC_IA44:
    case FOURCC_AI44:
	if (pitches)
	    pitches[0] = *w;
	size = *w * *h;
	break;
    case FOURCC_YV12:
    case FOURCC_I420:
	*h = (*h + 1) & ~1;
	size = (*w + 3) & ~3;
	if (pitches)
	    pitches[0] = size;
	size *= *h;
	if (offsets)
	    offsets[1] = size;
	tmp = ((*w >> 1) + 3) & ~3;
	if (pitches)
	    pitches[1] = pitches[2] = tmp;
	tmp *= (*h >> 1);
	size += tmp;
	if (offsets)
	    offsets[2] = size;
	size += tmp;
#if 0
	if (pitches)
	    ErrorF("pitch 0 is %d, pitch 1 is %d, pitch 2 is %d\n", pitches[0],
		   pitches[1], pitches[2]);
	if (offsets)
	    ErrorF("offset 1 is %d, offset 2 is %d\n", offsets[1], offsets[2]);
	if (offsets)
	    ErrorF("size is %d\n", size);
#endif
	break;
    case FOURCC_UYVY:
    case FOURCC_YUY2:
    default:
	size = *w << 1;
	if (pitches)
	    pitches[0] = size;
	size *= *h;
	break;
    }
d3236 1
a3236 1
    return size;
d3245 1
a3245 1
    return I830QueryImageAttributes(pScrn, id, w, h, pitches, offsets, FALSE);
d3254 1
a3254 1
    return I830QueryImageAttributes(pScrn, id, w, h, pitches, offsets, TRUE);
d3257 3
a3259 3
void
I830VideoBlockHandler(int i, pointer blockData, pointer pTimeout,
		      pointer pReadmask)
d3261 4
a3264 3
    ScrnInfoPtr pScrn = xf86Screens[i];
    I830Ptr pI830 = I830PTR(pScrn);
    I830PortPrivPtr pPriv;
d3266 1
a3266 2
    if (pI830->adaptor == NULL)
        return;
d3268 1
a3268 3
    /* No overlay scaler on the 965. */
    if (IS_I965G(pI830))
        return;
d3270 1
a3270 1
    pPriv = GET_PORT_PRIVATE(pScrn);
d3272 1
a3272 1
    if (pPriv->videoStatus & TIMER_MASK) {
d3274 1
a3274 1
	Time now = currentTime.milliseconds;
d3276 1
a3276 1
	UpdateCurrentTime();
d3278 25
a3302 24
	if (pPriv->videoStatus & OFF_TIMER) {
	    if (pPriv->offTime < now) {
		/* Turn off the overlay */
		OVERLAY_DEBUG("BLOCKHANDLER\n");

		i830_overlay_off (pScrn);

		pPriv->videoStatus = FREE_TIMER;
		pPriv->freeTime = now + FREE_DELAY;

		if (pI830->entityPrivate)
		    pI830->entityPrivate->XvInUse = -1;
	    }
	} else {				/* FREE_TIMER */
	    if (pPriv->freeTime < now) {
		/* Sync before freeing the buffer, because the pages will be
		 * unbound.
		 */
		I830Sync(pScrn);
		i830_free_memory(pScrn, pPriv->buf);
		pPriv->videoStatus = 0;
	    }
	}
    }
d3310 2
a3311 2
    i830_memory *buf;
    Bool isOn;
d3320 46
a3365 53
    int pitch, fbpitch, size;
    OffscreenPrivPtr pPriv;
    I830Ptr pI830 = I830PTR(pScrn);

    OVERLAY_DEBUG("I830AllocateSurface\n");

    if (IS_845G(pI830) || IS_I830(pI830)) {
	if ((w > IMAGE_MAX_WIDTH_LEGACY) || (h > IMAGE_MAX_HEIGHT_LEGACY))
	    return BadAlloc;
    } else {
	if ((w > IMAGE_MAX_WIDTH) || (h > IMAGE_MAX_HEIGHT))
	    return BadAlloc;
    }

    /* What to do when rotated ?? */
    if (pI830->rotation != RR_Rotate_0)
	return BadAlloc;

    if (!(surface->pitches = xalloc(sizeof(int))))
	return BadAlloc;
    if (!(surface->offsets = xalloc(sizeof(int)))) {
	xfree(surface->pitches);
	return BadAlloc;
    }
    if (!(pPriv = xalloc(sizeof(OffscreenPrivRec)))) {
	xfree(surface->pitches);
	xfree(surface->offsets);
	return BadAlloc;
    }

    w = (w + 1) & ~1;
    pitch = ((w << 1) + 15) & ~15;
    fbpitch = pI830->cpp * pScrn->displayWidth;
    size = pitch * h;

    pPriv->buf = i830_allocate_memory(pScrn, "xv surface buffer", size, 16, 0);
    if (pPriv->buf == NULL) {
	xfree(surface->pitches);
	xfree(surface->offsets);
	xfree(pPriv);
	return BadAlloc;
    }

    surface->width = w;
    surface->height = h;

    pPriv->isOn = FALSE;

    surface->pScrn = pScrn;
    surface->id = id;
    surface->pitches[0] = pitch;
    surface->offsets[0] = pPriv->buf->offset;
    surface->devPrivate.ptr = (pointer) pPriv;
d3367 2
a3368 1
    memset(pI830->FbBase + surface->offsets[0], 0, size);
d3370 13
a3382 1
    return Success;
d3388 2
a3389 2
    OffscreenPrivPtr pPriv = (OffscreenPrivPtr) surface->devPrivate.ptr;
    ScrnInfoPtr pScrn = surface->pScrn;
d3391 2
a3392 2
    if (pPriv->isOn) {
	I830Ptr pI830 = I830PTR(pScrn);
d3394 1
a3394 1
	OVERLAY_DEBUG("StopSurface\n");
d3396 3
a3398 1
	i830_overlay_off (pScrn);
d3400 2
a3401 2
	if (pI830->entityPrivate)
	    pI830->entityPrivate->XvInUse = -1;
d3403 2
a3404 2
	pPriv->isOn = FALSE;
    }
d3406 1
a3406 1
    return Success;
d3412 1
a3412 2
    ScrnInfoPtr pScrn = surface->pScrn;
    OffscreenPrivPtr pPriv = (OffscreenPrivPtr) surface->devPrivate.ptr;
d3414 7
a3420 7
    I830StopSurface(surface);
    /* Sync before freeing the buffer, because the pages will be unbound. */
    I830Sync(pScrn);
    i830_free_memory(surface->pScrn, pPriv->buf);
    xfree(surface->pitches);
    xfree(surface->offsets);
    xfree(surface->devPrivate.ptr);
d3422 1
a3422 1
    return Success;
d3428 1
a3428 1
    return I830GetPortAttribute(pScrn, attribute, value, NULL);
d3434 1
a3434 1
    return I830SetPortAttribute(pScrn, attribute, value, NULL);
d3444 16
a3459 14
    OffscreenPrivPtr pPriv = (OffscreenPrivPtr) surface->devPrivate.ptr;
    ScrnInfoPtr pScrn = surface->pScrn;
    ScreenPtr pScreen = screenInfo.screens[pScrn->scrnIndex];
    I830Ptr pI830 = I830PTR(pScrn);
    I830PortPrivPtr pI830Priv = GET_PORT_PRIVATE(pScrn);
    INT32 x1, y1, x2, y2;
    BoxRec dstBox;
    xf86CrtcPtr crtc;

    OVERLAY_DEBUG("I830DisplaySurface\n");

    if (pI830->entityPrivate) {
	if (pI830->entityPrivate->XvInUse != -1 &&
	    pI830->entityPrivate->XvInUse != i830_crtc_pipe (pI830Priv->current_crtc)) {
d3461 3
a3463 3
	    if (!noPanoramiXExtension) {
		return Success; /* faked for trying to share it */
	    } else
d3465 44
a3508 4
	    {
		return BadAlloc;
	    }
	}
d3510 6
a3515 2
	pI830->entityPrivate->XvInUse = i830_crtc_pipe (pI830Priv->current_crtc);
    }
d3517 15
a3531 37
    x1 = src_x;
    x2 = src_x + src_w;
    y1 = src_y;
    y2 = src_y + src_h;

    dstBox.x1 = drw_x;
    dstBox.x2 = drw_x + drw_w;
    dstBox.y1 = drw_y;
    dstBox.y2 = drw_y + drw_h;

    if (!i830_clip_video_helper (pScrn, &crtc, &dstBox,
				 &x1, &x2, &y1, &y2, clipBoxes,
				 surface->width, surface->height))
	return Success;

    /* fixup pointers */
    pI830Priv->YBuf0offset = surface->offsets[0];
    pI830Priv->YBuf1offset = pI830Priv->YBuf0offset;

    /* Pick the idle buffer */
    if (!pI830Priv->textured && *pI830->overlayOn && pI830Priv->doubleBuffer) 
	pI830Priv->currentBuf = !((INREG(DOVSTA) & OC_BUF) >> 20);

    i830_display_video(pScrn, crtc, surface->id, surface->width, surface->height,
		     surface->pitches[0], x1, y1, x2, y2, &dstBox,
		     src_w, src_h, drw_w, drw_h);

    i830_fill_colorkey (pScreen, pI830Priv->colorKey, clipBoxes);

    pPriv->isOn = TRUE;
    /* we've prempted the XvImage stream so set its free timer */
    if (pI830Priv->videoStatus & CLIENT_VIDEO_ON) {
	REGION_EMPTY(pScrn->pScreen, &pI830Priv->clip);
	UpdateCurrentTime();
	pI830Priv->videoStatus = FREE_TIMER;
	pI830Priv->freeTime = currentTime.milliseconds + FREE_DELAY;
    }
d3533 1
a3533 1
    return Success;
d3539 8
a3546 26
    XF86OffscreenImagePtr offscreenImages;
    ScrnInfoPtr pScrn = xf86Screens[pScreen->myNum];
    I830Ptr pI830 = I830PTR(pScrn);

    /* need to free this someplace */
    if (!(offscreenImages = xalloc(sizeof(XF86OffscreenImageRec)))) {
	return;
    }

    offscreenImages[0].image = &Images[0];
    offscreenImages[0].flags = VIDEO_OVERLAID_IMAGES /*| VIDEO_CLIP_TO_VIEWPORT*/;
    offscreenImages[0].alloc_surface = I830AllocateSurface;
    offscreenImages[0].free_surface = I830FreeSurface;
    offscreenImages[0].display = I830DisplaySurface;
    offscreenImages[0].stop = I830StopSurface;
    offscreenImages[0].setAttribute = I830SetSurfaceAttribute;
    offscreenImages[0].getAttribute = I830GetSurfaceAttribute;
    if (IS_845G(pI830) || IS_I830(pI830)) {
	offscreenImages[0].max_width = IMAGE_MAX_WIDTH_LEGACY;
	offscreenImages[0].max_height = IMAGE_MAX_HEIGHT_LEGACY;
    } else {
	offscreenImages[0].max_width = IMAGE_MAX_WIDTH;
	offscreenImages[0].max_height = IMAGE_MAX_HEIGHT; 
    }
    offscreenImages[0].num_attributes = 1;
    offscreenImages[0].attributes = Attributes;
d3548 19
a3566 1
    xf86XVRegisterOffscreenImages(pScreen, offscreenImages, 1);
d3570 1
a3570 1
i830_crtc_dpms_video(xf86CrtcPtr crtc, Bool on)
d3572 98
a3669 27
    ScrnInfoPtr pScrn = crtc->scrn;
    I830Ptr pI830 = I830PTR(pScrn);
    I830PortPrivPtr pPriv;

    if (pI830->adaptor == NULL)
	return;

    /* No overlay scaler on the 965. */
    if (IS_I965G(pI830))
	return;

    pPriv = GET_PORT_PRIVATE(pScrn);

    if (crtc != pPriv->current_crtc)
	return;

    /* Check if it's the crtc the overlay is off */
    if (!on) {
	/* We stop the video when mode switching, so we don't lock up
	 * the engine. The overlayOK will determine whether we can re-enable
	 * with the current video on completion of the mode switch.
	 */
	I830StopVideo(pScrn, pPriv, TRUE);
	pPriv->current_crtc = NULL;
	pPriv->overlayOK = FALSE;
	pPriv->oneLineMode = FALSE;
    }
@


1.1.1.4
log
@Import intel driver v 2.2.0.90. tested by many, including krw@@ kettenis@@,
jakemsr@@, landry@@, beck@@ and oga@@. Thanks.
@
text
@a52 1
#include <inttypes.h>
d465 1
a465 2
    OVERLAY_DEBUG ("overlay_continue cmd 0x%08" PRIx32 " -> 0x%08" PRIx32
		   " sta 0x%08" PRIx32 "\n",
d505 1
a505 1
	OVERLAY_DEBUG ("overlay_off cmd 0x%08" PRIx32 " -> 0x%08" PRIx32 " sta 0x%08" PRIx32 "\n",
d677 1
a677 1
	    ErrorF("0x%x 0x%" PRIx32 "\n", i, INREG(i));
d1907 1
a1907 1
    OVERLAY_DEBUG("pos: 0x%" PRIx32 ", size: 0x%" PRIx32 "\n",
d2069 1
a2069 1
    OVERLAY_DEBUG("OCMD is 0x%" PRIx32 "\n", OCMD);
a2576 1
		pPriv->buf = NULL;
a2688 1
    pPriv->buf = NULL;
@


