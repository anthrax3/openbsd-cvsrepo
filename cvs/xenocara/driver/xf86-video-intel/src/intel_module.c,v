head	1.7;
access;
symbols
	OPENBSD_6_2:1.7.0.10
	OPENBSD_6_2_BASE:1.7
	OPENBSD_6_1:1.7.0.8
	OPENBSD_6_1_BASE:1.7
	OPENBSD_6_0:1.7.0.6
	OPENBSD_6_0_BASE:1.7
	OPENBSD_5_9:1.7.0.4
	OPENBSD_5_9_BASE:1.7
	OPENBSD_5_8:1.7.0.2
	OPENBSD_5_8_BASE:1.7
	OPENBSD_5_7:1.6.0.6
	OPENBSD_5_7_BASE:1.6
	OPENBSD_5_6:1.6.0.4
	OPENBSD_5_6_BASE:1.6
	OPENBSD_5_5:1.6.0.2
	OPENBSD_5_5_BASE:1.6
	OPENBSD_5_4:1.5.0.2
	OPENBSD_5_4_BASE:1.5
	OPENBSD_5_3:1.4.0.2
	OPENBSD_5_3_BASE:1.4
	OPENBSD_5_2:1.2.0.4
	OPENBSD_5_2_BASE:1.2
	OPENBSD_5_1_BASE:1.2
	OPENBSD_5_1:1.2.0.2;
locks; strict;
comment	@ * @;


1.7
date	2015.04.12.19.42.05;	author matthieu;	state Exp;
branches;
next	1.6;
commitid	DK857Z2Au1JEohAk;

1.6
date	2014.02.03.15.54.52;	author matthieu;	state Exp;
branches;
next	1.5;

1.5
date	2013.03.18.18.38.20;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2012.12.19.21.19.49;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2012.10.06.03.51.23;	author jsg;	state Exp;
branches;
next	1.2;

1.2
date	2011.12.21.21.25.02;	author kettenis;	state Exp;
branches;
next	1.1;

1.1
date	2011.11.29.12.39.03;	author oga;	state Exp;
branches;
next	;


desc
@@


1.7
log
@Update to xf86-video-intel 2.99.916
Fixes a display bug seenby ajacoutot@@, ok jsg@@ and kettenis@@.
newer X.Org (2.99.917 or master) version cause corruption on older
machines (X40, i965), probably caused by a bug in our kernel,
under investigation by kettenis@@.
@
text
@/*
 * Copyright 1998-1999 Precision Insight, Inc., Cedar Park, Texas.
 * All Rights Reserved.
 * Copyright Â© 2010 Intel Corporation
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice (including the next
 * paragraph) shall be included in all copies or substantial portions of the
 * Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 */

#ifdef HAVE_CONFIG_H
#include "config.h"
#endif

#include <xorg-server.h>
#include <xorgVersion.h>

#include <xf86.h>
#include <xf86Parser.h>

#if XORG_VERSION_CURRENT < XORG_VERSION_NUMERIC(1,6,99,0,0)
#include <xf86Resources.h>
#endif

#include "intel_driver.h"
#include "intel_options.h"
#include "legacy/legacy.h"
#include "sna/sna_module.h"
#include "uxa/uxa_module.h"

#include "i915_pciids.h" /* copied from (kernel) include/drm/i915_pciids.h */

#ifdef XSERVER_PLATFORM_BUS
#include <xf86platformBus.h>
#endif

#ifndef XF86_ALLOCATE_GPU_SCREEN
#define XF86_ALLOCATE_GPU_SCREEN 0
#endif

static const struct intel_device_info intel_generic_info = {
	.gen = -1,
};

static const struct intel_device_info intel_i81x_info = {
	.gen = 010,
};

static const struct intel_device_info intel_i830_info = {
	.gen = 020,
};
static const struct intel_device_info intel_i845_info = {
	.gen = 020,
};
static const struct intel_device_info intel_i855_info = {
	.gen = 021,
};
static const struct intel_device_info intel_i865_info = {
	.gen = 022,
};

static const struct intel_device_info intel_i915_info = {
	.gen = 030,
};
static const struct intel_device_info intel_i945_info = {
	.gen = 031,
};

static const struct intel_device_info intel_g33_info = {
	.gen = 033,
};

static const struct intel_device_info intel_i965_info = {
	.gen = 040,
};

static const struct intel_device_info intel_g4x_info = {
	.gen = 045,
};

static const struct intel_device_info intel_ironlake_info = {
	.gen = 050,
};

static const struct intel_device_info intel_sandybridge_info = {
	.gen = 060,
};

static const struct intel_device_info intel_ivybridge_info = {
	.gen = 070,
};

static const struct intel_device_info intel_valleyview_info = {
	.gen = 071,
};

static const struct intel_device_info intel_haswell_info = {
	.gen = 075,
};

static const struct intel_device_info intel_broadwell_info = {
	.gen = 0100,
};

static const struct intel_device_info intel_cherryview_info = {
	.gen = 0101,
};

static const SymTabRec intel_chipsets[] = {
	{PCI_CHIP_I810,				"i810"},
	{PCI_CHIP_I810_DC100,			"i810-dc100"},
	{PCI_CHIP_I810_E,			"i810e"},
	{PCI_CHIP_I815,				"i815"},
	{PCI_CHIP_I830_M,			"i830M"},
	{PCI_CHIP_845_G,			"845G"},
	{PCI_CHIP_I854,				"854"},
	{PCI_CHIP_I855_GM,			"852GM/855GM"},
	{PCI_CHIP_I865_G,			"865G"},
	{PCI_CHIP_I915_G,			"915G"},
	{PCI_CHIP_E7221_G,			"E7221 (i915)"},
	{PCI_CHIP_I915_GM,			"915GM"},
	{PCI_CHIP_I945_G,			"945G"},
	{PCI_CHIP_I945_GM,			"945GM"},
	{PCI_CHIP_I945_GME,			"945GME"},
	{PCI_CHIP_PINEVIEW_M,			"Pineview GM"},
	{PCI_CHIP_PINEVIEW_G,			"Pineview G"},
	{PCI_CHIP_I965_G,			"965G"},
	{PCI_CHIP_G35_G,			"G35"},
	{PCI_CHIP_I965_Q,			"965Q"},
	{PCI_CHIP_I946_GZ,			"946GZ"},
	{PCI_CHIP_I965_GM,			"965GM"},
	{PCI_CHIP_I965_GME,			"965GME/GLE"},
	{PCI_CHIP_G33_G,			"G33"},
	{PCI_CHIP_Q35_G,			"Q35"},
	{PCI_CHIP_Q33_G,			"Q33"},
	{PCI_CHIP_GM45_GM,			"GM45"},
	{PCI_CHIP_G45_E_G,			"4 Series"},
	{PCI_CHIP_G45_G,			"G45/G43"},
	{PCI_CHIP_Q45_G,			"Q45/Q43"},
	{PCI_CHIP_G41_G,			"G41"},
	{PCI_CHIP_B43_G,			"B43"},
	{PCI_CHIP_B43_G1,			"B43"},

	{0, ""},

	{PCI_CHIP_IRONLAKE_D_G,			"HD Graphics"},
	{PCI_CHIP_IRONLAKE_M_G,			"HD Graphics"},
	{PCI_CHIP_SANDYBRIDGE_GT1,		"HD Graphics 2000" },
	{PCI_CHIP_SANDYBRIDGE_GT2,		"HD Graphics 3000" },
	{PCI_CHIP_SANDYBRIDGE_GT2_PLUS,		"HD Graphics 3000" },
	{PCI_CHIP_SANDYBRIDGE_M_GT1,		"HD Graphics 2000" },
	{PCI_CHIP_SANDYBRIDGE_M_GT2,		"HD Graphics 3000" },
	{PCI_CHIP_SANDYBRIDGE_M_GT2_PLUS,	"HD Graphics 3000" },
	{PCI_CHIP_SANDYBRIDGE_S_GT,		"HD Graphics" },
	{PCI_CHIP_IVYBRIDGE_M_GT1,		"HD Graphics 2500" },
	{PCI_CHIP_IVYBRIDGE_M_GT2,		"HD Graphics 4000" },
	{PCI_CHIP_IVYBRIDGE_D_GT1,		"HD Graphics 2500" },
	{PCI_CHIP_IVYBRIDGE_D_GT2,		"HD Graphics 4000" },
	{PCI_CHIP_IVYBRIDGE_S_GT1,		"HD Graphics" },
	{PCI_CHIP_IVYBRIDGE_S_GT2,		"HD Graphics P4000" },
	{PCI_CHIP_HASWELL_D_GT1,		"HD Graphics" },
	{PCI_CHIP_HASWELL_D_GT2,		"HD Graphics 4600" },
	{PCI_CHIP_HASWELL_D_GT3,		"HD Graphics 5000" }, /* ??? */
	{PCI_CHIP_HASWELL_M_GT1,		"HD Graphics" },
	{PCI_CHIP_HASWELL_M_GT2,		"HD Graphics 4600" },
	{PCI_CHIP_HASWELL_M_GT3,		"HD Graphics 5000" }, /* ??? */
	{PCI_CHIP_HASWELL_S_GT1,		"HD Graphics" },
	{PCI_CHIP_HASWELL_S_GT2,		"HD Graphics P4600/P4700" },
	{PCI_CHIP_HASWELL_S_GT3,		"HD Graphics 5000" }, /* ??? */
	{PCI_CHIP_HASWELL_B_GT1,		"HD Graphics" }, /* ??? */
	{PCI_CHIP_HASWELL_B_GT2,		"HD Graphics" }, /* ??? */
	{PCI_CHIP_HASWELL_B_GT3,		"HD Graphics" }, /* ??? */
	{PCI_CHIP_HASWELL_E_GT1,		"HD Graphics" },
	{PCI_CHIP_HASWELL_E_GT2,		"HD Graphics" }, /* ??? */
	{PCI_CHIP_HASWELL_E_GT3,		"HD Graphics" }, /* ??? */
	{PCI_CHIP_HASWELL_ULT_D_GT1,		"HD Graphics" }, /* ??? */
	{PCI_CHIP_HASWELL_ULT_D_GT2,		"HD Graphics" }, /* ??? */
	{PCI_CHIP_HASWELL_ULT_D_GT3,		"Iris(TM) Graphics 5100" },
	{PCI_CHIP_HASWELL_ULT_M_GT1,		"HD Graphics" },
	{PCI_CHIP_HASWELL_ULT_M_GT2,		"HD Graphics 4400" },
	{PCI_CHIP_HASWELL_ULT_M_GT3,		"HD Graphics 5000" },
	{PCI_CHIP_HASWELL_ULT_S_GT1,		"HD Graphics" }, /* ??? */
	{PCI_CHIP_HASWELL_ULT_S_GT2,		"HD Graphics" }, /* ??? */
	{PCI_CHIP_HASWELL_ULT_S_GT3,		"Iris(TM) Graphics 5100" },
	{PCI_CHIP_HASWELL_ULT_B_GT1,		"HD Graphics" }, /* ??? */
	{PCI_CHIP_HASWELL_ULT_B_GT2,		"HD Graphics" }, /* ??? */
	{PCI_CHIP_HASWELL_ULT_B_GT3,		"Iris(TM) Graphics 5100" },
	{PCI_CHIP_HASWELL_ULT_E_GT1,		"HD Graphics" },
	{PCI_CHIP_HASWELL_ULT_E_GT2,		"HD Graphics 4200" },
	{PCI_CHIP_HASWELL_ULT_E_GT3,		"Iris(TM) Graphics 5100" },
	{PCI_CHIP_HASWELL_CRW_D_GT1,		"HD Graphics" }, /* ??? */
	{PCI_CHIP_HASWELL_CRW_D_GT2,		"HD Graphics 4600" },
	{PCI_CHIP_HASWELL_CRW_D_GT3,		"Iris(TM) Pro Graphics 5200" },
	{PCI_CHIP_HASWELL_CRW_M_GT1,		"HD Graphics" }, /* ??? */
	{PCI_CHIP_HASWELL_CRW_M_GT2,		"HD Graphics 4600" },
	{PCI_CHIP_HASWELL_CRW_M_GT3,		"Iris(TM) Pro Graphics 5200" },
	{PCI_CHIP_HASWELL_CRW_S_GT1,		"HD Graphics" }, /* ??? */
	{PCI_CHIP_HASWELL_CRW_S_GT2,		"HD Graphics" }, /* ??? */
	{PCI_CHIP_HASWELL_CRW_S_GT3,		"Iris(TM) Pro Graphics 5200" },
	{PCI_CHIP_HASWELL_CRW_B_GT1,		"HD Graphics" }, /* ??? */
	{PCI_CHIP_HASWELL_CRW_B_GT2,		"HD Graphics" }, /* ??? */
	{PCI_CHIP_HASWELL_CRW_B_GT3,		"Iris(TM) Pro Graphics 5200" },
	{PCI_CHIP_HASWELL_CRW_E_GT1,		"HD Graphics" }, /* ??? */
	{PCI_CHIP_HASWELL_CRW_E_GT2,		"HD Graphics" }, /* ??? */
	{PCI_CHIP_HASWELL_CRW_E_GT3,		"Iris(TM) Pro Graphics 5200" },

	/* Valleyview (Baytail) */
	{0x0f30, "HD Graphics"},
	{0x0f31, "HD Graphics"},
	{0x0f32, "HD Graphics"},
	{0x0f33, "HD Graphics"},
	{0x0155, "HD Graphics"},
	{0x0157, "HD Graphics"},

	/* Broadwell Marketing names */
	{0x1602, "HD graphics"},
	{0x1606, "HD graphics"},
	{0x160B, "HD graphics"},
	{0x160A, "HD graphics"},
	{0x160D, "HD graphics"},
	{0x160E, "HD graphics"},
	{0x1612, "HD graphics 5600"},
	{0x1616, "HD graphics 5500"},
	{0x161B, "HD graphics"},
	{0x161A, "HD graphics"},
	{0x161D, "HD graphics"},
	{0x161E, "HD graphics 5300"},
	{0x1622, "Iris Pro graphics 6200"},
	{0x1626, "HD graphics 6000"},
	{0x162B, "Iris graphics 6100"},
	{0x162A, "Iris Pro graphics P6300"},
	{0x162D, "HD graphics"},
	{0x162E, "HD graphics"},
	{0x1632, "HD graphics"},
	{0x1636, "HD graphics"},
	{0x163B, "HD graphics"},
	{0x163A, "HD graphics"},
	{0x163D, "HD graphics"},
	{0x163E, "HD graphics"},

	/* When adding new identifiers, also update:
	 * 1. intel_identify()
	 * 2. man/intel.man
	 * 3. README
	 */

	{-1, NULL} /* Sentinel */
};

static const struct pci_id_match intel_device_match[] = {
#if UMS
	INTEL_VGA_DEVICE(PCI_CHIP_I810, &intel_i81x_info),
	INTEL_VGA_DEVICE(PCI_CHIP_I810_DC100, &intel_i81x_info),
	INTEL_VGA_DEVICE(PCI_CHIP_I810_E, &intel_i81x_info),
	INTEL_VGA_DEVICE(PCI_CHIP_I815, &intel_i81x_info),
#endif

#if KMS
	INTEL_I830_IDS(&intel_i830_info),
	INTEL_I845G_IDS(&intel_i845_info),
	INTEL_I85X_IDS(&intel_i855_info),
	INTEL_I865G_IDS(&intel_i865_info),

	INTEL_I915G_IDS(&intel_i915_info),
	INTEL_I915GM_IDS(&intel_i915_info),
	INTEL_I945G_IDS(&intel_i945_info),
	INTEL_I945GM_IDS(&intel_i945_info),

	INTEL_G33_IDS(&intel_g33_info),
	INTEL_PINEVIEW_IDS(&intel_g33_info),

	INTEL_I965G_IDS(&intel_i965_info),
	INTEL_I965GM_IDS(&intel_i965_info),

	INTEL_G45_IDS(&intel_g4x_info),
	INTEL_GM45_IDS(&intel_g4x_info),

	INTEL_IRONLAKE_D_IDS(&intel_ironlake_info),
	INTEL_IRONLAKE_M_IDS(&intel_ironlake_info),

	INTEL_SNB_D_IDS(&intel_sandybridge_info),
	INTEL_SNB_M_IDS(&intel_sandybridge_info),

	INTEL_IVB_D_IDS(&intel_ivybridge_info),
	INTEL_IVB_M_IDS(&intel_ivybridge_info),

	INTEL_HSW_D_IDS(&intel_haswell_info),
	INTEL_HSW_M_IDS(&intel_haswell_info),

	INTEL_VLV_D_IDS(&intel_valleyview_info),
	INTEL_VLV_M_IDS(&intel_valleyview_info),

	INTEL_BDW_D_IDS(&intel_broadwell_info),
	INTEL_BDW_M_IDS(&intel_broadwell_info),

	INTEL_CHV_IDS(&intel_cherryview_info),

	INTEL_VGA_DEVICE(PCI_MATCH_ANY, &intel_generic_info),
#endif

	{ 0, 0, 0 },
};

void
intel_detect_chipset(ScrnInfoPtr scrn, EntityInfoPtr ent)
{
	MessageType from = X_PROBED;
	const char *name = NULL;
	int devid;
	int i;

	if (ent->device->chipID >= 0) {
		xf86DrvMsg(scrn->scrnIndex, from = X_CONFIG,
			   "ChipID override: 0x%04X\n",
			   ent->device->chipID);
		devid = ent->device->chipID;
	} else {
		struct pci_device *pci;

		pci = xf86GetPciInfoForEntity(ent->index);
		if (pci != NULL)
			devid = pci->device_id;
		else
			devid = intel_get_device_id(scrn);
	}

	for (i = 0; intel_chipsets[i].name != NULL; i++) {
		if (devid == intel_chipsets[i].token) {
			name = intel_chipsets[i].name;
			break;
		}
	}
	if (name == NULL) {
		int gen = 0;

		for (i = 0; intel_device_match[i].device_id != 0; i++) {
			if (devid == intel_device_match[i].device_id) {
				const struct intel_device_info *info = (void *)intel_device_match[i].match_data;
				gen = info->gen >> 3;
				break;
			}
		}

		if (gen) {
			xf86DrvMsg(scrn->scrnIndex, from,
				   "gen%d engineering sample\n", gen);
		} else {
			xf86DrvMsg(scrn->scrnIndex, X_WARNING,
				   "Unknown chipset\n");
		}

		name = "unknown";
	} else {
		xf86DrvMsg(scrn->scrnIndex, from,
			   "Integrated Graphics Chipset: Intel(R) %s\n",
			   name);
	}

	scrn->chipset = (char *)name;
}

/*
 * intel_identify --
 *
 * Returns the string name for the driver based on the chipset.
 *
 */
static void intel_identify(int flags)
{
	const SymTabRec *chipset;
	const char *stack[64], **unique;
	int i, j, size, len;

	unique = stack;
	size = sizeof(stack)/sizeof(stack[0]);
	i = 0;

	xf86Msg(X_INFO, INTEL_NAME ": Driver for Intel(R) Integrated Graphics Chipsets:\n\t");
	len = 8;

	for (chipset = intel_chipsets; chipset->token; chipset++) {
		for (j = i; --j >= 0;)
			if (strcmp(unique[j], chipset->name) == 0)
				break;
		if (j < 0) {
			int name_len = strlen(chipset->name);
			if (i != 0) {
				xf86ErrorF(",");
				len++;
				if (len + 2 + name_len < 78) {
					xf86ErrorF(" ");
					len++;
				} else {
					xf86ErrorF("\n\t");
					len = 8;
				}
			}
			xf86ErrorF("%s", chipset->name);
			len += name_len;

			if (i == size) {
				const char **new_unique;

				if (unique == stack)
					new_unique = malloc(2*sizeof(*unique)*size);
				else
					new_unique = realloc(unique, 2*sizeof(*unique)*size);
				if (new_unique != NULL) {
					if (unique == stack)
						memcpy(new_unique, stack,
						       sizeof(stack));
					unique = new_unique;
					size *= 2;
				}
			}
			if (i < size)
				unique[i++] = chipset->name;
		}
	}
	xf86ErrorF("\n");
	if (unique != stack)
		free(unique);

	xf86Msg(X_INFO, INTEL_NAME ": Driver for Intel(R) HD Graphics: 2000-6000\n");
	xf86Msg(X_INFO, INTEL_NAME ": Driver for Intel(R) Iris(TM) Graphics: 5100, 6100\n");
	xf86Msg(X_INFO, INTEL_NAME ": Driver for Intel(R) Iris(TM) Pro Graphics: 5200, 6200, P6300\n");
}

static Bool intel_driver_func(ScrnInfoPtr pScrn,
			      xorgDriverFuncOp op,
			      pointer ptr)
{
	xorgHWFlags *flag;

	switch (op) {
	case GET_REQUIRED_HW_INTERFACES:
		flag = (CARD32*)ptr;
		(*flag) = 0;
#if UMS
		(*flag) = HW_IO | HW_MMIO;
#endif
#ifdef HW_SKIP_CONSOLE
		if (hosted())
			(*flag) = HW_SKIP_CONSOLE;
#endif

		return TRUE;

#if XORG_VERSION_CURRENT >= XORG_VERSION_NUMERIC(1,15,99,902,0)
	case SUPPORTS_SERVER_FDS:
		return TRUE;
#endif

	default:
		/* Unknown or deprecated function */
		return FALSE;
	}
}

#if KMS
extern XF86ConfigPtr xf86configptr;

static XF86ConfDevicePtr
_xf86findDriver(const char *ident, XF86ConfDevicePtr p)
{
	while (p) {
		if (p->dev_driver && xf86nameCompare(ident, p->dev_driver) == 0)
			return p;

		p = p->list.next;
	}

	return NULL;
}

static enum accel_method { NOACCEL, SNA, UXA, GLAMOR } get_accel_method(void)
{
	enum accel_method accel_method = DEFAULT_ACCEL_METHOD;
	XF86ConfDevicePtr dev;

	if (hosted())
		return SNA;

	dev = _xf86findDriver("intel", xf86configptr->conf_device_lst);
	if (dev && dev->dev_option_lst) {
		const char *s;

		s = xf86FindOptionValue(dev->dev_option_lst, "AccelMethod");
		if (s ) {
			if (strcasecmp(s, "none") == 0)
				accel_method = NOACCEL;
			else if (strcasecmp(s, "sna") == 0)
				accel_method = SNA;
			else if (strcasecmp(s, "uxa") == 0)
				accel_method = UXA;
			else if (strcasecmp(s, "glamor") == 0)
				accel_method = GLAMOR;
		}
	}

	return accel_method;
}
#endif

static Bool
intel_scrn_create(DriverPtr		driver,
		  int			entity_num,
		  intptr_t		match_data,
		  unsigned		flags)
{
	ScrnInfoPtr scrn;

	if (match_data == 0) {
		int devid = intel_entity_get_devid(entity_num), i;
		if (devid == 0)
			return FALSE;

		for (i = 0; intel_device_match[i].device_id != 0; i++) {
			if (devid == intel_device_match[i].device_id) {
				match_data = (intptr_t)&intel_device_match[i];
				break;
			}
		}

		if (match_data == 0)
			return FALSE;
	}

	scrn = xf86AllocateScreen(driver, flags);
	if (scrn == NULL)
		return FALSE;

	scrn->driverVersion = INTEL_VERSION;
	scrn->driverName = (char *)INTEL_DRIVER_NAME;
	scrn->name = (char *)INTEL_NAME;
	scrn->driverPrivate = (void *)(match_data | (flags & XF86_ALLOCATE_GPU_SCREEN) | 2);
	scrn->Probe = NULL;

	if (xf86IsEntitySharable(entity_num))
		xf86SetEntityShared(entity_num);
	xf86AddEntityToScreen(scrn, entity_num);

#if UMS
	if ((unsigned)((struct intel_device_info *)match_data)->gen < 020)
		return lg_i810_init(scrn);
#endif

#if KMS
	switch (get_accel_method()) {
#if USE_SNA
	case NOACCEL:
	case SNA:
		return sna_init_scrn(scrn, entity_num);
#endif
#if USE_UXA
#if !USE_SNA
	case NOACCEL:
#endif
	case GLAMOR:
	case UXA:
		  return intel_init_scrn(scrn);
#endif

	default: break;
	}
#endif

	return FALSE;
}

/*
 * intel_pci_probe --
 *
 * Look through the PCI bus to find cards that are intel boards.
 * Setup the dispatch table for the rest of the driver functions.
 *
 */
static Bool intel_pci_probe(DriverPtr		driver,
			    int			entity_num,
			    struct pci_device	*pci,
			    intptr_t		match_data)
{
	if (intel_open_device(entity_num, pci, NULL) == -1) {
#if UMS
		switch (pci->device_id) {
		case PCI_CHIP_I810:
		case PCI_CHIP_I810_DC100:
		case PCI_CHIP_I810_E:
		case PCI_CHIP_I815:
			if (!hosted())
				break;
		default:
			return FALSE;
		}
#else
		return FALSE;
#endif
	}

	return intel_scrn_create(driver, entity_num, match_data, 0);
}

#ifdef XSERVER_PLATFORM_BUS
static Bool
intel_platform_probe(DriverPtr driver,
		     int entity_num, int flags,
		     struct xf86_platform_device *dev,
		     intptr_t match_data)
{
	unsigned scrn_flags = 0;

	if (intel_open_device(entity_num, dev->pdev, dev) == -1)
		return FALSE;

	/* Allow ourselves to act as a slaved output if not primary */
	if (flags & PLATFORM_PROBE_GPU_SCREEN) {
		flags &= ~PLATFORM_PROBE_GPU_SCREEN;
		scrn_flags |= XF86_ALLOCATE_GPU_SCREEN;
	}

	/* if we get any flags we don't understand fail to probe for now */
	if (flags)
		return FALSE;

	return intel_scrn_create(driver, entity_num, match_data, scrn_flags);
}
#endif

#ifdef XFree86LOADER

static MODULESETUPPROTO(intel_setup);

static XF86ModuleVersionInfo intel_version = {
	"intel",
	MODULEVENDORSTRING,
	MODINFOSTRING1,
	MODINFOSTRING2,
	XORG_VERSION_CURRENT,
	INTEL_VERSION_MAJOR, INTEL_VERSION_MINOR, INTEL_VERSION_PATCH,
	ABI_CLASS_VIDEODRV,
	ABI_VIDEODRV_VERSION,
	MOD_CLASS_VIDEODRV,
	{0, 0, 0, 0}
};

static const OptionInfoRec *
intel_available_options(int chipid, int busid)
{
	switch (chipid) {
#if UMS
	case PCI_CHIP_I810:
	case PCI_CHIP_I810_DC100:
	case PCI_CHIP_I810_E:
	case PCI_CHIP_I815:
		return lg_i810_available_options(chipid, busid);
#endif

	default:
		return intel_options;
	}
}

static DriverRec intel = {
	INTEL_VERSION,
	(char *)INTEL_DRIVER_NAME,
	intel_identify,
	NULL,
	intel_available_options,
	NULL,
	0,
	intel_driver_func,
	intel_device_match,
	intel_pci_probe,
#ifdef XSERVER_PLATFORM_BUS
	intel_platform_probe
#endif
};

static pointer intel_setup(pointer module,
			   pointer opts,
			   int *errmaj,
			   int *errmin)
{
	static Bool setupDone = 0;

	/* This module should be loaded only once, but check to be sure.
	*/
	if (!setupDone) {
		setupDone = 1;
		xf86AddDriver(&intel, module, HaveDriverFuncs);

		/*
		 * The return value must be non-NULL on success even though there
		 * is no TearDownProc.
		 */
		return (pointer) 1;
	} else {
		if (errmaj)
			*errmaj = LDR_ONCEONLY;
		return NULL;
	}
}

_X_EXPORT XF86ModuleData intelModuleData = { &intel_version, intel_setup, NULL };
#endif
@


1.6
log
@Update to xf86-video-intel 2.99.909
Tested by jsg@@, kettenis@@ and myself on a wide range of intel cards.
@
text
@d53 4
d121 4
d231 32
d276 1
a276 1
	INTEL_I845G_IDS(&intel_i830_info),
d312 2
d440 3
a442 3
	xf86Msg(X_INFO, INTEL_NAME ": Driver for Intel(R) HD Graphics: 2000-5000\n");
	xf86Msg(X_INFO, INTEL_NAME ": Driver for Intel(R) Iris(TM) Graphics: 5100\n");
	xf86Msg(X_INFO, INTEL_NAME ": Driver for Intel(R) Iris(TM) Pro Graphics: 5200\n");
d464 6
d492 1
a492 1
static enum accel_method { SNA, UXA, GLAMOR } get_accel_method(void)
d506 3
a508 1
			if (strcasecmp(s, "sna") == 0)
d552 1
a552 1
	scrn->driverPrivate = (void *)(match_data | 1);
d567 3
a569 1
	case SNA: return sna_init_scrn(scrn, entity_num);
d572 3
@


1.5
log
@Update to xf86-video-intel 2.20.19.

A recent kernel with kernel modesetting support is required.
Thanks to jsg@@ and kettenis@@ for their work.
@
text
@d31 4
a34 2
#include <unistd.h>
#include <xf86_OSproc.h>
a35 5
#include <xf86drm.h>
#include <xf86drmMode.h>
#include <i915_drm.h>

#include <xorgVersion.h>
a40 1
#include "common.h"
d45 3
d106 1
a106 1
	.gen = 070,
d113 4
d151 73
a223 53
	{PCI_CHIP_IRONLAKE_D_G,			"Clarkdale"},
	{PCI_CHIP_IRONLAKE_M_G,			"Arrandale"},
	{PCI_CHIP_SANDYBRIDGE_GT1,		"Sandybridge Desktop (GT1)" },
	{PCI_CHIP_SANDYBRIDGE_GT2,		"Sandybridge Desktop (GT2)" },
	{PCI_CHIP_SANDYBRIDGE_GT2_PLUS,		"Sandybridge Desktop (GT2+)" },
	{PCI_CHIP_SANDYBRIDGE_M_GT1,		"Sandybridge Mobile (GT1)" },
	{PCI_CHIP_SANDYBRIDGE_M_GT2,		"Sandybridge Mobile (GT2)" },
	{PCI_CHIP_SANDYBRIDGE_M_GT2_PLUS,	"Sandybridge Mobile (GT2+)" },
	{PCI_CHIP_SANDYBRIDGE_S_GT,		"Sandybridge Server" },
	{PCI_CHIP_IVYBRIDGE_M_GT1,		"Ivybridge Mobile (GT1)" },
	{PCI_CHIP_IVYBRIDGE_M_GT2,		"Ivybridge Mobile (GT2)" },
	{PCI_CHIP_IVYBRIDGE_D_GT1,		"Ivybridge Desktop (GT1)" },
	{PCI_CHIP_IVYBRIDGE_D_GT2,		"Ivybridge Desktop (GT2)" },
	{PCI_CHIP_IVYBRIDGE_S_GT1,		"Ivybridge Server" },
	{PCI_CHIP_IVYBRIDGE_S_GT2,		"Ivybridge Server (GT2)" },
	{PCI_CHIP_HASWELL_D_GT1,		"Haswell Desktop (GT1)" },
	{PCI_CHIP_HASWELL_D_GT2,		"Haswell Desktop (GT2)" },
	{PCI_CHIP_HASWELL_D_GT2_PLUS,		"Haswell Desktop (GT2+)" },
	{PCI_CHIP_HASWELL_M_GT1,		"Haswell Mobile (GT1)" },
	{PCI_CHIP_HASWELL_M_GT2,		"Haswell Mobile (GT2)" },
	{PCI_CHIP_HASWELL_M_GT2_PLUS,		"Haswell Mobile (GT2+)" },
	{PCI_CHIP_HASWELL_S_GT1,		"Haswell Server (GT1)" },
	{PCI_CHIP_HASWELL_S_GT2,		"Haswell Server (GT2)" },
	{PCI_CHIP_HASWELL_S_GT2_PLUS,		"Haswell Server (GT2+)" },
	{PCI_CHIP_HASWELL_SDV_D_GT1,		"Haswell SDV Desktop (GT1)" },
	{PCI_CHIP_HASWELL_SDV_D_GT2,		"Haswell SDV Desktop (GT2)" },
	{PCI_CHIP_HASWELL_SDV_D_GT2_PLUS,	"Haswell SDV Desktop (GT2+)" },
	{PCI_CHIP_HASWELL_SDV_M_GT1,		"Haswell SDV Mobile (GT1)" },
	{PCI_CHIP_HASWELL_SDV_M_GT2,		"Haswell SDV Mobile (GT2)" },
	{PCI_CHIP_HASWELL_SDV_M_GT2_PLUS,	"Haswell SDV Mobile (GT2+)" },
	{PCI_CHIP_HASWELL_SDV_S_GT1,		"Haswell SDV Server (GT1)" },
	{PCI_CHIP_HASWELL_SDV_S_GT2,		"Haswell SDV Server (GT2)" },
	{PCI_CHIP_HASWELL_SDV_S_GT2_PLUS,	"Haswell SDV Server (GT2+)" },
	{PCI_CHIP_HASWELL_ULT_D_GT1,		"Haswell ULT Desktop (GT1)" },
	{PCI_CHIP_HASWELL_ULT_D_GT2,		"Haswell ULT Desktop (GT2)" },
	{PCI_CHIP_HASWELL_ULT_D_GT2_PLUS,	"Haswell ULT Desktop (GT2+)" },
	{PCI_CHIP_HASWELL_ULT_M_GT1,		"Haswell ULT Mobile (GT1)" },
	{PCI_CHIP_HASWELL_ULT_M_GT2,		"Haswell ULT Mobile (GT2)" },
	{PCI_CHIP_HASWELL_ULT_M_GT2_PLUS,	"Haswell ULT Mobile (GT2+)" },
	{PCI_CHIP_HASWELL_ULT_S_GT1,		"Haswell ULT Server (GT1)" },
	{PCI_CHIP_HASWELL_ULT_S_GT2,		"Haswell ULT Server (GT2)" },
	{PCI_CHIP_HASWELL_ULT_S_GT2_PLUS,	"Haswell ULT Server (GT2+)" },
	{PCI_CHIP_HASWELL_CRW_D_GT1,		"Haswell CRW Desktop (GT1)" },
	{PCI_CHIP_HASWELL_CRW_D_GT2,		"Haswell CRW Desktop (GT2)" },
	{PCI_CHIP_HASWELL_CRW_D_GT2_PLUS,	"Haswell CRW Desktop (GT2+)" },
	{PCI_CHIP_HASWELL_CRW_M_GT1,		"Haswell CRW Mobile (GT1)" },
	{PCI_CHIP_HASWELL_CRW_M_GT2,		"Haswell CRW Mobile (GT2)" },
	{PCI_CHIP_HASWELL_CRW_M_GT2_PLUS,	"Haswell CRW Mobile (GT2+)" },
	{PCI_CHIP_HASWELL_CRW_S_GT1,		"Haswell CRW Server (GT1)" },
	{PCI_CHIP_HASWELL_CRW_S_GT2,		"Haswell CRW Server (GT2)" },
	{PCI_CHIP_HASWELL_CRW_S_GT2_PLUS,	"Haswell CRW Server (GT2+)" },
	{PCI_CHIP_VALLEYVIEW_PO,		"ValleyView PO board" },
	{-1,					NULL}
a224 1
#define NUM_CHIPSETS (sizeof(intel_chipsets) / sizeof(intel_chipsets[0]))
d226 21
a246 2
#define INTEL_DEVICE_MATCH(d,i) \
    { 0x8086, (d), PCI_MATCH_ANY, PCI_MATCH_ANY, 0x3 << 16, 0xff << 16, (intptr_t)(i) }
d248 20
a267 100
static const struct pci_id_match intel_device_match[] = {
#if !KMS_ONLY
	INTEL_DEVICE_MATCH (PCI_CHIP_I810, &intel_i81x_info ),
	INTEL_DEVICE_MATCH (PCI_CHIP_I810_DC100, &intel_i81x_info ),
	INTEL_DEVICE_MATCH (PCI_CHIP_I810_E, &intel_i81x_info ),
	INTEL_DEVICE_MATCH (PCI_CHIP_I815, &intel_i81x_info ),
#endif

#if !UMS_ONLY
	INTEL_DEVICE_MATCH (PCI_CHIP_I830_M, &intel_i830_info ),
	INTEL_DEVICE_MATCH (PCI_CHIP_845_G, &intel_i845_info ),
	INTEL_DEVICE_MATCH (PCI_CHIP_I854, &intel_i855_info ),
	INTEL_DEVICE_MATCH (PCI_CHIP_I855_GM, &intel_i855_info ),
	INTEL_DEVICE_MATCH (PCI_CHIP_I865_G, &intel_i865_info ),

	INTEL_DEVICE_MATCH (PCI_CHIP_I915_G, &intel_i915_info ),
	INTEL_DEVICE_MATCH (PCI_CHIP_E7221_G, &intel_i915_info ),
	INTEL_DEVICE_MATCH (PCI_CHIP_I915_GM, &intel_i915_info ),
	INTEL_DEVICE_MATCH (PCI_CHIP_I945_G, &intel_i945_info ),
	INTEL_DEVICE_MATCH (PCI_CHIP_I945_GM, &intel_i945_info ),
	INTEL_DEVICE_MATCH (PCI_CHIP_I945_GME, &intel_i945_info ),

	INTEL_DEVICE_MATCH (PCI_CHIP_PINEVIEW_M, &intel_g33_info ),
	INTEL_DEVICE_MATCH (PCI_CHIP_PINEVIEW_G, &intel_g33_info ),
	INTEL_DEVICE_MATCH (PCI_CHIP_G33_G, &intel_g33_info ),
	INTEL_DEVICE_MATCH (PCI_CHIP_Q33_G, &intel_g33_info ),
	/* Another marketing win: Q35 is another g33 device not a gen4 part
	 * like its G35 brethren.
	 */
	INTEL_DEVICE_MATCH (PCI_CHIP_Q35_G, &intel_g33_info ),

	INTEL_DEVICE_MATCH (PCI_CHIP_I965_G, &intel_i965_info ),
	INTEL_DEVICE_MATCH (PCI_CHIP_G35_G, &intel_i965_info ),
	INTEL_DEVICE_MATCH (PCI_CHIP_I965_Q, &intel_i965_info ),
	INTEL_DEVICE_MATCH (PCI_CHIP_I946_GZ, &intel_i965_info ),
	INTEL_DEVICE_MATCH (PCI_CHIP_I965_GM, &intel_i965_info ),
	INTEL_DEVICE_MATCH (PCI_CHIP_I965_GME, &intel_i965_info ),

	INTEL_DEVICE_MATCH (PCI_CHIP_GM45_GM, &intel_g4x_info ),
	INTEL_DEVICE_MATCH (PCI_CHIP_G45_E_G, &intel_g4x_info ),
	INTEL_DEVICE_MATCH (PCI_CHIP_G45_G, &intel_g4x_info ),
	INTEL_DEVICE_MATCH (PCI_CHIP_Q45_G, &intel_g4x_info ),
	INTEL_DEVICE_MATCH (PCI_CHIP_G41_G, &intel_g4x_info ),
	INTEL_DEVICE_MATCH (PCI_CHIP_B43_G, &intel_g4x_info ),
	INTEL_DEVICE_MATCH (PCI_CHIP_B43_G1, &intel_g4x_info ),

	INTEL_DEVICE_MATCH (PCI_CHIP_IRONLAKE_D_G, &intel_ironlake_info ),
	INTEL_DEVICE_MATCH (PCI_CHIP_IRONLAKE_M_G, &intel_ironlake_info ),

	INTEL_DEVICE_MATCH (PCI_CHIP_SANDYBRIDGE_GT1, &intel_sandybridge_info ),
	INTEL_DEVICE_MATCH (PCI_CHIP_SANDYBRIDGE_GT2, &intel_sandybridge_info ),
	INTEL_DEVICE_MATCH (PCI_CHIP_SANDYBRIDGE_GT2_PLUS, &intel_sandybridge_info ),
	INTEL_DEVICE_MATCH (PCI_CHIP_SANDYBRIDGE_M_GT1, &intel_sandybridge_info ),
	INTEL_DEVICE_MATCH (PCI_CHIP_SANDYBRIDGE_M_GT2, &intel_sandybridge_info ),
	INTEL_DEVICE_MATCH (PCI_CHIP_SANDYBRIDGE_M_GT2_PLUS, &intel_sandybridge_info ),
	INTEL_DEVICE_MATCH (PCI_CHIP_SANDYBRIDGE_S_GT, &intel_sandybridge_info ),

	INTEL_DEVICE_MATCH (PCI_CHIP_IVYBRIDGE_M_GT1, &intel_ivybridge_info ),
	INTEL_DEVICE_MATCH (PCI_CHIP_IVYBRIDGE_M_GT2, &intel_ivybridge_info ),
	INTEL_DEVICE_MATCH (PCI_CHIP_IVYBRIDGE_D_GT1, &intel_ivybridge_info ),
	INTEL_DEVICE_MATCH (PCI_CHIP_IVYBRIDGE_D_GT2, &intel_ivybridge_info ),
	INTEL_DEVICE_MATCH (PCI_CHIP_IVYBRIDGE_S_GT1, &intel_ivybridge_info ),
	INTEL_DEVICE_MATCH (PCI_CHIP_IVYBRIDGE_S_GT2, &intel_ivybridge_info ),

	INTEL_DEVICE_MATCH (PCI_CHIP_HASWELL_D_GT1, &intel_haswell_info ),
	INTEL_DEVICE_MATCH (PCI_CHIP_HASWELL_D_GT2, &intel_haswell_info ),
	INTEL_DEVICE_MATCH (PCI_CHIP_HASWELL_D_GT2_PLUS, &intel_haswell_info ),
	INTEL_DEVICE_MATCH (PCI_CHIP_HASWELL_M_GT1, &intel_haswell_info ),
	INTEL_DEVICE_MATCH (PCI_CHIP_HASWELL_M_GT2, &intel_haswell_info ),
	INTEL_DEVICE_MATCH (PCI_CHIP_HASWELL_M_GT2_PLUS, &intel_haswell_info ),
	INTEL_DEVICE_MATCH (PCI_CHIP_HASWELL_S_GT1, &intel_haswell_info ),
	INTEL_DEVICE_MATCH (PCI_CHIP_HASWELL_S_GT2, &intel_haswell_info ),
	INTEL_DEVICE_MATCH (PCI_CHIP_HASWELL_S_GT2_PLUS, &intel_haswell_info ),
	INTEL_DEVICE_MATCH (PCI_CHIP_HASWELL_SDV_D_GT1, &intel_haswell_info ),
	INTEL_DEVICE_MATCH (PCI_CHIP_HASWELL_SDV_D_GT2, &intel_haswell_info ),
	INTEL_DEVICE_MATCH (PCI_CHIP_HASWELL_SDV_D_GT2_PLUS, &intel_haswell_info ),
	INTEL_DEVICE_MATCH (PCI_CHIP_HASWELL_SDV_M_GT1, &intel_haswell_info ),
	INTEL_DEVICE_MATCH (PCI_CHIP_HASWELL_SDV_M_GT2, &intel_haswell_info ),
	INTEL_DEVICE_MATCH (PCI_CHIP_HASWELL_SDV_M_GT2_PLUS, &intel_haswell_info ),
	INTEL_DEVICE_MATCH (PCI_CHIP_HASWELL_SDV_S_GT1, &intel_haswell_info ),
	INTEL_DEVICE_MATCH (PCI_CHIP_HASWELL_SDV_S_GT2, &intel_haswell_info ),
	INTEL_DEVICE_MATCH (PCI_CHIP_HASWELL_SDV_S_GT2_PLUS, &intel_haswell_info ),
	INTEL_DEVICE_MATCH (PCI_CHIP_HASWELL_ULT_D_GT1, &intel_haswell_info ),
	INTEL_DEVICE_MATCH (PCI_CHIP_HASWELL_ULT_D_GT2, &intel_haswell_info ),
	INTEL_DEVICE_MATCH (PCI_CHIP_HASWELL_ULT_D_GT2_PLUS, &intel_haswell_info ),
	INTEL_DEVICE_MATCH (PCI_CHIP_HASWELL_ULT_M_GT1, &intel_haswell_info ),
	INTEL_DEVICE_MATCH (PCI_CHIP_HASWELL_ULT_M_GT2, &intel_haswell_info ),
	INTEL_DEVICE_MATCH (PCI_CHIP_HASWELL_ULT_M_GT2_PLUS, &intel_haswell_info ),
	INTEL_DEVICE_MATCH (PCI_CHIP_HASWELL_ULT_S_GT1, &intel_haswell_info ),
	INTEL_DEVICE_MATCH (PCI_CHIP_HASWELL_ULT_S_GT2, &intel_haswell_info ),
	INTEL_DEVICE_MATCH (PCI_CHIP_HASWELL_ULT_S_GT2_PLUS, &intel_haswell_info ),
	INTEL_DEVICE_MATCH (PCI_CHIP_HASWELL_CRW_D_GT1, &intel_haswell_info ),
	INTEL_DEVICE_MATCH (PCI_CHIP_HASWELL_CRW_D_GT2, &intel_haswell_info ),
	INTEL_DEVICE_MATCH (PCI_CHIP_HASWELL_CRW_D_GT2_PLUS, &intel_haswell_info ),
	INTEL_DEVICE_MATCH (PCI_CHIP_HASWELL_CRW_M_GT1, &intel_haswell_info ),
	INTEL_DEVICE_MATCH (PCI_CHIP_HASWELL_CRW_M_GT2, &intel_haswell_info ),
	INTEL_DEVICE_MATCH (PCI_CHIP_HASWELL_CRW_M_GT2_PLUS, &intel_haswell_info ),
	INTEL_DEVICE_MATCH (PCI_CHIP_HASWELL_CRW_S_GT1, &intel_haswell_info ),
	INTEL_DEVICE_MATCH (PCI_CHIP_HASWELL_CRW_S_GT2, &intel_haswell_info ),
	INTEL_DEVICE_MATCH (PCI_CHIP_HASWELL_CRW_S_GT2_PLUS, &intel_haswell_info ),
d269 2
a270 1
	INTEL_DEVICE_MATCH (PCI_CHIP_VALLEYVIEW_PO, &intel_valleyview_info ),
d272 1
a272 1
	INTEL_DEVICE_MATCH (PCI_MATCH_ANY, &intel_generic_info ),
d279 1
a279 3
intel_detect_chipset(ScrnInfoPtr scrn,
		     EntityInfoPtr ent,
		     struct pci_device *pci)
d283 1
d290 9
a298 1
		DEVICE_ID(pci) = ent->device->chipID;
d302 1
a302 1
		if (DEVICE_ID(pci) == intel_chipsets[i].token) {
d308 18
a325 1
		xf86DrvMsg(scrn->scrnIndex, X_WARNING, "unknown chipset\n");
d333 1
a333 1
	scrn->chipset = name;
d344 57
a400 3
	xf86PrintChipsets(INTEL_NAME,
			  "Driver for Intel Integrated Graphics Chipsets",
			  intel_chipsets);
a411 1
#ifdef KMS_ONLY
d413 1
a413 1
#else
d416 5
d428 1
a428 42
static Bool has_kernel_mode_setting(const struct pci_device *dev)
{
	char id[20];
	int ret, fd;

	snprintf(id, sizeof(id),
		 "pci:%04x:%02x:%02x.%d",
		 dev->domain, dev->bus, dev->dev, dev->func);

	ret = drmCheckModesettingSupported(id);
	if (ret) {
		if (xf86LoadKernelModule("i915"))
			ret = drmCheckModesettingSupported(id);
		if (ret)
			return FALSE;
		/* Be nice to the user and load fbcon too */
		(void)xf86LoadKernelModule("fbcon");
	}

	/* Confirm that this is a i915.ko device with GEM/KMS enabled */
	ret = FALSE;
	fd = drmOpen(NULL, id);
	if (fd != -1) {
		drmVersionPtr version = drmGetVersion(fd);
		if (version) {
			ret = strcmp ("i915", version->name) == 0;
			drmFreeVersion(version);
		}
		if (ret) {
			struct drm_i915_getparam gp;
			gp.param = I915_PARAM_HAS_GEM;
			gp.value = &ret;
			if (drmIoctl(fd, DRM_IOCTL_I915_GETPARAM, &gp))
				ret = FALSE;
		}
		close(fd);
	}

	return ret;
}

#if !UMS_ONLY
d444 1
a444 1
static enum accel_method { UXA, SNA } get_accel_method(void)
d449 3
d463 1
a463 1
				accel_method = UXA;
d479 16
d500 2
a501 2
	scrn->driverName = INTEL_DRIVER_NAME;
	scrn->name = INTEL_NAME;
d509 2
a510 2
#if !KMS_ONLY
	if (((struct intel_device_info *)match_data)->gen < 020)
d514 1
a514 1
#if !UMS_ONLY
d520 3
a522 1
	case UXA: return intel_init_scrn(scrn);
d541 1
a541 1
			    struct pci_device	*device,
d544 3
a546 5
	if (!has_kernel_mode_setting(device)) {
#if KMS_ONLY
		return FALSE;
#else
		switch (DEVICE_ID(device)) {
d551 2
a552 1
			break;
d556 2
d573 1
a573 4
	if (!dev->pdev)
		return FALSE;

	if (!has_kernel_mode_setting(dev->pdev))
d611 1
a611 1
#if !KMS_ONLY
d626 1
a626 1
	INTEL_DRIVER_NAME,
@


1.4
log
@- sync the "legacy" i810 driver, used only on true i810 and i815
  chipsets to the one in recent intel driver from X.Org.

- remove one of the output probe method in i830PreInit(). This method is
  calling functions that are normally forbidden in PreInit(). With
  xserver 1.13 this causes a fatal error at run time.

Tested by bluhm@@, nick@@ and shadchin@@ back in september.
@
text
@d31 12
a42 3
#include "xf86.h"
#include "xf86_OSproc.h"
#include "xf86cmap.h"
a44 1
#include "intel.h"
d46 1
d48 1
d50 3
d54 3
a56 1
static struct intel_device_info *chipset_info;
d59 1
a59 1
	.gen = 10,
d62 11
a72 2
static const struct intel_device_info intel_i8xx_info = {
	.gen = 20,
d76 4
a79 1
	.gen = 30,
d83 1
a83 1
	.gen = 33,
d87 1
a87 1
	.gen = 40,
d91 1
a91 1
	.gen = 45,
d95 1
a95 1
	.gen = 50,
d99 1
a99 1
	.gen = 60,
d103 5
a107 1
	.gen = 70,
d110 5
a114 1
static const SymTabRec _intel_chipsets[] = {
d161 1
a161 1
	{PCI_CHIP_IVYBRIDGE_S_GT1,		"Ivybridge Server (GT1)" },
d163 37
d202 1
a202 1
SymTabRec *intel_chipsets = (SymTabRec *) _intel_chipsets;
d205 1
a205 1
    { 0x8086, (d), PCI_MATCH_ANY, PCI_MATCH_ANY, 0, 0, (intptr_t)(i) }
d208 1
d213 1
d215 6
a220 5
	INTEL_DEVICE_MATCH (PCI_CHIP_I830_M, &intel_i8xx_info ),
	INTEL_DEVICE_MATCH (PCI_CHIP_845_G, &intel_i8xx_info ),
	INTEL_DEVICE_MATCH (PCI_CHIP_I854, &intel_i8xx_info ),
	INTEL_DEVICE_MATCH (PCI_CHIP_I855_GM, &intel_i8xx_info ),
	INTEL_DEVICE_MATCH (PCI_CHIP_I865_G, &intel_i8xx_info ),
d225 3
a227 3
	INTEL_DEVICE_MATCH (PCI_CHIP_I945_G, &intel_i915_info ),
	INTEL_DEVICE_MATCH (PCI_CHIP_I945_GM, &intel_i915_info ),
	INTEL_DEVICE_MATCH (PCI_CHIP_I945_GME, &intel_i915_info ),
d271 42
d316 4
a319 3
void intel_detect_chipset(ScrnInfoPtr scrn,
			  struct pci_device *pci,
			  struct intel_chipset *chipset)
d321 2
d325 6
a330 1
	chipset->info = chipset_info;
d334 1
a334 1
			chipset->name = intel_chipsets[i].name;
d338 7
a344 2
	if (intel_chipsets[i].name == NULL) {
		chipset->name = "unknown chipset";
d347 1
a347 2
	xf86DrvMsg(scrn->scrnIndex, X_INFO,
		   "Integrated Graphics Chipset: Intel(R) %s\n", chipset->name);
d384 124
d520 1
a520 21
	ScrnInfoPtr scrn;
	PciChipsets intel_pci_chipsets[ARRAY_SIZE(intel_chipsets)];
	int i;

	chipset_info = (void *)match_data;


	for (i = 0; i < ARRAY_SIZE(intel_chipsets); i++) {
		intel_pci_chipsets[i].numChipset = intel_chipsets[i].token;
		intel_pci_chipsets[i].PCIid = intel_chipsets[i].token;
		intel_pci_chipsets[i].dummy = NULL;
	}

	scrn = xf86ConfigPciEntity(NULL, 0, entity_num, intel_pci_chipsets,
				   NULL, NULL, NULL, NULL, NULL);
	if (scrn != NULL) {
		scrn->driverVersion = INTEL_VERSION;
		scrn->driverName = INTEL_DRIVER_NAME;
		scrn->name = INTEL_NAME;
		scrn->Probe = NULL;

d522 1
a522 1
		intel_init_scrn(scrn);
d529 1
a529 2
			return lg_i810_init(scrn);

d531 1
a531 2
			intel_init_scrn(scrn);
			break;
d535 30
a564 1
	return scrn != NULL;
d566 1
a587 3
#if KMS_ONLY
	return intel_uxa_available_options(chipid, busid);
#else
d589 1
d595 1
d598 1
a598 1
		return intel_uxa_available_options(chipid, busid);
a599 1
#endif
d612 4
a615 1
	intel_pci_probe
@


1.3
log
@Add basic support for ivy bridge and fix several cases of register
access not being adjusted for the pch split, one of which prevented
multiple display pipes from working.  The third pipe on ivy bridge
remains disabled for now.

ok kettenis@@ thanks to everyone who tested
@
text
@d296 1
a296 2
			lg_i810_init(scrn);
			break;
@


1.2
log
@Add support for Sandy Bridge.  Not perfect yet.  Most notably 3D acceleration
is completely absent, and playing video doesn't work yet.  But support for
"normal" 2D stuff is pretty solid and it is really nice to be able to use
my laptop at the panel's native resolution and be able to suspend and resume
the machine.

tested by some
@
text
@a121 1
#if 0
d126 2
a127 2
	{PCI_CHIP_IVYBRIDGE_S_GT1,		"Ivybridge Server" },
#endif
a188 1
#if 0
d194 1
a194 1
#endif
@


1.1
log
@Update the intel driver to a more recent version based on more recent
upsteam code.

Backporting keeping UMS changes by me, some bugfixes from kettenis@@.

Has been in snapshots for a while, committed on request so we can be
sure what people are running. This is a prerequesite for sandybridge
support but has those chipsets disabled for now until the correct code
has been added.
@
text
@a114 1
#if 0
d122 1
a181 1
#if 0
d190 1
@

