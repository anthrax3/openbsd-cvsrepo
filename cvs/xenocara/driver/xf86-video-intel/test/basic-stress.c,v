head	1.3;
access;
symbols
	OPENBSD_6_1:1.3.0.8
	OPENBSD_6_1_BASE:1.3
	OPENBSD_6_0:1.3.0.6
	OPENBSD_6_0_BASE:1.3
	OPENBSD_5_9:1.3.0.4
	OPENBSD_5_9_BASE:1.3
	OPENBSD_5_8:1.3.0.2
	OPENBSD_5_8_BASE:1.3
	OPENBSD_5_7:1.2.0.6
	OPENBSD_5_7_BASE:1.2
	OPENBSD_5_6:1.2.0.4
	OPENBSD_5_6_BASE:1.2
	OPENBSD_5_5:1.2.0.2
	OPENBSD_5_5_BASE:1.2
	OPENBSD_5_4:1.1.0.2
	OPENBSD_5_4_BASE:1.1;
locks; strict;
comment	@ * @;


1.3
date	2015.04.12.19.42.07;	author matthieu;	state Exp;
branches;
next	1.2;
commitid	DK857Z2Au1JEohAk;

1.2
date	2014.02.03.15.54.54;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2013.03.18.18.38.21;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.3
log
@Update to xf86-video-intel 2.99.916
Fixes a display bug seenby ajacoutot@@, ok jsg@@ and kettenis@@.
newer X.Org (2.99.917 or master) version cause corruption on older
machines (X40, i965), probably caused by a bug in our kernel,
under investigation by kettenis@@.
@
text
@#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>

#include <X11/Xutil.h> /* for XDestroyImage */
#include <pixman.h>

#include "test.h"

static void fill_rect(struct test_target *tt,
		      int alu, int color,
		      int x, int y, int w, int h)
{
	XGCValues val;

	val.function = alu;
	val.foreground = color;
	XChangeGC(tt->dpy->dpy, tt->gc, GCFunction | GCForeground, &val);

	XFillRectangle(tt->dpy->dpy, tt->draw, tt->gc, x, y, w, h);
}

static void clear(struct test_target *tt)
{
	fill_rect(tt,
		  GXcopy, 0,
		  0, 0, tt->width, tt->height);
}

static void fill(struct test_target *out,
		 struct test_target *ref)
{
	int x = rand() % (2*out->width) - out->width;
	int y = rand() % (2*out->height) - out->height;
	int w = rand() % (2*out->width);
	int h = rand() % (2*out->height);
	int color = rand();
	int alu = rand() % 16;

	fill_rect(out, alu, color, x, y, w, h);
	fill_rect(ref, alu, color, x, y, w, h);
}

static void copy(struct test_target *out,
		 struct test_target *ref)
{
	int sx = rand() % (2*out->width) - ref->width;
	int sy = rand() % (2*out->height) - ref->height;
	int dx = rand() % (2*out->width) - ref->width;
	int dy = rand() % (2*out->height) - ref->height;
	int w = rand() % (2*out->width);
	int h = rand() % (2*out->height);
	XGCValues val;

	val.function = rand() % 16;

	XChangeGC(out->dpy->dpy, out->gc, GCFunction, &val);
	XCopyArea(out->dpy->dpy,
		  out->draw, out->draw, out->gc,
		  sx, sy, w, h, dx, dy);

	XChangeGC(ref->dpy->dpy, ref->gc, GCFunction, &val);
	XCopyArea(ref->dpy->dpy,
		  ref->draw, ref->draw, ref->gc,
		  sx, sy, w, h, dx, dy);
}

static void _put(struct test_target *tt,
		 int x, int y, int w,int h, int color, int alu)
{
	XImage image;
	XGCValues val;

	val.function = alu;

	test_init_image(&image, &tt->dpy->shm, tt->format, w, h);
	pixman_fill((uint32_t*)image.data,
		    image.bytes_per_line/sizeof(uint32_t),
		    image.bits_per_pixel,
		    0, 0, w, h, color);

	XChangeGC(tt->dpy->dpy, tt->gc, GCFunction, &val);
	if (rand() & 1) {
		XShmPutImage(tt->dpy->dpy, tt->draw, tt->gc, &image,
			     0, 0, x, y, w, h, 0);
		XSync(tt->dpy->dpy, 1);
	} else {
		XPutImage(tt->dpy->dpy, tt->draw, tt->gc, &image,
			  0, 0, x, y, w, h);
	}
}

static void put(struct test_target *out,
		struct test_target *ref)
{
	int x = rand() % (2*out->width) - out->width;
	int y = rand() % (2*out->height) - out->height;
	int w = rand() % out->width;
	int h = rand() % out->height;
	int color = rand();
	int alu = rand() % 16;

	_put(out, x, y, w, h, color, alu);
	_put(ref, x, y, w, h, color, alu);
}

static void rect_tests(struct test *test, int iterations, enum target target)
{
	struct test_target out, ref;
	void (* const ops[])(struct test_target *, struct test_target *) = {
		copy,
		fill,
		put,
	};
	int n;

	printf("Running mixed ops stress against %s: ",
	       test_target_name(target));
	fflush(stdout);

	test_target_create_render(&test->out, target, &out);
	test_target_create_render(&test->ref, target, &ref);

	clear(&out);
	clear(&ref);

	for (n = 0; n < iterations; n++)
		ops[rand() % ARRAY_SIZE(ops)](&out, &ref);

	test_compare(test,
		     out.draw, out.format,
		     ref.draw, ref.format,
		     0, 0, out.width, out.height,
		     "");

	printf("passed [%d iterations]\n", n);

	test_target_destroy_render(&test->out, &out);
	test_target_destroy_render(&test->ref, &ref);
}

int main(int argc, char **argv)
{
	struct test test;
	int i;

	test_init(&test, argc, argv);

	for (i = 0; i <= DEFAULT_ITERATIONS; i++) {
		int iterations = REPS(i);
		rect_tests(&test, iterations, 0);
		rect_tests(&test, iterations, 1);
	}

	return 0;
}
@


1.2
log
@Update to xf86-video-intel 2.99.909
Tested by jsg@@, kettenis@@ and myself on a wide range of intel cards.
@
text
@d30 1
a30 1
static void fill(struct test_target *real,
d33 4
a36 4
	int x = rand() % (2*real->width) - real->width;
	int y = rand() % (2*real->height) - real->height;
	int w = rand() % (2*real->width);
	int h = rand() % (2*real->height);
d40 1
a40 1
	fill_rect(real, alu, color, x, y, w, h);
d44 1
a44 1
static void copy(struct test_target *real,
d47 6
a52 6
	int sx = rand() % (2*real->width) - ref->width;
	int sy = rand() % (2*real->height) - ref->height;
	int dx = rand() % (2*real->width) - ref->width;
	int dy = rand() % (2*real->height) - ref->height;
	int w = rand() % (2*real->width);
	int h = rand() % (2*real->height);
d57 3
a59 3
	XChangeGC(real->dpy->dpy, real->gc, GCFunction, &val);
	XCopyArea(real->dpy->dpy,
		  real->draw, real->draw, real->gc,
d93 1
a93 1
static void put(struct test_target *real,
d96 4
a99 4
	int x = rand() % (2*real->width) - real->width;
	int y = rand() % (2*real->height) - real->height;
	int w = rand() % real->width;
	int h = rand() % real->height;
d103 1
a103 1
	_put(real, x, y, w, h, color, alu);
d109 1
a109 1
	struct test_target real, ref;
d121 1
a121 1
	test_target_create_render(&test->real, target, &real);
d124 1
a124 1
	clear(&real);
d128 1
a128 1
		ops[rand() % ARRAY_SIZE(ops)](&real, &ref);
d131 1
a131 1
		     real.draw, real.format,
d133 1
a133 1
		     0, 0, real.width, real.height,
d138 1
a138 1
	test_target_destroy_render(&test->real, &real);
@


1.1
log
@Update to xf86-video-intel 2.20.19.

A recent kernel with kernel modesetting support is required.
Thanks to jsg@@ and kettenis@@ for their work.
@
text
@d150 1
a150 1
		int iterations = 1 << i;
@

