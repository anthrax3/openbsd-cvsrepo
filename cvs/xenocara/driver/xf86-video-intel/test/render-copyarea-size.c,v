head	1.3;
access;
symbols
	OPENBSD_6_1_BASE:1.3
	OPENBSD_6_0:1.3.0.6
	OPENBSD_6_0_BASE:1.3
	OPENBSD_5_9:1.3.0.4
	OPENBSD_5_9_BASE:1.3
	OPENBSD_5_8:1.3.0.2
	OPENBSD_5_8_BASE:1.3
	OPENBSD_5_7:1.2.0.6
	OPENBSD_5_7_BASE:1.2
	OPENBSD_5_6:1.2.0.4
	OPENBSD_5_6_BASE:1.2
	OPENBSD_5_5:1.2.0.2
	OPENBSD_5_5_BASE:1.2
	OPENBSD_5_4:1.1.0.2
	OPENBSD_5_4_BASE:1.1;
locks; strict;
comment	@ * @;


1.3
date	2015.04.12.19.42.07;	author matthieu;	state Exp;
branches;
next	1.2;
commitid	DK857Z2Au1JEohAk;

1.2
date	2014.02.03.15.54.54;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2013.03.18.18.38.21;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.3
log
@Update to xf86-video-intel 2.99.916
Fixes a display bug seenby ajacoutot@@, ok jsg@@ and kettenis@@.
newer X.Org (2.99.917 or master) version cause corruption on older
machines (X40, i965), probably caused by a bug in our kernel,
under investigation by kettenis@@.
@
text
@#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>

#include <X11/Xutil.h> /* for XDestroyImage */

#include "test.h"

#define SIZE 20000
struct draw {
	Pixmap a, b;
	Picture pa, pb;
	GC gc;
	XRenderPictFormat *format;
};

static void target_init(struct test_display *t, struct draw *tt, int size)
{
	XRenderColor color;

	tt->format = XRenderFindStandardFormat(t->dpy, PictStandardARGB32);

	tt->a = XCreatePixmap(t->dpy, DefaultRootWindow(t->dpy),
			      size, size, tt->format->depth);
	tt->pa = XRenderCreatePicture(t->dpy, tt->a, tt->format, 0, NULL);

	color.alpha = 0xffff;
	color.red = 0xffff;
	color.green = 0;
	color.blue = 0;
	XRenderFillRectangle(t->dpy, PictOpSrc, tt->pa, &color, 0, 0, size, size);

	tt->b = XCreatePixmap(t->dpy, DefaultRootWindow(t->dpy),
			      size, size, tt->format->depth);
	tt->pb = XRenderCreatePicture(t->dpy, tt->b, tt->format, 0, NULL);

	color.alpha = 0xffff;
	color.red = 0;
	color.green = 0;
	color.blue = 0xffff;
	XRenderFillRectangle(t->dpy, PictOpSrc, tt->pb, &color, 0, 0, size, size);
}

static void target_fini(struct test_display *t, struct draw *tt)
{
	XRenderFreePicture(t->dpy, tt->pa);
	XFreePixmap(t->dpy, tt->a);

	XRenderFreePicture(t->dpy, tt->pb);
	XFreePixmap(t->dpy, tt->b);
}

int main(int argc, char **argv)
{
	struct test test;
	struct draw out, ref;
	int size, i;

	test_init(&test, argc, argv);

	/* Copy back and forth betwenn two pixmaps, gradually getting larger */
	for (size = 1; size <= SIZE; size = (size * 3 + 1) / 2) {
		target_init(&test.out, &out, size);
		target_init(&test.ref, &ref, size);

		printf("size=%d\n", size);
		for (i = 0; i <= DEFAULT_ITERATIONS; i++) {
			int reps = REPS(i);
			do {
				int sx = rand() % (2*size) - size;
				int sy = rand() % (2*size) - size;

				int dx = rand() % (2*size) - size;
				int dy = rand() % (2*size) - size;

				int w = rand() % size;
				int h = rand() % size;

				int order = rand() & 1;

				XRenderComposite(test.out.dpy, PictOpSrc,
						 order ? out.pa : out.pb,
						 0,
						 (!order) ? out.pa : out.pb,
						 sx, sy,
						 0, 0,
						 dx, dy,
						 w, h);

				XRenderComposite(test.ref.dpy, PictOpSrc,
						 order ? ref.pa : ref.pb,
						 0,
						 (!order) ? ref.pa : ref.pb,
						 sx, sy,
						 0, 0,
						 dx, dy,
						 w, h);
			} while (--reps);
		}

		test_compare(&test,
			     out.a, out.format,
			     ref.a, ref.format,
			     0, 0, size, size,
			     "");
		test_compare(&test,
			     out.b, out.format,
			     ref.b, ref.format,
			     0, 0, size, size,
			     "");

		target_fini(&test.out, &out);
		target_fini(&test.ref, &ref);
	}

	return 0;
}
@


1.2
log
@Update to xf86-video-intel 2.99.909
Tested by jsg@@, kettenis@@ and myself on a wide range of intel cards.
@
text
@d56 1
a56 1
	struct draw real, ref;
d63 1
a63 1
		target_init(&test.real, &real, size);
d81 2
a82 2
				XRenderComposite(test.real.dpy, PictOpSrc,
						 order ? real.pa : real.pb,
d84 1
a84 1
						 (!order) ? real.pa : real.pb,
d102 1
a102 1
			     real.a, real.format,
d107 1
a107 1
			     real.b, real.format,
d112 1
a112 1
		target_fini(&test.real, &real);
@


1.1
log
@Update to xf86-video-intel 2.20.19.

A recent kernel with kernel modesetting support is required.
Thanks to jsg@@ and kettenis@@ for their work.
@
text
@d68 1
a68 1
			int reps = 1 << i;
@

