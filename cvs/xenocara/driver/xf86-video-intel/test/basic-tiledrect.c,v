head	1.2;
access;
symbols
	OPENBSD_6_2:1.2.0.10
	OPENBSD_6_2_BASE:1.2
	OPENBSD_6_1:1.2.0.8
	OPENBSD_6_1_BASE:1.2
	OPENBSD_6_0:1.2.0.6
	OPENBSD_6_0_BASE:1.2
	OPENBSD_5_9:1.2.0.4
	OPENBSD_5_9_BASE:1.2
	OPENBSD_5_8:1.2.0.2
	OPENBSD_5_8_BASE:1.2
	OPENBSD_5_7:1.1.0.6
	OPENBSD_5_7_BASE:1.1
	OPENBSD_5_6:1.1.0.4
	OPENBSD_5_6_BASE:1.1
	OPENBSD_5_5:1.1.0.2
	OPENBSD_5_5_BASE:1.1;
locks; strict;
comment	@ * @;


1.2
date	2015.04.12.19.42.07;	author matthieu;	state Exp;
branches;
next	1.1;
commitid	DK857Z2Au1JEohAk;

1.1
date	2014.02.03.15.54.54;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.2
log
@Update to xf86-video-intel 2.99.916
Fixes a display bug seenby ajacoutot@@, ok jsg@@ and kettenis@@.
newer X.Org (2.99.917 or master) version cause corruption on older
machines (X40, i965), probably caused by a bug in our kernel,
under investigation by kettenis@@.
@
text
@#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>

#include "test.h"

static const unsigned char data[] = {
	0xaa, 0x55, 0xaa, 0x55, 0xaa, 0x55, 0xaa, 0x55,
	0xaa, 0x55, 0xaa, 0x55, 0xaa, 0x55, 0xaa, 0x55,
	0xaa, 0x55, 0xaa, 0x55, 0xaa, 0x55, 0xaa, 0x55,
	0xaa, 0x55, 0xaa, 0x55, 0xaa, 0x55, 0xaa, 0x55,
};

static struct bitmap {
	int width, height;
	struct cache {
		Display *dpy;
		Pixmap pixmap;
	} cached[2];
} bitmaps[] = {
	{ 1, 1, },
	{ 1, 2, },
	{ 2, 3, },
	{ 3, 2, },
	{ 4, 4, },
	{ 6, 6, },
	{ 8, 8, },
	{ 8, 4, },
	{ 8, 2, },
	{ 8, 1, },
	{ 4, 8, },
	{ 2, 8, },
	{ 1, 8, },
	{ 16, 16, },
	{ 15, 17, },
	{ 24, 24, },
	{ 32, 32, },
	{ 16, 8, },
	{ 16, 4, },
	{ 16, 2, },
	{ 16, 1, },
	{ 8, 16, },
	{ 4, 16, },
	{ 2, 16, },
	{ 1, 16, },
};

static void reset_cache(void)
{
	int n, m;

	for (n = 0; n < sizeof(bitmaps)/sizeof(bitmaps[0]); n++) {
		for (m = 0; m < 2; m++) {
			if (bitmaps[n].cached[m].dpy) {
				XFreePixmap(bitmaps[n].cached[m].dpy, bitmaps[n].cached[m].pixmap);
				bitmaps[n].cached[m].dpy = NULL;
			}
		}
	}
}

static void fill_rect(struct test_target *t, uint8_t alu,
		      XRectangle *clip, int nclip,
		      uint8_t tile, int tx, int ty,
		      int x, int y, int w, int h,
		      uint32_t fg, uint32_t bg)
{
	Display *dpy = t->dpy->dpy;
	struct bitmap *b = &bitmaps[(tile >> 1) % (sizeof(bitmaps)/sizeof(bitmaps[0]))];
	XGCValues val;
	GC gc;
	int n;

	val.function = alu;
	val.function = GXcopy;
	val.fill_style = FillTiled;
	val.ts_x_origin = tx;
	val.ts_y_origin = ty;
	if (tile & 1) {
		val.tile = 0;
		for (n = 0; n < 2; n++) {
			if (b->cached[n].dpy == dpy) {
				val.tile = b->cached[n].pixmap;
				break;
			}
		}
		if (val.tile == 0) {
			val.tile = XCreatePixmapFromBitmapData(dpy, t->draw,
							       (char *)data, b->width, b->height,
							       fg, bg, t->depth);
			for (n = 0; n < 2; n++) {
				if (b->cached[n].dpy == NULL) {
					b->cached[n].dpy = dpy;
					b->cached[n].pixmap = val.tile;
					break;
				}
			}
		}
	} else
		val.tile = XCreatePixmapFromBitmapData(dpy, t->draw,
						       (char *)data, b->width, b->height,
						       fg, bg, t->depth);

	gc = XCreateGC(dpy, t->draw, GCFillStyle | GCTileStipXOrigin | GCTileStipYOrigin | GCTile | GCFunction, &val);
	if (nclip)
		XSetClipRectangles(dpy, gc, 0, 0, clip, nclip, Unsorted);
	XFillRectangle(dpy, t->draw, gc, x, y, w, h);
	XFreeGC(dpy, gc);
	if ((tile & 1) == 0)
		XFreePixmap(dpy, val.tile);
}

static void clear(struct test_target *tt)
{
	XRenderColor render_color = {0};
	XRenderFillRectangle(tt->dpy->dpy, PictOpClear, tt->picture, &render_color,
			     0, 0, tt->width, tt->height);
}

static void small_tests(struct test *t, int reps, int sets, enum target target)
{
	struct test_target out, ref;
	int r, s;

	printf("Testing small tiled fills (%s): ", test_target_name(target));
	fflush(stdout);

	test_target_create_render(&t->out, target, &out);
	clear(&out);

	test_target_create_render(&t->ref, target, &ref);
	clear(&ref);

	for (s = 0; s < sets; s++) {
		for (r = 0; r < reps; r++) {
			int x = rand() % out.width;
			int y = rand() % out.height;
			int w = rand() % out.width;
			int h = rand() % 8;
			int tx = rand() % (2*out.width) - out.width;
			int ty = rand() % (2*out.height) - out.height;
			uint8_t tile = rand();
			uint8_t alu = rand() % (GXset + 1);
			uint32_t fg = rand();
			uint32_t bg = rand();

			fill_rect(&out, alu, NULL, 0,
				  tile, tx, ty,
				  x, y, w, h,
				  fg, bg);
			fill_rect(&ref, alu, NULL, 0,
				  tile, tx, ty,
				  x, y, w, h,
				  fg, bg);

			fill_rect(&out, alu, NULL, 0,
				  tile, tx, ty,
				  x, y, h, w,
				  fg, bg);
			fill_rect(&ref, alu, NULL, 0,
				  tile, tx, ty,
				  x, y, h, w,
				  fg, bg);
		}

		test_compare(t,
			     out.draw, out.format,
			     ref.draw, ref.format,
			     0, 0, out.width, out.height,
			     "");

		if (target == CHILD) {
			int x = rand() % (t->out.width-out.width);
			int y = rand() % (t->out.height-out.height);

			clear(&out);
			clear(&ref);

			XMoveWindow(out.dpy->dpy, out.draw, x, y);
			XMoveWindow(ref.dpy->dpy, ref.draw, x, y);

			clear(&out);
			clear(&ref);
		}
	}

	printf("passed [%d iterations x %d]\n", reps, sets);

	test_target_destroy_render(&t->out, &out);
	test_target_destroy_render(&t->ref, &ref);
}

static void unclipped_tests(struct test *t, int reps, int sets, enum target target)
{
	struct test_target out, ref;
	int r, s;

	printf("Testing unclipped tiled fills (%s): ", test_target_name(target));
	fflush(stdout);

	test_target_create_render(&t->out, target, &out);
	clear(&out);

	test_target_create_render(&t->ref, target, &ref);
	clear(&ref);

	for (s = 0; s < sets; s++) {
		for (r = 0; r < reps; r++) {
			int x = rand() % out.width;
			int y = rand() % out.height;
			int w = rand() % (out.width - x);
			int h = rand() % (out.height - y);
			int tx = rand() % (2*out.width) - out.width;
			int ty = rand() % (2*out.height) - out.height;
			uint8_t tile = rand();
			uint8_t alu = rand() % (GXset + 1);
			uint32_t fg = rand();
			uint32_t bg = rand();

			fill_rect(&out, alu, NULL, 0,
				  tile, tx, ty,
				  x, y, w, h,
				  fg, bg);
			fill_rect(&ref, alu, NULL, 0,
				  tile, tx, ty,
				  x, y, w, h,
				  fg, bg);
		}

		test_compare(t,
			     out.draw, out.format,
			     ref.draw, ref.format,
			     0, 0, out.width, out.height,
			     "");

		if (target == CHILD) {
			int x = rand() % (t->out.width-out.width);
			int y = rand() % (t->out.height-out.height);

			clear(&out);
			clear(&ref);

			XMoveWindow(out.dpy->dpy, out.draw, x, y);
			XMoveWindow(ref.dpy->dpy, ref.draw, x, y);

			clear(&out);
			clear(&ref);
		}
	}

	printf("passed [%d iterations x %d]\n", reps, sets);

	test_target_destroy_render(&t->out, &out);
	test_target_destroy_render(&t->ref, &ref);
}

static void simple_clip_tests(struct test *t, int reps, int sets, enum target target)
{
	struct test_target out, ref;
	int r, s;

	printf("Testing simple clipped tiled fills (%s): ", test_target_name(target));
	fflush(stdout);

	test_target_create_render(&t->out, target, &out);
	clear(&out);

	test_target_create_render(&t->ref, target, &ref);
	clear(&ref);

	for (s = 0; s < sets; s++) {
		for (r = 0; r < reps; r++) {
			int x = rand() % (2*out.width) - out.width;
			int y = rand() % (2*out.height) - out.height;
			int w = rand() % (2*out.width);
			int h = rand() % (2*out.height);
			int tx = rand() % (2*out.width) - out.width;
			int ty = rand() % (2*out.height) - out.height;
			uint8_t tile = rand();
			uint8_t alu = rand() % (GXset + 1);
			uint32_t fg = rand();
			uint32_t bg = rand();

			fill_rect(&out, alu, NULL, 0,
				  tile, tx, ty,
				  x, y, w, h,
				  fg, bg);
			fill_rect(&ref, alu, NULL, 0,
				  tile, tx, ty,
				  x, y, w, h,
				  fg, bg);
		}

		test_compare(t,
			     out.draw, out.format,
			     ref.draw, ref.format,
			     0, 0, out.width, out.height,
			     "");

		if (target == CHILD) {
			int x = rand() % (t->out.width-out.width);
			int y = rand() % (t->out.height-out.height);

			clear(&out);
			clear(&ref);

			XMoveWindow(out.dpy->dpy, out.draw, x, y);
			XMoveWindow(ref.dpy->dpy, ref.draw, x, y);

			clear(&out);
			clear(&ref);
		}
	}

	printf("passed [%d iterations x %d]\n", reps, sets);

	test_target_destroy_render(&t->out, &out);
	test_target_destroy_render(&t->ref, &ref);
}

static void complex_clip_tests(struct test *t, int reps, int sets, enum target target)
{
	struct test_target out, ref;
	XRectangle *clip;
	int nclip, r, s;

	printf("Testing complex clipped tiled fills (%s): ", test_target_name(target));
	fflush(stdout);

	test_target_create_render(&t->out, target, &out);
	clear(&out);

	test_target_create_render(&t->ref, target, &ref);
	clear(&ref);

	for (s = 0; s < sets; s++) {
		nclip = (rand() % 16) + 2;
		clip = malloc(sizeof(XRectangle)*nclip);
		for (r = 0; r < nclip; r++) {
			clip[r].x = rand() % out.width;
			clip[r].y = rand() % out.height;
			clip[r].width = rand() % (out.width - clip[r].x);
			clip[r].height = rand() % (out.height - clip[r].y);
		}

		for (r = 0; r < reps; r++) {
			int x = rand() % (2*out.width) - out.width;
			int y = rand() % (2*out.height) - out.height;
			int w = rand() % (2*out.width);
			int h = rand() % (2*out.height);
			int tx = rand() % (2*out.width) - out.width;
			int ty = rand() % (2*out.height) - out.height;
			uint8_t tile = rand();
			uint8_t alu = rand() % (GXset + 1);
			uint32_t fg = rand();
			uint32_t bg = rand();

			fill_rect(&out, alu, clip, nclip,
				  tile, tx, ty,
				  x, y, w, h,
				  fg, bg);
			fill_rect(&ref, alu, clip, nclip,
				  tile, tx, ty,
				  x, y, w, h,
				  fg, bg);
		}

		test_compare(t,
			     out.draw, out.format,
			     ref.draw, ref.format,
			     0, 0, out.width, out.height,
			     "");

		free(clip);

		if (target == CHILD) {
			int x = rand() % (t->out.width-out.width);
			int y = rand() % (t->out.height-out.height);

			clear(&out);
			clear(&ref);

			XMoveWindow(out.dpy->dpy, out.draw, x, y);
			XMoveWindow(ref.dpy->dpy, ref.draw, x, y);

			clear(&out);
			clear(&ref);
		}
	}

	printf("passed [%d iterations x %d]\n", reps, sets);

	test_target_destroy_render(&t->out, &out);
	test_target_destroy_render(&t->ref, &ref);
}

int main(int argc, char **argv)
{
	struct test test;
	int i;

	test_init(&test, argc, argv);

	for (i = 0; i <= DEFAULT_ITERATIONS; i++) {
		int reps = REPS(i), sets = SETS(i);
		enum target t;

		for (t = TARGET_FIRST; t <= TARGET_LAST; t++) {
			small_tests(&test, reps, sets, t);
			unclipped_tests(&test, reps, sets, t);
			simple_clip_tests(&test, reps, sets, t);
			complex_clip_tests(&test, reps, sets, t);
			reset_cache();
		}
	}

	return 0;
}
@


1.1
log
@Update to xf86-video-intel 2.99.909
Tested by jsg@@, kettenis@@ and myself on a wide range of intel cards.
@
text
@d7 5
a11 2
static unsigned char bitmap4x4[] = {
	   0x03, 0x06, 0x0c, 0x09
d14 32
a45 4
static unsigned char bitmap8x8[3][8] = {
	{ 0xcc, 0x66, 0x33, 0x99, 0xcc, 0x66, 0x33, 0x99 },
	{ 0x00, 0xfe, 0x92, 0x92, 0xfe, 0x92, 0x92, 0xfe },
	{ 0x55, 0xaa, 0x55, 0xaa, 0x55, 0xaa, 0x55, 0xaa },
d48 14
d69 1
d72 1
d75 1
d79 23
a101 6
	if (tile == 0) {
		val.tile = XCreatePixmapFromBitmapData(dpy, t->draw, (char *)bitmap4x4, 4, 4,
						       fg, bg, t->depth);
	} else {
		char *b = (char *)bitmap8x8[tile-1];
		val.tile = XCreatePixmapFromBitmapData(dpy, t->draw, b, 8, 8,
a102 1
	}
d109 2
a110 1
	XFreePixmap(dpy, val.tile);
d120 73
d195 1
a195 1
	struct test_target real, ref;
d201 2
a202 2
	test_target_create_render(&t->real, target, &real);
	clear(&real);
d209 7
a215 7
			int x = rand() % real.width;
			int y = rand() % real.height;
			int w = rand() % (real.width - x);
			int h = rand() % (real.height - y);
			int tx = rand() % (2*real.width) - real.width;
			int ty = rand() % (2*real.height) - real.height;
			uint8_t tile = rand() % 4;
d220 1
a220 1
			fill_rect(&real, alu, NULL, 0,
d231 1
a231 1
			     real.draw, real.format,
d233 1
a233 1
			     0, 0, real.width, real.height,
d235 14
d253 1
a253 1
	test_target_destroy_render(&t->real, &real);
d259 1
a259 1
	struct test_target real, ref;
d265 2
a266 2
	test_target_create_render(&t->real, target, &real);
	clear(&real);
d273 7
a279 7
			int x = rand() % (2*real.width) - real.width;
			int y = rand() % (2*real.height) - real.height;
			int w = rand() % (2*real.width);
			int h = rand() % (2*real.height);
			int tx = rand() % (2*real.width) - real.width;
			int ty = rand() % (2*real.height) - real.height;
			uint8_t tile = rand() % 4;
d284 1
a284 1
			fill_rect(&real, alu, NULL, 0,
d295 1
a295 1
			     real.draw, real.format,
d297 1
a297 1
			     0, 0, real.width, real.height,
d299 14
d317 1
a317 1
	test_target_destroy_render(&t->real, &real);
d323 1
a323 1
	struct test_target real, ref;
d330 2
a331 2
	test_target_create_render(&t->real, target, &real);
	clear(&real);
d340 4
a343 4
			clip[r].x = rand() % real.width;
			clip[r].y = rand() % real.height;
			clip[r].width = rand() % (real.width - clip[r].x);
			clip[r].height = rand() % (real.height - clip[r].y);
d347 7
a353 7
			int x = rand() % (2*real.width) - real.width;
			int y = rand() % (2*real.height) - real.height;
			int w = rand() % (2*real.width);
			int h = rand() % (2*real.height);
			int tx = rand() % (2*real.width) - real.width;
			int ty = rand() % (2*real.height) - real.height;
			uint8_t tile = rand() % 4;
d358 1
a358 1
			fill_rect(&real, alu, clip, nclip,
d369 1
a369 1
			     real.draw, real.format,
d371 1
a371 1
			     0, 0, real.width, real.height,
d375 14
d393 1
a393 1
	test_target_destroy_render(&t->real, &real);
d409 1
d413 1
@

