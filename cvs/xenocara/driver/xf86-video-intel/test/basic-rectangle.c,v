head	1.3;
access;
symbols
	OPENBSD_6_0:1.3.0.6
	OPENBSD_6_0_BASE:1.3
	OPENBSD_5_9:1.3.0.4
	OPENBSD_5_9_BASE:1.3
	OPENBSD_5_8:1.3.0.2
	OPENBSD_5_8_BASE:1.3
	OPENBSD_5_7:1.2.0.6
	OPENBSD_5_7_BASE:1.2
	OPENBSD_5_6:1.2.0.4
	OPENBSD_5_6_BASE:1.2
	OPENBSD_5_5:1.2.0.2
	OPENBSD_5_5_BASE:1.2
	OPENBSD_5_4:1.1.0.2
	OPENBSD_5_4_BASE:1.1;
locks; strict;
comment	@ * @;


1.3
date	2015.04.12.19.42.07;	author matthieu;	state Exp;
branches;
next	1.2;
commitid	DK857Z2Au1JEohAk;

1.2
date	2014.02.03.15.54.54;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2013.03.18.18.38.21;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.3
log
@Update to xf86-video-intel 2.99.916
Fixes a display bug seenby ajacoutot@@, ok jsg@@ and kettenis@@.
newer X.Org (2.99.917 or master) version cause corruption on older
machines (X40, i965), probably caused by a bug in our kernel,
under investigation by kettenis@@.
@
text
@#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>

#include <X11/Xutil.h> /* for XDestroyImage */

#include "test.h"

static void draw_rect(struct test_display *t, Drawable d, uint8_t alu,
		      int x, int y, int w, int h, uint32_t fg, int lw)
{
	XGCValues val;
	GC gc;

	val.function = alu;
	val.foreground = fg;
	val.line_width = lw;

	gc = XCreateGC(t->dpy, d, GCForeground | GCFunction | GCLineWidth, &val);
	XDrawRectangle(t->dpy, d, gc, x, y, w, h);
	XFreeGC(t->dpy, gc);
}

static void clear(struct test_display *dpy, struct test_target *tt)
{
	XRenderColor render_color = {0};
	XRenderFillRectangle(dpy->dpy, PictOpClear, tt->picture, &render_color,
			     0, 0, tt->width, tt->height);
}

static void zrect_tests(struct test *t, int reps, int sets, enum target target)
{
	struct test_target out, ref;
	int r, s;

	printf("Testing empty rects (%s): ", test_target_name(target));
	fflush(stdout);

	test_target_create_render(&t->out, target, &out);
	clear(&t->out, &out);

	test_target_create_render(&t->ref, target, &ref);
	clear(&t->ref, &ref);

	for (s = 0; s < sets; s++) {
		for (r = 0; r < reps; r++) {
			int x = rand() % (2*out.width) - out.width;
			int y = rand() % (2*out.height) - out.height;
			uint8_t alu = rand() % (GXset + 1);
			uint32_t fg = rand();
			uint32_t lw = rand() % 4;

			draw_rect(&t->out, out.draw, alu,
				  x, y, 0, 0, fg, lw);
			draw_rect(&t->ref, ref.draw, alu,
				  x, y, 0, 0, fg, lw);
		}

		test_compare(t,
			     out.draw, out.format,
			     ref.draw, ref.format,
			     0, 0, out.width, out.height,
			     "");
	}

	printf("passed [%d iterations x %d]\n", reps, sets);

	test_target_destroy_render(&t->out, &out);
	test_target_destroy_render(&t->ref, &ref);
}

static void hrect_tests(struct test *t, int reps, int sets, enum target target)
{
	struct test_target out, ref;
	int r, s;

	printf("Testing horizontal rects (%s): ", test_target_name(target));
	fflush(stdout);

	test_target_create_render(&t->out, target, &out);
	clear(&t->out, &out);

	test_target_create_render(&t->ref, target, &ref);
	clear(&t->ref, &ref);

	for (s = 0; s < sets; s++) {
		for (r = 0; r < reps; r++) {
			int x = rand() % (2*out.width) - out.width;
			int y = rand() % (2*out.height) - out.height;
			int w = rand() % (2*out.width);
			uint8_t alu = rand() % (GXset + 1);
			uint32_t fg = rand();
			uint32_t lw = rand() % 4;

			draw_rect(&t->out, out.draw, alu,
				  x, y, w, 0, fg, lw);
			draw_rect(&t->ref, ref.draw, alu,
				  x, y, w, 0, fg, lw);
		}

		test_compare(t,
			     out.draw, out.format,
			     ref.draw, ref.format,
			     0, 0, out.width, out.height,
			     "");
	}

	printf("passed [%d iterations x %d]\n", reps, sets);

	test_target_destroy_render(&t->out, &out);
	test_target_destroy_render(&t->ref, &ref);
}

static void vrect_tests(struct test *t, int reps, int sets, enum target target)
{
	struct test_target out, ref;
	int r, s;

	printf("Testing vertical rects (%s): ", test_target_name(target));
	fflush(stdout);

	test_target_create_render(&t->out, target, &out);
	clear(&t->out, &out);

	test_target_create_render(&t->ref, target, &ref);
	clear(&t->ref, &ref);

	for (s = 0; s < sets; s++) {
		for (r = 0; r < reps; r++) {
			int x = rand() % (2*out.width) - out.width;
			int y = rand() % (2*out.height) - out.height;
			int h = rand() % (2*out.width);
			uint8_t alu = rand() % (GXset + 1);
			uint32_t fg = rand();
			uint32_t lw = rand() % 4;

			draw_rect(&t->out, out.draw, alu,
				  x, y, 0, h, fg, lw);
			draw_rect(&t->ref, ref.draw, alu,
				  x, y, 0, h, fg, lw);
		}

		test_compare(t,
			     out.draw, out.format,
			     ref.draw, ref.format,
			     0, 0, out.width, out.height,
			     "");
	}

	printf("passed [%d iterations x %d]\n", reps, sets);

	test_target_destroy_render(&t->out, &out);
	test_target_destroy_render(&t->ref, &ref);
}

static void rect_tests(struct test *t, int reps, int sets, enum target target)
{
	struct test_target out, ref;
	int r, s;

	printf("Testing general (%s): ", test_target_name(target));
	fflush(stdout);

	test_target_create_render(&t->out, target, &out);
	clear(&t->out, &out);

	test_target_create_render(&t->ref, target, &ref);
	clear(&t->ref, &ref);

	for (s = 0; s < sets; s++) {
		for (r = 0; r < reps; r++) {
			int x = rand() % (2*out.width) - out.width;
			int y = rand() % (2*out.height) - out.height;
			int w = rand() % (2*out.width);
			int h = rand() % (2*out.height);
			uint8_t alu = rand() % (GXset + 1);
			uint32_t fg = rand();
			uint32_t lw = rand() % 4;

			draw_rect(&t->out, out.draw, alu,
				  x, y, w, h, fg, lw);
			draw_rect(&t->ref, ref.draw, alu,
				  x, y, w, h, fg, lw);
		}

		test_compare(t,
			     out.draw, out.format,
			     ref.draw, ref.format,
			     0, 0, out.width, out.height,
			     "");
	}

	printf("passed [%d iterations x %d]\n", reps, sets);

	test_target_destroy_render(&t->out, &out);
	test_target_destroy_render(&t->ref, &ref);
}

int main(int argc, char **argv)
{
	struct test test;
	int i;

	test_init(&test, argc, argv);

	for (i = 0; i <= DEFAULT_ITERATIONS; i++) {
		int reps = REPS(i), sets = SETS(i);
		enum target t;

		for (t = TARGET_FIRST; t <= TARGET_LAST; t++) {
			zrect_tests(&test, reps, sets, t);
			hrect_tests(&test, reps, sets, t);
			vrect_tests(&test, reps, sets, t);
			rect_tests(&test, reps, sets, t);
		}
	}

	return 0;
}
@


1.2
log
@Update to xf86-video-intel 2.99.909
Tested by jsg@@, kettenis@@ and myself on a wide range of intel cards.
@
text
@d33 1
a33 1
	struct test_target real, ref;
d39 2
a40 2
	test_target_create_render(&t->real, target, &real);
	clear(&t->real, &real);
d47 2
a48 2
			int x = rand() % (2*real.width) - real.width;
			int y = rand() % (2*real.height) - real.height;
d53 1
a53 1
			draw_rect(&t->real, real.draw, alu,
d60 1
a60 1
			     real.draw, real.format,
d62 1
a62 1
			     0, 0, real.width, real.height,
d68 1
a68 1
	test_target_destroy_render(&t->real, &real);
d74 1
a74 1
	struct test_target real, ref;
d80 2
a81 2
	test_target_create_render(&t->real, target, &real);
	clear(&t->real, &real);
d88 3
a90 3
			int x = rand() % (2*real.width) - real.width;
			int y = rand() % (2*real.height) - real.height;
			int w = rand() % (2*real.width);
d95 1
a95 1
			draw_rect(&t->real, real.draw, alu,
d102 1
a102 1
			     real.draw, real.format,
d104 1
a104 1
			     0, 0, real.width, real.height,
d110 1
a110 1
	test_target_destroy_render(&t->real, &real);
d116 1
a116 1
	struct test_target real, ref;
d122 2
a123 2
	test_target_create_render(&t->real, target, &real);
	clear(&t->real, &real);
d130 3
a132 3
			int x = rand() % (2*real.width) - real.width;
			int y = rand() % (2*real.height) - real.height;
			int h = rand() % (2*real.width);
d137 1
a137 1
			draw_rect(&t->real, real.draw, alu,
d144 1
a144 1
			     real.draw, real.format,
d146 1
a146 1
			     0, 0, real.width, real.height,
d152 1
a152 1
	test_target_destroy_render(&t->real, &real);
d158 1
a158 1
	struct test_target real, ref;
d164 2
a165 2
	test_target_create_render(&t->real, target, &real);
	clear(&t->real, &real);
d172 4
a175 4
			int x = rand() % (2*real.width) - real.width;
			int y = rand() % (2*real.height) - real.height;
			int w = rand() % (2*real.width);
			int h = rand() % (2*real.height);
d180 1
a180 1
			draw_rect(&t->real, real.draw, alu,
d187 1
a187 1
			     real.draw, real.format,
d189 1
a189 1
			     0, 0, real.width, real.height,
d195 1
a195 1
	test_target_destroy_render(&t->real, &real);
@


1.1
log
@Update to xf86-video-intel 2.20.19.

A recent kernel with kernel modesetting support is required.
Thanks to jsg@@ and kettenis@@ for their work.
@
text
@d207 1
a207 2
		int reps = 1 << i;
		int sets = 1 << (12 - i);
a208 3

		if (sets < 2)
			sets = 2;
@

