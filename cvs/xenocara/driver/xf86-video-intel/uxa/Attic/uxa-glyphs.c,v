head	1.6;
access;
symbols
	OPENBSD_5_4:1.5.0.2
	OPENBSD_5_4_BASE:1.5
	OPENBSD_5_3:1.4.0.6
	OPENBSD_5_3_BASE:1.4
	OPENBSD_5_2:1.4.0.4
	OPENBSD_5_2_BASE:1.4
	OPENBSD_5_1_BASE:1.4
	OPENBSD_5_1:1.4.0.2
	OPENBSD_5_0:1.3.0.6
	OPENBSD_5_0_BASE:1.3
	OPENBSD_4_9:1.3.0.2
	OPENBSD_4_9_BASE:1.3
	OPENBSD_4_8:1.3.0.4
	OPENBSD_4_8_BASE:1.3
	OPENBSD_4_7:1.1.0.4
	OPENBSD_4_7_BASE:1.1
	OPENBSD_4_6:1.1.0.2
	OPENBSD_4_6_BASE:1.1;
locks; strict;
comment	@ * @;


1.6
date	2014.02.03.15.54.54;	author matthieu;	state dead;
branches;
next	1.5;

1.5
date	2013.03.18.18.38.22;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2011.11.29.12.39.03;	author oga;	state Exp;
branches;
next	1.3;

1.3
date	2010.07.18.14.47.48;	author oga;	state Exp;
branches;
next	1.2;

1.2
date	2010.05.10.22.32.30;	author oga;	state Exp;
branches;
next	1.1;

1.1
date	2009.06.25.20.16.44;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.6
log
@Update to xf86-video-intel 2.99.909
Tested by jsg@@, kettenis@@ and myself on a wide range of intel cards.
@
text
@/*
 * Copyright © 2010 Intel Corporation
 * Partly based on code Copyright © 2008 Red Hat, Inc.
 * Partly based on code Copyright © 2000 SuSE, Inc.
 *
 * Permission to use, copy, modify, distribute, and sell this software and its
 * documentation for any purpose is hereby granted without fee, provided that
 * the above copyright notice appear in all copies and that both that
 * copyright notice and this permission notice appear in supporting
 * documentation, and that the name of Intel not be used in advertising or
 * publicity pertaining to distribution of the software without specific,
 * written prior permission.  Intel makes no representations about the
 * suitability of this software for any purpose.  It is provided "as is"
 * without express or implied warranty.
 *
 * INTEL DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING ALL
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL INTEL
 * BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
 * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
 * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 *
 * Permission to use, copy, modify, distribute, and sell this software and its
 * documentation for any purpose is hereby granted without fee, provided that
 * the above copyright notice appear in all copies and that both that
 * copyright notice and this permission notice appear in supporting
 * documentation, and that the name of Red Hat not be used in advertising or
 * publicity pertaining to distribution of the software without specific,
 * written prior permission.  Red Hat makes no representations about the
 * suitability of this software for any purpose.  It is provided "as is"
 * without express or implied warranty.
 *
 * Red Hat DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING ALL
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL Red Hat
 * BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
 * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
 * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 *
 * Permission to use, copy, modify, distribute, and sell this software and its
 * documentation for any purpose is hereby granted without fee, provided that
 * the above copyright notice appear in all copies and that both that
 * copyright notice and this permission notice appear in supporting
 * documentation, and that the name of SuSE not be used in advertising or
 * publicity pertaining to distribution of the software without specific,
 * written prior permission.  SuSE makes no representations about the
 * suitability of this software for any purpose.  It is provided "as is"
 * without express or implied warranty.
 *
 * SuSE DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING ALL
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL SuSE
 * BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
 * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
 * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 *
 * Author: Chris Wilson <chris@@chris-wilson.co.uk>
 * Based on code by: Keith Packard <keithp@@keithp.com> and Owen Taylor <otaylor@@fishsoup.net>
 */

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#include <stdlib.h>

#include "uxa-priv.h"
#include "uxa-glamor.h"
#include "../src/common.h"

#include "mipict.h"

/* Width of the pixmaps we use for the caches; this should be less than
 * max texture size of the driver; this may need to actually come from
 * the driver.
 */
#define CACHE_PICTURE_SIZE 1024
#define GLYPH_MIN_SIZE 8
#define GLYPH_MAX_SIZE 64
#define GLYPH_CACHE_SIZE (CACHE_PICTURE_SIZE * CACHE_PICTURE_SIZE / (GLYPH_MIN_SIZE * GLYPH_MIN_SIZE))

struct uxa_glyph {
	uxa_glyph_cache_t *cache;
	uint16_t x, y;
	uint16_t size, pos;
};

#if HAS_DEVPRIVATEKEYREC
static DevPrivateKeyRec uxa_glyph_key;
#else
static int uxa_glyph_key;
#endif

static inline struct uxa_glyph *uxa_glyph_get_private(GlyphPtr glyph)
{
#if HAS_DEVPRIVATEKEYREC
	return dixGetPrivate(&glyph->devPrivates, &uxa_glyph_key);
#else
	return dixLookupPrivate(&glyph->devPrivates, &uxa_glyph_key);
#endif
}

static inline void uxa_glyph_set_private(GlyphPtr glyph, struct uxa_glyph *priv)
{
	dixSetPrivate(&glyph->devPrivates, &uxa_glyph_key, priv);
}

#define NeedsComponent(f) (PICT_FORMAT_A(f) != 0 && PICT_FORMAT_RGB(f) != 0)

static void uxa_unrealize_glyph_caches(ScreenPtr pScreen)
{
	uxa_screen_t *uxa_screen = uxa_get_screen(pScreen);
	int i;

	if (!uxa_screen->glyph_cache_initialized)
		return;

	for (i = 0; i < UXA_NUM_GLYPH_CACHE_FORMATS; i++) {
		uxa_glyph_cache_t *cache = &uxa_screen->glyphCaches[i];

		if (cache->picture)
			FreePicture(cache->picture, 0);

		if (cache->glyphs)
			free(cache->glyphs);
	}
	uxa_screen->glyph_cache_initialized = FALSE;
}

void uxa_glyphs_fini(ScreenPtr pScreen)
{
	uxa_unrealize_glyph_caches(pScreen);
}

/* All caches for a single format share a single pixmap for glyph storage,
 * allowing mixing glyphs of different sizes without paying a penalty
 * for switching between source pixmaps. (Note that for a size of font
 * right at the border between two sizes, we might be switching for almost
 * every glyph.)
 *
 * This function allocates the storage pixmap, and then fills in the
 * rest of the allocated structures for all caches with the given format.
 */
static Bool uxa_realize_glyph_caches(ScreenPtr pScreen)
{
	uxa_screen_t *uxa_screen = uxa_get_screen(pScreen);
	unsigned int formats[] = {
		PIXMAN_a8,
		PIXMAN_a8r8g8b8,
	};
	int i;

	if (uxa_screen->glyph_cache_initialized)
		return TRUE;

	uxa_screen->glyph_cache_initialized = TRUE;
	memset(uxa_screen->glyphCaches, 0, sizeof(uxa_screen->glyphCaches));

	for (i = 0; i < sizeof(formats)/sizeof(formats[0]); i++) {
		uxa_glyph_cache_t *cache = &uxa_screen->glyphCaches[i];
		PixmapPtr pixmap;
		PicturePtr picture;
		CARD32 component_alpha;
		int depth = PIXMAN_FORMAT_DEPTH(formats[i]);
		int error;
		PictFormatPtr pPictFormat = PictureMatchFormat(pScreen, depth, formats[i]);
		if (!pPictFormat)
			goto bail;

		/* Now allocate the pixmap and picture */
		pixmap = pScreen->CreatePixmap(pScreen,
					       CACHE_PICTURE_SIZE, CACHE_PICTURE_SIZE, depth,
					       INTEL_CREATE_PIXMAP_TILING_X);
		if (!pixmap)
			goto bail;
		if (!uxa_pixmap_is_offscreen(pixmap)) {
			/* Presume shadow is in-effect */
			pScreen->DestroyPixmap(pixmap);
			uxa_unrealize_glyph_caches(pScreen);
			return TRUE;
		}

		component_alpha = NeedsComponent(pPictFormat->format);
		picture = CreatePicture(0, &pixmap->drawable, pPictFormat,
					CPComponentAlpha, &component_alpha,
					serverClient, &error);

		pScreen->DestroyPixmap(pixmap);

		if (!picture)
			goto bail;

		ValidatePicture(picture);

		cache->picture = picture;
		cache->glyphs = calloc(sizeof(GlyphPtr), GLYPH_CACHE_SIZE);
		if (!cache->glyphs)
			goto bail;

		cache->evict = rand() % GLYPH_CACHE_SIZE;
	}
	assert(i == UXA_NUM_GLYPH_CACHE_FORMATS);

	return TRUE;

bail:
	uxa_unrealize_glyph_caches(pScreen);
	return FALSE;
}


Bool uxa_glyphs_init(ScreenPtr pScreen)
{

	uxa_screen_t *uxa_screen = uxa_get_screen(pScreen);

	if (uxa_screen->info->flags & UXA_USE_GLAMOR)
		return TRUE;
#if HAS_DIXREGISTERPRIVATEKEY
	if (!dixRegisterPrivateKey(&uxa_glyph_key, PRIVATE_GLYPH, 0))
		return FALSE;
#else
	if (!dixRequestPrivate(&uxa_glyph_key, 0))
		return FALSE;
#endif

	/* Skip pixmap creation if we don't intend to use it. */
	if (uxa_get_screen(pScreen)->force_fallback)
		return TRUE;

	return uxa_realize_glyph_caches(pScreen);
}

/* The most efficient thing to way to upload the glyph to the screen
 * is to use CopyArea; uxa pixmaps are always offscreen.
 */
static void
uxa_glyph_cache_upload_glyph(ScreenPtr screen,
			     uxa_glyph_cache_t * cache,
			     GlyphPtr glyph,
			     int x, int y)
{
	PicturePtr pGlyphPicture = GetGlyphPicture(glyph, screen);
	PixmapPtr pGlyphPixmap = (PixmapPtr) pGlyphPicture->pDrawable;
	PixmapPtr pCachePixmap = (PixmapPtr) cache->picture->pDrawable;
	PixmapPtr scratch;
	GCPtr gc;

	gc = GetScratchGC(pCachePixmap->drawable.depth, screen);
	if (!gc)
		return;

	ValidateGC(&pCachePixmap->drawable, gc);

	scratch = pGlyphPixmap;
	/* Create a temporary bo to stream the updates to the cache */
	if (pGlyphPixmap->drawable.depth != pCachePixmap->drawable.depth ||
	    !uxa_pixmap_is_offscreen(scratch)) {
		scratch = screen->CreatePixmap(screen,
					       glyph->info.width,
					       glyph->info.height,
					       pCachePixmap->drawable.depth,
					       UXA_CREATE_PIXMAP_FOR_MAP);
		if (scratch) {
			if (pGlyphPixmap->drawable.depth != pCachePixmap->drawable.depth) {
				PicturePtr picture;
				int error;

				picture = CreatePicture(0, &scratch->drawable,
							PictureMatchFormat(screen,
									   pCachePixmap->drawable.depth,
									   cache->picture->format),
							0, NULL,
							serverClient, &error);
				if (picture) {
					ValidatePicture(picture);
					uxa_composite(PictOpSrc, pGlyphPicture, NULL, picture,
						      0, 0,
						      0, 0,
						      0, 0,
						      glyph->info.width, glyph->info.height);
					FreePicture(picture, 0);
				}
			} else {
				uxa_copy_area(&pGlyphPixmap->drawable,
					      &scratch->drawable,
					      gc,
					      0, 0,
					      glyph->info.width, glyph->info.height,
					      0, 0);
			}
		} else {
			scratch = pGlyphPixmap;
		}
	}

	uxa_copy_area(&scratch->drawable, &pCachePixmap->drawable, gc,
		      0, 0,
		      glyph->info.width, glyph->info.height,
		      x, y);

	if (scratch != pGlyphPixmap)
		screen->DestroyPixmap(scratch);

	FreeScratchGC(gc);
}

void
uxa_glyph_unrealize(ScreenPtr screen,
		    GlyphPtr glyph)
{
	struct uxa_glyph *priv;
	uxa_screen_t *uxa_screen = uxa_get_screen(screen);

	if (uxa_screen->info->flags & UXA_USE_GLAMOR) {
		glamor_glyph_unrealize(screen, glyph);
		return;
	}

	/* Use Lookup in case we have not attached to this glyph. */
	priv = dixLookupPrivate(&glyph->devPrivates, &uxa_glyph_key);
	if (priv == NULL)
		return;

	priv->cache->glyphs[priv->pos] = NULL;

	uxa_glyph_set_private(glyph, NULL);
	free(priv);
}

/* Cut and paste from render/glyph.c - probably should export it instead */
static void
uxa_glyph_extents(int nlist,
		  GlyphListPtr list, GlyphPtr * glyphs, BoxPtr extents)
{
	int x1, x2, y1, y2;
	int x, y, n;

	x1 = y1 = MAXSHORT;
	x2 = y2 = MINSHORT;
	x = y = 0;
	while (nlist--) {
		x += list->xOff;
		y += list->yOff;
		n = list->len;
		list++;
		while (n--) {
			GlyphPtr glyph = *glyphs++;
			int v;

			v = x - glyph->info.x;
			if (v < x1)
			    x1 = v;
			v += glyph->info.width;
			if (v > x2)
			    x2 = v;

			v = y - glyph->info.y;
			if (v < y1)
			    y1 = v;
			v += glyph->info.height;
			if (v > y2)
			    y2 = v;

			x += glyph->info.xOff;
			y += glyph->info.yOff;
		}
	}

	extents->x1 = x1 < MINSHORT ? MINSHORT : x1;
	extents->x2 = x2 > MAXSHORT ? MAXSHORT : x2;
	extents->y1 = y1 < MINSHORT ? MINSHORT : y1;
	extents->y2 = y2 > MAXSHORT ? MAXSHORT : y2;
}

/**
 * Returns TRUE if the glyphs in the lists intersect.  Only checks based on
 * bounding box, which appears to be good enough to catch most cases at least.
 */
static Bool
uxa_glyphs_intersect(int nlist, GlyphListPtr list, GlyphPtr * glyphs)
{
	int x1, x2, y1, y2;
	int n;
	int x, y;
	BoxRec extents;
	Bool first = TRUE;

	x = 0;
	y = 0;
	extents.x1 = 0;
	extents.y1 = 0;
	extents.x2 = 0;
	extents.y2 = 0;
	while (nlist--) {
		x += list->xOff;
		y += list->yOff;
		n = list->len;
		list++;
		while (n--) {
			GlyphPtr glyph = *glyphs++;

			if (glyph->info.width == 0 || glyph->info.height == 0) {
				x += glyph->info.xOff;
				y += glyph->info.yOff;
				continue;
			}

			x1 = x - glyph->info.x;
			if (x1 < MINSHORT)
				x1 = MINSHORT;
			y1 = y - glyph->info.y;
			if (y1 < MINSHORT)
				y1 = MINSHORT;
			x2 = x1 + glyph->info.width;
			if (x2 > MAXSHORT)
				x2 = MAXSHORT;
			y2 = y1 + glyph->info.height;
			if (y2 > MAXSHORT)
				y2 = MAXSHORT;

			if (first) {
				extents.x1 = x1;
				extents.y1 = y1;
				extents.x2 = x2;
				extents.y2 = y2;
				first = FALSE;
			} else {
				if (x1 < extents.x2 && x2 > extents.x1 &&
				    y1 < extents.y2 && y2 > extents.y1) {
					return TRUE;
				}

				if (x1 < extents.x1)
					extents.x1 = x1;
				if (x2 > extents.x2)
					extents.x2 = x2;
				if (y1 < extents.y1)
					extents.y1 = y1;
				if (y2 > extents.y2)
					extents.y2 = y2;
			}
			x += glyph->info.xOff;
			y += glyph->info.yOff;
		}
	}

	return FALSE;
}

static void
uxa_check_glyphs(CARD8 op,
		 PicturePtr src,
		 PicturePtr dst,
		 PictFormatPtr maskFormat,
		 INT16 xSrc,
		 INT16 ySrc, int nlist, GlyphListPtr list, GlyphPtr * glyphs)
{
	pixman_image_t *image;
	PixmapPtr scratch;
	PicturePtr mask, mask_src = NULL, mask_dst = NULL, white = NULL;
	int width = 0, height = 0;
	int x, y, n;
	int xDst = list->xOff, yDst = list->yOff;
	BoxRec extents = { 0, 0, 0, 0 };
	CARD8 mask_op = 0;

	if (maskFormat) {
		pixman_format_code_t format;
		CARD32 component_alpha;
		xRenderColor color;
		int error;

		uxa_glyph_extents(nlist, list, glyphs, &extents);
		if (extents.x2 <= extents.x1 || extents.y2 <= extents.y1)
			return;

		width = extents.x2 - extents.x1;
		height = extents.y2 - extents.y1;

		format = maskFormat->format |
			(BitsPerPixel(maskFormat->depth) << 24);
		image =
			pixman_image_create_bits(format, width, height, NULL, 0);
		if (!image)
			return;

		scratch = GetScratchPixmapHeader(dst->pDrawable->pScreen, width, height,
						 PIXMAN_FORMAT_DEPTH(format),
						 PIXMAN_FORMAT_BPP(format),
						 pixman_image_get_stride(image),
						 pixman_image_get_data(image));

		if (!scratch) {
			pixman_image_unref(image);
			return;
		}

		component_alpha = NeedsComponent(maskFormat->format);
		mask = CreatePicture(0, &scratch->drawable,
				     maskFormat, CPComponentAlpha,
				     &component_alpha, serverClient, &error);
		if (!mask) {
			FreeScratchPixmapHeader(scratch);
			pixman_image_unref(image);
			return;
		}
		ValidatePicture(mask);

		x = -extents.x1;
		y = -extents.y1;

		color.red = color.green = color.blue = color.alpha = 0xffff;
		white = CreateSolidPicture(0, &color, &error);

		mask_op = op;
		op = PictOpAdd;

		mask_src = src;
		src = white;

		mask_dst = dst;
		dst = mask;
	} else {
		mask = dst;
		x = 0;
		y = 0;
	}

	while (nlist--) {
		x += list->xOff;
		y += list->yOff;
		n = list->len;
		while (n--) {
			GlyphPtr glyph = *glyphs++;
			PicturePtr g = GetGlyphPicture(glyph, dst->pDrawable->pScreen);
			if (g) {
				CompositePicture(op, src, g, dst,
						 xSrc + (x - glyph->info.x) - xDst,
						 ySrc + (y - glyph->info.y) - yDst,
						 0, 0,
						 x - glyph->info.x,
						 y - glyph->info.y,
						 glyph->info.width,
						 glyph->info.height);
			}

			x += glyph->info.xOff;
			y += glyph->info.yOff;
		}
		list++;
	}

	if (white)
		FreePicture(white, 0);

	if (maskFormat) {
		x = extents.x1;
		y = extents.y1;
		CompositePicture(mask_op, mask_src, mask, mask_dst,
				 xSrc + x - xDst,
				 ySrc + y - yDst,
				 0, 0,
				 x, y,
				 width, height);
		FreePicture(mask, 0);
		FreeScratchPixmapHeader(scratch);
		pixman_image_unref(image);
	}
}

static inline unsigned int
uxa_glyph_size_to_count(int size)
{
	size /= GLYPH_MIN_SIZE;
	return size * size;
}

static inline unsigned int
uxa_glyph_count_to_mask(int count)
{
	return ~(count - 1);
}

static inline unsigned int
uxa_glyph_size_to_mask(int size)
{
	return uxa_glyph_count_to_mask(uxa_glyph_size_to_count(size));
}

static PicturePtr
uxa_glyph_cache(ScreenPtr screen, GlyphPtr glyph, int *out_x, int *out_y)
{
	uxa_screen_t *uxa_screen = uxa_get_screen(screen);
	PicturePtr glyph_picture = GetGlyphPicture(glyph, screen);
	uxa_glyph_cache_t *cache = &uxa_screen->glyphCaches[PICT_FORMAT_RGB(glyph_picture->format) != 0];
	struct uxa_glyph *priv = NULL;
	int size, mask, pos, s;

	if (glyph->info.width > GLYPH_MAX_SIZE || glyph->info.height > GLYPH_MAX_SIZE)
		return NULL;

	for (size = GLYPH_MIN_SIZE; size <= GLYPH_MAX_SIZE; size *= 2)
		if (glyph->info.width <= size && glyph->info.height <= size)
			break;

	s = uxa_glyph_size_to_count(size);
	mask = uxa_glyph_count_to_mask(s);
	pos = (cache->count + s - 1) & mask;
	if (pos < GLYPH_CACHE_SIZE) {
		cache->count = pos + s;
	} else {
		for (s = size; s <= GLYPH_MAX_SIZE; s *= 2) {
			int i = cache->evict & uxa_glyph_size_to_mask(s);
			GlyphPtr evicted = cache->glyphs[i];
			if (evicted == NULL)
				continue;

			priv = uxa_glyph_get_private(evicted);
			if (priv->size >= s) {
				cache->glyphs[i] = NULL;
				uxa_glyph_set_private(evicted, NULL);
				pos = cache->evict & uxa_glyph_size_to_mask(size);
			} else
				priv = NULL;
			break;
		}
		if (priv == NULL) {
			int count = uxa_glyph_size_to_count(size);
			mask = uxa_glyph_count_to_mask(count);
			pos = cache->evict & mask;
			for (s = 0; s < count; s++) {
				GlyphPtr evicted = cache->glyphs[pos + s];
				if (evicted != NULL) {
					if (priv != NULL)
						free(priv);

					priv = uxa_glyph_get_private(evicted);
					uxa_glyph_set_private(evicted, NULL);
					cache->glyphs[pos + s] = NULL;
				}
			}
		}

		/* And pick a new eviction position */
		cache->evict = rand() % GLYPH_CACHE_SIZE;
	}

	if (priv == NULL) {
		priv = malloc(sizeof(struct uxa_glyph));
		if (priv == NULL)
			return NULL;
	}

	uxa_glyph_set_private(glyph, priv);
	cache->glyphs[pos] = glyph;

	priv->cache = cache;
	priv->size = size;
	priv->pos = pos;
	s = pos / ((GLYPH_MAX_SIZE / GLYPH_MIN_SIZE) * (GLYPH_MAX_SIZE / GLYPH_MIN_SIZE));
	priv->x = s % (CACHE_PICTURE_SIZE / GLYPH_MAX_SIZE) * GLYPH_MAX_SIZE;
	priv->y = (s / (CACHE_PICTURE_SIZE / GLYPH_MAX_SIZE)) * GLYPH_MAX_SIZE;
	for (s = GLYPH_MIN_SIZE; s < GLYPH_MAX_SIZE; s *= 2) {
		if (pos & 1)
			priv->x += s;
		if (pos & 2)
			priv->y += s;
		pos >>= 2;
	}

	uxa_glyph_cache_upload_glyph(screen, cache, glyph, priv->x, priv->y);

	*out_x = priv->x;
	*out_y = priv->y;
	return cache->picture;
}

static void
uxa_clear_pixmap(ScreenPtr screen,
		 uxa_screen_t *uxa_screen,
		 PixmapPtr pixmap)
{
	if (uxa_screen->info->check_solid &&
	    !uxa_screen->info->check_solid(&pixmap->drawable, GXcopy, FB_ALLONES))
		goto fallback;

	if (!uxa_screen->info->prepare_solid(pixmap, GXcopy, FB_ALLONES, 0))
		goto fallback;

	uxa_screen->info->solid(pixmap,
				0, 0,
				pixmap->drawable.width,
				pixmap->drawable.height);

	uxa_screen->info->done_solid(pixmap);
	return;

fallback:
	{
		GCPtr gc;

		gc = GetScratchGC(pixmap->drawable.depth, screen);
		if (gc) {
			xRectangle rect;

			ValidateGC(&pixmap->drawable, gc);

			rect.x = 0;
			rect.y = 0;
			rect.width  = pixmap->drawable.width;
			rect.height = pixmap->drawable.height;
			gc->ops->PolyFillRect(&pixmap->drawable, gc, 1, &rect);

			FreeScratchGC(gc);
		}
	}
}

static PicturePtr
create_white_solid(ScreenPtr screen)
{
	PicturePtr white, ret = NULL;
	xRenderColor color;
	int error;

	color.red = color.green = color.blue = color.alpha = 0xffff;
	white = CreateSolidPicture(0, &color, &error);
	if (white) {
		ret = uxa_acquire_solid(screen, white->pSourcePict);
		FreePicture(white, 0);
	}

	return ret;
}

static int
uxa_glyphs_via_mask(CARD8 op,
		    PicturePtr pSrc,
		    PicturePtr pDst,
		    PictFormatPtr maskFormat,
		    INT16 xSrc, INT16 ySrc,
		    int nlist, GlyphListPtr list, GlyphPtr * glyphs)
{
	ScreenPtr screen = pDst->pDrawable->pScreen;
	uxa_screen_t *uxa_screen = uxa_get_screen(screen);
	CARD32 component_alpha;
	PixmapPtr pixmap, white_pixmap;
	PicturePtr glyph_atlas, mask, white;
	int xDst = list->xOff, yDst = list->yOff;
	int x, y, width, height;
	int dst_off_x, dst_off_y;
	int n, error;
	BoxRec box;

	uxa_glyph_extents(nlist, list, glyphs, &box);
	if (box.x2 <= box.x1 || box.y2 <= box.y1)
		return 0;

	dst_off_x = box.x1;
	dst_off_y = box.y1;

	width  = box.x2 - box.x1;
	height = box.y2 - box.y1;
	x = -box.x1;
	y = -box.y1;

	if (maskFormat->depth == 1) {
		PictFormatPtr a8Format =
			PictureMatchFormat(screen, 8, PICT_a8);

		if (!a8Format)
			return -1;

		maskFormat = a8Format;
	}

	pixmap = screen->CreatePixmap(screen, width, height,
				      maskFormat->depth,
				      CREATE_PIXMAP_USAGE_SCRATCH);
	if (!pixmap)
		return 1;

	if (!uxa_pixmap_is_offscreen(pixmap)) {
		screen->DestroyPixmap(pixmap);
		return -1;
	}

	white_pixmap = NULL;
	white = create_white_solid(screen);
	if (white)
		white_pixmap = uxa_get_drawable_pixmap(white->pDrawable);
	if (!white_pixmap) {
		if (white)
			FreePicture(white, 0);
		screen->DestroyPixmap(pixmap);
		return -1;
	}

	uxa_clear_pixmap(screen, uxa_screen, pixmap);

	component_alpha = NeedsComponent(maskFormat->format);
	mask = CreatePicture(0, &pixmap->drawable,
			      maskFormat, CPComponentAlpha,
			      &component_alpha, serverClient, &error);
	screen->DestroyPixmap(pixmap);

	if (!mask) {
		FreePicture(white, 0);
		return 1;
	}

	ValidatePicture(mask);

	glyph_atlas = NULL;
	while (nlist--) {
		x += list->xOff;
		y += list->yOff;
		n = list->len;
		while (n--) {
			GlyphPtr glyph = *glyphs++;
			PicturePtr this_atlas;
			int glyph_x, glyph_y;
			struct uxa_glyph *priv;

			if (glyph->info.width == 0 || glyph->info.height == 0)
				goto next_glyph;

			priv = uxa_glyph_get_private(glyph);
			if (priv != NULL) {
				glyph_x = priv->x;
				glyph_y = priv->y;
				this_atlas = priv->cache->picture;
			} else {
				if (glyph_atlas) {
					uxa_screen->info->done_composite(pixmap);
					glyph_atlas = NULL;
				}
				this_atlas = uxa_glyph_cache(screen, glyph, &glyph_x, &glyph_y);
				if (this_atlas == NULL) {
					/* no cache for this glyph */
					this_atlas = GetGlyphPicture(glyph, screen);
					glyph_x = glyph_y = 0;
				}
			}

			if (this_atlas != glyph_atlas) {
				PixmapPtr glyph_pixmap;

				if (glyph_atlas)
					uxa_screen->info->done_composite(pixmap);

				glyph_pixmap =
					uxa_get_drawable_pixmap(this_atlas->pDrawable);
				if (!uxa_pixmap_is_offscreen(glyph_pixmap) ||
				    !uxa_screen->info->prepare_composite(PictOpAdd,
									 white, this_atlas, mask,
									 white_pixmap, glyph_pixmap, pixmap)) {
					FreePicture(white, 0);
					FreePicture(mask, 0);
					return -1;
				}

				glyph_atlas = this_atlas;
			}

			uxa_screen->info->composite(pixmap,
						    0, 0,
						    glyph_x, glyph_y,
						    x - glyph->info.x,
						    y - glyph->info.y,
						    glyph->info.width,
						    glyph->info.height);

next_glyph:
			x += glyph->info.xOff;
			y += glyph->info.yOff;
		}
		list++;
	}
	if (glyph_atlas)
		uxa_screen->info->done_composite(pixmap);

	uxa_composite(op,
		      pSrc, mask, pDst,
		      dst_off_x + xSrc - xDst,
		      dst_off_y + ySrc - yDst,
		      0, 0,
		      dst_off_x, dst_off_y,
		      width, height);

	FreePicture(white, 0);
	FreePicture(mask, 0);
	return 0;
}

static int
uxa_glyphs_to_dst(CARD8 op,
		  PicturePtr pSrc,
		  PicturePtr pDst,
		  INT16 xSrc, INT16 ySrc,
		  int nlist, GlyphListPtr list, GlyphPtr * glyphs)
{
	ScreenPtr screen = pDst->pDrawable->pScreen;
	int x, y, n;

	xSrc -= list->xOff;
	ySrc -= list->yOff;
	x = y = 0;
	while (nlist--) {
		x += list->xOff;
		y += list->yOff;
		n = list->len;
		while (n--) {
			GlyphPtr glyph = *glyphs++;
			PicturePtr glyph_atlas;
			int glyph_x, glyph_y;
			struct uxa_glyph *priv;

			if (glyph->info.width == 0 || glyph->info.height == 0)
				goto next_glyph;

			priv = uxa_glyph_get_private(glyph);
			if (priv != NULL) {
				glyph_x = priv->x;
				glyph_y = priv->y;
				glyph_atlas = priv->cache->picture;
			} else {
				glyph_atlas = uxa_glyph_cache(screen, glyph, &glyph_x, &glyph_y);
				if (glyph_atlas == NULL) {
					/* no cache for this glyph */
					glyph_atlas = GetGlyphPicture(glyph, screen);
					glyph_x = glyph_y = 0;
				}
			}

			uxa_composite(op,
				      pSrc, glyph_atlas, pDst,
				      xSrc + x - glyph->info.x,
				      ySrc + y - glyph->info.y,
				      glyph_x, glyph_y,
				      x - glyph->info.x,
				      y - glyph->info.y,
				      glyph->info.width, glyph->info.height);

next_glyph:
			x += glyph->info.xOff;
			y += glyph->info.yOff;
		}
		list++;
	}

	return 0;
}

static Bool
is_solid(PicturePtr picture)
{
	if (picture->pSourcePict) {
		SourcePict *source = picture->pSourcePict;
		return source->type == SourcePictTypeSolidFill;
	} else {
		return (picture->repeat &&
			picture->pDrawable->width  == 1 &&
			picture->pDrawable->height == 1);
	}
}

void
uxa_glyphs(CARD8 op,
	   PicturePtr pSrc,
	   PicturePtr pDst,
	   PictFormatPtr maskFormat,
	   INT16 xSrc, INT16 ySrc,
	   int nlist, GlyphListPtr list, GlyphPtr * glyphs)
{
	ScreenPtr screen = pDst->pDrawable->pScreen;
	uxa_screen_t *uxa_screen = uxa_get_screen(screen);

	if (uxa_screen->info->flags & UXA_USE_GLAMOR) {
		int ok;

		uxa_picture_prepare_access(pDst, UXA_GLAMOR_ACCESS_RW);
		uxa_picture_prepare_access(pSrc, UXA_GLAMOR_ACCESS_RO);
		ok = glamor_glyphs_nf(op,
				     pSrc, pDst, maskFormat,
				     xSrc, ySrc, nlist, list, glyphs);
		uxa_picture_finish_access(pSrc, UXA_GLAMOR_ACCESS_RO);
		uxa_picture_finish_access(pDst, UXA_GLAMOR_ACCESS_RW);

		if (!ok)
			goto fallback;

		return;
	}

	if (!uxa_screen->info->prepare_composite ||
	    uxa_screen->force_fallback ||
	    !uxa_drawable_is_offscreen(pDst->pDrawable) ||
	    pDst->alphaMap || pSrc->alphaMap ||
	    /* XXX we fail to handle (rare) non-solid sources correctly. */
	    !is_solid(pSrc)) {
fallback:
	    uxa_check_glyphs(op, pSrc, pDst, maskFormat, xSrc, ySrc, nlist, list, glyphs);
	    return;
	}

	/* basic sanity check */
	if (uxa_screen->info->check_composite &&
	    !uxa_screen->info->check_composite(op, pSrc, NULL, pDst, 0, 0)) {
		goto fallback;
	}

	ValidatePicture(pSrc);
	ValidatePicture(pDst);

	if (!maskFormat) {
		/* If we don't have a mask format but all the glyphs have the same format,
		 * require ComponentAlpha and don't intersect, use the glyph format as mask
		 * format for the full benefits of the glyph cache.
		 */
		if (NeedsComponent(list[0].format->format)) {
			Bool sameFormat = TRUE;
			int i;

			maskFormat = list[0].format;

			for (i = 0; i < nlist; i++) {
				if (maskFormat->format != list[i].format->format) {
					sameFormat = FALSE;
					break;
				}
			}

			if (!sameFormat ||
			    uxa_glyphs_intersect(nlist, list, glyphs))
				maskFormat = NULL;
		}
	}

	if (!maskFormat) {
		if (uxa_glyphs_to_dst(op, pSrc, pDst,
				      xSrc, ySrc,
				      nlist, list, glyphs))
			goto fallback;
	} else {
		if (uxa_glyphs_via_mask(op,
					pSrc, pDst, maskFormat,
					xSrc, ySrc,
					nlist, list, glyphs))
			goto fallback;
	}
}
@


1.5
log
@Update to xf86-video-intel 2.20.19.

A recent kernel with kernel modesetting support is required.
Thanks to jsg@@ and kettenis@@ for their work.
@
text
@@


1.4
log
@Update the intel driver to a more recent version based on more recent
upsteam code.

Backporting keeping UMS changes by me, some bugfixes from kettenis@@.

Has been in snapshots for a while, committed on request so we can be
sure what people are running. This is a prerequesite for sandybridge
support but has those chipsets disabled for now until the correct code
has been added.
@
text
@d68 1
d214 5
d243 1
a243 1
	PicturePtr pGlyphPicture = GlyphPicture(glyph)[screen->myNum];
d313 6
a458 1
	int screen = dst->pDrawable->pScreen->myNum;
d461 1
a461 1
	PicturePtr mask;
d466 1
d471 1
d512 12
d536 1
a536 1
			PicturePtr g = GlyphPicture(glyph)[screen];
d538 8
a545 18
				if (maskFormat) {
					CompositePicture(PictOpAdd, g, NULL, mask,
							 0, 0,
							 0, 0,
							 x - glyph->info.x,
							 y - glyph->info.y,
							 glyph->info.width,
							 glyph->info.height);
				} else {
					CompositePicture(op, src, g, dst,
							 xSrc + (x - glyph->info.x) - xDst,
							 ySrc + (y - glyph->info.y) - yDst,
							 0, 0,
							 x - glyph->info.x,
							 y - glyph->info.y,
							 glyph->info.width,
							 glyph->info.height);
				}
d554 3
d560 1
a560 1
		CompositePicture(op, src, mask, dst,
d595 1
a595 1
	PicturePtr glyph_picture = GlyphPicture(glyph)[screen->myNum];
a678 184
static int
uxa_glyphs_to_dst(CARD8 op,
		  PicturePtr pSrc,
		  PicturePtr pDst,
		  INT16 src_x, INT16 src_y,
		  INT16 xDst, INT16 yDst,
		  int nlist, GlyphListPtr list, GlyphPtr * glyphs,
		  BoxPtr extents)
{
	ScreenPtr screen = pDst->pDrawable->pScreen;
	uxa_screen_t *uxa_screen = uxa_get_screen(screen);
	PixmapPtr src_pixmap, dst_pixmap;
	PicturePtr localSrc, glyph_atlas;
	int x, y, n;
	BoxRec box;

	if (uxa_screen->info->check_composite_texture &&
	    uxa_screen->info->check_composite_texture(screen, pSrc)) {
		if (pSrc->pDrawable) {
			int src_off_x, src_off_y;

			src_pixmap = uxa_get_offscreen_pixmap(pSrc->pDrawable, &src_off_x, &src_off_y);
			if (src_pixmap == NULL)
				return -1;

			src_x += pSrc->pDrawable->x + src_off_x;
			src_y += pSrc->pDrawable->y + src_off_y;
		} else {
			src_pixmap = NULL;
		}
		localSrc = pSrc;
	} else {
		int width, height;

		if (extents == NULL) {
			uxa_glyph_extents(nlist, list, glyphs, &box);
			extents = &box;
		}

		width  = extents->x2 - extents->x1;
		height = extents->y2 - extents->y1;
		if (width == 0 || height == 0)
			return 0;

		if (pSrc->pDrawable) {
			int src_off_x, src_off_y;

			src_off_x = extents->x1 - xDst;
			src_off_y = extents->y1 - yDst;
			localSrc = uxa_acquire_drawable(screen, pSrc,
							src_x + src_off_x, src_y + src_off_y,
							width, height,
							&src_x, &src_y);
			if (uxa_screen->info->check_composite_texture &&
			    !uxa_screen->info->check_composite_texture(screen, localSrc)) {
				if (localSrc != pSrc)
					FreePicture(localSrc, 0);
				return -1;
			}

			src_pixmap = uxa_get_offscreen_pixmap(localSrc->pDrawable, &src_off_x, &src_off_y);
			if (src_pixmap == NULL) {
				if (localSrc != pSrc)
					FreePicture(localSrc, 0);
				return -1;
			}

			src_x += localSrc->pDrawable->x + src_off_x;
			src_y += localSrc->pDrawable->y + src_off_y;
		} else {
			localSrc = uxa_acquire_pattern(screen, pSrc,
						       PICT_a8r8g8b8, x, y, width, height);
			if (!localSrc)
				return 1;

			src_pixmap = uxa_get_drawable_pixmap(localSrc->pDrawable);
			if (src_pixmap == NULL) {
				FreePicture(localSrc, 0);
				return -1;
			}

			src_x = src_y = 0;
		}
	}

	dst_pixmap = uxa_get_offscreen_pixmap(pDst->pDrawable, &x, &y);
	x += xDst + pDst->pDrawable->x - list->xOff;
	y += yDst + pDst->pDrawable->y - list->yOff;

	glyph_atlas = NULL;
	while (nlist--) {
		x += list->xOff;
		y += list->yOff;
		n = list->len;
		while (n--) {
			GlyphPtr glyph = *glyphs++;
			PicturePtr this_atlas;
			int mask_x, mask_y, nrect;
			struct uxa_glyph *priv;
			BoxPtr rects;

			if (glyph->info.width == 0 || glyph->info.height == 0)
				goto next_glyph;

			priv = uxa_glyph_get_private(glyph);
			if (priv != NULL) {
				mask_x = priv->x;
				mask_y = priv->y;
				this_atlas = priv->cache->picture;
			} else {
				if (glyph_atlas) {
					uxa_screen->info->done_composite(dst_pixmap);
					glyph_atlas = NULL;
				}
				this_atlas = uxa_glyph_cache(screen, glyph, &mask_x, &mask_y);
				if (this_atlas == NULL) {
					/* no cache for this glyph */
					this_atlas = GlyphPicture(glyph)[screen->myNum];
					mask_x = mask_y = 0;
				}
			}

			if (this_atlas != glyph_atlas) {
				PixmapPtr mask_pixmap;

				if (glyph_atlas)
					uxa_screen->info->done_composite(dst_pixmap);

				mask_pixmap =
					uxa_get_drawable_pixmap(this_atlas->pDrawable);
				if (!uxa_pixmap_is_offscreen(mask_pixmap) ||
				    !uxa_screen->info->prepare_composite(op,
									 localSrc, this_atlas, pDst,
									 src_pixmap, mask_pixmap, dst_pixmap))
					return -1;

				glyph_atlas = this_atlas;
			}

			rects = REGION_RECTS(pDst->pCompositeClip);
			nrect = REGION_NUM_RECTS(pDst->pCompositeClip);
			while (nrect--) {
				int x1 = x - glyph->info.x, dx = 0;
				int y1 = y - glyph->info.y, dy = 0;
				int x2 = x1 + glyph->info.width;
				int y2 = y1 + glyph->info.height;

				if (rects->y1 >= y2)
					break;

				if (x1 < rects->x1)
					dx = rects->x1 - x1, x1 = rects->x1;
				if (x2 > rects->x2)
					x2 = rects->x2;
				if (y1 < rects->y1)
					dy = rects->y1 - y1, y1 = rects->y1;
				if (y2 > rects->y2)
					y2 = rects->y2;

				if (x1 < x2 && y1 < y2) {
					uxa_screen->info->composite(dst_pixmap,
								    x1 + src_x,  y1 + src_y,
								    dx + mask_x, dy + mask_y,
								    x1, y1,
								    x2 - x1, y2 - y1);
				}
				rects++;
			}

next_glyph:
			x += glyph->info.xOff;
			y += glyph->info.yOff;
		}
		list++;
	}
	if (glyph_atlas)
		uxa_screen->info->done_composite(dst_pixmap);

	if (localSrc != pSrc)
		FreePicture(localSrc, 0);

	return 0;
}

d720 17
d743 1
a743 3
		    INT16 xDst, INT16 yDst,
		    int nlist, GlyphListPtr list, GlyphPtr * glyphs,
		    BoxPtr extents)
d748 3
a750 2
	PixmapPtr pixmap;
	PicturePtr glyph_atlas, mask;
d756 11
a766 17
	if (!extents) {
		uxa_glyph_extents(nlist, list, glyphs, &box);

		if (box.x2 <= box.x1 || box.y2 <= box.y1)
			return 0;

		extents = &box;
		dst_off_x = box.x1;
		dst_off_y = box.y1;
	} else {
		dst_off_x = dst_off_y = 0;
	}

	width  = extents->x2 - extents->x1;
	height = extents->y2 - extents->y1;
	x = -extents->x1;
	y = -extents->y1;
d789 11
d808 2
a809 1
	if (!mask)
d811 1
d823 1
a823 1
			int src_x, src_y;
d831 2
a832 2
				src_x = priv->x;
				src_y = priv->y;
d839 1
a839 1
				this_atlas = uxa_glyph_cache(screen, glyph, &src_x, &src_y);
d842 2
a843 2
					this_atlas = GlyphPicture(glyph)[screen->myNum];
					src_x = src_y = 0;
d848 1
a848 1
				PixmapPtr src_pixmap;
d853 1
a853 1
				src_pixmap =
d855 1
a855 1
				if (!uxa_pixmap_is_offscreen(src_pixmap) ||
d857 4
a860 2
									 this_atlas, NULL, mask,
									 src_pixmap, NULL, pixmap))
d862 1
a867 1
						    src_x, src_y,
d869 1
d892 1
d897 59
d979 17
a995 5
	int xDst = list->xOff, yDst = list->yOff;
	BoxRec extents = { 0, 0, 0, 0 };
	Bool have_extents = FALSE;
	int width, height, ret;
	PicturePtr localDst = pDst;
a997 1
	    uxa_screen->swappedOut ||
d1041 4
a1044 11
	if (!maskFormat &&
	    uxa_screen->info->check_composite_target &&
	    !uxa_screen->info->check_composite_target(uxa_get_drawable_pixmap(pDst->pDrawable))) {
		int depth = pDst->pDrawable->depth;
		PixmapPtr pixmap;
		int x, y, error;
		GCPtr gc;

		pixmap = uxa_get_drawable_pixmap(pDst->pDrawable);
		if (uxa_screen->info->check_copy &&
		    !uxa_screen->info->check_copy(pixmap, pixmap, GXcopy, FB_ALLONES))
a1045 66

		uxa_glyph_extents(nlist, list, glyphs, &extents);

		/* clip against dst bounds */
		if (extents.x1 < 0)
			extents.x1 = 0;
		if (extents.y1 < 0)
			extents.y1 = 0;
		if (extents.x2 > pDst->pDrawable->width)
			extents.x2 = pDst->pDrawable->width;
		if (extents.y2 > pDst->pDrawable->height)
			extents.y2 = pDst->pDrawable->height;

		if (extents.x2 <= extents.x1 || extents.y2 <= extents.y1)
			return;
		width  = extents.x2 - extents.x1;
		height = extents.y2 - extents.y1;
		x = -extents.x1;
		y = -extents.y1;
		have_extents = TRUE;

		xDst += x;
		yDst += y;

		pixmap = screen->CreatePixmap(screen,
					      width, height, depth,
					      CREATE_PIXMAP_USAGE_SCRATCH);
		if (!pixmap)
			return;

		if (!uxa_pixmap_is_offscreen(pixmap)) {
			screen->DestroyPixmap(pixmap);
			goto fallback;
		}

		gc = GetScratchGC(depth, screen);
		if (!gc) {
			screen->DestroyPixmap(pixmap);
			return;
		}

		ValidateGC(&pixmap->drawable, gc);
		gc->ops->CopyArea(pDst->pDrawable, &pixmap->drawable, gc,
				  extents.x1, extents.y1,
				  width, height,
				  0, 0);
		FreeScratchGC(gc);

		localDst = CreatePicture(0, &pixmap->drawable,
					 PictureMatchFormat(screen, depth, pDst->format),
					 0, 0, serverClient, &error);
		screen->DestroyPixmap(pixmap);

		if (!localDst)
			return;

		ValidatePicture(localDst);
	}

	if (maskFormat) {
		ret = uxa_glyphs_via_mask(op,
					  pSrc, localDst, maskFormat,
					  xSrc, ySrc,
					  xDst, yDst,
					  nlist, list, glyphs,
					  have_extents ? &extents : NULL);
d1047 2
a1048 2
		ret = uxa_glyphs_to_dst(op,
					pSrc, localDst,
d1050 2
a1051 25
					xDst, yDst,
					nlist, list, glyphs,
					have_extents ? &extents : NULL);
	}
	if (ret) {
		if (localDst != pDst)
			FreePicture(localDst, 0);

		goto fallback;
	}

	if (localDst != pDst) {
		GCPtr gc;

		gc = GetScratchGC(pDst->pDrawable->depth, screen);
		if (gc) {
			ValidateGC(pDst->pDrawable, gc);
			gc->ops->CopyArea(localDst->pDrawable, pDst->pDrawable, gc,
					  0, 0,
					  width, height,
					  extents.x1, extents.y1);
			FreeScratchGC(gc);
		}

		FreePicture(localDst, 0);
@


1.3
log
@Update the intel driver to (mostly) a backport of 2.12.

It is missing a few commits that I have yet to verify (ones that try and
continue if we lock the gpu rendering engine and can't reset it, for
example) taht will be verified and sent out for extra testing soon.

Should contain a bunch of speedups and some correctness improvements
(though rendercheck still gives some errors that I am looking into).

This has been in snaps since the first day of c2k10, any known issues
with just this driver have (to my knowledge) been fixed since. A problem
with macbooks pointed out by otto happens with both this and the in-tree
driver and thus doesn't stop this moving forward.

As well as the 2.12 improvements, this driver also has a backport
(partially aided by the backports in RHEL 5 kindly provided by Dave
Airlie) from the kms code of modesetting support for ironlake (arrandale
and clarkdale: the IGDs build into intel nehalem cpu dies) which has
been tested on a number of chipsets. Note that Display port and eDP
displays have not yet been worked on (and probably won't until I can
find a displayport monitor), but VGA and lvds at least are known to
work, sure beats vesa.

"no objection on my side" matthieu@@, prodding (as always) from princess
marco.
@
text
@d114 3
d126 1
d152 4
d175 6
a180 1
		assert (uxa_pixmap_is_offscreen(pixmap));
a212 7
	/* We are trying to initialise per screen resources prior to the
	 * complete initialisation of the screen. So ensure the components
	 * that we depend upon are initialsed prior to our use.
	 */
	if (!CreateScratchPixmapsForScreen(pScreen->myNum))
		return FALSE;

d221 3
a223 2
	if (!uxa_realize_glyph_caches(pScreen))
		return FALSE;
d225 1
a225 1
	return TRUE;
d303 2
a304 2
uxa_glyph_unrealize(ScreenPtr pScreen,
		    GlyphPtr pGlyph)
d308 2
a309 1
	priv = uxa_glyph_get_private(pGlyph);
d315 1
a315 1
	uxa_glyph_set_private(pGlyph, NULL);
d791 2
a792 3
				assert (uxa_pixmap_is_offscreen(mask_pixmap));

				if (!uxa_screen->info->prepare_composite(op,
d940 5
d998 2
a999 3
				assert (uxa_pixmap_is_offscreen(src_pixmap));

				if (!uxa_screen->info->prepare_composite(PictOpAdd,
d1036 13
d1067 1
d1069 3
a1071 1
	    pDst->alphaMap || pSrc->alphaMap) {
d1151 5
@


1.2
log
@Update the intel driver to 2.9.1 plus backports.

2.9.1 is the last version of the intel DDX that supports UMS (User
modesetting), with 2.10 onwards being purely KMS only. As such, this
driver contains backports of almost every correctness or performance
related fix to the rendering layer in later intel drivers. This driver
*REQUIRES* a GEM enabled kernel. it claims to support non-gem mode but
this is essentially unmaintained and due to the way the abstraciton
works is slow, if it works at all (it often does not). You have been
warned.

tested by many many people on tech over the last few weeks.
@
text
@d2 2
a3 1
 * Copyright © 2008 Red Hat, Inc.
d10 17
d37 1
a37 1
 * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN 
d54 1
a54 1
 * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN 
d57 2
a58 2
 * Author: Owen Taylor <otaylor@@fishsoup.net>
 * Based on code by: Keith Packard
a71 6
#if DEBUG_GLYPH_CACHE
#define DBG_GLYPH_CACHE(a) ErrorF a
#else
#define DBG_GLYPH_CACHE(a)
#endif

d76 10
a85 1
#define CACHE_PICTURE_WIDTH 1024
d87 5
a91 4
/* Maximum number of glyphs we buffer on the stack before flushing
 * rendering to the mask or destination surface.
 */
#define GLYPH_BUFFER_SIZE 256
d93 8
a100 11
typedef struct {
	PicturePtr source;
	uxa_composite_rect_t rects[GLYPH_BUFFER_SIZE];
	int count;
} uxa_glyph_buffer_t;

typedef enum {
	UXA_GLYPH_SUCCESS,	/* Glyph added to render buffer */
	UXA_GLYPH_FAIL,		/* out of memory, etc */
	UXA_GLYPH_NEED_FLUSH,	/* would evict a glyph already in the buffer */
} uxa_glyph_cache_result_t;
d102 1
a102 1
void uxa_glyphs_init(ScreenPtr pScreen)
d104 2
a105 2
	uxa_screen_t *uxa_screen = uxa_get_screen(pScreen);
	int i = 0;
d107 1
a107 28
	memset(uxa_screen->glyphCaches, 0, sizeof(uxa_screen->glyphCaches));

	uxa_screen->glyphCaches[i].format = PICT_a8;
	uxa_screen->glyphCaches[i].glyphWidth =
	    uxa_screen->glyphCaches[i].glyphHeight = 16;
	i++;
	uxa_screen->glyphCaches[i].format = PICT_a8;
	uxa_screen->glyphCaches[i].glyphWidth =
	    uxa_screen->glyphCaches[i].glyphHeight = 32;
	i++;
	uxa_screen->glyphCaches[i].format = PICT_a8r8g8b8;
	uxa_screen->glyphCaches[i].glyphWidth =
	    uxa_screen->glyphCaches[i].glyphHeight = 16;
	i++;
	uxa_screen->glyphCaches[i].format = PICT_a8r8g8b8;
	uxa_screen->glyphCaches[i].glyphWidth =
	    uxa_screen->glyphCaches[i].glyphHeight = 32;
	i++;

	assert(i == UXA_NUM_GLYPH_CACHES);

	for (i = 0; i < UXA_NUM_GLYPH_CACHES; i++) {
		uxa_screen->glyphCaches[i].columns =
		    CACHE_PICTURE_WIDTH / uxa_screen->glyphCaches[i].glyphWidth;
		uxa_screen->glyphCaches[i].size = 256;
		uxa_screen->glyphCaches[i].hashSize = 557;
	}
}
d109 1
a109 1
static void uxa_unrealize_glyph_caches(ScreenPtr pScreen, unsigned int format)
d114 1
a114 1
	for (i = 0; i < UXA_NUM_GLYPH_CACHES; i++) {
d117 2
a118 7
		if (cache->format != format)
			continue;

		if (cache->picture) {
			FreePicture((pointer) cache->picture, (XID) 0);
			cache->picture = NULL;
		}
d120 2
a121 10
		if (cache->hashEntries) {
			xfree(cache->hashEntries);
			cache->hashEntries = NULL;
		}

		if (cache->glyphs) {
			xfree(cache->glyphs);
			cache->glyphs = NULL;
		}
		cache->glyphCount = 0;
d125 4
a128 1
#define NeedsComponent(f) (PICT_FORMAT_A(f) != 0 && PICT_FORMAT_RGB(f) != 0)
d139 1
a139 1
static Bool uxa_realize_glyph_caches(ScreenPtr pScreen, unsigned int format)
d142 4
a145 6
	int depth = PIXMAN_FORMAT_DEPTH(format);
	PictFormatPtr pPictFormat;
	PixmapPtr pPixmap;
	PicturePtr pPicture;
	CARD32 component_alpha;
	int height;
a146 1
	int error;
d148 1
a148 5
	pPictFormat = PictureMatchFormat(pScreen, depth, format);
	if (!pPictFormat)
		return FALSE;

	/* Compute the total vertical size needed for the format */
d150 1
a150 2
	height = 0;
	for (i = 0; i < UXA_NUM_GLYPH_CACHES; i++) {
d152 8
a159 1
		int rows;
d161 7
a167 2
		if (cache->format != format)
			continue;
d169 4
a172 1
		cache->yOffset = height;
d174 1
a174 3
		rows = (cache->size + cache->columns - 1) / cache->columns;
		height += rows * cache->glyphHeight;
	}
d176 2
a177 13
	/* Now allocate the pixmap and picture */

	pPixmap = (*pScreen->CreatePixmap) (pScreen,
					    CACHE_PICTURE_WIDTH,
					    height, depth,
					    INTEL_CREATE_PIXMAP_TILING_X);
	if (!pPixmap)
		return FALSE;

	component_alpha = NeedsComponent(pPictFormat->format);
	pPicture = CreatePicture(0, &pPixmap->drawable, pPictFormat,
				 CPComponentAlpha, &component_alpha,
				 serverClient, &error);
d179 1
a179 1
	(*pScreen->DestroyPixmap) (pPixmap);	/* picture holds a refcount */
d181 3
a183 20
	if (!pPicture)
		return FALSE;

	/* And store the picture in all the caches for the format */

	for (i = 0; i < UXA_NUM_GLYPH_CACHES; i++) {
		uxa_glyph_cache_t *cache = &uxa_screen->glyphCaches[i];
		int j;

		if (cache->format != format)
			continue;

		cache->picture = pPicture;
		cache->picture->refcnt++;
		cache->hashEntries = xalloc(sizeof(int) * cache->hashSize);
		cache->glyphs =
		    xalloc(sizeof(uxa_cached_glyph_t) * cache->size);
		cache->glyphCount = 0;

		if (!cache->hashEntries || !cache->glyphs)
d186 1
a186 4
		for (j = 0; j < cache->hashSize; j++)
			cache->hashEntries[j] = -1;

		cache->evictionPosition = rand() % cache->size;
d188 1
a189 2
	/* Each cache references the picture individually */
	FreePicture((pointer) pPicture, (XID) 0);
d193 1
a193 1
	uxa_unrealize_glyph_caches(pScreen, format);
a196 4
void uxa_glyphs_fini(ScreenPtr pScreen)
{
	uxa_screen_t *uxa_screen = uxa_get_screen(pScreen);
	int i;
d198 1
a198 10
	for (i = 0; i < UXA_NUM_GLYPH_CACHES; i++) {
		uxa_glyph_cache_t *cache = &uxa_screen->glyphCaches[i];

		if (cache->picture)
			uxa_unrealize_glyph_caches(pScreen, cache->format);
	}
}

static int
uxa_glyph_cache_hash_lookup(uxa_glyph_cache_t * cache, GlyphPtr pGlyph)
d200 6
a205 1
	int slot;
d207 7
a213 1
	slot = (*(CARD32 *) pGlyph->sha1) % cache->hashSize;
d215 2
a216 4
	while (TRUE) {		/* hash table can never be full */
		int entryPos = cache->hashEntries[slot];
		if (entryPos == -1)
			return -1;
d218 1
a218 85
		if (memcmp
		    (pGlyph->sha1, cache->glyphs[entryPos].sha1,
		     sizeof(pGlyph->sha1)) == 0) {
			return entryPos;
		}

		slot--;
		if (slot < 0)
			slot = cache->hashSize - 1;
	}
}

static void
uxa_glyph_cache_hash_insert(uxa_glyph_cache_t * cache, GlyphPtr pGlyph, int pos)
{
	int slot;

	memcpy(cache->glyphs[pos].sha1, pGlyph->sha1, sizeof(pGlyph->sha1));

	slot = (*(CARD32 *) pGlyph->sha1) % cache->hashSize;

	while (TRUE) {		/* hash table can never be full */
		if (cache->hashEntries[slot] == -1) {
			cache->hashEntries[slot] = pos;
			return;
		}

		slot--;
		if (slot < 0)
			slot = cache->hashSize - 1;
	}
}

static void uxa_glyph_cache_hash_remove(uxa_glyph_cache_t * cache, int pos)
{
	int slot;
	int emptiedSlot = -1;

	slot = (*(CARD32 *) cache->glyphs[pos].sha1) % cache->hashSize;

	while (TRUE) {		/* hash table can never be full */
		int entryPos = cache->hashEntries[slot];

		if (entryPos == -1)
			return;

		if (entryPos == pos) {
			cache->hashEntries[slot] = -1;
			emptiedSlot = slot;
		} else if (emptiedSlot != -1) {
			/* See if we can move this entry into the emptied slot,
			 * we can't do that if if entry would have hashed
			 * between the current position and the emptied slot.
			 * (taking wrapping into account). Bad positions
			 * are:
			 *
			 * |   XXXXXXXXXX             |
			 *     i         j
			 *
			 * |XXX                   XXXX|
			 *     j                  i
			 *
			 * i - slot, j - emptiedSlot
			 *
			 * (Knuth 6.4R)
			 */

			int entrySlot =
			    (*(CARD32 *) cache->glyphs[entryPos].sha1) %
			    cache->hashSize;

			if (!((entrySlot >= slot && entrySlot < emptiedSlot) ||
			      (emptiedSlot < slot
			       && (entrySlot < emptiedSlot
				   || entrySlot >= slot)))) {
				cache->hashEntries[emptiedSlot] = entryPos;
				cache->hashEntries[slot] = -1;
				emptiedSlot = slot;
			}
		}

		slot--;
		if (slot < 0)
			slot = cache->hashSize - 1;
	}
a220 3
#define CACHE_X(pos) (((pos) % cache->columns) * cache->glyphWidth)
#define CACHE_Y(pos) (cache->yOffset + ((pos) / cache->columns) * cache->glyphHeight)

d224 2
a225 2
static Bool
uxa_glyph_cache_upload_glyph(ScreenPtr pScreen,
d227 2
a228 1
			     int pos, GlyphPtr pGlyph)
d230 1
a230 1
	PicturePtr pGlyphPicture = GlyphPicture(pGlyph)[pScreen->myNum];
d234 1
a234 1
	GCPtr pGC;
d236 3
a238 4
	/* UploadToScreen only works if bpp match */
	if (pGlyphPixmap->drawable.bitsPerPixel !=
	    pCachePixmap->drawable.bitsPerPixel)
		return FALSE;
d240 1
a240 2
	pGC = GetScratchGC(pCachePixmap->drawable.depth, pScreen);
	ValidateGC(&pCachePixmap->drawable, pGC);
d242 1
d244 26
a269 85
	scratch = (*pScreen->CreatePixmap)(pScreen,
					   pGlyph->info.width,
					   pGlyph->info.height,
					   pGlyphPixmap->drawable.depth,
					   UXA_CREATE_PIXMAP_FOR_MAP);
	if (scratch) {
		(void)uxa_copy_area(&pGlyphPixmap->drawable,
				    &scratch->drawable,
				    pGC,
				    0, 0,
				    pGlyph->info.width, pGlyph->info.height,
				    0, 0);
	} else {
		scratch = pGlyphPixmap;
	}

	(void)uxa_copy_area(&scratch->drawable,
			    &pCachePixmap->drawable,
			    pGC,
			    0, 0, pGlyph->info.width, pGlyph->info.height,
			    CACHE_X(pos), CACHE_Y(pos));

	if (scratch != pGlyphPixmap)
		(*pScreen->DestroyPixmap)(scratch);

	FreeScratchGC(pGC);

	return TRUE;
}

static uxa_glyph_cache_result_t
uxa_glyph_cache_buffer_glyph(ScreenPtr pScreen,
			     uxa_glyph_cache_t * cache,
			     uxa_glyph_buffer_t * buffer,
			     GlyphPtr pGlyph, int xGlyph, int yGlyph)
{
	uxa_composite_rect_t *rect;
	int pos;

	if (buffer->source && buffer->source != cache->picture)
		return UXA_GLYPH_NEED_FLUSH;

	if (!cache->picture) {
		if (!uxa_realize_glyph_caches(pScreen, cache->format))
			return UXA_GLYPH_FAIL;
	}

	DBG_GLYPH_CACHE(("(%d,%d,%s): buffering glyph %lx\n",
			 cache->glyphWidth, cache->glyphHeight,
			 cache->format == PICT_a8 ? "A" : "ARGB",
			 (long)*(CARD32 *) pGlyph->sha1));

	pos = uxa_glyph_cache_hash_lookup(cache, pGlyph);
	if (pos != -1) {
		DBG_GLYPH_CACHE(("  found existing glyph at %d\n", pos));
	} else {
		if (cache->glyphCount < cache->size) {
			/* Space remaining; we fill from the start */
			pos = cache->glyphCount;
			cache->glyphCount++;
			DBG_GLYPH_CACHE(("  storing glyph in free space at %d\n", pos));

			uxa_glyph_cache_hash_insert(cache, pGlyph, pos);

		} else {
			/* Need to evict an entry. We have to see if any glyphs
			 * already in the output buffer were at this position in
			 * the cache
			 */

			pos = cache->evictionPosition;
			DBG_GLYPH_CACHE(("  evicting glyph at %d\n", pos));
			if (buffer->count) {
				int x, y;
				int i;

				x = CACHE_X(pos);
				y = CACHE_Y(pos);

				for (i = 0; i < buffer->count; i++) {
					if (buffer->rects[i].xSrc == x
					    && buffer->rects[i].ySrc == y) {
						DBG_GLYPH_CACHE(("  must flush buffer\n"));
						return UXA_GLYPH_NEED_FLUSH;
					}
d271 7
d279 2
a280 24

			/* OK, we're all set, swap in the new glyph */
			uxa_glyph_cache_hash_remove(cache, pos);
			uxa_glyph_cache_hash_insert(cache, pGlyph, pos);

			/* And pick a new eviction position */
			cache->evictionPosition = rand() % cache->size;
		}

		/* Now actually upload the glyph into the cache picture; if
		 * we can't do it with UploadToScreen (because the glyph is
		 * offscreen, etc), we fall back to CompositePicture.
		 */
		if (!uxa_glyph_cache_upload_glyph(pScreen, cache, pos, pGlyph)) {
			CompositePicture(PictOpSrc,
					 GlyphPicture(pGlyph)[pScreen->myNum],
					 None,
					 cache->picture,
					 0, 0,
					 0, 0,
					 CACHE_X(pos),
					 CACHE_Y(pos),
					 pGlyph->info.width,
					 pGlyph->info.height);
a281 1

d284 4
a287 1
	buffer->source = cache->picture;
d289 2
a290 7
	rect = &buffer->rects[buffer->count];
	rect->xSrc = CACHE_X(pos);
	rect->ySrc = CACHE_Y(pos);
	rect->xDst = xGlyph - pGlyph->info.x;
	rect->yDst = yGlyph - pGlyph->info.y;
	rect->width = pGlyph->info.width;
	rect->height = pGlyph->info.height;
d292 1
a292 3
	buffer->count++;

	return UXA_GLYPH_SUCCESS;
d295 3
a297 67
#undef CACHE_X
#undef CACHE_Y

static uxa_glyph_cache_result_t
uxa_buffer_glyph(ScreenPtr pScreen,
		 uxa_glyph_buffer_t * buffer,
		 GlyphPtr pGlyph, int xGlyph, int yGlyph)
{
	uxa_screen_t *uxa_screen = uxa_get_screen(pScreen);
	unsigned int format = (GlyphPicture(pGlyph)[pScreen->myNum])->format;
	int width = pGlyph->info.width;
	int height = pGlyph->info.height;
	uxa_composite_rect_t *rect;
	PicturePtr source;
	int i;

	if (buffer->count == GLYPH_BUFFER_SIZE)
		return UXA_GLYPH_NEED_FLUSH;

	if (PICT_FORMAT_BPP(format) == 1)
		format = PICT_a8;

	for (i = 0; i < UXA_NUM_GLYPH_CACHES; i++) {
		uxa_glyph_cache_t *cache = &uxa_screen->glyphCaches[i];

		if (format == cache->format &&
		    width <= cache->glyphWidth &&
		    height <= cache->glyphHeight) {
			uxa_glyph_cache_result_t result =
			    uxa_glyph_cache_buffer_glyph(pScreen,
							 &uxa_screen->
							 glyphCaches[i],
							 buffer,
							 pGlyph, xGlyph,
							 yGlyph);
			switch (result) {
			case UXA_GLYPH_FAIL:
				break;
			case UXA_GLYPH_SUCCESS:
			case UXA_GLYPH_NEED_FLUSH:
				return result;
			}
		}
	}

	/* Couldn't find the glyph in the cache, use the glyph picture directly */

	source = GlyphPicture(pGlyph)[pScreen->myNum];
	if (buffer->source && buffer->source != source)
		return UXA_GLYPH_NEED_FLUSH;

	buffer->source = source;

	rect = &buffer->rects[buffer->count];
	rect->xSrc = 0;
	rect->ySrc = 0;
	rect->xDst = xGlyph - pGlyph->info.x;
	rect->yDst = yGlyph - pGlyph->info.y;
	rect->width = pGlyph->info.width;
	rect->height = pGlyph->info.height;

	buffer->count++;

	return UXA_GLYPH_SUCCESS;
}

static void uxa_glyphs_to_mask(PicturePtr pMask, uxa_glyph_buffer_t * buffer)
d299 1
a299 2
	uxa_composite_rects(PictOpAdd, buffer->source, pMask,
			    buffer->count, buffer->rects);
d301 3
a303 3
	buffer->count = 0;
	buffer->source = NULL;
}
d305 1
a305 23
static void
uxa_glyphs_to_dst(CARD8 op,
		  PicturePtr pSrc,
		  PicturePtr pDst,
		  uxa_glyph_buffer_t * buffer,
		  INT16 xSrc, INT16 ySrc, INT16 xDst, INT16 yDst)
{
	int i;

	for (i = 0; i < buffer->count; i++) {
		uxa_composite_rect_t *rect = &buffer->rects[i];

		CompositePicture(op,
				 pSrc,
				 buffer->source,
				 pDst,
				 xSrc + rect->xDst - xDst,
				 ySrc + rect->yDst - yDst,
				 rect->xSrc,
				 rect->ySrc,
				 rect->xDst,
				 rect->yDst, rect->width, rect->height);
	}
d307 2
a308 2
	buffer->count = 0;
	buffer->source = NULL;
d317 1
a317 3
	int n;
	GlyphPtr glyph;
	int x, y;
d319 3
a321 6
	x = 0;
	y = 0;
	extents->x1 = MAXSHORT;
	extents->x2 = MINSHORT;
	extents->y1 = MAXSHORT;
	extents->y2 = MINSHORT;
d328 17
a344 21
			glyph = *glyphs++;
			x1 = x - glyph->info.x;
			if (x1 < MINSHORT)
				x1 = MINSHORT;
			y1 = y - glyph->info.y;
			if (y1 < MINSHORT)
				y1 = MINSHORT;
			x2 = x1 + glyph->info.width;
			if (x2 > MAXSHORT)
				x2 = MAXSHORT;
			y2 = y1 + glyph->info.height;
			if (y2 > MAXSHORT)
				y2 = MAXSHORT;
			if (x1 < extents->x1)
				extents->x1 = x1;
			if (x2 > extents->x2)
				extents->x2 = x2;
			if (y1 < extents->y1)
				extents->y1 = y1;
			if (y2 > extents->y2)
				extents->y2 = y2;
d349 5
a364 1
	GlyphPtr glyph;
d381 1
a381 1
			glyph = *glyphs++;
d431 7
a437 7
void
uxa_glyphs(CARD8 op,
	   PicturePtr pSrc,
	   PicturePtr pDst,
	   PictFormatPtr maskFormat,
	   INT16 xSrc,
	   INT16 ySrc, int nlist, GlyphListPtr list, GlyphPtr * glyphs)
d439 4
a442 4
	PicturePtr pPicture;
	PixmapPtr pMaskPixmap = 0;
	PicturePtr pMask;
	ScreenPtr pScreen = pDst->pDrawable->pScreen;
d444 1
a444 1
	int x, y;
a445 3
	int n;
	GlyphPtr glyph;
	int error;
a446 26
	CARD32 component_alpha;
	uxa_glyph_buffer_t buffer;

	/* If we don't have a mask format but all the glyphs have the same format
	 * and don't intersect, use the glyph format as mask format for the full
	 * benefits of the glyph cache.
	 */
	if (!maskFormat) {
		Bool sameFormat = TRUE;
		int i;

		maskFormat = list[0].format;

		for (i = 0; i < nlist; i++) {
			if (maskFormat->format != list[i].format->format) {
				sameFormat = FALSE;
				break;
			}
		}

		if (!sameFormat || (maskFormat->depth != 1 &&
				    uxa_glyphs_intersect(nlist, list,
							 glyphs))) {
			maskFormat = NULL;
		}
	}
d449 3
a451 2
		GCPtr pGC;
		xRectangle rect;
a453 1

d456 1
d460 16
a475 6
		if (maskFormat->depth == 1) {
			PictFormatPtr a8Format =
			    PictureMatchFormat(pScreen, 8, PICT_a8);

			if (a8Format)
				maskFormat = a8Format;
a477 5
		pMaskPixmap = (*pScreen->CreatePixmap) (pScreen, width, height,
							maskFormat->depth,
							CREATE_PIXMAP_USAGE_SCRATCH);
		if (!pMaskPixmap)
			return;
d479 6
a484 5
		pMask = CreatePicture(0, &pMaskPixmap->drawable,
				      maskFormat, CPComponentAlpha,
				      &component_alpha, serverClient, &error);
		if (!pMask) {
			(*pScreen->DestroyPixmap) (pMaskPixmap);
d487 2
a488 9
		pGC = GetScratchGC(pMaskPixmap->drawable.depth, pScreen);
		ValidateGC(&pMaskPixmap->drawable, pGC);
		rect.x = 0;
		rect.y = 0;
		rect.width = width;
		rect.height = height;
		(*pGC->ops->PolyFillRect) (&pMaskPixmap->drawable, pGC, 1,
					   &rect);
		FreeScratchGC(pGC);
d492 1
a492 1
		pMask = pDst;
d496 247
a742 2
	buffer.count = 0;
	buffer.source = NULL;
d748 26
a773 2
			glyph = *glyphs++;
			pPicture = GlyphPicture(glyph)[pScreen->myNum];
d775 2
a776 9
			if (glyph->info.width > 0 && glyph->info.height > 0 &&
			    uxa_buffer_glyph(pScreen, &buffer, glyph, x,
					     y) == UXA_GLYPH_NEED_FLUSH) {
				if (maskFormat)
					uxa_glyphs_to_mask(pMask, &buffer);
				else
					uxa_glyphs_to_dst(op, pSrc, pDst,
							  &buffer, xSrc, ySrc,
							  xDst, yDst);
d778 43
a820 1
				uxa_buffer_glyph(pScreen, &buffer, glyph, x, y);
d823 1
d829 5
d835 312
a1146 6
	if (buffer.count) {
		if (maskFormat)
			uxa_glyphs_to_mask(pMask, &buffer);
		else
			uxa_glyphs_to_dst(op, pSrc, pDst, &buffer,
					  xSrc, ySrc, xDst, yDst);
d1150 35
a1184 10
		x = extents.x1;
		y = extents.y1;
		CompositePicture(op,
				 pSrc,
				 pMask,
				 pDst,
				 xSrc + x - xDst,
				 ySrc + y - yDst, 0, 0, x, y, width, height);
		FreePicture((pointer) pMask, (XID) 0);
		(*pScreen->DestroyPixmap) (pMaskPixmap);
@


1.1
log
@update to xf86-video-intel 2.7.1. Tested by many.
@
text
@d50 1
a53 2
#ifdef SERVER_1_5

d72 3
a74 3
    PicturePtr source;
    uxa_composite_rect_t rects[GLYPH_BUFFER_SIZE];
    int count;
d78 3
a80 3
    UXA_GLYPH_SUCCESS,    /* Glyph added to render buffer */
    UXA_GLYPH_FAIL,       /* out of memory, etc */
    UXA_GLYPH_NEED_FLUSH, /* would evict a glyph already in the buffer */
d83 1
a83 2
void
uxa_glyphs_init(ScreenPtr pScreen)
d85 2
a86 2
    uxa_screen_t    *uxa_screen = uxa_get_screen(pScreen);
    int		    i = 0;
d88 1
a88 1
    memset(uxa_screen->glyphCaches, 0, sizeof(uxa_screen->glyphCaches));
d90 25
a114 20
    uxa_screen->glyphCaches[i].format = PICT_a8;
    uxa_screen->glyphCaches[i].glyphWidth = uxa_screen->glyphCaches[i].glyphHeight = 16;
    i++;
    uxa_screen->glyphCaches[i].format = PICT_a8;
    uxa_screen->glyphCaches[i].glyphWidth = uxa_screen->glyphCaches[i].glyphHeight = 32;
    i++;
    uxa_screen->glyphCaches[i].format = PICT_a8r8g8b8;
    uxa_screen->glyphCaches[i].glyphWidth = uxa_screen->glyphCaches[i].glyphHeight = 16;
    i++;
    uxa_screen->glyphCaches[i].format = PICT_a8r8g8b8;
    uxa_screen->glyphCaches[i].glyphWidth = uxa_screen->glyphCaches[i].glyphHeight = 32;
    i++;

    assert(i == UXA_NUM_GLYPH_CACHES);
    
    for (i = 0; i < UXA_NUM_GLYPH_CACHES; i++) {
	uxa_screen->glyphCaches[i].columns = CACHE_PICTURE_WIDTH / uxa_screen->glyphCaches[i].glyphWidth;
	uxa_screen->glyphCaches[i].size = 256;
	uxa_screen->glyphCaches[i].hashSize = 557;
    }
d117 20
a136 6
static void
uxa_unrealize_glyph_caches(ScreenPtr    pScreen,
			   unsigned int format)
{
    uxa_screen_t    *uxa_screen = uxa_get_screen(pScreen);
    int		    i;
d138 5
a142 19
    for (i = 0; i < UXA_NUM_GLYPH_CACHES; i++) {
	uxa_glyph_cache_t *cache = &uxa_screen->glyphCaches[i];
	
	if (cache->format != format)
	    continue;

	if (cache->picture) {
	    FreePicture ((pointer) cache->picture, (XID) 0);
	    cache->picture = NULL;
	}

	if (cache->hashEntries) {
	    xfree(cache->hashEntries);
	    cache->hashEntries = NULL;
	}
	
	if (cache->glyphs) {
	    xfree(cache->glyphs);
	    cache->glyphs = NULL;
a143 2
	cache->glyphCount = 0;
    }
d157 1
a157 3
static Bool
uxa_realize_glyph_caches(ScreenPtr    pScreen,
			 unsigned int format)
d159 20
a178 9
    uxa_screen_t    *uxa_screen = uxa_get_screen(pScreen);
    int		    depth = PIXMAN_FORMAT_DEPTH(format);
    PictFormatPtr   pPictFormat;
    PixmapPtr	    pPixmap;
    PicturePtr	    pPicture;
    CARD32          component_alpha;
    int		    height;
    int		    i;
    int		    error;
d180 36
a215 5
    pPictFormat = PictureMatchFormat(pScreen, depth, format);
    if (!pPictFormat)
	return FALSE;
    
    /* Compute the total vertical size needed for the format */
d217 6
a222 21
    height = 0;
    for (i = 0; i < UXA_NUM_GLYPH_CACHES; i++) {
	uxa_glyph_cache_t *cache = &uxa_screen->glyphCaches[i];
	int rows;

	if (cache->format != format)
	    continue;

	cache->yOffset = height;

	rows = (cache->size + cache->columns - 1) / cache->columns;
	height += rows * cache->glyphHeight;
    }

    /* Now allocate the pixmap and picture */
       
    pPixmap = (*pScreen->CreatePixmap) (pScreen,
					CACHE_PICTURE_WIDTH,
					height, depth, 0);
    if (!pPixmap)
	return FALSE;
d224 2
a225 4
    component_alpha = NeedsComponent(pPictFormat->format);
    pPicture = CreatePicture(0, &pPixmap->drawable, pPictFormat,
			     CPComponentAlpha, &component_alpha, serverClient,
			     &error);
d227 2
a228 1
    (*pScreen->DestroyPixmap) (pPixmap); /* picture holds a refcount */
d230 2
a231 2
    if (!pPicture)
	return FALSE;
d233 3
a235 27
    /* And store the picture in all the caches for the format */
    
    for (i = 0; i < UXA_NUM_GLYPH_CACHES; i++) {
	uxa_glyph_cache_t *cache = &uxa_screen->glyphCaches[i];
	int j;

	if (cache->format != format)
	    continue;

	cache->picture = pPicture;
	cache->picture->refcnt++;
	cache->hashEntries = xalloc(sizeof(int) * cache->hashSize);
	cache->glyphs = xalloc(sizeof(uxa_cached_glyph_t) * cache->size);
	cache->glyphCount = 0;

	if (!cache->hashEntries || !cache->glyphs)
	    goto bail;

	for (j = 0; j < cache->hashSize; j++)
	    cache->hashEntries[j] = -1;
	
	cache->evictionPosition = rand() % cache->size;
    }

    /* Each cache references the picture individually */
    FreePicture ((pointer) pPicture, (XID) 0);
    return TRUE;
d238 2
a239 2
    uxa_unrealize_glyph_caches(pScreen, format);
    return FALSE;
d242 1
a242 2
void
uxa_glyphs_fini (ScreenPtr pScreen)
d244 2
a245 2
    uxa_screen_t    *uxa_screen = uxa_get_screen(pScreen);
    int		    i;
d247 2
a248 2
    for (i = 0; i < UXA_NUM_GLYPH_CACHES; i++) {
	uxa_glyph_cache_t *cache = &uxa_screen->glyphCaches[i];
d250 3
a252 3
	if (cache->picture)
	    uxa_unrealize_glyph_caches(pScreen, cache->format);
    }
d256 1
a256 1
uxa_glyph_cache_hash_lookup(uxa_glyph_cache_t *cache, GlyphPtr pGlyph)
d258 8
a265 1
    int slot;
d267 5
a271 16
    slot = (*(CARD32 *) pGlyph->sha1) % cache->hashSize;
    
    while (TRUE) { /* hash table can never be full */
	int entryPos = cache->hashEntries[slot];
	if (entryPos == -1)
	    return -1;

	if (memcmp(pGlyph->sha1, cache->glyphs[entryPos].sha1, sizeof(pGlyph->sha1)) == 0){
	    return entryPos;
	}
	    
	slot--;
	if (slot < 0)
	    slot = cache->hashSize - 1;
    }
}
d273 4
a276 21
static void
uxa_glyph_cache_hash_insert(uxa_glyph_cache_t *cache,
			GlyphPtr         pGlyph,
			int              pos)
{
    int slot;

    memcpy(cache->glyphs[pos].sha1, pGlyph->sha1, sizeof(pGlyph->sha1));
    
    slot = (*(CARD32 *) pGlyph->sha1) % cache->hashSize;
    
    while (TRUE) { /* hash table can never be full */
	if (cache->hashEntries[slot] == -1) {
	    cache->hashEntries[slot] = pos;
	    return;
	}
	    
	slot--;
	if (slot < 0)
	    slot = cache->hashSize - 1;
    }
d280 1
a280 2
uxa_glyph_cache_hash_remove(uxa_glyph_cache_t *cache,
			int              pos)
d282 5
a286 2
    int slot;
    int emptiedSlot = -1;
d288 11
a298 1
    slot = (*(CARD32 *) cache->glyphs[pos].sha1) % cache->hashSize;
d300 52
a351 41
    while (TRUE) { /* hash table can never be full */
	int entryPos = cache->hashEntries[slot];
	
	if (entryPos == -1)
	    return;

	if (entryPos == pos) {
	    cache->hashEntries[slot] = -1;
	    emptiedSlot = slot;
	} else if (emptiedSlot != -1) {
	    /* See if we can move this entry into the emptied slot, we can't
	     * do that if if entry would have hashed between the current position
	     * and the emptied slot. (taking wrapping into account). Bad positions
	     * are:
	     *
	     * |   XXXXXXXXXX             |
	     *     i         j            
	     *                            
	     * |XXX                   XXXX|
	     *     j                  i
	     *
	     * i - slot, j - emptiedSlot
	     *
	     * (Knuth 6.4R)
	     */
	    
	    int entrySlot = (*(CARD32 *) cache->glyphs[entryPos].sha1) % cache->hashSize;

	    if (!((entrySlot >= slot && entrySlot < emptiedSlot) ||
		  (emptiedSlot < slot && (entrySlot < emptiedSlot || entrySlot >= slot)))) 
	    {
		cache->hashEntries[emptiedSlot] = entryPos;
		cache->hashEntries[slot] = -1;
		emptiedSlot = slot;
	    }
	}
	
	slot--;
	if (slot < 0)
	    slot = cache->hashSize - 1;
    }
d361 40
a400 9
uxa_glyph_cache_upload_glyph(ScreenPtr		    pScreen,
			     uxa_glyph_cache_t	    *cache,
			     int		    pos,
			     GlyphPtr		    pGlyph)
{
    PicturePtr	    pGlyphPicture = GlyphPicture(pGlyph)[pScreen->myNum];
    PixmapPtr	    pGlyphPixmap = (PixmapPtr)pGlyphPicture->pDrawable;
    PixmapPtr	    pCachePixmap = (PixmapPtr)cache->picture->pDrawable;
    GCPtr	    pGC;
d402 4
a405 3
    /* UploadToScreen only works if bpp match */
    if (pGlyphPixmap->drawable.bitsPerPixel != pCachePixmap->drawable.bitsPerPixel)
	return FALSE;
d407 1
a407 9
    pGC = GetScratchGC(pCachePixmap->drawable.depth, pScreen);
    ValidateGC(&pCachePixmap->drawable, pGC);
    (void) uxa_copy_area (&pGlyphPixmap->drawable,
			  &pCachePixmap->drawable,
			  pGC,
			  0, 0, pGlyph->info.width, pGlyph->info.height,
			  CACHE_X(pos), CACHE_Y(pos));
    FreeScratchGC (pGC);
    return TRUE;
d411 24
a434 34
uxa_glyph_cache_buffer_glyph(ScreenPtr		pScreen,
			     uxa_glyph_cache_t	*cache,
			     uxa_glyph_buffer_t *buffer,
			     GlyphPtr		pGlyph,
			     int		xGlyph,
			     int		yGlyph)
{
    uxa_composite_rect_t    *rect;
    int			    pos;
    
    if (buffer->source && buffer->source != cache->picture)
	return UXA_GLYPH_NEED_FLUSH;

    if (!cache->picture) {
	if (!uxa_realize_glyph_caches(pScreen, cache->format))
	    return UXA_GLYPH_FAIL;
    }

    DBG_GLYPH_CACHE(("(%d,%d,%s): buffering glyph %lx\n",
		     cache->glyphWidth, cache->glyphHeight, cache->format == PICT_a8 ? "A" : "ARGB",
		     (long)*(CARD32 *) pGlyph->sha1));
   
    pos = uxa_glyph_cache_hash_lookup(cache, pGlyph);
    if (pos != -1) {
	DBG_GLYPH_CACHE(("  found existing glyph at %d\n", pos));
    } else {
	if (cache->glyphCount < cache->size) {
	    /* Space remaining; we fill from the start */
	    pos = cache->glyphCount;
	    cache->glyphCount++;
	    DBG_GLYPH_CACHE(("  storing glyph in free space at %d\n", pos));

	    uxa_glyph_cache_hash_insert(cache, pGlyph, pos);

d436 35
a470 13
	    /* Need to evict an entry. We have to see if any glyphs
	     * already in the output buffer were at this position in
	     * the cache
	     */
	    
	    pos = cache->evictionPosition;
	    DBG_GLYPH_CACHE(("  evicting glyph at %d\n", pos));
	    if (buffer->count) {
		int x, y;
		int i;
		
		x = CACHE_X(pos);
		y = CACHE_Y(pos);
d472 2
a473 5
		for (i = 0; i < buffer->count; i++) {
		    if (buffer->rects[i].xSrc == x && buffer->rects[i].ySrc == y) {
			DBG_GLYPH_CACHE(("  must flush buffer\n"));
			return UXA_GLYPH_NEED_FLUSH;
		    }
a474 1
	    }
d476 16
a491 3
	    /* OK, we're all set, swap in the new glyph */
	    uxa_glyph_cache_hash_remove(cache, pos);
	    uxa_glyph_cache_hash_insert(cache, pGlyph, pos);
a492 2
	    /* And pick a new eviction position */
	    cache->evictionPosition = rand() % cache->size;
d495 11
a505 31
	/* Now actually upload the glyph into the cache picture; if
	 * we can't do it with UploadToScreen (because the glyph is
	 * offscreen, etc), we fall back to CompositePicture.
	 */
	if (!uxa_glyph_cache_upload_glyph(pScreen, cache, pos, pGlyph)) {
	    CompositePicture (PictOpSrc,
			      GlyphPicture(pGlyph)[pScreen->myNum],
			      None,
			      cache->picture,
			      0, 0,
			      0, 0,
			      CACHE_X(pos),
			      CACHE_Y(pos),
			      pGlyph->info.width,
			      pGlyph->info.height);
	}

    }
    

    buffer->source = cache->picture;
	    
    rect = &buffer->rects[buffer->count];
    rect->xSrc = CACHE_X(pos);
    rect->ySrc = CACHE_Y(pos);
    rect->xDst = xGlyph - pGlyph->info.x;
    rect->yDst = yGlyph - pGlyph->info.y;
    rect->width = pGlyph->info.width;
    rect->height = pGlyph->info.height;
	    
    buffer->count++;
d507 1
a507 1
    return UXA_GLYPH_SUCCESS;
d514 46
a559 54
uxa_buffer_glyph(ScreenPtr	    pScreen,
		 uxa_glyph_buffer_t *buffer,
		 GlyphPtr	    pGlyph,
		 int		    xGlyph,
		 int		    yGlyph)
{
    uxa_screen_t    *uxa_screen = uxa_get_screen(pScreen);
    unsigned int    format = (GlyphPicture(pGlyph)[pScreen->myNum])->format;
    int		    width = pGlyph->info.width;
    int		    height = pGlyph->info.height;
    uxa_composite_rect_t    *rect;
    PicturePtr	    source;
    int		     i;

    if (buffer->count == GLYPH_BUFFER_SIZE)
	return UXA_GLYPH_NEED_FLUSH;

    if (PICT_FORMAT_BPP(format) == 1)
	format = PICT_a8;
    
    for (i = 0; i < UXA_NUM_GLYPH_CACHES; i++) {
	uxa_glyph_cache_t *cache = &uxa_screen->glyphCaches[i];

	if (format == cache->format &&
	    width <= cache->glyphWidth &&
	    height <= cache->glyphHeight) {
	    uxa_glyph_cache_result_t result = uxa_glyph_cache_buffer_glyph(pScreen, &uxa_screen->glyphCaches[i],
									   buffer,
									   pGlyph, xGlyph, yGlyph);
	    switch (result) {
	    case UXA_GLYPH_FAIL:
		break;
	    case UXA_GLYPH_SUCCESS:
	    case UXA_GLYPH_NEED_FLUSH:
		return result;
	    }
	}
    }

    /* Couldn't find the glyph in the cache, use the glyph picture directly */

    source = GlyphPicture(pGlyph)[pScreen->myNum];
    if (buffer->source && buffer->source != source)
	return UXA_GLYPH_NEED_FLUSH;

    buffer->source = source;
    
    rect = &buffer->rects[buffer->count];
    rect->xSrc = 0;
    rect->ySrc = 0;
    rect->xDst = xGlyph - pGlyph->info.x;
    rect->yDst = yGlyph - pGlyph->info.y;
    rect->width = pGlyph->info.width;
    rect->height = pGlyph->info.height;
d561 1
a561 1
    buffer->count++;
d563 11
a573 1
    return UXA_GLYPH_SUCCESS;
d576 1
a576 3
static void
uxa_glyphs_to_mask(PicturePtr		pMask,
		   uxa_glyph_buffer_t	*buffer)
d578 5
a582 5
    uxa_composite_rects(PictOpAdd, buffer->source, pMask,
		      buffer->count, buffer->rects);
    
    buffer->count = 0;
    buffer->source = NULL;
d586 25
a610 30
uxa_glyphs_to_dst(CARD8			op,
		  PicturePtr		pSrc,
		  PicturePtr		pDst,
		  uxa_glyph_buffer_t	*buffer,
		  INT16			xSrc,
		  INT16			ySrc,
		  INT16			xDst,
		  INT16			yDst)
{
    int i;

    for (i = 0; i < buffer->count; i++) {
	uxa_composite_rect_t	*rect = &buffer->rects[i];
	
	CompositePicture (op,
			  pSrc,
			  buffer->source,
			  pDst,
			  xSrc + rect->xDst - xDst,
			  ySrc + rect->yDst - yDst,
			  rect->xSrc,
			  rect->ySrc,
			  rect->xDst,
			  rect->yDst,
			  rect->width,
			  rect->height);
    }
    
    buffer->count = 0;
    buffer->source = NULL;
d615 44
a658 47
uxa_glyph_extents (int		nlist,
	      GlyphListPtr	list,
	      GlyphPtr	       *glyphs,
	      BoxPtr		extents)
{
    int		x1, x2, y1, y2;
    int		n;
    GlyphPtr	glyph;
    int		x, y;
    
    x = 0;
    y = 0;
    extents->x1 = MAXSHORT;
    extents->x2 = MINSHORT;
    extents->y1 = MAXSHORT;
    extents->y2 = MINSHORT;
    while (nlist--)
    {
	x += list->xOff;
	y += list->yOff;
	n = list->len;
	list++;
	while (n--)
	{
	    glyph = *glyphs++;
	    x1 = x - glyph->info.x;
	    if (x1 < MINSHORT)
		x1 = MINSHORT;
	    y1 = y - glyph->info.y;
	    if (y1 < MINSHORT)
		y1 = MINSHORT;
	    x2 = x1 + glyph->info.width;
	    if (x2 > MAXSHORT)
		x2 = MAXSHORT;
	    y2 = y1 + glyph->info.height;
	    if (y2 > MAXSHORT)
		y2 = MAXSHORT;
	    if (x1 < extents->x1)
		extents->x1 = x1;
	    if (x2 > extents->x2)
		extents->x2 = x2;
	    if (y1 < extents->y1)
		extents->y1 = y1;
	    if (y2 > extents->y2)
		extents->y2 = y2;
	    x += glyph->info.xOff;
	    y += glyph->info.yOff;
a659 1
    }
d667 1
a667 1
uxa_glyphs_intersect(int nlist, GlyphListPtr list, GlyphPtr *glyphs)
d669 65
a733 66
    int x1, x2, y1, y2;
    int n;
    GlyphPtr glyph;
    int x, y;
    BoxRec extents;
    Bool first = TRUE;

    x = 0;
    y = 0;
    extents.x1 = 0;
    extents.y1 = 0;
    extents.x2 = 0;
    extents.y2 = 0;
    while (nlist--) {
       x += list->xOff;
       y += list->yOff;
       n = list->len;
       list++;
       while (n--) {
           glyph = *glyphs++;

           if (glyph->info.width == 0 || glyph->info.height == 0) {
               x += glyph->info.xOff;
               y += glyph->info.yOff;
               continue;
           }

           x1 = x - glyph->info.x;
           if (x1 < MINSHORT)
               x1 = MINSHORT;
           y1 = y - glyph->info.y;
           if (y1 < MINSHORT)
               y1 = MINSHORT;
           x2 = x1 + glyph->info.width;
           if (x2 > MAXSHORT)
               x2 = MAXSHORT;
           y2 = y1 + glyph->info.height;
           if (y2 > MAXSHORT)
               y2 = MAXSHORT;

           if (first) {
               extents.x1 = x1;
               extents.y1 = y1;
               extents.x2 = x2;
               extents.y2 = y2;
               first = FALSE;
           } else {
               if (x1 < extents.x2 && x2 > extents.x1 &&
                   y1 < extents.y2 && y2 > extents.y1)
               {
                   return TRUE;
               }

               if (x1 < extents.x1)
                  extents.x1 = x1;
               if (x2 > extents.x2)
                   extents.x2 = x2;
               if (y1 < extents.y1)
                   extents.y1 = y1;
               if (y2 > extents.y2)
                   extents.y2 = y2;
           }
           x += glyph->info.xOff;
           y += glyph->info.yOff;
       }
    }
d735 1
a735 1
    return FALSE;
d739 3
a741 3
uxa_glyphs (CARD8 	 op,
	   PicturePtr	 pSrc,
	   PicturePtr	 pDst,
d743 119
a861 108
	   INT16	 xSrc,
	   INT16	 ySrc,
	   int		 nlist,
	   GlyphListPtr	 list,
	   GlyphPtr	*glyphs)
{
    PicturePtr	pPicture;
    PixmapPtr   pMaskPixmap = 0;
    PicturePtr  pMask;
    ScreenPtr   pScreen = pDst->pDrawable->pScreen;
    int		width = 0, height = 0;
    int		x, y;
    int		xDst = list->xOff, yDst = list->yOff;
    int		n;
    GlyphPtr	glyph;
    int		error;
    BoxRec	extents = {0, 0, 0, 0};
    CARD32	component_alpha;
    uxa_glyph_buffer_t buffer;

    /* If we don't have a mask format but all the glyphs have the same format
     * and don't intersect, use the glyph format as mask format for the full
     * benefits of the glyph cache.
     */
    if (!maskFormat) {
       Bool sameFormat = TRUE;
       int i;

       maskFormat = list[0].format;

       for (i = 0; i < nlist; i++) {
           if (maskFormat->format != list[i].format->format) {
               sameFormat = FALSE;
               break;
           }
       }

       if (!sameFormat || (maskFormat->depth != 1 &&
			   uxa_glyphs_intersect(nlist, list, glyphs))) {
	   maskFormat = NULL;
       }
    }

    if (maskFormat)
    {
	GCPtr	    pGC;
	xRectangle  rect;

	uxa_glyph_extents (nlist, list, glyphs, &extents);

	if (extents.x2 <= extents.x1 || extents.y2 <= extents.y1)
	    return;
	width = extents.x2 - extents.x1;
	height = extents.y2 - extents.y1;

	if (maskFormat->depth == 1) {
	    PictFormatPtr a8Format = PictureMatchFormat (pScreen, 8, PICT_a8);

	    if (a8Format)
		maskFormat = a8Format;
	}

	pMaskPixmap = (*pScreen->CreatePixmap) (pScreen, width, height,
						maskFormat->depth,
						CREATE_PIXMAP_USAGE_SCRATCH);
	if (!pMaskPixmap)
	    return;
	component_alpha = NeedsComponent(maskFormat->format);
	pMask = CreatePicture (0, &pMaskPixmap->drawable,
			       maskFormat, CPComponentAlpha, &component_alpha,
			       serverClient, &error);
	if (!pMask)
	{
	    (*pScreen->DestroyPixmap) (pMaskPixmap);
	    return;
	}
	pGC = GetScratchGC (pMaskPixmap->drawable.depth, pScreen);
	ValidateGC (&pMaskPixmap->drawable, pGC);
	rect.x = 0;
	rect.y = 0;
	rect.width = width;
	rect.height = height;
	(*pGC->ops->PolyFillRect) (&pMaskPixmap->drawable, pGC, 1, &rect);
	FreeScratchGC (pGC);
	x = -extents.x1;
	y = -extents.y1;
    }
    else
    {
	pMask = pDst;
	x = 0;
	y = 0;
    }
    buffer.count = 0;
    buffer.source = NULL;
    while (nlist--)
    {
	x += list->xOff;
	y += list->yOff;
	n = list->len;
	while (n--)
	{
	    glyph = *glyphs++;
	    pPicture = GlyphPicture (glyph)[pScreen->myNum];

	    if (glyph->info.width > 0 && glyph->info.height > 0 &&
		uxa_buffer_glyph(pScreen, &buffer, glyph, x, y) == UXA_GLYPH_NEED_FLUSH)
	    {
d863 1
a863 1
		    uxa_glyphs_to_mask(pMask, &buffer);
d865 3
a867 5
		    uxa_glyphs_to_dst(op, pSrc, pDst, &buffer,
				   xSrc, ySrc, xDst, yDst);

		uxa_buffer_glyph(pScreen, &buffer, glyph, x, y);
	    }
d869 11
a879 2
	    x += glyph->info.xOff;
	    y += glyph->info.yOff;
a880 27
	list++;
    }

    if (buffer.count) {
	if (maskFormat)
	    uxa_glyphs_to_mask(pMask, &buffer);
	else
	    uxa_glyphs_to_dst(op, pSrc, pDst, &buffer,
			      xSrc, ySrc, xDst, yDst);
    }

    if (maskFormat)
    {
	x = extents.x1;
	y = extents.y1;
	CompositePicture (op,
			  pSrc,
			  pMask,
			  pDst,
			  xSrc + x - xDst,
			  ySrc + y - yDst,
			  0, 0,
			  x, y,
			  width, height);
	FreePicture ((pointer) pMask, (XID) 0);
	(*pScreen->DestroyPixmap) (pMaskPixmap);
    }
a881 2

#endif /* SERVER_1_5 */
@

