head	1.7;
access;
symbols
	OPENBSD_6_1:1.7.0.8
	OPENBSD_6_1_BASE:1.7
	OPENBSD_6_0:1.7.0.6
	OPENBSD_6_0_BASE:1.7
	OPENBSD_5_9:1.7.0.4
	OPENBSD_5_9_BASE:1.7
	OPENBSD_5_8:1.7.0.2
	OPENBSD_5_8_BASE:1.7
	OPENBSD_5_7:1.6.0.6
	OPENBSD_5_7_BASE:1.6
	OPENBSD_5_6:1.6.0.4
	OPENBSD_5_6_BASE:1.6
	OPENBSD_5_5:1.6.0.2
	OPENBSD_5_5_BASE:1.6
	OPENBSD_5_4:1.5.0.6
	OPENBSD_5_4_BASE:1.5
	OPENBSD_5_3:1.5.0.4
	OPENBSD_5_3_BASE:1.5
	OPENBSD_5_2:1.5.0.2
	OPENBSD_5_2_BASE:1.5
	OPENBSD_5_1_BASE:1.3
	OPENBSD_5_1:1.3.0.2
	OPENBSD_5_0:1.1.0.8
	OPENBSD_5_0_BASE:1.1
	OPENBSD_4_9:1.1.0.4
	OPENBSD_4_9_BASE:1.1
	OPENBSD_4_8:1.1.0.6
	OPENBSD_4_8_BASE:1.1
	OPENBSD_4_7:1.1.0.2
	OPENBSD_4_7_BASE:1.1;
locks; strict;
comment	@ * @;


1.7
date	2015.04.14.19.55.49;	author matthieu;	state Exp;
branches;
next	1.6;
commitid	cZqnMrCmViqubI1u;

1.6
date	2013.08.16.17.04.07;	author matthieu;	state Exp;
branches;
next	1.5;

1.5
date	2012.06.07.20.55.34;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2012.03.04.16.01.20;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2012.02.06.22.53.12;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2012.01.25.21.33.35;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2009.08.25.18.51.45;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.7
log
@Update to xf86-video-ati 7.5.0. Discussed with jsg@@
@
text
@/*
 * Copyright 2008 Advanced Micro Devices, Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice (including the next
 * paragraph) shall be included in all copies or substantial portions of the
 * Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 * Authors: Alex Deucher <alexander.deucher@@amd.com>
 *          Matthias Hopf <mhopf@@suse.de>
 */
#ifdef HAVE_CONFIG_H
#include "config.h"
#endif

#include "xf86.h"

#include <errno.h>

#include "radeon.h"
#include "r600_shader.h"
#include "radeon_reg.h"
#include "r600_reg.h"
#include "r600_state.h"

#include "radeon_vbo.h"
#include "radeon_exa_shared.h"

static const uint32_t R600_ROP[16] = {
    RADEON_ROP3_ZERO, /* GXclear        */
    RADEON_ROP3_DSa,  /* Gxand          */
    RADEON_ROP3_SDna, /* GXandReverse   */
    RADEON_ROP3_S,    /* GXcopy         */
    RADEON_ROP3_DSna, /* GXandInverted  */
    RADEON_ROP3_D,    /* GXnoop         */
    RADEON_ROP3_DSx,  /* GXxor          */
    RADEON_ROP3_DSo,  /* GXor           */
    RADEON_ROP3_DSon, /* GXnor          */
    RADEON_ROP3_DSxn, /* GXequiv        */
    RADEON_ROP3_Dn,   /* GXinvert       */
    RADEON_ROP3_SDno, /* GXorReverse    */
    RADEON_ROP3_Sn,   /* GXcopyInverted */
    RADEON_ROP3_DSno, /* GXorInverted   */
    RADEON_ROP3_DSan, /* GXnand         */
    RADEON_ROP3_ONE,  /* GXset          */
};

/* we try and batch operations together under KMS -
   but it doesn't work yet without misrendering */
#define KMS_MULTI_OP 1

/* Flush the indirect buffer to the kernel for submission to the card */
void R600CPFlushIndirect(ScrnInfoPtr pScrn)
{
    radeon_cs_flush_indirect(pScrn);
}

void R600IBDiscard(ScrnInfoPtr pScrn)
{
    radeon_ib_discard(pScrn);
}

void
r600_wait_3d_idle_clean(ScrnInfoPtr pScrn)
{
    RADEONInfoPtr info = RADEONPTR(pScrn);

    //flush caches, don't generate timestamp
    BEGIN_BATCH(5);
    PACK3(IT_EVENT_WRITE, 1);
    E32(CACHE_FLUSH_AND_INV_EVENT);
    // wait for 3D idle clean
    EREG(WAIT_UNTIL,                          (WAIT_3D_IDLE_bit |
						   WAIT_3D_IDLECLEAN_bit));
    END_BATCH();
}

void
r600_wait_3d_idle(ScrnInfoPtr pScrn)
{
    RADEONInfoPtr info = RADEONPTR(pScrn);

    BEGIN_BATCH(3);
    EREG(WAIT_UNTIL,                          WAIT_3D_IDLE_bit);
    END_BATCH();
}

void
r600_start_3d(ScrnInfoPtr pScrn)
{
    RADEONInfoPtr info = RADEONPTR(pScrn);

    if (info->ChipFamily < CHIP_FAMILY_RV770) {
	BEGIN_BATCH(5);
	PACK3(IT_START_3D_CMDBUF, 1);
	E32(0);
    } else
	BEGIN_BATCH(3);

    PACK3(IT_CONTEXT_CONTROL, 2);
    E32(0x80000000);
    E32(0x80000000);
    END_BATCH();

}

/*
 * Setup of functional groups
 */

// asic stack/thread/gpr limits - need to query the drm
static void
r600_sq_setup(ScrnInfoPtr pScrn, sq_config_t *sq_conf)
{
    uint32_t sq_config, sq_gpr_resource_mgmt_1, sq_gpr_resource_mgmt_2;
    uint32_t sq_thread_resource_mgmt, sq_stack_resource_mgmt_1, sq_stack_resource_mgmt_2;
    RADEONInfoPtr info = RADEONPTR(pScrn);

    if ((info->ChipFamily == CHIP_FAMILY_RV610) ||
	(info->ChipFamily == CHIP_FAMILY_RV620) ||
	(info->ChipFamily == CHIP_FAMILY_RS780) ||
	(info->ChipFamily == CHIP_FAMILY_RS880) ||
	(info->ChipFamily == CHIP_FAMILY_RV710))
	sq_config = 0;						// no VC
    else
	sq_config = VC_ENABLE_bit;

    sq_config |= (DX9_CONSTS_bit |
		  ALU_INST_PREFER_VECTOR_bit |
		  (sq_conf->ps_prio << PS_PRIO_shift) |
		  (sq_conf->vs_prio << VS_PRIO_shift) |
		  (sq_conf->gs_prio << GS_PRIO_shift) |
		  (sq_conf->es_prio << ES_PRIO_shift));

    sq_gpr_resource_mgmt_1 = ((sq_conf->num_ps_gprs << NUM_PS_GPRS_shift) |
			      (sq_conf->num_vs_gprs << NUM_VS_GPRS_shift) |
			      (sq_conf->num_temp_gprs << NUM_CLAUSE_TEMP_GPRS_shift));
    sq_gpr_resource_mgmt_2 = ((sq_conf->num_gs_gprs << NUM_GS_GPRS_shift) |
			      (sq_conf->num_es_gprs << NUM_ES_GPRS_shift));

    sq_thread_resource_mgmt = ((sq_conf->num_ps_threads << NUM_PS_THREADS_shift) |
			       (sq_conf->num_vs_threads << NUM_VS_THREADS_shift) |
			       (sq_conf->num_gs_threads << NUM_GS_THREADS_shift) |
			       (sq_conf->num_es_threads << NUM_ES_THREADS_shift));

    sq_stack_resource_mgmt_1 = ((sq_conf->num_ps_stack_entries << NUM_PS_STACK_ENTRIES_shift) |
				(sq_conf->num_vs_stack_entries << NUM_VS_STACK_ENTRIES_shift));

    sq_stack_resource_mgmt_2 = ((sq_conf->num_gs_stack_entries << NUM_GS_STACK_ENTRIES_shift) |
				(sq_conf->num_es_stack_entries << NUM_ES_STACK_ENTRIES_shift));

    BEGIN_BATCH(8);
    PACK0(SQ_CONFIG, 6);
    E32(sq_config);
    E32(sq_gpr_resource_mgmt_1);
    E32(sq_gpr_resource_mgmt_2);
    E32(sq_thread_resource_mgmt);
    E32(sq_stack_resource_mgmt_1);
    E32(sq_stack_resource_mgmt_2);
    END_BATCH();
}

void
r600_set_render_target(ScrnInfoPtr pScrn, cb_config_t *cb_conf, uint32_t domain)
{
    uint32_t cb_color_info, cb_color_control;
    unsigned pitch, slice, h, array_mode;
    RADEONInfoPtr info = RADEONPTR(pScrn);


    if (cb_conf->surface) {
	switch (cb_conf->surface->level[0].mode) {
	case RADEON_SURF_MODE_1D:
		array_mode = 2;
		break;
	case RADEON_SURF_MODE_2D:
		array_mode = 4;
		break;
	default:
		array_mode = 0;
		break;
	}
	pitch = (cb_conf->surface->level[0].nblk_x >> 3) - 1;
	slice = ((cb_conf->surface->level[0].nblk_x * cb_conf->surface->level[0].nblk_y) / 64) - 1;
    } else
    {
	array_mode = cb_conf->array_mode;
	pitch = (cb_conf->w / 8) - 1;
	h = RADEON_ALIGN(cb_conf->h, 8);
	slice = ((cb_conf->w * h) / 64) - 1;
    }

    cb_color_info = ((cb_conf->endian      << ENDIAN_shift)				|
		     (cb_conf->format      << CB_COLOR0_INFO__FORMAT_shift)		|
		     (array_mode  << CB_COLOR0_INFO__ARRAY_MODE_shift)		|
		     (cb_conf->number_type << NUMBER_TYPE_shift)			|
		     (cb_conf->comp_swap   << COMP_SWAP_shift)				|
		     (cb_conf->tile_mode   << CB_COLOR0_INFO__TILE_MODE_shift));
    if (cb_conf->read_size)
	cb_color_info |= CB_COLOR0_INFO__READ_SIZE_bit;
    if (cb_conf->blend_clamp)
	cb_color_info |= BLEND_CLAMP_bit;
    if (cb_conf->clear_color)
	cb_color_info |= CLEAR_COLOR_bit;
    if (cb_conf->blend_bypass)
	cb_color_info |= BLEND_BYPASS_bit;
    if (cb_conf->blend_float32)
	cb_color_info |= BLEND_FLOAT32_bit;
    if (cb_conf->simple_float)
	cb_color_info |= SIMPLE_FLOAT_bit;
    if (cb_conf->round_mode)
	cb_color_info |= CB_COLOR0_INFO__ROUND_MODE_bit;
    if (cb_conf->tile_compact)
	cb_color_info |= TILE_COMPACT_bit;
    if (cb_conf->source_format)
	cb_color_info |= SOURCE_FORMAT_bit;

    BEGIN_BATCH(3 + 2);
    EREG((CB_COLOR0_BASE + (4 * cb_conf->id)), (cb_conf->base >> 8));
    RELOC_BATCH(cb_conf->bo, 0, domain);
    END_BATCH();

    // rv6xx workaround
    if ((info->ChipFamily > CHIP_FAMILY_R600) &&
        (info->ChipFamily < CHIP_FAMILY_RV770)) {
        BEGIN_BATCH(2);
        PACK3(IT_SURFACE_BASE_UPDATE, 1);
        E32((2 << cb_conf->id));
        END_BATCH();
    }
    /* Set CMASK & TILE buffer to the offset of color buffer as
     * we don't use those this shouldn't cause any issue and we
     * then have a valid cmd stream
     */
    BEGIN_BATCH(3 + 2);
    EREG((CB_COLOR0_TILE + (4 * cb_conf->id)), (0     >> 8));	// CMASK per-tile data base/256
    RELOC_BATCH(cb_conf->bo, 0, domain);
    END_BATCH();
    BEGIN_BATCH(3 + 2);
    EREG((CB_COLOR0_FRAG + (4 * cb_conf->id)), (0     >> 8));	// FMASK per-tile data base/256
    RELOC_BATCH(cb_conf->bo, 0, domain);
    END_BATCH();
    BEGIN_BATCH(9);
    // pitch only for ARRAY_LINEAR_GENERAL, other tiling modes require addrlib
    EREG((CB_COLOR0_SIZE + (4 * cb_conf->id)), ((pitch << PITCH_TILE_MAX_shift)	|
						    (slice << SLICE_TILE_MAX_shift)));
    EREG((CB_COLOR0_VIEW + (4 * cb_conf->id)), ((0    << SLICE_START_shift)		|
						    (0    << SLICE_MAX_shift)));
    EREG((CB_COLOR0_MASK + (4 * cb_conf->id)), ((0    << CMASK_BLOCK_MAX_shift)	|
						    (0    << FMASK_TILE_MAX_shift)));
    END_BATCH();

    BEGIN_BATCH(3 + 2);
    EREG((CB_COLOR0_INFO + (4 * cb_conf->id)), cb_color_info);
    RELOC_BATCH(cb_conf->bo, 0, domain);
    END_BATCH();

    BEGIN_BATCH(9);
    EREG(CB_TARGET_MASK,          (cb_conf->pmask << TARGET0_ENABLE_shift));
    cb_color_control = R600_ROP[cb_conf->rop] |
	(cb_conf->blend_enable << TARGET_BLEND_ENABLE_shift);
    if (info->ChipFamily == CHIP_FAMILY_R600) {
	/* no per-MRT blend on R600 */
	EREG(CB_COLOR_CONTROL,    cb_color_control);
	EREG(CB_BLEND_CONTROL,    cb_conf->blendcntl);
    } else {
	if (cb_conf->blend_enable)
	    cb_color_control |= PER_MRT_BLEND_bit;
	EREG(CB_COLOR_CONTROL,    cb_color_control);
	EREG(CB_BLEND0_CONTROL,   cb_conf->blendcntl);
    }
    END_BATCH();
}

static void
r600_cp_set_surface_sync(ScrnInfoPtr pScrn, uint32_t sync_type,
			 uint32_t size, uint64_t mc_addr,
			 struct radeon_bo *bo, uint32_t rdomains, uint32_t wdomain)
{
    RADEONInfoPtr info = RADEONPTR(pScrn);
    uint32_t cp_coher_size;
    if (size == 0xffffffff)
	cp_coher_size = 0xffffffff;
    else
	cp_coher_size = ((size + 255) >> 8);

    BEGIN_BATCH(5 + 2);
    PACK3(IT_SURFACE_SYNC, 4);
    E32(sync_type);
    E32(cp_coher_size);
    E32((mc_addr >> 8));
    E32(10); /* poll interval */
    RELOC_BATCH(bo, rdomains, wdomain);
    END_BATCH();
}

/* inserts a wait for vline in the command stream */
void
r600_cp_wait_vline_sync(ScrnInfoPtr pScrn, PixmapPtr pPix,
			xf86CrtcPtr crtc, int start, int stop)
{
    RADEONInfoPtr  info = RADEONPTR(pScrn);
    drmmode_crtc_private_ptr drmmode_crtc;

    if (!crtc)
        return;

    if (!crtc->enabled)
        return;

    if (pPix != pScrn->pScreen->GetScreenPixmap(pScrn->pScreen))
        return;

    start = max(start, crtc->y);
    stop = min(stop, crtc->y + crtc->mode.VDisplay);

    if (start >= stop)
        return;

    drmmode_crtc = crtc->driver_private;

    BEGIN_BATCH(11);
    /* set the VLINE range */
    EREG(AVIVO_D1MODE_VLINE_START_END, /* this is just a marker */
	 (start << AVIVO_D1MODE_VLINE_START_SHIFT) |
	 (stop << AVIVO_D1MODE_VLINE_END_SHIFT));

    /* tell the CP to poll the VLINE state register */
    PACK3(IT_WAIT_REG_MEM, 6);
    E32(IT_WAIT_REG | IT_WAIT_EQ);
    E32(IT_WAIT_ADDR(AVIVO_D1MODE_VLINE_STATUS));
    E32(0);
    E32(0);                          // Ref value
    E32(AVIVO_D1MODE_VLINE_STAT);    // Mask
    E32(10);                         // Wait interval
    /* add crtc reloc */
    PACK3(IT_NOP, 1);
    E32(drmmode_crtc->mode_crtc->crtc_id);
    END_BATCH();
}

void
r600_set_spi(ScrnInfoPtr pScrn, int vs_export_count, int num_interp)
{
    RADEONInfoPtr info = RADEONPTR(pScrn);

    BEGIN_BATCH(8);
    /* Interpolator setup */
    EREG(SPI_VS_OUT_CONFIG, (vs_export_count << VS_EXPORT_COUNT_shift));
    PACK0(SPI_PS_IN_CONTROL_0, 3);
    E32((num_interp << NUM_INTERP_shift));
    E32(0);
    E32(0);
    END_BATCH();
}

void
r600_fs_setup(ScrnInfoPtr pScrn, shader_config_t *fs_conf, uint32_t domain)
{
    RADEONInfoPtr info = RADEONPTR(pScrn);
    uint32_t sq_pgm_resources;

    sq_pgm_resources = ((fs_conf->num_gprs << NUM_GPRS_shift) |
			(fs_conf->stack_size << STACK_SIZE_shift));

    if (fs_conf->dx10_clamp)
	sq_pgm_resources |= SQ_PGM_RESOURCES_FS__DX10_CLAMP_bit;

    BEGIN_BATCH(3 + 2);
    EREG(SQ_PGM_START_FS, fs_conf->shader_addr >> 8);
    RELOC_BATCH(fs_conf->bo, domain, 0);
    END_BATCH();

    BEGIN_BATCH(6);
    EREG(SQ_PGM_RESOURCES_FS, sq_pgm_resources);
    EREG(SQ_PGM_CF_OFFSET_FS, 0);
    END_BATCH();
}

void
r600_vs_setup(ScrnInfoPtr pScrn, shader_config_t *vs_conf, uint32_t domain)
{
    RADEONInfoPtr info = RADEONPTR(pScrn);
    uint32_t sq_pgm_resources;

    sq_pgm_resources = ((vs_conf->num_gprs << NUM_GPRS_shift) |
			(vs_conf->stack_size << STACK_SIZE_shift));

    if (vs_conf->dx10_clamp)
	sq_pgm_resources |= SQ_PGM_RESOURCES_VS__DX10_CLAMP_bit;
    if (vs_conf->fetch_cache_lines)
	sq_pgm_resources |= (vs_conf->fetch_cache_lines << FETCH_CACHE_LINES_shift);
    if (vs_conf->uncached_first_inst)
	sq_pgm_resources |= UNCACHED_FIRST_INST_bit;

    /* flush SQ cache */
    r600_cp_set_surface_sync(pScrn, SH_ACTION_ENA_bit,
			     vs_conf->shader_size, vs_conf->shader_addr,
			     vs_conf->bo, domain, 0);

    BEGIN_BATCH(3 + 2);
    EREG(SQ_PGM_START_VS, vs_conf->shader_addr >> 8);
    RELOC_BATCH(vs_conf->bo, domain, 0);
    END_BATCH();

    BEGIN_BATCH(6);
    EREG(SQ_PGM_RESOURCES_VS, sq_pgm_resources);
    EREG(SQ_PGM_CF_OFFSET_VS, 0);
    END_BATCH();
}

void
r600_ps_setup(ScrnInfoPtr pScrn, shader_config_t *ps_conf, uint32_t domain)
{
    RADEONInfoPtr info = RADEONPTR(pScrn);
    uint32_t sq_pgm_resources;

    sq_pgm_resources = ((ps_conf->num_gprs << NUM_GPRS_shift) |
			(ps_conf->stack_size << STACK_SIZE_shift));

    if (ps_conf->dx10_clamp)
	sq_pgm_resources |= SQ_PGM_RESOURCES_PS__DX10_CLAMP_bit;
    if (ps_conf->fetch_cache_lines)
	sq_pgm_resources |= (ps_conf->fetch_cache_lines << FETCH_CACHE_LINES_shift);
    if (ps_conf->uncached_first_inst)
	sq_pgm_resources |= UNCACHED_FIRST_INST_bit;
    if (ps_conf->clamp_consts)
	sq_pgm_resources |= CLAMP_CONSTS_bit;

    /* flush SQ cache */
    r600_cp_set_surface_sync(pScrn, SH_ACTION_ENA_bit,
			     ps_conf->shader_size, ps_conf->shader_addr,
			     ps_conf->bo, domain, 0);

    BEGIN_BATCH(3 + 2);
    EREG(SQ_PGM_START_PS, ps_conf->shader_addr >> 8);
    RELOC_BATCH(ps_conf->bo, domain, 0);
    END_BATCH();

    BEGIN_BATCH(9);
    EREG(SQ_PGM_RESOURCES_PS, sq_pgm_resources);
    EREG(SQ_PGM_EXPORTS_PS, ps_conf->export_mode);
    EREG(SQ_PGM_CF_OFFSET_PS, 0);
    END_BATCH();
}

void
r600_set_alu_consts(ScrnInfoPtr pScrn, int offset, int count, float *const_buf)
{
    RADEONInfoPtr info = RADEONPTR(pScrn);
    int i;
    const int countreg = count * (SQ_ALU_CONSTANT_offset >> 2);

    BEGIN_BATCH(2 + countreg);
    PACK0(SQ_ALU_CONSTANT + offset * SQ_ALU_CONSTANT_offset, countreg);
    for (i = 0; i < countreg; i++)
	EFLOAT(const_buf[i]);
    END_BATCH();
}

void
r600_set_bool_consts(ScrnInfoPtr pScrn, int offset, uint32_t val)
{
    RADEONInfoPtr info = RADEONPTR(pScrn);
    /* bool register order is: ps, vs, gs; one register each
     * 1 bits per bool; 32 bools each for ps, vs, gs.
     */
    BEGIN_BATCH(3);
    EREG(SQ_BOOL_CONST + offset * SQ_BOOL_CONST_offset, val);
    END_BATCH();
}

static void
r600_set_vtx_resource(ScrnInfoPtr pScrn, vtx_resource_t *res, uint32_t domain)
{
    RADEONInfoPtr info = RADEONPTR(pScrn);
    struct radeon_accel_state *accel_state = info->accel_state;
    uint32_t sq_vtx_constant_word2;

    sq_vtx_constant_word2 = ((((res->vb_addr) >> 32) & BASE_ADDRESS_HI_mask) |
			     ((res->vtx_size_dw << 2) << SQ_VTX_CONSTANT_WORD2_0__STRIDE_shift) |
			     (res->format << SQ_VTX_CONSTANT_WORD2_0__DATA_FORMAT_shift) |
			     (res->num_format_all << SQ_VTX_CONSTANT_WORD2_0__NUM_FORMAT_ALL_shift) |
			     (res->endian << SQ_VTX_CONSTANT_WORD2_0__ENDIAN_SWAP_shift));
    if (res->clamp_x)
	    sq_vtx_constant_word2 |= SQ_VTX_CONSTANT_WORD2_0__CLAMP_X_bit;

    if (res->format_comp_all)
	    sq_vtx_constant_word2 |= SQ_VTX_CONSTANT_WORD2_0__FORMAT_COMP_ALL_bit;

    if (res->srf_mode_all)
	    sq_vtx_constant_word2 |= SQ_VTX_CONSTANT_WORD2_0__SRF_MODE_ALL_bit;

    /* flush vertex cache */
    if ((info->ChipFamily == CHIP_FAMILY_RV610) ||
	(info->ChipFamily == CHIP_FAMILY_RV620) ||
	(info->ChipFamily == CHIP_FAMILY_RS780) ||
	(info->ChipFamily == CHIP_FAMILY_RS880) ||
	(info->ChipFamily == CHIP_FAMILY_RV710))
	r600_cp_set_surface_sync(pScrn, TC_ACTION_ENA_bit,
				 accel_state->vbo.vb_offset, 0,
				 res->bo,
				 domain, 0);
    else
	r600_cp_set_surface_sync(pScrn, VC_ACTION_ENA_bit,
				 accel_state->vbo.vb_offset, 0,
				 res->bo,
				 domain, 0);

    BEGIN_BATCH(9 + 2);
    PACK0(SQ_VTX_RESOURCE + res->id * SQ_VTX_RESOURCE_offset, 7);
    E32(res->vb_addr & 0xffffffff);				// 0: BASE_ADDRESS
    E32((res->vtx_num_entries << 2) - 1);			// 1: SIZE
    E32(sq_vtx_constant_word2);	// 2: BASE_HI, STRIDE, CLAMP, FORMAT, ENDIAN
    E32(res->mem_req_size << MEM_REQUEST_SIZE_shift);		// 3: MEM_REQUEST_SIZE ?!?
    E32(0);							// 4: n/a
    E32(0);							// 5: n/a
    E32(SQ_TEX_VTX_VALID_BUFFER << SQ_VTX_CONSTANT_WORD6_0__TYPE_shift);	// 6: TYPE
    RELOC_BATCH(res->bo, domain, 0);
    END_BATCH();
}

void
r600_set_tex_resource(ScrnInfoPtr pScrn, tex_resource_t *tex_res, uint32_t domain)
{
    RADEONInfoPtr info = RADEONPTR(pScrn);
    uint32_t sq_tex_resource_word0, sq_tex_resource_word1, sq_tex_resource_word4;
    uint32_t sq_tex_resource_word5, sq_tex_resource_word6;
    uint32_t array_mode, pitch;

    if (tex_res->surface) {
	switch (tex_res->surface->level[0].mode) {
	case RADEON_SURF_MODE_1D:
		array_mode = 2;
		break;
	case RADEON_SURF_MODE_2D:
		array_mode = 4;
		break;
	default:
		array_mode = 0;
		break;
	}
	pitch = tex_res->surface->level[0].nblk_x >> 3;
    } else
    {
	array_mode = tex_res->tile_mode;
	pitch = (tex_res->pitch + 7) >> 3;
    }

    sq_tex_resource_word0 = ((tex_res->dim << DIM_shift) |
		     (array_mode << SQ_TEX_RESOURCE_WORD0_0__TILE_MODE_shift));

    if (tex_res->w)
	sq_tex_resource_word0 |= (((pitch - 1) << PITCH_shift) |
				  ((tex_res->w - 1) << TEX_WIDTH_shift));

    if (tex_res->tile_type)
	sq_tex_resource_word0 |= TILE_TYPE_bit;

    sq_tex_resource_word1 = (tex_res->format << SQ_TEX_RESOURCE_WORD1_0__DATA_FORMAT_shift);

    if (tex_res->h)
	sq_tex_resource_word1 |= ((tex_res->h - 1) << TEX_HEIGHT_shift);
    if (tex_res->depth)
	sq_tex_resource_word1 |= ((tex_res->depth - 1) << TEX_DEPTH_shift);

    sq_tex_resource_word4 = ((tex_res->format_comp_x << FORMAT_COMP_X_shift) |
			     (tex_res->format_comp_y << FORMAT_COMP_Y_shift) |
			     (tex_res->format_comp_z << FORMAT_COMP_Z_shift) |
			     (tex_res->format_comp_w << FORMAT_COMP_W_shift) |
			     (tex_res->num_format_all << SQ_TEX_RESOURCE_WORD4_0__NUM_FORMAT_ALL_shift) |
			     (tex_res->endian << SQ_TEX_RESOURCE_WORD4_0__ENDIAN_SWAP_shift) |
			     (tex_res->request_size << REQUEST_SIZE_shift) |
			     (tex_res->dst_sel_x << SQ_TEX_RESOURCE_WORD4_0__DST_SEL_X_shift) |
			     (tex_res->dst_sel_y << SQ_TEX_RESOURCE_WORD4_0__DST_SEL_Y_shift) |
			     (tex_res->dst_sel_z << SQ_TEX_RESOURCE_WORD4_0__DST_SEL_Z_shift) |
			     (tex_res->dst_sel_w << SQ_TEX_RESOURCE_WORD4_0__DST_SEL_W_shift) |
			     (tex_res->base_level << BASE_LEVEL_shift));

    if (tex_res->srf_mode_all)
	sq_tex_resource_word4 |= SQ_TEX_RESOURCE_WORD4_0__SRF_MODE_ALL_bit;
    if (tex_res->force_degamma)
	sq_tex_resource_word4 |= SQ_TEX_RESOURCE_WORD4_0__FORCE_DEGAMMA_bit;

    sq_tex_resource_word5 = ((tex_res->last_level << LAST_LEVEL_shift) |
			     (tex_res->base_array << BASE_ARRAY_shift) |
			     (tex_res->last_array << LAST_ARRAY_shift));

    sq_tex_resource_word6 = ((tex_res->mpeg_clamp << MPEG_CLAMP_shift) |
			     (tex_res->perf_modulation << PERF_MODULATION_shift) |
			     (SQ_TEX_VTX_VALID_TEXTURE << SQ_TEX_RESOURCE_WORD6_0__TYPE_shift));

    if (tex_res->interlaced)
	sq_tex_resource_word6 |= INTERLACED_bit;

    /* flush texture cache */
    r600_cp_set_surface_sync(pScrn, TC_ACTION_ENA_bit,
			     tex_res->size, tex_res->base,
			     tex_res->bo, domain, 0);

    BEGIN_BATCH(9 + 4);
    PACK0(SQ_TEX_RESOURCE + tex_res->id * SQ_TEX_RESOURCE_offset, 7);
    E32(sq_tex_resource_word0);
    E32(sq_tex_resource_word1);
    E32(((tex_res->base) >> 8));
    E32(((tex_res->mip_base) >> 8));
    E32(sq_tex_resource_word4);
    E32(sq_tex_resource_word5);
    E32(sq_tex_resource_word6);
    RELOC_BATCH(tex_res->bo, domain, 0);
    RELOC_BATCH(tex_res->mip_bo, domain, 0);
    END_BATCH();
}

void
r600_set_tex_sampler (ScrnInfoPtr pScrn, tex_sampler_t *s)
{
    RADEONInfoPtr info = RADEONPTR(pScrn);
    uint32_t sq_tex_sampler_word0, sq_tex_sampler_word1, sq_tex_sampler_word2;

    sq_tex_sampler_word0 = ((s->clamp_x       << SQ_TEX_SAMPLER_WORD0_0__CLAMP_X_shift)		|
			    (s->clamp_y       << CLAMP_Y_shift)					|
			    (s->clamp_z       << CLAMP_Z_shift)					|
			    (s->xy_mag_filter << XY_MAG_FILTER_shift)				|
			    (s->xy_min_filter << XY_MIN_FILTER_shift)				|
			    (s->z_filter      << Z_FILTER_shift)	|
			    (s->mip_filter    << MIP_FILTER_shift)				|
			    (s->border_color  << BORDER_COLOR_TYPE_shift)			|
			    (s->depth_compare << DEPTH_COMPARE_FUNCTION_shift)			|
			    (s->chroma_key    << CHROMA_KEY_shift));
    if (s->point_sampling_clamp)
	sq_tex_sampler_word0 |= POINT_SAMPLING_CLAMP_bit;
    if (s->tex_array_override)
	sq_tex_sampler_word0 |= TEX_ARRAY_OVERRIDE_bit;
    if (s->lod_uses_minor_axis)
	sq_tex_sampler_word0 |= LOD_USES_MINOR_AXIS_bit;

    sq_tex_sampler_word1 = ((s->min_lod       << MIN_LOD_shift)					|
			    (s->max_lod       << MAX_LOD_shift)					|
			    (s->lod_bias      << SQ_TEX_SAMPLER_WORD1_0__LOD_BIAS_shift));

    sq_tex_sampler_word2 = ((s->lod_bias2     << LOD_BIAS_SEC_shift)	|
			    (s->perf_mip      << PERF_MIP_shift)	|
			    (s->perf_z        << PERF_Z_shift));
    if (s->mc_coord_truncate)
	sq_tex_sampler_word2 |= MC_COORD_TRUNCATE_bit;
    if (s->force_degamma)
	sq_tex_sampler_word2 |= SQ_TEX_SAMPLER_WORD2_0__FORCE_DEGAMMA_bit;
    if (s->high_precision_filter)
	sq_tex_sampler_word2 |= HIGH_PRECISION_FILTER_bit;
    if (s->fetch_4)
	sq_tex_sampler_word2 |= FETCH_4_bit;
    if (s->sample_is_pcf)
	sq_tex_sampler_word2 |= SAMPLE_IS_PCF_bit;
    if (s->type)
	sq_tex_sampler_word2 |= SQ_TEX_SAMPLER_WORD2_0__TYPE_bit;

    BEGIN_BATCH(5);
    PACK0(SQ_TEX_SAMPLER_WORD + s->id * SQ_TEX_SAMPLER_WORD_offset, 3);
    E32(sq_tex_sampler_word0);
    E32(sq_tex_sampler_word1);
    E32(sq_tex_sampler_word2);
    END_BATCH();
}

//XXX deal with clip offsets in clip setup
void
r600_set_screen_scissor(ScrnInfoPtr pScrn, int x1, int y1, int x2, int y2)
{
    RADEONInfoPtr info = RADEONPTR(pScrn);

    BEGIN_BATCH(4);
    PACK0(PA_SC_SCREEN_SCISSOR_TL, 2);
    E32(((x1 << PA_SC_SCREEN_SCISSOR_TL__TL_X_shift) |
	     (y1 << PA_SC_SCREEN_SCISSOR_TL__TL_Y_shift)));
    E32(((x2 << PA_SC_SCREEN_SCISSOR_BR__BR_X_shift) |
	     (y2 << PA_SC_SCREEN_SCISSOR_BR__BR_Y_shift)));
    END_BATCH();
}

void
r600_set_vport_scissor(ScrnInfoPtr pScrn, int id, int x1, int y1, int x2, int y2)
{
    RADEONInfoPtr info = RADEONPTR(pScrn);

    BEGIN_BATCH(4);
    PACK0(PA_SC_VPORT_SCISSOR_0_TL + id * PA_SC_VPORT_SCISSOR_0_TL_offset, 2);
    E32(((x1 << PA_SC_VPORT_SCISSOR_0_TL__TL_X_shift) |
	     (y1 << PA_SC_VPORT_SCISSOR_0_TL__TL_Y_shift) |
	     WINDOW_OFFSET_DISABLE_bit));
    E32(((x2 << PA_SC_VPORT_SCISSOR_0_BR__BR_X_shift) |
	     (y2 << PA_SC_VPORT_SCISSOR_0_BR__BR_Y_shift)));
    END_BATCH();
}

void
r600_set_generic_scissor(ScrnInfoPtr pScrn, int x1, int y1, int x2, int y2)
{
    RADEONInfoPtr info = RADEONPTR(pScrn);

    BEGIN_BATCH(4);
    PACK0(PA_SC_GENERIC_SCISSOR_TL, 2);
    E32(((x1 << PA_SC_GENERIC_SCISSOR_TL__TL_X_shift) |
	     (y1 << PA_SC_GENERIC_SCISSOR_TL__TL_Y_shift) |
	     WINDOW_OFFSET_DISABLE_bit));
    E32(((x2 << PA_SC_GENERIC_SCISSOR_BR__BR_X_shift) |
	     (y2 << PA_SC_GENERIC_SCISSOR_TL__TL_Y_shift)));
    END_BATCH();
}

void
r600_set_window_scissor(ScrnInfoPtr pScrn, int x1, int y1, int x2, int y2)
{
    RADEONInfoPtr info = RADEONPTR(pScrn);

    BEGIN_BATCH(4);
    PACK0(PA_SC_WINDOW_SCISSOR_TL, 2);
    E32(((x1 << PA_SC_WINDOW_SCISSOR_TL__TL_X_shift) |
	     (y1 << PA_SC_WINDOW_SCISSOR_TL__TL_Y_shift) |
	     WINDOW_OFFSET_DISABLE_bit));
    E32(((x2 << PA_SC_WINDOW_SCISSOR_BR__BR_X_shift) |
	      (y2 << PA_SC_WINDOW_SCISSOR_BR__BR_Y_shift)));
    END_BATCH();
}

void
r600_set_clip_rect(ScrnInfoPtr pScrn, int id, int x1, int y1, int x2, int y2)
{
    RADEONInfoPtr info = RADEONPTR(pScrn);

    BEGIN_BATCH(4);
    PACK0(PA_SC_CLIPRECT_0_TL + id * PA_SC_CLIPRECT_0_TL_offset, 2);
    E32(((x1 << PA_SC_CLIPRECT_0_TL__TL_X_shift) |
	     (y1 << PA_SC_CLIPRECT_0_TL__TL_Y_shift)));
    E32(((x2 << PA_SC_CLIPRECT_0_BR__BR_X_shift) |
	     (y2 << PA_SC_CLIPRECT_0_BR__BR_Y_shift)));
    END_BATCH();
}

/*
 * Setup of default state
 */

void
r600_set_default_state(ScrnInfoPtr pScrn)
{
    tex_resource_t tex_res;
    shader_config_t fs_conf;
    sq_config_t sq_conf;
    int i;
    RADEONInfoPtr info = RADEONPTR(pScrn);
    struct radeon_accel_state *accel_state = info->accel_state;

    if (accel_state->XInited3D)
	return;

    memset(&tex_res, 0, sizeof(tex_resource_t));
    memset(&fs_conf, 0, sizeof(shader_config_t));

    accel_state->XInited3D = TRUE;

    r600_start_3d(pScrn);

    // SQ
    sq_conf.ps_prio = 0;
    sq_conf.vs_prio = 1;
    sq_conf.gs_prio = 2;
    sq_conf.es_prio = 3;
    // need to set stack/thread/gpr limits based on the asic
    // for now just set them low enough so any card will work
    // see r600_cp.c in the drm
    switch (info->ChipFamily) {
    case CHIP_FAMILY_R600:
	sq_conf.num_ps_gprs = 192;
	sq_conf.num_vs_gprs = 56;
	sq_conf.num_temp_gprs = 4;
	sq_conf.num_gs_gprs = 0;
	sq_conf.num_es_gprs = 0;
	sq_conf.num_ps_threads = 136;
	sq_conf.num_vs_threads = 48;
	sq_conf.num_gs_threads = 4;
	sq_conf.num_es_threads = 4;
	sq_conf.num_ps_stack_entries = 128;
	sq_conf.num_vs_stack_entries = 128;
	sq_conf.num_gs_stack_entries = 0;
	sq_conf.num_es_stack_entries = 0;
	break;
    case CHIP_FAMILY_RV630:
    case CHIP_FAMILY_RV635:
	sq_conf.num_ps_gprs = 84;
	sq_conf.num_vs_gprs = 36;
	sq_conf.num_temp_gprs = 4;
	sq_conf.num_gs_gprs = 0;
	sq_conf.num_es_gprs = 0;
	sq_conf.num_ps_threads = 144;
	sq_conf.num_vs_threads = 40;
	sq_conf.num_gs_threads = 4;
	sq_conf.num_es_threads = 4;
	sq_conf.num_ps_stack_entries = 40;
	sq_conf.num_vs_stack_entries = 40;
	sq_conf.num_gs_stack_entries = 32;
	sq_conf.num_es_stack_entries = 16;
	break;
    case CHIP_FAMILY_RV610:
    case CHIP_FAMILY_RV620:
    case CHIP_FAMILY_RS780:
    case CHIP_FAMILY_RS880:
    default:
	sq_conf.num_ps_gprs = 84;
	sq_conf.num_vs_gprs = 36;
	sq_conf.num_temp_gprs = 4;
	sq_conf.num_gs_gprs = 0;
	sq_conf.num_es_gprs = 0;
	sq_conf.num_ps_threads = 136;
	sq_conf.num_vs_threads = 48;
	sq_conf.num_gs_threads = 4;
	sq_conf.num_es_threads = 4;
	sq_conf.num_ps_stack_entries = 40;
	sq_conf.num_vs_stack_entries = 40;
	sq_conf.num_gs_stack_entries = 32;
	sq_conf.num_es_stack_entries = 16;
	break;
    case CHIP_FAMILY_RV670:
	sq_conf.num_ps_gprs = 144;
	sq_conf.num_vs_gprs = 40;
	sq_conf.num_temp_gprs = 4;
	sq_conf.num_gs_gprs = 0;
	sq_conf.num_es_gprs = 0;
	sq_conf.num_ps_threads = 136;
	sq_conf.num_vs_threads = 48;
	sq_conf.num_gs_threads = 4;
	sq_conf.num_es_threads = 4;
	sq_conf.num_ps_stack_entries = 40;
	sq_conf.num_vs_stack_entries = 40;
	sq_conf.num_gs_stack_entries = 32;
	sq_conf.num_es_stack_entries = 16;
	break;
    case CHIP_FAMILY_RV770:
	sq_conf.num_ps_gprs = 192;
	sq_conf.num_vs_gprs = 56;
	sq_conf.num_temp_gprs = 4;
	sq_conf.num_gs_gprs = 0;
	sq_conf.num_es_gprs = 0;
	sq_conf.num_ps_threads = 188;
	sq_conf.num_vs_threads = 60;
	sq_conf.num_gs_threads = 0;
	sq_conf.num_es_threads = 0;
	sq_conf.num_ps_stack_entries = 256;
	sq_conf.num_vs_stack_entries = 256;
	sq_conf.num_gs_stack_entries = 0;
	sq_conf.num_es_stack_entries = 0;
	break;
    case CHIP_FAMILY_RV730:
    case CHIP_FAMILY_RV740:
	sq_conf.num_ps_gprs = 84;
	sq_conf.num_vs_gprs = 36;
	sq_conf.num_temp_gprs = 4;
	sq_conf.num_gs_gprs = 0;
	sq_conf.num_es_gprs = 0;
	sq_conf.num_ps_threads = 188;
	sq_conf.num_vs_threads = 60;
	sq_conf.num_gs_threads = 0;
	sq_conf.num_es_threads = 0;
	sq_conf.num_ps_stack_entries = 128;
	sq_conf.num_vs_stack_entries = 128;
	sq_conf.num_gs_stack_entries = 0;
	sq_conf.num_es_stack_entries = 0;
	break;
    case CHIP_FAMILY_RV710:
	sq_conf.num_ps_gprs = 192;
	sq_conf.num_vs_gprs = 56;
	sq_conf.num_temp_gprs = 4;
	sq_conf.num_gs_gprs = 0;
	sq_conf.num_es_gprs = 0;
	sq_conf.num_ps_threads = 144;
	sq_conf.num_vs_threads = 48;
	sq_conf.num_gs_threads = 0;
	sq_conf.num_es_threads = 0;
	sq_conf.num_ps_stack_entries = 128;
	sq_conf.num_vs_stack_entries = 128;
	sq_conf.num_gs_stack_entries = 0;
	sq_conf.num_es_stack_entries = 0;
	break;
    }

    r600_sq_setup(pScrn, &sq_conf);

    /* set fake reloc for unused depth */
    BEGIN_BATCH(3 + 2);
    EREG(DB_DEPTH_INFO, 0);
    RELOC_BATCH(accel_state->shaders_bo, RADEON_GEM_DOMAIN_VRAM, 0);
    END_BATCH();

    BEGIN_BATCH(80);
    if (info->ChipFamily < CHIP_FAMILY_RV770) {
	EREG(TA_CNTL_AUX, (( 3 << GRADIENT_CREDIT_shift) |
			       (28 << TD_FIFO_CREDIT_shift)));
	EREG(VC_ENHANCE, 0);
	EREG(R7xx_SQ_DYN_GPR_CNTL_PS_FLUSH_REQ, 0);
	EREG(DB_DEBUG, 0x82000000); /* ? */
	EREG(DB_WATERMARKS, ((4 << DEPTH_FREE_shift) |
				 (16 << DEPTH_FLUSH_shift) |
				 (0 << FORCE_SUMMARIZE_shift) |
				 (4 << DEPTH_PENDING_FREE_shift) |
				 (16 << DEPTH_CACHELINE_FREE_shift) |
				 0));
    } else {
	EREG(TA_CNTL_AUX, (( 2 << GRADIENT_CREDIT_shift) |
			       (28 << TD_FIFO_CREDIT_shift)));
	EREG(VC_ENHANCE, 0);
	EREG(R7xx_SQ_DYN_GPR_CNTL_PS_FLUSH_REQ, VS_PC_LIMIT_ENABLE_bit);
	EREG(DB_DEBUG, 0);
	EREG(DB_WATERMARKS, ((4 << DEPTH_FREE_shift) |
				 (16 << DEPTH_FLUSH_shift) |
				 (0 << FORCE_SUMMARIZE_shift) |
				 (4 << DEPTH_PENDING_FREE_shift) |
				 (4 << DEPTH_CACHELINE_FREE_shift) |
				 0));
    }

    PACK0(SQ_VTX_BASE_VTX_LOC, 2);
    E32(0);
    E32(0);

    PACK0(SQ_ESGS_RING_ITEMSIZE, 9);
    E32(0); // SQ_ESGS_RING_ITEMSIZE
    E32(0); // SQ_GSVS_RING_ITEMSIZE
    E32(0); // SQ_ESTMP_RING_ITEMSIZE
    E32(0); // SQ_GSTMP_RING_ITEMSIZE
    E32(0); // SQ_VSTMP_RING_ITEMSIZE
    E32(0); // SQ_PSTMP_RING_ITEMSIZE
    E32(0); // SQ_FBUF_RING_ITEMSIZE
    E32(0); // SQ_REDUC_RING_ITEMSIZE
    E32(0); // SQ_GS_VERT_ITEMSIZE

    // DB
    EREG(DB_DEPTH_CONTROL,                    0);
    PACK0(DB_RENDER_CONTROL, 2);
    E32(STENCIL_COMPRESS_DISABLE_bit | DEPTH_COMPRESS_DISABLE_bit);
    if (info->ChipFamily < CHIP_FAMILY_RV770)
	E32(FORCE_SHADER_Z_ORDER_bit);
    else
	E32(0);
    EREG(DB_ALPHA_TO_MASK,                    ((2 << ALPHA_TO_MASK_OFFSET0_shift)	|
						   (2 << ALPHA_TO_MASK_OFFSET1_shift)	|
						   (2 << ALPHA_TO_MASK_OFFSET2_shift)	|
						   (2 << ALPHA_TO_MASK_OFFSET3_shift)));
    EREG(DB_SHADER_CONTROL, ((1 << Z_ORDER_shift) | /* EARLY_Z_THEN_LATE_Z */
				 DUAL_EXPORT_ENABLE_bit)); /* Only useful if no depth export */

    PACK0(DB_STENCIL_CLEAR, 2);
    E32(0); // DB_STENCIL_CLEAR
    E32(0); // DB_DEPTH_CLEAR

    PACK0(DB_STENCILREFMASK, 3);
    E32(0); // DB_STENCILREFMASK
    E32(0); // DB_STENCILREFMASK_BF
    E32(0); // SX_ALPHA_REF

    PACK0(CB_CLRCMP_CONTROL, 4);
    E32(1 << CLRCMP_FCN_SEL_shift);				// CB_CLRCMP_CONTROL: use CLRCMP_FCN_SRC
    E32(0);							// CB_CLRCMP_SRC
    E32(0);							// CB_CLRCMP_DST
    E32(0);							// CB_CLRCMP_MSK

    EREG(CB_SHADER_MASK,                      OUTPUT0_ENABLE_mask);
    EREG(R7xx_CB_SHADER_CONTROL,              (RT0_ENABLE_bit));

    PACK0(SX_ALPHA_TEST_CONTROL, 5);
    E32(0); // SX_ALPHA_TEST_CONTROL
    E32(0x00000000); // CB_BLEND_RED
    E32(0x00000000); // CB_BLEND_GREEN
    E32(0x00000000); // CB_BLEND_BLUE
    E32(0x00000000); // CB_BLEND_ALPHA

    EREG(PA_SC_WINDOW_OFFSET,                 ((0 << WINDOW_X_OFFSET_shift) |
						   (0 << WINDOW_Y_OFFSET_shift)));

    if (info->ChipFamily < CHIP_FAMILY_RV770)
	EREG(R7xx_PA_SC_EDGERULE,             0x00000000);
    else
	EREG(R7xx_PA_SC_EDGERULE,             0xAAAAAAAA);

    EREG(PA_SC_CLIPRECT_RULE,                 CLIP_RULE_mask);

    END_BATCH();

    /* clip boolean is set to always visible -> doesn't matter */
    for (i = 0; i < PA_SC_CLIPRECT_0_TL_num; i++)
	r600_set_clip_rect(pScrn, i, 0, 0, 8192, 8192);

    for (i = 0; i < PA_SC_VPORT_SCISSOR_0_TL_num; i++)
	r600_set_vport_scissor(pScrn, i, 0, 0, 8192, 8192);

    BEGIN_BATCH(49);
    PACK0(PA_SC_MPASS_PS_CNTL, 2);
    E32(0);
    if (info->ChipFamily < CHIP_FAMILY_RV770)
	E32((WALK_ORDER_ENABLE_bit | FORCE_EOV_CNTDWN_ENABLE_bit));
    else
	E32((FORCE_EOV_CNTDWN_ENABLE_bit | FORCE_EOV_REZ_ENABLE_bit |
		 0x00500000)); /* ? */

    PACK0(PA_SC_LINE_CNTL, 9);
    E32(0); // PA_SC_LINE_CNTL
    E32(0); // PA_SC_AA_CONFIG
    E32(((2 << PA_SU_VTX_CNTL__ROUND_MODE_shift) | PIX_CENTER_bit | // PA_SU_VTX_CNTL
	     (5 << QUANT_MODE_shift))); /* Round to Even, fixed point 1/256 */
    EFLOAT(1.0);						// PA_CL_GB_VERT_CLIP_ADJ
    EFLOAT(1.0);						// PA_CL_GB_VERT_DISC_ADJ
    EFLOAT(1.0);						// PA_CL_GB_HORZ_CLIP_ADJ
    EFLOAT(1.0);						// PA_CL_GB_HORZ_DISC_ADJ
    E32(0);                                                 // PA_SC_AA_SAMPLE_LOCS_MCTX
    E32(0);                                                 // PA_SC_AA_SAMPLE_LOCS_8S_WD1_M

    EREG(PA_SC_AA_MASK,                       0xFFFFFFFF);

    PACK0(PA_CL_CLIP_CNTL, 5);
    E32(CLIP_DISABLE_bit); // PA_CL_CLIP_CNTL
    E32(FACE_bit);         // PA_SU_SC_MODE_CNTL
    E32(VTX_XY_FMT_bit);   // PA_CL_VTE_CNTL
    E32(0);                // PA_CL_VS_OUT_CNTL
    E32(0);                // PA_CL_NANINF_CNTL

    PACK0(PA_SU_POLY_OFFSET_DB_FMT_CNTL, 6);
    E32(0); // PA_SU_POLY_OFFSET_DB_FMT_CNTL
    E32(0); // PA_SU_POLY_OFFSET_CLAMP
    E32(0); // PA_SU_POLY_OFFSET_FRONT_SCALE
    E32(0); // PA_SU_POLY_OFFSET_FRONT_OFFSET
    E32(0); // PA_SU_POLY_OFFSET_BACK_SCALE
    E32(0); // PA_SU_POLY_OFFSET_BACK_OFFSET

    // SPI
    if (info->ChipFamily < CHIP_FAMILY_RV770)
	EREG(R7xx_SPI_THREAD_GROUPING,        0);
    else
	EREG(R7xx_SPI_THREAD_GROUPING,        (1 << PS_GROUPING_shift));

    /* default Interpolator setup */
    EREG(SPI_VS_OUT_ID_0, ((0 << SEMANTIC_0_shift) |
			       (1 << SEMANTIC_1_shift)));
    PACK0(SPI_PS_INPUT_CNTL_0 + (0 << 2), 2);
    /* SPI_PS_INPUT_CNTL_0 maps to GPR[0] - load with semantic id 0 */
    E32(((0    << SEMANTIC_shift)	|
	     (0x01 << DEFAULT_VAL_shift)	|
	     SEL_CENTROID_bit));
    /* SPI_PS_INPUT_CNTL_1 maps to GPR[1] - load with semantic id 1 */
    E32(((1    << SEMANTIC_shift)	|
	     (0x01 << DEFAULT_VAL_shift)	|
	     SEL_CENTROID_bit));

    PACK0(SPI_INPUT_Z, 4);
    E32(0); // SPI_INPUT_Z
    E32(0); // SPI_FOG_CNTL
    E32(0); // SPI_FOG_FUNC_SCALE
    E32(0); // SPI_FOG_FUNC_BIAS

    END_BATCH();

    // clear FS
    fs_conf.bo = accel_state->shaders_bo;
    r600_fs_setup(pScrn, &fs_conf, RADEON_GEM_DOMAIN_VRAM);

    // VGT
    BEGIN_BATCH(46);
    PACK0(VGT_MAX_VTX_INDX, 4);
    E32(0xffffff); // VGT_MAX_VTX_INDX
    E32(0); // VGT_MIN_VTX_INDX
    E32(0); // VGT_INDX_OFFSET
    E32(0); // VGT_MULTI_PRIM_IB_RESET_INDX

    EREG(VGT_PRIMITIVEID_EN,                  0);
    EREG(VGT_MULTI_PRIM_IB_RESET_EN,          0);

    PACK0(VGT_INSTANCE_STEP_RATE_0, 2);
    E32(0); // VGT_INSTANCE_STEP_RATE_0
    E32(0); // VGT_INSTANCE_STEP_RATE_1

    PACK0(PA_SU_POINT_SIZE, 17);
    E32(0); // PA_SU_POINT_SIZE
    E32(0); // PA_SU_POINT_MINMAX
    E32((8 << PA_SU_LINE_CNTL__WIDTH_shift)); /* Line width 1 pixel */ // PA_SU_LINE_CNTL
    E32(0); // PA_SC_LINE_STIPPLE
    E32(0); // VGT_OUTPUT_PATH_CNTL
    E32(0); // VGT_HOS_CNTL
    E32(0); // VGT_HOS_MAX_TESS_LEVEL
    E32(0); // VGT_HOS_MIN_TESS_LEVEL
    E32(0); // VGT_HOS_REUSE_DEPTH
    E32(0); // VGT_GROUP_PRIM_TYPE
    E32(0); // VGT_GROUP_FIRST_DECR
    E32(0); // VGT_GROUP_DECR
    E32(0); // VGT_GROUP_VECT_0_CNTL
    E32(0); // VGT_GROUP_VECT_1_CNTL
    E32(0); // VGT_GROUP_VECT_0_FMT_CNTL
    E32(0); // VGT_GROUP_VECT_1_FMT_CNTL
    E32(0); // VGT_GS_MODE

    PACK0(VGT_STRMOUT_EN, 3);
    E32(0); // VGT_STRMOUT_EN
    E32(0); // VGT_REUSE_OFF
    E32(0); // VGT_VTX_CNT_EN

    EREG(VGT_STRMOUT_BUFFER_EN,               0);
    EREG(SX_MISC,                             0);
    END_BATCH();
}


/*
 * Commands
 */

void
r600_draw_immd(ScrnInfoPtr pScrn, draw_config_t *draw_conf, uint32_t *indices)
{
    RADEONInfoPtr info = RADEONPTR(pScrn);
    uint32_t i, count;

    // calculate num of packets
    count = 2;
    if (draw_conf->index_type == DI_INDEX_SIZE_16_BIT)
	count += (draw_conf->num_indices + 1) / 2;
    else
	count += draw_conf->num_indices;

    BEGIN_BATCH(8 + count);
    EREG(VGT_PRIMITIVE_TYPE, draw_conf->prim_type);
    PACK3(IT_INDEX_TYPE, 1);
#if X_BYTE_ORDER == X_BIG_ENDIAN
    E32(IT_INDEX_TYPE_SWAP_MODE(ENDIAN_8IN32) | draw_conf->index_type);
#else
    E32(draw_conf->index_type);
#endif
    PACK3(IT_NUM_INSTANCES, 1);
    E32(draw_conf->num_instances);

    PACK3(IT_DRAW_INDEX_IMMD, count);
    E32(draw_conf->num_indices);
    E32(draw_conf->vgt_draw_initiator);

    if (draw_conf->index_type == DI_INDEX_SIZE_16_BIT) {
	for (i = 0; i < draw_conf->num_indices; i += 2) {
	    if ((i + 1) == draw_conf->num_indices)
		E32(indices[i]);
	    else
		E32((indices[i] | (indices[i + 1] << 16)));
	}
    } else {
	for (i = 0; i < draw_conf->num_indices; i++)
	    E32(indices[i]);
    }
    END_BATCH();
}

void
r600_draw_auto(ScrnInfoPtr pScrn, draw_config_t *draw_conf)
{
    RADEONInfoPtr info = RADEONPTR(pScrn);

    BEGIN_BATCH(10);
    EREG(VGT_PRIMITIVE_TYPE, draw_conf->prim_type);
    PACK3(IT_INDEX_TYPE, 1);
#if X_BYTE_ORDER == X_BIG_ENDIAN
    E32(IT_INDEX_TYPE_SWAP_MODE(ENDIAN_8IN32) | draw_conf->index_type);
#else
    E32(draw_conf->index_type);
#endif
    PACK3(IT_NUM_INSTANCES, 1);
    E32(draw_conf->num_instances);
    PACK3(IT_DRAW_INDEX_AUTO, 2);
    E32(draw_conf->num_indices);
    E32(draw_conf->vgt_draw_initiator);
    END_BATCH();
}

void r600_finish_op(ScrnInfoPtr pScrn, int vtx_size)
{
    RADEONInfoPtr info = RADEONPTR(pScrn);
    struct radeon_accel_state *accel_state = info->accel_state;
    draw_config_t   draw_conf;
    vtx_resource_t  vtx_res;

    if (accel_state->vbo.vb_start_op == -1)
	return;

    CLEAR (draw_conf);
    CLEAR (vtx_res);

    if (accel_state->vbo.vb_offset == accel_state->vbo.vb_start_op) {
        R600IBDiscard(pScrn);
	return;
    }

    /* Vertex buffer setup */
    accel_state->vbo.vb_size = accel_state->vbo.vb_offset - accel_state->vbo.vb_start_op;
    vtx_res.id              = SQ_VTX_RESOURCE_vs;
    vtx_res.vtx_size_dw     = vtx_size / 4;
    vtx_res.vtx_num_entries = accel_state->vbo.vb_size / 4;
    vtx_res.mem_req_size    = 1;
    vtx_res.vb_addr         = accel_state->vbo.vb_start_op;
    vtx_res.bo              = accel_state->vbo.vb_bo;
#if X_BYTE_ORDER == X_BIG_ENDIAN
    vtx_res.endian          = SQ_ENDIAN_8IN32;
#endif
    r600_set_vtx_resource(pScrn, &vtx_res, RADEON_GEM_DOMAIN_GTT);

    /* Draw */
    draw_conf.prim_type          = DI_PT_RECTLIST;
    draw_conf.vgt_draw_initiator = DI_SRC_SEL_AUTO_INDEX;
    draw_conf.num_instances      = 1;
    draw_conf.num_indices        = vtx_res.vtx_num_entries / vtx_res.vtx_size_dw;
    draw_conf.index_type         = DI_INDEX_SIZE_16_BIT;

    r600_draw_auto(pScrn, &draw_conf);

    /* XXX drm should handle this in fence submit */
    r600_wait_3d_idle_clean(pScrn);

    /* sync dst surface */
    r600_cp_set_surface_sync(pScrn, (CB_ACTION_ENA_bit | CB0_DEST_BASE_ENA_bit),
			     accel_state->dst_size, 0,
			     accel_state->dst_obj.bo, 0, accel_state->dst_obj.domain);

    accel_state->vbo.vb_start_op = -1;
    accel_state->ib_reset_op = 0;

}

@


1.6
log
@Update to xf86-video-ati 7.2.0, requested by jsg@@

It fixes an endianess problem with kms and the in tree x86-video-ati
among other things.
It has been tested on various i386/amd64/sparc64/macppc machines
on a range of hardware from r100->northern islands.
@
text
@a39 1
#include "radeon_drm.h"
@


1.5
log
@Update to xf86-video-ati 6.14.4. Tested by jasper@@, krw@@, mpi@@, shadchin@@
@
text
@d68 1
a68 1
void R600CPFlushIndirect(ScrnInfoPtr pScrn, drmBufPtr ib)
d70 1
a70 36
    RADEONInfoPtr  info = RADEONPTR(pScrn);
    drmBufPtr          buffer = ib;
    int                start  = 0;
    drm_radeon_indirect_t  indirect;

#if defined(XF86DRM_MODE)
    if (info->cs) {
	radeon_cs_flush_indirect(pScrn);
	return;
    }
#endif

    if (!buffer) return;

    //xf86DrvMsg(pScrn->scrnIndex, X_INFO, "Flushing buffer %d\n",
    //       buffer->idx);

    while (buffer->used & 0x3c){
	BEGIN_BATCH(1);
        E32(buffer, CP_PACKET2()); /* fill up to multiple of 16 dwords */
	END_BATCH();
    }

    info->accel_state->vbo.vb_offset = 0;
    info->accel_state->vbo.vb_start_op = -1;

    //ErrorF("buffer bytes: %d\n", buffer->used);

    indirect.idx     = buffer->idx;
    indirect.start   = start;
    indirect.end     = buffer->used;
    indirect.discard = 1;

    drmCommandWriteRead(info->dri->drmFD, DRM_RADEON_INDIRECT,
			&indirect, sizeof(drm_radeon_indirect_t));

d73 1
a73 1
void R600IBDiscard(ScrnInfoPtr pScrn, drmBufPtr ib)
d75 1
a75 10
#if defined(XF86DRM_MODE)
    RADEONInfoPtr info = RADEONPTR(pScrn);
    if (info->cs) {
        radeon_ib_discard(pScrn);
    }
#endif
    if (!ib) return;

    ib->used = 0;
    R600CPFlushIndirect(pScrn, ib);
d79 1
a79 1
r600_wait_3d_idle_clean(ScrnInfoPtr pScrn, drmBufPtr ib)
d85 2
a86 2
    PACK3(ib, IT_EVENT_WRITE, 1);
    E32(ib, CACHE_FLUSH_AND_INV_EVENT);
d88 1
a88 1
    EREG(ib, WAIT_UNTIL,                          (WAIT_3D_IDLE_bit |
d94 1
a94 1
r600_wait_3d_idle(ScrnInfoPtr pScrn, drmBufPtr ib)
d99 1
a99 1
    EREG(ib, WAIT_UNTIL,                          WAIT_3D_IDLE_bit);
d104 1
a104 1
r600_start_3d(ScrnInfoPtr pScrn, drmBufPtr ib)
d110 2
a111 2
	PACK3(ib, IT_START_3D_CMDBUF, 1);
	E32(ib, 0);
d115 3
a117 3
    PACK3(ib, IT_CONTEXT_CONTROL, 2);
    E32(ib, 0x80000000);
    E32(ib, 0x80000000);
d128 1
a128 1
r600_sq_setup(ScrnInfoPtr pScrn, drmBufPtr ib, sq_config_t *sq_conf)
d168 7
a174 7
    PACK0(ib, SQ_CONFIG, 6);
    E32(ib, sq_config);
    E32(ib, sq_gpr_resource_mgmt_1);
    E32(ib, sq_gpr_resource_mgmt_2);
    E32(ib, sq_thread_resource_mgmt);
    E32(ib, sq_stack_resource_mgmt_1);
    E32(ib, sq_stack_resource_mgmt_2);
d179 1
a179 1
r600_set_render_target(ScrnInfoPtr pScrn, drmBufPtr ib, cb_config_t *cb_conf, uint32_t domain)
a185 1
#if defined(XF86DRM_MODE)
a200 1
#endif
d234 1
a234 1
    EREG(ib, (CB_COLOR0_BASE + (4 * cb_conf->id)), (cb_conf->base >> 8));
d242 2
a243 2
        PACK3(ib, IT_SURFACE_BASE_UPDATE, 1);
        E32(ib, (2 << cb_conf->id));
d251 1
a251 1
    EREG(ib, (CB_COLOR0_TILE + (4 * cb_conf->id)), (0     >> 8));	// CMASK per-tile data base/256
d255 1
a255 1
    EREG(ib, (CB_COLOR0_FRAG + (4 * cb_conf->id)), (0     >> 8));	// FMASK per-tile data base/256
d260 1
a260 1
    EREG(ib, (CB_COLOR0_SIZE + (4 * cb_conf->id)), ((pitch << PITCH_TILE_MAX_shift)	|
d262 1
a262 1
    EREG(ib, (CB_COLOR0_VIEW + (4 * cb_conf->id)), ((0    << SLICE_START_shift)		|
d264 1
a264 1
    EREG(ib, (CB_COLOR0_MASK + (4 * cb_conf->id)), ((0    << CMASK_BLOCK_MAX_shift)	|
d269 1
a269 1
    EREG(ib, (CB_COLOR0_INFO + (4 * cb_conf->id)), cb_color_info);
d274 1
a274 1
    EREG(ib, CB_TARGET_MASK,          (cb_conf->pmask << TARGET0_ENABLE_shift));
d279 2
a280 2
	EREG(ib, CB_COLOR_CONTROL,    cb_color_control);
	EREG(ib, CB_BLEND_CONTROL,    cb_conf->blendcntl);
d284 2
a285 2
	EREG(ib, CB_COLOR_CONTROL,    cb_color_control);
	EREG(ib, CB_BLEND0_CONTROL,   cb_conf->blendcntl);
d291 1
a291 1
r600_cp_set_surface_sync(ScrnInfoPtr pScrn, drmBufPtr ib, uint32_t sync_type,
d303 5
a307 5
    PACK3(ib, IT_SURFACE_SYNC, 4);
    E32(ib, sync_type);
    E32(ib, cp_coher_size);
    E32(ib, (mc_addr >> 8));
    E32(ib, 10); /* poll interval */
d314 1
a314 1
r600_cp_wait_vline_sync(ScrnInfoPtr pScrn, drmBufPtr ib, PixmapPtr pPix,
d318 1
a318 1
    uint32_t offset;
d326 2
a327 15
    if (info->cs) {
        if (pPix != pScrn->pScreen->GetScreenPixmap(pScrn->pScreen))
	    return;
    } else {
#ifdef USE_EXA
	if (info->useEXA)
	    offset = exaGetPixmapOffset(pPix);
	else
#endif
	    offset = pPix->devPrivate.ptr - info->FB;

	/* if drawing to front buffer */
	if (offset != 0)
	    return;
    }
d335 1
a335 26
#if defined(XF86DRM_MODE)
    if (info->cs) {
	drmmode_crtc_private_ptr drmmode_crtc = crtc->driver_private;

	BEGIN_BATCH(11);
	/* set the VLINE range */
	EREG(ib, AVIVO_D1MODE_VLINE_START_END, /* this is just a marker */
	     (start << AVIVO_D1MODE_VLINE_START_SHIFT) |
	     (stop << AVIVO_D1MODE_VLINE_END_SHIFT));

	/* tell the CP to poll the VLINE state register */
	PACK3(ib, IT_WAIT_REG_MEM, 6);
	E32(ib, IT_WAIT_REG | IT_WAIT_EQ);
	E32(ib, IT_WAIT_ADDR(AVIVO_D1MODE_VLINE_STATUS));
	E32(ib, 0);
	E32(ib, 0);                          // Ref value
	E32(ib, AVIVO_D1MODE_VLINE_STAT);    // Mask
	E32(ib, 10);                         // Wait interval
	/* add crtc reloc */
	PACK3(ib, IT_NOP, 1);
	E32(ib, drmmode_crtc->mode_crtc->crtc_id);
	END_BATCH();
    } else
#endif
    {
	RADEONCrtcPrivatePtr radeon_crtc = crtc->driver_private;
d337 18
a354 16
	BEGIN_BATCH(9);
	/* set the VLINE range */
	EREG(ib, AVIVO_D1MODE_VLINE_START_END + radeon_crtc->crtc_offset,
	     (start << AVIVO_D1MODE_VLINE_START_SHIFT) |
	     (stop << AVIVO_D1MODE_VLINE_END_SHIFT));

	/* tell the CP to poll the VLINE state register */
	PACK3(ib, IT_WAIT_REG_MEM, 6);
	E32(ib, IT_WAIT_REG | IT_WAIT_EQ);
	E32(ib, IT_WAIT_ADDR(AVIVO_D1MODE_VLINE_STATUS + radeon_crtc->crtc_offset));
	E32(ib, 0);
	E32(ib, 0);                          // Ref value
	E32(ib, AVIVO_D1MODE_VLINE_STAT);    // Mask
	E32(ib, 10);                         // Wait interval
	END_BATCH();
    }
d358 1
a358 1
r600_set_spi(ScrnInfoPtr pScrn, drmBufPtr ib, int vs_export_count, int num_interp)
d364 5
a368 5
    EREG(ib, SPI_VS_OUT_CONFIG, (vs_export_count << VS_EXPORT_COUNT_shift));
    PACK0(ib, SPI_PS_IN_CONTROL_0, 3);
    E32(ib, (num_interp << NUM_INTERP_shift));
    E32(ib, 0);
    E32(ib, 0);
d373 1
a373 1
r600_fs_setup(ScrnInfoPtr pScrn, drmBufPtr ib, shader_config_t *fs_conf, uint32_t domain)
d385 1
a385 1
    EREG(ib, SQ_PGM_START_FS, fs_conf->shader_addr >> 8);
d390 2
a391 2
    EREG(ib, SQ_PGM_RESOURCES_FS, sq_pgm_resources);
    EREG(ib, SQ_PGM_CF_OFFSET_FS, 0);
d396 1
a396 1
r600_vs_setup(ScrnInfoPtr pScrn, drmBufPtr ib, shader_config_t *vs_conf, uint32_t domain)
d412 1
a412 1
    r600_cp_set_surface_sync(pScrn, ib, SH_ACTION_ENA_bit,
d417 1
a417 1
    EREG(ib, SQ_PGM_START_VS, vs_conf->shader_addr >> 8);
d422 2
a423 2
    EREG(ib, SQ_PGM_RESOURCES_VS, sq_pgm_resources);
    EREG(ib, SQ_PGM_CF_OFFSET_VS, 0);
d428 1
a428 1
r600_ps_setup(ScrnInfoPtr pScrn, drmBufPtr ib, shader_config_t *ps_conf, uint32_t domain)
d446 1
a446 1
    r600_cp_set_surface_sync(pScrn, ib, SH_ACTION_ENA_bit,
d451 1
a451 1
    EREG(ib, SQ_PGM_START_PS, ps_conf->shader_addr >> 8);
d456 3
a458 3
    EREG(ib, SQ_PGM_RESOURCES_PS, sq_pgm_resources);
    EREG(ib, SQ_PGM_EXPORTS_PS, ps_conf->export_mode);
    EREG(ib, SQ_PGM_CF_OFFSET_PS, 0);
d463 1
a463 1
r600_set_alu_consts(ScrnInfoPtr pScrn, drmBufPtr ib, int offset, int count, float *const_buf)
d470 1
a470 1
    PACK0(ib, SQ_ALU_CONSTANT + offset * SQ_ALU_CONSTANT_offset, countreg);
d472 1
a472 1
	EFLOAT(ib, const_buf[i]);
d477 1
a477 1
r600_set_bool_consts(ScrnInfoPtr pScrn, drmBufPtr ib, int offset, uint32_t val)
d484 1
a484 1
    EREG(ib, SQ_BOOL_CONST + offset * SQ_BOOL_CONST_offset, val);
d489 1
a489 1
r600_set_vtx_resource(ScrnInfoPtr pScrn, drmBufPtr ib, vtx_resource_t *res, uint32_t domain)
d515 2
a516 2
	r600_cp_set_surface_sync(pScrn, ib, TC_ACTION_ENA_bit,
				 accel_state->vbo.vb_offset, accel_state->vbo.vb_mc_addr,
d520 2
a521 2
	r600_cp_set_surface_sync(pScrn, ib, VC_ACTION_ENA_bit,
				 accel_state->vbo.vb_offset, accel_state->vbo.vb_mc_addr,
d526 8
a533 8
    PACK0(ib, SQ_VTX_RESOURCE + res->id * SQ_VTX_RESOURCE_offset, 7);
    E32(ib, res->vb_addr & 0xffffffff);				// 0: BASE_ADDRESS
    E32(ib, (res->vtx_num_entries << 2) - 1);			// 1: SIZE
    E32(ib, sq_vtx_constant_word2);	// 2: BASE_HI, STRIDE, CLAMP, FORMAT, ENDIAN
    E32(ib, res->mem_req_size << MEM_REQUEST_SIZE_shift);		// 3: MEM_REQUEST_SIZE ?!?
    E32(ib, 0);							// 4: n/a
    E32(ib, 0);							// 5: n/a
    E32(ib, SQ_TEX_VTX_VALID_BUFFER << SQ_VTX_CONSTANT_WORD6_0__TYPE_shift);	// 6: TYPE
d539 1
a539 1
r600_set_tex_resource(ScrnInfoPtr pScrn, drmBufPtr ib, tex_resource_t *tex_res, uint32_t domain)
a545 1
#if defined(XF86DRM_MODE)
a559 1
#endif
d612 1
a612 1
    r600_cp_set_surface_sync(pScrn, ib, TC_ACTION_ENA_bit,
d617 8
a624 8
    PACK0(ib, SQ_TEX_RESOURCE + tex_res->id * SQ_TEX_RESOURCE_offset, 7);
    E32(ib, sq_tex_resource_word0);
    E32(ib, sq_tex_resource_word1);
    E32(ib, ((tex_res->base) >> 8));
    E32(ib, ((tex_res->mip_base) >> 8));
    E32(ib, sq_tex_resource_word4);
    E32(ib, sq_tex_resource_word5);
    E32(ib, sq_tex_resource_word6);
d631 1
a631 1
r600_set_tex_sampler (ScrnInfoPtr pScrn, drmBufPtr ib, tex_sampler_t *s)
d674 4
a677 4
    PACK0(ib, SQ_TEX_SAMPLER_WORD + s->id * SQ_TEX_SAMPLER_WORD_offset, 3);
    E32(ib, sq_tex_sampler_word0);
    E32(ib, sq_tex_sampler_word1);
    E32(ib, sq_tex_sampler_word2);
d683 1
a683 1
r600_set_screen_scissor(ScrnInfoPtr pScrn, drmBufPtr ib, int x1, int y1, int x2, int y2)
d688 2
a689 2
    PACK0(ib, PA_SC_SCREEN_SCISSOR_TL, 2);
    E32(ib, ((x1 << PA_SC_SCREEN_SCISSOR_TL__TL_X_shift) |
d691 1
a691 1
    E32(ib, ((x2 << PA_SC_SCREEN_SCISSOR_BR__BR_X_shift) |
d697 1
a697 1
r600_set_vport_scissor(ScrnInfoPtr pScrn, drmBufPtr ib, int id, int x1, int y1, int x2, int y2)
d702 2
a703 2
    PACK0(ib, PA_SC_VPORT_SCISSOR_0_TL + id * PA_SC_VPORT_SCISSOR_0_TL_offset, 2);
    E32(ib, ((x1 << PA_SC_VPORT_SCISSOR_0_TL__TL_X_shift) |
d706 1
a706 1
    E32(ib, ((x2 << PA_SC_VPORT_SCISSOR_0_BR__BR_X_shift) |
d712 1
a712 1
r600_set_generic_scissor(ScrnInfoPtr pScrn, drmBufPtr ib, int x1, int y1, int x2, int y2)
d717 2
a718 2
    PACK0(ib, PA_SC_GENERIC_SCISSOR_TL, 2);
    E32(ib, ((x1 << PA_SC_GENERIC_SCISSOR_TL__TL_X_shift) |
d721 1
a721 1
    E32(ib, ((x2 << PA_SC_GENERIC_SCISSOR_BR__BR_X_shift) |
d727 1
a727 1
r600_set_window_scissor(ScrnInfoPtr pScrn, drmBufPtr ib, int x1, int y1, int x2, int y2)
d732 2
a733 2
    PACK0(ib, PA_SC_WINDOW_SCISSOR_TL, 2);
    E32(ib, ((x1 << PA_SC_WINDOW_SCISSOR_TL__TL_X_shift) |
d736 1
a736 1
    E32(ib, ((x2 << PA_SC_WINDOW_SCISSOR_BR__BR_X_shift) |
d742 1
a742 1
r600_set_clip_rect(ScrnInfoPtr pScrn, drmBufPtr ib, int id, int x1, int y1, int x2, int y2)
d747 2
a748 2
    PACK0(ib, PA_SC_CLIPRECT_0_TL + id * PA_SC_CLIPRECT_0_TL_offset, 2);
    E32(ib, ((x1 << PA_SC_CLIPRECT_0_TL__TL_X_shift) |
d750 1
a750 1
    E32(ib, ((x2 << PA_SC_CLIPRECT_0_BR__BR_X_shift) |
d760 1
a760 1
r600_set_default_state(ScrnInfoPtr pScrn, drmBufPtr ib)
d777 1
a777 1
    r600_start_3d(pScrn, accel_state->ib);
d901 1
a901 1
    r600_sq_setup(pScrn, ib, &sq_conf);
d905 1
a905 1
    EREG(ib, DB_DEPTH_INFO, 0);
d911 1
a911 1
	EREG(ib, TA_CNTL_AUX, (( 3 << GRADIENT_CREDIT_shift) |
d913 4
a916 4
	EREG(ib, VC_ENHANCE, 0);
	EREG(ib, R7xx_SQ_DYN_GPR_CNTL_PS_FLUSH_REQ, 0);
	EREG(ib, DB_DEBUG, 0x82000000); /* ? */
	EREG(ib, DB_WATERMARKS, ((4 << DEPTH_FREE_shift) |
d923 1
a923 1
	EREG(ib, TA_CNTL_AUX, (( 2 << GRADIENT_CREDIT_shift) |
d925 4
a928 4
	EREG(ib, VC_ENHANCE, 0);
	EREG(ib, R7xx_SQ_DYN_GPR_CNTL_PS_FLUSH_REQ, VS_PC_LIMIT_ENABLE_bit);
	EREG(ib, DB_DEBUG, 0);
	EREG(ib, DB_WATERMARKS, ((4 << DEPTH_FREE_shift) |
d936 14
a949 14
    PACK0(ib, SQ_VTX_BASE_VTX_LOC, 2);
    E32(ib, 0);
    E32(ib, 0);

    PACK0(ib, SQ_ESGS_RING_ITEMSIZE, 9);
    E32(ib, 0); // SQ_ESGS_RING_ITEMSIZE
    E32(ib, 0); // SQ_GSVS_RING_ITEMSIZE
    E32(ib, 0); // SQ_ESTMP_RING_ITEMSIZE
    E32(ib, 0); // SQ_GSTMP_RING_ITEMSIZE
    E32(ib, 0); // SQ_VSTMP_RING_ITEMSIZE
    E32(ib, 0); // SQ_PSTMP_RING_ITEMSIZE
    E32(ib, 0); // SQ_FBUF_RING_ITEMSIZE
    E32(ib, 0); // SQ_REDUC_RING_ITEMSIZE
    E32(ib, 0); // SQ_GS_VERT_ITEMSIZE
d952 3
a954 3
    EREG(ib, DB_DEPTH_CONTROL,                    0);
    PACK0(ib, DB_RENDER_CONTROL, 2);
    E32(ib, STENCIL_COMPRESS_DISABLE_bit | DEPTH_COMPRESS_DISABLE_bit);
d956 1
a956 1
	E32(ib, FORCE_SHADER_Z_ORDER_bit);
d958 2
a959 2
	E32(ib, 0);
    EREG(ib, DB_ALPHA_TO_MASK,                    ((2 << ALPHA_TO_MASK_OFFSET0_shift)	|
d963 1
a963 1
    EREG(ib, DB_SHADER_CONTROL, ((1 << Z_ORDER_shift) | /* EARLY_Z_THEN_LATE_Z */
d966 24
a989 24
    PACK0(ib, DB_STENCIL_CLEAR, 2);
    E32(ib, 0); // DB_STENCIL_CLEAR
    E32(ib, 0); // DB_DEPTH_CLEAR

    PACK0(ib, DB_STENCILREFMASK, 3);
    E32(ib, 0); // DB_STENCILREFMASK
    E32(ib, 0); // DB_STENCILREFMASK_BF
    E32(ib, 0); // SX_ALPHA_REF

    PACK0(ib, CB_CLRCMP_CONTROL, 4);
    E32(ib, 1 << CLRCMP_FCN_SEL_shift);				// CB_CLRCMP_CONTROL: use CLRCMP_FCN_SRC
    E32(ib, 0);							// CB_CLRCMP_SRC
    E32(ib, 0);							// CB_CLRCMP_DST
    E32(ib, 0);							// CB_CLRCMP_MSK

    EREG(ib, CB_SHADER_MASK,                      OUTPUT0_ENABLE_mask);
    EREG(ib, R7xx_CB_SHADER_CONTROL,              (RT0_ENABLE_bit));

    PACK0(ib, SX_ALPHA_TEST_CONTROL, 5);
    E32(ib, 0); // SX_ALPHA_TEST_CONTROL
    E32(ib, 0x00000000); // CB_BLEND_RED
    E32(ib, 0x00000000); // CB_BLEND_GREEN
    E32(ib, 0x00000000); // CB_BLEND_BLUE
    E32(ib, 0x00000000); // CB_BLEND_ALPHA
d991 1
a991 1
    EREG(ib, PA_SC_WINDOW_OFFSET,                 ((0 << WINDOW_X_OFFSET_shift) |
d995 1
a995 1
	EREG(ib, R7xx_PA_SC_EDGERULE,             0x00000000);
d997 1
a997 1
	EREG(ib, R7xx_PA_SC_EDGERULE,             0xAAAAAAAA);
d999 1
a999 1
    EREG(ib, PA_SC_CLIPRECT_RULE,                 CLIP_RULE_mask);
d1005 1
a1005 1
	r600_set_clip_rect(pScrn, ib, i, 0, 0, 8192, 8192);
d1008 1
a1008 1
	r600_set_vport_scissor(pScrn, ib, i, 0, 0, 8192, 8192);
d1011 2
a1012 2
    PACK0(ib, PA_SC_MPASS_PS_CNTL, 2);
    E32(ib, 0);
d1014 1
a1014 1
	E32(ib, (WALK_ORDER_ENABLE_bit | FORCE_EOV_CNTDWN_ENABLE_bit));
d1016 1
a1016 1
	E32(ib, (FORCE_EOV_CNTDWN_ENABLE_bit | FORCE_EOV_REZ_ENABLE_bit |
d1019 4
a1022 4
    PACK0(ib, PA_SC_LINE_CNTL, 9);
    E32(ib, 0); // PA_SC_LINE_CNTL
    E32(ib, 0); // PA_SC_AA_CONFIG
    E32(ib, ((2 << PA_SU_VTX_CNTL__ROUND_MODE_shift) | PIX_CENTER_bit | // PA_SU_VTX_CNTL
d1024 23
a1046 23
    EFLOAT(ib, 1.0);						// PA_CL_GB_VERT_CLIP_ADJ
    EFLOAT(ib, 1.0);						// PA_CL_GB_VERT_DISC_ADJ
    EFLOAT(ib, 1.0);						// PA_CL_GB_HORZ_CLIP_ADJ
    EFLOAT(ib, 1.0);						// PA_CL_GB_HORZ_DISC_ADJ
    E32(ib, 0);                                                 // PA_SC_AA_SAMPLE_LOCS_MCTX
    E32(ib, 0);                                                 // PA_SC_AA_SAMPLE_LOCS_8S_WD1_M

    EREG(ib, PA_SC_AA_MASK,                       0xFFFFFFFF);

    PACK0(ib, PA_CL_CLIP_CNTL, 5);
    E32(ib, CLIP_DISABLE_bit); // PA_CL_CLIP_CNTL
    E32(ib, FACE_bit);         // PA_SU_SC_MODE_CNTL
    E32(ib, VTX_XY_FMT_bit);   // PA_CL_VTE_CNTL
    E32(ib, 0);                // PA_CL_VS_OUT_CNTL
    E32(ib, 0);                // PA_CL_NANINF_CNTL

    PACK0(ib, PA_SU_POLY_OFFSET_DB_FMT_CNTL, 6);
    E32(ib, 0); // PA_SU_POLY_OFFSET_DB_FMT_CNTL
    E32(ib, 0); // PA_SU_POLY_OFFSET_CLAMP
    E32(ib, 0); // PA_SU_POLY_OFFSET_FRONT_SCALE
    E32(ib, 0); // PA_SU_POLY_OFFSET_FRONT_OFFSET
    E32(ib, 0); // PA_SU_POLY_OFFSET_BACK_SCALE
    E32(ib, 0); // PA_SU_POLY_OFFSET_BACK_OFFSET
d1050 1
a1050 1
	EREG(ib, R7xx_SPI_THREAD_GROUPING,        0);
d1052 1
a1052 1
	EREG(ib, R7xx_SPI_THREAD_GROUPING,        (1 << PS_GROUPING_shift));
d1055 1
a1055 1
    EREG(ib, SPI_VS_OUT_ID_0, ((0 << SEMANTIC_0_shift) |
d1057 1
a1057 1
    PACK0(ib, SPI_PS_INPUT_CNTL_0 + (0 << 2), 2);
d1059 1
a1059 1
    E32(ib, ((0    << SEMANTIC_shift)	|
d1063 1
a1063 1
    E32(ib, ((1    << SEMANTIC_shift)	|
d1067 5
a1071 5
    PACK0(ib, SPI_INPUT_Z, 4);
    E32(ib, 0); // SPI_INPUT_Z
    E32(ib, 0); // SPI_FOG_CNTL
    E32(ib, 0); // SPI_FOG_FUNC_SCALE
    E32(ib, 0); // SPI_FOG_FUNC_BIAS
d1077 1
a1077 1
    r600_fs_setup(pScrn, ib, &fs_conf, RADEON_GEM_DOMAIN_VRAM);
d1081 36
a1116 36
    PACK0(ib, VGT_MAX_VTX_INDX, 4);
    E32(ib, 0xffffff); // VGT_MAX_VTX_INDX
    E32(ib, 0); // VGT_MIN_VTX_INDX
    E32(ib, 0); // VGT_INDX_OFFSET
    E32(ib, 0); // VGT_MULTI_PRIM_IB_RESET_INDX

    EREG(ib, VGT_PRIMITIVEID_EN,                  0);
    EREG(ib, VGT_MULTI_PRIM_IB_RESET_EN,          0);

    PACK0(ib, VGT_INSTANCE_STEP_RATE_0, 2);
    E32(ib, 0); // VGT_INSTANCE_STEP_RATE_0
    E32(ib, 0); // VGT_INSTANCE_STEP_RATE_1

    PACK0(ib, PA_SU_POINT_SIZE, 17);
    E32(ib, 0); // PA_SU_POINT_SIZE
    E32(ib, 0); // PA_SU_POINT_MINMAX
    E32(ib, (8 << PA_SU_LINE_CNTL__WIDTH_shift)); /* Line width 1 pixel */ // PA_SU_LINE_CNTL
    E32(ib, 0); // PA_SC_LINE_STIPPLE
    E32(ib, 0); // VGT_OUTPUT_PATH_CNTL
    E32(ib, 0); // VGT_HOS_CNTL
    E32(ib, 0); // VGT_HOS_MAX_TESS_LEVEL
    E32(ib, 0); // VGT_HOS_MIN_TESS_LEVEL
    E32(ib, 0); // VGT_HOS_REUSE_DEPTH
    E32(ib, 0); // VGT_GROUP_PRIM_TYPE
    E32(ib, 0); // VGT_GROUP_FIRST_DECR
    E32(ib, 0); // VGT_GROUP_DECR
    E32(ib, 0); // VGT_GROUP_VECT_0_CNTL
    E32(ib, 0); // VGT_GROUP_VECT_1_CNTL
    E32(ib, 0); // VGT_GROUP_VECT_0_FMT_CNTL
    E32(ib, 0); // VGT_GROUP_VECT_1_FMT_CNTL
    E32(ib, 0); // VGT_GS_MODE

    PACK0(ib, VGT_STRMOUT_EN, 3);
    E32(ib, 0); // VGT_STRMOUT_EN
    E32(ib, 0); // VGT_REUSE_OFF
    E32(ib, 0); // VGT_VTX_CNT_EN
d1118 2
a1119 2
    EREG(ib, VGT_STRMOUT_BUFFER_EN,               0);
    EREG(ib, SX_MISC,                             0);
d1129 1
a1129 1
r600_draw_immd(ScrnInfoPtr pScrn, drmBufPtr ib, draw_config_t *draw_conf, uint32_t *indices)
d1142 2
a1143 2
    EREG(ib, VGT_PRIMITIVE_TYPE, draw_conf->prim_type);
    PACK3(ib, IT_INDEX_TYPE, 1);
d1145 1
a1145 1
    E32(ib, IT_INDEX_TYPE_SWAP_MODE(ENDIAN_8IN32) | draw_conf->index_type);
d1147 1
a1147 1
    E32(ib, draw_conf->index_type);
d1149 2
a1150 2
    PACK3(ib, IT_NUM_INSTANCES, 1);
    E32(ib, draw_conf->num_instances);
d1152 3
a1154 3
    PACK3(ib, IT_DRAW_INDEX_IMMD, count);
    E32(ib, draw_conf->num_indices);
    E32(ib, draw_conf->vgt_draw_initiator);
d1159 1
a1159 1
		E32(ib, indices[i]);
d1161 1
a1161 1
		E32(ib, (indices[i] | (indices[i + 1] << 16)));
d1165 1
a1165 1
	    E32(ib, indices[i]);
d1171 1
a1171 1
r600_draw_auto(ScrnInfoPtr pScrn, drmBufPtr ib, draw_config_t *draw_conf)
d1176 2
a1177 2
    EREG(ib, VGT_PRIMITIVE_TYPE, draw_conf->prim_type);
    PACK3(ib, IT_INDEX_TYPE, 1);
d1179 1
a1179 1
    E32(ib, IT_INDEX_TYPE_SWAP_MODE(ENDIAN_8IN32) | draw_conf->index_type);
d1181 1
a1181 1
    E32(ib, draw_conf->index_type);
d1183 5
a1187 5
    PACK3(ib, IT_NUM_INSTANCES, 1);
    E32(ib, draw_conf->num_instances);
    PACK3(ib, IT_DRAW_INDEX_AUTO, 2);
    E32(ib, draw_conf->num_indices);
    E32(ib, draw_conf->vgt_draw_initiator);
d1205 1
a1205 1
        R600IBDiscard(pScrn, accel_state->ib);
d1215 1
a1215 1
    vtx_res.vb_addr         = accel_state->vbo.vb_mc_addr + accel_state->vbo.vb_start_op;
d1220 1
a1220 1
    r600_set_vtx_resource(pScrn, accel_state->ib, &vtx_res, RADEON_GEM_DOMAIN_GTT);
d1229 1
a1229 1
    r600_draw_auto(pScrn, accel_state->ib, &draw_conf);
d1232 1
a1232 1
    r600_wait_3d_idle_clean(pScrn, accel_state->ib);
d1235 2
a1236 2
    r600_cp_set_surface_sync(pScrn, accel_state->ib, (CB_ACTION_ENA_bit | CB0_DEST_BASE_ENA_bit),
			     accel_state->dst_size, accel_state->dst_obj.offset,
a1241 4
#if KMS_MULTI_OP
    if (!info->cs)
#endif
	R600CPFlushIndirect(pScrn, accel_state->ib);
@


1.4
log
@Re-update xf86-video-ati to 6.14.3.

Because of ati.c revision 1.5, it will not be selected by
autoconfiguration code, so people who want to run this version of the
driver on their radeon cards need an explicit "Device" section in
xorg.conf.
@
text
@d226 1
a226 1
    int pitch, slice, h;
d229 25
d256 1
a256 1
		     (cb_conf->array_mode  << CB_COLOR0_INFO__ARRAY_MODE_shift)		|
a278 4
    pitch = (cb_conf->w / 8) - 1;
    h = RADEON_ALIGN(cb_conf->h, 8);
    slice = ((cb_conf->w * h) / 64) - 1;

a368 3
    if (stop < start)
        return;

d388 2
a389 2
    start = max(start, 0);
    stop = min(stop, crtc->mode.VDisplay);
d391 1
a391 1
    if (start > crtc->mode.VDisplay)
a393 4
    /* on r5xx+ vline starts at viewport_y */
    start += crtc->y;
    stop += crtc->y;

d626 22
d650 1
a650 1
			     (tex_res->tile_mode << SQ_TEX_RESOURCE_WORD0_0__TILE_MODE_shift));
d653 1
a653 1
	sq_tex_resource_word0 |= (((((tex_res->pitch + 7) >> 3) - 1) << PITCH_shift) |
d1164 1
a1164 1
    BEGIN_BATCH(43);
d1203 1
@


1.3
log
@Revert the update to xf86-video-ati 6.14.3. Requested by espie@@
who experiemnts regressions with this driver.
@
text
@d41 25
d75 7
d88 1
d90 1
d93 3
d110 6
d123 1
a123 1
wait_3d_idle_clean(ScrnInfoPtr pScrn, drmBufPtr ib)
d125 1
d128 1
d134 1
d138 1
a138 1
wait_3d_idle(ScrnInfoPtr pScrn, drmBufPtr ib)
d140 1
d142 1
d144 1
a144 70

}

static void
reset_cb(ScrnInfoPtr pScrn, drmBufPtr ib)
{
    int i;

    PACK0(ib, CB_COLOR0_INFO, 8);
    for (i = 0; i < 8; i++)
	E32(ib, 0);
}

static void
reset_td_samplers(ScrnInfoPtr pScrn, drmBufPtr ib)
{
    int i;

    wait_3d_idle(pScrn, ib);

    PACK0(ib, TD_PS_SAMPLER0_BORDER_RED, 4*TD_PS_SAMPLER0_BORDER_RED_num);
    for (i = 0; i < 4*TD_PS_SAMPLER0_BORDER_RED_num; i++)
	E32(ib, 0);
    PACK0(ib, TD_VS_SAMPLER0_BORDER_RED, 4*TD_VS_SAMPLER0_BORDER_RED_num);
    for (i = 0; i < 4*TD_VS_SAMPLER0_BORDER_RED_num; i++)
	E32(ib, 0);

    wait_3d_idle(pScrn, ib);
}

static void
reset_sampler_const (ScrnInfoPtr pScrn, drmBufPtr ib)
{
    int i;

    for (i = 0; i < SQ_TEX_SAMPLER_WORD_all_num; i++) {
	PACK0(ib, SQ_TEX_SAMPLER_WORD + i * SQ_TEX_SAMPLER_WORD_offset, 3);
	E32(ib, SQ_TEX_DEPTH_COMPARE_LESSEQUAL << DEPTH_COMPARE_FUNCTION_shift);
	E32(ib, MAX_LOD_mask);
	E32(ib, 0);
    }
}

static void
reset_dx9_alu_consts(ScrnInfoPtr pScrn, drmBufPtr ib)
{
    int i;

    const int count = SQ_ALU_CONSTANT_all_num * (SQ_ALU_CONSTANT_offset >> 2);

    PACK0(ib, SQ_ALU_CONSTANT, count);
    for (i = 0; i < count; i++)
	EFLOAT(ib, 0.0);
}

static void
reset_bool_loop_const(ScrnInfoPtr pScrn, drmBufPtr ib)
{
    int i;


    PACK0(ib, SQ_BOOL_CONST, SQ_BOOL_CONST_all_num);
    for (i = 0; i < SQ_BOOL_CONST_all_num; i++)
	E32(ib, 0);

    PACK0(ib, SQ_LOOP_CONST, SQ_LOOP_CONST_all_num);

    for (i = 0; i < SQ_LOOP_CONST_all_num; i++)
	E32(ib, 0);

d148 1
a148 1
start_3d(ScrnInfoPtr pScrn, drmBufPtr ib)
d153 1
d156 2
a157 1
    }
d162 1
a163 1
    wait_3d_idle_clean (pScrn, ib);
d172 1
a172 1
sq_setup(ScrnInfoPtr pScrn, drmBufPtr ib, sq_config_t *sq_conf)
d181 1
d211 1
d219 1
a219 1

d223 1
a223 1
set_render_target(ScrnInfoPtr pScrn, drmBufPtr ib, cb_config_t *cb_conf)
d225 1
a225 1
    uint32_t cb_color_info;
d255 1
a255 1
    h = (cb_conf->h + 7) & ~7;
d258 1
d260 2
d265 5
a269 3
	(info->ChipFamily < CHIP_FAMILY_RV770)) {
	PACK3(ib, IT_SURFACE_BASE_UPDATE, 1);
	E32(ib, (2 << cb_conf->id));
d271 13
a283 1

a288 3
    EREG(ib, (CB_COLOR0_INFO + (4 * cb_conf->id)), cb_color_info);
    EREG(ib, (CB_COLOR0_TILE + (4 * cb_conf->id)), (0     >> 8));	// CMASK per-tile data base/256
    EREG(ib, (CB_COLOR0_FRAG + (4 * cb_conf->id)), (0     >> 8));	// FMASK per-tile data base/256
d291 22
d315 4
a318 2
void
cp_set_surface_sync(ScrnInfoPtr pScrn, drmBufPtr ib, uint32_t sync_type, uint32_t size, uint64_t mc_addr)
d320 1
d327 1
d333 2
d338 3
a340 2
void cp_wait_vline_sync(ScrnInfoPtr pScrn, drmBufPtr ib, PixmapPtr pPix,
	int crtc, int start, int stop)
a342 1
    xf86CrtcConfigPtr  xf86_config = XF86_CRTC_CONFIG_PTR(pScrn);
a343 1
    RADEONCrtcPrivatePtr radeon_crtc;
d345 1
a345 1
    if ((crtc < 0) || (crtc > 1))
d351 1
a351 1
    if (!xf86_config->crtc[crtc]->enabled)
d354 4
d359 3
a361 3
    if (info->useEXA)
        offset = exaGetPixmapOffset(pPix);
    else
d363 1
a363 1
        offset = pPix->devPrivate.ptr - info->FB;
d365 4
a368 3
    /* if drawing to front buffer */
    if (offset != 0)
        return;
d371 1
a371 1
    stop = min(stop, xf86_config->crtc[crtc]->mode.VDisplay);
d373 1
a373 1
    if (start > xf86_config->crtc[crtc]->mode.VDisplay)
d376 48
a423 1
    radeon_crtc = xf86_config->crtc[crtc]->driver_private;
d425 11
a435 9
    /* set the VLINE range */
    EREG(ib, AVIVO_D1MODE_VLINE_START_END + radeon_crtc->crtc_offset,
         (start << AVIVO_D1MODE_VLINE_START_SHIFT) |
         (stop << AVIVO_D1MODE_VLINE_END_SHIFT));

    /* tell the CP to poll the VLINE state register */
    PACK3(ib, IT_WAIT_REG_MEM, 6);
    E32(ib, IT_WAIT_REG | IT_WAIT_EQ);
    E32(ib, IT_WAIT_ADDR(AVIVO_D1MODE_VLINE_STATUS + radeon_crtc->crtc_offset));
d437 1
a437 3
    E32(ib, 0);                          // Ref value
    E32(ib, AVIVO_D1MODE_VLINE_STAT);    // Mask
    E32(ib, 10);                         // Wait interval
d441 1
a441 1
fs_setup(ScrnInfoPtr pScrn, drmBufPtr ib, shader_config_t *fs_conf)
d443 1
d452 1
d454 4
d460 1
d464 1
a464 1
vs_setup(ScrnInfoPtr pScrn, drmBufPtr ib, shader_config_t *vs_conf)
d466 1
d479 6
d486 4
d492 1
d496 1
a496 1
ps_setup(ScrnInfoPtr pScrn, drmBufPtr ib, shader_config_t *ps_conf)
d498 1
d513 6
d520 4
d527 1
d531 1
a531 1
set_alu_consts(ScrnInfoPtr pScrn, drmBufPtr ib, int offset, int count, float *const_buf)
d533 1
d537 1
d541 1
d545 1
a545 1
set_bool_consts(ScrnInfoPtr pScrn, drmBufPtr ib, int offset, uint32_t val)
d547 1
d551 1
d553 1
d556 2
a557 2
void
set_vtx_resource(ScrnInfoPtr pScrn, drmBufPtr ib, vtx_resource_t *res)
d559 2
d577 17
d602 2
d607 1
a607 1
set_tex_resource(ScrnInfoPtr pScrn, drmBufPtr ib, tex_resource_t *tex_res)
d609 1
d659 6
d673 3
d679 1
a679 1
set_tex_sampler (ScrnInfoPtr pScrn, drmBufPtr ib, tex_sampler_t *s)
d681 1
d721 1
d726 1
d731 1
a731 1
set_screen_scissor(ScrnInfoPtr pScrn, drmBufPtr ib, int x1, int y1, int x2, int y2)
d733 1
d735 7
a741 4
    EREG(ib, PA_SC_SCREEN_SCISSOR_TL,              ((x1 << PA_SC_SCREEN_SCISSOR_TL__TL_X_shift) |
						    (y1 << PA_SC_SCREEN_SCISSOR_TL__TL_Y_shift)));
    EREG(ib, PA_SC_SCREEN_SCISSOR_BR,              ((x2 << PA_SC_SCREEN_SCISSOR_BR__BR_X_shift) |
						    (y2 << PA_SC_SCREEN_SCISSOR_BR__BR_Y_shift)));
d745 1
a745 1
set_vport_scissor(ScrnInfoPtr pScrn, drmBufPtr ib, int id, int x1, int y1, int x2, int y2)
d747 1
d749 8
a756 7
    EREG(ib, PA_SC_VPORT_SCISSOR_0_TL +
	 id * PA_SC_VPORT_SCISSOR_0_TL_offset, ((x1 << PA_SC_VPORT_SCISSOR_0_TL__TL_X_shift) |
						(y1 << PA_SC_VPORT_SCISSOR_0_TL__TL_Y_shift) |
						WINDOW_OFFSET_DISABLE_bit));
    EREG(ib, PA_SC_VPORT_SCISSOR_0_BR +
	 id * PA_SC_VPORT_SCISSOR_0_BR_offset, ((x2 << PA_SC_VPORT_SCISSOR_0_BR__BR_X_shift) |
						(y2 << PA_SC_VPORT_SCISSOR_0_BR__BR_Y_shift)));
d760 1
a760 1
set_generic_scissor(ScrnInfoPtr pScrn, drmBufPtr ib, int x1, int y1, int x2, int y2)
d762 1
d764 8
a771 5
    EREG(ib, PA_SC_GENERIC_SCISSOR_TL,            ((x1 << PA_SC_GENERIC_SCISSOR_TL__TL_X_shift) |
						   (y1 << PA_SC_GENERIC_SCISSOR_TL__TL_Y_shift) |
						   WINDOW_OFFSET_DISABLE_bit));
    EREG(ib, PA_SC_GENERIC_SCISSOR_BR,            ((x2 << PA_SC_GENERIC_SCISSOR_BR__BR_X_shift) |
						   (y2 << PA_SC_GENERIC_SCISSOR_TL__TL_Y_shift)));
d775 1
a775 1
set_window_scissor(ScrnInfoPtr pScrn, drmBufPtr ib, int x1, int y1, int x2, int y2)
d777 1
d779 8
a786 5
    EREG(ib, PA_SC_WINDOW_SCISSOR_TL,             ((x1 << PA_SC_WINDOW_SCISSOR_TL__TL_X_shift) |
						   (y1 << PA_SC_WINDOW_SCISSOR_TL__TL_Y_shift) |
						   WINDOW_OFFSET_DISABLE_bit));
    EREG(ib, PA_SC_WINDOW_SCISSOR_BR,             ((x2 << PA_SC_WINDOW_SCISSOR_BR__BR_X_shift) |
						   (y2 << PA_SC_WINDOW_SCISSOR_BR__BR_Y_shift)));
d790 1
a790 1
set_clip_rect(ScrnInfoPtr pScrn, drmBufPtr ib, int id, int x1, int y1, int x2, int y2)
d792 1
d794 7
a800 6
    EREG(ib, PA_SC_CLIPRECT_0_TL +
	 id * PA_SC_CLIPRECT_0_TL_offset,     ((x1 << PA_SC_CLIPRECT_0_TL__TL_X_shift) |
					       (y1 << PA_SC_CLIPRECT_0_TL__TL_Y_shift)));
    EREG(ib, PA_SC_CLIPRECT_0_BR +
	 id * PA_SC_CLIPRECT_0_BR_offset,     ((x2 << PA_SC_CLIPRECT_0_BR__BR_X_shift) |
					       (y2 << PA_SC_CLIPRECT_0_BR__BR_Y_shift)));
d808 1
a808 1
set_default_state(ScrnInfoPtr pScrn, drmBufPtr ib)
d817 3
a822 5
#if 1
    if (accel_state->XInited3D)
	return;
#endif

d825 1
a825 33
    wait_3d_idle(pScrn, ib);

    // ASIC specific setup, see drm
    if (info->ChipFamily < CHIP_FAMILY_RV770) {
	EREG(ib, TA_CNTL_AUX,                     (( 3 << GRADIENT_CREDIT_shift)		|
						   (28 << TD_FIFO_CREDIT_shift)));
	EREG(ib, VC_ENHANCE,                      0);
	EREG(ib, R7xx_SQ_DYN_GPR_CNTL_PS_FLUSH_REQ, 0);
	EREG(ib, DB_DEBUG,                        0x82000000); /* ? */
	EREG(ib, DB_WATERMARKS,		        ((4  << DEPTH_FREE_shift)		|
						 (16 << DEPTH_FLUSH_shift)		|
						 (0  << FORCE_SUMMARIZE_shift)		|
						 (4  << DEPTH_PENDING_FREE_shift)	|
						 (16 << DEPTH_CACHELINE_FREE_shift)	|
						 0));
    } else {
	EREG(ib, TA_CNTL_AUX,                      (( 2 << GRADIENT_CREDIT_shift)		|
						    (28 << TD_FIFO_CREDIT_shift)));
	EREG(ib, VC_ENHANCE,                       0);
	EREG(ib, R7xx_SQ_DYN_GPR_CNTL_PS_FLUSH_REQ, VS_PC_LIMIT_ENABLE_bit);
	EREG(ib, DB_DEBUG,                         0);
	EREG(ib, DB_WATERMARKS,                    ((4  << DEPTH_FREE_shift)		|
						    (16 << DEPTH_FLUSH_shift)		|
						    (0  << FORCE_SUMMARIZE_shift)		|
						    (4  << DEPTH_PENDING_FREE_shift)	|
						    (4  << DEPTH_CACHELINE_FREE_shift)	|
						    0));
    }

    reset_td_samplers(pScrn, ib);
    reset_dx9_alu_consts(pScrn, ib);
    reset_bool_loop_const (pScrn, ib);
    reset_sampler_const (pScrn, ib);
d870 1
d917 1
d949 1
a949 1
    sq_setup(pScrn, ib, &sq_conf);
d951 36
a986 2
    EREG(ib, SQ_VTX_BASE_VTX_LOC,                 0);
    EREG(ib, SQ_VTX_START_INST_LOC,               0);
d989 9
a997 9
    E32(ib, 0);							// SQ_ESGS_RING_ITEMSIZE
    E32(ib, 0);							// SQ_GSVS_RING_ITEMSIZE
    E32(ib, 0);							// SQ_ESTMP_RING_ITEMSIZE
    E32(ib, 0);							// SQ_GSTMP_RING_ITEMSIZE
    E32(ib, 0);							// SQ_VSTMP_RING_ITEMSIZE
    E32(ib, 0);							// SQ_PSTMP_RING_ITEMSIZE
    E32(ib, 0);							// SQ_FBUF_RING_ITEMSIZE
    E32(ib, 0);							// SQ_REDUC_RING_ITEMSIZE
    E32(ib, 0);							// SQ_GS_VERT_ITEMSIZE
a999 5
    EREG(ib, DB_DEPTH_INFO,                       0);
    EREG(ib, DB_STENCIL_CLEAR,                    0);
    EREG(ib, DB_DEPTH_CLEAR,                      0);
    EREG(ib, DB_STENCILREFMASK,                   0);
    EREG(ib, DB_STENCILREFMASK_BF,                0);
d1001 2
a1002 1
    EREG(ib, DB_RENDER_CONTROL,                   STENCIL_COMPRESS_DISABLE_bit | DEPTH_COMPRESS_DISABLE_bit);
d1004 1
a1004 1
	EREG(ib, DB_RENDER_OVERRIDE,              FORCE_SHADER_Z_ORDER_bit);
d1006 1
a1006 1
	EREG(ib, DB_RENDER_OVERRIDE,              0);
d1011 2
d1014 8
a1021 29
    // SX
    EREG(ib, SX_ALPHA_TEST_CONTROL,               0);
    EREG(ib, SX_ALPHA_REF,                        0);

    // CB
    reset_cb(pScrn, ib);

    PACK0(ib, CB_BLEND_RED, 4);
    E32(ib, 0x00000000);
    E32(ib, 0x00000000);
    E32(ib, 0x00000000);
    E32(ib, 0x00000000);

    /* CB_COLOR_CONTROL.PER_MRT_BLEND is off */
    // RV6xx+ have per-MRT blend
    if (info->ChipFamily > CHIP_FAMILY_R600) {
	PACK0(ib, CB_BLEND0_CONTROL, CB_BLEND0_CONTROL_num);
	for (i = 0; i < CB_BLEND0_CONTROL_num; i++)
	    E32(ib, 0);
    }

    EREG(ib, CB_BLEND_CONTROL,                    0);

    if (info->ChipFamily < CHIP_FAMILY_RV770) {
	PACK0(ib, CB_FOG_RED, 3);
	E32(ib, 0x00000000);
	E32(ib, 0x00000000);
	E32(ib, 0x00000000);
    }
a1022 1
    EREG(ib, CB_COLOR_CONTROL,                    0);
d1029 2
d1032 6
a1037 8
    if (info->ChipFamily < CHIP_FAMILY_RV770) {
	PACK0(ib, CB_CLEAR_RED, 4);
	EFLOAT(ib, 1.0);						/* WTF? */
	EFLOAT(ib, 0.0);
	EFLOAT(ib, 1.0);
	EFLOAT(ib, 1.0);
    }
    EREG(ib, CB_TARGET_MASK,                      (0x0f << TARGET0_ENABLE_shift));
a1038 3
    // SC
    set_generic_scissor(pScrn, ib, 0, 0, 8192, 8192);
    set_screen_scissor(pScrn, ib, 0, 0, 8192, 8192);
a1040 7
    set_window_scissor(pScrn, ib, 0, 0, 8192, 8192);

    EREG(ib, PA_SC_CLIPRECT_RULE,                 CLIP_RULE_mask);

    /* clip boolean is set to always visible -> doesn't matter */
    for (i = 0; i < PA_SC_CLIPRECT_0_TL_num; i++)
	set_clip_rect (pScrn, ib, i, 0, 0, 8192, 8192);
d1047 1
a1047 6
    for (i = 0; i < PA_SC_VPORT_SCISSOR_0_TL_num; i++) {
	set_vport_scissor (pScrn, ib, i, 0, 0, 8192, 8192);
	PACK0(ib, PA_SC_VPORT_ZMIN_0 + i * PA_SC_VPORT_ZMIN_0_offset, 2);
	EFLOAT(ib, 0.0);
	EFLOAT(ib, 1.0);
    }
d1049 1
a1049 5
    if (info->ChipFamily < CHIP_FAMILY_RV770)
	EREG(ib, PA_SC_MODE_CNTL,                 (WALK_ORDER_ENABLE_bit | FORCE_EOV_CNTDWN_ENABLE_bit));
    else
	EREG(ib, PA_SC_MODE_CNTL,                 (FORCE_EOV_CNTDWN_ENABLE_bit | FORCE_EOV_REZ_ENABLE_bit |
						   0x00500000)); /* ? */
d1051 3
a1053 3
    EREG(ib, PA_SC_LINE_CNTL,                     0);
    EREG(ib, PA_SC_AA_CONFIG,                     0);
    EREG(ib, PA_SC_AA_MASK,                       0xFFFFFFFF);
d1055 2
a1056 5
    //XXX: double check this
    if (info->ChipFamily > CHIP_FAMILY_R600) {
	EREG(ib, PA_SC_AA_SAMPLE_LOCS_MCTX,       0);
	EREG(ib, PA_SC_AA_SAMPLE_LOCS_8S_WD1_M,   0);
    }
d1058 8
a1065 2
    EREG(ib, PA_SC_LINE_STIPPLE,                  0);
    EREG(ib, PA_SC_MPASS_PS_CNTL,                 0);
d1067 5
a1071 13
    // CL
    PACK0(ib, PA_CL_VPORT_XSCALE_0, 6);
    EFLOAT(ib, 0.0f);						// PA_CL_VPORT_XSCALE
    EFLOAT(ib, 0.0f);						// PA_CL_VPORT_XOFFSET
    EFLOAT(ib, 0.0f);						// PA_CL_VPORT_YSCALE
    EFLOAT(ib, 0.0f);						// PA_CL_VPORT_YOFFSET
    EFLOAT(ib, 0.0f);						// PA_CL_VPORT_ZSCALE
    EFLOAT(ib, 0.0f);						// PA_CL_VPORT_ZOFFSET
    EREG(ib, PA_CL_CLIP_CNTL,                     (CLIP_DISABLE_bit | DX_CLIP_SPACE_DEF_bit));
    EREG(ib, PA_CL_VTE_CNTL,                      0);
    EREG(ib, PA_CL_VS_OUT_CNTL,                   0);
    EREG(ib, PA_CL_NANINF_CNTL,                   0);
    PACK0(ib, PA_CL_GB_VERT_CLIP_ADJ, 4);
d1076 2
d1079 16
a1094 19
    /* user clipping planes are disabled by default */
    PACK0(ib, PA_CL_UCP_0_X, 24);
    for (i = 0; i < 24; i++)
	EFLOAT(ib, 0.0);

    // SU
    EREG(ib, PA_SU_SC_MODE_CNTL,                  FACE_bit);
    EREG(ib, PA_SU_POINT_SIZE,                    0);
    EREG(ib, PA_SU_POINT_MINMAX,                  0);
    EREG(ib, PA_SU_POLY_OFFSET_DB_FMT_CNTL,       0);
    EREG(ib, PA_SU_POLY_OFFSET_BACK_SCALE,        0);
    EREG(ib, PA_SU_POLY_OFFSET_FRONT_SCALE,       0);
    EREG(ib, PA_SU_POLY_OFFSET_BACK_OFFSET,       0);
    EREG(ib, PA_SU_POLY_OFFSET_FRONT_OFFSET,      0);

    EREG(ib, PA_SU_LINE_CNTL,                     (8 << PA_SU_LINE_CNTL__WIDTH_shift)); /* Line width 1 pixel */
    EREG(ib, PA_SU_VTX_CNTL,                      ((2 << PA_SU_VTX_CNTL__ROUND_MODE_shift) |
						   (5 << QUANT_MODE_shift))); /* Round to Even, fixed point 1/256 */
    EREG(ib, PA_SU_POLY_OFFSET_CLAMP,             0);
d1102 20
a1121 13
    EREG(ib, SPI_INTERP_CONTROL_0,                ((2 << PNT_SPRITE_OVRD_X_shift)		|
						   (3 << PNT_SPRITE_OVRD_Y_shift)		|
						   (0 << PNT_SPRITE_OVRD_Z_shift)		|
						   (1 << PNT_SPRITE_OVRD_W_shift))); /* s,t,0,1 */
    EREG(ib, SPI_INPUT_Z,                         0);
    EREG(ib, SPI_FOG_CNTL,                        0);
    EREG(ib, SPI_FOG_FUNC_SCALE,                  0);
    EREG(ib, SPI_FOG_FUNC_BIAS,                   0);

    PACK0(ib, SPI_VS_OUT_ID_0, SPI_VS_OUT_ID_0_num);
    for (i = 0; i < SPI_VS_OUT_ID_0_num; i++)		/* identity mapping */
	E32(ib, 0x03020100 + i*0x04040404);
    EREG(ib, SPI_VS_OUT_CONFIG,                   0);
d1124 2
a1125 1
    fs_setup(pScrn, ib, &fs_conf);
d1128 7
a1134 20
    EREG(ib, VGT_MAX_VTX_INDX,                    2048); /* XXX set to a reasonably large number of indices */
    EREG(ib, VGT_MIN_VTX_INDX,                    0);
    EREG(ib, VGT_INDX_OFFSET,                     0);
    EREG(ib, VGT_INSTANCE_STEP_RATE_0,            0);
    EREG(ib, VGT_INSTANCE_STEP_RATE_1,            0);

    EREG(ib, VGT_MULTI_PRIM_IB_RESET_INDX,        0);
    EREG(ib, VGT_OUTPUT_PATH_CNTL,                0);
    EREG(ib, VGT_GS_MODE,                         0);
    EREG(ib, VGT_HOS_CNTL,                        0);
    EREG(ib, VGT_HOS_MAX_TESS_LEVEL,              0);
    EREG(ib, VGT_HOS_MIN_TESS_LEVEL,              0);
    EREG(ib, VGT_HOS_REUSE_DEPTH,                 0);
    EREG(ib, VGT_GROUP_PRIM_TYPE,                 0);
    EREG(ib, VGT_GROUP_FIRST_DECR,                0);
    EREG(ib, VGT_GROUP_DECR,                      0);
    EREG(ib, VGT_GROUP_VECT_0_CNTL,               0);
    EREG(ib, VGT_GROUP_VECT_1_CNTL,               0);
    EREG(ib, VGT_GROUP_VECT_0_FMT_CNTL,           0);
    EREG(ib, VGT_GROUP_VECT_1_FMT_CNTL,           0);
a1136 10
    EREG(ib, VGT_STRMOUT_EN,                      0);
    EREG(ib, VGT_REUSE_OFF,                       0);
    EREG(ib, VGT_VTX_CNT_EN,                      0);
    EREG(ib, VGT_STRMOUT_BUFFER_EN,               0);

    // clear tex resources - PS
    for (i = 0; i < 16; i++) {
	tex_res.id = i;
	set_tex_resource(pScrn, ib, &tex_res);
    }
d1138 27
a1164 11
    // clear tex resources - VS
    for (i = 160; i < 164; i++) {
	tex_res.id = i;
	set_tex_resource(pScrn, ib, &tex_res);
    }

    // clear tex resources - FS
    for (i = 320; i < 335; i++) {
	tex_res.id = i;
	set_tex_resource(pScrn, ib, &tex_res);
    }
d1166 2
d1176 1
a1176 1
draw_immd(ScrnInfoPtr pScrn, drmBufPtr ib, draw_config_t *draw_conf, uint32_t *indices)
d1178 1
a1180 6
    EREG(ib, VGT_PRIMITIVE_TYPE, draw_conf->prim_type);
    PACK3(ib, IT_INDEX_TYPE, 1);
    E32(ib, draw_conf->index_type);
    PACK3(ib, IT_NUM_INSTANCES, 1);
    E32(ib, draw_conf->num_instances);

d1188 11
d1214 1
d1218 1
a1218 1
draw_auto(ScrnInfoPtr pScrn, drmBufPtr ib, draw_config_t *draw_conf)
d1220 1
d1222 1
d1225 3
d1229 1
d1235 58
d1294 1
@


1.2
log
@Update to xf86-video-ati 6.14.3. Tested by many.
@
text
@a40 25
#include "radeon_vbo.h"
#include "radeon_exa_shared.h"

static const uint32_t R600_ROP[16] = {
    RADEON_ROP3_ZERO, /* GXclear        */
    RADEON_ROP3_DSa,  /* Gxand          */
    RADEON_ROP3_SDna, /* GXandReverse   */
    RADEON_ROP3_S,    /* GXcopy         */
    RADEON_ROP3_DSna, /* GXandInverted  */
    RADEON_ROP3_D,    /* GXnoop         */
    RADEON_ROP3_DSx,  /* GXxor          */
    RADEON_ROP3_DSo,  /* GXor           */
    RADEON_ROP3_DSon, /* GXnor          */
    RADEON_ROP3_DSxn, /* GXequiv        */
    RADEON_ROP3_Dn,   /* GXinvert       */
    RADEON_ROP3_SDno, /* GXorReverse    */
    RADEON_ROP3_Sn,   /* GXcopyInverted */
    RADEON_ROP3_DSno, /* GXorInverted   */
    RADEON_ROP3_DSan, /* GXnand         */
    RADEON_ROP3_ONE,  /* GXset          */
};

/* we try and batch operations together under KMS -
   but it doesn't work yet without misrendering */
#define KMS_MULTI_OP 1
a49 7
#if defined(XF86DRM_MODE)
    if (info->cs) {
	radeon_cs_flush_indirect(pScrn);
	return;
    }
#endif

a55 1
	BEGIN_BATCH(1);
a56 1
	END_BATCH();
a58 3
    info->accel_state->vbo.vb_offset = 0;
    info->accel_state->vbo.vb_start_op = -1;

a72 6
#if defined(XF86DRM_MODE)
    RADEONInfoPtr info = RADEONPTR(pScrn);
    if (info->cs) {
        radeon_ib_discard(pScrn);
    }
#endif
d80 1
a80 1
r600_wait_3d_idle_clean(ScrnInfoPtr pScrn, drmBufPtr ib)
a81 1
    RADEONInfoPtr info = RADEONPTR(pScrn);
a83 1
    BEGIN_BATCH(5);
a88 1
    END_BATCH();
d92 1
a92 1
r600_wait_3d_idle(ScrnInfoPtr pScrn, drmBufPtr ib)
a93 1
    RADEONInfoPtr info = RADEONPTR(pScrn);
a94 1
    BEGIN_BATCH(3);
d96 70
a165 1
    END_BATCH();
d169 1
a169 1
r600_start_3d(ScrnInfoPtr pScrn, drmBufPtr ib)
a173 1
	BEGIN_BATCH(5);
d176 1
a176 2
    } else
	BEGIN_BATCH(3);
a180 1
    END_BATCH();
d182 1
d191 1
a191 1
r600_sq_setup(ScrnInfoPtr pScrn, drmBufPtr ib, sq_config_t *sq_conf)
a199 1
	(info->ChipFamily == CHIP_FAMILY_RS880) ||
a228 1
    BEGIN_BATCH(8);
d236 1
a236 1
    END_BATCH();
d240 1
a240 1
r600_set_render_target(ScrnInfoPtr pScrn, drmBufPtr ib, cb_config_t *cb_conf, uint32_t domain)
d242 1
a242 1
    uint32_t cb_color_info, cb_color_control;
d272 1
a272 1
    h = RADEON_ALIGN(cb_conf->h, 8);
a274 1
    BEGIN_BATCH(3 + 2);
a275 2
    RELOC_BATCH(cb_conf->bo, 0, domain);
    END_BATCH();
d279 3
a281 5
        (info->ChipFamily < CHIP_FAMILY_RV770)) {
        BEGIN_BATCH(2);
        PACK3(ib, IT_SURFACE_BASE_UPDATE, 1);
        E32(ib, (2 << cb_conf->id));
        END_BATCH();
d283 1
a283 13
    /* Set CMASK & TILE buffer to the offset of color buffer as
     * we don't use those this shouldn't cause any issue and we
     * then have a valid cmd stream
     */
    BEGIN_BATCH(3 + 2);
    EREG(ib, (CB_COLOR0_TILE + (4 * cb_conf->id)), (0     >> 8));	// CMASK per-tile data base/256
    RELOC_BATCH(cb_conf->bo, 0, domain);
    END_BATCH();
    BEGIN_BATCH(3 + 2);
    EREG(ib, (CB_COLOR0_FRAG + (4 * cb_conf->id)), (0     >> 8));	// FMASK per-tile data base/256
    RELOC_BATCH(cb_conf->bo, 0, domain);
    END_BATCH();
    BEGIN_BATCH(9);
d289 3
a293 22
    END_BATCH();

    BEGIN_BATCH(3 + 2);
    EREG(ib, (CB_COLOR0_INFO + (4 * cb_conf->id)), cb_color_info);
    RELOC_BATCH(cb_conf->bo, 0, domain);
    END_BATCH();

    BEGIN_BATCH(9);
    EREG(ib, CB_TARGET_MASK,          (cb_conf->pmask << TARGET0_ENABLE_shift));
    cb_color_control = R600_ROP[cb_conf->rop] |
	(cb_conf->blend_enable << TARGET_BLEND_ENABLE_shift);
    if (info->ChipFamily == CHIP_FAMILY_R600) {
	/* no per-MRT blend on R600 */
	EREG(ib, CB_COLOR_CONTROL,    cb_color_control);
	EREG(ib, CB_BLEND_CONTROL,    cb_conf->blendcntl);
    } else {
	if (cb_conf->blend_enable)
	    cb_color_control |= PER_MRT_BLEND_bit;
	EREG(ib, CB_COLOR_CONTROL,    cb_color_control);
	EREG(ib, CB_BLEND0_CONTROL,   cb_conf->blendcntl);
    }
    END_BATCH();
d296 2
a297 4
static void
r600_cp_set_surface_sync(ScrnInfoPtr pScrn, drmBufPtr ib, uint32_t sync_type,
			 uint32_t size, uint64_t mc_addr,
			 struct radeon_bo *bo, uint32_t rdomains, uint32_t wdomain)
a298 1
    RADEONInfoPtr info = RADEONPTR(pScrn);
a304 1
    BEGIN_BATCH(5 + 2);
a309 2
    RELOC_BATCH(bo, rdomains, wdomain);
    END_BATCH();
d313 2
a314 3
void
r600_cp_wait_vline_sync(ScrnInfoPtr pScrn, drmBufPtr ib, PixmapPtr pPix,
			xf86CrtcPtr crtc, int start, int stop)
d317 1
d319 1
d321 1
a321 1
    if (!crtc)
d327 1
a327 1
    if (!crtc->enabled)
a329 4
    if (info->cs) {
        if (pPix != pScrn->pScreen->GetScreenPixmap(pScrn->pScreen))
	    return;
    } else {
d331 3
a333 3
	if (info->useEXA)
	    offset = exaGetPixmapOffset(pPix);
	else
d335 1
a335 1
	    offset = pPix->devPrivate.ptr - info->FB;
d337 3
a339 4
	/* if drawing to front buffer */
	if (offset != 0)
	    return;
    }
d342 1
a342 1
    stop = min(stop, crtc->mode.VDisplay);
d344 1
a344 1
    if (start > crtc->mode.VDisplay)
d347 1
a347 48
    /* on r5xx+ vline starts at viewport_y */
    start += crtc->y;
    stop += crtc->y;

#if defined(XF86DRM_MODE)
    if (info->cs) {
	drmmode_crtc_private_ptr drmmode_crtc = crtc->driver_private;

	BEGIN_BATCH(11);
	/* set the VLINE range */
	EREG(ib, AVIVO_D1MODE_VLINE_START_END, /* this is just a marker */
	     (start << AVIVO_D1MODE_VLINE_START_SHIFT) |
	     (stop << AVIVO_D1MODE_VLINE_END_SHIFT));

	/* tell the CP to poll the VLINE state register */
	PACK3(ib, IT_WAIT_REG_MEM, 6);
	E32(ib, IT_WAIT_REG | IT_WAIT_EQ);
	E32(ib, IT_WAIT_ADDR(AVIVO_D1MODE_VLINE_STATUS));
	E32(ib, 0);
	E32(ib, 0);                          // Ref value
	E32(ib, AVIVO_D1MODE_VLINE_STAT);    // Mask
	E32(ib, 10);                         // Wait interval
	/* add crtc reloc */
	PACK3(ib, IT_NOP, 1);
	E32(ib, drmmode_crtc->mode_crtc->crtc_id);
	END_BATCH();
    } else
#endif
    {
	RADEONCrtcPrivatePtr radeon_crtc = crtc->driver_private;

	BEGIN_BATCH(9);
	/* set the VLINE range */
	EREG(ib, AVIVO_D1MODE_VLINE_START_END + radeon_crtc->crtc_offset,
	     (start << AVIVO_D1MODE_VLINE_START_SHIFT) |
	     (stop << AVIVO_D1MODE_VLINE_END_SHIFT));

	/* tell the CP to poll the VLINE state register */
	PACK3(ib, IT_WAIT_REG_MEM, 6);
	E32(ib, IT_WAIT_REG | IT_WAIT_EQ);
	E32(ib, IT_WAIT_ADDR(AVIVO_D1MODE_VLINE_STATUS + radeon_crtc->crtc_offset));
	E32(ib, 0);
	E32(ib, 0);                          // Ref value
	E32(ib, AVIVO_D1MODE_VLINE_STAT);    // Mask
	E32(ib, 10);                         // Wait interval
	END_BATCH();
    }
}
d349 9
a357 11
void
r600_set_spi(ScrnInfoPtr pScrn, drmBufPtr ib, int vs_export_count, int num_interp)
{
    RADEONInfoPtr info = RADEONPTR(pScrn);

    BEGIN_BATCH(8);
    /* Interpolator setup */
    EREG(ib, SPI_VS_OUT_CONFIG, (vs_export_count << VS_EXPORT_COUNT_shift));
    PACK0(ib, SPI_PS_IN_CONTROL_0, 3);
    E32(ib, (num_interp << NUM_INTERP_shift));
    E32(ib, 0);
d359 3
a361 1
    END_BATCH();
d365 1
a365 1
r600_fs_setup(ScrnInfoPtr pScrn, drmBufPtr ib, shader_config_t *fs_conf, uint32_t domain)
a366 1
    RADEONInfoPtr info = RADEONPTR(pScrn);
a374 1
    BEGIN_BATCH(3 + 2);
a375 4
    RELOC_BATCH(fs_conf->bo, domain, 0);
    END_BATCH();

    BEGIN_BATCH(6);
a377 1
    END_BATCH();
d381 1
a381 1
r600_vs_setup(ScrnInfoPtr pScrn, drmBufPtr ib, shader_config_t *vs_conf, uint32_t domain)
a382 1
    RADEONInfoPtr info = RADEONPTR(pScrn);
a394 6
    /* flush SQ cache */
    r600_cp_set_surface_sync(pScrn, ib, SH_ACTION_ENA_bit,
			     vs_conf->shader_size, vs_conf->shader_addr,
			     vs_conf->bo, domain, 0);

    BEGIN_BATCH(3 + 2);
a395 4
    RELOC_BATCH(vs_conf->bo, domain, 0);
    END_BATCH();

    BEGIN_BATCH(6);
a397 1
    END_BATCH();
d401 1
a401 1
r600_ps_setup(ScrnInfoPtr pScrn, drmBufPtr ib, shader_config_t *ps_conf, uint32_t domain)
a402 1
    RADEONInfoPtr info = RADEONPTR(pScrn);
a416 6
    /* flush SQ cache */
    r600_cp_set_surface_sync(pScrn, ib, SH_ACTION_ENA_bit,
			     ps_conf->shader_size, ps_conf->shader_addr,
			     ps_conf->bo, domain, 0);

    BEGIN_BATCH(3 + 2);
a417 4
    RELOC_BATCH(ps_conf->bo, domain, 0);
    END_BATCH();

    BEGIN_BATCH(9);
a420 1
    END_BATCH();
d424 1
a424 1
r600_set_alu_consts(ScrnInfoPtr pScrn, drmBufPtr ib, int offset, int count, float *const_buf)
a425 1
    RADEONInfoPtr info = RADEONPTR(pScrn);
a428 1
    BEGIN_BATCH(2 + countreg);
a431 1
    END_BATCH();
d435 1
a435 1
r600_set_bool_consts(ScrnInfoPtr pScrn, drmBufPtr ib, int offset, uint32_t val)
a436 1
    RADEONInfoPtr info = RADEONPTR(pScrn);
a439 1
    BEGIN_BATCH(3);
a440 1
    END_BATCH();
d443 2
a444 2
static void
r600_set_vtx_resource(ScrnInfoPtr pScrn, drmBufPtr ib, vtx_resource_t *res, uint32_t domain)
a445 2
    RADEONInfoPtr info = RADEONPTR(pScrn);
    struct radeon_accel_state *accel_state = info->accel_state;
a461 17
    /* flush vertex cache */
    if ((info->ChipFamily == CHIP_FAMILY_RV610) ||
	(info->ChipFamily == CHIP_FAMILY_RV620) ||
	(info->ChipFamily == CHIP_FAMILY_RS780) ||
	(info->ChipFamily == CHIP_FAMILY_RS880) ||
	(info->ChipFamily == CHIP_FAMILY_RV710))
	r600_cp_set_surface_sync(pScrn, ib, TC_ACTION_ENA_bit,
				 accel_state->vbo.vb_offset, accel_state->vbo.vb_mc_addr,
				 res->bo,
				 domain, 0);
    else
	r600_cp_set_surface_sync(pScrn, ib, VC_ACTION_ENA_bit,
				 accel_state->vbo.vb_offset, accel_state->vbo.vb_mc_addr,
				 res->bo,
				 domain, 0);

    BEGIN_BATCH(9 + 2);
a469 2
    RELOC_BATCH(res->bo, domain, 0);
    END_BATCH();
d473 1
a473 1
r600_set_tex_resource(ScrnInfoPtr pScrn, drmBufPtr ib, tex_resource_t *tex_res, uint32_t domain)
a474 1
    RADEONInfoPtr info = RADEONPTR(pScrn);
a523 6
    /* flush texture cache */
    r600_cp_set_surface_sync(pScrn, ib, TC_ACTION_ENA_bit,
			     tex_res->size, tex_res->base,
			     tex_res->bo, domain, 0);

    BEGIN_BATCH(9 + 4);
a531 3
    RELOC_BATCH(tex_res->bo, domain, 0);
    RELOC_BATCH(tex_res->mip_bo, domain, 0);
    END_BATCH();
d535 1
a535 1
r600_set_tex_sampler (ScrnInfoPtr pScrn, drmBufPtr ib, tex_sampler_t *s)
a536 1
    RADEONInfoPtr info = RADEONPTR(pScrn);
a575 1
    BEGIN_BATCH(5);
a579 1
    END_BATCH();
d584 1
a584 1
r600_set_screen_scissor(ScrnInfoPtr pScrn, drmBufPtr ib, int x1, int y1, int x2, int y2)
a585 1
    RADEONInfoPtr info = RADEONPTR(pScrn);
d587 4
a590 7
    BEGIN_BATCH(4);
    PACK0(ib, PA_SC_SCREEN_SCISSOR_TL, 2);
    E32(ib, ((x1 << PA_SC_SCREEN_SCISSOR_TL__TL_X_shift) |
	     (y1 << PA_SC_SCREEN_SCISSOR_TL__TL_Y_shift)));
    E32(ib, ((x2 << PA_SC_SCREEN_SCISSOR_BR__BR_X_shift) |
	     (y2 << PA_SC_SCREEN_SCISSOR_BR__BR_Y_shift)));
    END_BATCH();
d594 1
a594 1
r600_set_vport_scissor(ScrnInfoPtr pScrn, drmBufPtr ib, int id, int x1, int y1, int x2, int y2)
a595 1
    RADEONInfoPtr info = RADEONPTR(pScrn);
d597 7
a603 8
    BEGIN_BATCH(4);
    PACK0(ib, PA_SC_VPORT_SCISSOR_0_TL + id * PA_SC_VPORT_SCISSOR_0_TL_offset, 2);
    E32(ib, ((x1 << PA_SC_VPORT_SCISSOR_0_TL__TL_X_shift) |
	     (y1 << PA_SC_VPORT_SCISSOR_0_TL__TL_Y_shift) |
	     WINDOW_OFFSET_DISABLE_bit));
    E32(ib, ((x2 << PA_SC_VPORT_SCISSOR_0_BR__BR_X_shift) |
	     (y2 << PA_SC_VPORT_SCISSOR_0_BR__BR_Y_shift)));
    END_BATCH();
d607 1
a607 1
r600_set_generic_scissor(ScrnInfoPtr pScrn, drmBufPtr ib, int x1, int y1, int x2, int y2)
a608 1
    RADEONInfoPtr info = RADEONPTR(pScrn);
d610 5
a614 8
    BEGIN_BATCH(4);
    PACK0(ib, PA_SC_GENERIC_SCISSOR_TL, 2);
    E32(ib, ((x1 << PA_SC_GENERIC_SCISSOR_TL__TL_X_shift) |
	     (y1 << PA_SC_GENERIC_SCISSOR_TL__TL_Y_shift) |
	     WINDOW_OFFSET_DISABLE_bit));
    E32(ib, ((x2 << PA_SC_GENERIC_SCISSOR_BR__BR_X_shift) |
	     (y2 << PA_SC_GENERIC_SCISSOR_TL__TL_Y_shift)));
    END_BATCH();
d618 1
a618 1
r600_set_window_scissor(ScrnInfoPtr pScrn, drmBufPtr ib, int x1, int y1, int x2, int y2)
a619 1
    RADEONInfoPtr info = RADEONPTR(pScrn);
d621 5
a625 8
    BEGIN_BATCH(4);
    PACK0(ib, PA_SC_WINDOW_SCISSOR_TL, 2);
    E32(ib, ((x1 << PA_SC_WINDOW_SCISSOR_TL__TL_X_shift) |
	     (y1 << PA_SC_WINDOW_SCISSOR_TL__TL_Y_shift) |
	     WINDOW_OFFSET_DISABLE_bit));
    E32(ib, ((x2 << PA_SC_WINDOW_SCISSOR_BR__BR_X_shift) |
	      (y2 << PA_SC_WINDOW_SCISSOR_BR__BR_Y_shift)));
    END_BATCH();
d629 1
a629 1
r600_set_clip_rect(ScrnInfoPtr pScrn, drmBufPtr ib, int id, int x1, int y1, int x2, int y2)
a630 1
    RADEONInfoPtr info = RADEONPTR(pScrn);
d632 6
a637 7
    BEGIN_BATCH(4);
    PACK0(ib, PA_SC_CLIPRECT_0_TL + id * PA_SC_CLIPRECT_0_TL_offset, 2);
    E32(ib, ((x1 << PA_SC_CLIPRECT_0_TL__TL_X_shift) |
	     (y1 << PA_SC_CLIPRECT_0_TL__TL_Y_shift)));
    E32(ib, ((x2 << PA_SC_CLIPRECT_0_BR__BR_X_shift) |
	     (y2 << PA_SC_CLIPRECT_0_BR__BR_Y_shift)));
    END_BATCH();
d645 1
a645 1
r600_set_default_state(ScrnInfoPtr pScrn, drmBufPtr ib)
d654 4
d660 1
d662 3
a664 2
    memset(&tex_res, 0, sizeof(tex_resource_t));
    memset(&fs_conf, 0, sizeof(shader_config_t));
d666 26
a691 1
    accel_state->XInited3D = TRUE;
d693 4
a696 1
    r600_start_3d(pScrn, accel_state->ib);
a740 1
    case CHIP_FAMILY_RS880:
a786 1
    case CHIP_FAMILY_RV740:
d818 1
a818 1
    r600_sq_setup(pScrn, ib, &sq_conf);
d820 2
a821 36
    /* set fake reloc for unused depth */
    BEGIN_BATCH(3 + 2);
    EREG(ib, DB_DEPTH_INFO, 0);
    RELOC_BATCH(accel_state->shaders_bo, RADEON_GEM_DOMAIN_VRAM, 0);
    END_BATCH();

    BEGIN_BATCH(80);
    if (info->ChipFamily < CHIP_FAMILY_RV770) {
	EREG(ib, TA_CNTL_AUX, (( 3 << GRADIENT_CREDIT_shift) |
			       (28 << TD_FIFO_CREDIT_shift)));
	EREG(ib, VC_ENHANCE, 0);
	EREG(ib, R7xx_SQ_DYN_GPR_CNTL_PS_FLUSH_REQ, 0);
	EREG(ib, DB_DEBUG, 0x82000000); /* ? */
	EREG(ib, DB_WATERMARKS, ((4 << DEPTH_FREE_shift) |
				 (16 << DEPTH_FLUSH_shift) |
				 (0 << FORCE_SUMMARIZE_shift) |
				 (4 << DEPTH_PENDING_FREE_shift) |
				 (16 << DEPTH_CACHELINE_FREE_shift) |
				 0));
    } else {
	EREG(ib, TA_CNTL_AUX, (( 2 << GRADIENT_CREDIT_shift) |
			       (28 << TD_FIFO_CREDIT_shift)));
	EREG(ib, VC_ENHANCE, 0);
	EREG(ib, R7xx_SQ_DYN_GPR_CNTL_PS_FLUSH_REQ, VS_PC_LIMIT_ENABLE_bit);
	EREG(ib, DB_DEBUG, 0);
	EREG(ib, DB_WATERMARKS, ((4 << DEPTH_FREE_shift) |
				 (16 << DEPTH_FLUSH_shift) |
				 (0 << FORCE_SUMMARIZE_shift) |
				 (4 << DEPTH_PENDING_FREE_shift) |
				 (4 << DEPTH_CACHELINE_FREE_shift) |
				 0));
    }

    PACK0(ib, SQ_VTX_BASE_VTX_LOC, 2);
    E32(ib, 0);
    E32(ib, 0);
d824 9
a832 9
    E32(ib, 0); // SQ_ESGS_RING_ITEMSIZE
    E32(ib, 0); // SQ_GSVS_RING_ITEMSIZE
    E32(ib, 0); // SQ_ESTMP_RING_ITEMSIZE
    E32(ib, 0); // SQ_GSTMP_RING_ITEMSIZE
    E32(ib, 0); // SQ_VSTMP_RING_ITEMSIZE
    E32(ib, 0); // SQ_PSTMP_RING_ITEMSIZE
    E32(ib, 0); // SQ_FBUF_RING_ITEMSIZE
    E32(ib, 0); // SQ_REDUC_RING_ITEMSIZE
    E32(ib, 0); // SQ_GS_VERT_ITEMSIZE
d835 5
d841 1
a841 2
    PACK0(ib, DB_RENDER_CONTROL, 2);
    E32(ib, STENCIL_COMPRESS_DISABLE_bit | DEPTH_COMPRESS_DISABLE_bit);
d843 1
a843 1
	E32(ib, FORCE_SHADER_Z_ORDER_bit);
d845 1
a845 1
	E32(ib, 0);
a849 2
    EREG(ib, DB_SHADER_CONTROL, ((1 << Z_ORDER_shift) | /* EARLY_Z_THEN_LATE_Z */
				 DUAL_EXPORT_ENABLE_bit)); /* Only useful if no depth export */
d851 29
a879 8
    PACK0(ib, DB_STENCIL_CLEAR, 2);
    E32(ib, 0); // DB_STENCIL_CLEAR
    E32(ib, 0); // DB_DEPTH_CLEAR

    PACK0(ib, DB_STENCILREFMASK, 3);
    E32(ib, 0); // DB_STENCILREFMASK
    E32(ib, 0); // DB_STENCILREFMASK_BF
    E32(ib, 0); // SX_ALPHA_REF
d881 1
a887 2
    EREG(ib, CB_SHADER_MASK,                      OUTPUT0_ENABLE_mask);
    EREG(ib, R7xx_CB_SHADER_CONTROL,              (RT0_ENABLE_bit));
d889 8
a896 6
    PACK0(ib, SX_ALPHA_TEST_CONTROL, 5);
    E32(ib, 0); // SX_ALPHA_TEST_CONTROL
    E32(ib, 0x00000000); // CB_BLEND_RED
    E32(ib, 0x00000000); // CB_BLEND_GREEN
    E32(ib, 0x00000000); // CB_BLEND_BLUE
    E32(ib, 0x00000000); // CB_BLEND_ALPHA
d898 3
d903 7
d916 6
a921 1
    EREG(ib, PA_SC_CLIPRECT_RULE,                 CLIP_RULE_mask);
d923 5
a927 1
    END_BATCH();
d929 3
a931 3
    /* clip boolean is set to always visible -> doesn't matter */
    for (i = 0; i < PA_SC_CLIPRECT_0_TL_num; i++)
	r600_set_clip_rect(pScrn, ib, i, 0, 0, 8192, 8192);
d933 5
a937 2
    for (i = 0; i < PA_SC_VPORT_SCISSOR_0_TL_num; i++)
	r600_set_vport_scissor(pScrn, ib, i, 0, 0, 8192, 8192);
d939 2
a940 8
    BEGIN_BATCH(49);
    PACK0(ib, PA_SC_MPASS_PS_CNTL, 2);
    E32(ib, 0);
    if (info->ChipFamily < CHIP_FAMILY_RV770)
	E32(ib, (WALK_ORDER_ENABLE_bit | FORCE_EOV_CNTDWN_ENABLE_bit));
    else
	E32(ib, (FORCE_EOV_CNTDWN_ENABLE_bit | FORCE_EOV_REZ_ENABLE_bit |
		 0x00500000)); /* ? */
d942 13
a954 5
    PACK0(ib, PA_SC_LINE_CNTL, 9);
    E32(ib, 0); // PA_SC_LINE_CNTL
    E32(ib, 0); // PA_SC_AA_CONFIG
    E32(ib, ((2 << PA_SU_VTX_CNTL__ROUND_MODE_shift) | PIX_CENTER_bit | // PA_SU_VTX_CNTL
	     (5 << QUANT_MODE_shift))); /* Round to Even, fixed point 1/256 */
a958 2
    E32(ib, 0);                                                 // PA_SC_AA_SAMPLE_LOCS_MCTX
    E32(ib, 0);                                                 // PA_SC_AA_SAMPLE_LOCS_8S_WD1_M
d960 19
a978 16
    EREG(ib, PA_SC_AA_MASK,                       0xFFFFFFFF);

    PACK0(ib, PA_CL_CLIP_CNTL, 5);
    E32(ib, CLIP_DISABLE_bit); // PA_CL_CLIP_CNTL
    E32(ib, FACE_bit);         // PA_SU_SC_MODE_CNTL
    E32(ib, VTX_XY_FMT_bit);   // PA_CL_VTE_CNTL
    E32(ib, 0);                // PA_CL_VS_OUT_CNTL
    E32(ib, 0);                // PA_CL_NANINF_CNTL

    PACK0(ib, PA_SU_POLY_OFFSET_DB_FMT_CNTL, 6);
    E32(ib, 0); // PA_SU_POLY_OFFSET_DB_FMT_CNTL
    E32(ib, 0); // PA_SU_POLY_OFFSET_CLAMP
    E32(ib, 0); // PA_SU_POLY_OFFSET_FRONT_SCALE
    E32(ib, 0); // PA_SU_POLY_OFFSET_FRONT_OFFSET
    E32(ib, 0); // PA_SU_POLY_OFFSET_BACK_SCALE
    E32(ib, 0); // PA_SU_POLY_OFFSET_BACK_OFFSET
d986 13
a998 20
    /* default Interpolator setup */
    EREG(ib, SPI_VS_OUT_ID_0, ((0 << SEMANTIC_0_shift) |
			       (1 << SEMANTIC_1_shift)));
    PACK0(ib, SPI_PS_INPUT_CNTL_0 + (0 << 2), 2);
    /* SPI_PS_INPUT_CNTL_0 maps to GPR[0] - load with semantic id 0 */
    E32(ib, ((0    << SEMANTIC_shift)	|
	     (0x01 << DEFAULT_VAL_shift)	|
	     SEL_CENTROID_bit));
    /* SPI_PS_INPUT_CNTL_1 maps to GPR[1] - load with semantic id 1 */
    E32(ib, ((1    << SEMANTIC_shift)	|
	     (0x01 << DEFAULT_VAL_shift)	|
	     SEL_CENTROID_bit));

    PACK0(ib, SPI_INPUT_Z, 4);
    E32(ib, 0); // SPI_INPUT_Z
    E32(ib, 0); // SPI_FOG_CNTL
    E32(ib, 0); // SPI_FOG_FUNC_SCALE
    E32(ib, 0); // SPI_FOG_FUNC_BIAS

    END_BATCH();
d1001 1
a1001 2
    fs_conf.bo = accel_state->shaders_bo;
    r600_fs_setup(pScrn, ib, &fs_conf, RADEON_GEM_DOMAIN_VRAM);
d1004 20
a1023 7
    BEGIN_BATCH(43);
    PACK0(ib, VGT_MAX_VTX_INDX, 4);
    E32(ib, 0xffffff); // VGT_MAX_VTX_INDX
    E32(ib, 0); // VGT_MIN_VTX_INDX
    E32(ib, 0); // VGT_INDX_OFFSET
    E32(ib, 0); // VGT_MULTI_PRIM_IB_RESET_INDX

d1026 16
d1043 5
a1047 27
    PACK0(ib, VGT_INSTANCE_STEP_RATE_0, 2);
    E32(ib, 0); // VGT_INSTANCE_STEP_RATE_0
    E32(ib, 0); // VGT_INSTANCE_STEP_RATE_1

    PACK0(ib, PA_SU_POINT_SIZE, 17);
    E32(ib, 0); // PA_SU_POINT_SIZE
    E32(ib, 0); // PA_SU_POINT_MINMAX
    E32(ib, (8 << PA_SU_LINE_CNTL__WIDTH_shift)); /* Line width 1 pixel */ // PA_SU_LINE_CNTL
    E32(ib, 0); // PA_SC_LINE_STIPPLE
    E32(ib, 0); // VGT_OUTPUT_PATH_CNTL
    E32(ib, 0); // VGT_HOS_CNTL
    E32(ib, 0); // VGT_HOS_MAX_TESS_LEVEL
    E32(ib, 0); // VGT_HOS_MIN_TESS_LEVEL
    E32(ib, 0); // VGT_HOS_REUSE_DEPTH
    E32(ib, 0); // VGT_GROUP_PRIM_TYPE
    E32(ib, 0); // VGT_GROUP_FIRST_DECR
    E32(ib, 0); // VGT_GROUP_DECR
    E32(ib, 0); // VGT_GROUP_VECT_0_CNTL
    E32(ib, 0); // VGT_GROUP_VECT_1_CNTL
    E32(ib, 0); // VGT_GROUP_VECT_0_FMT_CNTL
    E32(ib, 0); // VGT_GROUP_VECT_1_FMT_CNTL
    E32(ib, 0); // VGT_GS_MODE

    PACK0(ib, VGT_STRMOUT_EN, 3);
    E32(ib, 0); // VGT_STRMOUT_EN
    E32(ib, 0); // VGT_REUSE_OFF
    E32(ib, 0); // VGT_VTX_CNT_EN
a1048 2
    EREG(ib, VGT_STRMOUT_BUFFER_EN,               0);
    END_BATCH();
d1057 1
a1057 1
r600_draw_immd(ScrnInfoPtr pScrn, drmBufPtr ib, draw_config_t *draw_conf, uint32_t *indices)
a1058 1
    RADEONInfoPtr info = RADEONPTR(pScrn);
d1061 6
a1073 11
    BEGIN_BATCH(8 + count);
    EREG(ib, VGT_PRIMITIVE_TYPE, draw_conf->prim_type);
    PACK3(ib, IT_INDEX_TYPE, 1);
#if X_BYTE_ORDER == X_BIG_ENDIAN
    E32(ib, IT_INDEX_TYPE_SWAP_MODE(ENDIAN_8IN32) | draw_conf->index_type);
#else
    E32(ib, draw_conf->index_type);
#endif
    PACK3(ib, IT_NUM_INSTANCES, 1);
    E32(ib, draw_conf->num_instances);

a1088 1
    END_BATCH();
d1092 1
a1092 1
r600_draw_auto(ScrnInfoPtr pScrn, drmBufPtr ib, draw_config_t *draw_conf)
a1093 1
    RADEONInfoPtr info = RADEONPTR(pScrn);
a1094 1
    BEGIN_BATCH(10);
a1096 3
#if X_BYTE_ORDER == X_BIG_ENDIAN
    E32(ib, IT_INDEX_TYPE_SWAP_MODE(ENDIAN_8IN32) | draw_conf->index_type);
#else
a1097 1
#endif
a1102 58
    END_BATCH();
}

void r600_finish_op(ScrnInfoPtr pScrn, int vtx_size)
{
    RADEONInfoPtr info = RADEONPTR(pScrn);
    struct radeon_accel_state *accel_state = info->accel_state;
    draw_config_t   draw_conf;
    vtx_resource_t  vtx_res;

    if (accel_state->vbo.vb_start_op == -1)
	return;

    CLEAR (draw_conf);
    CLEAR (vtx_res);

    if (accel_state->vbo.vb_offset == accel_state->vbo.vb_start_op) {
        R600IBDiscard(pScrn, accel_state->ib);
	return;
    }

    /* Vertex buffer setup */
    accel_state->vbo.vb_size = accel_state->vbo.vb_offset - accel_state->vbo.vb_start_op;
    vtx_res.id              = SQ_VTX_RESOURCE_vs;
    vtx_res.vtx_size_dw     = vtx_size / 4;
    vtx_res.vtx_num_entries = accel_state->vbo.vb_size / 4;
    vtx_res.mem_req_size    = 1;
    vtx_res.vb_addr         = accel_state->vbo.vb_mc_addr + accel_state->vbo.vb_start_op;
    vtx_res.bo              = accel_state->vbo.vb_bo;
#if X_BYTE_ORDER == X_BIG_ENDIAN
    vtx_res.endian          = SQ_ENDIAN_8IN32;
#endif
    r600_set_vtx_resource(pScrn, accel_state->ib, &vtx_res, RADEON_GEM_DOMAIN_GTT);

    /* Draw */
    draw_conf.prim_type          = DI_PT_RECTLIST;
    draw_conf.vgt_draw_initiator = DI_SRC_SEL_AUTO_INDEX;
    draw_conf.num_instances      = 1;
    draw_conf.num_indices        = vtx_res.vtx_num_entries / vtx_res.vtx_size_dw;
    draw_conf.index_type         = DI_INDEX_SIZE_16_BIT;

    r600_draw_auto(pScrn, accel_state->ib, &draw_conf);

    /* XXX drm should handle this in fence submit */
    r600_wait_3d_idle_clean(pScrn, accel_state->ib);

    /* sync dst surface */
    r600_cp_set_surface_sync(pScrn, accel_state->ib, (CB_ACTION_ENA_bit | CB0_DEST_BASE_ENA_bit),
			     accel_state->dst_size, accel_state->dst_obj.offset,
			     accel_state->dst_obj.bo, 0, accel_state->dst_obj.domain);

    accel_state->vbo.vb_start_op = -1;
    accel_state->ib_reset_op = 0;

#if KMS_MULTI_OP
    if (!info->cs)
#endif
	R600CPFlushIndirect(pScrn, accel_state->ib);
a1103 1

@


1.1
log
@update do xf86-video-ati 6.12.2

This has been in snapshots for weeks. ok oga@@, todd@@.
@
text
@d41 25
d75 7
d88 1
d90 1
d93 3
d110 6
d123 1
a123 1
wait_3d_idle_clean(ScrnInfoPtr pScrn, drmBufPtr ib)
d125 1
d128 1
d134 1
d138 1
a138 1
wait_3d_idle(ScrnInfoPtr pScrn, drmBufPtr ib)
d140 1
d142 1
d144 1
a144 70

}

static void
reset_cb(ScrnInfoPtr pScrn, drmBufPtr ib)
{
    int i;

    PACK0(ib, CB_COLOR0_INFO, 8);
    for (i = 0; i < 8; i++)
	E32(ib, 0);
}

static void
reset_td_samplers(ScrnInfoPtr pScrn, drmBufPtr ib)
{
    int i;

    wait_3d_idle(pScrn, ib);

    PACK0(ib, TD_PS_SAMPLER0_BORDER_RED, 4*TD_PS_SAMPLER0_BORDER_RED_num);
    for (i = 0; i < 4*TD_PS_SAMPLER0_BORDER_RED_num; i++)
	E32(ib, 0);
    PACK0(ib, TD_VS_SAMPLER0_BORDER_RED, 4*TD_VS_SAMPLER0_BORDER_RED_num);
    for (i = 0; i < 4*TD_VS_SAMPLER0_BORDER_RED_num; i++)
	E32(ib, 0);

    wait_3d_idle(pScrn, ib);
}

static void
reset_sampler_const (ScrnInfoPtr pScrn, drmBufPtr ib)
{
    int i;

    for (i = 0; i < SQ_TEX_SAMPLER_WORD_all_num; i++) {
	PACK0(ib, SQ_TEX_SAMPLER_WORD + i * SQ_TEX_SAMPLER_WORD_offset, 3);
	E32(ib, SQ_TEX_DEPTH_COMPARE_LESSEQUAL << DEPTH_COMPARE_FUNCTION_shift);
	E32(ib, MAX_LOD_mask);
	E32(ib, 0);
    }
}

static void
reset_dx9_alu_consts(ScrnInfoPtr pScrn, drmBufPtr ib)
{
    int i;

    const int count = SQ_ALU_CONSTANT_all_num * (SQ_ALU_CONSTANT_offset >> 2);

    PACK0(ib, SQ_ALU_CONSTANT, count);
    for (i = 0; i < count; i++)
	EFLOAT(ib, 0.0);
}

static void
reset_bool_loop_const(ScrnInfoPtr pScrn, drmBufPtr ib)
{
    int i;


    PACK0(ib, SQ_BOOL_CONST, SQ_BOOL_CONST_all_num);
    for (i = 0; i < SQ_BOOL_CONST_all_num; i++)
	E32(ib, 0);

    PACK0(ib, SQ_LOOP_CONST, SQ_LOOP_CONST_all_num);

    for (i = 0; i < SQ_LOOP_CONST_all_num; i++)
	E32(ib, 0);

d148 1
a148 1
start_3d(ScrnInfoPtr pScrn, drmBufPtr ib)
d153 1
d156 2
a157 1
    }
d162 1
a163 1
    wait_3d_idle_clean (pScrn, ib);
d172 1
a172 1
sq_setup(ScrnInfoPtr pScrn, drmBufPtr ib, sq_config_t *sq_conf)
d181 1
d211 1
d219 1
a219 1

d223 1
a223 1
set_render_target(ScrnInfoPtr pScrn, drmBufPtr ib, cb_config_t *cb_conf)
d225 1
a225 1
    uint32_t cb_color_info;
d255 1
a255 1
    h = (cb_conf->h + 7) & ~7;
d258 1
d260 2
d265 5
a269 3
	(info->ChipFamily < CHIP_FAMILY_RV770)) {
	PACK3(ib, IT_SURFACE_BASE_UPDATE, 1);
	E32(ib, (2 << cb_conf->id));
d271 13
a283 1

a288 3
    EREG(ib, (CB_COLOR0_INFO + (4 * cb_conf->id)), cb_color_info);
    EREG(ib, (CB_COLOR0_TILE + (4 * cb_conf->id)), (0     >> 8));	// CMASK per-tile data base/256
    EREG(ib, (CB_COLOR0_FRAG + (4 * cb_conf->id)), (0     >> 8));	// FMASK per-tile data base/256
d291 22
d315 4
a318 2
void
cp_set_surface_sync(ScrnInfoPtr pScrn, drmBufPtr ib, uint32_t sync_type, uint32_t size, uint64_t mc_addr)
d320 1
d327 1
d333 2
d338 3
a340 2
void cp_wait_vline_sync(ScrnInfoPtr pScrn, drmBufPtr ib, PixmapPtr pPix,
	int crtc, int start, int stop)
a342 1
    xf86CrtcConfigPtr  xf86_config = XF86_CRTC_CONFIG_PTR(pScrn);
a343 1
    RADEONCrtcPrivatePtr radeon_crtc;
d345 1
a345 1
    if ((crtc < 0) || (crtc > 1))
d351 1
a351 1
    if (!xf86_config->crtc[crtc]->enabled)
d354 4
d359 3
a361 3
    if (info->useEXA)
        offset = exaGetPixmapOffset(pPix);
    else
d363 1
a363 1
        offset = pPix->devPrivate.ptr - info->FB;
d365 4
a368 3
    /* if drawing to front buffer */
    if (offset != 0)
        return;
d371 1
a371 1
    stop = min(stop, xf86_config->crtc[crtc]->mode.VDisplay);
d373 1
a373 1
    if (start > xf86_config->crtc[crtc]->mode.VDisplay)
d376 48
a423 1
    radeon_crtc = xf86_config->crtc[crtc]->driver_private;
d425 11
a435 9
    /* set the VLINE range */
    EREG(ib, AVIVO_D1MODE_VLINE_START_END + radeon_crtc->crtc_offset,
         (start << AVIVO_D1MODE_VLINE_START_SHIFT) |
         (stop << AVIVO_D1MODE_VLINE_END_SHIFT));

    /* tell the CP to poll the VLINE state register */
    PACK3(ib, IT_WAIT_REG_MEM, 6);
    E32(ib, IT_WAIT_REG | IT_WAIT_EQ);
    E32(ib, IT_WAIT_ADDR(AVIVO_D1MODE_VLINE_STATUS + radeon_crtc->crtc_offset));
d437 1
a437 3
    E32(ib, 0);                          // Ref value
    E32(ib, AVIVO_D1MODE_VLINE_STAT);    // Mask
    E32(ib, 10);                         // Wait interval
d441 1
a441 1
fs_setup(ScrnInfoPtr pScrn, drmBufPtr ib, shader_config_t *fs_conf)
d443 1
d452 1
d454 4
d460 1
d464 1
a464 1
vs_setup(ScrnInfoPtr pScrn, drmBufPtr ib, shader_config_t *vs_conf)
d466 1
d479 6
d486 4
d492 1
d496 1
a496 1
ps_setup(ScrnInfoPtr pScrn, drmBufPtr ib, shader_config_t *ps_conf)
d498 1
d513 6
d520 4
d527 1
d531 1
a531 1
set_alu_consts(ScrnInfoPtr pScrn, drmBufPtr ib, int offset, int count, float *const_buf)
d533 1
d537 1
d541 1
d545 1
a545 1
set_bool_consts(ScrnInfoPtr pScrn, drmBufPtr ib, int offset, uint32_t val)
d547 1
d551 1
d553 1
d556 2
a557 2
void
set_vtx_resource(ScrnInfoPtr pScrn, drmBufPtr ib, vtx_resource_t *res)
d559 2
d577 17
d602 2
d607 1
a607 1
set_tex_resource(ScrnInfoPtr pScrn, drmBufPtr ib, tex_resource_t *tex_res)
d609 1
d659 6
d673 3
d679 1
a679 1
set_tex_sampler (ScrnInfoPtr pScrn, drmBufPtr ib, tex_sampler_t *s)
d681 1
d721 1
d726 1
d731 1
a731 1
set_screen_scissor(ScrnInfoPtr pScrn, drmBufPtr ib, int x1, int y1, int x2, int y2)
d733 1
d735 7
a741 4
    EREG(ib, PA_SC_SCREEN_SCISSOR_TL,              ((x1 << PA_SC_SCREEN_SCISSOR_TL__TL_X_shift) |
						    (y1 << PA_SC_SCREEN_SCISSOR_TL__TL_Y_shift)));
    EREG(ib, PA_SC_SCREEN_SCISSOR_BR,              ((x2 << PA_SC_SCREEN_SCISSOR_BR__BR_X_shift) |
						    (y2 << PA_SC_SCREEN_SCISSOR_BR__BR_Y_shift)));
d745 1
a745 1
set_vport_scissor(ScrnInfoPtr pScrn, drmBufPtr ib, int id, int x1, int y1, int x2, int y2)
d747 1
d749 8
a756 7
    EREG(ib, PA_SC_VPORT_SCISSOR_0_TL +
	 id * PA_SC_VPORT_SCISSOR_0_TL_offset, ((x1 << PA_SC_VPORT_SCISSOR_0_TL__TL_X_shift) |
						(y1 << PA_SC_VPORT_SCISSOR_0_TL__TL_Y_shift) |
						WINDOW_OFFSET_DISABLE_bit));
    EREG(ib, PA_SC_VPORT_SCISSOR_0_BR +
	 id * PA_SC_VPORT_SCISSOR_0_BR_offset, ((x2 << PA_SC_VPORT_SCISSOR_0_BR__BR_X_shift) |
						(y2 << PA_SC_VPORT_SCISSOR_0_BR__BR_Y_shift)));
d760 1
a760 1
set_generic_scissor(ScrnInfoPtr pScrn, drmBufPtr ib, int x1, int y1, int x2, int y2)
d762 1
d764 8
a771 5
    EREG(ib, PA_SC_GENERIC_SCISSOR_TL,            ((x1 << PA_SC_GENERIC_SCISSOR_TL__TL_X_shift) |
						   (y1 << PA_SC_GENERIC_SCISSOR_TL__TL_Y_shift) |
						   WINDOW_OFFSET_DISABLE_bit));
    EREG(ib, PA_SC_GENERIC_SCISSOR_BR,            ((x2 << PA_SC_GENERIC_SCISSOR_BR__BR_X_shift) |
						   (y2 << PA_SC_GENERIC_SCISSOR_TL__TL_Y_shift)));
d775 1
a775 1
set_window_scissor(ScrnInfoPtr pScrn, drmBufPtr ib, int x1, int y1, int x2, int y2)
d777 1
d779 8
a786 5
    EREG(ib, PA_SC_WINDOW_SCISSOR_TL,             ((x1 << PA_SC_WINDOW_SCISSOR_TL__TL_X_shift) |
						   (y1 << PA_SC_WINDOW_SCISSOR_TL__TL_Y_shift) |
						   WINDOW_OFFSET_DISABLE_bit));
    EREG(ib, PA_SC_WINDOW_SCISSOR_BR,             ((x2 << PA_SC_WINDOW_SCISSOR_BR__BR_X_shift) |
						   (y2 << PA_SC_WINDOW_SCISSOR_BR__BR_Y_shift)));
d790 1
a790 1
set_clip_rect(ScrnInfoPtr pScrn, drmBufPtr ib, int id, int x1, int y1, int x2, int y2)
d792 1
d794 7
a800 6
    EREG(ib, PA_SC_CLIPRECT_0_TL +
	 id * PA_SC_CLIPRECT_0_TL_offset,     ((x1 << PA_SC_CLIPRECT_0_TL__TL_X_shift) |
					       (y1 << PA_SC_CLIPRECT_0_TL__TL_Y_shift)));
    EREG(ib, PA_SC_CLIPRECT_0_BR +
	 id * PA_SC_CLIPRECT_0_BR_offset,     ((x2 << PA_SC_CLIPRECT_0_BR__BR_X_shift) |
					       (y2 << PA_SC_CLIPRECT_0_BR__BR_Y_shift)));
d808 1
a808 1
set_default_state(ScrnInfoPtr pScrn, drmBufPtr ib)
d817 3
a822 5
#if 1
    if (accel_state->XInited3D)
	return;
#endif

d825 1
a825 33
    wait_3d_idle(pScrn, ib);

    // ASIC specific setup, see drm
    if (info->ChipFamily < CHIP_FAMILY_RV770) {
	EREG(ib, TA_CNTL_AUX,                     (( 3 << GRADIENT_CREDIT_shift)		|
						   (28 << TD_FIFO_CREDIT_shift)));
	EREG(ib, VC_ENHANCE,                      0);
	EREG(ib, R7xx_SQ_DYN_GPR_CNTL_PS_FLUSH_REQ, 0);
	EREG(ib, DB_DEBUG,                        0x82000000); /* ? */
	EREG(ib, DB_WATERMARKS,		        ((4  << DEPTH_FREE_shift)		|
						 (16 << DEPTH_FLUSH_shift)		|
						 (0  << FORCE_SUMMARIZE_shift)		|
						 (4  << DEPTH_PENDING_FREE_shift)	|
						 (16 << DEPTH_CACHELINE_FREE_shift)	|
						 0));
    } else {
	EREG(ib, TA_CNTL_AUX,                      (( 2 << GRADIENT_CREDIT_shift)		|
						    (28 << TD_FIFO_CREDIT_shift)));
	EREG(ib, VC_ENHANCE,                       0);
	EREG(ib, R7xx_SQ_DYN_GPR_CNTL_PS_FLUSH_REQ, VS_PC_LIMIT_ENABLE_bit);
	EREG(ib, DB_DEBUG,                         0);
	EREG(ib, DB_WATERMARKS,                    ((4  << DEPTH_FREE_shift)		|
						    (16 << DEPTH_FLUSH_shift)		|
						    (0  << FORCE_SUMMARIZE_shift)		|
						    (4  << DEPTH_PENDING_FREE_shift)	|
						    (4  << DEPTH_CACHELINE_FREE_shift)	|
						    0));
    }

    reset_td_samplers(pScrn, ib);
    reset_dx9_alu_consts(pScrn, ib);
    reset_bool_loop_const (pScrn, ib);
    reset_sampler_const (pScrn, ib);
d870 1
d917 1
d949 1
a949 1
    sq_setup(pScrn, ib, &sq_conf);
d951 36
a986 2
    EREG(ib, SQ_VTX_BASE_VTX_LOC,                 0);
    EREG(ib, SQ_VTX_START_INST_LOC,               0);
d989 9
a997 9
    E32(ib, 0);							// SQ_ESGS_RING_ITEMSIZE
    E32(ib, 0);							// SQ_GSVS_RING_ITEMSIZE
    E32(ib, 0);							// SQ_ESTMP_RING_ITEMSIZE
    E32(ib, 0);							// SQ_GSTMP_RING_ITEMSIZE
    E32(ib, 0);							// SQ_VSTMP_RING_ITEMSIZE
    E32(ib, 0);							// SQ_PSTMP_RING_ITEMSIZE
    E32(ib, 0);							// SQ_FBUF_RING_ITEMSIZE
    E32(ib, 0);							// SQ_REDUC_RING_ITEMSIZE
    E32(ib, 0);							// SQ_GS_VERT_ITEMSIZE
a999 5
    EREG(ib, DB_DEPTH_INFO,                       0);
    EREG(ib, DB_STENCIL_CLEAR,                    0);
    EREG(ib, DB_DEPTH_CLEAR,                      0);
    EREG(ib, DB_STENCILREFMASK,                   0);
    EREG(ib, DB_STENCILREFMASK_BF,                0);
d1001 2
a1002 1
    EREG(ib, DB_RENDER_CONTROL,                   STENCIL_COMPRESS_DISABLE_bit | DEPTH_COMPRESS_DISABLE_bit);
d1004 1
a1004 1
	EREG(ib, DB_RENDER_OVERRIDE,              FORCE_SHADER_Z_ORDER_bit);
d1006 1
a1006 1
	EREG(ib, DB_RENDER_OVERRIDE,              0);
d1011 2
d1014 8
a1021 29
    // SX
    EREG(ib, SX_ALPHA_TEST_CONTROL,               0);
    EREG(ib, SX_ALPHA_REF,                        0);

    // CB
    reset_cb(pScrn, ib);

    PACK0(ib, CB_BLEND_RED, 4);
    E32(ib, 0x00000000);
    E32(ib, 0x00000000);
    E32(ib, 0x00000000);
    E32(ib, 0x00000000);

    /* CB_COLOR_CONTROL.PER_MRT_BLEND is off */
    // RV6xx+ have per-MRT blend
    if (info->ChipFamily > CHIP_FAMILY_R600) {
	PACK0(ib, CB_BLEND0_CONTROL, CB_BLEND0_CONTROL_num);
	for (i = 0; i < CB_BLEND0_CONTROL_num; i++)
	    E32(ib, 0);
    }

    EREG(ib, CB_BLEND_CONTROL,                    0);

    if (info->ChipFamily < CHIP_FAMILY_RV770) {
	PACK0(ib, CB_FOG_RED, 3);
	E32(ib, 0x00000000);
	E32(ib, 0x00000000);
	E32(ib, 0x00000000);
    }
a1022 1
    EREG(ib, CB_COLOR_CONTROL,                    0);
d1029 2
d1032 6
a1037 8
    if (info->ChipFamily < CHIP_FAMILY_RV770) {
	PACK0(ib, CB_CLEAR_RED, 4);
	EFLOAT(ib, 1.0);						/* WTF? */
	EFLOAT(ib, 0.0);
	EFLOAT(ib, 1.0);
	EFLOAT(ib, 1.0);
    }
    EREG(ib, CB_TARGET_MASK,                      (0x0f << TARGET0_ENABLE_shift));
a1038 3
    // SC
    set_generic_scissor(pScrn, ib, 0, 0, 8192, 8192);
    set_screen_scissor(pScrn, ib, 0, 0, 8192, 8192);
a1040 7
    set_window_scissor(pScrn, ib, 0, 0, 8192, 8192);

    EREG(ib, PA_SC_CLIPRECT_RULE,                 CLIP_RULE_mask);

    /* clip boolean is set to always visible -> doesn't matter */
    for (i = 0; i < PA_SC_CLIPRECT_0_TL_num; i++)
	set_clip_rect (pScrn, ib, i, 0, 0, 8192, 8192);
d1047 1
a1047 6
    for (i = 0; i < PA_SC_VPORT_SCISSOR_0_TL_num; i++) {
	set_vport_scissor (pScrn, ib, i, 0, 0, 8192, 8192);
	PACK0(ib, PA_SC_VPORT_ZMIN_0 + i * PA_SC_VPORT_ZMIN_0_offset, 2);
	EFLOAT(ib, 0.0);
	EFLOAT(ib, 1.0);
    }
d1049 1
a1049 5
    if (info->ChipFamily < CHIP_FAMILY_RV770)
	EREG(ib, PA_SC_MODE_CNTL,                 (WALK_ORDER_ENABLE_bit | FORCE_EOV_CNTDWN_ENABLE_bit));
    else
	EREG(ib, PA_SC_MODE_CNTL,                 (FORCE_EOV_CNTDWN_ENABLE_bit | FORCE_EOV_REZ_ENABLE_bit |
						   0x00500000)); /* ? */
d1051 3
a1053 3
    EREG(ib, PA_SC_LINE_CNTL,                     0);
    EREG(ib, PA_SC_AA_CONFIG,                     0);
    EREG(ib, PA_SC_AA_MASK,                       0xFFFFFFFF);
d1055 2
a1056 5
    //XXX: double check this
    if (info->ChipFamily > CHIP_FAMILY_R600) {
	EREG(ib, PA_SC_AA_SAMPLE_LOCS_MCTX,       0);
	EREG(ib, PA_SC_AA_SAMPLE_LOCS_8S_WD1_M,   0);
    }
d1058 8
a1065 2
    EREG(ib, PA_SC_LINE_STIPPLE,                  0);
    EREG(ib, PA_SC_MPASS_PS_CNTL,                 0);
d1067 5
a1071 13
    // CL
    PACK0(ib, PA_CL_VPORT_XSCALE_0, 6);
    EFLOAT(ib, 0.0f);						// PA_CL_VPORT_XSCALE
    EFLOAT(ib, 0.0f);						// PA_CL_VPORT_XOFFSET
    EFLOAT(ib, 0.0f);						// PA_CL_VPORT_YSCALE
    EFLOAT(ib, 0.0f);						// PA_CL_VPORT_YOFFSET
    EFLOAT(ib, 0.0f);						// PA_CL_VPORT_ZSCALE
    EFLOAT(ib, 0.0f);						// PA_CL_VPORT_ZOFFSET
    EREG(ib, PA_CL_CLIP_CNTL,                     (CLIP_DISABLE_bit | DX_CLIP_SPACE_DEF_bit));
    EREG(ib, PA_CL_VTE_CNTL,                      0);
    EREG(ib, PA_CL_VS_OUT_CNTL,                   0);
    EREG(ib, PA_CL_NANINF_CNTL,                   0);
    PACK0(ib, PA_CL_GB_VERT_CLIP_ADJ, 4);
d1076 2
d1079 16
a1094 19
    /* user clipping planes are disabled by default */
    PACK0(ib, PA_CL_UCP_0_X, 24);
    for (i = 0; i < 24; i++)
	EFLOAT(ib, 0.0);

    // SU
    EREG(ib, PA_SU_SC_MODE_CNTL,                  FACE_bit);
    EREG(ib, PA_SU_POINT_SIZE,                    0);
    EREG(ib, PA_SU_POINT_MINMAX,                  0);
    EREG(ib, PA_SU_POLY_OFFSET_DB_FMT_CNTL,       0);
    EREG(ib, PA_SU_POLY_OFFSET_BACK_SCALE,        0);
    EREG(ib, PA_SU_POLY_OFFSET_FRONT_SCALE,       0);
    EREG(ib, PA_SU_POLY_OFFSET_BACK_OFFSET,       0);
    EREG(ib, PA_SU_POLY_OFFSET_FRONT_OFFSET,      0);

    EREG(ib, PA_SU_LINE_CNTL,                     (8 << PA_SU_LINE_CNTL__WIDTH_shift)); /* Line width 1 pixel */
    EREG(ib, PA_SU_VTX_CNTL,                      ((2 << PA_SU_VTX_CNTL__ROUND_MODE_shift) |
						   (5 << QUANT_MODE_shift))); /* Round to Even, fixed point 1/256 */
    EREG(ib, PA_SU_POLY_OFFSET_CLAMP,             0);
d1102 20
a1121 13
    EREG(ib, SPI_INTERP_CONTROL_0,                ((2 << PNT_SPRITE_OVRD_X_shift)		|
						   (3 << PNT_SPRITE_OVRD_Y_shift)		|
						   (0 << PNT_SPRITE_OVRD_Z_shift)		|
						   (1 << PNT_SPRITE_OVRD_W_shift))); /* s,t,0,1 */
    EREG(ib, SPI_INPUT_Z,                         0);
    EREG(ib, SPI_FOG_CNTL,                        0);
    EREG(ib, SPI_FOG_FUNC_SCALE,                  0);
    EREG(ib, SPI_FOG_FUNC_BIAS,                   0);

    PACK0(ib, SPI_VS_OUT_ID_0, SPI_VS_OUT_ID_0_num);
    for (i = 0; i < SPI_VS_OUT_ID_0_num; i++)		/* identity mapping */
	E32(ib, 0x03020100 + i*0x04040404);
    EREG(ib, SPI_VS_OUT_CONFIG,                   0);
d1124 2
a1125 1
    fs_setup(pScrn, ib, &fs_conf);
d1128 7
a1134 20
    EREG(ib, VGT_MAX_VTX_INDX,                    2048); /* XXX set to a reasonably large number of indices */
    EREG(ib, VGT_MIN_VTX_INDX,                    0);
    EREG(ib, VGT_INDX_OFFSET,                     0);
    EREG(ib, VGT_INSTANCE_STEP_RATE_0,            0);
    EREG(ib, VGT_INSTANCE_STEP_RATE_1,            0);

    EREG(ib, VGT_MULTI_PRIM_IB_RESET_INDX,        0);
    EREG(ib, VGT_OUTPUT_PATH_CNTL,                0);
    EREG(ib, VGT_GS_MODE,                         0);
    EREG(ib, VGT_HOS_CNTL,                        0);
    EREG(ib, VGT_HOS_MAX_TESS_LEVEL,              0);
    EREG(ib, VGT_HOS_MIN_TESS_LEVEL,              0);
    EREG(ib, VGT_HOS_REUSE_DEPTH,                 0);
    EREG(ib, VGT_GROUP_PRIM_TYPE,                 0);
    EREG(ib, VGT_GROUP_FIRST_DECR,                0);
    EREG(ib, VGT_GROUP_DECR,                      0);
    EREG(ib, VGT_GROUP_VECT_0_CNTL,               0);
    EREG(ib, VGT_GROUP_VECT_1_CNTL,               0);
    EREG(ib, VGT_GROUP_VECT_0_FMT_CNTL,           0);
    EREG(ib, VGT_GROUP_VECT_1_FMT_CNTL,           0);
a1136 10
    EREG(ib, VGT_STRMOUT_EN,                      0);
    EREG(ib, VGT_REUSE_OFF,                       0);
    EREG(ib, VGT_VTX_CNT_EN,                      0);
    EREG(ib, VGT_STRMOUT_BUFFER_EN,               0);

    // clear tex resources - PS
    for (i = 0; i < 16; i++) {
	tex_res.id = i;
	set_tex_resource(pScrn, ib, &tex_res);
    }
d1138 27
a1164 11
    // clear tex resources - VS
    for (i = 160; i < 164; i++) {
	tex_res.id = i;
	set_tex_resource(pScrn, ib, &tex_res);
    }

    // clear tex resources - FS
    for (i = 320; i < 335; i++) {
	tex_res.id = i;
	set_tex_resource(pScrn, ib, &tex_res);
    }
d1166 2
d1176 1
a1176 1
draw_immd(ScrnInfoPtr pScrn, drmBufPtr ib, draw_config_t *draw_conf, uint32_t *indices)
d1178 1
a1180 6
    EREG(ib, VGT_PRIMITIVE_TYPE, draw_conf->prim_type);
    PACK3(ib, IT_INDEX_TYPE, 1);
    E32(ib, draw_conf->index_type);
    PACK3(ib, IT_NUM_INSTANCES, 1);
    E32(ib, draw_conf->num_instances);

d1188 11
d1214 1
d1218 1
a1218 1
draw_auto(ScrnInfoPtr pScrn, drmBufPtr ib, draw_config_t *draw_conf)
d1220 1
d1222 1
d1225 3
d1229 1
d1235 58
d1294 1
@

