head	1.8;
access;
symbols
	OPENBSD_5_4:1.7.0.4
	OPENBSD_5_4_BASE:1.7
	OPENBSD_5_3:1.7.0.2
	OPENBSD_5_3_BASE:1.7
	OPENBSD_5_2:1.6.0.2
	OPENBSD_5_2_BASE:1.6
	OPENBSD_5_1_BASE:1.5
	OPENBSD_5_1:1.5.0.2
	OPENBSD_5_0:1.3.0.6
	OPENBSD_5_0_BASE:1.3
	OPENBSD_4_9:1.3.0.2
	OPENBSD_4_9_BASE:1.3
	OPENBSD_4_8:1.3.0.4
	OPENBSD_4_8_BASE:1.3
	OPENBSD_4_7:1.2.0.2
	OPENBSD_4_7_BASE:1.2
	OPENBSD_4_6:1.1.0.6
	OPENBSD_4_6_BASE:1.1
	OPENBSD_4_5:1.1.0.4
	OPENBSD_4_5_BASE:1.1
	OPENBSD_4_4:1.1.0.2
	OPENBSD_4_4_BASE:1.1;
locks; strict;
comment	@ * @;


1.8
date	2013.08.16.17.04.05;	author matthieu;	state dead;
branches;
next	1.7;

1.7
date	2012.08.08.16.25.22;	author matthieu;	state Exp;
branches;
next	1.6;

1.6
date	2012.03.04.16.01.19;	author matthieu;	state Exp;
branches;
next	1.5;

1.5
date	2012.02.06.22.53.12;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2012.01.25.21.33.35;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2010.04.13.19.56.37;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2009.08.25.18.51.45;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2008.07.12.15.18.34;	author oga;	state Exp;
branches;
next	;


desc
@@


1.8
log
@Update to xf86-video-ati 7.2.0, requested by jsg@@

It fixes an endianess problem with kms and the in tree x86-video-ati
among other things.
It has been tested on various i386/amd64/sparc64/macppc machines
on a range of hardware from r100->northern islands.
@
text
@/*
 * Copyright Â© 2007 Red Hat, Inc.
 * Copyright 2007  Advanced Micro Devices, Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice (including the next
 * paragraph) shall be included in all copies or substantial portions of the
 * Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 * Authors:
 *    Dave Airlie <airlied@@redhat.com>
 *    Alex Deucher <alexander.deucher@@amd.com>
 *
 */
/*
 * avivo crtc handling functions.
 */
#ifdef HAVE_CONFIG_H
#include "config.h"
#endif
/* DPMS */
#ifdef HAVE_XEXTPROTO_71
#include <X11/extensions/dpmsconst.h>
#else
#define DPMS_SERVER
#include <X11/extensions/dpms.h>
#endif

#include <math.h>
#include "radeon.h"
#include "radeon_reg.h"
#include "radeon_macros.h"
#include "radeon_atombios.h"

#ifdef XF86DRI
#define _XF86DRI_SERVER_
#include "radeon_drm.h"
#include "sarea.h"
#endif

extern int
atombios_get_encoder_mode(xf86OutputPtr output);

extern void
RADEONInitCrtcBase(xf86CrtcPtr crtc, RADEONSavePtr save,
		   int x, int y);
extern void
RADEONInitCrtc2Base(xf86CrtcPtr crtc, RADEONSavePtr save,
		    int x, int y);
extern void
RADEONRestoreCrtcBase(ScrnInfoPtr pScrn,
		      RADEONSavePtr restore);
extern void
RADEONRestoreCrtc2Base(ScrnInfoPtr pScrn,
		       RADEONSavePtr restore);
extern void
RADEONInitCommonRegisters(RADEONSavePtr save, RADEONInfoPtr info);
extern void
RADEONInitSurfaceCntl(xf86CrtcPtr crtc, RADEONSavePtr save);

AtomBiosResult
atombios_lock_crtc(atomBiosHandlePtr atomBIOS, int crtc, int lock)
{
    ENABLE_CRTC_PS_ALLOCATION crtc_data;
    AtomBiosArgRec data;
    unsigned char *space;

    crtc_data.ucCRTC = crtc;
    crtc_data.ucEnable = lock;

    data.exec.index = GetIndexIntoMasterTable(COMMAND, UpdateCRTC_DoubleBufferRegisters);
    data.exec.dataSpace = (void *)&space;
    data.exec.pspace = &crtc_data;

    if (RHDAtomBiosFunc(atomBIOS->pScrn, atomBIOS, ATOMBIOS_EXEC, &data) == ATOM_SUCCESS) {
	ErrorF("%s CRTC %d success\n", lock? "Lock":"Unlock", crtc);
	return ATOM_SUCCESS ;
    }

    ErrorF("Lock CRTC failed\n");
    return ATOM_NOT_IMPLEMENTED;
}

static AtomBiosResult
atombios_enable_crtc(atomBiosHandlePtr atomBIOS, int crtc, int state)
{
    ENABLE_CRTC_PS_ALLOCATION crtc_data;
    AtomBiosArgRec data;
    unsigned char *space;

    crtc_data.ucCRTC = crtc;
    crtc_data.ucEnable = state;

    data.exec.index = GetIndexIntoMasterTable(COMMAND, EnableCRTC);
    data.exec.dataSpace = (void *)&space;
    data.exec.pspace = &crtc_data;

    if (RHDAtomBiosFunc(atomBIOS->pScrn, atomBIOS, ATOMBIOS_EXEC, &data) == ATOM_SUCCESS) {
	ErrorF("%s CRTC %d success\n", state? "Enable":"Disable", crtc);
	return ATOM_SUCCESS ;
    }

    ErrorF("Enable CRTC failed\n");
    return ATOM_NOT_IMPLEMENTED;
}

static AtomBiosResult
atombios_enable_crtc_memreq(atomBiosHandlePtr atomBIOS, int crtc, int state)
{
    ENABLE_CRTC_PS_ALLOCATION crtc_data;
    AtomBiosArgRec data;
    unsigned char *space;

    crtc_data.ucCRTC = crtc;
    crtc_data.ucEnable = state;

    data.exec.index = GetIndexIntoMasterTable(COMMAND, EnableCRTCMemReq);
    data.exec.dataSpace = (void *)&space;
    data.exec.pspace = &crtc_data;

    if (RHDAtomBiosFunc(atomBIOS->pScrn, atomBIOS, ATOMBIOS_EXEC, &data) == ATOM_SUCCESS) {
	ErrorF("%s CRTC memreq %d success\n", state? "Enable":"Disable", crtc);
	return ATOM_SUCCESS ;
    }

    ErrorF("Enable CRTC memreq failed\n");
    return ATOM_NOT_IMPLEMENTED;
}

static AtomBiosResult
atombios_blank_crtc(atomBiosHandlePtr atomBIOS, int crtc, int state)
{
    BLANK_CRTC_PS_ALLOCATION crtc_data;
    unsigned char *space;
    AtomBiosArgRec data;

    memset(&crtc_data, 0, sizeof(crtc_data));
    crtc_data.ucCRTC = crtc;
    crtc_data.ucBlanking = state;

    data.exec.index = GetIndexIntoMasterTable(COMMAND, BlankCRTC);
    data.exec.dataSpace = (void *)&space;
    data.exec.pspace = &crtc_data;

    if (RHDAtomBiosFunc(atomBIOS->pScrn, atomBIOS, ATOMBIOS_EXEC, &data) == ATOM_SUCCESS) {
	ErrorF("%s CRTC %d success\n", state? "Blank":"Unblank", crtc);
	return ATOM_SUCCESS ;
    }

    ErrorF("Blank CRTC failed\n");
    return ATOM_NOT_IMPLEMENTED;
}

void
atombios_crtc_dpms(xf86CrtcPtr crtc, int mode)
{
    RADEONCrtcPrivatePtr radeon_crtc = crtc->driver_private;
    RADEONInfoPtr  info = RADEONPTR(crtc->scrn);
    switch (mode) {
    case DPMSModeOn:
	atombios_enable_crtc(info->atomBIOS, radeon_crtc->crtc_id, 1);
	if (IS_DCE3_VARIANT)
	    atombios_enable_crtc_memreq(info->atomBIOS, radeon_crtc->crtc_id, 1);
	atombios_blank_crtc(info->atomBIOS, radeon_crtc->crtc_id, 0);
	break;
    case DPMSModeStandby:
    case DPMSModeSuspend:
    case DPMSModeOff:
	atombios_blank_crtc(info->atomBIOS, radeon_crtc->crtc_id, 1);
	if (IS_DCE3_VARIANT)
	    atombios_enable_crtc_memreq(info->atomBIOS, radeon_crtc->crtc_id, 0);
	atombios_enable_crtc(info->atomBIOS, radeon_crtc->crtc_id, 0);
	break;
    }
}

static AtomBiosResult
atombios_set_crtc_timing(xf86CrtcPtr crtc, DisplayModePtr mode)
{
    RADEONCrtcPrivatePtr radeon_crtc = crtc->driver_private;
    RADEONInfoPtr  info = RADEONPTR(crtc->scrn);
    AtomBiosArgRec data;
    unsigned char *space;
    uint16_t misc = 0;
    SET_CRTC_TIMING_PARAMETERS_PS_ALLOCATION param;
    memset(&param, 0, sizeof(param));

    param.usH_Total		= cpu_to_le16(mode->CrtcHTotal);
    param.usH_Disp		= cpu_to_le16(mode->CrtcHDisplay);
    param.usH_SyncStart		= cpu_to_le16(mode->CrtcHSyncStart);
    param.usH_SyncWidth		= cpu_to_le16(mode->CrtcHSyncEnd - mode->CrtcHSyncStart);
    param.usV_Total		= cpu_to_le16(mode->CrtcVTotal);
    param.usV_Disp		= cpu_to_le16(mode->CrtcVDisplay);
    param.usV_SyncStart		= cpu_to_le16(mode->CrtcVSyncStart);
    param.usV_SyncWidth		= cpu_to_le16(mode->CrtcVSyncEnd - mode->CrtcVSyncStart);

    if (mode->Flags & V_NVSYNC)
	misc |= ATOM_VSYNC_POLARITY;

    if (mode->Flags & V_NHSYNC)
	misc |= ATOM_HSYNC_POLARITY;

    if (mode->Flags & V_CSYNC)
	misc |= ATOM_COMPOSITESYNC;

    if (mode->Flags & V_INTERLACE)
	misc |= ATOM_INTERLACE;

    if (mode->Flags & V_DBLSCAN)
	misc |= ATOM_DOUBLE_CLOCK_MODE;

    param.susModeMiscInfo.usAccess      = cpu_to_le16(misc);
    param.ucCRTC			= radeon_crtc->crtc_id;

    data.exec.index = GetIndexIntoMasterTable(COMMAND, SetCRTC_Timing);
    data.exec.dataSpace = (void *)&space;
    data.exec.pspace = &param;

    if (RHDAtomBiosFunc(info->atomBIOS->pScrn, info->atomBIOS, ATOMBIOS_EXEC, &data) == ATOM_SUCCESS) {
	ErrorF("Set CRTC Timing success\n");
	return ATOM_SUCCESS ;
    }

    ErrorF("Set CRTC Timing failed\n");
    return ATOM_NOT_IMPLEMENTED;
}

static AtomBiosResult
atombios_set_crtc_dtd_timing(xf86CrtcPtr crtc, DisplayModePtr mode)
{
    RADEONCrtcPrivatePtr radeon_crtc = crtc->driver_private;
    RADEONInfoPtr  info = RADEONPTR(crtc->scrn);
    AtomBiosArgRec data;
    unsigned char *space;
    uint16_t misc = 0;
    SET_CRTC_USING_DTD_TIMING_PARAMETERS param;
    memset(&param, 0, sizeof(param));

    param.usH_Size          = cpu_to_le16(mode->CrtcHDisplay);
    param.usH_Blanking_Time = cpu_to_le16(mode->CrtcHBlankEnd - mode->CrtcHDisplay);
    param.usV_Size          = cpu_to_le16(mode->CrtcVDisplay);
    param.usV_Blanking_Time = cpu_to_le16(mode->CrtcVBlankEnd - mode->CrtcVDisplay);
    param.usH_SyncOffset    = cpu_to_le16(mode->CrtcHSyncStart - mode->CrtcHDisplay);
    param.usH_SyncWidth     = cpu_to_le16(mode->CrtcHSyncEnd - mode->CrtcHSyncStart);
    param.usV_SyncOffset    = cpu_to_le16(mode->CrtcVSyncStart - mode->CrtcVDisplay);
    param.usV_SyncWidth     = cpu_to_le16(mode->CrtcVSyncEnd - mode->CrtcVSyncStart);

    if (mode->Flags & V_NVSYNC)
	misc |= ATOM_VSYNC_POLARITY;

    if (mode->Flags & V_NHSYNC)
	misc |= ATOM_HSYNC_POLARITY;

    if (mode->Flags & V_CSYNC)
	misc |= ATOM_COMPOSITESYNC;

    if (mode->Flags & V_INTERLACE)
	misc |= ATOM_INTERLACE;

    if (mode->Flags & V_DBLSCAN)
	misc |= ATOM_DOUBLE_CLOCK_MODE;

    param.susModeMiscInfo.usAccess = cpu_to_le16(misc);
    param.ucCRTC= radeon_crtc->crtc_id;

    data.exec.index = GetIndexIntoMasterTable(COMMAND, SetCRTC_UsingDTDTiming);
    data.exec.dataSpace = (void *)&space;
    data.exec.pspace = &param;

    if (RHDAtomBiosFunc(info->atomBIOS->pScrn, info->atomBIOS, ATOMBIOS_EXEC, &data) == ATOM_SUCCESS) {
	ErrorF("Set DTD CRTC Timing success\n");
	return ATOM_SUCCESS ;
    }

    ErrorF("Set DTD CRTC Timing failed\n");
    return ATOM_NOT_IMPLEMENTED;
}

static void
atombios_pick_pll(xf86CrtcPtr crtc)
{
    RADEONCrtcPrivatePtr radeon_crtc = crtc->driver_private;
    RADEONInfoPtr info = RADEONPTR(crtc->scrn);
    xf86CrtcConfigPtr xf86_config = XF86_CRTC_CONFIG_PTR(crtc->scrn);
    xf86OutputPtr output;
    RADEONOutputPrivatePtr radeon_output;
    int o, c;
    uint32_t pll_use_mask = 0;
    Bool is_dp = FALSE;

    if (IS_DCE4_VARIANT) {
	for (o = 0; o < xf86_config->num_output; o++) {
	    output = xf86_config->output[o];
	    if (output->crtc == crtc) {
		int mode = atombios_get_encoder_mode(output);
		radeon_output = output->driver_private;

		if (mode == ATOM_ENCODER_MODE_DP) {
		    is_dp = TRUE;
		    break;
		} else {
		    for (c = 0; c < xf86_config->num_crtc; c++) {
			xf86CrtcPtr test_crtc = xf86_config->crtc[c];
			RADEONCrtcPrivatePtr radeon_test_crtc = test_crtc->driver_private;

			if (crtc != test_crtc && (radeon_test_crtc->pll_id >= 0))
			    pll_use_mask |= (1 << radeon_test_crtc->pll_id);

		    }
		}
	    }
	}
	/* DP clock comes from DCPLL, DP PHY CLK comes from ext source
	 * setting ATOM_PPLL_INVALID skips the PPLL programming for DP
	 */
	if (is_dp)
	    radeon_crtc->pll_id = ATOM_PPLL_INVALID;
	else if (!(pll_use_mask & 1))
	    radeon_crtc->pll_id = ATOM_PPLL1;
	else
	    radeon_crtc->pll_id = ATOM_PPLL2;
    } else
	radeon_crtc->pll_id = radeon_crtc->crtc_id;

    ErrorF("Picked PLL %d\n", radeon_crtc->pll_id);

    for (o = 0; o < xf86_config->num_output; o++) {
	output = xf86_config->output[o];
	if (output->crtc == crtc) {
	    radeon_output = output->driver_private;
	    radeon_output->pll_id = radeon_crtc->pll_id;
	}
    }
}

union adjust_pixel_clock {
	ADJUST_DISPLAY_PLL_PS_ALLOCATION v1;
	ADJUST_DISPLAY_PLL_PS_ALLOCATION_V3 v3;
};

static uint32_t atombios_adjust_pll(xf86CrtcPtr crtc, DisplayModePtr mode, int *pll_flags_p)
{
    RADEONCrtcPrivatePtr radeon_crtc = crtc->driver_private;
    ScrnInfoPtr pScrn = crtc->scrn;
    RADEONInfoPtr  info = RADEONPTR(pScrn);
    xf86CrtcConfigPtr   xf86_config = XF86_CRTC_CONFIG_PTR(crtc->scrn);
    uint32_t adjusted_clock = mode->Clock;
    RADEONOutputPrivatePtr radeon_output = NULL;
    radeon_encoder_ptr radeon_encoder = NULL;
    xf86OutputPtr output;
    int pll_flags = 0;
    int i;

    if (IS_AVIVO_VARIANT) {
	if (xf86ReturnOptValBool(info->Options, OPTION_NEW_PLL, TRUE))
	    radeon_crtc->pll_algo = RADEON_PLL_NEW;
	else
	    radeon_crtc->pll_algo = RADEON_PLL_OLD;
    } else {
	if (xf86ReturnOptValBool(info->Options, OPTION_NEW_PLL, FALSE))
	    radeon_crtc->pll_algo = RADEON_PLL_NEW;
	else
	    radeon_crtc->pll_algo = RADEON_PLL_OLD;
    }

    if (IS_AVIVO_VARIANT) {
	if ((info->ChipFamily == CHIP_FAMILY_RS600) ||
	    (info->ChipFamily == CHIP_FAMILY_RS690) ||
	    (info->ChipFamily == CHIP_FAMILY_RS740))
	    pll_flags |= /*RADEON_PLL_USE_FRAC_FB_DIV |*/
		RADEON_PLL_PREFER_CLOSEST_LOWER;
	if (IS_DCE32_VARIANT && mode->Clock > 200000) /* range limits??? */
	    pll_flags |= RADEON_PLL_PREFER_HIGH_FB_DIV;
	else
	    pll_flags |= RADEON_PLL_PREFER_LOW_REF_DIV;
    } else {
	pll_flags |= RADEON_PLL_LEGACY;

	if (mode->Clock > 200000) /* range limits??? */
	    pll_flags |= RADEON_PLL_PREFER_HIGH_FB_DIV;
	else
	    pll_flags |= RADEON_PLL_PREFER_LOW_REF_DIV;
    }
    
    for (i = 0; i < xf86_config->num_output; i++) {
	output = xf86_config->output[i];
	if (output->crtc == crtc) {
	    radeon_output = output->driver_private;
	    radeon_encoder = radeon_get_encoder(output);
	    if (IS_AVIVO_VARIANT) {
		/* DVO wants 2x pixel clock if the DVO chip is in 12 bit mode */
		if (radeon_encoder &&
		    (radeon_encoder->encoder_id == ENCODER_OBJECT_ID_INTERNAL_KLDSCP_DVO1) &&
		    !IS_DCE3_VARIANT)
		    adjusted_clock *= 2;
		if (radeon_output->active_device &
		    (ATOM_DEVICE_CV_SUPPORT | ATOM_DEVICE_TV_SUPPORT)) {
		    pll_flags |= RADEON_PLL_PREFER_CLOSEST_LOWER;
		    radeon_crtc->pll_algo = RADEON_PLL_OLD;
		}
	    } else {
		if (radeon_output->active_device & (ATOM_DEVICE_LCD_SUPPORT |
						    ATOM_DEVICE_DFP_SUPPORT))
		    pll_flags |= RADEON_PLL_NO_ODD_POST_DIV;
		if (radeon_output->active_device & (ATOM_DEVICE_LCD_SUPPORT))
		    pll_flags |= (RADEON_PLL_USE_BIOS_DIVS | RADEON_PLL_USE_REF_DIV);
	    }
    	    if (IS_DCE3_VARIANT)
		break;
	}
    }
    
    if (IS_DCE3_VARIANT) {
	union adjust_pixel_clock args;
	int major, minor, index;
	AtomBiosArgRec data;
	unsigned char *space;

	memset(&args, 0, sizeof(args));

	index = GetIndexIntoMasterTable(COMMAND, AdjustDisplayPll);

	atombios_get_command_table_version(info->atomBIOS, index, &major, &minor);

	data.exec.index = index;
	data.exec.dataSpace = (void *)&space;
	data.exec.pspace = &args;

	switch(major) {
	case 1:
	    switch(minor) {
	    case 1:
	    case 2:
		args.v1.usPixelClock = cpu_to_le16(adjusted_clock / 10);
		args.v1.ucTransmitterID = radeon_encoder->encoder_id;
		args.v1.ucEncodeMode = atombios_get_encoder_mode(output);

		ErrorF("before %d\n", args.v1.usPixelClock);
		if (RHDAtomBiosFunc(info->atomBIOS->pScrn, info->atomBIOS, ATOMBIOS_EXEC, &data) == ATOM_SUCCESS) {
		    adjusted_clock = le16_to_cpu(args.v1.usPixelClock) * 10;
		}
		ErrorF("after %d\n", args.v1.usPixelClock);
		break;
	    case 3:
		args.v3.sInput.usPixelClock = cpu_to_le16(adjusted_clock / 10);
		args.v3.sInput.ucTransmitterID = radeon_encoder->encoder_id;
		args.v3.sInput.ucEncodeMode = atombios_get_encoder_mode(output);
		args.v3.sInput.ucDispPllConfig = 0;
		if (radeon_output->coherent_mode || (args.v3.sInput.ucEncodeMode == ATOM_ENCODER_MODE_DP))
		    args.v3.sInput.ucDispPllConfig |= DISPPLL_CONFIG_COHERENT_MODE;
		if (adjusted_clock > 165000)
		    args.v3.sInput.ucDispPllConfig |= DISPPLL_CONFIG_DUAL_LINK;
		// if SS
		//    args.v3.sInput.ucDispPllConfig |= DISPPLL_CONFIG_SS_ENABLE;

		ErrorF("before %d 0x%x\n", args.v3.sInput.usPixelClock, args.v3.sInput.ucDispPllConfig);
		if (RHDAtomBiosFunc(info->atomBIOS->pScrn, info->atomBIOS, ATOMBIOS_EXEC, &data) == ATOM_SUCCESS) {
		    adjusted_clock = args.v3.sOutput.ulDispPllFreq * 10;
		    if (args.v3.sOutput.ucRefDiv) {
			pll_flags |= RADEON_PLL_USE_REF_DIV;
			info->pll.reference_div = args.v3.sOutput.ucRefDiv;
		    }
		    if (args.v3.sOutput.ucPostDiv) {
			pll_flags |= RADEON_PLL_USE_POST_DIV;
			info->pll.post_div = args.v3.sOutput.ucPostDiv;
		    }
		    ErrorF("after %d %d %d\n", args.v3.sOutput.ulDispPllFreq,
			   args.v3.sOutput.ucRefDiv, args.v3.sOutput.ucPostDiv);
		}
		break;
	    default:
		ErrorF("%s: Unknown table version %d %d\n", __func__, major, minor);
		goto out;
	    }
	    break;
	default:
	    ErrorF("%s: Unknown table version %d %d\n", __func__, major, minor);
	    goto out;
	}
    }
out:
    *pll_flags_p = pll_flags;
    return adjusted_clock;
}
				    
union set_pixel_clock {
	SET_PIXEL_CLOCK_PS_ALLOCATION base;
	PIXEL_CLOCK_PARAMETERS v1;
	PIXEL_CLOCK_PARAMETERS_V2 v2;
	PIXEL_CLOCK_PARAMETERS_V3 v3;
	PIXEL_CLOCK_PARAMETERS_V5 v5;
};

static void
atombios_crtc_set_dcpll(xf86CrtcPtr crtc)
{
    RADEONInfoPtr  info = RADEONPTR(crtc->scrn);
    xf86CrtcConfigPtr   xf86_config = XF86_CRTC_CONFIG_PTR(crtc->scrn);
    xf86OutputPtr output = NULL;
    RADEONOutputPrivatePtr radeon_output = NULL;
    radeon_encoder_ptr radeon_encoder = NULL;
    int index;
    int major, minor, i;
    union set_pixel_clock args;
    AtomBiosArgRec data;
    unsigned char *space;

    memset(&args, 0, sizeof(args));

    for (i = 0; i < xf86_config->num_output; i++) {
	output = xf86_config->output[i];
	if (output->crtc == crtc) {
	    radeon_output = output->driver_private;
	    radeon_encoder = radeon_get_encoder(output);
	    break;
	}
    }

    if (radeon_output == NULL) {
	xf86DrvMsg(crtc->scrn->scrnIndex, X_ERROR, "No output assigned to crtc!\n");
	return;
    }

    if (radeon_encoder == NULL) {
	xf86DrvMsg(crtc->scrn->scrnIndex, X_ERROR, "No encoder assigned to output!\n");
	return;
    }

    index = GetIndexIntoMasterTable(COMMAND, SetPixelClock);
    atombios_get_command_table_version(info->atomBIOS, index, &major, &minor);

    /*ErrorF("table is %d %d\n", major, minor);*/
    switch(major) {
    case 1:
	switch(minor) {
	case 5:
	    args.v5.ucCRTC = ATOM_CRTC_INVALID;
	    /* XXX: get this from the firmwareinfo table */
	    args.v5.usPixelClock = info->default_dispclk;
	    args.v5.ucPpll = ATOM_DCPLL;
	    break;
	default:
	    ErrorF("Unknown table version\n");
	    exit(-1);
	}
	break;
    default:
	ErrorF("Unknown table version\n");
	exit(-1);
    }

    data.exec.index = index;
    data.exec.dataSpace = (void *)&space;
    data.exec.pspace = &args;

    if (RHDAtomBiosFunc(info->atomBIOS->pScrn, info->atomBIOS, ATOMBIOS_EXEC, &data) == ATOM_SUCCESS) {
	ErrorF("Set DCPLL success\n");
	return;
    }

    ErrorF("Set DCPLL failed\n");
    return;
}

static void
atombios_crtc_set_pll(xf86CrtcPtr crtc, DisplayModePtr mode)
{
    RADEONCrtcPrivatePtr radeon_crtc = crtc->driver_private;
    ScrnInfoPtr pScrn = crtc->scrn;
    RADEONInfoPtr  info = RADEONPTR(pScrn);
    unsigned char *RADEONMMIO = info->MMIO;
    int index;
    uint32_t sclock;
    uint32_t ref_div = 0, fb_div = 0, frac_fb_div = 0, post_div = 0;
    int major, minor;
    union set_pixel_clock args;
    xf86OutputPtr output = NULL;
    xf86CrtcConfigPtr   xf86_config = XF86_CRTC_CONFIG_PTR(crtc->scrn);
    radeon_encoder_ptr radeon_encoder = NULL;
    int pll_flags = 0;
    uint32_t temp;
    AtomBiosArgRec data;
    unsigned char *space;
    int i;

    memset(&args, 0, sizeof(args));

    if (IS_DCE4_VARIANT) {
	/* XXX 6 crtcs, but only 2 plls */
	switch (radeon_crtc->pll_id) {
	case ATOM_PPLL1:
	    temp = INREG(EVERGREEN_P1PLL_SS_CNTL);
	    OUTREG(EVERGREEN_P1PLL_SS_CNTL, temp & ~EVERGREEN_PxPLL_SS_EN);
	    break;
	case ATOM_PPLL2:
	    temp = INREG(EVERGREEN_P2PLL_SS_CNTL);
	    OUTREG(EVERGREEN_P2PLL_SS_CNTL, temp & ~EVERGREEN_PxPLL_SS_EN);
	    break;
	}
    } else {
	if (radeon_crtc->crtc_id == 0) {
	    temp = INREG(AVIVO_P1PLL_INT_SS_CNTL);
	    OUTREG(AVIVO_P1PLL_INT_SS_CNTL, temp & ~1);
	} else {
	    temp = INREG(AVIVO_P2PLL_INT_SS_CNTL);
	    OUTREG(AVIVO_P2PLL_INT_SS_CNTL, temp & ~1);
	}
    }

    if (IS_DCE3_VARIANT) {
	for (i = 0; i < xf86_config->num_output; i++) {
	    output = xf86_config->output[i];
	    if (output->crtc == crtc) {
		radeon_encoder = radeon_get_encoder(output);
		break;
	    }
	}

	if (output->driver_private == NULL) {
	    xf86DrvMsg(crtc->scrn->scrnIndex, X_ERROR, "No output assigned to crtc!\n");
	    return;
	}
	if (radeon_encoder == NULL) {
	    xf86DrvMsg(crtc->scrn->scrnIndex, X_ERROR, "No encoder assigned to output!\n");
	    return;
	}
    }

    sclock = atombios_adjust_pll(crtc, mode, &pll_flags);

    RADEONComputePLL(crtc, &info->pll, sclock, &temp,
		     &fb_div, &frac_fb_div, &ref_div, &post_div, pll_flags);
    sclock = temp; /* 10 khz */

    xf86DrvMsg(crtc->scrn->scrnIndex, X_INFO,
	       "crtc(%d) Clock: mode %d, PLL %lu\n",
	       radeon_crtc->crtc_id, mode->Clock, (long unsigned int)sclock * 10);
    xf86DrvMsg(crtc->scrn->scrnIndex, X_INFO,
	       "crtc(%d) PLL  : refdiv %u, fbdiv 0x%X(%u), fracfbdiv %u, pdiv %u\n",
	       radeon_crtc->crtc_id, (unsigned int)ref_div, (unsigned int)fb_div,
	       (unsigned int)fb_div, (unsigned int)frac_fb_div, (unsigned int)post_div);

    index = GetIndexIntoMasterTable(COMMAND, SetPixelClock);
    atombios_get_command_table_version(info->atomBIOS, index, &major, &minor);

    /*ErrorF("table is %d %d\n", major, minor);*/
    switch(major) {
    case 1:
	switch(minor) {
	case 1:
	case 2:
	    args.v2.usPixelClock = cpu_to_le16(mode->Clock / 10);
	    args.v2.usRefDiv = cpu_to_le16(ref_div);
	    args.v2.usFbDiv = cpu_to_le16(fb_div);
	    args.v2.ucFracFbDiv = frac_fb_div;
	    args.v2.ucPostDiv = post_div;
	    args.v2.ucPpll = radeon_crtc->pll_id;
	    args.v2.ucCRTC = radeon_crtc->crtc_id;
	    args.v2.ucRefDivSrc = 1;
	    break;
	case 3:
	    args.v3.usPixelClock = cpu_to_le16(mode->Clock / 10);
	    args.v3.usRefDiv = cpu_to_le16(ref_div);
	    args.v3.usFbDiv = cpu_to_le16(fb_div);
	    args.v3.ucFracFbDiv = frac_fb_div;
	    args.v3.ucPostDiv = post_div;
	    args.v3.ucPpll = radeon_crtc->pll_id;
	    args.v3.ucMiscInfo = (radeon_crtc->crtc_id << 2);
	    args.v3.ucTransmitterId = radeon_encoder->encoder_id;
	    args.v3.ucEncoderMode = atombios_get_encoder_mode(output);
	    break;
	case 5:
	    args.v5.ucCRTC = radeon_crtc->crtc_id;
	    args.v5.usPixelClock = cpu_to_le16(mode->Clock / 10);
	    args.v5.ucRefDiv = ref_div;
	    args.v5.usFbDiv = cpu_to_le16(fb_div);
	    args.v5.ulFbDivDecFrac = cpu_to_le32(frac_fb_div * 100000);
	    args.v5.ucPostDiv = post_div;
	    args.v5.ucPpll = radeon_crtc->pll_id;
	    args.v5.ucMiscInfo = 0; //HDMI depth
	    args.v5.ucTransmitterID = radeon_encoder->encoder_id;
	    args.v5.ucEncoderMode = atombios_get_encoder_mode(output);
	    break;
	default:
	    ErrorF("Unknown table version\n");
	    exit(-1);
	}
	break;
    default:
	ErrorF("Unknown table version\n");
	exit(-1);
    }

    data.exec.index = index;
    data.exec.dataSpace = (void *)&space;
    data.exec.pspace = &args;

    if (RHDAtomBiosFunc(info->atomBIOS->pScrn, info->atomBIOS, ATOMBIOS_EXEC, &data) == ATOM_SUCCESS) {
	ErrorF("Set CRTC %d PLL success\n", radeon_crtc->crtc_id);
	return;
    }

    ErrorF("Set CRTC %d PLL failed\n", radeon_crtc->crtc_id);
    return;
}

static void evergreen_set_base_format(xf86CrtcPtr crtc,
				      DisplayModePtr mode,
				      DisplayModePtr adjusted_mode,
				      int x, int y)
{
    ScrnInfoPtr pScrn = crtc->scrn;
    RADEONCrtcPrivatePtr radeon_crtc = crtc->driver_private;
    RADEONInfoPtr  info = RADEONPTR(pScrn);
    unsigned char *RADEONMMIO = info->MMIO;
    uint64_t fb_location = crtc->scrn->fbOffset + info->fbLocation;
    uint32_t fb_format;
    uint32_t fb_swap = EVERGREEN_GRPH_ENDIAN_SWAP(EVERGREEN_GRPH_ENDIAN_NONE);

    switch (crtc->scrn->bitsPerPixel) {
    case 15:
	fb_format = (EVERGREEN_GRPH_DEPTH(EVERGREEN_GRPH_DEPTH_16BPP) |
		     EVERGREEN_GRPH_FORMAT(EVERGREEN_GRPH_FORMAT_ARGB1555));
	break;
    case 16:
	fb_format = (EVERGREEN_GRPH_DEPTH(EVERGREEN_GRPH_DEPTH_16BPP) |
		     EVERGREEN_GRPH_FORMAT(EVERGREEN_GRPH_FORMAT_ARGB565));
#if X_BYTE_ORDER == X_BIG_ENDIAN
	fb_swap = EVERGREEN_GRPH_ENDIAN_SWAP(EVERGREEN_GRPH_ENDIAN_8IN16);
#endif
	break;
    case 24:
    case 32:
	fb_format = (EVERGREEN_GRPH_DEPTH(EVERGREEN_GRPH_DEPTH_32BPP) |
		     EVERGREEN_GRPH_FORMAT(EVERGREEN_GRPH_FORMAT_ARGB8888));
#if X_BYTE_ORDER == X_BIG_ENDIAN
	fb_swap = EVERGREEN_GRPH_ENDIAN_SWAP(EVERGREEN_GRPH_ENDIAN_8IN32);
#endif
	break;
    default:
	FatalError("Unsupported screen depth: %d\n", xf86GetDepth());
    }

    switch (radeon_crtc->crtc_id) {
    case 0:
    default:
	OUTREG(AVIVO_D1VGA_CONTROL, 0);
	break;
    case 1:
	OUTREG(AVIVO_D2VGA_CONTROL, 0);
	break;
    case 2:
	OUTREG(EVERGREEN_D3VGA_CONTROL, 0);
	break;
    case 3:
	OUTREG(EVERGREEN_D4VGA_CONTROL, 0);
	break;
    case 4:
	OUTREG(EVERGREEN_D5VGA_CONTROL, 0);
	break;
    case 5:
	OUTREG(EVERGREEN_D6VGA_CONTROL, 0);
	break;
    }

    /* setup fb format and location
     */
    if (crtc->rotatedData != NULL) {
	/* x/y offset is already included */
	x = 0;
	y = 0;
	fb_location = fb_location + (char *)crtc->rotatedData - (char *)info->FB;
    }


    OUTREG(EVERGREEN_GRPH_PRIMARY_SURFACE_ADDRESS_HIGH + radeon_crtc->crtc_offset,
	   (fb_location >> 32) & 0xf);
    OUTREG(EVERGREEN_GRPH_SECONDARY_SURFACE_ADDRESS_HIGH + radeon_crtc->crtc_offset,
	   (fb_location >> 32) & 0xf);
    OUTREG(EVERGREEN_GRPH_PRIMARY_SURFACE_ADDRESS + radeon_crtc->crtc_offset,
	   fb_location & EVERGREEN_GRPH_SURFACE_ADDRESS_MASK);
    OUTREG(EVERGREEN_GRPH_SECONDARY_SURFACE_ADDRESS + radeon_crtc->crtc_offset,
	   fb_location & EVERGREEN_GRPH_SURFACE_ADDRESS_MASK);
    OUTREG(EVERGREEN_GRPH_CONTROL + radeon_crtc->crtc_offset, fb_format);
    OUTREG(EVERGREEN_GRPH_SWAP_CONTROL + radeon_crtc->crtc_offset, fb_swap);

    OUTREG(EVERGREEN_GRPH_SURFACE_OFFSET_X + radeon_crtc->crtc_offset, 0);
    OUTREG(EVERGREEN_GRPH_SURFACE_OFFSET_Y + radeon_crtc->crtc_offset, 0);
    OUTREG(EVERGREEN_GRPH_X_START + radeon_crtc->crtc_offset, 0);
    OUTREG(EVERGREEN_GRPH_Y_START + radeon_crtc->crtc_offset, 0);
    OUTREG(EVERGREEN_GRPH_X_END + radeon_crtc->crtc_offset, info->virtualX);
    OUTREG(EVERGREEN_GRPH_Y_END + radeon_crtc->crtc_offset, info->virtualY);
    OUTREG(EVERGREEN_GRPH_PITCH + radeon_crtc->crtc_offset,
	   crtc->scrn->displayWidth);
    OUTREG(EVERGREEN_GRPH_ENABLE + radeon_crtc->crtc_offset, 1);

    OUTREG(EVERGREEN_DESKTOP_HEIGHT + radeon_crtc->crtc_offset, mode->VDisplay);
    x &= ~3;
    y &= ~1;
    OUTREG(EVERGREEN_VIEWPORT_START + radeon_crtc->crtc_offset, (x << 16) | y);
    OUTREG(EVERGREEN_VIEWPORT_SIZE + radeon_crtc->crtc_offset, (mode->HDisplay << 16) | mode->VDisplay);

    if (adjusted_mode->Flags & V_INTERLACE)
	OUTREG(EVERGREEN_DATA_FORMAT + radeon_crtc->crtc_offset, EVERGREEN_INTERLEAVE_EN);
    else
	OUTREG(EVERGREEN_DATA_FORMAT + radeon_crtc->crtc_offset, 0);

}

static void avivo_set_base_format(xf86CrtcPtr crtc,
				  DisplayModePtr mode,
				  DisplayModePtr adjusted_mode,
				  int x, int y)
{
    ScrnInfoPtr pScrn = crtc->scrn;
    RADEONCrtcPrivatePtr radeon_crtc = crtc->driver_private;
    RADEONInfoPtr  info = RADEONPTR(pScrn);
    unsigned char *RADEONMMIO = info->MMIO;
    uint64_t fb_location = crtc->scrn->fbOffset + info->fbLocation;
    uint32_t fb_format;
#if X_BYTE_ORDER == X_BIG_ENDIAN
    uint32_t fb_swap = R600_D1GRPH_SWAP_ENDIAN_NONE;
#endif

    switch (crtc->scrn->bitsPerPixel) {
    case 15:
	fb_format = AVIVO_D1GRPH_CONTROL_DEPTH_16BPP | AVIVO_D1GRPH_CONTROL_16BPP_ARGB1555;
	break;
    case 16:
	fb_format = AVIVO_D1GRPH_CONTROL_DEPTH_16BPP | AVIVO_D1GRPH_CONTROL_16BPP_RGB565;
#if X_BYTE_ORDER == X_BIG_ENDIAN
	fb_swap = R600_D1GRPH_SWAP_ENDIAN_16BIT;
#endif
	break;
    case 24:
    case 32:
	fb_format = AVIVO_D1GRPH_CONTROL_DEPTH_32BPP | AVIVO_D1GRPH_CONTROL_32BPP_ARGB8888;
#if X_BYTE_ORDER == X_BIG_ENDIAN
	fb_swap = R600_D1GRPH_SWAP_ENDIAN_32BIT;
#endif
	break;
    default:
	FatalError("Unsupported screen depth: %d\n", xf86GetDepth());
    }

    if (info->tilingEnabled && (crtc->rotatedData == NULL)) {
	fb_format |= AVIVO_D1GRPH_MACRO_ADDRESS_MODE;
    }

    if (radeon_crtc->crtc_id == 0)
	OUTREG(AVIVO_D1VGA_CONTROL, 0);
    else
	OUTREG(AVIVO_D2VGA_CONTROL, 0);

    /* setup fb format and location
     */
    if (crtc->rotatedData != NULL) {
	/* x/y offset is already included */
	x = 0;
	y = 0;
	fb_location = fb_location + (char *)crtc->rotatedData - (char *)info->FB;
    }

    if (info->ChipFamily >= CHIP_FAMILY_RV770) {
	if (radeon_crtc->crtc_id) {
	    OUTREG(R700_D2GRPH_PRIMARY_SURFACE_ADDRESS_HIGH, (fb_location >> 32) & 0xf);
	    OUTREG(R700_D2GRPH_SECONDARY_SURFACE_ADDRESS_HIGH, (fb_location >> 32) & 0xf);
	} else {
	    OUTREG(R700_D1GRPH_PRIMARY_SURFACE_ADDRESS_HIGH, (fb_location >> 32) & 0xf);
	    OUTREG(R700_D1GRPH_SECONDARY_SURFACE_ADDRESS_HIGH, (fb_location >> 32) & 0xf);
	}
    }
    OUTREG(AVIVO_D1GRPH_PRIMARY_SURFACE_ADDRESS + radeon_crtc->crtc_offset,
	   fb_location & 0xffffffff);
    OUTREG(AVIVO_D1GRPH_SECONDARY_SURFACE_ADDRESS + radeon_crtc->crtc_offset,
	   fb_location & 0xffffffff);
    OUTREG(AVIVO_D1GRPH_CONTROL + radeon_crtc->crtc_offset, fb_format);

#if X_BYTE_ORDER == X_BIG_ENDIAN
    if (info->ChipFamily >= CHIP_FAMILY_R600)
	OUTREG(R600_D1GRPH_SWAP_CONTROL + radeon_crtc->crtc_offset, fb_swap);
#endif

    OUTREG(AVIVO_D1GRPH_SURFACE_OFFSET_X + radeon_crtc->crtc_offset, 0);
    OUTREG(AVIVO_D1GRPH_SURFACE_OFFSET_Y + radeon_crtc->crtc_offset, 0);
    OUTREG(AVIVO_D1GRPH_X_START + radeon_crtc->crtc_offset, 0);
    OUTREG(AVIVO_D1GRPH_Y_START + radeon_crtc->crtc_offset, 0);
    OUTREG(AVIVO_D1GRPH_X_END + radeon_crtc->crtc_offset, info->virtualX);
    OUTREG(AVIVO_D1GRPH_Y_END + radeon_crtc->crtc_offset, info->virtualY);
    OUTREG(AVIVO_D1GRPH_PITCH + radeon_crtc->crtc_offset,
	   crtc->scrn->displayWidth);
    OUTREG(AVIVO_D1GRPH_ENABLE + radeon_crtc->crtc_offset, 1);

    OUTREG(AVIVO_D1MODE_DESKTOP_HEIGHT + radeon_crtc->crtc_offset, mode->VDisplay);
    x &= ~3;
    y &= ~1;
    OUTREG(AVIVO_D1MODE_VIEWPORT_START + radeon_crtc->crtc_offset, (x << 16) | y);
    OUTREG(AVIVO_D1MODE_VIEWPORT_SIZE + radeon_crtc->crtc_offset,
	   (mode->HDisplay << 16) | mode->VDisplay);

    if (mode->Flags & V_INTERLACE)
	OUTREG(AVIVO_D1MODE_DATA_FORMAT + radeon_crtc->crtc_offset,
	       AVIVO_D1MODE_INTERLEAVE_EN);
    else
	OUTREG(AVIVO_D1MODE_DATA_FORMAT + radeon_crtc->crtc_offset, 0);
}

static void legacy_set_base_format(xf86CrtcPtr crtc,
				   DisplayModePtr mode,
				   DisplayModePtr adjusted_mode,
				   int x, int y)
{
    ScrnInfoPtr pScrn = crtc->scrn;
    RADEONCrtcPrivatePtr radeon_crtc = crtc->driver_private;
    RADEONInfoPtr  info = RADEONPTR(pScrn);
    unsigned char *RADEONMMIO = info->MMIO;
    int format = 0;
    uint32_t crtc_gen_cntl, crtc2_gen_cntl, crtc_pitch;

    RADEONInitCommonRegisters(info->ModeReg, info);
    RADEONInitSurfaceCntl(crtc, info->ModeReg);
    RADEONRestoreCommonRegisters(pScrn, info->ModeReg);

    switch (info->CurrentLayout.pixel_code) {
    case 4:  format = 1; break;
    case 8:  format = 2; break;
    case 15: format = 3; break;      /*  555 */
    case 16: format = 4; break;      /*  565 */
    case 24: format = 5; break;      /*  RGB */
    case 32: format = 6; break;      /* xRGB */
    default:
	xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
		   "Unsupported pixel depth (%d)\n",
		   info->CurrentLayout.bitsPerPixel);
    }

    crtc_pitch  = (((pScrn->displayWidth * pScrn->bitsPerPixel) +
		    ((pScrn->bitsPerPixel * 8) -1)) /
		       (pScrn->bitsPerPixel * 8));
    crtc_pitch |= crtc_pitch << 16;

    switch (radeon_crtc->crtc_id) {
    case 0:
	crtc_gen_cntl = INREG(RADEON_CRTC_GEN_CNTL) & 0xfffff0ff;
	crtc_gen_cntl |= (format << 8);
	OUTREG(RADEON_CRTC_GEN_CNTL, crtc_gen_cntl);
	OUTREG(RADEON_CRTC_PITCH, crtc_pitch);
	RADEONInitCrtcBase(crtc, info->ModeReg, x, y);
	RADEONRestoreCrtcBase(pScrn, info->ModeReg);
	break;
    case 1:
	crtc2_gen_cntl = INREG(RADEON_CRTC2_GEN_CNTL) & 0xfffff0ff;
	crtc2_gen_cntl |= (format << 8);
	OUTREG(RADEON_CRTC2_GEN_CNTL, crtc2_gen_cntl);
	OUTREG(RADEON_CRTC2_PITCH, crtc_pitch);
	RADEONInitCrtc2Base(crtc, info->ModeReg, x, y);
	RADEONRestoreCrtc2Base(pScrn, info->ModeReg);
	OUTREG(RADEON_FP_H2_SYNC_STRT_WID,   INREG(RADEON_CRTC2_H_SYNC_STRT_WID));
	OUTREG(RADEON_FP_V2_SYNC_STRT_WID,   INREG(RADEON_CRTC2_V_SYNC_STRT_WID));
	break;
    }
}

void
atombios_crtc_mode_set(xf86CrtcPtr crtc,
		       DisplayModePtr mode,
		       DisplayModePtr adjusted_mode,
		       int x, int y)
{
    ScrnInfoPtr pScrn = crtc->scrn;
    RADEONCrtcPrivatePtr radeon_crtc = crtc->driver_private;
    RADEONInfoPtr  info = RADEONPTR(pScrn);
    Bool tilingChanged = FALSE;

    if (info->allowColorTiling) {
	radeon_crtc->can_tile = (mode->Flags & (V_DBLSCAN | V_INTERLACE)) ? FALSE : TRUE;
	tilingChanged = RADEONSetTiling(pScrn);
    }

    ErrorF("Mode %dx%d - %d %d %d\n", adjusted_mode->CrtcHDisplay, adjusted_mode->CrtcVDisplay,
	   adjusted_mode->CrtcHTotal, adjusted_mode->CrtcVTotal, adjusted_mode->Flags);

    RADEONInitMemMapRegisters(pScrn, info->ModeReg, info);
    RADEONRestoreMemMapRegisters(pScrn, info->ModeReg);

    if (IS_DCE4_VARIANT)
	atombios_crtc_set_dcpll(crtc);
    atombios_pick_pll(crtc);
    atombios_crtc_set_pll(crtc, adjusted_mode);
    if (IS_DCE4_VARIANT)
	atombios_set_crtc_dtd_timing(crtc, adjusted_mode);
    else {
	atombios_set_crtc_timing(crtc, adjusted_mode);
	if (!IS_AVIVO_VARIANT && (radeon_crtc->crtc_id == 0))
	    atombios_set_crtc_dtd_timing(crtc, adjusted_mode);
    }

    if (IS_DCE4_VARIANT)
	evergreen_set_base_format(crtc, mode, adjusted_mode, x, y);
    else if (IS_AVIVO_VARIANT)
	avivo_set_base_format(crtc, mode, adjusted_mode, x, y);
    else
	legacy_set_base_format(crtc, mode, adjusted_mode, x, y);

    if (info->DispPriority)
	RADEONInitDispBandwidth(pScrn);

    radeon_crtc->initialized = TRUE;

    if (tilingChanged) {
	/* need to redraw front buffer, I guess this can be considered a hack ? */
	/* if this is called during ScreenInit() we don't have pScrn->pScreen yet */
	if (pScrn->pScreen)
	    xf86EnableDisableFBAccess(XF86_ENABLEDISABLEFB_ARG(pScrn), FALSE);
	RADEONChangeSurfaces(pScrn);
	if (pScrn->pScreen)
	    xf86EnableDisableFBAccess(XF86_ENABLEDISABLEFB_ARG(pScrn), TRUE);
	/* xf86SetRootClip would do, but can't access that here */
    }

}

/* Calculate display buffer watermark to prevent buffer underflow */
void
RADEONInitDispBandwidthAVIVO(ScrnInfoPtr pScrn,
			      DisplayModePtr mode1, int pixel_bytes1,
			      DisplayModePtr mode2, int pixel_bytes2)
{
    RADEONInfoPtr info = RADEONPTR(pScrn);
    RADEONEntPtr pRADEONEnt   = RADEONEntPriv(pScrn);
    unsigned char *RADEONMMIO = info->MMIO;

    uint32_t dc_lb_memory_split;
    float available_bandwidth = 0;
    float read_delay_latency = 1000;
    int i;
    Bool sideport = FALSE;

    /*
     * Set display0/1 priority up in the memory controller for
     * modes if the user specifies HIGH for displaypriority
     * option.
     */
    if (info->DispPriority == 2) {
	uint32_t mc_init_misc_lat_timer = 0;
	if (info->ChipFamily == CHIP_FAMILY_RV515)
	    mc_init_misc_lat_timer = INMC(pScrn, RV515_MC_INIT_MISC_LAT_TIMER);
	else if ((info->ChipFamily == CHIP_FAMILY_RS690) ||
		 (info->ChipFamily == CHIP_FAMILY_RS740))
	    mc_init_misc_lat_timer = INMC(pScrn, RS690_MC_INIT_MISC_LAT_TIMER);

	mc_init_misc_lat_timer &= ~(R300_MC_DISP1R_INIT_LAT_MASK << R300_MC_DISP1R_INIT_LAT_SHIFT);
	mc_init_misc_lat_timer &= ~(R300_MC_DISP0R_INIT_LAT_MASK << R300_MC_DISP0R_INIT_LAT_SHIFT);

	if (pRADEONEnt->pCrtc[1]->enabled)
	    mc_init_misc_lat_timer |= (1 << R300_MC_DISP1R_INIT_LAT_SHIFT); /* display 1 */
	if (pRADEONEnt->pCrtc[0]->enabled)
	    mc_init_misc_lat_timer |= (1 << R300_MC_DISP0R_INIT_LAT_SHIFT); /* display 0 */

	if (info->ChipFamily == CHIP_FAMILY_RV515)
	    OUTMC(pScrn, RV515_MC_INIT_MISC_LAT_TIMER, mc_init_misc_lat_timer);
	else if ((info->ChipFamily == CHIP_FAMILY_RS690) ||
		 (info->ChipFamily == CHIP_FAMILY_RS740))
	    OUTMC(pScrn, RS690_MC_INIT_MISC_LAT_TIMER, mc_init_misc_lat_timer);
    }

    /*
     * Line Buffer Setup
     * There is a single line buffer shared by both display controllers.
     * DC_LB_MEMORY_SPLIT controls how that line buffer is shared between the display
     * controllers.  The paritioning can either be done manually or via one of four
     * preset allocations specified in bits 1:0:
     * 0 - line buffer is divided in half and shared between each display controller
     * 1 - D1 gets 3/4 of the line buffer, D2 gets 1/4
     * 2 - D1 gets the whole buffer
     * 3 - D1 gets 1/4 of the line buffer, D2 gets 3/4
     * Setting bit 2 of DC_LB_MEMORY_SPLIT controls switches to manual allocation mode.
     * In manual allocation mode, D1 always starts at 0, D1 end/2 is specified in bits
     * 14:4; D2 allocation follows D1.
     */

    dc_lb_memory_split = INREG(AVIVO_DC_LB_MEMORY_SPLIT) & ~AVIVO_DC_LB_MEMORY_SPLIT_MASK;
    dc_lb_memory_split &= ~AVIVO_DC_LB_MEMORY_SPLIT_SHIFT_MODE;
    /* auto */
    if (mode1 && mode2) {
	if (mode1->HDisplay > mode2->HDisplay) {
	    if (mode1->HDisplay > 2560)
		dc_lb_memory_split |= AVIVO_DC_LB_MEMORY_SPLIT_D1_3Q_D2_1Q;
	    else
		dc_lb_memory_split |= AVIVO_DC_LB_MEMORY_SPLIT_D1HALF_D2HALF;
	} else if (mode2->HDisplay > mode1->HDisplay) {
	    if (mode2->HDisplay > 2560)
		dc_lb_memory_split |= AVIVO_DC_LB_MEMORY_SPLIT_D1_1Q_D2_3Q;
	    else
		dc_lb_memory_split |= AVIVO_DC_LB_MEMORY_SPLIT_D1HALF_D2HALF;
	} else
	    dc_lb_memory_split |= AVIVO_DC_LB_MEMORY_SPLIT_D1HALF_D2HALF;
    } else if (mode1) {
	dc_lb_memory_split |= AVIVO_DC_LB_MEMORY_SPLIT_D1_ONLY;
    } else if (mode2) {
	dc_lb_memory_split |= AVIVO_DC_LB_MEMORY_SPLIT_D1_1Q_D2_3Q;
    }
    OUTREG(AVIVO_DC_LB_MEMORY_SPLIT, dc_lb_memory_split);
#if 0
    /* manual */
    dc_lb_memory_split |= AVIVO_DC_LB_MEMORY_SPLIT_SHIFT_MODE;
    dc_lb_memory_split &= ~(AVIVO_DC_LB_DISP1_END_ADR_MASK << AVIVO_DC_LB_DISP1_END_ADR_SHIFT);
    if (mode1) {
	dc_lb_memory_split |= ((((mode1->HDisplay / 2) + 64 /*???*/) & AVIVO_DC_LB_DISP1_END_ADR_MASK)
			       << AVIVO_DC_LB_DISP1_END_ADR_SHIFT);
    } else if (mode2) {
	dc_lb_memory_split |= (0 << AVIVO_DC_LB_DISP1_END_ADR_SHIFT);
    }
    OUTREG(AVIVO_DC_LB_MEMORY_SPLIT, dc_lb_memory_split);
#endif

    /* fixme
     * Still need to implement the actual watermark calculation
     * for rs600.  This just allows us to force high display
     * priority.
     */
    if (info->ChipFamily == CHIP_FAMILY_RS600) {
	if (info->DispPriority == 2) {
	    uint32_t priority_cnt;

	    if (mode1) {
		priority_cnt = INREG(AVIVO_D1MODE_PRIORITY_A_CNT);
		priority_cnt |= AVIVO_DxMODE_PRIORITY_ALWAYS_ON;
		OUTREG(AVIVO_D1MODE_PRIORITY_A_CNT, priority_cnt);

		priority_cnt = INREG(AVIVO_D1MODE_PRIORITY_B_CNT);
		priority_cnt |= AVIVO_DxMODE_PRIORITY_ALWAYS_ON;
		OUTREG(AVIVO_D1MODE_PRIORITY_B_CNT, priority_cnt);
	    }

	    if (mode2) {
		priority_cnt = INREG(AVIVO_D2MODE_PRIORITY_A_CNT);
		priority_cnt |= AVIVO_DxMODE_PRIORITY_ALWAYS_ON;
		OUTREG(AVIVO_D2MODE_PRIORITY_A_CNT, priority_cnt);

		priority_cnt = INREG(AVIVO_D2MODE_PRIORITY_B_CNT);
		priority_cnt |= AVIVO_DxMODE_PRIORITY_ALWAYS_ON;
		OUTREG(AVIVO_D2MODE_PRIORITY_B_CNT, priority_cnt);
	    }
	}
	return;
    }

    /* IGP bandwidth - get from integrated systems table
     * SYSTEM_MEMORY_BANDWIDTH (Mbyte/s) = SYSTEM_MEMORY_CLOCK (MHz) * (1+DDR) * 8 * EFF * Num of channels
     * SIDEPORT_MEMORY_BANDWIDTH = SIDEPORT_MEMORY_CLOCK * 2(byte) * 2(DDR) * 0.7(Eff)
     * CORE_CLOCK_BANDWIDTH (Mbyte/s) = SCLK (MHz) * 16 / Dynamic Engine clock Divider
     * HT_LINK_BANDWIDTH = HT_LINK_CLOCK * 2 * HT_LINK_WIDTH/8 * HT_LINK_EFF
     * system read delay
     * READ_DLY_MAX_LATENCY: 5000 ns
     * sideport read delay
     * READ_DLY_MAX_LATENCY: 370 * MCLK + 800 ns
     * MCLK is the sideport memory clock period in ns (MCLK = 1000 / MCLKfreq MHz)
     */

    if (info->IsIGP) {
	float core_clock_bandwidth = ((float)info->pm.mode[info->pm.current_mode].sclk / 100) * 16 / 1;

	if (sideport) {
	    float sideport_memory_bandwidth = (info->igp_sideport_mclk / 2) * 2 * 2 * 0.7;
	    float mclk = 1000 / info->igp_sideport_mclk;
	    read_delay_latency = 370 * mclk * 800;
	    available_bandwidth = MIN(sideport_memory_bandwidth, core_clock_bandwidth);
	} else {
	    float system_memory_bandwidth = (info->igp_system_mclk / 2) * (1 + 1) * 8 * 0.5 * 1;
	    float ht_link_bandwidth = info->igp_ht_link_clk * 2 * (info->igp_ht_link_width / 8) * 0.8;
	    read_delay_latency = 5000;
	    available_bandwidth = MIN(system_memory_bandwidth, MIN(ht_link_bandwidth, core_clock_bandwidth));
	}
    }

    /* calculate for each display */
    for (i = 0; i < 2; i++) {
	DisplayModePtr current = NULL;
	//RADEONCrtcPrivatePtr radeon_crtc = pRADEONEnt->Controller[i];
	float pclk, sclk, sclkfreq = 0;
	float consumption_time, consumption_rate;
	int num_line_pair, request_fifo_depth, lb_request_fifo_depth;
	int max_req;
	uint32_t lb_max_req_outstanding, priority_cnt;
	float line_time, active_time, chunk_time;
	float worst_case_latency, tolerable_latency;
	float fill_rate;
	int priority_mark_max, priority_mark, priority_mark2;
	int width, estimated_width;
	/* FIXME: handle the scalers better */
	Bool d1_scale_en = pRADEONEnt->Controller[0]->scaler_enabled;
	Bool d2_scale_en = pRADEONEnt->Controller[1]->scaler_enabled;
	float vtaps1 = 2; /* XXX */
	float vsc1 = pRADEONEnt->Controller[0]->vsc;
	float hsc1 = pRADEONEnt->Controller[0]->hsc;
	float vtaps2 = 2; /* XXX */
	float vsc2 = pRADEONEnt->Controller[1]->vsc;
	float hsc2 = pRADEONEnt->Controller[1]->hsc;

	if (i == 0)
	    current = mode1;
	else
	    current = mode2;

	if (current == NULL)
	    continue;

	/* Determine consumption rate
	   pclk = pixel clock period(ns)
	   vtaps = number of vertical taps,
	   vsc = vertical scaling ratio, defined as source/destination
	   hsc = horizontal scaling ration, defined as source/destination
	*/

	pclk = 1000 / ((float)current->Clock / 1000);

	if (i == 0) {
	    if (d1_scale_en)
		consumption_time = pclk / ((MAX(vtaps1, vsc1) * hsc1) / vtaps1);
	    else
		consumption_time = pclk;
	} else {
	    if (d2_scale_en)
		consumption_time = pclk / ((MAX(vtaps2, vsc2) * hsc2) / vtaps2);
	    else
		consumption_time = pclk;
	}

	consumption_rate = 1 / consumption_time;

	/* Determine request line buffer fifo depth
	   NumLinePair = Number of line pairs to request(1 = 2 lines, 2 = 4 lines)
	   LBRequestFifoDepth = Number of chunk requests the LB can put into the request FIFO for a display
	   width = viewport width in pixels
	*/
	if (i == 0) {
	    if (vsc1 > 2)
		num_line_pair = 2;
	    else
		num_line_pair = 1;
	} else {
	    if (vsc2 > 2)
		num_line_pair = 2;
	    else
		num_line_pair = 1;
	}

	width = current->CrtcHDisplay;
	request_fifo_depth = ceil(width/256) * num_line_pair;
	if (request_fifo_depth < 4)
	    lb_request_fifo_depth = 4;
	else
	    lb_request_fifo_depth = request_fifo_depth;

	if (info->IsIGP) {
	    if ((info->ChipFamily == CHIP_FAMILY_RS690) ||
		(info->ChipFamily == CHIP_FAMILY_RS740))
		OUTREG(RS690_DCP_CONTROL, 0);
	    else if ((info->ChipFamily == CHIP_FAMILY_RS780) ||
		     (info->ChipFamily == CHIP_FAMILY_RS880))
		OUTREG(RS690_DCP_CONTROL, 2);
	    max_req = lb_request_fifo_depth - 1;
	} else
	    max_req = lb_request_fifo_depth;

	/*ErrorF("max_req %d: 0x%x\n", i, max_req);*/

	lb_max_req_outstanding = INREG(AVIVO_LB_MAX_REQ_OUTSTANDING);
	if (i == 0) {
	    lb_max_req_outstanding &= ~(AVIVO_LB_D1_MAX_REQ_OUTSTANDING_MASK << AVIVO_LB_D1_MAX_REQ_OUTSTANDING_SHIFT);
	    lb_max_req_outstanding |= (max_req & AVIVO_LB_D1_MAX_REQ_OUTSTANDING_MASK) << AVIVO_LB_D1_MAX_REQ_OUTSTANDING_SHIFT;
	} else {
	    lb_max_req_outstanding &= ~(AVIVO_LB_D2_MAX_REQ_OUTSTANDING_MASK << AVIVO_LB_D2_MAX_REQ_OUTSTANDING_SHIFT);
	    lb_max_req_outstanding |= (max_req & AVIVO_LB_D2_MAX_REQ_OUTSTANDING_MASK) << AVIVO_LB_D2_MAX_REQ_OUTSTANDING_SHIFT;
	}
	OUTREG(AVIVO_LB_MAX_REQ_OUTSTANDING, lb_max_req_outstanding);

	/* Determine line time
	   LineTime = total time for one line of displayhtotal = total number of horizontal pixels
	   pclk = pixel clock period(ns)
	*/
	line_time = current->CrtcHTotal * pclk;

	/* Determine active time
	   ActiveTime = time of active region of display within one line,
	   hactive = total number of horizontal active pixels
	   htotal = total number of horizontal pixels
	*/
	active_time = line_time * current->CrtcHDisplay / current->CrtcHTotal;

	/* Determine chunk time
	   ChunkTime = the time it takes the DCP to send one chunk of data
	   to the LB which consists of pipeline delay and inter chunk gap
	   sclk = system clock(ns)
	*/
	if (info->IsIGP) {
	    sclk = 1000 / (available_bandwidth / 16);
	    /* Sclkfreq = sclk in MHz = 1000/sclk (because sclk is in ns). */
	    sclkfreq = 1000 / sclk;
	    chunk_time = sclk * 256 * 1.3;
	} else {
	    sclk = 1000 / ((float)info->pm.mode[info->pm.current_mode].sclk / 100);
	    chunk_time = sclk * 600;
	}

	/* Determine the worst case latency
	   NumLinePair = Number of line pairs to request(1 = 2 lines, 2 = 4 lines)
	   WorstCaseLatency = The worst case time from urgent to when the MC starts
	   to return data
	   READ_DELAY_IDLE_MAX = constant of 1us
	   ChunkTime = the time it takes the DCP to send one chunk of data to the LB
	   which consists of pipeline delay and
	   inter chunk gap
	*/
	if (info->IsIGP) {
	    if (num_line_pair > 1)
		worst_case_latency = read_delay_latency + 3 * chunk_time;
	    else
		worst_case_latency = read_delay_latency + 2 * chunk_time;
	} else {
	    if (num_line_pair > 1)
		worst_case_latency = read_delay_latency + 3 * chunk_time;
	    else
		worst_case_latency = read_delay_latency + chunk_time;
	}

	/* Determine the tolerable latency
	   TolerableLatency = Any given request has only 1 line time for the data to be returned
	   LBRequestFifoDepth = Number of chunk requests the LB can put into the request FIFO for a display
	   LineTime = total time for one line of display
	   ChunkTime = the time it takes the DCP to send one chunk of data to the LB which consists of
	   pipeline delay and inter chunk gap
	*/
	if ((2 + lb_request_fifo_depth) >= request_fifo_depth)
	    tolerable_latency = line_time;
	else
	    tolerable_latency = line_time - (request_fifo_depth - lb_request_fifo_depth - 2) * chunk_time;

	if (mode1 && mode2) {
	    int d1bpp, d2bpp;
	    int d1_graph_enable = 1;
	    int d2_graph_enable = 1;
	    int d1_ovl_enable = 0;
	    int d2_ovl_enable = 0;
	    int d1grph_depth, d2grph_depth;
	    int d1ovl_depth = 0;
	    int d2ovl_depth = 0;
	    int d1_num_line_pair, d2_num_line_pair;
	    float d1_fill_rate_coeff, d2_fill_rate_coeff;

	    switch (pixel_bytes1) {
	    case 2:
		d1grph_depth = 1;
		break;
	    case 4:
		d1grph_depth = 2;
		break;
	    default:
		d1grph_depth = 0;
		break;
	    }

	    switch (pixel_bytes2) {
	    case 2:
		d2grph_depth = 1;
		break;
	    case 4:
		d2grph_depth = 2;
		break;
	    default:
		d2grph_depth = 0;
		break;
	    }

	    /* If both displays are active, determine line buffer fill rate */
	    if (d1_scale_en && (vsc1 > 2))
		d1_num_line_pair = 2;
	    else
		d1_num_line_pair = 1;

	    if (d2_scale_en && (vsc2 > 2))
		d2_num_line_pair = 2;
	    else
		d2_num_line_pair = 1;

	    if (info->IsIGP) {
		d1bpp = (d1_graph_enable * pow(2, d1grph_depth) * 8) + (d1_ovl_enable * pow(2, d1ovl_depth) * 8);
		d2bpp = (d2_graph_enable * pow(2, d2grph_depth) * 8) + (d2_ovl_enable * pow(2, d2ovl_depth) * 8);

		if (d1bpp > 64)
		    d1_fill_rate_coeff = d1bpp * d1_num_line_pair;
		else
		    d1_fill_rate_coeff = d1_num_line_pair;

		if (d2bpp > 64)
		    d2_fill_rate_coeff = d2bpp * d2_num_line_pair;
		else
		    d2_fill_rate_coeff = d2_num_line_pair;

		fill_rate = sclkfreq / (d1_fill_rate_coeff + d2_fill_rate_coeff);
	    } else {
		d1bpp = (d1grph_depth + d1ovl_depth) * 16;
		d2bpp = (d2grph_depth + d2ovl_depth) * 16;

		if (d1bpp > 64)
		    d1_fill_rate_coeff = d1bpp / d1_num_line_pair;
		else
		    d1_fill_rate_coeff = d1_num_line_pair;

		if (d2bpp > 64)
		    d2_fill_rate_coeff = d2bpp / d2_num_line_pair;
		else
		    d2_fill_rate_coeff = d2_num_line_pair;

		fill_rate = sclk / (d1_fill_rate_coeff + d2_fill_rate_coeff);

		/* Convert line buffer fill rate from period to frequency */
		fill_rate = 1 / fill_rate;
	    }
	} else {
	    int dxbpp;
	    int dx_grph_enable = 1;
	    int dx_ovl_enable = 0;
	    int dxgrph_depth;
	    int dxovl_depth = 0;
	    int cpp;

	    if (i == 0)
		cpp = pixel_bytes1;
	    else
		cpp = pixel_bytes2;

	    switch (cpp) {
	    case 2:
		dxgrph_depth = 1;
		break;
	    case 4:
		dxgrph_depth = 2;
		break;
	    default:
		dxgrph_depth = 0;
		break;
	    }

	    /* If only one display active, the line buffer fill rate becomes */
	    if (info->IsIGP) {
		dxbpp = (dx_grph_enable * pow(2, dxgrph_depth) * 8) + (dx_ovl_enable * pow(2, dxovl_depth) * 8);
		if (dxbpp > 64)
		    fill_rate = sclkfreq / dxbpp / num_line_pair;
		else
		    fill_rate = sclkfreq / num_line_pair;
	    } else {
		dxbpp = (dxgrph_depth + dxovl_depth) * 16;

		if (dxbpp > 64)
		    fill_rate = sclk / dxbpp / num_line_pair;
		else
		    fill_rate = sclk / num_line_pair;

		/* Convert line buffer fill rate from period to frequency */
		fill_rate = 1 / fill_rate;
	    }
	}

	/* Determine the maximum priority mark
	   width = viewport width in pixels
	*/
	priority_mark_max = ceil(width/16);

	/* Determine estimated width */
	estimated_width = (tolerable_latency - worst_case_latency) / consumption_time;

	/* Determine priority mark based on active time */
	if (info->IsIGP) {
	    if (estimated_width > width)
		priority_mark = 10;
	    else
		priority_mark = priority_mark_max - ceil(estimated_width / 16);
	} else {
	    if (estimated_width > width)
		priority_mark = priority_mark_max;
	    else
		priority_mark = priority_mark_max - ceil(estimated_width / 16);
	}

	/* Determine priority mark 2 based on worst case latency,
	   consumption rate, fill rate and active time
	*/
	if (info->IsIGP) {
	    if (consumption_rate > fill_rate)
		priority_mark2 = ceil((worst_case_latency * consumption_rate + (consumption_rate - fill_rate) * active_time) / 1000 / 16);
	    else
		priority_mark2 = ceil(worst_case_latency * consumption_rate / 1000 / 16);
	} else {
	    if (consumption_rate > fill_rate)
		priority_mark2 = ceil(worst_case_latency * consumption_rate + (consumption_rate - fill_rate) * active_time / 16);
	    else
		priority_mark2 = ceil(worst_case_latency * consumption_rate / 16);
	}

	/* Determine final priority mark and clamp if necessary */
	priority_mark = max(priority_mark, priority_mark2);
	if (priority_mark < 0)
	    priority_mark = 0;
	else if (priority_mark > priority_mark_max)
	    priority_mark = priority_mark_max;

	priority_cnt = priority_mark & AVIVO_DxMODE_PRIORITY_MARK_MASK;

	if (info->DispPriority == 2)
	    priority_cnt |= AVIVO_DxMODE_PRIORITY_ALWAYS_ON;

	/*ErrorF("priority_mark %d: 0x%x\n", i, priority_mark);*/

	/* Determine which display to program priority mark for */
	/* FIXME: program DxMODE_PRIORITY_B_CNT for slower sclk */
	if (i == 0) {
	    OUTREG(AVIVO_D1MODE_PRIORITY_A_CNT, priority_cnt);
	    OUTREG(AVIVO_D1MODE_PRIORITY_B_CNT, priority_cnt);
	} else {
	    OUTREG(AVIVO_D2MODE_PRIORITY_A_CNT, priority_cnt);
	    OUTREG(AVIVO_D2MODE_PRIORITY_B_CNT, priority_cnt);
	}
    }

}
@


1.7
log
@Update to xf86-video-ati 6.14.6. Tested by mpi@@, brad, eric@@, ajacoutot@@.
@
text
@@


1.6
log
@Re-update xf86-video-ati to 6.14.3.

Because of ati.c revision 1.5, it will not be selected by
autoconfiguration code, so people who want to run this version of the
driver on their radeon cards need an explicit "Device" section in
xorg.conf.
@
text
@d89 1
a89 1
    if (RHDAtomBiosFunc(atomBIOS->scrnIndex, atomBIOS, ATOMBIOS_EXEC, &data) == ATOM_SUCCESS) {
d112 1
a112 1
    if (RHDAtomBiosFunc(atomBIOS->scrnIndex, atomBIOS, ATOMBIOS_EXEC, &data) == ATOM_SUCCESS) {
d135 1
a135 1
    if (RHDAtomBiosFunc(atomBIOS->scrnIndex, atomBIOS, ATOMBIOS_EXEC, &data) == ATOM_SUCCESS) {
d159 1
a159 1
    if (RHDAtomBiosFunc(atomBIOS->scrnIndex, atomBIOS, ATOMBIOS_EXEC, &data) == ATOM_SUCCESS) {
d233 1
a233 1
    if (RHDAtomBiosFunc(info->atomBIOS->scrnIndex, info->atomBIOS, ATOMBIOS_EXEC, &data) == ATOM_SUCCESS) {
d284 1
a284 1
    if (RHDAtomBiosFunc(info->atomBIOS->scrnIndex, info->atomBIOS, ATOMBIOS_EXEC, &data) == ATOM_SUCCESS) {
d453 1
a453 1
		if (RHDAtomBiosFunc(info->atomBIOS->scrnIndex, info->atomBIOS, ATOMBIOS_EXEC, &data) == ATOM_SUCCESS) {
d471 1
a471 1
		if (RHDAtomBiosFunc(info->atomBIOS->scrnIndex, info->atomBIOS, ATOMBIOS_EXEC, &data) == ATOM_SUCCESS) {
d570 1
a570 1
    if (RHDAtomBiosFunc(info->atomBIOS->scrnIndex, info->atomBIOS, ATOMBIOS_EXEC, &data) == ATOM_SUCCESS) {
d712 1
a712 1
    if (RHDAtomBiosFunc(info->atomBIOS->scrnIndex, info->atomBIOS, ATOMBIOS_EXEC, &data) == ATOM_SUCCESS) {
d1028 1
a1028 1
	    xf86EnableDisableFBAccess(pScrn->scrnIndex, FALSE);
d1031 1
a1031 1
	    xf86EnableDisableFBAccess(pScrn->scrnIndex, TRUE);
@


1.5
log
@Revert the update to xf86-video-ati 6.14.3. Requested by espie@@
who experiemnts regressions with this driver.
@
text
@d36 1
a36 1
#ifdef HAVE_X11_EXTENSIONS_DPMSCONST_H
d43 1
d175 1
a175 2
    case DPMSModeStandby:
    case DPMSModeSuspend:
a177 1
	atombios_enable_crtc(info->atomBIOS, radeon_crtc->crtc_id, 1);
d180 2
a183 1
	atombios_enable_crtc(info->atomBIOS, radeon_crtc->crtc_id, 0);
d186 1
d192 1
a192 1
atombios_set_crtc_timing(atomBiosHandlePtr atomBIOS, SET_CRTC_TIMING_PARAMETERS_PS_ALLOCATION *crtc_param)
d194 2
d198 21
a218 1
    SET_CRTC_TIMING_PARAMETERS_PS_ALLOCATION conv_param;
d220 8
a227 15
    conv_param.usH_Total		= cpu_to_le16(crtc_param->usH_Total);
    conv_param.usH_Disp			= cpu_to_le16(crtc_param->usH_Disp);
    conv_param.usH_SyncStart		= cpu_to_le16(crtc_param->usH_SyncStart);
    conv_param.usH_SyncWidth		= cpu_to_le16(crtc_param->usH_SyncWidth);
    conv_param.usV_Total		= cpu_to_le16(crtc_param->usV_Total);
    conv_param.usV_Disp			= cpu_to_le16(crtc_param->usV_Disp);
    conv_param.usV_SyncStart		= cpu_to_le16(crtc_param->usV_SyncStart);
    conv_param.usV_SyncWidth		= cpu_to_le16(crtc_param->usV_SyncWidth);
    conv_param.susModeMiscInfo.usAccess = cpu_to_le16(crtc_param->susModeMiscInfo.usAccess);
    conv_param.ucCRTC			= crtc_param->ucCRTC;
    conv_param.ucOverscanRight		= crtc_param->ucOverscanRight;
    conv_param.ucOverscanLeft		= crtc_param->ucOverscanLeft;
    conv_param.ucOverscanBottom		= crtc_param->ucOverscanBottom;
    conv_param.ucOverscanTop		= crtc_param->ucOverscanTop;
    conv_param.ucReserved		= crtc_param->ucReserved;
d231 1
a231 1
    data.exec.pspace = &conv_param;
d233 1
a233 1
    if (RHDAtomBiosFunc(atomBIOS->scrnIndex, atomBIOS, ATOMBIOS_EXEC, &data) == ATOM_SUCCESS) {
d243 1
a243 1
atombios_set_crtc_dtd_timing(atomBiosHandlePtr atomBIOS, SET_CRTC_USING_DTD_TIMING_PARAMETERS *crtc_param)
d245 2
d249 21
a269 1
    SET_CRTC_USING_DTD_TIMING_PARAMETERS conv_param;
d271 8
a278 10
    conv_param.usH_Size        = cpu_to_le16(crtc_param->usH_Size);
    conv_param.usH_Blanking_Time= cpu_to_le16(crtc_param->usH_Blanking_Time);
    conv_param.usV_Size        = cpu_to_le16(crtc_param->usV_Size);
    conv_param.usV_Blanking_Time= cpu_to_le16(crtc_param->usV_Blanking_Time);
    conv_param.usH_SyncOffset= cpu_to_le16(crtc_param->usH_SyncOffset);
    conv_param.usH_SyncWidth= cpu_to_le16(crtc_param->usH_SyncWidth);
    conv_param.usV_SyncOffset= cpu_to_le16(crtc_param->usV_SyncOffset);
    conv_param.usV_SyncWidth= cpu_to_le16(crtc_param->usV_SyncWidth);
    conv_param.susModeMiscInfo.usAccess = cpu_to_le16(crtc_param->susModeMiscInfo.usAccess);
    conv_param.ucCRTC= crtc_param->ucCRTC;
d282 1
a282 1
    data.exec.pspace = &conv_param;
d284 1
a284 1
    if (RHDAtomBiosFunc(atomBIOS->scrnIndex, atomBIOS, ATOMBIOS_EXEC, &data) == ATOM_SUCCESS) {
d293 63
a355 2
void
atombios_crtc_set_pll(xf86CrtcPtr crtc, DisplayModePtr mode)
d358 2
a359 1
    RADEONInfoPtr  info = RADEONPTR(crtc->scrn);
d361 1
a361 9
    unsigned char *RADEONMMIO = info->MMIO;
    int index = GetIndexIntoMasterTable(COMMAND, SetPixelClock);
    uint32_t sclock = mode->Clock;
    uint32_t ref_div = 0, fb_div = 0, post_div = 0;
    int major, minor, i;
    SET_PIXEL_CLOCK_PS_ALLOCATION spc_param;
    PIXEL_CLOCK_PARAMETERS_V2 *spc2_ptr;
    PIXEL_CLOCK_PARAMETERS_V3 *spc3_ptr;
    xf86OutputPtr output;
d364 1
d366 1
a366 1
    uint32_t temp;
d368 11
a378 3
    void *ptr;
    AtomBiosArgRec data;
    unsigned char *space;
a379 1
    memset(&spc_param, 0, sizeof(spc_param));
d381 6
a386 1
	if (IS_DCE3_VARIANT && mode->Clock > 200000) /* range limits??? */
a389 9

	/* disable spread spectrum clocking for now -- thanks Hedy Lamarr */
	if (radeon_crtc->crtc_id == 0) {
	    temp = INREG(AVIVO_P1PLL_INT_SS_CNTL);
	    OUTREG(AVIVO_P1PLL_INT_SS_CNTL, temp & ~1);
	} else {
	    temp = INREG(AVIVO_P2PLL_INT_SS_CNTL);
	    OUTREG(AVIVO_P2PLL_INT_SS_CNTL, temp & ~1);
	}
d393 23
a415 5
	for (i = 0; i < xf86_config->num_output; i++) {
	    xf86OutputPtr output = xf86_config->output[i];
	    RADEONOutputPrivatePtr radeon_output = output->driver_private;

	    if (output->crtc == crtc) {
d422 2
d425 9
d435 59
a493 4
	if (mode->Clock > 200000) /* range limits??? */
	    pll_flags |= RADEON_PLL_PREFER_HIGH_FB_DIV;
	else
	    pll_flags |= RADEON_PLL_PREFER_LOW_REF_DIV;
d495 12
d508 13
a520 2
    RADEONComputePLL(&info->pll, mode->Clock, &temp, &fb_div, &ref_div, &post_div, pll_flags);
    sclock = temp;
d522 1
a522 6
    xf86DrvMsg(crtc->scrn->scrnIndex, X_INFO,
	       "crtc(%d) Clock: mode %d, PLL %lu\n",
	       radeon_crtc->crtc_id, mode->Clock, (long unsigned int)sclock * 10);
    xf86DrvMsg(crtc->scrn->scrnIndex, X_INFO,
	       "crtc(%d) PLL  : refdiv %u, fbdiv 0x%X(%u), pdiv %u\n",
	       radeon_crtc->crtc_id, (unsigned int)ref_div, (unsigned int)fb_div, (unsigned int)fb_div, (unsigned int)post_div);
a523 1
    /* Can't really do cloning easily on DCE3 cards */
d543 1
d550 5
a554 24
	case 1:
	case 2:
	    spc2_ptr = (PIXEL_CLOCK_PARAMETERS_V2*)&spc_param.sPCLKInput;
	    spc2_ptr->usPixelClock = cpu_to_le16(sclock);
	    spc2_ptr->usRefDiv = cpu_to_le16(ref_div);
	    spc2_ptr->usFbDiv = cpu_to_le16(fb_div);
	    spc2_ptr->ucPostDiv = post_div;
	    spc2_ptr->ucPpll = radeon_crtc->crtc_id ? ATOM_PPLL2 : ATOM_PPLL1;
	    spc2_ptr->ucCRTC = radeon_crtc->crtc_id;
	    spc2_ptr->ucRefDivSrc = 1;
	    ptr = &spc_param;
	    break;
	case 3:
	    spc3_ptr = (PIXEL_CLOCK_PARAMETERS_V3*)&spc_param.sPCLKInput;
	    spc3_ptr->usPixelClock = cpu_to_le16(sclock);
	    spc3_ptr->usRefDiv = cpu_to_le16(ref_div);
	    spc3_ptr->usFbDiv = cpu_to_le16(fb_div);
	    spc3_ptr->ucPostDiv = post_div;
	    spc3_ptr->ucPpll = radeon_crtc->crtc_id ? ATOM_PPLL2 : ATOM_PPLL1;
	    spc3_ptr->ucMiscInfo = (radeon_crtc->crtc_id << 2);
	    spc3_ptr->ucTransmitterId = radeon_encoder->encoder_id;
	    spc3_ptr->ucEncoderMode = atombios_get_encoder_mode(output);

	    ptr = &spc_param;
d566 1
a566 1
    data.exec.index = GetIndexIntoMasterTable(COMMAND, SetPixelClock);
d568 1
a568 1
    data.exec.pspace = ptr;
d571 1
a571 1
	ErrorF("Set CRTC %d PLL success\n", radeon_crtc->crtc_id);
d575 1
a575 1
    ErrorF("Set CRTC %d PLL failed\n", radeon_crtc->crtc_id);
d579 2
a580 5
void
atombios_crtc_mode_set(xf86CrtcPtr crtc,
		       DisplayModePtr mode,
		       DisplayModePtr adjusted_mode,
		       int x, int y)
d582 1
a583 1
    RADEONCrtcPrivatePtr radeon_crtc = crtc->driver_private;
a584 1
    xf86CrtcConfigPtr   xf86_config = XF86_CRTC_CONFIG_PTR(pScrn);
d586 15
a600 8
    unsigned long fb_location = crtc->scrn->fbOffset + info->fbLocation;
    int need_tv_timings = 0;
    int i, ret;
    SET_CRTC_TIMING_PARAMETERS_PS_ALLOCATION crtc_timing;
    SET_CRTC_USING_DTD_TIMING_PARAMETERS crtc_dtd_timing;
    Bool tilingChanged = FALSE;
    memset(&crtc_timing, 0, sizeof(crtc_timing));
    memset(&crtc_dtd_timing, 0, sizeof(crtc_dtd_timing));
d602 20
a621 3
    if (info->allowColorTiling) {
        radeon_crtc->can_tile = (adjusted_mode->Flags & (V_DBLSCAN | V_INTERLACE)) ? FALSE : TRUE;
	tilingChanged = RADEONSetTiling(pScrn);
d624 6
a629 14
    for (i = 0; i < xf86_config->num_output; i++) {
	xf86OutputPtr output = xf86_config->output[i];
	RADEONOutputPrivatePtr radeon_output = output->driver_private;
	radeon_tvout_ptr tvout = &radeon_output->tvout;

	if (output->crtc == crtc) {
	    if (radeon_output->MonType == MT_STV || radeon_output->MonType == MT_CTV) {
		if (tvout->tvStd == TV_STD_NTSC ||
		    tvout->tvStd == TV_STD_NTSC_J ||
		    tvout->tvStd == TV_STD_PAL_M)
		    need_tv_timings = 1;
		else
		    need_tv_timings = 2;

a631 1
    }
d633 7
a639 5
    crtc_timing.ucCRTC = radeon_crtc->crtc_id;
    if (need_tv_timings) {
	ret = RADEONATOMGetTVTimings(pScrn, need_tv_timings - 1, &crtc_timing, &adjusted_mode->Clock);
	if (ret == FALSE) {
	    need_tv_timings = 0;
d643 1
a643 5
    if (!need_tv_timings) {
	crtc_timing.usH_Total = adjusted_mode->CrtcHTotal;
	crtc_timing.usH_Disp = adjusted_mode->CrtcHDisplay;
	crtc_timing.usH_SyncStart = adjusted_mode->CrtcHSyncStart;
	crtc_timing.usH_SyncWidth = adjusted_mode->CrtcHSyncEnd - adjusted_mode->CrtcHSyncStart;
d645 3
a647 4
	crtc_timing.usV_Total = adjusted_mode->CrtcVTotal;
	crtc_timing.usV_Disp = adjusted_mode->CrtcVDisplay;
	crtc_timing.usV_SyncStart = adjusted_mode->CrtcVSyncStart;
	crtc_timing.usV_SyncWidth = adjusted_mode->CrtcVSyncEnd - adjusted_mode->CrtcVSyncStart;
d649 7
a655 2
	if (adjusted_mode->Flags & V_NVSYNC)
	    crtc_timing.susModeMiscInfo.usAccess |= ATOM_VSYNC_POLARITY;
d657 2
a658 2
	if (adjusted_mode->Flags & V_NHSYNC)
	    crtc_timing.susModeMiscInfo.usAccess |= ATOM_HSYNC_POLARITY;
d660 47
a706 2
	if (adjusted_mode->Flags & V_CSYNC)
	    crtc_timing.susModeMiscInfo.usAccess |= ATOM_COMPOSITESYNC;
d708 3
a710 2
	if (adjusted_mode->Flags & V_INTERLACE)
	    crtc_timing.susModeMiscInfo.usAccess |= ATOM_INTERLACE;
d712 4
a715 2
	if (adjusted_mode->Flags & V_DBLSCAN)
	    crtc_timing.susModeMiscInfo.usAccess |= ATOM_DOUBLE_CLOCK_MODE;
d717 3
a719 14
	if (!IS_AVIVO_VARIANT && (radeon_crtc->crtc_id == 0)) {
	    crtc_dtd_timing.ucCRTC = radeon_crtc->crtc_id;
	    crtc_dtd_timing.usH_Size = adjusted_mode->CrtcHDisplay;
	    crtc_dtd_timing.usV_Size = adjusted_mode->CrtcVDisplay;
	    crtc_dtd_timing.usH_Blanking_Time = adjusted_mode->CrtcHBlankEnd - adjusted_mode->CrtcHDisplay;
	    crtc_dtd_timing.usV_Blanking_Time = adjusted_mode->CrtcVBlankEnd - adjusted_mode->CrtcVDisplay;
	    crtc_dtd_timing.usH_SyncOffset = adjusted_mode->CrtcHSyncStart - adjusted_mode->CrtcHDisplay;
	    crtc_dtd_timing.usV_SyncOffset = adjusted_mode->CrtcVSyncStart - adjusted_mode->CrtcVDisplay;
	    crtc_dtd_timing.usH_SyncWidth = adjusted_mode->CrtcHSyncEnd - adjusted_mode->CrtcHSyncStart;
	    crtc_dtd_timing.usV_SyncWidth = adjusted_mode->CrtcVSyncEnd - adjusted_mode->CrtcVSyncStart;
	    ErrorF("%d %d %d %d %d %d %d %d\n", crtc_dtd_timing.usH_Size, crtc_dtd_timing.usH_SyncOffset,
		   crtc_dtd_timing.usH_SyncWidth, crtc_dtd_timing.usH_Blanking_Time,
		   crtc_dtd_timing.usV_Size, crtc_dtd_timing.usV_SyncOffset,
		   crtc_dtd_timing.usV_SyncWidth, crtc_dtd_timing.usV_Blanking_Time);
d721 36
a756 2
	    if (adjusted_mode->Flags & V_NVSYNC)
		crtc_dtd_timing.susModeMiscInfo.usAccess |= ATOM_VSYNC_POLARITY;
d758 21
a778 2
	    if (adjusted_mode->Flags & V_NHSYNC)
		crtc_dtd_timing.susModeMiscInfo.usAccess |= ATOM_HSYNC_POLARITY;
d780 7
a786 9
	    if (adjusted_mode->Flags & V_CSYNC)
		crtc_dtd_timing.susModeMiscInfo.usAccess |= ATOM_COMPOSITESYNC;

	    if (adjusted_mode->Flags & V_INTERLACE)
		crtc_dtd_timing.susModeMiscInfo.usAccess |= ATOM_INTERLACE;

	    if (adjusted_mode->Flags & V_DBLSCAN)
		crtc_dtd_timing.susModeMiscInfo.usAccess |= ATOM_DOUBLE_CLOCK_MODE;
	}
a788 2
    ErrorF("Mode %dx%d - %d %d %d\n", adjusted_mode->CrtcHDisplay, adjusted_mode->CrtcVDisplay,
	   adjusted_mode->CrtcHTotal, adjusted_mode->CrtcVTotal, adjusted_mode->Flags);
d790 31
a820 2
    RADEONInitMemMapRegisters(pScrn, info->ModeReg, info);
    RADEONRestoreMemMapRegisters(pScrn, info->ModeReg);
d822 1
a822 4
    atombios_crtc_set_pll(crtc, adjusted_mode);
    atombios_set_crtc_timing(info->atomBIOS, &crtc_timing);
    if (!IS_AVIVO_VARIANT && (radeon_crtc->crtc_id == 0))
	atombios_set_crtc_dtd_timing(info->atomBIOS, &crtc_dtd_timing);
d824 11
a834 2
    if (IS_AVIVO_VARIANT) {
	uint32_t fb_format;
d836 1
a836 1
	uint32_t fb_swap = R600_D1GRPH_SWAP_ENDIAN_NONE;
d839 6
a844 6
	switch (crtc->scrn->bitsPerPixel) {
	case 15:
	    fb_format = AVIVO_D1GRPH_CONTROL_DEPTH_16BPP | AVIVO_D1GRPH_CONTROL_16BPP_ARGB1555;
	    break;
	case 16:
	    fb_format = AVIVO_D1GRPH_CONTROL_DEPTH_16BPP | AVIVO_D1GRPH_CONTROL_16BPP_RGB565;
d846 1
a846 1
	    fb_swap = R600_D1GRPH_SWAP_ENDIAN_16BIT;
d848 4
a851 4
	    break;
	case 24:
	case 32:
	    fb_format = AVIVO_D1GRPH_CONTROL_DEPTH_32BPP | AVIVO_D1GRPH_CONTROL_32BPP_ARGB8888;
d853 1
a853 1
	    fb_swap = R600_D1GRPH_SWAP_ENDIAN_32BIT;
d855 8
a862 4
	    break;
	default:
	    FatalError("Unsupported screen depth: %d\n", xf86GetDepth());
	}
d864 4
a867 3
	if (info->tilingEnabled && (crtc->rotatedData == NULL)) {
	    fb_format |= AVIVO_D1GRPH_MACRO_ADDRESS_MODE;
	}
d869 8
a876 4
	if (radeon_crtc->crtc_id == 0)
	    OUTREG(AVIVO_D1VGA_CONTROL, 0);
	else
	    OUTREG(AVIVO_D2VGA_CONTROL, 0);
d878 7
a884 7
	/* setup fb format and location
	 */
	if (crtc->rotatedData != NULL) {
	    /* x/y offset is already included */
	    x = 0;
	    y = 0;
	    fb_location = fb_location + (char *)crtc->rotatedData - (char *)info->FB;
d886 6
a891 4

	OUTREG(AVIVO_D1GRPH_PRIMARY_SURFACE_ADDRESS + radeon_crtc->crtc_offset, fb_location);
	OUTREG(AVIVO_D1GRPH_SECONDARY_SURFACE_ADDRESS + radeon_crtc->crtc_offset, fb_location);
	OUTREG(AVIVO_D1GRPH_CONTROL + radeon_crtc->crtc_offset, fb_format);
d894 2
a895 2
	if (info->ChipFamily >= CHIP_FAMILY_R600)
	    OUTREG(R600_D1GRPH_SWAP_CONTROL + radeon_crtc->crtc_offset, fb_swap);
d898 23
a920 26
	OUTREG(AVIVO_D1GRPH_SURFACE_OFFSET_X + radeon_crtc->crtc_offset, 0);
	OUTREG(AVIVO_D1GRPH_SURFACE_OFFSET_Y + radeon_crtc->crtc_offset, 0);
	OUTREG(AVIVO_D1GRPH_X_START + radeon_crtc->crtc_offset, 0);
	OUTREG(AVIVO_D1GRPH_Y_START + radeon_crtc->crtc_offset, 0);
	OUTREG(AVIVO_D1GRPH_X_END + radeon_crtc->crtc_offset, info->virtualX);
	OUTREG(AVIVO_D1GRPH_Y_END + radeon_crtc->crtc_offset, info->virtualY);
	OUTREG(AVIVO_D1GRPH_PITCH + radeon_crtc->crtc_offset,
	       crtc->scrn->displayWidth);
	OUTREG(AVIVO_D1GRPH_ENABLE + radeon_crtc->crtc_offset, 1);

	OUTREG(AVIVO_D1MODE_DESKTOP_HEIGHT + radeon_crtc->crtc_offset, mode->VDisplay);
	x &= ~3;
	y &= ~1;
	OUTREG(AVIVO_D1MODE_VIEWPORT_START + radeon_crtc->crtc_offset, (x << 16) | y);
	OUTREG(AVIVO_D1MODE_VIEWPORT_SIZE + radeon_crtc->crtc_offset,
	       (mode->HDisplay << 16) | mode->VDisplay);

	if (adjusted_mode->Flags & V_INTERLACE)
	    OUTREG(AVIVO_D1MODE_DATA_FORMAT + radeon_crtc->crtc_offset,
		   AVIVO_D1MODE_INTERLEAVE_EN);
	else
	    OUTREG(AVIVO_D1MODE_DATA_FORMAT + radeon_crtc->crtc_offset,
		   0);
    } else {
	int format = 0;
	uint32_t crtc_gen_cntl, crtc2_gen_cntl, crtc_pitch;
d922 11
d934 16
a949 17
	RADEONInitCommonRegisters(info->ModeReg, info);
	RADEONInitSurfaceCntl(crtc, info->ModeReg);
	ErrorF("restore common\n");
	RADEONRestoreCommonRegisters(pScrn, info->ModeReg);

	switch (info->CurrentLayout.pixel_code) {
	case 4:  format = 1; break;
	case 8:  format = 2; break;
	case 15: format = 3; break;      /*  555 */
	case 16: format = 4; break;      /*  565 */
	case 24: format = 5; break;      /*  RGB */
	case 32: format = 6; break;      /* xRGB */
	default:
	    xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
		       "Unsupported pixel depth (%d)\n",
		       info->CurrentLayout.bitsPerPixel);
	}
d951 2
a952 2
	crtc_pitch  = (((pScrn->displayWidth * pScrn->bitsPerPixel) +
			((pScrn->bitsPerPixel * 8) -1)) /
d954 1
a954 1
	crtc_pitch |= crtc_pitch << 16;
d956 54
a1009 21
	switch (radeon_crtc->crtc_id) {
	case 0:
	    ErrorF("init crtc1\n");
	    crtc_gen_cntl = INREG(RADEON_CRTC_GEN_CNTL) & 0xfffff0ff;
	    crtc_gen_cntl |= (format << 8);
	    OUTREG(RADEON_CRTC_GEN_CNTL, crtc_gen_cntl);
	    OUTREG(RADEON_CRTC_PITCH, crtc_pitch);
	    RADEONInitCrtcBase(crtc, info->ModeReg, x, y);
	    RADEONRestoreCrtcBase(pScrn, info->ModeReg);
	    break;
	case 1:
	    crtc2_gen_cntl = INREG(RADEON_CRTC2_GEN_CNTL) & 0xfffff0ff;
	    crtc2_gen_cntl |= (format << 8);
	    OUTREG(RADEON_CRTC2_GEN_CNTL, crtc2_gen_cntl);
	    OUTREG(RADEON_CRTC2_PITCH, crtc_pitch);
	    RADEONInitCrtc2Base(crtc, info->ModeReg, x, y);
	    RADEONRestoreCrtc2Base(pScrn, info->ModeReg);
	    OUTREG(RADEON_FP_H2_SYNC_STRT_WID,   INREG(RADEON_CRTC2_H_SYNC_STRT_WID));
	    OUTREG(RADEON_FP_V2_SYNC_STRT_WID,   INREG(RADEON_CRTC2_V_SYNC_STRT_WID));
	    break;
	}
d1012 7
d1048 4
a1051 3
    float mem_bw, peak_disp_bw;
    float min_mem_eff = 0.8; /* XXX: taken from legacy method */
    float pix_clk, pix_clk2; /* in MHz */
d1062 2
a1063 1
	else if (info->ChipFamily == CHIP_FAMILY_RS690)
d1076 2
a1077 1
	else if (info->ChipFamily == CHIP_FAMILY_RS690)
a1080 23
    /* XXX: fix me for AVIVO
     * Determine if there is enough bandwidth for current display mode
     */
    mem_bw = info->mclk * (info->RamWidth / 8) * (info->IsDDR ? 2 : 1);

    pix_clk = 0;
    pix_clk2 = 0;
    peak_disp_bw = 0;
    if (mode1) {
	pix_clk = mode1->Clock/1000.0;
	peak_disp_bw += (pix_clk * pixel_bytes1);
    }
    if (mode2) {
	pix_clk2 = mode2->Clock/1000.0;
	peak_disp_bw += (pix_clk2 * pixel_bytes2);
    }

    if (peak_disp_bw >= mem_bw * min_mem_eff) {
	xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
		   "You may not have enough display bandwidth for current mode\n"
		   "If you have flickering problem, try to lower resolution, refresh rate, or color depth\n");
    }

a1095 1
    /* is auto or manual better ? */
a1097 1
#if 1
d1117 2
a1118 1
#else
d1131 42
a1172 5
    /*
     * Watermark setup
     * TODO...
     * Unforunately, I haven't been able to dig up the avivo watermark programming
     * guide yet. -AGD
d1174 366
@


1.4
log
@Update to xf86-video-ati 6.14.3. Tested by many.
@
text
@d36 1
a36 1
#ifdef HAVE_XEXTPROTO_71
a42 1
#include <math.h>
d174 2
a175 1
	atombios_enable_crtc(info->atomBIOS, radeon_crtc->crtc_id, 1);
d178 1
a180 2
    case DPMSModeStandby:
    case DPMSModeSuspend:
d183 1
a185 1
	atombios_enable_crtc(info->atomBIOS, radeon_crtc->crtc_id, 0);
d191 1
a191 1
atombios_set_crtc_timing(xf86CrtcPtr crtc, DisplayModePtr mode)
a192 2
    RADEONCrtcPrivatePtr radeon_crtc = crtc->driver_private;
    RADEONInfoPtr  info = RADEONPTR(crtc->scrn);
d195 1
a195 21
    uint16_t misc = 0;
    SET_CRTC_TIMING_PARAMETERS_PS_ALLOCATION param;
    memset(&param, 0, sizeof(param));

    param.usH_Total		= cpu_to_le16(mode->CrtcHTotal);
    param.usH_Disp		= cpu_to_le16(mode->CrtcHDisplay);
    param.usH_SyncStart		= cpu_to_le16(mode->CrtcHSyncStart);
    param.usH_SyncWidth		= cpu_to_le16(mode->CrtcHSyncEnd - mode->CrtcHSyncStart);
    param.usV_Total		= cpu_to_le16(mode->CrtcVTotal);
    param.usV_Disp		= cpu_to_le16(mode->CrtcVDisplay);
    param.usV_SyncStart		= cpu_to_le16(mode->CrtcVSyncStart);
    param.usV_SyncWidth		= cpu_to_le16(mode->CrtcVSyncEnd - mode->CrtcVSyncStart);

    if (mode->Flags & V_NVSYNC)
	misc |= ATOM_VSYNC_POLARITY;

    if (mode->Flags & V_NHSYNC)
	misc |= ATOM_HSYNC_POLARITY;

    if (mode->Flags & V_CSYNC)
	misc |= ATOM_COMPOSITESYNC;
d197 15
a211 8
    if (mode->Flags & V_INTERLACE)
	misc |= ATOM_INTERLACE;

    if (mode->Flags & V_DBLSCAN)
	misc |= ATOM_DOUBLE_CLOCK_MODE;

    param.susModeMiscInfo.usAccess      = cpu_to_le16(misc);
    param.ucCRTC			= radeon_crtc->crtc_id;
d215 1
a215 1
    data.exec.pspace = &param;
d217 1
a217 1
    if (RHDAtomBiosFunc(info->atomBIOS->scrnIndex, info->atomBIOS, ATOMBIOS_EXEC, &data) == ATOM_SUCCESS) {
d227 1
a227 1
atombios_set_crtc_dtd_timing(xf86CrtcPtr crtc, DisplayModePtr mode)
a228 2
    RADEONCrtcPrivatePtr radeon_crtc = crtc->driver_private;
    RADEONInfoPtr  info = RADEONPTR(crtc->scrn);
d231 1
a231 21
    uint16_t misc = 0;
    SET_CRTC_USING_DTD_TIMING_PARAMETERS param;
    memset(&param, 0, sizeof(param));

    param.usH_Size          = cpu_to_le16(mode->CrtcHDisplay);
    param.usH_Blanking_Time = cpu_to_le16(mode->CrtcHBlankEnd - mode->CrtcHDisplay);
    param.usV_Size          = cpu_to_le16(mode->CrtcVDisplay);
    param.usV_Blanking_Time = cpu_to_le16(mode->CrtcVBlankEnd - mode->CrtcVDisplay);
    param.usH_SyncOffset    = cpu_to_le16(mode->CrtcHSyncStart - mode->CrtcHDisplay);
    param.usH_SyncWidth     = cpu_to_le16(mode->CrtcHSyncEnd - mode->CrtcHSyncStart);
    param.usV_SyncOffset    = cpu_to_le16(mode->CrtcVSyncStart - mode->CrtcVDisplay);
    param.usV_SyncWidth     = cpu_to_le16(mode->CrtcVSyncEnd - mode->CrtcVSyncStart);

    if (mode->Flags & V_NVSYNC)
	misc |= ATOM_VSYNC_POLARITY;

    if (mode->Flags & V_NHSYNC)
	misc |= ATOM_HSYNC_POLARITY;

    if (mode->Flags & V_CSYNC)
	misc |= ATOM_COMPOSITESYNC;
d233 10
a242 8
    if (mode->Flags & V_INTERLACE)
	misc |= ATOM_INTERLACE;

    if (mode->Flags & V_DBLSCAN)
	misc |= ATOM_DOUBLE_CLOCK_MODE;

    param.susModeMiscInfo.usAccess = cpu_to_le16(misc);
    param.ucCRTC= radeon_crtc->crtc_id;
d246 1
a246 1
    data.exec.pspace = &param;
d248 1
a248 1
    if (RHDAtomBiosFunc(info->atomBIOS->scrnIndex, info->atomBIOS, ATOMBIOS_EXEC, &data) == ATOM_SUCCESS) {
d257 2
a258 2
static void
atombios_pick_pll(xf86CrtcPtr crtc)
d261 10
a270 2
    RADEONInfoPtr info = RADEONPTR(crtc->scrn);
    xf86CrtcConfigPtr xf86_config = XF86_CRTC_CONFIG_PTR(crtc->scrn);
a271 62
    RADEONOutputPrivatePtr radeon_output;
    int o, c;
    uint32_t pll_use_mask = 0;
    Bool is_dp = FALSE;

    if (IS_DCE4_VARIANT) {
	for (o = 0; o < xf86_config->num_output; o++) {
	    output = xf86_config->output[o];
	    if (output->crtc == crtc) {
		int mode = atombios_get_encoder_mode(output);
		radeon_output = output->driver_private;

		if (mode == ATOM_ENCODER_MODE_DP) {
		    is_dp = TRUE;
		    break;
		} else {
		    for (c = 0; c < xf86_config->num_crtc; c++) {
			xf86CrtcPtr test_crtc = xf86_config->crtc[c];
			RADEONCrtcPrivatePtr radeon_test_crtc = test_crtc->driver_private;

			if (crtc != test_crtc && (radeon_test_crtc->pll_id >= 0))
			    pll_use_mask |= (1 << radeon_test_crtc->pll_id);

		    }
		}
	    }
	}
	/* DP clock comes from DCPLL, DP PHY CLK comes from ext source
	 * setting ATOM_PPLL_INVALID skips the PPLL programming for DP
	 */
	if (is_dp)
	    radeon_crtc->pll_id = ATOM_PPLL_INVALID;
	else if (!(pll_use_mask & 1))
	    radeon_crtc->pll_id = ATOM_PPLL1;
	else
	    radeon_crtc->pll_id = ATOM_PPLL2;
    } else
	radeon_crtc->pll_id = radeon_crtc->crtc_id;

    ErrorF("Picked PLL %d\n", radeon_crtc->pll_id);

    for (o = 0; o < xf86_config->num_output; o++) {
	output = xf86_config->output[o];
	if (output->crtc == crtc) {
	    radeon_output = output->driver_private;
	    radeon_output->pll_id = radeon_crtc->pll_id;
	}
    }
}

union adjust_pixel_clock {
	ADJUST_DISPLAY_PLL_PS_ALLOCATION v1;
	ADJUST_DISPLAY_PLL_PS_ALLOCATION_V3 v3;
};

static uint32_t atombios_adjust_pll(xf86CrtcPtr crtc, DisplayModePtr mode, int *pll_flags_p)
{
    RADEONCrtcPrivatePtr radeon_crtc = crtc->driver_private;
    ScrnInfoPtr pScrn = crtc->scrn;
    RADEONInfoPtr  info = RADEONPTR(pScrn);
    xf86CrtcConfigPtr   xf86_config = XF86_CRTC_CONFIG_PTR(crtc->scrn);
    uint32_t adjusted_clock = mode->Clock;
a273 1
    xf86OutputPtr output;
d275 1
a275 1
    int i;
d277 3
a279 11
    if (IS_AVIVO_VARIANT) {
	if (xf86ReturnOptValBool(info->Options, OPTION_NEW_PLL, TRUE))
	    radeon_crtc->pll_algo = RADEON_PLL_NEW;
	else
	    radeon_crtc->pll_algo = RADEON_PLL_OLD;
    } else {
	if (xf86ReturnOptValBool(info->Options, OPTION_NEW_PLL, FALSE))
	    radeon_crtc->pll_algo = RADEON_PLL_NEW;
	else
	    radeon_crtc->pll_algo = RADEON_PLL_OLD;
    }
d281 1
d283 1
a283 6
	if ((info->ChipFamily == CHIP_FAMILY_RS600) ||
	    (info->ChipFamily == CHIP_FAMILY_RS690) ||
	    (info->ChipFamily == CHIP_FAMILY_RS740))
	    pll_flags |= /*RADEON_PLL_USE_FRAC_FB_DIV |*/
		RADEON_PLL_PREFER_CLOSEST_LOWER;
	if (IS_DCE32_VARIANT && mode->Clock > 200000) /* range limits??? */
d287 9
d299 5
a303 23
	if (mode->Clock > 200000) /* range limits??? */
	    pll_flags |= RADEON_PLL_PREFER_HIGH_FB_DIV;
	else
	    pll_flags |= RADEON_PLL_PREFER_LOW_REF_DIV;
    }
    
    for (i = 0; i < xf86_config->num_output; i++) {
	output = xf86_config->output[i];
	if (output->crtc == crtc) {
	    radeon_output = output->driver_private;
	    radeon_encoder = radeon_get_encoder(output);
	    if (IS_AVIVO_VARIANT) {
		/* DVO wants 2x pixel clock if the DVO chip is in 12 bit mode */
		if (radeon_encoder &&
		    (radeon_encoder->encoder_id == ENCODER_OBJECT_ID_INTERNAL_KLDSCP_DVO1) &&
		    !IS_DCE3_VARIANT)
		    adjusted_clock *= 2;
		if (radeon_output->active_device &
		    (ATOM_DEVICE_CV_SUPPORT | ATOM_DEVICE_TV_SUPPORT)) {
		    pll_flags |= RADEON_PLL_PREFER_CLOSEST_LOWER;
		    radeon_crtc->pll_algo = RADEON_PLL_OLD;
		}
	    } else {
a309 2
    	    if (IS_DCE3_VARIANT)
		break;
a310 7
    }
    
    if (IS_DCE3_VARIANT) {
	union adjust_pixel_clock args;
	int major, minor, index;
	AtomBiosArgRec data;
	unsigned char *space;
d312 4
a315 61
	memset(&args, 0, sizeof(args));

	index = GetIndexIntoMasterTable(COMMAND, AdjustDisplayPll);

	atombios_get_command_table_version(info->atomBIOS, index, &major, &minor);

	data.exec.index = index;
	data.exec.dataSpace = (void *)&space;
	data.exec.pspace = &args;

	switch(major) {
	case 1:
	    switch(minor) {
	    case 1:
	    case 2:
		args.v1.usPixelClock = cpu_to_le16(adjusted_clock / 10);
		args.v1.ucTransmitterID = radeon_encoder->encoder_id;
		args.v1.ucEncodeMode = atombios_get_encoder_mode(output);

		ErrorF("before %d\n", args.v1.usPixelClock);
		if (RHDAtomBiosFunc(info->atomBIOS->scrnIndex, info->atomBIOS, ATOMBIOS_EXEC, &data) == ATOM_SUCCESS) {
		    adjusted_clock = le16_to_cpu(args.v1.usPixelClock) * 10;
		}
		ErrorF("after %d\n", args.v1.usPixelClock);
		break;
	    case 3:
		args.v3.sInput.usPixelClock = cpu_to_le16(adjusted_clock / 10);
		args.v3.sInput.ucTransmitterID = radeon_encoder->encoder_id;
		args.v3.sInput.ucEncodeMode = atombios_get_encoder_mode(output);
		args.v3.sInput.ucDispPllConfig = 0;
		if (radeon_output->coherent_mode || (args.v3.sInput.ucEncodeMode == ATOM_ENCODER_MODE_DP))
		    args.v3.sInput.ucDispPllConfig |= DISPPLL_CONFIG_COHERENT_MODE;
		if (adjusted_clock > 165000)
		    args.v3.sInput.ucDispPllConfig |= DISPPLL_CONFIG_DUAL_LINK;
		// if SS
		//    args.v3.sInput.ucDispPllConfig |= DISPPLL_CONFIG_SS_ENABLE;

		ErrorF("before %d 0x%x\n", args.v3.sInput.usPixelClock, args.v3.sInput.ucDispPllConfig);
		if (RHDAtomBiosFunc(info->atomBIOS->scrnIndex, info->atomBIOS, ATOMBIOS_EXEC, &data) == ATOM_SUCCESS) {
		    adjusted_clock = args.v3.sOutput.ulDispPllFreq * 10;
		    if (args.v3.sOutput.ucRefDiv) {
			pll_flags |= RADEON_PLL_USE_REF_DIV;
			info->pll.reference_div = args.v3.sOutput.ucRefDiv;
		    }
		    if (args.v3.sOutput.ucPostDiv) {
			pll_flags |= RADEON_PLL_USE_POST_DIV;
			info->pll.post_div = args.v3.sOutput.ucPostDiv;
		    }
		    ErrorF("after %d %d %d\n", args.v3.sOutput.ulDispPllFreq,
			   args.v3.sOutput.ucRefDiv, args.v3.sOutput.ucPostDiv);
		}
		break;
	    default:
		ErrorF("%s: Unknown table version %d %d\n", __func__, major, minor);
		goto out;
	    }
	    break;
	default:
	    ErrorF("%s: Unknown table version %d %d\n", __func__, major, minor);
	    goto out;
	}
a316 12
out:
    *pll_flags_p = pll_flags;
    return adjusted_clock;
}
				    
union set_pixel_clock {
	SET_PIXEL_CLOCK_PS_ALLOCATION base;
	PIXEL_CLOCK_PARAMETERS v1;
	PIXEL_CLOCK_PARAMETERS_V2 v2;
	PIXEL_CLOCK_PARAMETERS_V3 v3;
	PIXEL_CLOCK_PARAMETERS_V5 v5;
};
d318 2
a319 13
static void
atombios_crtc_set_dcpll(xf86CrtcPtr crtc)
{
    RADEONInfoPtr  info = RADEONPTR(crtc->scrn);
    xf86CrtcConfigPtr   xf86_config = XF86_CRTC_CONFIG_PTR(crtc->scrn);
    xf86OutputPtr output = NULL;
    RADEONOutputPrivatePtr radeon_output = NULL;
    radeon_encoder_ptr radeon_encoder = NULL;
    int index;
    int major, minor, i;
    union set_pixel_clock args;
    AtomBiosArgRec data;
    unsigned char *space;
d321 6
a326 1
    memset(&args, 0, sizeof(args));
d328 1
a347 1
    index = GetIndexIntoMasterTable(COMMAND, SetPixelClock);
d354 24
a377 5
	case 5:
	    args.v5.ucCRTC = ATOM_CRTC_INVALID;
	    /* XXX: get this from the firmwareinfo table */
	    args.v5.usPixelClock = info->default_dispclk;
	    args.v5.ucPpll = ATOM_DCPLL;
d389 1
a389 1
    data.exec.index = index;
d391 1
a391 1
    data.exec.pspace = &args;
d394 1
a394 1
	ErrorF("Set DCPLL success\n");
d398 1
a398 1
    ErrorF("Set DCPLL failed\n");
d402 5
a406 2
static void
atombios_crtc_set_pll(xf86CrtcPtr crtc, DisplayModePtr mode)
d408 1
a409 1
    ScrnInfoPtr pScrn = crtc->scrn;
d411 1
d413 13
a425 13
    int index;
    uint32_t sclock;
    uint32_t ref_div = 0, fb_div = 0, frac_fb_div = 0, post_div = 0;
    int major, minor;
    union set_pixel_clock args;
    xf86OutputPtr output = NULL;
    xf86CrtcConfigPtr   xf86_config = XF86_CRTC_CONFIG_PTR(crtc->scrn);
    radeon_encoder_ptr radeon_encoder = NULL;
    int pll_flags = 0;
    uint32_t temp;
    AtomBiosArgRec data;
    unsigned char *space;
    int i;
d427 4
a430 1
    memset(&args, 0, sizeof(args));
d432 8
a439 21
    if (IS_DCE4_VARIANT) {
	/* XXX 6 crtcs, but only 2 plls */
	switch (radeon_crtc->pll_id) {
	case ATOM_PPLL1:
	    temp = INREG(EVERGREEN_P1PLL_SS_CNTL);
	    OUTREG(EVERGREEN_P1PLL_SS_CNTL, temp & ~EVERGREEN_PxPLL_SS_EN);
	    break;
	case ATOM_PPLL2:
	    temp = INREG(EVERGREEN_P2PLL_SS_CNTL);
	    OUTREG(EVERGREEN_P2PLL_SS_CNTL, temp & ~EVERGREEN_PxPLL_SS_EN);
	    break;
	}
    } else {
	if (radeon_crtc->crtc_id == 0) {
	    temp = INREG(AVIVO_P1PLL_INT_SS_CNTL);
	    OUTREG(AVIVO_P1PLL_INT_SS_CNTL, temp & ~1);
	} else {
	    temp = INREG(AVIVO_P2PLL_INT_SS_CNTL);
	    OUTREG(AVIVO_P2PLL_INT_SS_CNTL, temp & ~1);
	}
    }
a440 6
    if (IS_DCE3_VARIANT) {
	for (i = 0; i < xf86_config->num_output; i++) {
	    output = xf86_config->output[i];
	    if (output->crtc == crtc) {
		radeon_encoder = radeon_get_encoder(output);
		break;
d443 1
d445 5
a449 7
	if (output->driver_private == NULL) {
	    xf86DrvMsg(crtc->scrn->scrnIndex, X_ERROR, "No output assigned to crtc!\n");
	    return;
	}
	if (radeon_encoder == NULL) {
	    xf86DrvMsg(crtc->scrn->scrnIndex, X_ERROR, "No encoder assigned to output!\n");
	    return;
d453 5
a457 1
    sclock = atombios_adjust_pll(crtc, mode, &pll_flags);
d459 4
a462 3
    RADEONComputePLL(crtc, &info->pll, sclock, &temp,
		     &fb_div, &frac_fb_div, &ref_div, &post_div, pll_flags);
    sclock = temp; /* 10 khz */
d464 8
a471 7
    xf86DrvMsg(crtc->scrn->scrnIndex, X_INFO,
	       "crtc(%d) Clock: mode %d, PLL %lu\n",
	       radeon_crtc->crtc_id, mode->Clock, (long unsigned int)sclock * 10);
    xf86DrvMsg(crtc->scrn->scrnIndex, X_INFO,
	       "crtc(%d) PLL  : refdiv %u, fbdiv 0x%X(%u), fracfbdiv %u, pdiv %u\n",
	       radeon_crtc->crtc_id, (unsigned int)ref_div, (unsigned int)fb_div,
	       (unsigned int)fb_div, (unsigned int)frac_fb_div, (unsigned int)post_div);
d473 2
a474 2
    index = GetIndexIntoMasterTable(COMMAND, SetPixelClock);
    atombios_get_command_table_version(info->atomBIOS, index, &major, &minor);
d476 2
a477 47
    /*ErrorF("table is %d %d\n", major, minor);*/
    switch(major) {
    case 1:
	switch(minor) {
	case 1:
	case 2:
	    args.v2.usPixelClock = cpu_to_le16(mode->Clock / 10);
	    args.v2.usRefDiv = cpu_to_le16(ref_div);
	    args.v2.usFbDiv = cpu_to_le16(fb_div);
	    args.v2.ucFracFbDiv = frac_fb_div;
	    args.v2.ucPostDiv = post_div;
	    args.v2.ucPpll = radeon_crtc->pll_id;
	    args.v2.ucCRTC = radeon_crtc->crtc_id;
	    args.v2.ucRefDivSrc = 1;
	    break;
	case 3:
	    args.v3.usPixelClock = cpu_to_le16(mode->Clock / 10);
	    args.v3.usRefDiv = cpu_to_le16(ref_div);
	    args.v3.usFbDiv = cpu_to_le16(fb_div);
	    args.v3.ucFracFbDiv = frac_fb_div;
	    args.v3.ucPostDiv = post_div;
	    args.v3.ucPpll = radeon_crtc->pll_id;
	    args.v3.ucMiscInfo = (radeon_crtc->crtc_id << 2);
	    args.v3.ucTransmitterId = radeon_encoder->encoder_id;
	    args.v3.ucEncoderMode = atombios_get_encoder_mode(output);
	    break;
	case 5:
	    args.v5.ucCRTC = radeon_crtc->crtc_id;
	    args.v5.usPixelClock = cpu_to_le16(mode->Clock / 10);
	    args.v5.ucRefDiv = ref_div;
	    args.v5.usFbDiv = cpu_to_le16(fb_div);
	    args.v5.ulFbDivDecFrac = cpu_to_le32(frac_fb_div * 100000);
	    args.v5.ucPostDiv = post_div;
	    args.v5.ucPpll = radeon_crtc->pll_id;
	    args.v5.ucMiscInfo = 0; //HDMI depth
	    args.v5.ucTransmitterID = radeon_encoder->encoder_id;
	    args.v5.ucEncoderMode = atombios_get_encoder_mode(output);
	    break;
	default:
	    ErrorF("Unknown table version\n");
	    exit(-1);
	}
	break;
    default:
	ErrorF("Unknown table version\n");
	exit(-1);
    }
d479 14
a492 3
    data.exec.index = index;
    data.exec.dataSpace = (void *)&space;
    data.exec.pspace = &args;
d494 2
a495 4
    if (RHDAtomBiosFunc(info->atomBIOS->scrnIndex, info->atomBIOS, ATOMBIOS_EXEC, &data) == ATOM_SUCCESS) {
	ErrorF("Set CRTC %d PLL success\n", radeon_crtc->crtc_id);
	return;
    }
d497 2
a498 3
    ErrorF("Set CRTC %d PLL failed\n", radeon_crtc->crtc_id);
    return;
}
d500 2
a501 36
static void evergreen_set_base_format(xf86CrtcPtr crtc,
				      DisplayModePtr mode,
				      DisplayModePtr adjusted_mode,
				      int x, int y)
{
    ScrnInfoPtr pScrn = crtc->scrn;
    RADEONCrtcPrivatePtr radeon_crtc = crtc->driver_private;
    RADEONInfoPtr  info = RADEONPTR(pScrn);
    unsigned char *RADEONMMIO = info->MMIO;
    uint64_t fb_location = crtc->scrn->fbOffset + info->fbLocation;
    uint32_t fb_format;
    uint32_t fb_swap = EVERGREEN_GRPH_ENDIAN_SWAP(EVERGREEN_GRPH_ENDIAN_NONE);

    switch (crtc->scrn->bitsPerPixel) {
    case 15:
	fb_format = (EVERGREEN_GRPH_DEPTH(EVERGREEN_GRPH_DEPTH_16BPP) |
		     EVERGREEN_GRPH_FORMAT(EVERGREEN_GRPH_FORMAT_ARGB1555));
	break;
    case 16:
	fb_format = (EVERGREEN_GRPH_DEPTH(EVERGREEN_GRPH_DEPTH_16BPP) |
		     EVERGREEN_GRPH_FORMAT(EVERGREEN_GRPH_FORMAT_ARGB565));
#if X_BYTE_ORDER == X_BIG_ENDIAN
	fb_swap = EVERGREEN_GRPH_ENDIAN_SWAP(EVERGREEN_GRPH_ENDIAN_8IN16);
#endif
	break;
    case 24:
    case 32:
	fb_format = (EVERGREEN_GRPH_DEPTH(EVERGREEN_GRPH_DEPTH_32BPP) |
		     EVERGREEN_GRPH_FORMAT(EVERGREEN_GRPH_FORMAT_ARGB8888));
#if X_BYTE_ORDER == X_BIG_ENDIAN
	fb_swap = EVERGREEN_GRPH_ENDIAN_SWAP(EVERGREEN_GRPH_ENDIAN_8IN32);
#endif
	break;
    default:
	FatalError("Unsupported screen depth: %d\n", xf86GetDepth());
    }
d503 2
a504 21
    switch (radeon_crtc->crtc_id) {
    case 0:
    default:
	OUTREG(AVIVO_D1VGA_CONTROL, 0);
	break;
    case 1:
	OUTREG(AVIVO_D2VGA_CONTROL, 0);
	break;
    case 2:
	OUTREG(EVERGREEN_D3VGA_CONTROL, 0);
	break;
    case 3:
	OUTREG(EVERGREEN_D4VGA_CONTROL, 0);
	break;
    case 4:
	OUTREG(EVERGREEN_D5VGA_CONTROL, 0);
	break;
    case 5:
	OUTREG(EVERGREEN_D6VGA_CONTROL, 0);
	break;
    }
d506 3
a508 7
    /* setup fb format and location
     */
    if (crtc->rotatedData != NULL) {
	/* x/y offset is already included */
	x = 0;
	y = 0;
	fb_location = fb_location + (char *)crtc->rotatedData - (char *)info->FB;
d511 2
d514 2
a515 31
    OUTREG(EVERGREEN_GRPH_PRIMARY_SURFACE_ADDRESS_HIGH + radeon_crtc->crtc_offset,
	   (fb_location >> 32) & 0xf);
    OUTREG(EVERGREEN_GRPH_SECONDARY_SURFACE_ADDRESS_HIGH + radeon_crtc->crtc_offset,
	   (fb_location >> 32) & 0xf);
    OUTREG(EVERGREEN_GRPH_PRIMARY_SURFACE_ADDRESS + radeon_crtc->crtc_offset,
	   fb_location & EVERGREEN_GRPH_SURFACE_ADDRESS_MASK);
    OUTREG(EVERGREEN_GRPH_SECONDARY_SURFACE_ADDRESS + radeon_crtc->crtc_offset,
	   fb_location & EVERGREEN_GRPH_SURFACE_ADDRESS_MASK);
    OUTREG(EVERGREEN_GRPH_CONTROL + radeon_crtc->crtc_offset, fb_format);
    OUTREG(EVERGREEN_GRPH_SWAP_CONTROL + radeon_crtc->crtc_offset, fb_swap);

    OUTREG(EVERGREEN_GRPH_SURFACE_OFFSET_X + radeon_crtc->crtc_offset, 0);
    OUTREG(EVERGREEN_GRPH_SURFACE_OFFSET_Y + radeon_crtc->crtc_offset, 0);
    OUTREG(EVERGREEN_GRPH_X_START + radeon_crtc->crtc_offset, 0);
    OUTREG(EVERGREEN_GRPH_Y_START + radeon_crtc->crtc_offset, 0);
    OUTREG(EVERGREEN_GRPH_X_END + radeon_crtc->crtc_offset, info->virtualX);
    OUTREG(EVERGREEN_GRPH_Y_END + radeon_crtc->crtc_offset, info->virtualY);
    OUTREG(EVERGREEN_GRPH_PITCH + radeon_crtc->crtc_offset,
	   crtc->scrn->displayWidth);
    OUTREG(EVERGREEN_GRPH_ENABLE + radeon_crtc->crtc_offset, 1);

    OUTREG(EVERGREEN_DESKTOP_HEIGHT + radeon_crtc->crtc_offset, mode->VDisplay);
    x &= ~3;
    y &= ~1;
    OUTREG(EVERGREEN_VIEWPORT_START + radeon_crtc->crtc_offset, (x << 16) | y);
    OUTREG(EVERGREEN_VIEWPORT_SIZE + radeon_crtc->crtc_offset, (mode->HDisplay << 16) | mode->VDisplay);

    if (adjusted_mode->Flags & V_INTERLACE)
	OUTREG(EVERGREEN_DATA_FORMAT + radeon_crtc->crtc_offset, EVERGREEN_INTERLEAVE_EN);
    else
	OUTREG(EVERGREEN_DATA_FORMAT + radeon_crtc->crtc_offset, 0);
d517 4
a520 1
}
d522 2
a523 11
static void avivo_set_base_format(xf86CrtcPtr crtc,
				  DisplayModePtr mode,
				  DisplayModePtr adjusted_mode,
				  int x, int y)
{
    ScrnInfoPtr pScrn = crtc->scrn;
    RADEONCrtcPrivatePtr radeon_crtc = crtc->driver_private;
    RADEONInfoPtr  info = RADEONPTR(pScrn);
    unsigned char *RADEONMMIO = info->MMIO;
    uint64_t fb_location = crtc->scrn->fbOffset + info->fbLocation;
    uint32_t fb_format;
d525 1
a525 1
    uint32_t fb_swap = R600_D1GRPH_SWAP_ENDIAN_NONE;
d528 6
a533 6
    switch (crtc->scrn->bitsPerPixel) {
    case 15:
	fb_format = AVIVO_D1GRPH_CONTROL_DEPTH_16BPP | AVIVO_D1GRPH_CONTROL_16BPP_ARGB1555;
	break;
    case 16:
	fb_format = AVIVO_D1GRPH_CONTROL_DEPTH_16BPP | AVIVO_D1GRPH_CONTROL_16BPP_RGB565;
d535 1
a535 1
	fb_swap = R600_D1GRPH_SWAP_ENDIAN_16BIT;
d537 4
a540 4
	break;
    case 24:
    case 32:
	fb_format = AVIVO_D1GRPH_CONTROL_DEPTH_32BPP | AVIVO_D1GRPH_CONTROL_32BPP_ARGB8888;
d542 1
a542 1
	fb_swap = R600_D1GRPH_SWAP_ENDIAN_32BIT;
d544 4
a547 4
	break;
    default:
	FatalError("Unsupported screen depth: %d\n", xf86GetDepth());
    }
d549 3
a551 3
    if (info->tilingEnabled && (crtc->rotatedData == NULL)) {
	fb_format |= AVIVO_D1GRPH_MACRO_ADDRESS_MODE;
    }
d553 4
a556 4
    if (radeon_crtc->crtc_id == 0)
	OUTREG(AVIVO_D1VGA_CONTROL, 0);
    else
	OUTREG(AVIVO_D2VGA_CONTROL, 0);
d558 8
a565 8
    /* setup fb format and location
     */
    if (crtc->rotatedData != NULL) {
	/* x/y offset is already included */
	x = 0;
	y = 0;
	fb_location = fb_location + (char *)crtc->rotatedData - (char *)info->FB;
    }
d567 3
a569 14
    if (info->ChipFamily >= CHIP_FAMILY_RV770) {
	if (radeon_crtc->crtc_id) {
	    OUTREG(R700_D2GRPH_PRIMARY_SURFACE_ADDRESS_HIGH, (fb_location >> 32) & 0xf);
	    OUTREG(R700_D2GRPH_SECONDARY_SURFACE_ADDRESS_HIGH, (fb_location >> 32) & 0xf);
	} else {
	    OUTREG(R700_D1GRPH_PRIMARY_SURFACE_ADDRESS_HIGH, (fb_location >> 32) & 0xf);
	    OUTREG(R700_D1GRPH_SECONDARY_SURFACE_ADDRESS_HIGH, (fb_location >> 32) & 0xf);
	}
    }
    OUTREG(AVIVO_D1GRPH_PRIMARY_SURFACE_ADDRESS + radeon_crtc->crtc_offset,
	   fb_location & 0xffffffff);
    OUTREG(AVIVO_D1GRPH_SECONDARY_SURFACE_ADDRESS + radeon_crtc->crtc_offset,
	   fb_location & 0xffffffff);
    OUTREG(AVIVO_D1GRPH_CONTROL + radeon_crtc->crtc_offset, fb_format);
d572 2
a573 2
    if (info->ChipFamily >= CHIP_FAMILY_R600)
	OUTREG(R600_D1GRPH_SWAP_CONTROL + radeon_crtc->crtc_offset, fb_swap);
d576 26
a601 23
    OUTREG(AVIVO_D1GRPH_SURFACE_OFFSET_X + radeon_crtc->crtc_offset, 0);
    OUTREG(AVIVO_D1GRPH_SURFACE_OFFSET_Y + radeon_crtc->crtc_offset, 0);
    OUTREG(AVIVO_D1GRPH_X_START + radeon_crtc->crtc_offset, 0);
    OUTREG(AVIVO_D1GRPH_Y_START + radeon_crtc->crtc_offset, 0);
    OUTREG(AVIVO_D1GRPH_X_END + radeon_crtc->crtc_offset, info->virtualX);
    OUTREG(AVIVO_D1GRPH_Y_END + radeon_crtc->crtc_offset, info->virtualY);
    OUTREG(AVIVO_D1GRPH_PITCH + radeon_crtc->crtc_offset,
	   crtc->scrn->displayWidth);
    OUTREG(AVIVO_D1GRPH_ENABLE + radeon_crtc->crtc_offset, 1);

    OUTREG(AVIVO_D1MODE_DESKTOP_HEIGHT + radeon_crtc->crtc_offset, mode->VDisplay);
    x &= ~3;
    y &= ~1;
    OUTREG(AVIVO_D1MODE_VIEWPORT_START + radeon_crtc->crtc_offset, (x << 16) | y);
    OUTREG(AVIVO_D1MODE_VIEWPORT_SIZE + radeon_crtc->crtc_offset,
	   (mode->HDisplay << 16) | mode->VDisplay);

    if (mode->Flags & V_INTERLACE)
	OUTREG(AVIVO_D1MODE_DATA_FORMAT + radeon_crtc->crtc_offset,
	       AVIVO_D1MODE_INTERLEAVE_EN);
    else
	OUTREG(AVIVO_D1MODE_DATA_FORMAT + radeon_crtc->crtc_offset, 0);
}
a602 11
static void legacy_set_base_format(xf86CrtcPtr crtc,
				   DisplayModePtr mode,
				   DisplayModePtr adjusted_mode,
				   int x, int y)
{
    ScrnInfoPtr pScrn = crtc->scrn;
    RADEONCrtcPrivatePtr radeon_crtc = crtc->driver_private;
    RADEONInfoPtr  info = RADEONPTR(pScrn);
    unsigned char *RADEONMMIO = info->MMIO;
    int format = 0;
    uint32_t crtc_gen_cntl, crtc2_gen_cntl, crtc_pitch;
d604 17
a620 16
    RADEONInitCommonRegisters(info->ModeReg, info);
    RADEONInitSurfaceCntl(crtc, info->ModeReg);
    RADEONRestoreCommonRegisters(pScrn, info->ModeReg);

    switch (info->CurrentLayout.pixel_code) {
    case 4:  format = 1; break;
    case 8:  format = 2; break;
    case 15: format = 3; break;      /*  555 */
    case 16: format = 4; break;      /*  565 */
    case 24: format = 5; break;      /*  RGB */
    case 32: format = 6; break;      /* xRGB */
    default:
	xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
		   "Unsupported pixel depth (%d)\n",
		   info->CurrentLayout.bitsPerPixel);
    }
d622 2
a623 2
    crtc_pitch  = (((pScrn->displayWidth * pScrn->bitsPerPixel) +
		    ((pScrn->bitsPerPixel * 8) -1)) /
d625 1
a625 1
    crtc_pitch |= crtc_pitch << 16;
d627 21
a647 19
    switch (radeon_crtc->crtc_id) {
    case 0:
	crtc_gen_cntl = INREG(RADEON_CRTC_GEN_CNTL) & 0xfffff0ff;
	crtc_gen_cntl |= (format << 8);
	OUTREG(RADEON_CRTC_GEN_CNTL, crtc_gen_cntl);
	OUTREG(RADEON_CRTC_PITCH, crtc_pitch);
	RADEONInitCrtcBase(crtc, info->ModeReg, x, y);
	RADEONRestoreCrtcBase(pScrn, info->ModeReg);
	break;
    case 1:
	crtc2_gen_cntl = INREG(RADEON_CRTC2_GEN_CNTL) & 0xfffff0ff;
	crtc2_gen_cntl |= (format << 8);
	OUTREG(RADEON_CRTC2_GEN_CNTL, crtc2_gen_cntl);
	OUTREG(RADEON_CRTC2_PITCH, crtc_pitch);
	RADEONInitCrtc2Base(crtc, info->ModeReg, x, y);
	RADEONRestoreCrtc2Base(pScrn, info->ModeReg);
	OUTREG(RADEON_FP_H2_SYNC_STRT_WID,   INREG(RADEON_CRTC2_H_SYNC_STRT_WID));
	OUTREG(RADEON_FP_V2_SYNC_STRT_WID,   INREG(RADEON_CRTC2_V_SYNC_STRT_WID));
	break;
a648 42
}

void
atombios_crtc_mode_set(xf86CrtcPtr crtc,
		       DisplayModePtr mode,
		       DisplayModePtr adjusted_mode,
		       int x, int y)
{
    ScrnInfoPtr pScrn = crtc->scrn;
    RADEONCrtcPrivatePtr radeon_crtc = crtc->driver_private;
    RADEONInfoPtr  info = RADEONPTR(pScrn);
    Bool tilingChanged = FALSE;

    if (info->allowColorTiling) {
	radeon_crtc->can_tile = (mode->Flags & (V_DBLSCAN | V_INTERLACE)) ? FALSE : TRUE;
	tilingChanged = RADEONSetTiling(pScrn);
    }

    ErrorF("Mode %dx%d - %d %d %d\n", adjusted_mode->CrtcHDisplay, adjusted_mode->CrtcVDisplay,
	   adjusted_mode->CrtcHTotal, adjusted_mode->CrtcVTotal, adjusted_mode->Flags);

    RADEONInitMemMapRegisters(pScrn, info->ModeReg, info);
    RADEONRestoreMemMapRegisters(pScrn, info->ModeReg);

    if (IS_DCE4_VARIANT)
	atombios_crtc_set_dcpll(crtc);
    atombios_pick_pll(crtc);
    atombios_crtc_set_pll(crtc, adjusted_mode);
    if (IS_DCE4_VARIANT)
	atombios_set_crtc_dtd_timing(crtc, adjusted_mode);
    else {
	atombios_set_crtc_timing(crtc, adjusted_mode);
	if (!IS_AVIVO_VARIANT && (radeon_crtc->crtc_id == 0))
	    atombios_set_crtc_dtd_timing(crtc, adjusted_mode);
    }

    if (IS_DCE4_VARIANT)
	evergreen_set_base_format(crtc, mode, adjusted_mode, x, y);
    else if (IS_AVIVO_VARIANT)
	avivo_set_base_format(crtc, mode, adjusted_mode, x, y);
    else
	legacy_set_base_format(crtc, mode, adjusted_mode, x, y);
d679 3
a681 4
    float available_bandwidth = 0;
    float read_delay_latency = 1000;
    int i;
    Bool sideport = FALSE;
d692 1
a692 2
	else if ((info->ChipFamily == CHIP_FAMILY_RS690) ||
		 (info->ChipFamily == CHIP_FAMILY_RS740))
d705 1
a705 2
	else if ((info->ChipFamily == CHIP_FAMILY_RS690) ||
		 (info->ChipFamily == CHIP_FAMILY_RS740))
d709 23
d747 1
d750 1
d770 1
a770 2
    OUTREG(AVIVO_DC_LB_MEMORY_SPLIT, dc_lb_memory_split);
#if 0
d783 5
a787 4
    /* fixme
     * Still need to implement the actual watermark calculation
     * for rs600.  This just allows us to force high display
     * priority.
a788 404
    if (info->ChipFamily == CHIP_FAMILY_RS600) {
	if (info->DispPriority == 2) {
	    uint32_t priority_cnt;

	    if (mode1) {
		priority_cnt = INREG(AVIVO_D1MODE_PRIORITY_A_CNT);
		priority_cnt |= AVIVO_DxMODE_PRIORITY_ALWAYS_ON;
		OUTREG(AVIVO_D1MODE_PRIORITY_A_CNT, priority_cnt);

		priority_cnt = INREG(AVIVO_D1MODE_PRIORITY_B_CNT);
		priority_cnt |= AVIVO_DxMODE_PRIORITY_ALWAYS_ON;
		OUTREG(AVIVO_D1MODE_PRIORITY_B_CNT, priority_cnt);
	    }

	    if (mode2) {
		priority_cnt = INREG(AVIVO_D2MODE_PRIORITY_A_CNT);
		priority_cnt |= AVIVO_DxMODE_PRIORITY_ALWAYS_ON;
		OUTREG(AVIVO_D2MODE_PRIORITY_A_CNT, priority_cnt);

		priority_cnt = INREG(AVIVO_D2MODE_PRIORITY_B_CNT);
		priority_cnt |= AVIVO_DxMODE_PRIORITY_ALWAYS_ON;
		OUTREG(AVIVO_D2MODE_PRIORITY_B_CNT, priority_cnt);
	    }
	}
	return;
    }

    /* IGP bandwidth - get from integrated systems table
     * SYSTEM_MEMORY_BANDWIDTH (Mbyte/s) = SYSTEM_MEMORY_CLOCK (MHz) * (1+DDR) * 8 * EFF * Num of channels
     * SIDEPORT_MEMORY_BANDWIDTH = SIDEPORT_MEMORY_CLOCK * 2(byte) * 2(DDR) * 0.7(Eff)
     * CORE_CLOCK_BANDWIDTH (Mbyte/s) = SCLK (MHz) * 16 / Dynamic Engine clock Divider
     * HT_LINK_BANDWIDTH = HT_LINK_CLOCK * 2 * HT_LINK_WIDTH/8 * HT_LINK_EFF
     * system read delay
     * READ_DLY_MAX_LATENCY: 5000 ns
     * sideport read delay
     * READ_DLY_MAX_LATENCY: 370 * MCLK + 800 ns
     * MCLK is the sideport memory clock period in ns (MCLK = 1000 / MCLKfreq MHz)
     */

    if (info->IsIGP) {
	float core_clock_bandwidth = ((float)info->pm.mode[info->pm.current_mode].sclk / 100) * 16 / 1;

	if (sideport) {
	    float sideport_memory_bandwidth = (info->igp_sideport_mclk / 2) * 2 * 2 * 0.7;
	    float mclk = 1000 / info->igp_sideport_mclk;
	    read_delay_latency = 370 * mclk * 800;
	    available_bandwidth = MIN(sideport_memory_bandwidth, core_clock_bandwidth);
	} else {
	    float system_memory_bandwidth = (info->igp_system_mclk / 2) * (1 + 1) * 8 * 0.5 * 1;
	    float ht_link_bandwidth = info->igp_ht_link_clk * 2 * (info->igp_ht_link_width / 8) * 0.8;
	    read_delay_latency = 5000;
	    available_bandwidth = MIN(system_memory_bandwidth, MIN(ht_link_bandwidth, core_clock_bandwidth));
	}
    }

    /* calculate for each display */
    for (i = 0; i < 2; i++) {
	DisplayModePtr current = NULL;
	//RADEONCrtcPrivatePtr radeon_crtc = pRADEONEnt->Controller[i];
	float pclk, sclk, sclkfreq = 0;
	float consumption_time, consumption_rate;
	int num_line_pair, request_fifo_depth, lb_request_fifo_depth;
	int max_req;
	uint32_t lb_max_req_outstanding, priority_cnt;
	float line_time, active_time, chunk_time;
	float worst_case_latency, tolerable_latency;
	float fill_rate;
	int priority_mark_max, priority_mark, priority_mark2;
	int width, estimated_width;
	/* FIXME: handle the scalers better */
	Bool d1_scale_en = pRADEONEnt->Controller[0]->scaler_enabled;
	Bool d2_scale_en = pRADEONEnt->Controller[1]->scaler_enabled;
	float vtaps1 = 2; /* XXX */
	float vsc1 = pRADEONEnt->Controller[0]->vsc;
	float hsc1 = pRADEONEnt->Controller[0]->hsc;
	float vtaps2 = 2; /* XXX */
	float vsc2 = pRADEONEnt->Controller[1]->vsc;
	float hsc2 = pRADEONEnt->Controller[1]->hsc;

	if (i == 0)
	    current = mode1;
	else
	    current = mode2;

	if (current == NULL)
	    continue;

	/* Determine consumption rate
	   pclk = pixel clock period(ns)
	   vtaps = number of vertical taps,
	   vsc = vertical scaling ratio, defined as source/destination
	   hsc = horizontal scaling ration, defined as source/destination
	*/

	pclk = 1000 / ((float)current->Clock / 1000);

	if (i == 0) {
	    if (d1_scale_en)
		consumption_time = pclk / ((MAX(vtaps1, vsc1) * hsc1) / vtaps1);
	    else
		consumption_time = pclk;
	} else {
	    if (d2_scale_en)
		consumption_time = pclk / ((MAX(vtaps2, vsc2) * hsc2) / vtaps2);
	    else
		consumption_time = pclk;
	}

	consumption_rate = 1 / consumption_time;

	/* Determine request line buffer fifo depth
	   NumLinePair = Number of line pairs to request(1 = 2 lines, 2 = 4 lines)
	   LBRequestFifoDepth = Number of chunk requests the LB can put into the request FIFO for a display
	   width = viewport width in pixels
	*/
	if (i == 0) {
	    if (vsc1 > 2)
		num_line_pair = 2;
	    else
		num_line_pair = 1;
	} else {
	    if (vsc2 > 2)
		num_line_pair = 2;
	    else
		num_line_pair = 1;
	}

	width = current->CrtcHDisplay;
	request_fifo_depth = ceil(width/256) * num_line_pair;
	if (request_fifo_depth < 4)
	    lb_request_fifo_depth = 4;
	else
	    lb_request_fifo_depth = request_fifo_depth;

	if (info->IsIGP) {
	    if ((info->ChipFamily == CHIP_FAMILY_RS690) ||
		(info->ChipFamily == CHIP_FAMILY_RS740))
		OUTREG(RS690_DCP_CONTROL, 0);
	    else if ((info->ChipFamily == CHIP_FAMILY_RS780) ||
		     (info->ChipFamily == CHIP_FAMILY_RS880))
		OUTREG(RS690_DCP_CONTROL, 2);
	    max_req = lb_request_fifo_depth - 1;
	} else
	    max_req = lb_request_fifo_depth;

	/*ErrorF("max_req %d: 0x%x\n", i, max_req);*/

	lb_max_req_outstanding = INREG(AVIVO_LB_MAX_REQ_OUTSTANDING);
	if (i == 0) {
	    lb_max_req_outstanding &= ~(AVIVO_LB_D1_MAX_REQ_OUTSTANDING_MASK << AVIVO_LB_D1_MAX_REQ_OUTSTANDING_SHIFT);
	    lb_max_req_outstanding |= (max_req & AVIVO_LB_D1_MAX_REQ_OUTSTANDING_MASK) << AVIVO_LB_D1_MAX_REQ_OUTSTANDING_SHIFT;
	} else {
	    lb_max_req_outstanding &= ~(AVIVO_LB_D2_MAX_REQ_OUTSTANDING_MASK << AVIVO_LB_D2_MAX_REQ_OUTSTANDING_SHIFT);
	    lb_max_req_outstanding |= (max_req & AVIVO_LB_D2_MAX_REQ_OUTSTANDING_MASK) << AVIVO_LB_D2_MAX_REQ_OUTSTANDING_SHIFT;
	}
	OUTREG(AVIVO_LB_MAX_REQ_OUTSTANDING, lb_max_req_outstanding);

	/* Determine line time
	   LineTime = total time for one line of displayhtotal = total number of horizontal pixels
	   pclk = pixel clock period(ns)
	*/
	line_time = current->CrtcHTotal * pclk;

	/* Determine active time
	   ActiveTime = time of active region of display within one line,
	   hactive = total number of horizontal active pixels
	   htotal = total number of horizontal pixels
	*/
	active_time = line_time * current->CrtcHDisplay / current->CrtcHTotal;

	/* Determine chunk time
	   ChunkTime = the time it takes the DCP to send one chunk of data
	   to the LB which consists of pipeline delay and inter chunk gap
	   sclk = system clock(ns)
	*/
	if (info->IsIGP) {
	    sclk = 1000 / (available_bandwidth / 16);
	    /* Sclkfreq = sclk in MHz = 1000/sclk (because sclk is in ns). */
	    sclkfreq = 1000 / sclk;
	    chunk_time = sclk * 256 * 1.3;
	} else {
	    sclk = 1000 / ((float)info->pm.mode[info->pm.current_mode].sclk / 100);
	    chunk_time = sclk * 600;
	}

	/* Determine the worst case latency
	   NumLinePair = Number of line pairs to request(1 = 2 lines, 2 = 4 lines)
	   WorstCaseLatency = The worst case time from urgent to when the MC starts
	   to return data
	   READ_DELAY_IDLE_MAX = constant of 1us
	   ChunkTime = the time it takes the DCP to send one chunk of data to the LB
	   which consists of pipeline delay and
	   inter chunk gap
	*/
	if (info->IsIGP) {
	    if (num_line_pair > 1)
		worst_case_latency = read_delay_latency + 3 * chunk_time;
	    else
		worst_case_latency = read_delay_latency + 2 * chunk_time;
	} else {
	    if (num_line_pair > 1)
		worst_case_latency = read_delay_latency + 3 * chunk_time;
	    else
		worst_case_latency = read_delay_latency + chunk_time;
	}

	/* Determine the tolerable latency
	   TolerableLatency = Any given request has only 1 line time for the data to be returned
	   LBRequestFifoDepth = Number of chunk requests the LB can put into the request FIFO for a display
	   LineTime = total time for one line of display
	   ChunkTime = the time it takes the DCP to send one chunk of data to the LB which consists of
	   pipeline delay and inter chunk gap
	*/
	if ((2 + lb_request_fifo_depth) >= request_fifo_depth)
	    tolerable_latency = line_time;
	else
	    tolerable_latency = line_time - (request_fifo_depth - lb_request_fifo_depth - 2) * chunk_time;

	if (mode1 && mode2) {
	    int d1bpp, d2bpp;
	    int d1_graph_enable = 1;
	    int d2_graph_enable = 1;
	    int d1_ovl_enable = 0;
	    int d2_ovl_enable = 0;
	    int d1grph_depth, d2grph_depth;
	    int d1ovl_depth = 0;
	    int d2ovl_depth = 0;
	    int d1_num_line_pair, d2_num_line_pair;
	    float d1_fill_rate_coeff, d2_fill_rate_coeff;

	    switch (pixel_bytes1) {
	    case 2:
		d1grph_depth = 1;
		break;
	    case 4:
		d1grph_depth = 2;
		break;
	    default:
		d1grph_depth = 0;
		break;
	    }

	    switch (pixel_bytes2) {
	    case 2:
		d2grph_depth = 1;
		break;
	    case 4:
		d2grph_depth = 2;
		break;
	    default:
		d2grph_depth = 0;
		break;
	    }

	    /* If both displays are active, determine line buffer fill rate */
	    if (d1_scale_en && (vsc1 > 2))
		d1_num_line_pair = 2;
	    else
		d1_num_line_pair = 1;

	    if (d2_scale_en && (vsc2 > 2))
		d2_num_line_pair = 2;
	    else
		d2_num_line_pair = 1;

	    if (info->IsIGP) {
		d1bpp = (d1_graph_enable * pow(2, d1grph_depth) * 8) + (d1_ovl_enable * pow(2, d1ovl_depth) * 8);
		d2bpp = (d2_graph_enable * pow(2, d2grph_depth) * 8) + (d2_ovl_enable * pow(2, d2ovl_depth) * 8);

		if (d1bpp > 64)
		    d1_fill_rate_coeff = d1bpp * d1_num_line_pair;
		else
		    d1_fill_rate_coeff = d1_num_line_pair;

		if (d2bpp > 64)
		    d2_fill_rate_coeff = d2bpp * d2_num_line_pair;
		else
		    d2_fill_rate_coeff = d2_num_line_pair;

		fill_rate = sclkfreq / (d1_fill_rate_coeff + d2_fill_rate_coeff);
	    } else {
		d1bpp = (d1grph_depth + d1ovl_depth) * 16;
		d2bpp = (d2grph_depth + d2ovl_depth) * 16;

		if (d1bpp > 64)
		    d1_fill_rate_coeff = d1bpp / d1_num_line_pair;
		else
		    d1_fill_rate_coeff = d1_num_line_pair;

		if (d2bpp > 64)
		    d2_fill_rate_coeff = d2bpp / d2_num_line_pair;
		else
		    d2_fill_rate_coeff = d2_num_line_pair;

		fill_rate = sclk / (d1_fill_rate_coeff + d2_fill_rate_coeff);

		/* Convert line buffer fill rate from period to frequency */
		fill_rate = 1 / fill_rate;
	    }
	} else {
	    int dxbpp;
	    int dx_grph_enable = 1;
	    int dx_ovl_enable = 0;
	    int dxgrph_depth;
	    int dxovl_depth = 0;
	    int cpp;

	    if (i == 0)
		cpp = pixel_bytes1;
	    else
		cpp = pixel_bytes2;

	    switch (cpp) {
	    case 2:
		dxgrph_depth = 1;
		break;
	    case 4:
		dxgrph_depth = 2;
		break;
	    default:
		dxgrph_depth = 0;
		break;
	    }

	    /* If only one display active, the line buffer fill rate becomes */
	    if (info->IsIGP) {
		dxbpp = (dx_grph_enable * pow(2, dxgrph_depth) * 8) + (dx_ovl_enable * pow(2, dxovl_depth) * 8);
		if (dxbpp > 64)
		    fill_rate = sclkfreq / dxbpp / num_line_pair;
		else
		    fill_rate = sclkfreq / num_line_pair;
	    } else {
		dxbpp = (dxgrph_depth + dxovl_depth) * 16;

		if (dxbpp > 64)
		    fill_rate = sclk / dxbpp / num_line_pair;
		else
		    fill_rate = sclk / num_line_pair;

		/* Convert line buffer fill rate from period to frequency */
		fill_rate = 1 / fill_rate;
	    }
	}

	/* Determine the maximum priority mark
	   width = viewport width in pixels
	*/
	priority_mark_max = ceil(width/16);

	/* Determine estimated width */
	estimated_width = (tolerable_latency - worst_case_latency) / consumption_time;

	/* Determine priority mark based on active time */
	if (info->IsIGP) {
	    if (estimated_width > width)
		priority_mark = 10;
	    else
		priority_mark = priority_mark_max - ceil(estimated_width / 16);
	} else {
	    if (estimated_width > width)
		priority_mark = priority_mark_max;
	    else
		priority_mark = priority_mark_max - ceil(estimated_width / 16);
	}

	/* Determine priority mark 2 based on worst case latency,
	   consumption rate, fill rate and active time
	*/
	if (info->IsIGP) {
	    if (consumption_rate > fill_rate)
		priority_mark2 = ceil((worst_case_latency * consumption_rate + (consumption_rate - fill_rate) * active_time) / 1000 / 16);
	    else
		priority_mark2 = ceil(worst_case_latency * consumption_rate / 1000 / 16);
	} else {
	    if (consumption_rate > fill_rate)
		priority_mark2 = ceil(worst_case_latency * consumption_rate + (consumption_rate - fill_rate) * active_time / 16);
	    else
		priority_mark2 = ceil(worst_case_latency * consumption_rate / 16);
	}

	/* Determine final priority mark and clamp if necessary */
	priority_mark = max(priority_mark, priority_mark2);
	if (priority_mark < 0)
	    priority_mark = 0;
	else if (priority_mark > priority_mark_max)
	    priority_mark = priority_mark_max;

	priority_cnt = priority_mark & AVIVO_DxMODE_PRIORITY_MARK_MASK;

	if (info->DispPriority == 2)
	    priority_cnt |= AVIVO_DxMODE_PRIORITY_ALWAYS_ON;

	/*ErrorF("priority_mark %d: 0x%x\n", i, priority_mark);*/

	/* Determine which display to program priority mark for */
	/* FIXME: program DxMODE_PRIORITY_B_CNT for slower sclk */
	if (i == 0) {
	    OUTREG(AVIVO_D1MODE_PRIORITY_A_CNT, priority_cnt);
	    OUTREG(AVIVO_D1MODE_PRIORITY_B_CNT, priority_cnt);
	} else {
	    OUTREG(AVIVO_D2MODE_PRIORITY_A_CNT, priority_cnt);
	    OUTREG(AVIVO_D2MODE_PRIORITY_B_CNT, priority_cnt);
	}
    }
@


1.3
log
@Make it possible to build drivers with the newer proto headers. ok oga@@.
@
text
@d36 1
a36 1
#ifdef HAVE_X11_EXTENSIONS_DPMSCONST_H
d43 1
d175 1
a175 2
    case DPMSModeStandby:
    case DPMSModeSuspend:
a177 1
	atombios_enable_crtc(info->atomBIOS, radeon_crtc->crtc_id, 1);
d180 2
a183 1
	atombios_enable_crtc(info->atomBIOS, radeon_crtc->crtc_id, 0);
d186 1
d192 1
a192 1
atombios_set_crtc_timing(atomBiosHandlePtr atomBIOS, SET_CRTC_TIMING_PARAMETERS_PS_ALLOCATION *crtc_param)
d194 2
d198 21
a218 1
    SET_CRTC_TIMING_PARAMETERS_PS_ALLOCATION conv_param;
d220 8
a227 15
    conv_param.usH_Total		= cpu_to_le16(crtc_param->usH_Total);
    conv_param.usH_Disp			= cpu_to_le16(crtc_param->usH_Disp);
    conv_param.usH_SyncStart		= cpu_to_le16(crtc_param->usH_SyncStart);
    conv_param.usH_SyncWidth		= cpu_to_le16(crtc_param->usH_SyncWidth);
    conv_param.usV_Total		= cpu_to_le16(crtc_param->usV_Total);
    conv_param.usV_Disp			= cpu_to_le16(crtc_param->usV_Disp);
    conv_param.usV_SyncStart		= cpu_to_le16(crtc_param->usV_SyncStart);
    conv_param.usV_SyncWidth		= cpu_to_le16(crtc_param->usV_SyncWidth);
    conv_param.susModeMiscInfo.usAccess = cpu_to_le16(crtc_param->susModeMiscInfo.usAccess);
    conv_param.ucCRTC			= crtc_param->ucCRTC;
    conv_param.ucOverscanRight		= crtc_param->ucOverscanRight;
    conv_param.ucOverscanLeft		= crtc_param->ucOverscanLeft;
    conv_param.ucOverscanBottom		= crtc_param->ucOverscanBottom;
    conv_param.ucOverscanTop		= crtc_param->ucOverscanTop;
    conv_param.ucReserved		= crtc_param->ucReserved;
d231 1
a231 1
    data.exec.pspace = &conv_param;
d233 1
a233 1
    if (RHDAtomBiosFunc(atomBIOS->scrnIndex, atomBIOS, ATOMBIOS_EXEC, &data) == ATOM_SUCCESS) {
d243 1
a243 1
atombios_set_crtc_dtd_timing(atomBiosHandlePtr atomBIOS, SET_CRTC_USING_DTD_TIMING_PARAMETERS *crtc_param)
d245 2
d249 21
a269 1
    SET_CRTC_USING_DTD_TIMING_PARAMETERS conv_param;
d271 8
a278 10
    conv_param.usH_Size        = cpu_to_le16(crtc_param->usH_Size);
    conv_param.usH_Blanking_Time= cpu_to_le16(crtc_param->usH_Blanking_Time);
    conv_param.usV_Size        = cpu_to_le16(crtc_param->usV_Size);
    conv_param.usV_Blanking_Time= cpu_to_le16(crtc_param->usV_Blanking_Time);
    conv_param.usH_SyncOffset= cpu_to_le16(crtc_param->usH_SyncOffset);
    conv_param.usH_SyncWidth= cpu_to_le16(crtc_param->usH_SyncWidth);
    conv_param.usV_SyncOffset= cpu_to_le16(crtc_param->usV_SyncOffset);
    conv_param.usV_SyncWidth= cpu_to_le16(crtc_param->usV_SyncWidth);
    conv_param.susModeMiscInfo.usAccess = cpu_to_le16(crtc_param->susModeMiscInfo.usAccess);
    conv_param.ucCRTC= crtc_param->ucCRTC;
d282 1
a282 1
    data.exec.pspace = &conv_param;
d284 1
a284 1
    if (RHDAtomBiosFunc(atomBIOS->scrnIndex, atomBIOS, ATOMBIOS_EXEC, &data) == ATOM_SUCCESS) {
d293 63
a355 2
void
atombios_crtc_set_pll(xf86CrtcPtr crtc, DisplayModePtr mode)
d358 2
a359 1
    RADEONInfoPtr  info = RADEONPTR(crtc->scrn);
d361 1
a361 9
    unsigned char *RADEONMMIO = info->MMIO;
    int index = GetIndexIntoMasterTable(COMMAND, SetPixelClock);
    uint32_t sclock = mode->Clock;
    uint32_t ref_div = 0, fb_div = 0, post_div = 0;
    int major, minor, i;
    SET_PIXEL_CLOCK_PS_ALLOCATION spc_param;
    PIXEL_CLOCK_PARAMETERS_V2 *spc2_ptr;
    PIXEL_CLOCK_PARAMETERS_V3 *spc3_ptr;
    xf86OutputPtr output;
d364 1
d366 1
a366 1
    uint32_t temp;
d368 11
a378 3
    void *ptr;
    AtomBiosArgRec data;
    unsigned char *space;
a379 1
    memset(&spc_param, 0, sizeof(spc_param));
d381 6
a386 1
	if (IS_DCE3_VARIANT && mode->Clock > 200000) /* range limits??? */
a389 9

	/* disable spread spectrum clocking for now -- thanks Hedy Lamarr */
	if (radeon_crtc->crtc_id == 0) {
	    temp = INREG(AVIVO_P1PLL_INT_SS_CNTL);
	    OUTREG(AVIVO_P1PLL_INT_SS_CNTL, temp & ~1);
	} else {
	    temp = INREG(AVIVO_P2PLL_INT_SS_CNTL);
	    OUTREG(AVIVO_P2PLL_INT_SS_CNTL, temp & ~1);
	}
d393 23
a415 5
	for (i = 0; i < xf86_config->num_output; i++) {
	    xf86OutputPtr output = xf86_config->output[i];
	    RADEONOutputPrivatePtr radeon_output = output->driver_private;

	    if (output->crtc == crtc) {
d422 2
d425 9
d435 59
a493 4
	if (mode->Clock > 200000) /* range limits??? */
	    pll_flags |= RADEON_PLL_PREFER_HIGH_FB_DIV;
	else
	    pll_flags |= RADEON_PLL_PREFER_LOW_REF_DIV;
d495 12
d508 13
a520 2
    RADEONComputePLL(&info->pll, mode->Clock, &temp, &fb_div, &ref_div, &post_div, pll_flags);
    sclock = temp;
d522 1
a522 6
    xf86DrvMsg(crtc->scrn->scrnIndex, X_INFO,
	       "crtc(%d) Clock: mode %d, PLL %lu\n",
	       radeon_crtc->crtc_id, mode->Clock, (long unsigned int)sclock * 10);
    xf86DrvMsg(crtc->scrn->scrnIndex, X_INFO,
	       "crtc(%d) PLL  : refdiv %u, fbdiv 0x%X(%u), pdiv %u\n",
	       radeon_crtc->crtc_id, (unsigned int)ref_div, (unsigned int)fb_div, (unsigned int)fb_div, (unsigned int)post_div);
a523 1
    /* Can't really do cloning easily on DCE3 cards */
d543 1
d550 5
a554 24
	case 1:
	case 2:
	    spc2_ptr = (PIXEL_CLOCK_PARAMETERS_V2*)&spc_param.sPCLKInput;
	    spc2_ptr->usPixelClock = cpu_to_le16(sclock);
	    spc2_ptr->usRefDiv = cpu_to_le16(ref_div);
	    spc2_ptr->usFbDiv = cpu_to_le16(fb_div);
	    spc2_ptr->ucPostDiv = post_div;
	    spc2_ptr->ucPpll = radeon_crtc->crtc_id ? ATOM_PPLL2 : ATOM_PPLL1;
	    spc2_ptr->ucCRTC = radeon_crtc->crtc_id;
	    spc2_ptr->ucRefDivSrc = 1;
	    ptr = &spc_param;
	    break;
	case 3:
	    spc3_ptr = (PIXEL_CLOCK_PARAMETERS_V3*)&spc_param.sPCLKInput;
	    spc3_ptr->usPixelClock = cpu_to_le16(sclock);
	    spc3_ptr->usRefDiv = cpu_to_le16(ref_div);
	    spc3_ptr->usFbDiv = cpu_to_le16(fb_div);
	    spc3_ptr->ucPostDiv = post_div;
	    spc3_ptr->ucPpll = radeon_crtc->crtc_id ? ATOM_PPLL2 : ATOM_PPLL1;
	    spc3_ptr->ucMiscInfo = (radeon_crtc->crtc_id << 2);
	    spc3_ptr->ucTransmitterId = radeon_encoder->encoder_id;
	    spc3_ptr->ucEncoderMode = atombios_get_encoder_mode(output);

	    ptr = &spc_param;
d566 1
a566 1
    data.exec.index = GetIndexIntoMasterTable(COMMAND, SetPixelClock);
d568 1
a568 1
    data.exec.pspace = ptr;
d571 1
a571 1
	ErrorF("Set CRTC %d PLL success\n", radeon_crtc->crtc_id);
d575 1
a575 1
    ErrorF("Set CRTC %d PLL failed\n", radeon_crtc->crtc_id);
d579 2
a580 5
void
atombios_crtc_mode_set(xf86CrtcPtr crtc,
		       DisplayModePtr mode,
		       DisplayModePtr adjusted_mode,
		       int x, int y)
d582 1
a583 1
    RADEONCrtcPrivatePtr radeon_crtc = crtc->driver_private;
a584 1
    xf86CrtcConfigPtr   xf86_config = XF86_CRTC_CONFIG_PTR(pScrn);
d586 15
a600 8
    unsigned long fb_location = crtc->scrn->fbOffset + info->fbLocation;
    int need_tv_timings = 0;
    int i, ret;
    SET_CRTC_TIMING_PARAMETERS_PS_ALLOCATION crtc_timing;
    SET_CRTC_USING_DTD_TIMING_PARAMETERS crtc_dtd_timing;
    Bool tilingChanged = FALSE;
    memset(&crtc_timing, 0, sizeof(crtc_timing));
    memset(&crtc_dtd_timing, 0, sizeof(crtc_dtd_timing));
d602 20
a621 3
    if (info->allowColorTiling) {
        radeon_crtc->can_tile = (adjusted_mode->Flags & (V_DBLSCAN | V_INTERLACE)) ? FALSE : TRUE;
	tilingChanged = RADEONSetTiling(pScrn);
d624 6
a629 14
    for (i = 0; i < xf86_config->num_output; i++) {
	xf86OutputPtr output = xf86_config->output[i];
	RADEONOutputPrivatePtr radeon_output = output->driver_private;
	radeon_tvout_ptr tvout = &radeon_output->tvout;

	if (output->crtc == crtc) {
	    if (radeon_output->MonType == MT_STV || radeon_output->MonType == MT_CTV) {
		if (tvout->tvStd == TV_STD_NTSC ||
		    tvout->tvStd == TV_STD_NTSC_J ||
		    tvout->tvStd == TV_STD_PAL_M)
		    need_tv_timings = 1;
		else
		    need_tv_timings = 2;

a631 1
    }
d633 7
a639 5
    crtc_timing.ucCRTC = radeon_crtc->crtc_id;
    if (need_tv_timings) {
	ret = RADEONATOMGetTVTimings(pScrn, need_tv_timings - 1, &crtc_timing, &adjusted_mode->Clock);
	if (ret == FALSE) {
	    need_tv_timings = 0;
d643 1
a643 5
    if (!need_tv_timings) {
	crtc_timing.usH_Total = adjusted_mode->CrtcHTotal;
	crtc_timing.usH_Disp = adjusted_mode->CrtcHDisplay;
	crtc_timing.usH_SyncStart = adjusted_mode->CrtcHSyncStart;
	crtc_timing.usH_SyncWidth = adjusted_mode->CrtcHSyncEnd - adjusted_mode->CrtcHSyncStart;
d645 3
a647 4
	crtc_timing.usV_Total = adjusted_mode->CrtcVTotal;
	crtc_timing.usV_Disp = adjusted_mode->CrtcVDisplay;
	crtc_timing.usV_SyncStart = adjusted_mode->CrtcVSyncStart;
	crtc_timing.usV_SyncWidth = adjusted_mode->CrtcVSyncEnd - adjusted_mode->CrtcVSyncStart;
d649 7
a655 2
	if (adjusted_mode->Flags & V_NVSYNC)
	    crtc_timing.susModeMiscInfo.usAccess |= ATOM_VSYNC_POLARITY;
d657 2
a658 2
	if (adjusted_mode->Flags & V_NHSYNC)
	    crtc_timing.susModeMiscInfo.usAccess |= ATOM_HSYNC_POLARITY;
d660 47
a706 2
	if (adjusted_mode->Flags & V_CSYNC)
	    crtc_timing.susModeMiscInfo.usAccess |= ATOM_COMPOSITESYNC;
d708 3
a710 2
	if (adjusted_mode->Flags & V_INTERLACE)
	    crtc_timing.susModeMiscInfo.usAccess |= ATOM_INTERLACE;
d712 4
a715 2
	if (adjusted_mode->Flags & V_DBLSCAN)
	    crtc_timing.susModeMiscInfo.usAccess |= ATOM_DOUBLE_CLOCK_MODE;
d717 3
a719 14
	if (!IS_AVIVO_VARIANT && (radeon_crtc->crtc_id == 0)) {
	    crtc_dtd_timing.ucCRTC = radeon_crtc->crtc_id;
	    crtc_dtd_timing.usH_Size = adjusted_mode->CrtcHDisplay;
	    crtc_dtd_timing.usV_Size = adjusted_mode->CrtcVDisplay;
	    crtc_dtd_timing.usH_Blanking_Time = adjusted_mode->CrtcHBlankEnd - adjusted_mode->CrtcHDisplay;
	    crtc_dtd_timing.usV_Blanking_Time = adjusted_mode->CrtcVBlankEnd - adjusted_mode->CrtcVDisplay;
	    crtc_dtd_timing.usH_SyncOffset = adjusted_mode->CrtcHSyncStart - adjusted_mode->CrtcHDisplay;
	    crtc_dtd_timing.usV_SyncOffset = adjusted_mode->CrtcVSyncStart - adjusted_mode->CrtcVDisplay;
	    crtc_dtd_timing.usH_SyncWidth = adjusted_mode->CrtcHSyncEnd - adjusted_mode->CrtcHSyncStart;
	    crtc_dtd_timing.usV_SyncWidth = adjusted_mode->CrtcVSyncEnd - adjusted_mode->CrtcVSyncStart;
	    ErrorF("%d %d %d %d %d %d %d %d\n", crtc_dtd_timing.usH_Size, crtc_dtd_timing.usH_SyncOffset,
		   crtc_dtd_timing.usH_SyncWidth, crtc_dtd_timing.usH_Blanking_Time,
		   crtc_dtd_timing.usV_Size, crtc_dtd_timing.usV_SyncOffset,
		   crtc_dtd_timing.usV_SyncWidth, crtc_dtd_timing.usV_Blanking_Time);
d721 36
a756 2
	    if (adjusted_mode->Flags & V_NVSYNC)
		crtc_dtd_timing.susModeMiscInfo.usAccess |= ATOM_VSYNC_POLARITY;
d758 21
a778 2
	    if (adjusted_mode->Flags & V_NHSYNC)
		crtc_dtd_timing.susModeMiscInfo.usAccess |= ATOM_HSYNC_POLARITY;
d780 7
a786 9
	    if (adjusted_mode->Flags & V_CSYNC)
		crtc_dtd_timing.susModeMiscInfo.usAccess |= ATOM_COMPOSITESYNC;

	    if (adjusted_mode->Flags & V_INTERLACE)
		crtc_dtd_timing.susModeMiscInfo.usAccess |= ATOM_INTERLACE;

	    if (adjusted_mode->Flags & V_DBLSCAN)
		crtc_dtd_timing.susModeMiscInfo.usAccess |= ATOM_DOUBLE_CLOCK_MODE;
	}
a788 2
    ErrorF("Mode %dx%d - %d %d %d\n", adjusted_mode->CrtcHDisplay, adjusted_mode->CrtcVDisplay,
	   adjusted_mode->CrtcHTotal, adjusted_mode->CrtcVTotal, adjusted_mode->Flags);
d790 31
a820 2
    RADEONInitMemMapRegisters(pScrn, info->ModeReg, info);
    RADEONRestoreMemMapRegisters(pScrn, info->ModeReg);
d822 1
a822 4
    atombios_crtc_set_pll(crtc, adjusted_mode);
    atombios_set_crtc_timing(info->atomBIOS, &crtc_timing);
    if (!IS_AVIVO_VARIANT && (radeon_crtc->crtc_id == 0))
	atombios_set_crtc_dtd_timing(info->atomBIOS, &crtc_dtd_timing);
d824 11
a834 2
    if (IS_AVIVO_VARIANT) {
	uint32_t fb_format;
d836 1
a836 1
	uint32_t fb_swap = R600_D1GRPH_SWAP_ENDIAN_NONE;
d839 6
a844 6
	switch (crtc->scrn->bitsPerPixel) {
	case 15:
	    fb_format = AVIVO_D1GRPH_CONTROL_DEPTH_16BPP | AVIVO_D1GRPH_CONTROL_16BPP_ARGB1555;
	    break;
	case 16:
	    fb_format = AVIVO_D1GRPH_CONTROL_DEPTH_16BPP | AVIVO_D1GRPH_CONTROL_16BPP_RGB565;
d846 1
a846 1
	    fb_swap = R600_D1GRPH_SWAP_ENDIAN_16BIT;
d848 4
a851 4
	    break;
	case 24:
	case 32:
	    fb_format = AVIVO_D1GRPH_CONTROL_DEPTH_32BPP | AVIVO_D1GRPH_CONTROL_32BPP_ARGB8888;
d853 1
a853 1
	    fb_swap = R600_D1GRPH_SWAP_ENDIAN_32BIT;
d855 8
a862 4
	    break;
	default:
	    FatalError("Unsupported screen depth: %d\n", xf86GetDepth());
	}
d864 4
a867 3
	if (info->tilingEnabled && (crtc->rotatedData == NULL)) {
	    fb_format |= AVIVO_D1GRPH_MACRO_ADDRESS_MODE;
	}
d869 8
a876 4
	if (radeon_crtc->crtc_id == 0)
	    OUTREG(AVIVO_D1VGA_CONTROL, 0);
	else
	    OUTREG(AVIVO_D2VGA_CONTROL, 0);
d878 7
a884 7
	/* setup fb format and location
	 */
	if (crtc->rotatedData != NULL) {
	    /* x/y offset is already included */
	    x = 0;
	    y = 0;
	    fb_location = fb_location + (char *)crtc->rotatedData - (char *)info->FB;
d886 6
a891 4

	OUTREG(AVIVO_D1GRPH_PRIMARY_SURFACE_ADDRESS + radeon_crtc->crtc_offset, fb_location);
	OUTREG(AVIVO_D1GRPH_SECONDARY_SURFACE_ADDRESS + radeon_crtc->crtc_offset, fb_location);
	OUTREG(AVIVO_D1GRPH_CONTROL + radeon_crtc->crtc_offset, fb_format);
d894 2
a895 2
	if (info->ChipFamily >= CHIP_FAMILY_R600)
	    OUTREG(R600_D1GRPH_SWAP_CONTROL + radeon_crtc->crtc_offset, fb_swap);
d898 23
a920 26
	OUTREG(AVIVO_D1GRPH_SURFACE_OFFSET_X + radeon_crtc->crtc_offset, 0);
	OUTREG(AVIVO_D1GRPH_SURFACE_OFFSET_Y + radeon_crtc->crtc_offset, 0);
	OUTREG(AVIVO_D1GRPH_X_START + radeon_crtc->crtc_offset, 0);
	OUTREG(AVIVO_D1GRPH_Y_START + radeon_crtc->crtc_offset, 0);
	OUTREG(AVIVO_D1GRPH_X_END + radeon_crtc->crtc_offset, info->virtualX);
	OUTREG(AVIVO_D1GRPH_Y_END + radeon_crtc->crtc_offset, info->virtualY);
	OUTREG(AVIVO_D1GRPH_PITCH + radeon_crtc->crtc_offset,
	       crtc->scrn->displayWidth);
	OUTREG(AVIVO_D1GRPH_ENABLE + radeon_crtc->crtc_offset, 1);

	OUTREG(AVIVO_D1MODE_DESKTOP_HEIGHT + radeon_crtc->crtc_offset, mode->VDisplay);
	x &= ~3;
	y &= ~1;
	OUTREG(AVIVO_D1MODE_VIEWPORT_START + radeon_crtc->crtc_offset, (x << 16) | y);
	OUTREG(AVIVO_D1MODE_VIEWPORT_SIZE + radeon_crtc->crtc_offset,
	       (mode->HDisplay << 16) | mode->VDisplay);

	if (adjusted_mode->Flags & V_INTERLACE)
	    OUTREG(AVIVO_D1MODE_DATA_FORMAT + radeon_crtc->crtc_offset,
		   AVIVO_D1MODE_INTERLEAVE_EN);
	else
	    OUTREG(AVIVO_D1MODE_DATA_FORMAT + radeon_crtc->crtc_offset,
		   0);
    } else {
	int format = 0;
	uint32_t crtc_gen_cntl, crtc2_gen_cntl, crtc_pitch;
d922 11
d934 16
a949 17
	RADEONInitCommonRegisters(info->ModeReg, info);
	RADEONInitSurfaceCntl(crtc, info->ModeReg);
	ErrorF("restore common\n");
	RADEONRestoreCommonRegisters(pScrn, info->ModeReg);

	switch (info->CurrentLayout.pixel_code) {
	case 4:  format = 1; break;
	case 8:  format = 2; break;
	case 15: format = 3; break;      /*  555 */
	case 16: format = 4; break;      /*  565 */
	case 24: format = 5; break;      /*  RGB */
	case 32: format = 6; break;      /* xRGB */
	default:
	    xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
		       "Unsupported pixel depth (%d)\n",
		       info->CurrentLayout.bitsPerPixel);
	}
d951 2
a952 2
	crtc_pitch  = (((pScrn->displayWidth * pScrn->bitsPerPixel) +
			((pScrn->bitsPerPixel * 8) -1)) /
d954 1
a954 1
	crtc_pitch |= crtc_pitch << 16;
d956 54
a1009 21
	switch (radeon_crtc->crtc_id) {
	case 0:
	    ErrorF("init crtc1\n");
	    crtc_gen_cntl = INREG(RADEON_CRTC_GEN_CNTL) & 0xfffff0ff;
	    crtc_gen_cntl |= (format << 8);
	    OUTREG(RADEON_CRTC_GEN_CNTL, crtc_gen_cntl);
	    OUTREG(RADEON_CRTC_PITCH, crtc_pitch);
	    RADEONInitCrtcBase(crtc, info->ModeReg, x, y);
	    RADEONRestoreCrtcBase(pScrn, info->ModeReg);
	    break;
	case 1:
	    crtc2_gen_cntl = INREG(RADEON_CRTC2_GEN_CNTL) & 0xfffff0ff;
	    crtc2_gen_cntl |= (format << 8);
	    OUTREG(RADEON_CRTC2_GEN_CNTL, crtc2_gen_cntl);
	    OUTREG(RADEON_CRTC2_PITCH, crtc_pitch);
	    RADEONInitCrtc2Base(crtc, info->ModeReg, x, y);
	    RADEONRestoreCrtc2Base(pScrn, info->ModeReg);
	    OUTREG(RADEON_FP_H2_SYNC_STRT_WID,   INREG(RADEON_CRTC2_H_SYNC_STRT_WID));
	    OUTREG(RADEON_FP_V2_SYNC_STRT_WID,   INREG(RADEON_CRTC2_V_SYNC_STRT_WID));
	    break;
	}
d1012 7
d1048 4
a1051 3
    float mem_bw, peak_disp_bw;
    float min_mem_eff = 0.8; /* XXX: taken from legacy method */
    float pix_clk, pix_clk2; /* in MHz */
d1062 2
a1063 1
	else if (info->ChipFamily == CHIP_FAMILY_RS690)
d1076 2
a1077 1
	else if (info->ChipFamily == CHIP_FAMILY_RS690)
a1080 23
    /* XXX: fix me for AVIVO
     * Determine if there is enough bandwidth for current display mode
     */
    mem_bw = info->mclk * (info->RamWidth / 8) * (info->IsDDR ? 2 : 1);

    pix_clk = 0;
    pix_clk2 = 0;
    peak_disp_bw = 0;
    if (mode1) {
	pix_clk = mode1->Clock/1000.0;
	peak_disp_bw += (pix_clk * pixel_bytes1);
    }
    if (mode2) {
	pix_clk2 = mode2->Clock/1000.0;
	peak_disp_bw += (pix_clk2 * pixel_bytes2);
    }

    if (peak_disp_bw >= mem_bw * min_mem_eff) {
	xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
		   "You may not have enough display bandwidth for current mode\n"
		   "If you have flickering problem, try to lower resolution, refresh rate, or color depth\n");
    }

a1095 1
    /* is auto or manual better ? */
a1097 1
#if 1
d1117 2
a1118 1
#else
d1131 42
a1172 5
    /*
     * Watermark setup
     * TODO...
     * Unforunately, I haven't been able to dig up the avivo watermark programming
     * guide yet. -AGD
d1174 366
@


1.2
log
@update do xf86-video-ati 6.12.2

This has been in snapshots for weeks. ok oga@@, todd@@.
@
text
@d36 3
d41 1
@


1.1
log
@Long awaited update of xf86-video-ati to 6.9.0.

the rage128 and mach64 drivers were split out of this driver just after
the 6.8.0 release, these drivers will be commited separately.

MergedFb mode is gone, so please use xrandr if you used to use it.

ok matthieu@@.
@
text
@d1 1
a1 1
 /*
d46 1
a46 2
#include "radeon_dri.h"
#include "radeon_sarea.h"
d50 43
d150 1
a150 1
    data.exec.index = offsetof(ATOM_MASTER_LIST_OF_COMMAND_TABLES, BlankCRTC) / sizeof(unsigned short);
d191 17
d211 1
a211 1
    data.exec.pspace = crtc_param;
d222 31
d254 1
a254 1
atombios_crtc_set_pll(xf86CrtcPtr crtc, DisplayModePtr mode, int pll_flags)
d269 3
a275 1
    RADEONSavePtr save = info->ModeReg;
d277 1
d279 4
a282 6
	uint32_t temp;

	pll_flags |= RADEON_PLL_PREFER_LOW_REF_DIV;

	RADEONComputePLL(&info->pll, mode->Clock, &temp, &fb_div, &ref_div, &post_div, pll_flags);
	sclock = temp;
d293 19
a311 4
	sclock = save->dot_clock_freq;
	fb_div = save->feedback_div;
	post_div = save->post_div;
	ref_div = save->ppll_ref_div;
d314 3
d329 1
d339 5
d353 3
a355 3
	    spc2_ptr->usPixelClock = sclock;
	    spc2_ptr->usRefDiv = ref_div;
	    spc2_ptr->usFbDiv = fb_div;
d364 3
a366 3
	    spc3_ptr->usPixelClock = sclock;
	    spc3_ptr->usRefDiv = ref_div;
	    spc3_ptr->usFbDiv = fb_div;
d370 2
a371 37

	    if (radeon_output->MonType == MT_CRT) {
		if (radeon_output->DACType == DAC_PRIMARY)
		    spc3_ptr->ucTransmitterId = ENCODER_OBJECT_ID_INTERNAL_KLDSCP_DAC1;
		else if (radeon_output->DACType == DAC_TVDAC)
		    spc3_ptr->ucTransmitterId = ENCODER_OBJECT_ID_INTERNAL_KLDSCP_DAC2;
		spc3_ptr->ucEncoderMode = ATOM_ENCODER_MODE_CRT;
	    } else if (radeon_output->MonType == MT_DFP) {
		if (radeon_output->devices & ATOM_DEVICE_DFP1_SUPPORT)
		    spc3_ptr->ucTransmitterId = ENCODER_OBJECT_ID_INTERNAL_UNIPHY;
		else if (radeon_output->devices & ATOM_DEVICE_DFP2_SUPPORT)
		    spc3_ptr->ucTransmitterId = ENCODER_OBJECT_ID_INTERNAL_KLDSCP_DVO1;
		else if (radeon_output->devices & ATOM_DEVICE_DFP3_SUPPORT)
		    spc3_ptr->ucTransmitterId = ENCODER_OBJECT_ID_INTERNAL_KLDSCP_LVTMA;
		if (OUTPUT_IS_DVI)
		    spc3_ptr->ucEncoderMode = ATOM_ENCODER_MODE_DVI;
		else if (radeon_output->type == OUTPUT_HDMI)
		    spc3_ptr->ucEncoderMode = ATOM_ENCODER_MODE_HDMI;
		else if (radeon_output->type == OUTPUT_DP)
		    spc3_ptr->ucEncoderMode = ATOM_ENCODER_MODE_DP;
	    } else if (radeon_output->MonType == MT_LCD) {
		if (radeon_output->devices & ATOM_DEVICE_LCD1_SUPPORT)
		    spc3_ptr->ucTransmitterId = ENCODER_OBJECT_ID_INTERNAL_KLDSCP_LVTMA;
		spc3_ptr->ucEncoderMode = ATOM_ENCODER_MODE_LVDS;
	    } else if (OUTPUT_IS_TV) {
		if (radeon_output->DACType == DAC_PRIMARY)
		    spc3_ptr->ucTransmitterId = ENCODER_OBJECT_ID_INTERNAL_KLDSCP_DAC1;
		else if (radeon_output->DACType == DAC_TVDAC)
		    spc3_ptr->ucTransmitterId = ENCODER_OBJECT_ID_INTERNAL_KLDSCP_DAC2;
		spc3_ptr->ucEncoderMode = ATOM_ENCODER_MODE_TV;
	    } else if (radeon_output->MonType == MT_CV) {
		if (radeon_output->DACType == DAC_PRIMARY)
		    spc3_ptr->ucTransmitterId = ENCODER_OBJECT_ID_INTERNAL_KLDSCP_DAC1;
		else if (radeon_output->DACType == DAC_TVDAC)
		    spc3_ptr->ucTransmitterId = ENCODER_OBJECT_ID_INTERNAL_KLDSCP_DAC2;
		spc3_ptr->ucEncoderMode = ATOM_ENCODER_MODE_CV;
	    }
d390 1
a390 1
	ErrorF("Set CRTC PLL success\n");
d394 1
a394 1
    ErrorF("Set CRTC PLL failed\n");
d413 1
a414 1
    int pll_flags = 0;
d416 1
d426 1
d430 3
a432 3
		if (radeon_output->tvStd == TV_STD_NTSC ||
		    radeon_output->tvStd == TV_STD_NTSC_J ||
		    radeon_output->tvStd == TV_STD_PAL_M)
a437 3

	    if (radeon_output->MonType == MT_LCD)
	      pll_flags |= RADEON_PLL_USE_REF_DIV;
a445 5
	} else {
	    adjusted_mode->CrtcHDisplay = crtc_timing.usH_Disp;
	    adjusted_mode->CrtcHTotal = crtc_timing.usH_Total;
	    adjusted_mode->CrtcVDisplay = crtc_timing.usV_Disp;
	    adjusted_mode->CrtcVTotal = crtc_timing.usV_Total;
d475 30
d513 5
d520 3
d530 3
d537 3
a562 3
	/* lock the grph regs */
	OUTREG(AVIVO_D1GRPH_UPDATE + radeon_crtc->crtc_offset, AVIVO_D1GRPH_UPDATE_LOCK);

d567 5
d574 4
a577 4
	OUTREG(AVIVO_D1GRPH_X_START + radeon_crtc->crtc_offset, x);
	OUTREG(AVIVO_D1GRPH_Y_START + radeon_crtc->crtc_offset, y);
	OUTREG(AVIVO_D1GRPH_X_END + radeon_crtc->crtc_offset, x + mode->HDisplay);
	OUTREG(AVIVO_D1GRPH_Y_END + radeon_crtc->crtc_offset, y + mode->VDisplay);
d582 3
a584 8
	/* unlock the grph regs */
	OUTREG(AVIVO_D1GRPH_UPDATE + radeon_crtc->crtc_offset, 0);

	/* lock the mode regs */
	OUTREG(AVIVO_D1SCL_UPDATE + radeon_crtc->crtc_offset, AVIVO_D1SCL_UPDATE_LOCK);

	OUTREG(AVIVO_D1MODE_DESKTOP_HEIGHT + radeon_crtc->crtc_offset,
	       		mode->VDisplay);
a587 2
	/* unlock the mode regs */
	OUTREG(AVIVO_D1SCL_UPDATE + radeon_crtc->crtc_offset, 0);
d589 55
d646 2
a647 1
    atombios_crtc_set_pll(crtc, adjusted_mode, pll_flags);
d649 1
a649 1
    atombios_set_crtc_timing(info->atomBIOS, &crtc_timing);
d664 123
@

