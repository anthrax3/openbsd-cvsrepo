head	1.8;
access;
symbols
	OPENBSD_5_4:1.7.0.4
	OPENBSD_5_4_BASE:1.7
	OPENBSD_5_3:1.7.0.2
	OPENBSD_5_3_BASE:1.7
	OPENBSD_5_2:1.6.0.2
	OPENBSD_5_2_BASE:1.6
	OPENBSD_5_1_BASE:1.5
	OPENBSD_5_1:1.5.0.2
	OPENBSD_5_0:1.3.0.8
	OPENBSD_5_0_BASE:1.3
	OPENBSD_4_9:1.3.0.4
	OPENBSD_4_9_BASE:1.3
	OPENBSD_4_8:1.3.0.6
	OPENBSD_4_8_BASE:1.3
	OPENBSD_4_7:1.3.0.2
	OPENBSD_4_7_BASE:1.3
	OPENBSD_4_6:1.2.0.6
	OPENBSD_4_6_BASE:1.2
	OPENBSD_4_5:1.2.0.4
	OPENBSD_4_5_BASE:1.2
	OPENBSD_4_4:1.2.0.2
	OPENBSD_4_4_BASE:1.2
	OPENBSD_4_3_BASE:1.1.1.1
	OPENBSD_4_3:1.1.1.1.0.4
	OPENBSD_4_2:1.1.1.1.0.2
	OPENBSD_4_2_BASE:1.1.1.1
	v6_6_3:1.1.1.1
	xorg:1.1.1;
locks; strict;
comment	@ * @;


1.8
date	2013.08.16.17.04.08;	author matthieu;	state dead;
branches;
next	1.7;

1.7
date	2012.08.08.16.25.22;	author matthieu;	state Exp;
branches;
next	1.6;

1.6
date	2012.03.04.16.01.20;	author matthieu;	state Exp;
branches;
next	1.5;

1.5
date	2012.02.06.22.53.12;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2012.01.25.21.33.35;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2009.08.25.18.51.45;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2008.07.12.15.18.34;	author oga;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.26.20.01.03;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.11.26.20.01.03;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.8
log
@Update to xf86-video-ati 7.2.0, requested by jsg@@

It fixes an endianess problem with kms and the in tree x86-video-ati
among other things.
It has been tested on various i386/amd64/sparc64/macppc machines
on a range of hardware from r100->northern islands.
@
text
@/*
 * Copyright 2004 ATI Technologies Inc., Markham, Ontario
 *
 * All Rights Reserved.
 *
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation on the rights to use, copy, modify, merge,
 * publish, distribute, sublicense, and/or sell copies of the Software,
 * and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice (including the
 * next paragraph) shall be included in all copies or substantial
 * portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NON-INFRINGEMENT.  IN NO EVENT SHALL ATI, VA LINUX SYSTEMS AND/OR
 * THEIR SUPPLIERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
 * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 */

#ifdef HAVE_CONFIG_H
#include "config.h"
#endif

#include <string.h>

#include "xf86.h"
#include "xf86_OSproc.h"

#include "atipciids.h"
#include "radeon.h"
#include "radeon_reg.h"
#include "radeon_macros.h"
#include "radeon_probe.h"
#include "radeon_atombios.h"

typedef enum
{
    DDC_NONE_DETECTED,
    DDC_MONID,
    DDC_DVI,
    DDC_VGA,
    DDC_CRT2,
    DDC_LCD,
    DDC_GPIO,
} RADEONLegacyDDCType;

typedef enum
{
    CONNECTOR_NONE_LEGACY,
    CONNECTOR_PROPRIETARY_LEGACY,
    CONNECTOR_CRT_LEGACY,
    CONNECTOR_DVI_I_LEGACY,
    CONNECTOR_DVI_D_LEGACY,
    CONNECTOR_CTV_LEGACY,
    CONNECTOR_STV_LEGACY,
    CONNECTOR_UNSUPPORTED_LEGACY
} RADEONLegacyConnectorType;

static Bool
radeon_read_bios(ScrnInfoPtr pScrn)
{
    RADEONInfoPtr info     = RADEONPTR(pScrn);

#ifdef XSERVER_LIBPCIACCESS
    if (pci_device_read_rom(info->PciInfo, info->VBIOS)) {
	xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
		   "Failed to read PCI ROM!\n");
	return FALSE;
    }
#else
    xf86ReadPciBIOS(0, info->PciTag, 0, info->VBIOS, RADEON_VBIOS_SIZE);
    if (info->VBIOS[0] != 0x55 || info->VBIOS[1] != 0xaa) {
	xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
		   "Video BIOS not detected in PCI space!\n");
	if (xf86IsEntityPrimary(info->pEnt->index)) {
	    xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
		       "Attempting to read Video BIOS from "
		       "legacy ISA space!\n");
	    info->BIOSAddr = 0x000c0000;
	    xf86ReadDomainMemory(info->PciTag, info->BIOSAddr,
				 RADEON_VBIOS_SIZE, info->VBIOS);
	}
    }
#endif
    if (info->VBIOS[0] != 0x55 || info->VBIOS[1] != 0xaa)
	return FALSE;
    else
	return TRUE;
}

static Bool
radeon_read_disabled_bios(ScrnInfoPtr pScrn)
{
    RADEONInfoPtr info     = RADEONPTR(pScrn);
    RADEONEntPtr pRADEONEnt = RADEONEntPriv(pScrn);
    unsigned char *RADEONMMIO = info->MMIO;
    Bool ret;

    xf86DrvMsg(pScrn->scrnIndex, X_INFO, "Attempting to read un-POSTed bios\n");

    if (info->ChipFamily >= CHIP_FAMILY_RV770) {
	uint32_t viph_control   = INREG(RADEON_VIPH_CONTROL);
	uint32_t bus_cntl       = INREG(RADEON_BUS_CNTL);
	uint32_t d1vga_control  = INREG(AVIVO_D1VGA_CONTROL);
	uint32_t d2vga_control  = INREG(AVIVO_D2VGA_CONTROL);
	uint32_t vga_render_control  = INREG(AVIVO_VGA_RENDER_CONTROL);
	uint32_t rom_cntl       = INREG(R600_ROM_CNTL);
	uint32_t cg_spll_func_cntl = 0;
	uint32_t cg_spll_status;

	/* disable VIP */
	OUTREG(RADEON_VIPH_CONTROL, (viph_control & ~RADEON_VIPH_EN));

	/* enable the rom */
	OUTREG(RADEON_BUS_CNTL, (bus_cntl & ~RADEON_BUS_BIOS_DIS_ROM));

	/* Disable VGA mode */
	OUTREG(AVIVO_D1VGA_CONTROL, (d1vga_control & ~(AVIVO_DVGA_CONTROL_MODE_ENABLE |
						       AVIVO_DVGA_CONTROL_TIMING_SELECT)));
	OUTREG(AVIVO_D2VGA_CONTROL, (d2vga_control & ~(AVIVO_DVGA_CONTROL_MODE_ENABLE |
						       AVIVO_DVGA_CONTROL_TIMING_SELECT)));
	OUTREG(AVIVO_VGA_RENDER_CONTROL, (vga_render_control & ~AVIVO_VGA_VSTATUS_CNTL_MASK));

	if (info->ChipFamily == CHIP_FAMILY_RV730) {
	    cg_spll_func_cntl = INREG(R600_CG_SPLL_FUNC_CNTL);

	    /* enable bypass mode */
	    OUTREG(R600_CG_SPLL_FUNC_CNTL, (cg_spll_func_cntl | R600_SPLL_BYPASS_EN));

	    /* wait for SPLL_CHG_STATUS to change to 1 */
	    cg_spll_status = 0;
	    while (!(cg_spll_status & R600_SPLL_CHG_STATUS))
		cg_spll_status = INREG(R600_CG_SPLL_STATUS);

	    OUTREG(R600_ROM_CNTL, (rom_cntl & ~R600_SCK_OVERWRITE));
	} else
	    OUTREG(R600_ROM_CNTL, (rom_cntl | R600_SCK_OVERWRITE));

	ret = radeon_read_bios(pScrn);

	/* restore regs */
	if (info->ChipFamily == CHIP_FAMILY_RV730) {
	    OUTREG(R600_CG_SPLL_FUNC_CNTL, cg_spll_func_cntl);

	    /* wait for SPLL_CHG_STATUS to change to 1 */
	    cg_spll_status = 0;
	    while (!(cg_spll_status & R600_SPLL_CHG_STATUS))
		cg_spll_status = INREG(R600_CG_SPLL_STATUS);
	}
	OUTREG(RADEON_VIPH_CONTROL, viph_control);
	OUTREG(RADEON_BUS_CNTL, bus_cntl);
	OUTREG(AVIVO_D1VGA_CONTROL, d1vga_control);
	OUTREG(AVIVO_D2VGA_CONTROL, d2vga_control);
	OUTREG(AVIVO_VGA_RENDER_CONTROL, vga_render_control);
	OUTREG(R600_ROM_CNTL, rom_cntl);
    } else if (info->ChipFamily >= CHIP_FAMILY_R600) {
	uint32_t viph_control   = INREG(RADEON_VIPH_CONTROL);
	uint32_t bus_cntl       = INREG(RADEON_BUS_CNTL);
	uint32_t d1vga_control  = INREG(AVIVO_D1VGA_CONTROL);
	uint32_t d2vga_control  = INREG(AVIVO_D2VGA_CONTROL);
	uint32_t vga_render_control  = INREG(AVIVO_VGA_RENDER_CONTROL);
	uint32_t rom_cntl       = INREG(R600_ROM_CNTL);
	uint32_t general_pwrmgt = INREG(R600_GENERAL_PWRMGT);
	uint32_t low_vid_lower_gpio_cntl    = INREG(R600_LOW_VID_LOWER_GPIO_CNTL);
	uint32_t medium_vid_lower_gpio_cntl = INREG(R600_MEDIUM_VID_LOWER_GPIO_CNTL);
	uint32_t high_vid_lower_gpio_cntl   = INREG(R600_HIGH_VID_LOWER_GPIO_CNTL);
	uint32_t ctxsw_vid_lower_gpio_cntl  = INREG(R600_CTXSW_VID_LOWER_GPIO_CNTL);
	uint32_t lower_gpio_enable          = INREG(R600_LOWER_GPIO_ENABLE);

	/* disable VIP */
	OUTREG(RADEON_VIPH_CONTROL, (viph_control & ~RADEON_VIPH_EN));

	/* enable the rom */
	OUTREG(RADEON_BUS_CNTL, (bus_cntl & ~RADEON_BUS_BIOS_DIS_ROM));

	/* Disable VGA mode */
	OUTREG(AVIVO_D1VGA_CONTROL, (d1vga_control & ~(AVIVO_DVGA_CONTROL_MODE_ENABLE |
						       AVIVO_DVGA_CONTROL_TIMING_SELECT)));
	OUTREG(AVIVO_D2VGA_CONTROL, (d2vga_control & ~(AVIVO_DVGA_CONTROL_MODE_ENABLE |
						       AVIVO_DVGA_CONTROL_TIMING_SELECT)));
	OUTREG(AVIVO_VGA_RENDER_CONTROL, (vga_render_control & ~AVIVO_VGA_VSTATUS_CNTL_MASK));

	OUTREG(R600_ROM_CNTL, ((rom_cntl & ~R600_SCK_PRESCALE_CRYSTAL_CLK_MASK) |
			       (1 << R600_SCK_PRESCALE_CRYSTAL_CLK_SHIFT) |
			       R600_SCK_OVERWRITE));

	OUTREG(R600_GENERAL_PWRMGT, (general_pwrmgt & ~R600_OPEN_DRAIN_PADS));

	OUTREG(R600_LOW_VID_LOWER_GPIO_CNTL, (low_vid_lower_gpio_cntl & ~0x400));

	OUTREG(R600_MEDIUM_VID_LOWER_GPIO_CNTL, (medium_vid_lower_gpio_cntl & ~0x400));

	OUTREG(R600_HIGH_VID_LOWER_GPIO_CNTL, (high_vid_lower_gpio_cntl & ~0x400));

	OUTREG(R600_CTXSW_VID_LOWER_GPIO_CNTL, (ctxsw_vid_lower_gpio_cntl & ~0x400));

	OUTREG(R600_LOWER_GPIO_ENABLE, (lower_gpio_enable | 0x400));

	ret = radeon_read_bios(pScrn);

	/* restore regs */
	OUTREG(RADEON_VIPH_CONTROL, viph_control);
	OUTREG(RADEON_BUS_CNTL, bus_cntl);
	OUTREG(AVIVO_D1VGA_CONTROL, d1vga_control);
	OUTREG(AVIVO_D2VGA_CONTROL, d2vga_control);
	OUTREG(AVIVO_VGA_RENDER_CONTROL, vga_render_control);
	OUTREG(R600_ROM_CNTL, rom_cntl);
	OUTREG(R600_GENERAL_PWRMGT, general_pwrmgt);
	OUTREG(R600_LOW_VID_LOWER_GPIO_CNTL, low_vid_lower_gpio_cntl);
	OUTREG(R600_MEDIUM_VID_LOWER_GPIO_CNTL, medium_vid_lower_gpio_cntl);
	OUTREG(R600_HIGH_VID_LOWER_GPIO_CNTL, high_vid_lower_gpio_cntl);
	OUTREG(R600_CTXSW_VID_LOWER_GPIO_CNTL, ctxsw_vid_lower_gpio_cntl);
	OUTREG(R600_LOWER_GPIO_ENABLE, lower_gpio_enable);

    } else if (info->ChipFamily >= CHIP_FAMILY_RV515) {
	uint32_t seprom_cntl1   = INREG(RADEON_SEPROM_CNTL1);
	uint32_t viph_control   = INREG(RADEON_VIPH_CONTROL);
	uint32_t bus_cntl       = INREG(RADEON_BUS_CNTL);
	uint32_t d1vga_control  = INREG(AVIVO_D1VGA_CONTROL);
	uint32_t d2vga_control  = INREG(AVIVO_D2VGA_CONTROL);
	uint32_t vga_render_control  = INREG(AVIVO_VGA_RENDER_CONTROL);
	uint32_t gpiopad_a      = INREG(RADEON_GPIOPAD_A);
	uint32_t gpiopad_en     = INREG(RADEON_GPIOPAD_EN);
	uint32_t gpiopad_mask   = INREG(RADEON_GPIOPAD_MASK);

	OUTREG(RADEON_SEPROM_CNTL1, ((seprom_cntl1 & ~RADEON_SCK_PRESCALE_MASK) |
				     (0xc << RADEON_SCK_PRESCALE_SHIFT)));

	OUTREG(RADEON_GPIOPAD_A, 0);
	OUTREG(RADEON_GPIOPAD_EN, 0);
	OUTREG(RADEON_GPIOPAD_MASK, 0);

	/* disable VIP */
	OUTREG(RADEON_VIPH_CONTROL, (viph_control & ~RADEON_VIPH_EN));

	/* enable the rom */
	OUTREG(RADEON_BUS_CNTL, (bus_cntl & ~RADEON_BUS_BIOS_DIS_ROM));

        /* Disable VGA mode */
	OUTREG(AVIVO_D1VGA_CONTROL, (d1vga_control & ~(AVIVO_DVGA_CONTROL_MODE_ENABLE |
						       AVIVO_DVGA_CONTROL_TIMING_SELECT)));
	OUTREG(AVIVO_D2VGA_CONTROL, (d2vga_control & ~(AVIVO_DVGA_CONTROL_MODE_ENABLE |
						       AVIVO_DVGA_CONTROL_TIMING_SELECT)));
	OUTREG(AVIVO_VGA_RENDER_CONTROL, (vga_render_control & ~AVIVO_VGA_VSTATUS_CNTL_MASK));

	ret = radeon_read_bios(pScrn);

	/* restore regs */
	OUTREG(RADEON_SEPROM_CNTL1, seprom_cntl1);
	OUTREG(RADEON_VIPH_CONTROL, viph_control);
	OUTREG(RADEON_BUS_CNTL, bus_cntl);
	OUTREG(AVIVO_D1VGA_CONTROL, d1vga_control);
	OUTREG(AVIVO_D2VGA_CONTROL, d2vga_control);
	OUTREG(AVIVO_VGA_RENDER_CONTROL, vga_render_control);
	OUTREG(RADEON_GPIOPAD_A, gpiopad_a);
	OUTREG(RADEON_GPIOPAD_EN, gpiopad_en);
	OUTREG(RADEON_GPIOPAD_MASK, gpiopad_mask);

    } else {
	uint32_t seprom_cntl1   = INREG(RADEON_SEPROM_CNTL1);
	uint32_t viph_control   = INREG(RADEON_VIPH_CONTROL);
	uint32_t bus_cntl       = INREG(RADEON_BUS_CNTL);
	uint32_t crtc_gen_cntl  = INREG(RADEON_CRTC_GEN_CNTL);
	uint32_t crtc2_gen_cntl = 0;
	uint32_t crtc_ext_cntl  = INREG(RADEON_CRTC_EXT_CNTL);
	uint32_t fp2_gen_cntl   = 0;

	if (PCI_DEV_DEVICE_ID(info->PciInfo) == PCI_CHIP_RV100_QY)
	    fp2_gen_cntl   = INREG(RADEON_FP2_GEN_CNTL);

	if (pRADEONEnt->HasCRTC2)
	    crtc2_gen_cntl = INREG(RADEON_CRTC2_GEN_CNTL);

	OUTREG(RADEON_SEPROM_CNTL1, ((seprom_cntl1 & ~RADEON_SCK_PRESCALE_MASK) |
				     (0xc << RADEON_SCK_PRESCALE_SHIFT)));

	/* disable VIP */
	OUTREG(RADEON_VIPH_CONTROL, (viph_control & ~RADEON_VIPH_EN));

	/* enable the rom */
	OUTREG(RADEON_BUS_CNTL, (bus_cntl & ~RADEON_BUS_BIOS_DIS_ROM));

        /* Turn off mem requests and CRTC for both controllers */
	OUTREG(RADEON_CRTC_GEN_CNTL, ((crtc_gen_cntl & ~RADEON_CRTC_EN) |
				      (RADEON_CRTC_DISP_REQ_EN_B |
				       RADEON_CRTC_EXT_DISP_EN)));
	if (pRADEONEnt->HasCRTC2)
	    OUTREG(RADEON_CRTC2_GEN_CNTL, ((crtc2_gen_cntl & ~RADEON_CRTC2_EN) |
					   RADEON_CRTC2_DISP_REQ_EN_B));

        /* Turn off CRTC */
	OUTREG(RADEON_CRTC_EXT_CNTL, ((crtc_ext_cntl & ~RADEON_CRTC_CRT_ON) |
				      (RADEON_CRTC_SYNC_TRISTAT |
				       RADEON_CRTC_DISPLAY_DIS)));

	if (PCI_DEV_DEVICE_ID(info->PciInfo) == PCI_CHIP_RV100_QY)
	    OUTREG(RADEON_FP2_GEN_CNTL, (fp2_gen_cntl & ~RADEON_FP2_ON));

	ret = radeon_read_bios(pScrn);

	/* restore regs */
	OUTREG(RADEON_SEPROM_CNTL1, seprom_cntl1);
	OUTREG(RADEON_VIPH_CONTROL, viph_control);
	OUTREG(RADEON_BUS_CNTL, bus_cntl);
	OUTREG(RADEON_CRTC_GEN_CNTL, crtc_gen_cntl);
	if (pRADEONEnt->HasCRTC2)
	    OUTREG(RADEON_CRTC2_GEN_CNTL, crtc2_gen_cntl);
	OUTREG(RADEON_CRTC_EXT_CNTL, crtc_ext_cntl);
	if (PCI_DEV_DEVICE_ID(info->PciInfo) == PCI_CHIP_RV100_QY)
	    OUTREG(RADEON_FP2_GEN_CNTL, fp2_gen_cntl);
    }
    return ret;
}

Bool
radeon_card_posted(ScrnInfoPtr pScrn)
{
    RADEONInfoPtr info     = RADEONPTR(pScrn);
    unsigned char *RADEONMMIO = info->MMIO;
    uint32_t reg;

    /* first check CRTCs */
    if (IS_AVIVO_VARIANT) {
	reg = INREG(AVIVO_D1CRTC_CONTROL) | INREG(AVIVO_D2CRTC_CONTROL);
	if (reg & AVIVO_CRTC_EN)
	    return TRUE;
    } else {
	reg = INREG(RADEON_CRTC_GEN_CNTL) | INREG(RADEON_CRTC2_GEN_CNTL);
	if (reg & RADEON_CRTC_EN)
	    return TRUE;
    }

    /* then check MEM_SIZE, in case something turned the crtcs off */
    if (info->ChipFamily >= CHIP_FAMILY_R600)
	reg = INREG(R600_CONFIG_MEMSIZE);
    else
	reg = INREG(RADEON_CONFIG_MEMSIZE);

    if (reg)
	return TRUE;

    return FALSE;
}

/* Read the Video BIOS block and the FP registers (if applicable). */
Bool
RADEONGetBIOSInfo(ScrnInfoPtr pScrn, xf86Int10InfoPtr  pInt10)
{
    RADEONInfoPtr info     = RADEONPTR(pScrn);
    int tmp;
    unsigned short dptr;

#ifdef XSERVER_LIBPCIACCESS
    int size = info->PciInfo->rom_size > RADEON_VBIOS_SIZE ? info->PciInfo->rom_size : RADEON_VBIOS_SIZE;
    info->VBIOS = malloc(size);
#else
    info->VBIOS = malloc(RADEON_VBIOS_SIZE);
#endif
    if (!info->VBIOS) {
	xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
		   "Cannot allocate space for hold Video BIOS!\n");
	return FALSE;
    } else {
	if (pInt10) {
	    info->BIOSAddr = pInt10->BIOSseg << 4;
	    (void)memcpy(info->VBIOS, xf86int10Addr(pInt10, info->BIOSAddr),
			 RADEON_VBIOS_SIZE);
	} else if (!radeon_read_bios(pScrn))
	    (void)radeon_read_disabled_bios(pScrn);
    }

    if (info->VBIOS[0] != 0x55 || info->VBIOS[1] != 0xaa) {
	xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
		   "Unrecognized BIOS signature, BIOS data will not be used\n");
	free (info->VBIOS);
	info->VBIOS = NULL;
	return FALSE;
    }

    /* Verify it's an x86 BIOS not OF firmware, copied from radeonfb */
    dptr = RADEON_BIOS16(0x18);
    /* If PCI data signature is wrong assume x86 video BIOS anyway */
    if (RADEON_BIOS32(dptr) != (('R' << 24) | ('I' << 16) | ('C' << 8) | 'P')) {
       xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
		   "ROM PCI data signature incorrect, ignoring\n");
    }
    else if (info->VBIOS[dptr + 0x14] != 0x0) {
	xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
		   "Not an x86 BIOS ROM image, BIOS data will not be used\n");
	free (info->VBIOS);
	info->VBIOS = NULL;
	return FALSE;
    }

    if (info->VBIOS) info->ROMHeaderStart = RADEON_BIOS16(0x48);

    if(!info->ROMHeaderStart) {
	xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
		   "Invalid ROM pointer, BIOS data will not be used\n");
	free (info->VBIOS);
	info->VBIOS = NULL;
	return FALSE;
    }

    tmp = info->ROMHeaderStart + 4;
    if ((RADEON_BIOS8(tmp)   == 'A' &&
	 RADEON_BIOS8(tmp+1) == 'T' &&
	 RADEON_BIOS8(tmp+2) == 'O' &&
	 RADEON_BIOS8(tmp+3) == 'M') ||
	(RADEON_BIOS8(tmp)   == 'M' &&
	 RADEON_BIOS8(tmp+1) == 'O' &&
	 RADEON_BIOS8(tmp+2) == 'T' &&
	 RADEON_BIOS8(tmp+3) == 'A'))
	info->IsAtomBios = TRUE;
    else
	info->IsAtomBios = FALSE;

    xf86DrvMsg(pScrn->scrnIndex, X_INFO, "%s BIOS detected\n",
	       info->IsAtomBios ? "ATOM":"Legacy");

    if (info->IsAtomBios) {
	AtomBiosArgRec atomBiosArg;

	if (RHDAtomBiosFunc(pScrn, NULL, ATOMBIOS_INIT, &atomBiosArg)
	    == ATOM_SUCCESS) {
	    info->atomBIOS = atomBiosArg.atomhandle;
	}

	atomBiosArg.fb.start = info->FbFreeStart;
	atomBiosArg.fb.size = info->FbFreeSize;
	if (RHDAtomBiosFunc(pScrn, info->atomBIOS, ATOMBIOS_ALLOCATE_FB_SCRATCH,
			    &atomBiosArg) == ATOM_SUCCESS) {

	    info->FbFreeStart = atomBiosArg.fb.start;
	    info->FbFreeSize = atomBiosArg.fb.size;
	}

	RHDAtomBiosFunc(pScrn, info->atomBIOS, GET_DEFAULT_ENGINE_CLOCK,
			&atomBiosArg);
	RHDAtomBiosFunc(pScrn, info->atomBIOS, GET_DEFAULT_MEMORY_CLOCK,
			&atomBiosArg);
	RHDAtomBiosFunc(pScrn, info->atomBIOS,
			GET_MAX_PIXEL_CLOCK_PLL_OUTPUT, &atomBiosArg);
	RHDAtomBiosFunc(pScrn, info->atomBIOS,
			GET_MIN_PIXEL_CLOCK_PLL_OUTPUT, &atomBiosArg);
	RHDAtomBiosFunc(pScrn, info->atomBIOS,
			GET_MAX_PIXEL_CLOCK_PLL_INPUT, &atomBiosArg);
	RHDAtomBiosFunc(pScrn, info->atomBIOS,
			GET_MIN_PIXEL_CLOCK_PLL_INPUT, &atomBiosArg);
	RHDAtomBiosFunc(pScrn, info->atomBIOS,
			GET_MAX_PIXEL_CLK, &atomBiosArg);
	RHDAtomBiosFunc(pScrn, info->atomBIOS,
			GET_REF_CLOCK, &atomBiosArg);

	info->MasterDataStart = RADEON_BIOS16 (info->ROMHeaderStart + 32);
    }

    /* We are a bit too quick at using this "unposted" to re-post the
     * card. This causes some problems with VT switch on some machines,
     * so let's work around this for now by only POSTing if none of the
     * CRTCs are enabled
     */
    if ((!radeon_card_posted(pScrn)) && info->VBIOS) {
	if (info->IsAtomBios) {
	    if (!rhdAtomASICInit(info->atomBIOS))
		xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
			   "%s: AsicInit failed.\n",__func__);
	} else {
#if 0
	    /* FIX ME */
	    xf86DrvMsg(pScrn->scrnIndex, X_INFO, "Attempting to POST via legacy BIOS tables\n");
	    RADEONGetBIOSInitTableOffsets(pScrn);
	    RADEONPostCardFromBIOSTables(pScrn);
#endif
	}
    }

    return TRUE;
}

static Bool RADEONGetATOMConnectorInfoFromBIOS (ScrnInfoPtr pScrn)
{
    RADEONInfoPtr info = RADEONPTR (pScrn);

    if (!info->VBIOS) return FALSE;

    if (RADEONGetATOMConnectorInfoFromBIOSObject(pScrn))
	return TRUE;

    if (RADEONGetATOMConnectorInfoFromBIOSConnectorTable(pScrn))
	return TRUE;

    return FALSE;
}

static void RADEONApplyLegacyQuirks(ScrnInfoPtr pScrn, int index)
{
    RADEONInfoPtr info = RADEONPTR (pScrn);

    /* XPRESS DDC quirks */
    if ((info->ChipFamily == CHIP_FAMILY_RS400 ||
	 info->ChipFamily == CHIP_FAMILY_RS480) &&
	info->BiosConnector[index].ddc_i2c.mask_clk_reg == RADEON_GPIO_CRT2_DDC) {
	info->BiosConnector[index].ddc_i2c = legacy_setup_i2c_bus(RADEON_GPIO_MONID);
    } else if ((info->ChipFamily == CHIP_FAMILY_RS400 ||
		info->ChipFamily == CHIP_FAMILY_RS480) &&
	       info->BiosConnector[index].ddc_i2c.mask_clk_reg == RADEON_GPIO_MONID) {
	info->BiosConnector[index].ddc_i2c.valid = TRUE;
	info->BiosConnector[index].ddc_i2c.mask_clk_mask = (0x20 << 8);
	info->BiosConnector[index].ddc_i2c.mask_data_mask = 0x80;
	info->BiosConnector[index].ddc_i2c.a_clk_mask = (0x20 << 8);
	info->BiosConnector[index].ddc_i2c.a_data_mask = 0x80;
	info->BiosConnector[index].ddc_i2c.put_clk_mask = (0x20 << 8);
	info->BiosConnector[index].ddc_i2c.put_data_mask = 0x80;
	info->BiosConnector[index].ddc_i2c.get_clk_mask = (0x20 << 8);
	info->BiosConnector[index].ddc_i2c.get_data_mask = 0x80;
	info->BiosConnector[index].ddc_i2c.mask_clk_reg = RADEON_GPIOPAD_MASK;
	info->BiosConnector[index].ddc_i2c.mask_data_reg = RADEON_GPIOPAD_MASK;
	info->BiosConnector[index].ddc_i2c.a_clk_reg = RADEON_GPIOPAD_A;
	info->BiosConnector[index].ddc_i2c.a_data_reg = RADEON_GPIOPAD_A;
	info->BiosConnector[index].ddc_i2c.put_clk_reg = RADEON_GPIOPAD_EN;
	info->BiosConnector[index].ddc_i2c.put_data_reg = RADEON_GPIOPAD_EN;
	info->BiosConnector[index].ddc_i2c.get_clk_reg = RADEON_LCD_GPIO_Y_REG;
	info->BiosConnector[index].ddc_i2c.get_data_reg = RADEON_LCD_GPIO_Y_REG;
    }

    /* R3xx+ chips don't have GPIO_CRT2_DDC gpio pad */
    if ((IS_R300_VARIANT) &&
	info->BiosConnector[index].ddc_i2c.mask_clk_reg == RADEON_GPIO_CRT2_DDC)
	info->BiosConnector[index].ddc_i2c = legacy_setup_i2c_bus(RADEON_GPIO_DVI_DDC);

    /* Certain IBM chipset RN50s have a BIOS reporting two VGAs,
       one with VGA DDC and one with CRT2 DDC. - kill the CRT2 DDC one */
    if (info->Chipset == PCI_CHIP_RN50_515E &&
	PCI_SUB_VENDOR_ID(info->PciInfo) == 0x1014) {
	if (info->BiosConnector[index].ConnectorType == CONNECTOR_VGA &&
	    info->BiosConnector[index].ddc_i2c.mask_clk_reg == RADEON_GPIO_CRT2_DDC) {
	    info->BiosConnector[index].valid = FALSE;
	}
    }

    /* X300 card with extra non-existent DVI port */
    if (info->Chipset == PCI_CHIP_RV370_5B60 &&
	PCI_SUB_VENDOR_ID(info->PciInfo) == 0x17af &&
	PCI_SUB_DEVICE_ID(info->PciInfo) == 0x201e &&
	index == 2) {
	if (info->BiosConnector[index].ConnectorType == CONNECTOR_DVI_I) {
	    info->BiosConnector[index].valid = FALSE;
	}
    }

    /* r200 card with primary dac routed to both VGA and DVI - disable load detection 
     * otherwise you end up detecing load if either port is attached
     */
    if (info->Chipset == PCI_CHIP_R200_QL &&
	PCI_SUB_VENDOR_ID(info->PciInfo) == 0x1569 &&
	PCI_SUB_DEVICE_ID(info->PciInfo) == 0x514c &&
	(info->BiosConnector[index].devices & ATOM_DEVICE_CRT1_SUPPORT)) {
	info->BiosConnector[index].load_detection = FALSE;
    }

}

static Bool RADEONGetLegacyConnectorInfoFromBIOS (ScrnInfoPtr pScrn)
{
    RADEONInfoPtr info = RADEONPTR (pScrn);
    int offset, i, entry, tmp, tmp0, tmp1;
    RADEONLegacyDDCType DDCType;
    RADEONLegacyConnectorType ConnectorType;

    if (!info->VBIOS) return FALSE;

    offset = RADEON_BIOS16(info->ROMHeaderStart + 0x50);
    if (offset) {
	for (i = 0; i < 4; i++) {
	    entry = offset + 2 + i*2;

	    if (!RADEON_BIOS16(entry)) {
		break;
	    }
	    info->BiosConnector[i].valid = TRUE;
	    tmp = RADEON_BIOS16(entry);
	    info->BiosConnector[i].ConnectorType = (tmp >> 12) & 0xf;
	    ConnectorType = (tmp >> 12) & 0xf;
	    switch (ConnectorType) {
	    case CONNECTOR_PROPRIETARY_LEGACY:
		info->BiosConnector[i].ConnectorType = CONNECTOR_DVI_D;
		if ((tmp >> 4) & 0x1) {
		    info->BiosConnector[i].devices |= ATOM_DEVICE_DFP2_SUPPORT;
		    if (!radeon_add_encoder(pScrn,
				       radeon_get_encoder_id_from_supported_device(pScrn,
										   ATOM_DEVICE_DFP2_SUPPORT,
										   0),
					    ATOM_DEVICE_DFP2_SUPPORT))
			return FALSE;
		} else {
		    info->BiosConnector[i].devices |= ATOM_DEVICE_DFP1_SUPPORT;
		    if (!radeon_add_encoder(pScrn,
					    radeon_get_encoder_id_from_supported_device(pScrn,
											ATOM_DEVICE_DFP1_SUPPORT,
											0),
					    ATOM_DEVICE_DFP1_SUPPORT))
			return FALSE;
		}
		break;
	    case CONNECTOR_CRT_LEGACY:
		info->BiosConnector[i].ConnectorType = CONNECTOR_VGA;
		if (tmp & 0x1) {
		    info->BiosConnector[i].load_detection = FALSE;
		    info->BiosConnector[i].devices |= ATOM_DEVICE_CRT2_SUPPORT;
		    if (!radeon_add_encoder(pScrn,
					    radeon_get_encoder_id_from_supported_device(pScrn,
											ATOM_DEVICE_CRT2_SUPPORT,
											2),
					    ATOM_DEVICE_CRT2_SUPPORT))
			return FALSE;
		} else {
		    info->BiosConnector[i].load_detection = TRUE;
		    info->BiosConnector[i].devices |= ATOM_DEVICE_CRT1_SUPPORT;
		    if (!radeon_add_encoder(pScrn,
					    radeon_get_encoder_id_from_supported_device(pScrn,
											ATOM_DEVICE_CRT1_SUPPORT,
											1),
					    ATOM_DEVICE_CRT1_SUPPORT))
			return FALSE;
		}
		break;
	    case CONNECTOR_DVI_I_LEGACY:
		info->BiosConnector[i].ConnectorType = CONNECTOR_DVI_I;
		if (tmp & 0x1) {
		    info->BiosConnector[i].load_detection = FALSE;
		    info->BiosConnector[i].devices |= ATOM_DEVICE_CRT2_SUPPORT;
		    if (!radeon_add_encoder(pScrn,
					    radeon_get_encoder_id_from_supported_device(pScrn,
											ATOM_DEVICE_CRT2_SUPPORT,
											2),
					    ATOM_DEVICE_CRT2_SUPPORT))
			return FALSE;
		} else {
		    info->BiosConnector[i].load_detection = TRUE;
		    info->BiosConnector[i].devices |= ATOM_DEVICE_CRT1_SUPPORT;
		    if (!radeon_add_encoder(pScrn,
					    radeon_get_encoder_id_from_supported_device(pScrn,
											ATOM_DEVICE_CRT1_SUPPORT,
											1),
					    ATOM_DEVICE_CRT1_SUPPORT))
			return FALSE;
		}
		if ((tmp >> 4) & 0x1) {
		    info->BiosConnector[i].devices |= ATOM_DEVICE_DFP2_SUPPORT;
		    if (!radeon_add_encoder(pScrn,
					    radeon_get_encoder_id_from_supported_device(pScrn,
											ATOM_DEVICE_DFP2_SUPPORT,
											0),
					    ATOM_DEVICE_DFP2_SUPPORT))
			return FALSE;
		} else {
		    info->BiosConnector[i].devices |= ATOM_DEVICE_DFP1_SUPPORT;
		    if (!radeon_add_encoder(pScrn,
					    radeon_get_encoder_id_from_supported_device(pScrn,
											ATOM_DEVICE_DFP1_SUPPORT,
											0),
					    ATOM_DEVICE_DFP1_SUPPORT))
			return FALSE;
		}
		break;
	    case CONNECTOR_DVI_D_LEGACY:
		info->BiosConnector[i].ConnectorType = CONNECTOR_DVI_D;
		if ((tmp >> 4) & 0x1) {
		    info->BiosConnector[i].devices |= ATOM_DEVICE_DFP2_SUPPORT;
		    if (!radeon_add_encoder(pScrn,
					    radeon_get_encoder_id_from_supported_device(pScrn,
											ATOM_DEVICE_DFP2_SUPPORT,
											0),
					    ATOM_DEVICE_DFP2_SUPPORT))
			return FALSE;
		} else {
		    info->BiosConnector[i].devices |= ATOM_DEVICE_DFP1_SUPPORT;
		    if (!radeon_add_encoder(pScrn,
					    radeon_get_encoder_id_from_supported_device(pScrn,
											ATOM_DEVICE_DFP1_SUPPORT,
											0),
					    ATOM_DEVICE_DFP1_SUPPORT))
			return FALSE;
		}
		break;
	    case CONNECTOR_CTV_LEGACY:
		info->BiosConnector[i].ConnectorType = CONNECTOR_CTV;
		info->BiosConnector[i].load_detection = FALSE;
		info->BiosConnector[i].devices = ATOM_DEVICE_TV1_SUPPORT;
		if (!radeon_add_encoder(pScrn,
					radeon_get_encoder_id_from_supported_device(pScrn,
										    ATOM_DEVICE_TV1_SUPPORT,
										    2),
					ATOM_DEVICE_TV1_SUPPORT))
		    return FALSE;
		break;
	    case CONNECTOR_STV_LEGACY:
		info->BiosConnector[i].ConnectorType = CONNECTOR_STV;
		info->BiosConnector[i].load_detection = FALSE;
		info->BiosConnector[i].devices = ATOM_DEVICE_TV1_SUPPORT;
		if (!radeon_add_encoder(pScrn,
					radeon_get_encoder_id_from_supported_device(pScrn,
										    ATOM_DEVICE_TV1_SUPPORT,
										    2),
					ATOM_DEVICE_TV1_SUPPORT))
		    return FALSE;
		break;
	    default:
		xf86DrvMsg(pScrn->scrnIndex, X_WARNING, "Unknown Connector Type: %d\n", ConnectorType);
		info->BiosConnector[i].valid = FALSE;
		break;
	    }

	    info->BiosConnector[i].ddc_i2c.valid = FALSE;

	    DDCType = (tmp >> 8) & 0xf;
	    switch (DDCType) {
	    case DDC_MONID:
		info->BiosConnector[i].ddc_i2c = legacy_setup_i2c_bus(RADEON_GPIO_MONID);
		break;
	    case DDC_DVI:
		info->BiosConnector[i].ddc_i2c = legacy_setup_i2c_bus(RADEON_GPIO_DVI_DDC);
		break;
	    case DDC_VGA:
		info->BiosConnector[i].ddc_i2c = legacy_setup_i2c_bus(RADEON_GPIO_VGA_DDC);
		break;
	    case DDC_CRT2:
		info->BiosConnector[i].ddc_i2c = legacy_setup_i2c_bus(RADEON_GPIO_CRT2_DDC);
		break;
	    default:
		xf86DrvMsg(pScrn->scrnIndex, X_WARNING, "Unknown DDC Type: %d\n", DDCType);
		break;
	    }

	    RADEONApplyLegacyQuirks(pScrn, i);

	}
    } else {
	xf86DrvMsg(pScrn->scrnIndex, X_WARNING, "No Connector Info Table found!\n");

	/* old radeons and r128 didn't use connector tables you just check
	 * for LVDS, DVI, TV, etc. tables
	 */
	offset = RADEON_BIOS16(info->ROMHeaderStart + 0x34);
	if (offset) {
	    xf86DrvMsg(pScrn->scrnIndex, X_INFO,
		       "Found DFP table, assuming DVI connector\n");
	    info->BiosConnector[0].valid = TRUE;
	    info->BiosConnector[0].ConnectorType = CONNECTOR_DVI_I;
	    info->BiosConnector[0].load_detection = TRUE;
	    info->BiosConnector[0].ddc_i2c = legacy_setup_i2c_bus(RADEON_GPIO_DVI_DDC);
	    info->BiosConnector[0].devices = ATOM_DEVICE_CRT1_SUPPORT | ATOM_DEVICE_DFP1_SUPPORT;
	    if (!radeon_add_encoder(pScrn,
				    radeon_get_encoder_id_from_supported_device(pScrn,
										ATOM_DEVICE_DFP1_SUPPORT,
										0),
				    ATOM_DEVICE_DFP1_SUPPORT))
		return FALSE;
	    if (!radeon_add_encoder(pScrn,
				    radeon_get_encoder_id_from_supported_device(pScrn,
										ATOM_DEVICE_CRT1_SUPPORT,
										1),
				    ATOM_DEVICE_CRT1_SUPPORT))
		return FALSE;
	} else
	    return FALSE;
    }

    /* check LVDS table */
    /* IGP can be mobile or desktop so check the connectors */
    if (info->IsMobility || info->IsIGP) {
	offset = RADEON_BIOS16(info->ROMHeaderStart + 0x40);
	if (offset) {
	    info->BiosConnector[4].valid = TRUE;
	    info->BiosConnector[4].ConnectorType = CONNECTOR_LVDS;
	    info->BiosConnector[4].ddc_i2c.valid = FALSE;

	    info->BiosConnector[4].devices = ATOM_DEVICE_LCD1_SUPPORT;
	    if (!radeon_add_encoder(pScrn,
				    radeon_get_encoder_id_from_supported_device(pScrn,
										ATOM_DEVICE_LCD1_SUPPORT,
										0),
				    ATOM_DEVICE_LCD1_SUPPORT))
		return FALSE;

	    tmp = RADEON_BIOS16(info->ROMHeaderStart + 0x42);
	    if (tmp) {
		tmp0 = RADEON_BIOS16(tmp + 0x15);
		if (tmp0) {
		    tmp1 = RADEON_BIOS8(tmp0+2) & 0x07;
		    if (tmp1) {
			DDCType	= tmp1;
			switch (DDCType) {
			case DDC_NONE_DETECTED:
			    xf86DrvMsg(pScrn->scrnIndex, X_INFO, "No DDC for LCD\n");
			    break;
			case DDC_MONID:
			    info->BiosConnector[4].ddc_i2c = legacy_setup_i2c_bus(RADEON_GPIO_MONID);
			    break;
			case DDC_DVI:
			    info->BiosConnector[4].ddc_i2c = legacy_setup_i2c_bus(RADEON_GPIO_DVI_DDC);
			    break;
			case DDC_VGA:
			    info->BiosConnector[4].ddc_i2c = legacy_setup_i2c_bus(RADEON_GPIO_VGA_DDC);
			    break;
			case DDC_CRT2:
			    info->BiosConnector[4].ddc_i2c = legacy_setup_i2c_bus(RADEON_GPIO_CRT2_DDC);
			    break;
			case DDC_LCD:
			    info->BiosConnector[4].ddc_i2c = legacy_setup_i2c_bus(RADEON_LCD_GPIO_MASK);
			    info->BiosConnector[4].ddc_i2c.mask_clk_mask = RADEON_BIOS32(tmp0 + 0x03);
			    info->BiosConnector[4].ddc_i2c.mask_data_mask = RADEON_BIOS32(tmp0 + 0x07);
			    info->BiosConnector[4].ddc_i2c.a_clk_mask = RADEON_BIOS32(tmp0 + 0x03);
			    info->BiosConnector[4].ddc_i2c.a_data_mask = RADEON_BIOS32(tmp0 + 0x07);
			    info->BiosConnector[4].ddc_i2c.put_clk_mask = RADEON_BIOS32(tmp0 + 0x03);
			    info->BiosConnector[4].ddc_i2c.put_data_mask = RADEON_BIOS32(tmp0 + 0x07);
			    info->BiosConnector[4].ddc_i2c.get_clk_mask = RADEON_BIOS32(tmp0 + 0x03);
			    info->BiosConnector[4].ddc_i2c.get_data_mask = RADEON_BIOS32(tmp0 + 0x07);
			    break;
			case DDC_GPIO:
			    info->BiosConnector[4].ddc_i2c = legacy_setup_i2c_bus(RADEON_MDGPIO_EN_REG);
			    info->BiosConnector[4].ddc_i2c.mask_clk_mask =  RADEON_BIOS32(tmp0 + 0x03);
			    info->BiosConnector[4].ddc_i2c.mask_data_mask = RADEON_BIOS32(tmp0 + 0x07);
			    info->BiosConnector[4].ddc_i2c.a_clk_mask = RADEON_BIOS32(tmp0 + 0x03);
			    info->BiosConnector[4].ddc_i2c.a_data_mask = RADEON_BIOS32(tmp0 + 0x07);
			    info->BiosConnector[4].ddc_i2c.put_clk_mask = RADEON_BIOS32(tmp0 + 0x03);
			    info->BiosConnector[4].ddc_i2c.put_data_mask = RADEON_BIOS32(tmp0 + 0x07);
			    info->BiosConnector[4].ddc_i2c.get_clk_mask = RADEON_BIOS32(tmp0 + 0x03);
			    info->BiosConnector[4].ddc_i2c.get_data_mask = RADEON_BIOS32(tmp0 + 0x07);
			    break;
			default:
			    xf86DrvMsg(pScrn->scrnIndex, X_WARNING, "Unknown DDC Type: %d\n", DDCType);
			    break;
			}
			xf86DrvMsg(pScrn->scrnIndex, X_WARNING, "LCD DDC Info Table found!\n");
		    }
		}
	    } else
		info->BiosConnector[4].ddc_i2c.valid = FALSE;
	}
    }

    /* check TV table */
    if (info->InternalTVOut) {
	offset = RADEON_BIOS16(info->ROMHeaderStart + 0x32);
	if (offset) {
	    if (RADEON_BIOS8(offset + 6) == 'T') {
		info->BiosConnector[5].valid = TRUE;
		/* assume s-video for now */
		info->BiosConnector[5].ConnectorType = CONNECTOR_STV;
		info->BiosConnector[5].load_detection = FALSE;
		info->BiosConnector[5].ddc_i2c.valid = FALSE;
		info->BiosConnector[5].devices = ATOM_DEVICE_TV1_SUPPORT;
		if (!radeon_add_encoder(pScrn,
					radeon_get_encoder_id_from_supported_device(pScrn,
										    ATOM_DEVICE_TV1_SUPPORT,
										    2),
					ATOM_DEVICE_TV1_SUPPORT))
		    return FALSE;
	    }
	}
    }

    return TRUE;
}

Bool RADEONGetConnectorInfoFromBIOS (ScrnInfoPtr pScrn)
{
    RADEONInfoPtr info = RADEONPTR (pScrn);

    if(!info->VBIOS) return FALSE;

    if (info->IsAtomBios)
	return RADEONGetATOMConnectorInfoFromBIOS(pScrn);
    else
	return RADEONGetLegacyConnectorInfoFromBIOS(pScrn);
}

Bool RADEONGetTVInfoFromBIOS (xf86OutputPtr output) {
    ScrnInfoPtr pScrn = output->scrn;
    RADEONInfoPtr  info       = RADEONPTR(pScrn);
    RADEONOutputPrivatePtr radeon_output = output->driver_private;
    radeon_tvout_ptr tvout = &radeon_output->tvout;
    int offset, refclk, stds;

    if (!info->VBIOS) return FALSE;

    if (info->IsAtomBios)
        return RADEONGetATOMTVInfo(output);
    else {
	offset = RADEON_BIOS16(info->ROMHeaderStart + 0x32);
	if (offset) {
	    if (RADEON_BIOS8(offset + 6) == 'T') {
		switch (RADEON_BIOS8(offset + 7) & 0xf) {
		case 1:
		    tvout->default_tvStd = TV_STD_NTSC;
		    xf86DrvMsg(pScrn->scrnIndex, X_INFO, "Default TV standard: NTSC\n");
		    break;
		case 2:
		    tvout->default_tvStd = TV_STD_PAL;
		    xf86DrvMsg(pScrn->scrnIndex, X_INFO, "Default TV standard: PAL\n");
		    break;
		case 3:
		    tvout->default_tvStd = TV_STD_PAL_M;
		    xf86DrvMsg(pScrn->scrnIndex, X_INFO, "Default TV standard: PAL-M\n");
		    break;
		case 4:
		    tvout->default_tvStd = TV_STD_PAL_60;
		    xf86DrvMsg(pScrn->scrnIndex, X_INFO, "Default TV standard: PAL-60\n");
		    break;
		case 5:
		    tvout->default_tvStd = TV_STD_NTSC_J;
		    xf86DrvMsg(pScrn->scrnIndex, X_INFO, "Default TV standard: NTSC-J\n");
		    break;
		case 6:
		    tvout->default_tvStd = TV_STD_SCART_PAL;
		    xf86DrvMsg(pScrn->scrnIndex, X_INFO, "Default TV standard: SCART-PAL\n");
		    break;
		default:
		    tvout->default_tvStd = TV_STD_NTSC;
		    xf86DrvMsg(pScrn->scrnIndex, X_INFO, "Unknown TV standard; defaulting to NTSC\n");
		    break;
		}
		tvout->tvStd = tvout->default_tvStd;

		refclk = (RADEON_BIOS8(offset + 9) >> 2) & 0x3;
		if (refclk == 0)
		    tvout->TVRefClk = 29.498928713; /* MHz */
		else if (refclk == 1)
		    tvout->TVRefClk = 28.636360000;
		else if (refclk == 2)
		    tvout->TVRefClk = 14.318180000;
		else if (refclk == 3)
		    tvout->TVRefClk = 27.000000000;

		tvout->SupportedTVStds = tvout->default_tvStd;
		xf86DrvMsg(pScrn->scrnIndex, X_INFO, "TV standards supported by chip: ");
		stds = RADEON_BIOS8(offset + 10) & 0x1f;
		if (stds & TV_STD_NTSC) {
		    tvout->SupportedTVStds |= TV_STD_NTSC;
		    ErrorF("NTSC ");
		}
		if (stds & TV_STD_PAL) {
		    tvout->SupportedTVStds |= TV_STD_PAL;
		    ErrorF("PAL ");
		}
		if (stds & TV_STD_PAL_M) {
		    tvout->SupportedTVStds |= TV_STD_PAL_M;
		    ErrorF("PAL-M ");
		}
		if (stds & TV_STD_PAL_60) {
		    tvout->SupportedTVStds |= TV_STD_PAL_60;
		    ErrorF("PAL-60 ");
		}
		if (stds & TV_STD_NTSC_J) {
		    tvout->SupportedTVStds |= TV_STD_NTSC_J;
		    ErrorF("NTSC-J ");
		}
		if (stds & TV_STD_SCART_PAL) {
		    tvout->SupportedTVStds |= TV_STD_SCART_PAL;
		    ErrorF("SCART-PAL");
		}
		ErrorF("\n");

		return TRUE;
	    }
	}
    }
    return FALSE;
}

/* Read PLL parameters from BIOS block.  Default to typical values if there
   is no BIOS. */
Bool RADEONGetClockInfoFromBIOS (ScrnInfoPtr pScrn)
{
    RADEONInfoPtr info = RADEONPTR (pScrn);
    RADEONPLLPtr pll = &info->pll;
    uint16_t pll_info_block;

    if (!info->VBIOS) {
	return FALSE;
    } else {
	if (info->IsAtomBios) {
	    return RADEONGetATOMClockInfo(pScrn);
	} else {
	    int rev;

	    pll_info_block = RADEON_BIOS16 (info->ROMHeaderStart + 0x30);

	    rev = RADEON_BIOS8(pll_info_block);

	    pll->reference_freq = RADEON_BIOS16 (pll_info_block + 0x0e);
	    pll->reference_div = RADEON_BIOS16 (pll_info_block + 0x10);
	    pll->pll_out_min = RADEON_BIOS32 (pll_info_block + 0x12);
	    pll->pll_out_max = RADEON_BIOS32 (pll_info_block + 0x16);

	    if (rev > 9) {
		pll->pll_in_min = RADEON_BIOS32(pll_info_block + 0x36);
		pll->pll_in_max = RADEON_BIOS32(pll_info_block + 0x3a);
	    } else {
		pll->pll_in_min = 40;
		pll->pll_in_max = 500;
	    }

	    pll->xclk = RADEON_BIOS16(pll_info_block + 0x08);

	    info->sclk = RADEON_BIOS16(pll_info_block + 10) / 100.0;
	    info->mclk = RADEON_BIOS16(pll_info_block + 8) / 100.0;
	}

	if (info->sclk == 0) info->sclk = 200;
	if (info->mclk == 0) info->mclk = 200;
    }

    xf86DrvMsg(pScrn->scrnIndex, X_INFO, "ref_freq: %d, min_out_pll: %u, "
	       "max_out_pll: %u, min_in_pll: %u, max_in_pll: %u, xclk: %d, "
	       "sclk: %f, mclk: %f\n",
	       pll->reference_freq, (unsigned)pll->pll_out_min,
	       (unsigned)pll->pll_out_max, (unsigned)pll->pll_in_min,
	       (unsigned)pll->pll_in_max, pll->xclk, info->sclk, info->mclk);

    return TRUE;
}

Bool RADEONGetDAC2InfoFromBIOS (ScrnInfoPtr pScrn, radeon_tvdac_ptr tvdac)
{
    RADEONInfoPtr  info       = RADEONPTR(pScrn);
    int offset, rev, bg, dac;

    if (!info->VBIOS) return FALSE;

    if (xf86ReturnOptValBool(info->Options, OPTION_DEFAULT_TVDAC_ADJ, FALSE))
	return FALSE;

    if (info->IsAtomBios) {
	/* not implemented yet */
	return FALSE;
    } else {
	/* first check TV table */
	offset = RADEON_BIOS16(info->ROMHeaderStart + 0x32);
        if (offset) {
	    rev = RADEON_BIOS8(offset + 0x3);
	    if (rev > 4) {
		bg = RADEON_BIOS8(offset + 0xc) & 0xf;
		dac = RADEON_BIOS8(offset + 0xd) & 0xf;
		tvdac->ps2_tvdac_adj = (bg << 16) | (dac << 20);

		bg = RADEON_BIOS8(offset + 0xe) & 0xf;
		dac = RADEON_BIOS8(offset + 0xf) & 0xf;
		tvdac->pal_tvdac_adj = (bg << 16) | (dac << 20);

		bg = RADEON_BIOS8(offset + 0x10) & 0xf;
		dac = RADEON_BIOS8(offset + 0x11) & 0xf;
		tvdac->ntsc_tvdac_adj = (bg << 16) | (dac << 20);

		return TRUE;
	    } else if (rev > 1) {
		bg = RADEON_BIOS8(offset + 0xc) & 0xf;
		dac = (RADEON_BIOS8(offset + 0xc) >> 4) & 0xf;
		tvdac->ps2_tvdac_adj = (bg << 16) | (dac << 20);

		bg = RADEON_BIOS8(offset + 0xd) & 0xf;
		dac = (RADEON_BIOS8(offset + 0xd) >> 4) & 0xf;
		tvdac->pal_tvdac_adj = (bg << 16) | (dac << 20);

		bg = RADEON_BIOS8(offset + 0xe) & 0xf;
		dac = (RADEON_BIOS8(offset + 0xe) >> 4) & 0xf;
		tvdac->ntsc_tvdac_adj = (bg << 16) | (dac << 20);

		return TRUE;
	    }
	}
	/* then check CRT table */
	offset = RADEON_BIOS16(info->ROMHeaderStart + 0x60);
        if (offset) {
	    rev = RADEON_BIOS8(offset) & 0x3;
	    if (rev < 2) {
		bg = RADEON_BIOS8(offset + 0x3) & 0xf;
		dac = (RADEON_BIOS8(offset + 0x3) >> 4) & 0xf;
		tvdac->ps2_tvdac_adj = (bg << 16) | (dac << 20);
		tvdac->pal_tvdac_adj = tvdac->ps2_tvdac_adj;
		tvdac->ntsc_tvdac_adj = tvdac->ps2_tvdac_adj;

		return TRUE;
	    } else {
		bg = RADEON_BIOS8(offset + 0x4) & 0xf;
		dac = RADEON_BIOS8(offset + 0x5) & 0xf;
		tvdac->ps2_tvdac_adj = (bg << 16) | (dac << 20);
		tvdac->pal_tvdac_adj = tvdac->ps2_tvdac_adj;
		tvdac->ntsc_tvdac_adj = tvdac->ps2_tvdac_adj;

		return TRUE;
	    }
	}
    }

    return FALSE;
}

Bool
RADEONGetLVDSInfoFromBIOS(ScrnInfoPtr pScrn, radeon_lvds_ptr lvds)
{
    RADEONInfoPtr  info       = RADEONPTR(pScrn);
    radeon_native_mode_ptr native_mode = &lvds->native_mode;
    unsigned long tmp, i;

    if (!info->VBIOS)
	return FALSE;

    if (!info->IsAtomBios) {
	tmp = RADEON_BIOS16(info->ROMHeaderStart + 0x40);

	if (!tmp) {
	    xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
		       "No Panel Info Table found in BIOS!\n");
	    return FALSE;
	} else {
	    char  stmp[30];
	    int   tmp0;

	    for (i = 0; i < 24; i++)
	    stmp[i] = RADEON_BIOS8(tmp+i+1);
	    stmp[24] = 0;

	    xf86DrvMsg(pScrn->scrnIndex, X_INFO,
		       "Panel ID string: %s\n", stmp);

	    native_mode->PanelXRes = RADEON_BIOS16(tmp+25);
	    native_mode->PanelYRes = RADEON_BIOS16(tmp+27);
	    xf86DrvMsg(0, X_INFO, "Panel Size from BIOS: %dx%d\n",
		       native_mode->PanelXRes, native_mode->PanelYRes);

	    lvds->PanelPwrDly = RADEON_BIOS16(tmp+44);
	    if (lvds->PanelPwrDly > 2000 || lvds->PanelPwrDly < 0)
		lvds->PanelPwrDly = 2000;

	    /* some panels only work well with certain divider combinations.
	     */
	    info->RefDivider = RADEON_BIOS16(tmp+46);
	    info->PostDivider = RADEON_BIOS8(tmp+48);
	    info->FeedbackDivider = RADEON_BIOS16(tmp+49);
	    if ((info->RefDivider != 0) &&
		(info->FeedbackDivider > 3)) {
		info->UseBiosDividers = TRUE;
		xf86DrvMsg(pScrn->scrnIndex, X_INFO,
			   "BIOS provided dividers will be used.\n");
	    }

	    /* We don't use a while loop here just in case we have a corrupted BIOS image.
	       The max number of table entries is 23 at present, but may grow in future.
	       To ensure it works with future revisions we loop it to 32.
	    */
	    for (i = 0; i < 32; i++) {
		tmp0 = RADEON_BIOS16(tmp+64+i*2);
		if (tmp0 == 0) break;
		if ((RADEON_BIOS16(tmp0) == native_mode->PanelXRes) &&
		    (RADEON_BIOS16(tmp0+2) == native_mode->PanelYRes)) {
		    native_mode->HBlank     = (RADEON_BIOS16(tmp0+17) -
					       RADEON_BIOS16(tmp0+19)) * 8;
		    native_mode->HOverPlus  = (RADEON_BIOS16(tmp0+21) -
					       RADEON_BIOS16(tmp0+19) - 1) * 8;
		    native_mode->HSyncWidth = RADEON_BIOS8(tmp0+23) * 8;
		    native_mode->VBlank     = (RADEON_BIOS16(tmp0+24) -
					       RADEON_BIOS16(tmp0+26));
		    native_mode->VOverPlus  = ((RADEON_BIOS16(tmp0+28) & 0x7ff) -
					       RADEON_BIOS16(tmp0+26));
		    native_mode->VSyncWidth = ((RADEON_BIOS16(tmp0+28) & 0xf800) >> 11);
		    native_mode->DotClock   = RADEON_BIOS16(tmp0+9) * 10;
		    native_mode->Flags = 0;
		}
	    }
	}

	xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
		   "LVDS Info:\n"
		   "XRes: %d, YRes: %d, DotClock: %d\n"
		   "HBlank: %d, HOverPlus: %d, HSyncWidth: %d\n"
		   "VBlank: %d, VOverPlus: %d, VSyncWidth: %d\n",
		   native_mode->PanelXRes, native_mode->PanelYRes, native_mode->DotClock,
		   native_mode->HBlank, native_mode->HOverPlus, native_mode->HSyncWidth,
		   native_mode->VBlank, native_mode->VOverPlus, native_mode->VSyncWidth);

	return TRUE;
    }
    return FALSE;
}

xf86MonPtr RADEONGetHardCodedEDIDFromBIOS (xf86OutputPtr output)
{
    ScrnInfoPtr pScrn = output->scrn;
    RADEONInfoPtr info = RADEONPTR(pScrn);
    unsigned long tmp;
    unsigned char edid[256];
    xf86MonPtr mon = NULL;

    if (!info->VBIOS)
	return mon;

    if (!info->IsAtomBios) {
	tmp = RADEON_BIOS16(info->ROMHeaderStart + 0x4c);
	if (tmp) {
	    memcpy(edid, (unsigned char*)(info->VBIOS + tmp), 256);
	    if (edid[1] == 0xff)
		mon = xf86InterpretEDID(output->scrn->scrnIndex, edid);
	}
    }

    return mon;
}

Bool RADEONGetTMDSInfoFromBIOS (ScrnInfoPtr pScrn, radeon_tmds_ptr tmds)
{
    RADEONInfoPtr  info       = RADEONPTR(pScrn);
    uint32_t tmp, maxfreq;
    int i, n;

    if (!info->VBIOS) return FALSE;

    if (info->IsAtomBios) {
	if((tmp = RADEON_BIOS16 (info->MasterDataStart + 18))) {

	    maxfreq = RADEON_BIOS16(tmp+4);

	    for (i=0; i<4; i++) {
		tmds->tmds_pll[i].freq = RADEON_BIOS16(tmp+i*6+6);
		/* This assumes each field in TMDS_PLL has 6 bit as in R300/R420 */
		tmds->tmds_pll[i].value = ((RADEON_BIOS8(tmp+i*6+8) & 0x3f) |
					   ((RADEON_BIOS8(tmp+i*6+10) & 0x3f)<<6) |
					   ((RADEON_BIOS8(tmp+i*6+9) & 0xf)<<12) |
					   ((RADEON_BIOS8(tmp+i*6+11) & 0xf)<<16));
		xf86DrvMsg(pScrn->scrnIndex, X_INFO,
			   "TMDS PLL from BIOS: %u %x\n",
			   (unsigned)tmds->tmds_pll[i].freq,
			   (unsigned)tmds->tmds_pll[i].value);

		if (maxfreq == tmds->tmds_pll[i].freq) {
		    tmds->tmds_pll[i].freq = 0xffffffff;
		    break;
		}
	    }
	    return TRUE;
	}
    } else {

	tmp = RADEON_BIOS16(info->ROMHeaderStart + 0x34);
	if (tmp) {
	    xf86DrvMsg(pScrn->scrnIndex, X_INFO,
		       "DFP table revision: %d\n", RADEON_BIOS8(tmp));
	    if (RADEON_BIOS8(tmp) == 3) {
		n = RADEON_BIOS8(tmp + 5) + 1;
		if (n > 4) n = 4;
		for (i=0; i<n; i++) {
		    tmds->tmds_pll[i].value = RADEON_BIOS32(tmp+i*10+0x08);
		    tmds->tmds_pll[i].freq = RADEON_BIOS16(tmp+i*10+0x10);
		}
		return TRUE;
	    } else if (RADEON_BIOS8(tmp) == 4) {
	        int stride = 0;
		n = RADEON_BIOS8(tmp + 5) + 1;
		if (n > 4) n = 4;
		for (i=0; i<n; i++) {
		    tmds->tmds_pll[i].value = RADEON_BIOS32(tmp+stride+0x08);
		    tmds->tmds_pll[i].freq = RADEON_BIOS16(tmp+stride+0x10);
		    if (i == 0) stride += 10;
		    else stride += 6;
		}
		return TRUE;
	    }
	}
    }
    return FALSE;
}

static RADEONI2CBusRec
RADEONLookupI2CBlock(ScrnInfoPtr pScrn, int id)
{
    RADEONInfoPtr info = RADEONPTR (pScrn);
    int offset, blocks, i;
    RADEONI2CBusRec i2c;

    memset(&i2c, 0, sizeof(RADEONI2CBusRec));
    i2c.valid = FALSE;

    offset = RADEON_BIOS16(info->ROMHeaderStart + 0x70);
    if (offset) {
	blocks = RADEON_BIOS8(offset + 2);
	for (i = 0; i < blocks; i++) {
	    int i2c_id = RADEON_BIOS8(offset + 3 + (i * 5) + 0);
	    if (id == i2c_id) {
		int clock_shift = RADEON_BIOS8(offset + 3 + (i * 5) + 3);
		int data_shift = RADEON_BIOS8(offset + 3 + (i * 5) + 4);

		i2c.mask_clk_mask = (1 << clock_shift);
		i2c.mask_data_mask = (1 << data_shift);
		i2c.a_clk_mask = (1 << clock_shift);
		i2c.a_data_mask = (1 << data_shift);
		i2c.put_clk_mask = (1 << clock_shift);
		i2c.put_data_mask = (1 << data_shift);
		i2c.get_clk_mask = (1 << clock_shift);
		i2c.get_data_mask = (1 << data_shift);
		i2c.mask_clk_reg = RADEON_GPIOPAD_MASK;
		i2c.mask_data_reg = RADEON_GPIOPAD_MASK;
		i2c.a_clk_reg = RADEON_GPIOPAD_A;
		i2c.a_data_reg = RADEON_GPIOPAD_A;
		i2c.put_clk_reg = RADEON_GPIOPAD_EN;
		i2c.put_data_reg = RADEON_GPIOPAD_EN;
		i2c.get_clk_reg = RADEON_LCD_GPIO_Y_REG;
		i2c.get_data_reg = RADEON_LCD_GPIO_Y_REG;
		i2c.valid = TRUE;
		break;
	    }
	}
    }
    return i2c;
}

Bool RADEONGetExtTMDSInfoFromBIOS (ScrnInfoPtr pScrn, radeon_dvo_ptr dvo)
{
    RADEONInfoPtr info = RADEONPTR(pScrn);
    int offset, table_start, max_freq, gpio_reg, flags;

    if (!info->VBIOS)
	return FALSE;

    if (info->IsAtomBios)
	return FALSE;
    else if (info->IsIGP) {
	/* RS4xx TMDS stuff is in the mobile table */
	offset = RADEON_BIOS16(info->ROMHeaderStart + 0x42);
	if (offset) {
	    int rev = RADEON_BIOS8(offset);
	    if (rev >= 6) {
		offset = RADEON_BIOS16(offset + 0x17);
		if (offset) {
		    offset = RADEON_BIOS16(offset + 2);
		    rev = RADEON_BIOS8(offset);
		    if (offset && (rev > 1)) {
			int blocks = RADEON_BIOS8(offset + 3);
			int index = offset + 4;
			dvo->dvo_i2c.valid = FALSE;
			while (blocks > 0) {
			    int id = RADEON_BIOS16(index);
			    index += 2;
			    switch (id >> 13) {
			    case 0:
				index += 6;
				break;
			    case 2:
				index += 10;
				break;
			    case 3:
				index += 2;
				break;
			    case 4:
				index += 2;
				break;
			    case 6:
				dvo->dvo_i2c_slave_addr =
				    RADEON_BIOS16(index) & 0xff;
				index += 2;
				dvo->dvo_i2c =
				    RADEONLookupI2CBlock(pScrn, RADEON_BIOS8(index));
				return TRUE;
			    default:
				break;
			    }
			    blocks--;
			}
		    }
		}
	    }
	} else {
	    dvo->dvo_i2c_slave_addr = 0x70;
	    dvo->dvo_i2c = RADEONLookupI2CBlock(pScrn, 136);
	    info->ext_tmds_chip = RADEON_SIL_164;
	}
    } else {
	offset = RADEON_BIOS16(info->ROMHeaderStart + 0x58);
	if (offset) {
	     xf86DrvMsg(pScrn->scrnIndex, X_INFO,
			"External TMDS Table revision: %d\n",
			RADEON_BIOS8(offset));
	    table_start = offset+4;
	    max_freq = RADEON_BIOS16(table_start);
	    dvo->dvo_i2c_slave_addr = RADEON_BIOS8(table_start+2);
	    dvo->dvo_i2c.valid = FALSE;
	    gpio_reg = RADEON_BIOS8(table_start+3);
	    if (gpio_reg == 1)
		dvo->dvo_i2c = legacy_setup_i2c_bus(RADEON_GPIO_MONID);
	    else if (gpio_reg == 2)
		dvo->dvo_i2c = legacy_setup_i2c_bus(RADEON_GPIO_DVI_DDC);
	    else if (gpio_reg == 3)
		dvo->dvo_i2c = legacy_setup_i2c_bus(RADEON_GPIO_VGA_DDC);
	    else if (gpio_reg == 4) {
		if (IS_R300_VARIANT)
		    dvo->dvo_i2c = legacy_setup_i2c_bus(RADEON_GPIO_MONID);
		else
		    dvo->dvo_i2c = legacy_setup_i2c_bus(RADEON_GPIO_CRT2_DDC);
	    } else if (gpio_reg == 5) {
		xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
			   "unsupported MM gpio_reg\n");
		return FALSE;
	    } else {
		xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
			   "Unknown gpio reg: %d\n", gpio_reg);
		return FALSE;
	    }
	    flags = RADEON_BIOS8(table_start+5);
	    dvo->dvo_duallink = flags & 0x01;
	    if (dvo->dvo_duallink) {
		xf86DrvMsg(pScrn->scrnIndex, X_INFO,
			   "Duallink TMDS detected\n");
	    }
	    return TRUE;
	}
    }

    xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
	       "No External TMDS Table found\n");

    return FALSE;
}

Bool RADEONInitExtTMDSInfoFromBIOS (xf86OutputPtr output)
{
    ScrnInfoPtr pScrn = output->scrn;
    RADEONInfoPtr info = RADEONPTR(pScrn);
    unsigned char *RADEONMMIO = info->MMIO;
    radeon_encoder_ptr radeon_encoder = radeon_get_encoder(output);
    radeon_dvo_ptr dvo = NULL;
    int offset, index, id;
    uint32_t val, reg, and_mask, or_mask;

    if (radeon_encoder == NULL)
	return FALSE;

    dvo = (radeon_dvo_ptr)radeon_encoder->dev_priv;

    if (dvo == NULL)
	return FALSE;

    if (!info->VBIOS)
	return FALSE;

    if (info->IsAtomBios)
	return FALSE;
    else if (info->IsIGP) {
	/* RS4xx TMDS stuff is in the mobile table */
	offset = RADEON_BIOS16(info->ROMHeaderStart + 0x42);
	if (offset) {
	    int rev = RADEON_BIOS8(offset);
	    if (rev >= 6) {
		offset = RADEON_BIOS16(offset + 0x17);
		if (offset) {
		    offset = RADEON_BIOS16(offset + 2);
		    rev = RADEON_BIOS8(offset);
		    if (offset && (rev > 1)) {
			int blocks = RADEON_BIOS8(offset + 3);
			index = offset + 4;
			while (blocks > 0) {
			    id = RADEON_BIOS16(index);
			    index += 2;
			    switch (id >> 13) {
			    case 0:
				reg = (id & 0x1fff) * 4;
				val = RADEON_BIOS32(index);
				index += 4;
				ErrorF("MMIO: 0x%x 0x%x\n",
				       (unsigned)reg, (unsigned)val);
				OUTREG(reg, val);
				break;
			    case 2:
				reg = (id & 0x1fff) * 4;
				and_mask = RADEON_BIOS32(index);
				index += 4;
				or_mask = RADEON_BIOS32(index);
				index += 4;
				ErrorF("MMIO mask: 0x%x 0x%x 0x%x\n",
				       (unsigned)reg, (unsigned)and_mask, (unsigned)or_mask);
				val = INREG(reg);
				val = (val & and_mask) | or_mask;
				OUTREG(reg, val);
				break;
			    case 3:
				val = RADEON_BIOS16(index);
				index += 2;
				ErrorF("delay: %u\n", (unsigned)val);
				usleep(val);
				break;
			    case 4:
				val = RADEON_BIOS16(index);
				index += 2;
				ErrorF("delay: %u\n", (unsigned)val * 1000);
				usleep(val * 1000);
				break;
			    case 6:
				index++;
				reg = RADEON_BIOS8(index);
				index++;
				val = RADEON_BIOS8(index);
				index++;
				ErrorF("i2c write: 0x%x, 0x%x\n", (unsigned)reg,
				       (unsigned)val);
				RADEONDVOWriteByte(dvo->DVOChip, reg, val);
				break;
			    default:
				ErrorF("unknown id %d\n", id>>13);
				return FALSE;
			    }
			    blocks--;
			}
			return TRUE;
		    }
		}
	    }
	}
    } else {
	offset = RADEON_BIOS16(info->ROMHeaderStart + 0x58);
	if (offset) {
	    index = offset+10;
	    id = RADEON_BIOS16(index);
	    while (id != 0xffff) {
		index += 2;
		switch(id >> 13) {
		case 0:
		    reg = (id & 0x1fff) * 4;
		    val = RADEON_BIOS32(index);
		    index += 4;
		    ErrorF("MMIO: 0x%x 0x%x\n",
			   (unsigned)reg, (unsigned)val);
		    OUTREG(reg, val);
		    break;
		case 2:
		    reg = (id & 0x1fff) * 4;
		    and_mask = RADEON_BIOS32(index);
		    index += 4;
		    or_mask = RADEON_BIOS32(index);
		    index += 4;
		    val = INREG(reg);
		    val = (val & and_mask) | or_mask;
		    ErrorF("MMIO mask: 0x%x 0x%x 0x%x\n",
			   (unsigned)reg, (unsigned)and_mask, (unsigned)or_mask);
		    OUTREG(reg, val);
		    break;
		case 4:
		    val = RADEON_BIOS16(index);
		    index += 2;
		    ErrorF("delay: %u\n", (unsigned)val);
		    usleep(val);
		    break;
		case 5:
		    reg = id & 0x1fff;
		    and_mask = RADEON_BIOS32(index);
		    index += 4;
		    or_mask = RADEON_BIOS32(index);
		    index += 4;
		    ErrorF("PLL mask: 0x%x 0x%x 0x%x\n",
			   (unsigned)reg, (unsigned)and_mask, (unsigned)or_mask);
		    val = INPLL(pScrn, reg);
		    val = (val & and_mask) | or_mask;
		    OUTPLL(pScrn, reg, val);
		    break;
		case 6:
		    reg = id & 0x1fff;
		    val = RADEON_BIOS8(index);
		    index += 1;
		    ErrorF("i2c write: 0x%x, 0x%x\n", (unsigned)reg,
			   (unsigned)val);
		    RADEONDVOWriteByte(dvo->DVOChip, reg, val);
		    break;
		default:
		    ErrorF("unknown id %d\n", id>>13);
		    return FALSE;
		};
		id = RADEON_BIOS16(index);
	    }
	    return TRUE;
	}
    }

    return FALSE;
}

/* support for init from bios tables
 *
 * Based heavily on the netbsd radeonfb driver
 * Written by Garrett D'Amore
 * Copyright (c) 2006 Itronix Inc.
 *
 */

/* bios table defines */

#define RADEON_TABLE_ENTRY_FLAG_MASK    0xe000
#define RADEON_TABLE_ENTRY_INDEX_MASK   0x1fff
#define RADEON_TABLE_ENTRY_COMMAND_MASK 0x00ff

#define RADEON_TABLE_FLAG_WRITE_INDEXED 0x0000
#define RADEON_TABLE_FLAG_WRITE_DIRECT  0x2000
#define RADEON_TABLE_FLAG_MASK_INDEXED  0x4000
#define RADEON_TABLE_FLAG_MASK_DIRECT   0x6000
#define RADEON_TABLE_FLAG_DELAY         0x8000
#define RADEON_TABLE_FLAG_SCOMMAND      0xa000

#define RADEON_TABLE_SCOMMAND_WAIT_MC_BUSY_MASK       0x03
#define RADEON_TABLE_SCOMMAND_WAIT_MEM_PWRUP_COMPLETE 0x08

#define RADEON_PLL_FLAG_MASK      0xc0
#define RADEON_PLL_INDEX_MASK     0x3f

#define RADEON_PLL_FLAG_WRITE     0x00
#define RADEON_PLL_FLAG_MASK_BYTE 0x40
#define RADEON_PLL_FLAG_WAIT      0x80

#define RADEON_PLL_WAIT_150MKS                    1
#define RADEON_PLL_WAIT_5MS                       2
#define RADEON_PLL_WAIT_MC_BUSY_MASK              3
#define RADEON_PLL_WAIT_DLL_READY_MASK            4
#define RADEON_PLL_WAIT_CHK_SET_CLK_PWRMGT_CNTL24 5

static uint16_t
RADEONValidateBIOSOffset(ScrnInfoPtr pScrn, uint16_t offset)
{
    RADEONInfoPtr info = RADEONPTR (pScrn);
    uint8_t revision = RADEON_BIOS8(offset - 1);

    if (revision > 0x10) {
        xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
                   "Bad revision %d for BIOS table\n", revision);
        return 0;
    }

    if (offset < 0x60) {
        xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
                   "Bad offset 0x%x for BIOS Table\n", offset);
        return 0;
    }

    return offset;
}

Bool
RADEONGetBIOSInitTableOffsets(ScrnInfoPtr pScrn)
{
    RADEONInfoPtr info = RADEONPTR (pScrn);
    uint8_t val;

    if (!info->VBIOS) {
	return FALSE;
    } else {
	if (info->IsAtomBios) {
	    return FALSE;
	} else {
	    info->BiosTable.revision = RADEON_BIOS8(info->ROMHeaderStart + 4);
	    info->BiosTable.rr1_offset = RADEON_BIOS16(info->ROMHeaderStart + 0x0c);
	    if (info->BiosTable.rr1_offset) {
		info->BiosTable.rr1_offset =
		    RADEONValidateBIOSOffset(pScrn, info->BiosTable.rr1_offset);
	    }
	    if (info->BiosTable.revision > 0x09)
		return TRUE;
	    info->BiosTable.rr2_offset = RADEON_BIOS16(info->ROMHeaderStart + 0x4e);
	    if (info->BiosTable.rr2_offset) {
		info->BiosTable.rr2_offset =
		    RADEONValidateBIOSOffset(pScrn, info->BiosTable.rr2_offset);
	    }
	    info->BiosTable.dyn_clk_offset = RADEON_BIOS16(info->ROMHeaderStart + 0x52);
	    if (info->BiosTable.dyn_clk_offset) {
		info->BiosTable.dyn_clk_offset =
		    RADEONValidateBIOSOffset(pScrn, info->BiosTable.dyn_clk_offset);
	    }
	    info->BiosTable.pll_offset = RADEON_BIOS16(info->ROMHeaderStart + 0x46);
	    if (info->BiosTable.pll_offset) {
		info->BiosTable.pll_offset =
		    RADEONValidateBIOSOffset(pScrn, info->BiosTable.pll_offset);
	    }
	    info->BiosTable.mem_config_offset = RADEON_BIOS16(info->ROMHeaderStart + 0x48);
	    if (info->BiosTable.mem_config_offset) {
		info->BiosTable.mem_config_offset =
		    RADEONValidateBIOSOffset(pScrn, info->BiosTable.mem_config_offset);
	    }
	    if (info->BiosTable.mem_config_offset) {
		info->BiosTable.mem_reset_offset = info->BiosTable.mem_config_offset;
		if (info->BiosTable.mem_reset_offset) {
		    while (RADEON_BIOS8(info->BiosTable.mem_reset_offset))
			info->BiosTable.mem_reset_offset++;
		    info->BiosTable.mem_reset_offset++;
		    info->BiosTable.mem_reset_offset += 2;
		}
	    }
	    if (info->BiosTable.mem_config_offset) {
		info->BiosTable.short_mem_offset = info->BiosTable.mem_config_offset;
		if ((info->BiosTable.short_mem_offset != 0) &&
		    (RADEON_BIOS8(info->BiosTable.short_mem_offset - 2) <= 64))
		    info->BiosTable.short_mem_offset +=
			RADEON_BIOS8(info->BiosTable.short_mem_offset - 3);
	    }
	    if (info->BiosTable.rr2_offset) {
		info->BiosTable.rr3_offset = info->BiosTable.rr2_offset;
		if (info->BiosTable.rr3_offset) {
		    while ((val = RADEON_BIOS8(info->BiosTable.rr3_offset + 1)) != 0) {
			if (val & 0x40)
			    info->BiosTable.rr3_offset += 10;
			else if (val & 0x80)
			    info->BiosTable.rr3_offset += 4;
			else
			    info->BiosTable.rr3_offset += 6;
		    }
		    info->BiosTable.rr3_offset += 2;
		}
	    }

	    if (info->BiosTable.rr3_offset) {
		info->BiosTable.rr4_offset = info->BiosTable.rr3_offset;
		if (info->BiosTable.rr4_offset) {
		    while ((val = RADEON_BIOS8(info->BiosTable.rr4_offset + 1)) != 0) {
			if (val & 0x40)
			    info->BiosTable.rr4_offset += 10;
			else if (val & 0x80)
			    info->BiosTable.rr4_offset += 4;
			else
			    info->BiosTable.rr4_offset += 6;
		    }
		    info->BiosTable.rr4_offset += 2;
		}
	    }

	    if (info->BiosTable.rr3_offset + 1 == info->BiosTable.pll_offset) {
		info->BiosTable.rr3_offset = 0;
		info->BiosTable.rr4_offset = 0;
	    }

	    return TRUE;

	}
    }
}

static void
RADEONRestoreBIOSRegBlock(ScrnInfoPtr pScrn, uint16_t table_offset)
{
    RADEONInfoPtr info = RADEONPTR (pScrn);
    unsigned char *RADEONMMIO = info->MMIO;
    uint16_t offset = table_offset;
    uint16_t value, flag, index, count;
    uint32_t andmask, ormask, val, channel_complete_mask;
    uint8_t  command;

    if (offset == 0)
	return;

    while ((value = RADEON_BIOS16(offset)) != 0) {
	flag = value & RADEON_TABLE_ENTRY_FLAG_MASK;
	index = value & RADEON_TABLE_ENTRY_INDEX_MASK;
	command = value & RADEON_TABLE_ENTRY_COMMAND_MASK;

	offset += 2;

	switch (flag) {
	case RADEON_TABLE_FLAG_WRITE_INDEXED:
	    val = RADEON_BIOS32(offset);
	    ErrorF("WRITE INDEXED: 0x%x 0x%x\n",
		   index, (unsigned)val);
	    OUTREG(RADEON_MM_INDEX, index);
	    OUTREG(RADEON_MM_DATA, val);
	    offset += 4;
	    break;

	case RADEON_TABLE_FLAG_WRITE_DIRECT:
	    val = RADEON_BIOS32(offset);
	    ErrorF("WRITE DIRECT: 0x%x 0x%x\n", index, (unsigned)val);
	    OUTREG(index, val);
	    offset += 4;
	    break;

	case RADEON_TABLE_FLAG_MASK_INDEXED:
	    andmask = RADEON_BIOS32(offset);
	    offset += 4;
	    ormask = RADEON_BIOS32(offset);
	    offset += 4;
	    ErrorF("MASK INDEXED: 0x%x 0x%x 0x%x\n",
		   index, (unsigned)andmask, (unsigned)ormask);
	    OUTREG(RADEON_MM_INDEX, index);
	    val = INREG(RADEON_MM_DATA);
	    val = (val & andmask) | ormask;
	    OUTREG(RADEON_MM_DATA, val);
	    break;

	case RADEON_TABLE_FLAG_MASK_DIRECT:
	    andmask = RADEON_BIOS32(offset);
	    offset += 4;
	    ormask = RADEON_BIOS32(offset);
	    offset += 4;
	    ErrorF("MASK DIRECT: 0x%x 0x%x 0x%x\n",
		   index, (unsigned)andmask, (unsigned)ormask);
	    val = INREG(index);
	    val = (val & andmask) | ormask;
	    OUTREG(index, val);
	    break;

	case RADEON_TABLE_FLAG_DELAY:
	    count = RADEON_BIOS16(offset);
	    ErrorF("delay: %d\n", count);
	    usleep(count);
	    offset += 2;
	    break;

	case RADEON_TABLE_FLAG_SCOMMAND:
	    ErrorF("SCOMMAND 0x%x\n", command); 
	    switch (command) {
	    case RADEON_TABLE_SCOMMAND_WAIT_MC_BUSY_MASK:
		count = RADEON_BIOS16(offset);
		ErrorF("SCOMMAND_WAIT_MC_BUSY_MASK %d\n", count);
		while (count--) {
		    if (!(INPLL(pScrn, RADEON_CLK_PWRMGT_CNTL) &
			  RADEON_MC_BUSY))
			break;
		}
		break;

	    case RADEON_TABLE_SCOMMAND_WAIT_MEM_PWRUP_COMPLETE:
		count = RADEON_BIOS16(offset);
		ErrorF("SCOMMAND_WAIT_MEM_PWRUP_COMPLETE %d\n", count);
		/* may need to take into account how many memory channels
		 * each card has
		 */
		if (IS_R300_VARIANT)
		    channel_complete_mask = R300_MEM_PWRUP_COMPLETE;
		else
		    channel_complete_mask = RADEON_MEM_PWRUP_COMPLETE;
		while (count--) {
		    /* XXX: may need indexed access */
		    if ((INREG(RADEON_MEM_STR_CNTL) &
			 channel_complete_mask) ==
		        channel_complete_mask)
			break;
		}
		break;

	    }
	    offset += 2;
	    break;
	}
    }
}

static void
RADEONRestoreBIOSMemBlock(ScrnInfoPtr pScrn, uint16_t table_offset)
{
    RADEONInfoPtr info = RADEONPTR (pScrn);
    unsigned char *RADEONMMIO = info->MMIO;
    uint16_t offset = table_offset;
    uint16_t count;
    uint32_t ormask, val, channel_complete_mask;
    uint8_t  index;

    if (offset == 0)
	return;

    while ((index = RADEON_BIOS8(offset)) != 0xff) {
	offset++;
	if (index == 0x0f) {
	    count = 20000;
	    ErrorF("MEM_WAIT_MEM_PWRUP_COMPLETE %d\n", count);
	    /* may need to take into account how many memory channels
	     * each card has
	     */
	    if (IS_R300_VARIANT)
		channel_complete_mask = R300_MEM_PWRUP_COMPLETE;
	    else
		channel_complete_mask = RADEON_MEM_PWRUP_COMPLETE;
	    while (count--) {
		/* XXX: may need indexed access */
		if ((INREG(RADEON_MEM_STR_CNTL) &
		     channel_complete_mask) ==
		    channel_complete_mask)
		    break;
	    }
	} else {
	    ormask = RADEON_BIOS16(offset);
	    offset += 2;

	    ErrorF("INDEX RADEON_MEM_SDRAM_MODE_REG %x %x\n",
		   RADEON_SDRAM_MODE_MASK, (unsigned)ormask);

	    /* can this use direct access? */
	    OUTREG(RADEON_MM_INDEX, RADEON_MEM_SDRAM_MODE_REG);
	    val = INREG(RADEON_MM_DATA);
	    val = (val & RADEON_SDRAM_MODE_MASK) | ormask;
	    OUTREG(RADEON_MM_DATA, val);

	    ormask = (uint32_t)index << 24;

	    ErrorF("INDEX RADEON_MEM_SDRAM_MODE_REG %x %x\n",
		   RADEON_B3MEM_RESET_MASK, (unsigned)ormask);

            /* can this use direct access? */
            OUTREG(RADEON_MM_INDEX, RADEON_MEM_SDRAM_MODE_REG);
            val = INREG(RADEON_MM_DATA);
            val = (val & RADEON_B3MEM_RESET_MASK) | ormask;
            OUTREG(RADEON_MM_DATA, val);
	}
    }
}

static void
RADEONRestoreBIOSPllBlock(ScrnInfoPtr pScrn, uint16_t table_offset)
{
    RADEONInfoPtr info = RADEONPTR (pScrn);
    uint16_t offset = table_offset;
    uint8_t  index, shift;
    uint32_t andmask, ormask, val, clk_pwrmgt_cntl;
    uint16_t count;

    if (offset == 0)
	return;

    while ((index = RADEON_BIOS8(offset)) != 0) {
	offset++;

	switch (index & RADEON_PLL_FLAG_MASK) {
	case RADEON_PLL_FLAG_WAIT:
	    switch (index & RADEON_PLL_INDEX_MASK) {
	    case RADEON_PLL_WAIT_150MKS:
		ErrorF("delay: 150 us\n");
		usleep(150);
		break;
	    case RADEON_PLL_WAIT_5MS:
		ErrorF("delay: 5 ms\n");
		usleep(5000);
		break;

	    case RADEON_PLL_WAIT_MC_BUSY_MASK:
		count = 1000;
		ErrorF("PLL_WAIT_MC_BUSY_MASK %d\n", count);
		while (count--) {
		    if (!(INPLL(pScrn, RADEON_CLK_PWRMGT_CNTL) &
			  RADEON_MC_BUSY))
			break;
		}
		break;

	    case RADEON_PLL_WAIT_DLL_READY_MASK:
		count = 1000;
		ErrorF("PLL_WAIT_DLL_READY_MASK %d\n", count);
		while (count--) {
		    if (INPLL(pScrn, RADEON_CLK_PWRMGT_CNTL) &
			RADEON_DLL_READY)
			break;
		}
		break;

	    case RADEON_PLL_WAIT_CHK_SET_CLK_PWRMGT_CNTL24:
		ErrorF("PLL_WAIT_CHK_SET_CLK_PWRMGT_CNTL24\n");
		clk_pwrmgt_cntl = INPLL(pScrn, RADEON_CLK_PWRMGT_CNTL);
		if (clk_pwrmgt_cntl & RADEON_CG_NO1_DEBUG_0) {
		    val = INPLL(pScrn, RADEON_MCLK_CNTL);
		    /* is this right? */
		    val = (val & 0xFFFF0000) | 0x1111; /* seems like we should clear these... */
		    OUTPLL(pScrn, RADEON_MCLK_CNTL, val);
		    usleep(10000);
		    OUTPLL(pScrn, RADEON_CLK_PWRMGT_CNTL,
			   clk_pwrmgt_cntl & ~RADEON_CG_NO1_DEBUG_0);
		    usleep(10000);
		}
		break;
	    }
	    break;
	    
	case RADEON_PLL_FLAG_MASK_BYTE:
	    shift = RADEON_BIOS8(offset) * 8;
	    offset++;

	    andmask =
		(((uint32_t)RADEON_BIOS8(offset)) << shift) |
		~((uint32_t)0xff << shift);
	    offset++;

	    ormask = ((uint32_t)RADEON_BIOS8(offset)) << shift;
	    offset++;

	    ErrorF("PLL_MASK_BYTE 0x%x 0x%x 0x%x 0x%x\n", 
		   index, shift, (unsigned)andmask, (unsigned)ormask);
	    val = INPLL(pScrn, index);
	    val = (val & andmask) | ormask;
	    OUTPLL(pScrn, index, val);
	    break;

	case RADEON_PLL_FLAG_WRITE:
	    val = RADEON_BIOS32(offset);
	    ErrorF("PLL_WRITE 0x%x 0x%x\n", index, (unsigned)val);
	    OUTPLL(pScrn, index, val);
	    offset += 4;
	    break;
	}
    }
}

Bool
RADEONPostCardFromBIOSTables(ScrnInfoPtr pScrn)
{
    RADEONInfoPtr info = RADEONPTR (pScrn);

    if (!info->VBIOS) {
	return FALSE;
    } else {
	if (info->IsAtomBios) {
	    return FALSE;
	} else {
	    if (info->BiosTable.rr1_offset) {
		ErrorF("rr1 restore, 0x%x\n", info->BiosTable.rr1_offset);
		RADEONRestoreBIOSRegBlock(pScrn, info->BiosTable.rr1_offset);
	    }
	    if (info->BiosTable.revision < 0x09) {
		if (info->BiosTable.pll_offset) {
		    ErrorF("pll restore, 0x%x\n", info->BiosTable.pll_offset);
		    RADEONRestoreBIOSPllBlock(pScrn, info->BiosTable.pll_offset);
		}
		if (info->BiosTable.rr2_offset) {
		    ErrorF("rr2 restore, 0x%x\n", info->BiosTable.rr2_offset);
		    RADEONRestoreBIOSRegBlock(pScrn, info->BiosTable.rr2_offset);
		}
		if (info->BiosTable.rr4_offset) {
		    ErrorF("rr4 restore, 0x%x\n", info->BiosTable.rr4_offset);
		    RADEONRestoreBIOSRegBlock(pScrn, info->BiosTable.rr4_offset);
		}
		if (info->BiosTable.mem_reset_offset) {
		    ErrorF("mem reset restore, 0x%x\n", info->BiosTable.mem_reset_offset);
		    RADEONRestoreBIOSMemBlock(pScrn, info->BiosTable.mem_reset_offset);
		}
		if (info->BiosTable.rr3_offset) {
		    ErrorF("rr3 restore, 0x%x\n", info->BiosTable.rr3_offset);
		    RADEONRestoreBIOSRegBlock(pScrn, info->BiosTable.rr3_offset);
		}
		if (info->BiosTable.dyn_clk_offset) {
		    ErrorF("dyn_clk restore, 0x%x\n", info->BiosTable.dyn_clk_offset);
		    RADEONRestoreBIOSPllBlock(pScrn, info->BiosTable.dyn_clk_offset);
		}
	    }
	}
    }
    return TRUE;
}
@


1.7
log
@Update to xf86-video-ati 6.14.6. Tested by mpi@@, brad, eric@@, ajacoutot@@.
@
text
@@


1.6
log
@Re-update xf86-video-ati to 6.14.3.

Because of ati.c revision 1.5, it will not be selected by
autoconfiguration code, so people who want to run this version of the
driver on their radeon cards need an explicit "Device" section in
xorg.conf.
@
text
@d432 1
a432 1
	if (RHDAtomBiosFunc(pScrn->scrnIndex, NULL, ATOMBIOS_INIT, &atomBiosArg)
d439 1
a439 1
	if (RHDAtomBiosFunc(pScrn->scrnIndex, info->atomBIOS, ATOMBIOS_ALLOCATE_FB_SCRATCH,
d446 1
a446 1
	RHDAtomBiosFunc(pScrn->scrnIndex, info->atomBIOS, GET_DEFAULT_ENGINE_CLOCK,
d448 1
a448 1
	RHDAtomBiosFunc(pScrn->scrnIndex, info->atomBIOS, GET_DEFAULT_MEMORY_CLOCK,
d450 1
a450 1
	RHDAtomBiosFunc(pScrn->scrnIndex, info->atomBIOS,
d452 1
a452 1
	RHDAtomBiosFunc(pScrn->scrnIndex, info->atomBIOS,
d454 1
a454 1
	RHDAtomBiosFunc(pScrn->scrnIndex, info->atomBIOS,
d456 1
a456 1
	RHDAtomBiosFunc(pScrn->scrnIndex, info->atomBIOS,
d458 1
a458 1
	RHDAtomBiosFunc(pScrn->scrnIndex, info->atomBIOS,
d460 1
a460 1
	RHDAtomBiosFunc(pScrn->scrnIndex, info->atomBIOS,
@


1.5
log
@Revert the update to xf86-video-ati 6.14.3. Requested by espie@@
who experiemnts regressions with this driver.
@
text
@d37 1
a37 1
#include "xf86PciInfo.h"
a42 1
#include "vbe.h"
d109 56
a164 1
    if (info->ChipFamily >= CHIP_FAMILY_R600) {
d184 1
a184 1
        /* Disable VGA mode */
d330 1
d341 9
d363 1
a363 1
    info->VBIOS = xalloc(size);
d365 1
a365 1
    info->VBIOS = xalloc(RADEON_VBIOS_SIZE);
d383 1
a383 1
	xfree (info->VBIOS);
d398 1
a398 1
	xfree (info->VBIOS);
d408 1
a408 1
	xfree (info->VBIOS);
d535 5
a549 9
    /* Some RV100 cards with 2 VGA ports show up with DVI+VGA */
    if (info->Chipset == PCI_CHIP_RV100_QY &&
	PCI_SUB_VENDOR_ID(info->PciInfo) == 0x1002 &&
	PCI_SUB_DEVICE_ID(info->PciInfo) == 0x013a) {
	if (info->BiosConnector[index].ConnectorType == CONNECTOR_DVI_I) {
	    info->BiosConnector[index].ConnectorType = CONNECTOR_VGA;
	}
    }

d993 1
a993 24
	    pll_info_block = RADEON_BIOS16 (info->MasterDataStart + 12);

	    pll->reference_freq = RADEON_BIOS16 (pll_info_block + 82);
	    pll->reference_div = 0; /* Need to derive from existing setting
					or use a new algorithm to calculate
					from min_input and max_input
				     */
	    pll->pll_out_min = RADEON_BIOS16 (pll_info_block + 78);
	    pll->pll_out_max = RADEON_BIOS32 (pll_info_block + 32);

	    if (pll->pll_out_min == 0) {
		if (IS_AVIVO_VARIANT)
		    pll->pll_out_min = 64800;
		else
		    pll->pll_out_min = 20000;
	    }

	    pll->pll_in_min = RADEON_BIOS16 (pll_info_block + 74);
	    pll->pll_in_max = RADEON_BIOS16 (pll_info_block + 76);

	    pll->xclk = RADEON_BIOS16 (pll_info_block + 72);

	    info->sclk = RADEON_BIOS32(pll_info_block + 8) / 100.0;
	    info->mclk = RADEON_BIOS32(pll_info_block + 12) / 100.0;
a1298 1
		int reg = RADEON_BIOS16(offset + 3 + (i * 5) + 1) * 4;
d1310 8
a1317 8
		i2c.mask_clk_reg = reg;
		i2c.mask_data_reg = reg;
		i2c.a_clk_reg = reg;
		i2c.a_data_reg = reg;
		i2c.put_clk_reg = reg;
		i2c.put_data_reg = reg;
		i2c.get_clk_reg = reg;
		i2c.get_data_reg = reg;
d1381 4
d1403 6
a1408 3
	    else if (gpio_reg == 4)
		dvo->dvo_i2c = legacy_setup_i2c_bus(RADEON_GPIO_CRT2_DDC);
	    else if (gpio_reg == 5) {
@


1.4
log
@Update to xf86-video-ati 6.14.3. Tested by many.
@
text
@d37 1
a37 1
#include "atipciids.h"
d43 1
d110 1
a110 56
    if (info->ChipFamily >= CHIP_FAMILY_RV770) {
	uint32_t viph_control   = INREG(RADEON_VIPH_CONTROL);
	uint32_t bus_cntl       = INREG(RADEON_BUS_CNTL);
	uint32_t d1vga_control  = INREG(AVIVO_D1VGA_CONTROL);
	uint32_t d2vga_control  = INREG(AVIVO_D2VGA_CONTROL);
	uint32_t vga_render_control  = INREG(AVIVO_VGA_RENDER_CONTROL);
	uint32_t rom_cntl       = INREG(R600_ROM_CNTL);
	uint32_t cg_spll_func_cntl = 0;
	uint32_t cg_spll_status;

	/* disable VIP */
	OUTREG(RADEON_VIPH_CONTROL, (viph_control & ~RADEON_VIPH_EN));

	/* enable the rom */
	OUTREG(RADEON_BUS_CNTL, (bus_cntl & ~RADEON_BUS_BIOS_DIS_ROM));

	/* Disable VGA mode */
	OUTREG(AVIVO_D1VGA_CONTROL, (d1vga_control & ~(AVIVO_DVGA_CONTROL_MODE_ENABLE |
						       AVIVO_DVGA_CONTROL_TIMING_SELECT)));
	OUTREG(AVIVO_D2VGA_CONTROL, (d2vga_control & ~(AVIVO_DVGA_CONTROL_MODE_ENABLE |
						       AVIVO_DVGA_CONTROL_TIMING_SELECT)));
	OUTREG(AVIVO_VGA_RENDER_CONTROL, (vga_render_control & ~AVIVO_VGA_VSTATUS_CNTL_MASK));

	if (info->ChipFamily == CHIP_FAMILY_RV730) {
	    cg_spll_func_cntl = INREG(R600_CG_SPLL_FUNC_CNTL);

	    /* enable bypass mode */
	    OUTREG(R600_CG_SPLL_FUNC_CNTL, (cg_spll_func_cntl | R600_SPLL_BYPASS_EN));

	    /* wait for SPLL_CHG_STATUS to change to 1 */
	    cg_spll_status = 0;
	    while (!(cg_spll_status & R600_SPLL_CHG_STATUS))
		cg_spll_status = INREG(R600_CG_SPLL_STATUS);

	    OUTREG(R600_ROM_CNTL, (rom_cntl & ~R600_SCK_OVERWRITE));
	} else
	    OUTREG(R600_ROM_CNTL, (rom_cntl | R600_SCK_OVERWRITE));

	ret = radeon_read_bios(pScrn);

	/* restore regs */
	if (info->ChipFamily == CHIP_FAMILY_RV730) {
	    OUTREG(R600_CG_SPLL_FUNC_CNTL, cg_spll_func_cntl);

	    /* wait for SPLL_CHG_STATUS to change to 1 */
	    cg_spll_status = 0;
	    while (!(cg_spll_status & R600_SPLL_CHG_STATUS))
		cg_spll_status = INREG(R600_CG_SPLL_STATUS);
	}
	OUTREG(RADEON_VIPH_CONTROL, viph_control);
	OUTREG(RADEON_BUS_CNTL, bus_cntl);
	OUTREG(AVIVO_D1VGA_CONTROL, d1vga_control);
	OUTREG(AVIVO_D2VGA_CONTROL, d2vga_control);
	OUTREG(AVIVO_VGA_RENDER_CONTROL, vga_render_control);
	OUTREG(R600_ROM_CNTL, rom_cntl);
    } else if (info->ChipFamily >= CHIP_FAMILY_R600) {
d130 1
a130 1
	/* Disable VGA mode */
a275 1
    /* first check CRTCs */
a285 9
    /* then check MEM_SIZE, in case something turned the crtcs off */
    if (info->ChipFamily >= CHIP_FAMILY_R600)
	reg = INREG(R600_CONFIG_MEMSIZE);
    else
	reg = INREG(RADEON_CONFIG_MEMSIZE);

    if (reg)
	return TRUE;

d299 1
a299 1
    info->VBIOS = malloc(size);
d301 1
a301 1
    info->VBIOS = malloc(RADEON_VBIOS_SIZE);
d319 1
a319 1
	free (info->VBIOS);
d334 1
a334 1
	free (info->VBIOS);
d344 1
a344 1
	free (info->VBIOS);
a470 5
    /* R3xx+ chips don't have GPIO_CRT2_DDC gpio pad */
    if ((IS_R300_VARIANT) &&
	info->BiosConnector[index].ddc_i2c.mask_clk_reg == RADEON_GPIO_CRT2_DDC)
	info->BiosConnector[index].ddc_i2c = legacy_setup_i2c_bus(RADEON_GPIO_DVI_DDC);

d481 9
d933 24
a956 1
	    return RADEONGetATOMClockInfo(pScrn);
d1262 1
d1274 8
a1281 8
		i2c.mask_clk_reg = RADEON_GPIOPAD_MASK;
		i2c.mask_data_reg = RADEON_GPIOPAD_MASK;
		i2c.a_clk_reg = RADEON_GPIOPAD_A;
		i2c.a_data_reg = RADEON_GPIOPAD_A;
		i2c.put_clk_reg = RADEON_GPIOPAD_EN;
		i2c.put_data_reg = RADEON_GPIOPAD_EN;
		i2c.get_clk_reg = RADEON_LCD_GPIO_Y_REG;
		i2c.get_data_reg = RADEON_LCD_GPIO_Y_REG;
a1344 4
	} else {
	    dvo->dvo_i2c_slave_addr = 0x70;
	    dvo->dvo_i2c = RADEONLookupI2CBlock(pScrn, 136);
	    info->ext_tmds_chip = RADEON_SIL_164;
d1363 3
a1365 6
	    else if (gpio_reg == 4) {
		if (IS_R300_VARIANT)
		    dvo->dvo_i2c = legacy_setup_i2c_bus(RADEON_GPIO_MONID);
		else
		    dvo->dvo_i2c = legacy_setup_i2c_bus(RADEON_GPIO_CRT2_DDC);
	    } else if (gpio_reg == 5) {
@


1.3
log
@update do xf86-video-ati 6.12.2

This has been in snapshots for weeks. ok oga@@, todd@@.
@
text
@d37 1
a37 1
#include "xf86PciInfo.h"
a42 1
#include "vbe.h"
d109 56
a164 1
    if (info->ChipFamily >= CHIP_FAMILY_R600) {
d184 1
a184 1
        /* Disable VGA mode */
d330 1
d341 9
d363 1
a363 1
    info->VBIOS = xalloc(size);
d365 1
a365 1
    info->VBIOS = xalloc(RADEON_VBIOS_SIZE);
d383 1
a383 1
	xfree (info->VBIOS);
d398 1
a398 1
	xfree (info->VBIOS);
d408 1
a408 1
	xfree (info->VBIOS);
d535 5
a549 9
    /* Some RV100 cards with 2 VGA ports show up with DVI+VGA */
    if (info->Chipset == PCI_CHIP_RV100_QY &&
	PCI_SUB_VENDOR_ID(info->PciInfo) == 0x1002 &&
	PCI_SUB_DEVICE_ID(info->PciInfo) == 0x013a) {
	if (info->BiosConnector[index].ConnectorType == CONNECTOR_DVI_I) {
	    info->BiosConnector[index].ConnectorType = CONNECTOR_VGA;
	}
    }

d993 1
a993 24
	    pll_info_block = RADEON_BIOS16 (info->MasterDataStart + 12);

	    pll->reference_freq = RADEON_BIOS16 (pll_info_block + 82);
	    pll->reference_div = 0; /* Need to derive from existing setting
					or use a new algorithm to calculate
					from min_input and max_input
				     */
	    pll->pll_out_min = RADEON_BIOS16 (pll_info_block + 78);
	    pll->pll_out_max = RADEON_BIOS32 (pll_info_block + 32);

	    if (pll->pll_out_min == 0) {
		if (IS_AVIVO_VARIANT)
		    pll->pll_out_min = 64800;
		else
		    pll->pll_out_min = 20000;
	    }

	    pll->pll_in_min = RADEON_BIOS16 (pll_info_block + 74);
	    pll->pll_in_max = RADEON_BIOS16 (pll_info_block + 76);

	    pll->xclk = RADEON_BIOS16 (pll_info_block + 72);

	    info->sclk = RADEON_BIOS32(pll_info_block + 8) / 100.0;
	    info->mclk = RADEON_BIOS32(pll_info_block + 12) / 100.0;
a1298 1
		int reg = RADEON_BIOS16(offset + 3 + (i * 5) + 1) * 4;
d1310 8
a1317 8
		i2c.mask_clk_reg = reg;
		i2c.mask_data_reg = reg;
		i2c.a_clk_reg = reg;
		i2c.a_data_reg = reg;
		i2c.put_clk_reg = reg;
		i2c.put_data_reg = reg;
		i2c.get_clk_reg = reg;
		i2c.get_data_reg = reg;
d1381 4
d1403 6
a1408 3
	    else if (gpio_reg == 4)
		dvo->dvo_i2c = legacy_setup_i2c_bus(RADEON_GPIO_CRT2_DDC);
	    else if (gpio_reg == 5) {
@


1.2
log
@Long awaited update of xf86-video-ati to 6.9.0.

the rage128 and mach64 drivers were split out of this driver just after
the 6.8.0 release, these drivers will be commited separately.

MergedFb mode is gone, so please use xrandr if you used to use it.

ok matthieu@@.
@
text
@d101 1
a101 1
radeon_read_unposted_bios(ScrnInfoPtr pScrn)
d269 20
d312 2
a313 3
	} else if (!radeon_read_bios(pScrn)) {
	    (void)radeon_read_unposted_bios(pScrn);
	}
d348 1
a348 1
 
d366 1
a366 1
        AtomBiosArgRec atomBiosArg;
d368 8
a375 8
        if (RHDAtomBiosFunc(pScrn->scrnIndex, NULL, ATOMBIOS_INIT, &atomBiosArg)
            == ATOM_SUCCESS) {
            info->atomBIOS = atomBiosArg.atomhandle;
        }

        atomBiosArg.fb.start = info->FbFreeStart;
        atomBiosArg.fb.size = info->FbFreeSize;
        if (RHDAtomBiosFunc(pScrn->scrnIndex, info->atomBIOS, ATOMBIOS_ALLOCATE_FB_SCRATCH,
d380 1
a380 1
        }
d382 11
a392 11
        RHDAtomBiosFunc(pScrn->scrnIndex, info->atomBIOS, GET_DEFAULT_ENGINE_CLOCK,
                        &atomBiosArg);
        RHDAtomBiosFunc(pScrn->scrnIndex, info->atomBIOS, GET_DEFAULT_MEMORY_CLOCK,
                        &atomBiosArg);
        RHDAtomBiosFunc(pScrn->scrnIndex, info->atomBIOS,
                        GET_MAX_PIXEL_CLOCK_PLL_OUTPUT, &atomBiosArg);
        RHDAtomBiosFunc(pScrn->scrnIndex, info->atomBIOS,
                        GET_MIN_PIXEL_CLOCK_PLL_OUTPUT, &atomBiosArg);
        RHDAtomBiosFunc(pScrn->scrnIndex, info->atomBIOS,
                        GET_MAX_PIXEL_CLOCK_PLL_INPUT, &atomBiosArg);
        RHDAtomBiosFunc(pScrn->scrnIndex, info->atomBIOS,
d394 1
a394 1
        RHDAtomBiosFunc(pScrn->scrnIndex, info->atomBIOS,
d396 2
a397 2
        RHDAtomBiosFunc(pScrn->scrnIndex, info->atomBIOS,
                        GET_REF_CLOCK, &atomBiosArg);
d401 12
d414 2
a415 4
    else {
	/* non-primary card may need posting */
	if (!pInt10) {
	    xf86DrvMsg(pScrn->scrnIndex, X_INFO, "Attempting to POST via BIOS tables\n");
d418 1
d421 1
a421 1
#endif
d430 1
a430 1
    
d444 1
a444 5
    /* on XPRESS chips, CRT2_DDC and MONID_DCC both use the 
     * MONID gpio, but use different pins.
     * CRT2_DDC uses the standard pinout, MONID_DDC uses
     * something else.
     */
a446 1
	info->BiosConnector[index].ConnectorType == CONNECTOR_VGA &&
d449 20
a468 12
    }

    /* XPRESS desktop chips seem to have a proprietary connector listed for
     * DVI-D, try and do the right thing here.
     */
    if ((!info->IsMobility) &&
	(info->BiosConnector[index].ConnectorType == CONNECTOR_LVDS)) {
	xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
		   "Proprietary connector found, assuming DVI-D\n");
	info->BiosConnector[index].DACType = DAC_NONE;
	info->BiosConnector[index].TMDSType = TMDS_EXT;
	info->BiosConnector[index].ConnectorType = CONNECTOR_DVI_D;
d490 20
d535 18
a552 1
		info->BiosConnector[i].ConnectorType = CONNECTOR_LVDS;
d556 19
d578 36
d617 17
d637 8
d648 8
a683 14
	    if (tmp & 0x1)
		info->BiosConnector[i].DACType = DAC_TVDAC;
	    else
		info->BiosConnector[i].DACType = DAC_PRIMARY;

	    /* For RS300/RS350/RS400 chips, there is no primary DAC. Force VGA port to use TVDAC*/
	    if (info->IsIGP)
		info->BiosConnector[i].DACType = DAC_TVDAC;

	    if ((tmp >> 4) & 0x1)
		info->BiosConnector[i].TMDSType = TMDS_EXT;
	    else
		info->BiosConnector[i].TMDSType = TMDS_INT;

d699 1
a699 2
	    info->BiosConnector[0].DACType = DAC_PRIMARY;
	    info->BiosConnector[0].TMDSType = TMDS_INT;
d701 13
d719 2
a720 1
    if (info->IsMobility) {
a724 2
	    info->BiosConnector[4].DACType = DAC_NONE;
	    info->BiosConnector[4].TMDSType = TMDS_NONE;
d727 8
d743 3
d760 4
a763 4
			    info->BiosConnector[4].ddc_i2c.mask_clk_mask =
				RADEON_BIOS32(tmp0 + 0x03) | RADEON_BIOS32(tmp0 + 0x07);
			    info->BiosConnector[4].ddc_i2c.mask_data_mask =
				RADEON_BIOS32(tmp0 + 0x03) | RADEON_BIOS32(tmp0 + 0x07);
d771 4
a774 4
			    info->BiosConnector[4].ddc_i2c.mask_clk_mask =
				RADEON_BIOS32(tmp0 + 0x03) | RADEON_BIOS32(tmp0 + 0x07);
			    info->BiosConnector[4].ddc_i2c.mask_data_mask =
				RADEON_BIOS32(tmp0 + 0x03) | RADEON_BIOS32(tmp0 + 0x07);
d787 1
a787 1
	    } else {
a788 1
	    }
d800 1
a800 2
		info->BiosConnector[5].DACType = DAC_TVDAC;
		info->BiosConnector[5].TMDSType = TMDS_NONE;
d802 7
a812 9
    xf86DrvMsg(pScrn->scrnIndex, X_INFO, "Bios Connector table: \n");
    for (i = 0; i < RADEON_MAX_BIOS_CONNECTOR; i++) {
	if (info->BiosConnector[i].valid) {
	    xf86DrvMsg(pScrn->scrnIndex, X_INFO, "Port%d: DDCType-0x%x, DACType-%d, TMDSType-%d, ConnectorType-%d\n",
		       i, (unsigned int)info->BiosConnector[i].ddc_i2c.mask_clk_reg, info->BiosConnector[i].DACType,
		       info->BiosConnector[i].TMDSType, info->BiosConnector[i].ConnectorType);
	}
    }

d832 1
d837 1
a837 1
    if (info->IsAtomBios) {
d839 1
a839 1
    } else {
d845 1
a845 1
		    radeon_output->default_tvStd = TV_STD_NTSC;
d849 1
a849 1
		    radeon_output->default_tvStd = TV_STD_PAL;
d853 1
a853 1
		    radeon_output->default_tvStd = TV_STD_PAL_M;
d857 1
a857 1
		    radeon_output->default_tvStd = TV_STD_PAL_60;
d861 1
a861 1
		    radeon_output->default_tvStd = TV_STD_NTSC_J;
d865 1
a865 1
		    radeon_output->default_tvStd = TV_STD_SCART_PAL;
d869 1
a869 1
		    radeon_output->default_tvStd = TV_STD_NTSC;
d873 1
a873 1
		radeon_output->tvStd = radeon_output->default_tvStd;
d877 1
a877 1
		    radeon_output->TVRefClk = 29.498928713; /* MHz */
d879 1
a879 1
		    radeon_output->TVRefClk = 28.636360000;
d881 1
a881 1
		    radeon_output->TVRefClk = 14.318180000;
d883 1
a883 1
		    radeon_output->TVRefClk = 27.000000000;
d885 1
a885 1
		radeon_output->SupportedTVStds = radeon_output->default_tvStd;
d889 1
a889 1
		    radeon_output->SupportedTVStds |= TV_STD_NTSC;
d893 1
a893 1
		    radeon_output->SupportedTVStds |= TV_STD_PAL;
d897 1
a897 1
		    radeon_output->SupportedTVStds |= TV_STD_PAL_M;
d901 1
a901 1
		    radeon_output->SupportedTVStds |= TV_STD_PAL_60;
d905 1
a905 1
		    radeon_output->SupportedTVStds |= TV_STD_NTSC_J;
d909 1
a909 1
		    radeon_output->SupportedTVStds |= TV_STD_SCART_PAL;
d979 2
a980 2
	    info->sclk = RADEON_BIOS16(pll_info_block + 8) / 100.0;
	    info->mclk = RADEON_BIOS16(pll_info_block + 10) / 100.0;
d997 1
a997 1
Bool RADEONGetDAC2InfoFromBIOS (xf86OutputPtr output)
a998 1
    ScrnInfoPtr pScrn = output->scrn;
a999 1
    RADEONOutputPrivatePtr radeon_output = output->driver_private;
d1018 1
a1018 1
		radeon_output->ps2_tvdac_adj = (bg << 16) | (dac << 20);
d1022 1
a1022 1
		radeon_output->pal_tvdac_adj = (bg << 16) | (dac << 20);
d1026 1
a1026 1
		radeon_output->ntsc_tvdac_adj = (bg << 16) | (dac << 20);
d1032 1
a1032 1
		radeon_output->ps2_tvdac_adj = (bg << 16) | (dac << 20);
d1036 1
a1036 1
		radeon_output->pal_tvdac_adj = (bg << 16) | (dac << 20);
d1040 1
a1040 1
		radeon_output->ntsc_tvdac_adj = (bg << 16) | (dac << 20);
d1052 3
a1054 3
		radeon_output->ps2_tvdac_adj = (bg << 16) | (dac << 20);
		radeon_output->pal_tvdac_adj = radeon_output->ps2_tvdac_adj;
		radeon_output->ntsc_tvdac_adj = radeon_output->ps2_tvdac_adj;
d1060 3
a1062 3
		radeon_output->ps2_tvdac_adj = (bg << 16) | (dac << 20);
		radeon_output->pal_tvdac_adj = radeon_output->ps2_tvdac_adj;
		radeon_output->ntsc_tvdac_adj = radeon_output->ps2_tvdac_adj;
d1072 2
a1073 1
Bool RADEONGetLVDSInfoFromBIOS (xf86OutputPtr output)
a1074 1
    ScrnInfoPtr pScrn = output->scrn;
d1076 1
a1076 1
    RADEONOutputPrivatePtr radeon_output = output->driver_private;
d1079 2
a1080 26
    if (!info->VBIOS) return FALSE;

    if (info->IsAtomBios) {
	if((tmp = RADEON_BIOS16 (info->MasterDataStart + 16))) {

	    radeon_output->PanelXRes = RADEON_BIOS16(tmp+6);
	    radeon_output->PanelYRes = RADEON_BIOS16(tmp+10);
	    radeon_output->DotClock   = RADEON_BIOS16(tmp+4)*10;
	    radeon_output->HBlank     = RADEON_BIOS16(tmp+8);
	    radeon_output->HOverPlus  = RADEON_BIOS16(tmp+14);
	    radeon_output->HSyncWidth = RADEON_BIOS16(tmp+16);
	    radeon_output->VBlank     = RADEON_BIOS16(tmp+12);
	    radeon_output->VOverPlus  = RADEON_BIOS16(tmp+18);
	    radeon_output->VSyncWidth = RADEON_BIOS16(tmp+20);
	    radeon_output->PanelPwrDly = RADEON_BIOS16(tmp+40);

	    if (radeon_output->PanelPwrDly > 2000 || radeon_output->PanelPwrDly < 0)
		radeon_output->PanelPwrDly = 2000;

	    radeon_output->Flags = 0;
	} else {
	    xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
		       "No LVDS Info Table found in BIOS!\n");
	    return FALSE;
	}
    } else {
d1082 1
d1100 2
a1101 2
	    radeon_output->PanelXRes = RADEON_BIOS16(tmp+25);
	    radeon_output->PanelYRes = RADEON_BIOS16(tmp+27);
d1103 5
a1107 5
		       radeon_output->PanelXRes, radeon_output->PanelYRes);
	
	    radeon_output->PanelPwrDly = RADEON_BIOS16(tmp+44);
	    if (radeon_output->PanelPwrDly > 2000 || radeon_output->PanelPwrDly < 0)
		radeon_output->PanelPwrDly = 2000;
d1128 14
a1141 14
		if ((RADEON_BIOS16(tmp0) == radeon_output->PanelXRes) &&
		    (RADEON_BIOS16(tmp0+2) == radeon_output->PanelYRes)) {
		    radeon_output->HBlank     = (RADEON_BIOS16(tmp0+17) -
					RADEON_BIOS16(tmp0+19)) * 8;
		    radeon_output->HOverPlus  = (RADEON_BIOS16(tmp0+21) -
					RADEON_BIOS16(tmp0+19) - 1) * 8;
		    radeon_output->HSyncWidth = RADEON_BIOS8(tmp0+23) * 8;
		    radeon_output->VBlank     = (RADEON_BIOS16(tmp0+24) -
					RADEON_BIOS16(tmp0+26));
		    radeon_output->VOverPlus  = ((RADEON_BIOS16(tmp0+28) & 0x7ff) -
					RADEON_BIOS16(tmp0+26));
		    radeon_output->VSyncWidth = ((RADEON_BIOS16(tmp0+28) & 0xf800) >> 11);
		    radeon_output->DotClock   = RADEON_BIOS16(tmp0+9) * 10;
		    radeon_output->Flags = 0;
a1144 1
    }
d1146 8
a1153 8
    xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
	       "LVDS Info:\n"
	       "XRes: %d, YRes: %d, DotClock: %d\n"
	       "HBlank: %d, HOverPlus: %d, HSyncWidth: %d\n"
	       "VBlank: %d, VOverPlus: %d, VSyncWidth: %d\n",
	       radeon_output->PanelXRes, radeon_output->PanelYRes, radeon_output->DotClock,
	       radeon_output->HBlank, radeon_output->HOverPlus, radeon_output->HSyncWidth,
	       radeon_output->VBlank, radeon_output->VOverPlus, radeon_output->VSyncWidth);
d1155 3
a1157 1
    return TRUE;
d1160 1
a1160 1
Bool RADEONGetHardCodedEDIDFromBIOS (xf86OutputPtr output)
d1163 1
a1163 2
    RADEONInfoPtr  info       = RADEONPTR(pScrn);
    RADEONOutputPrivatePtr radeon_output = output->driver_private;
d1165 2
a1166 1
    char EDID[256];
d1168 2
a1169 1
    if (!info->VBIOS) return FALSE;
d1171 6
a1176 6
    if (info->IsAtomBios) {
	/* Not yet */
	return FALSE;
    } else {
	if (!(tmp = RADEON_BIOS16(info->ROMHeaderStart + 0x4c))) {
	    return FALSE;
d1178 1
d1180 1
a1180 15
	memcpy(EDID, (char*)(info->VBIOS + tmp), 256);

	radeon_output->DotClock = (*(uint16_t*)(EDID+54)) * 10;
	radeon_output->PanelXRes = (*(uint8_t*)(EDID+56)) + ((*(uint8_t*)(EDID+58))>>4)*256;
	radeon_output->HBlank = (*(uint8_t*)(EDID+57)) + ((*(uint8_t*)(EDID+58)) & 0xf)*256;
	radeon_output->HOverPlus = (*(uint8_t*)(EDID+62)) + ((*(uint8_t*)(EDID+65)>>6)*256);
	radeon_output->HSyncWidth = (*(uint8_t*)(EDID+63)) + (((*(uint8_t*)(EDID+65)>>4) & 3)*256);
	radeon_output->PanelYRes = (*(uint8_t*)(EDID+59)) + ((*(uint8_t*)(EDID+61))>>4)*256;
	radeon_output->VBlank = ((*(uint8_t*)(EDID+60)) + ((*(uint8_t*)(EDID+61)) & 0xf)*256);
	radeon_output->VOverPlus = (((*(uint8_t*)(EDID+64))>>4) + (((*(uint8_t*)(EDID+65)>>2) & 3)*16));
	radeon_output->VSyncWidth = (((*(uint8_t*)(EDID+64)) & 0xf) + ((*(uint8_t*)(EDID+65)) & 3)*256);
	radeon_output->Flags      = V_NHSYNC | V_NVSYNC; /**(uint8_t*)(EDID+71);*/
	xf86DrvMsg(pScrn->scrnIndex, X_INFO, "Hardcoded EDID data will be used for TMDS panel\n");
    }
    return TRUE;
d1183 1
a1183 1
Bool RADEONGetTMDSInfoFromBIOS (xf86OutputPtr output)
a1184 1
    ScrnInfoPtr pScrn = output->scrn;
a1185 1
    RADEONOutputPrivatePtr radeon_output = output->driver_private;
d1195 1
a1195 1
	    
d1197 1
a1197 1
		radeon_output->tmds_pll[i].freq = RADEON_BIOS16(tmp+i*6+6);
d1199 1
a1199 1
		radeon_output->tmds_pll[i].value = ((RADEON_BIOS8(tmp+i*6+8) & 0x3f) |
d1203 7
a1209 7
		xf86DrvMsg(pScrn->scrnIndex, X_INFO, 
			   "TMDS PLL from BIOS: %u %x\n", 
			   (unsigned)radeon_output->tmds_pll[i].freq,
			   (unsigned)radeon_output->tmds_pll[i].value);
		       
		if (maxfreq == radeon_output->tmds_pll[i].freq) {
		    radeon_output->tmds_pll[i].freq = 0xffffffff;
d1225 2
a1226 2
		    radeon_output->tmds_pll[i].value = RADEON_BIOS32(tmp+i*10+0x08);
		    radeon_output->tmds_pll[i].freq = RADEON_BIOS16(tmp+i*10+0x10);
d1234 2
a1235 2
		    radeon_output->tmds_pll[i].value = RADEON_BIOS32(tmp+stride+0x08);
		    radeon_output->tmds_pll[i].freq = RADEON_BIOS16(tmp+stride+0x10);
d1246 45
a1290 1
Bool RADEONGetExtTMDSInfoFromBIOS (xf86OutputPtr output)
a1291 1
    ScrnInfoPtr pScrn = output->scrn;
a1292 1
    RADEONOutputPrivatePtr radeon_output = output->driver_private;
d1295 2
a1296 1
    if (!info->VBIOS) return FALSE;
d1298 1
a1298 1
    if (info->IsAtomBios) {
d1300 46
d1354 2
a1355 2
	    radeon_output->dvo_i2c_slave_addr = RADEON_BIOS8(table_start+2);
	    radeon_output->dvo_i2c.valid = FALSE;
d1358 1
a1358 1
		radeon_output->dvo_i2c = legacy_setup_i2c_bus(RADEON_GPIO_MONID);
d1360 1
a1360 1
		radeon_output->dvo_i2c = legacy_setup_i2c_bus(RADEON_GPIO_DVI_DDC);
d1362 1
a1362 1
		radeon_output->dvo_i2c = legacy_setup_i2c_bus(RADEON_GPIO_VGA_DDC);
d1364 2
a1365 2
		radeon_output->dvo_i2c = legacy_setup_i2c_bus(RADEON_GPIO_CRT2_DDC);
	    else if (gpio_reg == 5)
d1368 2
a1369 1
	    else {
d1375 2
a1376 2
	    radeon_output->dvo_duallink = flags & 0x01;
	    if (radeon_output->dvo_duallink) {
d1395 2
a1396 1
    RADEONOutputPrivatePtr radeon_output = output->driver_private;
d1398 4
a1401 1
    uint32_t val, reg, andmask, ormask;
d1403 7
a1409 1
    if (!info->VBIOS) return FALSE;
d1411 1
a1411 1
    if (info->IsAtomBios) {
d1413 70
d1492 1
a1492 1
		    reg = id & 0x1fff;
d1495 1
a1495 1
		    ErrorF("WRITE INDEXED: 0x%x 0x%x\n",
d1497 1
a1497 1
		    /*OUTREG(reg, val);*/
d1500 2
a1501 2
		    reg = id & 0x1fff;
		    andmask = RADEON_BIOS32(index);
d1503 1
a1503 1
		    ormask = RADEON_BIOS32(index);
d1506 4
a1509 4
		    val = (val & andmask) | ormask;
		    ErrorF("MASK DIRECT: 0x%x 0x%x 0x%x\n",
			   (unsigned)reg, (unsigned)andmask, (unsigned)ormask);
		    /*OUTREG(reg, val);*/
d1519 1
a1519 1
		    andmask = RADEON_BIOS32(index);
d1521 1
a1521 1
		    ormask = RADEON_BIOS32(index);
d1523 5
a1527 5
		    ErrorF("MASK PLL: 0x%x 0x%x 0x%x\n",
			   (unsigned)reg, (unsigned)andmask, (unsigned)ormask);
		    /*val = INPLL(pScrn, reg);
		    val = (val & andmask) | ormask;
		    OUTPLL(pScrn, reg, val);*/
d1535 1
a1535 1
		    RADEONDVOWriteByte(radeon_output->DVOChip, reg, val);
@


1.1
log
@Initial revision
@
text
@a0 1
/* $XFree86: xc/programs/Xserver/hw/xfree86/drivers/ati/radeon_bios.c,v 1.0 Exp $ */
d37 1
d42 1
d45 224
d270 2
a271 1
Bool RADEONGetBIOSInfo(ScrnInfoPtr pScrn, xf86Int10InfoPtr  pInt10)
d277 7
a283 1
    if (!(info->VBIOS = xalloc(RADEON_VBIOS_SIZE))) {
d292 2
a293 12
	} else {
	    xf86ReadPciBIOS(0, info->PciTag, 0, info->VBIOS, RADEON_VBIOS_SIZE);
	    if (info->VBIOS[0] != 0x55 || info->VBIOS[1] != 0xaa) {
		xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
			   "Video BIOS not detected in PCI space!\n");
		xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
			   "Attempting to read Video BIOS from "
			   "legacy ISA space!\n");
		info->BIOSAddr = 0x000c0000;
		xf86ReadDomainMemory(info->PciTag, info->BIOSAddr,
				     RADEON_VBIOS_SIZE, info->VBIOS);
	    }
a342 3
    if (info->IsAtomBios) 
	info->MasterDataStart = RADEON_BIOS16 (info->ROMHeaderStart + 32);

d346 46
d395 65
a459 1
Bool RADEONGetConnectorInfoFromBIOS (ScrnInfoPtr pScrn)
d462 5
a466 2
    RADEONEntPtr pRADEONEnt = RADEONEntPriv(pScrn);
    int i = 0, j, tmp, tmp0=0, tmp1=0;
d468 4
a471 1
    if(!info->VBIOS) return FALSE;
d473 31
a503 23
    if (info->IsAtomBios) {
	if((tmp = RADEON_BIOS16 (info->MasterDataStart + 22))) {
	    int crtc = 0, id[2];
	    tmp1 = RADEON_BIOS16 (tmp + 4);
	    for (i=0; i<8; i++) {
		if(tmp1 & (1<<i)) {
		    CARD16 portinfo = RADEON_BIOS16(tmp+6+i*2);
		    if (crtc < 2) {
			if ((i==2) || (i==6)) continue; /* ignore TV here */

			if (crtc == 1) {
			    /* sharing same port with id[0] */
			    if (((portinfo>>8) & 0xf) == id[0]) {
				if (i == 3) 
				    pRADEONEnt->PortInfo[0].TMDSType = TMDS_INT;
				else if (i == 7)
				    pRADEONEnt->PortInfo[0].TMDSType = TMDS_EXT;

				if (pRADEONEnt->PortInfo[0].DACType == DAC_UNKNOWN)
				    pRADEONEnt->PortInfo[0].DACType = (portinfo & 0xf) - 1;
				continue;
			    }
			}
d505 1
a505 27
			id[crtc] = (portinfo>>8) & 0xf; 
			pRADEONEnt->PortInfo[crtc].DACType = (portinfo & 0xf) - 1;
			pRADEONEnt->PortInfo[crtc].ConnectorType = (portinfo>>4) & 0xf;
			if (i == 3) 
			    pRADEONEnt->PortInfo[crtc].TMDSType = TMDS_INT;
			else if (i == 7)
			    pRADEONEnt->PortInfo[crtc].TMDSType = TMDS_EXT;
			
			if((tmp0 = RADEON_BIOS16 (info->MasterDataStart + 24)) && id[crtc]) {
			    switch (RADEON_BIOS16 (tmp0 + 4 + 27 * id[crtc]) * 4) 
			    {
			    case RADEON_GPIO_MONID:
				pRADEONEnt->PortInfo[crtc].DDCType = DDC_MONID;
				break;
			    case RADEON_GPIO_DVI_DDC:
				pRADEONEnt->PortInfo[crtc].DDCType = DDC_DVI;
				break;
			    case RADEON_GPIO_VGA_DDC:
				pRADEONEnt->PortInfo[crtc].DDCType = DDC_VGA;
				break;
			    case RADEON_GPIO_CRT2_DDC:
				pRADEONEnt->PortInfo[crtc].DDCType = DDC_CRT2;
				break;
			    default:
				pRADEONEnt->PortInfo[crtc].DDCType = DDC_NONE_DETECTED;
				break;
			    }
d507 17
a523 21
			} else {
			    pRADEONEnt->PortInfo[crtc].DDCType = DDC_NONE_DETECTED;
			}
			crtc++;
		    } else {
			/* we have already had two CRTCs assigned. the rest may share the same
			 * port with the existing connector, fill in them accordingly.
			 */
			for (j=0; j<2; j++) {
			    if (((portinfo>>8) & 0xf) == id[j]) {
				if (i == 3) 
				    pRADEONEnt->PortInfo[j].TMDSType = TMDS_INT;
				else if (i == 7)
				    pRADEONEnt->PortInfo[j].TMDSType = TMDS_EXT;

				if (pRADEONEnt->PortInfo[j].DACType == DAC_UNKNOWN)
				    pRADEONEnt->PortInfo[j].DACType = (portinfo & 0xf) - 1;
			    }
			}
		    }
		}
d526 16
a541 8
	    for (i=0; i<2; i++) {
		xf86DrvMsg(pScrn->scrnIndex, X_INFO, "Port%d: DDCType-%d, DACType-%d, TMDSType-%d, ConnectorType-%d\n",
			   i, pRADEONEnt->PortInfo[i].DDCType, pRADEONEnt->PortInfo[i].DACType,
			   pRADEONEnt->PortInfo[i].TMDSType, pRADEONEnt->PortInfo[i].ConnectorType);
	    }	    
	} else {
	    xf86DrvMsg(pScrn->scrnIndex, X_WARNING, "No Device Info Table found!\n");
	    return FALSE;
d544 4
a547 8
	/* Some laptops only have one connector (VGA) listed in the connector table, 
	 * we need to add LVDS in as a non-DDC display. 
	 * Note, we can't assume the listed VGA will be filled in PortInfo[0],
	 * when walking through connector table. connector_found has following meaning: 
	 * 0 -- nothing found, 
	 * 1 -- only PortInfo[0] filled, 
	 * 2 -- only PortInfo[1] filled,
	 * 3 -- both are filled.
d549 10
a558 35
	int connector_found = 0;

	if ((tmp = RADEON_BIOS16(info->ROMHeaderStart + 0x50))) {
	    for (i = 1; i < 4; i++) {

		if (!RADEON_BIOS16(tmp + i*2))
			break; /* end of table */
		
		tmp0 = RADEON_BIOS16(tmp + i*2);
		if (((tmp0 >> 12) & 0x0f) == 0) continue;     /* no connector */
		if (connector_found > 0) {
		    if (pRADEONEnt->PortInfo[tmp1].DDCType == ((tmp0 >> 8) & 0x0f))
			continue;                             /* same connector */
		}

		/* internal DDC_DVI port will get assigned to PortInfo[0], or if there is no DDC_DVI (like in some IGPs). */
		tmp1 = ((((tmp0 >> 8) & 0xf) == DDC_DVI) || (tmp1 == 1)) ? 0 : 1; /* determine port info index */
		
		pRADEONEnt->PortInfo[tmp1].DDCType        = (tmp0 >> 8) & 0x0f;
		if (pRADEONEnt->PortInfo[tmp1].DDCType > DDC_CRT2) pRADEONEnt->PortInfo[tmp1].DDCType = DDC_NONE_DETECTED;
		pRADEONEnt->PortInfo[tmp1].DACType        = (tmp0 & 0x01) ? DAC_TVDAC : DAC_PRIMARY;
		pRADEONEnt->PortInfo[tmp1].ConnectorType  = (tmp0 >> 12) & 0x0f;
		if (pRADEONEnt->PortInfo[tmp1].ConnectorType > CONNECTOR_UNSUPPORTED) pRADEONEnt->PortInfo[tmp1].ConnectorType = CONNECTOR_UNSUPPORTED;
		pRADEONEnt->PortInfo[tmp1].TMDSType       = ((tmp0 >> 4) & 0x01) ? TMDS_EXT : TMDS_INT;

		/* some sanity checks */
		if (((pRADEONEnt->PortInfo[tmp1].ConnectorType != CONNECTOR_DVI_D) &&
		     (pRADEONEnt->PortInfo[tmp1].ConnectorType != CONNECTOR_DVI_I)) &&
		    pRADEONEnt->PortInfo[tmp1].TMDSType == TMDS_INT)
		    pRADEONEnt->PortInfo[tmp1].TMDSType = TMDS_UNKNOWN;
		
		connector_found += (tmp1 + 1);
	    }
	} else {
	    xf86DrvMsg(pScrn->scrnIndex, X_WARNING, "No Connector Info Table found!\n");
d560 1
a560 1
	}
d562 55
a616 29
	if (info->IsMobility) {
	    /* For the cases where only one VGA connector is found, 
	       we assume LVDS is not listed in the connector table, 
	       add it in here as the first port.
	    */
	    if ((connector_found < 3) && (pRADEONEnt->PortInfo[tmp1].ConnectorType == CONNECTOR_CRT)) {
		if (connector_found == 1) {
		    memcpy (&pRADEONEnt->PortInfo[1], &pRADEONEnt->PortInfo[0], 
			    sizeof (pRADEONEnt->PortInfo[0]));
		}
		pRADEONEnt->PortInfo[0].DACType = DAC_TVDAC;
		pRADEONEnt->PortInfo[0].TMDSType = TMDS_UNKNOWN;
		pRADEONEnt->PortInfo[0].DDCType = DDC_NONE_DETECTED;
		pRADEONEnt->PortInfo[0].ConnectorType = CONNECTOR_PROPRIETARY;

		xf86DrvMsg(pScrn->scrnIndex, X_INFO, "LVDS port is not in connector table, added in.\n");
		if (connector_found == 0) connector_found = 1;
		else connector_found = 3;
	    }

	    if ((tmp = RADEON_BIOS16(info->ROMHeaderStart + 0x42))) {
	        if ((tmp0 = RADEON_BIOS16(tmp + 0x15))) {
		    if ((tmp1 = RADEON_BIOS8(tmp0+2) & 0x07)) {	    
			pRADEONEnt->PortInfo[0].DDCType	= tmp1;      
			if (pRADEONEnt->PortInfo[0].DDCType > DDC_CRT2) {
			    xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
				       "Unknown DDCType %d found\n",
				       pRADEONEnt->PortInfo[0].DDCType);
			    pRADEONEnt->PortInfo[0].DDCType = DDC_NONE_DETECTED;
d621 18
a638 9
	    } 
	} else if (connector_found == 2) {
	    memcpy (&pRADEONEnt->PortInfo[0], &pRADEONEnt->PortInfo[1], 
		    sizeof (pRADEONEnt->PortInfo[0]));	
	    pRADEONEnt->PortInfo[1].DACType = DAC_UNKNOWN;
	    pRADEONEnt->PortInfo[1].TMDSType = TMDS_UNKNOWN;
	    pRADEONEnt->PortInfo[1].DDCType = DDC_NONE_DETECTED;
	    pRADEONEnt->PortInfo[1].ConnectorType = CONNECTOR_NONE;
	    connector_found = 1;
d640 1
d642 6
a647 11
	if (connector_found == 0) {
	    xf86DrvMsg(pScrn->scrnIndex, X_WARNING, "No connector found in Connector Info Table.\n");
	} else {
	    xf86DrvMsg(0, X_INFO, "Connector0: DDCType-%d, DACType-%d, TMDSType-%d, ConnectorType-%d\n",
		       pRADEONEnt->PortInfo[0].DDCType, pRADEONEnt->PortInfo[0].DACType,
		       pRADEONEnt->PortInfo[0].TMDSType, pRADEONEnt->PortInfo[0].ConnectorType);
	}
	if (connector_found == 3) {
	    xf86DrvMsg(0, X_INFO, "Connector1: DDCType-%d, DACType-%d, TMDSType-%d, ConnectorType-%d\n",
		       pRADEONEnt->PortInfo[1].DDCType, pRADEONEnt->PortInfo[1].DACType,
		       pRADEONEnt->PortInfo[1].TMDSType, pRADEONEnt->PortInfo[1].ConnectorType);
d649 8
d658 13
a670 3
#if 0
/* External TMDS Table, not used now */
        if ((tmp0 = RADEON_BIOS16(info->ROMHeaderStart + 0x58))) {
d672 1
a672 4
            //pRADEONEnt->PortInfo[1].DDCType = (RADEON_BIOS8(tmp0 + 7) & 0x07);
            //pRADEONEnt->PortInfo[1].ConnectorType  = CONNECTOR_DVI_I;
            //pRADEONEnt->PortInfo[1].TMDSType = TMDS_EXT;
            xf86DrvMsg(pScrn->scrnIndex, X_INFO, "External TMDS found.\n");
d674 37
a710 2
        } else {
            xf86DrvMsg(pScrn->scrnIndex, X_INFO, "NO External TMDS Info found\n");
d712 38
a749 2
        }
#endif
d751 3
d755 1
a755 1
    return TRUE;
d764 1
a764 1
    CARD16 pll_info_block;
d777 13
a789 2
	    pll->min_pll_freq = RADEON_BIOS16 (pll_info_block + 78);
	    pll->max_pll_freq = RADEON_BIOS32 (pll_info_block + 32);
d794 2
a795 5
	    if (info->sclk == 0) info->sclk = 200;
	    if (info->mclk == 0) info->mclk = 200;
		
	    xf86DrvMsg(pScrn->scrnIndex, X_INFO, "ref_freq: %d, min_pll: %ld, max_pll: %ld, xclk: %d, sclk: %f, mclk: %f\n",
		       pll->reference_freq, pll->min_pll_freq, pll->max_pll_freq, pll->xclk, info->sclk, info->mclk);
a796 1
	} else {
d799 2
d803 12
a814 3
	    pll->min_pll_freq = RADEON_BIOS32 (pll_info_block + 0x12);
	    pll->max_pll_freq = RADEON_BIOS32 (pll_info_block + 0x16);
	    pll->xclk = RADEON_BIOS16 (pll_info_block + 0x08);
d819 3
d824 7
d834 1
a834 1
Bool RADEONGetLVDSInfoFromBIOS (ScrnInfoPtr pScrn)
d836 80
a915 1
    RADEONInfoPtr info     = RADEONPTR(pScrn);
d923 15
a937 20
	    info->PanelXRes = RADEON_BIOS16(tmp+6);
	    info->PanelYRes = RADEON_BIOS16(tmp+10);
	    info->DotClock   = RADEON_BIOS16(tmp+4)*10;
	    info->HBlank     = RADEON_BIOS16(tmp+8);
	    info->HOverPlus  = RADEON_BIOS16(tmp+14);
	    info->HSyncWidth = RADEON_BIOS16(tmp+16);
	    info->VBlank     = RADEON_BIOS16(tmp+12);
	    info->VOverPlus  = RADEON_BIOS16(tmp+18);
	    info->VSyncWidth = RADEON_BIOS16(tmp+20);
	    info->PanelPwrDly = RADEON_BIOS16(tmp+40);

	    info->Flags = 0;
	    xf86DrvMsg(pScrn->scrnIndex, X_WARNING, 
		       "LVDS Info:\n"
		       "XRes: %d, YRes: %d, DotClock: %d\n"
		       "HBlank: %d, HOverPlus: %d, HSyncWidth: %d\n"
		       "VBlank: %d, VOverPlus: %d, VSyncWidth: %d\n",
		       info->PanelXRes, info->PanelYRes, info->DotClock,
		       info->HBlank,info->HOverPlus, info->HSyncWidth,
		       info->VBlank, info->VOverPlus, info->VSyncWidth);
d962 2
a963 2
	    info->PanelXRes = RADEON_BIOS16(tmp+25);
	    info->PanelYRes = RADEON_BIOS16(tmp+27);
d965 1
a965 1
		       info->PanelXRes, info->PanelYRes);
d967 3
a969 3
	    info->PanelPwrDly = RADEON_BIOS16(tmp+44);
	    if (info->PanelPwrDly > 2000 || info->PanelPwrDly < 0)
		info->PanelPwrDly = 2000;
d990 3
a992 3
		if ((RADEON_BIOS16(tmp0) == info->PanelXRes) &&
		    (RADEON_BIOS16(tmp0+2) == info->PanelYRes)) {
		    info->HBlank     = (RADEON_BIOS16(tmp0+17) -
d994 1
a994 1
		    info->HOverPlus  = (RADEON_BIOS16(tmp0+21) -
d996 2
a997 2
		    info->HSyncWidth = RADEON_BIOS8(tmp0+23) * 8;
		    info->VBlank     = (RADEON_BIOS16(tmp0+24) -
d999 1
a999 1
		    info->VOverPlus  = ((RADEON_BIOS16(tmp0+28) & 0x7ff) -
d1001 3
a1003 3
		    info->VSyncWidth = ((RADEON_BIOS16(tmp0+28) & 0xf800) >> 11);
		    info->DotClock   = RADEON_BIOS16(tmp0+9) * 10;
		    info->Flags = 0;
d1008 10
d1021 1
a1021 1
Bool RADEONGetHardCodedEDIDFromBIOS (ScrnInfoPtr pScrn)
d1023 3
a1025 1
    RADEONInfoPtr info     = RADEONPTR(pScrn);
d1041 10
a1050 10
	info->DotClock = (*(CARD16*)(EDID+54)) * 10;
	info->PanelXRes = (*(CARD8*)(EDID+56)) + ((*(CARD8*)(EDID+58))>>4)*256;
	info->HBlank = (*(CARD8*)(EDID+57)) + ((*(CARD8*)(EDID+58)) & 0xf)*256;
	info->HOverPlus = (*(CARD8*)(EDID+62)) + ((*(CARD8*)(EDID+65)>>6)*256);
	info->HSyncWidth = (*(CARD8*)(EDID+63)) + (((*(CARD8*)(EDID+65)>>4) & 3)*256);
	info->PanelYRes = (*(CARD8*)(EDID+59)) + ((*(CARD8*)(EDID+61))>>4)*256;
	info->VBlank = ((*(CARD8*)(EDID+60)) + ((*(CARD8*)(EDID+61)) & 0xf)*256);
	info->VOverPlus = (((*(CARD8*)(EDID+64))>>4) + (((*(CARD8*)(EDID+65)>>2) & 3)*16));
	info->VSyncWidth = (((*(CARD8*)(EDID+64)) & 0xf) + ((*(CARD8*)(EDID+65)) & 3)*256);
	info->Flags      = V_NHSYNC | V_NVSYNC; /**(CARD8*)(EDID+71);*/
d1056 1
a1056 1
Bool RADEONGetTMDSInfoFromBIOS (ScrnInfoPtr pScrn)
d1058 4
a1061 2
    RADEONInfoPtr info     = RADEONPTR(pScrn);
    CARD32 tmp, maxfreq;
d1072 1
a1072 1
		info->tmds_pll[i].freq = RADEON_BIOS16(tmp+i*6+6);
d1074 1
a1074 1
		info->tmds_pll[i].value = ((RADEON_BIOS8(tmp+i*6+8) & 0x3f) |
d1079 3
a1081 2
			   "TMDS PLL from BIOS: %ld %lx\n", 
			   info->tmds_pll[i].freq, info->tmds_pll[i].value);
d1083 2
a1084 2
		if (maxfreq == info->tmds_pll[i].freq) {
		    info->tmds_pll[i].freq = 0xffffffff;
d1100 2
a1101 2
		    info->tmds_pll[i].value = RADEON_BIOS32(tmp+i*10+0x08);
		    info->tmds_pll[i].freq = RADEON_BIOS16(tmp+i*10+0x10);
d1109 2
a1110 2
		    info->tmds_pll[i].value = RADEON_BIOS32(tmp+stride+0x08);
		    info->tmds_pll[i].freq = RADEON_BIOS16(tmp+stride+0x10);
d1116 55
d1172 77
a1248 16
	    /* revision 4 has some problem as it appears in RV280, 
	       comment it off for now, use default instead */ 
	    /*    
		  else if (RADEON_BIOS8(tmp) == 4) {
		  int stride = 0;
		  n = RADEON_BIOS8(tmp + 5) + 1;
		  if (n > 4) n = 4;
		  for (i=0; i<n; i++) {
		  info->tmds_pll[i].value = RADEON_BIOS32(tmp+stride+0x08);
		  info->tmds_pll[i].freq = RADEON_BIOS16(tmp+stride+0x10);
		  if (i == 0) stride += 10;
		  else stride += 6;
		  }
		  return TRUE;
		  }
	    */  
d1251 1
d1253 461
@


1.1.1.1
log
@Importing xf86-video-ati 6.6.3
@
text
@@
