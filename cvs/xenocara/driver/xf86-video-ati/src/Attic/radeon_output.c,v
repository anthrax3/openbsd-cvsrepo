head	1.11;
access;
symbols
	OPENBSD_5_4:1.10.0.4
	OPENBSD_5_4_BASE:1.10
	OPENBSD_5_3:1.10.0.2
	OPENBSD_5_3_BASE:1.10
	OPENBSD_5_2:1.9.0.2
	OPENBSD_5_2_BASE:1.9
	OPENBSD_5_1_BASE:1.6
	OPENBSD_5_1:1.6.0.2
	OPENBSD_5_0:1.3.0.8
	OPENBSD_5_0_BASE:1.3
	OPENBSD_4_9:1.3.0.4
	OPENBSD_4_9_BASE:1.3
	OPENBSD_4_8:1.3.0.6
	OPENBSD_4_8_BASE:1.3
	OPENBSD_4_7:1.3.0.2
	OPENBSD_4_7_BASE:1.3
	OPENBSD_4_6:1.2.0.2
	OPENBSD_4_6_BASE:1.2
	OPENBSD_4_5:1.1.0.4
	OPENBSD_4_5_BASE:1.1
	OPENBSD_4_4:1.1.0.2
	OPENBSD_4_4_BASE:1.1;
locks; strict;
comment	@ * @;


1.11
date	2013.08.16.17.04.12;	author matthieu;	state dead;
branches;
next	1.10;

1.10
date	2012.08.08.16.25.22;	author matthieu;	state Exp;
branches;
next	1.9;

1.9
date	2012.07.08.13.42.13;	author matthieu;	state Exp;
branches;
next	1.8;

1.8
date	2012.06.07.20.55.34;	author matthieu;	state Exp;
branches;
next	1.7;

1.7
date	2012.03.04.16.01.20;	author matthieu;	state Exp;
branches;
next	1.6;

1.6
date	2012.02.06.22.53.13;	author matthieu;	state Exp;
branches;
next	1.5;

1.5
date	2012.01.25.21.33.35;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2011.11.28.23.13.11;	author shadchin;	state Exp;
branches;
next	1.3;

1.3
date	2009.08.25.18.51.45;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2009.04.30.11.13.24;	author kettenis;	state Exp;
branches;
next	1.1;

1.1
date	2008.07.12.15.18.34;	author oga;	state Exp;
branches;
next	;


desc
@@


1.11
log
@Update to xf86-video-ati 7.2.0, requested by jsg@@

It fixes an endianess problem with kms and the in tree x86-video-ati
among other things.
It has been tested on various i386/amd64/sparc64/macppc machines
on a range of hardware from r100->northern islands.
@
text
@/*
 * Copyright 2000 ATI Technologies Inc., Markham, Ontario, and
 *                VA Linux Systems Inc., Fremont, California.
 *
 * All Rights Reserved.
 *
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation on the rights to use, copy, modify, merge,
 * publish, distribute, sublicense, and/or sell copies of the Software,
 * and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice (including the
 * next paragraph) shall be included in all copies or substantial
 * portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NON-INFRINGEMENT.  IN NO EVENT SHALL ATI, VA LINUX SYSTEMS AND/OR
 * THEIR SUPPLIERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
 * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 */

#ifdef HAVE_CONFIG_H
#include "config.h"
#endif

#include <string.h>
#include <stdio.h>
#include <fcntl.h>

/* X and server generic header files */
#include "xf86.h"
#include "xf86_OSproc.h"
#include "vgaHW.h"
#include "xf86Modes.h"

/* Driver data structures */
#include "radeon.h"
#include "radeon_reg.h"
#include "radeon_macros.h"
#include "radeon_probe.h"
#include "radeon_version.h"
#include "radeon_tv.h"
#include "radeon_atombios.h"

const char *encoder_name[34] = {
    "NONE",
    "INTERNAL_LVDS",
    "INTERNAL_TMDS1",
    "INTERNAL_TMDS2",
    "INTERNAL_DAC1",
    "INTERNAL_DAC2",
    "INTERNAL_SDVOA",
    "INTERNAL_SDVOB",
    "SI170B",
    "CH7303",
    "CH7301",
    "INTERNAL_DVO1",
    "EXTERNAL_SDVOA",
    "EXTERNAL_SDVOB",
    "TITFP513",
    "INTERNAL_LVTM1",
    "VT1623",
    "HDMI_SI1930",
    "HDMI_INTERNAL",
    "INTERNAL_KLDSCP_TMDS1",
    "INTERNAL_KLDSCP_DVO1",
    "INTERNAL_KLDSCP_DAC1",
    "INTERNAL_KLDSCP_DAC2",
    "SI178",
    "MVPU_FPGA",
    "INTERNAL_DDI",
    "VT1625",
    "HDMI_SI1932",
    "DP_AN9801",
    "DP_DP501",
    "INTERNAL_UNIPHY",
    "INTERNAL_KLDSCP_LVTMA",
    "INTERNAL_UNIPHY1",
    "INTERNAL_UNIPHY2",
};

const char *ConnectorTypeName[18] = {
  "None",
  "VGA",
  "DVI-I",
  "DVI-D",
  "DVI-A",
  "S-video",
  "Composite",
  "LVDS",
  "Digital",
  "SCART",
  "HDMI-A",
  "HDMI-B",
  "Unsupported",
  "Unsupported",
  "DIN",
  "DisplayPort",
  "eDP",
  "Unsupported"
};

extern void atombios_output_mode_set(xf86OutputPtr output,
				     DisplayModePtr mode,
				     DisplayModePtr adjusted_mode);
extern void atombios_output_dpms(xf86OutputPtr output, int mode);
extern RADEONMonitorType atombios_dac_detect(xf86OutputPtr output);
extern AtomBiosResult
atombios_lock_crtc(atomBiosHandlePtr atomBIOS, int crtc, int lock);
static void
radeon_bios_output_dpms(xf86OutputPtr output, int mode);
static void
radeon_bios_output_crtc(xf86OutputPtr output);
static void
radeon_bios_output_lock(xf86OutputPtr output, Bool lock);
extern void
atombios_pick_dig_encoder(xf86OutputPtr output);

void RADEONPrintPortMap(ScrnInfoPtr pScrn)
{
    RADEONInfoPtr info = RADEONPTR(pScrn);
    xf86CrtcConfigPtr   xf86_config = XF86_CRTC_CONFIG_PTR(pScrn);
    RADEONOutputPrivatePtr radeon_output;
    xf86OutputPtr output;
    int o;

    for (o = 0; o < xf86_config->num_output; o++) {
	output = xf86_config->output[o];
	radeon_output = output->driver_private;

	xf86DrvMsg(pScrn->scrnIndex, X_INFO, "Port%d:\n", o);
	ErrorF("  XRANDR name: %s\n", output->name);
	ErrorF("  Connector: %s\n", ConnectorTypeName[radeon_output->ConnectorType]);
	if (radeon_output->devices & ATOM_DEVICE_CRT1_SUPPORT)
	    ErrorF("  CRT1: %s\n", encoder_name[info->encoders[ATOM_DEVICE_CRT1_INDEX]->encoder_id]);
	if (radeon_output->devices & ATOM_DEVICE_CRT2_SUPPORT)
	    ErrorF("  CRT2: %s\n", encoder_name[info->encoders[ATOM_DEVICE_CRT2_INDEX]->encoder_id]);
	if (radeon_output->devices & ATOM_DEVICE_LCD1_SUPPORT)
	    ErrorF("  LCD1: %s\n", encoder_name[info->encoders[ATOM_DEVICE_LCD1_INDEX]->encoder_id]);
	if (radeon_output->devices & ATOM_DEVICE_DFP1_SUPPORT)
	    ErrorF("  DFP1: %s\n", encoder_name[info->encoders[ATOM_DEVICE_DFP1_INDEX]->encoder_id]);
	if (radeon_output->devices & ATOM_DEVICE_DFP2_SUPPORT)
	    ErrorF("  DFP2: %s\n", encoder_name[info->encoders[ATOM_DEVICE_DFP2_INDEX]->encoder_id]);
	if (radeon_output->devices & ATOM_DEVICE_DFP3_SUPPORT)
	    ErrorF("  DFP3: %s\n", encoder_name[info->encoders[ATOM_DEVICE_DFP3_INDEX]->encoder_id]);
	if (radeon_output->devices & ATOM_DEVICE_DFP4_SUPPORT)
	    ErrorF("  DFP4: %s\n", encoder_name[info->encoders[ATOM_DEVICE_DFP4_INDEX]->encoder_id]);
	if (radeon_output->devices & ATOM_DEVICE_DFP5_SUPPORT)
	    ErrorF("  DFP5: %s\n", encoder_name[info->encoders[ATOM_DEVICE_DFP5_INDEX]->encoder_id]);
	if (radeon_output->devices & ATOM_DEVICE_TV1_SUPPORT)
	    ErrorF("  TV1: %s\n", encoder_name[info->encoders[ATOM_DEVICE_TV1_INDEX]->encoder_id]);
	if (radeon_output->devices & ATOM_DEVICE_CV_SUPPORT)
	    ErrorF("  CV: %s\n", encoder_name[info->encoders[ATOM_DEVICE_CV_INDEX]->encoder_id]);
	ErrorF("  DDC reg: 0x%x\n",(unsigned int)radeon_output->ddc_i2c.mask_clk_reg);
    }

}

static void
radeon_set_active_device(xf86OutputPtr output)
{
    RADEONOutputPrivatePtr radeon_output = output->driver_private;

    radeon_output->active_device = 0;

    switch (radeon_output->MonType) {
    case MT_DP:
    case MT_DFP:
	if (radeon_output->devices & ATOM_DEVICE_DFP1_SUPPORT)
	    radeon_output->active_device = ATOM_DEVICE_DFP1_SUPPORT;
	else if (radeon_output->devices & ATOM_DEVICE_DFP2_SUPPORT)
	    radeon_output->active_device = ATOM_DEVICE_DFP2_SUPPORT;
	else if (radeon_output->devices & ATOM_DEVICE_DFP3_SUPPORT)
	    radeon_output->active_device = ATOM_DEVICE_DFP3_SUPPORT;
	else if (radeon_output->devices & ATOM_DEVICE_DFP4_SUPPORT)
	    radeon_output->active_device = ATOM_DEVICE_DFP4_SUPPORT;
	else if (radeon_output->devices & ATOM_DEVICE_DFP5_SUPPORT)
	    radeon_output->active_device = ATOM_DEVICE_DFP5_SUPPORT;
	else if (radeon_output->devices & ATOM_DEVICE_LCD1_SUPPORT)
	    radeon_output->active_device = ATOM_DEVICE_LCD1_SUPPORT;
	else if (radeon_output->devices & ATOM_DEVICE_LCD2_SUPPORT)
	    radeon_output->active_device = ATOM_DEVICE_LCD2_SUPPORT;
	break;
    case MT_CRT:
	if (radeon_output->devices & ATOM_DEVICE_CRT1_SUPPORT)
	    radeon_output->active_device = ATOM_DEVICE_CRT1_SUPPORT;
	else if (radeon_output->devices & ATOM_DEVICE_CRT2_SUPPORT)
	    radeon_output->active_device = ATOM_DEVICE_CRT2_SUPPORT;
	break;
    case MT_LCD:
	if (radeon_output->devices & ATOM_DEVICE_LCD1_SUPPORT)
	    radeon_output->active_device = ATOM_DEVICE_LCD1_SUPPORT;
	else if (radeon_output->devices & ATOM_DEVICE_LCD2_SUPPORT)
	    radeon_output->active_device = ATOM_DEVICE_LCD2_SUPPORT;
	break;
    case MT_STV:
    case MT_CTV:
	if (radeon_output->devices & ATOM_DEVICE_TV1_SUPPORT)
	    radeon_output->active_device = ATOM_DEVICE_TV1_SUPPORT;
	else if (radeon_output->devices & ATOM_DEVICE_TV2_SUPPORT)
	    radeon_output->active_device = ATOM_DEVICE_TV2_SUPPORT;
	break;
    case MT_CV:
	if (radeon_output->devices & ATOM_DEVICE_CV_SUPPORT)
	    radeon_output->active_device = ATOM_DEVICE_CV_SUPPORT;
	break;
    default:
	ErrorF("Unhandled monitor type %d\n", radeon_output->MonType);
	radeon_output->active_device = 0;
    }
}

static Bool
monitor_is_digital(xf86MonPtr MonInfo)
{
    return (MonInfo->rawData[0x14] & 0x80) != 0;
}

static void
RADEONGetHardCodedEDIDFromFile(xf86OutputPtr output)
{
    ScrnInfoPtr pScrn = output->scrn;
    RADEONInfoPtr info = RADEONPTR(pScrn);
    RADEONOutputPrivatePtr radeon_output = output->driver_private;
    char *EDIDlist = (char *)xf86GetOptValString(info->Options, OPTION_CUSTOM_EDID);

    radeon_output->custom_edid = FALSE;
    radeon_output->custom_mon = NULL;

    if (EDIDlist != NULL) {
	unsigned char* edid = xnfcalloc(128, 1);
	char *name = output->name;
	char *outputEDID = strstr(EDIDlist, name);

	if (outputEDID != NULL) {
	    char *end;
	    char *colon;
	    char *command = NULL;
	    int fd;

	    outputEDID += strlen(name) + 1;
	    end = strstr(outputEDID, ";");
	    if (end != NULL)
		*end = 0;

	    colon = strstr(outputEDID, ":");
	    if (colon != NULL) {
		*colon = 0;
		command = colon + 1;
	    }

	    fd = open (outputEDID, O_RDONLY);
	    if (fd >= 0) {
		read(fd, edid, 128);
		close(fd);
		if (edid[1] == 0xff) {
		    radeon_output->custom_mon = xf86InterpretEDID(output->scrn->scrnIndex, edid);
		    radeon_output->custom_edid = TRUE;
		    xf86DrvMsg(pScrn->scrnIndex, X_INFO,
			       "Successfully read Custom EDID data for output %s from %s.\n",
			       name, outputEDID);
		    if (command != NULL) {
			if (!strcmp(command, "digital")) {
			    radeon_output->custom_mon->rawData[0x14] |= 0x80;
			    xf86DrvMsg(pScrn->scrnIndex, X_INFO,
				       "Forcing digital output for output %s.\n", name);
			} else if (!strcmp(command, "analog")) {
			    radeon_output->custom_mon->rawData[0x14] &= ~0x80;
			    xf86DrvMsg(pScrn->scrnIndex, X_INFO,
				       "Forcing analog output for output %s.\n", name);
			} else {
			    xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
				       "Unknown custom EDID command: '%s'.\n",
				       command);
			}
		    }
		} else {
		    xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
			       "Custom EDID data for %s read from %s was invalid.\n",
			       name, outputEDID);
		}
	    } else {
		xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
			   "Could not read custom EDID for output %s from file %s.\n",
			   name, outputEDID);
	    }
	} else {
	    xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
		       "Could not find EDID file name for output %s; using auto detection.\n",
		       name);
	}
    }
}


static RADEONMonitorType
radeon_ddc_connected(xf86OutputPtr output)
{
    ScrnInfoPtr pScrn        = output->scrn;
    RADEONInfoPtr info = RADEONPTR(pScrn);
    RADEONMonitorType MonType = MT_NONE;
    xf86MonPtr MonInfo = NULL;
    RADEONOutputPrivatePtr radeon_output = output->driver_private;
    int ret;

    if (radeon_output->custom_edid) {
	MonInfo = xnfcalloc(sizeof(xf86Monitor), 1);
	*MonInfo = *radeon_output->custom_mon;
    } else if ((radeon_output->ConnectorType == CONNECTOR_DISPLAY_PORT) ||
	       (radeon_output->ConnectorType == CONNECTOR_EDP)) {
	ret = RADEON_DP_GetSinkType(output);
	if (ret == CONNECTOR_OBJECT_ID_DISPLAYPORT ||
	    ret == CONNECTOR_OBJECT_ID_eDP) {
		MonInfo = xf86OutputGetEDID(output, radeon_output->dp_pI2CBus);
	}
	if (MonInfo == NULL) {
	    if (radeon_output->pI2CBus) {
		RADEONI2CDoLock(output, radeon_output->pI2CBus, TRUE);
		MonInfo = xf86OutputGetEDID(output, radeon_output->pI2CBus);
		RADEONI2CDoLock(output, radeon_output->pI2CBus, FALSE);
	    }
	}
    } else if (radeon_output->pI2CBus) {
	if (info->get_hardcoded_edid_from_bios)
	    MonInfo = RADEONGetHardCodedEDIDFromBIOS(output);
	if (MonInfo == NULL) {
	    RADEONI2CDoLock(output, radeon_output->pI2CBus, TRUE);
	    MonInfo = xf86OutputGetEDID(output, radeon_output->pI2CBus);
	    RADEONI2CDoLock(output, radeon_output->pI2CBus, FALSE);
	}
    }
    if (MonInfo) {
	switch (radeon_output->ConnectorType) {
	case CONNECTOR_LVDS:
	    MonType = MT_LCD;
	    break;
	case CONNECTOR_DVI_D:
	case CONNECTOR_HDMI_TYPE_A:
	    if (radeon_output->shared_ddc) {
		xf86CrtcConfigPtr config = XF86_CRTC_CONFIG_PTR (output->scrn);
		int i;

		if (monitor_is_digital(MonInfo))
		    MonType = MT_DFP;
		else
		    MonType = MT_NONE;

		for (i = 0; i < config->num_output; i++) {
		    if (output != config->output[i]) {
			RADEONOutputPrivatePtr other_radeon_output =
			    config->output[i]->driver_private;
			if (radeon_output->devices & other_radeon_output->devices) {
#ifndef EDID_COMPLETE_RAWDATA
			    if (radeon_output->ConnectorType == CONNECTOR_HDMI_TYPE_A) {
				MonType = MT_NONE;
				break;
			    }
#else
			    if (xf86MonitorIsHDMI(MonInfo)) {
				if (radeon_output->ConnectorType == CONNECTOR_DVI_D) {
				    MonType = MT_NONE;
				    break;
				}
			    } else {
				if (radeon_output->ConnectorType == CONNECTOR_HDMI_TYPE_A) {
				    MonType = MT_NONE;
				    break;
				}
			    }
#endif
			}
		    }
		}
	    } else
		MonType = MT_DFP;
	    break;
	case CONNECTOR_DISPLAY_PORT:
	case CONNECTOR_EDP:
	    /*
	     * XXX wrong. need to infer based on whether we got DDC from I2C
	     * or AUXCH.
	     */
	    ret = RADEON_DP_GetSinkType(output);

	    if ((ret == CONNECTOR_OBJECT_ID_DISPLAYPORT) ||
		(ret == CONNECTOR_OBJECT_ID_eDP)) {
		MonType = MT_DP;
		RADEON_DP_GetDPCD(output);
	    } else
		MonType = MT_DFP;
	    break;
	case CONNECTOR_HDMI_TYPE_B:
	case CONNECTOR_DVI_I:
	    if (monitor_is_digital(MonInfo))
		MonType = MT_DFP;
	    else
		MonType = MT_CRT;
	    break;
	case CONNECTOR_VGA:
	case CONNECTOR_DVI_A:
	default:
	    if (radeon_output->shared_ddc) {
		if (monitor_is_digital(MonInfo))
		    MonType = MT_NONE;
		else
		    MonType = MT_CRT;
	    } else
		MonType = MT_CRT;
	    break;
	}

	if (MonType != MT_NONE) {
	    if (!xf86ReturnOptValBool(info->Options, OPTION_IGNORE_EDID, FALSE))
		xf86OutputSetEDID(output, MonInfo);
	} else
	    free(MonInfo);
    } else
	MonType = MT_NONE;

    return MonType;
}

#ifndef __powerpc__

static RADEONMonitorType
RADEONDetectLidStatus(ScrnInfoPtr pScrn)
{
    RADEONInfoPtr info = RADEONPTR(pScrn);
    RADEONMonitorType MonType = MT_NONE;
#ifdef __linux__
    char lidline[50];  /* 50 should be sufficient for our purposes */
    FILE *f = fopen ("/proc/acpi/button/lid/LID/state", "r");

    if (f != NULL) {
	while (fgets(lidline, sizeof lidline, f)) {
	    if (!strncmp(lidline, "state:", strlen ("state:"))) {
		if (strstr(lidline, "open")) {
		    fclose(f);
		    ErrorF("proc lid open\n");
		    return MT_LCD;
		}
		else if (strstr(lidline, "closed")) {
		    fclose(f);
		    ErrorF("proc lid closed\n");
		    return MT_NONE;
		}
	    }
	}
	fclose(f);
    }
#endif

    if (!info->IsAtomBios) {
	unsigned char *RADEONMMIO = info->MMIO;

	/* see if the lid is closed -- only works at boot */
	if (INREG(RADEON_BIOS_6_SCRATCH) & 0x10)
	    MonType = MT_NONE;
	else
	    MonType = MT_LCD;
    } else
	MonType = MT_LCD;

    return MonType;
}

#endif /* __powerpc__ */

static void
radeon_dpms(xf86OutputPtr output, int mode)
{
    RADEONInfoPtr info = RADEONPTR(output->scrn);
    RADEONOutputPrivatePtr radeon_output = output->driver_private;

    if ((mode == DPMSModeOn) && radeon_output->enabled)
	return;

    if ((mode != DPMSModeOn) && radeon_output->shared_ddc) {
	xf86CrtcConfigPtr config = XF86_CRTC_CONFIG_PTR (output->scrn);
	int i;

	for (i = 0; i < config->num_output; i++) {
	    if (output != config->output[i]) {
		RADEONOutputPrivatePtr other_radeon_output =
		    config->output[i]->driver_private;
		if (radeon_output->devices & other_radeon_output->devices) {
		    if (output->status == XF86OutputStatusDisconnected)
			return;
		}
	    }
	}
    }

    if (IS_AVIVO_VARIANT || info->r4xx_atom) {
	atombios_output_dpms(output, mode);
    } else {
	legacy_output_dpms(output, mode);
    }
    radeon_bios_output_dpms(output, mode);

    if (mode == DPMSModeOn)
	radeon_output->enabled = TRUE;
    else
	radeon_output->enabled = FALSE;

}

static void
radeon_save(xf86OutputPtr output)
{

}

static void
radeon_restore(xf86OutputPtr restore)
{

}

static int
radeon_mode_valid(xf86OutputPtr output, DisplayModePtr pMode)
{
    RADEONOutputPrivatePtr radeon_output = output->driver_private;
    radeon_native_mode_ptr native_mode = &radeon_output->native_mode;
    ScrnInfoPtr pScrn = output->scrn;
    RADEONInfoPtr info = RADEONPTR(pScrn);
    RADEONEntPtr pRADEONEnt = RADEONEntPriv(pScrn);

    /*
     * RN50 has effective maximum mode bandwidth of about 300MiB/s.
     * XXX should really do this for all chips by properly computing
     * memory bandwidth and an overhead factor.
     */
    if (info->ChipFamily == CHIP_FAMILY_RV100 && !pRADEONEnt->HasCRTC2) {
	if (xf86ModeBandwidth(pMode, pScrn->bitsPerPixel) > 300)
	    return MODE_BANDWIDTH;
    }

    if (radeon_output->active_device & (ATOM_DEVICE_TV_SUPPORT)) {
	if (IS_AVIVO_VARIANT)
	    return MODE_OK;
	else {
	    /* FIXME: Update when more modes are added */
	    if (pMode->HDisplay == 800 && pMode->VDisplay == 600)
		return MODE_OK;
	    else
		return MODE_CLOCK_RANGE;
	}
    }

    /* clocks over 135 MHz have heat issues with DVI on RV100 */
    if ((radeon_output->MonType == MT_DFP) &&
	(info->ChipFamily == CHIP_FAMILY_RV100) &&
	(pMode->Clock > 135000))
	    return MODE_CLOCK_HIGH;

    /* single link DVI check */
    if (pMode->Clock > 165000 && radeon_output->MonType == MT_DFP) {
	/* DP->DVI converter */
	if (radeon_output->ConnectorType == CONNECTOR_DISPLAY_PORT)
	    return MODE_CLOCK_HIGH;

	if (radeon_output->ConnectorType == CONNECTOR_EDP)
	    return MODE_CLOCK_HIGH;

	/* XXX some HDMI can do better than 165MHz on a link */
	if (radeon_output->ConnectorType == CONNECTOR_HDMI_TYPE_A)
	    return MODE_CLOCK_HIGH;

	/* XXX some R300 and R400 can actually do this */
	if (!IS_AVIVO_VARIANT)
	    return MODE_CLOCK_HIGH;

	/* XXX and some AVIVO can't */
    }

    if (radeon_output->active_device & (ATOM_DEVICE_LCD_SUPPORT)) {
	if (radeon_output->rmx_type == RMX_OFF) {
	    if (pMode->HDisplay != native_mode->PanelXRes ||
		pMode->VDisplay != native_mode->PanelYRes)
		return MODE_PANEL;
	}
	if (pMode->HDisplay > native_mode->PanelXRes ||
	    pMode->VDisplay > native_mode->PanelYRes)
	    return MODE_PANEL;
    }

    return MODE_OK;
}

static Bool
radeon_mode_fixup(xf86OutputPtr output, DisplayModePtr mode,
		    DisplayModePtr adjusted_mode)
{
    RADEONInfoPtr info = RADEONPTR(output->scrn);
    RADEONOutputPrivatePtr radeon_output = output->driver_private;
    radeon_native_mode_ptr native_mode = &radeon_output->native_mode;
    xf86CrtcPtr crtc = output->crtc;
    RADEONCrtcPrivatePtr radeon_crtc = crtc->driver_private;

    radeon_output->Flags &= ~RADEON_USE_RMX;
    radeon_crtc->scaler_enabled = FALSE;

    /*
     *  Refresh the Crtc values without INTERLACE_HALVE_V
     *  Should we use output->scrn->adjustFlags like xf86RandRModeConvert() does?
     */
    xf86SetModeCrtc(adjusted_mode, 0);

    /* decide if we are using RMX */
    if ((radeon_output->active_device & (ATOM_DEVICE_LCD_SUPPORT | ATOM_DEVICE_DFP_SUPPORT))
	&& radeon_output->rmx_type != RMX_OFF) {

	if (IS_AVIVO_VARIANT || radeon_crtc->crtc_id == 0) {
	    if (mode->HDisplay < native_mode->PanelXRes ||
		mode->VDisplay < native_mode->PanelYRes) {
		radeon_output->Flags |= RADEON_USE_RMX;
		radeon_crtc->scaler_enabled = TRUE;
		if (IS_AVIVO_VARIANT) {
		    radeon_crtc->hsc = (float)mode->HDisplay / (float)native_mode->PanelXRes;
		    radeon_crtc->vsc = (float)mode->VDisplay / (float)native_mode->PanelYRes;
		    /* set to the panel's native mode */
		    adjusted_mode->HDisplay = native_mode->PanelXRes;
		    adjusted_mode->VDisplay = native_mode->PanelYRes;
		    adjusted_mode->HTotal = native_mode->PanelXRes + native_mode->HBlank;
		    adjusted_mode->HSyncStart = native_mode->PanelXRes + native_mode->HOverPlus;
		    adjusted_mode->HSyncEnd = adjusted_mode->HSyncStart + native_mode->HSyncWidth;
		    adjusted_mode->VTotal = native_mode->PanelYRes + native_mode->VBlank;
		    adjusted_mode->VSyncStart = native_mode->PanelYRes + native_mode->VOverPlus;
		    adjusted_mode->VSyncEnd = adjusted_mode->VSyncStart + native_mode->VSyncWidth;
		    /* update crtc values */
		    xf86SetModeCrtc(adjusted_mode, INTERLACE_HALVE_V);
		    /* adjust crtc values */
		    adjusted_mode->CrtcHDisplay = native_mode->PanelXRes;
		    adjusted_mode->CrtcVDisplay = native_mode->PanelYRes;
		    adjusted_mode->CrtcHTotal = adjusted_mode->CrtcHDisplay + native_mode->HBlank;
		    adjusted_mode->CrtcHSyncStart = adjusted_mode->CrtcHDisplay + native_mode->HOverPlus;
		    adjusted_mode->CrtcHSyncEnd = adjusted_mode->CrtcHSyncStart + native_mode->HSyncWidth;
		    adjusted_mode->CrtcVTotal = adjusted_mode->CrtcVDisplay + native_mode->VBlank;
		    adjusted_mode->CrtcVSyncStart = adjusted_mode->CrtcVDisplay + native_mode->VOverPlus;
		    adjusted_mode->CrtcVSyncEnd = adjusted_mode->CrtcVSyncStart + native_mode->VSyncWidth;
		} else {
		    /* set to the panel's native mode */
		    adjusted_mode->HTotal = native_mode->PanelXRes + native_mode->HBlank;
		    adjusted_mode->HSyncStart = native_mode->PanelXRes + native_mode->HOverPlus;
		    adjusted_mode->HSyncEnd = adjusted_mode->HSyncStart + native_mode->HSyncWidth;
		    adjusted_mode->VTotal = native_mode->PanelYRes + native_mode->VBlank;
		    adjusted_mode->VSyncStart = native_mode->PanelYRes + native_mode->VOverPlus;
		    adjusted_mode->VSyncEnd = adjusted_mode->VSyncStart + native_mode->VSyncWidth;
		    adjusted_mode->Clock = native_mode->DotClock;
		    /* update crtc values */
		    xf86SetModeCrtc(adjusted_mode, INTERLACE_HALVE_V);
		    /* adjust crtc values */
		    adjusted_mode->CrtcHTotal = adjusted_mode->CrtcHDisplay + native_mode->HBlank;
		    adjusted_mode->CrtcHSyncStart = adjusted_mode->CrtcHDisplay + native_mode->HOverPlus;
		    adjusted_mode->CrtcHSyncEnd = adjusted_mode->CrtcHSyncStart + native_mode->HSyncWidth;
		    adjusted_mode->CrtcVTotal = adjusted_mode->CrtcVDisplay + native_mode->VBlank;
		    adjusted_mode->CrtcVSyncStart = adjusted_mode->CrtcVDisplay + native_mode->VOverPlus;
		    adjusted_mode->CrtcVSyncEnd = adjusted_mode->CrtcVSyncStart + native_mode->VSyncWidth;
		}
		adjusted_mode->Clock = native_mode->DotClock;
		adjusted_mode->Flags = native_mode->Flags;
	    }
	}
    }

    /* FIXME: vsc/hsc */
    if (radeon_output->active_device & (ATOM_DEVICE_TV_SUPPORT | ATOM_DEVICE_CV_SUPPORT)) {
	radeon_crtc->scaler_enabled = TRUE;
	radeon_crtc->hsc = (float)mode->HDisplay / (float)640;
	radeon_crtc->vsc = (float)mode->VDisplay / (float)480;
    }

    if (IS_AVIVO_VARIANT) {
	/* hw bug */
	if ((mode->Flags & V_INTERLACE)
	    && (adjusted_mode->CrtcVSyncStart < (adjusted_mode->CrtcVDisplay + 2)))
	    adjusted_mode->CrtcVSyncStart = adjusted_mode->CrtcVDisplay + 2;
    }

    if (IS_AVIVO_VARIANT || info->r4xx_atom) {
	if (radeon_output->MonType == MT_STV || radeon_output->MonType == MT_CTV) {
	    radeon_tvout_ptr tvout = &radeon_output->tvout;
	    ScrnInfoPtr pScrn = output->scrn;

	    if (tvout->tvStd == TV_STD_NTSC ||
		tvout->tvStd == TV_STD_NTSC_J ||
		tvout->tvStd == TV_STD_PAL_M)
		RADEONATOMGetTVTimings(pScrn, 0, adjusted_mode);
	    else
		RADEONATOMGetTVTimings(pScrn, 1, adjusted_mode);
	}
    }

    if (((radeon_output->ConnectorType == CONNECTOR_DISPLAY_PORT) ||
	 (radeon_output->ConnectorType == CONNECTOR_EDP)) &&
	(radeon_output->MonType == MT_DP)) {
      radeon_dp_mode_fixup(output, mode, adjusted_mode);
    }
    return TRUE;
}

static void
radeon_mode_prepare(xf86OutputPtr output)
{
    RADEONInfoPtr info = RADEONPTR(output->scrn);
    xf86CrtcConfigPtr	config = XF86_CRTC_CONFIG_PTR (output->scrn);
    int o;

    for (o = 0; o < config->num_output; o++) {
	xf86OutputPtr loop_output = config->output[o];
	if (loop_output == output)
	    continue;
	else if (loop_output->crtc) {
	    xf86CrtcPtr other_crtc = loop_output->crtc;
	    RADEONCrtcPrivatePtr other_radeon_crtc = other_crtc->driver_private;
	    if (other_crtc->enabled) {
		if (other_radeon_crtc->initialized) {
		    radeon_crtc_dpms(other_crtc, DPMSModeOff);
		    if (IS_AVIVO_VARIANT || info->r4xx_atom)
			atombios_lock_crtc(info->atomBIOS, other_radeon_crtc->crtc_id, 1);
		    radeon_dpms(loop_output, DPMSModeOff);
		}
	    }
	}
    }

    radeon_bios_output_lock(output, TRUE);
    if (IS_AVIVO_VARIANT)
	atombios_pick_dig_encoder(output);
    radeon_dpms(output, DPMSModeOff);
    radeon_crtc_dpms(output->crtc, DPMSModeOff);

    if (IS_AVIVO_VARIANT || info->r4xx_atom)
        atombios_set_output_crtc_source(output);

}

static void
radeon_mode_set(xf86OutputPtr output, DisplayModePtr mode,
		DisplayModePtr adjusted_mode)
{
    RADEONInfoPtr info = RADEONPTR(output->scrn);

    if (IS_AVIVO_VARIANT || info->r4xx_atom)
	atombios_output_mode_set(output, mode, adjusted_mode);
    else
	legacy_output_mode_set(output, mode, adjusted_mode);
    radeon_bios_output_crtc(output);

}

static void
radeon_mode_commit(xf86OutputPtr output)
{
    RADEONInfoPtr info = RADEONPTR(output->scrn);
    xf86CrtcConfigPtr	config = XF86_CRTC_CONFIG_PTR (output->scrn);
    int o;

    for (o = 0; o < config->num_output; o++) {
	xf86OutputPtr loop_output = config->output[o];
	if (loop_output == output)
	    continue;
	else if (loop_output->crtc) {
	    xf86CrtcPtr other_crtc = loop_output->crtc;
	    RADEONCrtcPrivatePtr other_radeon_crtc = other_crtc->driver_private;
	    if (other_crtc->enabled) {
		if (other_radeon_crtc->initialized) {
		    radeon_crtc_dpms(other_crtc, DPMSModeOn);
		    if (IS_AVIVO_VARIANT || info->r4xx_atom)
			atombios_lock_crtc(info->atomBIOS, other_radeon_crtc->crtc_id, 0);
		    radeon_dpms(loop_output, DPMSModeOn);
		}
	    }
	}
    }

    radeon_dpms(output, DPMSModeOn);
    radeon_crtc_dpms(output->crtc, DPMSModeOn);
    radeon_bios_output_lock(output, FALSE);
}

static void
radeon_bios_output_lock(xf86OutputPtr output, Bool lock)
{
    ScrnInfoPtr	    pScrn = output->scrn;
    RADEONInfoPtr info = RADEONPTR(pScrn);
    unsigned char *RADEONMMIO = info->MMIO;
    RADEONSavePtr save = info->ModeReg;

    if (info->IsAtomBios) {
	if (lock) {
	    save->bios_6_scratch |= ATOM_S6_CRITICAL_STATE;
	} else {
	    save->bios_6_scratch &= ~ATOM_S6_CRITICAL_STATE;
	}
    } else {
	if (lock) {
	    save->bios_6_scratch |= RADEON_DRIVER_CRITICAL;
	} else {
	    save->bios_6_scratch &= ~RADEON_DRIVER_CRITICAL;
	}
    }
    if (info->ChipFamily >= CHIP_FAMILY_R600)
	OUTREG(R600_BIOS_6_SCRATCH, save->bios_6_scratch);
    else
	OUTREG(RADEON_BIOS_6_SCRATCH, save->bios_6_scratch);
}

static void
radeon_bios_output_dpms(xf86OutputPtr output, int mode)
{
    ScrnInfoPtr	    pScrn = output->scrn;
    RADEONInfoPtr info = RADEONPTR(pScrn);
    RADEONOutputPrivatePtr radeon_output = output->driver_private;
    unsigned char *RADEONMMIO = info->MMIO;
    RADEONSavePtr save = info->ModeReg;

    if (info->IsAtomBios) {
	if (radeon_output->active_device & ATOM_DEVICE_TV1_SUPPORT) {
	    if (mode == DPMSModeOn)
		save->bios_2_scratch &= ~ATOM_S2_TV1_DPMS_STATE;
	    else
		save->bios_2_scratch |= ATOM_S2_TV1_DPMS_STATE;
	} else if (radeon_output->active_device & ATOM_DEVICE_CV_SUPPORT) {
	    if (mode == DPMSModeOn)
		save->bios_2_scratch &= ~ATOM_S2_CV_DPMS_STATE;
	    else
		save->bios_2_scratch |= ATOM_S2_CV_DPMS_STATE;
	} else if (radeon_output->active_device & ATOM_DEVICE_CRT1_SUPPORT) {
	    if (mode == DPMSModeOn)
		save->bios_2_scratch &= ~ATOM_S2_CRT1_DPMS_STATE;
	    else
		save->bios_2_scratch |= ATOM_S2_CRT1_DPMS_STATE;
	} else if (radeon_output->active_device & ATOM_DEVICE_CRT2_SUPPORT) {
	    if (mode == DPMSModeOn)
		save->bios_2_scratch &= ~ATOM_S2_CRT2_DPMS_STATE;
	    else
		save->bios_2_scratch |= ATOM_S2_CRT2_DPMS_STATE;
	} else if (radeon_output->active_device & ATOM_DEVICE_LCD1_SUPPORT) {
	    if (mode == DPMSModeOn)
		save->bios_2_scratch &= ~ATOM_S2_LCD1_DPMS_STATE;
	    else
		save->bios_2_scratch |= ATOM_S2_LCD1_DPMS_STATE;
	} else if (radeon_output->active_device & ATOM_DEVICE_DFP1_SUPPORT) {
	    if (mode == DPMSModeOn)
		save->bios_2_scratch &= ~ATOM_S2_DFP1_DPMS_STATE;
	    else
		save->bios_2_scratch |= ATOM_S2_DFP1_DPMS_STATE;
	} else if (radeon_output->active_device & ATOM_DEVICE_DFP2_SUPPORT) {
	    if (mode == DPMSModeOn)
		save->bios_2_scratch &= ~ATOM_S2_DFP2_DPMS_STATE;
	    else
		save->bios_2_scratch |= ATOM_S2_DFP2_DPMS_STATE;
	} else if (radeon_output->active_device & ATOM_DEVICE_DFP3_SUPPORT) {
	    if (mode == DPMSModeOn)
		save->bios_2_scratch &= ~ATOM_S2_DFP3_DPMS_STATE;
	    else
		save->bios_2_scratch |= ATOM_S2_DFP3_DPMS_STATE;
	} else if (radeon_output->active_device & ATOM_DEVICE_DFP4_SUPPORT) {
	    if (mode == DPMSModeOn)
		save->bios_2_scratch &= ~ATOM_S2_DFP4_DPMS_STATE;
	    else
		save->bios_2_scratch |= ATOM_S2_DFP4_DPMS_STATE;
	} else if (radeon_output->active_device & ATOM_DEVICE_DFP5_SUPPORT) {
	    if (mode == DPMSModeOn)
		save->bios_2_scratch &= ~ATOM_S2_DFP5_DPMS_STATE;
	    else
		save->bios_2_scratch |= ATOM_S2_DFP5_DPMS_STATE;
	}
	if (info->ChipFamily >= CHIP_FAMILY_R600)
	    OUTREG(R600_BIOS_2_SCRATCH, save->bios_2_scratch);
	else
	    OUTREG(RADEON_BIOS_2_SCRATCH, save->bios_2_scratch);
    } else {
	if (mode == DPMSModeOn) {
	    save->bios_6_scratch &= ~(RADEON_DPMS_MASK | RADEON_SCREEN_BLANKING);
	    save->bios_6_scratch |= RADEON_DPMS_ON;
	} else {
	    save->bios_6_scratch &= ~RADEON_DPMS_MASK;
	    save->bios_6_scratch |= (RADEON_DPMS_OFF | RADEON_SCREEN_BLANKING);
	}
	if (radeon_output->active_device & ATOM_DEVICE_TV1_SUPPORT) {
	    if (mode == DPMSModeOn)
		save->bios_6_scratch |= RADEON_TV_DPMS_ON;
	    else
		save->bios_6_scratch &= ~RADEON_TV_DPMS_ON;
	} else if (radeon_output->active_device & ATOM_DEVICE_CRT1_SUPPORT) {
	    if (mode == DPMSModeOn)
		save->bios_6_scratch |= RADEON_CRT_DPMS_ON;
	    else
		save->bios_6_scratch &= ~RADEON_CRT_DPMS_ON;
	} else if (radeon_output->active_device & ATOM_DEVICE_CRT2_SUPPORT) {
	    if (mode == DPMSModeOn)
		save->bios_6_scratch |= RADEON_CRT_DPMS_ON;
	    else
		save->bios_6_scratch &= ~RADEON_CRT_DPMS_ON;
	} else if (radeon_output->active_device & ATOM_DEVICE_LCD1_SUPPORT) {
	    if (mode == DPMSModeOn)
		save->bios_6_scratch |= RADEON_LCD_DPMS_ON;
	    else
		save->bios_6_scratch &= ~RADEON_LCD_DPMS_ON;
	} else if (radeon_output->active_device & ATOM_DEVICE_DFP1_SUPPORT) {
	    if (mode == DPMSModeOn)
		save->bios_6_scratch |= RADEON_DFP_DPMS_ON;
	    else
		save->bios_6_scratch &= ~RADEON_DFP_DPMS_ON;
	} else if (radeon_output->active_device & ATOM_DEVICE_DFP2_SUPPORT) {
	    if (mode == DPMSModeOn)
		save->bios_6_scratch |= RADEON_DFP_DPMS_ON;
	    else
		save->bios_6_scratch &= ~RADEON_DFP_DPMS_ON;
	}
	OUTREG(RADEON_BIOS_6_SCRATCH, save->bios_6_scratch);
    }
}

static void
radeon_bios_output_crtc(xf86OutputPtr output)
{
    ScrnInfoPtr	    pScrn = output->scrn;
    RADEONInfoPtr info = RADEONPTR(pScrn);
    RADEONOutputPrivatePtr radeon_output = output->driver_private;
    unsigned char *RADEONMMIO = info->MMIO;
    RADEONSavePtr save = info->ModeReg;
    xf86CrtcPtr crtc = output->crtc;
    RADEONCrtcPrivatePtr radeon_crtc = crtc->driver_private;

    /* no need to update crtc routing scratch regs on DCE4 */
    if (IS_DCE4_VARIANT)
	return;

    if (info->IsAtomBios) {
	if (radeon_output->active_device & ATOM_DEVICE_TV1_SUPPORT) {
	    save->bios_3_scratch &= ~ATOM_S3_TV1_CRTC_ACTIVE;
	    save->bios_3_scratch |= (radeon_crtc->crtc_id << 18);
	} else if (radeon_output->active_device & ATOM_DEVICE_CV_SUPPORT) {
	    save->bios_3_scratch &= ~ATOM_S3_CV_CRTC_ACTIVE;
	    save->bios_3_scratch |= (radeon_crtc->crtc_id << 24);
	} else if (radeon_output->active_device & ATOM_DEVICE_CRT1_SUPPORT) {
	    save->bios_3_scratch &= ~ATOM_S3_CRT1_CRTC_ACTIVE;
	    save->bios_3_scratch |= (radeon_crtc->crtc_id << 16);
	} else if (radeon_output->active_device & ATOM_DEVICE_CRT2_SUPPORT) {
	    save->bios_3_scratch &= ~ATOM_S3_CRT2_CRTC_ACTIVE;
	    save->bios_3_scratch |= (radeon_crtc->crtc_id << 20);
	} else if (radeon_output->active_device & ATOM_DEVICE_LCD1_SUPPORT) {
	    save->bios_3_scratch &= ~ATOM_S3_LCD1_CRTC_ACTIVE;
	    save->bios_3_scratch |= (radeon_crtc->crtc_id << 17);
	} else if (radeon_output->active_device & ATOM_DEVICE_DFP1_SUPPORT) {
	    save->bios_3_scratch &= ~ATOM_S3_DFP1_CRTC_ACTIVE;
	    save->bios_3_scratch |= (radeon_crtc->crtc_id << 19);
	} else if (radeon_output->active_device & ATOM_DEVICE_DFP2_SUPPORT) {
	    save->bios_3_scratch &= ~ATOM_S3_DFP2_CRTC_ACTIVE;
	    save->bios_3_scratch |= (radeon_crtc->crtc_id << 23);
	} else if (radeon_output->active_device & ATOM_DEVICE_DFP3_SUPPORT) {
	    save->bios_3_scratch &= ~ATOM_S3_DFP3_CRTC_ACTIVE;
	    save->bios_3_scratch |= (radeon_crtc->crtc_id << 25);
	}
	if (info->ChipFamily >= CHIP_FAMILY_R600)
	    OUTREG(R600_BIOS_3_SCRATCH, save->bios_3_scratch);
	else
	    OUTREG(RADEON_BIOS_3_SCRATCH, save->bios_3_scratch);
    } else {
	if (radeon_output->active_device & ATOM_DEVICE_TV1_SUPPORT) {
	    save->bios_5_scratch &= ~RADEON_TV1_CRTC_MASK;
	    save->bios_5_scratch |= (radeon_crtc->crtc_id << RADEON_TV1_CRTC_SHIFT);
	} else if (radeon_output->active_device & ATOM_DEVICE_CRT1_SUPPORT) {
	    save->bios_5_scratch &= ~RADEON_CRT1_CRTC_MASK;
	    save->bios_5_scratch |= (radeon_crtc->crtc_id << RADEON_CRT1_CRTC_SHIFT);
	} else if (radeon_output->active_device & ATOM_DEVICE_CRT2_SUPPORT) {
	    save->bios_5_scratch &= ~RADEON_CRT2_CRTC_MASK;
	    save->bios_5_scratch |= (radeon_crtc->crtc_id << RADEON_CRT2_CRTC_SHIFT);
	} else if (radeon_output->active_device & ATOM_DEVICE_LCD1_SUPPORT) {
	    save->bios_5_scratch &= ~RADEON_LCD1_CRTC_MASK;
	    save->bios_5_scratch |= (radeon_crtc->crtc_id << RADEON_LCD1_CRTC_SHIFT);
	} else if (radeon_output->active_device & ATOM_DEVICE_DFP1_SUPPORT) {
	    save->bios_5_scratch &= ~RADEON_DFP1_CRTC_MASK;
	    save->bios_5_scratch |= (radeon_crtc->crtc_id << RADEON_DFP1_CRTC_SHIFT);
	} else if (radeon_output->active_device & ATOM_DEVICE_DFP2_SUPPORT) {
	    save->bios_5_scratch &= ~RADEON_DFP2_CRTC_MASK;
	    save->bios_5_scratch |= (radeon_crtc->crtc_id << RADEON_DFP2_CRTC_SHIFT);
	}
	OUTREG(RADEON_BIOS_5_SCRATCH, save->bios_5_scratch);
    }
}

static void
radeon_bios_output_connected(xf86OutputPtr output, Bool connected)
{
    ScrnInfoPtr	    pScrn = output->scrn;
    RADEONInfoPtr info = RADEONPTR(pScrn);
    RADEONOutputPrivatePtr radeon_output = output->driver_private;
    unsigned char *RADEONMMIO = info->MMIO;
    RADEONSavePtr save = info->ModeReg;

    if (info->IsAtomBios) {
	switch (radeon_output->active_device) {
	case ATOM_DEVICE_TV1_SUPPORT:
	    if (connected)
		save->bios_3_scratch |= ATOM_S3_TV1_ACTIVE;
	    else {
		save->bios_0_scratch &= ~ATOM_S0_TV1_MASK;
		save->bios_3_scratch &= ~ATOM_S3_TV1_ACTIVE;
	    }
	    break;
	case ATOM_DEVICE_CV_SUPPORT:
	    if (connected)
		save->bios_3_scratch |= ATOM_S3_CV_ACTIVE;
	    else {
		save->bios_0_scratch &= ~ATOM_S0_CV_MASK;
		save->bios_3_scratch &= ~ATOM_S3_CV_ACTIVE;
	    }
	    break;
	case ATOM_DEVICE_LCD1_SUPPORT:
	    if (connected) {
		save->bios_0_scratch |= ATOM_S0_LCD1;
		save->bios_3_scratch |= ATOM_S3_LCD1_ACTIVE;
	    } else {
		save->bios_0_scratch &= ~ATOM_S0_LCD1;
		save->bios_3_scratch &= ~ATOM_S3_LCD1_ACTIVE;
	    }
	    break;
	case ATOM_DEVICE_CRT1_SUPPORT:
	    if (connected) {
		save->bios_0_scratch |= ATOM_S0_CRT1_COLOR;
		save->bios_3_scratch |= ATOM_S3_CRT1_ACTIVE;
	    } else {
		save->bios_0_scratch &= ~ATOM_S0_CRT1_MASK;
		save->bios_3_scratch &= ~ATOM_S3_CRT1_ACTIVE;
	    }
	    break;
	case ATOM_DEVICE_CRT2_SUPPORT:
	    if (connected) {
		save->bios_0_scratch |= ATOM_S0_CRT2_COLOR;
		save->bios_3_scratch |= ATOM_S3_CRT2_ACTIVE;
	    } else {
		save->bios_0_scratch &= ~ATOM_S0_CRT2_MASK;
		save->bios_3_scratch &= ~ATOM_S3_CRT2_ACTIVE;
	    }
	    break;
	case ATOM_DEVICE_DFP1_SUPPORT:
	    if (connected) {
		save->bios_0_scratch |= ATOM_S0_DFP1;
		save->bios_3_scratch |= ATOM_S3_DFP1_ACTIVE;
	    } else {
		save->bios_0_scratch &= ~ATOM_S0_DFP1;
		save->bios_3_scratch &= ~ATOM_S3_DFP1_ACTIVE;
	    }
	    break;
	case ATOM_DEVICE_DFP2_SUPPORT:
	    if (connected) {
		save->bios_0_scratch |= ATOM_S0_DFP2;
		save->bios_3_scratch |= ATOM_S3_DFP2_ACTIVE;
	    } else {
		save->bios_0_scratch &= ~ATOM_S0_DFP2;
		save->bios_3_scratch &= ~ATOM_S3_DFP2_ACTIVE;
	    }
	    break;
	case ATOM_DEVICE_DFP3_SUPPORT:
	    if (connected) {
		save->bios_0_scratch |= ATOM_S0_DFP3;
		save->bios_3_scratch |= ATOM_S3_DFP3_ACTIVE;
	    } else {
		save->bios_0_scratch &= ~ATOM_S0_DFP3;
		save->bios_3_scratch &= ~ATOM_S3_DFP3_ACTIVE;
	    }
	    break;
	case ATOM_DEVICE_DFP4_SUPPORT:
	    if (connected) {
		save->bios_0_scratch |= ATOM_S0_DFP4;
		save->bios_3_scratch |= ATOM_S3_DFP4_ACTIVE;
	    } else {
		save->bios_0_scratch &= ~ATOM_S0_DFP4;
		save->bios_3_scratch &= ~ATOM_S3_DFP4_ACTIVE;
	    }
	    break;
	case ATOM_DEVICE_DFP5_SUPPORT:
	    if (connected) {
		save->bios_0_scratch |= ATOM_S0_DFP5;
		save->bios_3_scratch |= ATOM_S3_DFP5_ACTIVE;
	    } else {
		save->bios_0_scratch &= ~ATOM_S0_DFP5;
		save->bios_3_scratch &= ~ATOM_S3_DFP5_ACTIVE;
	    }
	    break;
	}
	if (info->ChipFamily >= CHIP_FAMILY_R600) {
	    OUTREG(R600_BIOS_0_SCRATCH, save->bios_0_scratch);
	    OUTREG(R600_BIOS_3_SCRATCH, save->bios_3_scratch);
	} else {
	    OUTREG(RADEON_BIOS_0_SCRATCH, save->bios_0_scratch);
	    OUTREG(RADEON_BIOS_3_SCRATCH, save->bios_3_scratch);
	}
    } else {
	switch (radeon_output->active_device) {
	case ATOM_DEVICE_TV1_SUPPORT:
	    if (connected) {
		if (radeon_output->MonType == MT_STV)
		    save->bios_4_scratch |= RADEON_TV1_ATTACHED_SVIDEO;
		else if (radeon_output->MonType == MT_CTV)
		    save->bios_4_scratch |= RADEON_TV1_ATTACHED_COMP;
		save->bios_5_scratch |= RADEON_TV1_ON;
	    } else {
		save->bios_4_scratch &= ~RADEON_TV1_ATTACHED_MASK;
		save->bios_5_scratch &= ~RADEON_TV1_ON;
	    }
	    break;
	case ATOM_DEVICE_LCD1_SUPPORT:
	    if (connected) {
		save->bios_4_scratch |= RADEON_LCD1_ATTACHED;
		save->bios_5_scratch |= RADEON_LCD1_ON;
	    } else {
		save->bios_4_scratch &= ~RADEON_LCD1_ATTACHED;
		save->bios_5_scratch &= ~RADEON_LCD1_ON;
	    }
	    break;
	case ATOM_DEVICE_CRT1_SUPPORT:
	    if (connected) {
		save->bios_4_scratch |= RADEON_CRT1_ATTACHED_COLOR;
		save->bios_5_scratch |= RADEON_CRT1_ON;
	    } else {
		save->bios_4_scratch &= ~RADEON_CRT1_ATTACHED_MASK;
		save->bios_5_scratch &= ~RADEON_CRT1_ON;
	    }
	    break;
	case ATOM_DEVICE_CRT2_SUPPORT:
	    if (connected) {
		save->bios_4_scratch |= RADEON_CRT2_ATTACHED_COLOR;
		save->bios_5_scratch |= RADEON_CRT2_ON;
	    } else {
		save->bios_4_scratch &= ~RADEON_CRT2_ATTACHED_MASK;
		save->bios_5_scratch &= ~RADEON_CRT2_ON;
	    }
	    break;
	case ATOM_DEVICE_DFP1_SUPPORT:
	    if (connected) {
		save->bios_4_scratch |= RADEON_DFP1_ATTACHED;
		save->bios_5_scratch |= RADEON_DFP1_ON;
	    } else {
		save->bios_4_scratch &= ~RADEON_DFP1_ATTACHED;
		save->bios_5_scratch &= ~RADEON_DFP1_ON;
	    }
	    break;
	case ATOM_DEVICE_DFP2_SUPPORT:
	    if (connected) {
		save->bios_4_scratch |= RADEON_DFP2_ATTACHED;
		save->bios_5_scratch |= RADEON_DFP2_ON;
	    } else {
		save->bios_4_scratch &= ~RADEON_DFP2_ATTACHED;
		save->bios_5_scratch &= ~RADEON_DFP2_ON;
	    }
	    break;
	}
	OUTREG(RADEON_BIOS_4_SCRATCH, save->bios_4_scratch);
	OUTREG(RADEON_BIOS_5_SCRATCH, save->bios_5_scratch);
    }

}

static xf86OutputStatus
radeon_detect(xf86OutputPtr output)
{
    ScrnInfoPtr	    pScrn = output->scrn;
    RADEONInfoPtr info = RADEONPTR(pScrn);
    RADEONOutputPrivatePtr radeon_output = output->driver_private;
    Bool connected = TRUE;

    radeon_output->MonType = MT_UNKNOWN;
    radeon_bios_output_connected(output, FALSE);
    radeon_output->MonType = radeon_ddc_connected(output);
    if (!radeon_output->MonType) {
	if (radeon_output->devices & (ATOM_DEVICE_LCD_SUPPORT)) {
	    if (xf86ReturnOptValBool(info->Options, OPTION_IGNORE_LID_STATUS, TRUE))
		radeon_output->MonType = MT_LCD;
	    else
#if defined(__powerpc__)
		radeon_output->MonType = MT_LCD;
#else
	        radeon_output->MonType = RADEONDetectLidStatus(pScrn);
#endif
	} else {
	    if (info->IsAtomBios)
		radeon_output->MonType = atombios_dac_detect(output);
	    else
		radeon_output->MonType = legacy_dac_detect(output);
	}
    }

    // if size is zero panel probably broken or not connected
    if (radeon_output->devices & (ATOM_DEVICE_LCD_SUPPORT)) {
	radeon_encoder_ptr radeon_encoder = info->encoders[ATOM_DEVICE_LCD1_INDEX];
	if (radeon_encoder) {
	    radeon_lvds_ptr lvds = (radeon_lvds_ptr)radeon_encoder->dev_priv;
	    if (lvds) {
		if ((lvds->native_mode.PanelXRes == 0) || (lvds->native_mode.PanelYRes == 0))
		    radeon_output->MonType = MT_NONE;
	    }
	}
    }


    xf86DrvMsg(pScrn->scrnIndex, X_INFO,
	       "Output: %s, Detected Monitor Type: %d\n", output->name, radeon_output->MonType);
    if (output->MonInfo) {
	xf86DrvMsg(pScrn->scrnIndex, X_INFO, "EDID data from the display on output: %s ----------------------\n",
		   output->name);
	xf86PrintEDID( output->MonInfo );
    }

    /* nothing connected, light up some defaults so the server comes up */
    if (radeon_output->MonType == MT_NONE &&
	info->first_load_no_devices) {
	if (info->IsMobility) {
	    if (radeon_output->devices & (ATOM_DEVICE_LCD_SUPPORT)) {
		radeon_output->MonType = MT_LCD;
		info->first_load_no_devices = FALSE;
		xf86DrvMsg(pScrn->scrnIndex, X_ERROR, "Using LCD default\n");
	    }
	} else {
	    if (radeon_output->devices & (ATOM_DEVICE_CRT_SUPPORT)) {
		radeon_output->MonType = MT_CRT;
		info->first_load_no_devices = FALSE;
		xf86DrvMsg(pScrn->scrnIndex, X_ERROR, "Using CRT default\n");
	    } else if (radeon_output->devices & (ATOM_DEVICE_DFP_SUPPORT)) {
		radeon_output->MonType = MT_DFP;
		info->first_load_no_devices = FALSE;
		xf86DrvMsg(pScrn->scrnIndex, X_ERROR, "Using DFP default\n");
	    }
	}
    }

    radeon_bios_output_connected(output, TRUE);

    /* set montype so users can force outputs on even if detection fails */
    if (radeon_output->MonType == MT_NONE) {
	connected = FALSE;
	switch (radeon_output->ConnectorType) {
	case CONNECTOR_LVDS:
	    radeon_output->MonType = MT_LCD;
	    break;
	case CONNECTOR_DVI_D:
	case CONNECTOR_HDMI_TYPE_A:
	case CONNECTOR_HDMI_TYPE_B:
	    radeon_output->MonType = MT_DFP;
	    break;
	case CONNECTOR_VGA:
	case CONNECTOR_DVI_A:
	default:
	    radeon_output->MonType = MT_CRT;
	    break;
	case CONNECTOR_DVI_I:
	    if (radeon_output->DVIType == DVI_ANALOG)
		radeon_output->MonType = MT_CRT;
	    else if (radeon_output->DVIType == DVI_DIGITAL)
		radeon_output->MonType = MT_DFP;
	    break;
	case CONNECTOR_STV:
            radeon_output->MonType = MT_STV;
	    break;
	case CONNECTOR_CTV:
            radeon_output->MonType = MT_CTV;
	    break;
	case CONNECTOR_DIN:
            radeon_output->MonType = MT_CV;
	    break;
	case CONNECTOR_DISPLAY_PORT:
	case CONNECTOR_EDP:
	    radeon_output->MonType = MT_DP;
	    break;
	}
    }

    radeon_set_active_device(output);

    if (radeon_output->active_device & (ATOM_DEVICE_LCD_SUPPORT | ATOM_DEVICE_DFP_SUPPORT))
	output->subpixel_order = SubPixelHorizontalRGB;
    else
	output->subpixel_order = SubPixelNone;

    if (connected)
	return XF86OutputStatusConnected;
    else
	return XF86OutputStatusDisconnected;
}

static DisplayModePtr
radeon_get_modes(xf86OutputPtr output)
{
  DisplayModePtr modes;
  modes = RADEONProbeOutputModes(output);
  return modes;
}

static void
radeon_destroy (xf86OutputPtr output)
{
    if (output->driver_private)
        free(output->driver_private);
}

static void
radeon_set_backlight_level(xf86OutputPtr output, int level)
{
#if 0
    ScrnInfoPtr pScrn = output->scrn;
    RADEONInfoPtr info = RADEONPTR(pScrn);
    unsigned char * RADEONMMIO = info->MMIO;
    uint32_t lvds_gen_cntl;

    lvds_gen_cntl = INREG(RADEON_LVDS_GEN_CNTL);
    lvds_gen_cntl |= RADEON_LVDS_BL_MOD_EN;
    lvds_gen_cntl &= ~RADEON_LVDS_BL_MOD_LEVEL_MASK;
    lvds_gen_cntl |= (level << RADEON_LVDS_BL_MOD_LEVEL_SHIFT) & RADEON_LVDS_BL_MOD_LEVEL_MASK;
    //usleep (radeon_output->PanelPwrDly * 1000);
    OUTREG(RADEON_LVDS_GEN_CNTL, lvds_gen_cntl);
    lvds_gen_cntl &= ~RADEON_LVDS_BL_MOD_EN;
    //usleep (radeon_output->PanelPwrDly * 1000);
    OUTREG(RADEON_LVDS_GEN_CNTL, lvds_gen_cntl);
#endif
}

static Atom backlight_atom;
static Atom tmds_pll_atom;
static Atom rmx_atom;
static Atom monitor_type_atom;
static Atom load_detection_atom;
static Atom coherent_mode_atom;
static Atom tv_hsize_atom;
static Atom tv_hpos_atom;
static Atom tv_vpos_atom;
static Atom tv_std_atom;
#define RADEON_MAX_BACKLIGHT_LEVEL 255

static void
radeon_create_resources(xf86OutputPtr output)
{
    ScrnInfoPtr pScrn = output->scrn;
    RADEONInfoPtr info = RADEONPTR(pScrn);
    RADEONOutputPrivatePtr radeon_output = output->driver_private;
    INT32 range[2];
    int data, err;
    const char *s;

#if 0
    /* backlight control */
    if (radeon_output->type == OUTPUT_LVDS) {
	backlight_atom = MAKE_ATOM("backlight");

	range[0] = 0;
	range[1] = RADEON_MAX_BACKLIGHT_LEVEL;
	err = RRConfigureOutputProperty(output->randr_output, backlight_atom,
					FALSE, TRUE, FALSE, 2, range);
	if (err != 0) {
	    xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
		       "RRConfigureOutputProperty error, %d\n", err);
	}
	/* Set the current value of the backlight property */
	//data = (info->SavedReg->lvds_gen_cntl & RADEON_LVDS_BL_MOD_LEVEL_MASK) >> RADEON_LVDS_BL_MOD_LEVEL_SHIFT;
	data = RADEON_MAX_BACKLIGHT_LEVEL;
	err = RRChangeOutputProperty(output->randr_output, backlight_atom,
				     XA_INTEGER, 32, PropModeReplace, 1, &data,
				     FALSE, TRUE);
	if (err != 0) {
	    xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
		       "RRChangeOutputProperty error, %d\n", err);
	}
    }
#endif

    if (radeon_output->devices & (ATOM_DEVICE_CRT_SUPPORT | ATOM_DEVICE_TV_SUPPORT | ATOM_DEVICE_CV_SUPPORT)) {
	load_detection_atom = MAKE_ATOM("load_detection");

	range[0] = 0; /* off */
	range[1] = 1; /* on */
	err = RRConfigureOutputProperty(output->randr_output, load_detection_atom,
					FALSE, TRUE, FALSE, 2, range);
	if (err != 0) {
	    xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
		       "RRConfigureOutputProperty error, %d\n", err);
	}

	if (radeon_output->load_detection)
	    data = 1;
	else
	    data = 0;

	err = RRChangeOutputProperty(output->randr_output, load_detection_atom,
				     XA_INTEGER, 32, PropModeReplace, 1, &data,
				     FALSE, TRUE);
	if (err != 0) {
	    xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
		       "RRChangeOutputProperty error, %d\n", err);
	}
    }

    if (IS_AVIVO_VARIANT && (radeon_output->devices & (ATOM_DEVICE_DFP_SUPPORT))) {
	coherent_mode_atom = MAKE_ATOM("coherent_mode");

	range[0] = 0; /* off */
	range[1] = 1; /* on */
	err = RRConfigureOutputProperty(output->randr_output, coherent_mode_atom,
					FALSE, TRUE, FALSE, 2, range);
	if (err != 0) {
	    xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
		       "RRConfigureOutputProperty error, %d\n", err);
	}

	data = 1; /* coherent mode on by default */

	err = RRChangeOutputProperty(output->randr_output, coherent_mode_atom,
				     XA_INTEGER, 32, PropModeReplace, 1, &data,
				     FALSE, TRUE);
	if (err != 0) {
	    xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
		       "RRChangeOutputProperty error, %d\n", err);
	}
    }

    if ((!IS_AVIVO_VARIANT) && (radeon_output->devices & (ATOM_DEVICE_DFP1_SUPPORT))) {
	tmds_pll_atom = MAKE_ATOM("tmds_pll");

	err = RRConfigureOutputProperty(output->randr_output, tmds_pll_atom,
					FALSE, FALSE, FALSE, 0, NULL);
	if (err != 0) {
	    xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
		       "RRConfigureOutputProperty error, %d\n", err);
	}
	/* Set the current value of the property */
#if defined(__powerpc__)
	s = "driver";
#else
	s = "bios";
#endif
	if (xf86ReturnOptValBool(info->Options, OPTION_DEFAULT_TMDS_PLL, FALSE)) {
	    s = "driver";
	}

	err = RRChangeOutputProperty(output->randr_output, tmds_pll_atom,
				     XA_STRING, 8, PropModeReplace, strlen(s), (pointer)s,
				     FALSE, FALSE);
	if (err != 0) {
	    xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
		       "RRChangeOutputProperty error, %d\n", err);
	}

    }

    /* RMX control - fullscreen, centered, keep ratio, off */
    /* actually more of a crtc property as only crtc1 has rmx */
    if (radeon_output->devices & (ATOM_DEVICE_DFP_SUPPORT | ATOM_DEVICE_LCD_SUPPORT)) {
	rmx_atom = MAKE_ATOM("scaler");

	err = RRConfigureOutputProperty(output->randr_output, rmx_atom,
					FALSE, FALSE, FALSE, 0, NULL);
	if (err != 0) {
	    xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
		       "RRConfigureOutputProperty error, %d\n", err);
	}
	/* Set the current value of the property */
	switch (radeon_output->rmx_type) {
	case RMX_OFF:
	default:
	    s = "off";
	    break;
	case RMX_FULL:
	    s = "full";
	    break;
	case RMX_CENTER:
	    s = "center";
	    break;
	case RMX_ASPECT:
	    s = "aspect";
	    break;
	}
	err = RRChangeOutputProperty(output->randr_output, rmx_atom,
				     XA_STRING, 8, PropModeReplace, strlen(s), (pointer)s,
				     FALSE, FALSE);
	if (err != 0) {
	    xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
		       "RRChangeOutputProperty error, %d\n", err);
	}
    }

    /* force auto/analog/digital for DVI-I ports */
    if ((radeon_output->devices & (ATOM_DEVICE_CRT_SUPPORT)) &&
	(radeon_output->devices & (ATOM_DEVICE_DFP_SUPPORT))){
	monitor_type_atom = MAKE_ATOM("dvi_monitor_type");

	err = RRConfigureOutputProperty(output->randr_output, monitor_type_atom,
					FALSE, FALSE, FALSE, 0, NULL);
	if (err != 0) {
	    xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
		       "RRConfigureOutputProperty error, %d\n", err);
	}
	/* Set the current value of the backlight property */
	s = "auto";
	err = RRChangeOutputProperty(output->randr_output, monitor_type_atom,
				     XA_STRING, 8, PropModeReplace, strlen(s), (pointer)s,
				     FALSE, FALSE);
	if (err != 0) {
	    xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
		       "RRChangeOutputProperty error, %d\n", err);
	}
    }

    if (radeon_output->devices & (ATOM_DEVICE_TV_SUPPORT)) {
	radeon_tvout_ptr tvout = &radeon_output->tvout;
	if (!IS_AVIVO_VARIANT) {
	    tv_hsize_atom = MAKE_ATOM("tv_horizontal_size");

	    range[0] = -MAX_H_SIZE;
	    range[1] = MAX_H_SIZE;
	    err = RRConfigureOutputProperty(output->randr_output, tv_hsize_atom,
					    FALSE, TRUE, FALSE, 2, range);
	    if (err != 0) {
		xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
			   "RRConfigureOutputProperty error, %d\n", err);
	    }
	    data = 0;
	    err = RRChangeOutputProperty(output->randr_output, tv_hsize_atom,
					 XA_INTEGER, 32, PropModeReplace, 1, &data,
					 FALSE, TRUE);
	    if (err != 0) {
		xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
			   "RRChangeOutputProperty error, %d\n", err);
	    }

	    tv_hpos_atom = MAKE_ATOM("tv_horizontal_position");

	    range[0] = -MAX_H_POSITION;
	    range[1] = MAX_H_POSITION;
	    err = RRConfigureOutputProperty(output->randr_output, tv_hpos_atom,
					    FALSE, TRUE, FALSE, 2, range);
	    if (err != 0) {
		xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
			   "RRConfigureOutputProperty error, %d\n", err);
	    }
	    data = 0;
	    err = RRChangeOutputProperty(output->randr_output, tv_hpos_atom,
					 XA_INTEGER, 32, PropModeReplace, 1, &data,
					 FALSE, TRUE);
	    if (err != 0) {
		xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
			   "RRChangeOutputProperty error, %d\n", err);
	    }

	    tv_vpos_atom = MAKE_ATOM("tv_vertical_position");

	    range[0] = -MAX_V_POSITION;
	    range[1] = MAX_V_POSITION;
	    err = RRConfigureOutputProperty(output->randr_output, tv_vpos_atom,
					    FALSE, TRUE, FALSE, 2, range);
	    if (err != 0) {
		xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
			   "RRConfigureOutputProperty error, %d\n", err);
	    }
	    data = 0;
	    err = RRChangeOutputProperty(output->randr_output, tv_vpos_atom,
					 XA_INTEGER, 32, PropModeReplace, 1, &data,
					 FALSE, TRUE);
	    if (err != 0) {
		xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
			   "RRChangeOutputProperty error, %d\n", err);
	    }
	}

	tv_std_atom = MAKE_ATOM("tv_standard");

	err = RRConfigureOutputProperty(output->randr_output, tv_std_atom,
					FALSE, FALSE, FALSE, 0, NULL);
	if (err != 0) {
	    xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
		       "RRConfigureOutputProperty error, %d\n", err);
	}

	/* Set the current value of the property */
	switch (tvout->tvStd) {
	case TV_STD_PAL:
	    s = "pal";
	    break;
	case TV_STD_PAL_M:
	    s = "pal-m";
	    break;
	case TV_STD_PAL_60:
	    s = "pal-60";
	    break;
	case TV_STD_NTSC_J:
	    s = "ntsc-j";
	    break;
	case TV_STD_SCART_PAL:
	    s = "scart-pal";
	    break;
	case TV_STD_NTSC:
	default:
	    s = "ntsc";
	    break;
	}

	err = RRChangeOutputProperty(output->randr_output, tv_std_atom,
				     XA_STRING, 8, PropModeReplace, strlen(s), (pointer)s,
				     FALSE, FALSE);
	if (err != 0) {
	    xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
		       "RRChangeOutputProperty error, %d\n", err);
	}
    }
}

static Bool
radeon_set_mode_for_property(xf86OutputPtr output)
{
    ScrnInfoPtr pScrn = output->scrn;

    if (output->crtc) {
	xf86CrtcPtr crtc = output->crtc;

	if (crtc->enabled) {
#ifdef RANDR_14_INTERFACE
	    xf86CrtcSetRec crtc_set_rec;

	    crtc_set_rec.flags = (XF86CrtcSetMode |
				  XF86CrtcSetOutput |
				  XF86CrtcSetOrigin |
				  XF86CrtcSetRotation);
	    crtc_set_rec.mode = &crtc->desiredMode;
	    crtc_set_rec.rotation = crtc->desiredRotation;
	    crtc_set_rec.transform = NULL;
	    crtc_set_rec.x = crtc->desiredX;
	    crtc_set_rec.y = crtc->desiredY;
	    if (!xf86CrtcSet(crtc, &crtc_set_rec)) {
#else
	    if (!xf86CrtcSetMode(crtc, &crtc->desiredMode, crtc->desiredRotation,
				 crtc->desiredX, crtc->desiredY)) {
#endif
		xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
			   "Failed to set mode after property change!\n");
		return FALSE;
	    }
	}
    }
    return TRUE;
}

static Bool
radeon_set_property(xf86OutputPtr output, Atom property,
		       RRPropertyValuePtr value)
{
    RADEONInfoPtr info = RADEONPTR(output->scrn);
    RADEONOutputPrivatePtr radeon_output = output->driver_private;
    INT32 val;


    if (property == backlight_atom) {
	if (value->type != XA_INTEGER ||
	    value->format != 32 ||
	    value->size != 1) {
	    return FALSE;
	}

	val = *(INT32 *)value->data;
	if (val < 0 || val > RADEON_MAX_BACKLIGHT_LEVEL)
	    return FALSE;

#if defined(__powerpc__)
	val = RADEON_MAX_BACKLIGHT_LEVEL - val;
#endif

	radeon_set_backlight_level(output, val);

    } else if (property == load_detection_atom) {
	if (value->type != XA_INTEGER ||
	    value->format != 32 ||
	    value->size != 1) {
	    return FALSE;
	}

	val = *(INT32 *)value->data;
	if (val < 0 || val > 1)
	    return FALSE;

	radeon_output->load_detection = val;

    } else if (property == coherent_mode_atom) {
	Bool coherent_mode = radeon_output->coherent_mode;

	if (value->type != XA_INTEGER ||
	    value->format != 32 ||
	    value->size != 1) {
	    return FALSE;
	}

	val = *(INT32 *)value->data;
	if (val < 0 || val > 1)
	    return FALSE;

	radeon_output->coherent_mode = val;
	if (!radeon_set_mode_for_property(output)) {
	    radeon_output->coherent_mode = coherent_mode;
	    (void)radeon_set_mode_for_property(output);
	    return FALSE;
	}

    } else if (property == rmx_atom) {
	const char *s;
	RADEONRMXType rmx = radeon_output->rmx_type;

	if (value->type != XA_STRING || value->format != 8)
	    return FALSE;
	s = (char*)value->data;
	if (value->size == strlen("full") && !strncmp("full", s, strlen("full"))) {
	    radeon_output->rmx_type = RMX_FULL;
	} else if (value->size == strlen("center") && !strncmp("center", s, strlen("center"))) {
	    radeon_output->rmx_type = RMX_CENTER;
	} else if (value->size == strlen("aspect") && !strncmp("aspect", s, strlen("aspect"))) {
	    if (IS_AVIVO_VARIANT)
		radeon_output->rmx_type = RMX_ASPECT;
	    else
		return FALSE;
	} else if (value->size == strlen("off") && !strncmp("off", s, strlen("off"))) {
	    radeon_output->rmx_type = RMX_OFF;
	} else
	    return FALSE;

	if (!radeon_set_mode_for_property(output)) {
	    radeon_output->rmx_type = rmx;
	    (void)radeon_set_mode_for_property(output);
	    return FALSE;
	}
    } else if (property == tmds_pll_atom) {
	radeon_tmds_ptr tmds = NULL;
	const char *s;

	if (info->encoders[ATOM_DEVICE_DFP1_INDEX] && info->encoders[ATOM_DEVICE_DFP1_INDEX]->dev_priv)
	    tmds = (radeon_tmds_ptr)info->encoders[ATOM_DEVICE_DFP1_INDEX]->dev_priv;
	else
	    return FALSE;

	if (value->type != XA_STRING || value->format != 8)
	    return FALSE;
	s = (char*)value->data;
	if (value->size == strlen("bios") && !strncmp("bios", s, strlen("bios"))) {
	    if (!RADEONGetTMDSInfoFromBIOS(output->scrn, tmds))
		RADEONGetTMDSInfoFromTable(output->scrn, tmds);
	} else if (value->size == strlen("driver") && !strncmp("driver", s, strlen("driver")))
	    RADEONGetTMDSInfoFromTable(output->scrn, tmds);
	else
	    return FALSE;

	return radeon_set_mode_for_property(output);
    } else if (property == monitor_type_atom) {
	const char *s;
	if (value->type != XA_STRING || value->format != 8)
	    return FALSE;
	s = (char*)value->data;
	if (value->size == strlen("auto") && !strncmp("auto", s, strlen("auto"))) {
	    radeon_output->DVIType = DVI_AUTO;
	    return TRUE;
	} else if (value->size == strlen("analog") && !strncmp("analog", s, strlen("analog"))) {
	    radeon_output->DVIType = DVI_ANALOG;
	    return TRUE;
	} else if (value->size == strlen("digital") && !strncmp("digital", s, strlen("digital"))) {
	    radeon_output->DVIType = DVI_DIGITAL;
	    return TRUE;
	} else
	    return FALSE;
    } else if (property == tv_hsize_atom) {
	radeon_tvout_ptr tvout = &radeon_output->tvout;
	if (value->type != XA_INTEGER ||
	    value->format != 32 ||
	    value->size != 1) {
	    return FALSE;
	}

	val = *(INT32 *)value->data;
	if (val < -MAX_H_SIZE || val > MAX_H_SIZE)
	    return FALSE;

	tvout->hSize = val;
	if (tvout->tv_on && !IS_AVIVO_VARIANT)
	    RADEONUpdateHVPosition(output, &output->crtc->mode);

    } else if (property == tv_hpos_atom) {
	radeon_tvout_ptr tvout = &radeon_output->tvout;
	if (value->type != XA_INTEGER ||
	    value->format != 32 ||
	    value->size != 1) {
	    return FALSE;
	}

	val = *(INT32 *)value->data;
	if (val < -MAX_H_POSITION || val > MAX_H_POSITION)
	    return FALSE;

	tvout->hPos = val;
	if (tvout->tv_on && !IS_AVIVO_VARIANT)
	    RADEONUpdateHVPosition(output, &output->crtc->mode);

    } else if (property == tv_vpos_atom) {
	radeon_tvout_ptr tvout = &radeon_output->tvout;
	if (value->type != XA_INTEGER ||
	    value->format != 32 ||
	    value->size != 1) {
	    return FALSE;
	}

	val = *(INT32 *)value->data;
	if (val < -MAX_H_POSITION || val > MAX_H_POSITION)
	    return FALSE;

	tvout->vPos = val;
	if (tvout->tv_on && !IS_AVIVO_VARIANT)
	    RADEONUpdateHVPosition(output, &output->crtc->mode);

    } else if (property == tv_std_atom) {
	const char *s;
	radeon_tvout_ptr tvout = &radeon_output->tvout;
	TVStd std = tvout->tvStd;

	if (value->type != XA_STRING || value->format != 8)
	    return FALSE;
	s = (char*)value->data;
	if (value->size == strlen("ntsc") && !strncmp("ntsc", s, strlen("ntsc"))) {
	    tvout->tvStd = TV_STD_NTSC;
	} else if (value->size == strlen("pal") && !strncmp("pal", s, strlen("pal"))) {
	    tvout->tvStd = TV_STD_PAL;
	} else if (value->size == strlen("pal-m") && !strncmp("pal-m", s, strlen("pal-m"))) {
	    tvout->tvStd = TV_STD_PAL_M;
	} else if (value->size == strlen("pal-60") && !strncmp("pal-60", s, strlen("pal-60"))) {
	    tvout->tvStd = TV_STD_PAL_60;
	} else if (value->size == strlen("ntsc-j") && !strncmp("ntsc-j", s, strlen("ntsc-j"))) {
	    tvout->tvStd = TV_STD_NTSC_J;
	} else if (value->size == strlen("scart-pal") && !strncmp("scart-pal", s, strlen("scart-pal"))) {
	    tvout->tvStd = TV_STD_SCART_PAL;
	} else if (value->size == strlen("pal-cn") && !strncmp("pal-cn", s, strlen("pal-cn"))) {
	    tvout->tvStd = TV_STD_PAL_CN;
	} else if (value->size == strlen("secam") && !strncmp("secam", s, strlen("secam"))) {
	    tvout->tvStd = TV_STD_SECAM;
	} else
	    return FALSE;

	if (!radeon_set_mode_for_property(output)) {
	    tvout->tvStd = std;
	    (void)radeon_set_mode_for_property(output);
	    return FALSE;
	}
    }

    return TRUE;
}

static const xf86OutputFuncsRec radeon_output_funcs = {
    .create_resources = radeon_create_resources,
    .dpms = radeon_dpms,
    .save = radeon_save,
    .restore = radeon_restore,
    .mode_valid = radeon_mode_valid,
    .mode_fixup = radeon_mode_fixup,
    .prepare = radeon_mode_prepare,
    .mode_set = radeon_mode_set,
    .commit = radeon_mode_commit,
    .detect = radeon_detect,
    .get_modes = radeon_get_modes,
    .set_property = radeon_set_property,
    .destroy = radeon_destroy
};

Bool
RADEONI2CDoLock(xf86OutputPtr output, I2CBusPtr b, int lock_state)
{
    ScrnInfoPtr pScrn = output->scrn;
    RADEONInfoPtr  info       = RADEONPTR(pScrn);
    RADEONI2CBusPtr pRADEONI2CBus = b->DriverPrivate.ptr;
    unsigned char *RADEONMMIO = info->MMIO;
    uint32_t temp;

    if (lock_state) {
	/* RV410 appears to have a bug where the hw i2c in reset
	 * holds the i2c port in a bad state - switch hw i2c away before
	 * doing DDC - do this for all r200s/r300s for safety sakes */
	if ((info->ChipFamily >= CHIP_FAMILY_R200) && (!IS_AVIVO_VARIANT)) {
	    if (pRADEONI2CBus->mask_clk_reg == RADEON_GPIO_MONID)
                OUTREG(RADEON_DVI_I2C_CNTL_0, (RADEON_I2C_SOFT_RST |
					       R200_DVI_I2C_PIN_SEL(R200_SEL_DDC1)));
	    else
                OUTREG(RADEON_DVI_I2C_CNTL_0, (RADEON_I2C_SOFT_RST |
					       R200_DVI_I2C_PIN_SEL(R200_SEL_DDC3)));
	}

	/* set the pad in ddc mode */
	if (IS_DCE3_VARIANT &&
	    pRADEONI2CBus->hw_capable) {
	    temp = INREG(pRADEONI2CBus->mask_clk_reg);
	    temp &= ~(1 << 16);
	    OUTREG(pRADEONI2CBus->mask_clk_reg, temp);
	}

	temp = INREG(pRADEONI2CBus->a_clk_reg);
	temp &= ~(pRADEONI2CBus->a_clk_mask);
	OUTREG(pRADEONI2CBus->a_clk_reg, temp);

	temp = INREG(pRADEONI2CBus->a_data_reg);
	temp &= ~(pRADEONI2CBus->a_data_mask);
	OUTREG(pRADEONI2CBus->a_data_reg, temp);
    }

    temp = INREG(pRADEONI2CBus->mask_clk_reg);
    if (lock_state)
	temp |= (pRADEONI2CBus->mask_clk_mask);
    else
	temp &= ~(pRADEONI2CBus->mask_clk_mask);
    OUTREG(pRADEONI2CBus->mask_clk_reg, temp);
    temp = INREG(pRADEONI2CBus->mask_clk_reg);

    temp = INREG(pRADEONI2CBus->mask_data_reg);
    if (lock_state)
	temp |= (pRADEONI2CBus->mask_data_mask);
    else
	temp &= ~(pRADEONI2CBus->mask_data_mask);
    OUTREG(pRADEONI2CBus->mask_data_reg, temp);
    temp = INREG(pRADEONI2CBus->mask_data_reg);

    return TRUE;
}

static void RADEONI2CGetBits(I2CBusPtr b, int *Clock, int *data)
{
    ScrnInfoPtr    pScrn      = xf86Screens[b->scrnIndex];
    RADEONInfoPtr  info       = RADEONPTR(pScrn);
    unsigned long  val;
    unsigned char *RADEONMMIO = info->MMIO;
    RADEONI2CBusPtr pRADEONI2CBus = b->DriverPrivate.ptr;

    /* Get the result */
    val = INREG(pRADEONI2CBus->get_clk_reg);
    *Clock = (val & pRADEONI2CBus->get_clk_mask) != 0;
    val = INREG(pRADEONI2CBus->get_data_reg);
    *data  = (val & pRADEONI2CBus->get_data_mask) != 0;

}

static void RADEONI2CPutBits(I2CBusPtr b, int Clock, int data)
{
    ScrnInfoPtr    pScrn      = xf86Screens[b->scrnIndex];
    RADEONInfoPtr  info       = RADEONPTR(pScrn);
    unsigned long  val;
    unsigned char *RADEONMMIO = info->MMIO;
    RADEONI2CBusPtr pRADEONI2CBus = b->DriverPrivate.ptr;

    val = INREG(pRADEONI2CBus->put_clk_reg) & (uint32_t)~(pRADEONI2CBus->put_clk_mask);
    val |= (Clock ? 0:pRADEONI2CBus->put_clk_mask);
    OUTREG(pRADEONI2CBus->put_clk_reg, val);
    /* read back to improve reliability on some cards. */
    val = INREG(pRADEONI2CBus->put_clk_reg);

    val = INREG(pRADEONI2CBus->put_data_reg) & (uint32_t)~(pRADEONI2CBus->put_data_mask);
    val |= (data ? 0:pRADEONI2CBus->put_data_mask);
    OUTREG(pRADEONI2CBus->put_data_reg, val);
    /* read back to improve reliability on some cards. */
    val = INREG(pRADEONI2CBus->put_data_reg);

}

Bool
RADEONI2CInit(ScrnInfoPtr pScrn, I2CBusPtr *bus_ptr, char *name, RADEONI2CBusPtr pRADEONI2CBus)
{
    I2CBusPtr pI2CBus;

    pI2CBus = xf86CreateI2CBusRec();
    if (!pI2CBus) return FALSE;

    pI2CBus->BusName    = name;
    pI2CBus->scrnIndex  = pScrn->scrnIndex;
    pI2CBus->I2CPutBits = RADEONI2CPutBits;
    pI2CBus->I2CGetBits = RADEONI2CGetBits;
    pI2CBus->AcknTimeout = 5;

    pI2CBus->DriverPrivate.ptr = (pointer)pRADEONI2CBus;

    if (!xf86I2CBusInit(pI2CBus))
	return FALSE;

    *bus_ptr = pI2CBus;
    return TRUE;
}

RADEONI2CBusRec
legacy_setup_i2c_bus(int ddc_line)
{
    RADEONI2CBusRec i2c;

    i2c.hw_line = 0;
    i2c.hw_capable = FALSE;
    i2c.mask_clk_mask = RADEON_GPIO_EN_1;
    i2c.mask_data_mask = RADEON_GPIO_EN_0;
    i2c.a_clk_mask = RADEON_GPIO_A_1;
    i2c.a_data_mask = RADEON_GPIO_A_0;
    i2c.put_clk_mask = RADEON_GPIO_EN_1;
    i2c.put_data_mask = RADEON_GPIO_EN_0;
    i2c.get_clk_mask = RADEON_GPIO_Y_1;
    i2c.get_data_mask = RADEON_GPIO_Y_0;
    if ((ddc_line == RADEON_LCD_GPIO_MASK) ||
	(ddc_line == RADEON_MDGPIO_EN_REG)) {
	i2c.mask_clk_reg = ddc_line;
	i2c.mask_data_reg = ddc_line;
	i2c.a_clk_reg = ddc_line;
	i2c.a_data_reg = ddc_line;
	i2c.put_clk_reg = ddc_line;
	i2c.put_data_reg = ddc_line;
	i2c.get_clk_reg = ddc_line + 4;
	i2c.get_data_reg = ddc_line + 4;
    } else {
	i2c.mask_clk_reg = ddc_line;
	i2c.mask_data_reg = ddc_line;
	i2c.a_clk_reg = ddc_line;
	i2c.a_data_reg = ddc_line;
	i2c.put_clk_reg = ddc_line;
	i2c.put_data_reg = ddc_line;
	i2c.get_clk_reg = ddc_line;
	i2c.get_data_reg = ddc_line;
    }

    if (ddc_line)
	i2c.valid = TRUE;
    else
	i2c.valid = FALSE;

    return i2c;
}

RADEONI2CBusRec
atom_setup_i2c_bus(int ddc_line)
{
    RADEONI2CBusRec i2c;

    i2c.hw_line = 0;
    i2c.hw_capable = FALSE;
    if (ddc_line == AVIVO_GPIO_0) {
	i2c.put_clk_mask = (1 << 19);
	i2c.put_data_mask = (1 << 18);
	i2c.get_clk_mask = (1 << 19);
	i2c.get_data_mask = (1 << 18);
	i2c.mask_clk_mask = (1 << 19);
	i2c.mask_data_mask = (1 << 18);
	i2c.a_clk_mask = (1 << 19);
	i2c.a_data_mask = (1 << 18);
    } else {
	i2c.put_clk_mask = (1 << 0);
	i2c.put_data_mask = (1 << 8);
	i2c.get_clk_mask = (1 << 0);
	i2c.get_data_mask = (1 << 8);
	i2c.mask_clk_mask = (1 << 0);
	i2c.mask_data_mask = (1 << 8);
	i2c.a_clk_mask = (1 << 0);
	i2c.a_data_mask = (1 << 8);
    }
    i2c.mask_clk_reg = ddc_line;
    i2c.mask_data_reg = ddc_line;
    i2c.a_clk_reg = ddc_line + 0x4;
    i2c.a_data_reg = ddc_line + 0x4;
    i2c.put_clk_reg = ddc_line + 0x8;
    i2c.put_data_reg = ddc_line + 0x8;
    i2c.get_clk_reg = ddc_line + 0xc;
    i2c.get_data_reg = ddc_line + 0xc;
    if (ddc_line)
	i2c.valid = TRUE;
    else
	i2c.valid = FALSE;

    return i2c;
}

static void
RADEONGetTVInfo(xf86OutputPtr output)
{
    ScrnInfoPtr pScrn = output->scrn;
    RADEONInfoPtr  info       = RADEONPTR(pScrn);
    RADEONOutputPrivatePtr radeon_output = output->driver_private;
    radeon_tvout_ptr tvout = &radeon_output->tvout;
    char *optstr;

    tvout->hPos = 0;
    tvout->vPos = 0;
    tvout->hSize = 0;
    tvout->tv_on = FALSE;

    if (!RADEONGetTVInfoFromBIOS(output)) {
	/* set some reasonable defaults */
	tvout->default_tvStd = TV_STD_NTSC;
	tvout->tvStd = TV_STD_NTSC;
	tvout->TVRefClk = 27.000000000;
	tvout->SupportedTVStds = TV_STD_NTSC | TV_STD_PAL;
    }

    optstr = (char *)xf86GetOptValString(info->Options, OPTION_TVSTD);
    if (optstr) {
	if (!strncmp("ntsc", optstr, strlen("ntsc")))
	    tvout->tvStd = TV_STD_NTSC;
	else if (!strncmp("pal", optstr, strlen("pal")))
	    tvout->tvStd = TV_STD_PAL;
	else if (!strncmp("pal-m", optstr, strlen("pal-m")))
	    tvout->tvStd = TV_STD_PAL_M;
	else if (!strncmp("pal-60", optstr, strlen("pal-60")))
	    tvout->tvStd = TV_STD_PAL_60;
	else if (!strncmp("ntsc-j", optstr, strlen("ntsc-j")))
	    tvout->tvStd = TV_STD_NTSC_J;
	else if (!strncmp("scart-pal", optstr, strlen("scart-pal")))
	    tvout->tvStd = TV_STD_SCART_PAL;
	else {
	    xf86DrvMsg(pScrn->scrnIndex, X_ERROR, "Invalid TV Standard: %s\n", optstr);
	}
    }

}

void RADEONInitConnector(xf86OutputPtr output)
{
    ScrnInfoPtr	    pScrn = output->scrn;
    RADEONInfoPtr  info       = RADEONPTR(pScrn);
    RADEONOutputPrivatePtr radeon_output = output->driver_private;

    if (radeon_output->devices & (ATOM_DEVICE_LCD_SUPPORT))
	radeon_output->rmx_type = RMX_FULL;
    else
	radeon_output->rmx_type = RMX_OFF;

    if (!IS_AVIVO_VARIANT) {
	if (radeon_output->devices & (ATOM_DEVICE_CRT2_SUPPORT)) {
	    if (xf86ReturnOptValBool(info->Options, OPTION_TVDAC_LOAD_DETECT, FALSE))
		radeon_output->load_detection = 1;
	}
    }

    if (radeon_output->devices & (ATOM_DEVICE_TV_SUPPORT))
	RADEONGetTVInfo(output);

    if (radeon_output->devices & (ATOM_DEVICE_DFP_SUPPORT))
	radeon_output->coherent_mode = TRUE;

    if (radeon_output->ConnectorType == CONNECTOR_DISPLAY_PORT) {
	strcpy(radeon_output->dp_bus_name, output->name);
	strcat(radeon_output->dp_bus_name, "-DP");
	RADEON_DP_I2CInit(pScrn, &radeon_output->dp_pI2CBus, radeon_output->dp_bus_name, output);
	RADEON_DP_GetSinkType(output);
    }

    if (radeon_output->ConnectorType == CONNECTOR_EDP) {
	strcpy(radeon_output->dp_bus_name, output->name);
	strcat(radeon_output->dp_bus_name, "-eDP");
	RADEON_DP_I2CInit(pScrn, &radeon_output->dp_pI2CBus, radeon_output->dp_bus_name, output);
	RADEON_DP_GetSinkType(output);
    }

    if (radeon_output->ddc_i2c.valid)
	RADEONI2CInit(pScrn, &radeon_output->pI2CBus, output->name, &radeon_output->ddc_i2c);

}

#if defined(__powerpc__)
static Bool RADEONSetupAppleConnectors(ScrnInfoPtr pScrn)
{
    RADEONInfoPtr info       = RADEONPTR(pScrn);


    switch (info->MacModel) {
    case RADEON_MAC_IBOOK:
	info->BiosConnector[0].ddc_i2c = legacy_setup_i2c_bus(RADEON_GPIO_DVI_DDC);
	info->BiosConnector[0].ConnectorType = CONNECTOR_LVDS;
	info->BiosConnector[0].valid = TRUE;
	info->BiosConnector[0].devices = ATOM_DEVICE_LCD1_SUPPORT;
	if (!radeon_add_encoder(pScrn,
				radeon_get_encoder_id_from_supported_device(pScrn,
									    ATOM_DEVICE_LCD1_SUPPORT,
									    0),
				ATOM_DEVICE_LCD1_SUPPORT))
	    return FALSE;

	info->BiosConnector[1].ddc_i2c = legacy_setup_i2c_bus(RADEON_GPIO_VGA_DDC);
	info->BiosConnector[1].load_detection = FALSE;
	info->BiosConnector[1].ConnectorType = CONNECTOR_VGA;
	info->BiosConnector[1].valid = TRUE;
	info->BiosConnector[1].devices = ATOM_DEVICE_CRT2_SUPPORT;
	if (!radeon_add_encoder(pScrn,
				radeon_get_encoder_id_from_supported_device(pScrn,
									    ATOM_DEVICE_CRT2_SUPPORT,
									    2),
				ATOM_DEVICE_CRT2_SUPPORT))
	    return FALSE;

	info->BiosConnector[2].ConnectorType = CONNECTOR_STV;
	info->BiosConnector[2].load_detection = FALSE;
	info->BiosConnector[2].ddc_i2c.valid = FALSE;
	info->BiosConnector[2].valid = TRUE;
	info->BiosConnector[2].devices = ATOM_DEVICE_TV1_SUPPORT;
	if (!radeon_add_encoder(pScrn,
				radeon_get_encoder_id_from_supported_device(pScrn,
									    ATOM_DEVICE_TV1_SUPPORT,
									    2),
				ATOM_DEVICE_TV1_SUPPORT))
	    return FALSE;
	return TRUE;
    case RADEON_MAC_POWERBOOK_EXTERNAL:
	info->BiosConnector[0].ddc_i2c = legacy_setup_i2c_bus(RADEON_GPIO_DVI_DDC);
	info->BiosConnector[0].ConnectorType = CONNECTOR_LVDS;
	info->BiosConnector[0].valid = TRUE;
	info->BiosConnector[0].devices = ATOM_DEVICE_LCD1_SUPPORT;
	if (!radeon_add_encoder(pScrn,
				radeon_get_encoder_id_from_supported_device(pScrn,
									    ATOM_DEVICE_LCD1_SUPPORT,
									    0),
				ATOM_DEVICE_LCD1_SUPPORT))
	    return FALSE;

	info->BiosConnector[1].ddc_i2c = legacy_setup_i2c_bus(RADEON_GPIO_VGA_DDC);
	info->BiosConnector[1].ConnectorType = CONNECTOR_DVI_I;
	info->BiosConnector[1].valid = TRUE;
	info->BiosConnector[1].devices = ATOM_DEVICE_CRT1_SUPPORT | ATOM_DEVICE_DFP2_SUPPORT;
	if (!radeon_add_encoder(pScrn,
				radeon_get_encoder_id_from_supported_device(pScrn,
									    ATOM_DEVICE_CRT1_SUPPORT,
									    1),
				ATOM_DEVICE_CRT1_SUPPORT))
	    return FALSE;
	if (!radeon_add_encoder(pScrn,
				radeon_get_encoder_id_from_supported_device(pScrn,
									    ATOM_DEVICE_DFP2_SUPPORT,
									    0),
				ATOM_DEVICE_DFP2_SUPPORT))
	    return FALSE;

	info->BiosConnector[2].ConnectorType = CONNECTOR_STV;
	info->BiosConnector[2].load_detection = FALSE;
	info->BiosConnector[2].ddc_i2c.valid = FALSE;
	info->BiosConnector[2].valid = TRUE;
	info->BiosConnector[2].devices = ATOM_DEVICE_TV1_SUPPORT;
	if (!radeon_add_encoder(pScrn,
				radeon_get_encoder_id_from_supported_device(pScrn,
									    ATOM_DEVICE_TV1_SUPPORT,
									    2),
				ATOM_DEVICE_TV1_SUPPORT))
	    return FALSE;
	return TRUE;
    case RADEON_MAC_POWERBOOK_INTERNAL:
	info->BiosConnector[0].ddc_i2c = legacy_setup_i2c_bus(RADEON_GPIO_DVI_DDC);
	info->BiosConnector[0].ConnectorType = CONNECTOR_LVDS;
	info->BiosConnector[0].valid = TRUE;
	info->BiosConnector[0].devices = ATOM_DEVICE_LCD1_SUPPORT;
	if (!radeon_add_encoder(pScrn,
				radeon_get_encoder_id_from_supported_device(pScrn,
									    ATOM_DEVICE_LCD1_SUPPORT,
									    0),
				ATOM_DEVICE_LCD1_SUPPORT))
	    return FALSE;

	info->BiosConnector[1].ddc_i2c = legacy_setup_i2c_bus(RADEON_GPIO_VGA_DDC);
	info->BiosConnector[1].ConnectorType = CONNECTOR_DVI_I;
	info->BiosConnector[1].valid = TRUE;
	info->BiosConnector[1].devices = ATOM_DEVICE_CRT1_SUPPORT | ATOM_DEVICE_DFP1_SUPPORT;
	if (!radeon_add_encoder(pScrn,
				radeon_get_encoder_id_from_supported_device(pScrn,
									    ATOM_DEVICE_CRT1_SUPPORT,
									    1),
				ATOM_DEVICE_CRT1_SUPPORT))
	    return FALSE;
	if (!radeon_add_encoder(pScrn,
				radeon_get_encoder_id_from_supported_device(pScrn,
									    ATOM_DEVICE_DFP1_SUPPORT,
									    0),
				ATOM_DEVICE_DFP1_SUPPORT))
	    return FALSE;

	info->BiosConnector[2].ConnectorType = CONNECTOR_STV;
	info->BiosConnector[2].load_detection = FALSE;
	info->BiosConnector[2].ddc_i2c.valid = FALSE;
	info->BiosConnector[2].valid = TRUE;
	info->BiosConnector[2].devices = ATOM_DEVICE_TV1_SUPPORT;
	if (!radeon_add_encoder(pScrn,
				radeon_get_encoder_id_from_supported_device(pScrn,
									    ATOM_DEVICE_TV1_SUPPORT,
									    2),
				ATOM_DEVICE_TV1_SUPPORT))
	    return FALSE;
	return TRUE;
    case RADEON_MAC_POWERBOOK_VGA:
	info->BiosConnector[0].ddc_i2c = legacy_setup_i2c_bus(RADEON_GPIO_DVI_DDC);
	info->BiosConnector[0].ConnectorType = CONNECTOR_LVDS;
	info->BiosConnector[0].valid = TRUE;
	info->BiosConnector[0].devices = ATOM_DEVICE_LCD1_SUPPORT;
	if (!radeon_add_encoder(pScrn,
				radeon_get_encoder_id_from_supported_device(pScrn,
									    ATOM_DEVICE_LCD1_SUPPORT,
									    0),
				ATOM_DEVICE_LCD1_SUPPORT))
	    return FALSE;

	info->BiosConnector[1].ddc_i2c = legacy_setup_i2c_bus(RADEON_GPIO_VGA_DDC);
	info->BiosConnector[1].ConnectorType = CONNECTOR_VGA;
	info->BiosConnector[1].valid = TRUE;
	info->BiosConnector[1].devices = ATOM_DEVICE_CRT1_SUPPORT;
	if (!radeon_add_encoder(pScrn,
				radeon_get_encoder_id_from_supported_device(pScrn,
									    ATOM_DEVICE_CRT1_SUPPORT,
									    1),
				ATOM_DEVICE_CRT1_SUPPORT))
	    return FALSE;

	info->BiosConnector[2].ConnectorType = CONNECTOR_STV;
	info->BiosConnector[2].load_detection = FALSE;
	info->BiosConnector[2].ddc_i2c.valid = FALSE;
	info->BiosConnector[2].valid = TRUE;
	info->BiosConnector[2].devices = ATOM_DEVICE_TV1_SUPPORT;
	if (!radeon_add_encoder(pScrn,
				radeon_get_encoder_id_from_supported_device(pScrn,
									    ATOM_DEVICE_TV1_SUPPORT,
									    2),
				ATOM_DEVICE_TV1_SUPPORT))
	    return FALSE;
	return TRUE;
    case RADEON_MAC_MINI_EXTERNAL:
	info->BiosConnector[0].ddc_i2c = legacy_setup_i2c_bus(RADEON_GPIO_CRT2_DDC);
	info->BiosConnector[0].load_detection = FALSE;
	info->BiosConnector[0].ConnectorType = CONNECTOR_DVI_I;
	info->BiosConnector[0].valid = TRUE;
	info->BiosConnector[0].devices = ATOM_DEVICE_CRT2_SUPPORT | ATOM_DEVICE_DFP2_SUPPORT;
	if (!radeon_add_encoder(pScrn,
				radeon_get_encoder_id_from_supported_device(pScrn,
									    ATOM_DEVICE_CRT2_SUPPORT,
									    2),
				ATOM_DEVICE_CRT2_SUPPORT))
	    return FALSE;
	if (!radeon_add_encoder(pScrn,
				radeon_get_encoder_id_from_supported_device(pScrn,
									    ATOM_DEVICE_DFP2_SUPPORT,
									    0),
				ATOM_DEVICE_DFP2_SUPPORT))
	    return FALSE;

	info->BiosConnector[1].ConnectorType = CONNECTOR_STV;
	info->BiosConnector[1].load_detection = FALSE;
	info->BiosConnector[1].ddc_i2c.valid = FALSE;
	info->BiosConnector[1].valid = TRUE;
	info->BiosConnector[1].devices = ATOM_DEVICE_TV1_SUPPORT;
	if (!radeon_add_encoder(pScrn,
				radeon_get_encoder_id_from_supported_device(pScrn,
									    ATOM_DEVICE_TV1_SUPPORT,
									    2),
				ATOM_DEVICE_TV1_SUPPORT))
	    return FALSE;
	return TRUE;
    case RADEON_MAC_MINI_INTERNAL:
	info->BiosConnector[0].ddc_i2c = legacy_setup_i2c_bus(RADEON_GPIO_CRT2_DDC);
	info->BiosConnector[0].load_detection = FALSE;
	info->BiosConnector[0].ConnectorType = CONNECTOR_DVI_I;
	info->BiosConnector[0].valid = TRUE;
	info->BiosConnector[0].devices = ATOM_DEVICE_CRT2_SUPPORT | ATOM_DEVICE_DFP1_SUPPORT;
	if (!radeon_add_encoder(pScrn,
				radeon_get_encoder_id_from_supported_device(pScrn,
									    ATOM_DEVICE_CRT2_SUPPORT,
									    2),
				ATOM_DEVICE_CRT2_SUPPORT))
	    return FALSE;
	if (!radeon_add_encoder(pScrn,
				radeon_get_encoder_id_from_supported_device(pScrn,
									    ATOM_DEVICE_DFP1_SUPPORT,
									    0),
				ATOM_DEVICE_DFP1_SUPPORT))
	    return FALSE;

	info->BiosConnector[1].ConnectorType = CONNECTOR_STV;
	info->BiosConnector[1].load_detection = FALSE;
	info->BiosConnector[1].ddc_i2c.valid = FALSE;
	info->BiosConnector[1].valid = TRUE;
	info->BiosConnector[1].devices = ATOM_DEVICE_TV1_SUPPORT;
	if (!radeon_add_encoder(pScrn,
				radeon_get_encoder_id_from_supported_device(pScrn,
									    ATOM_DEVICE_TV1_SUPPORT,
									    2),
				ATOM_DEVICE_TV1_SUPPORT))
	    return FALSE;
	return TRUE;
    case RADEON_MAC_IMAC_G5_ISIGHT:
	info->BiosConnector[0].ddc_i2c = legacy_setup_i2c_bus(RADEON_GPIO_MONID);
	info->BiosConnector[0].ConnectorType = CONNECTOR_DVI_D;
	info->BiosConnector[0].valid = TRUE;
	info->BiosConnector[0].devices = ATOM_DEVICE_DFP1_SUPPORT;
	if (!radeon_add_encoder(pScrn,
				radeon_get_encoder_id_from_supported_device(pScrn,
									    ATOM_DEVICE_DFP1_SUPPORT,
									    0),
				ATOM_DEVICE_DFP1_SUPPORT))
	    return FALSE;

	info->BiosConnector[1].ddc_i2c = legacy_setup_i2c_bus(RADEON_GPIO_DVI_DDC);
	info->BiosConnector[1].load_detection = FALSE;
	info->BiosConnector[1].ConnectorType = CONNECTOR_VGA;
	info->BiosConnector[1].valid = TRUE;
	info->BiosConnector[1].devices = ATOM_DEVICE_CRT2_SUPPORT;
	if (!radeon_add_encoder(pScrn,
				radeon_get_encoder_id_from_supported_device(pScrn,
									    ATOM_DEVICE_CRT2_SUPPORT,
									    2),
				ATOM_DEVICE_CRT2_SUPPORT))
	    return FALSE;

	info->BiosConnector[2].ConnectorType = CONNECTOR_STV;
	info->BiosConnector[2].load_detection = FALSE;
	info->BiosConnector[2].ddc_i2c.valid = FALSE;
	info->BiosConnector[2].valid = TRUE;
	info->BiosConnector[2].devices = ATOM_DEVICE_TV1_SUPPORT;
	if (!radeon_add_encoder(pScrn,
				radeon_get_encoder_id_from_supported_device(pScrn,
									    ATOM_DEVICE_TV1_SUPPORT,
									    2),
				ATOM_DEVICE_TV1_SUPPORT))
	    return FALSE;
	return TRUE;
    case RADEON_MAC_EMAC:
	/* eMac G4 800/1.0 with radeon 7500, no EDID on internal monitor
	 * later eMac's (G4 1.25/1.42) with radeon 9200 and 9600 may have
	 * different ddc setups.  need to verify
	 */
	info->BiosConnector[0].ddc_i2c = legacy_setup_i2c_bus(RADEON_GPIO_VGA_DDC);
	info->BiosConnector[0].ConnectorType = CONNECTOR_VGA;
	info->BiosConnector[0].valid = TRUE;
	info->BiosConnector[0].devices = ATOM_DEVICE_CRT1_SUPPORT;
	if (!radeon_add_encoder(pScrn,
				radeon_get_encoder_id_from_supported_device(pScrn,
									    ATOM_DEVICE_CRT1_SUPPORT,
									    1),
				ATOM_DEVICE_CRT1_SUPPORT))
	    return FALSE;

	info->BiosConnector[1].ddc_i2c = legacy_setup_i2c_bus(RADEON_GPIO_CRT2_DDC);
	info->BiosConnector[1].load_detection = FALSE;
	info->BiosConnector[1].ConnectorType = CONNECTOR_VGA;
	info->BiosConnector[1].valid = TRUE;
	info->BiosConnector[1].devices = ATOM_DEVICE_CRT2_SUPPORT;
	if (!radeon_add_encoder(pScrn,
				radeon_get_encoder_id_from_supported_device(pScrn,
									    ATOM_DEVICE_CRT2_SUPPORT,
									    2),
				ATOM_DEVICE_CRT2_SUPPORT))
	    return FALSE;

	info->BiosConnector[2].ConnectorType = CONNECTOR_STV;
	info->BiosConnector[2].load_detection = FALSE;
	info->BiosConnector[2].ddc_i2c.valid = FALSE;
	info->BiosConnector[2].valid = TRUE;
	info->BiosConnector[2].devices = ATOM_DEVICE_TV1_SUPPORT;
	if (!radeon_add_encoder(pScrn,
				radeon_get_encoder_id_from_supported_device(pScrn,
									    ATOM_DEVICE_TV1_SUPPORT,
									    2),
				ATOM_DEVICE_TV1_SUPPORT))
	    return FALSE;
	return TRUE;
    case RADEON_MAC_SAM440EP:
	/* LVDS header */
	info->BiosConnector[0].ddc_i2c = legacy_setup_i2c_bus(0);
	info->BiosConnector[0].ConnectorType = CONNECTOR_LVDS;
	info->BiosConnector[0].valid = TRUE;
	info->BiosConnector[0].devices = ATOM_DEVICE_LCD1_SUPPORT;
	if (!radeon_add_encoder(pScrn,
				radeon_get_encoder_id_from_supported_device(pScrn,
									    ATOM_DEVICE_LCD1_SUPPORT,
									    0),
				ATOM_DEVICE_LCD1_SUPPORT))
	    return FALSE;

	/* DVI-I port */
	info->BiosConnector[1].ddc_i2c = legacy_setup_i2c_bus(RADEON_GPIO_DVI_DDC);
	info->BiosConnector[1].ConnectorType = CONNECTOR_DVI_I;
	info->BiosConnector[1].valid = TRUE;
	info->BiosConnector[1].devices = ATOM_DEVICE_CRT2_SUPPORT | ATOM_DEVICE_DFP1_SUPPORT;
	if (!radeon_add_encoder(pScrn,
				radeon_get_encoder_id_from_supported_device(pScrn,
									    ATOM_DEVICE_CRT2_SUPPORT,
									    2),
				ATOM_DEVICE_CRT2_SUPPORT))
	    return FALSE;
	if (!radeon_add_encoder(pScrn,
				radeon_get_encoder_id_from_supported_device(pScrn,
									    ATOM_DEVICE_DFP1_SUPPORT,
									    0),
				ATOM_DEVICE_DFP1_SUPPORT))
	    return FALSE;

	/* VGA header */
	info->BiosConnector[2].ddc_i2c = legacy_setup_i2c_bus(RADEON_GPIO_VGA_DDC);
	info->BiosConnector[2].ConnectorType = CONNECTOR_VGA;
	info->BiosConnector[2].valid = TRUE;
	info->BiosConnector[2].devices = ATOM_DEVICE_CRT1_SUPPORT;
	if (!radeon_add_encoder(pScrn,
				radeon_get_encoder_id_from_supported_device(pScrn,
									    ATOM_DEVICE_CRT1_SUPPORT,
									    1),
				ATOM_DEVICE_CRT1_SUPPORT))
	    return FALSE;

	/* s-video */
	info->BiosConnector[3].ConnectorType = CONNECTOR_STV;
	info->BiosConnector[3].load_detection = FALSE;
	info->BiosConnector[3].ddc_i2c.valid = FALSE;
	info->BiosConnector[3].valid = TRUE;
	info->BiosConnector[3].devices = ATOM_DEVICE_TV1_SUPPORT;
	if (!radeon_add_encoder(pScrn,
				radeon_get_encoder_id_from_supported_device(pScrn,
									    ATOM_DEVICE_TV1_SUPPORT,
									    2),
				ATOM_DEVICE_TV1_SUPPORT))
	    return FALSE;
	return TRUE;
    default:
	return FALSE;
    }

    return FALSE;
}
#endif

static void RADEONSetupGenericConnectors(ScrnInfoPtr pScrn)
{
    RADEONInfoPtr info       = RADEONPTR(pScrn);
    RADEONEntPtr pRADEONEnt  = RADEONEntPriv(pScrn);

    if (IS_AVIVO_VARIANT)
	return;

    if (!pRADEONEnt->HasCRTC2) {
	info->BiosConnector[0].ddc_i2c = legacy_setup_i2c_bus(RADEON_GPIO_VGA_DDC);
	info->BiosConnector[0].ConnectorType = CONNECTOR_VGA;
	info->BiosConnector[0].valid = TRUE;
	info->BiosConnector[0].devices = ATOM_DEVICE_CRT1_SUPPORT;
	radeon_add_encoder(pScrn,
			   radeon_get_encoder_id_from_supported_device(pScrn,
								       ATOM_DEVICE_CRT1_SUPPORT,
								       1),
			   ATOM_DEVICE_CRT1_SUPPORT);
	return;
    }

    if (info->IsMobility) {
	/* Below is the most common setting, but may not be true */
	if (info->IsIGP) {
	    info->BiosConnector[0].ddc_i2c = legacy_setup_i2c_bus(RADEON_LCD_GPIO_MASK);
	    info->BiosConnector[0].ConnectorType = CONNECTOR_LVDS;
	    info->BiosConnector[0].valid = TRUE;
	    info->BiosConnector[0].devices = ATOM_DEVICE_LCD1_SUPPORT;
	    radeon_add_encoder(pScrn,
			       radeon_get_encoder_id_from_supported_device(pScrn,
									   ATOM_DEVICE_LCD1_SUPPORT,
									   0),
			       ATOM_DEVICE_LCD1_SUPPORT);

	    /* IGP only has TVDAC */
	    if ((info->ChipFamily == CHIP_FAMILY_RS400) ||
		(info->ChipFamily == CHIP_FAMILY_RS480))
		info->BiosConnector[1].ddc_i2c = legacy_setup_i2c_bus(RADEON_GPIO_CRT2_DDC);
	    else
		info->BiosConnector[1].ddc_i2c = legacy_setup_i2c_bus(RADEON_GPIO_VGA_DDC);
	    info->BiosConnector[1].load_detection = FALSE;
	    info->BiosConnector[1].ConnectorType = CONNECTOR_VGA;
	    info->BiosConnector[1].valid = TRUE;
	    info->BiosConnector[1].devices = ATOM_DEVICE_CRT1_SUPPORT;
	    radeon_add_encoder(pScrn,
			       radeon_get_encoder_id_from_supported_device(pScrn,
									   ATOM_DEVICE_CRT1_SUPPORT,
									   2),
			       ATOM_DEVICE_CRT1_SUPPORT);
	} else {
#if defined(__powerpc__)
	    info->BiosConnector[0].ddc_i2c = legacy_setup_i2c_bus(RADEON_GPIO_DVI_DDC);
#else
	    info->BiosConnector[0].ddc_i2c = legacy_setup_i2c_bus(RADEON_LCD_GPIO_MASK);
#endif
	    info->BiosConnector[0].ConnectorType = CONNECTOR_LVDS;
	    info->BiosConnector[0].valid = TRUE;
	    info->BiosConnector[0].devices = ATOM_DEVICE_LCD1_SUPPORT;
	    radeon_add_encoder(pScrn,
			       radeon_get_encoder_id_from_supported_device(pScrn,
									   ATOM_DEVICE_LCD1_SUPPORT,
									   0),
			       ATOM_DEVICE_LCD1_SUPPORT);

	    info->BiosConnector[1].ddc_i2c = legacy_setup_i2c_bus(RADEON_GPIO_VGA_DDC);
	    info->BiosConnector[1].ConnectorType = CONNECTOR_VGA;
	    info->BiosConnector[1].valid = TRUE;
	    info->BiosConnector[1].devices = ATOM_DEVICE_CRT1_SUPPORT;
	    radeon_add_encoder(pScrn,
			       radeon_get_encoder_id_from_supported_device(pScrn,
									   ATOM_DEVICE_CRT1_SUPPORT,
									   1),
			       ATOM_DEVICE_CRT1_SUPPORT);
	}
    } else {
	/* Below is the most common setting, but may not be true */
	if (info->IsIGP) {
	    if ((info->ChipFamily == CHIP_FAMILY_RS400) ||
		(info->ChipFamily == CHIP_FAMILY_RS480))
		info->BiosConnector[0].ddc_i2c = legacy_setup_i2c_bus(RADEON_GPIO_CRT2_DDC);
	    else
		info->BiosConnector[0].ddc_i2c = legacy_setup_i2c_bus(RADEON_GPIO_VGA_DDC);
	    info->BiosConnector[0].load_detection = FALSE;
	    info->BiosConnector[0].ConnectorType = CONNECTOR_VGA;
	    info->BiosConnector[0].valid = TRUE;
	    info->BiosConnector[0].devices = ATOM_DEVICE_CRT1_SUPPORT;
	    radeon_add_encoder(pScrn,
			       radeon_get_encoder_id_from_supported_device(pScrn,
									   ATOM_DEVICE_CRT1_SUPPORT,
									   1),
			       ATOM_DEVICE_CRT1_SUPPORT);

	    /* not sure what a good default DDCType for DVI on
	     * IGP desktop chips is
	     */
	    info->BiosConnector[1].ddc_i2c = legacy_setup_i2c_bus(RADEON_GPIO_MONID); /* DDC_DVI? */
	    info->BiosConnector[1].ConnectorType = CONNECTOR_DVI_D;
	    info->BiosConnector[1].valid = TRUE;
	    info->BiosConnector[1].devices = ATOM_DEVICE_DFP1_SUPPORT;
	    radeon_add_encoder(pScrn,
			       radeon_get_encoder_id_from_supported_device(pScrn,
									   ATOM_DEVICE_DFP1_SUPPORT,
									   0),
			       ATOM_DEVICE_DFP1_SUPPORT);
	} else {
	    info->BiosConnector[0].ddc_i2c = legacy_setup_i2c_bus(RADEON_GPIO_DVI_DDC);
	    info->BiosConnector[0].load_detection = FALSE;
	    info->BiosConnector[0].ConnectorType = CONNECTOR_DVI_I;
	    info->BiosConnector[0].valid = TRUE;
	    info->BiosConnector[0].devices = ATOM_DEVICE_CRT2_SUPPORT | ATOM_DEVICE_DFP1_SUPPORT;
	    radeon_add_encoder(pScrn,
			       radeon_get_encoder_id_from_supported_device(pScrn,
									   ATOM_DEVICE_CRT2_SUPPORT,
									   2),
			       ATOM_DEVICE_CRT2_SUPPORT);
	    radeon_add_encoder(pScrn,
			       radeon_get_encoder_id_from_supported_device(pScrn,
									   ATOM_DEVICE_DFP1_SUPPORT,
									   0),
			       ATOM_DEVICE_DFP1_SUPPORT);

#if defined(__powerpc__)
	    info->BiosConnector[1].ddc_i2c = legacy_setup_i2c_bus(RADEON_GPIO_VGA_DDC);
	    info->BiosConnector[1].ConnectorType = CONNECTOR_DVI_I;
	    info->BiosConnector[1].valid = TRUE;
	    info->BiosConnector[1].devices = ATOM_DEVICE_CRT1_SUPPORT | ATOM_DEVICE_DFP2_SUPPORT;
	    radeon_add_encoder(pScrn,
			       radeon_get_encoder_id_from_supported_device(pScrn,
									   ATOM_DEVICE_CRT1_SUPPORT,
									   1),
			       ATOM_DEVICE_CRT1_SUPPORT);
	    radeon_add_encoder(pScrn,
			       radeon_get_encoder_id_from_supported_device(pScrn,
									   ATOM_DEVICE_DFP2_SUPPORT,
									   0),
			       ATOM_DEVICE_DFP2_SUPPORT);
#else
	    info->BiosConnector[1].ddc_i2c = legacy_setup_i2c_bus(RADEON_GPIO_VGA_DDC);
	    info->BiosConnector[1].ConnectorType = CONNECTOR_VGA;
	    info->BiosConnector[1].valid = TRUE;
	    info->BiosConnector[1].devices = ATOM_DEVICE_CRT1_SUPPORT;
	    radeon_add_encoder(pScrn,
			       radeon_get_encoder_id_from_supported_device(pScrn,
									   ATOM_DEVICE_CRT1_SUPPORT,
									   1),
			       ATOM_DEVICE_CRT1_SUPPORT);
#endif
	}
    }

    if (info->InternalTVOut) {
	info->BiosConnector[2].ConnectorType = CONNECTOR_STV;
	info->BiosConnector[2].load_detection = FALSE;
	info->BiosConnector[2].ddc_i2c.valid = FALSE;
	info->BiosConnector[2].valid = TRUE;
	info->BiosConnector[2].devices = ATOM_DEVICE_TV1_SUPPORT;
	radeon_add_encoder(pScrn,
			       radeon_get_encoder_id_from_supported_device(pScrn,
									   ATOM_DEVICE_TV1_SUPPORT,
									   2),
			       ATOM_DEVICE_TV1_SUPPORT);
    }

    /* Some cards have the DDC lines swapped and we have no way to
     * detect it yet (Mac cards)
     */
    if (xf86ReturnOptValBool(info->Options, OPTION_REVERSE_DDC, FALSE)) {
	info->BiosConnector[0].ddc_i2c = legacy_setup_i2c_bus(RADEON_GPIO_VGA_DDC);
	info->BiosConnector[1].ddc_i2c = legacy_setup_i2c_bus(RADEON_GPIO_DVI_DDC);
    }
}

#if defined(__powerpc__)

#ifdef __OpenBSD__
#include <sys/param.h>
#include <sys/sysctl.h>
#endif

/*
 * Returns RADEONMacModel or 0 based on lines 'detected as' and 'machine'
 * in /proc/cpuinfo (on Linux) */
static RADEONMacModel RADEONDetectMacModel(ScrnInfoPtr pScrn)
{
    RADEONInfoPtr info = RADEONPTR(pScrn);
    RADEONMacModel ret = 0;
#ifdef __linux__
    char cpuline[50];  /* 50 should be sufficient for our purposes */
    FILE *f = fopen ("/proc/cpuinfo", "r");

    /* Some macs (minis and powerbooks) use internal tmds, others use external tmds
     * and not just for dual-link TMDS, it shows up with single-link as well.
     * Unforunately, there doesn't seem to be any good way to figure it out.
     */

    /*
     * PowerBook5,[1-5]: external tmds, single-link
     * PowerBook5,[789]: external tmds, dual-link
     * PowerBook5,6:     external tmds, single-link or dual-link
     * need to add another option to specify the external tmds chip
     * or find out what's used and add it.
     */


    if (f != NULL) {
	while (fgets(cpuline, sizeof cpuline, f)) {
	    if (!strncmp(cpuline, "machine", strlen ("machine"))) {
		if (strstr(cpuline, "PowerBook5,1") ||
		    strstr(cpuline, "PowerBook5,2") ||
		    strstr(cpuline, "PowerBook5,3") ||
		    strstr(cpuline, "PowerBook5,4") ||
		    strstr(cpuline, "PowerBook5,5")) {
		    ret = RADEON_MAC_POWERBOOK_EXTERNAL; /* single link */
		    info->ext_tmds_chip = RADEON_SIL_164; /* works on 5,2 */
		    break;
		}

		if (strstr(cpuline, "PowerBook5,6")) {
		    ret = RADEON_MAC_POWERBOOK_EXTERNAL; /* dual or single link */
		    break;
		}

		if (strstr(cpuline, "PowerBook5,7") ||
		    strstr(cpuline, "PowerBook5,8") ||
		    strstr(cpuline, "PowerBook5,9")) {
		    ret = RADEON_MAC_POWERBOOK_EXTERNAL; /* dual link */
		    info->ext_tmds_chip = RADEON_SIL_1178; /* guess */
		    break;
		}

		if (strstr(cpuline, "PowerBook3,3")) {
		    ret = RADEON_MAC_POWERBOOK_VGA; /* vga rather than dvi */
		    break;
		}

		if (strstr(cpuline, "PowerMac10,1")) {
		    ret = RADEON_MAC_MINI_INTERNAL; /* internal tmds */
		    break;
		}
		if (strstr(cpuline, "PowerMac10,2")) {
		    ret = RADEON_MAC_MINI_EXTERNAL; /* external tmds */
		    break;
		}
	    } else if (!strncmp(cpuline, "detected as", strlen("detected as"))) {
		if (strstr(cpuline, "iBook")) {
		    ret = RADEON_MAC_IBOOK;
		    break;
		} else if (strstr(cpuline, "PowerBook")) {
		    ret = RADEON_MAC_POWERBOOK_INTERNAL; /* internal tmds */
		    break;
		} else if (strstr(cpuline, "iMac G5 (iSight)")) {
		    ret = RADEON_MAC_IMAC_G5_ISIGHT;
		    break;
		} else if (strstr(cpuline, "eMac")) {
		    ret = RADEON_MAC_EMAC;
		    break;
		}

		/* No known PowerMac model detected */
		break;
	    }
	}

	fclose (f);
    } else
	xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
		   "Cannot detect PowerMac model because /proc/cpuinfo not "
		   "readable.\n");

#endif /* __linux */

#ifdef __OpenBSD__
    char model[32];
    int mib[2];
    size_t len;

    mib[0] = CTL_HW;
    mib[1] = HW_PRODUCT;
    len = sizeof(model);
    if (sysctl(mib, 2, model, &len, NULL, 0) >= 0) {
	if (strcmp(model, "PowerBook5,1") == 0 ||
	    strcmp(model, "PowerBook5,2") == 0 ||
	    strcmp(model, "PowerBook5,3") == 0 ||
	    strcmp(model, "PowerBook5,4") == 0 ||
	    strcmp(model, "PowerBook5,5") == 0) {
	    ret = RADEON_MAC_POWERBOOK_EXTERNAL; /* single link */
	    info->ext_tmds_chip = RADEON_SIL_164; /* works on 5,2 */
	}

	if (strcmp(model, "PowerBook5,6") == 0) {
	    ret = RADEON_MAC_POWERBOOK_EXTERNAL; /* dual or single link */
	}

	if (strcmp(model, "PowerBook5,7") == 0 ||
	    strcmp(model, "PowerBook5,8") == 0 ||
	    strcmp(model, "PowerBook5,9") == 0) {
	    ret = RADEON_MAC_POWERBOOK_EXTERNAL; /* dual link */
	    info->ext_tmds_chip = RADEON_SIL_1178; /* guess */
	}

	if (strcmp(model, "PowerBook3,3") == 0) {
	    ret = RADEON_MAC_POWERBOOK_VGA; /* vga rather than dvi */
	}

	if (strcmp(model, "PowerMac10,1") == 0) {
	    ret = RADEON_MAC_MINI_INTERNAL; /* internal tmds */
	}

	if (strcmp(model, "PowerMac10,2") == 0) {
	    ret = RADEON_MAC_MINI_EXTERNAL; /* external tmds */
	}

	if (strcmp(model, "PowerBook2,1") == 0 ||
	    strcmp(model, "PowerBook2,2") == 0 ||
	    strcmp(model, "PowerBook4,1") == 0 ||
	    strcmp(model, "PowerBook4,2") == 0 ||
	    strcmp(model, "PowerBook4,3") == 0 ||
	    strcmp(model, "PowerBook6,3") == 0 ||
	    strcmp(model, "PowerBook6,5") == 0 ||
	    strcmp(model, "PowerBook6,7") == 0) {
	    ret = RADEON_MAC_IBOOK;
	}

	if (strcmp(model, "PowerBook1,1") == 0 ||
	    strcmp(model, "PowerBook3,1") == 0 ||
	    strcmp(model, "PowerBook3,2") == 0 ||
	    strcmp(model, "PowerBook3,4") == 0 ||
	    strcmp(model, "PowerBook3,5") == 0) {
	    ret = RADEON_MAC_POWERBOOK_INTERNAL;
	}

	if (strcmp(model, "PowerMac12,1") == 0) {
	    ret = RADEON_MAC_IMAC_G5_ISIGHT;
	}
    }
#endif /* __OpenBSD__ */

    if (ret) {
	xf86DrvMsg(pScrn->scrnIndex, X_DEFAULT, "Detected %s.\n",
		   ret == RADEON_MAC_POWERBOOK_EXTERNAL ? "PowerBook with external DVI" :
		   ret == RADEON_MAC_POWERBOOK_INTERNAL ? "PowerBook with integrated DVI" :
		   ret == RADEON_MAC_POWERBOOK_VGA ? "PowerBook with VGA" :
		   ret == RADEON_MAC_IBOOK ? "iBook" :
		   ret == RADEON_MAC_MINI_EXTERNAL ? "Mac Mini with external DVI" :
		   ret == RADEON_MAC_MINI_INTERNAL ? "Mac Mini with integrated DVI" :
		   "iMac G5 iSight");
	xf86DrvMsg(pScrn->scrnIndex, X_INFO,
		   "If this is not correct, try Option \"MacModel\" and "
		   "consider reporting to the\n");
	xf86DrvMsg(pScrn->scrnIndex, X_INFO,
		   "xorg-driver-ati@@lists.x.org mailing list"
#ifdef __linux__
		   " with the contents of /proc/cpuinfo"
#endif
		   ".\n");
    }

    return ret;
}

#endif /* __powerpc__ */

static int
radeon_output_clones (ScrnInfoPtr pScrn, xf86OutputPtr output)
{
    RADEONInfoPtr info = RADEONPTR(pScrn);
    RADEONOutputPrivatePtr radeon_output = output->driver_private;
    xf86CrtcConfigPtr	config = XF86_CRTC_CONFIG_PTR (pScrn);
    int			o;
    int			index_mask = 0;

    /* no cloning with zaphod */
    if (info->IsPrimary || info->IsSecondary)
	return index_mask;

    /* DIG routing gets problematic */
    if (info->ChipFamily >= CHIP_FAMILY_R600)
	return index_mask;

    /* LVDS is too wacky */
    if (radeon_output->devices & (ATOM_DEVICE_LCD_SUPPORT))
	return index_mask;

    /* TV requires very specific timing */
    if (radeon_output->devices & (ATOM_DEVICE_TV_SUPPORT))
	return index_mask;

    /* DVO requires 2x ppll clocks depending on the tmds chip */
    if (radeon_output->devices & (ATOM_DEVICE_DFP2_SUPPORT))
	return index_mask;

    for (o = 0; o < config->num_output; o++) {
	xf86OutputPtr clone = config->output[o];
	RADEONOutputPrivatePtr radeon_clone = clone->driver_private;

	if (output == clone) /* don't clone yourself */
	    continue;
	else if (radeon_clone->devices & (ATOM_DEVICE_LCD_SUPPORT)) /* LVDS */
	    continue;
	else if (radeon_clone->devices & (ATOM_DEVICE_TV_SUPPORT)) /* TV */
	    continue;
	else
	    index_mask |= (1 << o);
    }

    return index_mask;
}

static xf86OutputPtr
RADEONOutputCreate(ScrnInfoPtr pScrn, const char *name, int i)
{
    char buf[32];
    sprintf(buf, name, i);
    return xf86OutputCreate(pScrn, &radeon_output_funcs, buf);
}

/*
 * initialise the static data sos we don't have to re-do at randr change */
Bool RADEONSetupConnectors(ScrnInfoPtr pScrn)
{
    xf86CrtcConfigPtr   xf86_config = XF86_CRTC_CONFIG_PTR(pScrn);
    RADEONInfoPtr info       = RADEONPTR(pScrn);
    xf86OutputPtr output;
    char *optstr;
    int i;
    int num_vga = 0;
    int num_dvi = 0;
    int num_hdmi = 0;
    int num_dp = 0;
    int num_edp = 0;

    /* We first get the information about all connectors from BIOS.
     * This is how the card is phyiscally wired up.
     * The information should be correct even on a OEM card.
     */
    for (i = 0; i < RADEON_MAX_BIOS_CONNECTOR; i++) {
	info->encoders[i] = NULL;
	info->BiosConnector[i].valid = FALSE;
	info->BiosConnector[i].load_detection = TRUE;
	info->BiosConnector[i].shared_ddc = FALSE;
	info->BiosConnector[i].ddc_i2c.valid = FALSE;
	info->BiosConnector[i].ConnectorType = CONNECTOR_NONE;
	info->BiosConnector[i].devices = 0;
    }

#if defined(__powerpc__)
    info->MacModel = 0;
    optstr = (char *)xf86GetOptValString(info->Options, OPTION_MAC_MODEL);
    if (optstr) {
	if (!strncmp("ibook", optstr, strlen("ibook")))
	    info->MacModel = RADEON_MAC_IBOOK;
	else if (!strncmp("powerbook-duallink", optstr, strlen("powerbook-duallink"))) /* alias */
	    info->MacModel = RADEON_MAC_POWERBOOK_EXTERNAL;
	else if (!strncmp("powerbook-external", optstr, strlen("powerbook-external")))
	    info->MacModel = RADEON_MAC_POWERBOOK_EXTERNAL;
	else if (!strncmp("powerbook-internal", optstr, strlen("powerbook-internal")))
	    info->MacModel = RADEON_MAC_POWERBOOK_INTERNAL;
	else if (!strncmp("powerbook-vga", optstr, strlen("powerbook-vga")))
	    info->MacModel = RADEON_MAC_POWERBOOK_VGA;
	else if (!strncmp("powerbook", optstr, strlen("powerbook"))) /* alias */
	    info->MacModel = RADEON_MAC_POWERBOOK_INTERNAL;
	else if (!strncmp("mini-internal", optstr, strlen("mini-internal")))
	    info->MacModel = RADEON_MAC_MINI_INTERNAL;
	else if (!strncmp("mini-external", optstr, strlen("mini-external")))
	    info->MacModel = RADEON_MAC_MINI_EXTERNAL;
	else if (!strncmp("mini", optstr, strlen("mini"))) /* alias */
	    info->MacModel = RADEON_MAC_MINI_EXTERNAL;
	else if (!strncmp("imac-g5-isight", optstr, strlen("imac-g5-isight")))
	    info->MacModel = RADEON_MAC_IMAC_G5_ISIGHT;
	else if (!strncmp("emac", optstr, strlen("emac")))
	    info->MacModel = RADEON_MAC_EMAC;
	else if (!strncmp("sam440ep", optstr, strlen("sam440ep")))
	    info->MacModel = RADEON_MAC_SAM440EP;
	else {
	    xf86DrvMsg(pScrn->scrnIndex, X_ERROR, "Invalid Mac Model: %s\n", optstr);
	}
    }

    if (!info->MacModel) {
	info->MacModel = RADEONDetectMacModel(pScrn);
    }

    if (info->MacModel){
	if (!RADEONSetupAppleConnectors(pScrn))
	    RADEONSetupGenericConnectors(pScrn);
    } else
#endif
    if (xf86ReturnOptValBool(info->Options, OPTION_DEFAULT_CONNECTOR_TABLE, FALSE)) {
	RADEONSetupGenericConnectors(pScrn);
    } else {
	if (!RADEONGetConnectorInfoFromBIOS(pScrn))
	    RADEONSetupGenericConnectors(pScrn);
    }

    /* parse connector table option */
    optstr = (char *)xf86GetOptValString(info->Options, OPTION_CONNECTORTABLE);

    if (optstr) {
	unsigned int ddc_line[2];
	int DACType[2], TMDSType[2];

	for (i = 2; i < RADEON_MAX_BIOS_CONNECTOR; i++) {
	    info->BiosConnector[i].valid = FALSE;
	}

	if (sscanf(optstr, "%u,%u,%u,%u,%u,%u,%u,%u",
		   &ddc_line[0],
		   &DACType[0],
		   &TMDSType[0],
		   &info->BiosConnector[0].ConnectorType,
		   &ddc_line[1],
		   &DACType[1],
		   &TMDSType[1],
		   &info->BiosConnector[1].ConnectorType) != 8) {
	    xf86DrvMsg(pScrn->scrnIndex, X_ERROR, "Invalid ConnectorTable option: %s\n", optstr);
	    return FALSE;
	}

	for (i = 0; i < 2; i++) {
	    info->BiosConnector[i].valid = TRUE;
	    info->BiosConnector[i].ddc_i2c = legacy_setup_i2c_bus(ddc_line[i]);
	    switch (DACType[i]) {
	    case 1:
		info->BiosConnector[i].devices |= ATOM_DEVICE_CRT1_SUPPORT;
		if (!radeon_add_encoder(pScrn,
					radeon_get_encoder_id_from_supported_device(pScrn,
										    ATOM_DEVICE_CRT1_SUPPORT,
										    1),
					ATOM_DEVICE_CRT1_SUPPORT))
		    return FALSE;
		info->BiosConnector[i].load_detection = TRUE;
		break;
	    case 2:
		info->BiosConnector[i].devices |= ATOM_DEVICE_CRT2_SUPPORT;
		if (!radeon_add_encoder(pScrn,
					radeon_get_encoder_id_from_supported_device(pScrn,
										    ATOM_DEVICE_CRT2_SUPPORT,
										    2),
					ATOM_DEVICE_CRT2_SUPPORT))
		    return FALSE;
		info->BiosConnector[i].load_detection = FALSE;
		break;
	    }
	    switch (TMDSType[i]) {
	    case 1:
		info->BiosConnector[i].devices |= ATOM_DEVICE_DFP1_SUPPORT;
		if (!radeon_add_encoder(pScrn,
					radeon_get_encoder_id_from_supported_device(pScrn,
										    ATOM_DEVICE_DFP1_SUPPORT,
										    0),
					ATOM_DEVICE_DFP1_SUPPORT))
		    return FALSE;
		break;
	    case 2:
		info->BiosConnector[i].devices |= ATOM_DEVICE_DFP2_SUPPORT;
		if (!radeon_add_encoder(pScrn,
					radeon_get_encoder_id_from_supported_device(pScrn,
										    ATOM_DEVICE_DFP2_SUPPORT,
										    0),
					ATOM_DEVICE_DFP2_SUPPORT))
		    return FALSE;
		break;
	    }
	}
    }

    for (i = 0; i < RADEON_MAX_BIOS_CONNECTOR; i++) {
	if (info->BiosConnector[i].valid) {
	    RADEONConnectorType conntype = info->BiosConnector[i].ConnectorType;
	    if ((conntype == CONNECTOR_DVI_D) ||
		(conntype == CONNECTOR_DVI_I) ||
		(conntype == CONNECTOR_DVI_A) ||
		(conntype == CONNECTOR_HDMI_TYPE_B)) {
		num_dvi++;
	    } else if (conntype == CONNECTOR_VGA) {
		num_vga++;
	    } else if (conntype == CONNECTOR_HDMI_TYPE_A) {
		num_hdmi++;
	    } else if (conntype == CONNECTOR_DISPLAY_PORT) {
		num_dp++;
	    } else if (conntype == CONNECTOR_EDP) {
		num_edp++;
	    }
	}
    }

    for (i = 0 ; i < RADEON_MAX_BIOS_CONNECTOR; i++) {
	if (info->BiosConnector[i].valid) {
	    RADEONOutputPrivatePtr radeon_output;
	    RADEONConnectorType conntype = info->BiosConnector[i].ConnectorType;

	    if (conntype == CONNECTOR_NONE)
		continue;

	    radeon_output = xnfcalloc(sizeof(RADEONOutputPrivateRec), 1);
	    if (!radeon_output) {
		return FALSE;
	    }
	    radeon_output->MonType = MT_UNKNOWN;
	    radeon_output->ConnectorType = conntype;
	    radeon_output->devices = info->BiosConnector[i].devices;
	    radeon_output->ddc_i2c = info->BiosConnector[i].ddc_i2c;
	    radeon_output->igp_lane_info = info->BiosConnector[i].igp_lane_info;
	    radeon_output->shared_ddc = info->BiosConnector[i].shared_ddc;
	    radeon_output->load_detection = info->BiosConnector[i].load_detection;
	    radeon_output->linkb = info->BiosConnector[i].linkb;
	    radeon_output->dig_encoder = -1;
	    radeon_output->connector_id = info->BiosConnector[i].connector_object;
	    radeon_output->connector_object_id = info->BiosConnector[i].connector_object_id;
	    radeon_output->ucI2cId = info->BiosConnector[i].ucI2cId;
	    radeon_output->hpd_id = info->BiosConnector[i].hpd_id;

	    /* Technically HDMI-B is a glorfied DL DVI so the bios is correct,
	     * but this can be confusing to users when it comes to output names,
	     * so call it DVI
	     */
	    if ((conntype == CONNECTOR_DVI_D) ||
		(conntype == CONNECTOR_DVI_I) ||
		(conntype == CONNECTOR_DVI_A) ||
		(conntype == CONNECTOR_HDMI_TYPE_B)) {
		output = RADEONOutputCreate(pScrn, "DVI-%d", --num_dvi);
	    } else if (conntype == CONNECTOR_VGA) {
		output = RADEONOutputCreate(pScrn, "VGA-%d", --num_vga);
	    } else if (conntype == CONNECTOR_HDMI_TYPE_A) {
		output = RADEONOutputCreate(pScrn, "HDMI-%d", --num_hdmi);
	    } else if (conntype == CONNECTOR_DISPLAY_PORT) {
		output = RADEONOutputCreate(pScrn, "DisplayPort-%d", --num_dp);
	    } else if (conntype == CONNECTOR_EDP) {
		output = RADEONOutputCreate(pScrn, "eDP-%d", --num_edp);
	    } else {
		output = RADEONOutputCreate(pScrn,
					    ConnectorTypeName[conntype], 0);
	    }

	    if (!output) {
		return FALSE;
	    }
	    output->interlaceAllowed = TRUE;
	    output->doubleScanAllowed = TRUE;
	    output->driver_private = radeon_output;
	    if (IS_DCE4_VARIANT) {
		output->possible_crtcs = 0x3f;
	    } else {
		output->possible_crtcs = 1;
		/* crtc2 can drive LVDS, it just doesn't have RMX */
		if (!(radeon_output->devices & (ATOM_DEVICE_LCD_SUPPORT)))
		    output->possible_crtcs |= 2;
	    }

	    /* we can clone the DACs, and probably TV-out,
	       but I'm not sure it's worth the trouble */
	    output->possible_clones = 0;

	    RADEONInitConnector(output);
	}
    }

    for (i = 0; i < xf86_config->num_output; i++) {
	xf86OutputPtr output = xf86_config->output[i];

	output->possible_clones = radeon_output_clones(pScrn, output);
	RADEONGetHardCodedEDIDFromFile(output);
    }

    return TRUE;
}

@


1.10
log
@Update to xf86-video-ati 6.14.6. Tested by mpi@@, brad, eric@@, ajacoutot@@.
@
text
@@


1.9
log
@Brown paperbag commit.

Prodded by espie@@ I reviewed the history of
OpenBSD local changes carefully and found a number of merge errors
accumulated over the complicated CVS history of this driver.

This the 6.14.4 code + OpenBSD local fixes as it should be.
@
text
@d2463 56
d2998 2
@


1.8
log
@Update to xf86-video-ati 6.14.4. Tested by jasper@@, krw@@, mpi@@, shadchin@@
@
text
@d2764 1
a2764 1
	if (strcmp(model, "PowerBook5,7") ||
@


1.7
log
@Re-update xf86-video-ati to 6.14.3.

Because of ati.c revision 1.5, it will not be selected by
autoconfiguration code, so people who want to run this version of the
driver on their radeon cards need an explicit "Device" section in
xorg.conf.
@
text
@d3005 1
a3005 1
										    ATOM_DEVICE_CRT1_SUPPORT,
d3007 1
a3007 1
					ATOM_DEVICE_CRT1_SUPPORT))
@


1.6
log
@Revert the update to xf86-video-ati 6.14.3. Requested by espie@@
who experiemnts regressions with this driver.
@
text
@d35 1
d89 1
a89 1
const char *ConnectorTypeName[17] = {
d106 1
d123 2
d160 1
a160 1
	    ErrorF("  CV: %s\n", encoder_name[info->encoders[ATOM_DEVICE_CRT1_INDEX]->encoder_id]);
d186 4
d220 83
d311 1
d313 13
a325 12
    if (radeon_output->pI2CBus) {
	/* RV410 RADEON_GPIO_VGA_DDC seems to only work via hw i2c
	 * We may want to extend this to other cases if the need arises...
	 */
	if ((info->ChipFamily == CHIP_FAMILY_RV410) &&
	    (radeon_output->ddc_i2c.mask_clk_reg == RADEON_GPIO_VGA_DDC) &&
	    info->IsAtomBios)
	    MonInfo = radeon_atom_get_edid(output);
	else if (info->get_hardcoded_edid_from_bios) {
	    MonInfo = RADEONGetHardCodedEDIDFromBIOS(output);
	    if (MonInfo == NULL) {
		RADEONI2CDoLock(output, TRUE);
d327 1
a327 1
		RADEONI2CDoLock(output, FALSE);
d329 6
a334 2
	} else {
	    RADEONI2CDoLock(output, TRUE);
d336 1
a336 1
	    RADEONI2CDoLock(output, FALSE);
a345 1
	case CONNECTOR_HDMI_TYPE_B:
d347 4
a350 1
		if (MonInfo->rawData[0x14] & 0x80) /* if it's digital and DVI/HDMI/etc. */
d354 27
d385 1
d390 10
a399 1
	    MonType = MT_DFP;
d401 1
a401 1
	    if (MonInfo->rawData[0x14] & 0x80) /* if it's digital and DVI */
d410 1
a410 1
		if (MonInfo->rawData[0x14] & 0x80) /* if it's digital and VGA */
d419 1
a419 1
	if (MonType != MT_NONE)
d422 2
a426 3
    xf86DrvMsg(pScrn->scrnIndex, X_INFO,
	       "Output: %s, Detected Monitor Type: %d\n", output->name, MonType);

d485 16
d558 6
d570 3
d605 2
d609 1
a619 2
	xf86CrtcPtr crtc = output->crtc;
	RADEONCrtcPrivatePtr radeon_crtc = crtc->driver_private;
d625 1
d627 2
d674 7
d688 19
d713 22
d736 2
d739 5
d763 22
d786 1
d936 4
d1209 2
d1274 1
d1305 1
a1305 1
        xfree(output->driver_private);
d1426 1
a1426 1
    if ((!IS_AVIVO_VARIANT) && (radeon_output->devices & (ATOM_DEVICE_DFP2_SUPPORT))) {
d1625 14
d1641 1
d1643 1
a1643 1
			   "Failed to set mode after propery change!\n");
d1875 1
a1875 1
RADEONI2CDoLock(xf86OutputPtr output, int lock_state)
d1879 1
a1879 2
    RADEONOutputPrivatePtr radeon_output = output->driver_private;
    RADEONI2CBusPtr pRADEONI2CBus = radeon_output->pI2CBus->DriverPrivate.ptr;
d1884 20
a2132 4
    /* dce 3.2 chips have problems with low dot clocks, so use the scaler */
    if (IS_DCE32_VARIANT && (radeon_output->devices & (ATOM_DEVICE_DFP_SUPPORT)))
	radeon_output->rmx_type = RMX_FULL;

d2146 14
d2764 1
a2764 1
	if (strcmp(model, "PowerBook5,7") == 0 ||
d2842 4
d2847 1
a2847 1
    if (IS_DCE32_VARIANT)
d2854 1
d2858 4
d2900 1
d3040 2
a3041 1
		(conntype == CONNECTOR_DVI_A)) {
d3045 1
a3045 2
	    } else if ((conntype == CONNECTOR_HDMI_TYPE_A) ||
		       (conntype == CONNECTOR_HDMI_TYPE_B)) {
d3049 2
d3075 1
d3077 8
a3084 1

d3087 2
a3088 1
		(conntype == CONNECTOR_DVI_A)) {
d3092 1
a3092 2
	    } else if ((conntype == CONNECTOR_HDMI_TYPE_A) ||
		       (conntype == CONNECTOR_HDMI_TYPE_B)) {
d3096 2
d3106 2
d3109 8
a3116 4
	    output->possible_crtcs = 1;
	    /* crtc2 can drive LVDS, it just doesn't have RMX */
	    if (!(radeon_output->devices & (ATOM_DEVICE_LCD_SUPPORT)))
		output->possible_crtcs |= 2;
d3130 1
@


1.5
log
@Update to xf86-video-ati 6.14.3. Tested by many.
@
text
@a34 1
#include <fcntl.h>
d88 1
a88 1
const char *ConnectorTypeName[18] = {
a104 1
  "eDP",
a120 2
extern void
atombios_pick_dig_encoder(xf86OutputPtr output);
d156 1
a156 1
	    ErrorF("  CV: %s\n", encoder_name[info->encoders[ATOM_DEVICE_CV_INDEX]->encoder_id]);
a181 4
	else if (radeon_output->devices & ATOM_DEVICE_LCD1_SUPPORT)
	    radeon_output->active_device = ATOM_DEVICE_LCD1_SUPPORT;
	else if (radeon_output->devices & ATOM_DEVICE_LCD2_SUPPORT)
	    radeon_output->active_device = ATOM_DEVICE_LCD2_SUPPORT;
a211 83
static Bool
monitor_is_digital(xf86MonPtr MonInfo)
{
    return (MonInfo->rawData[0x14] & 0x80) != 0;
}

static void
RADEONGetHardCodedEDIDFromFile(xf86OutputPtr output)
{
    ScrnInfoPtr pScrn = output->scrn;
    RADEONInfoPtr info = RADEONPTR(pScrn);
    RADEONOutputPrivatePtr radeon_output = output->driver_private;
    char *EDIDlist = (char *)xf86GetOptValString(info->Options, OPTION_CUSTOM_EDID);

    radeon_output->custom_edid = FALSE;
    radeon_output->custom_mon = NULL;

    if (EDIDlist != NULL) {
	unsigned char* edid = xnfcalloc(128, 1);
	char *name = output->name;
	char *outputEDID = strstr(EDIDlist, name);

	if (outputEDID != NULL) {
	    char *end;
	    char *colon;
	    char *command = NULL;
	    int fd;

	    outputEDID += strlen(name) + 1;
	    end = strstr(outputEDID, ";");
	    if (end != NULL)
		*end = 0;

	    colon = strstr(outputEDID, ":");
	    if (colon != NULL) {
		*colon = 0;
		command = colon + 1;
	    }

	    fd = open (outputEDID, O_RDONLY);
	    if (fd >= 0) {
		read(fd, edid, 128);
		close(fd);
		if (edid[1] == 0xff) {
		    radeon_output->custom_mon = xf86InterpretEDID(output->scrn->scrnIndex, edid);
		    radeon_output->custom_edid = TRUE;
		    xf86DrvMsg(pScrn->scrnIndex, X_INFO,
			       "Successfully read Custom EDID data for output %s from %s.\n",
			       name, outputEDID);
		    if (command != NULL) {
			if (!strcmp(command, "digital")) {
			    radeon_output->custom_mon->rawData[0x14] |= 0x80;
			    xf86DrvMsg(pScrn->scrnIndex, X_INFO,
				       "Forcing digital output for output %s.\n", name);
			} else if (!strcmp(command, "analog")) {
			    radeon_output->custom_mon->rawData[0x14] &= ~0x80;
			    xf86DrvMsg(pScrn->scrnIndex, X_INFO,
				       "Forcing analog output for output %s.\n", name);
			} else {
			    xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
				       "Unknown custom EDID command: '%s'.\n",
				       command);
			}
		    }
		} else {
		    xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
			       "Custom EDID data for %s read from %s was invalid.\n",
			       name, outputEDID);
		}
	    } else {
		xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
			   "Could not read custom EDID for output %s from file %s.\n",
			   name, outputEDID);
	    }
	} else {
	    xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
		       "Could not find EDID file name for output %s; using auto detection.\n",
		       name);
	}
    }
}


a219 1
    int ret;
d221 12
a232 13
    if (radeon_output->custom_edid) {
	MonInfo = xnfcalloc(sizeof(xf86Monitor), 1);
	*MonInfo = *radeon_output->custom_mon;
    } else if ((radeon_output->ConnectorType == CONNECTOR_DISPLAY_PORT) ||
	       (radeon_output->ConnectorType == CONNECTOR_EDP)) {
	ret = RADEON_DP_GetSinkType(output);
	if (ret == CONNECTOR_OBJECT_ID_DISPLAYPORT ||
	    ret == CONNECTOR_OBJECT_ID_eDP) {
		MonInfo = xf86OutputGetEDID(output, radeon_output->dp_pI2CBus);
	}
	if (MonInfo == NULL) {
	    if (radeon_output->pI2CBus) {
		RADEONI2CDoLock(output, radeon_output->pI2CBus, TRUE);
d234 1
a234 1
		RADEONI2CDoLock(output, radeon_output->pI2CBus, FALSE);
d236 2
a237 6
	}
    } else if (radeon_output->pI2CBus) {
	if (info->get_hardcoded_edid_from_bios)
	    MonInfo = RADEONGetHardCodedEDIDFromBIOS(output);
	if (MonInfo == NULL) {
	    RADEONI2CDoLock(output, radeon_output->pI2CBus, TRUE);
d239 1
a239 1
	    RADEONI2CDoLock(output, radeon_output->pI2CBus, FALSE);
d249 1
d251 1
a251 4
		xf86CrtcConfigPtr config = XF86_CRTC_CONFIG_PTR (output->scrn);
		int i;

		if (monitor_is_digital(MonInfo))
a254 27

		for (i = 0; i < config->num_output; i++) {
		    if (output != config->output[i]) {
			RADEONOutputPrivatePtr other_radeon_output =
			    config->output[i]->driver_private;
			if (radeon_output->devices & other_radeon_output->devices) {
#ifndef EDID_COMPLETE_RAWDATA
			    if (radeon_output->ConnectorType == CONNECTOR_HDMI_TYPE_A) {
				MonType = MT_NONE;
				break;
			    }
#else
			    if (xf86MonitorIsHDMI(MonInfo)) {
				if (radeon_output->ConnectorType == CONNECTOR_DVI_D) {
				    MonType = MT_NONE;
				    break;
				}
			    } else {
				if (radeon_output->ConnectorType == CONNECTOR_HDMI_TYPE_A) {
				    MonType = MT_NONE;
				    break;
				}
			    }
#endif
			}
		    }
		}
a258 1
	case CONNECTOR_EDP:
d263 1
a263 10
	    ret = RADEON_DP_GetSinkType(output);

	    if ((ret == CONNECTOR_OBJECT_ID_DISPLAYPORT) ||
		(ret == CONNECTOR_OBJECT_ID_eDP)) {
		MonType = MT_DP;
		RADEON_DP_GetDPCD(output);
	    } else
		MonType = MT_DFP;
	    break;
	case CONNECTOR_HDMI_TYPE_B:
d265 1
a265 1
	    if (monitor_is_digital(MonInfo))
d274 1
a274 1
		if (monitor_is_digital(MonInfo))
d283 1
a283 1
	if (MonType != MT_NONE) {
a285 2
	} else
	    free(MonInfo);
d289 3
a349 16
    if ((mode != DPMSModeOn) && radeon_output->shared_ddc) {
	xf86CrtcConfigPtr config = XF86_CRTC_CONFIG_PTR (output->scrn);
	int i;

	for (i = 0; i < config->num_output; i++) {
	    if (output != config->output[i]) {
		RADEONOutputPrivatePtr other_radeon_output =
		    config->output[i]->driver_private;
		if (radeon_output->devices & other_radeon_output->devices) {
		    if (output->status == XF86OutputStatusDisconnected)
			return;
		}
	    }
	}
    }

a406 6
    /* clocks over 135 MHz have heat issues with DVI on RV100 */
    if ((radeon_output->MonType == MT_DFP) &&
	(info->ChipFamily == CHIP_FAMILY_RV100) &&
	(pMode->Clock > 135000))
	    return MODE_CLOCK_HIGH;

a412 3
	if (radeon_output->ConnectorType == CONNECTOR_EDP)
	    return MODE_CLOCK_HIGH;

a444 2
    xf86CrtcPtr crtc = output->crtc;
    RADEONCrtcPrivatePtr radeon_crtc = crtc->driver_private;
a446 1
    radeon_crtc->scaler_enabled = FALSE;
d457 2
a463 1
		radeon_crtc->scaler_enabled = TRUE;
a464 2
		    radeon_crtc->hsc = (float)mode->HDisplay / (float)native_mode->PanelXRes;
		    radeon_crtc->vsc = (float)mode->VDisplay / (float)native_mode->PanelYRes;
a509 7
    /* FIXME: vsc/hsc */
    if (radeon_output->active_device & (ATOM_DEVICE_TV_SUPPORT | ATOM_DEVICE_CV_SUPPORT)) {
	radeon_crtc->scaler_enabled = TRUE;
	radeon_crtc->hsc = (float)mode->HDisplay / (float)640;
	radeon_crtc->vsc = (float)mode->VDisplay / (float)480;
    }

a516 19
    if (IS_AVIVO_VARIANT || info->r4xx_atom) {
	if (radeon_output->MonType == MT_STV || radeon_output->MonType == MT_CTV) {
	    radeon_tvout_ptr tvout = &radeon_output->tvout;
	    ScrnInfoPtr pScrn = output->scrn;

	    if (tvout->tvStd == TV_STD_NTSC ||
		tvout->tvStd == TV_STD_NTSC_J ||
		tvout->tvStd == TV_STD_PAL_M)
		RADEONATOMGetTVTimings(pScrn, 0, adjusted_mode);
	    else
		RADEONATOMGetTVTimings(pScrn, 1, adjusted_mode);
	}
    }

    if (((radeon_output->ConnectorType == CONNECTOR_DISPLAY_PORT) ||
	 (radeon_output->ConnectorType == CONNECTOR_EDP)) &&
	(radeon_output->MonType == MT_DP)) {
      radeon_dp_mode_fixup(output, mode, adjusted_mode);
    }
a522 22
    RADEONInfoPtr info = RADEONPTR(output->scrn);
    xf86CrtcConfigPtr	config = XF86_CRTC_CONFIG_PTR (output->scrn);
    int o;

    for (o = 0; o < config->num_output; o++) {
	xf86OutputPtr loop_output = config->output[o];
	if (loop_output == output)
	    continue;
	else if (loop_output->crtc) {
	    xf86CrtcPtr other_crtc = loop_output->crtc;
	    RADEONCrtcPrivatePtr other_radeon_crtc = other_crtc->driver_private;
	    if (other_crtc->enabled) {
		if (other_radeon_crtc->initialized) {
		    radeon_crtc_dpms(other_crtc, DPMSModeOff);
		    if (IS_AVIVO_VARIANT || info->r4xx_atom)
			atombios_lock_crtc(info->atomBIOS, other_radeon_crtc->crtc_id, 1);
		    radeon_dpms(loop_output, DPMSModeOff);
		}
	    }
	}
    }

a523 2
    if (IS_AVIVO_VARIANT)
	atombios_pick_dig_encoder(output);
a524 5
    radeon_crtc_dpms(output->crtc, DPMSModeOff);

    if (IS_AVIVO_VARIANT || info->r4xx_atom)
        atombios_set_output_crtc_source(output);

a543 22
    RADEONInfoPtr info = RADEONPTR(output->scrn);
    xf86CrtcConfigPtr	config = XF86_CRTC_CONFIG_PTR (output->scrn);
    int o;

    for (o = 0; o < config->num_output; o++) {
	xf86OutputPtr loop_output = config->output[o];
	if (loop_output == output)
	    continue;
	else if (loop_output->crtc) {
	    xf86CrtcPtr other_crtc = loop_output->crtc;
	    RADEONCrtcPrivatePtr other_radeon_crtc = other_crtc->driver_private;
	    if (other_crtc->enabled) {
		if (other_radeon_crtc->initialized) {
		    radeon_crtc_dpms(other_crtc, DPMSModeOn);
		    if (IS_AVIVO_VARIANT || info->r4xx_atom)
			atombios_lock_crtc(info->atomBIOS, other_radeon_crtc->crtc_id, 0);
		    radeon_dpms(loop_output, DPMSModeOn);
		}
	    }
	}
    }

a544 1
    radeon_crtc_dpms(output->crtc, DPMSModeOn);
a693 4
    /* no need to update crtc routing scratch regs on DCE4 */
    if (IS_DCE4_VARIANT)
	return;

a962 2
    xf86DrvMsg(pScrn->scrnIndex, X_INFO,
	       "Output: %s, Detected Monitor Type: %d\n", output->name, radeon_output->MonType);
a1025 1
	case CONNECTOR_EDP:
d1056 1
a1056 1
        free(output->driver_private);
d1177 1
a1177 1
    if ((!IS_AVIVO_VARIANT) && (radeon_output->devices & (ATOM_DEVICE_DFP1_SUPPORT))) {
a1375 14
#ifdef RANDR_14_INTERFACE
	    xf86CrtcSetRec crtc_set_rec;

	    crtc_set_rec.flags = (XF86CrtcSetMode |
				  XF86CrtcSetOutput |
				  XF86CrtcSetOrigin |
				  XF86CrtcSetRotation);
	    crtc_set_rec.mode = &crtc->desiredMode;
	    crtc_set_rec.rotation = crtc->desiredRotation;
	    crtc_set_rec.transform = NULL;
	    crtc_set_rec.x = crtc->desiredX;
	    crtc_set_rec.y = crtc->desiredY;
	    if (!xf86CrtcSet(crtc, &crtc_set_rec)) {
#else
a1377 1
#endif
d1379 1
a1379 1
			   "Failed to set mode after property change!\n");
d1611 1
a1611 1
RADEONI2CDoLock(xf86OutputPtr output, I2CBusPtr b, int lock_state)
d1615 2
a1616 1
    RADEONI2CBusPtr pRADEONI2CBus = b->DriverPrivate.ptr;
a1620 20
	/* RV410 appears to have a bug where the hw i2c in reset
	 * holds the i2c port in a bad state - switch hw i2c away before
	 * doing DDC - do this for all r200s/r300s for safety sakes */
	if ((info->ChipFamily >= CHIP_FAMILY_R200) && (!IS_AVIVO_VARIANT)) {
	    if (pRADEONI2CBus->mask_clk_reg == RADEON_GPIO_MONID)
                OUTREG(RADEON_DVI_I2C_CNTL_0, (RADEON_I2C_SOFT_RST |
					       R200_DVI_I2C_PIN_SEL(R200_SEL_DDC1)));
	    else
                OUTREG(RADEON_DVI_I2C_CNTL_0, (RADEON_I2C_SOFT_RST |
					       R200_DVI_I2C_PIN_SEL(R200_SEL_DDC3)));
	}

	/* set the pad in ddc mode */
	if (IS_DCE3_VARIANT &&
	    pRADEONI2CBus->hw_capable) {
	    temp = INREG(pRADEONI2CBus->mask_clk_reg);
	    temp &= ~(1 << 16);
	    OUTREG(pRADEONI2CBus->mask_clk_reg, temp);
	}

d1850 4
a1866 14
    if (radeon_output->ConnectorType == CONNECTOR_DISPLAY_PORT) {
	strcpy(radeon_output->dp_bus_name, output->name);
	strcat(radeon_output->dp_bus_name, "-DP");
	RADEON_DP_I2CInit(pScrn, &radeon_output->dp_pI2CBus, radeon_output->dp_bus_name, output);
	RADEON_DP_GetSinkType(output);
    }

    if (radeon_output->ConnectorType == CONNECTOR_EDP) {
	strcpy(radeon_output->dp_bus_name, output->name);
	strcat(radeon_output->dp_bus_name, "-eDP");
	RADEON_DP_I2CInit(pScrn, &radeon_output->dp_pI2CBus, radeon_output->dp_bus_name, output);
	RADEON_DP_GetSinkType(output);
    }

d2471 1
a2471 1
	if (strcmp(model, "PowerBook5,7") ||
a2548 4
    /* no cloning with zaphod */
    if (info->IsPrimary || info->IsSecondary)
	return index_mask;

d2550 1
a2550 1
    if (info->ChipFamily >= CHIP_FAMILY_R600)
a2556 1
    /* TV requires very specific timing */
a2559 4
    /* DVO requires 2x ppll clocks depending on the tmds chip */
    if (radeon_output->devices & (ATOM_DEVICE_DFP2_SUPPORT))
	return index_mask;

a2597 1
    int num_edp = 0;
d2737 1
a2737 2
		(conntype == CONNECTOR_DVI_A) ||
		(conntype == CONNECTOR_HDMI_TYPE_B)) {
d2741 2
a2742 1
	    } else if (conntype == CONNECTOR_HDMI_TYPE_A) {
a2745 2
	    } else if (conntype == CONNECTOR_EDP) {
		num_edp++;
a2769 1
	    radeon_output->dig_encoder = -1;
d2771 1
a2771 8
	    radeon_output->connector_object_id = info->BiosConnector[i].connector_object_id;
	    radeon_output->ucI2cId = info->BiosConnector[i].ucI2cId;
	    radeon_output->hpd_id = info->BiosConnector[i].hpd_id;

	    /* Technically HDMI-B is a glorfied DL DVI so the bios is correct,
	     * but this can be confusing to users when it comes to output names,
	     * so call it DVI
	     */
d2774 1
a2774 2
		(conntype == CONNECTOR_DVI_A) ||
		(conntype == CONNECTOR_HDMI_TYPE_B)) {
d2778 2
a2779 1
	    } else if (conntype == CONNECTOR_HDMI_TYPE_A) {
a2782 2
	    } else if (conntype == CONNECTOR_EDP) {
		output = RADEONOutputCreate(pScrn, "eDP-%d", --num_edp);
a2790 2
	    output->interlaceAllowed = TRUE;
	    output->doubleScanAllowed = TRUE;
d2792 4
a2795 8
	    if (IS_DCE4_VARIANT) {
		output->possible_crtcs = 0x3f;
	    } else {
		output->possible_crtcs = 1;
		/* crtc2 can drive LVDS, it just doesn't have RMX */
		if (!(radeon_output->devices & (ATOM_DEVICE_LCD_SUPPORT)))
		    output->possible_crtcs |= 2;
	    }
a2808 1
	RADEONGetHardCodedEDIDFromFile(output);
@


1.4
log
@Fixed incorrect condition (s/strcmp()/strcmp() == 0/)

ok matthieu@@
@
text
@d35 1
d89 1
a89 1
const char *ConnectorTypeName[17] = {
d106 1
d123 2
d160 1
a160 1
	    ErrorF("  CV: %s\n", encoder_name[info->encoders[ATOM_DEVICE_CRT1_INDEX]->encoder_id]);
d186 4
d220 83
d311 1
d313 13
a325 12
    if (radeon_output->pI2CBus) {
	/* RV410 RADEON_GPIO_VGA_DDC seems to only work via hw i2c
	 * We may want to extend this to other cases if the need arises...
	 */
	if ((info->ChipFamily == CHIP_FAMILY_RV410) &&
	    (radeon_output->ddc_i2c.mask_clk_reg == RADEON_GPIO_VGA_DDC) &&
	    info->IsAtomBios)
	    MonInfo = radeon_atom_get_edid(output);
	else if (info->get_hardcoded_edid_from_bios) {
	    MonInfo = RADEONGetHardCodedEDIDFromBIOS(output);
	    if (MonInfo == NULL) {
		RADEONI2CDoLock(output, TRUE);
d327 1
a327 1
		RADEONI2CDoLock(output, FALSE);
d329 6
a334 2
	} else {
	    RADEONI2CDoLock(output, TRUE);
d336 1
a336 1
	    RADEONI2CDoLock(output, FALSE);
a345 1
	case CONNECTOR_HDMI_TYPE_B:
d347 4
a350 1
		if (MonInfo->rawData[0x14] & 0x80) /* if it's digital and DVI/HDMI/etc. */
d354 27
d385 1
d390 10
a399 1
	    MonType = MT_DFP;
d401 1
a401 1
	    if (MonInfo->rawData[0x14] & 0x80) /* if it's digital and DVI */
d410 1
a410 1
		if (MonInfo->rawData[0x14] & 0x80) /* if it's digital and VGA */
d419 1
a419 1
	if (MonType != MT_NONE)
d422 2
a426 3
    xf86DrvMsg(pScrn->scrnIndex, X_INFO,
	       "Output: %s, Detected Monitor Type: %d\n", output->name, MonType);

d485 16
d558 6
d570 3
d605 2
d609 1
a619 2
	xf86CrtcPtr crtc = output->crtc;
	RADEONCrtcPrivatePtr radeon_crtc = crtc->driver_private;
d625 1
d627 2
d674 7
d688 19
d713 22
d736 2
d739 5
d763 22
d786 1
d936 4
d1209 2
d1274 1
d1305 1
a1305 1
        xfree(output->driver_private);
d1426 1
a1426 1
    if ((!IS_AVIVO_VARIANT) && (radeon_output->devices & (ATOM_DEVICE_DFP2_SUPPORT))) {
d1625 14
d1641 1
d1643 1
a1643 1
			   "Failed to set mode after propery change!\n");
d1875 1
a1875 1
RADEONI2CDoLock(xf86OutputPtr output, int lock_state)
d1879 1
a1879 2
    RADEONOutputPrivatePtr radeon_output = output->driver_private;
    RADEONI2CBusPtr pRADEONI2CBus = radeon_output->pI2CBus->DriverPrivate.ptr;
d1884 20
a2132 4
    /* dce 3.2 chips have problems with low dot clocks, so use the scaler */
    if (IS_DCE32_VARIANT && (radeon_output->devices & (ATOM_DEVICE_DFP_SUPPORT)))
	radeon_output->rmx_type = RMX_FULL;

d2146 14
d2764 1
a2764 1
	if (strcmp(model, "PowerBook5,7") == 0 ||
d2842 4
d2847 1
a2847 1
    if (IS_DCE32_VARIANT)
d2854 1
d2858 4
d2900 1
d3040 2
a3041 1
		(conntype == CONNECTOR_DVI_A)) {
d3045 1
a3045 2
	    } else if ((conntype == CONNECTOR_HDMI_TYPE_A) ||
		       (conntype == CONNECTOR_HDMI_TYPE_B)) {
d3049 2
d3075 1
d3077 8
a3084 1

d3087 2
a3088 1
		(conntype == CONNECTOR_DVI_A)) {
d3092 1
a3092 2
	    } else if ((conntype == CONNECTOR_HDMI_TYPE_A) ||
		       (conntype == CONNECTOR_HDMI_TYPE_B)) {
d3096 2
d3106 2
d3109 8
a3116 4
	    output->possible_crtcs = 1;
	    /* crtc2 can drive LVDS, it just doesn't have RMX */
	    if (!(radeon_output->devices & (ATOM_DEVICE_LCD_SUPPORT)))
		output->possible_crtcs |= 2;
d3130 1
@


1.3
log
@update do xf86-video-ati 6.12.2

This has been in snapshots for weeks. ok oga@@, todd@@.
@
text
@d2471 1
a2471 1
	if (strcmp(model, "PowerBook5,7") ||
@


1.2
log
@Set default for "MacModel" option based on hw.product.

ok matthieu@@, oga@@
@
text
@d51 35
a85 40
const char *MonTypeName[10] = {
  "AUTO",
  "NONE",
  "CRT",
  "LVDS",
  "TMDS",
  "CTV",
  "STV",
  "CV",
  "HDMI",
  "DP"
};

const RADEONMonitorType MonTypeID[10] = {
  MT_UNKNOWN, /* this is just a dummy value for AUTO DETECTION */
  MT_NONE,    /* NONE -> NONE */
  MT_CRT,     /* CRT -> CRT */
  MT_LCD,     /* Laptop LCDs are driven via LVDS port */
  MT_DFP,     /* DFPs are driven via TMDS */
  MT_CTV,     /* CTV -> CTV */
  MT_STV,     /* STV -> STV */
  MT_CV,
  MT_HDMI,
  MT_DP
};

const char *TMDSTypeName[6] = {
  "None",
  "Internal",
  "External",
  "LVTMA",
  "DDIA",
  "UNIPHY"
};

const char *DACTypeName[4] = {
  "None",
  "Primary",
  "TVDAC/ExtDAC",
  "ExtDac"
d94 2
a95 2
  "STV",
  "CTV",
a107 67
const char *OutputType[11] = {
    "None",
    "VGA",
    "DVI",
    "DVI",
    "DVI",
    "LVDS",
    "S-video",
    "Composite",
    "Component",
    "HDMI",
    "DisplayPort",
};

static const RADEONTMDSPll default_tmds_pll[CHIP_FAMILY_LAST][4] =
{
    {{0, 0}, {0, 0}, {0, 0}, {0, 0}},				/*CHIP_FAMILY_UNKNOW*/
    {{0, 0}, {0, 0}, {0, 0}, {0, 0}},				/*CHIP_FAMILY_LEGACY*/
    {{12000, 0xa1b}, {0xffffffff, 0xa3f}, {0, 0}, {0, 0}},	/*CHIP_FAMILY_RADEON*/
    {{12000, 0xa1b}, {0xffffffff, 0xa3f}, {0, 0}, {0, 0}},	/*CHIP_FAMILY_RV100*/
    {{0, 0}, {0, 0}, {0, 0}, {0, 0}},				/*CHIP_FAMILY_RS100*/
    {{15000, 0xa1b}, {0xffffffff, 0xa3f}, {0, 0}, {0, 0}},	/*CHIP_FAMILY_RV200*/
    {{12000, 0xa1b}, {0xffffffff, 0xa3f}, {0, 0}, {0, 0}},	/*CHIP_FAMILY_RS200*/
    {{15000, 0xa1b}, {0xffffffff, 0xa3f}, {0, 0}, {0, 0}},	/*CHIP_FAMILY_R200*/
    {{15500, 0x81b}, {0xffffffff, 0x83f}, {0, 0}, {0, 0}},	/*CHIP_FAMILY_RV250*/
    {{0, 0}, {0, 0}, {0, 0}, {0, 0}},				/*CHIP_FAMILY_RS300*/
    {{13000, 0x400f4}, {15000, 0x400f7}, {0xffffffff, 0x40111}, {0, 0}}, /*CHIP_FAMILY_RV280*/
    {{0xffffffff, 0xb01cb}, {0, 0}, {0, 0}, {0, 0}},		/*CHIP_FAMILY_R300*/
    {{0xffffffff, 0xb01cb}, {0, 0}, {0, 0}, {0, 0}},		/*CHIP_FAMILY_R350*/
    {{15000, 0xb0155}, {0xffffffff, 0xb01cb}, {0, 0}, {0, 0}},	/*CHIP_FAMILY_RV350*/
    {{15000, 0xb0155}, {0xffffffff, 0xb01cb}, {0, 0}, {0, 0}},	/*CHIP_FAMILY_RV380*/
    {{0xffffffff, 0xb01cb}, {0, 0}, {0, 0}, {0, 0}},		/*CHIP_FAMILY_R420*/
    {{0xffffffff, 0xb01cb}, {0, 0}, {0, 0}, {0, 0}},		/*CHIP_FAMILY_RV410*/ /* FIXME: just values from r420 used... */
    {{15000, 0xb0155}, {0xffffffff, 0xb01cb}, {0, 0}, {0, 0}},	/*CHIP_FAMILY_RS400*/ /* FIXME: just values from rv380 used... */
    {{15000, 0xb0155}, {0xffffffff, 0xb01cb}, {0, 0}, {0, 0}},	/*CHIP_FAMILY_RS480*/ /* FIXME: just values from rv380 used... */
};

static const uint32_t default_tvdac_adj [CHIP_FAMILY_LAST] =
{
    0x00000000,   /* unknown */
    0x00000000,   /* legacy */
    0x00000000,   /* r100 */
    0x00280000,   /* rv100 */
    0x00000000,   /* rs100 */
    0x00880000,   /* rv200 */
    0x00000000,   /* rs200 */
    0x00000000,   /* r200 */
    0x00770000,   /* rv250 */
    0x00290000,   /* rs300 */
    0x00560000,   /* rv280 */
    0x00780000,   /* r300 */
    0x00770000,   /* r350 */
    0x00780000,   /* rv350 */
    0x00780000,   /* rv380 */
    0x01080000,   /* r420 */
    0x01080000,   /* rv410 */ /* FIXME: just values from r420 used... */
    0x00780000,   /* rs400 */ /* FIXME: just values from rv380 used... */
    0x00780000,   /* rs480 */ /* FIXME: just values from rv380 used... */
};


static void RADEONUpdatePanelSize(xf86OutputPtr output);
static void RADEONGetTMDSInfoFromTable(xf86OutputPtr output);
#define AVIVO_I2C_DISABLE 0
#define AVIVO_I2C_ENABLE 1
static Bool AVIVOI2CDoLock(xf86OutputPtr output, int lock_state);

d112 3
a114 2
extern RADEONMonitorType atombios_dac_detect(ScrnInfoPtr pScrn, xf86OutputPtr output);
extern int atombios_external_tmds_setup(xf86OutputPtr output, DisplayModePtr mode);
d124 1
d134 24
a157 8
	xf86DrvMsg(pScrn->scrnIndex, X_INFO,
		   "Port%d:\n Monitor   -- %s\n Connector -- %s\n DAC Type  -- %s\n TMDS Type -- %s\n DDC Type  -- 0x%x\n", 
		   o,
		   MonTypeName[radeon_output->MonType+1],
		   ConnectorTypeName[radeon_output->ConnectorType],
		   DACTypeName[radeon_output->DACType],
		   TMDSTypeName[radeon_output->TMDSType],
		   (unsigned int)radeon_output->ddc_i2c.mask_clk_reg);
d162 2
a163 2
static xf86MonPtr
radeon_do_ddc(xf86OutputPtr output)
a164 4
    RADEONInfoPtr info = RADEONPTR(output->scrn);
    unsigned char *RADEONMMIO = info->MMIO;
    uint32_t DDCReg;
    xf86MonPtr MonInfo = NULL;
a165 1
    int i, j;
d167 1
a167 2
    if (radeon_output->pI2CBus) {
	DDCReg = radeon_output->ddc_i2c.mask_clk_reg;
d169 40
a208 64
	if (IS_AVIVO_VARIANT) {
	    AVIVOI2CDoLock(output, AVIVO_I2C_ENABLE);
	    MonInfo = xf86OutputGetEDID(output, radeon_output->pI2CBus);
	    AVIVOI2CDoLock(output, AVIVO_I2C_DISABLE);
	} else if ((DDCReg == RADEON_LCD_GPIO_MASK) || (DDCReg == RADEON_MDGPIO_EN_REG)) {
	    MonInfo = xf86OutputGetEDID(output, radeon_output->pI2CBus);
	} else {
	    OUTREG(DDCReg, INREG(DDCReg) &
		   (uint32_t)~(RADEON_GPIO_A_0 | RADEON_GPIO_A_1));

	    /* For some old monitors (like Compaq Presario FP500), we need
	     * following process to initialize/stop DDC
	     */
	    OUTREG(DDCReg, INREG(DDCReg) & ~(RADEON_GPIO_EN_1));
	    for (j = 0; j < 3; j++) {
		OUTREG(DDCReg,
		       INREG(DDCReg) & ~(RADEON_GPIO_EN_0));
		usleep(13000);

		OUTREG(DDCReg,
		       INREG(DDCReg) & ~(RADEON_GPIO_EN_1));
		for (i = 0; i < 10; i++) {
		    usleep(15000);
		    if (INREG(DDCReg) & RADEON_GPIO_Y_1)
			break;
		}
		if (i == 10) continue;

		usleep(15000);

		OUTREG(DDCReg, INREG(DDCReg) | RADEON_GPIO_EN_0);
		usleep(15000);

		OUTREG(DDCReg, INREG(DDCReg) | RADEON_GPIO_EN_1);
		usleep(15000);
		OUTREG(DDCReg,
		       INREG(DDCReg) & ~(RADEON_GPIO_EN_0));
		usleep(15000);

		MonInfo = xf86OutputGetEDID(output, radeon_output->pI2CBus);

		OUTREG(DDCReg, INREG(DDCReg) | RADEON_GPIO_EN_1);
		OUTREG(DDCReg, INREG(DDCReg) | RADEON_GPIO_EN_0);
		usleep(15000);
		OUTREG(DDCReg,
		       INREG(DDCReg) & ~(RADEON_GPIO_EN_1));
		for (i = 0; i < 5; i++) {
		    usleep(15000);
		    if (INREG(DDCReg) & RADEON_GPIO_Y_1)
			break;
		}
		usleep(15000);
		OUTREG(DDCReg,
		       INREG(DDCReg) & ~(RADEON_GPIO_EN_0));
		usleep(15000);

		OUTREG(DDCReg, INREG(DDCReg) | RADEON_GPIO_EN_1);
		OUTREG(DDCReg, INREG(DDCReg) | RADEON_GPIO_EN_0);
		usleep(15000);
		if (MonInfo)  break;
	    }
	    OUTREG(DDCReg, INREG(DDCReg) &
		   ~(RADEON_GPIO_EN_0 | RADEON_GPIO_EN_1));
	}
a209 2

    return MonInfo;
d221 21
a241 2
    if (radeon_output->pI2CBus)
	MonInfo = radeon_do_ddc(output);
d243 2
a244 3
	if (!xf86ReturnOptValBool(info->Options, OPTION_IGNORE_EDID, FALSE))
	    xf86OutputSetEDID(output, MonInfo);
	if (radeon_output->type == OUTPUT_LVDS)
d246 17
a262 1
	else if (radeon_output->type == OUTPUT_DVI_D)
d264 22
a285 8
	else if (radeon_output->type == OUTPUT_HDMI)
	    MonType = MT_DFP;
	else if (radeon_output->type == OUTPUT_DP)
	    MonType = MT_DFP;
	else if (radeon_output->type == OUTPUT_DVI_I && (MonInfo->rawData[0x14] & 0x80)) /* if it's digital and DVI */
	    MonType = MT_DFP;
	else
	    MonType = MT_CRT;
d288 1
a288 1
    
a341 44
RADEONConnectorFindMonitor(xf86OutputPtr output)
{
    ScrnInfoPtr pScrn        = output->scrn;
    RADEONInfoPtr info       = RADEONPTR(pScrn);
    RADEONOutputPrivatePtr radeon_output = output->driver_private;

    if (radeon_output->MonType == MT_UNKNOWN) {
	radeon_output->MonType = radeon_ddc_connected(output);
	if (!radeon_output->MonType) {
	    if (radeon_output->type == OUTPUT_LVDS) {
		if (xf86ReturnOptValBool(info->Options, OPTION_IGNORE_LID_STATUS, TRUE))
		    radeon_output->MonType = MT_LCD;
		else
#if defined(__powerpc__)
		    radeon_output->MonType = MT_LCD;
#else
		    radeon_output->MonType = RADEONDetectLidStatus(pScrn);
#endif
	    } else {
		if (info->IsAtomBios)
		    radeon_output->MonType = atombios_dac_detect(pScrn, output);
		else
		    radeon_output->MonType = legacy_dac_detect(pScrn, output);
	    }
	}
    }

    /* update panel info for RMX */
    if (radeon_output->MonType == MT_LCD || radeon_output->MonType == MT_DFP)
	RADEONUpdatePanelSize(output);

    /* panel is probably busted or not connected */
    if ((radeon_output->MonType == MT_LCD) &&
	((radeon_output->PanelXRes == 0) || (radeon_output->PanelYRes == 0)))
	radeon_output->MonType = MT_NONE;

    if (output->MonInfo) {
	xf86DrvMsg(pScrn->scrnIndex, X_INFO, "EDID data from the display on output: %s ----------------------\n",
		   output->name);
	xf86PrintEDID( output->MonInfo );
    }
}

static void
d350 1
a350 1
    if (IS_AVIVO_VARIANT) {
d380 1
d395 5
a399 21
    if (OUTPUT_IS_TV) {
	/* FIXME: Update when more modes are added */
	if (IS_AVIVO_VARIANT) {
	    int max_v;

	    /* tv-scaler can scale horizontal width
	     * but frame ends must match tv_pll
	     * for now cap v size
	     */
	    if (radeon_output->tvStd == TV_STD_NTSC ||
		radeon_output->tvStd == TV_STD_NTSC_J ||
		radeon_output->tvStd == TV_STD_PAL_M)
		max_v = 480;
	    else
		max_v = 600;

	    if (pMode->VDisplay == max_v)
		return MODE_OK;
	    else
		return MODE_CLOCK_RANGE;
	} else {
d407 18
a424 1
    if (radeon_output->type == OUTPUT_LVDS) {
d426 2
a427 2
	    if (pMode->HDisplay != radeon_output->PanelXRes ||
		pMode->VDisplay != radeon_output->PanelYRes)
d430 2
a431 2
	if (pMode->HDisplay > radeon_output->PanelXRes ||
	    pMode->VDisplay > radeon_output->PanelYRes)
d444 1
d448 6
d455 1
a455 1
    if ((radeon_output->MonType == MT_LCD || radeon_output->MonType == MT_DFP)
d461 2
a462 2
	    if (mode->HDisplay < radeon_output->PanelXRes ||
		mode->VDisplay < radeon_output->PanelYRes) {
d466 8
a473 8
		    adjusted_mode->HDisplay = radeon_output->PanelXRes;
		    adjusted_mode->HDisplay = radeon_output->PanelYRes;
		    adjusted_mode->HTotal = radeon_output->PanelXRes + radeon_output->HBlank;
		    adjusted_mode->HSyncStart = radeon_output->PanelXRes + radeon_output->HOverPlus;
		    adjusted_mode->HSyncEnd = adjusted_mode->HSyncStart + radeon_output->HSyncWidth;
		    adjusted_mode->VTotal = radeon_output->PanelYRes + radeon_output->VBlank;
		    adjusted_mode->VSyncStart = radeon_output->PanelYRes + radeon_output->VOverPlus;
		    adjusted_mode->VSyncEnd = adjusted_mode->VSyncStart + radeon_output->VSyncWidth;
d477 8
a484 8
		    adjusted_mode->CrtcHDisplay = radeon_output->PanelXRes;
		    adjusted_mode->CrtcVDisplay = radeon_output->PanelYRes;
		    adjusted_mode->CrtcHTotal = adjusted_mode->CrtcHDisplay + radeon_output->HBlank;
		    adjusted_mode->CrtcHSyncStart = adjusted_mode->CrtcHDisplay + radeon_output->HOverPlus;
		    adjusted_mode->CrtcHSyncEnd = adjusted_mode->CrtcHSyncStart + radeon_output->HSyncWidth;
		    adjusted_mode->CrtcVTotal = adjusted_mode->CrtcVDisplay + radeon_output->VBlank;
		    adjusted_mode->CrtcVSyncStart = adjusted_mode->CrtcVDisplay + radeon_output->VOverPlus;
		    adjusted_mode->CrtcVSyncEnd = adjusted_mode->CrtcVSyncStart + radeon_output->VSyncWidth;
d487 7
a493 7
		    adjusted_mode->HTotal = radeon_output->PanelXRes + radeon_output->HBlank;
		    adjusted_mode->HSyncStart = radeon_output->PanelXRes + radeon_output->HOverPlus;
		    adjusted_mode->HSyncEnd = adjusted_mode->HSyncStart + radeon_output->HSyncWidth;
		    adjusted_mode->VTotal = radeon_output->PanelYRes + radeon_output->VBlank;
		    adjusted_mode->VSyncStart = radeon_output->PanelYRes + radeon_output->VOverPlus;
		    adjusted_mode->VSyncEnd = adjusted_mode->VSyncStart + radeon_output->VSyncWidth;
		    adjusted_mode->Clock = radeon_output->DotClock;
d497 6
a502 6
		    adjusted_mode->CrtcHTotal = adjusted_mode->CrtcHDisplay + radeon_output->HBlank;
		    adjusted_mode->CrtcHSyncStart = adjusted_mode->CrtcHDisplay + radeon_output->HOverPlus;
		    adjusted_mode->CrtcHSyncEnd = adjusted_mode->CrtcHSyncStart + radeon_output->HSyncWidth;
		    adjusted_mode->CrtcVTotal = adjusted_mode->CrtcVDisplay + radeon_output->VBlank;
		    adjusted_mode->CrtcVSyncStart = adjusted_mode->CrtcVDisplay + radeon_output->VOverPlus;
		    adjusted_mode->CrtcVSyncEnd = adjusted_mode->CrtcVSyncStart + radeon_output->VSyncWidth;
d504 2
a505 2
		adjusted_mode->Clock = radeon_output->DotClock;
		adjusted_mode->Flags = radeon_output->Flags;
d510 7
a522 16
    xf86CrtcConfigPtr	config = XF86_CRTC_CONFIG_PTR (output->scrn);
    int o;

    for (o = 0; o < config->num_output; o++) {
	xf86OutputPtr loop_output = config->output[o];
	if (loop_output == output)
	    continue;
	else if (loop_output->crtc) {
	    xf86CrtcPtr other_crtc = loop_output->crtc;
	    if (other_crtc->enabled) {
		radeon_dpms(loop_output, DPMSModeOff);
		radeon_crtc_dpms(other_crtc, DPMSModeOff);
	    }
	}
    }

a524 2
    radeon_crtc_dpms(output->crtc, DPMSModeOff);

d533 1
a533 1
    if (IS_AVIVO_VARIANT)
a543 16
    xf86CrtcConfigPtr	config = XF86_CRTC_CONFIG_PTR (output->scrn);
    int o;

    for (o = 0; o < config->num_output; o++) {
	xf86OutputPtr loop_output = config->output[o];
	if (loop_output == output)
	    continue;
	else if (loop_output->crtc) {
	    xf86CrtcPtr other_crtc = loop_output->crtc;
	    if (other_crtc->enabled) {
		radeon_dpms(loop_output, DPMSModeOn);		
		radeon_crtc_dpms(other_crtc, DPMSModeOn);
	    }
	}
    }

a544 1
    radeon_crtc_dpms(output->crtc, DPMSModeOn);
d585 50
a634 74
	if (mode == DPMSModeOn) {
	    if (radeon_output->MonType == MT_STV ||
		radeon_output->MonType == MT_CTV) {
		if (radeon_output->devices & ATOM_DEVICE_TV1_SUPPORT) {
		    save->bios_2_scratch &= ~ATOM_S2_TV1_DPMS_STATE;
		    save->bios_3_scratch |= ATOM_S3_TV1_ACTIVE;
		}
	    } else if (radeon_output->MonType == MT_CV) {
		if (radeon_output->devices & ATOM_DEVICE_CV_SUPPORT) {
		    save->bios_2_scratch &= ~ATOM_S2_CV_DPMS_STATE;
		    save->bios_3_scratch |= ATOM_S3_CV_ACTIVE;
		}
	    } else if (radeon_output->MonType == MT_CRT) {
		if (radeon_output->devices & ATOM_DEVICE_CRT1_SUPPORT) {
		    save->bios_2_scratch &= ~ATOM_S2_CRT1_DPMS_STATE;
		    save->bios_3_scratch |= ATOM_S3_CRT1_ACTIVE;
		} else if (radeon_output->devices & ATOM_DEVICE_CRT2_SUPPORT) {
		    save->bios_2_scratch &= ~ATOM_S2_CRT2_DPMS_STATE;
		    save->bios_3_scratch |= ATOM_S3_CRT2_ACTIVE;
		}
	    } else if (radeon_output->MonType == MT_LCD) {
		if (radeon_output->devices & ATOM_DEVICE_LCD1_SUPPORT) {
		    save->bios_2_scratch &= ~ATOM_S2_LCD1_DPMS_STATE;
		    save->bios_3_scratch |= ATOM_S3_LCD1_ACTIVE;
		}
	    } else if (radeon_output->MonType == MT_DFP) {
		if (radeon_output->devices & ATOM_DEVICE_DFP1_SUPPORT) {
		    save->bios_2_scratch &= ~ATOM_S2_DFP1_DPMS_STATE;
		    save->bios_3_scratch |= ATOM_S3_DFP1_ACTIVE;
		} else if (radeon_output->devices & ATOM_DEVICE_DFP2_SUPPORT) {
		    save->bios_2_scratch &= ~ATOM_S2_DFP2_DPMS_STATE;
		    save->bios_3_scratch |= ATOM_S3_DFP2_ACTIVE;
		} else if (radeon_output->devices & ATOM_DEVICE_DFP3_SUPPORT) {
		    save->bios_2_scratch &= ~ATOM_S2_DFP3_DPMS_STATE;
		    save->bios_3_scratch |= ATOM_S3_DFP3_ACTIVE;
		}
	    }
	} else {
	    if (radeon_output->MonType == MT_STV ||
		radeon_output->MonType == MT_CTV) {
		if (radeon_output->devices & ATOM_DEVICE_TV1_SUPPORT) {
		    save->bios_2_scratch |= ATOM_S2_TV1_DPMS_STATE;
		    save->bios_3_scratch &= ~ATOM_S3_TV1_ACTIVE;
		}
	    } else if (radeon_output->MonType == MT_CV) {
		if (radeon_output->devices & ATOM_DEVICE_CV_SUPPORT) {
		    save->bios_2_scratch |= ATOM_S2_CV_DPMS_STATE;
		    save->bios_3_scratch &= ~ATOM_S3_CV_ACTIVE;
		}
	    } else if (radeon_output->MonType == MT_CRT) {
		if (radeon_output->devices & ATOM_DEVICE_CRT1_SUPPORT) {
		    save->bios_2_scratch |= ATOM_S2_CRT1_DPMS_STATE;
		    save->bios_3_scratch &= ~ATOM_S3_CRT1_ACTIVE;
		} else if (radeon_output->devices & ATOM_DEVICE_CRT2_SUPPORT) {
		    save->bios_2_scratch |= ATOM_S2_CRT2_DPMS_STATE;
		    save->bios_3_scratch &= ~ATOM_S3_CRT2_ACTIVE;
		}
	    } else if (radeon_output->MonType == MT_LCD) {
		if (radeon_output->devices & ATOM_DEVICE_LCD1_SUPPORT) {
		    save->bios_2_scratch |= ATOM_S2_LCD1_DPMS_STATE;
		    save->bios_3_scratch &= ~ATOM_S3_LCD1_ACTIVE;
		}
	    } else if (radeon_output->MonType == MT_DFP) {
		if (radeon_output->devices & ATOM_DEVICE_DFP1_SUPPORT) {
		    save->bios_2_scratch |= ATOM_S2_DFP1_DPMS_STATE;
		    save->bios_3_scratch &= ~ATOM_S3_DFP1_ACTIVE;
		} else if (radeon_output->devices & ATOM_DEVICE_DFP2_SUPPORT) {
		    save->bios_2_scratch |= ATOM_S2_DFP2_DPMS_STATE;
		    save->bios_3_scratch &= ~ATOM_S3_DFP2_ACTIVE;
		} else if (radeon_output->devices & ATOM_DEVICE_DFP3_SUPPORT) {
		    save->bios_2_scratch |= ATOM_S2_DFP3_DPMS_STATE;
		    save->bios_3_scratch &= ~ATOM_S3_DFP3_ACTIVE;
		}
	    }
d636 1
a636 1
	if (info->ChipFamily >= CHIP_FAMILY_R600) {
d638 1
a638 2
	    OUTREG(R600_BIOS_3_SCRATCH, save->bios_3_scratch);
	} else {
a639 2
	    OUTREG(RADEON_BIOS_3_SCRATCH, save->bios_3_scratch);
	}
a643 20
	    if (radeon_output->MonType == MT_STV ||
		radeon_output->MonType == MT_CTV) {
		save->bios_5_scratch |= RADEON_TV1_ON;
		save->bios_6_scratch |= RADEON_TV_DPMS_ON;
	    } else if (radeon_output->MonType == MT_CRT) {
		if (radeon_output->DACType == DAC_PRIMARY)
		    save->bios_5_scratch |= RADEON_CRT1_ON;
		else
		    save->bios_5_scratch |= RADEON_CRT2_ON;
		save->bios_6_scratch |= RADEON_CRT_DPMS_ON;
	    } else if (radeon_output->MonType == MT_LCD) {
		save->bios_5_scratch |= RADEON_LCD1_ON;
		save->bios_6_scratch |= RADEON_LCD_DPMS_ON;
	    } else if (radeon_output->MonType == MT_DFP) {
		if (radeon_output->TMDSType == TMDS_INT)
		    save->bios_5_scratch |= RADEON_DFP1_ON;
		else
		    save->bios_5_scratch |= RADEON_DFP2_ON;
		save->bios_6_scratch |= RADEON_DFP_DPMS_ON;
	    }
d647 5
a651 3
	    if (radeon_output->MonType == MT_STV ||
		radeon_output->MonType == MT_CTV) {
		save->bios_5_scratch &= ~RADEON_TV1_ON;
d653 9
a661 5
	    } else if (radeon_output->MonType == MT_CRT) {
		if (radeon_output->DACType == DAC_PRIMARY)
		    save->bios_5_scratch &= ~RADEON_CRT1_ON;
		else
		    save->bios_5_scratch &= ~RADEON_CRT2_ON;
d663 4
a666 2
	    } else if (radeon_output->MonType == MT_LCD) {
		save->bios_5_scratch &= ~RADEON_LCD1_ON;
d668 9
a676 5
	    } else if (radeon_output->MonType == MT_DFP) {
		if (radeon_output->TMDSType == TMDS_INT)
		    save->bios_5_scratch &= ~RADEON_DFP1_ON;
		else
		    save->bios_5_scratch &= ~RADEON_DFP2_ON;
a677 1
	    }
a678 1
	OUTREG(RADEON_BIOS_5_SCRATCH, save->bios_5_scratch);
d695 24
a718 35
	if (radeon_output->MonType == MT_STV ||
	    radeon_output->MonType == MT_CTV) {
	    if (radeon_output->devices & ATOM_DEVICE_TV1_SUPPORT) {
		save->bios_3_scratch &= ~ATOM_S3_TV1_CRTC_ACTIVE;
		save->bios_3_scratch |= (radeon_crtc->crtc_id << 18);
	    }
	} else if (radeon_output->MonType == MT_CV) {
	    if (radeon_output->devices & ATOM_DEVICE_CV_SUPPORT) {
		save->bios_2_scratch &= ~ATOM_S3_CV_CRTC_ACTIVE;
		save->bios_3_scratch |= (radeon_crtc->crtc_id << 24);
	    }
	} else if (radeon_output->MonType == MT_CRT) {
	    if (radeon_output->devices & ATOM_DEVICE_CRT1_SUPPORT) {
		save->bios_2_scratch &= ~ATOM_S3_CRT1_CRTC_ACTIVE;
		save->bios_3_scratch |= (radeon_crtc->crtc_id << 16);
	    } else if (radeon_output->devices & ATOM_DEVICE_CRT2_SUPPORT) {
		save->bios_2_scratch &= ~ATOM_S3_CRT2_CRTC_ACTIVE;
		save->bios_3_scratch |= (radeon_crtc->crtc_id << 20);
	    }
	} else if (radeon_output->MonType == MT_LCD) {
	    if (radeon_output->devices & ATOM_DEVICE_LCD1_SUPPORT) {
		save->bios_2_scratch &= ~ATOM_S3_LCD1_CRTC_ACTIVE;
		save->bios_3_scratch |= (radeon_crtc->crtc_id << 17);
	    }
	} else if (radeon_output->MonType == MT_DFP) {
	    if (radeon_output->devices & ATOM_DEVICE_DFP1_SUPPORT) {
		save->bios_2_scratch &= ~ATOM_S3_DFP1_CRTC_ACTIVE;
		save->bios_3_scratch |= (radeon_crtc->crtc_id << 19);
	    } else if (radeon_output->devices & ATOM_DEVICE_DFP2_SUPPORT) {
		save->bios_2_scratch &= ~ATOM_S3_DFP2_CRTC_ACTIVE;
		save->bios_3_scratch |= (radeon_crtc->crtc_id << 23);
	    } else if (radeon_output->devices & ATOM_DEVICE_DFP3_SUPPORT) {
		save->bios_2_scratch &= ~ATOM_S3_DFP3_CRTC_ACTIVE;
		save->bios_3_scratch |= (radeon_crtc->crtc_id << 25);
	    }
d725 1
a725 2
	if (radeon_output->MonType == MT_STV ||
	    radeon_output->MonType == MT_CTV) {
d728 7
a734 9
	} else if (radeon_output->MonType == MT_CRT) {
	    if (radeon_output->DACType == DAC_PRIMARY) {
		save->bios_5_scratch &= ~RADEON_CRT1_CRTC_MASK;
		save->bios_5_scratch |= (radeon_crtc->crtc_id << RADEON_CRT1_CRTC_SHIFT);
	    } else {
		save->bios_5_scratch &= ~RADEON_CRT2_CRTC_MASK;
		save->bios_5_scratch |= (radeon_crtc->crtc_id << RADEON_CRT2_CRTC_SHIFT);
	    }
	} else if (radeon_output->MonType == MT_LCD) {
d737 6
a742 8
	} else if (radeon_output->MonType == MT_DFP) {
	    if (radeon_output->TMDSType == TMDS_INT) {
		save->bios_5_scratch &= ~RADEON_DFP1_CRTC_MASK;
		save->bios_5_scratch |= (radeon_crtc->crtc_id << RADEON_DFP1_CRTC_SHIFT);
	    } else {
		save->bios_5_scratch &= ~RADEON_DFP2_CRTC_MASK;
		save->bios_5_scratch |= (radeon_crtc->crtc_id << RADEON_DFP2_CRTC_SHIFT);
	    }
a756 3
    if (info->ChipFamily >= CHIP_FAMILY_R600)
	return;

d758 15
a772 22
	if (connected) {
	    if (radeon_output->MonType == MT_STV) {
		/* taken care of by load detection */
	    } else if (radeon_output->MonType == MT_CTV) {
		/* taken care of by load detection */
	    } else if (radeon_output->MonType == MT_CV) {
		/* taken care of by load detection */
	    } else if (radeon_output->MonType == MT_CRT) {
		if (radeon_output->devices & ATOM_DEVICE_CRT1_SUPPORT)
		    save->bios_0_scratch |= ATOM_S0_CRT1_COLOR;
		else if (radeon_output->devices & ATOM_DEVICE_CRT2_SUPPORT)
		    save->bios_0_scratch |= ATOM_S0_CRT2_COLOR;
	    } else if (radeon_output->MonType == MT_LCD) {
		if (radeon_output->devices & ATOM_DEVICE_LCD1_SUPPORT)
		    save->bios_0_scratch |= ATOM_S0_LCD1;
	    } else if (radeon_output->MonType == MT_DFP) {
		if (radeon_output->devices & ATOM_DEVICE_DFP1_SUPPORT)
		    save->bios_0_scratch |= ATOM_S0_DFP1;
		else if (radeon_output->devices & ATOM_DEVICE_DFP2_SUPPORT)
		    save->bios_0_scratch |= ATOM_S0_DFP2;
		else if (radeon_output->devices & ATOM_DEVICE_DFP3_SUPPORT)
		    save->bios_0_scratch |= ATOM_S0_DFP3;
d774 71
a844 26
	} else {
	    if (OUTPUT_IS_TV) {
		if (radeon_output->devices & ATOM_DEVICE_TV1_SUPPORT)
		    save->bios_0_scratch &= ~ATOM_S0_TV1_MASK;
	    }
	    if (radeon_output->type == OUTPUT_CV) {
		if (radeon_output->devices & ATOM_DEVICE_CV_SUPPORT)
		    save->bios_0_scratch &= ~ATOM_S0_CV_MASK;
	    }
	    if (radeon_output->DACType) {
		if (radeon_output->devices & ATOM_DEVICE_CRT1_SUPPORT)
		    save->bios_0_scratch &= ~ATOM_S0_CRT1_MASK;
		else if (radeon_output->devices & ATOM_DEVICE_CRT2_SUPPORT)
		    save->bios_0_scratch &= ~ATOM_S0_CRT2_MASK;
	    }
	    if (radeon_output->type == OUTPUT_LVDS) {
		if (radeon_output->devices & ATOM_DEVICE_LCD1_SUPPORT)
		    save->bios_0_scratch &= ~ATOM_S0_LCD1;
	    }
	    if (radeon_output->TMDSType) {
		if (radeon_output->devices & ATOM_DEVICE_DFP1_SUPPORT)
		    save->bios_0_scratch &= ~ATOM_S0_DFP1;
		else if (radeon_output->devices & ATOM_DEVICE_DFP2_SUPPORT)
		    save->bios_0_scratch &= ~ATOM_S0_DFP2;
		else if (radeon_output->devices & ATOM_DEVICE_DFP3_SUPPORT)
		    save->bios_0_scratch &= ~ATOM_S0_DFP3;
d846 1
d848 1
a848 1
	if (info->ChipFamily >= CHIP_FAMILY_R600)
d850 2
a851 1
	else
d853 2
d856 15
a870 11
	if (connected) {
	    if (radeon_output->MonType == MT_STV)
		save->bios_4_scratch |= RADEON_TV1_ATTACHED_SVIDEO;
	    else if (radeon_output->MonType == MT_CTV)
		save->bios_4_scratch |= RADEON_TV1_ATTACHED_COMP;
	    else if (radeon_output->MonType == MT_CRT) {
		if (radeon_output->DACType == DAC_PRIMARY)
		    save->bios_4_scratch |= RADEON_CRT1_ATTACHED_COLOR;
		else
		    save->bios_4_scratch |= RADEON_CRT2_ATTACHED_COLOR;
	    } else if (radeon_output->MonType == MT_LCD)
d872 13
a884 5
	    else if (radeon_output->MonType == MT_DFP) {
		if (radeon_output->TMDSType == TMDS_INT)
		    save->bios_4_scratch |= RADEON_DFP1_ATTACHED;
		else
		    save->bios_4_scratch |= RADEON_DFP2_ATTACHED;
d886 6
a891 4
	} else {
	    if (OUTPUT_IS_TV)
		save->bios_4_scratch &= ~RADEON_TV1_ATTACHED_MASK;
	    else if (radeon_output->DACType == DAC_TVDAC)
d893 8
a900 5
	    if (radeon_output->DACType == DAC_PRIMARY)
		save->bios_4_scratch &= ~RADEON_CRT1_ATTACHED_MASK;
	    if (radeon_output->type == OUTPUT_LVDS)
		save->bios_4_scratch &= ~RADEON_LCD1_ATTACHED;
	    if (radeon_output->TMDSType == TMDS_INT)
d902 8
a909 1
	    if (radeon_output->TMDSType == TMDS_EXT)
d911 3
d916 1
d931 37
a967 1
    RADEONConnectorFindMonitor(output);
d973 1
a973 1
	    if (radeon_output->type == OUTPUT_LVDS) {
d976 1
a976 1
		xf86DrvMsg(pScrn->scrnIndex, X_ERROR, "Using LVDS default\n");
d979 1
a979 2
	    if (radeon_output->type == OUTPUT_VGA ||
		radeon_output->type == OUTPUT_DVI_I) {
d982 2
a983 2
		xf86DrvMsg(pScrn->scrnIndex, X_ERROR, "Using VGA default\n");
	    } else if (radeon_output->type == OUTPUT_DVI_D) {
d986 1
a986 1
		xf86DrvMsg(pScrn->scrnIndex, X_ERROR, "Using DVI default\n");
d996 2
a997 1
	if (radeon_output->type == OUTPUT_LVDS)
d999 4
a1002 9
	else if (radeon_output->type == OUTPUT_VGA)
            radeon_output->MonType = MT_CRT;
	else if (radeon_output->type == OUTPUT_STV)
            radeon_output->MonType = MT_STV;
	else if (radeon_output->type == OUTPUT_CTV)
            radeon_output->MonType = MT_CTV;
	else if (radeon_output->type == OUTPUT_CV)
            radeon_output->MonType = MT_CV;
	else if (radeon_output->type == OUTPUT_DVI_D)
d1004 4
a1007 3
	else if (radeon_output->type == OUTPUT_HDMI)
	    radeon_output->MonType = MT_DFP;
	else if (radeon_output->type == OUTPUT_DVI_A)
d1009 2
a1010 1
	else if (radeon_output->type == OUTPUT_DVI_I) {
d1015 13
d1031 1
a1031 4
    if (radeon_output->MonType == MT_UNKNOWN) {
        output->subpixel_order = SubPixelUnknown;
	return XF86OutputStatusUnknown;
    } else {
d1033 4
a1036 15
      switch(radeon_output->MonType) {
      case MT_LCD:
      case MT_DFP:
	  output->subpixel_order = SubPixelHorizontalRGB;
	  break;
      default:
	  output->subpixel_order = SubPixelNone;
	  break;
      }

      if (connected)
	  return XF86OutputStatusConnected;
      else
	  return XF86OutputStatusDisconnected;
    }
d1038 4
d1102 1
d1126 1
d1128 1
a1128 2
    if (radeon_output->DACType == DAC_PRIMARY ||
	radeon_output->DACType == DAC_TVDAC) {
d1141 1
a1141 1
	    data = 1; /* user forces on tv dac load detection */
d1143 1
a1143 1
	    data = 0; /* shared tvdac between vga/dvi/tv */
d1154 1
a1154 2
    if (IS_DCE3_VARIANT &&
	(OUTPUT_IS_DVI || (radeon_output->type == OUTPUT_HDMI))) {
d1166 1
a1166 1
	data = 1; /* use coherent mode by default */
d1177 1
a1177 1
    if (OUTPUT_IS_DVI && radeon_output->TMDSType == TMDS_INT) {
d1208 1
a1208 1
    if (radeon_output->type == OUTPUT_LVDS || OUTPUT_IS_DVI) {
d1218 6
a1223 1
	if (radeon_output->type == OUTPUT_LVDS)
d1225 8
a1232 2
	else
	    s = "off";
d1243 2
a1244 1
    if (radeon_output->type == OUTPUT_DVI_I) {
d1264 2
a1265 1
    if (OUTPUT_IS_TV) {
d1335 1
a1335 1
	switch (radeon_output->tvStd) {
d1457 5
d1473 1
d1475 6
d1485 5
a1489 5
	    if (!RADEONGetTMDSInfoFromBIOS(output))
		RADEONGetTMDSInfoFromTable(output);
	} else if (value->size == strlen("driver") && !strncmp("driver", s, strlen("driver"))) {
	    RADEONGetTMDSInfoFromTable(output);
	} else
d1510 1
d1521 2
a1522 2
	radeon_output->hSize = val;
	if (radeon_output->tv_on && !IS_AVIVO_VARIANT)
d1526 1
d1537 2
a1538 2
	radeon_output->hPos = val;
	if (radeon_output->tv_on && !IS_AVIVO_VARIANT)
d1542 1
d1553 2
a1554 2
	radeon_output->vPos = val;
	if (radeon_output->tv_on && !IS_AVIVO_VARIANT)
d1559 2
a1560 1
	TVStd std = radeon_output->tvStd;
d1566 1
a1566 1
	    radeon_output->tvStd = TV_STD_NTSC;
d1568 1
a1568 1
	    radeon_output->tvStd = TV_STD_PAL;
d1570 1
a1570 1
	    radeon_output->tvStd = TV_STD_PAL_M;
d1572 1
a1572 1
	    radeon_output->tvStd = TV_STD_PAL_60;
d1574 1
a1574 1
	    radeon_output->tvStd = TV_STD_NTSC_J;
d1576 1
a1576 1
	    radeon_output->tvStd = TV_STD_SCART_PAL;
d1578 1
a1578 1
	    radeon_output->tvStd = TV_STD_PAL_CN;
d1580 1
a1580 1
	    radeon_output->tvStd = TV_STD_SECAM;
d1585 1
a1585 1
	    radeon_output->tvStd = std;
d1610 2
a1611 55
void RADEONSetOutputType(ScrnInfoPtr pScrn, RADEONOutputPrivatePtr radeon_output)
{
    RADEONOutputType output = OUTPUT_NONE;

    switch(radeon_output->ConnectorType) {
    case CONNECTOR_VGA:
	output = OUTPUT_VGA; break;
    case CONNECTOR_DVI_I:
	output = OUTPUT_DVI_I; break;
    case CONNECTOR_DVI_D:
	output = OUTPUT_DVI_D; break;
    case CONNECTOR_DVI_A:
	output = OUTPUT_DVI_A; break;
    case CONNECTOR_DIN:
	if (radeon_output->devices & ATOM_DEVICE_CV_SUPPORT)
	    output = OUTPUT_CV;
	else if (radeon_output->devices & ATOM_DEVICE_TV1_SUPPORT)
	    output = OUTPUT_STV;
	break;
    case CONNECTOR_STV:
	output = OUTPUT_STV; break;
    case CONNECTOR_CTV:
	output = OUTPUT_CTV; break;
    case CONNECTOR_LVDS:
	output = OUTPUT_LVDS; break;
    case CONNECTOR_HDMI_TYPE_A:
    case CONNECTOR_HDMI_TYPE_B:
	output = OUTPUT_HDMI; break;
    case CONNECTOR_DISPLAY_PORT:
	output = OUTPUT_DP; break;
    case CONNECTOR_DIGITAL:
    case CONNECTOR_NONE:
    case CONNECTOR_UNSUPPORTED:
    default:
	output = OUTPUT_NONE; break;
    }
    radeon_output->type = output;
}

#if 0
static
Bool AVIVOI2CReset(ScrnInfoPtr pScrn)
{
  RADEONInfoPtr info = RADEONPTR(pScrn);
  unsigned char *RADEONMMIO = info->MMIO;

  OUTREG(AVIVO_I2C_STOP, 1);
  INREG(AVIVO_I2C_STOP);
  OUTREG(AVIVO_I2C_STOP, 0x0);
  return TRUE;
}
#endif

static
Bool AVIVOI2CDoLock(xf86OutputPtr output, int lock_state)
d1620 10
d1631 2
a1632 2
    if (lock_state == AVIVO_I2C_ENABLE)
	temp |= (pRADEONI2CBus->put_clk_mask);
d1634 1
a1634 1
	temp &= ~(pRADEONI2CBus->put_clk_mask);
d1639 2
a1640 2
    if (lock_state == AVIVO_I2C_ENABLE)
	temp |= (pRADEONI2CBus->put_data_mask);
d1642 1
a1642 1
	temp &= ~(pRADEONI2CBus->put_data_mask);
d1687 2
a1688 2
static Bool
RADEONI2CInit(xf86OutputPtr output, I2CBusPtr *bus_ptr, char *name, Bool dvo)
a1689 2
    ScrnInfoPtr pScrn = output->scrn;
    RADEONOutputPrivatePtr radeon_output = output->driver_private;
a1690 1
    RADEONI2CBusPtr pRADEONI2CBus;
a1700 6
    if (dvo) {
	pRADEONI2CBus = &(radeon_output->dvo_i2c);
    } else {
	pRADEONI2CBus = &(radeon_output->ddc_i2c);
    }

d1715 6
a1720 2
    i2c.mask_clk_mask = RADEON_GPIO_EN_1 | RADEON_GPIO_Y_1;
    i2c.mask_data_mask =  RADEON_GPIO_EN_0 | RADEON_GPIO_Y_0;
d1729 2
d1738 2
d1759 2
d1768 2
d1777 2
d1782 2
a1796 258
RADEONGetPanelInfoFromReg (xf86OutputPtr output)
{
    ScrnInfoPtr pScrn = output->scrn;
    RADEONInfoPtr  info       = RADEONPTR(pScrn);
    RADEONOutputPrivatePtr radeon_output = output->driver_private;
    unsigned char *RADEONMMIO = info->MMIO;
    uint32_t fp_vert_stretch = INREG(RADEON_FP_VERT_STRETCH);
    uint32_t fp_horz_stretch = INREG(RADEON_FP_HORZ_STRETCH);

    radeon_output->PanelPwrDly = 200;
    if (fp_vert_stretch & RADEON_VERT_STRETCH_ENABLE) {
	radeon_output->PanelYRes = ((fp_vert_stretch & RADEON_VERT_PANEL_SIZE) >>
				    RADEON_VERT_PANEL_SHIFT) + 1;
    } else {
	radeon_output->PanelYRes = (INREG(RADEON_CRTC_V_TOTAL_DISP)>>16) + 1;
    }
    if (fp_horz_stretch & RADEON_HORZ_STRETCH_ENABLE) {
	radeon_output->PanelXRes = (((fp_horz_stretch & RADEON_HORZ_PANEL_SIZE) >>
				     RADEON_HORZ_PANEL_SHIFT) + 1) * 8;
    } else {
	radeon_output->PanelXRes = ((INREG(RADEON_CRTC_H_TOTAL_DISP)>>16) + 1) * 8;
    }
    
    if ((radeon_output->PanelXRes < 640) || (radeon_output->PanelYRes < 480)) {
	radeon_output->PanelXRes = 640;
	radeon_output->PanelYRes = 480;
    }

    // move this to crtc function
    if (xf86ReturnOptValBool(info->Options, OPTION_LVDS_PROBE_PLL, TRUE)) {
           uint32_t ppll_div_sel, ppll_val;

           ppll_div_sel = INREG8(RADEON_CLOCK_CNTL_INDEX + 1) & 0x3;
	   RADEONPllErrataAfterIndex(info);
	   ppll_val = INPLL(pScrn, RADEON_PPLL_DIV_0 + ppll_div_sel);
           if ((ppll_val & 0x000707ff) == 0x1bb)
		   goto noprobe;
	   info->FeedbackDivider = ppll_val & 0x7ff;
	   info->PostDivider = (ppll_val >> 16) & 0x7;
	   info->RefDivider = info->pll.reference_div;
	   info->UseBiosDividers = TRUE;

           xf86DrvMsg(pScrn->scrnIndex, X_INFO,
                      "Existing panel PLL dividers will be used.\n");
    }
 noprobe:

    xf86DrvMsg(pScrn->scrnIndex, X_WARNING, 
	       "Panel size %dx%d is derived, this may not be correct.\n"
		   "If not, use PanelSize option to overwrite this setting\n",
	       radeon_output->PanelXRes, radeon_output->PanelYRes);
}

/* BIOS may not have right panel size, we search through all supported
 * DDC modes looking for the maximum panel size.
 */
static void
RADEONUpdatePanelSize(xf86OutputPtr output)
{
    ScrnInfoPtr pScrn = output->scrn;
    RADEONInfoPtr  info       = RADEONPTR(pScrn);
    RADEONOutputPrivatePtr radeon_output = output->driver_private;
    int             j;
    /* XXX: fixme */
    //xf86MonPtr      ddc  = pScrn->monitor->DDC;
    xf86MonPtr ddc = output->MonInfo;
    DisplayModePtr  p;

    // crtc should handle?
    if ((info->UseBiosDividers && radeon_output->DotClock != 0) || (ddc == NULL))
       return;

    /* Go thru detailed timing table first */
    for (j = 0; j < 4; j++) {
	if (ddc->det_mon[j].type == 0) {
	    struct detailed_timings *d_timings =
		&ddc->det_mon[j].section.d_timings;
           int match = 0;

           /* If we didn't get a panel clock or guessed one, try to match the
            * mode with the panel size. We do that because we _need_ a panel
            * clock, or ValidateFPModes will fail, even when UseBiosDividers
            * is set.
            */
           if (radeon_output->DotClock == 0 &&
               radeon_output->PanelXRes == d_timings->h_active &&
               radeon_output->PanelYRes == d_timings->v_active)
               match = 1;

           /* If we don't have a BIOS provided panel data with fixed dividers,
            * check for a larger panel size
            */
	    if (radeon_output->PanelXRes < d_timings->h_active &&
               radeon_output->PanelYRes < d_timings->v_active &&
               !info->UseBiosDividers)
               match = 1;

             if (match) {
		radeon_output->PanelXRes  = d_timings->h_active;
		radeon_output->PanelYRes  = d_timings->v_active;
		radeon_output->DotClock   = d_timings->clock / 1000;
		radeon_output->HOverPlus  = d_timings->h_sync_off;
		radeon_output->HSyncWidth = d_timings->h_sync_width;
		radeon_output->HBlank     = d_timings->h_blanking;
		radeon_output->VOverPlus  = d_timings->v_sync_off;
		radeon_output->VSyncWidth = d_timings->v_sync_width;
		radeon_output->VBlank     = d_timings->v_blanking;
                radeon_output->Flags      = (d_timings->interlaced ? V_INTERLACE : 0);
                switch (d_timings->misc) {
                case 0: radeon_output->Flags |= V_NHSYNC | V_NVSYNC; break;
                case 1: radeon_output->Flags |= V_PHSYNC | V_NVSYNC; break;
                case 2: radeon_output->Flags |= V_NHSYNC | V_PVSYNC; break;
                case 3: radeon_output->Flags |= V_PHSYNC | V_PVSYNC; break;
                }
                xf86DrvMsg(pScrn->scrnIndex, X_INFO, "Panel infos found from DDC detailed: %dx%d\n",
                           radeon_output->PanelXRes, radeon_output->PanelYRes);
	    }
	}
    }

    if (info->UseBiosDividers && radeon_output->DotClock != 0)
       return;

    /* Search thru standard VESA modes from EDID */
    for (j = 0; j < 8; j++) {
	if ((radeon_output->PanelXRes < ddc->timings2[j].hsize) &&
	    (radeon_output->PanelYRes < ddc->timings2[j].vsize)) {
	    for (p = pScrn->monitor->Modes; p; p = p->next) {
		if ((ddc->timings2[j].hsize == p->HDisplay) &&
		    (ddc->timings2[j].vsize == p->VDisplay)) {
		    float  refresh =
			(float)p->Clock * 1000.0 / p->HTotal / p->VTotal;

		    if (abs((float)ddc->timings2[j].refresh - refresh) < 1.0) {
			/* Is this good enough? */
			radeon_output->PanelXRes  = ddc->timings2[j].hsize;
			radeon_output->PanelYRes  = ddc->timings2[j].vsize;
			radeon_output->HBlank     = p->HTotal - p->HDisplay;
			radeon_output->HOverPlus  = p->HSyncStart - p->HDisplay;
			radeon_output->HSyncWidth = p->HSyncEnd - p->HSyncStart;
			radeon_output->VBlank     = p->VTotal - p->VDisplay;
			radeon_output->VOverPlus  = p->VSyncStart - p->VDisplay;
			radeon_output->VSyncWidth = p->VSyncEnd - p->VSyncStart;
			radeon_output->DotClock   = p->Clock;
                        radeon_output->Flags      = p->Flags;
                        xf86DrvMsg(pScrn->scrnIndex, X_INFO, "Panel infos found from DDC VESA/EDID: %dx%d\n",
                                   radeon_output->PanelXRes, radeon_output->PanelYRes);
		    }
		}
	    }
	}
    }
}

static Bool
RADEONGetLVDSInfo (xf86OutputPtr output)
{
    ScrnInfoPtr pScrn = output->scrn;
    RADEONInfoPtr  info       = RADEONPTR(pScrn);
    RADEONOutputPrivatePtr radeon_output = output->driver_private;
    char* s;

    if (!RADEONGetLVDSInfoFromBIOS(output))
	RADEONGetPanelInfoFromReg(output);

    if ((s = xf86GetOptValString(info->Options, OPTION_PANEL_SIZE))) {
	radeon_output->PanelPwrDly = 200;
	if (sscanf (s, "%dx%d", &radeon_output->PanelXRes, &radeon_output->PanelYRes) != 2) {
	    xf86DrvMsg(pScrn->scrnIndex, X_WARNING, "Invalid PanelSize option: %s\n", s);
	    RADEONGetPanelInfoFromReg(output);
	}
    }

    /* The panel size we collected from BIOS may not be the
     * maximum size supported by the panel.  If not, we update
     * it now.  These will be used if no matching mode can be
     * found from EDID data.
     */
    RADEONUpdatePanelSize(output);

    if (radeon_output->DotClock == 0) {
	DisplayModePtr  tmp_mode = NULL;
	xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
		   "No valid timing info from BIOS.\n");
	/* No timing information for the native mode,
	   use whatever specified in the Modeline.
	   If no Modeline specified, we'll just pick
	   the VESA mode at 60Hz refresh rate which
	   is likely to be the best for a flat panel.
	*/
	tmp_mode = pScrn->monitor->Modes;
	while(tmp_mode) {
	    if ((tmp_mode->HDisplay == radeon_output->PanelXRes) &&
		(tmp_mode->VDisplay == radeon_output->PanelYRes)) {
		    
		float  refresh =
		    (float)tmp_mode->Clock * 1000.0 / tmp_mode->HTotal / tmp_mode->VTotal;
		if ((abs(60.0 - refresh) < 1.0) ||
		    (tmp_mode->type == 0)) {
		    radeon_output->HBlank     = tmp_mode->HTotal - tmp_mode->HDisplay;
		    radeon_output->HOverPlus  = tmp_mode->HSyncStart - tmp_mode->HDisplay;
		    radeon_output->HSyncWidth = tmp_mode->HSyncEnd - tmp_mode->HSyncStart;
		    radeon_output->VBlank     = tmp_mode->VTotal - tmp_mode->VDisplay;
		    radeon_output->VOverPlus  = tmp_mode->VSyncStart - tmp_mode->VDisplay;
		    radeon_output->VSyncWidth = tmp_mode->VSyncEnd - tmp_mode->VSyncStart;
		    radeon_output->DotClock   = tmp_mode->Clock;
		    radeon_output->Flags = 0;
		    break;
		}
	    }

	    tmp_mode = tmp_mode->next;

	    if (tmp_mode == pScrn->monitor->Modes)
		break;
	}
	if ((radeon_output->DotClock == 0) && !output->MonInfo) {
	    xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
		       "Panel size is not correctly detected.\n"
		       "Please try to use PanelSize option for correct settings.\n");
	    return FALSE;
	}
    }

    return TRUE;
}

static void
RADEONGetTMDSInfoFromTable(xf86OutputPtr output)
{
    ScrnInfoPtr pScrn = output->scrn;
    RADEONInfoPtr  info       = RADEONPTR(pScrn);
    RADEONOutputPrivatePtr radeon_output = output->driver_private;
    int i;

    for (i=0; i<4; i++) {
        radeon_output->tmds_pll[i].value = default_tmds_pll[info->ChipFamily][i].value;
        radeon_output->tmds_pll[i].freq = default_tmds_pll[info->ChipFamily][i].freq;
    }
}

static void
RADEONGetTMDSInfo(xf86OutputPtr output)
{
    RADEONOutputPrivatePtr radeon_output = output->driver_private;
    int i;

    for (i=0; i<4; i++) {
        radeon_output->tmds_pll[i].value = 0;
        radeon_output->tmds_pll[i].freq = 0;
    }

    if (!RADEONGetTMDSInfoFromBIOS(output))
	RADEONGetTMDSInfoFromTable(output);

}

static void
d1802 1
d1805 4
a1808 3
    radeon_output->hPos = 0;
    radeon_output->vPos = 0;
    radeon_output->hSize = 0;
d1812 4
a1815 4
	radeon_output->default_tvStd = TV_STD_NTSC;
	radeon_output->tvStd = TV_STD_NTSC;
	radeon_output->TVRefClk = 27.000000000;
	radeon_output->SupportedTVStds = TV_STD_NTSC | TV_STD_PAL;
d1821 1
a1821 1
	    radeon_output->tvStd = TV_STD_NTSC;
d1823 1
a1823 1
	    radeon_output->tvStd = TV_STD_PAL;
d1825 1
a1825 1
	    radeon_output->tvStd = TV_STD_PAL_M;
d1827 1
a1827 1
	    radeon_output->tvStd = TV_STD_PAL_60;
d1829 1
a1829 1
	    radeon_output->tvStd = TV_STD_NTSC_J;
d1831 1
a1831 1
	    radeon_output->tvStd = TV_STD_SCART_PAL;
a1838 19
static void
RADEONGetTVDacAdjInfo(xf86OutputPtr output)
{
    ScrnInfoPtr pScrn = output->scrn;
    RADEONInfoPtr  info       = RADEONPTR(pScrn);
    RADEONOutputPrivatePtr radeon_output = output->driver_private;

    if (!RADEONGetDAC2InfoFromBIOS(output)) {
	radeon_output->ps2_tvdac_adj = default_tvdac_adj[info->ChipFamily];
	if (info->IsMobility) { /* some mobility chips may different */
	    if (info->ChipFamily == CHIP_FAMILY_RV250)
		radeon_output->ps2_tvdac_adj = 0x00880000;
	}
	radeon_output->pal_tvdac_adj = radeon_output->ps2_tvdac_adj;
	radeon_output->ntsc_tvdac_adj = radeon_output->ps2_tvdac_adj;
    }

}

d1845 2
a1846 9
    if (info->IsAtomBios &&
	((radeon_output->DACType == DAC_PRIMARY) ||
	 (radeon_output->DACType == DAC_TVDAC)))
	radeon_output->load_detection = 1;
    else if (radeon_output->DACType == DAC_PRIMARY)
	radeon_output->load_detection = 1; /* primary dac, only drives vga */
    else if ((radeon_output->DACType == DAC_TVDAC) &&
	     (xf86ReturnOptValBool(info->Options, OPTION_TVDAC_LOAD_DETECT, FALSE)))
	radeon_output->load_detection = 1; /* shared tvdac between vga/dvi/tv */
d1848 1
a1848 1
	radeon_output->load_detection = 0;
d1850 2
a1851 1
    if (radeon_output->type == OUTPUT_LVDS) {
a1852 2
	RADEONGetLVDSInfo(output);
    }
d1854 5
a1858 22
    if (OUTPUT_IS_DVI) {
	I2CBusPtr pDVOBus;
	radeon_output->rmx_type = RMX_OFF;
	if ((!info->IsAtomBios) && radeon_output->TMDSType == TMDS_EXT) {
#if defined(__powerpc__)
	    radeon_output->dvo_i2c = legacy_setup_i2c_bus(RADEON_GPIO_MONID);
	    radeon_output->dvo_i2c_slave_addr = 0x70;
#else
	    if (!RADEONGetExtTMDSInfoFromBIOS(output)) {
		radeon_output->dvo_i2c = legacy_setup_i2c_bus(RADEON_GPIO_CRT2_DDC);
		radeon_output->dvo_i2c_slave_addr = 0x70;
	    }
#endif
	    if (RADEONI2CInit(output, &pDVOBus, "DVO", TRUE)) {
		radeon_output->DVOChip =
		    RADEONDVODeviceInit(pDVOBus,
					radeon_output->dvo_i2c_slave_addr);
		if (!radeon_output->DVOChip)
		    xfree(pDVOBus);
	    }
	} else
	    RADEONGetTMDSInfo(output);
d1861 1
a1861 1
    if (OUTPUT_IS_TV)
d1864 1
a1864 6
    if (radeon_output->DACType == DAC_TVDAC) {
	radeon_output->tv_on = FALSE;
	RADEONGetTVDacAdjInfo(output);
    }

    if (OUTPUT_IS_DVI || (radeon_output->type == OUTPUT_HDMI))
d1868 1
a1868 1
	RADEONI2CInit(output, &radeon_output->pI2CBus, output->name, FALSE);
a1880 2
	info->BiosConnector[0].DACType = DAC_NONE;
	info->BiosConnector[0].TMDSType = TMDS_NONE;
d1883 7
d1892 1
a1892 2
	info->BiosConnector[1].DACType = DAC_TVDAC;
	info->BiosConnector[1].TMDSType = TMDS_NONE;
d1895 7
d1904 1
a1904 2
	info->BiosConnector[2].DACType = DAC_TVDAC;
	info->BiosConnector[2].TMDSType = TMDS_NONE;
d1907 7
a1916 2
	info->BiosConnector[0].DACType = DAC_NONE;
	info->BiosConnector[0].TMDSType = TMDS_NONE;
d1919 7
a1927 2
	info->BiosConnector[1].DACType = DAC_PRIMARY;
	info->BiosConnector[1].TMDSType = TMDS_EXT;
d1930 13
d1945 1
a1945 2
	info->BiosConnector[2].DACType = DAC_TVDAC;
	info->BiosConnector[2].TMDSType = TMDS_NONE;
d1948 7
a1955 1

a1957 2
	info->BiosConnector[0].DACType = DAC_NONE;
	info->BiosConnector[0].TMDSType = TMDS_NONE;
d1960 7
a1968 2
	info->BiosConnector[1].DACType = DAC_PRIMARY;
	info->BiosConnector[1].TMDSType = TMDS_INT;
d1971 13
d1986 1
a1986 2
	info->BiosConnector[2].DACType = DAC_TVDAC;
	info->BiosConnector[2].TMDSType = TMDS_NONE;
d1989 7
d1999 1
a1999 3
	info->BiosConnector[0].DACType = DAC_NONE;
	info->BiosConnector[0].TMDSType = TMDS_NONE;
	info->BiosConnector[0].ConnectorType = CONNECTOR_VGA;
d2001 7
d2010 1
a2010 3
	info->BiosConnector[1].DACType = DAC_PRIMARY;
	info->BiosConnector[1].TMDSType = TMDS_INT;
	info->BiosConnector[1].ConnectorType = CONNECTOR_DVI_I;
d2012 7
d2021 1
a2021 2
	info->BiosConnector[2].DACType = DAC_TVDAC;
	info->BiosConnector[2].TMDSType = TMDS_NONE;
d2024 7
d2034 1
a2034 2
	info->BiosConnector[0].DACType = DAC_TVDAC;
	info->BiosConnector[0].TMDSType = TMDS_EXT;
d2037 13
d2052 1
a2052 2
	info->BiosConnector[1].DACType = DAC_TVDAC;
	info->BiosConnector[1].TMDSType = TMDS_NONE;
d2055 7
d2065 1
a2065 2
	info->BiosConnector[0].DACType = DAC_TVDAC;
	info->BiosConnector[0].TMDSType = TMDS_INT;
d2068 13
d2083 1
a2083 2
	info->BiosConnector[1].DACType = DAC_TVDAC;
	info->BiosConnector[1].TMDSType = TMDS_NONE;
d2086 7
a2095 2
	info->BiosConnector[0].DACType = DAC_NONE;
	info->BiosConnector[0].TMDSType = TMDS_INT;
d2098 7
d2107 41
a2147 2
	info->BiosConnector[1].DACType = DAC_TVDAC;
	info->BiosConnector[1].TMDSType = TMDS_NONE;
d2150 7
d2159 1
a2159 2
	info->BiosConnector[2].DACType = DAC_TVDAC;
	info->BiosConnector[2].TMDSType = TMDS_NONE;
d2162 7
d2183 3
a2187 2
	info->BiosConnector[0].DACType = DAC_PRIMARY;
	info->BiosConnector[0].TMDSType = TMDS_NONE;
d2190 6
d2199 4
a2202 5
    if (IS_AVIVO_VARIANT) {
	if (info->IsMobility) {
	    info->BiosConnector[0].ddc_i2c = atom_setup_i2c_bus(0x7e60);
	    info->BiosConnector[0].DACType = DAC_NONE;
	    info->BiosConnector[0].TMDSType = TMDS_NONE;
d2204 1
d2206 13
a2218 5
	    info->BiosConnector[0].valid = TRUE;

	    info->BiosConnector[1].ddc_i2c = atom_setup_i2c_bus(0x7e40);
	    info->BiosConnector[1].DACType = DAC_PRIMARY;
	    info->BiosConnector[1].TMDSType = TMDS_NONE;
d2220 1
d2222 5
a2226 1
	    info->BiosConnector[1].valid = TRUE;
d2228 6
a2233 5
	    info->BiosConnector[0].ddc_i2c = atom_setup_i2c_bus(0x7e50);
	    info->BiosConnector[0].DACType = DAC_TVDAC;
	    info->BiosConnector[0].TMDSType = TMDS_INT;
	    info->BiosConnector[0].ConnectorType = CONNECTOR_DVI_I;
	    info->BiosConnector[0].devices = ATOM_DEVICE_CRT2_SUPPORT | ATOM_DEVICE_DFP1_SUPPORT;
d2235 6
d2242 1
a2242 3
	    info->BiosConnector[1].ddc_i2c = atom_setup_i2c_bus(0x7e40);
	    info->BiosConnector[1].DACType = DAC_PRIMARY;
	    info->BiosConnector[1].TMDSType = TMDS_NONE;
d2244 1
d2246 5
a2250 1
	    info->BiosConnector[1].valid = TRUE;
a2251 7

	info->BiosConnector[2].ConnectorType = CONNECTOR_STV;
	info->BiosConnector[2].DACType = DAC_TVDAC;
	info->BiosConnector[2].TMDSType = TMDS_NONE;
	info->BiosConnector[2].ddc_i2c.valid = FALSE;
	info->BiosConnector[2].devices = ATOM_DEVICE_TV1_SUPPORT;
	info->BiosConnector[2].valid = TRUE;
d2253 16
a2268 29
	if (info->IsMobility) {
	    /* Below is the most common setting, but may not be true */
	    if (info->IsIGP) {
		info->BiosConnector[0].ddc_i2c = legacy_setup_i2c_bus(RADEON_LCD_GPIO_MASK);
		info->BiosConnector[0].DACType = DAC_NONE;
		info->BiosConnector[0].TMDSType = TMDS_NONE;
		info->BiosConnector[0].ConnectorType = CONNECTOR_LVDS;
		info->BiosConnector[0].valid = TRUE;

		/* IGP only has TVDAC */
		if ((info->ChipFamily == CHIP_FAMILY_RS400) ||
		    (info->ChipFamily == CHIP_FAMILY_RS480))
		    info->BiosConnector[1].ddc_i2c = legacy_setup_i2c_bus(RADEON_GPIO_CRT2_DDC);
		else
		    info->BiosConnector[1].ddc_i2c = legacy_setup_i2c_bus(RADEON_GPIO_VGA_DDC);
		info->BiosConnector[1].DACType = DAC_TVDAC;
		info->BiosConnector[1].TMDSType = TMDS_NONE;
		info->BiosConnector[1].ConnectorType = CONNECTOR_VGA;
		info->BiosConnector[1].valid = TRUE;
	    } else {
#if defined(__powerpc__)
		info->BiosConnector[0].ddc_i2c = legacy_setup_i2c_bus(RADEON_GPIO_DVI_DDC);
#else
		info->BiosConnector[0].ddc_i2c = legacy_setup_i2c_bus(RADEON_LCD_GPIO_MASK);
#endif
		info->BiosConnector[0].DACType = DAC_NONE;
		info->BiosConnector[0].TMDSType = TMDS_NONE;
		info->BiosConnector[0].ConnectorType = CONNECTOR_LVDS;
		info->BiosConnector[0].valid = TRUE;
d2270 12
a2281 6
		info->BiosConnector[1].ddc_i2c = legacy_setup_i2c_bus(RADEON_GPIO_VGA_DDC);
		info->BiosConnector[1].DACType = DAC_PRIMARY;
		info->BiosConnector[1].TMDSType = TMDS_NONE;
		info->BiosConnector[1].ConnectorType = CONNECTOR_VGA;
		info->BiosConnector[1].valid = TRUE;
	    }
d2283 15
a2297 26
	    /* Below is the most common setting, but may not be true */
	    if (info->IsIGP) {
		if ((info->ChipFamily == CHIP_FAMILY_RS400) ||
		    (info->ChipFamily == CHIP_FAMILY_RS480))
		    info->BiosConnector[0].ddc_i2c = legacy_setup_i2c_bus(RADEON_GPIO_CRT2_DDC);
		else
		    info->BiosConnector[0].ddc_i2c = legacy_setup_i2c_bus(RADEON_GPIO_VGA_DDC);
		info->BiosConnector[0].DACType = DAC_TVDAC;
		info->BiosConnector[0].TMDSType = TMDS_NONE;
		info->BiosConnector[0].ConnectorType = CONNECTOR_VGA;
		info->BiosConnector[0].valid = TRUE;

		/* not sure what a good default DDCType for DVI on
		 * IGP desktop chips is
		 */
		info->BiosConnector[1].ddc_i2c = legacy_setup_i2c_bus(RADEON_GPIO_MONID); /* DDC_DVI? */
		info->BiosConnector[1].DACType = DAC_NONE;
		info->BiosConnector[1].TMDSType = TMDS_EXT;
		info->BiosConnector[1].ConnectorType = CONNECTOR_DVI_D;
		info->BiosConnector[1].valid = TRUE;
	    } else {
		info->BiosConnector[0].ddc_i2c = legacy_setup_i2c_bus(RADEON_GPIO_DVI_DDC);
		info->BiosConnector[0].DACType = DAC_TVDAC;
		info->BiosConnector[0].TMDSType = TMDS_INT;
		info->BiosConnector[0].ConnectorType = CONNECTOR_DVI_I;
		info->BiosConnector[0].valid = TRUE;
d2300 14
a2313 5
		info->BiosConnector[1].ddc_i2c = legacy_setup_i2c_bus(RADEON_GPIO_VGA_DDC);
		info->BiosConnector[1].DACType = DAC_PRIMARY;
		info->BiosConnector[1].TMDSType = TMDS_EXT;
		info->BiosConnector[1].ConnectorType = CONNECTOR_DVI_I;
		info->BiosConnector[1].valid = TRUE;
d2315 9
a2323 5
		info->BiosConnector[1].ddc_i2c = legacy_setup_i2c_bus(RADEON_GPIO_VGA_DDC);
		info->BiosConnector[1].DACType = DAC_PRIMARY;
		info->BiosConnector[1].TMDSType = TMDS_EXT;
		info->BiosConnector[1].ConnectorType = CONNECTOR_VGA;
		info->BiosConnector[1].valid = TRUE;
a2324 1
	    }
d2326 1
d2328 12
a2339 7
	if (info->InternalTVOut) {
	    info->BiosConnector[2].ConnectorType = CONNECTOR_STV;
	    info->BiosConnector[2].DACType = DAC_TVDAC;
	    info->BiosConnector[2].TMDSType = TMDS_NONE;
	    info->BiosConnector[2].ddc_i2c.valid = FALSE;
	    info->BiosConnector[2].valid = TRUE;
	}
d2341 6
a2346 7
	/* Some cards have the DDC lines swapped and we have no way to
	 * detect it yet (Mac cards)
	 */
	if (xf86ReturnOptValBool(info->Options, OPTION_REVERSE_DDC, FALSE)) {
	    info->BiosConnector[0].ddc_i2c = legacy_setup_i2c_bus(RADEON_GPIO_VGA_DDC);
	    info->BiosConnector[1].ddc_i2c = legacy_setup_i2c_bus(RADEON_GPIO_DVI_DDC);
	}
d2373 1
a2373 1
    /* 
d2431 3
d2543 1
a2544 1
    RADEONInfoPtr info       = RADEONPTR(pScrn);
d2549 2
a2550 1
    if (IS_DCE3_VARIANT)
d2554 4
a2557 1
    if (radeon_output->type == OUTPUT_LVDS)
d2563 1
d2566 1
a2566 4
	else if (radeon_clone->type == OUTPUT_LVDS) /* LVDS */
	    continue;
	else if ((radeon_output->DACType != DAC_NONE) &&
		 (radeon_output->DACType == radeon_clone->DACType)) /* shared dac */
d2568 1
a2568 2
	else if ((radeon_output->TMDSType != TMDS_NONE) &&
		 (radeon_output->TMDSType == radeon_clone->TMDSType)) /* shared tmds */
d2577 8
a2590 1
    RADEONEntPtr pRADEONEnt  = RADEONEntPriv(pScrn);
d2593 1
a2593 1
    int i = 0;
d2597 1
d2604 1
d2606 2
a2608 2
	info->BiosConnector[i].DACType = DAC_NONE;
	info->BiosConnector[i].TMDSType = TMDS_NONE;
d2610 1
d2637 2
a2659 7
    if (!pRADEONEnt->HasCRTC2) {
	for (i = 0; i < RADEON_MAX_BIOS_CONNECTOR; i++) {
	    if (info->BiosConnector[i].ConnectorType == CONNECTOR_VGA)
		info->BiosConnector[i].DACType = DAC_PRIMARY;
	}
    }

d2665 1
d2670 1
a2670 2
	info->BiosConnector[0].valid = TRUE;
	info->BiosConnector[1].valid = TRUE;
d2673 2
a2674 2
		   &info->BiosConnector[0].DACType,
		   &info->BiosConnector[0].TMDSType,
d2677 2
a2678 2
		   &info->BiosConnector[1].DACType,
		   &info->BiosConnector[1].TMDSType,
d2684 46
a2729 2
	info->BiosConnector[0].ddc_i2c = legacy_setup_i2c_bus(ddc_line[0]);
	info->BiosConnector[1].ddc_i2c = legacy_setup_i2c_bus(ddc_line[1]);
a2731 1
    info->tvdac_use_count = 0;
d2734 4
a2737 6
	    if (info->BiosConnector[i].DACType == DAC_TVDAC)
		info->tvdac_use_count++;

	    if ((info->BiosConnector[i].ConnectorType == CONNECTOR_DVI_D) ||
		(info->BiosConnector[i].ConnectorType == CONNECTOR_DVI_I) ||
		(info->BiosConnector[i].ConnectorType == CONNECTOR_DVI_A)) {
d2739 1
a2739 1
	    } else if (info->BiosConnector[i].ConnectorType == CONNECTOR_VGA) {
d2741 2
a2742 2
	    } else if ((info->BiosConnector[i].ConnectorType == CONNECTOR_HDMI_TYPE_A) ||
		       (info->BiosConnector[i].ConnectorType == CONNECTOR_HDMI_TYPE_B)) {
d2744 2
a2749 8
    /* clear the enable masks */
    info->output_crt1 = 0;
    info->output_crt2 = 0;
    info->output_dfp1 = 0;
    info->output_dfp2 = 0;
    info->output_lcd1 = 0;
    info->output_tv1 = 0;

d2753 1
d2755 1
a2755 1
	    if (info->BiosConnector[i].ConnectorType == CONNECTOR_NONE)
d2763 1
a2763 1
	    radeon_output->ConnectorType = info->BiosConnector[i].ConnectorType;
a2764 1
	    radeon_output->output_id = info->BiosConnector[i].output_id;
d2767 20
a2786 38

	    if (radeon_output->ConnectorType == CONNECTOR_DVI_D)
		radeon_output->DACType = DAC_NONE;
	    else
		radeon_output->DACType = info->BiosConnector[i].DACType;

	    if (radeon_output->ConnectorType == CONNECTOR_VGA)
		radeon_output->TMDSType = TMDS_NONE;
	    else
		radeon_output->TMDSType = info->BiosConnector[i].TMDSType;

	    RADEONSetOutputType(pScrn, radeon_output);
	    if ((info->BiosConnector[i].ConnectorType == CONNECTOR_DVI_D) ||
		(info->BiosConnector[i].ConnectorType == CONNECTOR_DVI_I) ||
		(info->BiosConnector[i].ConnectorType == CONNECTOR_DVI_A)) {
		if (num_dvi > 1) {
		    output = xf86OutputCreate(pScrn, &radeon_output_funcs, "DVI-1");
		    num_dvi--;
		} else {
		    output = xf86OutputCreate(pScrn, &radeon_output_funcs, "DVI-0");
		}
	    } else if (info->BiosConnector[i].ConnectorType == CONNECTOR_VGA) {
		if (num_vga > 1) {
		    output = xf86OutputCreate(pScrn, &radeon_output_funcs, "VGA-1");
		    num_vga--;
		} else {
		    output = xf86OutputCreate(pScrn, &radeon_output_funcs, "VGA-0");
		}
	    } else if ((info->BiosConnector[i].ConnectorType == CONNECTOR_HDMI_TYPE_A) ||
		(info->BiosConnector[i].ConnectorType == CONNECTOR_HDMI_TYPE_B)) {
		if (num_hdmi > 1) {
		    output = xf86OutputCreate(pScrn, &radeon_output_funcs, "HDMI-1");
		    num_hdmi--;
		} else {
		    output = xf86OutputCreate(pScrn, &radeon_output_funcs, "HDMI-0");
		}
	    } else
		output = xf86OutputCreate(pScrn, &radeon_output_funcs, OutputType[radeon_output->type]);
d2794 1
a2794 1
	    if (radeon_output->type != OUTPUT_LVDS)
d2797 1
a2797 1
	    /* we can clone the DACs, and probably TV-out, 
@


1.1
log
@Long awaited update of xf86-video-ati to 6.9.0.

the rage128 and mach64 drivers were split out of this driver just after
the 6.8.0 release, these drivers will be commited separately.

MergedFb mode is gone, so please use xrandr if you used to use it.

ok matthieu@@.
@
text
@d2524 5
d2617 66
@

