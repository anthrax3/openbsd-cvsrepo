head	1.16;
access;
symbols
	OPENBSD_6_1_BASE:1.16
	OPENBSD_6_0:1.15.0.2
	OPENBSD_6_0_BASE:1.15
	OPENBSD_5_9:1.14.0.4
	OPENBSD_5_9_BASE:1.14
	OPENBSD_5_8:1.14.0.2
	OPENBSD_5_8_BASE:1.14
	OPENBSD_5_7:1.13.0.4
	OPENBSD_5_7_BASE:1.13
	OPENBSD_5_6:1.13.0.2
	OPENBSD_5_6_BASE:1.13
	OPENBSD_5_5:1.12.0.2
	OPENBSD_5_5_BASE:1.12
	OPENBSD_5_4:1.11.0.4
	OPENBSD_5_4_BASE:1.11
	OPENBSD_5_3:1.11.0.2
	OPENBSD_5_3_BASE:1.11
	OPENBSD_5_2:1.10.0.2
	OPENBSD_5_2_BASE:1.10
	OPENBSD_5_1_BASE:1.7
	OPENBSD_5_1:1.7.0.2
	OPENBSD_5_0:1.5.0.8
	OPENBSD_5_0_BASE:1.5
	OPENBSD_4_9:1.5.0.4
	OPENBSD_4_9_BASE:1.5
	OPENBSD_4_8:1.5.0.6
	OPENBSD_4_8_BASE:1.5
	OPENBSD_4_7:1.5.0.2
	OPENBSD_4_7_BASE:1.5
	OPENBSD_4_6:1.4.0.4
	OPENBSD_4_6_BASE:1.4
	OPENBSD_4_5:1.4.0.2
	OPENBSD_4_5_BASE:1.4
	OPENBSD_4_4:1.3.0.2
	OPENBSD_4_4_BASE:1.3
	OPENBSD_4_3_BASE:1.2
	OPENBSD_4_3:1.2.0.4
	OPENBSD_4_2:1.2.0.2
	OPENBSD_4_2_BASE:1.2
	v6_6_3:1.1.1.1
	xorg:1.1.1;
locks; strict;
comment	@ * @;


1.16
date	2016.11.13.14.42.27;	author matthieu;	state Exp;
branches;
next	1.15;
commitid	VCI3KGRPv1Ex2rp2;

1.15
date	2016.04.02.07.37.34;	author matthieu;	state Exp;
branches;
next	1.14;
commitid	bsyGwvYIwQ6RE8Qj;

1.14
date	2015.04.14.19.55.49;	author matthieu;	state Exp;
branches;
next	1.13;
commitid	cZqnMrCmViqubI1u;

1.13
date	2014.04.09.20.21.16;	author matthieu;	state Exp;
branches;
next	1.12;

1.12
date	2013.08.16.17.04.07;	author matthieu;	state Exp;
branches;
next	1.11;

1.11
date	2012.08.08.16.25.22;	author matthieu;	state Exp;
branches;
next	1.10;

1.10
date	2012.07.08.13.42.13;	author matthieu;	state Exp;
branches;
next	1.9;

1.9
date	2012.06.07.20.55.34;	author matthieu;	state Exp;
branches;
next	1.8;

1.8
date	2012.03.04.16.01.20;	author matthieu;	state Exp;
branches;
next	1.7;

1.7
date	2012.02.06.22.53.12;	author matthieu;	state Exp;
branches;
next	1.6;

1.6
date	2012.01.25.21.33.35;	author matthieu;	state Exp;
branches;
next	1.5;

1.5
date	2009.08.25.18.51.45;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2009.01.10.15.01.25;	author oga;	state Exp;
branches;
next	1.3;

1.3
date	2008.07.12.15.18.34;	author oga;	state Exp;
branches;
next	1.2;

1.2
date	2006.12.03.17.58.02;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.26.20.01.15;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.11.26.20.01.15;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.16
log
@Update to xf86-video-ati 7.7.1
Tested by jsg@@,  Rafael Sadowski and myself on various hardware.
@
text
@/*
 * Copyright 2000 ATI Technologies Inc., Markham, Ontario, and
 *                VA Linux Systems Inc., Fremont, California.
 *
 * All Rights Reserved.
 *
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation on the rights to use, copy, modify, merge,
 * publish, distribute, sublicense, and/or sell copies of the Software,
 * and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice (including the
 * next paragraph) shall be included in all copies or substantial
 * portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NON-INFRINGEMENT.  IN NO EVENT SHALL ATI, VA LINUX SYSTEMS AND/OR
 * THEIR SUPPLIERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
 * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 */

/*
 * Authors:
 *   Kevin E. Martin <martin@@xfree86.org>
 *   Rickard E. Faith <faith@@valinux.com>
 *   Alan Hourihane <alanh@@fairlite.demon.co.uk>
 *
 */

#ifndef _RADEON_H_
#define _RADEON_H_

#include <stdlib.h>		/* For abs() */
#include <unistd.h>		/* For usleep() */
#include <sys/time.h>		/* For gettimeofday() */

#include "config.h"

#include "xf86str.h"
#include "compiler.h"

				/* PCI support */
#include "xf86Pci.h"

#include "exa.h"

				/* Exa and Cursor Support */
#include "xf86Cursor.h"

				/* DDC support */
#include "xf86DDC.h"

				/* Xv support */
#include "xf86xv.h"

#include "radeon_probe.h"

				/* DRI support */
#include "xf86drm.h"
#include "radeon_drm.h"

#ifndef RADEON_GEM_NO_CPU_ACCESS
#define RADEON_GEM_NO_CPU_ACCESS	(1 << 4)
#endif

#ifdef DAMAGE
#include "damage.h"
#include "globals.h"
#endif

#include "xf86Crtc.h"
#include "X11/Xatom.h"

#include "radeon_bo.h"
#include "radeon_cs.h"
#include "radeon_dri2.h"
#include "drmmode_display.h"
#include "radeon_surface.h"

				/* Render support */
#ifdef RENDER
#include "picturestr.h"
#endif

#include "compat-api.h"

#include "simple_list.h"
#include "atipcirename.h"

struct _SyncFence;

#ifndef MAX
#define MAX(a,b) ((a)>(b)?(a):(b))
#endif
#ifndef MIN
#define MIN(a,b) ((a)>(b)?(b):(a))
#endif

#if HAVE_BYTESWAP_H
#include <byteswap.h>
#elif defined(USE_SYS_ENDIAN_H)
#include <sys/endian.h>
#else
#define bswap_16(value)  \
        ((((value) & 0xff) << 8) | ((value) >> 8))

#define bswap_32(value) \
        (((uint32_t)bswap_16((uint16_t)((value) & 0xffff)) << 16) | \
        (uint32_t)bswap_16((uint16_t)((value) >> 16)))
 
#define bswap_64(value) \
        (((uint64_t)bswap_32((uint32_t)((value) & 0xffffffff)) \
            << 32) | \
        (uint64_t)bswap_32((uint32_t)((value) >> 32)))
#endif

#if X_BYTE_ORDER == X_BIG_ENDIAN
#define le32_to_cpu(x) bswap_32(x)
#define le16_to_cpu(x) bswap_16(x)
#define cpu_to_le32(x) bswap_32(x)
#define cpu_to_le16(x) bswap_16(x)
#else
#define le32_to_cpu(x) (x)
#define le16_to_cpu(x) (x)
#define cpu_to_le32(x) (x)
#define cpu_to_le16(x) (x)
#endif

/* Provide substitutes for gcc's __FUNCTION__ on other compilers */
#if !defined(__GNUC__) && !defined(__FUNCTION__)
# define __FUNCTION__ __func__		/* C99 */
#endif

typedef enum {
    OPTION_ACCEL,
    OPTION_SW_CURSOR,
    OPTION_PAGE_FLIP,
    OPTION_EXA_PIXMAPS,
    OPTION_COLOR_TILING,
    OPTION_COLOR_TILING_2D,
#ifdef RENDER
    OPTION_RENDER_ACCEL,
    OPTION_SUBPIXEL_ORDER,
#endif
    OPTION_ACCELMETHOD,
    OPTION_EXA_VSYNC,
    OPTION_ZAPHOD_HEADS,
    OPTION_SWAPBUFFERS_WAIT,
    OPTION_DELETE_DP12,
    OPTION_DRI3,
    OPTION_DRI,
    OPTION_SHADOW_PRIMARY,
    OPTION_TEAR_FREE,
} RADEONOpts;


#if XF86_CRTC_VERSION >= 5
#define RADEON_PIXMAP_SHARING 1
#endif

#define RADEON_VSYNC_TIMEOUT	20000 /* Maximum wait for VSYNC (in usecs) */

/* Buffer are aligned on 4096 byte boundaries */
#define RADEON_GPU_PAGE_SIZE 4096
#define RADEON_BUFFER_ALIGN (RADEON_GPU_PAGE_SIZE - 1)


#define xFixedToFloat(f) (((float) (f)) / 65536)

#define RADEON_LOGLEVEL_DEBUG 4

/* for Xv, outputs */
#define MAKE_ATOM(a) MakeAtom(a, sizeof(a) - 1, TRUE)

/* Other macros */
#define RADEON_ARRAY_SIZE(x)  (sizeof(x)/sizeof(x[0]))
#define RADEON_ALIGN(x,bytes) (((x) + ((bytes) - 1)) & ~((bytes) - 1))
#define RADEONPTR(pScrn)      ((RADEONInfoPtr)(pScrn)->driverPrivate)

#define IS_RV100_VARIANT ((info->ChipFamily == CHIP_FAMILY_RV100)  ||  \
        (info->ChipFamily == CHIP_FAMILY_RV200)  ||  \
        (info->ChipFamily == CHIP_FAMILY_RS100)  ||  \
        (info->ChipFamily == CHIP_FAMILY_RS200)  ||  \
        (info->ChipFamily == CHIP_FAMILY_RV250)  ||  \
        (info->ChipFamily == CHIP_FAMILY_RV280)  ||  \
        (info->ChipFamily == CHIP_FAMILY_RS300))


#define IS_R300_VARIANT ((info->ChipFamily == CHIP_FAMILY_R300)  ||  \
        (info->ChipFamily == CHIP_FAMILY_RV350) ||  \
        (info->ChipFamily == CHIP_FAMILY_R350)  ||  \
        (info->ChipFamily == CHIP_FAMILY_RV380) ||  \
        (info->ChipFamily == CHIP_FAMILY_R420)  ||  \
        (info->ChipFamily == CHIP_FAMILY_RV410) ||  \
        (info->ChipFamily == CHIP_FAMILY_RS400) ||  \
        (info->ChipFamily == CHIP_FAMILY_RS480))

#define IS_AVIVO_VARIANT ((info->ChipFamily >= CHIP_FAMILY_RV515))

#define IS_DCE3_VARIANT ((info->ChipFamily >= CHIP_FAMILY_RV620))

#define IS_DCE32_VARIANT ((info->ChipFamily >= CHIP_FAMILY_RV730))

#define IS_DCE4_VARIANT ((info->ChipFamily >= CHIP_FAMILY_CEDAR))

#define IS_DCE41_VARIANT ((info->ChipFamily >= CHIP_FAMILY_PALM))

#define IS_DCE5_VARIANT ((info->ChipFamily >= CHIP_FAMILY_BARTS))

#define IS_EVERGREEN_3D (info->ChipFamily >= CHIP_FAMILY_CEDAR)

#define IS_R600_3D (info->ChipFamily >= CHIP_FAMILY_R600)

#define IS_R500_3D ((info->ChipFamily == CHIP_FAMILY_RV515)  ||  \
	(info->ChipFamily == CHIP_FAMILY_R520)   ||  \
	(info->ChipFamily == CHIP_FAMILY_RV530)  ||  \
	(info->ChipFamily == CHIP_FAMILY_R580)   ||  \
	(info->ChipFamily == CHIP_FAMILY_RV560)  ||  \
	(info->ChipFamily == CHIP_FAMILY_RV570))

/* RS6xx, RS740 are technically R4xx as well, but the
 * clipping hardware seems to follow the r3xx restrictions
 */
#define IS_R400_3D ((info->ChipFamily == CHIP_FAMILY_R420)  ||  \
	(info->ChipFamily == CHIP_FAMILY_RV410))

#define IS_R300_3D ((info->ChipFamily == CHIP_FAMILY_R300)  ||  \
	(info->ChipFamily == CHIP_FAMILY_RV350) ||  \
	(info->ChipFamily == CHIP_FAMILY_R350)  ||  \
	(info->ChipFamily == CHIP_FAMILY_RV380) ||  \
	(info->ChipFamily == CHIP_FAMILY_R420)  ||  \
	(info->ChipFamily == CHIP_FAMILY_RV410) ||  \
	(info->ChipFamily == CHIP_FAMILY_RS690) ||  \
	(info->ChipFamily == CHIP_FAMILY_RS600) ||  \
	(info->ChipFamily == CHIP_FAMILY_RS740) ||  \
	(info->ChipFamily == CHIP_FAMILY_RS400) ||  \
	(info->ChipFamily == CHIP_FAMILY_RS480))

#define IS_R200_3D ((info->ChipFamily == CHIP_FAMILY_RV250) || \
	(info->ChipFamily == CHIP_FAMILY_RV280) || \
	(info->ChipFamily == CHIP_FAMILY_RS300) || \
	(info->ChipFamily == CHIP_FAMILY_R200))

#define CURSOR_WIDTH	64
#define CURSOR_HEIGHT	64

#define CURSOR_WIDTH_CIK	128
#define CURSOR_HEIGHT_CIK	128


#ifdef USE_GLAMOR

struct radeon_pixmap {
	struct radeon_surface surface;

	uint_fast32_t gpu_read;
	uint_fast32_t gpu_write;

	struct radeon_bo *bo;

	uint32_t tiling_flags;

	/* GEM handle for glamor-only pixmaps shared via DRI3 */
	Bool handle_valid;
	uint32_t handle;
};

extern DevPrivateKeyRec glamor_pixmap_index;

static inline struct radeon_pixmap *radeon_get_pixmap_private(PixmapPtr pixmap)
{
	return dixGetPrivate(&pixmap->devPrivates, &glamor_pixmap_index);
}

static inline void radeon_set_pixmap_private(PixmapPtr pixmap, struct radeon_pixmap *priv)
{
	dixSetPrivate(&pixmap->devPrivates, &glamor_pixmap_index, priv);
}

#endif /* USE_GLAMOR */


struct radeon_exa_pixmap_priv {
    struct radeon_bo *bo;
    uint32_t tiling_flags;
    struct radeon_surface surface;
    Bool bo_mapped;
    Bool shared;
};

#define RADEON_2D_EXA_COPY 1
#define RADEON_2D_EXA_SOLID 2

struct radeon_2d_state {
    int op; //
    uint32_t dst_pitch_offset;
    uint32_t src_pitch_offset;
    uint32_t dp_gui_master_cntl;
    uint32_t dp_cntl;
    uint32_t dp_write_mask;
    uint32_t dp_brush_frgd_clr;
    uint32_t dp_brush_bkgd_clr;
    uint32_t dp_src_frgd_clr;
    uint32_t dp_src_bkgd_clr;
    uint32_t default_sc_bottom_right;
    uint32_t dst_domain;
    struct radeon_bo *dst_bo;
    struct radeon_bo *src_bo;
};
    
#define DMA_BO_FREE_TIME 1000

struct radeon_dma_bo {
    struct radeon_dma_bo *next, *prev;
    struct radeon_bo  *bo;
    int expire_counter;
};

struct r600_accel_object {
    uint32_t pitch;
    uint32_t width;
    uint32_t height;
    int bpp;
    uint32_t domain;
    struct radeon_bo *bo;
    uint32_t tiling_flags;
    struct radeon_surface *surface;
};

struct radeon_vbo_object {
    int               vb_offset;
    int               vb_total;
    uint32_t          vb_size;
    uint32_t          vb_op_vert_size;
    int32_t           vb_start_op;
    struct radeon_bo *vb_bo;
    unsigned          verts_per_op;
};

struct radeon_accel_state {

				/* Saved values for ScreenToScreenCopy */
    int               xdir;
    int               ydir;

    /* render accel */
    unsigned short    texW[2];
    unsigned short    texH[2];
    Bool              XInited3D; /* X itself has the 3D context */
    int               num_gb_pipes;
    Bool              has_tcl;
    Bool              allowHWDFS;

    /* EXA */
    ExaDriverPtr      exa;
    int               exaSyncMarker;
    int               exaMarkerSynced;
    int               engineMode;
#define EXA_ENGINEMODE_UNKNOWN 0
#define EXA_ENGINEMODE_2D      1
#define EXA_ENGINEMODE_3D      2

    int               composite_op;
    PicturePtr        dst_pic;
    PicturePtr        msk_pic;
    PicturePtr        src_pic;
    PixmapPtr         dst_pix;
    PixmapPtr         msk_pix;
    PixmapPtr         src_pix;
    Bool              is_transform[2];
    PictTransform     *transform[2];
    /* Whether we are tiling horizontally and vertically */
    Bool              need_src_tile_x;
    Bool              need_src_tile_y;
    /* Size of tiles ... set to 65536x65536 if not tiling in that direction */
    Bool              src_tile_width;
    Bool              src_tile_height;
    uint32_t          *draw_header;
    unsigned          vtx_count;
    unsigned          num_vtx;
    Bool              vsync;

    struct radeon_vbo_object vbo;
    struct radeon_vbo_object cbuf;

    /* where to discard IB from if we cancel operation */
    uint32_t          ib_reset_op;
    struct radeon_dma_bo bo_free;
    struct radeon_dma_bo bo_wait;
    struct radeon_dma_bo bo_reserved;
    Bool use_vbos;
    void (*finish_op)(ScrnInfoPtr, int);
    // shader storage
    struct radeon_bo  *shaders_bo;
    uint32_t          solid_vs_offset;
    uint32_t          solid_ps_offset;
    uint32_t          copy_vs_offset;
    uint32_t          copy_ps_offset;
    uint32_t          comp_vs_offset;
    uint32_t          comp_ps_offset;
    uint32_t          xv_vs_offset;
    uint32_t          xv_ps_offset;
    // shader consts
    uint32_t          solid_vs_const_offset;
    uint32_t          solid_ps_const_offset;
    uint32_t          copy_vs_const_offset;
    uint32_t          copy_ps_const_offset;
    uint32_t          comp_vs_const_offset;
    uint32_t          comp_ps_const_offset;
    uint32_t          comp_mask_ps_const_offset;
    uint32_t          xv_vs_const_offset;
    uint32_t          xv_ps_const_offset;

    //size/addr stuff
    struct r600_accel_object src_obj[2];
    struct r600_accel_object dst_obj;
    uint32_t          src_size[2];
    uint32_t          dst_size;

    uint32_t          vs_size;
    uint64_t          vs_mc_addr;
    uint32_t          ps_size;
    uint64_t          ps_mc_addr;

    // solid/copy
    void *copy_area;
    struct radeon_bo  *copy_area_bo;
    Bool              same_surface;
    int               rop;
    uint32_t          planemask;
    uint32_t          fg;

    // composite
    Bool              component_alpha;
    Bool              src_alpha;
    // vline
    xf86CrtcPtr       vline_crtc;
    int               vline_y1;
    int               vline_y2;

    Bool              force;
};

typedef struct {
    EntityInfoPtr     pEnt;
    pciVideoPtr       PciInfo;
    int               Chipset;
    RADEONChipFamily  ChipFamily;

    Bool              (*CloseScreen)(CLOSE_SCREEN_ARGS_DECL);

    void              (*BlockHandler)(BLOCKHANDLER_ARGS_DECL);

    void              (*CreateFence) (ScreenPtr pScreen, struct _SyncFence *pFence,
				      Bool initially_triggered);

    int               pix24bpp;         /* Depth of pixmap for 24bpp fb      */
    Bool              dac6bits;         /* Use 6 bit DAC?                    */

    int               pixel_bytes;

    Bool              directRenderingEnabled;
    struct radeon_dri2  dri2;

    /* accel */
    Bool              RenderAccel; /* Render */
    Bool              allowColorTiling;
    Bool              allowColorTiling2D;
    uint_fast32_t     gpu_flushed;
    uint_fast32_t     gpu_synced;
    struct radeon_accel_state *accel_state;
    PixmapPtr         fbcon_pixmap;
    Bool              accelOn;
    Bool              use_glamor;
    Bool              shadow_primary;
    Bool              tear_free;
    Bool	      exa_pixmaps;
    Bool              exa_force_create;
    XF86ModReqInfo    exaReq;
    Bool              is_fast_fb; /* use direct mapping for fast fb access */

    unsigned int xv_max_width;
    unsigned int xv_max_height;

    /* general */
    OptionInfoPtr     Options;

    DisplayModePtr currentMode;

    CreateScreenResourcesProcPtr CreateScreenResources;
#if GET_ABI_MAJOR(ABI_VIDEODRV_VERSION) >= 10
    CreateWindowProcPtr CreateWindow;
#endif

    Bool              IsSecondary;

    Bool              r600_shadow_fb;
    void *fb_shadow;

    void (*reemit_current2d)(ScrnInfoPtr pScrn, int op); // emit the current 2D state into the IB 
    struct radeon_2d_state state_2d;
    struct radeon_bo *front_bo;
    struct radeon_bo_manager *bufmgr;
    struct radeon_cs_manager *csm;
    struct radeon_cs *cs;

    struct radeon_bo *cursor_bo[32];
    uint64_t vram_size;
    uint64_t gart_size;
    drmmode_rec drmmode;
    Bool drmmode_inited;
    /* r6xx+ tile config */
    Bool have_tiling_info;
    uint32_t tile_config;
    int group_bytes;
    int num_channels;
    int num_banks;
    int r7xx_bank_op;
    struct radeon_surface_manager *surf_man;
    struct radeon_surface front_surface;

    /* Xv bicubic filtering */
    struct radeon_bo *bicubic_bo;

    /* kms pageflipping */
    Bool allowPageFlip;

    /* Perform vsync'ed SwapBuffers? */
    Bool swapBuffersWait;

    /* cursor size */
    int cursor_w;
    int cursor_h;

    /* If bit n of this field is set, xf86_config->crtc[n] currently can't
     * use the HW cursor
     */
    unsigned hwcursor_disabled;

#ifdef USE_GLAMOR
    struct {
	CreateGCProcPtr SavedCreateGC;
	RegionPtr (*SavedCopyArea)(DrawablePtr, DrawablePtr, GCPtr, int, int,
				   int, int, int, int);
	void (*SavedPolyFillRect)(DrawablePtr, GCPtr, int, xRectangle*);
	CloseScreenProcPtr SavedCloseScreen;
	GetImageProcPtr SavedGetImage;
	GetSpansProcPtr SavedGetSpans;
	CreatePixmapProcPtr SavedCreatePixmap;
	DestroyPixmapProcPtr SavedDestroyPixmap;
	CopyWindowProcPtr SavedCopyWindow;
	ChangeWindowAttributesProcPtr SavedChangeWindowAttributes;
	BitmapToRegionProcPtr SavedBitmapToRegion;
#ifdef RENDER
	CompositeProcPtr SavedComposite;
	TrianglesProcPtr SavedTriangles;
	GlyphsProcPtr SavedGlyphs;
	TrapezoidsProcPtr SavedTrapezoids;
	AddTrapsProcPtr SavedAddTraps;
	UnrealizeGlyphProcPtr SavedUnrealizeGlyph;
#endif
#ifdef RADEON_PIXMAP_SHARING
	SharePixmapBackingProcPtr SavedSharePixmapBacking;
	SetSharedPixmapBackingProcPtr SavedSetSharedPixmapBacking;
#endif
    } glamor;
#endif /* USE_GLAMOR */
} RADEONInfoRec, *RADEONInfoPtr;

/* radeon_accel.c */
extern Bool RADEONAccelInit(ScreenPtr pScreen);
extern void RADEONEngineInit(ScrnInfoPtr pScrn);
extern void  RADEONCopySwap(uint8_t *dst, uint8_t *src, unsigned int size, int swap);
extern void RADEONInit3DEngine(ScrnInfoPtr pScrn);
extern int radeon_cs_space_remaining(ScrnInfoPtr pScrn);

/* radeon_commonfuncs.c */
extern void RADEONWaitForVLine(ScrnInfoPtr pScrn, PixmapPtr pPix,
			       xf86CrtcPtr crtc, int start, int stop);


/* radeon_exa.c */
extern unsigned eg_tile_split(unsigned tile_split);
extern Bool radeon_transform_is_affine_or_scaled(PictTransformPtr t);

/* radeon_exa_funcs.c */
extern Bool RADEONDrawInit(ScreenPtr pScreen);
extern Bool R600DrawInit(ScreenPtr pScreen);
extern Bool R600LoadShaders(ScrnInfoPtr pScrn);
extern Bool EVERGREENDrawInit(ScreenPtr pScreen);

/* radeon_exa.c */
extern Bool RADEONGetDatatypeBpp(int bpp, uint32_t *type);
extern Bool RADEONGetPixmapOffsetPitch(PixmapPtr pPix,
				       uint32_t *pitch_offset);

/* radeon_dri3.c */
Bool radeon_dri3_screen_init(ScreenPtr screen);

/* radeon_kms.c */
void radeon_scanout_update_handler(xf86CrtcPtr crtc, uint32_t frame,
				   uint64_t usec, void *event_data);

/* radeon_present.c */
Bool radeon_present_screen_init(ScreenPtr screen);

/* radeon_sync.c */
extern Bool radeon_sync_init(ScreenPtr screen);
extern void radeon_sync_close(ScreenPtr screen);

/* radeon_video.c */
extern void RADEONInitVideo(ScreenPtr pScreen);
extern void RADEONResetVideo(ScrnInfoPtr pScrn);
extern Bool radeon_load_bicubic_texture(ScrnInfoPtr pScrn);
extern xf86CrtcPtr radeon_pick_best_crtc(ScrnInfoPtr pScrn,
					 Bool consider_disabled,
					 int x1, int x2, int y1, int y2);

extern void radeon_cs_flush_indirect(ScrnInfoPtr pScrn);
extern void radeon_ddx_cs_start(ScrnInfoPtr pScrn,
				int num, const char *file,
				const char *func, int line);
void radeon_kms_update_vram_limit(ScrnInfoPtr pScrn, uint32_t new_fb_size);
extern RADEONEntPtr RADEONEntPriv(ScrnInfoPtr pScrn);

drmVBlankSeqType radeon_populate_vbl_request_type(xf86CrtcPtr crtc);

static inline struct radeon_surface *radeon_get_pixmap_surface(PixmapPtr pPix)
{
#ifdef USE_GLAMOR
    RADEONInfoPtr info = RADEONPTR(xf86ScreenToScrn(pPix->drawable.pScreen));

    if (info->use_glamor) {
	struct radeon_pixmap *priv;
	priv = radeon_get_pixmap_private(pPix);
	return priv ? &priv->surface : NULL;
    } else
#endif
    {
	struct radeon_exa_pixmap_priv *driver_priv;
	driver_priv = exaGetPixmapDriverPrivate(pPix);
	return &driver_priv->surface;
    }

    return NULL;
}

uint32_t radeon_get_pixmap_tiling(PixmapPtr pPix);

static inline void radeon_set_pixmap_bo(PixmapPtr pPix, struct radeon_bo *bo)
{
#ifdef USE_GLAMOR
    RADEONInfoPtr info = RADEONPTR(xf86ScreenToScrn(pPix->drawable.pScreen));

    if (info->use_glamor) {
	struct radeon_pixmap *priv;

	priv = radeon_get_pixmap_private(pPix);
	if (priv == NULL && bo == NULL)
	    return;

	if (priv) {
	    if (priv->bo == bo)
		return;

	    if (priv->bo)
		radeon_bo_unref(priv->bo);

	    if (!bo) {
		free(priv);
		priv = NULL;
	    }
	}

	if (bo) {
	    uint32_t pitch;

	    if (!priv) {
		priv = calloc(1, sizeof (struct radeon_pixmap));
		if (!priv)
		    goto out;
	    }

	    radeon_bo_ref(bo);
	    priv->bo = bo;

	    radeon_bo_get_tiling(bo, &priv->tiling_flags, &pitch);
	}
out:
	radeon_set_pixmap_private(pPix, priv);
    } else
#endif /* USE_GLAMOR */
    {
	struct radeon_exa_pixmap_priv *driver_priv;

	driver_priv = exaGetPixmapDriverPrivate(pPix);
	if (driver_priv) {
	    uint32_t pitch;

	    if (driver_priv->bo)
		radeon_bo_unref(driver_priv->bo);

	    radeon_bo_ref(bo);
	    driver_priv->bo = bo;

	    radeon_bo_get_tiling(bo, &driver_priv->tiling_flags, &pitch);
	}
    }
}

static inline struct radeon_bo *radeon_get_pixmap_bo(PixmapPtr pPix)
{
#ifdef USE_GLAMOR
    RADEONInfoPtr info = RADEONPTR(xf86ScreenToScrn(pPix->drawable.pScreen));

    if (info->use_glamor) {
	struct radeon_pixmap *priv;
	priv = radeon_get_pixmap_private(pPix);
	return priv ? priv->bo : NULL;
    } else
#endif
    {
	struct radeon_exa_pixmap_priv *driver_priv;
	driver_priv = exaGetPixmapDriverPrivate(pPix);
	return driver_priv ? driver_priv->bo : NULL;
    }

    return NULL;
}

static inline Bool radeon_get_pixmap_shared(PixmapPtr pPix)
{
#ifdef USE_GLAMOR
    RADEONInfoPtr info = RADEONPTR(xf86ScreenToScrn(pPix->drawable.pScreen));

    if (info->use_glamor) {
        ErrorF("glamor sharing todo\n");
	return FALSE;
    } else
#endif
    {
	struct radeon_exa_pixmap_priv *driver_priv;
	driver_priv = exaGetPixmapDriverPrivate(pPix);
	return driver_priv->shared;
    }
    return FALSE;
}

#define CP_PACKET0(reg, n)						\
	(RADEON_CP_PACKET0 | ((n) << 16) | ((reg) >> 2))
#define CP_PACKET1(reg0, reg1)						\
	(RADEON_CP_PACKET1 | (((reg1) >> 2) << 11) | ((reg0) >> 2))
#define CP_PACKET2()							\
	(RADEON_CP_PACKET2)
#define CP_PACKET3(pkt, n)						\
	(RADEON_CP_PACKET3 | (pkt) | ((n) << 16))


#define RADEON_VERBOSE	0

#define BEGIN_RING(n) do {						\
    if (RADEON_VERBOSE) {						\
	xf86DrvMsg(pScrn->scrnIndex, X_INFO,				\
		   "BEGIN_RING(%d) in %s\n", (unsigned int)n, __FUNCTION__);\
    }									\
    radeon_ddx_cs_start(pScrn, n, __FILE__, __func__, __LINE__);   \
} while (0)

#define ADVANCE_RING() do {						\
    radeon_cs_end(info->cs, __FILE__, __func__, __LINE__); \
  } while (0)

#define OUT_RING(x) do {						\
    if (RADEON_VERBOSE) {						\
	xf86DrvMsg(pScrn->scrnIndex, X_INFO,				\
		   "   OUT_RING(0x%08x)\n", (unsigned int)(x));		\
    }									\
    radeon_cs_write_dword(info->cs, (x));		\
} while (0)

#define OUT_RING_REG(reg, val)						\
do {									\
    OUT_RING(CP_PACKET0(reg, 0));					\
    OUT_RING(val);							\
} while (0)

#define OUT_RING_RELOC(x, read_domains, write_domain)			\
  do {									\
	int _ret; \
    _ret = radeon_cs_write_reloc(info->cs, x, read_domains, write_domain, 0); \
	if (_ret) ErrorF("reloc emit failure %d\n", _ret); \
  } while(0)


#define FLUSH_RING()							\
do {									\
    if (RADEON_VERBOSE)							\
	xf86DrvMsg(pScrn->scrnIndex, X_INFO,				\
		   "FLUSH_RING in %s\n", __FUNCTION__);			\
    radeon_cs_flush_indirect(pScrn); 				\
} while (0)

#define CS_FULL(cs) ((cs)->cdw > 15 * 1024)

#define RADEON_SWITCH_TO_2D()						\
do {									\
	uint32_t flush = 0;                                             \
	switch (info->accel_state->engineMode) {			\
	case EXA_ENGINEMODE_UNKNOWN:					\
	    flush = 1;                                                  \
	    break;							\
	case EXA_ENGINEMODE_3D:						\
	    flush = CS_FULL(info->cs);			\
	    break;							\
	case EXA_ENGINEMODE_2D:						\
	    flush = CS_FULL(info->cs);			\
	    break;							\
	}								\
	if (flush) {							\
	    radeon_cs_flush_indirect(pScrn);			\
	}								\
        info->accel_state->engineMode = EXA_ENGINEMODE_2D;              \
} while (0);

#define RADEON_SWITCH_TO_3D()						\
do {									\
	uint32_t flush = 0;						\
	switch (info->accel_state->engineMode) {			\
	case EXA_ENGINEMODE_UNKNOWN:					\
	    flush = 1;                                                  \
	    break;							\
	case EXA_ENGINEMODE_2D:						\
	    flush = CS_FULL(info->cs);	 		\
	    break;							\
	case EXA_ENGINEMODE_3D:						\
	    flush = CS_FULL(info->cs);			\
	    break;							\
	}								\
	if (flush) {							\
	    radeon_cs_flush_indirect(pScrn);			\
	}                                                               \
	if (!info->accel_state->XInited3D)				\
	    RADEONInit3DEngine(pScrn);                                  \
        info->accel_state->engineMode = EXA_ENGINEMODE_3D;              \
} while (0);

				/* Memory mapped register access macros */

#define BEGIN_ACCEL_RELOC(n, r) do {		\
	int _nqw = (n) + (r);	\
	BEGIN_RING(2*_nqw);			\
    } while (0)

#define EMIT_OFFSET(reg, value, pPix, rd, wd) do {		\
    driver_priv = exaGetPixmapDriverPrivate(pPix);		\
    OUT_RING_REG((reg), (value));				\
    OUT_RING_RELOC(driver_priv->bo, (rd), (wd));			\
    } while(0)

#define EMIT_READ_OFFSET(reg, value, pPix) EMIT_OFFSET(reg, value, pPix, (RADEON_GEM_DOMAIN_VRAM | RADEON_GEM_DOMAIN_GTT), 0)
#define EMIT_WRITE_OFFSET(reg, value, pPix) EMIT_OFFSET(reg, value, pPix, 0, RADEON_GEM_DOMAIN_VRAM)

#define OUT_TEXTURE_REG(reg, offset, bo) do {   \
    OUT_RING_REG((reg), (offset));                                   \
    OUT_RING_RELOC((bo), RADEON_GEM_DOMAIN_VRAM | RADEON_GEM_DOMAIN_GTT, 0); \
  } while(0)

#define EMIT_COLORPITCH(reg, value, pPix) do {			\
    driver_priv = exaGetPixmapDriverPrivate(pPix);			\
    OUT_RING_REG((reg), value);					\
    OUT_RING_RELOC(driver_priv->bo, 0, RADEON_GEM_DOMAIN_VRAM);		\
} while(0)

static __inline__ void RADEON_SYNC(RADEONInfoPtr info, ScrnInfoPtr pScrn)
{
    if (pScrn->pScreen)
	exaWaitSync(pScrn->pScreen);
}

enum {
    RADEON_CREATE_PIXMAP_SCANOUT		= 0x02000000,
    RADEON_CREATE_PIXMAP_DRI2			= 0x04000000,
    RADEON_CREATE_PIXMAP_TILING_MICRO_SQUARE	= 0x08000000,
    RADEON_CREATE_PIXMAP_TILING_MACRO		= 0x10000000,
    RADEON_CREATE_PIXMAP_TILING_MICRO		= 0x20000000,
    RADEON_CREATE_PIXMAP_DEPTH			= 0x40000000, /* for r200 */
    RADEON_CREATE_PIXMAP_SZBUFFER		= 0x80000000, /* for eg */
};

#define RADEON_CREATE_PIXMAP_TILING_FLAGS	\
    (RADEON_CREATE_PIXMAP_TILING_MICRO_SQUARE |	\
     RADEON_CREATE_PIXMAP_TILING_MACRO |	\
     RADEON_CREATE_PIXMAP_TILING_MICRO |	\
     RADEON_CREATE_PIXMAP_DEPTH |		\
     RADEON_CREATE_PIXMAP_SZBUFFER)


/* Compute log base 2 of val. */
static __inline__ int
RADEONLog2(int val)
{
	int bits;
#if (defined __i386__ || defined __x86_64__) && (defined __GNUC__)
	__asm volatile("bsrl	%1, %0"
		: "=r" (bits)
		: "c" (val)
	);
	return bits;
#else
	for (bits = 0; val != 0; val >>= 1, ++bits)
		;
	return bits - 1;
#endif
}

#define RADEON_TILING_MASK				0xff
#define RADEON_TILING_LINEAR				0x0

#endif /* _RADEON_H_ */
@


1.15
log
@Update to xf86-video-ati 7.6.1. ok jsg@@
@
text
@d69 4
d164 4
a274 1
#if HAS_DEVPRIVATEKEYREC
a275 3
#else
extern int glamor_pixmap_index;
#endif
a278 1
#if HAS_DEVPRIVATEKEYREC
a279 3
#else
	return dixLookupPrivate(&pixmap->devPrivates, &glamor_pixmap_index);
#endif
d542 5
d569 4
d608 1
a608 1
void radeon_scanout_update_handler(ScrnInfoPtr scrn, uint32_t frame,
a633 4

#if XF86_CRTC_VERSION >= 5
#define RADEON_PIXMAP_SHARING 1
#endif
@


1.14
log
@Update to xf86-video-ati 7.5.0. Discussed with jsg@@
@
text
@a53 2
#include "radeon_glamor.h"

d93 2
d151 6
a156 1
    OPTION_SWAPBUFFERS_WAIT
d249 41
d461 3
a470 1
    Bool              accelDFS;
d476 2
d479 1
d482 2
d498 3
a502 1
    Bool              IsPrimary;
d541 25
d595 14
d727 1
a727 1
	return driver_priv->bo;
d883 1
@


1.13
log
@Update to xf86-video-ati 7.3.0. Tested by jsg@@ ajacoutot@@.
@
text
@d138 1
a138 1
    OPTION_NOACCEL,
d789 6
a794 6
    RADEON_CREATE_PIXMAP_DRI2 = 0x08000000,
    RADEON_CREATE_PIXMAP_TILING_MACRO = 0x10000000,
    RADEON_CREATE_PIXMAP_TILING_MICRO = 0x20000000,
    RADEON_CREATE_PIXMAP_DEPTH = 0x40000000, /* for r200 */
    RADEON_CREATE_PIXMAP_SZBUFFER = 0x80000000, /* for eg */
    RADEON_CREATE_PIXMAP_TILING_MICRO_SQUARE = 0x8000000,
d797 7
d823 2
@


1.12
log
@Update to xf86-video-ati 7.2.0, requested by jsg@@

It fixes an endianess problem with kms and the in tree x86-video-ati
among other things.
It has been tested on various i386/amd64/sparc64/macppc machines
on a range of hardware from r100->northern islands.
@
text
@d527 1
a527 1
void radeon_kms_update_vram_limit(ScrnInfoPtr pScrn, int new_fb_size);
@


1.11
log
@Update to xf86-video-ati 6.14.6. Tested by mpi@@, brad, eric@@, ajacoutot@@.
@
text
@a47 1
#include "xf86fbman.h"
a51 1
#ifdef USE_EXA
d53 2
a54 4
#endif
#ifdef USE_XAA
#include "xaa.h"
#endif
a56 1
#include "vbe.h"
a65 1
#include "radeon_tv.h"
a67 4
#ifdef XF86DRI
#define _XF86DRI_SERVER_
#include "dri.h"
#include "GL/glxint.h"
a74 1
#endif
a78 1
#ifdef XF86DRM_MODE
a83 3
#else
#include "radeon_dummy_bufmgr.h"
#endif
a136 5
#ifndef HAVE_XF86MODEBANDWIDTH
extern unsigned int xf86ModeBandwidth(DisplayModePtr mode, int depth);
#define MODE_BANDWIDTH MODE_BAD
#endif

a139 13
    OPTION_DAC_6BIT,
    OPTION_DAC_8BIT,
#ifdef XF86DRI
    OPTION_BUS_TYPE,
    OPTION_CP_PIO,
    OPTION_USEC_TIMEOUT,
    OPTION_AGP_MODE,
    OPTION_AGP_FW,
    OPTION_GART_SIZE,
    OPTION_GART_SIZE_OLD,
    OPTION_RING_SIZE,
    OPTION_BUFFER_SIZE,
    OPTION_DEPTH_MOVE,
a140 7
    OPTION_NO_BACKBUFFER,
    OPTION_XV_DMA,
    OPTION_FBTEX_PERCENT,
    OPTION_DEPTH_BITS,
    OPTION_PCIAPER_SIZE,
#ifdef USE_EXA
    OPTION_ACCEL_DFS,
a141 7
#endif
#endif
    OPTION_IGNORE_EDID,
    OPTION_CUSTOM_EDID,
    OPTION_DISP_PRIORITY,
    OPTION_PANEL_SIZE,
    OPTION_MIN_DOTCLOCK,
a143 11
#ifdef XvExtension
    OPTION_VIDEO_KEY,
    OPTION_RAGE_THEATRE_CRYSTAL,
    OPTION_RAGE_THEATRE_TUNER_PORT,
    OPTION_RAGE_THEATRE_COMPOSITE_PORT,
    OPTION_RAGE_THEATRE_SVIDEO_PORT,
    OPTION_TUNER_TYPE,
    OPTION_RAGE_THEATRE_MICROC_PATH,
    OPTION_RAGE_THEATRE_MICROC_TYPE,
    OPTION_SCALER_WIDTH,
#endif
a147 6
    OPTION_SHOWCACHE,
    OPTION_CLOCK_GATING,
    OPTION_BIOS_HOTKEYS,
    OPTION_VGA_ACCESS,
    OPTION_REVERSE_DDC,
    OPTION_LVDS_PROBE_PLL,
a148 13
    OPTION_CONNECTORTABLE,
    OPTION_DRI,
    OPTION_DEFAULT_CONNECTOR_TABLE,
#if defined(__powerpc__)
    OPTION_MAC_MODEL,
#endif
    OPTION_DEFAULT_TMDS_PLL,
    OPTION_TVDAC_LOAD_DETECT,
    OPTION_FORCE_TVOUT,
    OPTION_TVSTD,
    OPTION_IGNORE_LID_STATUS,
    OPTION_DEFAULT_TVDAC_ADJ,
    OPTION_INT10,
a149 5
    OPTION_ATOM_TVOUT,
    OPTION_R4XX_ATOM,
    OPTION_FORCE_LOW_POWER,
    OPTION_DYNAMIC_PM,
    OPTION_NEW_PLL,
a154 3
#define RADEON_IDLE_RETRY      16 /* Fall out of idle loops after this count */
#define RADEON_TIMEOUT    2000000 /* Fall out of wait loops after this count */

d160 1
a160 5
#define RADEON_VBIOS_SIZE 0x00010000
#define RADEON_USE_RMX 0x80000000 /* mode flag for using RMX
				   * Need to comfirm this is not used
				   * for something else.
				   */
a173 58
typedef struct {
    int    revision;
    uint16_t rr1_offset;
    uint16_t rr2_offset;
    uint16_t dyn_clk_offset;
    uint16_t pll_offset;
    uint16_t mem_config_offset;
    uint16_t mem_reset_offset;
    uint16_t short_mem_offset;
    uint16_t rr3_offset;
    uint16_t rr4_offset;
} RADEONBIOSInitTable;

#define RADEON_PLL_USE_BIOS_DIVS   (1 << 0)
#define RADEON_PLL_NO_ODD_POST_DIV (1 << 1)
#define RADEON_PLL_USE_REF_DIV     (1 << 2)
#define RADEON_PLL_LEGACY          (1 << 3)
#define RADEON_PLL_PREFER_LOW_REF_DIV   (1 << 4)
#define RADEON_PLL_PREFER_HIGH_REF_DIV  (1 << 5)
#define RADEON_PLL_PREFER_LOW_FB_DIV    (1 << 6)
#define RADEON_PLL_PREFER_HIGH_FB_DIV   (1 << 7)
#define RADEON_PLL_PREFER_LOW_POST_DIV  (1 << 8)
#define RADEON_PLL_PREFER_HIGH_POST_DIV (1 << 9)
#define RADEON_PLL_USE_FRAC_FB_DIV      (1 << 10)
#define RADEON_PLL_PREFER_CLOSEST_LOWER (1 << 11)
#define RADEON_PLL_USE_POST_DIV    (1 << 12)

typedef struct {
    uint32_t          reference_freq;
    uint32_t          reference_div;
    uint32_t          post_div;
    uint32_t          pll_in_min;
    uint32_t          pll_in_max;
    uint32_t          pll_out_min;
    uint32_t          pll_out_max;
    uint16_t          xclk;

    uint32_t          min_ref_div;
    uint32_t          max_ref_div;
    uint32_t          min_post_div;
    uint32_t          max_post_div;
    uint32_t          min_feedback_div;
    uint32_t          max_feedback_div;
    uint32_t          min_frac_feedback_div;
    uint32_t          max_frac_feedback_div;
    uint32_t          best_vco;
} RADEONPLLRec, *RADEONPLLPtr;

typedef struct {
    int               bitsPerPixel;
    int               depth;
    int               displayWidth;
    int               displayHeight;
    int               pixel_code;
    int               pixel_bytes;
    DisplayModePtr    mode;
} RADEONFBLayout;

d215 3
d219 1
a219 4
	(info->ChipFamily == CHIP_FAMILY_RV410) ||  \
	(info->ChipFamily == CHIP_FAMILY_RS690) ||  \
	(info->ChipFamily == CHIP_FAMILY_RS600) ||  \
	(info->ChipFamily == CHIP_FAMILY_RS740))
d238 2
a239 60
/*
 * Errata workarounds
 */
typedef enum {
       CHIP_ERRATA_R300_CG             = 0x00000001,
       CHIP_ERRATA_PLL_DUMMYREADS      = 0x00000002,
       CHIP_ERRATA_PLL_DELAY           = 0x00000004
} RADEONErrata;

typedef enum {
    RADEON_DVOCHIP_NONE,
    RADEON_SIL_164,
    RADEON_SIL_1178
} RADEONExtTMDSChip;

#if defined(__powerpc__)
typedef enum {
    RADEON_MAC_NONE,
    RADEON_MAC_IBOOK,
    RADEON_MAC_POWERBOOK_EXTERNAL,
    RADEON_MAC_POWERBOOK_INTERNAL,
    RADEON_MAC_POWERBOOK_VGA,
    RADEON_MAC_MINI_EXTERNAL,
    RADEON_MAC_MINI_INTERNAL,
    RADEON_MAC_IMAC_G5_ISIGHT,
    RADEON_MAC_EMAC,
    RADEON_MAC_SAM440EP
} RADEONMacModel;
#endif

typedef enum {
	CARD_PCI,
	CARD_AGP,
	CARD_PCIE
} RADEONCardType;

typedef enum {
	POWER_DEFAULT,
	POWER_LOW,
	POWER_HIGH
} RADEONPMType;

typedef struct {
    RADEONPMType type;
    uint32_t sclk;
    uint32_t mclk;
    uint32_t pcie_lanes;
    uint32_t flags;
} RADEONPowerMode;

typedef struct {
    /* power modes */
    int num_modes;
    int current_mode;
    RADEONPowerMode mode[3];

    Bool     clock_gating_enabled;
    Bool     dynamic_mode_enabled;
    Bool     force_low_power_enabled;
} RADEONPowerManagement;
d241 2
a242 1
typedef struct _atomBiosHandle *atomBiosHandlePtr;
a246 1
#ifdef XF86DRM_MODE
a247 1
#endif
d249 1
d267 1
a271 137
#ifdef XF86DRI
struct radeon_cp {
    Bool              CPRuns;           /* CP is running */
    Bool              CPInUse;          /* CP has been used by X server */
    Bool              CPStarted;        /* CP has started */
    int               CPMode;           /* CP mode that server/clients use */
    int               CPFifoSize;       /* Size of the CP command FIFO */
    int               CPusecTimeout;    /* CP timeout in usecs */
    Bool              needCacheFlush;

    /* CP accleration */
    drmBufPtr         indirectBuffer;
    int               indirectStart;

    /* Debugging info for BEGIN_RING/ADVANCE_RING pairs. */
    int               dma_begin_count;
    char              *dma_debug_func;
    int               dma_debug_lineno;

    };

typedef struct {
    /* Nothing here yet */
    int dummy;
} RADEONConfigPrivRec, *RADEONConfigPrivPtr;

typedef struct {
    /* Nothing here yet */
    int dummy;
} RADEONDRIContextRec, *RADEONDRIContextPtr;

struct radeon_dri {
    Bool              noBackBuffer;

    Bool              newMemoryMap;
    drmVersionPtr     pLibDRMVersion;
    drmVersionPtr     pKernelDRMVersion;
    DRIInfoPtr        pDRIInfo;
    int               drmFD;
    int               numVisualConfigs;
    __GLXvisualConfig *pVisualConfigs;
    RADEONConfigPrivPtr pVisualConfigsPriv;
    Bool             (*DRICloseScreen)(CLOSE_SCREEN_ARGS_DECL);

    drm_handle_t      fbHandle;

    drmSize           pciSize;
    drm_handle_t      pciMemHandle;
    unsigned char     *PCI;             /* Map */

    Bool              depthMoves;       /* Enable depth moves -- slow! */
    Bool              allowPageFlip;    /* Enable 3d page flipping */
#ifdef DAMAGE
    DamagePtr         pDamage;
    RegionRec         driRegion;
#endif
    Bool              have3DWindows;    /* Are there any 3d clients? */

    int               pciAperSize;
    drmSize           gartSize;
    drm_handle_t      agpMemHandle;     /* Handle from drmAgpAlloc */
    unsigned long     gartOffset;
    unsigned char     *AGP;             /* Map */
    int               agpMode;

    uint32_t          pciCommand;

    /* CP ring buffer data */
    unsigned long     ringStart;        /* Offset into GART space */
    drm_handle_t      ringHandle;       /* Handle from drmAddMap */
    drmSize           ringMapSize;      /* Size of map */
    int               ringSize;         /* Size of ring (in MB) */
    drmAddress        ring;             /* Map */
    int               ringSizeLog2QW;

    unsigned long     ringReadOffset;   /* Offset into GART space */
    drm_handle_t      ringReadPtrHandle; /* Handle from drmAddMap */
    drmSize           ringReadMapSize;  /* Size of map */
    drmAddress        ringReadPtr;      /* Map */

    /* CP vertex/indirect buffer data */
    unsigned long     bufStart;         /* Offset into GART space */
    drm_handle_t      bufHandle;        /* Handle from drmAddMap */
    drmSize           bufMapSize;       /* Size of map */
    int               bufSize;          /* Size of buffers (in MB) */
    drmAddress        buf;              /* Map */
    int               bufNumBufs;       /* Number of buffers */
    drmBufMapPtr      buffers;          /* Buffer map */

    /* CP GART Texture data */
    unsigned long     gartTexStart;      /* Offset into GART space */
    drm_handle_t      gartTexHandle;     /* Handle from drmAddMap */
    drmSize           gartTexMapSize;    /* Size of map */
    int               gartTexSize;       /* Size of GART tex space (in MB) */
    drmAddress        gartTex;           /* Map */
    int               log2GARTTexGran;

    /* DRI screen private data */
    int               fbX;
    int               fbY;
    int               backX;
    int               backY;
    int               depthX;
    int               depthY;

    int               frontOffset;
    int               frontPitch;
    int               backOffset;
    int               backPitch;
    int               depthOffset;
    int               depthPitch;
    int               depthBits;
    int               textureOffset;
    int               textureSize;
    int               log2TexGran;

    int               pciGartSize;
    uint32_t          pciGartOffset;
    void              *pciGartBackup;

    int               irq;

#ifdef USE_XAA
    uint32_t          frontPitchOffset;
    uint32_t          backPitchOffset;
    uint32_t          depthPitchOffset;

    /* offscreen memory management */
    int               backLines;
    FBAreaPtr         backArea;
    int               depthTexLines;
    FBAreaPtr         depthTexArea;
#endif

};
#endif

a283 1
    uint32_t offset;
a287 1
#if defined(XF86DRM_MODE)
a288 1
#endif
a292 1
    uint64_t          vb_mc_addr;
a293 1
    void              *vb_ptr;
d302 1
a302 6
    /* common accel data */
    int               fifo_slots;       /* Free slots in the FIFO (64 max)   */
				/* Computed values for Radeon */
    uint32_t          dp_gui_master_cntl;
    uint32_t          dp_gui_master_cntl_clip;
    uint32_t          trans_color;
a305 1
    uint32_t          dst_pitch_offset;
a314 1
#ifdef USE_EXA
a343 2
    drmBufPtr         ib;

a348 1
#ifdef XF86DRM_MODE
a352 1
#endif
a354 1
    ExaOffscreenArea  *shaders;
a385 3
    // UTS/DFS
    drmBufPtr         scratch;

d387 1
a387 1
    ExaOffscreenArea  *copy_area;
a400 36
#endif

#ifdef USE_XAA
    /* XAA */
    XAAInfoRecPtr     accel;
				/* ScanlineScreenToScreenColorExpand support */
    unsigned char     *scratch_buffer[1];
    unsigned char     *scratch_save;
    int               scanline_x;
    int               scanline_y;
    int               scanline_w;
    int               scanline_h;
    int               scanline_h_w;
    int               scanline_words;
    int               scanline_direct;
    int               scanline_bpp;     /* Only used for ImageWrite */
    int               scanline_fg;
    int               scanline_bg;
    int               scanline_hpass;
    int               scanline_x1clip;
    int               scanline_x2clip;
				/* Saved values for DashedTwoPointLine */
    int               dashLen;
    uint32_t          dashPattern;
    int               dash_fg;
    int               dash_bg;

    FBLinearPtr       RenderTex;
    void              (*RenderCallback)(ScrnInfoPtr);
    Time              RenderTimeout;
    /*
     * XAAForceTransBlit is used to change the behavior of the XAA
     * SetupForScreenToScreenCopy function, to make it DGA-friendly.
     */
    Bool              XAAForceTransBlit;
#endif
d402 1
a407 3
#ifndef XSERVER_LIBPCIACCESS
    PCITAG            PciTag;
#endif
a409 1
    RADEONErrata      ChipErrata;
a410 54
    unsigned long long     LinearAddr;       /* Frame buffer physical address     */
    unsigned long long     MMIOAddr;         /* MMIO region physical address      */
    unsigned long long     BIOSAddr;         /* BIOS physical address             */
    uint64_t          fbLocation;
    uint32_t          gartLocation;
    uint32_t          mc_fb_location;
    uint32_t          mc_agp_location;
    uint32_t          mc_agp_location_hi;

    void              *MMIO;            /* Map of MMIO region                */
    void              *FB;              /* Map of frame buffer               */
    uint8_t           *VBIOS;           /* Video BIOS pointer                */

    Bool              IsAtomBios;       /* New BIOS used in R420 etc.        */
    int               ROMHeaderStart;   /* Start of the ROM Info Table       */
    int               MasterDataStart;  /* Offset for Master Data Table for ATOM BIOS */

    uint32_t          MemCntl;
    uint32_t          BusCntl;
    unsigned long     MMIOSize;         /* MMIO region physical address      */
    unsigned long     FbMapSize;        /* Size of frame buffer, in bytes    */
    unsigned long     FbSecureSize;     /* Size of secured fb area at end of
                                           framebuffer */

    Bool              IsMobility;       /* Mobile chips for laptops */
    Bool              IsIGP;            /* IGP chips */
    Bool              HasSingleDAC;     /* only TVDAC on chip */
    Bool              ddc_mode;         /* Validate mode by matching exactly
					 * the modes supported in DDC data
					 */
    Bool              R300CGWorkaround;

				/* EDID or BIOS values for FPs */
    int               RefDivider;
    int               FeedbackDivider;
    int               PostDivider;
    Bool              UseBiosDividers;
				/* EDID data using DDC interface */
    Bool              ddc_bios;
    Bool              ddc1;
    Bool              ddc2;

    RADEONPLLRec      pll;
    int               default_dispclk;
    int               dp_extclk;

    int               RamWidth;
    float	      sclk;		/* in MHz */
    float	      mclk;		/* in MHz */
    Bool	      IsDDR;
    int               DispPriority;

    RADEONSavePtr     SavedReg;         /* Original (text) mode              */
    RADEONSavePtr     ModeReg;          /* Current mode                      */
a414 9
    Bool              PaletteSavedOnVT; /* Palette saved on last VT switch   */

    xf86CursorInfoPtr cursor;
#ifdef ARGB_CURSOR
    Bool	      cursor_argb;
#endif
    int               cursor_fg;
    int               cursor_bg;

d418 1
a418 1
    RADEONFBLayout    CurrentLayout;
a419 1
#ifdef XF86DRI
a420 5
    Bool              directRenderingInited;
    RADEONCardType    cardType;            /* Current card is a PCI card */
    struct radeon_cp  *cp;
    struct radeon_dri  *dri;
#ifdef XF86DRM_MODE
a421 2
#endif
#ifdef USE_EXA
a422 3
#endif
    Bool              DMAForXv;
#endif /* XF86DRI */
a427 1
    Bool              tilingEnabled; /* mirror of sarea->tiling_enabled */
d430 1
a430 2
    Bool              useEXA;
#ifdef USE_EXA
d434 1
a434 4
#endif
#ifdef USE_XAA
    XF86ModReqInfo    xaaReq;
#endif
a435 27
				/* XVideo */
    XF86VideoAdaptorPtr adaptor;
    void              (*VideoTimerCallback)(ScrnInfoPtr, Time);
    int               videoKey;
    int		      RageTheatreCrystal;
    int               RageTheatreTunerPort;
    int               RageTheatreCompositePort;
    int               RageTheatreSVideoPort;
    int               tunerType;
    char*             RageTheatreMicrocPath;
    char*             RageTheatreMicrocType;
    Bool              MM_TABLE_valid;
    struct {
    	uint8_t table_revision;
	uint8_t table_size;
        uint8_t tuner_type;
        uint8_t audio_chip;
        uint8_t product_id;
        uint8_t tuner_voltage_teletext_fm;
        uint8_t i2s_config; /* configuration of the sound chip */
        uint8_t video_decoder_type;
        uint8_t video_decoder_host_config;
        uint8_t input[5];
    } MM_TABLE;
    uint16_t video_decoder_type;
    int overlay_scaler_buffer_width;
    int ecp_div;
d442 1
a442 29
    DisplayModePtr currentMode, savedCurrentMode;

    /* special handlings for DELL triple-head server */
    Bool              IsDellServer;

    Bool              VGAAccess;

    int               MaxSurfaceWidth;
    int               MaxLines;

    Bool want_vblank_interrupts;
    RADEONBIOSConnector BiosConnector[RADEON_MAX_BIOS_CONNECTOR];
    radeon_encoder_ptr encoders[RADEON_MAX_BIOS_CONNECTOR];
    RADEONBIOSInitTable BiosTable;

    /* save crtc state for console restore */
    Bool              crtc_on;
    Bool              crtc2_on;

    Bool              InternalTVOut;

#if defined(__powerpc__)
    RADEONMacModel    MacModel;
#endif
    RADEONExtTMDSChip ext_tmds_chip;

    atomBiosHandlePtr atomBIOS;
    unsigned long FbFreeStart, FbFreeSize;
    unsigned char*      BIOSCopy;
a445 3
    /* if no devices are connected at server startup */
    Bool              first_load_no_devices;

a451 18
    /* some server chips have a hardcoded edid in the bios so that they work with KVMs */
    Bool get_hardcoded_edid_from_bios;

    int               virtualX;
    int               virtualY;

    Bool              r4xx_atom;

    /* pm */
    RADEONPowerManagement pm;

    /* igp info */
    float igp_sideport_mclk;
    float igp_system_mclk;
    float igp_ht_link_clk;
    float igp_ht_link_width;

    int can_resize;
a453 1
    Bool kms_enabled;
a454 1
#ifdef XF86DRM_MODE
d463 1
a472 4
#else
    /* fake bool */
    Bool cs;
#endif
d476 1
a476 2
    void             *bicubic_memory;
    int               bicubic_offset;
d482 4
a487 50
#define RADEONWaitForFifo(pScrn, entries)				\
do {									\
    if (info->accel_state->fifo_slots < entries)			\
	RADEONWaitForFifoFunction(pScrn, entries);			\
    info->accel_state->fifo_slots -= entries;				\
} while (0)

/* legacy_crtc.c */
extern void legacy_crtc_dpms(xf86CrtcPtr crtc, int mode);
extern void legacy_crtc_mode_set(xf86CrtcPtr crtc, DisplayModePtr mode,
				 DisplayModePtr adjusted_mode, int x, int y);
extern void RADEONRestoreCommonRegisters(ScrnInfoPtr pScrn,
					 RADEONSavePtr restore);
extern void RADEONRestoreCrtcRegisters(ScrnInfoPtr pScrn,
				       RADEONSavePtr restore);
extern void RADEONRestoreCrtc2Registers(ScrnInfoPtr pScrn,
					RADEONSavePtr restore);
extern void RADEONRestorePLLRegisters(ScrnInfoPtr pScrn,
				      RADEONSavePtr restore);
extern void RADEONRestorePLL2Registers(ScrnInfoPtr pScrn,
				       RADEONSavePtr restore);
extern void RADEONSaveCommonRegisters(ScrnInfoPtr pScrn, RADEONSavePtr save);
extern void RADEONSaveCrtcRegisters(ScrnInfoPtr pScrn, RADEONSavePtr save);
extern void RADEONSaveCrtc2Registers(ScrnInfoPtr pScrn, RADEONSavePtr save);
extern void RADEONSavePLLRegisters(ScrnInfoPtr pScrn, RADEONSavePtr save);
extern void RADEONSavePLL2Registers(ScrnInfoPtr pScrn, RADEONSavePtr save);

/* legacy_output.c */
extern RADEONMonitorType legacy_dac_detect(xf86OutputPtr output);
extern void legacy_output_dpms(xf86OutputPtr output, int mode);
extern void legacy_output_mode_set(xf86OutputPtr output, DisplayModePtr mode,
				   DisplayModePtr adjusted_mode);
extern I2CDevPtr RADEONDVODeviceInit(I2CBusPtr b, I2CSlaveAddr addr);
extern Bool RADEONDVOReadByte(I2CDevPtr dvo, int addr, uint8_t *ch);
extern Bool RADEONDVOWriteByte(I2CDevPtr dvo, int addr, uint8_t ch);
extern void RADEONRestoreDACRegisters(ScrnInfoPtr pScrn, RADEONSavePtr restore);
extern void RADEONRestoreFPRegisters(ScrnInfoPtr pScrn, RADEONSavePtr restore);
extern void RADEONRestoreFP2Registers(ScrnInfoPtr pScrn, RADEONSavePtr restore);
extern void RADEONRestoreLVDSRegisters(ScrnInfoPtr pScrn, RADEONSavePtr restore);
extern void RADEONRestoreRMXRegisters(ScrnInfoPtr pScrn, RADEONSavePtr restore);
extern void RADEONSaveDACRegisters(ScrnInfoPtr pScrn, RADEONSavePtr save);
extern void RADEONSaveFPRegisters(ScrnInfoPtr pScrn, RADEONSavePtr save);
extern void radeon_save_palette_on_demand(ScrnInfoPtr pScrn, int palID);

extern void RADEONGetTVDacAdjInfo(ScrnInfoPtr pScrn, radeon_tvdac_ptr tvdac);
extern void RADEONGetTMDSInfoFromTable(ScrnInfoPtr pScrn, radeon_tmds_ptr tmds);
extern void RADEONGetTMDSInfo(ScrnInfoPtr pScrn, radeon_tmds_ptr tmds);
extern void RADEONGetExtTMDSInfo(ScrnInfoPtr pScrn, radeon_dvo_ptr dvo);
extern void RADEONGetLVDSInfo(ScrnInfoPtr pScrn, radeon_lvds_ptr lvds);

a489 1
extern void RADEONEngineFlush(ScrnInfoPtr pScrn);
a490 12
extern void RADEONEngineReset(ScrnInfoPtr pScrn);
extern void RADEONEngineRestore(ScrnInfoPtr pScrn);
extern uint8_t *RADEONHostDataBlit(ScrnInfoPtr pScrn, unsigned int cpp,
				 unsigned int w, uint32_t dstPitchOff,
				 uint32_t *bufPitch, int x, int *y,
				 unsigned int *h, unsigned int *hpass);
extern void RADEONHostDataBlitCopyPass(ScrnInfoPtr pScrn,
				       unsigned int bpp,
				       uint8_t *dst, uint8_t *src,
				       unsigned int hpass,
				       unsigned int dstPitch,
				       unsigned int srcPitch);
a491 3
extern void RADEONHostDataParams(ScrnInfoPtr pScrn, uint8_t *dst,
				 uint32_t pitch, int cpp,
				 uint32_t *dstPitchOffset, int *x, int *y);
a492 11
extern void RADEONWaitForFifoFunction(ScrnInfoPtr pScrn, int entries);
#ifdef XF86DRI
extern drmBufPtr RADEONCPGetBuffer(ScrnInfoPtr pScrn);
extern void RADEONCPFlushIndirect(ScrnInfoPtr pScrn, int discard);
extern void RADEONCPReleaseIndirect(ScrnInfoPtr pScrn);
extern int RADEONCPStop(ScrnInfoPtr pScrn,  RADEONInfoPtr info);
#  ifdef USE_XAA
extern Bool RADEONSetupMemXAA_DRI(ScreenPtr pScreen);
#  endif
uint32_t radeonGetPixmapOffset(PixmapPtr pPix);
#endif
a494 21
#ifdef USE_XAA
/* radeon_accelfuncs.c */
extern void RADEONAccelInitMMIO(ScreenPtr pScreen, XAAInfoRecPtr a);
extern Bool RADEONSetupMemXAA(ScreenPtr pScreen);
#endif

/* radeon_bios.c */
extern Bool RADEONGetBIOSInfo(ScrnInfoPtr pScrn, xf86Int10InfoPtr pInt10);
extern Bool RADEONGetClockInfoFromBIOS(ScrnInfoPtr pScrn);
extern Bool RADEONGetConnectorInfoFromBIOS(ScrnInfoPtr pScrn);
extern Bool RADEONGetDAC2InfoFromBIOS(ScrnInfoPtr pScrn, radeon_tvdac_ptr tvdac);
extern Bool RADEONGetExtTMDSInfoFromBIOS (ScrnInfoPtr pScrn, radeon_dvo_ptr dvo);
extern xf86MonPtr RADEONGetHardCodedEDIDFromBIOS(xf86OutputPtr output);
extern Bool RADEONGetBIOSInitTableOffsets(ScrnInfoPtr pScrn);
extern Bool RADEONGetLVDSInfoFromBIOS(ScrnInfoPtr pScrn, radeon_lvds_ptr lvds);
extern Bool RADEONGetTMDSInfoFromBIOS(ScrnInfoPtr pScrn, radeon_tmds_ptr tmds);
extern Bool RADEONGetTVInfoFromBIOS(xf86OutputPtr output);
extern Bool RADEONInitExtTMDSInfoFromBIOS (xf86OutputPtr output);
extern Bool RADEONPostCardFromBIOSTables(ScrnInfoPtr pScrn);
extern Bool radeon_card_posted(ScrnInfoPtr pScrn);

d496 2
a497 51
#ifdef XF86DRI
extern void RADEONWaitForIdleCP(ScrnInfoPtr pScrn);
extern void RADEONWaitForVLineCP(ScrnInfoPtr pScrn, PixmapPtr pPix,
				 xf86CrtcPtr crtc, int start, int stop);
#endif
extern void RADEONWaitForIdleMMIO(ScrnInfoPtr pScrn);
extern void RADEONWaitForVLineMMIO(ScrnInfoPtr pScrn, PixmapPtr pPix,
				   xf86CrtcPtr crtc, int start, int stop);

/* radeon_crtc.c */
extern void radeon_crtc_dpms(xf86CrtcPtr crtc, int mode);
extern void radeon_do_crtc_dpms(xf86CrtcPtr crtc, int mode);
extern void radeon_crtc_load_lut(xf86CrtcPtr crtc);
extern void radeon_crtc_modeset_ioctl(xf86CrtcPtr crtc, Bool post);
extern Bool RADEONAllocateControllers(ScrnInfoPtr pScrn, int mask);
extern void RADEONBlank(ScrnInfoPtr pScrn);
extern void RADEONComputePLL(xf86CrtcPtr crtc,
			     RADEONPLLPtr pll, unsigned long freq,
			     uint32_t *chosen_dot_clock_freq,
			     uint32_t *chosen_feedback_div,
			     uint32_t *chosen_frac_feedback_div,
			     uint32_t *chosen_reference_div,
			     uint32_t *chosen_post_div, int flags);
extern DisplayModePtr RADEONCrtcFindClosestMode(xf86CrtcPtr crtc,
						DisplayModePtr pMode);
extern void RADEONUnblank(ScrnInfoPtr pScrn);
extern Bool RADEONSetTiling(ScrnInfoPtr pScrn);
extern void RADEONInitDispBandwidth(ScrnInfoPtr pScrn);

/* radeon_cursor.c */
extern Bool RADEONCursorInit(ScreenPtr pScreen);
extern void radeon_crtc_hide_cursor(xf86CrtcPtr crtc);
extern void radeon_crtc_load_cursor_argb(xf86CrtcPtr crtc, CARD32 *image);
extern void radeon_crtc_set_cursor_colors(xf86CrtcPtr crtc, int bg, int fg);
extern void radeon_crtc_set_cursor_position(xf86CrtcPtr crtc, int x, int y);
extern void radeon_crtc_show_cursor(xf86CrtcPtr crtc);

#ifdef XF86DRI
/* radeon_dri.c */
extern void RADEONDRIAllocatePCIGARTTable(ScreenPtr pScreen);
extern void RADEONDRICloseScreen(ScreenPtr pScreen);
extern Bool RADEONDRIFinishScreenInit(ScreenPtr pScreen);
extern int RADEONDRIGetPciAperTableSize(ScrnInfoPtr pScrn);
extern Bool RADEONDRIGetVersion(ScrnInfoPtr pScrn);
extern void RADEONDRIResume(ScreenPtr pScreen);
extern Bool RADEONDRIScreenInit(ScreenPtr pScreen);
extern int RADEONDRISetParam(ScrnInfoPtr pScrn,
			     unsigned int param, int64_t value);
extern Bool RADEONDRISetVBlankInterrupt(ScrnInfoPtr pScrn, Bool on);
extern void RADEONDRIStop(ScreenPtr pScreen);
#endif
a498 40
/* radeon_driver.c */
extern void RADEONDoAdjustFrame(ScrnInfoPtr pScrn, int x, int y, Bool clone);
extern void RADEONChangeSurfaces(ScrnInfoPtr pScrn);
extern RADEONEntPtr RADEONEntPriv(ScrnInfoPtr pScrn);
extern int RADEONMinBits(int val);
extern unsigned RADEONINMC(ScrnInfoPtr pScrn, int addr);
extern unsigned RADEONINPLL(ScrnInfoPtr pScrn, int addr);
extern unsigned RADEONINPCIE(ScrnInfoPtr pScrn, int addr);
extern unsigned R600INPCIE_PORT(ScrnInfoPtr pScrn, int addr);
extern void RADEONOUTMC(ScrnInfoPtr pScrn, int addr, uint32_t data);
extern void RADEONOUTPLL(ScrnInfoPtr pScrn, int addr, uint32_t data);
extern void RADEONOUTPCIE(ScrnInfoPtr pScrn, int addr, uint32_t data);
extern void R600OUTPCIE_PORT(ScrnInfoPtr pScrn, int addr, uint32_t data);
extern void RADEONPllErrataAfterData(RADEONInfoPtr info);
extern void RADEONPllErrataAfterIndex(RADEONInfoPtr info);
extern void RADEONWaitForVerticalSync(ScrnInfoPtr pScrn);
extern void RADEONWaitForVerticalSync2(ScrnInfoPtr pScrn);
extern void RADEONInitMemMapRegisters(ScrnInfoPtr pScrn, RADEONSavePtr save,
				      RADEONInfoPtr info);
extern void RADEONRestoreMemMapRegisters(ScrnInfoPtr pScrn,
					 RADEONSavePtr restore);
extern Bool
RADEONZaphodStringMatches(ScrnInfoPtr pScrn, const char *s, char *output_name);

Bool RADEONGetRec(ScrnInfoPtr pScrn);
void RADEONFreeRec(ScrnInfoPtr pScrn);
Bool RADEONPreInitVisual(ScrnInfoPtr pScrn);
Bool RADEONPreInitWeight(ScrnInfoPtr pScrn);

extern Bool RADEON_DP_I2CInit(ScrnInfoPtr pScrn, I2CBusPtr *bus_ptr,
			      char *name, xf86OutputPtr output);
extern void RADEON_DP_GetDPCD(xf86OutputPtr output);
extern int RADEON_DP_GetSinkType(xf86OutputPtr output);

/* radeon_pm.c */
extern void RADEONPMInit(ScrnInfoPtr pScrn);
extern void RADEONPMBlockHandler(ScrnInfoPtr pScrn);
extern void RADEONPMEnterVT(ScrnInfoPtr pScrn);
extern void RADEONPMLeaveVT(ScrnInfoPtr pScrn);
extern void RADEONPMFini(ScrnInfoPtr pScrn);
a499 1
#ifdef USE_EXA
a501 1
extern Bool RADEONSetupMemEXA(ScreenPtr pScreen);
d505 1
a505 16
extern void RADEONCopyCP(PixmapPtr pDst, int srcX, int srcY, int dstX,
			 int dstY, int w, int h);
extern void RADEONCopyMMIO(PixmapPtr pDst, int srcX, int srcY, int dstX,
			   int dstY, int w, int h);
extern Bool RADEONDrawInitCP(ScreenPtr pScreen);
extern Bool RADEONDrawInitMMIO(ScreenPtr pScreen);
extern void RADEONDoPrepareCopyCP(ScrnInfoPtr pScrn,
				  uint32_t src_pitch_offset,
				  uint32_t dst_pitch_offset,
				  uint32_t datatype, int rop,
				  Pixel planemask);
extern void RADEONDoPrepareCopyMMIO(ScrnInfoPtr pScrn,
				    uint32_t src_pitch_offset,
				    uint32_t dst_pitch_offset,
				    uint32_t datatype, int rop,
				    Pixel planemask);
a507 1
#ifdef XF86DRM_MODE
a508 2
#endif
#endif
a509 1
#if defined(XF86DRI) && defined(USE_EXA)
a513 34
extern unsigned long long RADEONTexOffsetStart(PixmapPtr pPix);
#endif

/* radeon_modes.c */
extern void RADEONSetPitch(ScrnInfoPtr pScrn);
extern DisplayModePtr RADEONProbeOutputModes(xf86OutputPtr output);

/* radeon_output.c */
extern RADEONI2CBusRec atom_setup_i2c_bus(int ddc_line);
extern RADEONI2CBusRec legacy_setup_i2c_bus(int ddc_line);
extern void RADEONGetPanelInfo(ScrnInfoPtr pScrn);
extern void RADEONInitConnector(xf86OutputPtr output);
extern void RADEONPrintPortMap(ScrnInfoPtr pScrn);
extern void RADEONSetOutputType(ScrnInfoPtr pScrn,
				RADEONOutputPrivatePtr radeon_output);
extern Bool RADEONSetupConnectors(ScrnInfoPtr pScrn);
extern Bool RADEONI2CDoLock(xf86OutputPtr output, I2CBusPtr b, Bool lock_state);

extern Bool radeon_dp_mode_fixup(xf86OutputPtr output, DisplayModePtr mode, DisplayModePtr adjusted_mode);

/* radeon_tv.c */
extern void RADEONSaveTVRegisters(ScrnInfoPtr pScrn, RADEONSavePtr save);
extern void RADEONAdjustCrtcRegistersForTV(ScrnInfoPtr pScrn, RADEONSavePtr save,
					   DisplayModePtr mode, xf86OutputPtr output);
extern void RADEONAdjustPLLRegistersForTV(ScrnInfoPtr pScrn, RADEONSavePtr save,
					  DisplayModePtr mode, xf86OutputPtr output);
extern void RADEONAdjustCrtc2RegistersForTV(ScrnInfoPtr pScrn, RADEONSavePtr save,
					   DisplayModePtr mode, xf86OutputPtr output);
extern void RADEONAdjustPLL2RegistersForTV(ScrnInfoPtr pScrn, RADEONSavePtr save,
					  DisplayModePtr mode, xf86OutputPtr output);
extern void RADEONInitTVRegisters(xf86OutputPtr output, RADEONSavePtr save,
                                  DisplayModePtr mode, BOOL IsPrimary);
extern void RADEONRestoreTVRegisters(ScrnInfoPtr pScrn, RADEONSavePtr restore);
extern void RADEONUpdateHVPosition(xf86OutputPtr output, DisplayModePtr mode);
d520 1
a522 12
/* radeon_legacy_memory.c */
extern uint32_t
radeon_legacy_allocate_memory(ScrnInfoPtr pScrn,
			      void **mem_struct,
			      int size,
			      int align,
			      int domain);
extern void
radeon_legacy_free_memory(ScrnInfoPtr pScrn,
		          void *mem_struct);

#ifdef XF86DRM_MODE
d528 6
a533 1
struct radeon_surface *radeon_get_pixmap_surface(PixmapPtr pPix);
d535 21
a555 2
struct radeon_bo *radeon_get_pixmap_bo(PixmapPtr pPix);
void radeon_set_pixmap_bo(PixmapPtr pPix, struct radeon_bo *bo);
d558 7
a564 5
#ifdef XF86DRI
#  ifdef USE_XAA
/* radeon_accelfuncs.c */
extern void RADEONAccelInitCP(ScreenPtr pScreen, XAAInfoRecPtr a);
#  endif
d566 52
a617 9
#define RADEONCP_START(pScrn, info)					\
do {									\
    int _ret = drmCommandNone(info->dri->drmFD, DRM_RADEON_CP_START);	\
    if (_ret) {								\
	xf86DrvMsg(pScrn->scrnIndex, X_ERROR,				\
		   "%s: CP start %d\n", __FUNCTION__, _ret);		\
    }									\
    info->cp->CPStarted = TRUE;                                         \
} while (0)
d619 4
a622 11
#define RADEONCP_RELEASE(pScrn, info)					\
do {									\
    if (info->cs) {							\
	radeon_cs_flush_indirect(pScrn);				\
    } else if (info->cp->CPInUse) {					\
	RADEON_PURGE_CACHE();						\
	RADEON_WAIT_UNTIL_IDLE();					\
	RADEONCPReleaseIndirect(pScrn);					\
	info->cp->CPInUse = FALSE;				        \
    }									\
} while (0)
d624 11
a634 15
#define RADEONCP_STOP(pScrn, info)					\
do {									\
    int _ret;								\
    if (info->cp->CPStarted) {						\
        _ret = RADEONCPStop(pScrn, info);				\
        if (_ret) {							\
	    xf86DrvMsg(pScrn->scrnIndex, X_ERROR,			\
		   "%s: CP stop %d\n", __FUNCTION__, _ret);		\
        }								\
        info->cp->CPStarted = FALSE;                                    \
    }									\
    if (info->ChipFamily < CHIP_FAMILY_R600)                            \
        RADEONEngineRestore(pScrn);					\
    info->cp->CPRuns = FALSE;						\
} while (0)
d636 2
a637 8
#define RADEONCP_RESET(pScrn, info)					\
do {									\
	int _ret = drmCommandNone(info->dri->drmFD, DRM_RADEON_CP_RESET);	\
	if (_ret) {							\
	    xf86DrvMsg(pScrn->scrnIndex, X_ERROR,			\
		       "%s: CP reset %d\n", __FUNCTION__, _ret);	\
	}								\
} while (0)
d639 4
a642 12
#define RADEONCP_REFRESH(pScrn, info)					\
do {									\
    if (!info->cp->CPInUse && !info->cs) {				\
	if (info->cp->needCacheFlush) {					\
	    RADEON_PURGE_CACHE();					\
	    RADEON_PURGE_ZCACHE();					\
	    info->cp->needCacheFlush = FALSE;				\
	}								\
	RADEON_WAIT_UNTIL_IDLE();					\
	info->cp->CPInUse = TRUE;					\
    }									\
} while (0)
d644 12
a668 2
#define RING_LOCALS	uint32_t *__head = NULL; int __expected; int __count = 0

d674 1
a674 21
    if (info->cs) { radeon_ddx_cs_start(pScrn, n, __FILE__, __func__, __LINE__); } else { \
      if (++info->cp->dma_begin_count != 1) {				\
	xf86DrvMsg(pScrn->scrnIndex, X_ERROR,				\
		   "BEGIN_RING without end at %s:%d\n",			\
		   info->cp->dma_debug_func, info->cp->dma_debug_lineno); \
	info->cp->dma_begin_count = 1;					\
      }									\
      info->cp->dma_debug_func = __FILE__;				\
      info->cp->dma_debug_lineno = __LINE__;				\
      if (!info->cp->indirectBuffer) {					\
	info->cp->indirectBuffer = RADEONCPGetBuffer(pScrn);		\
	info->cp->indirectStart = 0;					\
      } else if (info->cp->indirectBuffer->used + (n) * (int)sizeof(uint32_t) >	\
		 info->cp->indirectBuffer->total) {		        \
	RADEONCPFlushIndirect(pScrn, 1);				\
      }									\
      __expected = n;							\
      __head = (pointer)((char *)info->cp->indirectBuffer->address +	\
			 info->cp->indirectBuffer->used);		\
      __count = 0;							\
    }									\
d678 1
a678 21
    if (info->cs) radeon_cs_end(info->cs, __FILE__, __func__, __LINE__); else {		\
      if (info->cp->dma_begin_count-- != 1) {				\
	xf86DrvMsg(pScrn->scrnIndex, X_ERROR,				\
		   "ADVANCE_RING without begin at %s:%d\n",		\
		   __FILE__, __LINE__);					\
	info->cp->dma_begin_count = 0;					\
      }									\
      if (__count != __expected) {					\
	xf86DrvMsg(pScrn->scrnIndex, X_ERROR,				\
		   "ADVANCE_RING count != expected (%d vs %d) at %s:%d\n", \
		   __count, __expected, __FILE__, __LINE__);		\
      }									\
      if (RADEON_VERBOSE) {						\
	xf86DrvMsg(pScrn->scrnIndex, X_INFO,				\
		   "ADVANCE_RING() start: %d used: %d count: %d\n",	\
		   info->cp->indirectStart,				\
		   info->cp->indirectBuffer->used,			\
		   __count * (int)sizeof(uint32_t));			\
      }									\
      info->cp->indirectBuffer->used += __count * (int)sizeof(uint32_t); \
    }									\
d686 1
a686 2
    if (info->cs) radeon_cs_write_dword(info->cs, (x)); else		\
    __head[__count++] = (x);						\
d708 1
a708 4
    if (info->cs)							\
	radeon_cs_flush_indirect(pScrn); 				\
    else if (info->cp->indirectBuffer)					\
	RADEONCPFlushIndirect(pScrn, 0);				\
a710 74

#define RADEON_WAIT_UNTIL_2D_IDLE()					\
do {									\
    if (info->ChipFamily < CHIP_FAMILY_R600) {                          \
	BEGIN_RING(2);                                                  \
	OUT_RING(CP_PACKET0(RADEON_WAIT_UNTIL, 0));                     \
	OUT_RING((RADEON_WAIT_2D_IDLECLEAN |                            \
		  RADEON_WAIT_HOST_IDLECLEAN));                         \
	ADVANCE_RING();                                                 \
    }                                                                   \
} while (0)

#define RADEON_WAIT_UNTIL_3D_IDLE()					\
do {									\
    if (info->ChipFamily < CHIP_FAMILY_R600) {				\
	BEGIN_RING(2);							\
	OUT_RING(CP_PACKET0(RADEON_WAIT_UNTIL, 0));                     \
	OUT_RING((RADEON_WAIT_3D_IDLECLEAN |                            \
		  RADEON_WAIT_HOST_IDLECLEAN));                         \
	ADVANCE_RING();							\
    }                                                                   \
} while (0)

#define RADEON_WAIT_UNTIL_IDLE()					\
do {									\
    if (RADEON_VERBOSE) {						\
	xf86DrvMsg(pScrn->scrnIndex, X_INFO,				\
		   "WAIT_UNTIL_IDLE() in %s\n", __FUNCTION__);		\
    }									\
    if (info->ChipFamily < CHIP_FAMILY_R600) {                          \
	BEGIN_RING(2);							\
	OUT_RING(CP_PACKET0(RADEON_WAIT_UNTIL, 0));                     \
	OUT_RING((RADEON_WAIT_2D_IDLECLEAN |                            \
                  RADEON_WAIT_3D_IDLECLEAN |                            \
		  RADEON_WAIT_HOST_IDLECLEAN));                         \
	ADVANCE_RING();							\
    }                                                                   \
} while (0)

#define RADEON_PURGE_CACHE()						\
do {									\
    if (info->ChipFamily < CHIP_FAMILY_R600) {				\
	BEGIN_RING(2);							\
	if (info->ChipFamily <= CHIP_FAMILY_RV280) {			\
	    OUT_RING(CP_PACKET0(RADEON_RB3D_DSTCACHE_CTLSTAT, 0));	\
	    OUT_RING(RADEON_RB3D_DC_FLUSH_ALL);				\
	} else {							\
	    OUT_RING(CP_PACKET0(R300_RB3D_DSTCACHE_CTLSTAT, 0));	\
	    OUT_RING(R300_RB3D_DC_FLUSH_ALL);				\
	}								\
	ADVANCE_RING();							\
    }									\
} while (0)

#define RADEON_PURGE_ZCACHE()						\
do {									\
    if (info->ChipFamily < CHIP_FAMILY_R600) {                          \
	BEGIN_RING(2);                                                  \
	if (info->ChipFamily <= CHIP_FAMILY_RV280) {                    \
	    OUT_RING(CP_PACKET0(RADEON_RB3D_ZCACHE_CTLSTAT, 0));        \
	    OUT_RING(RADEON_RB3D_ZC_FLUSH_ALL);                         \
	} else {                                                        \
	    OUT_RING(CP_PACKET0(R300_RB3D_ZCACHE_CTLSTAT, 0));          \
	    OUT_RING(R300_ZC_FLUSH_ALL);                                \
	}                                                               \
	ADVANCE_RING();                                                 \
    }                                                                   \
} while (0)

#endif /* XF86DRI */

#if defined(XF86DRI) && defined(USE_EXA)

#ifdef XF86DRM_MODE
a711 3
#else
#define CS_FULL(cs) FALSE
#endif
d721 1
a721 1
	    flush = !info->cs || CS_FULL(info->cs);			\
d724 1
a724 1
	    flush = info->cs && CS_FULL(info->cs);			\
d728 1
a728 4
    	    if (info->cs)						\
	        radeon_cs_flush_indirect(pScrn);			\
            else if (info->directRenderingEnabled)                     	\
	        RADEONCPFlushIndirect(pScrn, 1);                        \
d741 1
a741 1
	    flush = !info->cs || CS_FULL(info->cs);			\
d744 1
a744 1
	    flush = info->cs && CS_FULL(info->cs);			\
d748 1
a748 4
    	    if (info->cs)						\
	        radeon_cs_flush_indirect(pScrn);			\
	    else if (info->directRenderingEnabled)				\
	        RADEONCPFlushIndirect(pScrn, 1);                        \
a753 4
#else
#define RADEON_SWITCH_TO_2D()
#define RADEON_SWITCH_TO_3D()
#endif
d755 26
a780 11
static __inline__ void RADEON_MARK_SYNC(RADEONInfoPtr info, ScrnInfoPtr pScrn)
{
#ifdef USE_EXA
    if (info->useEXA)
	exaMarkSync(pScrn->pScreen);
#endif
#ifdef USE_XAA
    if (!info->useEXA)
	SET_SYNC_FLAG(info->accel_state->accel);
#endif
}
d784 1
a784 2
#ifdef USE_EXA
    if (info->useEXA && pScrn->pScreen)
a785 22
#endif
#ifdef USE_XAA
    if (!info->useEXA && info->accel_state->accel)
	info->accel_state->accel->Sync(pScrn);
#endif
}

static __inline__ void radeon_init_timeout(struct timeval *endtime,
    unsigned int timeout)
{
    gettimeofday(endtime, NULL);
    endtime->tv_usec += timeout;
    endtime->tv_sec += endtime->tv_usec / 1000000;
    endtime->tv_usec %= 1000000;
}

static __inline__ int radeon_timedout(const struct timeval *endtime)
{
    struct timeval now;
    gettimeofday(&now, NULL);
    return now.tv_sec == endtime->tv_sec ?
        now.tv_usec > endtime->tv_usec : now.tv_sec > endtime->tv_sec;
d789 1
d794 1
d796 20
@


1.10
log
@Brown paperbag commit.

Prodded by espie@@ I reviewed the history of
OpenBSD local changes carefully and found a number of merge errors
accumulated over the complicated CVS history of this driver.

This the 6.14.4 code + OpenBSD local fixes as it should be.
@
text
@d45 1
d105 2
d410 2
a411 1
    RADEON_MAC_EMAC
d518 1
a518 1
    Bool             (*DRICloseScreen)(int, ScreenPtr);
d865 1
a865 1
    Bool              (*CloseScreen)(int, ScreenPtr);
d867 1
a867 1
    void              (*BlockHandler)(int, pointer, pointer, pointer);
d1123 1
a1123 1
extern Bool RADEONSetupMemXAA_DRI(int scrnIndex, ScreenPtr pScreen);
d1132 1
a1132 1
extern Bool RADEONSetupMemXAA(int scrnIndex, ScreenPtr pScreen);
@


1.9
log
@Update to xf86-video-ati 6.14.4. Tested by jasper@@, krw@@, mpi@@, shadchin@@
@
text
@a517 3
    drmSize           registerSize;
    drm_handle_t      registerHandle;

@


1.8
log
@Re-update xf86-video-ati to 6.14.3.

Because of ati.c revision 1.5, it will not be selected by
autoconfiguration code, so people who want to run this version of the
driver on their radeon cards need an explicit "Device" section in
xorg.conf.
@
text
@d94 1
d187 1
d447 3
d629 3
d803 1
d805 1
d900 1
d1015 1
a1015 1
    struct radeon_bo *cursor_bo[6];
d1026 2
d1086 1
d1161 1
d1245 1
d1337 1
d1685 2
@


1.7
log
@Revert the update to xf86-video-ati 6.14.3. Requested by espie@@
who experiemnts regressions with this driver.
@
text
@d78 1
d89 9
d103 1
d177 1
d181 1
d202 1
a202 1
    OPTION_DYNAMIC_CLOCKS,
d223 6
a228 1
    OPTION_R4XX_ATOM
d238 2
a239 1
#define RADEON_BUFFER_ALIGN 0x00000fff
d281 3
d286 3
a288 2
    uint16_t          reference_freq;
    uint16_t          reference_div;
d301 2
a315 44
typedef enum {
    CHIP_FAMILY_UNKNOW,
    CHIP_FAMILY_LEGACY,
    CHIP_FAMILY_RADEON,
    CHIP_FAMILY_RV100,
    CHIP_FAMILY_RS100,    /* U1 (IGP320M) or A3 (IGP320)*/
    CHIP_FAMILY_RV200,
    CHIP_FAMILY_RS200,    /* U2 (IGP330M/340M/350M) or A4 (IGP330/340/345/350), RS250 (IGP 7000) */
    CHIP_FAMILY_R200,
    CHIP_FAMILY_RV250,
    CHIP_FAMILY_RS300,    /* RS300/RS350 */
    CHIP_FAMILY_RV280,
    CHIP_FAMILY_R300,
    CHIP_FAMILY_R350,
    CHIP_FAMILY_RV350,
    CHIP_FAMILY_RV380,    /* RV370/RV380/M22/M24 */
    CHIP_FAMILY_R420,     /* R420/R423/M18 */
    CHIP_FAMILY_RV410,    /* RV410, M26 */
    CHIP_FAMILY_RS400,    /* xpress 200, 200m (RS400) Intel */
    CHIP_FAMILY_RS480,    /* xpress 200, 200m (RS410/480/482/485) AMD */
    CHIP_FAMILY_RV515,    /* rv515 */
    CHIP_FAMILY_R520,    /* r520 */
    CHIP_FAMILY_RV530,    /* rv530 */
    CHIP_FAMILY_R580,    /* r580 */
    CHIP_FAMILY_RV560,   /* rv560 */
    CHIP_FAMILY_RV570,   /* rv570 */
    CHIP_FAMILY_RS600,
    CHIP_FAMILY_RS690,
    CHIP_FAMILY_RS740,
    CHIP_FAMILY_R600,    /* r600 */
    CHIP_FAMILY_R630,
    CHIP_FAMILY_RV610,
    CHIP_FAMILY_RV630,
    CHIP_FAMILY_RV670,
    CHIP_FAMILY_RV620,
    CHIP_FAMILY_RV635,
    CHIP_FAMILY_RS780,
    CHIP_FAMILY_RS880,
    CHIP_FAMILY_RV770,
    CHIP_FAMILY_RV730,
    CHIP_FAMILY_RV710,
    CHIP_FAMILY_LAST
} RADEONChipFamily;

d340 8
d357 6
d375 5
d415 25
d442 8
a449 9
typedef struct {
    uint32_t pci_device_id;
    RADEONChipFamily chip_family;
    int mobility;
    int igp;
    int nocrtc2;
    int nointtvout;
    int singledac;
} RADEONCardInfo;
d451 16
a493 4
#ifdef PER_CONTEXT_SAREA
    drm_context_t ctx_id;
    drm_handle_t sarea_handle;
#else
a495 1
#endif
d513 3
a591 4
#ifdef PER_CONTEXT_SAREA
    int               perctx_sarea_size;
#endif

d607 31
d656 1
d668 7
a676 1
    Bool              has_mask;
d683 3
a685 1

a688 1
    int               vb_index;
d690 12
d704 1
a710 1
    uint32_t          comp_mask_ps_offset;
d713 10
d725 2
a727 5
    uint64_t          src_mc_addr[2];
    uint32_t          src_pitch[2];
    uint32_t          src_width[2];
    uint32_t          src_height[2];
    uint32_t          src_bpp[2];
d729 1
a729 4
    uint64_t          dst_mc_addr;
    uint32_t          dst_pitch;
    uint32_t          dst_height;
    uint32_t          dst_bpp;
a733 2
    uint32_t          vb_size;
    uint64_t          vb_mc_addr;
d738 1
a738 1
    // copy
d740 1
d744 1
d749 4
d803 1
a803 1
    uint32_t          fbLocation;
d843 2
a869 6
    DGAModePtr        DGAModes;
    int               numDGAModes;
    Bool              DGAactive;
    int               DGAViewportStatus;
    DGAFunctionRec    DGAFuncs;

d878 3
d895 2
d930 2
a933 1
    Bool              showCache;
a965 2
    Rotation rotation;
    void (*PointerMoved)(int, int, int);
d985 44
d1110 1
d1112 1
d1139 1
a1139 1
	int crtc, int start, int stop);
d1143 1
a1143 1
	int crtc, int start, int stop);
d1151 2
a1152 1
extern void RADEONComputePLL(RADEONPLLPtr pll, unsigned long freq,
d1155 1
a1171 3
/* radeon_dga.c */
extern Bool RADEONDGAInit(ScreenPtr pScreen);

d1195 1
d1199 1
d1208 19
d1231 1
d1252 3
d1278 1
a1278 1
extern Bool RADEONI2CDoLock(xf86OutputPtr output, Bool lock_state);
d1280 1
d1300 3
d1309 2
a1310 1
			      int align);
d1315 11
d1344 3
a1346 1
    if (info->cp->CPInUse) {						\
d1381 1
a1381 1
    if (!info->cp->CPInUse) {						\
d1412 2
a1413 1
    if (++info->cp->dma_begin_count != 1) {				\
d1416 1
a1416 1
		   info->cp->dma_debug_func, info->cp->dma_debug_lineno);	\
d1418 4
a1421 4
    }									\
    info->cp->dma_debug_func = __FILE__;				\
    info->cp->dma_debug_lineno = __LINE__;				\
    if (!info->cp->indirectBuffer) {					\
d1424 2
a1425 2
    } else if (info->cp->indirectBuffer->used + (n) * (int)sizeof(uint32_t) >	\
	       info->cp->indirectBuffer->total) {		        \
d1427 5
a1432 4
    __expected = n;							\
    __head = (pointer)((char *)info->cp->indirectBuffer->address +	\
		       info->cp->indirectBuffer->used);			\
    __count = 0;							\
d1436 2
a1437 1
    if (info->cp->dma_begin_count-- != 1) {				\
d1442 2
a1443 2
    }									\
    if (__count != __expected) {					\
d1447 2
a1448 2
    }									\
    if (RADEON_VERBOSE) {						\
d1454 2
d1457 1
a1457 2
    info->cp->indirectBuffer->used += __count * (int)sizeof(uint32_t);	\
} while (0)
d1464 1
d1474 8
d1487 3
a1489 1
    if (info->cp->indirectBuffer)					\
d1565 7
d1577 2
d1580 2
a1581 1
	    flush = 1;                                                  \
d1583 1
d1586 6
a1591 2
	if (flush && info->directRenderingEnabled)                      \
	    RADEONCPFlushIndirect(pScrn, 1);                            \
d1600 2
d1603 2
a1604 1
	    flush = 1;                                                  \
d1606 1
d1610 3
a1612 1
	    if (info->directRenderingEnabled)				\
d1614 2
a1616 1
	}                                                               \
d1664 5
@


1.6
log
@Update to xf86-video-ati 6.14.3. Tested by many.
@
text
@a77 1
#include "radeon_drm.h"
a87 9
#ifdef XF86DRM_MODE
#include "radeon_bo.h"
#include "radeon_cs.h"
#include "radeon_dri2.h"
#include "drmmode_display.h"
#else
#include "radeon_dummy_bufmgr.h"
#endif

a92 1
#include "simple_list.h"
a165 1
    OPTION_EXA_PIXMAPS,
a168 1
    OPTION_CUSTOM_EDID,
d189 1
a189 1
    OPTION_CLOCK_GATING,
d210 1
a210 6
    OPTION_R4XX_ATOM,
    OPTION_FORCE_LOW_POWER,
    OPTION_DYNAMIC_PM,
    OPTION_NEW_PLL,
    OPTION_ZAPHOD_HEADS,
    OPTION_SWAPBUFFERS_WAIT
d220 1
a220 2
#define RADEON_GPU_PAGE_SIZE 4096
#define RADEON_BUFFER_ALIGN (RADEON_GPU_PAGE_SIZE - 1)
a261 3
#define RADEON_PLL_USE_FRAC_FB_DIV      (1 << 10)
#define RADEON_PLL_PREFER_CLOSEST_LOWER (1 << 11)
#define RADEON_PLL_USE_POST_DIV    (1 << 12)
d264 2
a265 3
    uint32_t          reference_freq;
    uint32_t          reference_div;
    uint32_t          post_div;
a277 2
    uint32_t          min_frac_feedback_div;
    uint32_t          max_frac_feedback_div;
d291 44
a358 8
#define IS_DCE4_VARIANT ((info->ChipFamily >= CHIP_FAMILY_CEDAR))

#define IS_DCE41_VARIANT ((info->ChipFamily >= CHIP_FAMILY_PALM))

#define IS_DCE5_VARIANT ((info->ChipFamily >= CHIP_FAMILY_BARTS))

#define IS_EVERGREEN_3D (info->ChipFamily >= CHIP_FAMILY_CEDAR)

a367 6
#define IS_R400_3D ((info->ChipFamily == CHIP_FAMILY_R420)  ||  \
	(info->ChipFamily == CHIP_FAMILY_RV410) ||  \
	(info->ChipFamily == CHIP_FAMILY_RS690) ||  \
	(info->ChipFamily == CHIP_FAMILY_RS600) ||  \
	(info->ChipFamily == CHIP_FAMILY_RS740))

a379 5
#define IS_R200_3D ((info->ChipFamily == CHIP_FAMILY_RV250) || \
	(info->ChipFamily == CHIP_FAMILY_RV280) || \
	(info->ChipFamily == CHIP_FAMILY_RS300) || \
	(info->ChipFamily == CHIP_FAMILY_R200))

d415 1
a415 13
typedef enum {
	POWER_DEFAULT,
	POWER_LOW,
	POWER_HIGH
} RADEONPMType;

typedef struct {
    RADEONPMType type;
    uint32_t sclk;
    uint32_t mclk;
    uint32_t pcie_lanes;
    uint32_t flags;
} RADEONPowerMode;
d418 8
a425 11
    /* power modes */
    int num_modes;
    int current_mode;
    RADEONPowerMode mode[3];

    Bool     clock_gating_enabled;
    Bool     dynamic_mode_enabled;
    Bool     force_low_power_enabled;
} RADEONPowerManagement;

typedef struct _atomBiosHandle *atomBiosHandlePtr;
a426 25
struct radeon_exa_pixmap_priv {
    struct radeon_bo *bo;
    uint32_t tiling_flags;
    Bool bo_mapped;
};

#define RADEON_2D_EXA_COPY 1
#define RADEON_2D_EXA_SOLID 2

struct radeon_2d_state {
    int op; //
    uint32_t dst_pitch_offset;
    uint32_t src_pitch_offset;
    uint32_t dp_gui_master_cntl;
    uint32_t dp_cntl;
    uint32_t dp_write_mask;
    uint32_t dp_brush_frgd_clr;
    uint32_t dp_brush_bkgd_clr;
    uint32_t dp_src_frgd_clr;
    uint32_t dp_src_bkgd_clr;
    uint32_t default_sc_bottom_right;
    struct radeon_bo *dst_bo;
    struct radeon_bo *src_bo;
};
    
d454 4
d460 1
d554 4
a572 31
#define DMA_BO_FREE_TIME 1000

struct radeon_dma_bo {
    struct radeon_dma_bo *next, *prev;
    struct radeon_bo  *bo;
    int expire_counter;
};

struct r600_accel_object {
    uint32_t pitch;
    uint32_t width;
    uint32_t height;
    uint32_t offset;
    int bpp;
    uint32_t domain;
    struct radeon_bo *bo;
    uint32_t tiling_flags;
};

struct radeon_vbo_object {
    int               vb_offset;
    uint64_t          vb_mc_addr;
    int               vb_total;
    void              *vb_ptr;
    uint32_t          vb_size;
    uint32_t          vb_op_vert_size;
    int32_t           vb_start_op;
    struct radeon_bo *vb_bo;
    unsigned          verts_per_op;
};

a590 1
    Bool              allowHWDFS;
a601 7
    int               composite_op;
    PicturePtr        dst_pic;
    PicturePtr        msk_pic;
    PicturePtr        src_pic;
    PixmapPtr         dst_pix;
    PixmapPtr         msk_pix;
    PixmapPtr         src_pix;
d604 1
d611 1
a611 3
    uint32_t          *draw_header;
    unsigned          vtx_count;
    unsigned          num_vtx;
d615 1
a616 12
    struct radeon_vbo_object vbo;
    struct radeon_vbo_object cbuf;

    /* where to discard IB from if we cancel operation */
    uint32_t          ib_reset_op;
#ifdef XF86DRM_MODE
    struct radeon_dma_bo bo_free;
    struct radeon_dma_bo bo_wait;
    struct radeon_dma_bo bo_reserved;
    Bool use_vbos;
#endif
    void (*finish_op)(ScrnInfoPtr, int);
a618 1
    struct radeon_bo  *shaders_bo;
d625 1
a627 10
    // shader consts
    uint32_t          solid_vs_const_offset;
    uint32_t          solid_ps_const_offset;
    uint32_t          copy_vs_const_offset;
    uint32_t          copy_ps_const_offset;
    uint32_t          comp_vs_const_offset;
    uint32_t          comp_ps_const_offset;
    uint32_t          comp_mask_ps_const_offset;
    uint32_t          xv_vs_const_offset;
    uint32_t          xv_ps_const_offset;
a629 2
    struct r600_accel_object src_obj[2];
    struct r600_accel_object dst_obj;
d631 5
d637 4
a640 1

d645 2
d651 1
a651 1
    // solid/copy
a652 1
    struct radeon_bo  *copy_area_bo;
a655 1
    uint32_t          fg;
a659 4
    // vline
    xf86CrtcPtr       vline_crtc;
    int               vline_y1;
    int               vline_y2;
d710 1
a710 1
    uint64_t          fbLocation;
a749 2
    int               default_dispclk;
    int               dp_extclk;
d775 6
a788 3
#ifdef XF86DRM_MODE
    struct radeon_dri2  dri2;
#endif
a802 2
    Bool	      exa_pixmaps;
    Bool              exa_force_create;
a835 2
    unsigned int xv_max_width;
    unsigned int xv_max_height;
d838 1
d871 2
a891 44
    /* pm */
    RADEONPowerManagement pm;

    /* igp info */
    float igp_sideport_mclk;
    float igp_system_mclk;
    float igp_ht_link_clk;
    float igp_ht_link_width;

    int can_resize;
    void (*reemit_current2d)(ScrnInfoPtr pScrn, int op); // emit the current 2D state into the IB 
    struct radeon_2d_state state_2d;
    Bool kms_enabled;
    struct radeon_bo *front_bo;
#ifdef XF86DRM_MODE
    struct radeon_bo_manager *bufmgr;
    struct radeon_cs_manager *csm;
    struct radeon_cs *cs;

    struct radeon_bo *cursor_bo[6];
    uint64_t vram_size;
    uint64_t gart_size;
    drmmode_rec drmmode;
    /* r6xx+ tile config */
    Bool have_tiling_info;
    uint32_t tile_config;
    int group_bytes;
    int num_channels;
    int num_banks;
    int r7xx_bank_op;
#else
    /* fake bool */
    Bool cs;
#endif

    /* Xv bicubic filtering */
    struct radeon_bo *bicubic_bo;
    void             *bicubic_memory;
    int               bicubic_offset;
    /* kms pageflipping */
    Bool allowPageFlip;

    /* Perform vsync'ed SwapBuffers? */
    Bool swapBuffersWait;
a972 1
uint32_t radeonGetPixmapOffset(PixmapPtr pPix);
a973 1
extern int radeon_cs_space_remaining(ScrnInfoPtr pScrn);
d1000 1
a1000 1
				 xf86CrtcPtr crtc, int start, int stop);
d1004 1
a1004 1
				   xf86CrtcPtr crtc, int start, int stop);
d1012 1
a1012 2
extern void RADEONComputePLL(xf86CrtcPtr crtc,
			     RADEONPLLPtr pll, unsigned long freq,
a1014 1
			     uint32_t *chosen_frac_feedback_div,
d1031 3
a1056 1
extern unsigned R600INPCIE_PORT(ScrnInfoPtr pScrn, int addr);
a1059 1
extern void R600OUTPCIE_PORT(ScrnInfoPtr pScrn, int addr, uint32_t data);
a1067 19
extern Bool
RADEONZaphodStringMatches(ScrnInfoPtr pScrn, const char *s, char *output_name);

Bool RADEONGetRec(ScrnInfoPtr pScrn);
void RADEONFreeRec(ScrnInfoPtr pScrn);
Bool RADEONPreInitVisual(ScrnInfoPtr pScrn);
Bool RADEONPreInitWeight(ScrnInfoPtr pScrn);

extern Bool RADEON_DP_I2CInit(ScrnInfoPtr pScrn, I2CBusPtr *bus_ptr,
			      char *name, xf86OutputPtr output);
extern void RADEON_DP_GetDPCD(xf86OutputPtr output);
extern int RADEON_DP_GetSinkType(xf86OutputPtr output);

/* radeon_pm.c */
extern void RADEONPMInit(ScrnInfoPtr pScrn);
extern void RADEONPMBlockHandler(ScrnInfoPtr pScrn);
extern void RADEONPMEnterVT(ScrnInfoPtr pScrn);
extern void RADEONPMLeaveVT(ScrnInfoPtr pScrn);
extern void RADEONPMFini(ScrnInfoPtr pScrn);
a1071 1
extern Bool radeon_transform_is_affine_or_scaled(PictTransformPtr t);
a1091 3
#ifdef XF86DRM_MODE
extern Bool EVERGREENDrawInit(ScreenPtr pScreen);
#endif
d1115 1
a1115 1
extern Bool RADEONI2CDoLock(xf86OutputPtr output, I2CBusPtr b, Bool lock_state);
a1116 1
extern Bool radeon_dp_mode_fixup(xf86OutputPtr output, DisplayModePtr mode, DisplayModePtr adjusted_mode);
a1135 3
extern Bool radeon_load_bicubic_texture(ScrnInfoPtr pScrn);
extern xf86CrtcPtr radeon_pick_best_crtc(ScrnInfoPtr pScrn,
					 int x1, int x2, int y1, int y2);
d1142 1
a1142 2
			      int align,
			      int domain);
a1146 11
#ifdef XF86DRM_MODE
extern void radeon_cs_flush_indirect(ScrnInfoPtr pScrn);
extern void radeon_ddx_cs_start(ScrnInfoPtr pScrn,
				int num, const char *file,
				const char *func, int line);
void radeon_kms_update_vram_limit(ScrnInfoPtr pScrn, int new_fb_size);
#endif
struct radeon_bo *radeon_get_pixmap_bo(PixmapPtr pPix);
void radeon_set_pixmap_bo(PixmapPtr pPix, struct radeon_bo *bo);
uint32_t radeon_get_pixmap_tiling(PixmapPtr pPix);

d1165 1
a1165 3
    if (info->cs) {							\
	radeon_cs_flush_indirect(pScrn);				\
    } else if (info->cp->CPInUse) {					\
d1200 1
a1200 1
    if (!info->cp->CPInUse && !info->cs) {				\
d1231 1
a1231 2
    if (info->cs) { radeon_ddx_cs_start(pScrn, n, __FILE__, __func__, __LINE__); } else { \
      if (++info->cp->dma_begin_count != 1) {				\
d1234 1
a1234 1
		   info->cp->dma_debug_func, info->cp->dma_debug_lineno); \
d1236 4
a1239 4
      }									\
      info->cp->dma_debug_func = __FILE__;				\
      info->cp->dma_debug_lineno = __LINE__;				\
      if (!info->cp->indirectBuffer) {					\
d1242 2
a1243 2
      } else if (info->cp->indirectBuffer->used + (n) * (int)sizeof(uint32_t) >	\
		 info->cp->indirectBuffer->total) {		        \
a1244 5
      }									\
      __expected = n;							\
      __head = (pointer)((char *)info->cp->indirectBuffer->address +	\
			 info->cp->indirectBuffer->used);		\
      __count = 0;							\
d1246 4
d1253 1
a1253 2
    if (info->cs) radeon_cs_end(info->cs, __FILE__, __func__, __LINE__); else {		\
      if (info->cp->dma_begin_count-- != 1) {				\
d1258 2
a1259 2
      }									\
      if (__count != __expected) {					\
d1263 2
a1264 2
      }									\
      if (RADEON_VERBOSE) {						\
a1269 2
      }									\
      info->cp->indirectBuffer->used += __count * (int)sizeof(uint32_t); \
d1271 2
a1272 1
  } while (0)
a1278 1
    if (info->cs) radeon_cs_write_dword(info->cs, (x)); else		\
a1287 8
#define OUT_RING_RELOC(x, read_domains, write_domain)			\
  do {									\
	int _ret; \
    _ret = radeon_cs_write_reloc(info->cs, x, read_domains, write_domain, 0); \
	if (_ret) ErrorF("reloc emit failure %d\n", _ret); \
  } while(0)


d1293 1
a1293 3
    if (info->cs)							\
	radeon_cs_flush_indirect(pScrn); 				\
    else if (info->cp->indirectBuffer)					\
a1368 7

#ifdef XF86DRM_MODE
#define CS_FULL(cs) ((cs)->cdw > 15 * 1024)
#else
#define CS_FULL(cs) FALSE
#endif

d1374 1
a1375 4
	    break;							\
	case EXA_ENGINEMODE_3D:						\
	    flush = !info->cs || CS_FULL(info->cs);			\
	    break;							\
a1376 1
	    flush = info->cs && CS_FULL(info->cs);			\
d1379 2
a1380 6
	if (flush) {							\
    	    if (info->cs)						\
	        radeon_cs_flush_indirect(pScrn);			\
            else if (info->directRenderingEnabled)                     	\
	        RADEONCPFlushIndirect(pScrn, 1);                        \
	}								\
d1389 1
a1390 4
	    break;							\
	case EXA_ENGINEMODE_2D:						\
	    flush = !info->cs || CS_FULL(info->cs);			\
	    break;							\
a1391 1
	    flush = info->cs && CS_FULL(info->cs);			\
d1395 1
a1395 3
    	    if (info->cs)						\
	        radeon_cs_flush_indirect(pScrn);			\
	    else if (info->directRenderingEnabled)				\
d1397 1
a1398 2
	if (!info->accel_state->XInited3D)				\
	    RADEONInit3DEngine(pScrn);                                  \
a1445 5

enum {
    RADEON_CREATE_PIXMAP_TILING_MACRO = 0x10000000,
    RADEON_CREATE_PIXMAP_TILING_MICRO = 0x20000000,
};
@


1.5
log
@update do xf86-video-ati 6.12.2

This has been in snapshots for weeks. ok oga@@, todd@@.
@
text
@d78 1
d89 9
d103 1
d177 1
d181 1
d202 1
a202 1
    OPTION_DYNAMIC_CLOCKS,
d223 6
a228 1
    OPTION_R4XX_ATOM
d238 2
a239 1
#define RADEON_BUFFER_ALIGN 0x00000fff
d281 3
d286 3
a288 2
    uint16_t          reference_freq;
    uint16_t          reference_div;
d301 2
a315 44
typedef enum {
    CHIP_FAMILY_UNKNOW,
    CHIP_FAMILY_LEGACY,
    CHIP_FAMILY_RADEON,
    CHIP_FAMILY_RV100,
    CHIP_FAMILY_RS100,    /* U1 (IGP320M) or A3 (IGP320)*/
    CHIP_FAMILY_RV200,
    CHIP_FAMILY_RS200,    /* U2 (IGP330M/340M/350M) or A4 (IGP330/340/345/350), RS250 (IGP 7000) */
    CHIP_FAMILY_R200,
    CHIP_FAMILY_RV250,
    CHIP_FAMILY_RS300,    /* RS300/RS350 */
    CHIP_FAMILY_RV280,
    CHIP_FAMILY_R300,
    CHIP_FAMILY_R350,
    CHIP_FAMILY_RV350,
    CHIP_FAMILY_RV380,    /* RV370/RV380/M22/M24 */
    CHIP_FAMILY_R420,     /* R420/R423/M18 */
    CHIP_FAMILY_RV410,    /* RV410, M26 */
    CHIP_FAMILY_RS400,    /* xpress 200, 200m (RS400) Intel */
    CHIP_FAMILY_RS480,    /* xpress 200, 200m (RS410/480/482/485) AMD */
    CHIP_FAMILY_RV515,    /* rv515 */
    CHIP_FAMILY_R520,    /* r520 */
    CHIP_FAMILY_RV530,    /* rv530 */
    CHIP_FAMILY_R580,    /* r580 */
    CHIP_FAMILY_RV560,   /* rv560 */
    CHIP_FAMILY_RV570,   /* rv570 */
    CHIP_FAMILY_RS600,
    CHIP_FAMILY_RS690,
    CHIP_FAMILY_RS740,
    CHIP_FAMILY_R600,    /* r600 */
    CHIP_FAMILY_R630,
    CHIP_FAMILY_RV610,
    CHIP_FAMILY_RV630,
    CHIP_FAMILY_RV670,
    CHIP_FAMILY_RV620,
    CHIP_FAMILY_RV635,
    CHIP_FAMILY_RS780,
    CHIP_FAMILY_RS880,
    CHIP_FAMILY_RV770,
    CHIP_FAMILY_RV730,
    CHIP_FAMILY_RV710,
    CHIP_FAMILY_LAST
} RADEONChipFamily;

d340 8
d357 6
d375 5
d415 25
d442 8
a449 9
typedef struct {
    uint32_t pci_device_id;
    RADEONChipFamily chip_family;
    int mobility;
    int igp;
    int nocrtc2;
    int nointtvout;
    int singledac;
} RADEONCardInfo;
d451 16
a493 4
#ifdef PER_CONTEXT_SAREA
    drm_context_t ctx_id;
    drm_handle_t sarea_handle;
#else
a495 1
#endif
a588 4
#ifdef PER_CONTEXT_SAREA
    int               perctx_sarea_size;
#endif

d604 31
d653 1
d665 7
a673 1
    Bool              has_mask;
d680 3
a682 1

a685 1
    int               vb_index;
d687 12
d701 1
a707 1
    uint32_t          comp_mask_ps_offset;
d710 10
d722 2
a724 5
    uint64_t          src_mc_addr[2];
    uint32_t          src_pitch[2];
    uint32_t          src_width[2];
    uint32_t          src_height[2];
    uint32_t          src_bpp[2];
d726 1
a726 4
    uint64_t          dst_mc_addr;
    uint32_t          dst_pitch;
    uint32_t          dst_height;
    uint32_t          dst_bpp;
a730 2
    uint32_t          vb_size;
    uint64_t          vb_mc_addr;
d735 1
a735 1
    // copy
d737 1
d741 1
d746 4
d800 1
a800 1
    uint32_t          fbLocation;
d840 2
a866 6
    DGAModePtr        DGAModes;
    int               numDGAModes;
    Bool              DGAactive;
    int               DGAViewportStatus;
    DGAFunctionRec    DGAFuncs;

d875 3
d892 2
d927 2
a930 1
    Bool              showCache;
a962 2
    Rotation rotation;
    void (*PointerMoved)(int, int, int);
d982 44
d1107 1
d1109 1
d1136 1
a1136 1
	int crtc, int start, int stop);
d1140 1
a1140 1
	int crtc, int start, int stop);
d1148 2
a1149 1
extern void RADEONComputePLL(RADEONPLLPtr pll, unsigned long freq,
d1152 1
a1168 3
/* radeon_dga.c */
extern Bool RADEONDGAInit(ScreenPtr pScreen);

d1192 1
d1196 1
d1205 19
d1228 1
d1249 3
d1275 1
a1275 1
extern Bool RADEONI2CDoLock(xf86OutputPtr output, Bool lock_state);
d1277 1
d1297 3
d1306 2
a1307 1
			      int align);
d1312 11
d1341 3
a1343 1
    if (info->cp->CPInUse) {						\
d1378 1
a1378 1
    if (!info->cp->CPInUse) {						\
d1409 2
a1410 1
    if (++info->cp->dma_begin_count != 1) {				\
d1413 1
a1413 1
		   info->cp->dma_debug_func, info->cp->dma_debug_lineno);	\
d1415 4
a1418 4
    }									\
    info->cp->dma_debug_func = __FILE__;				\
    info->cp->dma_debug_lineno = __LINE__;				\
    if (!info->cp->indirectBuffer) {					\
d1421 2
a1422 2
    } else if (info->cp->indirectBuffer->used + (n) * (int)sizeof(uint32_t) >	\
	       info->cp->indirectBuffer->total) {		        \
d1424 5
a1429 4
    __expected = n;							\
    __head = (pointer)((char *)info->cp->indirectBuffer->address +	\
		       info->cp->indirectBuffer->used);			\
    __count = 0;							\
d1433 2
a1434 1
    if (info->cp->dma_begin_count-- != 1) {				\
d1439 2
a1440 2
    }									\
    if (__count != __expected) {					\
d1444 2
a1445 2
    }									\
    if (RADEON_VERBOSE) {						\
d1451 2
d1454 1
a1454 2
    info->cp->indirectBuffer->used += __count * (int)sizeof(uint32_t);	\
} while (0)
d1461 1
d1471 8
d1484 3
a1486 1
    if (info->cp->indirectBuffer)					\
d1562 7
d1574 2
d1577 2
a1578 1
	    flush = 1;                                                  \
d1580 1
d1583 6
a1588 2
	if (flush && info->directRenderingEnabled)                      \
	    RADEONCPFlushIndirect(pScrn, 1);                            \
d1597 2
d1600 2
a1601 1
	    flush = 1;                                                  \
d1603 1
d1607 3
a1609 1
	    if (info->directRenderingEnabled)				\
d1611 2
a1613 1
	}                                                               \
d1661 5
@


1.4
log
@don't map the mmio registers via the drm in the radeon DDX either
(companion commit to the mesa one I just made)

ok matthieu@@
@
text
@a74 1
#include "radeon_dripriv.h"
d77 2
d102 30
a167 1
    OPTION_DDC_MODE,
d207 4
a210 1
    OPTION_INT10
d256 6
a261 1
#define RADEON_PLL_PREFER_LOW_REF_DIV (1 << 4)
d328 4
d357 4
d404 2
a405 1
    RADEON_MAC_IMAC_G5_ISIGHT
a426 74
typedef struct {
    EntityInfoPtr     pEnt;
    pciVideoPtr       PciInfo;
    PCITAG            PciTag;
    int               Chipset;
    RADEONChipFamily  ChipFamily;
    RADEONErrata      ChipErrata;

    unsigned long     LinearAddr;       /* Frame buffer physical address     */
    unsigned long     MMIOAddr;         /* MMIO region physical address      */
    unsigned long     BIOSAddr;         /* BIOS physical address             */
    uint32_t          fbLocation;
    uint32_t          gartLocation;
    uint32_t          mc_fb_location;
    uint32_t          mc_agp_location;
    uint32_t          mc_agp_location_hi;

    void              *MMIO;            /* Map of MMIO region                */
    void              *FB;              /* Map of frame buffer               */
    uint8_t           *VBIOS;           /* Video BIOS pointer                */

    Bool              IsAtomBios;       /* New BIOS used in R420 etc.        */
    int               ROMHeaderStart;   /* Start of the ROM Info Table       */
    int               MasterDataStart;  /* Offset for Master Data Table for ATOM BIOS */

    uint32_t          MemCntl;
    uint32_t          BusCntl;
    unsigned long     MMIOSize;         /* MMIO region physical address      */
    unsigned long     FbMapSize;        /* Size of frame buffer, in bytes    */
    unsigned long     FbSecureSize;     /* Size of secured fb area at end of
                                           framebuffer */

    Bool              IsMobility;       /* Mobile chips for laptops */
    Bool              IsIGP;            /* IGP chips */
    Bool              HasSingleDAC;     /* only TVDAC on chip */
    Bool              ddc_mode;         /* Validate mode by matching exactly
					 * the modes supported in DDC data
					 */
    Bool              R300CGWorkaround;

				/* EDID or BIOS values for FPs */
    int               RefDivider;
    int               FeedbackDivider;
    int               PostDivider;
    Bool              UseBiosDividers;
				/* EDID data using DDC interface */
    Bool              ddc_bios;
    Bool              ddc1;
    Bool              ddc2;

    RADEONPLLRec      pll;

    int               RamWidth;
    float	      sclk;		/* in MHz */
    float	      mclk;		/* in MHz */
    Bool	      IsDDR;
    int               DispPriority;

    RADEONSavePtr     SavedReg;         /* Original (text) mode              */
    RADEONSavePtr     ModeReg;          /* Current mode                      */
    Bool              (*CloseScreen)(int, ScreenPtr);

    void              (*BlockHandler)(int, pointer, pointer, pointer);

    Bool              PaletteSavedOnVT; /* Palette saved on last VT switch   */

#ifdef USE_EXA
    ExaDriverPtr      exa;
    int               exaSyncMarker;
    int               exaMarkerSynced;
    int               engineMode;
#define EXA_ENGINEMODE_UNKNOWN 0
#define EXA_ENGINEMODE_2D      1
#define EXA_ENGINEMODE_3D      2
d428 8
a435 15
    Bool              accelDFS;
#endif
#endif
#ifdef USE_XAA
    XAAInfoRecPtr     accel;
#endif
    Bool              accelOn;
    xf86CursorInfoPtr cursor;
    Bool              allowColorTiling;
    Bool              tilingEnabled; /* mirror of sarea->tiling_enabled */
#ifdef ARGB_CURSOR
    Bool	      cursor_argb;
#endif
    int               cursor_fg;
    int               cursor_bg;
d437 3
a439 7
#ifdef USE_XAA
    /*
     * XAAForceTransBlit is used to change the behavior of the XAA
     * SetupForScreenToScreenCopy function, to make it DGA-friendly.
     */
    Bool              XAAForceTransBlit;
#endif
d441 4
a444 3
    int               fifo_slots;       /* Free slots in the FIFO (64 max)   */
    int               pix24bpp;         /* Depth of pixmap for 24bpp fb      */
    Bool              dac6bits;         /* Use 6 bit DAC?                    */
d446 1
a446 6
				/* Computed values for Radeon */
    int               pitch;
    int               datatype;
    uint32_t          dp_gui_master_cntl;
    uint32_t          dp_gui_master_cntl_clip;
    uint32_t          trans_color;
d448 4
a451 3
				/* Saved values for ScreenToScreenCopy */
    int               xdir;
    int               ydir;
d453 7
a459 17
#ifdef USE_XAA
				/* ScanlineScreenToScreenColorExpand support */
    unsigned char     *scratch_buffer[1];
    unsigned char     *scratch_save;
    int               scanline_x;
    int               scanline_y;
    int               scanline_w;
    int               scanline_h;
    int               scanline_h_w;
    int               scanline_words;
    int               scanline_direct;
    int               scanline_bpp;     /* Only used for ImageWrite */
    int               scanline_fg;
    int               scanline_bg;
    int               scanline_hpass;
    int               scanline_x1clip;
    int               scanline_x2clip;
d461 1
a461 5
				/* Saved values for DashedTwoPointLine */
    int               dashLen;
    uint32_t          dashPattern;
    int               dash_fg;
    int               dash_bg;
d463 2
a464 5
    DGAModePtr        DGAModes;
    int               numDGAModes;
    Bool              DGAactive;
    int               DGAViewportStatus;
    DGAFunctionRec    DGAFuncs;
a465 6
    RADEONFBLayout    CurrentLayout;
    uint32_t          dst_pitch_offset;
#ifdef XF86DRI
    Bool              noBackBuffer;	
    Bool              directRenderingEnabled;
    Bool              directRenderingInited;
a477 1
    RADEONCardType    cardType;            /* Current card is a PCI card */
d499 1
a499 9
    Bool              CPRuns;           /* CP is running */
    Bool              CPInUse;          /* CP has been used by X server */
    Bool              CPStarted;        /* CP has started */
    int               CPMode;           /* CP mode that server/clients use */
    int               CPFifoSize;       /* Size of the CP command FIFO */
    int               CPusecTimeout;    /* CP timeout in usecs */
    Bool              needCacheFlush;

				/* CP ring buffer data */
d512 1
a512 1
				/* CP vertex/indirect buffer data */
d521 1
a521 1
				/* CP GART Texture data */
d529 1
a529 5
				/* CP accleration */
    drmBufPtr         indirectBuffer;
    int               indirectStart;

				/* DRI screen private data */
d551 7
d563 1
a563 1
				/* offscreen memory management */
d570 2
a571 5
				/* Saved scissor values */
    uint32_t          sc_left;
    uint32_t          sc_right;
    uint32_t          sc_top;
    uint32_t          sc_bottom;
d573 11
a583 2
    uint32_t          re_top_left;
    uint32_t          re_width_height;
d585 6
a590 1
    uint32_t          aux_sc_cntl;
d592 170
a761 1
    int               irq;
d763 1
a763 1
    Bool              DMAForXv;
d765 3
a767 2
#ifdef PER_CONTEXT_SAREA
    int               perctx_sarea_size;
d769 13
d783 10
a792 4
    /* Debugging info for BEGIN_RING/ADVANCE_RING pairs. */
    int               dma_begin_count;
    char              *dma_debug_func;
    int               dma_debug_lineno;
d795 14
a836 10
    /* Render */
    Bool              RenderAccel;
    unsigned short    texW[2];
    unsigned short    texH[2];
#ifdef USE_XAA
    FBLinearPtr       RenderTex;
    void              (*RenderCallback)(ScrnInfoPtr);
    Time              RenderTimeout;
#endif

a840 11
    Bool              useEXA;
#ifdef USE_EXA
    XF86ModReqInfo    exaReq;
#endif
#ifdef USE_XAA
    XF86ModReqInfo    xaaReq;
#endif

    /* X itself has the 3D context */
    Bool              XInited3D;

d844 1
a844 1
    Bool              IsDellServer; 
a850 3
    uint32_t          tv_dac_adj;
    uint32_t          tv_dac_enable_mask;

d853 1
a860 1
    int               tvdac_use_count;
a870 8
    /* output enable masks for outputs shared across connectors */
    int output_crt1;
    int output_crt2;
    int output_dfp1;
    int output_dfp2;
    int output_lcd1;
    int output_tv1;

d884 8
a891 2
    int num_gb_pipes;
    Bool has_tcl;
d896 1
a896 1
    if (info->fifo_slots < entries)					\
d898 1
a898 1
    info->fifo_slots -= entries;					\
a904 1
extern void RADEONInitDispBandwidth(ScrnInfoPtr pScrn);
d922 1
a922 2
extern RADEONMonitorType legacy_dac_detect(ScrnInfoPtr pScrn,
					   xf86OutputPtr output);
d937 6
d985 3
a987 3
extern Bool RADEONGetDAC2InfoFromBIOS(xf86OutputPtr output);
extern Bool RADEONGetExtTMDSInfoFromBIOS(xf86OutputPtr output);
extern Bool RADEONGetHardCodedEDIDFromBIOS(xf86OutputPtr output);
d989 2
a990 2
extern Bool RADEONGetLVDSInfoFromBIOS(xf86OutputPtr output);
extern Bool RADEONGetTMDSInfoFromBIOS(xf86OutputPtr output);
d994 1
d999 2
d1003 2
d1021 1
d1056 1
d1059 1
d1090 2
d1115 2
d1137 10
d1155 1
a1155 1
    int _ret = drmCommandNone(info->drmFD, DRM_RADEON_CP_START);	\
d1160 1
a1160 1
    info->CPStarted = TRUE;                                             \
d1165 1
a1165 1
    if (info->CPInUse) {						\
d1169 1
a1169 1
	info->CPInUse = FALSE;						\
d1176 1
a1176 1
     if (info->CPStarted) {						\
d1182 5
a1186 4
        info->CPStarted = FALSE;                                        \
   }									\
    RADEONEngineRestore(pScrn);						\
    info->CPRuns = FALSE;						\
d1191 1
a1191 2
    if (RADEONCP_USE_RING_BUFFER(info->CPMode)) {			\
	int _ret = drmCommandNone(info->drmFD, DRM_RADEON_CP_RESET);	\
a1195 1
    }									\
d1200 2
a1201 2
    if (!info->CPInUse) {						\
	if (info->needCacheFlush) {					\
d1204 1
a1204 1
	    info->needCacheFlush = FALSE;				\
d1207 1
a1207 13
        if (info->ChipFamily <= CHIP_FAMILY_RV280) {                    \
	    BEGIN_RING(6);						\
	    OUT_RING_REG(RADEON_RE_TOP_LEFT,     info->re_top_left);	\
	    OUT_RING_REG(RADEON_RE_WIDTH_HEIGHT, info->re_width_height); \
	    OUT_RING_REG(RADEON_AUX_SC_CNTL,     info->aux_sc_cntl);	\
	    ADVANCE_RING();						\
        } else {                                                        \
            BEGIN_RING(4);                                              \
            OUT_RING_REG(R300_SC_SCISSOR0, info->re_top_left);          \
	    OUT_RING_REG(R300_SC_SCISSOR1, info->re_width_height);      \
            ADVANCE_RING();                                             \
	}                                                               \
	info->CPInUse = TRUE;						\
d1231 1
a1231 1
    if (++info->dma_begin_count != 1) {					\
d1234 2
a1235 2
		   info->dma_debug_func, info->dma_debug_lineno);	\
	info->dma_begin_count = 1;					\
d1237 7
a1243 7
    info->dma_debug_func = __FILE__;					\
    info->dma_debug_lineno = __LINE__;					\
    if (!info->indirectBuffer) {					\
	info->indirectBuffer = RADEONCPGetBuffer(pScrn);		\
	info->indirectStart = 0;					\
    } else if (info->indirectBuffer->used + (n) * (int)sizeof(uint32_t) >	\
	       info->indirectBuffer->total) {				\
d1247 2
a1248 2
    __head = (pointer)((char *)info->indirectBuffer->address +		\
		       info->indirectBuffer->used);			\
d1253 1
a1253 1
    if (info->dma_begin_count-- != 1) {					\
d1257 1
a1257 1
	info->dma_begin_count = 0;					\
d1267 2
a1268 2
		   info->indirectStart,					\
		   info->indirectBuffer->used,				\
d1271 1
a1271 1
    info->indirectBuffer->used += __count * (int)sizeof(uint32_t);	\
d1293 1
a1293 1
    if (info->indirectBuffer) {						\
a1294 1
    }									\
d1300 7
a1306 5
    BEGIN_RING(2);							\
    OUT_RING(CP_PACKET0(RADEON_WAIT_UNTIL, 0));				\
    OUT_RING((RADEON_WAIT_2D_IDLECLEAN |				\
	      RADEON_WAIT_HOST_IDLECLEAN));				\
    ADVANCE_RING();							\
d1311 7
a1317 5
    BEGIN_RING(2);							\
    OUT_RING(CP_PACKET0(RADEON_WAIT_UNTIL, 0));				\
    OUT_RING((RADEON_WAIT_3D_IDLECLEAN |				\
	      RADEON_WAIT_HOST_IDLECLEAN));				\
    ADVANCE_RING();							\
d1326 8
a1333 6
    BEGIN_RING(2);							\
    OUT_RING(CP_PACKET0(RADEON_WAIT_UNTIL, 0));				\
    OUT_RING((RADEON_WAIT_2D_IDLECLEAN |				\
	      RADEON_WAIT_3D_IDLECLEAN |				\
	      RADEON_WAIT_HOST_IDLECLEAN));				\
    ADVANCE_RING();							\
d1338 11
a1348 9
    BEGIN_RING(2);							\
    if (info->ChipFamily <= CHIP_FAMILY_RV280) {                        \
        OUT_RING(CP_PACKET0(RADEON_RB3D_DSTCACHE_CTLSTAT, 0));		\
        OUT_RING(RADEON_RB3D_DC_FLUSH_ALL);				\
    } else {                                                            \
        OUT_RING(CP_PACKET0(R300_RB3D_DSTCACHE_CTLSTAT, 0));		\
        OUT_RING(R300_RB3D_DC_FLUSH_ALL);				\
    }                                                                   \
    ADVANCE_RING();							\
d1353 10
a1362 7
    BEGIN_RING(2);							\
    if (info->ChipFamily <= CHIP_FAMILY_RV280) {                        \
        OUT_RING(CP_PACKET0(RADEON_RB3D_ZCACHE_CTLSTAT, 0));		\
        OUT_RING(RADEON_RB3D_ZC_FLUSH_ALL);				\
    } else {                                                            \
        OUT_RING(CP_PACKET0(R300_RB3D_ZCACHE_CTLSTAT, 0));		\
        OUT_RING(R300_ZC_FLUSH_ALL);					\
a1363 1
    ADVANCE_RING();							\
d1368 38
d1414 1
a1414 1
	SET_SYNC_FLAG(info->accel);
d1421 1
a1421 1
    if (info->useEXA)
d1425 2
a1426 2
    if (!info->useEXA && info->accel)
	info->accel->Sync(pScrn);
@


1.3
log
@Long awaited update of xf86-video-ati to 6.9.0.

the rage128 and mach64 drivers were split out of this driver just after
the 6.8.0 release, these drivers will be commited separately.

MergedFb mode is gone, so please use xrandr if you used to use it.

ok matthieu@@.
@
text
@a541 3
    drmSize           registerSize;
    drm_handle_t      registerHandle;

@


1.2
log
@OpenBSD modification: IBookHack option.
@
text
@a0 1
/* $XFree86: xc/programs/Xserver/hw/xfree86/drivers/ati/radeon.h,v 1.43 2003/11/06 18:38:00 tsi Exp $ */
d42 1
d44 1
d70 2
d78 4
d84 3
d92 19
d132 1
a136 1
    OPTION_PANEL_OFF,
a137 1
    OPTION_MONITOR_LAYOUT,
a138 11
    OPTION_FBDEV,
    OPTION_MERGEDFB,
    OPTION_CRT2HSYNC,
    OPTION_CRT2VREFRESH,
    OPTION_CRT2POS,
    OPTION_METAMODES,
    OPTION_MERGEDDPI,
    OPTION_RADEONXINERAMA,
    OPTION_CRT2ISSCRN0,
    OPTION_MERGEDFBNONRECT,
    OPTION_MERGEDFBMOUSER,
d152 1
d165 13
a177 4
    OPTION_CONSTANTDPI,
#ifdef __powerpc__
    OPTION_IBOOKHACKS
#endif
a179 24
/* ------- mergedfb support ------------- */
		/* Psuedo Xinerama support */
#define NEED_REPLIES  		/* ? */
#define EXTENSION_PROC_ARGS void *
#include "extnsionst.h"  	/* required */
#include <X11/extensions/panoramiXproto.h>  	/* required */
#define RADEON_XINERAMA_MAJOR_VERSION  1
#define RADEON_XINERAMA_MINOR_VERSION  1


/* Relative merge position */
typedef enum {
   radeonLeftOf,
   radeonRightOf,
   radeonAbove,
   radeonBelow,
   radeonClone
} RADEONScrn2Rel;

typedef struct _region {
    int x0,x1,y0,y1;
} region;

/* ------------------------------------- */
a180 1
#define RADEON_DEBUG            1 /* Turn off debugging output               */
d184 2
d194 3
a196 9
#if RADEON_DEBUG
#define RADEONTRACE(x)						\
do {									\
    ErrorF("(**) %s(%d): ", RADEON_NAME, pScrn->scrnIndex);		\
    ErrorF x;								\
} while(0)
#else
#define RADEONTRACE(x) do { } while(0)
#endif
d198 2
a205 1

d207 17
a223 109
				/* Common registers */
    CARD32            ovr_clr;
    CARD32            ovr_wid_left_right;
    CARD32            ovr_wid_top_bottom;
    CARD32            ov0_scale_cntl;
    CARD32            mpp_tb_config;
    CARD32            mpp_gp_config;
    CARD32            subpic_cntl;
    CARD32            viph_control;
    CARD32            i2c_cntl_1;
    CARD32            gen_int_cntl;
    CARD32            cap0_trig_cntl;
    CARD32            cap1_trig_cntl;
    CARD32            bus_cntl;
    CARD32            bios_4_scratch;
    CARD32            bios_5_scratch;
    CARD32            bios_6_scratch;
    CARD32            surface_cntl;
    CARD32            surfaces[8][3];
    CARD32            mc_agp_location;
    CARD32            mc_fb_location;
    CARD32            display_base_addr;
    CARD32            display2_base_addr;
    CARD32            ov0_base_addr;

				/* Other registers to save for VT switches */
    CARD32            dp_datatype;
    CARD32            rbbm_soft_reset;
    CARD32            clock_cntl_index;
    CARD32            amcgpio_en_reg;
    CARD32            amcgpio_mask;

				/* CRTC registers */
    CARD32            crtc_gen_cntl;
    CARD32            crtc_ext_cntl;
    CARD32            dac_cntl;
    CARD32            crtc_h_total_disp;
    CARD32            crtc_h_sync_strt_wid;
    CARD32            crtc_v_total_disp;
    CARD32            crtc_v_sync_strt_wid;
    CARD32            crtc_offset;
    CARD32            crtc_offset_cntl;
    CARD32            crtc_pitch;
    CARD32            disp_merge_cntl;
    CARD32            grph_buffer_cntl;
    CARD32            crtc_more_cntl;

				/* CRTC2 registers */
    CARD32            crtc2_gen_cntl;

    CARD32            dac2_cntl;
    CARD32            disp_output_cntl;
    CARD32            disp_hw_debug;
    CARD32            disp2_merge_cntl;
    CARD32            grph2_buffer_cntl;
    CARD32            crtc2_h_total_disp;
    CARD32            crtc2_h_sync_strt_wid;
    CARD32            crtc2_v_total_disp;
    CARD32            crtc2_v_sync_strt_wid;
    CARD32            crtc2_offset;
    CARD32            crtc2_offset_cntl;
    CARD32            crtc2_pitch;
				/* Flat panel registers */
    CARD32            fp_crtc_h_total_disp;
    CARD32            fp_crtc_v_total_disp;
    CARD32            fp_gen_cntl;
    CARD32            fp2_gen_cntl;
    CARD32            fp_h_sync_strt_wid;
    CARD32            fp2_h_sync_strt_wid;
    CARD32            fp_horz_stretch;
    CARD32            fp_panel_cntl;
    CARD32            fp_v_sync_strt_wid;
    CARD32            fp2_v_sync_strt_wid;
    CARD32            fp_vert_stretch;
    CARD32            lvds_gen_cntl;
    CARD32            lvds_pll_cntl;
    CARD32            tmds_pll_cntl;
    CARD32            tmds_transmitter_cntl;

				/* Computed values for PLL */
    CARD32            dot_clock_freq;
    CARD32            pll_output_freq;
    int               feedback_div;
    int               post_div;

				/* PLL registers */
    unsigned          ppll_ref_div;
    unsigned          ppll_div_3;
    CARD32            htotal_cntl;

				/* Computed values for PLL2 */
    CARD32            dot_clock_freq_2;
    CARD32            pll_output_freq_2;
    int               feedback_div_2;
    int               post_div_2;

				/* PLL2 registers */
    CARD32            p2pll_ref_div;
    CARD32            p2pll_div_0;
    CARD32            htotal_cntl2;

				/* Pallet */
    Bool              palette_valid;
    CARD32            palette[256];
    CARD32            palette2[256];

    CARD32            tv_dac_cntl;

} RADEONSaveRec, *RADEONSavePtr;
d226 15
a240 5
    CARD16            reference_freq;
    CARD16            reference_div;
    CARD32            min_pll_freq;
    CARD32            max_pll_freq;
    CARD16            xclk;
d271 19
a289 1
    CHIP_FAMILY_RS400,    /* xpress 200, 200m (RS400/410/480) */
d308 25
a332 1
        (info->ChipFamily == CHIP_FAMILY_RS400))
d344 19
d368 2
d371 8
a378 3
    CARD32 freq;
    CARD32 value;
}RADEONTMDSPll;
a387 2
    Bool              FBDev;

d391 9
a399 8
    CARD32            fbLocation;
    CARD32            gartLocation;
    CARD32            mc_fb_location;
    CARD32            mc_agp_location;

    unsigned char     *MMIO;            /* Map of MMIO region                */
    unsigned char     *FB;              /* Map of frame buffer               */
    CARD8             *VBIOS;           /* Video BIOS pointer                */
d405 2
a406 2
    CARD32            MemCntl;
    CARD32            BusCntl;
a410 1
    int               Flags;            /* Saved copy of mode flags          */
a411 5
				/* VE/M6 support */
    RADEONMonitorType DisplayType;      /* Monitor connected on              */
    RADEONDDCType     DDCType;
    RADEONConnectorType ConnectorType;
    Bool              HasCRTC2;         /* All cards except original Radeon  */
a414 5
    Bool              IsSecondary;      /* Second Screen                     */
    Bool	      IsPrimary;        /* Primary Screen */
    Bool              IsSwitching;      /* Flag for switching mode           */
    Bool              OverlayOnCRTC2;
    Bool              PanelOff;         /* Force panel (LCD/DFP) off         */
a420 10
    int               PanelXRes;
    int               PanelYRes;
    int               HOverPlus;
    int               HSyncWidth;
    int               HBlank;
    int               VOverPlus;
    int               VSyncWidth;
    int               VBlank;
    int               PanelPwrDly;
    int               DotClock;
a428 2
    I2CBusPtr         pI2CBus;
    CARD32            DDCReg;
d431 1
a431 1
    RADEONTMDSPll     tmds_pll[4];
d438 2
a439 2
    RADEONSaveRec     SavedReg;         /* Original (text) mode              */
    RADEONSaveRec     ModeReg;          /* Current mode                      */
d448 2
a462 4
    CARD32            cursor_offset;
#ifdef USE_XAA
    unsigned long     cursor_end;
#endif
d486 3
a488 3
    CARD32            dp_gui_master_cntl;
    CARD32            dp_gui_master_cntl_clip;
    CARD32            trans_color;
d514 1
a514 1
    CARD32            dashPattern;
d525 1
a525 1
    CARD32            dst_pitch_offset;
d540 1
a540 1
    drm_handle_t         fbHandle;
d543 1
a543 1
    drm_handle_t         registerHandle;
d547 1
a547 1
    drm_handle_t         pciMemHandle;
d552 4
d558 1
d560 1
a560 1
    drm_handle_t         agpMemHandle;     /* Handle from drmAgpAlloc */
a563 1
    int               agpFastWrite;
d565 1
a565 1
    CARD32            pciCommand;
d573 1
d577 1
a577 1
    drm_handle_t         ringHandle;       /* Handle from drmAddMap */
d584 1
a584 1
    drm_handle_t         ringReadPtrHandle; /* Handle from drmAddMap */
d590 1
a590 1
    drm_handle_t         bufHandle;        /* Handle from drmAddMap */
d599 1
a599 1
    drm_handle_t         gartTexHandle;     /* Handle from drmAddMap */
d629 1
a629 1
    CARD32            pciGartOffset;
d632 3
a634 3
    CARD32            frontPitchOffset;
    CARD32            backPitchOffset;
    CARD32            depthPitchOffset;
d644 4
a647 4
    CARD32            sc_left;
    CARD32            sc_right;
    CARD32            sc_top;
    CARD32            sc_bottom;
d649 2
a650 2
    CARD32            re_top_left;
    CARD32            re_width_height;
d652 1
a652 1
    CARD32            aux_sc_cntl;
d677 3
a679 3
	char*			RageTheatreMicrocPath;
	char*			RageTheatreMicrocType;
    Bool               MM_TABLE_valid;
d681 14
a694 12
    	CARD8 table_revision;
	CARD8 table_size;
        CARD8 tuner_type;
        CARD8 audio_chip;
        CARD8 product_id;
        CARD8 tuner_voltage_teletext_fm;
        CARD8 i2s_config; /* configuration of the sound chip */
        CARD8 video_decoder_type;
        CARD8 video_decoder_host_config;
        CARD8 input[5];
    	} MM_TABLE;
    CARD16 video_decoder_type;
d698 2
a710 1
#ifdef XFree86LOADER
a716 1
#endif
d721 1
a721 36
    /* merged fb stuff, also covers clone modes */
    Bool		MergedFB;
    RADEONScrn2Rel	CRT2Position;
    char *		CRT2HSync;
    char *		CRT2VRefresh;
    char *		MetaModes;
    ScrnInfoPtr		CRT2pScrn;
    DisplayModePtr	CRT1Modes;
    DisplayModePtr	CRT1CurrentMode;
    int			CRT1frameX0;
    int			CRT1frameY0;
    int			CRT1frameX1;
    int			CRT1frameY1;
    RADEONMonitorType   MergeType;
    RADEONDDCType       MergeDDCType;
    void        	(*PointerMoved)(int index, int x, int y);
    /* pseudo xinerama support for mergedfb */
    int			maxCRT1_X1, maxCRT1_X2, maxCRT1_Y1, maxCRT1_Y2;
    int			maxCRT2_X1, maxCRT2_X2, maxCRT2_Y1, maxCRT2_Y2;
    int			maxClone_X1, maxClone_X2, maxClone_Y1, maxClone_Y2;
    Bool		UseRADEONXinerama;
    Bool		CRT2IsScrn0;
    ExtensionEntry 	*XineramaExtEntry;
    int			RADEONXineramaVX, RADEONXineramaVY;
    Bool		AtLeastOneNonClone;
    int			MergedFBXDPI, MergedFBYDPI;
    Bool		NoVirtual;
    int                 CRT1XOffs, CRT1YOffs, CRT2XOffs, CRT2YOffs;
    int                 MBXNR1XMAX, MBXNR1YMAX, MBXNR2XMAX, MBXNR2YMAX;
    Bool                NonRect, HaveNonRect, HaveOffsRegions, MouseRestrictions;
    region              NonRectDead, OffDead1, OffDead2;

    int			constantDPI; /* -1 = auto, 0 = off, 1 = on */
    int			RADEONDPIVX, RADEONDPIVY;
    RADEONScrn2Rel	MergedDPISRel;
    int			RADEONMergedDPIVX, RADEONMergedDPIVY, RADEONMergedDPIRot;
d724 3
a726 1
    Bool		IsDellServer; 
d728 2
a729 2
    /* enable bios hotkey output switching */
    Bool		BiosHotkeys;
d731 2
a732 1
    Bool               VGAAccess;
d734 3
a736 2
    int                MaxSurfaceWidth;
    int                MaxLines;
d738 39
d786 60
a845 3
extern RADEONEntPtr RADEONEntPriv(ScrnInfoPtr pScrn);
extern void        RADEONWaitForFifoFunction(ScrnInfoPtr pScrn, int entries);
extern void        RADEONWaitForIdleMMIO(ScrnInfoPtr pScrn);
d847 7
a853 1
extern void        RADEONWaitForIdleCP(ScrnInfoPtr pScrn);
d856 19
a874 12
extern void        RADEONDoAdjustFrame(ScrnInfoPtr pScrn, int x, int y,
				       int clone);

extern void        RADEONEngineReset(ScrnInfoPtr pScrn);
extern void        RADEONEngineFlush(ScrnInfoPtr pScrn);
extern void        RADEONEngineRestore(ScrnInfoPtr pScrn);

extern unsigned    RADEONINPLL(ScrnInfoPtr pScrn, int addr);
extern void        RADEONOUTPLL(ScrnInfoPtr pScrn, int addr, CARD32 data);

extern void        RADEONWaitForVerticalSync(ScrnInfoPtr pScrn);
extern void        RADEONWaitForVerticalSync2(ScrnInfoPtr pScrn);
d876 1
a876 6
extern void        RADEONChangeSurfaces(ScrnInfoPtr pScrn);

extern Bool        RADEONAccelInit(ScreenPtr pScreen);
#ifdef USE_EXA
extern Bool        RADEONSetupMemEXA (ScreenPtr pScreen);
extern Bool        RADEONDrawInitMMIO(ScreenPtr pScreen);
d878 1
a878 5
extern Bool        RADEONDrawInitCP(ScreenPtr pScreen);
#endif
#endif
#ifdef USE_XAA
extern void        RADEONAccelInitMMIO(ScreenPtr pScreen, XAAInfoRecPtr a);
d880 1
a880 3
extern void        RADEONEngineInit(ScrnInfoPtr pScrn);
extern Bool        RADEONCursorInit(ScreenPtr pScreen);
extern Bool        RADEONDGAInit(ScreenPtr pScreen);
d882 23
a904 1
extern void        RADEONInit3DEngine(ScrnInfoPtr pScrn);
d906 2
a907 1
extern int         RADEONMinBits(int val);
d909 32
a940 3
extern void        RADEONInitVideo(ScreenPtr pScreen);
extern void        RADEONResetVideo(ScrnInfoPtr pScrn);
extern void        R300CGWorkaround(ScrnInfoPtr pScrn);
d942 3
a944 2
extern void        RADEONPllErrataAfterIndex(RADEONInfoPtr info);
extern void        RADEONPllErrataAfterData(RADEONInfoPtr info);
d946 59
a1004 6
extern Bool        RADEONGetBIOSInfo(ScrnInfoPtr pScrn, xf86Int10InfoPtr pInt10);
extern Bool        RADEONGetConnectorInfoFromBIOS (ScrnInfoPtr pScrn);
extern Bool        RADEONGetClockInfoFromBIOS (ScrnInfoPtr pScrn);
extern Bool        RADEONGetLVDSInfoFromBIOS (ScrnInfoPtr pScrn);
extern Bool        RADEONGetTMDSInfoFromBIOS (ScrnInfoPtr pScrn);
extern Bool        RADEONGetHardCodedEDIDFromBIOS (ScrnInfoPtr pScrn);
d1007 4
a1010 32
#ifdef USE_XAA
extern void        RADEONAccelInitCP(ScreenPtr pScreen, XAAInfoRecPtr a);
#endif
extern Bool        RADEONDRIGetVersion(ScrnInfoPtr pScrn);
extern Bool        RADEONDRIScreenInit(ScreenPtr pScreen);
extern void        RADEONDRICloseScreen(ScreenPtr pScreen);
extern void        RADEONDRIResume(ScreenPtr pScreen);
extern Bool        RADEONDRIFinishScreenInit(ScreenPtr pScreen);
extern void        RADEONDRIAllocatePCIGARTTable(ScreenPtr pScreen);
extern void	   RADEONDRIInitPageFlip(ScreenPtr pScreen);
extern void        RADEONDRIStop(ScreenPtr pScreen);

extern drmBufPtr   RADEONCPGetBuffer(ScrnInfoPtr pScrn);
extern void        RADEONCPFlushIndirect(ScrnInfoPtr pScrn, int discard);
extern void        RADEONCPReleaseIndirect(ScrnInfoPtr pScrn);
extern int         RADEONCPStop(ScrnInfoPtr pScrn,  RADEONInfoPtr info);

extern void        RADEONHostDataParams(ScrnInfoPtr pScrn, CARD8 *dst,
					CARD32 pitch, int cpp,
					CARD32 *dstPitchOffset, int *x, int *y);
extern CARD8*      RADEONHostDataBlit(ScrnInfoPtr pScrn, unsigned int cpp,
				      unsigned int w, CARD32 dstPitchOff,
				      CARD32 *bufPitch, int x, int *y,
				      unsigned int *h, unsigned int *hpass);
extern void        RADEONHostDataBlitCopyPass(ScrnInfoPtr pScrn,
					      unsigned int bpp,
					      CARD8 *dst, CARD8 *src,
					      unsigned int hpass,
					      unsigned int dstPitch,
					      unsigned int srcPitch);
extern void        RADEONCopySwap(CARD8 *dst, CARD8 *src, unsigned int size,
				  int swap);
d1022 10
d1061 5
d1067 12
a1078 5
	BEGIN_RING(6);							\
	OUT_RING_REG(RADEON_RE_TOP_LEFT,     info->re_top_left);	\
	OUT_RING_REG(RADEON_RE_WIDTH_HEIGHT, info->re_width_height);	\
	OUT_RING_REG(RADEON_AUX_SC_CNTL,     info->aux_sc_cntl);	\
	ADVANCE_RING();							\
d1096 1
a1096 1
#define RING_LOCALS	CARD32 *__head = NULL; int __expected; int __count = 0
d1114 1
a1114 1
    } else if (info->indirectBuffer->used + (n) * (int)sizeof(CARD32) >	\
d1141 1
a1141 1
		   __count * (int)sizeof(CARD32));			\
d1143 1
a1143 1
    info->indirectBuffer->used += __count * (int)sizeof(CARD32);	\
d1203 1
a1203 1
#define RADEON_FLUSH_CACHE()						\
d1206 7
a1212 2
    OUT_RING(CP_PACKET0(RADEON_RB3D_DSTCACHE_CTLSTAT, 0));		\
    OUT_RING(RADEON_RB3D_DC_FLUSH);					\
d1216 1
a1216 1
#define RADEON_PURGE_CACHE()						\
d1219 7
a1225 2
    OUT_RING(CP_PACKET0(RADEON_RB3D_DSTCACHE_CTLSTAT, 0));		\
    OUT_RING(RADEON_RB3D_DC_FLUSH_ALL);					\
d1253 17
@


1.1
log
@Initial revision
@
text
@d147 4
a150 1
    OPTION_CONSTANTDPI
@


1.1.1.1
log
@Importing xf86-video-ati 6.6.3
@
text
@@
