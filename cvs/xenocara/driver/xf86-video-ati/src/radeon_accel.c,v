head	1.9;
access;
symbols
	OPENBSD_6_0:1.9.0.2
	OPENBSD_6_0_BASE:1.9
	OPENBSD_5_9:1.8.0.10
	OPENBSD_5_9_BASE:1.8
	OPENBSD_5_8:1.8.0.8
	OPENBSD_5_8_BASE:1.8
	OPENBSD_5_7:1.8.0.6
	OPENBSD_5_7_BASE:1.8
	OPENBSD_5_6:1.8.0.4
	OPENBSD_5_6_BASE:1.8
	OPENBSD_5_5:1.8.0.2
	OPENBSD_5_5_BASE:1.8
	OPENBSD_5_4:1.7.0.4
	OPENBSD_5_4_BASE:1.7
	OPENBSD_5_3:1.7.0.2
	OPENBSD_5_3_BASE:1.7
	OPENBSD_5_2:1.6.0.2
	OPENBSD_5_2_BASE:1.6
	OPENBSD_5_1_BASE:1.5
	OPENBSD_5_1:1.5.0.2
	OPENBSD_5_0:1.3.0.8
	OPENBSD_5_0_BASE:1.3
	OPENBSD_4_9:1.3.0.4
	OPENBSD_4_9_BASE:1.3
	OPENBSD_4_8:1.3.0.6
	OPENBSD_4_8_BASE:1.3
	OPENBSD_4_7:1.3.0.2
	OPENBSD_4_7_BASE:1.3
	OPENBSD_4_6:1.2.0.6
	OPENBSD_4_6_BASE:1.2
	OPENBSD_4_5:1.2.0.4
	OPENBSD_4_5_BASE:1.2
	OPENBSD_4_4:1.2.0.2
	OPENBSD_4_4_BASE:1.2
	OPENBSD_4_3_BASE:1.1.1.1
	OPENBSD_4_3:1.1.1.1.0.4
	OPENBSD_4_2:1.1.1.1.0.2
	OPENBSD_4_2_BASE:1.1.1.1
	v6_6_3:1.1.1.1
	xorg:1.1.1;
locks; strict;
comment	@ * @;


1.9
date	2016.04.02.07.37.34;	author matthieu;	state Exp;
branches;
next	1.8;
commitid	bsyGwvYIwQ6RE8Qj;

1.8
date	2013.08.16.17.04.07;	author matthieu;	state Exp;
branches;
next	1.7;

1.7
date	2012.08.08.16.25.22;	author matthieu;	state Exp;
branches;
next	1.6;

1.6
date	2012.03.04.16.01.20;	author matthieu;	state Exp;
branches;
next	1.5;

1.5
date	2012.02.06.22.53.12;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2012.01.25.21.33.35;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2009.08.25.18.51.45;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2008.07.12.15.18.34;	author oga;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.26.20.00.55;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.11.26.20.00.55;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.9
log
@Update to xf86-video-ati 7.6.1. ok jsg@@
@
text
@/*
 * Copyright 2000 ATI Technologies Inc., Markham, Ontario, and
 *                VA Linux Systems Inc., Fremont, California.
 *
 * All Rights Reserved.
 *
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation on the rights to use, copy, modify, merge,
 * publish, distribute, sublicense, and/or sell copies of the Software,
 * and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice (including the
 * next paragraph) shall be included in all copies or substantial
 * portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NON-INFRINGEMENT.  IN NO EVENT SHALL ATI, VA LINUX SYSTEMS AND/OR
 * THEIR SUPPLIERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
 * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 */

#ifdef HAVE_CONFIG_H
#include "config.h"
#endif

/*
 * Authors:
 *   Kevin E. Martin <martin@@xfree86.org>
 *   Rickard E. Faith <faith@@valinux.com>
 *   Alan Hourihane <alanh@@fairlite.demon.co.uk>
 *
 * Credits:
 *
 *   Thanks to Ani Joshi <ajoshi@@shell.unixbox.com> for providing source
 *   code to his Radeon driver.  Portions of this file are based on the
 *   initialization code for that driver.
 *
 * References:
 *
 * !!!! FIXME !!!!
 *   RAGE 128 VR/ RAGE 128 GL Register Reference Manual (Technical
 *   Reference Manual P/N RRG-G04100-C Rev. 0.04), ATI Technologies: April
 *   1999.
 *
 *   RAGE 128 Software Development Manual (Technical Reference Manual P/N
 *   SDK-G04000 Rev. 0.01), ATI Technologies: June 1999.
 *
 * Notes on unimplemented XAA optimizations:
 *
 *   SetClipping:   This has been removed as XAA expects 16bit registers
 *                  for full clipping.
 *   TwoPointLine:  The Radeon supports this. Not Bresenham.
 *   DashedLine with non-power-of-two pattern length: Apparently, there is
 *                  no way to set the length of the pattern -- it is always
 *                  assumed to be 8 or 32 (or 1024?).
 *   ScreenToScreenColorExpandFill: See p. 4-17 of the Technical Reference
 *                  Manual where it states that monochrome expansion of frame
 *                  buffer data is not supported.
 *   CPUToScreenColorExpandFill, direct: The implementation here uses a hybrid
 *                  direct/indirect method.  If we had more data registers,
 *                  then we could do better.  If XAA supported a trigger write
 *                  address, the code would be simpler.
 *   Color8x8PatternFill: Apparently, an 8x8 color brush cannot take an 8x8
 *                  pattern from frame buffer memory.
 *   ImageWrites:   Same as CPUToScreenColorExpandFill
 *
 */

#include <errno.h>
#include <string.h>
#include <assert.h>
				/* Driver data structures */
#include "radeon.h"
#include "radeon_glamor.h"
#include "radeon_reg.h"
#include "r600_reg.h"
#include "radeon_probe.h"
#include "radeon_version.h"

#include "ati_pciids_gen.h"

				/* Line support */
#include "miline.h"

				/* X and server generic header files */
#include "xf86.h"

static int RADEONDRMGetNumPipes(ScrnInfoPtr pScrn, int *num_pipes)
{
    RADEONInfoPtr info = RADEONPTR(pScrn);
    struct drm_radeon_info np2;
    np2.value = (unsigned long)num_pipes;
    np2.request = RADEON_INFO_NUM_GB_PIPES;
    return drmCommandWriteRead(info->dri2.drm_fd, DRM_RADEON_INFO, &np2, sizeof(np2));
}

/* Initialize the acceleration hardware */
void RADEONEngineInit(ScrnInfoPtr pScrn)
{
    RADEONInfoPtr  info       = RADEONPTR(pScrn);
    info->accel_state->num_gb_pipes = 0;

    if (info->directRenderingEnabled && (IS_R300_3D || IS_R500_3D)) {
	int num_pipes;

	if(RADEONDRMGetNumPipes(pScrn, &num_pipes) < 0) {
	    xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
		       "Failed to determine num pipes from DRM, falling back to "
		       "manual look-up!\n");
	    info->accel_state->num_gb_pipes = 0;
	} else {
	    info->accel_state->num_gb_pipes = num_pipes;
	}
    }
}

int radeon_cs_space_remaining(ScrnInfoPtr pScrn)
{
    RADEONInfoPtr info = RADEONPTR(pScrn);

    return (info->cs->ndw - info->cs->cdw);
}

void RADEONCopySwap(uint8_t *dst, uint8_t *src, unsigned int size, int swap)
{
    switch(swap) {
    case RADEON_HOST_DATA_SWAP_HDW:
        {
	    unsigned int *d = (unsigned int *)dst;
	    unsigned int *s = (unsigned int *)src;
	    unsigned int nwords = size >> 2;

	    for (; nwords > 0; --nwords, ++d, ++s)
		*d = ((*s & 0xffff) << 16) | ((*s >> 16) & 0xffff);
	    return;
        }
    case RADEON_HOST_DATA_SWAP_32BIT:
        {
	    unsigned int *d = (unsigned int *)dst;
	    unsigned int *s = (unsigned int *)src;
	    unsigned int nwords = size >> 2;

	    for (; nwords > 0; --nwords, ++d, ++s)
#ifdef __powerpc__
		asm volatile("stwbrx %0,0,%1" : : "r" (*s), "r" (d));
#else
		*d = ((*s >> 24) & 0xff) | ((*s >> 8) & 0xff00)
			| ((*s & 0xff00) << 8) | ((*s & 0xff) << 24);
#endif
	    return;
        }
    case RADEON_HOST_DATA_SWAP_16BIT:
        {
	    unsigned short *d = (unsigned short *)dst;
	    unsigned short *s = (unsigned short *)src;
	    unsigned int nwords = size >> 1;

	    for (; nwords > 0; --nwords, ++d, ++s)
#ifdef __powerpc__
		asm volatile("sthbrx %0,0,%1" : : "r" (*s), "r" (d));
#else
	        *d = (*s >> 8) | (*s << 8);
#endif
	    return;
	}
    }
    if (src != dst)
	memcpy(dst, src, size);
}



Bool RADEONAccelInit(ScreenPtr pScreen)
{
    ScrnInfoPtr    pScrn = xf86ScreenToScrn(pScreen);
    RADEONInfoPtr  info  = RADEONPTR(pScrn);

    if (info->directRenderingEnabled) {
	if (info->use_glamor) {
	    if (!radeon_glamor_init(pScreen)) {
		info->use_glamor = FALSE;
		return FALSE;
	    }
	} else if (info->ChipFamily >= CHIP_FAMILY_CEDAR) {
	    if (!EVERGREENDrawInit(pScreen))
		return FALSE;
	} else
	    if (info->ChipFamily >= CHIP_FAMILY_R600) {
		if (!R600DrawInit(pScreen))
		    return FALSE;
	    } else {
		if (!RADEONDrawInit(pScreen))
		    return FALSE;
	    }
    }
    return TRUE;
}

static void RADEONInit3DEngineInternal(ScrnInfoPtr pScrn)
{
    RADEONInfoPtr  info       = RADEONPTR(pScrn);
    uint32_t gb_tile_config, vap_cntl;

    info->accel_state->texW[0] = info->accel_state->texH[0] =
	info->accel_state->texW[1] = info->accel_state->texH[1] = 1;

    if (IS_R300_3D || IS_R500_3D) {

	gb_tile_config = (R300_ENABLE_TILING | R300_TILE_SIZE_16);

	switch(info->accel_state->num_gb_pipes) {
	case 2: gb_tile_config |= R300_PIPE_COUNT_R300; break;
	case 3: gb_tile_config |= R300_PIPE_COUNT_R420_3P; break;
	case 4: gb_tile_config |= R300_PIPE_COUNT_R420; break;
	default:
	case 1: gb_tile_config |= R300_PIPE_COUNT_RV350; break;
	}

	BEGIN_RING(2*3);
	OUT_RING_REG(R300_RB3D_DSTCACHE_CTLSTAT, R300_DC_FLUSH_3D | R300_DC_FREE_3D);
	OUT_RING_REG(R300_RB3D_ZCACHE_CTLSTAT, R300_ZC_FLUSH | R300_ZC_FREE);
	OUT_RING_REG(RADEON_WAIT_UNTIL, RADEON_WAIT_2D_IDLECLEAN | RADEON_WAIT_3D_IDLECLEAN);
	ADVANCE_RING();

	BEGIN_RING(2*3);
	OUT_RING_REG(R300_GB_AA_CONFIG, 0);
	OUT_RING_REG(R300_RB3D_DSTCACHE_CTLSTAT, R300_DC_FLUSH_3D | R300_DC_FREE_3D);
	OUT_RING_REG(R300_RB3D_ZCACHE_CTLSTAT, R300_ZC_FLUSH | R300_ZC_FREE);
	ADVANCE_RING();

	BEGIN_RING(2*4);
	OUT_RING_REG(R300_GA_POLY_MODE, R300_FRONT_PTYPE_TRIANGE | R300_BACK_PTYPE_TRIANGE);
	OUT_RING_REG(R300_GA_ROUND_MODE, (R300_GEOMETRY_ROUND_NEAREST |
					   R300_COLOR_ROUND_NEAREST));
	OUT_RING_REG(R300_GA_COLOR_CONTROL, (R300_RGB0_SHADING_GOURAUD |
					      R300_ALPHA0_SHADING_GOURAUD |
					      R300_RGB1_SHADING_GOURAUD |
					      R300_ALPHA1_SHADING_GOURAUD |
					      R300_RGB2_SHADING_GOURAUD |
					      R300_ALPHA2_SHADING_GOURAUD |
					      R300_RGB3_SHADING_GOURAUD |
					      R300_ALPHA3_SHADING_GOURAUD));
	OUT_RING_REG(R300_GA_OFFSET, 0);
	ADVANCE_RING();

	BEGIN_RING(2*5);
	OUT_RING_REG(R300_SU_TEX_WRAP, 0);
	OUT_RING_REG(R300_SU_POLY_OFFSET_ENABLE, 0);
	OUT_RING_REG(R300_SU_CULL_MODE, R300_FACE_NEG);
	OUT_RING_REG(R300_SU_DEPTH_SCALE, 0x4b7fffff);
	OUT_RING_REG(R300_SU_DEPTH_OFFSET, 0);
	ADVANCE_RING();

	/* setup the VAP */
	if (info->accel_state->has_tcl)
	    vap_cntl = ((5 << R300_PVS_NUM_SLOTS_SHIFT) |
			(5 << R300_PVS_NUM_CNTLRS_SHIFT) |
			(9 << R300_VF_MAX_VTX_NUM_SHIFT));
	else
	    vap_cntl = ((10 << R300_PVS_NUM_SLOTS_SHIFT) |
			(5 << R300_PVS_NUM_CNTLRS_SHIFT) |
			(5 << R300_VF_MAX_VTX_NUM_SHIFT));

	if ((info->ChipFamily == CHIP_FAMILY_R300) ||
	    (info->ChipFamily == CHIP_FAMILY_R350))
	    vap_cntl |= (4 << R300_PVS_NUM_FPUS_SHIFT);
	else if (info->ChipFamily == CHIP_FAMILY_RV530)
	    vap_cntl |= (5 << R300_PVS_NUM_FPUS_SHIFT);
	else if ((info->ChipFamily == CHIP_FAMILY_RV410) ||
		 (info->ChipFamily == CHIP_FAMILY_R420))
	    vap_cntl |= (6 << R300_PVS_NUM_FPUS_SHIFT);
	else if ((info->ChipFamily == CHIP_FAMILY_R520) ||
		 (info->ChipFamily == CHIP_FAMILY_R580) ||
		 (info->ChipFamily == CHIP_FAMILY_RV560) ||
		 (info->ChipFamily == CHIP_FAMILY_RV570))
	    vap_cntl |= (8 << R300_PVS_NUM_FPUS_SHIFT);
	else
	    vap_cntl |= (2 << R300_PVS_NUM_FPUS_SHIFT);

	if (info->accel_state->has_tcl)
	    BEGIN_RING(2*15);
	else
	    BEGIN_RING(2*9);
	OUT_RING_REG(R300_VAP_VTX_STATE_CNTL, 0);
	OUT_RING_REG(R300_VAP_PVS_STATE_FLUSH_REG, 0);

	if (info->accel_state->has_tcl)
	    OUT_RING_REG(R300_VAP_CNTL_STATUS, 0);
	else
	    OUT_RING_REG(R300_VAP_CNTL_STATUS, R300_PVS_BYPASS);
	OUT_RING_REG(R300_VAP_CNTL, vap_cntl);
	OUT_RING_REG(R300_VAP_PVS_STATE_FLUSH_REG, 0);
	OUT_RING_REG(R300_VAP_VTE_CNTL, R300_VTX_XY_FMT | R300_VTX_Z_FMT);
	OUT_RING_REG(R300_VAP_PSC_SGN_NORM_CNTL, 0);

	OUT_RING_REG(R300_VAP_PROG_STREAM_CNTL_EXT_0,
		      ((R300_SWIZZLE_SELECT_X << R300_SWIZZLE_SELECT_X_0_SHIFT) |
		       (R300_SWIZZLE_SELECT_Y << R300_SWIZZLE_SELECT_Y_0_SHIFT) |
		       (R300_SWIZZLE_SELECT_Z << R300_SWIZZLE_SELECT_Z_0_SHIFT) |
		       (R300_SWIZZLE_SELECT_W << R300_SWIZZLE_SELECT_W_0_SHIFT) |
		       ((R300_WRITE_ENA_X | R300_WRITE_ENA_Y | R300_WRITE_ENA_Z | R300_WRITE_ENA_W)
			<< R300_WRITE_ENA_0_SHIFT) |
		       (R300_SWIZZLE_SELECT_X << R300_SWIZZLE_SELECT_X_1_SHIFT) |
		       (R300_SWIZZLE_SELECT_Y << R300_SWIZZLE_SELECT_Y_1_SHIFT) |
		       (R300_SWIZZLE_SELECT_Z << R300_SWIZZLE_SELECT_Z_1_SHIFT) |
		       (R300_SWIZZLE_SELECT_W << R300_SWIZZLE_SELECT_W_1_SHIFT) |
		       ((R300_WRITE_ENA_X | R300_WRITE_ENA_Y | R300_WRITE_ENA_Z | R300_WRITE_ENA_W)
			<< R300_WRITE_ENA_1_SHIFT)));
	OUT_RING_REG(R300_VAP_PROG_STREAM_CNTL_EXT_1,
		      ((R300_SWIZZLE_SELECT_X << R300_SWIZZLE_SELECT_X_2_SHIFT) |
		       (R300_SWIZZLE_SELECT_Y << R300_SWIZZLE_SELECT_Y_2_SHIFT) |
		       (R300_SWIZZLE_SELECT_Z << R300_SWIZZLE_SELECT_Z_2_SHIFT) |
		       (R300_SWIZZLE_SELECT_W << R300_SWIZZLE_SELECT_W_2_SHIFT) |
		       ((R300_WRITE_ENA_X | R300_WRITE_ENA_Y | R300_WRITE_ENA_Z | R300_WRITE_ENA_W)
			<< R300_WRITE_ENA_2_SHIFT)));

	if (info->accel_state->has_tcl) {
	    OUT_RING_REG(R300_VAP_PVS_FLOW_CNTL_OPC, 0);
	    OUT_RING_REG(R300_VAP_GB_VERT_CLIP_ADJ, 0x3f800000);
	    OUT_RING_REG(R300_VAP_GB_VERT_DISC_ADJ, 0x3f800000);
	    OUT_RING_REG(R300_VAP_GB_HORZ_CLIP_ADJ, 0x3f800000);
	    OUT_RING_REG(R300_VAP_GB_HORZ_DISC_ADJ, 0x3f800000);
	    OUT_RING_REG(R300_VAP_CLIP_CNTL, R300_CLIP_DISABLE);
	}
	ADVANCE_RING();

	/* pre-load the vertex shaders */
	if (info->accel_state->has_tcl) {
	    BEGIN_RING(2*37);
	    /* exa composite shader program */
	    OUT_RING_REG(R300_VAP_PVS_VECTOR_INDX_REG, R300_PVS_VECTOR_INST_INDEX(0));
	    /* PVS inst 0 - dst X,Y */
	    OUT_RING_REG(R300_VAP_PVS_VECTOR_DATA_REG,
			  (R300_PVS_DST_OPCODE(R300_VE_ADD) |
			   R300_PVS_DST_REG_TYPE(R300_PVS_DST_REG_OUT) |
			   R300_PVS_DST_OFFSET(0) |
			   R300_PVS_DST_WE_X | R300_PVS_DST_WE_Y |
			   R300_PVS_DST_WE_Z | R300_PVS_DST_WE_W));
	    OUT_RING_REG(R300_VAP_PVS_VECTOR_DATA_REG,
			  (R300_PVS_SRC_REG_TYPE(R300_PVS_SRC_REG_INPUT) |
			   R300_PVS_SRC_OFFSET(0) |
			   R300_PVS_SRC_SWIZZLE_X(R300_PVS_SRC_SELECT_X) |
			   R300_PVS_SRC_SWIZZLE_Y(R300_PVS_SRC_SELECT_Y) |
			   R300_PVS_SRC_SWIZZLE_Z(R300_PVS_SRC_SELECT_FORCE_0) |
			   R300_PVS_SRC_SWIZZLE_W(R300_PVS_SRC_SELECT_FORCE_1)));
	    OUT_RING_REG(R300_VAP_PVS_VECTOR_DATA_REG,
			  (R300_PVS_SRC_REG_TYPE(R300_PVS_SRC_REG_INPUT) |
			   R300_PVS_SRC_OFFSET(0) |
			   R300_PVS_SRC_SWIZZLE_X(R300_PVS_SRC_SELECT_FORCE_0) |
			   R300_PVS_SRC_SWIZZLE_Y(R300_PVS_SRC_SELECT_FORCE_0) |
			   R300_PVS_SRC_SWIZZLE_Z(R300_PVS_SRC_SELECT_FORCE_0) |
			   R300_PVS_SRC_SWIZZLE_W(R300_PVS_SRC_SELECT_FORCE_0)));
	    OUT_RING_REG(R300_VAP_PVS_VECTOR_DATA_REG,
			  (R300_PVS_SRC_REG_TYPE(R300_PVS_SRC_REG_INPUT) |
			   R300_PVS_SRC_OFFSET(0) |
			   R300_PVS_SRC_SWIZZLE_X(R300_PVS_SRC_SELECT_FORCE_0) |
			   R300_PVS_SRC_SWIZZLE_Y(R300_PVS_SRC_SELECT_FORCE_0) |
			   R300_PVS_SRC_SWIZZLE_Z(R300_PVS_SRC_SELECT_FORCE_0) |
			   R300_PVS_SRC_SWIZZLE_W(R300_PVS_SRC_SELECT_FORCE_0)));

	    /* PVS inst 1 - src X */
	    OUT_RING_REG(R300_VAP_PVS_VECTOR_DATA_REG,
			  (R300_PVS_DST_OPCODE(R300_VE_DOT_PRODUCT) |
			   R300_PVS_DST_REG_TYPE(R300_PVS_DST_REG_TEMPORARY) |
			   R300_PVS_DST_OFFSET(0) |
			   R300_PVS_DST_WE_X));
	    OUT_RING_REG(R300_VAP_PVS_VECTOR_DATA_REG,
			  (R300_PVS_SRC_REG_TYPE(R300_PVS_SRC_REG_INPUT) |
			   R300_PVS_SRC_OFFSET(6) |
			   R300_PVS_SRC_SWIZZLE_X(R300_PVS_SRC_SELECT_X) |
			   R300_PVS_SRC_SWIZZLE_Y(R300_PVS_SRC_SELECT_Y) |
			   R300_PVS_SRC_SWIZZLE_Z(R300_PVS_SRC_SELECT_FORCE_1) |
			   R300_PVS_SRC_SWIZZLE_W(R300_PVS_SRC_SELECT_FORCE_0)));
	    OUT_RING_REG(R300_VAP_PVS_VECTOR_DATA_REG,
			  (R300_PVS_SRC_REG_TYPE(R300_PVS_SRC_REG_CONSTANT) |
			   R300_PVS_SRC_OFFSET(0) |
			   R300_PVS_SRC_SWIZZLE_X(R300_PVS_SRC_SELECT_X) |
			   R300_PVS_SRC_SWIZZLE_Y(R300_PVS_SRC_SELECT_Y) |
			   R300_PVS_SRC_SWIZZLE_Z(R300_PVS_SRC_SELECT_Z) |
			   R300_PVS_SRC_SWIZZLE_W(R300_PVS_SRC_SELECT_FORCE_0)));
	    OUT_RING_REG(R300_VAP_PVS_VECTOR_DATA_REG,
			  (R300_PVS_SRC_REG_TYPE(R300_PVS_SRC_REG_INPUT) |
			   R300_PVS_SRC_OFFSET(6) |
			   R300_PVS_SRC_SWIZZLE_X(R300_PVS_SRC_SELECT_FORCE_0) |
			   R300_PVS_SRC_SWIZZLE_Y(R300_PVS_SRC_SELECT_FORCE_0) |
			   R300_PVS_SRC_SWIZZLE_Z(R300_PVS_SRC_SELECT_FORCE_0) |
			   R300_PVS_SRC_SWIZZLE_W(R300_PVS_SRC_SELECT_FORCE_0)));

	    /* PVS inst 2 - src Y */
	    OUT_RING_REG(R300_VAP_PVS_VECTOR_DATA_REG,
			  (R300_PVS_DST_OPCODE(R300_VE_DOT_PRODUCT) |
			   R300_PVS_DST_REG_TYPE(R300_PVS_DST_REG_TEMPORARY) |
			   R300_PVS_DST_OFFSET(0) |
			   R300_PVS_DST_WE_Y));
	    OUT_RING_REG(R300_VAP_PVS_VECTOR_DATA_REG,
			  (R300_PVS_SRC_REG_TYPE(R300_PVS_SRC_REG_INPUT) |
			   R300_PVS_SRC_OFFSET(6) |
			   R300_PVS_SRC_SWIZZLE_X(R300_PVS_SRC_SELECT_X) |
			   R300_PVS_SRC_SWIZZLE_Y(R300_PVS_SRC_SELECT_Y) |
			   R300_PVS_SRC_SWIZZLE_Z(R300_PVS_SRC_SELECT_FORCE_1) |
			   R300_PVS_SRC_SWIZZLE_W(R300_PVS_SRC_SELECT_FORCE_0)));
	    OUT_RING_REG(R300_VAP_PVS_VECTOR_DATA_REG,
			  (R300_PVS_SRC_REG_TYPE(R300_PVS_SRC_REG_CONSTANT) |
			   R300_PVS_SRC_OFFSET(1) |
			   R300_PVS_SRC_SWIZZLE_X(R300_PVS_SRC_SELECT_X) |
			   R300_PVS_SRC_SWIZZLE_Y(R300_PVS_SRC_SELECT_Y) |
			   R300_PVS_SRC_SWIZZLE_Z(R300_PVS_SRC_SELECT_Z) |
			   R300_PVS_SRC_SWIZZLE_W(R300_PVS_SRC_SELECT_FORCE_0)));
	    OUT_RING_REG(R300_VAP_PVS_VECTOR_DATA_REG,
			  (R300_PVS_SRC_REG_TYPE(R300_PVS_SRC_REG_INPUT) |
			   R300_PVS_SRC_OFFSET(6) |
			   R300_PVS_SRC_SWIZZLE_X(R300_PVS_SRC_SELECT_FORCE_0) |
			   R300_PVS_SRC_SWIZZLE_Y(R300_PVS_SRC_SELECT_FORCE_0) |
			   R300_PVS_SRC_SWIZZLE_Z(R300_PVS_SRC_SELECT_FORCE_0) |
			   R300_PVS_SRC_SWIZZLE_W(R300_PVS_SRC_SELECT_FORCE_0)));

	    /* PVS inst 3 - src X / w */
	    OUT_RING_REG(R300_VAP_PVS_VECTOR_DATA_REG,
			  (R300_PVS_DST_OPCODE(R300_VE_MULTIPLY) |
			   R300_PVS_DST_REG_TYPE(R300_PVS_DST_REG_OUT) |
			   R300_PVS_DST_OFFSET(1) |
			   R300_PVS_DST_WE_X));
	    OUT_RING_REG(R300_VAP_PVS_VECTOR_DATA_REG,
			  (R300_PVS_SRC_REG_TYPE(R300_PVS_SRC_REG_TEMPORARY) |
			   R300_PVS_SRC_OFFSET(0) |
			   R300_PVS_SRC_SWIZZLE_X(R300_PVS_SRC_SELECT_X) |
			   R300_PVS_SRC_SWIZZLE_Y(R300_PVS_SRC_SELECT_FORCE_0) |
			   R300_PVS_SRC_SWIZZLE_Z(R300_PVS_SRC_SELECT_FORCE_0) |
			   R300_PVS_SRC_SWIZZLE_W(R300_PVS_SRC_SELECT_FORCE_0)));
	    OUT_RING_REG(R300_VAP_PVS_VECTOR_DATA_REG,
			  (R300_PVS_SRC_REG_TYPE(R300_PVS_SRC_REG_CONSTANT) |
			   R300_PVS_SRC_OFFSET(0) |
			   R300_PVS_SRC_SWIZZLE_X(R300_PVS_SRC_SELECT_W) |
			   R300_PVS_SRC_SWIZZLE_Y(R300_PVS_SRC_SELECT_FORCE_0) |
			   R300_PVS_SRC_SWIZZLE_Z(R300_PVS_SRC_SELECT_FORCE_0) |
			   R300_PVS_SRC_SWIZZLE_W(R300_PVS_SRC_SELECT_FORCE_0)));
	    OUT_RING_REG(R300_VAP_PVS_VECTOR_DATA_REG,
			  (R300_PVS_SRC_REG_TYPE(R300_PVS_SRC_REG_INPUT) |
			   R300_PVS_SRC_OFFSET(6) |
			   R300_PVS_SRC_SWIZZLE_X(R300_PVS_SRC_SELECT_FORCE_0) |
			   R300_PVS_SRC_SWIZZLE_Y(R300_PVS_SRC_SELECT_FORCE_0) |
			   R300_PVS_SRC_SWIZZLE_Z(R300_PVS_SRC_SELECT_FORCE_0) |
			   R300_PVS_SRC_SWIZZLE_W(R300_PVS_SRC_SELECT_FORCE_0)));

	    /* PVS inst 4 - src y / h */
	    OUT_RING_REG(R300_VAP_PVS_VECTOR_DATA_REG,
			  (R300_PVS_DST_OPCODE(R300_VE_MULTIPLY) |
			   R300_PVS_DST_REG_TYPE(R300_PVS_DST_REG_OUT) |
			   R300_PVS_DST_OFFSET(1) |
			   R300_PVS_DST_WE_Y));
	    OUT_RING_REG(R300_VAP_PVS_VECTOR_DATA_REG,
			  (R300_PVS_SRC_REG_TYPE(R300_PVS_SRC_REG_TEMPORARY) |
			   R300_PVS_SRC_OFFSET(0) |
			   R300_PVS_SRC_SWIZZLE_X(R300_PVS_SRC_SELECT_FORCE_0) |
			   R300_PVS_SRC_SWIZZLE_Y(R300_PVS_SRC_SELECT_Y) |
			   R300_PVS_SRC_SWIZZLE_Z(R300_PVS_SRC_SELECT_FORCE_0) |
			   R300_PVS_SRC_SWIZZLE_W(R300_PVS_SRC_SELECT_FORCE_0)));
	    OUT_RING_REG(R300_VAP_PVS_VECTOR_DATA_REG,
			  (R300_PVS_SRC_REG_TYPE(R300_PVS_SRC_REG_CONSTANT) |
			   R300_PVS_SRC_OFFSET(1) |
			   R300_PVS_SRC_SWIZZLE_X(R300_PVS_SRC_SELECT_FORCE_0) |
			   R300_PVS_SRC_SWIZZLE_Y(R300_PVS_SRC_SELECT_W) |
			   R300_PVS_SRC_SWIZZLE_Z(R300_PVS_SRC_SELECT_FORCE_0) |
			   R300_PVS_SRC_SWIZZLE_W(R300_PVS_SRC_SELECT_FORCE_0)));
	    OUT_RING_REG(R300_VAP_PVS_VECTOR_DATA_REG,
			  (R300_PVS_SRC_REG_TYPE(R300_PVS_SRC_REG_INPUT) |
			   R300_PVS_SRC_OFFSET(6) |
			   R300_PVS_SRC_SWIZZLE_X(R300_PVS_SRC_SELECT_FORCE_0) |
			   R300_PVS_SRC_SWIZZLE_Y(R300_PVS_SRC_SELECT_FORCE_0) |
			   R300_PVS_SRC_SWIZZLE_Z(R300_PVS_SRC_SELECT_FORCE_0) |
			   R300_PVS_SRC_SWIZZLE_W(R300_PVS_SRC_SELECT_FORCE_0)));

	    /* PVS inst 5 - mask X */
	    OUT_RING_REG(R300_VAP_PVS_VECTOR_DATA_REG,
			  (R300_PVS_DST_OPCODE(R300_VE_DOT_PRODUCT) |
			   R300_PVS_DST_REG_TYPE(R300_PVS_DST_REG_TEMPORARY) |
			   R300_PVS_DST_OFFSET(0) |
			   R300_PVS_DST_WE_Z));
	    OUT_RING_REG(R300_VAP_PVS_VECTOR_DATA_REG,
			  (R300_PVS_SRC_REG_TYPE(R300_PVS_SRC_REG_INPUT) |
			   R300_PVS_SRC_OFFSET(7) |
			   R300_PVS_SRC_SWIZZLE_X(R300_PVS_SRC_SELECT_X) |
			   R300_PVS_SRC_SWIZZLE_Y(R300_PVS_SRC_SELECT_Y) |
			   R300_PVS_SRC_SWIZZLE_Z(R300_PVS_SRC_SELECT_FORCE_1) |
			   R300_PVS_SRC_SWIZZLE_W(R300_PVS_SRC_SELECT_FORCE_0)));
	    OUT_RING_REG(R300_VAP_PVS_VECTOR_DATA_REG,
			  (R300_PVS_SRC_REG_TYPE(R300_PVS_SRC_REG_CONSTANT) |
			   R300_PVS_SRC_OFFSET(2) |
			   R300_PVS_SRC_SWIZZLE_X(R300_PVS_SRC_SELECT_X) |
			   R300_PVS_SRC_SWIZZLE_Y(R300_PVS_SRC_SELECT_Y) |
			   R300_PVS_SRC_SWIZZLE_Z(R300_PVS_SRC_SELECT_Z) |
			   R300_PVS_SRC_SWIZZLE_W(R300_PVS_SRC_SELECT_FORCE_0)));
	    OUT_RING_REG(R300_VAP_PVS_VECTOR_DATA_REG,
			  (R300_PVS_SRC_REG_TYPE(R300_PVS_SRC_REG_INPUT) |
			   R300_PVS_SRC_OFFSET(7) |
			   R300_PVS_SRC_SWIZZLE_X(R300_PVS_SRC_SELECT_FORCE_0) |
			   R300_PVS_SRC_SWIZZLE_Y(R300_PVS_SRC_SELECT_FORCE_0) |
			   R300_PVS_SRC_SWIZZLE_Z(R300_PVS_SRC_SELECT_FORCE_0) |
			   R300_PVS_SRC_SWIZZLE_W(R300_PVS_SRC_SELECT_FORCE_0)));

	    /* PVS inst 6 - mask Y */
	    OUT_RING_REG(R300_VAP_PVS_VECTOR_DATA_REG,
			  (R300_PVS_DST_OPCODE(R300_VE_DOT_PRODUCT) |
			   R300_PVS_DST_REG_TYPE(R300_PVS_DST_REG_TEMPORARY) |
			   R300_PVS_DST_OFFSET(0) |
			   R300_PVS_DST_WE_W));
	    OUT_RING_REG(R300_VAP_PVS_VECTOR_DATA_REG,
			  (R300_PVS_SRC_REG_TYPE(R300_PVS_SRC_REG_INPUT) |
			   R300_PVS_SRC_OFFSET(7) |
			   R300_PVS_SRC_SWIZZLE_X(R300_PVS_SRC_SELECT_X) |
			   R300_PVS_SRC_SWIZZLE_Y(R300_PVS_SRC_SELECT_Y) |
			   R300_PVS_SRC_SWIZZLE_Z(R300_PVS_SRC_SELECT_FORCE_1) |
			   R300_PVS_SRC_SWIZZLE_W(R300_PVS_SRC_SELECT_FORCE_0)));
	    OUT_RING_REG(R300_VAP_PVS_VECTOR_DATA_REG,
			  (R300_PVS_SRC_REG_TYPE(R300_PVS_SRC_REG_CONSTANT) |
			   R300_PVS_SRC_OFFSET(3) |
			   R300_PVS_SRC_SWIZZLE_X(R300_PVS_SRC_SELECT_X) |
			   R300_PVS_SRC_SWIZZLE_Y(R300_PVS_SRC_SELECT_Y) |
			   R300_PVS_SRC_SWIZZLE_Z(R300_PVS_SRC_SELECT_Z) |
			   R300_PVS_SRC_SWIZZLE_W(R300_PVS_SRC_SELECT_FORCE_0)));
	    OUT_RING_REG(R300_VAP_PVS_VECTOR_DATA_REG,
			  (R300_PVS_SRC_REG_TYPE(R300_PVS_SRC_REG_INPUT) |
			   R300_PVS_SRC_OFFSET(7) |
			   R300_PVS_SRC_SWIZZLE_X(R300_PVS_SRC_SELECT_FORCE_0) |
			   R300_PVS_SRC_SWIZZLE_Y(R300_PVS_SRC_SELECT_FORCE_0) |
			   R300_PVS_SRC_SWIZZLE_Z(R300_PVS_SRC_SELECT_FORCE_0) |
			   R300_PVS_SRC_SWIZZLE_W(R300_PVS_SRC_SELECT_FORCE_0)));

	    /* PVS inst 7 - mask X / w */
	    OUT_RING_REG(R300_VAP_PVS_VECTOR_DATA_REG,
			  (R300_PVS_DST_OPCODE(R300_VE_MULTIPLY) |
			   R300_PVS_DST_REG_TYPE(R300_PVS_DST_REG_OUT) |
			   R300_PVS_DST_OFFSET(2) |
			   R300_PVS_DST_WE_X));
	    OUT_RING_REG(R300_VAP_PVS_VECTOR_DATA_REG,
			  (R300_PVS_SRC_REG_TYPE(R300_PVS_SRC_REG_TEMPORARY) |
			   R300_PVS_SRC_OFFSET(0) |
			   R300_PVS_SRC_SWIZZLE_X(R300_PVS_SRC_SELECT_Z) |
			   R300_PVS_SRC_SWIZZLE_Y(R300_PVS_SRC_SELECT_FORCE_0) |
			   R300_PVS_SRC_SWIZZLE_Z(R300_PVS_SRC_SELECT_FORCE_0) |
			   R300_PVS_SRC_SWIZZLE_W(R300_PVS_SRC_SELECT_FORCE_0)));
	    OUT_RING_REG(R300_VAP_PVS_VECTOR_DATA_REG,
			  (R300_PVS_SRC_REG_TYPE(R300_PVS_SRC_REG_CONSTANT) |
			   R300_PVS_SRC_OFFSET(2) |
			   R300_PVS_SRC_SWIZZLE_X(R300_PVS_SRC_SELECT_W) |
			   R300_PVS_SRC_SWIZZLE_Y(R300_PVS_SRC_SELECT_FORCE_0) |
			   R300_PVS_SRC_SWIZZLE_Z(R300_PVS_SRC_SELECT_FORCE_0) |
			   R300_PVS_SRC_SWIZZLE_W(R300_PVS_SRC_SELECT_FORCE_0)));
	    OUT_RING_REG(R300_VAP_PVS_VECTOR_DATA_REG,
			  (R300_PVS_SRC_REG_TYPE(R300_PVS_SRC_REG_INPUT) |
			   R300_PVS_SRC_OFFSET(6) |
			   R300_PVS_SRC_SWIZZLE_X(R300_PVS_SRC_SELECT_FORCE_0) |
			   R300_PVS_SRC_SWIZZLE_Y(R300_PVS_SRC_SELECT_FORCE_0) |
			   R300_PVS_SRC_SWIZZLE_Z(R300_PVS_SRC_SELECT_FORCE_0) |
			   R300_PVS_SRC_SWIZZLE_W(R300_PVS_SRC_SELECT_FORCE_0)));

	    /* PVS inst 8 - mask y / h */
	    OUT_RING_REG(R300_VAP_PVS_VECTOR_DATA_REG,
			  (R300_PVS_DST_OPCODE(R300_VE_MULTIPLY) |
			   R300_PVS_DST_REG_TYPE(R300_PVS_DST_REG_OUT) |
			   R300_PVS_DST_OFFSET(2) |
			   R300_PVS_DST_WE_Y));
	    OUT_RING_REG(R300_VAP_PVS_VECTOR_DATA_REG,
			  (R300_PVS_SRC_REG_TYPE(R300_PVS_SRC_REG_TEMPORARY) |
			   R300_PVS_SRC_OFFSET(0) |
			   R300_PVS_SRC_SWIZZLE_X(R300_PVS_SRC_SELECT_FORCE_0) |
			   R300_PVS_SRC_SWIZZLE_Y(R300_PVS_SRC_SELECT_W) |
			   R300_PVS_SRC_SWIZZLE_Z(R300_PVS_SRC_SELECT_FORCE_0) |
			   R300_PVS_SRC_SWIZZLE_W(R300_PVS_SRC_SELECT_FORCE_0)));
	    OUT_RING_REG(R300_VAP_PVS_VECTOR_DATA_REG,
			  (R300_PVS_SRC_REG_TYPE(R300_PVS_SRC_REG_CONSTANT) |
			   R300_PVS_SRC_OFFSET(3) |
			   R300_PVS_SRC_SWIZZLE_X(R300_PVS_SRC_SELECT_FORCE_0) |
			   R300_PVS_SRC_SWIZZLE_Y(R300_PVS_SRC_SELECT_W) |
			   R300_PVS_SRC_SWIZZLE_Z(R300_PVS_SRC_SELECT_FORCE_0) |
			   R300_PVS_SRC_SWIZZLE_W(R300_PVS_SRC_SELECT_FORCE_0)));
	    OUT_RING_REG(R300_VAP_PVS_VECTOR_DATA_REG,
			  (R300_PVS_SRC_REG_TYPE(R300_PVS_SRC_REG_INPUT) |
			   R300_PVS_SRC_OFFSET(6) |
			   R300_PVS_SRC_SWIZZLE_X(R300_PVS_SRC_SELECT_FORCE_0) |
			   R300_PVS_SRC_SWIZZLE_Y(R300_PVS_SRC_SELECT_FORCE_0) |
			   R300_PVS_SRC_SWIZZLE_Z(R300_PVS_SRC_SELECT_FORCE_0) |
			   R300_PVS_SRC_SWIZZLE_W(R300_PVS_SRC_SELECT_FORCE_0)));
	    ADVANCE_RING();

	    /* Xv shader program */
	    BEGIN_RING(2*9);
	    OUT_RING_REG(R300_VAP_PVS_VECTOR_INDX_REG, R300_PVS_VECTOR_INST_INDEX(9));

	    OUT_RING_REG(R300_VAP_PVS_VECTOR_DATA_REG,
			  (R300_PVS_DST_OPCODE(R300_VE_ADD) |
			   R300_PVS_DST_REG_TYPE(R300_PVS_DST_REG_OUT) |
			   R300_PVS_DST_OFFSET(0) |
			   R300_PVS_DST_WE_X | R300_PVS_DST_WE_Y |
			   R300_PVS_DST_WE_Z | R300_PVS_DST_WE_W));
	    OUT_RING_REG(R300_VAP_PVS_VECTOR_DATA_REG,
			  (R300_PVS_SRC_REG_TYPE(R300_PVS_SRC_REG_INPUT) |
			   R300_PVS_SRC_OFFSET(0) |
			   R300_PVS_SRC_SWIZZLE_X(R300_PVS_SRC_SELECT_X) |
			   R300_PVS_SRC_SWIZZLE_Y(R300_PVS_SRC_SELECT_Y) |
			   R300_PVS_SRC_SWIZZLE_Z(R300_PVS_SRC_SELECT_FORCE_0) |
			   R300_PVS_SRC_SWIZZLE_W(R300_PVS_SRC_SELECT_FORCE_1)));
	    OUT_RING_REG(R300_VAP_PVS_VECTOR_DATA_REG,
			  (R300_PVS_SRC_REG_TYPE(R300_PVS_SRC_REG_INPUT) |
			   R300_PVS_SRC_OFFSET(0) |
			   R300_PVS_SRC_SWIZZLE_X(R300_PVS_SRC_SELECT_FORCE_0) |
			   R300_PVS_SRC_SWIZZLE_Y(R300_PVS_SRC_SELECT_FORCE_0) |
			   R300_PVS_SRC_SWIZZLE_Z(R300_PVS_SRC_SELECT_FORCE_0) |
			   R300_PVS_SRC_SWIZZLE_W(R300_PVS_SRC_SELECT_FORCE_0)));
	    OUT_RING_REG(R300_VAP_PVS_VECTOR_DATA_REG,
			  (R300_PVS_SRC_REG_TYPE(R300_PVS_SRC_REG_INPUT) |
			   R300_PVS_SRC_OFFSET(0) |
			   R300_PVS_SRC_SWIZZLE_X(R300_PVS_SRC_SELECT_FORCE_0) |
			   R300_PVS_SRC_SWIZZLE_Y(R300_PVS_SRC_SELECT_FORCE_0) |
			   R300_PVS_SRC_SWIZZLE_Z(R300_PVS_SRC_SELECT_FORCE_0) |
			   R300_PVS_SRC_SWIZZLE_W(R300_PVS_SRC_SELECT_FORCE_0)));

	    OUT_RING_REG(R300_VAP_PVS_VECTOR_DATA_REG,
			  (R300_PVS_DST_OPCODE(R300_VE_ADD) |
			   R300_PVS_DST_REG_TYPE(R300_PVS_DST_REG_OUT) |
			   R300_PVS_DST_OFFSET(1) |
			   R300_PVS_DST_WE_X | R300_PVS_DST_WE_Y));
	    OUT_RING_REG(R300_VAP_PVS_VECTOR_DATA_REG,
			  (R300_PVS_SRC_REG_TYPE(R300_PVS_SRC_REG_INPUT) |
			   R300_PVS_SRC_OFFSET(6) |
			   R300_PVS_SRC_SWIZZLE_X(R300_PVS_SRC_SELECT_X) |
			   R300_PVS_SRC_SWIZZLE_Y(R300_PVS_SRC_SELECT_Y) |
			   R300_PVS_SRC_SWIZZLE_Z(R300_PVS_SRC_SELECT_FORCE_0) |
			   R300_PVS_SRC_SWIZZLE_W(R300_PVS_SRC_SELECT_FORCE_1)));
	    OUT_RING_REG(R300_VAP_PVS_VECTOR_DATA_REG,
			  (R300_PVS_SRC_REG_TYPE(R300_PVS_SRC_REG_INPUT) |
			   R300_PVS_SRC_OFFSET(6) |
			   R300_PVS_SRC_SWIZZLE_X(R300_PVS_SRC_SELECT_FORCE_0) |
			   R300_PVS_SRC_SWIZZLE_Y(R300_PVS_SRC_SELECT_FORCE_0) |
			   R300_PVS_SRC_SWIZZLE_Z(R300_PVS_SRC_SELECT_FORCE_0) |
			   R300_PVS_SRC_SWIZZLE_W(R300_PVS_SRC_SELECT_FORCE_0)));
	    OUT_RING_REG(R300_VAP_PVS_VECTOR_DATA_REG,
			  (R300_PVS_SRC_REG_TYPE(R300_PVS_SRC_REG_INPUT) |
			   R300_PVS_SRC_OFFSET(6) |
			   R300_PVS_SRC_SWIZZLE_X(R300_PVS_SRC_SELECT_FORCE_0) |
			   R300_PVS_SRC_SWIZZLE_Y(R300_PVS_SRC_SELECT_FORCE_0) |
			   R300_PVS_SRC_SWIZZLE_Z(R300_PVS_SRC_SELECT_FORCE_0) |
			   R300_PVS_SRC_SWIZZLE_W(R300_PVS_SRC_SELECT_FORCE_0)));
	    ADVANCE_RING();

            /* Xv bicubic shader program */
	    BEGIN_RING(2*13);
            OUT_RING_REG(R300_VAP_PVS_VECTOR_INDX_REG, R300_PVS_VECTOR_INST_INDEX(11));
            /* PVS inst 0 */
            OUT_RING_REG(R300_VAP_PVS_VECTOR_DATA_REG,
                          (R300_PVS_DST_OPCODE(R300_VE_ADD) |
                           R300_PVS_DST_REG_TYPE(R300_PVS_DST_REG_OUT) |
			   R300_PVS_DST_OFFSET(0) |
                           R300_PVS_DST_WE_X | R300_PVS_DST_WE_Y |
                           R300_PVS_DST_WE_Z | R300_PVS_DST_WE_W));
	    OUT_RING_REG(R300_VAP_PVS_VECTOR_DATA_REG,
			  (R300_PVS_SRC_REG_TYPE(R300_PVS_SRC_REG_INPUT) |
                           R300_PVS_SRC_OFFSET(0) |
                           R300_PVS_SRC_SWIZZLE_X(R300_PVS_SRC_SELECT_X) |
                           R300_PVS_SRC_SWIZZLE_Y(R300_PVS_SRC_SELECT_Y) |
                           R300_PVS_SRC_SWIZZLE_Z(R300_PVS_SRC_SELECT_FORCE_0) |
                           R300_PVS_SRC_SWIZZLE_W(R300_PVS_SRC_SELECT_FORCE_1)));
	    OUT_RING_REG(R300_VAP_PVS_VECTOR_DATA_REG,
                          (R300_PVS_SRC_REG_TYPE(R300_PVS_SRC_REG_INPUT) |
                           R300_PVS_SRC_OFFSET(0) |
                           R300_PVS_SRC_SWIZZLE_X(R300_PVS_SRC_SELECT_FORCE_0) |
                           R300_PVS_SRC_SWIZZLE_Y(R300_PVS_SRC_SELECT_FORCE_0) |
			   R300_PVS_SRC_SWIZZLE_Z(R300_PVS_SRC_SELECT_FORCE_0) |
                           R300_PVS_SRC_SWIZZLE_W(R300_PVS_SRC_SELECT_FORCE_0)));
	    OUT_RING_REG(R300_VAP_PVS_VECTOR_DATA_REG,
			  (R300_PVS_SRC_REG_TYPE(R300_PVS_SRC_REG_INPUT) |
                           R300_PVS_SRC_OFFSET(0) |
                           R300_PVS_SRC_SWIZZLE_X(R300_PVS_SRC_SELECT_FORCE_0) |
			   R300_PVS_SRC_SWIZZLE_Y(R300_PVS_SRC_SELECT_FORCE_0) |
                           R300_PVS_SRC_SWIZZLE_Z(R300_PVS_SRC_SELECT_FORCE_0) |
                           R300_PVS_SRC_SWIZZLE_W(R300_PVS_SRC_SELECT_FORCE_0)));

            /* PVS inst 1 */
            OUT_RING_REG(R300_VAP_PVS_VECTOR_DATA_REG,
                          (R300_PVS_DST_OPCODE(R300_VE_ADD) |
                           R300_PVS_DST_REG_TYPE(R300_PVS_DST_REG_OUT) |
                           R300_PVS_DST_OFFSET(1) |
                           R300_PVS_DST_WE_X | R300_PVS_DST_WE_Y |
                           R300_PVS_DST_WE_Z | R300_PVS_DST_WE_W));
            OUT_RING_REG(R300_VAP_PVS_VECTOR_DATA_REG,
                          (R300_PVS_SRC_REG_TYPE(R300_PVS_SRC_REG_INPUT) |
                           R300_PVS_SRC_OFFSET(6) |
                           R300_PVS_SRC_SWIZZLE_X(R300_PVS_SRC_SELECT_X) |
                           R300_PVS_SRC_SWIZZLE_Y(R300_PVS_SRC_SELECT_Y) |
                           R300_PVS_SRC_SWIZZLE_Z(R300_PVS_SRC_SELECT_FORCE_0) |
                           R300_PVS_SRC_SWIZZLE_W(R300_PVS_SRC_SELECT_FORCE_1)));
	    OUT_RING_REG(R300_VAP_PVS_VECTOR_DATA_REG,
                          (R300_PVS_SRC_REG_TYPE(R300_PVS_SRC_REG_INPUT) |
                           R300_PVS_SRC_OFFSET(6) |
                           R300_PVS_SRC_SWIZZLE_X(R300_PVS_SRC_SELECT_FORCE_0) |
                           R300_PVS_SRC_SWIZZLE_Y(R300_PVS_SRC_SELECT_FORCE_0) |
			   R300_PVS_SRC_SWIZZLE_Z(R300_PVS_SRC_SELECT_FORCE_0) |
                           R300_PVS_SRC_SWIZZLE_W(R300_PVS_SRC_SELECT_FORCE_0)));
	    OUT_RING_REG(R300_VAP_PVS_VECTOR_DATA_REG,
			  (R300_PVS_SRC_REG_TYPE(R300_PVS_SRC_REG_INPUT) |
                           R300_PVS_SRC_OFFSET(6) |
                           R300_PVS_SRC_SWIZZLE_X(R300_PVS_SRC_SELECT_FORCE_0) |
			   R300_PVS_SRC_SWIZZLE_Y(R300_PVS_SRC_SELECT_FORCE_0) |
                           R300_PVS_SRC_SWIZZLE_Z(R300_PVS_SRC_SELECT_FORCE_0) |
                           R300_PVS_SRC_SWIZZLE_W(R300_PVS_SRC_SELECT_FORCE_0)));

            /* PVS inst 2 */
            OUT_RING_REG(R300_VAP_PVS_VECTOR_DATA_REG,
                          (R300_PVS_DST_OPCODE(R300_VE_ADD) |
                           R300_PVS_DST_REG_TYPE(R300_PVS_DST_REG_OUT) |
                           R300_PVS_DST_OFFSET(2) |
                           R300_PVS_DST_WE_X | R300_PVS_DST_WE_Y |
                           R300_PVS_DST_WE_Z | R300_PVS_DST_WE_W));
            OUT_RING_REG(R300_VAP_PVS_VECTOR_DATA_REG,
                          (R300_PVS_SRC_REG_TYPE(R300_PVS_SRC_REG_INPUT) |
                           R300_PVS_SRC_OFFSET(7) |
                           R300_PVS_SRC_SWIZZLE_X(R300_PVS_SRC_SELECT_X) |
                           R300_PVS_SRC_SWIZZLE_Y(R300_PVS_SRC_SELECT_Y) |
                           R300_PVS_SRC_SWIZZLE_Z(R300_PVS_SRC_SELECT_FORCE_0) |
                           R300_PVS_SRC_SWIZZLE_W(R300_PVS_SRC_SELECT_FORCE_1)));
            OUT_RING_REG(R300_VAP_PVS_VECTOR_DATA_REG,
                          (R300_PVS_SRC_REG_TYPE(R300_PVS_SRC_REG_INPUT) |
                           R300_PVS_SRC_OFFSET(7) |
                           R300_PVS_SRC_SWIZZLE_X(R300_PVS_SRC_SELECT_FORCE_0) |
                           R300_PVS_SRC_SWIZZLE_Y(R300_PVS_SRC_SELECT_FORCE_0) |
                           R300_PVS_SRC_SWIZZLE_Z(R300_PVS_SRC_SELECT_FORCE_0) |
                           R300_PVS_SRC_SWIZZLE_W(R300_PVS_SRC_SELECT_FORCE_0)));
            OUT_RING_REG(R300_VAP_PVS_VECTOR_DATA_REG,
                          (R300_PVS_SRC_REG_TYPE(R300_PVS_SRC_REG_INPUT) |
                           R300_PVS_SRC_OFFSET(7) |
                           R300_PVS_SRC_SWIZZLE_X(R300_PVS_SRC_SELECT_FORCE_0) |
                           R300_PVS_SRC_SWIZZLE_Y(R300_PVS_SRC_SELECT_FORCE_0) |
                           R300_PVS_SRC_SWIZZLE_Z(R300_PVS_SRC_SELECT_FORCE_0) |
                           R300_PVS_SRC_SWIZZLE_W(R300_PVS_SRC_SELECT_FORCE_0)));
            ADVANCE_RING();
	}

	/* pre-load the RS instructions */
	BEGIN_RING(2*4);
	if (IS_R300_3D) {
	    /* rasterizer source table
	     * R300_RS_TEX_PTR is the offset into the input RS stream
	     * 0,1 are tex0
	     * 2,3 are tex1
	     */
	    OUT_RING_REG(R300_RS_IP_0,
			  (R300_RS_TEX_PTR(0) |
			   R300_RS_SEL_S(R300_RS_SEL_C0) |
			   R300_RS_SEL_T(R300_RS_SEL_C1) |
			   R300_RS_SEL_R(R300_RS_SEL_K0) |
			   R300_RS_SEL_Q(R300_RS_SEL_K1)));
	    OUT_RING_REG(R300_RS_IP_1,
			  (R300_RS_TEX_PTR(2) |
			   R300_RS_SEL_S(R300_RS_SEL_C0) |
			   R300_RS_SEL_T(R300_RS_SEL_C1) |
			   R300_RS_SEL_R(R300_RS_SEL_K0) |
			   R300_RS_SEL_Q(R300_RS_SEL_K1)));
	    /* src tex */
	    /* R300_INST_TEX_ID - select the RS source table entry
	     * R300_INST_TEX_ADDR - the FS temp register for the texture data
	     */
	    OUT_RING_REG(R300_RS_INST_0, (R300_INST_TEX_ID(0) |
					   R300_RS_INST_TEX_CN_WRITE |
					   R300_INST_TEX_ADDR(0)));
	    /* mask tex */
	    OUT_RING_REG(R300_RS_INST_1, (R300_INST_TEX_ID(1) |
					   R300_RS_INST_TEX_CN_WRITE |
					   R300_INST_TEX_ADDR(1)));

	} else {
	    /* rasterizer source table
	     * R300_RS_TEX_PTR is the offset into the input RS stream
	     * 0,1 are tex0
	     * 2,3 are tex1
	     */
	    OUT_RING_REG(R500_RS_IP_0, ((0 << R500_RS_IP_TEX_PTR_S_SHIFT) |
					 (1 << R500_RS_IP_TEX_PTR_T_SHIFT) |
					 (R500_RS_IP_PTR_K0 << R500_RS_IP_TEX_PTR_R_SHIFT) |
					 (R500_RS_IP_PTR_K1 << R500_RS_IP_TEX_PTR_Q_SHIFT)));

	    OUT_RING_REG(R500_RS_IP_1, ((2 << R500_RS_IP_TEX_PTR_S_SHIFT) |
					 (3 << R500_RS_IP_TEX_PTR_T_SHIFT) |
					 (R500_RS_IP_PTR_K0 << R500_RS_IP_TEX_PTR_R_SHIFT) |
					 (R500_RS_IP_PTR_K1 << R500_RS_IP_TEX_PTR_Q_SHIFT)));
	    /* src tex */
	    /* R500_RS_INST_TEX_ID_SHIFT - select the RS source table entry
	     * R500_RS_INST_TEX_ADDR_SHIFT - the FS temp register for the texture data
	     */
	    OUT_RING_REG(R500_RS_INST_0, ((0 << R500_RS_INST_TEX_ID_SHIFT) |
					   R500_RS_INST_TEX_CN_WRITE |
					   (0 << R500_RS_INST_TEX_ADDR_SHIFT)));
	    /* mask tex */
	    OUT_RING_REG(R500_RS_INST_1, ((1 << R500_RS_INST_TEX_ID_SHIFT) |
					   R500_RS_INST_TEX_CN_WRITE |
					   (1 << R500_RS_INST_TEX_ADDR_SHIFT)));
	}
	ADVANCE_RING();

	if (IS_R300_3D)
	    BEGIN_RING(2*4);
	else {
	    BEGIN_RING(2*6);
	    OUT_RING_REG(R300_US_CONFIG, R500_ZERO_TIMES_ANYTHING_EQUALS_ZERO);
	    OUT_RING_REG(R500_US_FC_CTRL, 0);
	}
	OUT_RING_REG(R300_US_W_FMT, 0);
	OUT_RING_REG(R300_US_OUT_FMT_1, (R300_OUT_FMT_UNUSED |
					  R300_OUT_FMT_C0_SEL_BLUE |
					  R300_OUT_FMT_C1_SEL_GREEN |
					  R300_OUT_FMT_C2_SEL_RED |
					  R300_OUT_FMT_C3_SEL_ALPHA));
	OUT_RING_REG(R300_US_OUT_FMT_2, (R300_OUT_FMT_UNUSED |
					  R300_OUT_FMT_C0_SEL_BLUE |
					  R300_OUT_FMT_C1_SEL_GREEN |
					  R300_OUT_FMT_C2_SEL_RED |
					  R300_OUT_FMT_C3_SEL_ALPHA));
	OUT_RING_REG(R300_US_OUT_FMT_3, (R300_OUT_FMT_UNUSED |
					  R300_OUT_FMT_C0_SEL_BLUE |
					  R300_OUT_FMT_C1_SEL_GREEN |
					  R300_OUT_FMT_C2_SEL_RED |
					  R300_OUT_FMT_C3_SEL_ALPHA));
	ADVANCE_RING();


	BEGIN_RING(2*3);
	OUT_RING_REG(R300_FG_DEPTH_SRC, 0);
	OUT_RING_REG(R300_FG_FOG_BLEND, 0);
	OUT_RING_REG(R300_FG_ALPHA_FUNC, 0);
	ADVANCE_RING();

	BEGIN_RING(2*13);
	OUT_RING_REG(R300_RB3D_ABLENDCNTL, 0);
	OUT_RING_REG(R300_RB3D_ZSTENCILCNTL, 0);
	OUT_RING_REG(R300_RB3D_ZCACHE_CTLSTAT, R300_ZC_FLUSH | R300_ZC_FREE);
	OUT_RING_REG(R300_RB3D_BW_CNTL, 0);
	OUT_RING_REG(R300_RB3D_ZCNTL, 0);
	OUT_RING_REG(R300_RB3D_ZTOP, 0);
	OUT_RING_REG(R300_RB3D_ROPCNTL, 0);

	OUT_RING_REG(R300_RB3D_AARESOLVE_CTL, 0);
	OUT_RING_REG(R300_RB3D_COLOR_CHANNEL_MASK, (R300_BLUE_MASK_EN |
						     R300_GREEN_MASK_EN |
						     R300_RED_MASK_EN |
						     R300_ALPHA_MASK_EN));
	OUT_RING_REG(R300_RB3D_DSTCACHE_CTLSTAT, R300_DC_FLUSH_3D | R300_DC_FREE_3D);
	OUT_RING_REG(R300_RB3D_CCTL, 0);
	OUT_RING_REG(R300_RB3D_DITHER_CTL, 0);
	OUT_RING_REG(R300_RB3D_DSTCACHE_CTLSTAT, R300_DC_FLUSH_3D | R300_DC_FREE_3D);
	ADVANCE_RING();

	BEGIN_RING(2*5);
	OUT_RING_REG(R300_SC_EDGERULE, 0xA5294A5);
	if (IS_R300_3D) {
	    /* clip has offset 1440 */
	    OUT_RING_REG(R300_SC_CLIP_0_A, ((1440 << R300_CLIP_X_SHIFT) |
					     (1440 << R300_CLIP_Y_SHIFT)));
	    OUT_RING_REG(R300_SC_CLIP_0_B, ((4080 << R300_CLIP_X_SHIFT) |
					     (4080 << R300_CLIP_Y_SHIFT)));
	} else {
	    OUT_RING_REG(R300_SC_CLIP_0_A, ((0 << R300_CLIP_X_SHIFT) |
					     (0 << R300_CLIP_Y_SHIFT)));
	    OUT_RING_REG(R300_SC_CLIP_0_B, ((4080 << R300_CLIP_X_SHIFT) |
					     (4080 << R300_CLIP_Y_SHIFT)));
	}
	OUT_RING_REG(R300_SC_CLIP_RULE, 0xAAAA);
	OUT_RING_REG(R300_SC_SCREENDOOR, 0xffffff);
	ADVANCE_RING();
    } else if (IS_R200_3D) {

	BEGIN_RING(2*6);
	if (info->ChipFamily == CHIP_FAMILY_RS300) {
	    OUT_RING_REG(R200_SE_VAP_CNTL_STATUS, RADEON_TCL_BYPASS);
	} else {
	    OUT_RING_REG(R200_SE_VAP_CNTL_STATUS, 0);
	}
	OUT_RING_REG(R200_PP_CNTL_X, 0);
	OUT_RING_REG(R200_PP_TXMULTI_CTL_0, 0);
	OUT_RING_REG(R200_SE_VTX_STATE_CNTL, 0);
	OUT_RING_REG(R200_SE_VTE_CNTL, 0);
	OUT_RING_REG(R200_SE_VAP_CNTL, R200_VAP_FORCE_W_TO_ONE |
	    R200_VAP_VF_MAX_VTX_NUM);
	ADVANCE_RING();

	BEGIN_RING(2*4);
	OUT_RING_REG(R200_RE_AUX_SCISSOR_CNTL, 0);
	OUT_RING_REG(R200_RE_CNTL, 0);
	OUT_RING_REG(RADEON_RB3D_PLANEMASK, 0xffffffff);
	OUT_RING_REG(RADEON_SE_CNTL, (RADEON_DIFFUSE_SHADE_GOURAUD |
				       RADEON_BFACE_SOLID |
				       RADEON_FFACE_SOLID |
				       RADEON_VTX_PIX_CENTER_OGL |
				       RADEON_ROUND_MODE_ROUND |
				       RADEON_ROUND_PREC_4TH_PIX));
	ADVANCE_RING();
    } else {
	BEGIN_RING(2*2);
	if ((info->ChipFamily == CHIP_FAMILY_RADEON) ||
	    (info->ChipFamily == CHIP_FAMILY_RV200))
	    OUT_RING_REG(RADEON_SE_CNTL_STATUS, 0);
	else
	    OUT_RING_REG(RADEON_SE_CNTL_STATUS, RADEON_TCL_BYPASS);
	OUT_RING_REG(RADEON_SE_COORD_FMT,
		      RADEON_VTX_XY_PRE_MULT_1_OVER_W0 |
		      RADEON_VTX_ST0_PRE_MULT_1_OVER_W0 |
		      RADEON_VTX_ST1_PRE_MULT_1_OVER_W0 |
		      RADEON_TEX1_W_ROUTING_USE_W0);
	ADVANCE_RING();

	BEGIN_RING(2*2);
	OUT_RING_REG(RADEON_RB3D_PLANEMASK, 0xffffffff);
	OUT_RING_REG(RADEON_SE_CNTL, (RADEON_DIFFUSE_SHADE_GOURAUD |
				       RADEON_BFACE_SOLID |
				       RADEON_FFACE_SOLID |
				       RADEON_VTX_PIX_CENTER_OGL |
				       RADEON_ROUND_MODE_ROUND |
				       RADEON_ROUND_PREC_4TH_PIX));
	ADVANCE_RING();
    }

}

/* inserts a wait for vline in the command stream */
void RADEONWaitForVLine(ScrnInfoPtr pScrn, PixmapPtr pPix,
			xf86CrtcPtr crtc, int start, int stop)
{
    RADEONInfoPtr  info = RADEONPTR(pScrn);
    drmmode_crtc_private_ptr drmmode_crtc;

    if (!crtc)
	return;

    if (!crtc->enabled)
	return;

    if (pPix != pScrn->pScreen->GetScreenPixmap(pScrn->pScreen))
        return;

    start = max(start, crtc->y);
    stop = min(stop, crtc->y + crtc->mode.VDisplay);

    if (start >= stop)
	return;

    if (!IS_AVIVO_VARIANT) {
	/* on pre-r5xx vline starts at CRTC scanout */
	start -= crtc->y;
	stop -= crtc->y;
    }

    drmmode_crtc = crtc->driver_private;

    BEGIN_RING(2*3);
    if (IS_AVIVO_VARIANT) {
	OUT_RING_REG(AVIVO_D1MODE_VLINE_START_END, /* this is just a marker */
		      ((start << AVIVO_D1MODE_VLINE_START_SHIFT) |
		       (stop << AVIVO_D1MODE_VLINE_END_SHIFT) |
		       AVIVO_D1MODE_VLINE_INV));
    } else {
	OUT_RING_REG(RADEON_CRTC_GUI_TRIG_VLINE, /* another placeholder */
		      ((start << RADEON_CRTC_GUI_TRIG_VLINE_START_SHIFT) |
		       (stop << RADEON_CRTC_GUI_TRIG_VLINE_END_SHIFT) |
		       RADEON_CRTC_GUI_TRIG_VLINE_INV |
		       RADEON_CRTC_GUI_TRIG_VLINE_STALL));
    }
    OUT_RING_REG(RADEON_WAIT_UNTIL, (RADEON_WAIT_CRTC_VLINE |
				      RADEON_ENG_DISPLAY_SELECT_CRTC0));
    
    OUT_RING(CP_PACKET3(RADEON_CP_PACKET3_NOP, 0));
    OUT_RING(drmmode_crtc->mode_crtc->crtc_id);
    ADVANCE_RING();
}


void RADEONInit3DEngine(ScrnInfoPtr pScrn)
{
    RADEONInfoPtr info = RADEONPTR (pScrn);

    if (info->directRenderingEnabled) {
	RADEONInit3DEngineInternal(pScrn);
    }
    info->accel_state->XInited3D = TRUE;
}
@


1.8
log
@Update to xf86-video-ati 7.2.0, requested by jsg@@

It fixes an endianess problem with kms and the in tree x86-video-ati
among other things.
It has been tested on various i386/amd64/sparc64/macppc machines
on a range of hardware from r100->northern islands.
@
text
@d81 1
@


1.7
log
@Update to xf86-video-ati 6.14.6. Tested by mpi@@, brad, eric@@, ajacoutot@@.
@
text
@a82 1
#include "radeon_macros.h"
a84 4
#ifdef XF86DRI
#define _XF86DRI_SERVER_
#include "radeon_drm.h"
#endif
a93 325
static void R600EngineReset(ScrnInfoPtr pScrn);

#ifdef USE_XAA
static struct {
    int rop;
    int pattern;
} RADEON_ROP[] = {
    { RADEON_ROP3_ZERO, RADEON_ROP3_ZERO }, /* GXclear        */
    { RADEON_ROP3_DSa,  RADEON_ROP3_DPa  }, /* Gxand          */
    { RADEON_ROP3_SDna, RADEON_ROP3_PDna }, /* GXandReverse   */
    { RADEON_ROP3_S,    RADEON_ROP3_P    }, /* GXcopy         */
    { RADEON_ROP3_DSna, RADEON_ROP3_DPna }, /* GXandInverted  */
    { RADEON_ROP3_D,    RADEON_ROP3_D    }, /* GXnoop         */
    { RADEON_ROP3_DSx,  RADEON_ROP3_DPx  }, /* GXxor          */
    { RADEON_ROP3_DSo,  RADEON_ROP3_DPo  }, /* GXor           */
    { RADEON_ROP3_DSon, RADEON_ROP3_DPon }, /* GXnor          */
    { RADEON_ROP3_DSxn, RADEON_ROP3_PDxn }, /* GXequiv        */
    { RADEON_ROP3_Dn,   RADEON_ROP3_Dn   }, /* GXinvert       */
    { RADEON_ROP3_SDno, RADEON_ROP3_PDno }, /* GXorReverse    */
    { RADEON_ROP3_Sn,   RADEON_ROP3_Pn   }, /* GXcopyInverted */
    { RADEON_ROP3_DSno, RADEON_ROP3_DPno }, /* GXorInverted   */
    { RADEON_ROP3_DSan, RADEON_ROP3_DPan }, /* GXnand         */
    { RADEON_ROP3_ONE,  RADEON_ROP3_ONE  }  /* GXset          */
};
#endif

/* The FIFO has 64 slots.  This routines waits until at least `entries'
 * of these slots are empty.
 */
void RADEONWaitForFifoFunction(ScrnInfoPtr pScrn, int entries)
{
    RADEONInfoPtr  info       = RADEONPTR(pScrn);
    unsigned char *RADEONMMIO = info->MMIO;
    int            i;

    for (;;) {
	for (i = 0; i < RADEON_TIMEOUT; i++) {
	    info->accel_state->fifo_slots =
		INREG(RADEON_RBBM_STATUS) & RADEON_RBBM_FIFOCNT_MASK;
	    if (info->accel_state->fifo_slots >= entries) return;
	}
	xf86DrvMsgVerb(pScrn->scrnIndex, X_INFO, RADEON_LOGLEVEL_DEBUG,
		       "FIFO timed out: %u entries, stat=0x%08x\n",
		       (unsigned int)INREG(RADEON_RBBM_STATUS) & RADEON_RBBM_FIFOCNT_MASK,
		       (unsigned int)INREG(RADEON_RBBM_STATUS));
	xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
		   "FIFO timed out, resetting engine...\n");
	RADEONEngineReset(pScrn);
	RADEONEngineRestore(pScrn);
#ifdef XF86DRI
	if (info->directRenderingEnabled) {
	    RADEONCP_RESET(pScrn, info);
	    RADEONCP_START(pScrn, info);
	}
#endif
    }
}

void R600WaitForFifoFunction(ScrnInfoPtr pScrn, int entries)
{
    RADEONInfoPtr  info       = RADEONPTR(pScrn);
    unsigned char *RADEONMMIO = info->MMIO;
    int            i;

    for (;;) {
	for (i = 0; i < RADEON_TIMEOUT; i++) {
	    if (info->ChipFamily >= CHIP_FAMILY_RV770)
		info->accel_state->fifo_slots =
		    INREG(R600_GRBM_STATUS) & R700_CMDFIFO_AVAIL_MASK;
	    else
		info->accel_state->fifo_slots =
		    INREG(R600_GRBM_STATUS) & R600_CMDFIFO_AVAIL_MASK;
	    if (info->accel_state->fifo_slots >= entries) return;
	}
	xf86DrvMsgVerb(pScrn->scrnIndex, X_INFO, RADEON_LOGLEVEL_DEBUG,
		       "FIFO timed out: stat=0x%08x\n",
		       (unsigned int)INREG(R600_GRBM_STATUS));
	xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
		   "FIFO timed out, resetting engine...\n");
	R600EngineReset(pScrn);
#ifdef XF86DRI
	if (info->directRenderingEnabled) {
	    RADEONCP_RESET(pScrn, info);
	    RADEONCP_START(pScrn, info);
	}
#endif
    }
}

/* Flush all dirty data in the Pixel Cache to memory */
void RADEONEngineFlush(ScrnInfoPtr pScrn)
{
    RADEONInfoPtr  info       = RADEONPTR(pScrn);
    unsigned char *RADEONMMIO = info->MMIO;
    int            i;

    if (info->ChipFamily <= CHIP_FAMILY_RV280) {
	OUTREGP(RADEON_RB3D_DSTCACHE_CTLSTAT,
		RADEON_RB3D_DC_FLUSH_ALL,
		~RADEON_RB3D_DC_FLUSH_ALL);
	for (i = 0; i < RADEON_TIMEOUT; i++) {
	    if (!(INREG(RADEON_RB3D_DSTCACHE_CTLSTAT) & RADEON_RB3D_DC_BUSY))
		break;
	}
	if (i == RADEON_TIMEOUT) {
	    xf86DrvMsgVerb(pScrn->scrnIndex, X_INFO, RADEON_LOGLEVEL_DEBUG,
			   "DC flush timeout: %x\n",
			   (unsigned int)INREG(RADEON_RB3D_DSTCACHE_CTLSTAT));
	}
    } else {
	OUTREGP(R300_DSTCACHE_CTLSTAT,
		R300_RB2D_DC_FLUSH_ALL,
		~R300_RB2D_DC_FLUSH_ALL);
	for (i = 0; i < RADEON_TIMEOUT; i++) {
	    if (!(INREG(R300_DSTCACHE_CTLSTAT) & R300_RB2D_DC_BUSY))
		break;
	}
	if (i == RADEON_TIMEOUT) {
	    xf86DrvMsgVerb(pScrn->scrnIndex, X_INFO, RADEON_LOGLEVEL_DEBUG,
			   "DC flush timeout: %x\n",
			   (unsigned int)INREG(R300_DSTCACHE_CTLSTAT));
	}
    }
}

/* Reset graphics card to known state */
void RADEONEngineReset(ScrnInfoPtr pScrn)
{
    RADEONInfoPtr  info       = RADEONPTR(pScrn);
    unsigned char *RADEONMMIO = info->MMIO;
    uint32_t       clock_cntl_index;
    uint32_t       mclk_cntl;
    uint32_t       rbbm_soft_reset;
    uint32_t       host_path_cntl;

    /* The following RBBM_SOFT_RESET sequence can help un-wedge
     * an R300 after the command processor got stuck.
     */
    rbbm_soft_reset = INREG(RADEON_RBBM_SOFT_RESET);
    OUTREG(RADEON_RBBM_SOFT_RESET, (rbbm_soft_reset |
                                   RADEON_SOFT_RESET_CP |
                                   RADEON_SOFT_RESET_HI |
                                   RADEON_SOFT_RESET_SE |
                                   RADEON_SOFT_RESET_RE |
                                   RADEON_SOFT_RESET_PP |
                                   RADEON_SOFT_RESET_E2 |
                                   RADEON_SOFT_RESET_RB));
    INREG(RADEON_RBBM_SOFT_RESET);
    OUTREG(RADEON_RBBM_SOFT_RESET, (rbbm_soft_reset & (uint32_t)
                                   ~(RADEON_SOFT_RESET_CP |
                                     RADEON_SOFT_RESET_HI |
                                     RADEON_SOFT_RESET_SE |
                                     RADEON_SOFT_RESET_RE |
                                     RADEON_SOFT_RESET_PP |
                                     RADEON_SOFT_RESET_E2 |
                                     RADEON_SOFT_RESET_RB)));
    INREG(RADEON_RBBM_SOFT_RESET);
    OUTREG(RADEON_RBBM_SOFT_RESET, rbbm_soft_reset);
    INREG(RADEON_RBBM_SOFT_RESET);

    RADEONEngineFlush(pScrn);

    clock_cntl_index = INREG(RADEON_CLOCK_CNTL_INDEX);
    RADEONPllErrataAfterIndex(info);

#if 0 /* taken care of by new PM code */
    /* Some ASICs have bugs with dynamic-on feature, which are
     * ASIC-version dependent, so we force all blocks on for now
     */
    if (info->HasCRTC2) {
	uint32_t tmp;

	tmp = INPLL(pScrn, RADEON_SCLK_CNTL);
	OUTPLL(RADEON_SCLK_CNTL, ((tmp & ~RADEON_DYN_STOP_LAT_MASK) |
				  RADEON_CP_MAX_DYN_STOP_LAT |
				  RADEON_SCLK_FORCEON_MASK));

	if (info->ChipFamily == CHIP_FAMILY_RV200) {
	    tmp = INPLL(pScrn, RADEON_SCLK_MORE_CNTL);
	    OUTPLL(RADEON_SCLK_MORE_CNTL, tmp | RADEON_SCLK_MORE_FORCEON);
	}
    }
#endif /* new PM code */

    mclk_cntl = INPLL(pScrn, RADEON_MCLK_CNTL);

#if 0 /* handled by new PM code */
    OUTPLL(RADEON_MCLK_CNTL, (mclk_cntl |
			      RADEON_FORCEON_MCLKA |
			      RADEON_FORCEON_MCLKB |
			      RADEON_FORCEON_YCLKA |
			      RADEON_FORCEON_YCLKB |
			      RADEON_FORCEON_MC |
			      RADEON_FORCEON_AIC));
#endif /* new PM code */

    /* Soft resetting HDP thru RBBM_SOFT_RESET register can cause some
     * unexpected behaviour on some machines.  Here we use
     * RADEON_HOST_PATH_CNTL to reset it.
     */
    host_path_cntl = INREG(RADEON_HOST_PATH_CNTL);
    rbbm_soft_reset = INREG(RADEON_RBBM_SOFT_RESET);

    if (IS_R300_VARIANT || IS_AVIVO_VARIANT) {
	uint32_t tmp;

	OUTREG(RADEON_RBBM_SOFT_RESET, (rbbm_soft_reset |
					RADEON_SOFT_RESET_CP |
					RADEON_SOFT_RESET_HI |
					RADEON_SOFT_RESET_E2));
	INREG(RADEON_RBBM_SOFT_RESET);
	OUTREG(RADEON_RBBM_SOFT_RESET, 0);
	tmp = INREG(RADEON_RB3D_DSTCACHE_MODE);
	OUTREG(RADEON_RB3D_DSTCACHE_MODE, tmp | (1 << 17)); /* FIXME */
    } else {
	OUTREG(RADEON_RBBM_SOFT_RESET, (rbbm_soft_reset |
					RADEON_SOFT_RESET_CP |
					RADEON_SOFT_RESET_SE |
					RADEON_SOFT_RESET_RE |
					RADEON_SOFT_RESET_PP |
					RADEON_SOFT_RESET_E2 |
					RADEON_SOFT_RESET_RB));
	INREG(RADEON_RBBM_SOFT_RESET);
	OUTREG(RADEON_RBBM_SOFT_RESET, (rbbm_soft_reset & (uint32_t)
					~(RADEON_SOFT_RESET_CP |
					  RADEON_SOFT_RESET_SE |
					  RADEON_SOFT_RESET_RE |
					  RADEON_SOFT_RESET_PP |
					  RADEON_SOFT_RESET_E2 |
					  RADEON_SOFT_RESET_RB)));
	INREG(RADEON_RBBM_SOFT_RESET);
    }

    if (!IS_R300_VARIANT && !IS_AVIVO_VARIANT)
	OUTREG(RADEON_RBBM_SOFT_RESET, rbbm_soft_reset);

    OUTREG(RADEON_CLOCK_CNTL_INDEX, clock_cntl_index);
    RADEONPllErrataAfterIndex(info);
    OUTPLL(pScrn, RADEON_MCLK_CNTL, mclk_cntl);
}

/* Reset graphics card to known state */
static void R600EngineReset(ScrnInfoPtr pScrn)
{
    RADEONInfoPtr  info       = RADEONPTR(pScrn);
    unsigned char *RADEONMMIO = info->MMIO;
    uint32_t cp_ptr, cp_me_cntl, cp_rb_cntl;

    cp_ptr = INREG(R600_CP_RB_WPTR);

    cp_me_cntl = INREG(R600_CP_ME_CNTL);
    OUTREG(R600_CP_ME_CNTL, 0x10000000);

    OUTREG(R600_GRBM_SOFT_RESET, 0x7fff);
    INREG(R600_GRBM_SOFT_RESET);
    usleep (50);
    OUTREG(R600_GRBM_SOFT_RESET, 0);
    INREG(R600_GRBM_SOFT_RESET);

    OUTREG(R600_CP_RB_WPTR_DELAY, 0);
    cp_rb_cntl = INREG(R600_CP_RB_CNTL);
    OUTREG(R600_CP_RB_CNTL, 0x80000000);

    OUTREG(R600_CP_RB_RPTR_WR, cp_ptr);
    OUTREG(R600_CP_RB_WPTR, cp_ptr);
    OUTREG(R600_CP_RB_CNTL, cp_rb_cntl);
    OUTREG(R600_CP_ME_CNTL, cp_me_cntl);

}

/* Restore the acceleration hardware to its previous state */
void RADEONEngineRestore(ScrnInfoPtr pScrn)
{
    RADEONInfoPtr  info       = RADEONPTR(pScrn);
    unsigned char *RADEONMMIO = info->MMIO;

    if (info->cs)
      return;

    xf86DrvMsgVerb(pScrn->scrnIndex, X_INFO, RADEON_LOGLEVEL_DEBUG,
		   "EngineRestore (%d/%d)\n",
		   info->CurrentLayout.pixel_code,
		   info->CurrentLayout.bitsPerPixel);

    /* Setup engine location. This shouldn't be necessary since we
     * set them appropriately before any accel ops, but let's avoid
     * random bogus DMA in case we inadvertently trigger the engine
     * in the wrong place (happened).
     */
    RADEONWaitForFifo(pScrn, 2);
    OUTREG(RADEON_DST_PITCH_OFFSET, info->accel_state->dst_pitch_offset);
    OUTREG(RADEON_SRC_PITCH_OFFSET, info->accel_state->dst_pitch_offset);

    RADEONWaitForFifo(pScrn, 1);
#if X_BYTE_ORDER == X_BIG_ENDIAN
    OUTREGP(RADEON_DP_DATATYPE,
	    RADEON_HOST_BIG_ENDIAN_EN,
	    ~RADEON_HOST_BIG_ENDIAN_EN);
#else
    OUTREGP(RADEON_DP_DATATYPE, 0, ~RADEON_HOST_BIG_ENDIAN_EN);
#endif

    /* Restore SURFACE_CNTL */
    OUTREG(RADEON_SURFACE_CNTL, info->ModeReg->surface_cntl);

    RADEONWaitForFifo(pScrn, 1);
    OUTREG(RADEON_DEFAULT_SC_BOTTOM_RIGHT, (RADEON_DEFAULT_SC_RIGHT_MAX
					    | RADEON_DEFAULT_SC_BOTTOM_MAX));
    RADEONWaitForFifo(pScrn, 1);
    OUTREG(RADEON_DP_GUI_MASTER_CNTL, (info->accel_state->dp_gui_master_cntl
				       | RADEON_GMC_BRUSH_SOLID_COLOR
				       | RADEON_GMC_SRC_DATATYPE_COLOR));

    RADEONWaitForFifo(pScrn, 5);
    OUTREG(RADEON_DP_BRUSH_FRGD_CLR, 0xffffffff);
    OUTREG(RADEON_DP_BRUSH_BKGD_CLR, 0x00000000);
    OUTREG(RADEON_DP_SRC_FRGD_CLR,   0xffffffff);
    OUTREG(RADEON_DP_SRC_BKGD_CLR,   0x00000000);
    OUTREG(RADEON_DP_WRITE_MASK,     0xffffffff);

    RADEONWaitForIdleMMIO(pScrn);

    info->accel_state->XInited3D = FALSE;
}

d97 4
a100 13
    if (info->dri->pKernelDRMVersion->version_major < 2) {
        drm_radeon_getparam_t np;

        memset(&np, 0, sizeof(np));
        np.param = RADEON_PARAM_NUM_GB_PIPES;
        np.value = num_pipes;
        return drmCommandWriteRead(info->dri->drmFD, DRM_RADEON_GETPARAM, &np, sizeof(np));
    } else {
        struct drm_radeon_info np2;
        np2.value = (unsigned long)num_pipes;
        np2.request = RADEON_INFO_NUM_GB_PIPES;
        return drmCommandWriteRead(info->dri->drmFD, DRM_RADEON_INFO, &np2, sizeof(np2));
    }
a106 2
    unsigned char *RADEONMMIO = info->MMIO;
    int datatype = 0;
a108 6
    xf86DrvMsgVerb(pScrn->scrnIndex, X_INFO, RADEON_LOGLEVEL_DEBUG,
		   "EngineInit (%d/%d)\n",
		   info->CurrentLayout.pixel_code,
		   info->CurrentLayout.bitsPerPixel);

#ifdef XF86DRI
a120 105
#endif

    if (!info->cs) {
	if ((info->ChipFamily == CHIP_FAMILY_RV410) ||
	    (info->ChipFamily == CHIP_FAMILY_R420)  ||
	    (info->ChipFamily == CHIP_FAMILY_RS600) ||
	    (info->ChipFamily == CHIP_FAMILY_RS690) ||
	    (info->ChipFamily == CHIP_FAMILY_RS740) ||
	    (info->ChipFamily == CHIP_FAMILY_RS400) ||
	    (info->ChipFamily == CHIP_FAMILY_RS480) ||
	    IS_R500_3D) {
	    if (info->accel_state->num_gb_pipes == 0) {
		uint32_t gb_pipe_sel = INREG(R400_GB_PIPE_SELECT);

		info->accel_state->num_gb_pipes = ((gb_pipe_sel >> 12) & 0x3) + 1;
		if (IS_R500_3D)
		    OUTPLL(pScrn, R500_DYN_SCLK_PWMEM_PIPE, (1 | ((gb_pipe_sel >> 8) & 0xf) << 4));
	    }
	} else {
	    if (info->accel_state->num_gb_pipes == 0) {
		if ((info->ChipFamily == CHIP_FAMILY_R300) ||
		    (info->ChipFamily == CHIP_FAMILY_R350)) {
		    /* R3xx chips */
		    info->accel_state->num_gb_pipes = 2;
		} else {
		    /* RV3xx chips */
		    info->accel_state->num_gb_pipes = 1;
		}
	    }
	}

	/* SE cards only have 1 quadpipe */
	if ((info->Chipset == PCI_CHIP_RV410_5E4C) ||
	    (info->Chipset == PCI_CHIP_RV410_5E4F) ||
	    (info->Chipset == PCI_CHIP_R300_AD) ||
	    (info->Chipset == PCI_CHIP_R350_AH))
	    info->accel_state->num_gb_pipes = 1;

	if (IS_R300_3D || IS_R500_3D)
	    xf86DrvMsg(pScrn->scrnIndex, X_INFO,
		       "num quad-pipes is %d\n", info->accel_state->num_gb_pipes);

	if (IS_R300_3D || IS_R500_3D) {
	    uint32_t gb_tile_config = (R300_ENABLE_TILING | R300_TILE_SIZE_16);
	    
	    switch(info->accel_state->num_gb_pipes) {
	    case 2: gb_tile_config |= R300_PIPE_COUNT_R300; break;
	    case 3: gb_tile_config |= R300_PIPE_COUNT_R420_3P; break;
	    case 4: gb_tile_config |= R300_PIPE_COUNT_R420; break;
	    default:
	    case 1: gb_tile_config |= R300_PIPE_COUNT_RV350; break;
	    }

	    OUTREG(R300_GB_TILE_CONFIG, gb_tile_config);
	    OUTREG(RADEON_WAIT_UNTIL, RADEON_WAIT_2D_IDLECLEAN | RADEON_WAIT_3D_IDLECLEAN);
	    if (info->ChipFamily >= CHIP_FAMILY_R420)
		OUTREG(R300_DST_PIPE_CONFIG, INREG(R300_DST_PIPE_CONFIG) | R300_PIPE_AUTO_CONFIG);
	    OUTREG(R300_RB2D_DSTCACHE_MODE, (INREG(R300_RB2D_DSTCACHE_MODE) |
					     R300_DC_AUTOFLUSH_ENABLE |
					     R300_DC_DC_DISABLE_IGNORE_PE));
	} else
	    OUTREG(RADEON_RB3D_CNTL, 0);
	
	RADEONEngineReset(pScrn);
    }

    switch (info->CurrentLayout.pixel_code) {
    case 8:  datatype = 2; break;
    case 15: datatype = 3; break;
    case 16: datatype = 4; break;
    case 24: datatype = 5; break;
    case 32: datatype = 6; break;
    default:
	xf86DrvMsgVerb(pScrn->scrnIndex, X_INFO, RADEON_LOGLEVEL_DEBUG,
		       "Unknown depth/bpp = %d/%d (code = %d)\n",
		       info->CurrentLayout.depth,
		       info->CurrentLayout.bitsPerPixel,
		       info->CurrentLayout.pixel_code);
    }

    info->accel_state->dp_gui_master_cntl =
	((datatype << RADEON_GMC_DST_DATATYPE_SHIFT)
	 | RADEON_GMC_CLR_CMP_CNTL_DIS
	 | RADEON_GMC_DST_PITCH_OFFSET_CNTL);

    RADEONEngineRestore(pScrn);
}

uint32_t radeonGetPixmapOffset(PixmapPtr pPix)
{
    ScrnInfoPtr pScrn = xf86ScreenToScrn(pPix->drawable.pScreen);
    RADEONInfoPtr info = RADEONPTR(pScrn);
    uint32_t offset = 0;
    if (info->cs)
	return 0;
#ifdef USE_EXA
    if (info->useEXA) {
	offset = exaGetPixmapOffset(pPix);
    } else
#endif
    {
	offset = pPix->devPrivate.ptr - info->FB;
    }
    offset += info->fbLocation + pScrn->fbOffset;
    return offset;
d127 1
a127 368
#ifdef XF86DRM_MODE
    if (info->cs)
	return (info->cs->ndw - info->cs->cdw);
    else
#endif
        return (info->cp->indirectBuffer->total - info->cp->indirectBuffer->used) / (int)sizeof(uint32_t);
}

#define ACCEL_MMIO
#define ACCEL_PREAMBLE()        unsigned char *RADEONMMIO = info->MMIO
#define BEGIN_ACCEL(n)          RADEONWaitForFifo(pScrn, (n))
#define OUT_ACCEL_REG(reg, val) OUTREG(reg, val)
#define FINISH_ACCEL()

#include "radeon_commonfuncs.c"
#if defined(RENDER) && defined(USE_XAA)
#include "radeon_render.c"
#endif
#include "radeon_accelfuncs.c"

#undef ACCEL_MMIO
#undef ACCEL_PREAMBLE
#undef BEGIN_ACCEL
#undef OUT_ACCEL_REG
#undef FINISH_ACCEL

#ifdef XF86DRI

#define ACCEL_CP
#define ACCEL_PREAMBLE()						\
    RING_LOCALS;							\
    RADEONCP_REFRESH(pScrn, info)
#define BEGIN_ACCEL(n)          BEGIN_RING(2*(n))
#define OUT_ACCEL_REG(reg, val) OUT_RING_REG(reg, val)
#define FINISH_ACCEL()          ADVANCE_RING()


#include "radeon_commonfuncs.c"
#if defined(RENDER) && defined(USE_XAA)
#include "radeon_render.c"
#endif
#include "radeon_accelfuncs.c"

#undef ACCEL_CP
#undef ACCEL_PREAMBLE
#undef BEGIN_ACCEL
#undef OUT_ACCEL_REG
#undef FINISH_ACCEL

/* Stop the CP */
int RADEONCPStop(ScrnInfoPtr pScrn, RADEONInfoPtr info)
{
    drm_radeon_cp_stop_t  stop;
    int              ret, i;

    stop.flush = 1;
    stop.idle  = 1;

    ret = drmCommandWrite(info->dri->drmFD, DRM_RADEON_CP_STOP, &stop,
			  sizeof(drm_radeon_cp_stop_t));

    if (ret == 0) {
	return 0;
    } else if (errno != EBUSY) {
	return -errno;
    }

    stop.flush = 0;

    i = 0;
    do {
	ret = drmCommandWrite(info->dri->drmFD, DRM_RADEON_CP_STOP, &stop,
			      sizeof(drm_radeon_cp_stop_t));
    } while (ret && errno == EBUSY && i++ < RADEON_IDLE_RETRY);

    if (ret == 0) {
	return 0;
    } else if (errno != EBUSY) {
	return -errno;
    }

    stop.idle = 0;

    if (drmCommandWrite(info->dri->drmFD, DRM_RADEON_CP_STOP,
			&stop, sizeof(drm_radeon_cp_stop_t))) {
	return -errno;
    } else {
	return 0;
    }
}

#define RADEON_IB_RESERVE (16 * sizeof(uint32_t))

/* Get an indirect buffer for the CP 2D acceleration commands  */
drmBufPtr RADEONCPGetBuffer(ScrnInfoPtr pScrn)
{
    RADEONInfoPtr  info = RADEONPTR(pScrn);
    drmDMAReq      dma;
    drmBufPtr      buf = NULL;
    int            indx = 0;
    int            size = 0;
    int            i = 0;
    int            ret;

#if 0
    /* FIXME: pScrn->pScreen has not been initialized when this is first
     * called from RADEONSelectBuffer via RADEONDRICPInit.  We could use
     * the screen index from pScrn, which is initialized, and then get
     * the screen from screenInfo.screens[index], but that is a hack.
     */
    dma.context = DRIGetContext(pScrn->pScreen);
#else
    /* This is the X server's context */
    dma.context = 0x00000001;
#endif

    dma.send_count    = 0;
    dma.send_list     = NULL;
    dma.send_sizes    = NULL;
    dma.flags         = 0;
    dma.request_count = 1;
    dma.request_size  = RADEON_BUFFER_SIZE;
    dma.request_list  = &indx;
    dma.request_sizes = &size;
    dma.granted_count = 0;

    while (1) {
	do {
	    ret = drmDMA(info->dri->drmFD, &dma);
	    if (ret && ret != -EBUSY) {
		xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
			   "%s: CP GetBuffer %d\n", __FUNCTION__, ret);
	    }
	} while ((ret == -EBUSY) && (i++ < RADEON_TIMEOUT));

	if (ret == 0) {
	    buf = &info->dri->buffers->list[indx];
	    buf->used = 0;
	    if (RADEON_VERBOSE) {
		xf86DrvMsg(pScrn->scrnIndex, X_INFO,
			   "   GetBuffer returning %d %p\n",
			   buf->idx, buf->address);
	    }
	    return buf;
	}

	xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
		   "GetBuffer timed out, resetting engine...\n");

	if (info->ChipFamily < CHIP_FAMILY_R600) {
	    RADEONEngineReset(pScrn);
	    RADEONEngineRestore(pScrn);
	} else
	    R600EngineReset(pScrn);

	/* Always restart the engine when doing CP 2D acceleration */
	RADEONCP_RESET(pScrn, info);
	RADEONCP_START(pScrn, info);
    }
}

/* Flush the indirect buffer to the kernel for submission to the card */
void RADEONCPFlushIndirect(ScrnInfoPtr pScrn, int discard)
{
    RADEONInfoPtr      info   = RADEONPTR(pScrn);
    drmBufPtr          buffer = info->cp->indirectBuffer;
    int                start  = info->cp->indirectStart;
    drm_radeon_indirect_t  indirect;

    assert(!info->cs);
    if (!buffer) return;
    if (start == buffer->used && !discard) return;

    if (RADEON_VERBOSE) {
	xf86DrvMsg(pScrn->scrnIndex, X_INFO, "Flushing buffer %d\n",
		   buffer->idx);
    }

    if (info->ChipFamily >= CHIP_FAMILY_R600) {
	if (buffer->used & 0x3c) {
	    RING_LOCALS;

	    while (buffer->used & 0x3c) {
		BEGIN_RING(1);
		OUT_RING(CP_PACKET2()); /* fill up to multiple of 16 dwords */
		ADVANCE_RING();
	    }
	}
    }

    indirect.idx     = buffer->idx;
    indirect.start   = start;
    indirect.end     = buffer->used;
    indirect.discard = discard;

    drmCommandWriteRead(info->dri->drmFD, DRM_RADEON_INDIRECT,
			&indirect, sizeof(drm_radeon_indirect_t));

    if (discard) {
	info->cp->indirectBuffer = RADEONCPGetBuffer(pScrn);
	info->cp->indirectStart  = 0;
    } else {
	/* Start on a double word boundary */
	info->cp->indirectStart  = buffer->used = RADEON_ALIGN(buffer->used, 8);
	if (RADEON_VERBOSE) {
	    xf86DrvMsg(pScrn->scrnIndex, X_INFO, "   Starting at %d\n",
		       info->cp->indirectStart);
	}
    }
}

/* Flush and release the indirect buffer */
void RADEONCPReleaseIndirect(ScrnInfoPtr pScrn)
{
    RADEONInfoPtr      info   = RADEONPTR(pScrn);
    drmBufPtr          buffer = info->cp->indirectBuffer;
    int                start  = info->cp->indirectStart;
    drm_radeon_indirect_t  indirect;

    assert(!info->cs);
    if (info->ChipFamily >= CHIP_FAMILY_R600) {
	if (buffer && (buffer->used & 0x3c)) {
	    RING_LOCALS;

	    while (buffer->used & 0x3c) {
		BEGIN_RING(1);
		OUT_RING(CP_PACKET2()); /* fill up to multiple of 16 dwords */
		ADVANCE_RING();
	    }
	}
    }

    info->cp->indirectBuffer = NULL;
    info->cp->indirectStart  = 0;

    if (!buffer) return;

    if (RADEON_VERBOSE) {
	xf86DrvMsg(pScrn->scrnIndex, X_INFO, "Releasing buffer %d\n",
		   buffer->idx);
    }

    indirect.idx     = buffer->idx;
    indirect.start   = start;
    indirect.end     = buffer->used;
    indirect.discard = 1;

    drmCommandWriteRead(info->dri->drmFD, DRM_RADEON_INDIRECT,
			&indirect, sizeof(drm_radeon_indirect_t));
}

/** \brief Calculate HostDataBlit parameters from pointer and pitch
 *
 * This is a helper for the trivial HostDataBlit users that don't need to worry
 * about tiling etc.
 */
void
RADEONHostDataParams(ScrnInfoPtr pScrn, uint8_t *dst, uint32_t pitch, int cpp,
		     uint32_t *dstPitchOff, int *x, int *y)
{
    RADEONInfoPtr info = RADEONPTR( pScrn );
    uint32_t dstOffs = dst - (uint8_t*)info->FB + info->fbLocation;

    *dstPitchOff = pitch << 16 | (dstOffs & ~RADEON_BUFFER_ALIGN) >> 10;
    *y = ( dstOffs & RADEON_BUFFER_ALIGN ) / pitch;
    *x = ( ( dstOffs & RADEON_BUFFER_ALIGN ) - ( *y * pitch ) ) / cpp;
}

/* Set up a hostdata blit to transfer data from system memory to the
 * framebuffer. Returns the address where the data can be written to and sets
 * the dstPitch and hpass variables as required.
 */
uint8_t*
RADEONHostDataBlit(
    ScrnInfoPtr pScrn,
    unsigned int cpp,
    unsigned int w,
    uint32_t dstPitchOff,
    uint32_t *bufPitch,
    int x,
    int *y,
    unsigned int *h,
    unsigned int *hpass
){
    RADEONInfoPtr info = RADEONPTR( pScrn );
    uint32_t format, dwords;
    uint8_t *ret;
    RING_LOCALS;

    if ( *h == 0 )
    {
	return NULL;
    }

    switch ( cpp )
    {
    case 4:
	format = RADEON_GMC_DST_32BPP;
	*bufPitch = 4 * w;
	break;
    case 2:
	format = RADEON_GMC_DST_16BPP;
	*bufPitch = 2 * RADEON_ALIGN(w, 2);
	break;
    case 1:
	format = RADEON_GMC_DST_8BPP_CI;
	*bufPitch = RADEON_ALIGN(w, 4);
	break;
    default:
	xf86DrvMsg( pScrn->scrnIndex, X_ERROR,
		    "%s: Unsupported cpp %d!\n", __func__, cpp );
	return NULL;
    }

#if X_BYTE_ORDER == X_BIG_ENDIAN
    /* Swap doesn't work on R300 and later, it's handled during the
     * copy to ind. buffer pass
     */
    if (info->ChipFamily < CHIP_FAMILY_R300) {
        BEGIN_RING(2);
	if (cpp == 2)
	    OUT_RING_REG(RADEON_RBBM_GUICNTL,
			 RADEON_HOST_DATA_SWAP_HDW);
	else if (cpp == 1)
	    OUT_RING_REG(RADEON_RBBM_GUICNTL,
			 RADEON_HOST_DATA_SWAP_32BIT);
	else
	    OUT_RING_REG(RADEON_RBBM_GUICNTL,
			 RADEON_HOST_DATA_SWAP_NONE);
	ADVANCE_RING();
    }
#endif

    /*RADEON_PURGE_CACHE();
      RADEON_WAIT_UNTIL_IDLE();*/

    *hpass = min( *h, ( ( RADEON_BUFFER_SIZE - 10 * 4 ) / *bufPitch ) );
    dwords = *hpass * *bufPitch / 4;

    BEGIN_RING( dwords + 10 );
    OUT_RING( CP_PACKET3( RADEON_CP_PACKET3_CNTL_HOSTDATA_BLT, dwords + 10 - 2 ) );
    OUT_RING( RADEON_GMC_DST_PITCH_OFFSET_CNTL
	    | RADEON_GMC_DST_CLIPPING
	    | RADEON_GMC_BRUSH_NONE
	    | format
	    | RADEON_GMC_SRC_DATATYPE_COLOR
	    | RADEON_ROP3_S
	    | RADEON_DP_SRC_SOURCE_HOST_DATA
	    | RADEON_GMC_CLR_CMP_CNTL_DIS
	    | RADEON_GMC_WR_MSK_DIS );
    OUT_RING( dstPitchOff );
    OUT_RING( (*y << 16) | x );
    OUT_RING( ((*y + *hpass) << 16) | (x + w) );
    OUT_RING( 0xffffffff );
    OUT_RING( 0xffffffff );
    OUT_RING( *y << 16 | x );
    OUT_RING( *hpass << 16 | (*bufPitch / cpp) );
    OUT_RING( dwords );

    ret = ( uint8_t* )&__head[__count];

    __count += dwords;
    ADVANCE_RING();

    *y += *hpass;
    *h -= *hpass;

    return ret;
a176 67
/* Copies a single pass worth of data for a hostdata blit set up by
 * RADEONHostDataBlit().
 */
void
RADEONHostDataBlitCopyPass(
    ScrnInfoPtr pScrn,
    unsigned int cpp,
    uint8_t *dst,
    uint8_t *src,
    unsigned int hpass,
    unsigned int dstPitch,
    unsigned int srcPitch
){

#if X_BYTE_ORDER == X_BIG_ENDIAN
    RADEONInfoPtr info = RADEONPTR( pScrn );
#endif

    /* RADEONHostDataBlitCopy can return NULL ! */
    if( (dst==NULL) || (src==NULL)) return;

    if ( dstPitch == srcPitch )
    {
#if X_BYTE_ORDER == X_BIG_ENDIAN
        if (info->ChipFamily >= CHIP_FAMILY_R300) {
	    switch(cpp) {
	    case 1:
		RADEONCopySwap(dst, src, hpass * dstPitch,
			       RADEON_HOST_DATA_SWAP_32BIT);
		return;
	    case 2:
	        RADEONCopySwap(dst, src, hpass * dstPitch,
			       RADEON_HOST_DATA_SWAP_HDW);
		return;
	    }
	}
#endif
	memcpy( dst, src, hpass * dstPitch );
    }
    else
    {
	unsigned int minPitch = min( dstPitch, srcPitch );
	while ( hpass-- )
	{
#if X_BYTE_ORDER == X_BIG_ENDIAN
            if (info->ChipFamily >= CHIP_FAMILY_R300) {
		switch(cpp) {
		case 1:
		    RADEONCopySwap(dst, src, minPitch,
				   RADEON_HOST_DATA_SWAP_32BIT);
		    goto next;
		case 2:
	            RADEONCopySwap(dst, src, minPitch,
				   RADEON_HOST_DATA_SWAP_HDW);
		    goto next;
		}
	    }
#endif
	    memcpy( dst, src, minPitch );
#if X_BYTE_ORDER == X_BIG_ENDIAN
	next:
#endif
	    src += srcPitch;
	    dst += dstPitch;
	}
    }
}
a177 1
#endif
d184 11
a194 11
#ifdef USE_EXA
    if (info->useEXA) {
# ifdef XF86DRI
	if (info->directRenderingEnabled) {
#ifdef XF86DRM_MODE
	    if (info->ChipFamily >= CHIP_FAMILY_CEDAR) {
		if (!EVERGREENDrawInit(pScreen))
		    return FALSE;
	    } else
#endif
	      if (info->ChipFamily >= CHIP_FAMILY_R600) {
d198 1
a198 1
		if (!RADEONDrawInitCP(pScreen))
a200 10
	} else
# endif /* XF86DRI */
	{
	    if (info->ChipFamily >= CHIP_FAMILY_R600)
		return FALSE;
	    else {
		if (!RADEONDrawInitMMIO(pScreen))
		    return FALSE;
	    }
	}
a201 28
#endif /* USE_EXA */
#ifdef USE_XAA
    if (!info->useEXA) {
	XAAInfoRecPtr  a;

	if (info->ChipFamily >= CHIP_FAMILY_R600)
	    return FALSE;

	if (!(a = info->accel_state->accel = XAACreateInfoRec())) {
	    xf86DrvMsg(pScrn->scrnIndex, X_ERROR, "XAACreateInfoRec Error\n");
	    return FALSE;
	}

#ifdef XF86DRI
	if (info->directRenderingEnabled)
	    RADEONAccelInitCP(pScreen, a);
	else
#endif /* XF86DRI */
	    RADEONAccelInitMMIO(pScreen, a);

	RADEONEngineInit(pScrn);

	if (!XAAInit(pScreen, a)) {
	    xf86DrvMsg(pScrn->scrnIndex, X_ERROR, "XAAInit Error\n");
	    return FALSE;
	}
    }
#endif /* USE_XAA */
d205 1
a205 1
void RADEONInit3DEngine(ScrnInfoPtr pScrn)
d207 7
a213 1
    RADEONInfoPtr info = RADEONPTR (pScrn);
d215 1
a215 3
#ifdef XF86DRI
    if (info->directRenderingEnabled) {
	drm_radeon_sarea_t *pSAREAPriv;
d217 6
a222 3
	if (!info->kms_enabled) {
	    pSAREAPriv = DRIGetSAREAPrivate(pScrn->pScreen);
	    pSAREAPriv->ctx_owner = DRIGetContext(pScrn->pScreen);
a223 4
	RADEONInit3DEngineCP(pScrn);
    } else
#endif
	RADEONInit3DEngineMMIO(pScrn);
d225 5
a229 2
    info->accel_state->XInited3D = TRUE;
}
d231 5
a235 32
#ifdef USE_XAA
#ifdef XF86DRI
Bool
RADEONSetupMemXAA_DRI(ScreenPtr pScreen)
{
    ScrnInfoPtr    pScrn = xf86ScreenToScrn(pScreen);
    RADEONInfoPtr  info  = RADEONPTR(pScrn);
    int            cpp = info->CurrentLayout.pixel_bytes;
    int            depthCpp = (info->dri->depthBits - 8) / 4;
    int            width_bytes = pScrn->displayWidth * cpp;
    int            bufferSize;
    int            depthSize;
    int            l;
    int            scanlines;
    int            texsizerequest;
    BoxRec         MemBox;
    FBAreaPtr      fbarea;

    info->dri->frontOffset = 0;
    info->dri->frontPitch = pScrn->displayWidth;
    info->dri->backPitch = pScrn->displayWidth;

    /* make sure we use 16 line alignment for tiling (8 might be enough).
     * Might need that for non-XF86DRI too?
     */
    if (info->allowColorTiling) {
	bufferSize = RADEON_ALIGN((RADEON_ALIGN(pScrn->virtualY, 16)) * width_bytes,
		      RADEON_GPU_PAGE_SIZE);
    } else {
        bufferSize = RADEON_ALIGN(pScrn->virtualY * width_bytes,
		      RADEON_GPU_PAGE_SIZE);
    }
d237 14
a250 35
    /* Due to tiling, the Z buffer pitch must be a multiple of 32 pixels,
     * which is always the case if color tiling is used due to color pitch
     * but not necessarily otherwise, and its height a multiple of 16 lines.
     */
    info->dri->depthPitch = RADEON_ALIGN(pScrn->displayWidth, 32);
    depthSize = RADEON_ALIGN((RADEON_ALIGN(pScrn->virtualY, 16)) * info->dri->depthPitch
		  * depthCpp, RADEON_GPU_PAGE_SIZE);

    xf86DrvMsg(pScrn->scrnIndex, X_INFO,
	       "Using %d MB GART aperture\n", info->dri->gartSize);
    xf86DrvMsg(pScrn->scrnIndex, X_INFO,
	       "Using %d MB for the ring buffer\n", info->dri->ringSize);
    xf86DrvMsg(pScrn->scrnIndex, X_INFO,
	       "Using %d MB for vertex/indirect buffers\n", info->dri->bufSize);
    xf86DrvMsg(pScrn->scrnIndex, X_INFO,
	       "Using %d MB for GART textures\n", info->dri->gartTexSize);

    /* Try for front, back, depth, and three framebuffers worth of
     * pixmap cache.  Should be enough for a fullscreen background
     * image plus some leftovers.
     * If the FBTexPercent option was used, try to achieve that percentage instead,
     * but still have at least one pixmap buffer (get problems with xvideo/render
     * otherwise probably), and never reserve more than 3 offscreen buffers as it's
     * probably useless for XAA.
     */
    if (info->dri->textureSize >= 0) {
	texsizerequest = ((int)info->FbMapSize - 2 * bufferSize - depthSize
			 - 2 * width_bytes - 16384 - info->FbSecureSize)
	/* first divide, then multiply or we'll get an overflow (been there...) */
			 / 100 * info->dri->textureSize;
    }
    else {
	texsizerequest = (int)info->FbMapSize / 2;
    }
    info->dri->textureSize = info->FbMapSize - info->FbSecureSize - 5 * bufferSize - depthSize;
d252 7
a258 11
    /* If that gives us less than the requested memory, let's
     * be greedy and grab some more.  Sorry, I care more about 3D
     * performance than playing nicely, and you'll get around a full
     * framebuffer's worth of pixmap cache anyway.
     */
    if (info->dri->textureSize < texsizerequest) {
        info->dri->textureSize = info->FbMapSize - 4 * bufferSize - depthSize;
    }
    if (info->dri->textureSize < texsizerequest) {
        info->dri->textureSize = info->FbMapSize - 3 * bufferSize - depthSize;
    }
d260 25
a284 8
    /* If there's still no space for textures, try without pixmap cache, but
     * never use the reserved space, the space hw cursor and PCIGART table might
     * use.
     */
    if (info->dri->textureSize < 0) {
	info->dri->textureSize = info->FbMapSize - 2 * bufferSize - depthSize
	                    - 2 * width_bytes - 16384 - info->FbSecureSize;
    }
d286 6
a291 9
    /* Check to see if there is more room available after the 8192nd
     * scanline for textures
     */
    /* FIXME: what's this good for? condition is pretty much impossible to meet */
    if ((int)info->FbMapSize - 8192*width_bytes - bufferSize - depthSize
	> info->dri->textureSize) {
	info->dri->textureSize =
		info->FbMapSize - 8192*width_bytes - bufferSize - depthSize;
    }
d293 39
a331 4
    /* If backbuffer is disabled, don't allocate memory for it */
    if (info->dri->noBackBuffer) {
	info->dri->textureSize += bufferSize;
    }
d333 442
a774 26
    /* RADEON_BUFFER_ALIGN is not sufficient for backbuffer!
       At least for pageflip + color tiling, need to make sure it's 16 scanlines aligned,
       otherwise the copy-from-front-to-back will fail (width_bytes * 16 will also guarantee
       it's still 4kb aligned for tiled case). Need to round up offset (might get into cursor
       area otherwise).
       This might cause some space at the end of the video memory to be unused, since it
       can't be used (?) due to that log_tex_granularity thing???
       Could use different copyscreentoscreen function for the pageflip copies
       (which would use different src and dst offsets) to avoid this. */   
    if (info->allowColorTiling && !info->dri->noBackBuffer) {
	info->dri->textureSize = info->FbMapSize - ((info->FbMapSize - info->dri->textureSize +
			  width_bytes * 16 - 1) / (width_bytes * 16)) * (width_bytes * 16);
    }
    if (info->dri->textureSize > 0) {
	l = RADEONMinBits((info->dri->textureSize-1) / RADEON_NR_TEX_REGIONS);
	if (l < RADEON_LOG_TEX_GRANULARITY)
	    l = RADEON_LOG_TEX_GRANULARITY;
	/* Round the texture size up to the nearest whole number of
	 * texture regions.  Again, be greedy about this, don't
	 * round down.
	 */
	info->dri->log2TexGran = l;
	info->dri->textureSize = (info->dri->textureSize >> l) << l;
    } else {
	info->dri->textureSize = 0;
    }
d776 28
a803 7
    /* Set a minimum usable local texture heap size.  This will fit
     * two 256x256x32bpp textures.
     */
    if (info->dri->textureSize < 512 * 1024) {
	info->dri->textureOffset = 0;
	info->dri->textureSize = 0;
    }
d805 24
a828 9
    if (info->allowColorTiling && !info->dri->noBackBuffer) {
	info->dri->textureOffset = ((info->FbMapSize - info->dri->textureSize) /
				    (width_bytes * 16)) * (width_bytes * 16);
    }
    else {
	/* Reserve space for textures */
	info->dri->textureOffset = RADEON_ALIGN(info->FbMapSize - info->dri->textureSize,
				     RADEON_GPU_PAGE_SIZE);
    }
a829 13
    /* Reserve space for the shared depth
     * buffer.
     */
    info->dri->depthOffset = RADEON_ALIGN(info->dri->textureOffset - depthSize,
			       RADEON_GPU_PAGE_SIZE);

    /* Reserve space for the shared back buffer */
    if (info->dri->noBackBuffer) {
       info->dri->backOffset = info->dri->depthOffset;
    } else {
       info->dri->backOffset = RADEON_ALIGN(info->dri->depthOffset - bufferSize,
				 RADEON_GPU_PAGE_SIZE);
    }
d831 5
a835 2
    info->dri->backY = info->dri->backOffset / width_bytes;
    info->dri->backX = (info->dri->backOffset - (info->dri->backY * width_bytes)) / cpp;
d837 19
a855 17
    scanlines = (info->FbMapSize-info->FbSecureSize) / width_bytes;
    if (scanlines > 8191)
	scanlines = 8191;

    MemBox.x1 = 0;
    MemBox.y1 = 0;
    MemBox.x2 = pScrn->displayWidth;
    MemBox.y2 = scanlines;

    if (!xf86InitFBManager(pScreen, &MemBox)) {
        xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
		   "Memory manager initialization to "
		   "(%d,%d) (%d,%d) failed\n",
		   MemBox.x1, MemBox.y1, MemBox.x2, MemBox.y2);
	return FALSE;
    } else {
	int  width, height;
d857 8
a864 16
	xf86DrvMsg(pScrn->scrnIndex, X_INFO,
		   "Memory manager initialized to (%d,%d) (%d,%d)\n",
		   MemBox.x1, MemBox.y1, MemBox.x2, MemBox.y2);
	/* why oh why can't we just request modes which are guaranteed to be 16 lines
	   aligned... sigh */
	if ((fbarea = xf86AllocateOffscreenArea(pScreen,
						pScrn->displayWidth,
						info->allowColorTiling ? 
						(RADEON_ALIGN(pScrn->virtualY, 16))
						- pScrn->virtualY + 2 : 2,
						0, NULL, NULL,
						NULL))) {
	    xf86DrvMsg(pScrn->scrnIndex, X_INFO,
		       "Reserved area from (%d,%d) to (%d,%d)\n",
		       fbarea->box.x1, fbarea->box.y1,
		       fbarea->box.x2, fbarea->box.y2);
d866 4
a869 1
	    xf86DrvMsg(pScrn->scrnIndex, X_ERROR, "Unable to reserve area\n");
d871 4
d876 13
a888 1
	RADEONDRIAllocatePCIGARTTable(pScreen);
d890 24
a913 5
	if (xf86QueryLargestOffscreenArea(pScreen, &width,
					  &height, 0, 0, 0)) {
	    xf86DrvMsg(pScrn->scrnIndex, X_INFO,
		       "Largest offscreen area available: %d x %d\n",
		       width, height);
d915 9
a923 15
	    /* Lines in offscreen area needed for depth buffer and
	     * textures
	     */
	    info->dri->depthTexLines = (scanlines
					- info->dri->depthOffset / width_bytes);
	    info->dri->backLines	    = (scanlines
					       - info->dri->backOffset / width_bytes
					       - info->dri->depthTexLines);
	    info->dri->backArea	    = NULL;
	} else {
	    xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
		       "Unable to determine largest offscreen area "
		       "available\n");
	    return FALSE;
	}
d926 1
a926 17
    xf86DrvMsg(pScrn->scrnIndex, X_INFO,
	       "Will use front buffer at offset 0x%x\n",
	       info->dri->frontOffset);

    xf86DrvMsg(pScrn->scrnIndex, X_INFO,
	       "Will use back buffer at offset 0x%x\n",
	       info->dri->backOffset);
    xf86DrvMsg(pScrn->scrnIndex, X_INFO,
	       "Will use depth buffer at offset 0x%x\n",
	       info->dri->depthOffset);
    if (info->cardType==CARD_PCIE)
    	xf86DrvMsg(pScrn->scrnIndex, X_INFO,
	           "Will use %d kb for PCI GART table at offset 0x%x\n",
		   info->dri->pciGartSize/1024, (unsigned)info->dri->pciGartOffset);
    xf86DrvMsg(pScrn->scrnIndex, X_INFO,
	       "Will use %d kb for textures at offset 0x%x\n",
	       info->dri->textureSize/1024, info->dri->textureOffset);
d928 15
a942 2
    info->dri->frontPitchOffset = (((info->dri->frontPitch * cpp / 64) << 22) |
				   ((info->dri->frontOffset + info->fbLocation) >> 10));
d944 2
a945 2
    info->dri->backPitchOffset = (((info->dri->backPitch * cpp / 64) << 22) |
				  ((info->dri->backOffset + info->fbLocation) >> 10));
d947 2
a948 5
    info->dri->depthPitchOffset = (((info->dri->depthPitch * depthCpp / 64) << 22) |
				   ((info->dri->depthOffset + info->fbLocation) >> 10));
    return TRUE;
}
#endif /* XF86DRI */
d950 5
a954 7
Bool
RADEONSetupMemXAA(ScreenPtr pScreen)
{
    ScrnInfoPtr    pScrn = xf86ScreenToScrn(pScreen);
    RADEONInfoPtr  info  = RADEONPTR(pScrn);
    BoxRec         MemBox;
    int            y2;
d956 1
a956 1
    int width_bytes = pScrn->displayWidth * info->CurrentLayout.pixel_bytes;
d958 15
a972 7
    MemBox.x1 = 0;
    MemBox.y1 = 0;
    MemBox.x2 = pScrn->displayWidth;
    y2 = info->FbMapSize / width_bytes;
    if (y2 >= 32768)
	y2 = 32767; /* because MemBox.y2 is signed short */
    MemBox.y2 = y2;
d974 9
a982 16
    /* The acceleration engine uses 14 bit
     * signed coordinates, so we can't have any
     * drawable caches beyond this region.
     */
    if (MemBox.y2 > 8191)
	MemBox.y2 = 8191;

    if (!xf86InitFBManager(pScreen, &MemBox)) {
	xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
		   "Memory manager initialization to "
		   "(%d,%d) (%d,%d) failed\n",
		   MemBox.x1, MemBox.y1, MemBox.x2, MemBox.y2);
	return FALSE;
    } else {
	int       width, height;
	FBAreaPtr fbarea;
d984 4
a987 25
	xf86DrvMsg(pScrn->scrnIndex, X_INFO,
		   "Memory manager initialized to (%d,%d) (%d,%d)\n",
		   MemBox.x1, MemBox.y1, MemBox.x2, MemBox.y2);
	if ((fbarea = xf86AllocateOffscreenArea(pScreen,
						pScrn->displayWidth,
						info->allowColorTiling ? 
						(RADEON_ALIGN(pScrn->virtualY, 16))
						- pScrn->virtualY + 2 : 2,
						0, NULL, NULL,
						NULL))) {
	    xf86DrvMsg(pScrn->scrnIndex, X_INFO,
		       "Reserved area from (%d,%d) to (%d,%d)\n",
		       fbarea->box.x1, fbarea->box.y1,
		       fbarea->box.x2, fbarea->box.y2);
	} else {
	    xf86DrvMsg(pScrn->scrnIndex, X_ERROR, "Unable to reserve area\n");
	}
	if (xf86QueryLargestOffscreenArea(pScreen, &width, &height,
					      0, 0, 0)) {
	    xf86DrvMsg(pScrn->scrnIndex, X_INFO,
		       "Largest offscreen area available: %d x %d\n",
		       width, height);
	}
	return TRUE;
    }    
a988 1
#endif /* USE_XAA */
@


1.6
log
@Re-update xf86-video-ati to 6.14.3.

Because of ati.c revision 1.5, it will not be selected by
autoconfiguration code, so people who want to run this version of the
driver on their radeon cards need an explicit "Device" section in
xorg.conf.
@
text
@d558 1
a558 1
    ScrnInfoPtr pScrn = xf86Screens[pPix->drawable.pScreen->myNum];
d985 1
a985 1
		asm volatile("stwbrx %0,0,%1" : : "r" (*s), "r" (d));
d987 1
a987 2
	        *d = ((*s >> 24) & 0xff) | ((*s >> 8) & 0xff00)
			| ((*s & 0xff00) << 8) | ((*s & 0xff) << 24);
d1068 1
a1068 1
    ScrnInfoPtr    pScrn = xf86Screens[pScreen->myNum];
d1153 1
a1153 1
RADEONSetupMemXAA_DRI(int scrnIndex, ScreenPtr pScreen)
d1155 1
a1155 1
    ScrnInfoPtr    pScrn = xf86Screens[pScreen->myNum];
d1327 1
a1327 1
        xf86DrvMsg(scrnIndex, X_ERROR,
d1335 1
a1335 1
	xf86DrvMsg(scrnIndex, X_INFO,
d1347 1
a1347 1
	    xf86DrvMsg(scrnIndex, X_INFO,
d1352 1
a1352 1
	    xf86DrvMsg(scrnIndex, X_ERROR, "Unable to reserve area\n");
d1359 1
a1359 1
	    xf86DrvMsg(scrnIndex, X_INFO,
d1373 1
a1373 1
	    xf86DrvMsg(scrnIndex, X_ERROR,
d1380 1
a1380 1
    xf86DrvMsg(scrnIndex, X_INFO,
d1384 1
a1384 1
    xf86DrvMsg(scrnIndex, X_INFO,
d1387 1
a1387 1
    xf86DrvMsg(scrnIndex, X_INFO,
d1391 1
a1391 1
    	xf86DrvMsg(scrnIndex, X_INFO,
d1394 1
a1394 1
    xf86DrvMsg(scrnIndex, X_INFO,
d1411 1
a1411 1
RADEONSetupMemXAA(int scrnIndex, ScreenPtr pScreen)
d1413 1
a1413 1
    ScrnInfoPtr    pScrn = xf86Screens[pScreen->myNum];
d1436 1
a1436 1
	xf86DrvMsg(scrnIndex, X_ERROR,
d1445 1
a1445 1
	xf86DrvMsg(scrnIndex, X_INFO,
d1455 1
a1455 1
	    xf86DrvMsg(scrnIndex, X_INFO,
d1460 1
a1460 1
	    xf86DrvMsg(scrnIndex, X_ERROR, "Unable to reserve area\n");
d1464 1
a1464 1
	    xf86DrvMsg(scrnIndex, X_INFO,
@


1.5
log
@Revert the update to xf86-video-ati 6.14.3. Requested by espie@@
who experiemnts regressions with this driver.
@
text
@d78 1
d91 2
a331 4
    OUTREG(RADEON_HOST_PATH_CNTL, host_path_cntl | RADEON_HDP_SOFT_RESET);
    INREG(RADEON_HOST_PATH_CNTL);
    OUTREG(RADEON_HOST_PATH_CNTL, host_path_cntl);

d375 3
d424 18
a456 1
	drm_radeon_getparam_t np;
d459 1
a459 6
	memset(&np, 0, sizeof(np));
	np.param = RADEON_PARAM_NUM_GB_PIPES;
	np.value = &num_pipes;

	if (drmCommandWriteRead(info->dri->drmFD, DRM_RADEON_GETPARAM, &np,
				sizeof(np)) < 0) {
d470 26
a495 24
    if ((info->ChipFamily == CHIP_FAMILY_RV410) ||
	(info->ChipFamily == CHIP_FAMILY_R420)  ||
	(info->ChipFamily == CHIP_FAMILY_RS600) ||
	(info->ChipFamily == CHIP_FAMILY_RS690) ||
	(info->ChipFamily == CHIP_FAMILY_RS740) ||
	(info->ChipFamily == CHIP_FAMILY_RS400) ||
	(info->ChipFamily == CHIP_FAMILY_RS480) ||
	IS_R500_3D) {
	if (info->accel_state->num_gb_pipes == 0) {
	    uint32_t gb_pipe_sel = INREG(R400_GB_PIPE_SELECT);

	    info->accel_state->num_gb_pipes = ((gb_pipe_sel >> 12) & 0x3) + 1;
	    if (IS_R500_3D)
		OUTPLL(pScrn, R500_DYN_SCLK_PWMEM_PIPE, (1 | ((gb_pipe_sel >> 8) & 0xf) << 4));
	}
    } else {
	if (info->accel_state->num_gb_pipes == 0) {
	    if ((info->ChipFamily == CHIP_FAMILY_R300) ||
		(info->ChipFamily == CHIP_FAMILY_R350)) {
		/* R3xx chips */
		info->accel_state->num_gb_pipes = 2;
	    } else {
		/* RV3xx chips */
		info->accel_state->num_gb_pipes = 1;
a497 1
    }
d499 21
a519 23
    if (IS_R300_3D || IS_R500_3D)
	xf86DrvMsg(pScrn->scrnIndex, X_INFO,
		   "num quad-pipes is %d\n", info->accel_state->num_gb_pipes);

    if (IS_R300_3D || IS_R500_3D) {
	uint32_t gb_tile_config = (R300_ENABLE_TILING | R300_TILE_SIZE_16 | R300_SUBPIXEL_1_16);

	switch(info->accel_state->num_gb_pipes) {
	case 2: gb_tile_config |= R300_PIPE_COUNT_R300; break;
	case 3: gb_tile_config |= R300_PIPE_COUNT_R420_3P; break;
	case 4: gb_tile_config |= R300_PIPE_COUNT_R420; break;
	default:
	case 1: gb_tile_config |= R300_PIPE_COUNT_RV350; break;
	}

	OUTREG(R300_GB_TILE_CONFIG, gb_tile_config);
	OUTREG(RADEON_WAIT_UNTIL, RADEON_WAIT_2D_IDLECLEAN | RADEON_WAIT_3D_IDLECLEAN);
	OUTREG(R300_DST_PIPE_CONFIG, INREG(R300_DST_PIPE_CONFIG) | R300_PIPE_AUTO_CONFIG);
	OUTREG(R300_RB2D_DSTCACHE_MODE, (INREG(R300_RB2D_DSTCACHE_MODE) |
					 R300_DC_AUTOFLUSH_ENABLE |
					 R300_DC_DC_DISABLE_IGNORE_PE));
    } else
	OUTREG(RADEON_RB3D_CNTL, 0);
d521 12
a532 1
    RADEONEngineReset(pScrn);
d556 30
d670 2
d748 1
d782 1
a782 1
	info->cp->indirectStart  = buffer->used = (buffer->used + 7) & ~7;
d798 1
d881 1
a881 1
	*bufPitch = 2 * ((w + 1) & ~1);
d885 1
a885 1
	*bufPitch = (w + 3) & ~3;
d994 1
a994 1
	    memmove(dst, src, size);
d1076 7
a1082 1
	    if (info->ChipFamily >= CHIP_FAMILY_R600) {
d1139 4
a1142 2
	pSAREAPriv = DRIGetSAREAPrivate(pScrn->pScreen);
	pSAREAPriv->ctx_owner = DRIGetContext(pScrn->pScreen);
d1177 2
a1178 2
	bufferSize = (((pScrn->virtualY + 15) & ~15) * width_bytes
		      + RADEON_BUFFER_ALIGN) & ~RADEON_BUFFER_ALIGN;
d1180 2
a1181 2
        bufferSize = (pScrn->virtualY * width_bytes
		      + RADEON_BUFFER_ALIGN) & ~RADEON_BUFFER_ALIGN;
d1188 3
a1190 3
    info->dri->depthPitch = (pScrn->displayWidth + 31) & ~31;
    depthSize = ((((pScrn->virtualY + 15) & ~15) * info->dri->depthPitch
		  * depthCpp + RADEON_BUFFER_ALIGN) & ~RADEON_BUFFER_ALIGN);
d1297 2
a1298 3
	info->dri->textureOffset = ((info->FbMapSize - info->dri->textureSize +
				     RADEON_BUFFER_ALIGN) &
				    ~(uint32_t)RADEON_BUFFER_ALIGN);
d1304 2
a1305 3
    info->dri->depthOffset = ((info->dri->textureOffset - depthSize +
			       RADEON_BUFFER_ALIGN) &
			      ~(uint32_t)RADEON_BUFFER_ALIGN);
d1311 2
a1312 3
       info->dri->backOffset = ((info->dri->depthOffset - bufferSize +
				 RADEON_BUFFER_ALIGN) &
				~(uint32_t)RADEON_BUFFER_ALIGN);
d1344 1
a1344 1
						((pScrn->virtualY + 15) & ~15)
d1452 1
a1452 1
						((pScrn->virtualY + 15) & ~15)
@


1.4
log
@Update to xf86-video-ati 6.14.3. Tested by many.
@
text
@a77 1
#include <assert.h>
a89 2
#include "ati_pciids_gen.h"

d329 4
a375 3
    if (info->cs)
      return;

a421 18
static int RADEONDRMGetNumPipes(ScrnInfoPtr pScrn, int *num_pipes)
{
    RADEONInfoPtr info = RADEONPTR(pScrn);
    if (info->dri->pKernelDRMVersion->version_major < 2) {
        drm_radeon_getparam_t np;

        memset(&np, 0, sizeof(np));
        np.param = RADEON_PARAM_NUM_GB_PIPES;
        np.value = num_pipes;
        return drmCommandWriteRead(info->dri->drmFD, DRM_RADEON_GETPARAM, &np, sizeof(np));
    } else {
        struct drm_radeon_info np2;
        np2.value = (unsigned long)num_pipes;
        np2.request = RADEON_INFO_NUM_GB_PIPES;
        return drmCommandWriteRead(info->dri->drmFD, DRM_RADEON_INFO, &np2, sizeof(np2));
    }
}

d437 1
d440 6
a445 1
	if(RADEONDRMGetNumPipes(pScrn, &num_pipes) < 0) {
d456 24
a479 26
    if (!info->cs) {
	if ((info->ChipFamily == CHIP_FAMILY_RV410) ||
	    (info->ChipFamily == CHIP_FAMILY_R420)  ||
	    (info->ChipFamily == CHIP_FAMILY_RS600) ||
	    (info->ChipFamily == CHIP_FAMILY_RS690) ||
	    (info->ChipFamily == CHIP_FAMILY_RS740) ||
	    (info->ChipFamily == CHIP_FAMILY_RS400) ||
	    (info->ChipFamily == CHIP_FAMILY_RS480) ||
	    IS_R500_3D) {
	    if (info->accel_state->num_gb_pipes == 0) {
		uint32_t gb_pipe_sel = INREG(R400_GB_PIPE_SELECT);

		info->accel_state->num_gb_pipes = ((gb_pipe_sel >> 12) & 0x3) + 1;
		if (IS_R500_3D)
		    OUTPLL(pScrn, R500_DYN_SCLK_PWMEM_PIPE, (1 | ((gb_pipe_sel >> 8) & 0xf) << 4));
	    }
	} else {
	    if (info->accel_state->num_gb_pipes == 0) {
		if ((info->ChipFamily == CHIP_FAMILY_R300) ||
		    (info->ChipFamily == CHIP_FAMILY_R350)) {
		    /* R3xx chips */
		    info->accel_state->num_gb_pipes = 2;
		} else {
		    /* RV3xx chips */
		    info->accel_state->num_gb_pipes = 1;
		}
d482 1
d484 23
a506 21
	/* SE cards only have 1 quadpipe */
	if ((info->Chipset == PCI_CHIP_RV410_5E4C) ||
	    (info->Chipset == PCI_CHIP_RV410_5E4F) ||
	    (info->Chipset == PCI_CHIP_R300_AD) ||
	    (info->Chipset == PCI_CHIP_R350_AH))
	    info->accel_state->num_gb_pipes = 1;

	if (IS_R300_3D || IS_R500_3D)
	    xf86DrvMsg(pScrn->scrnIndex, X_INFO,
		       "num quad-pipes is %d\n", info->accel_state->num_gb_pipes);

	if (IS_R300_3D || IS_R500_3D) {
	    uint32_t gb_tile_config = (R300_ENABLE_TILING | R300_TILE_SIZE_16);
	    
	    switch(info->accel_state->num_gb_pipes) {
	    case 2: gb_tile_config |= R300_PIPE_COUNT_R300; break;
	    case 3: gb_tile_config |= R300_PIPE_COUNT_R420_3P; break;
	    case 4: gb_tile_config |= R300_PIPE_COUNT_R420; break;
	    default:
	    case 1: gb_tile_config |= R300_PIPE_COUNT_RV350; break;
	    }
d508 1
a508 12
	    OUTREG(R300_GB_TILE_CONFIG, gb_tile_config);
	    OUTREG(RADEON_WAIT_UNTIL, RADEON_WAIT_2D_IDLECLEAN | RADEON_WAIT_3D_IDLECLEAN);
	    if (info->ChipFamily >= CHIP_FAMILY_R420)
		OUTREG(R300_DST_PIPE_CONFIG, INREG(R300_DST_PIPE_CONFIG) | R300_PIPE_AUTO_CONFIG);
	    OUTREG(R300_RB2D_DSTCACHE_MODE, (INREG(R300_RB2D_DSTCACHE_MODE) |
					     R300_DC_AUTOFLUSH_ENABLE |
					     R300_DC_DC_DISABLE_IGNORE_PE));
	} else
	    OUTREG(RADEON_RB3D_CNTL, 0);
	
	RADEONEngineReset(pScrn);
    }
a531 30
uint32_t radeonGetPixmapOffset(PixmapPtr pPix)
{
    ScrnInfoPtr pScrn = xf86Screens[pPix->drawable.pScreen->myNum];
    RADEONInfoPtr info = RADEONPTR(pScrn);
    uint32_t offset = 0;
    if (info->cs)
	return 0;
#ifdef USE_EXA
    if (info->useEXA) {
	offset = exaGetPixmapOffset(pPix);
    } else
#endif
    {
	offset = pPix->devPrivate.ptr - info->FB;
    }
    offset += info->fbLocation + pScrn->fbOffset;
    return offset;
}

int radeon_cs_space_remaining(ScrnInfoPtr pScrn)
{
    RADEONInfoPtr info = RADEONPTR(pScrn);

#ifdef XF86DRM_MODE
    if (info->cs)
	return (info->cs->ndw - info->cs->cdw);
    else
#endif
        return (info->cp->indirectBuffer->total - info->cp->indirectBuffer->used) / (int)sizeof(uint32_t);
}
a615 2
#define RADEON_IB_RESERVE (16 * sizeof(uint32_t))

a691 1
    assert(!info->cs);
d725 1
a725 1
	info->cp->indirectStart  = buffer->used = RADEON_ALIGN(buffer->used, 8);
a740 1
    assert(!info->cs);
d823 1
a823 1
	*bufPitch = 2 * RADEON_ALIGN(w, 2);
d827 1
a827 1
	*bufPitch = RADEON_ALIGN(w, 4);
d936 1
a936 1
	memcpy(dst, src, size);
d1018 1
a1018 7
#ifdef XF86DRM_MODE
	    if (info->ChipFamily >= CHIP_FAMILY_CEDAR) {
		if (!EVERGREENDrawInit(pScreen))
		    return FALSE;
	    } else
#endif
	      if (info->ChipFamily >= CHIP_FAMILY_R600) {
d1075 2
a1076 4
	if (!info->kms_enabled) {
	    pSAREAPriv = DRIGetSAREAPrivate(pScrn->pScreen);
	    pSAREAPriv->ctx_owner = DRIGetContext(pScrn->pScreen);
	}
d1111 2
a1112 2
	bufferSize = RADEON_ALIGN((RADEON_ALIGN(pScrn->virtualY, 16)) * width_bytes,
		      RADEON_GPU_PAGE_SIZE);
d1114 2
a1115 2
        bufferSize = RADEON_ALIGN(pScrn->virtualY * width_bytes,
		      RADEON_GPU_PAGE_SIZE);
d1122 3
a1124 3
    info->dri->depthPitch = RADEON_ALIGN(pScrn->displayWidth, 32);
    depthSize = RADEON_ALIGN((RADEON_ALIGN(pScrn->virtualY, 16)) * info->dri->depthPitch
		  * depthCpp, RADEON_GPU_PAGE_SIZE);
d1231 3
a1233 2
	info->dri->textureOffset = RADEON_ALIGN(info->FbMapSize - info->dri->textureSize,
				     RADEON_GPU_PAGE_SIZE);
d1239 3
a1241 2
    info->dri->depthOffset = RADEON_ALIGN(info->dri->textureOffset - depthSize,
			       RADEON_GPU_PAGE_SIZE);
d1247 3
a1249 2
       info->dri->backOffset = RADEON_ALIGN(info->dri->depthOffset - bufferSize,
				 RADEON_GPU_PAGE_SIZE);
d1281 1
a1281 1
						(RADEON_ALIGN(pScrn->virtualY, 16))
d1389 1
a1389 1
						(RADEON_ALIGN(pScrn->virtualY, 16))
@


1.3
log
@update do xf86-video-ati 6.12.2

This has been in snapshots for weeks. ok oga@@, todd@@.
@
text
@d78 1
d91 2
a331 4
    OUTREG(RADEON_HOST_PATH_CNTL, host_path_cntl | RADEON_HDP_SOFT_RESET);
    INREG(RADEON_HOST_PATH_CNTL);
    OUTREG(RADEON_HOST_PATH_CNTL, host_path_cntl);

d375 3
d424 18
a456 1
	drm_radeon_getparam_t np;
d459 1
a459 6
	memset(&np, 0, sizeof(np));
	np.param = RADEON_PARAM_NUM_GB_PIPES;
	np.value = &num_pipes;

	if (drmCommandWriteRead(info->dri->drmFD, DRM_RADEON_GETPARAM, &np,
				sizeof(np)) < 0) {
d470 26
a495 24
    if ((info->ChipFamily == CHIP_FAMILY_RV410) ||
	(info->ChipFamily == CHIP_FAMILY_R420)  ||
	(info->ChipFamily == CHIP_FAMILY_RS600) ||
	(info->ChipFamily == CHIP_FAMILY_RS690) ||
	(info->ChipFamily == CHIP_FAMILY_RS740) ||
	(info->ChipFamily == CHIP_FAMILY_RS400) ||
	(info->ChipFamily == CHIP_FAMILY_RS480) ||
	IS_R500_3D) {
	if (info->accel_state->num_gb_pipes == 0) {
	    uint32_t gb_pipe_sel = INREG(R400_GB_PIPE_SELECT);

	    info->accel_state->num_gb_pipes = ((gb_pipe_sel >> 12) & 0x3) + 1;
	    if (IS_R500_3D)
		OUTPLL(pScrn, R500_DYN_SCLK_PWMEM_PIPE, (1 | ((gb_pipe_sel >> 8) & 0xf) << 4));
	}
    } else {
	if (info->accel_state->num_gb_pipes == 0) {
	    if ((info->ChipFamily == CHIP_FAMILY_R300) ||
		(info->ChipFamily == CHIP_FAMILY_R350)) {
		/* R3xx chips */
		info->accel_state->num_gb_pipes = 2;
	    } else {
		/* RV3xx chips */
		info->accel_state->num_gb_pipes = 1;
a497 1
    }
d499 21
a519 23
    if (IS_R300_3D || IS_R500_3D)
	xf86DrvMsg(pScrn->scrnIndex, X_INFO,
		   "num quad-pipes is %d\n", info->accel_state->num_gb_pipes);

    if (IS_R300_3D || IS_R500_3D) {
	uint32_t gb_tile_config = (R300_ENABLE_TILING | R300_TILE_SIZE_16 | R300_SUBPIXEL_1_16);

	switch(info->accel_state->num_gb_pipes) {
	case 2: gb_tile_config |= R300_PIPE_COUNT_R300; break;
	case 3: gb_tile_config |= R300_PIPE_COUNT_R420_3P; break;
	case 4: gb_tile_config |= R300_PIPE_COUNT_R420; break;
	default:
	case 1: gb_tile_config |= R300_PIPE_COUNT_RV350; break;
	}

	OUTREG(R300_GB_TILE_CONFIG, gb_tile_config);
	OUTREG(RADEON_WAIT_UNTIL, RADEON_WAIT_2D_IDLECLEAN | RADEON_WAIT_3D_IDLECLEAN);
	OUTREG(R300_DST_PIPE_CONFIG, INREG(R300_DST_PIPE_CONFIG) | R300_PIPE_AUTO_CONFIG);
	OUTREG(R300_RB2D_DSTCACHE_MODE, (INREG(R300_RB2D_DSTCACHE_MODE) |
					 R300_DC_AUTOFLUSH_ENABLE |
					 R300_DC_DC_DISABLE_IGNORE_PE));
    } else
	OUTREG(RADEON_RB3D_CNTL, 0);
d521 12
a532 1
    RADEONEngineReset(pScrn);
d556 30
d670 2
d748 1
d782 1
a782 1
	info->cp->indirectStart  = buffer->used = (buffer->used + 7) & ~7;
d798 1
d881 1
a881 1
	*bufPitch = 2 * ((w + 1) & ~1);
d885 1
a885 1
	*bufPitch = (w + 3) & ~3;
d994 1
a994 1
	    memmove(dst, src, size);
d1076 7
a1082 1
	    if (info->ChipFamily >= CHIP_FAMILY_R600) {
d1139 4
a1142 2
	pSAREAPriv = DRIGetSAREAPrivate(pScrn->pScreen);
	pSAREAPriv->ctx_owner = DRIGetContext(pScrn->pScreen);
d1177 2
a1178 2
	bufferSize = (((pScrn->virtualY + 15) & ~15) * width_bytes
		      + RADEON_BUFFER_ALIGN) & ~RADEON_BUFFER_ALIGN;
d1180 2
a1181 2
        bufferSize = (pScrn->virtualY * width_bytes
		      + RADEON_BUFFER_ALIGN) & ~RADEON_BUFFER_ALIGN;
d1188 3
a1190 3
    info->dri->depthPitch = (pScrn->displayWidth + 31) & ~31;
    depthSize = ((((pScrn->virtualY + 15) & ~15) * info->dri->depthPitch
		  * depthCpp + RADEON_BUFFER_ALIGN) & ~RADEON_BUFFER_ALIGN);
d1297 2
a1298 3
	info->dri->textureOffset = ((info->FbMapSize - info->dri->textureSize +
				     RADEON_BUFFER_ALIGN) &
				    ~(uint32_t)RADEON_BUFFER_ALIGN);
d1304 2
a1305 3
    info->dri->depthOffset = ((info->dri->textureOffset - depthSize +
			       RADEON_BUFFER_ALIGN) &
			      ~(uint32_t)RADEON_BUFFER_ALIGN);
d1311 2
a1312 3
       info->dri->backOffset = ((info->dri->depthOffset - bufferSize +
				 RADEON_BUFFER_ALIGN) &
				~(uint32_t)RADEON_BUFFER_ALIGN);
d1344 1
a1344 1
						((pScrn->virtualY + 15) & ~15)
d1452 1
a1452 1
						((pScrn->virtualY + 15) & ~15)
@


1.2
log
@Long awaited update of xf86-video-ati to 6.9.0.

the rage128 and mach64 drivers were split out of this driver just after
the 6.8.0 release, these drivers will be commited separately.

MergedFb mode is gone, so please use xrandr if you used to use it.

ok matthieu@@.
@
text
@d81 1
d87 1
a87 3
#include "radeon_dri.h"
#include "radeon_common.h"
#include "radeon_sarea.h"
d96 1
d133 1
a133 1
	    info->fifo_slots =
d135 1
a135 1
	    if (info->fifo_slots >= entries) return;
d154 31
d341 29
d387 2
a388 2
    OUTREG(RADEON_DST_PITCH_OFFSET, info->dst_pitch_offset);
    OUTREG(RADEON_SRC_PITCH_OFFSET, info->dst_pitch_offset);
d406 1
a406 1
    OUTREG(RADEON_DP_GUI_MASTER_CNTL, (info->dp_gui_master_cntl
d419 1
a419 1
    info->XInited3D = FALSE;
d427 2
d437 1
a437 1
	drmRadeonGetParam np;
d444 1
a444 1
	if (drmCommandWriteRead(info->drmFD, DRM_RADEON_GETPARAM, &np,
d449 1
a449 1
	    info->num_gb_pipes = 0;
d451 1
a451 1
	    info->num_gb_pipes = num_pipes;
d464 1
a464 1
	if (info->num_gb_pipes == 0) {
d467 1
a467 1
	    info->num_gb_pipes = ((gb_pipe_sel >> 12) & 0x3) + 1;
d472 1
a472 1
	if (info->num_gb_pipes == 0) {
d476 1
a476 1
		info->num_gb_pipes = 2;
d479 1
a479 1
		info->num_gb_pipes = 1;
d486 1
a486 1
		   "num pipes is %d\n", info->num_gb_pipes);
d491 1
a491 1
	switch(info->num_gb_pipes) {
d511 5
a515 5
    case 8:  info->datatype = 2; break;
    case 15: info->datatype = 3; break;
    case 16: info->datatype = 4; break;
    case 24: info->datatype = 5; break;
    case 32: info->datatype = 6; break;
a522 5
    info->pitch = ((info->CurrentLayout.displayWidth / 8) *
		   (info->CurrentLayout.pixel_bytes == 3 ? 3 : 1));

    xf86DrvMsgVerb(pScrn->scrnIndex, X_INFO, RADEON_LOGLEVEL_DEBUG,
		   "Pitch for acceleration = %d\n", info->pitch);
d524 2
a525 2
    info->dp_gui_master_cntl =
	((info->datatype << RADEON_GMC_DST_DATATYPE_SHIFT)
a528 17
#ifdef XF86DRI
    info->sc_left         = 0x00000000;
    info->sc_right        = RADEON_DEFAULT_SC_RIGHT_MAX;
    info->sc_top          = 0x00000000;
    info->sc_bottom       = RADEON_DEFAULT_SC_BOTTOM_MAX;

    info->re_top_left     = 0x00000000;
    if (info->ChipFamily <= CHIP_FAMILY_RV280)
	info->re_width_height = ((0x7ff << RADEON_RE_WIDTH_SHIFT) |
				 (0x7ff << RADEON_RE_HEIGHT_SHIFT));
    else
	info->re_width_height = ((8191 << R300_SCISSOR_X_SHIFT) |
				 (8191 << R300_SCISSOR_Y_SHIFT));

    info->aux_sc_cntl     = 0x00000000;
#endif

d577 1
a577 1
    drmRadeonCPStop  stop;
d583 2
a584 2
    ret = drmCommandWrite(info->drmFD, DRM_RADEON_CP_STOP, &stop,
			  sizeof(drmRadeonCPStop));
d596 2
a597 2
	ret = drmCommandWrite(info->drmFD, DRM_RADEON_CP_STOP, &stop,
			      sizeof(drmRadeonCPStop));
d608 2
a609 2
    if (drmCommandWrite(info->drmFD, DRM_RADEON_CP_STOP,
			&stop, sizeof(drmRadeonCPStop))) {
d651 1
a651 1
	    ret = drmDMA(info->drmFD, &dma);
d659 1
a659 1
	    buf = &info->buffers->list[indx];
d671 6
a676 2
	RADEONEngineReset(pScrn);
	RADEONEngineRestore(pScrn);
d688 3
a690 3
    drmBufPtr          buffer = info->indirectBuffer;
    int                start  = info->indirectStart;
    drmRadeonIndirect  indirect;
d700 12
d717 2
a718 2
    drmCommandWriteRead(info->drmFD, DRM_RADEON_INDIRECT,
			&indirect, sizeof(drmRadeonIndirect));
d721 2
a722 2
	info->indirectBuffer = RADEONCPGetBuffer(pScrn);
	info->indirectStart  = 0;
d725 1
a725 1
	info->indirectStart  = buffer->used = (buffer->used + 7) & ~7;
d728 1
a728 1
		       info->indirectStart);
d737 15
a751 3
    drmBufPtr          buffer = info->indirectBuffer;
    int                start  = info->indirectStart;
    drmRadeonIndirect  indirect;
d753 2
a754 2
    info->indirectBuffer = NULL;
    info->indirectStart  = 0;
d768 2
a769 2
    drmCommandWriteRead(info->drmFD, DRM_RADEON_INDIRECT,
			&indirect, sizeof(drmRadeonIndirect));
a1013 3
    if (info->ChipFamily >= CHIP_FAMILY_R600)
	return FALSE;

d1018 7
a1024 2
	    if (!RADEONDrawInitCP(pScreen))
		return FALSE;
d1028 1
a1028 1
	    if (!RADEONDrawInitMMIO(pScreen))
d1030 4
d1041 4
a1044 1
	if (!(a = info->accel = XAACreateInfoRec())) {
d1073 1
a1073 1
	RADEONSAREAPrivPtr pSAREAPriv;
d1076 1
a1076 1
	pSAREAPriv->ctxOwner = DRIGetContext(pScrn->pScreen);
d1082 1
a1082 1
    info->XInited3D = TRUE;
d1093 1
a1093 1
    int            depthCpp = (info->depthBits - 8) / 4;
d1103 3
a1105 3
    info->frontOffset = 0;
    info->frontPitch = pScrn->displayWidth;
    info->backPitch = pScrn->displayWidth;
d1122 2
a1123 2
    info->depthPitch = (pScrn->displayWidth + 31) & ~31;
    depthSize = ((((pScrn->virtualY + 15) & ~15) * info->depthPitch
a1125 12
    switch (info->CPMode) {
    case RADEON_DEFAULT_CP_PIO_MODE:
	xf86DrvMsg(pScrn->scrnIndex, X_INFO, "CP in PIO mode\n");
	break;
    case RADEON_DEFAULT_CP_BM_MODE:
	xf86DrvMsg(pScrn->scrnIndex, X_INFO, "CP in BM mode\n");
	break;
    default:
        xf86DrvMsg(pScrn->scrnIndex, X_INFO, "CP in UNKNOWN mode\n");
	break;
    }

d1127 1
a1127 1
	       "Using %d MB GART aperture\n", info->gartSize);
d1129 1
a1129 1
	       "Using %d MB for the ring buffer\n", info->ringSize);
d1131 1
a1131 1
	       "Using %d MB for vertex/indirect buffers\n", info->bufSize);
d1133 1
a1133 1
	       "Using %d MB for GART textures\n", info->gartTexSize);
d1143 1
a1143 1
    if (info->textureSize >= 0) {
d1147 1
a1147 1
			 / 100 * info->textureSize;
d1152 1
a1152 1
    info->textureSize = info->FbMapSize - info->FbSecureSize - 5 * bufferSize - depthSize;
d1159 2
a1160 2
    if (info->textureSize < texsizerequest) {
        info->textureSize = info->FbMapSize - 4 * bufferSize - depthSize;
d1162 2
a1163 2
    if (info->textureSize < texsizerequest) {
        info->textureSize = info->FbMapSize - 3 * bufferSize - depthSize;
d1170 2
a1171 2
    if (info->textureSize < 0) {
	info->textureSize = info->FbMapSize - 2 * bufferSize - depthSize
d1180 2
a1181 2
	> info->textureSize) {
	info->textureSize =
d1186 2
a1187 2
    if (info->noBackBuffer) {
	info->textureSize += bufferSize;
d1199 2
a1200 2
    if (info->allowColorTiling && !info->noBackBuffer) {
	info->textureSize = info->FbMapSize - ((info->FbMapSize - info->textureSize +
d1203 2
a1204 2
    if (info->textureSize > 0) {
	l = RADEONMinBits((info->textureSize-1) / RADEON_NR_TEX_REGIONS);
d1211 2
a1212 2
	info->log2TexGran = l;
	info->textureSize = (info->textureSize >> l) << l;
d1214 1
a1214 1
	info->textureSize = 0;
d1220 3
a1222 3
    if (info->textureSize < 512 * 1024) {
	info->textureOffset = 0;
	info->textureSize = 0;
d1225 3
a1227 3
    if (info->allowColorTiling && !info->noBackBuffer) {
	info->textureOffset = ((info->FbMapSize - info->textureSize) /
			       (width_bytes * 16)) * (width_bytes * 16);
d1231 3
a1233 3
	info->textureOffset = ((info->FbMapSize - info->textureSize +
				RADEON_BUFFER_ALIGN) &
			       ~(uint32_t)RADEON_BUFFER_ALIGN);
d1239 3
a1241 3
    info->depthOffset = ((info->textureOffset - depthSize +
			  RADEON_BUFFER_ALIGN) &
			 ~(uint32_t)RADEON_BUFFER_ALIGN);
d1244 2
a1245 2
    if (info->noBackBuffer) {
       info->backOffset = info->depthOffset;
d1247 3
a1249 3
       info->backOffset = ((info->depthOffset - bufferSize +
			    RADEON_BUFFER_ALIGN) &
			   ~(uint32_t)RADEON_BUFFER_ALIGN);
d1252 2
a1253 2
    info->backY = info->backOffset / width_bytes;
    info->backX = (info->backOffset - (info->backY * width_bytes)) / cpp;
d1304 6
a1309 6
	    info->depthTexLines = (scanlines
				   - info->depthOffset / width_bytes);
	    info->backLines	    = (scanlines
				       - info->backOffset / width_bytes
				       - info->depthTexLines);
	    info->backArea	    = NULL;
d1320 1
a1320 1
	       info->frontOffset);
d1324 1
a1324 1
	       info->backOffset);
d1327 1
a1327 1
	       info->depthOffset);
d1331 1
a1331 1
		   info->pciGartSize/1024, (unsigned)info->pciGartOffset);
d1334 1
a1334 1
	       info->textureSize/1024, info->textureOffset);
d1336 2
a1337 2
    info->frontPitchOffset = (((info->frontPitch * cpp / 64) << 22) |
			      ((info->frontOffset + info->fbLocation) >> 10));
d1339 2
a1340 2
    info->backPitchOffset = (((info->backPitch * cpp / 64) << 22) |
			     ((info->backOffset + info->fbLocation) >> 10));
d1342 2
a1343 2
    info->depthPitchOffset = (((info->depthPitch * depthCpp / 64) << 22) |
			      ((info->depthOffset + info->fbLocation) >> 10));
@


1.1
log
@Initial revision
@
text
@a0 1
/* $XFree86: xc/programs/Xserver/hw/xfree86/drivers/ati/radeon_accel.c,v 1.36 2003/11/10 18:41:22 tsi Exp $ */
d137 4
a140 3
	RADEONTRACE(("FIFO timed out: %u entries, stat=0x%08x\n",
		     INREG(RADEON_RBBM_STATUS) & RADEON_RBBM_FIFOCNT_MASK,
		     INREG(RADEON_RBBM_STATUS)));
d161 26
a186 10
    OUTREGP(RADEON_RB3D_DSTCACHE_CTLSTAT,
	    RADEON_RB3D_DC_FLUSH_ALL,
	    ~RADEON_RB3D_DC_FLUSH_ALL);
    for (i = 0; i < RADEON_TIMEOUT; i++) {
	if (!(INREG(RADEON_RB3D_DSTCACHE_CTLSTAT) & RADEON_RB3D_DC_BUSY))
	    break;
    }
    if (i == RADEON_TIMEOUT) {
	RADEONTRACE(("DC flush timeout: %x\n",
		    INREG(RADEON_RB3D_DSTCACHE_CTLSTAT)));
d195 4
a198 4
    CARD32         clock_cntl_index;
    CARD32         mclk_cntl;
    CARD32         rbbm_soft_reset;
    CARD32         host_path_cntl;
d213 1
a213 1
    OUTREG(RADEON_RBBM_SOFT_RESET, (rbbm_soft_reset & (CARD32)
d235 1
a235 1
	CARD32 tmp;
d268 2
a269 2
    if (IS_R300_VARIANT) {
	CARD32 tmp;
d288 1
a288 1
	OUTREG(RADEON_RBBM_SOFT_RESET, (rbbm_soft_reset & (CARD32)
d302 1
a302 1
    if (!IS_R300_VARIANT)
d316 4
a319 3
    RADEONTRACE(("EngineRestore (%d/%d)\n",
		 info->CurrentLayout.pixel_code,
		 info->CurrentLayout.bitsPerPixel));
d340 1
a340 1
    OUTREG(RADEON_SURFACE_CNTL, info->ModeReg.surface_cntl);
d368 4
a371 3
    RADEONTRACE(("EngineInit (%d/%d)\n",
		 info->CurrentLayout.pixel_code,
		 info->CurrentLayout.bitsPerPixel));
d373 72
a444 1
    OUTREG(RADEON_RB3D_CNTL, 0);
d455 5
a459 4
	RADEONTRACE(("Unknown depth/bpp = %d/%d (code = %d)\n",
		     info->CurrentLayout.depth,
		     info->CurrentLayout.bitsPerPixel,
		     info->CurrentLayout.pixel_code));
d464 2
a465 1
    RADEONTRACE(("Pitch for acceleration = %d\n", info->pitch));
d479 6
a484 2
    info->re_width_height = ((0x7ff << RADEON_RE_WIDTH_SHIFT) |
			     (0x7ff << RADEON_RE_HEIGHT_SHIFT));
d710 2
a711 2
RADEONHostDataParams(ScrnInfoPtr pScrn, CARD8 *dst, CARD32 pitch, int cpp,
		     CARD32 *dstPitchOff, int *x, int *y)
d714 1
a714 1
    CARD32 dstOffs = dst - info->FB + info->fbLocation;
d725 1
a725 1
CARD8*
d730 2
a731 2
    CARD32 dstPitchOff,
    CARD32 *bufPitch,
d738 2
a739 2
    CARD32 format, dwords;
    CARD8 *ret;
d812 1
a812 1
    ret = ( CARD8* )&__head[__count];
d823 1
a823 1
void RADEONCopySwap(CARD8 *dst, CARD8 *src, unsigned int size, int swap)
d878 2
a879 2
    CARD8 *dst,
    CARD8 *src,
d946 3
d1008 337
@


1.1.1.1
log
@Importing xf86-video-ati 6.6.3
@
text
@@
