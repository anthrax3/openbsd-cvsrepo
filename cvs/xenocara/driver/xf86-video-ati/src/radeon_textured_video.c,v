head	1.8;
access;
symbols
	OPENBSD_6_1_BASE:1.8
	OPENBSD_6_0:1.8.0.12
	OPENBSD_6_0_BASE:1.8
	OPENBSD_5_9:1.8.0.10
	OPENBSD_5_9_BASE:1.8
	OPENBSD_5_8:1.8.0.8
	OPENBSD_5_8_BASE:1.8
	OPENBSD_5_7:1.8.0.6
	OPENBSD_5_7_BASE:1.8
	OPENBSD_5_6:1.8.0.4
	OPENBSD_5_6_BASE:1.8
	OPENBSD_5_5:1.8.0.2
	OPENBSD_5_5_BASE:1.8
	OPENBSD_5_4:1.7.0.4
	OPENBSD_5_4_BASE:1.7
	OPENBSD_5_3:1.7.0.2
	OPENBSD_5_3_BASE:1.7
	OPENBSD_5_2:1.6.0.2
	OPENBSD_5_2_BASE:1.6
	OPENBSD_5_1_BASE:1.4
	OPENBSD_5_1:1.4.0.2
	OPENBSD_5_0:1.2.0.8
	OPENBSD_5_0_BASE:1.2
	OPENBSD_4_9:1.2.0.4
	OPENBSD_4_9_BASE:1.2
	OPENBSD_4_8:1.2.0.6
	OPENBSD_4_8_BASE:1.2
	OPENBSD_4_7:1.2.0.2
	OPENBSD_4_7_BASE:1.2
	OPENBSD_4_6:1.1.0.6
	OPENBSD_4_6_BASE:1.1
	OPENBSD_4_5:1.1.0.4
	OPENBSD_4_5_BASE:1.1
	OPENBSD_4_4:1.1.0.2
	OPENBSD_4_4_BASE:1.1;
locks; strict;
comment	@ * @;


1.8
date	2013.08.16.17.04.13;	author matthieu;	state Exp;
branches;
next	1.7;

1.7
date	2012.08.08.16.25.22;	author matthieu;	state Exp;
branches;
next	1.6;

1.6
date	2012.06.07.20.55.34;	author matthieu;	state Exp;
branches;
next	1.5;

1.5
date	2012.03.04.16.01.20;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2012.02.06.22.53.13;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2012.01.25.21.33.35;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2009.08.25.18.51.45;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2008.07.12.15.18.34;	author oga;	state Exp;
branches;
next	;


desc
@@


1.8
log
@Update to xf86-video-ati 7.2.0, requested by jsg@@

It fixes an endianess problem with kms and the in tree x86-video-ati
among other things.
It has been tested on various i386/amd64/sparc64/macppc machines
on a range of hardware from r100->northern islands.
@
text
@/*
 * Copyright 2008 Alex Deucher
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice (including the next
 * paragraph) shall be included in all copies or substantial portions of the
 * Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 *
 * Based on radeon_exa_render.c and kdrive ati_video.c by Eric Anholt, et al.
 *
 */

#ifdef HAVE_CONFIG_H
#include "config.h"
#endif

#include <stdlib.h>
#include <string.h>
#include <stdio.h>
#include <math.h>

#include "radeon.h"
#include "radeon_reg.h"
#include "radeon_probe.h"
#include "radeon_video.h"

#include <X11/extensions/Xv.h>
#include "fourcc.h"

extern void
R600DisplayTexturedVideo(ScrnInfoPtr pScrn, RADEONPortPrivPtr pPriv);

extern void
EVERGREENDisplayTexturedVideo(ScrnInfoPtr pScrn, RADEONPortPrivPtr pPriv);


#define IMAGE_MAX_WIDTH		2048
#define IMAGE_MAX_HEIGHT	2048

#define IMAGE_MAX_WIDTH_R500	4096
#define IMAGE_MAX_HEIGHT_R500	4096

#define IMAGE_MAX_WIDTH_R600	8192
#define IMAGE_MAX_HEIGHT_R600	8192

#define IMAGE_MAX_WIDTH_EG	16384
#define IMAGE_MAX_HEIGHT_EG	16384

static Bool
RADEONTilingEnabled(ScrnInfoPtr pScrn, PixmapPtr pPix)
{
    return FALSE;
}

static __inline__ uint32_t F_TO_DW(float val)
{
    union {
	float f;
	uint32_t l;
    } tmp;
    tmp.f = val;
    return tmp.l;
}

/* Borrowed from Mesa */
static __inline__ uint32_t F_TO_24(float val)
{
	float mantissa;
	int exponent;
	uint32_t float24 = 0;

	if (val == 0.0)
		return 0;

	mantissa = frexpf(val, &exponent);

	/* Handle -ve */
	if (mantissa < 0) {
		float24 |= (1 << 23);
		mantissa = mantissa * -1.0;
	}
	/* Handle exponent, bias of 63 */
	exponent += 62;
	float24 |= (exponent << 16);
	/* Kill 7 LSB of mantissa */
	float24 |= (F_TO_DW(mantissa) & 0x7FFFFF) >> 7;

	return float24;
}

static __inline__ uint32_t float4touint(float fr, float fg, float fb, float fa)
{
    unsigned ur = fr * 255.0 + 0.5;
    unsigned ug = fg * 255.0 + 0.5;
    unsigned ub = fb * 255.0 + 0.5;
    unsigned ua = fa * 255.0 + 0.5;
    return (ua << 24) | (ur << 16) | (ug << 8) | ub;
}

/* Parameters for ITU-R BT.601 and ITU-R BT.709 colour spaces
   note the difference to the parameters used in overlay are due
   to 10bit vs. float calcs */
static REF_TRANSFORM trans[2] =
{
    {1.1643, 0.0, 1.5960, -0.3918, -0.8129, 2.0172, 0.0}, /* BT.601 */
    {1.1643, 0.0, 1.7927, -0.2132, -0.5329, 2.1124, 0.0}  /* BT.709 */
};


/* Allocates memory, either by resizing the allocation pointed to by mem_struct,
 * or by freeing mem_struct (if non-NULL) and allocating a new space.  The size
 * is measured in bytes, and the offset from the beginning of card space is
 * returned.
 */
static Bool
radeon_allocate_video_bo(ScrnInfoPtr pScrn,
			 struct radeon_bo **video_bo_p,
			 int size,
			 int align,
			 int domain)
{
    RADEONInfoPtr info = RADEONPTR(pScrn);
    struct radeon_bo *video_bo;

    if (*video_bo_p)
        radeon_bo_unref(*video_bo_p);

    video_bo = radeon_bo_open(info->bufmgr, 0, size, align, domain, 0);

    *video_bo_p = video_bo;

    if (!video_bo)
        return FALSE;

    return TRUE;
}

static void
RADEONFreeVideoMemory(ScrnInfoPtr pScrn, RADEONPortPrivPtr pPriv)
{
    if (pPriv->video_memory != NULL) {
	radeon_bo_unref(pPriv->video_memory);
	pPriv->video_memory = NULL;

	if (pPriv->textured) {
	    pPriv->src_bo[0] = NULL;
	    radeon_bo_unref(pPriv->src_bo[1]);
	    pPriv->src_bo[1] = NULL;
	}
    }
}

static void
RADEONStopVideo(ScrnInfoPtr pScrn, pointer data, Bool cleanup)
{
  RADEONPortPrivPtr pPriv = (RADEONPortPrivPtr)data;

  if (pPriv->textured) {
      if (cleanup) {
	  RADEONFreeVideoMemory(pScrn, pPriv);
      }
      return;
  }
}

#define OUT_ACCEL_REG_F(reg, val)	OUT_RING_REG(reg, F_TO_DW(val))

#include "radeon_textured_videofuncs.c"

#undef OUT_ACCEL_REG_F

static void
R600CopyData(
    ScrnInfoPtr pScrn,
    unsigned char *src,
    unsigned char *dst,
    unsigned int srcPitch,
    unsigned int dstPitch,
    unsigned int h,
    unsigned int w,
    unsigned int cpp
){
    if (cpp == 2) {
	w *= 2;
	cpp = 1;
    }

    if (srcPitch == dstPitch)
        memcpy(dst, src, srcPitch * h);
    else {
	while (h--) {
	    memcpy(dst, src, srcPitch);
	    src += srcPitch;
	    dst += dstPitch;
	}
    }
}

static int
RADEONPutImageTextured(ScrnInfoPtr pScrn,
		       short src_x, short src_y,
		       short drw_x, short drw_y,
		       short src_w, short src_h,
		       short drw_w, short drw_h,
		       int id,
		       unsigned char *buf,
		       short width,
		       short height,
		       Bool sync,
		       RegionPtr clipBoxes,
		       pointer data,
		       DrawablePtr pDraw)
{
    ScreenPtr pScreen = pScrn->pScreen;
    RADEONInfoPtr info = RADEONPTR(pScrn);
    RADEONPortPrivPtr pPriv = (RADEONPortPrivPtr)data;
    INT32 x1, x2, y1, y2;
    int srcPitch, srcPitch2, dstPitch, dstPitch2 = 0;
    int s2offset, s3offset, tmp;
    int d2line, d3line;
    int top, nlines, size;
    BoxRec dstBox;
    int dst_width = width, dst_height = height;
    int aligned_height;
    int h_align = drmmode_get_height_align(pScrn, 0);
    struct radeon_bo *src_bo;
    int ret;

    /* make the compiler happy */
    s2offset = s3offset = srcPitch2 = 0;

    /* Clip */
    x1 = src_x;
    x2 = src_x + src_w;
    y1 = src_y;
    y2 = src_y + src_h;

    dstBox.x1 = drw_x;
    dstBox.x2 = drw_x + drw_w;
    dstBox.y1 = drw_y;
    dstBox.y2 = drw_y + drw_h;

    if (!xf86XVClipVideoHelper(&dstBox, &x1, &x2, &y1, &y2, clipBoxes, width, height))
	return Success;

    if ((x1 >= x2) || (y1 >= y2))
	return Success;

    /* Bicubic filter setup */
    pPriv->bicubic_enabled = (pPriv->bicubic_state != BICUBIC_OFF);
    if (!(IS_R300_3D || IS_R500_3D)) {
	pPriv->bicubic_enabled = FALSE;
	pPriv->bicubic_state = BICUBIC_OFF;
    }
    if (pPriv->bicubic_enabled && (pPriv->bicubic_state == BICUBIC_AUTO)) {
	/*
	 * Applying the bicubic filter with a scale of less than 200%
	 * results in a blurred picture, so disable the filter.
	 */
	if ((src_w > drw_w / 2) || (src_h > drw_h / 2))
	    pPriv->bicubic_enabled = FALSE;
    }

    if (info->ChipFamily >= CHIP_FAMILY_R600)
	pPriv->hw_align = drmmode_get_base_align(pScrn, 2, 0);
    else
	pPriv->hw_align = 64;

    aligned_height = RADEON_ALIGN(dst_height, h_align);

    switch(id) {
    case FOURCC_YV12:
    case FOURCC_I420:
	srcPitch = RADEON_ALIGN(width, 4);
	srcPitch2 = RADEON_ALIGN(width >> 1, 4);
        if (pPriv->bicubic_state != BICUBIC_OFF) {
	    dstPitch = RADEON_ALIGN(dst_width << 1, pPriv->hw_align);
	    dstPitch2 = 0;
	} else {
	    dstPitch = RADEON_ALIGN(dst_width, pPriv->hw_align);
	    dstPitch2 = RADEON_ALIGN(dstPitch >> 1, pPriv->hw_align);
	}
	break;
    case FOURCC_UYVY:
    case FOURCC_YUY2:
    default:
	dstPitch = RADEON_ALIGN(dst_width << 1, pPriv->hw_align);
	srcPitch = (width << 1);
	srcPitch2 = 0;
	break;
    }

    size = dstPitch * aligned_height + 2 * dstPitch2 * RADEON_ALIGN(((aligned_height + 1) >> 1), h_align);
    size = RADEON_ALIGN(size, pPriv->hw_align);

    if (size != pPriv->size) {
	RADEONFreeVideoMemory(pScrn, pPriv);
    }

    if (pPriv->video_memory == NULL) {
      Bool ret;
      ret = radeon_allocate_video_bo(pScrn,
				     &pPriv->video_memory,
				     size, pPriv->hw_align,
				     RADEON_GEM_DOMAIN_GTT);
      if (ret == FALSE)
	  return BadAlloc;

      pPriv->src_bo[0] = pPriv->video_memory;
      radeon_allocate_video_bo(pScrn, (void*)&pPriv->src_bo[1], size,
			       pPriv->hw_align,
			       RADEON_GEM_DOMAIN_GTT);
    }

    /* Bicubic filter loading */
    if (pPriv->bicubic_enabled) {
	if (info->bicubic_bo == NULL)
	    pPriv->bicubic_enabled = FALSE;
    }

    if (pDraw->type == DRAWABLE_WINDOW)
	pPriv->pPixmap = (*pScreen->GetWindowPixmap)((WindowPtr)pDraw);
    else
	pPriv->pPixmap = (PixmapPtr)pDraw;

    /* Force the pixmap into framebuffer so we can draw to it. */
    info->exa_force_create = TRUE;
    exaMoveInPixmap(pPriv->pPixmap);
    info->exa_force_create = FALSE;

    /* copy data */
    top = (y1 >> 16) & ~1;
    nlines = ((y2 + 0xffff) >> 16) - top;

    pPriv->currentBuffer ^= 1;
	
    src_bo = pPriv->src_bo[pPriv->currentBuffer];

    ret = radeon_bo_map(src_bo, 1);
    if (ret)
	return BadAlloc;
  
    pPriv->src_addr = src_bo->ptr;
    pPriv->src_pitch = dstPitch;

    pPriv->planeu_offset = dstPitch * aligned_height;
    pPriv->planeu_offset = RADEON_ALIGN(pPriv->planeu_offset, pPriv->hw_align);
    pPriv->planev_offset = pPriv->planeu_offset + dstPitch2 * RADEON_ALIGN(((aligned_height + 1) >> 1), h_align);
    pPriv->planev_offset = RADEON_ALIGN(pPriv->planev_offset, pPriv->hw_align);

    pPriv->size = size;
    pPriv->pDraw = pDraw;

    switch(id) {
    case FOURCC_YV12:
    case FOURCC_I420:
	s2offset = srcPitch * (RADEON_ALIGN(height, 2));
	s3offset = s2offset + (srcPitch2 * ((height + 1) >> 1));
	s2offset += ((top >> 1) * srcPitch2);
	s3offset += ((top >> 1) * srcPitch2);
	if (pPriv->bicubic_state != BICUBIC_OFF) {
	    if (id == FOURCC_I420) {
		tmp = s2offset;
		s2offset = s3offset;
		s3offset = tmp;
	    }
	    RADEONCopyMungedData(pScrn, buf + (top * srcPitch),
				 buf + s2offset, buf + s3offset, pPriv->src_addr + (top * dstPitch),
				 srcPitch, srcPitch2, dstPitch, nlines, width);
	} else {
	    if (id == FOURCC_YV12) {
		tmp = s2offset;
		s2offset = s3offset;
		s3offset = tmp;
	    }
	    d2line = pPriv->planeu_offset + ((top >> 1) * dstPitch2);
	    d3line = pPriv->planev_offset + ((top >> 1) * dstPitch2);

	    if (info->ChipFamily >= CHIP_FAMILY_R600) {
		R600CopyData(pScrn, buf + (top * srcPitch), pPriv->src_addr + (top * dstPitch),
			     srcPitch, dstPitch, nlines, width, 1);
		R600CopyData(pScrn, buf + s2offset,  pPriv->src_addr + d2line,
			     srcPitch2, dstPitch2, (nlines + 1) >> 1, width >> 1, 1);
		R600CopyData(pScrn, buf + s3offset, pPriv->src_addr + d3line,
			     srcPitch2, dstPitch2, (nlines + 1) >> 1, width >> 1, 1);
	    } else {
		RADEONCopyData(pScrn, buf + (top * srcPitch), pPriv->src_addr + (top * dstPitch),
			       srcPitch, dstPitch, nlines, width, 1);
		RADEONCopyData(pScrn, buf + s2offset,  pPriv->src_addr + d2line,
			       srcPitch2, dstPitch2, (nlines + 1) >> 1, width >> 1, 1);
		RADEONCopyData(pScrn, buf + s3offset, pPriv->src_addr + d3line,
			       srcPitch2, dstPitch2, (nlines + 1) >> 1, width >> 1, 1);
	    }
	}
	break;
    case FOURCC_UYVY:
    case FOURCC_YUY2:
    default:
	if (info->ChipFamily >= CHIP_FAMILY_R600)
	    R600CopyData(pScrn, buf + (top * srcPitch),
			 pPriv->src_addr + (top * dstPitch),
			 srcPitch, dstPitch, nlines, width, 2);
	else
	    RADEONCopyData(pScrn, buf + (top * srcPitch),
			   pPriv->src_addr + (top * dstPitch),
			   srcPitch, dstPitch, nlines, width, 2);
	break;
    }

    /* update cliplist */
    if (!REGION_EQUAL(pScrn->pScreen, &pPriv->clip, clipBoxes)) {
	REGION_COPY(pScrn->pScreen, &pPriv->clip, clipBoxes);
    }

    pPriv->id = id;
    pPriv->src_w = src_w;
    pPriv->src_h = src_h;
    pPriv->src_x = src_x;
    pPriv->src_y = src_y;
    pPriv->drw_x = drw_x;
    pPriv->drw_y = drw_y;
    pPriv->dst_w = drw_w;
    pPriv->dst_h = drw_h;
    pPriv->w = width;
    pPriv->h = height;

    radeon_bo_unmap(pPriv->src_bo[pPriv->currentBuffer]);
    if (info->directRenderingEnabled) {
	if (IS_EVERGREEN_3D)
	    EVERGREENDisplayTexturedVideo(pScrn, pPriv);
	else if (IS_R600_3D)
	    R600DisplayTexturedVideo(pScrn, pPriv);
	else if (IS_R500_3D)
	    R500DisplayTexturedVideo(pScrn, pPriv);
	else if (IS_R300_3D)
	    R300DisplayTexturedVideo(pScrn, pPriv);
	else if (IS_R200_3D)
	    R200DisplayTexturedVideo(pScrn, pPriv);
	else
	    RADEONDisplayTexturedVideo(pScrn, pPriv);
    }

    return Success;
}

/* client libraries expect an encoding */
static XF86VideoEncodingRec DummyEncoding[1] =
{
    {
	0,
	"XV_IMAGE",
	IMAGE_MAX_WIDTH, IMAGE_MAX_HEIGHT,
	{1, 1}
    }
};

static XF86VideoEncodingRec DummyEncodingR500[1] =
{
    {
	0,
	"XV_IMAGE",
	IMAGE_MAX_WIDTH_R500, IMAGE_MAX_HEIGHT_R500,
	{1, 1}
    }
};

static XF86VideoEncodingRec DummyEncodingR600[1] =
{
    {
	0,
	"XV_IMAGE",
	IMAGE_MAX_WIDTH_R600, IMAGE_MAX_HEIGHT_R600,
	{1, 1}
    }
};

static XF86VideoEncodingRec DummyEncodingEG[1] =
{
    {
	0,
	"XV_IMAGE",
	IMAGE_MAX_WIDTH_EG, IMAGE_MAX_HEIGHT_EG,
	{1, 1}
    }
};

#define NUM_FORMATS 3

static XF86VideoFormatRec Formats[NUM_FORMATS] =
{
    {15, TrueColor}, {16, TrueColor}, {24, TrueColor}
};

#define NUM_ATTRIBUTES 2

static XF86AttributeRec Attributes[NUM_ATTRIBUTES+1] =
{
    {XvSettable | XvGettable, 0, 1, "XV_VSYNC"},
    {XvSettable | XvGettable, -1, 1, "XV_CRTC"},
    {0, 0, 0, NULL}
};

#define NUM_ATTRIBUTES_R200 7

static XF86AttributeRec Attributes_r200[NUM_ATTRIBUTES_R200+1] =
{
    {XvSettable | XvGettable, 0, 1, "XV_VSYNC"},
    {XvSettable | XvGettable, -1000, 1000, "XV_BRIGHTNESS"},
    {XvSettable | XvGettable, -1000, 1000, "XV_CONTRAST"},
    {XvSettable | XvGettable, -1000, 1000, "XV_SATURATION"},
    {XvSettable | XvGettable, -1000, 1000, "XV_HUE"},
    {XvSettable | XvGettable, 0, 1, "XV_COLORSPACE"},
    {XvSettable | XvGettable, -1, 1, "XV_CRTC"},
    {0, 0, 0, NULL}
};

#define NUM_ATTRIBUTES_R300 9

static XF86AttributeRec Attributes_r300[NUM_ATTRIBUTES_R300+1] =
{
    {XvSettable | XvGettable, 0, 2, "XV_BICUBIC"},
    {XvSettable | XvGettable, 0, 1, "XV_VSYNC"},
    {XvSettable | XvGettable, -1000, 1000, "XV_BRIGHTNESS"},
    {XvSettable | XvGettable, -1000, 1000, "XV_CONTRAST"},
    {XvSettable | XvGettable, -1000, 1000, "XV_SATURATION"},
    {XvSettable | XvGettable, -1000, 1000, "XV_HUE"},
    {XvSettable | XvGettable, 100, 10000, "XV_GAMMA"},
    {XvSettable | XvGettable, 0, 1, "XV_COLORSPACE"},
    {XvSettable | XvGettable, -1, 1, "XV_CRTC"},
    {0, 0, 0, NULL}
};

#define NUM_ATTRIBUTES_R500 8

static XF86AttributeRec Attributes_r500[NUM_ATTRIBUTES_R500+1] =
{
    {XvSettable | XvGettable, 0, 2, "XV_BICUBIC"},
    {XvSettable | XvGettable, 0, 1, "XV_VSYNC"},
    {XvSettable | XvGettable, -1000, 1000, "XV_BRIGHTNESS"},
    {XvSettable | XvGettable, -1000, 1000, "XV_CONTRAST"},
    {XvSettable | XvGettable, -1000, 1000, "XV_SATURATION"},
    {XvSettable | XvGettable, -1000, 1000, "XV_HUE"},
    {XvSettable | XvGettable, 0, 1, "XV_COLORSPACE"},
    {XvSettable | XvGettable, -1, 1, "XV_CRTC"},
    {0, 0, 0, NULL}
};

#define NUM_ATTRIBUTES_R600 7

static XF86AttributeRec Attributes_r600[NUM_ATTRIBUTES_R600+1] =
{
    {XvSettable | XvGettable, 0, 1, "XV_VSYNC"},
    {XvSettable | XvGettable, -1000, 1000, "XV_BRIGHTNESS"},
    {XvSettable | XvGettable, -1000, 1000, "XV_CONTRAST"},
    {XvSettable | XvGettable, -1000, 1000, "XV_SATURATION"},
    {XvSettable | XvGettable, -1000, 1000, "XV_HUE"},
    {XvSettable | XvGettable, 0, 1, "XV_COLORSPACE"},
    {XvSettable | XvGettable, -1, 1, "XV_CRTC"},
    {0, 0, 0, NULL}
};

static XF86AttributeRec Attributes_eg[NUM_ATTRIBUTES_R600+1] =
{
    {XvSettable | XvGettable, 0, 1, "XV_VSYNC"},
    {XvSettable | XvGettable, -1000, 1000, "XV_BRIGHTNESS"},
    {XvSettable | XvGettable, -1000, 1000, "XV_CONTRAST"},
    {XvSettable | XvGettable, -1000, 1000, "XV_SATURATION"},
    {XvSettable | XvGettable, -1000, 1000, "XV_HUE"},
    {XvSettable | XvGettable, 0, 1, "XV_COLORSPACE"},
    {XvSettable | XvGettable, -1, 5, "XV_CRTC"},
    {0, 0, 0, NULL}
};

static Atom xvBicubic;
static Atom xvVSync;
static Atom xvBrightness, xvContrast, xvSaturation, xvHue;
static Atom xvGamma, xvColorspace;
static Atom xvCRTC;

#define NUM_IMAGES 4

static XF86ImageRec Images[NUM_IMAGES] =
{
    XVIMAGE_YUY2,
    XVIMAGE_YV12,
    XVIMAGE_I420,
    XVIMAGE_UYVY
};

int
RADEONGetTexPortAttribute(ScrnInfoPtr  pScrn,
		       Atom	    attribute,
		       INT32	    *value,
		       pointer	    data)
{
    RADEONInfoPtr	info = RADEONPTR(pScrn);
    RADEONPortPrivPtr	pPriv = (RADEONPortPrivPtr)data;

    if (info->accelOn) RADEON_SYNC(info, pScrn);

    if (attribute == xvBicubic)
	*value = pPriv->bicubic_state;
    else if (attribute == xvVSync)
	*value = pPriv->vsync;
    else if (attribute == xvBrightness)
	*value = pPriv->brightness;
    else if (attribute == xvContrast)
	*value = pPriv->contrast;
    else if (attribute == xvSaturation)
	*value = pPriv->saturation;
    else if (attribute == xvHue)
	*value = pPriv->hue;
    else if (attribute == xvGamma)
	*value = pPriv->gamma;
    else if(attribute == xvColorspace)
	*value = pPriv->transform_index;
    else if(attribute == xvCRTC) {
	int		c;
	xf86CrtcConfigPtr	xf86_config = XF86_CRTC_CONFIG_PTR(pScrn);
	for (c = 0; c < xf86_config->num_crtc; c++)
	    if (xf86_config->crtc[c] == pPriv->desired_crtc)
		break;
	if (c == xf86_config->num_crtc)
	    c = -1;
	*value = c;
    } else
	return BadMatch;

    return Success;
}

int
RADEONSetTexPortAttribute(ScrnInfoPtr  pScrn,
		       Atom	    attribute,
		       INT32	    value,
		       pointer	    data)
{
    RADEONInfoPtr	info = RADEONPTR(pScrn);
    RADEONPortPrivPtr	pPriv = (RADEONPortPrivPtr)data;

    RADEON_SYNC(info, pScrn);

    if (attribute == xvBicubic)
	pPriv->bicubic_state = ClipValue (value, 0, 2);
    else if (attribute == xvVSync)
	pPriv->vsync = ClipValue (value, 0, 1);
    else if (attribute == xvBrightness)
	pPriv->brightness = ClipValue (value, -1000, 1000);
    else if (attribute == xvContrast)
	pPriv->contrast = ClipValue (value, -1000, 1000);
    else if (attribute == xvSaturation)
	pPriv->saturation = ClipValue (value, -1000, 1000);
    else if (attribute == xvHue)
	pPriv->hue = ClipValue (value, -1000, 1000);
    else if (attribute == xvGamma)
	pPriv->gamma = ClipValue (value, 100, 10000);
    else if(attribute == xvColorspace)
	pPriv->transform_index = ClipValue (value, 0, 1);
    else if(attribute == xvCRTC) {
	xf86CrtcConfigPtr   xf86_config = XF86_CRTC_CONFIG_PTR(pScrn);
	if ((value < -1) || (value > xf86_config->num_crtc))
	    return BadValue;
	if (value < 0)
	    pPriv->desired_crtc = NULL;
	else
	    pPriv->desired_crtc = xf86_config->crtc[value];
    } else
	return BadMatch;

    return Success;
}

Bool radeon_load_bicubic_texture(ScrnInfoPtr pScrn)
{
    RADEONInfoPtr    info = RADEONPTR(pScrn);
    int ret;
    /* Bicubic filter loading */
    ret = radeon_allocate_video_bo(pScrn,
				   &info->bicubic_bo,
				   sizeof(bicubic_tex_512), 64,
				   RADEON_GEM_DOMAIN_VRAM);
    if (ret == FALSE)
	return FALSE;

    /* Upload bicubic filter tex */
    if (info->ChipFamily < CHIP_FAMILY_R600) {
	uint8_t *bicubic_addr;
	int ret;
	ret = radeon_bo_map(info->bicubic_bo, 1);
	if (ret)
	    return FALSE;

	bicubic_addr = info->bicubic_bo->ptr;

	RADEONCopySwap(bicubic_addr, (uint8_t *)bicubic_tex_512, 1024,
#if X_BYTE_ORDER == X_BIG_ENDIAN
		       RADEON_HOST_DATA_SWAP_16BIT
#else
		       RADEON_HOST_DATA_SWAP_NONE
#endif
);
	radeon_bo_unmap(info->bicubic_bo);
    }
    return TRUE;
}

#if 0
/* XXX */
static void radeon_unload_bicubic_texture(ScrnInfoPtr pScrn)
{
    RADEONInfoPtr    info = RADEONPTR(pScrn);

    if (info->bicubic_memory != NULL) {
	radeon_bo_unref(info->bicubic_memory);
	info->bicubic_memory = NULL;
    }

}
#endif

static void
RADEONQueryBestSize(
  ScrnInfoPtr pScrn,
  Bool motion,
  short vid_w, short vid_h,
  short drw_w, short drw_h,
  unsigned int *p_w, unsigned int *p_h,
  pointer data
){
    RADEONPortPrivPtr pPriv = (RADEONPortPrivPtr)data;

    if (!pPriv->textured) {
	if (vid_w > (drw_w << 4))
	    drw_w = vid_w >> 4;
	if (vid_h > (drw_h << 4))
	    drw_h = vid_h >> 4;
    }

  *p_w = drw_w;
  *p_h = drw_h;
}

#define FOURCC_RGB24    0x00000000
#define FOURCC_RGBT16   0x54424752
#define FOURCC_RGB16    0x32424752
#define FOURCC_RGBA32   0x41424752

static int
RADEONQueryImageAttributes(
    ScrnInfoPtr pScrn,
    int id,
    unsigned short *w, unsigned short *h,
    int *pitches, int *offsets
){
    const RADEONInfoRec * const info = RADEONPTR(pScrn);
    int size, tmp;

    if(*w > info->xv_max_width) *w = info->xv_max_width;
    if(*h > info->xv_max_height) *h = info->xv_max_height;

    *w = RADEON_ALIGN(*w, 2);
    if(offsets) offsets[0] = 0;

    switch(id) {
    case FOURCC_YV12:
    case FOURCC_I420:
	*h = RADEON_ALIGN(*h, 2);
	size = RADEON_ALIGN(*w, 4);
	if(pitches) pitches[0] = size;
	size *= *h;
	if(offsets) offsets[1] = size;
	tmp = RADEON_ALIGN(*w >> 1, 4);
	if(pitches) pitches[1] = pitches[2] = tmp;
	tmp *= (*h >> 1);
	size += tmp;
	if(offsets) offsets[2] = size;
	size += tmp;
	break;
    case FOURCC_RGBA32:
	size = *w << 2;
	if(pitches) pitches[0] = size;
	size *= *h;
	break;
    case FOURCC_RGB24:
	size = *w * 3;
	if(pitches) pitches[0] = size;
	size *= *h;
	break;
    case FOURCC_RGBT16:
    case FOURCC_RGB16:
    case FOURCC_UYVY:
    case FOURCC_YUY2:
    default:
	size = *w << 1;
	if(pitches) pitches[0] = size;
	size *= *h;
	break;
    }

    return size;
}

XF86VideoAdaptorPtr
RADEONSetupImageTexturedVideo(ScreenPtr pScreen)
{
    ScrnInfoPtr pScrn = xf86ScreenToScrn(pScreen);
    RADEONInfoPtr    info = RADEONPTR(pScrn);
    RADEONPortPrivPtr pPortPriv;
    XF86VideoAdaptorPtr adapt;
    int i;
    int num_texture_ports = 16;

    adapt = calloc(1, sizeof(XF86VideoAdaptorRec) + num_texture_ports *
		   (sizeof(RADEONPortPrivRec) + sizeof(DevUnion)));
    if (adapt == NULL)
	return NULL;

    xvBicubic         = MAKE_ATOM("XV_BICUBIC");
    xvVSync           = MAKE_ATOM("XV_VSYNC");
    xvBrightness      = MAKE_ATOM("XV_BRIGHTNESS");
    xvContrast        = MAKE_ATOM("XV_CONTRAST");
    xvSaturation      = MAKE_ATOM("XV_SATURATION");
    xvHue             = MAKE_ATOM("XV_HUE");
    xvGamma           = MAKE_ATOM("XV_GAMMA");
    xvColorspace      = MAKE_ATOM("XV_COLORSPACE");
    xvCRTC            = MAKE_ATOM("XV_CRTC");

    adapt->type = XvWindowMask | XvInputMask | XvImageMask;
    adapt->flags = 0;
    adapt->name = "Radeon Textured Video";
    adapt->nEncodings = 1;
    if (IS_EVERGREEN_3D)
	adapt->pEncodings = DummyEncodingEG;
    else if (IS_R600_3D)
	adapt->pEncodings = DummyEncodingR600;
    else if (IS_R500_3D)
	adapt->pEncodings = DummyEncodingR500;
    else
	adapt->pEncodings = DummyEncoding;
    adapt->nFormats = NUM_FORMATS;
    adapt->pFormats = Formats;
    adapt->nPorts = num_texture_ports;
    adapt->pPortPrivates = (DevUnion*)(&adapt[1]);

    pPortPriv =
	(RADEONPortPrivPtr)(&adapt->pPortPrivates[num_texture_ports]);

    if (IS_EVERGREEN_3D) {
	adapt->pAttributes = Attributes_eg;
	adapt->nAttributes = NUM_ATTRIBUTES_R600;
    }
    else if (IS_R600_3D) {
	adapt->pAttributes = Attributes_r600;
	adapt->nAttributes = NUM_ATTRIBUTES_R600;
    }
    else if (IS_R500_3D) {
	adapt->pAttributes = Attributes_r500;
	adapt->nAttributes = NUM_ATTRIBUTES_R500;
    }
    else if (IS_R300_3D) {
	adapt->pAttributes = Attributes_r300;
	adapt->nAttributes = NUM_ATTRIBUTES_R300;
    }
    else if (IS_R200_3D) {
	adapt->pAttributes = Attributes_r200;
	adapt->nAttributes = NUM_ATTRIBUTES_R200;
    }
    else {
	adapt->pAttributes = Attributes;
	adapt->nAttributes = NUM_ATTRIBUTES;
    }
    adapt->pImages = Images;
    adapt->nImages = NUM_IMAGES;
    adapt->PutVideo = NULL;
    adapt->PutStill = NULL;
    adapt->GetVideo = NULL;
    adapt->GetStill = NULL;
    adapt->StopVideo = RADEONStopVideo;
    adapt->SetPortAttribute = RADEONSetTexPortAttribute;
    adapt->GetPortAttribute = RADEONGetTexPortAttribute;
    adapt->QueryBestSize = RADEONQueryBestSize;
    adapt->PutImage = RADEONPutImageTextured;
    adapt->ReputImage = NULL;
    adapt->QueryImageAttributes = RADEONQueryImageAttributes;

    for (i = 0; i < num_texture_ports; i++) {
	RADEONPortPrivPtr pPriv = &pPortPriv[i];

	pPriv->textured = TRUE;
	pPriv->bicubic_state = BICUBIC_OFF;
	pPriv->vsync = TRUE;
	pPriv->brightness = 0;
	pPriv->contrast = 0;
	pPriv->saturation = 0;
	pPriv->hue = 0;
	pPriv->gamma = 1000;
	pPriv->transform_index = 0;
	pPriv->desired_crtc = NULL;

	/* gotta uninit this someplace, XXX: shouldn't be necessary for textured */
	REGION_NULL(pScreen, &pPriv->clip);
	adapt->pPortPrivates[i].ptr = (pointer) (pPriv);
    }

    if (IS_R500_3D || IS_R300_3D)
	radeon_load_bicubic_texture(pScrn);

    info->xv_max_width = adapt->pEncodings->width;
    info->xv_max_height = adapt->pEncodings->height;

    return adapt;
}

@


1.7
log
@Update to xf86-video-ati 6.14.6. Tested by mpi@@, brad, eric@@, ajacoutot@@.
@
text
@a38 1
#include "radeon_macros.h"
a47 1
#ifdef XF86DRM_MODE
a49 1
#endif
a50 5
extern Bool
R600CopyToVRAM(ScrnInfoPtr pScrn,
	       char *src, int src_pitch,
	       uint32_t dst_pitch, uint32_t dst_mc_addr, uint32_t dst_width, uint32_t dst_height, int bpp,
	       int x, int y, int w, int h);
d67 1
a67 16
    RADEONInfoPtr info = RADEONPTR(pScrn);

#ifdef USE_EXA
    if (info->useEXA) {
	if (info->tilingEnabled && exaGetPixmapOffset(pPix) == 0)
	    return TRUE;
	else
	    return FALSE;
    } else
#endif
	{
	    if (info->tilingEnabled && ((pPix->devPrivate.ptr - info->FB) == 0))
		return TRUE;
	    else
		return FALSE;
	}
a123 7
#define ACCEL_MMIO
#define ACCEL_PREAMBLE()	unsigned char *RADEONMMIO = info->MMIO
#define BEGIN_ACCEL(n)		RADEONWaitForFifo(pScrn, (n))
#define OUT_ACCEL_REG(reg, val)	OUTREG(reg, val)
#define OUT_ACCEL_REG_F(reg, val) OUTREG(reg, F_TO_DW(val))
#define OUT_RELOC(x, read, write) do {} while(0)
#define FINISH_ACCEL()
d125 42
a166 1
#include "radeon_textured_videofuncs.c"
d168 4
a171 7
#undef ACCEL_MMIO
#undef ACCEL_PREAMBLE
#undef BEGIN_ACCEL
#undef OUT_ACCEL_REG
#undef OUT_ACCEL_REG_F
#undef OUT_RELOC
#undef FINISH_ACCEL
d173 7
a179 1
#ifdef XF86DRI
d181 1
a181 10
#define ACCEL_CP
#define ACCEL_PREAMBLE()						\
    RING_LOCALS;							\
    RADEONCP_REFRESH(pScrn, info)
#define BEGIN_ACCEL(n)		BEGIN_RING(2*(n))
#define OUT_ACCEL_REG(reg, val)	OUT_RING_REG(reg, val)
#define OUT_ACCEL_REG_F(reg, val)	OUT_ACCEL_REG(reg, F_TO_DW(val))
#define FINISH_ACCEL()		ADVANCE_RING()
#define OUT_RING_F(x) OUT_RING(F_TO_DW(x))
#define OUT_RELOC(x, read, write) OUT_RING_RELOC(x, read, write)
a184 4
#undef ACCEL_CP
#undef ACCEL_PREAMBLE
#undef BEGIN_ACCEL
#undef OUT_ACCEL_REG
a185 4
#undef FINISH_ACCEL
#undef OUT_RING_F

#endif /* XF86DRI */
a197 2
    RADEONInfoPtr info = RADEONPTR( pScrn );

d203 7
a209 16
    if (info->DMAForXv) {
	uint32_t dst_mc_addr = dst - (unsigned char *)info->FB + info->fbLocation;

	R600CopyToVRAM(pScrn,
		       (char *)src, srcPitch,
		       dstPitch, dst_mc_addr, w, h, cpp * 8,
		       0, 0, w, h);
    } else {
	if (srcPitch == dstPitch)
	    memcpy(dst, src, srcPitch * h);
	else {
	    while (h--) {
		memcpy(dst, src, srcPitch);
		src += srcPitch;
		dst += dstPitch;
	    }
a239 1
#ifdef XF86DRM_MODE
d241 3
a243 3
#else
    int h_align = 1;
#endif
d279 4
a282 14
#ifdef XF86DRM_MODE
    if (info->cs) {
	if (info->ChipFamily >= CHIP_FAMILY_R600)
	    pPriv->hw_align = drmmode_get_base_align(pScrn, 2, 0);
	else
	    pPriv->hw_align = 64;
    } else
#endif
    {
	if (info->ChipFamily >= CHIP_FAMILY_R600)
	    pPriv->hw_align = 256;
	else
	    pPriv->hw_align = 64;
    }
d316 12
a327 13
	pPriv->video_offset = radeon_legacy_allocate_memory(pScrn,
							    &pPriv->video_memory,
							    size, pPriv->hw_align,
							    RADEON_GEM_DOMAIN_GTT);
	if (pPriv->video_offset == 0)
	    return BadAlloc;

	if (info->cs) {
	    pPriv->src_bo[0] = pPriv->video_memory;
	    radeon_legacy_allocate_memory(pScrn, (void*)&pPriv->src_bo[1], size,
					  pPriv->hw_align,
					  RADEON_GEM_DOMAIN_GTT);
	}
d332 1
a332 1
	if (info->bicubic_offset == 0)
a333 1
	pPriv->bicubic_src_offset = info->bicubic_offset;
d341 4
a344 18
#ifdef USE_EXA
    if (info->useEXA) {
	/* Force the pixmap into framebuffer so we can draw to it. */
	info->exa_force_create = TRUE;
	exaMoveInPixmap(pPriv->pPixmap);
	info->exa_force_create = FALSE;
    }
#endif

    if (!info->useEXA &&
	(((char *)pPriv->pPixmap->devPrivate.ptr < (char *)info->FB) ||
	 ((char *)pPriv->pPixmap->devPrivate.ptr >= (char *)info->FB +
	  info->FbMapSize))) {
	/* If the pixmap wasn't in framebuffer, then we have no way in XAA to
	 * force it there. So, we simply refuse to draw and fail.
	 */
	return BadAlloc;
    }
d350 3
a352 6
    pPriv->src_offset = pPriv->video_offset;
    if (info->cs) {
	struct radeon_bo *src_bo;
	int ret;

	pPriv->currentBuffer ^= 1;
d354 5
a358 11
	src_bo = pPriv->src_bo[pPriv->currentBuffer];

	ret = radeon_bo_map(src_bo, 1);
	if (ret)
	    return BadAlloc;

	pPriv->src_addr = src_bo->ptr;
    } else {
	pPriv->src_addr = (uint8_t *)(info->FB + pPriv->video_offset);
	RADEONWaitForIdleMMIO(pScrn);
    }
d442 1
a442 5
#if defined(XF86DRM_MODE)
    if (info->cs)
	radeon_bo_unmap(pPriv->src_bo[pPriv->currentBuffer]);
#endif
#ifdef XF86DRI
a443 1
#ifdef XF86DRM_MODE
d446 1
a446 3
	else
#endif
	  if (IS_R600_3D)
d449 1
a449 12
	    R500DisplayTexturedVideoCP(pScrn, pPriv);
	else if (IS_R300_3D)
	    R300DisplayTexturedVideoCP(pScrn, pPriv);
	else if (IS_R200_3D)
	    R200DisplayTexturedVideoCP(pScrn, pPriv);
	else
	    RADEONDisplayTexturedVideoCP(pScrn, pPriv);
    } else
#endif
    {
	if (IS_R500_3D)
	    R500DisplayTexturedVideoMMIO(pScrn, pPriv);
d451 1
a451 1
	    R300DisplayTexturedVideoMMIO(pScrn, pPriv);
d453 1
a453 1
	    R200DisplayTexturedVideoMMIO(pScrn, pPriv);
d455 1
a455 1
	    RADEONDisplayTexturedVideoMMIO(pScrn, pPriv);
d691 1
a691 1

d693 5
a697 5
    info->bicubic_offset = radeon_legacy_allocate_memory(pScrn,
							 &info->bicubic_memory,
							 sizeof(bicubic_tex_512), 64,
							 RADEON_GEM_DOMAIN_VRAM);
    if (info->bicubic_offset == 0)
a699 3
    if (info->cs)
	info->bicubic_bo = info->bicubic_memory;

d704 5
a708 8
	if (info->cs) {
	    ret = radeon_bo_map(info->bicubic_bo, 1);
	    if (ret)
		return FALSE;

	    bicubic_addr = info->bicubic_bo->ptr;
	} else
	    bicubic_addr = (uint8_t *)(info->FB + info->bicubic_offset);
d717 1
a717 2
	if (info->cs)
	    radeon_bo_unmap(info->bicubic_bo);
d729 1
a729 1
	radeon_legacy_free_memory(pScrn, info->bicubic_memory);
d736 82
a904 3
	pPriv->videoStatus = 0;
	pPriv->currentBuffer = 0;
	pPriv->doubleBuffer = 0;
@


1.6
log
@Update to xf86-video-ati 6.14.4. Tested by jasper@@, krw@@, mpi@@, shadchin@@
@
text
@d814 1
a814 1
    ScrnInfoPtr pScrn = xf86Screens[pScreen->myNum];
@


1.5
log
@Re-update xf86-video-ati to 6.14.3.

Because of ati.c revision 1.5, it will not be selected by
autoconfiguration code, so people who want to run this version of the
driver on their radeon cards need an explicit "Device" section in
xorg.conf.
@
text
@d69 3
d560 10
d840 3
a842 1
    if (IS_R600_3D)
@


1.4
log
@Revert the update to xf86-video-ati 6.14.3. Requested by espie@@
who experiemnts regressions with this driver.
@
text
@a38 1
#include "r600_reg.h"
d49 5
d57 1
a57 1
	       uint32_t dst_pitch, uint32_t dst_mc_addr, uint32_t dst_height, int bpp,
d135 9
d149 1
d159 1
d173 1
d188 24
a211 64
R600CopyPlanarHW(ScrnInfoPtr pScrn,
		 unsigned char *y_src, unsigned char *u_src, unsigned char *v_src,
		 uint32_t dst_mc_addr,
		 int srcPitch, int srcPitch2, int dstPitch,
		 int w, int h)
{
    int dstPitch2 = dstPitch >> 1;
    int h2 = h >> 1;
    int w2 = w >> 1;
    int v_offset, u_offset;
    v_offset = dstPitch * h;
    v_offset = (v_offset + 255) & ~255;
    u_offset = v_offset + (dstPitch2 * h2);
    u_offset = (u_offset + 255) & ~255;

    /* Y */
    R600CopyToVRAM(pScrn,
		   (char *)y_src, srcPitch,
		   dstPitch, dst_mc_addr, h, 8,
		   0, 0, w, h);

    /* V */
    R600CopyToVRAM(pScrn,
		   (char *)v_src, srcPitch2,
		   dstPitch2, dst_mc_addr + v_offset, h2, 8,
		   0, 0, w2, h2);

    /* U */
    R600CopyToVRAM(pScrn,
		   (char *)u_src, srcPitch2,
		   dstPitch2, dst_mc_addr + u_offset, h2, 8,
		   0, 0, w2, h2);
}

static void
R600CopyPackedHW(ScrnInfoPtr pScrn,
		 unsigned char *src, uint32_t dst_mc_addr,
		 int srcPitch, int dstPitch,
		 int w, int h)
{

    /* YUV */
    R600CopyToVRAM(pScrn,
		   (char *)src, srcPitch,
		   dstPitch >> 2, dst_mc_addr, h, 32,
		   0, 0, w >> 1, h);

}

static void
R600CopyPlanarSW(ScrnInfoPtr pScrn,
		 unsigned char *y_src, unsigned char *u_src, unsigned char *v_src,
		 unsigned char *dst,
		 int srcPitch, int srcPitch2, int dstPitch,
		 int w, int h)
{
    int i;
    int dstPitch2 = dstPitch >> 1;
    int h2 = h >> 1;

    /* Y */
    if (srcPitch == dstPitch) {
        memcpy(dst, y_src, srcPitch * h);
	dst += (dstPitch * h);
d213 9
a221 57
	for (i = 0; i < h; i++) {
            memcpy(dst, y_src, srcPitch);
            y_src += srcPitch;
            dst += dstPitch;
        }
    }

    /* tex base need 256B alignment */
    if (h & 1)
	dst += dstPitch;

    /* V */
    if (srcPitch2 == dstPitch2) {
        memcpy(dst, v_src, srcPitch2 * h2);
	dst += (dstPitch2 * h2);
    } else {
	for (i = 0; i < h2; i++) {
            memcpy(dst, v_src, srcPitch2);
            v_src += srcPitch2;
            dst += dstPitch2;
        }
    }

    /* tex base need 256B alignment */
    if (h2 & 1)
	dst += dstPitch2;

    /* U */
    if (srcPitch2 == dstPitch2) {
        memcpy(dst, u_src, srcPitch2 * h2);
	dst += (dstPitch2 * h2);
    } else {
	for (i = 0; i < h2; i++) {
            memcpy(dst, u_src, srcPitch2);
            u_src += srcPitch2;
            dst += dstPitch2;
        }
    }
}

static void
R600CopyPackedSW(ScrnInfoPtr pScrn,
		 unsigned char *src, unsigned char *dst,
		 int srcPitch, int dstPitch,
		 int w, int h)
{
    int i;

    if (srcPitch == dstPitch) {
        memcpy(dst, src, srcPitch * h);
	dst += (dstPitch * h);
    } else {
	for (i = 0; i < h; i++) {
            memcpy(dst, src, srcPitch);
            src += srcPitch;
            dst += dstPitch;
        }
d247 1
a247 1
    int top, left, npixels, nlines, size;
d250 6
a255 1

a272 5
/*    src_w = (x2 - x1) >> 16;
    src_h = (y2 - y1) >> 16;
    drw_w = dstBox.x2 - dstBox.x1;
    drw_h = dstBox.y2 - dstBox.y1;*/

d278 1
a278 1
    if (!(IS_R300_3D || IS_R500_3D || IS_R600_3D))
d280 2
d291 16
a306 7
    pPriv->planar_hw = pPriv->planar_state;
    if (pPriv->bicubic_enabled || !( IS_R300_3D ||
	    (info->ChipFamily == CHIP_FAMILY_RV250) ||
	    (info->ChipFamily == CHIP_FAMILY_RV280) ||
	    (info->ChipFamily == CHIP_FAMILY_RS300) ||
	    (info->ChipFamily == CHIP_FAMILY_R200) ))
        pPriv->planar_hw = 0;
d311 5
a315 7
	srcPitch = (width + 3) & ~3;
	srcPitch2 = ((width >> 1) + 3) & ~3;
        if (pPriv->planar_hw) {
	    dstPitch = (dst_width + 15) & ~15;
	    dstPitch = (dstPitch + 63) & ~63;
	    dstPitch2 = ((dst_width >> 1) + 15) & ~15;
	    dstPitch2 = (dstPitch2 + 63) & ~63;
d317 2
a318 2
	    dstPitch = ((dst_width << 1) + 15) & ~15;
	    dstPitch = (dstPitch + 63) & ~63;
d324 1
a324 2
	dstPitch = ((dst_width << 1) + 15) & ~15;
	dstPitch = (dstPitch + 63) & ~63;
d330 2
a331 4
    if (info->ChipFamily >= CHIP_FAMILY_R600)
	dstPitch = (dstPitch + 255) & ~255;

    size = dstPitch * dst_height + 2 * dstPitch2 * ((dst_height + 1) >> 1);
d333 2
a334 3
    if (pPriv->video_memory != NULL && size != pPriv->size) {
	radeon_legacy_free_memory(pScrn, pPriv->video_memory);
	pPriv->video_memory = NULL;
d338 4
a341 8
	if (info->ChipFamily >= CHIP_FAMILY_R600)
	    pPriv->video_offset = radeon_legacy_allocate_memory(pScrn,
								&pPriv->video_memory,
								size * 2, 256);
	else
	    pPriv->video_offset = radeon_legacy_allocate_memory(pScrn,
								&pPriv->video_memory,
								size * 2, 64);
d344 7
d354 4
a357 7
    if (pPriv->bicubic_memory == NULL && pPriv->bicubic_enabled) {
	pPriv->bicubic_offset = radeon_legacy_allocate_memory(pScrn,
						              &pPriv->bicubic_memory,
						              sizeof(bicubic_tex_512), 64);
	pPriv->bicubic_src_offset = pPriv->bicubic_offset + info->fbLocation + pScrn->fbOffset;
	if (pPriv->bicubic_offset == 0)
		pPriv->bicubic_enabled = FALSE;
d368 1
d370 1
d385 11
a395 3
    top = y1 >> 16;
    left = (x1 >> 16) & ~1;
    npixels = ((((x2 + 0xffff) >> 16) + 1) & ~1) - left;
d397 6
a402 2
    pPriv->src_offset = pPriv->video_offset + info->fbLocation + pScrn->fbOffset;
    if (info->ChipFamily >= CHIP_FAMILY_R600)
d404 2
a405 2
    else
	pPriv->src_addr = (uint8_t *)(info->FB + pPriv->video_offset + (top * dstPitch));
d407 6
a412 2
    pPriv->planeu_offset = dstPitch * dst_height;
    pPriv->planev_offset = pPriv->planeu_offset + dstPitch2 * ((dst_height + 1) >> 1);
a415 10

#if 0
    ErrorF("planeu_offset: 0x%x\n", pPriv->planeu_offset);
    ErrorF("planev_offset: 0x%x\n", pPriv->planev_offset);
    ErrorF("dstPitch2: 0x%x\n", dstPitch2);
    ErrorF("src_offset: 0x%x\n", pPriv->src_offset);
    ErrorF("src_addr: 0x%x\n", pPriv->src_addr);
    ErrorF("src_pitch: 0x%x\n", pPriv->src_pitch);
#endif

d419 6
a424 39
	if (info->ChipFamily >= CHIP_FAMILY_R600) {
	    s2offset = srcPitch * height;
	    s3offset = (srcPitch2 * (height >> 1)) + s2offset;
	    if (info->DMAForXv) {
		if (id == FOURCC_YV12)
		    R600CopyPlanarHW(pScrn, buf, buf + s3offset, buf + s2offset,
				     pPriv->src_offset,
				     srcPitch, srcPitch2, pPriv->src_pitch,
				     width, height);
		else
		    R600CopyPlanarHW(pScrn, buf, buf + s2offset, buf + s3offset,
				     pPriv->src_offset,
				     srcPitch, srcPitch2, pPriv->src_pitch,
				     width, height);
	    } else {
		if (id == FOURCC_YV12)
		    R600CopyPlanarSW(pScrn, buf, buf + s3offset, buf + s2offset,
				     pPriv->src_addr,
				     srcPitch, srcPitch2, pPriv->src_pitch,
				     width, height);
		else
		    R600CopyPlanarSW(pScrn, buf, buf + s2offset, buf + s3offset,
				     pPriv->src_addr,
				     srcPitch, srcPitch2, pPriv->src_pitch,
				     width, height);
	    }
	}
        else if (pPriv->planar_hw) {
	    top &= ~1;
	    s2offset = srcPitch * ((height + 1) & ~1);
	    s3offset = s2offset + srcPitch2 * ((height + 1) >> 1);
	    s2offset += (top >> 1) * srcPitch2 + (left >> 1);
	    s3offset += (top >> 1) * srcPitch2 + (left >> 1);
	    d2line = pPriv->planeu_offset;
	    d3line = pPriv->planev_offset;
	    d2line += (top >> 1) * dstPitch2 - (top * dstPitch);
	    d3line += (top >> 1) * dstPitch2 - (top * dstPitch);
	    nlines = ((y2 + 0xffff) >> 16) - top;
	    if(id == FOURCC_YV12) {
d429 3
a431 6
	    RADEONCopyData(pScrn, buf + (top * srcPitch) + left, pPriv->src_addr + left,
		srcPitch, dstPitch, nlines, npixels, 1);
	    RADEONCopyData(pScrn, buf + s2offset,  pPriv->src_addr + d2line + (left >> 1),
		srcPitch2, dstPitch2, (nlines + 1) >> 1, npixels >> 1, 1);
	    RADEONCopyData(pScrn, buf + s3offset, pPriv->src_addr + d3line + (left >> 1),
		srcPitch2, dstPitch2, (nlines + 1) >> 1, npixels >> 1, 1);
d433 1
a433 9
	    top &= ~1;
	    nlines = ((((y2 + 0xffff) >> 16) + 1) & ~1) - top;
	    s2offset = srcPitch * height;
	    s3offset = (srcPitch2 * (height >> 1)) + s2offset;
	    pPriv->src_addr += left << 1;
	    tmp = ((top >> 1) * srcPitch2) + (left >> 1);
	    s2offset += tmp;
	    s3offset += tmp;
	    if (id == FOURCC_I420) {
d438 18
a455 3
	    RADEONCopyMungedData(pScrn, buf + (top * srcPitch) + left,
				 buf + s2offset, buf + s3offset, pPriv->src_addr,
				 srcPitch, srcPitch2, dstPitch, nlines, npixels);
d461 8
a468 15
	if (info->ChipFamily >= CHIP_FAMILY_R600) {
	    if (info->DMAForXv)
		R600CopyPackedHW(pScrn, buf, pPriv->src_offset,
				 2 * width, pPriv->src_pitch,
				 width, height);
	    else
		R600CopyPackedSW(pScrn, buf, pPriv->src_addr,
				 2 * width, pPriv->src_pitch,
				 width, height);
	} else {
	    nlines = ((y2 + 0xffff) >> 16) - top;
	    pPriv->src_addr += left << 1;
	    RADEONCopyData(pScrn, buf + (top * srcPitch) + (left << 1),
			   pPriv->src_addr, srcPitch, dstPitch, nlines, npixels, 2);
	}
a471 7
    /* Upload bicubic filter tex */
    if (pPriv->bicubic_enabled) {
	if (info->ChipFamily < CHIP_FAMILY_R600)
	    RADEONCopyData(pScrn, (uint8_t *)bicubic_tex_512,
			   (uint8_t *)(info->FB + pPriv->bicubic_offset), 1024, 1024, 1, 512, 2);
    }

d480 2
d489 4
d494 17
a510 5
    if (IS_R600_3D)
	R600DisplayTexturedVideo(pScrn, pPriv);
    else if (info->directRenderingEnabled)
	RADEONDisplayTexturedVideoCP(pScrn, pPriv);
    else
d512 10
a521 1
	RADEONDisplayTexturedVideoMMIO(pScrn, pPriv);
d569 1
a569 1
    {XvSettable | XvGettable, 0, 1, "XV_HWPLANAR"},
d573 15
a587 1
#define NUM_ATTRIBUTES_R300 3
d593 48
a640 1
    {XvSettable | XvGettable, 0, 1, "XV_HWPLANAR"},
d646 3
a648 1
static Atom xvHWPlanar;
d675 22
a696 3
    else if (attribute == xvHWPlanar)
	*value = pPriv->planar_state;
    else
d717 21
a737 3
    else if (attribute == xvHWPlanar)
	pPriv->planar_state = ClipValue (value, 0, 1);
    else
d743 55
d808 2
a809 2
    adapt = xcalloc(1, sizeof(XF86VideoAdaptorRec) + num_texture_ports *
		    (sizeof(RADEONPortPrivRec) + sizeof(DevUnion)));
d815 7
a821 1
    xvHWPlanar        = MAKE_ATOM("XV_HWPLANAR");
d841 13
a853 1
    if (IS_R300_3D || IS_R500_3D) {
d856 6
a861 1
    } else {
d886 1
a886 1
	pPriv->bicubic_state = BICUBIC_AUTO;
d888 7
a894 1
	pPriv->planar_state = 1;
d900 6
@


1.3
log
@Update to xf86-video-ati 6.14.3. Tested by many.
@
text
@d39 1
a49 5
#ifdef XF86DRM_MODE
extern void
EVERGREENDisplayTexturedVideo(ScrnInfoPtr pScrn, RADEONPortPrivPtr pPriv);
#endif

d53 1
a53 1
	       uint32_t dst_pitch, uint32_t dst_mc_addr, uint32_t dst_width, uint32_t dst_height, int bpp,
a130 9
/* Parameters for ITU-R BT.601 and ITU-R BT.709 colour spaces
   note the difference to the parameters used in overlay are due
   to 10bit vs. float calcs */
static REF_TRANSFORM trans[2] =
{
    {1.1643, 0.0, 1.5960, -0.3918, -0.8129, 2.0172, 0.0}, /* BT.601 */
    {1.1643, 0.0, 1.7927, -0.2132, -0.5329, 2.1124, 0.0}  /* BT.709 */
};

a135 1
#define OUT_RELOC(x, read, write) do {} while(0)
a144 1
#undef OUT_RELOC
a157 1
#define OUT_RELOC(x, read, write) OUT_RING_RELOC(x, read, write)
d172 116
a287 24
R600CopyData(
    ScrnInfoPtr pScrn,
    unsigned char *src,
    unsigned char *dst,
    unsigned int srcPitch,
    unsigned int dstPitch,
    unsigned int h,
    unsigned int w,
    unsigned int cpp
){
    RADEONInfoPtr info = RADEONPTR( pScrn );

    if (cpp == 2) {
	w *= 2;
	cpp = 1;
    }

    if (info->DMAForXv) {
	uint32_t dst_mc_addr = dst - (unsigned char *)info->FB + info->fbLocation;

	R600CopyToVRAM(pScrn,
		       (char *)src, srcPitch,
		       dstPitch, dst_mc_addr, w, h, cpp * 8,
		       0, 0, w, h);
d289 5
a293 9
	if (srcPitch == dstPitch)
	    memcpy(dst, src, srcPitch * h);
	else {
	    while (h--) {
		memcpy(dst, src, srcPitch);
		src += srcPitch;
		dst += dstPitch;
	    }
	}
d319 1
a319 1
    int top, nlines, size;
d322 1
a322 6
    int aligned_height;
#ifdef XF86DRM_MODE
    int h_align = drmmode_get_height_align(pScrn, 0);
#else
    int h_align = 1;
#endif
d340 5
d350 1
a350 1
    if (!(IS_R300_3D || IS_R500_3D)) {
a351 2
	pPriv->bicubic_state = BICUBIC_OFF;
    }
d361 7
a367 16
#ifdef XF86DRM_MODE
    if (info->cs) {
	if (info->ChipFamily >= CHIP_FAMILY_R600)
	    pPriv->hw_align = drmmode_get_base_align(pScrn, 2, 0);
	else
	    pPriv->hw_align = 64;
    } else
#endif
    {
	if (info->ChipFamily >= CHIP_FAMILY_R600)
	    pPriv->hw_align = 256;
	else
	    pPriv->hw_align = 64;
    }

    aligned_height = RADEON_ALIGN(dst_height, h_align);
d372 7
a378 5
	srcPitch = RADEON_ALIGN(width, 4);
	srcPitch2 = RADEON_ALIGN(width >> 1, 4);
        if (pPriv->bicubic_state != BICUBIC_OFF) {
	    dstPitch = RADEON_ALIGN(dst_width << 1, pPriv->hw_align);
	    dstPitch2 = 0;
d380 2
a381 2
	    dstPitch = RADEON_ALIGN(dst_width, pPriv->hw_align);
	    dstPitch2 = RADEON_ALIGN(dstPitch >> 1, pPriv->hw_align);
d387 2
a388 1
	dstPitch = RADEON_ALIGN(dst_width << 1, pPriv->hw_align);
d394 4
a397 2
    size = dstPitch * aligned_height + 2 * dstPitch2 * RADEON_ALIGN(((aligned_height + 1) >> 1), h_align);
    size = RADEON_ALIGN(size, pPriv->hw_align);
d399 3
a401 2
    if (size != pPriv->size) {
	RADEONFreeVideoMemory(pScrn, pPriv);
d405 8
a412 4
	pPriv->video_offset = radeon_legacy_allocate_memory(pScrn,
							    &pPriv->video_memory,
							    size, pPriv->hw_align,
							    RADEON_GEM_DOMAIN_GTT);
a414 7

	if (info->cs) {
	    pPriv->src_bo[0] = pPriv->video_memory;
	    radeon_legacy_allocate_memory(pScrn, (void*)&pPriv->src_bo[1], size,
					  pPriv->hw_align,
					  RADEON_GEM_DOMAIN_GTT);
	}
d418 7
a424 4
    if (pPriv->bicubic_enabled) {
	if (info->bicubic_offset == 0)
	    pPriv->bicubic_enabled = FALSE;
	pPriv->bicubic_src_offset = info->bicubic_offset;
a434 1
	info->exa_force_create = TRUE;
a435 1
	info->exa_force_create = FALSE;
d450 3
a452 11
    top = (y1 >> 16) & ~1;
    nlines = ((y2 + 0xffff) >> 16) - top;

    pPriv->src_offset = pPriv->video_offset;
    if (info->cs) {
	struct radeon_bo *src_bo;
	int ret;

	pPriv->currentBuffer ^= 1;

	src_bo = pPriv->src_bo[pPriv->currentBuffer];
d454 2
a455 6
	ret = radeon_bo_map(src_bo, 1);
	if (ret)
	    return BadAlloc;

	pPriv->src_addr = src_bo->ptr;
    } else {
d457 2
a458 2
	RADEONWaitForIdleMMIO(pScrn);
    }
d460 4
a464 4
    pPriv->planeu_offset = dstPitch * aligned_height;
    pPriv->planeu_offset = RADEON_ALIGN(pPriv->planeu_offset, pPriv->hw_align);
    pPriv->planev_offset = pPriv->planeu_offset + dstPitch2 * RADEON_ALIGN(((aligned_height + 1) >> 1), h_align);
    pPriv->planev_offset = RADEON_ALIGN(pPriv->planev_offset, pPriv->hw_align);
d466 8
a473 2
    pPriv->size = size;
    pPriv->pDraw = pDraw;
d478 39
a516 6
	s2offset = srcPitch * (RADEON_ALIGN(height, 2));
	s3offset = s2offset + (srcPitch2 * ((height + 1) >> 1));
	s2offset += ((top >> 1) * srcPitch2);
	s3offset += ((top >> 1) * srcPitch2);
	if (pPriv->bicubic_state != BICUBIC_OFF) {
	    if (id == FOURCC_I420) {
d521 6
a526 3
	    RADEONCopyMungedData(pScrn, buf + (top * srcPitch),
				 buf + s2offset, buf + s3offset, pPriv->src_addr + (top * dstPitch),
				 srcPitch, srcPitch2, dstPitch, nlines, width);
d528 9
a536 1
	    if (id == FOURCC_YV12) {
d541 3
a543 18
	    d2line = pPriv->planeu_offset + ((top >> 1) * dstPitch2);
	    d3line = pPriv->planev_offset + ((top >> 1) * dstPitch2);

	    if (info->ChipFamily >= CHIP_FAMILY_R600) {
		R600CopyData(pScrn, buf + (top * srcPitch), pPriv->src_addr + (top * dstPitch),
			     srcPitch, dstPitch, nlines, width, 1);
		R600CopyData(pScrn, buf + s2offset,  pPriv->src_addr + d2line,
			     srcPitch2, dstPitch2, (nlines + 1) >> 1, width >> 1, 1);
		R600CopyData(pScrn, buf + s3offset, pPriv->src_addr + d3line,
			     srcPitch2, dstPitch2, (nlines + 1) >> 1, width >> 1, 1);
	    } else {
		RADEONCopyData(pScrn, buf + (top * srcPitch), pPriv->src_addr + (top * dstPitch),
			       srcPitch, dstPitch, nlines, width, 1);
		RADEONCopyData(pScrn, buf + s2offset,  pPriv->src_addr + d2line,
			       srcPitch2, dstPitch2, (nlines + 1) >> 1, width >> 1, 1);
		RADEONCopyData(pScrn, buf + s3offset, pPriv->src_addr + d3line,
			       srcPitch2, dstPitch2, (nlines + 1) >> 1, width >> 1, 1);
	    }
d549 15
a563 8
	if (info->ChipFamily >= CHIP_FAMILY_R600)
	    R600CopyData(pScrn, buf + (top * srcPitch),
			 pPriv->src_addr + (top * dstPitch),
			 srcPitch, dstPitch, nlines, width, 2);
	else
	    RADEONCopyData(pScrn, buf + (top * srcPitch),
			   pPriv->src_addr + (top * dstPitch),
			   srcPitch, dstPitch, nlines, width, 2);
d567 7
a581 2
    pPriv->src_x = src_x;
    pPriv->src_y = src_y;
a588 4
#if defined(XF86DRM_MODE)
    if (info->cs)
	radeon_bo_unmap(pPriv->src_bo[pPriv->currentBuffer]);
#endif
d590 5
a594 5
    if (info->directRenderingEnabled) {
#ifdef XF86DRM_MODE
	if (IS_EVERGREEN_3D)
	    EVERGREENDisplayTexturedVideo(pScrn, pPriv);
	else
d596 1
a596 22
	  if (IS_R600_3D)
	    R600DisplayTexturedVideo(pScrn, pPriv);
	else if (IS_R500_3D)
	    R500DisplayTexturedVideoCP(pScrn, pPriv);
	else if (IS_R300_3D)
	    R300DisplayTexturedVideoCP(pScrn, pPriv);
	else if (IS_R200_3D)
	    R200DisplayTexturedVideoCP(pScrn, pPriv);
	else
	    RADEONDisplayTexturedVideoCP(pScrn, pPriv);
    } else
#endif
    {
	if (IS_R500_3D)
	    R500DisplayTexturedVideoMMIO(pScrn, pPriv);
	else if (IS_R300_3D)
	    R300DisplayTexturedVideoMMIO(pScrn, pPriv);
	else if (IS_R200_3D)
	    R200DisplayTexturedVideoMMIO(pScrn, pPriv);
	else
	    RADEONDisplayTexturedVideoMMIO(pScrn, pPriv);
    }
d644 1
a644 1
    {XvSettable | XvGettable, -1, 1, "XV_CRTC"},
d648 1
a648 15
#define NUM_ATTRIBUTES_R200 7

static XF86AttributeRec Attributes_r200[NUM_ATTRIBUTES_R200+1] =
{
    {XvSettable | XvGettable, 0, 1, "XV_VSYNC"},
    {XvSettable | XvGettable, -1000, 1000, "XV_BRIGHTNESS"},
    {XvSettable | XvGettable, -1000, 1000, "XV_CONTRAST"},
    {XvSettable | XvGettable, -1000, 1000, "XV_SATURATION"},
    {XvSettable | XvGettable, -1000, 1000, "XV_HUE"},
    {XvSettable | XvGettable, 0, 1, "XV_COLORSPACE"},
    {XvSettable | XvGettable, -1, 1, "XV_CRTC"},
    {0, 0, 0, NULL}
};

#define NUM_ATTRIBUTES_R300 9
d654 1
a654 48
    {XvSettable | XvGettable, -1000, 1000, "XV_BRIGHTNESS"},
    {XvSettable | XvGettable, -1000, 1000, "XV_CONTRAST"},
    {XvSettable | XvGettable, -1000, 1000, "XV_SATURATION"},
    {XvSettable | XvGettable, -1000, 1000, "XV_HUE"},
    {XvSettable | XvGettable, 100, 10000, "XV_GAMMA"},
    {XvSettable | XvGettable, 0, 1, "XV_COLORSPACE"},
    {XvSettable | XvGettable, -1, 1, "XV_CRTC"},
    {0, 0, 0, NULL}
};

#define NUM_ATTRIBUTES_R500 8

static XF86AttributeRec Attributes_r500[NUM_ATTRIBUTES_R500+1] =
{
    {XvSettable | XvGettable, 0, 2, "XV_BICUBIC"},
    {XvSettable | XvGettable, 0, 1, "XV_VSYNC"},
    {XvSettable | XvGettable, -1000, 1000, "XV_BRIGHTNESS"},
    {XvSettable | XvGettable, -1000, 1000, "XV_CONTRAST"},
    {XvSettable | XvGettable, -1000, 1000, "XV_SATURATION"},
    {XvSettable | XvGettable, -1000, 1000, "XV_HUE"},
    {XvSettable | XvGettable, 0, 1, "XV_COLORSPACE"},
    {XvSettable | XvGettable, -1, 1, "XV_CRTC"},
    {0, 0, 0, NULL}
};

#define NUM_ATTRIBUTES_R600 7

static XF86AttributeRec Attributes_r600[NUM_ATTRIBUTES_R600+1] =
{
    {XvSettable | XvGettable, 0, 1, "XV_VSYNC"},
    {XvSettable | XvGettable, -1000, 1000, "XV_BRIGHTNESS"},
    {XvSettable | XvGettable, -1000, 1000, "XV_CONTRAST"},
    {XvSettable | XvGettable, -1000, 1000, "XV_SATURATION"},
    {XvSettable | XvGettable, -1000, 1000, "XV_HUE"},
    {XvSettable | XvGettable, 0, 1, "XV_COLORSPACE"},
    {XvSettable | XvGettable, -1, 1, "XV_CRTC"},
    {0, 0, 0, NULL}
};

static XF86AttributeRec Attributes_eg[NUM_ATTRIBUTES_R600+1] =
{
    {XvSettable | XvGettable, 0, 1, "XV_VSYNC"},
    {XvSettable | XvGettable, -1000, 1000, "XV_BRIGHTNESS"},
    {XvSettable | XvGettable, -1000, 1000, "XV_CONTRAST"},
    {XvSettable | XvGettable, -1000, 1000, "XV_SATURATION"},
    {XvSettable | XvGettable, -1000, 1000, "XV_HUE"},
    {XvSettable | XvGettable, 0, 1, "XV_COLORSPACE"},
    {XvSettable | XvGettable, -1, 5, "XV_CRTC"},
d660 1
a660 3
static Atom xvBrightness, xvContrast, xvSaturation, xvHue;
static Atom xvGamma, xvColorspace;
static Atom xvCRTC;
d687 3
a689 22
    else if (attribute == xvBrightness)
	*value = pPriv->brightness;
    else if (attribute == xvContrast)
	*value = pPriv->contrast;
    else if (attribute == xvSaturation)
	*value = pPriv->saturation;
    else if (attribute == xvHue)
	*value = pPriv->hue;
    else if (attribute == xvGamma)
	*value = pPriv->gamma;
    else if(attribute == xvColorspace)
	*value = pPriv->transform_index;
    else if(attribute == xvCRTC) {
	int		c;
	xf86CrtcConfigPtr	xf86_config = XF86_CRTC_CONFIG_PTR(pScrn);
	for (c = 0; c < xf86_config->num_crtc; c++)
	    if (xf86_config->crtc[c] == pPriv->desired_crtc)
		break;
	if (c == xf86_config->num_crtc)
	    c = -1;
	*value = c;
    } else
d710 3
a712 21
    else if (attribute == xvBrightness)
	pPriv->brightness = ClipValue (value, -1000, 1000);
    else if (attribute == xvContrast)
	pPriv->contrast = ClipValue (value, -1000, 1000);
    else if (attribute == xvSaturation)
	pPriv->saturation = ClipValue (value, -1000, 1000);
    else if (attribute == xvHue)
	pPriv->hue = ClipValue (value, -1000, 1000);
    else if (attribute == xvGamma)
	pPriv->gamma = ClipValue (value, 100, 10000);
    else if(attribute == xvColorspace)
	pPriv->transform_index = ClipValue (value, 0, 1);
    else if(attribute == xvCRTC) {
	xf86CrtcConfigPtr   xf86_config = XF86_CRTC_CONFIG_PTR(pScrn);
	if ((value < -1) || (value > xf86_config->num_crtc))
	    return BadValue;
	if (value < 0)
	    pPriv->desired_crtc = NULL;
	else
	    pPriv->desired_crtc = xf86_config->crtc[value];
    } else
a717 55
Bool radeon_load_bicubic_texture(ScrnInfoPtr pScrn)
{
    RADEONInfoPtr    info = RADEONPTR(pScrn);

    /* Bicubic filter loading */
    info->bicubic_offset = radeon_legacy_allocate_memory(pScrn,
							 &info->bicubic_memory,
							 sizeof(bicubic_tex_512), 64,
							 RADEON_GEM_DOMAIN_VRAM);
    if (info->bicubic_offset == 0)
	return FALSE;

    if (info->cs)
	info->bicubic_bo = info->bicubic_memory;

    /* Upload bicubic filter tex */
    if (info->ChipFamily < CHIP_FAMILY_R600) {
	uint8_t *bicubic_addr;
	int ret;
	if (info->cs) {
	    ret = radeon_bo_map(info->bicubic_bo, 1);
	    if (ret)
		return FALSE;

	    bicubic_addr = info->bicubic_bo->ptr;
	} else
	    bicubic_addr = (uint8_t *)(info->FB + info->bicubic_offset);

	RADEONCopySwap(bicubic_addr, (uint8_t *)bicubic_tex_512, 1024,
#if X_BYTE_ORDER == X_BIG_ENDIAN
		       RADEON_HOST_DATA_SWAP_16BIT
#else
		       RADEON_HOST_DATA_SWAP_NONE
#endif
);
	if (info->cs)
	    radeon_bo_unmap(info->bicubic_bo);
    }
    return TRUE;
}

#if 0
/* XXX */
static void radeon_unload_bicubic_texture(ScrnInfoPtr pScrn)
{
    RADEONInfoPtr    info = RADEONPTR(pScrn);

    if (info->bicubic_memory != NULL) {
	radeon_legacy_free_memory(pScrn, info->bicubic_memory);
	info->bicubic_memory = NULL;
    }

}
#endif

d728 2
a729 2
    adapt = calloc(1, sizeof(XF86VideoAdaptorRec) + num_texture_ports *
		   (sizeof(RADEONPortPrivRec) + sizeof(DevUnion)));
d735 1
a735 7
    xvBrightness      = MAKE_ATOM("XV_BRIGHTNESS");
    xvContrast        = MAKE_ATOM("XV_CONTRAST");
    xvSaturation      = MAKE_ATOM("XV_SATURATION");
    xvHue             = MAKE_ATOM("XV_HUE");
    xvGamma           = MAKE_ATOM("XV_GAMMA");
    xvColorspace      = MAKE_ATOM("XV_COLORSPACE");
    xvCRTC            = MAKE_ATOM("XV_CRTC");
d755 1
a755 13
    if (IS_EVERGREEN_3D) {
	adapt->pAttributes = Attributes_eg;
	adapt->nAttributes = NUM_ATTRIBUTES_R600;
    }
    else if (IS_R600_3D) {
	adapt->pAttributes = Attributes_r600;
	adapt->nAttributes = NUM_ATTRIBUTES_R600;
    }
    else if (IS_R500_3D) {
	adapt->pAttributes = Attributes_r500;
	adapt->nAttributes = NUM_ATTRIBUTES_R500;
    }
    else if (IS_R300_3D) {
d758 1
a758 6
    }
    else if (IS_R200_3D) {
	adapt->pAttributes = Attributes_r200;
	adapt->nAttributes = NUM_ATTRIBUTES_R200;
    }
    else {
d783 1
a783 1
	pPriv->bicubic_state = BICUBIC_OFF;
d785 1
a785 7
	pPriv->brightness = 0;
	pPriv->contrast = 0;
	pPriv->saturation = 0;
	pPriv->hue = 0;
	pPriv->gamma = 1000;
	pPriv->transform_index = 0;
	pPriv->desired_crtc = NULL;
a790 6

    if (IS_R500_3D || IS_R300_3D)
	radeon_load_bicubic_texture(pScrn);

    info->xv_max_width = adapt->pEncodings->width;
    info->xv_max_height = adapt->pEncodings->height;
@


1.2
log
@update do xf86-video-ati 6.12.2

This has been in snapshots for weeks. ok oga@@, todd@@.
@
text
@a38 1
#include "r600_reg.h"
d49 5
d57 1
a57 1
	       uint32_t dst_pitch, uint32_t dst_mc_addr, uint32_t dst_height, int bpp,
d135 9
d149 1
d159 1
d173 1
d188 24
a211 64
R600CopyPlanarHW(ScrnInfoPtr pScrn,
		 unsigned char *y_src, unsigned char *u_src, unsigned char *v_src,
		 uint32_t dst_mc_addr,
		 int srcPitch, int srcPitch2, int dstPitch,
		 int w, int h)
{
    int dstPitch2 = dstPitch >> 1;
    int h2 = h >> 1;
    int w2 = w >> 1;
    int v_offset, u_offset;
    v_offset = dstPitch * h;
    v_offset = (v_offset + 255) & ~255;
    u_offset = v_offset + (dstPitch2 * h2);
    u_offset = (u_offset + 255) & ~255;

    /* Y */
    R600CopyToVRAM(pScrn,
		   (char *)y_src, srcPitch,
		   dstPitch, dst_mc_addr, h, 8,
		   0, 0, w, h);

    /* V */
    R600CopyToVRAM(pScrn,
		   (char *)v_src, srcPitch2,
		   dstPitch2, dst_mc_addr + v_offset, h2, 8,
		   0, 0, w2, h2);

    /* U */
    R600CopyToVRAM(pScrn,
		   (char *)u_src, srcPitch2,
		   dstPitch2, dst_mc_addr + u_offset, h2, 8,
		   0, 0, w2, h2);
}

static void
R600CopyPackedHW(ScrnInfoPtr pScrn,
		 unsigned char *src, uint32_t dst_mc_addr,
		 int srcPitch, int dstPitch,
		 int w, int h)
{

    /* YUV */
    R600CopyToVRAM(pScrn,
		   (char *)src, srcPitch,
		   dstPitch >> 2, dst_mc_addr, h, 32,
		   0, 0, w >> 1, h);

}

static void
R600CopyPlanarSW(ScrnInfoPtr pScrn,
		 unsigned char *y_src, unsigned char *u_src, unsigned char *v_src,
		 unsigned char *dst,
		 int srcPitch, int srcPitch2, int dstPitch,
		 int w, int h)
{
    int i;
    int dstPitch2 = dstPitch >> 1;
    int h2 = h >> 1;

    /* Y */
    if (srcPitch == dstPitch) {
        memcpy(dst, y_src, srcPitch * h);
	dst += (dstPitch * h);
d213 9
a221 57
	for (i = 0; i < h; i++) {
            memcpy(dst, y_src, srcPitch);
            y_src += srcPitch;
            dst += dstPitch;
        }
    }

    /* tex base need 256B alignment */
    if (h & 1)
	dst += dstPitch;

    /* V */
    if (srcPitch2 == dstPitch2) {
        memcpy(dst, v_src, srcPitch2 * h2);
	dst += (dstPitch2 * h2);
    } else {
	for (i = 0; i < h2; i++) {
            memcpy(dst, v_src, srcPitch2);
            v_src += srcPitch2;
            dst += dstPitch2;
        }
    }

    /* tex base need 256B alignment */
    if (h2 & 1)
	dst += dstPitch2;

    /* U */
    if (srcPitch2 == dstPitch2) {
        memcpy(dst, u_src, srcPitch2 * h2);
	dst += (dstPitch2 * h2);
    } else {
	for (i = 0; i < h2; i++) {
            memcpy(dst, u_src, srcPitch2);
            u_src += srcPitch2;
            dst += dstPitch2;
        }
    }
}

static void
R600CopyPackedSW(ScrnInfoPtr pScrn,
		 unsigned char *src, unsigned char *dst,
		 int srcPitch, int dstPitch,
		 int w, int h)
{
    int i;

    if (srcPitch == dstPitch) {
        memcpy(dst, src, srcPitch * h);
	dst += (dstPitch * h);
    } else {
	for (i = 0; i < h; i++) {
            memcpy(dst, src, srcPitch);
            src += srcPitch;
            dst += dstPitch;
        }
d247 1
a247 1
    int top, left, npixels, nlines, size;
d250 6
a255 1

a272 5
/*    src_w = (x2 - x1) >> 16;
    src_h = (y2 - y1) >> 16;
    drw_w = dstBox.x2 - dstBox.x1;
    drw_h = dstBox.y2 - dstBox.y1;*/

d278 1
a278 1
    if (!(IS_R300_3D || IS_R500_3D || IS_R600_3D))
d280 2
d291 16
a306 7
    pPriv->planar_hw = pPriv->planar_state;
    if (pPriv->bicubic_enabled || !( IS_R300_3D ||
	    (info->ChipFamily == CHIP_FAMILY_RV250) ||
	    (info->ChipFamily == CHIP_FAMILY_RV280) ||
	    (info->ChipFamily == CHIP_FAMILY_RS300) ||
	    (info->ChipFamily == CHIP_FAMILY_R200) ))
        pPriv->planar_hw = 0;
d311 5
a315 7
	srcPitch = (width + 3) & ~3;
	srcPitch2 = ((width >> 1) + 3) & ~3;
        if (pPriv->planar_hw) {
	    dstPitch = (dst_width + 15) & ~15;
	    dstPitch = (dstPitch + 63) & ~63;
	    dstPitch2 = ((dst_width >> 1) + 15) & ~15;
	    dstPitch2 = (dstPitch2 + 63) & ~63;
d317 2
a318 2
	    dstPitch = ((dst_width << 1) + 15) & ~15;
	    dstPitch = (dstPitch + 63) & ~63;
d324 1
a324 2
	dstPitch = ((dst_width << 1) + 15) & ~15;
	dstPitch = (dstPitch + 63) & ~63;
d330 2
a331 4
    if (info->ChipFamily >= CHIP_FAMILY_R600)
	dstPitch = (dstPitch + 255) & ~255;

    size = dstPitch * dst_height + 2 * dstPitch2 * ((dst_height + 1) >> 1);
d333 2
a334 3
    if (pPriv->video_memory != NULL && size != pPriv->size) {
	radeon_legacy_free_memory(pScrn, pPriv->video_memory);
	pPriv->video_memory = NULL;
d338 4
a341 8
	if (info->ChipFamily >= CHIP_FAMILY_R600)
	    pPriv->video_offset = radeon_legacy_allocate_memory(pScrn,
								&pPriv->video_memory,
								size * 2, 256);
	else
	    pPriv->video_offset = radeon_legacy_allocate_memory(pScrn,
								&pPriv->video_memory,
								size * 2, 64);
d344 7
d354 4
a357 7
    if (pPriv->bicubic_memory == NULL && pPriv->bicubic_enabled) {
	pPriv->bicubic_offset = radeon_legacy_allocate_memory(pScrn,
						              &pPriv->bicubic_memory,
						              sizeof(bicubic_tex_512), 64);
	pPriv->bicubic_src_offset = pPriv->bicubic_offset + info->fbLocation + pScrn->fbOffset;
	if (pPriv->bicubic_offset == 0)
		pPriv->bicubic_enabled = FALSE;
d368 1
d370 1
d385 11
a395 3
    top = y1 >> 16;
    left = (x1 >> 16) & ~1;
    npixels = ((((x2 + 0xffff) >> 16) + 1) & ~1) - left;
d397 6
a402 2
    pPriv->src_offset = pPriv->video_offset + info->fbLocation + pScrn->fbOffset;
    if (info->ChipFamily >= CHIP_FAMILY_R600)
d404 2
a405 2
    else
	pPriv->src_addr = (uint8_t *)(info->FB + pPriv->video_offset + (top * dstPitch));
d407 6
a412 2
    pPriv->planeu_offset = dstPitch * dst_height;
    pPriv->planev_offset = pPriv->planeu_offset + dstPitch2 * ((dst_height + 1) >> 1);
a415 10

#if 0
    ErrorF("planeu_offset: 0x%x\n", pPriv->planeu_offset);
    ErrorF("planev_offset: 0x%x\n", pPriv->planev_offset);
    ErrorF("dstPitch2: 0x%x\n", dstPitch2);
    ErrorF("src_offset: 0x%x\n", pPriv->src_offset);
    ErrorF("src_addr: 0x%x\n", pPriv->src_addr);
    ErrorF("src_pitch: 0x%x\n", pPriv->src_pitch);
#endif

d419 6
a424 39
	if (info->ChipFamily >= CHIP_FAMILY_R600) {
	    s2offset = srcPitch * height;
	    s3offset = (srcPitch2 * (height >> 1)) + s2offset;
	    if (info->DMAForXv) {
		if (id == FOURCC_YV12)
		    R600CopyPlanarHW(pScrn, buf, buf + s3offset, buf + s2offset,
				     pPriv->src_offset,
				     srcPitch, srcPitch2, pPriv->src_pitch,
				     width, height);
		else
		    R600CopyPlanarHW(pScrn, buf, buf + s2offset, buf + s3offset,
				     pPriv->src_offset,
				     srcPitch, srcPitch2, pPriv->src_pitch,
				     width, height);
	    } else {
		if (id == FOURCC_YV12)
		    R600CopyPlanarSW(pScrn, buf, buf + s3offset, buf + s2offset,
				     pPriv->src_addr,
				     srcPitch, srcPitch2, pPriv->src_pitch,
				     width, height);
		else
		    R600CopyPlanarSW(pScrn, buf, buf + s2offset, buf + s3offset,
				     pPriv->src_addr,
				     srcPitch, srcPitch2, pPriv->src_pitch,
				     width, height);
	    }
	}
        else if (pPriv->planar_hw) {
	    top &= ~1;
	    s2offset = srcPitch * ((height + 1) & ~1);
	    s3offset = s2offset + srcPitch2 * ((height + 1) >> 1);
	    s2offset += (top >> 1) * srcPitch2 + (left >> 1);
	    s3offset += (top >> 1) * srcPitch2 + (left >> 1);
	    d2line = pPriv->planeu_offset;
	    d3line = pPriv->planev_offset;
	    d2line += (top >> 1) * dstPitch2 - (top * dstPitch);
	    d3line += (top >> 1) * dstPitch2 - (top * dstPitch);
	    nlines = ((y2 + 0xffff) >> 16) - top;
	    if(id == FOURCC_YV12) {
d429 3
a431 6
	    RADEONCopyData(pScrn, buf + (top * srcPitch) + left, pPriv->src_addr + left,
		srcPitch, dstPitch, nlines, npixels, 1);
	    RADEONCopyData(pScrn, buf + s2offset,  pPriv->src_addr + d2line + (left >> 1),
		srcPitch2, dstPitch2, (nlines + 1) >> 1, npixels >> 1, 1);
	    RADEONCopyData(pScrn, buf + s3offset, pPriv->src_addr + d3line + (left >> 1),
		srcPitch2, dstPitch2, (nlines + 1) >> 1, npixels >> 1, 1);
d433 1
a433 9
	    top &= ~1;
	    nlines = ((((y2 + 0xffff) >> 16) + 1) & ~1) - top;
	    s2offset = srcPitch * height;
	    s3offset = (srcPitch2 * (height >> 1)) + s2offset;
	    pPriv->src_addr += left << 1;
	    tmp = ((top >> 1) * srcPitch2) + (left >> 1);
	    s2offset += tmp;
	    s3offset += tmp;
	    if (id == FOURCC_I420) {
d438 18
a455 3
	    RADEONCopyMungedData(pScrn, buf + (top * srcPitch) + left,
				 buf + s2offset, buf + s3offset, pPriv->src_addr,
				 srcPitch, srcPitch2, dstPitch, nlines, npixels);
d461 8
a468 15
	if (info->ChipFamily >= CHIP_FAMILY_R600) {
	    if (info->DMAForXv)
		R600CopyPackedHW(pScrn, buf, pPriv->src_offset,
				 2 * width, pPriv->src_pitch,
				 width, height);
	    else
		R600CopyPackedSW(pScrn, buf, pPriv->src_addr,
				 2 * width, pPriv->src_pitch,
				 width, height);
	} else {
	    nlines = ((y2 + 0xffff) >> 16) - top;
	    pPriv->src_addr += left << 1;
	    RADEONCopyData(pScrn, buf + (top * srcPitch) + (left << 1),
			   pPriv->src_addr, srcPitch, dstPitch, nlines, npixels, 2);
	}
a471 7
    /* Upload bicubic filter tex */
    if (pPriv->bicubic_enabled) {
	if (info->ChipFamily < CHIP_FAMILY_R600)
	    RADEONCopyData(pScrn, (uint8_t *)bicubic_tex_512,
			   (uint8_t *)(info->FB + pPriv->bicubic_offset), 1024, 1024, 1, 512, 2);
    }

d480 2
d489 4
d494 17
a510 5
    if (IS_R600_3D)
	R600DisplayTexturedVideo(pScrn, pPriv);
    else if (info->directRenderingEnabled)
	RADEONDisplayTexturedVideoCP(pScrn, pPriv);
    else
d512 10
a521 1
	RADEONDisplayTexturedVideoMMIO(pScrn, pPriv);
d569 1
a569 1
    {XvSettable | XvGettable, 0, 1, "XV_HWPLANAR"},
d573 15
a587 1
#define NUM_ATTRIBUTES_R300 3
d593 48
a640 1
    {XvSettable | XvGettable, 0, 1, "XV_HWPLANAR"},
d646 3
a648 1
static Atom xvHWPlanar;
d675 22
a696 3
    else if (attribute == xvHWPlanar)
	*value = pPriv->planar_state;
    else
d717 21
a737 3
    else if (attribute == xvHWPlanar)
	pPriv->planar_state = ClipValue (value, 0, 1);
    else
d743 55
d808 2
a809 2
    adapt = xcalloc(1, sizeof(XF86VideoAdaptorRec) + num_texture_ports *
		    (sizeof(RADEONPortPrivRec) + sizeof(DevUnion)));
d815 7
a821 1
    xvHWPlanar        = MAKE_ATOM("XV_HWPLANAR");
d841 13
a853 1
    if (IS_R300_3D || IS_R500_3D) {
d856 6
a861 1
    } else {
d886 1
a886 1
	pPriv->bicubic_state = BICUBIC_AUTO;
d888 7
a894 1
	pPriv->planar_state = 1;
d900 6
@


1.1
log
@Long awaited update of xf86-video-ati to 6.9.0.

the rage128 and mach64 drivers were split out of this driver just after
the 6.8.0 release, these drivers will be commited separately.

MergedFb mode is gone, so please use xrandr if you used to use it.

ok matthieu@@.
@
text
@d39 1
d47 9
d62 3
d96 35
d132 5
a136 5
#define VIDEO_PREAMBLE()	unsigned char *RADEONMMIO = info->MMIO
#define BEGIN_VIDEO(n)		RADEONWaitForFifo(pScrn, (n))
#define OUT_VIDEO_REG(reg, val)	OUTREG(reg, val)
#define OUT_VIDEO_REG_F(reg, val) OUTREG(reg, F_TO_DW(val))
#define FINISH_VIDEO()
d141 5
a145 4
#undef VIDEO_PREAMBLE
#undef BEGIN_VIDEO
#undef OUT_VIDEO_REG
#undef FINISH_VIDEO
d150 1
a150 1
#define VIDEO_PREAMBLE()						\
d153 5
a157 4
#define BEGIN_VIDEO(n)		BEGIN_RING(2*(n))
#define OUT_VIDEO_REG(reg, val)	OUT_RING_REG(reg, val)
#define FINISH_VIDEO()		ADVANCE_RING()
#define OUT_VIDEO_RING_F(x) OUT_RING(F_TO_DW(x))
d161 8
d171 126
d316 1
a316 1
    int srcPitch, srcPitch2, dstPitch;
d318 1
d340 1
a340 1
    src_w = (x2 - x1) >> 16;
d343 1
a343 1
    drw_h = dstBox.y2 - dstBox.y1;
d348 21
a371 1
	dstPitch = ((dst_width << 1) + 15) & ~15;
d374 9
a382 1
	size = dstPitch * dst_height;
d388 1
a390 1
	size = dstPitch * dst_height;
d394 4
a397 7
#ifdef XF86DRI
   if (info->directRenderingEnabled && info->DMAForXv)
       /* The upload blit only supports multiples of 64 bytes */
       dstPitch = (dstPitch + 63) & ~63;
   else
#endif
       dstPitch = (dstPitch + 15) & ~15;
d400 1
a400 1
	RADEONFreeMemory(pScrn, pPriv->video_memory);
d405 8
a412 3
	pPriv->video_offset = RADEONAllocateMemory(pScrn,
						       &pPriv->video_memory,
						       size * 2);
d417 10
d455 4
a458 1
    pPriv->src_addr = (uint8_t *)(info->FB + pPriv->video_offset + (top * dstPitch));
d460 2
d465 1
d467 3
d478 66
a543 13
	top &= ~1;
	nlines = ((((y2 + 0xffff) >> 16) + 1) & ~1) - top;
	s2offset = srcPitch * height;
	s3offset = (srcPitch2 * (height >> 1)) + s2offset;
	top &= ~1;
	pPriv->src_addr += left << 1;
	tmp = ((top >> 1) * srcPitch2) + (left >> 1);
	s2offset += tmp;
	s3offset += tmp;
	if (id == FOURCC_I420) {
	    tmp = s2offset;
	    s2offset = s3offset;
	    s3offset = tmp;
a544 3
	RADEONCopyMungedData(pScrn, buf + (top * srcPitch) + left,
			     buf + s2offset, buf + s3offset, pPriv->src_addr,
			     srcPitch, srcPitch2, dstPitch, nlines, npixels);
d549 15
a563 2
	nlines = ((y2 + 0xffff) >> 16) - top;
	RADEONCopyData(pScrn, buf, pPriv->src_addr, srcPitch, dstPitch, nlines, npixels, 2);
d567 7
d590 3
a592 1
    if (info->directRenderingEnabled)
d622 10
d639 1
a639 1
#define NUM_ATTRIBUTES 0
d641 1
a641 1
static XF86AttributeRec Attributes[NUM_ATTRIBUTES] =
d643 3
d648 14
d672 46
d733 4
d741 3
a743 1
    if (IS_R500_3D)
d755 7
a761 2
    adapt->nAttributes = NUM_ATTRIBUTES;
    adapt->pAttributes = Attributes;
d769 2
a770 2
    adapt->SetPortAttribute = RADEONSetPortAttribute;
    adapt->GetPortAttribute = RADEONGetPortAttribute;
d783 3
@

