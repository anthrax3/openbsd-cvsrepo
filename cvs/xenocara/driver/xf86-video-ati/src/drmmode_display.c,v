head	1.12;
access;
symbols
	OPENBSD_6_0:1.11.0.2
	OPENBSD_6_0_BASE:1.11
	OPENBSD_5_9:1.10.0.4
	OPENBSD_5_9_BASE:1.10
	OPENBSD_5_8:1.10.0.2
	OPENBSD_5_8_BASE:1.10
	OPENBSD_5_7:1.9.0.4
	OPENBSD_5_7_BASE:1.9
	OPENBSD_5_6:1.9.0.2
	OPENBSD_5_6_BASE:1.9
	OPENBSD_5_5:1.8.0.2
	OPENBSD_5_5_BASE:1.8
	OPENBSD_5_4:1.6.0.2
	OPENBSD_5_4_BASE:1.6
	OPENBSD_5_3:1.5.0.2
	OPENBSD_5_3_BASE:1.5
	OPENBSD_5_2:1.4.0.2
	OPENBSD_5_2_BASE:1.4;
locks; strict;
comment	@ * @;


1.12
date	2016.11.13.14.42.27;	author matthieu;	state Exp;
branches;
next	1.11;
commitid	VCI3KGRPv1Ex2rp2;

1.11
date	2016.04.02.07.37.34;	author matthieu;	state Exp;
branches;
next	1.10;
commitid	bsyGwvYIwQ6RE8Qj;

1.10
date	2015.04.14.19.55.49;	author matthieu;	state Exp;
branches;
next	1.9;
commitid	cZqnMrCmViqubI1u;

1.9
date	2014.04.09.20.21.16;	author matthieu;	state Exp;
branches;
next	1.8;

1.8
date	2013.08.18.13.54.41;	author kettenis;	state Exp;
branches;
next	1.7;

1.7
date	2013.08.16.17.04.06;	author matthieu;	state Exp;
branches;
next	1.6;

1.6
date	2013.06.29.14.20.25;	author jsg;	state Exp;
branches;
next	1.5;

1.5
date	2012.08.08.16.25.22;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2012.06.07.20.55.34;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2012.03.04.16.01.19;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2012.02.06.22.53.12;	author matthieu;	state dead;
branches;
next	1.1;

1.1
date	2012.01.25.21.33.35;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.12
log
@Update to xf86-video-ati 7.7.1
Tested by jsg@@,  Rafael Sadowski and myself on various hardware.
@
text
@/*
 * Copyright Â© 2007 Red Hat, Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice (including the next
 * paragraph) shall be included in all copies or substantial portions of the
 * Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 * Authors:
 *    Dave Airlie <airlied@@redhat.com>
 *
 */

#ifdef HAVE_CONFIG_H
#include "config.h"
#endif

#include <errno.h>
#include <sys/ioctl.h>
#include <time.h>
#include "cursorstr.h"
#include "damagestr.h"
#include "micmap.h"
#include "xf86cmap.h"
#include "xf86Priv.h"
#include "radeon.h"
#include "radeon_bo_helper.h"
#include "radeon_glamor.h"
#include "radeon_list.h"
#include "radeon_reg.h"

#ifdef RADEON_PIXMAP_SHARING
#include <dri.h>
#endif

#include "drmmode_display.h"

/* DPMS */
#ifdef HAVE_XEXTPROTO_71
#include <X11/extensions/dpmsconst.h>
#else
#define DPMS_SERVER
#include <X11/extensions/dpms.h>
#endif

#define DEFAULT_NOMINAL_FRAME_RATE 60

static Bool
drmmode_xf86crtc_resize (ScrnInfoPtr scrn, int width, int height);

static Bool
RADEONZaphodStringMatches(ScrnInfoPtr pScrn, const char *s, char *output_name)
{
    int i = 0;
    char s1[20];

    do {
	switch(*s) {
	case ',':
  	    s1[i] = '\0';
	    i = 0;
	    if (strcmp(s1, output_name) == 0)
		return TRUE;
	    break;
	case ' ':
	case '\t':
	case '\n':
	case '\r':
	    break;
	default:
	    s1[i] = *s;
	    i++;
	    break;
	}
    } while(*s++);

    s1[i] = '\0';
    if (strcmp(s1, output_name) == 0)
	return TRUE;

    return FALSE;
}

static PixmapPtr drmmode_create_bo_pixmap(ScrnInfoPtr pScrn,
					  int width, int height,
					  int depth, int bpp,
					  int pitch,
					  struct radeon_bo *bo, struct radeon_surface *psurf)
{
	RADEONInfoPtr info = RADEONPTR(pScrn);
	ScreenPtr pScreen = pScrn->pScreen;
	PixmapPtr pixmap;
	struct radeon_surface *surface;
	uint32_t tiling;

	pixmap = (*pScreen->CreatePixmap)(pScreen, 0, 0, depth,
					  RADEON_CREATE_PIXMAP_SCANOUT);
	if (!pixmap)
		return NULL;

	if (pitch <= 0 &&
	    (radeon_bo_get_tiling(bo, &tiling, (uint32_t*)&pitch) != 0 ||
	     pitch <= 0)) {
		ErrorF("radeon_bo_get_tiling failed to determine pitch\n");
		pScreen->DestroyPixmap(pixmap);
		return NULL;
	}

	if (!(*pScreen->ModifyPixmapHeader)(pixmap, width, height,
					    depth, bpp, pitch, NULL)) {
		return NULL;
	}

	if (!info->use_glamor)
		exaMoveInPixmap(pixmap);
	radeon_set_pixmap_bo(pixmap, bo);
	if (info->ChipFamily >= CHIP_FAMILY_R600) {
		surface = radeon_get_pixmap_surface(pixmap);
		if (surface && psurf) 
			*surface = *psurf;
		else if (surface) {
			memset(surface, 0, sizeof(struct radeon_surface));
			surface->npix_x = width;
			surface->npix_y = height;
			surface->npix_z = 1;
			surface->blk_w = 1;
			surface->blk_h = 1;
			surface->blk_d = 1;
			surface->array_size = 1;
			surface->last_level = 0;
			surface->bpe = bpp / 8;
			surface->nsamples = 1;
			surface->flags = RADEON_SURF_SCANOUT;
			/* we are requiring a recent enough libdrm version */
			surface->flags |= RADEON_SURF_HAS_TILE_MODE_INDEX;
			surface->flags |= RADEON_SURF_SET(RADEON_SURF_TYPE_2D, TYPE);
			surface->flags |= RADEON_SURF_SET(RADEON_SURF_MODE_LINEAR_ALIGNED, MODE);
			tiling = radeon_get_pixmap_tiling_flags(pixmap);
			if (tiling & RADEON_TILING_MICRO) {
				surface->flags = RADEON_SURF_CLR(surface->flags, MODE);
				surface->flags |= RADEON_SURF_SET(RADEON_SURF_MODE_1D, MODE);
			}
			if (tiling & RADEON_TILING_MACRO) {
				surface->flags = RADEON_SURF_CLR(surface->flags, MODE);
				surface->flags |= RADEON_SURF_SET(RADEON_SURF_MODE_2D, MODE);
			}
			if (radeon_surface_best(info->surf_man, surface)) {
				return NULL;
			}
			if (radeon_surface_init(info->surf_man, surface)) {
				return NULL;
			}
		}
	}

	if (info->use_glamor &&
	    !radeon_glamor_create_textured_pixmap(pixmap,
						  radeon_get_pixmap_private(pixmap))) {
		pScreen->DestroyPixmap(pixmap);
	  	return NULL;
	}

	return pixmap;
}

static void drmmode_destroy_bo_pixmap(PixmapPtr pixmap)
{
	ScreenPtr pScreen = pixmap->drawable.pScreen;

	(*pScreen->DestroyPixmap)(pixmap);
}

static void
drmmode_ConvertFromKMode(ScrnInfoPtr	scrn,
		     drmModeModeInfo *kmode,
		     DisplayModePtr	mode)
{
	memset(mode, 0, sizeof(DisplayModeRec));
	mode->status = MODE_OK;

	mode->Clock = kmode->clock;

	mode->HDisplay = kmode->hdisplay;
	mode->HSyncStart = kmode->hsync_start;
	mode->HSyncEnd = kmode->hsync_end;
	mode->HTotal = kmode->htotal;
	mode->HSkew = kmode->hskew;

	mode->VDisplay = kmode->vdisplay;
	mode->VSyncStart = kmode->vsync_start;
	mode->VSyncEnd = kmode->vsync_end;
	mode->VTotal = kmode->vtotal;
	mode->VScan = kmode->vscan;

	mode->Flags = kmode->flags; //& FLAG_BITS;
	mode->name = strdup(kmode->name);

	if (kmode->type & DRM_MODE_TYPE_DRIVER)
		mode->type = M_T_DRIVER;
	if (kmode->type & DRM_MODE_TYPE_PREFERRED)
		mode->type |= M_T_PREFERRED;
	xf86SetModeCrtc (mode, scrn->adjustFlags);
}

static void
drmmode_ConvertToKMode(ScrnInfoPtr	scrn,
		     drmModeModeInfo *kmode,
		     DisplayModePtr	mode)
{
	memset(kmode, 0, sizeof(*kmode));

	kmode->clock = mode->Clock;
	kmode->hdisplay = mode->HDisplay;
	kmode->hsync_start = mode->HSyncStart;
	kmode->hsync_end = mode->HSyncEnd;
	kmode->htotal = mode->HTotal;
	kmode->hskew = mode->HSkew;

	kmode->vdisplay = mode->VDisplay;
	kmode->vsync_start = mode->VSyncStart;
	kmode->vsync_end = mode->VSyncEnd;
	kmode->vtotal = mode->VTotal;
	kmode->vscan = mode->VScan;

	kmode->flags = mode->Flags; //& FLAG_BITS;
	if (mode->name)
		strncpy(kmode->name, mode->name, DRM_DISPLAY_MODE_LEN);
	kmode->name[DRM_DISPLAY_MODE_LEN-1] = 0;

}

/*
 * Retrieves present time in microseconds that is compatible
 * with units used by vblank timestamps. Depending on the kernel
 * version and DRM kernel module configuration, the vblank
 * timestamp can either be in real time or monotonic time
 */
int drmmode_get_current_ust(int drm_fd, CARD64 *ust)
{
	uint64_t cap_value;
	int ret;
	struct timespec now;

	ret = drmGetCap(drm_fd, DRM_CAP_TIMESTAMP_MONOTONIC, &cap_value);
	if (ret || !cap_value)
		/* old kernel or drm_timestamp_monotonic turned off */
		ret = clock_gettime(CLOCK_REALTIME, &now);
	else
		ret = clock_gettime(CLOCK_MONOTONIC, &now);
	if (ret)
		return ret;
	*ust = ((CARD64)now.tv_sec * 1000000) + ((CARD64)now.tv_nsec / 1000);
	return 0;
}

/*
 * Get current frame count and frame count timestamp of the crtc.
 */
int drmmode_crtc_get_ust_msc(xf86CrtcPtr crtc, CARD64 *ust, CARD64 *msc)
{
    ScrnInfoPtr scrn = crtc->scrn;
    RADEONInfoPtr info = RADEONPTR(scrn);
    drmVBlank vbl;
    int ret;

    vbl.request.type = DRM_VBLANK_RELATIVE;
    vbl.request.type |= radeon_populate_vbl_request_type(crtc);
    vbl.request.sequence = 0;

    ret = drmWaitVBlank(info->dri2.drm_fd, &vbl);
    if (ret) {
	xf86DrvMsg(scrn->scrnIndex, X_WARNING,
		   "get vblank counter failed: %s\n", strerror(errno));
	return ret;
    }

    *ust = ((CARD64)vbl.reply.tval_sec * 1000000) + vbl.reply.tval_usec;
    *msc = vbl.reply.sequence;

    return Success;
}

static void
drmmode_do_crtc_dpms(xf86CrtcPtr crtc, int mode)
{
	drmmode_crtc_private_ptr drmmode_crtc = crtc->driver_private;
	ScrnInfoPtr scrn = crtc->scrn;
	RADEONInfoPtr info = RADEONPTR(scrn);
	CARD64 ust;
	int ret;

	drmmode_crtc->pending_dpms_mode = mode;

	if (drmmode_crtc->dpms_mode == DPMSModeOn && mode != DPMSModeOn) {
		drmVBlank vbl;

		/* Wait for any pending flip to finish */
		if (drmmode_crtc->flip_pending)
			return;

		/*
		 * On->Off transition: record the last vblank time,
		 * sequence number and frame period.
		 */
		vbl.request.type = DRM_VBLANK_RELATIVE;
		vbl.request.type |= radeon_populate_vbl_request_type(crtc);
		vbl.request.sequence = 0;
		ret = drmWaitVBlank(info->dri2.drm_fd, &vbl);
		if (ret)
			xf86DrvMsg(scrn->scrnIndex, X_ERROR,
				   "%s cannot get last vblank counter\n",
				   __func__);
		else {
			CARD64 seq = (CARD64)vbl.reply.sequence;
			CARD64 nominal_frame_rate, pix_in_frame;

			ust = ((CARD64)vbl.reply.tval_sec * 1000000) +
				vbl.reply.tval_usec;
			drmmode_crtc->dpms_last_ust = ust;
			drmmode_crtc->dpms_last_seq = seq;
			nominal_frame_rate = crtc->mode.Clock;
			nominal_frame_rate *= 1000;
			pix_in_frame = crtc->mode.HTotal * crtc->mode.VTotal;
			if (nominal_frame_rate == 0 || pix_in_frame == 0)
				nominal_frame_rate = DEFAULT_NOMINAL_FRAME_RATE;
			else
				nominal_frame_rate /= pix_in_frame;
			drmmode_crtc->dpms_last_fps = nominal_frame_rate;
		}
	} else if (drmmode_crtc->dpms_mode != DPMSModeOn && mode == DPMSModeOn) {
		/*
		 * Off->On transition: calculate and accumulate the
		 * number of interpolated vblanks while we were in Off state
		 */
		ret = drmmode_get_current_ust(info->dri2.drm_fd, &ust);
		if (ret)
			xf86DrvMsg(scrn->scrnIndex, X_ERROR,
				   "%s cannot get current time\n", __func__);
		else if (drmmode_crtc->dpms_last_ust) {
			CARD64 time_elapsed, delta_seq;
			time_elapsed = ust - drmmode_crtc->dpms_last_ust;
			delta_seq = time_elapsed * drmmode_crtc->dpms_last_fps;
			delta_seq /= 1000000;
			drmmode_crtc->interpolated_vblanks += delta_seq;

		}
	}
	drmmode_crtc->dpms_mode = mode;
}

static void
drmmode_crtc_dpms(xf86CrtcPtr crtc, int mode)
{
	drmmode_crtc_private_ptr drmmode_crtc = crtc->driver_private;
	drmmode_ptr drmmode = drmmode_crtc->drmmode;

	/* Disable unused CRTCs */
	if (!crtc->enabled || mode != DPMSModeOn) {
		/* Wait for any pending flip to finish */
		if (drmmode_crtc->flip_pending)
			return;

		drmModeSetCrtc(drmmode->fd, drmmode_crtc->mode_crtc->crtc_id,
			       0, 0, 0, NULL, 0, NULL);
	} else if (drmmode_crtc->dpms_mode != DPMSModeOn)
		crtc->funcs->set_mode_major(crtc, &crtc->mode, crtc->rotation,
					    crtc->x, crtc->y);
}

#if GET_ABI_MAJOR(ABI_VIDEODRV_VERSION) >= 10

static PixmapPtr
create_pixmap_for_fbcon(drmmode_ptr drmmode,
			ScrnInfoPtr pScrn, int fbcon_id)
{
	RADEONInfoPtr info = RADEONPTR(pScrn);
	PixmapPtr pixmap = info->fbcon_pixmap;
	struct radeon_bo *bo;
	drmModeFBPtr fbcon;
	struct drm_gem_flink flink;

	if (pixmap)
	    return pixmap;

	fbcon = drmModeGetFB(drmmode->fd, fbcon_id);
	if (fbcon == NULL)
		return NULL;

	if (fbcon->depth != pScrn->depth ||
	    fbcon->width != pScrn->virtualX ||
	    fbcon->height != pScrn->virtualY)
		goto out_free_fb;

	flink.handle = fbcon->handle;
	if (ioctl(drmmode->fd, DRM_IOCTL_GEM_FLINK, &flink) < 0) {
		xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
			   "Couldn't flink fbcon handle\n");
		goto out_free_fb;
	}

	bo = radeon_bo_open(drmmode->bufmgr, flink.name, 0, 0, 0, 0);
	if (bo == NULL) {
		xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
			   "Couldn't allocate bo for fbcon handle\n");
		goto out_free_fb;
	}

	pixmap = drmmode_create_bo_pixmap(pScrn, fbcon->width, fbcon->height,
					  fbcon->depth, fbcon->bpp, fbcon->pitch,
					  bo, NULL);
	info->fbcon_pixmap = pixmap;
	radeon_bo_unref(bo);
out_free_fb:
	drmModeFreeFB(fbcon);
	return pixmap;
}

static void
destroy_pixmap_for_fbcon(ScrnInfoPtr pScrn)
{
	RADEONInfoPtr info = RADEONPTR(pScrn);

	/* XXX: The current GPUVM support in the kernel doesn't allow removing
	 * the virtual address range for this BO, so we need to keep around
	 * the pixmap to avoid breaking glamor with GPUVM
	 */
	if (info->use_glamor && info->ChipFamily >= CHIP_FAMILY_CAYMAN)
		return;

	if (info->fbcon_pixmap)
		pScrn->pScreen->DestroyPixmap(info->fbcon_pixmap);
	info->fbcon_pixmap = NULL;
}

void drmmode_copy_fb(ScrnInfoPtr pScrn, drmmode_ptr drmmode)
{
	xf86CrtcConfigPtr   xf86_config = XF86_CRTC_CONFIG_PTR(pScrn);
	RADEONInfoPtr info = RADEONPTR(pScrn);
	PixmapPtr src, dst;
	ScreenPtr pScreen = pScrn->pScreen;
	int fbcon_id = 0;
	Bool force;
	GCPtr gc;
	int i;

	for (i = 0; i < xf86_config->num_crtc; i++) {
		drmmode_crtc_private_ptr drmmode_crtc = xf86_config->crtc[i]->driver_private;

		if (drmmode_crtc->mode_crtc->buffer_id)
			fbcon_id = drmmode_crtc->mode_crtc->buffer_id;
	}

	if (!fbcon_id)
		return;

	if (fbcon_id == drmmode->fb_id) {
		/* in some rare case there might be no fbcon and we might already
		 * be the one with the current fb to avoid a false deadlck in
		 * kernel ttm code just do nothing as anyway there is nothing
		 * to do
		 */
		return;
	}

	src = create_pixmap_for_fbcon(drmmode, pScrn, fbcon_id);
	if (!src)
		return;

	dst = pScreen->GetScreenPixmap(pScreen);

	gc = GetScratchGC(pScrn->depth, pScreen);
	ValidateGC(&dst->drawable, gc);

	force = info->accel_state->force;
	info->accel_state->force = TRUE;
	(*gc->ops->CopyArea)(&src->drawable, &dst->drawable, gc, 0, 0,
			     pScrn->virtualX, pScrn->virtualY, 0, 0);
	info->accel_state->force = force;

	FreeScratchGC(gc);

	radeon_cs_flush_indirect(pScrn);
	radeon_bo_wait(info->front_bo);

	pScreen->canDoBGNoneRoot = TRUE;
	destroy_pixmap_for_fbcon(pScrn);
	return;
}

#endif /* GET_ABI_MAJOR(ABI_VIDEODRV_VERSION) >= 10 */

static void
drmmode_crtc_scanout_destroy(drmmode_ptr drmmode,
			     struct drmmode_scanout *scanout)
{
	if (scanout->pixmap) {
		drmmode_destroy_bo_pixmap(scanout->pixmap);
		scanout->pixmap = NULL;
	}

	if (scanout->bo) {
		drmModeRmFB(drmmode->fd, scanout->fb_id);
		scanout->fb_id = 0;
		radeon_bo_unmap(scanout->bo);
		radeon_bo_unref(scanout->bo);
		scanout->bo = NULL;
	}

	if (scanout->damage) {
		DamageDestroy(scanout->damage);
		scanout->damage = NULL;
	}
}

void
drmmode_scanout_free(ScrnInfoPtr scrn)
{
	xf86CrtcConfigPtr xf86_config = XF86_CRTC_CONFIG_PTR(scrn);
	int c;

	for (c = 0; c < xf86_config->num_crtc; c++) {
		drmmode_crtc_private_ptr drmmode_crtc =
			xf86_config->crtc[c]->driver_private;

		drmmode_crtc_scanout_destroy(drmmode_crtc->drmmode,
					     &drmmode_crtc->scanout[0]);
		drmmode_crtc_scanout_destroy(drmmode_crtc->drmmode,
					     &drmmode_crtc->scanout[1]);
	}
}

static void *
drmmode_crtc_scanout_allocate(xf86CrtcPtr crtc,
			      struct drmmode_scanout *scanout,
			      int width, int height)
{
	ScrnInfoPtr pScrn = crtc->scrn;
	RADEONInfoPtr info = RADEONPTR(pScrn);
	drmmode_crtc_private_ptr drmmode_crtc = crtc->driver_private;
	drmmode_ptr drmmode = drmmode_crtc->drmmode;
	struct radeon_surface surface;
	uint32_t tiling = RADEON_CREATE_PIXMAP_TILING_MACRO;
	int ret;
	int pitch;

	if (scanout->bo) {
		if (scanout->width == width && scanout->height == height)
			return scanout->bo->ptr;

		drmmode_crtc_scanout_destroy(drmmode, scanout);
	}

	if (info->ChipFamily >= CHIP_FAMILY_R600)
		tiling |= RADEON_CREATE_PIXMAP_TILING_MICRO;
	scanout->bo = radeon_alloc_pixmap_bo(pScrn, width, height, pScrn->depth,
					     tiling, pScrn->bitsPerPixel,
					     &pitch, &surface, &tiling);
	if (scanout->bo == NULL)
		return NULL;

	radeon_bo_map(scanout->bo, 1);

	ret = drmModeAddFB(drmmode->fd, width, height, pScrn->depth,
			   pScrn->bitsPerPixel, pitch,
			   scanout->bo->handle,
			   &scanout->fb_id);
	if (ret) {
		ErrorF("failed to add scanout fb\n");
		radeon_bo_unref(scanout->bo);
		scanout->bo = NULL;
		return NULL;
	}

	scanout->width = width;
	scanout->height = height;
	return scanout->bo->ptr;
}

static PixmapPtr
drmmode_crtc_scanout_create(xf86CrtcPtr crtc, struct drmmode_scanout *scanout,
			    int width, int height)
{
	ScrnInfoPtr pScrn = crtc->scrn;
	drmmode_crtc_private_ptr drmmode_crtc = crtc->driver_private;
	drmmode_ptr drmmode = drmmode_crtc->drmmode;

	if (scanout->pixmap) {
		if (scanout->width == width && scanout->height == height)
			return scanout->pixmap;

		drmmode_crtc_scanout_destroy(drmmode, scanout);
	}

	if (!scanout->bo) {
		if (!drmmode_crtc_scanout_allocate(crtc, scanout, width, height))
			return NULL;
	}

	scanout->pixmap = drmmode_create_bo_pixmap(pScrn,
						 width, height,
						 pScrn->depth,
						 pScrn->bitsPerPixel,
						 -1, scanout->bo, NULL);
	if (scanout->pixmap == NULL)
		xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
			   "Couldn't allocate scanout pixmap for CRTC\n");

	return scanout->pixmap;
}

static void
radeon_screen_damage_report(DamagePtr damage, RegionPtr region, void *closure)
{
	/* Only keep track of the extents */
	RegionUninit(&damage->damage);
	damage->damage.data = NULL;
}

static Bool
drmmode_can_use_hw_cursor(xf86CrtcPtr crtc)
{
	RADEONInfoPtr info = RADEONPTR(crtc->scrn);

	/* Check for Option "SWcursor" */
	if (xf86ReturnOptValBool(info->Options, OPTION_SW_CURSOR, FALSE))
		return FALSE;

	/* Fall back to SW cursor if the CRTC is transformed */
	if (crtc->transformPresent)
		return FALSE;

#if XF86_CRTC_VERSION >= 4
	/* Xorg doesn't correctly handle cursor position transform in the
	 * rotation case
	 */
	if (crtc->driverIsPerformingTransform &&
	    (crtc->rotation & 0xf) != RR_Rotate_0)
		return FALSE;
#endif

#ifdef RADEON_PIXMAP_SHARING
	/* HW cursor not supported yet with RandR 1.4 multihead */
	if (!xorg_list_is_empty(&crtc->scrn->pScreen->pixmap_dirty_list))
		return FALSE;
#endif

	return TRUE;
}

#if XF86_CRTC_VERSION >= 4

static Bool
drmmode_handle_transform(xf86CrtcPtr crtc)
{
	RADEONInfoPtr info = RADEONPTR(crtc->scrn);
	Bool ret;

	crtc->driverIsPerformingTransform = info->tear_free &&
		!crtc->transformPresent && crtc->rotation != RR_Rotate_0;

	ret = xf86CrtcRotate(crtc);

	crtc->driverIsPerformingTransform &= ret && crtc->transform_in_use;

	return ret;
}

#else

static Bool
drmmode_handle_transform(xf86CrtcPtr crtc)
{
	return xf86CrtcRotate(crtc);
}

#endif

static Bool
drmmode_set_mode_major(xf86CrtcPtr crtc, DisplayModePtr mode,
		     Rotation rotation, int x, int y)
{
	ScrnInfoPtr pScrn = crtc->scrn;
	ScreenPtr pScreen = pScrn->pScreen;
	RADEONInfoPtr info = RADEONPTR(pScrn);
	xf86CrtcConfigPtr   xf86_config = XF86_CRTC_CONFIG_PTR(crtc->scrn);
	drmmode_crtc_private_ptr drmmode_crtc = crtc->driver_private;
	drmmode_ptr drmmode = drmmode_crtc->drmmode;
	int saved_x, saved_y;
	Rotation saved_rotation;
	DisplayModeRec saved_mode;
	uint32_t *output_ids = NULL;
	int output_count = 0;
	Bool ret = TRUE;
	int i;
	int fb_id;
	drmModeModeInfo kmode;
	int pitch;
	uint32_t tiling_flags = 0;

	if (info->allowColorTiling) {
		if (info->ChipFamily >= CHIP_FAMILY_R600)
			tiling_flags |= RADEON_TILING_MICRO;
		else
			tiling_flags |= RADEON_TILING_MACRO;
	}

	pitch = RADEON_ALIGN(pScrn->displayWidth, drmmode_get_pitch_align(pScrn, info->pixel_bytes, tiling_flags)) *
		info->pixel_bytes;
	if (info->ChipFamily >= CHIP_FAMILY_R600) {
		pitch = info->front_surface.level[0].pitch_bytes;
	}

	if (drmmode->fb_id == 0) {
		ret = drmModeAddFB(drmmode->fd,
				   pScrn->virtualX, pScrn->virtualY,
                                   pScrn->depth, pScrn->bitsPerPixel,
				   pitch,
				   info->front_bo->handle,
                                   &drmmode->fb_id);
                if (ret < 0) {
                        ErrorF("failed to add fb\n");
                        return FALSE;
                }
        }

	saved_mode = crtc->mode;
	saved_x = crtc->x;
	saved_y = crtc->y;
	saved_rotation = crtc->rotation;

	if (mode) {
		crtc->mode = *mode;
		crtc->x = x;
		crtc->y = y;
		crtc->rotation = rotation;

		output_ids = calloc(sizeof(uint32_t), xf86_config->num_output);
		if (!output_ids) {
			ret = FALSE;
			goto done;
		}

		for (i = 0; i < xf86_config->num_output; i++) {
			xf86OutputPtr output = xf86_config->output[i];
			drmmode_output_private_ptr drmmode_output;

			if (output->crtc != crtc)
				continue;

			drmmode_output = output->driver_private;
			output_ids[output_count] = drmmode_output->mode_output->connector_id;
			output_count++;
		}

		if (!drmmode_handle_transform(crtc))
			goto done;

		crtc->funcs->gamma_set(crtc, crtc->gamma_red, crtc->gamma_green,
				       crtc->gamma_blue, crtc->gamma_size);

		drmmode_ConvertToKMode(crtc->scrn, &kmode, mode);

		fb_id = drmmode->fb_id;
#ifdef RADEON_PIXMAP_SHARING
		if (crtc->randr_crtc && crtc->randr_crtc->scanout_pixmap) {
			x = drmmode_crtc->prime_pixmap_x;
			y = 0;

			drmmode_crtc_scanout_destroy(drmmode, &drmmode_crtc->scanout[0]);
			drmmode_crtc_scanout_destroy(drmmode, &drmmode_crtc->scanout[1]);
		} else
#endif
		if (drmmode_crtc->rotate.fb_id) {
			fb_id = drmmode_crtc->rotate.fb_id;
			x = y = 0;

			drmmode_crtc_scanout_destroy(drmmode, &drmmode_crtc->scanout[0]);
			drmmode_crtc_scanout_destroy(drmmode, &drmmode_crtc->scanout[1]);
		} else if (info->tear_free ||
#if XF86_CRTC_VERSION >= 4
			   crtc->driverIsPerformingTransform ||
#endif
			   info->shadow_primary) {
			for (i = 0; i < (info->tear_free ? 2 : 1); i++) {
				drmmode_crtc_scanout_create(crtc,
							    &drmmode_crtc->scanout[i],
							    mode->HDisplay,
							    mode->VDisplay);

				if (drmmode_crtc->scanout[i].pixmap) {
					RegionPtr pRegion;
					BoxPtr pBox;

					if (!drmmode_crtc->scanout[i].damage) {
						drmmode_crtc->scanout[i].damage =
							DamageCreate(radeon_screen_damage_report,
								     NULL, DamageReportRawRegion,
								     TRUE, pScreen, NULL);
						DamageRegister(&pScreen->GetScreenPixmap(pScreen)->drawable,
							       drmmode_crtc->scanout[i].damage);
					}

					pRegion = DamageRegion(drmmode_crtc->scanout[i].damage);
					RegionUninit(pRegion);
					pRegion->data = NULL;
					pBox = RegionExtents(pRegion);
					pBox->x1 = min(pBox->x1, x);
					pBox->y1 = min(pBox->y1, y);

					switch (crtc->rotation & 0xf) {
					case RR_Rotate_90:
					case RR_Rotate_270:
						pBox->x2 = max(pBox->x2, x + mode->VDisplay);
						pBox->y2 = max(pBox->y2, y + mode->HDisplay);
						break;
					default:
						pBox->x2 = max(pBox->x2, x + mode->HDisplay);
						pBox->y2 = max(pBox->y2, y + mode->VDisplay);
					}
				}
			}

			if (drmmode_crtc->scanout[0].pixmap &&
			    (!info->tear_free || drmmode_crtc->scanout[1].pixmap)) {
				drmmode_crtc->scanout_id = 0;
				fb_id = drmmode_crtc->scanout[0].fb_id;
				x = y = 0;

				radeon_scanout_update_handler(crtc, 0, 0, drmmode_crtc);
				radeon_bo_wait(drmmode_crtc->scanout[0].bo);
			}
		}

		/* Wait for any pending flip to finish */
		do {} while (drmmode_crtc->flip_pending &&
			     drmHandleEvent(drmmode->fd,
					    &drmmode->event_context) > 0);

		if (drmModeSetCrtc(drmmode->fd,
				   drmmode_crtc->mode_crtc->crtc_id,
				   fb_id, x, y, output_ids,
				   output_count, &kmode) != 0) {
			xf86DrvMsg(crtc->scrn->scrnIndex, X_ERROR,
				   "failed to set mode: %s", strerror(errno));
			ret = FALSE;
			goto done;
		} else
			ret = TRUE;

		if (pScreen)
			xf86CrtcSetScreenSubpixelOrder(pScreen);

		drmmode_crtc->need_modeset = FALSE;

		/* go through all the outputs and force DPMS them back on? */
		for (i = 0; i < xf86_config->num_output; i++) {
			xf86OutputPtr output = xf86_config->output[i];

			if (output->crtc != crtc)
				continue;

			output->funcs->dpms(output, DPMSModeOn);
		}
	}

	/* Compute index of this CRTC into xf86_config->crtc */
	for (i = 0; i < xf86_config->num_crtc; i++) {
		if (xf86_config->crtc[i] != crtc)
			continue;

		if (!crtc->enabled || drmmode_can_use_hw_cursor(crtc))
			info->hwcursor_disabled &= ~(1 << i);
		else
			info->hwcursor_disabled |= 1 << i;

		break;
	}

#ifndef HAVE_XF86_CURSOR_RESET_CURSOR
	if (!info->hwcursor_disabled)
		xf86_reload_cursors(pScreen);
#endif

done:
	if (!ret) {
		crtc->x = saved_x;
		crtc->y = saved_y;
		crtc->rotation = saved_rotation;
		crtc->mode = saved_mode;
	} else
		crtc->active = TRUE;

	free(output_ids);

	return ret;
}

static void
drmmode_set_cursor_colors (xf86CrtcPtr crtc, int bg, int fg)
{

}

static void
drmmode_set_cursor_position (xf86CrtcPtr crtc, int x, int y)
{
	drmmode_crtc_private_ptr drmmode_crtc = crtc->driver_private;
	drmmode_ptr drmmode = drmmode_crtc->drmmode;

#if XF86_CRTC_VERSION >= 4
	if (crtc->driverIsPerformingTransform) {
		x += crtc->x;
		y += crtc->y;
		xf86CrtcTransformCursorPos(crtc, &x, &y);
	}
#endif

	drmModeMoveCursor(drmmode->fd, drmmode_crtc->mode_crtc->crtc_id, x, y);
}

#if XF86_CRTC_VERSION >= 4

static int
drmmode_cursor_src_offset(Rotation rotation, int width, int height,
			  int x_dst, int y_dst)
{
	int t;

	switch (rotation & 0xf) {
	case RR_Rotate_90:
		t = x_dst;
		x_dst = height - y_dst - 1;
		y_dst = t;
		break;
	case RR_Rotate_180:
		x_dst = width - x_dst - 1;
		y_dst = height - y_dst - 1;
		break;
	case RR_Rotate_270:
		t = x_dst;
		x_dst = y_dst;
		y_dst = width - t - 1;
		break;
	}

	if (rotation & RR_Reflect_X)
		x_dst = width - x_dst - 1;
	if (rotation & RR_Reflect_Y)
		y_dst = height - y_dst - 1;

	return y_dst * height + x_dst;
}

#endif

static void
drmmode_load_cursor_argb (xf86CrtcPtr crtc, CARD32 *image)
{
	ScrnInfoPtr pScrn = crtc->scrn;
	RADEONInfoPtr info = RADEONPTR(pScrn);
	drmmode_crtc_private_ptr drmmode_crtc = crtc->driver_private;
	uint32_t *ptr;

	/* cursor should be mapped already */
	ptr = (uint32_t *)(drmmode_crtc->cursor_bo->ptr);

#if XF86_CRTC_VERSION >= 4
	if (crtc->driverIsPerformingTransform) {
		uint32_t cursor_w = info->cursor_w, cursor_h = info->cursor_h;
		int dstx, dsty;
		int srcoffset;

		for (dsty = 0; dsty < cursor_h; dsty++) {
			for (dstx = 0; dstx < cursor_w; dstx++) {
				srcoffset = drmmode_cursor_src_offset(crtc->rotation,
								      cursor_w,
								      cursor_h,
								      dstx, dsty);

				ptr[dsty * info->cursor_w + dstx] =
					cpu_to_le32(image[srcoffset]);
			}
		}
	} else
#endif
	{
		uint32_t cursor_size = info->cursor_w * info->cursor_h;
		int i;

		for (i = 0; i < cursor_size; i++)
			ptr[i] = cpu_to_le32(image[i]);
	}
}

#if XORG_VERSION_CURRENT >= XORG_VERSION_NUMERIC(1,15,99,903,0)

static Bool drmmode_load_cursor_argb_check(xf86CrtcPtr crtc, CARD32 * image)
{
	if (!drmmode_can_use_hw_cursor(crtc))
		return FALSE;

	drmmode_load_cursor_argb(crtc, image);
	return TRUE;
}

#endif

static void
drmmode_hide_cursor (xf86CrtcPtr crtc)
{
	ScrnInfoPtr pScrn = crtc->scrn;
	RADEONInfoPtr info = RADEONPTR(pScrn);
	drmmode_crtc_private_ptr drmmode_crtc = crtc->driver_private;
	drmmode_ptr drmmode = drmmode_crtc->drmmode;

	drmModeSetCursor(drmmode->fd, drmmode_crtc->mode_crtc->crtc_id, 0,
			 info->cursor_w, info->cursor_h);

}

static void
drmmode_show_cursor (xf86CrtcPtr crtc)
{
	ScrnInfoPtr pScrn = crtc->scrn;
	RADEONInfoPtr info = RADEONPTR(pScrn);
	drmmode_crtc_private_ptr drmmode_crtc = crtc->driver_private;
	drmmode_ptr drmmode = drmmode_crtc->drmmode;
	uint32_t handle = drmmode_crtc->cursor_bo->handle;
	static Bool use_set_cursor2 = TRUE;

	if (use_set_cursor2) {
	    xf86CrtcConfigPtr xf86_config = XF86_CRTC_CONFIG_PTR(crtc->scrn);
	    CursorPtr cursor = xf86_config->cursor;
	    int ret;

	    ret =
		drmModeSetCursor2(drmmode->fd, drmmode_crtc->mode_crtc->crtc_id,
				  handle, info->cursor_w, info->cursor_h,
				  cursor->bits->xhot, cursor->bits->yhot);
	    if (ret == -EINVAL)
		use_set_cursor2 = FALSE;
	    else
		return;
	}

	drmModeSetCursor(drmmode->fd, drmmode_crtc->mode_crtc->crtc_id, handle,
			 info->cursor_w, info->cursor_h);
}

static void *
drmmode_crtc_shadow_allocate(xf86CrtcPtr crtc, int width, int height)
{
	drmmode_crtc_private_ptr drmmode_crtc = crtc->driver_private;

	return drmmode_crtc_scanout_allocate(crtc, &drmmode_crtc->rotate,
					     width, height);
}

static PixmapPtr
drmmode_crtc_shadow_create(xf86CrtcPtr crtc, void *data, int width, int height)
{
	drmmode_crtc_private_ptr drmmode_crtc = crtc->driver_private;

	/* Xorg passes in the return value of drmmode_crtc_shadow_allocate
	 * for data, but that's redundant for drmmode_crtc_scanout_create.
	 */
	return drmmode_crtc_scanout_create(crtc, &drmmode_crtc->rotate, width,
					   height);
}

static void
drmmode_crtc_shadow_destroy(xf86CrtcPtr crtc, PixmapPtr rotate_pixmap, void *data)
{
	drmmode_crtc_private_ptr drmmode_crtc = crtc->driver_private;
	drmmode_ptr drmmode = drmmode_crtc->drmmode;

	drmmode_crtc_scanout_destroy(drmmode, &drmmode_crtc->rotate);
}

static void
drmmode_crtc_gamma_set(xf86CrtcPtr crtc, uint16_t *red, uint16_t *green,
                      uint16_t *blue, int size)
{
	drmmode_crtc_private_ptr drmmode_crtc = crtc->driver_private;
	drmmode_ptr drmmode = drmmode_crtc->drmmode;

	drmModeCrtcSetGamma(drmmode->fd, drmmode_crtc->mode_crtc->crtc_id,
			    size, red, green, blue);
}

#ifdef RADEON_PIXMAP_SHARING
static Bool
drmmode_set_scanout_pixmap(xf86CrtcPtr crtc, PixmapPtr ppix)
{
	ScreenPtr screen = xf86ScrnToScreen(crtc->scrn);
	PixmapPtr screenpix = screen->GetScreenPixmap(screen);
	xf86CrtcConfigPtr xf86_config = XF86_CRTC_CONFIG_PTR(crtc->scrn);
	drmmode_crtc_private_ptr drmmode_crtc = crtc->driver_private;
	int c, total_width = 0, max_height = 0, this_x = 0;

	if (!ppix) {
		if (crtc->randr_crtc->scanout_pixmap)
			PixmapStopDirtyTracking(crtc->randr_crtc->scanout_pixmap, screenpix);
		drmmode_crtc->prime_pixmap_x = 0;
		return TRUE;
	}

	/* iterate over all the attached crtcs -
	   work out bounding box */
	for (c = 0; c < xf86_config->num_crtc; c++) {
		xf86CrtcPtr iter = xf86_config->crtc[c];
		if (!iter->enabled && iter != crtc)
			continue;
		if (iter == crtc) {
			this_x = total_width;
			total_width += ppix->drawable.width;
			if (max_height < ppix->drawable.height)
				max_height = ppix->drawable.height;
		} else {
			total_width += iter->mode.HDisplay;
			if (max_height < iter->mode.VDisplay)
				max_height = iter->mode.VDisplay;
		}
#if !defined(HAS_DIRTYTRACKING_ROTATION) && !defined(HAS_DIRTYTRACKING2)
		if (iter != crtc) {
			ErrorF("Cannot do multiple crtcs without X server dirty tracking 2 interface\n");
			return FALSE;
		}
#endif
	}

	if (total_width != screenpix->drawable.width ||
	    max_height != screenpix->drawable.height) {
		Bool ret;
		ret = drmmode_xf86crtc_resize(crtc->scrn, total_width, max_height);
		if (ret == FALSE)
			return FALSE;

		screenpix = screen->GetScreenPixmap(screen);
		screen->width = screenpix->drawable.width = total_width;
		screen->height = screenpix->drawable.height = max_height;
	}
	drmmode_crtc->prime_pixmap_x = this_x;
#ifdef HAS_DIRTYTRACKING_ROTATION
	PixmapStartDirtyTracking(ppix, screenpix, 0, 0, this_x, 0, RR_Rotate_0);
#elif defined(HAS_DIRTYTRACKING2)
	PixmapStartDirtyTracking2(ppix, screenpix, 0, 0, this_x, 0);
#else
	PixmapStartDirtyTracking(ppix, screenpix, 0, 0);
#endif
	return TRUE;
}
#endif

static xf86CrtcFuncsRec drmmode_crtc_funcs = {
    .dpms = drmmode_crtc_dpms,
    .set_mode_major = drmmode_set_mode_major,
    .set_cursor_colors = drmmode_set_cursor_colors,
    .set_cursor_position = drmmode_set_cursor_position,
    .show_cursor = drmmode_show_cursor,
    .hide_cursor = drmmode_hide_cursor,
    .load_cursor_argb = drmmode_load_cursor_argb,
#if XORG_VERSION_CURRENT >= XORG_VERSION_NUMERIC(1,15,99,903,0)
    .load_cursor_argb_check = drmmode_load_cursor_argb_check,
#endif

    .gamma_set = drmmode_crtc_gamma_set,
    .shadow_create = drmmode_crtc_shadow_create,
    .shadow_allocate = drmmode_crtc_shadow_allocate,
    .shadow_destroy = drmmode_crtc_shadow_destroy,
    .destroy = NULL, /* XXX */
#ifdef RADEON_PIXMAP_SHARING
    .set_scanout_pixmap = drmmode_set_scanout_pixmap,
#endif
};

int drmmode_get_crtc_id(xf86CrtcPtr crtc)
{
	drmmode_crtc_private_ptr drmmode_crtc = crtc->driver_private;
	return drmmode_crtc->hw_id;
}

void drmmode_crtc_hw_id(xf86CrtcPtr crtc)
{
	drmmode_crtc_private_ptr drmmode_crtc = crtc->driver_private;
	ScrnInfoPtr pScrn = crtc->scrn;
	RADEONInfoPtr info = RADEONPTR(pScrn);
	struct drm_radeon_info ginfo;
	int r;
	uint32_t tmp;

	memset(&ginfo, 0, sizeof(ginfo));
	ginfo.request = 0x4;
	tmp = drmmode_crtc->mode_crtc->crtc_id;
	ginfo.value = (uintptr_t)&tmp;
	r = drmCommandWriteRead(info->dri2.drm_fd, DRM_RADEON_INFO, &ginfo, sizeof(ginfo));
	if (r) {
		drmmode_crtc->hw_id = -1;
		return;
	}
	drmmode_crtc->hw_id = tmp;
}

static unsigned int
drmmode_crtc_init(ScrnInfoPtr pScrn, drmmode_ptr drmmode, drmModeResPtr mode_res, int num)
{
	xf86CrtcPtr crtc;
	drmmode_crtc_private_ptr drmmode_crtc;
	RADEONEntPtr pRADEONEnt = RADEONEntPriv(pScrn);

	crtc = xf86CrtcCreate(pScrn, &drmmode_crtc_funcs);
	if (crtc == NULL)
		return 0;

	drmmode_crtc = xnfcalloc(sizeof(drmmode_crtc_private_rec), 1);
	drmmode_crtc->mode_crtc = drmModeGetCrtc(drmmode->fd, mode_res->crtcs[num]);
	drmmode_crtc->drmmode = drmmode;
	drmmode_crtc->dpms_mode = DPMSModeOff;
	drmmode_crtc->pending_dpms_mode = DPMSModeOff;
	crtc->driver_private = drmmode_crtc;
	drmmode_crtc_hw_id(crtc);

	/* Mark num'th crtc as in use on this device. */
	pRADEONEnt->assigned_crtcs |= (1 << num);
	xf86DrvMsgVerb(pScrn->scrnIndex, X_INFO, RADEON_LOGLEVEL_DEBUG,
		       "Allocated crtc nr. %d to this screen.\n", num);

	return 1;
}

static xf86OutputStatus
drmmode_output_detect(xf86OutputPtr output)
{
	/* go to the hw and retrieve a new output struct */
	drmmode_output_private_ptr drmmode_output = output->driver_private;
	drmmode_ptr drmmode = drmmode_output->drmmode;
	xf86OutputStatus status;
	drmModeFreeConnector(drmmode_output->mode_output);

	drmmode_output->mode_output = drmModeGetConnector(drmmode->fd, drmmode_output->output_id);
	if (!drmmode_output->mode_output)
		return XF86OutputStatusDisconnected;

	switch (drmmode_output->mode_output->connection) {
	case DRM_MODE_CONNECTED:
		status = XF86OutputStatusConnected;
		break;
	case DRM_MODE_DISCONNECTED:
		status = XF86OutputStatusDisconnected;
		break;
	default:
	case DRM_MODE_UNKNOWNCONNECTION:
		status = XF86OutputStatusUnknown;
		break;
	}
	return status;
}

static Bool
drmmode_output_mode_valid(xf86OutputPtr output, DisplayModePtr pModes)
{
	return MODE_OK;
}

static DisplayModePtr
drmmode_output_get_modes(xf86OutputPtr output)
{
	drmmode_output_private_ptr drmmode_output = output->driver_private;
	drmModeConnectorPtr koutput = drmmode_output->mode_output;
	drmmode_ptr drmmode = drmmode_output->drmmode;
	int i;
	DisplayModePtr Modes = NULL, Mode;
	drmModePropertyPtr props;
	xf86MonPtr mon = NULL;

	if (!koutput)
		return NULL;

	/* look for an EDID property */
	for (i = 0; i < koutput->count_props; i++) {
		props = drmModeGetProperty(drmmode->fd, koutput->props[i]);
		if (props && (props->flags & DRM_MODE_PROP_BLOB)) {
			if (!strcmp(props->name, "EDID")) {
				if (drmmode_output->edid_blob)
					drmModeFreePropertyBlob(drmmode_output->edid_blob);
				drmmode_output->edid_blob = drmModeGetPropertyBlob(drmmode->fd, koutput->prop_values[i]);
			}
		}
		if (props)
			drmModeFreeProperty(props);
	}

	if (drmmode_output->edid_blob) {
		mon = xf86InterpretEDID(output->scrn->scrnIndex,
					drmmode_output->edid_blob->data);
		if (mon && drmmode_output->edid_blob->length > 128)
			mon->flags |= MONITOR_EDID_COMPLETE_RAWDATA;
	}
	xf86OutputSetEDID(output, mon);

	/* modes should already be available */
	for (i = 0; i < koutput->count_modes; i++) {
		Mode = xnfalloc(sizeof(DisplayModeRec));

		drmmode_ConvertFromKMode(output->scrn, &koutput->modes[i], Mode);
		Modes = xf86ModesAdd(Modes, Mode);

	}
	return Modes;
}

static void
drmmode_output_destroy(xf86OutputPtr output)
{
	drmmode_output_private_ptr drmmode_output = output->driver_private;
	int i;

	if (drmmode_output->edid_blob)
		drmModeFreePropertyBlob(drmmode_output->edid_blob);
	for (i = 0; i < drmmode_output->num_props; i++) {
		drmModeFreeProperty(drmmode_output->props[i].mode_prop);
		free(drmmode_output->props[i].atoms);
	}
	for (i = 0; i < drmmode_output->mode_output->count_encoders; i++) {
		drmModeFreeEncoder(drmmode_output->mode_encoders[i]);
	}
	free(drmmode_output->mode_encoders);
	free(drmmode_output->props);
	drmModeFreeConnector(drmmode_output->mode_output);
	free(drmmode_output);
	output->driver_private = NULL;
}

static void
drmmode_output_dpms(xf86OutputPtr output, int mode)
{
	drmmode_output_private_ptr drmmode_output = output->driver_private;
	xf86CrtcPtr crtc = output->crtc;
	drmModeConnectorPtr koutput = drmmode_output->mode_output;
	drmmode_ptr drmmode = drmmode_output->drmmode;

	if (!koutput)
		return;

	if (mode != DPMSModeOn && crtc) {
		drmmode_crtc_private_ptr drmmode_crtc = crtc->driver_private;

		drmmode_do_crtc_dpms(crtc, mode);

		/* Wait for any pending flip to finish */
		if (drmmode_crtc->flip_pending)
			return;
	}

	drmModeConnectorSetProperty(drmmode->fd, koutput->connector_id,
				    drmmode_output->dpms_enum_id, mode);

	if (mode == DPMSModeOn && crtc) {
	    drmmode_crtc_private_ptr drmmode_crtc = crtc->driver_private;

	    if (drmmode_crtc->need_modeset)
		drmmode_set_mode_major(crtc, &crtc->mode, crtc->rotation, crtc->x,
				       crtc->y);
	    else
		drmmode_do_crtc_dpms(crtc, mode);
	}
}


static Bool
drmmode_property_ignore(drmModePropertyPtr prop)
{
    if (!prop)
	return TRUE;
    /* ignore blob prop */
    if (prop->flags & DRM_MODE_PROP_BLOB)
	return TRUE;
    /* ignore standard property */
    if (!strcmp(prop->name, "EDID") ||
	    !strcmp(prop->name, "DPMS"))
	return TRUE;

    return FALSE;
}

static void
drmmode_output_create_resources(xf86OutputPtr output)
{
    drmmode_output_private_ptr drmmode_output = output->driver_private;
    drmModeConnectorPtr mode_output = drmmode_output->mode_output;
    drmmode_ptr drmmode = drmmode_output->drmmode;
    drmModePropertyPtr drmmode_prop;
    int i, j, err;

    drmmode_output->props = calloc(mode_output->count_props, sizeof(drmmode_prop_rec));
    if (!drmmode_output->props)
	return;
    
    drmmode_output->num_props = 0;
    for (i = 0, j = 0; i < mode_output->count_props; i++) {
	drmmode_prop = drmModeGetProperty(drmmode->fd, mode_output->props[i]);
	if (drmmode_property_ignore(drmmode_prop)) {
	    drmModeFreeProperty(drmmode_prop);
	    continue;
	}
	drmmode_output->props[j].mode_prop = drmmode_prop;
	drmmode_output->props[j].value = mode_output->prop_values[i];
	drmmode_output->num_props++;
	j++;
    }

    for (i = 0; i < drmmode_output->num_props; i++) {
	drmmode_prop_ptr p = &drmmode_output->props[i];
	drmmode_prop = p->mode_prop;

	if (drmmode_prop->flags & DRM_MODE_PROP_RANGE) {
	    INT32 range[2];
	    INT32 value = p->value;

	    p->num_atoms = 1;
	    p->atoms = calloc(p->num_atoms, sizeof(Atom));
	    if (!p->atoms)
		continue;
	    p->atoms[0] = MakeAtom(drmmode_prop->name, strlen(drmmode_prop->name), TRUE);
	    range[0] = drmmode_prop->values[0];
	    range[1] = drmmode_prop->values[1];
	    err = RRConfigureOutputProperty(output->randr_output, p->atoms[0],
		    FALSE, TRUE,
		    drmmode_prop->flags & DRM_MODE_PROP_IMMUTABLE ? TRUE : FALSE,
		    2, range);
	    if (err != 0) {
		xf86DrvMsg(output->scrn->scrnIndex, X_ERROR,
			"RRConfigureOutputProperty error, %d\n", err);
	    }
	    err = RRChangeOutputProperty(output->randr_output, p->atoms[0],
		    XA_INTEGER, 32, PropModeReplace, 1, &value, FALSE, TRUE);
	    if (err != 0) {
		xf86DrvMsg(output->scrn->scrnIndex, X_ERROR,
			"RRChangeOutputProperty error, %d\n", err);
	    }
	} else if (drmmode_prop->flags & DRM_MODE_PROP_ENUM) {
	    p->num_atoms = drmmode_prop->count_enums + 1;
	    p->atoms = calloc(p->num_atoms, sizeof(Atom));
	    if (!p->atoms)
		continue;
	    p->atoms[0] = MakeAtom(drmmode_prop->name, strlen(drmmode_prop->name), TRUE);
	    for (j = 1; j <= drmmode_prop->count_enums; j++) {
		struct drm_mode_property_enum *e = &drmmode_prop->enums[j-1];
		p->atoms[j] = MakeAtom(e->name, strlen(e->name), TRUE);
	    }
	    err = RRConfigureOutputProperty(output->randr_output, p->atoms[0],
		    FALSE, FALSE,
		    drmmode_prop->flags & DRM_MODE_PROP_IMMUTABLE ? TRUE : FALSE,
		    p->num_atoms - 1, (INT32 *)&p->atoms[1]);
	    if (err != 0) {
		xf86DrvMsg(output->scrn->scrnIndex, X_ERROR,
			"RRConfigureOutputProperty error, %d\n", err);
	    }
	    for (j = 0; j < drmmode_prop->count_enums; j++)
		if (drmmode_prop->enums[j].value == p->value)
		    break;
	    /* there's always a matching value */
	    err = RRChangeOutputProperty(output->randr_output, p->atoms[0],
		    XA_ATOM, 32, PropModeReplace, 1, &p->atoms[j+1], FALSE, TRUE);
	    if (err != 0) {
		xf86DrvMsg(output->scrn->scrnIndex, X_ERROR,
			"RRChangeOutputProperty error, %d\n", err);
	    }
	}
    }
}

static Bool
drmmode_output_set_property(xf86OutputPtr output, Atom property,
		RRPropertyValuePtr value)
{
    drmmode_output_private_ptr drmmode_output = output->driver_private;
    drmmode_ptr drmmode = drmmode_output->drmmode;
    int i;

    for (i = 0; i < drmmode_output->num_props; i++) {
	drmmode_prop_ptr p = &drmmode_output->props[i];

	if (p->atoms[0] != property)
	    continue;

	if (p->mode_prop->flags & DRM_MODE_PROP_RANGE) {
	    uint32_t val;

	    if (value->type != XA_INTEGER || value->format != 32 ||
		    value->size != 1)
		return FALSE;
	    val = *(uint32_t *)value->data;

	    drmModeConnectorSetProperty(drmmode->fd, drmmode_output->output_id,
		    p->mode_prop->prop_id, (uint64_t)val);
	    return TRUE;
	} else if (p->mode_prop->flags & DRM_MODE_PROP_ENUM) {
	    Atom	atom;
	    const char	*name;
	    int		j;

	    if (value->type != XA_ATOM || value->format != 32 || value->size != 1)
		return FALSE;
	    memcpy(&atom, value->data, 4);
	    name = NameForAtom(atom);

	    /* search for matching name string, then set its value down */
	    for (j = 0; j < p->mode_prop->count_enums; j++) {
		if (!strcmp(p->mode_prop->enums[j].name, name)) {
		    drmModeConnectorSetProperty(drmmode->fd, drmmode_output->output_id,
			    p->mode_prop->prop_id, p->mode_prop->enums[j].value);
		    return TRUE;
		}
	    }
	}
    }

    return TRUE;
}

static Bool
drmmode_output_get_property(xf86OutputPtr output, Atom property)
{
    return TRUE;
}

static const xf86OutputFuncsRec drmmode_output_funcs = {
    .dpms = drmmode_output_dpms,
    .create_resources = drmmode_output_create_resources,
    .set_property = drmmode_output_set_property,
    .get_property = drmmode_output_get_property,
#if 0

    .save = drmmode_crt_save,
    .restore = drmmode_crt_restore,
    .mode_fixup = drmmode_crt_mode_fixup,
    .prepare = drmmode_output_prepare,
    .mode_set = drmmode_crt_mode_set,
    .commit = drmmode_output_commit,
#endif
    .detect = drmmode_output_detect,
    .mode_valid = drmmode_output_mode_valid,

    .get_modes = drmmode_output_get_modes,
    .destroy = drmmode_output_destroy
};

static int subpixel_conv_table[7] = { 0, SubPixelUnknown,
				      SubPixelHorizontalRGB,
				      SubPixelHorizontalBGR,
				      SubPixelVerticalRGB,
				      SubPixelVerticalBGR,
				      SubPixelNone };

const char *output_names[] = { "None",
			       "VGA",
			       "DVI",
			       "DVI",
			       "DVI",
			       "Composite",
			       "S-video",
			       "LVDS",
			       "CTV",
			       "DIN",
			       "DisplayPort",
			       "HDMI",
			       "HDMI",
			       "TV",
			       "eDP"
};

#define NUM_OUTPUT_NAMES (sizeof(output_names) / sizeof(output_names[0]))

static xf86OutputPtr find_output(ScrnInfoPtr pScrn, int id)
{
	xf86CrtcConfigPtr   xf86_config = XF86_CRTC_CONFIG_PTR(pScrn);
	int i;
	for (i = 0; i < xf86_config->num_output; i++) {
		xf86OutputPtr output = xf86_config->output[i];
		drmmode_output_private_ptr drmmode_output;

		drmmode_output = output->driver_private;
		if (drmmode_output->output_id == id)
			return output;
	}
	return NULL;
}

static int parse_path_blob(drmModePropertyBlobPtr path_blob, int *conn_base_id, char **path)
{
	char *conn;
	char conn_id[5];
	int id, len;
	char *blob_data;

	if (!path_blob)
		return -1;

	blob_data = path_blob->data;
	/* we only handle MST paths for now */
	if (strncmp(blob_data, "mst:", 4))
		return -1;

	conn = strchr(blob_data + 4, '-');
	if (!conn)
		return -1;
	len = conn - (blob_data + 4);
	if (len + 1 > 5)
		return -1;
	memcpy(conn_id, blob_data + 4, len);
	conn_id[len] = '\0';
	id = strtoul(conn_id, NULL, 10);

	*conn_base_id = id;

	*path = conn + 1;
	return 0;
}

static void
drmmode_create_name(ScrnInfoPtr pScrn, drmModeConnectorPtr koutput, char *name,
		    drmModePropertyBlobPtr path_blob, int *num_dvi, int *num_hdmi)
{
	xf86OutputPtr output;
	int conn_id;
	char *extra_path;

	output = NULL;
	if (parse_path_blob(path_blob, &conn_id, &extra_path) == 0)
		output = find_output(pScrn, conn_id);
	if (output) {
		snprintf(name, 32, "%s-%s", output->name, extra_path);
	} else {
		if (koutput->connector_type >= NUM_OUTPUT_NAMES)
			snprintf(name, 32, "Unknown%d-%d", koutput->connector_type,
				 koutput->connector_type_id - 1);
#ifdef RADEON_PIXMAP_SHARING
		else if (pScrn->is_gpu)
			snprintf(name, 32, "%s-%d-%d",
				 output_names[koutput->connector_type], pScrn->scrnIndex - GPU_SCREEN_OFFSET + 1,
				 koutput->connector_type_id - 1);
#endif
		else {
			/* need to do smart conversion here for compat with non-kms ATI driver */
			if (koutput->connector_type_id == 1) {
				switch(koutput->connector_type) {
				case DRM_MODE_CONNECTOR_DVII:
				case DRM_MODE_CONNECTOR_DVID:
				case DRM_MODE_CONNECTOR_DVIA:
					snprintf(name, 32, "%s-%d", output_names[koutput->connector_type], *num_dvi);
					(*num_dvi)++;
					break;
				case DRM_MODE_CONNECTOR_HDMIA:
				case DRM_MODE_CONNECTOR_HDMIB:
					snprintf(name, 32, "%s-%d", output_names[koutput->connector_type], *num_hdmi);
					(*num_hdmi)++;
					break;
				case DRM_MODE_CONNECTOR_VGA:
				case DRM_MODE_CONNECTOR_DisplayPort:
					snprintf(name, 32, "%s-%d", output_names[koutput->connector_type],
						 koutput->connector_type_id - 1);
					break;
				default:
					snprintf(name, 32, "%s", output_names[koutput->connector_type]);
					break;
				}
			} else {
				snprintf(name, 32, "%s-%d", output_names[koutput->connector_type],
					 koutput->connector_type_id - 1);
			}
		}
	}
}

static unsigned int
drmmode_output_init(ScrnInfoPtr pScrn, drmmode_ptr drmmode, drmModeResPtr mode_res, int num, int *num_dvi, int *num_hdmi, int dynamic)
{
	xf86CrtcConfigPtr   xf86_config = XF86_CRTC_CONFIG_PTR(pScrn);
	RADEONInfoPtr info = RADEONPTR(pScrn);
	xf86OutputPtr output;
	drmModeConnectorPtr koutput;
	drmModeEncoderPtr *kencoders = NULL;
	drmmode_output_private_ptr drmmode_output;
	drmModePropertyPtr props;
	drmModePropertyBlobPtr path_blob = NULL;
	char name[32];
	int i;
	const char *s;

	koutput = drmModeGetConnector(drmmode->fd, mode_res->connectors[num]);
	if (!koutput)
		return 0;

	for (i = 0; i < koutput->count_props; i++) {
		props = drmModeGetProperty(drmmode->fd, koutput->props[i]);
		if (props && (props->flags & DRM_MODE_PROP_BLOB)) {
			if (!strcmp(props->name, "PATH")) {
				path_blob = drmModeGetPropertyBlob(drmmode->fd, koutput->prop_values[i]);
				drmModeFreeProperty(props);
				break;
			}
			drmModeFreeProperty(props);
		}
	}

	kencoders = calloc(sizeof(drmModeEncoderPtr), koutput->count_encoders);
	if (!kencoders) {
		goto out_free_encoders;
	}

	for (i = 0; i < koutput->count_encoders; i++) {
		kencoders[i] = drmModeGetEncoder(drmmode->fd, koutput->encoders[i]);
		if (!kencoders[i]) {
			goto out_free_encoders;
		}
	}

	drmmode_create_name(pScrn, koutput, name, path_blob, num_dvi, num_hdmi);
	if (path_blob)
		drmModeFreePropertyBlob(path_blob);

	if (path_blob && dynamic) {
		/* See if we have an output with this name already
		 * and hook stuff up.
		 */
		for (i = 0; i < xf86_config->num_output; i++) {
			output = xf86_config->output[i];

			if (strncmp(output->name, name, 32))
				continue;

			drmmode_output = output->driver_private;
			drmmode_output->output_id = mode_res->connectors[num];
			drmmode_output->mode_output = koutput;
			for (i = 0; i < koutput->count_encoders; i++)
				drmModeFreeEncoder(kencoders[i]);
			free(kencoders);
			return 0;
		}
	}

	if (xf86IsEntityShared(pScrn->entityList[0])) {
		if ((s = xf86GetOptValString(info->Options, OPTION_ZAPHOD_HEADS))) {
			if (!RADEONZaphodStringMatches(pScrn, s, name))
				goto out_free_encoders;
		} else {
			if (!info->IsSecondary && (num != 0))
				goto out_free_encoders;
			else if (info->IsSecondary && (num != 1))
				goto out_free_encoders;
		}
	}

	output = xf86OutputCreate (pScrn, &drmmode_output_funcs, name);
	if (!output) {
		goto out_free_encoders;
	}

	drmmode_output = calloc(sizeof(drmmode_output_private_rec), 1);
	if (!drmmode_output) {
		xf86OutputDestroy(output);
		goto out_free_encoders;
	}

	drmmode_output->output_id = mode_res->connectors[num];
	drmmode_output->mode_output = koutput;
	drmmode_output->mode_encoders = kencoders;
	drmmode_output->drmmode = drmmode;
	output->mm_width = koutput->mmWidth;
	output->mm_height = koutput->mmHeight;

	output->subpixel_order = subpixel_conv_table[koutput->subpixel];
	output->interlaceAllowed = TRUE;
	output->doubleScanAllowed = TRUE;
	output->driver_private = drmmode_output;
	
	output->possible_crtcs = 0xffffffff;
	for (i = 0; i < koutput->count_encoders; i++) {
		output->possible_crtcs &= kencoders[i]->possible_crtcs;
	}
	/* work out the possible clones later */
	output->possible_clones = 0;

	for (i = 0; i < koutput->count_props; i++) {
		props = drmModeGetProperty(drmmode->fd, koutput->props[i]);
		if (props && (props->flags & DRM_MODE_PROP_ENUM)) {
			if (!strcmp(props->name, "DPMS")) {
				drmmode_output->dpms_enum_id = koutput->props[i];
				drmModeFreeProperty(props);
				break;
			}
			drmModeFreeProperty(props);
		}
	}

	if (dynamic) {
		output->randr_output = RROutputCreate(xf86ScrnToScreen(pScrn), output->name, strlen(output->name), output);
		drmmode_output_create_resources(output);
	}

	return 1;
out_free_encoders:
	if (kencoders){
		for (i = 0; i < koutput->count_encoders; i++)
			drmModeFreeEncoder(kencoders[i]);
		free(kencoders);
	}
	drmModeFreeConnector(koutput);
	return 0;
}

uint32_t find_clones(ScrnInfoPtr scrn, xf86OutputPtr output)
{
	drmmode_output_private_ptr drmmode_output = output->driver_private, clone_drmout;
	int i;
	xf86OutputPtr clone_output;
	xf86CrtcConfigPtr   xf86_config = XF86_CRTC_CONFIG_PTR(scrn);
	int index_mask = 0;

	if (drmmode_output->enc_clone_mask == 0)
		return index_mask;

	for (i = 0; i < xf86_config->num_output; i++) {
		clone_output = xf86_config->output[i];
		clone_drmout = clone_output->driver_private;
		if (output == clone_output)
			continue;
		
		if (clone_drmout->enc_mask == 0)
			continue;
		if (drmmode_output->enc_clone_mask == clone_drmout->enc_mask)
			index_mask |= (1 << i);
	}
	return index_mask;
}


static void
drmmode_clones_init(ScrnInfoPtr scrn, drmmode_ptr drmmode, drmModeResPtr mode_res)
{
	int i, j;
	xf86CrtcConfigPtr   xf86_config = XF86_CRTC_CONFIG_PTR(scrn);

	for (i = 0; i < xf86_config->num_output; i++) {
		xf86OutputPtr output = xf86_config->output[i];
		drmmode_output_private_ptr drmmode_output;

		drmmode_output = output->driver_private;
		drmmode_output->enc_clone_mask = 0xff;
		/* and all the possible encoder clones for this output together */
		for (j = 0; j < drmmode_output->mode_output->count_encoders; j++)
		{
			int k;
			for (k = 0; k < mode_res->count_encoders; k++) {
				if (mode_res->encoders[k] == drmmode_output->mode_encoders[j]->encoder_id)
					drmmode_output->enc_mask |= (1 << k);
			}

			drmmode_output->enc_clone_mask &= drmmode_output->mode_encoders[j]->possible_clones;
		}
	}

	for (i = 0; i < xf86_config->num_output; i++) {
		xf86OutputPtr output = xf86_config->output[i];
		output->possible_clones = find_clones(scrn, output);
	}
}

/* returns height alignment in pixels */
int drmmode_get_height_align(ScrnInfoPtr scrn, uint32_t tiling)
{
	RADEONInfoPtr info = RADEONPTR(scrn);
	int height_align = 1;

	if (info->ChipFamily >= CHIP_FAMILY_R600) {
		if (tiling & RADEON_TILING_MACRO)
			height_align =  info->num_channels * 8;
		else if (tiling & RADEON_TILING_MICRO)
			height_align = 8;
		else
			height_align = 8;
	} else {
		if (tiling & RADEON_TILING_MICRO_SQUARE)
			height_align =  32;
		else if (tiling)
			height_align = 16;
		else
			height_align = 1;
	}
	return height_align;
}

/* returns pitch alignment in pixels */
int drmmode_get_pitch_align(ScrnInfoPtr scrn, int bpe, uint32_t tiling)
{
	RADEONInfoPtr info = RADEONPTR(scrn);
	int pitch_align = 1;

	if (info->ChipFamily >= CHIP_FAMILY_R600) {
		if (tiling & RADEON_TILING_MACRO) {
			/* general surface requirements */
			pitch_align = MAX(info->num_banks,
					  (((info->group_bytes / 8) / bpe) * info->num_banks)) * 8;
			/* further restrictions for scanout */
			pitch_align = MAX(info->num_banks * 8, pitch_align);
		} else if (tiling & RADEON_TILING_MICRO) {
			/* general surface requirements */
			pitch_align = MAX(8, (info->group_bytes / (8 * bpe)));
			/* further restrictions for scanout */
			pitch_align = MAX(info->group_bytes / bpe, pitch_align);
		} else {
			if (info->have_tiling_info)
				/* linear aligned requirements */
				pitch_align = MAX(64, info->group_bytes / bpe);
			else
				/* default to 512 elements if we don't know the real
				 * group size otherwise the kernel may reject the CS
				 * if the group sizes don't match as the pitch won't
				 * be aligned properly.
				 */
				pitch_align = 512;
		}
	} else {
		/* general surface requirements */
		if (tiling)
			pitch_align = 256 / bpe;
		else
			pitch_align = 64;
	}
	return pitch_align;
}

/* returns base alignment in bytes */
int drmmode_get_base_align(ScrnInfoPtr scrn, int bpe, uint32_t tiling)
{
	RADEONInfoPtr info = RADEONPTR(scrn);
	int pixel_align = drmmode_get_pitch_align(scrn, bpe, tiling);
	int height_align = drmmode_get_height_align(scrn, tiling);
	int base_align = RADEON_GPU_PAGE_SIZE;

	if (info->ChipFamily >= CHIP_FAMILY_R600) {
		if (tiling & RADEON_TILING_MACRO)
			base_align = MAX(info->num_banks * info->num_channels * 8 * 8 * bpe,
					 pixel_align * bpe * height_align);
		else {
			if (info->have_tiling_info)
				base_align = info->group_bytes;
			else
				/* default to 512 if we don't know the real
				 * group size otherwise the kernel may reject the CS
				 * if the group sizes don't match as the base won't
				 * be aligned properly.
				 */
				base_align = 512;
		}
	}
	return base_align;
}

static Bool
drmmode_xf86crtc_resize (ScrnInfoPtr scrn, int width, int height)
{
	xf86CrtcConfigPtr xf86_config = XF86_CRTC_CONFIG_PTR(scrn);
	drmmode_crtc_private_ptr
		    drmmode_crtc = xf86_config->crtc[0]->driver_private;
	drmmode_ptr drmmode = drmmode_crtc->drmmode;
	RADEONInfoPtr info = RADEONPTR(scrn);
	struct radeon_bo *old_front = NULL;
	Bool	    ret;
	ScreenPtr   screen = xf86ScrnToScreen(scrn);
	uint32_t    old_fb_id;
	int	    i, pitch, old_width, old_height, old_pitch;
	int aligned_height;
	uint32_t screen_size;
	int cpp = info->pixel_bytes;
	struct radeon_bo *front_bo;
	struct radeon_surface surface;
	struct radeon_surface *psurface;
	uint32_t tiling_flags = 0, base_align;
	PixmapPtr ppix = screen->GetScreenPixmap(screen);
	void *fb_shadow;
	xRectangle rect;
	Bool force;
	GCPtr gc;

	if (scrn->virtualX == width && scrn->virtualY == height)
		return TRUE;

	front_bo = info->front_bo;
	radeon_cs_flush_indirect(scrn);

	if (front_bo)
		radeon_bo_wait(front_bo);

	if (info->allowColorTiling && !info->shadow_primary) {
		if (info->ChipFamily >= CHIP_FAMILY_R600) {
			if (info->allowColorTiling2D) {
				tiling_flags |= RADEON_TILING_MACRO;
			} else {
				tiling_flags |= RADEON_TILING_MICRO;
			}
		} else
			tiling_flags |= RADEON_TILING_MACRO;
	}

	pitch = RADEON_ALIGN(width, drmmode_get_pitch_align(scrn, cpp, tiling_flags)) * cpp;
	aligned_height = RADEON_ALIGN(height, drmmode_get_height_align(scrn, tiling_flags));
	screen_size = RADEON_ALIGN(pitch * aligned_height, RADEON_GPU_PAGE_SIZE);
	base_align = 4096;
	if (info->ChipFamily >= CHIP_FAMILY_R600) {
		memset(&surface, 0, sizeof(struct radeon_surface));
		surface.npix_x = width;
		surface.npix_y = height;
		surface.npix_z = 1;
		surface.blk_w = 1;
		surface.blk_h = 1;
		surface.blk_d = 1;
		surface.array_size = 1;
		surface.last_level = 0;
		surface.bpe = cpp;
		surface.nsamples = 1;
		surface.flags = RADEON_SURF_SCANOUT;
		/* we are requiring a recent enough libdrm version */
		surface.flags |= RADEON_SURF_HAS_TILE_MODE_INDEX;
		surface.flags |= RADEON_SURF_SET(RADEON_SURF_TYPE_2D, TYPE);
		surface.flags |= RADEON_SURF_SET(RADEON_SURF_MODE_LINEAR_ALIGNED, MODE);
		if (tiling_flags & RADEON_TILING_MICRO) {
			surface.flags = RADEON_SURF_CLR(surface.flags, MODE);
			surface.flags |= RADEON_SURF_SET(RADEON_SURF_MODE_1D, MODE);
		}
		if (tiling_flags & RADEON_TILING_MACRO) {
			surface.flags = RADEON_SURF_CLR(surface.flags, MODE);
			surface.flags |= RADEON_SURF_SET(RADEON_SURF_MODE_2D, MODE);
		}
		if (radeon_surface_best(info->surf_man, &surface)) {
			return FALSE;
		}
		if (radeon_surface_init(info->surf_man, &surface)) {
			return FALSE;
		}
		screen_size = surface.bo_size;
		base_align = surface.bo_alignment;
		pitch = surface.level[0].pitch_bytes;
		tiling_flags = 0;
		switch (surface.level[0].mode) {
		case RADEON_SURF_MODE_2D:
			tiling_flags |= RADEON_TILING_MACRO;
			tiling_flags |= surface.bankw << RADEON_TILING_EG_BANKW_SHIFT;
			tiling_flags |= surface.bankh << RADEON_TILING_EG_BANKH_SHIFT;
			tiling_flags |= surface.mtilea << RADEON_TILING_EG_MACRO_TILE_ASPECT_SHIFT;
			if (surface.tile_split)
				tiling_flags |= eg_tile_split(surface.tile_split)
						<< RADEON_TILING_EG_TILE_SPLIT_SHIFT;
			break;
		case RADEON_SURF_MODE_1D:
			tiling_flags |= RADEON_TILING_MICRO;
			break;
		default:
			break;
		}
		info->front_surface = surface;
	}

	xf86DrvMsg(scrn->scrnIndex, X_INFO,
		   "Allocate new frame buffer %dx%d stride %d\n",
		   width, height, pitch / cpp);

	old_width = scrn->virtualX;
	old_height = scrn->virtualY;
	old_pitch = scrn->displayWidth;
	old_fb_id = drmmode->fb_id;
	old_front = info->front_bo;

	scrn->virtualX = width;
	scrn->virtualY = height;
	scrn->displayWidth = pitch / cpp;

	info->front_bo = radeon_bo_open(info->bufmgr, 0, screen_size, base_align,
					info->shadow_primary ?
					RADEON_GEM_DOMAIN_GTT :
					RADEON_GEM_DOMAIN_VRAM,
					tiling_flags ? RADEON_GEM_NO_CPU_ACCESS : 0);
	if (!info->front_bo)
		goto fail;

#if X_BYTE_ORDER == X_BIG_ENDIAN
	switch (cpp) {
	case 4:
	    tiling_flags |= RADEON_TILING_SWAP_32BIT;
	    break;
	case 2:
	    tiling_flags |= RADEON_TILING_SWAP_16BIT;
	    break;
	}
	if (info->ChipFamily < CHIP_FAMILY_R600 &&
	    info->r600_shadow_fb && tiling_flags)
	    tiling_flags |= RADEON_TILING_SURFACE;
#endif
	if (tiling_flags)
	    radeon_bo_set_tiling(info->front_bo, tiling_flags, pitch);

	ret = drmModeAddFB(drmmode->fd, width, height, scrn->depth,
			   scrn->bitsPerPixel, pitch,
			   info->front_bo->handle,
			   &drmmode->fb_id);
	if (ret)
		goto fail;

	if (!info->r600_shadow_fb) {
		radeon_set_pixmap_bo(ppix, info->front_bo);
		psurface = radeon_get_pixmap_surface(ppix);
		*psurface = info->front_surface;
		screen->ModifyPixmapHeader(ppix,
					   width, height, -1, -1, pitch, NULL);
	} else {
		if (radeon_bo_map(info->front_bo, 1))
			goto fail;
		fb_shadow = calloc(1, screen_size);
		if (fb_shadow == NULL)
			goto fail;
		free(info->fb_shadow);
		info->fb_shadow = fb_shadow;
		screen->ModifyPixmapHeader(ppix,
					   width, height, -1, -1, pitch,
					   info->fb_shadow);
	}
#if XORG_VERSION_CURRENT < XORG_VERSION_NUMERIC(1,9,99,1,0)
	scrn->pixmapPrivate.ptr = ppix->devPrivate.ptr;
#endif

	if (info->use_glamor)
		radeon_glamor_create_screen_resources(scrn->pScreen);

	/* Clear new buffer */
	gc = GetScratchGC(ppix->drawable.depth, scrn->pScreen);
	force = info->accel_state->force;
	info->accel_state->force = TRUE;
	ValidateGC(&ppix->drawable, gc);
	rect.x = 0;
	rect.y = 0;
	rect.width = width;
	rect.height = height;
	(*gc->ops->PolyFillRect)(&ppix->drawable, gc, 1, &rect);
	FreeScratchGC(gc);
	info->accel_state->force = force;
	radeon_cs_flush_indirect(scrn);
	radeon_bo_wait(info->front_bo);

	for (i = 0; i < xf86_config->num_crtc; i++) {
		xf86CrtcPtr crtc = xf86_config->crtc[i];

		if (!crtc->enabled)
			continue;

		drmmode_set_mode_major(crtc, &crtc->mode,
				       crtc->rotation, crtc->x, crtc->y);
	}

	if (old_fb_id)
		drmModeRmFB(drmmode->fd, old_fb_id);
	if (old_front)
		radeon_bo_unref(old_front);

	radeon_kms_update_vram_limit(scrn, screen_size);
	return TRUE;

 fail:
	if (info->front_bo)
		radeon_bo_unref(info->front_bo);
	info->front_bo = old_front;
	scrn->virtualX = old_width;
	scrn->virtualY = old_height;
	scrn->displayWidth = old_pitch;
	drmmode->fb_id = old_fb_id;

	return FALSE;
}

static const xf86CrtcConfigFuncsRec drmmode_xf86crtc_config_funcs = {
	drmmode_xf86crtc_resize
};

void
drmmode_clear_pending_flip(xf86CrtcPtr crtc)
{
	drmmode_crtc_private_ptr drmmode_crtc = crtc->driver_private;

	drmmode_crtc->flip_pending = FALSE;

	if (!crtc->enabled ||
	    (drmmode_crtc->pending_dpms_mode != DPMSModeOn &&
	     drmmode_crtc->dpms_mode != drmmode_crtc->pending_dpms_mode)) {
		xf86CrtcConfigPtr xf86_config = XF86_CRTC_CONFIG_PTR(crtc->scrn);
		int o;

		for (o = 0; o < xf86_config->num_output; o++) {
			xf86OutputPtr output = xf86_config->output[o];

			if (output->crtc != crtc)
				continue;

			drmmode_output_dpms(output, drmmode_crtc->pending_dpms_mode);
		}

		drmmode_crtc_dpms(crtc, drmmode_crtc->pending_dpms_mode);
	}
}

static void
drmmode_flip_abort(xf86CrtcPtr crtc, void *event_data)
{
	drmmode_flipdata_ptr flipdata = event_data;

	if (--flipdata->flip_count == 0) {
		if (!flipdata->fe_crtc)
			flipdata->fe_crtc = crtc;
		flipdata->abort(flipdata->fe_crtc, flipdata->event_data);
		free(flipdata);
	}

	drmmode_clear_pending_flip(crtc);
}

static void
drmmode_flip_handler(xf86CrtcPtr crtc, uint32_t frame, uint64_t usec, void *event_data)
{
	RADEONInfoPtr info = RADEONPTR(crtc->scrn);
	drmmode_flipdata_ptr flipdata = event_data;

	/* Is this the event whose info shall be delivered to higher level? */
	if (crtc == flipdata->fe_crtc) {
		/* Yes: Cache msc, ust for later delivery. */
		flipdata->fe_frame = frame;
		flipdata->fe_usec = usec;
	}

	if (--flipdata->flip_count == 0) {
		/* Deliver MSC & UST from reference/current CRTC to flip event
		 * handler
		 */
		if (flipdata->fe_crtc)
			flipdata->handler(flipdata->fe_crtc, flipdata->fe_frame,
					  flipdata->fe_usec, flipdata->event_data);
		else
			flipdata->handler(crtc, frame, usec, flipdata->event_data);

		/* Release framebuffer */
		drmModeRmFB(info->drmmode.fd, flipdata->old_fb_id);

		free(flipdata);
	}

	drmmode_clear_pending_flip(crtc);
}


static void
drm_wakeup_handler(pointer data, int err, pointer p)
{
	drmmode_ptr drmmode = data;
	fd_set *read_mask = p;

	if (err >= 0 && FD_ISSET(drmmode->fd, read_mask)) {
		drmHandleEvent(drmmode->fd, &drmmode->event_context);
	}
}

Bool drmmode_pre_init(ScrnInfoPtr pScrn, drmmode_ptr drmmode, int cpp)
{
	RADEONEntPtr pRADEONEnt = RADEONEntPriv(pScrn);
	RADEONInfoPtr info = RADEONPTR(pScrn);
	int i, num_dvi = 0, num_hdmi = 0;
	drmModeResPtr mode_res;
	unsigned int crtcs_needed = 0;
#ifdef RADEON_PIXMAP_SHARING
	char *bus_id_string, *provider_name;
#endif

	xf86CrtcConfigInit(pScrn, &drmmode_xf86crtc_config_funcs);

	drmmode->scrn = pScrn;
	drmmode->cpp = cpp;
	mode_res = drmModeGetResources(drmmode->fd);
	if (!mode_res)
		return FALSE;

	xf86DrvMsgVerb(pScrn->scrnIndex, X_INFO, RADEON_LOGLEVEL_DEBUG,
		       "Initializing outputs ...\n");
	for (i = 0; i < mode_res->count_connectors; i++)
		crtcs_needed += drmmode_output_init(pScrn, drmmode, mode_res,
						    i, &num_dvi, &num_hdmi, 0);
	xf86DrvMsgVerb(pScrn->scrnIndex, X_INFO, RADEON_LOGLEVEL_DEBUG,
		       "%d crtcs needed for screen.\n", crtcs_needed);

	if (info->r600_shadow_fb) {
		/* Rotation requires hardware acceleration */
		drmmode_crtc_funcs.shadow_allocate = NULL;
		drmmode_crtc_funcs.shadow_create = NULL;
		drmmode_crtc_funcs.shadow_destroy = NULL;
	}

	drmmode->count_crtcs = mode_res->count_crtcs;
	xf86CrtcSetSizeRange(pScrn, 320, 200, mode_res->max_width, mode_res->max_height);

	for (i = 0; i < mode_res->count_crtcs; i++)
		if (!xf86IsEntityShared(pScrn->entityList[0]) ||
		    (crtcs_needed && !(pRADEONEnt->assigned_crtcs & (1 << i))))
			crtcs_needed -= drmmode_crtc_init(pScrn, drmmode, mode_res, i);

	/* All ZaphodHeads outputs provided with matching crtcs? */
	if (xf86IsEntityShared(pScrn->entityList[0]) && (crtcs_needed > 0))
		xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
			   "%d ZaphodHeads crtcs unavailable. Some outputs will stay off.\n",
			   crtcs_needed);

	/* workout clones */
	drmmode_clones_init(pScrn, drmmode, mode_res);

#ifdef RADEON_PIXMAP_SHARING
	bus_id_string = DRICreatePCIBusID(info->PciInfo);
	XNFasprintf(&provider_name, "%s @@ %s", pScrn->chipset, bus_id_string);
	free(bus_id_string);
	xf86ProviderSetup(pScrn, NULL, provider_name);
	free(provider_name);
#endif

	xf86InitialConfiguration(pScrn, TRUE);

	drmmode->event_context.version = DRM_EVENT_CONTEXT_VERSION;
	drmmode->event_context.vblank_handler = radeon_drm_queue_handler;
	drmmode->event_context.page_flip_handler = radeon_drm_queue_handler;

	drmModeFreeResources(mode_res);
	return TRUE;
}

void drmmode_init(ScrnInfoPtr pScrn, drmmode_ptr drmmode)
{
	RADEONEntPtr pRADEONEnt = RADEONEntPriv(pScrn);
	RADEONInfoPtr info = RADEONPTR(pScrn);

	if (info->dri2.pKernelDRMVersion->version_minor < 4)
		return;

	info->drmmode_inited = TRUE;
	if (pRADEONEnt->fd_wakeup_registered != serverGeneration) {
		AddGeneralSocket(drmmode->fd);
		RegisterBlockAndWakeupHandlers((BlockHandlerProcPtr)NoopDDA,
				drm_wakeup_handler, drmmode);
		pRADEONEnt->fd_wakeup_registered = serverGeneration;
		pRADEONEnt->fd_wakeup_ref = 1;
	} else
		pRADEONEnt->fd_wakeup_ref++;
}

void drmmode_fini(ScrnInfoPtr pScrn, drmmode_ptr drmmode)
{
	xf86CrtcConfigPtr config = XF86_CRTC_CONFIG_PTR(pScrn);
	RADEONEntPtr pRADEONEnt = RADEONEntPriv(pScrn);
	RADEONInfoPtr info = RADEONPTR(pScrn);
	int c;

	if (info->dri2.pKernelDRMVersion->version_minor < 4 || !info->drmmode_inited)
		return;

	if (pRADEONEnt->fd_wakeup_registered == serverGeneration &&
	    !--pRADEONEnt->fd_wakeup_ref) {
		RemoveGeneralSocket(drmmode->fd);
		RemoveBlockAndWakeupHandlers((BlockHandlerProcPtr)NoopDDA,
				drm_wakeup_handler, drmmode);
	}

	for (c = 0; c < config->num_crtc; c++) {
		xf86CrtcPtr crtc = config->crtc[c];
		drmmode_crtc_private_ptr drmmode_crtc = crtc->driver_private;

		drmmode_crtc_scanout_destroy(&info->drmmode, &drmmode_crtc->scanout[0]);
		drmmode_crtc_scanout_destroy(&info->drmmode, &drmmode_crtc->scanout[1]);
	}
}


Bool drmmode_set_bufmgr(ScrnInfoPtr pScrn, drmmode_ptr drmmode, struct radeon_bo_manager *bufmgr)
{
	drmmode->bufmgr = bufmgr;
	return TRUE;
}



void drmmode_set_cursor(ScrnInfoPtr scrn, drmmode_ptr drmmode, int id, struct radeon_bo *bo)
{
	xf86CrtcConfigPtr   xf86_config = XF86_CRTC_CONFIG_PTR(scrn);
	xf86CrtcPtr crtc = xf86_config->crtc[id];
	drmmode_crtc_private_ptr drmmode_crtc = crtc->driver_private;

	drmmode_crtc->cursor_bo = bo;
}

void drmmode_adjust_frame(ScrnInfoPtr pScrn, drmmode_ptr drmmode, int x, int y)
{
	xf86CrtcConfigPtr	config = XF86_CRTC_CONFIG_PTR(pScrn);
	xf86OutputPtr  output = config->output[config->compat_output];
	xf86CrtcPtr	crtc = output->crtc;

	if (crtc && crtc->enabled) {
		drmmode_set_mode_major(crtc, &crtc->mode, crtc->rotation,
				       x, y);
	}
}

Bool drmmode_set_desired_modes(ScrnInfoPtr pScrn, drmmode_ptr drmmode,
			       Bool set_hw)
{
	xf86CrtcConfigPtr   config = XF86_CRTC_CONFIG_PTR(pScrn);
	int c;

	for (c = 0; c < config->num_crtc; c++) {
		xf86CrtcPtr	crtc = config->crtc[c];
		drmmode_crtc_private_ptr drmmode_crtc = crtc->driver_private;
		xf86OutputPtr	output = NULL;
		int		o;

		/* Skip disabled CRTCs */
		if (!crtc->enabled) {
			if (set_hw) {
				drmmode_do_crtc_dpms(crtc, DPMSModeOff);
				drmModeSetCrtc(drmmode->fd,
					       drmmode_crtc->mode_crtc->crtc_id,
					       0, 0, 0, NULL, 0, NULL);
			}
			continue;
		}

		if (config->output[config->compat_output]->crtc == crtc)
			output = config->output[config->compat_output];
		else
		{
			for (o = 0; o < config->num_output; o++)
				if (config->output[o]->crtc == crtc)
				{
					output = config->output[o];
					break;
				}
		}
		/* paranoia */
		if (!output)
			continue;

		/* Mark that we'll need to re-set the mode for sure */
		memset(&crtc->mode, 0, sizeof(crtc->mode));
		if (!crtc->desiredMode.CrtcHDisplay)
		{
			DisplayModePtr  mode = xf86OutputFindClosestMode (output, pScrn->currentMode);

			if (!mode)
				return FALSE;
			crtc->desiredMode = *mode;
			crtc->desiredRotation = RR_Rotate_0;
			crtc->desiredX = 0;
			crtc->desiredY = 0;
		}

		if (set_hw) {
			if (!crtc->funcs->set_mode_major(crtc, &crtc->desiredMode, crtc->desiredRotation,
							 crtc->desiredX, crtc->desiredY))
				return FALSE;
		} else {
			crtc->mode = crtc->desiredMode;
			crtc->rotation = crtc->desiredRotation;
			crtc->x = crtc->desiredX;
			crtc->y = crtc->desiredY;
			if (!drmmode_handle_transform(crtc))
				return FALSE;
		}
	}
	return TRUE;
}

static void drmmode_load_palette(ScrnInfoPtr pScrn, int numColors,
                                 int *indices, LOCO *colors, VisualPtr pVisual)
{
    xf86CrtcConfigPtr   xf86_config = XF86_CRTC_CONFIG_PTR(pScrn);
    uint16_t       lut_r[256], lut_g[256], lut_b[256];
    int index, j, i;
    int c;

    for (c = 0; c < xf86_config->num_crtc; c++) {
        xf86CrtcPtr crtc = xf86_config->crtc[c];
	drmmode_crtc_private_ptr drmmode_crtc = crtc->driver_private;

        for (i = 0 ; i < 256; i++) {
            lut_r[i] = drmmode_crtc->lut_r[i] << 6;
            lut_g[i] = drmmode_crtc->lut_g[i] << 6;
            lut_b[i] = drmmode_crtc->lut_b[i] << 6;
        }

        switch(pScrn->depth) {
        case 15:
            for (i = 0; i < numColors; i++) {
                index = indices[i];
                for (j = 0; j < 8; j++) {
                    lut_r[index * 8 + j] = colors[index].red << 6;
                    lut_g[index * 8 + j] = colors[index].green << 6;
                    lut_b[index * 8 + j] = colors[index].blue << 6;
                }
            }
         break;
         case 16:
             for (i = 0; i < numColors; i++) {
                 index = indices[i];

                  if (i <= 31) {
                      for (j = 0; j < 8; j++) {
                          lut_r[index * 8 + j] = colors[index].red << 6;
                          lut_b[index * 8 + j] = colors[index].blue << 6;
                      }
                  }

                  for (j = 0; j < 4; j++) {
                      lut_g[index * 4 + j] = colors[index].green << 6;
                  }
              }
	  break;
          default:
              for (i = 0; i < numColors; i++) {
                  index = indices[i];
                  lut_r[index] = colors[index].red << 6;
                  lut_g[index] = colors[index].green << 6;
                  lut_b[index] = colors[index].blue << 6;
              }
              break;
          }

    /* Make the change through RandR */
        if (crtc->randr_crtc)
            RRCrtcGammaSet(crtc->randr_crtc, lut_r, lut_g, lut_b);
        else
            crtc->funcs->gamma_set(crtc, lut_r, lut_g, lut_b, 256);
     }
}

Bool drmmode_setup_colormap(ScreenPtr pScreen, ScrnInfoPtr pScrn)
{
    xf86CrtcConfigPtr   xf86_config = XF86_CRTC_CONFIG_PTR(pScrn);

    if (xf86_config->num_crtc) {
	xf86DrvMsgVerb(pScrn->scrnIndex, X_INFO, RADEON_LOGLEVEL_DEBUG,
		       "Initializing kms color map\n");
	if (!miCreateDefColormap(pScreen))
	    return FALSE;
	/* all radeons support 10 bit CLUTs */
	if (!xf86HandleColormaps(pScreen, 256, 10,
				 drmmode_load_palette, NULL,
				 CMAP_PALETTED_TRUECOLOR
#if 0 /* This option messes up text mode! (eich@@suse.de) */
				 | CMAP_LOAD_EVEN_IF_OFFSCREEN
#endif
				 | CMAP_RELOAD_ON_MODE_SWITCH))
	    return FALSE;
    }
    return TRUE;
}

void
radeon_mode_hotplug(ScrnInfoPtr scrn, drmmode_ptr drmmode)
{
	xf86CrtcConfigPtr config = XF86_CRTC_CONFIG_PTR(scrn);
	RADEONEntPtr pRADEONEnt = RADEONEntPriv(scrn);
	drmModeResPtr mode_res;
	int i, j, s;
	Bool found;
	Bool changed = FALSE;
	int num_dvi = 0, num_hdmi = 0;

	mode_res = drmModeGetResources(drmmode->fd);
	if (!mode_res)
		goto out;

restart_destroy:
	for (i = 0; i < config->num_output; i++) {
		xf86OutputPtr output = config->output[i];
		drmmode_output_private_ptr drmmode_output = output->driver_private;
		found = FALSE;
		for (j = 0; j < mode_res->count_connectors; j++) {
			if (mode_res->connectors[j] == drmmode_output->output_id) {
				found = TRUE;
				break;
			}
		}
		if (found)
			continue;

		drmModeFreeConnector(drmmode_output->mode_output);
		drmmode_output->mode_output = NULL;
		drmmode_output->output_id = -1;

		changed = TRUE;
		if (drmmode->delete_dp_12_displays) {
			RROutputDestroy(output->randr_output);
			xf86OutputDestroy(output);
			goto restart_destroy;
		}
	}

	/* find new output ids we don't have outputs for */
	for (i = 0; i < mode_res->count_connectors; i++) {
		found = FALSE;

		for (s = 0; !found && s < xf86NumScreens; s++) {
			ScrnInfoPtr loop_scrn = xf86Screens[s];
			xf86CrtcConfigPtr loop_config =
				XF86_CRTC_CONFIG_PTR(loop_scrn);

			if (strcmp(loop_scrn->driverName, scrn->driverName) ||
			    RADEONEntPriv(loop_scrn) != pRADEONEnt)
				continue;

			for (j = 0; !found && j < loop_config->num_output; j++) {
				xf86OutputPtr output = loop_config->output[j];
				drmmode_output_private_ptr drmmode_output;

				drmmode_output = output->driver_private;
				if (mode_res->connectors[i] ==
				    drmmode_output->output_id) {
					found = TRUE;

					switch(drmmode_output->mode_output->connector_type) {
					case DRM_MODE_CONNECTOR_DVII:
					case DRM_MODE_CONNECTOR_DVID:
					case DRM_MODE_CONNECTOR_DVIA:
						num_dvi++;
						break;
					case DRM_MODE_CONNECTOR_HDMIA:
					case DRM_MODE_CONNECTOR_HDMIB:
						num_hdmi++;
						break;
					}
				}
			}
		}
		if (found)
			continue;

		if (drmmode_output_init(scrn, drmmode, mode_res, i, &num_dvi,
					&num_hdmi, 1) != 0)
			changed = TRUE;
	}

	if (changed && dixPrivateKeyRegistered(rrPrivKey)) {
#if XORG_VERSION_CURRENT >= XORG_VERSION_NUMERIC(1,14,99,2,0)
		RRSetChanged(xf86ScrnToScreen(scrn));
#else
		rrScrPrivPtr rrScrPriv = rrGetScrPriv(scrn->pScreen);
		rrScrPriv->changed = TRUE;
#endif
		RRTellChanged(xf86ScrnToScreen(scrn));
	}

	drmModeFreeResources(mode_res);
out:
	RRGetInfo(xf86ScrnToScreen(scrn), TRUE);
}
#ifdef HAVE_LIBUDEV
static void
drmmode_handle_uevents(int fd, void *closure)
{
	drmmode_ptr drmmode = closure;
	ScrnInfoPtr scrn = drmmode->scrn;
	struct udev_device *dev;
	dev = udev_monitor_receive_device(drmmode->uevent_monitor);
	if (!dev)
		return;

	radeon_mode_hotplug(scrn, drmmode);
	udev_device_unref(dev);
}
#endif

void drmmode_uevent_init(ScrnInfoPtr scrn, drmmode_ptr drmmode)
{
#ifdef HAVE_LIBUDEV
	struct udev *u;
	struct udev_monitor *mon;

	u = udev_new();
	if (!u)
		return;
	mon = udev_monitor_new_from_netlink(u, "udev");
	if (!mon) {
		udev_unref(u);
		return;
	}

	if (udev_monitor_filter_add_match_subsystem_devtype(mon,
							    "drm",
							    "drm_minor") < 0 ||
	    udev_monitor_enable_receiving(mon) < 0) {
		udev_monitor_unref(mon);
		udev_unref(u);
		return;
	}

	drmmode->uevent_handler =
		xf86AddGeneralHandler(udev_monitor_get_fd(mon),
				      drmmode_handle_uevents,
				      drmmode);

	drmmode->uevent_monitor = mon;
#endif
}

void drmmode_uevent_fini(ScrnInfoPtr scrn, drmmode_ptr drmmode)
{
#ifdef HAVE_LIBUDEV
	if (drmmode->uevent_handler) {
		struct udev *u = udev_monitor_get_udev(drmmode->uevent_monitor);
		xf86RemoveGeneralHandler(drmmode->uevent_handler);

		udev_monitor_unref(drmmode->uevent_monitor);
		udev_unref(u);
	}
	if (info->ChipFamily < CHIP_FAMILY_R600 &&
	    info->r600_shadow_fb && tiling_flags)
	    tiling_flags |= RADEON_TILING_SURFACE;
#endif
}

Bool radeon_do_pageflip(ScrnInfoPtr scrn, ClientPtr client,
			uint32_t new_front_handle, uint64_t id, void *data,
			int ref_crtc_hw_id, radeon_drm_handler_proc handler,
			radeon_drm_abort_proc abort)
{
	RADEONInfoPtr info = RADEONPTR(scrn);
	xf86CrtcConfigPtr config = XF86_CRTC_CONFIG_PTR(scrn);
	xf86CrtcPtr crtc = NULL;
	drmmode_crtc_private_ptr drmmode_crtc = config->crtc[0]->driver_private;
	drmmode_ptr drmmode = drmmode_crtc->drmmode;
	unsigned int pitch;
	int i;
	uint32_t tiling_flags = 0;
	drmmode_flipdata_ptr flipdata;
	uintptr_t drm_queue_seq = 0;

	if (info->allowColorTiling) {
		if (info->ChipFamily >= CHIP_FAMILY_R600)
			tiling_flags |= RADEON_TILING_MICRO;
		else
			tiling_flags |= RADEON_TILING_MACRO;
	}

	pitch = RADEON_ALIGN(scrn->displayWidth, drmmode_get_pitch_align(scrn, info->pixel_bytes, tiling_flags)) *
		info->pixel_bytes;
	if (info->ChipFamily >= CHIP_FAMILY_R600 && info->surf_man) {
		pitch = info->front_surface.level[0].pitch_bytes;
	}

        flipdata = calloc(1, sizeof(drmmode_flipdata_rec));
        if (!flipdata) {
             xf86DrvMsg(scrn->scrnIndex, X_WARNING,
                        "flip queue: data alloc failed.\n");
             goto error;
        }

	/*
	 * Create a new handle for the back buffer
	 */
	flipdata->old_fb_id = drmmode->fb_id;
	if (drmModeAddFB(drmmode->fd, scrn->virtualX, scrn->virtualY,
			 scrn->depth, scrn->bitsPerPixel, pitch,
			 new_front_handle, &drmmode->fb_id))
		goto error;

	/*
	 * Queue flips on all enabled CRTCs
	 * Note that if/when we get per-CRTC buffers, we'll have to update this.
	 * Right now it assumes a single shared fb across all CRTCs, with the
	 * kernel fixing up the offset of each CRTC as necessary.
	 *
	 * Also, flips queued on disabled or incorrectly configured displays
	 * may never complete; this is a configuration error.
	 */

        flipdata->event_data = data;
        flipdata->handler = handler;
        flipdata->abort = abort;

	for (i = 0; i < config->num_crtc; i++) {
		crtc = config->crtc[i];

		if (!crtc->enabled)
			continue;

		flipdata->flip_count++;
		drmmode_crtc = crtc->driver_private;

		/* Only the reference crtc will finally deliver its page flip
		 * completion event. All other crtc's events will be discarded.
		 */
		if (drmmode_crtc->hw_id == ref_crtc_hw_id)
			flipdata->fe_crtc = crtc;

		drm_queue_seq = radeon_drm_queue_alloc(crtc, client, id,
						       flipdata,
						       drmmode_flip_handler,
						       drmmode_flip_abort);
		if (!drm_queue_seq) {
			xf86DrvMsg(scrn->scrnIndex, X_WARNING,
				   "Allocating DRM queue event entry failed.\n");
			goto error;
		}

		if (drmModePageFlip(drmmode->fd, drmmode_crtc->mode_crtc->crtc_id,
				    drmmode->fb_id, DRM_MODE_PAGE_FLIP_EVENT,
				    (void*)drm_queue_seq)) {
			xf86DrvMsg(scrn->scrnIndex, X_WARNING,
				   "flip queue failed: %s\n", strerror(errno));
			goto error;
		}
		drmmode_crtc->flip_pending = TRUE;
		drm_queue_seq = 0;
	}

	if (flipdata->flip_count > 0)
		return TRUE;

error:
	if (flipdata && flipdata->flip_count <= 1) {
		drmModeRmFB(drmmode->fd, drmmode->fb_id);
		drmmode->fb_id = flipdata->old_fb_id;
	}

	if (drm_queue_seq)
		radeon_drm_abort_entry(drm_queue_seq);
	else if (crtc)
		drmmode_flip_abort(crtc, flipdata);
	else if (flipdata && flipdata->flip_count <= 1)
		free(flipdata);

	xf86DrvMsg(scrn->scrnIndex, X_WARNING, "Page flip failed: %s\n",
		   strerror(errno));
	return FALSE;
}
@


1.11
log
@Update to xf86-video-ati 7.6.1. ok jsg@@
@
text
@d39 1
d41 1
d43 1
d46 4
d101 1
a101 1
					  int pitch, int tiling,
d108 1
d115 8
d152 1
d306 2
d311 4
d372 5
a376 1
	if (!crtc->enabled || mode != DPMSModeOn)
d379 1
a379 1
	else if (drmmode_crtc->dpms_mode != DPMSModeOn)
d384 2
d423 2
a424 2
					  fbcon->depth, fbcon->bpp,
					  fbcon->pitch, 0, bo, NULL);
a448 2
#if GET_ABI_MAJOR(ABI_VIDEODRV_VERSION) >= 10

d552 1
d555 2
a556 2
	int aligned_height;
	int size;
d558 1
a558 2
	unsigned long rotate_pitch;
	int base_align;
d567 5
a571 9
	rotate_pitch =
		RADEON_ALIGN(width, drmmode_get_pitch_align(pScrn, drmmode->cpp, 0))
		* drmmode->cpp;
	aligned_height = RADEON_ALIGN(height, drmmode_get_height_align(pScrn, 0));
	base_align = drmmode_get_base_align(pScrn, drmmode->cpp, 0);
	size = RADEON_ALIGN(rotate_pitch * aligned_height, RADEON_GPU_PAGE_SIZE);

	scanout->bo = radeon_bo_open(drmmode->bufmgr, 0, size, base_align,
				     RADEON_GEM_DOMAIN_VRAM, 0);
d578 1
a578 1
			   pScrn->bitsPerPixel, rotate_pitch,
a599 1
	unsigned long rotate_pitch;
a612 3
	rotate_pitch = RADEON_ALIGN(width, drmmode_get_pitch_align(pScrn, drmmode->cpp, 0))
		* drmmode->cpp;

d617 1
a617 2
						 rotate_pitch,
						 0, scanout->bo, NULL);
d634 59
d697 1
a749 1
		crtc->transformPresent = FALSE;
a756 2
		ScreenPtr pScreen = pScrn->pScreen;

d769 1
a769 1
		if (!xf86CrtcRotate(crtc)) {
d771 1
a771 1
		}
d793 5
a797 1
		} else if (info->tear_free || info->shadow_primary) {
d823 11
a833 2
					pBox->x2 = max(pBox->x2, x + mode->HDisplay);
					pBox->y2 = max(pBox->y2, y + mode->VDisplay);
d843 1
a843 1
				radeon_scanout_update_handler(pScrn, 0, 0, crtc);
d847 6
d864 2
a865 2
		if (crtc->scrn->pScreen)
			xf86CrtcSetScreenSubpixelOrder(crtc->scrn->pScreen);
d880 17
a896 3
	if (pScrn->pScreen &&
		!xf86ReturnOptValBool(info->Options, OPTION_SW_CURSOR, FALSE))
		xf86_reload_cursors(pScrn->pScreen);
d904 1
a904 3
	}
#if defined(XF86_CRTC_VERSION) && XF86_CRTC_VERSION >= 3
	else
d906 1
a906 1
#endif
d924 8
d935 35
a975 1
	int i;
a976 1
	uint32_t cursor_size = info->cursor_w * info->cursor_h;
d981 26
a1006 2
	for (i = 0; i < cursor_size; i++)
		ptr[i] = cpu_to_le32(image[i]);
d1009 12
d1138 1
a1138 1
#ifndef HAS_DIRTYTRACKING2
d1177 3
d1232 2
d1359 3
a1361 1
	if (mode != DPMSModeOn && crtc)
d1364 5
d2096 2
a2097 1
					RADEON_GEM_DOMAIN_VRAM, 0);
d2198 2
a2199 2
static void
drmmode_flip_free(drmmode_flipevtcarrier_ptr flipcarrier)
d2201 1
a2201 1
	drmmode_flipdata_ptr flipdata = flipcarrier->flipdata;
d2203 1
a2203 1
	free(flipcarrier);
d2205 14
a2218 2
	if (--flipdata->flip_count > 0)
		return;
d2220 2
a2221 1
	free(flipdata);
d2225 1
a2225 1
drmmode_flip_abort(ScrnInfoPtr scrn, void *event_data)
d2227 1
a2227 2
	drmmode_flipevtcarrier_ptr flipcarrier = event_data;
	drmmode_flipdata_ptr flipdata = flipcarrier->flipdata;
d2229 6
a2234 2
	if (flipdata->flip_count == 1)
		flipdata->abort(scrn, flipdata->event_data);
d2236 1
a2236 1
	drmmode_flip_free(flipcarrier);
d2240 1
a2240 1
drmmode_flip_handler(ScrnInfoPtr scrn, uint32_t frame, uint64_t usec, void *event_data)
d2242 2
a2243 2
	drmmode_flipevtcarrier_ptr flipcarrier = event_data;
	drmmode_flipdata_ptr flipdata = flipcarrier->flipdata;
d2246 1
a2246 1
	if (flipcarrier->dispatch_me) {
d2252 9
a2260 6
	if (flipdata->flip_count == 1) {
		/* Deliver cached msc, ust from reference crtc to flip event handler */
		if (flipdata->event_data)
			flipdata->handler(scrn, flipdata->fe_frame,
					  flipdata->fe_usec,
					  flipdata->event_data);
d2263 3
a2265 1
		drmModeRmFB(flipdata->drmmode->fd, flipdata->old_fb_id);
d2268 1
a2268 1
	drmmode_flip_free(flipcarrier);
d2290 3
d2335 5
a2339 1
	xf86ProviderSetup(pScrn, NULL, "radeon");
d2373 1
d2376 1
d2387 8
d2488 2
a2489 2
			if (!xf86CrtcRotate(crtc))
			    return FALSE;
d2584 1
d2586 1
a2586 1
	int i, j;
d2589 1
d2625 8
a2632 3
		for (j = 0; j < config->num_output; j++) {
			xf86OutputPtr output = config->output[j];
			drmmode_output_private_ptr drmmode_output;
d2634 21
a2654 4
			drmmode_output = output->driver_private;
			if (mode_res->connectors[i] == drmmode_output->output_id) {
				found = TRUE;
				break;
d2660 3
a2662 2
		changed = TRUE;
		drmmode_output_init(scrn, drmmode, mode_res, i, NULL, NULL, 1);
d2665 2
a2666 1
	if (changed) {
d2668 4
d2751 1
d2758 1
a2758 2
	drmmode_flipevtcarrier_ptr flipcarrier = NULL;
	struct radeon_drm_queue_entry *drm_queue = NULL;
a2799 1
        flipdata->drmmode = drmmode;
d2804 3
a2806 1
		if (!config->crtc[i]->enabled)
d2810 1
a2810 8
		drmmode_crtc = config->crtc[i]->driver_private;

		flipcarrier = calloc(1, sizeof(drmmode_flipevtcarrier_rec));
		if (!flipcarrier) {
			xf86DrvMsg(scrn->scrnIndex, X_WARNING,
				   "flip queue: carrier alloc failed.\n");
			goto error;
		}
d2815 2
a2816 2
		flipcarrier->dispatch_me = (drmmode_crtc->hw_id == ref_crtc_hw_id);
		flipcarrier->flipdata = flipdata;
d2818 5
a2822 5
		drm_queue = radeon_drm_queue_alloc(scrn, client, id,
						   flipcarrier,
						   drmmode_flip_handler,
						   drmmode_flip_abort);
		if (!drm_queue) {
d2830 1
a2830 1
				    drm_queue)) {
d2835 2
a2836 2
		flipcarrier = NULL;
		drm_queue = NULL;
d2848 4
a2851 4
	if (drm_queue)
		radeon_drm_abort_entry(drm_queue);
	else if (flipcarrier)
		drmmode_flip_abort(scrn, flipcarrier);
@


1.10
log
@Update to xf86-video-ati 7.5.0. Discussed with jsg@@
@
text
@d35 2
d40 1
a41 1
#include "sarea.h"
d102 2
a103 1
	pixmap = (*pScreen->CreatePixmap)(pScreen, 0, 0, depth, 0);
d153 3
a155 1
	if (!radeon_glamor_create_textured_pixmap(pixmap)) {
d253 27
d345 10
a354 1
	/* Nothing to do. drmmode_do_crtc_dpms() is called as appropriate */
d361 2
a362 1
	PixmapPtr pixmap = NULL;
d367 3
d396 1
d403 19
d429 2
a431 6
	int pitch;
	uint32_t tiling_flags = 0;
	Bool ret;

	if (info->accelOn == FALSE || info->use_glamor)
		goto fallback;
d441 1
a441 1
		goto fallback;
d454 3
a456 1
		goto fallback;
d458 8
a465 10
	if (info->allowColorTiling) {
		if (info->ChipFamily >= CHIP_FAMILY_R600) {
			if (info->allowColorTiling2D) {
				tiling_flags |= RADEON_TILING_MACRO;
			} else {
				tiling_flags |= RADEON_TILING_MICRO;
			}
		} else
			tiling_flags |= RADEON_TILING_MACRO;
	}
d467 1
a467 3
	pitch = RADEON_ALIGN(pScrn->displayWidth,
			     drmmode_get_pitch_align(pScrn, info->pixel_bytes, tiling_flags)) *
		info->pixel_bytes;
a468 14
	dst = drmmode_create_bo_pixmap(pScrn, pScrn->virtualX,
				       pScrn->virtualY, pScrn->depth,
				       pScrn->bitsPerPixel, pitch,
				       tiling_flags, info->front_bo, &info->front_surface);
	if (!dst)
		goto out_free_src;

	ret = info->accel_state->exa->PrepareCopy (src, dst,
						   -1, -1, GXcopy, FB_ALLONES);
	if (!ret)
	  goto out_free_src;
	info->accel_state->exa->Copy (dst, 0, 0, 0, 0,
				      pScrn->virtualX, pScrn->virtualY);
	info->accel_state->exa->DoneCopy (dst);
d470 1
a471 1
#if GET_ABI_MAJOR(ABI_VIDEODRV_VERSION) >= 10
d473 1
a473 4
#endif
	drmmode_destroy_bo_pixmap(dst);
 out_free_src:
	drmmode_destroy_bo_pixmap(src);
d475 94
d570 36
a605 4
fallback:
	/* map and memset the bo */
	if (radeon_bo_map(info->front_bo, 1))
		return;
d607 6
a612 2
	memset(info->front_bo->ptr, 0x00, info->front_bo->size);
	radeon_bo_unmap(info->front_bo);
d627 1
a627 1
	uint32_t *output_ids;
a634 1
	int height;
a644 1
	height = RADEON_ALIGN(pScrn->virtualY, drmmode_get_height_align(pScrn, tiling_flags));
d651 1
a651 1
				   pScrn->virtualX, height,
a672 1
	}
d674 7
a680 5
	output_ids = calloc(sizeof(uint32_t), xf86_config->num_output);
	if (!output_ids) {
		ret = FALSE;
		goto done;
	}
a681 1
	if (mode) {
d705 1
a705 1
			x = drmmode_crtc->scanout_pixmap_x;
d707 3
d712 2
a713 2
		if (drmmode_crtc->rotate_fb_id) {
			fb_id = drmmode_crtc->rotate_fb_id;
d715 43
d759 4
a762 3
		ret = drmModeSetCrtc(drmmode->fd, drmmode_crtc->mode_crtc->crtc_id,
				     fb_id, x, y, output_ids, output_count, &kmode);
		if (ret)
d764 4
a767 2
				   "failed to set mode: %s", strerror(-ret));
		else
d772 3
d801 1
d860 16
a883 2
	ScrnInfoPtr pScrn = crtc->scrn;
	RADEONInfoPtr info = RADEONPTR(pScrn);
a884 23
	drmmode_ptr drmmode = drmmode_crtc->drmmode;
	int size;
	struct radeon_bo *rotate_bo;
	int ret;
	unsigned long rotate_pitch;
	int base_align;

	/* rotation requires acceleration */
	if (info->r600_shadow_fb) {
		xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
			   "Rotation requires acceleration!\n");
		return NULL;
	}

	rotate_pitch =
		RADEON_ALIGN(width, drmmode_get_pitch_align(crtc->scrn, drmmode->cpp, 0)) * drmmode->cpp;
	height = RADEON_ALIGN(height, drmmode_get_height_align(crtc->scrn, 0));
	base_align = drmmode_get_base_align(crtc->scrn, drmmode->cpp, 0);
	size = RADEON_ALIGN(rotate_pitch * height, RADEON_GPU_PAGE_SIZE);

	rotate_bo = radeon_bo_open(drmmode->bufmgr, 0, size, base_align, RADEON_GEM_DOMAIN_VRAM, 0);
	if (rotate_bo == NULL)
		return NULL;
d886 2
a887 12
	radeon_bo_map(rotate_bo, 1);

	ret = drmModeAddFB(drmmode->fd, width, height, crtc->scrn->depth,
			   crtc->scrn->bitsPerPixel, rotate_pitch,
			   rotate_bo->handle,
			   &drmmode_crtc->rotate_fb_id);
	if (ret) {
		ErrorF("failed to add rotate fb\n");
	}

	drmmode_crtc->rotate_bo = rotate_bo;
	return drmmode_crtc->rotate_bo->ptr;
a892 1
	ScrnInfoPtr pScrn = crtc->scrn;
a893 20
	drmmode_ptr drmmode = drmmode_crtc->drmmode;
	unsigned long rotate_pitch;
	PixmapPtr rotate_pixmap;

	if (!data)
		data = drmmode_crtc_shadow_allocate (crtc, width, height);

	rotate_pitch = RADEON_ALIGN(width, drmmode_get_pitch_align(pScrn, drmmode->cpp, 0)) * drmmode->cpp;

	rotate_pixmap = drmmode_create_bo_pixmap(pScrn,
						 width, height,
						 pScrn->depth,
						 pScrn->bitsPerPixel,
						 rotate_pitch,
						 0, drmmode_crtc->rotate_bo, NULL);
	if (rotate_pixmap == NULL) {
		xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
			   "Couldn't allocate shadow pixmap for rotated CRTC\n");
	}
	return rotate_pixmap;
d895 5
d908 1
a908 11
	if (rotate_pixmap)
		drmmode_destroy_bo_pixmap(rotate_pixmap);

	if (data) {
		drmModeRmFB(drmmode->fd, drmmode_crtc->rotate_fb_id);
		drmmode_crtc->rotate_fb_id = 0;
		radeon_bo_unmap(drmmode_crtc->rotate_bo);
		radeon_bo_unref(drmmode_crtc->rotate_bo);
		drmmode_crtc->rotate_bo = NULL;
	}

d935 1
a935 1
		drmmode_crtc->scanout_pixmap_x = 0;
d974 4
a977 2
	drmmode_crtc->scanout_pixmap_x = this_x;
#ifdef HAS_DIRTYTRACKING2
d986 1
a986 1
static const xf86CrtcFuncsRec drmmode_crtc_funcs = {
d1032 2
a1033 2
static void
drmmode_crtc_init(ScrnInfoPtr pScrn, drmmode_ptr drmmode, int num)
d1037 1
d1041 1
a1041 1
		return;
d1044 1
a1044 1
	drmmode_crtc->mode_crtc = drmModeGetCrtc(drmmode->fd, drmmode->mode_res->crtcs[num]);
d1049 6
a1054 1
	return;
d1164 1
d1168 5
a1172 2
	if (mode != DPMSModeOn && output->crtc)
		drmmode_do_crtc_dpms(output->crtc, mode);
d1177 9
a1185 2
	if (mode == DPMSModeOn && output->crtc)
		drmmode_do_crtc_dpms(output->crtc, mode);
d1394 46
d1441 56
a1496 1
drmmode_output_init(ScrnInfoPtr pScrn, drmmode_ptr drmmode, int num, int *num_dvi, int *num_hdmi)
d1498 1
d1505 1
d1510 1
a1510 1
	koutput = drmModeGetConnector(drmmode->fd, drmmode->mode_res->connectors[num]);
d1512 13
a1524 1
		return;
d1538 21
a1558 36
	if (koutput->connector_type >= NUM_OUTPUT_NAMES)
		snprintf(name, 32, "Unknown%d-%d", koutput->connector_type,
			 koutput->connector_type_id - 1);
#ifdef RADEON_PIXMAP_SHARING
	else if (pScrn->is_gpu)
		snprintf(name, 32, "%s-%d-%d",
			 output_names[koutput->connector_type], pScrn->scrnIndex - GPU_SCREEN_OFFSET + 1,
			 koutput->connector_type_id - 1);
#endif
	else {
		/* need to do smart conversion here for compat with non-kms ATI driver */
		if (koutput->connector_type_id == 1) {
			switch(koutput->connector_type) {
			case DRM_MODE_CONNECTOR_DVII:
			case DRM_MODE_CONNECTOR_DVID:
			case DRM_MODE_CONNECTOR_DVIA:
				snprintf(name, 32, "%s-%d", output_names[koutput->connector_type], *num_dvi);
				(*num_dvi)++;
				break;
			case DRM_MODE_CONNECTOR_HDMIA:
			case DRM_MODE_CONNECTOR_HDMIB:
				snprintf(name, 32, "%s-%d", output_names[koutput->connector_type], *num_hdmi);
				(*num_hdmi)++;
				break;
			case DRM_MODE_CONNECTOR_VGA:
			case DRM_MODE_CONNECTOR_DisplayPort:
				snprintf(name, 32, "%s-%d", output_names[koutput->connector_type],
					 koutput->connector_type_id - 1);
				break;
			default:
				snprintf(name, 32, "%s", output_names[koutput->connector_type]);
				break;
			}
		} else {
			snprintf(name, 32, "%s-%d", output_names[koutput->connector_type],
				 koutput->connector_type_id - 1);
d1567 1
a1567 1
			if (info->IsPrimary && (num != 0))
d1585 1
a1585 1
	drmmode_output->output_id = drmmode->mode_res->connectors[num];
d1616 6
a1621 1
	return;
d1629 1
a1629 1
	
d1659 1
a1659 1
drmmode_clones_init(ScrnInfoPtr scrn, drmmode_ptr drmmode)
d1674 2
a1675 2
			for (k = 0; k < drmmode->mode_res->count_encoders; k++) {
				if (drmmode->mode_res->encoders[k] == drmmode_output->mode_encoders[j]->encoder_id)
d1793 1
d1802 3
d1815 1
a1815 1
	if (info->allowColorTiling) {
d1827 2
a1828 2
	height = RADEON_ALIGN(height, drmmode_get_height_align(scrn, tiling_flags));
	screen_size = RADEON_ALIGN(pitch * height, RADEON_GPU_PAGE_SIZE);
d1871 3
a1873 1
			tiling_flags |= eg_tile_split(surface.tile_split) << RADEON_TILING_EG_TILE_SPLIT_SHIFT;
d1898 4
a1901 1
	info->front_bo = radeon_bo_open(info->bufmgr, 0, screen_size, base_align, RADEON_GEM_DOMAIN_VRAM, 0);
d1950 18
a1977 3
	if (info->use_glamor)
		radeon_glamor_create_screen_resources(scrn->pScreen);

d2003 14
a2016 2
drmmode_vblank_handler(int fd, unsigned int frame, unsigned int tv_sec,
			unsigned int tv_usec, void *event_data)
d2018 7
a2024 1
	radeon_dri2_frame_event_handler(frame, tv_sec, tv_usec, event_data);
d2028 1
a2028 2
drmmode_flip_handler(int fd, unsigned int frame, unsigned int tv_sec,
		     unsigned int tv_usec, void *event_data)
a2031 1
	drmmode_ptr drmmode = flipdata->drmmode;
d2037 1
a2037 2
		flipdata->fe_tv_sec = tv_sec;
		flipdata->fe_tv_usec = tv_usec;
a2038 1
	free(flipcarrier);
d2040 6
a2045 4
	/* Last crtc completed flip? */
	flipdata->flip_count--;
	if (flipdata->flip_count > 0)
		return;
d2047 3
a2049 5
	/* Release framebuffer */
	drmModeRmFB(drmmode->fd, flipdata->old_fb_id);

	if (flipdata->event_data == NULL)
		return;
d2051 1
a2051 5
	/* Deliver cached msc, ust from reference crtc to flip event handler */
	radeon_dri2_flip_event_handler(flipdata->fe_frame, flipdata->fe_tv_sec,
				       flipdata->fe_tv_usec, flipdata->event_data);

	free(flipdata);
d2068 2
d2071 2
d2078 2
a2079 2
	drmmode->mode_res = drmModeGetResources(drmmode->fd);
	if (!drmmode->mode_res)
d2082 7
a2088 4
	xf86CrtcSetSizeRange(pScrn, 320, 200, drmmode->mode_res->max_width, drmmode->mode_res->max_height);
	for (i = 0; i < drmmode->mode_res->count_crtcs; i++)
		if (!xf86IsEntityShared(pScrn->entityList[0]) || pScrn->confScreen->device->screen == i)
			drmmode_crtc_init(pScrn, drmmode, i);
d2090 20
a2109 2
	for (i = 0; i < drmmode->mode_res->count_connectors; i++)
		drmmode_output_init(pScrn, drmmode, i, &num_dvi, &num_hdmi);
d2112 1
a2112 1
	drmmode_clones_init(pScrn, drmmode);
d2121 2
a2122 2
	drmmode->event_context.vblank_handler = drmmode_vblank_handler;
	drmmode->event_context.page_flip_handler = drmmode_flip_handler;
d2124 1
d2193 2
a2194 1
Bool drmmode_set_desired_modes(ScrnInfoPtr pScrn, drmmode_ptr drmmode)
a2198 2
	drmmode_copy_fb(pScrn, drmmode);

d2207 6
a2212 3
			drmmode_do_crtc_dpms(crtc, DPMSModeOff);
			drmModeSetCrtc(drmmode->fd, drmmode_crtc->mode_crtc->crtc_id,
				       0, 0, 0, NULL, 0, NULL);
d2245 12
a2256 3
		if (!crtc->funcs->set_mode_major(crtc, &crtc->desiredMode, crtc->desiredRotation,
						 crtc->desiredX, crtc->desiredY))
			return FALSE;
d2346 69
d2426 1
a2426 1
	RRGetInfo(xf86ScrnToScreen(scrn), TRUE);
d2480 4
a2483 1
Bool radeon_do_pageflip(ScrnInfoPtr scrn, struct radeon_bo *new_front, void *data, int ref_crtc_hw_id)
d2490 1
a2490 1
	int i, old_fb_id;
a2491 1
	int height, emitted = 0;
d2493 2
a2494 1
	drmmode_flipevtcarrier_ptr flipcarrier;
a2504 1
	height = RADEON_ALIGN(scrn->virtualY, drmmode_get_height_align(scrn, tiling_flags));
d2509 7
d2519 2
a2520 2
	old_fb_id = drmmode->fb_id;
	if (drmModeAddFB(drmmode->fd, scrn->virtualX, height,
d2522 2
a2523 2
			 new_front->handle, &drmmode->fb_id))
		goto error_out;
a2524 6
        flipdata = calloc(1, sizeof(drmmode_flipdata_rec));
        if (!flipdata) {
             xf86DrvMsg(scrn->scrnIndex, X_WARNING,
                        "flip queue: data alloc failed.\n");
             goto error_undo;
        }
d2537 2
d2551 1
a2551 3
			if (emitted == 0)
				free(flipdata);
			goto error_undo;
d2560 10
d2571 2
a2572 1
				    drmmode->fb_id, DRM_MODE_PAGE_FLIP_EVENT, flipcarrier)) {
d2575 1
a2575 4
			free(flipcarrier);
			if (emitted == 0)
				free(flipdata);
			goto error_undo;
d2577 2
a2578 1
		emitted++;
d2581 8
a2588 2
	flipdata->old_fb_id = old_fb_id;
	return TRUE;
d2590 6
a2595 3
error_undo:
	drmModeRmFB(drmmode->fd, drmmode->fb_id);
	drmmode->fb_id = old_fb_id;
a2596 1
error_out:
a2600 1

@


1.9
log
@Update to xf86-video-ati 7.3.0. Tested by jsg@@ ajacoutot@@.
@
text
@a38 1
#include "radeon_drm.h"
d249 1
a249 1
drmmode_crtc_dpms(xf86CrtcPtr crtc, int mode)
d310 6
a965 1
		free(drmmode_output->mode_encoders);
d967 1
d981 3
d986 3
a988 1
	return;
d1846 1
d1953 11
a1963 8
    xf86DrvMsgVerb(pScrn->scrnIndex, X_INFO, RADEON_LOGLEVEL_DEBUG,
                  "Initializing kms color map\n");
    if (!miCreateDefColormap(pScreen))
        return FALSE;
    /* all radeons support 10 bit CLUTs */
    if (!xf86HandleColormaps(pScreen, 256, 10,
                             drmmode_load_palette, NULL,
                             CMAP_PALETTED_TRUECOLOR
d1965 1
a1965 1
                             | CMAP_LOAD_EVEN_IF_OFFSCREEN
d1967 3
a1969 2
                             | CMAP_RELOAD_ON_MODE_SWITCH))
         return FALSE;
@


1.8
log
@Fix shadowfb on big-endian machines.

ok matthieu@@
@
text
@d1481 1
a1481 1
	int screen_size;
d2017 3
@


1.7
log
@Update to xf86-video-ati 7.2.0, requested by jsg@@

It fixes an endianess problem with kms and the in tree x86-video-ati
among other things.
It has been tested on various i386/amd64/sparc64/macppc machines
on a range of hardware from r100->northern islands.
@
text
@d1593 3
@


1.6
log
@Remove a local change that disabled the pageflipping
code in the KMS path.  Previously disabled due to
not having the required libdrm parts.
ok matthieu@@
@
text
@a32 1
#ifdef XF86DRM_MODE
d34 1
d52 38
d110 2
a111 1
	exaMoveInPixmap(pixmap);
d130 2
d151 5
d225 24
d253 7
a259 1
//	drmmode_ptr drmmode = drmmode_crtc->drmmode;
d261 44
a304 1
	drmmode_crtc->dpms_mode = mode;
d306 1
a306 5
#if 0
	/* bonghits in the randr 1.2 - uses dpms to disable crtc - bad buzz */
	if (mode == DPMSModeOff) {
//		drmModeSetCrtc(drmmode->fd, drmmode_crtc->mode_crtc->crtc_id,
//			       0, 0, 0, NULL, 0, NULL);
d308 1
a308 1
#endif
d364 1
a364 1
	if (info->accelOn == FALSE)
d377 9
d402 2
a403 2
			     drmmode_get_pitch_align(pScrn, info->CurrentLayout.pixel_bytes, tiling_flags)) *
		info->CurrentLayout.pixel_bytes;
d467 2
a468 2
	pitch = RADEON_ALIGN(pScrn->displayWidth, drmmode_get_pitch_align(pScrn, info->CurrentLayout.pixel_bytes, tiling_flags)) *
		info->CurrentLayout.pixel_bytes;
a496 1
#if XORG_VERSION_CURRENT >= XORG_VERSION_NUMERIC(1,5,99,0,0)
a497 1
#endif
a521 1
#if XORG_VERSION_CURRENT >= XORG_VERSION_NUMERIC(1,7,0,0,0)
d524 1
a524 2
#endif
		
d528 6
d596 2
d601 1
d606 1
a606 1
	for (i = 0; i < 64 * 64; i++)
d614 2
d619 2
a620 1
	drmModeSetCursor(drmmode->fd, drmmode_crtc->mode_crtc->crtc_id, 0, 64, 64);
d627 2
d633 2
a634 1
	drmModeSetCursor(drmmode->fd, drmmode_crtc->mode_crtc->crtc_id, handle, 64, 64);
d739 62
d815 3
d839 1
a839 1
	r = drmCommandWriteRead(info->dri->drmFD, DRM_RADEON_INFO, &ginfo, sizeof(ginfo));
d876 2
d911 3
d923 2
a925 1
		}
a1142 1
#ifdef RANDR_12_INTERFACE
a1144 1
#endif
d1185 2
d1216 37
a1252 24
	/* need to do smart conversion here for compat with non-kms ATI driver */
	if (koutput->connector_type_id == 1) {
	    switch(koutput->connector_type) {
	    case DRM_MODE_CONNECTOR_DVII:
	    case DRM_MODE_CONNECTOR_DVID:
	    case DRM_MODE_CONNECTOR_DVIA:
		snprintf(name, 32, "%s-%d", output_names[koutput->connector_type], *num_dvi);
		(*num_dvi)++;
		break;
	    case DRM_MODE_CONNECTOR_HDMIA:
	    case DRM_MODE_CONNECTOR_HDMIB:
		snprintf(name, 32, "%s-%d", output_names[koutput->connector_type], *num_hdmi);
		(*num_hdmi)++;
		break;
	    case DRM_MODE_CONNECTOR_VGA:
	    case DRM_MODE_CONNECTOR_DisplayPort:
		snprintf(name, 32, "%s-%d", output_names[koutput->connector_type], koutput->connector_type_id - 1);
		break;
	    default:
		snprintf(name, 32, "%s", output_names[koutput->connector_type]);
		break;
	    }
	} else {
	    snprintf(name, 32, "%s-%d", output_names[koutput->connector_type], koutput->connector_type_id - 1);
d1391 3
a1393 1
		if (tiling)
d1482 1
a1482 1
	int cpp = info->CurrentLayout.pixel_bytes;
d1527 2
d1636 3
a1718 1
	xf86CrtcConfigPtr xf86_config;
a1721 1
	xf86_config = XF86_CRTC_CONFIG_PTR(pScrn);
d1740 4
d1758 5
a1762 2
	if (pRADEONEnt->fd_wakeup_registered != serverGeneration &&
	    info->dri->pKernelDRMVersion->version_minor >= 4) {
d1767 18
d1788 1
a1929 1
#ifdef RANDR_12_INTERFACE
a1932 1
#endif
d2037 2
a2038 2
	pitch = RADEON_ALIGN(scrn->displayWidth, drmmode_get_pitch_align(scrn, info->CurrentLayout.pixel_bytes, tiling_flags)) *
		info->CurrentLayout.pixel_bytes;
a2118 1
#endif
@


1.5
log
@Update to xf86-video-ati 6.14.6. Tested by mpi@@, brad, eric@@, ajacoutot@@.
@
text
@a1443 1
#ifdef __linux__
a1477 1
#endif
a1519 1
#ifdef __linux__
a1520 1
#endif
a1768 1
#ifdef __linux__
a1870 1
#endif
@


1.4
log
@Update to xf86-video-ati 6.14.4. Tested by jasper@@, krw@@, mpi@@, shadchin@@
@
text
@d56 1
a56 1
					  struct radeon_bo *bo)
d76 3
a78 1
		if (surface) {
d182 1
a182 3
#if 0
	xf86CrtcConfigPtr   xf86_config = XF86_CRTC_CONFIG_PTR(crtc->scrn);
//	drmmode_crtc_private_ptr drmmode_crtc = crtc->driver_private;
d185 3
d198 1
a198 1
			ScrnInfoPtr pScrn, int crtc_id)
d200 1
a200 3
	xf86CrtcConfigPtr xf86_config = XF86_CRTC_CONFIG_PTR(pScrn);
	drmmode_crtc_private_ptr drmmode_crtc;
	PixmapPtr pixmap;
d205 1
a205 3
	drmmode_crtc = xf86_config->crtc[crtc_id]->driver_private;

	fbcon = drmModeGetFB(drmmode->fd, drmmode_crtc->mode_crtc->buffer_id);
d209 5
d218 1
a218 1
		return NULL;
d225 1
a225 1
		return NULL;
d230 1
a230 4
					  fbcon->pitch, 0, bo);
	if (!pixmap) 
		return NULL;

d232 1
d243 1
a243 1
	int crtc_id = 0;
d250 1
a250 1
		return;
d253 1
a253 2
		xf86CrtcPtr crtc = xf86_config->crtc[i];
		drmmode_crtc_private_ptr drmmode_crtc;
a254 1
		drmmode_crtc = crtc->driver_private;
d256 1
a256 1
			crtc_id = i;
d259 4
a262 1
	src = create_pixmap_for_fbcon(drmmode, pScrn, crtc_id);
d264 1
a264 1
		return;
d284 1
a284 1
				       tiling_flags, info->front_bo);
d303 1
d305 7
d565 1
a565 1
						 0, drmmode_crtc->rotate_bo);
d1257 1
a1257 1
	ScreenPtr   screen = screenInfo.screens[scrn->scrnIndex];
d1481 1
d1526 1
a1526 1
       return TRUE;
d1531 2
a1532 2
       RADEONEntPtr pRADEONEnt = RADEONEntPriv(pScrn);
       RADEONInfoPtr info = RADEONPTR(pScrn);
d1534 2
a1535 2
       if (pRADEONEnt->fd_wakeup_registered != serverGeneration &&
           info->dri->pKernelDRMVersion->version_minor >= 4) {
d1560 1
a1560 1
void drmmode_adjust_frame(ScrnInfoPtr pScrn, drmmode_ptr drmmode, int x, int y, int flags)
d1722 1
a1722 1
	RRGetInfo(screenInfo.screens[scrn->scrnIndex], TRUE);
d1875 1
@


1.3
log
@Re-update xf86-video-ati to 6.14.3.

Because of ati.c revision 1.5, it will not be selected by
autoconfiguration code, so people who want to run this version of the
driver on their radeon cards need an explicit "Device" section in
xorg.conf.
@
text
@d52 1
a52 1
static PixmapPtr drmmode_create_bo_pixmap(ScreenPtr pScreen,
d55 2
a56 1
					  int pitch, struct radeon_bo *bo)
d58 2
d61 1
d74 33
a198 1
	ScreenPtr pScreen = pScrn->pScreen;
d224 1
a224 1
	pixmap = drmmode_create_bo_pixmap(pScreen, fbcon->width, fbcon->height,
d226 1
a226 1
					  fbcon->pitch, bo);
d264 7
a270 3
		if (info->ChipFamily >= CHIP_FAMILY_R600)
			tiling_flags |= RADEON_TILING_MICRO;
		else
d278 1
a278 1
	dst = drmmode_create_bo_pixmap(pScreen, pScrn->virtualX,
d281 1
a281 1
				       info->front_bo);
d294 3
d335 3
d549 1
a549 1
	rotate_pixmap = drmmode_create_bo_pixmap(pScrn->pScreen,
d554 1
a554 1
						 drmmode_crtc->rotate_bo);
d1060 1
a1060 1
	output->possible_crtcs = 0x7f;
d1252 3
a1254 1
	uint32_t tiling_flags = 0;
d1268 7
a1274 3
		if (info->ChipFamily >= CHIP_FAMILY_R600)
			tiling_flags |= RADEON_TILING_MICRO;
		else
d1281 50
d1346 1
a1346 1
	info->front_bo = radeon_bo_open(info->bufmgr, 0, screen_size, 0, RADEON_GEM_DOMAIN_VRAM, 0);
d1372 2
a1482 1
	RADEONEntPtr pRADEONEnt   = RADEONEntPriv(pScrn);
a1483 1
	RADEONInfoPtr info = RADEONPTR(pScrn);
d1513 11
a1523 1
	if (!pRADEONEnt->fd_wakeup_registered && info->dri->pKernelDRMVersion->version_minor >= 4) {
d1527 1
a1527 1
		pRADEONEnt->fd_wakeup_registered = TRUE;
a1528 2

	return TRUE;
d1785 3
@


1.2
log
@Revert the update to xf86-video-ati 6.14.3. Requested by espie@@
who experiemnts regressions with this driver.
@
text
@@


1.1
log
@Update to xf86-video-ati 6.14.3. Tested by many.
@
text
@@

