head	1.10;
access;
symbols
	OPENBSD_6_0:1.9.0.2
	OPENBSD_6_0_BASE:1.9
	OPENBSD_5_9:1.8.0.4
	OPENBSD_5_9_BASE:1.8
	OPENBSD_5_8:1.8.0.2
	OPENBSD_5_8_BASE:1.8
	OPENBSD_5_7:1.7.0.4
	OPENBSD_5_7_BASE:1.7
	OPENBSD_5_6:1.7.0.2
	OPENBSD_5_6_BASE:1.7
	OPENBSD_5_5:1.6.0.2
	OPENBSD_5_5_BASE:1.6
	OPENBSD_5_4:1.5.0.4
	OPENBSD_5_4_BASE:1.5
	OPENBSD_5_3:1.5.0.2
	OPENBSD_5_3_BASE:1.5
	OPENBSD_5_2:1.4.0.2
	OPENBSD_5_2_BASE:1.4;
locks; strict;
comment	@ * @;


1.10
date	2016.11.13.14.42.27;	author matthieu;	state Exp;
branches;
next	1.9;
commitid	VCI3KGRPv1Ex2rp2;

1.9
date	2016.04.02.07.37.34;	author matthieu;	state Exp;
branches;
next	1.8;
commitid	bsyGwvYIwQ6RE8Qj;

1.8
date	2015.04.14.19.55.49;	author matthieu;	state Exp;
branches;
next	1.7;
commitid	cZqnMrCmViqubI1u;

1.7
date	2014.04.09.20.21.16;	author matthieu;	state Exp;
branches;
next	1.6;

1.6
date	2013.08.16.17.04.10;	author matthieu;	state Exp;
branches;
next	1.5;

1.5
date	2012.08.08.16.25.22;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2012.06.07.20.55.34;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2012.03.04.16.01.20;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2012.02.06.22.53.13;	author matthieu;	state dead;
branches;
next	1.1;

1.1
date	2012.01.25.21.33.35;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.10
log
@Update to xf86-video-ati 7.7.1
Tested by jsg@@,  Rafael Sadowski and myself on various hardware.
@
text
@/*
 * Copyright 2008 Kristian Høgsberg 
 * Copyright 2008 Jérôme Glisse
 *
 * All Rights Reserved.
 *
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation on the rights to use, copy, modify, merge,
 * publish, distribute, sublicense, and/or sell copies of the Software,
 * and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice (including the
 * next paragraph) shall be included in all copies or substantial
 * portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NON-INFRINGEMENT.  IN NO EVENT SHALL ATI, VA LINUX SYSTEMS AND/OR
 * THEIR SUPPLIERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
 * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 */
#ifdef HAVE_CONFIG_H
#include "config.h"
#endif

#include "radeon.h"
#include "radeon_dri2.h"
#include "radeon_video.h"

#ifdef DRI2

#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <errno.h>

#include "radeon_bo_helper.h"
#include "radeon_version.h"
#include "radeon_list.h"

#include "radeon_bo_gem.h"

#include <xf86Priv.h>

#if DRI2INFOREC_VERSION >= 9
#define USE_DRI2_PRIME
#endif

#define FALLBACK_SWAP_DELAY 16

#include "radeon_glamor.h"

typedef DRI2BufferPtr BufferPtr;

struct dri2_buffer_priv {
    PixmapPtr   pixmap;
    unsigned int attachment;
    unsigned int refcnt;
};


struct dri2_window_priv {
    xf86CrtcPtr crtc;
    int vblank_delta;
};

static DevPrivateKeyRec dri2_window_private_key_rec;
#define dri2_window_private_key (&dri2_window_private_key_rec)

#define get_dri2_window_priv(window) \
    ((struct dri2_window_priv*) \
     dixLookupPrivate(&(window)->devPrivates, dri2_window_private_key))


/* Get GEM flink name for a pixmap */
static Bool
radeon_get_flink_name(RADEONInfoPtr info, PixmapPtr pixmap, uint32_t *name)
{
    struct radeon_bo *bo = radeon_get_pixmap_bo(pixmap);
    struct drm_gem_flink flink;

    if (bo)
	return radeon_gem_get_kernel_name(bo, name) == 0;

    if (radeon_get_pixmap_handle(pixmap, &flink.handle)) {
	if (drmIoctl(info->dri2.drm_fd, DRM_IOCTL_GEM_FLINK, &flink) != 0)
	    return FALSE;

	*name = flink.name;
	return TRUE;
    }

    return FALSE;
}

static BufferPtr
radeon_dri2_create_buffer2(ScreenPtr pScreen,
			   DrawablePtr drawable,
			   unsigned int attachment,
			   unsigned int format)
{
    ScrnInfoPtr pScrn = xf86ScreenToScrn(pScreen);
    RADEONInfoPtr info = RADEONPTR(pScrn);
    BufferPtr buffers;
    struct dri2_buffer_priv *privates;
    PixmapPtr pixmap;
    int flags;
    unsigned front_width;
    uint32_t tiling = 0;
    unsigned aligned_width = drawable->width;
    unsigned height = drawable->height;
    Bool is_glamor_pixmap = FALSE;
    int depth;
    int cpp;

    if (format) {
	depth = format;

	switch (depth) {
	case 15:
	    cpp = 2;
	    break;
	case 24:
	    cpp = 4;
	    break;
	default:
	    cpp = depth / 8;
	}
    } else {
	depth = drawable->depth;
	cpp = drawable->bitsPerPixel / 8;
    }

    front_width = pScreen->GetScreenPixmap(pScreen)->drawable.width;

    pixmap = NULL;

    if (attachment == DRI2BufferFrontLeft) {
	uint32_t handle;

        pixmap = get_drawable_pixmap(drawable);
	if (pScreen != pixmap->drawable.pScreen)
	    pixmap = NULL;
	else if (info->use_glamor && !radeon_get_pixmap_handle(pixmap, &handle)) {
	    is_glamor_pixmap = TRUE;
	    aligned_width = pixmap->drawable.width;
	    height = pixmap->drawable.height;
	    pixmap = NULL;
	} else
	    pixmap->refcnt++;
    }

    if (!pixmap && (is_glamor_pixmap || attachment != DRI2BufferFrontLeft)) {
	/* tile the back buffer */
	switch(attachment) {
	case DRI2BufferDepth:
	    /* macro is the preferred setting, but the 2D detiling for software
	     * fallbacks in mesa still has issues on some configurations
	     */
	    if (info->ChipFamily >= CHIP_FAMILY_R600) {
		if (info->allowColorTiling2D) {
			flags = RADEON_CREATE_PIXMAP_TILING_MACRO;
		} else {
			flags = RADEON_CREATE_PIXMAP_TILING_MICRO;
		}
		if (info->ChipFamily >= CHIP_FAMILY_CEDAR)
		    flags |= RADEON_CREATE_PIXMAP_SZBUFFER;
	    } else if (cpp == 2 && info->ChipFamily >= CHIP_FAMILY_R300)
		flags = RADEON_CREATE_PIXMAP_TILING_MACRO | RADEON_CREATE_PIXMAP_TILING_MICRO_SQUARE;
	    else
		flags = RADEON_CREATE_PIXMAP_TILING_MACRO | RADEON_CREATE_PIXMAP_TILING_MICRO;
	    if (IS_R200_3D || info->ChipFamily == CHIP_FAMILY_RV200 || info->ChipFamily == CHIP_FAMILY_RADEON)
		flags |= RADEON_CREATE_PIXMAP_DEPTH;
	    break;
	case DRI2BufferDepthStencil:
	    /* macro is the preferred setting, but the 2D detiling for software
	     * fallbacks in mesa still has issues on some configurations
	     */
	    if (info->ChipFamily >= CHIP_FAMILY_R600) {
		if (info->allowColorTiling2D) {
			flags = RADEON_CREATE_PIXMAP_TILING_MACRO;
		} else {
			flags = RADEON_CREATE_PIXMAP_TILING_MICRO;
		}
		if (info->ChipFamily >= CHIP_FAMILY_CEDAR)
		    flags |= RADEON_CREATE_PIXMAP_SZBUFFER;
	    } else if (cpp == 2 && info->ChipFamily >= CHIP_FAMILY_R300)
		flags = RADEON_CREATE_PIXMAP_TILING_MACRO | RADEON_CREATE_PIXMAP_TILING_MICRO_SQUARE;
	    else
		flags = RADEON_CREATE_PIXMAP_TILING_MACRO | RADEON_CREATE_PIXMAP_TILING_MICRO;
	    if (IS_R200_3D || info->ChipFamily == CHIP_FAMILY_RV200 || info->ChipFamily == CHIP_FAMILY_RADEON)
		flags |= RADEON_CREATE_PIXMAP_DEPTH;
		
	    break;
	case DRI2BufferBackLeft:
	case DRI2BufferBackRight:
	case DRI2BufferFrontLeft:
	case DRI2BufferFrontRight:
	case DRI2BufferFakeFrontLeft:
	case DRI2BufferFakeFrontRight:
	    if (info->ChipFamily >= CHIP_FAMILY_R600) {
		if (info->allowColorTiling2D) {
			flags = RADEON_CREATE_PIXMAP_TILING_MACRO;
		} else {
			flags = RADEON_CREATE_PIXMAP_TILING_MICRO;
		}
	    } else
		flags = RADEON_CREATE_PIXMAP_TILING_MACRO;
	    break;
	default:
	    flags = 0;
	}

	if (flags & RADEON_CREATE_PIXMAP_TILING_MICRO)
	    tiling |= RADEON_TILING_MICRO;
	if (flags & RADEON_CREATE_PIXMAP_TILING_MICRO_SQUARE)
	    tiling |= RADEON_TILING_MICRO_SQUARE;
	if (flags & RADEON_CREATE_PIXMAP_TILING_MACRO)
	    tiling |= RADEON_TILING_MACRO;

	    if (aligned_width == front_width)
		aligned_width = pScrn->virtualX;

	    pixmap = (*pScreen->CreatePixmap)(pScreen,
					      aligned_width,
					      height,
					      depth,
					      flags | RADEON_CREATE_PIXMAP_DRI2);
    }

    buffers = calloc(1, sizeof *buffers);
    if (buffers == NULL)
        goto error;

    if (pixmap) {
	if (!info->use_glamor) {
	    info->exa_force_create = TRUE;
	    exaMoveInPixmap(pixmap);
	    info->exa_force_create = FALSE;
	    if (exaGetPixmapDriverPrivate(pixmap) == NULL) {
		/* this happen if pixmap is non accelerable */
		goto error;
	    }
	} else if (is_glamor_pixmap) {
	    pixmap = radeon_glamor_set_pixmap_bo(drawable, pixmap);
	    pixmap->refcnt++;
	}

	if (!radeon_get_flink_name(info, pixmap, &buffers->name))
	    goto error;
    }

    privates = calloc(1, sizeof(struct dri2_buffer_priv));
    if (privates == NULL)
        goto error;

    buffers->attachment = attachment;
    if (pixmap) {
	buffers->pitch = pixmap->devKind;
	buffers->cpp = cpp;
    }
    buffers->driverPrivate = privates;
    buffers->format = format;
    buffers->flags = 0; /* not tiled */
    privates->pixmap = pixmap;
    privates->attachment = attachment;
    privates->refcnt = 1;

    return buffers;

error:
    free(buffers);
    if (pixmap)
        (*pScreen->DestroyPixmap)(pixmap);
    return NULL;
}

DRI2BufferPtr
radeon_dri2_create_buffer(DrawablePtr pDraw, unsigned int attachment,
			   unsigned int format)
{
	return radeon_dri2_create_buffer2(pDraw->pScreen, pDraw,
					  attachment, format);
}

static void
radeon_dri2_destroy_buffer2(ScreenPtr pScreen,
			    DrawablePtr drawable, BufferPtr buffers)
{
    if(buffers)
    {
        struct dri2_buffer_priv *private = buffers->driverPrivate;

        /* Trying to free an already freed buffer is unlikely to end well */
        if (private->refcnt == 0) {
            ScrnInfoPtr scrn = xf86ScreenToScrn(pScreen);

            xf86DrvMsg(scrn->scrnIndex, X_WARNING, 
                       "Attempted to destroy previously destroyed buffer.\
 This is a programming error\n");
            return;
        }

        private->refcnt--;
        if (private->refcnt == 0)
        {
	    if (private->pixmap)
                (*pScreen->DestroyPixmap)(private->pixmap);

            free(buffers->driverPrivate);
            free(buffers);
        }
    }
}

void
radeon_dri2_destroy_buffer(DrawablePtr pDraw, DRI2BufferPtr buf)
{
    radeon_dri2_destroy_buffer2(pDraw->pScreen, pDraw, buf);
}


static inline PixmapPtr GetDrawablePixmap(DrawablePtr drawable)
{
    if (drawable->type == DRAWABLE_PIXMAP)
        return (PixmapPtr)drawable;
    else {
        struct _Window *pWin = (struct _Window *)drawable;
        return drawable->pScreen->GetWindowPixmap(pWin);
    }
}
static void
radeon_dri2_copy_region2(ScreenPtr pScreen,
			 DrawablePtr drawable,
			 RegionPtr region,
			 BufferPtr dest_buffer,
			 BufferPtr src_buffer)
{
    struct dri2_buffer_priv *src_private = src_buffer->driverPrivate;
    struct dri2_buffer_priv *dst_private = dest_buffer->driverPrivate;
    ScrnInfoPtr pScrn = xf86ScreenToScrn(pScreen);
    DrawablePtr src_drawable;
    DrawablePtr dst_drawable;
    RegionPtr copy_clip;
    GCPtr gc;
    RADEONInfoPtr info = RADEONPTR(pScrn);
    Bool vsync;
    Bool translate = FALSE;
    int off_x = 0, off_y = 0;
    PixmapPtr dst_ppix;

    dst_ppix = dst_private->pixmap;
    src_drawable = &src_private->pixmap->drawable;
    dst_drawable = &dst_private->pixmap->drawable;

    if (src_private->attachment == DRI2BufferFrontLeft) {
#ifdef USE_DRI2_PRIME
	if (drawable->pScreen != pScreen) {
	    src_drawable = DRI2UpdatePrime(drawable, src_buffer);
	    if (!src_drawable)
		return;
	} else
#endif
	    src_drawable = drawable;
    }
    if (dst_private->attachment == DRI2BufferFrontLeft) {
#ifdef USE_DRI2_PRIME
	if (drawable->pScreen != pScreen) {
	    dst_drawable = DRI2UpdatePrime(drawable, dest_buffer);
	    if (!dst_drawable)
		return;
	    dst_ppix = (PixmapPtr)dst_drawable;
	    if (dst_drawable != drawable)
		translate = TRUE;
	} else
#endif
	    dst_drawable = drawable;
    }

    if (translate && drawable->type == DRAWABLE_WINDOW) {
	PixmapPtr pPix = GetDrawablePixmap(drawable);

	off_x = drawable->x - pPix->screen_x;
	off_y = drawable->y - pPix->screen_y;
    }
    gc = GetScratchGC(dst_drawable->depth, pScreen);
    copy_clip = REGION_CREATE(pScreen, NULL, 0);
    REGION_COPY(pScreen, copy_clip, region);

    if (translate) {
	REGION_TRANSLATE(pScreen, copy_clip, off_x, off_y);
    }

    (*gc->funcs->ChangeClip) (gc, CT_REGION, copy_clip, 0);
    ValidateGC(dst_drawable, gc);

    /* If this is a full buffer swap or frontbuffer flush, throttle on the
     * previous one
     */
    if (dst_private->attachment == DRI2BufferFrontLeft) {
	if (REGION_NUM_RECTS(region) == 1) {
	    BoxPtr extents = REGION_EXTENTS(pScreen, region);

	    if (extents->x1 == 0 && extents->y1 == 0 &&
		extents->x2 == drawable->width &&
		extents->y2 == drawable->height) {
		struct radeon_bo *bo = radeon_get_pixmap_bo(dst_ppix);

		if (bo)
		    radeon_bo_wait(bo);
	    }
	}
    }

    vsync = info->accel_state->vsync;

    /* Driver option "SwapbuffersWait" defines if we vsync DRI2 copy-swaps. */ 
    info->accel_state->vsync = info->swapBuffersWait;
    info->accel_state->force = TRUE;

    (*gc->ops->CopyArea)(src_drawable, dst_drawable, gc,
                         0, 0, drawable->width, drawable->height, off_x, off_y);

    info->accel_state->force = FALSE;
    info->accel_state->vsync = vsync;

    FreeScratchGC(gc);
}

void
radeon_dri2_copy_region(DrawablePtr pDraw, RegionPtr pRegion,
			 DRI2BufferPtr pDstBuffer, DRI2BufferPtr pSrcBuffer)
{
    return radeon_dri2_copy_region2(pDraw->pScreen, pDraw, pRegion,
				     pDstBuffer, pSrcBuffer);
}

enum DRI2FrameEventType {
    DRI2_SWAP,
    DRI2_FLIP,
    DRI2_WAITMSC,
};

typedef struct _DRI2FrameEvent {
    XID drawable_id;
    ClientPtr client;
    enum DRI2FrameEventType type;
    unsigned frame;
    xf86CrtcPtr crtc;
    OsTimerPtr timer;
    uintptr_t drm_queue_seq;

    /* for swaps & flips only */
    DRI2SwapEventPtr event_complete;
    void *event_data;
    DRI2BufferPtr front;
    DRI2BufferPtr back;
} DRI2FrameEventRec, *DRI2FrameEventPtr;

static int DRI2InfoCnt;

static void
radeon_dri2_ref_buffer(BufferPtr buffer)
{
    struct dri2_buffer_priv *private = buffer->driverPrivate;
    private->refcnt++;
}

static void
radeon_dri2_unref_buffer(BufferPtr buffer)
{
    if (buffer) {
        struct dri2_buffer_priv *private = buffer->driverPrivate;
        radeon_dri2_destroy_buffer(&(private->pixmap->drawable), buffer);
    }
}

static void
radeon_dri2_client_state_changed(CallbackListPtr *ClientStateCallback, pointer data, pointer calldata)
{
    NewClientInfoRec *clientinfo = calldata;
    ClientPtr pClient = clientinfo->client;

    switch (pClient->clientState) {
    case ClientStateRetained:
    case ClientStateGone:
        radeon_drm_abort_client(pClient);
        break;
    default:
        break;
    }
}

/*
 * Get current frame count delta for the specified drawable and CRTC
 */
static uint32_t radeon_get_msc_delta(DrawablePtr pDraw, xf86CrtcPtr crtc)
{
    drmmode_crtc_private_ptr drmmode_crtc = crtc->driver_private;

    if (pDraw && pDraw->type == DRAWABLE_WINDOW)
	return drmmode_crtc->interpolated_vblanks +
	    get_dri2_window_priv((WindowPtr)pDraw)->vblank_delta;

    return drmmode_crtc->interpolated_vblanks;
}

/*
 * Get current frame count and timestamp of the specified CRTC
 */
static Bool radeon_dri2_get_crtc_msc(xf86CrtcPtr crtc, CARD64 *ust, CARD64 *msc)
{
    drmmode_crtc_private_ptr drmmode_crtc = crtc->driver_private;

    if (!radeon_crtc_is_enabled(crtc) ||
	 drmmode_crtc_get_ust_msc(crtc, ust, msc) != Success) {
	/* CRTC is not running, extrapolate MSC and timestamp */
	ScrnInfoPtr scrn = crtc->scrn;
	RADEONInfoPtr info = RADEONPTR(scrn);
	CARD64 now, delta_t, delta_seq;

	if (!drmmode_crtc->dpms_last_ust)
	    return FALSE;

	if (drmmode_get_current_ust(info->dri2.drm_fd, &now) != 0) {
	    xf86DrvMsg(scrn->scrnIndex, X_ERROR,
		       "%s cannot get current time\n", __func__);
	    return FALSE;
	}

	delta_t = now - drmmode_crtc->dpms_last_ust;
	delta_seq = delta_t * drmmode_crtc->dpms_last_fps;
	delta_seq /= 1000000;
	*ust = drmmode_crtc->dpms_last_ust;
	delta_t = delta_seq * 1000000;
	delta_t /= drmmode_crtc->dpms_last_fps;
	*ust += delta_t;
	*msc = drmmode_crtc->dpms_last_seq;
	*msc += delta_seq;
    }

    *msc += drmmode_crtc->interpolated_vblanks;

    return TRUE;
}

static
xf86CrtcPtr radeon_dri2_drawable_crtc(DrawablePtr pDraw, Bool consider_disabled)
{
    ScreenPtr pScreen = pDraw->pScreen;
    ScrnInfoPtr pScrn = xf86ScreenToScrn(pScreen);
    xf86CrtcPtr crtc = radeon_pick_best_crtc(pScrn, consider_disabled,
					      pDraw->x, pDraw->x + pDraw->width,
					      pDraw->y, pDraw->y + pDraw->height);

    if (crtc && pDraw->type == DRAWABLE_WINDOW) {
	struct dri2_window_priv *priv = get_dri2_window_priv((WindowPtr)pDraw);

	if (priv->crtc && priv->crtc != crtc) {
	    CARD64 ust, mscold, mscnew;

	    if (radeon_dri2_get_crtc_msc(priv->crtc, &ust, &mscold) &&
		radeon_dri2_get_crtc_msc(crtc, &ust, &mscnew))
		priv->vblank_delta += mscold - mscnew;
	}

	priv->crtc = crtc;
    }

    return crtc;
}

static void
radeon_dri2_flip_event_abort(xf86CrtcPtr crtc, void *event_data)
{
    RADEONInfoPtr info = RADEONPTR(crtc->scrn);

    info->drmmode.dri2_flipping = FALSE;
    free(event_data);
}

static void
radeon_dri2_flip_event_handler(xf86CrtcPtr crtc, uint32_t frame, uint64_t usec,
			       void *event_data)
{
    DRI2FrameEventPtr flip = event_data;
    ScrnInfoPtr scrn = crtc->scrn;
    unsigned tv_sec, tv_usec;
    DrawablePtr drawable;
    ScreenPtr screen;
    int status;
    PixmapPtr pixmap;

    status = dixLookupDrawable(&drawable, flip->drawable_id, serverClient,
			       M_ANY, DixWriteAccess);
    if (status != Success)
	goto abort;

    frame += radeon_get_msc_delta(drawable, crtc);

    screen = scrn->pScreen;
    pixmap = screen->GetScreenPixmap(screen);
    xf86DrvMsgVerb(scrn->scrnIndex, X_INFO, RADEON_LOGLEVEL_DEBUG,
		   "%s:%d fevent[%p] width %d pitch %d (/4 %d)\n",
		   __func__, __LINE__, flip, pixmap->drawable.width, pixmap->devKind, pixmap->devKind/4);

    tv_sec = usec / 1000000;
    tv_usec = usec % 1000000;

    /* We assume our flips arrive in order, so we don't check the frame */
    switch (flip->type) {
    case DRI2_SWAP:
	/* Check for too small vblank count of pageflip completion, taking wraparound
	 * into account. This usually means some defective kms pageflip completion,
	 * causing wrong (msc, ust) return values and possible visual corruption.
	 */
	if ((frame < flip->frame) && (flip->frame - frame < 5)) {
	    xf86DrvMsg(scrn->scrnIndex, X_WARNING,
		       "%s: Pageflip completion event has impossible msc %u < target_msc %u\n",
		       __func__, frame, flip->frame);
	    /* All-Zero values signal failure of (msc, ust) timestamping to client. */
	    frame = tv_sec = tv_usec = 0;
	}

	DRI2SwapComplete(flip->client, drawable, frame, tv_sec, tv_usec,
			 DRI2_FLIP_COMPLETE, flip->event_complete,
			 flip->event_data);
	break;
    default:
	xf86DrvMsg(scrn->scrnIndex, X_WARNING, "%s: unknown vblank event received\n", __func__);
	/* Unknown type */
	break;
    }

abort:
    radeon_dri2_flip_event_abort(crtc, event_data);
}

static Bool
radeon_dri2_schedule_flip(xf86CrtcPtr crtc, ClientPtr client,
			  DrawablePtr draw, DRI2BufferPtr front,
			  DRI2BufferPtr back, DRI2SwapEventPtr func,
			  void *data, unsigned int target_msc)
{
    ScrnInfoPtr scrn = crtc->scrn;
    RADEONInfoPtr info = RADEONPTR(scrn);
    struct dri2_buffer_priv *back_priv;
    struct radeon_bo *bo;
    DRI2FrameEventPtr flip_info;
    int ref_crtc_hw_id = drmmode_get_crtc_id(crtc);

    flip_info = calloc(1, sizeof(DRI2FrameEventRec));
    if (!flip_info)
	return FALSE;

    flip_info->drawable_id = draw->id;
    flip_info->client = client;
    flip_info->type = DRI2_SWAP;
    flip_info->event_complete = func;
    flip_info->event_data = data;
    flip_info->frame = target_msc;
    flip_info->crtc = crtc;

    xf86DrvMsgVerb(scrn->scrnIndex, X_INFO, RADEON_LOGLEVEL_DEBUG,
		   "%s:%d fevent[%p]\n", __func__, __LINE__, flip_info);

    /* Page flip the full screen buffer */
    back_priv = back->driverPrivate;
    bo = radeon_get_pixmap_bo(back_priv->pixmap);

    if (radeon_do_pageflip(scrn, client, bo->handle,
			   RADEON_DRM_QUEUE_ID_DEFAULT, flip_info,
			   ref_crtc_hw_id,
			   radeon_dri2_flip_event_handler,
			   radeon_dri2_flip_event_abort)) {
	info->drmmode.dri2_flipping = TRUE;
	return TRUE;
    }

    return FALSE;
}

static Bool
update_front(DrawablePtr draw, DRI2BufferPtr front)
{
    PixmapPtr pixmap;
    RADEONInfoPtr info = RADEONPTR(xf86ScreenToScrn(draw->pScreen));
    struct dri2_buffer_priv *priv = front->driverPrivate;

    pixmap = get_drawable_pixmap(draw);
    pixmap->refcnt++;

    if (!info->use_glamor)
	exaMoveInPixmap(pixmap);
    if (!radeon_get_flink_name(info, pixmap, &front->name)) {
	(*draw->pScreen->DestroyPixmap)(pixmap);
	return FALSE;
    }
    (*draw->pScreen->DestroyPixmap)(priv->pixmap);
    front->pitch = pixmap->devKind;
    front->cpp = pixmap->drawable.bitsPerPixel / 8;
    priv->pixmap = pixmap;

    return TRUE;
}

static Bool
can_exchange(ScrnInfoPtr pScrn, DrawablePtr draw,
	     DRI2BufferPtr front, DRI2BufferPtr back)
{
    struct dri2_buffer_priv *front_priv = front->driverPrivate;
    struct dri2_buffer_priv *back_priv = back->driverPrivate;
    PixmapPtr front_pixmap;
    PixmapPtr back_pixmap = back_priv->pixmap;
    xf86CrtcConfigPtr xf86_config = XF86_CRTC_CONFIG_PTR(pScrn);
    int i;

    for (i = 0; i < xf86_config->num_crtc; i++) {
	xf86CrtcPtr crtc = xf86_config->crtc[i];
	if (crtc->enabled && crtc->rotatedData)
	    return FALSE;
    }

    if (!update_front(draw, front))
	return FALSE;

    front_pixmap = front_priv->pixmap;

    if (front_pixmap->drawable.width != back_pixmap->drawable.width)
	return FALSE;

    if (front_pixmap->drawable.height != back_pixmap->drawable.height)
	return FALSE;

    if (front_pixmap->drawable.bitsPerPixel != back_pixmap->drawable.bitsPerPixel)
	return FALSE;

    if (front_pixmap->devKind != back_pixmap->devKind)
	return FALSE;

    return TRUE;
}

static Bool
can_flip(ScrnInfoPtr pScrn, DrawablePtr draw,
	 DRI2BufferPtr front, DRI2BufferPtr back)
{
    RADEONInfoPtr info = RADEONPTR(pScrn);

    return draw->type == DRAWABLE_WINDOW &&
	   info->allowPageFlip &&
	   !info->hwcursor_disabled &&
	   !info->drmmode.present_flipping &&
	   pScrn->vtSema &&
	   DRI2CanFlip(draw) &&
	   can_exchange(pScrn, draw, front, back);
}

static void
radeon_dri2_exchange_buffers(DrawablePtr draw, DRI2BufferPtr front, DRI2BufferPtr back)
{
    struct dri2_buffer_priv *front_priv = front->driverPrivate;
    struct dri2_buffer_priv *back_priv = back->driverPrivate;
    struct radeon_bo *front_bo, *back_bo;
    ScreenPtr screen;
    RADEONInfoPtr info;
    RegionRec region;
    int tmp;

    region.extents.x1 = region.extents.y1 = 0;
    region.extents.x2 = front_priv->pixmap->drawable.width;
    region.extents.y2 = front_priv->pixmap->drawable.height;
    region.data = NULL;
    DamageRegionAppend(&front_priv->pixmap->drawable, &region);

    /* Swap BO names so DRI works */
    tmp = front->name;
    front->name = back->name;
    back->name = tmp;

    /* Swap pixmap bos */
    front_bo = radeon_get_pixmap_bo(front_priv->pixmap);
    back_bo = radeon_get_pixmap_bo(back_priv->pixmap);
    radeon_set_pixmap_bo(front_priv->pixmap, back_bo);
    radeon_set_pixmap_bo(back_priv->pixmap, front_bo);

    /* Do we need to update the Screen? */
    screen = draw->pScreen;
    info = RADEONPTR(xf86ScreenToScrn(screen));
    if (front_bo == info->front_bo) {
	radeon_bo_ref(back_bo);
	radeon_bo_unref(info->front_bo);
	info->front_bo = back_bo;
	radeon_set_pixmap_bo(screen->GetScreenPixmap(screen), back_bo);
    }

    radeon_glamor_exchange_buffers(front_priv->pixmap, back_priv->pixmap);

    DamageRegionProcessPending(&front_priv->pixmap->drawable);
}

static void radeon_dri2_frame_event_abort(xf86CrtcPtr crtc, void *event_data)
{
    DRI2FrameEventPtr event = event_data;

    TimerCancel(event->timer);
    TimerFree(event->timer);
    radeon_dri2_unref_buffer(event->front);
    radeon_dri2_unref_buffer(event->back);
    free(event);
}

static void radeon_dri2_frame_event_handler(xf86CrtcPtr crtc, uint32_t seq,
					    uint64_t usec, void *event_data)
{
    DRI2FrameEventPtr event = event_data;
    ScrnInfoPtr scrn = crtc->scrn;
    DrawablePtr drawable;
    int status;
    int swap_type;
    BoxRec box;
    RegionRec region;

    status = dixLookupDrawable(&drawable, event->drawable_id, serverClient,
                               M_ANY, DixWriteAccess);
    if (status != Success)
        goto cleanup;

    seq += radeon_get_msc_delta(drawable, crtc);

    switch (event->type) {
    case DRI2_FLIP:
	if (can_flip(scrn, drawable, event->front, event->back) &&
	    radeon_dri2_schedule_flip(crtc,
				      event->client,
				      drawable,
				      event->front,
				      event->back,
				      event->event_complete,
				      event->event_data,
				      event->frame)) {
	    radeon_dri2_exchange_buffers(drawable, event->front, event->back);
	    break;
	}
	/* else fall through to exchange/blit */
    case DRI2_SWAP:
	if (DRI2CanExchange(drawable) &&
	    can_exchange(scrn, drawable, event->front, event->back)) {
	    radeon_dri2_exchange_buffers(drawable, event->front, event->back);
	    swap_type = DRI2_EXCHANGE_COMPLETE;
	} else {
	    box.x1 = 0;
	    box.y1 = 0;
	    box.x2 = drawable->width;
	    box.y2 = drawable->height;
	    REGION_INIT(pScreen, &region, &box, 0);
	    radeon_dri2_copy_region(drawable, &region, event->front, event->back);
	    swap_type = DRI2_BLIT_COMPLETE;
	}

        DRI2SwapComplete(event->client, drawable, seq, usec / 1000000,
			 usec % 1000000, swap_type, event->event_complete,
			 event->event_data);

        break;
    case DRI2_WAITMSC:
        DRI2WaitMSCComplete(event->client, drawable, seq, usec / 1000000,
			    usec % 1000000);
        break;
    default:
        /* Unknown type */
        xf86DrvMsg(scrn->scrnIndex, X_WARNING,
                "%s: unknown vblank event received\n", __func__);
        break;
    }

cleanup:
    radeon_dri2_frame_event_abort(crtc, event_data);
}

drmVBlankSeqType radeon_populate_vbl_request_type(xf86CrtcPtr crtc)
{
    drmVBlankSeqType type = 0;
    int crtc_id = drmmode_get_crtc_id(crtc);

    if (crtc_id == 1)
        type |= DRM_VBLANK_SECONDARY;
    else if (crtc_id > 1)
#ifdef DRM_VBLANK_HIGH_CRTC_SHIFT
	type |= (crtc_id << DRM_VBLANK_HIGH_CRTC_SHIFT) &
		DRM_VBLANK_HIGH_CRTC_MASK;
#else
	ErrorF("radeon driver bug: %s called for CRTC %d > 1, but "
	       "DRM_VBLANK_HIGH_CRTC_MASK not defined at build time\n",
	       __func__, crtc_id);
#endif

    return type; 
}

/*
 * This function should be called on a disabled CRTC only (i.e., CRTC
 * in DPMS-off state). It will calculate the delay necessary to reach
 * target_msc from present time if the CRTC were running.
 */
static
CARD32 radeon_dri2_extrapolate_msc_delay(xf86CrtcPtr crtc, CARD64 *target_msc,
					 CARD64 divisor, CARD64 remainder)
{
    drmmode_crtc_private_ptr drmmode_crtc = crtc->driver_private;
    ScrnInfoPtr pScrn = crtc->scrn;
    RADEONInfoPtr info = RADEONPTR(pScrn);
    int nominal_frame_rate = drmmode_crtc->dpms_last_fps;
    CARD64 last_vblank_ust = drmmode_crtc->dpms_last_ust;
    uint32_t last_vblank_seq = drmmode_crtc->dpms_last_seq;
    CARD64 now, target_time, delta_t;
    int64_t d, delta_seq;
    int ret;
    CARD32 d_ms;

    if (!last_vblank_ust) {
	*target_msc = 0;
	return FALLBACK_SWAP_DELAY;
    }
    ret = drmmode_get_current_ust(info->dri2.drm_fd, &now);
    if (ret) {
	xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
		   "%s cannot get current time\n", __func__);
	*target_msc = 0;
	return FALLBACK_SWAP_DELAY;
    }
    delta_seq = *target_msc - last_vblank_seq;
    delta_seq *= 1000000;
    target_time = last_vblank_ust;
    target_time += delta_seq / nominal_frame_rate;
    d = target_time - now;
    if (d < 0) {
	/* we missed the event, adjust target_msc, do the divisor magic */
	CARD64 current_msc = last_vblank_seq;

	delta_t = now - last_vblank_ust;
	delta_seq = delta_t * nominal_frame_rate;
	current_msc += delta_seq / 1000000;
	current_msc &= 0xffffffff;
	if (divisor == 0) {
	    *target_msc = current_msc;
	    d = 0;
	} else {
	    *target_msc = current_msc - (current_msc % divisor) + remainder;
	    if ((current_msc % divisor) >= remainder)
		*target_msc += divisor;
	    *target_msc &= 0xffffffff;
	    delta_seq = *target_msc - last_vblank_seq;
	    delta_seq *= 1000000;
	    target_time = last_vblank_ust;
	    target_time += delta_seq / nominal_frame_rate;
	    d = target_time - now;
	}
    }
    /*
     * convert delay to milliseconds and add margin to prevent the client
     * from coming back early (due to timer granularity and rounding
     * errors) and getting the same MSC it just got
     */
    d_ms = (CARD32)d / 1000;
    if ((CARD32)d - d_ms * 1000 > 0)
	d_ms += 2;
    else
	d_ms++;
    return d_ms;
}

/*
 * Get current interpolated frame count and frame count timestamp, based on
 * drawable's crtc.
 */
static int radeon_dri2_get_msc(DrawablePtr draw, CARD64 *ust, CARD64 *msc)
{
    xf86CrtcPtr crtc = radeon_dri2_drawable_crtc(draw, TRUE);

    /* Drawable not displayed, make up a value */
    if (crtc == NULL) {
        *ust = 0;
        *msc = 0;
        return TRUE;
    }

    if (!radeon_dri2_get_crtc_msc(crtc, ust, msc))
	return FALSE;

    if (draw && draw->type == DRAWABLE_WINDOW)
	*msc += get_dri2_window_priv((WindowPtr)draw)->vblank_delta;
    *msc &= 0xffffffff;
    return TRUE;
}

static
CARD32 radeon_dri2_deferred_event(OsTimerPtr timer, CARD32 now, pointer data)
{
    DRI2FrameEventPtr event_info = (DRI2FrameEventPtr)data;
    xf86CrtcPtr crtc = event_info->crtc;
    ScrnInfoPtr scrn;
    RADEONInfoPtr info;
    CARD64 drm_now;
    int ret;
    CARD64 delta_t, delta_seq, frame;
    drmmode_crtc_private_ptr drmmode_crtc;

    /*
     * This is emulated event, so its time is current time, which we
     * have to get in DRM-compatible form (which is a bit messy given
     * the information that we have at this point). Can't use now argument
     * because DRM event time may come from monotonic clock, while
     * DIX timer facility uses real-time clock.
     */
    if (!event_info->crtc) {
	ErrorF("%s no crtc\n", __func__);
	if (event_info->drm_queue_seq)
	    radeon_drm_abort_entry(event_info->drm_queue_seq);
	else
	    radeon_dri2_frame_event_abort(NULL, data);
	return 0;
    }

    scrn = crtc->scrn;
    info = RADEONPTR(scrn);
    ret = drmmode_get_current_ust(info->dri2.drm_fd, &drm_now);
    if (ret) {
	xf86DrvMsg(scrn->scrnIndex, X_ERROR,
		   "%s cannot get current time\n", __func__);
	if (event_info->drm_queue_seq)
	    radeon_drm_queue_handler(info->dri2.drm_fd, 0, 0, 0,
				     (void*)event_info->drm_queue_seq);
	else
	    radeon_dri2_frame_event_handler(crtc, 0, 0, data);
	return 0;
    }
    /*
     * calculate the frame number from current time
     * that would come from CRTC if it were running
     */
    drmmode_crtc = event_info->crtc->driver_private;
    delta_t = drm_now - (CARD64)drmmode_crtc->dpms_last_ust;
    delta_seq = delta_t * drmmode_crtc->dpms_last_fps;
    delta_seq /= 1000000;
    frame = (CARD64)drmmode_crtc->dpms_last_seq + delta_seq;
    if (event_info->drm_queue_seq)
	radeon_drm_queue_handler(info->dri2.drm_fd, frame, drm_now / 1000000,
				 drm_now % 1000000,
				 (void*)event_info->drm_queue_seq);
    else
	radeon_dri2_frame_event_handler(crtc, frame, drm_now, data);
    return 0;
}

static
void radeon_dri2_schedule_event(CARD32 delay, DRI2FrameEventPtr event_info)
{
    event_info->timer = TimerSet(NULL, 0, delay, radeon_dri2_deferred_event,
				 event_info);
    if (delay == 0) {
	CARD32 now = GetTimeInMillis();
	radeon_dri2_deferred_event(event_info->timer, now, event_info);
    }
}

/*
 * Request a DRM event when the requested conditions will be satisfied.
 *
 * We need to handle the event and ask the server to wake up the client when
 * we receive it.
 */
static int radeon_dri2_schedule_wait_msc(ClientPtr client, DrawablePtr draw,
                                         CARD64 target_msc, CARD64 divisor,
                                         CARD64 remainder)
{
    ScreenPtr screen = draw->pScreen;
    ScrnInfoPtr scrn = xf86ScreenToScrn(screen);
    RADEONInfoPtr info = RADEONPTR(scrn);
    DRI2FrameEventPtr wait_info = NULL;
    uintptr_t drm_queue_seq = 0;
    xf86CrtcPtr crtc = radeon_dri2_drawable_crtc(draw, TRUE);
    uint32_t msc_delta;
    drmVBlank vbl;
    int ret;
    CARD64 current_msc;

    /* Truncate to match kernel interfaces; means occasional overflow
     * misses, but that's generally not a big deal */
    target_msc &= 0xffffffff;
    divisor &= 0xffffffff;
    remainder &= 0xffffffff;

    /* Drawable not visible, return immediately */
    if (crtc == NULL)
        goto out_complete;

    msc_delta = radeon_get_msc_delta(draw, crtc);

    wait_info = calloc(1, sizeof(DRI2FrameEventRec));
    if (!wait_info)
        goto out_complete;

    wait_info->drawable_id = draw->id;
    wait_info->client = client;
    wait_info->type = DRI2_WAITMSC;
    wait_info->crtc = crtc;

    /*
     * CRTC is in DPMS off state, calculate wait time from current time,
     * target_msc and last vblank time/sequence when CRTC was turned off
     */
    if (!radeon_crtc_is_enabled(crtc)) {
	CARD32 delay;
	target_msc -= msc_delta;
	delay = radeon_dri2_extrapolate_msc_delay(crtc, &target_msc,
						  divisor, remainder);
	radeon_dri2_schedule_event(delay, wait_info);
	DRI2BlockClient(client, draw);
	return TRUE;
    }

    /* Get current count */
    vbl.request.type = DRM_VBLANK_RELATIVE;
    vbl.request.type |= radeon_populate_vbl_request_type(crtc);
    vbl.request.sequence = 0;
    ret = drmWaitVBlank(info->dri2.drm_fd, &vbl);
    if (ret) {
        xf86DrvMsg(scrn->scrnIndex, X_WARNING,
                "get vblank counter failed: %s\n", strerror(errno));
        goto out_complete;
    }

    current_msc = vbl.reply.sequence + msc_delta;
    current_msc &= 0xffffffff;

    drm_queue_seq = radeon_drm_queue_alloc(crtc, client, RADEON_DRM_QUEUE_ID_DEFAULT,
					   wait_info, radeon_dri2_frame_event_handler,
					   radeon_dri2_frame_event_abort);
    if (!drm_queue_seq) {
        xf86DrvMsg(scrn->scrnIndex, X_WARNING,
		   "Allocating DRM queue event entry failed.\n");
        goto out_complete;
    }
    wait_info->drm_queue_seq = drm_queue_seq;

    /*
     * If divisor is zero, or current_msc is smaller than target_msc,
     * we just need to make sure target_msc passes  before waking up the
     * client.
     */
    if (divisor == 0 || current_msc < target_msc) {
        /* If target_msc already reached or passed, set it to
         * current_msc to ensure we return a reasonable value back
         * to the caller. This keeps the client from continually
         * sending us MSC targets from the past by forcibly updating
         * their count on this call.
         */
        if (current_msc >= target_msc)
            target_msc = current_msc;
        vbl.request.type = DRM_VBLANK_ABSOLUTE | DRM_VBLANK_EVENT;
	vbl.request.type |= radeon_populate_vbl_request_type(crtc);
        vbl.request.sequence = target_msc - msc_delta;
        vbl.request.signal = drm_queue_seq;
        ret = drmWaitVBlank(info->dri2.drm_fd, &vbl);
        if (ret) {
            xf86DrvMsg(scrn->scrnIndex, X_WARNING,
                    "get vblank counter failed: %s\n", strerror(errno));
            goto out_complete;
        }

        DRI2BlockClient(client, draw);
        return TRUE;
    }

    /*
     * If we get here, target_msc has already passed or we don't have one,
     * so we queue an event that will satisfy the divisor/remainder equation.
     */
    vbl.request.type = DRM_VBLANK_ABSOLUTE | DRM_VBLANK_EVENT;
    vbl.request.type |= radeon_populate_vbl_request_type(crtc);

    vbl.request.sequence = current_msc - (current_msc % divisor) +
        remainder - msc_delta;

    /*
     * If calculated remainder is larger than requested remainder,
     * it means we've passed the last point where
     * seq % divisor == remainder, so we need to wait for the next time
     * that will happen.
     */
    if ((current_msc % divisor) >= remainder)
        vbl.request.sequence += divisor;

    vbl.request.signal = drm_queue_seq;
    ret = drmWaitVBlank(info->dri2.drm_fd, &vbl);
    if (ret) {
        xf86DrvMsg(scrn->scrnIndex, X_WARNING,
                "get vblank counter failed: %s\n", strerror(errno));
        goto out_complete;
    }

    DRI2BlockClient(client, draw);

    return TRUE;

out_complete:
    if (wait_info)
	radeon_dri2_deferred_event(NULL, 0, wait_info);
    return TRUE;
}

/*
 * ScheduleSwap is responsible for requesting a DRM vblank event for the
 * appropriate frame.
 *
 * In the case of a blit (e.g. for a windowed swap) or buffer exchange,
 * the vblank requested can simply be the last queued swap frame + the swap
 * interval for the drawable.
 *
 * In the case of a page flip, we request an event for the last queued swap
 * frame + swap interval - 1, since we'll need to queue the flip for the frame
 * immediately following the received event.
 *
 * The client will be blocked if it tries to perform further GL commands
 * after queueing a swap, though in the Intel case after queueing a flip, the
 * client is free to queue more commands; they'll block in the kernel if
 * they access buffers busy with the flip.
 *
 * When the swap is complete, the driver should call into the server so it
 * can send any swap complete events that have been requested.
 */
static int radeon_dri2_schedule_swap(ClientPtr client, DrawablePtr draw,
                                     DRI2BufferPtr front, DRI2BufferPtr back,
                                     CARD64 *target_msc, CARD64 divisor,
                                     CARD64 remainder, DRI2SwapEventPtr func,
                                     void *data)
{
    ScreenPtr screen = draw->pScreen;
    ScrnInfoPtr scrn = xf86ScreenToScrn(screen);
    RADEONInfoPtr info = RADEONPTR(scrn);
    xf86CrtcPtr crtc = radeon_dri2_drawable_crtc(draw, TRUE);
    uint32_t msc_delta;
    drmVBlank vbl;
    int ret, flip = 0;
    DRI2FrameEventPtr swap_info = NULL;
    uintptr_t drm_queue_seq;
    CARD64 current_msc;
    BoxRec box;
    RegionRec region;

    /* Truncate to match kernel interfaces; means occasional overflow
     * misses, but that's generally not a big deal */
    *target_msc &= 0xffffffff;
    divisor &= 0xffffffff;
    remainder &= 0xffffffff;

    /* radeon_dri2_frame_event_handler will get called some unknown time in the
     * future with these buffers.  Take a reference to ensure that they won't
     * get destroyed before then. 
     */
    radeon_dri2_ref_buffer(front);
    radeon_dri2_ref_buffer(back);

    /* either off-screen or CRTC not usable... just complete the swap */
    if (crtc == NULL)
        goto blit_fallback;

    msc_delta = radeon_get_msc_delta(draw, crtc);

    swap_info = calloc(1, sizeof(DRI2FrameEventRec));
    if (!swap_info)
        goto blit_fallback;

    swap_info->type = DRI2_SWAP;
    swap_info->drawable_id = draw->id;
    swap_info->client = client;
    swap_info->event_complete = func;
    swap_info->event_data = data;
    swap_info->front = front;
    swap_info->back = back;
    swap_info->crtc = crtc;

    drm_queue_seq = radeon_drm_queue_alloc(crtc, client, RADEON_DRM_QUEUE_ID_DEFAULT,
					   swap_info, radeon_dri2_frame_event_handler,
					   radeon_dri2_frame_event_abort);
    if (!drm_queue_seq) {
        xf86DrvMsg(scrn->scrnIndex, X_WARNING,
		   "Allocating DRM queue entry failed.\n");
        goto blit_fallback;
    }
    swap_info->drm_queue_seq = drm_queue_seq;

    /*
     * CRTC is in DPMS off state, fallback to blit, but calculate
     * wait time from current time, target_msc and last vblank
     * time/sequence when CRTC was turned off
     */
    if (!radeon_crtc_is_enabled(crtc)) {
	CARD32 delay;
	*target_msc -= msc_delta;
	delay = radeon_dri2_extrapolate_msc_delay(crtc, target_msc,
						  divisor, remainder);
	*target_msc += msc_delta;
	*target_msc &= 0xffffffff;
	radeon_dri2_schedule_event(delay, swap_info);
	return TRUE;
    }

    /* Get current count */
    vbl.request.type = DRM_VBLANK_RELATIVE;
    vbl.request.type |= radeon_populate_vbl_request_type(crtc);
    vbl.request.sequence = 0;
    ret = drmWaitVBlank(info->dri2.drm_fd, &vbl);
    if (ret) {
        xf86DrvMsg(scrn->scrnIndex, X_WARNING,
                "first get vblank counter failed: %s\n",
                strerror(errno));
	goto blit_fallback;
    }

    current_msc = vbl.reply.sequence + msc_delta;
    current_msc &= 0xffffffff;

    /* Flips need to be submitted one frame before */
    if (can_flip(scrn, draw, front, back)) {
	swap_info->type = DRI2_FLIP;
	flip = 1;
    }

    /* Correct target_msc by 'flip' if swap_info->type == DRI2_FLIP.
     * Do it early, so handling of different timing constraints
     * for divisor, remainder and msc vs. target_msc works.
     */
    if (*target_msc > 0)
        *target_msc -= flip;

    /*
     * If divisor is zero, or current_msc is smaller than target_msc
     * we just need to make sure target_msc passes before initiating
     * the swap.
     */
    if (divisor == 0 || current_msc < *target_msc) {
        vbl.request.type =  DRM_VBLANK_ABSOLUTE | DRM_VBLANK_EVENT;
        /* If non-pageflipping, but blitting/exchanging, we need to use
         * DRM_VBLANK_NEXTONMISS to avoid unreliable timestamping later
         * on.
         */
        if (flip == 0)
            vbl.request.type |= DRM_VBLANK_NEXTONMISS;
	vbl.request.type |= radeon_populate_vbl_request_type(crtc);

        /* If target_msc already reached or passed, set it to
         * current_msc to ensure we return a reasonable value back
         * to the caller. This makes swap_interval logic more robust.
         */
        if (current_msc >= *target_msc)
            *target_msc = current_msc;

        vbl.request.sequence = *target_msc - msc_delta;
        vbl.request.signal = drm_queue_seq;
        ret = drmWaitVBlank(info->dri2.drm_fd, &vbl);
        if (ret) {
            xf86DrvMsg(scrn->scrnIndex, X_WARNING,
                    "divisor 0 get vblank counter failed: %s\n",
                    strerror(errno));
	    goto blit_fallback;
        }

        *target_msc = vbl.reply.sequence + flip + msc_delta;
        swap_info->frame = *target_msc;

        return TRUE;
    }

    /*
     * If we get here, target_msc has already passed or we don't have one,
     * and we need to queue an event that will satisfy the divisor/remainder
     * equation.
     */
    vbl.request.type = DRM_VBLANK_ABSOLUTE | DRM_VBLANK_EVENT;
    if (flip == 0)
        vbl.request.type |= DRM_VBLANK_NEXTONMISS;
    vbl.request.type |= radeon_populate_vbl_request_type(crtc);

    vbl.request.sequence = current_msc - (current_msc % divisor) +
        remainder - msc_delta;

    /*
     * If the calculated deadline vbl.request.sequence is smaller than
     * or equal to current_msc, it means we've passed the last point
     * when effective onset frame seq could satisfy
     * seq % divisor == remainder, so we need to wait for the next time
     * this will happen.

     * This comparison takes the 1 frame swap delay in pageflipping mode
     * into account, as well as a potential DRM_VBLANK_NEXTONMISS delay
     * if we are blitting/exchanging instead of flipping.
     */
    if (vbl.request.sequence <= current_msc)
        vbl.request.sequence += divisor;

    /* Account for 1 frame extra pageflip delay if flip > 0 */
    vbl.request.sequence -= flip;

    vbl.request.signal = drm_queue_seq;
    ret = drmWaitVBlank(info->dri2.drm_fd, &vbl);
    if (ret) {
        xf86DrvMsg(scrn->scrnIndex, X_WARNING,
                "final get vblank counter failed: %s\n",
                strerror(errno));
	goto blit_fallback;
    }

    /* Adjust returned value for 1 fame pageflip offset of flip > 0 */
    *target_msc = vbl.reply.sequence + flip + msc_delta;
    *target_msc &= 0xffffffff;
    swap_info->frame = *target_msc;

    return TRUE;

blit_fallback:
    if (swap_info) {
	swap_info->type = DRI2_SWAP;
	radeon_dri2_schedule_event(FALLBACK_SWAP_DELAY, swap_info);
    } else {
	box.x1 = 0;
	box.y1 = 0;
	box.x2 = draw->width;
	box.y2 = draw->height;
	REGION_INIT(pScreen, &region, &box, 0);

	radeon_dri2_copy_region(draw, &region, front, back);

	DRI2SwapComplete(client, draw, 0, 0, 0, DRI2_BLIT_COMPLETE, func, data);

	radeon_dri2_unref_buffer(front);
	radeon_dri2_unref_buffer(back);
    }

    *target_msc = 0; /* offscreen, so zero out target vblank count */
    return TRUE;
}


Bool
radeon_dri2_screen_init(ScreenPtr pScreen)
{
    ScrnInfoPtr pScrn = xf86ScreenToScrn(pScreen);
    RADEONInfoPtr info = RADEONPTR(pScrn);
    DRI2InfoRec dri2_info = { 0 };
    const char *driverNames[2];
    Bool scheduling_works = TRUE;

    if (!info->dri2.available)
        return FALSE;

    info->dri2.device_name = drmGetDeviceNameFromFd(info->dri2.drm_fd);

    if ( (info->ChipFamily >= CHIP_FAMILY_TAHITI) ) {
        dri2_info.driverName = SI_DRIVER_NAME;
    } else if ( (info->ChipFamily >= CHIP_FAMILY_R600) ) {
        dri2_info.driverName = R600_DRIVER_NAME;
    } else if ( (info->ChipFamily >= CHIP_FAMILY_R300) ) {
        dri2_info.driverName = R300_DRIVER_NAME;
    } else if ( info->ChipFamily >= CHIP_FAMILY_R200 ) {
        dri2_info.driverName = R200_DRIVER_NAME;
    } else {
        dri2_info.driverName = RADEON_DRIVER_NAME;
    }
    dri2_info.fd = info->dri2.drm_fd;
    dri2_info.deviceName = info->dri2.device_name;
    dri2_info.version = DRI2INFOREC_VERSION;
    dri2_info.CreateBuffer = radeon_dri2_create_buffer;
    dri2_info.DestroyBuffer = radeon_dri2_destroy_buffer;
    dri2_info.CopyRegion = radeon_dri2_copy_region;

    if (info->dri2.pKernelDRMVersion->version_minor < 4) {
	xf86DrvMsg(pScrn->scrnIndex, X_WARNING, "You need a newer kernel for "
		   "sync extension\n");
	scheduling_works = FALSE;
    }

    if (scheduling_works && info->drmmode.count_crtcs > 2) {
#ifdef DRM_CAP_VBLANK_HIGH_CRTC
	uint64_t cap_value;

	if (drmGetCap(info->dri2.drm_fd, DRM_CAP_VBLANK_HIGH_CRTC, &cap_value)) {
	    xf86DrvMsg(pScrn->scrnIndex, X_WARNING, "You need a newer kernel "
		       "for VBLANKs on CRTC > 1\n");
	    scheduling_works = FALSE;
	} else if (!cap_value) {
	    xf86DrvMsg(pScrn->scrnIndex, X_WARNING, "Your kernel does not "
		       "handle VBLANKs on CRTC > 1\n");
	    scheduling_works = FALSE;
	}
#else
	xf86DrvMsg(pScrn->scrnIndex, X_WARNING, "You need to rebuild against a "
		   "newer libdrm to handle VBLANKs on CRTC > 1\n");
	scheduling_works = FALSE;
#endif
    }

    if (scheduling_works) {
        dri2_info.version = 4;
        dri2_info.ScheduleSwap = radeon_dri2_schedule_swap;
        dri2_info.GetMSC = radeon_dri2_get_msc;
        dri2_info.ScheduleWaitMSC = radeon_dri2_schedule_wait_msc;
        dri2_info.numDrivers = RADEON_ARRAY_SIZE(driverNames);
        dri2_info.driverNames = driverNames;
        driverNames[0] = dri2_info.driverName;

        if (info->ChipFamily >= CHIP_FAMILY_R300)
            driverNames[1] = driverNames[0];
        else
            driverNames[1] = NULL; /* no VDPAU support */

	if (DRI2InfoCnt == 0) {
	    if (!dixRegisterPrivateKey(dri2_window_private_key,
				       PRIVATE_WINDOW,
				       sizeof(struct dri2_window_priv))) {
		xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
			   "Failed to get DRI2 window private\n");
		return FALSE;
	    }

	    AddCallback(&ClientStateCallback, radeon_dri2_client_state_changed, 0);
	}

	DRI2InfoCnt++;
    }

#if DRI2INFOREC_VERSION >= 9
    dri2_info.version = 9;
    dri2_info.CreateBuffer2 = radeon_dri2_create_buffer2;
    dri2_info.DestroyBuffer2 = radeon_dri2_destroy_buffer2;
    dri2_info.CopyRegion2 = radeon_dri2_copy_region2;
#endif

    info->dri2.enabled = DRI2ScreenInit(pScreen, &dri2_info);
    return info->dri2.enabled;
}

void radeon_dri2_close_screen(ScreenPtr pScreen)
{
    ScrnInfoPtr pScrn = xf86ScreenToScrn(pScreen);
    RADEONInfoPtr info = RADEONPTR(pScrn);

    if (--DRI2InfoCnt == 0)
    	DeleteCallback(&ClientStateCallback, radeon_dri2_client_state_changed, 0);

    DRI2CloseScreen(pScreen);
    drmFree(info->dri2.device_name);
}

#endif /* DRI2 */

@


1.9
log
@Update to xf86-video-ati 7.6.1. ok jsg@@
@
text
@a72 2
#if HAS_DEVPRIVATEKEYREC

a75 7
#else

static int dri2_window_private_key_index;
DevPrivateKey dri2_window_private_key = &dri2_window_private_key_index;

#endif /* HAS_DEVPRIVATEKEYREC */

a80 63
static PixmapPtr get_drawable_pixmap(DrawablePtr drawable)
{
    if (drawable->type == DRAWABLE_PIXMAP)
	return (PixmapPtr)drawable;
    else
	return (*drawable->pScreen->GetWindowPixmap)((WindowPtr)drawable);
}


static PixmapPtr fixup_glamor(DrawablePtr drawable, PixmapPtr pixmap)
{
	PixmapPtr old = get_drawable_pixmap(drawable);
#ifdef USE_GLAMOR
	ScreenPtr screen = drawable->pScreen;
	struct radeon_pixmap *priv = radeon_get_pixmap_private(pixmap);
	GCPtr gc;

	/* With a glamor pixmap, 2D pixmaps are created in texture
	 * and without a static BO attached to it. To support DRI,
	 * we need to create a new textured-drm pixmap and
	 * need to copy the original content to this new textured-drm
	 * pixmap, and then convert the old pixmap to a coherent
	 * textured-drm pixmap which has a valid BO attached to it
	 * and also has a valid texture, thus both glamor and DRI2
	 * can access it.
	 *
	 */

	/* Copy the current contents of the pixmap to the bo. */
	gc = GetScratchGC(drawable->depth, screen);
	if (gc) {
		ValidateGC(&pixmap->drawable, gc);
		gc->ops->CopyArea(&old->drawable, &pixmap->drawable,
				  gc,
				  0, 0,
				  old->drawable.width,
				  old->drawable.height,
				  0, 0);
		FreeScratchGC(gc);
	}

	radeon_set_pixmap_private(pixmap, NULL);

	/* And redirect the pixmap to the new bo (for 3D). */
	glamor_egl_exchange_buffers(old, pixmap);
	radeon_set_pixmap_private(old, priv);
	old->refcnt++;

	screen->ModifyPixmapHeader(old,
				   old->drawable.width,
				   old->drawable.height,
				   0, 0,
				   pixmap->devKind,
				   NULL);
	old->devPrivate.ptr = NULL;

	screen->DestroyPixmap(pixmap);

#endif /* USE_GLAMOR*/

	return old;
}

d250 3
a254 2
	if (is_glamor_pixmap)
	    pixmap = fixup_glamor(drawable, pixmap);
d457 1
a457 1
    struct radeon_drm_queue_entry *drm_queue;
d519 2
a523 1
	drmmode_crtc_private_ptr drmmode_crtc = crtc->driver_private;
d548 2
d580 1
a580 1
radeon_dri2_flip_event_abort(ScrnInfoPtr scrn, void *event_data)
d582 3
d589 1
a589 1
radeon_dri2_flip_event_handler(ScrnInfoPtr scrn, uint32_t frame, uint64_t usec,
a591 1
    RADEONInfoPtr info = RADEONPTR(scrn);
d593 1
d605 1
a605 3
    if (!flip->crtc)
	goto abort;
    frame += radeon_get_msc_delta(drawable, flip->crtc);
a633 1
	info->drmmode.dri2_flipping = FALSE;
d642 1
a642 1
    radeon_dri2_flip_event_abort(scrn, event_data);
d646 1
a646 1
radeon_dri2_schedule_flip(ScrnInfoPtr scrn, ClientPtr client,
d651 1
d656 1
a656 3
    /* Main crtc for this drawable shall finally deliver pageflip event. */
    xf86CrtcPtr crtc = radeon_dri2_drawable_crtc(draw, FALSE);
    int ref_crtc_hw_id = crtc ? drmmode_get_crtc_id(crtc) : -1;
d758 1
d778 1
a778 1
    region.extents.y2 = front_priv->pixmap->drawable.width;
d808 1
a808 1
static void radeon_dri2_frame_event_abort(ScrnInfoPtr scrn, void *event_data)
d819 1
a819 1
static void radeon_dri2_frame_event_handler(ScrnInfoPtr scrn, uint32_t seq,
d823 1
a829 3
    if (!event->crtc)
	goto cleanup;

d835 1
a835 1
    seq += radeon_get_msc_delta(drawable, event->crtc);
d840 1
a840 1
	    radeon_dri2_schedule_flip(scrn,
d884 1
a884 1
    radeon_dri2_frame_event_abort(scrn, event_data);
d997 2
a998 1
    *msc += radeon_get_msc_delta(draw, crtc);
d1024 2
a1025 2
	if (event_info->drm_queue)
	    radeon_drm_abort_entry(event_info->drm_queue);
d1037 1
a1037 1
	if (event_info->drm_queue)
d1039 1
a1039 1
				     event_info->drm_queue);
d1041 1
a1041 1
	    radeon_dri2_frame_event_handler(scrn, 0, 0, data);
d1053 1
a1053 1
    if (event_info->drm_queue)
d1055 2
a1056 1
				 drm_now % 1000000, event_info->drm_queue);
d1058 1
a1058 1
	radeon_dri2_frame_event_handler(scrn, frame, drm_now, data);
d1087 1
a1087 1
    struct radeon_drm_queue_entry *wait = NULL;
d1143 4
a1146 4
    wait = radeon_drm_queue_alloc(scrn, client, RADEON_DRM_QUEUE_ID_DEFAULT,
				  wait_info, radeon_dri2_frame_event_handler,
				  radeon_dri2_frame_event_abort);
    if (!wait) {
d1151 1
a1151 1
    wait_info->drm_queue = wait;
d1170 1
a1170 1
        vbl.request.signal = (unsigned long)wait;
d1201 1
a1201 1
    vbl.request.signal = (unsigned long)wait;
d1253 1
a1253 1
    struct radeon_drm_queue_entry *swap;
d1290 4
a1293 4
    swap = radeon_drm_queue_alloc(scrn, client, RADEON_DRM_QUEUE_ID_DEFAULT,
				  swap_info, radeon_dri2_frame_event_handler,
				  radeon_dri2_frame_event_abort);
    if (!swap) {
d1298 1
a1298 1
    swap_info->drm_queue = swap;
d1367 1
a1367 1
        vbl.request.signal = (unsigned long)swap;
d1412 1
a1412 1
    vbl.request.signal = (unsigned long)swap;
a1524 1
#if HAS_DIXREGISTERPRIVATEKEY
a1527 4
#else
	    if (!dixRequestPrivate(dri2_window_private_key,
				   sizeof(struct dri2_window_priv))) {
#endif
@


1.8
log
@Update to xf86-video-ati 7.5.0. Discussed with jsg@@
@
text
@d43 1
d45 1
a45 12

#if HAVE_LIST_H
#include "list.h"
#if !HAVE_XORG_LIST
#define xorg_list			list
#define xorg_list_init			list_init
#define xorg_list_add			list_add
#define xorg_list_del			list_del
#define xorg_list_for_each_entry	list_for_each_entry
#endif
#endif

d49 1
a49 3
#if DRI2INFOREC_VERSION >= 4 && HAVE_LIST_H
#define USE_DRI2_SCHEDULING
#endif
d57 1
a57 3
#ifdef USE_GLAMOR
#include <glamor.h>
#endif
d68 22
a135 1
	screen->DestroyPixmap(pixmap);
d142 1
a142 1
				   priv->stride,
d144 3
d153 20
d184 1
a184 2
    PixmapPtr pixmap, depth_pixmap;
    struct radeon_bo *bo;
d212 1
a212 2
    pixmap = pScreen->GetScreenPixmap(pScreen);
    front_width = pixmap->drawable.width;
d214 1
a214 1
    pixmap = depth_pixmap = NULL;
d217 2
d222 1
a222 1
	else if (info->use_glamor && !radeon_get_pixmap_bo(pixmap)) {
a228 3
    } else if (attachment == DRI2BufferStencil && depth_pixmap) {
        pixmap = depth_pixmap;
        pixmap->refcnt++;
a312 4
    if (attachment == DRI2BufferDepth) {
        depth_pixmap = pixmap;
    }

d326 1
a326 2
	bo = radeon_get_pixmap_bo(pixmap);
	if (!bo || radeon_gem_get_kernel_name(bo, &buffers->name) != 0)
a514 2
#ifdef USE_DRI2_SCHEDULING

d525 1
a525 1
    int frame;
d527 2
a534 4

    Bool valid;

    struct xorg_list link;
a536 6
typedef struct _DRI2ClientEvents {
    struct xorg_list   reference_list;
} DRI2ClientEventsRec, *DRI2ClientEventsPtr;

#if HAS_DEVPRIVATEKEYREC

a538 39
static DevPrivateKeyRec DRI2ClientEventsPrivateKeyRec;
#define DRI2ClientEventsPrivateKey (&DRI2ClientEventsPrivateKeyRec)

#else

static int DRI2ClientEventsPrivateKeyIndex;
DevPrivateKey DRI2ClientEventsPrivateKey = &DRI2ClientEventsPrivateKeyIndex;

#endif /* HAS_DEVPRIVATEKEYREC */

#define GetDRI2ClientEvents(pClient)	((DRI2ClientEventsPtr) \
    dixLookupPrivate(&(pClient)->devPrivates, DRI2ClientEventsPrivateKey))

static int
ListAddDRI2ClientEvents(ClientPtr client, struct xorg_list *entry)
{
    DRI2ClientEventsPtr pClientPriv;
    pClientPriv = GetDRI2ClientEvents(client);

    if (!pClientPriv) {
        return BadAlloc;
    }

    xorg_list_add(entry, &pClientPriv->reference_list);
    return 0;
}

static void
ListDelDRI2ClientEvents(ClientPtr client, struct xorg_list *entry)
{
    DRI2ClientEventsPtr pClientPriv;
    pClientPriv = GetDRI2ClientEvents(client);

    if (!pClientPriv) {
        return;
    }
    xorg_list_del(entry);
}

a557 2
    DRI2ClientEventsPtr pClientEventsPriv;
    DRI2FrameEventPtr ref;
a559 1
    pClientEventsPriv = GetDRI2ClientEvents(pClient);
a561 6
    case ClientStateInitial:
        xorg_list_init(&pClientEventsPriv->reference_list);
        break;
    case ClientStateRunning:
        break;

d564 1
a564 7
        if (pClientEventsPriv) {
            xorg_list_for_each_entry(ref, &pClientEventsPriv->reference_list, link) {
                ref->valid = FALSE;
                radeon_dri2_unref_buffer(ref->front);
                radeon_dri2_unref_buffer(ref->back);
            }
        }
d571 50
d626 82
a707 1
    xf86CrtcPtr crtc;
d709 2
a710 11
    crtc = radeon_pick_best_crtc(pScrn, consider_disabled,
				 pDraw->x,
				 pDraw->x + pDraw->width,
				 pDraw->y,
				 pDraw->y + pDraw->height);

    /* Make sure the CRTC is valid and this is the real front buffer */
    if (crtc != NULL && !crtc->rotatedData)
	return crtc;
    else
	return NULL;
d719 1
d746 10
a755 1
    return radeon_do_pageflip(scrn, bo, flip_info, ref_crtc_hw_id);
a760 1
    int r;
a763 1
    struct radeon_bo *bo;
d770 1
a770 3
    bo = radeon_get_pixmap_bo(pixmap);
    r = radeon_gem_get_kernel_name(bo, &front->name);
    if (r) {
d823 2
d826 2
a827 1
	   RADEONPTR(pScrn)->allowPageFlip &&
d876 13
a888 2
void radeon_dri2_frame_event_handler(unsigned int frame, unsigned int tv_sec,
                                     unsigned int tv_usec, void *event_data)
a891 2
    ScreenPtr screen;
    ScrnInfoPtr scrn;
d897 1
a897 1
    if (!event->valid)
a903 3
    if (!event->crtc)
	goto cleanup;
    frame += radeon_get_interpolated_vblanks(event->crtc);
d905 1
a905 2
    screen = drawable->pScreen;
    scrn = xf86ScreenToScrn(screen);
d937 3
a939 2
        DRI2SwapComplete(event->client, drawable, frame, tv_sec, tv_usec,
                swap_type, event->event_complete, event->event_data);
d943 2
a944 1
        DRI2WaitMSCComplete(event->client, drawable, frame, tv_sec, tv_usec);
d954 1
a954 6
    if (event->valid) {
        radeon_dri2_unref_buffer(event->front);
        radeon_dri2_unref_buffer(event->back);
        ListDelDRI2ClientEvents(event->client, &event->link);
    }
    free(event);
a991 2
    int interpolated_vblanks = drmmode_crtc->interpolated_vblanks;
    int target_seq;
d1008 1
a1008 2
    target_seq = (int)*target_msc - interpolated_vblanks;
    delta_seq = (int64_t)target_seq - (int64_t)last_vblank_seq;
d1015 2
a1016 2
	CARD64 current_msc;
	current_msc = last_vblank_seq + interpolated_vblanks;
d1029 1
a1029 2
	    target_seq = (int)*target_msc - interpolated_vblanks;
	    delta_seq = (int64_t)target_seq - (int64_t)last_vblank_seq;
d1050 2
a1051 2
 * Get current frame count and frame count timestamp, based on drawable's
 * crtc.
a1054 5
    ScreenPtr screen = draw->pScreen;
    ScrnInfoPtr scrn = xf86ScreenToScrn(screen);
    RADEONInfoPtr info = RADEONPTR(scrn);
    drmVBlank vbl;
    int ret;
a1062 5
    if (radeon_crtc_is_enabled(crtc)) {
	/* CRTC is running, read vblank counter and timestamp */
	vbl.request.type = DRM_VBLANK_RELATIVE;
	vbl.request.type |= radeon_populate_vbl_request_type(crtc);
	vbl.request.sequence = 0;
d1064 2
a1065 14
	ret = drmWaitVBlank(info->dri2.drm_fd, &vbl);
	if (ret) {
	    xf86DrvMsg(scrn->scrnIndex, X_WARNING,
		       "get vblank counter failed: %s\n", strerror(errno));
	    return FALSE;
	}

	*ust = ((CARD64)vbl.reply.tval_sec * 1000000) + vbl.reply.tval_usec;
	*msc = vbl.reply.sequence + radeon_get_interpolated_vblanks(crtc);
	*msc &= 0xffffffff;
    } else {
	/* CRTC is not running, extrapolate MSC and timestamp */
	drmmode_crtc_private_ptr drmmode_crtc = crtc->driver_private;
	CARD64 now, delta_t, delta_seq;
d1067 2
a1068 20
	if (!drmmode_crtc->dpms_last_ust)
	    return FALSE;
	ret = drmmode_get_current_ust(info->dri2.drm_fd, &now);
	if (ret) {
	    xf86DrvMsg(scrn->scrnIndex, X_ERROR,
		       "%s cannot get current time\n", __func__);
	    return FALSE;
	}
	delta_t = now - drmmode_crtc->dpms_last_ust;
	delta_seq = delta_t * drmmode_crtc->dpms_last_fps;
	delta_seq /= 1000000;
	*ust = drmmode_crtc->dpms_last_ust;
	delta_t = delta_seq * 1000000;
	delta_t /= drmmode_crtc->dpms_last_fps;
	*ust += delta_t;
	*msc = drmmode_crtc->dpms_last_seq;
	*msc += drmmode_crtc->interpolated_vblanks;
	*msc += delta_seq;
	*msc &= 0xffffffff;
    }
d1076 1
a1076 2
    DrawablePtr drawable;
    ScreenPtr screen;
a1078 1
    int status;
a1080 1
    unsigned int tv_sec, tv_usec;
a1082 1
    TimerFree(timer);
d1093 4
a1096 1
	radeon_dri2_frame_event_handler(0, 0, 0, data);
d1099 2
a1100 9
    status = dixLookupDrawable(&drawable, event_info->drawable_id, serverClient,
			       M_ANY, DixWriteAccess);
    if (status != Success) {
	ErrorF("%s cannot lookup drawable\n", __func__);
	radeon_dri2_frame_event_handler(0, 0, 0, data);
	return 0;
    }
    screen = drawable->pScreen;
    scrn = xf86ScreenToScrn(screen);
d1106 5
a1110 1
	radeon_dri2_frame_event_handler(0, 0, 0, data);
a1112 2
    tv_sec = (unsigned int)(drm_now / 1000000);
    tv_usec = (unsigned int)(drm_now - (CARD64)tv_sec * 1000000);
d1122 5
a1126 2
    frame &= 0xffffffff;
    radeon_dri2_frame_event_handler((unsigned int)frame, tv_sec, tv_usec, data);
d1131 1
a1131 1
void radeon_dri2_schedule_event(CARD32 delay, pointer arg)
d1133 2
a1134 3
    OsTimerPtr timer;

    timer = TimerSet(NULL, 0, delay, radeon_dri2_deferred_event, arg);
d1137 1
a1137 1
	radeon_dri2_deferred_event(timer, now, arg);
d1155 1
d1157 1
d1172 2
a1180 1
    wait_info->valid = TRUE;
a1182 8
    if (ListAddDRI2ClientEvents(client, &wait_info->link)) {
        xf86DrvMsg(scrn->scrnIndex, X_WARNING,
                "add events to client private failed.\n");
        free(wait_info);
        wait_info = NULL;
        goto out_complete;
    }

d1189 1
a1191 1
	wait_info->frame = target_msc;
d1208 1
a1208 1
    current_msc = vbl.reply.sequence + radeon_get_interpolated_vblanks(crtc);
d1211 10
d1237 2
a1238 3
        vbl.request.sequence = target_msc;
	vbl.request.sequence -= radeon_get_interpolated_vblanks(crtc);
        vbl.request.signal = (unsigned long)wait_info;
a1245 2
        wait_info->frame = vbl.reply.sequence;
	wait_info->frame += radeon_get_interpolated_vblanks(crtc);
d1258 1
a1258 1
        remainder;
a1267 1
    vbl.request.sequence -= radeon_get_interpolated_vblanks(crtc);
d1269 1
a1269 1
    vbl.request.signal = (unsigned long)wait_info;
a1276 2
    wait_info->frame = vbl.reply.sequence;
    wait_info->frame += radeon_get_interpolated_vblanks(crtc);
d1282 2
a1283 5
    if (wait_info) {
        ListDelDRI2ClientEvents(wait_info->client, &wait_info->link);
        free(wait_info);
    }
    DRI2WaitMSCComplete(client, draw, target_msc, 0, 0);
a1286 58
void radeon_dri2_flip_event_handler(unsigned int frame, unsigned int tv_sec,
				    unsigned int tv_usec, void *event_data)
{
    DRI2FrameEventPtr flip = event_data;
    DrawablePtr drawable;
    ScreenPtr screen;
    ScrnInfoPtr scrn;
    int status;
    PixmapPtr pixmap;

    status = dixLookupDrawable(&drawable, flip->drawable_id, serverClient,
			       M_ANY, DixWriteAccess);
    if (status != Success) {
	free(flip);
	return;
    }
    if (!flip->crtc) {
	free(flip);
	return;
    }
    frame += radeon_get_interpolated_vblanks(flip->crtc);

    screen = drawable->pScreen;
    scrn = xf86ScreenToScrn(screen);

    pixmap = screen->GetScreenPixmap(screen);
    xf86DrvMsgVerb(scrn->scrnIndex, X_INFO, RADEON_LOGLEVEL_DEBUG,
		   "%s:%d fevent[%p] width %d pitch %d (/4 %d)\n",
		   __func__, __LINE__, flip, pixmap->drawable.width, pixmap->devKind, pixmap->devKind/4);

    /* We assume our flips arrive in order, so we don't check the frame */
    switch (flip->type) {
    case DRI2_SWAP:
	/* Check for too small vblank count of pageflip completion, taking wraparound
	 * into account. This usually means some defective kms pageflip completion,
	 * causing wrong (msc, ust) return values and possible visual corruption.
	 */
	if ((frame < flip->frame) && (flip->frame - frame < 5)) {
	    xf86DrvMsg(scrn->scrnIndex, X_WARNING,
		       "%s: Pageflip completion event has impossible msc %d < target_msc %d\n",
		        __func__, frame, flip->frame);
	    /* All-Zero values signal failure of (msc, ust) timestamping to client. */
	    frame = tv_sec = tv_usec = 0;
	}

	DRI2SwapComplete(flip->client, drawable, frame, tv_sec, tv_usec,
			 DRI2_FLIP_COMPLETE, flip->event_complete,
			 flip->event_data);
	break;
    default:
	xf86DrvMsg(scrn->scrnIndex, X_WARNING, "%s: unknown vblank event received\n", __func__);
	/* Unknown type */
	break;
    }

    free(flip);
}

d1317 1
d1321 1
a1321 1
    enum DRI2FrameEventType swap_type = DRI2_SWAP;
d1343 2
d1349 1
a1355 1
    swap_info->valid = TRUE;
d1357 5
a1361 1
    if (ListAddDRI2ClientEvents(client, &swap_info->link)) {
d1363 1
a1363 3
                "add events to client private failed.\n");
        free(swap_info);
        swap_info = NULL;
d1366 1
d1375 1
d1378 2
a1379 1
	swap_info->frame = *target_msc;
d1393 1
a1393 3
	*target_msc = 0;
	radeon_dri2_schedule_event(FALLBACK_SWAP_DELAY, swap_info);
	return TRUE;
d1396 1
a1396 1
    current_msc = vbl.reply.sequence + radeon_get_interpolated_vblanks(crtc);
d1401 1
a1401 1
	swap_type = DRI2_FLIP;
d1405 1
a1405 3
    swap_info->type = swap_type;

    /* Correct target_msc by 'flip' if swap_type == DRI2_FLIP.
d1434 2
a1435 3
        vbl.request.sequence = *target_msc;
	vbl.request.sequence -= radeon_get_interpolated_vblanks(crtc);
        vbl.request.signal = (unsigned long)swap_info;
d1441 1
a1441 3
	    *target_msc = 0;
	    radeon_dri2_schedule_event(FALLBACK_SWAP_DELAY, swap_info);
            return TRUE;
d1444 1
a1444 2
        *target_msc = vbl.reply.sequence + flip;
	*target_msc += radeon_get_interpolated_vblanks(crtc);
d1461 1
a1461 1
        remainder;
a1475 1
    vbl.request.sequence -= radeon_get_interpolated_vblanks(crtc);
d1480 1
a1480 1
    vbl.request.signal = (unsigned long)swap_info;
d1486 1
a1486 3
	*target_msc = 0;
	radeon_dri2_schedule_event(FALLBACK_SWAP_DELAY, swap_info);
	return TRUE;
d1490 2
a1491 2
    *target_msc = vbl.reply.sequence + flip;
    *target_msc += radeon_get_interpolated_vblanks(crtc);
d1497 11
a1507 5
    box.x1 = 0;
    box.y1 = 0;
    box.x2 = draw->width;
    box.y2 = draw->height;
    REGION_INIT(pScreen, &region, &box, 0);
d1509 1
a1509 1
    radeon_dri2_copy_region(draw, &region, front, back);
d1511 2
a1512 4
    DRI2SwapComplete(client, draw, 0, 0, 0, DRI2_BLIT_COMPLETE, func, data);
    if (swap_info) {
        ListDelDRI2ClientEvents(swap_info->client, &swap_info->link);
        free(swap_info);
a1514 3
    radeon_dri2_unref_buffer(front);
    radeon_dri2_unref_buffer(back);

a1518 2
#endif /* USE_DRI2_SCHEDULING */

a1525 1
#ifdef USE_DRI2_SCHEDULING
a1527 1
#endif
a1551 1
#ifdef USE_DRI2_SCHEDULING
d1558 1
a1558 1
    if (scheduling_works && info->drmmode.mode_res->count_crtcs > 2) {
d1585 6
a1590 1
        driverNames[0] = driverNames[1] = dri2_info.driverName;
d1594 3
a1596 6
	    if (!dixRegisterPrivateKey(DRI2ClientEventsPrivateKey,
				       PRIVATE_CLIENT, sizeof(DRI2ClientEventsRec))) {
		xf86DrvMsg(pScrn->scrnIndex, X_WARNING, "DRI2 registering "
			   "private key to client failed\n");
		return FALSE;
	    }
d1598 5
a1602 4
	    if (!dixRequestPrivate(DRI2ClientEventsPrivateKey,
				   sizeof(DRI2ClientEventsRec))) {
		xf86DrvMsg(pScrn->scrnIndex, X_WARNING, "DRI2 requesting "
			   "private key to client failed\n");
a1604 1
#endif
a1610 1
#endif
a1627 1
#ifdef USE_DRI2_SCHEDULING
a1629 1
#endif
@


1.7
log
@Update to xf86-video-ati 7.3.0. Tested by jsg@@ ajacoutot@@.
@
text
@d412 8
a419 1
        src_drawable = drawable;
@


1.6
log
@Update to xf86-video-ati 7.2.0, requested by jsg@@

It fixes an endianess problem with kms and the in tree x86-video-ati
among other things.
It has been tested on various i386/amd64/sparc64/macppc machines
on a range of hardware from r100->northern islands.
@
text
@d69 4
a95 1
	ScrnInfoPtr scrn = xf86ScreenToScrn(screen);
a123 1
	screen->DestroyPixmap(pixmap);
d126 1
d128 1
a130 9
	/* This creating should not fail, as we already created its
	 * successfully. But if it happens, we put a warning indicator
	 * here, and the old pixmap will still be a glamor pixmap, and
	 * latter the pixmap_flink will get a 0 name, then the X server
	 * will pass a BadAlloc to the client.*/
	if (!radeon_glamor_create_textured_pixmap(old))
		xf86DrvMsg(scrn->scrnIndex, X_WARNING,
			   "Failed to get DRI drawable for glamor pixmap.\n");

d518 2
d893 1
a893 1
    int last_vblank_seq = drmmode_crtc->dpms_last_seq;
a1542 1
    RADEONEntPtr pRADEONEnt   = RADEONEntPriv(pScrn);
d1606 1
a1606 1
	if (pRADEONEnt->dri2_info_cnt == 0) {
d1626 1
a1626 1
	pRADEONEnt->dri2_info_cnt++;
d1645 1
d1647 1
a1647 3
    RADEONEntPtr pRADEONEnt   = RADEONEntPriv(pScrn);

    if (--pRADEONEnt->dri2_info_cnt == 0)
d1650 1
@


1.5
log
@Update to xf86-video-ati 6.14.6. Tested by mpi@@, brad, eric@@, ajacoutot@@.
@
text
@d32 6
a42 2
#include "radeon.h"
#include "radeon_dri2.h"
a55 1
#ifdef RADEON_DRI2
d59 2
a60 2
#if DRI2INFOREC_VERSION >= 1
#define USE_DRI2_1_1_0
d63 2
a64 2
#if DRI2INFOREC_VERSION >= 4 && HAVE_LIST_H
#define USE_DRI2_SCHEDULING
d67 2
a68 1
#if XORG_VERSION_CURRENT >= XORG_VERSION_NUMERIC(1,6,99,0, 0)
a69 3
#else
typedef DRI2Buffer2Ptr BufferPtr;
#endif
d78 10
a87 5
#ifndef USE_DRI2_1_1_0
static BufferPtr
radeon_dri2_create_buffers(DrawablePtr drawable,
                           unsigned int *attachments,
                           int count)
d89 17
a105 11
    ScreenPtr pScreen = drawable->pScreen;
    ScrnInfoPtr pScrn = xf86ScreenToScrn(pScreen);
    RADEONInfoPtr info = RADEONPTR(pScrn);
    BufferPtr buffers;
    struct dri2_buffer_priv *privates;
    PixmapPtr pixmap, depth_pixmap;
    struct radeon_exa_pixmap_priv *driver_priv;
    int i, r, need_enlarge = 0;
    int flags = 0;
    unsigned front_width;
    uint32_t tiling = 0;
d107 12
a118 2
    pixmap = screen->GetScreenPixmap(screen);
    front_width = pixmap->drawable.width;
d120 2
a121 64
    buffers = calloc(count, sizeof *buffers);
    if (buffers == NULL) {
        return NULL;
    }
    privates = calloc(count, sizeof(struct dri2_buffer_priv));
    if (privates == NULL) {
        free(buffers);
        return NULL;
    }

    depth_pixmap = NULL;
    for (i = 0; i < count; i++) {
        if (attachments[i] == DRI2BufferFrontLeft) {
            if (drawable->type == DRAWABLE_PIXMAP) {
                pixmap = (Pixmap*)drawable;
            } else {
                pixmap = (*pScreen->GetWindowPixmap)((WindowPtr)drawable);
            }
            pixmap->refcnt++;
        } else if (attachments[i] == DRI2BufferStencil && depth_pixmap) {
            pixmap = depth_pixmap;
            pixmap->refcnt++;
        } else {
	    /* tile the back buffer */
	    switch(attachments[i]) {
	    case DRI2BufferDepth:
		if (info->ChipFamily >= CHIP_FAMILY_R600)
		    /* macro is the preferred setting, but the 2D detiling for software
		     * fallbacks in mesa still has issues on some configurations
		     */
		    flags = RADEON_CREATE_PIXMAP_TILING_MICRO;
		else
		    flags = RADEON_CREATE_PIXMAP_TILING_MACRO | RADEON_CREATE_PIXMAP_TILING_MICRO;
		if (IS_R200_3D || info->ChipFamily == CHIP_FAMILY_RV200 || info->ChipFamily == CHIP_FAMILY_RADEON)
		    flags |= RADEON_CREATE_PIXMAP_DEPTH;
		break;
	    case DRI2BufferDepthStencil:
		if (info->ChipFamily >= CHIP_FAMILY_R600) {
		    /* macro is the preferred setting, but the 2D detiling for software
		     * fallbacks in mesa still has issues on some configurations
		     */
		    flags = RADEON_CREATE_PIXMAP_TILING_MICRO;
		    if (info->ChipFamily >= CHIP_FAMILY_CEDAR)
			need_enlarge = 1;
		} else
		    flags = RADEON_CREATE_PIXMAP_TILING_MACRO | RADEON_CREATE_PIXMAP_TILING_MICRO;
		if (IS_R200_3D || info->ChipFamily == CHIP_FAMILY_RV200 || info->ChipFamily == CHIP_FAMILY_RADEON)
		    flags |= RADEON_CREATE_PIXMAP_DEPTH;
		break;
	    case DRI2BufferBackLeft:
	    case DRI2BufferBackRight:
	    case DRI2BufferFakeFrontLeft:
	    case DRI2BufferFakeFrontRight:
		if (info->ChipFamily >= CHIP_FAMILY_R600)
		    /* macro is the preferred setting, but the 2D detiling for software
		     * fallbacks in mesa still has issues on some configurations
		     */
		    flags = RADEON_CREATE_PIXMAP_TILING_MICRO;
		else
		    flags = RADEON_CREATE_PIXMAP_TILING_MACRO;
		break;
	    default:
		flags = 0;
	    }
d123 19
a141 48
	    if (flags & RADEON_CREATE_PIXMAP_TILING_MICRO)
		tiling |= RADEON_TILING_MICRO;
	    if (flags & RADEON_CREATE_PIXMAP_TILING_MACRO)
		tiling |= RADEON_TILING_MACRO;

	    if (need_enlarge) {
		/* evergreen uses separate allocations for depth and stencil
		 * so we make an extra large depth buffer to cover stencil
		 * as well.
		 */
		unsigned aligned_width = drawable->width;
		unsigned width_align = drmmode_get_pitch_align(pScrn, drawable->depth / 8, tiling);
		unsigned aligned_height;
		unsigned height_align = drmmode_get_height_align(pScrn, tiling);
		unsigned base_align = drmmode_get_base_align(pScrn, drawable->depth / 8, tiling);
		unsigned pitch_bytes;
		unsigned size;

		if (aligned_width == front_width)
		    aligned_width = pScrn->virtualX;
		aligned_width = RADEON_ALIGN(aligned_width, width_align);
		pitch_bytes = aligned_width * (drawable->depth / 8);
		aligned_height = RADEON_ALIGN(drawable->height, height_align);
		size = pitch_bytes * aligned_height;
		size = RADEON_ALIGN(size, base_align);
		/* add additional size for stencil */
		size += aligned_width * aligned_height;
		aligned_height = RADEON_ALIGN(size / pitch_bytes, height_align);

		pixmap = (*pScreen->CreatePixmap)(pScreen,
						  aligned_width,
						  aligned_height,
						  drawable->depth,
						  flags);

	    } else {
		unsigned aligned_width = drawable->width;

		if (aligned_width == front_width)
		    aligned_width = pScrn->virtualX;

		pixmap = (*pScreen->CreatePixmap)(pScreen,
						  aligned_width,
						  drawable->height,
						  drawable->depth,
						  flags);
	    }
        }
d143 1
a143 18
        if (attachments[i] == DRI2BufferDepth) {
            depth_pixmap = pixmap;
        }
	info->exa_force_create = TRUE;
	exaMoveInPixmap(pixmap);
	info->exa_force_create = FALSE;
        driver_priv = exaGetPixmapDriverPrivate(pixmap);
	if (!driver_priv ||
	    radeon_gem_get_kernel_name(driver_priv->bo, &buffers[i].name) != 0) {
	    int j;

	    for (j = 0; j < i; j++)
		(*pScreen->DestroyPixmap)(privates[j].pixmap);
	    (*pScreen->DestroyPixmap)(pixmap);
	    free(privates);
	    free(buffers);
	    return NULL;
	}
d145 1
a145 9
        buffers[i].attachment = attachments[i];
        buffers[i].pitch = pixmap->devKind;
        buffers[i].cpp = pixmap->drawable.bitsPerPixel / 8;
        buffers[i].driverPrivate = &privates[i];
        buffers[i].flags = 0;
        privates[i].pixmap = pixmap;
        privates[i].attachment = attachments[i];
    }
    return buffers;
d147 2
a148 1
#else
d150 4
a153 3
radeon_dri2_create_buffer(DrawablePtr drawable,
                          unsigned int attachment,
                          unsigned int format)
a154 1
    ScreenPtr pScreen = drawable->pScreen;
d160 1
a160 1
    struct radeon_exa_pixmap_priv *driver_priv;
d165 22
d194 10
a203 6
        if (drawable->type == DRAWABLE_PIXMAP) {
            pixmap = (PixmapPtr)drawable;
        } else {
            pixmap = (*pScreen->GetWindowPixmap)((WindowPtr)drawable);
        }
        pixmap->refcnt++;
d207 3
a209 1
    } else {
d224 3
a226 1
	    } else
d243 3
a245 1
	    } else
d253 2
d272 2
a276 1

d282 3
a284 3
					      drawable->height,
					      (format != 0)?format:drawable->depth,
					      flags);
a286 3
    if (!pixmap)
        return NULL;

d294 18
a311 7
    info->exa_force_create = TRUE;
    exaMoveInPixmap(pixmap);
    info->exa_force_create = FALSE;
    driver_priv = exaGetPixmapDriverPrivate(pixmap);
    if (!driver_priv ||
	(radeon_gem_get_kernel_name(driver_priv->bo, &buffers->name) != 0))
        goto error;
d318 4
a321 2
    buffers->pitch = pixmap->devKind;
    buffers->cpp = pixmap->drawable.bitsPerPixel / 8;
a336 1
#endif
d338 3
a340 5
#ifndef USE_DRI2_1_1_0
static void
radeon_dri2_destroy_buffers(DrawablePtr drawable,
                            BufferPtr buffers,
                            int count)
d342 3
a344 3
    ScreenPtr pScreen = drawable->pScreen;
    struct dri2_buffer_priv *private;
    int i;
a345 10
    for (i = 0; i < count; i++) {
        private = buffers[i].driverPrivate;
        (*pScreen->DestroyPixmap)(private->pixmap);
    }
    if (buffers) {
        free(buffers[0].driverPrivate);
        free(buffers);
    }
}
#else
d347 2
a348 1
radeon_dri2_destroy_buffer(DrawablePtr drawable, BufferPtr buffers)
a351 1
        ScreenPtr pScreen = drawable->pScreen;
d367 2
a368 1
            (*pScreen->DestroyPixmap)(private->pixmap);
a374 1
#endif
d376 16
d393 5
a397 4
radeon_dri2_copy_region(DrawablePtr drawable,
                        RegionPtr region,
                        BufferPtr dest_buffer,
                        BufferPtr src_buffer)
a400 1
    ScreenPtr pScreen = drawable->pScreen;
d408 7
a417 2
    } else {
        src_drawable = &src_private->pixmap->drawable;
d420 18
a437 3
        dst_drawable = drawable;
    } else {
        dst_drawable = &dst_private->pixmap->drawable;
d442 5
d460 1
a460 2
		struct radeon_exa_pixmap_priv *exa_priv =
		    exaGetPixmapDriverPrivate(dst_private->pixmap);
d462 2
a463 2
		if (exa_priv && exa_priv->bo)
		    radeon_bo_wait(exa_priv->bo);
d472 1
d475 1
a475 1
                         0, 0, drawable->width, drawable->height, 0, 0);
d477 1
d483 7
d504 1
d609 2
a610 1
static int radeon_dri2_drawable_crtc(DrawablePtr pDraw)
a614 1
    int crtc_id = -1;
d616 1
a616 1
    crtc = radeon_pick_best_crtc(pScrn,
d623 4
a626 4
    if (crtc != NULL && !crtc->rotatedData) {
        crtc_id = drmmode_get_crtc_id(crtc);
    }
    return crtc_id;
d636 1
a636 1
    struct radeon_exa_pixmap_priv *exa_priv;
a637 1

d639 2
a640 1
    int ref_crtc_hw_id = radeon_dri2_drawable_crtc(draw);
d652 1
d659 1
a659 1
    exa_priv = exaGetPixmapDriverPrivate(back_priv->pixmap);
d661 1
a661 1
    return radeon_do_pageflip(scrn, exa_priv->bo, flip_info, ref_crtc_hw_id);
d669 1
d671 1
a671 6
    struct radeon_exa_pixmap_priv *driver_priv;

    if (draw->type == DRAWABLE_PIXMAP)
	pixmap = (PixmapPtr)draw;
    else
	pixmap = (*draw->pScreen->GetWindowPixmap)((WindowPtr)draw);
d673 1
d676 4
a679 3
    exaMoveInPixmap(pixmap);
    driver_priv = exaGetPixmapDriverPrivate(pixmap);
    r = radeon_gem_get_kernel_name(driver_priv->bo, &front->name);
d745 1
a745 1
    struct radeon_exa_pixmap_priv *front_radeon, *back_radeon;
d748 1
a748 1
    struct radeon_bo *bo;
d751 6
d763 4
a766 5
    front_radeon = exaGetPixmapDriverPrivate(front_priv->pixmap);
    back_radeon = exaGetPixmapDriverPrivate(back_priv->pixmap);
    bo = back_radeon->bo;
    back_radeon->bo = front_radeon->bo;
    front_radeon->bo = bo;
d771 2
a772 1
    if (front_radeon->bo == info->front_bo) {
d774 2
a775 4
	info->front_bo = back_radeon->bo;
	radeon_bo_ref(info->front_bo);
	front_radeon = exaGetPixmapDriverPrivate(screen->GetScreenPixmap(screen));
        front_radeon->bo = bo;
d777 4
d802 3
d862 1
a862 1
static drmVBlankSeqType populate_vbl_request_type(RADEONInfoPtr info, int crtc)
d865 1
d867 1
a867 1
    if (crtc == 1)
d869 1
a869 1
    else if (crtc > 1)
d871 1
a871 1
	type |= (crtc << DRM_VBLANK_HIGH_CRTC_SHIFT) &
d876 1
a876 1
	       __func__, crtc);
d883 76
d969 1
a969 1
    int crtc = radeon_dri2_drawable_crtc(draw);
d972 1
a972 1
    if (crtc == -1) {
d977 59
a1035 3
    vbl.request.type = DRM_VBLANK_RELATIVE;
    vbl.request.type |= populate_vbl_request_type(info, crtc);
    vbl.request.sequence = 0;
d1037 23
a1059 1
    ret = drmWaitVBlank(info->dri2.drm_fd, &vbl);
d1061 4
a1064 3
        xf86DrvMsg(scrn->scrnIndex, X_WARNING,
                "get vblank counter failed: %s\n", strerror(errno));
        return FALSE;
d1066 15
d1082 4
a1085 2
    *ust = ((CARD64)vbl.reply.tval_sec * 1000000) + vbl.reply.tval_usec;
    *msc = vbl.reply.sequence;
d1087 5
a1091 1
    return TRUE;
d1108 1
d1110 1
a1110 1
    int ret, crtc = radeon_dri2_drawable_crtc(draw);
d1120 1
a1120 1
    if (crtc == -1)
d1131 1
d1141 14
d1157 1
a1157 1
    vbl.request.type |= populate_vbl_request_type(info, crtc);
d1166 2
a1167 1
    current_msc = vbl.reply.sequence;
d1184 1
a1184 1
	vbl.request.type |= populate_vbl_request_type(info, crtc);
d1186 1
d1196 1
d1206 1
a1206 1
    vbl.request.type |= populate_vbl_request_type(info, crtc);
d1219 1
d1230 1
d1260 5
d1331 1
d1333 1
a1333 1
    int ret, crtc= radeon_dri2_drawable_crtc(draw), flip = 0;
d1353 2
a1354 2
    /* Drawable not displayed... just complete the swap */
    if (crtc == -1)
d1368 1
d1377 14
d1393 1
a1393 1
    vbl.request.type |= populate_vbl_request_type(info, crtc);
d1400 3
a1402 1
        goto blit_fallback;
d1405 2
a1406 1
    current_msc = vbl.reply.sequence;
d1436 1
a1436 1
	vbl.request.type |= populate_vbl_request_type(info, crtc);
d1446 1
d1453 3
a1455 1
            goto blit_fallback;
d1459 1
d1473 1
a1473 1
    vbl.request.type |= populate_vbl_request_type(info, crtc);
d1491 1
d1502 3
a1504 1
        goto blit_fallback;
d1509 1
d1551 1
a1551 2
    if (!info->useEXA) {
        xf86DrvMsg(pScrn->scrnIndex, X_WARNING, "DRI2 requires EXA\n");
a1552 1
    }
d1556 3
a1558 1
    if ( (info->ChipFamily >= CHIP_FAMILY_R600) ) {
a1568 5
#ifndef USE_DRI2_1_1_0
    dri2_info.version = 1;
    dri2_info.CreateBuffers = radeon_dri2_create_buffers;
    dri2_info.DestroyBuffers = radeon_dri2_destroy_buffers;
#else
a1571 1
#endif
d1575 1
a1575 1
    if (info->dri->pKernelDRMVersion->version_minor < 4) {
d1634 7
d1659 2
a1660 1
#endif
@


1.4
log
@Update to xf86-video-ati 6.14.4. Tested by jasper@@, krw@@, mpi@@, shadchin@@
@
text
@d84 1
a84 1
    ScrnInfoPtr pScrn = xf86Screens[pScreen->myNum];
d248 1
a248 1
    ScrnInfoPtr pScrn = xf86Screens[pScreen->myNum];
d417 1
a417 1
            ScrnInfoPtr scrn = xf86Screens[pScreen->myNum];
d446 1
a446 1
    ScrnInfoPtr pScrn = xf86Screens[pScreen->myNum];
d623 1
a623 1
    ScrnInfoPtr pScrn = xf86Screens[pScreen->myNum];
d747 1
d777 1
a777 1
    info = RADEONPTR(xf86Screens[screen->myNum]);
d808 1
a808 1
    scrn = xf86Screens[screen->myNum];
d889 1
a889 1
    ScrnInfoPtr scrn = xf86Screens[screen->myNum];
d929 1
a929 1
    ScrnInfoPtr scrn = xf86Screens[screen->myNum];
d1065 1
a1065 1
    scrn = xf86Screens[screen->myNum];
d1127 1
a1127 1
    ScrnInfoPtr scrn = xf86Screens[screen->myNum];
d1313 1
a1313 1
    ScrnInfoPtr pScrn = xf86Screens[pScreen->myNum];
d1417 1
a1417 1
    ScrnInfoPtr pScrn = xf86Screens[pScreen->myNum];
@


1.3
log
@Re-update xf86-video-ati to 6.14.3.

Because of ati.c revision 1.5, it will not be selected by
autoconfiguration code, so people who want to run this version of the
driver on their radeon cards need an explicit "Device" section in
xorg.conf.
@
text
@d43 7
d131 2
d144 2
a253 1
    int need_enlarge = 0;
d257 1
d281 9
a289 3
	    if (info->ChipFamily >= CHIP_FAMILY_R600)
		flags = RADEON_CREATE_PIXMAP_TILING_MICRO;
	    else
d291 2
d299 5
a303 1
		flags = RADEON_CREATE_PIXMAP_TILING_MICRO;
d305 1
a305 1
		    need_enlarge = 1;
d308 3
d316 7
a322 6
	    if (info->ChipFamily >= CHIP_FAMILY_R600)
		/* macro is the preferred setting, but the 2D detiling for software
		 * fallbacks in mesa still has issues on some configurations
		 */
		flags = RADEON_CREATE_PIXMAP_TILING_MICRO;
	    else
a333 33
	if (need_enlarge) {
	    /* evergreen uses separate allocations for depth and stencil
	     * so we make an extra large depth buffer to cover stencil
	     * as well.
	     */
	    int depth = (format != 0) ? format : drawable->depth;
	    unsigned aligned_width = drawable->width;
	    unsigned width_align = drmmode_get_pitch_align(pScrn, drawable->depth / 8, tiling);
	    unsigned aligned_height;
	    unsigned height_align = drmmode_get_height_align(pScrn, tiling);
	    unsigned base_align = drmmode_get_base_align(pScrn, drawable->depth / 8, tiling);
	    unsigned pitch_bytes;
	    unsigned size;

	    if (aligned_width == front_width)
		aligned_width = pScrn->virtualX;
	    aligned_width = RADEON_ALIGN(aligned_width, width_align);
	    pitch_bytes = aligned_width * (depth / 8);
	    aligned_height = RADEON_ALIGN(drawable->height, height_align);
	    size = pitch_bytes * aligned_height;
	    size = RADEON_ALIGN(size, base_align);
	    /* add additional size for stencil */
	    size += aligned_width * aligned_height;
	    aligned_height = RADEON_ALIGN(size / pitch_bytes, height_align);

	    pixmap = (*pScreen->CreatePixmap)(pScreen,
					      aligned_width,
					      aligned_height,
					      (format != 0)?format:drawable->depth,
					      flags);

	} else {
	    unsigned aligned_width = drawable->width;
a342 1
	}
d525 1
a525 1
    struct list link;
d529 1
a529 1
    struct list   reference_list;
d548 1
a548 1
ListAddDRI2ClientEvents(ClientPtr client, struct list *entry)
d557 1
a557 1
    list_add(entry, &pClientPriv->reference_list);
d562 1
a562 1
ListDelDRI2ClientEvents(ClientPtr client, struct list *entry)
d570 17
a586 1
    list_del(entry);
d600 1
a600 1
        list_init(&pClientEventsPriv->reference_list);
d608 1
a608 1
            list_for_each_entry(ref, &pClientEventsPriv->reference_list, link) {
d610 2
a619 16
static void
radeon_dri2_ref_buffer(BufferPtr buffer)
{
    struct dri2_buffer_priv *private = buffer->driverPrivate;
    private->refcnt++;
}

static void
radeon_dri2_unref_buffer(BufferPtr buffer)
{
    if (buffer) {
        struct dri2_buffer_priv *private = buffer->driverPrivate;
        radeon_dri2_destroy_buffer(&(private->pixmap->drawable), buffer);
    }
}

d741 10
a789 1
    RADEONInfoPtr info;
a807 1
    info = RADEONPTR(scrn);
d811 1
a811 3
	if (info->allowPageFlip &&
	    DRI2CanFlip(drawable) &&
	    can_exchange(scrn, drawable, event->front, event->back) &&
d854 3
a856 3
    radeon_dri2_unref_buffer(event->front);
    radeon_dri2_unref_buffer(event->back);
    if (event->valid)
d858 1
d1187 1
a1187 3
    if (info->allowPageFlip &&
	DRI2CanFlip(draw) &&
	can_exchange(scrn, draw, front, back)) {
@


1.2
log
@Revert the update to xf86-video-ati 6.14.3. Requested by espie@@
who experiemnts regressions with this driver.
@
text
@@


1.1
log
@Update to xf86-video-ati 6.14.3. Tested by many.
@
text
@@

