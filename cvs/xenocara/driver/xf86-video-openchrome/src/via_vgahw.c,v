head	1.2;
access;
symbols
	OPENBSD_6_2:1.2.0.22
	OPENBSD_6_2_BASE:1.2
	OPENBSD_6_1:1.2.0.20
	OPENBSD_6_1_BASE:1.2
	OPENBSD_6_0:1.2.0.18
	OPENBSD_6_0_BASE:1.2
	OPENBSD_5_9:1.2.0.16
	OPENBSD_5_9_BASE:1.2
	OPENBSD_5_8:1.2.0.14
	OPENBSD_5_8_BASE:1.2
	OPENBSD_5_7:1.2.0.12
	OPENBSD_5_7_BASE:1.2
	OPENBSD_5_6:1.2.0.10
	OPENBSD_5_6_BASE:1.2
	OPENBSD_5_5:1.2.0.8
	OPENBSD_5_5_BASE:1.2
	OPENBSD_5_4:1.2.0.6
	OPENBSD_5_4_BASE:1.2
	OPENBSD_5_3:1.2.0.4
	OPENBSD_5_3_BASE:1.2
	OPENBSD_5_2:1.2.0.2
	OPENBSD_5_2_BASE:1.2
	OPENBSD_5_1_BASE:1.1.1.1
	OPENBSD_5_1:1.1.1.1.0.16
	OPENBSD_5_0:1.1.1.1.0.14
	OPENBSD_5_0_BASE:1.1.1.1
	OPENBSD_4_9:1.1.1.1.0.10
	OPENBSD_4_9_BASE:1.1.1.1
	OPENBSD_4_8:1.1.1.1.0.12
	OPENBSD_4_8_BASE:1.1.1.1
	OPENBSD_4_7:1.1.1.1.0.8
	OPENBSD_4_7_BASE:1.1.1.1
	OPENBSD_4_6:1.1.1.1.0.6
	OPENBSD_4_6_BASE:1.1.1.1
	OPENBSD_4_5:1.1.1.1.0.4
	OPENBSD_4_5_BASE:1.1.1.1
	OPENBSD_4_4:1.1.1.1.0.2
	OPENBSD_4_4_BASE:1.1.1.1
	v0_2_902:1.1.1.1
	openchrome:1.1.1;
locks; strict;
comment	@ * @;


1.2
date	2012.05.15.21.32.57;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2008.07.12.12.48.36;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2008.07.12.12.48.36;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.2
log
@Update xf86-video-openchrome to 0.2.905
@
text
@/*
 * Copyright 2004-2005 The Unichrome Project  [unichrome.sf.net]
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sub license,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice (including the
 * next paragraph) shall be included in all copies or substantial portions
 * of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT. IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 */

/*
 * Wrappers around xf86 vgaHW functions.
 * And some generic IO calls lacking in the current vgaHW implementation.
 */

#ifdef HAVE_CONFIG_H
#include "config.h"
#endif

#include "via.h"
#include "compiler.h"
#include "xf86.h"
#include "via_driver.h" /* for HAVE_DEBUG */
#include "via_vgahw.h"

#if ABI_VIDEODRV_VERSION < 12
#define PIOOFFSET hwp->PIOOffset
#else
#define PIOOFFSET 0
#endif

static CARD8
ViaVgahwIn(vgaHWPtr hwp, int address)
{
    if (hwp->MMIOBase)
        return MMIO_IN8(hwp->MMIOBase, hwp->MMIOOffset + address);
    else
        return inb(PIOOFFSET + address);
}

static void
ViaVgahwOut(vgaHWPtr hwp, int address, CARD8 value)
{
    if (hwp->MMIOBase)
        MMIO_OUT8(hwp->MMIOBase, hwp->MMIOOffset + address, value);
    else
        outb(PIOOFFSET + address, value);
}

/*
 * An indexed read.
 */
static CARD8
ViaVgahwRead(vgaHWPtr hwp, int indexaddress, CARD8 index, int valueaddress)
{
    ViaVgahwOut(hwp, indexaddress, index);
    return ViaVgahwIn(hwp, valueaddress);
}

/*
 * An indexed write.
 */
void
ViaVgahwWrite(vgaHWPtr hwp, int indexaddress, CARD8 index,
              int valueaddress, CARD8 value)
{
    ViaVgahwOut(hwp, indexaddress, index);
    ViaVgahwOut(hwp, valueaddress, value);
}


void
ViaVgahwMask(vgaHWPtr hwp, int indexaddress, CARD8 index,
             int valueaddress, CARD8 value, CARD8 mask)
{
    CARD8 tmp;

    tmp = ViaVgahwRead(hwp, indexaddress, index, valueaddress);
    tmp &= ~mask;
    tmp |= (value & mask);

    ViaVgahwWrite(hwp, indexaddress, index, valueaddress, tmp);
}

void
ViaCrtcMask(vgaHWPtr hwp, CARD8 index, CARD8 value, CARD8 mask)
{
    CARD8 tmp;

    tmp = hwp->readCrtc(hwp, index);
    tmp &= ~mask;
    tmp |= (value & mask);

    hwp->writeCrtc(hwp, index, tmp);
}

void
ViaSeqMask(vgaHWPtr hwp, CARD8 index, CARD8 value, CARD8 mask)
{
    CARD8 tmp;

    tmp = hwp->readSeq(hwp, index);
    tmp &= ~mask;
    tmp |= (value & mask);

    hwp->writeSeq(hwp, index, tmp);
}

void
ViaGrMask(vgaHWPtr hwp, CARD8 index, CARD8 value, CARD8 mask)
{
    CARD8 tmp;

    tmp = hwp->readGr(hwp, index);
    tmp &= ~mask;
    tmp |= (value & mask);

    hwp->writeGr(hwp, index, tmp);
}


#ifdef HAVE_DEBUG
void
ViaVgahwPrint(vgaHWPtr hwp)
{
    int i;

    xf86DrvMsg(hwp->pScrn->scrnIndex, X_INFO, "VGA Sequence registers:\n");
    for (i = 0x00; i < 0x80; i++)
        xf86DrvMsg(hwp->pScrn->scrnIndex, X_INFO,
                   "SR%02X: 0x%02X\n", i, hwp->readSeq(hwp, i));

    xf86DrvMsg(hwp->pScrn->scrnIndex, X_INFO, "VGA CRTM/C registers:\n");
    for (i = 0x00; i < 0x19; i++)
        xf86DrvMsg(hwp->pScrn->scrnIndex, X_INFO,
                   "CR%02X: 0x%02X\n", i, hwp->readCrtc(hwp, i));
    for (i = 0x33; i < 0xA3; i++)
        xf86DrvMsg(hwp->pScrn->scrnIndex, X_INFO,
                   "CR%02X: 0x%02X\n", i, hwp->readCrtc(hwp, i));

    xf86DrvMsg(hwp->pScrn->scrnIndex, X_INFO, "VGA Graphics registers:\n");
    for (i = 0x00; i < 0x08; i++)
        xf86DrvMsg(hwp->pScrn->scrnIndex, X_INFO,
                   "GR%02X: 0x%02X\n", i, hwp->readGr(hwp, i));

    xf86DrvMsg(hwp->pScrn->scrnIndex, X_INFO, "VGA Attribute registers:\n");
    for (i = 0x00; i < 0x14; i++)
        xf86DrvMsg(hwp->pScrn->scrnIndex, X_INFO,
                   "AR%02X: 0x%02X\n", i, hwp->readAttr(hwp, i));

    xf86DrvMsg(hwp->pScrn->scrnIndex, X_INFO, "VGA Miscellaneous register:\n");
    xf86DrvMsg(hwp->pScrn->scrnIndex, X_INFO,
               "Misc: 0x%02X\n", hwp->readMiscOut(hwp));

    xf86DrvMsg(hwp->pScrn->scrnIndex, X_INFO, "End of VGA registers.\n");
}
#endif /* HAVE_DEBUG */
@


1.1
log
@Initial revision
@
text
@d39 5
d51 1
a51 1
        return inb(hwp->PIOOffset + address);
d60 1
a60 1
        outb(hwp->PIOOffset + address, value);
@


1.1.1.1
log
@Import the openchrome video driver, version 0.2.902. Discussed with
bernd@@ and oga@@. Tested by many in snaphots.
@
text
@@
