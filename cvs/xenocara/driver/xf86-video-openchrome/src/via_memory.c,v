head	1.6;
access;
symbols
	OPENBSD_6_1_BASE:1.6
	OPENBSD_6_0:1.6.0.16
	OPENBSD_6_0_BASE:1.6
	OPENBSD_5_9:1.6.0.14
	OPENBSD_5_9_BASE:1.6
	OPENBSD_5_8:1.6.0.12
	OPENBSD_5_8_BASE:1.6
	OPENBSD_5_7:1.6.0.10
	OPENBSD_5_7_BASE:1.6
	OPENBSD_5_6:1.6.0.8
	OPENBSD_5_6_BASE:1.6
	OPENBSD_5_5:1.6.0.6
	OPENBSD_5_5_BASE:1.6
	OPENBSD_5_4:1.6.0.4
	OPENBSD_5_4_BASE:1.6
	OPENBSD_5_3:1.6.0.2
	OPENBSD_5_3_BASE:1.6
	OPENBSD_5_2:1.4.0.14
	OPENBSD_5_2_BASE:1.4
	OPENBSD_5_1_BASE:1.4
	OPENBSD_5_1:1.4.0.12
	OPENBSD_5_0:1.4.0.10
	OPENBSD_5_0_BASE:1.4
	OPENBSD_4_9:1.4.0.6
	OPENBSD_4_9_BASE:1.4
	OPENBSD_4_8:1.4.0.8
	OPENBSD_4_8_BASE:1.4
	OPENBSD_4_7:1.4.0.4
	OPENBSD_4_7_BASE:1.4
	OPENBSD_4_6:1.4.0.2
	OPENBSD_4_6_BASE:1.4
	OPENBSD_4_5:1.3.0.2
	OPENBSD_4_5_BASE:1.3
	OPENBSD_4_4:1.1.1.1.0.2
	OPENBSD_4_4_BASE:1.1.1.1
	v0_2_902:1.1.1.1
	openchrome:1.1.1;
locks; strict;
comment	@ * @;


1.6
date	2012.11.11.21.34.15;	author matthieu;	state Exp;
branches;
next	1.5;

1.5
date	2012.09.11.20.25.34;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2009.06.25.21.27.19;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2009.01.08.20.28.57;	author oga;	state Exp;
branches;
next	1.2;

1.2
date	2008.11.03.20.37.24;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2008.07.12.12.48.30;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2008.07.12.12.48.30;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.6
log
@Patch the driver a bit more, to be able to build without XAA.
@
text
@/*
 * Copyright 2003 Red Hat, Inc. All Rights Reserved.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sub license,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice (including the
 * next paragraph) shall be included in all copies or substantial portions
 * of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT. IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 */

#ifdef HAVE_CONFIG_H
#include "config.h"
#endif

#include "xf86.h"
#include "xf86_OSproc.h"
#include "xf86fbman.h"

#include "via.h"

#ifdef OPENCHROMEDRI
#include "xf86drm.h"
#endif

#include "via_driver.h"
#include "via_priv.h"
#include "via_swov.h"
#ifdef OPENCHROMEDRI
#include "via_drm.h"
#endif

/*
 *	Isolate the wonders of X memory allocation and DRI memory allocation
 *	and 4.3 or 4.4 differences in one abstraction.
 *
 *	The pool code indicates who provided the memory:
 *	0  -  nobody
 *	1  -  xf86 linear 
 *	2  -  DRM
 */

static void
viaExaFBSave(ScreenPtr pScreen, ExaOffscreenArea * exa)
{
    FatalError("Xserver is incompatible with openchrome EXA.\n"
               "\t\tPlease look at Xorg bugzilla bug #7639, and at\n"
               "\t\thttp://wiki.openchrome.org/tikiwiki/tiki-index"
               ".php?page=EXAAcceleration .\n");
}

void
VIAFreeLinear(VIAMemPtr mem)
{
    DEBUG(ErrorF("Freed %lu (pool %d)\n", mem->base, mem->pool));
    switch (mem->pool) {
        case 0:
            return;
        case 1:
            {
                VIAPtr pVia = VIAPTR(mem->pScrn);

                if (pVia->useEXA && !pVia->NoAccel) {
                    exaOffscreenFree(mem->pScrn->pScreen, mem->exa);
#ifdef USE_XAA
                    mem->linear = NULL;
#endif
                    mem->pool = 0;
                    return;
                }
            }
#ifdef USE_XAA
            xf86FreeOffscreenLinear(mem->linear);
            mem->linear = NULL;
            mem->pool = 0;
#endif
            return;
        case 2:
#ifdef OPENCHROMEDRI
            if (drmCommandWrite(mem->drm_fd, DRM_VIA_FREEMEM,
                                &mem->drm, sizeof(drm_via_mem_t)) < 0)
                ErrorF("DRM module failed free.\n");
#endif
            mem->pool = 0;
            return;
    }
}
int
viaOffScreenLinear(VIAMemPtr mem, ScrnInfoPtr pScrn, unsigned long size)
{
    int depth = pScrn->bitsPerPixel >> 3;

    VIAPtr pVia = VIAPTR(pScrn);

    if (pVia->useEXA && !pVia->NoAccel) {

        mem->exa = exaOffscreenAlloc(pScrn->pScreen, size,
                                     32, TRUE, NULL, NULL);
        if (mem->exa == NULL)
            return BadAlloc;
        mem->exa->save = viaExaFBSave;
        mem->base = mem->exa->offset;
        mem->pool = 1;
        mem->pScrn = pScrn;
        return Success;
    }
#ifdef USE_XAA
    mem->linear = xf86AllocateOffscreenLinear(pScrn->pScreen,
                                              (size + depth - 1) / depth,
                                              32, NULL, NULL, NULL);
    if (mem->linear == NULL)
        return BadAlloc;
    mem->base = mem->linear->offset * depth;
    mem->pool = 1;
    mem->pScrn = pScrn;
#endif
    return Success;
}

int
VIAAllocLinear(VIAMemPtr mem, ScrnInfoPtr pScrn, unsigned long size)
{
#ifdef OPENCHROMEDRI
    VIAPtr pVia = VIAPTR(pScrn);
    int ret;

    if (mem->pool)
        ErrorF("VIA Double Alloc.\n");

    if (pVia->directRenderingEnabled) {
        mem->pScrn = pScrn;
        mem->drm_fd = pVia->drmFD;
        mem->drm.context = DRIGetContext(pScrn->pScreen);
        mem->drm.size = size;
        mem->drm.type = VIA_MEM_VIDEO;
        ret = drmCommandWriteRead(mem->drm_fd, DRM_VIA_ALLOCMEM,
                                  &mem->drm, sizeof(drm_via_mem_t));
        if (ret || (size != mem->drm.size)) {
            /* Try X Offsceen fallback before failing. */
            if (Success == viaOffScreenLinear(mem, pScrn, size))
                return Success;
            ErrorF("DRM memory allocation failed\n");
            return BadAlloc;
        }

        mem->base = mem->drm.offset;
        mem->pool = 2;
        DEBUG(ErrorF("Fulfilled via DRI at %lu\n", mem->base));
        return Success;
    }
#endif
    if (Success == viaOffScreenLinear(mem, pScrn, size))
        return Success;
    ErrorF("Linear memory allocation failed\n");
    return BadAlloc;
}

void
VIAInitLinear(ScreenPtr pScreen)
{
    ScrnInfoPtr pScrn = xf86ScreenToScrn(pScreen);
    VIAPtr pVia = VIAPTR(pScrn);

    if (pVia->useEXA && !pVia->NoAccel)
        return;
    else
    {
        unsigned long offset = (pVia->FBFreeStart + pVia->Bpp - 1) / pVia->Bpp;
        long size = pVia->FBFreeEnd / pVia->Bpp - offset;

        if (size > 0)
            xf86InitFBManagerLinear(pScreen, offset, size);
    }
}
@


1.5
log
@Cherry-pick upstreams commit to convert the openchrome driver to
compat-api.h for compatibility with xserver 1.13.
Unfortunaltly recent versions of the driver are broken in the !dri
!kms case, so it cannot be upgraded.OA
@
text
@d77 1
d79 1
d84 1
d88 1
a99 1

d119 1
a119 1

d128 1
@


1.4
log
@update to openchrome.net svn commit 750.
This adds among others support for the VX800 chipset.
This has been in snapshots for weeks.
@
text
@d169 1
a169 1
    ScrnInfoPtr pScrn = xf86Screens[pScreen->myNum];
@


1.3
log
@openchrome doesn't build if you have an xserver with DRI compiled in,
but you disable dri on in the driver build and don't have the via_drm.h
it wants in dri mode. Work around this by changing the #define used to
an openchrome only one, instead of overloading the XF86DRI identifier.

Also disable the DRI build unconditionally.

This is needed here since we don't provide the via DRM module, and i'm
moving libdrm over to using the kernel headers (instead of libdrms own
private copy of same... This is why kernel modules should be developed
in kernel). We won't provide a via drm driver until it is re-written,
since it is full of linuxisms (like futex).

ok matthieu@@, discussed with a few. tested by grange@@ to prove it was a
no-op functionality wise.
@
text
@d34 1
a34 1
#ifdef CHROMEDRI
d41 1
a41 1
#ifdef CHROMEDRI
a54 1
#ifdef VIA_HAVE_EXA
a62 1
#endif
a71 1
#ifdef VIA_HAVE_EXA
a81 1
#endif
d87 1
a87 1
#ifdef CHROMEDRI
a101 1
#ifdef VIA_HAVE_EXA
a115 1
#endif
d131 1
a131 1
#ifdef CHROMEDRI
a171 1
#ifdef VIA_HAVE_EXA
a174 1
#endif
@


1.2
log
@xf86-video-openchrome 0.2.903
@
text
@d34 1
a34 1
#ifdef XF86DRI
d41 1
a41 1
#ifdef XF86DRI
d91 1
a91 1
#ifdef XF86DRI
d137 1
a137 1
#ifdef XF86DRI
@


1.1
log
@Initial revision
@
text
@d55 1
d64 1
@


1.1.1.1
log
@Import the openchrome video driver, version 0.2.902. Discussed with
bernd@@ and oga@@. Tested by many in snaphots.
@
text
@@
