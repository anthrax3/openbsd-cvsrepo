head	1.5;
access;
symbols
	OPENBSD_6_2:1.5.0.20
	OPENBSD_6_2_BASE:1.5
	OPENBSD_6_1:1.5.0.18
	OPENBSD_6_1_BASE:1.5
	OPENBSD_6_0:1.5.0.16
	OPENBSD_6_0_BASE:1.5
	OPENBSD_5_9:1.5.0.14
	OPENBSD_5_9_BASE:1.5
	OPENBSD_5_8:1.5.0.12
	OPENBSD_5_8_BASE:1.5
	OPENBSD_5_7:1.5.0.10
	OPENBSD_5_7_BASE:1.5
	OPENBSD_5_6:1.5.0.8
	OPENBSD_5_6_BASE:1.5
	OPENBSD_5_5:1.5.0.6
	OPENBSD_5_5_BASE:1.5
	OPENBSD_5_4:1.5.0.4
	OPENBSD_5_4_BASE:1.5
	OPENBSD_5_3:1.5.0.2
	OPENBSD_5_3_BASE:1.5
	OPENBSD_5_2:1.4.0.2
	OPENBSD_5_2_BASE:1.4
	OPENBSD_5_1_BASE:1.3
	OPENBSD_5_1:1.3.0.10
	OPENBSD_5_0:1.3.0.8
	OPENBSD_5_0_BASE:1.3
	OPENBSD_4_9:1.3.0.4
	OPENBSD_4_9_BASE:1.3
	OPENBSD_4_8:1.3.0.6
	OPENBSD_4_8_BASE:1.3
	OPENBSD_4_7:1.3.0.2
	OPENBSD_4_7_BASE:1.3
	OPENBSD_4_6:1.2.0.2
	OPENBSD_4_6_BASE:1.2
	OPENBSD_4_5:1.1.1.1.0.4
	OPENBSD_4_5_BASE:1.1.1.1
	OPENBSD_4_4:1.1.1.1.0.2
	OPENBSD_4_4_BASE:1.1.1.1
	v0_2_902:1.1.1.1
	openchrome:1.1.1;
locks; strict;
comment	@ * @;


1.5
date	2012.09.11.20.25.34;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2012.05.15.21.32.57;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2009.11.24.16.54.55;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2009.06.25.21.27.18;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2008.07.12.12.48.37;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2008.07.12.12.48.37;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.5
log
@Cherry-pick upstreams commit to convert the openchrome driver to
compat-api.h for compatibility with xserver 1.13.
Unfortunaltly recent versions of the driver are broken in the !dri
!kms case, so it cannot be upgraded.OA
@
text
@/*
 * Copyright 2007 The Openchrome Project [openchrome.org]
 * Copyright 1998-2007 VIA Technologies, Inc. All Rights Reserved.
 * Copyright 2001-2003 S3 Graphics, Inc. All Rights Reserved.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sub license,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice (including the
 * next paragraph) shall be included in all copies or substantial portions
 * of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT. IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 */

/*************************************************************************
 *
 *  File:       via_cursor.c
 *  Content:    Hardware cursor support for VIA/S3G UniChrome
 *
 ************************************************************************/

#ifdef HAVE_CONFIG_H
#include "config.h"
#endif

#include "via.h"
#include "via_driver.h"
#include "via_id.h"
#include "cursorstr.h"

void viaShowCursor(ScrnInfoPtr pScrn);
void viaHideCursor(ScrnInfoPtr pScrn);
static void viaSetCursorPosition(ScrnInfoPtr pScrn, int x, int y);
static Bool viaUseHWCursor(ScreenPtr pScreen, CursorPtr pCurs);
static Bool viaUseHWCursorARGB(ScreenPtr pScreen, CursorPtr pCurs);
static void viaLoadCursorImage(ScrnInfoPtr pScrn, unsigned char *src);
static void viaSetCursorColors(ScrnInfoPtr pScrn, int bg, int fg);
static void viaLoadCursorARGB(ScrnInfoPtr pScrn, CursorPtr pCurs);

static CARD32 mono_cursor_color[] = {
	0x00000000,
	0x00000000,
	0xffffffff,
	0xff000000,
};

Bool
viaHWCursorInit(ScreenPtr pScreen)
{
    ScrnInfoPtr pScrn = xf86ScreenToScrn(pScreen);
    VIAPtr pVia = VIAPTR(pScrn);
    xf86CursorInfoPtr infoPtr;

	switch (pVia->Chipset) {
		case VIA_CLE266:
		case VIA_KM400:
			/* FIXME Mono HW Cursors not working */
			pVia->hwcursor = FALSE;
			pVia->CursorARGBSupported = FALSE;
			pVia->CursorMaxWidth = 32;
			pVia->CursorMaxHeight = 32;
			pVia->CursorSize = ((pVia->CursorMaxWidth * pVia->CursorMaxHeight) / 8) * 2;
			break;
		default:
			pVia->CursorARGBSupported = TRUE;
			pVia->CursorMaxWidth = 64;
			pVia->CursorMaxHeight = 64;
			pVia->CursorSize = pVia->CursorMaxWidth * (pVia->CursorMaxHeight + 1) << 2;
			break;
    }

    if (pVia->NoAccel) 
    	viaCursorSetFB(pScrn);

    pVia->cursorMap = pVia->FBBase + pVia->CursorStart;

    if (pVia->cursorMap == NULL)
		return FALSE;

    pVia->cursorOffset = pScrn->fbOffset + pVia->CursorStart;
    memset(pVia->cursorMap, 0x00, pVia->CursorSize);

    switch (pVia->Chipset) {
        case VIA_CX700:
        /* case VIA_CN750: */
        case VIA_P4M890:
        case VIA_P4M900:
        case VIA_VX800:
        case VIA_VX855:
        case VIA_VX900:
			if (pVia->pBIOSInfo->FirstCRTC->IsActive) {
				pVia->CursorRegControl  = VIA_REG_HI_CONTROL0;
				pVia->CursorRegBase     = VIA_REG_HI_BASE0;
				pVia->CursorRegPos      = VIA_REG_HI_POS0;
				pVia->CursorRegOffset   = VIA_REG_HI_OFFSET0;
				pVia->CursorRegFifo     = VIA_REG_HI_FIFO0;
				pVia->CursorRegTransKey = VIA_REG_HI_TRANSKEY0;
			}
			if (pVia->pBIOSInfo->SecondCRTC->IsActive) {
				pVia->CursorRegControl  = VIA_REG_HI_CONTROL1;
				pVia->CursorRegBase     = VIA_REG_HI_BASE1;
				pVia->CursorRegPos      = VIA_REG_HI_POS1;
				pVia->CursorRegOffset   = VIA_REG_HI_OFFSET1;
				pVia->CursorRegFifo     = VIA_REG_HI_FIFO1;
				pVia->CursorRegTransKey = VIA_REG_HI_TRANSKEY1;
			}
			break;
		default:
			pVia->CursorRegControl = VIA_REG_ALPHA_CONTROL;
			pVia->CursorRegBase = VIA_REG_ALPHA_BASE;
			pVia->CursorRegPos = VIA_REG_ALPHA_POS;
			pVia->CursorRegOffset = VIA_REG_ALPHA_OFFSET;
			pVia->CursorRegFifo = VIA_REG_ALPHA_FIFO;
			pVia->CursorRegTransKey = VIA_REG_ALPHA_TRANSKEY;
    }

    DEBUG(xf86DrvMsg(pScrn->scrnIndex, X_INFO, "VIAHWCursorInit\n"));
    infoPtr = xf86CreateCursorInfoRec();
    if (!infoPtr)
        return FALSE;

    pVia->CursorInfoRec = infoPtr;

    infoPtr->MaxWidth = pVia->CursorMaxWidth;
    infoPtr->MaxHeight = pVia->CursorMaxHeight;
    infoPtr->Flags = (HARDWARE_CURSOR_SOURCE_MASK_INTERLEAVE_1 |
                      HARDWARE_CURSOR_AND_SOURCE_WITH_MASK |
                      HARDWARE_CURSOR_TRUECOLOR_AT_8BPP |
                      0);

    infoPtr->SetCursorColors = viaSetCursorColors;
    infoPtr->SetCursorPosition = viaSetCursorPosition;
    infoPtr->LoadCursorImage = viaLoadCursorImage;
    infoPtr->HideCursor = viaHideCursor;
    infoPtr->ShowCursor = viaShowCursor;
    infoPtr->UseHWCursor = viaUseHWCursor;

    /* ARGB Cursor init */
    infoPtr->UseHWCursorARGB = viaUseHWCursorARGB;
    if (pVia->CursorARGBSupported) {
        DEBUG(xf86DrvMsg(pScrn->scrnIndex, X_INFO, "HWCursor ARGB enabled\n"));
    	infoPtr->LoadCursorARGB = viaLoadCursorARGB;
    }

    /* Set cursor location in frame buffer. */
    VIASETREG(VIA_REG_CURSOR_MODE, pVia->cursorOffset);

    pVia->CursorPipe = (pVia->pBIOSInfo->Panel->IsActive) ? 1 : 0;

    /* Init HI_X0 */
    VIASETREG(pVia->CursorRegControl, 0);
    VIASETREG(pVia->CursorRegBase, pVia->cursorOffset);
    VIASETREG(pVia->CursorRegTransKey, 0);

    switch (pVia->Chipset) {
        case VIA_CX700:
        /* case VIA_CN750: */
        case VIA_P4M890:
        case VIA_P4M900:
        case VIA_VX800:
        case VIA_VX855:
        case VIA_VX900:
			if (pVia->pBIOSInfo->FirstCRTC->IsActive) {
				VIASETREG(VIA_REG_PRIM_HI_INVTCOLOR, 0x00FFFFFF);
				VIASETREG(VIA_REG_V327_HI_INVTCOLOR, 0x00FFFFFF);
				VIASETREG(pVia->CursorRegFifo, 0x0D000D0F);
			}
			if (pVia->pBIOSInfo->SecondCRTC->IsActive) {
				VIASETREG(VIA_REG_HI_INVTCOLOR, 0X00FFFFFF);
				VIASETREG(VIA_REG_ALPHA_PREFIFO, 0xE0000);
				VIASETREG(pVia->CursorRegFifo, 0xE0F0000);

				/* Just in case */
				VIASETREG(VIA_REG_HI_BASE0, pVia->cursorOffset);
			}
			break;
    	default:
			VIASETREG(VIA_REG_HI_INVTCOLOR, 0X00FFFFFF);
			VIASETREG(VIA_REG_ALPHA_PREFIFO, 0xE0000);
			VIASETREG(pVia->CursorRegFifo, 0xE0F0000);
	}

    return xf86InitCursor(pScreen, infoPtr);
}

void
viaCursorSetFB(ScrnInfoPtr pScrn)
{
    VIAPtr pVia = VIAPTR(pScrn);

    if ((pVia->FBFreeEnd - pVia->FBFreeStart) > pVia->CursorSize) {
        pVia->CursorStart = pVia->FBFreeEnd - pVia->CursorSize;
        pVia->FBFreeEnd = pVia->CursorStart;
        xf86DrvMsg(pScrn->scrnIndex, X_INFO, "CursorStart: 0x%x\n", pVia->CursorStart);
    }
}


void
viaCursorStore(ScrnInfoPtr pScrn)
{
    VIAPtr pVia = VIAPTR(pScrn);

    DEBUG(xf86DrvMsg(pScrn->scrnIndex, X_INFO, "ViaCursorStore\n"));

    if (pVia->CursorPipe) {
		pVia->CursorControl1 = VIAGETREG(pVia->CursorRegControl);
    } else {
		pVia->CursorControl0 = VIAGETREG(pVia->CursorRegControl);
    }

    pVia->CursorTransparentKey = VIAGETREG(pVia->CursorRegTransKey);


    switch (pVia->Chipset) {
        case VIA_CX700:
        /* case VIA_CN750: */
        case VIA_P4M890:
        case VIA_P4M900:
        case VIA_VX800:
        case VIA_VX855:
        case VIA_VX900:
		if (pVia->pBIOSInfo->FirstCRTC->IsActive) {
	    		pVia->CursorPrimHiInvtColor = VIAGETREG(VIA_REG_PRIM_HI_INVTCOLOR);
	    		pVia->CursorV327HiInvtColor = VIAGETREG(VIA_REG_V327_HI_INVTCOLOR);
		} 
		if (pVia->pBIOSInfo->SecondCRTC->IsActive) {
	    	/* TODO add saves here */
		}
		pVia->CursorFifo = VIAGETREG(pVia->CursorRegFifo);
		break;
	default:
		/* TODO add saves here */
		break;
    }
}

void
viaCursorRestore(ScrnInfoPtr pScrn)
{
    VIAPtr pVia = VIAPTR(pScrn);

    DEBUG(xf86DrvMsg(pScrn->scrnIndex, X_INFO, "ViaCursorRestore\n"));

    if (pVia->CursorPipe) {
		VIASETREG(pVia->CursorRegControl, pVia->CursorControl1);
    } else {
		VIASETREG(pVia->CursorRegControl, pVia->CursorControl0);
    }

    VIASETREG(pVia->CursorRegBase, pVia->cursorOffset);

    VIASETREG(pVia->CursorRegTransKey, pVia->CursorTransparentKey);


    switch (pVia->Chipset) {
        case VIA_CX700:
        /* case VIA_CN750: */
        case VIA_P4M890:
        case VIA_P4M900:
        case VIA_VX800:
        case VIA_VX855:
        case VIA_VX900:
		if (pVia->pBIOSInfo->FirstCRTC->IsActive) {
	    		VIASETREG(VIA_REG_PRIM_HI_INVTCOLOR, pVia->CursorPrimHiInvtColor);
	    		VIASETREG(VIA_REG_V327_HI_INVTCOLOR, pVia->CursorV327HiInvtColor);
		}
		if (pVia->pBIOSInfo->SecondCRTC->IsActive) {
	   		/* TODO add real restores here */
	    		VIASETREG(VIA_REG_HI_INVTCOLOR, 0X00FFFFFF);
	    		VIASETREG(VIA_REG_ALPHA_PREFIFO, 0xE0000);
		}
		VIASETREG(pVia->CursorRegFifo, pVia->CursorFifo);
		break;
	default:
		/* TODO add real restores here */
		VIASETREG(VIA_REG_ALPHA_PREFIFO, 0xE0000);
		VIASETREG(pVia->CursorRegFifo, 0xE0F0000);
    }
}

/*
 * display the current cursor
 */

void
viaShowCursor(ScrnInfoPtr pScrn)
{
    VIAPtr pVia = VIAPTR(pScrn);

    switch(pVia->Chipset) {
        case VIA_CX700:
        case VIA_P4M890:
        case VIA_P4M900:
        case VIA_VX800:
        case VIA_VX855:
        case VIA_VX900:
             if (pVia->pBIOSInfo->FirstCRTC->IsActive) {
                 VIASETREG(VIA_REG_HI_CONTROL0, 0x36000005);
             }
  	     if (pVia->pBIOSInfo->SecondCRTC->IsActive) {
                 VIASETREG(VIA_REG_HI_CONTROL1, 0xb6000005);
             } 
             break;
        
        default:
	    /*temp = 0x76000005;
	      temp =
                (1 << 30) |
		(1 << 29) |
		(1 << 28) |
		(1 << 26) |
		(1 << 25) |
		(1 <<  2) |
		(1 <<  0);
            */

            /* Duoview */
	    if (pVia->CursorPipe) {
                /* Mono Cursor Display Path [bit31]: Secondary */
                /* FIXME For CLE266 and KM400 try to enable 32x32 cursor size [bit1] */
                VIASETREG(VIA_REG_ALPHA_CONTROL, 0xF6000005);
            } else {
                /* Mono Cursor Display Path [bit31]: Primary */
                VIASETREG(VIA_REG_ALPHA_CONTROL, 0x76000005);
            }
    }
}


/* hide the current cursor */
void
viaHideCursor(ScrnInfoPtr pScrn)
{
    VIAPtr pVia = VIAPTR(pScrn);
    CARD32 temp;

    switch(pVia->Chipset) {
        case VIA_CX700:
        case VIA_P4M890:
        case VIA_P4M900:
        case VIA_VX800:
        case VIA_VX855:
        case VIA_VX900:
             if (pVia->pBIOSInfo->FirstCRTC->IsActive) {
                 temp = VIAGETREG(VIA_REG_HI_CONTROL0);
                 VIASETREG(VIA_REG_HI_CONTROL0, temp & 0xFFFFFFFA);
             }
  	     if (pVia->pBIOSInfo->SecondCRTC->IsActive) {
                 temp = VIAGETREG(VIA_REG_HI_CONTROL1);
                 VIASETREG(VIA_REG_HI_CONTROL1, temp & 0xFFFFFFFA);
             } 
             break;
        
        default:
             temp = VIAGETREG(VIA_REG_ALPHA_CONTROL);
             /* Hardware cursor disable [bit0] */
             VIASETREG(VIA_REG_ALPHA_CONTROL, temp & 0xFFFFFFFA);
    }
}

/*
    Set the cursor position to (x,y).  X and/or y may be negative
    indicating that the cursor image is partially offscreen on
    the left and/or top edges of the screen.
*/
static void
viaSetCursorPosition(ScrnInfoPtr pScrn, int x, int y)
{
    VIAPtr pVia = VIAPTR(pScrn);
    unsigned xoff, yoff;

    if (x < 0) {
	xoff = ((-x) & 0xFE);
	x = 0;
    } else {
	xoff = 0;
    }

    if (y < 0) {
	yoff = ((-y) & 0xFE);
	y = 0;
    } else {
	yoff = 0;
    }

    switch(pVia->Chipset) {
        case VIA_CX700:
        case VIA_P4M890:
        case VIA_P4M900:
        case VIA_VX800:
        case VIA_VX855:
        case VIA_VX900:
             if (pVia->pBIOSInfo->FirstCRTC->IsActive) {                
                 VIASETREG(VIA_REG_HI_POS0,    ((x    << 16) | (y    & 0x07ff)));
                 VIASETREG(VIA_REG_HI_OFFSET0, ((xoff << 16) | (yoff & 0x07ff)));
             }
  	     if (pVia->pBIOSInfo->SecondCRTC->IsActive) {
                 VIASETREG(VIA_REG_HI_POS1,    ((x    << 16) | (y    & 0x07ff)));
                 VIASETREG(VIA_REG_HI_OFFSET1, ((xoff << 16) | (yoff & 0x07ff)));
             } 
             break;
        
        default:
            VIASETREG(VIA_REG_ALPHA_POS,    ((x    << 16) | (y    & 0x07ff)));
            VIASETREG(VIA_REG_ALPHA_OFFSET, ((xoff << 16) | (yoff & 0x07ff)));
    }

}

static Bool
viaUseHWCursorARGB(ScreenPtr pScreen, CursorPtr pCurs)
{
    ScrnInfoPtr pScrn = xf86ScreenToScrn(pScreen);
    VIAPtr pVia = VIAPTR(pScrn);

    return (pVia->hwcursor
            && pVia->CursorARGBSupported
            && pCurs->bits->width <= pVia->CursorMaxWidth
            && pCurs->bits->height <= pVia->CursorMaxHeight);
}

/*
    If the driver is unable to use a hardware cursor for reasons
    other than the cursor being larger than the maximum specified
    in the MaxWidth or MaxHeight field below, it can supply the
    UseHWCursor function.  If UseHWCursor is provided by the driver,
    it will be called whenever the cursor shape changes or the video
    mode changes.  This is useful for when the hardware cursor cannot
    be used in interlaced or doublescan modes.
*/
static Bool
viaUseHWCursor(ScreenPtr pScreen, CursorPtr pCurs)
{
    ScrnInfoPtr pScrn = xf86ScreenToScrn(pScreen);
    VIAPtr pVia = VIAPTR(pScrn);

    return (pVia->hwcursor
            /* Can't enable HW cursor on both CRTCs at the same time. */
            && !(pVia->pBIOSInfo->FirstCRTC->IsActive
                 && pVia->pBIOSInfo->SecondCRTC->IsActive)
            && pCurs->bits->width <= pVia->CursorMaxWidth
            && pCurs->bits->height <= pVia->CursorMaxHeight);
}

/*
    Load Mono Cursor Image 
*/
static void
viaLoadCursorImage(ScrnInfoPtr pScrn, unsigned char *src)
{
    VIAPtr pVia = VIAPTR(pScrn);
    CARD32 temp;
    CARD32 *dst;
    CARD8 chunk;
    int i, j;

    pVia->CursorARGB = FALSE;

    dst = (CARD32*)(pVia->cursorMap);

    if (pVia->CursorARGBSupported) {
#define ARGB_PER_CHUNK	(8 * sizeof (chunk) / 2)
		for (i = 0; i < (pVia->CursorMaxWidth * pVia->CursorMaxHeight / ARGB_PER_CHUNK); i++) {
		    chunk = *src++;
		    for (j = 0; j < ARGB_PER_CHUNK; j++, chunk >>= 2)
			*dst++ = mono_cursor_color[chunk & 3];
		}

		pVia->CursorFG = mono_cursor_color[3];
		pVia->CursorBG = mono_cursor_color[2];
    } else {
	memcpy(dst, (CARD8*)src, pVia->CursorSize);
    }
    switch(pVia->Chipset) {
        case VIA_CX700:
        case VIA_P4M890:
        case VIA_P4M900:
        case VIA_VX800:
        case VIA_VX855:
        case VIA_VX900:
             if (pVia->pBIOSInfo->FirstCRTC->IsActive) {
                 temp = VIAGETREG(VIA_REG_HI_CONTROL0);
                 VIASETREG(VIA_REG_HI_CONTROL0, temp & 0xFFFFFFFE);
             }
  	     if (pVia->pBIOSInfo->SecondCRTC->IsActive) {
                 temp = VIAGETREG(VIA_REG_HI_CONTROL1);
                 VIASETREG(VIA_REG_HI_CONTROL1, temp & 0xFFFFFFFE);
             }
             break;
        
        default:
             temp = VIAGETREG(VIA_REG_ALPHA_CONTROL);
             VIASETREG(VIA_REG_ALPHA_CONTROL, temp);
    }
}

/*
    Set the cursor foreground and background colors.  In 8bpp, fg and
    bg are indices into the current colormap unless the 
    HARDWARE_CURSOR_TRUECOLOR_AT_8BPP flag is set.  In that case
    and in all other bpps the fg and bg are in 8-8-8 RGB format.
*/

static void
viaSetCursorColors(ScrnInfoPtr pScrn, int bg, int fg)
{
    VIAPtr pVia = VIAPTR(pScrn);
    CARD32 pixel;
    CARD32 temp;
    CARD32 *dst;
    int i;

    if (pVia->CursorFG)
	return;

    fg |= 0xff000000;
    bg |= 0xff000000;

    /* Don't recolour the image if we don't have to. */
    if (fg == pVia->CursorFG && bg == pVia->CursorBG)
	return;

    dst = (CARD32*)pVia->cursorMap;
    for (i = 0; i < pVia->CursorMaxWidth * pVia->CursorMaxHeight; i++, dst++)
	if ((pixel = *dst))
	    *dst = (pixel == pVia->CursorFG) ? fg : bg;

    pVia->CursorFG = fg;
    pVia->CursorBG = bg;

    switch(pVia->Chipset) {
        case VIA_CX700:
        case VIA_P4M890:
        case VIA_P4M900:
        case VIA_VX800:
        case VIA_VX855:
        case VIA_VX900:
             if (pVia->pBIOSInfo->FirstCRTC->IsActive) {
                 temp = VIAGETREG(VIA_REG_HI_CONTROL0);
                 VIASETREG(VIA_REG_HI_CONTROL0, temp & 0xFFFFFFFE);
             }
  	     if (pVia->pBIOSInfo->SecondCRTC->IsActive) {
                 temp = VIAGETREG(VIA_REG_HI_CONTROL1);
                 VIASETREG(VIA_REG_HI_CONTROL1, temp & 0xFFFFFFFE);
             }
             break;        
        default:
             temp = VIAGETREG(VIA_REG_ALPHA_CONTROL);
             VIASETREG(VIA_REG_ALPHA_CONTROL, temp & 0xFFFFFFFE);
    }
}

static void
viaLoadCursorARGB(ScrnInfoPtr pScrn, CursorPtr pCurs)
{
    VIAPtr pVia = VIAPTR(pScrn);
    int x, y, w, h;
    CARD32 *image = (CARD32*)pCurs->bits->argb;
    CARD32 *dst = (CARD32*)pVia->cursorMap;

    pVia->CursorARGB = TRUE;

    w = pCurs->bits->width;
    h = pCurs->bits->height;

    for (y = 0; y < h; y++) {

	for (x = 0; x < w; x++)
	    *dst++ = *image++;
        /* pad to the right with transparent */
	for (; x < pVia->CursorMaxHeight; x++)
	    *dst++ = 0;
    }

    /* pad below with transparent */
    for (; y < pVia->CursorMaxHeight; y++)
	for (x = 0; x < pVia->CursorMaxWidth; x++)
	    *dst++ = 0;

}
@


1.4
log
@Update xf86-video-openchrome to 0.2.905
@
text
@d61 1
a61 1
    ScrnInfoPtr pScrn = xf86Screens[pScreen->myNum];
d425 1
a425 1
    ScrnInfoPtr pScrn = xf86Screens[pScreen->myNum];
d446 1
a446 1
    ScrnInfoPtr pScrn = xf86Screens[pScreen->myNum];
@


1.3
log
@Update to xf86-video-openchrome 0.2.904.
Tested by myself and kevlo@@ on V800 and V855 chipsets.
@
text
@d101 1
d149 1
d151 2
a152 1
	if (pVia->CursorARGBSupported)
d154 1
d173 1
d233 1
d274 1
d294 1
a294 1
 * ARGB Cursor
d308 1
d330 3
a332 1
	    if (pVia->CursorPipe)
d334 2
a335 1
            else
d337 1
d341 2
d355 1
d368 1
d373 5
d404 1
d434 9
d457 3
d461 1
a461 1
viaLoadCursorImage(ScrnInfoPtr pScrn, unsigned char *s)
d476 1
a476 1
		    chunk = *s++;
d484 1
a484 1
	memcpy(dst, (CARD8*)s, pVia->CursorSize);
d492 1
d509 7
a519 1
    CARD32 control = pVia->CursorRegControl;
d531 1
a534 3
    temp = VIAGETREG(control);
    VIASETREG(control, temp & 0xFFFFFFFE);

d549 1
d560 2
a561 1
             VIASETREG(control, temp);
@


1.2
log
@update to openchrome.net svn commit 750.
This adds among others support for the VX800 chipset.
This has been in snapshots for weeks.
@
text
@d79 1
a79 1
			pVia->CursorSize = pVia->CursorMaxWidth * (pVia->CursorMaxHeight + 1) * 4;
d100 1
d168 1
d227 2
a228 1
			if (pVia->pBIOSInfo->FirstCRTC->IsActive) {
d231 2
a232 2
			} 
			if (pVia->pBIOSInfo->SecondCRTC->IsActive) {
d234 6
a239 6
			}
			pVia->CursorFifo = VIAGETREG(pVia->CursorRegFifo);
			break;
		default:
			/* TODO add saves here */
			break;
d267 2
a268 1
			if (pVia->pBIOSInfo->FirstCRTC->IsActive) {
d271 3
a273 3
			}
			if (pVia->pBIOSInfo->SecondCRTC->IsActive) {
	    		/* TODO add real restores here */
d276 7
a282 7
			}
			VIASETREG(pVia->CursorRegFifo, pVia->CursorFifo);
			break;
		default:
			/* TODO add real restores here */
			VIASETREG(VIA_REG_ALPHA_PREFIFO, 0xE0000);
			VIASETREG(pVia->CursorRegFifo, 0xE0F0000);
a293 2
    CARD32 temp;
    CARD32 control = pVia->CursorRegControl;
d295 32
a326 13
    temp =
	(1 << 30) |
	(1 << 29) |
	(1 << 28) |
	(1 << 26) |
	(1 << 25) |
	(1 <<  2) |
	(1 <<  0);

    if (pVia->CursorPipe)
	temp |= (1 << 31);

    VIASETREG(control, temp);
a333 1
    CARD32 control = pVia->CursorRegControl;
d335 20
a354 2
    temp = VIAGETREG(control);
    VIASETREG(control, temp & 0xFFFFFFFE);
a360 4
    CARD32 temp;
    CARD32 control = pVia->CursorRegControl;
    CARD32 offset = pVia->CursorRegOffset;
    CARD32 pos = pVia->CursorRegPos;
d377 20
a396 2
    temp = VIAGETREG(control);
    VIASETREG(control, temp & 0xFFFFFFFE);
a397 4
    VIASETREG(pos,    ((x    << 16) | (y    & 0x07ff)));
    VIASETREG(offset, ((xoff << 16) | (yoff & 0x07ff)));

    VIASETREG(control, temp);
a429 1
    CARD32 control = pVia->CursorRegControl;
a431 1
    CARD8 *src;
a434 3
    temp = VIAGETREG(control);
    VIASETREG(control, temp & 0xFFFFFFFE);

a437 1
    src = (CARD8*)s;
d442 2
a443 2
		chunk = *s++;
		for (j = 0; j < ARGB_PER_CHUNK; j++, chunk >>= 2)
d449 23
a471 5
	} else {
		memcpy(dst, src, pVia->CursorSize);
	}

    VIASETREG(control, temp);
d504 18
a521 1
    VIASETREG(control, temp);
a527 1
    CARD32 control = pVia->CursorRegControl;
d529 2
a530 7
    CARD32 *image;
    CARD32 *dst;
    CARD32 *src;
    CARD32 temp;

    temp = VIAGETREG(control);
    VIASETREG(control, temp & 0xFFFFFFFE);
a533 3
    dst = (CARD32*)pVia->cursorMap;
    image = pCurs->bits->argb;

a534 3
    if (w > pVia->CursorMaxWidth)
	w = pVia->CursorMaxWidth;

a535 2
    if (h > pVia->CursorMaxHeight)
	h = pVia->CursorMaxHeight;
a538 3
	src = image;
	image += pCurs->bits->width;

d540 2
a541 1
	    *dst++ = *src++;
d546 1
a550 1
    VIASETREG(control, temp);
@


1.1
log
@Initial revision
@
text
@d2 2
a3 1
 * Copyright 1998-2003 VIA Technologies, Inc. All Rights Reserved.
d39 2
d42 15
a56 5
static void VIALoadCursorImage(ScrnInfoPtr pScrn, unsigned char *src);
static void VIASetCursorPosition(ScrnInfoPtr pScrn, int x, int y);
static void VIASetCursorColors(ScrnInfoPtr pScrn, int bg, int fg);

#define MAX_CURS 32
d59 1
a59 1
VIAHWCursorInit(ScreenPtr pScreen)
d65 61
d133 3
a135 3
    infoPtr->MaxWidth = MAX_CURS;
    infoPtr->MaxHeight = MAX_CURS;
    infoPtr->Flags = (HARDWARE_CURSOR_SOURCE_MASK_INTERLEAVE_32 |
a136 1
                      /*HARDWARE_CURSOR_SWAP_SOURCE_AND_MASK | */
a137 2
                      HARDWARE_CURSOR_INVERT_MASK |
                      HARDWARE_CURSOR_BIT_ORDER_MSBFIRST |
d140 10
a149 11
    infoPtr->SetCursorColors = VIASetCursorColors;
    infoPtr->SetCursorPosition = VIASetCursorPosition;
    infoPtr->LoadCursorImage = VIALoadCursorImage;
    infoPtr->HideCursor = VIAHideCursor;
    infoPtr->ShowCursor = VIAShowCursor;
    infoPtr->UseHWCursor = NULL;

    if (!pVia->CursorStart) {
        pVia->CursorStart = pVia->FBFreeEnd - VIA_CURSOR_SIZE;
        pVia->FBFreeEnd -= VIA_CURSOR_SIZE;
    }
d152 34
a185 1
    VIASETREG(VIA_REG_CURSOR_MODE, pVia->CursorStart);
d190 12
d204 1
a204 1
VIAShowCursor(ScrnInfoPtr pScrn)
a206 1
    CARD32 dwCursorMode;
d208 9
a216 1
    dwCursorMode = VIAGETREG(VIA_REG_CURSOR_MODE);
d218 20
a237 2
    /* Turn on hardware cursor. */
    VIASETREG(VIA_REG_CURSOR_MODE, dwCursorMode | 0x3);
a239 1

d241 1
a241 1
VIAHideCursor(ScrnInfoPtr pScrn)
a243 1
    CARD32 dwCursorMode;
d245 12
a256 1
    dwCursorMode = VIAGETREG(VIA_REG_CURSOR_MODE);
d258 22
a279 2
    /* Turn cursor off. */
    VIASETREG(VIA_REG_CURSOR_MODE, dwCursorMode & 0xFFFFFFFE);
d282 3
d286 2
a287 2
static void
VIALoadCursorImage(ScrnInfoPtr pScrn, unsigned char *src)
d290 2
a291 1
    CARD32 dwCursorMode;
d293 8
a300 1
    viaAccelSync(pScrn);
d302 2
a303 1
    dwCursorMode = VIAGETREG(VIA_REG_CURSOR_MODE);
d305 2
a306 2
    /* Turn cursor off. */
    VIASETREG(VIA_REG_CURSOR_MODE, dwCursorMode & 0xFFFFFFFE);
d308 6
a313 2
    /* Upload the cursor image to the frame buffer. */
    memcpy(pVia->FBBase + pVia->CursorStart, src, MAX_CURS * MAX_CURS / 8 * 2);
d315 2
a316 2
    /* Restore cursor status */
    VIASETREG(VIA_REG_CURSOR_MODE, dwCursorMode);
d320 1
a320 1
VIASetCursorPosition(ScrnInfoPtr pScrn, int x, int y)
d323 5
a327 3
    VIABIOSInfoPtr pBIOSInfo = pVia->pBIOSInfo;
    unsigned char xoff, yoff;
    CARD32 dwCursorMode;
d330 2
a331 2
        xoff = ((-x) & 0xFE);
        x = 0;
d333 1
a333 1
        xoff = 0;
d337 2
a338 2
        yoff = ((-y) & 0xFE);
        y = 0;
d340 5
a344 12
        yoff = 0;
        /* LCD Expand Mode Cursor Y Position Re-Calculated */
        if (pBIOSInfo->scaleY) {
            y = (int)(((pBIOSInfo->panelY * y) + (pBIOSInfo->resY >> 1))
                      / pBIOSInfo->resY);
        }
    }

    /* Hide cursor before set cursor position in order to avoid ghost cursor
     * image when directly set cursor position. It should be a HW bug but
     * we can use patch by SW. */
    dwCursorMode = VIAGETREG(VIA_REG_CURSOR_MODE);
d346 5
a350 2
    /* Turn cursor off. */
    VIASETREG(VIA_REG_CURSOR_MODE, dwCursorMode & 0xFFFFFFFE);
d352 5
a356 2
    VIASETREG(VIA_REG_CURSOR_ORG, ((xoff << 16) | (yoff & 0x003f)));
    VIASETREG(VIA_REG_CURSOR_POS, ((x << 16) | (y & 0x07ff)));
d358 4
a361 2
    /* Restore cursor status */
    VIASETREG(VIA_REG_CURSOR_MODE, dwCursorMode);
d364 13
d379 1
a379 1
VIASetCursorColors(ScrnInfoPtr pScrn, int bg, int fg)
d382 28
d411 1
a411 2
    VIASETREG(VIA_REG_CURSOR_FG, fg);
    VIASETREG(VIA_REG_CURSOR_BG, bg);
d414 2
a415 2
void
ViaCursorStore(ScrnInfoPtr pScrn)
d418 11
d430 10
a439 1
    DEBUG(xf86DrvMsg(pScrn->scrnIndex, X_INFO, "ViaCursorStore\n"));
d441 2
a442 5
    if (pVia->CursorImage) {
        xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
                   "ViaCursorStore: stale image left.\n");
        xfree(pVia->CursorImage);
    }
d444 1
a444 5
    pVia->CursorImage = xcalloc(1, 0x1000);
    memcpy(pVia->CursorImage, pVia->FBBase + pVia->CursorStart, 0x1000);
    pVia->CursorFG = (CARD32) VIAGETREG(VIA_REG_CURSOR_FG);
    pVia->CursorBG = (CARD32) VIAGETREG(VIA_REG_CURSOR_BG);
    pVia->CursorMC = (CARD32) VIAGETREG(VIA_REG_CURSOR_MODE);
d447 2
a448 2
void
ViaCursorRestore(ScrnInfoPtr pScrn)
d451 33
d485 3
a487 1
    DEBUG(xf86DrvMsg(pScrn->scrnIndex, X_INFO, "ViaCursorRestore\n"));
d489 1
a489 10
    if (pVia->CursorImage) {
        memcpy(pVia->FBBase + pVia->CursorStart, pVia->CursorImage, 0x1000);
        VIASETREG(VIA_REG_CURSOR_FG, pVia->CursorFG);
        VIASETREG(VIA_REG_CURSOR_BG, pVia->CursorBG);
        VIASETREG(VIA_REG_CURSOR_MODE, pVia->CursorMC);
        xfree(pVia->CursorImage);
        pVia->CursorImage = NULL;
    } else
        xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
                   "ViaCursorRestore: No cursor image stored.\n");
@


1.1.1.1
log
@Import the openchrome video driver, version 0.2.902. Discussed with
bernd@@ and oga@@. Tested by many in snaphots.
@
text
@@
