head	1.6;
access;
symbols
	OPENBSD_6_1_BASE:1.6
	OPENBSD_6_0:1.6.0.6
	OPENBSD_6_0_BASE:1.6
	OPENBSD_5_9:1.6.0.4
	OPENBSD_5_9_BASE:1.6
	OPENBSD_5_8:1.6.0.2
	OPENBSD_5_8_BASE:1.6
	OPENBSD_5_7:1.5.0.10
	OPENBSD_5_7_BASE:1.5
	OPENBSD_5_6:1.5.0.8
	OPENBSD_5_6_BASE:1.5
	OPENBSD_5_5:1.5.0.6
	OPENBSD_5_5_BASE:1.5
	OPENBSD_5_4:1.5.0.4
	OPENBSD_5_4_BASE:1.5
	OPENBSD_5_3:1.5.0.2
	OPENBSD_5_3_BASE:1.5
	OPENBSD_5_2:1.4.0.2
	OPENBSD_5_2_BASE:1.4
	OPENBSD_5_1_BASE:1.3
	OPENBSD_5_1:1.3.0.10
	OPENBSD_5_0:1.3.0.8
	OPENBSD_5_0_BASE:1.3
	OPENBSD_4_9:1.3.0.4
	OPENBSD_4_9_BASE:1.3
	OPENBSD_4_8:1.3.0.6
	OPENBSD_4_8_BASE:1.3
	OPENBSD_4_7:1.3.0.2
	OPENBSD_4_7_BASE:1.3
	OPENBSD_4_6:1.2.0.4
	OPENBSD_4_6_BASE:1.2
	OPENBSD_4_5:1.2.0.2
	OPENBSD_4_5_BASE:1.2
	OPENBSD_4_4:1.1.1.1.0.6
	OPENBSD_4_4_BASE:1.1.1.1
	OPENBSD_4_3_BASE:1.1.1.1
	OPENBSD_4_3:1.1.1.1.0.4
	OPENBSD_4_2:1.1.1.1.0.2
	OPENBSD_4_2_BASE:1.1.1.1
	v1_1_0:1.1.1.1
	xorg:1.1.1;
locks; strict;
comment	@ * @;


1.6
date	2015.05.23.15.02.40;	author matthieu;	state Exp;
branches;
next	1.5;
commitid	Ny6LuiDiL6vNudHo;

1.5
date	2012.08.16.16.13.04;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2012.05.06.15.41.35;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2009.11.22.16.01.56;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2008.09.16.22.02.31;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.26.20.02.17;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.11.26.20.02.17;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.6
log
@Merge cirrus driver version 1.5.3
@
text
@/*
 * Driver for CL-GD5480.
 * Itai Nahshon.
 *
 * Support for the CL-GD7548: David Monniaux
 *
 * This is mainly a cut & paste from the MGA driver.
 * Original autors and contributors list include:
 *	Radoslaw Kapitan, Andrew Vanderstock, Dirk Hohndel,
 *	David Dawes, Andrew E. Mileski, Leonard N. Zubkoff,
 *	Guy DESBIEF
 */

#ifdef HAVE_CONFIG_H
#include "config.h"
#endif

/* All drivers should typically include these */
#include "xf86.h"
#include "xf86_OSproc.h"

#if GET_ABI_MAJOR(ABI_VIDEODRV_VERSION) < 6
#include "xf86Resources.h"
#endif
/* All drivers need this */

/* Drivers that need to access the PCI config space directly need this */
#include "xf86Pci.h"

#include "cir.h"
#include "alp.h"
#include "lg.h"

#include "vbe.h"

/*
 * Forward definitions for the functions that make up the driver.
 */

/* Mandatory functions */

static const OptionInfoRec *	CIRAvailableOptions(int chipid, int busid);
static void	CIRIdentify(int flags);
static Bool	CIRProbe(DriverPtr drv, int flags);

static Bool lg_loaded = FALSE;
static Bool alp_loaded = FALSE;

#define CIR_VERSION 4000
#define CIR_NAME "CIRRUS"
#define CIR_DRIVER_NAME "cirrus"
#define CIR_MAJOR_VERSION PACKAGE_VERSION_MAJOR
#define CIR_MINOR_VERSION PACKAGE_VERSION_MINOR
#define CIR_PATCHLEVEL PACKAGE_VERSION_PATCHLEVEL

/*
 * This contains the functions needed by the server after loading the
 * driver module.  It must be supplied, and gets added to the driver list by
 * the Module Setup function in the dynamic case.  In the static case a
 * reference to this is compiled in, and this requires that the name of
 * this DriverRec be an upper-case version of the driver name.
 */

_X_EXPORT DriverRec CIRRUS = {
	CIR_VERSION,
	CIR_DRIVER_NAME,
	CIRIdentify,
	CIRProbe,
	CIRAvailableOptions,
	NULL,
	0
};

/* Supported chipsets */
SymTabRec CIRChipsets[] = {
	{ PCI_CHIP_GD5430,		"CLGD5430" },
	{ PCI_CHIP_GD5434_4,	"CLGD5434-4" },
	{ PCI_CHIP_GD5434_8,	"CLGD5434-8" },
	{ PCI_CHIP_GD5436,		"CLGD5436" },
/*  { PCI_CHIP_GD5440,		"CLGD5440" }, */
	{ PCI_CHIP_GD5446,		"CLGD5446" },
	{ PCI_CHIP_GD5480,		"CLGD5480" },
	{ PCI_CHIP_GD5462,		"CL-GD5462" },
	{ PCI_CHIP_GD5464,		"CL-GD5464" },
	{ PCI_CHIP_GD5464BD,	"CL-GD5464BD" },
	{ PCI_CHIP_GD5465,		"CL-GD5465" },
	{ PCI_CHIP_GD7548,              "CL-GD7548" },
	{ PCI_CHIP_GD7555,              "CL-GD7555" },
	{ PCI_CHIP_GD7556,              "CL-GD7556" },
	{-1,					NULL }
};

/* List of PCI chipset names */
_X_EXPORT PciChipsets CIRPciChipsets[] = {
	{ PCI_CHIP_GD5430,	PCI_CHIP_GD5430,	RES_SHARED_VGA },
	{ PCI_CHIP_GD5434_4,PCI_CHIP_GD5434_4,	RES_SHARED_VGA },
	{ PCI_CHIP_GD5434_8,PCI_CHIP_GD5434_8,	RES_SHARED_VGA },
	{ PCI_CHIP_GD5436,	PCI_CHIP_GD5436,	RES_SHARED_VGA },
/*  { PCI_CHIP_GD5440,	PCI_CHIP_GD5440,	RES_SHARED_VGA }, */
	{ PCI_CHIP_GD5446,	PCI_CHIP_GD5446,	RES_SHARED_VGA },
	{ PCI_CHIP_GD5480,	PCI_CHIP_GD5480,	RES_SHARED_VGA },
	{ PCI_CHIP_GD5462,	PCI_CHIP_GD5462,	RES_SHARED_VGA },
	{ PCI_CHIP_GD5464,	PCI_CHIP_GD5464,	RES_SHARED_VGA },
	{ PCI_CHIP_GD5464BD,PCI_CHIP_GD5464BD,	RES_SHARED_VGA },
	{ PCI_CHIP_GD5465,	PCI_CHIP_GD5465,	RES_SHARED_VGA },
	{ PCI_CHIP_GD7548,	PCI_CHIP_GD7548,	RES_SHARED_VGA },
	{ PCI_CHIP_GD7555,	PCI_CHIP_GD7555,	RES_SHARED_VGA },
	{ PCI_CHIP_GD7556,	PCI_CHIP_GD7556,	RES_SHARED_VGA },
	{ -1,				-1,					RES_UNDEFINED}
};

#ifdef XFree86LOADER

static MODULESETUPPROTO(cirSetup);

static XF86ModuleVersionInfo cirVersRec =
{
	"cirrus",
	MODULEVENDORSTRING,
	MODINFOSTRING1,
	MODINFOSTRING2,
	XORG_VERSION_CURRENT,
	CIR_MAJOR_VERSION, CIR_MINOR_VERSION, CIR_PATCHLEVEL,
	ABI_CLASS_VIDEODRV,			/* This is a video driver */
	ABI_VIDEODRV_VERSION,
	MOD_CLASS_VIDEODRV,
	{0,0,0,0}
};

/*
 * This is the module init data.
 * Its name has to be the driver name followed by ModuleData.
 */
_X_EXPORT XF86ModuleData cirrusModuleData = { &cirVersRec, cirSetup, NULL };

static pointer
cirSetup(pointer module, pointer opts, int *errmaj, int *errmin)
{
	static Bool setupDone = FALSE;

	/* This module should be loaded only once, but check to be sure. */

	if (!setupDone) {
		setupDone = TRUE;
		xf86AddDriver(&CIRRUS, module, 0);

		return (pointer)1;
	}
	if (errmaj) *errmaj = LDR_ONCEONLY;
	return NULL;
}

#endif /* XFree86LOADER */

/* Mandatory */
static void
CIRIdentify(int flags)
{
	xf86PrintChipsets(CIR_NAME, "driver for Cirrus chipsets", CIRChipsets);
}

static const OptionInfoRec *
CIRAvailableOptions(int chipid, int busid)
{
	int chip = chipid & 0xffff;

        switch (chip)
	{
	case PCI_CHIP_GD5462:
	case PCI_CHIP_GD5464:
	case PCI_CHIP_GD5464BD:
	case PCI_CHIP_GD5465:
		if (lg_loaded)
			return LgAvailableOptions(chipid);
		else
			return NULL;

	default:
		if (alp_loaded)
			return AlpAvailableOptions(chipid);
		else
			return NULL;
	}
}

static Bool
CIRProbe(DriverPtr drv, int flags)
{
    int i;
    GDevPtr *devSections;
    pciVideoPtr pPci;
    int *usedChips;
    int numDevSections;
    int numUsed;
    Bool foundScreen = FALSE;
    ScrnInfoPtr pScrn;

#ifdef CIR_DEBUG
    ErrorF("CirProbe\n");
#endif
  
    /*
     * For PROBE_DETECT, make sure both sub-modules are loaded before
     * calling xf86MatchPciInstances(), because the AvailableOptions()
     * functions may be called before xf86MatchPciInstances() returns.
     */
    
    if (flags & PROBE_DETECT) {
	if (!lg_loaded) {
	    if (xf86LoadDrvSubModule(drv, "cirrus_laguna")) {
		lg_loaded = TRUE;
	    }
	}
	if (!alp_loaded) {
	    if (xf86LoadDrvSubModule(drv, "cirrus_alpine")) {
		alp_loaded = TRUE;
	    }
	}
    }

    if ((numDevSections = xf86MatchDevice(CIR_DRIVER_NAME,
					  &devSections)) <= 0) {
	return FALSE;
    }

#ifndef XSERVER_LIBPCIACCESS    
    if (xf86GetPciVideoInfo() == NULL) {
	/*
	 * We won't let anything in the config file override finding no
	 * PCI video cards at all.  This seems reasonable now, but we'll see.
	 */
	return FALSE;
    }
#endif
  
    numUsed = xf86MatchPciInstances(CIR_NAME, PCI_VENDOR_CIRRUS,
				    CIRChipsets, CIRPciChipsets, devSections,
 				    numDevSections, drv, &usedChips);
    /* Free it since we don't need that list after this */
    if (numUsed <= 0) {
        free(devSections);
 	return FALSE;
    }
    if (flags & PROBE_DETECT)
 	foundScreen = TRUE;
    else for (i = 0; i < numUsed; i++) {
 	/* The Laguna family of chips is so different from the Alpine
 	   family that we won't share even the highest-level of
 	   functions.  But, the Laguna chips /are/ Cirrus chips, so
 	   they should be handled in this driver (as opposed to their
 	   own driver). */
	pPci = xf86GetPciInfoForEntity(usedChips[i]);

#ifdef XSERVER_LIBPCIACCESS
    if (pci_device_has_kernel_driver(pPci)) {
        xf86DrvMsg(0, X_ERROR,
                   "cirrus: The PCI device 0x%x at %2.2d@@%2.2d:%2.2d:%1.1d has a kernel module claiming it.\n",
                   pPci->device_id, pPci->bus, pPci->domain, pPci->dev, pPci->func);
        xf86DrvMsg(0, X_ERROR,
                   "cirrus: This driver cannot operate until it has been unloaded.\n");
#if GET_ABI_MAJOR(ABI_VIDEODRV_VERSION) < 13
	xf86UnclaimPciSlot(pPci);
#else
	xf86UnclaimPciSlot(pPci, devSections[0]);
#endif
        free(devSections);
        return FALSE;
    }
#endif
	pScrn = NULL;
 	if (pPci && (PCI_DEV_DEVICE_ID(pPci) == PCI_CHIP_GD5462 ||
		     PCI_DEV_DEVICE_ID(pPci) == PCI_CHIP_GD5464 ||
		     PCI_DEV_DEVICE_ID(pPci) == PCI_CHIP_GD5464BD ||
		     PCI_DEV_DEVICE_ID(pPci) == PCI_CHIP_GD5465)) {
 	    
 	    if (!lg_loaded) {
 		if (!xf86LoadDrvSubModule(drv, "cirrus_laguna")) 
		    continue;
 		lg_loaded = TRUE;
 	    }
	    pScrn = LgProbe(usedChips[i]);
 	} else {
 	    if (!alp_loaded) {
 		if (!xf86LoadDrvSubModule(drv, "cirrus_alpine")) 
 		    continue;
 		alp_loaded = TRUE;
 	    }
 	    pScrn = AlpProbe(usedChips[i]);
 	}
 	
 	if (pScrn) {
 	    foundScreen = TRUE;
 	    /* Fill in what we can of the ScrnInfoRec */
 	    pScrn->driverVersion = CIR_VERSION;
 	    pScrn->driverName	 = CIR_DRIVER_NAME;
 	    pScrn->name		 = CIR_NAME;
 	    pScrn->Probe	 = NULL;
 	}
    }
    free(devSections);
    free(usedChips);
     
    return foundScreen;
}

/*
 * Map the framebuffer and MMIO memory.
 */

_X_EXPORT Bool
CirMapMem(CirPtr pCir, int scrnIndex)
{
	int mmioFlags;

#ifdef CIR_DEBUG
	ErrorF("CirMapMem\n");
#endif

	/*
	 * Map the frame buffer.
	 */
	if (pCir->FbMapSize) {

#ifndef XSERVER_LIBPCIACCESS
	    
	    pCir->FbBase = xf86MapPciMem(scrnIndex, VIDMEM_FRAMEBUFFER,
					 pCir->PciTag, pCir->FbAddress,
					 pCir->FbMapSize);
	    if (pCir->FbBase == NULL)
		return FALSE;

#else
	    void** result = (void**)&pCir->FbBase;
	    int err = pci_device_map_range(pCir->PciInfo,
					   pCir->FbAddress,
					   pCir->FbMapSize,
					   PCI_DEV_MAP_FLAG_WRITABLE |
					   PCI_DEV_MAP_FLAG_WRITE_COMBINE,
					   result);

	    if (err) 
	      return FALSE;
#endif
	}
	
#ifdef CIR_DEBUG
	ErrorF("CirMapMem pCir->FbBase=0x%08x\n", pCir->FbBase);
#endif

	/*
	 * Map IO registers to virtual address space
	 */
	if (pCir->IOAddress == 0) {
		pCir->IOBase = NULL; /* Until we are ready to use MMIO */
	} else {

#ifndef XSERVER_LIBPCIACCESS
		mmioFlags = VIDMEM_MMIO;
		/*
		 * For Alpha, we need to map SPARSE memory, since we need
		 * byte/short access.  Common-level will automatically use
		 * sparse mapping for MMIO.
		 */

		pCir->IOBase =
		  xf86MapPciMem(scrnIndex, mmioFlags, pCir->PciTag,
		       	        pCir->IOAddress, pCir->IoMapSize);
		if (pCir->IOBase == NULL)
			return FALSE;

#else
		void** result = (void**)&pCir->IOBase;
		int err = pci_device_map_range(pCir->PciInfo,
					       pCir->IOAddress,
					       pCir->IoMapSize,
					       PCI_DEV_MAP_FLAG_WRITABLE,
					       result);
		
		if (err) 
			return FALSE;
		
#endif
	}

#ifdef CIR_DEBUG
	ErrorF("CirMapMem pCir->IOBase=0x%08x [length=%08x] from PCI=%08x\n",
	       pCir->IOBase, pCir->IoMapSize, pCir->IOAddress);
	ErrorF("MMIO[GR31] = %2X\n", (int)
	       ((volatile unsigned char*) pCir->IOBase)[0x40]);
#endif

	return TRUE;
}


/*
 * Unmap the framebuffer and MMIO memory.
 */

_X_EXPORT Bool
CirUnmapMem(CirPtr pCir, int scrnIndex)
{
#ifdef CIR_DEBUG
	ErrorF("CirUnmapMem\n");
#endif

	if (pCir->IOBase != NULL) {
		/*
		 * Unmap IO registers to virtual address space
		 */
#ifndef XSERVER_LIBPCIACCESS
		xf86UnMapVidMem(scrnIndex, (pointer)pCir->IOBase, pCir->IoMapSize);
#else
		pci_device_unmap_range(pCir->PciInfo, (pointer)pCir->IOBase, pCir->IoMapSize);
#endif
		pCir->IOBase = NULL;
	}

#ifndef XSERVER_LIBPCIACCESS
	xf86UnMapVidMem(scrnIndex, (pointer)pCir->FbBase, pCir->FbMapSize);
#else
	pci_device_unmap_range(pCir->PciInfo, (pointer)pCir->FbBase, pCir->FbMapSize);
#endif
	pCir->FbBase = NULL;
	return TRUE;
}

_X_EXPORT void
cirProbeDDC(ScrnInfoPtr pScrn, int index)
{
    vbeInfoPtr pVbe;

    if (xf86LoadSubModule(pScrn, "vbe")) {
        pVbe = VBEInit(NULL,index);
        ConfiguredMonitor = vbeDoEDID(pVbe, NULL);
	vbeFree(pVbe);
    }
}
@


1.5
log
@Update to xf86-video-cirrus 1.5.1
@
text
@d240 2
a241 2
    free(devSections);
    if (numUsed <= 0)
d243 1
d261 6
d300 1
@


1.4
log
@Upate to xf86-video-cirrus 1.4.0
@
text
@a26 7
/* Drivers for PCI hardware need this */
#include "xf86PciInfo.h"

#ifndef PCI_CHIP_GD7556  /*  for old xf86PciInfo.h  */
#define PCI_CHIP_GD7556            0x004C
#endif

d252 11
@


1.3
log
@Update to xf86-video-cirrus 1.3.2
@
text
@a17 2
/* $XFree86: xc/programs/Xserver/hw/xfree86/drivers/cirrus/cir_driver.c,v 1.67 2001/05/15 10:19:37 eich Exp $ */

d30 4
d95 2
d114 2
d247 1
a247 1
    xfree(devSections);
d289 1
a289 1
    xfree(usedChips);
@


1.2
log
@xf86-video-cirrus 1.2.1 + one bug fix from git-current.
Tested on alpine gl5446 on alpha.
@
text
@d24 1
d26 1
a26 1

d97 1
a97 1
PciChipsets CIRPciChipsets[] = {
a112 27
/*
 * List of symbols from other modules that this module references.  This
 * list is used to tell the loader that it is OK for symbols here to be
 * unresolved providing that it hasn't been told that they haven't been
 * told that they are essential via a call to xf86LoaderReqSymbols() or
 * xf86LoaderReqSymLists().  The purpose of this is to avoid warnings about
 * unresolved symbols that are not required.
 */

static const char *alpSymbols[] = {
	"AlpAvailableOptions",
	"AlpProbe",
	NULL
};
static const char *lgSymbols[] = {
	"LgAvailableOptions",
	"LgProbe",
	NULL
};

static const char *vbeSymbols[] = {
	"VBEInit",
	"vbeDoEDID",
	"vbeFree",
	NULL
};

a147 1
		LoaderRefSymLists(alpSymbols, lgSymbols, vbeSymbols, NULL);
a211 1
		xf86LoaderReqSymLists(lgSymbols, NULL);
a216 1
		xf86LoaderReqSymLists(alpSymbols, NULL);
a261 1
 		xf86LoaderReqSymLists(lgSymbols, NULL);
a268 1
 		xf86LoaderReqSymLists(alpSymbols, NULL);
d292 1
a292 1
Bool
d382 1
a382 1
Bool
d410 1
a410 1
void
a415 1
	xf86LoaderReqSymLists(vbeSymbols,NULL);
@


1.1
log
@Initial revision
@
text
@d56 3
a58 3
#define CIR_MAJOR_VERSION 1
#define CIR_MINOR_VERSION 1
#define CIR_PATCHLEVEL 0
d255 2
a256 1
    
d264 1
d283 4
a286 4
 	if (pPci && (pPci->chipType == PCI_CHIP_GD5462 ||
 	    pPci->chipType == PCI_CHIP_GD5464 ||
 	    pPci->chipType == PCI_CHIP_GD5464BD ||
 	    pPci->chipType == PCI_CHIP_GD5465)) {
d308 1
a308 1
 	    pScrn->driverVersion = VERSION;
d336 2
d344 13
d369 2
d377 1
d383 13
d424 1
d426 3
d432 1
d434 3
@


1.1.1.1
log
@Importing xf86-video-cirrus 1.1.0
@
text
@@
