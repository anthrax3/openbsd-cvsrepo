head	1.9;
access;
symbols
	OPENBSD_6_1_BASE:1.9
	OPENBSD_6_0:1.9.0.8
	OPENBSD_6_0_BASE:1.9
	OPENBSD_5_9:1.9.0.6
	OPENBSD_5_9_BASE:1.9
	OPENBSD_5_8:1.9.0.4
	OPENBSD_5_8_BASE:1.9
	OPENBSD_5_7:1.9.0.2
	OPENBSD_5_7_BASE:1.9
	OPENBSD_5_6:1.8.0.6
	OPENBSD_5_6_BASE:1.8
	OPENBSD_5_5:1.8.0.4
	OPENBSD_5_5_BASE:1.8
	OPENBSD_5_4:1.8.0.2
	OPENBSD_5_4_BASE:1.8
	OPENBSD_5_3:1.7.0.2
	OPENBSD_5_3_BASE:1.7
	OPENBSD_5_2:1.6.0.2
	OPENBSD_5_2_BASE:1.6
	OPENBSD_5_1_BASE:1.5
	OPENBSD_5_1:1.5.0.2
	OPENBSD_5_0:1.4.0.2
	OPENBSD_5_0_BASE:1.4
	OPENBSD_4_9:1.3.0.2
	OPENBSD_4_9_BASE:1.3
	OPENBSD_4_8:1.2.0.4
	OPENBSD_4_8_BASE:1.2
	OPENBSD_4_7:1.1.0.4
	OPENBSD_4_7_BASE:1.1
	OPENBSD_4_6:1.1.0.2
	OPENBSD_4_6_BASE:1.1;
locks; strict;
comment	@ * @;


1.9
date	2015.01.25.18.49.46;	author shadchin;	state Exp;
branches;
next	1.8;
commitid	YMqHg8ZchhpuJyuU;

1.8
date	2013.05.03.09.34.39;	author shadchin;	state Exp;
branches;
next	1.7;

1.7
date	2012.08.16.16.42.10;	author shadchin;	state Exp;
branches;
next	1.6;

1.6
date	2012.04.01.12.17.17;	author shadchin;	state Exp;
branches;
next	1.5;

1.5
date	2011.11.06.10.21.07;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2011.04.22.18.35.19;	author shadchin;	state Exp;
branches;
next	1.3;

1.3
date	2010.11.21.15.13.52;	author shadchin;	state Exp;
branches;
next	1.2;

1.2
date	2010.07.27.19.08.46;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2009.05.03.16.21.30;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.9
log
@Update to xf86-input-mouse 1.9.1.

ok matthieu@@
@
text
@/*
 * Copyright (c) 2004-2005, 2008-2010, Oracle and/or its affiliates.
 * All rights reserved.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice (including the next
 * paragraph) shall be included in all copies or substantial portions of the
 * Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 */
/*
 * Copyright 1999-2001 The XFree86 Project, Inc.  All Rights Reserved.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to
 * deal in the Software without restriction, including without limitation the
 * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
 * sell copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
 * XFREE86 PROJECT BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
 * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 *
 * Except as contained in this notice, the name of the XFree86 Project shall
 * not be used in advertising or otherwise to promote the sale, use or other
 * dealings in this Software without prior written authorization from the
 * XFree86 Project.
 */

#ifdef HAVE_XORG_CONFIG_H
#include <xorg-config.h>
#endif

#include "xorg-server.h"
#include "xf86.h"
#include "xf86_OSlib.h"
#include "mouse.h"
#include "xisb.h"
#include "mipointer.h"
#include "xf86Crtc.h"
#include <sys/stropts.h>
#include <sys/vuid_event.h>
#include <sys/msio.h>

/* Wheel mouse support in VUID drivers in Solaris 9 updates & Solaris 10 */
#ifdef WHEEL_DEVID /* Defined in vuid_event.h if VUID wheel support present */
# define HAVE_VUID_WHEEL
#endif
#ifdef HAVE_VUID_WHEEL
# include <sys/vuid_wheel.h>
#endif

/* Support for scaling absolute coordinates to screen size in
 * Solaris 10 updates and beyond */
#if !defined(HAVE_ABSOLUTE_MOUSE_SCALING)
# ifdef MSIOSRESOLUTION /* Defined in msio.h if scaling support present */
#  define HAVE_ABSOLUTE_MOUSE_SCALING
# endif
#endif

/* Names of protocols that are handled internally here. */

static const char *internalNames[] = {
        "VUID",
        NULL
};

static const char *solarisMouseDevs[] = {
    /* Device file:     Protocol:                       */
    "/dev/mouse",       "VUID",         /* USB or SPARC */
#if defined(__i386) || defined(__x86)
    "/dev/kdmouse",     "PS/2",         /* PS/2 */
#endif
    NULL
};

typedef struct _VuidMseRec {
    struct _VuidMseRec *next;
    InputInfoPtr        pInfo;
    Firm_event          event;
    unsigned char *     buffer;
    char *              strmod;
    Bool(*wrapped_device_control)(DeviceIntPtr device, int what);
#ifdef HAVE_ABSOLUTE_MOUSE_SCALING
    Ms_screen_resolution         absres;
#endif
    OsTimerPtr          remove_timer;   /* Callback for removal on ENODEV */
} VuidMseRec, *VuidMsePtr;

static VuidMsePtr       vuidMouseList = NULL;

static int  vuidMouseProc(DeviceIntPtr pPointer, int what);
static void vuidReadInput(InputInfoPtr pInfo);

#ifdef HAVE_ABSOLUTE_MOUSE_SCALING
# include "compat-api.h"

static void vuidMouseSendScreenSize(ScreenPtr pScreen, VuidMsePtr pVuidMse);
static void vuidMouseAdjustFrame(ADJUST_FRAME_ARGS_DECL);

static int vuidMouseGeneration = 0;

#if HAS_DEVPRIVATEKEYREC
static DevPrivateKeyRec vuidMouseScreenIndex;
#else
static int vuidMouseScreenIndex;
#endif /* HAS_DEVPRIVATEKEYREC */

#define vuidMouseGetScreenPrivate(s) ( \
    dixLookupPrivate(&(s)->devPrivates, &vuidMouseScreenIndex))
#define vuidMouseSetScreenPrivate(s,p) \
    dixSetPrivate(&(s)->devPrivates, &vuidMouseScreenIndex, (void *) p)
#endif /* HAVE_ABSOLUTE_MOUSE_SCALING */

static inline
VuidMsePtr getVuidMsePriv(InputInfoPtr pInfo)
{
    VuidMsePtr m = vuidMouseList;

    while ((m != NULL) && (m->pInfo != pInfo)) {
        m = m->next;
    }

    return m;
}

/* Called from OsTimer callback, since removing a device from the device
   list or changing pInfo->fd while xf86Wakeup is looping through the list
   causes server crashes */
static CARD32
vuidRemoveMouse(OsTimerPtr timer, CARD32 now, pointer arg)
{
    InputInfoPtr pInfo = (InputInfoPtr) arg;

    xf86DisableDevice(pInfo->dev, TRUE);

    return 0;  /* All done, don't set to run again */
}

/*
 * Initialize and enable the mouse wheel, if present.
 *
 * Returns 1 if mouse wheel was successfully enabled.
 * Returns 0 if an error occurred or if there is no mouse wheel.
 */
static int
vuidMouseWheelInit(InputInfoPtr pInfo)
{
#ifdef HAVE_VUID_WHEEL
    wheel_state wstate;
    int nwheel = -1;
    int i;

    wstate.vers = VUID_WHEEL_STATE_VERS;
    wstate.id = 0;
    wstate.stateflags = (uint32_t) -1;

    SYSCALL(i = ioctl(pInfo->fd, VUIDGWHEELCOUNT, &nwheel));
    if (i != 0)
        return (0);

    SYSCALL(i = ioctl(pInfo->fd, VUIDGWHEELSTATE, &wstate));
    if (i != 0) {
        xf86Msg(X_WARNING, "%s: couldn't get wheel state\n", pInfo->name);
        return (0);
    }

    wstate.stateflags |= VUID_WHEEL_STATE_ENABLED;

    SYSCALL(i = ioctl(pInfo->fd, VUIDSWHEELSTATE, &wstate));
    if (i != 0) {
        xf86Msg(X_WARNING, "%s: couldn't enable wheel\n", pInfo->name);
        return (0);
    }

    return (1);
#else
    return (0);
#endif
}


/* This function is called when the protocol is "VUID". */
static Bool
vuidPreInit(InputInfoPtr pInfo, const char *protocol, int flags)
{
    MouseDevPtr pMse = pInfo->private;
    VuidMsePtr pVuidMse;

    /* Ensure we don't add the same device twice */
    if (getVuidMsePriv(pInfo) != NULL)
        return TRUE;

    pVuidMse = calloc(sizeof(VuidMseRec), 1);
    if (pVuidMse == NULL) {
        xf86Msg(X_ERROR, "%s: cannot allocate VuidMouseRec\n", pInfo->name);
        free(pMse);
        return FALSE;
    }

    pVuidMse->buffer = (unsigned char *)&pVuidMse->event;
    pVuidMse->strmod = xf86SetStrOption(pInfo->options, "StreamsModule", NULL);

    /* Setup the local procs. */
    pVuidMse->wrapped_device_control = pInfo->device_control;
    pInfo->device_control = vuidMouseProc;
    pInfo->read_input = vuidReadInput;

    pMse->xisbscale = sizeof(Firm_event);

#ifdef HAVE_ABSOLUTE_MOUSE_SCALING
    pVuidMse->absres.height = pVuidMse->absres.width = 0;
#endif
    pVuidMse->pInfo = pInfo;
    pVuidMse->next = vuidMouseList;
    vuidMouseList = pVuidMse;

#if GET_ABI_MAJOR(ABI_XINPUT_VERSION) < 12
    pInfo->flags |= XI86_CONFIGURED;
#endif
    return TRUE;
}

static void
vuidFlushAbsEvents(InputInfoPtr pInfo, int absX, int absY,
                   Bool *absXset, Bool *absYset)
{
#ifdef DEBUG
    ErrorF("vuidFlushAbsEvents: %d,%d (set: %d, %d)\n", absX, absY,
           *absXset, *absYset);
#endif
    if ((*absXset) && (*absYset)) {
        xf86PostMotionEvent(pInfo->dev,
                            /* is_absolute: */    TRUE,
                            /* first_valuator: */ 0,
                            /* num_valuators: */  2,
                            absX, absY);
    } else if (*absXset) {
        xf86PostMotionEvent(pInfo->dev,
                            /* is_absolute: */    TRUE,
                            /* first_valuator: */ 0,
                            /* num_valuators: */  1,
                            absX);
    } else if (*absYset) {
        xf86PostMotionEvent(pInfo->dev,
                            /* is_absolute: */    TRUE,
                            /* first_valuator: */ 1,
                            /* num_valuators: */  1,
                            absY);
    }

    *absXset = FALSE;
    *absYset = FALSE;
}

static void
vuidReadInput(InputInfoPtr pInfo)
{
    MouseDevPtr pMse;
    VuidMsePtr pVuidMse;
    int buttons;
    int dx = 0, dy = 0, dz = 0, dw = 0;
    unsigned int n;
    unsigned char *pBuf;
    int absX = 0, absY = 0;
    Bool absXset = FALSE, absYset = FALSE;

    pMse = pInfo->private;
    pVuidMse = getVuidMsePriv(pInfo);
    buttons = pMse->lastButtons;
    pBuf = pVuidMse->buffer;
    n = 0;

    do {
        n = read(pInfo->fd, pBuf, sizeof(Firm_event));

        if (n == 0) {
            break;
        } else if (n == -1) {
            switch (errno) {
                case EAGAIN: /* Nothing to read now */
                    n = 0;   /* End loop, go on to flush events & return */
                    continue;
                case EINTR:  /* Interrupted, try again */
                    continue;
                case ENODEV: /* May happen when USB mouse is unplugged */
                    /* We use X_NONE here because it didn't alloc since we
                       may be called from SIGIO handler. No longer true for
                       sigsafe logging, but matters for older servers  */
                    LogMessageVerbSigSafe(X_NONE, 0,
                                          "%s: Device no longer present - removing.\n",
                                          pInfo->name);
                    xf86RemoveEnabledDevice(pInfo);
                    pVuidMse->remove_timer =
                        TimerSet(pVuidMse->remove_timer, 0, 1,
                                 vuidRemoveMouse, pInfo);
                    return;
                default:     /* All other errors */
                    /* We use X_NONE here because it didn't alloc since we
                       may be called from SIGIO handler. No longer true for
                       sigsafe logging, but matters for older servers  */
                    LogMessageVerbSigSafe(X_NONE, 0, "%s: Read error: %s\n",
                                          pInfo->name, strerror(errno));
                    return;
            }
        } else if (n != sizeof(Firm_event)) {
            xf86Msg(X_WARNING, "%s: incomplete packet, size %d\n",
                        pInfo->name, n);
        }

#ifdef DEBUG
        LogMessageVerbSigSafe("vuidReadInput: event type: %d value: %d\n",
                              pVuidMse->event.id, pVuidMse->event.value);
#endif

        if (pVuidMse->event.id >= BUT_FIRST && pVuidMse->event.id <= BUT_LAST) {
            /* button */
            int butnum = pVuidMse->event.id - BUT_FIRST;

            if (butnum < 3)
                butnum = 2 - butnum;
            if (!pVuidMse->event.value)
                buttons &= ~(1 << butnum);
            else
                buttons |= (1 << butnum);
        } else if (pVuidMse->event.id >= VLOC_FIRST &&
                   pVuidMse->event.id <= VLOC_LAST) {
            /* axis */
            int delta = pVuidMse->event.value;
            switch(pVuidMse->event.id) {
            case LOC_X_DELTA:
                dx += delta;
                break;
            case LOC_Y_DELTA:
                dy -= delta;
                break;
            case LOC_X_ABSOLUTE:
                if (absXset) {
                    vuidFlushAbsEvents(pInfo, absX, absY, &absXset, &absYset);
                }
                absX = delta;
                absXset = TRUE;
                break;
            case LOC_Y_ABSOLUTE:
                if (absYset) {
                    vuidFlushAbsEvents(pInfo, absX, absY, &absXset, &absYset);
                }
                absY = delta;
                absYset = TRUE;
                break;
            }
        }
#ifdef HAVE_VUID_WHEEL
        else if (vuid_in_range(VUID_WHEEL, pVuidMse->event.id)) {
            if (vuid_id_offset(pVuidMse->event.id) == 0)
                dz -= VUID_WHEEL_GETDELTA(pVuidMse->event.value);
            else
                dw -= VUID_WHEEL_GETDELTA(pVuidMse->event.value);
        }
#endif
#ifdef HAVE_ABSOLUTE_MOUSE_SCALING
        else if (pVuidMse->event.id == MOUSE_TYPE_ABSOLUTE) {
            ScreenPtr   ptrCurScreen;

            /* force sending absolute resolution scaling ioctl */
            pVuidMse->absres.height = pVuidMse->absres.width = 0;
            ptrCurScreen = miPointerGetScreen(pInfo->dev);
            vuidMouseSendScreenSize(ptrCurScreen, pVuidMse);
        }
#endif

    } while (n != 0);

    if (absXset || absYset) {
        vuidFlushAbsEvents(pInfo, absX, absY, &absXset, &absYset);
    }

    pMse->PostEvent(pInfo, buttons, dx, dy, dz, dw);
    return;
}

#ifdef HAVE_ABSOLUTE_MOUSE_SCALING
static void vuidMouseSendScreenSize(ScreenPtr pScreen, VuidMsePtr pVuidMse)
{
    InputInfoPtr pInfo = pVuidMse->pInfo;
    ScrnInfoPtr pScr = XF86SCRNINFO(pScreen);
    int result;

    if ((pVuidMse->absres.width != pScr->virtualX) ||
        (pVuidMse->absres.height != pScr->virtualY))
    {
        pVuidMse->absres.width = pScr->virtualX;
        pVuidMse->absres.height = pScr->virtualY;

        do {
            result = ioctl(pInfo->fd, MSIOSRESOLUTION, &(pVuidMse->absres));
        } while ( (result != 0) && (errno == EINTR) );

        if (result != 0) {
            LogMessageVerbSigSafe(X_WARNING, -1,
                                  "%s: couldn't set absolute mouse scaling resolution: %s\n",
                                  pInfo->name, strerror(errno));
#ifdef DEBUG
        } else {
            LogMessageVerbSigSafe(X_INFO,
                                  "%s: absolute mouse scaling resolution set to %d x %d\n",
                                  pInfo->name,
                                  pVuidMse->absres.width,
                                  pVuidMse->absres.height);
#endif
        }
    }
}

static void vuidMouseAdjustFrame(ADJUST_FRAME_ARGS_DECL)
{
      SCRN_INFO_PTR(arg);
      ScreenPtr         pScreen = xf86ScrnToScreen(pScrn);
      xf86AdjustFrameProc *wrappedAdjustFrame
          = (xf86AdjustFrameProc *) vuidMouseGetScreenPrivate(pScreen);
      VuidMsePtr        m;
      ScreenPtr         ptrCurScreen;

      if (wrappedAdjustFrame) {
          pScrn->AdjustFrame = wrappedAdjustFrame;
          (*pScrn->AdjustFrame)(ADJUST_FRAME_ARGS(pScrn, x, y));
          pScrn->AdjustFrame = vuidMouseAdjustFrame;
      }

      for (m = vuidMouseList; m != NULL ; m = m->next) {
          ptrCurScreen = miPointerGetScreen(m->pInfo->dev);
          if (ptrCurScreen == pScreen)
          {
              vuidMouseSendScreenSize(pScreen, m);
          }
      }
}

static void vuidMouseCrtcNotify(ScreenPtr pScreen)
{
    xf86_crtc_notify_proc_ptr wrappedCrtcNotify
        = (xf86_crtc_notify_proc_ptr) vuidMouseGetScreenPrivate(pScreen);
    VuidMsePtr       m;
    ScreenPtr        ptrCurScreen;

    if (wrappedCrtcNotify)
        wrappedCrtcNotify(pScreen);

    for (m = vuidMouseList; m != NULL ; m = m->next) {
        ptrCurScreen = miPointerGetScreen(m->pInfo->dev);
        if (ptrCurScreen == pScreen) {
            vuidMouseSendScreenSize(pScreen, m);
        }
    }
}
#endif /* HAVE_ABSOLUTE_MOUSE_SCALING */


static int
vuidMouseProc(DeviceIntPtr pPointer, int what)
{
    InputInfoPtr pInfo;
    MouseDevPtr pMse;
    VuidMsePtr pVuidMse;
    int ret = Success;
    int i;

    pInfo = pPointer->public.devicePrivate;
    pMse = pInfo->private;
    pMse->device = pPointer;

    pVuidMse = getVuidMsePriv(pInfo);
    if (pVuidMse == NULL) {
        return BadImplementation;
    }

    switch (what) {

    case DEVICE_INIT:
#ifdef HAVE_ABSOLUTE_MOUSE_SCALING

#if HAS_DEVPRIVATEKEYREC
        if (!dixRegisterPrivateKey(&vuidMouseScreenIndex, PRIVATE_SCREEN, 0))
                return BadAlloc;
#endif  /* HAS_DEVPRIVATEKEYREC */

        if (vuidMouseGeneration != serverGeneration) {
                for (i = 0; i < screenInfo.numScreens; i++) {
                    ScreenPtr pScreen = screenInfo.screens[i];
                    ScrnInfoPtr pScrn = XF86SCRNINFO(pScreen);
                    if (xf86CrtcConfigPrivateIndex != -1) {
                        xf86_crtc_notify_proc_ptr pCrtcNotify
                            = xf86_wrap_crtc_notify(pScreen,
                                                    vuidMouseCrtcNotify);
                        vuidMouseSetScreenPrivate(pScreen, pCrtcNotify);
                    } else {
                        vuidMouseSetScreenPrivate(pScreen,
                                                  pScrn->AdjustFrame);
                        pScrn->AdjustFrame = vuidMouseAdjustFrame;
                    }
                }
            vuidMouseGeneration = serverGeneration;
        }
#endif
        ret = pVuidMse->wrapped_device_control(pPointer, what);
        break;

    case DEVICE_ON:
        ret = pVuidMse->wrapped_device_control(pPointer, DEVICE_ON);

        if ((ret == Success) && (pInfo->fd != -1)) {
            int fmt = VUID_FIRM_EVENT;

            if (pVuidMse->strmod) {
                /* Check to see if module is already pushed */
                SYSCALL(i = ioctl(pInfo->fd, I_FIND, pVuidMse->strmod));

                if (i == 0) { /* Not already pushed */
                    SYSCALL(i = ioctl(pInfo->fd, I_PUSH, pVuidMse->strmod));
                    if (i < 0) {
                        xf86Msg(X_WARNING, "%s: cannot push module '%s' "
                                "onto mouse device: %s\n", pInfo->name,
                                pVuidMse->strmod, strerror(errno));
                        free(pVuidMse->strmod);
                        pVuidMse->strmod = NULL;
                    }
                }
            }

            SYSCALL(i = ioctl(pInfo->fd, VUIDSFORMAT, &fmt));
            if (i < 0) {
                xf86Msg(X_WARNING,
                        "%s: cannot set mouse device to VUID mode: %s\n",
                        pInfo->name, strerror(errno));
            }
            vuidMouseWheelInit(pInfo);
#ifdef HAVE_ABSOLUTE_MOUSE_SCALING
            vuidMouseSendScreenSize(screenInfo.screens[0], pVuidMse);
#endif
            xf86FlushInput(pInfo->fd);

            /* Allocate here so we don't alloc in ReadInput which may be called
               from SIGIO handler. */
            if (pVuidMse->remove_timer == NULL) {
                pVuidMse->remove_timer = TimerSet(pVuidMse->remove_timer,
                                                  0, 0, NULL, NULL);
            }
        }
        break;

    case DEVICE_OFF:
    case DEVICE_CLOSE:
        if (pInfo->fd != -1) {
            if (pVuidMse->strmod) {
                SYSCALL(i = ioctl(pInfo->fd, I_POP, pVuidMse->strmod));
                if (i == -1) {
                    xf86Msg(X_WARNING,
                      "%s: cannot pop module '%s' off mouse device: %s\n",
                      pInfo->name, pVuidMse->strmod, strerror(errno));
                }
            }
        }
        if (pVuidMse->remove_timer) {
            TimerFree(pVuidMse->remove_timer);
            pVuidMse->remove_timer = NULL;
        }
        ret = pVuidMse->wrapped_device_control(pPointer, what);
        break;

    default: /* Should never be called, but just in case */
        ret = pVuidMse->wrapped_device_control(pPointer, what);
        break;
    }
    return ret;
}

static Bool
sunMousePreInit(InputInfoPtr pInfo, const char *protocol, int flags)
{
    /* The protocol is guaranteed to be one of the internalNames[] */
    if (xf86NameCmp(protocol, "VUID") == 0) {
        return vuidPreInit(pInfo, protocol, flags);
    }
    return TRUE;
}

static const char **
BuiltinNames(void)
{
    return internalNames;
}

static Bool
CheckProtocol(const char *protocol)
{
    int i;

    for (i = 0; internalNames[i]; i++)
        if (xf86NameCmp(protocol, internalNames[i]) == 0)
            return TRUE;

    return FALSE;
}

static const char *
DefaultProtocol(void)
{
    return "Auto";
}

static Bool
solarisMouseAutoProbe(InputInfoPtr pInfo, const char **protocol,
        const char **device)
{
    const char **pdev, **pproto;
    int fd = -1;
    Bool found;
    char *strmod;

    if (*device == NULL) {
        /* Check to see if xorg.conf or HAL specified a device to use */
        *device = xf86CheckStrOption(pInfo->options, "Device", NULL);
    }

    if (*device != NULL) {
        strmod = xf86CheckStrOption(pInfo->options, "StreamsModule", NULL);
        if (strmod) {
            /* if a device name is already known, and a StreamsModule is
               specified to convert events to VUID, then we don't need to
               probe further */
            *protocol = "VUID";
            return TRUE;
        }
    }


    for (pdev = solarisMouseDevs; *pdev; pdev += 2) {
        pproto = pdev + 1;
        if ((*protocol != NULL) && (strcmp(*protocol, "Auto") != 0) &&
          (*pproto != NULL) && (strcmp(*pproto, *protocol) != 0)) {
            continue;
        }
        if ((*device != NULL) && (strcmp(*device, *pdev) != 0)) {
            continue;
        }
        SYSCALL (fd = open(*pdev, O_RDWR | O_NONBLOCK));
        if (fd == -1) {
#ifdef DEBUG
            ErrorF("Cannot open %s (%s)\n", pdev, strerror(errno));
#endif
        } else {
            found = TRUE;
            if ((*pproto != NULL) && (strcmp(*pproto, "VUID") == 0)) {
                int i, r;
                SYSCALL(r = ioctl(fd, VUIDGFORMAT, &i));
                if (r < 0) {
                    found = FALSE;
                }
            }
            close(fd);
            if (found == TRUE) {
                if (*pproto != NULL) {
                    *protocol = *pproto;
                }
                *device = *pdev;
                return TRUE;
            }
        }
    }
    return FALSE;
}

static const char *
SetupAuto(InputInfoPtr pInfo, int *protoPara)
{
    const char *pdev = NULL;
    const char *pproto = NULL;
    MouseDevPtr pMse = pInfo->private;

    if (pInfo->fd == -1) {
        /* probe to find device/protocol to use */
        if (solarisMouseAutoProbe(pInfo, &pproto, &pdev) != FALSE) {
            /* Set the Device option. */
            pInfo->options =
             xf86AddNewOption(pInfo->options, "Device", pdev);
            xf86Msg(X_INFO, "%s: Setting Device option to \"%s\"\n",
              pInfo->name, pdev);
        }
    } else if (pMse->protocolID == PROT_AUTO) {
        pdev = xf86CheckStrOption(pInfo->options,
                "Device", NULL);
        if ((solarisMouseAutoProbe(pInfo, &pproto, &pdev) != FALSE) &&
            (pproto != NULL))
            sunMousePreInit(pInfo, pproto, 0);
    }
    return pproto;
}

static const char *
FindDevice(InputInfoPtr pInfo, const char *protocol, int flags)
{
    const char *pdev = NULL;
    const char *pproto = protocol;

    if (solarisMouseAutoProbe(pInfo, &pproto, &pdev) != FALSE) {
        /* Set the Device option. */
        pInfo->options =
          xf86AddNewOption(pInfo->options, "Device", pdev);
        xf86Msg(X_INFO, "%s: Setting Device option to \"%s\"\n",
          pInfo->name, pdev);
    }
    return pdev;
}

static int
SupportedInterfaces(void)
{
    /* XXX This needs to be checked. */
    return MSE_SERIAL | MSE_BUS | MSE_PS2 | MSE_AUTO | MSE_XPS2 | MSE_MISC;
}

OSMouseInfoPtr
OSMouseInit(int flags)
{
    OSMouseInfoPtr p;

    p = calloc(sizeof(OSMouseInfoRec), 1);
    if (!p)
        return NULL;
    p->SupportedInterfaces = SupportedInterfaces;
    p->BuiltinNames = BuiltinNames;
    p->CheckProtocol = CheckProtocol;
    p->PreInit = sunMousePreInit;
    p->DefaultProtocol = DefaultProtocol;
    p->SetupAuto = SetupAuto;
    p->FindDevice = FindDevice;

    return p;
}

@


1.8
log
@Update to xf86-input-mouse 1.9.0.

ok matthieu@@
@
text
@d60 1
d409 2
a410 5
    if (!pScr->currentMode)
        return;

    if ((pVuidMse->absres.width != pScr->currentMode->HDisplay) ||
        (pVuidMse->absres.height != pScr->currentMode->VDisplay))
d412 2
a413 2
        pVuidMse->absres.width = pScr->currentMode->HDisplay;
        pVuidMse->absres.height = pScr->currentMode->VDisplay;
d458 18
d511 10
a520 2
                    vuidMouseSetScreenPrivate(pScreen, pScrn->AdjustFrame);
                    pScrn->AdjustFrame = vuidMouseAdjustFrame;
@


1.7
log
@Update to xf86-input-mouse 1.8.1

ok matthieu@@
@
text
@d306 6
a311 5
                    /* We use X_NONE here because it doesn't alloc since we
                       may be called from SIGIO handler */
                    xf86MsgVerb(X_NONE, 0,
                                "%s: Device no longer present - removing.\n",
                                pInfo->name);
d318 5
a322 4
                    /* We use X_NONE here because it doesn't alloc since we
                       may be called from SIGIO handler */
                    xf86MsgVerb(X_NONE, 0, "%s: Read error: %s\n", pInfo->name,
                                strerror(errno));
d331 2
a332 2
        ErrorF("vuidReadInput: event type: %3d value: %5d\n",
               pVuidMse->event.id, pVuidMse->event.value);
d422 3
a424 3
            xf86Msg(X_WARNING,
                    "%s: couldn't set absolute mouse scaling resolution: %s\n",
                    pInfo->name, strerror(errno));
d427 5
a431 4
            xf86Msg(X_INFO,
                    "%s: absolute mouse scaling resolution set to %d x %d\n",
                    pInfo->name,
                    pVuidMse->absres.width, pVuidMse->absres.height);
@


1.6
log
@Update to xf86-input-mouse 1.7.2.

ok matthieu@@
@
text
@d72 1
a72 1
/* Support for scaling absolute coordinates to screen size in 
d83 2
a84 2
	"VUID",
	NULL
d88 2
a89 2
    /* Device file:	Protocol: 			*/
    "/dev/mouse",	"VUID",		/* USB or SPARC */
d91 1
a91 1
    "/dev/kdmouse",	"PS/2",		/* PS/2 */
d97 5
a101 5
    struct _VuidMseRec *next;    
    InputInfoPtr	pInfo;
    Firm_event 		event;
    unsigned char *	buffer;
    char *		strmod;
d104 1
a104 1
    Ms_screen_resolution	 absres;
d106 1
a106 1
    OsTimerPtr		remove_timer;   /* Callback for removal on ENODEV */
d109 1
a109 1
static VuidMsePtr	vuidMouseList = NULL;
d115 2
d118 1
a118 1
static void vuidMouseAdjustFrame(int index, int x, int y, int flags);
d140 1
a140 1
	m = m->next;
d150 1
a150 1
vuidRemoveMouse(OsTimerPtr timer, CARD32 time, pointer arg)
d179 1
a179 1
	return (0);
d183 2
a184 2
	xf86Msg(X_WARNING, "%s: couldn't get wheel state\n", pInfo->name);
	return (0);
d191 2
a192 2
	xf86Msg(X_WARNING, "%s: couldn't enable wheel\n", pInfo->name);
	return (0);
d211 1
a211 1
	return TRUE;
d215 3
a217 3
	xf86Msg(X_ERROR, "%s: cannot allocate VuidMouseRec\n", pInfo->name);
	free(pMse);
	return FALSE;
d230 1
a230 1
#ifdef HAVE_ABSOLUTE_MOUSE_SCALING    
d234 1
a234 1
    pVuidMse->next = vuidMouseList; 
d244 2
a245 2
vuidFlushAbsEvents(InputInfoPtr pInfo, int absX, int absY, 
		   Bool *absXset, Bool *absYset)
d248 2
a249 2
    ErrorF("vuidFlushAbsEvents: %d,%d (set: %d, %d)\n", absX, absY, 
	   *absXset, *absYset);
d252 5
a256 5
	xf86PostMotionEvent(pInfo->dev, 
			    /* is_absolute: */    TRUE,
			    /* first_valuator: */ 0,
			    /* num_valuators: */  2,
			    absX, absY);
d258 5
a262 5
	xf86PostMotionEvent(pInfo->dev, 
			    /* is_absolute: */    TRUE,
			    /* first_valuator: */ 0,
			    /* num_valuators: */  1,
			    absX);
d264 5
a268 5
	xf86PostMotionEvent(pInfo->dev, 
			    /* is_absolute: */    TRUE,
			    /* first_valuator: */ 1,
			    /* num_valuators: */  1,
			    absY);
d294 1
a294 1
	n = read(pInfo->fd, pBuf, sizeof(Firm_event));
d296 31
a326 31
	if (n == 0) {
	    break;
	} else if (n == -1) {
	    switch (errno) {
		case EAGAIN: /* Nothing to read now */
		    n = 0;   /* End loop, go on to flush events & return */
		    continue;
		case EINTR:  /* Interrupted, try again */
		    continue;
		case ENODEV: /* May happen when USB mouse is unplugged */
		    /* We use X_NONE here because it doesn't alloc since we
		       may be called from SIGIO handler */
		    xf86MsgVerb(X_NONE, 0,
				"%s: Device no longer present - removing.\n",
				pInfo->name);
		    xf86RemoveEnabledDevice(pInfo);
		    pVuidMse->remove_timer =
			TimerSet(pVuidMse->remove_timer, 0, 1,
				 vuidRemoveMouse, pInfo);
		    return;
		default:     /* All other errors */
		    /* We use X_NONE here because it doesn't alloc since we
		       may be called from SIGIO handler */
		    xf86MsgVerb(X_NONE, 0, "%s: Read error: %s\n", pInfo->name,
				strerror(errno));
		    return;
	    }
	} else if (n != sizeof(Firm_event)) {
	    xf86Msg(X_WARNING, "%s: incomplete packet, size %d\n",
			pInfo->name, n);
	}
d329 2
a330 2
	ErrorF("vuidReadInput: event type: %3d value: %5d\n",
	       pVuidMse->event.id, pVuidMse->event.value);
d333 37
a369 37
	if (pVuidMse->event.id >= BUT_FIRST && pVuidMse->event.id <= BUT_LAST) {
	    /* button */
	    int butnum = pVuidMse->event.id - BUT_FIRST;

	    if (butnum < 3)
		butnum = 2 - butnum;
	    if (!pVuidMse->event.value)
		buttons &= ~(1 << butnum);
	    else
		buttons |= (1 << butnum);
	} else if (pVuidMse->event.id >= VLOC_FIRST &&
		   pVuidMse->event.id <= VLOC_LAST) {
	    /* axis */
	    int delta = pVuidMse->event.value;
	    switch(pVuidMse->event.id) {
	    case LOC_X_DELTA:
		dx += delta;
		break;
	    case LOC_Y_DELTA:
		dy -= delta;
		break;
	    case LOC_X_ABSOLUTE:
		if (absXset) {
		    vuidFlushAbsEvents(pInfo, absX, absY, &absXset, &absYset);
		}
		absX = delta;
		absXset = TRUE;
		break;
	    case LOC_Y_ABSOLUTE:
		if (absYset) {
		    vuidFlushAbsEvents(pInfo, absX, absY, &absXset, &absYset);
		}
		absY = delta;
		absYset = TRUE;
		break;
	    }
	} 
d371 6
a376 6
	else if (vuid_in_range(VUID_WHEEL, pVuidMse->event.id)) {
	    if (vuid_id_offset(pVuidMse->event.id) == 0)
		dz -= VUID_WHEEL_GETDELTA(pVuidMse->event.value);
	    else
		dw -= VUID_WHEEL_GETDELTA(pVuidMse->event.value);
	}
d379 2
a380 2
	else if (pVuidMse->event.id == MOUSE_TYPE_ABSOLUTE) {
	    ScreenPtr 	ptrCurScreen;
d382 5
a386 5
	    /* force sending absolute resolution scaling ioctl */
	    pVuidMse->absres.height = pVuidMse->absres.width = 0;
	    ptrCurScreen = miPointerGetScreen(pInfo->dev);
	    vuidMouseSendScreenSize(ptrCurScreen, pVuidMse);
	}
d392 1
a392 1
	vuidFlushAbsEvents(pInfo, absX, absY, &absXset, &absYset);
d407 1
a407 1
	return;
d409 2
a410 2
    if ((pVuidMse->absres.width != pScr->currentMode->HDisplay) || 
	(pVuidMse->absres.height != pScr->currentMode->VDisplay))
d412 2
a413 2
	pVuidMse->absres.width = pScr->currentMode->HDisplay;
	pVuidMse->absres.height = pScr->currentMode->VDisplay;
d415 8
a422 8
	do {
	    result = ioctl(pInfo->fd, MSIOSRESOLUTION, &(pVuidMse->absres));
	} while ( (result != 0) && (errno == EINTR) );

	if (result != 0) {
	    xf86Msg(X_WARNING, 
		    "%s: couldn't set absolute mouse scaling resolution: %s\n",
		    pInfo->name, strerror(errno));
d424 5
a428 5
	} else {
	    xf86Msg(X_INFO, 
		    "%s: absolute mouse scaling resolution set to %d x %d\n", 
		    pInfo->name, 
		    pVuidMse->absres.width, pVuidMse->absres.height);
d430 1
a430 1
	}
d434 1
a434 1
static void vuidMouseAdjustFrame(int index, int x, int y, int flags)
d436 6
a441 6
      ScrnInfoPtr	pScrn = xf86Screens[index];
      ScreenPtr		pScreen = pScrn->pScreen;
      xf86AdjustFrameProc *wrappedAdjustFrame 
	  = (xf86AdjustFrameProc *) vuidMouseGetScreenPrivate(pScreen);
      VuidMsePtr	m;
      ScreenPtr 	ptrCurScreen;
d443 4
a446 4
      if(wrappedAdjustFrame) {
        pScrn->AdjustFrame = wrappedAdjustFrame;
        (*pScrn->AdjustFrame)(index, x, y, flags);
        pScrn->AdjustFrame = vuidMouseAdjustFrame;
d450 5
a454 5
	  ptrCurScreen = miPointerGetScreen(m->pInfo->dev);
	  if (ptrCurScreen == pScreen)
	  {
	      vuidMouseSendScreenSize(pScreen, m);
	  }
d475 1
a475 1
	return BadImplementation;
d477 1
a477 1
    
d484 2
a485 2
	if (!dixRegisterPrivateKey(&vuidMouseScreenIndex, PRIVATE_SCREEN, 0))
		return BadAlloc;
d488 13
a500 13
	if (vuidMouseGeneration != serverGeneration) {
		for (i = 0; i < screenInfo.numScreens; i++) {
		    ScreenPtr pScreen = screenInfo.screens[i];
		    ScrnInfoPtr pScrn = XF86SCRNINFO(pScreen);
		    vuidMouseSetScreenPrivate(pScreen, pScrn->AdjustFrame);
		    pScrn->AdjustFrame = vuidMouseAdjustFrame;
		}
	    vuidMouseGeneration = serverGeneration;
	}
#endif    	
	ret = pVuidMse->wrapped_device_control(pPointer, what);
	break;
	
d502 1
a502 1
	ret = pVuidMse->wrapped_device_control(pPointer, DEVICE_ON);
d504 39
a542 39
	if ((ret == Success) && (pInfo->fd != -1)) {
	    int fmt = VUID_FIRM_EVENT;
	    
	    if (pVuidMse->strmod) {
		/* Check to see if module is already pushed */
		SYSCALL(i = ioctl(pInfo->fd, I_FIND, pVuidMse->strmod));

		if (i == 0) { /* Not already pushed */
		    SYSCALL(i = ioctl(pInfo->fd, I_PUSH, pVuidMse->strmod));
		    if (i < 0) {
			xf86Msg(X_WARNING, "%s: cannot push module '%s' "
				"onto mouse device: %s\n", pInfo->name,
				pVuidMse->strmod, strerror(errno));
			free(pVuidMse->strmod);
			pVuidMse->strmod = NULL;
		    }
		}
	    }

	    SYSCALL(i = ioctl(pInfo->fd, VUIDSFORMAT, &fmt));
	    if (i < 0) {
		xf86Msg(X_WARNING,
			"%s: cannot set mouse device to VUID mode: %s\n",
			pInfo->name, strerror(errno));
	    }
	    vuidMouseWheelInit(pInfo);
#ifdef HAVE_ABSOLUTE_MOUSE_SCALING	    
	    vuidMouseSendScreenSize(screenInfo.screens[0], pVuidMse);
#endif	    
	    xf86FlushInput(pInfo->fd);

	    /* Allocate here so we don't alloc in ReadInput which may be called
	       from SIGIO handler. */
	    if (pVuidMse->remove_timer == NULL) {
		pVuidMse->remove_timer = TimerSet(pVuidMse->remove_timer,
						  0, 0, NULL, NULL);
	    }
	}
	break;
d546 16
a561 16
	if (pInfo->fd != -1) {
	    if (pVuidMse->strmod) {
		SYSCALL(i = ioctl(pInfo->fd, I_POP, pVuidMse->strmod));
		if (i == -1) {
		    xf86Msg(X_WARNING,
		      "%s: cannot pop module '%s' off mouse device: %s\n",
		      pInfo->name, pVuidMse->strmod, strerror(errno));
		}
	    }
	}
	if (pVuidMse->remove_timer) {
	    TimerFree(pVuidMse->remove_timer);
	    pVuidMse->remove_timer = NULL;
	}
	ret = pVuidMse->wrapped_device_control(pPointer, what);
	break;
d564 2
a565 2
	ret = pVuidMse->wrapped_device_control(pPointer, what);
	break;
d575 1
a575 1
	return vuidPreInit(pInfo, protocol, flags);
d578 1
a578 1
}    
d592 2
a593 2
	if (xf86NameCmp(protocol, internalNames[i]) == 0)
	    return TRUE;
d605 2
a606 2
solarisMouseAutoProbe(InputInfoPtr pInfo, const char **protocol, 
	const char **device)
d614 2
a615 5
	/* Check to see if xorg.conf or HAL specified a device to use */
	*device = xf86CheckStrOption(pInfo->options, "Device", NULL);
	if (*device == NULL) {
	    *device = xf86CheckStrOption(pInfo->options, "Device", NULL);
	}
d619 8
a626 11
	strmod = xf86CheckStrOption(pInfo->options, "StreamsModule", NULL);
	if (strmod == NULL) {
	    strmod = xf86CheckStrOption(pInfo->options, "StreamsModule", NULL);
	}
	if (strmod) {
	    /* if a device name is already known, and a StreamsModule is
	       specified to convert events to VUID, then we don't need to
	       probe further */
	    *protocol = "VUID";
	    return TRUE;
	}
d631 8
a638 8
	pproto = pdev + 1;
	if ((*protocol != NULL) && (strcmp(*protocol, "Auto") != 0) &&
	  (*pproto != NULL) && (strcmp(*pproto, *protocol) != 0)) {
	    continue;
	}
	if ((*device != NULL) && (strcmp(*device, *pdev) != 0)) {
	    continue;
	}
d640 1
a640 1
	if (fd == -1) {
d642 1
a642 1
	    ErrorF("Cannot open %s (%s)\n", pdev, strerror(errno));
d644 18
a661 18
	} else {
	    found = TRUE;
	    if ((*pproto != NULL) && (strcmp(*pproto, "VUID") == 0)) {
		int i, r;
		SYSCALL(r = ioctl(fd, VUIDGFORMAT, &i));
    		if (r < 0) {
		    found = FALSE;
		}
	    }
	    close(fd);
	    if (found == TRUE) {
		if (*pproto != NULL) {
		    *protocol = *pproto;
		}
		*device = *pdev;
		return TRUE;
	    }
	}
d674 8
a681 8
	/* probe to find device/protocol to use */
	if (solarisMouseAutoProbe(pInfo, &pproto, &pdev) != FALSE) {
	    /* Set the Device option. */
	    pInfo->options =
	     xf86AddNewOption(pInfo->options, "Device", pdev);
	    xf86Msg(X_INFO, "%s: Setting Device option to \"%s\"\n",
	      pInfo->name, pdev);
	}
d683 5
a687 5
	pdev = xf86CheckStrOption(pInfo->options,
		"Device", NULL);
	if ((solarisMouseAutoProbe(pInfo, &pproto, &pdev) != FALSE) &&
	    (pproto != NULL))
	    sunMousePreInit(pInfo, pproto, 0);
d699 5
a703 5
	/* Set the Device option. */
	pInfo->options =
	  xf86AddNewOption(pInfo->options, "Device", pdev);
	xf86Msg(X_INFO, "%s: Setting Device option to \"%s\"\n",
	  pInfo->name, pdev);
d722 1
a722 1
	return NULL;
@


1.5
log
@Update to xf86-input-mouse 1.7.1. ok shadchin@@
@
text
@d206 4
a209 1
    int buttons, i;
a280 1
    int c; 
d689 3
a691 1
	solarisMouseAutoProbe(pInfo, &pproto, &pdev);
@


1.4
log
@update to xf86-input-mouse 1.7.0

ok matthieu@@
@
text
@a214 7
    pMse->protocol = protocol;
    xf86Msg(X_CONFIG, "%s: Protocol: %s\n", pInfo->name, protocol);

    /* Collect the options, and process the common options. */
    COLLECT_INPUT_OPTIONS(pInfo, NULL);
    xf86ProcessCommonOptions(pInfo, pInfo->options);

a216 61

    /* Check if the device can be opened. */
    pInfo->fd = xf86OpenSerial(pInfo->options);
    if (pInfo->fd == -1) {
	if (xf86GetAllowMouseOpenFail()) {
	    xf86Msg(X_WARNING, "%s: cannot open input device\n", pInfo->name);
	} else {
	    xf86Msg(X_ERROR, "%s: cannot open input device\n", pInfo->name);
	    free(pVuidMse->strmod);
	    free(pVuidMse);
	    free(pMse);
	    return FALSE;
	}
    } else {
	if (pVuidMse->strmod) {
	    /* Check to see if module is already pushed */
	    SYSCALL(i = ioctl(pInfo->fd, I_FIND, pVuidMse->strmod));

	    if (i == 0) { /* Not already pushed */
		SYSCALL(i = ioctl(pInfo->fd, I_PUSH, pVuidMse->strmod));
		if (i < 0) {
		    xf86Msg(X_ERROR,
			"%s: cannot push module '%s' onto mouse device: %s\n",
			pInfo->name, pVuidMse->strmod, strerror(errno));
		    xf86CloseSerial(pInfo->fd);
		    pInfo->fd = -1;
		    free(pVuidMse->strmod);
		    free(pVuidMse);
		    free(pMse);
		    return FALSE;
		}
	    }
	}

	buttons = xf86SetIntOption(pInfo->options, "Buttons", 0);
	if (buttons == 0) {
	    SYSCALL(i = ioctl(pInfo->fd, MSIOBUTTONS, &buttons));
	    if (i == 0) {
		pInfo->options =
		    xf86ReplaceIntOption(pInfo->options,
					 "Buttons", buttons);
		xf86Msg(X_INFO, "%s: Setting Buttons option to \"%d\"\n",
			pInfo->name, buttons);
	    }
	}

	if (pVuidMse->strmod) {
	    SYSCALL(i = ioctl(pInfo->fd, I_POP, pVuidMse->strmod));
	    if (i == -1) {
		xf86Msg(X_WARNING,
			"%s: cannot pop module '%s' off mouse device: %s\n",
			pInfo->name, pVuidMse->strmod, strerror(errno));
	    }
	}

	xf86CloseSerial(pInfo->fd);
	pInfo->fd = -1;
    }

    /* Process common mouse options (like Emulate3Buttons, etc). */
    pMse->CommonOptions(pInfo);
@


1.3
log
@Update to xf86-input-mouse 1.6.0.
ok matthieu@@
@
text
@d57 1
a57 1
#include "xf86OSmouse.h"
d208 1
a208 1
    pVuidMse = xcalloc(sizeof(VuidMseRec), 1);
d211 1
a211 1
	xfree(pMse);
d219 1
a219 1
    xf86CollectInputOptions(pInfo, NULL, NULL);
d232 3
a234 3
	    xfree(pVuidMse->strmod);
	    xfree(pVuidMse);
	    xfree(pMse);
d250 3
a252 3
		    xfree(pVuidMse->strmod);
		    xfree(pVuidMse);
		    xfree(pMse);
d262 2
a263 2
		pInfo->conf_idev->commonOptions =
		    xf86ReplaceIntOption(pInfo->conf_idev->commonOptions,
d300 1
d302 1
a447 3
#if GET_ABI_MAJOR(ABI_XINPUT_VERSION) == 0
	    ptrCurScreen = miPointerCurrentScreen();
#else
a448 1
#endif	    
a512 4
#if GET_ABI_MAJOR(ABI_XINPUT_VERSION) == 0
      ptrCurScreen = miPointerCurrentScreen();
#endif
      
a513 1
#if GET_ABI_MAJOR(ABI_XINPUT_VERSION) >= 0
a514 1
#endif
d581 1
a581 1
			xfree(pVuidMse->strmod);
d681 1
a681 2
	    *device = xf86CheckStrOption(pInfo->conf_idev->commonOptions,
					 "Device", NULL);
d688 1
a688 2
	    strmod = xf86CheckStrOption(pInfo->conf_idev->commonOptions,
					"StreamsModule", NULL);
d747 2
a748 2
	    pInfo->conf_idev->commonOptions =
	     xf86AddNewOption(pInfo->conf_idev->commonOptions, "Device", pdev);
d753 1
a753 1
	pdev = xf86CheckStrOption(pInfo->conf_idev->commonOptions, 
d768 2
a769 2
	pInfo->conf_idev->commonOptions =
	  xf86AddNewOption(pInfo->conf_idev->commonOptions, "Device", pdev);
d783 2
a784 2
_X_EXPORT OSMouseInfoPtr
xf86OSMouseInit(int flags)
d788 1
a788 1
    p = xcalloc(sizeof(OSMouseInfoRec), 1);
@


1.2
log
@Update to xf86-input-mouse 1.5.0. Tested by many with xserver 1.8
ok oga@@, todd@@.
@
text
@d2 23
a48 27
/* Copyright 2004-2005, 2008-2009 Sun Microsystems, Inc.  All rights reserved.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, and/or sell copies of the Software, and to permit persons
 * to whom the Software is furnished to do so, provided that the above
 * copyright notice(s) and this permission notice appear in all copies of
 * the Software and that both the above copyright notice(s) and this
 * permission notice appear in supporting documentation.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT
 * OF THIRD PARTY RIGHTS. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
 * HOLDERS INCLUDED IN THIS NOTICE BE LIABLE FOR ANY CLAIM, OR ANY SPECIAL
 * INDIRECT OR CONSEQUENTIAL DAMAGES, OR ANY DAMAGES WHATSOEVER RESULTING
 * FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT,
 * NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION
 * WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 * 
 * Except as contained in this notice, the name of a copyright holder
 * shall not be used in advertising or otherwise to promote the sale, use
 * or other dealings in this Software without prior written authorization
 * of the copyright holder.
 */
d106 1
d119 4
d124 2
d144 12
a351 1
    XisbBlockDuration(pMse->buffer, -1);
d356 1
a356 3
	while (n < sizeof(Firm_event) && (c = XisbRead(pMse->buffer)) >= 0) {
	    pBuf[n++] = (unsigned char)c;
	}
d358 28
a385 4
	if (n == 0)
	    return;

	if (n != sizeof(Firm_event)) {
a454 5
	n = 0;
	if ((c = XisbRead(pMse->buffer)) >= 0) {
	    /* Another packet.  Handle it right away. */
	    pBuf[n++] = c;
	}
d472 3
d554 6
d606 7
d627 4
@


1.1
log
@update to xf86-input-mouse 1.4.0.
@
text
@d26 1
a26 1
/* Copyright 2004-2005 Sun Microsystems, Inc.  All rights reserved.
d207 3
d213 1
a213 1
	if (xf86GetAllowMouseOpenFail())
d215 1
a215 1
	else {
d217 1
d222 4
a225 1
    }
d227 15
a241 1
    pVuidMse->buffer = (unsigned char *)&pVuidMse->event;
d243 10
a252 13
    pVuidMse->strmod = xf86SetStrOption(pInfo->options, "StreamsModule", NULL);
    if (pVuidMse->strmod) {
	SYSCALL(i = ioctl(pInfo->fd, I_PUSH, pVuidMse->strmod));
 	if (i < 0) {
	    xf86Msg(X_ERROR,
		    "%s: cannot push module '%s' onto mouse device: %s\n",
		    pInfo->name, pVuidMse->strmod, strerror(errno));
	    xf86CloseSerial(pInfo->fd);
	    pInfo->fd = -1;
	    xfree(pVuidMse->strmod);
	    xfree(pVuidMse);
	    xfree(pMse);
	    return FALSE;
a253 1
    }
d255 7
a261 9
    buttons = xf86SetIntOption(pInfo->options, "Buttons", 0);
    if (buttons == 0) {
	SYSCALL(i = ioctl(pInfo->fd, MSIOBUTTONS, &buttons));
	if (i == 0) {
	    pInfo->conf_idev->commonOptions =
		xf86ReplaceIntOption(pInfo->conf_idev->commonOptions, 
				     "Buttons", buttons);
	    xf86Msg(X_INFO, "%s: Setting Buttons option to \"%d\"\n",
		    pInfo->name, buttons);
a262 1
    }
d264 2
a265 7
    if (pVuidMse->strmod) { 
	SYSCALL(i = ioctl(pInfo->fd, I_POP, pVuidMse->strmod));
	if (i == -1) {
	    xf86Msg(X_WARNING,
		    "%s: cannot pop module '%s' off mouse device: %s\n",
		    pInfo->name, pVuidMse->strmod, strerror(errno));
	}
a267 3
    xf86CloseSerial(pInfo->fd);
    pInfo->fd = -1;

d540 12
a551 7
		SYSCALL(i = ioctl(pInfo->fd, I_PUSH, pVuidMse->strmod));
		if (i < 0) {
		    xf86Msg(X_WARNING,
			"%s: cannot push module '%s' onto mouse device: %s\n",
			pInfo->name, pVuidMse->strmod, strerror(errno));
		    xfree(pVuidMse->strmod);
		    pVuidMse->strmod = NULL;
d554 1
@

