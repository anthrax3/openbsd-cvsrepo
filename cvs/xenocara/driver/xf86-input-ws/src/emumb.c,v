head	1.14;
access;
symbols
	OPENBSD_6_2:1.14.0.8
	OPENBSD_6_2_BASE:1.14
	OPENBSD_6_1:1.14.0.6
	OPENBSD_6_1_BASE:1.14
	OPENBSD_6_0:1.14.0.4
	OPENBSD_6_0_BASE:1.14
	OPENBSD_5_9:1.14.0.2
	OPENBSD_5_9_BASE:1.14
	OPENBSD_5_8:1.13.0.14
	OPENBSD_5_8_BASE:1.13
	OPENBSD_5_7:1.13.0.12
	OPENBSD_5_7_BASE:1.13
	OPENBSD_5_6:1.13.0.10
	OPENBSD_5_6_BASE:1.13
	OPENBSD_5_5:1.13.0.8
	OPENBSD_5_5_BASE:1.13
	OPENBSD_5_4:1.13.0.6
	OPENBSD_5_4_BASE:1.13
	OPENBSD_5_3:1.13.0.4
	OPENBSD_5_3_BASE:1.13
	OPENBSD_5_2:1.13.0.2
	OPENBSD_5_2_BASE:1.13
	OPENBSD_5_1_BASE:1.9
	OPENBSD_5_1:1.9.0.2
	OPENBSD_5_0:1.5.0.2
	OPENBSD_5_0_BASE:1.5
	OPENBSD_4_9:1.2.0.4
	OPENBSD_4_9_BASE:1.2
	OPENBSD_4_8:1.2.0.6
	OPENBSD_4_8_BASE:1.2
	OPENBSD_4_7:1.2.0.2
	OPENBSD_4_7_BASE:1.2;
locks; strict;
comment	@ * @;


1.14
date	2015.12.25.15.08.28;	author matthieu;	state Exp;
branches;
next	1.13;
commitid	QbRBUhJ8sj0rL66h;

1.13
date	2012.07.08.14.22.03;	author shadchin;	state Exp;
branches;
next	1.12;

1.12
date	2012.07.08.13.51.11;	author shadchin;	state Exp;
branches;
next	1.11;

1.11
date	2012.06.12.17.11.23;	author shadchin;	state Exp;
branches;
next	1.10;

1.10
date	2012.06.12.17.06.43;	author shadchin;	state Exp;
branches;
next	1.9;

1.9
date	2011.11.19.13.09.16;	author shadchin;	state Exp;
branches;
next	1.8;

1.8
date	2011.11.19.13.05.33;	author shadchin;	state Exp;
branches;
next	1.7;

1.7
date	2011.11.19.12.36.16;	author shadchin;	state Exp;
branches;
next	1.6;

1.6
date	2011.11.07.18.33.04;	author shadchin;	state Exp;
branches;
next	1.5;

1.5
date	2011.07.17.13.08.38;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2011.05.08.10.38.13;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2011.04.24.15.55.12;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2009.11.26.18.18.34;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2009.11.26.16.42.06;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.14
log
@Explicitely include <sys/time.h> where needed.
From pkgsrc (Takahiro Kambe) via Thomas Klausner. Thanks
@
text
@/*	$OpenBSD: emumb.c,v 1.13 2012/07/08 14:22:03 shadchin Exp $ */
/*
 * Copyright 1990,91 by Thomas Roell, Dinkelscherben, Germany.
 * Copyright 1993 by David Dawes <dawes@@xfree86.org>
 * Copyright 2002 by SuSE Linux AG, Author: Egbert Eich
 * Copyright 1994-2002 by The XFree86 Project, Inc.
 * Copyright 2002 by Paul Elliott
 * (Ported from xf86-input-mouse, above copyrights taken from there)
 * Copyright © 2008 University of South Australia
 * Copyright © 2009 Matthieu Herrb <matthieu@@herrb.eu>
 *
 * Permission to use, copy, modify, distribute, and sell this software
 * and its documentation for any purpose is hereby granted without
 * fee, provided that the above copyright notice appear in all copies
 * and that both that copyright notice and this permission notice
 * appear in supporting documentation, and that the name of the authors
 * not be used in advertising or publicity pertaining to distribution of the
 * software without specific, written prior permission.  The authors make no
 * representations about the suitability of this software for any
 * purpose.  It is provided "as is" without express or implied
 * warranty.
 *
 * THE AUTHORS DISCLAIM ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
 * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN
 * NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY SPECIAL, INDIRECT OR
 * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS
 * OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT,
 * NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
 * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 *
 */

/* Middle mouse button emulation code. */

#ifdef HAVE_CONFIG_H
#include "config.h"
#endif

#include <sys/time.h>

#include <xorg-server.h>
#include <X11/Xatom.h>
#include <xf86.h>
#include <xf86_OSproc.h>
#include <X11/extensions/XI.h>
#include <X11/extensions/XIproto.h>
#include <xf86Xinput.h>
#include <exevents.h>

#include <ws-properties.h>
#include "ws.h"

enum {
	MBEMU_DISABLED = 0,
	MBEMU_ENABLED,
	MBEMU_AUTO
};

static Atom prop_mbemu;		/* Middle button emulation on/off property */
static Atom prop_mbtimeout;	/* Middle button timeout property */

/*
 * Lets create a simple finite-state machine for 3 button emulation:
 *
 * We track buttons 1 and 3 (left and right).  There are 11 states:
 *   0 ground           - initial state
 *   1 delayed left     - left pressed, waiting for right
 *   2 delayed right    - right pressed, waiting for left
 *   3 pressed middle   - right and left pressed, emulated middle sent
 *   4 pressed left     - left pressed and sent
 *   5 pressed right    - right pressed and sent
 *   6 released left    - left released after emulated middle
 *   7 released right   - right released after emulated middle
 *   8 repressed left   - left pressed after released left
 *   9 repressed right  - right pressed after released right
 *  10 pressed both     - both pressed, not emulating middle
 *
 * At each state, we need handlers for the following events
 *   0: no buttons down
 *   1: left button down
 *   2: right button down
 *   3: both buttons down
 *   4: emulate3Timeout passed without a button change
 * Note that button events are not deltas, they are the set of buttons being
 * pressed now.  It's possible (ie, mouse hardware does it) to go from (eg)
 * left down to right down without anything in between, so all cases must be
 * handled.
 *
 * a handler consists of three values:
 *   0: action1
 *   1: action2
 *   2: new emulation state
 *
 * action > 0: ButtonPress
 * action = 0: nothing
 * action < 0: ButtonRelease
 *
 * The comment preceeding each section is the current emulation state.
 * The comments to the right are of the form
 *      <button state> (<events>) -> <new emulation state>
 * which should be read as
 *      If the buttons are in <button state>, generate <events> then go to
 *      <new emulation state>.
 */
static signed char stateTab[11][5][3] = {
/* 0 ground */
  {
    {  0,  0,  0 },   /* nothing -> ground (no change) */
    {  0,  0,  1 },   /* left -> delayed left */
    {  0,  0,  2 },   /* right -> delayed right */
    {  2,  0,  3 },   /* left & right (middle press) -> pressed middle */
    {  0,  0, -1 }    /* timeout N/A */
  },
/* 1 delayed left */
  {
    {  1, -1,  0 },   /* nothing (left event) -> ground */
    {  0,  0,  1 },   /* left -> delayed left (no change) */
    {  1, -1,  2 },   /* right (left event) -> delayed right */
    {  2,  0,  3 },   /* left & right (middle press) -> pressed middle */
    {  1,  0,  4 },   /* timeout (left press) -> pressed left */
  },
/* 2 delayed right */
  {
    {  3, -3,  0 },   /* nothing (right event) -> ground */
    {  3, -3,  1 },   /* left (right event) -> delayed left (no change) */
    {  0,  0,  2 },   /* right -> delayed right (no change) */
    {  2,  0,  3 },   /* left & right (middle press) -> pressed middle */
    {  3,  0,  5 },   /* timeout (right press) -> pressed right */
  },
/* 3 pressed middle */
  {
    { -2,  0,  0 },   /* nothing (middle release) -> ground */
    {  0,  0,  7 },   /* left -> released right */
    {  0,  0,  6 },   /* right -> released left */
    {  0,  0,  3 },   /* left & right -> pressed middle (no change) */
    {  0,  0, -1 },   /* timeout N/A */
  },
/* 4 pressed left */
  {
    { -1,  0,  0 },   /* nothing (left release) -> ground */
    {  0,  0,  4 },   /* left -> pressed left (no change) */
    { -1,  0,  2 },   /* right (left release) -> delayed right */
    {  3,  0, 10 },   /* left & right (right press) -> pressed both */
    {  0,  0, -1 },   /* timeout N/A */
  },
/* 5 pressed right */
  {
    { -3,  0,  0 },   /* nothing (right release) -> ground */
    { -3,  0,  1 },   /* left (right release) -> delayed left */
    {  0,  0,  5 },   /* right -> pressed right (no change) */
    {  1,  0, 10 },   /* left & right (left press) -> pressed both */
    {  0,  0, -1 },   /* timeout N/A */
  },
/* 6 released left */
  {
    { -2,  0,  0 },   /* nothing (middle release) -> ground */
    { -2,  0,  1 },   /* left (middle release) -> delayed left */
    {  0,  0,  6 },   /* right -> released left (no change) */
    {  1,  0,  8 },   /* left & right (left press) -> repressed left */
    {  0,  0, -1 },   /* timeout N/A */
  },
/* 7 released right */
  {
    { -2,  0,  0 },   /* nothing (middle release) -> ground */
    {  0,  0,  7 },   /* left -> released right (no change) */
    { -2,  0,  2 },   /* right (middle release) -> delayed right */
    {  3,  0,  9 },   /* left & right (right press) -> repressed right */
    {  0,  0, -1 },   /* timeout N/A */
  },
/* 8 repressed left */
  {
    { -2, -1,  0 },   /* nothing (middle release, left release) -> ground */
    { -2,  0,  4 },   /* left (middle release) -> pressed left */
    { -1,  0,  6 },   /* right (left release) -> released left */
    {  0,  0,  8 },   /* left & right -> repressed left (no change) */
    {  0,  0, -1 },   /* timeout N/A */
  },
/* 9 repressed right */
  {
    { -2, -3,  0 },   /* nothing (middle release, right release) -> ground */
    { -3,  0,  7 },   /* left (right release) -> released right */
    { -2,  0,  5 },   /* right (middle release) -> pressed right */
    {  0,  0,  9 },   /* left & right -> repressed right (no change) */
    {  0,  0, -1 },   /* timeout N/A */
  },
/* 10 pressed both */
  {
    { -1, -3,  0 },   /* nothing (left release, right release) -> ground */
    { -3,  0,  4 },   /* left (right release) -> pressed left */
    { -1,  0,  5 },   /* right (left release) -> pressed right */
    {  0,  0, 10 },   /* left & right -> pressed both (no change) */
    {  0,  0, -1 },   /* timeout N/A */
  },
};

int
wsmbEmuTimer(InputInfoPtr pInfo)
{
	WSDevicePtr priv = (WSDevicePtr)pInfo->private;
	int sigstate;
	int id;

	sigstate = xf86BlockSIGIO();

	priv->emulateMB.pending = FALSE;
	if ((id = stateTab[priv->emulateMB.state][4][0]) != 0) {
		xf86PostButtonEvent(pInfo->dev, 0, abs(id), (id >= 0), 0, 0);
		priv->emulateMB.state = stateTab[priv->emulateMB.state][4][2];
	} else {
		xf86IDrvMsg(pInfo, X_ERROR,
		    "Got unexpected buttonTimer in state %d\n",
		    priv->emulateMB.state);
	}

	xf86UnblockSIGIO(sigstate);
	return 0;
}

/**
 * Emulate a middle button on button press.
 *
 * @@param code button number (1 for left, 3 for right)
 * @@param press TRUE if press, FALSE if release.
 *
 * @@return TRUE if event was swallowed by middle mouse button emulation, FALSE
 * otherwise.
 */
BOOL
wsmbEmuFilterEvent(InputInfoPtr pInfo, int button, BOOL press)
{
	WSDevicePtr priv = (WSDevicePtr)pInfo->private;
	int id;
	int *btstate;
	int ret = FALSE;

	if (!priv->emulateMB.enabled)
		return ret;

	/* Disable emulation when middle button event is detected */
	if (button == 2 && priv->emulateMB.enabled == MBEMU_AUTO) {
		priv->emulateMB.enabled = FALSE;
		return ret;
	}

	/* don't care about other buttons */
	if (button != 1 && button != 3)
		return ret;

	btstate = &priv->emulateMB.buttonstate;
	if (press)
		*btstate |= (button == 1) ? 0x1 : 0x2;
	else
		*btstate &= (button == 1) ? ~0x1 : ~0x2;

	if ((id = stateTab[priv->emulateMB.state][*btstate][0]) != 0) {
		xf86PostButtonEvent(pInfo->dev, 0, abs(id), (id >= 0), 0, 0);
		ret = TRUE;
	}
	if ((id = stateTab[priv->emulateMB.state][*btstate][1]) != 0) {
		xf86PostButtonEvent(pInfo->dev, 0, abs(id), (id >= 0), 0, 0);
		ret = TRUE;
	}

	priv->emulateMB.state = stateTab[priv->emulateMB.state][*btstate][2];

	if (stateTab[priv->emulateMB.state][4][0] != 0) {
		priv->emulateMB.expires = GetTimeInMillis()
		    + priv->emulateMB.timeout;
		priv->emulateMB.pending = TRUE;
		ret = TRUE;
	} else {
		priv->emulateMB.pending = FALSE;
	}
	return ret;
}

void
wsmbEmuWakeupHandler(pointer data, int i, pointer LastSelectMask)
{
	InputInfoPtr pInfo = (InputInfoPtr)data;
	WSDevicePtr priv = (WSDevicePtr)pInfo->private;
	int ms;

	if (priv->emulateMB.pending) {
		ms = priv->emulateMB.expires - GetTimeInMillis();
		if (ms <= 0)
			wsmbEmuTimer(pInfo);
	}
}

void
wsmbEmuBlockHandler(pointer data, struct timeval **waitTime,
    pointer LastSelectMask)
{
	InputInfoPtr pInfo = (InputInfoPtr)data;
	WSDevicePtr priv = (WSDevicePtr)pInfo->private;
	int ms;

	if (priv->emulateMB.pending) {
		ms = priv->emulateMB.expires - GetTimeInMillis();
		if (ms <= 0)
			ms = 0;
		AdjustWaitForDelay(waitTime, ms);
	}
}

void
wsmbEmuPreInit(InputInfoPtr pInfo)
{
	WSDevicePtr priv = (WSDevicePtr)pInfo->private;
	int timeout;

	DBG(1, ErrorF("wsmbEmuPreInit\n"));

	priv->emulateMB.enabled = MBEMU_AUTO;
	if (xf86FindOption(pInfo->options, "Emulate3Buttons")) {
		priv->emulateMB.enabled = xf86SetBoolOption(pInfo->options,
		    "Emulate3Buttons",
		    MBEMU_ENABLED);
		xf86IDrvMsg(pInfo, X_INFO, "Forcing middle mouse button "
		    "emulation %s.\n",
		    (priv->emulateMB.enabled) ? "on" : "off");
	}

	timeout = xf86SetIntOption(pInfo->options, "Emulate3Timeout", 50);
	if (timeout < 0) {
		xf86IDrvMsg(pInfo, X_WARNING,
		    "Invalid Emulate3Timeout value: %d\n", timeout);
		xf86IDrvMsg(pInfo, X_WARNING, "Using built-in timeout value\n");
		timeout = 50;
	}
	priv->emulateMB.timeout = timeout;
}

void
wsmbEmuOn(InputInfoPtr pInfo)
{
	RegisterBlockAndWakeupHandlers(wsmbEmuBlockHandler,
	    wsmbEmuWakeupHandler, (pointer)pInfo);
}

void
wsmbEmuFinalize(InputInfoPtr pInfo)
{
	RemoveBlockAndWakeupHandlers(wsmbEmuBlockHandler,
	    wsmbEmuWakeupHandler, (pointer)pInfo);
}

static int
wsmbEmuSetProperty(DeviceIntPtr dev, Atom atom, XIPropertyValuePtr val,
    BOOL checkonly)
{
	InputInfoPtr pInfo = (InputInfoPtr)dev->public.devicePrivate;
	WSDevicePtr priv = (WSDevicePtr)pInfo->private;

	DBG(1, ErrorF("wsmbEmuSetProperty %s\n", NameForAtom(atom)));

	if (atom == prop_mbemu) {
		if (val->format != 8 || val->size != 1 ||
		    val->type != XA_INTEGER)
			return BadMatch;

		if (!checkonly)
			priv->emulateMB.enabled = *((BOOL*)val->data);
	} else if (atom == prop_mbtimeout) {
		int timeout;

		if (val->format != 32 || val->size != 1 ||
		    val->type != XA_INTEGER)
			return BadMatch;

		timeout = *((CARD32*)val->data);

		if (timeout < 0)
			return BadValue;

		if (!checkonly)
			priv->emulateMB.timeout = timeout;
	}

	return Success;
}

/**
 * Initialise property for MB emulation on/off.
 */
void
wsmbEmuInitProperty(DeviceIntPtr dev)
{
	InputInfoPtr pInfo = (InputInfoPtr)dev->public.devicePrivate;
	WSDevicePtr priv = (WSDevicePtr)pInfo->private;
	int rc;

	DBG(1, ErrorF("wsmbEmuInitProperty\n"));

	prop_mbemu = MakeAtom(WS_PROP_MIDBUTTON,
	    strlen(WS_PROP_MIDBUTTON), TRUE);
	rc = XIChangeDeviceProperty(dev, prop_mbemu, XA_INTEGER, 8,
	    PropModeReplace, 1, &priv->emulateMB.enabled, FALSE);
	if (rc != Success) {
		xf86IDrvMsg(pInfo, X_ERROR,
		    "cannot create device property %s: %d\n",
		    WS_PROP_MIDBUTTON, rc);
		return;
	}
	XISetDevicePropertyDeletable(dev, prop_mbemu, FALSE);

	prop_mbtimeout = MakeAtom(WS_PROP_MIDBUTTON_TIMEOUT,
	    strlen(WS_PROP_MIDBUTTON_TIMEOUT), TRUE);
	rc = XIChangeDeviceProperty(dev, prop_mbtimeout, XA_INTEGER, 32,
	    PropModeReplace, 1, &priv->emulateMB.timeout, FALSE);
	if (rc != Success) {
		xf86IDrvMsg(pInfo, X_ERROR,
		    "cannot create device property %s: %d\n",
		    WS_PROP_MIDBUTTON_TIMEOUT, rc);
		return;
	}
	XISetDevicePropertyDeletable(dev, prop_mbtimeout, FALSE);

	XIRegisterPropertyHandler(dev, wsmbEmuSetProperty, NULL, NULL);
}
@


1.13
log
@two nits missing in previous commit
@
text
@d1 1
a1 1
/*	$OpenBSD: emumb.c,v 1.12 2012/07/08 13:51:11 shadchin Exp $ */
d38 2
@


1.12
log
@Cleanup and uniform style. No functional changes.
@
text
@d1 1
a1 1
/*	$OpenBSD: emumb.c,v 1.11 2012/06/12 17:11:23 shadchin Exp $ */
d294 1
a294 1
	WSDevicePtr priv= (WSDevicePtr)pInfo->private;
@


1.11
log
@Small cleanup

ok matthieu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: emumb.c,v 1.10 2012/06/12 17:06:43 shadchin Exp $ */
d197 1
a197 1
	WSDevicePtr priv = pInfo->private;
d206 1
a206 2
		priv->emulateMB.state =
		    stateTab[priv->emulateMB.state][4][2];
d229 1
a229 1
	WSDevicePtr priv = pInfo->private;
d276 1
a276 3
wsmbEmuWakeupHandler(pointer data,
    int i,
    pointer LastSelectMask)
d290 1
a290 2
wsmbEmuBlockHandler(pointer data,
    struct timeval **waitTime,
d293 2
a294 2
	InputInfoPtr pInfo = (InputInfoPtr) data;
	WSDevicePtr priv= (WSDevicePtr) pInfo->private;
d351 2
a352 2
	InputInfoPtr pInfo  = dev->public.devicePrivate;
	WSDevicePtr priv = pInfo->private;
d388 2
a389 2
	InputInfoPtr pInfo  = dev->public.devicePrivate;
	WSDevicePtr priv = pInfo->private;
@


1.10
log
@Use xf86IDrvMsg in emumb.c instead of ErrorF

ok matthieu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: emumb.c,v 1.9 2011/11/19 13:09:16 shadchin Exp $ */
a397 3
	if (!dev->button) /* don't init prop for keyboards */
		return;

d411 3
a413 6
	    strlen(WS_PROP_MIDBUTTON_TIMEOUT),
	    TRUE);
	rc = XIChangeDeviceProperty(dev, prop_mbtimeout,
	    XA_INTEGER, 32, PropModeReplace, 1,
	    &priv->emulateMB.timeout, FALSE);

@


1.9
log
@Simplify middle button emulation code.

ok matthieu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: emumb.c,v 1.8 2011/11/19 13:05:33 shadchin Exp $ */
d209 2
a210 1
		ErrorF("Got unexpected buttonTimer in state %d\n",
@


1.8
log
@Add check emulateMB.timeout >= 0.

ok matthieu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: emumb.c,v 1.7 2011/11/19 12:36:16 shadchin Exp $ */
d237 3
a239 2
	if (button == 2) {
		wsmbEmuEnable(pInfo, FALSE);
a347 11

}

/* Enable/disable middle mouse button emulation. */
void
wsmbEmuEnable(InputInfoPtr pInfo, BOOL enable)
{
	WSDevicePtr priv = (WSDevicePtr)pInfo->private;

	if (priv->emulateMB.enabled == MBEMU_AUTO)
		priv->emulateMB.enabled = enable;
@


1.7
log
@Static atoms don't need to be initialized to 0.

ok matthieu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: emumb.c,v 1.6 2011/11/07 18:33:04 shadchin Exp $ */
d311 1
a311 1
	priv->emulateMB.enabled = MBEMU_AUTO;
d314 2
d325 8
a332 2
	priv->emulateMB.timeout = xf86SetIntOption(pInfo->options,
	    "Emulate3Timeout", 50);
d362 1
a362 1
                      BOOL checkonly)
d377 2
d383 5
d389 1
a389 1
			priv->emulateMB.timeout = *((CARD32*)val->data);
@


1.6
log
@Replace xf86Msg on xf86IDrvMsg.
The latter provides a standardised message format in the form of
    driver name: device name: message

ok matthieu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: emumb.c,v 1.5 2011/07/17 13:08:38 matthieu Exp $ */
d57 2
a58 2
static Atom prop_mbemu     = 0; /* Middle button emulation on/off property */
static Atom prop_mbtimeout = 0; /* Middle button timeout property */
a193 1

a216 1

a273 1

a350 1

@


1.5
log
@Unifdef support for xinput ABI up to 10.
@
text
@d1 1
a1 1
/*	$OpenBSD: emumb.c,v 1.4 2011/05/08 10:38:13 matthieu Exp $ */
d321 1
a321 1
		xf86Msg(X_INFO, "%s: Forcing middle mouse button "
d323 1
a323 1
		    pInfo->name, (priv->emulateMB.enabled) ? "on" : "off");
d404 2
a405 1
		xf86Msg(X_ERROR, "cannot create device property %s: %d\n",
d419 3
a421 2
		xf86Msg(X_ERROR, "cannot create device property %s\n",
		WS_PROP_MIDBUTTON_TIMEOUT);
@


1.4
log
@fix xf86-input-ws on xserver 1.9 and earlier.
<xorg-server.h> is needed to get the proper Xinput ABI definition from
other headers.
@
text
@d1 1
a1 1
/*	$OpenBSD: emumb.c,v 1.3 2011/04/24 15:55:12 matthieu Exp $ */
a56 1
#ifdef HAVE_PROPERTIES
d59 1
a59 1
#endif
a355 1
#ifdef HAVE_PROPERTIES
a425 1
#endif
@


1.3
log
@xf86-input-ws 1.3.0:
- API compatibility with Xserver 1.10
- sync build system with other Xorg input modules
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d39 1
@


1.2
log
@white space
@
text
@d1 1
a1 1
/*	$OpenBSD: emumb.c,v 1.1 2009/11/26 16:42:06 matthieu Exp $ */
@


1.1
log
@Add middle mouse button emulation to xf86-input-ws.
Code stolen from evdev, that stole it from xf86-input mouse.
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d199 1
a199 1
	int	sigstate;
d201 3
a203 3
	
	sigstate = xf86BlockSIGIO ();
	
d213 2
a214 2
	
	xf86UnblockSIGIO (sigstate);
d235 1
a235 1
	
d238 1
a238 1
	
d243 1
a243 1
	
d247 1
a247 1
	
d253 1
a253 1
	
d262 1
a262 1
	
d264 1
a264 1
	
d266 1
a266 1
		priv->emulateMB.expires = GetTimeInMillis() 
d277 1
a277 1
void 
d283 1
a283 1
	WSDevicePtr     priv = (WSDevicePtr)pInfo->private;
d285 1
a285 1
	
d293 1
a293 1
void 
d298 4
a301 4
	InputInfoPtr    pInfo = (InputInfoPtr) data;
	WSDevicePtr        priv= (WSDevicePtr) pInfo->private;
	int             ms;
	
d306 1
a306 1
		AdjustWaitForDelay (waitTime, ms);
d315 1
a315 1
	
d325 1
a325 1
	
d342 1
a342 1
	
d362 2
a363 2
	WSDevicePtr     priv = pInfo->private;
	
d367 1
a367 1
		if (val->format != 8 || val->size != 1 || 
d370 1
a370 1
		
d374 1
a374 1
		if (val->format != 32 || val->size != 1 || 
d377 1
a377 1
		
d381 1
a381 1
	
d392 2
a393 2
	WSDevicePtr     priv = pInfo->private;
	int          rc;
d399 2
a400 2
	
	prop_mbemu = MakeAtom(WS_PROP_MIDBUTTON, 
d410 1
a410 1
	
d414 1
a414 1
	rc = XIChangeDeviceProperty(dev, prop_mbtimeout, 
d417 1
a417 1
	
d424 1
a424 1
	
@

