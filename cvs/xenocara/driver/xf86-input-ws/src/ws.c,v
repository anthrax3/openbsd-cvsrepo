head	1.62;
access;
symbols
	OPENBSD_6_1:1.62.0.6
	OPENBSD_6_1_BASE:1.62
	OPENBSD_6_0:1.62.0.4
	OPENBSD_6_0_BASE:1.62
	OPENBSD_5_9:1.62.0.2
	OPENBSD_5_9_BASE:1.62
	OPENBSD_5_8:1.61.0.4
	OPENBSD_5_8_BASE:1.61
	OPENBSD_5_7:1.61.0.2
	OPENBSD_5_7_BASE:1.61
	OPENBSD_5_6:1.60.0.4
	OPENBSD_5_6_BASE:1.60
	OPENBSD_5_5:1.60.0.2
	OPENBSD_5_5_BASE:1.60
	OPENBSD_5_4:1.58.0.2
	OPENBSD_5_4_BASE:1.58
	OPENBSD_5_3:1.57.0.4
	OPENBSD_5_3_BASE:1.57
	OPENBSD_5_2:1.57.0.2
	OPENBSD_5_2_BASE:1.57
	OPENBSD_5_1_BASE:1.51
	OPENBSD_5_1:1.51.0.2
	OPENBSD_5_0:1.33.0.2
	OPENBSD_5_0_BASE:1.33
	OPENBSD_4_9:1.31.0.4
	OPENBSD_4_9_BASE:1.31
	OPENBSD_4_8:1.31.0.6
	OPENBSD_4_8_BASE:1.31
	OPENBSD_4_7:1.31.0.2
	OPENBSD_4_7_BASE:1.31
	v1_2:1.1.1.1
	OPENBSD:1.1.1;
locks; strict;
comment	@ * @;


1.62
date	2015.08.29.08.48.29;	author shadchin;	state Exp;
branches;
next	1.61;
commitid	4W0lev75KAkLAmy0;

1.61
date	2015.02.17.08.21.14;	author matthieu;	state Exp;
branches;
next	1.60;
commitid	d45yn324q3UMjqYE;

1.60
date	2013.11.02.13.17.32;	author shadchin;	state Exp;
branches;
next	1.59;

1.59
date	2013.10.30.18.05.34;	author shadchin;	state Exp;
branches;
next	1.58;

1.58
date	2013.07.20.13.24.50;	author matthieu;	state Exp;
branches;
next	1.57;

1.57
date	2012.07.08.14.22.03;	author shadchin;	state Exp;
branches;
next	1.56;

1.56
date	2012.07.08.13.51.11;	author shadchin;	state Exp;
branches;
next	1.55;

1.55
date	2012.06.12.17.59.01;	author shadchin;	state Exp;
branches;
next	1.54;

1.54
date	2012.06.12.17.12.50;	author shadchin;	state Exp;
branches;
next	1.53;

1.53
date	2012.06.12.17.10.03;	author shadchin;	state Exp;
branches;
next	1.52;

1.52
date	2012.06.12.17.04.43;	author shadchin;	state Exp;
branches;
next	1.51;

1.51
date	2011.12.29.13.48.05;	author matthieu;	state Exp;
branches;
next	1.50;

1.50
date	2011.11.28.23.49.59;	author shadchin;	state Exp;
branches;
next	1.49;

1.49
date	2011.11.19.13.12.49;	author shadchin;	state Exp;
branches;
next	1.48;

1.48
date	2011.11.19.12.46.08;	author shadchin;	state Exp;
branches;
next	1.47;

1.47
date	2011.11.19.12.36.16;	author shadchin;	state Exp;
branches;
next	1.46;

1.46
date	2011.11.09.16.17.44;	author shadchin;	state Exp;
branches;
next	1.45;

1.45
date	2011.11.09.16.08.42;	author shadchin;	state Exp;
branches;
next	1.44;

1.44
date	2011.11.09.16.07.13;	author shadchin;	state Exp;
branches;
next	1.43;

1.43
date	2011.11.09.16.04.50;	author shadchin;	state Exp;
branches;
next	1.42;

1.42
date	2011.11.08.12.57.44;	author shadchin;	state Exp;
branches;
next	1.41;

1.41
date	2011.11.08.12.55.26;	author shadchin;	state Exp;
branches;
next	1.40;

1.40
date	2011.11.08.12.53.14;	author shadchin;	state Exp;
branches;
next	1.39;

1.39
date	2011.11.08.12.51.32;	author shadchin;	state Exp;
branches;
next	1.38;

1.38
date	2011.11.07.18.42.32;	author shadchin;	state Exp;
branches;
next	1.37;

1.37
date	2011.11.07.18.36.53;	author shadchin;	state Exp;
branches;
next	1.36;

1.36
date	2011.11.07.18.33.04;	author shadchin;	state Exp;
branches;
next	1.35;

1.35
date	2011.11.06.16.20.27;	author shadchin;	state Exp;
branches;
next	1.34;

1.34
date	2011.10.16.17.54.07;	author shadchin;	state Exp;
branches;
next	1.33;

1.33
date	2011.07.16.17.51.30;	author matthieu;	state Exp;
branches;
next	1.32;

1.32
date	2011.04.24.15.55.12;	author matthieu;	state Exp;
branches;
next	1.31;

1.31
date	2010.01.10.16.33.44;	author matthieu;	state Exp;
branches;
next	1.30;

1.30
date	2010.01.10.15.22.47;	author matthieu;	state Exp;
branches;
next	1.29;

1.29
date	2009.12.31.18.01.14;	author matthieu;	state Exp;
branches;
next	1.28;

1.28
date	2009.12.10.22.32.02;	author matthieu;	state Exp;
branches;
next	1.27;

1.27
date	2009.12.06.10.32.31;	author matthieu;	state Exp;
branches;
next	1.26;

1.26
date	2009.11.26.18.18.34;	author matthieu;	state Exp;
branches;
next	1.25;

1.25
date	2009.11.26.16.42.06;	author matthieu;	state Exp;
branches;
next	1.24;

1.24
date	2009.11.26.10.57.35;	author matthieu;	state Exp;
branches;
next	1.23;

1.23
date	2009.11.25.19.36.57;	author matthieu;	state Exp;
branches;
next	1.22;

1.22
date	2009.11.25.19.31.35;	author matthieu;	state Exp;
branches;
next	1.21;

1.21
date	2009.11.25.19.11.55;	author matthieu;	state Exp;
branches;
next	1.20;

1.20
date	2009.11.25.18.14.23;	author matthieu;	state Exp;
branches;
next	1.19;

1.19
date	2009.11.25.18.10.26;	author matthieu;	state Exp;
branches;
next	1.18;

1.18
date	2009.11.25.18.03.42;	author matthieu;	state Exp;
branches;
next	1.17;

1.17
date	2009.11.25.17.59.42;	author matthieu;	state Exp;
branches;
next	1.16;

1.16
date	2009.11.23.22.10.29;	author matthieu;	state Exp;
branches;
next	1.15;

1.15
date	2009.11.23.21.11.27;	author matthieu;	state Exp;
branches;
next	1.14;

1.14
date	2009.11.23.18.29.13;	author matthieu;	state Exp;
branches;
next	1.13;

1.13
date	2009.11.23.17.36.23;	author matthieu;	state Exp;
branches;
next	1.12;

1.12
date	2009.11.23.16.55.52;	author matthieu;	state Exp;
branches;
next	1.11;

1.11
date	2009.11.23.16.21.50;	author matthieu;	state Exp;
branches;
next	1.10;

1.10
date	2009.11.23.15.25.11;	author matthieu;	state Exp;
branches;
next	1.9;

1.9
date	2009.11.23.15.16.52;	author matthieu;	state Exp;
branches;
next	1.8;

1.8
date	2009.11.23.14.00.17;	author matthieu;	state Exp;
branches;
next	1.7;

1.7
date	2009.11.23.12.54.04;	author matthieu;	state Exp;
branches;
next	1.6;

1.6
date	2009.11.23.12.37.32;	author matthieu;	state Exp;
branches;
next	1.5;

1.5
date	2009.11.23.12.35.40;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2009.11.22.23.00.43;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2009.11.22.22.08.57;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2009.11.22.19.26.48;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2009.11.22.19.13.10;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2009.11.22.19.13.10;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.62
log
@Read multiple events at once.

Before:
Both drivers currently do one read(2) per event, but since we use a
"sync" event we have a least two of them for ws(4) but more commonly
3 for ws(4) and 4 for synaptics(4).

most of the code and ok mpi@@
@
text
@/*
 * Copyright Â© 2005-2009,2011 Matthieu Herrb
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */
/* $OpenBSD: ws.c,v 1.61 2015/02/17 08:21:14 matthieu Exp $ */

#ifdef HAVE_CONFIG_H
#include "config.h"
#endif

#include <unistd.h>
#include <errno.h>
#include <sys/ioctl.h>
#include <sys/time.h>
#include <dev/wscons/wsconsio.h>

#include <xorg-server.h>
#include <xf86.h>
#include <xf86_OSproc.h>
#include <X11/extensions/XI.h>
#include <X11/extensions/XIproto.h>
#include <xf86Xinput.h>
#include <exevents.h>
#include <mipointer.h>
#include <extinit.h>

#include "ws.h"

#include <X11/Xatom.h>
#include "ws-properties.h"
#include <xserver-properties.h>

static MODULESETUPPROTO(SetupProc);
static MODULETEARDOWNPROTO(TearDownProc);

static int wsPreInit(InputDriverPtr, InputInfoPtr, int);
static void wsUnInit(InputDriverPtr, InputInfoPtr, int);
static int wsProc(DeviceIntPtr, int);
static int wsDeviceInit(DeviceIntPtr);
static int wsDeviceOn(DeviceIntPtr);
static void wsDeviceOff(DeviceIntPtr);
static void wsReadInput(InputInfoPtr);
static void wsSendButtons(InputInfoPtr, int);
static int wsSwitchMode(ClientPtr, DeviceIntPtr, int);
static Bool wsOpen(InputInfoPtr);
static void wsClose(InputInfoPtr);
static void wsControlProc(DeviceIntPtr , PtrCtrl *);

static void wsInitCalibProperty(DeviceIntPtr);
static int wsSetCalibProperty(DeviceIntPtr, Atom, XIPropertyValuePtr, BOOL);

static Atom prop_calibration;
static Atom prop_swap;

#ifdef DEBUG
int ws_debug_level = 0;
#endif

static XF86ModuleVersionInfo VersionRec = {
	"ws",
	MODULEVENDORSTRING,
	MODINFOSTRING1,
	MODINFOSTRING2,
	XORG_VERSION_CURRENT,
	PACKAGE_VERSION_MAJOR,
	PACKAGE_VERSION_MINOR,
	PACKAGE_VERSION_PATCHLEVEL,
	ABI_CLASS_XINPUT,
	ABI_XINPUT_VERSION,
	MOD_CLASS_XINPUT,
	{0, 0, 0, 0}
};

_X_EXPORT XF86ModuleData wsModuleData = {
	&VersionRec,
	SetupProc,
	TearDownProc
};

_X_EXPORT InputDriverRec WS = {
	1,
	"ws",
	NULL,
	wsPreInit,
	wsUnInit,
	NULL,
	0
};

static pointer
SetupProc(pointer module, pointer options, int *errmaj, int *errmin)
{
	static Bool Initialised = FALSE;

	if (!Initialised) {
		xf86AddInputDriver(&WS, module, 0);
		Initialised = TRUE;
	}
	return module;
}

static void
TearDownProc(pointer p)
{
	DBG(1, ErrorF("WS TearDownProc called\n"));
}

static int
wsPreInit(InputDriverPtr drv, InputInfoPtr pInfo, int flags)
{
	WSDevicePtr priv;
	MessageType buttons_from = X_CONFIG;
	char *s;
	int i, phy_btn = 1, rc = BadValue;

	priv = (WSDevicePtr)calloc(1, sizeof(WSDeviceRec));
	if (priv == NULL) {
		rc = BadAlloc;
		goto fail;
	}
	pInfo->private = priv;

#ifdef DEBUG
	ws_debug_level = xf86SetIntOption(pInfo->options, "DebugLevel",
	    ws_debug_level);
	xf86IDrvMsg(pInfo, X_INFO, "debuglevel %d\n", ws_debug_level);
#endif
	priv->devName = xf86SetStrOption(pInfo->options, "Device", NULL);
	if (priv->devName == NULL) {
		xf86IDrvMsg(pInfo, X_ERROR, "No Device specified.\n");
		goto fail;
	}
	priv->buttons = xf86SetIntOption(pInfo->options, "Buttons", 0);
	if (priv->buttons == 0) {
		priv->buttons = DFLTBUTTONS;
		buttons_from = X_DEFAULT;
	}

	/* Check for user-defined button mapping */
	s = xf86SetStrOption(pInfo->options, "ButtonMapping", NULL);
	if (s) {
		char *map = s, *end;
		int btn;

		do {
			btn = strtol(map, &end, 10);

			if (end == map || btn < 0 || btn > NBUTTONS) {
				xf86IDrvMsg(pInfo, X_ERROR,
				    "Invalid button mapping. Using defaults\n");
				phy_btn = 1; /* ensure defaults start at 1 */
				break;
			}

			priv->btnmap[phy_btn++] = btn;
			map = end;
		} while (end && *end != '\0' && phy_btn <= NBUTTONS);
		free(s);
	}

	for (i = phy_btn; i <= NBUTTONS; i++)
		priv->btnmap[i] = i;

	wsWheelHandleButtonMap(pInfo, &(priv->Z), "ZAxisMapping", "4 5");
	wsWheelHandleButtonMap(pInfo, &(priv->W), "WAxisMapping", "6 7");

	priv->screen_no = xf86SetIntOption(pInfo->options, "ScreenNo", 0);
	xf86IDrvMsg(pInfo, X_CONFIG, "associated screen: %d\n",
	    priv->screen_no);
	if (priv->screen_no < 0 || priv->screen_no >= screenInfo.numScreens)
		priv->screen_no = 0;

	priv->swap_axes = xf86SetBoolOption(pInfo->options, "SwapXY", 0);
	if (priv->swap_axes) {
		xf86IDrvMsg(pInfo, X_CONFIG,
		    "device will work with X and Y axes swapped\n");
	}
	priv->inv_x = 0;
	priv->inv_y = 0;
	s = xf86SetStrOption(pInfo->options, "Rotate", NULL);
	if (s) {
		if (xf86NameCmp(s, "CW") == 0) {
			priv->inv_x = 1;
			priv->inv_y = 0;
			priv->swap_axes = 1;
		} else if (xf86NameCmp(s, "CCW") == 0) {
			priv->inv_x = 0;
			priv->inv_y = 1;
			priv->swap_axes = 1;
		} else if (xf86NameCmp(s, "UD") == 0) {
			priv->inv_x = 1;
			priv->inv_y = 1;
		} else {
			xf86IDrvMsg(pInfo, X_ERROR, "\"%s\" is not a valid "
			    "value for Option \"Rotate\"\n", s);
			xf86IDrvMsg(pInfo, X_ERROR, "Valid options are "
			    "\"CW\", \"CCW\", or \"UD\"\n");
		}
		free(s);
	}
	if (wsOpen(pInfo) != Success)
		goto fail;
	if (ioctl(pInfo->fd, WSMOUSEIO_GTYPE, &priv->type) != 0)
		goto fail;
	if (priv->type == WSMOUSE_TYPE_TPANEL) {
		pInfo->type_name = XI_TOUCHSCREEN;
		priv->raw = xf86SetBoolOption(pInfo->options, "Raw", 1);
		if (priv->raw) {
			xf86IDrvMsg(pInfo, X_CONFIG,
			    "device will work in raw mode\n");
		}
	} else {
		pInfo->type_name = XI_MOUSE;
		priv->raw = 0;
	}

	if (priv->type == WSMOUSE_TYPE_TPANEL && priv->raw) {
		if (ioctl(pInfo->fd, WSMOUSEIO_GCALIBCOORDS,
		    &priv->coords) != 0) {
			xf86IDrvMsg(pInfo, X_ERROR,
			    "GCALIBCOORS failed %s\n", strerror(errno));
			goto fail;
		}

		/* get default coordinate space from kernel */
		priv->min_x = priv->coords.minx;
		priv->max_x = priv->coords.maxx;
		priv->min_y = priv->coords.miny;
		priv->max_y = priv->coords.maxy;
	} else {
		/* in calibrated mode, coordinate space, is screen coords */
		priv->min_x = 0;
		priv->max_x = screenInfo.screens[priv->screen_no]->width - 1;
		priv->min_y = 0;
		priv->max_y = screenInfo.screens[priv->screen_no]->height - 1;
	}
	/* Allow options to override this */
	priv->min_x = xf86SetIntOption(pInfo->options, "MinX", priv->min_x);
	xf86IDrvMsg(pInfo, X_INFO, "minimum x position: %d\n", priv->min_x);
	priv->max_x = xf86SetIntOption(pInfo->options, "MaxX", priv->max_x);
	xf86IDrvMsg(pInfo, X_INFO, "maximum x position: %d\n", priv->max_x);
	priv->min_y = xf86SetIntOption(pInfo->options, "MinY", priv->min_y);
	xf86IDrvMsg(pInfo, X_INFO, "minimum y position: %d\n", priv->min_y);
	priv->max_y = xf86SetIntOption(pInfo->options, "MaxY", priv->max_y);
	xf86IDrvMsg(pInfo, X_INFO, "maximum y position: %d\n", priv->max_y);

	pInfo->device_control = wsProc;
	pInfo->read_input = wsReadInput;
	pInfo->switch_mode = wsSwitchMode;

	xf86IDrvMsg(pInfo, buttons_from, "Buttons: %d\n", priv->buttons);

	wsClose(pInfo);

	wsmbEmuPreInit(pInfo);
	wsWheelEmuPreInit(pInfo);
	return Success;

fail:
	if (pInfo->fd >= 0)
		wsClose(pInfo);
	if (priv != NULL) {
		free(priv);
		pInfo->private = NULL;
	}
	return rc;
}

static void
wsUnInit(InputDriverPtr drv, InputInfoPtr pInfo, int flags)
{
	WSDevicePtr priv = (WSDevicePtr)pInfo->private;

	if (priv) {
		free(priv->devName);
		priv->devName = NULL;
	}
	xf86DeleteInput(pInfo, flags);
}

static int
wsProc(DeviceIntPtr pWS, int what)
{
	InputInfoPtr pInfo = (InputInfoPtr)pWS->public.devicePrivate;

	switch (what) {
	case DEVICE_INIT:
		return wsDeviceInit(pWS);

	case DEVICE_ON:
		return wsDeviceOn(pWS);

	case DEVICE_OFF:
		wsDeviceOff(pWS);
		break;

	case DEVICE_CLOSE:
		DBG(1, ErrorF("WS DEVICE_CLOSE\n"));
		wsClose(pInfo);
		break;

	default:
		xf86IDrvMsg(pInfo, X_ERROR, "unknown command %d\n", what);
		return !Success;
	}
	return Success;
}

static int
wsDeviceInit(DeviceIntPtr pWS)
{
	InputInfoPtr pInfo = (InputInfoPtr)pWS->public.devicePrivate;
	WSDevicePtr priv = (WSDevicePtr)pInfo->private;
	int xmin, xmax, ymin, ymax;
	Atom btn_labels[NBUTTONS] = {0};
	Atom axes_labels[NAXES] = {0};

	DBG(1, ErrorF("WS DEVICE_INIT\n"));

	btn_labels[0] = XIGetKnownProperty(BTN_LABEL_PROP_BTN_LEFT);
	btn_labels[1] = XIGetKnownProperty(BTN_LABEL_PROP_BTN_MIDDLE);
	btn_labels[2] = XIGetKnownProperty(BTN_LABEL_PROP_BTN_RIGHT);
	if (!InitButtonClassDeviceStruct(pWS, min(priv->buttons, NBUTTONS),
	    btn_labels, priv->btnmap))
		return !Success;

	if (priv->type == WSMOUSE_TYPE_TPANEL) {
		xmin = priv->min_x;
		xmax = priv->max_x;
		ymin = priv->min_y;
		ymax = priv->max_y;
	} else {
		xmin = -1;
		xmax = -1;
		ymin = -1;
		ymax = -1;
	}

	if (priv->swap_axes) {
		int tmp;
		tmp = xmin;
		xmin = ymin;
		ymin = tmp;
		tmp = xmax;
		xmax = ymax;
		ymax = tmp;
	}
	if (priv->type == WSMOUSE_TYPE_TPANEL) {
		axes_labels[0] = XIGetKnownProperty(AXIS_LABEL_PROP_ABS_X);
		axes_labels[1] = XIGetKnownProperty(AXIS_LABEL_PROP_ABS_Y);
	} else {
		axes_labels[0] = XIGetKnownProperty(AXIS_LABEL_PROP_REL_X);
		axes_labels[1] = XIGetKnownProperty(AXIS_LABEL_PROP_REL_Y);
	}
	if (!InitValuatorClassDeviceStruct(pWS,
	    NAXES, axes_labels, GetMotionHistorySize(),
	    priv->type == WSMOUSE_TYPE_TPANEL ? Absolute : Relative))
		return !Success;
	if (!InitPtrFeedbackClassDeviceStruct(pWS, wsControlProc))
		return !Success;

	xf86InitValuatorAxisStruct(pWS, 0,
	    axes_labels[0],
	    xmin, xmax, 1, 0, 1,
	    priv->type == WSMOUSE_TYPE_TPANEL ? Absolute : Relative);
	xf86InitValuatorDefaults(pWS, 0);

	xf86InitValuatorAxisStruct(pWS, 1,
	    axes_labels[1],
	    ymin, ymax, 1, 0, 1,
	    priv->type == WSMOUSE_TYPE_TPANEL ? Absolute : Relative);
	xf86InitValuatorDefaults(pWS, 1);

	pWS->public.on = FALSE;
	if (wsOpen(pInfo) != Success) {
		return !Success;
	}

	if (priv->type == WSMOUSE_TYPE_TPANEL)
		wsInitCalibProperty(pWS);
	wsmbEmuInitProperty(pWS);
	wsWheelEmuInitProperty(pWS);
	return Success;
}

static int
wsDeviceOn(DeviceIntPtr pWS)
{
	InputInfoPtr pInfo = (InputInfoPtr)pWS->public.devicePrivate;
	WSDevicePtr priv = (WSDevicePtr)pInfo->private;
	struct wsmouse_calibcoords coords;

	DBG(1, ErrorF("WS DEVICE ON\n"));
	if ((pInfo->fd < 0) && (wsOpen(pInfo) != Success)) {
		xf86IDrvMsg(pInfo, X_ERROR, "wsOpen failed %s\n",
		    strerror(errno));
		return !Success;
	}

	if (priv->type == WSMOUSE_TYPE_TPANEL) {
		/* get calibration values */
		if (ioctl(pInfo->fd, WSMOUSEIO_GCALIBCOORDS, &coords) != 0) {
			xf86IDrvMsg(pInfo, X_ERROR, "GCALIBCOORS failed %s\n",
			    strerror(errno));
			return !Success;
		}
		memcpy(&priv->coords, &coords, sizeof coords);
		/* set raw mode */
		if (coords.samplelen != priv->raw) {
			coords.samplelen = priv->raw;
			if (ioctl(pInfo->fd, WSMOUSEIO_SCALIBCOORDS,
			    &coords) != 0) {
				xf86IDrvMsg(pInfo, X_ERROR,
				    "SCALIBCOORS failed %s\n", strerror(errno));
				return !Success;
			}
		}
	}
	xf86AddEnabledDevice(pInfo);
	wsmbEmuOn(pInfo);
	pWS->public.on = TRUE;
	return Success;
}

static void
wsDeviceOff(DeviceIntPtr pWS)
{
	InputInfoPtr pInfo = (InputInfoPtr)pWS->public.devicePrivate;
	WSDevicePtr priv = (WSDevicePtr)pInfo->private;
	struct wsmouse_calibcoords coords;

	DBG(1, ErrorF("WS DEVICE OFF\n"));
	wsmbEmuFinalize(pInfo);
	if (priv->type == WSMOUSE_TYPE_TPANEL) {
		/* Restore calibration data */
		memcpy(&coords, &priv->coords, sizeof coords);
		if (ioctl(pInfo->fd, WSMOUSEIO_SCALIBCOORDS, &coords) != 0) {
			xf86IDrvMsg(pInfo, X_ERROR, "SCALIBCOORS failed %s\n",
			    strerror(errno));
		}
	}
	if (pInfo->fd >= 0) {
		xf86RemoveEnabledDevice(pInfo);
		wsClose(pInfo);
	}
	pWS->public.on = FALSE;
}

static size_t
wsReadEvents(InputInfoPtr pInfo)
{
	WSDevicePtr priv = (WSDevicePtr)pInfo->private;
	ssize_t len;

	priv->events_count = priv->events_pos = 0;
	len = read(pInfo->fd, priv->events, sizeof(priv->events));
	if (len < 0) {
		if (errno != EAGAIN)
			xf86IDrvMsg(pInfo, X_ERROR, "read error %s\n",
			    strerror(errno));
	} else if (len % sizeof(struct wscons_event)) {
		xf86IDrvMsg(pInfo, X_ERROR,
		    "read error, invalid number of bytes\n");
	} else {
		priv->events_count = len / sizeof(struct wscons_event);
	}

	return priv->events_count;
}

static struct wscons_event *
wsGetEvent(InputInfoPtr pInfo)
{
	WSDevicePtr priv = (WSDevicePtr)pInfo->private;
	struct wscons_event *event;

	if (priv->events_count == 0 && wsReadEvents(pInfo) == 0)
		return NULL;

	event = &priv->events[priv->events_pos];
	priv->events_pos++;
	priv->events_count--;

	return event;
}

static Bool
wsReadHwState(InputInfoPtr pInfo, wsHwState *hw)
{
	WSDevicePtr priv = (WSDevicePtr)pInfo->private;
	struct wscons_event *event;

	bzero(hw, sizeof(wsHwState));
	hw->buttons = priv->lastButtons;
	hw->ax = priv->old_ax;
	hw->ay = priv->old_ay;

	while ((event = wsGetEvent(pInfo)) != NULL) {
		switch (event->type) {
		case WSCONS_EVENT_MOUSE_UP:
			hw->buttons &= ~(1 << event->value);
			DBG(4, ErrorF("Button %d up %x\n", event->value,
			    hw->buttons));
			break;
		case WSCONS_EVENT_MOUSE_DOWN:
			hw->buttons |= (1 << event->value);
			DBG(4, ErrorF("Button %d down %x\n", event->value,
			    hw->buttons));
			break;
		case WSCONS_EVENT_MOUSE_DELTA_X:
			hw->dx = event->value;
			DBG(4, ErrorF("Relative X %d\n", event->value));
			break;
		case WSCONS_EVENT_MOUSE_DELTA_Y:
			hw->dy = -event->value;
			DBG(4, ErrorF("Relative Y %d\n", event->value));
			break;
		case WSCONS_EVENT_MOUSE_DELTA_Z:
			hw->dz = event->value;
			DBG(4, ErrorF("Relative Z %d\n", event->value));
			break;
		case WSCONS_EVENT_MOUSE_DELTA_W:
			hw->dw = event->value;
			DBG(4, ErrorF("Relative W %d\n", event->value));
			break;
		case WSCONS_EVENT_MOUSE_ABSOLUTE_X:
			hw->ax = event->value;
			if (priv->inv_x)
				hw->ax = priv->max_x - hw->ax + priv->min_x;
			DBG(4, ErrorF("Absolute X %d\n", event->value));
			break;
		case WSCONS_EVENT_MOUSE_ABSOLUTE_Y:
			hw->ay = event->value;
			if (priv->inv_y)
				hw->ay = priv->max_y - hw->ay + priv->min_y;
			DBG(4, ErrorF("Absolute Y %d\n", event->value));
			break;
		case WSCONS_EVENT_MOUSE_ABSOLUTE_Z:
		case WSCONS_EVENT_MOUSE_ABSOLUTE_W:
			/* ignore those */
			continue;
		case WSCONS_EVENT_SYNC:
			DBG(4, ErrorF("Sync\n"));
			return TRUE;
		default:
			xf86IDrvMsg(pInfo, X_WARNING,
			    "bad wsmouse event type=%d\n", event->type);
			continue;
		}
#ifdef __NetBSD__
		/*
		 * XXX NetBSD reads only one event.
		 * WSCONS_EVENT_SYNC is not supported yet.
		 */
		return TRUE;
#endif
	}

	return FALSE;
}

static void
wsReadInput(InputInfoPtr pInfo)
{
	WSDevicePtr priv = (WSDevicePtr)pInfo->private;
	wsHwState hw;

	if (!wsReadHwState(pInfo, &hw))
		return;

	if ((hw.dx || hw.dy) && !wsWheelEmuFilterMotion(pInfo, hw.dx, hw.dy)) {
		/* relative motion event */
		DBG(3, ErrorF("postMotionEvent dX %d dY %d\n", hw.dx, hw.dy));
		xf86PostMotionEvent(pInfo->dev, 0, 0, 2, hw.dx, hw.dy);
	}
	if (hw.dz && priv->Z.negative != WS_NOMAP
	    && priv->Z.positive != WS_NOMAP) {
		int zbutton;
		zbutton = (hw.dz < 0) ? priv->Z.negative : priv->Z.positive;
		DBG(4, ErrorF("Z -> button %d (%d)\n", zbutton, abs(hw.dz)));
		wsButtonClicks(pInfo, zbutton, abs(hw.dz));
	}
	if (hw.dw && priv->W.negative != WS_NOMAP
	    && priv->W.positive != WS_NOMAP) {
		int wbutton;
		wbutton = (hw.dw < 0) ? priv->W.negative : priv->W.positive;
		DBG(4, ErrorF("W -> button %d (%d)\n", wbutton, abs(hw.dw)));
		wsButtonClicks(pInfo, wbutton, abs(hw.dw));
	}
	if (priv->lastButtons != hw.buttons) {
		/* button event */
		wsSendButtons(pInfo, hw.buttons);
	}
	if (priv->swap_axes) {
		int tmp;

		tmp = hw.ax;
		hw.ax = hw.ay;
		hw.ay = tmp;
	}
	if ((hw.ax != priv->old_ax) || (hw.ay != priv->old_ay)) {
		int xdelta = hw.ax - priv->old_ax;
		int ydelta = hw.ay - priv->old_ay;
		priv->old_ax = hw.ax;
		priv->old_ay = hw.ay;
		if (wsWheelEmuFilterMotion(pInfo, xdelta, ydelta))
			return;

		/* absolute position event */
		DBG(3, ErrorF("postMotionEvent X %d Y %d\n", hw.ax, hw.ay));
		xf86PostMotionEvent(pInfo->dev, 1, 0, 2, hw.ax, hw.ay);
	}
}

static void
wsSendButtons(InputInfoPtr pInfo, int buttons)
{
	WSDevicePtr priv = (WSDevicePtr)pInfo->private;
	int change, button, press;

	change = buttons ^ priv->lastButtons;
	while (change) {
		button = ffs(change);
		press = buttons & (1 << (button - 1));
		change &= ~(1 << (button - 1));

		if (wsWheelEmuFilterButton(pInfo, button, press))
			continue;

		if (wsmbEmuFilterEvent(pInfo, button, press))
			continue;

		xf86PostButtonEvent(pInfo->dev, TRUE, button, press, 0, 0);
		DBG(3, ErrorF("post button event %d %d\n", button, press));
	}
	priv->lastButtons = buttons;
}

static int
wsSwitchMode(ClientPtr client, DeviceIntPtr dev, int mode)
{
	return BadMatch;
}

static Bool
wsOpen(InputInfoPtr pInfo)
{
	WSDevicePtr priv = (WSDevicePtr)pInfo->private;
#ifdef __NetBSD__
	int version = WSMOUSE_EVENT_VERSION;
#endif

	DBG(1, ErrorF("WS open %s\n", priv->devName));
	pInfo->fd = xf86OpenSerial(pInfo->options);
	if (pInfo->fd == -1) {
		xf86IDrvMsg(pInfo, X_ERROR, "cannot open input device\n");
		return !Success;
	}
#ifdef __NetBSD__
	if (ioctl(pInfo->fd, WSMOUSEIO_SETVERSION, &version) == -1) {
		xf86IDrvMsg(pInfo, X_ERROR,
		    "cannot set wsmouse event version\n");
		return !Success;
	}
#endif
	return Success;
}

static void
wsClose(InputInfoPtr pInfo)
{
	xf86CloseSerial(pInfo->fd);
	pInfo->fd = -1;
}

static void
wsControlProc(DeviceIntPtr device, PtrCtrl *ctrl)
{
	/* Nothing to do, dix handles all settings */
	DBG(1, ErrorF("wsControlProc\n"));
}

static void
wsInitCalibProperty(DeviceIntPtr device)
{
	InputInfoPtr pInfo = (InputInfoPtr)device->public.devicePrivate;
	WSDevicePtr priv = (WSDevicePtr)pInfo->private;
	int rc;

	DBG(1, ErrorF("wsInitCalibProperty\n"));

	prop_calibration = MakeAtom(WS_PROP_CALIBRATION,
	    strlen(WS_PROP_CALIBRATION), TRUE);
	rc = XIChangeDeviceProperty(device, prop_calibration, XA_INTEGER, 32,
	    PropModeReplace, 4, &priv->min_x, FALSE);
	if (rc != Success) {
		xf86IDrvMsg(pInfo, X_ERROR,
		    "cannot create device property %s: %d\n",
		    WS_PROP_CALIBRATION, rc);
		return;
	}
	XISetDevicePropertyDeletable(device, prop_calibration, FALSE);

	prop_swap = MakeAtom(WS_PROP_SWAP_AXES,
	    strlen(WS_PROP_SWAP_AXES), TRUE);
	rc = XIChangeDeviceProperty(device, prop_swap, XA_INTEGER, 8,
	    PropModeReplace, 1, &priv->swap_axes, FALSE);
	if (rc != Success) {
		xf86IDrvMsg(pInfo, X_ERROR,
		    "cannot create device property %s: %d\n",
		    WS_PROP_SWAP_AXES, rc);
		return;
	}
	XISetDevicePropertyDeletable(device, prop_swap, FALSE);

	XIRegisterPropertyHandler(device, wsSetCalibProperty, NULL, NULL);

	return;
}

static int
wsSetCalibProperty(DeviceIntPtr device, Atom atom, XIPropertyValuePtr val,
    BOOL checkonly)
{
	InputInfoPtr pInfo = (InputInfoPtr)device->public.devicePrivate;
	WSDevicePtr priv = (WSDevicePtr)pInfo->private;
	struct wsmouse_calibcoords coords;
	int need_update = 0;
	AxisInfoPtr ax = device->valuator->axes,
		    ay = device->valuator->axes + 1;

	DBG(1, ErrorF("wsSetCalibProperty %s\n", NameForAtom(atom)));

	if (atom == prop_calibration) {
		if (val->format != 32 || val->type != XA_INTEGER)
			return BadMatch;
		if (val->size != 4 && val->size != 0)
			return BadMatch;
		if (!checkonly) {
			if (val->size == 0) {
				DBG(1, ErrorF(" uncalibrate\n"));
				priv->min_x = 0;
				priv->max_x = -1;
				priv->min_y = 0;
				priv->max_y = -1;
			} else {
				priv->min_x = ((int *)(val->data))[0];
				priv->max_x = ((int *)(val->data))[1];
				priv->min_y = ((int *)(val->data))[2];
				priv->max_y = ((int *)(val->data))[3];
				DBG(1, ErrorF(" calibrate %d %d %d %d\n",
					priv->min_x, priv->max_x,
					priv->min_y, priv->max_y));
				need_update++;
			}
			/* Update axes descriptors */
			if (!priv->swap_axes) {
				ax->min_value = priv->min_x;
				ax->max_value = priv->max_x;
				ay->min_value = priv->min_y;
				ay->max_value = priv->max_y;
			} else {
				ax->min_value = priv->min_y;
				ax->max_value = priv->max_y;
				ay->min_value = priv->min_x;
				ay->max_value = priv->max_x;
			}
		}
	} else if (atom == prop_swap) {
		if (val->format != 8 || val->type != XA_INTEGER ||
		    val->size != 1)
			return BadMatch;
		if (!checkonly) {
			priv->swap_axes = *((BOOL *)val->data);
			DBG(1, ErrorF("swap_axes %d\n", priv->swap_axes));
			need_update++;
		}
	}
	if (need_update) {
		/* Update the saved values to be restored on device off */
		priv->coords.minx = priv->min_x;
		priv->coords.maxx = priv->max_x;
		priv->coords.miny = priv->min_y;
		priv->coords.maxy = priv->max_y;
		priv->coords.swapxy = priv->swap_axes;

		/* Update the kernel calibration table */
		coords.minx = priv->min_x;
		coords.maxx = priv->max_x;
		coords.miny = priv->min_y;
		coords.maxy = priv->max_y;
		coords.swapxy = priv->swap_axes;
		coords.samplelen = priv->raw;
		coords.resx = priv->coords.resx;
		coords.resy = priv->coords.resy;
		if (ioctl(pInfo->fd, WSMOUSEIO_SCALIBCOORDS, &coords) != 0) {
			xf86IDrvMsg(pInfo, X_ERROR, "SCALIBCOORDS failed %s\n",
			    strerror(errno));
		}
	}
	return Success;
}

void
wsWheelHandleButtonMap(InputInfoPtr pInfo, WheelAxisPtr pAxis,
    const char* axis_name, const char* default_value)
{
	WSDevicePtr priv = (WSDevicePtr)pInfo->private;
	char *option_string;
	int b1, b2;

	pAxis->negative = pAxis->positive = WS_NOMAP;
	pAxis->traveled_distance = 0;

	option_string = xf86SetStrOption(pInfo->options, axis_name,
	    default_value);
	if (option_string) {
		if (sscanf(option_string, "%d %d", &b1, &b2) == 2 &&
		    b1 > 0 && b1 <= NBUTTONS &&
		    b2 > 0 && b2 <= NBUTTONS) {
			xf86IDrvMsg(pInfo, X_CONFIG, "%s: buttons %d and %d\n",
			    axis_name, b1, b2);

			pAxis->negative = b1;
			pAxis->positive = b2;

			if (max(b1, b2) > priv->buttons)
				priv->buttons = max(b1, b2);
		} else {
			xf86IDrvMsg(pInfo, X_WARNING,
			    "Invalid %s value: \"%s\"\n",
			    axis_name, option_string);
		}
		free(option_string);
	}
}

void
wsButtonClicks(InputInfoPtr pInfo, int button, int count)
{
	int i;

	for (i = 0; i < count; i++) {
		xf86PostButtonEvent(pInfo->dev, TRUE, button, 1, 0, 0);
		xf86PostButtonEvent(pInfo->dev, TRUE, button, 0, 0, 0);
	}
}
@


1.61
log
@log read errors at verbose level 4 and above.
This prevents filling /var/log/Xorg.0.log when a device gets disconnected.
XXX more work is needed to actually disable it (and make it possible to
automatically re-enable it when it becomes available again).
@
text
@d16 1
a16 1
/* $OpenBSD: ws.c,v 1.60 2013/11/02 13:17:32 shadchin Exp $ */
d460 2
a461 2
static Bool
wsReadEvent(InputInfoPtr pInfo, struct wscons_event *event)
d463 1
a463 1
	Bool rc = TRUE;
d466 3
a468 2
	len = read(pInfo->fd, event, sizeof(struct wscons_event));
	if (len <= 0) {
d470 1
a470 1
			xf86IDrvMsgVerb(pInfo, X_ERROR, 4, "read error %s\n",
d472 1
a472 2
		rc = FALSE;
	} else if (len != sizeof(struct wscons_event)) {
d475 2
a476 1
		rc = FALSE;
d479 17
a495 1
	return rc;
d502 1
a502 1
	struct wscons_event event;
a504 1

d509 2
a510 2
	while (wsReadEvent(pInfo, &event)) {
		switch (event.type) {
d512 2
a513 2
			hw->buttons &= ~(1 << event.value);
			DBG(4, ErrorF("Button %d up %x\n", event.value,
d517 2
a518 2
			hw->buttons |= (1 << event.value);
			DBG(4, ErrorF("Button %d down %x\n", event.value,
d522 2
a523 2
			hw->dx = event.value;
			DBG(4, ErrorF("Relative X %d\n", event.value));
d526 2
a527 2
			hw->dy = -event.value;
			DBG(4, ErrorF("Relative Y %d\n", event.value));
d530 2
a531 2
			hw->dz = event.value;
			DBG(4, ErrorF("Relative Z %d\n", event.value));
d534 2
a535 2
			hw->dw = event.value;
			DBG(4, ErrorF("Relative W %d\n", event.value));
d538 1
a538 1
			hw->ax = event.value;
d541 1
a541 1
			DBG(4, ErrorF("Absolute X %d\n", event.value));
d544 1
a544 1
			hw->ay = event.value;
d547 1
a547 1
			DBG(4, ErrorF("Absolute Y %d\n", event.value));
d558 1
a558 1
			    "bad wsmouse event type=%d\n", event.type);
@


1.60
log
@a little header cleanup
@
text
@d16 1
a16 1
/* $OpenBSD: ws.c,v 1.59 2013/10/30 18:05:34 shadchin Exp $ */
d469 1
a469 1
			xf86IDrvMsg(pInfo, X_ERROR, "read error %s\n",
@


1.59
log
@Fix jagged diagonal lines (xenocara part)

Make sure that you have a recent kernel.

ok matthieu@@. tested edd@@, Henri Kemppainen and Alf Schlichting.
@
text
@d16 1
a16 1
/* $OpenBSD: ws.c,v 1.58 2013/07/20 13:24:50 matthieu Exp $ */
a34 1
#include <xisb.h>
@


1.58
log
@Sum consecutive dx and dy motion events received separartely from
the kernel before sending them up to X. Reduces staircacse effects
on diagonal freehand drawings. Patch from Henri Kemppainen, tested
by edd@@. Thanks.
@
text
@d16 1
a16 1
/* $OpenBSD: ws.c,v 1.57 2012/07/08 14:22:03 shadchin Exp $ */
a430 7
	priv->buffer = XisbNew(pInfo->fd,
	    sizeof(struct wscons_event) * NUMEVENTS);
	if (priv->buffer == NULL) {
		xf86IDrvMsg(pInfo, X_ERROR, "cannot alloc xisb buffer\n");
		wsClose(pInfo);
		return !Success;
	}
d458 19
a476 3
	if (priv->buffer) {
		XisbFree(priv->buffer);
		priv->buffer = NULL;
d478 2
a479 1
	pWS->public.on = FALSE;
d482 2
a483 2
static void
wsReadInput(InputInfoPtr pInfo)
d486 1
a486 11
	static struct wscons_event eventList[NUMEVENTS];
	int n, c, dx, dy;
	struct wscons_event *event = eventList;
	unsigned char *pBuf;

	XisbBlockDuration(priv->buffer, -1);
	pBuf = (unsigned char *)eventList;
	n = 0;
	while (n < sizeof(eventList) && (c = XisbRead(priv->buffer)) >= 0) {
		pBuf[n++] = (unsigned char)c;
	}
d488 1
a488 2
	if (n == 0)
		return;
d490 3
a492 6
	dx = dy = 0;
	n /= sizeof(struct wscons_event);
	while (n--) {
		int buttons = priv->lastButtons;
		int newdx = 0, newdy = 0, dz = 0, dw = 0, ax = 0, ay = 0;
		int zbutton = 0, wbutton = 0;
d494 2
a495 1
		switch (event->type) {
d497 3
a499 3
			buttons &= ~(1 << event->value);
			DBG(4, ErrorF("Button %d up %x\n", event->value,
			    buttons));
d502 3
a504 3
			buttons |= (1 << event->value);
			DBG(4, ErrorF("Button %d down %x\n", event->value,
			    buttons));
d507 2
a508 5
			if (!dx)
				dx = event->value;
			else
				newdx = event->value;
			DBG(4, ErrorF("Relative X %d\n", event->value));
d511 10
a520 5
			if (!dy)
				dy = -event->value;
			else
				newdy = -event->value;
			DBG(4, ErrorF("Relative Y %d\n", event->value));
d523 1
a523 4
			DBG(4, ErrorF("Absolute X %d\n", event->value));
			if (event->value == 4095)
				break;
			ax = event->value;
d525 2
a526 1
				ax = priv->max_x - ax + priv->min_x;
d529 1
a529 2
			DBG(4, ErrorF("Absolute Y %d\n", event->value));
			ay = event->value;
d531 2
a532 5
				ay = priv->max_y - ay + priv->min_y;
			break;
		case WSCONS_EVENT_MOUSE_DELTA_Z:
			DBG(4, ErrorF("Relative Z %d\n", event->value));
			dz = event->value;
d535 1
a536 1
			++event;
d538 3
a540 5
			break;
		case WSCONS_EVENT_MOUSE_DELTA_W:
			DBG(4, ErrorF("Relative W %d\n", event->value));
			dw = event->value;
			break;
d543 1
a543 2
			    "bad wsmouse event type=%d\n", event->type);
			++event;
d546 17
a562 1
		++event;
d564 2
a565 35
		if ((newdx || newdy) || ((dx || dy) &&
		    event->type != WSCONS_EVENT_MOUSE_DELTA_X &&
		    event->type != WSCONS_EVENT_MOUSE_DELTA_Y)) {
			int tmpx = dx, tmpy = dy;
			dx = newdx;
			dy = newdy;

			if (wsWheelEmuFilterMotion(pInfo, tmpx, tmpy))
				continue;

			/* relative motion event */
			DBG(3, ErrorF("postMotionEvent dX %d dY %d\n",
			    tmpx, tmpy));
			xf86PostMotionEvent(pInfo->dev, 0, 0, 2, tmpx, tmpy);
		}
		if (dz && priv->Z.negative != WS_NOMAP
		    && priv->Z.positive != WS_NOMAP) {
			zbutton = (dz < 0) ? priv->Z.negative :
			    priv->Z.positive;
			DBG(4, ErrorF("Z -> button %d\n", zbutton));
			wsButtonClicks(pInfo, zbutton, abs(dz));
		}
		if (dw && priv->W.negative != WS_NOMAP
		    && priv->W.positive != WS_NOMAP) {
			wbutton = (dw < 0) ? priv->W.negative :
			    priv->W.positive;
			DBG(4, ErrorF("W -> button %d\n", wbutton));
			wsButtonClicks(pInfo, wbutton, abs(dw));
		}
		if (priv->lastButtons != buttons) {
			/* button event */
			wsSendButtons(pInfo, buttons);
		}
		if (priv->swap_axes) {
			int tmp;
d567 22
a588 24
			tmp = ax;
			ax = ay;
			ay = tmp;
		}
		if (ax) {
			int xdelta = ax - priv->old_ax;
			priv->old_ax = ax;
			if (wsWheelEmuFilterMotion(pInfo, xdelta, 0))
				continue;

			/* absolute position event */
			DBG(3, ErrorF("postMotionEvent X %d\n", ax));
			xf86PostMotionEvent(pInfo->dev, 1, 0, 1, ax);
		}
		if (ay) {
			int ydelta = ay - priv->old_ay;
			priv->old_ay = ay;
			if (wsWheelEmuFilterMotion(pInfo, 0, ydelta))
				continue;

			/* absolute position event */
			DBG(3, ErrorF("postMotionEvent y %d\n", ay));
			xf86PostMotionEvent(pInfo->dev, 1, 1, 1, ay);
		}
d590 13
a602 2
	if (dx || dy) {
		if (wsWheelEmuFilterMotion(pInfo, dx, dy))
d605 3
a607 4
		/* relative motion event */
		DBG(3, ErrorF("postMotionEvent dX %d dY %d\n",
		    dx, dy));
		xf86PostMotionEvent(pInfo->dev, 0, 0, 2, dx, dy);
a608 1
	return;
@


1.57
log
@two nits missing in previous commit
@
text
@d16 1
a16 1
/* $OpenBSD: ws.c,v 1.56 2012/07/08 13:51:11 shadchin Exp $ */
d477 1
a477 1
	int n, c;
d491 1
d495 1
a495 1
		int dx = 0, dy = 0, dz = 0, dw = 0, ax = 0, ay = 0;
d510 4
a513 1
			dx = event->value;
d517 4
a520 1
			dy = -event->value;
d558 8
a565 2
		if (dx || dy) {
			if (wsWheelEmuFilterMotion(pInfo, dx, dy))
d570 2
a571 2
			    dx, dy));
			xf86PostMotionEvent(pInfo->dev, 0, 0, 2, dx, dy);
d599 1
a599 1
			dx = ax - priv->old_ax;
d601 1
a601 1
			if (wsWheelEmuFilterMotion(pInfo, dx, 0))
d609 1
a609 1
			dy = ay - priv->old_ay;
d611 1
a611 1
			if (wsWheelEmuFilterMotion(pInfo, 0, dy))
d618 9
@


1.56
log
@Cleanup and uniform style. No functional changes.
@
text
@d16 1
a16 1
/* $OpenBSD: ws.c,v 1.55 2012/06/12 17:59:01 shadchin Exp $ */
d501 1
a501 1
				buttons));
d506 1
a506 1
				buttons));
@


1.55
log
@zap extra brackets
@
text
@d16 1
a16 1
/* $OpenBSD: ws.c,v 1.54 2012/06/12 17:12:50 shadchin Exp $ */
d86 5
a90 2
_X_EXPORT XF86ModuleData wsModuleData = {&VersionRec,
			       SetupProc, TearDownProc };
d284 1
a284 1
	WSDevicePtr priv = pInfo->private;
d317 1
a317 1
	} /* switch */
d319 1
a319 1
} /* wsProc */
d368 2
a369 5
		NAXES,
		axes_labels,
		GetMotionHistorySize(),
		priv->type == WSMOUSE_TYPE_TPANEL ?
		Absolute : Relative))
d409 1
a409 1
			return !Success;
d424 1
a424 1
				&coords) != 0) {
d448 1
a448 1
	WSDevicePtr priv = pInfo->private;
d475 1
a475 1
	WSDevicePtr priv;
a480 2
	priv = pInfo->private;

d492 1
a492 1
	while( n-- ) {
a498 1

d502 1
a502 1
		break;
d548 1
a548 1
		} /* case */
d607 1
a607 1
} /* wsReadInput */
d631 1
a631 1
} /* wsSendButtons */
d650 2
a651 2
	    xf86IDrvMsg(pInfo, X_ERROR, "cannot open input device\n");
	    return !Success;
d680 1
a680 1
	InputInfoPtr pInfo = device->public.devicePrivate;
d719 1
a719 1
	InputInfoPtr pInfo = device->public.devicePrivate;
@


1.54
log
@Add support ButtonMapping

ok matthieu@@
@
text
@d16 1
a16 1
/* $OpenBSD: ws.c,v 1.53 2012/06/12 17:10:03 shadchin Exp $ */
d357 1
a357 1
	if ((priv->type == WSMOUSE_TYPE_TPANEL)) {
@


1.53
log
@Add missing XISetDevicePropertyDeletable and more information about error

ok matthieu@@
@
text
@d16 1
a16 1
/* $OpenBSD: ws.c,v 1.52 2012/06/12 17:04:43 shadchin Exp $ */
d123 1
a123 1
	int rc = BadValue;
d148 25
d323 1
a323 2
	unsigned char map[NBUTTONS + 1];
	int i, xmin, xmax, ymin, ymax;
d332 2
a333 6
	for (i = 0; i < NBUTTONS; i++)
		map[i + 1] = i + 1;
	if (!InitButtonClassDeviceStruct(pWS,
		min(priv->buttons, NBUTTONS),
		btn_labels,
		map))
@


1.52
log
@Fix some obvious constness-related compile warnings

ok matthieu@@
@
text
@d16 1
a16 1
/* $OpenBSD: ws.c,v 1.51 2011/12/29 13:48:05 matthieu Exp $ */
d673 4
a676 1
	if (rc != Success)
d678 1
a678 1

d685 4
a688 1
	if (rc != Success)
d690 2
@


1.51
log
@add _X_EXPORT attribute to public symbols.
@
text
@d16 1
a16 1
/* $OpenBSD: ws.c,v 1.50 2011/11/28 23:49:59 shadchin Exp $ */
d775 1
a775 1
    char* axis_name, char* default_value)
@


1.50
log
@Adding wheel emulation, ported from evdev(4)

ok matthieu@@
@
text
@d16 1
a16 1
/* $OpenBSD: ws.c,v 1.49 2011/11/19 13:12:49 shadchin Exp $ */
d86 1
a86 1
XF86ModuleData wsModuleData = {&VersionRec,
d89 1
a89 1
InputDriverRec WS = {
@


1.49
log
@Replace WS_NOZMAP on WS_NOMAP.

ok matthieu@@
@
text
@d16 1
a16 1
/* $OpenBSD: ws.c,v 1.48 2011/11/19 12:46:08 shadchin Exp $ */
a146 4
	priv->negativeZ = priv->positiveZ = WS_NOMAP;
	s = xf86SetStrOption(pInfo->options, "ZAxisMapping", "4 5");
	if (s) {
		int b1, b2;
d148 2
a149 41
		if (sscanf(s, "%d %d", &b1, &b2) == 2 &&
		    b1 > 0 && b1 <= NBUTTONS &&
		    b2 > 0 && b2 <= NBUTTONS) {
			priv->negativeZ = 1 << (b1 - 1);
			priv->positiveZ = 1 << (b2 - 1);
			xf86IDrvMsg(pInfo, X_CONFIG,
			    "ZAxisMapping: buttons %d and %d\n",
			    b1, b2);
			if (max(b1, b2) > priv->buttons) {
				priv->buttons = max(b1, b2);
				buttons_from = X_CONFIG;
			}
		} else {
			xf86IDrvMsg(pInfo, X_WARNING,
			    "invalid ZAxisMapping value: \"%s\"\n", s);
		}
		free(s);
	}
	priv->negativeW = priv->positiveW = WS_NOMAP;
	s = xf86SetStrOption(pInfo->options, "WAxisMapping", "6 7");
	if (s) {
		int b1, b2;

		if (sscanf(s, "%d %d", &b1, &b2) == 2 &&
		    b1 > 0 && b1 <= NBUTTONS &&
		    b2 > 0 && b2 <= NBUTTONS) {
			priv->negativeW = 1 << (b1 - 1);
			priv->positiveW = 1 << (b2 - 1);
			xf86IDrvMsg(pInfo, X_CONFIG,
			    "WAxisMapping: buttons %d and %d\n",
			    b1, b2);
			if (max(b1, b2) > priv->buttons) {
				priv->buttons = max(b1, b2);
				buttons_from = X_CONFIG;
			}
		} else {
			xf86IDrvMsg(pInfo, X_WARNING,
			    "invalid WAxisMapping value: \"%s\"\n", s);
		}
		free(s);
	}
d240 1
d374 1
a459 1
	int ax, ay;
d476 1
a476 1
		int dx = 0, dy = 0, dz = 0, dw = 0;
a478 1
		ax = 0; ay = 0;
d532 1
d535 3
d540 2
a541 18
				      dx, dy));
			xf86PostMotionEvent(pInfo->dev, 0, 0, 2,
			    dx, dy);
		}
		if (dz && priv->negativeZ != WS_NOMAP
		    && priv->positiveZ != WS_NOMAP) {
			buttons &= ~(priv->negativeZ | priv->positiveZ);
			if (dz < 0) {
				DBG(4, ErrorF("Z -> button %d\n",
					ffs(priv->negativeZ)));
				zbutton = priv->negativeZ;
			} else {
				DBG(4, ErrorF("Z -> button %d\n",
					ffs(priv->positiveZ)));
				zbutton = priv->positiveZ;
			}
			buttons |= zbutton;
			dz = 0;
d543 13
a555 14
		if (dw && priv->negativeW != WS_NOMAP
		    && priv->positiveW != WS_NOMAP) {
			buttons &= ~(priv->negativeW | priv->positiveW);
			if (dw < 0) {
				DBG(4, ErrorF("W -> button %d\n",
					ffs(priv->negativeW)));
				wbutton = priv->negativeW;
			} else {
				DBG(4, ErrorF("W -> button %d\n",
					ffs(priv->positiveW)));
				wbutton = priv->positiveW;
			}
			buttons |= wbutton;
			dw = 0;
a560 5
		if (zbutton != 0) {
			/* generate a button up event */
			buttons &= ~zbutton;
			wsSendButtons(pInfo, buttons);
		}
d569 5
d579 5
a587 1
		++event;
d596 1
a596 1
	int change, button, mask;
d601 11
a611 8
		mask = 1 << (button - 1);
		change &= ~mask;
		if (!wsmbEmuFilterEvent(pInfo, button, (buttons & mask) != 0)) {
			xf86PostButtonEvent(pInfo->dev, TRUE,
			    button, (buttons & mask) != 0, 0, 0);
			DBG(3, ErrorF("post button event %d %d\n",
			    button, (buttons & mask) != 0))
		}
d771 45
@


1.48
log
@Using macros MODULETEARDOWNPROTO for prototype.

ok matthieu@@
@
text
@d16 1
a16 1
/* $OpenBSD: ws.c,v 1.47 2011/11/19 12:36:16 shadchin Exp $ */
a85 2
#define WS_NOZMAP 0

d147 1
a147 1
	priv->negativeZ = priv->positiveZ = WS_NOZMAP;
d170 1
a170 1
	priv->negativeW = priv->positiveW = WS_NOZMAP;
d583 2
a584 2
		if (dz && priv->negativeZ != WS_NOZMAP
		    && priv->positiveZ != WS_NOZMAP) {
d598 2
a599 2
		if (dw && priv->negativeW != WS_NOZMAP
		    && priv->positiveW != WS_NOZMAP) {
@


1.47
log
@Static atoms don't need to be initialized to 0.

ok matthieu@@
@
text
@d16 1
a16 1
/* $OpenBSD: ws.c,v 1.46 2011/11/09 16:17:44 shadchin Exp $ */
d46 1
a46 1
static void TearDownProc(pointer);
@


1.46
log
@Call wsInitProperty() only for WSMOUSE_TYPE_TPANEL and simplify code.

Also renamed wsInitProperty and wsSetProperty to
wsInitCalibProperty and wsSetCalibProperty respectively.

ok matthieu@@
@
text
@d16 1
a16 1
/* $OpenBSD: ws.c,v 1.45 2011/11/09 16:08:42 shadchin Exp $ */
a44 1

d64 2
a65 2
static Atom prop_calibration = 0;
static Atom prop_swap = 0;
a90 1

a118 1

a665 1

@


1.45
log
@Simplify wsPreInit

ok matthieu@@
@
text
@d16 1
a16 1
/* $OpenBSD: ws.c,v 1.44 2011/11/09 16:07:13 shadchin Exp $ */
d62 2
a63 2
static void wsInitProperty(DeviceIntPtr);
static int wsSetProperty(DeviceIntPtr, Atom, XIPropertyValuePtr, BOOL);
d417 3
a419 2
	wsInitProperty(pWS);
	XIRegisterPropertyHandler(pWS, wsSetProperty, NULL, NULL);
d716 1
a716 1
wsInitProperty(DeviceIntPtr device)
d722 1
a722 3
	DBG(1, ErrorF("wsInitProperty\n"));
	if (priv->type != WSMOUSE_TYPE_TPANEL)
		return;
d739 3
d746 1
a746 1
wsSetProperty(DeviceIntPtr device, Atom atom, XIPropertyValuePtr val,
d756 1
a756 5
	DBG(1, ErrorF("wsSetProperty %s\n", NameForAtom(atom)));

	/* Ignore non panel devices */
	if (priv->type != WSMOUSE_TYPE_TPANEL)
		return Success;
@


1.44
log
@Ignore option Raw for mices. (was more noise than useful information)

ok matthieu@@
@
text
@d16 1
a16 1
/* $OpenBSD: ws.c,v 1.43 2011/11/09 16:04:50 shadchin Exp $ */
d128 1
a128 1
	int rc;
a144 1
		rc = BadValue;
d202 1
a202 2
	if (priv->screen_no >= screenInfo.numScreens ||
	    priv->screen_no < 0) {
a203 2
	}

d233 1
a233 2
	if (wsOpen(pInfo) != Success) {
		rc = BadValue;
d235 1
a235 4
	}
	if (ioctl(pInfo->fd, WSMOUSEIO_GTYPE, &priv->type) != 0) {
		wsClose(pInfo);
		rc = BadValue;
a236 1
	}
d251 1
a251 1
			&priv->coords) != 0) {
a253 2
			wsClose(pInfo);
			rc = BadValue;
d291 2
@


1.43
log
@Remove call xf86CollectInputOptions. It is useless if second arg is NULL.

ok matthieu@@
@
text
@d16 1
a16 1
/* $OpenBSD: ws.c,v 1.42 2011/11/08 12:57:44 shadchin Exp $ */
d249 4
d255 1
a255 11
		priv->raw = xf86SetBoolOption(pInfo->options, "Raw", 0);
		if (priv->raw) {
			xf86IDrvMsg(pInfo, X_WARNING,
			    "Device is not a touch panel,"
			    "ignoring 'Option \"Raw\"'\n");
			priv->raw = 0;
		}
	}
	if (priv->raw) {
		xf86IDrvMsg(pInfo, X_CONFIG,
		    "device will work in raw mode\n");
@


1.42
log
@Mapping scroll events:
on 4 and 5 buttons (vertical scrolling)
on 6 and 7 buttons (horizontal scrolling)

This is do default xf86-input-mouse, xf86-input-evdev.
Also sync manual page.

ok matthieu@@
@
text
@d16 1
a16 1
/* $OpenBSD: ws.c,v 1.41 2011/11/08 12:55:26 shadchin Exp $ */
a136 1
	xf86CollectInputOptions(pInfo, NULL);
@


1.41
log
@Correct clean bit for scroll buttons plus small optimisation.

ok matthieu@@
@
text
@d16 1
a16 1
/* $OpenBSD: ws.c,v 1.40 2011/11/08 12:53:14 shadchin Exp $ */
d155 1
a155 1
	s = xf86SetStrOption(pInfo->options, "ZAxisMapping", "4 5 6 7");
d178 1
a178 1
	s = xf86SetStrOption(pInfo->options, "WAxisMapping", NULL);
@


1.40
log
@Process only changed button

ok matthieu@@
@
text
@d16 1
a16 1
/* $OpenBSD: ws.c,v 1.39 2011/11/08 12:51:32 shadchin Exp $ */
d154 1
a154 1
	priv->negativeZ =  priv->positiveZ = WS_NOZMAP;
d162 2
a163 2
			priv->negativeZ = b1;
			priv->positiveZ = b2;
d167 4
d177 1
a177 9
	if (priv->negativeZ > priv->buttons) {
		priv->buttons = priv->negativeZ;
		buttons_from = X_CONFIG;
	}
	if (priv->positiveZ > priv->buttons) {
		priv->buttons = priv->positiveZ;
		buttons_from = X_CONFIG;
	}
	priv->negativeW =  priv->positiveW = WS_NOZMAP;
d185 2
a186 2
			priv->negativeW = b1;
			priv->positiveW = b2;
d190 4
a199 8
	if (priv->negativeW > priv->buttons) {
		priv->buttons = priv->negativeW;
		buttons_from = X_CONFIG;
	}
	if (priv->positiveW > priv->buttons) {
		priv->buttons = priv->positiveW;
		buttons_from = X_CONFIG;
	}
d608 2
a609 2
					priv->negativeZ));
				zbutton = 1 << (priv->negativeZ - 1);
d612 2
a613 2
					priv->positiveZ));
				zbutton = 1 << (priv->positiveZ - 1);
d623 2
a624 2
					priv->negativeW));
				wbutton = 1 << (priv->negativeW - 1);
d627 2
a628 2
					priv->positiveW));
				wbutton = 1 << (priv->positiveW - 1);
@


1.39
log
@Fix memory leak

ok matthieu@@
@
text
@d16 1
a16 1
/* $OpenBSD: ws.c,v 1.38 2011/11/07 18:42:32 shadchin Exp $ */
d676 1
a676 1
	int button, mask;
d678 3
a680 1
	for (button = 1; button < NBUTTONS; button++) {
d682 6
a687 9
		if ((mask & priv->lastButtons) != (mask & buttons)) {
			if (!wsmbEmuFilterEvent(pInfo, button,
				(buttons & mask) != 0)) {
				xf86PostButtonEvent(pInfo->dev, TRUE,
				    button, (buttons & mask) != 0,
				    0, 0);
				DBG(3, ErrorF("post button event %d %d\n",
					button, (buttons & mask) != 0))
				    }
d689 1
a689 1
	} /* for */
@


1.38
log
@Replace xf86FindOptionValue on xf86SetStrOption.
If option set as "", then xf86FindOptionValue returns "",
and xf86SetStrOption returns NULL.

ok matthieu@@
@
text
@d16 1
a16 1
/* $OpenBSD: ws.c,v 1.37 2011/11/07 18:36:53 shadchin Exp $ */
d50 1
d98 1
a98 1
	NULL,
d171 1
d198 1
d244 1
d322 12
@


1.37
log
@Remove code for ABI_XINPUT_VERSION < 12

ok matthieu@@
@
text
@d16 1
a16 1
/* $OpenBSD: ws.c,v 1.36 2011/11/07 18:33:04 shadchin Exp $ */
d142 1
a142 1
	priv->devName = xf86FindOptionValue(pInfo->options, "Device");
d222 1
a222 1
	s = xf86FindOptionValue(pInfo->options, "Rotate");
@


1.36
log
@Replace xf86Msg on xf86IDrvMsg.
The latter provides a standardised message format in the form of
    driver name: device name: message

ok matthieu@@
@
text
@d16 1
a16 1
/* $OpenBSD: ws.c,v 1.35 2011/11/06 16:20:27 shadchin Exp $ */
d49 1
a49 4
#if GET_ABI_MAJOR(ABI_XINPUT_VERSION) < 12
static InputInfoPtr wsPreInit(InputDriverPtr, IDevPtr, int);
#endif
static int wsPreInit12(InputDriverPtr, InputInfoPtr, int);
a95 1
#if GET_ABI_MAJOR(ABI_XINPUT_VERSION) < 12
a96 3
#else
	wsPreInit12,
#endif
d122 1
a122 1
wsPreInit12(InputDriverPtr drv, InputInfoPtr pInfo, int flags)
a135 4
#if GET_ABI_MAJOR(ABI_XINPUT_VERSION) < 12
	xf86CollectInputOptions(pInfo, NULL, NULL);
	xf86ProcessCommonOptions(pInfo, pInfo->options);
#else
a136 1
#endif
d304 1
a304 6
#if GET_ABI_MAJOR(ABI_XINPUT_VERSION) < 12
	pInfo->conversion_proc = NULL;
	pInfo->reverse_conversion_proc = NULL;
	pInfo->old_x = -1;
	pInfo->old_y = -1;
#endif
a319 27
#if GET_ABI_MAJOR(ABI_XINPUT_VERSION) < 12
static InputInfoPtr
wsPreInit(InputDriverPtr drv, IDevPtr dev, int flags)
{
	InputInfoPtr pInfo = NULL;

	pInfo = xf86AllocateInput(drv, 0);
	if (pInfo == NULL) {
		return NULL;
	}
	pInfo->name = dev->identifier;
	pInfo->flags = XI86_POINTER_CAPABLE | XI86_SEND_DRAG_EVENTS;
	pInfo->conf_idev = dev;
	pInfo->close_proc = NULL;
	pInfo->private_flags = 0;
	pInfo->always_core_feedback = NULL;

	if (wsPreInit12(drv, pInfo, flags) != Success) {
		xf86DeleteInput(pInfo, 0);
		return NULL;
	}
	/* mark the device configured */
	pInfo->flags |= XI86_CONFIGURED;
	return pInfo;
}
#endif

d411 2
a412 5
	    xmin, xmax, 1, 0, 1
#if GET_ABI_MAJOR(ABI_XINPUT_VERSION) >= 12
	    , priv->type == WSMOUSE_TYPE_TPANEL  ? Absolute : Relative
#endif
	);
d417 2
a418 5
	    ymin, ymax, 1, 0, 1
#if GET_ABI_MAJOR(ABI_XINPUT_VERSION) >= 12
	    , priv->type == WSMOUSE_TYPE_TPANEL ? Absolute : Relative
#endif
	);
a420 4
#if GET_ABI_MAJOR(ABI_XINPUT_VERSION) < 12
	xf86MotionHistoryAllocate(pInfo);
	AssignTypeAndName(pWS, pInfo->atom, pInfo->name);
#endif
@


1.35
log
@Remove prototype wsChangeControl, this is missing in last change
@
text
@d16 1
a16 1
/* $OpenBSD: ws.c,v 1.34 2011/10/16 17:54:07 shadchin Exp $ */
d152 1
a152 2
	xf86Msg(X_INFO, "%s: debuglevel %d\n", pInfo->name,
	    ws_debug_level);
d156 1
a156 2
		xf86Msg(X_ERROR, "%s: No Device specified.\n",
			pInfo->name);
d175 3
a177 3
			xf86Msg(X_CONFIG,
			    "%s: ZAxisMapping: buttons %d and %d\n",
			    pInfo->name, b1, b2);
d179 2
a180 2
			xf86Msg(X_WARNING, "%s: invalid ZAxisMapping value: "
			    "\"%s\"\n", pInfo->name, s);
d201 3
a203 3
			xf86Msg(X_CONFIG,
			    "%s: WAxisMapping: buttons %d and %d\n",
			    pInfo->name, b1, b2);
d205 2
a206 2
			xf86Msg(X_WARNING, "%s: invalid WAxisMapping value: "
			    "\"%s\"\n", pInfo->name, s);
d219 2
a220 2
	xf86Msg(X_CONFIG, "%s associated screen: %d\n",
	    pInfo->name, priv->screen_no);
d229 2
a230 3
		xf86Msg(X_CONFIG,
		    "%s device will work with X and Y axes swapped\n",
		    pInfo->name);
d248 4
a251 4
			xf86Msg(X_ERROR, "\"%s\" is not a valid value "
				"for Option \"Rotate\"\n", s);
			xf86Msg(X_ERROR, "Valid options are \"CW\", \"CCW\","
				" or \"UD\"\n");
d270 2
a271 1
			xf86Msg(X_WARNING, "Device is not a touch panel,"
d277 2
a278 3
		xf86Msg(X_CONFIG,
		    "%s device will work in raw mode\n",
		    pInfo->name);
d284 2
a285 2
			xf86Msg(X_ERROR, "GCALIBCOORS failed %s\n",
			    strerror(errno));
d305 1
a305 2
	xf86Msg(X_INFO, "%s minimum x position: %d\n",
	    pInfo->name, priv->min_x);
d307 1
a307 2
	xf86Msg(X_INFO, "%s maximum x position: %d\n",
	    pInfo->name, priv->max_x);
d309 1
a309 2
	xf86Msg(X_INFO, "%s minimum y position: %d\n",
	    pInfo->name, priv->min_y);
d311 1
a311 2
	xf86Msg(X_INFO, "%s maximum y position: %d\n",
	    pInfo->name, priv->max_y);
d322 1
a322 1
	xf86Msg(buttons_from, "%s: Buttons: %d\n", pInfo->name, priv->buttons);
d386 1
a386 1
		xf86Msg(X_ERROR, "WS: unknown command %d\n", what);
d494 1
a494 1
		xf86Msg(X_ERROR, "wsOpen failed %s\n",
d502 1
a502 1
			xf86Msg(X_ERROR, "GCALIBCOORS failed %s\n",
d512 2
a513 2
				xf86Msg(X_ERROR, "SCALIBCOORS failed %s\n",
				    strerror(errno));
d521 1
a521 1
		xf86Msg(X_ERROR, "cannot alloc xisb buffer\n");
d544 1
a544 1
			xf86Msg(X_ERROR, "SCALIBCOORS failed %s\n",
d636 2
a637 2
			xf86Msg(X_WARNING, "%s: bad wsmouse event type=%d\n",
			    pInfo->name, event->type);
d750 1
a750 1
	    xf86Msg(X_ERROR, "%s: cannot open input device\n", pInfo->name);
d755 2
a756 2
		xf86Msg(X_ERROR, "%s: cannot set wsmouse event version\n",
		    pInfo->name);
d886 1
a886 1
			xf86Msg(X_ERROR, "SCALIBCOORDS failed %s\n",
@


1.34
log
@Some cleanup:
* remove trailing whitespace
* remove odd pInfo->private = priv
* remove wsChangeControl (not used)
* remove useless actions in wsControlProc

ok matthieu@@
@
text
@d16 1
a16 1
/* $OpenBSD: ws.c,v 1.33 2011/07/16 17:51:30 matthieu Exp $ */
a58 1
static int wsChangeControl(InputInfoPtr, xDeviceCtl *);
@


1.33
log
@Unifdef support for xinput ABI up to 10.
@
text
@d16 1
a16 1
/* $OpenBSD: ws.c,v 1.32 2011/04/24 15:55:12 matthieu Exp $ */
d129 1
a129 1
static int 
a322 1
	pInfo->control_proc = wsChangeControl;
a323 1
	pInfo->private = priv;
d618 1
a618 1
			if (event->value == 4095) 
a741 6
wsChangeControl(InputInfoPtr pInfo, xDeviceCtl *control)
{
	return BadMatch;
}

static int
d781 1
a781 3
	InputInfoPtr pInfo = device->public.devicePrivate;
	WSDevicePtr priv = (WSDevicePtr)pInfo->private;

a782 3
	priv->num = ctrl->num;
	priv->den = ctrl->den;
	priv->threshold = ctrl->threshold;
@


1.32
log
@xf86-input-ws 1.3.0:
- API compatibility with Xserver 1.10
- sync build system with other Xorg input modules
@
text
@d2 1
a2 1
 * Copyright Â© 2005-2009 Matthieu Herrb
d16 1
a16 1
/* $OpenBSD$ */
a38 11
#if GET_ABI_MAJOR(ABI_XINPUT_VERSION) > 10
#undef xalloc
#undef xcalloc

#define xcalloc calloc
#define xalloc malloc
#define Xcalloc calloc
#define Xalloc malloc
#define Xfree free
#endif

a40 1
#ifdef HAVE_PROPERTIES
a42 4
#endif

#if GET_ABI_MAJOR(ABI_XINPUT_VERSION) >= 7
#include <X11/Xatom.h>
a43 1
#endif
a64 1
#ifdef HAVE_PROPERTIES
a69 1
#endif
d137 1
a137 1
	priv = (WSDevicePtr)xcalloc(1, sizeof(WSDeviceRec));
d341 1
a341 1
		xfree(priv);
a408 1
#if GET_ABI_MAJOR(ABI_XINPUT_VERSION) >= 7
a410 1
#endif
a413 1
#if GET_ABI_MAJOR(ABI_XINPUT_VERSION) >= 7
a416 1
#endif
a420 1
#if GET_ABI_MAJOR(ABI_XINPUT_VERSION) >= 7
a421 1
#endif
a445 1
#if GET_ABI_MAJOR(ABI_XINPUT_VERSION) >= 7
a452 1
#endif
a454 1
#if GET_ABI_MAJOR(ABI_XINPUT_VERSION) >= 7
a455 4
#endif
#if GET_ABI_MAJOR(ABI_XINPUT_VERSION) < 3
		xf86GetMotionEvents,
#endif
a463 1
#if GET_ABI_MAJOR(ABI_XINPUT_VERSION) >= 7
a464 1
#endif
a472 1
#if GET_ABI_MAJOR(ABI_XINPUT_VERSION) >= 7
a473 1
#endif
a488 1
#ifdef HAVE_PROPERTIES
a491 1
#endif
a631 1
#ifdef WSCONS_EVENT_MOUSE_DELTA_Z
a635 2
#endif
#ifdef WSCONS_EVENT_MOUSE_ABSOLUTE_Z
a640 2
#endif
#ifdef WSCONS_EVENT_MOUSE_DELTA_W
a644 1
#endif
a725 1

a797 1
#ifdef HAVE_PROPERTIES
a912 1
#endif
@


1.31
log
@Remove unused screen_width and screen_height fields from
driver private data.
@
text
@d16 1
a16 1
/* $OpenBSD: ws.c,v 1.30 2010/01/10 15:22:47 matthieu Exp $ */
d28 1
a29 1

d39 11
d66 1
d68 2
d119 1
d121 3
d147 3
a149 2
static InputInfoPtr
wsPreInit(InputDriverPtr drv, IDevPtr dev, int flags)
a150 1
	InputInfoPtr pInfo = NULL;
d154 1
a155 4
	pInfo = xf86AllocateInput(drv, 0);
	if (pInfo == NULL) {
		return NULL;
	}
d157 2
a158 1
	if (priv == NULL)
d160 1
a160 3
	pInfo->flags = XI86_POINTER_CAPABLE | XI86_SEND_DRAG_EVENTS;
	pInfo->conf_idev = dev;
	pInfo->name = "ws";
d163 1
d166 3
d172 1
a172 1
	xf86Msg(X_INFO, "%s: debuglevel %d\n", dev->identifier,
d178 2
a179 1
			dev->identifier);
d242 1
a242 1
	    dev->identifier, priv->screen_no);
d253 1
a253 1
		    dev->identifier);
d278 1
d283 1
d301 1
a301 1
		    dev->identifier);
d310 1
d329 1
a329 1
	    dev->identifier, priv->min_x);
d332 1
a332 1
	    dev->identifier, priv->max_x);
d335 1
a335 1
	    dev->identifier, priv->min_y);
d338 1
a338 1
	    dev->identifier, priv->max_y);
a339 1
	pInfo->name = dev->identifier;
d344 2
a347 1
	pInfo->private = priv;
d350 1
d356 1
a357 3
	/* mark the device configured */
	pInfo->flags |= XI86_CONFIGURED;
	return pInfo;
d363 21
a383 1
	if (pInfo != NULL) {
d385 1
d387 3
a389 1
	return NULL;
d391 1
d425 1
a425 1
	WSDevicePtr priv = (WSDevicePtr)XI_PRIVATE(pWS);
d499 5
a503 1
	    xmin, xmax, 1, 0, 1);
d510 5
a514 1
	    ymin, ymax, 1, 0, 1);
d517 1
d520 1
d537 1
a537 1
	WSDevicePtr priv = (WSDevicePtr)XI_PRIVATE(pWS);
d583 1
a583 1
	WSDevicePtr priv = (WSDevicePtr)XI_PRIVATE(pWS);
@


1.30
log
@Typos in comments and error messages.
@
text
@d16 1
a16 1
/* $OpenBSD: ws.c,v 1.29 2009/12/31 18:01:14 matthieu Exp $ */
a394 3
	priv->screen_width = screenInfo.screens[priv->screen_no]->width;
	priv->screen_height = screenInfo.screens[priv->screen_no]->height;

@


1.29
log
@Default to ZAxisMapping 4 5 6 7.

This is what most users expect noawadays.
@
text
@d16 1
a16 1
/* $OpenBSD: ws.c,v 1.28 2009/12/10 22:32:02 matthieu Exp $ */
a45 1

d496 1
a496 1
		/* save calibration values */
d508 1
a508 1
				xf86Msg(X_ERROR, "GCALIBCOORS failed %s\n",
@


1.28
log
@Fix SwapXY and rotation support.
More work to do wrt properties and calibration.
@
text
@d16 1
a16 1
/* $OpenBSD: ws.c,v 1.27 2009/12/06 10:32:31 matthieu Exp $ */
d170 1
a170 1
	s = xf86SetStrOption(pInfo->options, "ZAxisMapping", NULL);
@


1.27
log
@Remove the input driver before returning NULL on error in PreInit().
@
text
@d16 1
a16 1
/* $OpenBSD: ws.c,v 1.26 2009/11/26 18:18:34 matthieu Exp $ */
d421 9
d467 1
d607 5
a611 5
			if (event->value != 4095) {
				ax = event->value;
				if (priv->inv_x)
					ax = priv->max_x - ax + priv->min_x;
			}
d691 7
d862 11
a872 4
			ax->min_value = priv->min_x;
			ax->max_value = priv->max_x;
			ay->min_value = priv->min_y;
			ay->max_value = priv->max_y;
@


1.26
log
@white space
@
text
@d16 1
a16 1
/* $OpenBSD: ws.c,v 1.25 2009/11/26 16:42:06 matthieu Exp $ */
d339 1
a339 1
	if (priv != NULL)
d341 5
a345 2
	if (pInfo != NULL)
		xfree(pInfo);
@


1.25
log
@Add middle mouse button emulation to xf86-input-ws.
Code stolen from evdev, that stole it from xf86-input mouse.
@
text
@d16 1
a16 1
/* $OpenBSD: ws.c,v 1.24 2009/11/26 10:57:35 matthieu Exp $ */
d88 1
a88 1
	PACKAGE_VERSION_MINOR, 
d155 1
a155 1
	xf86Msg(X_INFO, "%s: debuglevel %d\n", dev->identifier, 
d285 1
a285 1
		if (ioctl(pInfo->fd, WSMOUSEIO_GCALIBCOORDS, 
d395 1
a395 1
	
d405 1
a405 1
	
d441 1
a441 1
	
d448 1
a448 1
	
d494 1
a494 1
			if (ioctl(pInfo->fd, WSMOUSEIO_SCALIBCOORDS, 
d703 1
a703 1
			if (!wsmbEmuFilterEvent(pInfo, button, 
d773 1
a773 1
static void 
d793 1
a793 1
	prop_swap = MakeAtom(WS_PROP_SWAP_AXES, 
d797 1
a797 1
	if (rc != Success) 
d848 1
a848 1
		if (val->format != 8 || val->type != XA_INTEGER || 
d856 1
a856 1
	} 
@


1.24
log
@Set resx/resy fields of the wscons calibration structure to the saved
values when the calibration properties change.
@
text
@d2 1
a2 1
 * Copyright (c) 2005-2009 Matthieu Herrb
d16 1
a16 1
/* $OpenBSD: ws.c,v 1.23 2009/11/25 19:36:57 matthieu Exp $ */
d39 1
a39 3
#if GET_ABI_MAJOR(ABI_XINPUT_VERSION) >= 3
#define HAVE_PROPERTIES 1
#endif
a51 22
#define NAXES 2			/* X and Y axes only */
#define NBUTTONS 32		/* max theoretical buttons */
#define DFLTBUTTONS 3		/* default number of buttons */
#define NUMEVENTS 16		/* max # of ws events to read at once */

typedef struct WSDevice {
	char *devName;		/* device name */
	int type;		/* ws device type */
	unsigned int buttons;	/* # of buttons */
	unsigned int lastButtons; /* last state of buttons */
	int min_x, max_x, min_y, max_y; /* coord space */
	int swap_axes;
	int raw;
	int inv_x, inv_y;
	int screen_width, screen_height;
	int screen_no;
	int num, den, threshold; /* relative accel params */
	pointer buffer;
	int negativeZ, positiveZ; /* mappings for Z axis */
	int negativeW, positiveW; /* mappings for W axis */
	struct wsmouse_calibcoords coords; /* mirror of the kernel values */
} WSDeviceRec, *WSDevicePtr;
d77 4
a111 10
/* #undef DEBUG */
#define DEBUG
#undef DBG
static int debug_level = 0;
#ifdef DEBUG
# define DBG(lvl, f) { if ((lvl) <= debug_level) f;}
#else
# define DBG(lvl, f)
#endif

d153 4
a156 3
	debug_level = xf86SetIntOption(pInfo->options, "DebugLevel",
	    debug_level);
	xf86Msg(X_INFO, "%s: debuglevel %d\n", dev->identifier, debug_level);
d333 2
d464 1
d510 1
d523 1
d699 1
d703 8
a710 5
			xf86PostButtonEvent(pInfo->dev, TRUE,
			    button, (buttons & mask) != 0,
					    0, 0);
			DBG(3, ErrorF("post button event %d %d\n",
				button, (buttons & mask) != 0))
d813 1
a813 1
	DBG(1, ErrorF("wsSetProperty\n"));
d856 1
a856 3
	} else {
		return BadMatch;
	}
@


1.23
log
@Only default to raw mode for touchpanels. The raw mode doesn't make
sense for mices.
@
text
@d16 1
a16 1
/* $OpenBSD: ws.c,v 1.22 2009/11/25 19:31:35 matthieu Exp $ */
d894 2
@


1.22
log
@When calibrating directly update the axis structures with new min/max values.
In xserver 1.7 with axis labels, the init function used previously
makes no sense anymore.
@
text
@d16 1
a16 1
/* $OpenBSD: ws.c,v 1.21 2009/11/25 19:11:55 matthieu Exp $ */
a287 1
	priv->raw = xf86SetBoolOption(pInfo->options, "Raw", 1);
d295 1
a295 1
	if (priv->type == WSMOUSE_TYPE_TPANEL)
d297 2
a298 1
	else {
d300 1
@


1.21
log
@The raw mode is a lot more useful now. So enable it by default.
@
text
@d16 1
a16 1
/* $OpenBSD: ws.c,v 1.20 2009/11/25 18:14:23 matthieu Exp $ */
d829 2
d861 4
a864 4
			InitValuatorAxisStruct(device, 0,
			    priv->min_x, priv->max_x, 1, 0, 1);
			InitValuatorAxisStruct(device, 1, 
			    priv->min_y, priv->max_y, 1, 0, 1);
@


1.20
log
@No need to maintain a local cache of the pointer position anymore.
@
text
@d16 1
a16 1
/* $OpenBSD: ws.c,v 1.19 2009/11/25 18:10:26 matthieu Exp $ */
d288 1
a288 1
	priv->raw = xf86SetBoolOption(pInfo->options, "Raw", 0);
@


1.19
log
@Implement device properties for calibration data.
Setting the properties also write to the kernel table.
The calibration code can now change the data without quitting X.
@
text
@d16 1
a16 1
/* $OpenBSD: ws.c,v 1.18 2009/11/25 18:03:42 matthieu Exp $ */
a63 1
	int x, y;		/* current abs coordinates */
a483 3
	/* This should correspond to the center of the screen */
	priv->x = (priv->max_x - priv->min_x) / 2;
	priv->y = (priv->max_y - priv->min_y) / 2;
a704 1
			priv->x = ax;
a709 1
			priv->y = ay;
@


1.18
log
@Save a copy of the kernel calibration data in the private data and
use it to save/restore the state during DEVICE_ON/DEVICE_OFF.
@
text
@d16 1
a16 1
/* $OpenBSD: ws.c,v 1.17 2009/11/25 17:59:42 matthieu Exp $ */
d39 10
d94 7
d491 4
d796 109
@


1.17
log
@Send events upstreams one axis at a time.
@
text
@d16 1
a16 1
/* $OpenBSD: ws.c,v 1.16 2009/11/23 22:10:29 matthieu Exp $ */
d65 1
a146 1
	struct wsmouse_calibcoords coords;
d297 2
a298 1
		if (ioctl(pInfo->fd, WSMOUSEIO_GCALIBCOORDS, &coords) != 0) {
d306 4
a309 4
		priv->min_x = coords.minx;
		priv->max_x = coords.maxx;
		priv->min_y = coords.miny;
		priv->max_y = coords.maxy;
a482 1
	int raw;
d492 1
a492 2
		/* Set raw mode */
		raw = priv->raw;
d498 10
a507 6
		priv->raw = coords.samplelen;
		coords.samplelen = raw;
		if (ioctl(pInfo->fd, WSMOUSEIO_SCALIBCOORDS, &coords) != 0) {
			xf86Msg(X_ERROR, "GCALIBCOORS failed %s\n",
			    strerror(errno));
			return !Success;
a527 1
	int raw;
d531 2
a532 8
		/* Restore raw mode */
		raw = priv->raw;
		if (ioctl(pInfo->fd, WSMOUSEIO_GCALIBCOORDS, &coords) != 0) {
			xf86Msg(X_ERROR, "GCALIBCOORS failed %s\n",
			    strerror(errno));
		}
		priv->raw = coords.samplelen;
		coords.samplelen = raw;
d534 1
a534 1
			xf86Msg(X_ERROR, "GCALIBCOORS failed %s\n",
@


1.16
log
@conversion_proc is not used anymore since Xserver 1.5.
Don't define one that's never called.
@
text
@d16 1
a16 1
/* $OpenBSD: ws.c,v 1.15 2009/11/23 21:11:27 matthieu Exp $ */
a645 10
#if 0
			priv->x += dx;
			if (priv->x < priv->min_x) priv->x = priv->min_x;
			if (priv->x > priv->max_x) priv->x = priv->max_x;
			priv->y += dy;
			if (priv->y < priv->min_y) priv->y = priv->min_y;
			if (priv->y > priv->max_y) priv->y = priv->max_y;
			xf86PostMotionEvent(pInfo->dev, 1, 0, 2,
			    priv->x, priv->y);
#else
a647 1
#endif
d690 2
a691 3
			DBG(3, ErrorF("postMotionEvent X %d %d\n",
				      ax, priv->y));
			xf86PostMotionEvent(pInfo->dev, 1, 0, 2, ax, priv->y);
d696 2
a697 3
			DBG(3, ErrorF("postMotionEvent y %d %d\n",
				      priv->x, ay));
			xf86PostMotionEvent(pInfo->dev, 1, 0, 2, priv->x, ay);
d716 1
a716 1
					    0, 0); /*2, priv->x, priv->y);*/
@


1.15
log
@Fix previous for non tablet cases. the WSMOUSE_IO_GCALIBCOODS fails there.
@
text
@d16 1
a16 1
/* $OpenBSD: ws.c,v 1.14 2009/11/23 18:29:13 matthieu Exp $ */
a80 2
static Bool wsConvert(InputInfoPtr, int, int, int, int, int, int, int, int,
    int *, int *);
d335 1
a335 1
	pInfo->conversion_proc = wsConvert;
a778 36
}

static Bool
wsConvert(InputInfoPtr pInfo, int first, int num,
	  int v0, int v1, int v2, int v3, int v4, int v5,
	  int *x, int *y)
{
	WSDevicePtr priv = (WSDevicePtr) pInfo->private;
	if (first != 0 || num != 2) {
		return FALSE;
	}

	DBG(3, ErrorF("WSConvert: v0(%d), v1(%d)\n", v0, v1));

	if (priv->swap_axes != 0) {
		*x = xf86ScaleAxis(v1, 0, priv->screen_width - 1,
				   priv->min_y, priv->max_y);
		*y = xf86ScaleAxis(v0, 0, priv->screen_height - 1,
				   priv->min_x, priv->max_x);
	} else {
		*x = xf86ScaleAxis(v0, 0, priv->screen_width - 1,
				   priv->min_x, priv->max_x);
		*y = xf86ScaleAxis(v1, 0, priv->screen_height - 1,
				   priv->min_y, priv->max_y);
	}

	/*
	 * Need to check if still on the correct screen.
	 * This call is here so that this work can be done after
	 * calib and before posting the event.
	 */
	xf86XInputSetScreen(pInfo, priv->screen_no, *x, *y);

	DBG(3, ErrorF("WSConvert: x(%d), y(%d)\n", *x, *y));

	return TRUE;
@


1.14
log
@Implement a new "raw" mode that will put a panel in raw mode.
Calibration data is read from the kernel, so things still work in this
mode.
@
text
@d16 1
a16 1
/* $OpenBSD: ws.c,v 1.13 2009/11/23 17:36:23 matthieu Exp $ */
a274 5
	if (priv->raw) {
		xf86Msg(X_CONFIG,
		    "%s device will work in raw mode\n",
		    dev->identifier);
	}
d284 1
a284 1
	else
d286 11
d298 1
a298 1
	if (priv->raw) {
d492 16
a507 12
	raw = priv->raw;
	if (ioctl(pInfo->fd, WSMOUSEIO_GCALIBCOORDS, &coords) != 0) {
		xf86Msg(X_ERROR, "GCALIBCOORS failed %s\n",
		    strerror(errno));
		return !Success;
	}
	priv->raw = coords.samplelen;
	coords.samplelen = raw;
	if (ioctl(pInfo->fd, WSMOUSEIO_SCALIBCOORDS, &coords) != 0) {
		xf86Msg(X_ERROR, "GCALIBCOORS failed %s\n",
		    strerror(errno));
		return !Success;
d530 13
a542 10
	raw = priv->raw;
	if (ioctl(pInfo->fd, WSMOUSEIO_GCALIBCOORDS, &coords) != 0) {
		xf86Msg(X_ERROR, "GCALIBCOORS failed %s\n",
		    strerror(errno));
	}
	priv->raw = coords.samplelen;
	coords.samplelen = raw;
	if (ioctl(pInfo->fd, WSMOUSEIO_SCALIBCOORDS, &coords) != 0) {
		xf86Msg(X_ERROR, "GCALIBCOORS failed %s\n",
		    strerror(errno));
a543 1
 
@


1.13
log
@Another unused declaratin bites the dust.
@
text
@d16 1
a16 1
/* $OpenBSD: ws.c,v 1.12 2009/11/23 16:55:52 matthieu Exp $ */
d57 1
d148 1
a244 14
	priv->max_x = xf86SetIntOption(pInfo->options, "MaxX",
	    screenInfo.screens[priv->screen_no]->width - 1);
	xf86Msg(X_INFO, "%s maximum x position: %d\n",
	    dev->identifier, priv->max_x);
	priv->min_x = xf86SetIntOption(pInfo->options, "MinX", 0);
	xf86Msg(X_INFO, "%s minimum x position: %d\n",
	    dev->identifier, priv->min_x);
	priv->max_y = xf86SetIntOption(pInfo->options, "MaxY",
	    screenInfo.screens[priv->screen_no]->height - 1);
	xf86Msg(X_INFO, "%s maximum y position: %d\n",
	    dev->identifier, priv->max_y);
	priv->min_y = xf86SetIntOption(pInfo->options, "MinY", 0);
	xf86Msg(X_INFO, "%s minimum y position: %d\n",
	    dev->identifier, priv->min_y);
d274 6
d291 34
a324 1
	wsClose(pInfo);
d338 2
d477 2
d486 13
d516 2
d520 12
@


1.12
log
@- fix parameter orders for XInput 2 xf86InitValuatorAxisStruct() calls
- set min/max axis values for absolute valuators
@
text
@d16 1
a16 1
/* $OpenBSD: ws.c,v 1.11 2009/11/23 16:21:50 matthieu Exp $ */
a98 13

typedef enum {
	WSOPT_DEVICE,
	WSOPT_DEBUG_LEVEL,
	WSOPT_MINX,
	WSOPT_MAXX,
	WSOPT_MINY,
	WSOPT_MAXY,
	WSOPT_ROTATE,
	WSOPT_SWAPXY,
	WSOPT_SCREENNO,
	WSOPT_ZAXIS_MAPPING,
} WSOpts;
@


1.11
log
@Set buttons and axis labels for XInput 2.
@
text
@d16 1
a16 1
/* $OpenBSD: ws.c,v 1.10 2009/11/23 15:25:11 matthieu Exp $ */
d34 1
d369 1
a369 1
	int i;
d395 12
d431 1
a431 1
	xf86InitValuatorAxisStruct(pWS,
d435 1
a435 1
	    0, 0, -1, 1, 0, 1);
d438 1
a438 1
	xf86InitValuatorAxisStruct(pWS,
d442 1
a442 1
	    1, 0, -1, 1, 0, 1);
@


1.10
log
@Handle NetBSD's wsmouse ABI versions. From marc at msys dot ch. Thanks.
@
text
@d16 1
a16 1
/* $OpenBSD: ws.c,v 1.9 2009/11/23 15:16:52 matthieu Exp $ */
d38 5
d375 6
a380 1
	
d394 9
@


1.9
log
@split wsProc().
@
text
@d16 1
a16 1
/* $OpenBSD: ws.c,v 1.8 2009/11/23 14:00:17 matthieu Exp $ */
d667 3
d677 7
@


1.8
log
@typo. From marc@@msys.ch. Thanks.
@
text
@d16 1
a16 1
/* $OpenBSD: ws.c,v 1.7 2009/11/23 12:54:04 matthieu Exp $ */
d65 3
d333 28
d365 2
a366 2
    Atom btn_labels[NBUTTONS] = {0};
    Atom axes_labels[NAXES] = {0};
d369 9
a377 13
	switch (what) {
	case DEVICE_INIT:
		DBG(1, ErrorF("WS DEVICE_INIT\n"));

		priv->screen_width =
		    screenInfo.screens[priv->screen_no]->width;
		priv->screen_height =
		    screenInfo.screens[priv->screen_no]->height;

		for (i = 0; i < NBUTTONS; i++)
			map[i + 1] = i + 1;
		if (!InitButtonClassDeviceStruct(pWS,
			min(priv->buttons, NBUTTONS),
d379 1
a379 1
			btn_labels,
d381 5
a385 5
			map))
			return !Success;

		if (!InitValuatorClassDeviceStruct(pWS,
			NAXES,
d387 1
a387 1
			axes_labels,
d390 1
a390 1
			xf86GetMotionEvents,
d392 8
a399 8
			GetMotionHistorySize(),
			priv->type == WSMOUSE_TYPE_TPANEL ?
			Absolute : Relative))
			return !Success;
		if (!InitPtrFeedbackClassDeviceStruct(pWS, wsControlProc))
			return !Success;

		xf86InitValuatorAxisStruct(pWS,
d401 1
a401 1
                axes_labels[0],
d403 4
a406 4
		    0, 0, -1, 1, 0, 1);
		xf86InitValuatorDefaults(pWS, 0);

		xf86InitValuatorAxisStruct(pWS,
d408 1
a408 1
		    axes_labels[1],
d410 19
a428 12
		    1, 0, -1, 1, 0, 1);
		xf86InitValuatorDefaults(pWS, 1);
		xf86MotionHistoryAllocate(pInfo);
		AssignTypeAndName(pWS, pInfo->atom, pInfo->name);
		pWS->public.on = FALSE;
		/* This should correspond to the center of the screen */
		priv->x = (priv->max_x - priv->min_x) / 2;
		priv->y = (priv->max_y - priv->min_y) / 2;
		if (wsOpen(pInfo) != Success) {
			return !Success;
		}
		break;
d430 4
a433 5
	case DEVICE_ON:
		DBG(1, ErrorF("WS DEVICE ON\n"));
		if ((pInfo->fd < 0) && (wsOpen(pInfo) != Success)) {
			xf86Msg(X_ERROR, "wsOpen failed %s\n",
				strerror(errno));
d435 12
a446 10
		}
		priv->buffer = XisbNew(pInfo->fd,
		    sizeof(struct wscons_event) * NUMEVENTS);
		if (priv->buffer == NULL) {
			xf86Msg(X_ERROR, "cannot alloc xisb buffer\n");
			wsClose(pInfo);
			return !Success;
		}
		xf86AddEnabledDevice(pInfo);
		pWS->public.on = TRUE;
d448 5
a452 14
		break;

	case DEVICE_OFF:
		DBG(1, ErrorF("WS DEVICE OFF\n"));
		if (pInfo->fd >= 0) {
			xf86RemoveEnabledDevice(pInfo);
			wsClose(pInfo);
		}
		if (priv->buffer) {
			XisbFree(priv->buffer);
			priv->buffer = NULL;
		}
		pWS->public.on = FALSE;
		break;
d454 3
a456 2
	case DEVICE_CLOSE:
		DBG(1, ErrorF("WS DEVICE_CLOSE\n"));
d458 7
a464 8
		break;

	default:
		xf86Msg(X_ERROR, "WS: unknown command %d\n", what);
		return !Success;
	} /* switch */
	return Success;
} /* wsProc */
@


1.7
log
@Fetch the module version from autotools instead of hard-coding it.
@
text
@d16 1
a16 1
/* $OpenBSD: ws.c,v 1.6 2009/11/23 12:37:32 matthieu Exp $ */
d388 1
a388 1
		/* This sould correspond to the center of the screen */
@


1.6
log
@kill white space at EOL
@
text
@d16 1
a16 1
/* $OpenBSD: ws.c,v 1.5 2009/11/23 12:35:40 matthieu Exp $ */
d82 3
a84 1
	1, 0, 0,
@


1.5
log
@Set correct device type and mode in XInput structures.
@
text
@d16 1
a16 1
/* $OpenBSD: ws.c,v 1.4 2009/11/22 23:00:43 matthieu Exp $ */
d132 1
a132 1
	
d153 1
a153 1
	
d159 1
a159 1
	if (priv == NULL) 
d169 1
a169 1
	debug_level = xf86SetIntOption(pInfo->options, "DebugLevel", 
d175 1
a175 1
		xf86Msg(X_ERROR, "%s: No Device specified.\n", 
d185 1
a185 1
	s = xf86SetStrOption(pInfo->options, "ZAxisMapping", NULL);	
d189 1
a189 1
		if (sscanf(s, "%d %d", &b1, &b2) == 2 && 
d194 2
a195 2
			xf86Msg(X_CONFIG, 
			    "%s: ZAxisMapping: buttons %d and %d\n", 
d211 1
a211 1
	s = xf86SetStrOption(pInfo->options, "WAxisMapping", NULL);	
d215 1
a215 1
		if (sscanf(s, "%d %d", &b1, &b2) == 2 && 
d220 2
a221 2
			xf86Msg(X_CONFIG, 
			    "%s: WAxisMapping: buttons %d and %d\n", 
d238 2
a239 2
	xf86Msg(X_CONFIG, "%s associated screen: %d\n", 
	    dev->identifier, priv->screen_no);  
d245 1
a245 1
	priv->max_x = xf86SetIntOption(pInfo->options, "MaxX", 
d247 1
a247 1
	xf86Msg(X_INFO, "%s maximum x position: %d\n", 
d250 1
a250 1
	xf86Msg(X_INFO, "%s minimum x position: %d\n", 
d252 1
a252 1
	priv->max_y = xf86SetIntOption(pInfo->options, "MaxY", 
d254 1
a254 1
	xf86Msg(X_INFO, "%s maximum y position: %d\n", 
d257 1
a257 1
	xf86Msg(X_INFO, "%s minimum y position: %d\n", 
d262 1
a262 1
		xf86Msg(X_CONFIG, 
d295 1
a295 1
	if (priv->type == WSMOUSE_TYPE_TPANEL) 
d312 1
a312 1
	
d319 1
a319 1
	if (pInfo != NULL) 
d335 1
a335 1
 
d340 1
a340 1
		priv->screen_width = 
d342 1
a342 1
		priv->screen_height = 
d348 1
a348 1
			min(priv->buttons, NBUTTONS), 
d354 1
a354 1
		
d364 1
a364 1
			priv->type == WSMOUSE_TYPE_TPANEL ? 
d369 2
a370 2
		
		xf86InitValuatorAxisStruct(pWS, 
d376 2
a377 2
		
		xf86InitValuatorAxisStruct(pWS, 
d401 1
a401 1
		priv->buffer = XisbNew(pInfo->fd, 
d430 1
a430 1
		
d443 1
a443 1
	int n, c; 
d447 1
a447 1
	
d456 1
a456 1
	
d459 1
a459 1
	
d521 1
a521 1
			xf86Msg(X_WARNING, "%s: bad wsmouse event type=%d\n", 
d529 1
a529 1
			DBG(3, ErrorF("postMotionEvent dX %d dY %d\n", 
d538 1
a538 1
			xf86PostMotionEvent(pInfo->dev, 1, 0, 2, 
d541 1
a541 1
			xf86PostMotionEvent(pInfo->dev, 0, 0, 2, 
d545 1
a545 1
		if (dz && priv->negativeZ != WS_NOZMAP 
d549 1
a549 1
				DBG(4, ErrorF("Z -> button %d\n", 
d553 1
a553 1
				DBG(4, ErrorF("Z -> button %d\n", 
d586 1
a586 1
			DBG(3, ErrorF("postMotionEvent X %d %d\n", 
d593 1
a593 1
			DBG(3, ErrorF("postMotionEvent y %d %d\n", 
d613 1
a613 1
			    button, (buttons & mask) != 0, 
d657 1
a657 1
wsConvert(InputInfoPtr pInfo, int first, int num, 
d679 1
a679 1
  
d686 1
a686 1
	
d688 1
a688 1
	
@


1.4
log
@Get rid of the now unused remaining moduleInfoRec bits.
@
text
@d2 1
a2 1
 * Copyright (c) 2005 Matthieu Herrb
d16 1
a16 1
/* $OpenBSD: ws.c,v 1.3 2009/11/22 22:08:57 matthieu Exp $ */
d24 1
d45 1
d288 12
a301 1
	pInfo->type_name = "wscons pointer";
a307 1
	pInfo->fd = -1;
d347 2
a348 2
		InitPointerDeviceStruct((DevicePtr)pWS, map,
				min(priv->buttons, NBUTTONS),
d350 1
a350 1
                                btn_labels,
d352 7
a358 10
#if GET_ABI_MAJOR(ABI_XINPUT_VERSION) == 0
		    miPointerGetMotionEvents,
#elif GET_ABI_MAJOR(ABI_XINPUT_VERSION) < 3
		    GetMotionHistory, 
#endif
		    wsControlProc, 
#if GET_ABI_MAJOR(ABI_XINPUT_VERSION) == 0
		    miPointerGetMotionBufferSize()
#else
		    GetMotionHistorySize(), NAXES
d360 2
a361 2
#if GET_ABI_MAJOR(ABI_XINPUT_VERSION) >= 7
                                , axes_labels
d363 7
a369 1
		    );
a702 1

@


1.3
log
@Prepare for  ABI_XINPUT_VERSION 7.
Still missing the actual button and axis labeling,
this can be added at a later point in time.
@
text
@d16 1
a16 1
/* $OpenBSD: ws.c,v 1.2 2009/11/22 19:26:48 matthieu Exp $ */
a36 2
#include "xf86Module.h"

a59 1
static const OptionInfoRec *wsAvailableOptions(void *);
a101 14
static const OptionInfoRec WSOptions[] = {
	{ WSOPT_DEVICE, "device", OPTV_STRING, {0}, FALSE },
	{ WSOPT_DEBUG_LEVEL, "debugLevel", OPTV_INTEGER, {0}, FALSE },
	{ WSOPT_MINX, "minX", OPTV_INTEGER, {0}, FALSE },
	{ WSOPT_MAXX, "maxX", OPTV_INTEGER, {0}, FALSE },
	{ WSOPT_MINY, "minY", OPTV_INTEGER, {0}, FALSE },
	{ WSOPT_MAXY, "maxY", OPTV_INTEGER, {0}, FALSE },
	{ WSOPT_ROTATE, "rotate", OPTV_STRING, {0}, FALSE },
	{ WSOPT_SWAPXY, "swapxy", OPTV_BOOLEAN, {0}, FALSE },
	{ WSOPT_SCREENNO, "ScreenNo", OPTV_INTEGER, {0}, FALSE },
	{ WSOPT_ZAXIS_MAPPING, "ZAxisMapping", OPTV_STRING, {0}, FALSE },
	{ -1, NULL, OPTV_NONE, {0}, FALSE }
};

a141 6
}

static const OptionInfoRec *
wsAvailableOptions(void *unused)
{
	return WSOptions;
@


1.2
log
@unifdef XFree86Loader. It's mandatory nowadays.
@
text
@d16 1
a16 1
/* $OpenBSD: ws.c,v 1.7 2009/06/01 21:15:50 matthieu Exp $ */
d342 4
d360 3
d374 3
d378 5
a382 1
		xf86InitValuatorAxisStruct(pWS, 0, 0, -1, 1, 0, 1);
d385 5
a389 1
		xf86InitValuatorAxisStruct(pWS, 1, 0, -1, 1, 0, 1);
@


1.1
log
@Initial revision
@
text
@a36 1
#ifdef XFree86LOADER
a37 1
#endif
a59 1
#ifdef XFree86LOADER
a62 1
#endif
a142 1
#ifdef XFree86LOADER
a165 1
#endif /* XFree86LOADER */
@


1.1.1.1
log
@Re-import the wscons pointer input driver using the correct name.
@
text
@@
