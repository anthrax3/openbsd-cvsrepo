head	1.5;
access;
symbols
	OPENBSD_6_1_BASE:1.5
	OPENBSD_6_0:1.5.0.20
	OPENBSD_6_0_BASE:1.5
	OPENBSD_5_9:1.5.0.18
	OPENBSD_5_9_BASE:1.5
	OPENBSD_5_8:1.5.0.16
	OPENBSD_5_8_BASE:1.5
	OPENBSD_5_7:1.5.0.14
	OPENBSD_5_7_BASE:1.5
	OPENBSD_5_6:1.5.0.12
	OPENBSD_5_6_BASE:1.5
	OPENBSD_5_5:1.5.0.10
	OPENBSD_5_5_BASE:1.5
	OPENBSD_5_4:1.5.0.8
	OPENBSD_5_4_BASE:1.5
	OPENBSD_5_3:1.5.0.6
	OPENBSD_5_3_BASE:1.5
	OPENBSD_5_2:1.5.0.4
	OPENBSD_5_2_BASE:1.5
	OPENBSD_5_1_BASE:1.5
	OPENBSD_5_1:1.5.0.2
	OPENBSD_5_0:1.4.0.6
	OPENBSD_5_0_BASE:1.4
	OPENBSD_4_9:1.4.0.2
	OPENBSD_4_9_BASE:1.4
	OPENBSD_4_8:1.4.0.4
	OPENBSD_4_8_BASE:1.4
	OPENBSD_4_7:1.3.0.4
	OPENBSD_4_7_BASE:1.3
	OPENBSD_4_6:1.3.0.2
	OPENBSD_4_6_BASE:1.3
	OPENBSD_4_5:1.2.0.2
	OPENBSD_4_5_BASE:1.2
	OPENBSD_4_4:1.1.1.1.0.6
	OPENBSD_4_4_BASE:1.1.1.1
	OPENBSD_4_3_BASE:1.1.1.1
	OPENBSD_4_3:1.1.1.1.0.4
	OPENBSD_4_2:1.1.1.1.0.2
	OPENBSD_4_2_BASE:1.1.1.1
	v1_1_0:1.1.1.1
	xorg:1.1.1;
locks; strict;
comment	@ * @;


1.5
date	2011.11.05.13.47.11;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2010.06.13.11.10.57;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2009.05.03.13.40.35;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2008.08.23.13.57.32;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.26.19.51.34;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.11.26.19.51.34;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.5
log
@Update xf86-input-fpit to version 1.4.0
@
text
@/*
 * Copyright 1995, 1999 by Patrick Lecoanet, France. <lecoanet@@cena.dgac.fr>
 * Copyright 2002, Red Hat <alan@@redhat.com>
 *
 * This driver is a merge of the Elographics driver (from Patrick Lecoanet) and
 * the driver for Fujitsu Pen Computers from Rob Tsuk and John Apfelbaum.
 * 
 * Modified for Stylistic 3400 passive pen support by David Clay
 * Fixed processing of all packets
 * Detangled and simplified if-statement logic
 * Fixed hover-mode pointer movement
 * Added Passive parameter for passive displays
 * Added switch 3 for "right" mouse button
 * I might have broken active pen support. I can't test it.
 *   January 2005 <dave at claysrus.com>
 *
 * Stylistic 500, 1000, 1200, 2300 Support fixed by John Apfelbaum
 *   June 2001 <johnapf@@linuxlsate.com>
 *
 * Richard Miller-Smith <Richard.Miller-Smith@@philips.com>
 *
 * Fixed up for XFree86 4.2, cleaned up the junk, cured crash on pointer
 * setting.
 *                                                                            
 * Permission to use, copy, modify, distribute, and sell this software and its
 * documentation for any purpose is  hereby granted without fee, provided that
 * the  above copyright   notice appear  in   all  copies and  that both  that
 * copyright  notice   and   this  permission   notice  appear  in  supporting
 * documentation, and that   the  name of  Patrick  Lecoanet not  be  used  in
 * advertising or publicity pertaining to distribution of the software without
 * specific,  written      prior  permission.     The Authors   make  no
 * representations about the suitability of this software for any purpose.  It
 * is provided "as is" without express or implied warranty.                   
 *                                                                            
 * PATRICK LECOANET DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
 * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO
 * EVENT  SHALL PATRICK LECOANET BE LIABLE FOR ANY SPECIAL, INDIRECT OR
 * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
 * DATA  OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
 * TORTIOUS  ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
 * PERFORMANCE OF THIS SOFTWARE.
 *
 * RED HAT DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
 * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO
 * EVENT  SHALL RED HAT BE LIABLE FOR ANY SPECIAL, INDIRECT OR
 * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
 * DATA  OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
 * TORTIOUS  ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
 * PERFORMANCE OF THIS SOFTWARE.
 *
 */

#ifdef HAVE_CONFIG_H
#include "config.h"
#endif

#include <xorg-server.h>

#include <unistd.h>
#include <errno.h>
#include <string.h>

#  include <misc.h>
#  include <xf86.h>
#  include <xf86_OSproc.h>
#  include <xf86Xinput.h>
#  include <exevents.h>
#  include <randrstr.h>

#  include <xf86Module.h>

/*
 ***************************************************************************
 *
 * Default constants.
 *
 ***************************************************************************
 */
#define FPIT_PORT		"/dev/ttyS3"

#define FPIT_MAX_X		4100
#define FPIT_MIN_X		0
#define FPIT_MAX_Y		4100
#define FPIT_MIN_Y		0


/*
 ***************************************************************************
 *
 * Protocol constants.
 *
 ***************************************************************************
 */
#define FPIT_PACKET_SIZE		5
#define BUFFER_SIZE               (FPIT_PACKET_SIZE*20)

/*
 ***************************************************************************
 *
 * Screen orientation descriptors.
 *
 ***************************************************************************
 */

typedef enum {
	FPIT_INVERT_X     = 0x01,
	FPIT_INVERT_Y     = 0x02,
	FPIT_THEN_SWAP_XY = 0x04
} FpitOrientation;

/*
 ***************************************************************************
 *
 * Device private records.
 *
 ***************************************************************************
 */
typedef struct {
	char *fpitDev;		/* device file name */
	int screen_width;
	int screen_height;
	Rotation screen_rotation;
	int screen_no;
	int fpitOldX;		/* previous X position */
	int fpitOldY;		/* previous Y position */
	int fpitOldProximity;	/* previous proximity */
	int fpitOldButtons;	/* previous buttons state */
	int fpitMinX;		/* min X value */
	int fpitMinY;		/* min Y value */
	int fpitMaxX;		/* max X value */
	int fpitMaxY;		/* max Y value */
	int fpitIndex;		/* number of bytes read */
	unsigned char fpitData[BUFFER_SIZE];	/* data read on the device */
	FpitOrientation fpitBaseOrientation;	/* read from X config */
	FpitOrientation fpitTotalOrientation;	/* above + RandR */
	int fpitPassive;	/* translate passive buttons */
	int fpitTrackRandR;	/* check for, react to screen rotate/resize */
	/* XXX when this last option is unset, we provide "compatibly stupid"
	 * behavior. */
} FpitPrivateRec, *FpitPrivatePtr;




/*
 ***************************************************************************
 *
 * xf86FpitConvert --
 *	Convert extended valuators to x and y suitable for core motion
 *	events. Return True if ok and False if the requested conversion
 *	can't be done for the specified valuators.
 *
 ***************************************************************************
 */
static Bool xf86FpitConvert(InputInfoPtr pInfo, int first, int num, int v0, int v1, int v2, int v3, int v4, int v5, int *x, int *y)
{
	FpitPrivatePtr priv = (FpitPrivatePtr) pInfo->private;
	AxisInfoPtr axes = pInfo->dev->valuator->axes;
	if (first != 0 || num != 2) {
		return FALSE;
	}

	*x = xf86ScaleAxis(v0, 0, priv->screen_width, axes[0].min_value, axes[0].max_value);
	*y = xf86ScaleAxis(v1, 0, priv->screen_height, axes[1].min_value, axes[1].max_value);

	return TRUE;
}

/*
 ***************************************************************************
 *
 * xf86FpitSetUpAxes --
 *	Based on current screen resolution and, if RandR support is enabled,
 *	current rotation state, set up the XInput axes and orientation info.
 *
 ***************************************************************************
 */

static void xf86FpitSetUpAxes(DeviceIntPtr dev, FpitPrivatePtr priv)
{
	/*
	 * Device reports motions on 2 axes in absolute coordinates.
	 * Axes min and max values are reported in raw coordinates.
	 * Resolution is computed roughly by the difference between
	 * max and min values scaled from the approximate size of the
	 * screen to fit one meter.
	 */
	int quarter_turns;
        Atom axis_labels[2] = { 0, 0 };

	priv->screen_width = screenInfo.screens[priv->screen_no]->width;
	priv->screen_height = screenInfo.screens[priv->screen_no]->height;

	priv->fpitTotalOrientation = priv->fpitBaseOrientation;
	if (!priv->fpitTrackRandR)
		return;

	/* now apply transforms specified by RandR:
	 * slightly complicated because invertX/Y and swapXY don't commute. */
	priv->screen_rotation = RRGetRotation(screenInfo.screens[priv->screen_no]);
	quarter_turns = (
		(priv->screen_rotation & RR_Rotate_90  ? 1 : 0) +
		(priv->screen_rotation & RR_Rotate_180 ? 2 : 0) +
		(priv->screen_rotation & RR_Rotate_270 ? 3 : 0) ) % 4;
	if (quarter_turns / 2 != 0)
		priv->fpitTotalOrientation ^= FPIT_INVERT_X | FPIT_INVERT_Y;
	if (quarter_turns % 2 != 0) {
		priv->fpitTotalOrientation ^=
		    (priv->fpitTotalOrientation & FPIT_THEN_SWAP_XY ? FPIT_INVERT_X : FPIT_INVERT_Y)
		    | FPIT_THEN_SWAP_XY;
	}

	if (priv->fpitTotalOrientation & FPIT_THEN_SWAP_XY) {
		InitValuatorAxisStruct(dev, 1, axis_labels[1],
				       priv->fpitMinX, priv->fpitMaxX, 9500, 0 /* min_res */ ,
				       9500 /* max_res */, Absolute);
		InitValuatorAxisStruct(dev, 0, axis_labels[0],
				       priv->fpitMinY, priv->fpitMaxY, 10500, 0 /* min_res */ ,
				       10500 /* max_res */, Absolute);
	} else {
		InitValuatorAxisStruct(dev, 0, axis_labels[0],
				       priv->fpitMinX, priv->fpitMaxX, 9500, 0 /* min_res */ ,
				       9500 /* max_res */, Absolute);
		InitValuatorAxisStruct(dev, 1, axis_labels[1],
				       priv->fpitMinY, priv->fpitMaxY, 10500, 0 /* min_res */ ,
				       10500 /* max_res */, Absolute);
	}
}
/*
** xf86FpitReadInput
** Reads from the Fpit and posts any new events to the server.
*/
static void xf86FpitReadInput(InputInfoPtr pInfo)
{
	FpitPrivatePtr priv = (FpitPrivatePtr) pInfo->private;
	int len, loop;
	int is_core_pointer = 0;
	int x, y, buttons, prox;
	DeviceIntPtr device;
	int conv_x, conv_y;
	
	if (priv->fpitTrackRandR && (
		priv->screen_width  != screenInfo.screens[priv->screen_no]->width  ||
		priv->screen_height != screenInfo.screens[priv->screen_no]->height ||
		priv->screen_rotation != RRGetRotation(screenInfo.screens[priv->screen_no])
	))
		xf86FpitSetUpAxes(pInfo->dev, priv);

  do { /* keep reading blocks until there are no more */

	/* Read data into buffer */
	len = xf86ReadSerial(pInfo->fd, priv->fpitData+priv->fpitIndex, BUFFER_SIZE-priv->fpitIndex);
	if (len <= 0) {
		Error("error reading FPIT device");
		priv->fpitIndex = 0;
		return;
	}


	/* Since the Fujitsu only delivers data in an absolute mode, we
	   can look through the data backwards to find the last full and valid
	   position. (This may make cursor movement a bit faster) */

	/* DMC: We want to process ALL packets! This way, all points will come
			through and drawing curves are smoother. Also we won't miss any
			button events.
	*/

	priv->fpitIndex += len;


#define PHASING_BIT	0x80
#define PROXIMITY_BIT	0x20
#define BUTTON_BITS	0x07
#define SW1	0x01
#define SW2	0x02
#define SW3	0x04

	/* process each packet in this block */
/* Format of 5 bytes data packet for Fpit Tablets
     Byte 1
       bit  7   (0x80)  Phasing bit always 1
       bit  6   (0x40)  Switch status change
       bit  5   (0x20)  Proximity
       bit  4   (0x10)  Always 0
       bit  3   (0x08)  Test data
       bits 2-0 (0x07)  Buttons:
       bit  2   (0x04)   Sw3 (2nd side sw) 
       bit  1   (0x02)   Sw2 (1st side sw) 
       bit  0   (0x01)   Sw1 (Pen tip sw) 

     Byte 2
       bit  7   (0x80)  Always 0
       bits 6-0 (0x7f)  X6 - X0

     Byte 3
       bit  7   (0x80)  Always 0
       bits 6-0 (0x7f)  X13 - X7

     Byte 4
       bit  7   (0x80)  Always 0
       bits 6-0 (0x7f)  Y6 - Y0

     Byte 5
       bit  7   (0x80)  Always 0
       bits 6-0 (0x7f)  Y13 - Y7
*/
	for (loop=0;loop+FPIT_PACKET_SIZE<=priv->fpitIndex;loop++) { 
		if (!(priv->fpitData[loop] & PHASING_BIT)) continue; /* we don't have a start bit yet */

		x = (int) (priv->fpitData[loop + 1] & 0x7f) + ((int) (priv->fpitData[loop + 2] & 0x7f) << 7);
		y = (int) (priv->fpitData[loop + 3] & 0x7f) + ((int) (priv->fpitData[loop + 4] & 0x7f) << 7);
		/* Adjust to orientation */
		if (priv->fpitTotalOrientation & FPIT_INVERT_X)
			x = priv->fpitMaxX - x + priv->fpitMinX;
		if (priv->fpitTotalOrientation & FPIT_INVERT_Y)
			y = priv->fpitMaxY - y + priv->fpitMinY;
		if (priv->fpitTotalOrientation & FPIT_THEN_SWAP_XY) {
			int z = x; x = y; y = z;
		}

		prox = (priv->fpitData[loop] & PROXIMITY_BIT) ? 0 : 1;
		buttons = (priv->fpitData[loop] & BUTTON_BITS);
		device = pInfo->dev;

		xf86FpitConvert(pInfo, 0, 2, x, y, 0, 0, 0, 0, &conv_x, &conv_y);
		xf86XInputSetScreen(pInfo, priv->screen_no, conv_x, conv_y);

		/* coordinates are ready we can send events */

		if (prox!=priv->fpitOldProximity) /* proximity changed */
			if (!is_core_pointer) xf86PostProximityEvent(device, prox, 0, 2, x, y);

		if (priv->fpitOldX != x || priv->fpitOldY != y) /* position changed */
			xf86PostMotionEvent(device, 1, 0, 2, x, y);

		if (priv->fpitPassive) {
			/*
				For passive pen (Stylistic 3400, et al.):
				sw1 = 1 if pen is moving
				sw2 = 1 if pen was lifted from the pad / isn't in contact
				sw3 = 1 if right mouse-button icon was chosen
			*/
			/* convert the pen button bits to actual mouse buttons */
			if (buttons & SW2) buttons=0; /* the pen was lifted, so no buttons are pressed */
			else if (buttons & SW3) buttons=SW3; /* the "right mouse" button was pressed, so send down event */
			else if (prox) buttons=SW1; /* the "left mouse" button was pressed and we are not hovering, so send down event */
			else buttons=0; /* We are in hover mode, so not left-clicking. */
		}
		/* the active pen's buttons map directly to the mouse buttons. Right-click may happen even in hover mode. */
	
		/* DBG(2, ErrorF("%02d/%02d Prox=%d SW:%x Buttons:%x->%x (%d, %d)\n",
			loop,priv->fpitIndex,prox,priv->fpitData[loop]&BUTTON_BITS,priv->fpitOldButtons,buttons,x,y));*/

		if (priv->fpitOldButtons != buttons) {
			int delta;
			delta = buttons ^ priv->fpitOldButtons; /* set delta to the bits that have changed */
			while (delta) {
				int id;
				id = ffs(delta);
				delta &= ~(1 << (id - 1));
				xf86PostButtonEvent(device, 1, id, (buttons & (1 << (id - 1))), 0, 2, x, y);
				/* DBG(1, ErrorF("Button %d %s\n",id,(buttons & (1 << (id - 1)))?"DOWN":"UP"));*/
			}
			priv->fpitOldButtons = buttons;
		}
		priv->fpitOldX = x;
		priv->fpitOldY = y;
		priv->fpitOldProximity = prox;

		loop+=FPIT_PACKET_SIZE-1; /* advance to the next packet */
	} /* for each packet */

	/* remove from the data buffer all that we have processed */
	if (loop<priv->fpitIndex) memmove(priv->fpitData, priv->fpitData+loop,priv->fpitIndex-loop);
	priv->fpitIndex-=loop;

	/* DMC: My system did not read the pen-up event until another event was
			posted, the result was the button sticking down even though
			I had lifted the pen. So I am checking the device for more data
			and then retrieving it. This fixed it for me. I don't know if this is just my system. */

  } while (xf86WaitForInput(pInfo->fd,0)>0); /* go back and check for more data (we don't want to block for I/O!) */

	return;
}

static void xf86FpitPtrCtrl(DeviceIntPtr device, PtrCtrl *ctrl)
{
	/* I have no clue what this does, except that registering it stops the 
	   X server segfaulting in ProcGetPointerMapping()
	   Ho Hum.
	*/
}


/*
 ***************************************************************************
 *
 * xf86FpitControl --
 *
 ***************************************************************************
 */
static Bool xf86FpitControl(DeviceIntPtr dev, int mode)
{
	InputInfoPtr pInfo = (InputInfoPtr) dev->public.devicePrivate;
	FpitPrivatePtr priv = (FpitPrivatePtr) (pInfo->private);
	unsigned char map[] = {
		0, 1, 2, 3 /* DMC: changed this so we can use all three buttons */
	};
	Atom btn_labels[3] = { 0 };
	Atom axis_labels[2] = { 0, 0 };

	switch (mode) {
	case DEVICE_INIT:
		{

			if (priv->screen_no >= screenInfo.numScreens || priv->screen_no < 0) {
				priv->screen_no = 0;
			}
			/*
			 * Device reports button press for up to 3 buttons.
			 */
			if (InitButtonClassDeviceStruct(dev, 3, btn_labels, map) == FALSE) {
				ErrorF("Unable to allocate Fpit touchscreen ButtonClassDeviceStruct\n");
				return !Success;
			}

			if (InitFocusClassDeviceStruct(dev) == FALSE) {
				ErrorF("Unable to allocate Fpit touchscreen FocusClassDeviceStruct\n");
				return !Success;
			}

			if(InitPtrFeedbackClassDeviceStruct(dev, xf86FpitPtrCtrl) == FALSE) {
				ErrorF("Unable to allocate PtrFeedBackClassDeviceStruct\n");
			}

			if (InitValuatorClassDeviceStruct(dev, 2, axis_labels,
                                                          GetMotionHistorySize(), Absolute) == FALSE) {
				ErrorF("Unable to allocate Fpit touchscreen ValuatorClassDeviceStruct\n");
				return !Success;
			}
			xf86FpitSetUpAxes(dev, priv);

			if (InitFocusClassDeviceStruct(dev) == FALSE) {
				ErrorF("Unable to allocate Fpit touchscreen FocusClassDeviceStruct\n");
			}
			/*
			 * Allocate the motion events buffer.
			 */
			xf86MotionHistoryAllocate(pInfo);
			/*
			 * This once has caused the server to crash after doing a malloc & strcpy ??
			 */
			return Success;
		}

	case DEVICE_ON:
		if (pInfo->fd < 0) {
			pInfo->fd = xf86OpenSerial(pInfo->options);
			if (pInfo->fd < 0) {
				Error("Unable to open Fpit touchscreen device");
				return !Success;
			}

			xf86AddEnabledDevice(pInfo);
			dev->public.on = TRUE;
		}
		return Success;

		/*
		 * Deactivate the device. After this, the device will not emit
		 * events until a subsequent DEVICE_ON. Thus, we can momentarily
		 * close the port.
		 */
	case DEVICE_OFF:
		dev->public.on = FALSE;
		if (pInfo->fd >= 0) {
			xf86RemoveEnabledDevice(pInfo);
		}
		xf86CloseSerial(pInfo->fd);
		pInfo->fd = -1;
		return Success;
		/*
		 * Final close before server exit. This is used during server shutdown.
		 * Close the port and free all the resources.
		 */
	case DEVICE_CLOSE:
		dev->public.on = FALSE;
		if (pInfo->fd >= 0) {
			RemoveEnabledDevice(pInfo->fd);
		}
		xf86CloseSerial(pInfo->fd);
		pInfo->fd = -1;
		return Success;
	default:
		ErrorF("unsupported mode=%d\n", mode);
		return !Success;
	}
}

/*
 ***************************************************************************
 *
 * xf86FpitAllocate --
 *
 ***************************************************************************
 */
static int xf86FpitAllocate(InputDriverPtr drv, InputInfoPtr pInfo)
{
	FpitPrivatePtr priv;
	priv = malloc(sizeof(FpitPrivateRec));
	if (!priv)
		return BadAlloc;

	priv->fpitDev = strdup(FPIT_PORT);
	priv->screen_no = 0;
	priv->screen_width = -1;
	priv->screen_height = -1;
	priv->screen_rotation = RR_Rotate_0;
	priv->fpitMinX = FPIT_MIN_X;
	priv->fpitMaxX = FPIT_MAX_X;
	priv->fpitMinY = FPIT_MIN_Y;
	priv->fpitMaxY = FPIT_MAX_Y;
	priv->fpitOldX = priv->fpitOldY = -1;
	priv->fpitOldButtons = 0;
	priv->fpitOldProximity = 0;
	priv->fpitIndex = 0;
	priv->fpitPassive = 0;
	pInfo->name = XI_TOUCHSCREEN;
	pInfo->flags = 0 /* XI86_NO_OPEN_ON_INIT */ ;
	pInfo->device_control = xf86FpitControl;
	pInfo->read_input = xf86FpitReadInput;
	pInfo->control_proc = NULL;
	pInfo->switch_mode = NULL;
	pInfo->fd = -1;
	pInfo->dev = NULL;
	pInfo->private = priv;
	pInfo->type_name = "Fujitsu Stylistic";
	return Success;
}

static void xf86FpitUninit(InputDriverPtr drv, InputInfoPtr pInfo, int flags)
{
	FpitPrivatePtr priv = (FpitPrivatePtr) pInfo->private;
	xf86FpitControl(pInfo->dev, DEVICE_OFF);
	free(priv->fpitDev);
	free(priv);
	pInfo->private = NULL;
	xf86DeleteInput(pInfo, 0);
}

static char *default_options[] = {
	"BaudRate", "19200", "StopBits", "0", "DataBits", "8", "Parity", "None", "Vmin", "10", "Vtime", "1", "FlowControl", "None", NULL
};

static int xf86FpitInit(InputDriverPtr drv, InputInfoPtr pInfo, int flags)
{
	FpitPrivatePtr priv = NULL;
	char *str;
        int rc;

	rc = xf86FpitAllocate(drv, pInfo);
	if (rc != Success)
		return rc;

	priv = pInfo->private;
	str = xf86FindOptionValue(pInfo->options, "Device");
	if (!str) {
		xf86Msg(X_ERROR, "%s: No Device specified in FPIT module config.\n", pInfo->name);
		if (priv) {
			if (priv->fpitDev) {
				free(priv->fpitDev);
			}
			free(priv);
		}
		return BadValue;
	}
	priv->fpitDev = strdup(str);
	pInfo->name = xf86SetStrOption(pInfo->options, "DeviceName", XI_TOUCHSCREEN);
	xf86Msg(X_CONFIG, "FPIT device name: %s\n", pInfo->name);
	priv->screen_no = xf86SetIntOption(pInfo->options, "ScreenNo", 0);
	xf86Msg(X_CONFIG, "Fpit associated screen: %d\n", priv->screen_no);
	priv->fpitMaxX = xf86SetIntOption(pInfo->options, "MaximumXPosition", FPIT_MAX_X);
	xf86Msg(X_CONFIG, "FPIT maximum x position: %d\n", priv->fpitMaxX);
	priv->fpitMinX = xf86SetIntOption(pInfo->options, "MinimumXPosition", FPIT_MIN_X);
	xf86Msg(X_CONFIG, "FPIT minimum x position: %d\n", priv->fpitMinX);
	priv->fpitMaxY = xf86SetIntOption(pInfo->options, "MaximumYPosition", FPIT_MAX_Y);
	xf86Msg(X_CONFIG, "FPIT maximum y position: %d\n", priv->fpitMaxY);
	priv->fpitMinY = xf86SetIntOption(pInfo->options, "MinimumYPosition", FPIT_MIN_Y);
	xf86Msg(X_CONFIG, "FPIT minimum y position: %d\n", priv->fpitMinY);

	priv->fpitBaseOrientation = 0;
	if (xf86SetBoolOption(pInfo->options, "InvertX", 0))
		priv->fpitBaseOrientation |= FPIT_INVERT_X;
	if (xf86SetBoolOption(pInfo->options, "InvertY", 0))
		priv->fpitBaseOrientation |= FPIT_INVERT_Y;
	if (xf86SetBoolOption(pInfo->options, "SwapXY", 0))
		priv->fpitBaseOrientation |= FPIT_THEN_SWAP_XY;
	priv->fpitPassive = xf86SetBoolOption(pInfo->options, "Passive", 0);
	priv->fpitTrackRandR = xf86SetBoolOption(pInfo->options, "TrackRandR", 0);
	/* XXX "Rotate" option provides compatibly stupid behavior. JEB. */
	str = xf86SetStrOption(pInfo->options, "Rotate", 0);
	if (!xf86NameCmp(str, "CW"))
		priv->fpitBaseOrientation |= FPIT_INVERT_X | FPIT_INVERT_Y | FPIT_THEN_SWAP_XY;
	else if (!xf86NameCmp(str, "CCW"))
		priv->fpitBaseOrientation |= FPIT_THEN_SWAP_XY;
	xf86Msg(X_CONFIG, "FPIT invert X axis: %s\n", priv->fpitBaseOrientation & FPIT_INVERT_X ? "Yes" : "No");
	xf86Msg(X_CONFIG, "FPIT invert Y axis: %s\n", priv->fpitBaseOrientation & FPIT_INVERT_Y ? "Yes" : "No");
	xf86Msg(X_CONFIG, "FPIT swap X and Y axis: %s\n", priv->fpitBaseOrientation & FPIT_THEN_SWAP_XY ? "Yes" : "No");
	xf86Msg(X_CONFIG, "FPIT Passive button mode: %s\n", priv->fpitPassive ? "Yes" : "No");
	xf86Msg(X_CONFIG, "FPIT RandR tracking: %s\n", priv->fpitTrackRandR ? "Yes" : "No");
	return Success;
}


_X_EXPORT InputDriverRec FPIT = {
	1,			/* driver version */
	"fpit",			/* driver name */
	NULL,			/* identify */
	xf86FpitInit,		/* pre-init */
	xf86FpitUninit,		/* un-init */
	NULL,			/* module */
	default_options
};

static pointer Plug(pointer module, pointer options, int *errmaj, int *errmin)
{
	xf86AddInputDriver(&FPIT, module, 0);
	return module;
}

static void Unplug(pointer p)
{
}

static XF86ModuleVersionInfo version_rec = {
	"fpit",
	MODULEVENDORSTRING,
	MODINFOSTRING1,
	MODINFOSTRING2,
	XORG_VERSION_CURRENT,
	PACKAGE_VERSION_MAJOR, PACKAGE_VERSION_MINOR, PACKAGE_VERSION_PATCHLEVEL,
	ABI_CLASS_XINPUT,
	ABI_XINPUT_VERSION,
	MOD_CLASS_XINPUT, 
	{0, 0, 0, 0}
};

/*
 * This is the entry point in the module. The name
 * is setup after the pattern <module_name>ModuleData.
 * Do not change it.
 */
_X_EXPORT XF86ModuleData fpitModuleData = {
	&version_rec, Plug, Unplug
};
@


1.4
log
@merge X.Org git HEAD to get XINPUT ABI version 7 support.
@
text
@a51 1
/* $XFree86: xc/programs/Xserver/hw/xfree86/input/fpit/xf86Fpit.c,v 1.6 2004/04/26 22:48:21 dawes Exp $ */
d57 1
a57 1
#include <xorgVersion.h>
a71 1

d155 1
a155 1
static Bool xf86FpitConvert(LocalDevicePtr local, int first, int num, int v0, int v1, int v2, int v3, int v4, int v5, int *x, int *y)
d157 2
a158 2
	FpitPrivatePtr priv = (FpitPrivatePtr) local->private;
	AxisInfoPtr axes = local->dev->valuator->axes;
a188 1
#if GET_ABI_MAJOR(ABI_XINPUT_VERSION) >= 7
a189 1
#endif
d214 1
a214 4
		InitValuatorAxisStruct(dev, 1,
#if GET_ABI_MAJOR(ABI_XINPUT_VERSION) >= 7
				       axis_labels[1],
#endif
d216 2
a217 5
				       9500 /* max_res */ );
		InitValuatorAxisStruct(dev, 0,
#if GET_ABI_MAJOR(ABI_XINPUT_VERSION) >= 7
				       axis_labels[0],
#endif
d219 1
a219 1
				       10500 /* max_res */ );
d221 1
a221 4
		InitValuatorAxisStruct(dev, 0,
#if GET_ABI_MAJOR(ABI_XINPUT_VERSION) >= 7
				       axis_labels[0],
#endif
d223 2
a224 5
				       9500 /* max_res */ );
		InitValuatorAxisStruct(dev, 1,
#if GET_ABI_MAJOR(ABI_XINPUT_VERSION) >= 7
				       axis_labels[1],
#endif
d226 1
a226 1
				       10500 /* max_res */ );
d233 1
a233 1
static void xf86FpitReadInput(LocalDevicePtr local)
d235 1
a235 1
	FpitPrivatePtr priv = (FpitPrivatePtr) local->private;
d247 1
a247 1
		xf86FpitSetUpAxes(local->dev, priv);
d252 1
a252 1
	len = xf86ReadSerial(local->fd, priv->fpitData+priv->fpitIndex, BUFFER_SIZE-priv->fpitIndex);
d324 1
a324 4
		device = local->dev;
#if GET_ABI_MAJOR(ABI_XINPUT_VERSION) == 0
		is_core_pointer = xf86IsCorePointer(device);
#endif
d326 2
a327 2
		xf86FpitConvert(local, 0, 2, x, y, 0, 0, 0, 0, &conv_x, &conv_y);
		xf86XInputSetScreen(local, priv->screen_no, conv_x, conv_y);
d383 1
a383 1
  } while (xf86WaitForInput(local->fd,0)>0); /* go back and check for more data (we don't want to block for I/O!) */
d406 2
a407 2
	LocalDevicePtr local = (LocalDevicePtr) dev->public.devicePrivate;
	FpitPrivatePtr priv = (FpitPrivatePtr) (local->private);
a410 1
#if GET_ABI_MAJOR(ABI_XINPUT_VERSION) >= 7
a412 2
#endif

d424 1
a424 5
			if (InitButtonClassDeviceStruct(dev, 3,
#if GET_ABI_MAJOR(ABI_XINPUT_VERSION) >= 7
				      btn_labels,
#endif
				      map) == FALSE) {
d437 3
a439 9
	      
			if (InitValuatorClassDeviceStruct(dev, 2,
#if GET_ABI_MAJOR(ABI_XINPUT_VERSION) >= 7
				      axis_labels,
#endif
#if GET_ABI_MAJOR(ABI_XINPUT_VERSION) < 3
                                    xf86GetMotionEvents,
#endif
                                    local->history_size, Absolute) == FALSE) {
d451 1
a451 1
			xf86MotionHistoryAllocate(local);
d453 1
a453 1
			 * This once has caused the server to crash after doing an xalloc & strcpy ??
d459 3
a461 3
		if (local->fd < 0) {
			local->fd = xf86OpenSerial(local->options);
			if (local->fd < 0) {
d466 1
a466 1
			xf86AddEnabledDevice(local);
d478 2
a479 2
		if (local->fd >= 0) {
			xf86RemoveEnabledDevice(local);
d481 2
a482 2
		xf86CloseSerial(local->fd);
		local->fd = -1;
d490 2
a491 2
		if (local->fd >= 0) {
			RemoveEnabledDevice(local->fd);
d493 2
a494 2
		xf86CloseSerial(local->fd);
		local->fd = -1;
d509 1
a509 1
static LocalDevicePtr xf86FpitAllocate(InputDriverPtr drv)
a510 1
	LocalDevicePtr local;
d512 1
a512 1
	priv = xalloc(sizeof(FpitPrivateRec));
d514 1
a514 6
		return NULL;
	local = xf86AllocateInput(drv, 0);
	if (!local) {
		xfree(priv);
		return NULL;
	}
d530 11
a540 16
	local->name = XI_TOUCHSCREEN;
	local->flags = 0 /* XI86_NO_OPEN_ON_INIT */ ;
	local->device_control = xf86FpitControl;
	local->read_input = xf86FpitReadInput;
	local->control_proc = NULL;
	local->close_proc = NULL;
	local->switch_mode = NULL;
	local->conversion_proc = xf86FpitConvert;
	local->reverse_conversion_proc = NULL;
	local->fd = -1;
	local->atom = 0;
	local->dev = NULL;
	local->private = priv;
	local->type_name = "Fujitsu Stylistic";
	local->history_size = 0;
	return local;
d543 1
a543 1
static void xf86FpitUninit(InputDriverPtr drv, LocalDevicePtr local, int flags)
d545 6
a550 6
	FpitPrivatePtr priv = (FpitPrivatePtr) local->private;
	xf86FpitControl(local->dev, DEVICE_OFF);
	xfree(priv->fpitDev);
	xfree(priv);
	local->private = NULL;
	xf86DeleteInput(local, 0);
d553 1
a553 1
static const char *default_options[] = {
d557 1
a557 1
static InputInfoPtr xf86FpitInit(InputDriverPtr drv, IDevPtr dev, int flags)
a558 1
	LocalDevicePtr local = NULL;
d561 1
d563 6
a568 10
	local = xf86FpitAllocate(drv);
	if (!local)
		return NULL;

	priv = local->private;
	local->conf_idev = dev;
	xf86CollectInputOptions(local, default_options, NULL);
	/* Process the common options. */
	xf86ProcessCommonOptions(local, local->options);
	str = xf86FindOptionValue(local->options, "Device");
d570 1
a570 1
		xf86Msg(X_ERROR, "%s: No Device specified in FPIT module config.\n", dev->identifier);
d573 1
a573 1
				xfree(priv->fpitDev);
d575 1
a575 1
			xfree(priv);
d577 1
a577 1
		return local;
d580 3
a582 3
	local->name = xf86SetStrOption(local->options, "DeviceName", XI_TOUCHSCREEN);
	xf86Msg(X_CONFIG, "FPIT device name: %s\n", local->name);
	priv->screen_no = xf86SetIntOption(local->options, "ScreenNo", 0);
d584 1
a584 1
	priv->fpitMaxX = xf86SetIntOption(local->options, "MaximumXPosition", FPIT_MAX_X);
d586 1
a586 1
	priv->fpitMinX = xf86SetIntOption(local->options, "MinimumXPosition", FPIT_MIN_X);
d588 1
a588 1
	priv->fpitMaxY = xf86SetIntOption(local->options, "MaximumYPosition", FPIT_MAX_Y);
d590 1
a590 1
	priv->fpitMinY = xf86SetIntOption(local->options, "MinimumYPosition", FPIT_MIN_Y);
d594 1
a594 1
	if (xf86SetBoolOption(local->options, "InvertX", 0))
d596 1
a596 1
	if (xf86SetBoolOption(local->options, "InvertY", 0))
d598 1
a598 1
	if (xf86SetBoolOption(local->options, "SwapXY", 0))
d600 2
a601 2
	priv->fpitPassive = xf86SetBoolOption(local->options, "Passive", 0);
	priv->fpitTrackRandR = xf86SetBoolOption(local->options, "TrackRandR", 0);
d603 1
a603 1
	str = xf86SetStrOption(local->options, "Rotate", 0);
d613 1
a613 3
	/* mark the device configured */
	local->flags |= XI86_CONFIGURED;
	return local;
d624 1
a624 1
	0			/* ref count */
a626 1
#ifdef XFree86LOADER
a657 1
#endif
@


1.3
log
@update to xf86-input-fpit 1.3.0
@
text
@d191 3
d218 5
a222 1
		InitValuatorAxisStruct(dev, 1, priv->fpitMinX, priv->fpitMaxX, 9500, 0 /* min_res */ ,
d224 5
a228 1
		InitValuatorAxisStruct(dev, 0, priv->fpitMinY, priv->fpitMaxY, 10500, 0 /* min_res */ ,
d231 5
a235 1
		InitValuatorAxisStruct(dev, 0, priv->fpitMinX, priv->fpitMaxX, 9500, 0 /* min_res */ ,
d237 5
a241 1
		InitValuatorAxisStruct(dev, 1, priv->fpitMinY, priv->fpitMaxY, 10500, 0 /* min_res */ ,
d430 4
d446 5
a450 1
			if (InitButtonClassDeviceStruct(dev, 3, map) == FALSE) {
d465 3
d592 1
a592 2
	xfree(local->name);
	xfree(local);
@


1.2
log
@xf86-input-fpit 1.2.0
@
text
@d58 1
a58 1
#include <xf86Version.h>
d234 1
d322 3
d331 2
a332 6
		if (prox!=priv->fpitOldProximity) { /* proximity changed */
#if GET_ABI_MAJOR(ABI_XINPUT_VERSION) == 0
			if (xf86IsCorePointer(device) == 0)
#endif
			xf86PostProximityEvent(device, prox, 0, 2, x, y);
		}
d437 5
a441 1
			if (InitValuatorClassDeviceStruct(dev, 2, xf86GetMotionEvents, local->history_size, Absolute) == FALSE) {
@


1.1
log
@Initial revision
@
text
@a65 2
#  if !defined(DGUX)
#  endif
d69 1
a80 1
#define FPIT_LINK_SPEED		B19200	/* 19200 Baud                           */
a87 13
#define PHASING_BIT	0x80
#define PROXIMITY_BIT	0x20 /* DMC: This was 0x40 but the chart says its bit 5 which is 0x20 */
/*#define TABID_BIT	0x20  */
#define XSIGN_BIT	0x10
#define YSIGN_BIT	0x08
#define BUTTON_BITS	0x07
#define COORD_BITS	0x7f

/* DMC: Added these */
#define SW1	0x01
#define SW2	0x02
#define SW3	0x04

d102 14
d124 1
a125 2
	int fpitInc;		/* increment between transmits */
	int fpitButTrans;	/* button translation flags */
a133 4
	int fpitInvX;		/* Invert X axis */
	int fpitInvY;		/* Invert Y axis */
	int fpitRes;		/* resolution in lines per inch */
	int flags;		/* various flags */
a134 1
	int fpitBaud;		/* Baud rate of device */
d136 2
a137 1
	int fpitSwapXY;		/* swap X and Y values */
d139 3
d160 1
d165 54
a218 3
	if (priv->fpitSwapXY != 0) {
		*x = xf86ScaleAxis(v1, 0, priv->screen_width, priv->fpitMinY, priv->fpitMaxY);
		*y = xf86ScaleAxis(v0, 0, priv->screen_height, priv->fpitMinX, priv->fpitMaxX);
d220 4
a223 2
		*x = xf86ScaleAxis(v0, 0, priv->screen_width, priv->fpitMinX, priv->fpitMaxX);
		*y = xf86ScaleAxis(v1, 0, priv->screen_height, priv->fpitMinY, priv->fpitMaxY);
a224 1
	return TRUE;
a225 1

a233 1
	int is_core_pointer;
d238 7
d267 8
a275 3
	for (loop=0;loop+FPIT_PACKET_SIZE<=priv->fpitIndex;loop++) { 
		if (!(priv->fpitData[loop] & 0x80)) continue; /* we don't have a start bit yet */

d278 9
a286 8
       bit 7  Phasing bit always 1
       bit 6  Switch status change
       bit 5  Proximity
       bit 4  Always 0
       bit 3  Test data
       bit 2  Sw3 (2nd side sw) 
       bit 1  Sw2 (1st side sw) 
       bit 0  Sw1 (Pen tip sw) 
d289 2
a290 2
       bit 7  Always 0
       bits 6-0 = X6 - X0
d293 2
a294 2
       bit 7  Always 0
       bits 6-0 = X13 - X7
d297 2
a298 2
       bit 7  Always 0
       bits 6-0 = Y6 - Y0
d301 2
a302 2
       bit 7  Always 0
       bits 6-0 = Y13 - Y7
d304 2
d309 2
a310 2
		/* Add in any offsets */
		if (priv->fpitInvX)
d312 1
a312 1
		if (priv->fpitInvY)
d314 4
a320 1
		is_core_pointer = xf86IsCorePointer(device);
d325 1
a325 1
		/* coordonates are ready we can send events */
d327 6
a332 2
		if (prox!=priv->fpitOldProximity) /* proximity changed */
			if (!is_core_pointer) xf86PostProximityEvent(device, prox, 0, 2, x, y);
d341 1
a341 3
				sw1 = 0 if pen is not moving
				sw2 = 0 if pen is contacting the pad
				sw2 = 1 if pen was lifted from the pad
d348 1
a348 4
			else buttons=0; /* We are in hover mode, so no buttons */
		}
		else { /* the active pen's buttons map directly to the mouse buttons */
			if (!prox) buttons=0; /* We are in hover mode, so no buttons */
d350 1
a419 2
			priv->screen_width = screenInfo.screens[priv->screen_no]->width;
			priv->screen_height = screenInfo.screens[priv->screen_no]->height;
a436 7
			/*
			 * Device reports motions on 2 axes in absolute coordinates.
			 * Axes min and max values are reported in raw coordinates.
			 * Resolution is computed roughly by the difference between
			 * max and min values scaled from the approximate size of the
			 * screen to fit one meter.
			 */
d438 1
a438 1
				ErrorF("Unable to allocate Elographics touchscreen ValuatorClassDeviceStruct\n");
a439 5
			} else {
				InitValuatorAxisStruct(dev, 0, priv->fpitMinX, priv->fpitMaxX, 9500, 0 /* min_res */ ,
						       9500 /* max_res */ );
				InitValuatorAxisStruct(dev, 1, priv->fpitMinY, priv->fpitMaxY, 10500, 0 /* min_res */ ,
						       10500 /* max_res */ );
d441 1
d524 1
a532 1
	priv->fpitSwapXY = 0;
d598 1
a598 1
	priv->fpitMaxX = xf86SetIntOption(local->options, "MaximumXPosition", 4100);
d600 1
a600 1
	priv->fpitMinX = xf86SetIntOption(local->options, "MinimumXPosition", 0);
d602 1
a602 1
	priv->fpitMaxY = xf86SetIntOption(local->options, "MaximumYPosition", 4100);
d604 1
a604 1
	priv->fpitMinY = xf86SetIntOption(local->options, "MinimumYPosition", 0);
d606 8
a613 3
	priv->fpitInvX = xf86SetBoolOption(local->options, "InvertX", 0);
	priv->fpitInvY = xf86SetBoolOption(local->options, "InvertY", 0);
	priv->fpitSwapXY = xf86SetBoolOption(local->options, "SwapXY", 0);
d615 2
d618 7
a624 12
	if (!xf86NameCmp(str, "CW")) {
		priv->fpitInvX = 1;
		priv->fpitInvY = 1;
		priv->fpitSwapXY = 1;
	} else if (!xf86NameCmp(str, "CCW")) {
		priv->fpitInvX = 0;
		priv->fpitInvY = 0;
		priv->fpitSwapXY = 1;
	}
	xf86Msg(X_CONFIG, "FPIT invert X axis: %s\n", priv->fpitInvX ? "Yes" : "No");
	xf86Msg(X_CONFIG, "FPIT invert Y axis: %s\n", priv->fpitInvY ? "Yes" : "No");
	xf86Msg(X_CONFIG, "FPIT swap X and Y axis: %s\n", priv->fpitSwapXY ? "Yes" : "No");
d626 1
d632 1
d655 9
a663 1
	"fpit", MODULEVENDORSTRING, MODINFOSTRING1, MODINFOSTRING2, XORG_VERSION_CURRENT, 1, 1, 0, ABI_CLASS_XINPUT, ABI_XINPUT_VERSION, MOD_CLASS_XINPUT, 
@


1.1.1.1
log
@Importing xf86-input-fpit 1.1.0
@
text
@@
