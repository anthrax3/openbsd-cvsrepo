head	1.12;
access;
symbols
	OPENBSD_6_1:1.12.0.2
	OPENBSD_6_1_BASE:1.12
	OPENBSD_6_0:1.11.0.12
	OPENBSD_6_0_BASE:1.11
	OPENBSD_5_9:1.11.0.10
	OPENBSD_5_9_BASE:1.11
	OPENBSD_5_8:1.11.0.8
	OPENBSD_5_8_BASE:1.11
	OPENBSD_5_7:1.11.0.6
	OPENBSD_5_7_BASE:1.11
	OPENBSD_5_6:1.11.0.4
	OPENBSD_5_6_BASE:1.11
	OPENBSD_5_5:1.11.0.2
	OPENBSD_5_5_BASE:1.11
	OPENBSD_5_4:1.10.0.6
	OPENBSD_5_4_BASE:1.10
	OPENBSD_5_3:1.10.0.4
	OPENBSD_5_3_BASE:1.10
	OPENBSD_5_2:1.10.0.2
	OPENBSD_5_2_BASE:1.10
	OPENBSD_5_1_BASE:1.8
	OPENBSD_5_1:1.8.0.4
	OPENBSD_5_0:1.8.0.2
	OPENBSD_5_0_BASE:1.8
	OPENBSD_4_9:1.7.0.2
	OPENBSD_4_9_BASE:1.7
	OPENBSD_4_8:1.6.0.4
	OPENBSD_4_8_BASE:1.6
	OPENBSD_4_7:1.5.0.2
	OPENBSD_4_7_BASE:1.5
	OPENBSD_4_6:1.4.0.2
	OPENBSD_4_6_BASE:1.4
	OPENBSD_4_5:1.2.0.2
	OPENBSD_4_5_BASE:1.2
	OPENBSD_4_4:1.1.1.2.0.4
	OPENBSD_4_4_BASE:1.1.1.2
	OPENBSD_4_3_BASE:1.1.1.2
	OPENBSD_4_3:1.1.1.2.0.2
	v12_4_3:1.1.1.2
	OPENBSD_4_2:1.1.1.1.0.2
	OPENBSD_4_2_BASE:1.1.1.1
	v12_4_0:1.1.1.1
	xorg:1.1.1;
locks; strict;
comment	@ * @;


1.12
date	2017.01.21.18.40.20;	author matthieu;	state Exp;
branches;
next	1.11;
commitid	WS4oD9OADRw3XCXL;

1.11
date	2014.01.03.09.41.23;	author matthieu;	state Exp;
branches;
next	1.10;

1.10
date	2012.06.09.09.33.55;	author matthieu;	state Exp;
branches;
next	1.9;

1.9
date	2012.05.13.20.48.40;	author matthieu;	state Exp;
branches;
next	1.8;

1.8
date	2011.04.25.14.10.29;	author matthieu;	state Exp;
branches;
next	1.7;

1.7
date	2010.08.22.12.11.57;	author matthieu;	state Exp;
branches;
next	1.6;

1.6
date	2010.05.24.08.51.42;	author matthieu;	state Exp;
branches;
next	1.5;

1.5
date	2009.11.22.14.29.51;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2009.05.18.20.53.43;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2009.05.03.14.11.13;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2008.08.23.15.46.07;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.26.19.58.25;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.11.26.19.58.25;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2007.11.24.20.46.24;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.12
log
@Update to xf86-input-vmmouse 13.1.0
@
text
@/*
 * Copyright 1990,91 by Thomas Roell, Dinkelscherben, Germany.
 * Copyright 1993 by David Dawes <dawes@@xfree86.org>
 * Copyright 2002 by SuSE Linux AG, Author: Egbert Eich
 * Copyright 1994-2002 by The XFree86 Project, Inc.
 * Copyright 2002 by Paul Elliott
 * Copyright 2002-2006 by VMware, Inc.
 *
 * Permission to use, copy, modify, distribute, and sell this software and its
 * documentation for any purpose is hereby granted without fee, provided that
 * the above copyright notice appear in all copies and that both that
 * copyright notice and this permission notice appear in supporting
 * documentation, and that the names of copyright holders not be
 * used in advertising or publicity pertaining to distribution of the
 * software without specific, written prior permission.  The copyright holders
 * make no representations about the suitability of this
 * software for any purpose.  It is provided "as is" without express or
 * implied warranty.
 *
 * THE COPYRIGHT HOLDERS DISCLAIM ALL WARRANTIES WITH REGARD TO THIS
 * SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND
 * FITNESS, IN NO EVENT SHALL THE COPYRIGHT HOLDERS BE LIABLE FOR ANY
 * SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER
 * RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF
 * CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
 * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 *
 */

/*
 * vmmouse.c --
 *
 * 	This is a modified version of the mouse input driver
 * 	provided in Xserver/hw/xfree86/input/mouse/mouse.c
 *
 *      Although all data is read using the vmmouse protocol, notification
 *      is still done through the PS/2 port, so all the basic code for
 *      interacting with the port is retained.
 *
 */


/*****************************************************************************
 *	Standard Headers
 ****************************************************************************/
#ifdef HAVE_CONFIG_H
#include "config.h"
#endif

#include <stdio.h>
#include <X11/X.h>
#include <X11/Xproto.h>

#include "xf86.h"

#ifdef XINPUT
#include <X11/extensions/XI.h>
#include <X11/extensions/XIproto.h>
#include "extnsionst.h"
#include "extinit.h"
#else
#include "inputstr.h"
#endif

#include "xf86Xinput.h"
#include "xf86_OSproc.h"
#include "xf86OSmouse.h"
#include "xf86Priv.h"
#include "compiler.h"

#if GET_ABI_MAJOR(ABI_XINPUT_VERSION) >= 7
#include <xserver-properties.h>
#include "exevents.h"
#endif

#if GET_ABI_MAJOR(ABI_XINPUT_VERSION) < 18
#define LogMessageVerbSigSafe xf86MsgVerb
#endif

#include "xisb.h"
#include "mipointer.h"

#ifndef HAVE_XORG_SERVER_1_5_0
#include <xf86_ansic.h>
#include <xf86_libc.h>
#endif

/*****************************************************************************
 *	Local Headers
 ****************************************************************************/
#include "vmmouse_client.h"

/*
 * This is the only way I know to turn a #define of an integer constant into
 * a constant string.
 */
#define VMW_INNERSTRINGIFY(s) #s
#define VMW_STRING(str) VMW_INNERSTRINGIFY(str)

/*
 * So that the file compiles unmodified when dropped into an xfree source tree.
 */
#ifndef XORG_VERSION_CURRENT
#define XORG_VERSION_CURRENT XF86_VERSION_CURRENT
#endif

/*
 * Version constants
 */
#define VMMOUSE_DRIVER_VERSION \
   (PACKAGE_VERSION_MAJOR * 65536 + PACKAGE_VERSION_MINOR * 256 + PACKAGE_VERSION_PATCHLEVEL)
#define VMMOUSE_DRIVER_VERSION_STRING \
    VMW_STRING(PACKAGE_VERSION_MAJOR) "." VMW_STRING(PACKAGE_VERSION_MINOR) \
    "." VMW_STRING(PACKAGE_VERSION_PATCHLEVEL)

/*
 * Standard four digit version string expected by VMware Tools installer.
 * As the driver's version is only  {major, minor, patchlevel},
 * The fourth digit may describe the commit number relative to the
 * last version tag as output from `git describe`
 */
#ifdef __GNUC__
#ifdef VMW_SUBPATCH
const char vm_mouse_version[] __attribute__((section(".modinfo"),unused)) =
    "version=" VMMOUSE_DRIVER_VERSION_STRING "." VMW_STRING(VMW_SUBPATCH);
#else
const char vm_mouse_version[] __attribute__((section(".modinfo"),unused)) =
    "version=" VMMOUSE_DRIVER_VERSION_STRING ".0";
#endif /*VMW_SUBPATCH*/
#endif


/*****************************************************************************
 *	static function header
 ****************************************************************************/
#if GET_ABI_MAJOR(ABI_XINPUT_VERSION) >= 12
static int VMMousePreInit(InputDriverPtr drv, InputInfoPtr pInfo, int flags);
#else
static InputInfoPtr VMMousePreInit(InputDriverPtr drv, IDevPtr dev, int flags);
static void VMMouseCloseProc(InputInfoPtr pInfo);
static Bool VMMouseConvertProc(InputInfoPtr pInfo, int first, int num, int v0, int v1, int v2,
			       int v3, int v4, int v5, int *x, int *y);
#endif
static void VMMouseUnInit(InputDriverPtr drv, InputInfoPtr pInfo, int flags);
static void MouseCommonOptions(InputInfoPtr pInfo);
static void GetVMMouseMotionEvent(InputInfoPtr pInfo);
static void VMMousePostEvent(InputInfoPtr pInfo, int buttons, int dx, int dy, int dz, int dw);
static void VMMouseDoPostEvent(InputInfoPtr pInfo, int buttons, int dx, int dy);
static Bool VMMouseDeviceControl(DeviceIntPtr device, int mode);
static int  VMMouseControlProc(InputInfoPtr pInfo, xDeviceCtl * control);
static void VMMouseReadInput(InputInfoPtr pInfo);
static int  VMMouseSwitchMode(ClientPtr client, DeviceIntPtr dev, int mode);
static void MouseCtrl(DeviceIntPtr device, PtrCtrl *ctrl);

/******************************************************************************
 *		Definitions
 *****************************************************************************/
typedef struct {
   int                 screenNum;
   Bool                vmmouseAvailable;
   VMMOUSE_INPUT_DATA  vmmousePrevInput;
   Bool                isCurrRelative;
   Bool                absoluteRequested;
} VMMousePrivRec, *VMMousePrivPtr;

#if GET_ABI_MAJOR(ABI_XINPUT_VERSION) < 7
static const char *reqSymbols[] = {
   "InitPointerDeviceStruct",
   "LoaderSymbol",
   "LoadSubModule",
   "miPointerGetMotionBufferSize",
   "miPointerGetMotionEvents",
   "screenInfo",
   "Xcalloc",
   "xf86AddEnabledDevice",
   "xf86AddInputDriver",
   "xf86AddModuleInfo",
   "xf86AllocateInput",
   "xf86BlockSIGIO",
   "xf86CloseSerial",
   "xf86CollectInputOptions",
   "xf86ffs",
   "xf86FlushInput",
   "xf86GetAllowMouseOpenFail",
   "xf86GetMotionEvents",
   "xf86InitValuatorAxisStruct",
   "xf86InitValuatorDefaults",
   "xf86LoaderCheckSymbol",
   "xf86MotionHistoryAllocate",
   "xf86Msg",
   "xf86NameCmp",
   "xf86OpenSerial",
   "xf86OSMouseInit",
   "xf86PostButtonEvent",
   "xf86PostMotionEvent",
   "xf86ProcessCommonOptions",
   "xf86RemoveEnabledDevice",
   "xf86SetIntOption",
   "xf86SetStrOption",
   "xf86sprintf",
   "xf86sscanf",
   "xf86UnblockSIGIO",
   "xf86usleep",
   "xf86XInputSetScreen",
   "Xfree",
   "XisbBlockDuration",
   "XisbFree",
   "XisbNew",
   "XisbRead",
   "Xstrdup",
   NULL
};
#endif

InputDriverRec VMMOUSE = {
   1,
   "vmmouse",
   NULL,
   VMMousePreInit,
   VMMouseUnInit,
   NULL
#if GET_ABI_MAJOR(ABI_XINPUT_VERSION) < 11
       ,
   0
#endif
};

static char reverseMap[32] = { 0,  4,  2,  6,  1,  5,  3,  7,
			       8, 12, 10, 14,  9, 13, 11, 15,
			      16, 20, 18, 22, 17, 21, 19, 23,
			      24, 28, 26, 30, 25, 29, 27, 31};

#define reverseBits(map, b)	(((b) & ~0x0f) | map[(b) & 0x0f])

#if GET_ABI_MAJOR(ABI_XINPUT_VERSION) >= 12
#if GET_ABI_MAJOR(ABI_XINPUT_VERSION) < 14

static InputOption*
input_option_new(InputOption *list, char *key, char *value)
{
   InputOption *new;

   new = calloc(1, sizeof(InputOption));
   new->key = key;
   new->value = value;
   new->next = list;
   return new;
}

static void
input_option_free_list(InputOption **opts)
{
   InputOption *tmp = *opts;
   while(*opts)
   {
      tmp = (*opts)->next;
      free((*opts)->key);
      free((*opts)->value);
      free((*opts));
      *opts = tmp;
   }
}
#endif

static int
VMMouseInitPassthru(InputDriverPtr drv, InputInfoPtr pInfo, int flags)
{
   InputAttributes *attrs = NULL;
   InputOption *input_options = NULL;
   pointer options;
   DeviceIntPtr dev;
   int rc;

   options = xf86OptionListDuplicate(pInfo->options);
   options = xf86ReplaceStrOption(options, "Driver", "mouse");

   while(options) {
      input_options = input_option_new(input_options,
                                       xf86OptionName(options),
                                       xf86OptionValue(options));
      options = xf86NextOption(options);
   }

   rc = NewInputDeviceRequest(input_options, attrs, &dev);

   input_option_free_list(&input_options);

   return rc;
}

#else /* if ABI_XINPUT_VERSION < 12 */
static InputInfoPtr
VMMouseInitPassthru(InputDriverPtr drv, IDevPtr dev, int flags)
{
   InputDriverRec *passthruMouse;
   passthruMouse = (InputDriverRec *)LoaderSymbol("MOUSE");
   if(passthruMouse != NULL) {
      return (passthruMouse->PreInit)(drv, dev, flags);
   } else {
      return NULL;
   }
}
#endif

/*
 *----------------------------------------------------------------------
 *
 * VMMousePreInit --
 *	This function collect all the information that is necessary to
 *	determine the configuration of the hardware and to prepare the
 *	device for being used
 *
 * Results:
 * 	An InputInfoPtr object which points to vmmouse's information,
 *	if the absolute pointing device available
 *	Otherwise, an InputInfoPtr of regular mouse
 *
 * Side effects:
 * 	VMMouse was initialized with necessary information
 *
 *----------------------------------------------------------------------
 */

#if GET_ABI_MAJOR(ABI_XINPUT_VERSION) < 12
static int
VMMouseNewPreInit(InputDriverPtr drv, InputInfoPtr pInfo, int flags);

static InputInfoPtr
VMMousePreInit(InputDriverPtr drv, IDevPtr dev, int flags)
{
   InputInfoPtr pInfo;

#ifndef NO_MOUSE_MODULE
{
   OSMouseInfoPtr osInfo = NULL;

   /*
    * let Xserver init the mouse first
    */
   osInfo = xf86OSMouseInit(0);
   if (!osInfo)
      return FALSE;
}
#endif

   /*
    * enable hardware access
    */
   if (!xorgHWAccess) {
      if (xf86EnableIO())
          xorgHWAccess = TRUE;
      else
          return NULL;
   }

   /*
    * try to enable vmmouse here
    */
   if (!VMMouseClient_Enable()) {
      /*
       * vmmouse failed
       * Fall back to normal mouse module
       */
      xf86Msg(X_ERROR, "VMWARE(0): vmmouse enable failed\n");
      return VMMouseInitPassthru(drv, dev, flags);
   } else {
      /*
       * vmmouse is available
       */
      xf86Msg(X_INFO, "VMWARE(0): vmmouse is available\n");
      /*
       * Disable the absolute pointing device for now
       * It will be enabled during DEVICE_ON phase
       */
      VMMouseClient_Disable();
   }

   if (!(pInfo = xf86AllocateInput(drv, 0))) {
      return NULL;
   }

   pInfo->name = dev->identifier;
#if GET_ABI_MAJOR(ABI_XINPUT_VERSION) == 0
   pInfo->motion_history_proc = xf86GetMotionEvents;
#endif
   pInfo->close_proc = VMMouseCloseProc;
   pInfo->conversion_proc = VMMouseConvertProc;
   pInfo->reverse_conversion_proc = NULL;
   pInfo->fd = -1;
   pInfo->dev = NULL;
   pInfo->private_flags = 0;
   pInfo->always_core_feedback = 0;
   pInfo->conf_idev = dev;
   pInfo->flags = XI86_POINTER_CAPABLE | XI86_SEND_DRAG_EVENTS;

   /* Collect the options, and process the common options. */
   xf86CollectInputOptions(pInfo, NULL, NULL);
   xf86ProcessCommonOptions(pInfo, pInfo->options);

   if (VMMouseNewPreInit(drv, pInfo, flags) == Success)
       pInfo->flags |= XI86_CONFIGURED;

   return pInfo;
}

static int
VMMouseNewPreInit(InputDriverPtr drv, InputInfoPtr pInfo, int flags)
#else /* if ABI_XINPUT_VERSION >= 12 */
static int
VMMousePreInit(InputDriverPtr drv, InputInfoPtr pInfo, int flags)
#endif
{
   MouseDevPtr pMse = NULL;
   VMMousePrivPtr mPriv = NULL;
   int rc = Success;

   /* Enable hardware access. */
   if (!xorgHWAccess) {
      if (xf86EnableIO())
          xorgHWAccess = TRUE;
      else {
          rc = BadValue;
          goto error;
      }
   }

#if GET_ABI_MAJOR(ABI_XINPUT_VERSION) >= 12
   /* For ABI < 12, we need to return the wrapped driver's pInfo (see
    * above). ABI 12, we call NIDR and are done */
   if (!VMMouseClient_Enable()) {
      xf86Msg(X_ERROR, "VMWARE(0): vmmouse enable failed\n");
      return VMMouseInitPassthru(drv, pInfo, flags);
   } else {
      xf86Msg(X_INFO, "VMWARE(0): vmmouse is available\n");
      VMMouseClient_Disable();
   }
#endif

   mPriv = calloc (1, sizeof (VMMousePrivRec));

   if (!mPriv) {
      rc = BadAlloc;
      goto error;
   }

   mPriv->absoluteRequested = FALSE;
   mPriv->vmmouseAvailable = TRUE;

   /* Settup the pInfo */
   pInfo->type_name = XI_MOUSE;
   pInfo->device_control = VMMouseDeviceControl;
   pInfo->read_input = VMMouseReadInput;
   pInfo->control_proc = VMMouseControlProc;
   pInfo->switch_mode = VMMouseSwitchMode;

   /* Allocate the MouseDevRec and initialise it. */
   if (!(pMse = calloc(sizeof(MouseDevRec), 1))) {
      rc = BadAlloc;
      goto error;
   }

   pInfo->private = pMse;
   pMse->Ctrl = MouseCtrl;
   pMse->PostEvent = VMMousePostEvent;
   pMse->CommonOptions = MouseCommonOptions;
   pMse->mousePriv = mPriv;


   /* Check if the device can be opened. */
   pInfo->fd = xf86OpenSerial(pInfo->options);
   if (pInfo->fd == -1) {
      if (xf86GetAllowMouseOpenFail())
	 xf86Msg(X_WARNING, "%s: cannot open input device\n", pInfo->name);
      else {
	 xf86Msg(X_ERROR, "%s: cannot open input device\n", pInfo->name);
	 rc = BadValue;
	 goto error;
      }
   }
   xf86CloseSerial(pInfo->fd);
   pInfo->fd = -1;

   /* Process the options */
   pMse->CommonOptions(pInfo);

   /* set up the current screen num */
   mPriv->screenNum = xf86SetIntOption(pInfo->options, "ScreenNumber", 0);

   return Success;

error:
   pInfo->private = NULL;
   if (mPriv)
      free(mPriv);
   if (pMse)
      free(pMse);

   return rc;
}


/*
 *----------------------------------------------------------------------
 *
 * MouseCtrl --
 *     Alter the control paramters for the mouse.
 *
 * Results:
 * 	None
 *
 * Side effects:
 * 	None
 *
 *----------------------------------------------------------------------
 */

static void
MouseCtrl(DeviceIntPtr device, PtrCtrl *ctrl)
{
    InputInfoPtr pInfo;
    MouseDevPtr pMse;

    pInfo = device->public.devicePrivate;
    pMse = pInfo->private;

#ifdef EXTMOUSEDEBUG
    xf86Msg(X_INFO, "VMMOUSE(0): MouseCtrl pMse=%p\n", pMse);
#endif

    pMse->num       = ctrl->num;
    pMse->den       = ctrl->den;
    pMse->threshold = ctrl->threshold;
}


/*
 *----------------------------------------------------------------------
 *
 * VMMouseDoPostEvent --
 *	Post the mouse button event and mouse motion event to Xserver
 *
 * Results:
 * 	None
 *
 * Side effects:
 * 	Mouse location and button status was updated
 *
 *----------------------------------------------------------------------
 */

static void
VMMouseDoPostEvent(InputInfoPtr pInfo, int buttons, int dx, int dy)
{
    MouseDevPtr pMse;
    VMMousePrivPtr mPriv;
    int truebuttons;
    int id, change;
    Bool mouseMoved = FALSE;

    pMse = pInfo->private;
    mPriv = (VMMousePrivPtr)pMse->mousePriv;

    /*
     * The following truebuttons/reverseBits and lastButtons are
     * used to compare the current buttons and the previous buttons
     * to find the button changes during two mouse events
     */
    truebuttons = buttons;

    buttons = reverseBits(reverseMap, buttons);

    if (mPriv->isCurrRelative) {
       mouseMoved = dx || dy;
    } else {
       mouseMoved = (dx != mPriv->vmmousePrevInput.X) ||
                    (dy != mPriv->vmmousePrevInput.Y) ||
                    (mPriv->vmmousePrevInput.Flags & VMMOUSE_MOVE_RELATIVE);
    }
    if (mouseMoved) {

#ifdef CALL_CONVERSION_PROC
        /*
         * Xservers between 1.3.99.0 - 1.4.0.90 do not call conversion_proc, so
         * we need to do the conversion from device to screen space.
         */
        VMMouseConvertProc(pInfo, 0, 2, dx, dy, 0, 0, 0, 0, &dx, &dy);
#endif
        xf86PostMotionEvent(pInfo->dev, !mPriv->isCurrRelative, 0, 2, dx, dy);
    }

    if (truebuttons != pMse->lastButtons) {
       change = buttons ^ reverseBits(reverseMap, pMse->lastButtons);
       while (change) {
	  id = ffs(change);
	  change &= ~(1 << (id - 1));
	  xf86PostButtonEvent(pInfo->dev, 0, id,
			      (buttons & (1 << (id - 1))), 0, 0);
       }
       pMse->lastButtons = truebuttons;
    }
}


/*
 *----------------------------------------------------------------------
 *
 * VMMousePostEvent --
 *	Prepare the mouse status according to the Z axis mapping
 *	before we post the event to Xserver
 *
 * Results:
 * 	None
 *
 * Side effects:
 * 	Buttons was updated according to Z axis mapping
 *
 *----------------------------------------------------------------------
 */

static void
VMMousePostEvent(InputInfoPtr pInfo, int buttons, int dx, int dy, int dz, int dw)
{
    MouseDevPtr pMse;
    int zbutton = 0;
    VMMousePrivPtr mPriv;

    pMse = pInfo->private;
    mPriv = (VMMousePrivPtr)pMse->mousePriv;
    /* Map the Z axis movement. */
    /* XXX Could this go in the conversion_proc? */
    switch (pMse->negativeZ) {
    case MSE_NOZMAP:	/* do nothing */
	break;
    case MSE_MAPTOX:
	if (dz != 0) {
	   if(mPriv->isCurrRelative)
	      dx = dz;
	   else
	      dx += dz;
	    dz = 0;
	}
	break;
    case MSE_MAPTOY:
	if (dz != 0) {
	   if(mPriv->isCurrRelative)
	      dy = dz;
	   else
	      dy += dz;
	    dz = 0;
	}
	break;
    default:	/* buttons */
	buttons &= ~(pMse->negativeZ | pMse->positiveZ
		   | pMse->negativeW | pMse->positiveW);
	if (dw < 0 || dz < -1) {
	    zbutton = pMse->negativeW;
	}
	else if (dz < 0) {
	    zbutton = pMse->negativeZ;
	}
	else if (dw > 0 || dz > 1) {
	    zbutton = pMse->positiveW;
	}
	else if (dz > 0) {
	    zbutton = pMse->positiveZ;
	}
	buttons |= zbutton;
	dz = 0;
	break;
    }

    VMMouseDoPostEvent(pInfo, buttons, dx, dy);

    /*
     * If dz has been mapped to a button `down' event, we need to cook up
     * a corresponding button `up' event.
     */
    if (zbutton) {
	buttons &= ~zbutton;
	if(mPriv->isCurrRelative)
	   VMMouseDoPostEvent(pInfo, buttons, 0, 0);
	else
	   VMMouseDoPostEvent(pInfo, buttons, dx, dy);
    }
}


/*
 *----------------------------------------------------------------------
 *
 * FlushButtons --
 *
 * 	FlushButtons -- reset button states.
 *
 * Results:
 * 	None
 *
 * Side effects:
 * 	None
 *
 *----------------------------------------------------------------------
 */

static void
FlushButtons(MouseDevPtr pMse)
{
    pMse->lastButtons = 0;
}


/*
 *----------------------------------------------------------------------
 *
 * MouseCommonOptions --
 *	Process acceptable mouse options. Currently we only process
 *	"Buttons" and "ZAxisMapping" options.
 *	More options can be added later on
 *
 * Results:
 * 	None
 *
 * Side effects:
 * 	The buttons was setup according to the options
 *
 *----------------------------------------------------------------------
 */

static void
MouseCommonOptions(InputInfoPtr pInfo)
{
   MouseDevPtr pMse;
   char *s;

   pMse = pInfo->private;

   pMse->buttons = xf86SetIntOption(pInfo->options, "Buttons", 0);
   if (!pMse->buttons) {
      pMse->buttons = MSE_DFLTBUTTONS;
   }

   /*
    * "emulate3Buttons" and "Drag Lock" is not supported
    */

   /*
    * Process option for ZAxisMapping
    */
   s = xf86SetStrOption(pInfo->options, "ZAxisMapping", "4 5");
   if (s) {
      int b1 = 0, b2 = 0, b3 = 0, b4 = 0;
      char *msg = NULL;

      if (!xf86NameCmp(s, "x")) {
	 pMse->negativeZ = pMse->positiveZ = MSE_MAPTOX;
	 pMse->negativeW = pMse->positiveW = MSE_MAPTOX;
	 msg = xstrdup("X axis");
      } else if (!xf86NameCmp(s, "y")) {
	 pMse->negativeZ = pMse->positiveZ = MSE_MAPTOY;
	 pMse->negativeW = pMse->positiveW = MSE_MAPTOY;
	 msg = xstrdup("Y axis");
      } else if (sscanf(s, "%d %d %d %d", &b1, &b2, &b3, &b4) >= 2 &&
		 b1 > 0 && b1 <= MSE_MAXBUTTONS &&
		 b2 > 0 && b2 <= MSE_MAXBUTTONS) {
	 msg = xstrdup("buttons XX and YY");
	 if (msg)
	    sprintf(msg, "buttons %d and %d", b1, b2);
	 pMse->negativeZ = pMse->negativeW = 1 << (b1-1);
	 pMse->positiveZ = pMse->positiveW = 1 << (b2-1);
	 if (b1 > pMse->buttons) pMse->buttons = b1;
	 if (b2 > pMse->buttons) pMse->buttons = b2;

	 /*
	  * Option "ZAxisMapping" "N1 N2 N3 N4" not supported
	  */
	 pMse->negativeW = pMse->positiveW = MSE_NOZMAP;
      } else {
	 pMse->negativeZ = pMse->positiveZ = MSE_NOZMAP;
	 pMse->negativeW = pMse->positiveW = MSE_NOZMAP;
      }
      if (msg) {
	 xf86Msg(X_CONFIG, "%s: ZAxisMapping: %s\n", pInfo->name, msg);
	 free(msg);
      } else {
	 xf86Msg(X_WARNING, "%s: Invalid ZAxisMapping value: \"%s\"\n",
		 pInfo->name, s);
      }
   }
}


/*
 *----------------------------------------------------------------------
 *
 * VMMouseUnInit --
 * 	This function was supposed to be called by Xserver to do Un-Init.
 *	But it was unused now
 *
 * Results:
 * 	None
 *
 * Side effects:
 * 	None
 *
 *----------------------------------------------------------------------
 */

static void
VMMouseUnInit(InputDriverPtr drv, InputInfoPtr pInfo, int flags)
{
   MouseDevPtr pMse = pInfo->private;

   xf86Msg(X_INFO, "VMWARE(0): VMMouseUnInit\n");

   if (pMse) {
       VMMousePrivPtr mPriv = (VMMousePrivPtr)pMse->mousePriv;
       free(mPriv);
   }

   xf86DeleteInput(pInfo, flags);
}


/*
 *----------------------------------------------------------------------
 *
 * VMMouseDeviceControl --
 * 	This function was called by Xserver during DEVICE_INIT, DEVICE_ON,
 *	DEVICE_OFF and DEVICE_CLOSE phase
 *
 * Results:
 * 	TRUE, if sucessful
 *	FALSE, if failed
 *
 * Side effects:
 * 	Absolute pointing device is enabled during DEVICE_ON
 *	Absolute pointing device is disabled during DEVICE_OFF
 *	and DEVICE_CLOSE
 *
 *----------------------------------------------------------------------
 */

static Bool
VMMouseDeviceControl(DeviceIntPtr device, int mode)
{
   InputInfoPtr pInfo;
   MouseDevPtr pMse;
   unsigned char map[MSE_MAXBUTTONS + 1];
   int i;
#if GET_ABI_MAJOR(ABI_XINPUT_VERSION) >= 7
   Atom btn_labels[MSE_MAXBUTTONS] = {0};
   Atom axes_labels[2] = { 0, 0 };
#endif

   pInfo = device->public.devicePrivate;
   pMse = pInfo->private;
   pMse->device = device;

   switch (mode){
   case DEVICE_INIT:
      device->public.on = FALSE;
      /*
       * [KAZU-241097] We don't know exactly how many buttons the
       * device has, so setup the map with the maximum number.
       */
      for (i = 0; i < MSE_MAXBUTTONS; i++)
	 map[i + 1] = i + 1;
#if GET_ABI_MAJOR(ABI_XINPUT_VERSION) >= 7
      btn_labels[0] = XIGetKnownProperty(BTN_LABEL_PROP_BTN_LEFT);
      btn_labels[1] = XIGetKnownProperty(BTN_LABEL_PROP_BTN_MIDDLE);
      btn_labels[2] = XIGetKnownProperty(BTN_LABEL_PROP_BTN_RIGHT);
      btn_labels[3] = XIGetKnownProperty(BTN_LABEL_PROP_BTN_WHEEL_UP);
      btn_labels[4] = XIGetKnownProperty(BTN_LABEL_PROP_BTN_WHEEL_DOWN);
      btn_labels[5] = XIGetKnownProperty(BTN_LABEL_PROP_BTN_HWHEEL_LEFT);
      btn_labels[6] = XIGetKnownProperty(BTN_LABEL_PROP_BTN_HWHEEL_RIGHT);
      /* other buttons are unknown */

#ifdef ABS_VALUATOR_AXES
      axes_labels[0] = XIGetKnownProperty(AXIS_LABEL_PROP_ABS_X);
      axes_labels[1] = XIGetKnownProperty(AXIS_LABEL_PROP_ABS_Y);
#else
      axes_labels[0] = XIGetKnownProperty(AXIS_LABEL_PROP_REL_X);
      axes_labels[1] = XIGetKnownProperty(AXIS_LABEL_PROP_REL_Y);
#endif /* ABS_VALUATOR_AXES */
#endif

      InitPointerDeviceStruct((DevicePtr)device, map,
			      min(pMse->buttons, MSE_MAXBUTTONS),
#if GET_ABI_MAJOR(ABI_XINPUT_VERSION) >= 7
				btn_labels,
#endif
#if GET_ABI_MAJOR(ABI_XINPUT_VERSION) == 0
				miPointerGetMotionEvents,
#elif GET_ABI_MAJOR(ABI_XINPUT_VERSION) < 3
                                GetMotionHistory,
#endif
                                pMse->Ctrl,
#if GET_ABI_MAJOR(ABI_XINPUT_VERSION) == 0
				miPointerGetMotionBufferSize()
#else
                                GetMotionHistorySize(), 2
#endif
#if GET_ABI_MAJOR(ABI_XINPUT_VERSION) >= 7
				, axes_labels
#endif
                                );

      /* X valuator */
#ifdef ABS_VALUATOR_AXES
      xf86InitValuatorAxisStruct(device, 0,
#if GET_ABI_MAJOR(ABI_XINPUT_VERSION) >= 7
				axes_labels[0],
#endif
				0, 65535, 10000, 0, 10000
#if GET_ABI_MAJOR(ABI_XINPUT_VERSION) >= 12
                                , Absolute
#endif
                                );
#else
      xf86InitValuatorAxisStruct(device, 0,
#if GET_ABI_MAJOR(ABI_XINPUT_VERSION) >= 7
				axes_labels[0],
#endif
				0, -1, 1, 0, 1
#if GET_ABI_MAJOR(ABI_XINPUT_VERSION) >= 12
                                , Relative
#endif
                                );
#endif
      xf86InitValuatorDefaults(device, 0);
      /* Y valuator */
#ifdef ABS_VALUATOR_AXES
      xf86InitValuatorAxisStruct(device, 1,
#if GET_ABI_MAJOR(ABI_XINPUT_VERSION) >= 7
				axes_labels[1],
#endif
				0, 65535, 10000, 0, 10000
#if GET_ABI_MAJOR(ABI_XINPUT_VERSION) >= 12
                                , Absolute
#endif
                                );
#else
      xf86InitValuatorAxisStruct(device, 1,
#if GET_ABI_MAJOR(ABI_XINPUT_VERSION) >= 7
				axes_labels[1],
#endif
				0, -1, 1, 0, 1
#if GET_ABI_MAJOR(ABI_XINPUT_VERSION) >= 12
                                , Relative
#endif
                                );
#endif
      xf86InitValuatorDefaults(device, 1);
#if GET_ABI_MAJOR(ABI_XINPUT_VERSION) == 0
      xf86MotionHistoryAllocate(pInfo);
#endif

      xf86Msg(X_INFO, "VMWARE(0): VMMOUSE DEVICE_INIT\n");
#ifdef EXTMOUSEDEBUG
      xf86Msg(X_INFO, "assigning %p atom=%d name=%s\n", device, pInfo->atom,
	     pInfo->name);
#endif
      break;

   case DEVICE_ON:
      xf86Msg(X_INFO, "VMWARE(0): VMMOUSE DEVICE_ON\n");
      pInfo->fd = xf86OpenSerial(pInfo->options);
      if (pInfo->fd == -1)
	 xf86Msg(X_WARNING, "%s: cannot open input device\n", pInfo->name);
      else {
	 pMse->buffer = XisbNew(pInfo->fd, 64);
	 if (!pMse->buffer) {
	    xf86CloseSerial(pInfo->fd);
	    pInfo->fd = -1;
	 } else {
	    VMMousePrivPtr mPriv = (VMMousePrivPtr)pMse->mousePriv;
	    if (mPriv != NULL) {
	       /*
		* enable absolute pointing device here
		*/
	       if (!VMMouseClient_Enable()) {
		  xf86Msg(X_ERROR, "VMWARE(0): vmmouse enable failed\n");
		  mPriv->vmmouseAvailable = FALSE;
		  device->public.on = FALSE;
		  return FALSE;
	       } else {
		  mPriv->vmmouseAvailable = TRUE;
		  xf86Msg(X_INFO, "VMWARE(0): vmmouse enabled\n");
	       }
	    }
	    xf86FlushInput(pInfo->fd);
	    xf86AddEnabledDevice(pInfo);
	 }
      }
      pMse->lastButtons = 0;
      device->public.on = TRUE;
      FlushButtons(pMse);
      break;
   case DEVICE_OFF:
   case DEVICE_CLOSE:
      xf86Msg(X_INFO, "VMWARE(0): VMMOUSE DEVICE_OFF/CLOSE\n");

      if (pInfo->fd != -1) {
	 VMMousePrivPtr mPriv = (VMMousePrivPtr)pMse->mousePriv;
	 if( mPriv->vmmouseAvailable ) {
	    VMMouseClient_Disable();
            mPriv->vmmouseAvailable = FALSE;
            mPriv->absoluteRequested = FALSE;
	 }

	 xf86RemoveEnabledDevice(pInfo);
	 if (pMse->buffer) {
	    XisbFree(pMse->buffer);
	    pMse->buffer = NULL;
	 }
	 xf86CloseSerial(pInfo->fd);
	 pInfo->fd = -1;
      }
      device->public.on = FALSE;
      usleep(300000);
      break;

#if GET_ABI_MAJOR(ABI_XINPUT_VERSION) * 100 + GET_ABI_MINOR(ABI_XINPUT_VERSION) >= 1901
   case  DEVICE_ABORT:
      if (pInfo->fd != -1) {
	 VMMousePrivPtr mPriv = (VMMousePrivPtr)pMse->mousePriv;
	 if( mPriv->vmmouseAvailable )
	    VMMouseClient_Disable();
         break;
      }
#endif
   }

   return Success;
}


/*
 *----------------------------------------------------------------------
 *
 * VMMouseReadInput --
 * 	This function was called by Xserver when there is data available
 *	in the input device
 *
 * Results:
 * 	None
 *
 * Side effects:
 * 	Input data in regular PS/2 fd was cleared
 *	Real mouse data was read from the absolute pointing device
 *	and posted to Xserver
 *
 *----------------------------------------------------------------------
 */

static void
VMMouseReadInput(InputInfoPtr pInfo)
{
   MouseDevPtr pMse;
   VMMousePrivPtr mPriv;
   int c;
   int len = 0;

   pMse = pInfo->private;
   mPriv = pMse->mousePriv;

   if (!mPriv->absoluteRequested) {
      /*
       * We can request for absolute mode, but it depends on
       * host whether it will send us absolute or relative
       * position.
       */
      VMMouseClient_RequestAbsolute();
      mPriv->absoluteRequested = TRUE;
      LogMessageVerbSigSafe(X_INFO, -1, "VMWARE(0): vmmouse enable absolute mode\n");
   }

   /*
    * First read the bytes in input device to clear the regular PS/2 fd so
    * we don't get called again.
    */
   /*
    * Set blocking to -1 on the first call because we know there is data to
    * read. Xisb automatically clears it after one successful read so that
    * succeeding reads are preceeded by a select with a 0 timeout to prevent
    * read from blocking indefinitely.
    */
   XisbBlockDuration(pMse->buffer, -1);
   while ((c = XisbRead(pMse->buffer)) >= 0) {
      len++;
      /*
       * regular PS packet consists of 3 bytes
       * We read 3 bytes to drain the PS/2 packet
       */
      if(len < 3) continue;
      len = 0;
      /*
       * Now get the real data from absolute pointing device
       */
      GetVMMouseMotionEvent(pInfo);
   }
   /*
    * There maybe still vmmouse data available
    */
   GetVMMouseMotionEvent(pInfo);
}


/*
 *----------------------------------------------------------------------
 *
 * GetVMMouseMotionEvent --
 * 	Read all the mouse data available from the absolute
 * 	pointing device	and post it to the Xserver
 *
 * Results:
 * 	None
 *
 * Side effects:
 *	Real mouse data was read from the absolute pointing
 *	device and posted to Xserver
 *
 *----------------------------------------------------------------------
 */

static void
GetVMMouseMotionEvent(InputInfoPtr pInfo){
   MouseDevPtr pMse;
   VMMousePrivPtr mPriv;
   int buttons, dx, dy, dz, dw;
   VMMOUSE_INPUT_DATA  vmmouseInput;
   int numPackets;

   pMse = pInfo->private;
   mPriv = (VMMousePrivPtr)pMse->mousePriv;
   while((numPackets = VMMouseClient_GetInput(&vmmouseInput))){
      int ps2Buttons = 0;
      if (numPackets == VMMOUSE_ERROR) {
         VMMouseClient_Disable();
         VMMouseClient_Enable();
         VMMouseClient_RequestAbsolute();
         LogMessageVerbSigSafe(X_INFO, -1, "VMWARE(0): re-requesting absolute mode after reset\n");
         break;
      }

      if(vmmouseInput.Buttons & VMMOUSE_MIDDLE_BUTTON)
	 ps2Buttons |= 0x04; 			/* Middle*/
      if(vmmouseInput.Buttons & VMMOUSE_RIGHT_BUTTON)
	 ps2Buttons |= 0x02; 			/* Right*/
      if(vmmouseInput.Buttons & VMMOUSE_LEFT_BUTTON)
	 ps2Buttons |= 0x01; 			/* Left*/

      buttons = (ps2Buttons & 0x04) >> 1 |	/* Middle */
	 (ps2Buttons & 0x02) >> 1 |       	/* Right */
	 (ps2Buttons & 0x01) << 2;       	/* Left */

      dx = vmmouseInput.X;
      dy = vmmouseInput.Y;
      dz = (char)vmmouseInput.Z;
      dw = 0;
      /*
       * Get the per package relative or absolute information.
       */
      mPriv->isCurrRelative = vmmouseInput.Flags & VMMOUSE_MOVE_RELATIVE;
      /* post an event */
      pMse->PostEvent(pInfo, buttons, dx, dy, dz, dw);
      mPriv->vmmousePrevInput = vmmouseInput;
   }
}


/*
 *----------------------------------------------------------------------
 *
 * VMMouseControlProc --
 *	This function is unused
 *
 * Results:
 * 	None
 *
 * Side effects:
 * 	None
 *
 *----------------------------------------------------------------------
 */

static int
VMMouseControlProc(InputInfoPtr pInfo, xDeviceCtl * control)
{
   xf86Msg(X_INFO, "VMWARE(0): VMMouseControlProc\n");
   return (Success);
}


/*
 *----------------------------------------------------------------------
 *
 *  VMMouseCloseProc --
 *	This function is unused
 *
 * Results:
 * 	None
 *
 * Side effects:
 * 	None
 *
 *----------------------------------------------------------------------
 */

#if GET_ABI_MAJOR(ABI_XINPUT_VERSION) < 12
static void
VMMouseCloseProc(InputInfoPtr pInfo)
{
   xf86Msg(X_INFO, "VMWARE(0): VMMouseCloseProc\n");
}
#endif


/*
 *----------------------------------------------------------------------
 *
 *  VMMouseSwitchProc --
 *	This function is unused
 *
 * Results:
 * 	None
 *
 * Side effects:
 * 	None
 *
 *----------------------------------------------------------------------
 */

static int
VMMouseSwitchMode(ClientPtr client, DeviceIntPtr dev, int mode)
{
   xf86Msg(X_INFO, "VMWARE(0): VMMouseSwitchMode\n");
   return (Success);
}


/*
 *----------------------------------------------------------------------
 *
 * VMMouseConvertProc  --
 * 	This function was called by Xserver to convert valuators to X and Y
 *
 * Results:
 * 	TRUE
 *
 * Side effects:
 * 	X and Y was converted according to current Screen dimension
 *
 *----------------------------------------------------------------------
 */

#if GET_ABI_MAJOR(ABI_XINPUT_VERSION) < 12
static Bool
VMMouseConvertProc(InputInfoPtr pInfo, int first, int num, int v0, int v1, int v2,
	     int v3, int v4, int v5, int *x, int *y)
{
   MouseDevPtr pMse;
   VMMousePrivPtr mPriv;
   double factorX, factorY;

   pMse = pInfo->private;
   mPriv = pMse->mousePriv;

   if (first != 0 || num != 2)
      return FALSE;

   if(mPriv->isCurrRelative) {
      *x = v0;
      *y = v1;
   } else {
      factorX = ((double) screenInfo.screens[mPriv->screenNum]->width) / (double) 65535;
      factorY = ((double) screenInfo.screens[mPriv->screenNum]->height) / (double) 65535;

      *x = v0 * factorX + 0.5;
      *y = v1 * factorY + 0.5;

      if (mPriv->screenNum != -1) {
	 xf86XInputSetScreen(pInfo, mPriv->screenNum, *x, *y);
      }
   }
   return TRUE;
}
#endif


#ifdef XFree86LOADER

/*
 *----------------------------------------------------------------------
 *
 * VMMouseUnplug  --
 * 	This function was called by Xserver when unplug
 *
 * Results:
 * 	None
 *
 * Side effects:
 * 	None
 *
 *----------------------------------------------------------------------
 */

static void
VMMouseUnplug(pointer p)
{
   xf86Msg(X_INFO, "VMWARE(0): VMMouseUnplug\n");
}


/*
 *----------------------------------------------------------------------
 *
 * VMMousePlug  --
 * 	This function was called when Xserver load vmmouse module. It will
 * 	integrate the  module infto the XFree86 loader architecutre.
 *
 * Results:
 * 	TRUE
 *
 * Side effects:
 * 	Regular mouse module was loaded as a submodule. In case
 * 	absolute pointing device is not available, we can always fall back
 *	to the regular mouse module
 *
 *----------------------------------------------------------------------
 */

static pointer
VMMousePlug(pointer	module,
	    pointer	options,
	    int		*errmaj,
	    int		*errmin)
{
   static Bool Initialised = FALSE;

#if GET_ABI_MAJOR(ABI_XINPUT_VERSION) < 7
   xf86LoaderReqSymLists(reqSymbols, NULL);
#endif

   if (!Initialised)
      Initialised = TRUE;

   xf86Msg(X_INFO, "VMWARE(0): VMMOUSE module was loaded\n");
   xf86AddInputDriver(&VMMOUSE, module, 0);

#ifndef NO_MOUSE_MODULE
{
   char *name;
   /*
    * Load the normal mouse module as submodule
    * If we fail in PreInit later, this allows us to fall back to normal mouse module
    */
#ifndef NORMALISE_MODULE_NAME
   name = xstrdup("mouse");
#else
   /* Normalise the module name */
   name = xf86NormalizeName("mouse");
#endif

   if (!LoadSubModule(module, name, NULL, NULL, NULL, NULL, errmaj, errmin)) {
      LoaderErrorMsg(NULL, name, *errmaj, *errmin);
   }
   free(name);
}
#endif

   return module;
}

static XF86ModuleVersionInfo VMMouseVersionRec = {
   "vmmouse",
   MODULEVENDORSTRING,
   MODINFOSTRING1,
   MODINFOSTRING2,
   XORG_VERSION_CURRENT,
   PACKAGE_VERSION_MAJOR, PACKAGE_VERSION_MINOR, PACKAGE_VERSION_PATCHLEVEL,
   ABI_CLASS_XINPUT,
   ABI_XINPUT_VERSION,
   MOD_CLASS_XINPUT,
   {0, 0, 0, 0}		/* signature, to be patched into the file by a tool */
};

/*
 * The variable contains the necessary information to load and initialize the module
 */
_X_EXPORT XF86ModuleData vmmouseModuleData = {
   &VMMouseVersionRec,
   VMMousePlug,
   VMMouseUnplug
};
#endif /* XFree86LOADER */
@


1.11
log
@Update xf86-input-vmmouse to  13.0.0
@
text
@d810 2
d813 7
d871 4
a874 4
      btn_labels[4] = XIGetKnownProperty(BTN_LABEL_PROP_BTN_WHEEL_UP);
      btn_labels[5] = XIGetKnownProperty(BTN_LABEL_PROP_BTN_WHEEL_DOWN);
      btn_labels[6] = XIGetKnownProperty(BTN_LABEL_PROP_BTN_HWHEEL_LEFT);
      btn_labels[7] = XIGetKnownProperty(BTN_LABEL_PROP_BTN_HWHEEL_RIGHT);
d1022 9
@


1.10
log
@Update to xf86-input-vmmouse 12.9.0
@
text
@d76 4
a731 1
   MessageType from = X_DEFAULT;
a732 1
   int origButtons;
a736 1
   from = X_CONFIG;
a738 1
      from = X_DEFAULT;
a739 1
   origButtons = pMse->buttons;
a787 7

   /*
    * Emulatewheel is not supported
    */
   if (origButtons != pMse->buttons)
      from = X_CONFIG;

a837 1
   VMMousePrivPtr mPriv;
a847 1
   mPriv = (VMMousePrivPtr)pMse->mousePriv;
d1056 1
a1056 1
      xf86Msg(X_INFO, "VMWARE(0): vmmouse enable absolute mode\n");
a1112 1
   int ps2Buttons = 0;
d1118 1
d1123 1
a1123 1
         xf86Msg(X_INFO, "VMWARE(0): re-requesting absolute mode after reset\n");
@


1.9
log
@Update to xf86-input-vmmouse 12.8.0
@
text
@d68 1
d343 10
d412 10
@


1.8
log
@Update to xf86-input-vmmouse 12.7.0.
@
text
@d231 29
d264 1
a264 1
   InputOption *input_options = NULL, *tmp, *opts;
d273 3
a275 5
      tmp = calloc(1, sizeof(InputOption));
      tmp->key = xf86OptionName(options);
      tmp->value = xf86OptionValue(options);
      tmp->next = input_options;
      input_options = tmp;
d281 1
a281 9
   opts = input_options;
   tmp = opts;
   while(opts) {
      tmp = opts->next;
      free(opts->key);
      free(opts->value);
      free(opts);
      opts = tmp;
   }
@


1.7
log
@Update to xf86-input-vmmouse 12.6.10. No functionnal change.
@
text
@d78 5
d113 3
a115 2
 * As the driver's version is only  {major, minor, patchlevel}, simply append an
 * extra zero for the fourth digit.
d118 4
d124 1
d131 3
d135 4
d145 1
a145 2
static void VMMouseCloseProc(LocalDevicePtr local);
static int  VMMouseControlProc(LocalDevicePtr local, xDeviceCtl * control);
a147 2
static Bool VMMouseConvertProc(InputInfoPtr pInfo, int first, int num, int v0, int v1, int v2,
			       int v3, int v4, int v5, int *x, int *y);
d216 3
a218 1
   NULL,
d220 1
d230 50
d300 4
a307 2
   MouseDevPtr pMse;
   VMMousePrivPtr mPriv;
a321 9
   mPriv = xcalloc (1, sizeof (VMMousePrivRec));


   if (!mPriv) {
      return NULL;
   }

   mPriv->absoluteRequested = FALSE;

a329 1
      InputDriverRec *passthruMouse;
d331 1
a331 9
      mPriv->vmmouseAvailable = FALSE;
      passthruMouse = (InputDriverRec *)LoaderSymbol("MOUSE");
      xfree(mPriv);
      if(passthruMouse != NULL){
	 return (passthruMouse->PreInit)(drv, dev, flags);
      } else {
	 return NULL;
      }

a335 1
      mPriv->vmmouseAvailable = TRUE;
a344 1
      xfree(mPriv);
a347 1
   /* Settup the pInfo */
a348 4
   pInfo->type_name = XI_MOUSE;
   pInfo->flags = XI86_POINTER_CAPABLE | XI86_SEND_DRAG_EVENTS;
   pInfo->device_control = VMMouseDeviceControl;
   pInfo->read_input = VMMouseReadInput;
a351 1
   pInfo->control_proc = VMMouseControlProc;
a352 1
   pInfo->switch_mode = VMMouseSwitchMode;
d360 51
d413 3
a415 3
   if (!(pMse = xcalloc(sizeof(MouseDevRec), 1))) {
      xfree(mPriv);
      return pInfo;
a424 4
   /* Collect the options, and process the common options. */
   xf86CollectInputOptions(pInfo, NULL, NULL);
   xf86ProcessCommonOptions(pInfo, pInfo->options);

d432 2
a433 5
	 if (pMse->mousePriv)
	    xfree(pMse->mousePriv);
	 xfree(pMse);
	 pInfo->private = NULL;
	 return pInfo;
d445 10
a454 2
   pInfo->flags |= XI86_CONFIGURED;
   return pInfo;
d743 1
a743 1
	 xfree(msg);
d776 1
a776 1
VMMouseUnInit(InputDriverPtr drv, LocalDevicePtr local, int flags)
d874 5
a878 1
				0, 65535, 10000, 0, 10000);
d884 5
a888 1
				0, -1, 1, 0, 1);
d897 5
a901 1
				0, 65535, 10000, 0, 10000);
d907 5
a911 1
				0, -1, 1, 0, 1);
d1139 1
a1139 1
VMMouseControlProc(LocalDevicePtr local, xDeviceCtl * control)
d1161 1
d1163 1
a1163 1
VMMouseCloseProc(LocalDevicePtr local)
d1167 1
d1208 1
d1239 1
d1319 1
a1319 1
   xfree(name);
@


1.6
log
@Update to xf86-input-vmmouse 12.6.9
@
text
@a50 1
#define NEED_EVENTS
d72 1
@


1.5
log
@Update xf86-input-vmmouse to version 12.6.5
@
text
@a99 3
#define VMMOUSE_MAJOR_VERSION 12
#define VMMOUSE_MINOR_VERSION 6
#define VMMOUSE_PATCHLEVEL 5
d101 1
a101 1
   (VMMOUSE_MAJOR_VERSION * 65536 + VMMOUSE_MINOR_VERSION * 256 + VMMOUSE_PATCHLEVEL)
d103 2
a104 2
    VMW_STRING(VMMOUSE_MAJOR_VERSION) "." VMW_STRING(VMMOUSE_MINOR_VERSION) \
    "." VMW_STRING(VMMOUSE_PATCHLEVEL)
d146 1
d193 1
d1177 1
d1179 1
d1217 1
a1217 1
   VMMOUSE_MAJOR_VERSION, VMMOUSE_MINOR_VERSION, VMMOUSE_PATCHLEVEL,
@


1.4
log
@update to xf86-input-vmmouse 12.6.4
@
text
@d71 4
d102 1
a102 1
#define VMMOUSE_PATCHLEVEL 4
a122 3
#ifdef XFree86LOADER
static const OptionInfoRec *VMMouseAvailableOptions(void *unused);
#endif
a205 62
typedef enum {
    OPTION_ALWAYS_CORE,
    OPTION_SEND_CORE_EVENTS,
    OPTION_CORE_POINTER,
    OPTION_SEND_DRAG_EVENTS,
    OPTION_HISTORY_SIZE,
    OPTION_DEVICE,
    OPTION_PROTOCOL,
    OPTION_BUTTONS,
    OPTION_EMULATE_3_BUTTONS,
    OPTION_EMULATE_3_TIMEOUT,
    OPTION_CHORD_MIDDLE,
    OPTION_FLIP_XY,
    OPTION_INV_X,
    OPTION_INV_Y,
    OPTION_ANGLE_OFFSET,
    OPTION_Z_AXIS_MAPPING,
    OPTION_SAMPLE_RATE,
    OPTION_RESOLUTION,
    OPTION_EMULATE_WHEEL,
    OPTION_EMU_WHEEL_BUTTON,
    OPTION_EMU_WHEEL_INERTIA,
    OPTION_X_AXIS_MAPPING,
    OPTION_Y_AXIS_MAPPING,
    OPTION_AUTO_SOFT,
    OPTION_DRAGLOCKBUTTONS
} MouseOpts;

/*
 * Define the acceptable mouse options
 * Currently not all of those options are supported
 *
 */
static const OptionInfoRec mouseOptions[] = {
    { OPTION_ALWAYS_CORE,	"AlwaysCore",	  OPTV_BOOLEAN,	{0}, FALSE },
    { OPTION_SEND_CORE_EVENTS,	"SendCoreEvents", OPTV_BOOLEAN,	{0}, FALSE },
    { OPTION_CORE_POINTER,	"CorePointer",	  OPTV_BOOLEAN,	{0}, FALSE },
    { OPTION_SEND_DRAG_EVENTS,	"SendDragEvents", OPTV_BOOLEAN,	{0}, FALSE },
    { OPTION_HISTORY_SIZE,	"HistorySize",	  OPTV_INTEGER,	{0}, FALSE },
    { OPTION_DEVICE,		"Device",	  OPTV_STRING,	{0}, FALSE },
    { OPTION_PROTOCOL,		"Protocol",	  OPTV_STRING,	{0}, FALSE },
    { OPTION_BUTTONS,		"Buttons",	  OPTV_INTEGER,	{0}, FALSE },
    { OPTION_EMULATE_3_BUTTONS,	"Emulate3Buttons",OPTV_BOOLEAN,	{0}, FALSE },
    { OPTION_EMULATE_3_TIMEOUT,	"Emulate3Timeout",OPTV_INTEGER,	{0}, FALSE },
    { OPTION_CHORD_MIDDLE,	"ChordMiddle",	  OPTV_BOOLEAN,	{0}, FALSE },
    { OPTION_FLIP_XY,		"FlipXY",	  OPTV_BOOLEAN,	{0}, FALSE },
    { OPTION_INV_X,		"InvX",		  OPTV_BOOLEAN,	{0}, FALSE },
    { OPTION_INV_Y,		"InvY",		  OPTV_BOOLEAN,	{0}, FALSE },
    { OPTION_ANGLE_OFFSET,	"AngleOffset",	  OPTV_INTEGER,	{0}, FALSE },
    { OPTION_Z_AXIS_MAPPING,	"ZAxisMapping",	  OPTV_STRING,	{0}, FALSE },
    { OPTION_SAMPLE_RATE,	"SampleRate",	  OPTV_INTEGER,	{0}, FALSE },
    { OPTION_RESOLUTION,	"Resolution",	  OPTV_INTEGER,	{0}, FALSE },
    { OPTION_EMULATE_WHEEL,	"EmulateWheel",	  OPTV_BOOLEAN, {0}, FALSE },
    { OPTION_EMU_WHEEL_BUTTON,	"EmulateWheelButton", OPTV_INTEGER, {0}, FALSE },
    { OPTION_EMU_WHEEL_INERTIA,	"EmulateWheelInertia", OPTV_INTEGER, {0}, FALSE },
    { OPTION_X_AXIS_MAPPING,	"XAxisMapping",	  OPTV_STRING,	{0}, FALSE },
    { OPTION_Y_AXIS_MAPPING,	"YAxisMapping",	  OPTV_STRING,	{0}, FALSE },
    { OPTION_AUTO_SOFT,		"AutoSoft",	  OPTV_BOOLEAN, {0}, FALSE },
    { OPTION_DRAGLOCKBUTTONS,	"DragLockButtons",OPTV_STRING,	{0}, FALSE },
    { -1,			NULL,		  OPTV_NONE,	{0}, FALSE }
};

d239 3
d250 2
a362 8
#ifdef XFree86LOADER
static const OptionInfoRec *
VMMouseAvailableOptions(void *unused)
{
    return (mouseOptions);
}
#endif

d715 4
d734 18
d755 3
d769 3
d776 5
a780 1
      xf86InitValuatorAxisStruct(device, 0, 0, 65535, 10000, 0, 10000);
d782 5
a786 1
      xf86InitValuatorAxisStruct(device, 0, 0, -1, 1, 0, 1);
d791 5
a795 1
      xf86InitValuatorAxisStruct(device, 1, 0, 65535, 10000, 0, 10000);
d797 5
a801 1
      xf86InitValuatorAxisStruct(device, 1, 0, -1, 1, 0, 1);
a1128 8
ModuleInfoRec VMMouseInfo = {
    1,
    "VMMOUSE",
    NULL,
    0,
    VMMouseAvailableOptions,
};

a1176 1
   char *name;
d1186 3
d1204 2
d1226 1
a1226 1
XF86ModuleData vmmouseModuleData = {
@


1.3
log
@update to xf86-input-vmmouse 12.6.3.
HAL tools and files are not built/installed on OpenBSD.
@
text
@d98 1
a98 1
#define VMMOUSE_PATCHLEVEL 2
d141 5
a145 3
   int 		screenNum;
   Bool 	vmmouseAvailable;
   Bool		relative;
d316 1
a316 1
   mPriv->relative = TRUE;
d484 1
d498 8
a505 1
    if (dx || dy) {
d514 1
a514 1
        xf86PostMotionEvent(pInfo->dev, !mPriv->relative, 0, 2, dx, dy);
d562 1
a562 1
	   if(mPriv->relative)
d571 1
a571 1
	   if(mPriv->relative)
d606 1
a606 1
	if(mPriv->relative)
a633 1
    pMse->lastMappedButtons = 0;
d877 2
a878 2
	    mPriv->vmmouseAvailable = FALSE;
            mPriv->relative = TRUE;
d928 6
a933 1
   if (mPriv->relative) {
d935 1
a935 1
      mPriv->relative = FALSE;
d990 1
d997 1
d1022 4
d1028 1
d1130 1
a1130 1
   if(mPriv->relative) {
@


1.2
log
@xf86-input-vmmouse 12.5.1
@
text
@d97 2
a98 2
#define VMMOUSE_MINOR_VERSION 5
#define VMMOUSE_PATCHLEVEL 1
d313 3
d609 1
a609 2
 * 	FlushButtons -- send button up events for sanity. It is called
 *	during DEVICE_ON in VMMouseDeviceControl
a622 6

    /* If no button down is pending xf86PostButtonEvent()
     * will discard them. So we are on the safe side. */

    int i, blocked;

d624 1
a624 5

    blocked = xf86BlockSIGIO ();
    for (i = 1; i <= 5; i++)
	xf86PostButtonEvent(pMse->device,0,i,0,0,0);
    xf86UnblockSIGIO (blocked);
d670 1
a670 1
   s = xf86SetStrOption(pInfo->options, "ZAxisMapping", NULL);
d790 1
a790 1
#else
d802 3
d806 1
d809 3
d813 1
a848 2
		  VMMouseClient_RequestAbsolute();
		  mPriv->relative = FALSE;
d869 1
d919 6
d1188 1
a1188 1
   if (!Initialised) {
a1189 5
#ifndef REMOVE_LOADER_CHECK_MODULE_INFO
      if (xf86LoaderCheckSymbol("xf86AddModuleInfo"))
#endif
	 xf86AddModuleInfo(&VMMouseInfo, module);
   }
@


1.1
log
@Initial revision
@
text
@d35 1
a35 1
 *      
d39 1
a39 1
 * 	
d80 14
d97 18
a114 2
#define VMMOUSE_MINOR_VERSION 4
#define VMMOUSE_PATCHLEVEL 0
d142 2
a143 2
   Bool 	vmmouseAvailable; 
   Bool		relative; 
d198 1
a198 1
   VMMouseUnInit,  
d234 2
a235 2
 * 
 */ 
d280 1
a280 1
 * 
d285 1
a285 1
 *	
d294 1
a294 1
{              
d302 1
a302 1
    */ 
d306 1
a306 1
   
d309 1
a309 1
   
d331 1
a331 1
      
d342 1
a342 1
      VMMouseClient_Disable(); 	
d344 1
a344 1
   
d348 1
a348 1
   }	
d351 1
a351 1
   pInfo->name = dev->identifier;			
d356 1
d358 1
d381 1
a381 1
   
d403 1
a403 1
   
d406 1
a406 1
   
d409 1
a409 1
    
d427 2
a428 2
 *     Alter the control paramters for the mouse. 
 *	
d430 2
a431 2
 * 	None 
 *	
d450 1
a450 1
    
d462 1
a462 1
 *	
d465 1
a465 1
 *	
d479 1
a479 1
    
d487 1
a487 1
     */ 
d493 9
a501 1
       xf86PostMotionEvent(pInfo->dev, !mPriv->relative, 0, 2, dx, dy);
d503 1
a503 1
    
d523 1
a523 1
 *	
d526 1
a526 1
 *	
d539 1
a539 1
    
d552 1
a552 1
	      dx += dz; 
d561 1
a561 1
	      dy += dz; 
d611 1
a611 1
 *	
d642 1
a642 1
 *	More options can be added later on 
d646 1
a646 1
 *	
d701 1
a701 1
	 
d703 1
a703 1
	  * Option "ZAxisMapping" "N1 N2 N3 N4" not supported 
d724 1
a724 1
    
d737 1
a737 1
 *	
d744 1
a744 1
static void 
d756 2
a757 2
 *	DEVICE_OFF and DEVICE_CLOSE phase 
 *	
d761 1
a761 1
 *	
d778 1
a778 1
    
d782 1
a782 1
   mPriv = (VMMousePrivPtr)pMse->mousePriv;    
d796 12
a807 2
			      miPointerGetMotionEvents, pMse->Ctrl,
			      miPointerGetMotionBufferSize());
d815 1
d817 1
d842 1
a842 1
	       if (!VMMouseClient_Enable()) { 
d848 1
a848 1
		  mPriv->vmmouseAvailable = TRUE; 
d852 1
a852 1
	       }		
d861 1
a861 1
      break;	
d872 1
a872 1
	    
d897 1
a897 1
 *	
d900 1
a900 1
 *		
d905 1
a905 1
 *	
d913 1
a913 1
   VMMousePrivPtr mPriv; 
d915 1
a915 1
   int len = 0; 
d919 1
a919 1
 
d922 1
a922 1
    * we don't get called again. 
d935 1
a935 1
       * We read 3 bytes to drain the PS/2 packet 
d938 1
a938 1
      len = 0; 
d957 1
a957 1
 *	
d960 1
a960 1
 *		
d964 1
a964 1
 *	
d974 11
a985 2
   pMse = pInfo->private;  
   while(VMMouseClient_GetInput(&vmmouseInput)){
d992 1
a992 1
	      
d996 1
a996 1
	   
d998 1
a998 1
      dy = vmmouseInput.Y; 
d1011 1
a1011 1
 *	This function is unused 
d1015 1
a1015 1
 *	
d1034 1
a1034 1
 *	This function is unused 
d1038 1
a1038 1
 *	
d1056 1
a1056 1
 *	This function is unused 
d1060 1
a1060 1
 *	
d1080 1
a1080 1
 *	
d1083 1
a1083 1
 *		
d1086 1
a1086 1
 *	
d1103 1
a1103 1
   
d1110 1
a1110 1
      
d1113 1
a1113 1
      
d1137 1
a1137 1
 *	
d1140 1
a1140 1
 *		
d1143 1
a1143 1
 *	
d1159 2
a1160 2
 * 	integrate the  module infto the XFree86 loader architecutre. 
 *	
d1163 1
a1163 1
 *		
d1165 1
a1165 1
 * 	Regular mouse module was loaded as a submodule. In case 
d1168 1
a1168 1
 *	
d1182 1
a1182 1
   
d1209 1
a1209 1
    
@


1.1.1.1
log
@Importing xf86-input-vmmouse 12.4.0
@
text
@@


1.1.1.2
log
@xf86-input-vmmouse 12.4.3
@
text
@a79 14
 * This is the only way I know to turn a #define of an integer constant into
 * a constant string.
 */
#define VMW_INNERSTRINGIFY(s) #s
#define VMW_STRING(str) VMW_INNERSTRINGIFY(str)

/*
 * So that the file compiles unmodified when dropped into an xfree source tree.
 */
#ifndef XORG_VERSION_CURRENT
#define XORG_VERSION_CURRENT XF86_VERSION_CURRENT
#endif

/*
d84 1
a84 17
#define VMMOUSE_PATCHLEVEL 3
#define VMMOUSE_DRIVER_VERSION \
   (VMMOUSE_MAJOR_VERSION * 65536 + VMMOUSE_MINOR_VERSION * 256 + VMMOUSE_PATCHLEVEL)
#define VMMOUSE_DRIVER_VERSION_STRING \
    VMW_STRING(VMMOUSE_MAJOR_VERSION) "." VMW_STRING(VMMOUSE_MINOR_VERSION) \
    "." VMW_STRING(VMMOUSE_PATCHLEVEL)

/*
 * Standard four digit version string expected by VMware Tools installer.
 * As the driver's version is only  {major, minor, patchlevel}, simply append an
 * extra zero for the fourth digit.
 */
#ifdef __GNUC__
const char vm_mouse_version[] __attribute__((section(".modinfo"),unused)) =
    "version=" VMMOUSE_DRIVER_VERSION_STRING ".0";
#endif

a325 1
#if GET_ABI_MAJOR(ABI_XINPUT_VERSION) == 0
a326 1
#endif
d756 2
a757 12
#if GET_ABI_MAJOR(ABI_XINPUT_VERSION) == 0
				miPointerGetMotionEvents,
#else
                                GetMotionHistory,
#endif
                                pMse->Ctrl,
#if GET_ABI_MAJOR(ABI_XINPUT_VERSION) == 0
				miPointerGetMotionBufferSize()
#else
                                GetMotionHistorySize(), 2
#endif
                                );
a764 1
#if GET_ABI_MAJOR(ABI_XINPUT_VERSION) == 0
a765 1
#endif
a921 1
   int numPackets;
d924 1
a924 9
   while((numPackets = VMMouseClient_GetInput(&vmmouseInput))){
      if (numPackets == VMMOUSE_ERROR) {
         VMMouseClient_Disable();
         VMMouseClient_Enable();
         VMMouseClient_RequestAbsolute();
         xf86Msg(X_INFO, "VMWARE(0): re-requesting absolute mode after reset\n");
         break;
      }

@

