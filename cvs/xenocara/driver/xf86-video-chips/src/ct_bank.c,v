head	1.3;
access;
symbols
	OPENBSD_6_0:1.3.0.16
	OPENBSD_6_0_BASE:1.3
	OPENBSD_5_9:1.3.0.14
	OPENBSD_5_9_BASE:1.3
	OPENBSD_5_8:1.3.0.12
	OPENBSD_5_8_BASE:1.3
	OPENBSD_5_7:1.3.0.10
	OPENBSD_5_7_BASE:1.3
	OPENBSD_5_6:1.3.0.8
	OPENBSD_5_6_BASE:1.3
	OPENBSD_5_5:1.3.0.6
	OPENBSD_5_5_BASE:1.3
	OPENBSD_5_4:1.3.0.4
	OPENBSD_5_4_BASE:1.3
	OPENBSD_5_3:1.3.0.2
	OPENBSD_5_3_BASE:1.3
	OPENBSD_5_2:1.2.0.16
	OPENBSD_5_2_BASE:1.2
	OPENBSD_5_1_BASE:1.2
	OPENBSD_5_1:1.2.0.14
	OPENBSD_5_0:1.2.0.12
	OPENBSD_5_0_BASE:1.2
	OPENBSD_4_9:1.2.0.8
	OPENBSD_4_9_BASE:1.2
	OPENBSD_4_8:1.2.0.10
	OPENBSD_4_8_BASE:1.2
	OPENBSD_4_7:1.2.0.6
	OPENBSD_4_7_BASE:1.2
	OPENBSD_4_6:1.2.0.4
	OPENBSD_4_6_BASE:1.2
	OPENBSD_4_5:1.2.0.2
	OPENBSD_4_5_BASE:1.2
	OPENBSD_4_4:1.1.1.1.0.6
	OPENBSD_4_4_BASE:1.1.1.1
	OPENBSD_4_3_BASE:1.1.1.1
	OPENBSD_4_3:1.1.1.1.0.4
	OPENBSD_4_2:1.1.1.1.0.2
	OPENBSD_4_2_BASE:1.1.1.1
	v1_1_1:1.1.1.1
	xorg:1.1.1;
locks; strict;
comment	@ * @;


1.3
date	2012.08.11.09.40.48;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2008.08.23.21.13.12;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.26.20.01.47;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.11.26.20.01.47;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.3
log
@Update to xf86-video-chips 1.2.5
@
text
@
/*
 * Copyright 1997
 * Digital Equipment Corporation. All rights reserved.
 * This software is furnished under license and may be used and copied only in 
 * accordance with the following terms and conditions.  Subject to these 
 * conditions, you may download, copy, install, use, modify and distribute 
 * this software in source and/or binary form. No title or ownership is 
 * transferred hereby.
 * 1) Any source code used, modified or distributed must reproduce and retain 
 *    this copyright notice and list of conditions as they appear in the 
 *    source file.
 *
 * 2) No right is granted to use any trade name, trademark, or logo of Digital 
 *    Equipment Corporation. Neither the "Digital Equipment Corporation" name 
 *    nor any trademark or logo of Digital Equipment Corporation may be used 
 *    to endorse or promote products derived from this software without the 
 *    prior written permission of Digital Equipment Corporation.
 *
 * 3) This software is provided "AS-IS" and any express or implied warranties,
 *    including but not limited to, any implied warranties of merchantability,
 *    fitness for a particular purpose, or non-infringement are disclaimed. In
 *    no event shall DIGITAL be liable for any damages whatsoever, and in 
 *    particular, DIGITAL shall not be liable for special, indirect, 
 *    consequential, or incidental damages or damages for lost profits, loss 
 *    of revenue or loss of use, whether such damages arise in contract, 
 *    negligence, tort, under statute, in equity, at law or otherwise, even if
 *    advised of the possibility of such damage. 
 */

#ifdef HAVE_CONFIG_H
#include "config.h"
#endif

#define PSZ 8

/*
 * Define DIRECT_REGISTER_ACCESS if you want to bypass the wrapped register
 * access functions
 */
/* #define DIRECT_REGISTER_ACCESS */

/* All drivers should typically include these */
#include "xf86.h"
#include "xf86_OSproc.h"

/* Everything using inb/outb, etc needs "compiler.h" */
#include "compiler.h"

/* Drivers that need to access the PCI config space directly need this */
#include "xf86Pci.h"

/* Driver specific headers */
#include "ct_driver.h"

#if defined(__arm32__) && defined(__NetBSD__)
#include <machine/sysarch.h>
#define	arm32_drain_writebuf()	sysarch(1, 0)
#elif defined(__arm32__)
#define arm32_drain_writebuf()
#endif

#define ChipsBank(pScreen) CHIPSPTR(xf86ScreenToScrn(pScreen))->Bank

#ifdef DIRECT_REGISTER_ACCESS
int
CHIPSSetRead(ScreenPtr pScreen, int bank)
{ 
    CHIPSPtr cPtr = CHIPSPTR(xf86ScreenToScrn(pScreen));

    outw(cPtr->PIOBase + 0x3D6, ((((bank << 3) & 0xFF) << 8) | 0x10));

#ifdef	__arm32__
    /* Must drain StrongARM write buffer on bank switch! */
    if (bank != ChipsBank(pScreen)) {
	arm32_drain_writebuf();
	ChipsBank(pScreen) = bank;
    }
#endif

    return 0;
}


int
CHIPSSetWrite(ScreenPtr pScreen, int bank)
{
    CHIPSPtr cPtr = CHIPSPTR(xf86ScreenToScrn(pScreen));

    outw(cPtr->PIOBase + 0x3D6, ((((bank << 3) & 0xFF) << 8) | 0x11));

#ifdef	__arm32__
    /* Must drain StrongARM write buffer on bank switch! */
    if (bank != ChipsBank(pScreen)) {
	arm32_drain_writebuf();
	ChipsBank(pScreen) = bank;
    }
#endif

    return 0;
}


int
CHIPSSetReadWrite(ScreenPtr pScreen, int bank)
{
    CHIPSPtr cPtr = CHIPSPTR(xf86ScreenToScrn(pScreen));

    outw(cPtr->PIOBase + 0x3D6, ((((bank << 3) & 0xFF) << 8) | 0x10));
    outw(cPtr->PIOBase + 0x3D6, ((((bank << 3) & 0xFF) << 8) | 0x11));

#ifdef	__arm32__
    /* Must drain StrongARM write buffer on bank switch! */
    if (bank != ChipsBank(pScreen)) {
	arm32_drain_writebuf();
	ChipsBank(pScreen) = bank;
    }
#endif

    return 0;
}

int
CHIPSSetReadPlanar(ScreenPtr pScreen, int bank)
{
    CHIPSPtr cPtr = CHIPSPTR(xf86ScreenToScrn(pScreen));

    outw(cPtr->PIOBase + 0x3D6, ((((bank << 5) & 0xFF) << 8) | 0x10));

#ifdef	__arm32__
    /* Must drain StrongARM write buffer on bank switch! */
    if (bank != ChipsBank(pScreen)) {
	arm32_drain_writebuf();
	ChipsBank(pScreen) = bank;
    }
#endif

    return 0;
}

int
CHIPSSetWritePlanar(ScreenPtr pScreen, int bank)
{
    CHIPSPtr cPtr = CHIPSPTR(xf86ScreenToScrn(pScreen));

    outw(cPtr->PIOBase + 0x3D6, ((((bank << 5) & 0xFF) << 8) | 0x11));

#ifdef	__arm32__
    /* Must drain StrongARM write buffer on bank switch! */
    if (bank != ChipsBank(pScreen)) {
	arm32_drain_writebuf();
	ChipsBank(pScreen) = bank;
    }
#endif

    return 0;
}

int
CHIPSSetReadWritePlanar(ScreenPtr pScreen, int bank)
{
    CHIPSPtr cPtr = CHIPSPTR(xf86ScreenToScrn(pScreen));

    outw(cPtr->PIOBase + 0x3D6, ((((bank << 5) & 0xFF) << 8) | 0x10));
    outw(cPtr->PIOBase + 0x3D6, ((((bank << 5) & 0xFF) << 8) | 0x11));

#ifdef	__arm32__
    /* Must drain StrongARM write buffer on bank switch! */
    if (bank != ChipsBank(pScreen)) {
	arm32_drain_writebuf();
	ChipsBank(pScreen) = bank;
    }
#endif

    return 0;
}

int
CHIPSWINSetRead(ScreenPtr pScreen, int bank)
{
    CHIPSPtr cPtr = CHIPSPTR(xf86ScreenToScrn(pScreen));
    register unsigned char tmp;

    outw(cPtr->PIOBase + 0x3D6, ((((bank << 3) & 0xFF) << 8) | 0x10));
    outb(cPtr->PIOBase + 0x3D6, 0x0C);
    tmp = inb(cPtr->PIOBase + 0x3D7) & 0xEF;
    outw(cPtr->PIOBase + 0x3D6, (((((bank >> 1) & 0x10) | tmp) << 8) | 0x0C));

#ifdef	__arm32__
    /* Must drain StrongARM write buffer on bank switch! */
    if (bank != ChipsBank(pScreen)) {
	arm32_drain_writebuf();
	ChipsBank(pScreen) = bank;
    }
#endif

    return 0;
}


int
CHIPSWINSetWrite(ScreenPtr pScreen, int bank)
{
    CHIPSPtr cPtr = CHIPSPTR(xf86ScreenToScrn(pScreen));
    register unsigned char tmp;

    outw(cPtr->PIOBase + 0x3D6, ((((bank << 3) & 0xFF) << 8) | 0x11));
    outb(cPtr->PIOBase + 0x3D6, 0x0C);
    tmp = inb(cPtr->PIOBase + 0x3D7) & 0xBF;
    outw(cPtr->PIOBase + 0x3D6, (((((bank << 1) & 0x40) | tmp) << 8) | 0x0C));

#ifdef	__arm32__
    /* Must drain StrongARM write buffer on bank switch! */
    if (bank != ChipsBank(pScreen)) {
	arm32_drain_writebuf();
	ChipsBank(pScreen) = bank;
    }
#endif

    return 0;
}

int
CHIPSWINSetReadWrite(ScreenPtr pScreen, int bank)
{
    CHIPSPtr cPtr = CHIPSPTR(xf86ScreenToScrn(pScreen));
    register unsigned char tmp;

    outw(cPtr->PIOBase + 0x3D6, ((((bank << 3) & 0xFF) << 8) | 0x10));
    outw(cPtr->PIOBase + 0x3D6, ((((bank << 3) & 0xFF) << 8) | 0x11));
    outb(cPtr->PIOBase + 0x3D6, 0x0C);
    tmp = inb(cPtr->PIOBase + 0x3D7) & 0xAF;
    outw(cPtr->PIOBase + 0x3D6,
	(((((bank << 1) & 0x40) | ((bank >> 1) & 0x10) | tmp) << 8) | 0x0C));

#ifdef	__arm32__
    /* Must drain StrongARM write buffer on bank switch! */
    if (bank != ChipsBank(pScreen)) {
	arm32_drain_writebuf();
	ChipsBank(pScreen) = bank;
    }
#endif

    return 0;
}

int
CHIPSWINSetReadPlanar(ScreenPtr pScreen, int bank)
{
    CHIPSPtr cPtr = CHIPSPTR(xf86ScreenToScrn(pScreen));
    register unsigned char tmp;

    outw(cPtr->PIOBase + 0x3D6, ((((bank << 5) & 0xFF) << 8) | 0x10));
    outb(cPtr->PIOBase + 0x3D6, 0x0C);
    tmp = inb(cPtr->PIOBase + 0x3D7) & 0xEF;
    outw(cPtr->PIOBase + 0x3D6, (((((bank << 1) & 0x10) | tmp) << 8) | 0x0C));

#ifdef	__arm32__
    /* Must drain StrongARM write buffer on bank switch! */
    if (bank != ChipsBank(pScreen)) {
	arm32_drain_writebuf();
	ChipsBank(pScreen) = bank;
    }
#endif

    return 0;
}

int
CHIPSWINSetWritePlanar(ScreenPtr pScreen, int bank)
{
    CHIPSPtr cPtr = CHIPSPTR(xf86ScreenToScrn(pScreen));
    register unsigned char tmp;

    outw(cPtr->PIOBase + 0x3D6, ((((bank << 5) & 0xFF) << 8) | 0x11));
    outb(cPtr->PIOBase + 0x3D6, 0x0C);
    tmp = inb(cPtr->PIOBase + 0x3D7) & 0xBF;
    outw(cPtr->PIOBase + 0x3D6, (((((bank << 3) & 0x40) | tmp) << 8) | 0x0C));

#ifdef	__arm32__
    /* Must drain StrongARM write buffer on bank switch! */
    if (bank != ChipsBank(pScreen)) {
	arm32_drain_writebuf();
	ChipsBank(pScreen) = bank;
    }
#endif

    return 0;
}

int
CHIPSWINSetReadWritePlanar(ScreenPtr pScreen, int bank)
{
    CHIPSPtr cPtr = CHIPSPTR(xf86ScreenToScrn(pScreen));
    register unsigned char tmp;

    outw(cPtr->PIOBase + 0x3D6, ((((bank << 5) & 0xFF) << 8) | 0x10));
    outw(cPtr->PIOBase + 0x3D6, ((((bank << 5) & 0xFF) << 8) | 0x11));
    outb(cPtr->PIOBase + 0x3D6, 0x0C);
    tmp = inb(cPtr->PIOBase + 0x3D7) & 0xAF;
    outw(cPtr->PIOBase + 0x3D6,
	(((((bank << 3) & 0x40) | ((bank << 1) & 0x10) | tmp) << 8) | 0x0C));

#ifdef	__arm32__
    /* Must drain StrongARM write buffer on bank switch! */
    if (bank != ChipsBank(pScreen)) {
	arm32_drain_writebuf();
	ChipsBank(pScreen) = bank;
    }
#endif

    return 0;
}

int
CHIPSHiQVSetReadWrite(ScreenPtr pScreen, int bank)
{
    CHIPSPtr cPtr = CHIPSPTR(xf86ScreenToScrn(pScreen));

    outw(cPtr->PIOBase + 0x3D6, (((bank & 0x7F) << 8) | 0x0E));

#ifdef	__arm32__
    /* Must drain StrongARM write buffer on bank switch! */
    if (bank != ChipsBank(pScreen)) {
	arm32_drain_writebuf();
	ChipsBank(pScreen) = bank;
    }
#endif

    return 0;
}

int
CHIPSHiQVSetReadWritePlanar(ScreenPtr pScreen, int bank)
{
    CHIPSPtr cPtr = CHIPSPTR(xf86ScreenToScrn(pScreen));

    outw(cPtr->PIOBase + 0x3D6, ((((bank << 2) & 0x7F) << 8) | 0x0E));

#ifdef	__arm32__
    /* Must drain StrongARM write buffer on bank switch! */
    if (bank != ChipsBank(pScreen)) {
	arm32_drain_writebuf();
	ChipsBank(pScreen) = bank;
    }
#endif

    return 0;
}

#else /* DIRECT_REGISTER_ACCESS */

int
CHIPSSetRead(ScreenPtr pScreen, int bank)
{ 
    CHIPSPtr cPtr = CHIPSPTR(xf86ScreenToScrn(pScreen));
  
    cPtr->writeXR(cPtr, 0x10, ((bank << 3) & 0xFF));

#ifdef	__arm32__
    /* Must drain StrongARM write buffer on bank switch! */
    if (bank != cPtr->Bank) {
	arm32_drain_writebuf();
	cPtr->Bank = bank;
    }
#endif

    return 0;
}


int
CHIPSSetWrite(ScreenPtr pScreen, int bank)
{
    CHIPSPtr cPtr = CHIPSPTR(xf86ScreenToScrn(pScreen));
  
    cPtr->writeXR(cPtr, 0x11, ((bank << 3) & 0xFF));

#ifdef	__arm32__
    /* Must drain StrongARM write buffer on bank switch! */
    if (bank != cPtr->Bank) {
	arm32_drain_writebuf();
	cPtr->Bank = bank;
    }
#endif

    return 0;
}


int
CHIPSSetReadWrite(ScreenPtr pScreen, int bank)
{
    CHIPSPtr cPtr = CHIPSPTR(xf86ScreenToScrn(pScreen));
  
    cPtr->writeXR(cPtr, 0x10, ((bank << 3) & 0xFF));
    cPtr->writeXR(cPtr, 0x11, ((bank << 3) & 0xFF));

#ifdef	__arm32__
    /* Must drain StrongARM write buffer on bank switch! */
    if (bank != cPtr->Bank) {
	arm32_drain_writebuf();
	cPtr->Bank = bank;
    }
#endif

    return 0;
}

int
CHIPSSetReadPlanar(ScreenPtr pScreen, int bank)
{
    CHIPSPtr cPtr = CHIPSPTR(xf86ScreenToScrn(pScreen));
  
    cPtr->writeXR(cPtr, 0x10, ((bank << 5) & 0xFF));

#ifdef	__arm32__
    /* Must drain StrongARM write buffer on bank switch! */
    if (bank != cPtr->Bank) {
	arm32_drain_writebuf();
	cPtr->Bank = bank;
    }
#endif

    return 0;
}

int
CHIPSSetWritePlanar(ScreenPtr pScreen, int bank)
{
    CHIPSPtr cPtr = CHIPSPTR(xf86ScreenToScrn(pScreen));
  
    cPtr->writeXR(cPtr, 0x11, ((bank << 5) & 0xFF));

#ifdef	__arm32__
    /* Must drain StrongARM write buffer on bank switch! */
    if (bank != cPtr->Bank) {
	arm32_drain_writebuf();
	cPtr->Bank = bank;
    }
#endif

    return 0;
}

int
CHIPSSetReadWritePlanar(ScreenPtr pScreen, int bank)
{
    CHIPSPtr cPtr = CHIPSPTR(xf86ScreenToScrn(pScreen));
  
    cPtr->writeXR(cPtr, 0x10, ((bank << 5) & 0xFF));
    cPtr->writeXR(cPtr, 0x11, ((bank << 5) & 0xFF));

#ifdef	__arm32__
    /* Must drain StrongARM write buffer on bank switch! */
    if (bank != cPtr->Bank) {
	arm32_drain_writebuf();
	cPtr->Bank = bank;
    }
#endif

    return 0;
}

int
CHIPSWINSetRead(ScreenPtr pScreen, int bank)
{
    CHIPSPtr cPtr = CHIPSPTR(xf86ScreenToScrn(pScreen));
    register unsigned char tmp;
  
    cPtr->writeXR(cPtr, 0x10, ((bank << 3) & 0xFF));
    tmp = cPtr->readXR(cPtr, 0x0C) & 0xEF;
    cPtr->writeXR(cPtr, 0x0C, ((bank >> 1) & 0x10) | tmp);

#ifdef	__arm32__
    /* Must drain StrongARM write buffer on bank switch! */
    if (bank != cPtr->Bank) {
	arm32_drain_writebuf();
	cPtr->Bank = bank;
    }
#endif

    return 0;
}


int
CHIPSWINSetWrite(ScreenPtr pScreen, int bank)
{
    CHIPSPtr cPtr = CHIPSPTR(xf86ScreenToScrn(pScreen));
    register unsigned char tmp;

    cPtr->writeXR(cPtr, 0x11, ((bank << 3) & 0xFF));
    tmp = cPtr->readXR(cPtr, 0x0C) & 0xBF;
    cPtr->writeXR(cPtr, 0x0C, ((bank << 1) & 0x40) | tmp);

#ifdef	__arm32__
    /* Must drain StrongARM write buffer on bank switch! */
    if (bank != cPtr->Bank) {
	arm32_drain_writebuf();
	cPtr->Bank = bank;
    }
#endif

    return 0;
}

int
CHIPSWINSetReadWrite(ScreenPtr pScreen, int bank)
{
    CHIPSPtr cPtr = CHIPSPTR(xf86ScreenToScrn(pScreen));
    register unsigned char tmp;

    cPtr->writeXR(cPtr, 0x10, ((bank << 3) & 0xFF));
    cPtr->writeXR(cPtr, 0x11, ((bank << 3) & 0xFF));
    tmp = cPtr->readXR(cPtr, 0x0C) & 0xAF;
    cPtr->writeXR(cPtr, 0x0C, ((bank << 1) & 0x40) | ((bank >> 1) & 0x10) | tmp);

#ifdef	__arm32__
    /* Must drain StrongARM write buffer on bank switch! */
    if (bank != cPtr->Bank) {
	arm32_drain_writebuf();
	cPtr->Bank = bank;
    }
#endif

    return 0;
}

int
CHIPSWINSetReadPlanar(ScreenPtr pScreen, int bank)
{
    CHIPSPtr cPtr = CHIPSPTR(xf86ScreenToScrn(pScreen));
    register unsigned char tmp;

    cPtr->writeXR(cPtr, 0x10, ((bank << 5) & 0xFF));
    tmp = cPtr->readXR(cPtr, 0x0C) & 0xEF;
    cPtr->writeXR(cPtr, 0x0C, ((bank << 1) & 0x10) | tmp);

#ifdef	__arm32__
    /* Must drain StrongARM write buffer on bank switch! */
    if (bank != cPtr->Bank) {
	arm32_drain_writebuf();
	cPtr->Bank = bank;
    }
#endif

    return 0;
}

int
CHIPSWINSetWritePlanar(ScreenPtr pScreen, int bank)
{
    CHIPSPtr cPtr = CHIPSPTR(xf86ScreenToScrn(pScreen));
    register unsigned char tmp;

    cPtr->writeXR(cPtr, 0x11, ((bank << 5) & 0xFF));
    tmp = cPtr->readXR(cPtr, 0x0C) & 0xBF;
    cPtr->writeXR(cPtr, 0x0C, ((bank << 3) & 0x40) | tmp);

#ifdef	__arm32__
    /* Must drain StrongARM write buffer on bank switch! */
    if (bank != cPtr->Bank) {
	arm32_drain_writebuf();
	cPtr->Bank = bank;
    }
#endif

    return 0;
}

int
CHIPSWINSetReadWritePlanar(ScreenPtr pScreen, int bank)
{
    CHIPSPtr cPtr = CHIPSPTR(xf86ScreenToScrn(pScreen));
    register unsigned char tmp;

    cPtr->writeXR(cPtr, 0x10, ((bank << 5) & 0xFF));
    cPtr->writeXR(cPtr, 0x11, ((bank << 5) & 0xFF));
    tmp = cPtr->readXR(cPtr, 0x0C) & 0xAF;
    cPtr->writeXR(cPtr, 0x0C, ((bank << 3) & 0x40) | ((bank << 1) & 0x10) | tmp);

#ifdef	__arm32__
    /* Must drain StrongARM write buffer on bank switch! */
    if (bank != cPtr->Bank) {
	arm32_drain_writebuf();
	cPtr->Bank = bank;
    }
#endif

    return 0;
}

int
CHIPSHiQVSetReadWrite(ScreenPtr pScreen, int bank)
{
    CHIPSPtr cPtr = CHIPSPTR(xf86ScreenToScrn(pScreen));

    cPtr->writeXR(cPtr, 0x0E, bank & 0x7F);

#ifdef	__arm32__
    /* Must drain StrongARM write buffer on bank switch! */
    if (bank != cPtr->Bank) {
	arm32_drain_writebuf();
	cPtr->Bank = bank;
    }
#endif

    return 0;
}

int
CHIPSHiQVSetReadWritePlanar(ScreenPtr pScreen, int bank)
{
    CHIPSPtr cPtr = CHIPSPTR(xf86ScreenToScrn(pScreen));

    cPtr->writeXR(cPtr, 0x0E, (bank << 2) & 0x7F);

#ifdef	__arm32__
    /* Must drain StrongARM write buffer on bank switch! */
    if (bank != cPtr->Bank) {
	arm32_drain_writebuf();
	cPtr->Bank = bank;
    }
#endif

    return 0;
}
#endif
@


1.2
log
@xf86-video-chips 1.2.0
@
text
@a49 3
/* Drivers for PCI hardware need this */
#include "xf86PciInfo.h"

d63 1
a63 1
#define ChipsBank(pScreen) CHIPSPTR(xf86Screens[pScreen->myNum])->Bank
d69 1
a69 1
    CHIPSPtr cPtr = CHIPSPTR(xf86Screens[pScreen->myNum]);
d88 1
a88 1
    CHIPSPtr cPtr = CHIPSPTR(xf86Screens[pScreen->myNum]);
d107 1
a107 1
    CHIPSPtr cPtr = CHIPSPTR(xf86Screens[pScreen->myNum]);
d126 1
a126 1
    CHIPSPtr cPtr = CHIPSPTR(xf86Screens[pScreen->myNum]);
d144 1
a144 1
    CHIPSPtr cPtr = CHIPSPTR(xf86Screens[pScreen->myNum]);
d162 1
a162 1
    CHIPSPtr cPtr = CHIPSPTR(xf86Screens[pScreen->myNum]);
d181 1
a181 1
    CHIPSPtr cPtr = CHIPSPTR(xf86Screens[pScreen->myNum]);
d204 1
a204 1
    CHIPSPtr cPtr = CHIPSPTR(xf86Screens[pScreen->myNum]);
d226 1
a226 1
    CHIPSPtr cPtr = CHIPSPTR(xf86Screens[pScreen->myNum]);
d250 1
a250 1
    CHIPSPtr cPtr = CHIPSPTR(xf86Screens[pScreen->myNum]);
d272 1
a272 1
    CHIPSPtr cPtr = CHIPSPTR(xf86Screens[pScreen->myNum]);
d294 1
a294 1
    CHIPSPtr cPtr = CHIPSPTR(xf86Screens[pScreen->myNum]);
d318 1
a318 1
    CHIPSPtr cPtr = CHIPSPTR(xf86Screens[pScreen->myNum]);
d336 1
a336 1
    CHIPSPtr cPtr = CHIPSPTR(xf86Screens[pScreen->myNum]);
d356 1
a356 1
    CHIPSPtr cPtr = CHIPSPTR(xf86Screens[pScreen->myNum]);
d375 1
a375 1
    CHIPSPtr cPtr = CHIPSPTR(xf86Screens[pScreen->myNum]);
d394 1
a394 1
    CHIPSPtr cPtr = CHIPSPTR(xf86Screens[pScreen->myNum]);
d413 1
a413 1
    CHIPSPtr cPtr = CHIPSPTR(xf86Screens[pScreen->myNum]);
d431 1
a431 1
    CHIPSPtr cPtr = CHIPSPTR(xf86Screens[pScreen->myNum]);
d449 1
a449 1
    CHIPSPtr cPtr = CHIPSPTR(xf86Screens[pScreen->myNum]);
d468 1
a468 1
    CHIPSPtr cPtr = CHIPSPTR(xf86Screens[pScreen->myNum]);
d490 1
a490 1
    CHIPSPtr cPtr = CHIPSPTR(xf86Screens[pScreen->myNum]);
d511 1
a511 1
    CHIPSPtr cPtr = CHIPSPTR(xf86Screens[pScreen->myNum]);
d533 1
a533 1
    CHIPSPtr cPtr = CHIPSPTR(xf86Screens[pScreen->myNum]);
d554 1
a554 1
    CHIPSPtr cPtr = CHIPSPTR(xf86Screens[pScreen->myNum]);
d575 1
a575 1
    CHIPSPtr cPtr = CHIPSPTR(xf86Screens[pScreen->myNum]);
d597 1
a597 1
    CHIPSPtr cPtr = CHIPSPTR(xf86Screens[pScreen->myNum]);
d615 1
a615 1
    CHIPSPtr cPtr = CHIPSPTR(xf86Screens[pScreen->myNum]);
@


1.1
log
@Initial revision
@
text
@a0 1
/* $XFree86: xc/programs/Xserver/hw/xfree86/drivers/chips/ct_bank.c,v 1.6 2002/01/25 21:55:58 tsi Exp $ */
@


1.1.1.1
log
@Importing xf86-video-chips 1.1.1
@
text
@@
