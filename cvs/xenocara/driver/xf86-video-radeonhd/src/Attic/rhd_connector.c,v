head	1.10;
access;
symbols
	OPENBSD_5_1_BASE:1.9
	OPENBSD_5_1:1.9.0.2
	OPENBSD_5_0:1.7.0.8
	OPENBSD_5_0_BASE:1.7
	OPENBSD_4_9:1.7.0.4
	OPENBSD_4_9_BASE:1.7
	OPENBSD_4_8:1.7.0.6
	OPENBSD_4_8_BASE:1.7
	OPENBSD_4_7:1.7.0.2
	OPENBSD_4_7_BASE:1.7
	OPENBSD_4_6:1.6.0.2
	OPENBSD_4_6_BASE:1.6
	OPENBSD_4_5:1.5.0.2
	OPENBSD_4_5_BASE:1.5
	OPENBSD_4_4:1.3.0.2
	OPENBSD_4_4_BASE:1.3
	OPENBSD_4_3_BASE:1.1.1.2
	OPENBSD_4_3:1.1.1.2.0.2
	v1_1_0:1.1.1.2
	v1_0:1.1.1.1
	xorg:1.1.1;
locks; strict;
comment	@ * @;


1.10
date	2012.03.04.16.09.06;	author matthieu;	state dead;
branches;
next	1.9;

1.9
date	2012.02.06.22.53.13;	author matthieu;	state Exp;
branches;
next	1.8;

1.8
date	2012.01.31.07.59.54;	author matthieu;	state dead;
branches;
next	1.7;

1.7
date	2009.11.24.16.57.34;	author matthieu;	state Exp;
branches;
next	1.6;

1.6
date	2009.04.26.13.59.41;	author matthieu;	state Exp;
branches;
next	1.5;

1.5
date	2009.01.28.14.43.56;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2008.11.01.18.14.37;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2008.04.19.14.02.04;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2008.04.19.13.41.45;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2007.12.04.22.20.27;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2007.12.04.22.20.27;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2008.01.05.17.28.35;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.10
log
@Remove xf86-video-radeonhd for good.
@
text
@/*
 * Copyright 2007, 2008  Luc Verhaegen <libv@@exsuse.de>
 * Copyright 2007, 2008  Matthias Hopf <mhopf@@novell.com>
 * Copyright 2007, 2008 Egbert Eich   <eich@@novell.com>
 * Copyright 2007, 2008  Advanced Micro Devices, Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE COPYRIGHT HOLDER(S) OR AUTHOR(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR
 * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 */

#ifdef HAVE_CONFIG_H
#include "config.h"
#endif

#include "xf86.h"
#include "xf86i2c.h"
#include "edid.h"

/* for usleep */
#if HAVE_XF86_ANSIC_H
# include "xf86_ansic.h"
#else
# include <unistd.h>
# include <string.h>
# include <stdio.h>
#endif

#include "rhd.h"
#ifdef ATOM_BIOS
# include "rhd_atombios.h"
#endif
#include "rhd_connector.h"
#include "rhd_output.h"
#include "rhd_regs.h"
#include "rhd_monitor.h"
#include "rhd_card.h"
#include "rhd_i2c.h"

/*
 *
 */
struct rhdHPD {
    Bool Stored;
    CARD32 StoreMask;
    CARD32 StoreEnable;
};

/*
 *
 */
void
RHDHPDSave(RHDPtr rhdPtr)
{
    struct rhdHPD *hpd = rhdPtr->HPD;

    RHDFUNC(rhdPtr);

    hpd->StoreMask = RHDRegRead(rhdPtr, DC_GPIO_HPD_MASK);
    hpd->StoreEnable = RHDRegRead(rhdPtr, DC_GPIO_HPD_EN);

    hpd->Stored = TRUE;
}

/*
 *
 */
void
RHDHPDRestore(RHDPtr rhdPtr)
{
    struct rhdHPD *hpd = rhdPtr->HPD;

    RHDFUNC(rhdPtr);

    if (hpd->Stored) {
	RHDRegWrite(rhdPtr, DC_GPIO_HPD_MASK, hpd->StoreMask);
	RHDRegWrite(rhdPtr, DC_GPIO_HPD_EN, hpd->StoreEnable);
    } else
	xf86DrvMsg(rhdPtr->scrnIndex, X_ERROR,
		   "%s: no registers stored.\n", __func__);
}

/*
 *
 */
static void
RHDHPDSet(RHDPtr rhdPtr)
{
    RHDFUNC(rhdPtr);

    /* give the hw full control */
    RHDRegWrite(rhdPtr, DC_GPIO_HPD_MASK, 0);
    RHDRegWrite(rhdPtr, DC_GPIO_HPD_EN, 0);

    usleep(1);
}

/*
 *
 */
static Bool
RHDHPDCheck(struct rhdConnector *Connector)
{
    Bool ret;

    RHDFUNC(Connector);

    ret = RHDRegRead(Connector, DC_GPIO_HPD_Y);
    RHDDebug(Connector->scrnIndex, "%s returned: %x mask: %x\n",
	     __func__,ret, Connector->HPDMask);

    return (ret & Connector->HPDMask);
}

struct rhdCsState {
    int vga_cnt;
    int dvi_cnt;
};

/*
 *
 */
static char *
rhdConnectorSynthName(struct rhdConnectorInfo *ConnectorInfo,
		      struct rhdCsState **state)
{
    char *str = NULL;
    char *TypeName;
    char *str1, *str2;
    int cnt;

    ASSERT(state != NULL);

    if (!*state) {
	if (!(*state = xcalloc(sizeof(struct rhdCsState), 1)))
	    return NULL;
    }
    switch (ConnectorInfo->Type) {
	case RHD_CONNECTOR_NONE:
	    return NULL;
	case RHD_CONNECTOR_DVI:
	case RHD_CONNECTOR_DVI_SINGLE:
	    if (ConnectorInfo->Output[0] && ConnectorInfo->Output[1]) {
		TypeName = "DVI-I";
		cnt = ++(*state)->dvi_cnt;
	    } else if (ConnectorInfo->Output[0] == RHD_OUTPUT_DACA
		     || ConnectorInfo->Output[0] == RHD_OUTPUT_DACB
		     || ConnectorInfo->Output[1] == RHD_OUTPUT_DACA
		     || ConnectorInfo->Output[1] == RHD_OUTPUT_DACB
		) {
		if (ConnectorInfo->HPD == RHD_HPD_NONE) {
		    TypeName = "VGA";
		    cnt = ++(*state)->vga_cnt;
		} else {
		    TypeName = "DVI-A";
		    cnt = ++(*state)->dvi_cnt;
		}
	    } else {
		TypeName = "DVI-D";
		cnt = ++(*state)->dvi_cnt;
	    }
	    str = xalloc(12);
	    snprintf(str, 11, "%s %i",TypeName, cnt);
	    return str;

	case RHD_CONNECTOR_VGA:
	    str = xalloc(10);
	    snprintf(str, 9, "VGA %i",++(*state)->vga_cnt);
	    return str;

	case RHD_CONNECTOR_PANEL:
	    str = xalloc(10);
	    snprintf(str, 9, "PANEL");
	    return str;

	case RHD_CONNECTOR_TV:
	    str1 = xstrdup(ConnectorInfo->Name);
	    str = xalloc(20);
	    str2 = strchr(str1, ' ');
	    if (str2) *(str2) = '\0';
	    snprintf(str, 20, "TV %s",str1);
	    xfree(str1);
	    return str;

	case RHD_CONNECTOR_PCIE: /* should never get here */
	    return NULL;
    }
    return NULL;
}

/*
 *
 */
Bool
RHDConnectorsInit(RHDPtr rhdPtr, struct rhdCard *Card)
{
    struct rhdConnectorInfo *ConnectorInfo;
    struct rhdConnector *Connector;
    struct rhdOutput *Output;
    struct rhdCsState *csstate = NULL;
    int i, j, k, l, hpd;
    Bool InfoAllocated = FALSE;

    RHDFUNC(rhdPtr);

    /* Card->ConnectorInfo is there to work around quirks, so check it first */
    if (Card && (Card->ConnectorInfo[0].Type != RHD_CONNECTOR_NONE)) {
	ConnectorInfo = Card->ConnectorInfo;
	xf86DrvMsg(rhdPtr->scrnIndex, X_INFO,
		   "ConnectorInfo from quirk table:\n");
	RhdPrintConnectorInfo (rhdPtr->scrnIndex, ConnectorInfo);
    } else {
#ifdef ATOM_BIOS
	/* common case */
	AtomBiosArgRec data;
	AtomBiosResult result;

	data.chipset = rhdPtr->ChipSet;
	result = RHDAtomBiosFunc(rhdPtr->scrnIndex, rhdPtr->atomBIOS,
				 ATOM_GET_CONNECTORS, &data);
	if (result == ATOM_SUCCESS) {
	    ConnectorInfo = data.ConnectorInfo;
	    InfoAllocated = TRUE;
	} else
#endif
        {
	    xf86DrvMsg(rhdPtr->scrnIndex, X_ERROR, "%s: Failed to retrieve "
		       "Connector information.\n", __func__);
	    return FALSE;
	}
    }
    /* Init HPD */
    rhdPtr->HPD = xnfcalloc(sizeof(struct rhdHPD), 1);
    RHDHPDSave(rhdPtr);
    RHDHPDSet(rhdPtr);

    for (i = 0, j = 0; i < RHD_CONNECTORS_MAX; i++) {
	if (ConnectorInfo[i].Type == RHD_CONNECTOR_NONE)
	    continue;

	RHDDebug(rhdPtr->scrnIndex, "%s: %d (%s) type %d, ddc %d, hpd %d\n",
		 __func__, i, ConnectorInfo[i].Name, ConnectorInfo[i].Type,
		 ConnectorInfo[i].DDC, ConnectorInfo[i].HPD);

	Connector = xnfcalloc(sizeof(struct rhdConnector), 1);

	Connector->scrnIndex = rhdPtr->scrnIndex;

	Connector->Type = ConnectorInfo[i].Type;
	Connector->Name = rhdConnectorSynthName(&ConnectorInfo[i], &csstate);

	/* Get the DDC bus of this connector */
	if (ConnectorInfo[i].DDC != RHD_DDC_NONE) {
	    RHDI2CDataArg data;
	    int ret;

	    data.i = ConnectorInfo[i].DDC;
	    ret = RHDI2CFunc(rhdPtr->scrnIndex,
			     rhdPtr->I2C, RHD_I2C_GETBUS, &data);
	    if (ret == RHD_I2C_SUCCESS)
		Connector->DDC = data.i2cBusPtr;
	}

	/* attach HPD */
	hpd = ConnectorInfo[i].HPD;
	switch (rhdPtr->hpdUsage) {
	case RHD_HPD_USAGE_OFF:
	case RHD_HPD_USAGE_AUTO_OFF:
	    hpd = RHD_HPD_NONE;
	    break;
	case RHD_HPD_USAGE_SWAP:
	case RHD_HPD_USAGE_AUTO_SWAP:
	    switch (hpd) {
	    case RHD_HPD_0:
		hpd = RHD_HPD_1;
		break;
	    case RHD_HPD_1:
		hpd = RHD_HPD_0;
		break;
	    }
	    break;
	default:
	    break;
	}
	switch(hpd) {
	case RHD_HPD_0:
	    Connector->HPDMask = 0x00000001;
	    Connector->HPDCheck = RHDHPDCheck;
	    break;
	case RHD_HPD_1:
	    Connector->HPDMask = 0x00000100;
	    Connector->HPDCheck = RHDHPDCheck;
	    break;
	case RHD_HPD_2:
	    Connector->HPDMask = 0x00010000;
	    Connector->HPDCheck = RHDHPDCheck;
	    break;
	case RHD_HPD_3:
	    Connector->HPDMask = 0x01000000;
	    Connector->HPDCheck = RHDHPDCheck;
	    break;
	default:
	    Connector->HPDCheck = NULL;
	    break;
	}

	/* create Outputs */
	for (k = 0; k < 2; k++) {
	    if (ConnectorInfo[i].Output[k] == RHD_OUTPUT_NONE)
		continue;

	    /* Check whether the output exists already */
	    for (Output = rhdPtr->Outputs; Output; Output = Output->Next)
		if (Output->Id == ConnectorInfo[i].Output[k])
		    break;

	    if (!Output) {
		if (!RHDUseAtom(rhdPtr, NULL, atomUsageOutput)) {
		    switch (ConnectorInfo[i].Output[k]) {
		    case RHD_OUTPUT_DACA:
			Output = RHDDACAInit(rhdPtr);
			RHDOutputAdd(rhdPtr, Output);
			break;
		    case RHD_OUTPUT_DACB:
			Output = RHDDACBInit(rhdPtr);
			RHDOutputAdd(rhdPtr, Output);
			break;
		    case RHD_OUTPUT_TMDSA:
			Output = RHDTMDSAInit(rhdPtr);
			RHDOutputAdd(rhdPtr, Output);
			break;
		    case RHD_OUTPUT_LVTMA:
			Output = RHDLVTMAInit(rhdPtr, ConnectorInfo[i].Type);
			RHDOutputAdd(rhdPtr, Output);
			break;
		    case RHD_OUTPUT_DVO:
			Output = RHDDDIAInit(rhdPtr);
			if (Output)
			    RHDOutputAdd(rhdPtr, Output);
			break;
		    case RHD_OUTPUT_KLDSKP_LVTMA:
		    case RHD_OUTPUT_UNIPHYA:
		    case RHD_OUTPUT_UNIPHYB:
			Output = RHDDIGInit(rhdPtr, ConnectorInfo[i].Output[k], ConnectorInfo[i].Type);
			RHDOutputAdd(rhdPtr, Output);
			break;
		    default:
			xf86DrvMsg(rhdPtr->scrnIndex, X_ERROR,
				   "%s: unhandled output id: %d. Trying fallback to AtomBIOS\n", __func__,
				   ConnectorInfo[i].Output[k]);
			break;
		    }
		}
#ifdef ATOM_BIOS
		if (!Output) {
		    Output = RHDAtomOutputInit(rhdPtr, ConnectorInfo[i].Type,
					       ConnectorInfo[i].Output[k]);
		    if (Output)
			RHDOutputAdd(rhdPtr, Output);
		}
#endif
	    }

	    if (Output) {
		xf86DrvMsg(rhdPtr->scrnIndex, X_PROBED,
			   "Attaching Output %s to Connector %s\n",
			   Output->Name, Connector->Name);
		for (l = 0; l < 2; l++)
		    if (!Connector->Output[l]) {
			Connector->Output[l] = Output;
			break;
		    }
	    }
	}

	rhdPtr->Connector[j] = Connector;
	j++;
    }
    if (csstate)
	xfree(csstate);

    /* Deallocate what atombios code allocated */
    if (ConnectorInfo && InfoAllocated) {
	for (i = 0; i < RHD_CONNECTORS_MAX; i++)
	    if (ConnectorInfo[i].Type != RHD_CONNECTOR_NONE)
		xfree(ConnectorInfo[i].Name);
	/* Don't free the Privates as they are hooked into the rhdConnector structures !!! */
	xfree(ConnectorInfo);
    }

    RHDHPDRestore(rhdPtr);

    return (j && 1);
}

/*
 *
 */
void
RHDConnectorsDestroy(RHDPtr rhdPtr)
{
    struct rhdConnector *Connector;
    int i;

    RHDFUNC(rhdPtr);

    for (i = 0; i < RHD_CONNECTORS_MAX; i++) {
	Connector = rhdPtr->Connector[i];
	if (Connector) {
	    if (Connector->Monitor)
		RHDMonitorDestroy(Connector->Monitor);
	    xfree(Connector->Name);
	    xfree(Connector);
	}
    }
}

/*
 *
 */
void
RhdPrintConnectorInfo(int scrnIndex, struct rhdConnectorInfo *cp)
{
    int n;
    ScrnInfoPtr pScrn = xf86Screens[scrnIndex];
    RHDPtr rhdPtr = RHDPTR(pScrn);

    const char *c_name[] =
	{ "RHD_CONNECTOR_NONE", "RHD_CONNECTOR_VGA", "RHD_CONNECTOR_DVI",
	  "RHD_CONNECTOR_DVI_SINGLE", "RHD_CONNECTOR_PANEL",
	  "RHD_CONNECTOR_TV", "RHD_CONNECTOR_PCIE" };

    const char *ddc_name[] =
	{ "RHD_DDC_0", "RHD_DDC_1", "RHD_DDC_2", "RHD_DDC_3", "RHD_DDC_4" };

    const char *hpd_name_normal[] =
	{ "RHD_HPD_NONE", "RHD_HPD_0", "RHD_HPD_1", "RHD_HPD_2", "RHD_HPD_3" };
    const char *hpd_name_off[] =
	{ "RHD_HPD_NONE", "RHD_HPD_NONE /*0*/", "RHD_HPD_NONE /*1*/", "RHD_HPD_NONE /*2*/", "RHD_HPD_NONE /*3*/" };
    const char *hpd_name_swapped[] =
	{ "RHD_HPD_NONE", "RHD_HPD_1 /*swapped*/", "RHD_HPD_0 /*swapped*/", "RHD_HPD_2", "RHD_HPD_3" };

    const char *output_name[] =
	{ "RHD_OUTPUT_NONE", "RHD_OUTPUT_DACA", "RHD_OUTPUT_DACB", "RHD_OUTPUT_TMDSA",
	  "RHD_OUTPUT_LVTMA", "RHD_OUTPUT_DVO", "RHD_OUTPUT_KLDSKP_LVTMA",
	  "RHD_OUTPUT_UNIPHYA", "RHD_OUTPUT_UNIPHYB", "RHD_OUTPUT_UNIPHYC", "RHD_OUTPUT_UNIPHYD",
	  "RHD_OUTPUT_UNIPHYE", "RHD_OUTPUT_UNIPHYF" };
    const char **hpd_name;

    switch (rhdPtr->hpdUsage) {
    case RHD_HPD_USAGE_OFF:
    case RHD_HPD_USAGE_AUTO_OFF:
	hpd_name = hpd_name_off;
	break;
    case RHD_HPD_USAGE_SWAP:
    case RHD_HPD_USAGE_AUTO_SWAP:
	hpd_name = hpd_name_swapped;
	break;
    default:
	hpd_name = hpd_name_normal;
	break;
    }

    for (n = 0; n < RHD_CONNECTORS_MAX; n++) {
	if (cp[n].Type == RHD_CONNECTOR_NONE)
	    break;
	xf86DrvMsg(scrnIndex, X_INFO, "Connector[%i] {%s, \"%s\", %s, %s, { %s, %s } }\n",
		   n, c_name[cp[n].Type], cp[n].Name,
		   cp[n].DDC == RHD_DDC_NONE ? "RHD_DDC_NONE" : ddc_name[cp[n].DDC],
		   hpd_name[cp[n].HPD], output_name[cp[n].Output[0]],
		   output_name[cp[n].Output[1]]);
    }
}

/*
 * Should we enable HDMI on this connector?
 */
Bool RHDConnectorEnableHDMI(struct rhdConnector *Connector)
{
    RHDPtr rhdPtr = RHDPTRI(Connector);
    RHDFUNC(rhdPtr);

    /* check if user forced HDMI on this connector */
    switch(RhdParseBooleanOption(&rhdPtr->hdmi, Connector->Name)) {
	case RHD_OPTION_ON:
	case RHD_OPTION_DEFAULT:
	    xf86DrvMsg(rhdPtr->scrnIndex, X_INFO, "Enabling HDMI on %s because of config option\n", Connector->Name);
	    return TRUE;
	case RHD_OPTION_OFF:
	    xf86DrvMsg(rhdPtr->scrnIndex, X_INFO, "Disabling HDMI on %s because of config option\n", Connector->Name);
	    return FALSE;
	case RHD_OPTION_NOT_SET:
	    /* ask connected monitor if it supports HDMI */
	    /* TODO: Not implemented yet! */
	    return FALSE;
    }

    return FALSE;
}
@


1.9
log
@Revert the update to xf86-video-ati 6.14.3. Requested by espie@@
who experiemnts regressions with this driver.
@
text
@@


1.8
log
@Remove 2 obsolete drivers that have been unlinked from builds.
@
text
@@


1.7
log
@Update to xf86-video-radeonhd 1.3.0
Tested by killi@@ on a HD3200.
@
text
@@


1.6
log
@Update to xf86-video-radeonhd 1.2.5. Tested by eric@@

Version 1.2.5 improvements:

  - Added 2D acceleration for R6xx and R7xx.
  - Added XVideo support for R6xx and R7xx.
  - Added support for RS880 and RV790.
  - Added RandR 1.3 mandatory properties.
  - Refactoring of MC code.
  - Enable DRI support by default on R5xx and RS6xx.
  - LUT (color lookup table) fixes.
  - Tons of quirk table entries and bug fixes.
  - Fix register accesses for processors that reorder memory writes.
@
text
@d234 1
a234 1
				 ATOMBIOS_GET_CONNECTORS, &data);
@


1.5
log
@Update to xf86-video-radeonhd 1.2.4.

  - Added HDMI support.
  - Added support for RV710, RV730 (DCE 3.2).
  - Added screen rotation support.
  - Added RandR 1.3 panning support. (not useful until xserver 1.6)
  - Many acceleration and build fixes.

Tested on mbalmer@@'s radeon 2400HD card.
@
text
@d2 1
a2 1
 * Copyright 2007, 2008  Luc Verhaegen <lverhaegen@@novell.com>
@


1.4
log
@xf86-video-radeonhd 1.2.3
@
text
@d448 1
a448 1
	{ "RHD_DDC_0", "RHD_DDC_1", "RHD_DDC_2", "RHD_DDC_3" };
d460 2
a461 1
	  "RHD_OUTPUT_UNIPHYA", "RHD_OUTPUT_UNIPHYB" };
d487 26
@


1.3
log
@update to xf86-video-radeonhd-1.2.1.
@
text
@d44 3
a53 4
#ifdef ATOM_BIOS
#include "rhd_atombios.h"
#endif

d142 1
a142 1
    char *typec;
d144 1
d157 4
a160 3
	    if (ConnectorInfo->Output[0] && ConnectorInfo->Output[1])
		typec = "I";
	    else if (ConnectorInfo->Output[0] == RHD_OUTPUT_DACA
d164 12
a175 4
		)
		typec = "A";
	    else
		typec = "D";
d177 1
a177 1
	    snprintf(str, 11, "DVI-%s %i",typec, ++(*state)->dvi_cnt);
d197 1
d199 2
a200 1
	    return str;
d224 1
a224 1
		   "ConnectorInfo from quirk table:");
d236 1
a236 1
	    ConnectorInfo = data.connectorInfo;
a245 1

d312 4
d332 18
a349 17
		switch (ConnectorInfo[i].Output[k]) {
		case RHD_OUTPUT_DACA:
		    Output = RHDDACAInit(rhdPtr);
		    RHDOutputAdd(rhdPtr, Output);
		    break;
		case RHD_OUTPUT_DACB:
		    Output = RHDDACBInit(rhdPtr);
		    RHDOutputAdd(rhdPtr, Output);
		    break;
		case RHD_OUTPUT_TMDSA:
		    Output = RHDTMDSAInit(rhdPtr);
		    RHDOutputAdd(rhdPtr, Output);
		    break;
		case RHD_OUTPUT_LVTMA:
		    Output = RHDLVTMAInit(rhdPtr, ConnectorInfo[i].Type);
		    RHDOutputAdd(rhdPtr, Output);
		    break;
d351 21
a371 1
		    Output = RHDDDIAInit(rhdPtr, ConnectorInfo[i].Type);
a373 12
		    break;
		case RHD_OUTPUT_KLDSKP_LVTMA:
		case RHD_OUTPUT_UNIPHYA:
		case RHD_OUTPUT_UNIPHYB:
		    Output = RHDDIGInit(rhdPtr, ConnectorInfo[i].Output[k], ConnectorInfo[i].Type);
		    RHDOutputAdd(rhdPtr, Output);
		    break;
		default:
		    xf86DrvMsg(rhdPtr->scrnIndex, X_ERROR,
			       "%s: unhandled output id: %d\n", __func__,
			       ConnectorInfo[i].Output[k]);
		    break;
d375 1
d401 1
d444 2
a445 1
	  "RHD_CONNECTOR_DVI_SINGLE", "RHD_CONNECTOR_PANEL", "RHD_CONNECTOR_TV" };
d451 1
a451 1
	{ "RHD_HPD_NONE", "RHD_HPD_0", "RHD_HPD_1", "RHD_HPD_2" };
d453 1
a453 1
	{ "RHD_HPD_NONE", "RHD_HPD_NONE /*0*/", "RHD_HPD_NONE /*1*/", "RHD_HPD_NONE /*2*/" };
d455 1
a455 1
	{ "RHD_HPD_NONE", "RHD_HPD_1 /*swapped*/", "RHD_HPD_0 /*swapped*/", "RHD_HPD_2" };
d482 1
a482 1
		   cp[n].DDC == RHD_DDC_NONE ? "DDC_NONE" : ddc_name[cp[n].DDC],
@


1.2
log
@Update to xf86-video-radeonhd 1.2.0. Tested by jdixon@@ and jasper@@
@
text
@d146 1
a146 1
    assert(state != NULL);
@


1.1
log
@Initial revision
@
text
@d2 4
a5 4
 * Copyright 2007  Luc Verhaegen <lverhaegen@@novell.com>
 * Copyright 2007  Matthias Hopf <mhopf@@novell.com>
 * Copyright 2007  Egbert Eich   <eich@@novell.com>
 * Copyright 2007  Advanced Micro Devices, Inc.
d31 1
d35 7
a41 1
#include "xf86_ansic.h"
d49 1
a54 3
#include "xf86i2c.h"
#include "rhd_i2c.h"

d119 9
a127 1
    return (RHDRegRead(Connector, DC_GPIO_HPD_Y) & Connector->HPDMask);
d139 1
a139 1
rhdConnectorSynthName(struct rhdConnectorInfo *ConnectorInfo, 
d146 1
a146 1
    assert(state != NULL); 
d156 1
d159 1
a159 1
	    else if (ConnectorInfo->Output[0] == RHD_OUTPUT_DACA 
d165 1
a165 1
	    else 
d182 1
a182 1
	    str1 = strdup(ConnectorInfo->Name);
d204 1
a204 1
    int i, j, k, l;
d210 1
a210 1
    if (Card && (Card->ConnectorInfo[0].Type != RHD_CONNECTOR_NONE))
d212 4
a215 1
    else {
d221 1
d269 21
a289 1
	switch(ConnectorInfo[i].HPD) {
d335 11
d414 3
d419 1
a419 1
	  "RHD_CONNECTOR_PANEL", "RHD_CONNECTOR_TV" };
d424 1
a424 1
    const char *hpd_name[] =
d426 4
d433 17
a449 2
	  "RHD_OUTPUT_LVTMA"
	};
@


1.1.1.1
log
@xf86-video-radeonhd 1.0
@
text
@@


1.1.1.2
log
@xf86-video-radeonhd 1.1.0
@
text
@d34 1
a34 7
#if HAVE_XF86_ANSIC_H
# include "xf86_ansic.h"
#else
# include <unistd.h>
# include <string.h>
# include <stdio.h>
#endif
d168 1
a168 1
	    str1 = xstrdup(ConnectorInfo->Name);
d190 1
a190 1
    int i, j, k, l, hpd;
d196 1
a196 1
    if (Card && (Card->ConnectorInfo[0].Type != RHD_CONNECTOR_NONE)) {
d198 1
a198 4
	xf86DrvMsg(rhdPtr->scrnIndex, X_INFO,
		   "ConnectorInfo from quirk table:");
	RhdPrintConnectorInfo (rhdPtr->scrnIndex, ConnectorInfo);
    } else {
d251 1
a251 20
	hpd = ConnectorInfo[i].HPD;
	switch (rhdPtr->hpdUsage) {
	case RHD_HPD_USAGE_OFF:
	    hpd = RHD_HPD_NONE;
	    break;
	case RHD_HPD_USAGE_AUTO_SWAP:
	case RHD_HPD_USAGE_SWAP:
	    switch (hpd) {
	    case RHD_HPD_0:
		hpd = RHD_HPD_1;
		break;
	    case RHD_HPD_1:
		hpd = RHD_HPD_0;
		break;
	    }
	    break;
	default:
	    break;
	}
	switch(hpd) {
a364 3
    ScrnInfoPtr pScrn = xf86Screens[scrnIndex];
    RHDPtr rhdPtr = RHDPTR(pScrn);

d372 1
a372 1
    const char *hpd_name_normal[] =
a373 4
    const char *hpd_name_off[] =
	{ "RHD_HPD_NONE", "RHD_HPD_NONE /*0*/", "RHD_HPD_NONE /*1*/", "RHD_HPD_NONE /*2*/" };
    const char *hpd_name_swapped[] =
	{ "RHD_HPD_NONE", "RHD_HPD_1 /*swapped*/", "RHD_HPD_0 /*swapped*/", "RHD_HPD_2" };
a378 14
    const char **hpd_name;

    switch (rhdPtr->hpdUsage) {
    case RHD_HPD_USAGE_OFF:
	hpd_name = hpd_name_off;
	break;
    case RHD_HPD_USAGE_SWAP:
    case RHD_HPD_USAGE_AUTO_SWAP:
	hpd_name = hpd_name_swapped;
	break;
    default:
	hpd_name = hpd_name_normal;
	break;
    }
@

