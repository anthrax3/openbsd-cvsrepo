head	1.9;
access;
symbols
	OPENBSD_5_1_BASE:1.8
	OPENBSD_5_1:1.8.0.2
	OPENBSD_5_0:1.6.0.8
	OPENBSD_5_0_BASE:1.6
	OPENBSD_4_9:1.6.0.4
	OPENBSD_4_9_BASE:1.6
	OPENBSD_4_8:1.6.0.6
	OPENBSD_4_8_BASE:1.6
	OPENBSD_4_7:1.6.0.2
	OPENBSD_4_7_BASE:1.6
	OPENBSD_4_6:1.5.0.2
	OPENBSD_4_6_BASE:1.5
	OPENBSD_4_5:1.4.0.2
	OPENBSD_4_5_BASE:1.4
	OPENBSD_4_4:1.2.0.2
	OPENBSD_4_4_BASE:1.2
	OPENBSD_4_3_BASE:1.1.1.2
	OPENBSD_4_3:1.1.1.2.0.2
	v1_1_0:1.1.1.2
	v1_0:1.1.1.1
	xorg:1.1.1;
locks; strict;
comment	@ * @;


1.9
date	2012.03.04.16.09.07;	author matthieu;	state dead;
branches;
next	1.8;

1.8
date	2012.02.06.22.53.14;	author matthieu;	state Exp;
branches;
next	1.7;

1.7
date	2012.01.31.07.59.54;	author matthieu;	state dead;
branches;
next	1.6;

1.6
date	2009.11.24.16.57.34;	author matthieu;	state Exp;
branches;
next	1.5;

1.5
date	2009.04.26.13.59.41;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2009.01.28.14.43.56;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2008.11.01.18.14.37;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2008.04.19.13.41.46;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2007.12.04.22.20.30;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2007.12.04.22.20.30;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2008.01.05.17.28.38;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.9
log
@Remove xf86-video-radeonhd for good.
@
text
@/*
 * Copyright 2007, 2008  Luc Verhaegen <libv@@exsuse.de>
 * Copyright 2007, 2008  Matthias Hopf <mhopf@@novell.com>
 * Copyright 2007, 2008  Egbert Eich   <eich@@novell.com>
 * Copyright 2007, 2008  Advanced Micro Devices, Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE COPYRIGHT HOLDER(S) OR AUTHOR(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR
 * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 */

/*
 * MC idling:
 *
 * For SetupFBLocation and Restore, we require a fully idle MC as we might lock up
 * otherwise. Both calls now check whether the MC is Idle before attempting
 * to set up the MC, and complain loudly when this fails.
 *
 * Likely suspect registers for when the Idle fails:
 *   DxVGA_CONTROL & D1VGA_MODE_ENABLE (run RHDVGADisable beforehand)
 *   DxCRTC_CONTROL & 0x1 (run DxCRTCDisable beforehand)
 *   (... Add more here...)
 *
 *
 * MC addressing:
 *
 * On R600 and up the MC can use a larger than 32bit card internal address for
 * its framebuffer. This is why the Address used inside the MC code is a
 * CARD64.
 *
 * rhdPtr->FbIntAddress is kept as a CARD32 for the time being. This is still
 * valid, as this makes the R500 code simpler, and since we pick FbIntAddress
 * from a 32bit register anyway on R600. FbIntAddress will also correctly cast
 * to a CARD64 when passed to the likes of the SetupFBLocation callback.
 */

#ifdef HAVE_CONFIG_H
#include "config.h"
#endif

#if HAVE_XF86_ANSIC_H
# include "xf86_ansic.h"
#else
# include <unistd.h>
#endif

#include "xf86.h"

#include "rhd.h"
#include "rhd_mc.h"
#include "rhd_regs.h"
#include "rhd_crtc.h" /* for definition of Crtc->Id */

#include "r600_reg_auto_r6xx.h"
#include "r600_reg_r6xx.h"

struct rhdMC {
    int scrnIndex;

    CARD32 FbLocation;
    CARD32 HdpFbAddress;
    CARD32 MiscLatencyTimer;

    Bool Stored;

    void (*Save)(struct rhdMC *MC);
    void (*Restore)(struct rhdMC *MC);
    Bool (*Idle)(struct rhdMC *MC);
    CARD64 (*GetFBLocation)(struct rhdMC *MC, CARD32 *size);
    void (*SetupFBLocation)(struct rhdMC *MC, CARD64 Address, CARD32 Size);
    void (*TuneAccessForDisplay)(struct rhdMC *MC, int crtc,
			   DisplayModePtr Mode, DisplayModePtr ScaledToMode);
};

/*
 * Some common FB location calculations.
 */
/*
 * Applicable for all R5xx and RS600, RS690, RS740
 */
static CARD64
R5xxMCGetFBLocation(CARD32 Value, CARD32 *Size)
{
    *Size = (Value & 0xFFFF0000) - ((Value & 0xFFFF) << 16);
    return  (Value & 0xFFFF) << 16;
}

#define R5XX_FB_LOCATION(address, size) \
    ((((address) + (size)) & 0xFFFF0000) | (((address) >> 16) & 0xFFFF))
#define R5XX_HDP_LOCATION(address) \
    (((address) >> 16) & 0xFFFF)

/*
 * Applicable for all R6xx and R7xx, and RS780/RS790
 */
static CARD64
R6xxMCGetFBLocation(CARD32 Value, CARD32 *Size)
{
    *Size = (((Value & 0xFFFF0000) - ((Value & 0xFFFF) << 16))) << 8;
    return (Value & 0xFFFF) << 24;
}

#define R6XX_FB_LOCATION(address, size) \
    (((((address) + (size)) >> 8) & 0xFFFF0000) | (((address) >> 24) & 0xFFFF))
#define R6XX_HDP_LOCATION(address) \
    ((((address) >> 8) & 0x00FF0000))

/*
 *
 */
static void
RV515MCSave(struct rhdMC *MC)
{
    MC->FbLocation = RHDReadMC(MC, MC_IND_ALL | RV515_MC_FB_LOCATION);
    MC->MiscLatencyTimer = RHDReadMC(MC, MC_IND_ALL | RV515_MC_MISC_LAT_TIMER);
    MC->HdpFbAddress = RHDRegRead(MC, HDP_FB_LOCATION);
}

/*
 *
 */
static void
RV515MCRestore(struct rhdMC *MC)
{
    RHDWriteMC(MC, MC_IND_ALL | RV515_MC_FB_LOCATION, MC->FbLocation);
    RHDWriteMC(MC, MC_IND_ALL | RV515_MC_MISC_LAT_TIMER, MC->MiscLatencyTimer);
    RHDRegWrite(MC, HDP_FB_LOCATION, MC->HdpFbAddress);
}

/*
 *
 */
static Bool
RV515MCWaitIdle(struct rhdMC *MC)
{
    if (RHDReadMC(MC, MC_IND_ALL | RV515_MC_STATUS) & RV515_MC_IDLE)
	return TRUE;
    return FALSE;
}

/*
 *
 */
static CARD64
RV515MCGetFBLocation(struct rhdMC *MC, CARD32 *Size)
{
    return R5xxMCGetFBLocation(RHDReadMC(MC, RV515_MC_FB_LOCATION | MC_IND_ALL), Size);
}

/*
 *
 */
static void
RV515MCSetupFBLocation(struct rhdMC *MC, CARD64 Address, CARD32 Size)
{
    RHDWriteMC(MC, RV515_MC_FB_LOCATION | MC_IND_ALL,
	       R5XX_FB_LOCATION(Address, Size));
    RHDRegWrite(MC, HDP_FB_LOCATION, R5XX_HDP_LOCATION(Address));
}

/*
 *
 */
static void
RV515MCTuneMCAccessForDisplay(struct rhdMC *MC, int Crtc,
		    DisplayModePtr Mode, DisplayModePtr ScaledToMode)
{
    CARD32 value, setting = 0x1;

    value = RHDReadMC(MC, RV515_MC_MISC_LAT_TIMER);

    if (Crtc == RHD_CRTC_1) {
	value &= ~(0x0F << MC_DISP0R_INIT_LAT_SHIFT);
	value |= setting << MC_DISP0R_INIT_LAT_SHIFT;
    } else { /* RHD_CRTC_2 */
	value &= ~(0x0F << MC_DISP1R_INIT_LAT_SHIFT);
	value |= setting << MC_DISP1R_INIT_LAT_SHIFT;
    }

    RHDWriteMC(MC, RV515_MC_MISC_LAT_TIMER, value);
}

/*
 *
 */
static void
R500MCSave(struct rhdMC *MC)
{
    MC->FbLocation = RHDReadMC(MC, MC_IND_ALL | R5XX_MC_FB_LOCATION);
    MC->HdpFbAddress = RHDRegRead(MC, HDP_FB_LOCATION);
}

/*
 *
 */
static void
R500MCRestore(struct rhdMC *MC)
{
    RHDWriteMC(MC, MC_IND_ALL | R5XX_MC_FB_LOCATION, MC->FbLocation);
    RHDRegWrite(MC, HDP_FB_LOCATION, MC->HdpFbAddress);
}

/*
 *
 */
static Bool
R500MCWaitIdle(struct rhdMC *MC)
{
    if (RHDReadMC(MC, MC_IND_ALL | R5XX_MC_STATUS) & R5XX_MC_IDLE)
	return TRUE;
    return FALSE;
}

/*
 *
 */
static CARD64
R500MCGetFBLocation(struct rhdMC *MC, CARD32 *Size)
{
    return R5xxMCGetFBLocation(RHDReadMC(MC, R5XX_MC_FB_LOCATION | MC_IND_ALL), Size);
}

/*
 *
 */
static void
R500MCSetupFBLocation(struct rhdMC *MC, CARD64 Address, CARD32 Size)
{
    RHDWriteMC(MC, R5XX_MC_FB_LOCATION | MC_IND_ALL,
	       R5XX_FB_LOCATION(Address, Size));
    RHDRegWrite(MC, HDP_FB_LOCATION, R5XX_HDP_LOCATION(Address));
}

/*
 *
 */
static void
RS600MCSave(struct rhdMC *MC)
{
    MC->FbLocation = RHDReadMC(MC, RS60_NB_FB_LOCATION);
    MC->HdpFbAddress = RHDRegRead(MC, HDP_FB_LOCATION);
}

/*
 *
 */
static void
RS600MCRestore(struct rhdMC *MC)
{
    RHDWriteMC(MC, RS60_NB_FB_LOCATION, MC->FbLocation);
    RHDRegWrite(MC, HDP_FB_LOCATION, MC->HdpFbAddress);
}

/*
 *
 */
static Bool
RS600MCWaitIdle(struct rhdMC *MC)
{
    if (RHDReadMC(MC, RS60_MC_SYSTEM_STATUS) & RS6X_MC_SEQUENCER_IDLE)
	return TRUE;
    return FALSE;
}

/*
 *
 */
static CARD64
RS600MCGetFBLocation(struct rhdMC *MC, CARD32 *Size)
{
    return R5xxMCGetFBLocation(RHDReadMC(MC, RS60_NB_FB_LOCATION), Size);
}

/*
 *
 */
static void
RS600MCSetupFBLocation(struct rhdMC *MC, CARD64 Address, CARD32 Size)
{
    RHDWriteMC(MC, RS60_NB_FB_LOCATION, R5XX_FB_LOCATION(Address, Size));
    RHDRegWrite(MC, HDP_FB_LOCATION, R5XX_HDP_LOCATION(Address));
}

/*
 *
 */
static void
RS690MCSave(struct rhdMC *MC)
{
    MC->FbLocation = RHDReadMC(MC, RS69_MCCFG_FB_LOCATION);
    MC->HdpFbAddress = RHDRegRead(MC, HDP_FB_LOCATION);
    MC->MiscLatencyTimer = RHDReadMC(MC, RS69_MC_INIT_MISC_LAT_TIMER);
}

/*
 *
 */
static void
RS690MCRestore(struct rhdMC *MC)
{
    RHDWriteMC(MC, RS69_MCCFG_FB_LOCATION, MC->FbLocation);
    RHDRegWrite(MC, HDP_FB_LOCATION, MC->HdpFbAddress);
    RHDWriteMC(MC, RS69_MC_INIT_MISC_LAT_TIMER, MC->MiscLatencyTimer);
}

/*
 *
 */
static Bool
RS690MCWaitIdle(struct rhdMC *MC)
{
    if (RHDReadMC(MC, RS69_MC_SYSTEM_STATUS) & RS6X_MC_SYSTEM_IDLE)
	return TRUE;
    return FALSE;
}

/*
 *
 */
static CARD64
RS690MCGetFBLocation(struct rhdMC *MC, CARD32 *Size)
{
    return R5xxMCGetFBLocation(RHDReadMC(MC, RS69_MCCFG_FB_LOCATION), Size);
}

/*
 *
 */
static void
RS690MCSetupFBLocation(struct rhdMC *MC, CARD64 Address, CARD32 Size)
{
    RHDWriteMC(MC, RS69_MCCFG_FB_LOCATION, R5XX_FB_LOCATION(Address, Size));
    RHDRegWrite(MC, HDP_FB_LOCATION, R5XX_HDP_LOCATION(Address));
}

/*
 *
 */
static void
RS690MCTuneMCAccessForDisplay(struct rhdMC *MC, int Crtc,
		      DisplayModePtr Mode, DisplayModePtr ScaledToMode)
{
    CARD32 value, setting = 0x1;

    value = RHDReadMC(MC, RS69_MC_INIT_MISC_LAT_TIMER);

    if (Crtc == RHD_CRTC_1) {
	value &= ~(0x0F << MC_DISP0R_INIT_LAT_SHIFT);
	value |= setting << MC_DISP0R_INIT_LAT_SHIFT;
    } else { /* RHD_CRTC_2 */
	value &= ~(0x0F << MC_DISP1R_INIT_LAT_SHIFT);
	value |= setting << MC_DISP1R_INIT_LAT_SHIFT;
    }

    RHDWriteMC(MC, RS69_MC_INIT_MISC_LAT_TIMER, value);
}

/*
 *
 */
static void
R600MCSave(struct rhdMC *MC)
{
    MC->FbLocation = RHDRegRead(MC, R6XX_MC_VM_FB_LOCATION);
    MC->HdpFbAddress = RHDRegRead(MC, R6XX_HDP_NONSURFACE_BASE);
}

/*
 *
 */
static void
R600MCRestore(struct rhdMC *MC)
{
    RHDRegWrite(MC, R6XX_MC_VM_FB_LOCATION, MC->FbLocation);
    RHDRegWrite(MC, R6XX_HDP_NONSURFACE_BASE, MC->HdpFbAddress);
}

/*
 *
 */
static Bool
R600MCWaitIdle(struct rhdMC *MC)
{
    if (!(RHDRegRead(MC, SRBM_STATUS) &
            (VMC_BUSY_bit | MCB_BUSY_bit |
             MCDZ_BUSY_bit | MCDY_BUSY_bit | MCDX_BUSY_bit | MCDW_BUSY_bit)))
	return TRUE;
    return FALSE;
}

/*
 *
 */
static CARD64
R600MCGetFBLocation(struct rhdMC *MC, CARD32 *Size)
{
    return R6xxMCGetFBLocation(RHDRegRead(MC, R6XX_MC_VM_FB_LOCATION), Size);
}

/*
 *
 */
static void
R600MCSetupFBLocation(struct rhdMC *MC, CARD64 Address, CARD32 Size)
{
    RHDRegWrite(MC, R6XX_MC_VM_FB_LOCATION, R6XX_FB_LOCATION(Address, Size));
    RHDRegWrite(MC, R6XX_HDP_NONSURFACE_BASE, R6XX_HDP_LOCATION(Address));
}

/*
 *
 */
#ifdef NOTYET

/*
 *
 */
static void
RS780MCSave(struct rhdMC *MC)
{
    MC->FbLocation = RHDReadMC(MC, RS78_MC_FB_LOCATION);
    MC->HdpFbAddress = RHDRegRead(MC, R6XX_HDP_NONSURFACE_BASE);
}

/*
 *
 */
static void
RS780MCRestore(struct rhdMC *MC)
{
    RHDWriteMC(MC, RS78_MC_FB_LOCATION, MC->FbLocation);
    RHDRegWrite(MC, R6XX_HDP_NONSURFACE_BASE, MC->HdpFbAddress);
}

/*
 *
 */
static Bool
RS780MCWaitIdle(struct rhdMC *MC)
{
    if (RHDReadMC(MC, RS78_MC_SYSTEM_STATUS) & RS78_MC_SEQUENCER_IDLE)
	return TRUE;
    return FALSE;
}

/*
 *
 */
static CARD64
RS780MCGetFBLocation(struct rhdMC *MC, CARD32 *Size)
{
    /* is this correct? */
    return R5xxMCGetFBLocation(RHDReadMC(MC, RS78_MC_FB_LOCATION), Size);
}

/*
 *
 */
static void
RS780MCSetupFBLocation(struct rhdMC *MC, CARD64 Address, CARD32 Size)
{
    /* is this correct? */
    RHDWriteMC(MC, RS78_MC_FB_LOCATION, R5XX_FB_LOCATION(Address, Size));
    RHDRegWrite(MC, R6XX_HDP_NONSURFACE_BASE, R6XX_HDP_LOCATION(Address));
}
#endif /* NOTYET */

/*
 *
 */
static void
R700MCSave(struct rhdMC *MC)
{
    MC->FbLocation = RHDRegRead(MC, R7XX_MC_VM_FB_LOCATION);
    MC->HdpFbAddress = RHDRegRead(MC, R6XX_HDP_NONSURFACE_BASE);
}

/*
 *
 */
static void
R700MCRestore(struct rhdMC *MC)
{
    RHDFUNC(MC);

    RHDRegWrite(MC, R7XX_MC_VM_FB_LOCATION, MC->FbLocation);
    RHDRegWrite(MC, R6XX_HDP_NONSURFACE_BASE, MC->HdpFbAddress);
}

/*
 * Idle is the R600 one...
 */

/*
 *
 */
static CARD64
R700MCGetFBLocation(struct rhdMC *MC, CARD32 *Size)
{
    return R6xxMCGetFBLocation(RHDRegRead(MC, R7XX_MC_VM_FB_LOCATION), Size);
}

/*
 *
 */
static void
R700MCSetupFBLocation(struct rhdMC *MC, CARD64 Address, CARD32 Size)
{
    RHDRegWrite(MC, R7XX_MC_VM_FB_LOCATION, R6XX_FB_LOCATION(Address, Size));
    RHDRegWrite(MC, R6XX_HDP_NONSURFACE_BASE, R6XX_HDP_LOCATION(Address));
}


/*
 *
 */
void
RHDMCInit(RHDPtr rhdPtr)
{
    struct rhdMC *MC;

    RHDFUNC(rhdPtr);

    /* These devices have an internal address reference, which some other
     * address registers in there also use. This can be different from the
     * address in the BAR.
     *
     * We read out the address here from some known location. This address
     * is as good a guess as any, we just need to pick one, but then make
     * sure that it is made consistent in MCSetupFBLocation and the various MC
     * accessing subsystems.
     */

    RHDDebug(rhdPtr->scrnIndex, "MC FB Address: 0x%08X.\n",
	     rhdPtr->FbIntAddress);

    MC = xnfcalloc(1, sizeof(struct rhdMC));
    MC->scrnIndex = rhdPtr->scrnIndex;

    if (rhdPtr->ChipSet < RHD_RS600) {
	switch(rhdPtr->ChipSet) {
	case RHD_RV515:
	case RHD_RV505:
	case RHD_RV516:
	case RHD_RV550:
	case RHD_M52:
	case RHD_M54:
	case RHD_M62:
	case RHD_M64:
	case RHD_M71:
	    MC->Save = RV515MCSave;
	    MC->Restore = RV515MCRestore;
	    MC->SetupFBLocation = RV515MCSetupFBLocation;
	    MC->GetFBLocation = RV515MCGetFBLocation;
	    MC->Idle = RV515MCWaitIdle;
	    MC->TuneAccessForDisplay = RV515MCTuneMCAccessForDisplay;
	    break;
	default:
	    MC->Save = R500MCSave;
	    MC->Restore = R500MCRestore;
	    MC->SetupFBLocation = R500MCSetupFBLocation;
	    MC->GetFBLocation = R500MCGetFBLocation;
	    MC->Idle = R500MCWaitIdle;
	    break;
	}
    } else if (rhdPtr->ChipSet == RHD_RS600) {
	MC->Save = RS600MCSave;
	MC->Restore = RS600MCRestore;
	MC->SetupFBLocation = RS600MCSetupFBLocation;
	MC->Idle = RS600MCWaitIdle;
	MC->GetFBLocation = RS600MCGetFBLocation;
    } else if (rhdPtr->ChipSet < RHD_R600) {
	MC->Save = RS690MCSave;
	MC->Restore = RS690MCRestore;
	MC->SetupFBLocation = RS690MCSetupFBLocation;
	MC->Idle = RS690MCWaitIdle;
	MC->GetFBLocation = RS690MCGetFBLocation;
	MC->TuneAccessForDisplay = RS690MCTuneMCAccessForDisplay;
    } else if (rhdPtr->ChipSet <= RHD_RS880) {
	MC->Save = R600MCSave;
	MC->Restore = R600MCRestore;
	MC->SetupFBLocation = R600MCSetupFBLocation;
	MC->Idle = R600MCWaitIdle;
	MC->GetFBLocation = R600MCGetFBLocation;
    }
#ifdef NOTYET
    else if (rhdPtr->ChipSet == RHD_RS880) {
	MC->Save = RS780MCSave;
	MC->Restore = RS780MCRestore;
	MC->SetupFBLocation = RS780MCSetupFBLocation;
	MC->Idle = RS780MCWaitIdle;
	MC->GetFBLocation = RS780MCGetFBLocation;
    }
#endif /* NOTYET */
    else if (rhdPtr->ChipSet >= RHD_RV770) {
	MC->Save = R700MCSave;
	MC->Restore = R700MCRestore;
	MC->SetupFBLocation = R700MCSetupFBLocation;
	MC->Idle = R600MCWaitIdle;
	MC->GetFBLocation = R700MCGetFBLocation;
    } else {
	xf86DrvMsg(rhdPtr->scrnIndex, X_ERROR, "I don't know anything about MC on this chipset\n");
	xfree(MC);
	return;
    }
    if (rhdPtr->ChipSet < RHD_R600)
	rhdPtr->FbIntAddress = RHDRegRead(rhdPtr, HDP_FB_LOCATION) << 16;
    else
	rhdPtr->FbIntAddress = RHDRegRead(rhdPtr, R6XX_CONFIG_FB_BASE);
    MC->GetFBLocation(MC, &rhdPtr->FbIntSize);

    rhdPtr->MC = MC;

}

/*
 * Free structure.
 */
void
RHDMCDestroy(RHDPtr rhdPtr)
{
    RHDFUNC(rhdPtr);

    if (!rhdPtr->MC)
	return;

    xfree(rhdPtr->MC);
    rhdPtr->MC = NULL;
}

/*
 *
 */
void
RHDMCSave(RHDPtr rhdPtr)
{
    struct rhdMC *MC = rhdPtr->MC;

    ASSERT(MC);

    RHDFUNC(rhdPtr);

    MC->Save(MC);

    MC->Stored = TRUE;
}

/*
 * Make sure that nothing is accessing memory anymore before calling this.
 */
void
RHDMCRestore(RHDPtr rhdPtr)
{
    struct rhdMC *MC = rhdPtr->MC;

    ASSERT(MC);
    RHD_UNSETDEBUGFLAG(rhdPtr, MC_SETUP);

    RHDFUNC(rhdPtr);

    if (!MC->Stored) {
	xf86DrvMsg(rhdPtr->scrnIndex, X_ERROR,
		   "%s: trying to restore uninitialized values.\n",__func__);
	return;
    }

    if (MC->Idle(MC))
	MC->Restore(MC);
    else
	xf86DrvMsg(rhdPtr->scrnIndex, X_ERROR,
		   "%s: MC is still not idle!!!\n", __func__);
}

/*
 *
 */
Bool
RHDMCIdleWait(RHDPtr rhdPtr, CARD32 count)
{
    struct rhdMC *MC = rhdPtr->MC;

    RHDFUNC(rhdPtr);

    ASSERT(MC);

    do {
	if (MC->Idle(MC))
	    return TRUE;
	usleep(1000);
    } while (count--);

    RHDDebug(rhdPtr->scrnIndex, "%s: MC not idle\n",__func__);

    return FALSE;
}

/*
 * Get FB location and size.
 */
CARD64
RHDMCGetFBLocation(RHDPtr rhdPtr, CARD32 *size)
{
    struct rhdMC *MC = rhdPtr->MC;

    ASSERT(MC);
    ASSERT(size);

    RHDFUNC(rhdPtr);

    return MC->GetFBLocation(MC, size);
}

/*
 * Make sure that nothing is accessing memory anymore before calling this.
 */
Bool
RHDMCSetupFBLocation(RHDPtr rhdPtr, CARD64 Address, CARD32 Size)
{
    struct rhdMC *MC = rhdPtr->MC;
    CARD64 OldAddress;
    CARD32 OldSize;

    ASSERT(MC);
    RHD_SETDEBUGFLAG(rhdPtr, MC_SETUP);

    RHDFUNC(rhdPtr);

    if (!MC->Idle(MC)) {
	xf86DrvMsg(rhdPtr->scrnIndex, X_ERROR,
		   "%s: Cannot setup MC: not idle!!!\n", __func__);
	return FALSE;
    }

    OldAddress = MC->GetFBLocation(MC, &OldSize);
    if (OldAddress == Address && OldSize == Size)
	return TRUE;

    /* If this ever occurs, we might have issues */
    if (OldAddress >> 32)
	xf86DrvMsg(rhdPtr->scrnIndex, X_WARNING, "%s: Board claims to use a "
		   "higher than 32bit address for its FB\n", __func__);

    RHDDebug(rhdPtr->scrnIndex,
	     "Setting MC from 0x%08X to 0x%08X [Size 0x%08X]\n",
	     OldAddress, rhdPtr->FbIntAddress, Size);

    MC->SetupFBLocation(MC, Address, Size);

    return TRUE;
}

/*
 *
 */
void
RHDMCTuneAccessForDisplay(RHDPtr rhdPtr, int Crtc,
		    DisplayModePtr Mode, DisplayModePtr ScaledToMode)
{
    struct rhdMC *MC = rhdPtr->MC;

    ASSERT(MC);

    RHDFUNC(rhdPtr);

    if (MC->TuneAccessForDisplay)
	MC->TuneAccessForDisplay(MC, Crtc, Mode, ScaledToMode);
}

/*
 *
 */
Bool
RHD_MC_IGP_SideportMemoryPresent(RHDPtr rhdPtr)
{
    Bool Present = FALSE;

    RHDFUNC(rhdPtr);

    switch (rhdPtr->ChipSet) {
	case RHD_RS690:
	case RHD_RS740:
	    Present = (RHDReadMC(rhdPtr, RS69_MC_MISC_UMA_CNTL) & RS69_SIDE_PORT_PRESENT_R) != 0;
	    break;
	case RHD_RS780:
	    Present = (RHDReadMC(rhdPtr, RS78_MC_MISC_UMA_CNTL) & RS78_SIDE_PORT_PRESENT_R) != 0;
	    break;
	default:
	    break;
    }
    xf86DrvMsg(rhdPtr->scrnIndex, X_INFO, "IGP sideport memory %s present.\n", Present ? "" : "not");

    return Present;
}
@


1.8
log
@Revert the update to xf86-video-ati 6.14.3. Requested by espie@@
who experiemnts regressions with this driver.
@
text
@@


1.7
log
@Remove 2 obsolete drivers that have been unlinked from builds.
@
text
@@


1.6
log
@Update to xf86-video-radeonhd 1.3.0
Tested by killi@@ on a HD3200.
@
text
@@


1.5
log
@Update to xf86-video-radeonhd 1.2.5. Tested by eric@@

Version 1.2.5 improvements:

  - Added 2D acceleration for R6xx and R7xx.
  - Added XVideo support for R6xx and R7xx.
  - Added support for RS880 and RV790.
  - Added RandR 1.3 mandatory properties.
  - Refactoring of MC code.
  - Enable DRI support by default on R5xx and RS6xx.
  - LUT (color lookup table) fixes.
  - Tons of quirk table entries and bug fixes.
  - Fix register accesses for processors that reorder memory writes.
@
text
@d64 1
d68 3
d326 1
a326 1
    if (RHDReadMC(MC, RS69_MC_SYSTEM_STATUS) & RS6X_MC_SEQUENCER_IDLE)
d398 3
a400 1
    if (!(RHDRegRead(MC, SRBM_STATUS) & 0x3f00))
@


1.4
log
@Update to xf86-video-radeonhd 1.2.4.

  - Added HDMI support.
  - Added support for RV710, RV730 (DCE 3.2).
  - Added screen rotation support.
  - Added RandR 1.3 panning support. (not useful until xserver 1.6)
  - Many acceleration and build fixes.

Tested on mbalmer@@'s radeon 2400HD card.
@
text
@d2 4
a5 4
 * Copyright 2007  Luc Verhaegen <lverhaegen@@novell.com>
 * Copyright 2007  Matthias Hopf <mhopf@@novell.com>
 * Copyright 2007  Egbert Eich   <eich@@novell.com>
 * Copyright 2007  Advanced Micro Devices, Inc.
d26 25
d65 1
a65 1
#include "r5xx_accel.h"
d67 2
a68 3
Bool RHDMCIdle(RHDPtr rhdPtr, CARD32 count);

Bool RHDMCIdle(RHDPtr rhdPtr, CARD32 count);
a69 1
struct rhdMC {
d71 1
a71 1
    CARD32 HdpFbBase;
d73 1
d75 8
a82 8
    void (*SaveMC)(RHDPtr rhdPtr);
    void (*RestoreMC)(RHDPtr rhdPtr);
    void (*SetupMC)(RHDPtr rhdPtr);
    Bool (*MCIdle)(RHDPtr rhdPtr);
    CARD32 (*GetFBLocation)(RHDPtr rhdPtr, CARD32 *size);
    void (*TuneMCAccessForDisplay)(RHDPtr rhdPtr, int crtc,
				   DisplayModePtr Mode, DisplayModePtr ScaledToMode);
    Bool RV515Variant;
d86 4
a89 1
 * Save MC_VM state.
d91 2
a92 2
static void
rs600SaveMC(RHDPtr rhdPtr)
d94 3
a96 1
    struct rhdMC *MC = rhdPtr->MC;
d98 4
a101 1
    RHDFUNC(rhdPtr);
d103 8
a110 2
    MC->FbLocation = RHDReadMC(rhdPtr, RS60_NB_FB_LOCATION);
    MC->HdpFbBase = RHDRegRead(rhdPtr, HDP_FB_LOCATION);
d113 5
d122 1
a122 1
rs690SaveMC(RHDPtr rhdPtr)
d124 3
a126 7
    struct rhdMC *MC = rhdPtr->MC;

    RHDFUNC(rhdPtr);

    MC->FbLocation = RHDReadMC(rhdPtr, RS69_MCCFG_FB_LOCATION);
    MC->HdpFbBase = RHDRegRead(rhdPtr, HDP_FB_LOCATION);
    MC->MiscLatencyTimer = RHDReadMC(rhdPtr, RS69_MC_INIT_MISC_LAT_TIMER);
d133 1
a133 1
r6xxSaveMC(RHDPtr rhdPtr)
d135 4
a138 1
    struct rhdMC *MC = rhdPtr->MC;
d140 10
a149 1
    RHDFUNC(rhdPtr);
d151 7
a157 2
    MC->FbLocation = RHDRegRead(rhdPtr, R6XX_MC_VM_FB_LOCATION);
    MC->HdpFbBase = RHDRegRead(rhdPtr, R6XX_HDP_NONSURFACE_BASE);
a162 1
#ifdef NOTYET
d164 1
a164 1
rs780SaveMC(RHDPtr rhdPtr)
d166 3
a168 7
    struct rhdMC *MC = rhdPtr->MC;

    RHDFUNC(rhdPtr);

    MC->FbLocation = RHDReadMC(rhdPtr, RS78_MC_FB_LOCATION);
    /* RS780 uses the same register as R6xx */
    MC->HdpFbBase = RHDRegRead(rhdPtr, R6XX_HDP_NONSURFACE_BASE);
a169 1
#endif
d175 2
a176 1
r7xxSaveMC(RHDPtr rhdPtr)
d178 3
a180 1
    struct rhdMC *MC = rhdPtr->MC;
d182 7
a188 1
    RHDFUNC(rhdPtr);
d190 1
a190 2
    MC->FbLocation = RHDRegRead(rhdPtr, R7XX_MC_VM_FB_LOCATION);
    MC->HdpFbBase = RHDRegRead(rhdPtr, R6XX_HDP_NONSURFACE_BASE);
d197 1
a197 1
r5xxRestoreMC(RHDPtr rhdPtr)
d199 2
a200 13
    struct rhdMC *MC = rhdPtr->MC;

    RHDFUNC(rhdPtr);

    if (MC->RV515Variant) {
	RHDWriteMC(rhdPtr, MC_IND_ALL |  RV515_MC_FB_LOCATION,
		   MC->FbLocation);
	RHDWriteMC(rhdPtr, MC_IND_ALL |  RV515_MC_MISC_LAT_TIMER,
		   MC->MiscLatencyTimer);
    } else
	RHDWriteMC(rhdPtr, MC_IND_ALL | R5XX_MC_FB_LOCATION,
		   MC->FbLocation);
    RHDRegWrite(rhdPtr, HDP_FB_LOCATION, MC->HdpFbBase);
d207 1
a207 1
rs600RestoreMC(RHDPtr rhdPtr)
d209 3
a211 1
    struct rhdMC *MC = rhdPtr->MC;
d213 10
a222 1
    RHDFUNC(rhdPtr);
d224 7
a230 2
    RHDWriteMC(rhdPtr, RS60_NB_FB_LOCATION, MC->FbLocation);
    RHDRegWrite(rhdPtr, HDP_FB_LOCATION, MC->HdpFbBase);
d237 1
a237 1
rs690RestoreMC(RHDPtr rhdPtr)
d239 3
a241 7
    struct rhdMC *MC = rhdPtr->MC;

    RHDFUNC(rhdPtr);

    RHDWriteMC(rhdPtr,  RS69_MCCFG_FB_LOCATION, MC->FbLocation);
    RHDRegWrite(rhdPtr, HDP_FB_LOCATION, MC->HdpFbBase);
    RHDWriteMC(rhdPtr,  RS69_MC_INIT_MISC_LAT_TIMER, MC->MiscLatencyTimer);
d248 1
a248 1
r6xxRestoreMC(RHDPtr rhdPtr)
d250 2
a251 6
    struct rhdMC *MC = rhdPtr->MC;

    RHDFUNC(rhdPtr);

    RHDRegWrite(rhdPtr, R6XX_MC_VM_FB_LOCATION, MC->FbLocation);
    RHDRegWrite(rhdPtr, R6XX_HDP_NONSURFACE_BASE, MC->HdpFbBase);
a256 1
#ifdef NOTYET
d258 1
a258 1
rs780RestoreMC(RHDPtr rhdPtr)
d260 2
a261 7
    struct rhdMC *MC = rhdPtr->MC;

    RHDFUNC(rhdPtr);

    RHDWriteMC(rhdPtr, RS78_MC_FB_LOCATION, MC->FbLocation);
    /* RS780 uses the same register as R6xx */
    RHDRegWrite(rhdPtr, R6XX_HDP_NONSURFACE_BASE, MC->HdpFbBase);
a262 1
#endif
d267 2
a268 2
static void
r7xxRestoreMC(RHDPtr rhdPtr)
d270 3
a272 6
    struct rhdMC *MC = rhdPtr->MC;

    RHDFUNC(rhdPtr);

    RHDRegWrite(rhdPtr, R7XX_MC_VM_FB_LOCATION, MC->FbLocation);
    RHDRegWrite(rhdPtr, R6XX_HDP_NONSURFACE_BASE, MC->HdpFbBase);
d276 1
a276 1
 * Setup the MC
d278 5
d288 1
a288 1
r5xxSetupMC(RHDPtr rhdPtr)
d290 2
a291 24
    struct rhdMC *MC = rhdPtr->MC;
    CARD32 fb_location, fb_location_tmp;
    CARD16 fb_size;
    unsigned int reg;

    RHDFUNC(rhdPtr);


    if (MC->RV515Variant)
	reg = RV515_MC_FB_LOCATION | MC_IND_ALL;
    else
	reg = R5XX_MC_FB_LOCATION | MC_IND_ALL;

    fb_location = RHDReadMC(rhdPtr, reg);
    fb_size = (fb_location >> 16) - (fb_location & 0xFFFF);
    fb_location_tmp = rhdPtr->FbIntAddress >> 16;
    fb_location_tmp |= (fb_location_tmp + fb_size) << 16;

    RHDDebug(rhdPtr->scrnIndex, "%s: fb_location: 0x%08X "
	     "[fb_size: 0x%04X] -> fb_location: 0x%08X\n",
	     __func__, (unsigned int)fb_location,
	     fb_size,(unsigned int)fb_location_tmp);
    RHDWriteMC(rhdPtr, reg, fb_location_tmp);
    RHDRegWrite(rhdPtr, HDP_FB_LOCATION, fb_location_tmp & 0xFFFF);
d298 1
a298 1
rs600SetupMC(RHDPtr rhdPtr)
d300 3
a302 16
    CARD32 fb_location, fb_location_tmp;
    CARD16 fb_size;

    RHDFUNC(rhdPtr);

    fb_location = RHDReadMC(rhdPtr, RS60_NB_FB_LOCATION);
    fb_size = (fb_location >> 16) - (fb_location & 0xFFFF);
    fb_location_tmp = rhdPtr->FbIntAddress >> 16;
    fb_location_tmp |= (fb_location_tmp + fb_size) << 16;

    RHDDebug(rhdPtr->scrnIndex, "%s: fb_location: 0x%08X "
	     "[fb_size: 0x%04X] -> fb_location: 0x%08X\n",
	     __func__, (unsigned int)fb_location,
	     fb_size,(unsigned int)fb_location_tmp);
    RHDWriteMC(rhdPtr, RS60_NB_FB_LOCATION, fb_location_tmp);
    RHDRegWrite(rhdPtr, HDP_FB_LOCATION, fb_location_tmp & 0xFFFF); /* same ;) */
d309 1
a309 1
rs690SetupMC(RHDPtr rhdPtr)
d311 4
a314 2
    CARD32 fb_location, fb_location_tmp;
    CARD16 fb_size;
d316 9
a324 13
    RHDFUNC(rhdPtr);

    fb_location = RHDReadMC(rhdPtr, RS69_MCCFG_FB_LOCATION);
    fb_size = (fb_location >> 16) - (fb_location & 0xFFFF);
    fb_location_tmp = rhdPtr->FbIntAddress >> 16;
    fb_location_tmp |= (fb_location_tmp + fb_size) << 16;

    RHDDebug(rhdPtr->scrnIndex, "%s: fb_location: 0x%08X "
	     "[fb_size: 0x%04X] -> fb_location: 0x%08X\n",
	     __func__, (unsigned int)fb_location,
	     fb_size,(unsigned int)fb_location_tmp);
    RHDWriteMC(rhdPtr, RS69_MCCFG_FB_LOCATION, fb_location_tmp);
    RHDRegWrite(rhdPtr, HDP_FB_LOCATION, fb_location_tmp & 0xFFFF);
d330 2
a331 2
static void
r6xxSetupMC(RHDPtr rhdPtr)
d333 1
a333 20
    CARD32 fb_location, fb_location_tmp, hdp_fbbase_tmp;
    CARD16 fb_size;

    RHDFUNC(rhdPtr);

    fb_location = RHDRegRead(rhdPtr, R6XX_MC_VM_FB_LOCATION);
    fb_size = (fb_location >> 16) - (fb_location & 0xFFFF);
    fb_location_tmp = rhdPtr->FbIntAddress >> 24;
    fb_location_tmp |= (fb_location_tmp + fb_size) << 16;
    hdp_fbbase_tmp = (rhdPtr->FbIntAddress >> 8) & 0xff0000;

    RHDDebug(rhdPtr->scrnIndex, "%s: fb_location: 0x%08X "
	     "fb_offset: 0x%08X [fb_size: 0x%04X] -> fb_location: 0x%08X "
	     "fb_offset: 0x%08X\n",
	     __func__, (unsigned int)fb_location,
	     RHDRegRead(rhdPtr,R6XX_HDP_NONSURFACE_BASE), fb_size,
	     (unsigned int)fb_location_tmp, (unsigned int)hdp_fbbase_tmp);

    RHDRegWrite(rhdPtr, R6XX_MC_VM_FB_LOCATION, fb_location_tmp);
    RHDRegWrite(rhdPtr, R6XX_HDP_NONSURFACE_BASE, hdp_fbbase_tmp);
a338 1
#ifdef NOTYET
d340 1
a340 1
rs780SetupMC(RHDPtr rhdPtr)
d342 2
a343 18
    CARD32 fb_location, fb_location_tmp, hdp_fbbase_tmp;
    CARD16 fb_size;

    RHDFUNC(rhdPtr);

    fb_location = RHDReadMC(rhdPtr, RS78_MC_FB_LOCATION);
    fb_size = (fb_location >> 16) - (fb_location & 0xFFFF);
    fb_location_tmp = rhdPtr->FbIntAddress >> 16;
    fb_location_tmp |= (fb_location_tmp + fb_size) << 16;
    hdp_fbbase_tmp = (rhdPtr->FbIntAddress >> 8) & 0xff0000;

    RHDDebug(rhdPtr->scrnIndex, "%s: fb_location: 0x%08X "
	     "[fb_size: 0x%04X] -> fb_location: 0x%08X\n",
	     __func__, (unsigned int)fb_location,
	     fb_size,(unsigned int)fb_location_tmp);
    RHDWriteMC(rhdPtr, RS78_MC_FB_LOCATION, fb_location_tmp);
    /* RS780 uses the same register as R6xx */
    RHDRegWrite(rhdPtr, R6XX_HDP_NONSURFACE_BASE, hdp_fbbase_tmp);
a344 1
#endif
d350 2
a351 1
r7xxSetupMC(RHDPtr rhdPtr)
d353 1
a353 2
    CARD32 fb_location, fb_location_tmp, hdp_fbbase_tmp;
    CARD16 fb_size;
d355 1
a355 1
    RHDFUNC(rhdPtr);
d357 7
a363 12
    fb_location = RHDRegRead(rhdPtr, R7XX_MC_VM_FB_LOCATION);
    fb_size = (fb_location >> 16) - (fb_location & 0xFFFF);
    fb_location_tmp = rhdPtr->FbIntAddress >> 24;
    fb_location_tmp |= (fb_location_tmp + fb_size) << 16;
    hdp_fbbase_tmp = (rhdPtr->FbIntAddress >> 8) & 0xff0000;

    RHDDebug(rhdPtr->scrnIndex, "%s: fb_location: 0x%08X "
	     "fb_offset: 0x%08X [fb_size: 0x%04X] -> fb_location: 0x%08X "
	     "fb_offset: 0x%08X\n",
	     __func__, (unsigned int)fb_location,
	     RHDRegRead(rhdPtr,R6XX_HDP_NONSURFACE_BASE), fb_size,
	     (unsigned int)fb_location_tmp, (unsigned int)hdp_fbbase_tmp);
d365 1
a365 2
    RHDRegWrite(rhdPtr, R7XX_MC_VM_FB_LOCATION, fb_location_tmp);
    RHDRegWrite(rhdPtr, R6XX_HDP_NONSURFACE_BASE, hdp_fbbase_tmp);
d371 2
a372 2
void
RHDMCSetup(RHDPtr rhdPtr)
d374 2
a375 16
    struct rhdMC *MC = rhdPtr->MC;
    RHDFUNC(rhdPtr);

    if (!MC)
	return;
    /*
     * make sure the hw is in a state such that we can update
     * the MC - ie no subsystem is currently accessing memory.
     */
    ASSERT((RHDRegRead(rhdPtr, D1VGA_CONTROL) & D1VGA_MODE_ENABLE) != D1VGA_MODE_ENABLE);
    ASSERT((RHDRegRead(rhdPtr, D2VGA_CONTROL) & D2VGA_MODE_ENABLE) != D2VGA_MODE_ENABLE);
    ASSERT((RHDRegRead(rhdPtr, D1CRTC_CONTROL) & 0x1) != 0x1);
    ASSERT((RHDRegRead(rhdPtr, D2CRTC_CONTROL) & 0x1) != 0x1);
    ASSERT(RHDMCIdle(rhdPtr, 1));

    MC->SetupMC(rhdPtr);
d379 1
a379 1
 * Get FB location and size.
d381 2
a382 2
static CARD32
r5xxGetFBLocation(RHDPtr rhdPtr, CARD32 *size)
d384 2
a385 14
    struct rhdMC *MC = rhdPtr->MC;
    CARD32 val;
    CARD32 reg;

    if (MC->RV515Variant)
	reg = RV515_MC_FB_LOCATION | MC_IND_ALL;
    else
	reg = R5XX_MC_FB_LOCATION | MC_IND_ALL;

	val = RHDReadMC(rhdPtr, reg);

    if (size) *size = ((val >> 16) - (val & 0xFFFF)) << 16;

    return (val & 0xFFFF) << 16;
d391 2
a392 2
static CARD32
rs600GetFBLocation(RHDPtr rhdPtr, CARD32 *size)
d394 3
a396 5
    CARD32 val = RHDReadMC(rhdPtr, RS60_NB_FB_LOCATION);

    if (size) *size = ((val >> 16) - (val & 0xFFFF)) << 16;

    return (val & 0xFFFF) << 16;
d402 2
a403 2
static CARD32
rs690GetFBLocation(RHDPtr rhdPtr, CARD32 *size)
d405 1
a405 5
    CARD32 val = RHDReadMC(rhdPtr, RS69_MCCFG_FB_LOCATION);

    if (size) *size = ((val >> 16) - (val & 0xFFFF)) << 16;

    return (val & 0xFFFF) << 16;
d411 2
a412 2
static CARD32
r6xxGetFBLocation(RHDPtr rhdPtr, CARD32 *size)
d414 2
a415 5
    CARD32 val = RHDRegRead(rhdPtr, R6XX_MC_VM_FB_LOCATION);

    if (size) *size = ((val >> 16) - (val & 0xFFFF)) << 24;

    return (val & 0xFFFF) << 24;
a421 9
static CARD32
rs780GetFBLocation(RHDPtr rhdPtr, CARD32 *size)
{
    CARD32 val = RHDReadMC(rhdPtr, RS78_MC_FB_LOCATION);
    if (size) *size = ((val >> 16) - (val & 0xFFFF)) << 16;

    return (val & 0xFFFF) << 16;
}
#endif
d426 2
a427 2
static CARD32
r7xxGetFBLocation(RHDPtr rhdPtr, CARD32 *size)
d429 2
a430 5
    CARD32 val = RHDRegRead(rhdPtr, R7XX_MC_VM_FB_LOCATION);

    if (size) *size = ((val >> 16) - (val & 0xFFFF)) << 24;

    return (val & 0xFFFF) << 24;
d436 2
a437 2
CARD32
RHDGetFBLocation(RHDPtr rhdPtr, CARD32 *size)
d439 2
a440 9
    struct rhdMC *MC = rhdPtr->MC;
    RHDFUNC(rhdPtr);

    if (!MC) {
	if (size) *size = 0;
	return 0;
    }

    return MC->GetFBLocation(rhdPtr, size);
d447 1
a447 1
rv515MCIdle(RHDPtr rhdPtr)
d449 1
a449 3
    RHDFUNC(rhdPtr);

    if (RHDReadMC(rhdPtr, MC_IND_ALL | RV515_MC_STATUS) & RV515_MC_IDLE)
a453 1

d457 2
a458 2
static Bool
r5xxMCIdle(RHDPtr rhdPtr)
d460 2
a461 5
    RHDFUNC(rhdPtr);

    if (RHDReadMC(rhdPtr, MC_IND_ALL | R5XX_MC_STATUS) & R5XX_MC_IDLE)
	return TRUE;
    return FALSE;
d467 2
a468 2
static Bool
rs600MCIdle(RHDPtr rhdPtr)
d470 3
a472 5
    RHDFUNC(rhdPtr);

    if (RHDReadMC(rhdPtr, RS60_MC_SYSTEM_STATUS) & RS6X_MC_SEQUENCER_IDLE)
	return TRUE;
    return FALSE;
d474 1
d479 2
a480 2
static Bool
rs690MCIdle(RHDPtr rhdPtr)
d482 2
a483 5
    RHDFUNC(rhdPtr);

    if (RHDReadMC(rhdPtr, RS69_MC_SYSTEM_STATUS) & RS6X_MC_SEQUENCER_IDLE)
	return TRUE;
    return FALSE;
d489 2
a490 2
static Bool
r6xxMCIdle(RHDPtr rhdPtr)
d492 1
a492 1
    RHDFUNC(rhdPtr);
d494 2
a495 3
    if (!(RHDRegRead(rhdPtr, SRBM_STATUS) & 0x3f00))
	return TRUE;
    return FALSE;
d499 4
d505 2
a506 3
#ifdef NOTYET
static Bool
rs780MCIdle(RHDPtr rhdPtr)
d508 1
a508 5
    RHDFUNC(rhdPtr);

    if (RHDReadMC(rhdPtr, RS78_MC_SYSTEM_STATUS) & RS78_MC_SEQUENCER_IDLE)
	return TRUE;
    return FALSE;
a509 1
#endif
d514 2
a515 2
Bool
RHDMCIdle(RHDPtr rhdPtr, CARD32 count)
d517 3
a519 2
    struct rhdMC *MC = rhdPtr->MC;
    RHDFUNC(rhdPtr);
a520 13
    if (!MC)
	return TRUE;

    do {
	if (MC->MCIdle(rhdPtr))
	    return TRUE;
	usleep(10);
    } while (count--);

    RHDDebug(rhdPtr->scrnIndex, "%s: MC not idle\n",__func__);

    return FALSE;
}
d526 1
a526 1
RHDSaveMC(RHDPtr rhdPtr)
d528 2
a529 1
    struct rhdMC *MC = rhdPtr->MC;
d532 80
a611 1
    if (!MC)
d613 6
d620 1
a620 1
    MC->SaveMC(rhdPtr);
a621 1
    MC->Stored = TRUE;
d625 1
a625 1
 * Restore MC VM state.
d628 1
a628 1
RHDRestoreMC(RHDPtr rhdPtr)
a629 1
    struct rhdMC *MC = rhdPtr->MC;
d632 1
a632 1
    if (!MC)
d635 2
a636 16
    if (!MC->Stored) {
	xf86DrvMsg(rhdPtr->scrnIndex, X_ERROR,
		   "%s: trying to restore uninitialized values.\n",__func__);
	return;
    }
    /*
     * make sure the hw is in a state such that we can update
     * the MC - ie no subsystem is currently accessing memory.
     */
    ASSERT((RHDRegRead(rhdPtr, D1VGA_CONTROL) & D1VGA_MODE_ENABLE) != D1VGA_MODE_ENABLE);
    ASSERT((RHDRegRead(rhdPtr, D2VGA_CONTROL) & D2VGA_MODE_ENABLE) != D2VGA_MODE_ENABLE);
    ASSERT((RHDRegRead(rhdPtr, D1CRTC_CONTROL) & 0x1) != 0x1);
    ASSERT((RHDRegRead(rhdPtr, D2CRTC_CONTROL) & 0x1) != 0x1);
    ASSERT(RHDMCIdle(rhdPtr, 1));

    MC->RestoreMC(rhdPtr);
d642 2
a643 2
static void
r5xxSaveMC(RHDPtr rhdPtr)
d647 2
d651 3
a653 6
    if (MC->RV515Variant) {
	MC->FbLocation = RHDReadMC(rhdPtr, MC_IND_ALL | RV515_MC_FB_LOCATION);
	MC->MiscLatencyTimer = RHDReadMC(rhdPtr, MC_IND_ALL | RV515_MC_MISC_LAT_TIMER);
    } else
	MC->FbLocation = RHDReadMC(rhdPtr, MC_IND_ALL | R5XX_MC_FB_LOCATION);
    MC->HdpFbBase = RHDRegRead(rhdPtr, HDP_FB_LOCATION);
d657 1
a657 1
 *
d659 2
a660 3
static void
rv515TuneMCAccessForDisplay(RHDPtr rhdPtr, int crtc,
				   DisplayModePtr Mode, DisplayModePtr ScaledToMode)
d662 4
a665 1
    CARD32 value, setting = 0x1;
d669 5
a673 1
    value = RHDReadMC(rhdPtr,  RV515_MC_MISC_LAT_TIMER);
d675 5
a679 2
    value |= (setting << (crtc ? MC_DISP1R_INIT_LAT_SHIFT : MC_DISP0R_INIT_LAT_SHIFT));
    RHDWriteMC(rhdPtr,  RV515_MC_MISC_LAT_TIMER, value);
d685 2
a686 3
static void
rs690TuneMCAccessForDisplay(RHDPtr rhdPtr, int crtc,
				   DisplayModePtr Mode, DisplayModePtr ScaledToMode)
d688 1
a688 1
    CARD32 value, setting = 0x1;
d692 11
a702 3
    value = RHDReadMC(rhdPtr,  RS69_MC_INIT_MISC_LAT_TIMER);
    value |= setting << (crtc ? MC_DISP1R_INIT_LAT_SHIFT : MC_DISP0R_INIT_LAT_SHIFT);
    RHDWriteMC(rhdPtr,  RS69_MC_INIT_MISC_LAT_TIMER, value);
d706 1
a706 1
 *
d708 2
a709 3
void
RHDTuneMCAccessForDisplay(RHDPtr rhdPtr, int crtc,
				   DisplayModePtr Mode, DisplayModePtr ScaledToMode)
d713 3
d718 1
a718 2
    if (MC->TuneMCAccessForDisplay)
	MC->TuneMCAccessForDisplay(rhdPtr, crtc, Mode, ScaledToMode);
d722 1
a722 1
 *
d724 2
a725 2
void
RHDMCInit(RHDPtr rhdPtr)
d727 6
a732 1
    struct rhdMC *MC;
d736 5
a740 13
    /* These devices have an internal address reference, which some other
     * address registers in there also use. This can be different from the
     * address in the BAR.
     *
     * We read out the address here from some known location. This address
     * is as good a guess as any, we just need to pick one, but then make
     * sure that it is made consistent in MCSetup and the various MC
     * accessing subsystems.
     */
    if (rhdPtr->ChipSet < RHD_R600)
	rhdPtr->FbIntAddress = RHDRegRead(rhdPtr, HDP_FB_LOCATION) << 16;
    else
	rhdPtr->FbIntAddress = RHDRegRead(rhdPtr, R6XX_CONFIG_FB_BASE);
d742 3
a744 2
    RHDDebug(rhdPtr->scrnIndex, "MC FB Address: 0x%08X.\n",
	     rhdPtr->FbIntAddress);
d746 8
a753 2
    MC = xnfcalloc(1, sizeof(struct rhdMC));
    MC->Stored = FALSE;
d755 1
a755 67
    if (rhdPtr->ChipSet < RHD_RS600) {
	MC->SaveMC = r5xxSaveMC;
	MC->RestoreMC = r5xxRestoreMC;
	MC->SetupMC = r5xxSetupMC;
	MC->GetFBLocation = r5xxGetFBLocation;

	if (rhdPtr->ChipSet == RHD_RV515
	    || rhdPtr->ChipSet == RHD_RV505
	    || rhdPtr->ChipSet == RHD_RV516
	    || rhdPtr->ChipSet == RHD_RV550
	    || rhdPtr->ChipSet == RHD_M52
	    || rhdPtr->ChipSet == RHD_M54
	    || rhdPtr->ChipSet == RHD_M62
	    || rhdPtr->ChipSet == RHD_M64
	    || rhdPtr->ChipSet == RHD_M71) {

	    MC->RV515Variant = TRUE;
	    MC->MCIdle = rv515MCIdle;
	    MC->TuneMCAccessForDisplay = rv515TuneMCAccessForDisplay;
	} else {

	    MC->RV515Variant = FALSE;
	    MC->MCIdle = r5xxMCIdle;

	}

    } else if (rhdPtr->ChipSet == RHD_RS600) {
	MC->SaveMC = rs600SaveMC;
	MC->RestoreMC = rs600RestoreMC;
	MC->SetupMC = rs600SetupMC;
	MC->MCIdle = rs600MCIdle;
	MC->GetFBLocation = rs600GetFBLocation;
    } else if (rhdPtr->ChipSet < RHD_R600) {
	MC->SaveMC = rs690SaveMC;
	MC->RestoreMC = rs690RestoreMC;
	MC->SetupMC = rs690SetupMC;
	MC->MCIdle = rs690MCIdle;
	MC->GetFBLocation = rs690GetFBLocation;
	MC->TuneMCAccessForDisplay = rs690TuneMCAccessForDisplay;
    } else if (rhdPtr->ChipSet <= RHD_RS780) {
	MC->SaveMC = r6xxSaveMC;
	MC->RestoreMC = r6xxRestoreMC;
	MC->SetupMC = r6xxSetupMC;
	MC->MCIdle = r6xxMCIdle;
	MC->GetFBLocation = r6xxGetFBLocation;
    }
#if 0
    else if (rhdPtr->ChipSet == RHD_RS780) {
	MC->SaveMC = rs780SaveMC;
	MC->RestoreMC = rs780RestoreMC;
	MC->SetupMC = rs780SetupMC;
	MC->MCIdle = rs780MCIdle;
	MC->GetFBLocation = rs780GetFBLocation;
    }
#endif
    else if (rhdPtr->ChipSet >= RHD_RV770) {
	MC->SaveMC = r7xxSaveMC;
	MC->RestoreMC = r7xxRestoreMC;
	MC->SetupMC = r7xxSetupMC;
	MC->MCIdle = r6xxMCIdle;
	MC->GetFBLocation = r7xxGetFBLocation;
    } else {
	xf86DrvMsg(rhdPtr->scrnIndex, X_ERROR, "I don't know anything about MC on this chipset\n");
	xfree(MC);
	return;
    }
    rhdPtr->MC = MC;
d757 1
d761 1
a761 1
 * Free structure.
d764 2
a765 1
RHDMCDestroy(RHDPtr rhdPtr)
d767 4
d773 2
a774 5
    if (!rhdPtr->MC)
	return;

    xfree(rhdPtr->MC);
    rhdPtr->MC = NULL;
d798 1
a798 1
    xf86DrvMsg(rhdPtr->scrnIndex, X_INFO, "IPG sideport memory %s present.\n", Present ? "" : "not");
@


1.3
log
@xf86-video-radeonhd 1.2.3
@
text
@d829 1
a829 1
    else if (rhdPtr->ChipSet == RHD_RV770) {
@


1.2
log
@Update to xf86-video-radeonhd 1.2.0. Tested by jdixon@@ and jasper@@
@
text
@d40 5
d48 2
a49 1
    CARD32 MiscOffset;
d51 8
d61 13
d78 270
a347 2
void
RHDMCInit(RHDPtr rhdPtr)
d349 2
a350 1
    struct rhdMC *MC;
d354 26
a379 3
    /* we know nothing about RS600, yet */
    if (rhdPtr->ChipSet == RHD_RS600)
	return;
d381 12
a392 2
    MC = xnfcalloc(1, sizeof(struct rhdMC));
    MC->Stored = FALSE;
d394 2
a395 1
    rhdPtr->MC = MC;
d399 1
a399 1
 * Free structure.
d402 1
a402 1
RHDMCDestroy(RHDPtr rhdPtr)
d404 1
d407 1
a407 1
    if (!rhdPtr->MC)
d409 60
d470 159
a628 2
    xfree(rhdPtr->MC);
    rhdPtr->MC = NULL;
d632 1
a632 1
 * Save MC_VM state.
a637 1

d643 2
a644 11
    if (rhdPtr->ChipSet < RHD_RS690) {
	if (RHDFamily(rhdPtr->ChipSet) == RHD_FAMILY_RV515)
	    MC->FbLocation = RHDReadMC(rhdPtr, MC_IND_ALL | RV515_MC_FB_LOCATION);
	else
	    MC->FbLocation = RHDReadMC(rhdPtr, MC_IND_ALL | R5XX_MC_FB_LOCATION);
    } else if (RHDFamily(rhdPtr->ChipSet) == RHD_FAMILY_RS690) {
	MC->FbLocation = RHDReadMC(rhdPtr, RS69_MCCFG_FB_LOCATION);
    } else {
	MC->FbLocation = RHDRegRead(rhdPtr, R6XX_MC_VM_FB_LOCATION);
	MC->MiscOffset = RHDRegRead(rhdPtr, R6XX_HDP_NONSURFACE_BASE);
    }
a654 1

d665 62
a726 13
    if (rhdPtr->ChipSet < RHD_RS690) {
	if (RHDFamily(rhdPtr->ChipSet) == RHD_FAMILY_RV515)
	    RHDWriteMC(rhdPtr, MC_IND_ALL |  RV515_MC_FB_LOCATION,
		       MC->FbLocation);
	else
	    RHDWriteMC(rhdPtr, MC_IND_ALL | R5XX_MC_FB_LOCATION,
		       MC->FbLocation);
    } else if (RHDFamily(rhdPtr->ChipSet) == RHD_FAMILY_RS690) {
	RHDWriteMC(rhdPtr,  RS69_MCCFG_FB_LOCATION, MC->FbLocation);
    } else {
	RHDRegWrite(rhdPtr, R6XX_MC_VM_FB_LOCATION, MC->FbLocation);
	RHDRegWrite(rhdPtr, R6XX_HDP_NONSURFACE_BASE, MC->MiscOffset);
    }
d729 3
d733 2
a734 1
RHDMCSetup(RHDPtr rhdPtr)
a736 2
    CARD32 fb_location, fb_location_tmp, fb_offset_tmp;
    CARD16 fb_size;
d740 33
a772 2
    if (!MC)
	return;
d775 19
a793 1
	unsigned int reg;
d795 11
a805 15
	if (RHDFamily(rhdPtr->ChipSet) == RHD_FAMILY_RV515)
	    reg = RV515_MC_FB_LOCATION | MC_IND_ALL;
	else
	    reg = R5XX_MC_FB_LOCATION | MC_IND_ALL;

	fb_location = RHDReadMC(rhdPtr, reg);
	fb_size = (fb_location >> 16) - (fb_location & 0xFFFF);
	fb_location_tmp = rhdPtr->FbIntAddress >> 16;
	fb_location_tmp |= (fb_location_tmp + fb_size) << 16;

	RHDDebug(rhdPtr->scrnIndex, "%s: fb_location: 0x%08X "
		 "[fb_size: 0x%04X] -> fb_location: 0x%08X\n",
		 __func__, (unsigned int)fb_location,
		 fb_size,(unsigned int)fb_location_tmp);
	RHDWriteMC(rhdPtr, reg, fb_location_tmp);
d807 28
a834 11
	fb_location = RHDReadMC(rhdPtr, RS69_MCCFG_FB_LOCATION);
	fb_size = (fb_location >> 16) - (fb_location & 0xFFFF);
	fb_location_tmp = rhdPtr->FbIntAddress >> 16;
	fb_location_tmp |= (fb_location_tmp + fb_size) << 16;

	RHDDebug(rhdPtr->scrnIndex, "%s: fb_location: 0x%08X "
		 "[fb_size: 0x%04X] -> fb_location: 0x%08X\n",
		 __func__, (unsigned int)fb_location,
		 fb_size,(unsigned int)fb_location_tmp);
	RHDWriteMC(rhdPtr, RS69_MCCFG_FB_LOCATION,
		   fb_location_tmp);
d836 5
a840 12
	fb_location = RHDRegRead(rhdPtr, R6XX_MC_VM_FB_LOCATION);
	fb_size = (fb_location >> 16) - (fb_location & 0xFFFF);
	fb_location_tmp = rhdPtr->FbIntAddress >> 24;
	fb_location_tmp |= (fb_location_tmp + fb_size) << 16;
	fb_offset_tmp = (rhdPtr->FbIntAddress >> 8) & 0xff0000;

	RHDDebug(rhdPtr->scrnIndex, "%s: fb_location: 0x%08X "
		 "fb_offset: 0x%08X [fb_size: 0x%04X] -> fb_location: 0x%08X "
		 "fb_offset: 0x%08X\n",
		 __func__, (unsigned int)fb_location,
		 RHDRegRead(rhdPtr,R6XX_HDP_NONSURFACE_BASE), fb_size,
		 (unsigned int)fb_location_tmp, (unsigned int)fb_offset_tmp);
a841 3
	RHDRegWrite(rhdPtr, R6XX_MC_VM_FB_LOCATION, fb_location_tmp);
	RHDRegWrite(rhdPtr, R6XX_HDP_NONSURFACE_BASE, fb_offset_tmp);
    }
d844 5
a848 2
Bool
RHDMCIdle(RHDPtr rhdPtr, CARD32 count)
d852 14
a865 14
    do {
	if (RHDFamily(rhdPtr->ChipSet) == RHD_FAMILY_RV515) {
	    if (RHDReadMC(rhdPtr, MC_IND_ALL | RV515_MC_STATUS) & RV515_MC_IDLE)
		return TRUE;
	} else if (rhdPtr->ChipSet < RHD_RS690) {
	    if (RHDReadMC(rhdPtr, MC_IND_ALL | R5XX_MC_STATUS) & R5XX_MC_IDLE)
		return TRUE;
	} else if (RHDFamily(rhdPtr->ChipSet) == RHD_FAMILY_RS690) {
	    if (RHDReadMC(rhdPtr, RS69_MC_SYSTEM_STATUS) & RS69_MC_SEQUENCER_IDLE)
		return TRUE;
	} else {
	    if (!(RHDRegRead(rhdPtr, R6_MCLK_PWRMGT_CNTL) & R6_MC_BUSY))
		return TRUE;
	}
d867 1
a867 2
	usleep(10);
    } while (count--);
d869 12
a880 1
    RHDDebug(rhdPtr->scrnIndex, "%s: MC not idle\n",__func__);
d882 1
a882 1
    return FALSE;
@


1.1
log
@Initial revision
@
text
@d30 6
a40 4
#ifndef _XF86_ANSIC_H
#include <string.h>
#endif

d58 2
a59 2
    /* for now */
    if (rhdPtr->ChipSet < RHD_RS690)
d96 2
a97 2
    if (rhdPtr->ChipSet < RHD_R600) {
	if (rhdPtr->ChipSet == RHD_RV515)
d101 2
d105 1
a105 1
	MC->MiscOffset = RHDRegRead(rhdPtr, R6XX_MC_VM_MISC_OFFSET);
d128 3
a130 3
    if (rhdPtr->ChipSet < RHD_R600) {
	if (rhdPtr->ChipSet == RHD_RV515)
	    RHDWriteMC(rhdPtr, MC_IND_ALL | MC_IND_WR_EN | RV515_MC_FB_LOCATION,
d133 1
a133 1
	    RHDWriteMC(rhdPtr, MC_IND_ALL | MC_IND_WR_EN | R5XX_MC_FB_LOCATION,
d135 2
d139 1
a139 1
	RHDRegWrite(rhdPtr, R6XX_MC_VM_MISC_OFFSET, MC->MiscOffset);
d155 1
a155 1
    if (rhdPtr->ChipSet < RHD_R600) {
d158 1
a158 1
	if (rhdPtr->ChipSet == RHD_RV515)
d172 13
a184 1
	RHDWriteMC(rhdPtr, reg | MC_IND_WR_EN, fb_location_tmp);
d196 1
a196 1
		 RHDRegRead(rhdPtr,R6XX_MC_VM_MISC_OFFSET), fb_size,
d200 1
a200 1
	RHDRegWrite(rhdPtr, R6XX_MC_VM_MISC_OFFSET, fb_offset_tmp);
d202 28
@


1.1.1.1
log
@xf86-video-radeonhd 1.0
@
text
@@


1.1.1.2
log
@xf86-video-radeonhd 1.1.0
@
text
@d35 4
d57 1
a57 1
    if (rhdPtr->ChipSet < RHD_RS600)
@

