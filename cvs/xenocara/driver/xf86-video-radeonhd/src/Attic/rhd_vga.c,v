head	1.7;
access;
symbols
	OPENBSD_5_1_BASE:1.6
	OPENBSD_5_1:1.6.0.2
	OPENBSD_5_0:1.4.0.10
	OPENBSD_5_0_BASE:1.4
	OPENBSD_4_9:1.4.0.6
	OPENBSD_4_9_BASE:1.4
	OPENBSD_4_8:1.4.0.8
	OPENBSD_4_8_BASE:1.4
	OPENBSD_4_7:1.4.0.4
	OPENBSD_4_7_BASE:1.4
	OPENBSD_4_6:1.4.0.2
	OPENBSD_4_6_BASE:1.4
	OPENBSD_4_5:1.3.0.2
	OPENBSD_4_5_BASE:1.3
	OPENBSD_4_4:1.2.0.2
	OPENBSD_4_4_BASE:1.2
	OPENBSD_4_3_BASE:1.1.1.2
	OPENBSD_4_3:1.1.1.2.0.2
	v1_1_0:1.1.1.2
	v1_0:1.1.1.1
	xorg:1.1.1;
locks; strict;
comment	@ * @;


1.7
date	2012.03.04.16.09.07;	author matthieu;	state dead;
branches;
next	1.6;

1.6
date	2012.02.06.22.53.16;	author matthieu;	state Exp;
branches;
next	1.5;

1.5
date	2012.01.31.07.59.54;	author matthieu;	state dead;
branches;
next	1.4;

1.4
date	2009.04.26.13.59.41;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2008.11.01.18.14.38;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2008.04.19.13.41.46;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2007.12.04.22.20.28;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2007.12.04.22.20.28;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2008.01.05.17.28.36;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.7
log
@Remove xf86-video-radeonhd for good.
@
text
@/*
 * Copyright 2007-2008  Luc Verhaegen <libv@@exsuse.de>
 * Copyright 2007-2008  Matthias Hopf <mhopf@@novell.com>
 * Copyright 2007-2008  Egbert Eich   <eich@@novell.com>
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE COPYRIGHT HOLDER(S) OR AUTHOR(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR
 * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 */

#ifdef HAVE_CONFIG_H
#include "config.h"
#endif

#include "xf86.h"
#if HAVE_XF86_ANSIC_H
# include "xf86_ansic.h"
#endif

#include "rhd.h"
#include "rhd_vga.h"
#include "rhd_regs.h"
#include "rhd_mc.h"

struct rhdVGA {
    Bool Stored;

    CARD32 FBOffset;
    CARD8 *FB;
    int FBSize; /* 256kB */

    CARD32 Render_Control;
    CARD32 Mode_Control;
    CARD32 HDP_Control;
    CARD32 D1_Control;
    CARD32 D2_Control;
};

/*
 *
 */
void
RHDVGAInit(RHDPtr rhdPtr)
{
    struct rhdVGA *VGA;

    RHDFUNC(rhdPtr);

    /* Check whether one of our VGA bits is set */
    if (!(RHDRegRead(rhdPtr, VGA_RENDER_CONTROL) & 0x00030000) &&
	(RHDRegRead(rhdPtr, VGA_HDP_CONTROL) & 0x00000010) &&
	!(RHDRegRead(rhdPtr, D1VGA_CONTROL) & 0x00000001) &&
	!(RHDRegRead(rhdPtr, D2VGA_CONTROL) & 0x00000001))
	return;

    xf86DrvMsg(rhdPtr->scrnIndex, X_INFO, "Detected VGA mode.\n");

    VGA = xnfcalloc(sizeof(struct rhdVGA), 1);
    VGA->Stored = FALSE;

    rhdPtr->VGA = VGA;
}

/*
 * Thoroughly check whether our VGA FB is accessible.
 */
static CARD32
rhdVGAFBOffsetGet(RHDPtr rhdPtr)
{
    CARD32 FBSize, VGAFBOffset, VGAFBSize = 256 * 1024;
    CARD64 FBAddress = RHDMCGetFBLocation(rhdPtr, &FBSize);
    CARD64 VGAFBAddress = RHDRegRead(rhdPtr, VGA_MEMORY_BASE_ADDRESS);

    if (VGAFBAddress < FBAddress)
	return 0xFFFFFFFF;

    if ((VGAFBAddress + VGAFBSize) > (FBAddress + FBSize))
	return 0xFFFFFFFF;

    VGAFBOffset = VGAFBAddress - FBAddress; /* < FBSize, so 32bit */

    if ((VGAFBOffset + VGAFBSize) >= rhdPtr->FbMapSize)
	return 0xFFFFFFFF;

    return VGAFBOffset;
}

/*
 * This is (usually) ok, as VGASave is called after the memory has been mapped,
 * but before the MC is set up. So the use of RHDMCGetFBLocation is correct in
 * rhdVGAFBOffsetGet.
 */
static void
rhdVGASaveFB(RHDPtr rhdPtr)
{
    struct rhdVGA *VGA = rhdPtr->VGA;

    ASSERT(rhdPtr->FbBase);

    RHDFUNC(rhdPtr);

    VGA->FBOffset = rhdVGAFBOffsetGet(rhdPtr);

    if (VGA->FBOffset == 0xFFFFFFFF) {
	xf86DrvMsg(rhdPtr->scrnIndex, X_WARNING, "%s: Unable to access the VGA "
		   "framebuffer (0x%08X)\n", __func__,
		   (unsigned int) RHDRegRead(rhdPtr, VGA_MEMORY_BASE_ADDRESS));
	if (VGA->FB)
	    xfree(VGA->FB);
	VGA->FB = NULL;
	VGA->FBSize = 0;
	return;
    }

    VGA->FBSize = 256 * 1024;

    RHDDebug(rhdPtr->scrnIndex, "%s: VGA FB Offset 0x%08X [0x%08X]\n",
	     __func__, VGA->FBOffset, VGA->FBSize);

    if (!VGA->FB)
	VGA->FB = xcalloc(VGA->FBSize, 1);

    if (VGA->FB)
	memcpy(VGA->FB, ((CARD8 *) rhdPtr->FbBase) + VGA->FBOffset,
	       VGA->FBSize);
    else {
	xf86DrvMsg(rhdPtr->scrnIndex, X_WARNING, "%s: Failed to allocate"
		   " space for storing the VGA framebuffer.\n", __func__);
	VGA->FBOffset = 0xFFFFFFFF;
	VGA->FBSize = 0;
    }
}

/*
 *
 */
void
RHDVGASave(RHDPtr rhdPtr)
{
    struct rhdVGA *VGA = rhdPtr->VGA;

    RHDFUNC(rhdPtr);

    if (!VGA)
	return; /* We don't need to warn , this is intended use */

    VGA->Render_Control = RHDRegRead(rhdPtr, VGA_RENDER_CONTROL);
    VGA->Mode_Control = RHDRegRead(rhdPtr, VGA_MODE_CONTROL);
    VGA->HDP_Control = RHDRegRead(rhdPtr, VGA_HDP_CONTROL);
    VGA->D1_Control = RHDRegRead(rhdPtr, D1VGA_CONTROL);
    VGA->D2_Control = RHDRegRead(rhdPtr, D2VGA_CONTROL);

    rhdVGASaveFB(rhdPtr);
    VGA->Stored = TRUE;
}

/*
 *
 */
void
RHDVGARestore(RHDPtr rhdPtr)
{
    struct rhdVGA *VGA = rhdPtr->VGA;

    RHDFUNC(rhdPtr);

    if (!VGA)
	return; /* We don't need to warn , this is intended use */

    if (!VGA->Stored) {
	xf86DrvMsg(rhdPtr->scrnIndex, X_ERROR,
		   "%s: trying to restore uninitialized values.\n", __func__);
	return;
    }

    if (VGA->FB)
	memcpy(((CARD8 *) rhdPtr->FbBase) + VGA->FBOffset, VGA->FB,
	       VGA->FBSize);

    RHDRegWrite(rhdPtr, VGA_RENDER_CONTROL, VGA->Render_Control);
    RHDRegWrite(rhdPtr, VGA_MODE_CONTROL, VGA->Mode_Control);
    RHDRegWrite(rhdPtr, VGA_HDP_CONTROL, VGA->HDP_Control);
    RHDRegWrite(rhdPtr, D1VGA_CONTROL, VGA->D1_Control);
    RHDRegWrite(rhdPtr, D2VGA_CONTROL, VGA->D2_Control);
    RHD_UNSETDEBUGFLAG(rhdPtr, VGA_SETUP);
}

/*
 *
 */
void
RHDVGADisable(RHDPtr rhdPtr)
{
    RHDFUNC(rhdPtr);

    RHDRegMask(rhdPtr, VGA_RENDER_CONTROL, 0, 0x00030000);
    RHDRegMask(rhdPtr, VGA_MODE_CONTROL, 0, 0x00000030);
    RHDRegMask(rhdPtr, VGA_HDP_CONTROL, 0x00010010, 0x00010010);
    RHDRegMask(rhdPtr, D1VGA_CONTROL, 0, D1VGA_MODE_ENABLE);
    RHDRegMask(rhdPtr, D2VGA_CONTROL, 0, D2VGA_MODE_ENABLE);
    RHD_SETDEBUGFLAG(rhdPtr, VGA_SETUP);
}

/*
 *
 */
void
RHDVGADestroy(RHDPtr rhdPtr)
{
    struct rhdVGA *VGA = rhdPtr->VGA;

    RHDFUNC(rhdPtr);

    if (!VGA)
	return; /* We don't need to warn , this is intended use */

    if (VGA->FB)
	xfree(VGA->FB);
    xfree(VGA);
}
@


1.6
log
@Revert the update to xf86-video-ati 6.14.3. Requested by espie@@
who experiemnts regressions with this driver.
@
text
@@


1.5
log
@Remove 2 obsolete drivers that have been unlinked from builds.
@
text
@@


1.4
log
@Update to xf86-video-radeonhd 1.2.5. Tested by eric@@

Version 1.2.5 improvements:

  - Added 2D acceleration for R6xx and R7xx.
  - Added XVideo support for R6xx and R7xx.
  - Added support for RS880 and RV790.
  - Added RandR 1.3 mandatory properties.
  - Refactoring of MC code.
  - Enable DRI support by default on R5xx and RS6xx.
  - LUT (color lookup table) fixes.
  - Tons of quirk table entries and bug fixes.
  - Fix register accesses for processors that reorder memory writes.
@
text
@@


1.3
log
@xf86-video-radeonhd 1.2.3
@
text
@d2 3
a4 4
 * Copyright 2007  Luc Verhaegen <lverhaegen@@novell.com>
 * Copyright 2007  Matthias Hopf <mhopf@@novell.com>
 * Copyright 2007  Egbert Eich   <eich@@novell.com>
 * Copyright 2007  Advanced Micro Devices, Inc.
d39 14
d79 27
a105 1
 *
d111 2
a112 3
    CARD32 FBLocation;
    CARD32 FBSize;
    CARD32 VGAFBOffset;
d116 14
a129 2
    if (!VGA)
	return; /* We don't need to warn , this is intended use */
d131 2
a132 22
    /* Store our VGA FB */
    FBLocation = RHDGetFBLocation(rhdPtr, &FBSize);
    VGA->FBBase =
	RHDRegRead(rhdPtr, VGA_MEMORY_BASE_ADDRESS);
    VGAFBOffset = VGA->FBBase - FBLocation;
    RHDDebug(rhdPtr->scrnIndex, "%s: VGAFBOffset: 0x%8.8x FBLocation: 0x%8.8x FBSize: 0x%8.8x\n",
	     __func__, VGAFBOffset, FBLocation, FBSize);

    /* Could be that the VGA internal address no longer is pointing to what
       we know as our FB memory, in which case we should give up cleanly. */
    if (VGAFBOffset < (unsigned) (rhdPtr->FbMapSize)) {

	VGA->FBSize = 256 * 1024;

	if ((VGAFBOffset + VGA->FBSize) > (unsigned) (rhdPtr->FbMapSize)) {
	    /* clamp to the size of the aperture. Otherwise we would have to
	       remap here */
	    VGA->FBSize = (unsigned) (rhdPtr->FbMapSize) - VGAFBOffset;
		RHDDebug(rhdPtr->scrnIndex,
			 "%s: saving %i bytes of VGA memory\n",__func__,
			 VGA->FBSize);
	}
d134 1
d136 8
a143 18
	if (VGA->FB) {
	    RHDDebug(rhdPtr->scrnIndex,"%s: memcpy(%p, %p, 0x%x)\n",
		     __func__,VGA->FB, ((CARD8 *) rhdPtr->FbBase)
		     + VGAFBOffset, VGA->FBSize);
	    memcpy(VGA->FB, ((CARD8 *) rhdPtr->FbBase) + VGAFBOffset,
		   VGA->FBSize);
	} else {
	    xf86DrvMsg(rhdPtr->scrnIndex, X_WARNING, "%s: Failed to allocate"
		       " space for storing the VGA framebuffer.\n", __func__);
	    VGA->FBSize = 0;
	    VGA->FB = NULL;
	}
    } else {
	xf86DrvMsg(rhdPtr->scrnIndex, X_ERROR, "%s: VGA FB Offset (0x%08X) is "
		   "out of range of the Cards Internal FB Address (0x%08X)\n",
		   __func__, (int) RHDRegRead(rhdPtr, VGA_MEMORY_BASE_ADDRESS),
		   rhdPtr->FbIntAddress);
	VGA->FBBase = 0xFFFFFFFF;
a144 1
	VGA->FB = NULL;
d190 3
a192 6
    if (VGA->FB) {
	CARD32 VGAFBOffset = VGA->FBBase - RHDGetFBLocation(rhdPtr, NULL);

	memcpy(((CARD8 *) rhdPtr->FbBase) + VGAFBOffset,
	       VGA->FB, VGA->FBSize);
    }
d199 1
d215 1
@


1.2
log
@Update to xf86-video-radeonhd 1.2.0. Tested by jdixon@@ and jasper@@
@
text
@d38 1
d68 2
a69 2
void
RHDVGASave(RHDPtr rhdPtr)
a70 1
    ScrnInfoPtr pScrn = xf86Screens[rhdPtr->scrnIndex];
d72 3
a80 6
    VGA->Render_Control = RHDRegRead(rhdPtr, VGA_RENDER_CONTROL);
    VGA->Mode_Control = RHDRegRead(rhdPtr, VGA_MODE_CONTROL);
    VGA->HDP_Control = RHDRegRead(rhdPtr, VGA_HDP_CONTROL);
    VGA->D1_Control = RHDRegRead(rhdPtr, D1VGA_CONTROL);
    VGA->D2_Control = RHDRegRead(rhdPtr, D2VGA_CONTROL);

d82 6
a87 3
    VGA->FBOffset =
	RHDRegRead(rhdPtr, VGA_MEMORY_BASE_ADDRESS) - rhdPtr->FbIntAddress;

d91 2
a92 1
    if (VGA->FBOffset < (unsigned) (pScrn->videoRam * 1024)) {
d94 10
d105 5
a109 2
	if (VGA->FB)
	    memcpy(VGA->FB, ((CARD8 *) rhdPtr->FbBase) + VGA->FBOffset,
d111 1
a111 1
	else {
d122 1
a122 1
	VGA->FBOffset = 0xFFFFFFFF;
d126 1
d128 20
d170 4
a173 2
    if (VGA->FB)
	memcpy(((CARD8 *) rhdPtr->FbBase) + VGA->FBOffset,
d175 1
d195 2
a196 2
    RHDRegMask(rhdPtr, D1VGA_CONTROL, 0, 0x00000001);
    RHDRegMask(rhdPtr, D2VGA_CONTROL, 0, 0x00000001);
@


1.1
log
@Initial revision
@
text
@d31 3
a38 4
#ifndef _XF86_ANSIC_H
#include <string.h>
#endif

d91 1
a91 1
    if (VGA->FBOffset < (unsigned) pScrn->videoRam) {
@


1.1.1.1
log
@xf86-video-radeonhd 1.0
@
text
@@


1.1.1.2
log
@xf86-video-radeonhd 1.1.0
@
text
@a30 3
#if HAVE_XF86_ANSIC_H
# include "xf86_ansic.h"
#endif
d35 4
@

