head	1.8;
access;
symbols
	OPENBSD_5_1_BASE:1.7
	OPENBSD_5_1:1.7.0.2
	OPENBSD_5_0:1.5.0.8
	OPENBSD_5_0_BASE:1.5
	OPENBSD_4_9:1.5.0.4
	OPENBSD_4_9_BASE:1.5
	OPENBSD_4_8:1.5.0.6
	OPENBSD_4_8_BASE:1.5
	OPENBSD_4_7:1.5.0.2
	OPENBSD_4_7_BASE:1.5
	OPENBSD_4_6:1.4.0.2
	OPENBSD_4_6_BASE:1.4
	OPENBSD_4_5:1.3.0.2
	OPENBSD_4_5_BASE:1.3
	OPENBSD_4_4:1.1.1.2.0.4
	OPENBSD_4_4_BASE:1.1.1.2
	OPENBSD_4_3_BASE:1.1.1.2
	OPENBSD_4_3:1.1.1.2.0.2
	v1_1_0:1.1.1.2
	v1_0:1.1.1.1
	xorg:1.1.1;
locks; strict;
comment	@ * @;


1.8
date	2012.03.04.16.09.07;	author matthieu;	state dead;
branches;
next	1.7;

1.7
date	2012.02.06.22.53.14;	author matthieu;	state Exp;
branches;
next	1.6;

1.6
date	2012.01.31.07.59.54;	author matthieu;	state dead;
branches;
next	1.5;

1.5
date	2009.11.24.16.57.34;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2009.04.26.13.59.41;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2009.01.28.14.43.56;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2008.11.01.18.14.37;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2007.12.04.22.20.30;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2007.12.04.22.20.30;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2008.01.05.17.28.37;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.8
log
@Remove xf86-video-radeonhd for good.
@
text
@/*
 * Copyright 2007-2008  Luc Verhaegen <libv@@exsuse.de>
 * Copyright 2007-2008  Matthias Hopf <mhopf@@novell.com>
 * Copyright 2007-2008  Egbert Eich   <eich@@novell.com>
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE COPYRIGHT HOLDER(S) OR AUTHOR(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR
 * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 */

#ifdef HAVE_CONFIG_H
#include "config.h"
#endif

#include "xf86.h"

#include "rhd.h"
#include "rhd_lut.h"
#include "rhd_regs.h"

#include <compiler.h>

#define RHD_REGOFFSET_LUTA 0x000
#define RHD_REGOFFSET_LUTB 0x800

/*
 *
 */
static void
LUTxSave(struct rhdLUT *LUT)
{
    CARD16 RegOff;
    int i;
    RHDFUNC(LUT);

    if (LUT->Id == RHD_LUT_A)
	RegOff = RHD_REGOFFSET_LUTA;
    else
	RegOff = RHD_REGOFFSET_LUTB;

    LUT->StoreControl = RHDRegRead(LUT, RegOff + DC_LUTA_CONTROL);

    LUT->StoreBlackBlue = RHDRegRead(LUT, RegOff + DC_LUTA_BLACK_OFFSET_BLUE);
    LUT->StoreBlackGreen = RHDRegRead(LUT, RegOff + DC_LUTA_BLACK_OFFSET_GREEN);
    LUT->StoreBlackRed = RHDRegRead(LUT, RegOff + DC_LUTA_BLACK_OFFSET_RED);

    LUT->StoreWhiteBlue = RHDRegRead(LUT, RegOff + DC_LUTA_WHITE_OFFSET_BLUE);
    LUT->StoreWhiteGreen = RHDRegRead(LUT, RegOff + DC_LUTA_WHITE_OFFSET_GREEN);
    LUT->StoreWhiteRed = RHDRegRead(LUT, RegOff + DC_LUTA_WHITE_OFFSET_RED);

    RHDRegWrite(LUT, DC_LUT_RW_MODE, 0); /* Table */
    if (LUT->Id == RHD_LUT_A)
	RHDRegWrite(LUT, DC_LUT_READ_PIPE_SELECT, 0);
    else
	RHDRegWrite(LUT, DC_LUT_READ_PIPE_SELECT, 1);

    RHDRegWrite(LUT, DC_LUT_RW_INDEX, 0);
    for (i = 0; i < 256; i++)
	LUT->StoreEntry[i] = RHDRegRead(LUT, DC_LUT_30_COLOR);

    LUT->Stored = TRUE;
}

/*
 *
 */
static void
LUTxRestore(struct rhdLUT *LUT)
{
    CARD16 RegOff;
    int i;
    RHDFUNC(LUT);

    if (!LUT->Stored) {
	xf86DrvMsg(LUT->scrnIndex, X_ERROR, "%s: %s: nothing stored!\n",
		   __func__, LUT->Name);
	return;
    }

    if (LUT->Id == RHD_LUT_A)
	RegOff = RHD_REGOFFSET_LUTA;
    else
	RegOff = RHD_REGOFFSET_LUTB;

    RHDRegWrite(LUT, RegOff + DC_LUTA_BLACK_OFFSET_BLUE, LUT->StoreBlackBlue);
    RHDRegWrite(LUT, RegOff + DC_LUTA_BLACK_OFFSET_GREEN, LUT->StoreBlackGreen);
    RHDRegWrite(LUT, RegOff + DC_LUTA_BLACK_OFFSET_RED, LUT->StoreBlackRed);

    RHDRegWrite(LUT, RegOff + DC_LUTA_WHITE_OFFSET_BLUE, LUT->StoreWhiteBlue);
    RHDRegWrite(LUT, RegOff + DC_LUTA_WHITE_OFFSET_GREEN, LUT->StoreWhiteGreen);
    RHDRegWrite(LUT, RegOff + DC_LUTA_WHITE_OFFSET_RED, LUT->StoreWhiteRed);

    if (LUT->Id == RHD_LUT_A)
	RHDRegWrite(LUT, DC_LUT_RW_SELECT, 0);
    else
	RHDRegWrite(LUT, DC_LUT_RW_SELECT, 1);

    RHDRegWrite(LUT, DC_LUT_RW_MODE, 0); /* Table */
    RHDRegWrite(LUT, DC_LUT_WRITE_EN_MASK, 0x0000003F);
    RHDRegWrite(LUT, DC_LUT_RW_INDEX, 0);
    for (i = 0; i < 256; i++)
	RHDRegWrite(LUT, DC_LUT_30_COLOR, LUT->StoreEntry[i]);

    RHDRegWrite(LUT, RegOff + DC_LUTA_CONTROL, LUT->StoreControl);
}

/*
 * Load a new LUT
 *
 * Assumes 256 rows of input. It's up to the caller to ensure there are exactly
 * 256 rows of data, as that's what the hardware exepcts.
 */
static void
rhdLUTSet(struct rhdLUT *LUT, CARD16 *red, CARD16 *green, CARD16 *blue)
{
    CARD16 RegOff;
    int i;

    LUT->Initialised = TRUE; /* thank you RandR */

    if (LUT->Id == RHD_LUT_A)
	RegOff = RHD_REGOFFSET_LUTA;
    else
	RegOff = RHD_REGOFFSET_LUTB;

    RHDRegWrite(LUT, RegOff + DC_LUTA_CONTROL, 0);

    RHDRegWrite(LUT, RegOff + DC_LUTA_BLACK_OFFSET_BLUE, 0);
    RHDRegWrite(LUT, RegOff + DC_LUTA_BLACK_OFFSET_GREEN, 0);
    RHDRegWrite(LUT, RegOff + DC_LUTA_BLACK_OFFSET_RED, 0);

    RHDRegWrite(LUT, RegOff + DC_LUTA_WHITE_OFFSET_BLUE, 0x0000FFFF);
    RHDRegWrite(LUT, RegOff + DC_LUTA_WHITE_OFFSET_GREEN, 0x0000FFFF);
    RHDRegWrite(LUT, RegOff + DC_LUTA_WHITE_OFFSET_RED, 0x0000FFFF);

    if (LUT->Id == RHD_LUT_A)
	RHDRegWrite(LUT, DC_LUT_RW_SELECT, 0);
    else
	RHDRegWrite(LUT, DC_LUT_RW_SELECT, 1);

    RHDRegWrite(LUT, DC_LUT_RW_MODE, 0); /* table */
    RHDRegWrite(LUT, DC_LUT_WRITE_EN_MASK, 0x0000003F);

    RHDRegWrite(LUT, DC_LUT_RW_INDEX, 0);
    for (i = 0; i < 256; i++) {
        RHDRegWrite(LUT, DC_LUT_30_COLOR,
                    ((red[i] & 0xFFC0) << 14) | ((green[i] & 0xFFC0) << 4) | (blue[i] >> 6));
    }
}

/*
 * Set specific rows of the LUT
 *
 * Assumes LUTs are already initialized to a sane state, and will only update
 * specific rows.  Use ONLY when just specific rows need to be updated.
 */
static void
rhdLUTSetRows(struct rhdLUT *LUT, int numColors, int *indices, LOCO *colors)
{
    CARD16 RegOff;
    int i, index;

    if (LUT->Id == RHD_LUT_A)
	RegOff = RHD_REGOFFSET_LUTA;
    else
	RegOff = RHD_REGOFFSET_LUTB;

    if (LUT->Id == RHD_LUT_A)
	RHDRegWrite(LUT, DC_LUT_RW_SELECT, 0);
    else
	RHDRegWrite(LUT, DC_LUT_RW_SELECT, 1);

    RHDRegWrite(LUT, DC_LUT_RW_MODE, 0); /* table */
    RHDRegWrite(LUT, DC_LUT_WRITE_EN_MASK, 0x0000003F);

    for (i = 0; i < numColors; i++) {
        index = indices[i];
        RHDRegWrite(LUT, DC_LUT_RW_INDEX, index);
        RHDRegWrite(LUT, DC_LUT_30_COLOR,
                    (colors[index].red << 20) | (colors[index].green << 10) | (colors[index].blue));
    }
}

/*
 *
 */
void
RHDLUTsInit(RHDPtr rhdPtr)
{
    struct rhdLUT *LUT;

    RHDFUNC(rhdPtr);

    LUT = xnfcalloc(sizeof(struct rhdLUT), 1);

    LUT->scrnIndex = rhdPtr->scrnIndex;
    LUT->Name = "LUT A";
    LUT->Id = RHD_LUT_A;

    LUT->Save = LUTxSave;
    LUT->Restore = LUTxRestore;
    LUT->Set = rhdLUTSet;
    LUT->SetRows = rhdLUTSetRows;

    rhdPtr->LUT[0] = LUT;

    LUT = xnfcalloc(sizeof(struct rhdLUT), 1);

    LUT->scrnIndex = rhdPtr->scrnIndex;
    LUT->Name = "LUT B";
    LUT->Id = RHD_LUT_B;

    LUT->Save = LUTxSave;
    LUT->Restore = LUTxRestore;
    LUT->Set = rhdLUTSet;
    LUT->SetRows = rhdLUTSetRows;

    rhdPtr->LUT[1] = LUT;
}

/*
 *
 */
struct rhdLUTStore {
    CARD32 Select;
    CARD32 Mode;
    CARD32 Index;
    CARD32 Color;
    CARD32 ReadPipe;
    CARD32 WriteMask;
};

/*
 *
 */
void
RHDLUTsSave(RHDPtr rhdPtr)
{
    struct rhdLUTStore *Store = rhdPtr->LUTStore;

    RHDFUNC(rhdPtr);

    if (!Store) {
	Store = xnfcalloc(sizeof(struct rhdLUTStore), 1);
	rhdPtr->LUTStore = Store;
    }

    Store->Select = RHDRegRead(rhdPtr, DC_LUT_RW_SELECT);
    Store->Mode = RHDRegRead(rhdPtr, DC_LUT_RW_MODE);
    Store->Index = RHDRegRead(rhdPtr, DC_LUT_RW_INDEX);
    Store->Color = RHDRegRead(rhdPtr, DC_LUT_30_COLOR);
    Store->ReadPipe = RHDRegRead(rhdPtr, DC_LUT_READ_PIPE_SELECT);
    Store->WriteMask = RHDRegRead(rhdPtr, DC_LUT_WRITE_EN_MASK);

    rhdPtr->LUT[0]->Save(rhdPtr->LUT[0]);
    rhdPtr->LUT[1]->Save(rhdPtr->LUT[1]);
}

/*
 *
 */
void
RHDLUTsRestore(RHDPtr rhdPtr)
{
    struct rhdLUTStore *Store = rhdPtr->LUTStore;

    RHDFUNC(rhdPtr);

    rhdPtr->LUT[0]->Restore(rhdPtr->LUT[0]);
    rhdPtr->LUT[1]->Restore(rhdPtr->LUT[1]);

    if (!Store) {
	xf86DrvMsg(rhdPtr->scrnIndex, X_ERROR, "%s: nothing stored!\n", __func__);
	return;
    }

    RHDRegWrite(rhdPtr, DC_LUT_RW_SELECT, Store->Select);
    RHDRegWrite(rhdPtr, DC_LUT_RW_MODE, Store->Mode);
    RHDRegWrite(rhdPtr, DC_LUT_RW_INDEX, Store->Index);
    RHDRegWrite(rhdPtr, DC_LUT_30_COLOR, Store->Color);
    RHDRegWrite(rhdPtr, DC_LUT_READ_PIPE_SELECT, Store->ReadPipe);
    RHDRegWrite(rhdPtr, DC_LUT_WRITE_EN_MASK, Store->WriteMask);
}

/*
 *
 */
void
RHDLUTsDestroy(RHDPtr rhdPtr)
{
    RHDFUNC(rhdPtr);

    xfree(rhdPtr->LUT[0]);
    xfree(rhdPtr->LUT[1]);
    xfree(rhdPtr->LUTStore);
}

/*
 * Workaround for missing RandR functionality. Initialise this
 * LUT with the content of the other LUT.
 */
void
RHDLUTCopyForRR(struct rhdLUT *LUT)
{
    CARD16 red[256], green[256], blue[256];
    CARD32 entry;
    int i;

    RHDDebug(LUT->scrnIndex, "%s: %s\n", __func__, LUT->Name);

    RHDRegWrite(LUT, DC_LUT_RW_MODE, 0); /* Table */

    if (LUT->Id == RHD_LUT_A)
	RHDRegWrite(LUT, DC_LUT_READ_PIPE_SELECT, 1);
    else
	RHDRegWrite(LUT, DC_LUT_READ_PIPE_SELECT, 0);

    for (i = 0; i < 256; i++) {
        entry = RHDRegRead(LUT, DC_LUT_30_COLOR);
        red[i] = (entry >> 14) & 0xFFC0;
        green[i] = (entry >> 4) & 0xFFC0;
        blue[i] = (entry << 6) & 0xFFC0;
    }

    rhdLUTSet(LUT, red, green, blue);
}
@


1.7
log
@Revert the update to xf86-video-ati 6.14.3. Requested by espie@@
who experiemnts regressions with this driver.
@
text
@@


1.6
log
@Remove 2 obsolete drivers that have been unlinked from builds.
@
text
@@


1.5
log
@Update to xf86-video-radeonhd 1.3.0
Tested by killi@@ on a HD3200.
@
text
@@


1.4
log
@Update to xf86-video-radeonhd 1.2.5. Tested by eric@@

Version 1.2.5 improvements:

  - Added 2D acceleration for R6xx and R7xx.
  - Added XVideo support for R6xx and R7xx.
  - Added support for RS880 and RV790.
  - Added RandR 1.3 mandatory properties.
  - Refactoring of MC code.
  - Enable DRI support by default on R5xx and RS6xx.
  - LUT (color lookup table) fixes.
  - Tons of quirk table entries and bug fixes.
  - Fix register accesses for processors that reorder memory writes.
@
text
@d72 2
a73 2
    for (i = 0; i < 0x300; i++)
	LUT->StoreEntry[i] = RHDRegRead(LUT, DC_LUT_SEQ_COLOR);
d115 2
a116 2
    for (i = 0; i < 0x300; i++)
	RHDRegWrite(LUT, DC_LUT_SEQ_COLOR, LUT->StoreEntry[i]);
d122 1
d124 2
d128 1
a128 1
LUTxSet(struct rhdLUT *LUT, int numColors, int *indices, LOCO *colors)
a129 1
    ScrnInfoPtr pScrn = xf86Screens[LUT->scrnIndex];
d131 1
a131 1
    int i, index, hw_index;
d158 37
a194 60
    /* DC_LUT_RW_INDEX is incremented automatically when DC_LUT_30_COLOR
     * is accessed; hw_index is used to track the value of DC_LUT_RW_INDEX
     * so that we can properly handle the very unlikely case that the input
     * table indexes are not monotonically increasing
     */
    switch (pScrn->depth) {
    case 8:
    case 24:
    case 32:
        RHDRegWrite(LUT, DC_LUT_RW_INDEX, 0);
        hw_index = 0;
	for (i = 0; i < numColors; i++) {
            index = indices[i];
            if (hw_index != index) {
                RHDRegWrite(LUT, DC_LUT_RW_INDEX, index);
                hw_index = index;
            }
	    RHDRegWrite(LUT, DC_LUT_30_COLOR, (colors[index].red << 20) |
			(colors[index].green << 10) | (colors[index].blue));
            hw_index++;
	}
	break;
    case 16:
        RHDRegWrite(LUT, DC_LUT_RW_INDEX, 0);
        hw_index = 0;
	for (i = 0; i < numColors; i++) {
	    int j;

	    index = indices[i];
            if (hw_index != 4 * index) {
                RHDRegWrite(LUT, DC_LUT_RW_INDEX, 4 * index);
                hw_index = 4 * index;
            }

	    for (j = 0; j < 4; j++) {
		RHDRegWrite(LUT, DC_LUT_30_COLOR, (colors[index/2].red << 20) |
			    (colors[index].green << 10) | (colors[index/2].blue));
                hw_index++;
            }
	}
	break;
    case 15:
        RHDRegWrite(LUT, DC_LUT_RW_INDEX, 0);
        hw_index = 0;
	for (i = 0; i < numColors; i++) {
	    int j;

	    index = indices[i];
            if (hw_index != 8 * index) {
                RHDRegWrite(LUT, DC_LUT_RW_INDEX, 8 * index);
                hw_index = 8 * index;
            }

	    for (j = 0; j < 8; j++) {
		RHDRegWrite(LUT, DC_LUT_30_COLOR, (colors[index].red << 20) |
			    (colors[index].green << 10) | (colors[index].blue));
                hw_index++;
            }
	}
	break;
d216 2
a217 1
    LUT->Set = LUTxSet;
d229 2
a230 1
    LUT->Set = LUTxSet;
d319 1
a319 2
    int indices[0x100];
    LOCO colors[0x100];
d332 5
a336 45
    switch (xf86Screens[LUT->scrnIndex]->depth) {
    case 8:
    case 24:
    case 32:
	RHDRegWrite(LUT, DC_LUT_RW_INDEX, 0);

	for (i = 0; i < 0x100; i++) {
	    indices[i] = i;

	    entry = RHDRegRead(LUT, DC_LUT_30_COLOR);

	    colors[i].red = (entry >> 20) & 0x3FF;
	    colors[i].green = (entry >> 10) & 0x3FF;
	    colors[i].blue = (entry) & 0x3FF;
	}
	LUT->Set(LUT, 0x100, indices, colors);
	break;
    case 16:
	for (i = 0; i < 0x40; i++) {
	    indices[i] = i;

	    RHDRegWrite(LUT, DC_LUT_RW_INDEX, 4 * i);

	    entry = RHDRegRead(LUT, DC_LUT_30_COLOR);

	    colors[i / 2].red = (entry >> 20) & 0x3FF;
	    colors[i].green = (entry >> 10) & 0x3FF;
	    colors[i / 2].blue = (entry) & 0x3FF;
	}
	LUT->Set(LUT, 0x40, indices, colors);
	break;
    case 15:
	for (i = 0; i < 0x20; i++) {
	    indices[i] = i;

	    RHDRegWrite(LUT, DC_LUT_RW_INDEX, 8 * i);

	    entry = RHDRegRead(LUT, DC_LUT_30_COLOR);

	    colors[i].red = (entry >> 20) & 0x3FF;
	    colors[i].green = (entry >> 10) & 0x3FF;
	    colors[i].blue = (entry) & 0x3FF;
	}
	LUT->Set(LUT, 0x20, indices, colors);
	break;
d338 2
@


1.3
log
@Update to xf86-video-radeonhd 1.2.4.

  - Added HDMI support.
  - Added support for RV710, RV730 (DCE 3.2).
  - Added screen rotation support.
  - Added RandR 1.3 panning support. (not useful until xserver 1.6)
  - Many acceleration and build fixes.

Tested on mbalmer@@'s radeon 2400HD card.
@
text
@d2 1
a2 1
 * Copyright 2007-2008  Luc Verhaegen <lverhaegen@@novell.com>
d35 2
d129 1
a129 1
    int i, index;
d156 5
d165 2
d168 8
a175 4
	    index = indices[i];
	    RHDRegWrite(LUT, DC_LUT_RW_INDEX, index);
	    RHDRegWrite(LUT, DC_LUT_30_COLOR, (colors[index].red << 22) |
			(colors[index].green << 12) | (colors[index].blue << 2));
d179 2
d185 10
a194 5
	    RHDRegWrite(LUT, DC_LUT_RW_INDEX, 4 * index);

	    for (j = 0; j < 4; j++)
		RHDRegWrite(LUT, DC_LUT_30_COLOR, (colors[index/2].red << 24) |
			    (colors[index].green << 14) | (colors[index/2].blue << 4));
d198 2
d204 10
a213 5
	    RHDRegWrite(LUT, DC_LUT_RW_INDEX, 8 * index);

	    for (j = 0; j < 8; j++)
		RHDRegWrite(LUT, DC_LUT_30_COLOR, (colors[index].red << 25) |
			    (colors[index].green << 15) | (colors[index].blue << 5));
d363 3
a365 3
	    colors[i].red = (entry >> 22) & 0xFF;
	    colors[i].green = (entry >> 12) & 0xFF;
	    colors[i].blue = (entry >> 2) & 0xFF;
d377 3
a379 3
	    colors[i / 2].red = (entry >> 24) & 0xFF;
	    colors[i].green = (entry >> 14) & 0xFF;
	    colors[i / 2].blue = (entry >> 4) & 0xFF;
d391 3
a393 3
	    colors[i].red = (entry >> 25) & 0xFF;
	    colors[i].green = (entry >> 15) & 0xFF;
	    colors[i].blue = (entry >> 5) & 0xFF;
@


1.2
log
@xf86-video-radeonhd 1.2.3
@
text
@d2 3
a4 4
 * Copyright 2007  Luc Verhaegen <lverhaegen@@novell.com>
 * Copyright 2007  Matthias Hopf <mhopf@@novell.com>
 * Copyright 2007  Egbert Eich   <eich@@novell.com>
 * Copyright 2007  Advanced Micro Devices, Inc.
d47 1
a47 1
    
d129 2
d302 69
@


1.1
log
@Initial revision
@
text
@d36 2
a37 2
#define RHD_REGOFFSET_LUTA 0x0000
#define RHD_REGOFFSET_LUTB 0x8000
d47 2
a48 1

d85 1
@


1.1.1.1
log
@xf86-video-radeonhd 1.0
@
text
@@


1.1.1.2
log
@xf86-video-radeonhd 1.1.0
@
text
@d36 2
a37 2
#define RHD_REGOFFSET_LUTA 0x000
#define RHD_REGOFFSET_LUTB 0x800
@

