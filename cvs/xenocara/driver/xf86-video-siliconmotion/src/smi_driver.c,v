head	1.11;
access;
symbols
	OPENBSD_6_0:1.10.0.6
	OPENBSD_6_0_BASE:1.10
	OPENBSD_5_9:1.10.0.4
	OPENBSD_5_9_BASE:1.10
	OPENBSD_5_8:1.10.0.2
	OPENBSD_5_8_BASE:1.10
	OPENBSD_5_7:1.9.0.8
	OPENBSD_5_7_BASE:1.9
	OPENBSD_5_6:1.9.0.6
	OPENBSD_5_6_BASE:1.9
	OPENBSD_5_5:1.9.0.4
	OPENBSD_5_5_BASE:1.9
	OPENBSD_5_4:1.9.0.2
	OPENBSD_5_4_BASE:1.9
	OPENBSD_5_3:1.8.0.2
	OPENBSD_5_3_BASE:1.8
	OPENBSD_5_2:1.7.0.2
	OPENBSD_5_2_BASE:1.7
	OPENBSD_5_1_BASE:1.6
	OPENBSD_5_1:1.6.0.4
	OPENBSD_5_0:1.6.0.2
	OPENBSD_5_0_BASE:1.6
	OPENBSD_4_9:1.5.0.4
	OPENBSD_4_9_BASE:1.5
	OPENBSD_4_8:1.5.0.6
	OPENBSD_4_8_BASE:1.5
	OPENBSD_4_7:1.5.0.2
	OPENBSD_4_7_BASE:1.5
	OPENBSD_4_6:1.4.0.2
	OPENBSD_4_6_BASE:1.4
	OPENBSD_4_5:1.2.0.2
	OPENBSD_4_5_BASE:1.2
	OPENBSD_4_4:1.1.1.1.0.6
	OPENBSD_4_4_BASE:1.1.1.1
	OPENBSD_4_3_BASE:1.1.1.1
	OPENBSD_4_3:1.1.1.1.0.4
	OPENBSD_4_2:1.1.1.1.0.2
	OPENBSD_4_2_BASE:1.1.1.1
	v1_4_2:1.1.1.1
	xorg:1.1.1;
locks; strict;
comment	@ * @;


1.11
date	2017.02.18.18.08.53;	author matthieu;	state Exp;
branches;
next	1.10;
commitid	x6fhl0W21m7Udc7M;

1.10
date	2015.05.24.09.45.36;	author matthieu;	state Exp;
branches;
next	1.9;
commitid	OuU4Dc8TDAzNijzb;

1.9
date	2013.05.12.13.06.25;	author matthieu;	state Exp;
branches;
next	1.8;

1.8
date	2012.09.08.22.33.13;	author matthieu;	state Exp;
branches;
next	1.7;

1.7
date	2012.05.13.20.45.50;	author matthieu;	state Exp;
branches;
next	1.6;

1.6
date	2011.05.07.08.47.55;	author matthieu;	state Exp;
branches;
next	1.5;

1.5
date	2009.11.22.17.53.03;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2009.05.03.16.53.46;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2009.03.26.22.09.36;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2008.08.21.19.55.24;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.26.20.12.20;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.11.26.20.12.20;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.11
log
@Update to xf86-video-siliconmotion 1.7.9
@
text
@/* Header:   //Mercury/Projects/archives/XFree86/4.0/smi_driver.c-arc   1.42   03 Jan 2001 13:52:16   Frido  $ */

/*
Copyright (C) 1994-1999 The XFree86 Project, Inc.  All Rights Reserved.
Copyright (C) 2000 Silicon Motion, Inc.  All Rights Reserved.

Permission is hereby granted, free of charge, to any person obtaining a copy of
this software and associated documentation files (the "Software"), to deal in
the Software without restriction, including without limitation the rights to
use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
of the Software, and to permit persons to whom the Software is furnished to do
so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FIT-
NESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
XFREE86 PROJECT BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

Except as contained in this notice, the names of The XFree86 Project and
Silicon Motion shall not be used in advertising or otherwise to promote the
sale, use or other dealings in this Software without prior written
authorization from The XFree86 Project or Silicon Motion.
*/

#ifdef HAVE_CONFIG_H
#include "config.h"
#endif

#include "xf86.h"
#include "xf86DDC.h"
#include "xf86int10.h"
#include "vbe.h"

#if GET_ABI_MAJOR(ABI_VIDEODRV_VERSION) < 6
#include "xf86Resources.h"
#include "xf86RAC.h"
#endif

#include "smi.h"
#include "smi_501.h"
#include "smilynx.h"
#include "smi_crtc.h"

#include "globals.h"
#ifdef HAVE_XEXTPROTO_71
#include <X11/extensions/dpmsconst.h>
#else
#define DPMS_SERVER
#include <X11/extensions/dpms.h>
#endif


/*
 * Internals
 */
static Bool SMI_MapMmio(ScrnInfoPtr pScrn);
static Bool SMI_DetectMem(ScrnInfoPtr pScrn);
static void SMI_EnableMmio(ScrnInfoPtr pScrn);
static void SMI_DisableMmio(ScrnInfoPtr pScrn);
static Bool SMI_HWInit(ScrnInfoPtr pScrn);

/*
 * Forward definitions for the functions that make up the driver.
 */

static const OptionInfoRec * SMI_AvailableOptions(int chipid, int busid);
static void SMI_Identify(int flags);
static Bool SMI_Probe(DriverPtr drv, int flags);
static Bool SMI_PreInit(ScrnInfoPtr pScrn, int flags);
static Bool SMI_EnterVT(VT_FUNC_ARGS_DECL);
static void SMI_LeaveVT(VT_FUNC_ARGS_DECL);
static Bool SMI_ScreenInit(SCREEN_INIT_ARGS_DECL);
static void SMI_DisableVideo(ScrnInfoPtr pScrn);
static void SMI_EnableVideo(ScrnInfoPtr pScrn);
static Bool SMI_CloseScreen(CLOSE_SCREEN_ARGS_DECL);
static Bool SMI_SaveScreen(ScreenPtr pScreen, int mode);
static void SMI_FreeScreen(FREE_SCREEN_ARGS_DECL);
static void SMI_ProbeDDC(ScrnInfoPtr pScrn, int index);
static void SMI_DetectPanelSize(ScrnInfoPtr pScrn);
static void SMI_DetectMCLK(ScrnInfoPtr pScrn);

/*
 * xf86VDrvMsgVerb prints up to 14 characters prefix, where prefix has the
 * format "%s(%d): " so, use name "SMI" instead of "Silicon Motion"
 */
#define SILICONMOTION_NAME          "SMI"
#define SILICONMOTION_DRIVER_NAME   "siliconmotion"
#define SILICONMOTION_VERSION_NAME  PACKAGE_VERSION
#define SILICONMOTION_VERSION_MAJOR PACKAGE_VERSION_MAJOR
#define SILICONMOTION_VERSION_MINOR PACKAGE_VERSION_MINOR
#define SILICONMOTION_PATCHLEVEL    PACKAGE_VERSION_PATCHLEVEL
#define SILICONMOTION_DRIVER_VERSION ((SILICONMOTION_VERSION_MAJOR << 24) | \
                                      (SILICONMOTION_VERSION_MINOR << 16) | \
                                      (SILICONMOTION_PATCHLEVEL))

#if SMI_DEBUG
int smi_indent = 1;
#endif

/* for dualhead */
int gSMIEntityIndex = -1;

/*
 * This contains the functions needed by the server after loading the
 * driver module.  It must be supplied, and gets added the driver list by
 * the Module Setup funtion in the dynamic case.  In the static case a
 * reference to this is compiled in, and this requires that the name of
 * this DriverRec be an upper-case version of the driver name.
 */

_X_EXPORT DriverRec SILICONMOTION =
{
    SILICONMOTION_DRIVER_VERSION,
    SILICONMOTION_DRIVER_NAME,
    SMI_Identify,
    SMI_Probe,
    SMI_AvailableOptions,
    NULL,
    0
};

/* Supported chipsets */
static SymTabRec SMIChipsets[] =
{
    { PCI_CHIP_SMI910, "Lynx"    },
    { PCI_CHIP_SMI810, "LynxE"   },
    { PCI_CHIP_SMI820, "Lynx3D"  },
    { PCI_CHIP_SMI710, "LynxEM"  },
    { PCI_CHIP_SMI712, "LynxEM+" },
    { PCI_CHIP_SMI720, "Lynx3DM" },
    { PCI_CHIP_SMI731, "Cougar3DR" },
    { PCI_CHIP_SMI501, "MSOC"	 },
    { -1,             NULL      }
};

static PciChipsets SMIPciChipsets[] =
{
    /* numChipset,	PciID,			Resource */
    { PCI_CHIP_SMI910,	PCI_CHIP_SMI910,	RES_SHARED_VGA },
    { PCI_CHIP_SMI810,	PCI_CHIP_SMI810,	RES_SHARED_VGA },
    { PCI_CHIP_SMI820,	PCI_CHIP_SMI820,	RES_SHARED_VGA },
    { PCI_CHIP_SMI710,	PCI_CHIP_SMI710,	RES_SHARED_VGA },
    { PCI_CHIP_SMI712,	PCI_CHIP_SMI712,	RES_SHARED_VGA },
    { PCI_CHIP_SMI720,	PCI_CHIP_SMI720,	RES_SHARED_VGA },
    { PCI_CHIP_SMI731,	PCI_CHIP_SMI731,	RES_SHARED_VGA },
    { PCI_CHIP_SMI501,	PCI_CHIP_SMI501,	RES_UNDEFINED  },
    { -1,		-1,			RES_UNDEFINED  }
};

typedef enum
{
    OPTION_PCI_BURST,
    OPTION_PCI_RETRY,
    OPTION_NOACCEL,
    OPTION_MCLK,
    OPTION_MXCLK,
    OPTION_SWCURSOR,
    OPTION_HWCURSOR,
    OPTION_VIDEOKEY,
    OPTION_BYTESWAP,
    /* CZ 26.10.2001: interlaced video */
    OPTION_INTERLACED,
    /* end CZ */
    OPTION_USEBIOS,
    OPTION_DUALHEAD,
    OPTION_ACCELMETHOD,
    OPTION_PANEL_SIZE,
    OPTION_USE_FBDEV,
    OPTION_CSCVIDEO,
    NUMBER_OF_OPTIONS
} SMIOpts;

static const OptionInfoRec SMIOptions[] =
{
    { OPTION_PCI_BURST,	     "pci_burst",	  OPTV_BOOLEAN, {0}, TRUE },
    { OPTION_PCI_RETRY,	     "pci_retry",	  OPTV_BOOLEAN, {0}, TRUE },
    { OPTION_NOACCEL,	     "NoAccel",		  OPTV_BOOLEAN, {0}, FALSE },
    { OPTION_MCLK,	     "MCLK",		  OPTV_FREQ,	{0}, FALSE },
    { OPTION_MXCLK,	     "MXCLK",		  OPTV_FREQ,	{0}, FALSE },
    { OPTION_HWCURSOR,	     "HWCursor",	  OPTV_BOOLEAN, {0}, TRUE },
    { OPTION_SWCURSOR,	     "SWCursor",	  OPTV_BOOLEAN, {0}, FALSE },
    { OPTION_VIDEOKEY,	     "VideoKey",	  OPTV_INTEGER, {0}, FALSE },
    { OPTION_BYTESWAP,	     "ByteSwap",	  OPTV_BOOLEAN, {0}, FALSE },
    /* CZ 26.10.2001: interlaced video */
    { OPTION_INTERLACED,     "Interlaced",        OPTV_BOOLEAN, {0}, FALSE },
    /* end CZ */
    { OPTION_USEBIOS,	     "UseBIOS",		  OPTV_BOOLEAN,	{0}, FALSE },
    { OPTION_DUALHEAD,	     "Dualhead",	  OPTV_BOOLEAN,	{0}, TRUE },
    { OPTION_ACCELMETHOD,    "AccelMethod",       OPTV_STRING,  {0}, FALSE },
    { OPTION_PANEL_SIZE,     "PanelSize",	  OPTV_ANYSTR,	{0}, FALSE },
    { OPTION_USE_FBDEV,	     "UseFBDev",	  OPTV_BOOLEAN,	{0}, FALSE },
    { OPTION_CSCVIDEO,	     "CSCVideo",	  OPTV_BOOLEAN, {0}, TRUE },
    { -1,		     NULL,		  OPTV_NONE,	{0}, FALSE }
};

#ifdef XFree86LOADER

static MODULESETUPPROTO(siliconmotionSetup);

static XF86ModuleVersionInfo SMIVersRec =
{
    "siliconmotion",
    MODULEVENDORSTRING,
    MODINFOSTRING1,
    MODINFOSTRING2,
    XORG_VERSION_CURRENT,
    SILICONMOTION_VERSION_MAJOR,
    SILICONMOTION_VERSION_MINOR,
    SILICONMOTION_PATCHLEVEL,
    ABI_CLASS_VIDEODRV,
    ABI_VIDEODRV_VERSION,
    MOD_CLASS_VIDEODRV,
    {0, 0, 0, 0}
};

/*
 * This is the module init data for XFree86 modules.
 *
 * Its name has to be the driver name followed by ModuleData.
 */
_X_EXPORT XF86ModuleData siliconmotionModuleData =
{
    &SMIVersRec,
    siliconmotionSetup,
    NULL
};

static pointer
siliconmotionSetup(pointer module, pointer opts, int *errmaj, int *errmin)
{
    static Bool setupDone = FALSE;

    if (!setupDone) {
	setupDone = TRUE;
	xf86AddDriver(&SILICONMOTION, module, 0);

	/*
	 * The return value must be non-NULL on success even though there
	 * is no TearDownProc.
	 */
	return (pointer) 1;

    } else {
	if (errmaj) {
	    *errmaj = LDR_ONCEONLY;
	}
	return NULL;
    }
}

#endif /* XFree86LOADER */

static Bool
SMI_GetRec(ScrnInfoPtr pScrn)
{
    ENTER();

    /*
     * Allocate an 'Chip'Rec, and hook it into pScrn->driverPrivate.
     * pScrn->driverPrivate is initialised to NULL, so we can check if
     * the allocation has already been done.
     */
    if (pScrn->driverPrivate == NULL) {
	pScrn->driverPrivate = xnfcalloc(sizeof(SMIRec), 1);
    }

    LEAVE(TRUE);
}

static void
SMI_FreeRec(ScrnInfoPtr pScrn)
{
    SMIPtr	pSmi = SMIPTR(pScrn);

    ENTER();

    if (pSmi) {
	free(pSmi->save);
	free(pSmi->mode);
	free(pScrn->driverPrivate);
	pScrn->driverPrivate = NULL;
    }

    LEAVE();
}

static const OptionInfoRec *
SMI_AvailableOptions(int chipid, int busid)
{
    ENTER();

    LEAVE(SMIOptions);
}

static void
SMI_Identify(int flags)
{
    ENTER();

    xf86PrintChipsets(SILICONMOTION_NAME, "driver (version "
		SILICONMOTION_VERSION_NAME ") for Silicon Motion Lynx chipsets",
		SMIChipsets);

    LEAVE();
}

static Bool
SMI_Probe(DriverPtr drv, int flags)
{
    int i;
    GDevPtr *devSections;
    int *usedChips;
    int numDevSections;
    int numUsed;
    Bool foundScreen = FALSE;

    ENTER();

    numDevSections = xf86MatchDevice(SILICONMOTION_DRIVER_NAME, &devSections);

    if (numDevSections <= 0)
	/* There's no matching device section in the config file, so quit now. */
	LEAVE(FALSE);

#ifndef XSERVER_LIBPCIACCESS
    if (xf86GetPciVideoInfo() == NULL)
	LEAVE(FALSE);
#endif

    numUsed = xf86MatchPciInstances(SILICONMOTION_NAME, PCI_SMI_VENDOR_ID,
				    SMIChipsets, SMIPciChipsets, devSections,
				    numDevSections, drv, &usedChips);

    /* Free it since we don't need that list after this */
    free(devSections);
    if (numUsed <= 0)
	LEAVE(FALSE);

    if (flags & PROBE_DETECT)
	foundScreen = TRUE;
    else {
	ScrnInfoPtr	pScrn;
	EntityInfoPtr	pEnt;

	for (i = 0; i < numUsed; i++) {
	    if ((pScrn = xf86ConfigPciEntity(NULL, 0, usedChips[i],
					     SMIPciChipsets, NULL,
					     NULL, NULL, NULL, NULL))) {
		pScrn->driverVersion = SILICONMOTION_DRIVER_VERSION;
		pScrn->driverName    = SILICONMOTION_DRIVER_NAME;
		pScrn->name	     = SILICONMOTION_NAME;
		pScrn->Probe	     = SMI_Probe;
		pScrn->PreInit	     = SMI_PreInit;
		pScrn->ScreenInit    = SMI_ScreenInit;
		pScrn->SwitchMode    = SMI_SwitchMode;
		pScrn->AdjustFrame   = SMI_AdjustFrame;

		if ((pEnt = xf86GetEntityInfo(usedChips[i]))) {
			pScrn->EnterVT   = SMI_EnterVT;
			pScrn->LeaveVT   = SMI_LeaveVT;
		    free(pEnt);
		}
		pScrn->FreeScreen    = SMI_FreeScreen;
		foundScreen	     = TRUE;
	    }
	}
    }
    free(usedChips);

    LEAVE(foundScreen);
}

static Bool
SMI_PreInit(ScrnInfoPtr pScrn, int flags)
{
    EntityInfoPtr pEnt;
    SMIPtr pSmi;
    MessageType from;
    vgaHWPtr hwp;
	
    ENTER();

    /* Ignoring the Type list for now.  It might be needed when multiple cards
     * are supported.
     */
    if (pScrn->numEntities > 1)
	LEAVE(FALSE);

    /* Allocate the SMIRec driverPrivate */
    if (!SMI_GetRec(pScrn))
	LEAVE(FALSE);
    pSmi = SMIPTR(pScrn);

    /* Find the PCI slot for this screen */
    pEnt = xf86GetEntityInfo(pScrn->entityList[0]);

    pSmi->PciInfo = xf86GetPciInfoForEntity(pEnt->index);
    pSmi->Chipset = PCI_DEV_DEVICE_ID(pSmi->PciInfo);

    if (IS_MSOC(pSmi)) {
	pSmi->Save = SMI501_Save;
	pSmi->save = xnfcalloc(sizeof(MSOCRegRec), 1);
	pSmi->mode = xnfcalloc(sizeof(MSOCRegRec), 1);
    }
    else {
	pSmi->Save = SMILynx_Save;
	pSmi->save = xnfcalloc(sizeof(SMIRegRec), 1);
	pSmi->mode = xnfcalloc(sizeof(SMIRegRec), 1);
    }

    if (flags & PROBE_DETECT) {
	if (!IS_MSOC(pSmi))
	    SMI_ProbeDDC(pScrn, xf86GetEntityInfo(pScrn->entityList[0])->index);
	LEAVE(TRUE);
    }

    if (pEnt->location.type != BUS_PCI) {
	free(pEnt);
	SMI_FreeRec(pScrn);
	LEAVE(FALSE);
    }
    pSmi->PciInfo = xf86GetPciInfoForEntity(pEnt->index);

    /* Set pScrn->monitor */
    pScrn->monitor = pScrn->confScreen->monitor;

    if (!IS_MSOC(pSmi)) {
	/* The vgahw module should be loaded here when needed */
	if (!xf86LoadSubModule(pScrn, "vgahw"))
	    LEAVE(FALSE);

	/*
	 * Allocate a vgaHWRec
	 */
	if (!vgaHWGetHWRec(pScrn))
	    LEAVE(FALSE);

	hwp = VGAHWPTR(pScrn);
	vgaHWSetStdFuncs(hwp);
#if GET_ABI_MAJOR(ABI_VIDEODRV_VERSION) < 12
	pSmi->PIOBase = hwp->PIOOffset;
#else
	pSmi->PIOBase = 0;
#endif

	xf86ErrorFVerb(VERBLEV, "\tSMI_PreInit vgaCRIndex=%x, vgaIOBase=%x, "
		       "MMIOBase=%p\n", hwp->IOBase + VGA_CRTC_INDEX_OFFSET,
		       hwp->IOBase, hwp->MMIOBase);
    }

    /*
     * The first thing we should figure out is the depth, bpp, etc.
     */
    if (!xf86SetDepthBpp(pScrn, 0, 0, 0, Support32bppFb))
	LEAVE(FALSE);

    /* Check that the returned depth is one we support */
    if (pScrn->depth != 8 && pScrn->depth != 16 && pScrn->depth != 24) {
	xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
		   "Given depth (%d) is not supported by this driver\n",
		   pScrn->depth);
	LEAVE(FALSE);
    }


    if(pScrn->bitsPerPixel != 8 && pScrn->bitsPerPixel != 16 &&
       pScrn->bitsPerPixel != 24 && pScrn->bitsPerPixel != 32){
	xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
		   "Given bpp (%d) is not supported by this driver\n",
		   pScrn->bitsPerPixel);
	LEAVE(FALSE);
    }

    xf86PrintDepthBpp(pScrn);

    pSmi->Bpp = pScrn->bitsPerPixel >> 3;

    /*
     * This must happen after pScrn->display has been set because
     * xf86SetWeight references it.
     */
    if (pScrn->depth > 8) {
	/* The defaults are OK for us */
	rgb zeros = {0, 0, 0};
#if X_BYTE_ORDER == X_BIG_ENDIAN
	rgb masks = {0xff00,0xff0000,0xff000000};
#else
	rgb masks = {0, 0, 0};
#endif

	if (!xf86SetWeight(pScrn, zeros, masks))
	    LEAVE(FALSE);
    }

    if (!xf86SetDefaultVisual(pScrn, -1))
	LEAVE(FALSE);

    /* We don't currently support DirectColor at > 8bpp */
    if (pScrn->depth > 8 && pScrn->defaultVisual != TrueColor) {
	xf86DrvMsg(pScrn->scrnIndex, X_ERROR, "Given default visual (%s) "
		   "is not supported at depth %d\n",
		   xf86GetVisualName(pScrn->defaultVisual), pScrn->depth);
	LEAVE(FALSE);
    }

    /* We use a programmable clock */
    pScrn->progClock = TRUE;

    /* Collect all of the relevant option flags (fill in pScrn->options) */
    xf86CollectOptions(pScrn, NULL);

    /* Set the bits per RGB for 8bpp mode */
    if (pScrn->depth == 8){
	pScrn->rgbBits = IS_MSOC(pSmi) ? 8 : 6;
    }else if(pScrn->depth == 16){
	/* Use 8 bit LUT for gamma correction*/
	pScrn->rgbBits = 8;
    }

    /* Process the options */
    if (!(pSmi->Options = malloc(sizeof(SMIOptions))))
	LEAVE(FALSE);

    memcpy(pSmi->Options, SMIOptions, sizeof(SMIOptions));
    xf86ProcessOptions(pScrn->scrnIndex, pScrn->options, pSmi->Options);

    /* Enable pci burst by default */
    from = X_DEFAULT;
    pSmi->PCIBurst = TRUE;
    if (xf86GetOptValBool(pSmi->Options, OPTION_PCI_BURST, &pSmi->PCIBurst))
	from = X_CONFIG;
    xf86DrvMsg(pScrn->scrnIndex, from, "PCI Burst %sabled\n",
	       pSmi->PCIBurst ? "en" : "dis");

    /* Pci retry enabled by default if pci burst also enabled */
    from = X_DEFAULT;
    pSmi->PCIRetry = pSmi->PCIBurst ? TRUE : FALSE;
    if (xf86GetOptValBool(pSmi->Options, OPTION_PCI_RETRY, &pSmi->PCIRetry)) {
	from = X_CONFIG;
	if (pSmi->PCIRetry && !pSmi->PCIBurst) {
	    xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
		       "\"pci_retry\" option requires \"pci_burst\".\n");
	    pSmi->PCIRetry = FALSE;
	}
    }
    xf86DrvMsg(pScrn->scrnIndex, from, "PCI Retry %sabled\n",
	       pSmi->PCIRetry ? "en" : "dis");

    if (xf86ReturnOptValBool(pSmi->Options, OPTION_NOACCEL, FALSE)) {
	pSmi->NoAccel = TRUE;
	xf86DrvMsg(pScrn->scrnIndex, X_CONFIG, "Option: NoAccel - Acceleration "
		   "disabled\n");
    } else {
	pSmi->NoAccel = FALSE;
    }

    if (IS_MSOC(pSmi)) {
	from = X_DEFAULT;
	if (xf86GetOptValBool(pSmi->Options, OPTION_USE_FBDEV, &pSmi->UseFBDev))
	    from = X_CONFIG;
	xf86DrvMsg(pScrn->scrnIndex, from, "UseFBDev %s.\n",
		   pSmi->UseFBDev ? "enabled" : "disabled");
    }

    from = X_CONFIG;
    pSmi->HwCursor = TRUE;
    /* SWCursor overrides HWCusor if both specified */
    if (xf86ReturnOptValBool(pSmi->Options, OPTION_SWCURSOR, FALSE))
	pSmi->HwCursor = FALSE;
    else if (!xf86GetOptValBool(pSmi->Options, OPTION_HWCURSOR, &pSmi->HwCursor))
	from = X_DEFAULT;

    xf86DrvMsg(pScrn->scrnIndex, from, "Using %sware Cursor\n",
	       pSmi->HwCursor ? "Hard" : "Soft");

    if (xf86GetOptValInteger(pSmi->Options, OPTION_VIDEOKEY, &pSmi->videoKey)) {
	xf86DrvMsg(pScrn->scrnIndex, X_CONFIG, "Option: Video key set to "
		   "0x%08X\n", pSmi->videoKey);
    } else {
	pSmi->videoKey = (1 << pScrn->offset.red) |
			 (1 << pScrn->offset.green) |
			 (((pScrn->mask.blue >> pScrn->offset.blue) - 1)
			 << pScrn->offset.blue);
    }

    if (xf86ReturnOptValBool(pSmi->Options, OPTION_BYTESWAP, FALSE)) {
	pSmi->ByteSwap = TRUE;
	xf86DrvMsg(pScrn->scrnIndex, X_CONFIG, "Option: ByteSwap enabled.\n");
    } else {
	pSmi->ByteSwap = FALSE;
    }

    /* CZ 26.10.2001: interlaced video */
    if (xf86ReturnOptValBool(pSmi->Options, OPTION_INTERLACED, FALSE)) {
	pSmi->interlaced = TRUE;
	xf86DrvMsg(pScrn->scrnIndex, X_CONFIG, "Option: Interlaced enabled.\n");
    } else {
	pSmi->interlaced = FALSE;
    }
    /* end CZ */

    if (IS_MSOC(pSmi))
	pSmi->useBIOS = FALSE;
    else if (xf86GetOptValBool(pSmi->Options, OPTION_USEBIOS, &pSmi->useBIOS)) {
	xf86DrvMsg(pScrn->scrnIndex, X_CONFIG, "Option: UseBIOS %s.\n",
		   pSmi->useBIOS ? "enabled" : "disabled");
    }
    else if(pSmi->Chipset == SMI_LYNX3DM){
	/* Default to UseBIOS disabled. */
	pSmi->useBIOS = FALSE;
    }
    else {
	/* Default to UseBIOS enabled. */
	pSmi->useBIOS = TRUE;
    }

    if (pSmi->useBIOS) {
	if (xf86LoadSubModule(pScrn,"int10")) {
	    pSmi->pInt10 = xf86InitInt10(pEnt->index);
	}

	if (pSmi->pInt10 && xf86LoadSubModule(pScrn, "vbe")) {
	    pSmi->pVbe = VBEInit(pSmi->pInt10, pEnt->index);
	}

	if(!pSmi->pVbe){
	    xf86DrvMsg(pScrn->scrnIndex, X_WARNING, "VBE initialization failed: falling back to UseBIOS disabled.\n");
	    pSmi->useBIOS = FALSE;
	}
    }

#ifndef XSERVER_LIBPCIACCESS
    xf86RegisterResources(pEnt->index, NULL, ResExclusive);
#endif
    /*
     * Set the Chipset and ChipRev, allowing config file entries to
     * override.
     */
    if (pEnt->device->chipset && *pEnt->device->chipset) {
	pScrn->chipset = pEnt->device->chipset;
	pSmi->Chipset = xf86StringToToken(SMIChipsets, pScrn->chipset);
	from = X_CONFIG;
    }
    else if (pEnt->device->chipID >= 0) {
	pSmi->Chipset = pEnt->device->chipID;
	pScrn->chipset = (char *) xf86TokenToString(SMIChipsets, pSmi->Chipset);
	from = X_CONFIG;
	xf86DrvMsg(pScrn->scrnIndex, X_CONFIG, "ChipID override: 0x%04X\n",
		   pSmi->Chipset);
    }
    else {
	from = X_PROBED;
	pSmi->Chipset = PCI_DEV_DEVICE_ID(pSmi->PciInfo);
	pScrn->chipset = (char *) xf86TokenToString(SMIChipsets, pSmi->Chipset);
    }

    if (pEnt->device->chipRev >= 0) {
	pSmi->ChipRev = pEnt->device->chipRev;
	xf86DrvMsg(pScrn->scrnIndex, X_CONFIG, "ChipRev override: %d\n",
		   pSmi->ChipRev);
    }
    else
        pSmi->ChipRev = PCI_DEV_REVISION(pSmi->PciInfo);
    free(pEnt);

    /*
     * This shouldn't happen because such problems should be caught in
     * SMI_Probe(), but check it just in case.
     */
    if (pScrn->chipset == NULL) {
	xf86DrvMsg(pScrn->scrnIndex, X_ERROR, "ChipID 0x%04X is not "
				"recognised\n", pSmi->Chipset);
	LEAVE(FALSE);
    }

    if (pSmi->Chipset < 0) {
	xf86DrvMsg(pScrn->scrnIndex, X_ERROR, "Chipset \"%s\" is not "
		   "recognised\n", pScrn->chipset);
	LEAVE(FALSE);
    }

    xf86DrvMsg(pScrn->scrnIndex, from, "Chipset: \"%s\"\n", pScrn->chipset);

#ifndef XSERVER_LIBPCIACCESS
    pSmi->PciTag = pciTag(pSmi->PciInfo->bus, pSmi->PciInfo->device,
		   	  pSmi->PciInfo->func);
#endif

    from = X_DEFAULT;
    if(pSmi->Chipset == SMI_LYNX3DM &&
       pScrn->bitsPerPixel == 16)
	pSmi->Dualhead = TRUE;
    else
	pSmi->Dualhead = FALSE;

    if (xf86GetOptValBool(pSmi->Options, OPTION_DUALHEAD, &pSmi->Dualhead))
	from = X_CONFIG;

    if (IS_MSOC(pSmi)) {
	pSmi->lcd = TRUE;
	if (pSmi->Dualhead && pSmi->UseFBDev) {
	    xf86DrvMsg(pScrn->scrnIndex, X_INFO,
		       "Dual head disabled in fbdev mode\n");
	    pSmi->Dualhead = FALSE;
	}
	/* FIXME Randr cursor code only works properly when argb cursors
	 * are also supported.
	 * FIXME This probably is a randr cursor bug, and since access to
	 * hw/xfree86/ramdac/xf86CursorPriv.h:xf86CursorScreenRec.SWCursor
	 * field is not available, one cannot easily workaround the problem,
	 * so, just disable it...
	 * TODO Check with a X Server newer then 1.4.0.90 (that is being
	 * used in the 502 OEM image).
	 * */
	if (pSmi->Dualhead && pSmi->HwCursor) {
	    xf86DrvMsg(pScrn->scrnIndex, X_INFO,
		       "HW Cursor disabled in dual head mode\n");
	    pSmi->HwCursor = FALSE;
	}
    }
    else if (SMI_LYNXM_SERIES(pSmi->Chipset)) {
	/* tweak options for dualhead */
	if (pSmi->Dualhead) {
	    pSmi->useBIOS = FALSE;
	    xf86DrvMsg(pScrn->scrnIndex, X_INFO, "UseBIOS disabled in dualhead mode\n");
	    pSmi->HwCursor = FALSE;
	    xf86DrvMsg(pScrn->scrnIndex, X_INFO, "No hardware cursor in dualhead mode\n");
	    if (pScrn->bitsPerPixel != 16) {
		xf86DrvMsg(pScrn->scrnIndex, X_ERROR, "Dualhead only supported at "
			   "depth 16\n");
		LEAVE(FALSE);
	    }
	}
    }
    xf86DrvMsg(pScrn->scrnIndex, from, "Dual head %sabled\n",
	       pSmi->Dualhead ? "en" : "dis");

    if (!pSmi->NoAccel) {
	char *strptr;

	from = X_DEFAULT;
	if ((strptr = (char *)xf86GetOptValString(pSmi->Options,
						  OPTION_ACCELMETHOD))) {
	    if (!xf86NameCmp(strptr,"XAA")) {
		from = X_CONFIG;
		pSmi->useEXA = FALSE;
	    } else if(!xf86NameCmp(strptr,"EXA")) {
		from = X_CONFIG;
		pSmi->useEXA = TRUE;
	    }
	}

	xf86DrvMsg(pScrn->scrnIndex, from, "Using %s acceleration architecture\n",
		pSmi->useEXA ? "EXA" : "XAA");
    }

    if (IS_MSOC(pSmi)) {
	pSmi->CSCVideo = !pSmi->useEXA || !pSmi->Dualhead;
	from = X_DEFAULT;
	if (xf86GetOptValBool(pSmi->Options, OPTION_CSCVIDEO, &pSmi->CSCVideo)) {
	    from = X_CONFIG;

	    /* FIXME */
	    if (pSmi->CSCVideo && pSmi->useEXA && pSmi->Dualhead) {
		xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
			   "CSCVideo requires XAA or EXA in single head mode.\n");
		pSmi->CSCVideo = FALSE;
	    }
	}

	xf86DrvMsg(pScrn->scrnIndex, from, "CSC Video %sabled\n",
		   pSmi->CSCVideo ? "en" : "dis");
    }

    SMI_MapMmio(pScrn);
    SMI_DetectMem(pScrn);
    SMI_MapMem(pScrn);
    SMI_DisableVideo(pScrn);

    /* detect the panel size */
    SMI_DetectPanelSize(pScrn);

    if(!IS_MSOC(pSmi)){
	if (xf86LoadSubModule(pScrn, "i2c")) {
	    SMI_I2CInit(pScrn);
	}
	xf86LoadSubModule(pScrn, "ddc");
    }

    /*
     * If the driver can do gamma correction, it should call xf86SetGamma()
     */
    {
	Gamma zeros = { 0.0, 0.0, 0.0 };

	if (!xf86SetGamma(pScrn, zeros)) {
	    SMI_EnableVideo(pScrn);
	    SMI_UnmapMem(pScrn);
	    LEAVE(FALSE);
	}
    }

    SMI_DetectMCLK(pScrn);

    /*
     * Setup the ClockRanges, which describe what clock ranges are available,
     * and what sort of modes they can be used for.
     */
    pSmi->clockRange.next = NULL;
    pSmi->clockRange.minClock = 20000;

    if (SMI_LYNXM_SERIES(pSmi->Chipset) ||
	IS_MSOC(pSmi))
	pSmi->clockRange.maxClock = 200000;
    else
        pSmi->clockRange.maxClock = 135000;

    pSmi->clockRange.clockIndex = -1;
    pSmi->clockRange.interlaceAllowed = FALSE;
    pSmi->clockRange.doubleScanAllowed = FALSE;

    if(!SMI_CrtcPreInit(pScrn))
	LEAVE(FALSE);

    if(!SMI_OutputPreInit(pScrn))
	LEAVE(FALSE);

    /* Only allow growing the screen dimensions if EXA is being used */
    if (!xf86InitialConfiguration (pScrn, !pSmi->NoAccel && pSmi->useEXA)){
	xf86DrvMsg(pScrn->scrnIndex, X_ERROR, "No valid modes found\n");

	SMI_EnableVideo(pScrn);
	SMI_UnmapMem(pScrn);
	LEAVE(FALSE);
    }

    /* Ensure that the framebuffer size just set fits in video memory. */
    {
	int aligned_pitch = (pScrn->virtualX*pSmi->Bpp + 15) & ~15;

	if(aligned_pitch * pScrn->virtualY > pSmi->FBReserved){
	    xf86DrvMsg(pScrn->scrnIndex, X_ERROR, "Not enough video memory "
		       "for the configured screen size (%dx%d) and color depth.\n",
                       pScrn->virtualX, pScrn->virtualY);

	    SMI_EnableVideo(pScrn);
	    SMI_UnmapMem(pScrn);
	    LEAVE(FALSE);
	}
    }


    SMI_EnableVideo(pScrn);
    SMI_UnmapMem(pScrn);

    if(pSmi->pVbe){
       vbeFree(pSmi->pVbe);
       pSmi->pVbe = NULL;
    }
    if(pSmi->pInt10){
       xf86FreeInt10(pSmi->pInt10);
       pSmi->pInt10 = NULL;
    }

    /* Set display resolution */
    xf86SetDpi(pScrn, 0, 0);

    if (xf86LoadSubModule(pScrn, "fb") == NULL) {
	SMI_FreeRec(pScrn);
	LEAVE(FALSE);
    }

    /* Load XAA or EXA if needed */
    if (!pSmi->NoAccel) {
	if (!pSmi->useEXA) {
	    if (!xf86LoadSubModule(pScrn, "xaa")) {
		xf86DrvMsg(pScrn->scrnIndex, X_WARNING, "No acceleration\n");
		pSmi->NoAccel = 1;
	    }
	} else {
	    XF86ModReqInfo req;
	    int errmaj, errmin;

	    memset(&req, 0, sizeof(XF86ModReqInfo));
	    req.majorversion = 2;
	    req.minorversion = 1;
			
	    if (!LoadSubModule(pScrn->module, "exa", NULL, NULL, NULL,
				&req, &errmaj, &errmin)) {
		LoaderErrorMsg(NULL, "exa", errmaj, errmin);
		SMI_FreeRec(pScrn);
		LEAVE(FALSE);
	    }
	}
    }

    /* Load ramdac if needed */
    if (pSmi->HwCursor) {
	if (!xf86LoadSubModule(pScrn, "ramdac")) {
	    SMI_FreeRec(pScrn);
	    LEAVE(FALSE);
	}
    }

    LEAVE(TRUE);
}

/*
 * This is called when VT switching back to the X server.  Its job is to
 * reinitialise the video mode. We may wish to unmap video/MMIO memory too.
 */

static Bool
SMI_EnterVT(VT_FUNC_ARGS_DECL)
{
    SCRN_INFO_PTR(arg);
    SMIPtr pSmi = SMIPTR(pScrn);

    ENTER();

    /* Enable MMIO and map memory */
    SMI_MapMem(pScrn);

    pSmi->Save(pScrn);

    /* FBBase may have changed after remapping the memory */
    pScrn->pScreen->ModifyPixmapHeader(pScrn->pScreen->GetScreenPixmap(pScrn->pScreen),
				       -1,-1,-1,-1,-1, pSmi->FBBase + pSmi->FBOffset);
#if (XORG_VERSION_CURRENT < XORG_VERSION_NUMERIC(1, 9, 99, 1, 0))
    pScrn->pixmapPrivate.ptr=pSmi->FBBase + pSmi->FBOffset;
#endif

    if(pSmi->useEXA)
       pSmi->EXADriverPtr->memoryBase=pSmi->FBBase;

    /* Do the CRTC independent initialization */
    if(!SMI_HWInit(pScrn))
	LEAVE(FALSE);

    /* Initialize the chosen modes */
    if (!xf86SetDesiredModes(pScrn))
	LEAVE(FALSE);

    xf86DrvMsgVerb(pScrn->scrnIndex, X_INFO, VERBLEV,
		   "Done writing mode.  Register dump:\n");
    SMI_PrintRegs(pScrn);

    /* Reset the grapics engine */
    if (!pSmi->NoAccel)
	SMI_EngineReset(pScrn);

    LEAVE(TRUE);
}

/*
 * This is called when VT switching away from the X server.  Its job is to
 * restore the previous (text) mode. We may wish to remap video/MMIO memory
 * too.
 */

static void
SMI_LeaveVT(VT_FUNC_ARGS_DECL)
{
    SCRN_INFO_PTR(arg);
    SMIPtr	pSmi = SMIPTR(pScrn);

    ENTER();

    SMI_AccelSync(pScrn);

    /* Ensure that the rotation BlockHandler is unwrapped, and the shadow
       pixmaps are deallocated, as the video memory is going to be
       unmapped.  */
    xf86RotateCloseScreen(pScrn->pScreen);

    /* Pixmaps that by chance get allocated near the former aperture
       address shouldn't be considered offscreen. */
    if(pSmi->useEXA)
       pSmi->EXADriverPtr->memoryBase=NULL;

    /* Clear frame buffer */
    memset(pSmi->FBBase, 0, pSmi->videoRAMBytes);

    if (!IS_MSOC(pSmi)) {
	vgaHWPtr	hwp = VGAHWPTR(pScrn);

	SMILynx_WriteMode(pScrn, &hwp->SavedReg, pSmi->save);
    }
    else
	SMI501_WriteMode(pScrn, pSmi->save);

    SMI_UnmapMem(pScrn);

    LEAVE();
}

static void
SMI_DetectPanelSize(ScrnInfoPtr pScrn)
{
    const char	*s;
    int		 width, height;
    SMIPtr	 pSmi = SMIPTR(pScrn);

    pSmi->lcdWidth  = 0;
    pSmi->lcdHeight = 0;
    if ((s = xf86GetOptValString(pSmi->Options, OPTION_PANEL_SIZE)) != NULL) {
	if (sscanf(s, "%dx%d", &width, &height) != 2)
	    xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
		       "Invalid PanelSize option: %s\n", s);
	else {
	    pSmi->lcdWidth  = width;
	    pSmi->lcdHeight = height;
	}
    }

    if (pSmi->lcdWidth == 0 || pSmi->lcdHeight == 0) {
	/* panel size detection ... requires BIOS call on 730 hardware */
	if (pSmi->Chipset == SMI_COUGAR3DR) {
	    if (pSmi->pInt10 != NULL) {
		pSmi->pInt10->num = 0x10;
		pSmi->pInt10->ax  = 0x5F00;
		pSmi->pInt10->bx  = 0;
		pSmi->pInt10->cx  = 0;
		pSmi->pInt10->dx  = 0;
		xf86ExecX86int10(pSmi->pInt10);
		if (pSmi->pInt10->ax == 0x005F) {
		    switch (pSmi->pInt10->cx & 0x0F) {
			case PANEL_640x480:
			    pSmi->lcdWidth  = 640;
			    pSmi->lcdHeight = 480;
			    break;
			case PANEL_800x600:
			    pSmi->lcdWidth  = 800;
			    pSmi->lcdHeight = 600;
			    break;
			case PANEL_1024x768:
			    pSmi->lcdWidth  = 1024;
			    pSmi->lcdHeight = 768;
			    break;
			case PANEL_1280x1024:
			    pSmi->lcdWidth  = 1280;
			    pSmi->lcdHeight = 1024;
			    break;
			case PANEL_1600x1200:
			    pSmi->lcdWidth  = 1600;
			    pSmi->lcdHeight = 1200;
			    break;
			case PANEL_1400x1050:
			    pSmi->lcdWidth  = 1400;
			    pSmi->lcdHeight = 1050;
			    break;
		    }

		    xf86DrvMsg(pScrn->scrnIndex, X_INFO,
			       "Detected panel size via BIOS: %d x %d\n",
			       pSmi->lcdWidth, pSmi->lcdHeight);
		}
		else
		    xf86DrvMsg(pScrn->scrnIndex, X_INFO,
			       "BIOS error during 730 panel detection!\n");
	    }
	    else  {
		/* int10 support isn't setup on the second call to this function,
		  o if this is the second call, don't do detection again */
		if (pSmi->lcd == 0)
		    /* If we get here, int10 support is not loaded or not working */ 
		    xf86DrvMsg(pScrn->scrnIndex, X_INFO,
			       "No BIOS support for 730 panel detection!\n");
	    }

	    /* Set this to indicate that we've done the detection */
	    pSmi->lcd = 1;
	}
	else if (IS_MSOC(pSmi)) {
	    pSmi->lcdWidth  = (READ_SCR(pSmi, PANEL_WWIDTH)  >> 16) & 2047;
	    pSmi->lcdHeight = (READ_SCR(pSmi, PANEL_WHEIGHT) >> 16) & 2047;
	}
	else {
	    /* panel size detection for hardware other than 730 */
	    pSmi->lcd = VGAIN8_INDEX(pSmi, VGA_SEQ_INDEX, VGA_SEQ_DATA,
				     0x31) & 0x01;

	    if (VGAIN8_INDEX(pSmi, VGA_SEQ_INDEX, VGA_SEQ_DATA,
			     0x30) & 0x01) {
		pSmi->lcd <<= 1;
	    }
	    switch (VGAIN8_INDEX(pSmi, VGA_SEQ_INDEX, VGA_SEQ_DATA,
				 0x30) & 0x0C) {
		case 0x00:
		    pSmi->lcdWidth  = 640;
		    pSmi->lcdHeight = 480;
		    break;
		case 0x04:
		    pSmi->lcdWidth  = 800;
		    pSmi->lcdHeight = 600;
		    break;
		case 0x08:
		    if (VGAIN8_INDEX(pSmi, VGA_SEQ_INDEX, VGA_SEQ_DATA,
				     0x74) & 0x02) {
			pSmi->lcdWidth  = 1024;
			pSmi->lcdHeight = 600;
		    }
		    else {
			pSmi->lcdWidth  = 1024;
			pSmi->lcdHeight = 768;
		    }
		    break;
		case 0x0C:
		    pSmi->lcdWidth  = 1280;
		    pSmi->lcdHeight = 1024;
		    break;
	    }
	}
    }

    if (!pSmi->lcdWidth && (pSmi->lcdWidth = pScrn->virtualX) == 0)
	pSmi->lcdWidth = 1024;
    if (!pSmi->lcdHeight && (pSmi->lcdHeight = pScrn->virtualY) == 0)
	pSmi->lcdHeight = 768;

    xf86DrvMsg(pScrn->scrnIndex, X_INFO, "%s Panel Size = %dx%d\n",
	       (pSmi->lcd == 0) ? "OFF" : (pSmi->lcd == 1) ? "TFT" : "DSTN",
	       pSmi->lcdWidth, pSmi->lcdHeight);

}

static void
SMI_DetectMCLK(ScrnInfoPtr pScrn)
{
    double		real;
    MSOCClockRec	clock;
    int			mclk, mxclk;
    SMIPtr		pSmi = SMIPTR(pScrn);

    /* MCLK defaults */
    if (pSmi->Chipset == SMI_LYNXEMplus){
	/* The SM712 can be safely clocked up to 157MHz, according to
	   Silicon Motion engineers. */
	pSmi->MCLK = 157000;

    } else if (IS_MSOC(pSmi)) {
       /* Set some sane defaults for the clock settings if we are on a
          SM502 and it's likely to be uninitialized. */

       if (!xf86IsPrimaryPci(pSmi->PciInfo) &&
           (READ_SCR(pSmi, DEVICE_ID) & 0xFF) >= 0xC0) {
          pSmi->MCLK = 112000;
          pSmi->MXCLK = 144000;
       }

    } else {
        pSmi->MCLK = 0;
        pSmi->MXCLK = 0;
    }

    /* MCLK from user settings */
    if (xf86GetOptValFreq(pSmi->Options, OPTION_MCLK, OPTUNITS_MHZ, &real)) {
	if (IS_MSOC(pSmi) || (int)real <= 120) {
	    pSmi->MCLK = (int)(real * 1000.0);
	} else {
	    xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
		       "Memory Clock %1.3f MHz larger than limit of 120 MHz\n",
		       real);
	}
    }
    mclk = pSmi->MCLK;

    if (IS_MSOC(pSmi)) {
	clock.value = READ_SCR(pSmi, CURRENT_CLOCK);
	if (xf86GetOptValFreq(pSmi->Options, OPTION_MXCLK,
			      OPTUNITS_MHZ, &real))
	    pSmi->MXCLK = (int)(real * 1000.0);
    }

    /* Already programmed MCLK */
    if (pSmi->MCLK == 0) {
	if (IS_MSOC(pSmi))
	    mclk = ((clock.f.m_select ? 336 : 288) /
		    ((clock.f.m_divider ? 3 : 1) <<
		     (unsigned)clock.f.m_shift)) * 1000;
	else {
	    unsigned char	shift, m, n;

	    m = VGAIN8_INDEX(pSmi, VGA_SEQ_INDEX, VGA_SEQ_DATA, 0x6A);
	    n = VGAIN8_INDEX(pSmi, VGA_SEQ_INDEX, VGA_SEQ_DATA, 0x6B);
	    switch (n >> 6) {
		case 1:
		    shift = 4;
		    break;
		case 2:
		    shift = 2;
		    break;
		default:
		    shift = 1;
		    break;
	    }
	    n &= 0x3F;
	    mclk = ((1431818 * m) / n / shift + 50) / 100;
	}
    }

    xf86DrvMsg(pScrn->scrnIndex, X_INFO, "MCLK = %1.3f\n", mclk / 1000.0);
    if (IS_MSOC(pSmi)) {
	if (pSmi->MXCLK == 0) {
	    mxclk = ((clock.f.m1_select ? 336 : 288) /
		     ((clock.f.m1_divider ? 3 : 1) <<
		      (unsigned)clock.f.m1_shift)) * 1000;
	}
	else
	    mxclk = pSmi->MXCLK;
	xf86DrvMsg(pScrn->scrnIndex, X_INFO, "MXCLK = %1.3f\n", mxclk / 1000.0);
    }
}

static Bool
SMI_MapMmio(ScrnInfoPtr pScrn)
{
    SMIPtr	pSmi = SMIPTR(pScrn);
    CARD32	memBase;

    SMI_EnableMmio(pScrn);

    switch (pSmi->Chipset) {
	case SMI_COUGAR3DR:
	    memBase = PCI_REGION_BASE(pSmi->PciInfo, 1, REGION_MEM);
	    pSmi->MapSize = 0x200000;
	    break;
	case SMI_LYNX3D:
	    memBase = PCI_REGION_BASE(pSmi->PciInfo, 0, REGION_MEM) + 0x680000;
	    pSmi->MapSize = 0x180000;
	    break;
	case SMI_LYNXEM:
	case SMI_LYNXEMplus:
	    memBase = PCI_REGION_BASE(pSmi->PciInfo, 0, REGION_MEM) + 0x400000;
	    pSmi->MapSize = 0x400000;
	    break;
	case SMI_LYNX3DM:
	    memBase = PCI_REGION_BASE(pSmi->PciInfo, 0, REGION_MEM);
	    pSmi->MapSize = 0x200000;
	    break;
	case SMI_MSOC:
	    memBase = PCI_REGION_BASE(pSmi->PciInfo, 1, REGION_MEM);
	    pSmi->MapSize = 0x200000;
	    break;
	default:
	    memBase = PCI_REGION_BASE(pSmi->PciInfo, 0, REGION_MEM) + 0x400000;
	    pSmi->MapSize = 0x10000;
	    break;
    }

#ifndef XSERVER_LIBPCIACCESS
    pSmi->MapBase = xf86MapPciMem(pScrn->scrnIndex, VIDMEM_MMIO, pSmi->PciTag,
				  memBase, pSmi->MapSize);
#else
    {
	void	**result = (void**)&pSmi->MapBase;
	int	  err = pci_device_map_range(pSmi->PciInfo,
					     memBase,
					     pSmi->MapSize,
					     PCI_DEV_MAP_FLAG_WRITABLE,
					     result);

	if (err)
	    return (FALSE);
    }
#endif

    if (pSmi->MapBase == NULL) {
	xf86DrvMsg(pScrn->scrnIndex, X_ERROR, "Internal error: could not map "
		   "MMIO registers.\n");
	return (FALSE);
    }

    switch (pSmi->Chipset) {
	case SMI_COUGAR3DR:
	    pSmi->DPRBase = pSmi->MapBase + 0x000000;
	    pSmi->VPRBase = pSmi->MapBase + 0x000800;
	    pSmi->CPRBase = pSmi->MapBase + 0x001000;
	    pSmi->FPRBase = pSmi->MapBase + 0x005800;
	    pSmi->IOBase  = pSmi->MapBase + 0x0C0000;
	    pSmi->DataPortBase = pSmi->MapBase + 0x100000;
	    pSmi->DataPortSize = 0x100000;
	    break;
	case SMI_LYNX3D:
	    pSmi->DPRBase = pSmi->MapBase + 0x000000;
	    pSmi->VPRBase = pSmi->MapBase + 0x000800;
	    pSmi->CPRBase = pSmi->MapBase + 0x001000;
	    pSmi->IOBase  = pSmi->MapBase + 0x040000;
	    pSmi->DataPortBase = pSmi->MapBase + 0x080000;
	    pSmi->DataPortSize = 0x100000;
	    break;
	case SMI_LYNXEM:
	case SMI_LYNXEMplus:
	    pSmi->DPRBase = pSmi->MapBase + 0x008000;
	    pSmi->VPRBase = pSmi->MapBase + 0x00C000;
	    pSmi->CPRBase = pSmi->MapBase + 0x00E000;
	    pSmi->IOBase  = pSmi->MapBase + 0x300000;
	    pSmi->DataPortBase = pSmi->MapBase /*+ 0x100000*/;
	    pSmi->DataPortSize = 0x8000 /*0x200000*/;
	    break;
	case SMI_LYNX3DM:
	    pSmi->DPRBase = pSmi->MapBase + 0x000000;
	    pSmi->VPRBase = pSmi->MapBase + 0x000800;
	    pSmi->CPRBase = pSmi->MapBase + 0x001000;
	    pSmi->IOBase  = pSmi->MapBase + 0x0C0000;
	    pSmi->DataPortBase = pSmi->MapBase + 0x100000;
	    pSmi->DataPortSize = 0x100000;
	    break;
	case SMI_MSOC:
	    pSmi->DPRBase = pSmi->MapBase + 0x100000;
	    pSmi->VPRBase = pSmi->MapBase + 0x000000;
	    pSmi->CPRBase = pSmi->MapBase + 0x090000;
	    pSmi->DCRBase = pSmi->MapBase + 0x080000;
	    pSmi->SCRBase = pSmi->MapBase + 0x000000;
	    pSmi->IOBase = 0;
	    pSmi->DataPortBase = pSmi->MapBase + 0x110000;
	    pSmi->DataPortSize = 0x10000;
	    break;
	default:
	    pSmi->DPRBase = pSmi->MapBase + 0x8000;
	    pSmi->VPRBase = pSmi->MapBase + 0xC000;
	    pSmi->CPRBase = pSmi->MapBase + 0xE000;
	    pSmi->IOBase  = NULL;
	    pSmi->DataPortBase = pSmi->MapBase;
	    pSmi->DataPortSize = 0x8000;
	    break;
    }

    xf86DrvMsgVerb(pScrn->scrnIndex, X_INFO, VERBLEV,
		   "Physical MMIO at 0x%08lX\n", (unsigned long)memBase);
    xf86DrvMsgVerb(pScrn->scrnIndex, X_INFO, VERBLEV,
		   "Logical MMIO at %p - %p\n", pSmi->MapBase,
		   pSmi->MapBase + pSmi->MapSize - 1);
    xf86DrvMsgVerb(pScrn->scrnIndex, X_INFO, VERBLEV,
		   "DPR=%p, VPR=%p, IOBase=%p\n",
		   pSmi->DPRBase, pSmi->VPRBase, pSmi->IOBase);
    xf86DrvMsgVerb(pScrn->scrnIndex, X_INFO, VERBLEV,
		   "DataPort=%p - %p\n", pSmi->DataPortBase,
		   pSmi->DataPortBase + pSmi->DataPortSize - 1);

    return (TRUE);
}

/* HACK - In some cases the BIOS hasn't filled in the "scratchpad
   registers" (SR71) with the right amount of memory installed (e.g. MIPS
   platform). Probe it manually. */
static unsigned long
SMI_ProbeMem(ScrnInfoPtr pScrn, unsigned long mem_skip, unsigned long mem_max)
{
    SMIPtr pSmi = SMIPTR(pScrn);
    unsigned long mem_probe = 1024*1024;
    unsigned long aperture_base;
    void* mem;

    ENTER();

    aperture_base = PCI_REGION_BASE(pSmi->PciInfo, 0, REGION_MEM) + mem_skip;
    mem_max = min(mem_max , PCI_REGION_SIZE(pSmi->PciInfo, 0) - mem_skip);

#ifndef XSERVER_LIBPCIACCESS
    mem = xf86MapPciMem(pScrn->scrnIndex, VIDMEM_MMIO, pSmi->PciTag,
			aperture_base, mem_max);

    if(!mem)
	LEAVE(0);
#else
    if(pci_device_map_range(pSmi->PciInfo, aperture_base, mem_max,
			    PCI_DEV_MAP_FLAG_WRITABLE, &mem))
	LEAVE(0);
#endif

    while(mem_probe <= mem_max){
	MMIO_OUT32(mem, mem_probe-4, 0x55555555);
	if(MMIO_IN32(mem, mem_probe-4) != 0x55555555)
	    break;

	MMIO_OUT32(mem, mem_probe-4, 0xAAAAAAAA);
	if(MMIO_IN32(mem, mem_probe-4) != 0xAAAAAAAA)
	    break;

	mem_probe <<= 1;
    }

#ifndef XSERVER_LIBPCIACCESS
    xf86UnMapVidMem(pScrn->scrnIndex, mem, mem_max);
#else
    pci_device_unmap_range(pSmi->PciInfo, mem, mem_max);
#endif

    LEAVE(mem_probe >> 1);
}

static Bool
SMI_DetectMem(ScrnInfoPtr pScrn)
{
    SMIPtr	pSmi = SMIPTR(pScrn);
    MessageType from;

    if ((pScrn->videoRam = pScrn->confScreen->device->videoRam)){
	pSmi->videoRAMKBytes = pScrn->videoRam;
	from = X_CONFIG;
    }
    else {
	unsigned char	 config;
	static int	 lynx3d_table[4]  = {  0, 2, 4, 6 };
	static int	 lynx3dm_table[4] = { 16, 2, 4, 8 };
	static int	 msoc_table[8]    = {  4, 8, 16, 32, 64, 2, 0, 0 };
	static int	 default_table[4] = {  1, 2, 4, 0 };

	if (IS_MSOC(pSmi)) {
	    config = (READ_SCR(pSmi, DRAM_CTL) >> 13) & 7;
	    pSmi->videoRAMKBytes = msoc_table[config] * 1024 -
		SHARED_USB_DMA_BUFFER_SIZE;
	}
	else {
	    config = VGAIN8_INDEX(pSmi, VGA_SEQ_INDEX, VGA_SEQ_DATA, 0x71);
	    switch (pSmi->Chipset) {
		case SMI_LYNX3D:
		    pSmi->videoRAMKBytes = lynx3d_table[config >> 6] * 1024 +
			512;
		    break;
		case SMI_LYNXEMplus:
		    pSmi->videoRAMKBytes = SMI_ProbeMem(pScrn, 0, 0x400000) / 1024;
		    break;
		case SMI_LYNX3DM:
		    pSmi->videoRAMKBytes = lynx3dm_table[config >> 6] * 1024;
		    break;
		case SMI_COUGAR3DR:
		    /* DANGER - Cougar3DR BIOS is broken - hardcode video ram
		     * size per instructions from Silicon Motion engineers */
		    pSmi->videoRAMKBytes = 16 * 1024;
		    break;
		default:
		    pSmi->videoRAMKBytes = default_table[config >> 6] * 1024;
		    break;
	    }
	}
	from = X_PROBED;
    }

    pSmi->videoRAMBytes = pSmi->videoRAMKBytes * 1024;
    pScrn->videoRam     = pSmi->videoRAMKBytes;
    xf86DrvMsg(pScrn->scrnIndex, from,
	       "videoram: %dkB\n", pSmi->videoRAMKBytes);

    return (TRUE);
}

Bool
SMI_MapMem(ScrnInfoPtr pScrn)
{
    SMIPtr pSmi = SMIPTR(pScrn);
    vgaHWPtr hwp;

    ENTER();

    if (pSmi->MapBase == NULL && SMI_MapMmio(pScrn) == FALSE)
	LEAVE(FALSE);

    pScrn->memPhysBase = PCI_REGION_BASE(pSmi->PciInfo, 0, REGION_MEM);

    if (pSmi->Chipset == SMI_LYNX3DM)
	pSmi->fbMapOffset = 0x200000;
    else
	pSmi->fbMapOffset = 0x0;

#ifndef XSERVER_LIBPCIACCESS
    pSmi->FBBase = xf86MapPciMem(pScrn->scrnIndex,
				 VIDMEM_FRAMEBUFFER,
				 pSmi->PciTag,
				 pScrn->memPhysBase + pSmi->fbMapOffset,
				 pSmi->videoRAMBytes);
#else
    {
	void	**result = (void**)&pSmi->FBBase;
	int	  err = pci_device_map_range(pSmi->PciInfo,
					     pScrn->memPhysBase +
					     pSmi->fbMapOffset,
					     pSmi->videoRAMBytes,
					     PCI_DEV_MAP_FLAG_WRITABLE |
					     PCI_DEV_MAP_FLAG_WRITE_COMBINE,
					     result);

	if (err)
	    LEAVE(FALSE);
    }
#endif

    if (pSmi->FBBase == NULL) {
	xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
		   "Internal error: could not map framebuffer.\n");
	LEAVE(FALSE);
    }

    xf86DrvMsgVerb(pScrn->scrnIndex, X_INFO, VERBLEV,
		   "Physical frame buffer at 0x%08lX offset: 0x%08lX\n",
		   pScrn->memPhysBase, (unsigned long)pSmi->fbMapOffset);
    xf86DrvMsgVerb(pScrn->scrnIndex, X_INFO, VERBLEV,
		   "Logical frame buffer at %p - %p\n", pSmi->FBBase,
		   pSmi->FBBase + pSmi->videoRAMBytes - 1);

    if (IS_MSOC(pSmi)) {
	/* Reserve space for panel cursr, and crt if in dual head mode */
#if SMI_CURSOR_ALPHA_PLANE
	pSmi->FBReserved = pSmi->FBCursorOffset = pSmi->videoRAMBytes -
	    (pSmi->Dualhead ? SMI501_CURSOR_SIZE << 1 : SMI501_ARGB_CURSOR_SIZE);
#else
	pSmi->FBReserved = pSmi->FBCursorOffset = pSmi->videoRAMBytes -
	    (pSmi->Dualhead ? SMI501_CURSOR_SIZE << 1 : SMI501_CURSOR_SIZE);

# if SMI501_CLI_DEBUG
	if (pSmi->useEXA) {
	    pSmi->batch_active = FALSE;
	    pSmi->batch_length = 4096;
	    pSmi->FBReserved -= pSmi->batch_length << 3;
	    pSmi->batch_offset = pSmi->FBReserved;
	    pSmi->batch_handle = (int64_t *)(pSmi->FBBase + pSmi->batch_offset);
	    pSmi->batch_finish = -1;
	    pSmi->batch_index = 0;
	    xf86DrvMsg(pScrn->scrnIndex, X_INFO,
		       "Using command list interpreter debug code\n");
	}
# endif

#endif
    }
    else {
	/* Set up offset to hwcursor memory area, at the end of
	 * the frame buffer.
	 */
	pSmi->FBCursorOffset = pSmi->videoRAMBytes - SMILYNX_CURSOR_SIZE;
	/* set up the fifo reserved space */
	if (VGAIN8_INDEX(pSmi, VGA_SEQ_INDEX, VGA_SEQ_DATA, 0x30) & 0x01)/* #1074 */ {
	    CARD32 fifoOffset = 0;
	    fifoOffset |= VGAIN8_INDEX(pSmi, VGA_SEQ_INDEX, VGA_SEQ_DATA,
				       0x46) << 3;
	    fifoOffset |= VGAIN8_INDEX(pSmi, VGA_SEQ_INDEX, VGA_SEQ_DATA,
				       0x47) << 11;
	    fifoOffset |= (VGAIN8_INDEX(pSmi, VGA_SEQ_INDEX, VGA_SEQ_DATA,
					0x49) & 0x1C) << 17;
	    pSmi->FBReserved = fifoOffset;	/* PDR#1074 */
	}
	else
	    pSmi->FBReserved = pSmi->videoRAMBytes - 2048;

	xf86DrvMsg(pScrn->scrnIndex, X_INFO, "Cursor Offset: %08lX\n",
		   (unsigned long)pSmi->FBCursorOffset);

	/* Assign hwp->MemBase & IOBase here */
	hwp = VGAHWPTR(pScrn);
	if (pSmi->IOBase != NULL)
	    vgaHWSetMmioFuncs(hwp, pSmi->MapBase, pSmi->IOBase - pSmi->MapBase);
	vgaHWGetIOBase(hwp);

	/* Map the VGA memory when the primary video */
	if (xf86IsPrimaryPci(pSmi->PciInfo)) {
	    hwp->MapSize = 0x10000;
	    if (!vgaHWMapMem(pScrn))
		LEAVE(FALSE);
	    pSmi->PrimaryVidMapped = TRUE;
	}
    }

    xf86DrvMsg(pScrn->scrnIndex, X_INFO, "Reserved: %08lX\n",
	       (unsigned long)pSmi->FBReserved);

    LEAVE(TRUE);
}

/* UnMapMem - contains half of pre-4.0 EnterLeave function.  The EnterLeave
 * function which en/disable access to IO ports and ext. regs
 */

void
SMI_UnmapMem(ScrnInfoPtr pScrn)
{
    SMIPtr pSmi = SMIPTR(pScrn);

    ENTER();

    /* Unmap VGA mem if mapped. */
    if (pSmi->PrimaryVidMapped) {
	vgaHWUnmapMem(pScrn);
	pSmi->PrimaryVidMapped = FALSE;
    }

    SMI_DisableMmio(pScrn);

    if (pSmi->MapBase) {
#ifndef XSERVER_LIBPCIACCESS
	xf86UnMapVidMem(pScrn->scrnIndex, (pointer)pSmi->MapBase,
			pSmi->MapSize);
#else
	pci_device_unmap_range(pSmi->PciInfo, (pointer)pSmi->MapBase,
			       pSmi->MapSize);
#endif
	pSmi->MapBase = NULL;
    }

    if (pSmi->FBBase) {
#ifndef XSERVER_LIBPCIACCESS
	xf86UnMapVidMem(pScrn->scrnIndex, (pointer) pSmi->FBBase,
			pSmi->videoRAMBytes);
#else
	pci_device_unmap_range(pSmi->PciInfo, (pointer)pSmi->FBBase,
			       pSmi->videoRAMBytes);
#endif
	pSmi->FBBase = NULL;
    }

    LEAVE();
}

/* This gets called at the start of each server generation. */

static Bool
SMI_ScreenInit(SCREEN_INIT_ARGS_DECL)
{
    ScrnInfoPtr		pScrn = xf86ScreenToScrn(pScreen);
    SMIPtr		pSmi = SMIPTR(pScrn);
    EntityInfoPtr	pEnt;
	
    ENTER();

    /* Map MMIO regs and framebuffer */
    if (!SMI_MapMem(pScrn))
	LEAVE(FALSE);

    pEnt = xf86GetEntityInfo(pScrn->entityList[0]);

    if (!pSmi->pInt10 && pSmi->useBIOS) {
	pSmi->pInt10 = xf86InitInt10(pEnt->index);
    }
    if (!pSmi->pVbe && pSmi->pInt10 && xf86LoaderCheckSymbol("VBEInit")) {
	pSmi->pVbe = VBEInit(pSmi->pInt10, pEnt->index);
    }

    /* Save the chip/graphics state */
    pSmi->Save(pScrn);

    /* Fill in some needed pScrn fields */
    pScrn->vtSema = TRUE;
    pScrn->pScreen = pScreen;

    pScrn->displayWidth = ((pScrn->virtualX * pSmi->Bpp + 15) & ~15) / pSmi->Bpp;

    pSmi->fbArea = NULL;
    pSmi->FBOffset = 0;
    pScrn->fbOffset = pSmi->FBOffset + pSmi->fbMapOffset;

    /* Clear frame buffer */
    memset(pSmi->FBBase, 0, pSmi->videoRAMBytes);

    /*
     * The next step is to setup the screen's visuals, and initialise the
     * framebuffer code.  In cases where the framebuffer's default choises for
     * things like visual layouts and bits per RGB are OK, this may be as simple
     * as calling the framebuffer's ScreenInit() function.  If not, the visuals
     * will need to be setup before calling a fb ScreenInit() function and fixed
     * up after.
     */

    /*
     * Reset the visual list.
     */
    miClearVisualTypes();

    /* Setup the visuals we support. */

    if (!miSetVisualTypes(pScrn->depth, miGetDefaultVisualMask(pScrn->depth),
			  pScrn->rgbBits, pScrn->defaultVisual))
	LEAVE(FALSE);

    if (!miSetPixmapDepths ())
	LEAVE(FALSE);

    /*
     * Call the framebuffer layer's ScreenInit function
     */

    DEBUG("\tInitializing FB @@ 0x%08X for %dx%d (%d)\n",
	  pSmi->FBBase, pScrn->virtualX, pScrn->virtualY, pScrn->displayWidth);
    if(!fbScreenInit(pScreen, pSmi->FBBase, pScrn->virtualX, pScrn->virtualY, pScrn->xDpi,
		     pScrn->yDpi, pScrn->displayWidth, pScrn->bitsPerPixel))
	LEAVE(FALSE);

    xf86SetBlackWhitePixels(pScreen);

    if (pScrn->bitsPerPixel > 8) {
	VisualPtr visual;
	/* Fixup RGB ordering */
	visual = pScreen->visuals + pScreen->numVisuals;
	while (--visual >= pScreen->visuals) {
	    if ((visual->class | DynamicClass) == DirectColor) {
		visual->offsetRed   = pScrn->offset.red;
		visual->offsetGreen = pScrn->offset.green;
		visual->offsetBlue  = pScrn->offset.blue;
		visual->redMask     = pScrn->mask.red;
		visual->greenMask   = pScrn->mask.green;
		visual->blueMask    = pScrn->mask.blue;
	    }
	}
    }

    /* must be after RGB ordering fixed */
    fbPictureInit(pScreen, 0, 0);
 
    /* Do the CRTC independent initialization */
    if(!SMI_HWInit(pScrn))
	LEAVE(FALSE);

    /* Unless using EXA, regardless or using XAA or not, needs offscreen
     * management at least for video. */
    if (pSmi->NoAccel || !pSmi->useEXA) {
	int		numLines;
	BoxRec		AvailFBArea;

	numLines = pSmi->FBReserved / (pScrn->displayWidth * pSmi->Bpp);
	AvailFBArea.x1 = 0;
	AvailFBArea.y1 = 0;
	AvailFBArea.x2 = pScrn->virtualX;
	AvailFBArea.y2 = numLines;

	xf86DrvMsg(pScrn->scrnIndex, X_INFO,
		   "FrameBuffer Box: %d,%d - %d,%d\n",
		   AvailFBArea.x1, AvailFBArea.y1, AvailFBArea.x2,
		   AvailFBArea.y2);

	xf86InitFBManager(pScreen, &AvailFBArea);
    }

    /* Initialize acceleration layer */
    if (!pSmi->NoAccel) {
	if (pSmi->useEXA && !SMI_EXAInit(pScreen))
	    LEAVE(FALSE);
	else if (!pSmi->useEXA && !SMI_XAAInit(pScreen))
	    LEAVE(FALSE);
    }

    /* Initialize the chosen modes */
    if (!xf86SetDesiredModes(pScrn))
	    LEAVE(FALSE);

    xf86DrvMsgVerb(pScrn->scrnIndex, X_INFO, VERBLEV,
		   "Done writing mode.  Register dump:\n");
    SMI_PrintRegs(pScrn);

#ifdef HAVE_XMODES
    xf86DiDGAInit(pScreen, (unsigned long)(pSmi->FBBase + pScrn->fbOffset));
#endif

    /* Initialise cursor functions */
    miDCInitialize(pScreen, xf86GetPointerScreenFuncs());

    /* Initialize HW cursor layer.  Must follow software cursor
     * initialization.
     */
    if (pSmi->HwCursor) {
	int	size, flags;

	if (IS_MSOC(pSmi)) {
	    size = SMI501_MAX_CURSOR;
	    flags = (HARDWARE_CURSOR_SOURCE_MASK_INTERLEAVE_1 |
		     HARDWARE_CURSOR_SWAP_SOURCE_AND_MASK);
#if SMI_CURSOR_ALPHA_PLANE
	    if (!pSmi->Dualhead)
		flags |= HARDWARE_CURSOR_ARGB;
#endif
	}
	else {
	    size = SMILYNX_MAX_CURSOR;
	    flags = (HARDWARE_CURSOR_SOURCE_MASK_INTERLEAVE_8 |
		     HARDWARE_CURSOR_SWAP_SOURCE_AND_MASK |
		     HARDWARE_CURSOR_AND_SOURCE_WITH_MASK |
		     HARDWARE_CURSOR_BIT_ORDER_MSBFIRST |
		     HARDWARE_CURSOR_TRUECOLOR_AT_8BPP |
		     HARDWARE_CURSOR_INVERT_MASK);
	}

	if (!xf86_cursors_init(pScreen, size, size, flags))
	    xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
		       "Hardware cursor initialization failed\n");
    }

    /* Initialise default colormap */
    if (!miCreateDefColormap(pScreen))
	LEAVE(FALSE);

    /* Initialize colormap layer.  Must follow initialization of the default
     * colormap.  And SetGamma call, else it will load palette with solid white.
     */
    if (!xf86HandleColormaps(pScreen, 256, pScrn->rgbBits,SMI_LoadPalette, NULL,
			     CMAP_RELOAD_ON_MODE_SWITCH | CMAP_PALETTED_TRUECOLOR))
	LEAVE(FALSE);

    pScreen->SaveScreen = SMI_SaveScreen;
    pSmi->CloseScreen = pScreen->CloseScreen;
    pScreen->CloseScreen = SMI_CloseScreen;

    if ((IS_MSOC(pSmi) &&
	 !xf86DPMSInit(pScreen, SMI501_DisplayPowerManagementSet, 0)) ||
	(!IS_MSOC(pSmi) &&
	 !xf86DPMSInit(pScreen, SMILynx_DisplayPowerManagementSet, 0)))
	xf86DrvMsg(pScrn->scrnIndex, X_ERROR, "DPMS initialization failed!\n");

    SMI_InitVideo(pScreen);

    if(!xf86CrtcScreenInit(pScreen))
	LEAVE(FALSE);

    /* Report any unused options (only for the first generation) */
    if (serverGeneration == 1) {
	xf86ShowUnusedOptions(pScrn->scrnIndex, pScrn->options);
    }

    LEAVE(TRUE);
}

/*
 * This is called at the end of each server generation.  It restores the
 * original (text) mode.  It should also unmap the video memory, and free any
 * per-generation data allocated by the driver.  It should finish by unwrapping
 * and calling the saved CloseScreen function.
 */

static Bool
SMI_CloseScreen(CLOSE_SCREEN_ARGS_DECL)
{
    ScrnInfoPtr	pScrn = xf86ScreenToScrn(pScreen);
    SMIPtr	pSmi = SMIPTR(pScrn);
    Bool	ret;
	
    ENTER();

    if (pSmi->HwCursor)
	xf86_cursors_fini(pScreen);

    if (pScrn->vtSema)
	/* Restore console mode and unmap framebuffer */
        SMI_LeaveVT(VT_FUNC_ARGS);

#ifdef HAVE_XAA_H
    if (pSmi->XAAInfoRec != NULL) {
	XAADestroyInfoRec(pSmi->XAAInfoRec);
    }
#endif
    if (pSmi->EXADriverPtr) {
	exaDriverFini(pScreen);
	pSmi->EXADriverPtr = NULL;
    }
    if (pSmi->pVbe != NULL) {
	vbeFree(pSmi->pVbe);
	pSmi->pVbe = NULL;
    }
    if (pSmi->pInt10 != NULL) {
	xf86FreeInt10(pSmi->pInt10);
	pSmi->pInt10 = NULL;
    }
    if (pSmi->ptrAdaptor != NULL) {
	free(pSmi->ptrAdaptor);
    }
    if (pSmi->BlockHandler != NULL) {
	pScreen->BlockHandler = pSmi->BlockHandler;
    }

    pScrn->vtSema = FALSE;
    pScreen->CloseScreen = pSmi->CloseScreen;
    ret = (*pScreen->CloseScreen)(CLOSE_SCREEN_ARGS);

    LEAVE(ret);
}

static void
SMI_FreeScreen(FREE_SCREEN_ARGS_DECL)
{
    SCRN_INFO_PTR(arg);
    SMI_FreeRec(pScrn);
}

static Bool
SMI_SaveScreen(ScreenPtr pScreen, int mode)
{
    ScrnInfoPtr pScrn = xf86ScreenToScrn(pScreen);

    ENTER();

    if(xf86IsUnblank(mode)){
	pScrn->DPMSSet(pScrn, DPMSModeOn, 0);
    }else{
	pScrn->DPMSSet(pScrn, DPMSModeOff, 0);
    }

    LEAVE(TRUE);
}

void
SMI_AdjustFrame(ADJUST_FRAME_ARGS_DECL)
{
    SCRN_INFO_PTR(arg);
    xf86CrtcConfigPtr crtcConf = XF86_CRTC_CONFIG_PTR(pScrn);
    xf86CrtcPtr compat_crtc = crtcConf->output[crtcConf->compat_output]->crtc;

    ENTER();

    SMICRTC(compat_crtc)->adjust_frame(compat_crtc,x,y);

    LEAVE();
}

Bool
SMI_SwitchMode(SWITCH_MODE_ARGS_DECL)
{
    Bool ret;
    SCRN_INFO_PTR(arg);
    SMIPtr pSmi = SMIPTR(pScrn);

    ENTER();

    ret = xf86SetSingleMode(pScrn, mode, RR_Rotate_0);

    if (!pSmi->NoAccel)
	SMI_EngineReset(pScrn);

    LEAVE(ret);
}

void
SMI_LoadPalette(ScrnInfoPtr pScrn, int numColors, int *indicies,
		LOCO *colors, VisualPtr pVisual)
{
    xf86CrtcConfigPtr crtcConf = XF86_CRTC_CONFIG_PTR(pScrn);
    int crtc_idx,i,j;

    ENTER();

    if(pScrn->bitsPerPixel == 16){
	/* Expand the RGB 565 palette into the 256-elements LUT */

	for(crtc_idx=0; crtc_idx<crtcConf->num_crtc; crtc_idx++){
	    SMICrtcPrivatePtr crtcPriv = SMICRTC(crtcConf->crtc[crtc_idx]);

	    for(i=0; i<numColors; i++){
		int idx = indicies[i];

		if(idx<32){
		    for(j=0; j<8; j++){
			crtcPriv->lut_r[idx*8 + j] = colors[idx].red << 8;
			crtcPriv->lut_b[idx*8 + j] = colors[idx].blue << 8;
		    }
		}

		for(j=0; j<4; j++)
		    crtcPriv->lut_g[idx*4 + j] = colors[idx].green << 8;
	    }

	    crtcPriv->load_lut(crtcConf->crtc[crtc_idx]);
    }
    }else{
	for(crtc_idx=0; crtc_idx<crtcConf->num_crtc; crtc_idx++){
	    SMICrtcPrivatePtr crtcPriv = SMICRTC(crtcConf->crtc[crtc_idx]);

    for(i = 0; i < numColors; i++) {
		int idx = indicies[i];

		crtcPriv->lut_r[idx] = colors[idx].red << 8;
		crtcPriv->lut_g[idx] = colors[idx].green << 8;
		crtcPriv->lut_b[idx] = colors[idx].blue << 8;
	    }

	    crtcPriv->load_lut(crtcConf->crtc[crtc_idx]);
	}
    }

    LEAVE();
}

static void
SMI_DisableVideo(ScrnInfoPtr pScrn)
{
    SMIPtr pSmi = SMIPTR(pScrn);
    CARD8 tmp;

    if (!IS_MSOC(pSmi)) {
	if (!(tmp = VGAIN8(pSmi, VGA_DAC_MASK)))
	    return;
	pSmi->DACmask = tmp;
	VGAOUT8(pSmi, VGA_DAC_MASK, 0);
    }
}

static void
SMI_EnableVideo(ScrnInfoPtr pScrn)
{
    SMIPtr pSmi = SMIPTR(pScrn);

    if (!IS_MSOC(pSmi)) {
	VGAOUT8(pSmi, VGA_DAC_MASK, pSmi->DACmask);
    }
}


void
SMI_EnableMmio(ScrnInfoPtr pScrn)
{
    SMIPtr pSmi = SMIPTR(pScrn);

    ENTER();

    if (!IS_MSOC(pSmi)) {
	vgaHWPtr hwp = VGAHWPTR(pScrn);
	CARD8 tmp;

	/*
	 * Enable chipset (seen on uninitialized secondary cards) might not be
	 * needed once we use the VGA softbooter
	 */
	vgaHWSetStdFuncs(hwp);

	/* Enable linear mode */
	outb(pSmi->PIOBase + VGA_SEQ_INDEX, 0x18);
	tmp = inb(pSmi->PIOBase + VGA_SEQ_DATA);
	pSmi->SR18Value = tmp;					/* PDR#521 */
	outb(pSmi->PIOBase + VGA_SEQ_DATA, tmp | 0x11);

	/* Enable 2D/3D Engine and Video Processor */
	outb(pSmi->PIOBase + VGA_SEQ_INDEX, 0x21);
	tmp = inb(pSmi->PIOBase + VGA_SEQ_DATA);
	pSmi->SR21Value = tmp;					/* PDR#521 */
	outb(pSmi->PIOBase + VGA_SEQ_DATA, tmp & ~0x03);
    }

    LEAVE();
}

void
SMI_DisableMmio(ScrnInfoPtr pScrn)
{
    SMIPtr pSmi = SMIPTR(pScrn);

    ENTER();

    if (!IS_MSOC(pSmi)) {
	vgaHWPtr hwp = VGAHWPTR(pScrn);

	vgaHWSetStdFuncs(hwp);

	/* Disable 2D/3D Engine and Video Processor */
	outb(pSmi->PIOBase + VGA_SEQ_INDEX, 0x21);
	outb(pSmi->PIOBase + VGA_SEQ_DATA, pSmi->SR21Value);	/* PDR#521 */

	/* Disable linear mode */
	outb(pSmi->PIOBase + VGA_SEQ_INDEX, 0x18);
	outb(pSmi->PIOBase + VGA_SEQ_DATA, pSmi->SR18Value);	/* PDR#521 */
    }

    LEAVE();
}

static void
SMI_ProbeDDC(ScrnInfoPtr pScrn, int index)
{
    vbeInfoPtr pVbe;
    if (xf86LoadSubModule(pScrn, "vbe")) {
	pVbe = VBEInit(NULL, index);
	ConfiguredMonitor = vbeDoEDID(pVbe, NULL);
	vbeFree(pVbe);
    }
}

static Bool
SMI_HWInit(ScrnInfoPtr pScrn)
{
    SMIPtr pSmi = SMIPTR(pScrn);

    ENTER();

    if(IS_MSOC(pSmi))
	LEAVE(SMI501_HWInit(pScrn));
    else
	LEAVE(SMILynx_HWInit(pScrn));
}

void
SMI_PrintRegs(ScrnInfoPtr pScrn)
{
    SMIPtr pSmi = SMIPTR(pScrn);
    int i;

    ENTER();

    xf86DrvMsgVerb(pScrn->scrnIndex, X_INFO, VERBLEV,
		"START register dump ------------------\n");

    if(IS_MSOC(pSmi))
	SMI501_PrintRegs(pScrn);
    else
	SMILynx_PrintRegs(pScrn);


    xf86ErrorFVerb(VERBLEV, "\n\nDPR    x0       x4       x8       xC");
    for (i = 0x00; i <= 0x44; i += 4) {
	if ((i & 0xF) == 0x0) xf86ErrorFVerb(VERBLEV, "\n%02X|", i);
	xf86ErrorFVerb(VERBLEV, " %08lX", (unsigned long)READ_DPR(pSmi, i));
    }

    xf86ErrorFVerb(VERBLEV, "\n\nVPR    x0       x4       x8       xC");
    for (i = 0x00; i <= 0x60; i += 4) {
	if ((i & 0xF) == 0x0) xf86ErrorFVerb(VERBLEV, "\n%02X|", i);
	xf86ErrorFVerb(VERBLEV, " %08lX", (unsigned long)READ_VPR(pSmi, i));
    }

    xf86ErrorFVerb(VERBLEV, "\n\nCPR    x0       x4       x8       xC");
    for (i = 0x00; i <= 0x18; i += 4) {
	if ((i & 0xF) == 0x0) xf86ErrorFVerb(VERBLEV, "\n%02X|", i);
	xf86ErrorFVerb(VERBLEV, " %08lX", (unsigned long)READ_CPR(pSmi, i));
    }

    xf86ErrorFVerb(VERBLEV, "\n\n");
    xf86DrvMsgVerb(pScrn->scrnIndex, X_INFO, VERBLEV,
		"END register dump --------------------\n");

    LEAVE();
}
@


1.10
log
@Update xf86-video-siliconmotion to 1.7.8
@
text
@d490 1
a490 1
#if __BYTE_ORDER == __BIG_ENDIAN
@


1.9
log
@Remove calls to miInitializeBackingStore() and includes of mibstore.h

mibstore.h defines miInitializeBackingStore() as an empty stub, and
goes away in xserver 1.14.
@
text
@d1005 1
a1005 1
    char	*s;
d1902 1
a1902 1
SMI_AdjustFrame(int scrnIndex, int x, int y, int flags)
d1904 2
a1905 1
    xf86CrtcConfigPtr crtcConf = XF86_CRTC_CONFIG_PTR(xf86Screens[scrnIndex]);
d1916 1
a1916 1
SMI_SwitchMode(int scrnIndex, DisplayModePtr mode, int flags)
d1919 1
a1919 1
    ScrnInfoPtr pScrn = xf86Screens[scrnIndex];
@


1.8
log
@Update to xf86-video-siliconmotion 1.7.7
@
text
@a1752 2
    miInitializeBackingStore(pScreen);

@


1.7
log
@Update to xf86-video siliconmotion 1.7.6
@
text
@d75 3
a77 4
static Bool SMI_EnterVT(int scrnIndex, int flags);
static void SMI_LeaveVT(int scrnIndex, int flags);
static Bool SMI_ScreenInit(int scrnIndex, ScreenPtr pScreen, int argc,
                           char **argv);
d80 1
a80 1
static Bool SMI_CloseScreen(int scrnIndex, ScreenPtr pScreen);
d82 1
a82 1
static void SMI_FreeScreen(int ScrnIndex, int flags);
d919 1
a919 1
SMI_EnterVT(int scrnIndex, int flags)
d921 1
a921 1
    ScrnInfoPtr pScrn = xf86Screens[scrnIndex];
d967 1
a967 1
SMI_LeaveVT(int scrnIndex, int flags)
d969 1
a969 1
    ScrnInfoPtr	pScrn = xf86Screens[scrnIndex];
d1622 1
a1622 1
SMI_ScreenInit(int scrnIndex, ScreenPtr pScreen, int argc, char **argv)
d1624 1
a1624 1
    ScrnInfoPtr		pScrn = xf86Screens[pScreen->myNum];
d1834 1
a1834 1
SMI_CloseScreen(int scrnIndex, ScreenPtr pScreen)
d1836 1
a1836 1
    ScrnInfoPtr	pScrn = xf86Screens[scrnIndex];
d1847 1
a1847 1
	SMI_LeaveVT(scrnIndex, 0);
d1849 1
d1853 1
d1875 1
a1875 1
    ret = (*pScreen->CloseScreen)(scrnIndex, pScreen);
d1881 1
a1881 1
SMI_FreeScreen(int scrnIndex, int flags)
d1883 2
a1884 1
    SMI_FreeRec(xf86Screens[scrnIndex]);
d1890 1
a1890 1
    ScrnInfoPtr pScrn = xf86Screens[pScreen->myNum];
@


1.6
log
@Update to xf86-video-siliconmotion 1.7.5
@
text
@d445 2
d448 3
d883 2
a884 2
		SMI_FreeRec(pScrn);
		LEAVE(FALSE);
@


1.5
log
@Update to xf86-video-siliconmotion 1.7.3
@
text
@d284 3
a286 3
	xfree(pSmi->save);
	xfree(pSmi->mode);
	xfree(pScrn->driverPrivate);
d341 1
a341 1
    xfree(devSections);
d367 1
a367 1
		    xfree(pEnt);
d374 1
a374 1
    xfree(usedChips);
d424 1
a424 1
	xfree(pEnt);
d522 1
a522 1
    if (!(pSmi->Options = xalloc(sizeof(SMIOptions))))
d665 1
a665 1
    xfree(pEnt);
d930 1
d932 1
d1498 1
a1498 1
		   pScrn->memPhysBase, pSmi->fbMapOffset);
d1861 1
a1861 1
	xfree(pSmi->ptrAdaptor);
@


1.4
log
@update to xf86-video-siliconmotion 1.7.1.
@
text
@d34 1
a34 2
#include "xf86Resources.h"
#include "xf86RAC.h"
d39 5
d50 3
d55 2
a201 98
/*
 * Lists of symbols that may/may not be required by this driver.
 * This allows the loader to know which ones to issue warnings for.
 *
 * Note that vgahwSymbols and xaaSymbols are referenced outside the
 * XFree86LOADER define in later code, so are defined outside of that
 * define here also.
 */

static const char *vgahwSymbols[] =
{
    "vgaHWCopyReg",
    "vgaHWGetHWRec",
    "vgaHWGetIOBase",
    "vgaHWGetIndex",
    "vgaHWInit",
    "vgaHWLock",
    "vgaHWMapMem",
    "vgaHWProtect",
    "vgaHWRestore",
    "vgaHWSave",
    "vgaHWSaveScreen",
    "vgaHWSetMmioFuncs",
    "vgaHWSetStdFuncs",
    "vgaHWUnmapMem",
    "vgaHWddc1SetSpeedWeak",
    NULL
};

static const char *xaaSymbols[] =
{
    "XAAGetCopyROP",
    "XAACreateInfoRec",
    "XAADestroyInfoRec",
    "XAAGetFallbackOps",
    "XAAInit",
    "XAAGetPatternROP",
    NULL
};

static const char *exaSymbols[] =
{
    "exaDriverAlloc",
    "exaDriverInit",
    "exaDriverFini",
    "exaOffscreenAlloc",
    "exaOffscreenFree",
    "exaGetPixmapPitch",
    "exaGetPixmapOffset",
    "exaGetPixmapSize",
    NULL
};

static const char *ddcSymbols[] =
{
    "xf86PrintEDID",
    "xf86DoEDID_DDC1",
    "xf86DoEDID_DDC2",
    "xf86SetDDCproperties",
    NULL
};

static const char *i2cSymbols[] =
{
    "xf86CreateI2CBusRec",
    "xf86CreateI2CDevRec",
    "xf86DestroyI2CBusRec",
    "xf86DestroyI2CDevRec",
    "xf86I2CBusInit",
    "xf86I2CDevInit",
    "xf86I2CReadBytes",
    "xf86I2CWriteByte",
    NULL
};

static const char *int10Symbols[] =
{
    "xf86ExecX86int10",
    "xf86FreeInt10",
    "xf86InitInt10",
    NULL
};

static const char *vbeSymbols[] =
{
    "VBEInit",
    "vbeDoEDID",
    "vbeFree",
    NULL
};

static const char *fbSymbols[] =
{
    "fbPictureInit",
    "fbScreenInit",
    NULL
};

a243 13
	 * Modules that this driver always requires can be loaded here
	 * by calling LoadSubModule().
	 */

	/*
	 * Tell the loader about symbols from other modules that this module
	 * might refer to.
	 */
	LoaderRefSymLists(vgahwSymbols, fbSymbols, xaaSymbols, exaSymbols,
					  ddcSymbols, i2cSymbols, int10Symbols, vbeSymbols,
					  NULL);

	/*
d423 1
a423 1
    if (pEnt->location.type != BUS_PCI || pEnt->resources) {
a437 2
	xf86LoaderReqSymLists(vgahwSymbols, NULL);

d477 2
a619 1
	    xf86LoaderReqSymLists(int10Symbols,NULL);
a623 1
	    xf86LoaderReqSymLists(vbeSymbols, NULL);
d633 1
d635 1
a635 3
/*  xf86SetOperatingState(resVgaIo, pEnt->index, ResUnusedOpr); */
/*  xf86SetOperatingState(resVgaMem, pEnt->index, ResDisableOpr); */

a785 1
	    xf86LoaderReqSymLists(i2cSymbols, NULL);
d788 1
a788 3
	if (xf86LoadSubModule(pScrn, "ddc")) {
	    xf86LoaderReqSymLists(ddcSymbols, NULL);
	}
d832 3
d838 15
a873 2
    xf86LoaderReqSymLists(fbSymbols, NULL);

a880 1
	    xf86LoaderReqSymLists(xaaSymbols, NULL);
a894 1
	    xf86LoaderReqSymLists(exaSymbols, NULL);
a1138 2
    }else
	pSmi->MCLK = 0;
d1140 14
a1153 1
    pSmi->MXCLK = 0;
d1343 49
d1421 3
a1643 1
    pSmi->Bpp = pScrn->bitsPerPixel >> 3;
@


1.3
log
@Update to xf86-video-siliconmotion 1.7.0.

Tested by ratchov@@. It works a bit better than previous version on his
machine, but still has issues.
@
text
@d795 6
a800 1
    pSmi->Dualhead = FALSE;
a801 1
    from = X_DEFAULT;
d921 1
a921 2
    if (pSmi->Chipset == SMI_LYNX3DM ||
	pSmi->Chipset == SMI_COUGAR3DR ||
d1541 1
a1541 1
# ifdef SMI501_CLI_DEBUG
@


1.2
log
@update to xf86-video-siliconmotion 1.6.0
@
text
@a38 1
#include "shadowfb.h"
d41 3
d52 2
d56 1
a67 2
static void SMI_Save (ScrnInfoPtr pScrn);
static void SMI_WriteMode (ScrnInfoPtr pScrn, vgaRegPtr, SMIRegPtr);
a69 4
static int SMI_InternalScreenInit(int scrnIndex, ScreenPtr pScreen);
static void SMI_PrintRegs(ScrnInfoPtr);
static ModeStatus SMI_ValidMode(int scrnIndex, DisplayModePtr mode,
                                Bool verbose, int flags);
a71 3
static Bool SMI_MapMem(ScrnInfoPtr pScrn);
static void SMI_UnmapMem(ScrnInfoPtr pScrn);
static Bool SMI_ModeInit(ScrnInfoPtr pScrn, DisplayModePtr mode);
a73 6
static void SMI_LoadPalette(ScrnInfoPtr pScrn, int numColors, int *indicies,
                            LOCO *colors, VisualPtr pVisual);
static void SMI_DisplayPowerManagementSet(ScrnInfoPtr pScrn,
                                          int PowerManagementMode, int flags);
static Bool SMI_ddc1(int scrnIndex);
static unsigned int SMI_ddc1Read(ScrnInfoPtr pScrn);
d77 1
d79 5
a83 2

#define SILICONMOTION_NAME          "Silicon Motion"
d93 7
d129 1
d135 1
a135 1
    /* numChipset,		PciID,				Resource */
d143 2
a144 1
    { -1,				-1,					RES_UNDEFINED  }
a149 3
    OPTION_FIFO_CONSERV,
    OPTION_FIFO_MODERATE,
    OPTION_FIFO_AGGRESSIVE,
d153 1
a153 1
    OPTION_SHOWCACHE,
a155 2
    OPTION_SHADOW_FB,
    OPTION_ROTATE,
a161 1
    OPTION_ZOOMONLCD,
d164 3
d172 2
a173 5
    { OPTION_PCI_BURST,	     "pci_burst",	  OPTV_BOOLEAN, {0}, FALSE },
    { OPTION_FIFO_CONSERV,    "fifo_conservative", OPTV_BOOLEAN, {0}, FALSE },
    { OPTION_FIFO_MODERATE,   "fifo_moderate",	  OPTV_BOOLEAN, {0}, FALSE },
    { OPTION_FIFO_AGGRESSIVE, "fifo_aggressive",	  OPTV_BOOLEAN, {0}, FALSE },
    { OPTION_PCI_RETRY,	     "pci_retry",	  OPTV_BOOLEAN, {0}, FALSE },
d175 3
a177 3
    { OPTION_MCLK,	     "set_mclk",	  OPTV_FREQ,	{0}, FALSE },
    { OPTION_SHOWCACHE,	     "show_cache",	  OPTV_BOOLEAN, {0}, FALSE },
    { OPTION_HWCURSOR,	     "HWCursor",	  OPTV_BOOLEAN, {0}, FALSE },
a178 2
    { OPTION_SHADOW_FB,	     "ShadowFB",	  OPTV_BOOLEAN, {0}, FALSE },
    { OPTION_ROTATE,	     "Rotate",		  OPTV_ANYSTR,  {0}, FALSE },
d182 1
a182 1
    { OPTION_INTERLACED,	     "Interlaced",        OPTV_BOOLEAN, {0}, FALSE },
d185 1
a185 2
    { OPTION_ZOOMONLCD,	     "ZoomOnLCD",	  OPTV_BOOLEAN,	{0}, FALSE },
    { OPTION_DUALHEAD,	     "Dualhead",	  OPTV_BOOLEAN,	{0}, FALSE },
d187 3
a245 8
static const char *ramdacSymbols[] =
{
    "xf86CreateCursorInfoRec",
    "xf86DestroyCursorInfoRec",
    "xf86InitCursor",
    NULL
};

a267 6
static const char *shadowSymbols[] =
{
    "ShadowFBInit",
    NULL
};

d341 1
a341 1
	LoaderRefSymLists(vgahwSymbols, fbSymbols, xaaSymbols, exaSymbols, ramdacSymbols,
d343 1
a343 1
					  shadowSymbols, NULL);
d364 1
a364 1
    ENTER_PROC("SMI_GetRec");
d375 1
a375 2
    LEAVE_PROC("SMI_GetRec");
    return TRUE;
d381 1
a381 1
    ENTER_PROC("SMI_FreeRec");
d383 5
a387 1
    if (pScrn->driverPrivate != NULL) {
d392 1
a392 1
    LEAVE_PROC("SMI_FreeRec");
d398 3
a400 3
    ENTER_PROC("SMI_AvailableOptions");
    LEAVE_PROC("SMI_AvailableOptions");
    return SMIOptions;
d406 1
a406 1
    ENTER_PROC("SMI_Identify");
d412 1
a412 1
    LEAVE_PROC("SMI_Identify");
d425 1
a425 1
    ENTER_PROC("SMI_Probe");
d429 1
a429 1
    if (numDevSections <= 0) {
d431 1
a431 3
	LEAVE_PROC("SMI_Probe");
	return FALSE;
    }
d434 2
a435 4
    if (xf86GetPciVideoInfo() == NULL) {
	LEAVE_PROC("SMI_Probe");
	return FALSE;
    }
d444 8
a451 4
    if (numUsed <= 0) {
	LEAVE_PROC("SMI_Probe");
	return FALSE;
    }
a452 3
    if (flags & PROBE_DETECT) {
		foundScreen = TRUE;
    } else {
d454 20
a473 20
	    /* Allocate a ScrnInfoRec and claim the slot */
	    ScrnInfoPtr pScrn = xf86AllocateScreen(drv, 0);

	    /* Fill in what we can of the ScrnInfoRec */
	    pScrn->driverVersion = SILICONMOTION_DRIVER_VERSION;
	    pScrn->driverName	 = SILICONMOTION_DRIVER_NAME;
	    pScrn->name		 = SILICONMOTION_NAME;
	    pScrn->Probe	 = SMI_Probe;
	    pScrn->PreInit	 = SMI_PreInit;
	    pScrn->ScreenInit	 = SMI_ScreenInit;
	    pScrn->SwitchMode	 = SMI_SwitchMode;
	    pScrn->AdjustFrame	 = SMI_AdjustFrame;
	    pScrn->EnterVT	 = SMI_EnterVT;
	    pScrn->LeaveVT	 = SMI_LeaveVT;
	    pScrn->FreeScreen	 = SMI_FreeScreen;
	    pScrn->ValidMode	 = SMI_ValidMode;
	    foundScreen		 = TRUE;

	    xf86ConfigActivePciEntity(pScrn, usedChips[i], SMIPciChipsets, NULL,
				      NULL, NULL, NULL, NULL);
d478 1
a478 2
    LEAVE_PROC("SMI_Probe");
    return foundScreen;
a486 6
    int i;
    double real;
    ClockRangePtr clockRanges;
    char *s;
    unsigned char config, m, n, shift;
    int mclk;
a487 2
    int vgaCRIndex, vgaIOBase;
    vbeInfoPtr pVbe = NULL;
d489 1
a489 7
    ENTER_PROC("SMI_PreInit");

    if (flags & PROBE_DETECT) {
	SMI_ProbeDDC(pScrn, xf86GetEntityInfo(pScrn->entityList[0])->index);
	LEAVE_PROC("SMI_PreInit");
	return TRUE;
    }
d494 13
a506 4
    if (pScrn->numEntities > 1) {
	LEAVE_PROC("SMI_PreInit");
	return FALSE;
    }
d508 9
a516 4
    /* The vgahw module should be loaded here when needed */
    if (!xf86LoadSubModule(pScrn, "vgahw")) {
	LEAVE_PROC("SMI_PreInit");
	return FALSE;
d519 4
a522 8
    xf86LoaderReqSymLists(vgahwSymbols, NULL);

    /*
     * Allocate a vgaHWRec
     */
    if (!vgaHWGetHWRec(pScrn)) {
	LEAVE_PROC("SMI_PreInit");
	return FALSE;
d525 4
a528 4
    /* Allocate the SMIRec driverPrivate */
    if (!SMI_GetRec(pScrn)) {
	LEAVE_PROC("SMI_PreInit");
	return FALSE;
d530 1
a530 1
    pSmi = SMIPTR(pScrn);
d535 21
d559 2
a560 4
    if (!xf86SetDepthBpp(pScrn, 0, 0, 0, Support32bppFb)) {
	LEAVE_PROC("SMI_PreInit");
	return FALSE;
    }
d563 1
a563 8
    switch (pScrn->depth) {
    case 8:
    case 16:
    case 24:
	/* OK */
	break;

    default:
d567 10
a576 2
	LEAVE_PROC("SMI_PreInit");
	return FALSE;
d588 5
d594 2
a595 4
	if (!xf86SetWeight(pScrn, zeros, zeros)) {
	    LEAVE_PROC("SMI_PreInit");
	    return FALSE;
	}
d598 2
a599 4
    if (!xf86SetDefaultVisual(pScrn, -1)) {
	LEAVE_PROC("SMI_PreInit");
	return FALSE;
    }
d602 1
a602 1
    if ((pScrn->depth > 8) && (pScrn->defaultVisual != TrueColor)) {
d606 1
a606 2
	LEAVE_PROC("SMI_PreInit");
	return FALSE;
d616 5
a620 2
    if (pScrn->depth == 8) {
	pScrn->rgbBits = 6;
d625 2
a626 1
	return FALSE;
d630 7
a636 7
    if (xf86ReturnOptValBool(pSmi->Options, OPTION_PCI_BURST, FALSE)) {
	pSmi->pci_burst = TRUE;
	xf86DrvMsg(pScrn->scrnIndex, X_CONFIG, "Option: pci_burst - PCI burst "
		   "read enabled\n");
    } else {
	pSmi->pci_burst = FALSE;
    }
d638 9
a646 8
    pSmi->NoPCIRetry = TRUE;
    if (xf86ReturnOptValBool(pSmi->Options, OPTION_PCI_RETRY, FALSE)) {
	if (xf86ReturnOptValBool(pSmi->Options, OPTION_PCI_BURST, FALSE)) {
	    pSmi->NoPCIRetry = FALSE;
	    xf86DrvMsg(pScrn->scrnIndex, X_CONFIG, "Option: pci_retry\n");
	} else {
	    xf86DrvMsg(pScrn->scrnIndex, X_CONFIG, "\"pci_retry\" option "
		       "requires \"pci_burst\".\n");
d649 2
a650 22

    if (xf86IsOptionSet(pSmi->Options, OPTION_FIFO_CONSERV)) {
	pSmi->fifo_conservative = TRUE;
	xf86DrvMsg(pScrn->scrnIndex, X_CONFIG, "Option: fifo_conservative "
		   "set\n");
    } else {
	pSmi->fifo_conservative = FALSE;
    }

    if (xf86IsOptionSet(pSmi->Options, OPTION_FIFO_MODERATE)) {
	pSmi->fifo_moderate = TRUE;
	xf86DrvMsg(pScrn->scrnIndex, X_CONFIG, "Option: fifo_moderate set\n");
    } else {
	pSmi->fifo_moderate = FALSE;
    }

    if (xf86IsOptionSet(pSmi->Options, OPTION_FIFO_AGGRESSIVE)) {
	pSmi->fifo_aggressive = TRUE;
	xf86DrvMsg(pScrn->scrnIndex, X_CONFIG, "Option: fifo_aggressive set\n");
    } else {
	pSmi->fifo_aggressive = FALSE;
    }
d660 6
a665 5
    if (xf86ReturnOptValBool(pSmi->Options, OPTION_SHOWCACHE, FALSE)) {
	pSmi->ShowCache = TRUE;
	xf86DrvMsg(pScrn->scrnIndex, X_CONFIG, "Option: show_cache set\n");
    } else {
	pSmi->ShowCache = FALSE;
d668 7
a674 26
    if (xf86GetOptValFreq(pSmi->Options, OPTION_MCLK, OPTUNITS_MHZ, &real)) {
	pSmi->MCLK = (int)(real * 1000.0);
	if (pSmi->MCLK <= 120000) {
	    xf86DrvMsg(pScrn->scrnIndex, X_CONFIG, "Option: set_mclk set to "
		       "%1.3f MHz\n", pSmi->MCLK / 1000.0);
	} else {
	    xf86DrvMsg(pScrn->scrnIndex, X_WARNING, "Memory Clock value of "
		       "%1.3f MHz is larger than limit of 120 MHz\n",
		       pSmi->MCLK / 1000.0);
	    pSmi->MCLK = 0;
	}
    } else {
	pSmi->MCLK = 0;
    }

    from = X_DEFAULT;
    pSmi->hwcursor = TRUE;
    if (xf86GetOptValBool(pSmi->Options, OPTION_HWCURSOR, &pSmi->hwcursor)) {
	from = X_CONFIG;
    }
    if (xf86ReturnOptValBool(pSmi->Options, OPTION_SWCURSOR, FALSE)) {
	pSmi->hwcursor = FALSE;
	from = X_CONFIG;
    }
    xf86DrvMsg(pScrn->scrnIndex, from, "Using %s Cursor\n",
	       pSmi->hwcursor ? "Hardware" : "Software");
d676 2
a677 26
    if (xf86GetOptValBool(pSmi->Options, OPTION_SHADOW_FB, &pSmi->shadowFB)) {
	xf86DrvMsg(pScrn->scrnIndex, X_CONFIG, "ShadowFB %s.\n",
		   pSmi->shadowFB ? "enabled" : "disabled");
    }

#if 1 /* PDR#932 */
    if ((pScrn->depth == 8) || (pScrn->depth == 16))
#endif /* PDR#932 */
	if ((s = xf86GetOptValString(pSmi->Options, OPTION_ROTATE))) {
	    if (!xf86NameCmp(s, "CW")) {
		pSmi->shadowFB = TRUE;
		pSmi->rotate = SMI_ROTATE_CCW;
		xf86DrvMsg(pScrn->scrnIndex, X_CONFIG, "Rotating screen "
			   "clockwise\n");
	    } else if (!xf86NameCmp(s, "CCW")) {
		pSmi->shadowFB = TRUE;
		pSmi->rotate = SMI_ROTATE_CW;
		xf86DrvMsg(pScrn->scrnIndex, X_CONFIG, "Rotating screen counter "
			   "clockwise\n");
	    } else {
		xf86DrvMsg(pScrn->scrnIndex, X_CONFIG, "\"%s\" is not a valid "
			   "value for Option \"Rotate\"\n", s);
		xf86DrvMsg(pScrn->scrnIndex, X_INFO, "Valid options are \"CW\" or "
			   "\"CCW\"\n");
	    }
	}
a678 5
    if (pSmi->rotate) {
	/* Disable the RandR extension, it messes up the internal rotation stuff */
	xf86DisableRandR();
    }
		
d705 3
a707 1
    if (xf86GetOptValBool(pSmi->Options, OPTION_USEBIOS, &pSmi->useBIOS)) {
d710 6
a715 1
    } else {
d720 5
a724 7
    if (xf86GetOptValBool(pSmi->Options, OPTION_ZOOMONLCD, &pSmi->zoomOnLCD)) {
	xf86DrvMsg(pScrn->scrnIndex, X_CONFIG, "Option: ZoomOnLCD %s.\n",
		   pSmi->zoomOnLCD ? "enabled" : "disabled");
    } else {
	/* Default to ZoomOnLCD enabled. */
	pSmi->zoomOnLCD = TRUE;
    }
d726 4
a729 8
    /* Find the PCI slot for this screen */
    pEnt = xf86GetEntityInfo(pScrn->entityList[0]);
    if ((pEnt->location.type != BUS_PCI) || (pEnt->resources)) {
	xfree(pEnt);
	SMI_FreeRec(pScrn);
	LEAVE_PROC("SMI_PreInit");
	return FALSE;
    }
d731 4
a734 8
    if (xf86LoadSubModule(pScrn,"int10")) {
	xf86LoaderReqSymLists(int10Symbols,NULL);
	pSmi->pInt10 = xf86InitInt10(pEnt->index);
    }
	
    if (pSmi->pInt10 && xf86LoadSubModule(pScrn, "vbe")) {
	xf86LoaderReqSymLists(vbeSymbols, NULL);
	pVbe = VBEInit(pSmi->pInt10, pEnt->index);
a736 1
    pSmi->PciInfo = xf86GetPciInfoForEntity(pEnt->index);
d749 2
a750 1
    } else if (pEnt->device->chipID >= 0) {
d756 2
a757 1
    } else {
d767 2
a768 1
    } else {
a769 1
    }
d779 1
a779 2
	LEAVE_PROC("SMI_PreInit");
	return FALSE;
d785 1
a785 2
	LEAVE_PROC("SMI_PreInit");
	return FALSE;
d796 61
a856 3
    if (xf86ReturnOptValBool(pSmi->Options, OPTION_DUALHEAD, FALSE) &&
	SMI_LYNXM_SERIES(pSmi->Chipset)) {
	pSmi->Dualhead = TRUE;
d859 12
a870 10
    /* tweak options for dualhead */
    if (pSmi->Dualhead) {
	pSmi->useBIOS = FALSE;
	xf86DrvMsg(pScrn->scrnIndex, X_INFO, "UseBIOS disabled in dualhead mode\n");
	pSmi->hwcursor = FALSE;
	xf86DrvMsg(pScrn->scrnIndex, X_INFO, "No hardware cursor in dualhead mode\n");
	if (pScrn->bitsPerPixel != 16) {
	    xf86DrvMsg(pScrn->scrnIndex, X_ERROR, "Dualhead only supported at "
		       "depth 16\n");
	    return FALSE;
d872 3
d877 2
a881 8
    hwp = VGAHWPTR(pScrn);
    vgaIOBase  = hwp->IOBase;
    vgaCRIndex = vgaIOBase + VGA_CRTC_INDEX_OFFSET;
    pSmi->PIOBase = hwp->PIOOffset;

    xf86ErrorFVerb(VERBLEV, "\tSMI_PreInit vgaCRIndex=%x, vgaIOBase=%x, "
		   "MMIOBase=%p\n", vgaCRIndex, vgaIOBase, hwp->MMIOBase);

d885 8
a892 39
    if (xf86LoadSubModule(pScrn, "i2c")) {
	xf86LoaderReqSymLists(i2cSymbols, NULL);
	SMI_I2CInit(pScrn);
    }

    if (xf86LoadSubModule(pScrn, "ddc")) {
	xf86MonPtr pMon = NULL;

	xf86LoaderReqSymLists(ddcSymbols, NULL);
#if 1 /* PDR#579 */
	if (pVbe) {
	    pMon = vbeDoEDID(pVbe, NULL);
	    if (pMon != NULL) {
		if ((pMon->rawData[0] == 0x00) &&
		    (pMon->rawData[1] == 0xFF) &&
		    (pMon->rawData[2] == 0xFF) &&
		    (pMon->rawData[3] == 0xFF) &&
		    (pMon->rawData[4] == 0xFF) &&
		    (pMon->rawData[5] == 0xFF) &&
		    (pMon->rawData[6] == 0xFF) &&
		    (pMon->rawData[7] == 0x00)) {
		    pMon = xf86PrintEDID(pMon);
		    if (pMon != NULL) {
			xf86SetDDCproperties(pScrn, pMon);
		    }
		}
	    }
#else
	if ((pVbe) && 
	    ((pMon = xf86PrintEDID(vbeDoEDID(pVbe, NULL))) != NULL)) {
	    xf86SetDDCproperties(pScrn, pMon);
#endif
    	} else if (!SMI_ddc1(pScrn->scrnIndex)) {
	    if (pSmi->I2C) {
	    	xf86SetDDCproperties(pScrn,
			xf86PrintEDID(xf86DoEDID_DDC2(pScrn->scrnIndex,
			pSmi->I2C)));
	    }
    	}
a894 4
    vbeFree(pVbe);
    xf86FreeInt10(pSmi->pInt10);
    pSmi->pInt10 = NULL;

a896 2
     * here. (from MGA, no ViRGE gamma support yet, but needed for
     * xf86HandleColormaps support.)
a901 1
	    LEAVE_PROC("SMI_PreInit");
d904 1
a904 18
	    return FALSE;
	}
    }


    /* Next go on to detect amount of installed ram */
    config = VGAIN8_INDEX(pSmi, VGA_SEQ_INDEX, VGA_SEQ_DATA, 0x71);

    /* And compute the amount of video memory and offscreen memory */
    pSmi->videoRAMKBytes = 0;

    if (!pScrn->videoRam) {
	switch (pSmi->Chipset) {
	default:
	{
	    int mem_table[4] = { 1, 2, 4, 0 };
	    pSmi->videoRAMKBytes = mem_table[(config >> 6)] * 1024;
	    break;
a905 60
	case SMI_LYNX3D:
	{
	    int mem_table[4] = { 0, 2, 4, 6 };
	    pSmi->videoRAMKBytes = mem_table[(config >> 6)] * 1024 + 512;
	    break;
	}
	case SMI_LYNX3DM:
	{
	    int mem_table[4] = { 16, 2, 4, 8 };
	    pSmi->videoRAMKBytes = mem_table[(config >> 6)] * 1024;
	    break;
	}
	case SMI_COUGAR3DR:
	{
	    /* DANGER - Cougar3DR BIOS is broken - hardcode video ram size */
	    /* per instructions from Silicon Motion engineers */
	    pSmi->videoRAMKBytes = 16 * 1024;
	    break;
        }
	}
	pSmi->videoRAMBytes = pSmi->videoRAMKBytes * 1024;
	pScrn->videoRam     = pSmi->videoRAMKBytes;

	xf86DrvMsg(pScrn->scrnIndex, X_PROBED, "videoram: %dkB\n",
		   pSmi->videoRAMKBytes);
    } else {
	pSmi->videoRAMKBytes = pScrn->videoRam;
	pSmi->videoRAMBytes  = pScrn->videoRam * 1024;

	xf86DrvMsg(pScrn->scrnIndex, X_CONFIG, "videoram: %dk\n",
		   pSmi->videoRAMKBytes);
    }

    /* Detect current MCLK and print it for user */
    m = VGAIN8_INDEX(pSmi, VGA_SEQ_INDEX, VGA_SEQ_DATA, 0x6A);
    n = VGAIN8_INDEX(pSmi, VGA_SEQ_INDEX, VGA_SEQ_DATA, 0x6B);
    switch (n >> 6) {
    default:
	shift = 1;
	break;
    case 1:
	shift = 4;
	break;
    case 2:
	shift = 2;
	break;
    }
    n &= 0x3F;
    mclk = ((1431818 * m) / n / shift + 50) / 100;
    xf86DrvMsg(pScrn->scrnIndex, X_PROBED, "Detected current MCLK value of "
	       "%1.3f MHz\n", mclk / 1000.0);

    SMI_EnableVideo(pScrn);
    SMI_UnmapMem(pScrn);

    pSmi->IsSwitching = FALSE;

    if (pSmi->Dualhead) {
	pScrn->display->virtualX = 2 * pSmi->lcdWidth;
	pScrn->display->virtualY = pSmi->lcdHeight;
d908 1
a908 1
    pScrn->virtualX = pScrn->display->virtualX;
d914 2
a915 3
    clockRanges = xnfcalloc(sizeof(ClockRange),1);
    clockRanges->next = NULL;
    clockRanges->minClock = 20000;
d917 4
a920 2
    if ((pSmi->Chipset == SMI_LYNX3DM) || (pSmi->Chipset == SMI_COUGAR3DR))
	clockRanges->maxClock = 200000;
d922 1
a922 1
        clockRanges->maxClock = 135000;
d924 3
a926 21
    clockRanges->clockIndex = -1;
    clockRanges->interlaceAllowed = FALSE;
    clockRanges->doubleScanAllowed = FALSE;
		
    i = xf86ValidateModes(
		pScrn,				/* Screen pointer			  */
		pScrn->monitor->Modes,		/* Available monitor modes		  */
		pScrn->display->modes,		/* req mode names for screen		  */
		clockRanges,			/* list of clock ranges allowed		  */
		NULL,				/* use min/max below			  */
		128,				/* min line pitch (width)		  */
		4096,				/* maximum line pitch (width)		  */
		128,				/* bits of granularity for line pitch     */
						/* (width) above			  */
		128,				/* min virtual height			  */
		4096,				/* max virtual height			  */
		pScrn->display->virtualX,	/* force virtual x			  */
		pScrn->display->virtualY,	/* force virtual Y			  */
		pSmi->videoRAMBytes,		/* size of aperture used to access	  */
						/* video memory				  */
		LOOKUP_BEST_REFRESH);		/* how to pick modes			  */
d928 2
a929 5
    if (i == -1) {
	SMI_FreeRec(pScrn);
	LEAVE_PROC("SMI_PreInit");
	return FALSE;
    }
d931 2
a932 2
    /* Prune the modes marked as invalid */
    xf86PruneDriverModes(pScrn);
d934 2
a935 1
    if ((i == 0) || (pScrn->modes == NULL)) {
d937 1
a937 3
	SMI_FreeRec(pScrn);
	LEAVE_PROC("SMI_PreInit");
	return FALSE;
a938 1
    xf86SetCrtcForModes(pScrn, 0);
a939 2
    /* Set the current mode to the first in the list */
    pScrn->currentMode = pScrn->modes;
d941 11
a951 2
    /* Print the list of modes being used */
    xf86PrintModes(pScrn);
d956 1
a956 1
    if ((xf86LoadSubModule(pScrn, "fb") == NULL)) {
d958 1
a958 20
	LEAVE_PROC("SMI_PreInit");
	return FALSE;
    }

    if (!pSmi->NoAccel) {
	from = X_DEFAULT;
	char *strptr;
		
	if ((strptr = (char *)xf86GetOptValString(pSmi->Options, OPTION_ACCELMETHOD))) {
	    if (!xf86NameCmp(strptr,"XAA")) {
		from = X_CONFIG;
		pSmi->useEXA = FALSE;
	    } else if(!xf86NameCmp(strptr,"EXA")) {
		from = X_CONFIG;
		pSmi->useEXA = TRUE;
	    }
	}
	
	xf86DrvMsg(pScrn->scrnIndex, from, "Using %s acceleration architecture\n",
        	pSmi->useEXA ? "EXA" : "XAA");
d968 1
a968 2
		LEAVE_PROC("SMI_PreInit");
		return FALSE;
d977 1
a977 1
	    req.minorversion = 0;
d983 1
a983 2
		LEAVE_PROC("SMI_PreInit");
		return FALSE;
d990 1
a990 1
    if (pSmi->hwcursor) {
d993 1
a993 11
	    LEAVE_PROC("SMI_PreInit");
	    return FALSE;
	}
	xf86LoaderReqSymLists(ramdacSymbols, NULL);
    }

    if (pSmi->shadowFB) {
	if (!xf86LoadSubModule(pScrn, "shadowfb")) {
	    SMI_FreeRec(pScrn);
	    LEAVE_PROC("SMI_PreInit");
	    return FALSE;
a994 1
	xf86LoaderReqSymLists(shadowSymbols, NULL);
d997 1
a997 2
    LEAVE_PROC("SMI_PreInit");
    return TRUE;
a1009 1
    Bool ret;
d1011 1
a1011 1
    ENTER_PROC("SMI_EnterVT");
a1014 7
    SMI_Save(pScrn);

    /* #670 */
    if (pSmi->shadowFB) {
	pSmi->FBOffset = pSmi->savedFBOffset;
	pSmi->FBReserved = pSmi->savedFBReserved;
    }
d1016 1
a1016 1
    ret = SMI_ModeInit(pScrn, pScrn->currentMode);
d1018 15
a1032 3
    /* #670 */
    if (ret && pSmi->shadowFB) {
	BoxRec box;
d1034 3
a1036 28
	/* #920 */
	if (pSmi->paletteBuffer) {
	    int i;

	    VGAOUT8(pSmi, VGA_DAC_WRITE_ADDR, 0);
	    for (i = 0; i < 256 * 3; i++) {
		VGAOUT8(pSmi, VGA_DAC_DATA, pSmi->paletteBuffer[i]);
	    }
	    xfree(pSmi->paletteBuffer);
	    pSmi->paletteBuffer = NULL;
	}

	if (pSmi->pSaveBuffer) {
	    memcpy(pSmi->FBBase, pSmi->pSaveBuffer, pSmi->saveBufferSize);
	    xfree(pSmi->pSaveBuffer);
	    pSmi->pSaveBuffer = NULL;
	}

	box.x1 = 0;
	box.y1 = 0;
	box.x2 = pScrn->virtualY;
	box.y2 = pScrn->virtualX;
	if (pSmi->Chipset == SMI_COUGAR3DR) {
	    SMI_RefreshArea730(pScrn, 1, &box);
	} else {
	    SMI_RefreshArea(pScrn, 1, &box);
	}
    }
d1042 1
a1042 2
    LEAVE_PROC("SMI_EnterVT");
    return ret;
d1054 19
a1072 5
    ScrnInfoPtr pScrn = xf86Screens[scrnIndex];
    vgaHWPtr hwp = VGAHWPTR(pScrn);
    SMIPtr pSmi = SMIPTR(pScrn);
    vgaRegPtr vgaSavePtr = &hwp->SavedReg;
    SMIRegPtr SMISavePtr = &pSmi->SavedReg;
d1074 2
a1075 1
    ENTER_PROC("SMI_LeaveVT");
d1077 1
a1077 22
    /* #670 */
    if (pSmi->shadowFB) {
	pSmi->pSaveBuffer = xnfalloc(pSmi->saveBufferSize);
	if (pSmi->pSaveBuffer) {
	    memcpy(pSmi->pSaveBuffer, pSmi->FBBase, pSmi->saveBufferSize);
	}

	pSmi->savedFBOffset = pSmi->FBOffset;
	pSmi->savedFBReserved = pSmi->FBReserved;

	/* #920 */
	if (pSmi->Bpp == 1) {
	    pSmi->paletteBuffer = xnfalloc(256 * 3);
	    if (pSmi->paletteBuffer) {
		int i;

		VGAOUT8(pSmi, VGA_DAC_READ_ADDR, 0);
		for (i = 0; i < 256 * 3; i++) {
		    pSmi->paletteBuffer[i] = VGAIN8(pSmi, VGA_DAC_DATA);
		}
	    }
	}
d1079 2
a1081 2
    memset(pSmi->FBBase, 0, 256 * 1024);	/* #689 */
    SMI_WriteMode(pScrn, vgaSavePtr, SMISavePtr);
d1084 1
a1084 1
    LEAVE_PROC("SMI_LeaveVT");
a1086 6
/*
 * This function performs the inverse of the restore function: It saves all the
 * standard and extended registers that we are going to modify to set up a video
 * mode.
 */

d1088 1
a1088 1
SMI_Save(ScrnInfoPtr pScrn)
d1090 13
a1102 89
    int i;
    CARD32 offset;

    vgaHWPtr hwp         = VGAHWPTR(pScrn);
    vgaRegPtr vgaSavePtr = &hwp->SavedReg;
    SMIPtr pSmi          = SMIPTR(pScrn);
    SMIRegPtr save       = &pSmi->SavedReg;

    int vgaIOBase  = hwp->IOBase;
    int vgaCRIndex = vgaIOBase + VGA_CRTC_INDEX_OFFSET;
    int vgaCRData  = vgaIOBase + VGA_CRTC_DATA_OFFSET;

    ENTER_PROC("SMI_Save");

    /* Save the standard VGA registers */
    vgaHWSave(pScrn, vgaSavePtr, VGA_SR_ALL);
    save->smiDACMask = VGAIN8(pSmi, VGA_DAC_MASK);
    VGAOUT8(pSmi, VGA_DAC_READ_ADDR, 0);
    for (i = 0; i < 256; i++) {
	save->smiDacRegs[i][0] = VGAIN8(pSmi, VGA_DAC_DATA);
	save->smiDacRegs[i][1] = VGAIN8(pSmi, VGA_DAC_DATA);
	save->smiDacRegs[i][2] = VGAIN8(pSmi, VGA_DAC_DATA);
    }
    for (i = 0, offset = 2; i < 8192; i++, offset += 8) {
	save->smiFont[i] = *(pSmi->FBBase + offset);
    }

    /* Now we save all the extended registers we need. */
    save->SR17 = VGAIN8_INDEX(pSmi, VGA_SEQ_INDEX, VGA_SEQ_DATA, 0x17);
    save->SR18 = VGAIN8_INDEX(pSmi, VGA_SEQ_INDEX, VGA_SEQ_DATA, 0x18);
    save->SR21 = VGAIN8_INDEX(pSmi, VGA_SEQ_INDEX, VGA_SEQ_DATA, 0x21);
    save->SR31 = VGAIN8_INDEX(pSmi, VGA_SEQ_INDEX, VGA_SEQ_DATA, 0x31);
    save->SR32 = VGAIN8_INDEX(pSmi, VGA_SEQ_INDEX, VGA_SEQ_DATA, 0x32);
    save->SR6A = VGAIN8_INDEX(pSmi, VGA_SEQ_INDEX, VGA_SEQ_DATA, 0x6A);
    save->SR6B = VGAIN8_INDEX(pSmi, VGA_SEQ_INDEX, VGA_SEQ_DATA, 0x6B);
    save->SR81 = VGAIN8_INDEX(pSmi, VGA_SEQ_INDEX, VGA_SEQ_DATA, 0x81);
    save->SRA0 = VGAIN8_INDEX(pSmi, VGA_SEQ_INDEX, VGA_SEQ_DATA, 0xA0);

    /* vclk1 */
    save->SR6C = VGAIN8_INDEX(pSmi, VGA_SEQ_INDEX, VGA_SEQ_DATA, 0x6C);
    save->SR6D = VGAIN8_INDEX(pSmi, VGA_SEQ_INDEX, VGA_SEQ_DATA, 0x6D);
    /* vclk1 control */
    save->SR68 = VGAIN8_INDEX(pSmi, VGA_SEQ_INDEX, VGA_SEQ_DATA, 0x68);

    if (pSmi->Dualhead) {
	/* dualhead stuff */
	save->SR22 = VGAIN8_INDEX(pSmi, VGA_SEQ_INDEX, VGA_SEQ_DATA, 0x22);
	save->SR40 = VGAIN8_INDEX(pSmi, VGA_SEQ_INDEX, VGA_SEQ_DATA, 0x40);
	save->SR41 = VGAIN8_INDEX(pSmi, VGA_SEQ_INDEX, VGA_SEQ_DATA, 0x41);
	save->SR42 = VGAIN8_INDEX(pSmi, VGA_SEQ_INDEX, VGA_SEQ_DATA, 0x42);
	save->SR43 = VGAIN8_INDEX(pSmi, VGA_SEQ_INDEX, VGA_SEQ_DATA, 0x43);
	save->SR44 = VGAIN8_INDEX(pSmi, VGA_SEQ_INDEX, VGA_SEQ_DATA, 0x44);
	save->SR45 = VGAIN8_INDEX(pSmi, VGA_SEQ_INDEX, VGA_SEQ_DATA, 0x45);
	save->SR48 = VGAIN8_INDEX(pSmi, VGA_SEQ_INDEX, VGA_SEQ_DATA, 0x48);
	save->SR49 = VGAIN8_INDEX(pSmi, VGA_SEQ_INDEX, VGA_SEQ_DATA, 0x49);
	save->SR4A = VGAIN8_INDEX(pSmi, VGA_SEQ_INDEX, VGA_SEQ_DATA, 0x4A);
	save->SR4B = VGAIN8_INDEX(pSmi, VGA_SEQ_INDEX, VGA_SEQ_DATA, 0x4B);
	save->SR4C = VGAIN8_INDEX(pSmi, VGA_SEQ_INDEX, VGA_SEQ_DATA, 0x4C);
	/* PLL2 stuff */
	save->SR69 = VGAIN8_INDEX(pSmi, VGA_SEQ_INDEX, VGA_SEQ_DATA, 0x69);
	save->SR6E = VGAIN8_INDEX(pSmi, VGA_SEQ_INDEX, VGA_SEQ_DATA, 0x6E);
	save->SR6F = VGAIN8_INDEX(pSmi, VGA_SEQ_INDEX, VGA_SEQ_DATA, 0x6F);
    }

    if (SMI_LYNXM_SERIES(pSmi->Chipset)) {
	/* Save primary registers */
	save->CR90[14] = VGAIN8_INDEX(pSmi, vgaCRIndex, vgaCRData, 0x9E);
	VGAOUT8_INDEX(pSmi, vgaCRIndex, vgaCRData, 0x9E, save->CR90[14] & ~0x20);

	for (i = 0; i < 16; i++) {
	    save->CR90[i] = VGAIN8_INDEX(pSmi, vgaCRIndex, vgaCRData, 0x90 + i);
	}
	save->CR33 = VGAIN8_INDEX(pSmi, vgaCRIndex, vgaCRData, 0x33);
	save->CR3A = VGAIN8_INDEX(pSmi, vgaCRIndex, vgaCRData, 0x3A);
	for (i = 0; i < 14; i++) {
	    save->CR40[i] = VGAIN8_INDEX(pSmi, vgaCRIndex, vgaCRData, 0x40 + i);
	}

	/* Save secondary registers */
	VGAOUT8_INDEX(pSmi, vgaCRIndex, vgaCRData, 0x9E, save->CR90[14] | 0x20);
	save->CR33_2 = VGAIN8_INDEX(pSmi, vgaCRIndex, vgaCRData, 0x33);
	for (i = 0; i < 14; i++) {
	    save->CR40_2[i] = VGAIN8_INDEX(pSmi, vgaCRIndex, vgaCRData, 0x40 + i);
	}
	save->CR9F_2 = VGAIN8_INDEX(pSmi, vgaCRIndex, vgaCRData, 0x9F);

	/* Save common registers */
	for (i = 0; i < 14; i++) {
	    save->CRA0[i] = VGAIN8_INDEX(pSmi, vgaCRIndex, vgaCRData, 0xA0 + i);
d1104 1
d1106 37
a1142 15
	/* PDR#1069 */
	VGAOUT8_INDEX(pSmi, vgaCRIndex, vgaCRData, 0x9E, save->CR90[14]);
    } else {
	save->CR33 = VGAIN8_INDEX(pSmi, vgaCRIndex, vgaCRData, 0x33);
	save->CR3A = VGAIN8_INDEX(pSmi, vgaCRIndex, vgaCRData, 0x3A);
	for (i = 0; i < 14; i++) {
	    save->CR40[i] = VGAIN8_INDEX(pSmi, vgaCRIndex, vgaCRData, 0x40 + i);
	}
    }

    /* CZ 2.11.2001: for gamma correction (TODO: other chipsets?) */
    if ((pSmi->Chipset == SMI_LYNX3DM) || (pSmi->Chipset == SMI_COUGAR3DR)) {
	save->CCR66 = VGAIN8_INDEX(pSmi, VGA_SEQ_INDEX, VGA_SEQ_DATA, 0x66);
    }
    /* end CZ */
d1144 3
a1146 152
    save->DPR10 = READ_DPR(pSmi, 0x10);
    save->DPR1C = READ_DPR(pSmi, 0x1C);
    save->DPR20 = READ_DPR(pSmi, 0x20);
    save->DPR24 = READ_DPR(pSmi, 0x24);
    save->DPR28 = READ_DPR(pSmi, 0x28);
    save->DPR2C = READ_DPR(pSmi, 0x2C);
    save->DPR30 = READ_DPR(pSmi, 0x30);
    save->DPR3C = READ_DPR(pSmi, 0x3C);
    save->DPR40 = READ_DPR(pSmi, 0x40);
    save->DPR44 = READ_DPR(pSmi, 0x44);

    save->VPR00 = READ_VPR(pSmi, 0x00);
    save->VPR0C = READ_VPR(pSmi, 0x0C);
    save->VPR10 = READ_VPR(pSmi, 0x10);

    if (pSmi->Chipset == SMI_COUGAR3DR) {
	save->FPR00_ = READ_FPR(pSmi, FPR00); 
	save->FPR0C_ = READ_FPR(pSmi, FPR0C);
	save->FPR10_ = READ_FPR(pSmi, FPR10);
    }

    save->CPR00 = READ_CPR(pSmi, 0x00);

    if (!pSmi->ModeStructInit) {
	/* XXX Should check the return value of vgaHWCopyReg() */
	vgaHWCopyReg(&hwp->ModeReg, vgaSavePtr);
	memcpy(&pSmi->ModeReg, save, sizeof(SMIRegRec));
	pSmi->ModeStructInit = TRUE;
    }

    if (pSmi->useBIOS && (pSmi->pInt10 != NULL)) {
	pSmi->pInt10->num = 0x10;
	pSmi->pInt10->ax = 0x0F00;
	xf86ExecX86int10(pSmi->pInt10);
	save->mode = pSmi->pInt10->ax & 0x007F;
	xf86DrvMsg(pScrn->scrnIndex, X_INFO, "Current mode 0x%02X.\n",
		   save->mode);
    }

    if (xf86GetVerbosity() > 1) {
	xf86DrvMsgVerb(pScrn->scrnIndex, X_INFO, VERBLEV,
		       "Saved current video mode.  Register dump:\n");
	SMI_PrintRegs(pScrn);
    }

    LEAVE_PROC("SMI_Save");
}

/*
 * This function is used to restore a video mode. It writes out all of the
 * standard VGA and extended registers needed to setup a video mode.
 */

static void
SMI_WriteMode(ScrnInfoPtr pScrn, vgaRegPtr vgaSavePtr, SMIRegPtr restore)
{
    int i;
    CARD8 tmp;
    CARD32 offset;

    vgaHWPtr hwp   = VGAHWPTR(pScrn);
    SMIPtr pSmi    = SMIPTR(pScrn);
    int vgaIOBase  = hwp->IOBase;
    int vgaCRIndex = vgaIOBase + VGA_CRTC_INDEX_OFFSET;
    int vgaCRData  = vgaIOBase + VGA_CRTC_DATA_OFFSET;

    ENTER_PROC("SMI_WriteMode");

    vgaHWProtect(pScrn, TRUE);

    /* Wait for engine to become idle */
    if (pSmi->IsSwitching)
	WaitIdle();

    if (pSmi->useBIOS && (pSmi->pInt10 != NULL) && (restore->mode != 0)) {
	pSmi->pInt10->num = 0x10;
	pSmi->pInt10->ax = restore->mode | 0x80;
	xf86DrvMsg(pScrn->scrnIndex, X_INFO, "Setting mode 0x%02X\n",
		   restore->mode);
	xf86ExecX86int10(pSmi->pInt10);

	/* Enable linear mode. */
	outb(pSmi->PIOBase + VGA_SEQ_INDEX, 0x18);
	tmp = inb(pSmi->PIOBase + VGA_SEQ_DATA);
	outb(pSmi->PIOBase + VGA_SEQ_DATA, tmp | 0x01);

	/* Enable DPR/VPR registers. */
	tmp = VGAIN8_INDEX(pSmi, VGA_SEQ_INDEX, VGA_SEQ_DATA, 0x21);
	VGAOUT8_INDEX(pSmi, VGA_SEQ_INDEX, VGA_SEQ_DATA, 0x21, tmp & ~0x03);
    } else {
	VGAOUT8_INDEX(pSmi, VGA_SEQ_INDEX, VGA_SEQ_DATA, 0x17, restore->SR17);
	tmp = VGAIN8_INDEX(pSmi, VGA_SEQ_INDEX, VGA_SEQ_DATA, 0x18) & ~0x1F;
	VGAOUT8_INDEX(pSmi, VGA_SEQ_INDEX, VGA_SEQ_DATA, 0x18, tmp |
		      (restore->SR18 & 0x1F));
	tmp = VGAIN8_INDEX(pSmi, VGA_SEQ_INDEX, VGA_SEQ_DATA, 0x21);
	VGAOUT8_INDEX(pSmi, VGA_SEQ_INDEX, VGA_SEQ_DATA, 0x21, tmp & ~0x03);
	tmp = VGAIN8_INDEX(pSmi, VGA_SEQ_INDEX, VGA_SEQ_DATA, 0x31) & ~0xC0;
	VGAOUT8_INDEX(pSmi, VGA_SEQ_INDEX, VGA_SEQ_DATA, 0x31, tmp |
		      (restore->SR31 & 0xC0));
	tmp = VGAIN8_INDEX(pSmi, VGA_SEQ_INDEX, VGA_SEQ_DATA, 0x32) & ~0x07;
	VGAOUT8_INDEX(pSmi, VGA_SEQ_INDEX, VGA_SEQ_DATA, 0x32, tmp |
		      (restore->SR32 & 0x07));
	if (restore->SR6B != 0xFF) {
	    VGAOUT8_INDEX(pSmi, VGA_SEQ_INDEX, VGA_SEQ_DATA, 0x6A, restore->SR6A);
	    VGAOUT8_INDEX(pSmi, VGA_SEQ_INDEX, VGA_SEQ_DATA, 0x6B, restore->SR6B);
	}
	VGAOUT8_INDEX(pSmi, VGA_SEQ_INDEX, VGA_SEQ_DATA, 0x81, restore->SR81);
	VGAOUT8_INDEX(pSmi, VGA_SEQ_INDEX, VGA_SEQ_DATA, 0xA0, restore->SRA0);

	/* Restore the standard VGA registers */
	vgaHWRestore(pScrn, vgaSavePtr, VGA_SR_ALL);
	if (restore->smiDACMask) {
	    VGAOUT8(pSmi, VGA_DAC_MASK, restore->smiDACMask);
	} else {
	    VGAOUT8(pSmi, VGA_DAC_MASK, 0xFF);
	}
	VGAOUT8(pSmi, VGA_DAC_WRITE_ADDR, 0);
	for (i = 0; i < 256; i++) {
	    VGAOUT8(pSmi, VGA_DAC_DATA, restore->smiDacRegs[i][0]);
	    VGAOUT8(pSmi, VGA_DAC_DATA, restore->smiDacRegs[i][1]);
	    VGAOUT8(pSmi, VGA_DAC_DATA, restore->smiDacRegs[i][2]);
	}
	for (i = 0, offset = 2; i < 8192; i++, offset += 8) {
	    *(pSmi->FBBase + offset) = restore->smiFont[i];
	}

	if (SMI_LYNXM_SERIES(pSmi->Chipset)) {
	    /* Restore secondary registers */
	    VGAOUT8_INDEX(pSmi, vgaCRIndex, vgaCRData, 0x9E,
			  restore->CR90[14] | 0x20);

	    VGAOUT8_INDEX(pSmi, vgaCRIndex, vgaCRData, 0x33, restore->CR33_2);
	    for (i = 0; i < 14; i++) {
		VGAOUT8_INDEX(pSmi, vgaCRIndex, vgaCRData, 0x40 + i,
			      restore->CR40_2[i]);
	    }
	    VGAOUT8_INDEX(pSmi, vgaCRIndex, vgaCRData, 0x9F, restore->CR9F_2);

	    /* Restore primary registers */
	    VGAOUT8_INDEX(pSmi, vgaCRIndex, vgaCRData, 0x9E,
			  restore->CR90[14] & ~0x20);

	    VGAOUT8_INDEX(pSmi, vgaCRIndex, vgaCRData, 0x33, restore->CR33);
	    VGAOUT8_INDEX(pSmi, vgaCRIndex, vgaCRData, 0x3A, restore->CR3A);
	    for (i = 0; i < 14; i++) {
		VGAOUT8_INDEX(pSmi, vgaCRIndex, vgaCRData, 0x40 + i,
			      restore->CR40[i]);
	    }
	    for (i = 0; i < 16; i++) {
		if (i != 14) {
		    VGAOUT8_INDEX(pSmi, vgaCRIndex, vgaCRData, 0x90 + i,
				  restore->CR90[i]);
d1148 54
a1201 24
	    }
	    VGAOUT8_INDEX(pSmi, vgaCRIndex, vgaCRData, 0x9E, restore->CR90[14]);

	    /* Restore common registers */
	    for (i = 0; i < 14; i++) {
		VGAOUT8_INDEX(pSmi, vgaCRIndex, vgaCRData, 0xA0 + i,
			      restore->CRA0[i]);
	    }
	}

	/* Restore the standard VGA registers */
	if (xf86IsPrimaryPci(pSmi->PciInfo)) {
	    vgaHWRestore(pScrn, vgaSavePtr, VGA_SR_CMAP | VGA_SR_FONTS);
	} 

	if (restore->modeInit)
	    vgaHWRestore(pScrn, vgaSavePtr, VGA_SR_ALL);

	if (!SMI_LYNXM_SERIES(pSmi->Chipset)) {
	    VGAOUT8_INDEX(pSmi, vgaCRIndex, vgaCRData, 0x33, restore->CR33);
	    VGAOUT8_INDEX(pSmi, vgaCRIndex, vgaCRData, 0x3A, restore->CR3A);
	    for (i = 0; i < 14; i++) {
		VGAOUT8_INDEX(pSmi, vgaCRIndex, vgaCRData, 0x40 + i,
			      restore->CR40[i]);
a1203 54

	/* vclk1 */
	VGAOUT8_INDEX(pSmi, VGA_SEQ_INDEX, VGA_SEQ_DATA, 0x68, restore->SR68);
	VGAOUT8_INDEX(pSmi, VGA_SEQ_INDEX, VGA_SEQ_DATA, 0x6C, restore->SR6C);
	VGAOUT8_INDEX(pSmi, VGA_SEQ_INDEX, VGA_SEQ_DATA, 0x6D, restore->SR6D);

	if (pSmi->Dualhead) {

	/* TFT panel uses FIFO1, DSTN panel uses FIFO1 for upper panel and 
	 * FIFO2 for lower panel.  I don't have a DSTN panel, so it's untested.
	 * -- AGD
	 */

	    /* PLL2 regs */

	    VGAOUT8_INDEX(pSmi, VGA_SEQ_INDEX, VGA_SEQ_DATA, 0x69, restore->SR69);

	    VGAOUT8_INDEX(pSmi, VGA_SEQ_INDEX, VGA_SEQ_DATA, 0x6E, restore->SR6E);
	    VGAOUT8_INDEX(pSmi, VGA_SEQ_INDEX, VGA_SEQ_DATA, 0x6F, restore->SR6F);

	    /* setting SR21 bit 2 disables ZV circuitry, 
	     * if ZV is needed, SR21 = 0x20
	     */
	    /* enable DAC, PLL, etc. */
	    VGAOUT8_INDEX(pSmi, VGA_SEQ_INDEX, VGA_SEQ_DATA, 0x21, restore->SR21);

	    /* clear DPMS state */
	    VGAOUT8_INDEX(pSmi, VGA_SEQ_INDEX, VGA_SEQ_DATA, 0x22, restore->SR22);

	    /* enable virtual refresh and LCD and CRT outputs */
	    VGAOUT8_INDEX(pSmi, VGA_SEQ_INDEX, VGA_SEQ_DATA, 0x31, restore->SR31);

	    /* FIFO1 Read Offset */
	    VGAOUT8_INDEX(pSmi, VGA_SEQ_INDEX, VGA_SEQ_DATA, 0x44, restore->SR44);
	    /* FIFO2 Read Offset */
	    VGAOUT8_INDEX(pSmi, VGA_SEQ_INDEX, VGA_SEQ_DATA, 0x4B, restore->SR4B);
	    /* FIFO1/2 Read Offset overflow */
	    VGAOUT8_INDEX(pSmi, VGA_SEQ_INDEX, VGA_SEQ_DATA, 0x4C, restore->SR4C);

	    /* FIFO Write Offset */
	    VGAOUT8_INDEX(pSmi, VGA_SEQ_INDEX, VGA_SEQ_DATA, 0x48, restore->SR48);
	    VGAOUT8_INDEX(pSmi, VGA_SEQ_INDEX, VGA_SEQ_DATA, 0x49, restore->SR49);

	    /* set FIFO levels */
	    VGAOUT8_INDEX(pSmi, VGA_SEQ_INDEX, VGA_SEQ_DATA, 0x4A, restore->SR4A);

	    VGAOUT8_INDEX(pSmi, vgaCRIndex, vgaCRData, 0x33, restore->CR33);

	}
    }

    /* CZ 2.11.2001: for gamma correction (TODO: other chipsets?) */
    if ((pSmi->Chipset == SMI_LYNX3DM) || (pSmi->Chipset == SMI_COUGAR3DR)) {
	VGAOUT8_INDEX(pSmi, VGA_SEQ_INDEX, VGA_SEQ_DATA, 0x66, restore->CCR66);
a1204 1
    /* end CZ */
d1206 4
a1209 1
    VGAOUT8_INDEX(pSmi, VGA_SEQ_INDEX, VGA_SEQ_DATA, 0x81, 0x00);
d1211 3
a1213 32
    /* Reset the graphics engine */
    WRITE_DPR(pSmi, 0x10, restore->DPR10);
    WRITE_DPR(pSmi, 0x1C, restore->DPR1C);
    WRITE_DPR(pSmi, 0x20, restore->DPR20);
    WRITE_DPR(pSmi, 0x24, restore->DPR24);
    WRITE_DPR(pSmi, 0x28, restore->DPR28);
    WRITE_DPR(pSmi, 0x2C, restore->DPR2C);
    WRITE_DPR(pSmi, 0x30, restore->DPR30);
    WRITE_DPR(pSmi, 0x3C, restore->DPR3C);
    WRITE_DPR(pSmi, 0x40, restore->DPR40);
    WRITE_DPR(pSmi, 0x44, restore->DPR44);

    /* write video controller regs */
    WRITE_VPR(pSmi, 0x00, restore->VPR00);
    WRITE_VPR(pSmi, 0x0C, restore->VPR0C);
    WRITE_VPR(pSmi, 0x10, restore->VPR10);

    if(pSmi->Chipset == SMI_COUGAR3DR) {
	WRITE_FPR(pSmi, FPR00, restore->FPR00_);
	WRITE_FPR(pSmi, FPR0C, restore->FPR0C_);
	WRITE_FPR(pSmi, FPR10, restore->FPR10_);
    }

    WRITE_CPR(pSmi, 0x00, restore->CPR00);

    if (xf86GetVerbosity() > 1) {
	xf86DrvMsgVerb(pScrn->scrnIndex, X_INFO, VERBLEV,
		       "Done restoring mode.  Register dump:\n");
	SMI_PrintRegs(pScrn);
    }

    vgaHWProtect(pScrn, FALSE);
a1214 1
    LEAVE_PROC("SMI_WriteMode");
d1218 1
a1218 1
SMI_DetectPanelSize(ScrnInfoPtr pScrn)
d1220 14
a1233 1
    SMIPtr pSmi = SMIPTR(pScrn);
d1235 33
a1267 22
    /* panel size detection ... requires BIOS call on 730 hardware */
    if (pSmi->Chipset == SMI_COUGAR3DR) {
	if (pSmi->pInt10 != NULL) {
	    pSmi->pInt10->num = 0x10;
	    pSmi->pInt10->ax  = 0x5F00;
	    pSmi->pInt10->bx  = 0;
	    pSmi->pInt10->cx  = 0;
	    pSmi->pInt10->dx  = 0;
	    xf86ExecX86int10(pSmi->pInt10);
	    if (pSmi->pInt10->ax == 0x005F) {
		switch (pSmi->pInt10->cx & 0x0F) {
		case PANEL_640x480:
		    pSmi->lcdWidth  = 640;
		    pSmi->lcdHeight = 480;
		    break;
		case PANEL_800x600:
		    pSmi->lcdWidth  = 800;
		    pSmi->lcdHeight = 600;
		    break;
		case PANEL_1024x768:
		    pSmi->lcdWidth  = 1024;
		    pSmi->lcdHeight = 768;
d1269 2
a1270 7
		case PANEL_1280x1024:
		    pSmi->lcdWidth  = 1280;
		    pSmi->lcdHeight = 1024;
		    break;
		case PANEL_1600x1200:
		    pSmi->lcdWidth  = 1600;
		    pSmi->lcdHeight = 1200;
d1272 2
a1273 3
		case PANEL_1400x1050:
		    pSmi->lcdWidth  = 1400;
		    pSmi->lcdHeight = 1050;
a1274 17
		}
	
		xf86DrvMsg(pScrn->scrnIndex, X_INFO, "Detected panel size via BIOS: %d x %d\n",
			   pSmi->lcdWidth, pSmi->lcdHeight);
	    } else {
		xf86DrvMsg(pScrn->scrnIndex, X_INFO, "BIOS error during 730 panel detection!\n");
			   pSmi->lcdWidth  = pScrn->virtualX;
		pSmi->lcdHeight = pScrn->virtualY;
	    }
	} else  {
	    /* int10 support isn't setup on the second call to this function,
	       so if this is the second call, don't do detection again */
	    if (pSmi->lcd == 0) {
		/* If we get here, int10 support is not loaded or not working */ 
		xf86DrvMsg(pScrn->scrnIndex, X_INFO, "No BIOS support for 730 panel detection!\n");
		pSmi->lcdWidth  = pScrn->virtualX;
		pSmi->lcdHeight = pScrn->virtualY;
d1276 2
d1279 1
d1281 6
a1286 31
	/* Set this to indicate that we've done the detection */
	pSmi->lcd = 1;
    } else {
	/* panel size detection for hardware other than 730 */
	pSmi->lcd = VGAIN8_INDEX(pSmi, VGA_SEQ_INDEX, VGA_SEQ_DATA, 0x31) & 0x01;
	
	if (VGAIN8_INDEX(pSmi, VGA_SEQ_INDEX, VGA_SEQ_DATA, 0x30) & 0x01) {
	    pSmi->lcd <<= 1;
	}
	switch (VGAIN8_INDEX(pSmi, VGA_SEQ_INDEX, VGA_SEQ_DATA, 0x30) & 0x0C) {
	case 0x00:
	    pSmi->lcdWidth  = 640;
	    pSmi->lcdHeight = 480;
	    break;
	case 0x04:
	    pSmi->lcdWidth  = 800;
	    pSmi->lcdHeight = 600;
	    break;
	case 0x08:
	    if (VGAIN8_INDEX(pSmi, VGA_SEQ_INDEX, VGA_SEQ_DATA, 0x74) & 0x02) {
		pSmi->lcdWidth  = 1024;
		pSmi->lcdHeight = 600;
	    } else {
		pSmi->lcdWidth  = 1024;
		pSmi->lcdHeight = 768;
	    }
	    break;
	case 0x0C:
	    pSmi->lcdWidth  = 1280;
	    pSmi->lcdHeight = 1024;
	    break;
d1288 3
a1291 5

    xf86DrvMsg(pScrn->scrnIndex, X_INFO, "%s Panel Size = %dx%d\n",
	       (pSmi->lcd == 0) ? "OFF" : (pSmi->lcd == 1) ? "TFT" : "DSTN",
	       pSmi->lcdWidth, pSmi->lcdHeight);

d1295 1
a1295 1
SMI_MapMem(ScrnInfoPtr pScrn)
d1297 2
a1298 3
    SMIPtr pSmi = SMIPTR(pScrn);
    vgaHWPtr hwp;
    CARD32 memBase;
d1300 1
a1300 1
    ENTER_PROC("SMI_MapMem");
a1301 1
    /* Map the Lynx register space */
d1303 25
a1327 21
    default:
      memBase = PCI_REGION_BASE(pSmi->PciInfo, 0, REGION_MEM) + 0x400000;
	pSmi->MapSize = 0x10000;
	break;
    case SMI_COUGAR3DR:
        memBase = PCI_REGION_BASE(pSmi->PciInfo, 1, REGION_MEM);
	pSmi->MapSize = 0x200000;
	break;
    case SMI_LYNX3D:
	memBase = PCI_REGION_BASE(pSmi->PciInfo, 0, REGION_MEM) + 0x680000;
	pSmi->MapSize = 0x180000;
	break;
    case SMI_LYNXEM:
    case SMI_LYNXEMplus:
	memBase = PCI_REGION_BASE(pSmi->PciInfo, 0, REGION_MEM) + 0x400000;
	pSmi->MapSize = 0x400000;
	break;
    case SMI_LYNX3DM:
	memBase = PCI_REGION_BASE(pSmi->PciInfo, 0, REGION_MEM);
	pSmi->MapSize = 0x200000;
	break;
d1329 1
d1335 9
a1343 9
      void** result = (void**)&pSmi->MapBase;
      int err = pci_device_map_range(pSmi->PciInfo,
				     memBase,
				     pSmi->MapSize,
				     PCI_DEV_MAP_FLAG_WRITABLE,
				     result);
      
      if (err) 
	return FALSE;
d1346 1
d1350 1
a1350 2
	LEAVE_PROC("SMI_MapMem");
	return FALSE;
d1354 52
a1405 42
    default:
	pSmi->DPRBase = pSmi->MapBase + 0x8000;
	pSmi->VPRBase = pSmi->MapBase + 0xC000;
	pSmi->CPRBase = pSmi->MapBase + 0xE000;
	pSmi->IOBase  = NULL;
	pSmi->DataPortBase = pSmi->MapBase;
	pSmi->DataPortSize = 0x8000;
	break;
    case SMI_COUGAR3DR:
	pSmi->DPRBase = pSmi->MapBase + 0x000000;
	pSmi->VPRBase = pSmi->MapBase + 0x000800;
	pSmi->CPRBase = pSmi->MapBase + 0x001000;
	pSmi->FPRBase = pSmi->MapBase + 0x005800;
	pSmi->IOBase  = pSmi->MapBase + 0x0C0000;
	pSmi->DataPortBase = pSmi->MapBase + 0x100000;
	pSmi->DataPortSize = 0x100000;
	break;
    case SMI_LYNX3D:
	pSmi->DPRBase = pSmi->MapBase + 0x000000;
	pSmi->VPRBase = pSmi->MapBase + 0x000800;
	pSmi->CPRBase = pSmi->MapBase + 0x001000;
	pSmi->IOBase  = pSmi->MapBase + 0x040000;
	pSmi->DataPortBase = pSmi->MapBase + 0x080000;
	pSmi->DataPortSize = 0x100000;
	break;
    case SMI_LYNXEM:
    case SMI_LYNXEMplus:
	pSmi->DPRBase = pSmi->MapBase + 0x008000;
	pSmi->VPRBase = pSmi->MapBase + 0x00C000;
	pSmi->CPRBase = pSmi->MapBase + 0x00E000;
	pSmi->IOBase  = pSmi->MapBase + 0x300000;
	pSmi->DataPortBase = pSmi->MapBase /*+ 0x100000*/;
	pSmi->DataPortSize = 0x8000 /*0x200000*/;
	break;
    case SMI_LYNX3DM:
	pSmi->DPRBase = pSmi->MapBase + 0x000000;
	pSmi->VPRBase = pSmi->MapBase + 0x000800;
	pSmi->CPRBase = pSmi->MapBase + 0x001000;
	pSmi->IOBase  = pSmi->MapBase + 0x0C0000;
	pSmi->DataPortBase = pSmi->MapBase + 0x100000;
	pSmi->DataPortSize = 0x100000;
	break;
d1407 1
d1420 67
d1489 21
a1509 1
    SMI_EnableMmio(pScrn);
d1511 4
a1514 6
    if (pSmi->videoRAMBytes) {
	/* Map the frame buffer */
	if (pSmi->Chipset == SMI_LYNX3DM) 
	    pSmi->fbMapOffset = 0x200000;
	else
	    pSmi->fbMapOffset = 0x0;
d1516 5
a1520 1
	pSmi->FBOffset = 0;
d1522 6
a1527 1
	pScrn->fbOffset = pSmi->FBOffset + pSmi->fbMapOffset;
d1529 5
a1533 6
#ifndef XSERVER_LIBPCIACCESS
	pSmi->FBBase = xf86MapPciMem(pScrn->scrnIndex,
				     VIDMEM_FRAMEBUFFER,
				     pSmi->PciTag,
				     pScrn->memPhysBase + pSmi->fbMapOffset,
				     pSmi->videoRAMBytes);
d1535 14
a1548 11
	{
	  void** result = (void**)&pSmi->FBBase;
	  int err = pci_device_map_range(pSmi->PciInfo,
					 pScrn->memPhysBase + pSmi->fbMapOffset,
					 pSmi->videoRAMBytes,
					 PCI_DEV_MAP_FLAG_WRITABLE |
					 PCI_DEV_MAP_FLAG_WRITE_COMBINE,
					 result);
	  
	  if (err) 
	    return FALSE;
d1550 2
d1553 3
a1555 16
	    
	if (pSmi->FBBase == NULL) {
	    xf86DrvMsg(pScrn->scrnIndex, X_ERROR, "Internal error: could not "
		       "map framebuffer.\n");
	    LEAVE_PROC("SMI_MapMem");
	    return FALSE;
	}

	xf86DrvMsgVerb(pScrn->scrnIndex, X_INFO, VERBLEV,
		       "Physical frame buffer at 0x%08lX offset: 0x%08lX\n",
		       pScrn->memPhysBase, pScrn->fbOffset);
	xf86DrvMsgVerb(pScrn->scrnIndex, X_INFO, VERBLEV,
		       "Logical frame buffer at %p - %p\n", pSmi->FBBase,
		       pSmi->FBBase + pSmi->videoRAMBytes - 1);

	/* Set up offset to hwcursor memory area.  It's a 1K chunk at the end of
d1558 1
a1558 6
	pSmi->FBCursorOffset = pSmi->videoRAMBytes - 1024;

	xf86DrvMsg(pScrn->scrnIndex, X_INFO,
		   "Cursor Offset: %08lX\n",
		   (unsigned long)pSmi->FBCursorOffset);

d1562 6
a1567 4
	    fifoOffset |= VGAIN8_INDEX(pSmi, VGA_SEQ_INDEX, VGA_SEQ_DATA, 0x46) << 3;
	    fifoOffset |= VGAIN8_INDEX(pSmi, VGA_SEQ_INDEX, VGA_SEQ_DATA, 0x47) << 11;
	    fifoOffset |= (VGAIN8_INDEX(pSmi, VGA_SEQ_INDEX, VGA_SEQ_DATA, 0x49)
			& 0x1C) << 17;
d1569 2
a1570 1
	} else {
a1571 1
	}
d1573 2
a1574 2
	xf86DrvMsg(pScrn->scrnIndex, X_INFO, "Reserved: %08lX\n",
		   (unsigned long)pSmi->FBReserved);
d1576 5
a1580 1
    }
d1582 7
a1588 4
    /* Assign hwp->MemBase & IOBase here */
    hwp = VGAHWPTR(pScrn);
    if (pSmi->IOBase != NULL) {
	vgaHWSetMmioFuncs(hwp, pSmi->MapBase, pSmi->IOBase - pSmi->MapBase);
a1589 1
    vgaHWGetIOBase(hwp);
d1591 2
a1592 9
    /* Map the VGA memory when the primary video */
    if (xf86IsPrimaryPci(pSmi->PciInfo)) {
	hwp->MapSize = 0x10000;
	if (!vgaHWMapMem(pScrn)) {
	    LEAVE_PROC("SMI_MapMem");
	    return FALSE;
	}
	pSmi->PrimaryVidMapped = TRUE;
    }
d1594 1
a1594 2
    LEAVE_PROC("SMI_MapMem");
    return TRUE;
d1601 1
a1601 1
static void
d1606 1
a1606 1
    ENTER_PROC("SMI_UnmapMem");
d1616 13
a1628 2
    xf86UnMapVidMem(pScrn->scrnIndex, (pointer) pSmi->MapBase, pSmi->MapSize);
    if (pSmi->FBBase != NULL) {
d1631 5
d1638 1
a1638 1
    LEAVE_PROC("SMI_UnmapMem");
d1646 3
a1648 3
    ScrnInfoPtr pScrn = xf86Screens[pScreen->myNum];
    SMIPtr pSmi = SMIPTR(pScrn);
    EntityInfoPtr pEnt;
d1650 1
a1650 1
    ENTER_PROC("SMI_ScreenInit");
d1653 2
a1654 4
    if (!SMI_MapMem(pScrn)) {
	LEAVE_PROC("SMI_ScreenInit");
	return FALSE;
    }
d1657 2
a1658 2
	
    if (!pSmi->pInt10) {
d1661 3
d1666 14
a1679 3
    SMI_Save(pScrn);
	
    /* Zero the frame buffer, #258 */
a1681 6
    /* Initialize the first mode */
    if (!SMI_ModeInit(pScrn, pScrn->currentMode)) {
	LEAVE_PROC("SMI_ScreenInit");
	return FALSE;
    }

d1691 4
a1694 385
    /*
     * Reset the visual list.
     */
    miClearVisualTypes();

    /* Setup the visuals we support. */

    if (!miSetVisualTypes(pScrn->depth, miGetDefaultVisualMask(pScrn->depth),
			  pScrn->rgbBits, pScrn->defaultVisual)) {
	LEAVE_PROC("SMI_ScreenInit");
	return FALSE;
    }
    if (!miSetPixmapDepths ()) return FALSE;

    if (!SMI_InternalScreenInit(scrnIndex, pScreen)) {
	LEAVE_PROC("SMI_ScreenInit");
	return FALSE;
    }

    xf86SetBlackWhitePixels(pScreen);

    if (pScrn->bitsPerPixel > 8) {
	VisualPtr visual;
	/* Fixup RGB ordering */
	visual = pScreen->visuals + pScreen->numVisuals;
	while (--visual >= pScreen->visuals) {
	    if ((visual->class | DynamicClass) == DirectColor) {
		visual->offsetRed   = pScrn->offset.red;
		visual->offsetGreen = pScrn->offset.green;
		visual->offsetBlue  = pScrn->offset.blue;
		visual->redMask     = pScrn->mask.red;
		visual->greenMask   = pScrn->mask.green;
		visual->blueMask    = pScrn->mask.blue;
	    }
	}
    }

    /* must be after RGB ordering fixed */
    fbPictureInit(pScreen, 0, 0);
 
    /* CZ 18.06.2001: moved here from smi_accel.c to have offscreen
       framebuffer in NoAccel mode */
    if (!pSmi->useEXA) {
	int numLines, maxLines;
	BoxRec AvailFBArea;
 
	maxLines = pSmi->FBReserved / (pSmi->width * pSmi->Bpp);
	if (pSmi->rotate) {
	    numLines = maxLines;
	} else {
	    /* CZ 3.11.2001: What does the following code? see also smi_video.c aaa line 1226 */
/*#if SMI_USE_VIDEO */
#if 0
	    numLines = ((pSmi->FBReserved - pSmi->width * pSmi->Bpp
			* pSmi->height) * 25 / 100 + pSmi->width
			* pSmi->Bpp - 1) / (pSmi->width * pSmi->Bpp);
	    numLines += pSmi->height;
#else
	    numLines = maxLines;
#endif
	}
 
	AvailFBArea.x1 = 0;
	AvailFBArea.y1 = 0;
	AvailFBArea.x2 = pSmi->width;
	AvailFBArea.y2 = numLines;
	xf86DrvMsg(pScrn->scrnIndex, X_INFO,
		   "FrameBuffer Box: %d,%d - %d,%d\n",
		   AvailFBArea.x1, AvailFBArea.y1, AvailFBArea.x2,
		   AvailFBArea.y2);
	xf86InitFBManager(pScreen, &AvailFBArea);
    }
    /* end CZ */
	
	
    /* Initialize acceleration layer */
    if (!pSmi->NoAccel) {
	if (!pSmi->useEXA) {
	    if (!SMI_XAAInit(pScreen)) {
		LEAVE_PROC("SMI_ScreenInit");
		return FALSE;
	    }
	} else {
	    if (!SMI_EXAInit(pScreen)) {
		LEAVE_PROC("SMI_ScreenInit");
		return FALSE;
	    }
	}
    }
	
    miInitializeBackingStore(pScreen);
	
    /* hardware cursor needs to wrap this layer */
    if(!pSmi->NoAccel && !pSmi->useEXA)
	SMI_DGAInit(pScreen);
	
    /* Initialise cursor functions */
    miDCInitialize(pScreen, xf86GetPointerScreenFuncs());

    /* Initialize HW cursor layer.  Must follow software cursor
     * initialization.
     */
    if (pSmi->hwcursor) {
	if (!SMI_HWCursorInit(pScreen)) {
	    xf86DrvMsg(pScrn->scrnIndex, X_ERROR, "Hardware cursor "
		       "initialization failed\n");
	}
    }

    if (pSmi->shadowFB) {
	RefreshAreaFuncPtr refreshArea;

	if (pSmi->Chipset == SMI_COUGAR3DR) {
	    refreshArea = SMI_RefreshArea730;
	} else {
	    refreshArea = SMI_RefreshArea;
	}

	if (pSmi->rotate) {
	    if (pSmi->PointerMoved == NULL) {
		pSmi->PointerMoved  = pScrn->PointerMoved;
		pScrn->PointerMoved = SMI_PointerMoved;
	    }
	}

	ShadowFBInit(pScreen, refreshArea);
    }

    /* Initialise default colormap */
    if (!miCreateDefColormap(pScreen)) {
	LEAVE_PROC("SMI_ScreenInit");
	return FALSE;
    }

    /* Initialize colormap layer.  Must follow initialization of the default
     * colormap.  And SetGamma call, else it will load palette with solid white.
     */
    /* CZ 2.11.2001: CMAP_PALETTED_TRUECOLOR for gamma correction */
    if (!xf86HandleColormaps(pScreen, 256, pScrn->rgbBits, SMI_LoadPalette, NULL,
            CMAP_RELOAD_ON_MODE_SWITCH | CMAP_PALETTED_TRUECOLOR)) {
	LEAVE_PROC("SMI_ScreenInit");
	return FALSE;
    }

    pScreen->SaveScreen = SMI_SaveScreen;
    pSmi->CloseScreen = pScreen->CloseScreen;
    pScreen->CloseScreen = SMI_CloseScreen;

    if (!xf86DPMSInit(pScreen, SMI_DisplayPowerManagementSet, 0)) {
	xf86DrvMsg(pScrn->scrnIndex, X_ERROR, "DPMS initialization failed!\n");
    }

    if (!pSmi->Dualhead)
  	SMI_InitVideo(pScreen);
    else 
	xf86DrvMsg(pScrn->scrnIndex, X_INFO, "No overlay in dualhead mode\n");

    /* Report any unused options (only for the first generation) */
    if (serverGeneration == 1) {
	xf86ShowUnusedOptions(pScrn->scrnIndex, pScrn->options);
    }
	
    LEAVE_PROC("SMI_ScreenInit");
    return TRUE;
}

/* Common init routines needed in EnterVT and ScreenInit */

static int
SMI_InternalScreenInit(int scrnIndex, ScreenPtr pScreen)
{
    ScrnInfoPtr pScrn = xf86Screens[pScreen->myNum];
    SMIPtr pSmi = SMIPTR(pScrn);
    int width, height, displayWidth;
    int bytesPerPixel = pScrn->bitsPerPixel / 8;
    int xDpi, yDpi;
    int ret;

    ENTER_PROC("SMI_InternalScreenInit");

    if (pSmi->rotate) {
	width        = pScrn->virtualY;
	height       = pScrn->virtualX;
	xDpi         = pScrn->yDpi;
	yDpi         = pScrn->xDpi;
	displayWidth = ((width * bytesPerPixel + 15) & ~15) / bytesPerPixel;
    } else {
	width        = pScrn->virtualX;
	height       = pScrn->virtualY;
	xDpi		 = pScrn->xDpi;
	yDpi		 = pScrn->yDpi;
	displayWidth = pScrn->displayWidth;
    }

    if (pSmi->shadowFB) {
	pSmi->ShadowWidth      = width;
	pSmi->ShadowHeight     = height;
	pSmi->ShadowWidthBytes = (width * bytesPerPixel + 15) & ~15;
	if (bytesPerPixel == 3) {
	    pSmi->ShadowPitch = ((height * 3) << 16)
			      | pSmi->ShadowWidthBytes;
	} else {
	    pSmi->ShadowPitch = (height << 16)
			      | (pSmi->ShadowWidthBytes / bytesPerPixel);
	}

	pSmi->saveBufferSize = pSmi->ShadowWidthBytes * pSmi->ShadowHeight;
	pSmi->FBReserved -= pSmi->saveBufferSize;
	pSmi->FBReserved &= ~0x15;
	WRITE_VPR(pSmi, 0x0C, (pSmi->FBOffset = pSmi->FBReserved) >> 3);
	if (pSmi->Chipset == SMI_COUGAR3DR) {
	    WRITE_FPR(pSmi, FPR0C, (pSmi->FBOffset = pSmi->FBReserved) >> 3);
	}
	pScrn->fbOffset = pSmi->FBOffset + pSmi->fbMapOffset;
	xf86DrvMsg(pScrn->scrnIndex, X_INFO,
		   "Shadow: width=%d height=%d "
		   "offset=0x%08lX pitch=0x%08X\n",
		   pSmi->ShadowWidth, pSmi->ShadowHeight,
		   (unsigned long)pSmi->FBOffset,
		   pSmi->ShadowPitch);
    } else {
	pSmi->FBOffset = 0;
	pScrn->fbOffset = pSmi->FBOffset + pSmi->fbMapOffset;
    }

    /*
     * Call the framebuffer layer's ScreenInit function, and fill in other
     * pScreen fields.
     */

    DEBUG((VERBLEV, "\tInitializing FB @@ 0x%08X for %dx%d (%d)\n",
	   pSmi->FBBase, width, height, displayWidth));
    switch (pScrn->bitsPerPixel) {
    case 8:
    case 16:
    case 24:
    case 32:
	ret = fbScreenInit(pScreen, pSmi->FBBase, width, height, xDpi,
			   yDpi, displayWidth, pScrn->bitsPerPixel);
	break;
    default:
	xf86DrvMsg(scrnIndex, X_ERROR, "Internal error: invalid bpp (%d) "
		   "in SMI_InternalScreenInit\n", pScrn->bitsPerPixel);
	LEAVE_PROC("SMI_InternalScreenInit");
	return FALSE;
    }
	
    LEAVE_PROC("SMI_InternalScreenInit");
    return ret;
}

/* Checks if a mode is suitable for the selected configuration. */
static ModeStatus
SMI_ValidMode(int scrnIndex, DisplayModePtr mode, Bool verbose, int flags)
{
    ScrnInfoPtr pScrn = xf86Screens[scrnIndex];
    SMIPtr pSmi = SMIPTR(pScrn);
    float refresh;

    ENTER_PROC("SMI_ValidMode");
    refresh = (mode->VRefresh > 0) ? mode->VRefresh 
	    : mode->Clock * 1000.0 / mode->VTotal / mode->HTotal;
    xf86DrvMsg(scrnIndex, X_INFO, "Mode: %dx%d %d-bpp, %fHz\n", mode->HDisplay,
	       mode->VDisplay, pScrn->bitsPerPixel, refresh);

    if (pSmi->shadowFB) {
	int mem;

	if (pScrn->bitsPerPixel == 24) {
	    LEAVE_PROC("SMI_ValidMode");
	    return MODE_BAD;
	}

	mem  = (pScrn->virtualX * pScrn->bitsPerPixel / 8 + 15) & ~15;
	mem *= pScrn->virtualY * 2;

	if (mem > pSmi->FBReserved) /* PDR#1074 */ {
	    LEAVE_PROC("SMI_ValidMode");
	    return MODE_MEM;
	}
    }

    if (!pSmi->useBIOS || pSmi->lcd) {
#if 1 /* PDR#983 */
	if (pSmi->zoomOnLCD) {
	    if ((mode->HDisplay > pSmi->lcdWidth) ||
		(mode->VDisplay > pSmi->lcdHeight)) {
		LEAVE_PROC("SMI_ValidMode");
		return MODE_PANEL;
	    }
	} else
#endif
	{
	    if ((mode->HDisplay != pSmi->lcdWidth) ||
		(mode->VDisplay != pSmi->lcdHeight)) {
		LEAVE_PROC("SMI_ValidMode");
		return MODE_PANEL;
	    }
	}
    }

#if 1 /* PDR#944 */
    if (pSmi->rotate) {
	if ((mode->HDisplay != pSmi->lcdWidth) ||
	    (mode->VDisplay != pSmi->lcdHeight)) {
	    LEAVE_PROC("SMI_ValidMode");
	    return MODE_PANEL;
	}
    }
#endif

    LEAVE_PROC("SMI_ValidMode");
    return MODE_OK;
}

static void
SMI_DPRInit(ScrnInfoPtr pScrn)
{
    SMIPtr pSmi = SMIPTR(pScrn);
    int i;
    int xyAddress[] = { 320, 400, 512, 640, 800, 1024, 1280, 1600, 2048 };
    CARD32 DEDataFormat = 0;

    /* Store values to current mode register structs */
    SMIRegPtr new = &pSmi->ModeReg;

    /* Set DPR registers */
    pSmi->Stride = (pSmi->width * pSmi->Bpp + 15) & ~15;
    switch (pScrn->bitsPerPixel) {
    case 8:
	DEDataFormat = 0x00000000;
	break;
    case 16:
	pSmi->Stride >>= 1;
	DEDataFormat = 0x00100000;
	break;
    case 24:
	DEDataFormat = 0x00300000;
	break;
    case 32:
	pSmi->Stride >>= 2;
	DEDataFormat = 0x00200000;
	break;
    }

    for (i = 0; i < sizeof(xyAddress) / sizeof(xyAddress[0]); i++) {
	if (pSmi->rotate) {
	    if (xyAddress[i] == pSmi->height) {
		DEDataFormat |= i << 16;
		break;
	    }
	} else {
	    if (xyAddress[i] == pSmi->width) {
		DEDataFormat |= i << 16;
		break;
	    }
	}
    }

    new->DPR10 = (pSmi->Stride << 16) | pSmi->Stride;
    new->DPR1C = DEDataFormat;
    new->DPR20 = 0;
    new->DPR24 = 0xFFFFFFFF;
    new->DPR28 = 0xFFFFFFFF;
    new->DPR2C = 0;
    new->DPR30 = 0;
    new->DPR3C = (pSmi->Stride << 16) | pSmi->Stride;
    new->DPR40 = pSmi->FBOffset >> 3;
    new->DPR44 = pSmi->FBOffset >> 3;

}

static Bool
SMI_ModeInit(ScrnInfoPtr pScrn, DisplayModePtr mode)
{
    vgaHWPtr hwp = VGAHWPTR(pScrn);
    SMIPtr pSmi = SMIPTR(pScrn);
    unsigned char tmp;
    int panelIndex, modeIndex, i, vclk;

    /* Store values to current mode register structs */
    SMIRegPtr new = &pSmi->ModeReg;
    vgaRegPtr vganew = &hwp->ModeReg;
	
    ENTER_PROC("SMI_ModeInit");
d1696 1
a1696 4
    if (!vgaHWInit(pScrn, mode)) {
	LEAVE_PROC("SMI_ModeInit");
	return FALSE;
    }
d1698 3
a1700 1
    new->modeInit = TRUE;
d1702 2
a1703 8
    if (pSmi->rotate) {
	pSmi->width  = pScrn->virtualY;
	pSmi->height = pScrn->virtualX;
    } else {
	pSmi->width  = pScrn->virtualX;
	pSmi->height = pScrn->virtualY;
    }
    pSmi->Bpp    = pScrn->bitsPerPixel / 8;
d1705 3
a1707 7
    outb(pSmi->PIOBase + VGA_SEQ_INDEX, 0x17);
    tmp = inb(pSmi->PIOBase + VGA_SEQ_DATA);
    if (pSmi->pci_burst) {
	new->SR17 = tmp | 0x20;
    } else {
	new->SR17 = tmp & ~0x20;
    }
d1709 5
a1713 2
    outb(pSmi->PIOBase + VGA_SEQ_INDEX, 0x18);
    new->SR18 = inb(pSmi->PIOBase + VGA_SEQ_DATA) | 0x11;
d1715 1
a1715 2
    outb(pSmi->PIOBase + VGA_SEQ_INDEX, 0x21);
    new->SR21 = inb(pSmi->PIOBase + VGA_SEQ_DATA) & ~0x03;
d1717 13
a1729 9
    if (pSmi->Chipset != SMI_COUGAR3DR) {
	outb(pSmi->PIOBase + VGA_SEQ_INDEX, 0x31);
	new->SR31 = inb(pSmi->PIOBase + VGA_SEQ_DATA) & ~0xC0;

	outb(pSmi->PIOBase + VGA_SEQ_INDEX, 0x32);
	new->SR32 = inb(pSmi->PIOBase + VGA_SEQ_DATA) & ~0x07;

	if (SMI_LYNXM_SERIES(pSmi->Chipset)) {
	    new->SR32 |= 0x04;
d1733 12
a1744 1
    new->SRA0 = new->CR33 = new->CR3A = 0x00;
d1746 5
a1750 7
    if (pSmi->lcdWidth == 640) {
	panelIndex = 0;
    } else if (pSmi->lcdWidth == 800) {
	panelIndex = 1;
    } else {
	panelIndex = 2;
    }
d1752 4
a1755 7
    if (mode->HDisplay == 640) {
	modeIndex = 0;
    } else if (mode->HDisplay == 800) {
	modeIndex = 1;
    } else {
	modeIndex = 2;
    }
d1757 1
a1757 59
    if (SMI_LYNXM_SERIES(pSmi->Chipset)) {
	static unsigned char PanelTable[3][14] =
	    {
		{ 0x5F, 0x4F, 0x00, 0x52, 0x1E, 0x0B, 0xDF, 0x00, 0xE9, 0x0B, 0x2E,
		  0x00, 0x4F, 0xDF },
		{ 0x7F, 0x63, 0x00, 0x69, 0x19, 0x72, 0x57, 0x00, 0x58, 0x0C, 0xA2,
		  0x20, 0x4F, 0xDF },
		{ 0xA3, 0x7F, 0x00, 0x83, 0x14, 0x24, 0xFF, 0x00, 0x02, 0x08, 0xA7,
		  0xE0, 0x4F, 0xDF },
	    };

	for (i = 0; i < 14; i++) {
	    new->CR40[i] = PanelTable[panelIndex][i];
	}
	new->CR90[14] = 0x03;
	new->CR90[15] = 0x00;
	if (mode->VDisplay < pSmi->lcdHeight) {
	    new->CRA0[6] = (pSmi->lcdHeight - mode->VDisplay) / 8;
	} else {
	    new->CRA0[6] = 0;
	}

	if (mode->HDisplay < pSmi->lcdWidth) {
	    new->CRA0[7] = (pSmi->lcdWidth - mode->HDisplay) / 16;
	} else {
	    new->CRA0[7] = 0;
	}
    } else {
	static unsigned char PanelTable[3][3][14] =
	    {
		{ /* 640x480 panel */
		    { 0x5F, 0x4F, 0x00, 0x53, 0x00, 0x0B, 0xDF, 0x00, 0xEA, 0x0C,
		      0x2E, 0x00, 0x4F, 0xDF },
		    { 0x5F, 0x4F, 0x00, 0x53, 0x00, 0x0B, 0xDF, 0x00, 0xEA, 0x0C,
		      0x2E, 0x00, 0x4F, 0xDF },
		    { 0x5F, 0x4F, 0x00, 0x53, 0x00, 0x0B, 0xDF, 0x00, 0xEA, 0x0C,
		      0x2E, 0x00, 0x4F, 0xDF },
		},
		{ /* 800x600 panel */
		    { 0x7F, 0x59, 0x19, 0x5E, 0x8E, 0x72, 0x1C, 0x37, 0x1D, 0x00,
		      0xA2, 0x20, 0x4F, 0xDF },
		    { 0x7F, 0x63, 0x00, 0x68, 0x18, 0x72, 0x58, 0x00, 0x59, 0x0C,
		      0xE0, 0x20, 0x63, 0x57 },
		    { 0x7F, 0x63, 0x00, 0x68, 0x18, 0x72, 0x58, 0x00, 0x59, 0x0C,
		      0xE0, 0x20, 0x63, 0x57 },
		},
		{ /* 1024x768 panel */
		    { 0xA3, 0x67, 0x0F, 0x6D, 0x1D, 0x24, 0x70, 0x95, 0x72, 0x07,
		      0xA3, 0x20, 0x4F, 0xDF },
		    { 0xA3, 0x71, 0x19, 0x77, 0x07, 0x24, 0xAC, 0xD1, 0xAE, 0x03,
		      0xE1, 0x20, 0x63, 0x57 },
		    { 0xA3, 0x7F, 0x00, 0x85, 0x15, 0x24, 0xFF, 0x00, 0x01, 0x07,
		      0xE5, 0x20, 0x7F, 0xFF },
		},
	    };

	for (i = 0; i < 14; i++) {
	    new->CR40[i] = PanelTable[panelIndex][modeIndex][i];
	}
d1760 6
a1765 19
    /* CZ 2.11.2001: for gamma correction (TODO: other chipsets?) */
    new->CCR66 = VGAIN8_INDEX(pSmi, VGA_SEQ_INDEX, VGA_SEQ_DATA, 0x66);
    if ((pSmi->Chipset == SMI_LYNX3DM) || (pSmi->Chipset == SMI_COUGAR3DR)) {
	switch (pScrn->bitsPerPixel) {
	case 8:
	    new->CCR66 = (new->CCR66 & 0xF3) | 0x00; /* 6 bits-RAM */
	    break;
	case 16:
	    new->CCR66 = (new->CCR66 & 0xF3) | 0x00; /* 6 bits-RAM */
	    /* no Gamma correction in 16 Bit mode (s. Release.txt 1.3.1) */
	    break;
	case 24:
	case 32:
	    new->CCR66 = (new->CCR66 & 0xF3) | 0x04; /* Gamma correct ON */
	    break;
	default:
	    LEAVE_PROC("SMI_ModeInit");
	    return FALSE;
	}
d1768 3
a1770 6
    if (pSmi->Chipset != SMI_COUGAR3DR) {
	outb(pSmi->PIOBase + VGA_SEQ_INDEX, 0x30);
	if (inb(pSmi->PIOBase + VGA_SEQ_DATA) & 0x01) {
	    new->SR21 = 0x00;
	}
    }
d1772 3
a1774 9
    if (pSmi->MCLK > 0) {
	SMI_CommonCalcClock(pScrn->scrnIndex, pSmi->MCLK,
			    1, 1, 63, 0, 0,
                            pScrn->clockRanges->minClock,
                            pScrn->clockRanges->maxClock,
                            &new->SR6A, &new->SR6B);
    } else {
	new->SR6B = 0xFF;
    }
d1776 1
a1776 63
    if ((mode->HDisplay == 640) && SMI_LYNXM_SERIES(pSmi->Chipset)) {
	vganew->MiscOutReg &= ~0x0C;
    } else {
	vganew->MiscOutReg |= 0x0C;
    }
    vganew->MiscOutReg |= 0xE0;
    if (mode->HDisplay == 800) {
	vganew->MiscOutReg &= ~0xC0;
    }
    if ((mode->HDisplay == 1024) && SMI_LYNXM_SERIES(pSmi->Chipset)) {
	vganew->MiscOutReg &= ~0xC0;
    }

    /* calculate vclk1 */
    vclk = mode->Clock;
    if (SMI_LYNX_SERIES(pSmi->Chipset)) {
        SMI_CommonCalcClock(pScrn->scrnIndex, vclk,
			1, 1, 63, 0, 3,
                        pScrn->clockRanges->minClock,
                        pScrn->clockRanges->maxClock,
                        &new->SR6C, &new->SR6D);
    } else {
        SMI_CommonCalcClock(pScrn->scrnIndex, vclk,
			1, 1, 63, 0, 1,
                        pScrn->clockRanges->minClock,
                        pScrn->clockRanges->maxClock,
                        &new->SR6C, &new->SR6D);
    }

    /* use vclk1 */
    new->SR68 = 0x54;

    /* dualhead */
    if (pSmi->Dualhead) {
	/* PLL controls */
	/* set LCD to vclk2 */
	new->SR69 = 0x04;

	if (pSmi->lcdWidth == 640) {
	    /* vclk */
	    new->SR6C = 0x07;
	    new->SR6D = 0x04;

	    /* vclk2 */
	    new->SR6E = 0x07;
	    new->SR6F = 0x04;
	} else if (pSmi->lcdWidth == 800) {
	    /* vclk */
	    new->SR6C = 0x0B;
	    new->SR6D = 0x82;

	    /* vclk2 */
	    new->SR6E = 0x0B;
	    new->SR6F = 0x82;
	} else {
	    /* vclk */
	    new->SR6C = 0x52;
	    new->SR6D = 0x89;

	    /* vclk2 */
	    new->SR6E = 0x52;
	    new->SR6F = 0x89;
	}
d1778 3
a1780 5
	/* TFT panel uses FIFO1, DSTN panel uses FIFO1 for upper panel and 
	 * FIFO2 for lower panel.  I don't have a DSTN panel, so it's untested.
	 * -- AGD
	 */
	CARD32 fifo1_readoffset, fifo2_readoffset, fifo_writeoffset;
d1782 2
a1783 5
	/* setting SR21 bit 2 disables ZV circuitry, 
	 * if ZV is needed, SR21 = 0x20
	 */
	/* enable DAC, PLL, etc. */
	new->SR21 = 0x24;
d1785 5
a1789 2
	/* clear DPMS state */
	new->SR22 = VGAIN8_INDEX(pSmi, VGA_SEQ_INDEX, VGA_SEQ_DATA, 0x22) & ~0x30;
d1791 18
a1808 26
	/* enable virtual refresh and LCD and CRT outputs */
	if (pScrn->bitsPerPixel > 8)
	    new->SR31 = /*0xCB*/ 0xC3; /* 16 bpp */
	else
	    new->SR31 = /*0x8B*/ 0x83; /* 8 bpp */

	/* FIFO1 Read Offset */
	fifo1_readoffset = pSmi->lcdWidth / 2;
	fifo2_readoffset = pSmi->lcdWidth / 2;
	new->SR44 = fifo1_readoffset & 0x000000FF;
	/* FIFO2 Read Offset */
	new->SR4B = fifo2_readoffset & 0x000000FF;
	/* FIFO1/2 Read Offset overflow */
	new->SR4C = (((fifo1_readoffset & 0x00000300) >> 8) << 2) |
		    (((fifo2_readoffset & 0x00000300) >> 8) << 6);

	/* FIFO Write Offset */
	fifo_writeoffset = pSmi->lcdWidth / 4;
	new->SR48 = fifo_writeoffset & 0x000000FF;
	new->SR49 = (fifo_writeoffset & 0x00000300) >> 8;

	/* set FIFO levels */
	new->SR4A = 0x41;

	/* something related to tv... */
	new->CR33 |= 0x07;
d1810 3
d1815 3
a1817 30
    /* init graphics engine regs */
    SMI_DPRInit(pScrn);

    /* Set VPR registers (and FPR registers for SM731) */
    switch (pScrn->bitsPerPixel) {
    case 8:
	new->VPR00 = 0x00000000;
	new->FPR00_= 0x00080000;
	break;
    case 16:
	new->VPR00 = 0x00020000;
	new->FPR00_= 0x000A0000;
	break;
    case 24:
	new->VPR00 = 0x00040000;
	new->FPR00_= 0x000C0000;
	break;
    case 32:
	new->VPR00 = 0x00030000;
	new->FPR00_= 0x000B0000;
	break;
    }
    new->VPR0C = pSmi->FBOffset >> 3;
    if (pSmi->rotate) {
	new->VPR10 = (((( pSmi->height * pSmi->Bpp) >> 3) + 2) << 16) |
		     ((pSmi->height * pSmi->Bpp) >> 3);
    } else {
	new->VPR10 = ((((pSmi->width * pSmi->Bpp) >> 3) + 2) << 16) |
		     ((pSmi->width * pSmi->Bpp) >> 3);
    }
d1819 6
a1824 2
    new->FPR0C_ = new->VPR0C;
    new->FPR10_ = new->VPR10;
d1826 3
a1828 2
    /* Set CPR registers */
    new->CPR00 = 0x00000000;
d1830 5
a1834 40
    pScrn->vtSema = TRUE;

    /* Find the INT 10 mode number */
    {
	static struct {
	    int x, y, bpp;
	    CARD16 mode;
	} modeTable[] =
	    {
		{  640,  480,  8, 0x50 },
		{  640,  480, 16, 0x52 },
		{  640,  480, 24, 0x53 },
		{  640,  480, 32, 0x54 },
		{  800,  480,  8, 0x4A },
		{  800,  480, 16, 0x4C },
		{  800,  480, 24, 0x4D },
		{  800,  600,  8, 0x55 },
		{  800,  600, 16, 0x57 },
		{  800,  600, 24, 0x58 },
		{  800,  600, 32, 0x59 },
		{ 1024,  768,  8, 0x60 },
		{ 1024,  768, 16, 0x62 },
		{ 1024,  768, 24, 0x63 },
		{ 1024,  768, 32, 0x64 },
		{ 1280, 1024,  8, 0x65 },
		{ 1280, 1024, 16, 0x67 },
		{ 1280, 1024, 24, 0x68 },
		{ 1280, 1024, 32, 0x69 },
	    };

	new->mode = 0;
	for (i = 0; i < sizeof(modeTable) / sizeof(modeTable[0]); i++) {
	    if ((modeTable[i].x == mode->HDisplay) &&
		(modeTable[i].y == mode->VDisplay) &&
		(modeTable[i].bpp == pScrn->bitsPerPixel)) {
		new->mode = modeTable[i].mode;
		break;
	    }
	}
    }
d1836 1
a1836 2
    /* Zero the font memory */
    memset(new->smiFont, 0, sizeof(new->smiFont));
d1838 2
a1839 2
    /* Write the mode registers to hardware */
    SMI_WriteMode(pScrn, vganew, new);
d1841 4
a1844 2
    /* Adjust the viewport */
    SMI_AdjustFrame(pScrn->scrnIndex, pScrn->frameX0, pScrn->frameY0, 0);
d1846 1
a1846 2
    LEAVE_PROC("SMI_ModeInit");
    return TRUE;
d1859 3
a1861 6
    ScrnInfoPtr pScrn = xf86Screens[scrnIndex];
    vgaHWPtr hwp = VGAHWPTR(pScrn);
    SMIPtr pSmi = SMIPTR(pScrn);
    vgaRegPtr vgaSavePtr = &hwp->SavedReg;
    SMIRegPtr SMISavePtr = &pSmi->SavedReg;
    Bool ret;
d1863 1
a1863 1
    ENTER_PROC("SMI_CloseScreen");
d1865 6
a1870 5
    if (pScrn->vtSema) {
	SMI_WriteMode(pScrn, vgaSavePtr, SMISavePtr);
	vgaHWLock(hwp);
	SMI_UnmapMem(pScrn);
    }
d1879 3
a1881 5
    if (pSmi->CursorInfoRec != NULL) {
	xf86DestroyCursorInfoRec(pSmi->CursorInfoRec);
    }
    if (pSmi->DGAModes != NULL) {
	xfree(pSmi->DGAModes);
a1892 8
    /* #670 */
    if (pSmi->pSaveBuffer) {
	xfree(pSmi->pSaveBuffer);
    }
/* #920 */
    if (pSmi->paletteBuffer) {
	xfree(pSmi->paletteBuffer);
    }
d1898 1
a1898 2
    LEAVE_PROC("SMI_CloseScreen");
    return ret;
d1910 1
a1910 1
    Bool ret;
d1912 1
a1912 1
    ENTER_PROC("SMI_SaveScreen");
d1914 5
a1918 1
    ret = vgaHWSaveScreen(pScreen, mode);
d1920 1
a1920 2
    LEAVE_PROC("SMI_SaveScreen");
    return ret;
d1926 2
a1927 35
    ScrnInfoPtr pScrn = xf86Screens[scrnIndex];
    SMIPtr pSmi = SMIPTR(pScrn);
    CARD32 Base, lcdBase;

    ENTER_PROC("SMI_AdjustFrame");

    if (pSmi->ShowCache && y) {
	y += pScrn->virtualY - 1;
    }

    if (pSmi->Dualhead) {
	lcdBase = 0;
	x = pSmi->lcdWidth;
	y = 0;
    }

    Base = pSmi->FBOffset + (x + y * pScrn->virtualX) * pSmi->Bpp;
    if (SMI_LYNX3D_SERIES(pSmi->Chipset) ||
	SMI_COUGAR_SERIES(pSmi->Chipset)) {
	Base = (Base + 15) & ~15;
#if 1 /* PDR#1058 */
	while ((Base % pSmi->Bpp) > 0) {
	    Base -= 16;
	}
#endif
    } else {
	Base = (Base + 7) & ~7;
#if 1 /* PDR#1058 */
	while ((Base % pSmi->Bpp) > 0) {
	    Base -= 8;
	}
#endif
    }

    if (pSmi->Dualhead) {
d1929 1
a1929 5
	/* FIFO1 read start address */
	VGAOUT8_INDEX(pSmi, VGA_SEQ_INDEX, VGA_SEQ_DATA, 0x40, 
			 (lcdBase & 0x000000FF));
	VGAOUT8_INDEX(pSmi, VGA_SEQ_INDEX, VGA_SEQ_DATA, 0x41, 
			 ((lcdBase & 0x0000FF00) >> 8));
d1931 1
a1931 5
	/* FIFO2 read start address */
	VGAOUT8_INDEX(pSmi, VGA_SEQ_INDEX, VGA_SEQ_DATA, 0x42, 
			 (lcdBase & 0x000000FF));
	VGAOUT8_INDEX(pSmi, VGA_SEQ_INDEX, VGA_SEQ_DATA, 0x43, 
			 ((lcdBase & 0x0000FF00) >> 8));
d1933 1
a1933 12
	/* FIFO1/2 read start address overflow */
	VGAOUT8_INDEX(pSmi, VGA_SEQ_INDEX, VGA_SEQ_DATA, 0x45, 
		((lcdBase & 0x000F0000) >> 12) | (((lcdBase & 0x000F0000) >> 12) << 4));

    }

    WRITE_VPR(pSmi, 0x0C, Base >> 3);
    if (pSmi->Chipset == SMI_COUGAR3DR) {
	WRITE_FPR(pSmi, FPR0C, Base >> 3);
    }

    LEAVE_PROC("SMI_AdjustFrame");
d1940 4
a1943 1
    SMIPtr pSmi = SMIPTR(xf86Screens[scrnIndex]);
d1945 1
a1945 1
    ENTER_PROC("SMI_SwitchMode");
d1947 2
a1948 3
    pSmi->IsSwitching = TRUE;
    ret = SMI_ModeInit(xf86Screens[scrnIndex], mode);
    pSmi->IsSwitching = FALSE;
d1950 1
a1950 2
    LEAVE_PROC("SMI_SwitchMode");
    return ret;
d1954 2
a1955 2
SMI_LoadPalette(ScrnInfoPtr pScrn, int numColors, int *indicies, LOCO *colors,
				VisualPtr pVisual)
d1957 20
a1976 2
    SMIPtr pSmi = SMIPTR(pScrn);
    int i;
d1978 3
a1980 1
    ENTER_PROC("SMI_LoadPalette");
d1982 1
a1982 8
    /* Enable both the CRT and LCD DAC RAM paths, so both palettes are updated */
    if ((pSmi->Chipset == SMI_LYNX3DM) ||
	(pSmi->Chipset == SMI_COUGAR3DR)) {
	CARD8 ccr66;

	ccr66  = VGAIN8_INDEX(pSmi, VGA_SEQ_INDEX, VGA_SEQ_DATA, 0x66);
	ccr66 &= 0x0f;
	VGAOUT8_INDEX(pSmi, VGA_SEQ_INDEX, VGA_SEQ_DATA, 0x66, ccr66);
d1984 3
d1989 9
a1997 6
        DEBUG((VERBLEV, "pal[%d] = %d %d %d\n", indicies[i],
        colors[indicies[i]].red, colors[indicies[i]].green, colors[indicies[i]].blue));
	VGAOUT8(pSmi, VGA_DAC_WRITE_ADDR, indicies[i]);
	VGAOUT8(pSmi, VGA_DAC_DATA, colors[indicies[i]].red);
	VGAOUT8(pSmi, VGA_DAC_DATA, colors[indicies[i]].green);
	VGAOUT8(pSmi, VGA_DAC_DATA, colors[indicies[i]].blue);
d2000 1
a2000 1
    LEAVE_PROC("SMI_LoadPalette");
d2009 6
a2014 4
    if (!(tmp = VGAIN8(pSmi, VGA_DAC_MASK)))
	return;
    pSmi->DACmask = tmp;
    VGAOUT8(pSmi, VGA_DAC_MASK, 0);
d2022 3
a2024 1
    VGAOUT8(pSmi, VGA_DAC_MASK, pSmi->DACmask);
a2030 1
    vgaHWPtr hwp = VGAHWPTR(pScrn);
a2031 1
    CARD8 tmp;
d2033 11
a2043 1
    ENTER_PROC("SMI_EnableMmio");
d2045 5
a2049 5
    /*
     * Enable chipset (seen on uninitialized secondary cards) might not be
     * needed once we use the VGA softbooter
     */
    vgaHWSetStdFuncs(hwp);
d2051 6
a2056 11
    /* Enable linear mode */
    outb(pSmi->PIOBase + VGA_SEQ_INDEX, 0x18);
    tmp = inb(pSmi->PIOBase + VGA_SEQ_DATA);
    pSmi->SR18Value = tmp;					/* PDR#521 */
    outb(pSmi->PIOBase + VGA_SEQ_DATA, tmp | 0x11);

    /* Enable 2D/3D Engine and Video Processor */
    outb(pSmi->PIOBase + VGA_SEQ_INDEX, 0x21);
    tmp = inb(pSmi->PIOBase + VGA_SEQ_DATA);
    pSmi->SR21Value = tmp;					/* PDR#521 */
    outb(pSmi->PIOBase + VGA_SEQ_DATA, tmp & ~0x03);
d2058 1
a2058 1
    LEAVE_PROC("SMI_EnableMmio");
a2063 1
    vgaHWPtr hwp = VGAHWPTR(pScrn);
d2066 1
a2066 1
    ENTER_PROC("SMI_DisableMmio");
d2068 2
a2069 1
    vgaHWSetStdFuncs(hwp);
d2071 1
a2071 3
    /* Disable 2D/3D Engine and Video Processor */
    outb(pSmi->PIOBase + VGA_SEQ_INDEX, 0x21);
    outb(pSmi->PIOBase + VGA_SEQ_DATA, pSmi->SR21Value);	/* PDR#521 */
d2073 8
a2080 3
    /* Disable linear mode */
    outb(pSmi->PIOBase + VGA_SEQ_INDEX, 0x18);
    outb(pSmi->PIOBase + VGA_SEQ_DATA, pSmi->SR18Value);	/* PDR#521 */
d2082 1
a2082 1
    LEAVE_PROC("SMI_DisableMmio");
a2084 1
/* This function is used to debug, it prints out the contents of Lynx regs */
d2086 24
a2111 2
    unsigned char i;
    vgaHWPtr hwp = VGAHWPTR(pScrn);
d2113 3
a2115 3
    int vgaCRIndex = hwp->IOBase + VGA_CRTC_INDEX_OFFSET;
    int vgaCRReg   = hwp->IOBase + VGA_CRTC_DATA_OFFSET;
    int vgaStatus  = hwp->IOBase + VGA_IN_STAT_1_OFFSET;
d2120 4
a2123 31
    xf86ErrorFVerb(VERBLEV, "MISCELLANEOUS OUTPUT\n    %02X\n",
		VGAIN8(pSmi, VGA_MISC_OUT_R));

    xf86ErrorFVerb(VERBLEV, "\nSEQUENCER\n"
		"    x0 x1 x2 x3  x4 x5 x6 x7  x8 x9 xA xB  xC xD xE xF");
    for (i = 0x00; i <= 0xAF; i++) {
	if ((i & 0xF) == 0x0) xf86ErrorFVerb(VERBLEV, "\n%02X|", i);
	if ((i & 0x3) == 0x0) xf86ErrorFVerb(VERBLEV, " ");
	xf86ErrorFVerb(VERBLEV, "%02X ",
	    VGAIN8_INDEX(pSmi, VGA_SEQ_INDEX, VGA_SEQ_DATA, i));
    }

    xf86ErrorFVerb(VERBLEV, "\n\nCRT CONTROLLER\n"
		"    x0 x1 x2 x3  x4 x5 x6 x7  x8 x9 xA xB  xC xD xE xF");
    for (i = 0x00; i <= 0xAD; i++) {
	if (i == 0x20) i = 0x30;
	if (i == 0x50) i = 0x90;
	if ((i & 0xF) == 0x0) xf86ErrorFVerb(VERBLEV, "\n%02X|", i);
	if ((i & 0x3) == 0x0) xf86ErrorFVerb(VERBLEV, " ");
	xf86ErrorFVerb(VERBLEV, "%02X ",
	    VGAIN8_INDEX(pSmi, vgaCRIndex, vgaCRReg, i));
    }

    xf86ErrorFVerb(VERBLEV, "\n\nGRAPHICS CONTROLLER\n"
		"    x0 x1 x2 x3  x4 x5 x6 x7  x8 x9 xA xB  xC xD xE xF");
    for (i = 0x00; i <= 0x08; i++) {
	if ((i & 0xF) == 0x0) xf86ErrorFVerb(VERBLEV, "\n%02X|", i);
	if ((i & 0x3) == 0x0) xf86ErrorFVerb(VERBLEV, " ");
	xf86ErrorFVerb(VERBLEV, "%02X ",
	    VGAIN8_INDEX(pSmi, VGA_GRAPH_INDEX, VGA_GRAPH_DATA, i));
    }
a2124 11
    xf86ErrorFVerb(VERBLEV, "\n\nATTRIBUTE 0CONTROLLER\n"
		"    x0 x1 x2 x3  x4 x5 x6 x7  x8 x9 xA xB  xC xD xE xF");
    for (i = 0x00; i <= 0x14; i++) {
	(void) VGAIN8(pSmi, vgaStatus);
	if ((i & 0xF) == 0x0) xf86ErrorFVerb(VERBLEV, "\n%02X|", i);
	if ((i & 0x3) == 0x0) xf86ErrorFVerb(VERBLEV, " ");
	xf86ErrorFVerb(VERBLEV, "%02X ",
	    VGAIN8_INDEX(pSmi, VGA_ATTR_INDEX, VGA_ATTR_DATA_R, i));
    }
    (void) VGAIN8(pSmi, vgaStatus);
    VGAOUT8(pSmi, VGA_ATTR_INDEX, 0x20);
a2146 143
}

/*
 * SMI_DisplayPowerManagementSet -- Sets VESA Display Power Management
 * Signaling (DPMS) Mode.
 */
static void
SMI_DisplayPowerManagementSet(ScrnInfoPtr pScrn, int PowerManagementMode,
							  int flags)
{
    vgaHWPtr hwp = VGAHWPTR(pScrn);
    SMIPtr pSmi = SMIPTR(pScrn);
    CARD8 SR01, SR20, SR21, SR22, SR23, SR24, SR31, SR34;

    ENTER_PROC("SMI_DisplayPowerManagementSet");

    /* If we already are in the requested DPMS mode, just return */
    if (pSmi->CurrentDPMS == PowerManagementMode) {
	LEAVE_PROC("SMI_DisplayPowerManagementSet");
	return;
    }

#if 1 /* PDR#735 */
    if (pSmi->useBIOS && pSmi->pInt10 != NULL) {
	pSmi->pInt10->ax = 0x4F10;
	switch (PowerManagementMode) {
	case DPMSModeOn:
	    pSmi->pInt10->bx = 0x0001;
	    break;
	case DPMSModeStandby:
	    pSmi->pInt10->bx = 0x0101;
	    break;
	case DPMSModeSuspend:
	    pSmi->pInt10->bx = 0x0201;
	    break;
	case DPMSModeOff:
	    pSmi->pInt10->bx = 0x0401;
	    break;
	}
	pSmi->pInt10->cx = 0x0000;
	pSmi->pInt10->num = 0x10;
	xf86ExecX86int10(pSmi->pInt10);
	if (pSmi->pInt10->ax == 0x004F) {
	    pSmi->CurrentDPMS = PowerManagementMode;
#if 1 /* PDR#835 */
	    if (PowerManagementMode == DPMSModeOn) {
		SR01 = VGAIN8_INDEX(pSmi, VGA_SEQ_INDEX, VGA_SEQ_DATA, 0x01);
		VGAOUT8_INDEX(pSmi, VGA_SEQ_INDEX, VGA_SEQ_DATA, 0x01,
				SR01 & ~0x20);
	    }
#endif
	    LEAVE_PROC("SMI_DisplayPowerManagementSet");
	    return;
	}
    }
#endif

    /* Save the current SR registers */
    if (pSmi->CurrentDPMS == DPMSModeOn) {
	pSmi->DPMS_SR20 = VGAIN8_INDEX(pSmi, VGA_SEQ_INDEX, VGA_SEQ_DATA, 0x20);
	pSmi->DPMS_SR21 = VGAIN8_INDEX(pSmi, VGA_SEQ_INDEX, VGA_SEQ_DATA, 0x21);
	pSmi->DPMS_SR31 = VGAIN8_INDEX(pSmi, VGA_SEQ_INDEX, VGA_SEQ_DATA, 0x31);
	pSmi->DPMS_SR34 = VGAIN8_INDEX(pSmi, VGA_SEQ_INDEX, VGA_SEQ_DATA, 0x34);
    }

    /* Read the required SR registers for the DPMS handler */
    SR01 = VGAIN8_INDEX(pSmi, VGA_SEQ_INDEX, VGA_SEQ_DATA, 0x01);
    SR20 = VGAIN8_INDEX(pSmi, VGA_SEQ_INDEX, VGA_SEQ_DATA, 0x20);
    SR21 = VGAIN8_INDEX(pSmi, VGA_SEQ_INDEX, VGA_SEQ_DATA, 0x21);
    SR22 = VGAIN8_INDEX(pSmi, VGA_SEQ_INDEX, VGA_SEQ_DATA, 0x22);
    SR23 = VGAIN8_INDEX(pSmi, VGA_SEQ_INDEX, VGA_SEQ_DATA, 0x23);
    SR24 = VGAIN8_INDEX(pSmi, VGA_SEQ_INDEX, VGA_SEQ_DATA, 0x24);
    SR31 = VGAIN8_INDEX(pSmi, VGA_SEQ_INDEX, VGA_SEQ_DATA, 0x31);
    SR34 = VGAIN8_INDEX(pSmi, VGA_SEQ_INDEX, VGA_SEQ_DATA, 0x34);

    switch (PowerManagementMode) {
    case DPMSModeOn:
	/* Screen On: HSync: On, VSync : On */
	SR01 &= ~0x20;
	SR20  = pSmi->DPMS_SR20;
	SR21  = pSmi->DPMS_SR21;
	SR22 &= ~0x30;
	SR23 &= ~0xC0;
	SR24 |= 0x01;
	SR31  = pSmi->DPMS_SR31;
	SR34  = pSmi->DPMS_SR34;
	break;
    case DPMSModeStandby:
	/* Screen: Off; HSync: Off, VSync: On */
	SR01 |= 0x20;
	SR20  = (SR20 & ~0xB0) | 0x10;
	SR21 |= 0x88;
	SR22  = (SR22 & ~0x30) | 0x10;
	SR23  = (SR23 & ~0x07) | 0xD8;
	SR24 &= ~0x01;
	SR31  = (SR31 & ~0x07) | 0x00;
	SR34 |= 0x80;
	break;
    case DPMSModeSuspend:
	/* Screen: Off; HSync: On, VSync: Off */
	SR01 |= 0x20;
	SR20  = (SR20 & ~0xB0) | 0x10;
	SR21 |= 0x88;
	SR22  = (SR22 & ~0x30) | 0x20;
	SR23  = (SR23 & ~0x07) | 0xD8;
	SR24 &= ~0x01;
	SR31  = (SR31 & ~0x07) | 0x00;
	SR34 |= 0x80;
	break;
    case DPMSModeOff:
	/* Screen: Off; HSync: Off, VSync: Off */
	SR01 |= 0x20;
	SR20  = (SR20 & ~0xB0) | 0x10;
	SR21 |= 0x88;
	SR22  = (SR22 & ~0x30) | 0x30;
	SR23  = (SR23 & ~0x07) | 0xD8;
	SR24 &= ~0x01;
	SR31  = (SR31 & ~0x07) | 0x00;
	SR34 |= 0x80;
	break;
    default:
	xf86ErrorFVerb(VERBLEV, "Invalid PowerManagementMode %d passed to "
		"SMI_DisplayPowerManagementSet\n", PowerManagementMode);
	LEAVE_PROC("SMI_DisplayPowerManagementSet");
	return;
    }

    /* Wait for vertical retrace */
    while (hwp->readST01(hwp) & 0x8) ;
    while (!(hwp->readST01(hwp) & 0x8)) ;

    /* Write the registers */
    VGAOUT8_INDEX(pSmi, VGA_SEQ_INDEX, VGA_SEQ_DATA, 0x01, SR01);
    VGAOUT8_INDEX(pSmi, VGA_SEQ_INDEX, VGA_SEQ_DATA, 0x34, SR34);
    VGAOUT8_INDEX(pSmi, VGA_SEQ_INDEX, VGA_SEQ_DATA, 0x31, SR31);
    VGAOUT8_INDEX(pSmi, VGA_SEQ_INDEX, VGA_SEQ_DATA, 0x20, SR20);
    VGAOUT8_INDEX(pSmi, VGA_SEQ_INDEX, VGA_SEQ_DATA, 0x22, SR22);
    VGAOUT8_INDEX(pSmi, VGA_SEQ_INDEX, VGA_SEQ_DATA, 0x23, SR23);
    VGAOUT8_INDEX(pSmi, VGA_SEQ_INDEX, VGA_SEQ_DATA, 0x21, SR21);
    VGAOUT8_INDEX(pSmi, VGA_SEQ_INDEX, VGA_SEQ_DATA, 0x24, SR24);

    /* Save the current power state */
    pSmi->CurrentDPMS = PowerManagementMode;
d2148 1
a2148 1
    LEAVE_PROC("SMI_DisplayPowerManagementSet");
a2149 58

static void
SMI_ProbeDDC(ScrnInfoPtr pScrn, int index)
{
    vbeInfoPtr pVbe;
    if (xf86LoadSubModule(pScrn, "vbe")) {
	pVbe = VBEInit(NULL, index);
	ConfiguredMonitor = vbeDoEDID(pVbe, NULL);
	vbeFree(pVbe);
    }
}

static unsigned int
SMI_ddc1Read(ScrnInfoPtr pScrn)
{
    register vgaHWPtr hwp = VGAHWPTR(pScrn);
    SMIPtr pSmi = SMIPTR(pScrn);
    unsigned int ret;

    ENTER_PROC("SMI_ddc1Read");

    while (hwp->readST01(hwp) & 0x8) ;
    while (!(hwp->readST01(hwp) & 0x8)) ;

    ret = VGAIN8_INDEX(pSmi, VGA_SEQ_INDEX, VGA_SEQ_DATA, 0x72) & 0x08;

    LEAVE_PROC("SMI_ddc1Read");
    return ret;
}

static Bool
SMI_ddc1(int scrnIndex)
{
    ScrnInfoPtr pScrn = xf86Screens[scrnIndex];
    SMIPtr pSmi = SMIPTR(pScrn);
    Bool success = FALSE;
    xf86MonPtr pMon;
    unsigned char tmp;

    ENTER_PROC("SMI_ddc1");

    tmp = VGAIN8_INDEX(pSmi, VGA_SEQ_INDEX, VGA_SEQ_DATA, 0x72);
    VGAOUT8_INDEX(pSmi, VGA_SEQ_INDEX, VGA_SEQ_DATA, 0x72, tmp | 0x20);

    pMon = xf86PrintEDID(xf86DoEDID_DDC1(scrnIndex,
					 vgaHWddc1SetSpeedWeak(),
					 SMI_ddc1Read));
    if (pMon != NULL) {
	success = TRUE;
    }
    xf86SetDDCproperties(pScrn, pMon);

    VGAOUT8_INDEX(pSmi, VGA_SEQ_INDEX, VGA_SEQ_DATA, 0x72, tmp);

    LEAVE_PROC("SMI_ddc1");
    return success;
}

@


1.1
log
@Initial revision
@
text
@a28 1
/* $XFree86: xc/programs/Xserver/hw/xfree86/drivers/siliconmotion/smi_driver.c,v 1.36tsi Exp $ */
d91 4
a94 4
#define SILICONMOTION_VERSION_NAME  "1.4.1"
#define SILICONMOTION_VERSION_MAJOR 1
#define SILICONMOTION_VERSION_MINOR 4
#define SILICONMOTION_PATCHLEVEL    1
d109 7
a115 7
	SILICONMOTION_DRIVER_VERSION,
	SILICONMOTION_DRIVER_NAME,
	SMI_Identify,
	SMI_Probe,
	SMI_AvailableOptions,
	NULL,
	0
d121 8
a128 8
	{ PCI_CHIP_SMI910, "Lynx"    },
	{ PCI_CHIP_SMI810, "LynxE"   },
	{ PCI_CHIP_SMI820, "Lynx3D"  },
	{ PCI_CHIP_SMI710, "LynxEM"  },
	{ PCI_CHIP_SMI712, "LynxEM+" },
	{ PCI_CHIP_SMI720, "Lynx3DM" },
	{ PCI_CHIP_SMI731, "Cougar3DR" },
	{ -1,             NULL      }
d133 9
a141 9
	/* numChipset,		PciID,				Resource */
	{ PCI_CHIP_SMI910,	PCI_CHIP_SMI910,	RES_SHARED_VGA },
	{ PCI_CHIP_SMI810,	PCI_CHIP_SMI810,	RES_SHARED_VGA },
	{ PCI_CHIP_SMI820,	PCI_CHIP_SMI820,	RES_SHARED_VGA },
	{ PCI_CHIP_SMI710,	PCI_CHIP_SMI710,	RES_SHARED_VGA },
	{ PCI_CHIP_SMI712,	PCI_CHIP_SMI712,	RES_SHARED_VGA },
	{ PCI_CHIP_SMI720,	PCI_CHIP_SMI720,	RES_SHARED_VGA },
	{ PCI_CHIP_SMI731,	PCI_CHIP_SMI731,	RES_SHARED_VGA },
	{ -1,				-1,					RES_UNDEFINED  }
d146 22
a167 22
	OPTION_PCI_BURST,
	OPTION_FIFO_CONSERV,
	OPTION_FIFO_MODERATE,
	OPTION_FIFO_AGGRESSIVE,
	OPTION_PCI_RETRY,
	OPTION_NOACCEL,
	OPTION_MCLK,
	OPTION_SHOWCACHE,
	OPTION_SWCURSOR,
	OPTION_HWCURSOR,
	OPTION_SHADOW_FB,
	OPTION_ROTATE,
	OPTION_VIDEOKEY,
	OPTION_BYTESWAP,
	/* CZ 26.10.2001: interlaced video */
	OPTION_INTERLACED,
	/* end CZ */
	OPTION_USEBIOS,
	OPTION_ZOOMONLCD,
	OPTION_DUALHEAD,
	NUMBER_OF_OPTIONS

d172 14
a185 14
   { OPTION_PCI_BURST,	     "pci_burst",	  OPTV_BOOLEAN, {0}, FALSE },
   { OPTION_FIFO_CONSERV,    "fifo_conservative", OPTV_BOOLEAN, {0}, FALSE },
   { OPTION_FIFO_MODERATE,   "fifo_moderate",	  OPTV_BOOLEAN, {0}, FALSE },
   { OPTION_FIFO_AGGRESSIVE, "fifo_aggressive",	  OPTV_BOOLEAN, {0}, FALSE },
   { OPTION_PCI_RETRY,	     "pci_retry",	  OPTV_BOOLEAN, {0}, FALSE },
   { OPTION_NOACCEL,	     "NoAccel",		  OPTV_BOOLEAN, {0}, FALSE },
   { OPTION_MCLK,	     "set_mclk",	  OPTV_FREQ,	{0}, FALSE },
   { OPTION_SHOWCACHE,	     "show_cache",	  OPTV_BOOLEAN, {0}, FALSE },
   { OPTION_HWCURSOR,	     "HWCursor",	  OPTV_BOOLEAN, {0}, FALSE },
   { OPTION_SWCURSOR,	     "SWCursor",	  OPTV_BOOLEAN, {0}, FALSE },
   { OPTION_SHADOW_FB,	     "ShadowFB",	  OPTV_BOOLEAN, {0}, FALSE },
   { OPTION_ROTATE,	     "Rotate",		  OPTV_ANYSTR,  {0}, FALSE },
   { OPTION_VIDEOKEY,	     "VideoKey",	  OPTV_INTEGER, {0}, FALSE },
   { OPTION_BYTESWAP,	     "ByteSwap",	  OPTV_BOOLEAN, {0}, FALSE },
d187 7
a193 6
   { OPTION_INTERLACED,	     "Interlaced",        OPTV_BOOLEAN, {0}, FALSE },
   /* end CZ */
   { OPTION_USEBIOS,	     "UseBIOS",		  OPTV_BOOLEAN,	{0}, FALSE },
   { OPTION_ZOOMONLCD,	     "ZoomOnLCD",	  OPTV_BOOLEAN,	{0}, FALSE },
   { OPTION_DUALHEAD,	     "Dualhead",	  OPTV_BOOLEAN,	{0}, FALSE },
   { -1,		     NULL,		  OPTV_NONE,	{0}, FALSE }
d207 16
a222 16
	"vgaHWCopyReg",
	"vgaHWGetHWRec",
	"vgaHWGetIOBase",
	"vgaHWGetIndex",
	"vgaHWInit",
	"vgaHWLock",
	"vgaHWMapMem",
	"vgaHWProtect",
	"vgaHWRestore",
	"vgaHWSave",
	"vgaHWSaveScreen",
	"vgaHWSetMmioFuncs",
	"vgaHWSetStdFuncs",
	"vgaHWUnmapMem",
	"vgaHWddc1SetSpeedWeak",
	NULL
d227 20
a246 7
	"XAAGetCopyROP",
	"XAACreateInfoRec",
	"XAADestroyInfoRec",
	"XAAGetFallbackOps",
	"XAAInit",
	"XAAGetPatternROP",
	NULL
d251 4
a254 4
	"xf86CreateCursorInfoRec",
	"xf86DestroyCursorInfoRec",
	"xf86InitCursor",
	NULL
d259 5
a263 5
	"xf86PrintEDID",
	"xf86DoEDID_DDC1",
	"xf86DoEDID_DDC2",
	"xf86SetDDCproperties",
	NULL
d268 9
a276 9
	"xf86CreateI2CBusRec",
	"xf86CreateI2CDevRec",
	"xf86DestroyI2CBusRec",
	"xf86DestroyI2CDevRec",
	"xf86I2CBusInit",
	"xf86I2CDevInit",
	"xf86I2CReadBytes",
	"xf86I2CWriteByte",
	NULL
d281 2
a282 2
	"ShadowFBInit",
	NULL
d287 4
a290 4
	"xf86ExecX86int10",
	"xf86FreeInt10",
	"xf86InitInt10",
	NULL
d295 4
a298 4
	"VBEInit",
	"vbeDoEDID",
	"vbeFree",
	NULL
d303 3
a305 3
	"fbPictureInit",
	"fbScreenInit",
	NULL
d314 12
a325 12
	"siliconmotion",
	MODULEVENDORSTRING,
	MODINFOSTRING1,
	MODINFOSTRING2,
	XORG_VERSION_CURRENT,
	SILICONMOTION_VERSION_MAJOR,
	SILICONMOTION_VERSION_MINOR,
	SILICONMOTION_PATCHLEVEL,
	ABI_CLASS_VIDEODRV,
	ABI_VIDEODRV_VERSION,
	MOD_CLASS_VIDEODRV,
	{0, 0, 0, 0}
d335 3
a337 3
	&SMIVersRec,
	siliconmotionSetup,
	NULL
d343 18
a360 1
	static Bool setupDone = FALSE;
d362 5
a366 4
	if (!setupDone)
	{
		setupDone = TRUE;
		xf86AddDriver(&SILICONMOTION, module, 0);
d368 3
a370 26
		/*
		 * Modules that this driver always requires can be loaded here
		 * by calling LoadSubModule().
		 */

		/*
		 * Tell the loader about symbols from other modules that this module
		 * might refer to.
		 */
		LoaderRefSymLists(vgahwSymbols, fbSymbols, xaaSymbols, ramdacSymbols,
						  ddcSymbols, i2cSymbols, int10Symbols, vbeSymbols,
						  shadowSymbols, NULL);

		/*
		 * The return value must be non-NULL on success even though there
		 * is no TearDownProc.
		 */
		return (pointer) 1;
	}
	else
	{
		if (errmaj)
		{
			*errmaj = LDR_ONCEONLY;
		}
		return(NULL);
d372 2
d381 1
a381 1
	ENTER_PROC("SMI_GetRec");
d383 8
a390 9
	/*
	 * Allocate an 'Chip'Rec, and hook it into pScrn->driverPrivate.
	 * pScrn->driverPrivate is initialised to NULL, so we can check if
	 * the allocation has already been done.
	 */
	if (pScrn->driverPrivate == NULL)
	{
		pScrn->driverPrivate = xnfcalloc(sizeof(SMIRec), 1);
	}
d392 2
a393 2
	LEAVE_PROC("SMI_GetRec");
	return(TRUE);
d399 1
a399 1
	ENTER_PROC("SMI_FreeRec");
d401 4
a404 5
	if (pScrn->driverPrivate != NULL)
	{
		xfree(pScrn->driverPrivate);
		pScrn->driverPrivate = NULL;
	}
d406 1
a406 1
	LEAVE_PROC("SMI_FreeRec");
d412 3
a414 3
	ENTER_PROC("SMI_AvailableOptions");
	LEAVE_PROC("SMI_AvailableOptions");
	return(SMIOptions);
d420 1
a420 1
	ENTER_PROC("SMI_Identify");
d422 3
a424 3
	xf86PrintChipsets(SILICONMOTION_NAME, "driver (version "
			SILICONMOTION_VERSION_NAME ") for Silicon Motion Lynx chipsets",
			SMIChipsets);
d426 1
a426 1
	LEAVE_PROC("SMI_Identify");
d432 6
a437 6
	int i;
	GDevPtr *devSections;
	int *usedChips;
	int numDevSections;
	int numUsed;
	Bool foundScreen = FALSE;
d439 1
a439 1
	ENTER_PROC("SMI_Probe");
d441 1
a441 8
	numDevSections = xf86MatchDevice(SILICONMOTION_DRIVER_NAME, &devSections);
	if (numDevSections <= 0)
	{
		/* There's no matching device section in the config file, so quit now.
		 */
		LEAVE_PROC("SMI_Probe");
		return(FALSE);
	}
d443 5
a447 5
	if (xf86GetPciVideoInfo() == NULL)
	{
		LEAVE_PROC("SMI_Probe");
		return(FALSE);
	}
d449 6
a454 3
	numUsed = xf86MatchPciInstances(SILICONMOTION_NAME, PCI_SMI_VENDOR_ID,
									SMIChipsets, SMIPciChipsets, devSections,
									numDevSections, drv, &usedChips);
d456 10
a465 7
	/* Free it since we don't need that list after this */
	xfree(devSections);
	if (numUsed <= 0)
	{
		LEAVE_PROC("SMI_Probe");
		return(FALSE);
	}
d467 1
a467 2
	if (flags & PROBE_DETECT)
	{
d469 19
a487 22
	}
	else
	{
		for (i = 0; i < numUsed; i++)
		{
			/* Allocate a ScrnInfoRec and claim the slot */
			ScrnInfoPtr pScrn = xf86AllocateScreen(drv, 0);

			/* Fill in what we can of the ScrnInfoRec */
			pScrn->driverVersion = SILICONMOTION_DRIVER_VERSION;
			pScrn->driverName	 = SILICONMOTION_DRIVER_NAME;
			pScrn->name			 = SILICONMOTION_NAME;
			pScrn->Probe		 = SMI_Probe;
			pScrn->PreInit		 = SMI_PreInit;
			pScrn->ScreenInit	 = SMI_ScreenInit;
			pScrn->SwitchMode	 = SMI_SwitchMode;
			pScrn->AdjustFrame	 = SMI_AdjustFrame;
			pScrn->EnterVT		 = SMI_EnterVT;
			pScrn->LeaveVT		 = SMI_LeaveVT;
			pScrn->FreeScreen	 = SMI_FreeScreen;
			pScrn->ValidMode	 = SMI_ValidMode;
			foundScreen			 = TRUE;
d489 2
a490 3
			xf86ConfigActivePciEntity(pScrn, usedChips[i], SMIPciChipsets, NULL,
									  NULL, NULL, NULL, NULL);
		}
d492 2
a493 1
	xfree(usedChips);
d495 2
a496 2
	LEAVE_PROC("SMI_Probe");
	return(foundScreen);
d502 12
a513 12
	EntityInfoPtr pEnt;
	SMIPtr pSmi;
	MessageType from;
	int i;
	double real;
	ClockRangePtr clockRanges;
	char *s;
	unsigned char config, m, n, shift;
	int mclk;
	vgaHWPtr hwp;
	int vgaCRIndex, vgaIOBase;
	vbeInfoPtr pVbe = NULL;
d515 1
a515 1
	ENTER_PROC("SMI_PreInit");
d517 5
a521 6
	if (flags & PROBE_DETECT)
	{
		SMI_ProbeDDC(pScrn, xf86GetEntityInfo(pScrn->entityList[0])->index);
		LEAVE_PROC("SMI_PreInit");
		return(TRUE);
	}
d523 7
a529 8
	/* Ignoring the Type list for now.  It might be needed when multiple cards
	 * are supported.
	 */
	if (pScrn->numEntities > 1)
	{
		LEAVE_PROC("SMI_PreInit");
		return(FALSE);
	}
d531 5
a535 6
	/* The vgahw module should be loaded here when needed */
	if (!xf86LoadSubModule(pScrn, "vgahw"))
	{
		LEAVE_PROC("SMI_PreInit");
		return(FALSE);
	}
d537 1
a537 1
	xf86LoaderReqSymLists(vgahwSymbols, NULL);
d539 7
a545 8
	/*
	 * Allocate a vgaHWRec
	 */
	if (!vgaHWGetHWRec(pScrn))
	{
		LEAVE_PROC("SMI_PreInit");
		return(FALSE);
	}
d547 17
a563 7
	/* Allocate the SMIRec driverPrivate */
	if (!SMI_GetRec(pScrn))
	{
		LEAVE_PROC("SMI_PreInit");
		return(FALSE);
	}
	pSmi = SMIPTR(pScrn);
d565 15
a579 2
	/* Set pScrn->monitor */
	pScrn->monitor = pScrn->confScreen->monitor;
d581 1
a581 9
	/*
	 * The first thing we should figure out is the depth, bpp, etc.
	 * We support only 24bpp layouts, so indicate that.
	 */
	if (!xf86SetDepthBpp(pScrn, 0, 0, 0, Support24bppFb))
	{
		LEAVE_PROC("SMI_PreInit");
		return(FALSE);
	}
d583 11
a593 15
	/* Check that the returned depth is one we support */
	switch (pScrn->depth)
	{
		case 8:
		case 16:
		case 24:
			/* OK */
			break;

		default:
			xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
					"Given depth (%d) is not supported by this driver\n",
					pScrn->depth);
			LEAVE_PROC("SMI_PreInit");
			return(FALSE);
d595 1
a595 1
	xf86PrintDepthBpp(pScrn);
d597 4
a600 8
	/*
	 * This must happen after pScrn->display has been set because
	 * xf86SetWeight references it.
	 */
	if (pScrn->depth > 8)
	{
		/* The defaults are OK for us */
		rgb zeros = {0, 0, 0};
d602 8
a609 12
		if (!xf86SetWeight(pScrn, zeros, zeros))
		{
			LEAVE_PROC("SMI_PreInit");
			return(FALSE);
		}
	}

	if (!xf86SetDefaultVisual(pScrn, -1))
	{
		LEAVE_PROC("SMI_PreInit");
		return(FALSE);
	}
d611 2
a612 9
	/* We don't currently support DirectColor at > 8bpp */
	if ((pScrn->depth > 8) && (pScrn->defaultVisual != TrueColor))
	{
		xf86DrvMsg(pScrn->scrnIndex, X_ERROR, "Given default visual (%s) "
				"is not supported at depth %d\n",
				xf86GetVisualName(pScrn->defaultVisual), pScrn->depth);
		LEAVE_PROC("SMI_PreInit");
		return(FALSE);
	}
d614 2
a615 2
	/* We use a programmable clock */
	pScrn->progClock = TRUE;
d617 98
a714 2
	/* Collect all of the relevant option flags (fill in pScrn->options) */
	xf86CollectOptions(pScrn, NULL);
d716 20
a735 4
	/* Set the bits per RGB for 8bpp mode */
	if (pScrn->depth == 8)
	{
		pScrn->rgbBits = 6;
d738 21
a758 5
	/* Process the options */
	if (!(pSmi->Options = xalloc(sizeof(SMIOptions))))
		return FALSE;
	memcpy(pSmi->Options, SMIOptions, sizeof(SMIOptions));
	xf86ProcessOptions(pScrn->scrnIndex, pScrn->options, pSmi->Options);
d760 33
a792 10
	if (xf86ReturnOptValBool(pSmi->Options, OPTION_PCI_BURST, FALSE))
	{
		pSmi->pci_burst = TRUE;
		xf86DrvMsg(pScrn->scrnIndex, X_CONFIG, "Option: pci_burst - PCI burst "
				"read enabled\n");
	}
	else
	{
		pSmi->pci_burst = FALSE;
	}
d794 54
a847 14
	pSmi->NoPCIRetry = TRUE;
	if (xf86ReturnOptValBool(pSmi->Options, OPTION_PCI_RETRY, FALSE))
	{
		if (xf86ReturnOptValBool(pSmi->Options, OPTION_PCI_BURST, FALSE))
		{
			pSmi->NoPCIRetry = FALSE;
			xf86DrvMsg(pScrn->scrnIndex, X_CONFIG, "Option: pci_retry\n");
		}
		else
		{
			xf86DrvMsg(pScrn->scrnIndex, X_CONFIG, "\"pci_retry\" option "
					"requires \"pci_burst\".\n");
		}
	}
d849 6
a854 10
	if (xf86IsOptionSet(pSmi->Options, OPTION_FIFO_CONSERV))
	{
		pSmi->fifo_conservative = TRUE;
		xf86DrvMsg(pScrn->scrnIndex, X_CONFIG, "Option: fifo_conservative "
				"set\n");
	}
	else
	{
		pSmi->fifo_conservative = FALSE;
	}
d856 1
a856 9
	if (xf86IsOptionSet(pSmi->Options, OPTION_FIFO_MODERATE))
	{
		pSmi->fifo_moderate = TRUE;
		xf86DrvMsg(pScrn->scrnIndex, X_CONFIG, "Option: fifo_moderate set\n");
	}
	else
	{
		pSmi->fifo_moderate = FALSE;
	}
d858 4
a861 9
	if (xf86IsOptionSet(pSmi->Options, OPTION_FIFO_AGGRESSIVE))
	{
		pSmi->fifo_aggressive = TRUE;
		xf86DrvMsg(pScrn->scrnIndex, X_CONFIG, "Option: fifo_aggressive set\n");
	}
	else
	{
		pSmi->fifo_aggressive = FALSE;
	}
d863 37
a899 10
	if (xf86ReturnOptValBool(pSmi->Options, OPTION_NOACCEL, FALSE))
	{
		pSmi->NoAccel = TRUE;
		xf86DrvMsg(pScrn->scrnIndex, X_CONFIG, "Option: NoAccel - Acceleration "
				"disabled\n");
	}
	else
	{
		pSmi->NoAccel = FALSE;
	}
d901 2
a902 9
	if (xf86ReturnOptValBool(pSmi->Options, OPTION_SHOWCACHE, FALSE))
	{
		pSmi->ShowCache = TRUE;
		xf86DrvMsg(pScrn->scrnIndex, X_CONFIG, "Option: show_cache set\n");
	}
	else
	{
		pSmi->ShowCache = FALSE;
	}
d904 17
a920 7
	if (xf86GetOptValFreq(pSmi->Options, OPTION_MCLK, OPTUNITS_MHZ, &real))
	{
		pSmi->MCLK = (int)(real * 1000.0);
		if (pSmi->MCLK <= 120000)
		{
			xf86DrvMsg(pScrn->scrnIndex, X_CONFIG, "Option: set_mclk set to "
					"%1.3f MHz\n", pSmi->MCLK / 1000.0);
d922 34
a955 12
		else
		{
			xf86DrvMsg(pScrn->scrnIndex, X_WARNING, "Memory Clock value of "
					"%1.3f MHz is larger than limit of 120 MHz\n",
					pSmi->MCLK / 1000.0);
			pSmi->MCLK = 0;
		}
	}
	else
	{
		pSmi->MCLK = 0;
	}
a956 13
	from = X_DEFAULT;
	pSmi->hwcursor = TRUE;
	if (xf86GetOptValBool(pSmi->Options, OPTION_HWCURSOR, &pSmi->hwcursor))
	{
		from = X_CONFIG;
	}
	if (xf86ReturnOptValBool(pSmi->Options, OPTION_SWCURSOR, FALSE))
	{
		pSmi->hwcursor = FALSE;
		from = X_CONFIG;
	}
	xf86DrvMsg(pScrn->scrnIndex, from, "Using %s Cursor\n",
			pSmi->hwcursor ? "Hardware" : "Software");
d958 2
a959 5
	if (xf86GetOptValBool(pSmi->Options, OPTION_SHADOW_FB, &pSmi->shadowFB))
	{
		xf86DrvMsg(pScrn->scrnIndex, X_CONFIG, "ShadowFB %s.\n",
				pSmi->shadowFB ? "enabled" : "disabled");
	}
d961 2
a962 27
#if 1 /* PDR#932 */
	if ((pScrn->depth == 8) || (pScrn->depth == 16))
#endif /* PDR#932 */
	if ((s = xf86GetOptValString(pSmi->Options, OPTION_ROTATE)))
	{
		if(!xf86NameCmp(s, "CW"))
		{
			pSmi->shadowFB = TRUE;
			pSmi->rotate = SMI_ROTATE_CCW;
			xf86DrvMsg(pScrn->scrnIndex, X_CONFIG, "Rotating screen "
					"clockwise\n");
		}
		else if (!xf86NameCmp(s, "CCW"))
		{
			pSmi->shadowFB = TRUE;
			pSmi->rotate = SMI_ROTATE_CW;
			xf86DrvMsg(pScrn->scrnIndex, X_CONFIG, "Rotating screen counter "
					"clockwise\n");
		}
		else
		{
			xf86DrvMsg(pScrn->scrnIndex, X_CONFIG, "\"%s\" is not a valid "
					"value for Option \"Rotate\"\n", s);
			xf86DrvMsg(pScrn->scrnIndex, X_INFO, "Valid options are \"CW\" or "
					"\"CCW\"\n");
		}
	}
d964 3
a966 1
	if (pSmi->rotate)
d968 84
a1051 3
		/* Disable the RandR extension, it messes up the internal rotation stuff */
		xf86DisableRandR();
	}
d1053 17
a1069 11
	if (xf86GetOptValInteger(pSmi->Options, OPTION_VIDEOKEY, &pSmi->videoKey))
	{
		xf86DrvMsg(pScrn->scrnIndex, X_CONFIG, "Option: Video key set to "
				"0x%08X\n", pSmi->videoKey);
	}
	else
	{
		pSmi->videoKey = (1 << pScrn->offset.red) | (1 << pScrn->offset.green)
				| (((pScrn->mask.blue >> pScrn->offset.blue) - 1)
						<< pScrn->offset.blue);
	}
d1071 5
a1075 9
	if (xf86ReturnOptValBool(pSmi->Options, OPTION_BYTESWAP, FALSE))
	{
		pSmi->ByteSwap = TRUE;
		xf86DrvMsg(pScrn->scrnIndex, X_CONFIG, "Option: ByteSwap enabled.\n");
	}
	else
	{
		pSmi->ByteSwap = FALSE;
	}
d1077 2
a1078 11
	/* CZ 26.10.2001: interlaced video */
	if (xf86ReturnOptValBool(pSmi->Options, OPTION_INTERLACED, FALSE))
	{
		pSmi->interlaced = TRUE;
		xf86DrvMsg(pScrn->scrnIndex, X_CONFIG, "Option: Interlaced enabled.\n");
	}
	else
	{
		pSmi->interlaced = FALSE;
	}
	/* end CZ */
d1080 7
a1086 10
	if (xf86GetOptValBool(pSmi->Options, OPTION_USEBIOS, &pSmi->useBIOS))
	{
		xf86DrvMsg(pScrn->scrnIndex, X_CONFIG, "Option: UseBIOS %s.\n",
				pSmi->useBIOS ? "enabled" : "disabled");
	}
	else
	{
		/* Default to UseBIOS enabled. */
		pSmi->useBIOS = TRUE;
	}
d1088 2
a1089 10
	if (xf86GetOptValBool(pSmi->Options, OPTION_ZOOMONLCD, &pSmi->zoomOnLCD))
	{
		xf86DrvMsg(pScrn->scrnIndex, X_CONFIG, "Option: ZoomOnLCD %s.\n",
				pSmi->zoomOnLCD ? "enabled" : "disabled");
	}
	else
	{
		/* Default to ZoomOnLCD enabled. */
		pSmi->zoomOnLCD = TRUE;
	}
d1091 2
a1092 9
	/* Find the PCI slot for this screen */
	pEnt = xf86GetEntityInfo(pScrn->entityList[0]);
	if ((pEnt->location.type != BUS_PCI) || (pEnt->resources))
	{
		xfree(pEnt);
		SMI_FreeRec(pScrn);
		LEAVE_PROC("SMI_PreInit");
		return(FALSE);
	}
d1094 2
a1095 10
	if (xf86LoadSubModule(pScrn,"int10")) {
	    xf86LoaderReqSymLists(int10Symbols,NULL);
	    pSmi->pInt10 = xf86InitInt10(pEnt->index);
	}
	
	if (pSmi->pInt10 && xf86LoadSubModule(pScrn, "vbe"))
	{
	    xf86LoaderReqSymLists(vbeSymbols, NULL);
	    pVbe = VBEInit(pSmi->pInt10, pEnt->index);
	}
d1097 5
a1101 4
	pSmi->PciInfo = xf86GetPciInfoForEntity(pEnt->index);
	xf86RegisterResources(pEnt->index, NULL, ResExclusive);
/*	xf86SetOperatingState(resVgaIo, pEnt->index, ResUnusedOpr); */
/*	xf86SetOperatingState(resVgaMem, pEnt->index, ResDisableOpr); */
d1103 6
a1108 8
	/*
	 * Set the Chipset and ChipRev, allowing config file entries to
	 * override.
	 */
	if (pEnt->device->chipset && *pEnt->device->chipset)
	{
		pScrn->chipset = pEnt->device->chipset;
		pSmi->Chipset = xf86StringToToken(SMIChipsets, pScrn->chipset);
d1110 2
a1111 5
	}
	else if (pEnt->device->chipID >= 0)
	{
		pSmi->Chipset = pEnt->device->chipID;
		pScrn->chipset = (char *) xf86TokenToString(SMIChipsets, pSmi->Chipset);
d1113 2
a1114 2
		xf86DrvMsg(pScrn->scrnIndex, X_CONFIG, "ChipID override: 0x%04X\n",
				pSmi->Chipset);
d1116 32
a1147 5
	else
	{
		from = X_PROBED;
		pSmi->Chipset = pSmi->PciInfo->chipType;
		pScrn->chipset = (char *) xf86TokenToString(SMIChipsets, pSmi->Chipset);
d1149 1
d1151 15
a1165 9
	if (pEnt->device->chipRev >= 0)
	{
		pSmi->ChipRev = pEnt->device->chipRev;
		xf86DrvMsg(pScrn->scrnIndex, X_CONFIG, "ChipRev override: %d\n",
				pSmi->ChipRev);
	}
	else
	{
		pSmi->ChipRev = pSmi->PciInfo->chipRev;
d1167 2
a1168 1
	xfree(pEnt);
d1170 3
a1172 18
	/*
	 * This shouldn't happen because such problems should be caught in
	 * SMI_Probe(), but check it just in case.
	 */
	if (pScrn->chipset == NULL)
	{
		xf86DrvMsg(pScrn->scrnIndex, X_ERROR, "ChipID 0x%04X is not "
				"recognised\n", pSmi->Chipset);
		LEAVE_PROC("SMI_PreInit");
		return(FALSE);
	}
	if (pSmi->Chipset < 0)
	{
		xf86DrvMsg(pScrn->scrnIndex, X_ERROR, "Chipset \"%s\" is not "
				"recognised\n", pScrn->chipset);
		LEAVE_PROC("SMI_PreInit");
		return(FALSE);
	}
d1174 4
a1177 1
	xf86DrvMsg(pScrn->scrnIndex, from, "Chipset: \"%s\"\n", pScrn->chipset);
d1179 24
a1202 2
	pSmi->PciTag = pciTag(pSmi->PciInfo->bus, pSmi->PciInfo->device,
			pSmi->PciInfo->func);
d1204 3
a1206 6
	pSmi->Dualhead = FALSE;
	if (xf86ReturnOptValBool(pSmi->Options, OPTION_DUALHEAD, FALSE) &&
	    SMI_LYNXM_SERIES(pSmi->Chipset))
	{
	    pSmi->Dualhead = TRUE;
	}
d1208 3
a1210 10
	/* tweak options for dualhead */
	if (pSmi->Dualhead) {
	    pSmi->useBIOS = FALSE;
	    xf86DrvMsg(pScrn->scrnIndex, X_INFO, "UseBIOS disabled in dualhead mode\n");
	    pSmi->hwcursor = FALSE;
	    xf86DrvMsg(pScrn->scrnIndex, X_INFO, "No hardware cursor in dualhead mode\n");
	    if (pScrn->bitsPerPixel != 16) {
		xf86DrvMsg(pScrn->scrnIndex, X_ERROR, "Dualhead only supported at "
				"depth 16\n");
		return FALSE;
d1212 2
d1216 5
a1220 2
	SMI_MapMem(pScrn);
	SMI_DisableVideo(pScrn);
d1222 10
a1231 4
	hwp = VGAHWPTR(pScrn);
	vgaIOBase  = hwp->IOBase;
	vgaCRIndex = vgaIOBase + VGA_CRTC_INDEX_OFFSET;
	pSmi->PIOBase = hwp->PIOOffset;
d1233 3
a1235 2
	xf86ErrorFVerb(VERBLEV, "\tSMI_PreInit vgaCRIndex=%x, vgaIOBase=%x, "
			"MMIOBase=%p\n", vgaCRIndex, vgaIOBase, hwp->MMIOBase);
d1237 3
a1239 2
	/* detect the panel size */
	SMI_DetectPanelSize(pScrn);
d1241 5
a1245 351
	if (xf86LoadSubModule(pScrn, "i2c"))
	{
		xf86LoaderReqSymLists(i2cSymbols, NULL);
		SMI_I2CInit(pScrn);
	}
	if (xf86LoadSubModule(pScrn, "ddc"))
	{
		xf86MonPtr pMon = NULL;

		xf86LoaderReqSymLists(ddcSymbols, NULL);
#if 1 /* PDR#579 */
		if (pVbe)
		{
			pMon = vbeDoEDID(pVbe, NULL);
			if (pMon != NULL)
			{
				if (   (pMon->rawData[0] == 0x00)
					&& (pMon->rawData[1] == 0xFF)
					&& (pMon->rawData[2] == 0xFF)
					&& (pMon->rawData[3] == 0xFF)
					&& (pMon->rawData[4] == 0xFF)
					&& (pMon->rawData[5] == 0xFF)
					&& (pMon->rawData[6] == 0xFF)
					&& (pMon->rawData[7] == 0x00)
				)
				{
					pMon = xf86PrintEDID(pMon);
					if (pMon != NULL)
					{
						xf86SetDDCproperties(pScrn, pMon);
					}
				}
			}
		}
#else
		if (   (pVbe)
			&& ((pMon = xf86PrintEDID(vbeDoEDID(pVbe, NULL))) != NULL)
		)
		{
			xf86SetDDCproperties(pScrn, pMon);
		}
#endif
		else if (!SMI_ddc1(pScrn->scrnIndex))
		{
			if (pSmi->I2C)
			{
				xf86SetDDCproperties(pScrn,
						xf86PrintEDID(xf86DoEDID_DDC2(pScrn->scrnIndex,
								pSmi->I2C)));
			}
		}
	}

	vbeFree(pVbe);
	xf86FreeInt10(pSmi->pInt10);
	pSmi->pInt10 = NULL;

	/*
	 * If the driver can do gamma correction, it should call xf86SetGamma()
	 * here. (from MGA, no ViRGE gamma support yet, but needed for
	 * xf86HandleColormaps support.)
	 */
	{
		Gamma zeros = { 0.0, 0.0, 0.0 };

		if (!xf86SetGamma(pScrn, zeros))
		{
			LEAVE_PROC("SMI_PreInit");
			SMI_EnableVideo(pScrn);
			SMI_UnmapMem(pScrn);
			return(FALSE);
		}
	}


	/* Next go on to detect amount of installed ram */
	config = VGAIN8_INDEX(pSmi, VGA_SEQ_INDEX, VGA_SEQ_DATA, 0x71);

	/* And compute the amount of video memory and offscreen memory */
	pSmi->videoRAMKBytes = 0;

	if (!pScrn->videoRam)
	{
		switch (pSmi->Chipset)
		{
			default:
			{
				int mem_table[4] = { 1, 2, 4, 0 };
				pSmi->videoRAMKBytes = mem_table[(config >> 6)] * 1024;
				break;
			}

			case SMI_LYNX3D:
			{
				int mem_table[4] = { 0, 2, 4, 6 };
				pSmi->videoRAMKBytes = mem_table[(config >> 6)] * 1024 + 512;
				break;
			}

			case SMI_LYNX3DM:
			{
				int mem_table[4] = { 16, 2, 4, 8 };
				pSmi->videoRAMKBytes = mem_table[(config >> 6)] * 1024;
				break;
			}

			case SMI_COUGAR3DR:
			{
				/* DANGER - Cougar3DR BIOS is broken - hardcode video ram size */
				/* per instructions from Silicon Motion engineers */
				pSmi->videoRAMKBytes = 16 * 1024;
				break;
            }
		}
		pSmi->videoRAMBytes = pSmi->videoRAMKBytes * 1024;
		pScrn->videoRam     = pSmi->videoRAMKBytes;

		xf86DrvMsg(pScrn->scrnIndex, X_PROBED, "videoram: %dkB\n",
				pSmi->videoRAMKBytes);
	}
	else
	{
		pSmi->videoRAMKBytes = pScrn->videoRam;
		pSmi->videoRAMBytes  = pScrn->videoRam * 1024;

		xf86DrvMsg(pScrn->scrnIndex, X_CONFIG, "videoram: %dk\n",
				pSmi->videoRAMKBytes);
	}

	/* Detect current MCLK and print it for user */
	m = VGAIN8_INDEX(pSmi, VGA_SEQ_INDEX, VGA_SEQ_DATA, 0x6A);
	n = VGAIN8_INDEX(pSmi, VGA_SEQ_INDEX, VGA_SEQ_DATA, 0x6B);
	switch (n >> 6)
	{
		default:
			shift = 1;
			break;

		case 1:
			shift = 4;
			break;

		case 2:
			shift = 2;
			break;
	}
	n &= 0x3F;
	mclk = ((1431818 * m) / n / shift + 50) / 100;
	xf86DrvMsg(pScrn->scrnIndex, X_PROBED, "Detected current MCLK value of "
			"%1.3f MHz\n", mclk / 1000.0);

	SMI_EnableVideo(pScrn);
	SMI_UnmapMem(pScrn);

	if (pSmi->Dualhead) {
	    pScrn->display->virtualX = 2 * pSmi->lcdWidth;
	    pScrn->display->virtualY = pSmi->lcdHeight;
	}

	pScrn->virtualX = pScrn->display->virtualX;

	/*
	 * Setup the ClockRanges, which describe what clock ranges are available,
	 * and what sort of modes they can be used for.
	 */
	clockRanges = xnfcalloc(sizeof(ClockRange),1);
	clockRanges->next = NULL;
	clockRanges->minClock = 20000;

        if ((pSmi->Chipset == SMI_LYNX3DM) || (pSmi->Chipset == SMI_COUGAR3DR))
            clockRanges->maxClock = 200000;
        else
            clockRanges->maxClock = 135000;

	clockRanges->clockIndex = -1;
	clockRanges->interlaceAllowed = FALSE;
	clockRanges->doubleScanAllowed = FALSE;
		
	i = xf86ValidateModes(
			pScrn,						/* Screen pointer					  */
			pScrn->monitor->Modes,		/* Available monitor modes			  */
			pScrn->display->modes,		/* req mode names for screen		  */
			clockRanges,				/* list of clock ranges allowed		  */
			NULL,						/* use min/max below				  */
			128,						/* min line pitch (width)			  */
			4096,						/* maximum line pitch (width)		  */
			128,						/* bits of granularity for line pitch */
										/* (width) above					  */
			128,						/* min virtual height				  */
			4096,						/* max virtual height				  */
			pScrn->display->virtualX,	/* force virtual x					  */
			pScrn->display->virtualY,	/* force virtual Y					  */
			pSmi->videoRAMBytes,		/* size of aperture used to access	  */
										/* video memory						  */
			LOOKUP_BEST_REFRESH);		/* how to pick modes				  */

	if (i == -1)
	{
		SMI_FreeRec(pScrn);
		LEAVE_PROC("SMI_PreInit");
		return(FALSE);
	}

	/* Prune the modes marked as invalid */
	xf86PruneDriverModes(pScrn);

	if ((i == 0) || (pScrn->modes == NULL))
	{
		xf86DrvMsg(pScrn->scrnIndex, X_ERROR, "No valid modes found\n");
		SMI_FreeRec(pScrn);
		LEAVE_PROC("SMI_PreInit");
		return(FALSE);
	}
	xf86SetCrtcForModes(pScrn, 0);

	/* Set the current mode to the first in the list */
	pScrn->currentMode = pScrn->modes;

	/* Print the list of modes being used */
	xf86PrintModes(pScrn);

	/* Set display resolution */
	xf86SetDpi(pScrn, 0, 0);

	if ((xf86LoadSubModule(pScrn, "fb") == NULL))
	{
		SMI_FreeRec(pScrn);
		LEAVE_PROC("SMI_PreInit");
		return(FALSE);
	}

	xf86LoaderReqSymLists(fbSymbols, NULL);
	/* Load XAA if needed */
	if (!pSmi->NoAccel || pSmi->hwcursor)
	{
		if (!xf86LoadSubModule(pScrn, "xaa"))
		{
			SMI_FreeRec(pScrn);
			LEAVE_PROC("SMI_PreInit");
			return(FALSE);
		}
		xf86LoaderReqSymLists(xaaSymbols, NULL);
	}

	/* Load ramdac if needed */
	if (pSmi->hwcursor)
	{
		if (!xf86LoadSubModule(pScrn, "ramdac"))
		{
			SMI_FreeRec(pScrn);
			LEAVE_PROC("SMI_PreInit");
			return(FALSE);
		}
		xf86LoaderReqSymLists(ramdacSymbols, NULL);
	}

	if (pSmi->shadowFB)
	{
		if (!xf86LoadSubModule(pScrn, "shadowfb"))
		{
			SMI_FreeRec(pScrn);
			LEAVE_PROC("SMI_PreInit");
			return(FALSE);
		}
		xf86LoaderReqSymLists(shadowSymbols, NULL);
	}

	LEAVE_PROC("SMI_PreInit");
	return(TRUE);
}

/*
 * This is called when VT switching back to the X server.  Its job is to
 * reinitialise the video mode. We may wish to unmap video/MMIO memory too.
 */

static Bool
SMI_EnterVT(int scrnIndex, int flags)
{
	ScrnInfoPtr pScrn = xf86Screens[scrnIndex];
	SMIPtr pSmi = SMIPTR(pScrn);
	Bool ret;

	ENTER_PROC("SMI_EnterVT");

	/* Enable MMIO and map memory */
	SMI_MapMem(pScrn);
	SMI_Save(pScrn);

	/* #670 */
	if (pSmi->shadowFB)
	{
		pSmi->FBOffset = pSmi->savedFBOffset;
		pSmi->FBReserved = pSmi->savedFBReserved;
	}

	ret = SMI_ModeInit(pScrn, pScrn->currentMode);

	/* #670 */
	if (ret && pSmi->shadowFB)
	{
		BoxRec box;

		/* #920 */
		if (pSmi->paletteBuffer)
		{
			int i;

			VGAOUT8(pSmi, VGA_DAC_WRITE_ADDR, 0);
			for(i = 0; i < 256 * 3; i++)
			{
				VGAOUT8(pSmi, VGA_DAC_DATA, pSmi->paletteBuffer[i]);
			}
			xfree(pSmi->paletteBuffer);
			pSmi->paletteBuffer = NULL;
		}

		if (pSmi->pSaveBuffer)
		{
			memcpy(pSmi->FBBase, pSmi->pSaveBuffer, pSmi->saveBufferSize);
			xfree(pSmi->pSaveBuffer);
			pSmi->pSaveBuffer = NULL;
		}

		box.x1 = 0;
		box.y1 = 0;
		box.x2 = pScrn->virtualY;
		box.y2 = pScrn->virtualX;
		if (pSmi->Chipset == SMI_COUGAR3DR)
		{
			SMI_RefreshArea730(pScrn, 1, &box);
		}
		else
		{
			SMI_RefreshArea(pScrn, 1, &box);
		}
	}

	/* Reset the grapics engine */
	if (!pSmi->NoAccel)
	    SMI_EngineReset(pScrn);

	LEAVE_PROC("SMI_EnterVT");
	return(ret);
}

/*
 * This is called when VT switching away from the X server.  Its job is to
 * restore the previous (text) mode. We may wish to remap video/MMIO memory
 * too.
 */
d1250 14
a1263 5
	ScrnInfoPtr pScrn = xf86Screens[scrnIndex];
	vgaHWPtr hwp = VGAHWPTR(pScrn);
	SMIPtr pSmi = SMIPTR(pScrn);
	vgaRegPtr vgaSavePtr = &hwp->SavedReg;
	SMIRegPtr SMISavePtr = &pSmi->SavedReg;
d1265 2
a1266 1
	ENTER_PROC("SMI_LeaveVT");
d1268 9
a1276 26
	/* #670 */
	if (pSmi->shadowFB)
	{
		pSmi->pSaveBuffer = xnfalloc(pSmi->saveBufferSize);
		if (pSmi->pSaveBuffer)
		{
			memcpy(pSmi->pSaveBuffer, pSmi->FBBase, pSmi->saveBufferSize);
		}

		pSmi->savedFBOffset = pSmi->FBOffset;
		pSmi->savedFBReserved = pSmi->FBReserved;

		/* #920 */
		if (pSmi->Bpp == 1)
		{
			pSmi->paletteBuffer = xnfalloc(256 * 3);
			if (pSmi->paletteBuffer)
			{
				int i;

				VGAOUT8(pSmi, VGA_DAC_READ_ADDR, 0);
				for (i = 0; i < 256 * 3; i++)
				{
					pSmi->paletteBuffer[i] = VGAIN8(pSmi, VGA_DAC_DATA);
				}
			}
d1278 1
d1280 1
d1282 3
a1284 3
	memset(pSmi->FBBase, 0, 256 * 1024);	/* #689 */
	SMI_WriteMode(pScrn, vgaSavePtr, SMISavePtr);
	SMI_UnmapMem(pScrn);
d1286 1
a1286 1
	LEAVE_PROC("SMI_LeaveVT");
d1298 2
a1299 2
	int i;
	CARD32 offset;
d1301 142
a1442 25
	vgaHWPtr hwp         = VGAHWPTR(pScrn);
	vgaRegPtr vgaSavePtr = &hwp->SavedReg;
	SMIPtr pSmi          = SMIPTR(pScrn);
	SMIRegPtr save       = &pSmi->SavedReg;

	int vgaIOBase  = hwp->IOBase;
	int vgaCRIndex = vgaIOBase + VGA_CRTC_INDEX_OFFSET;
	int vgaCRData  = vgaIOBase + VGA_CRTC_DATA_OFFSET;

	ENTER_PROC("SMI_Save");

	/* Save the standard VGA registers */
	vgaHWSave(pScrn, vgaSavePtr, VGA_SR_ALL);
	save->smiDACMask = VGAIN8(pSmi, VGA_DAC_MASK);
	VGAOUT8(pSmi, VGA_DAC_READ_ADDR, 0);
	for (i = 0; i < 256; i++)
	{
		save->smiDacRegs[i][0] = VGAIN8(pSmi, VGA_DAC_DATA);
		save->smiDacRegs[i][1] = VGAIN8(pSmi, VGA_DAC_DATA);
		save->smiDacRegs[i][2] = VGAIN8(pSmi, VGA_DAC_DATA);
	}
	for (i = 0, offset = 2; i < 8192; i++, offset += 8)
	{
		save->smiFont[i] = *(pSmi->FBBase + offset);
	}
d1444 5
a1448 101
	/* Now we save all the extended registers we need. */
	save->SR17 = VGAIN8_INDEX(pSmi, VGA_SEQ_INDEX, VGA_SEQ_DATA, 0x17);
	save->SR18 = VGAIN8_INDEX(pSmi, VGA_SEQ_INDEX, VGA_SEQ_DATA, 0x18);
	save->SR21 = VGAIN8_INDEX(pSmi, VGA_SEQ_INDEX, VGA_SEQ_DATA, 0x21);
	save->SR31 = VGAIN8_INDEX(pSmi, VGA_SEQ_INDEX, VGA_SEQ_DATA, 0x31);
	save->SR32 = VGAIN8_INDEX(pSmi, VGA_SEQ_INDEX, VGA_SEQ_DATA, 0x32);
	save->SR6A = VGAIN8_INDEX(pSmi, VGA_SEQ_INDEX, VGA_SEQ_DATA, 0x6A);
	save->SR6B = VGAIN8_INDEX(pSmi, VGA_SEQ_INDEX, VGA_SEQ_DATA, 0x6B);
	save->SR81 = VGAIN8_INDEX(pSmi, VGA_SEQ_INDEX, VGA_SEQ_DATA, 0x81);
	save->SRA0 = VGAIN8_INDEX(pSmi, VGA_SEQ_INDEX, VGA_SEQ_DATA, 0xA0);

	if (pSmi->Dualhead) {
	    /* dualhead stuff */
	    save->SR22 = VGAIN8_INDEX(pSmi, VGA_SEQ_INDEX, VGA_SEQ_DATA, 0x22);
	    save->SR40 = VGAIN8_INDEX(pSmi, VGA_SEQ_INDEX, VGA_SEQ_DATA, 0x40);
	    save->SR41 = VGAIN8_INDEX(pSmi, VGA_SEQ_INDEX, VGA_SEQ_DATA, 0x41);
	    save->SR42 = VGAIN8_INDEX(pSmi, VGA_SEQ_INDEX, VGA_SEQ_DATA, 0x42);
	    save->SR43 = VGAIN8_INDEX(pSmi, VGA_SEQ_INDEX, VGA_SEQ_DATA, 0x43);
	    save->SR44 = VGAIN8_INDEX(pSmi, VGA_SEQ_INDEX, VGA_SEQ_DATA, 0x44);
	    save->SR45 = VGAIN8_INDEX(pSmi, VGA_SEQ_INDEX, VGA_SEQ_DATA, 0x45);
	    save->SR48 = VGAIN8_INDEX(pSmi, VGA_SEQ_INDEX, VGA_SEQ_DATA, 0x48);
	    save->SR49 = VGAIN8_INDEX(pSmi, VGA_SEQ_INDEX, VGA_SEQ_DATA, 0x49);
	    save->SR4A = VGAIN8_INDEX(pSmi, VGA_SEQ_INDEX, VGA_SEQ_DATA, 0x4A);
	    save->SR4B = VGAIN8_INDEX(pSmi, VGA_SEQ_INDEX, VGA_SEQ_DATA, 0x4B);
	    save->SR4C = VGAIN8_INDEX(pSmi, VGA_SEQ_INDEX, VGA_SEQ_DATA, 0x4C);
	    /* PLL stuff */
	    save->SR68 = VGAIN8_INDEX(pSmi, VGA_SEQ_INDEX, VGA_SEQ_DATA, 0x68);
	    save->SR69 = VGAIN8_INDEX(pSmi, VGA_SEQ_INDEX, VGA_SEQ_DATA, 0x69);
	    save->SR6C = VGAIN8_INDEX(pSmi, VGA_SEQ_INDEX, VGA_SEQ_DATA, 0x6C);
	    save->SR6D = VGAIN8_INDEX(pSmi, VGA_SEQ_INDEX, VGA_SEQ_DATA, 0x6D);
	    save->SR6E = VGAIN8_INDEX(pSmi, VGA_SEQ_INDEX, VGA_SEQ_DATA, 0x6E);
	    save->SR6F = VGAIN8_INDEX(pSmi, VGA_SEQ_INDEX, VGA_SEQ_DATA, 0x6F);
	}

	if (SMI_LYNXM_SERIES(pSmi->Chipset))
	{
		/* Save primary registers */
		save->CR90[14] = VGAIN8_INDEX(pSmi, vgaCRIndex, vgaCRData, 0x9E);
		VGAOUT8_INDEX(pSmi, vgaCRIndex, vgaCRData, 0x9E,
				save->CR90[14] & ~0x20);

		for (i = 0; i < 16; i++)
		{
			save->CR90[i] = VGAIN8_INDEX(pSmi, vgaCRIndex, vgaCRData, 0x90 + i);
		}
		save->CR33 = VGAIN8_INDEX(pSmi, vgaCRIndex, vgaCRData, 0x33);
		save->CR3A = VGAIN8_INDEX(pSmi, vgaCRIndex, vgaCRData, 0x3A);
		for (i = 0; i < 14; i++)
		{
			save->CR40[i] = VGAIN8_INDEX(pSmi, vgaCRIndex, vgaCRData, 0x40 + i);
		}

		/* Save secondary registers */
		VGAOUT8_INDEX(pSmi, vgaCRIndex, vgaCRData, 0x9E, save->CR90[14] | 0x20);
		save->CR33_2 = VGAIN8_INDEX(pSmi, vgaCRIndex, vgaCRData, 0x33);
		for (i = 0; i < 14; i++)
		{
			save->CR40_2[i] = VGAIN8_INDEX(pSmi, vgaCRIndex, vgaCRData,
					0x40 + i);
		}
		save->CR9F_2 = VGAIN8_INDEX(pSmi, vgaCRIndex, vgaCRData, 0x9F);

		/* Save common registers */
		for (i = 0; i < 14; i++)
		{
			save->CRA0[i] = VGAIN8_INDEX(pSmi, vgaCRIndex, vgaCRData, 0xA0 + i);
		}

		/* PDR#1069 */
		VGAOUT8_INDEX(pSmi, vgaCRIndex, vgaCRData, 0x9E, save->CR90[14]);
	}
	else
	{
		save->CR33 = VGAIN8_INDEX(pSmi, vgaCRIndex, vgaCRData, 0x33);
		save->CR3A = VGAIN8_INDEX(pSmi, vgaCRIndex, vgaCRData, 0x3A);
		for (i = 0; i < 14; i++)
		{
			save->CR40[i] = VGAIN8_INDEX(pSmi, vgaCRIndex, vgaCRData, 0x40 + i);
		}
	}

	/* CZ 2.11.2001: for gamma correction (TODO: other chipsets?) */
	if ((pSmi->Chipset == SMI_LYNX3DM) || (pSmi->Chipset == SMI_COUGAR3DR)) {
		save->CCR66 = VGAIN8_INDEX(pSmi, VGA_SEQ_INDEX, VGA_SEQ_DATA, 0x66);
	}
	/* end CZ */

	save->DPR10 = READ_DPR(pSmi, 0x10);
	save->DPR1C = READ_DPR(pSmi, 0x1C);
	save->DPR20 = READ_DPR(pSmi, 0x20);
	save->DPR24 = READ_DPR(pSmi, 0x24);
	save->DPR28 = READ_DPR(pSmi, 0x28);
	save->DPR2C = READ_DPR(pSmi, 0x2C);
	save->DPR30 = READ_DPR(pSmi, 0x30);
	save->DPR3C = READ_DPR(pSmi, 0x3C);
	save->DPR40 = READ_DPR(pSmi, 0x40);
	save->DPR44 = READ_DPR(pSmi, 0x44);

	save->VPR00 = READ_VPR(pSmi, 0x00);
	save->VPR0C = READ_VPR(pSmi, 0x0C);
	save->VPR10 = READ_VPR(pSmi, 0x10);
d1450 1
a1450 35
	if (pSmi->Chipset == SMI_COUGAR3DR)
	{
		save->FPR00_ = READ_FPR(pSmi, FPR00); 
		save->FPR0C_ = READ_FPR(pSmi, FPR0C);
		save->FPR10_ = READ_FPR(pSmi, FPR10);
	}

	save->CPR00 = READ_CPR(pSmi, 0x00);

	if (!pSmi->ModeStructInit)
	{
		/* XXX Should check the return value of vgaHWCopyReg() */
		vgaHWCopyReg(&hwp->ModeReg, vgaSavePtr);
		memcpy(&pSmi->ModeReg, save, sizeof(SMIRegRec));
		pSmi->ModeStructInit = TRUE;
	}

	if (pSmi->useBIOS && (pSmi->pInt10 != NULL))
	{
		pSmi->pInt10->num = 0x10;
		pSmi->pInt10->ax = 0x0F00;
		xf86ExecX86int10(pSmi->pInt10);
		save->mode = pSmi->pInt10->ax & 0x007F;
		xf86DrvMsg(pScrn->scrnIndex, X_INFO, "Current mode 0x%02X.\n",
				save->mode);
	}

	if (xf86GetVerbosity() > 1)
	{
		xf86DrvMsgVerb(pScrn->scrnIndex, X_INFO, VERBLEV,
				"Saved current video mode.  Register dump:\n");
		SMI_PrintRegs(pScrn);
	}

	LEAVE_PROC("SMI_Save");
d1461 24
a1484 3
	int i;
	CARD8 tmp;
	CARD32 offset;
d1486 4
a1489 5
	vgaHWPtr hwp   = VGAHWPTR(pScrn);
	SMIPtr pSmi    = SMIPTR(pScrn);
	int vgaIOBase  = hwp->IOBase;
	int vgaCRIndex = vgaIOBase + VGA_CRTC_INDEX_OFFSET;
	int vgaCRData  = vgaIOBase + VGA_CRTC_DATA_OFFSET;
d1491 51
a1541 1
	ENTER_PROC("SMI_WriteMode");
d1543 3
a1545 1
	vgaHWProtect(pScrn, TRUE);
d1547 13
a1559 2
	/* Wait for engine to become idle */
	WaitIdle();
d1561 5
a1565 17
	if (pSmi->useBIOS && (pSmi->pInt10 != NULL)
	    && (restore->mode != 0))
	{
		pSmi->pInt10->num = 0x10;
		pSmi->pInt10->ax = restore->mode | 0x80;
		xf86DrvMsg(pScrn->scrnIndex, X_INFO, "Setting mode 0x%02X\n",
				restore->mode);
		xf86ExecX86int10(pSmi->pInt10);

		/* Enable linear mode. */
		outb(pSmi->PIOBase + VGA_SEQ_INDEX, 0x18);
		tmp = inb(pSmi->PIOBase + VGA_SEQ_DATA);
		outb(pSmi->PIOBase + VGA_SEQ_DATA, tmp | 0x01);

		/* Enable DPR/VPR registers. */
		tmp = VGAIN8_INDEX(pSmi, VGA_SEQ_INDEX, VGA_SEQ_DATA, 0x21);
		VGAOUT8_INDEX(pSmi, VGA_SEQ_INDEX, VGA_SEQ_DATA, 0x21, tmp & ~0x03);
a1566 23
	else
	{
		VGAOUT8_INDEX(pSmi, VGA_SEQ_INDEX, VGA_SEQ_DATA, 0x17, restore->SR17);
		tmp = VGAIN8_INDEX(pSmi, VGA_SEQ_INDEX, VGA_SEQ_DATA, 0x18) & ~0x1F;
		VGAOUT8_INDEX(pSmi, VGA_SEQ_INDEX, VGA_SEQ_DATA, 0x18, tmp |
				(restore->SR18 & 0x1F));
		tmp = VGAIN8_INDEX(pSmi, VGA_SEQ_INDEX, VGA_SEQ_DATA, 0x21);
		VGAOUT8_INDEX(pSmi, VGA_SEQ_INDEX, VGA_SEQ_DATA, 0x21, tmp & ~0x03);
		tmp = VGAIN8_INDEX(pSmi, VGA_SEQ_INDEX, VGA_SEQ_DATA, 0x31) & ~0xC0;
		VGAOUT8_INDEX(pSmi, VGA_SEQ_INDEX, VGA_SEQ_DATA, 0x31, tmp |
				(restore->SR31 & 0xC0));
		tmp = VGAIN8_INDEX(pSmi, VGA_SEQ_INDEX, VGA_SEQ_DATA, 0x32) & ~0x07;
		VGAOUT8_INDEX(pSmi, VGA_SEQ_INDEX, VGA_SEQ_DATA, 0x32, tmp |
				(restore->SR32 & 0x07));
		if (restore->SR6B != 0xFF)
		{
			VGAOUT8_INDEX(pSmi, VGA_SEQ_INDEX, VGA_SEQ_DATA, 0x6A,
					restore->SR6A);
			VGAOUT8_INDEX(pSmi, VGA_SEQ_INDEX, VGA_SEQ_DATA, 0x6B,
					restore->SR6B);
		}
		VGAOUT8_INDEX(pSmi, VGA_SEQ_INDEX, VGA_SEQ_DATA, 0x81, restore->SR81);
		VGAOUT8_INDEX(pSmi, VGA_SEQ_INDEX, VGA_SEQ_DATA, 0xA0, restore->SRA0);
d1568 4
a1571 21
		/* Restore the standard VGA registers */
		vgaHWRestore(pScrn, vgaSavePtr, VGA_SR_ALL);
		if (restore->smiDACMask)
		{
			VGAOUT8(pSmi, VGA_DAC_MASK, restore->smiDACMask);
		}
		else
		{
			VGAOUT8(pSmi, VGA_DAC_MASK, 0xFF);
		}
		VGAOUT8(pSmi, VGA_DAC_WRITE_ADDR, 0);
		for (i = 0; i < 256; i++)
		{
			VGAOUT8(pSmi, VGA_DAC_DATA, restore->smiDacRegs[i][0]);
			VGAOUT8(pSmi, VGA_DAC_DATA, restore->smiDacRegs[i][1]);
			VGAOUT8(pSmi, VGA_DAC_DATA, restore->smiDacRegs[i][2]);
		}
		for (i = 0, offset = 2; i < 8192; i++, offset += 8)
		{
			*(pSmi->FBBase + offset) = restore->smiFont[i];
		}
d1573 2
a1574 42
		if (SMI_LYNXM_SERIES(pSmi->Chipset))
		{
			/* Restore secondary registers */
			VGAOUT8_INDEX(pSmi, vgaCRIndex, vgaCRData, 0x9E,
					restore->CR90[14] | 0x20);

			VGAOUT8_INDEX(pSmi, vgaCRIndex, vgaCRData, 0x33, restore->CR33_2);
			for (i = 0; i < 14; i++)
			{
				VGAOUT8_INDEX(pSmi, vgaCRIndex, vgaCRData, 0x40 + i,
						restore->CR40_2[i]);
			}
			VGAOUT8_INDEX(pSmi, vgaCRIndex, vgaCRData, 0x9F, restore->CR9F_2);

			/* Restore primary registers */
			VGAOUT8_INDEX(pSmi, vgaCRIndex, vgaCRData, 0x9E,
					restore->CR90[14] & ~0x20);

			VGAOUT8_INDEX(pSmi, vgaCRIndex, vgaCRData, 0x33, restore->CR33);
			VGAOUT8_INDEX(pSmi, vgaCRIndex, vgaCRData, 0x3A, restore->CR3A);
			for (i = 0; i < 14; i++)
			{
				VGAOUT8_INDEX(pSmi, vgaCRIndex, vgaCRData, 0x40 + i,
						restore->CR40[i]);
			}
			for (i = 0; i < 16; i++)
			{
				if (i != 14)
				{
					VGAOUT8_INDEX(pSmi, vgaCRIndex, vgaCRData, 0x90 + i,
							restore->CR90[i]);
				}
			}
			VGAOUT8_INDEX(pSmi, vgaCRIndex, vgaCRData, 0x9E, restore->CR90[14]);

			/* Restore common registers */
			for (i = 0; i < 14; i++)
			{
				VGAOUT8_INDEX(pSmi, vgaCRIndex, vgaCRData, 0xA0 + i,
						restore->CRA0[i]);
			}
		}
d1576 7
a1582 19
		/* Restore the standard VGA registers */
		if (xf86IsPrimaryPci(pSmi->PciInfo)) {
		    vgaHWRestore(pScrn, vgaSavePtr, VGA_SR_CMAP 
				 | VGA_SR_FONTS);
		} 

		if (restore->modeInit)
		    vgaHWRestore(pScrn, vgaSavePtr, VGA_SR_ALL);

		if (!SMI_LYNXM_SERIES(pSmi->Chipset))
		{
			VGAOUT8_INDEX(pSmi, vgaCRIndex, vgaCRData, 0x33, restore->CR33);
			VGAOUT8_INDEX(pSmi, vgaCRIndex, vgaCRData, 0x3A, restore->CR3A);
			for (i = 0; i < 14; i++)
			{
				VGAOUT8_INDEX(pSmi, vgaCRIndex, vgaCRData, 0x40 + i,
						restore->CR40[i]);
			}
		}
d1585 5
d1597 2
a1598 2
	    /* PLL regs */
	    VGAOUT8_INDEX(pSmi, VGA_SEQ_INDEX, VGA_SEQ_DATA, 0x68, restore->SR68);
a1600 3
	    VGAOUT8_INDEX(pSmi, VGA_SEQ_INDEX, VGA_SEQ_DATA, 0x6C, restore->SR6C);
	    VGAOUT8_INDEX(pSmi, VGA_SEQ_INDEX, VGA_SEQ_DATA, 0x6D, restore->SR6D);

d1633 1
d1635 30
a1664 24
	/* CZ 2.11.2001: for gamma correction (TODO: other chipsets?) */
	if ((pSmi->Chipset == SMI_LYNX3DM) || (pSmi->Chipset == SMI_COUGAR3DR)) {
		VGAOUT8_INDEX(pSmi, VGA_SEQ_INDEX, VGA_SEQ_DATA, 0x66, restore->CCR66);
	}
	/* end CZ */

	VGAOUT8_INDEX(pSmi, VGA_SEQ_INDEX, VGA_SEQ_DATA, 0x81, 0x00);

	/* Reset the graphics engine */
	WRITE_DPR(pSmi, 0x10, restore->DPR10);
	WRITE_DPR(pSmi, 0x1C, restore->DPR1C);
	WRITE_DPR(pSmi, 0x20, restore->DPR20);
	WRITE_DPR(pSmi, 0x24, restore->DPR24);
	WRITE_DPR(pSmi, 0x28, restore->DPR28);
	WRITE_DPR(pSmi, 0x2C, restore->DPR2C);
	WRITE_DPR(pSmi, 0x30, restore->DPR30);
	WRITE_DPR(pSmi, 0x3C, restore->DPR3C);
	WRITE_DPR(pSmi, 0x40, restore->DPR40);
	WRITE_DPR(pSmi, 0x44, restore->DPR44);

	/* write video controller regs */
	WRITE_VPR(pSmi, 0x00, restore->VPR00);
	WRITE_VPR(pSmi, 0x0C, restore->VPR0C);
	WRITE_VPR(pSmi, 0x10, restore->VPR10);
d1666 1
a1666 6
	if(pSmi->Chipset == SMI_COUGAR3DR)
	{
		WRITE_FPR(pSmi, FPR00, restore->FPR00_);
		WRITE_FPR(pSmi, FPR0C, restore->FPR0C_);
		WRITE_FPR(pSmi, FPR10, restore->FPR10_);
	}
d1668 5
a1672 8
	WRITE_CPR(pSmi, 0x00, restore->CPR00);

	if (xf86GetVerbosity() > 1)
	{
		xf86DrvMsgVerb(pScrn->scrnIndex, X_INFO, VERBLEV,
				"Done restoring mode.  Register dump:\n");
		SMI_PrintRegs(pScrn);
	}
d1674 1
a1674 1
	vgaHWProtect(pScrn, FALSE);
d1676 1
a1676 1
	LEAVE_PROC("SMI_WriteMode");
d1682 1
a1682 1
	SMIPtr pSmi = SMIPTR(pScrn);
d1684 36
a1719 45
	/* panel size detection ... requires BIOS call on 730 hardware */
	if (pSmi->Chipset == SMI_COUGAR3DR)
	{
		if (pSmi->pInt10 != NULL)
		{
			pSmi->pInt10->num = 0x10;
			pSmi->pInt10->ax  = 0x5F00;
			pSmi->pInt10->bx  = 0;
			pSmi->pInt10->cx  = 0;
			pSmi->pInt10->dx  = 0;
			xf86ExecX86int10(pSmi->pInt10);
			if (pSmi->pInt10->ax == 0x005F)
			{
				switch (pSmi->pInt10->cx & 0x0F)
				{
					case PANEL_640x480:
						pSmi->lcdWidth  = 640;
						pSmi->lcdHeight = 480;
						break;
					
					case PANEL_800x600:
						pSmi->lcdWidth  = 800;
						pSmi->lcdHeight = 600;
						break;
					
					case PANEL_1024x768:
						pSmi->lcdWidth  = 1024;
						pSmi->lcdHeight = 768;
						break;
					
					case PANEL_1280x1024:
						pSmi->lcdWidth  = 1280;
						pSmi->lcdHeight = 1024;
						break;
					
					case PANEL_1600x1200:
						pSmi->lcdWidth  = 1600;
						pSmi->lcdHeight = 1200;
						break;
					
					case PANEL_1400x1050:
						pSmi->lcdWidth  = 1400;
						pSmi->lcdHeight = 1050;
						break;
				}
d1721 17
a1737 22
				xf86DrvMsg(pScrn->scrnIndex, X_INFO, "Detected panel size via BIOS: %d x %d\n",
					   pSmi->lcdWidth, pSmi->lcdHeight);
			}
			else
			{
				xf86DrvMsg(pScrn->scrnIndex, X_INFO, "BIOS error during 730 panel detection!\n");
				pSmi->lcdWidth  = pScrn->virtualX;
				pSmi->lcdHeight = pScrn->virtualY;
			}
		}
		else 
		{
			/* int10 support isn't setup on the second call to this function,
			   so if this is the second call, don't do detection again */
			if (pSmi->lcd == 0)
			{
				/* If we get here, int10 support is not loaded or not working */ 
				xf86DrvMsg(pScrn->scrnIndex, X_INFO, "No BIOS support for 730 panel detection!\n");
				pSmi->lcdWidth  = pScrn->virtualX;
				pSmi->lcdHeight = pScrn->virtualY;
			}
		}
d1739 5
a1743 17
		/* Set this to indicate that we've done the detection */
		pSmi->lcd = 1;
	}
	else /* panel size detection for hardware other than 730 */
	{
		pSmi->lcd = VGAIN8_INDEX(pSmi, VGA_SEQ_INDEX, VGA_SEQ_DATA, 0x31) & 0x01;
	
		if (VGAIN8_INDEX(pSmi, VGA_SEQ_INDEX, VGA_SEQ_DATA, 0x30) & 0x01)
		{
			pSmi->lcd <<= 1;
		}
		switch (VGAIN8_INDEX(pSmi, VGA_SEQ_INDEX, VGA_SEQ_DATA, 0x30) & 0x0C)
		{
			case 0x00:
				pSmi->lcdWidth  = 640;
				pSmi->lcdHeight = 480;
				break;
d1745 2
a1746 23
			case 0x04:
				pSmi->lcdWidth  = 800;
				pSmi->lcdHeight = 600;
				break;
	
			case 0x08:
				if (VGAIN8_INDEX(pSmi, VGA_SEQ_INDEX, VGA_SEQ_DATA, 0x74) & 0x02)
				{
					pSmi->lcdWidth  = 1024;
					pSmi->lcdHeight = 600;
				}
				else
				{
					pSmi->lcdWidth  = 1024;
					pSmi->lcdHeight = 768;
				}
				break;
	
			case 0x0C:
				pSmi->lcdWidth  = 1280;
				pSmi->lcdHeight = 1024;
				break;
		}
d1748 28
a1775 4

	xf86DrvMsg(pScrn->scrnIndex, X_INFO, "%s Panel Size = %dx%d\n",
			(pSmi->lcd == 0) ? "OFF" : (pSmi->lcd == 1) ? "TFT" : "DSTN",
			pSmi->lcdWidth, pSmi->lcdHeight);
d1782 52
a1833 3
	SMIPtr pSmi = SMIPTR(pScrn);
	vgaHWPtr hwp;
	CARD32 memBase;
d1835 78
a1912 4
	ENTER_PROC("SMI_MapMem");

	/* Map the Lynx register space */
	switch (pSmi->Chipset)
d1914 10
a1923 25
		default:
			memBase = pSmi->PciInfo->memBase[0] + 0x400000;
			pSmi->MapSize = 0x10000;
			break;

		case SMI_COUGAR3DR:
			memBase = pSmi->PciInfo->memBase[1];
			pSmi->MapSize = 0x200000;
			break;

		case SMI_LYNX3D:
			memBase = pSmi->PciInfo->memBase[0] + 0x680000;
			pSmi->MapSize = 0x180000;
			break;

		case SMI_LYNXEM:
		case SMI_LYNXEMplus:
			memBase = pSmi->PciInfo->memBase[0] + 0x400000;
			pSmi->MapSize = 0x400000;
			break;

		case SMI_LYNX3DM:
			memBase = pSmi->PciInfo->memBase[0];
			pSmi->MapSize = 0x200000;
			break;
d1925 7
a1931 9
	pSmi->MapBase = xf86MapPciMem(pScrn->scrnIndex, VIDMEM_MMIO, pSmi->PciTag,
			memBase, pSmi->MapSize);

	if (pSmi->MapBase == NULL)
	{
		xf86DrvMsg(pScrn->scrnIndex, X_ERROR, "Internal error: could not map "
				"MMIO registers.\n");
		LEAVE_PROC("SMI_MapMem");
		return(FALSE);
a1933 49
	switch (pSmi->Chipset)
	{
		default:
			pSmi->DPRBase = pSmi->MapBase + 0x8000;
			pSmi->VPRBase = pSmi->MapBase + 0xC000;
			pSmi->CPRBase = pSmi->MapBase + 0xE000;
			pSmi->IOBase  = NULL;
			pSmi->DataPortBase = pSmi->MapBase;
			pSmi->DataPortSize = 0x8000;
			break;

		case SMI_COUGAR3DR:
			pSmi->DPRBase = pSmi->MapBase + 0x000000;
			pSmi->VPRBase = pSmi->MapBase + 0x000800;
			pSmi->CPRBase = pSmi->MapBase + 0x001000;
			pSmi->FPRBase = pSmi->MapBase + 0x005800;
			pSmi->IOBase  = pSmi->MapBase + 0x0C0000;
			pSmi->DataPortBase = pSmi->MapBase + 0x100000;
			pSmi->DataPortSize = 0x100000;
			break;

		case SMI_LYNX3D:
			pSmi->DPRBase = pSmi->MapBase + 0x000000;
			pSmi->VPRBase = pSmi->MapBase + 0x000800;
			pSmi->CPRBase = pSmi->MapBase + 0x001000;
			pSmi->IOBase  = pSmi->MapBase + 0x040000;
			pSmi->DataPortBase = pSmi->MapBase + 0x080000;
			pSmi->DataPortSize = 0x100000;
			break;

		case SMI_LYNXEM:
		case SMI_LYNXEMplus:
			pSmi->DPRBase = pSmi->MapBase + 0x008000;
			pSmi->VPRBase = pSmi->MapBase + 0x00C000;
			pSmi->CPRBase = pSmi->MapBase + 0x00E000;
			pSmi->IOBase  = pSmi->MapBase + 0x300000;
			pSmi->DataPortBase = pSmi->MapBase /*+ 0x100000*/;
			pSmi->DataPortSize = 0x8000 /*0x200000*/;
			break;

		case SMI_LYNX3DM:
			pSmi->DPRBase = pSmi->MapBase + 0x000000;
			pSmi->VPRBase = pSmi->MapBase + 0x000800;
			pSmi->CPRBase = pSmi->MapBase + 0x001000;
			pSmi->IOBase  = pSmi->MapBase + 0x0C0000;
			pSmi->DataPortBase = pSmi->MapBase + 0x100000;
			pSmi->DataPortSize = 0x100000;
			break;
	}
d1935 2
a1936 7
			"Physical MMIO at 0x%08lX\n", (unsigned long)memBase);
	xf86DrvMsgVerb(pScrn->scrnIndex, X_INFO, VERBLEV,
			"Logical MMIO at %p - %p\n", pSmi->MapBase,
			pSmi->MapBase + pSmi->MapSize - 1);
	xf86DrvMsgVerb(pScrn->scrnIndex, X_INFO, VERBLEV,
			"DPR=%p, VPR=%p, IOBase=%p\n",
			pSmi->DPRBase, pSmi->VPRBase, pSmi->IOBase);
d1938 2
a1939 2
			"DataPort=%p - %p\n", pSmi->DataPortBase,
			pSmi->DataPortBase + pSmi->DataPortSize - 1);
d1941 4
a1944 66
	pScrn->memPhysBase = pSmi->PciInfo->memBase[0];

	SMI_EnableMmio(pScrn);

	if (pSmi->videoRAMBytes) {

	    /* Map the frame buffer */
	    if (pSmi->Chipset == SMI_LYNX3DM) 
	        pSmi->fbMapOffset = 0x200000;
	    else
	        pSmi->fbMapOffset = 0x0;

	    pSmi->FBOffset = 0;

	    pScrn->fbOffset = pSmi->FBOffset + pSmi->fbMapOffset;

	    pSmi->FBBase = xf86MapPciMem(pScrn->scrnIndex,
					 VIDMEM_FRAMEBUFFER,
					 pSmi->PciTag,
					 pScrn->memPhysBase + pSmi->fbMapOffset,
					 pSmi->videoRAMBytes);
	    
		if (pSmi->FBBase == NULL)
		{
			xf86DrvMsg(pScrn->scrnIndex, X_ERROR, "Internal error: could not "
					"map framebuffer.\n");
			LEAVE_PROC("SMI_MapMem");
			return(FALSE);
		}

		xf86DrvMsgVerb(pScrn->scrnIndex, X_INFO, VERBLEV,
			"Physical frame buffer at 0x%08lX offset: 0x%08lX\n",
		       pScrn->memPhysBase, pScrn->fbOffset);
		xf86DrvMsgVerb(pScrn->scrnIndex, X_INFO, VERBLEV,
			"Logical frame buffer at %p - %p\n", pSmi->FBBase,
			pSmi->FBBase + pSmi->videoRAMBytes - 1);

		/* Set up offset to hwcursor memory area.  It's a 1K chunk at the end of
		 * the frame buffer.
		 */
		pSmi->FBCursorOffset = pSmi->videoRAMBytes - 1024;

		xf86DrvMsg(pScrn->scrnIndex, X_INFO,
			"Cursor Offset: %08lX\n",
			(unsigned long)pSmi->FBCursorOffset);

		/* set up the fifo reserved space */
		if (VGAIN8_INDEX(pSmi, VGA_SEQ_INDEX, VGA_SEQ_DATA, 0x30) & 0x01)/* #1074 */
		{
			CARD32 fifoOffset = 0;
			fifoOffset |= VGAIN8_INDEX(pSmi, VGA_SEQ_INDEX, VGA_SEQ_DATA, 0x46)
				<< 3;
			fifoOffset |= VGAIN8_INDEX(pSmi, VGA_SEQ_INDEX, VGA_SEQ_DATA, 0x47)
				<< 11;
			fifoOffset |= (VGAIN8_INDEX(pSmi, VGA_SEQ_INDEX, VGA_SEQ_DATA, 0x49)
				& 0x1C) << 17;
			pSmi->FBReserved = fifoOffset;	/* PDR#1074 */
		}
		else
		{
			pSmi->FBReserved = pSmi->videoRAMBytes - 2048;
		}

		xf86DrvMsg(pScrn->scrnIndex, X_INFO,
			"Reserved: %08lX\n",
			   (unsigned long)pSmi->FBReserved);
d1946 34
d1981 2
d1984 2
a1985 22
	/* Assign hwp->MemBase & IOBase here */
	hwp = VGAHWPTR(pScrn);
	if (pSmi->IOBase != NULL)
	{
		vgaHWSetMmioFuncs(hwp, pSmi->MapBase, pSmi->IOBase - pSmi->MapBase);
	}
	vgaHWGetIOBase(hwp);

	/* Map the VGA memory when the primary video */
	if (xf86IsPrimaryPci(pSmi->PciInfo))
	{
		hwp->MapSize = 0x10000;
		if (!vgaHWMapMem(pScrn))
		{
			LEAVE_PROC("SMI_MapMem");
			return(FALSE);
		}
		pSmi->PrimaryVidMapped = TRUE;
	}

	LEAVE_PROC("SMI_MapMem");
	return(TRUE);
d1995 1
a1995 1
	SMIPtr pSmi = SMIPTR(pScrn);
d1997 1
a1997 1
	ENTER_PROC("SMI_UnmapMem");
d1999 5
a2003 6
	/* Unmap VGA mem if mapped. */
	if (pSmi->PrimaryVidMapped)
	{
		vgaHWUnmapMem(pScrn);
		pSmi->PrimaryVidMapped = FALSE;
	}
d2005 1
a2005 1
	SMI_DisableMmio(pScrn);
d2007 5
a2011 6
	xf86UnMapVidMem(pScrn->scrnIndex, (pointer) pSmi->MapBase, pSmi->MapSize);
	if (pSmi->FBBase != NULL)
	{
		xf86UnMapVidMem(pScrn->scrnIndex, (pointer) pSmi->FBBase,
				pSmi->videoRAMBytes);
	}
d2013 1
a2013 1
	LEAVE_PROC("SMI_UnmapMem");
d2021 3
a2023 3
	ScrnInfoPtr pScrn = xf86Screens[pScreen->myNum];
	SMIPtr pSmi = SMIPTR(pScrn);
	EntityInfoPtr pEnt;
d2025 1
a2025 1
	ENTER_PROC("SMI_ScreenInit");
d2027 5
a2031 6
	/* Map MMIO regs and framebuffer */
	if (!SMI_MapMem(pScrn))
	{
		LEAVE_PROC("SMI_ScreenInit");
		return(FALSE);
	}
d2033 1
a2033 1
	pEnt = xf86GetEntityInfo(pScrn->entityList[0]);
d2035 3
a2037 3
	if (!pSmi->pInt10) {
	    pSmi->pInt10 = xf86InitInt10(pEnt->index);
	}
d2039 2
a2040 2
	/* Save the chip/graphics state */
	SMI_Save(pScrn);
d2042 2
a2043 2
	/* Zero the frame buffer, #258 */
	memset(pSmi->FBBase, 0, pSmi->videoRAMBytes);
d2045 5
a2049 15
	/* Initialize the first mode */
	if (!SMI_ModeInit(pScrn, pScrn->currentMode))
	{
		LEAVE_PROC("SMI_ScreenInit");
		return(FALSE);
	}

	/*
	 * The next step is to setup the screen's visuals, and initialise the
	 * framebuffer code.  In cases where the framebuffer's default choises for
	 * things like visual layouts and bits per RGB are OK, this may be as simple
	 * as calling the framebuffer's ScreenInit() function.  If not, the visuals
	 * will need to be setup before calling a fb ScreenInit() function and fixed
	 * up after.
	 */
d2051 13
a2063 4
	/*
	 * Reset the visual list.
	 */
	miClearVisualTypes();
d2065 1
a2065 1
	/* Setup the visuals we support. */
d2067 6
a2072 8
	if (!miSetVisualTypes(pScrn->depth,
			miGetDefaultVisualMask(pScrn->depth), pScrn->rgbBits,
			pScrn->defaultVisual))
	{
		LEAVE_PROC("SMI_ScreenInit");
		return(FALSE);
	}
	if (!miSetPixmapDepths ()) return FALSE;
d2074 4
a2077 5
	if (!SMI_InternalScreenInit(scrnIndex, pScreen))
	{
		LEAVE_PROC("SMI_ScreenInit");
		return(FALSE);
	}
d2079 1
a2079 1
	xf86SetBlackWhitePixels(pScreen);
d2081 13
a2093 17
	if (pScrn->bitsPerPixel > 8)
	{
		VisualPtr visual;
		/* Fixup RGB ordering */
		visual = pScreen->visuals + pScreen->numVisuals;
		while (--visual >= pScreen->visuals)
		{
			if ((visual->class | DynamicClass) == DirectColor)
			{
				visual->offsetRed   = pScrn->offset.red;
				visual->offsetGreen = pScrn->offset.green;
				visual->offsetBlue  = pScrn->offset.blue;
				visual->redMask     = pScrn->mask.red;
				visual->greenMask   = pScrn->mask.green;
				visual->blueMask    = pScrn->mask.blue;
			}
		}
d2095 1
d2097 2
a2098 2
	/* must be after RGB ordering fixed */
	fbPictureInit(pScreen, 0, 0);
d2100 5
a2104 5
	/* CZ 18.06.2001: moved here from smi_accel.c to have offscreen
	   framebuffer in NoAccel mode */
	{
	    int numLines, maxLines;
	    BoxRec AvailFBArea;
d2106 5
a2110 5
	    maxLines = pSmi->FBReserved / (pSmi->width * pSmi->Bpp);
	    if (pSmi->rotate) {
		numLines = maxLines;
	    } else {
		/* CZ 3.11.2001: What does the following code? see also smi_video.c aaa line 1226 */
d2113 4
a2116 4
		numLines = ((pSmi->FBReserved - pSmi->width * pSmi->Bpp
			     * pSmi->height) * 25 / 100 + pSmi->width
			    * pSmi->Bpp - 1) / (pSmi->width * pSmi->Bpp);
		numLines += pSmi->height;
d2118 1
a2118 1
		numLines = maxLines;
d2120 1
a2120 1
	    }
d2122 11
a2132 22
	    AvailFBArea.x1 = 0;
	    AvailFBArea.y1 = 0;
	    AvailFBArea.x2 = pSmi->width;
	    AvailFBArea.y2 = numLines;
	    xf86DrvMsg(pScrn->scrnIndex, X_INFO,
		       "FrameBuffer Box: %d,%d - %d,%d\n",
		       AvailFBArea.x1, AvailFBArea.y1, AvailFBArea.x2,
		       AvailFBArea.y2);
	    xf86InitFBManager(pScreen, &AvailFBArea);
	}
	/* end CZ */
	
	
	/* Initialize acceleration layer */
	if (!pSmi->NoAccel) {
		if (!SMI_AccelInit(pScreen)) {
		    LEAVE_PROC("SMI_ScreenInit");
		    return(FALSE);
		}
	}
	
	miInitializeBackingStore(pScreen);
a2133 2
	/* hardware cursor needs to wrap this layer */
  	SMI_DGAInit(pScreen);
d2135 4
a2138 43
	/* Initialise cursor functions */
	miDCInitialize(pScreen, xf86GetPointerScreenFuncs());

	/* Initialize HW cursor layer.  Must follow software cursor
	 * initialization.
	 */
	if (pSmi->hwcursor)
	{
		if (!SMI_HWCursorInit(pScreen))
		{
			xf86DrvMsg(pScrn->scrnIndex, X_ERROR, "Hardware cursor "
					"initialization failed\n");
		}
	}

	if (pSmi->shadowFB)
	{
		RefreshAreaFuncPtr refreshArea;

		if (pSmi->Chipset == SMI_COUGAR3DR)
		{
			refreshArea = SMI_RefreshArea730;
		}
		else
		{
			refreshArea = SMI_RefreshArea;
		}

		if (pSmi->rotate)
		{
			if (pSmi->PointerMoved == NULL)
			{
				pSmi->PointerMoved  = pScrn->PointerMoved;
				pScrn->PointerMoved = SMI_PointerMoved;
			}
		}

		ShadowFBInit(pScreen, refreshArea);
	}

	/* Initialise default colormap */
	if (!miCreateDefColormap(pScreen))
	{
d2140 4
a2143 10
		return(FALSE);
	}

	/* Initialize colormap layer.  Must follow initialization of the default
	 * colormap.  And SetGamma call, else it will load palette with solid white.
	 */
    /* CZ 2.11.2001: CMAP_PALETTED_TRUECOLOR for gamma correction */
    if (!xf86HandleColormaps(pScreen, 256, pScrn->rgbBits, SMI_LoadPalette, NULL,
            CMAP_RELOAD_ON_MODE_SWITCH | CMAP_PALETTED_TRUECOLOR))
	{
d2145 2
a2146 21
		return(FALSE);
	}

	pScreen->SaveScreen = SMI_SaveScreen;
	pSmi->CloseScreen = pScreen->CloseScreen;
	pScreen->CloseScreen = SMI_CloseScreen;

	if (!xf86DPMSInit(pScreen, SMI_DisplayPowerManagementSet, 0))
	{
		xf86DrvMsg(pScrn->scrnIndex, X_ERROR, "DPMS initialization failed!\n");
	}

	if (!pSmi->Dualhead)
  	    SMI_InitVideo(pScreen);
	else 
	    xf86DrvMsg(pScrn->scrnIndex, X_INFO, "No overlay in dualhead mode\n");

	/* Report any unused options (only for the first generation) */
	if (serverGeneration == 1)
	{
		xf86ShowUnusedOptions(pScrn->scrnIndex, pScrn->options);
d2148 3
d2152 3
a2154 94
	LEAVE_PROC("SMI_ScreenInit");
	return(TRUE);
}

/* Common init routines needed in EnterVT and ScreenInit */

static int
SMI_InternalScreenInit(int scrnIndex, ScreenPtr pScreen)
{
	ScrnInfoPtr pScrn = xf86Screens[pScreen->myNum];
	SMIPtr pSmi = SMIPTR(pScrn);
	int width, height, displayWidth;
	int bytesPerPixel = pScrn->bitsPerPixel / 8;
	int xDpi, yDpi;
	int ret;

	ENTER_PROC("SMI_InternalScreenInit");

	if (pSmi->rotate)
	{
		width        = pScrn->virtualY;
		height       = pScrn->virtualX;
		xDpi         = pScrn->yDpi;
		yDpi         = pScrn->xDpi;
		displayWidth = ((width * bytesPerPixel + 15) & ~15) / bytesPerPixel;
	}
	else
	{
		width        = pScrn->virtualX;
		height       = pScrn->virtualY;
		xDpi		 = pScrn->xDpi;
		yDpi		 = pScrn->yDpi;
		displayWidth = pScrn->displayWidth;
	}

	if (pSmi->shadowFB)
	{
		pSmi->ShadowWidth      = width;
		pSmi->ShadowHeight     = height;
		pSmi->ShadowWidthBytes = (width * bytesPerPixel + 15) & ~15;
		if (bytesPerPixel == 3)
		{
			pSmi->ShadowPitch = ((height * 3) << 16)
							  | pSmi->ShadowWidthBytes;
		}
		else
		{
			pSmi->ShadowPitch = (height << 16)
							  | (pSmi->ShadowWidthBytes / bytesPerPixel);
		}

		pSmi->saveBufferSize = pSmi->ShadowWidthBytes * pSmi->ShadowHeight;
		pSmi->FBReserved -= pSmi->saveBufferSize;
		pSmi->FBReserved &= ~0x15;
		WRITE_VPR(pSmi, 0x0C, (pSmi->FBOffset = pSmi->FBReserved) >> 3);
		if(pSmi->Chipset == SMI_COUGAR3DR)
		{
			WRITE_FPR(pSmi, FPR0C, (pSmi->FBOffset = pSmi->FBReserved) >> 3);
		}
		pScrn->fbOffset = pSmi->FBOffset + pSmi->fbMapOffset;
		xf86DrvMsg(pScrn->scrnIndex, X_INFO,
				"Shadow: width=%d height=%d "
				"offset=0x%08lX pitch=0x%08X\n",
				pSmi->ShadowWidth, pSmi->ShadowHeight,
				(unsigned long)pSmi->FBOffset,
				pSmi->ShadowPitch);
	}
	else
	{
		pSmi->FBOffset = 0;
		pScrn->fbOffset = pSmi->FBOffset + pSmi->fbMapOffset;
	}

	/*
	 * Call the framebuffer layer's ScreenInit function, and fill in other
	 * pScreen fields.
	 */

	DEBUG((VERBLEV, "\tInitializing FB @@ 0x%08X for %dx%d (%d)\n",
			pSmi->FBBase, width, height, displayWidth));
	switch (pScrn->bitsPerPixel)
	{
	case 8:
	case 16:
	case 24:
	  ret = fbScreenInit(pScreen, pSmi->FBBase, width, height, xDpi,
			     yDpi, displayWidth,pScrn->bitsPerPixel);
	  break;
	default:
	  xf86DrvMsg(scrnIndex, X_ERROR, "Internal error: invalid bpp (%d) "
		     "in SMI_InternalScreenInit\n", pScrn->bitsPerPixel);
	  LEAVE_PROC("SMI_InternalScreenInit");
	  return(FALSE);
	}
d2156 2
a2157 3
	LEAVE_PROC("SMI_InternalScreenInit");
	return(ret);
}
d2159 24
a2182 32
/* Checks if a mode is suitable for the selected configuration. */
static ModeStatus
SMI_ValidMode(int scrnIndex, DisplayModePtr mode, Bool verbose, int flags)
{
	ScrnInfoPtr pScrn = xf86Screens[scrnIndex];
	SMIPtr pSmi = SMIPTR(pScrn);
	float refresh;

	ENTER_PROC("SMI_ValidMode");
	refresh = (mode->VRefresh > 0) ? mode->VRefresh 
	  : mode->Clock * 1000.0 / mode->VTotal / mode->HTotal;
	xf86DrvMsg(scrnIndex, X_INFO, "Mode: %dx%d %d-bpp, %fHz\n", mode->HDisplay,
			mode->VDisplay, pScrn->bitsPerPixel, refresh);

	if (pSmi->shadowFB)
	{
		int mem;

		if (pScrn->bitsPerPixel == 24)
		{
			LEAVE_PROC("SMI_ValidMode");
			return(MODE_BAD);
		}

		mem  = (pScrn->virtualX * pScrn->bitsPerPixel / 8 + 15) & ~15;
		mem *= pScrn->virtualY * 2;

		if (mem > pSmi->FBReserved)	/* PDR#1074 */
		{
			LEAVE_PROC("SMI_ValidMode");
			return(MODE_MEM);
		}
d2185 2
a2186 39
	if (!pSmi->useBIOS || pSmi->lcd)
	{
#if 1 /* PDR#983 */
		if (pSmi->zoomOnLCD)
		{
			if (   (mode->HDisplay > pSmi->lcdWidth)
				|| (mode->VDisplay > pSmi->lcdHeight)
			)
			{
				LEAVE_PROC("SMI_ValidMode");
				return(MODE_PANEL);
			}
		}
		else
#endif
		{
			if (   (mode->HDisplay != pSmi->lcdWidth)
				|| (mode->VDisplay != pSmi->lcdHeight)
			)
			{
				LEAVE_PROC("SMI_ValidMode");
				return(MODE_PANEL);
			}
		}

	}

#if 1 /* PDR#944 */
	if (pSmi->rotate)
	{
		if (   (mode->HDisplay != pSmi->lcdWidth)
			|| (mode->VDisplay != pSmi->lcdHeight)
		)
		{
			LEAVE_PROC("SMI_ValidMode");
			return(MODE_PANEL);
		}
	}
#endif
d2188 5
a2192 3
	LEAVE_PROC("SMI_ValidMode");
	return(MODE_OK);
}
d2194 9
a2202 2
static void
SMI_DPRInit(ScrnInfoPtr pScrn) {
d2204 20
a2223 59
	SMIPtr pSmi = SMIPTR(pScrn);
	int i;
	int xyAddress[] = { 320, 400, 512, 640, 800, 1024, 1280, 1600, 2048 };
	CARD32 DEDataFormat = 0;

	/* Store values to current mode register structs */
	SMIRegPtr new = &pSmi->ModeReg;

	/* Set DPR registers */
	pSmi->Stride = (pSmi->width * pSmi->Bpp + 15) & ~15;
	switch (pScrn->bitsPerPixel)
	{
		case 8:
			DEDataFormat = 0x00000000;
			break;

		case 16:
			pSmi->Stride >>= 1;
			DEDataFormat = 0x00100000;
			break;

		case 24:
			DEDataFormat = 0x00300000;
			break;

		case 32:
			pSmi->Stride >>= 2;
			DEDataFormat = 0x00200000;
			break;
	}
	for (i = 0; i < sizeof(xyAddress) / sizeof(xyAddress[0]); i++)
	{
		if (pSmi->rotate)
		{
			if (xyAddress[i] == pSmi->height)
			{
				DEDataFormat |= i << 16;
				break;
			}
		}
		else
		{
			if (xyAddress[i] == pSmi->width)
			{
				DEDataFormat |= i << 16;
				break;
			}
		}
	}
	new->DPR10 = (pSmi->Stride << 16) | pSmi->Stride;
	new->DPR1C = DEDataFormat;
	new->DPR20 = 0;
	new->DPR24 = 0xFFFFFFFF;
	new->DPR28 = 0xFFFFFFFF;
	new->DPR2C = 0;
	new->DPR30 = 0;
	new->DPR3C = (pSmi->Stride << 16) | pSmi->Stride;
	new->DPR40 = pSmi->FBOffset;
	new->DPR44 = pSmi->FBOffset;
d2226 4
a2229 2
static Bool
SMI_ModeInit(ScrnInfoPtr pScrn, DisplayModePtr mode)
d2231 75
a2305 8
	vgaHWPtr hwp = VGAHWPTR(pScrn);
	SMIPtr pSmi = SMIPTR(pScrn);
	unsigned char tmp;
	int panelIndex, modeIndex, i;

	/* Store values to current mode register structs */
	SMIRegPtr new = &pSmi->ModeReg;
	vgaRegPtr vganew = &hwp->ModeReg;
d2307 3
a2309 1
	ENTER_PROC("SMI_ModeInit");
d2311 7
a2317 5
	if(!vgaHWInit(pScrn, mode))
	{
		LEAVE_PROC("SMI_ModeInit");
		return(FALSE);
	}
d2319 5
a2323 1
	new->modeInit = TRUE;
d2325 2
a2326 11
	if (pSmi->rotate)
	{
		pSmi->width  = pScrn->virtualY;
		pSmi->height = pScrn->virtualX;
	}
	else
	{
		pSmi->width  = pScrn->virtualX;
		pSmi->height = pScrn->virtualY;
	}
	pSmi->Bpp    = pScrn->bitsPerPixel / 8;
d2328 3
a2330 9
	outb(pSmi->PIOBase + VGA_SEQ_INDEX, 0x17);
	tmp = inb(pSmi->PIOBase + VGA_SEQ_DATA);
	if (pSmi->pci_burst)
	{
		new->SR17 = tmp | 0x20;
	}
	else
	{
		new->SR17 = tmp & ~0x20;
d2333 2
a2334 5
	outb(pSmi->PIOBase + VGA_SEQ_INDEX, 0x18);
	new->SR18 = inb(pSmi->PIOBase + VGA_SEQ_DATA) | 0x11;

	outb(pSmi->PIOBase + VGA_SEQ_INDEX, 0x21);
	new->SR21 = inb(pSmi->PIOBase + VGA_SEQ_DATA) & ~0x03;
d2336 3
a2338 12
	if (pSmi->Chipset != SMI_COUGAR3DR)
	{
		outb(pSmi->PIOBase + VGA_SEQ_INDEX, 0x31);
		new->SR31 = inb(pSmi->PIOBase + VGA_SEQ_DATA) & ~0xC0;

		outb(pSmi->PIOBase + VGA_SEQ_INDEX, 0x32);
		new->SR32 = inb(pSmi->PIOBase + VGA_SEQ_DATA) & ~0x07;

		if (SMI_LYNXM_SERIES(pSmi->Chipset))
		{
			new->SR32 |= 0x04;
		}
d2340 1
d2342 10
a2351 3
	new->SRA0 = new->CR33 = new->CR3A = 0x00;

	if (pSmi->lcdWidth == 640)
d2353 5
a2357 9
		panelIndex = 0;
	}
	else if (pSmi->lcdWidth == 800)
	{
		panelIndex = 1;
	}
	else
	{
		panelIndex = 2;
d2359 1
d2361 6
a2366 11
	if (mode->HDisplay == 640)
	{
		modeIndex = 0;
	}
	else if (mode->HDisplay == 800)
	{
		modeIndex = 1;
	}
	else
	{
		modeIndex = 2;
d2368 2
d2371 3
a2373 26
	if (SMI_LYNXM_SERIES(pSmi->Chipset))
	{
		static unsigned char PanelTable[3][14] =
		{
			{ 0x5F, 0x4F, 0x00, 0x52, 0x1E, 0x0B, 0xDF, 0x00, 0xE9, 0x0B, 0x2E,
			  0x00, 0x4F, 0xDF },
			{ 0x7F, 0x63, 0x00, 0x69, 0x19, 0x72, 0x57, 0x00, 0x58, 0x0C, 0xA2,
			  0x20, 0x4F, 0xDF },
			{ 0xA3, 0x7F, 0x00, 0x83, 0x14, 0x24, 0xFF, 0x00, 0x02, 0x08, 0xA7,
			  0xE0, 0x4F, 0xDF },
		};

		for (i = 0; i < 14; i++)
		{
			new->CR40[i] = PanelTable[panelIndex][i];
		}
		new->CR90[14] = 0x03;
		new->CR90[15] = 0x00;
		if (mode->VDisplay < pSmi->lcdHeight)
		{
			new->CRA0[6] = (pSmi->lcdHeight - mode->VDisplay) / 8;
		}
		else
		{
			new->CRA0[6] = 0;
		}
d2375 34
a2408 51
		if (mode->HDisplay < pSmi->lcdWidth)
		{
			new->CRA0[7] = (pSmi->lcdWidth - mode->HDisplay) / 16;
		}
		else
		{
			new->CRA0[7] = 0;
		}
	}
	else
	{
		static unsigned char PanelTable[3][3][14] =
		{
			{ /* 640x480 panel */
		        { 0x5F, 0x4F, 0x00, 0x53, 0x00, 0x0B, 0xDF, 0x00, 0xEA, 0x0C,
		          0x2E, 0x00, 0x4F, 0xDF },
		        { 0x5F, 0x4F, 0x00, 0x53, 0x00, 0x0B, 0xDF, 0x00, 0xEA, 0x0C,
		          0x2E, 0x00, 0x4F, 0xDF },
		        { 0x5F, 0x4F, 0x00, 0x53, 0x00, 0x0B, 0xDF, 0x00, 0xEA, 0x0C,
		          0x2E, 0x00, 0x4F, 0xDF },
			},
			{ /* 800x600 panel */
		        { 0x7F, 0x59, 0x19, 0x5E, 0x8E, 0x72, 0x1C, 0x37, 0x1D, 0x00,
		          0xA2, 0x20, 0x4F, 0xDF },
		        { 0x7F, 0x63, 0x00, 0x68, 0x18, 0x72, 0x58, 0x00, 0x59, 0x0C,
		          0xE0, 0x20, 0x63, 0x57 },
		        { 0x7F, 0x63, 0x00, 0x68, 0x18, 0x72, 0x58, 0x00, 0x59, 0x0C,
		          0xE0, 0x20, 0x63, 0x57 },
			},
			{ /* 1024x768 panel */
		        { 0xA3, 0x67, 0x0F, 0x6D, 0x1D, 0x24, 0x70, 0x95, 0x72, 0x07,
		          0xA3, 0x20, 0x4F, 0xDF },
		        { 0xA3, 0x71, 0x19, 0x77, 0x07, 0x24, 0xAC, 0xD1, 0xAE, 0x03,
		          0xE1, 0x20, 0x63, 0x57 },
		        { 0xA3, 0x7F, 0x00, 0x85, 0x15, 0x24, 0xFF, 0x00, 0x01, 0x07,
		          0xE5, 0x20, 0x7F, 0xFF },
			},
		};

		for (i = 0; i < 14; i++)
		{
			new->CR40[i] = PanelTable[panelIndex][modeIndex][i];
		}
	}

	/* CZ 2.11.2001: for gamma correction (TODO: other chipsets?) */
	new->CCR66 = VGAIN8_INDEX(pSmi, VGA_SEQ_INDEX, VGA_SEQ_DATA, 0x66);
	if ((pSmi->Chipset == SMI_LYNX3DM) || (pSmi->Chipset == SMI_COUGAR3DR)){
	    switch (pScrn->bitsPerPixel) {
	    case 8:
		new->CCR66 = (new->CCR66 & 0xF3) | 0x00; /* 6 bits-RAM */
d2410 4
a2413 3
	    case 16:
		new->CCR66 = (new->CCR66 & 0xF3) | 0x00; /* 6 bits-RAM */
		/* no Gamma correction in 16 Bit mode (s. Release.txt 1.3.1) */
a2414 7
	    case 24:
	    case 32:
		new->CCR66 = (new->CCR66 & 0xF3) | 0x04; /* Gamma correct ON */
		break;
	    default:
		LEAVE_PROC("SMI_ModeInit");
		return(FALSE);
d2417 12
d2430 1
a2430 8
	if (pSmi->Chipset != SMI_COUGAR3DR)
	{
		outb(pSmi->PIOBase + VGA_SEQ_INDEX, 0x30);
		if (inb(pSmi->PIOBase + VGA_SEQ_DATA) & 0x01)
		{
			new->SR21 = 0x00;
		}
	}
d2432 13
a2444 12
	if (pSmi->MCLK > 0)
	{
		SMI_CommonCalcClock(pScrn->scrnIndex, pSmi->MCLK,
				    1, 1, 31, 0, 2,
                                    pScrn->clockRanges->minClock,
                                    pScrn->clockRanges->maxClock,
                                    &new->SR6A, &new->SR6B);
	}
	else
	{
		new->SR6B = 0xFF;
	}
d2446 4
a2449 17
	if ((mode->HDisplay == 640) && SMI_LYNXM_SERIES(pSmi->Chipset))
	{
		vganew->MiscOutReg &= ~0x0C;
	}
	else
	{
		vganew->MiscOutReg |= 0x0C;
	}
	vganew->MiscOutReg |= 0xE0;
	if (mode->HDisplay == 800)
	{
		vganew->MiscOutReg &= ~0xC0;
	}
	if ((mode->HDisplay == 1024) && SMI_LYNXM_SERIES(pSmi->Chipset))
	{
		vganew->MiscOutReg &= ~0xC0;
	}
d2451 1
a2451 2
	/* dualhead */
	if (pSmi->Dualhead) {
d2453 52
a2504 5
	    /* PLL controls */
	    /* set CRT to vclk */
	    new->SR68 = 0x54;
	    /* set LCD to vclk2 */
	    new->SR69 = 0x04;
d2506 2
a2507 1
	    if (pSmi->lcdWidth == 640)
d2509 26
a2534 9
	        /* vclk */
	        new->SR6C = 0x07;
	        new->SR6D = 0x04;

	        /* vclk2 */
	        new->SR6E = 0x07;
	        new->SR6F = 0x04;
	    }
	    else if (pSmi->lcdWidth == 800)
d2536 132
a2667 18
	        /* vclk */
	        new->SR6C = 0x0B;
	        new->SR6D = 0x82;

	        /* vclk2 */
	        new->SR6E = 0x0B;
	        new->SR6F = 0x82;
	    }
	    else
	    {
	        /* vclk */
	        new->SR6C = 0x52;
	        new->SR6D = 0x89;

	        /* vclk2 */
	        new->SR6E = 0x52;
	        new->SR6F = 0x89;
	    }
d2673 1
a2673 1
	    CARD32 fifo1_readoffset, fifo2_readoffset, fifo_writeoffset;
d2675 5
a2679 5
	    /* setting SR21 bit 2 disables ZV circuitry, 
	     * if ZV is needed, SR21 = 0x20
	     */
	    /* enable DAC, PLL, etc. */
	    new->SR21 = 0x24;
d2681 2
a2682 2
	    /* clear DPMS state */
	    new->SR22 = VGAIN8_INDEX(pSmi, VGA_SEQ_INDEX, VGA_SEQ_DATA, 0x22) & ~0x30;
d2684 3
a2686 61
	    /* enable virtual refresh and LCD and CRT outputs */
	    if (pScrn->bitsPerPixel > 8)
		new->SR31 = /*0xCB*/ 0xC3; /* 16 bpp */
	    else
		new->SR31 = /*0x8B*/ 0x83; /* 8 bpp */

	    /* FIFO1 Read Offset */
	    fifo1_readoffset = pSmi->lcdWidth / 2;
	    fifo2_readoffset = pSmi->lcdWidth / 2;
	    new->SR44 = fifo1_readoffset & 0x000000FF;
	    /* FIFO2 Read Offset */
	    new->SR4B = fifo2_readoffset & 0x000000FF;
	    /* FIFO1/2 Read Offset overflow */
	    new->SR4C = (((fifo1_readoffset & 0x00000300) >> 8) << 2) |
		        (((fifo2_readoffset & 0x00000300) >> 8) << 6);

	    /* FIFO Write Offset */
	    fifo_writeoffset = pSmi->lcdWidth / 4;
	    new->SR48 = fifo_writeoffset & 0x000000FF;
	    new->SR49 = (fifo_writeoffset & 0x00000300) >> 8;

	    /* set FIFO levels */
	    new->SR4A = 0x41;

	    /* something related to tv... */
	    new->CR33 |= 0x07;

	}

	/* init graphics engine regs */
	SMI_DPRInit(pScrn);

	/* Set VPR registers (and FPR registers for SM731) */
	switch (pScrn->bitsPerPixel)
	{
		case 8:
			new->VPR00 = 0x00000000;
			new->FPR00_= 0x00080000;
			break;

		case 16:
			new->VPR00 = 0x00020000;
			new->FPR00_= 0x000A0000;
			break;

		case 24:
			new->VPR00 = 0x00040000;
			new->FPR00_= 0x000C0000;
			break;

		case 32:
			new->VPR00 = 0x00030000;
			new->FPR00_= 0x000B0000;
			break;
	}
	new->VPR0C = pSmi->FBOffset >> 3;
	if (pSmi->rotate)
	{
		new->VPR10 = (((( pSmi->height * pSmi->Bpp) >> 3)
				+ 2) << 16) | ((pSmi->height * pSmi->Bpp) >> 3);
	}
d2688 1
a2688 4
	{
		new->VPR10 = ((((pSmi->width * pSmi->Bpp) >> 3)
				+ 2) << 16) | ((pSmi->width * pSmi->Bpp) >> 3);
	}
d2690 98
a2787 50
	new->FPR0C_ = new->VPR0C;
	new->FPR10_ = new->VPR10;

	/* Set CPR registers */
	new->CPR00 = 0x00000000;

	pScrn->vtSema = TRUE;

	/* Find the INT 10 mode number */
	{
		static struct
		{
			int x, y, bpp;
			CARD16 mode;

		} modeTable[] =
		{
			{  640,  480,  8, 0x50 },
			{  640,  480, 16, 0x52 },
			{  640,  480, 24, 0x53 },
			{  640,  480, 32, 0x54 },
			{  800,  480,  8, 0x4A },
			{  800,  480, 16, 0x4C },
			{  800,  480, 24, 0x4D },
			{  800,  600,  8, 0x55 },
			{  800,  600, 16, 0x57 },
			{  800,  600, 24, 0x58 },
			{  800,  600, 32, 0x59 },
			{ 1024,  768,  8, 0x60 },
			{ 1024,  768, 16, 0x62 },
			{ 1024,  768, 24, 0x63 },
			{ 1024,  768, 32, 0x64 },
			{ 1280, 1024,  8, 0x65 },
			{ 1280, 1024, 16, 0x67 },
			{ 1280, 1024, 24, 0x68 },
			{ 1280, 1024, 32, 0x69 },
		};

		new->mode = 0;
		for (i = 0; i < sizeof(modeTable) / sizeof(modeTable[0]); i++)
		{
			if (   (modeTable[i].x == mode->HDisplay)
				&& (modeTable[i].y == mode->VDisplay)
				&& (modeTable[i].bpp == pScrn->bitsPerPixel)
			)
			{
				new->mode = modeTable[i].mode;
				break;
			}
		}
d2789 1
d2791 2
a2792 2
	/* Zero the font memory */
	memset(new->smiFont, 0, sizeof(new->smiFont));
d2794 2
a2795 2
	/* Write the mode registers to hardware */
	SMI_WriteMode(pScrn, vganew, new);
d2797 2
a2798 2
	/* Adjust the viewport */
	SMI_AdjustFrame(pScrn->scrnIndex, pScrn->frameX0, pScrn->frameY0, 0);
d2800 2
a2801 2
	LEAVE_PROC("SMI_ModeInit");
	return(TRUE);
d2814 6
a2819 6
	ScrnInfoPtr pScrn = xf86Screens[scrnIndex];
	vgaHWPtr hwp = VGAHWPTR(pScrn);
	SMIPtr pSmi = SMIPTR(pScrn);
	vgaRegPtr vgaSavePtr = &hwp->SavedReg;
	SMIRegPtr SMISavePtr = &pSmi->SavedReg;
	Bool ret;
d2821 1
a2821 1
	ENTER_PROC("SMI_CloseScreen");
d2823 5
a2827 6
	if (pScrn->vtSema)
	{
		SMI_WriteMode(pScrn, vgaSavePtr, SMISavePtr);
		vgaHWLock(hwp);
		SMI_UnmapMem(pScrn);
	}
d2829 35
a2863 39
	if (pSmi->AccelInfoRec != NULL)
	{
		XAADestroyInfoRec(pSmi->AccelInfoRec);
	}
	if (pSmi->CursorInfoRec != NULL)
	{
		xf86DestroyCursorInfoRec(pSmi->CursorInfoRec);
	}
	if (pSmi->DGAModes != NULL)
	{
		xfree(pSmi->DGAModes);
	}
	if (pSmi->pInt10 != NULL)
	{
		xf86FreeInt10(pSmi->pInt10);
		pSmi->pInt10 = NULL;
	}
	if (pSmi->ptrAdaptor != NULL)
	{
		xfree(pSmi->ptrAdaptor);
	}
	if (pSmi->BlockHandler != NULL)
	{
		pScreen->BlockHandler = pSmi->BlockHandler;
	}
	/* #670 */
	if (pSmi->pSaveBuffer)
	{
		xfree(pSmi->pSaveBuffer);
	}
	/* #920 */
	if (pSmi->paletteBuffer)
	{
		xfree(pSmi->paletteBuffer);
	}

	pScrn->vtSema = FALSE;
	pScreen->CloseScreen = pSmi->CloseScreen;
	ret = (*pScreen->CloseScreen)(scrnIndex, pScreen);
d2865 2
a2866 2
	LEAVE_PROC("SMI_CloseScreen");
	return(ret);
d2872 1
a2872 1
	SMI_FreeRec(xf86Screens[scrnIndex]);
d2878 1
a2878 1
	Bool ret;
d2880 1
a2880 1
	ENTER_PROC("SMI_SaveScreen");
d2882 1
a2882 1
	ret = vgaHWSaveScreen(pScreen, mode);
d2884 2
a2885 2
	LEAVE_PROC("SMI_SaveScreen");
	return(ret);
d2891 23
a2913 9
	ScrnInfoPtr pScrn = xf86Screens[scrnIndex];
	SMIPtr pSmi = SMIPTR(pScrn);
	CARD32 Base, lcdBase;

	ENTER_PROC("SMI_AdjustFrame");

	if (pSmi->ShowCache && y)
	{
		y += pScrn->virtualY - 1;
d2915 3
a2917 11

	if (pSmi->Dualhead) {
	    lcdBase = 0;
	    x = pSmi->lcdWidth;
	    y = 0;
	}

	Base = pSmi->FBOffset + (x + y * pScrn->virtualX) * pSmi->Bpp;
	if (SMI_LYNX3D_SERIES(pSmi->Chipset) || SMI_COUGAR_SERIES(pSmi->Chipset))
	{
		Base = (Base + 15) & ~15;
d2919 2
a2920 5
		while ((Base % pSmi->Bpp) > 0)
		{
			Base -= 16;
		}
#endif
a2921 8
	else
	{
		Base = (Base + 7) & ~7;
#if 1 /* PDR#1058 */
		while ((Base % pSmi->Bpp) > 0)
		{
			Base -= 8;
		}
d2923 1
a2923 2
	}

d2925 1
a2925 1
	if (pSmi->Dualhead) {
d2927 2
a2928 2
	    /* FIFO1 read start address */
	    VGAOUT8_INDEX(pSmi, VGA_SEQ_INDEX, VGA_SEQ_DATA, 0x40, 
d2930 1
a2930 1
	    VGAOUT8_INDEX(pSmi, VGA_SEQ_INDEX, VGA_SEQ_DATA, 0x41, 
d2933 2
a2934 2
	    /* FIFO2 read start address */
	    VGAOUT8_INDEX(pSmi, VGA_SEQ_INDEX, VGA_SEQ_DATA, 0x42, 
d2936 1
a2936 1
	    VGAOUT8_INDEX(pSmi, VGA_SEQ_INDEX, VGA_SEQ_DATA, 0x43, 
d2939 2
a2940 2
	    /* FIFO1/2 read start address overflow */
	    VGAOUT8_INDEX(pSmi, VGA_SEQ_INDEX, VGA_SEQ_DATA, 0x45, 
d2943 1
a2943 1
	}
d2945 4
a2948 5
	WRITE_VPR(pSmi, 0x0C, Base >> 3);
	if(pSmi->Chipset == SMI_COUGAR3DR)
	{
		WRITE_FPR(pSmi, FPR0C, Base >> 3);
	}
d2950 1
a2950 1
	LEAVE_PROC("SMI_AdjustFrame");
d2956 2
a2957 1
	Bool ret;
d2959 1
a2959 1
	ENTER_PROC("SMI_SwitchMode");
d2961 3
a2963 1
	ret = SMI_ModeInit(xf86Screens[scrnIndex], mode);
d2965 2
a2966 2
	LEAVE_PROC("SMI_SwitchMode");
	return(ret);
d2973 2
a2974 2
	SMIPtr pSmi = SMIPTR(pScrn);
	int i;
d2976 1
a2976 6
	ENTER_PROC("SMI_LoadPalette");

	/* Enable both the CRT and LCD DAC RAM paths, so both palettes are updated */
    if ((pSmi->Chipset == SMI_LYNX3DM) || (pSmi->Chipset == SMI_COUGAR3DR)) 
	{
		CARD8 ccr66;
d2978 9
a2986 4
		ccr66  = VGAIN8_INDEX(pSmi, VGA_SEQ_INDEX, VGA_SEQ_DATA, 0x66);
		ccr66 &= 0x0f;
		VGAOUT8_INDEX(pSmi, VGA_SEQ_INDEX, VGA_SEQ_DATA, 0x66, ccr66);
	}
d2988 1
a2988 2
	for(i = 0; i < numColors; i++)
	{
d2990 6
a2995 6
           colors[indicies[i]].red, colors[indicies[i]].green, colors[indicies[i]].blue));
		VGAOUT8(pSmi, VGA_DAC_WRITE_ADDR, indicies[i]);
		VGAOUT8(pSmi, VGA_DAC_DATA, colors[indicies[i]].red);
		VGAOUT8(pSmi, VGA_DAC_DATA, colors[indicies[i]].green);
		VGAOUT8(pSmi, VGA_DAC_DATA, colors[indicies[i]].blue);
	}
d2997 1
a2997 1
	LEAVE_PROC("SMI_LoadPalette");
d3003 2
a3004 2
	SMIPtr pSmi = SMIPTR(pScrn);
	CARD8 tmp;
d3006 4
a3009 4
	if (!(tmp = VGAIN8(pSmi, VGA_DAC_MASK)))
	  return;
	pSmi->DACmask = tmp;
	VGAOUT8(pSmi, VGA_DAC_MASK, 0);
d3015 1
a3015 1
	SMIPtr pSmi = SMIPTR(pScrn);
d3017 1
a3017 1
	VGAOUT8(pSmi, VGA_DAC_MASK, pSmi->DACmask);
d3024 23
a3046 23
	vgaHWPtr hwp = VGAHWPTR(pScrn);
	SMIPtr pSmi = SMIPTR(pScrn);
	CARD8 tmp;

	ENTER_PROC("SMI_EnableMmio");

	/*
	 * Enable chipset (seen on uninitialized secondary cards) might not be
	 * needed once we use the VGA softbooter
	 */
	vgaHWSetStdFuncs(hwp);

	/* Enable linear mode */
	outb(pSmi->PIOBase + VGA_SEQ_INDEX, 0x18);
	tmp = inb(pSmi->PIOBase + VGA_SEQ_DATA);
	pSmi->SR18Value = tmp;					/* PDR#521 */
	outb(pSmi->PIOBase + VGA_SEQ_DATA, tmp | 0x11);

	/* Enable 2D/3D Engine and Video Processor */
	outb(pSmi->PIOBase + VGA_SEQ_INDEX, 0x21);
	tmp = inb(pSmi->PIOBase + VGA_SEQ_DATA);
	pSmi->SR21Value = tmp;					/* PDR#521 */
	outb(pSmi->PIOBase + VGA_SEQ_DATA, tmp & ~0x03);
d3048 1
a3048 1
	LEAVE_PROC("SMI_EnableMmio");
d3054 2
a3055 2
	vgaHWPtr hwp = VGAHWPTR(pScrn);
	SMIPtr pSmi = SMIPTR(pScrn);
d3057 1
a3057 1
	ENTER_PROC("SMI_DisableMmio");
d3059 1
a3059 1
	vgaHWSetStdFuncs(hwp);
d3061 3
a3063 3
	/* Disable 2D/3D Engine and Video Processor */
	outb(pSmi->PIOBase + VGA_SEQ_INDEX, 0x21);
	outb(pSmi->PIOBase + VGA_SEQ_DATA, pSmi->SR21Value);	/* PDR#521 */
d3065 3
a3067 3
	/* Disable linear mode */
	outb(pSmi->PIOBase + VGA_SEQ_INDEX, 0x18);
	outb(pSmi->PIOBase + VGA_SEQ_DATA, pSmi->SR18Value);	/* PDR#521 */
d3069 1
a3069 1
	LEAVE_PROC("SMI_DisableMmio");
d3076 45
a3120 55
	unsigned char i;
	vgaHWPtr hwp = VGAHWPTR(pScrn);
	SMIPtr pSmi = SMIPTR(pScrn);
	int vgaCRIndex = hwp->IOBase + VGA_CRTC_INDEX_OFFSET;
	int vgaCRReg   = hwp->IOBase + VGA_CRTC_DATA_OFFSET;
	int vgaStatus  = hwp->IOBase + VGA_IN_STAT_1_OFFSET;

	xf86DrvMsgVerb(pScrn->scrnIndex, X_INFO, VERBLEV,
			"START register dump ------------------\n");

	xf86ErrorFVerb(VERBLEV, "MISCELLANEOUS OUTPUT\n    %02X\n",
			VGAIN8(pSmi, VGA_MISC_OUT_R));

	xf86ErrorFVerb(VERBLEV, "\nSEQUENCER\n"
			"    x0 x1 x2 x3  x4 x5 x6 x7  x8 x9 xA xB  xC xD xE xF");
	for (i = 0x00; i <= 0xAF; i++)
	{
		if ((i & 0xF) == 0x0) xf86ErrorFVerb(VERBLEV, "\n%02X|", i);
		if ((i & 0x3) == 0x0) xf86ErrorFVerb(VERBLEV, " ");
		xf86ErrorFVerb(VERBLEV, "%02X ",
				VGAIN8_INDEX(pSmi, VGA_SEQ_INDEX, VGA_SEQ_DATA, i));
	}

	xf86ErrorFVerb(VERBLEV, "\n\nCRT CONTROLLER\n"
			"    x0 x1 x2 x3  x4 x5 x6 x7  x8 x9 xA xB  xC xD xE xF");
	for (i = 0x00; i <= 0xAD; i++)
	{
		if (i == 0x20) i = 0x30;
		if (i == 0x50) i = 0x90;
		if ((i & 0xF) == 0x0) xf86ErrorFVerb(VERBLEV, "\n%02X|", i);
		if ((i & 0x3) == 0x0) xf86ErrorFVerb(VERBLEV, " ");
		xf86ErrorFVerb(VERBLEV, "%02X ",
				VGAIN8_INDEX(pSmi, vgaCRIndex, vgaCRReg, i));
	}

	xf86ErrorFVerb(VERBLEV, "\n\nGRAPHICS CONTROLLER\n"
			"    x0 x1 x2 x3  x4 x5 x6 x7  x8 x9 xA xB  xC xD xE xF");
	for (i = 0x00; i <= 0x08; i++)
	{
		if ((i & 0xF) == 0x0) xf86ErrorFVerb(VERBLEV, "\n%02X|", i);
		if ((i & 0x3) == 0x0) xf86ErrorFVerb(VERBLEV, " ");
		xf86ErrorFVerb(VERBLEV, "%02X ",
				VGAIN8_INDEX(pSmi, VGA_GRAPH_INDEX, VGA_GRAPH_DATA, i));
	}

	xf86ErrorFVerb(VERBLEV, "\n\nATTRIBUTE 0CONTROLLER\n"
			"    x0 x1 x2 x3  x4 x5 x6 x7  x8 x9 xA xB  xC xD xE xF");
	for (i = 0x00; i <= 0x14; i++)
	{
		(void) VGAIN8(pSmi, vgaStatus);
		if ((i & 0xF) == 0x0) xf86ErrorFVerb(VERBLEV, "\n%02X|", i);
		if ((i & 0x3) == 0x0) xf86ErrorFVerb(VERBLEV, " ");
		xf86ErrorFVerb(VERBLEV, "%02X ",
				VGAIN8_INDEX(pSmi, VGA_ATTR_INDEX, VGA_ATTR_DATA_R, i));
	}
d3122 29
a3150 26
	VGAOUT8(pSmi, VGA_ATTR_INDEX, 0x20);

	xf86ErrorFVerb(VERBLEV, "\n\nDPR    x0       x4       x8       xC");
	for (i = 0x00; i <= 0x44; i += 4)
	{
		if ((i & 0xF) == 0x0) xf86ErrorFVerb(VERBLEV, "\n%02X|", i);
		xf86ErrorFVerb(VERBLEV, " %08lX", (unsigned long)READ_DPR(pSmi, i));
	}

	xf86ErrorFVerb(VERBLEV, "\n\nVPR    x0       x4       x8       xC");
	for (i = 0x00; i <= 0x60; i += 4)
	{
		if ((i & 0xF) == 0x0) xf86ErrorFVerb(VERBLEV, "\n%02X|", i);
		xf86ErrorFVerb(VERBLEV, " %08lX", (unsigned long)READ_VPR(pSmi, i));
	}

	xf86ErrorFVerb(VERBLEV, "\n\nCPR    x0       x4       x8       xC");
	for (i = 0x00; i <= 0x18; i += 4)
	{
		if ((i & 0xF) == 0x0) xf86ErrorFVerb(VERBLEV, "\n%02X|", i);
		xf86ErrorFVerb(VERBLEV, " %08lX", (unsigned long)READ_CPR(pSmi, i));
	}

	xf86ErrorFVerb(VERBLEV, "\n\n");
	xf86DrvMsgVerb(pScrn->scrnIndex, X_INFO, VERBLEV,
			"END register dump --------------------\n");
d3161 3
a3163 3
	vgaHWPtr hwp = VGAHWPTR(pScrn);
	SMIPtr pSmi = SMIPTR(pScrn);
	CARD8 SR01, SR20, SR21, SR22, SR23, SR24, SR31, SR34;
d3165 1
a3165 1
	ENTER_PROC("SMI_DisplayPowerManagementSet");
d3167 5
a3171 6
	/* If we already are in the requested DPMS mode, just return */
	if (pSmi->CurrentDPMS == PowerManagementMode)
	{
		LEAVE_PROC("SMI_DisplayPowerManagementSet");
		return;
	}
d3174 21
a3194 27
	if (pSmi->useBIOS && pSmi->pInt10 != NULL)
	{
		pSmi->pInt10->ax = 0x4F10;
		switch (PowerManagementMode)
		{
			case DPMSModeOn:
				pSmi->pInt10->bx = 0x0001;
				break;

			case DPMSModeStandby:
				pSmi->pInt10->bx = 0x0101;
				break;

			case DPMSModeSuspend:
				pSmi->pInt10->bx = 0x0201;
				break;

			case DPMSModeOff:
				pSmi->pInt10->bx = 0x0401;
				break;
		}
		pSmi->pInt10->cx = 0x0000;
		pSmi->pInt10->num = 0x10;
		xf86ExecX86int10(pSmi->pInt10);
		if (pSmi->pInt10->ax == 0x004F)
		{
			pSmi->CurrentDPMS = PowerManagementMode;
d3196 5
a3200 6
			if (PowerManagementMode == DPMSModeOn)
			{
				SR01 = VGAIN8_INDEX(pSmi, VGA_SEQ_INDEX, VGA_SEQ_DATA, 0x01);
				VGAOUT8_INDEX(pSmi, VGA_SEQ_INDEX, VGA_SEQ_DATA, 0x01,
						SR01 & ~0x20);
			}
d3202 2
a3203 3
			LEAVE_PROC("SMI_DisplayPowerManagementSet");
			return;
		}
d3205 1
d3208 69
a3276 18
	/* Save the current SR registers */
	if (pSmi->CurrentDPMS == DPMSModeOn)
	{
		pSmi->DPMS_SR20 = VGAIN8_INDEX(pSmi, VGA_SEQ_INDEX, VGA_SEQ_DATA, 0x20);
		pSmi->DPMS_SR21 = VGAIN8_INDEX(pSmi, VGA_SEQ_INDEX, VGA_SEQ_DATA, 0x21);
		pSmi->DPMS_SR31 = VGAIN8_INDEX(pSmi, VGA_SEQ_INDEX, VGA_SEQ_DATA, 0x31);
		pSmi->DPMS_SR34 = VGAIN8_INDEX(pSmi, VGA_SEQ_INDEX, VGA_SEQ_DATA, 0x34);
	}

	/* Read the required SR registers for the DPMS handler */
	SR01 = VGAIN8_INDEX(pSmi, VGA_SEQ_INDEX, VGA_SEQ_DATA, 0x01);
	SR20 = VGAIN8_INDEX(pSmi, VGA_SEQ_INDEX, VGA_SEQ_DATA, 0x20);
	SR21 = VGAIN8_INDEX(pSmi, VGA_SEQ_INDEX, VGA_SEQ_DATA, 0x21);
	SR22 = VGAIN8_INDEX(pSmi, VGA_SEQ_INDEX, VGA_SEQ_DATA, 0x22);
	SR23 = VGAIN8_INDEX(pSmi, VGA_SEQ_INDEX, VGA_SEQ_DATA, 0x23);
	SR24 = VGAIN8_INDEX(pSmi, VGA_SEQ_INDEX, VGA_SEQ_DATA, 0x24);
	SR31 = VGAIN8_INDEX(pSmi, VGA_SEQ_INDEX, VGA_SEQ_DATA, 0x31);
	SR34 = VGAIN8_INDEX(pSmi, VGA_SEQ_INDEX, VGA_SEQ_DATA, 0x34);
d3278 13
a3290 70
	switch (PowerManagementMode)
	{
		case DPMSModeOn:
			/* Screen On: HSync: On, VSync : On */
			SR01 &= ~0x20;
			SR20  = pSmi->DPMS_SR20;
			SR21  = pSmi->DPMS_SR21;
			SR22 &= ~0x30;
			SR23 &= ~0xC0;
			SR24 |= 0x01;
			SR31  = pSmi->DPMS_SR31;
			SR34  = pSmi->DPMS_SR34;
			break;

		case DPMSModeStandby:
			/* Screen: Off; HSync: Off, VSync: On */
			SR01 |= 0x20;
			SR20  = (SR20 & ~0xB0) | 0x10;
			SR21 |= 0x88;
			SR22  = (SR22 & ~0x30) | 0x10;
			SR23  = (SR23 & ~0x07) | 0xD8;
			SR24 &= ~0x01;
			SR31  = (SR31 & ~0x07) | 0x00;
			SR34 |= 0x80;
			break;

		case DPMSModeSuspend:
			/* Screen: Off; HSync: On, VSync: Off */
			SR01 |= 0x20;
			SR20  = (SR20 & ~0xB0) | 0x10;
			SR21 |= 0x88;
			SR22  = (SR22 & ~0x30) | 0x20;
			SR23  = (SR23 & ~0x07) | 0xD8;
			SR24 &= ~0x01;
			SR31  = (SR31 & ~0x07) | 0x00;
			SR34 |= 0x80;
			break;

		case DPMSModeOff:
			/* Screen: Off; HSync: Off, VSync: Off */
			SR01 |= 0x20;
			SR20  = (SR20 & ~0xB0) | 0x10;
			SR21 |= 0x88;
			SR22  = (SR22 & ~0x30) | 0x30;
			SR23  = (SR23 & ~0x07) | 0xD8;
			SR24 &= ~0x01;
			SR31  = (SR31 & ~0x07) | 0x00;
			SR34 |= 0x80;
			break;

		default:
			xf86ErrorFVerb(VERBLEV, "Invalid PowerManagementMode %d passed to "
					"SMI_DisplayPowerManagementSet\n", PowerManagementMode);
			LEAVE_PROC("SMI_DisplayPowerManagementSet");
			return;
	}

	/* Wait for vertical retrace */
	while (hwp->readST01(hwp) & 0x8) ;
	while (!(hwp->readST01(hwp) & 0x8)) ;

	/* Write the registers */
	VGAOUT8_INDEX(pSmi, VGA_SEQ_INDEX, VGA_SEQ_DATA, 0x01, SR01);
	VGAOUT8_INDEX(pSmi, VGA_SEQ_INDEX, VGA_SEQ_DATA, 0x34, SR34);
	VGAOUT8_INDEX(pSmi, VGA_SEQ_INDEX, VGA_SEQ_DATA, 0x31, SR31);
	VGAOUT8_INDEX(pSmi, VGA_SEQ_INDEX, VGA_SEQ_DATA, 0x20, SR20);
	VGAOUT8_INDEX(pSmi, VGA_SEQ_INDEX, VGA_SEQ_DATA, 0x22, SR22);
	VGAOUT8_INDEX(pSmi, VGA_SEQ_INDEX, VGA_SEQ_DATA, 0x23, SR23);
	VGAOUT8_INDEX(pSmi, VGA_SEQ_INDEX, VGA_SEQ_DATA, 0x21, SR21);
	VGAOUT8_INDEX(pSmi, VGA_SEQ_INDEX, VGA_SEQ_DATA, 0x24, SR24);
d3292 2
a3293 2
	/* Save the current power state */
	pSmi->CurrentDPMS = PowerManagementMode;
d3295 1
a3295 1
	LEAVE_PROC("SMI_DisplayPowerManagementSet");
d3301 6
a3306 7
	vbeInfoPtr pVbe;
	if (xf86LoadSubModule(pScrn, "vbe"))
	{
		pVbe = VBEInit(NULL, index);
		ConfiguredMonitor = vbeDoEDID(pVbe, NULL);
		vbeFree(pVbe);
	}
d3312 3
a3314 3
	register vgaHWPtr hwp = VGAHWPTR(pScrn);
	SMIPtr pSmi = SMIPTR(pScrn);
	unsigned int ret;
d3316 1
a3316 1
	ENTER_PROC("SMI_ddc1Read");
d3318 2
a3319 2
	while (hwp->readST01(hwp) & 0x8) ;
	while (!(hwp->readST01(hwp) & 0x8)) ;
d3321 1
a3321 1
	ret = VGAIN8_INDEX(pSmi, VGA_SEQ_INDEX, VGA_SEQ_DATA, 0x72) & 0x08;
d3323 2
a3324 2
	LEAVE_PROC("SMI_ddc1Read");
	return(ret);
d3330 18
a3347 19
	ScrnInfoPtr pScrn = xf86Screens[scrnIndex];
	SMIPtr pSmi = SMIPTR(pScrn);
	Bool success = FALSE;
	xf86MonPtr pMon;
	unsigned char tmp;

	ENTER_PROC("SMI_ddc1");

	tmp = VGAIN8_INDEX(pSmi, VGA_SEQ_INDEX, VGA_SEQ_DATA, 0x72);
	VGAOUT8_INDEX(pSmi, VGA_SEQ_INDEX, VGA_SEQ_DATA, 0x72, tmp | 0x20);

	pMon = xf86PrintEDID(xf86DoEDID_DDC1(scrnIndex,
					     vgaHWddc1SetSpeedWeak(),
					     SMI_ddc1Read));
	if (pMon != NULL)
	{
		success = TRUE;
	}
	xf86SetDDCproperties(pScrn, pMon);
d3349 1
a3349 1
	VGAOUT8_INDEX(pSmi, VGA_SEQ_INDEX, VGA_SEQ_DATA, 0x72, tmp);
d3351 2
a3352 2
	LEAVE_PROC("SMI_ddc1");
	return(success);
d3354 1
@


1.1.1.1
log
@Importing xf86-video-siliconmotion 1.4.2
@
text
@@
