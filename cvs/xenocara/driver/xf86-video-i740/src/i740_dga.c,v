head	1.5;
access;
symbols
	OPENBSD_6_0:1.5.0.14
	OPENBSD_6_0_BASE:1.5
	OPENBSD_5_9:1.5.0.12
	OPENBSD_5_9_BASE:1.5
	OPENBSD_5_8:1.5.0.10
	OPENBSD_5_8_BASE:1.5
	OPENBSD_5_7:1.5.0.8
	OPENBSD_5_7_BASE:1.5
	OPENBSD_5_6:1.5.0.6
	OPENBSD_5_6_BASE:1.5
	OPENBSD_5_5:1.5.0.4
	OPENBSD_5_5_BASE:1.5
	OPENBSD_5_4:1.5.0.2
	OPENBSD_5_4_BASE:1.5
	OPENBSD_5_3:1.4.0.2
	OPENBSD_5_3_BASE:1.4
	OPENBSD_5_2:1.3.0.2
	OPENBSD_5_2_BASE:1.3
	OPENBSD_5_1_BASE:1.2
	OPENBSD_5_1:1.2.0.14
	OPENBSD_5_0:1.2.0.12
	OPENBSD_5_0_BASE:1.2
	OPENBSD_4_9:1.2.0.8
	OPENBSD_4_9_BASE:1.2
	OPENBSD_4_8:1.2.0.10
	OPENBSD_4_8_BASE:1.2
	OPENBSD_4_7:1.2.0.6
	OPENBSD_4_7_BASE:1.2
	OPENBSD_4_6:1.2.0.4
	OPENBSD_4_6_BASE:1.2
	OPENBSD_4_5:1.2.0.2
	OPENBSD_4_5_BASE:1.2
	OPENBSD_4_4:1.1.1.1.0.6
	OPENBSD_4_4_BASE:1.1.1.1
	OPENBSD_4_3_BASE:1.1.1.1
	OPENBSD_4_3:1.1.1.1.0.4
	OPENBSD_4_2:1.1.1.1.0.2
	OPENBSD_4_2_BASE:1.1.1.1
	v1_1_0:1.1.1.1
	xorg:1.1.1;
locks; strict;
comment	@ * @;


1.5
date	2013.06.13.21.53.26;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2012.08.16.16.17.28;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2012.05.13.20.07.37;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2008.10.12.20.41.53;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.26.20.05.15;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.11.26.20.05.15;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.5
log
@Fix loading the driver without XAA
@
text
@/*
 * Copyright 2001 by Patrick LERDA
 *
 * Permission to use, copy, modify, distribute, and sell this software and its
 * documentation for any purpose is hereby granted without fee, provided that
 * the above copyright notice appear in all copies and that both that
 * copyright notice and this permission notice appear in supporting
 * documentation, and that the name of Patrick LERDA not be used in
 * advertising or publicity pertaining to distribution of the software without
 * specific, written prior permission.  Patrick LERDA makes no representations
 * about the suitability of this software for any purpose.  It is provided
 * "as is" without express or implied warranty.
 *
 * PATRICK LERDA DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
 * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO
 * EVENT SHALL PATRICK LERDA BE LIABLE FOR ANY SPECIAL, INDIRECT OR
 * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
 * DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
 * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
 * PERFORMANCE OF THIS SOFTWARE.
 *
 * Authors:  Patrick LERDA
 */

#ifdef HAVE_CONFIG_H
#include "config.h"
#endif

#include "xf86.h"
#include "xf86_OSproc.h"
#include "xf86Pci.h"
#include "xf86PciInfo.h"
#include "vgaHW.h"
#include "xf86xv.h"
#include "i740.h"
#ifdef HAVE_XAA_H
#include "xaalocal.h"
#endif
#include "dgaproc.h"
#include "i740_dga.h"

static Bool I740_OpenFramebuffer(ScrnInfoPtr, char **, unsigned char **, int *, int *, int *);
static Bool I740_SetMode(ScrnInfoPtr, DGAModePtr);
static int  I740_GetViewport(ScrnInfoPtr);
static void I740_SetViewport(ScrnInfoPtr, int, int, int);
#ifdef HAVE_XAA_H
static void I740_Sync(ScrnInfoPtr);
static void I740_FillRect(ScrnInfoPtr, int, int, int, int, unsigned long);
static void I740_BlitRect(ScrnInfoPtr, int, int, int, int, int, int);
#if 0
static void I740_BlitTransRect(ScrnInfoPtr, int, int, int, int, int, int, unsigned long);
#endif
#endif
static DGAFunctionRec I740DGAFuncs = {
   I740_OpenFramebuffer,
   NULL,
   I740_SetMode,
   I740_SetViewport,
   I740_GetViewport,
#ifdef HAVE_XAA_H
   I740_Sync,
   I740_FillRect,
   I740_BlitRect,
#if 0
   I740_BlitTransRect
#else
   NULL
#endif
#else
   NULL, NULL, NULL, NULL
#endif
};

Bool I740DGAInit(ScreenPtr pScreen)
{   
  ScrnInfoPtr pScrn = xf86ScreenToScrn(pScreen);
  I740Ptr pI740 = I740PTR(pScrn);
  DGAModePtr modes = NULL, newmodes = NULL, currentMode;
  DisplayModePtr pMode, firstMode;
  int Bpp = pScrn->bitsPerPixel >> 3;
  int num = 0;

  pMode = firstMode = pScrn->modes;

  while(pMode) {

    newmodes = realloc(modes, (num + 1) * sizeof(DGAModeRec));

    if(!newmodes) {
      free(modes);
      return FALSE;
    }
    modes = newmodes;

    currentMode = modes + num;
    num++;

    currentMode->mode = pMode;
    currentMode->flags = DGA_CONCURRENT_ACCESS | DGA_PIXMAP_AVAILABLE;
#ifdef HAVE_XAA_H
    if(pI740->AccelInfoRec)
      currentMode->flags |= DGA_FILL_RECT | DGA_BLIT_RECT;
#endif
    if(pMode->Flags & V_DBLSCAN)
      currentMode->flags |= DGA_DOUBLESCAN;
    if(pMode->Flags & V_INTERLACE)
      currentMode->flags |= DGA_INTERLACED;
    currentMode->byteOrder = pScrn->imageByteOrder;
    currentMode->depth = pScrn->depth;
    currentMode->bitsPerPixel = pScrn->bitsPerPixel;
    currentMode->red_mask = pScrn->mask.red;
    currentMode->green_mask = pScrn->mask.green;
    currentMode->blue_mask = pScrn->mask.blue;
    currentMode->visualClass = (Bpp == 1) ? PseudoColor : TrueColor;
    currentMode->viewportWidth = pMode->HDisplay;
    currentMode->viewportHeight = pMode->VDisplay;
    currentMode->xViewportStep = (Bpp == 3) ? 2 : 1;
    currentMode->yViewportStep = 1;
    currentMode->viewportFlags = DGA_FLIP_RETRACE;
    currentMode->offset = 0;
    currentMode->address = pI740->FbBase;

    currentMode->bytesPerScanline = 
      ((pScrn->displayWidth * Bpp) + 3) & ~3L;
    currentMode->imageWidth = pI740->FbMemBox.x2;
    currentMode->imageHeight =  pI740->FbMemBox.y2;
    currentMode->pixmapWidth = currentMode->imageWidth;
    currentMode->pixmapHeight = currentMode->imageHeight;
    currentMode->maxViewportX = currentMode->imageWidth - 
      currentMode->viewportWidth;
    /* this might need to get clamped to some maximum */
    currentMode->maxViewportY = currentMode->imageHeight -
      currentMode->viewportHeight;

    pMode = pMode->next;
    if(pMode == firstMode)
      break;
  }

  pI740->numDGAModes = num;
  pI740->DGAModes = modes;

  return DGAInit(pScreen, &I740DGAFuncs, modes, num);  
}

static DisplayModePtr I740SavedDGAModes[MAXSCREENS];

static Bool I740_SetMode(ScrnInfoPtr pScrn, DGAModePtr pMode)
{
  int index = pScrn->pScreen->myNum;
  I740Ptr pI740 = I740PTR(pScrn);

  if(!pMode) { /* restore the original mode */
    if(pI740->DGAactive) {
      pScrn->currentMode = I740SavedDGAModes[index];
      I740SwitchMode(SWITCH_MODE_ARGS(pScrn, pScrn->currentMode));
      I740AdjustFrame(ADJUST_FRAME_ARGS(pScrn, 0, 0));
      pI740->DGAactive = FALSE;
    }
  } else {
    if(!pI740->DGAactive) {
      I740SavedDGAModes[index] = pScrn->currentMode;
      pI740->DGAactive = TRUE;
    }

    I740SwitchMode(SWITCH_MODE_ARGS(pScrn, pMode->mode));
  }
   
  return TRUE;
}

static int I740_GetViewport(ScrnInfoPtr pScrn)
{
  I740Ptr pI740 = I740PTR(pScrn);

  return pI740->DGAViewportStatus;
}

static void I740_SetViewport(ScrnInfoPtr pScrn, int x, int y, int flags)
{
  I740Ptr pI740 = I740PTR(pScrn);
  vgaHWPtr hwp = VGAHWPTR(pScrn);

  I740AdjustFrame(ADJUST_FRAME_ARGS(pScrn, x, y));

  /* wait for retrace */
  while((hwp->readST01(hwp) & 0x08));
  while(!(hwp->readST01(hwp) & 0x08));

  pI740->DGAViewportStatus = 0; 
}

#ifdef HAVE_XAA_H
static void I740_FillRect(ScrnInfoPtr pScrn, int x, int y, int w, int h, unsigned long color)
{
  I740Ptr pI740 = I740PTR(pScrn);

  if(pI740->AccelInfoRec) {
    (*pI740->AccelInfoRec->SetupForSolidFill)(pScrn, color, GXcopy, ~0);
    (*pI740->AccelInfoRec->SubsequentSolidFillRect)(pScrn, x, y, w, h);
    SET_SYNC_FLAG(pI740->AccelInfoRec);
  }
}

static void I740_Sync(ScrnInfoPtr pScrn)
{
  I740Ptr pI740 = I740PTR(pScrn);

  if(pI740->AccelInfoRec) {
    (*pI740->AccelInfoRec->Sync)(pScrn);
  }
}

static void I740_BlitRect(
   ScrnInfoPtr pScrn, 
   int srcx, int srcy, 
   int w, int h, 
   int dstx, int dsty
   ){
  I740Ptr pI740 = I740PTR(pScrn);

  if(pI740->AccelInfoRec) {
    int xdir = ((srcx < dstx) && (srcy == dsty)) ? -1 : 1;
    int ydir = (srcy < dsty) ? -1 : 1;

    (*pI740->AccelInfoRec->SetupForScreenToScreenCopy)(pScrn, xdir, ydir, GXcopy, ~0, -1);
    (*pI740->AccelInfoRec->SubsequentScreenToScreenCopy)(pScrn, srcx, srcy, dstx, dsty, w, h);
    SET_SYNC_FLAG(pI740->AccelInfoRec);
  }
}
#endif
#if 0
static void I740_BlitTransRect(ScrnInfoPtr pScrn, 
			       int srcx, int srcy, 
			       int w, int h, 
			       int dstx, int dsty,
			       unsigned long color
			       )
{
  /* this one should be separate since the XAA function would
     prohibit usage of ~0 as the key */
}
#endif

static Bool I740_OpenFramebuffer(
				 ScrnInfoPtr pScrn, 
				 char **name,
				 unsigned char **mem,
				 int *size,
				 int *offset,
				 int *flags
				 ){
    I740Ptr pI740 = I740PTR(pScrn);

    *name = NULL; 		/* no special device */
    *mem = (unsigned char*)pI740->LinearAddr;
    *size = pI740->FbMapSize;
    *offset = 0;
    *flags = DGA_NEED_ROOT;

    return TRUE;
}
@


1.4
log
@Update to xf86-video-i740 1.3.4
@
text
@a43 1
static void I740_Sync(ScrnInfoPtr);
d47 1
d60 1
a61 1
#ifdef HAVE_XAA_H
d70 1
a70 1
   NULL, NULL, NULL
@


1.3
log
@Update to xf86-video-i740 1.3.3
@
text
@a32 2
#include "xaa.h"
#include "xaalocal.h"
d36 3
d47 1
d53 1
a53 1

d61 1
d69 3
d76 1
a76 1
  ScrnInfoPtr pScrn = xf86Screens[pScreen->myNum];
d100 1
d103 1
d156 2
a157 2
      I740SwitchMode(index, pScrn->currentMode, 0);
      I740AdjustFrame(index, 0, 0, 0);
d166 1
a166 1
    I740SwitchMode(index, pMode->mode, 0);
d184 1
a184 1
  I740AdjustFrame(pScrn->pScreen->myNum, x, y, flags);
d193 1
d231 1
a231 1

@


1.2
log
@xf86-video-i740 1.2.0
@
text
@d81 1
a81 1
    newmodes = xrealloc(modes, (num + 1) * sizeof(DGAModeRec));
d84 1
a84 1
      xfree(modes);
@


1.1
log
@Initial revision
@
text
@a23 1
/* $XFree86: xc/programs/Xserver/hw/xfree86/drivers/i740/i740_dga.c,v 1.1tsi Exp $ */
@


1.1.1.1
log
@Importing xf86-video-i740 1.1.0
@
text
@@
