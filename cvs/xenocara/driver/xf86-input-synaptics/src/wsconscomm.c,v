head	1.17;
access;
symbols
	OPENBSD_6_2:1.17.0.4
	OPENBSD_6_2_BASE:1.17
	OPENBSD_6_1:1.17.0.2
	OPENBSD_6_1_BASE:1.17
	OPENBSD_6_0:1.15.0.2
	OPENBSD_6_0_BASE:1.15
	OPENBSD_5_9:1.13.0.2
	OPENBSD_5_9_BASE:1.13
	OPENBSD_5_8:1.12.0.4
	OPENBSD_5_8_BASE:1.12
	OPENBSD_5_7:1.12.0.2
	OPENBSD_5_7_BASE:1.12
	OPENBSD_5_6:1.8.0.6
	OPENBSD_5_6_BASE:1.8
	OPENBSD_5_5:1.8.0.4
	OPENBSD_5_5_BASE:1.8
	OPENBSD_5_4:1.8.0.2
	OPENBSD_5_4_BASE:1.8
	OPENBSD_5_3:1.7.0.2
	OPENBSD_5_3_BASE:1.7
	OPENBSD_5_2:1.6.0.2
	OPENBSD_5_2_BASE:1.6
	OPENBSD_5_1_BASE:1.4
	OPENBSD_5_1:1.4.0.2
	OPENBSD_5_0:1.3.0.2
	OPENBSD_5_0_BASE:1.3;
locks; strict;
comment	@ * @;


1.17
date	2017.03.07.19.07.56;	author bru;	state Exp;
branches;
next	1.16;
commitid	JUiikL0wbnNSyYjZ;

1.16
date	2016.09.12.22.12.44;	author matthieu;	state Exp;
branches;
next	1.15;
commitid	50W0WJrvHFFwWCnc;

1.15
date	2016.04.22.23.06.53;	author bru;	state Exp;
branches;
next	1.14;
commitid	qy9Y2R4QgI3HxJeO;

1.14
date	2016.03.30.23.33.34;	author bru;	state Exp;
branches;
next	1.13;
commitid	0V5n6Lx6l8VS4h4T;

1.13
date	2015.08.29.08.48.28;	author shadchin;	state Exp;
branches;
next	1.12;
commitid	4W0lev75KAkLAmy0;

1.12
date	2015.03.06.22.49.34;	author mpi;	state Exp;
branches;
next	1.11;
commitid	GozeU5S1GauhITao;

1.11
date	2015.02.09.03.31.31;	author mpi;	state Exp;
branches;
next	1.10;
commitid	wvoFhJC1pviWOdQQ;

1.10
date	2015.01.24.17.43.59;	author shadchin;	state Exp;
branches;
next	1.9;
commitid	K2hMOP8BdtHA1Vvi;

1.9
date	2015.01.15.01.30.40;	author jsg;	state Exp;
branches;
next	1.8;
commitid	aFpMEyoHxbOYZCzp;

1.8
date	2013.06.02.18.17.24;	author shadchin;	state Exp;
branches;
next	1.7;

1.7
date	2012.10.29.11.55.50;	author stsp;	state Exp;
branches;
next	1.6;

1.6
date	2012.07.22.18.33.01;	author shadchin;	state Exp;
branches;
next	1.5;

1.5
date	2012.06.12.18.59.42;	author shadchin;	state Exp;
branches;
next	1.4;

1.4
date	2011.09.23.16.53.49;	author shadchin;	state Exp;
branches;
next	1.3;

1.3
date	2011.07.17.13.53.00;	author shadchin;	state Exp;
branches;
next	1.2;

1.2
date	2011.05.07.17.30.31;	author shadchin;	state Exp;
branches;
next	1.1;

1.1
date	2011.04.10.12.04.30;	author shadchin;	state Exp;
branches;
next	;


desc
@@


1.17
log
@Don't use stale coordinates in the hysteresis filter.

OK mpi@@
@
text
@/*
 * Copyright Â© 2011 Alexandr Shadchin
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#ifdef HAVE_CONFIG_H
#include "config.h"
#endif

#include <xorg-server.h>
#include <unistd.h>
#include <sys/ioctl.h>
#include <sys/time.h>
#include <errno.h>
#include <string.h>
#include "synproto.h"
#include "synapticsstr.h"
#include <xf86.h>

#include <fcntl.h>
#include <dev/wscons/wsconsio.h>

#ifdef X_PRIVSEP
extern int priv_open_device(const char *);
#endif

#define DEFAULT_WSMOUSE_DEV		"/dev/wsmouse0"

#define NWSEVENTS	16

struct wsconscomm_proto_data {
    struct wscons_event	events[NWSEVENTS];
    size_t		events_count;
    size_t		events_pos;
};

static Bool
WSConsIsTouchpad(InputInfoPtr pInfo, const char *device)
{
    int wsmouse_type, fd = -1;
    Bool rc = FALSE;

    if (device) {
#ifndef X_PRIVSEP
        fd = open(device, O_RDWR);
#else
        fd = priv_open_device(device);
#endif
    } else
        fd = pInfo->fd;

    if (fd < 0)
        return FALSE;

    if (ioctl(fd, WSMOUSEIO_GTYPE, &wsmouse_type) == -1) {
        xf86IDrvMsg(pInfo, X_ERROR, "cannot get mouse type\n");
        goto out;
    }

    if (wsmouse_type == WSMOUSE_TYPE_SYNAPTICS ||
        wsmouse_type == WSMOUSE_TYPE_SYNAP_SBTN ||
        wsmouse_type == WSMOUSE_TYPE_ALPS ||
        wsmouse_type == WSMOUSE_TYPE_ELANTECH)
        rc = TRUE;

out:
    if (device)
        close(fd);

    return rc;
}

static size_t
WSConsReadEvents(InputInfoPtr pInfo)
{
    SynapticsPrivate *priv = (SynapticsPrivate *)pInfo->private;
    struct wsconscomm_proto_data *proto_data = priv->proto_data;
    ssize_t len;

    proto_data->events_count = proto_data->events_pos = 0;
    len = read(pInfo->fd, proto_data->events, sizeof(proto_data->events));
    if (len <= 0) {
        if (errno != EAGAIN)
            xf86IDrvMsg(pInfo, X_ERROR, "read error %s\n", strerror(errno));
    } else if (len % sizeof(struct wscons_event)) {
        xf86IDrvMsg(pInfo, X_ERROR, "read error, invalid number of bytes\n");
    } else {
        proto_data->events_count = len / sizeof(struct wscons_event);
    }

    return proto_data->events_count;
}

static struct wscons_event *
WSConsGetEvent(InputInfoPtr pInfo)
{
    SynapticsPrivate *priv = (SynapticsPrivate *)pInfo->private;
    struct wsconscomm_proto_data *proto_data = priv->proto_data;
    struct wscons_event *event;

    if (proto_data->events_count == 0 && WSConsReadEvents(pInfo) == 0)
        return NULL;

    event = &proto_data->events[proto_data->events_pos];
    proto_data->events_pos++;
    proto_data->events_count--;

    return event;
}

static Bool
WSConsDeviceOnHook(InputInfoPtr pInfo, SynapticsParameters *para)
{
    int wsmouse_mode = WSMOUSE_NATIVE;

    if (ioctl(pInfo->fd, WSMOUSEIO_SETMODE, &wsmouse_mode) == -1) {
        xf86IDrvMsg(pInfo, X_ERROR, "cannot set native mode\n");
        return FALSE;
    }

    return TRUE;
}

static Bool
WSConsDeviceOffHook(InputInfoPtr pInfo)
{
    int wsmouse_mode = WSMOUSE_COMPAT;

    if (ioctl(pInfo->fd, WSMOUSEIO_SETMODE, &wsmouse_mode) == -1) {
        xf86IDrvMsg(pInfo, X_ERROR, "cannot set compat mode\n");
        return FALSE;
    }

    return TRUE;
}

static Bool
WSConsQueryHardware(InputInfoPtr pInfo)
{
    return WSConsIsTouchpad(pInfo, NULL);
}

static void
WSConsAdjustScrollCoords(SynapticsPrivate *priv, struct SynapticsHwState *hw)
{
    int dx, dy, i;

    dx = hw->x - priv->scroll.last_x;
    dy = hw->y - priv->scroll.last_y;
    priv->scroll.last_x = hw->x;
    priv->scroll.last_y = hw->y;
    for (i = 0; i < SYNAPTICS_MOVE_HISTORY; i++) {
        priv->move_hist[i].x += dx;
        priv->move_hist[i].y += dy;
    }
}

static Bool
WSConsReadHwState(InputInfoPtr pInfo,
    struct CommData *comm, struct SynapticsHwState *hwRet)
{
    SynapticsPrivate *priv = (SynapticsPrivate *)pInfo->private;
    struct wsconscomm_proto_data *proto_data = priv->proto_data;
    struct SynapticsHwState *hw = comm->hwState;
    struct wscons_event *event;
    Bool v, reset = FALSE;

    while ((event = WSConsGetEvent(pInfo)) != NULL) {
        switch (event->type) {
        case WSCONS_EVENT_MOUSE_UP:
        case WSCONS_EVENT_MOUSE_DOWN:
            v = (event->type == WSCONS_EVENT_MOUSE_DOWN) ? TRUE : FALSE;
            switch (event->value) {
            case 0:
                hw->left = v;
                break;
            case 1:
                hw->middle = v;
                break;
            case 2:
                hw->right = v;
                break;
            case 3:
                hw->up = v;
                break;
            case 4:
                hw->down = v;
                break;
            case 5:
                hw->multi[0] = v;
                break;
            case 6:
                hw->multi[1] = v;
                break;
            case 7:
                hw->multi[2] = v;
                break;
            case 8:
                hw->multi[3] = v;
                break;
            case 9:
                hw->multi[4] = v;
                break;
            case 10:
                hw->multi[5] = v;
                break;
            case 11:
                hw->multi[6] = v;
                break;
            case 12:
                hw->multi[7] = v;
                break;
            }
            break;
        case WSCONS_EVENT_MOUSE_ABSOLUTE_X:
            hw->x = event->value;
            hw->cumulative_dx = hw->x;
            break;
        case WSCONS_EVENT_MOUSE_ABSOLUTE_Y:
            hw->y = priv->maxy - event->value + priv->miny;
            hw->cumulative_dy = hw->y;
            break;
        case WSCONS_EVENT_TOUCH_PRESSURE:
            hw->z = event->value;
            break;
        case WSCONS_EVENT_TOUCH_CONTACTS:
            hw->numFingers = event->value;
            if (hw->numFingers == 0)
                hw->fingerWidth = 0;
            else if (hw->fingerWidth == 0)
                hw->fingerWidth = 5;
            break;
        case WSCONS_EVENT_TOUCH_WIDTH:
            hw->fingerWidth = event->value;
            break;
        case WSCONS_EVENT_TOUCH_RESET:
            /* The contact count or the active MT slot has changed. */
            reset = TRUE;
            break;
        case WSCONS_EVENT_SYNC:
            if (reset) {
                /* Ensure that pointer motion stops. */
                priv->count_packet_finger = 0;
                /* Don't use stale coordinates for filtering. */
                priv->hyst_center_x = hw->x;
                priv->hyst_center_y = hw->y;
                if (priv->vert_scroll_twofinger_on
                    || priv->horiz_scroll_twofinger_on) {
                    WSConsAdjustScrollCoords(priv, hw);
                }
            }
            hw->millis = 1000 * event->time.tv_sec +
                event->time.tv_nsec / 1000000;
            SynapticsCopyHwState(hwRet, hw);
            return TRUE;
        default:
            return FALSE;
        }
    }

    return FALSE;
}

static Bool
WSConsAutoDevProbe(InputInfoPtr pInfo, const char *device)
{
    int i;

    if (device && WSConsIsTouchpad(pInfo, device))
        return TRUE;

    if (WSConsIsTouchpad(pInfo, DEFAULT_WSMOUSE_DEV)) {
        xf86IDrvMsg(pInfo, X_PROBED, "auto-dev sets device to %s\n",
            DEFAULT_WSMOUSE_DEV);
        xf86ReplaceStrOption(pInfo->options, "Device", DEFAULT_WSMOUSE_DEV);
        return TRUE;
    }

    return FALSE;
}

static void
WSConsReadDevDimensions(InputInfoPtr pInfo)
{
    SynapticsPrivate *priv = (SynapticsPrivate *)pInfo->private;
    SynapticsParameters *para = &priv->synpara;
    struct wsmouse_calibcoords wsmc;
    int wsmouse_type;

    priv->proto_data = calloc(1, sizeof(struct wsconscomm_proto_data));
    if (priv->proto_data == NULL) {
        xf86IDrvMsg(pInfo, X_ERROR, "failed to allocate protocol data (%s)\n",
            strerror(errno));
        return;
    }

    if (ioctl(pInfo->fd, WSMOUSEIO_GCALIBCOORDS, &wsmc) != 0) {
        free(priv->proto_data);
        priv->proto_data = NULL;
        xf86IDrvMsg(pInfo, X_ERROR, "failed to query axis range (%s)\n",
            strerror(errno));
        return;
    }

    priv->minx = wsmc.minx;
    priv->maxx = wsmc.maxx;
    priv->resx = wsmc.resx;
    xf86IDrvMsg(pInfo, X_PROBED, "x-axis range %d - %d resolution %d\n",
        priv->minx, priv->maxx, priv->resx);

    priv->miny = wsmc.miny;
    priv->maxy = wsmc.maxy;
    priv->resy = wsmc.resy;
    xf86IDrvMsg(pInfo, X_PROBED, "y-axis range %d - %d resolution %d\n",
        priv->miny, priv->maxy, priv->resy);

    priv->minp = 0;
    priv->maxp = 255;

    priv->minw = 0;
    priv->maxw = 15;

    priv->has_pressure = TRUE;
    priv->has_left = TRUE;
    priv->has_right = TRUE;
    priv->has_middle = TRUE;

    if (ioctl(pInfo->fd, WSMOUSEIO_GTYPE, &wsmouse_type) == -1)
        xf86IDrvMsg(pInfo, X_ERROR, "cannot get mouse type\n");

    switch (wsmouse_type) {
    default:
    case WSMOUSE_TYPE_SYNAP_SBTN:
        para->clickpad = TRUE;
        para->has_secondary_buttons = TRUE;
        /* FALLTHROUGH */
    case WSMOUSE_TYPE_SYNAPTICS:
        priv->model = MODEL_SYNAPTICS;
        priv->has_width = TRUE;
        priv->has_double = TRUE;
        priv->has_triple = TRUE;
        break;
    case WSMOUSE_TYPE_ALPS:
        priv->model = MODEL_ALPS;
        priv->has_width = FALSE;
        priv->has_double = FALSE;
        priv->has_triple = FALSE;
        break;
    case WSMOUSE_TYPE_ELANTECH:
        priv->model = MODEL_ELANTECH;
        priv->has_width = TRUE;
        priv->has_double = TRUE;
        priv->has_triple = TRUE;
        break;
    }
}

struct SynapticsProtocolOperations wscons_proto_operations = {
    WSConsDeviceOnHook,
    WSConsDeviceOffHook,
    WSConsQueryHardware,
    WSConsReadHwState,
    WSConsAutoDevProbe,
    WSConsReadDevDimensions
};
@


1.16
log
@include <sys/time.h> before wsconsio.h
@
text
@d255 3
@


1.15
log
@Don't stop scrolling when handling TOUCH_RESET events.

To avoid jumps, the original version of the handler clears
the scroll flags. The method works well if a scroll gesture
continues, but it can preclude "coasting". The new version
adjusts the coordinates that determine the speed and direction
of scrolling.

ok shadchin@@, mpi@@
@
text
@d24 1
@


1.14
log
@Handle the TOUCH events from wsmouse.

With the changes for multitouch input, new event types have been
introduced in wsmouse. There are separate types for contact count
and width values, and RESET events for controlling/stopping
pointer motion.

ok mpi@@, shadchin@@
@
text
@d153 15
d176 1
a176 1
    Bool v;
d247 2
a248 7
            /*
             * The contact count or the active MT-slot has changed.
             * Suppress pointer motion and two-finger scrolling.
             */
            priv->count_packet_finger = 0;
            priv->vert_scroll_twofinger_on = FALSE;
            priv->horiz_scroll_twofinger_on = FALSE;
d251 8
@


1.13
log
@Read multiple events at once.

Before:
Both drivers currently do one read(2) per event, but since we use a
"sync" event we have a least two of them for ws(4) but more commonly
3 for ws(4) and 4 for synaptics(4).

most of the code and ok mpi@@
@
text
@d218 1
a218 1
        case WSCONS_EVENT_MOUSE_ABSOLUTE_Z:
d221 5
a225 3
        case WSCONS_EVENT_MOUSE_ABSOLUTE_W:
            if (priv->model == MODEL_ELANTECH) {
                /* Elantech touchpads report number of fingers directly. */
d227 12
a238 18
                hw->numFingers = event->value;
                break;
            }
            /* XXX magic number mapping which is mirrored in pms driver */
            switch (event->value) {
            case 0:
                hw->fingerWidth = 5;
                hw->numFingers = 2;
                break;
            case 1:
                hw->fingerWidth = 5;
                hw->numFingers = 3;
                break;
            case 4 ... 5:
                hw->fingerWidth = event->value;
                hw->numFingers = 1;
                break;
            }
a240 12
            if (hw->z == 0) {
                hw->fingerWidth = 0;
                hw->numFingers = 0;
            } else if (hw->numFingers == 0) {
                /*
                 * Because W may be 0 already, a two-finger touch on a
                 * Synaptics touchpad doesn't necessarily produce an update
                 * event for W.
                 */
                hw->fingerWidth = 5;
                hw->numFingers = 2;
            }
@


1.12
log
@Make sure the end of a motion is correctly detected even if the hardware
does not always report a 0 'w' value for two-finger contacts.

Diff from Ulf Brosziewski.

Fix a regression with Synaptics touchpads reported by Patrick keshishian
and Henrik Friedrichsen on misc@@.

ok matthieu@@, deraadt@@
@
text
@d39 8
d83 2
a84 2
static Bool
WSConsReadEvent(InputInfoPtr pInfo, struct wscons_event *event)
d86 2
a87 1
    Bool rc = TRUE;
d90 2
a91 1
    len = read(pInfo->fd, event, sizeof(struct wscons_event));
a94 1
        rc = FALSE;
d97 2
a98 1
        rc = FALSE;
d101 18
a118 1
    return rc;
d158 1
d160 1
a160 1
    struct wscons_event event;
d163 2
a164 2
    while (WSConsReadEvent(pInfo, &event)) {
        switch (event.type) {
d167 2
a168 2
            v = (event.type == WSCONS_EVENT_MOUSE_DOWN) ? TRUE : FALSE;
            switch (event.value) {
d211 1
a211 1
            hw->x = event.value;
d215 1
a215 1
            hw->y = priv->maxy - event.value + priv->miny;
d219 1
a219 1
            hw->z = event.value;
d225 1
a225 1
                hw->numFingers = event.value;
d229 1
a229 1
            switch (event.value) {
d239 1
a239 1
                hw->fingerWidth = event.value;
d257 2
a258 1
            hw->millis = 1000 * event.time.tv_sec + event.time.tv_nsec / 1000000;
d295 7
d303 2
@


1.11
log
@Keep cumulative coordinates values in sync with absolute ones.

This improve "two-finger scrolling" on synaptics and will allow to
have proper "click-and-drag" support on elantech.

Note that this change is needed because wsmouse(4)/wscons(4) do not
support multitouch events for the moment and every protocol supported
by pms(4) do its own translation to fake such events.

From Ulf Brosziewski, ok shadchin@@
@
text
@d220 8
@


1.10
log
@Update to xf86-input-synaptics 1.8.1.

ok matthieu@@
@
text
@a134 6
    /* Reset cumulative values if buttons were not previously pressed */
    if (!hw->left && !hw->right && !hw->middle) {
        hw->cumulative_dx = hw->x;
        hw->cumulative_dy = hw->y;
    }

d184 1
d188 1
d217 4
@


1.9
log
@Recognise the synaptics with sw buttons mouse type and set the
clickpad and has_secondary_buttons properties.

Initial diff from myself with additional changes from matthieu@@
@
text
@d295 1
a295 1
    /* FALLTHROUGH */
@


1.8
log
@Update to xf86-input-synaptics 1.7.1.

ok mpi@@ jcs@@ matthieu@@
@
text
@d63 1
d254 1
d292 4
@


1.7
log
@Teach wsconscomm in synaptics(4) about elantech touchpads. ok mpi@@ shadchin@@
@
text
@a26 1
#include "synaptics.h"
d197 7
a203 7
	    if (priv->model == MODEL_ELANTECH) {
		/* Elantech touchpads report number of fingers directly. */
		hw->fingerWidth = 5;
		hw->numFingers = event.value;
	    	break;
	    }
	    /* XXX magic number mapping which is mirrored in pms driver */
@


1.6
log
@Fix for ClickPad (xenocara part). On issue pointed gilles@@ and matthieu@@

ok gilles@@, matthieu@@, mpi@@, miod@@, deraadt@@
@
text
@d64 2
a65 1
        wsmouse_type == WSMOUSE_TYPE_ALPS)
d198 7
d302 6
@


1.5
log
@Update to xf86-input-synaptics 1.6.1

ok matthieu@@
@
text
@d134 5
a138 2
    if (WSConsReadEvent(pInfo, &event) == FALSE)
        return FALSE;
d140 78
a217 44
    switch (event.type) {
    case WSCONS_EVENT_MOUSE_UP:
    case WSCONS_EVENT_MOUSE_DOWN:
        v = (event.type == WSCONS_EVENT_MOUSE_DOWN) ? TRUE : FALSE;
        switch (event.value) {
        case 0:
            hw->left = v;
            break;
        case 1:
            hw->middle = v;
            break;
        case 2:
            hw->right = v;
            break;
        case 3:
            hw->up = v;
            break;
        case 4:
            hw->down = v;
            break;
        case 5:
            hw->multi[0] = v;
            break;
        case 6:
            hw->multi[1] = v;
            break;
        case 7:
            hw->multi[2] = v;
            break;
        case 8:
            hw->multi[3] = v;
            break;
        case 9:
            hw->multi[4] = v;
            break;
        case 10:
            hw->multi[5] = v;
            break;
        case 11:
            hw->multi[6] = v;
            break;
        case 12:
            hw->multi[7] = v;
            break;
a218 28
        break;
    case WSCONS_EVENT_MOUSE_ABSOLUTE_X:
        hw->x = event.value;
        break;
    case WSCONS_EVENT_MOUSE_ABSOLUTE_Y:
        hw->y = priv->maxy - event.value + priv->miny;
        break;
    case WSCONS_EVENT_MOUSE_ABSOLUTE_Z:
        hw->z = event.value;
        break;
    case WSCONS_EVENT_MOUSE_ABSOLUTE_W:
        switch (event.value) {
        case 0:
            hw->fingerWidth = 5;
            hw->numFingers = 2;
            break;
        case 1:
            hw->fingerWidth = 5;
            hw->numFingers = 3;
            break;
        case 4 ... 5:
            hw->fingerWidth = event.value;
            hw->numFingers = 1;
            break;
        }
        break;
    default:
        return FALSE;
d221 1
a221 4
    hw->millis = GetTimeInMillis();

    SynapticsCopyHwState(hwRet, hw);
    return TRUE;
@


1.4
log
@Update to xf86-input-synaptics 1.5.0.
ok mpi@@, matthieu@@
@
text
@d93 1
a93 1
static void
d98 1
a98 1
    if (ioctl(pInfo->fd, WSMOUSEIO_SETMODE, &wsmouse_mode) == -1)
d100 4
d106 1
a106 1
static void
d111 1
a111 1
    if (ioctl(pInfo->fd, WSMOUSEIO_SETMODE, &wsmouse_mode) == -1)
d113 4
d130 1
a130 1
    struct SynapticsHwState *hw = &(comm->hwState);
d212 3
a214 1
    *hwRet = *hw;
@


1.3
log
@fix bug "lock up" touchpad ( not allowing to move the pointer, or click )

ok matthieu@@
@
text
@d31 1
d38 1
a38 7
#define DEFAULT_WSMOUSE0_DEV		"/dev/wsmouse0"
#define NEVENTS				64

static const char *synaptics_devs[] = {
    DEFAULT_WSMOUSE0_DEV,
    NULL
};
d41 1
a41 1
WSConsIsSynaptics(InputInfoPtr pInfo, const char *device)
d44 1
a44 1
    Bool res = FALSE;
d46 1
d48 1
a48 1
    fd = open(synaptics_devs[i], O_RDONLY);
d50 1
a50 1
    fd = priv_open_device(device);
d52 2
d59 1
a59 1
        xf86Msg(X_ERROR, "%s: cannot get mouse type\n", pInfo->name);
d63 3
a65 2
    if (wsmouse_type == WSMOUSE_TYPE_SYNAPTICS)
        res = TRUE;
d68 23
a90 2
    close(fd);
    return res;
d99 1
a99 1
        xf86Msg(X_ERROR, "%s: cannot set absolute mode\n", pInfo->name);
d108 1
a108 1
        xf86Msg(X_ERROR, "%s: cannot set relative mode\n", pInfo->name);
d114 1
a114 19
    SynapticsPrivate *priv = (SynapticsPrivate *)pInfo->private;
    struct CommData *comm = &priv->comm;
    int wsmouse_type;

    if (ioctl(pInfo->fd, WSMOUSEIO_GTYPE, &wsmouse_type) == -1) {
        xf86Msg(X_ERROR, "%s: cannot get mouse type\n", pInfo->name);
        return FALSE;
    }

    if (wsmouse_type != WSMOUSE_TYPE_SYNAPTICS)
        return FALSE;

    if (comm->buffer)
        XisbFree(comm->buffer);
    comm->buffer = XisbNew(pInfo->fd, sizeof(struct wscons_event) * NEVENTS);
    if (comm->buffer == NULL)
        return FALSE;

    return TRUE;
a123 2
    unsigned char *pBuf = (unsigned char *)&event;
    int c, n = 0;
d126 1
a126 5
    XisbBlockDuration(comm->buffer, -1);
    while (n < sizeof(struct wscons_event) && (c = XisbRead(comm->buffer)) >= 0)
        pBuf[n++] = (unsigned char)c;

    if (n != sizeof(struct wscons_event))
d213 1
a213 1
    if (device && WSConsIsSynaptics(pInfo, device))
d216 6
a221 7
    for (i = 0; synaptics_devs[i]; i++)
        if (WSConsIsSynaptics(pInfo, synaptics_devs[i])) {
            xf86Msg(X_PROBED, "%s auto-dev sets device to %s\n",
                pInfo->name, synaptics_devs[i]);
            xf86ReplaceStrOption(pInfo->options, "Device", synaptics_devs[i]);
            return TRUE;
        }
d231 1
d234 2
a235 2
        xf86Msg(X_ERROR, "%s: failed to query axis range (%s)\n",
            pInfo->name, strerror(errno));
d242 2
a243 2
    xf86Msg(X_PROBED, "%s: x-axis range %d - %d resolution %d\n",
        pInfo->name, priv->minx, priv->maxx, priv->resx);
d248 8
a255 2
    xf86Msg(X_PROBED, "%s: y-axis range %d - %d resolution %d\n",
        pInfo->name, priv->miny, priv->maxy, priv->resy);
a257 1
    priv->has_width = TRUE;
a260 3
    priv->has_double = TRUE;
    priv->has_triple = TRUE;
    priv->has_scrollbuttons = TRUE;
d262 18
a279 1
    priv->model = MODEL_SYNAPTICS;
@


1.2
log
@Add support new ioctl WSMOUSEIO_SETMODE.

ok matthieu@@
@
text
@d38 1
d94 2
d103 8
a110 2
    if (wsmouse_type == WSMOUSE_TYPE_SYNAPTICS)
        return TRUE;
d112 1
a112 1
    return FALSE;
@


1.1
log
@Add support wscons (upstream + implementation)

ok matthieu@@
@
text
@d72 18
d259 2
a260 2
    NULL,
    NULL,
@

