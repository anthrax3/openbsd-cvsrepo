head	1.13;
access;
symbols
	OPENBSD_6_2:1.13.0.4
	OPENBSD_6_2_BASE:1.13
	OPENBSD_6_1:1.13.0.2
	OPENBSD_6_1_BASE:1.13
	OPENBSD_6_0:1.12.0.4
	OPENBSD_6_0_BASE:1.12
	OPENBSD_5_9:1.12.0.2
	OPENBSD_5_9_BASE:1.12
	OPENBSD_5_8:1.11.0.2
	OPENBSD_5_8_BASE:1.11
	OPENBSD_5_7:1.10.0.2
	OPENBSD_5_7_BASE:1.10
	OPENBSD_5_6:1.9.0.2
	OPENBSD_5_6_BASE:1.9
	OPENBSD_5_5:1.7.0.4
	OPENBSD_5_5_BASE:1.7
	OPENBSD_5_4:1.7.0.2
	OPENBSD_5_4_BASE:1.7
	OPENBSD_5_3:1.6.0.4
	OPENBSD_5_3_BASE:1.6
	OPENBSD_5_2:1.6.0.2
	OPENBSD_5_2_BASE:1.6
	OPENBSD_5_1_BASE:1.3
	OPENBSD_5_1:1.3.0.2
	OPENBSD_5_0:1.2.0.2
	OPENBSD_5_0_BASE:1.2
	shadchin_2011/home/xenocara/driver/xf86-input-synaptics04:1.1.1.1
	shadchin:1.1.1;
locks; strict;
comment	@ * @;


1.13
date	2017.01.22.09.54.53;	author matthieu;	state Exp;
branches;
next	1.12;
commitid	CjjEXS1IfivpYe4R;

1.12
date	2015.12.17.06.04.21;	author shadchin;	state Exp;
branches;
next	1.11;
commitid	LCFuHNeMgbArQZM3;

1.11
date	2015.04.11.16.08.42;	author shadchin;	state Exp;
branches;
next	1.10;
commitid	FrUqGb4Ug8crCVhk;

1.10
date	2015.01.24.17.43.59;	author shadchin;	state Exp;
branches;
next	1.9;
commitid	K2hMOP8BdtHA1Vvi;

1.9
date	2014.05.17.17.18.21;	author shadchin;	state Exp;
branches;
next	1.8;

1.8
date	2014.05.09.20.05.46;	author shadchin;	state Exp;
branches;
next	1.7;

1.7
date	2013.06.02.18.17.24;	author shadchin;	state Exp;
branches;
next	1.6;

1.6
date	2012.06.30.13.31.04;	author shadchin;	state Exp;
branches;
next	1.5;

1.5
date	2012.06.12.18.59.42;	author shadchin;	state Exp;
branches;
next	1.4;

1.4
date	2012.04.01.12.18.45;	author shadchin;	state Exp;
branches;
next	1.3;

1.3
date	2011.09.23.16.53.49;	author shadchin;	state Exp;
branches;
next	1.2;

1.2
date	2011.04.10.12.04.30;	author shadchin;	state Exp;
branches;
next	1.1;

1.1
date	2011.04.09.08.38.41;	author shadchin;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2011.04.09.08.38.41;	author shadchin;	state Exp;
branches;
next	;


desc
@@


1.13
log
@Update to xf86-input-synaptics 1.9.0
@
text
@/*
 * Copyright © 1999 Henry Davies
 * Copyright © 2001 Stefan Gmeiner
 * Copyright © 2002 S. Lehner
 * Copyright © 2002 Peter Osterlund
 * Copyright © 2002 Linuxcare Inc. David Kennedy
 * Copyright © 2003 Hartwig Felger
 * Copyright © 2003 Jörg Bösner
 * Copyright © 2003 Fred Hucht
 * Copyright © 2004 Alexei Gilchrist
 * Copyright © 2004 Matthias Ihmig
 * Copyright © 2006 Stefan Bethge
 * Copyright © 2006 Christian Thaeter
 * Copyright © 2007 Joseph P. Skudlarek
 * Copyright © 2008 Fedor P. Goncharov
 * Copyright © 2008-2012 Red Hat, Inc.
 * Copyright © 2011 The Chromium OS Authors
 *
 * Permission to use, copy, modify, distribute, and sell this software
 * and its documentation for any purpose is hereby granted without
 * fee, provided that the above copyright notice appear in all copies
 * and that both that copyright notice and this permission notice
 * appear in supporting documentation, and that the name of Red Hat
 * not be used in advertising or publicity pertaining to distribution
 * of the software without specific, written prior permission.  Red
 * Hat makes no representations about the suitability of this software
 * for any purpose.  It is provided "as is" without express or implied
 * warranty.
 *
 * THE AUTHORS DISCLAIM ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
 * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN
 * NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY SPECIAL, INDIRECT OR
 * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS
 * OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT,
 * NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
 * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 *
 * Authors:
 *      Joseph P. Skudlarek <Jskud@@Jskud.com>
 *      Christian Thaeter <chth@@gmx.net>
 *      Stefan Bethge <stefan.bethge@@web.de>
 *      Matthias Ihmig <m.ihmig@@gmx.net>
 *      Alexei Gilchrist <alexei@@physics.uq.edu.au>
 *      Jörg Bösner <ich@@joerg-boesner.de>
 *      Hartwig Felger <hgfelger@@hgfelger.de>
 *      Peter Osterlund <petero2@@telia.com>
 *      S. Lehner <sam_x@@bluemail.ch>
 *      Stefan Gmeiner <riddlebox@@freesurf.ch>
 *      Henry Davies <hdavies@@ameritech.net> for the
 *      Linuxcare Inc. David Kennedy <dkennedy@@linuxcare.com>
 *      Fred Hucht <fred@@thp.Uni-Duisburg.de>
 *      Fedor P. Goncharov <fedgo@@gorodok.net>
 *      Simon Thum <simon.thum@@gmx.de>
 *
 * Trademarks are the property of their respective owners.
 */

#ifdef HAVE_CONFIG_H
#include "config.h"
#endif

#include <xorg-server.h>
#include <unistd.h>
#include <misc.h>
#include <xf86.h>
#include <math.h>
#include <stdio.h>
#include <xf86_OSproc.h>
#include <xf86Xinput.h>
#include <exevents.h>

#include <X11/Xatom.h>
#include <X11/extensions/XI2.h>
#include <xserver-properties.h>
#include <ptrveloc.h>

#include "synapticsstr.h"
#include "synaptics-properties.h"

enum EdgeType {
    NO_EDGE = 0,
    BOTTOM_EDGE = 1,
    TOP_EDGE = 2,
    LEFT_EDGE = 4,
    RIGHT_EDGE = 8,
    LEFT_BOTTOM_EDGE = BOTTOM_EDGE | LEFT_EDGE,
    RIGHT_BOTTOM_EDGE = BOTTOM_EDGE | RIGHT_EDGE,
    RIGHT_TOP_EDGE = TOP_EDGE | RIGHT_EDGE,
    LEFT_TOP_EDGE = TOP_EDGE | LEFT_EDGE
};

/*
 * We expect to be receiving a steady 80 packets/sec (which gives 40
 * reports/sec with more than one finger on the pad, as Advanced Gesture Mode
 * requires two PS/2 packets per report).  Instead of a random scattering of
 * magic 13 and 20ms numbers scattered throughout the driver, introduce
 * POLL_MS as 14ms, which is slightly less than 80Hz.  13ms is closer to
 * 80Hz, but if the kernel event reporting was even slightly delayed,
 * we would produce synthetic motion followed immediately by genuine
 * motion, so use 14.
 *
 * We use this to call back at a constant rate to at least produce the
 * illusion of smooth motion.  It works a lot better than you'd expect.
*/
#define POLL_MS 14

#define MAX(a, b) (((a)>(b))?(a):(b))
#define MIN(a, b) (((a)<(b))?(a):(b))
#define TIME_DIFF(a, b) ((int)((a)-(b)))

#define SQR(x) ((x) * (x))

#ifndef M_PI
#define M_PI 3.14159265358979323846
#endif

#define INPUT_BUFFER_SIZE 200

/*****************************************************************************
 * Forward declaration
 ****************************************************************************/
static int SynapticsPreInit(InputDriverPtr drv, InputInfoPtr pInfo, int flags);
static void SynapticsUnInit(InputDriverPtr drv, InputInfoPtr pInfo, int flags);
static Bool DeviceControl(DeviceIntPtr, int);
static void ReadInput(InputInfoPtr);
static int HandleState(InputInfoPtr, struct SynapticsHwState *, CARD32 now,
                       Bool from_timer);
static int ControlProc(InputInfoPtr, xDeviceCtl *);
static int SwitchMode(ClientPtr, DeviceIntPtr, int);
static int DeviceInit(DeviceIntPtr);
static int DeviceOn(DeviceIntPtr);
static int DeviceOff(DeviceIntPtr);
static int DeviceClose(DeviceIntPtr);
static Bool QueryHardware(InputInfoPtr);
static void ReadDevDimensions(InputInfoPtr);
#ifndef NO_DRIVER_SCALING
static void ScaleCoordinates(SynapticsPrivate * priv,
                             struct SynapticsHwState *hw);
static void CalculateScalingCoeffs(SynapticsPrivate * priv);
#endif
static void SanitizeDimensions(InputInfoPtr pInfo);

void InitDeviceProperties(InputInfoPtr pInfo);
int SetProperty(DeviceIntPtr dev, Atom property, XIPropertyValuePtr prop,
                BOOL checkonly);

const static struct {
    const char *name;
    struct SynapticsProtocolOperations *proto_ops;
} protocols[] = {
#ifdef BUILD_EVENTCOMM
    { "event", &event_proto_operations },
#endif
#ifdef BUILD_PSMCOMM
    { "psm", &psm_proto_operations },
#endif
#ifdef BUILD_PS2COMM
    { "psaux", &psaux_proto_operations },
    { "alps", &alps_proto_operations },
#endif
#ifdef BUILD_WSCONSCOMM
    { "wscons", &wscons_proto_operations },
#endif
    { NULL, NULL }
};

InputDriverRec SYNAPTICS = {
    1,
    "synaptics",
    NULL,
    SynapticsPreInit,
    SynapticsUnInit,
    NULL,
    NULL,
#ifdef XI86_DRV_CAP_SERVER_FD
    XI86_DRV_CAP_SERVER_FD
#endif
};

static XF86ModuleVersionInfo VersionRec = {
    "synaptics",
    MODULEVENDORSTRING,
    MODINFOSTRING1,
    MODINFOSTRING2,
    XORG_VERSION_CURRENT,
    PACKAGE_VERSION_MAJOR, PACKAGE_VERSION_MINOR, PACKAGE_VERSION_PATCHLEVEL,
    ABI_CLASS_XINPUT,
    ABI_XINPUT_VERSION,
    MOD_CLASS_XINPUT,
    {0, 0, 0, 0}
};

static pointer
SetupProc(pointer module, pointer options, int *errmaj, int *errmin)
{
    xf86AddInputDriver(&SYNAPTICS, module, 0);
    return module;
}

_X_EXPORT XF86ModuleData synapticsModuleData = {
    &VersionRec,
    &SetupProc,
    NULL
};

/*****************************************************************************
 *	Function Definitions
 ****************************************************************************/
static inline void
SynapticsCloseFd(InputInfoPtr pInfo)
{
    if (pInfo->fd > -1 && !(pInfo->flags & XI86_SERVER_FD)) {
        xf86CloseSerial(pInfo->fd);
        pInfo->fd = -1;
    }
}

/**
 * Fill in default dimensions for backends that cannot query the hardware.
 * Eventually, we want the edges to be 1900/5400 for x, 1900/4000 for y.
 * These values are based so that calculate_edge_widths() will give us the
 * right values.
 *
 * The default values 1900, etc. come from the dawn of time, when men where
 * men, or possibly apes.
 */
static void
SanitizeDimensions(InputInfoPtr pInfo)
{
    SynapticsPrivate *priv = (SynapticsPrivate *) pInfo->private;

    if (priv->minx >= priv->maxx) {
        priv->minx = 1615;
        priv->maxx = 5685;
        priv->resx = 0;

        xf86IDrvMsg(pInfo, X_PROBED,
                    "invalid x-axis range.  defaulting to %d - %d\n",
                    priv->minx, priv->maxx);
    }

    if (priv->miny >= priv->maxy) {
        priv->miny = 1729;
        priv->maxy = 4171;
        priv->resy = 0;

        xf86IDrvMsg(pInfo, X_PROBED,
                    "invalid y-axis range.  defaulting to %d - %d\n",
                    priv->miny, priv->maxy);
    }

    if (priv->minp >= priv->maxp) {
        priv->minp = 0;
        priv->maxp = 255;

        xf86IDrvMsg(pInfo, X_PROBED,
                    "invalid pressure range.  defaulting to %d - %d\n",
                    priv->minp, priv->maxp);
    }

    if (priv->minw >= priv->maxw) {
        priv->minw = 0;
        priv->maxw = 15;

        xf86IDrvMsg(pInfo, X_PROBED,
                    "invalid finger width range.  defaulting to %d - %d\n",
                    priv->minw, priv->maxw);
    }
}

static Bool
SetDeviceAndProtocol(InputInfoPtr pInfo)
{
    SynapticsPrivate *priv = pInfo->private;
    char *proto, *device;
    int i;

    proto = xf86SetStrOption(pInfo->options, "Protocol", NULL);
    device = xf86SetStrOption(pInfo->options, "Device", NULL);

    /* If proto is auto-dev, unset and let the code do the rest */
    if (proto && !strcmp(proto, "auto-dev")) {
        free(proto);
        proto = NULL;
    }

    for (i = 0; protocols[i].name; i++) {
        if ((!device || !proto) &&
            protocols[i].proto_ops->AutoDevProbe &&
            protocols[i].proto_ops->AutoDevProbe(pInfo, device))
            break;
        else if (proto && !strcmp(proto, protocols[i].name))
            break;
    }
    free(proto);
    free(device);

    priv->proto_ops = protocols[i].proto_ops;

    return (priv->proto_ops != NULL);
}

static void
calculate_edge_widths(SynapticsPrivate * priv, int *l, int *r, int *t, int *b)
{
    int width, height;
    int ewidth, eheight;        /* edge width/height */

    width = abs(priv->maxx - priv->minx);
    height = abs(priv->maxy - priv->miny);

    if (priv->model == MODEL_SYNAPTICS) {
        ewidth = width * .07;
        eheight = height * .07;
    }
    else if (priv->model == MODEL_ALPS) {
        ewidth = width * .15;
        eheight = height * .15;
    }
    else if (priv->model == MODEL_APPLETOUCH ||
             priv->model == MODEL_UNIBODY_MACBOOK) {
        ewidth = width * .085;
        eheight = height * .085;
    }
    else {
        ewidth = width * .04;
        eheight = height * .054;
    }

    *l = priv->minx + ewidth;
    *r = priv->maxx - ewidth;
    *t = priv->miny + eheight;
    *b = priv->maxy - eheight;
}

static void
calculate_tap_hysteresis(SynapticsPrivate * priv, int range,
                         int *fingerLow, int *fingerHigh)
{
    switch (priv->model) {
    case MODEL_ELANTECH:
        /* All Elantech touchpads don't need the Z filtering to get the
         * number of fingers correctly. See Documentation/elantech.txt
         * in the kernel.
         */
        *fingerLow = priv->minp + 1;
        *fingerHigh = priv->minp + 1;
        break;
    case MODEL_UNIBODY_MACBOOK:
        *fingerLow = 70;
        *fingerHigh = 75;
        break;
    default:
        *fingerLow = priv->minp + range * (25.0 / 256);
        *fingerHigh = priv->minp + range * (30.0 / 256);
        break;
    }
}

/* Area options support both percent values and absolute values. This is
 * awkward. The xf86Set* calls will print to the log, but they'll
 * also print an error if we request a percent value but only have an
 * int. So - check first for percent, then call xf86Set* again to get
 * the log message.
 */
static int
set_percent_option(pointer options, const char *optname,
                   const int range, const int offset, const int default_value)
{
    int result;
    double percent = xf86CheckPercentOption(options, optname, -1);

    if (percent >= 0.0) {
        percent = xf86SetPercentOption(options, optname, -1);
        result = percent / 100.0 * range + offset;
    } else
        result = xf86SetIntOption(options, optname, default_value);

    return result;
}

Bool
SynapticsIsSoftButtonAreasValid(int *values)
{
    Bool right_disabled = FALSE;
    Bool middle_disabled = FALSE;

    enum {
        /* right button left, right, top, bottom */
        RBL = 0,
        RBR = 1,
        RBT = 2,
        RBB = 3,
        /* middle button left, right, top, bottom */
        MBL = 4,
        MBR = 5,
        MBT = 6,
        MBB = 7,
    };

    /* Check right button area */
    if ((((values[RBL] != 0) && (values[RBR] != 0)) && (values[RBL] > values[RBR])) ||
        (((values[RBT] != 0) && (values[RBB] != 0)) && (values[RBT] > values[RBB])))
        return FALSE;

    /* Check middle button area */
    if ((((values[MBL] != 0) && (values[MBR] != 0)) && (values[MBL] > values[MBR])) ||
        (((values[MBT] != 0) && (values[MBB] != 0)) && (values[MBT] > values[MBB])))
        return FALSE;

    if (values[RBL] == 0 && values[RBR] == 0 && values[RBT] == 0 && values[RBB] == 0)
        right_disabled = TRUE;

    if (values[MBL] == 0 && values[MBR] == 0 && values[MBT] == 0 && values[MBB] == 0)
        middle_disabled = TRUE;

    if (!right_disabled &&
        ((values[RBL] && values[RBL] == values[RBR]) ||
         (values[RBT] && values[RBT] == values[RBB])))
        return FALSE;

    if (!middle_disabled &&
        ((values[MBL] && values[MBL] == values[MBR]) ||
         (values[MBT] && values[MBT] == values[MBB])))
        return FALSE;

    /* Check for overlapping button areas */
    if (!right_disabled && !middle_disabled) {
        int right_left = values[RBL] ? values[RBL] : INT_MIN;
        int right_right = values[RBR] ? values[RBR] : INT_MAX;
        int right_top = values[RBT] ? values[RBT] : INT_MIN;
        int right_bottom = values[RBB] ? values[RBB] : INT_MAX;
        int middle_left = values[MBL] ? values[MBL] : INT_MIN;
        int middle_right = values[MBR] ? values[MBR] : INT_MAX;
        int middle_top = values[MBT] ? values[MBT] : INT_MIN;
        int middle_bottom = values[MBB] ? values[MBB] : INT_MAX;

        /* If areas overlap in the Y axis */
        if ((right_bottom <= middle_bottom && right_bottom >= middle_top) ||
            (right_top <= middle_bottom && right_top >= middle_top)) {
            /* Check for overlapping left edges */
            if ((right_left < middle_left && right_right > middle_left) ||
                (middle_left < right_left && middle_right > right_left))
                return FALSE;

            /* Check for overlapping right edges */
            if ((right_right > middle_right && right_left < middle_right) ||
                (middle_right > right_right && middle_left < right_right))
                return FALSE;
        }

        /* If areas overlap in the X axis */
        if ((right_left >= middle_left && right_left <= middle_right) ||
            (right_right >= middle_left && right_right <= middle_right)) {
            /* Check for overlapping top edges */
            if ((right_top < middle_top && right_bottom > middle_top) ||
                (middle_top < right_top && middle_bottom > right_top))
                return FALSE;

            /* Check for overlapping bottom edges */
            if ((right_bottom > middle_bottom && right_top < middle_bottom) ||
                (middle_bottom > right_bottom && middle_top < right_bottom))
                return FALSE;
        }
    }

    return TRUE;
}

static void
set_softbutton_areas_option(InputInfoPtr pInfo, char *option_name, int offset)
{
    SynapticsPrivate *priv = pInfo->private;
    SynapticsParameters *pars = &priv->synpara;
    int values[8];
    int in_percent = 0;         /* bitmask for which ones are in % */
    char *option_string;
    char *next_num;
    char *end_str;
    int i;
    int width, height;

    if (!pars->clickpad)
        return;

    option_string = xf86SetStrOption(pInfo->options, option_name, NULL);
    if (!option_string)
        return;

    next_num = option_string;

    for (i = 0; i < 8 && *next_num != '\0'; i++) {
        long int value = strtol(next_num, &end_str, 0);

        if (value > INT_MAX || value < -INT_MAX)
            goto fail;

        values[i] = value;

        if (next_num != end_str) {
            if (*end_str == '%') {
                in_percent |= 1 << i;
                end_str++;
            }
            next_num = end_str;
        }
        else
            goto fail;
    }

    if (i < 8 || *next_num != '\0')
        goto fail;

    width = priv->maxx - priv->minx;
    height = priv->maxy - priv->miny;

    for (i = 0; in_percent && i < 8; i++) {
        int base, size;

        if ((in_percent & (1 << i)) == 0 || values[i] == 0)
            continue;

        size = ((i % 4) < 2) ? width : height;
        base = ((i % 4) < 2) ? priv->minx : priv->miny;
        values[i] = base + size * values[i] / 100.0;
    }

    if (!SynapticsIsSoftButtonAreasValid(values))
        goto fail;

    memcpy(pars->softbutton_areas[offset], values, 4 * sizeof(int));
    memcpy(pars->softbutton_areas[offset + 1], values + 4, 4 * sizeof(int));

    free(option_string);

    return;

 fail:
    xf86IDrvMsg(pInfo, X_ERROR,
                "invalid %s value '%s', keeping defaults\n",
                option_name, option_string);
    free(option_string);
}

static void
set_primary_softbutton_areas_option(InputInfoPtr pInfo)
{
    set_softbutton_areas_option(pInfo, "SoftButtonAreas", BOTTOM_BUTTON_AREA);
}

static void
set_secondary_softbutton_areas_option(InputInfoPtr pInfo)
{
    set_softbutton_areas_option(pInfo, "SecondarySoftButtonAreas", TOP_BUTTON_AREA);
}

static void
set_default_parameters(InputInfoPtr pInfo)
{
    SynapticsPrivate *priv = pInfo->private;    /* read-only */
    pointer opts = pInfo->options;      /* read-only */
    SynapticsParameters *pars = &priv->synpara; /* modified */

    int horizScrollDelta, vertScrollDelta;      /* pixels */
    int tapMove;                /* pixels */
    int l, r, t, b;             /* left, right, top, bottom */
    double accelFactor;         /* 1/pixels */
    int fingerLow, fingerHigh;  /* pressure */
    int emulateTwoFingerMinZ;   /* pressure */
    int emulateTwoFingerMinW;   /* width */
    int pressureMotionMinZ, pressureMotionMaxZ; /* pressure */
    int palmMinWidth, palmMinZ; /* pressure */
    int tapButton1, tapButton2, tapButton3;
    int clickFinger1, clickFinger2, clickFinger3;
    Bool vertEdgeScroll, horizEdgeScroll;
    Bool vertTwoFingerScroll, horizTwoFingerScroll;
    int horizResolution = 1;
    int vertResolution = 1;
    int width, height, diag, range;
    int horizHyst, vertHyst;
    int middle_button_timeout;
    int grab_event_device = 0;
    const char *source;

    /* The synaptics specs specify typical edge widths of 4% on x, and 5.4% on
     * y (page 7) [Synaptics TouchPad Interfacing Guide, 510-000080 - A
     * Second Edition, http://www.synaptics.com/support/dev_support.cfm, 8 Sep
     * 2008]. We use 7% for both instead for synaptics devices, and 15% for
     * ALPS models.
     * http://bugs.freedesktop.org/show_bug.cgi?id=21214
     *
     * If the range was autodetected, apply these edge widths to all four
     * sides.
     */

    width = abs(priv->maxx - priv->minx);
    height = abs(priv->maxy - priv->miny);
    diag = sqrt(width * width + height * height);

    calculate_edge_widths(priv, &l, &r, &t, &b);

    /* Again, based on typical x/y range and defaults */
    horizScrollDelta = diag * .020;
    vertScrollDelta = diag * .020;
    tapMove = diag * .044;
    accelFactor = 200.0 / diag; /* trial-and-error */

    /* hysteresis, assume >= 0 is a detected value (e.g. evdev fuzz) */
    horizHyst = pars->hyst_x >= 0 ? pars->hyst_x : diag * 0.005;
    vertHyst = pars->hyst_y >= 0 ? pars->hyst_y : diag * 0.005;

    range = priv->maxp - priv->minp + 1;

    calculate_tap_hysteresis(priv, range, &fingerLow, &fingerHigh);

    /* scaling based on defaults and a pressure of 256 */
    emulateTwoFingerMinZ = priv->minp + range * (282.0 / 256);
    pressureMotionMinZ = priv->minp + range * (30.0 / 256);
    pressureMotionMaxZ = priv->minp + range * (160.0 / 256);
    palmMinZ = priv->minp + range * (200.0 / 256);

    range = priv->maxw - priv->minw + 1;

    /* scaling based on defaults below and a tool width of 16 */
    palmMinWidth = priv->minw + range * (10.0 / 16);
    emulateTwoFingerMinW = priv->minw + range * (7.0 / 16);

    /* Enable tap if we don't have a phys left button */
    tapButton1 = priv->has_left ? 0 : 1;
    tapButton2 = priv->has_left ? 0 : 3;
    tapButton3 = priv->has_left ? 0 : 2;

    /* Enable multifinger-click if only have one physical button,
       otherwise clickFinger is always button 1. */
    clickFinger1 = 1;
    clickFinger2 = (priv->has_right || priv->has_middle) ? 1 : 3;
    clickFinger3 = (priv->has_right || priv->has_middle) ? 1 : 2;

    /* Enable vert edge scroll if we can't detect doubletap */
    vertEdgeScroll = priv->has_double ? FALSE : TRUE;
    horizEdgeScroll = FALSE;

    /* Enable twofinger scroll if we can detect doubletap */
    vertTwoFingerScroll = priv->has_double ? TRUE : FALSE;
    horizTwoFingerScroll = FALSE;

    /* Use resolution reported by hardware if available */
    if ((priv->resx > 0) && (priv->resy > 0)) {
        horizResolution = priv->resx;
        vertResolution = priv->resy;
    }

    /* set the parameters */
    pars->left_edge = xf86SetIntOption(opts, "LeftEdge", l);
    pars->right_edge = xf86SetIntOption(opts, "RightEdge", r);
    pars->top_edge = xf86SetIntOption(opts, "TopEdge", t);
    pars->bottom_edge = xf86SetIntOption(opts, "BottomEdge", b);

    pars->area_top_edge =
        set_percent_option(opts, "AreaTopEdge", height, priv->miny, 0);
    pars->area_bottom_edge =
        set_percent_option(opts, "AreaBottomEdge", height, priv->miny, 0);
    pars->area_left_edge =
        set_percent_option(opts, "AreaLeftEdge", width, priv->minx, 0);
    pars->area_right_edge =
        set_percent_option(opts, "AreaRightEdge", width, priv->minx, 0);

    pars->hyst_x =
        set_percent_option(opts, "HorizHysteresis", width, 0, horizHyst);
    pars->hyst_y =
        set_percent_option(opts, "VertHysteresis", height, 0, vertHyst);

    pars->finger_low = xf86SetIntOption(opts, "FingerLow", fingerLow);
    pars->finger_high = xf86SetIntOption(opts, "FingerHigh", fingerHigh);
    pars->tap_time = xf86SetIntOption(opts, "MaxTapTime", 180);
    pars->tap_move = xf86SetIntOption(opts, "MaxTapMove", tapMove);
    pars->tap_time_2 = xf86SetIntOption(opts, "MaxDoubleTapTime", 180);
    pars->click_time = xf86SetIntOption(opts, "ClickTime", 100);
    pars->clickpad = xf86SetBoolOption(opts, "ClickPad", pars->clickpad);       /* Probed */
    if (pars->clickpad)
        pars->has_secondary_buttons = xf86SetBoolOption(opts,
                                                        "HasSecondarySoftButtons",
                                                        pars->has_secondary_buttons);
    pars->clickpad_ignore_motion_time = 100; /* ms */
    /* middle mouse button emulation on a clickpad? nah, you're joking */
    middle_button_timeout = pars->clickpad ? 0 : 75;
    pars->emulate_mid_button_time =
        xf86SetIntOption(opts, "EmulateMidButtonTime", middle_button_timeout);
    pars->emulate_twofinger_z =
        xf86SetIntOption(opts, "EmulateTwoFingerMinZ", emulateTwoFingerMinZ);
    pars->emulate_twofinger_w =
        xf86SetIntOption(opts, "EmulateTwoFingerMinW", emulateTwoFingerMinW);
    pars->scroll_dist_vert =
        xf86SetIntOption(opts, "VertScrollDelta", vertScrollDelta);
    pars->scroll_dist_horiz =
        xf86SetIntOption(opts, "HorizScrollDelta", horizScrollDelta);
    pars->scroll_edge_vert =
        xf86SetBoolOption(opts, "VertEdgeScroll", vertEdgeScroll);
    pars->scroll_edge_horiz =
        xf86SetBoolOption(opts, "HorizEdgeScroll", horizEdgeScroll);
    pars->scroll_edge_corner = xf86SetBoolOption(opts, "CornerCoasting", FALSE);
    pars->scroll_twofinger_vert =
        xf86SetBoolOption(opts, "VertTwoFingerScroll", vertTwoFingerScroll);
    pars->scroll_twofinger_horiz =
        xf86SetBoolOption(opts, "HorizTwoFingerScroll", horizTwoFingerScroll);
    pars->touchpad_off = xf86SetIntOption(opts, "TouchpadOff", TOUCHPAD_ON);

    if (priv->has_scrollbuttons) {
        pars->updown_button_scrolling =
            xf86SetBoolOption(opts, "UpDownScrolling", TRUE);
        pars->leftright_button_scrolling =
            xf86SetBoolOption(opts, "LeftRightScrolling", TRUE);
        pars->updown_button_repeat =
            xf86SetBoolOption(opts, "UpDownScrollRepeat", TRUE);
        pars->leftright_button_repeat =
            xf86SetBoolOption(opts, "LeftRightScrollRepeat", TRUE);
    }
    pars->scroll_button_repeat =
        xf86SetIntOption(opts, "ScrollButtonRepeat", 100);

    pars->locked_drags = xf86SetBoolOption(opts, "LockedDrags", FALSE);
    pars->locked_drag_time = xf86SetIntOption(opts, "LockedDragTimeout", 5000);
    pars->tap_action[RT_TAP] = xf86SetIntOption(opts, "RTCornerButton", 0);
    pars->tap_action[RB_TAP] = xf86SetIntOption(opts, "RBCornerButton", 0);
    pars->tap_action[LT_TAP] = xf86SetIntOption(opts, "LTCornerButton", 0);
    pars->tap_action[LB_TAP] = xf86SetIntOption(opts, "LBCornerButton", 0);
    pars->tap_action[F1_TAP] = xf86SetIntOption(opts, "TapButton1", tapButton1);
    pars->tap_action[F2_TAP] = xf86SetIntOption(opts, "TapButton2", tapButton2);
    pars->tap_action[F3_TAP] = xf86SetIntOption(opts, "TapButton3", tapButton3);
    pars->click_action[F1_CLICK1] =
        xf86SetIntOption(opts, "ClickFinger1", clickFinger1);
    pars->click_action[F2_CLICK1] =
        xf86SetIntOption(opts, "ClickFinger2", clickFinger2);
    pars->click_action[F3_CLICK1] =
        xf86SetIntOption(opts, "ClickFinger3", clickFinger3);
    pars->circular_scrolling =
        xf86SetBoolOption(opts, "CircularScrolling", FALSE);
    pars->circular_trigger = xf86SetIntOption(opts, "CircScrollTrigger", 0);
    pars->circular_pad = xf86SetBoolOption(opts, "CircularPad", FALSE);
    pars->palm_detect = xf86SetBoolOption(opts, "PalmDetect", FALSE);
    pars->palm_min_width = xf86SetIntOption(opts, "PalmMinWidth", palmMinWidth);
    pars->palm_min_z = xf86SetIntOption(opts, "PalmMinZ", palmMinZ);
    pars->single_tap_timeout = xf86SetIntOption(opts, "SingleTapTimeout", 180);
    pars->press_motion_min_z =
        xf86SetIntOption(opts, "PressureMotionMinZ", pressureMotionMinZ);
    pars->press_motion_max_z =
        xf86SetIntOption(opts, "PressureMotionMaxZ", pressureMotionMaxZ);

    pars->min_speed = xf86SetRealOption(opts, "MinSpeed", 0.4);
    pars->max_speed = xf86SetRealOption(opts, "MaxSpeed", 0.7);
    pars->accl = xf86SetRealOption(opts, "AccelFactor", accelFactor);
    pars->scroll_dist_circ = xf86SetRealOption(opts, "CircScrollDelta", 0.1);
    pars->coasting_speed = xf86SetRealOption(opts, "CoastingSpeed", 20.0);
    pars->coasting_friction = xf86SetRealOption(opts, "CoastingFriction", 50);
    pars->press_motion_min_factor =
        xf86SetRealOption(opts, "PressureMotionMinFactor", 1.0);
    pars->press_motion_max_factor =
        xf86SetRealOption(opts, "PressureMotionMaxFactor", 1.0);

    /* Only grab the device by default if it's not coming from a config
       backend. This way we avoid the device being added twice and sending
       duplicate events.
      */
    source = xf86CheckStrOption(opts, "_source", NULL);
    if (source == NULL || strncmp(source, "server/", 7) != 0)
        grab_event_device = TRUE;
    pars->grab_event_device = xf86SetBoolOption(opts, "GrabEventDevice", grab_event_device);

    pars->tap_and_drag_gesture =
        xf86SetBoolOption(opts, "TapAndDragGesture", TRUE);
    pars->resolution_horiz =
        xf86SetIntOption(opts, "HorizResolution", horizResolution);
    pars->resolution_vert =
        xf86SetIntOption(opts, "VertResolution", vertResolution);
    if (pars->resolution_horiz <= 0) {
        xf86IDrvMsg(pInfo, X_ERROR,
                    "Invalid X resolution, using 1 instead.\n");
        pars->resolution_horiz = 1;
    }
    if (pars->resolution_vert <= 0) {
        xf86IDrvMsg(pInfo, X_ERROR,
                    "Invalid Y resolution, using 1 instead.\n");
        pars->resolution_vert = 1;
    }

    /* Touchpad sampling rate is too low to detect all movements.
       A user may lift one finger and put another one down within the same
       EV_SYN or even between samplings so the driver doesn't notice at all.

       We limit the movement to 20 mm within one event, that is more than
       recordings showed is needed (17mm on a T440).
      */
    if (pars->resolution_horiz > 1 &&
        pars->resolution_vert > 1)
        pars->maxDeltaMM = 20;
    else {
        /* on devices without resolution set the vector length to 0.25 of
           the touchpad diagonal */
        pars->maxDeltaMM = diag * 0.25;
    }


    /* Warn about (and fix) incorrectly configured TopEdge/BottomEdge parameters */
    if (pars->top_edge > pars->bottom_edge) {
        int tmp = pars->top_edge;

        pars->top_edge = pars->bottom_edge;
        pars->bottom_edge = tmp;
        xf86IDrvMsg(pInfo, X_WARNING,
                    "TopEdge is bigger than BottomEdge. Fixing.\n");
    }

    set_primary_softbutton_areas_option(pInfo);
    if (pars->has_secondary_buttons)
        set_secondary_softbutton_areas_option(pInfo);
}

static double
SynapticsAccelerationProfile(DeviceIntPtr dev,
                             DeviceVelocityPtr vel,
                             double velocity, double thr, double acc)
{
    InputInfoPtr pInfo = dev->public.devicePrivate;
    SynapticsPrivate *priv = (SynapticsPrivate *) (pInfo->private);
    SynapticsParameters *para = &priv->synpara;

    double accelfct;

    /*
     * synaptics accel was originally base on device coordinate based
     * velocity, which we recover this way so para->accl retains its scale.
     */
    velocity /= vel->const_acceleration;

    /* speed up linear with finger velocity */
    accelfct = velocity * para->accl;

    /* clip acceleration factor */
    if (accelfct > para->max_speed * acc)
        accelfct = para->max_speed * acc;
    else if (accelfct < para->min_speed)
        accelfct = para->min_speed;

    /* modify speed according to pressure */
    if (priv->moving_state == MS_TOUCHPAD_RELATIVE) {
        int minZ = para->press_motion_min_z;
        int maxZ = para->press_motion_max_z;
        double minFctr = para->press_motion_min_factor;
        double maxFctr = para->press_motion_max_factor;

        if (priv->hwState->z <= minZ) {
            accelfct *= minFctr;
        }
        else if (priv->hwState->z >= maxZ) {
            accelfct *= maxFctr;
        }
        else {
            accelfct *=
                minFctr + (priv->hwState->z - minZ) * (maxFctr -
                                                       minFctr) / (maxZ - minZ);
        }
    }

    return accelfct;
}

static int
SynapticsPreInit(InputDriverPtr drv, InputInfoPtr pInfo, int flags)
{
    SynapticsPrivate *priv;

    /* allocate memory for SynapticsPrivateRec */
    priv = calloc(1, sizeof(SynapticsPrivate));
    if (!priv)
        return BadAlloc;

    pInfo->type_name = XI_TOUCHPAD;
    pInfo->device_control = DeviceControl;
    pInfo->read_input = ReadInput;
    pInfo->control_proc = ControlProc;
    pInfo->switch_mode = SwitchMode;
    pInfo->private = priv;

    /* allocate now so we don't allocate in the signal handler */
    priv->timer = TimerSet(NULL, 0, 0, NULL, NULL);
    if (!priv->timer) {
        free(priv);
        return BadAlloc;
    }

    /* may change pInfo->options */
    if (!SetDeviceAndProtocol(pInfo)) {
        xf86IDrvMsg(pInfo, X_ERROR,
                    "Synaptics driver unable to detect protocol\n");
        goto SetupProc_fail;
    }

    priv->device = xf86FindOptionValue(pInfo->options, "Device");

    /* open the touchpad device */
    pInfo->fd = xf86OpenSerial(pInfo->options);
    if (pInfo->fd == -1) {
        xf86IDrvMsg(pInfo, X_ERROR, "Synaptics driver unable to open device\n");
        goto SetupProc_fail;
    }
    xf86ErrorFVerb(6, "port opened successfully\n");

    /* initialize variables */
    priv->repeatButtons = 0;
    priv->nextRepeat = 0;
    priv->count_packet_finger = 0;
    priv->tap_state = TS_START;
    priv->tap_button = 0;
    priv->tap_button_state = TBS_BUTTON_UP;
    priv->touch_on.millis = 0;
    priv->synpara.hyst_x = -1;
    priv->synpara.hyst_y = -1;

    /* read hardware dimensions */
    ReadDevDimensions(pInfo);

    set_default_parameters(pInfo);

#ifndef NO_DRIVER_SCALING
    CalculateScalingCoeffs(priv);
#endif


    priv->comm.buffer = XisbNew(pInfo->fd, INPUT_BUFFER_SIZE);

    if (!QueryHardware(pInfo)) {
        xf86IDrvMsg(pInfo, X_ERROR,
                    "Unable to query/initialize Synaptics hardware.\n");
        goto SetupProc_fail;
    }

    xf86ProcessCommonOptions(pInfo, pInfo->options);

    if (priv->comm.buffer) {
        XisbFree(priv->comm.buffer);
        priv->comm.buffer = NULL;
    }
    SynapticsCloseFd(pInfo);

    return Success;

 SetupProc_fail:
    SynapticsCloseFd(pInfo);

    if (priv->comm.buffer)
        XisbFree(priv->comm.buffer);
    free(priv->proto_data);
    free(priv->timer);
    free(priv);
    pInfo->private = NULL;
    return BadAlloc;
}

/*
 *  Uninitialize the device.
 */
static void
SynapticsUnInit(InputDriverPtr drv, InputInfoPtr pInfo, int flags)
{
    SynapticsPrivate *priv = ((SynapticsPrivate *) pInfo->private);

    if (priv && priv->timer)
        free(priv->timer);
    if (priv && priv->proto_data)
        free(priv->proto_data);
    if (priv && priv->scroll_events_mask)
        valuator_mask_free(&priv->scroll_events_mask);
    if (priv && priv->open_slots)
        free(priv->open_slots);
    free(pInfo->private);
    pInfo->private = NULL;
    xf86DeleteInput(pInfo, 0);
}

/*
 *  Alter the control parameters for the mouse. Note that all special
 *  protocol values are handled by dix.
 */
static void
SynapticsCtrl(DeviceIntPtr device, PtrCtrl * ctrl)
{
}

static int
DeviceControl(DeviceIntPtr dev, int mode)
{
    Bool RetValue;

    switch (mode) {
    case DEVICE_INIT:
        RetValue = DeviceInit(dev);
        break;
    case DEVICE_ON:
        RetValue = DeviceOn(dev);
        break;
    case DEVICE_OFF:
        RetValue = DeviceOff(dev);
        break;
    case DEVICE_CLOSE:
        RetValue = DeviceClose(dev);
        break;
    default:
        RetValue = BadValue;
    }

    return RetValue;
}

static int
DeviceOn(DeviceIntPtr dev)
{
    InputInfoPtr pInfo = dev->public.devicePrivate;
    SynapticsPrivate *priv = (SynapticsPrivate *) (pInfo->private);

    DBG(3, "Synaptics DeviceOn called\n");

    pInfo->fd = xf86OpenSerial(pInfo->options);
    if (pInfo->fd == -1) {
        xf86IDrvMsg(pInfo, X_WARNING, "cannot open input device\n");
        return !Success;
    }

    if (priv->proto_ops->DeviceOnHook &&
        !priv->proto_ops->DeviceOnHook(pInfo, &priv->synpara))
         goto error;

    priv->comm.buffer = XisbNew(pInfo->fd, INPUT_BUFFER_SIZE);
    if (!priv->comm.buffer)
        goto error;

    xf86FlushInput(pInfo->fd);

    /* reinit the pad */
    if (!QueryHardware(pInfo))
        goto error;

    xf86AddEnabledDevice(pInfo);
    dev->public.on = TRUE;

    return Success;

error:
    if (priv->comm.buffer) {
        XisbFree(priv->comm.buffer);
        priv->comm.buffer = NULL;
    }
    SynapticsCloseFd(pInfo);
    return !Success;
}

static void
SynapticsReset(SynapticsPrivate * priv)
{
    int i;

    SynapticsResetHwState(priv->hwState);
    SynapticsResetHwState(priv->local_hw_state);
    SynapticsResetHwState(priv->comm.hwState);

    memset(priv->move_hist, 0, sizeof(priv->move_hist));
    priv->hyst_center_x = 0;
    priv->hyst_center_y = 0;
    memset(&priv->scroll, 0, sizeof(priv->scroll));
    priv->count_packet_finger = 0;
    priv->finger_state = FS_UNTOUCHED;
    priv->last_motion_millis = 0;
    priv->clickpad_click_millis = 0;
    priv->last_button_area = NO_BUTTON_AREA;
    priv->tap_state = TS_START;
    priv->tap_button = 0;
    priv->tap_button_state = TBS_BUTTON_UP;
    priv->moving_state = MS_FALSE;
    priv->vert_scroll_edge_on = FALSE;
    priv->horiz_scroll_edge_on = FALSE;
    priv->vert_scroll_twofinger_on = FALSE;
    priv->horiz_scroll_twofinger_on = FALSE;
    priv->circ_scroll_on = FALSE;
    priv->circ_scroll_vert = FALSE;
    priv->mid_emu_state = MBE_OFF;
    priv->nextRepeat = 0;
    priv->lastButtons = 0;
    priv->prev_z = 0;
    priv->prevFingers = 0;
    priv->num_active_touches = 0;

    for (i = 0; i < priv->num_slots; i++)
        priv->open_slots[i] = -1;
}

static int
DeviceOff(DeviceIntPtr dev)
{
    InputInfoPtr pInfo = dev->public.devicePrivate;
    SynapticsPrivate *priv = (SynapticsPrivate *) (pInfo->private);
    Bool rc = Success;

    DBG(3, "Synaptics DeviceOff called\n");

    if (pInfo->fd != -1) {
        TimerCancel(priv->timer);
        xf86RemoveEnabledDevice(pInfo);
        SynapticsReset(priv);

        if (priv->proto_ops->DeviceOffHook &&
            !priv->proto_ops->DeviceOffHook(pInfo))
            rc = !Success;
        if (priv->comm.buffer) {
            XisbFree(priv->comm.buffer);
            priv->comm.buffer = NULL;
        }
        SynapticsCloseFd(pInfo);
    }
    dev->public.on = FALSE;
    return rc;
}

static int
DeviceClose(DeviceIntPtr dev)
{
    Bool RetValue;
    InputInfoPtr pInfo = dev->public.devicePrivate;
    SynapticsPrivate *priv = (SynapticsPrivate *) pInfo->private;

    RetValue = DeviceOff(dev);
    TimerFree(priv->timer);
    priv->timer = NULL;
    free(priv->touch_axes);
    priv->touch_axes = NULL;
    SynapticsHwStateFree(&priv->hwState);
    SynapticsHwStateFree(&priv->local_hw_state);
    SynapticsHwStateFree(&priv->comm.hwState);
    return RetValue;
}

static void
InitAxesLabels(Atom *labels, int nlabels, const SynapticsPrivate * priv)
{
    int i;

    memset(labels, 0, nlabels * sizeof(Atom));
    switch (nlabels) {
    default:
    case 4:
        labels[3] = XIGetKnownProperty(AXIS_LABEL_PROP_REL_VSCROLL);
    case 3:
        labels[2] = XIGetKnownProperty(AXIS_LABEL_PROP_REL_HSCROLL);
    case 2:
        labels[1] = XIGetKnownProperty(AXIS_LABEL_PROP_REL_Y);
    case 1:
        labels[0] = XIGetKnownProperty(AXIS_LABEL_PROP_REL_X);
        break;
    }

    for (i = 0; i < priv->num_mt_axes; i++) {
        SynapticsTouchAxisRec *axis = &priv->touch_axes[i];
        int axnum = nlabels - priv->num_mt_axes + i;

        labels[axnum] = XIGetKnownProperty(axis->label);
    }
}

static void
InitButtonLabels(Atom *labels, int nlabels)
{
    memset(labels, 0, nlabels * sizeof(Atom));
    switch (nlabels) {
    default:
    case 7:
        labels[6] = XIGetKnownProperty(BTN_LABEL_PROP_BTN_HWHEEL_RIGHT);
    case 6:
        labels[5] = XIGetKnownProperty(BTN_LABEL_PROP_BTN_HWHEEL_LEFT);
    case 5:
        labels[4] = XIGetKnownProperty(BTN_LABEL_PROP_BTN_WHEEL_DOWN);
    case 4:
        labels[3] = XIGetKnownProperty(BTN_LABEL_PROP_BTN_WHEEL_UP);
    case 3:
        labels[2] = XIGetKnownProperty(BTN_LABEL_PROP_BTN_RIGHT);
    case 2:
        labels[1] = XIGetKnownProperty(BTN_LABEL_PROP_BTN_MIDDLE);
    case 1:
        labels[0] = XIGetKnownProperty(BTN_LABEL_PROP_BTN_LEFT);
        break;
    }
}

static void
DeviceInitTouch(DeviceIntPtr dev, Atom *axes_labels)
{
    InputInfoPtr pInfo = dev->public.devicePrivate;
    SynapticsPrivate *priv = (SynapticsPrivate *) (pInfo->private);

    if (!priv->has_touch)
        return;

    priv->num_slots =
        priv->max_touches ? priv->max_touches : SYNAPTICS_MAX_TOUCHES;

    priv->open_slots = malloc(priv->num_slots * sizeof(int));
    if (!priv->open_slots) {
        xf86IDrvMsg(pInfo, X_ERROR,
                    "failed to allocate open touch slots array\n");
        priv->has_touch = 0;
        priv->num_slots = 0;
    }
}

static int
DeviceInit(DeviceIntPtr dev)
{
    InputInfoPtr pInfo = dev->public.devicePrivate;
    SynapticsPrivate *priv = (SynapticsPrivate *) (pInfo->private);
    Atom float_type, prop;
    float tmpf;
    unsigned char map[SYN_MAX_BUTTONS + 1];
    int i;
    int min, max;
    int num_axes = 2;
    Atom btn_labels[SYN_MAX_BUTTONS] = { 0 };
    Atom *axes_labels;
    DeviceVelocityPtr pVel;

    num_axes += 2;

    num_axes += priv->num_mt_axes;

    axes_labels = calloc(num_axes, sizeof(Atom));
    if (!axes_labels) {
        xf86IDrvMsg(pInfo, X_ERROR, "failed to allocate axis labels\n");
        return !Success;
    }

    InitAxesLabels(axes_labels, num_axes, priv);
    InitButtonLabels(btn_labels, SYN_MAX_BUTTONS);

    DBG(3, "Synaptics DeviceInit called\n");

    for (i = 0; i <= SYN_MAX_BUTTONS; i++)
        map[i] = i;

    dev->public.on = FALSE;

    InitPointerDeviceStruct((DevicePtr) dev, map,
                            SYN_MAX_BUTTONS,
                            btn_labels,
                            SynapticsCtrl,
                            GetMotionHistorySize(), num_axes, axes_labels);

    /*
     * setup dix acceleration to match legacy synaptics settings, and
     * etablish a device-specific profile to do stuff like pressure-related
     * acceleration.
     */
    if (NULL != (pVel = GetDevicePredictableAccelData(dev))) {
        SetDeviceSpecificAccelerationProfile(pVel,
                                             SynapticsAccelerationProfile);

        /* float property type */
        float_type = XIGetKnownProperty(XATOM_FLOAT);

        /* translate MinAcc to constant deceleration.
         * May be overridden in xf86InitValuatorDefaults */
        tmpf = 1.0 / priv->synpara.min_speed;

        xf86IDrvMsg(pInfo, X_CONFIG,
                    "(accel) MinSpeed is now constant deceleration " "%.1f\n",
                    tmpf);
        prop = XIGetKnownProperty(ACCEL_PROP_CONSTANT_DECELERATION);
        XIChangeDeviceProperty(dev, prop, float_type, 32,
                               PropModeReplace, 1, &tmpf, FALSE);

        /* adjust accordingly */
        priv->synpara.max_speed /= priv->synpara.min_speed;
        priv->synpara.min_speed = 1.0;

        /* synaptics seems to report 80 packet/s, but dix scales for
         * 100 packet/s by default. */
        pVel->corr_mul = 12.5f; /*1000[ms]/80[/s] = 12.5 */

        xf86IDrvMsg(pInfo, X_CONFIG, "(accel) MaxSpeed is now %.2f\n",
                    priv->synpara.max_speed);
        xf86IDrvMsg(pInfo, X_CONFIG, "(accel) AccelFactor is now %.3f\n",
                    priv->synpara.accl);

        prop = XIGetKnownProperty(ACCEL_PROP_PROFILE_NUMBER);
        i = AccelProfileDeviceSpecific;
        XIChangeDeviceProperty(dev, prop, XA_INTEGER, 32,
                               PropModeReplace, 1, &i, FALSE);
    }

    /* X valuator */
    if (priv->minx < priv->maxx) {
        min = priv->minx;
        max = priv->maxx;
    }
    else {
        min = 0;
        max = -1;
    }

    xf86InitValuatorAxisStruct(dev, 0, axes_labels[0], min, max,
			       priv->resx * 1000, 0, priv->resx * 1000,
			       Relative);
    xf86InitValuatorDefaults(dev, 0);

    /* Y valuator */
    if (priv->miny < priv->maxy) {
        min = priv->miny;
        max = priv->maxy;
    }
    else {
        min = 0;
        max = -1;
    }

    xf86InitValuatorAxisStruct(dev, 1, axes_labels[1], min, max,
			       priv->resy * 1000, 0, priv->resy * 1000,
			       Relative);
    xf86InitValuatorDefaults(dev, 1);

    xf86InitValuatorAxisStruct(dev, 2, axes_labels[2], 0, -1, 0, 0, 0,
                               Relative);
    priv->scroll_axis_horiz = 2;
    xf86InitValuatorAxisStruct(dev, 3, axes_labels[3], 0, -1, 0, 0, 0,
                               Relative);
    priv->scroll_axis_vert = 3;
    priv->scroll_events_mask = valuator_mask_new(MAX_VALUATORS);
    if (!priv->scroll_events_mask) {
        free(axes_labels);
        return !Success;
    }

    SetScrollValuator(dev, priv->scroll_axis_horiz, SCROLL_TYPE_HORIZONTAL,
                      priv->synpara.scroll_dist_horiz, 0);
    SetScrollValuator(dev, priv->scroll_axis_vert, SCROLL_TYPE_VERTICAL,
                      priv->synpara.scroll_dist_vert, 0);

    DeviceInitTouch(dev, axes_labels);

    free(axes_labels);

    priv->hwState = SynapticsHwStateAlloc(priv);
    if (!priv->hwState)
        goto fail;

    priv->local_hw_state = SynapticsHwStateAlloc(priv);
    if (!priv->local_hw_state)
        goto fail;

    priv->comm.hwState = SynapticsHwStateAlloc(priv);

    InitDeviceProperties(pInfo);
    XIRegisterPropertyHandler(pInfo->dev, SetProperty, NULL, NULL);

    SynapticsReset(priv);

    return Success;

 fail:
    free(priv->local_hw_state);
    free(priv->hwState);
    free(priv->open_slots);
    return !Success;
}

/*
 * Convert from absolute X/Y coordinates to a coordinate system where
 * -1 corresponds to the left/upper edge and +1 corresponds to the
 * right/lower edge.
 */
static void
relative_coords(SynapticsPrivate * priv, int x, int y,
                double *relX, double *relY)
{
    int minX = priv->synpara.left_edge;
    int maxX = priv->synpara.right_edge;
    int minY = priv->synpara.top_edge;
    int maxY = priv->synpara.bottom_edge;
    double xCenter = (minX + maxX) / 2.0;
    double yCenter = (minY + maxY) / 2.0;

    if ((maxX - xCenter > 0) && (maxY - yCenter > 0)) {
        *relX = (x - xCenter) / (maxX - xCenter);
        *relY = (y - yCenter) / (maxY - yCenter);
    }
    else {
        *relX = 0;
        *relY = 0;
    }
}

/* return angle of point relative to center */
static double
angle(SynapticsPrivate * priv, int x, int y)
{
    double xCenter = (priv->synpara.left_edge + priv->synpara.right_edge) / 2.0;
    double yCenter = (priv->synpara.top_edge + priv->synpara.bottom_edge) / 2.0;

    return atan2(-(y - yCenter), x - xCenter);
}

/* return angle difference */
static double
diffa(double a1, double a2)
{
    double da = fmod(a2 - a1, 2 * M_PI);

    if (da < 0)
        da += 2 * M_PI;
    if (da > M_PI)
        da -= 2 * M_PI;
    return da;
}

static enum EdgeType
circular_edge_detection(SynapticsPrivate * priv, int x, int y)
{
    enum EdgeType edge = 0;
    double relX, relY, relR;

    relative_coords(priv, x, y, &relX, &relY);
    relR = SQR(relX) + SQR(relY);

    if (relR > 1) {
        /* we are outside the ellipse enclosed by the edge parameters */
        if (relX > M_SQRT1_2)
            edge |= RIGHT_EDGE;
        else if (relX < -M_SQRT1_2)
            edge |= LEFT_EDGE;

        if (relY < -M_SQRT1_2)
            edge |= TOP_EDGE;
        else if (relY > M_SQRT1_2)
            edge |= BOTTOM_EDGE;
    }

    return edge;
}

static enum EdgeType
edge_detection(SynapticsPrivate * priv, int x, int y)
{
    enum EdgeType edge = NO_EDGE;

    if (priv->synpara.circular_pad)
        return circular_edge_detection(priv, x, y);

    if (x > priv->synpara.right_edge)
        edge |= RIGHT_EDGE;
    else if (x < priv->synpara.left_edge)
        edge |= LEFT_EDGE;

    if (y < priv->synpara.top_edge)
        edge |= TOP_EDGE;
    else if (y > priv->synpara.bottom_edge)
        edge |= BOTTOM_EDGE;

    return edge;
}

/* Checks whether coordinates are in the Synaptics Area
 * or not. If no Synaptics Area is defined (i.e. if
 * priv->synpara.area_{left|right|top|bottom}_edge are
 * all set to zero), the function returns TRUE.
 */
static Bool
is_inside_active_area(SynapticsPrivate * priv, int x, int y)
{
    Bool inside_area = TRUE;

    /* If a finger is down, then it must have started inside the active_area,
       allow the motion to complete using the entire area */
    if (priv->finger_state >= FS_TOUCHED)
        return TRUE;

    if ((priv->synpara.area_left_edge != 0) &&
        (x < priv->synpara.area_left_edge))
        inside_area = FALSE;
    else if ((priv->synpara.area_right_edge != 0) &&
             (x > priv->synpara.area_right_edge))
        inside_area = FALSE;

    if ((priv->synpara.area_top_edge != 0) && (y < priv->synpara.area_top_edge))
        inside_area = FALSE;
    else if ((priv->synpara.area_bottom_edge != 0) &&
             (y > priv->synpara.area_bottom_edge))
        inside_area = FALSE;

    return inside_area;
}

static Bool
is_inside_button_area(SynapticsParameters * para, int which, int x, int y)
{
    Bool inside_area = TRUE;

    if (para->softbutton_areas[which][LEFT] == 0 &&
        para->softbutton_areas[which][RIGHT] == 0 &&
        para->softbutton_areas[which][TOP] == 0 &&
        para->softbutton_areas[which][BOTTOM] == 0)
        return FALSE;

    if (para->softbutton_areas[which][LEFT] &&
        x < para->softbutton_areas[which][LEFT])
        inside_area = FALSE;
    else if (para->softbutton_areas[which][RIGHT] &&
             x > para->softbutton_areas[which][RIGHT])
        inside_area = FALSE;
    else if (para->softbutton_areas[which][TOP] &&
             y < para->softbutton_areas[which][TOP])
        inside_area = FALSE;
    else if (para->softbutton_areas[which][BOTTOM] &&
             y > para->softbutton_areas[which][BOTTOM])
        inside_area = FALSE;

    return inside_area;
}

static Bool
is_inside_rightbutton_area(SynapticsParameters * para, int x, int y)
{
    return is_inside_button_area(para, BOTTOM_RIGHT_BUTTON_AREA, x, y);
}

static Bool
is_inside_middlebutton_area(SynapticsParameters * para, int x, int y)
{
    return is_inside_button_area(para, BOTTOM_MIDDLE_BUTTON_AREA, x, y);
}

static Bool
is_inside_sec_rightbutton_area(SynapticsParameters * para, int x, int y)
{
    return is_inside_button_area(para, TOP_RIGHT_BUTTON_AREA, x, y);
}

static Bool
is_inside_sec_middlebutton_area(SynapticsParameters * para, int x, int y)
{
    return is_inside_button_area(para, TOP_MIDDLE_BUTTON_AREA, x, y);
}

static Bool
is_inside_top_or_bottom_button_area(SynapticsParameters * para, int offset,
                                    int x, int y)
{
    Bool inside_area = TRUE;
    Bool right_valid, middle_valid;
    int top, bottom;

    /* We don't have a left button area, so we only check the y axis */
    right_valid = para->softbutton_areas[offset][TOP] ||
                  para->softbutton_areas[offset][BOTTOM];
    middle_valid = para->softbutton_areas[offset + 1][TOP] ||
                   para->softbutton_areas[offset + 1][BOTTOM];

    if (!right_valid && !middle_valid)
        return FALSE;

    /* Check both buttons are horizontally aligned */
    if (right_valid && middle_valid && (
            para->softbutton_areas[offset][TOP] !=
                para->softbutton_areas[offset + 1][TOP] ||
            para->softbutton_areas[offset][BOTTOM] !=
                para->softbutton_areas[offset + 1][BOTTOM]))
        return FALSE;

    if (right_valid) {
        top    = para->softbutton_areas[offset][TOP];
        bottom = para->softbutton_areas[offset][BOTTOM];
    }
    else {
        top    = para->softbutton_areas[offset + 1][TOP];
        bottom = para->softbutton_areas[offset + 1][BOTTOM];
    }

    if (top && y < top)
        inside_area = FALSE;
    else if (bottom && y > bottom)
        inside_area = FALSE;

    return inside_area;
}

static enum SoftButtonAreas
current_button_area(SynapticsParameters * para, int x, int y)
{
    if (is_inside_top_or_bottom_button_area(para, BOTTOM_BUTTON_AREA, x, y))
        return BOTTOM_BUTTON_AREA;
    else if (is_inside_top_or_bottom_button_area(para, TOP_BUTTON_AREA, x, y))
        return TOP_BUTTON_AREA;
    else
        return NO_BUTTON_AREA;
}

static CARD32
timerFunc(OsTimerPtr timer, CARD32 now, pointer arg)
{
    InputInfoPtr pInfo = arg;
    SynapticsPrivate *priv = (SynapticsPrivate *) (pInfo->private);
    struct SynapticsHwState *hw = priv->local_hw_state;
    int delay;
#if !HAVE_THREADED_INPUT
    int sigstate = xf86BlockSIGIO();
#else
    input_lock();
#endif

    priv->hwState->millis += now - priv->timer_time;
    SynapticsCopyHwState(hw, priv->hwState);
    SynapticsResetTouchHwState(hw, FALSE);
    delay = HandleState(pInfo, hw, hw->millis, TRUE);

    priv->timer_time = now;
    priv->timer = TimerSet(priv->timer, 0, delay, timerFunc, pInfo);

#if !HAVE_THREADED_INPUT
    xf86UnblockSIGIO(sigstate);
#else
    input_unlock();
#endif

    return 0;
}

static int
clamp(int val, int min, int max)
{
    if (val < min)
        return min;
    else if (val < max)
        return val;
    else
        return max;
}

static Bool
SynapticsGetHwState(InputInfoPtr pInfo, SynapticsPrivate * priv,
                    struct SynapticsHwState *hw)
{
    return priv->proto_ops->ReadHwState(pInfo, &priv->comm, hw);
}

/*
 *  called for each full received packet from the touchpad
 */
static void
ReadInput(InputInfoPtr pInfo)
{
    SynapticsPrivate *priv = (SynapticsPrivate *) (pInfo->private);
    struct SynapticsHwState *hw = priv->local_hw_state;
    int delay = 0;
    Bool newDelay = FALSE;

    SynapticsResetTouchHwState(hw, FALSE);

    while (SynapticsGetHwState(pInfo, priv, hw)) {
        /* Semi-mt device touch slots do not track touches. When there is a
         * change in the number of touches, we must disregard the temporary
         * motion changes. */
        if (priv->has_semi_mt && hw->numFingers != priv->hwState->numFingers) {
            hw->cumulative_dx = priv->hwState->cumulative_dx;
            hw->cumulative_dy = priv->hwState->cumulative_dy;
        }

        /* timer may cause actual events to lag behind (#48777) */
        if (priv->hwState->millis > hw->millis)
            hw->millis = priv->hwState->millis;

        SynapticsCopyHwState(priv->hwState, hw);
        delay = HandleState(pInfo, hw, hw->millis, FALSE);
        newDelay = TRUE;
    }

    if (newDelay) {
        priv->timer_time = GetTimeInMillis();
        priv->timer = TimerSet(priv->timer, 0, delay, timerFunc, pInfo);
    }
}

static int
HandleMidButtonEmulation(SynapticsPrivate * priv, struct SynapticsHwState *hw,
                         CARD32 now, int *delay)
{
    SynapticsParameters *para = &priv->synpara;
    Bool done = FALSE;
    int timeleft;
    int mid = 0;

    if (para->emulate_mid_button_time <= 0)
        return mid;

    while (!done) {
        switch (priv->mid_emu_state) {
        case MBE_LEFT_CLICK:
        case MBE_RIGHT_CLICK:
        case MBE_OFF:
            priv->button_delay_millis = now;
            if (hw->left) {
                priv->mid_emu_state = MBE_LEFT;
            }
            else if (hw->right) {
                priv->mid_emu_state = MBE_RIGHT;
            }
            else {
                done = TRUE;
            }
            break;
        case MBE_LEFT:
            timeleft =
                TIME_DIFF(priv->button_delay_millis +
                          para->emulate_mid_button_time, now);
            if (timeleft > 0)
                *delay = MIN(*delay, timeleft);

            /* timeout, but within the same ReadInput cycle! */
            if ((timeleft <= 0) && !hw->left) {
                priv->mid_emu_state = MBE_LEFT_CLICK;
                done = TRUE;
            }
            else if ((!hw->left) || (timeleft <= 0)) {
                hw->left = TRUE;
                priv->mid_emu_state = MBE_TIMEOUT;
                done = TRUE;
            }
            else if (hw->right) {
                priv->mid_emu_state = MBE_MID;
            }
            else {
                hw->left = FALSE;
                done = TRUE;
            }
            break;
        case MBE_RIGHT:
            timeleft =
                TIME_DIFF(priv->button_delay_millis +
                          para->emulate_mid_button_time, now);
            if (timeleft > 0)
                *delay = MIN(*delay, timeleft);

            /* timeout, but within the same ReadInput cycle! */
            if ((timeleft <= 0) && !hw->right) {
                priv->mid_emu_state = MBE_RIGHT_CLICK;
                done = TRUE;
            }
            else if (!hw->right || (timeleft <= 0)) {
                hw->right = TRUE;
                priv->mid_emu_state = MBE_TIMEOUT;
                done = TRUE;
            }
            else if (hw->left) {
                priv->mid_emu_state = MBE_MID;
            }
            else {
                hw->right = FALSE;
                done = TRUE;
            }
            break;
        case MBE_MID:
            if (!hw->left && !hw->right) {
                priv->mid_emu_state = MBE_OFF;
            }
            else {
                mid = TRUE;
                hw->left = hw->right = FALSE;
                done = TRUE;
            }
            break;
        case MBE_TIMEOUT:
            if (!hw->left && !hw->right) {
                priv->mid_emu_state = MBE_OFF;
            }
            else {
                done = TRUE;
            }
        }
    }
    return mid;
}

static enum FingerState
SynapticsDetectFinger(SynapticsPrivate * priv, struct SynapticsHwState *hw)
{
    SynapticsParameters *para = &priv->synpara;
    enum FingerState finger;

    /* finger detection thru pressure and threshold */
    if (hw->z < para->finger_low)
        return FS_UNTOUCHED;

    if (priv->finger_state == FS_BLOCKED)
        return FS_BLOCKED;

    if (hw->z > para->finger_high && priv->finger_state == FS_UNTOUCHED)
        finger = FS_TOUCHED;
    else
        finger = priv->finger_state;

    if (!para->palm_detect)
        return finger;

    /* palm detection */

    if ((hw->z > para->palm_min_z) && (hw->fingerWidth > para->palm_min_width))
        return FS_BLOCKED;

    if (priv->has_mt_palm_detect)
        return finger;

    if (hw->x == 0 || priv->finger_state == FS_UNTOUCHED)
        priv->avg_width = 0;
    else
        priv->avg_width += (hw->fingerWidth - priv->avg_width + 1) / 2;

    if (finger != FS_UNTOUCHED && priv->finger_state == FS_UNTOUCHED) {
        int safe_width = MAX(hw->fingerWidth, priv->avg_width);

        if (hw->numFingers > 1 ||       /* more than one finger -> not a palm */
            ((safe_width < 6) && (priv->prev_z < para->finger_high)) || /* thin finger, distinct touch -> not a palm */
            ((safe_width < 7) && (priv->prev_z < para->finger_high / 2))) {     /* thin finger, distinct touch -> not a palm */
            /* leave finger value as is */
        }
        else if (hw->z > priv->prev_z + 1)      /* z not stable, may be a palm */
            finger = FS_UNTOUCHED;
        else if (hw->z < priv->prev_z - 5)      /* z not stable, may be a palm */
            finger = FS_UNTOUCHED;
        else if (hw->fingerWidth > para->palm_min_width)        /* finger width too large -> probably palm */
            finger = FS_UNTOUCHED;
    }
    priv->prev_z = hw->z;

    return finger;
}

static void
SelectTapButton(SynapticsPrivate * priv, enum EdgeType edge)
{
    enum TapEvent tap;

    if (priv->synpara.touchpad_off == TOUCHPAD_TAP_OFF) {
        priv->tap_button = 0;
        return;
    }

    switch (priv->tap_max_fingers) {
    case 1:
        switch (edge) {
        case RIGHT_TOP_EDGE:
            DBG(7, "right top edge\n");
            tap = RT_TAP;
            break;
        case RIGHT_BOTTOM_EDGE:
            DBG(7, "right bottom edge\n");
            tap = RB_TAP;
            break;
        case LEFT_TOP_EDGE:
            DBG(7, "left top edge\n");
            tap = LT_TAP;
            break;
        case LEFT_BOTTOM_EDGE:
            DBG(7, "left bottom edge\n");
            tap = LB_TAP;
            break;
        default:
            DBG(7, "no edge\n");
            tap = F1_TAP;
            break;
        }
        break;
    case 2:
        DBG(7, "two finger tap\n");
        tap = F2_TAP;
        break;
    case 3:
        DBG(7, "three finger tap\n");
        tap = F3_TAP;
        break;
    default:
        priv->tap_button = 0;
        return;
    }

    priv->tap_button = priv->synpara.tap_action[tap];
    priv->tap_button = clamp(priv->tap_button, 0, SYN_MAX_BUTTONS);
}

static void
SetTapState(SynapticsPrivate * priv, enum TapState tap_state, CARD32 millis)
{
    DBG(3, "SetTapState - %d -> %d (millis:%u)\n", priv->tap_state, tap_state,
        millis);
    switch (tap_state) {
    case TS_START:
        priv->tap_button_state = TBS_BUTTON_UP;
        priv->tap_max_fingers = 0;
        break;
    case TS_1:
        priv->tap_button_state = TBS_BUTTON_UP;
        break;
    case TS_2A:
	priv->tap_button_state = TBS_BUTTON_UP;
        break;
    case TS_2B:
        priv->tap_button_state = TBS_BUTTON_UP;
        break;
    case TS_3:
        priv->tap_button_state = TBS_BUTTON_DOWN;
        break;
    case TS_SINGLETAP:
	priv->tap_button_state = TBS_BUTTON_DOWN;
        priv->touch_on.millis = millis;
        break;
    default:
        break;
    }
    priv->tap_state = tap_state;
}

static void
SetMovingState(SynapticsPrivate * priv, enum MovingState moving_state,
               CARD32 millis)
{
    DBG(7, "SetMovingState - %d -> %d center at %d/%d (millis:%u)\n",
        priv->moving_state, moving_state, priv->hwState->x, priv->hwState->y,
        millis);

    priv->moving_state = moving_state;
}

static int
GetTimeOut(SynapticsPrivate * priv)
{
    SynapticsParameters *para = &priv->synpara;

    switch (priv->tap_state) {
    case TS_1:
    case TS_3:
    case TS_5:
        return para->tap_time;
    case TS_SINGLETAP:
        return para->click_time;
    case TS_2A:
        return para->single_tap_timeout;
    case TS_2B:
        return para->tap_time_2;
    case TS_4:
        return para->locked_drag_time;
    default:
        return -1;              /* No timeout */
    }
}

static int
HandleTapProcessing(SynapticsPrivate * priv, struct SynapticsHwState *hw,
                    CARD32 now, enum FingerState finger,
                    Bool inside_active_area)
{
    SynapticsParameters *para = &priv->synpara;
    Bool touch, release, is_timeout, move, press;
    int timeleft, timeout;
    enum EdgeType edge;
    int delay = 1000000000;

    if (para->touchpad_off == TOUCHPAD_OFF ||
        priv->finger_state == FS_BLOCKED)
        return delay;

    touch = finger >= FS_TOUCHED && priv->finger_state == FS_UNTOUCHED;
    release = finger == FS_UNTOUCHED && priv->finger_state >= FS_TOUCHED;
    move = (finger >= FS_TOUCHED &&
            (priv->tap_max_fingers <=
             ((priv->horiz_scroll_twofinger_on ||
               priv->vert_scroll_twofinger_on) ? 2 : 1)) &&
            (priv->prevFingers == hw->numFingers &&
             ((abs(hw->x - priv->touch_on.x) >= para->tap_move) ||
              (abs(hw->y - priv->touch_on.y) >= para->tap_move))));
    press = (hw->left || hw->right || hw->middle);

    if (touch) {
        priv->touch_on.x = hw->x;
        priv->touch_on.y = hw->y;
        priv->touch_on.millis = now;
    }
    else if (release) {
        priv->touch_on.millis = now;
    }
    if (hw->z > para->finger_high)
        if (priv->tap_max_fingers < hw->numFingers)
            priv->tap_max_fingers = hw->numFingers;
    timeout = GetTimeOut(priv);
    timeleft = TIME_DIFF(priv->touch_on.millis + timeout, now);
    is_timeout = timeleft <= 0;

 restart:
    switch (priv->tap_state) {
    case TS_START:
        if (touch)
            SetTapState(priv, TS_1, now);
        break;
    case TS_1:
        if (para->clickpad && press) {
            SetTapState(priv, TS_CLICKPAD_MOVE, now);
            goto restart;
        }
        if (move) {
            SetMovingState(priv, MS_TOUCHPAD_RELATIVE, now);
            SetTapState(priv, TS_MOVE, now);
            goto restart;
        }
        else if (is_timeout) {
            if (finger == FS_TOUCHED) {
                SetMovingState(priv, MS_TOUCHPAD_RELATIVE, now);
            }
            SetTapState(priv, TS_MOVE, now);
            goto restart;
        }
        else if (release) {
            edge = edge_detection(priv, priv->touch_on.x, priv->touch_on.y);
            SelectTapButton(priv, edge);
            /* Disable taps outside of the active area */
            if (!inside_active_area) {
                priv->tap_button = 0;
            }
            SetTapState(priv, TS_2A, now);
        }
        break;
    case TS_MOVE:
        if (para->clickpad && press) {
            SetTapState(priv, TS_CLICKPAD_MOVE, now);
            goto restart;
        }
        if (release) {
            SetMovingState(priv, MS_FALSE, now);
            SetTapState(priv, TS_START, now);
        }
        break;
    case TS_2A:
        if (touch)
            SetTapState(priv, TS_3, now);
        else if (is_timeout)
            SetTapState(priv, TS_SINGLETAP, now);
        break;
    case TS_2B:
        if (touch)
            SetTapState(priv, TS_3, now);
        else if (is_timeout)
            SetTapState(priv, TS_SINGLETAP, now);
        break;
    case TS_SINGLETAP:
        if (touch)
            SetTapState(priv, TS_1, now);
        else if (is_timeout)
            SetTapState(priv, TS_START, now);
        break;
    case TS_3:
        if (move) {
            if (para->tap_and_drag_gesture) {
                SetMovingState(priv, MS_TOUCHPAD_RELATIVE, now);
                SetTapState(priv, TS_DRAG, now);
            }
            else {
                SetTapState(priv, TS_1, now);
            }
            goto restart;
        }
        else if (is_timeout) {
            if (para->tap_and_drag_gesture) {
                if (finger == FS_TOUCHED) {
                    SetMovingState(priv, MS_TOUCHPAD_RELATIVE, now);
                }
                SetTapState(priv, TS_DRAG, now);
            }
            else {
                SetTapState(priv, TS_1, now);
            }
            goto restart;
        }
        else if (release) {
            SetTapState(priv, TS_2B, now);
        }
        break;
    case TS_DRAG:
        if (para->clickpad && press) {
            SetTapState(priv, TS_CLICKPAD_MOVE, now);
            goto restart;
        }
        if (move)
            SetMovingState(priv, MS_TOUCHPAD_RELATIVE, now);
        if (release) {
            SetMovingState(priv, MS_FALSE, now);
            if (para->locked_drags) {
                SetTapState(priv, TS_4, now);
            }
            else {
                SetTapState(priv, TS_START, now);
            }
        }
        break;
    case TS_4:
        if (is_timeout) {
            SetTapState(priv, TS_START, now);
            goto restart;
        }
        if (touch)
            SetTapState(priv, TS_5, now);
        break;
    case TS_5:
        if (is_timeout || move) {
            SetTapState(priv, TS_DRAG, now);
            goto restart;
        }
        else if (release) {
            SetMovingState(priv, MS_FALSE, now);
            SetTapState(priv, TS_START, now);
        }
        break;
    case TS_CLICKPAD_MOVE:
        /* Disable scrolling once a button is pressed on a clickpad */
        priv->vert_scroll_edge_on = FALSE;
        priv->horiz_scroll_edge_on = FALSE;
        priv->vert_scroll_twofinger_on = FALSE;
        priv->horiz_scroll_twofinger_on = FALSE;

        /* Assume one touch is only for holding the clickpad button down */
        if (hw->numFingers > 1)
            hw->numFingers--;
        SetMovingState(priv, MS_TOUCHPAD_RELATIVE, now);
        if (!press) {
            SetMovingState(priv, MS_FALSE, now);
            SetTapState(priv, TS_MOVE, now);
            priv->count_packet_finger = 0;
        }
        break;
    }

    timeout = GetTimeOut(priv);
    if (timeout >= 0) {
        timeleft = TIME_DIFF(priv->touch_on.millis + timeout, now);
        delay = clamp(timeleft, 1, delay);
    }
    return delay;
}

#define HIST(a) (priv->move_hist[((priv->hist_index - (a) + SYNAPTICS_MOVE_HISTORY) % SYNAPTICS_MOVE_HISTORY)])
#define HIST_DELTA(a, b, e) ((HIST((a)).e) - (HIST((b)).e))

static void
store_history(SynapticsPrivate * priv, int x, int y, CARD32 millis)
{
    int idx = (priv->hist_index + 1) % SYNAPTICS_MOVE_HISTORY;

    priv->move_hist[idx].x = x;
    priv->move_hist[idx].y = y;
    priv->move_hist[idx].millis = millis;
    priv->hist_index = idx;
    if (priv->count_packet_finger < SYNAPTICS_MOVE_HISTORY)
        priv->count_packet_finger++;
}

/*
 * Estimate the slope for the data sequence [x3, x2, x1, x0] by using
 * linear regression to fit a line to the data and use the slope of the
 * line.
 */
static double
estimate_delta(double x0, double x1, double x2, double x3)
{
    return x0 * 0.3 + x1 * 0.1 - x2 * 0.1 - x3 * 0.3;
}

/**
 * Applies hysteresis. center is shifted such that it is in range with
 * in by the margin again. The new center is returned.
 * @@param in the current value
 * @@param center the current center
 * @@param margin the margin to center in which no change is applied
 * @@return the new center (which might coincide with the previous)
 */
static int
hysteresis(int in, int center, int margin)
{
    int diff = in - center;

    if (abs(diff) <= margin) {
        diff = 0;
    }
    else if (diff > margin) {
        diff -= margin;
    }
    else if (diff < -margin) {
        diff += margin;
    }
    return center + diff;
}

static void
get_delta(SynapticsPrivate *priv, const struct SynapticsHwState *hw,
          enum EdgeType edge, double *dx, double *dy)
{
    *dx = hw->x - HIST(0).x;
    *dy = hw->y - HIST(0).y;
}

/* Vector length, but not sqrt'ed, we only need it for comparison */
static inline double
vlenpow2(double x, double y)
{
    return x * x + y * y;
}

/**
 * Compute relative motion ('deltas') including edge motion.
 */
static int
ComputeDeltas(SynapticsPrivate * priv, const struct SynapticsHwState *hw,
              enum EdgeType edge, int *dxP, int *dyP, Bool inside_area)
{
    enum MovingState moving_state;
    double dx, dy;
    double vlen;
    int delay = 1000000000;

    dx = dy = 0;

    moving_state = priv->moving_state;
    if (moving_state == MS_FALSE) {
        switch (priv->tap_state) {
        case TS_MOVE:
        case TS_DRAG:
            moving_state = MS_TOUCHPAD_RELATIVE;
            break;
        case TS_1:
        case TS_3:
        case TS_5:
            moving_state = MS_TOUCHPAD_RELATIVE;
            break;
        default:
            break;
        }
    }

    if (!inside_area || !moving_state || priv->finger_state == FS_BLOCKED ||
        priv->vert_scroll_edge_on || priv->horiz_scroll_edge_on ||
        priv->vert_scroll_twofinger_on || priv->horiz_scroll_twofinger_on ||
        priv->circ_scroll_on || priv->prevFingers != hw->numFingers ||
        (moving_state == MS_TOUCHPAD_RELATIVE && hw->numFingers != 1)) {
        /* reset packet counter. */
        priv->count_packet_finger = 0;
        goto out;
    }

    /* To create the illusion of fluid motion, call back at roughly the report
     * rate, even in the absence of new hardware events; see comment above
     * POLL_MS declaration. */
    delay = MIN(delay, POLL_MS);

    if (priv->count_packet_finger <= 1)
        goto out;               /* skip the lot */

    if (moving_state == MS_TOUCHPAD_RELATIVE)
        get_delta(priv, hw, edge, &dx, &dy);

 out:
    priv->prevFingers = hw->numFingers;

    vlen = vlenpow2(dx/priv->synpara.resolution_horiz,
                    dy/priv->synpara.resolution_vert);

    if (vlen > priv->synpara.maxDeltaMM * priv->synpara.maxDeltaMM) {
        dx = 0;
        dy = 0;
    }

    *dxP = dx;
    *dyP = dy;

    return delay;
}

static double
estimate_delta_circ(SynapticsPrivate * priv)
{
    double a1 = angle(priv, HIST(3).x, HIST(3).y);
    double a2 = angle(priv, HIST(2).x, HIST(2).y);
    double a3 = angle(priv, HIST(1).x, HIST(1).y);
    double a4 = angle(priv, HIST(0).x, HIST(0).y);
    double d1 = diffa(a2, a1);
    double d2 = d1 + diffa(a3, a2);
    double d3 = d2 + diffa(a4, a3);

    return estimate_delta(d3, d2, d1, 0);
}

/* vert and horiz are to know which direction to start coasting
 * circ is true if the user had been circular scrolling.
 */
static void
start_coasting(SynapticsPrivate * priv, struct SynapticsHwState *hw,
               Bool vert, Bool horiz, Bool circ)
{
    SynapticsParameters *para = &priv->synpara;

    priv->scroll.coast_delta_y = 0.0;
    priv->scroll.coast_delta_x = 0.0;

    if ((priv->scroll.packets_this_scroll > 3) && (para->coasting_speed > 0.0)) {
        double pkt_time = HIST_DELTA(0, 3, millis) / 1000.0;

        if (vert && !circ) {
            double dy =
                estimate_delta(HIST(0).y, HIST(1).y, HIST(2).y, HIST(3).y);
            if (pkt_time > 0) {
                double scrolls_per_sec = (dy / abs(para->scroll_dist_vert)) / pkt_time;

                if (fabs(scrolls_per_sec) >= para->coasting_speed) {
                    priv->scroll.coast_speed_y = scrolls_per_sec;
                    priv->scroll.coast_delta_y = (hw->y - priv->scroll.last_y);
                }
            }
        }
        if (horiz && !circ) {
            double dx =
                estimate_delta(HIST(0).x, HIST(1).x, HIST(2).x, HIST(3).x);
            if (pkt_time > 0) {
                double scrolls_per_sec = (dx / abs(para->scroll_dist_vert)) / pkt_time;

                if (fabs(scrolls_per_sec) >= para->coasting_speed) {
                    priv->scroll.coast_speed_x = scrolls_per_sec;
                    priv->scroll.coast_delta_x = (hw->x - priv->scroll.last_x);
                }
            }
        }
        if (circ) {
            double da = estimate_delta_circ(priv);

            if (pkt_time > 0) {
                double scrolls_per_sec = (da / para->scroll_dist_circ) / pkt_time;

                if (fabs(scrolls_per_sec) >= para->coasting_speed) {
                    if (vert) {
                        priv->scroll.coast_speed_y = scrolls_per_sec;
                        priv->scroll.coast_delta_y =
                            diffa(priv->scroll.last_a,
                                  angle(priv, hw->x, hw->y));
                    }
                    else if (horiz) {
                        priv->scroll.coast_speed_x = scrolls_per_sec;
                        priv->scroll.coast_delta_x =
                            diffa(priv->scroll.last_a,
                                  angle(priv, hw->x, hw->y));
                    }
                }
            }
        }
    }
    priv->scroll.packets_this_scroll = 0;
}

static void
stop_coasting(SynapticsPrivate * priv)
{
    priv->scroll.coast_speed_x = 0;
    priv->scroll.coast_speed_y = 0;
    priv->scroll.packets_this_scroll = 0;
}

static int
HandleScrolling(SynapticsPrivate * priv, struct SynapticsHwState *hw,
                enum EdgeType edge, Bool finger)
{
    SynapticsParameters *para = &priv->synpara;
    int delay = 1000000000;

    if (priv->synpara.touchpad_off == TOUCHPAD_TAP_OFF ||
        priv->synpara.touchpad_off == TOUCHPAD_OFF ||
        priv->finger_state == FS_BLOCKED) {
        stop_coasting(priv);
        priv->circ_scroll_on = FALSE;
        priv->vert_scroll_edge_on = FALSE;
        priv->horiz_scroll_edge_on = FALSE;
        priv->vert_scroll_twofinger_on = FALSE;
        priv->horiz_scroll_twofinger_on = FALSE;
        return delay;
    }

    /* scroll detection */
    if (finger && priv->finger_state == FS_UNTOUCHED) {
        stop_coasting(priv);
        priv->scroll.delta_y = 0;
        priv->scroll.delta_x = 0;
        if (para->circular_scrolling) {
            if ((para->circular_trigger == 0 && edge) ||
                (para->circular_trigger == 1 && edge & TOP_EDGE) ||
                (para->circular_trigger == 2 && edge & TOP_EDGE &&
                 edge & RIGHT_EDGE) || (para->circular_trigger == 3 &&
                                        edge & RIGHT_EDGE) ||
                (para->circular_trigger == 4 && edge & RIGHT_EDGE &&
                 edge & BOTTOM_EDGE) || (para->circular_trigger == 5 &&
                                         edge & BOTTOM_EDGE) ||
                (para->circular_trigger == 6 && edge & BOTTOM_EDGE &&
                 edge & LEFT_EDGE) || (para->circular_trigger == 7 &&
                                       edge & LEFT_EDGE) ||
                (para->circular_trigger == 8 && edge & LEFT_EDGE &&
                 edge & TOP_EDGE)) {
                priv->circ_scroll_on = TRUE;
                priv->circ_scroll_vert = TRUE;
                priv->scroll.last_a = angle(priv, hw->x, hw->y);
                DBG(7, "circular scroll detected on edge\n");
            }
        }
    }
    if (!priv->circ_scroll_on) {
        if (finger) {
            if (hw->numFingers == 2) {
                if (!priv->vert_scroll_twofinger_on &&
                    (para->scroll_twofinger_vert) &&
                    (para->scroll_dist_vert != 0)) {
                    stop_coasting(priv);
                    priv->vert_scroll_twofinger_on = TRUE;
                    priv->vert_scroll_edge_on = FALSE;
                    priv->scroll.last_y = hw->y;
                    DBG(7, "vert two-finger scroll detected\n");
                }
                if (!priv->horiz_scroll_twofinger_on &&
                    (para->scroll_twofinger_horiz) &&
                    (para->scroll_dist_horiz != 0)) {
                    stop_coasting(priv);
                    priv->horiz_scroll_twofinger_on = TRUE;
                    priv->horiz_scroll_edge_on = FALSE;
                    priv->scroll.last_x = hw->x;
                    DBG(7, "horiz two-finger scroll detected\n");
                }
            }
        }
        if (finger && priv->finger_state == FS_UNTOUCHED) {
            if (!priv->vert_scroll_twofinger_on &&
                !priv->horiz_scroll_twofinger_on) {
                if ((para->scroll_edge_vert) && (para->scroll_dist_vert != 0) &&
                    (edge & RIGHT_EDGE)) {
                    priv->vert_scroll_edge_on = TRUE;
                    priv->scroll.last_y = hw->y;
                    DBG(7, "vert edge scroll detected on right edge\n");
                }
                if ((para->scroll_edge_horiz) && (para->scroll_dist_horiz != 0)
                    && (edge & BOTTOM_EDGE)) {
                    priv->horiz_scroll_edge_on = TRUE;
                    priv->scroll.last_x = hw->x;
                    DBG(7, "horiz edge scroll detected on bottom edge\n");
                }
            }
        }
    }
    {
        Bool oldv = priv->vert_scroll_twofinger_on || priv->vert_scroll_edge_on
            || (priv->circ_scroll_on && priv->circ_scroll_vert);

        Bool oldh = priv->horiz_scroll_twofinger_on ||
            priv->horiz_scroll_edge_on || (priv->circ_scroll_on &&
                                           !priv->circ_scroll_vert);

        Bool oldc = priv->circ_scroll_on;

        if (priv->circ_scroll_on && !finger) {
            /* circular scroll locks in until finger is raised */
            DBG(7, "cicular scroll off\n");
            priv->circ_scroll_on = FALSE;
        }

        if (!finger || hw->numFingers != 2) {
            if (priv->vert_scroll_twofinger_on) {
                DBG(7, "vert two-finger scroll off\n");
                priv->vert_scroll_twofinger_on = FALSE;
            }
            if (priv->horiz_scroll_twofinger_on) {
                DBG(7, "horiz two-finger scroll off\n");
                priv->horiz_scroll_twofinger_on = FALSE;
            }
        }

        if (priv->vert_scroll_edge_on && (!(edge & RIGHT_EDGE) || !finger)) {
            DBG(7, "vert edge scroll off\n");
            priv->vert_scroll_edge_on = FALSE;
        }
        if (priv->horiz_scroll_edge_on && (!(edge & BOTTOM_EDGE) || !finger)) {
            DBG(7, "horiz edge scroll off\n");
            priv->horiz_scroll_edge_on = FALSE;
        }
        /* If we were corner edge scrolling (coasting),
         * but no longer in corner or raised a finger, then stop coasting. */
        if (para->scroll_edge_corner &&
            (priv->scroll.coast_speed_x || priv->scroll.coast_speed_y)) {
            Bool is_in_corner = ((edge & RIGHT_EDGE) &&
                                 (edge & (TOP_EDGE | BOTTOM_EDGE))) ||
                ((edge & BOTTOM_EDGE) && (edge & (LEFT_EDGE | RIGHT_EDGE)));
            if (!is_in_corner || !finger) {
                DBG(7, "corner edge scroll off\n");
                stop_coasting(priv);
            }
        }
        /* if we were scrolling, but couldn't corner edge scroll,
         * and are no longer scrolling, then start coasting */
        oldv = oldv && !(priv->vert_scroll_twofinger_on ||
                         priv->vert_scroll_edge_on || (priv->circ_scroll_on &&
                                                       priv->circ_scroll_vert));

        oldh = oldh && !(priv->horiz_scroll_twofinger_on ||
                         priv->horiz_scroll_edge_on || (priv->circ_scroll_on &&
                                                        !priv->
                                                        circ_scroll_vert));

        oldc = oldc && !priv->circ_scroll_on;

        if ((oldv || oldh) && !para->scroll_edge_corner) {
            start_coasting(priv, hw, oldv, oldh, oldc);
        }
    }

    /* if hitting a corner (top right or bottom right) while vertical
     * scrolling is active, consider starting corner edge scrolling or
     * switching over to circular scrolling smoothly */
    if (priv->vert_scroll_edge_on && !priv->horiz_scroll_edge_on &&
        (edge & RIGHT_EDGE) && (edge & (TOP_EDGE | BOTTOM_EDGE))) {
        if (para->scroll_edge_corner) {
            if (priv->scroll.coast_speed_y == 0) {
                /* FYI: We can generate multiple start_coasting requests if
                 * we're in the corner, but we were moving so slowly when we
                 * got here that we didn't actually start coasting. */
                DBG(7, "corner edge scroll on\n");
                start_coasting(priv, hw, TRUE, FALSE, FALSE);
            }
        }
        else if (para->circular_scrolling) {
            priv->vert_scroll_edge_on = FALSE;
            priv->circ_scroll_on = TRUE;
            priv->circ_scroll_vert = TRUE;
            priv->scroll.last_a = angle(priv, hw->x, hw->y);
            DBG(7, "switching to circular scrolling\n");
        }
    }
    /* Same treatment for horizontal scrolling */
    if (priv->horiz_scroll_edge_on && !priv->vert_scroll_edge_on &&
        (edge & BOTTOM_EDGE) && (edge & (LEFT_EDGE | RIGHT_EDGE))) {
        if (para->scroll_edge_corner) {
            if (priv->scroll.coast_speed_x == 0) {
                /* FYI: We can generate multiple start_coasting requests if
                 * we're in the corner, but we were moving so slowly when we
                 * got here that we didn't actually start coasting. */
                DBG(7, "corner edge scroll on\n");
                start_coasting(priv, hw, FALSE, TRUE, FALSE);
            }
        }
        else if (para->circular_scrolling) {
            priv->horiz_scroll_edge_on = FALSE;
            priv->circ_scroll_on = TRUE;
            priv->circ_scroll_vert = FALSE;
            priv->scroll.last_a = angle(priv, hw->x, hw->y);
            DBG(7, "switching to circular scrolling\n");
        }
    }

    if (priv->vert_scroll_edge_on || priv->horiz_scroll_edge_on ||
        priv->vert_scroll_twofinger_on || priv->horiz_scroll_twofinger_on ||
        priv->circ_scroll_on) {
        priv->scroll.packets_this_scroll++;
    }

    if (priv->vert_scroll_edge_on || priv->vert_scroll_twofinger_on) {
        /* + = down, - = up */
        if (para->scroll_dist_vert != 0 && hw->y != priv->scroll.last_y) {
            priv->scroll.delta_y += (hw->y - priv->scroll.last_y);
            priv->scroll.last_y = hw->y;
        }
    }
    if (priv->horiz_scroll_edge_on || priv->horiz_scroll_twofinger_on) {
        /* + = right, - = left */
        if (para->scroll_dist_horiz != 0 && hw->x != priv->scroll.last_x) {
            priv->scroll.delta_x += (hw->x - priv->scroll.last_x);
            priv->scroll.last_x = hw->x;
        }
    }
    if (priv->circ_scroll_on) {
        /* + = counter clockwise, - = clockwise */
        double delta = para->scroll_dist_circ;
        double diff = diffa(priv->scroll.last_a, angle(priv, hw->x, hw->y));

        if (delta >= 0.005 && diff != 0.0) {
            if (priv->circ_scroll_vert)
                priv->scroll.delta_y -= diff / delta * para->scroll_dist_vert;
            else
                priv->scroll.delta_x -= diff / delta * para->scroll_dist_horiz;
            priv->scroll.last_a = angle(priv, hw->x, hw->y);
        }
    }

    if (priv->scroll.coast_speed_y) {
        double dtime = (hw->millis - priv->scroll.last_millis) / 1000.0;
        double ddy = para->coasting_friction * dtime;

        priv->scroll.delta_y += priv->scroll.coast_speed_y * dtime * abs(para->scroll_dist_vert);
        delay = MIN(delay, POLL_MS);
        if (abs(priv->scroll.coast_speed_y) < ddy) {
            priv->scroll.coast_speed_y = 0;
            priv->scroll.packets_this_scroll = 0;
        }
        else {
            priv->scroll.coast_speed_y +=
                (priv->scroll.coast_speed_y < 0 ? ddy : -ddy);
        }
    }

    if (priv->scroll.coast_speed_x) {
        double dtime = (hw->millis - priv->scroll.last_millis) / 1000.0;
        double ddx = para->coasting_friction * dtime;
        priv->scroll.delta_x += priv->scroll.coast_speed_x * dtime * abs(para->scroll_dist_horiz);
        delay = MIN(delay, POLL_MS);
        if (abs(priv->scroll.coast_speed_x) < ddx) {
            priv->scroll.coast_speed_x = 0;
            priv->scroll.packets_this_scroll = 0;
        }
        else {
            priv->scroll.coast_speed_x +=
                (priv->scroll.coast_speed_x < 0 ? ddx : -ddx);
        }
    }

    return delay;
}

/**
 * Check if any 2+ fingers are close enough together to assume this is a
 * ClickFinger action.
 */
static int
clickpad_guess_clickfingers(SynapticsPrivate * priv,
                            struct SynapticsHwState *hw)
{
    int nfingers = 0;
    uint32_t close_point = 0; /* 1 bit for each point close to another one */
    int i, j;

    BUG_RETURN_VAL(hw->num_mt_mask > sizeof(close_point) * 8, 0);

    for (i = 0; i < hw->num_mt_mask - 1; i++) {
        ValuatorMask *f1;

        if (hw->slot_state[i] == SLOTSTATE_EMPTY ||
            hw->slot_state[i] == SLOTSTATE_CLOSE)
            continue;

        f1 = hw->mt_mask[i];

        for (j = i + 1; j < hw->num_mt_mask; j++) {
            ValuatorMask *f2;
            double x1, x2, y1, y2;

            if (hw->slot_state[j] == SLOTSTATE_EMPTY ||
                hw->slot_state[j] == SLOTSTATE_CLOSE)
                continue;

            f2 = hw->mt_mask[j];

            x1 = valuator_mask_get_double(f1, 0);
            y1 = valuator_mask_get_double(f1, 1);

            x2 = valuator_mask_get_double(f2, 0);
            y2 = valuator_mask_get_double(f2, 1);

            /* FIXME: fingers closer together than 30% of touchpad width, but
             * really, this should be dependent on the touchpad size. Also,
             * you'll need to find a touchpad that doesn't lie about it's
             * size. Good luck. */
            if (abs(x1 - x2) < (priv->maxx - priv->minx) * .3 &&
                abs(y1 - y2) < (priv->maxy - priv->miny) * .3) {
                close_point |= (1 << j);
                close_point |= (1 << i);
            }
        }
    }

    while (close_point > 0) {
        nfingers += close_point & 0x1;
        close_point >>= 1;
    }

    /* Some trackpads touchpad only track two touchpoints but announce
     * BTN_TOOL_TRIPLETAP (which sets hw->numFingers to 3), when this happens
     * the user likely intents to do a 3 finger click, so handle it as such.
     */
    if (hw->numFingers >= 3 && hw->num_mt_mask < 3)
        nfingers = 3;

    return nfingers;
}

static void
handle_clickfinger(SynapticsPrivate * priv, struct SynapticsHwState *hw)
{
    SynapticsParameters *para = &priv->synpara;
    int action = 0;
    int nfingers = hw->numFingers;

    /* if this is a clickpad, clickfinger handling is:
     * one finger down: no action, this is a normal click
     * two fingers down: F2_CLICK
     * three fingers down: F3_CLICK
     */

    if (para->clickpad)
        nfingers = clickpad_guess_clickfingers(priv, hw);

    switch (nfingers) {
    case 1:
        action = para->click_action[F1_CLICK1];
        break;
    case 2:
        action = para->click_action[F2_CLICK1];
        break;
    case 3:
        action = para->click_action[F3_CLICK1];
        break;
    }
    switch (action) {
    case 1:
        hw->left = 1 | BTN_EMULATED_FLAG;
        break;
    case 2:
        hw->left = 0;
        hw->middle = 1 | BTN_EMULATED_FLAG;
        break;
    case 3:
        hw->left = 0;
        hw->right = 1 | BTN_EMULATED_FLAG;
        break;
    }
}

/* Adjust the hardware state according to the extra buttons (if the touchpad
 * has any and not many touchpads do these days). These buttons are up/down
 * tilt buttons and/or left/right buttons that then map into a specific
 * function (or scrolling into).
 */
static Bool
adjust_state_from_scrollbuttons(const InputInfoPtr pInfo,
                                struct SynapticsHwState *hw)
{
    SynapticsPrivate *priv = (SynapticsPrivate *) (pInfo->private);
    SynapticsParameters *para = &priv->synpara;
    Bool double_click = FALSE;

    if (!para->updown_button_scrolling) {
        if (hw->down) {         /* map down button to middle button */
            hw->middle = TRUE;
        }

        if (hw->up) {           /* up button generates double click */
            if (!priv->prev_up)
                double_click = TRUE;
        }
        priv->prev_up = hw->up;

        /* reset up/down button events */
        hw->up = hw->down = FALSE;
    }

    /* Left/right button scrolling, or middle clicks */
    if (!para->leftright_button_scrolling) {
        if (hw->multi[2] || hw->multi[3])
            hw->middle = TRUE;

        /* reset left/right button events */
        hw->multi[2] = hw->multi[3] = FALSE;
    }

    return double_click;
}

static void
update_hw_button_state(const InputInfoPtr pInfo, struct SynapticsHwState *hw,
                       CARD32 now, int *delay)
{
    SynapticsPrivate *priv = (SynapticsPrivate *) (pInfo->private);
    SynapticsParameters *para = &priv->synpara;

    /* Treat the first two multi buttons as up/down for now. */
    hw->up |= hw->multi[0];
    hw->down |= hw->multi[1];

    /* 3rd button emulation */
    hw->middle |= HandleMidButtonEmulation(priv, hw, now, delay);

    /* If this is a clickpad and the user clicks in a soft button area, press
     * the soft button instead. */
    if (para->clickpad) {
        /* hw->left is down, but no other buttons were already down */
        if (!(priv->lastButtons & 7) && hw->left && !hw->right && !hw->middle) {
            /* If the finger down event is delayed, the x and y
             * coordinates are stale so we delay processing the click */
            if (hw->z < para->finger_low) {
                hw->left = 0;
                goto out;
            }
            if (is_inside_rightbutton_area(para, hw->x, hw->y)) {
                hw->left = 0;
                hw->right = 1;
            }
            else if (is_inside_sec_rightbutton_area(para, hw->x, hw->y)) {
                hw->left = 0;
                hw->right = 1;
            }
            else if (is_inside_middlebutton_area(para, hw->x, hw->y)) {
                hw->left = 0;
                hw->middle = 1;
            }
            else if (is_inside_sec_middlebutton_area(para, hw->x, hw->y)) {
                hw->left = 0;
                hw->middle = 1;
            }
            priv->clickpad_click_millis = now;
        }
        else if (hw->left) {
            hw->left   = (priv->lastButtons & 1) ? 1 : 0;
            hw->middle = (priv->lastButtons & 2) ? 1 : 0;
            hw->right  = (priv->lastButtons & 4) ? 1 : 0;
        }
    }

    /* Fingers emulate other buttons. ClickFinger can only be
       triggered on transition, when left is pressed
     */
    if (hw->left && !(priv->lastButtons & 7) && hw->numFingers >= 1)
        handle_clickfinger(priv, hw);

out:
    /* Two finger emulation */
    if (hw->numFingers == 1 && hw->z >= para->emulate_twofinger_z &&
        hw->fingerWidth >= para->emulate_twofinger_w) {
        hw->numFingers = 2;
    }
}

static void
post_button_click(const InputInfoPtr pInfo, const int button)
{
    xf86PostButtonEvent(pInfo->dev, FALSE, button, TRUE, 0, 0);
    xf86PostButtonEvent(pInfo->dev, FALSE, button, FALSE, 0, 0);
}

static void
post_scroll_events(const InputInfoPtr pInfo)
{
    SynapticsPrivate *priv = (SynapticsPrivate *) (pInfo->private);

    valuator_mask_zero(priv->scroll_events_mask);

    if (priv->scroll.delta_y != 0.0) {
        valuator_mask_set_double(priv->scroll_events_mask,
                                 priv->scroll_axis_vert, priv->scroll.delta_y);
        priv->scroll.delta_y = 0;
    }
    if (priv->scroll.delta_x != 0.0) {
        valuator_mask_set_double(priv->scroll_events_mask,
                                 priv->scroll_axis_horiz, priv->scroll.delta_x);
        priv->scroll.delta_x = 0;
    }
    if (valuator_mask_num_valuators(priv->scroll_events_mask))
        xf86PostMotionEventM(pInfo->dev, FALSE, priv->scroll_events_mask);
}

static inline int
repeat_scrollbuttons(const InputInfoPtr pInfo,
                     const struct SynapticsHwState *hw,
                     int buttons, CARD32 now, int delay)
{
    SynapticsPrivate *priv = (SynapticsPrivate *) (pInfo->private);
    SynapticsParameters *para = &priv->synpara;
    int repeat_delay, timeleft;
    int rep_buttons = 0;

    if (para->updown_button_repeat)
        rep_buttons |= (1 << (4 - 1)) | (1 << (5 - 1));
    if (para->leftright_button_repeat)
        rep_buttons |= (1 << (6 - 1)) | (1 << (7 - 1));

    /* Handle auto repeat buttons */
    repeat_delay = clamp(para->scroll_button_repeat, SBR_MIN, SBR_MAX);
    if (((hw->up || hw->down) && para->updown_button_repeat &&
         para->updown_button_scrolling) ||
        ((hw->multi[2] || hw->multi[3]) && para->leftright_button_repeat &&
         para->leftright_button_scrolling)) {
        priv->repeatButtons = buttons & rep_buttons;
        if (!priv->nextRepeat) {
            priv->nextRepeat = now + repeat_delay * 2;
        }
    }
    else {
        priv->repeatButtons = 0;
        priv->nextRepeat = 0;
    }

    if (priv->repeatButtons) {
        timeleft = TIME_DIFF(priv->nextRepeat, now);
        if (timeleft > 0)
            delay = MIN(delay, timeleft);
        if (timeleft <= 0) {
            int change, id;

            change = priv->repeatButtons;
            while (change) {
                id = ffs(change);
                change &= ~(1 << (id - 1));
                if (id == 4)
                    priv->scroll.delta_y -= para->scroll_dist_vert;
                else if (id == 5)
                    priv->scroll.delta_y += para->scroll_dist_vert;
                else if (id == 6)
                    priv->scroll.delta_x -= para->scroll_dist_horiz;
                else if (id == 7)
                    priv->scroll.delta_x += para->scroll_dist_horiz;
            }

            priv->nextRepeat = now + repeat_delay;
            delay = MIN(delay, repeat_delay);
        }
    }

    return delay;
}

/* Update the open slots and number of active touches */
static void
UpdateTouchState(InputInfoPtr pInfo, struct SynapticsHwState *hw)
{
    SynapticsPrivate *priv = (SynapticsPrivate *) pInfo->private;
    int i;

    for (i = 0; i < hw->num_mt_mask; i++) {
        if (hw->slot_state[i] == SLOTSTATE_OPEN) {
            priv->open_slots[priv->num_active_touches] = i;
            priv->num_active_touches++;
            BUG_WARN(priv->num_active_touches > priv->num_slots);
        }
        else if (hw->slot_state[i] == SLOTSTATE_CLOSE) {
            Bool found = FALSE;
            int j;

            for (j = 0; j < priv->num_active_touches - 1; j++) {
                if (priv->open_slots[j] == i)
                    found = TRUE;

                if (found)
                    priv->open_slots[j] = priv->open_slots[j + 1];
            }

            BUG_WARN(priv->num_active_touches == 0);
            if (priv->num_active_touches > 0)
                priv->num_active_touches--;
        }
    }

    SynapticsResetTouchHwState(hw, FALSE);
}

static void
HandleTouches(InputInfoPtr pInfo, struct SynapticsHwState *hw)
{
    SynapticsPrivate *priv = (SynapticsPrivate *) pInfo->private;
    int new_active_touches = priv->num_active_touches;
    int i;

    /* Count new number of active touches */
    for (i = 0; i < hw->num_mt_mask; i++) {
        if (hw->slot_state[i] == SLOTSTATE_OPEN)
            new_active_touches++;
        else if (hw->slot_state[i] == SLOTSTATE_CLOSE)
            new_active_touches--;
    }

    UpdateTouchState(pInfo, hw);
}

static void
filter_jitter(SynapticsPrivate * priv, int *x, int *y)
{
    SynapticsParameters *para = &priv->synpara;

    priv->hyst_center_x = hysteresis(*x, priv->hyst_center_x, para->hyst_x);
    priv->hyst_center_y = hysteresis(*y, priv->hyst_center_y, para->hyst_y);
    *x = priv->hyst_center_x;
    *y = priv->hyst_center_y;
}

static void
reset_hw_state(struct SynapticsHwState *hw)
{
    hw->x = 0;
    hw->y = 0;
    hw->z = 0;
    hw->numFingers = 0;
    hw->fingerWidth = 0;
}

/*
 * React on changes in the hardware state. This function is called every time
 * the hardware state changes. The return value is used to specify how many
 * milliseconds to wait before calling the function again if no state change
 * occurs.
 *
 * from_timer denotes if HandleState was triggered from a timer (e.g. to
 * generate fake motion events, or for the tap-to-click state machine), rather
 * than from having received a motion event.
 */
static int
HandleState(InputInfoPtr pInfo, struct SynapticsHwState *hw, CARD32 now,
            Bool from_timer)
{
    SynapticsPrivate *priv = (SynapticsPrivate *) (pInfo->private);
    SynapticsParameters *para = &priv->synpara;
    enum FingerState finger = FS_UNTOUCHED;
    int dx = 0, dy = 0, buttons, id;
    enum EdgeType edge = NO_EDGE;
    int change;
    int double_click = FALSE;
    int delay = 1000000000;
    int timeleft;
    Bool inside_active_area;
    Bool using_cumulative_coords = FALSE;
    Bool ignore_motion;

    /* We need both and x/y, the driver can't handle just one of the two
     * yet. But since it's possible to hit a phys button on non-clickpads
     * without ever getting motion data first, we must continue with 0/0 for
     * that case. */
    if (hw->x == INT_MIN || hw->y == INT_MAX) {
        if (para->clickpad)
            return delay;
        else if (hw->left || hw->right || hw->middle) {
            hw->x = (hw->x == INT_MIN) ? 0 : hw->x;
            hw->y = (hw->y == INT_MIN) ? 0 : hw->y;
        }
    }

    /* If a physical button is pressed on a clickpad or a two-finger scrolling
     * is ongoing, use cumulative relative touch movements for motion */
    if (para->clickpad &&
        ((priv->lastButtons & 7) ||
        (priv->vert_scroll_twofinger_on || priv->horiz_scroll_twofinger_on)) &&
        priv->last_button_area != TOP_BUTTON_AREA) {
        hw->x = hw->cumulative_dx;
        hw->y = hw->cumulative_dy;
        using_cumulative_coords = TRUE;
    }

    /* apply hysteresis before doing anything serious. This cancels
     * out a lot of noise which might surface in strange phenomena
     * like flicker in scrolling or noise motion. */
    filter_jitter(priv, &hw->x, &hw->y);

    inside_active_area = is_inside_active_area(priv, hw->x, hw->y);

    /* Ignore motion *starting* inside softbuttonareas */
    if (priv->finger_state < FS_TOUCHED)
        priv->last_button_area = current_button_area(para, hw->x, hw->y);
    /* If we already have a finger down, clear last_button_area if it goes
       outside of the softbuttonareas */
    else if (priv->last_button_area != NO_BUTTON_AREA &&
             current_button_area(para, hw->x, hw->y) == NO_BUTTON_AREA)
        priv->last_button_area = NO_BUTTON_AREA;

    ignore_motion = para->touchpad_off == TOUCHPAD_OFF ||
        (!using_cumulative_coords && priv->last_button_area != NO_BUTTON_AREA);

    /* these two just update hw->left, right, etc. */
    update_hw_button_state(pInfo, hw, now, &delay);
    if (priv->has_scrollbuttons)
        double_click = adjust_state_from_scrollbuttons(pInfo, hw);

    /* Ignore motion the first X ms after a clickpad click */
    if (priv->clickpad_click_millis) {
        if(TIME_DIFF(priv->clickpad_click_millis +
                     para->clickpad_ignore_motion_time, now) > 0)
            ignore_motion = TRUE;
        else
            priv->clickpad_click_millis = 0;
    }

    /* now we know that these _coordinates_ aren't in the area.
       invalid are: x, y, z, numFingers, fingerWidth
       valid are: millis, left/right/middle/up/down/etc.
     */
    if (!inside_active_area)
        reset_hw_state(hw);

    /* no edge or finger detection outside of area */
    if (inside_active_area) {
        edge = edge_detection(priv, hw->x, hw->y);
        if (!from_timer)
            finger = SynapticsDetectFinger(priv, hw);
        else
            finger = priv->finger_state;
    }

    /* tap and drag detection. Needs to be performed even if the finger is in
     * the dead area to reset the state. */
    timeleft = HandleTapProcessing(priv, hw, now, finger, inside_active_area);
    if (timeleft > 0)
        delay = MIN(delay, timeleft);

    if (inside_active_area) {
        /* Don't bother about scrolling in the dead area of the touchpad. */
        timeleft = HandleScrolling(priv, hw, edge, (finger >= FS_TOUCHED));
        if (timeleft > 0)
            delay = MIN(delay, timeleft);

        /*
         * Compensate for unequal x/y resolution. This needs to be done after
         * calculations that require unadjusted coordinates, for example edge
         * detection.
         */
#ifndef NO_DRIVER_SCALING
        ScaleCoordinates(priv, hw);
#endif
    }

    dx = dy = 0;

    timeleft = ComputeDeltas(priv, hw, edge, &dx, &dy, inside_active_area);
    delay = MIN(delay, timeleft);

    buttons = ((hw->left ? 0x01 : 0) |
               (hw->middle ? 0x02 : 0) |
               (hw->right ? 0x04 : 0) |
               (hw->up ? 0x08 : 0) |
               (hw->down ? 0x10 : 0) |
               (hw->multi[2] ? 0x20 : 0) | (hw->multi[3] ? 0x40 : 0));

    if (priv->tap_button > 0 && priv->tap_button_state == TBS_BUTTON_DOWN)
        buttons |= 1 << (priv->tap_button - 1);

    /* Post events */
    if (finger >= FS_TOUCHED && (dx || dy) && !ignore_motion)
        xf86PostMotionEvent(pInfo->dev, 0, 0, 2, dx, dy);

    if (priv->mid_emu_state == MBE_LEFT_CLICK) {
        post_button_click(pInfo, 1);
        priv->mid_emu_state = MBE_OFF;
    }
    else if (priv->mid_emu_state == MBE_RIGHT_CLICK) {
        post_button_click(pInfo, 3);
        priv->mid_emu_state = MBE_OFF;
    }

    change = buttons ^ priv->lastButtons;
    while (change) {
        id = ffs(change);       /* number of first set bit 1..32 is returned */
        change &= ~(1 << (id - 1));
        xf86PostButtonEvent(pInfo->dev, FALSE, id, (buttons & (1 << (id - 1))),
                            0, 0);
    }

    if (priv->has_scrollbuttons)
        delay = repeat_scrollbuttons(pInfo, hw, buttons, now, delay);

    /* Process scroll events only if coordinates are
     * in the Synaptics Area
     */
    if (inside_active_area &&
        (priv->scroll.delta_x != 0.0 || priv->scroll.delta_y != 0.0)) {
        post_scroll_events(pInfo);
        priv->scroll.last_millis = hw->millis;
    }

    if (double_click) {
        post_button_click(pInfo, 1);
        post_button_click(pInfo, 1);
    }

    HandleTouches(pInfo, hw);

    /* Save old values of some state variables */
    priv->finger_state = finger;
    priv->lastButtons = buttons;

    /* generate a history of the absolute positions */
    if (inside_active_area)
        store_history(priv, hw->x, hw->y, hw->millis);

    return delay;
}

static int
ControlProc(InputInfoPtr pInfo, xDeviceCtl * control)
{
    DBG(3, "Control Proc called\n");
    return Success;
}

static int
SwitchMode(ClientPtr client, DeviceIntPtr dev, int mode)
{
    DBG(3, "SwitchMode called\n");

    return XI_BadMode;
}

static void
ReadDevDimensions(InputInfoPtr pInfo)
{
    SynapticsPrivate *priv = (SynapticsPrivate *) pInfo->private;

    if (priv->proto_ops->ReadDevDimensions)
        priv->proto_ops->ReadDevDimensions(pInfo);

    SanitizeDimensions(pInfo);
}

static Bool
QueryHardware(InputInfoPtr pInfo)
{
    SynapticsPrivate *priv = (SynapticsPrivate *) pInfo->private;

    priv->comm.protoBufTail = 0;

    if (!priv->proto_ops->QueryHardware(pInfo)) {
        xf86IDrvMsg(pInfo, X_PROBED, "no supported touchpad found\n");
        if (priv->proto_ops->DeviceOffHook)
            priv->proto_ops->DeviceOffHook(pInfo);
        return FALSE;
    }

    return TRUE;
}

#ifndef NO_DRIVER_SCALING
static void
ScaleCoordinates(SynapticsPrivate * priv, struct SynapticsHwState *hw)
{
    int xCenter = (priv->synpara.left_edge + priv->synpara.right_edge) / 2;
    int yCenter = (priv->synpara.top_edge + priv->synpara.bottom_edge) / 2;

    hw->x = (hw->x - xCenter) * priv->horiz_coeff + xCenter;
    hw->y = (hw->y - yCenter) * priv->vert_coeff + yCenter;
}

void
CalculateScalingCoeffs(SynapticsPrivate * priv)
{
    int vertRes = priv->synpara.resolution_vert;
    int horizRes = priv->synpara.resolution_horiz;

    if ((horizRes > vertRes) && (horizRes > 0)) {
        priv->horiz_coeff = vertRes / (double) horizRes;
        priv->vert_coeff = 1;
    }
    else if ((horizRes < vertRes) && (vertRes > 0)) {
        priv->horiz_coeff = 1;
        priv->vert_coeff = horizRes / (double) vertRes;
    }
    else {
        priv->horiz_coeff = 1;
        priv->vert_coeff = 1;
    }
}
#endif
@


1.12
log
@Update to xf86-input-synaptics 1.8.3.

ok matthieu@@
@
text
@d501 1
a501 1
            if (end_str && *end_str == '%') {
d677 1
a677 1
    pars->tap_time_2 = xf86SetIntOption(opts, "MaxDoubleTapTime", 100);
d786 17
a1195 1
    int i;
d1197 5
a1201 38
    if (priv->has_touch) {
        priv->num_slots =
            priv->max_touches ? priv->max_touches : SYNAPTICS_MAX_TOUCHES;

        priv->open_slots = malloc(priv->num_slots * sizeof(int));
        if (!priv->open_slots) {
            xf86IDrvMsg(pInfo, X_ERROR,
                        "failed to allocate open touch slots array\n");
            priv->has_touch = 0;
            priv->num_slots = 0;
            return;
        }

        /* x/y + whatever other MT axes we found */
        if (!InitTouchClassDeviceStruct(dev, priv->max_touches,
                                        XIDependentTouch,
                                        2 + priv->num_mt_axes)) {
            xf86IDrvMsg(pInfo, X_ERROR,
                        "failed to initialize touch class device\n");
            priv->has_touch = 0;
            priv->num_slots = 0;
            free(priv->open_slots);
            priv->open_slots = NULL;
            return;
        }

        for (i = 0; i < priv->num_mt_axes; i++) {
            SynapticsTouchAxisRec *axis = &priv->touch_axes[i];
            int axnum = 4 + i;  /* Skip x, y, and scroll axes */

            if (!xf86InitValuatorAxisStruct(dev, axnum, axes_labels[axnum],
                                            axis->min, axis->max, axis->res, 0,
                                            axis->res, Absolute)) {
                xf86IDrvMsg(pInfo, X_WARNING,
                            "failed to initialize axis %s, skipping\n",
                            axis->label);
                continue;
            }
d1203 6
a1208 2
            xf86InitValuatorDefaults(dev, axnum);
        }
d1607 5
a1611 3
    int sigstate;

    sigstate = xf86BlockSIGIO();
d1621 1
d1623 3
d1811 3
a2203 3
    double integral;
    double tmpf;

d2206 1
d2208 5
a2212 16
    /* report edge speed as synthetic motion. Of course, it would be
     * cooler to report floats than to buffer, but anyway. */

    /* FIXME: When these values go NaN, bad things happen. Root cause is unknown
     * thus far though. */
    if (isnan(priv->frac_x))
        priv->frac_x = 0;
    if (isnan(priv->frac_y))
        priv->frac_y = 0;

    tmpf = *dx + priv->frac_x;
    priv->frac_x = modf(tmpf, &integral);
    *dx = integral;
    tmpf = *dy + priv->frac_y;
    priv->frac_y = modf(tmpf, &integral);
    *dy = integral;
d2224 1
d2270 8
a2970 1
    SynapticsParameters *para = &priv->synpara;
a2971 2
    int min_touches = 2;
    Bool restart_touches = FALSE;
a2973 6
    if (para->click_action[F3_CLICK1] || para->tap_action[F3_TAP])
        min_touches = 4;
    else if (para->click_action[F2_CLICK1] || para->tap_action[F2_TAP] ||
             para->scroll_twofinger_vert || para->scroll_twofinger_horiz)
        min_touches = 3;

a2981 54
    if (priv->has_semi_mt)
        goto out;

    if (priv->num_active_touches < min_touches &&
        new_active_touches < min_touches) {
        /* We stayed below number of touches needed to send events */
        goto out;
    }
    else if (priv->num_active_touches >= min_touches &&
             new_active_touches < min_touches) {
        /* We are transitioning to less than the number of touches needed to
         * send events. End all currently open touches. */
        for (i = 0; i < priv->num_active_touches; i++) {
            int slot = priv->open_slots[i];

            xf86PostTouchEvent(pInfo->dev, slot, XI_TouchEnd, 0,
                               hw->mt_mask[slot]);
        }

        /* Don't send any more events */
        goto out;
    }
    else if (priv->num_active_touches < min_touches &&
             new_active_touches >= min_touches) {
        /* We are transitioning to more than the number of touches needed to
         * send events. Begin all already open touches. */
        restart_touches = TRUE;
        for (i = 0; i < priv->num_active_touches; i++) {
            int slot = priv->open_slots[i];

            xf86PostTouchEvent(pInfo->dev, slot, XI_TouchBegin, 0,
                               hw->mt_mask[slot]);
        }
    }

    /* Send touch begin events for all new touches */
    for (i = 0; i < hw->num_mt_mask; i++)
        if (hw->slot_state[i] == SLOTSTATE_OPEN)
            xf86PostTouchEvent(pInfo->dev, i, XI_TouchBegin, 0, hw->mt_mask[i]);

    /* Send touch update/end events for all the rest */
    for (i = 0; i < priv->num_active_touches; i++) {
        int slot = priv->open_slots[i];

        /* Don't send update event if we just reopened the touch above */
        if (hw->slot_state[slot] == SLOTSTATE_UPDATE && !restart_touches)
            xf86PostTouchEvent(pInfo->dev, slot, XI_TouchUpdate, 0,
                               hw->mt_mask[slot]);
        else if (hw->slot_state[slot] == SLOTSTATE_CLOSE)
            xf86PostTouchEvent(pInfo->dev, slot, XI_TouchEnd, 0,
                               hw->mt_mask[slot]);
    }

 out:
@


1.11
log
@Update to xf86-input-synaptics 1.8.2.

ok matthieu@@
@
text
@d3117 5
a3121 3
    /* If a physical button is pressed on a clickpad, use cumulative relative
     * touch movements for motion */
    if (para->clickpad && (priv->lastButtons & 7) &&
@


1.10
log
@Update to xf86-input-synaptics 1.8.1.

ok matthieu@@
@
text
@d677 1
a677 1
    pars->tap_time_2 = xf86SetIntOption(opts, "MaxDoubleTapTime", 180);
d2052 1
a2052 1
        if (touch) {
d2054 2
a2055 5
        }
        else if (is_timeout) {
            SetTapState(priv, TS_START, now);
            priv->tap_button_state = TBS_BUTTON_DOWN_UP;
        }
d3209 2
a3210 14
    if (priv->tap_button > 0) {
        int tap_mask = 1 << (priv->tap_button - 1);

        if (priv->tap_button_state == TBS_BUTTON_DOWN_UP) {
            if (tap_mask != (priv->lastButtons & tap_mask)) {
                xf86PostButtonEvent(pInfo->dev, FALSE, priv->tap_button, TRUE,
                                    0, 0);
                priv->lastButtons |= tap_mask;
            }
            priv->tap_button_state = TBS_BUTTON_UP;
        }
        if (priv->tap_button_state == TBS_BUTTON_DOWN)
            buttons |= tap_mask;
    }
@


1.9
log
@Update to xf86-input-synaptics 1.8.0.

ok matthieu@@, tested claudio@@
@
text
@d775 10
d1042 2
d1073 3
a1075 1
    memset(priv->open_slots, 0, priv->num_slots * sizeof(int));
d1372 2
d1982 3
a1984 2
            ((abs(hw->x - priv->touch_on.x) >= para->tap_move) ||
             (abs(hw->y - priv->touch_on.y) >= para->tap_move)));
@


1.8
log
@Update to xf86-input-synaptics 1.7.5.

ok matthieu@@
@
text
@d174 4
d209 9
d471 1
a471 1
set_softbutton_areas_option(InputInfoPtr pInfo)
d486 1
a486 1
    option_string = xf86SetStrOption(pInfo->options, "SoftButtonAreas", NULL);
d531 2
a532 2
    memcpy(pars->softbutton_areas[0], values, 4 * sizeof(int));
    memcpy(pars->softbutton_areas[1], values + 4, 4 * sizeof(int));
d540 2
a541 2
                "invalid SoftButtonAreas value '%s', keeping defaults\n",
                option_string);
d546 12
d582 2
d680 5
d759 10
a768 1
    pars->grab_event_device = xf86SetBoolOption(opts, "GrabEventDevice", TRUE);
d786 3
a788 1
    set_softbutton_areas_option(pInfo);
d912 3
a914 6
    if (pInfo->fd != -1) {
        if (priv->comm.buffer) {
            XisbFree(priv->comm.buffer);
            priv->comm.buffer = NULL;
        }
        xf86CloseSerial(pInfo->fd);
d916 1
a916 1
    pInfo->fd = -1;
d921 1
a921 4
    if (pInfo->fd >= 0) {
        xf86CloseSerial(pInfo->fd);
        pInfo->fd = -1;
    }
d1002 2
a1003 4
        !priv->proto_ops->DeviceOnHook(pInfo, &priv->synpara)) {
        xf86CloseSerial(pInfo->fd);
        return !Success;
    }
d1006 2
a1007 5
    if (!priv->comm.buffer) {
        xf86CloseSerial(pInfo->fd);
        pInfo->fd = -1;
        return !Success;
    }
d1012 2
a1013 7
    if (!QueryHardware(pInfo)) {
        XisbFree(priv->comm.buffer);
        priv->comm.buffer = NULL;
        xf86CloseSerial(pInfo->fd);
        pInfo->fd = -1;
        return !Success;
    }
d1019 8
a1033 1
    SynapticsResetHwState(priv->old_hw_state);
d1043 2
d1085 1
a1085 2
        xf86CloseSerial(pInfo->fd);
        pInfo->fd = -1;
a1103 1
    SynapticsHwStateFree(&priv->old_hw_state);
a1348 4
    priv->old_hw_state = SynapticsHwStateAlloc(priv);
    if (!priv->old_hw_state)
        goto fail;

d1472 5
a1497 7
    enum {
        LEFT = 0,
        RIGHT = 1,
        TOP = 2,
        BOTTOM = 3
    };

d1523 1
a1523 1
    return is_inside_button_area(para, 0, x, y);
d1529 66
a1594 1
    return is_inside_button_area(para, 1, x, y);
d1956 2
a1957 1
    if (priv->finger_state == FS_BLOCKED)
a2193 1
    double dtime = (hw->millis - HIST(0).millis) / 1000.0;
a2195 2
    int x_edge_speed = 0;
    int y_edge_speed = 0;
d2210 1
a2210 1
    tmpf = *dx + x_edge_speed * dtime + priv->frac_x;
d2213 1
a2213 1
    tmpf = *dy + y_edge_speed * dtime + priv->frac_y;
d2372 3
a2374 1
    if ((priv->synpara.touchpad_off == TOUCHPAD_TAP_OFF) || (priv->finger_state == FS_BLOCKED)) {
d2683 7
d2777 1
a2777 1
                       struct SynapticsHwState *old, CARD32 now, int *delay)
d2793 24
a2816 10
        if (!old->left && !old->right && !old->middle &&
            hw->left && !hw->right && !hw->middle) {
                if (is_inside_rightbutton_area(para, hw->x, hw->y)) {
                    hw->left = 0;
                    hw->right = 1;
                }
                else if (is_inside_middlebutton_area(para, hw->x, hw->y)) {
                    hw->left = 0;
                    hw->middle = 1;
                }
d2819 3
a2821 3
            hw->left = old->left;
            hw->right = old->right;
            hw->middle = old->middle;
d2828 1
a2828 2
    if (hw->left && !old->left && !old->middle && !old->right &&
        hw->numFingers >= 1) {
a2829 1
    }
d2831 1
d3087 2
a3088 6

    /* If touchpad is switched off, we skip the whole thing and return delay */
    if (para->touchpad_off == TOUCHPAD_OFF) {
        UpdateTouchState(pInfo, hw);
        return delay;
    }
d3105 2
a3106 1
    if (para->clickpad && (hw->left || hw->right || hw->middle)) {
d3109 1
d3119 12
d3132 1
a3132 1
    update_hw_button_state(pInfo, hw, priv->old_hw_state, now, &delay);
d3136 9
d3149 1
a3149 1
    if (!inside_active_area) {
a3151 4
        /* FIXME: if finger accidentally moves into the area and doesn't
         * really release, the finger should remain down. */
    }

d3211 1
a3211 1
    if (finger >= FS_TOUCHED && (dx || dy))
a3256 3

    /* Save logical state for transition comparisons */
    SynapticsCopyHwState(priv->old_hw_state, hw);
@


1.7
log
@Update to xf86-input-synaptics 1.7.1.

ok mpi@@ jcs@@ matthieu@@
@
text
@d136 1
d140 1
d675 14
d707 1
d839 2
d854 1
d856 2
d965 2
a966 1
        !priv->proto_ops->DeviceOnHook(pInfo, &priv->synpara))
d968 1
d1020 1
d1337 26
d1387 25
d1416 3
d2635 40
d2754 60
d3010 2
d3050 1
d3052 1
d3103 3
d3179 1
d3209 1
@


1.6
log
@Update to xf86-input-synaptics 1.6.2

ok matthieu@@, mpi@@
@
text
@d16 1
a16 1
 * Copyright © 2008-2009 Red Hat, Inc.
a65 1
#include <sys/shm.h>
a76 1
#include "synaptics.h"
d80 1
a80 1
typedef enum {
d90 1
a90 1
} edge_type;
a116 4
#ifndef M_SQRT1_2
#define M_SQRT1_2  0.70710678118654752440       /* 1/sqrt(2) */
#endif

a121 1
#if GET_ABI_MAJOR(ABI_XINPUT_VERSION) >= 12
a122 4
#else
static InputInfoPtr SynapticsPreInit(InputDriverPtr drv, IDevPtr dev,
                                     int flags);
#endif
d130 4
a133 4
static Bool DeviceInit(DeviceIntPtr);
static Bool DeviceOn(DeviceIntPtr);
static Bool DeviceOff(DeviceIntPtr);
static Bool DeviceClose(DeviceIntPtr);
d150 1
a150 2
    {
    "event", &event_proto_operations},
d153 1
a153 2
    {
    "psm", &psm_proto_operations},
d156 2
a157 3
    {
    "psaux", &psaux_proto_operations}, {
    "alps", &alps_proto_operations},
d162 1
a162 2
    {
    NULL, NULL}
a287 58
/*
 * Allocate and initialize read-only memory for the SynapticsParameters data to hold
 * driver settings.
 * The function will allocate shared memory if priv->shm_config is TRUE.
 */
static Bool
alloc_shm_data(InputInfoPtr pInfo)
{
    int shmid;
    SynapticsPrivate *priv = pInfo->private;

    if (priv->synshm)
        return TRUE;            /* Already allocated */

    if (priv->shm_config) {
        if ((shmid = shmget(SHM_SYNAPTICS, 0, 0)) != -1)
            shmctl(shmid, IPC_RMID, NULL);
        if ((shmid = shmget(SHM_SYNAPTICS, sizeof(SynapticsSHM),
                            0774 | IPC_CREAT)) == -1) {
            xf86IDrvMsg(pInfo, X_ERROR, "error shmget\n");
            return FALSE;
        }
        if ((priv->synshm = (SynapticsSHM *) shmat(shmid, NULL, 0)) == NULL) {
            xf86IDrvMsg(pInfo, X_ERROR, "error shmat\n");
            return FALSE;
        }
    }
    else {
        priv->synshm = calloc(1, sizeof(SynapticsSHM));
        if (!priv->synshm)
            return FALSE;
    }

    return TRUE;
}

/*
 * Free SynapticsParameters data previously allocated by alloc_shm_data().
 */
static void
free_shm_data(SynapticsPrivate * priv)
{
    int shmid;

    if (!priv->synshm)
        return;

    if (priv->shm_config) {
        if ((shmid = shmget(SHM_SYNAPTICS, 0, 0)) != -1)
            shmctl(shmid, IPC_RMID, NULL);
    }
    else {
        free(priv->synshm);
    }

    priv->synshm = NULL;
}

d305 2
a306 1
    else if (priv->model == MODEL_APPLETOUCH) {
d323 1
a323 1
                         int *fingerLow, int *fingerHigh, int *fingerPress)
d325 2
a326 1
    if (priv->model == MODEL_ELANTECH) {
d333 6
a338 2
    }
    else {
d341 1
a342 2

    *fingerPress = priv->minp + range * 1.000;
a355 2

#if GET_ABI_MAJOR(ABI_XINPUT_VERSION) >= 11
d361 1
a361 3
    }
    else
#endif
d373 13
d387 2
a388 2
    if ((((values[0] != 0) && (values[1] != 0)) && (values[0] > values[1])) ||
        (((values[2] != 0) && (values[3] != 0)) && (values[2] > values[3])))
d392 2
a393 2
    if ((((values[4] != 0) && (values[5] != 0)) && (values[4] > values[5])) ||
        (((values[6] != 0) && (values[7] != 0)) && (values[6] > values[7])))
d396 1
a396 1
    if (values[0] == 0 && values[1] == 0 && values[2] == 0 && values[3] == 0)
d399 1
a399 1
    if (values[4] == 0 && values[5] == 0 && values[6] == 0 && values[7] == 0)
d403 2
a404 2
        ((values[0] && values[0] == values[1]) ||
         (values[2] && values[2] == values[3])))
d408 2
a409 2
        ((values[4] && values[4] == values[5]) ||
         (values[6] && values[6] == values[7])))
d414 8
a421 8
        int right_left = values[0] ? values[0] : INT_MIN;
        int right_right = values[1] ? values[1] : INT_MAX;
        int right_top = values[2] ? values[2] : INT_MIN;
        int right_bottom = values[3] ? values[3] : INT_MAX;
        int middle_left = values[4] ? values[4] : INT_MIN;
        int middle_right = values[5] ? values[5] : INT_MAX;
        int middle_top = values[6] ? values[6] : INT_MIN;
        int middle_bottom = values[7] ? values[7] : INT_MAX;
d427 2
a428 2
            if ((right_left < middle_left && right_right >= middle_left) ||
                (middle_left < right_left && middle_right >= right_left))
d432 2
a433 2
            if ((right_right > middle_right && right_left <= middle_right) ||
                (middle_right > right_right && middle_left <= right_right))
d441 2
a442 2
            if ((right_top < middle_top && right_bottom >= middle_top) ||
                (middle_top < right_top && middle_bottom >= right_top))
d446 2
a447 2
            if ((right_bottom > middle_bottom && right_top <= middle_bottom) ||
                (middle_bottom > right_bottom && middle_top <= right_bottom))
d519 2
d527 1
a539 1
    int edgeMotionMinSpeed, edgeMotionMaxSpeed; /* pixels/second */
d541 1
a541 1
    int fingerLow, fingerHigh, fingerPress;     /* pressure */
a543 1
    int edgeMotionMinZ, edgeMotionMaxZ; /* pressure */
a555 6
    /* read the parameters */
    if (priv->synshm)
        priv->synshm->version =
            (PACKAGE_VERSION_MAJOR * 10000 + PACKAGE_VERSION_MINOR * 100 +
             PACKAGE_VERSION_PATCHLEVEL);

a576 2
    edgeMotionMinSpeed = 1;
    edgeMotionMaxSpeed = diag * .080;
d585 1
a585 2
    calculate_tap_hysteresis(priv, range, &fingerLow, &fingerHigh,
                             &fingerPress);
a588 2
    edgeMotionMinZ = priv->minp + range * (30.0 / 256);
    edgeMotionMaxZ = priv->minp + range * (160.0 / 256);
a645 1
    pars->finger_press = xf86SetIntOption(opts, "FingerPress", fingerPress);
a650 1
    pars->fast_taps = xf86SetBoolOption(opts, "FastTaps", FALSE);
d672 1
a672 23
    pars->edge_motion_min_z =
        xf86SetIntOption(opts, "EdgeMotionMinZ", edgeMotionMinZ);
    pars->edge_motion_max_z =
        xf86SetIntOption(opts, "EdgeMotionMaxZ", edgeMotionMaxZ);
    pars->edge_motion_min_speed =
        xf86SetIntOption(opts, "EdgeMotionMinSpeed", edgeMotionMinSpeed);
    pars->edge_motion_max_speed =
        xf86SetIntOption(opts, "EdgeMotionMaxSpeed", edgeMotionMaxSpeed);
    pars->edge_motion_use_always =
        xf86SetBoolOption(opts, "EdgeMotionUseAlways", FALSE);
    if (priv->has_scrollbuttons) {
        pars->updown_button_scrolling =
            xf86SetBoolOption(opts, "UpDownScrolling", TRUE);
        pars->leftright_button_scrolling =
            xf86SetBoolOption(opts, "LeftRightScrolling", TRUE);
        pars->updown_button_repeat =
            xf86SetBoolOption(opts, "UpDownScrollRepeat", TRUE);
        pars->leftright_button_repeat =
            xf86SetBoolOption(opts, "LeftRightScrollRepeat", TRUE);
    }
    pars->scroll_button_repeat =
        xf86SetIntOption(opts, "ScrollButtonRepeat", 100);
    pars->touchpad_off = xf86SetIntOption(opts, "TouchpadOff", 0);
a690 1
    pars->circular_pad = xf86SetBoolOption(opts, "CircularPad", FALSE);
a702 1
    pars->trackstick_speed = xf86SetRealOption(opts, "TrackstickSpeed", 40);
a730 1
#if GET_ABI_MAJOR(ABI_XINPUT_VERSION) >= 14
a735 9
#else
static float
SynapticsAccelerationProfile(DeviceIntPtr dev,
                             DeviceVelocityPtr vel,
                             float velocity_f, float thr_f, float acc_f)
{
    double velocity = velocity_f;
    double acc = acc_f;
#endif
a779 40
#if GET_ABI_MAJOR(ABI_XINPUT_VERSION) < 12
static int
 NewSynapticsPreInit(InputDriverPtr drv, InputInfoPtr pInfo, int flags);

/*
 *  called by the module loader for initialization
 */
static InputInfoPtr
SynapticsPreInit(InputDriverPtr drv, IDevPtr dev, int flags)
{
    InputInfoPtr pInfo;

    /* Allocate a new InputInfoRec and add it to the head xf86InputDevs. */
    pInfo = xf86AllocateInput(drv, 0);
    if (!pInfo) {
        return NULL;
    }

    /* initialize the InputInfoRec */
    pInfo->name = dev->identifier;
    pInfo->reverse_conversion_proc = NULL;
    pInfo->dev = NULL;
    pInfo->private_flags = 0;
    pInfo->flags = XI86_SEND_DRAG_EVENTS;
    pInfo->conf_idev = dev;
    pInfo->always_core_feedback = 0;

    xf86CollectInputOptions(pInfo, NULL, NULL);

    if (NewSynapticsPreInit(drv, pInfo, flags) != Success)
        return NULL;

    pInfo->flags |= XI86_CONFIGURED;

    return pInfo;
}

static int
NewSynapticsPreInit(InputDriverPtr drv, InputInfoPtr pInfo, int flags)
#else
a781 1
#endif
a821 2
    priv->repeatButtons = 0;
    priv->nextRepeat = 0;
a832 3
    /* install shared memory or normal memory for parameters */
    priv->shm_config = xf86SetBoolOption(pInfo->options, "SHMConfig", FALSE);

a836 3
    if (!alloc_shm_data(pInfo))
        goto SetupProc_fail;

a865 1
    free_shm_data(priv);
a884 1
#ifdef HAVE_SMOOTH_SCROLL
a886 2
#endif
#ifdef HAVE_MULTITOUCH
a888 1
#endif
d903 1
a903 1
static Bool
d928 1
a928 1
static Bool
a995 1
    priv->nextRepeat = 0;
d999 1
a999 1
#ifdef HAVE_MULTITOUCH
a1000 1
#endif
d1003 1
a1003 1
static Bool
d1031 1
a1031 1
static Bool
d1041 2
a1042 1
    free_shm_data(priv);
a1052 1
#ifdef HAVE_MULTITOUCH
a1053 1
#endif
a1057 1
#ifdef HAVE_SMOOTH_SCROLL
a1061 1
#endif
a1068 1
#ifdef HAVE_MULTITOUCH
a1074 1
#endif
a1103 1
#ifdef HAVE_MULTITOUCH
a1149 1
#endif
d1152 1
a1152 1
static Bool
a1166 1
#ifdef HAVE_SMOOTH_SCROLL
a1167 1
#endif
a1168 1
#ifdef HAVE_MULTITOUCH
a1169 1
#endif
d1224 1
a1224 1
        xf86IDrvMsg(pInfo, X_CONFIG, "MaxSpeed is now %.2f\n",
d1226 1
a1226 1
        xf86IDrvMsg(pInfo, X_CONFIG, "AccelFactor is now %.3f\n",
d1245 3
a1247 6
    xf86InitValuatorAxisStruct(dev, 0, axes_labels[0],
                               min, max, priv->resx * 1000, 0, priv->resx * 1000
#if GET_ABI_MAJOR(ABI_XINPUT_VERSION) >= 12
                               , Relative
#endif
        );
d1260 3
a1262 6
    xf86InitValuatorAxisStruct(dev, 1, axes_labels[1],
                               min, max, priv->resy * 1000, 0, priv->resy * 1000
#if GET_ABI_MAJOR(ABI_XINPUT_VERSION) >= 12
                               , Relative
#endif
        );
a1264 1
#ifdef HAVE_SMOOTH_SCROLL
a1280 1
#endif
a1299 3
    if (!alloc_shm_data(pInfo))
        goto fail;

a1305 1
    free_shm_data(priv);
a1307 1
#ifdef HAVE_MULTITOUCH
a1308 1
#endif
a1311 26
/*
 * Convert from absolute X/Y coordinates to a coordinate system where
 * -1 corresponds to the left/upper edge and +1 corresponds to the
 * right/lower edge.
 */
static void
relative_coords(SynapticsPrivate * priv, int x, int y,
                double *relX, double *relY)
{
    int minX = priv->synpara.left_edge;
    int maxX = priv->synpara.right_edge;
    int minY = priv->synpara.top_edge;
    int maxY = priv->synpara.bottom_edge;
    double xCenter = (minX + maxX) / 2.0;
    double yCenter = (minY + maxY) / 2.0;

    if ((maxX - xCenter > 0) && (maxY - yCenter > 0)) {
        *relX = (x - xCenter) / (maxX - xCenter);
        *relY = (y - yCenter) / (maxY - yCenter);
    }
    else {
        *relX = 0;
        *relY = 0;
    }
}

d1335 1
a1335 26
static edge_type
circular_edge_detection(SynapticsPrivate * priv, int x, int y)
{
    edge_type edge = 0;
    double relX, relY, relR;

    relative_coords(priv, x, y, &relX, &relY);
    relR = SQR(relX) + SQR(relY);

    if (relR > 1) {
        /* we are outside the ellipse enclosed by the edge parameters */
        if (relX > M_SQRT1_2)
            edge |= RIGHT_EDGE;
        else if (relX < -M_SQRT1_2)
            edge |= LEFT_EDGE;

        if (relY < -M_SQRT1_2)
            edge |= TOP_EDGE;
        else if (relY > M_SQRT1_2)
            edge |= BOTTOM_EDGE;
    }

    return edge;
}

static edge_type
d1338 1
a1338 4
    edge_type edge = NO_EDGE;

    if (priv->synpara.circular_pad)
        return circular_edge_detection(priv, x, y);
d1384 11
a1394 4
    if (para->softbutton_areas[which][0] == 0 &&
        para->softbutton_areas[which][1] == 0 &&
        para->softbutton_areas[which][2] == 0 &&
        para->softbutton_areas[which][3] == 0)
d1397 2
a1398 2
    if (para->softbutton_areas[which][0] &&
        x < para->softbutton_areas[which][0])
d1400 2
a1401 2
    else if (para->softbutton_areas[which][1] &&
             x > para->softbutton_areas[which][1])
d1403 2
a1404 2
    else if (para->softbutton_areas[which][2] &&
             y < para->softbutton_areas[which][2])
d1406 2
a1407 2
    else if (para->softbutton_areas[which][3] &&
             y > para->softbutton_areas[which][3])
d1617 1
a1617 3
    if (hw->z > para->finger_press && priv->finger_state < FS_PRESSED)
        finger = FS_PRESSED;
    else if (hw->z > para->finger_high && priv->finger_state == FS_UNTOUCHED)
d1656 1
a1656 1
SelectTapButton(SynapticsPrivate * priv, edge_type edge)
d1658 1
a1658 1
    TapEvent tap;
d1660 1
a1660 1
    if (priv->synpara.touchpad_off == 2) {
a1709 2
    SynapticsParameters *para = &priv->synpara;

d1721 1
a1721 4
        if (para->fast_taps)
            priv->tap_button_state = TBS_BUTTON_DOWN;
        else
            priv->tap_button_state = TBS_BUTTON_UP;
d1730 1
a1730 4
        if (para->fast_taps)
            priv->tap_button_state = TBS_BUTTON_UP;
        else
            priv->tap_button_state = TBS_BUTTON_DOWN;
a1746 4
    if (moving_state == MS_TRACKSTICK) {
        priv->trackstick_neutral_x = priv->hwState->x;
        priv->trackstick_neutral_y = priv->hwState->y;
    }
d1781 1
a1781 1
    edge_type edge;
a1831 3
            else if (finger == FS_PRESSED) {
                SetMovingState(priv, MS_TRACKSTICK, now);
            }
a1849 3
        if (move && priv->moving_state == MS_TRACKSTICK) {
            SetMovingState(priv, MS_TOUCHPAD_RELATIVE, now);
        }
a1891 3
                else if (finger == FS_PRESSED) {
                    SetMovingState(priv, MS_TRACKSTICK, now);
                }
d2018 2
a2019 64
get_delta_for_trackstick(SynapticsPrivate * priv,
                         const struct SynapticsHwState *hw, double *dx,
                         double *dy)
{
    SynapticsParameters *para = &priv->synpara;
    double dtime = (hw->millis - HIST(0).millis) / 1000.0;

    *dx = (hw->x - priv->trackstick_neutral_x);
    *dy = (hw->y - priv->trackstick_neutral_y);

    *dx = *dx * dtime * para->trackstick_speed;
    *dy = *dy * dtime * para->trackstick_speed;
}

static void
get_edge_speed(SynapticsPrivate * priv, const struct SynapticsHwState *hw,
               edge_type edge, int *x_edge_speed, int *y_edge_speed)
{
    SynapticsParameters *para = &priv->synpara;

    int minZ = para->edge_motion_min_z;
    int maxZ = para->edge_motion_max_z;
    int minSpd = para->edge_motion_min_speed;
    int maxSpd = para->edge_motion_max_speed;
    int edge_speed;

    if (hw->z <= minZ) {
        edge_speed = minSpd;
    }
    else if (hw->z >= maxZ) {
        edge_speed = maxSpd;
    }
    else {
        edge_speed =
            minSpd + (hw->z - minZ) * (maxSpd - minSpd) / (maxZ - minZ);
    }
    if (!priv->synpara.circular_pad) {
        /* on rectangular pad */
        if (edge & RIGHT_EDGE) {
            *x_edge_speed = edge_speed;
        }
        else if (edge & LEFT_EDGE) {
            *x_edge_speed = -edge_speed;
        }
        if (edge & TOP_EDGE) {
            *y_edge_speed = -edge_speed;
        }
        else if (edge & BOTTOM_EDGE) {
            *y_edge_speed = edge_speed;
        }
    }
    else if (edge) {
        /* at edge of circular pad */
        double relX, relY;

        relative_coords(priv, hw->x, hw->y, &relX, &relY);
        *x_edge_speed = (int) (edge_speed * relX);
        *y_edge_speed = (int) (edge_speed * relY);
    }
}

static void
get_delta(SynapticsPrivate * priv, const struct SynapticsHwState *hw,
          edge_type edge, double *dx, double *dy)
a2020 1
    SynapticsParameters *para = &priv->synpara;
a2029 3
    if ((priv->tap_state == TS_DRAG) || para->edge_motion_use_always)
        get_edge_speed(priv, hw, edge, &x_edge_speed, &y_edge_speed);

d2049 1
a2049 1
 * Compute relative motion ('deltas') including edge motion xor trackstick.
d2053 1
a2053 1
              edge_type edge, int *dxP, int *dyP, Bool inside_area)
d2096 1
a2096 3
    if (priv->moving_state == MS_TRACKSTICK)
        get_delta_for_trackstick(priv, hw, &dx, &dy);
    else if (moving_state == MS_TOUCHPAD_RELATIVE)
d2197 1
a2197 1
                edge_type edge, Bool finger)
d2202 1
a2202 1
    if ((priv->synpara.touchpad_off == 2) || (priv->finger_state == FS_BLOCKED)) {
d2464 2
d2467 1
a2467 4
#if HAVE_MULTITOUCH
    char close_point[SYNAPTICS_MAX_TOUCHES] = { 0 };    /* 1 for each point close
                                                           to another one */
    int i, j;
d2500 2
a2501 2
                close_point[j] = 1;
                close_point[i] = 1;
d2506 4
a2509 3
    for (i = 0; i < SYNAPTICS_MAX_TOUCHES; i++)
        nfingers += close_point[i];
#endif
a2555 67
/* Update the hardware state in shared memory. This is read-only these days,
 * nothing in the driver reads back from SHM. SHM configuration is a thing of the past.
 */
static void
update_shm(const InputInfoPtr pInfo, const struct SynapticsHwState *hw)
{
    int i;
    SynapticsPrivate *priv = (SynapticsPrivate *) (pInfo->private);
    SynapticsSHM *shm = priv->synshm;

    if (!shm)
        return;

    shm->x = hw->x;
    shm->y = hw->y;
    shm->z = hw->z;
    shm->numFingers = hw->numFingers;
    shm->fingerWidth = hw->fingerWidth;
    shm->left = hw->left;
    shm->right = hw->right;
    shm->up = hw->up;
    shm->down = hw->down;
    for (i = 0; i < 8; i++)
        shm->multi[i] = hw->multi[i];
    shm->middle = hw->middle;
}

/* Adjust the hardware state according to the extra buttons (if the touchpad
 * has any and not many touchpads do these days). These buttons are up/down
 * tilt buttons and/or left/right buttons that then map into a specific
 * function (or scrolling into).
 */
static Bool
adjust_state_from_scrollbuttons(const InputInfoPtr pInfo,
                                struct SynapticsHwState *hw)
{
    SynapticsPrivate *priv = (SynapticsPrivate *) (pInfo->private);
    SynapticsParameters *para = &priv->synpara;
    Bool double_click = FALSE;

    if (!para->updown_button_scrolling) {
        if (hw->down) {         /* map down button to middle button */
            hw->middle = TRUE;
        }

        if (hw->up) {           /* up button generates double click */
            if (!priv->prev_up)
                double_click = TRUE;
        }
        priv->prev_up = hw->up;

        /* reset up/down button events */
        hw->up = hw->down = FALSE;
    }

    /* Left/right button scrolling, or middle clicks */
    if (!para->leftright_button_scrolling) {
        if (hw->multi[2] || hw->multi[3])
            hw->middle = TRUE;

        /* reset left/right button events */
        hw->multi[2] = hw->multi[3] = FALSE;
    }

    return double_click;
}

a2618 1
#ifdef HAVE_SMOOTH_SCROLL
a2632 85
#else
    SynapticsParameters *para = &priv->synpara;

    /* smooth scrolling uses the dist as increment */

    while (priv->scroll.delta_y <= -para->scroll_dist_vert) {
        post_button_click(pInfo, 4);
        priv->scroll.delta_y += para->scroll_dist_vert;
    }

    while (priv->scroll.delta_y >= para->scroll_dist_vert) {
        post_button_click(pInfo, 5);
        priv->scroll.delta_y -= para->scroll_dist_vert;
    }

    while (priv->scroll.delta_x <= -para->scroll_dist_horiz) {
        post_button_click(pInfo, 6);
        priv->scroll.delta_x += para->scroll_dist_horiz;
    }

    while (priv->scroll.delta_x >= para->scroll_dist_horiz) {
        post_button_click(pInfo, 7);
        priv->scroll.delta_x -= para->scroll_dist_horiz;
    }
#endif
}

static inline int
repeat_scrollbuttons(const InputInfoPtr pInfo,
                     const struct SynapticsHwState *hw,
                     int buttons, CARD32 now, int delay)
{
    SynapticsPrivate *priv = (SynapticsPrivate *) (pInfo->private);
    SynapticsParameters *para = &priv->synpara;
    int repeat_delay, timeleft;
    int rep_buttons = 0;

    if (para->updown_button_repeat)
        rep_buttons |= (1 << (4 - 1)) | (1 << (5 - 1));
    if (para->leftright_button_repeat)
        rep_buttons |= (1 << (6 - 1)) | (1 << (7 - 1));

    /* Handle auto repeat buttons */
    repeat_delay = clamp(para->scroll_button_repeat, SBR_MIN, SBR_MAX);
    if (((hw->up || hw->down) && para->updown_button_repeat &&
         para->updown_button_scrolling) ||
        ((hw->multi[2] || hw->multi[3]) && para->leftright_button_repeat &&
         para->leftright_button_scrolling)) {
        priv->repeatButtons = buttons & rep_buttons;
        if (!priv->nextRepeat) {
            priv->nextRepeat = now + repeat_delay * 2;
        }
    }
    else {
        priv->repeatButtons = 0;
        priv->nextRepeat = 0;
    }

    if (priv->repeatButtons) {
        timeleft = TIME_DIFF(priv->nextRepeat, now);
        if (timeleft > 0)
            delay = MIN(delay, timeleft);
        if (timeleft <= 0) {
            int change, id;

            change = priv->repeatButtons;
            while (change) {
                id = ffs(change);
                change &= ~(1 << (id - 1));
                if (id == 4)
                    priv->scroll.delta_y -= para->scroll_dist_vert;
                else if (id == 5)
                    priv->scroll.delta_y += para->scroll_dist_vert;
                else if (id == 6)
                    priv->scroll.delta_x -= para->scroll_dist_horiz;
                else if (id == 7)
                    priv->scroll.delta_x += para->scroll_dist_horiz;
            }

            priv->nextRepeat = now + repeat_delay;
            delay = MIN(delay, repeat_delay);
        }
    }

    return delay;
a2638 1
#ifdef HAVE_MULTITOUCH
d2646 1
a2666 1
#endif
a2671 1
#ifdef HAVE_MULTITOUCH
a2747 1
#endif
d2789 1
a2789 1
    edge_type edge = NO_EDGE;
a2795 2
    update_shm(pInfo, hw);

d2797 1
a2797 1
    if (para->touchpad_off == 1) {
d2829 3
a2842 5
    /* these two just update hw->left, right, etc. */
    update_hw_button_state(pInfo, hw, priv->old_hw_state, now, &delay);
    if (priv->has_scrollbuttons)
        double_click = adjust_state_from_scrollbuttons(pInfo, hw);

d2874 2
a2875 4
    if (!priv->absolute_events) {
        timeleft = ComputeDeltas(priv, hw, edge, &dx, &dy, inside_active_area);
        delay = MIN(delay, timeleft);
    }
d2900 2
a2901 8
    if (finger >= FS_TOUCHED) {
        if (priv->absolute_events && inside_active_area) {
            xf86PostMotionEvent(pInfo->dev, 1, 0, 2, hw->x, hw->y);
        }
        else if (dx || dy) {
            xf86PostMotionEvent(pInfo->dev, 0, 0, 2, dx, dy);
        }
    }
a2919 3
    if (priv->has_scrollbuttons)
        delay = repeat_scrollbuttons(pInfo, hw, buttons, now, delay);

a2959 3
    InputInfoPtr pInfo = (InputInfoPtr) dev->public.devicePrivate;
    SynapticsPrivate *priv = (SynapticsPrivate *) (pInfo->private);

d2962 1
a2962 14
    switch (mode) {
    case Absolute:
        priv->absolute_events = TRUE;
        break;

    case Relative:
        priv->absolute_events = FALSE;
        break;

    default:
        return XI_BadMode;
    }

    return Success;
@


1.5
log
@Update to xf86-input-synaptics 1.6.1

ok matthieu@@
@
text
@d1159 3
d2749 1
a2749 1
        priv->scroll.delta_y += priv->scroll.coast_speed_y * dtime * para->scroll_dist_vert;
d2764 1
a2764 1
        priv->scroll.delta_x += priv->scroll.coast_speed_x * dtime * para->scroll_dist_vert;
d3137 3
a3139 1
            priv->num_active_touches--;
d3282 13
@


1.4
log
@Update to xf86-input-synaptics 1.5.2.

ok matthieu@@
@
text
@d17 1
a57 1

d73 5
a81 6
#if GET_ABI_MAJOR(ABI_XINPUT_VERSION) >= 7
#include <X11/Xatom.h>
#include <xserver-properties.h>
#include <ptrveloc.h>
#endif

d94 15
d120 1
a120 1
#define M_SQRT1_2  0.70710678118654752440  /* 1/sqrt(2) */
d131 2
a132 1
static InputInfoPtr SynapticsPreInit(InputDriverPtr drv, IDevPtr dev, int flags);
d137 3
a139 2
static int HandleState(InputInfoPtr, struct SynapticsHwState*);
static int ControlProc(InputInfoPtr, xDeviceCtl*);
d147 3
a149 2
static void ScaleCoordinates(SynapticsPrivate *priv, struct SynapticsHwState *hw);
static void CalculateScalingCoeffs(SynapticsPrivate *priv);
d161 2
a162 1
    {"event", &event_proto_operations},
d165 2
a166 1
    {"psm", &psm_proto_operations},
d169 3
a171 2
    {"psaux", &psaux_proto_operations},
    {"alps", &alps_proto_operations},
d174 1
a174 1
    {"wscons", &wscons_proto_operations},
d176 2
a177 1
    {NULL, NULL}
a214 1

d230 1
a230 1
    SynapticsPrivate *priv = (SynapticsPrivate *)pInfo->private;
d232 4
a235 5
    if (priv->minx >= priv->maxx)
    {
	priv->minx = 1615;
	priv->maxx = 5685;
	priv->resx = 0;
d237 3
a239 3
	xf86IDrvMsg(pInfo, X_PROBED,
		    "invalid x-axis range.  defaulting to %d - %d\n",
		    priv->minx, priv->maxx);
d242 4
a245 5
    if (priv->miny >= priv->maxy)
    {
	priv->miny = 1729;
	priv->maxy = 4171;
	priv->resy = 0;
d247 3
a249 3
	xf86IDrvMsg(pInfo, X_PROBED,
		    "invalid y-axis range.  defaulting to %d - %d\n",
		    priv->miny, priv->maxy);
d252 3
a254 4
    if (priv->minp >= priv->maxp)
    {
	priv->minp = 0;
	priv->maxp = 255;
d256 3
a258 3
	xf86IDrvMsg(pInfo, X_PROBED,
		    "invalid pressure range.  defaulting to %d - %d\n",
		    priv->minp, priv->maxp);
d261 3
a263 4
    if (priv->minw >= priv->maxw)
    {
	priv->minw = 0;
	priv->maxw = 15;
d265 3
a267 3
	xf86IDrvMsg(pInfo, X_PROBED,
		    "invalid finger width range.  defaulting to %d - %d\n",
		    priv->minw, priv->maxw);
d271 1
a271 1
static void
d299 2
d315 1
a315 1
	return TRUE;			    /* Already allocated */
d318 16
a333 15
	if ((shmid = shmget(SHM_SYNAPTICS, 0, 0)) != -1)
	    shmctl(shmid, IPC_RMID, NULL);
	if ((shmid = shmget(SHM_SYNAPTICS, sizeof(SynapticsSHM),
				0774 | IPC_CREAT)) == -1) {
	    xf86IDrvMsg(pInfo, X_ERROR, "error shmget\n");
	    return FALSE;
	}
	if ((priv->synshm = (SynapticsSHM*)shmat(shmid, NULL, 0)) == NULL) {
	    xf86IDrvMsg(pInfo, X_ERROR, "error shmat\n");
	    return FALSE;
	}
    } else {
	priv->synshm = calloc(1, sizeof(SynapticsSHM));
	if (!priv->synshm)
	    return FALSE;
d343 1
a343 1
free_shm_data(SynapticsPrivate *priv)
d348 1
a348 1
	return;
d351 5
a355 4
	if ((shmid = shmget(SHM_SYNAPTICS, 0, 0)) != -1)
	    shmctl(shmid, IPC_RMID, NULL);
    } else {
	free(priv->synshm);
d362 1
a362 1
calculate_edge_widths(SynapticsPrivate *priv, int *l, int *r, int *t, int *b)
d365 1
a365 1
    int ewidth, eheight; /* edge width/height */
d370 1
a370 2
    if (priv->model == MODEL_SYNAPTICS)
    {
d373 2
a374 2
    } else if (priv->model == MODEL_ALPS)
    {
d377 2
a378 2
    } else if (priv->model == MODEL_APPLETOUCH)
    {
d381 2
a382 2
    } else
    {
d393 20
d419 3
a421 3
static int set_percent_option(pointer options, const char* optname,
                              const int range, const int offset,
                              const int default_value)
d424 1
d430 3
a432 2
        result = percent/100.0 * range + offset;
    } else
d439 149
a587 1
static void set_default_parameters(InputInfoPtr pInfo)
d589 2
a590 2
    SynapticsPrivate *priv = pInfo->private; /* read-only */
    pointer opts = pInfo->options; /* read-only */
d593 11
a603 11
    int horizScrollDelta, vertScrollDelta;		/* pixels */
    int tapMove;					/* pixels */
    int l, r, t, b; /* left, right, top, bottom */
    int edgeMotionMinSpeed, edgeMotionMaxSpeed;		/* pixels/second */
    double accelFactor;					/* 1/pixels */
    int fingerLow, fingerHigh, fingerPress;		/* pressure */
    int emulateTwoFingerMinZ;				/* pressure */
    int emulateTwoFingerMinW;				/* width */
    int edgeMotionMinZ, edgeMotionMaxZ;			/* pressure */
    int pressureMotionMinZ, pressureMotionMaxZ;		/* pressure */
    int palmMinWidth, palmMinZ;				/* pressure */
d612 1
d616 3
a618 1
        priv->synshm->version = (PACKAGE_VERSION_MAJOR*10000+PACKAGE_VERSION_MINOR*100+PACKAGE_VERSION_PATCHLEVEL);
d651 3
d655 6
a660 9
    fingerLow = priv->minp + range * (25.0/256);
    fingerHigh = priv->minp + range * (30.0/256);
    fingerPress = priv->minp + range * 1.000;
    emulateTwoFingerMinZ = priv->minp + range * (282.0/256);
    edgeMotionMinZ = priv->minp + range * (30.0/256);
    edgeMotionMaxZ = priv->minp + range * (160.0/256);
    pressureMotionMinZ = priv->minp + range * (30.0/256);
    pressureMotionMaxZ = priv->minp + range * (160.0/256);
    palmMinZ = priv->minp + range * (200.0/256);
d665 2
a666 2
    palmMinWidth = priv->minw + range * (10.0/16);
    emulateTwoFingerMinW = priv->minw + range * (7.0/16);
d699 13
a711 7
    pars->area_top_edge = set_percent_option(opts, "AreaTopEdge", height, priv->miny, 0);
    pars->area_bottom_edge = set_percent_option(opts, "AreaBottomEdge", height, priv->miny, 0);
    pars->area_left_edge = set_percent_option(opts, "AreaLeftEdge", width, priv->minx, 0);
    pars->area_right_edge = set_percent_option(opts, "AreaRightEdge", width, priv->minx, 0);

    pars->hyst_x = set_percent_option(opts, "HorizHysteresis", width, 0, horizHyst);
    pars->hyst_y = set_percent_option(opts, "VertHysteresis", height, 0, vertHyst);
d720 1
d722 16
a737 7
    pars->emulate_mid_button_time = xf86SetIntOption(opts, "EmulateMidButtonTime", 75);
    pars->emulate_twofinger_z = xf86SetIntOption(opts, "EmulateTwoFingerMinZ", emulateTwoFingerMinZ);
    pars->emulate_twofinger_w = xf86SetIntOption(opts, "EmulateTwoFingerMinW", emulateTwoFingerMinW);
    pars->scroll_dist_vert = xf86SetIntOption(opts, "VertScrollDelta", horizScrollDelta);
    pars->scroll_dist_horiz = xf86SetIntOption(opts, "HorizScrollDelta", vertScrollDelta);
    pars->scroll_edge_vert = xf86SetBoolOption(opts, "VertEdgeScroll", vertEdgeScroll);
    pars->scroll_edge_horiz = xf86SetBoolOption(opts, "HorizEdgeScroll", horizEdgeScroll);
d739 14
a752 7
    pars->scroll_twofinger_vert = xf86SetBoolOption(opts, "VertTwoFingerScroll", vertTwoFingerScroll);
    pars->scroll_twofinger_horiz = xf86SetBoolOption(opts, "HorizTwoFingerScroll", horizTwoFingerScroll);
    pars->edge_motion_min_z = xf86SetIntOption(opts, "EdgeMotionMinZ", edgeMotionMinZ);
    pars->edge_motion_max_z = xf86SetIntOption(opts, "EdgeMotionMaxZ", edgeMotionMaxZ);
    pars->edge_motion_min_speed = xf86SetIntOption(opts, "EdgeMotionMinSpeed", edgeMotionMinSpeed);
    pars->edge_motion_max_speed = xf86SetIntOption(opts, "EdgeMotionMaxSpeed", edgeMotionMaxSpeed);
    pars->edge_motion_use_always = xf86SetBoolOption(opts, "EdgeMotionUseAlways", FALSE);
d754 8
a761 4
	pars->updown_button_scrolling = xf86SetBoolOption(opts, "UpDownScrolling", TRUE);
	pars->leftright_button_scrolling = xf86SetBoolOption(opts, "LeftRightScrolling", TRUE);
	pars->updown_button_repeat = xf86SetBoolOption(opts, "UpDownScrollRepeat", TRUE);
	pars->leftright_button_repeat = xf86SetBoolOption(opts, "LeftRightScrollRepeat", TRUE);
d763 2
a764 1
    pars->scroll_button_repeat = xf86SetIntOption(opts,"ScrollButtonRepeat", 100);
d772 16
a787 12
    pars->tap_action[F1_TAP] = xf86SetIntOption(opts, "TapButton1",     tapButton1);
    pars->tap_action[F2_TAP] = xf86SetIntOption(opts, "TapButton2",     tapButton2);
    pars->tap_action[F3_TAP] = xf86SetIntOption(opts, "TapButton3",     tapButton3);
    pars->click_action[F1_CLICK1] = xf86SetIntOption(opts, "ClickFinger1", clickFinger1);
    pars->click_action[F2_CLICK1] = xf86SetIntOption(opts, "ClickFinger2", clickFinger2);
    pars->click_action[F3_CLICK1] = xf86SetIntOption(opts, "ClickFinger3", clickFinger3);
    pars->circular_scrolling = xf86SetBoolOption(opts, "CircularScrolling", FALSE);
    pars->circular_trigger   = xf86SetIntOption(opts, "CircScrollTrigger", 0);
    pars->circular_pad       = xf86SetBoolOption(opts, "CircularPad", FALSE);
    pars->palm_detect        = xf86SetBoolOption(opts, "PalmDetect", FALSE);
    pars->palm_min_width     = xf86SetIntOption(opts, "PalmMinWidth", palmMinWidth);
    pars->palm_min_z         = xf86SetIntOption(opts, "PalmMinZ", palmMinZ);
d789 4
a792 2
    pars->press_motion_min_z = xf86SetIntOption(opts, "PressureMotionMinZ", pressureMotionMinZ);
    pars->press_motion_max_z = xf86SetIntOption(opts, "PressureMotionMaxZ", pressureMotionMaxZ);
d801 4
a804 2
    pars->press_motion_min_factor = xf86SetRealOption(opts, "PressureMotionMinFactor", 1.0);
    pars->press_motion_max_factor = xf86SetRealOption(opts, "PressureMotionMaxFactor", 1.0);
d806 6
a811 3
    pars->tap_and_drag_gesture = xf86SetBoolOption(opts, "TapAndDragGesture", TRUE);
    pars->resolution_horiz = xf86SetIntOption(opts, "HorizResolution", horizResolution);
    pars->resolution_vert = xf86SetIntOption(opts, "VertResolution", vertResolution);
d815 6
a820 4
	int tmp = pars->top_edge;
	pars->top_edge = pars->bottom_edge;
	pars->bottom_edge = tmp;
	xf86IDrvMsg(pInfo, X_WARNING, "TopEdge is bigger than BottomEdge. Fixing.\n");
d822 2
d827 5
a831 5
static double SynapticsAccelerationProfile(DeviceIntPtr dev,
                                           DeviceVelocityPtr vel,
                                           double velocity,
                                           double thr,
                                           double acc) {
d833 5
a837 5
static float SynapticsAccelerationProfile(DeviceIntPtr dev,
                                          DeviceVelocityPtr vel,
                                          float velocity_f,
                                          float thr_f,
                                          float acc_f) {
a838 1
    double thr = thr_f;
d843 1
a843 1
    SynapticsParameters* para = &priv->synpara;
d858 1
a858 1
	accelfct = para->max_speed * acc;
d860 1
a860 1
	accelfct = para->min_speed;
d864 16
a879 11
	int minZ = para->press_motion_min_z;
	int maxZ = para->press_motion_max_z;
	double minFctr = para->press_motion_min_factor;
	double maxFctr = para->press_motion_max_factor;
	if (priv->hwState.z <= minZ) {
	    accelfct *= minFctr;
	} else if (priv->hwState.z >= maxZ) {
	    accelfct *= maxFctr;
	} else {
	    accelfct *= minFctr + (priv->hwState.z - minZ) * (maxFctr - minFctr) / (maxZ - minZ);
	}
d887 2
a888 1
NewSynapticsPreInit(InputDriverPtr drv, InputInfoPtr pInfo, int flags);
d900 1
a900 1
	return NULL;
d904 1
a904 1
    pInfo->name                    = dev->identifier;
d906 5
a910 5
    pInfo->dev                     = NULL;
    pInfo->private_flags           = 0;
    pInfo->flags                   = XI86_SEND_DRAG_EVENTS;
    pInfo->conf_idev               = dev;
    pInfo->always_core_feedback    = 0;
d934 1
a934 1
	return BadAlloc;
d936 6
a941 6
    pInfo->type_name               = XI_TOUCHPAD;
    pInfo->device_control          = DeviceControl;
    pInfo->read_input              = ReadInput;
    pInfo->control_proc            = ControlProc;
    pInfo->switch_mode             = SwitchMode;
    pInfo->private                 = priv;
d946 2
a947 2
	free(priv);
	return BadAlloc;
d951 3
a953 3
    SetDeviceAndProtocol(pInfo);
    if (priv->proto_ops == NULL) {
        xf86IDrvMsg(pInfo, X_ERROR, "Synaptics driver unable to detect protocol\n");
d962 2
a963 2
	xf86IDrvMsg(pInfo, X_ERROR, "Synaptics driver unable to open device\n");
	goto SetupProc_fail;
d989 1
a989 1
	goto SetupProc_fail;
d994 3
a996 2
	xf86IDrvMsg(pInfo, X_ERROR, "Unable to query/initialize Synaptics hardware.\n");
	goto SetupProc_fail;
d1002 5
a1006 5
	if (priv->comm.buffer) {
	    XisbFree(priv->comm.buffer);
	    priv->comm.buffer = NULL;
	}
	xf86CloseSerial(pInfo->fd);
d1014 2
a1015 2
	xf86CloseSerial(pInfo->fd);
	pInfo->fd = -1;
d1019 1
a1019 1
	XisbFree(priv->comm.buffer);
a1027 1

d1031 2
a1032 3
static void SynapticsUnInit(InputDriverPtr drv,
                            InputInfoPtr   pInfo,
                            int            flags)
d1034 2
a1035 1
    SynapticsPrivate *priv = ((SynapticsPrivate *)pInfo->private);
d1040 8
a1052 1

d1058 1
a1058 1
SynapticsCtrl(DeviceIntPtr device, PtrCtrl *ctrl)
d1069 2
a1070 2
	RetValue = DeviceInit(dev);
	break;
d1072 2
a1073 2
	RetValue = DeviceOn(dev);
	break;
d1075 2
a1076 2
	RetValue = DeviceOff(dev);
	break;
d1078 2
a1079 2
	RetValue = DeviceClose(dev);
	break;
d1081 1
a1081 1
	RetValue = BadValue;
d1097 2
a1098 2
	xf86IDrvMsg(pInfo, X_WARNING, "cannot open input device\n");
	return !Success;
d1101 3
a1103 2
    if (priv->proto_ops->DeviceOnHook)
        priv->proto_ops->DeviceOnHook(pInfo, &priv->synpara);
d1107 3
a1109 3
	xf86CloseSerial(pInfo->fd);
	pInfo->fd = -1;
	return !Success;
d1115 1
a1115 2
    if (!QueryHardware(pInfo))
    {
d1129 32
d1166 1
d1171 13
a1183 10
	TimerCancel(priv->timer);
	xf86RemoveEnabledDevice(pInfo);
        if (priv->proto_ops->DeviceOffHook)
            priv->proto_ops->DeviceOffHook(pInfo);
	if (priv->comm.buffer) {
	    XisbFree(priv->comm.buffer);
	    priv->comm.buffer = NULL;
	}
	xf86CloseSerial(pInfo->fd);
	pInfo->fd = -1;
d1186 1
a1186 1
    return Success;
d1200 4
d1207 2
a1208 2
#if GET_ABI_MAJOR(ABI_XINPUT_VERSION) >= 7
static void InitAxesLabels(Atom *labels, int nlabels)
d1210 4
d1215 21
a1235 8
    switch(nlabels)
    {
        default:
        case 2:
            labels[1] = XIGetKnownProperty(AXIS_LABEL_PROP_REL_Y);
        case 1:
            labels[0] = XIGetKnownProperty(AXIS_LABEL_PROP_REL_X);
            break;
d1237 1
d1240 2
a1241 1
static void InitButtonLabels(Atom *labels, int nlabels)
d1244 17
a1260 18
    switch(nlabels)
    {
        default:
        case 7:
            labels[6] = XIGetKnownProperty(BTN_LABEL_PROP_BTN_HWHEEL_RIGHT);
        case 6:
            labels[5] = XIGetKnownProperty(BTN_LABEL_PROP_BTN_HWHEEL_LEFT);
        case 5:
            labels[4] = XIGetKnownProperty(BTN_LABEL_PROP_BTN_WHEEL_DOWN);
        case 4:
            labels[3] = XIGetKnownProperty(BTN_LABEL_PROP_BTN_WHEEL_UP);
        case 3:
            labels[2] = XIGetKnownProperty(BTN_LABEL_PROP_BTN_RIGHT);
        case 2:
            labels[1] = XIGetKnownProperty(BTN_LABEL_PROP_BTN_MIDDLE);
        case 1:
            labels[0] = XIGetKnownProperty(BTN_LABEL_PROP_BTN_LEFT);
            break;
d1263 51
d1315 1
d1327 1
a1327 1
#if GET_ABI_MAJOR(ABI_XINPUT_VERSION) >= 7
d1329 1
a1329 1
    Atom axes_labels[2] = { 0 };
d1332 15
a1346 1
    InitAxesLabels(axes_labels, 2);
a1347 1
#endif
d1352 1
a1352 1
	map[i] = i;
d1356 2
a1357 3
    InitPointerDeviceStruct((DevicePtr)dev, map,
			    SYN_MAX_BUTTONS,
#if GET_ABI_MAJOR(ABI_XINPUT_VERSION) >= 7
d1359 2
a1360 7
#endif
			    SynapticsCtrl,
			    GetMotionHistorySize(), 2
#if GET_ABI_MAJOR(ABI_XINPUT_VERSION) >= 7
                            , axes_labels
#endif
			    );
a1366 1
#if GET_ABI_MAJOR(ABI_XINPUT_VERSION) >= 7
d1368 2
a1369 2
	SetDeviceSpecificAccelerationProfile(pVel,
	                                     SynapticsAccelerationProfile);
d1371 2
a1372 2
	/* float property type */
	float_type = XIGetKnownProperty(XATOM_FLOAT);
d1374 28
a1401 27
	/* translate MinAcc to constant deceleration.
	 * May be overridden in xf86InitValuatorDefaults */
	tmpf = 1.0 / priv->synpara.min_speed;

	xf86IDrvMsg(pInfo, X_CONFIG, "(accel) MinSpeed is now constant deceleration "
		    "%.1f\n", tmpf);
	prop = XIGetKnownProperty(ACCEL_PROP_CONSTANT_DECELERATION);
	XIChangeDeviceProperty(dev, prop, float_type, 32,
	                       PropModeReplace, 1, &tmpf, FALSE);

	/* adjust accordingly */
	priv->synpara.max_speed /= priv->synpara.min_speed;
	priv->synpara.min_speed = 1.0;

	/* synaptics seems to report 80 packet/s, but dix scales for
	 * 100 packet/s by default. */
	pVel->corr_mul = 12.5f; /*1000[ms]/80[/s] = 12.5 */

	xf86IDrvMsg(pInfo, X_CONFIG, "MaxSpeed is now %.2f\n",
		    priv->synpara.max_speed);
	xf86IDrvMsg(pInfo, X_CONFIG, "AccelFactor is now %.3f\n",
		    priv->synpara.accl);

	prop = XIGetKnownProperty(ACCEL_PROP_PROFILE_NUMBER);
	i = AccelProfileDeviceSpecific;
	XIChangeDeviceProperty(dev, prop, XA_INTEGER, 32,
	                       PropModeReplace, 1, &i, FALSE);
a1402 1
#endif
d1405 1
a1405 2
    if (priv->minx < priv->maxx)
    {
d1408 2
a1409 2
    } else
    {
d1414 2
a1415 5
    xf86InitValuatorAxisStruct(dev, 0,
#if GET_ABI_MAJOR(ABI_XINPUT_VERSION) >= 7
            axes_labels[0],
#endif
            min, max, priv->resx * 1000, 0, priv->resx * 1000
d1417 1
a1417 1
            , Relative
d1419 1
a1419 1
            );
d1423 1
a1423 2
    if (priv->miny < priv->maxy)
    {
d1426 2
a1427 2
    } else
    {
d1432 2
a1433 5
    xf86InitValuatorAxisStruct(dev, 1,
#if GET_ABI_MAJOR(ABI_XINPUT_VERSION) >= 7
            axes_labels[1],
#endif
            min, max, priv->resy * 1000, 0, priv->resy * 1000
d1435 1
a1435 1
            , Relative
d1437 1
a1437 1
            );
d1440 37
d1478 1
a1478 1
	return !Success;
d1484 9
a1494 1

d1501 2
a1502 2
relative_coords(SynapticsPrivate *priv, int x, int y,
		double *relX, double *relY)
d1512 6
a1517 5
	*relX = (x - xCenter) / (maxX - xCenter);
	*relY = (y - yCenter) / (maxY - yCenter);
    } else {
	*relX = 0;
	*relY = 0;
d1523 1
a1523 1
angle(SynapticsPrivate *priv, int x, int y)
d1536 1
d1538 1
a1538 1
	da += 2 * M_PI;
d1540 1
a1540 1
	da -= 2 * M_PI;
d1545 1
a1545 1
circular_edge_detection(SynapticsPrivate *priv, int x, int y)
d1554 10
a1563 10
	/* we are outside the ellipse enclosed by the edge parameters */
	if (relX > M_SQRT1_2)
	    edge |= RIGHT_EDGE;
	else if (relX < -M_SQRT1_2)
	    edge |= LEFT_EDGE;

	if (relY < -M_SQRT1_2)
	    edge |= TOP_EDGE;
	else if (relY > M_SQRT1_2)
	    edge |= BOTTOM_EDGE;
d1570 1
a1570 1
edge_detection(SynapticsPrivate *priv, int x, int y)
d1575 1
a1575 1
	return circular_edge_detection(priv, x, y);
d1578 1
a1578 1
	edge |= RIGHT_EDGE;
d1580 1
a1580 1
	edge |= LEFT_EDGE;
d1583 1
a1583 1
	edge |= TOP_EDGE;
d1585 1
a1585 1
	edge |= BOTTOM_EDGE;
d1596 1
a1596 1
is_inside_active_area(SynapticsPrivate *priv, int x, int y)
d1600 6
a1605 4
    if ((priv->synpara.area_left_edge != 0) && (x < priv->synpara.area_left_edge))
	inside_area = FALSE;
    else if ((priv->synpara.area_right_edge != 0) && (x > priv->synpara.area_right_edge))
	inside_area = FALSE;
d1608 4
a1611 3
	inside_area = FALSE;
    else if ((priv->synpara.area_bottom_edge != 0) && (y > priv->synpara.area_bottom_edge))
	inside_area = FALSE;
d1616 39
d1660 1
a1660 1
    struct SynapticsHwState hw;
a1662 1
    CARD32 wakeUpTime;
d1666 4
a1669 12
    hw = priv->hwState;
    hw.millis = now;
    delay = HandleState(pInfo, &hw);

    /*
     * Workaround for wraparound bug in the TimerSet function. This bug is already
     * fixed in CVS, but this driver needs to work with XFree86 versions 4.2.x and
     * 4.3.x too.
     */
    wakeUpTime = now + delay;
    if (wakeUpTime <= now)
	wakeUpTime = 0xffffffffL;
d1671 2
a1672 1
    priv->timer = TimerSet(priv->timer, TimerAbsolute, wakeUpTime, timerFunc, pInfo);
d1683 1
a1683 1
	return min;
d1685 1
a1685 1
	return val;
d1687 1
a1687 1
	return max;
d1691 2
a1692 2
SynapticsGetHwState(InputInfoPtr pInfo, SynapticsPrivate *priv,
		    struct SynapticsHwState *hw)
d1704 1
a1704 1
    struct SynapticsHwState hw;
d1708 18
a1725 5
    while (SynapticsGetHwState(pInfo, priv, &hw)) {
	hw.millis = GetTimeInMillis();
	priv->hwState = hw;
	delay = HandleState(pInfo, &hw);
	newDelay = TRUE;
d1728 4
a1731 2
    if (newDelay)
	priv->timer = TimerSet(priv->timer, 0, delay, timerFunc, pInfo);
d1735 2
a1736 1
HandleMidButtonEmulation(SynapticsPrivate *priv, struct SynapticsHwState *hw, int *delay)
d1743 3
d1747 21
a1767 18
	switch (priv->mid_emu_state) {
	case MBE_LEFT_CLICK:
	case MBE_RIGHT_CLICK:
	case MBE_OFF:
	    priv->button_delay_millis = hw->millis;
	    if (hw->left) {
		priv->mid_emu_state = MBE_LEFT;
	    } else if (hw->right) {
		priv->mid_emu_state = MBE_RIGHT;
	    } else {
		done = TRUE;
	    }
	    break;
	case MBE_LEFT:
	    timeleft = TIME_DIFF(priv->button_delay_millis + para->emulate_mid_button_time,
				 hw->millis);
	    if (timeleft > 0)
		*delay = MIN(*delay, timeleft);
d1771 22
a1792 18
		priv->mid_emu_state = MBE_LEFT_CLICK;
		done = TRUE;
            } else if ((!hw->left) || (timeleft <= 0)) {
		hw->left = TRUE;
		priv->mid_emu_state = MBE_TIMEOUT;
		done = TRUE;
	    } else if (hw->right) {
		priv->mid_emu_state = MBE_MID;
	    } else {
		hw->left = FALSE;
		done = TRUE;
	    }
	    break;
	case MBE_RIGHT:
	    timeleft = TIME_DIFF(priv->button_delay_millis + para->emulate_mid_button_time,
				 hw->millis);
	    if (timeleft > 0)
		*delay = MIN(*delay, timeleft);
d1794 1
a1794 1
	     /* timeout, but within the same ReadInput cycle! */
d1796 34
a1829 29
		priv->mid_emu_state = MBE_RIGHT_CLICK;
		done = TRUE;
            } else if (!hw->right || (timeleft <= 0)) {
		hw->right = TRUE;
		priv->mid_emu_state = MBE_TIMEOUT;
		done = TRUE;
	    } else if (hw->left) {
		priv->mid_emu_state = MBE_MID;
	    } else {
		hw->right = FALSE;
		done = TRUE;
	    }
	    break;
	case MBE_MID:
	    if (!hw->left && !hw->right) {
		priv->mid_emu_state = MBE_OFF;
	    } else {
		mid = TRUE;
		hw->left = hw->right = FALSE;
		done = TRUE;
	    }
	    break;
	case MBE_TIMEOUT:
	    if (!hw->left && !hw->right) {
		priv->mid_emu_state = MBE_OFF;
	    } else {
		done = TRUE;
	    }
	}
d1835 1
a1835 1
SynapticsDetectFinger(SynapticsPrivate *priv, struct SynapticsHwState *hw)
d1841 6
d1849 1
a1849 1
    else if (hw->z > para->finger_high && priv->finger_state < FS_TOUCHED)
a1850 2
    else if (hw->z < para->finger_low &&  priv->finger_state > FS_UNTOUCHED)
        finger = FS_UNTOUCHED;
d1852 1
a1852 1
	finger = priv->finger_state;
d1855 1
a1855 1
	return finger;
d1858 6
a1863 8
    if (finger) {
	if ((hw->z > para->palm_min_z) && (hw->fingerWidth > para->palm_min_width))
	    priv->palm = TRUE;
    } else {
	priv->palm = FALSE;
    }
    if (hw->x == 0)
	priv->avg_width = 0;
d1865 16
a1880 15
	priv->avg_width += (hw->fingerWidth - priv->avg_width + 1) / 2;
    if (finger && !priv->finger_state) {
	int safe_width = MAX(hw->fingerWidth, priv->avg_width);

	if (hw->numFingers > 1 ||	/* more than one finger -> not a palm */
	    ((safe_width < 6) && (priv->prev_z < para->finger_high)) ||  /* thin finger, distinct touch -> not a palm */
	    ((safe_width < 7) && (priv->prev_z < para->finger_high / 2)))/* thin finger, distinct touch -> not a palm */
	{
	    /* leave finger value as is */
	} else if (hw->z > priv->prev_z + 1)	/* z not stable, may be a palm */
	    finger = FS_UNTOUCHED;
	else if (hw->z < priv->prev_z - 5)	/* z not stable, may be a palm */
	    finger = FS_UNTOUCHED;
	else if (hw->fingerWidth > para->palm_min_width) /* finger width too large -> probably palm */
	    finger = FS_UNTOUCHED;
a1883 3
    if (priv->palm)
	finger = FS_UNTOUCHED;

d1888 1
a1888 1
SelectTapButton(SynapticsPrivate *priv, edge_type edge)
d1893 2
a1894 2
	priv->tap_button = 0;
	return;
d1899 23
a1921 24
    default:
	switch (edge) {
	case RIGHT_TOP_EDGE:
	    DBG(7, "right top edge\n");
	    tap = RT_TAP;
	    break;
	case RIGHT_BOTTOM_EDGE:
	    DBG(7, "right bottom edge\n");
	    tap = RB_TAP;
	    break;
	case LEFT_TOP_EDGE:
	    DBG(7, "left top edge\n");
	    tap = LT_TAP;
	    break;
	case LEFT_BOTTOM_EDGE:
	    DBG(7, "left bottom edge\n");
	    tap = LB_TAP;
	    break;
	default:
	    DBG(7, "no edge\n");
	    tap = F1_TAP;
	    break;
	}
	break;
d1923 3
a1925 3
	DBG(7, "two finger tap\n");
	tap = F2_TAP;
	break;
d1927 6
a1932 3
	DBG(7, "three finger tap\n");
	tap = F3_TAP;
	break;
d1940 1
a1940 1
SetTapState(SynapticsPrivate *priv, enum TapState tap_state, int millis)
d1943 3
a1945 1
    DBG(7, "SetTapState - %d -> %d (millis:%d)\n", priv->tap_state, tap_state, millis);
d1948 3
a1950 3
	priv->tap_button_state = TBS_BUTTON_UP;
	priv->tap_max_fingers = 0;
	break;
d1952 2
a1953 2
	priv->tap_button_state = TBS_BUTTON_UP;
	break;
d1955 5
a1959 5
	if (para->fast_taps)
	    priv->tap_button_state = TBS_BUTTON_DOWN;
	else
	    priv->tap_button_state = TBS_BUTTON_UP;
	break;
d1961 2
a1962 2
	priv->tap_button_state = TBS_BUTTON_UP;
	break;
d1964 2
a1965 5
	if (para->tap_and_drag_gesture)
	    priv->tap_button_state = TBS_BUTTON_DOWN;
	else
	    priv->tap_button_state = TBS_BUTTON_UP;
	break;
d1967 6
a1972 6
	if (para->fast_taps)
	    priv->tap_button_state = TBS_BUTTON_UP;
	else
	    priv->tap_button_state = TBS_BUTTON_DOWN;
	priv->touch_on.millis = millis;
	break;
d1974 1
a1974 1
	break;
d1980 2
a1981 1
SetMovingState(SynapticsPrivate *priv, enum MovingState moving_state, int millis)
d1983 3
a1985 2
    DBG(7, "SetMovingState - %d -> %d center at %d/%d (millis:%d)\n", priv->moving_state,
		  moving_state,priv->hwState.x, priv->hwState.y, millis);
d1988 2
a1989 2
	priv->trackstick_neutral_x = priv->hwState.x;
	priv->trackstick_neutral_y = priv->hwState.y;
d1995 1
a1995 1
GetTimeOut(SynapticsPrivate *priv)
d2003 1
a2003 1
	return para->tap_time;
d2005 1
a2005 1
	return para->click_time;
d2007 1
a2007 1
	return para->single_tap_timeout;
d2009 1
a2009 1
	return para->tap_time_2;
d2011 1
a2011 1
	return para->locked_drag_time;
d2013 1
a2013 1
	return -1;			    /* No timeout */
d2018 3
a2020 2
HandleTapProcessing(SynapticsPrivate *priv, struct SynapticsHwState *hw,
		    enum FingerState finger, Bool inside_active_area)
d2023 1
a2023 1
    Bool touch, release, is_timeout, move;
d2028 2
a2029 2
    if (priv->palm)
	return delay;
d2031 9
a2039 6
    touch = finger && !priv->finger_state;
    release = !finger && priv->finger_state;
    move = (finger &&
	     (priv->tap_max_fingers <= ((priv->horiz_scroll_twofinger_on || priv->vert_scroll_twofinger_on)? 2 : 1)) &&
	     ((abs(hw->x - priv->touch_on.x) >= para->tap_move) ||
	     (abs(hw->y - priv->touch_on.y) >= para->tap_move)));
d2042 6
a2047 5
	priv->touch_on.x = hw->x;
	priv->touch_on.y = hw->y;
	priv->touch_on.millis = hw->millis;
    } else if (release) {
	priv->touch_on.millis = hw->millis;
d2050 2
a2051 2
	if (priv->tap_max_fingers < hw->numFingers)
	    priv->tap_max_fingers = hw->numFingers;
d2053 1
a2053 1
    timeleft = TIME_DIFF(priv->touch_on.millis + timeout, hw->millis);
d2059 3
a2061 3
	if (touch)
	    SetTapState(priv, TS_1, hw->millis);
	break;
d2063 29
a2091 22
	if (move) {
	    SetMovingState(priv, MS_TOUCHPAD_RELATIVE, hw->millis);
	    SetTapState(priv, TS_MOVE, hw->millis);
	    goto restart;
	} else if (is_timeout) {
	    if (finger == FS_TOUCHED) {
		SetMovingState(priv, MS_TOUCHPAD_RELATIVE, hw->millis);
	    } else if (finger == FS_PRESSED) {
		SetMovingState(priv, MS_TRACKSTICK, hw->millis);
	    }
	    SetTapState(priv, TS_MOVE, hw->millis);
	    goto restart;
	} else if (release) {
	    edge = edge_detection(priv, priv->touch_on.x, priv->touch_on.y);
	    SelectTapButton(priv, edge);
	    /* Disable taps outside of the active area */
	    if (!inside_active_area) {
		priv->tap_button = 0;
	    }
	    SetTapState(priv, TS_2A, hw->millis);
	}
	break;
d2093 12
a2104 8
	if (move && priv->moving_state == MS_TRACKSTICK) {
	    SetMovingState(priv, MS_TOUCHPAD_RELATIVE, hw->millis);
	}
	if (release) {
	    SetMovingState(priv, MS_FALSE, hw->millis);
	    SetTapState(priv, TS_START, hw->millis);
	}
	break;
d2106 5
a2110 5
	if (touch)
	    SetTapState(priv, TS_3, hw->millis);
	else if (is_timeout)
	    SetTapState(priv, TS_SINGLETAP, hw->millis);
	break;
d2112 8
a2119 7
	if (touch) {
	    SetTapState(priv, TS_3, hw->millis);
	} else if (is_timeout) {
	    SetTapState(priv, TS_START, hw->millis);
	    priv->tap_button_state = TBS_BUTTON_DOWN_UP;
	}
	break;
d2121 5
a2125 5
	if (touch)
	    SetTapState(priv, TS_1, hw->millis);
	else if (is_timeout)
	    SetTapState(priv, TS_START, hw->millis);
	break;
d2127 29
a2155 24
	if (move) {
	    if (para->tap_and_drag_gesture) {
		SetMovingState(priv, MS_TOUCHPAD_RELATIVE, hw->millis);
		SetTapState(priv, TS_DRAG, hw->millis);
	    } else {
		SetTapState(priv, TS_1, hw->millis);
	    }
	    goto restart;
	} else if (is_timeout) {
	    if (para->tap_and_drag_gesture) {
		if (finger == FS_TOUCHED) {
		    SetMovingState(priv, MS_TOUCHPAD_RELATIVE, hw->millis);
		} else if (finger == FS_PRESSED) {
		    SetMovingState(priv, MS_TRACKSTICK, hw->millis);
		}
		SetTapState(priv, TS_DRAG, hw->millis);
	    } else {
		SetTapState(priv, TS_1, hw->millis);
	    }
	    goto restart;
	} else if (release) {
	    SetTapState(priv, TS_2B, hw->millis);
	}
	break;
d2157 16
a2172 11
	if (move)
	    SetMovingState(priv, MS_TOUCHPAD_RELATIVE, hw->millis);
	if (release) {
	    SetMovingState(priv, MS_FALSE, hw->millis);
	    if (para->locked_drags) {
		SetTapState(priv, TS_4, hw->millis);
	    } else {
		SetTapState(priv, TS_START, hw->millis);
	    }
	}
	break;
d2174 7
a2180 7
	if (is_timeout) {
	    SetTapState(priv, TS_START, hw->millis);
	    goto restart;
	}
	if (touch)
	    SetTapState(priv, TS_5, hw->millis);
	break;
d2182 26
a2207 8
	if (is_timeout || move) {
	    SetTapState(priv, TS_DRAG, hw->millis);
	    goto restart;
	} else if (release) {
	    SetMovingState(priv, MS_FALSE, hw->millis);
	    SetTapState(priv, TS_START, hw->millis);
	}
	break;
d2212 2
a2213 2
	timeleft = TIME_DIFF(priv->touch_on.millis + timeout, hw->millis);
	delay = clamp(timeleft, 1, delay);
d2219 1
d2222 1
a2222 1
store_history(SynapticsPrivate *priv, int x, int y, unsigned int millis)
d2225 1
d2230 2
d2253 3
a2255 1
static int hysteresis(int in, int center, int margin) {
d2257 1
d2259 7
a2265 5
	diff = 0;
    } else if (diff > margin) {
	diff -= margin;
    } else if (diff < -margin) {
	diff += margin;
d2271 3
a2273 2
get_delta_for_trackstick(SynapticsPrivate *priv, const struct SynapticsHwState *hw,
                         double *dx, double *dy)
d2286 1
a2286 1
get_edge_speed(SynapticsPrivate *priv, const struct SynapticsHwState *hw,
d2299 2
a2300 1
    } else if (hw->z >= maxZ) {
d2302 4
a2305 2
    } else {
        edge_speed = minSpd + (hw->z - minZ) * (maxSpd - minSpd) / (maxZ - minZ);
d2311 2
a2312 1
        } else if (edge & LEFT_EDGE) {
d2317 2
a2318 1
        } else if (edge & BOTTOM_EDGE) {
d2321 2
a2322 1
    } else if (edge) {
d2327 2
a2328 2
        *x_edge_speed = (int)(edge_speed * relX);
        *y_edge_speed = (int)(edge_speed * relY);
d2333 1
a2333 1
get_delta(SynapticsPrivate *priv, const struct SynapticsHwState *hw,
d2343 2
a2344 3
    /* HIST is full enough: priv->count_packet_finger > 3 */
    *dx = estimate_delta(hw->x, HIST(0).x, HIST(1).x, HIST(2).x);
    *dy = estimate_delta(hw->y, HIST(0).y, HIST(1).y, HIST(2).y);
d2351 8
d2371 2
a2372 2
ComputeDeltas(SynapticsPrivate *priv, const struct SynapticsHwState *hw,
	      edge_type edge, int *dxP, int *dyP, Bool inside_area)
d2382 20
a2401 21
	switch (priv->tap_state) {
	case TS_MOVE:
	case TS_DRAG:
	    moving_state = MS_TOUCHPAD_RELATIVE;
	    break;
	case TS_1:
	case TS_3:
	case TS_5:
	    if (hw->numFingers == 1)
		moving_state = MS_TOUCHPAD_RELATIVE;
	    break;
	default:
	    break;
	}
    }

    if (!inside_area || !moving_state || priv->palm ||
	priv->vert_scroll_edge_on || priv->horiz_scroll_edge_on ||
	priv->vert_scroll_twofinger_on || priv->horiz_scroll_twofinger_on ||
	priv->circ_scroll_on || priv->prevFingers != hw->numFingers)
    {
d2407 4
a2410 3
    /* to create fluid edge motion, call back 'soon'
     * even in the absence of new hardware events */
    delay = MIN(delay, 13);
d2412 2
a2413 2
    if (priv->count_packet_finger <= 3) /* min. 3 packets, see get_delta() */
        goto skip; /* skip the lot */
d2420 1
a2420 3
skip:
    priv->count_packet_finger++;
out:
a2428 4
struct ScrollData {
    int left, right, up, down;
};

d2430 1
a2430 1
estimate_delta_circ(SynapticsPrivate *priv)
d2432 9
a2440 8
	double a1 = angle(priv, HIST(3).x, HIST(3).y);
	double a2 = angle(priv, HIST(2).x, HIST(2).y);
	double a3 = angle(priv, HIST(1).x, HIST(1).y);
	double a4 = angle(priv, HIST(0).x, HIST(0).y);
	double d1 = diffa(a2, a1);
	double d2 = d1 + diffa(a3, a2);
	double d3 = d2 + diffa(a4, a3);
	return estimate_delta(d3, d2, d1, 0);
d2447 2
a2448 2
start_coasting(SynapticsPrivate *priv, struct SynapticsHwState *hw,
	       Bool vert, Bool horiz, Bool circ)
d2452 32
a2483 2
    priv->autoscroll_y = 0.0;
    priv->autoscroll_x = 0.0;
d2485 21
a2505 43
    if ((priv->scroll_packet_count > 3) && (para->coasting_speed > 0.0)) {
	double pkt_time = (HIST(0).millis - HIST(3).millis) / 1000.0;
	if (vert && !circ) {
	    double dy = estimate_delta(HIST(0).y, HIST(1).y, HIST(2).y, HIST(3).y);
	    int sdelta = para->scroll_dist_vert;
	    if (pkt_time > 0 && sdelta > 0) {
		double scrolls_per_sec = dy / pkt_time / sdelta;
		if (fabs(scrolls_per_sec) >= para->coasting_speed) {
		    priv->autoscroll_yspd = scrolls_per_sec;
		    priv->autoscroll_y = (hw->y - priv->scroll_y) / (double)sdelta;
		}
	    }
	}
	if (horiz && !circ){
	    double dx = estimate_delta(HIST(0).x, HIST(1).x, HIST(2).x, HIST(3).x);
	    int sdelta = para->scroll_dist_horiz;
	    if (pkt_time > 0 && sdelta > 0) {
		double scrolls_per_sec = dx / pkt_time / sdelta;
		if (fabs(scrolls_per_sec) >= para->coasting_speed) {
		    priv->autoscroll_xspd = scrolls_per_sec;
		    priv->autoscroll_x = (hw->x - priv->scroll_x) / (double)sdelta;
		}
	    }
	}
	if (circ) {
	    double da = estimate_delta_circ(priv);
	    double sdelta = para->scroll_dist_circ;
	    if (pkt_time > 0 && sdelta > 0) {
	        double scrolls_per_sec = da / pkt_time / sdelta;
	        if (fabs(scrolls_per_sec) >= para->coasting_speed) {
	            if (vert) {
	                priv->autoscroll_yspd = scrolls_per_sec;
	                priv->autoscroll_y = diffa(priv->scroll_a, angle(priv, hw->x, hw->y)) / sdelta;
	            }
	            else if (horiz) {
	                priv->autoscroll_xspd = scrolls_per_sec;
	                priv->autoscroll_x = diffa(priv->scroll_a, angle(priv, hw->x, hw->y)) / sdelta;
	            }
	        }
	    }
	}
    }
    priv->scroll_packet_count = 0;
d2509 5
a2513 5
stop_coasting(SynapticsPrivate *priv)
{
    priv->autoscroll_xspd = 0;
    priv->autoscroll_yspd = 0;
    priv->scroll_packet_count = 0;
d2517 2
a2518 2
HandleScrolling(SynapticsPrivate *priv, struct SynapticsHwState *hw,
		edge_type edge, Bool finger, struct ScrollData *sd)
d2523 8
a2530 10
    sd->left = sd->right = sd->up = sd->down = 0;

    if (priv->synpara.touchpad_off == 2) {
	stop_coasting(priv);
	priv->circ_scroll_on = FALSE;
	priv->vert_scroll_edge_on = FALSE;
	priv->horiz_scroll_edge_on = FALSE;
	priv->vert_scroll_twofinger_on = FALSE;
	priv->horiz_scroll_twofinger_on = FALSE;
	return delay;
d2534 24
a2557 18
    if (finger && !priv->finger_state) {
	stop_coasting(priv);
	if (para->circular_scrolling) {
	    if ((para->circular_trigger == 0 && edge) ||
		(para->circular_trigger == 1 && edge & TOP_EDGE) ||
		(para->circular_trigger == 2 && edge & TOP_EDGE && edge & RIGHT_EDGE) ||
		(para->circular_trigger == 3 && edge & RIGHT_EDGE) ||
		(para->circular_trigger == 4 && edge & RIGHT_EDGE && edge & BOTTOM_EDGE) ||
		(para->circular_trigger == 5 && edge & BOTTOM_EDGE) ||
		(para->circular_trigger == 6 && edge & BOTTOM_EDGE && edge & LEFT_EDGE) ||
		(para->circular_trigger == 7 && edge & LEFT_EDGE) ||
		(para->circular_trigger == 8 && edge & LEFT_EDGE && edge & TOP_EDGE)) {
		priv->circ_scroll_on = TRUE;
		priv->circ_scroll_vert = TRUE;
		priv->scroll_a = angle(priv, hw->x, hw->y);
		DBG(7, "circular scroll detected on edge\n");
	    }
	}
d2560 39
a2598 34
	if (finger) {
	    if (hw->numFingers == 2) {
		if (!priv->vert_scroll_twofinger_on &&
		    (para->scroll_twofinger_vert) && (para->scroll_dist_vert != 0)) {
		    priv->vert_scroll_twofinger_on = TRUE;
		    priv->vert_scroll_edge_on = FALSE;
		    priv->scroll_y = hw->y;
		    DBG(7, "vert two-finger scroll detected\n");
		}
		if (!priv->horiz_scroll_twofinger_on &&
		    (para->scroll_twofinger_horiz) && (para->scroll_dist_horiz != 0)) {
		    priv->horiz_scroll_twofinger_on = TRUE;
		    priv->horiz_scroll_edge_on = FALSE;
		    priv->scroll_x = hw->x;
		    DBG(7, "horiz two-finger scroll detected\n");
		}
	    }
	}
	if (finger && !priv->finger_state) {
	    if (!priv->vert_scroll_twofinger_on && !priv->horiz_scroll_twofinger_on) {
		if ((para->scroll_edge_vert) && (para->scroll_dist_vert != 0) &&
		    (edge & RIGHT_EDGE)) {
		    priv->vert_scroll_edge_on = TRUE;
		    priv->scroll_y = hw->y;
		    DBG(7, "vert edge scroll detected on right edge\n");
		}
		if ((para->scroll_edge_horiz) && (para->scroll_dist_horiz != 0) &&
		    (edge & BOTTOM_EDGE)) {
		    priv->horiz_scroll_edge_on = TRUE;
		    priv->scroll_x = hw->x;
		    DBG(7, "horiz edge scroll detected on bottom edge\n");
		}
	    }
	}
d2601 25
a2625 2
	Bool oldv = priv->vert_scroll_twofinger_on || priv->vert_scroll_edge_on ||
	              (priv->circ_scroll_on && priv->circ_scroll_vert);
d2627 30
a2656 2
	Bool oldh = priv->horiz_scroll_twofinger_on || priv->horiz_scroll_edge_on ||
	              (priv->circ_scroll_on && !priv->circ_scroll_vert);
d2658 1
a2658 1
	Bool oldc = priv->circ_scroll_on;
d2660 3
a2662 49
	if (priv->circ_scroll_on && !finger) {
	    /* circular scroll locks in until finger is raised */
	    DBG(7, "cicular scroll off\n");
	    priv->circ_scroll_on = FALSE;
	}

	if (!finger || hw->numFingers != 2) {
	    if (priv->vert_scroll_twofinger_on) {
		DBG(7, "vert two-finger scroll off\n");
		priv->vert_scroll_twofinger_on = FALSE;
	    }
	    if (priv->horiz_scroll_twofinger_on) {
		DBG(7, "horiz two-finger scroll off\n");
		priv->horiz_scroll_twofinger_on = FALSE;
	    }
	}

	if (priv->vert_scroll_edge_on && (!(edge & RIGHT_EDGE) || !finger)) {
	    DBG(7, "vert edge scroll off\n");
	    priv->vert_scroll_edge_on = FALSE;
	}
	if (priv->horiz_scroll_edge_on && (!(edge & BOTTOM_EDGE) || !finger)) {
	    DBG(7, "horiz edge scroll off\n");
	    priv->horiz_scroll_edge_on = FALSE;
	}
	/* If we were corner edge scrolling (coasting),
	 * but no longer in corner or raised a finger, then stop coasting. */
	if (para->scroll_edge_corner && (priv->autoscroll_xspd || priv->autoscroll_yspd)) {
	    Bool is_in_corner =
		((edge & RIGHT_EDGE)  && (edge & (TOP_EDGE | BOTTOM_EDGE))) ||
		((edge & BOTTOM_EDGE) && (edge & (LEFT_EDGE | RIGHT_EDGE))) ;
	    if (!is_in_corner || !finger) {
		DBG(7, "corner edge scroll off\n");
		stop_coasting(priv);
	    }
	}
	/* if we were scrolling, but couldn't corner edge scroll,
	 * and are no longer scrolling, then start coasting */
	oldv = oldv && !(priv->vert_scroll_twofinger_on || priv->vert_scroll_edge_on ||
	              (priv->circ_scroll_on && priv->circ_scroll_vert));

	oldh = oldh && !(priv->horiz_scroll_twofinger_on || priv->horiz_scroll_edge_on ||
	              (priv->circ_scroll_on && !priv->circ_scroll_vert));

	oldc = oldc && !priv->circ_scroll_on;

	if ((oldv || oldh) && !para->scroll_edge_corner) {
	    start_coasting(priv, hw, oldv, oldh, oldc);
	}
d2669 17
a2685 16
	(edge & RIGHT_EDGE) && (edge & (TOP_EDGE | BOTTOM_EDGE))) {
	if (para->scroll_edge_corner) {
	    if (priv->autoscroll_yspd == 0) {
		/* FYI: We can generate multiple start_coasting requests if
		 * we're in the corner, but we were moving so slowly when we
		 * got here that we didn't actually start coasting. */
		DBG(7, "corner edge scroll on\n");
		start_coasting(priv, hw, TRUE, FALSE, FALSE);
	    }
	} else if (para->circular_scrolling) {
	    priv->vert_scroll_edge_on = FALSE;
	    priv->circ_scroll_on = TRUE;
	    priv->circ_scroll_vert = TRUE;
	    priv->scroll_a = angle(priv, hw->x, hw->y);
	    DBG(7, "switching to circular scrolling\n");
	}
d2689 17
a2705 16
	(edge & BOTTOM_EDGE) && (edge & (LEFT_EDGE | RIGHT_EDGE))) {
	if (para->scroll_edge_corner) {
	    if (priv->autoscroll_xspd == 0) {
		/* FYI: We can generate multiple start_coasting requests if
		 * we're in the corner, but we were moving so slowly when we
		 * got here that we didn't actually start coasting. */
		DBG(7, "corner edge scroll on\n");
		start_coasting(priv, hw, FALSE, TRUE, FALSE);
	    }
	} else if (para->circular_scrolling) {
	    priv->horiz_scroll_edge_on = FALSE;
	    priv->circ_scroll_on = TRUE;
	    priv->circ_scroll_vert = FALSE;
	    priv->scroll_a = angle(priv, hw->x, hw->y);
	    DBG(7, "switching to circular scrolling\n");
	}
d2709 3
a2711 3
	priv->vert_scroll_twofinger_on || priv->horiz_scroll_twofinger_on ||
	priv->circ_scroll_on) {
	priv->scroll_packet_count++;
d2715 5
a2719 12
	/* + = down, - = up */
	int delta = para->scroll_dist_vert;
	if (delta > 0) {
	    while (hw->y - priv->scroll_y > delta) {
		sd->down++;
		priv->scroll_y += delta;
	    }
	    while (hw->y - priv->scroll_y < -delta) {
		sd->up++;
		priv->scroll_y -= delta;
	    }
	}
d2722 5
a2726 12
	/* + = right, - = left */
	int delta = para->scroll_dist_horiz;
	if (delta > 0) {
	    while (hw->x - priv->scroll_x > delta) {
		sd->right++;
		priv->scroll_x += delta;
	    }
	    while (hw->x - priv->scroll_x < -delta) {
		sd->left++;
		priv->scroll_x -= delta;
	    }
	}
d2729 42
a2770 64
	/* + = counter clockwise, - = clockwise */
	double delta = para->scroll_dist_circ;
	if (delta >= 0.005) {
	    while (diffa(priv->scroll_a, angle(priv, hw->x, hw->y)) > delta) {
		if (priv->circ_scroll_vert)
		    sd->up++;
		else
		    sd->right++;
		priv->scroll_a += delta;
		if (priv->scroll_a > M_PI)
		    priv->scroll_a -= 2 * M_PI;
	    }
	    while (diffa(priv->scroll_a, angle(priv, hw->x, hw->y)) < -delta) {
		if (priv->circ_scroll_vert)
		    sd->down++;
		else
		    sd->left++;
		priv->scroll_a -= delta;
		if (priv->scroll_a < -M_PI)
		    priv->scroll_a += 2 * M_PI;
	    }
	}
    }

    if (priv->autoscroll_yspd) {
	double dtime = (hw->millis - HIST(0).millis) / 1000.0;
	double ddy = para->coasting_friction * dtime;
	priv->autoscroll_y += priv->autoscroll_yspd * dtime;
	delay = MIN(delay, 20);
	while (priv->autoscroll_y > 1.0) {
	    sd->down++;
	    priv->autoscroll_y -= 1.0;
	}
	while (priv->autoscroll_y < -1.0) {
	    sd->up++;
	    priv->autoscroll_y += 1.0;
	}
	if (abs(priv->autoscroll_yspd) < ddy) {
	    priv->autoscroll_yspd = 0;
	    priv->scroll_packet_count = 0;
	} else {
	    priv->autoscroll_yspd += (priv->autoscroll_yspd < 0 ? ddy : -1*ddy);
	}
    }

    if (priv->autoscroll_xspd) {
	double dtime = (hw->millis - HIST(0).millis) / 1000.0;
	double ddx = para->coasting_friction * dtime;
	priv->autoscroll_x += priv->autoscroll_xspd * dtime;
	delay = MIN(delay, 20);
	while (priv->autoscroll_x > 1.0) {
	    sd->right++;
	    priv->autoscroll_x -= 1.0;
	}
	while (priv->autoscroll_x < -1.0) {
	    sd->left++;
	    priv->autoscroll_x += 1.0;
	}
	if (abs(priv->autoscroll_xspd) < ddx) {
	    priv->autoscroll_xspd = 0;
	    priv->scroll_packet_count = 0;
	} else {
	    priv->autoscroll_xspd += (priv->autoscroll_xspd < 0 ? ddx : -1*ddx);
	}
d2776 59
d2836 1
a2836 1
handle_clickfinger(SynapticsParameters *para, struct SynapticsHwState *hw)
d2838 1
d2840 21
a2860 10
    switch(hw->numFingers){
        case 1:
            action = para->click_action[F1_CLICK1];
            break;
        case 2:
            action = para->click_action[F2_CLICK1];
            break;
        case 3:
            action = para->click_action[F3_CLICK1];
            break;
d2862 12
a2873 12
    switch(action){
        case 1:
            hw->left = 1;
            break;
        case 2:
            hw->left = 0;
            hw->middle = 1;
            break;
        case 3:
            hw->left = 0;
            hw->right = 1;
            break;
a2876 1

d2888 1
a2888 1
	    return;
d2900 1
a2900 1
	    shm->multi[i] = hw->multi[i];
d2910 2
a2911 1
adjust_state_from_scrollbuttons(const InputInfoPtr pInfo, struct SynapticsHwState *hw)
d2918 9
a2926 9
	if (hw->down) {		/* map down button to middle button */
	    hw->middle = TRUE;
	}

	if (hw->up) {		/* up button generates double click */
	    if (!priv->prev_up)
		double_click = TRUE;
	}
	priv->prev_up = hw->up;
d2928 2
a2929 2
	/* reset up/down button events */
	hw->up = hw->down = FALSE;
d2934 2
a2935 2
	if (hw->multi[2] || hw->multi[3])
	    hw->middle = TRUE;
d2937 2
a2938 2
	/* reset left/right button events */
	hw->multi[2] = hw->multi[3] = FALSE;
d2945 2
a2946 1
update_hw_button_state(const InputInfoPtr pInfo, struct SynapticsHwState *hw, int *delay)
d2956 1
a2956 1
    hw->middle |= HandleMidButtonEmulation(priv, hw, delay);
d2958 28
a2985 3
    /* Fingers emulate other buttons */
    if(hw->left && hw->numFingers >= 1){
        handle_clickfinger(para, hw);
d2991 1
a2991 1
	hw->numFingers = 2;
a3001 1

d3003 1
a3003 1
post_scroll_events(const InputInfoPtr pInfo, struct ScrollData scroll)
d3005 23
a3027 1
    while (scroll.up-- > 0)
d3029 2
d3032 1
a3032 1
    while (scroll.down-- > 0)
d3034 2
d3037 1
a3037 1
    while (scroll.left-- > 0)
d3039 2
d3042 1
a3042 1
    while (scroll.right-- > 0)
d3044 3
d3052 1
a3052 1
		     int buttons, int delay)
d3057 6
a3062 2
    int rep_buttons = ((para->updown_button_repeat ? 0x18 : 0) |
			(para->leftright_button_repeat ? 0x60 : 0));
d3067 11
a3077 10
	 para->updown_button_scrolling) ||
	((hw->multi[2] || hw->multi[3]) && para->leftright_button_repeat &&
	 para->leftright_button_scrolling)) {
	priv->repeatButtons = buttons & rep_buttons;
	if (!priv->nextRepeat) {
	    priv->nextRepeat = hw->millis + repeat_delay * 2;
	}
    } else {
	priv->repeatButtons = 0;
	priv->nextRepeat = 0;
d3081 23
a3103 16
	timeleft = TIME_DIFF(priv->nextRepeat, hw->millis);
	if (timeleft > 0)
	    delay = MIN(delay, timeleft);
	if (timeleft <= 0) {
	    int change, id;
	    change = priv->repeatButtons;
	    while (change) {
		id = ffs(change);
		change &= ~(1 << (id - 1));
		xf86PostButtonEvent(pInfo->dev, FALSE, id, FALSE, 0, 0);
		xf86PostButtonEvent(pInfo->dev, FALSE, id, TRUE, 0, 0);
	    }

	    priv->nextRepeat = hw->millis + repeat_delay;
	    delay = MIN(delay, repeat_delay);
	}
d3109 137
d3251 4
d3257 2
a3258 1
HandleState(InputInfoPtr pInfo, struct SynapticsHwState *hw)
d3262 2
a3263 2
    int finger;
    int dx, dy, buttons, id;
a3265 1
    struct ScrollData scroll;
d3274 11
a3284 2
    if (para->touchpad_off == 1)
	return delay;
d3289 1
a3289 4
    priv->hyst_center_x = hysteresis(hw->x, priv->hyst_center_x, para->hyst_x);
    priv->hyst_center_y = hysteresis(hw->y, priv->hyst_center_y, para->hyst_y);
    hw->x = priv->hyst_center_x;
    hw->y = priv->hyst_center_y;
d3296 3
a3298 13
    */
    if (!inside_active_area)
    {
	hw->x = 0;
	hw->y = 0;
	hw->z = 0;
	hw->numFingers = 0;
	hw->fingerWidth = 0;

	/* FIXME: if finger accidentally moves into the area and doesn't
	 * really release, the finger should remain down. */
	finger = FS_UNTOUCHED;
	edge = NO_EDGE;
d3300 2
a3301 1
	dx = dy = 0;
d3305 1
a3305 1
    update_hw_button_state(pInfo, hw, &delay);
d3307 1
a3307 1
	double_click = adjust_state_from_scrollbuttons(pInfo, hw);
d3311 5
a3315 2
	edge = edge_detection(priv, hw->x, hw->y);
	finger = SynapticsDetectFinger(priv, hw);
d3320 1
a3320 1
    timeleft = HandleTapProcessing(priv, hw, finger, inside_active_area);
d3322 1
a3322 1
	delay = MIN(delay, timeleft);
d3324 12
a3335 13
    if (inside_active_area)
    {
	/* Don't bother about scrolling in the dead area of the touchpad. */
	timeleft = HandleScrolling(priv, hw, edge, finger, &scroll);
	if (timeleft > 0)
	    delay = MIN(delay, timeleft);

	/*
	 * Compensate for unequal x/y resolution. This needs to be done after
	 * calculations that require unadjusted coordinates, for example edge
	 * detection.
	 */
	ScaleCoordinates(priv, hw);
d3341 2
a3342 2
      timeleft = ComputeDeltas(priv, hw, edge, &dx, &dy, inside_active_area);
      delay = MIN(delay, timeleft);
d3345 6
d3352 2
a3353 7
    buttons = ((hw->left     ? 0x01 : 0) |
	       (hw->middle   ? 0x02 : 0) |
	       (hw->right    ? 0x04 : 0) |
	       (hw->up       ? 0x08 : 0) |
	       (hw->down     ? 0x10 : 0) |
	       (hw->multi[2] ? 0x20 : 0) |
	       (hw->multi[3] ? 0x40 : 0));
d3355 10
a3364 11
    if (priv->tap_button > 0) {
	int tap_mask = 1 << (priv->tap_button - 1);
	if (priv->tap_button_state == TBS_BUTTON_DOWN_UP) {
	    if (tap_mask != (priv->lastButtons & tap_mask)) {
		xf86PostButtonEvent(pInfo->dev, FALSE, priv->tap_button, TRUE, 0, 0);
		priv->lastButtons |= tap_mask;
	    }
	    priv->tap_button_state = TBS_BUTTON_UP;
	}
	if (priv->tap_button_state == TBS_BUTTON_DOWN)
	    buttons |= tap_mask;
d3368 1
a3368 1
    if (finger > FS_UNTOUCHED) {
d3371 2
a3372 1
        } else if (dx || dy) {
d3377 7
a3383 8
    if (priv->mid_emu_state == MBE_LEFT_CLICK)
    {
	post_button_click(pInfo, 1);
	priv->mid_emu_state = MBE_OFF;
    } else if (priv->mid_emu_state == MBE_RIGHT_CLICK)
    {
	post_button_click(pInfo, 3);
	priv->mid_emu_state = MBE_OFF;
d3388 4
a3391 3
	id = ffs(change); /* number of first set bit 1..32 is returned */
	change &= ~(1 << (id - 1));
	xf86PostButtonEvent(pInfo->dev, FALSE, id, (buttons & (1 << (id - 1))), 0, 0);
d3394 3
d3400 5
a3404 2
    if (inside_active_area)
	post_scroll_events(pInfo, scroll);
d3407 2
a3408 2
	post_button_click(pInfo, 1);
	post_button_click(pInfo, 1);
d3411 1
a3411 2
    if (priv->has_scrollbuttons)
	delay = repeat_scrollbuttons(pInfo, hw, buttons, delay);
d3419 4
a3422 1
	store_history(priv, hw->x, hw->y, hw->millis);
a3433 1

d3464 1
a3464 1
	priv->proto_ops->ReadDevDimensions(pInfo);
d3477 2
a3478 2
	xf86IDrvMsg(pInfo, X_PROBED, "no supported touchpad found\n");
	if (priv->proto_ops->DeviceOffHook)
d3487 1
a3487 1
ScaleCoordinates(SynapticsPrivate *priv, struct SynapticsHwState *hw)
d3497 1
a3497 1
CalculateScalingCoeffs(SynapticsPrivate *priv)
d3503 1
a3503 1
        priv->horiz_coeff = vertRes / (double)horizRes;
d3505 2
a3506 1
    } else if ((horizRes < vertRes) && (vertRes > 0)) {
d3508 3
a3510 2
        priv->vert_coeff = horizRes / (double)vertRes;
    } else {
@


1.3
log
@Update to xf86-input-synaptics 1.5.0.
ok mpi@@, matthieu@@
@
text
@d264 7
d591 7
d600 7
a606 3
                                          float velocity,
                                          float thr,
                                          float acc) {
@


1.2
log
@Add support wscons (upstream + implementation)

ok matthieu@@
@
text
@d218 3
a220 3
	xf86Msg(X_PROBED,
		"%s: invalid x-axis range.  defaulting to %d - %d\n",
		pInfo->name, priv->minx, priv->maxx);
d229 3
a231 3
	xf86Msg(X_PROBED,
		"%s: invalid y-axis range.  defaulting to %d - %d\n",
		pInfo->name, priv->miny, priv->maxy);
d237 1
a237 1
	priv->maxp = 256;
d239 3
a241 3
	xf86Msg(X_PROBED,
		"%s: invalid pressure range.  defaulting to %d - %d\n",
		pInfo->name, priv->minp, priv->maxp);
d247 1
a247 1
	priv->maxw = 16;
d249 3
a251 3
	xf86Msg(X_PROBED,
		"%s: invalid finger width range.  defaulting to %d - %d\n",
		pInfo->name, priv->minw, priv->maxw);
d297 1
a297 1
	    xf86Msg(X_ERROR, "%s error shmget\n", pInfo->name);
d301 1
a301 1
	    xf86Msg(X_ERROR, "%s error shmat\n", pInfo->name);
d450 1
a450 1
    range = priv->maxp - priv->minp;
d463 1
a463 1
    range = priv->maxw - priv->minw;
d580 1
a580 2
	xf86Msg(X_WARNING, "%s: TopEdge is bigger than BottomEdge. Fixing.\n",
		pInfo->name);
d695 1
a695 1
        xf86Msg(X_ERROR, "Synaptics driver unable to detect protocol\n");
d699 2
d704 1
a704 1
	xf86Msg(X_ERROR, "Synaptics driver unable to open device\n");
d736 1
a736 1
	xf86Msg(X_ERROR, "%s Unable to query/initialize Synaptics hardware.\n", pInfo->name);
d832 1
a832 1
	xf86Msg(X_WARNING, "%s: cannot open input device\n", pInfo->name);
d997 2
a998 2
	xf86Msg(X_CONFIG, "%s: (accel) MinSpeed is now constant deceleration "
	        "%.1f\n", dev->name, tmpf);
d1011 4
a1014 4
	xf86Msg(X_CONFIG, "%s: MaxSpeed is now %.2f\n",
		dev->name, priv->synpara.max_speed);
	xf86Msg(X_CONFIG, "%s: AccelFactor is now %.3f\n",
		dev->name, priv->synpara.accl);
d1879 16
d1896 2
a1897 2
start_coasting(SynapticsPrivate *priv, struct SynapticsHwState *hw, edge_type edge,
	       Bool vertical)
d1906 1
a1906 1
	if (para->scroll_twofinger_vert || vertical) {
d1909 1
a1909 1
	    if ((para->scroll_twofinger_vert || (edge & RIGHT_EDGE)) && pkt_time > 0 && sdelta > 0) {
d1917 1
a1917 1
	if (para->scroll_twofinger_horiz || !vertical){
d1920 1
a1920 1
	    if ((para->scroll_twofinger_horiz || (edge & BOTTOM_EDGE)) && pkt_time > 0 && sdelta > 0) {
d1928 17
d2035 1
d2038 3
d2079 10
a2088 5
	if ((oldv || oldh) && !para->scroll_edge_corner &&
	    !(priv->circ_scroll_on || priv->vert_scroll_edge_on ||
	      priv->horiz_scroll_edge_on || priv->horiz_scroll_twofinger_on ||
	      priv->vert_scroll_twofinger_on)) {
	    start_coasting(priv, hw, edge, oldv);
d2103 1
a2103 1
		start_coasting(priv, hw, edge, TRUE);
d2122 1
a2122 1
		start_coasting(priv, hw, edge, FALSE);
d2651 1
a2651 1
	xf86Msg(X_PROBED, "%s: no supported touchpad found\n", pInfo->name);
@


1.1
log
@Initial revision
@
text
@d133 1
d139 20
d207 2
a208 2
void
SynapticsDefaultDimensions(InputInfoPtr pInfo)
d227 1
a227 1
	priv->resx = 0;
a257 1
    char *str_par, *device;
d259 2
a260 1
    enum SynapticsProtocol proto = SYN_PROTO_PSAUX;
d262 1
d264 7
a270 49
    if (!device) {
	device = xf86SetStrOption(pInfo->options, "Path", NULL);
	if (device) {
	    pInfo->options =
	    	xf86ReplaceStrOption(pInfo->options, "Device", device);
	}
    }
    if (device && strstr(device, "/dev/input/event")) {
#ifdef BUILD_EVENTCOMM
	proto = SYN_PROTO_EVENT;
#endif
    } else {
	str_par = xf86FindOptionValue(pInfo->options, "Protocol");
	if (str_par && !strcmp(str_par, "psaux")) {
	    /* Already set up */
#ifdef BUILD_EVENTCOMM
	} else if (str_par && !strcmp(str_par, "event")) {
	    proto = SYN_PROTO_EVENT;
#endif /* BUILD_EVENTCOMM */
#ifdef BUILD_PSMCOMM
	} else if (str_par && !strcmp(str_par, "psm")) {
	    proto = SYN_PROTO_PSM;
#endif /* BUILD_PSMCOMM */
	} else if (str_par && !strcmp(str_par, "alps")) {
	    proto = SYN_PROTO_ALPS;
	} else { /* default to auto-dev */
#ifdef BUILD_EVENTCOMM
	    if (!device && event_proto_operations.AutoDevProbe(pInfo))
		proto = SYN_PROTO_EVENT;
#endif
	}
    }
    switch (proto) {
    case SYN_PROTO_PSAUX:
	priv->proto_ops = &psaux_proto_operations;
	break;
#ifdef BUILD_EVENTCOMM
    case SYN_PROTO_EVENT:
	priv->proto_ops = &event_proto_operations;
	break;
#endif /* BUILD_EVENTCOMM */
#ifdef BUILD_PSMCOMM
    case SYN_PROTO_PSM:
	priv->proto_ops = &psm_proto_operations;
	break;
#endif /* BUILD_PSMCOMM */
    case SYN_PROTO_ALPS:
	priv->proto_ops = &alps_proto_operations;
	break;
d272 4
a430 1
    SynapticsDefaultDimensions(pInfo);
d456 1
a462 6
    /* Enable emulation when hw supports both pressure and width. */
    if (!priv->has_double && priv->has_width)
	emulateTwoFingerMinZ = fingerHigh;
    else
	emulateTwoFingerMinZ = priv->minp + range * (282.0/256);

d695 4
a828 1
    SetDeviceAndProtocol(pInfo);
d1239 1
a1239 2
    return priv->proto_ops->ReadHwState(pInfo, priv->proto_ops,
					&priv->comm, hw);
d2596 2
@


1.1.1.1
log
@Import xf86-input-synaptics 1.4.0

ok matthieu@@
@
text
@@
