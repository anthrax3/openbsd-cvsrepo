head	1.6;
access;
symbols
	OPENBSD_6_2:1.6.0.4
	OPENBSD_6_2_BASE:1.6
	OPENBSD_6_1:1.6.0.2
	OPENBSD_6_1_BASE:1.6
	OPENBSD_6_0:1.5.0.14
	OPENBSD_6_0_BASE:1.5
	OPENBSD_5_9:1.5.0.12
	OPENBSD_5_9_BASE:1.5
	OPENBSD_5_8:1.5.0.10
	OPENBSD_5_8_BASE:1.5
	OPENBSD_5_7:1.5.0.8
	OPENBSD_5_7_BASE:1.5
	OPENBSD_5_6:1.5.0.6
	OPENBSD_5_6_BASE:1.5
	OPENBSD_5_5:1.5.0.4
	OPENBSD_5_5_BASE:1.5
	OPENBSD_5_4:1.5.0.2
	OPENBSD_5_4_BASE:1.5
	OPENBSD_5_3:1.4.0.4
	OPENBSD_5_3_BASE:1.4
	OPENBSD_5_2:1.4.0.2
	OPENBSD_5_2_BASE:1.4
	OPENBSD_5_1_BASE:1.3
	OPENBSD_5_1:1.3.0.2
	OPENBSD_5_0:1.2.0.2
	OPENBSD_5_0_BASE:1.2
	shadchin_2011/home/xenocara/driver/xf86-input-synaptics04:1.1.1.1
	shadchin:1.1.1;
locks; strict;
comment	@ * @;


1.6
date	2017.01.22.09.54.53;	author matthieu;	state Exp;
branches;
next	1.5;
commitid	CjjEXS1IfivpYe4R;

1.5
date	2013.06.02.18.17.24;	author shadchin;	state Exp;
branches;
next	1.4;

1.4
date	2012.06.12.18.59.42;	author shadchin;	state Exp;
branches;
next	1.3;

1.3
date	2011.09.23.16.53.49;	author shadchin;	state Exp;
branches;
next	1.2;

1.2
date	2011.04.10.12.04.30;	author shadchin;	state Exp;
branches;
next	1.1;

1.1
date	2011.04.09.08.38.41;	author shadchin;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2011.04.09.08.38.41;	author shadchin;	state Exp;
branches;
next	;


desc
@@


1.6
log
@Update to xf86-input-synaptics 1.9.0
@
text
@/*
 * Copyright © 1997 C. Scott Ananian
 * Copyright © 1998-2000 Bruce Kalk
 * Copyright © 2001 Stefan Gmeiner
 * Copyright © 2002 Linuxcare Inc. David Kennedy
 * Copyright © 2003 Fred Hucht <fred@@thp.Uni-Duisburg.de>
 *
 * Permission to use, copy, modify, distribute, and sell this software
 * and its documentation for any purpose is hereby granted without
 * fee, provided that the above copyright notice appear in all copies
 * and that both that copyright notice and this permission notice
 * appear in supporting documentation, and that the name of Red Hat
 * not be used in advertising or publicity pertaining to distribution
 * of the software without specific, written prior permission.  Red
 * Hat makes no representations about the suitability of this software
 * for any purpose.  It is provided "as is" without express or implied
 * warranty.
 *
 * THE AUTHORS DISCLAIM ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
 * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN
 * NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY SPECIAL, INDIRECT OR
 * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS
 * OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT,
 * NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
 * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 *
 * Authors:
 *      Stefan Gmeiner (riddlebox@@freesurf.ch)
 *      C. Scott Ananian (cananian@@alumni.priceton.edu)
 *      Bruce Kalk (kall@@compass.com)
 *      Linuxcare Inc. David Kennedy (dkennedy@@linuxcare.com)
 *      Fred Hucht (fred@@thp.Uni-Duisburg.de)
 */

#ifdef HAVE_CONFIG_H
#include "config.h"
#endif

#include <xorg-server.h>
#include "synproto.h"
#include "synapticsstr.h"
#include "ps2comm.h"
#include <xf86.h>

#define MAX_UNSYNC_PACKETS 10   /* i.e. 10 to 60 bytes */
/*
 * The x/y limits are taken from the Synaptics TouchPad interfacing Guide,
 * section 2.3.2, which says that they should be valid regardless of the
 * actual size of the sensor.
 */
#define XMIN_NOMINAL 1472
#define XMAX_NOMINAL 5472
#define YMIN_NOMINAL 1408
#define YMAX_NOMINAL 4448

#define XMAX_VALID 6143

/* synaptics queries */
#define SYN_QUE_IDENTIFY		0x00
#define SYN_QUE_MODES			0x01
#define SYN_QUE_CAPABILITIES		0x02
#define SYN_QUE_MODEL			0x03
#define SYN_QUE_SERIAL_NUMBER_PREFIX	0x06
#define SYN_QUE_SERIAL_NUMBER_SUFFIX	0x07
#define SYN_QUE_RESOLUTION		0x08
#define SYN_QUE_EXT_CAPAB		0x09

/* status request response bits (PS2_CMD_STATUS_REQUEST) */
#define PS2_RES_REMOTE(r)	((r) & (1 << 22))
#define PS2_RES_ENABLE(r)	((r) & (1 << 21))
#define PS2_RES_SCALING(r)	((r) & (1 << 20))
#define PS2_RES_LEFT(r)		((r) & (1 << 18))
#define PS2_RES_MIDDLE(r)	((r) & (1 << 17))
#define PS2_RES_RIGHT(r)	((r) & (1 << 16))
#define PS2_RES_RESOLUTION(r)	(((r) >> 8) & 0x03)
#define PS2_RES_SAMPLE_RATE(r)	((r) & 0xff)

#ifdef DEBUG
#define PS2DBG(...) ErrorF(__VA_ARGS__)
#else
#define PS2DBG(...)
#endif

/*****************************************************************************
 *	PS/2 Utility functions.
 *     Many parts adapted from tpconfig.c by C. Scott Ananian
 ****************************************************************************/

/*
 * Read a byte from the ps/2 port
 */
static Bool
ps2_getbyte(int fd, byte * b)
{
    if (xf86WaitForInput(fd, 50000) > 0) {
        if (xf86ReadSerial(fd, b, 1) != 1) {
            PS2DBG("ps2_getbyte: No byte read\n");
            return FALSE;
        }
        PS2DBG("ps2_getbyte: byte %02X read\n", *b);
        return TRUE;
    }
    PS2DBG("ps2_getbyte: timeout xf86WaitForInput\n");
    return FALSE;
}

/*
 * Write a byte to the ps/2 port, wait for ACK
 */
Bool
ps2_putbyte(int fd, byte b)
{
    byte ack;

    if (xf86WriteSerial(fd, &b, 1) != 1) {
        PS2DBG("ps2_putbyte: error xf86WriteSerial\n");
        return FALSE;
    }
    PS2DBG("ps2_putbyte: byte %02X send\n", b);
    /* wait for an ACK */
    if (!ps2_getbyte(fd, &ack)) {
        return FALSE;
    }
    if (ack != PS2_ACK) {
        PS2DBG("ps2_putbyte: wrong acknowledge 0x%02x\n", ack);
        return FALSE;
    }
    return TRUE;
}

/*
 * Use the Synaptics extended ps/2 syntax to write a special command byte. Needed by
 * ps2_send_cmd and ps2_set_mode.
 * special command: 0xE8 rr 0xE8 ss 0xE8 tt 0xE8 uu where (rr*64)+(ss*16)+(tt*4)+uu
 *                  is the command. A 0xF3 or 0xE9 must follow (see ps2_send_cmd, ps2_set_mode)
 */
static Bool
ps2_special_cmd(int fd, byte cmd)
{
    int i;

    /* initialize with 'inert' command */
    if (!ps2_putbyte(fd, PS2_CMD_SET_SCALING_1_1))
        return FALSE;

    /* send 4x 2-bits with set resolution command */
    for (i = 0; i < 4; i++) {
        if (!ps2_putbyte(fd, PS2_CMD_SET_RESOLUTION) ||
            !ps2_putbyte(fd, (cmd >> 6) & 0x3))
            return FALSE;
        cmd <<= 2;
    }
    return TRUE;
}

/*
 * Send a command to the synpatics touchpad by special commands
 */
static Bool
ps2_send_cmd(int fd, byte c)
{
    PS2DBG("send command: 0x%02X\n", c);
    return (ps2_special_cmd(fd, c) && ps2_putbyte(fd, PS2_CMD_STATUS_REQUEST));
}

/*****************************************************************************
 *	Synaptics communications functions
 ****************************************************************************/

/*
 * Set the synaptics touchpad mode byte by special commands
 */
static Bool
ps2_synaptics_set_mode(int fd, byte mode)
{
    PS2DBG("set mode byte to: 0x%02X\n", mode);
    return (ps2_special_cmd(fd, mode) &&
            ps2_putbyte(fd, PS2_CMD_SET_SAMPLE_RATE) && ps2_putbyte(fd, 0x14));
}

/*
 * reset the touchpad
 */
static Bool
ps2_synaptics_reset(int fd)
{
    byte r[2];

    xf86FlushInput(fd);
    PS2DBG("Reset the Touchpad...\n");
    if (!ps2_putbyte(fd, PS2_CMD_RESET)) {
        PS2DBG("...failed\n");
        return FALSE;
    }
    xf86WaitForInput(fd, 4000000);
    if (ps2_getbyte(fd, &r[0]) && ps2_getbyte(fd, &r[1])) {
        if (r[0] == 0xAA && r[1] == 0x00) {
            PS2DBG("...done\n");
            return TRUE;
        }
        else {
            PS2DBG("...failed. Wrong reset ack 0x%02x, 0x%02x\n", r[0], r[1]);
            return FALSE;
        }
    }
    PS2DBG("...failed\n");
    return FALSE;
}

/*
 * Read the model-id bytes from the touchpad
 * see also SYN_MODEL_* macros
 */
static Bool
ps2_synaptics_model_id(int fd, struct PS2SynapticsHwInfo *synhw)
{
    byte mi[3];

    PS2DBG("Read mode id...\n");

    synhw->model_id = 0;
    if (ps2_send_cmd(fd, SYN_QUE_MODEL) &&
        ps2_getbyte(fd, &mi[0]) &&
        ps2_getbyte(fd, &mi[1]) && ps2_getbyte(fd, &mi[2])) {
        synhw->model_id = (mi[0] << 16) | (mi[1] << 8) | mi[2];
        PS2DBG("model-id %06X\n", synhw->model_id);
        PS2DBG("...done.\n");
        return TRUE;
    }
    PS2DBG("...failed.\n");
    return FALSE;
}

/*
 * Read the capability-bits from the touchpad
 * see also the SYN_CAP_* macros
 */
static Bool
ps2_synaptics_capability(int fd, struct PS2SynapticsHwInfo *synhw)
{
    byte cap[3];

    PS2DBG("Read capabilites...\n");

    synhw->capabilities = 0;
    synhw->ext_cap = 0;
    if (ps2_send_cmd(fd, SYN_QUE_CAPABILITIES) &&
        ps2_getbyte(fd, &cap[0]) &&
        ps2_getbyte(fd, &cap[1]) && ps2_getbyte(fd, &cap[2])) {
        synhw->capabilities = (cap[0] << 16) | (cap[1] << 8) | cap[2];
        PS2DBG("capabilities %06X\n", synhw->capabilities);
        if (SYN_CAP_VALID(synhw)) {
            if (SYN_EXT_CAP_REQUESTS(synhw)) {
                if (ps2_send_cmd(fd, SYN_QUE_EXT_CAPAB) &&
                    ps2_getbyte(fd, &cap[0]) &&
                    ps2_getbyte(fd, &cap[1]) && ps2_getbyte(fd, &cap[2])) {
                    synhw->ext_cap = (cap[0] << 16) | (cap[1] << 8) | cap[2];
                    PS2DBG("ext-capability %06X\n", synhw->ext_cap);
                }
                else {
                    PS2DBG("synaptics says, that it has extended-capabilities, "
                           "but I cannot read them.");
                }
            }
            PS2DBG("...done.\n");
            return TRUE;
        }
    }
    PS2DBG("...failed.\n");
    return FALSE;
}

/*
 * Identify Touchpad
 * See also the SYN_ID_* macros
 */
static Bool
ps2_synaptics_identify(int fd, struct PS2SynapticsHwInfo *synhw)
{
    byte id[3];

    PS2DBG("Identify Touchpad...\n");

    synhw->identity = 0;
    if (ps2_send_cmd(fd, SYN_QUE_IDENTIFY) &&
        ps2_getbyte(fd, &id[0]) &&
        ps2_getbyte(fd, &id[1]) && ps2_getbyte(fd, &id[2])) {
        synhw->identity = (id[0] << 16) | (id[1] << 8) | id[2];
        PS2DBG("ident %06X\n", synhw->identity);
        if (SYN_ID_IS_SYNAPTICS(synhw)) {
            PS2DBG("...done.\n");
            return TRUE;
        }
    }
    PS2DBG("...failed.\n");
    return FALSE;
}

static Bool
ps2_synaptics_enable_device(int fd)
{
    return ps2_putbyte(fd, PS2_CMD_ENABLE);
}

static Bool
ps2_synaptics_disable_device(int fd)
{
    xf86FlushInput(fd);
    return ps2_putbyte(fd, PS2_CMD_DISABLE);
}

static Bool
ps2_query_is_synaptics(InputInfoPtr pInfo, int fd,
                       struct PS2SynapticsHwInfo *synhw)
{
    int i;

    for (i = 0; i < 3; i++) {
        if (ps2_synaptics_disable_device(fd))
            break;
    }

    xf86WaitForInput(fd, 20000);
    xf86FlushInput(fd);
    if (ps2_synaptics_identify(fd, synhw)) {
        return TRUE;
    }
    else {
        xf86IDrvMsg(pInfo, X_ERROR, "Query no Synaptics: %06X\n",
                    synhw->identity);
        return FALSE;
    }
}

void
ps2_print_ident(InputInfoPtr pInfo, const struct PS2SynapticsHwInfo *synhw)
{
    xf86IDrvMsg(pInfo, X_PROBED, " Synaptics Touchpad, model: %d\n",
                SYN_ID_MODEL(synhw));
    xf86IDrvMsg(pInfo, X_PROBED, " Firmware: %d.%d\n", SYN_ID_MAJOR(synhw),
                SYN_ID_MINOR(synhw));

    if (SYN_MODEL_ROT180(synhw))
        xf86IDrvMsg(pInfo, X_PROBED, " 180 degree mounted touchpad\n");
    if (SYN_MODEL_PORTRAIT(synhw))
        xf86IDrvMsg(pInfo, X_PROBED, " portrait touchpad\n");
    xf86IDrvMsg(pInfo, X_PROBED, " Sensor: %d\n", SYN_MODEL_SENSOR(synhw));
    if (SYN_MODEL_NEWABS(synhw))
        xf86IDrvMsg(pInfo, X_PROBED, " new absolute packet format\n");
    if (SYN_MODEL_PEN(synhw))
        xf86IDrvMsg(pInfo, X_PROBED, " pen detection\n");

    if (SYN_CAP_EXTENDED(synhw)) {
        xf86IDrvMsg(pInfo, X_PROBED,
                    " Touchpad has extended capability bits\n");
        if (SYN_CAP_MULTI_BUTTON_NO(synhw))
            xf86IDrvMsg(pInfo, X_PROBED,
                        " -> %d multi buttons, i.e. besides standard buttons\n",
                        (int) (SYN_CAP_MULTI_BUTTON_NO(synhw)));
        if (SYN_CAP_MIDDLE_BUTTON(synhw))
            xf86IDrvMsg(pInfo, X_PROBED, " -> middle button\n");
        if (SYN_CAP_FOUR_BUTTON(synhw))
            xf86IDrvMsg(pInfo, X_PROBED, " -> four buttons\n");
        if (SYN_CAP_MULTIFINGER(synhw))
            xf86IDrvMsg(pInfo, X_PROBED, " -> multifinger detection\n");
        if (SYN_CAP_PALMDETECT(synhw))
            xf86IDrvMsg(pInfo, X_PROBED, " -> palm detection\n");
        if (SYN_CAP_PASSTHROUGH(synhw))
            xf86IDrvMsg(pInfo, X_PROBED, " -> pass-through port\n");
    }
}

static Bool
PS2DeviceOffHook(InputInfoPtr pInfo)
{
    ps2_synaptics_reset(pInfo->fd);
    ps2_synaptics_enable_device(pInfo->fd);

    return TRUE;
}

static Bool
PS2QueryHardware(InputInfoPtr pInfo)
{
    int mode;
    SynapticsPrivate *priv = (SynapticsPrivate *) pInfo->private;
    struct PS2SynapticsHwInfo *synhw;

    if (!priv->proto_data)
        priv->proto_data = calloc(1, sizeof(struct PS2SynapticsHwInfo));
    synhw = (struct PS2SynapticsHwInfo *) priv->proto_data;

    /* is the synaptics touchpad active? */
    if (!ps2_query_is_synaptics(pInfo, pInfo->fd, synhw))
        return FALSE;

    xf86IDrvMsg(pInfo, X_PROBED, "synaptics touchpad found\n");

    if (!ps2_synaptics_reset(pInfo->fd))
        xf86IDrvMsg(pInfo, X_ERROR, "reset failed\n");

    if (!ps2_synaptics_identify(pInfo->fd, synhw))
        return FALSE;

    if (!ps2_synaptics_model_id(pInfo->fd, synhw))
        return FALSE;

    if (!ps2_synaptics_capability(pInfo->fd, synhw))
        return FALSE;

    mode = SYN_BIT_ABSOLUTE_MODE | SYN_BIT_HIGH_RATE;
    if (SYN_ID_MAJOR(synhw) >= 4)
        mode |= SYN_BIT_DISABLE_GESTURE;
    if (SYN_CAP_EXTENDED(synhw))
        mode |= SYN_BIT_W_MODE;
    if (!ps2_synaptics_set_mode(pInfo->fd, mode))
        return FALSE;

    ps2_synaptics_enable_device(pInfo->fd);

    ps2_print_ident(pInfo, synhw);

    return TRUE;
}

/*
 * Decide if the current packet stored in priv->protoBuf is valid.
 */
static Bool
ps2_packet_ok(struct PS2SynapticsHwInfo *synhw, struct CommData *comm)
{
    unsigned char *buf = comm->protoBuf;
    int newabs = SYN_MODEL_NEWABS(synhw);

    if (newabs ? ((buf[0] & 0xC0) != 0x80) : ((buf[0] & 0xC0) != 0xC0)) {
        PS2DBG("Synaptics driver lost sync at 1st byte\n");
        return FALSE;
    }

    if (!newabs && ((buf[1] & 0x60) != 0x00)) {
        PS2DBG("Synaptics driver lost sync at 2nd byte\n");
        return FALSE;
    }

    if ((newabs ? ((buf[3] & 0xC0) != 0xC0) : ((buf[3] & 0xC0) != 0x80))) {
        PS2DBG("Synaptics driver lost sync at 4th byte\n");
        return FALSE;
    }

    if (!newabs && ((buf[4] & 0x60) != 0x00)) {
        PS2DBG("Synaptics driver lost sync at 5th byte\n");
        return FALSE;
    }

    return TRUE;
}

static Bool
ps2_synaptics_get_packet(InputInfoPtr pInfo, struct PS2SynapticsHwInfo *synhw,
                         struct SynapticsProtocolOperations *proto_ops,
                         struct CommData *comm)
{
    int count = 0;
    int c;
    unsigned char u;

    while ((c = XisbRead(comm->buffer)) >= 0) {
        u = (unsigned char) c;

        /* test if there is a reset sequence received */
        if ((c == 0x00) && (comm->lastByte == 0xAA)) {
            if (xf86WaitForInput(pInfo->fd, 50000) == 0) {
                PS2DBG("Reset received\n");
                proto_ops->QueryHardware(pInfo);
            }
            else
                PS2DBG("faked reset received\n");
        }
        comm->lastByte = u;

        /* to avoid endless loops */
        if (count++ > 30) {
            LogMessageVerbSigSafe(X_ERROR, 0,
                                  "Synaptics driver lost sync... got gigantic packet!\n");
            return FALSE;
        }

        comm->protoBuf[comm->protoBufTail++] = u;

        /* Check that we have a valid packet. If not, we are out of sync,
           so we throw away the first byte in the packet. */
        if (comm->protoBufTail >= 6) {
            if (!ps2_packet_ok(synhw, comm)) {
                int i;

                for (i = 0; i < comm->protoBufTail - 1; i++)
                    comm->protoBuf[i] = comm->protoBuf[i + 1];
                comm->protoBufTail--;
                comm->outOfSync++;
                if (comm->outOfSync > MAX_UNSYNC_PACKETS) {
                    comm->outOfSync = 0;
                    PS2DBG("Synaptics synchronization lost too long -> reset touchpad.\n");
                    proto_ops->QueryHardware(pInfo);    /* including a reset */
                    continue;
                }
            }
        }

        if (comm->protoBufTail >= 6) {  /* Full packet received */
            if (comm->outOfSync > 0) {
                comm->outOfSync = 0;
                PS2DBG("Synaptics driver resynced.\n");
            }
            comm->protoBufTail = 0;
            return TRUE;
        }
    }

    return FALSE;
}

Bool
PS2ReadHwStateProto(InputInfoPtr pInfo,
                    struct SynapticsProtocolOperations *proto_ops,
                    struct CommData *comm, struct SynapticsHwState *hwRet)
{
    unsigned char *buf = comm->protoBuf;
    struct SynapticsHwState *hw = comm->hwState;
    SynapticsPrivate *priv = (SynapticsPrivate *) pInfo->private;
    SynapticsParameters *para = &priv->synpara;
    struct PS2SynapticsHwInfo *synhw;
    int newabs;
    int w, i;

    synhw = (struct PS2SynapticsHwInfo *) priv->proto_data;
    if (!synhw) {
        LogMessageVerbSigSafe(X_ERROR, 0,
                              "PS2ReadHwState, synhw is NULL. This is a bug.\n");
        return FALSE;
    }

    newabs = SYN_MODEL_NEWABS(synhw);

    if (!ps2_synaptics_get_packet(pInfo, synhw, proto_ops, comm))
        return FALSE;

    /* Handle normal packets */
    hw->x = hw->y = hw->z = hw->numFingers = hw->fingerWidth = 0;
    hw->left = hw->right = hw->up = hw->down = hw->middle = FALSE;
    for (i = 0; i < 8; i++)
        hw->multi[i] = FALSE;

    if (newabs) {               /* newer protos... */
        PS2DBG("using new protocols\n");
        hw->x = (((buf[3] & 0x10) << 8) | ((buf[1] & 0x0f) << 8) | buf[4]);
        hw->y = (((buf[3] & 0x20) << 7) | ((buf[1] & 0xf0) << 4) | buf[5]);

        hw->z = buf[2];
        w = (((buf[0] & 0x30) >> 2) |
             ((buf[0] & 0x04) >> 1) | ((buf[3] & 0x04) >> 2));

        hw->left = (buf[0] & 0x01) ? 1 : 0;
        hw->right = (buf[0] & 0x02) ? 1 : 0;

        if (SYN_CAP_EXTENDED(synhw)) {
            if (SYN_CAP_MIDDLE_BUTTON(synhw)) {
                hw->middle = ((buf[0] ^ buf[3]) & 0x01) ? 1 : 0;
            }
            if (SYN_CAP_FOUR_BUTTON(synhw)) {
                hw->up = ((buf[3] & 0x01)) ? 1 : 0;
                if (hw->left)
                    hw->up = !hw->up;
                hw->down = ((buf[3] & 0x02)) ? 1 : 0;
                if (hw->right)
                    hw->down = !hw->down;
            }
            if (SYN_CAP_MULTI_BUTTON_NO(synhw)) {
                if ((buf[3] & 2) ? !hw->right : hw->right) {
                    switch (SYN_CAP_MULTI_BUTTON_NO(synhw) & ~0x01) {
                    default:
                        break;
                    case 8:
                        hw->multi[7] = ((buf[5] & 0x08)) ? 1 : 0;
                        hw->multi[6] = ((buf[4] & 0x08)) ? 1 : 0;
                        /* fallthrough */
                    case 6:
                        hw->multi[5] = ((buf[5] & 0x04)) ? 1 : 0;
                        hw->multi[4] = ((buf[4] & 0x04)) ? 1 : 0;
                        /* fallthrough */
                    case 4:
                        hw->multi[3] = ((buf[5] & 0x02)) ? 1 : 0;
                        hw->multi[2] = ((buf[4] & 0x02)) ? 1 : 0;
                        /* fallthrough */
                    case 2:
                        hw->multi[1] = ((buf[5] & 0x01)) ? 1 : 0;
                        hw->multi[0] = ((buf[4] & 0x01)) ? 1 : 0;
                    }
                }
            }
        }
    }
    else {                      /* old proto... */
        PS2DBG("using old protocol\n");
        hw->x = (((buf[1] & 0x1F) << 8) | buf[2]);
        hw->y = (((buf[4] & 0x1F) << 8) | buf[5]);

        hw->z = (((buf[0] & 0x30) << 2) | (buf[3] & 0x3F));
        w = (((buf[1] & 0x80) >> 4) | ((buf[0] & 0x04) >> 1));

        hw->left = (buf[0] & 0x01) ? 1 : 0;
        hw->right = (buf[0] & 0x02) ? 1 : 0;
    }

    hw->y = YMAX_NOMINAL + YMIN_NOMINAL - hw->y;

    if (hw->z >= para->finger_high) {
        int w_ok = 0;

        /*
         * Use capability bits to decide if the w value is valid.
         * If not, set it to 5, which corresponds to a finger of
         * normal width.
         */
        if (SYN_CAP_EXTENDED(synhw)) {
            if ((w >= 0) && (w <= 1)) {
                w_ok = SYN_CAP_MULTIFINGER(synhw);
            }
            else if (w == 2) {
                w_ok = SYN_MODEL_PEN(synhw);
            }
            else if ((w >= 4) && (w <= 15)) {
                w_ok = SYN_CAP_PALMDETECT(synhw);
            }
        }
        if (!w_ok)
            w = 5;

        switch (w) {
        case 0:
            hw->numFingers = 2;
            hw->fingerWidth = 5;
            break;
        case 1:
            hw->numFingers = 3;
            hw->fingerWidth = 5;
            break;
        default:
            hw->numFingers = 1;
            hw->fingerWidth = w;
            break;
        }
    }
    hw->millis = GetTimeInMillis();
    SynapticsCopyHwState(hwRet, hw);
    return TRUE;
}

static Bool
PS2ReadHwState(InputInfoPtr pInfo,
               struct CommData *comm, struct SynapticsHwState *hwRet)
{
    return PS2ReadHwStateProto(pInfo, &psaux_proto_operations, comm, hwRet);
}

struct SynapticsProtocolOperations psaux_proto_operations = {
    NULL,
    PS2DeviceOffHook,
    PS2QueryHardware,
    PS2ReadHwState,
    NULL,
    NULL
};
@


1.5
log
@Update to xf86-input-synaptics 1.7.1.

ok mpi@@ jcs@@ matthieu@@
@
text
@d585 1
d589 1
d593 1
@


1.4
log
@Update to xf86-input-synaptics 1.6.1

ok matthieu@@
@
text
@a40 1
#include "synaptics.h"
d79 1
a79 1
#define PS2DBG(x) (x)
d81 1
a81 1
#define PS2DBG(x)
d97 1
a97 1
            PS2DBG(ErrorF("ps2_getbyte: No byte read\n"));
d100 1
a100 1
        PS2DBG(ErrorF("ps2_getbyte: byte %02X read\n", *b));
d103 1
a103 1
    PS2DBG(ErrorF("ps2_getbyte: timeout xf86WaitForInput\n"));
d116 1
a116 1
        PS2DBG(ErrorF("ps2_putbyte: error xf86WriteSerial\n"));
d119 1
a119 1
    PS2DBG(ErrorF("ps2_putbyte: byte %02X send\n", b));
d125 1
a125 1
        PS2DBG(ErrorF("ps2_putbyte: wrong acknowledge 0x%02x\n", ack));
d162 1
a162 1
    PS2DBG(ErrorF("send command: 0x%02X\n", c));
d176 1
a176 1
    PS2DBG(ErrorF("set mode byte to: 0x%02X\n", mode));
d190 1
a190 1
    PS2DBG(ErrorF("Reset the Touchpad...\n"));
d192 1
a192 1
        PS2DBG(ErrorF("...failed\n"));
d198 1
a198 1
            PS2DBG(ErrorF("...done\n"));
d202 1
a202 2
            PS2DBG(ErrorF
                   ("...failed. Wrong reset ack 0x%02x, 0x%02x\n", r[0], r[1]));
d206 1
a206 1
    PS2DBG(ErrorF("...failed\n"));
d219 1
a219 1
    PS2DBG(ErrorF("Read mode id...\n"));
d226 2
a227 2
        PS2DBG(ErrorF("model-id %06X\n", synhw->model_id));
        PS2DBG(ErrorF("...done.\n"));
d230 1
a230 1
    PS2DBG(ErrorF("...failed.\n"));
d243 1
a243 1
    PS2DBG(ErrorF("Read capabilites...\n"));
d251 1
a251 1
        PS2DBG(ErrorF("capabilities %06X\n", synhw->capabilities));
d258 1
a258 1
                    PS2DBG(ErrorF("ext-capability %06X\n", synhw->ext_cap));
d261 2
a262 3
                    PS2DBG(ErrorF
                           ("synaptics says, that it has extended-capabilities, "
                            "but I cannot read them."));
d265 1
a265 1
            PS2DBG(ErrorF("...done.\n"));
d269 1
a269 1
    PS2DBG(ErrorF("...failed.\n"));
d282 1
a282 1
    PS2DBG(ErrorF("Identify Touchpad...\n"));
d289 1
a289 1
        PS2DBG(ErrorF("ident %06X\n", synhw->identity));
d291 1
a291 1
            PS2DBG(ErrorF("...done.\n"));
d295 1
a295 1
    PS2DBG(ErrorF("...failed.\n"));
d436 1
a436 1
        DBG(4, "Synaptics driver lost sync at 1st byte\n");
d441 1
a441 1
        DBG(4, "Synaptics driver lost sync at 2nd byte\n");
d446 1
a446 1
        DBG(4, "Synaptics driver lost sync at 4th byte\n");
d451 1
a451 1
        DBG(4, "Synaptics driver lost sync at 5th byte\n");
d473 1
a473 1
                DBG(7, "Reset received\n");
d477 1
a477 1
                DBG(3, "faked reset received\n");
d483 2
a484 2
            xf86IDrvMsg(pInfo, X_ERROR,
                        "Synaptics driver lost sync... got gigantic packet!\n");
d502 1
a502 2
                    DBG(3,
                        "Synaptics synchronization lost too long -> reset touchpad.\n");
d512 1
a512 1
                DBG(4, "Synaptics driver resynced.\n");
d537 2
a538 2
        xf86IDrvMsg(pInfo, X_ERROR,
                    "PS2ReadHwState, synhw is NULL. This is a bug.\n");
d554 1
a554 1
        DBG(7, "using new protocols\n");
d600 1
a600 1
        DBG(7, "using old protocol\n");
@


1.3
log
@Update to xf86-input-synaptics 1.5.0.
ok mpi@@, matthieu@@
@
text
@d46 1
a46 1
#define MAX_UNSYNC_PACKETS 10				/* i.e. 10 to 60 bytes */
d94 1
a94 1
ps2_getbyte(int fd, byte *b)
d97 6
a102 6
	if (xf86ReadSerial(fd, b, 1) != 1) {
	    PS2DBG(ErrorF("ps2_getbyte: No byte read\n"));
	    return FALSE;
	}
	PS2DBG(ErrorF("ps2_getbyte: byte %02X read\n", *b));
	return TRUE;
d117 2
a118 2
	PS2DBG(ErrorF("ps2_putbyte: error xf86WriteSerial\n"));
	return FALSE;
d123 1
a123 1
	return FALSE;
d126 2
a127 2
	PS2DBG(ErrorF("ps2_putbyte: wrong acknowledge 0x%02x\n", ack));
	return FALSE;
d145 1
a145 1
	return FALSE;
d149 4
a152 4
	if (!ps2_putbyte(fd, PS2_CMD_SET_RESOLUTION) ||
	    !ps2_putbyte(fd, (cmd >> 6) & 0x3))
	    return FALSE;
	cmd <<= 2;
d164 1
a164 2
    return (ps2_special_cmd(fd, c) &&
	    ps2_putbyte(fd, PS2_CMD_STATUS_REQUEST));
d179 1
a179 2
	    ps2_putbyte(fd, PS2_CMD_SET_SAMPLE_RATE) &&
	    ps2_putbyte(fd, 0x14));
d193 2
a194 2
	PS2DBG(ErrorF("...failed\n"));
	return FALSE;
d198 9
a206 7
	if (r[0] == 0xAA && r[1] == 0x00) {
	    PS2DBG(ErrorF("...done\n"));
	    return TRUE;
	} else {
	    PS2DBG(ErrorF("...failed. Wrong reset ack 0x%02x, 0x%02x\n", r[0], r[1]));
	    return FALSE;
	}
d225 6
a230 7
	ps2_getbyte(fd, &mi[0]) &&
	ps2_getbyte(fd, &mi[1]) &&
	ps2_getbyte(fd, &mi[2])) {
	synhw->model_id = (mi[0] << 16) | (mi[1] << 8) | mi[2];
	PS2DBG(ErrorF("model-id %06X\n", synhw->model_id));
	PS2DBG(ErrorF("...done.\n"));
	return TRUE;
d250 21
a270 21
	ps2_getbyte(fd, &cap[0]) &&
	ps2_getbyte(fd, &cap[1]) &&
	ps2_getbyte(fd, &cap[2])) {
	synhw->capabilities = (cap[0] << 16) | (cap[1] << 8) | cap[2];
	PS2DBG(ErrorF("capabilities %06X\n", synhw->capabilities));
	if (SYN_CAP_VALID(synhw)) {
	    if (SYN_EXT_CAP_REQUESTS(synhw)) {
		if (ps2_send_cmd(fd, SYN_QUE_EXT_CAPAB) &&
		    ps2_getbyte(fd, &cap[0]) &&
		    ps2_getbyte(fd, &cap[1]) &&
		    ps2_getbyte(fd, &cap[2])) {
		    synhw->ext_cap = (cap[0] << 16) | (cap[1] << 8) | cap[2];
		    PS2DBG(ErrorF("ext-capability %06X\n", synhw->ext_cap));
		} else {
		    PS2DBG(ErrorF("synaptics says, that it has extended-capabilities, "
				  "but I cannot read them."));
		}
	    }
	    PS2DBG(ErrorF("...done.\n"));
	    return TRUE;
	}
d289 8
a296 9
	ps2_getbyte(fd, &id[0]) &&
	ps2_getbyte(fd, &id[1]) &&
	ps2_getbyte(fd, &id[2])) {
	synhw->identity = (id[0] << 16) | (id[1] << 8) | id[2];
	PS2DBG(ErrorF("ident %06X\n", synhw->identity));
	if (SYN_ID_IS_SYNAPTICS(synhw)) {
	    PS2DBG(ErrorF("...done.\n"));
	    return TRUE;
	}
d316 2
a317 1
ps2_query_is_synaptics(InputInfoPtr pInfo, int fd, struct PS2SynapticsHwInfo* synhw)
d322 2
a323 2
	if (ps2_synaptics_disable_device(fd))
	    break;
d329 6
a334 4
	return TRUE;
    } else {
	xf86IDrvMsg(pInfo, X_ERROR, "Query no Synaptics: %06X\n", synhw->identity);
	return FALSE;
d341 2
a342 1
    xf86IDrvMsg(pInfo, X_PROBED, " Synaptics Touchpad, model: %d\n", SYN_ID_MODEL(synhw));
d344 1
a344 1
	    SYN_ID_MINOR(synhw));
d347 1
a347 1
	xf86IDrvMsg(pInfo, X_PROBED, " 180 degree mounted touchpad\n");
d349 1
a349 1
	xf86IDrvMsg(pInfo, X_PROBED, " portrait touchpad\n");
d352 1
a352 1
	xf86IDrvMsg(pInfo, X_PROBED, " new absolute packet format\n");
d354 1
a354 1
	xf86IDrvMsg(pInfo, X_PROBED, " pen detection\n");
d357 16
a372 14
	xf86IDrvMsg(pInfo, X_PROBED, " Touchpad has extended capability bits\n");
	if (SYN_CAP_MULTI_BUTTON_NO(synhw))
	    xf86IDrvMsg(pInfo, X_PROBED, " -> %d multi buttons, i.e. besides standard buttons\n",
		    (int)(SYN_CAP_MULTI_BUTTON_NO(synhw)));
	if (SYN_CAP_MIDDLE_BUTTON(synhw))
	    xf86IDrvMsg(pInfo, X_PROBED, " -> middle button\n");
	if (SYN_CAP_FOUR_BUTTON(synhw))
	    xf86IDrvMsg(pInfo, X_PROBED, " -> four buttons\n");
	if (SYN_CAP_MULTIFINGER(synhw))
	    xf86IDrvMsg(pInfo, X_PROBED, " -> multifinger detection\n");
	if (SYN_CAP_PALMDETECT(synhw))
	    xf86IDrvMsg(pInfo, X_PROBED, " -> palm detection\n");
	if (SYN_CAP_PASSTHROUGH(synhw))
	    xf86IDrvMsg(pInfo, X_PROBED, " -> pass-through port\n");
d376 1
a376 1
static void
d381 2
d389 1
a389 1
    SynapticsPrivate *priv = (SynapticsPrivate *)pInfo->private;
d394 1
a394 1
    synhw = (struct PS2SynapticsHwInfo*)priv->proto_data;
d398 1
a398 1
	return FALSE;
d403 1
a403 1
	xf86IDrvMsg(pInfo, X_ERROR, "reset failed\n");
d406 1
a406 1
	return FALSE;
d409 1
a409 1
	return FALSE;
d412 1
a412 1
	return FALSE;
d416 1
a416 1
	mode |= SYN_BIT_DISABLE_GESTURE;
d418 1
a418 1
	mode |= SYN_BIT_W_MODE;
d420 1
a420 1
	return FALSE;
d439 2
a440 2
	DBG(4, "Synaptics driver lost sync at 1st byte\n");
	return FALSE;
d444 2
a445 2
	DBG(4, "Synaptics driver lost sync at 2nd byte\n");
	return FALSE;
d449 2
a450 2
	DBG(4, "Synaptics driver lost sync at 4th byte\n");
	return FALSE;
d454 2
a455 2
	DBG(4, "Synaptics driver lost sync at 5th byte\n");
	return FALSE;
d463 2
a464 2
			 struct SynapticsProtocolOperations *proto_ops,
			 struct CommData *comm)
d471 1
a471 1
	u = (unsigned char)c;
d473 48
a520 44
	/* test if there is a reset sequence received */
	if ((c == 0x00) && (comm->lastByte == 0xAA)) {
	    if (xf86WaitForInput(pInfo->fd, 50000) == 0) {
		DBG(7, "Reset received\n");
		proto_ops->QueryHardware(pInfo);
	    } else
		DBG(3, "faked reset received\n");
	}
	comm->lastByte = u;

	/* to avoid endless loops */
	if (count++ > 30) {
	    xf86IDrvMsg(pInfo, X_ERROR, "Synaptics driver lost sync... got gigantic packet!\n");
	    return FALSE;
	}

	comm->protoBuf[comm->protoBufTail++] = u;

	/* Check that we have a valid packet. If not, we are out of sync,
	   so we throw away the first byte in the packet.*/
	if (comm->protoBufTail >= 6) {
	    if (!ps2_packet_ok(synhw, comm)) {
		int i;
		for (i = 0; i < comm->protoBufTail - 1; i++)
		    comm->protoBuf[i] = comm->protoBuf[i + 1];
		comm->protoBufTail--;
		comm->outOfSync++;
		if (comm->outOfSync > MAX_UNSYNC_PACKETS) {
		    comm->outOfSync = 0;
		    DBG(3, "Synaptics synchronization lost too long -> reset touchpad.\n");
		    proto_ops->QueryHardware(pInfo); /* including a reset */
		    continue;
		}
	    }
	}

	if (comm->protoBufTail >= 6) { /* Full packet received */
	    if (comm->outOfSync > 0) {
		comm->outOfSync = 0;
		DBG(4, "Synaptics driver resynced.\n");
	    }
	    comm->protoBufTail = 0;
	    return TRUE;
	}
d528 2
a529 2
	       struct SynapticsProtocolOperations *proto_ops,
	       struct CommData *comm, struct SynapticsHwState *hwRet)
d532 2
a533 2
    struct SynapticsHwState *hw = &(comm->hwState);
    SynapticsPrivate *priv = (SynapticsPrivate *)pInfo->private;
d539 2
a540 3
    synhw = (struct PS2SynapticsHwInfo*)priv->proto_data;
    if (!synhw)
    {
d549 1
a549 1
	return FALSE;
d555 52
a606 1
	hw->multi[i] = FALSE;
d608 2
a609 61
    if (newabs) {			    /* newer protos...*/
	DBG(7, "using new protocols\n");
	hw->x = (((buf[3] & 0x10) << 8) |
		 ((buf[1] & 0x0f) << 8) |
		 buf[4]);
	hw->y = (((buf[3] & 0x20) << 7) |
		 ((buf[1] & 0xf0) << 4) |
		 buf[5]);

	hw->z = buf[2];
	w = (((buf[0] & 0x30) >> 2) |
	     ((buf[0] & 0x04) >> 1) |
	     ((buf[3] & 0x04) >> 2));

	hw->left  = (buf[0] & 0x01) ? 1 : 0;
	hw->right = (buf[0] & 0x02) ? 1 : 0;

	if (SYN_CAP_EXTENDED(synhw)) {
	    if (SYN_CAP_MIDDLE_BUTTON(synhw)) {
		hw->middle = ((buf[0] ^ buf[3]) & 0x01) ? 1 : 0;
	    }
	    if (SYN_CAP_FOUR_BUTTON(synhw)) {
		hw->up = ((buf[3] & 0x01)) ? 1 : 0;
		if (hw->left)
		    hw->up = !hw->up;
		hw->down = ((buf[3] & 0x02)) ? 1 : 0;
		if (hw->right)
		    hw->down = !hw->down;
	    }
	    if (SYN_CAP_MULTI_BUTTON_NO(synhw)) {
		if ((buf[3] & 2) ? !hw->right : hw->right) {
		    switch (SYN_CAP_MULTI_BUTTON_NO(synhw) & ~0x01) {
		    default:
			break;
		    case 8:
			hw->multi[7] = ((buf[5] & 0x08)) ? 1 : 0;
			hw->multi[6] = ((buf[4] & 0x08)) ? 1 : 0;
		    case 6:
			hw->multi[5] = ((buf[5] & 0x04)) ? 1 : 0;
			hw->multi[4] = ((buf[4] & 0x04)) ? 1 : 0;
		    case 4:
			hw->multi[3] = ((buf[5] & 0x02)) ? 1 : 0;
			hw->multi[2] = ((buf[4] & 0x02)) ? 1 : 0;
		    case 2:
			hw->multi[1] = ((buf[5] & 0x01)) ? 1 : 0;
			hw->multi[0] = ((buf[4] & 0x01)) ? 1 : 0;
		    }
		}
	    }
	}
    } else {			    /* old proto...*/
	DBG(7, "using old protocol\n");
	hw->x = (((buf[1] & 0x1F) << 8) |
		 buf[2]);
	hw->y = (((buf[4] & 0x1F) << 8) |
		 buf[5]);

	hw->z = (((buf[0] & 0x30) << 2) |
		 (buf[3] & 0x3F));
	w = (((buf[1] & 0x80) >> 4) |
	     ((buf[0] & 0x04) >> 1));
d611 2
a612 2
	hw->left  = (buf[0] & 0x01) ? 1 : 0;
	hw->right = (buf[0] & 0x02) ? 1 : 0;
d618 35
a652 32
	int w_ok = 0;
	/*
	 * Use capability bits to decide if the w value is valid.
	 * If not, set it to 5, which corresponds to a finger of
	 * normal width.
	 */
	if (SYN_CAP_EXTENDED(synhw)) {
	    if ((w >= 0) && (w <= 1)) {
		w_ok = SYN_CAP_MULTIFINGER(synhw);
	    } else if (w == 2) {
		w_ok = SYN_MODEL_PEN(synhw);
	    } else if ((w >= 4) && (w <= 15)) {
		w_ok = SYN_CAP_PALMDETECT(synhw);
	    }
	}
	if (!w_ok)
	    w = 5;

	switch (w) {
	case 0:
	    hw->numFingers = 2;
	    hw->fingerWidth = 5;
	    break;
	case 1:
	    hw->numFingers = 3;
	    hw->fingerWidth = 5;
	    break;
	default:
	    hw->numFingers = 1;
	    hw->fingerWidth = w;
	    break;
	}
d654 2
a655 2

    *hwRet = *hw;
@


1.2
log
@Add support wscons (upstream + implementation)

ok matthieu@@
@
text
@d318 1
a318 1
ps2_query_is_synaptics(int fd, struct PS2SynapticsHwInfo* synhw)
d332 1
a332 1
	xf86Msg(X_ERROR, "Query no Synaptics: %06X\n", synhw->identity);
d338 1
a338 1
ps2_print_ident(const struct PS2SynapticsHwInfo *synhw)
d340 2
a341 2
    xf86Msg(X_PROBED, " Synaptics Touchpad, model: %d\n", SYN_ID_MODEL(synhw));
    xf86Msg(X_PROBED, " Firmware: %d.%d\n", SYN_ID_MAJOR(synhw),
d345 1
a345 1
	xf86Msg(X_PROBED, " 180 degree mounted touchpad\n");
d347 2
a348 2
	xf86Msg(X_PROBED, " portrait touchpad\n");
    xf86Msg(X_PROBED, " Sensor: %d\n", SYN_MODEL_SENSOR(synhw));
d350 1
a350 1
	xf86Msg(X_PROBED, " new absolute packet format\n");
d352 1
a352 1
	xf86Msg(X_PROBED, " pen detection\n");
d355 1
a355 1
	xf86Msg(X_PROBED, " Touchpad has extended capability bits\n");
d357 1
a357 1
	    xf86Msg(X_PROBED, " -> %d multi buttons, i.e. besides standard buttons\n",
d360 1
a360 1
	    xf86Msg(X_PROBED, " -> middle button\n");
d362 1
a362 1
	    xf86Msg(X_PROBED, " -> four buttons\n");
d364 1
a364 1
	    xf86Msg(X_PROBED, " -> multifinger detection\n");
d366 1
a366 1
	    xf86Msg(X_PROBED, " -> palm detection\n");
d368 1
a368 1
	    xf86Msg(X_PROBED, " -> pass-through port\n");
d391 1
a391 1
    if (!ps2_query_is_synaptics(pInfo->fd, synhw))
d394 1
a394 1
    xf86Msg(X_PROBED, "%s synaptics touchpad found\n", pInfo->name);
d397 1
a397 1
	xf86Msg(X_ERROR, "%s reset failed\n", pInfo->name);
d418 1
a418 1
    ps2_print_ident(synhw);
d479 1
a479 1
	    xf86Msg(X_ERROR, "Synaptics driver lost sync... got gigantic packet!\n");
d532 2
a533 3
        xf86Msg(X_ERROR,
                "%s: PS2ReadHwState, synhw is NULL. This is a bug.\n",
                pInfo->name);
@


1.1
log
@Initial revision
@
text
@a39 1
#include "ps2comm.h"
d43 1
a84 7
struct SynapticsHwInfo {
    unsigned int model_id;		    /* Model-ID */
    unsigned int capabilities;		    /* Capabilities */
    unsigned int ext_cap;		    /* Extended Capabilities */
    unsigned int identity;		    /* Identification */
};

d217 1
a217 1
ps2_synaptics_model_id(int fd, struct SynapticsHwInfo *synhw)
d242 1
a242 1
ps2_synaptics_capability(int fd, struct SynapticsHwInfo *synhw)
d282 1
a282 1
ps2_synaptics_identify(int fd, struct SynapticsHwInfo *synhw)
d318 1
a318 1
ps2_query_is_synaptics(int fd, struct SynapticsHwInfo* synhw)
d338 1
a338 1
ps2_print_ident(const struct SynapticsHwInfo *synhw)
d384 1
a384 1
    struct SynapticsHwInfo *synhw;
d387 2
a388 2
        priv->proto_data = calloc(1, sizeof(struct SynapticsHwInfo));
    synhw = (struct SynapticsHwInfo*)priv->proto_data;
d427 1
a427 1
ps2_packet_ok(struct SynapticsHwInfo *synhw, struct CommData *comm)
d456 1
a456 1
ps2_synaptics_get_packet(InputInfoPtr pInfo, struct SynapticsHwInfo *synhw,
d516 2
a517 2
static Bool
PS2ReadHwState(InputInfoPtr pInfo,
d525 1
a525 1
    struct SynapticsHwInfo *synhw;
d529 1
a529 1
    synhw = (struct SynapticsHwInfo*)priv->proto_data;
d657 2
a658 1
PS2AutoDevProbe(InputInfoPtr pInfo)
d660 1
a660 1
    return FALSE;
d668 2
a669 2
    PS2AutoDevProbe,
    SynapticsDefaultDimensions
@


1.1.1.1
log
@Import xf86-input-synaptics 1.4.0

ok matthieu@@
@
text
@@
