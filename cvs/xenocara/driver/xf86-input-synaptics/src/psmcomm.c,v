head	1.5;
access;
symbols
	OPENBSD_6_2:1.5.0.18
	OPENBSD_6_2_BASE:1.5
	OPENBSD_6_1:1.5.0.16
	OPENBSD_6_1_BASE:1.5
	OPENBSD_6_0:1.5.0.14
	OPENBSD_6_0_BASE:1.5
	OPENBSD_5_9:1.5.0.12
	OPENBSD_5_9_BASE:1.5
	OPENBSD_5_8:1.5.0.10
	OPENBSD_5_8_BASE:1.5
	OPENBSD_5_7:1.5.0.8
	OPENBSD_5_7_BASE:1.5
	OPENBSD_5_6:1.5.0.6
	OPENBSD_5_6_BASE:1.5
	OPENBSD_5_5:1.5.0.4
	OPENBSD_5_5_BASE:1.5
	OPENBSD_5_4:1.5.0.2
	OPENBSD_5_4_BASE:1.5
	OPENBSD_5_3:1.4.0.4
	OPENBSD_5_3_BASE:1.4
	OPENBSD_5_2:1.4.0.2
	OPENBSD_5_2_BASE:1.4
	OPENBSD_5_1_BASE:1.3
	OPENBSD_5_1:1.3.0.2
	OPENBSD_5_0:1.2.0.2
	OPENBSD_5_0_BASE:1.2
	shadchin_2011/home/xenocara/driver/xf86-input-synaptics04:1.1.1.1
	shadchin:1.1.1;
locks; strict;
comment	@ * @;


1.5
date	2013.06.02.18.17.24;	author shadchin;	state Exp;
branches;
next	1.4;

1.4
date	2012.06.12.18.59.42;	author shadchin;	state Exp;
branches;
next	1.3;

1.3
date	2011.09.23.16.53.49;	author shadchin;	state Exp;
branches;
next	1.2;

1.2
date	2011.04.10.12.04.30;	author shadchin;	state Exp;
branches;
next	1.1;

1.1
date	2011.04.09.08.38.41;	author shadchin;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2011.04.09.08.38.41;	author shadchin;	state Exp;
branches;
next	;


desc
@@


1.5
log
@Update to xf86-input-synaptics 1.7.1.

ok mpi@@ jcs@@ matthieu@@
@
text
@/*
 * Copyright © 1997 C. Scott Ananian
 * Copyright © 1998-2000 Bruce Kalk
 * Copyright © 2001 Stefan Gmeiner
 * Copyright © 2002 Linuxcare Inc. David Kennedy
 * Copyright © 2003 Fred Hucht
 * Copyright © 2004 Arne Schwabe
 *
 * Permission to use, copy, modify, distribute, and sell this software
 * and its documentation for any purpose is hereby granted without
 * fee, provided that the above copyright notice appear in all copies
 * and that both that copyright notice and this permission notice
 * appear in supporting documentation, and that the name of Red Hat
 * not be used in advertising or publicity pertaining to distribution
 * of the software without specific, written prior permission.  Red
 * Hat makes no representations about the suitability of this software
 * for any purpose.  It is provided "as is" without express or implied
 * warranty.
 *
 * THE AUTHORS DISCLAIM ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
 * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN
 * NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY SPECIAL, INDIRECT OR
 * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS
 * OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT,
 * NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
 * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 *
 * Authors:
 *      Stefan Gmeiner (riddlebox@@freesurf.ch)
 *      C. Scott Ananian (cananian@@alumni.priceton.edu)
 *      Bruce Kalk (kall@@compass.com)
 *      Linuxcare Inc. David Kennedy (dkennedy@@linuxcare.com)
 *      Fred Hucht (fred@@thp.Uni-Duisburg.de)
 *      Arne Schwabe <schwabe@@uni-paderborn.de>
 */

#ifdef HAVE_CONFIG_H
#include "config.h"
#endif

#include <xorg-server.h>
#include <unistd.h>
#include <sys/ioctl.h>
#include <sys/mouse.h>
#include <errno.h>
#include <string.h>
#include "synproto.h"
#include "synapticsstr.h"
#include "ps2comm.h"            /* ps2_print_ident() */
#include <xf86.h>

#define SYSCALL(call) while (((call) == -1) && (errno == EINTR))

/*
 * Identify Touchpad
 * See also the SYN_ID_* macros
 */
static Bool
psm_synaptics_identify(int fd, synapticshw_t * ident)
{
    int ret;

    SYSCALL(ret = ioctl(fd, MOUSE_SYN_GETHWINFO, ident));
    if (ret == 0)
        return TRUE;
    else
        return FALSE;
}

/* This define is used in a ioctl but not in mouse.h :/ */
#define PSM_LEVEL_NATIVE	2

static Bool
PSMQueryIsSynaptics(InputInfoPtr pInfo)
{
    int ret;
    int level = PSM_LEVEL_NATIVE;
    mousehw_t mhw;

    /* Put the device in native protocol mode to be sure
     * Otherwise HWINFO will not return the right id
     * And we will need native mode anyway ...
     */
    SYSCALL(ret = ioctl(pInfo->fd, MOUSE_SETLEVEL, &level));
    if (ret != 0) {
        xf86IDrvMsg(pInfo, X_ERROR, "%s Can't set native mode\n", pInfo->name);
        return FALSE;
    }
    SYSCALL(ret = ioctl(pInfo->fd, MOUSE_GETHWINFO, &mhw));
    if (ret != 0) {
        xf86IDrvMsg(pInfo, X_ERROR, "%s Can't get hardware info\n",
                    pInfo->name);
        return FALSE;
    }

    if (mhw.model == MOUSE_MODEL_SYNAPTICS) {
        return TRUE;
    }
    else {
        xf86IDrvMsg(pInfo, X_ERROR,
                    "%s Found no Synaptics, found Mouse model %d instead\n",
                    pInfo->name, mhw.model);
        return FALSE;
    }
}

static void
convert_hw_info(const synapticshw_t * psm_ident,
                struct PS2SynapticsHwInfo *synhw)
{
    memset(synhw, 0, sizeof(*synhw));
    synhw->model_id = ((psm_ident->infoRot180 << 23) |
                       (psm_ident->infoPortrait << 22) |
                       (psm_ident->infoSensor << 16) |
                       (psm_ident->infoHardware << 9) |
                       (psm_ident->infoNewAbs << 7) |
                       (psm_ident->capPen << 6) |
                       (psm_ident->infoSimplC << 5) |
                       (psm_ident->infoGeometry));
    synhw->capabilities = ((psm_ident->capExtended << 23) |
                           (psm_ident->capPassthrough << 7) |
                           (psm_ident->capSleep << 4) |
                           (psm_ident->capFourButtons << 3) |
                           (psm_ident->capMultiFinger << 1) |
                           (psm_ident->capPalmDetect));
    synhw->ext_cap = 0;
    synhw->identity = ((psm_ident->infoMajor) |
                       (0x47 << 8) | (psm_ident->infoMinor << 16));
}

static Bool
PSMQueryHardware(InputInfoPtr pInfo)
{
    synapticshw_t psm_ident;
    struct PS2SynapticsHwInfo *synhw;
    SynapticsPrivate *priv;

    priv = (SynapticsPrivate *) pInfo->private;

    if (!priv->proto_data)
        priv->proto_data = calloc(1, sizeof(struct PS2SynapticsHwInfo));
    synhw = (struct PS2SynapticsHwInfo *) priv->proto_data;

    /* is the synaptics touchpad active? */
    if (!PSMQueryIsSynaptics(pInfo))
        return FALSE;

    xf86IDrvMsg(pInfo, X_PROBED, "synaptics touchpad found\n");

    if (!psm_synaptics_identify(pInfo->fd, &psm_ident))
        return FALSE;

    convert_hw_info(&psm_ident, synhw);

    ps2_print_ident(pInfo, synhw);

    return TRUE;
}

static Bool
PSMReadHwState(InputInfoPtr pInfo,
               struct CommData *comm, struct SynapticsHwState *hwRet)
{
    return PS2ReadHwStateProto(pInfo, &psm_proto_operations, comm, hwRet);
}

struct SynapticsProtocolOperations psm_proto_operations = {
    NULL,
    NULL,
    PSMQueryHardware,
    PSMReadHwState,
    NULL,
    NULL
};
@


1.4
log
@Update to xf86-input-synaptics 1.6.1

ok matthieu@@
@
text
@a47 1
#include "synaptics.h"
@


1.3
log
@Update to xf86-input-synaptics 1.5.0.
ok mpi@@, matthieu@@
@
text
@d50 1
a50 1
#include "ps2comm.h"			    /* ps2_print_ident() */
d60 1
a60 1
psm_synaptics_identify(int fd, synapticshw_t *ident)
d66 1
a66 1
	return TRUE;
d68 1
a68 1
	return FALSE;
d87 2
a88 2
	xf86IDrvMsg(pInfo, X_ERROR, "%s Can't set native mode\n", pInfo->name);
	return FALSE;
d92 3
a94 2
	xf86IDrvMsg(pInfo, X_ERROR, "%s Can't get hardware info\n", pInfo->name);
	return FALSE;
d98 7
a104 5
	return TRUE;
    } else {
	xf86IDrvMsg(pInfo, X_ERROR, "%s Found no Synaptics, found Mouse model %d instead\n",
		pInfo->name, mhw.model);
	return FALSE;
d109 2
a110 1
convert_hw_info(const synapticshw_t *psm_ident, struct PS2SynapticsHwInfo *synhw)
d114 7
a120 7
		       (psm_ident->infoPortrait << 22) |
		       (psm_ident->infoSensor << 16) |
		       (psm_ident->infoHardware << 9) |
		       (psm_ident->infoNewAbs << 7) |
		       (psm_ident->capPen << 6) |
		       (psm_ident->infoSimplC << 5) |
		       (psm_ident->infoGeometry));
d122 5
a126 5
			   (psm_ident->capPassthrough << 7) |
			   (psm_ident->capSleep << 4) |
			   (psm_ident->capFourButtons << 3) |
			   (psm_ident->capMultiFinger << 1) |
			   (psm_ident->capPalmDetect));
d129 1
a129 2
		       (0x47 << 8) |
		       (psm_ident->infoMinor << 16));
d139 1
a139 1
    priv = (SynapticsPrivate *)pInfo->private;
d141 1
a141 1
    if(!priv->proto_data)
d143 1
a143 1
    synhw = (struct PS2SynapticsHwInfo*)priv->proto_data;
d147 1
a147 1
	return FALSE;
d152 1
a152 1
	return FALSE;
d163 1
a163 1
	       struct CommData *comm, struct SynapticsHwState *hwRet)
@


1.2
log
@Add support wscons (upstream + implementation)

ok matthieu@@
@
text
@d87 1
a87 1
	xf86Msg(X_ERROR, "%s Can't set native mode\n", pInfo->name);
d92 1
a92 1
	xf86Msg(X_ERROR, "%s Can't get hardware info\n", pInfo->name);
d99 1
a99 1
	xf86Msg(X_ERROR, "%s Found no Synaptics, found Mouse model %d instead\n",
d146 1
a146 1
    xf86Msg(X_PROBED, "%s synaptics touchpad found\n", pInfo->name);
d153 1
a153 1
    ps2_print_ident(synhw);
@


1.1
log
@Initial revision
@
text
@a54 7
struct SynapticsHwInfo {
    unsigned int model_id;		    /* Model-ID */
    unsigned int capabilities;		    /* Capabilities */
    unsigned int ext_cap;		    /* Extended Capabilities */
    unsigned int identity;		    /* Identification */
};

d106 1
a106 1
convert_hw_info(const synapticshw_t *psm_ident, struct SynapticsHwInfo *synhw)
d133 1
a133 1
    struct SynapticsHwInfo *synhw;
d139 2
a140 2
        priv->proto_data = calloc(1, sizeof(struct SynapticsHwInfo));
    synhw = (struct SynapticsHwInfo*)priv->proto_data;
a159 1
	       struct SynapticsProtocolOperations *proto_ops,
d162 1
a162 6
    return psaux_proto_operations.ReadHwState(pInfo, proto_ops, comm, hwRet);
}

static Bool PSMAutoDevProbe(InputInfoPtr pInfo)
{
    return FALSE;
d170 2
a171 2
    PSMAutoDevProbe,
    SynapticsDefaultDimensions
@


1.1.1.1
log
@Import xf86-input-synaptics 1.4.0

ok matthieu@@
@
text
@@
