head	1.6;
access;
symbols
	OPENBSD_6_1:1.6.0.18
	OPENBSD_6_1_BASE:1.6
	OPENBSD_6_0:1.6.0.16
	OPENBSD_6_0_BASE:1.6
	OPENBSD_5_9:1.6.0.14
	OPENBSD_5_9_BASE:1.6
	OPENBSD_5_8:1.6.0.12
	OPENBSD_5_8_BASE:1.6
	OPENBSD_5_7:1.6.0.10
	OPENBSD_5_7_BASE:1.6
	OPENBSD_5_6:1.6.0.8
	OPENBSD_5_6_BASE:1.6
	OPENBSD_5_5:1.6.0.6
	OPENBSD_5_5_BASE:1.6
	OPENBSD_5_4:1.6.0.4
	OPENBSD_5_4_BASE:1.6
	OPENBSD_5_3:1.6.0.2
	OPENBSD_5_3_BASE:1.6
	OPENBSD_5_2:1.5.0.4
	OPENBSD_5_2_BASE:1.5
	OPENBSD_5_1_BASE:1.5
	OPENBSD_5_1:1.5.0.2
	OPENBSD_5_0:1.4.0.4
	OPENBSD_5_0_BASE:1.4
	OPENBSD_4_9:1.4.0.2
	OPENBSD_4_9_BASE:1.4
	OPENBSD_4_8:1.2.0.6
	OPENBSD_4_8_BASE:1.2
	OPENBSD_4_7:1.2.0.2
	OPENBSD_4_7_BASE:1.2
	OPENBSD_4_6:1.1.1.1.0.6
	OPENBSD_4_6_BASE:1.1.1.1
	OPENBSD_4_5:1.1.1.1.0.4
	OPENBSD_4_5_BASE:1.1.1.1
	OPENBSD_4_4:1.1.1.1.0.2
	OPENBSD_4_4_BASE:1.1.1.1
	v2_10_0:1.1.1.1
	xorg:1.1.1;
locks; strict;
comment	@ * @;


1.6
date	2012.12.16.23.04.18;	author matthieu;	state Exp;
branches;
next	1.5;

1.5
date	2011.09.13.20.25.35;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2010.12.07.21.54.11;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2010.11.05.12.30.03;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2009.10.11.09.30.15;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2008.06.14.22.15.43;	author mbalmer;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2008.06.14.22.15.43;	author mbalmer;	state Exp;
branches;
next	;


desc
@@


1.6
log
@Update to xf86-video-geode 2.11.14
@
text
@/* Copyright (c) 2007-2008 Advanced Micro Devices, Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to
 * deal in the Software without restriction, including without limitation the
 * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
 * sell copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
 * IN THE SOFTWARE.
 *
 * Neither the name of the Advanced Micro Devices, Inc. nor the names of its
 * contributors may be used to endorse or promote products derived from this
 * software without specific prior written permission.
 */

/* TODO:
   Add rotation
   Add back in double buffering?

*/

#ifdef HAVE_CONFIG_H
#include "config.h"
#endif

#include <stdlib.h>
#include <string.h>

#include "xf86.h"
#include "xf86_OSproc.h"
#include "compiler.h"
#include "xf86PciInfo.h"
#include "xf86Pci.h"
#include "xf86fbman.h"
#include "regionstr.h"
#include "dixstruct.h"

#include "geode.h"
#include "xf86xv.h"
#include <X11/extensions/Xv.h>
#include "fourcc.h"
#include "geode_fourcc.h"
#include "cim/cim_defs.h"
#include "cim/cim_regs.h"

#define OFF_DELAY 		200
#define FREE_DELAY 		60000
#define OFF_TIMER 		0x01
#define FREE_TIMER		0x02
#define CLIENT_VIDEO_ON	0x04
#define TIMER_MASK      (OFF_TIMER | FREE_TIMER)

#define MAKE_ATOM(a) MakeAtom(a, sizeof(a) - 1, TRUE)
#ifndef ARRAY_SIZE
#define ARRAY_SIZE(a) (sizeof((a)) / (sizeof(*(a))))
#endif

/* Local function prototypes */
static void LXStopVideo(ScrnInfoPtr pScrni, pointer data, Bool exit);

static void


LXDisplayVideo(ScrnInfoPtr pScrni, int id, short width, short height,
               BoxPtr dstBox, short srcW, short srcH, short drawW, short drawH);

static void LXResetVideo(ScrnInfoPtr pScrni);

static XF86VideoEncodingRec DummyEncoding[1] = {
    {0, "XV_IMAGE", 1024, 1024, {1, 1}}
};

static XF86VideoFormatRec Formats[] = {
    {8, PseudoColor}, {15, TrueColor}, {16, TrueColor}, {24, TrueColor}
};

static XF86AttributeRec Attributes[] = {
    {XvSettable | XvGettable, 0, (1 << 24) - 1, "XV_COLORKEY"},
    {XvSettable | XvGettable, 0, 1, "XV_FILTER"},
    {XvSettable | XvGettable, 0, 1, "XV_COLORKEYMODE"}
};

static XF86ImageRec Images[] = {
    XVIMAGE_UYVY,
    XVIMAGE_YUY2,
    XVIMAGE_Y2YU,
    XVIMAGE_YVYU,
    XVIMAGE_Y800,
    XVIMAGE_I420,
    XVIMAGE_YV12,
    XVIMAGE_RGB565
};

typedef struct {
    ExaOffscreenArea *vidmem;
    RegionRec clip;
    CARD32 filter;
    CARD32 colorKey;
    CARD32 colorKeyMode;
    CARD32 videoStatus;
    Time offTime;
    Time freeTime;
    short pwidth, pheight;
} GeodePortPrivRec, *GeodePortPrivPtr;

#define GET_PORT_PRIVATE(pScrni) \
   (GeodePortPrivRec *)((GEODEPTR(pScrni))->adaptor->pPortPrivates[0].ptr)

static void
LXCopyFromSys(GeodeRec * pGeode, unsigned char *src, unsigned int dst,
              int dstPitch, int srcPitch, int h, int w)
{

    gp_declare_blt(0);
    gp_set_bpp((srcPitch / w) << 3);

    gp_set_raster_operation(0xCC);
    gp_set_strides(dstPitch, srcPitch);
    gp_set_solid_pattern(0);

    gp_color_bitmap_to_screen_blt(dst, 0, w, h, src, srcPitch);
}

static void
LXSetColorkey(ScrnInfoPtr pScrni, GeodePortPrivRec * pPriv)
{
    int red, green, blue;
    unsigned long key;

    switch (pScrni->depth) {
    case 8:
        vg_get_display_palette_entry(pPriv->colorKey & 0xFF, &key);
        red = ((key >> 16) & 0xFF);
        green = ((key >> 8) & 0xFF);
        blue = (key & 0xFF);
        break;
    case 16:
        red = (pPriv->colorKey & pScrni->mask.red) >>
            pScrni->offset.red << (8 - pScrni->weight.red);
        green = (pPriv->colorKey & pScrni->mask.green) >>
            pScrni->offset.green << (8 - pScrni->weight.green);
        blue = (pPriv->colorKey & pScrni->mask.blue) >>
            pScrni->offset.blue << (8 - pScrni->weight.blue);
        break;
    default:
        /* for > 16 bpp we send in the mask in xf86SetWeight. This
         * function is providing the offset by 1 more. So we take
         * this as a special case and subtract 1 for > 16
         */

        red = (pPriv->colorKey & pScrni->mask.red) >>
            (pScrni->offset.red - 1) << (8 - pScrni->weight.red);
        green = (pPriv->colorKey & pScrni->mask.green) >>
            (pScrni->offset.green - 1) << (8 - pScrni->weight.green);
        blue = (pPriv->colorKey & pScrni->mask.blue) >>
            (pScrni->offset.blue - 1) << (8 - pScrni->weight.blue);
        break;
    }

    df_set_video_color_key((blue | (green << 8) | (red << 16)),
                           0xFFFFFF, (pPriv->colorKeyMode == 0));

    REGION_EMPTY(pScrni->pScreen, &pPriv->clip);
}

/* A structure full of the scratch information that originates in the copy routines,
   but is needed for the video display - maybe we should figure out a way to attach
   this to structures?  I hate to put it in pGeode since it will increase the size of
   the structure, and possibly cause us cache issues.
*/

struct {
    unsigned int dstOffset;
    unsigned int dstPitch;
    unsigned int UVPitch;
    unsigned int UDstOffset;
    unsigned int VDstOffset;
} videoScratch;

/* Copy planar YUV data */

static Bool
LXAllocateVidMem(ScrnInfoPtr pScrni, GeodePortPrivRec * pPriv, int size)
{
    if (!pPriv->vidmem || pPriv->vidmem->size < size) {
        if (pPriv->vidmem) {
            exaOffscreenFree(pScrni->pScreen, pPriv->vidmem);
            pPriv->vidmem = NULL;
        }

        pPriv->vidmem = exaOffscreenAlloc(pScrni->pScreen, size, 4,
                                          TRUE, NULL, NULL);

        if (pPriv->vidmem == NULL) {
            ErrorF("Could not allocate memory for the video\n");
            return FALSE;
        }
    }

    return TRUE;
}

static Bool
LXCopyPlanar(ScrnInfoPtr pScrni, int id, unsigned char *buf,
             short x1, short y1, short x2, short y2,
             int width, int height, pointer data)
{
    GeodeRec *pGeode = GEODEPTR(pScrni);
    GeodePortPrivRec *pPriv = (GeodePortPrivRec *) data;

    unsigned int YSrcPitch, YDstPitch;
    unsigned int UVSrcPitch, UVDstPitch;
    unsigned int YSrcOffset, YDstOffset;
    unsigned int USrcOffset, UDstOffset;
    unsigned int VSrcOffset, VDstOffset;

    unsigned int size, lines, top, left, pixels;

    YSrcPitch = (width + 3) & ~3;
    YDstPitch = (width + 31) & ~31;

    UVSrcPitch = ((width >> 1) + 3) & ~3;
    UVDstPitch = ((width >> 1) + 15) & ~15;

    USrcOffset = YSrcPitch * height;
    VSrcOffset = USrcOffset + (UVSrcPitch * (height >> 1));

    UDstOffset = YDstPitch * height;
    VDstOffset = UDstOffset + (UVDstPitch * (height >> 1));

    size = YDstPitch * height;
    size += UVDstPitch * height;

    if (LXAllocateVidMem(pScrni, pPriv, size) == FALSE) {
        ErrorF("Error allocating an offscreen Planar region.\n");
        return FALSE;
    }

    /* The top of the source region we want to copy */
    top = y1 & ~1;

    /* The left hand side of the source region, aligned on a word */
    left = x1 & ~1;

    /* Number of bytes to copy, also word aligned */
    pixels = ((x2 + 1) & ~1) - left;

    /* Calculate the source offset */
    YSrcOffset = (top * YSrcPitch) + left;
    USrcOffset += ((top >> 1) * UVSrcPitch) + (left >> 1);
    VSrcOffset += ((top >> 1) * UVSrcPitch) + (left >> 1);

    /* Calculate the destination offset */
    YDstOffset = (top * YDstPitch) + left;
    UDstOffset += ((top >> 1) * UVDstPitch) + (left >> 1);
    VDstOffset += ((top >> 1) * UVDstPitch) + (left >> 1);

    lines = ((y2 + 1) & ~1) - top;

    /* Copy Y */

    LXCopyFromSys(pGeode, buf + YSrcOffset,
                  pPriv->vidmem->offset + YDstOffset, YDstPitch, YSrcPitch,
                  lines, pixels);

    /* Copy U + V at the same time */

    LXCopyFromSys(pGeode, buf + USrcOffset,
                  pPriv->vidmem->offset + UDstOffset, UVDstPitch, UVSrcPitch,
                  lines, pixels >> 1);

    videoScratch.dstOffset = pPriv->vidmem->offset + YDstOffset;
    videoScratch.dstPitch = YDstPitch;
    videoScratch.UVPitch = UVDstPitch;
    videoScratch.UDstOffset = pPriv->vidmem->offset + UDstOffset;
    videoScratch.VDstOffset = pPriv->vidmem->offset + VDstOffset;

    return TRUE;
}

static Bool
LXCopyPacked(ScrnInfoPtr pScrni, int id, unsigned char *buf,
             short x1, short y1, short x2, short y2,
             int width, int height, pointer data)
{
    GeodePortPrivRec *pPriv = (GeodePortPrivRec *) data;
    GeodeRec *pGeode = GEODEPTR(pScrni);
    unsigned int dstPitch, srcPitch;
    unsigned int srcOffset, dstOffset;
    unsigned int lines, top, left, pixels;

    dstPitch = ((width << 1) + 3) & ~3;
    srcPitch = (width << 1);

    lines = ((dstPitch * height) + pGeode->Pitch - 1) / pGeode->Pitch;

    if (LXAllocateVidMem(pScrni, pPriv, dstPitch * height) == FALSE) {
        ErrorF("Error allocating an offscreen Packed region.\n");
        return FALSE;
    }

    /* The top of the source region we want to copy */
    top = y1;

    /* The left hand side of the source region, aligned on a word */
    left = x1 & ~1;

    /* Number of bytes to copy, also word aligned */
    pixels = ((x2 + 1) & ~1) - left;

    /* Adjust the incoming buffer */
    srcOffset = (top * srcPitch) + left;

    /* Calculate the destination offset */
    dstOffset = pPriv->vidmem->offset + (top * dstPitch) + left;

    /* Make the copy happen */

    if (id == FOURCC_Y800) {

        /* Use the shared (unaccelerated) greyscale copy - you could probably
         * accelerate it using a 2 pass blit and patterns, but it doesn't really
         * seem worth it
         */

        GeodeCopyGreyscale(buf + srcOffset, pGeode->FBBase + dstOffset,
                           srcPitch, dstPitch, height, pixels >> 1);
    }
    else
        /* FIXME: should lines be used here instead of height? */
        LXCopyFromSys(pGeode, buf + srcOffset, dstOffset, dstPitch, srcPitch,
                      height, pixels);

    videoScratch.dstOffset = dstOffset;
    videoScratch.dstPitch = dstPitch;

    return TRUE;
}

static void
LXDisplayVideo(ScrnInfoPtr pScrni, int id, short width, short height,
               BoxPtr dstBox, short srcW, short srcH, short drawW, short drawH)
{
    long ystart, xend, yend;
    unsigned long lines = 0;
    unsigned long yExtra, uvExtra = 0;
    DF_VIDEO_POSITION vidPos;
    DF_VIDEO_SOURCE_PARAMS vSrcParams;
    int err;

    memset(&vSrcParams, 0, sizeof(vSrcParams));

    gp_wait_until_idle();

    switch (id) {
    case FOURCC_UYVY:
        vSrcParams.video_format = DF_VIDFMT_UYVY;
        break;

    case FOURCC_Y800:
    case FOURCC_YV12:
    case FOURCC_I420:
        vSrcParams.video_format = DF_VIDFMT_Y0Y1Y2Y3;
        break;
    case FOURCC_YUY2:
        vSrcParams.video_format = DF_VIDFMT_YUYV;
        break;
    case FOURCC_Y2YU:
        vSrcParams.video_format = DF_VIDFMT_Y2YU;
        break;
    case FOURCC_YVYU:
        vSrcParams.video_format = DF_VIDFMT_YVYU;
        break;
    case FOURCC_RGB565:
        vSrcParams.video_format = DF_VIDFMT_RGB;
        break;
    }

    vSrcParams.width = width;
    vSrcParams.height = height;
    vSrcParams.y_pitch = videoScratch.dstPitch;
    vSrcParams.uv_pitch = videoScratch.UVPitch;

    /* Set up scaling */
    df_set_video_filter_coefficients(NULL, 1);

    err = df_set_video_scale(width, height, drawW, drawH,
                             DF_SCALEFLAG_CHANGEX | DF_SCALEFLAG_CHANGEY);
    if (err != CIM_STATUS_OK) {
        /* Note the problem, but do nothing for now. */
        ErrorF("Video scale factor too large: %dx%d -> %dx%d\n",
               width, height, drawW, drawH);
    }

    /* Figure out clipping */

    xend = dstBox->x2;
    yend = dstBox->y2;

    if (dstBox->y1 < 0) {
        if (srcH < drawH)
            lines = ((-dstBox->y1) * srcH) / drawH;
        else
            lines = (-dstBox->y1);

        ystart = 0;
        drawH += dstBox->y1;
    }
    else {
        ystart = dstBox->y1;
        lines = 0;
    }

    yExtra = lines * videoScratch.dstPitch;
    uvExtra = (lines >> 1) * videoScratch.UVPitch;

    memset(&vidPos, 0, sizeof(vidPos));

    vidPos.x = dstBox->x1;
    vidPos.y = ystart;
    vidPos.width = xend - dstBox->x1;
    vidPos.height = yend - ystart;

    df_set_video_position(&vidPos);

    vSrcParams.y_offset = videoScratch.dstOffset + yExtra;

    switch (id) {
    case FOURCC_Y800:
    case FOURCC_I420:
        vSrcParams.u_offset = videoScratch.UDstOffset + uvExtra;
        vSrcParams.v_offset = videoScratch.VDstOffset + uvExtra;
        break;
    case FOURCC_YV12:
        vSrcParams.v_offset = videoScratch.UDstOffset + uvExtra;
        vSrcParams.u_offset = videoScratch.VDstOffset + uvExtra;
        break;

    default:
        vSrcParams.u_offset = vSrcParams.v_offset = 0;
        break;
    }

    vSrcParams.flags = DF_SOURCEFLAG_IMPLICITSCALING;
    df_configure_video_source(&vSrcParams, &vSrcParams);

    /* Turn on the video palette */
    df_set_video_palette(NULL);
    df_set_video_enable(1, 0);
}

static int
LXPutImage(ScrnInfoPtr pScrni,
           short srcX, short srcY, short drawX, short drawY,
           short srcW, short srcH, short drawW, short drawH,
           int id, unsigned char *buf,
           short width, short height, Bool sync, RegionPtr clipBoxes,
           pointer data, DrawablePtr pDraw)
{
    GeodeRec *pGeode = GEODEPTR(pScrni);
    GeodePortPrivRec *pPriv = (GeodePortPrivRec *) data;
    INT32 x1, x2, y1, y2;
    BoxRec dstBox;
    Bool ret;

    if (pGeode->rotation != RR_Rotate_0)
        return Success;

    if (srcW <= 0 || srcH <= 0) {
        return Success;
    }

    if (drawW <= 0 || drawH <= 0) {
        return Success;
    }

    if (drawW > 16384)
        drawW = 16384;

    memset(&videoScratch, 0, sizeof(videoScratch));

    x1 = srcX;
    x2 = srcX + srcW;
    y1 = srcY;
    y2 = srcY + srcH;

    dstBox.x1 = drawX;
    dstBox.x2 = drawX + drawW;
    dstBox.y1 = drawY;
    dstBox.y2 = drawY + drawH;

    dstBox.x1 -= pScrni->frameX0;
    dstBox.x2 -= pScrni->frameX0;
    dstBox.y1 -= pScrni->frameY0;
    dstBox.y2 -= pScrni->frameY0;

    if (id == FOURCC_YV12 || id == FOURCC_I420)
        ret = LXCopyPlanar(pScrni, id, buf, x1, y1, x2, y2, width,
                           height, data);
    else
        ret = LXCopyPacked(pScrni, id, buf, x1, y1, x2, y2, width,
                           height, data);

    if (ret == FALSE)
        return BadAlloc;

    if (!RegionsEqual(&pPriv->clip, clipBoxes) ||
        (drawW != pPriv->pwidth || drawH != pPriv->pheight)) {
        REGION_COPY(pScrni->pScreen, &pPriv->clip, clipBoxes);

        if (pPriv->colorKeyMode == 0) {
            xf86XVFillKeyHelper(pScrni->pScreen, pPriv->colorKey, clipBoxes);
        }

        LXDisplayVideo(pScrni, id, width, height, &dstBox,
                       srcW, srcH, drawW, drawH);
        pPriv->pwidth = drawW;
        pPriv->pheight = drawH;
    }

    pPriv->videoStatus = CLIENT_VIDEO_ON;

    return Success;
}

static void
LXQueryBestSize(ScrnInfoPtr pScrni, Bool motion,
                short vidW, short vidH, short drawW, short drawH,
                unsigned int *retW, unsigned int *retH, pointer data)
{
    *retW = drawW > 16384 ? 16384 : drawW;
    *retH = drawH;
}

static Atom xvColorKey, xvColorKeyMode, xvFilter;

static int
LXGetPortAttribute(ScrnInfoPtr pScrni,
                   Atom attribute, INT32 *value, pointer data)
{
    GeodePortPrivRec *pPriv = (GeodePortPrivRec *) data;

    if (attribute == xvColorKey)
        *value = pPriv->colorKey;
    else if (attribute == xvColorKeyMode)
        *value = pPriv->colorKeyMode;
    else if (attribute == xvFilter)
        *value = pPriv->filter;
    else
        return BadMatch;

    return Success;
}

static int
LXSetPortAttribute(ScrnInfoPtr pScrni,
                   Atom attribute, INT32 value, pointer data)
{
    GeodePortPrivRec *pPriv = (GeodePortPrivRec *) data;

    gp_wait_until_idle();

    if (attribute == xvColorKey) {
        pPriv->colorKey = value;
        LXSetColorkey(pScrni, pPriv);
    }
    else if (attribute == xvColorKeyMode) {
        pPriv->colorKeyMode = value;
        LXSetColorkey(pScrni, pPriv);
    }
    else if (attribute == xvFilter) {
        if ((value < 0) || (value > 1))
            return BadValue;
        pPriv->filter = value;
    }
    else
        return BadMatch;

    return Success;
}

static void
LXStopVideo(ScrnInfoPtr pScrni, pointer data, Bool exit)
{
    GeodePortPrivRec *pPriv = (GeodePortPrivRec *) data;

    if (pPriv->videoStatus == 0)
        return;

    REGION_EMPTY(pScrni->pScreen, &pPriv->clip);
    gp_wait_until_idle();

    if (exit) {
        if (pPriv->videoStatus & CLIENT_VIDEO_ON) {
            unsigned int val;

            df_set_video_enable(0, 0);
            /* Put the LUT back in bypass */
            val = READ_VID32(DF_VID_MISC);
            WRITE_VID32(DF_VID_MISC, val | DF_GAMMA_BYPASS_BOTH);
        }

        if (pPriv->vidmem) {
            exaOffscreenFree(pScrni->pScreen, pPriv->vidmem);
            pPriv->vidmem = NULL;
        }

        pPriv->videoStatus = 0;

        /* Eh? */
    }
    else if (pPriv->videoStatus & CLIENT_VIDEO_ON) {
        pPriv->videoStatus |= OFF_TIMER;
        pPriv->offTime = currentTime.milliseconds + OFF_DELAY;
    }
}

static void
LXResetVideo(ScrnInfoPtr pScrni)
{
    GeodeRec *pGeode = GEODEPTR(pScrni);

    if (!pGeode->NoAccel) {
        GeodePortPrivRec *pPriv = pGeode->adaptor->pPortPrivates[0].ptr;

        gp_wait_until_idle();
        df_set_video_palette(NULL);

        LXSetColorkey(pScrni, pPriv);
    }
}

static void
LXVidBlockHandler(BLOCKHANDLER_ARGS_DECL)
{
    SCREEN_PTR(arg);
    ScrnInfoPtr pScrni = xf86ScreenToScrn(pScrn);
    GeodeRec *pGeode = GEODEPTR(pScrni);
    GeodePortPrivRec *pPriv = GET_PORT_PRIVATE(pScrni);

    pScrn->BlockHandler = pGeode->BlockHandler;
    (*pScrn->BlockHandler) (BLOCKHANDLER_ARGS);
    pScrn->BlockHandler = LXVidBlockHandler;

    if (pPriv->videoStatus & TIMER_MASK) {
        Time now = currentTime.milliseconds;

        if (pPriv->videoStatus & OFF_TIMER) {
            gp_wait_until_idle();

            if (pPriv->offTime < now) {
                unsigned int val;

                df_set_video_enable(0, 0);
                pPriv->videoStatus = FREE_TIMER;
                pPriv->freeTime = now + FREE_DELAY;

                /* Turn off the video palette */
                val = READ_VID32(DF_VID_MISC);
                WRITE_VID32(DF_VID_MISC, val | DF_GAMMA_BYPASS_BOTH);
            }
        }
        else {
            if (pPriv->freeTime < now) {

                if (pPriv->vidmem) {
                    exaOffscreenFree(pScrni->pScreen, pPriv->vidmem);
                    pPriv->vidmem = NULL;
                }

                pPriv->videoStatus = 0;
            }
        }
    }
}

static XF86VideoAdaptorPtr
LXSetupImageVideo(ScreenPtr pScrn)
{
    ScrnInfoPtr pScrni = xf86ScreenToScrn(pScrn);
    GeodeRec *pGeode = GEODEPTR(pScrni);
    XF86VideoAdaptorPtr adapt;
    GeodePortPrivRec *pPriv;

    adapt = calloc(1, sizeof(XF86VideoAdaptorRec) +
                   sizeof(GeodePortPrivRec) + sizeof(DevUnion));

    if (adapt == NULL) {
        ErrorF("Couldn't create the rec\n");
        return NULL;
    }

    adapt->type = XvWindowMask | XvInputMask | XvImageMask;
    adapt->flags = VIDEO_OVERLAID_IMAGES | VIDEO_CLIP_TO_VIEWPORT;

    adapt->name = "AMD Geode LX";
    adapt->nEncodings = 1;
    adapt->pEncodings = DummyEncoding;
    adapt->nFormats = ARRAY_SIZE(Formats);
    adapt->pFormats = Formats;
    adapt->nPorts = 1;
    adapt->pPortPrivates = (DevUnion *) (&adapt[1]);
    pPriv = (GeodePortPrivRec *) (&adapt->pPortPrivates[1]);
    adapt->pPortPrivates[0].ptr = (pointer) (pPriv);
    adapt->pAttributes = Attributes;
    adapt->nImages = ARRAY_SIZE(Images);
    adapt->nAttributes = ARRAY_SIZE(Attributes);
    adapt->pImages = Images;
    adapt->PutVideo = NULL;
    adapt->PutStill = NULL;
    adapt->GetVideo = NULL;
    adapt->GetStill = NULL;
    adapt->StopVideo = LXStopVideo;
    adapt->SetPortAttribute = LXSetPortAttribute;
    adapt->GetPortAttribute = LXGetPortAttribute;
    adapt->QueryBestSize = LXQueryBestSize;
    adapt->PutImage = LXPutImage;

    /* Use the common function */
    adapt->QueryImageAttributes = GeodeQueryImageAttributes;

    pPriv->vidmem = NULL;
    pPriv->filter = 0;
    pPriv->colorKey = 0;
    pPriv->colorKeyMode = 0;
    pPriv->videoStatus = 0;
    pPriv->pwidth = 0;
    pPriv->pheight = 0;

    REGION_NULL(pScrn, &pPriv->clip);

    pGeode->adaptor = adapt;

    pGeode->BlockHandler = pScrn->BlockHandler;
    pScrn->BlockHandler = LXVidBlockHandler;

    xvColorKey = MAKE_ATOM("XV_COLORKEY");
    xvColorKeyMode = MAKE_ATOM("XV_COLORKEYMODE");
    xvFilter = MAKE_ATOM("XV_FILTER");

    LXResetVideo(pScrni);

    return adapt;
}

/* Offscreen surface allocation */

struct OffscreenPrivRec {
    ExaOffscreenArea *vidmem;
    Bool isOn;
};

static int
LXDisplaySurface(XF86SurfacePtr surface,
                 short srcX, short srcY, short drawX, short drawY,
                 short srcW, short srcH, short drawW, short drawH,
                 RegionPtr clipBoxes)
{
    struct OffscreenPrivRec *pPriv =
        (struct OffscreenPrivRec *) surface->devPrivate.ptr;

    ScrnInfoPtr pScrni = surface->pScrn;
    GeodePortPrivRec *portPriv = GET_PORT_PRIVATE(pScrni);

    BoxRec dstBox;

    dstBox.x1 = drawX;
    dstBox.x2 = drawX + drawW;
    dstBox.y1 = drawY;
    dstBox.y2 = drawY + drawH;

    if ((drawW <= 0) | (drawH <= 0))
        return Success;

    /* Is this still valid? */

    dstBox.x1 -= pScrni->frameX0;
    dstBox.x2 -= pScrni->frameX0;
    dstBox.y1 -= pScrni->frameY0;
    dstBox.y2 -= pScrni->frameY0;

    xf86XVFillKeyHelper(pScrni->pScreen, portPriv->colorKey, clipBoxes);

    videoScratch.dstOffset = surface->offsets[0];
    videoScratch.dstPitch = surface->pitches[0];

    LXDisplayVideo(pScrni, surface->id, surface->width, surface->height,
                   &dstBox, srcW, srcH, drawW, drawH);

    pPriv->isOn = TRUE;

    if (portPriv->videoStatus & CLIENT_VIDEO_ON) {
        REGION_EMPTY(pScrni->pScreen, &portPriv->clip);
        UpdateCurrentTime();
        portPriv->videoStatus = FREE_TIMER;
        portPriv->freeTime = currentTime.milliseconds + FREE_DELAY;
    }

    return Success;
}

static int
LXAllocateSurface(ScrnInfoPtr pScrni, int id, unsigned short w,
                  unsigned short h, XF86SurfacePtr surface)
{
    GeodeRec *pGeode = GEODEPTR(pScrni);
    int pitch, lines;
    ExaOffscreenArea *vidmem;
    struct OffscreenPrivRec *pPriv;

    if (w > 1024 || h > 1024)
        return BadAlloc;

    /* The width needs to be word aligned */
    w = (w + 1) & ~1;

    pitch = ((w << 1) + 15) & ~15;
    lines = ((pitch * h) + (pGeode->Pitch - 1)) / pGeode->Pitch;

    /* FIXME: is lines the right parameter to use here,
     * or should it be height * pitch? */
    vidmem = exaOffscreenAlloc(pScrni->pScreen, lines, 4, TRUE, NULL, NULL);

    if (vidmem == NULL) {
        ErrorF("Error while allocating an offscreen region.\n");
        return BadAlloc;
    }

    surface->width = w;
    surface->height = h;

    surface->pitches = malloc(sizeof(int));

    surface->offsets = malloc(sizeof(int));

    pPriv = malloc(sizeof(struct OffscreenPrivRec));

    if (pPriv && surface->pitches && surface->offsets) {

        pPriv->vidmem = vidmem;

        pPriv->isOn = FALSE;

        surface->pScrn = pScrni;
        surface->id = id;
        surface->pitches[0] = pitch;
        surface->offsets[0] = vidmem->offset;
        surface->devPrivate.ptr = (pointer) pPriv;

        return Success;
    }

    if (surface->offsets)
        free(surface->offsets);

    if (surface->pitches)
        free(surface->pitches);

    if (vidmem) {
        exaOffscreenFree(pScrni->pScreen, vidmem);
        vidmem = NULL;
    }

    return BadAlloc;
}

static int
LXStopSurface(XF86SurfacePtr surface)
{
    struct OffscreenPrivRec *pPriv = (struct OffscreenPrivRec *)
        surface->devPrivate.ptr;

    pPriv->isOn = FALSE;
    return Success;
}

static int
LXFreeSurface(XF86SurfacePtr surface)
{
    struct OffscreenPrivRec *pPriv = (struct OffscreenPrivRec *)
        surface->devPrivate.ptr;
    ScrnInfoPtr pScrni = surface->pScrn;

    if (pPriv->isOn)
        LXStopSurface(surface);

    if (pPriv->vidmem) {
        exaOffscreenFree(pScrni->pScreen, pPriv->vidmem);
        pPriv->vidmem = NULL;
    }

    free(surface->pitches);
    free(surface->offsets);
    free(surface->devPrivate.ptr);

    return Success;
}

static int
LXGetSurfaceAttribute(ScrnInfoPtr pScrni, Atom attribute, INT32 *value)
{
    return LXGetPortAttribute(pScrni, attribute, value,
                              (pointer) (GET_PORT_PRIVATE(pScrni)));
}

static int
LXSetSurfaceAttribute(ScrnInfoPtr pScrni, Atom attribute, INT32 value)
{
    return LXSetPortAttribute(pScrni, attribute, value,
                              (pointer) (GET_PORT_PRIVATE(pScrni)));
}

static void
LXInitOffscreenImages(ScreenPtr pScrn)
{
    XF86OffscreenImagePtr offscreenImages;

    /* need to free this someplace */
    if (!(offscreenImages = malloc(sizeof(XF86OffscreenImageRec))))
        return;

    offscreenImages[0].image = &Images[0];
    offscreenImages[0].flags = VIDEO_OVERLAID_IMAGES | VIDEO_CLIP_TO_VIEWPORT;
    offscreenImages[0].alloc_surface = LXAllocateSurface;
    offscreenImages[0].free_surface = LXFreeSurface;
    offscreenImages[0].display = LXDisplaySurface;
    offscreenImages[0].stop = LXStopSurface;
    offscreenImages[0].setAttribute = LXSetSurfaceAttribute;
    offscreenImages[0].getAttribute = LXGetSurfaceAttribute;
    offscreenImages[0].max_width = 1024;
    offscreenImages[0].max_height = 1024;
    offscreenImages[0].num_attributes = ARRAY_SIZE(Attributes);
    offscreenImages[0].attributes = Attributes;

    xf86XVRegisterOffscreenImages(pScrn, offscreenImages, 1);
}

void
LXInitVideo(ScreenPtr pScrn)
{
    GeodeRec *pGeode;
    ScrnInfoPtr pScrni = xf86ScreenToScrn(pScrn);
    XF86VideoAdaptorPtr *adaptors, *newAdaptors = NULL;
    XF86VideoAdaptorPtr newAdaptor = NULL;
    int num_adaptors;

    pGeode = GEODEPTR(pScrni);

    if (pGeode->NoAccel) {
        ErrorF("Cannot run Xv without accelerations!\n");
        return;
    }

    if (!(newAdaptor = LXSetupImageVideo(pScrn))) {
        ErrorF("Error while setting up the adaptor.\n");
        return;
    }

    LXInitOffscreenImages(pScrn);

    num_adaptors = xf86XVListGenericAdaptors(pScrni, &adaptors);

    if (!num_adaptors) {
        num_adaptors = 1;
        adaptors = &newAdaptor;
    }
    else {
        newAdaptors =
            malloc((num_adaptors + 1) * sizeof(XF86VideoAdaptorPtr *));

        if (newAdaptors) {
            memcpy(newAdaptors, adaptors, num_adaptors *
                   sizeof(XF86VideoAdaptorPtr));
            newAdaptors[num_adaptors] = newAdaptor;
            adaptors = newAdaptors;
            num_adaptors++;
        }
        else
            ErrorF("Memory error while setting up the adaptor\n");
    }

    if (num_adaptors)
        xf86XVScreenInit(pScrn, adaptors, num_adaptors);

    if (newAdaptors)
        free(newAdaptors);
}
@


1.5
log
@Update to xf86-video-geode 2.11.12. Tested on Alix 3C3.
@
text
@d64 1
d66 1
d72 2
d75 1
a75 1
    BoxPtr dstBox, short srcW, short srcH, short drawW, short drawH);
d104 1
a104 2
typedef struct
{
d121 1
a121 1
    int dstPitch, int srcPitch, int h, int w)
d142 5
a146 5
	vg_get_display_palette_entry(pPriv->colorKey & 0xFF, &key);
	red = ((key >> 16) & 0xFF);
	green = ((key >> 8) & 0xFF);
	blue = (key & 0xFF);
	break;
d148 7
a154 7
	red = (pPriv->colorKey & pScrni->mask.red) >>
	    pScrni->offset.red << (8 - pScrni->weight.red);
	green = (pPriv->colorKey & pScrni->mask.green) >>
	    pScrni->offset.green << (8 - pScrni->weight.green);
	blue = (pPriv->colorKey & pScrni->mask.blue) >>
	    pScrni->offset.blue << (8 - pScrni->weight.blue);
	break;
d156 12
a167 12
	/* for > 16 bpp we send in the mask in xf86SetWeight. This
	 * function is providing the offset by 1 more. So we take
	 * this as a special case and subtract 1 for > 16
	 */

	red = (pPriv->colorKey & pScrni->mask.red) >>
	    (pScrni->offset.red - 1) << (8 - pScrni->weight.red);
	green = (pPriv->colorKey & pScrni->mask.green) >>
	    (pScrni->offset.green - 1) << (8 - pScrni->weight.green);
	blue = (pPriv->colorKey & pScrni->mask.blue) >>
	    (pScrni->offset.blue - 1) << (8 - pScrni->weight.blue);
	break;
d171 1
a171 1
	0xFFFFFF, (pPriv->colorKeyMode == 0));
d182 1
a182 2
struct
{
d193 1
a193 1
LXAllocateVidMem(ScrnInfoPtr pScrni, GeodePortPrivRec *pPriv, int size)
d195 13
a207 13
    if (!pPriv->vidmem || pPriv->vidmem->size < size) { 
	if (pPriv->vidmem) {
		exaOffscreenFree(pScrni->pScreen, pPriv->vidmem);
		pPriv->vidmem = NULL;
	}

	pPriv->vidmem = exaOffscreenAlloc(pScrni->pScreen, size, 4,
			TRUE, NULL, NULL);

    	if (pPriv->vidmem == NULL) {
		ErrorF("Could not allocate memory for the video\n");
		return FALSE;
    	}
d211 1
a211 1
}	
d215 2
a216 2
    short x1, short y1, short x2, short y2,
    int width, int height, pointer data)
d245 2
a246 2
	ErrorF("Error allocating an offscreen Planar region.\n");
	return FALSE;
d273 2
a274 2
	pPriv->vidmem->offset + YDstOffset, YDstPitch, YSrcPitch, lines,
	pixels);
d279 2
a280 2
	pPriv->vidmem->offset + UDstOffset, UVDstPitch, UVSrcPitch, lines,
	pixels >> 1);
d293 2
a294 2
    short x1, short y1, short x2, short y2,
    int width, int height, pointer data)
d308 2
a309 2
	ErrorF("Error allocating an offscreen Packed region.\n");
	return FALSE;
d331 12
a342 11
	/* Use the shared (unaccelerated) greyscale copy - you could probably
	 * accelerate it using a 2 pass blit and patterns, but it doesn't really
	 * seem worth it
	 */

	GeodeCopyGreyscale(buf + srcOffset, pGeode->FBBase + dstOffset,
	    srcPitch, dstPitch, height, pixels >> 1);
    } else
	/* FIXME: should lines be used here instead of height? */
	LXCopyFromSys(pGeode, buf + srcOffset, dstOffset, dstPitch, srcPitch,
	    height, pixels);
d352 1
a352 1
    BoxPtr dstBox, short srcW, short srcH, short drawW, short drawH)
d367 2
a368 2
	vSrcParams.video_format = DF_VIDFMT_UYVY;
	break;
d373 2
a374 2
	vSrcParams.video_format = DF_VIDFMT_Y0Y1Y2Y3;
	break;
d376 2
a377 2
	vSrcParams.video_format = DF_VIDFMT_YUYV;
	break;
d379 2
a380 2
	vSrcParams.video_format = DF_VIDFMT_Y2YU;
	break;
d382 2
a383 2
	vSrcParams.video_format = DF_VIDFMT_YVYU;
	break;
d385 2
a386 2
	vSrcParams.video_format = DF_VIDFMT_RGB;
	break;
d398 1
a398 1
	DF_SCALEFLAG_CHANGEX | DF_SCALEFLAG_CHANGEY);
d400 3
a402 3
	/* Note the problem, but do nothing for now. */
	ErrorF("Video scale factor too large: %dx%d -> %dx%d\n",
	    width, height, drawW, drawH);
d411 11
a421 10
	if (srcH < drawH)
	    lines = ((-dstBox->y1) * srcH) / drawH;
	else
	    lines = (-dstBox->y1);

	ystart = 0;
	drawH += dstBox->y1;
    } else {
	ystart = dstBox->y1;
	lines = 0;
d441 3
a443 3
	vSrcParams.u_offset = videoScratch.UDstOffset + uvExtra;
	vSrcParams.v_offset = videoScratch.VDstOffset + uvExtra;
	break;
d445 3
a447 3
	vSrcParams.v_offset = videoScratch.UDstOffset + uvExtra;
	vSrcParams.u_offset = videoScratch.VDstOffset + uvExtra;
	break;
d450 2
a451 2
	vSrcParams.u_offset = vSrcParams.v_offset = 0;
	break;
d464 5
a468 5
    short srcX, short srcY, short drawX, short drawY,
    short srcW, short srcH, short drawW, short drawH,
    int id, unsigned char *buf,
    short width, short height, Bool sync, RegionPtr clipBoxes,
    pointer data, DrawablePtr pDraw)
d477 1
a477 1
	return Success;
d480 1
a480 1
	return Success;
d484 1
a484 1
	return Success;
d488 1
a488 1
	drawW = 16384;
d508 2
a509 2
	ret = LXCopyPlanar(pScrni, id, buf, x1, y1, x2, y2, width,
			height, data);
d511 2
a512 2
	ret = LXCopyPacked(pScrni, id, buf, x1, y1, x2, y2, width,
			height, data);
d515 2
a516 2
	return BadAlloc;
	
d518 2
a519 2
	(drawW != pPriv->pwidth || drawH != pPriv->pheight)) {
	REGION_COPY(pScrni->pScreen, &pPriv->clip, clipBoxes);
d521 8
a528 8
	if (pPriv->colorKeyMode == 0) {
	    xf86XVFillKeyHelper(pScrni->pScreen, pPriv->colorKey, clipBoxes);
	}

	LXDisplayVideo(pScrni, id, width, height, &dstBox,
	    srcW, srcH, drawW, drawH);
	pPriv->pwidth = drawW;
	pPriv->pheight = drawH;
d538 2
a539 2
    short vidW, short vidH, short drawW, short drawH,
    unsigned int *retW, unsigned int *retH, pointer data)
d549 1
a549 1
    Atom attribute, INT32 * value, pointer data)
d554 1
a554 1
	*value = pPriv->colorKey;
d556 1
a556 1
	*value = pPriv->colorKeyMode;
d558 1
a558 1
	*value = pPriv->filter;
d560 1
a560 1
	return BadMatch;
d567 1
a567 1
    Atom attribute, INT32 value, pointer data)
d574 14
a587 11
	pPriv->colorKey = value;
	LXSetColorkey(pScrni, pPriv);
    } else if (attribute == xvColorKeyMode) {
	pPriv->colorKeyMode = value;
	LXSetColorkey(pScrni, pPriv);
    } else if (attribute == xvFilter) {
	if ((value < 0) || (value > 1))
	    return BadValue;
	pPriv->filter = value;
    } else
	return BadMatch;
d598 1
a598 1
	return;
d604 2
a605 2
	if (pPriv->videoStatus & CLIENT_VIDEO_ON) {
	    unsigned int val;
d607 18
a624 17
	    df_set_video_enable(0, 0);
	    /* Put the LUT back in bypass */
	    val = READ_VID32(DF_VID_MISC);
	    WRITE_VID32(DF_VID_MISC, val | DF_GAMMA_BYPASS_BOTH);
	}

	if (pPriv->vidmem) {
	    exaOffscreenFree(pScrni->pScreen, pPriv->vidmem);
	    pPriv->vidmem = NULL;
	}

	pPriv->videoStatus = 0;

	/* Eh? */
    } else if (pPriv->videoStatus & CLIENT_VIDEO_ON) {
	pPriv->videoStatus |= OFF_TIMER;
	pPriv->offTime = currentTime.milliseconds + OFF_DELAY;
d634 1
a634 1
	GeodePortPrivRec *pPriv = pGeode->adaptor->pPortPrivates[0].ptr;
d636 2
a637 2
	gp_wait_until_idle();
	df_set_video_palette(NULL);
d639 1
a639 1
	LXSetColorkey(pScrni, pPriv);
d644 1
a644 2
LXVidBlockHandler(int i, pointer blockData, pointer pTimeout,
    pointer pReadmask)
d646 2
a647 2
    ScreenPtr pScrn = screenInfo.screens[i];
    ScrnInfoPtr pScrni = xf86Screens[i];
d652 1
a652 1
    (*pScrn->BlockHandler) (i, blockData, pTimeout, pReadmask);
d656 1
a656 1
	Time now = currentTime.milliseconds;
d658 2
a659 2
	if (pPriv->videoStatus & OFF_TIMER) {
	    gp_wait_until_idle();
d661 2
a662 2
	    if (pPriv->offTime < now) {
		unsigned int val;
d664 20
a683 19
		df_set_video_enable(0, 0);
		pPriv->videoStatus = FREE_TIMER;
		pPriv->freeTime = now + FREE_DELAY;

		/* Turn off the video palette */
		val = READ_VID32(DF_VID_MISC);
		WRITE_VID32(DF_VID_MISC, val | DF_GAMMA_BYPASS_BOTH);
	    }
	} else {
	    if (pPriv->freeTime < now) {

		if (pPriv->vidmem) {
		    exaOffscreenFree(pScrni->pScreen, pPriv->vidmem);
		    pPriv->vidmem = NULL;
		}

		pPriv->videoStatus = 0;
	    }
	}
d690 1
a690 1
    ScrnInfoPtr pScrni = xf86Screens[pScrn->myNum];
d696 1
a696 1
	sizeof(GeodePortPrivRec) + sizeof(DevUnion));
d699 2
a700 2
	ErrorF("Couldn't create the rec\n");
	return NULL;
d758 1
a758 2
struct OffscreenPrivRec
{
d765 3
a767 2
    short srcX, short srcY, short drawX, short drawY,
    short srcW, short srcH, short drawW, short drawH, RegionPtr clipBoxes)
d770 1
a770 1
	(struct OffscreenPrivRec *)surface->devPrivate.ptr;
d783 1
a783 1
	return Success;
d798 1
a798 1
	&dstBox, srcW, srcH, drawW, drawH);
d803 4
a806 4
	REGION_EMPTY(pScrni->pScreen, &portPriv->clip);
	UpdateCurrentTime();
	portPriv->videoStatus = FREE_TIMER;
	portPriv->freeTime = currentTime.milliseconds + FREE_DELAY;
d814 1
a814 1
    unsigned short h, XF86SurfacePtr surface)
d822 1
a822 1
	return BadAlloc;
d832 1
a832 2
    vidmem = exaOffscreenAlloc(pScrni->pScreen, lines, 4, TRUE,
		NULL, NULL);
d835 2
a836 2
	ErrorF("Error while allocating an offscreen region.\n");
	return BadAlloc;
d850 1
a850 1
	pPriv->vidmem = vidmem;
d852 1
a852 1
	pPriv->isOn = FALSE;
d854 5
a858 5
	surface->pScrn = pScrni;
	surface->id = id;
	surface->pitches[0] = pitch;
	surface->offsets[0] = vidmem->offset;
	surface->devPrivate.ptr = (pointer) pPriv;
d860 1
a860 1
	return Success;
d864 1
a864 1
	free(surface->offsets);
d867 1
a867 1
	free(surface->pitches);
d870 2
a871 2
	exaOffscreenFree(pScrni->pScreen, vidmem);
	vidmem = NULL;
d881 1
a881 1
	surface->devPrivate.ptr;
d891 1
a891 1
	surface->devPrivate.ptr;
d895 1
a895 1
	LXStopSurface(surface);
d898 2
a899 2
	exaOffscreenFree(pScrni->pScreen, pPriv->vidmem);
	pPriv->vidmem = NULL;
d910 1
a910 1
LXGetSurfaceAttribute(ScrnInfoPtr pScrni, Atom attribute, INT32 * value)
d913 1
a913 1
	(pointer) (GET_PORT_PRIVATE(pScrni)));
d920 1
a920 1
	(pointer) (GET_PORT_PRIVATE(pScrni)));
d930 1
a930 1
	return;
d952 1
a952 1
    ScrnInfoPtr pScrni = xf86Screens[pScrn->myNum];
d960 2
a961 2
	ErrorF("Cannot run Xv without accelerations!\n");
	return;
d965 2
a966 2
	ErrorF("Error while setting up the adaptor.\n");
	return;
d974 16
a989 14
	num_adaptors = 1;
	adaptors = &newAdaptor;
    } else {
	newAdaptors =
	    malloc((num_adaptors + 1) * sizeof(XF86VideoAdaptorPtr *));

	if (newAdaptors) {
	    memcpy(newAdaptors, adaptors, num_adaptors *
		sizeof(XF86VideoAdaptorPtr));
	    newAdaptors[num_adaptors] = newAdaptor;
	    adaptors = newAdaptors;
	    num_adaptors++;
	} else
	    ErrorF("Memory error while setting up the adaptor\n");
d993 1
a993 1
	xf86XVScreenInit(pScrn, adaptors, num_adaptors);
d996 1
a996 1
	free(newAdaptors);
@


1.4
log
@Update to xf86-video-geode 2.11.10. Tested on Alix 3C3.
@
text
@d305 1
a305 1
    if (LXAllocateVidMem(pScrni, pPriv, lines) == FALSE) {
d337 1
d822 2
@


1.3
log
@Update to xf86-video-geode 2.11.9.
A bunch of bug fixes and performance improvements. Tested on Alix 3c3.
@
text
@d102 1
a102 1
    GeodeMemPtr vidmem;
d191 1
a191 1
LXAllocMem(GeodeRec *pGeode, GeodePortPrivRec *pPriv, int size)
d194 4
a197 2
	if (pPriv->vidmem) 
		GeodeFreeOffscreen(pGeode, pPriv->vidmem);
d199 2
a200 1
    	pPriv->vidmem = GeodeAllocOffscreen(pGeode, size, 4);
d242 2
a243 1
    if (LXAllocMem(pGeode, pPriv, size) == FALSE)
d245 1
d305 2
a306 1
    if (LXAllocMem(pGeode, pPriv, lines) == FALSE)
d308 1
a587 1
    GeodeRec *pGeode = GEODEPTR(pScrni);
d606 1
a606 1
	    GeodeFreeOffscreen(pGeode, pPriv->vidmem);
d668 1
a668 1
		    GeodeFreeOffscreen(pGeode, pPriv->vidmem);
d686 1
a686 1
    adapt = xcalloc(1, sizeof(XF86VideoAdaptorRec) +
d751 1
a751 1
    GeodeMemPtr vidmem;
d809 1
a809 1
    GeodeMemPtr vidmem;
d821 2
a822 1
    vidmem = GeodeAllocOffscreen(pGeode, lines, 4);
d832 1
a832 1
    surface->pitches = xalloc(sizeof(int));
d834 1
a834 1
    surface->offsets = xalloc(sizeof(int));
d836 1
a836 1
    pPriv = xalloc(sizeof(struct OffscreenPrivRec));
d854 1
a854 1
	xfree(surface->offsets);
d857 1
a857 1
	xfree(surface->pitches);
d859 4
a862 2
    if (vidmem)
	GeodeFreeOffscreen(pGeode, vidmem);
a882 1
    GeodeRec *pGeode = GEODEPTR(pScrni);
d888 1
a888 1
	GeodeFreeOffscreen(pGeode, pPriv->vidmem);
d892 3
a894 3
    xfree(surface->pitches);
    xfree(surface->offsets);
    xfree(surface->devPrivate.ptr);
d919 1
a919 1
    if (!(offscreenImages = xalloc(sizeof(XF86OffscreenImageRec))))
d968 1
a968 1
	    xalloc((num_adaptors + 1) * sizeof(XF86VideoAdaptorPtr *));
d984 1
a984 1
	xfree(newAdaptors);
@


1.2
log
@update to xf86-video-geode 2.11.6. Tested on a Alix 3C3.
@
text
@d122 1
a122 1
    gp_set_bpp(16);
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/* Copyright (c) 2007 Advanced Micro Devices, Inc.
a40 1
#include "xf86Resources.h"
d102 1
a102 2
    void *area;
    int offset;
a131 32
LXVideoSave(ScreenPtr pScreen, ExaOffscreenArea * area)
{
    ScrnInfoPtr pScrni = xf86Screens[pScreen->myNum];

    GeodePortPrivRec *pPriv = GET_PORT_PRIVATE(pScrni);

    if (area == pPriv->area)
	pPriv->area = NULL;

    LXStopVideo(pScrni, (void *)pPriv, TRUE);
}

static unsigned int
LXAllocateVidMem(ScrnInfoPtr pScrni, void **memp, int size)
{
    ExaOffscreenArea *area = *memp;

    if (area != NULL) {
	if (area->size >= size)
	    return area->offset;

	exaOffscreenFree(pScrni->pScreen, area);
    }

    area = exaOffscreenAlloc(pScrni->pScreen, size, 16, TRUE,
	LXVideoSave, NULL);

    *memp = area;
    return (area == NULL) ? 0 : area->offset;
}

static void
d191 18
d239 1
a239 4
    pPriv->offset = LXAllocateVidMem(pScrni, &pPriv->area, size);

    if (pPriv->offset == 0) {
	ErrorF("Error allocating an offscreen region.\n");
a240 1
    }
d265 3
a267 2
    LXCopyFromSys(pGeode, buf + YSrcOffset, pPriv->offset + YDstOffset,
	YDstPitch, YSrcPitch, lines, pixels);
d271 3
a273 2
    LXCopyFromSys(pGeode, buf + USrcOffset, pPriv->offset + UDstOffset,
	UVDstPitch, UVSrcPitch, lines, pixels >> 1);
d275 1
a275 1
    videoScratch.dstOffset = pPriv->offset + YDstOffset;
d278 2
a279 2
    videoScratch.UDstOffset = pPriv->offset + UDstOffset;
    videoScratch.VDstOffset = pPriv->offset + VDstOffset;
d300 1
a300 4
    pPriv->offset = LXAllocateVidMem(pScrni, &pPriv->area, height * dstPitch);

    if (pPriv->offset == 0) {
	ErrorF("Error while allocating an offscreen region.\n");
a301 1
    }
d316 1
a316 1
    dstOffset = pPriv->offset + (top * dstPitch) + left;
d462 1
d495 6
a500 13
    switch (id) {
    case FOURCC_YV12:
    case FOURCC_I420:
	LXCopyPlanar(pScrni, id, buf, x1, y1, x2, y2, width, height, data);
	break;

    case FOURCC_UYVY:
    case FOURCC_YUY2:
    case FOURCC_Y800:
    case FOURCC_RGB565:
	LXCopyPacked(pScrni, id, buf, x1, y1, x2, y2, width, height, data);
	break;
    }
d502 3
a519 1
    pGeode->OverlayON = TRUE;
d599 3
a601 3
	if (pPriv->area) {
	    exaOffscreenFree(pScrni->pScreen, pPriv->area);
	    pPriv->area = NULL;
a606 1
	pGeode->OverlayON = FALSE;
d660 4
a663 3
		if (pPriv->area) {
		    exaOffscreenFree(pScrni->pScreen, pPriv->area);
		    pPriv->area = NULL;
d717 1
d719 1
a719 1
    pPriv->colorKey = pGeode->videoKey;
d745 1
a745 2
    void *area;
    int offset;
a801 1
    void *area = NULL;
d803 1
a803 1
    unsigned offset;
d815 1
a815 1
    offset = LXAllocateVidMem(pScrni, &area, lines);
d817 1
a817 1
    if (offset == 0) {
d833 1
a833 2
	pPriv->area = area;
	pPriv->offset = offset;
d840 1
a840 1
	surface->offsets[0] = offset;
d852 2
a853 2
    if (area)
	exaOffscreenFree(pScrni->pScreen, area);
d874 1
d879 3
a881 3
    if (pPriv->area) {
	exaOffscreenFree(pScrni->pScreen, pPriv->area);
	pPriv->area = NULL;
@


1.1.1.1
log
@Import the xf86-video-geode driver for the AMD Geode LX graphics processor.

with and ok matthieu
@
text
@@
