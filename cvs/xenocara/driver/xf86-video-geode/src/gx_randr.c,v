head	1.8;
access;
symbols
	OPENBSD_6_0:1.8.0.16
	OPENBSD_6_0_BASE:1.8
	OPENBSD_5_9:1.8.0.14
	OPENBSD_5_9_BASE:1.8
	OPENBSD_5_8:1.8.0.12
	OPENBSD_5_8_BASE:1.8
	OPENBSD_5_7:1.8.0.10
	OPENBSD_5_7_BASE:1.8
	OPENBSD_5_6:1.8.0.8
	OPENBSD_5_6_BASE:1.8
	OPENBSD_5_5:1.8.0.6
	OPENBSD_5_5_BASE:1.8
	OPENBSD_5_4:1.8.0.4
	OPENBSD_5_4_BASE:1.8
	OPENBSD_5_3:1.8.0.2
	OPENBSD_5_3_BASE:1.8
	OPENBSD_5_2:1.7.0.2
	OPENBSD_5_2_BASE:1.7
	OPENBSD_5_1_BASE:1.6
	OPENBSD_5_1:1.6.0.2
	OPENBSD_5_0:1.5.0.4
	OPENBSD_5_0_BASE:1.5
	OPENBSD_4_9:1.5.0.2
	OPENBSD_4_9_BASE:1.5
	OPENBSD_4_8:1.3.0.6
	OPENBSD_4_8_BASE:1.3
	OPENBSD_4_7:1.3.0.2
	OPENBSD_4_7_BASE:1.3
	OPENBSD_4_6:1.1.1.1.0.6
	OPENBSD_4_6_BASE:1.1.1.1
	OPENBSD_4_5:1.1.1.1.0.4
	OPENBSD_4_5_BASE:1.1.1.1
	OPENBSD_4_4:1.1.1.1.0.2
	OPENBSD_4_4_BASE:1.1.1.1
	v2_10_0:1.1.1.1
	xorg:1.1.1;
locks; strict;
comment	@ * @;


1.8
date	2012.12.16.23.04.18;	author matthieu;	state Exp;
branches;
next	1.7;

1.7
date	2012.02.20.21.43.31;	author matthieu;	state Exp;
branches;
next	1.6;

1.6
date	2011.09.13.20.25.35;	author matthieu;	state Exp;
branches;
next	1.5;

1.5
date	2010.12.07.21.54.11;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2010.11.05.12.30.03;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2009.10.11.09.30.15;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2009.09.06.12.22.42;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2008.06.14.22.15.42;	author mbalmer;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2008.06.14.22.15.42;	author mbalmer;	state Exp;
branches;
next	;


desc
@@


1.8
log
@Update to xf86-video-geode 2.11.14
@
text
@/* Originally derived from the Intel example
 * Copyright (C) 2002 Keith Packard, member of The XFree86 Project, Inc.

 * Copyright (c) 2006 Advanced Micro Devices, Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to
 * deal in the Software without restriction, including without limitation the
 * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
 * sell copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
 * IN THE SOFTWARE.
 *
 * Neither the name of the Advanced Micro Devices, Inc. nor the names of its
 * contributors may be used to endorse or promote products derived from this
 * software without specific prior written permission.
 */

#ifdef HAVE_CONFIG_H
#include "config.h"
#endif

#include "xf86.h"
#include "xf86Modes.h"
#include "os.h"
#include "globals.h"
#include "xf86.h"
#include "xf86Priv.h"
#include "xf86DDC.h"
#include "xf86Module.h"
#include "mipointer.h"
#include "windowstr.h"
#include "inputstr.h"
#include <X11/extensions/randr.h>
#include <randrstr.h>

#include "geode.h"

static int GXRandRGeneration;

typedef struct _GXRandRInfo {
    int virtualX;
    int virtualY;
    int mmWidth;
    int mmHeight;
    int maxX;
    int maxY;
    Rotation rotation;          /* current mode */
    Rotation supported_rotations;       /* driver supported */
} XF86RandRInfoRec, *XF86RandRInfoPtr;

#if HAS_DEVPRIVATEKEYREC
static DevPrivateKeyRec GXRandRIndex;
#else
static int GXRandRIndex;
#endif

#define OLD_VIDEODRV_INTERFACE (GET_ABI_MAJOR(ABI_VIDEODRV_VERSION) < 4)

#if OLD_VIDEODRV_INTERFACE
#define XF86RANDRINFO(p)   ((XF86RandRInfoPtr) (p)->devPrivates[GXRandRIndex].ptr)
#define XF86RANDRSET(p, v) (p)->devPrivates[GXRandRIndex].ptr = v
#else
#define XF86RANDRINFO(p) ((XF86RandRInfoPtr)						\
			  dixLookupPrivate(&(p)->devPrivates, &GXRandRIndex))
#define XF86RANDRSET(p, v) dixSetPrivate(&(p)->devPrivates, &GXRandRIndex, v)
#endif

static int
GXRandRModeRefresh(DisplayModePtr mode)
{
    if (mode->VRefresh)
        return (int) (mode->VRefresh + 0.5);
    else
        return (int) (mode->Clock * 1000.0 / mode->HTotal / mode->VTotal + 0.5);
}

static Bool
GXRandRGetInfo(ScreenPtr pScreen, Rotation * rotations)
{
    RRScreenSizePtr pSize;
    ScrnInfoPtr pScrni = XF86SCRNINFO(pScreen);
    XF86RandRInfoPtr pRandr = XF86RANDRINFO(pScreen);
    DisplayModePtr mode;
    int refresh0 = 60;
    int maxX = 0, maxY = 0;

    *rotations = pRandr->supported_rotations;

    if (pRandr->virtualX == -1 || pRandr->virtualY == -1) {
        pRandr->virtualX = pScrni->virtualX;
        pRandr->virtualY = pScrni->virtualY;
    }

    for (mode = pScrni->modes;; mode = mode->next) {
        int refresh = GXRandRModeRefresh(mode);

        if (pRandr->maxX == 0 || pRandr->maxY == 0) {
            if (maxX < mode->HDisplay)
                maxX = mode->HDisplay;
            if (maxY < mode->VDisplay)
                maxY = mode->VDisplay;
        }

        if (mode == pScrni->modes)
            refresh0 = refresh;

        pSize = RRRegisterSize(pScreen,
                               mode->HDisplay, mode->VDisplay,
                               pRandr->mmWidth, pRandr->mmHeight);
        if (!pSize)
            return FALSE;

        RRRegisterRate(pScreen, pSize, refresh);

        if (mode == pScrni->currentMode &&
            mode->HDisplay == pScrni->virtualX
            && mode->VDisplay == pScrni->virtualY)
            RRSetCurrentConfig(pScreen, pRandr->rotation, refresh, pSize);
        if (mode->next == pScrni->modes)
            break;
    }

    if (pRandr->maxX == 0 || pRandr->maxY == 0) {
        pRandr->maxX = maxX;
        pRandr->maxY = maxY;
    }

    if (pScrni->currentMode->HDisplay != pScrni->virtualX ||
        pScrni->currentMode->VDisplay != pScrni->virtualY) {

        mode = pScrni->modes;
        pSize = RRRegisterSize(pScreen,
                               pRandr->virtualX, pRandr->virtualY,
                               pRandr->mmWidth, pRandr->mmHeight);
        if (!pSize)
            return FALSE;

        RRRegisterRate(pScreen, pSize, refresh0);
        if (pScrni->virtualX == pRandr->virtualX &&
            pScrni->virtualY == pRandr->virtualY) {
            RRSetCurrentConfig(pScreen, pRandr->rotation, refresh0, pSize);
        }
    }

    return TRUE;
}

static Bool
GXRandRSetMode(ScreenPtr pScreen,
               DisplayModePtr mode, Bool useVirtual, int mmWidth, int mmHeight)
{
    ScrnInfoPtr pScrni = XF86SCRNINFO(pScreen);
    XF86RandRInfoPtr pRandr = XF86RANDRINFO(pScreen);

    int oldWidth = pScreen->width;
    int oldHeight = pScreen->height;
    int oldmmWidth = pScreen->mmWidth;
    int oldmmHeight = pScreen->mmHeight;

#if GET_ABI_MAJOR(ABI_VIDEODRV_VERSION) < 8
    WindowPtr pRoot = WindowTable[pScreen->myNum];
#else
    WindowPtr pRoot = pScreen->root;
#endif
    DisplayModePtr currentMode = NULL;
    Bool ret = TRUE;

#if XORG_VERSION_CURRENT < XORG_VERSION_NUMERIC(1,9,99,1,0)
    PixmapPtr pspix = NULL;
#endif

    if (pRoot)
        (*pScrni->
         EnableDisableFBAccess) (XF86_ENABLEDISABLEFB_ARG(pScrni, FALSE));

    if (useVirtual) {
        pScrni->virtualX = pRandr->virtualX;
        pScrni->virtualY = pRandr->virtualY;
    }
    else {
        pScrni->virtualX = mode->HDisplay;
        pScrni->virtualY = mode->VDisplay;
    }

    if (pRandr->rotation & (RR_Rotate_90 | RR_Rotate_270)) {
        pScreen->width = pScrni->virtualY;
        pScreen->height = pScrni->virtualX;
        pScreen->mmWidth = mmHeight;
        pScreen->mmHeight = mmWidth;
    }
    else {
        pScreen->width = pScrni->virtualX;
        pScreen->height = pScrni->virtualY;
        pScreen->mmWidth = mmWidth;
        pScreen->mmHeight = mmHeight;
    }

    if (pScrni->currentMode == mode) {
        currentMode = pScrni->currentMode;
        pScrni->currentMode = NULL;
    }

    if (!xf86SwitchMode(pScreen, mode)) {
        ret = FALSE;
        pScrni->virtualX = pScreen->width = oldWidth;
        pScrni->virtualY = pScreen->height = oldHeight;
        pScreen->mmWidth = oldmmWidth;
        pScreen->mmHeight = oldmmHeight;
        pScrni->currentMode = currentMode;
    }

#if XORG_VERSION_CURRENT < XORG_VERSION_NUMERIC(1,9,99,1,0)
    /*
     * Get the new Screen pixmap ptr as SwitchMode might have called
     * ModifyPixmapHeader and xf86EnableDisableFBAccess will put it back...
     * Unfortunately.
     */
    pspix = (*pScreen->GetScreenPixmap) (pScreen);
    if (pspix->devPrivate.ptr)
        pScrni->pixmapPrivate = pspix->devPrivate;
#endif

    xf86ReconfigureLayout();

    xf86SetViewport(pScreen, pScreen->width, pScreen->height);
    xf86SetViewport(pScreen, 0, 0);

    if (pRoot)
        (*pScrni->
         EnableDisableFBAccess) (XF86_ENABLEDISABLEFB_ARG(pScrni, TRUE));

    return ret;
}

Bool
GXRandRSetConfig(ScreenPtr pScreen, Rotation rotation,
                 int rate, RRScreenSizePtr pSize)
{
    ScrnInfoPtr pScrni = XF86SCRNINFO(pScreen);
    XF86RandRInfoPtr pRandr = XF86RANDRINFO(pScreen);

    DisplayModePtr mode;
    int px, py;
    Bool useVirtual = FALSE;
    int maxX = 0, maxY = 0;
    Rotation oldRotation = pRandr->rotation;

    pRandr->rotation = rotation;

    if (pRandr->virtualX == -1 || pRandr->virtualY == -1) {
        pRandr->virtualX = pScrni->virtualX;
        pRandr->virtualY = pScrni->virtualY;
    }

/* FIXME: we don't have a new video ABI yet */
#if GET_ABI_MAJOR(ABI_XINPUT_VERSION) >= 3
    miPointerGetPosition(inputInfo.pointer, &px, &py);
#else
    miPointerPosition(&px, &py);
#endif

    for (mode = pScrni->modes;; mode = mode->next) {
        if (pRandr->maxX == 0 || pRandr->maxY == 0) {
            if (maxX < mode->HDisplay)
                maxX = mode->HDisplay;
            if (maxY < mode->VDisplay)
                maxY = mode->VDisplay;
        }
        if (mode->HDisplay == pSize->width &&
            mode->VDisplay == pSize->height &&
            (rate == 0 || GXRandRModeRefresh(mode) == rate))
            break;
        if (mode->next == pScrni->modes) {
            if (pSize->width == pRandr->virtualX &&
                pSize->height == pRandr->virtualY) {
                mode = pScrni->modes;
                useVirtual = TRUE;
                break;
            }
            if (pRandr->maxX == 0 || pRandr->maxY == 0) {
                pRandr->maxX = maxX;
                pRandr->maxY = maxY;
            }
            return FALSE;
        }
    }

    if (pRandr->maxX == 0 || pRandr->maxY == 0) {
        pRandr->maxX = maxX;
        pRandr->maxY = maxY;
    }

    if (!GXRandRSetMode(pScreen, mode, useVirtual, pSize->mmWidth,
                        pSize->mmHeight)) {
        pRandr->rotation = oldRotation;
        return FALSE;
    }

/* FIXME: we don't have a new video ABI yet */
#if GET_ABI_MAJOR(ABI_XINPUT_VERSION) >= 3
    if (pScreen == miPointerGetScreen(inputInfo.pointer))
#else
    if (pScreen == miPointerCurrentScreen())
#endif
    {
        px = (px >= pScreen->width ? (pScreen->width - 1) : px);
        py = (py >= pScreen->height ? (pScreen->height - 1) : py);

        xf86SetViewport(pScreen, px, py);

/* FIXME: we don't have a new video ABI yet */
        (*pScreen->SetCursorPosition) (
#if GET_ABI_MAJOR(ABI_XINPUT_VERSION) >= 3
                                          inputInfo.pointer,
#endif
                                          pScreen, px, py, FALSE);
    }

    return TRUE;
}

Rotation
GXGetRotation(ScreenPtr pScreen)
{
    XF86RandRInfoPtr pRandr = XF86RANDRINFO(pScreen);

    return pRandr->rotation;
}

Bool
GXRandRInit(ScreenPtr pScreen, int rotation)
{
    XF86RandRInfoPtr pRandr;
    rrScrPrivPtr rp;

    if (GXRandRGeneration != serverGeneration) {
        GXRandRGeneration = serverGeneration;
    }
#if OLD_VIDEODRV_INTERFACE
    GXRandRIndex = AllocateScreenPrivateIndex();
#endif
#if HAS_DIXREGISTERPRIVATEKEY
    if (!dixRegisterPrivateKey(&GXRandRIndex, PRIVATE_SCREEN, 0))
        return FALSE;
#endif

    pRandr = calloc(1, sizeof(XF86RandRInfoRec));
    if (pRandr == NULL)
        return FALSE;

    if (!RRScreenInit(pScreen)) {
        free(pRandr);
        return FALSE;
    }

    rp = rrGetScrPriv(pScreen);
    rp->rrGetInfo = GXRandRGetInfo;
    rp->rrSetConfig = GXRandRSetConfig;

    pRandr->virtualX = -1;
    pRandr->virtualY = -1;

    pRandr->mmWidth = pScreen->mmWidth;
    pRandr->mmHeight = pScreen->mmHeight;

    pRandr->rotation = RR_Rotate_0;
    pRandr->supported_rotations = rotation;
    pRandr->maxX = pRandr->maxY = 0;

    XF86RANDRSET(pScreen, pRandr);

    return TRUE;
}
@


1.7
log
@Update to xf86-video-geode 2.11.13
@
text
@d51 1
a51 2
typedef struct _GXRandRInfo
{
d58 2
a59 2
    Rotation rotation;		       /* current mode */
    Rotation supported_rotations;      /* driver supported */
d83 1
a83 1
	return (int)(mode->VRefresh + 0.5);
d85 1
a85 2
	return (int)(mode->Clock * 1000.0 / mode->HTotal / mode->VTotal +
	    0.5);
d101 2
a102 2
	pRandr->virtualX = pScrni->virtualX;
	pRandr->virtualY = pScrni->virtualY;
d106 1
a106 1
	int refresh = GXRandRModeRefresh(mode);
d108 24
a131 24
	if (pRandr->maxX == 0 || pRandr->maxY == 0) {
	    if (maxX < mode->HDisplay)
		maxX = mode->HDisplay;
	    if (maxY < mode->VDisplay)
		maxY = mode->VDisplay;
	}

	if (mode == pScrni->modes)
	    refresh0 = refresh;

	pSize = RRRegisterSize(pScreen,
	    mode->HDisplay, mode->VDisplay,
	    pRandr->mmWidth, pRandr->mmHeight);
	if (!pSize)
	    return FALSE;

	RRRegisterRate(pScreen, pSize, refresh);

	if (mode == pScrni->currentMode &&
	    mode->HDisplay == pScrni->virtualX
	    && mode->VDisplay == pScrni->virtualY)
	    RRSetCurrentConfig(pScreen, pRandr->rotation, refresh, pSize);
	if (mode->next == pScrni->modes)
	    break;
d135 2
a136 2
	pRandr->maxX = maxX;
	pRandr->maxY = maxY;
d140 1
a140 1
	pScrni->currentMode->VDisplay != pScrni->virtualY) {
d142 12
a153 12
	mode = pScrni->modes;
	pSize = RRRegisterSize(pScreen,
	    pRandr->virtualX, pRandr->virtualY,
	    pRandr->mmWidth, pRandr->mmHeight);
	if (!pSize)
	    return FALSE;

	RRRegisterRate(pScreen, pSize, refresh0);
	if (pScrni->virtualX == pRandr->virtualX &&
	    pScrni->virtualY == pRandr->virtualY) {
	    RRSetCurrentConfig(pScreen, pRandr->rotation, refresh0, pSize);
	}
d161 1
a161 1
    DisplayModePtr mode, Bool useVirtual, int mmWidth, int mmHeight)
d170 1
d178 1
d181 1
a181 1
 #endif
d184 2
a185 1
	(*pScrni->EnableDisableFBAccess) (pScreen->myNum, FALSE);
d188 6
a193 5
	pScrni->virtualX = pRandr->virtualX;
	pScrni->virtualY = pRandr->virtualY;
    } else {
	pScrni->virtualX = mode->HDisplay;
	pScrni->virtualY = mode->VDisplay;
d197 10
a206 9
	pScreen->width = pScrni->virtualY;
	pScreen->height = pScrni->virtualX;
	pScreen->mmWidth = mmHeight;
	pScreen->mmHeight = mmWidth;
    } else {
	pScreen->width = pScrni->virtualX;
	pScreen->height = pScrni->virtualY;
	pScreen->mmWidth = mmWidth;
	pScreen->mmHeight = mmHeight;
d210 2
a211 2
	currentMode = pScrni->currentMode;
	pScrni->currentMode = NULL;
d215 6
a220 6
	ret = FALSE;
	pScrni->virtualX = pScreen->width = oldWidth;
	pScrni->virtualY = pScreen->height = oldHeight;
	pScreen->mmWidth = oldmmWidth;
	pScreen->mmHeight = oldmmHeight;
	pScrni->currentMode = currentMode;
d231 1
a231 1
	pScrni->pixmapPrivate = pspix->devPrivate;
d240 2
a241 1
	(*pScrni->EnableDisableFBAccess) (pScreen->myNum, TRUE);
d248 1
a248 1
    int rate, RRScreenSizePtr pSize)
d262 2
a263 2
	pRandr->virtualX = pScrni->virtualX;
	pRandr->virtualY = pScrni->virtualY;
d274 23
a296 23
	if (pRandr->maxX == 0 || pRandr->maxY == 0) {
	    if (maxX < mode->HDisplay)
		maxX = mode->HDisplay;
	    if (maxY < mode->VDisplay)
		maxY = mode->VDisplay;
	}
	if (mode->HDisplay == pSize->width &&
	    mode->VDisplay == pSize->height &&
	    (rate == 0 || GXRandRModeRefresh(mode) == rate))
	    break;
	if (mode->next == pScrni->modes) {
	    if (pSize->width == pRandr->virtualX &&
		pSize->height == pRandr->virtualY) {
		mode = pScrni->modes;
		useVirtual = TRUE;
		break;
	    }
	    if (pRandr->maxX == 0 || pRandr->maxY == 0) {
		pRandr->maxX = maxX;
		pRandr->maxY = maxY;
	    }
	    return FALSE;
	}
d300 2
a301 2
	pRandr->maxX = maxX;
	pRandr->maxY = maxY;
d305 3
a307 3
	    pSize->mmHeight)) {
	pRandr->rotation = oldRotation;
	return FALSE;
d317 2
a318 2
	px = (px >= pScreen->width ? (pScreen->width - 1) : px);
	py = (py >= pScreen->height ? (pScreen->height - 1) : py);
d320 1
a320 1
	xf86SetViewport(pScreen, px, py);
d323 1
a323 1
	(*pScreen->SetCursorPosition) (
d325 1
a325 1
                                        inputInfo.pointer,
d327 1
a327 3
                                        pScreen,
                                        px, py,
                                        FALSE);
d348 1
a348 1
	GXRandRGeneration = serverGeneration;
d355 1
a355 1
	return FALSE;
d360 1
a360 1
	return FALSE;
d363 2
a364 2
	free(pRandr);
	return FALSE;
@


1.6
log
@Update to xf86-video-geode 2.11.12. Tested on Alix 3C3.
@
text
@d356 1
a356 1
    pRandr = calloc(sizeof(XF86RandRInfoRec), 1);
@


1.5
log
@Update to xf86-video-geode 2.11.10. Tested on Alix 3C3.
@
text
@d29 4
d34 1
d179 1
d181 1
d220 1
a224 1
     
a225 1

d229 1
@


1.4
log
@Update to xf86-video-geode 2.11.9.
A bunch of bug fixes and performance improvements. Tested on Alix 3c3.
@
text
@d349 1
a349 1
    pRandr = xcalloc(sizeof(XF86RandRInfoRec), 1);
d354 1
a354 1
	xfree(pRandr);
@


1.3
log
@update to xf86-video-geode 2.11.6. Tested on a Alix 3C3.
@
text
@a30 1
#include "mibank.h"
d58 3
d62 1
d167 1
d169 3
d343 4
@


1.2
log
@MFC: enable build with recent input ABI.
@
text
@d39 1
d59 1
a59 3
#define AMD_OLDPRIV (GET_ABI_MAJOR(ABI_VIDEODRV_VERSION) < 4)

#if AMD_OLDPRIV
d61 1
a61 1
static int GXRandRIndex;
d63 3
a65 1
#define XF86RANDRINFO(p) ((XF86RandRInfoPtr) (p)->devPrivates[GXRandRIndex].ptr)
d67 3
a69 6

static DevPrivateKey GXRandRKey;

#define XF86RANDRINFO(p) ((XF86RandRInfoPtr) \
			  dixLookupPrivate(&(p)->devPrivates, GXRandRKey));

d210 1
a210 1

d334 1
a334 1
#if AMD_OLDPRIV
a335 2
#else
    GXRandRKey = &GXRandRKey;
d361 2
a362 5
#if AMD_OLDPRIV
    pScreen->devPrivates[GXRandRIndex].ptr = pRandr;
#else
    dixSetPrivate(&pScreen->devPrivates, GXRandRKey, pRandr);
#endif
@


1.1
log
@Initial revision
@
text
@d251 1
a251 1
#if GET_ABI_MAJOR(ABI_XINPUT_VERSION) == 3
d295 1
a295 1
#if GET_ABI_MAJOR(ABI_XINPUT_VERSION) == 3
d308 1
a308 1
#if GET_ABI_MAJOR(ABI_XINPUT_VERSION) == 3
@


1.1.1.1
log
@Import the xf86-video-geode driver for the AMD Geode LX graphics processor.

with and ok matthieu
@
text
@@
