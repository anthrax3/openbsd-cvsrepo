head	1.5;
access;
symbols
	OPENBSD_6_1:1.5.0.18
	OPENBSD_6_1_BASE:1.5
	OPENBSD_6_0:1.5.0.16
	OPENBSD_6_0_BASE:1.5
	OPENBSD_5_9:1.5.0.14
	OPENBSD_5_9_BASE:1.5
	OPENBSD_5_8:1.5.0.12
	OPENBSD_5_8_BASE:1.5
	OPENBSD_5_7:1.5.0.10
	OPENBSD_5_7_BASE:1.5
	OPENBSD_5_6:1.5.0.8
	OPENBSD_5_6_BASE:1.5
	OPENBSD_5_5:1.5.0.6
	OPENBSD_5_5_BASE:1.5
	OPENBSD_5_4:1.5.0.4
	OPENBSD_5_4_BASE:1.5
	OPENBSD_5_3:1.5.0.2
	OPENBSD_5_3_BASE:1.5
	OPENBSD_5_2:1.4.0.10
	OPENBSD_5_2_BASE:1.4
	OPENBSD_5_1_BASE:1.4
	OPENBSD_5_1:1.4.0.8
	OPENBSD_5_0:1.4.0.6
	OPENBSD_5_0_BASE:1.4
	OPENBSD_4_9:1.4.0.2
	OPENBSD_4_9_BASE:1.4
	OPENBSD_4_8:1.4.0.4
	OPENBSD_4_8_BASE:1.4
	OPENBSD_4_7:1.3.0.2
	OPENBSD_4_7_BASE:1.3
	OPENBSD_4_6:1.2.0.2
	OPENBSD_4_6_BASE:1.2
	OPENBSD_4_5:1.1.1.1.0.8
	OPENBSD_4_5_BASE:1.1.1.1
	OPENBSD_4_4:1.1.1.1.0.6
	OPENBSD_4_4_BASE:1.1.1.1
	OPENBSD_4_3_BASE:1.1.1.1
	OPENBSD_4_3:1.1.1.1.0.4
	OPENBSD_4_2:1.1.1.1.0.2
	OPENBSD_4_2_BASE:1.1.1.1
	v1_1_1:1.1.1.1
	xorg:1.1.1;
locks; strict;
comment	@ * @;


1.5
date	2012.08.11.09.49.51;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2010.07.24.20.23.17;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2009.11.22.18.29.22;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2009.03.07.10.43.22;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.26.20.21.43;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.11.26.20.21.43;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.5
log
@Update to xf86-video-voodoo 1.2.5
@
text
@/* 
 *  XFree86 driver for the Voodoo 2 using native X support and no
 * Glide2. This is done for two reasons, firstly Glide2 is not portable
 * to other than x86_32 which is becoming an issue, and secondly to get
 * accelerations that Glide does not expose.  The Voodoo 2 hardware has
 * bit blit (screen->screen, cpu->screen), some colour expansion and 
 * also alpha (so could do hw render even!). Also can in theory use
 * texture ram and engine to do arbitary Xv support as we have
 * colour match on the 2D blit (ie 3D blit to back, 2D blit to front)
 * along with alpha on the Xv 8) and with some care rotation of Xv.
 * 
 * Alan Cox <alan@@redhat.com>
 *
 * Permission to use, copy, modify, distribute, and sell this software and its
 * documentation for any purpose is hereby granted without fee, provided that
 * the above copyright notice appear in all copies and that both that
 * copyright notice and this permission notice appear in supporting
 * documentation, and that the names of Red Hat, Alan Cox and Henrik Harmsen
 * not be used in advertising or publicity pertaining to distribution of the
 * software without specific, written prior permission.  Th authors make no 
 * representations about the suitability of this software for any purpose.
 * It is provided "as is" without express or implied warranty.
 *
 * THE AUTHORS DISCLAIM ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
 * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO
 * EVENT SHALL RICHARD HECKER BE LIABLE FOR ANY SPECIAL, INDIRECT OR
 * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
 * DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
 * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
 * PERFORMANCE OF THIS SOFTWARE.
 * 
 * THIS SOFTWARE IS NOT DESIGNED FOR USE IN SAFETY CRITICAL SYSTEMS OF
 * ANY KIND OR FORM.
 */

#ifdef HAVE_CONFIG_H
#include "config.h"
#endif

#include "fb.h"
#include "micmap.h"
#include "xf86.h"
#include "xf86_OSproc.h"
#include "xf86PciInfo.h"
#include "xf86Pci.h"
#include "xf86cmap.h"
#include "shadowfb.h"
#include "vgaHW.h"
#include "compiler.h"
#include "dgaproc.h"
#ifdef HAVE_XAA_H
#include "xaa.h"
#endif
#include "voodoo.h"

#define _XF86DGA_SERVER_
#include <X11/extensions/xf86dgaproto.h>

#include "opaque.h"
#ifdef HAVE_XEXTPROTO_71
#include <X11/extensions/dpmsconst.h>
#else
#define DPMS_SERVER
#include <X11/extensions/dpms.h>
#endif



 /***********************************************************************
 * DGA stuff
 ***********************************************************************/
static Bool VoodooDGAOpenFramebuffer(ScrnInfoPtr pScrn, char **DeviceName,
				   unsigned char **ApertureBase,
				   int *ApertureSize, int *ApertureOffset,
				   int *flags);
static Bool VoodooDGASetMode(ScrnInfoPtr pScrn, DGAModePtr pDGAMode);

static Bool VoodooDGAOpenFramebuffer(ScrnInfoPtr pScrn, char **DeviceName,
		       unsigned char **ApertureBase, int *ApertureSize,
		       int *ApertureOffset, int *flags)
{
    *DeviceName = NULL;		/* No special device */
    *ApertureBase = (unsigned char *)(pScrn->memPhysBase);
    *ApertureSize = pScrn->videoRam;
    *ApertureOffset = pScrn->fbOffset;
    *flags = 0;

    return TRUE;
}

static Bool VoodooDGASetMode(ScrnInfoPtr pScrn, DGAModePtr pDGAMode)
{
    DisplayModePtr pMode;
    int scrnIdx = pScrn->pScreen->myNum;
    int frameX0, frameY0;

    if (pDGAMode) {
	pMode = pDGAMode->mode;
	frameX0 = frameY0 = 0;
    }
    else {
	if (!(pMode = pScrn->currentMode))
	    return TRUE;

	frameX0 = pScrn->frameX0;
	frameY0 = pScrn->frameY0;
    }

    if (!(*pScrn->SwitchMode)(SWITCH_MODE_ARGS(pScrn, pMode)))
	return FALSE;
    return TRUE;
}

static int VoodooDGAGetViewport(ScrnInfoPtr pScrn)
{
    return (0);
}

static DGAFunctionRec VoodooDGAFunctions =
{
    VoodooDGAOpenFramebuffer,
    NULL,       /* CloseFramebuffer */
    VoodooDGASetMode,
    NULL,
    VoodooDGAGetViewport,
    /* TODO - can do Sync/blit/fill on Voodoo2 */
    NULL,       /* Sync */
    NULL,       /* FillRect */
    NULL,       /* BlitRect */
    NULL,       /* BlitTransRect */
};

static void VoodooDGAAddModes(ScrnInfoPtr pScrn)
{
    VoodooPtr pVoo = VoodooPTR(pScrn);
    DisplayModePtr pMode = pScrn->modes;
    DGAModePtr pDGAMode;

    do {
	pDGAMode = realloc(pVoo->pDGAMode,
			    (pVoo->nDGAMode + 1) * sizeof(DGAModeRec));
	if (!pDGAMode)
	    break;

	pVoo->pDGAMode = pDGAMode;
	pDGAMode += pVoo->nDGAMode;
	(void)memset(pDGAMode, 0, sizeof(DGAModeRec));

	++pVoo->nDGAMode;
	pDGAMode->mode = pMode;
	pDGAMode->flags = DGA_CONCURRENT_ACCESS | DGA_PIXMAP_AVAILABLE;
	pDGAMode->byteOrder = pScrn->imageByteOrder;
	pDGAMode->depth = pScrn->depth;
	pDGAMode->bitsPerPixel = pScrn->bitsPerPixel;
	pDGAMode->red_mask = pScrn->mask.red;
	pDGAMode->green_mask = pScrn->mask.green;
	pDGAMode->blue_mask = pScrn->mask.blue;
	pDGAMode->visualClass = TrueColor;
	pDGAMode->xViewportStep = 1;
	pDGAMode->yViewportStep = 1;
	pDGAMode->viewportWidth = pMode->HDisplay;
	pDGAMode->viewportHeight = pMode->VDisplay;

	pDGAMode->bytesPerScanline = 2048;

	pDGAMode->imageWidth = pMode->HDisplay;
	pDGAMode->imageHeight =  pMode->VDisplay;
	pDGAMode->pixmapWidth = pDGAMode->imageWidth;
	pDGAMode->pixmapHeight = pDGAMode->imageHeight;
	pDGAMode->maxViewportX = pScrn->virtualX -
				    pDGAMode->viewportWidth;
	pDGAMode->maxViewportY = pScrn->virtualY -
				    pDGAMode->viewportHeight;

	pDGAMode->address = pVoo->FBBase;

	pMode = pMode->next;
    } while (pMode != pScrn->modes);
}

Bool VoodooDGAInit(ScrnInfoPtr pScrn, ScreenPtr pScreen)
{
    VoodooPtr pVoo = VoodooPTR(pScrn);
    if (!pVoo->nDGAMode)
	VoodooDGAAddModes(pScrn);
    return (DGAInit(pScreen, &VoodooDGAFunctions,
	    pVoo->pDGAMode, pVoo->nDGAMode));
}
@


1.4
log
@Update to xf86-video-voodoo 1.2.4
@
text
@d50 2
d53 1
a53 2
#include "dgaproc.h"

d57 1
a57 1
#include <X11/extensions/xf86dgastr.h>
d109 1
a109 1
    if (!(*pScrn->SwitchMode)(scrnIdx, pMode, 0))
d140 1
a140 1
	pDGAMode = xrealloc(pVoo->pDGAMode,
@


1.3
log
@Update to xf86-video-voodoo 1.2.3
@
text
@a40 1
#include "mibank.h"
@


1.2
log
@update to xf86-video-voodoo 1.2.1
@
text
@a49 2
#include "xf86RAC.h"
#include "xf86Resources.h"
d60 3
d65 2
@


1.1
log
@Initial revision
@
text
@a44 1
#include "xf86Version.h"
a49 1
#include "xf86DDC.h"
@


1.1.1.1
log
@Importing xf86-video-voodoo 1.1.1
@
text
@@
