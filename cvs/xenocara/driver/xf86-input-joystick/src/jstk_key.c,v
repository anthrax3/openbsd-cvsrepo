head	1.8;
access;
symbols
	OPENBSD_6_2:1.8.0.4
	OPENBSD_6_2_BASE:1.8
	OPENBSD_6_1:1.8.0.2
	OPENBSD_6_1_BASE:1.8
	OPENBSD_6_0:1.7.0.18
	OPENBSD_6_0_BASE:1.7
	OPENBSD_5_9:1.7.0.16
	OPENBSD_5_9_BASE:1.7
	OPENBSD_5_8:1.7.0.14
	OPENBSD_5_8_BASE:1.7
	OPENBSD_5_7:1.7.0.12
	OPENBSD_5_7_BASE:1.7
	OPENBSD_5_6:1.7.0.10
	OPENBSD_5_6_BASE:1.7
	OPENBSD_5_5:1.7.0.8
	OPENBSD_5_5_BASE:1.7
	OPENBSD_5_4:1.7.0.6
	OPENBSD_5_4_BASE:1.7
	OPENBSD_5_3:1.7.0.4
	OPENBSD_5_3_BASE:1.7
	OPENBSD_5_2:1.7.0.2
	OPENBSD_5_2_BASE:1.7
	OPENBSD_5_1_BASE:1.6
	OPENBSD_5_1:1.6.0.2
	OPENBSD_5_0:1.5.0.2
	OPENBSD_5_0_BASE:1.5
	OPENBSD_4_9:1.3.0.4
	OPENBSD_4_9_BASE:1.3
	OPENBSD_4_8:1.3.0.6
	OPENBSD_4_8_BASE:1.3
	OPENBSD_4_7:1.3.0.2
	OPENBSD_4_7_BASE:1.3
	OPENBSD_4_6:1.2.0.2
	OPENBSD_4_6_BASE:1.2
	OPENBSD_4_5:1.1.0.2
	OPENBSD_4_5_BASE:1.1;
locks; strict;
comment	@ * @;


1.8
date	2017.01.22.09.44.15;	author matthieu;	state Exp;
branches;
next	1.7;
commitid	eqnV0ShUiED6Tid5;

1.7
date	2012.04.08.17.03.03;	author matthieu;	state Exp;
branches;
next	1.6;

1.6
date	2011.11.05.14.01.51;	author matthieu;	state Exp;
branches;
next	1.5;

1.5
date	2011.07.02.21.59.45;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2011.07.02.21.03.43;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2009.11.22.14.38.31;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2009.05.03.13.54.12;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2008.08.23.14.16.59;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.8
log
@Update to xf86-input-joystick 1.6.3
@
text
@/*
 * Copyright 2007-2008 by Sascha Hlusiak. <saschahlusiak@@freedesktop.org>     
 * Copyright 1995-1999 by Frederic Lepied, France. <Lepied@@XFree86.org>       
 *                                                                            
 * Permission to use, copy, modify, distribute, and sell this software and its
 * documentation for any purpose is  hereby granted without fee, provided that
 * the  above copyright   notice appear  in   all  copies and  that both  that
 * copyright  notice   and   this  permission   notice  appear  in  supporting
 * documentation, and that  the  names  of copyright holders not  be  used  in
 * advertising or publicity pertaining to distribution of the software without
 * specific,  written      prior  permission.  The copyright holders  make  no
 * representations about the suitability of this software for any purpose.  It
 * is provided "as is" without express or implied warranty.                   
 *                                                                            
 * THE COPYRIGHT HOLDERS DISCLAIM ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
 * INCLUDING ALL IMPLIED   WARRANTIES OF MERCHANTABILITY  AND   FITNESS, IN NO
 * EVENT  SHALL THE COPYRIGHT HOLDERS BE LIABLE FOR ANY SPECIAL, INDIRECT   OR
 * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
 * DATA  OR PROFITS, WHETHER  IN  AN ACTION OF  CONTRACT,  NEGLIGENCE OR OTHER
 * TORTIOUS  ACTION, ARISING    OUT OF OR   IN  CONNECTION  WITH THE USE    OR
 * PERFORMANCE OF THIS SOFTWARE.
 */



#ifdef HAVE_CONFIG_H
#include "config.h"
#endif


#include <xorg-server.h>
#include <xf86.h>
#include <xf86Xinput.h>
#include <X11/extensions/XKBsrv.h>
#include <X11/keysym.h>
#include <X11/XF86keysym.h>
#include <xf86Optrec.h>

#include "jstk.h"
#include "jstk_key.h"

#include <xkbsrv.h>

#define MIN_KEYCODE 8
#define GLYPHS_PER_KEY 2

#define AltMask		Mod1Mask
#define NumLockMask	Mod2Mask
#define AltLangMask	Mod3Mask
#define KanaMask	Mod4Mask
#define ScrollLockMask	Mod5Mask

static void
jstkKbdCtrl(DeviceIntPtr device, KeybdCtrl *ctrl)
{
}


/*
 ***************************************************************************
 *
 * jstkInitKeys --
 *
 * Sets up the keymap, modmap and the keyboard device structs
 *
 ***************************************************************************
 */
static int
jstkInitKeys(DeviceIntPtr pJstk, JoystickDevPtr priv)
{
    XkbSrvInfoPtr xkbi;
    XkbControlsPtr ctrls;

    if (!InitKeyboardDeviceStruct(pJstk, &priv->rmlvo, NULL, jstkKbdCtrl))
    {
        ErrorF("unable to init keyboard device\n");
        return !Success;
    }

    /* Set Autorepeat and Delay */
    if ((priv->repeat_delay || priv->repeat_interval) && 
        pJstk->key && 
        pJstk->key->xkbInfo)
    {
        xkbi = pJstk->key->xkbInfo;
        if (xkbi && xkbi->desc)
        {
            ctrls = xkbi->desc->ctrls;
            ctrls->repeat_delay = priv->repeat_delay;
            ctrls->repeat_interval = priv->repeat_interval;
        }
    }

    return Success;
}



/*
 ***************************************************************************
 *
 * jstkGenerateKeys
 *
 * Generates a series of keydown or keyup events of the specified 
 * KEYSCANCODES
 *
 ***************************************************************************
 */
void
jstkGenerateKeys(InputInfoPtr device, KEYSCANCODES keys, char pressed)
{
    int i;
    unsigned int k;

    if (device == NULL)
        return;
    for (i=0;i<MAXKEYSPERBUTTON;i++) {
        if (pressed != 0) 
            k = keys[i];
        else k = keys[MAXKEYSPERBUTTON - i - 1];

        if (k != 0) {
            DBG(2, ErrorF("Generating key %s event with keycode %d\n", 
                (pressed)?"press":"release", k));
            xf86PostKeyboardEvent(device->dev, k, pressed);
        }
    }
}


/*
 ***************************************************************************
 *
 * jstkKeyboardDeviceControlProc --
 *
 * Handles the initialization, etc. of the keyboard device
 *
 ***************************************************************************
 */
Bool
jstkKeyboardDeviceControlProc(DeviceIntPtr       dev,
                              int                what)
{
    InputInfoPtr pInfo = dev->public.devicePrivate;
    JoystickDevPtr priv  = pInfo->private;
    if (!priv) {
        DBG(2, ErrorF("jstkKeyboardDeviceControlProc: priv == NULL\n"));
        return !Success;
    }
    switch (what) {
    case DEVICE_INIT:
        DBG(2, ErrorF("jstkKeyboardDeviceControlProc what=DEVICE_INIT\n"));
        if (InitFocusClassDeviceStruct(dev) == FALSE) {
            ErrorF("unable to init Focus class device\n");
            return !Success;
        }
        if (jstkInitKeys(dev, priv) != Success)
            return !Success;
        break;
    case DEVICE_ON:
        DBG(2, ErrorF("jstkKeyboardDeviceControlProc what=DEVICE_ON\n"));
        dev->public.on = TRUE;
        break;
    case DEVICE_OFF:
        DBG(2, ErrorF("jstkKeyboardDeviceControlProc what=DEVICE_OFF\n"));
        dev->public.on = FALSE;
        break;
    case DEVICE_CLOSE:
        DBG(2, ErrorF("jstkKeyboardDeviceControlProc what=DEVICE_CLOSE\n"));
        dev->public.on = FALSE;
        break;
    default:
        return BadValue;
    }

    return Success;
}


/*
 ***************************************************************************
 *
 * jstkKeyboardPreInit --
 *
 * See comment in jstkCorePreInit() for details.
 *
 ***************************************************************************
 */

int jstkKeyboardPreInit(InputDriverPtr drv, InputInfoPtr pInfo, int flags)
{
    JoystickDevPtr priv = NULL;
    char *s;

    pInfo->private = priv = calloc(1, sizeof(JoystickDevRec));
    if (!priv)
        return BadAlloc;

    pInfo->device_control = jstkKeyboardDeviceControlProc;
    pInfo->read_input = NULL;
    pInfo->control_proc = NULL;
    pInfo->switch_mode = NULL;
    if (!(pInfo->flags & XI86_SERVER_FD))
        pInfo->fd = -1;
    pInfo->type_name = XI_JOYSTICK;

    /* parse keyboard-related options */
    priv->repeat_delay = 0;
    priv->repeat_interval = 0;

    /* Parse option for autorepeat */
    if ((s = xf86SetStrOption(pInfo->options, "AutoRepeat", NULL))) {
        int delay, rate;
        if (sscanf(s, "%d %d", &delay, &rate) != 2) {
            xf86Msg(X_ERROR, "%s: \"%s\" is not a valid AutoRepeat value",
                    pInfo->name, s);
        } else {
            priv->repeat_delay = delay;
            if (rate != 0)
                priv->repeat_interval = 1000/rate;
            else priv->repeat_interval = 0;
            DBG(1, xf86Msg(X_CONFIG, "Autorepeat set to delay=%d, interval=%d\n",
                           priv->repeat_delay,priv->repeat_interval));
        }
        free(s);
    }

    priv->rmlvo.rules = xf86SetStrOption(pInfo->options, "xkb_rules", NULL);
    if (!priv->rmlvo.rules)
	priv->rmlvo.rules = xf86SetStrOption(pInfo->options, "XkbRules", "evdev");

    priv->rmlvo.model = xf86SetStrOption(pInfo->options, "xkb_model", NULL);
    if (!priv->rmlvo.model)
	priv->rmlvo.model = xf86SetStrOption(pInfo->options, "XkbModel", "evdev");

    priv->rmlvo.layout = xf86SetStrOption(pInfo->options, "xkb_layout", NULL);
    if (!priv->rmlvo.layout)
	priv->rmlvo.layout = xf86SetStrOption(pInfo->options, "XkbLayout", "us");

    priv->rmlvo.variant = xf86SetStrOption(pInfo->options, "xkb_variant", NULL);
    if (!priv->rmlvo.variant)
	priv->rmlvo.variant = xf86SetStrOption(pInfo->options, "XkbVariant", "");

    priv->rmlvo.options = xf86SetStrOption(pInfo->options, "xkb_options", NULL);
    if (!priv->rmlvo.options)
	priv->rmlvo.options = xf86SetStrOption(pInfo->options, "XkbOptions", "");

    return Success;
}

#if GET_ABI_MAJOR(ABI_XINPUT_VERSION) < 14
static InputOption*
input_option_new(InputOption* list, char *key, char *value)
{
    InputOption *tmp;

    tmp = calloc(1, sizeof(*tmp));
    tmp->key = key;
    tmp->value = value;
    tmp->next = list;

    return tmp;
}

static void
input_option_free_list(InputOption **list)
{
    InputOption *iopts = *list;

    while(iopts)
    {
        InputOption *tmp = iopts->next;
        free(iopts->key);
        free(iopts->value);
        free(iopts);
        iopts = tmp;
    }

    *list = NULL;
}

#endif

InputInfoPtr
jstkKeyboardHotplug(InputInfoPtr pInfo, int flags)
{
    int rc;
    char name[512] = {0};
    InputAttributes *attrs = NULL;
    InputOption *iopts = NULL;
    DeviceIntPtr dev;
    XF86OptionPtr opts;

    /* duplicate option list, append to name */
    opts = xf86OptionListDuplicate(pInfo->options);
    strcpy(name, pInfo->name);
    strcat(name, " (keys)");
    opts = xf86ReplaceStrOption(opts, "Name", name);
    opts = xf86ReplaceStrOption(opts, "_source", "_driver/joystick");
    opts = xf86AddNewOption(opts, "Driver", pInfo->driver);

    while(opts)
    {
        iopts = input_option_new(iopts,
                                 xf86OptionName(opts),
                                 xf86OptionValue(opts));
        opts = xf86NextOption(opts);
    }

    /* duplicate attribute list */
    attrs = DuplicateInputAttributes(pInfo->attrs);

    rc = NewInputDeviceRequest(iopts, attrs, &dev);

    input_option_free_list(&iopts);

    FreeInputAttributes(attrs);

    return (rc == Success) ? dev->public.devicePrivate : NULL;
}


/*
 ***************************************************************************
 *
 * jstkKeyboardUnInit --
 *
 * Called when the keyboard slave device gets removed
 *
 ***************************************************************************
 */
void
jstkKeyboardUnInit(InputDriverPtr    drv,
                   InputInfoPtr      pInfo,
                   int               flags)
{
    JoystickDevPtr device = (JoystickDevPtr) pInfo->private;
    DBG(2, ErrorF("jstkKeyboardUnInit.\n"));

    device->keyboard_device = NULL;
    pInfo->private = NULL;

    xf86DeleteInput(pInfo, 0);
}

@


1.7
log
@Update to xf86-input-joystick 1.6.1
@
text
@d203 2
a204 1
    pInfo->fd = -1;
@


1.6
log
@Update to xf86-input-joystick 1.6.0 for good now.
@
text
@d172 2
d250 33
d289 1
a289 2
    InputOption *options;
    InputOption *iopts = NULL, *tmp;
d291 1
d294 1
a294 1
    options = xf86OptionListDuplicate(pInfo->options);
d297 3
a299 2
    options = xf86ReplaceStrOption(options, "Name", name);
    options = xf86ReplaceStrOption(options, "_source", "_driver/joystick");
d301 1
a301 1
    while(options)
d303 4
a306 7
        tmp = calloc(1, sizeof(InputOption));

        tmp->key = xf86OptionName(options);
        tmp->value = xf86OptionValue(options);
        tmp->next = iopts;
        iopts = tmp;
        options = xf86NextOption(options);
d314 1
a314 8
    while(iopts)
    {
        tmp = iopts->next;
        free(iopts->key);
        free(iopts->value);
        free(iopts);
        iopts = tmp;
    }
@


1.5
log
@Revert update to xf86-input-joystick 1.6.0.
This driver depends on xserver 1.10.
@
text
@d31 1
a41 1
#if GET_ABI_MAJOR(ABI_XINPUT_VERSION) >= 5
a42 1
#endif
a52 274


#if GET_ABI_MAJOR(ABI_XINPUT_VERSION) < 5
static KeySym map[] = {
    /* 0x00 */  NoSymbol,       NoSymbol,
    /* 0x01 */  XK_Escape,      NoSymbol,
    /* 0x02 */  XK_1,           XK_exclam,
    /* 0x03 */  XK_2,           XK_at,
    /* 0x04 */  XK_3,           XK_numbersign,
    /* 0x05 */  XK_4,           XK_dollar,
    /* 0x06 */  XK_5,           XK_percent,
    /* 0x07 */  XK_6,           XK_asciicircum,
    /* 0x08 */  XK_7,           XK_ampersand,
    /* 0x09 */  XK_8,           XK_asterisk,
    /* 0x0a */  XK_9,           XK_parenleft,
    /* 0x0b */  XK_0,           XK_parenright,
    /* 0x0c */  XK_minus,       XK_underscore,
    /* 0x0d */  XK_equal,       XK_plus,
    /* 0x0e */  XK_BackSpace,   NoSymbol,
    /* 0x0f */  XK_Tab,         XK_ISO_Left_Tab,
    /* 0x10 */  XK_Q,           NoSymbol,
    /* 0x11 */  XK_W,           NoSymbol,
    /* 0x12 */  XK_E,           NoSymbol,
    /* 0x13 */  XK_R,           NoSymbol,
    /* 0x14 */  XK_T,           NoSymbol,
    /* 0x15 */  XK_Y,           NoSymbol,
    /* 0x16 */  XK_U,           NoSymbol,
    /* 0x17 */  XK_I,           NoSymbol,
    /* 0x18 */  XK_O,           NoSymbol,
    /* 0x19 */  XK_P,           NoSymbol,
    /* 0x1a */  XK_bracketleft, XK_braceleft,
    /* 0x1b */  XK_bracketright,XK_braceright,
    /* 0x1c */  XK_Return,      NoSymbol,
    /* 0x1d */  XK_Control_L,   NoSymbol,
    /* 0x1e */  XK_A,           NoSymbol,
    /* 0x1f */  XK_S,           NoSymbol,
    /* 0x20 */  XK_D,           NoSymbol,
    /* 0x21 */  XK_F,           NoSymbol,
    /* 0x22 */  XK_G,           NoSymbol,
    /* 0x23 */  XK_H,           NoSymbol,
    /* 0x24 */  XK_J,           NoSymbol,
    /* 0x25 */  XK_K,           NoSymbol,
    /* 0x26 */  XK_L,           NoSymbol,
    /* 0x27 */  XK_semicolon,   XK_colon,
    /* 0x28 */  XK_quoteright,  XK_quotedbl,
    /* 0x29 */  XK_quoteleft,	XK_asciitilde,
    /* 0x2a */  XK_Shift_L,     NoSymbol,
    /* 0x2b */  XK_backslash,   XK_bar,
    /* 0x2c */  XK_Z,           NoSymbol,
    /* 0x2d */  XK_X,           NoSymbol,
    /* 0x2e */  XK_C,           NoSymbol,
    /* 0x2f */  XK_V,           NoSymbol,
    /* 0x30 */  XK_B,           NoSymbol,
    /* 0x31 */  XK_N,           NoSymbol,
    /* 0x32 */  XK_M,           NoSymbol,
    /* 0x33 */  XK_comma,       XK_less,
    /* 0x34 */  XK_period,      XK_greater,
    /* 0x35 */  XK_slash,       XK_question,
    /* 0x36 */  XK_Shift_R,     NoSymbol,
    /* 0x37 */  XK_KP_Multiply, NoSymbol,
    /* 0x38 */  XK_Alt_L,	XK_Meta_L,
    /* 0x39 */  XK_space,       NoSymbol,
    /* 0x3a */  XK_Caps_Lock,   NoSymbol,
    /* 0x3b */  XK_F1,          NoSymbol,
    /* 0x3c */  XK_F2,          NoSymbol,
    /* 0x3d */  XK_F3,          NoSymbol,
    /* 0x3e */  XK_F4,          NoSymbol,
    /* 0x3f */  XK_F5,          NoSymbol,
    /* 0x40 */  XK_F6,          NoSymbol,
    /* 0x41 */  XK_F7,          NoSymbol,
    /* 0x42 */  XK_F8,          NoSymbol,
    /* 0x43 */  XK_F9,          NoSymbol,
    /* 0x44 */  XK_F10,         NoSymbol,
    /* 0x45 */  XK_Num_Lock,    NoSymbol,
    /* 0x46 */  XK_Scroll_Lock,	NoSymbol,
    /* These KP keys should have the KP_7 keysyms in the numlock
     * modifer... ? */
    /* 0x47 */  XK_KP_Home,	XK_KP_7,
    /* 0x48 */  XK_KP_Up,	XK_KP_8,
    /* 0x49 */  XK_KP_Prior,	XK_KP_9,
    /* 0x4a */  XK_KP_Subtract, NoSymbol,
    /* 0x4b */  XK_KP_Left,	XK_KP_4,
    /* 0x4c */  XK_KP_Begin,	XK_KP_5,
    /* 0x4d */  XK_KP_Right,	XK_KP_6,
    /* 0x4e */  XK_KP_Add,      NoSymbol,
    /* 0x4f */  XK_KP_End,	XK_KP_1,
    /* 0x50 */  XK_KP_Down,	XK_KP_2,
    /* 0x51 */  XK_KP_Next,	XK_KP_3,
    /* 0x52 */  XK_KP_Insert,	XK_KP_0,
    /* 0x53 */  XK_KP_Delete,	XK_KP_Decimal,
    /* 0x54 */  NoSymbol,	NoSymbol,
    /* 0x55 */  XK_F13,		NoSymbol,
    /* 0x56 */  XK_less,	XK_greater,
    /* 0x57 */  XK_F11,		NoSymbol,
    /* 0x58 */  XK_F12,		NoSymbol,
    /* 0x59 */  XK_F14,		NoSymbol,
    /* 0x5a */  XK_F15,		NoSymbol,
    /* 0x5b */  XK_F16,		NoSymbol,
    /* 0x5c */  XK_F17,		NoSymbol,
    /* 0x5d */  XK_F18,		NoSymbol,
    /* 0x5e */  XK_F19,		NoSymbol,
    /* 0x5f */  XK_F20,		NoSymbol,
    /* 0x60 */  XK_KP_Enter,	NoSymbol,
    /* 0x61 */  XK_Control_R,	NoSymbol,
    /* 0x62 */  XK_KP_Divide,	NoSymbol,
    /* 0x63 */  XK_Print,	XK_Sys_Req,
    /* 0x64 */  XK_Alt_R,	XK_Meta_R,
    /* 0x65 */  NoSymbol,	NoSymbol, /* KEY_LINEFEED */
    /* 0x66 */  XK_Home,	NoSymbol,
    /* 0x67 */  XK_Up,		NoSymbol,
    /* 0x68 */  XK_Prior,	NoSymbol,
    /* 0x69 */  XK_Left,	NoSymbol,
    /* 0x6a */  XK_Right,	NoSymbol,
    /* 0x6b */  XK_End,		NoSymbol,
    /* 0x6c */  XK_Down,	NoSymbol,
    /* 0x6d */  XK_Next,	NoSymbol,
    /* 0x6e */  XK_Insert,	NoSymbol,
    /* 0x6f */  XK_Delete,	NoSymbol,
    /* 0x70 */  NoSymbol,	NoSymbol, /* KEY_MACRO */
    /* 0x71 */  NoSymbol,	NoSymbol,
    /* 0x72 */  NoSymbol,	NoSymbol,
    /* 0x73 */  NoSymbol,	NoSymbol,
    /* 0x74 */  NoSymbol,	NoSymbol,
    /* 0x75 */  XK_KP_Equal,	NoSymbol,
    /* 0x76 */  NoSymbol,	NoSymbol,
    /* 0x77 */  NoSymbol,	NoSymbol,
    /* 0x78 */  XK_F21,		NoSymbol,
    /* 0x79 */  XK_F22,		NoSymbol,
    /* 0x7a */  XK_F23,		NoSymbol,
    /* 0x7b */  XK_F24,		NoSymbol,
    /* 0x7c */  XK_KP_Separator, NoSymbol,
    /* 0x7d */  XK_Meta_L,	NoSymbol,
    /* 0x7e */  XK_Meta_R,	NoSymbol,
    /* 0x7f */  XK_Multi_key,	NoSymbol,
    /* 0x80 */  NoSymbol,	NoSymbol,
    /* 0x81 */  NoSymbol,	NoSymbol,
    /* 0x82 */  NoSymbol,	NoSymbol,
    /* 0x83 */  NoSymbol,	NoSymbol,
    /* 0x84 */  NoSymbol,	NoSymbol,
    /* 0x85 */  NoSymbol,	NoSymbol,
    /* 0x86 */  NoSymbol,	NoSymbol,
    /* 0x87 */  NoSymbol,	NoSymbol,
    /* 0x88 */  NoSymbol,	NoSymbol,
    /* 0x89 */  NoSymbol,	NoSymbol,
    /* 0x8a */  NoSymbol,	NoSymbol,
    /* 0x8b */  NoSymbol,	NoSymbol,
    /* 0x8c */  NoSymbol,	NoSymbol,
    /* 0x8d */  NoSymbol,	NoSymbol,
    /* 0x8e */  NoSymbol,	NoSymbol,
    /* 0x8f */  NoSymbol,	NoSymbol,
    /* 0x90 */  NoSymbol,	NoSymbol,
    /* 0x91 */  NoSymbol,	NoSymbol,
    /* 0x92 */  NoSymbol,	NoSymbol,
    /* 0x93 */  NoSymbol,	NoSymbol,
    /* 0x94 */  NoSymbol,	NoSymbol,
    /* 0x95 */  NoSymbol,	NoSymbol,
    /* 0x96 */  NoSymbol,	NoSymbol,
    /* 0x97 */  NoSymbol,	NoSymbol,
    /* 0x98 */  NoSymbol,	NoSymbol,
    /* 0x99 */  NoSymbol,	NoSymbol,
    /* 0x9a */  NoSymbol,	NoSymbol,
    /* 0x9b */  NoSymbol,	NoSymbol,
    /* 0x9c */  NoSymbol,	NoSymbol,
    /* 0x9d */  NoSymbol,	NoSymbol,
    /* 0x9e */  NoSymbol,	NoSymbol,
    /* 0x9f */  NoSymbol,	NoSymbol,
    /* 0xa0 */  NoSymbol,	NoSymbol,
    /* 0xa1 */  NoSymbol,	NoSymbol,
    /* 0xa2 */  NoSymbol,	NoSymbol,
    /* 0xa3 */  NoSymbol,	NoSymbol,
    /* 0xa4 */  NoSymbol,	NoSymbol,
    /* 0xa5 */  NoSymbol,	NoSymbol,
    /* 0xa6 */  NoSymbol,	NoSymbol,
    /* 0xa7 */  NoSymbol,	NoSymbol,
    /* 0xa8 */  NoSymbol,	NoSymbol,
    /* 0xa9 */  NoSymbol,	NoSymbol,
    /* 0xaa */  NoSymbol,	NoSymbol,
    /* 0xab */  NoSymbol,	NoSymbol,
    /* 0xac */  NoSymbol,	NoSymbol,
    /* 0xad */  NoSymbol,	NoSymbol,
    /* 0xae */  NoSymbol,	NoSymbol,
    /* 0xaf */  NoSymbol,	NoSymbol,
    /* 0xb0 */  NoSymbol,	NoSymbol,
    /* 0xb1 */  NoSymbol,	NoSymbol,
    /* 0xb2 */  NoSymbol,	NoSymbol,
    /* 0xb3 */  NoSymbol,	NoSymbol,
    /* 0xb4 */  NoSymbol,	NoSymbol,
    /* 0xb5 */  NoSymbol,	NoSymbol,
    /* 0xb6 */  NoSymbol,	NoSymbol,
    /* 0xb7 */  NoSymbol,	NoSymbol,
    /* 0xb8 */  NoSymbol,	NoSymbol,
    /* 0xb9 */  NoSymbol,	NoSymbol,
    /* 0xba */  NoSymbol,	NoSymbol,
    /* 0xbb */  NoSymbol,	NoSymbol,
    /* 0xbc */  NoSymbol,	NoSymbol,
    /* 0xbd */  NoSymbol,	NoSymbol,
    /* 0xbe */  NoSymbol,	NoSymbol,
    /* 0xbf */  NoSymbol,	NoSymbol,
    /* 0xc0 */  NoSymbol,	NoSymbol,
    /* 0xc1 */  NoSymbol,	NoSymbol,
    /* 0xc2 */  NoSymbol,	NoSymbol,
    /* 0xc3 */  NoSymbol,	NoSymbol,
    /* 0xc4 */  NoSymbol,	NoSymbol,
    /* 0xc5 */  NoSymbol,	NoSymbol,
    /* 0xc6 */  NoSymbol,	NoSymbol,
    /* 0xc7 */  NoSymbol,	NoSymbol,
    /* 0xc8 */  NoSymbol,	NoSymbol,
    /* 0xc9 */  NoSymbol,	NoSymbol,
    /* 0xca */  NoSymbol,	NoSymbol,
    /* 0xcb */  NoSymbol,	NoSymbol,
    /* 0xcc */  NoSymbol,	NoSymbol,
    /* 0xcd */  NoSymbol,	NoSymbol,
    /* 0xce */  NoSymbol,	NoSymbol,
    /* 0xcf */  NoSymbol,	NoSymbol,
    /* 0xd0 */  NoSymbol,	NoSymbol,
    /* 0xd1 */  NoSymbol,	NoSymbol,
    /* 0xd2 */  NoSymbol,	NoSymbol,
    /* 0xd3 */  NoSymbol,	NoSymbol,
    /* 0xd4 */  NoSymbol,	NoSymbol,
    /* 0xd5 */  NoSymbol,	NoSymbol,
    /* 0xd6 */  NoSymbol,	NoSymbol,
    /* 0xd7 */  NoSymbol,	NoSymbol,
    /* 0xd8 */  NoSymbol,	NoSymbol,
    /* 0xd9 */  NoSymbol,	NoSymbol,
    /* 0xda */  NoSymbol,	NoSymbol,
    /* 0xdb */  NoSymbol,	NoSymbol,
    /* 0xdc */  NoSymbol,	NoSymbol,
    /* 0xdd */  NoSymbol,	NoSymbol,
    /* 0xde */  NoSymbol,	NoSymbol,
    /* 0xdf */  NoSymbol,	NoSymbol,
    /* 0xe0 */  NoSymbol,	NoSymbol,
    /* 0xe1 */  NoSymbol,	NoSymbol,
    /* 0xe2 */  NoSymbol,	NoSymbol,
    /* 0xe3 */  NoSymbol,	NoSymbol,
    /* 0xe4 */  NoSymbol,	NoSymbol,
    /* 0xe5 */  NoSymbol,	NoSymbol,
    /* 0xe6 */  NoSymbol,	NoSymbol,
    /* 0xe7 */  NoSymbol,	NoSymbol,
    /* 0xe8 */  NoSymbol,	NoSymbol,
    /* 0xe9 */  NoSymbol,	NoSymbol,
    /* 0xea */  NoSymbol,	NoSymbol,
    /* 0xeb */  NoSymbol,	NoSymbol,
    /* 0xec */  NoSymbol,	NoSymbol,
    /* 0xed */  NoSymbol,	NoSymbol,
    /* 0xee */  NoSymbol,	NoSymbol,
    /* 0xef */  NoSymbol,	NoSymbol,
    /* 0xf0 */  NoSymbol,	NoSymbol,
    /* 0xf1 */  NoSymbol,	NoSymbol,
    /* 0xf2 */  NoSymbol,	NoSymbol,
    /* 0xf3 */  NoSymbol,	NoSymbol,
    /* 0xf4 */  NoSymbol,	NoSymbol,
    /* 0xf5 */  NoSymbol,	NoSymbol,
    /* 0xf6 */  NoSymbol,	NoSymbol,
    /* 0xf7 */  NoSymbol,	NoSymbol,
};

static struct { KeySym keysym; CARD8 mask; } modifiers[] = {
    { XK_Shift_L,		ShiftMask },
    { XK_Shift_R,		ShiftMask },
    { XK_Control_L,		ControlMask },
    { XK_Control_R,		ControlMask },
    { XK_Caps_Lock,		LockMask },
    { XK_Alt_L,		AltMask },
    { XK_Alt_R,		AltMask },
    { XK_Meta_L,		Mod4Mask },
    { XK_Meta_R,		Mod4Mask },
    { XK_Num_Lock,		NumLockMask },
    { XK_Scroll_Lock,	ScrollLockMask },
    { XK_Mode_switch,	AltLangMask }
};
#endif



d74 1
a74 1
#if GET_ABI_MAJOR(ABI_XINPUT_VERSION) >= 5
d76 2
a77 27
        if (!InitKeyboardDeviceStruct(pJstk, &priv->rmlvo, NULL, jstkKbdCtrl))
        {
            ErrorF("unable to init keyboard device\n");
            return !Success;
        }
    }
#else
    KeySymsRec keySyms;
    CARD8 modMap[MAP_LENGTH];
    KeySym sym;
    int i, j;
    XkbComponentNamesRec xkbnames;

    memset(modMap, 0, sizeof(modMap));
    memset(&xkbnames, 0, sizeof(xkbnames));

    keySyms.map        = map;
    keySyms.mapWidth   = GLYPHS_PER_KEY;
    keySyms.minKeyCode = MIN_KEYCODE;
    keySyms.maxKeyCode = MIN_KEYCODE + (sizeof(map) / sizeof(map[0])) / GLYPHS_PER_KEY - 1;

    for (i = 0; i < (sizeof(map) / sizeof(map[0])) / GLYPHS_PER_KEY; i++) {
        sym = map[i * GLYPHS_PER_KEY];
        for (j = 0; j < sizeof(modifiers)/sizeof(modifiers[0]); j++) {
            if (modifiers[j].keysym == sym)
                modMap[i + MIN_KEYCODE] = modifiers[j].mask;
        }
a79 10
    ErrorF("%s, %s, %s, %s, %s\n", priv->rmlvo.rules, priv->rmlvo.model, priv->rmlvo.layout, priv->rmlvo.variant, priv->rmlvo.options);
    XkbSetRulesDflts(priv->rmlvo.rules, priv->rmlvo.model,
            priv->rmlvo.layout, priv->rmlvo.variant,
            priv->rmlvo.options);
    if (!XkbInitKeyboardDeviceStruct(pJstk, &xkbnames,
                &keySyms, modMap, NULL,
                jstkKbdCtrl))
        return !Success;
#endif

d110 1
a110 1
jstkGenerateKeys(LocalDevicePtr device, KEYSCANCODES keys, char pressed)
d140 1
a140 1
static Bool
d144 2
a145 1
    JoystickDevPtr priv  = (JoystickDevPtr)XI_PRIVATE(dev);
d183 1
a183 1
 * Called manually to create a keyboard device for the joystick
d187 61
d249 1
a249 1
jstkKeyboardPreInit(InputDriverPtr drv, IDevPtr _dev, int flags)
d251 1
a251 2
    LocalDevicePtr local = NULL;
    IDevPtr dev = NULL;
d253 11
d265 9
a273 3
    local = xf86AllocateInput(drv, 0);
    if (!local) {
        goto SetupProc_fail;
d276 12
a287 41
    dev = xcalloc(sizeof(IDevRec), 1);
    strcpy(name, _dev->identifier);
    strcat(name, " (keys)");
    dev->identifier = xstrdup(name);
    dev->driver = xstrdup(_dev->driver);
    dev->commonOptions = (pointer)xf86optionListDup(_dev->commonOptions);
    dev->extraOptions = (pointer)xf86optionListDup(_dev->extraOptions);

    local->name   = dev->identifier;
    local->flags  = XI86_KEYBOARD_CAPABLE;
    local->device_control = jstkKeyboardDeviceControlProc;
    local->read_input = NULL;
    local->close_proc = NULL;
    local->control_proc = NULL;
    local->switch_mode = NULL;
    local->conversion_proc = NULL;
    local->fd = -1;
    local->dev = NULL;
    local->private = NULL;
    local->type_name = XI_JOYSTICK;
    local->history_size = 0;
    local->always_core_feedback = 0;
    local->conf_idev = dev;

    xf86CollectInputOptions(local, NULL, NULL);
    xf86OptionListReport(local->options);
    xf86ProcessCommonOptions(local, local->options);


    /* return the LocalDevice */
    local->flags |= XI86_CONFIGURED;

    return (local);

SetupProc_fail:
    if (local)
        local->private = NULL;
    if (dev) {
        if (dev->identifier) xfree(dev->identifier);
        if (dev->driver) xfree(dev->driver);
        xfree(dev);
d289 4
a292 1
    return NULL;
d307 1
a307 1
                   LocalDevicePtr    local,
d310 1
a310 1
    JoystickDevPtr device = (JoystickDevPtr) local->private;
d314 1
a314 1
    local->private = NULL;
d316 1
a316 1
    xf86DeleteInput(local, 0);
@


1.4
log
@Update to xf86-input-joystick 1.6.0
@
text
@a30 1
#include <xorg-server.h>
d41 1
d43 1
d54 274
d349 1
a349 1
    if (!InitKeyboardDeviceStruct(pJstk, &priv->rmlvo, NULL, jstkKbdCtrl))
d351 36
a386 1
        ErrorF("unable to init keyboard device\n");
d388 1
a388 1
    }
d420 1
a420 1
jstkGenerateKeys(InputInfoPtr device, KEYSCANCODES keys, char pressed)
d450 1
a450 1
Bool
d454 1
a454 2
    InputInfoPtr pInfo = dev->public.devicePrivate;
    JoystickDevPtr priv  = pInfo->private;
d492 1
a492 1
 * See comment in jstkCorePreInit() for details.
a495 61

int jstkKeyboardPreInit(InputDriverPtr drv, InputInfoPtr pInfo, int flags)
{
    JoystickDevPtr priv = NULL;
    char *s;

    pInfo->private = priv = calloc(1, sizeof(JoystickDevRec));
    if (!priv)
        return BadAlloc;

    pInfo->device_control = jstkKeyboardDeviceControlProc;
    pInfo->read_input = NULL;
    pInfo->control_proc = NULL;
    pInfo->switch_mode = NULL;
    pInfo->fd = -1;
    pInfo->type_name = XI_JOYSTICK;

    /* parse keyboard-related options */
    priv->repeat_delay = 0;
    priv->repeat_interval = 0;

    /* Parse option for autorepeat */
    if ((s = xf86SetStrOption(pInfo->options, "AutoRepeat", NULL))) {
        int delay, rate;
        if (sscanf(s, "%d %d", &delay, &rate) != 2) {
            xf86Msg(X_ERROR, "%s: \"%s\" is not a valid AutoRepeat value",
                    pInfo->name, s);
        } else {
            priv->repeat_delay = delay;
            if (rate != 0)
                priv->repeat_interval = 1000/rate;
            else priv->repeat_interval = 0;
            DBG(1, xf86Msg(X_CONFIG, "Autorepeat set to delay=%d, interval=%d\n",
                           priv->repeat_delay,priv->repeat_interval));
        }
        free(s);
    }

    priv->rmlvo.rules = xf86SetStrOption(pInfo->options, "xkb_rules", NULL);
    if (!priv->rmlvo.rules)
	priv->rmlvo.rules = xf86SetStrOption(pInfo->options, "XkbRules", "evdev");

    priv->rmlvo.model = xf86SetStrOption(pInfo->options, "xkb_model", NULL);
    if (!priv->rmlvo.model)
	priv->rmlvo.model = xf86SetStrOption(pInfo->options, "XkbModel", "evdev");

    priv->rmlvo.layout = xf86SetStrOption(pInfo->options, "xkb_layout", NULL);
    if (!priv->rmlvo.layout)
	priv->rmlvo.layout = xf86SetStrOption(pInfo->options, "XkbLayout", "us");

    priv->rmlvo.variant = xf86SetStrOption(pInfo->options, "xkb_variant", NULL);
    if (!priv->rmlvo.variant)
	priv->rmlvo.variant = xf86SetStrOption(pInfo->options, "XkbVariant", "");

    priv->rmlvo.options = xf86SetStrOption(pInfo->options, "xkb_options", NULL);
    if (!priv->rmlvo.options)
	priv->rmlvo.options = xf86SetStrOption(pInfo->options, "XkbOptions", "");

    return Success;
}

d497 1
a497 1
jstkKeyboardHotplug(InputInfoPtr pInfo, int flags)
d499 2
a500 1
    int rc;
a501 11
    InputAttributes *attrs = NULL;
    InputOption *options;
    InputOption *iopts = NULL, *tmp;
    DeviceIntPtr dev;

    /* duplicate option list, append to name */
    options = xf86OptionListDuplicate(pInfo->options);
    strcpy(name, pInfo->name);
    strcat(name, " (keys)");
    options = xf86ReplaceStrOption(options, "Name", name);
    options = xf86ReplaceStrOption(options, "_source", "_driver/joystick");
d503 3
a505 9
    while(options)
    {
        tmp = calloc(1, sizeof(InputOption));

        tmp->key = xf86OptionName(options);
        tmp->value = xf86OptionValue(options);
        tmp->next = iopts;
        iopts = tmp;
        options = xf86NextOption(options);
d508 41
a548 12
    /* duplicate attribute list */
    attrs = DuplicateInputAttributes(pInfo->attrs);

    rc = NewInputDeviceRequest(iopts, attrs, &dev);

    while(iopts)
    {
        tmp = iopts->next;
        free(iopts->key);
        free(iopts->value);
        free(iopts);
        iopts = tmp;
d550 1
a550 4

    FreeInputAttributes(attrs);

    return (rc == Success) ? dev->public.devicePrivate : NULL;
d565 1
a565 1
                   InputInfoPtr      pInfo,
d568 1
a568 1
    JoystickDevPtr device = (JoystickDevPtr) pInfo->private;
d572 1
a572 1
    pInfo->private = NULL;
d574 1
a574 1
    xf86DeleteInput(pInfo, 0);
@


1.3
log
@Update to xf86-input-joystick 1.5.0
@
text
@d31 1
a41 1
#if GET_ABI_MAJOR(ABI_XINPUT_VERSION) >= 5
a42 1
#endif
a52 274


#if GET_ABI_MAJOR(ABI_XINPUT_VERSION) < 5
static KeySym map[] = {
    /* 0x00 */  NoSymbol,       NoSymbol,
    /* 0x01 */  XK_Escape,      NoSymbol,
    /* 0x02 */  XK_1,           XK_exclam,
    /* 0x03 */  XK_2,           XK_at,
    /* 0x04 */  XK_3,           XK_numbersign,
    /* 0x05 */  XK_4,           XK_dollar,
    /* 0x06 */  XK_5,           XK_percent,
    /* 0x07 */  XK_6,           XK_asciicircum,
    /* 0x08 */  XK_7,           XK_ampersand,
    /* 0x09 */  XK_8,           XK_asterisk,
    /* 0x0a */  XK_9,           XK_parenleft,
    /* 0x0b */  XK_0,           XK_parenright,
    /* 0x0c */  XK_minus,       XK_underscore,
    /* 0x0d */  XK_equal,       XK_plus,
    /* 0x0e */  XK_BackSpace,   NoSymbol,
    /* 0x0f */  XK_Tab,         XK_ISO_Left_Tab,
    /* 0x10 */  XK_Q,           NoSymbol,
    /* 0x11 */  XK_W,           NoSymbol,
    /* 0x12 */  XK_E,           NoSymbol,
    /* 0x13 */  XK_R,           NoSymbol,
    /* 0x14 */  XK_T,           NoSymbol,
    /* 0x15 */  XK_Y,           NoSymbol,
    /* 0x16 */  XK_U,           NoSymbol,
    /* 0x17 */  XK_I,           NoSymbol,
    /* 0x18 */  XK_O,           NoSymbol,
    /* 0x19 */  XK_P,           NoSymbol,
    /* 0x1a */  XK_bracketleft, XK_braceleft,
    /* 0x1b */  XK_bracketright,XK_braceright,
    /* 0x1c */  XK_Return,      NoSymbol,
    /* 0x1d */  XK_Control_L,   NoSymbol,
    /* 0x1e */  XK_A,           NoSymbol,
    /* 0x1f */  XK_S,           NoSymbol,
    /* 0x20 */  XK_D,           NoSymbol,
    /* 0x21 */  XK_F,           NoSymbol,
    /* 0x22 */  XK_G,           NoSymbol,
    /* 0x23 */  XK_H,           NoSymbol,
    /* 0x24 */  XK_J,           NoSymbol,
    /* 0x25 */  XK_K,           NoSymbol,
    /* 0x26 */  XK_L,           NoSymbol,
    /* 0x27 */  XK_semicolon,   XK_colon,
    /* 0x28 */  XK_quoteright,  XK_quotedbl,
    /* 0x29 */  XK_quoteleft,	XK_asciitilde,
    /* 0x2a */  XK_Shift_L,     NoSymbol,
    /* 0x2b */  XK_backslash,   XK_bar,
    /* 0x2c */  XK_Z,           NoSymbol,
    /* 0x2d */  XK_X,           NoSymbol,
    /* 0x2e */  XK_C,           NoSymbol,
    /* 0x2f */  XK_V,           NoSymbol,
    /* 0x30 */  XK_B,           NoSymbol,
    /* 0x31 */  XK_N,           NoSymbol,
    /* 0x32 */  XK_M,           NoSymbol,
    /* 0x33 */  XK_comma,       XK_less,
    /* 0x34 */  XK_period,      XK_greater,
    /* 0x35 */  XK_slash,       XK_question,
    /* 0x36 */  XK_Shift_R,     NoSymbol,
    /* 0x37 */  XK_KP_Multiply, NoSymbol,
    /* 0x38 */  XK_Alt_L,	XK_Meta_L,
    /* 0x39 */  XK_space,       NoSymbol,
    /* 0x3a */  XK_Caps_Lock,   NoSymbol,
    /* 0x3b */  XK_F1,          NoSymbol,
    /* 0x3c */  XK_F2,          NoSymbol,
    /* 0x3d */  XK_F3,          NoSymbol,
    /* 0x3e */  XK_F4,          NoSymbol,
    /* 0x3f */  XK_F5,          NoSymbol,
    /* 0x40 */  XK_F6,          NoSymbol,
    /* 0x41 */  XK_F7,          NoSymbol,
    /* 0x42 */  XK_F8,          NoSymbol,
    /* 0x43 */  XK_F9,          NoSymbol,
    /* 0x44 */  XK_F10,         NoSymbol,
    /* 0x45 */  XK_Num_Lock,    NoSymbol,
    /* 0x46 */  XK_Scroll_Lock,	NoSymbol,
    /* These KP keys should have the KP_7 keysyms in the numlock
     * modifer... ? */
    /* 0x47 */  XK_KP_Home,	XK_KP_7,
    /* 0x48 */  XK_KP_Up,	XK_KP_8,
    /* 0x49 */  XK_KP_Prior,	XK_KP_9,
    /* 0x4a */  XK_KP_Subtract, NoSymbol,
    /* 0x4b */  XK_KP_Left,	XK_KP_4,
    /* 0x4c */  XK_KP_Begin,	XK_KP_5,
    /* 0x4d */  XK_KP_Right,	XK_KP_6,
    /* 0x4e */  XK_KP_Add,      NoSymbol,
    /* 0x4f */  XK_KP_End,	XK_KP_1,
    /* 0x50 */  XK_KP_Down,	XK_KP_2,
    /* 0x51 */  XK_KP_Next,	XK_KP_3,
    /* 0x52 */  XK_KP_Insert,	XK_KP_0,
    /* 0x53 */  XK_KP_Delete,	XK_KP_Decimal,
    /* 0x54 */  NoSymbol,	NoSymbol,
    /* 0x55 */  XK_F13,		NoSymbol,
    /* 0x56 */  XK_less,	XK_greater,
    /* 0x57 */  XK_F11,		NoSymbol,
    /* 0x58 */  XK_F12,		NoSymbol,
    /* 0x59 */  XK_F14,		NoSymbol,
    /* 0x5a */  XK_F15,		NoSymbol,
    /* 0x5b */  XK_F16,		NoSymbol,
    /* 0x5c */  XK_F17,		NoSymbol,
    /* 0x5d */  XK_F18,		NoSymbol,
    /* 0x5e */  XK_F19,		NoSymbol,
    /* 0x5f */  XK_F20,		NoSymbol,
    /* 0x60 */  XK_KP_Enter,	NoSymbol,
    /* 0x61 */  XK_Control_R,	NoSymbol,
    /* 0x62 */  XK_KP_Divide,	NoSymbol,
    /* 0x63 */  XK_Print,	XK_Sys_Req,
    /* 0x64 */  XK_Alt_R,	XK_Meta_R,
    /* 0x65 */  NoSymbol,	NoSymbol, /* KEY_LINEFEED */
    /* 0x66 */  XK_Home,	NoSymbol,
    /* 0x67 */  XK_Up,		NoSymbol,
    /* 0x68 */  XK_Prior,	NoSymbol,
    /* 0x69 */  XK_Left,	NoSymbol,
    /* 0x6a */  XK_Right,	NoSymbol,
    /* 0x6b */  XK_End,		NoSymbol,
    /* 0x6c */  XK_Down,	NoSymbol,
    /* 0x6d */  XK_Next,	NoSymbol,
    /* 0x6e */  XK_Insert,	NoSymbol,
    /* 0x6f */  XK_Delete,	NoSymbol,
    /* 0x70 */  NoSymbol,	NoSymbol, /* KEY_MACRO */
    /* 0x71 */  NoSymbol,	NoSymbol,
    /* 0x72 */  NoSymbol,	NoSymbol,
    /* 0x73 */  NoSymbol,	NoSymbol,
    /* 0x74 */  NoSymbol,	NoSymbol,
    /* 0x75 */  XK_KP_Equal,	NoSymbol,
    /* 0x76 */  NoSymbol,	NoSymbol,
    /* 0x77 */  NoSymbol,	NoSymbol,
    /* 0x78 */  XK_F21,		NoSymbol,
    /* 0x79 */  XK_F22,		NoSymbol,
    /* 0x7a */  XK_F23,		NoSymbol,
    /* 0x7b */  XK_F24,		NoSymbol,
    /* 0x7c */  XK_KP_Separator, NoSymbol,
    /* 0x7d */  XK_Meta_L,	NoSymbol,
    /* 0x7e */  XK_Meta_R,	NoSymbol,
    /* 0x7f */  XK_Multi_key,	NoSymbol,
    /* 0x80 */  NoSymbol,	NoSymbol,
    /* 0x81 */  NoSymbol,	NoSymbol,
    /* 0x82 */  NoSymbol,	NoSymbol,
    /* 0x83 */  NoSymbol,	NoSymbol,
    /* 0x84 */  NoSymbol,	NoSymbol,
    /* 0x85 */  NoSymbol,	NoSymbol,
    /* 0x86 */  NoSymbol,	NoSymbol,
    /* 0x87 */  NoSymbol,	NoSymbol,
    /* 0x88 */  NoSymbol,	NoSymbol,
    /* 0x89 */  NoSymbol,	NoSymbol,
    /* 0x8a */  NoSymbol,	NoSymbol,
    /* 0x8b */  NoSymbol,	NoSymbol,
    /* 0x8c */  NoSymbol,	NoSymbol,
    /* 0x8d */  NoSymbol,	NoSymbol,
    /* 0x8e */  NoSymbol,	NoSymbol,
    /* 0x8f */  NoSymbol,	NoSymbol,
    /* 0x90 */  NoSymbol,	NoSymbol,
    /* 0x91 */  NoSymbol,	NoSymbol,
    /* 0x92 */  NoSymbol,	NoSymbol,
    /* 0x93 */  NoSymbol,	NoSymbol,
    /* 0x94 */  NoSymbol,	NoSymbol,
    /* 0x95 */  NoSymbol,	NoSymbol,
    /* 0x96 */  NoSymbol,	NoSymbol,
    /* 0x97 */  NoSymbol,	NoSymbol,
    /* 0x98 */  NoSymbol,	NoSymbol,
    /* 0x99 */  NoSymbol,	NoSymbol,
    /* 0x9a */  NoSymbol,	NoSymbol,
    /* 0x9b */  NoSymbol,	NoSymbol,
    /* 0x9c */  NoSymbol,	NoSymbol,
    /* 0x9d */  NoSymbol,	NoSymbol,
    /* 0x9e */  NoSymbol,	NoSymbol,
    /* 0x9f */  NoSymbol,	NoSymbol,
    /* 0xa0 */  NoSymbol,	NoSymbol,
    /* 0xa1 */  NoSymbol,	NoSymbol,
    /* 0xa2 */  NoSymbol,	NoSymbol,
    /* 0xa3 */  NoSymbol,	NoSymbol,
    /* 0xa4 */  NoSymbol,	NoSymbol,
    /* 0xa5 */  NoSymbol,	NoSymbol,
    /* 0xa6 */  NoSymbol,	NoSymbol,
    /* 0xa7 */  NoSymbol,	NoSymbol,
    /* 0xa8 */  NoSymbol,	NoSymbol,
    /* 0xa9 */  NoSymbol,	NoSymbol,
    /* 0xaa */  NoSymbol,	NoSymbol,
    /* 0xab */  NoSymbol,	NoSymbol,
    /* 0xac */  NoSymbol,	NoSymbol,
    /* 0xad */  NoSymbol,	NoSymbol,
    /* 0xae */  NoSymbol,	NoSymbol,
    /* 0xaf */  NoSymbol,	NoSymbol,
    /* 0xb0 */  NoSymbol,	NoSymbol,
    /* 0xb1 */  NoSymbol,	NoSymbol,
    /* 0xb2 */  NoSymbol,	NoSymbol,
    /* 0xb3 */  NoSymbol,	NoSymbol,
    /* 0xb4 */  NoSymbol,	NoSymbol,
    /* 0xb5 */  NoSymbol,	NoSymbol,
    /* 0xb6 */  NoSymbol,	NoSymbol,
    /* 0xb7 */  NoSymbol,	NoSymbol,
    /* 0xb8 */  NoSymbol,	NoSymbol,
    /* 0xb9 */  NoSymbol,	NoSymbol,
    /* 0xba */  NoSymbol,	NoSymbol,
    /* 0xbb */  NoSymbol,	NoSymbol,
    /* 0xbc */  NoSymbol,	NoSymbol,
    /* 0xbd */  NoSymbol,	NoSymbol,
    /* 0xbe */  NoSymbol,	NoSymbol,
    /* 0xbf */  NoSymbol,	NoSymbol,
    /* 0xc0 */  NoSymbol,	NoSymbol,
    /* 0xc1 */  NoSymbol,	NoSymbol,
    /* 0xc2 */  NoSymbol,	NoSymbol,
    /* 0xc3 */  NoSymbol,	NoSymbol,
    /* 0xc4 */  NoSymbol,	NoSymbol,
    /* 0xc5 */  NoSymbol,	NoSymbol,
    /* 0xc6 */  NoSymbol,	NoSymbol,
    /* 0xc7 */  NoSymbol,	NoSymbol,
    /* 0xc8 */  NoSymbol,	NoSymbol,
    /* 0xc9 */  NoSymbol,	NoSymbol,
    /* 0xca */  NoSymbol,	NoSymbol,
    /* 0xcb */  NoSymbol,	NoSymbol,
    /* 0xcc */  NoSymbol,	NoSymbol,
    /* 0xcd */  NoSymbol,	NoSymbol,
    /* 0xce */  NoSymbol,	NoSymbol,
    /* 0xcf */  NoSymbol,	NoSymbol,
    /* 0xd0 */  NoSymbol,	NoSymbol,
    /* 0xd1 */  NoSymbol,	NoSymbol,
    /* 0xd2 */  NoSymbol,	NoSymbol,
    /* 0xd3 */  NoSymbol,	NoSymbol,
    /* 0xd4 */  NoSymbol,	NoSymbol,
    /* 0xd5 */  NoSymbol,	NoSymbol,
    /* 0xd6 */  NoSymbol,	NoSymbol,
    /* 0xd7 */  NoSymbol,	NoSymbol,
    /* 0xd8 */  NoSymbol,	NoSymbol,
    /* 0xd9 */  NoSymbol,	NoSymbol,
    /* 0xda */  NoSymbol,	NoSymbol,
    /* 0xdb */  NoSymbol,	NoSymbol,
    /* 0xdc */  NoSymbol,	NoSymbol,
    /* 0xdd */  NoSymbol,	NoSymbol,
    /* 0xde */  NoSymbol,	NoSymbol,
    /* 0xdf */  NoSymbol,	NoSymbol,
    /* 0xe0 */  NoSymbol,	NoSymbol,
    /* 0xe1 */  NoSymbol,	NoSymbol,
    /* 0xe2 */  NoSymbol,	NoSymbol,
    /* 0xe3 */  NoSymbol,	NoSymbol,
    /* 0xe4 */  NoSymbol,	NoSymbol,
    /* 0xe5 */  NoSymbol,	NoSymbol,
    /* 0xe6 */  NoSymbol,	NoSymbol,
    /* 0xe7 */  NoSymbol,	NoSymbol,
    /* 0xe8 */  NoSymbol,	NoSymbol,
    /* 0xe9 */  NoSymbol,	NoSymbol,
    /* 0xea */  NoSymbol,	NoSymbol,
    /* 0xeb */  NoSymbol,	NoSymbol,
    /* 0xec */  NoSymbol,	NoSymbol,
    /* 0xed */  NoSymbol,	NoSymbol,
    /* 0xee */  NoSymbol,	NoSymbol,
    /* 0xef */  NoSymbol,	NoSymbol,
    /* 0xf0 */  NoSymbol,	NoSymbol,
    /* 0xf1 */  NoSymbol,	NoSymbol,
    /* 0xf2 */  NoSymbol,	NoSymbol,
    /* 0xf3 */  NoSymbol,	NoSymbol,
    /* 0xf4 */  NoSymbol,	NoSymbol,
    /* 0xf5 */  NoSymbol,	NoSymbol,
    /* 0xf6 */  NoSymbol,	NoSymbol,
    /* 0xf7 */  NoSymbol,	NoSymbol,
};

static struct { KeySym keysym; CARD8 mask; } modifiers[] = {
    { XK_Shift_L,		ShiftMask },
    { XK_Shift_R,		ShiftMask },
    { XK_Control_L,		ControlMask },
    { XK_Control_R,		ControlMask },
    { XK_Caps_Lock,		LockMask },
    { XK_Alt_L,		AltMask },
    { XK_Alt_R,		AltMask },
    { XK_Meta_L,		Mod4Mask },
    { XK_Meta_R,		Mod4Mask },
    { XK_Num_Lock,		NumLockMask },
    { XK_Scroll_Lock,	ScrollLockMask },
    { XK_Mode_switch,	AltLangMask }
};
#endif



d74 1
a74 1
#if GET_ABI_MAJOR(ABI_XINPUT_VERSION) >= 5
d76 2
a77 27
        if (!InitKeyboardDeviceStruct(pJstk, &priv->rmlvo, NULL, jstkKbdCtrl))
        {
            ErrorF("unable to init keyboard device\n");
            return !Success;
        }
    }
#else
    KeySymsRec keySyms;
    CARD8 modMap[MAP_LENGTH];
    KeySym sym;
    int i, j;
    XkbComponentNamesRec xkbnames;

    memset(modMap, 0, sizeof(modMap));
    memset(&xkbnames, 0, sizeof(xkbnames));

    keySyms.map        = map;
    keySyms.mapWidth   = GLYPHS_PER_KEY;
    keySyms.minKeyCode = MIN_KEYCODE;
    keySyms.maxKeyCode = MIN_KEYCODE + (sizeof(map) / sizeof(map[0])) / GLYPHS_PER_KEY - 1;

    for (i = 0; i < (sizeof(map) / sizeof(map[0])) / GLYPHS_PER_KEY; i++) {
        sym = map[i * GLYPHS_PER_KEY];
        for (j = 0; j < sizeof(modifiers)/sizeof(modifiers[0]); j++) {
            if (modifiers[j].keysym == sym)
                modMap[i + MIN_KEYCODE] = modifiers[j].mask;
        }
a79 10
    ErrorF("%s, %s, %s, %s, %s\n", priv->rmlvo.rules, priv->rmlvo.model, priv->rmlvo.layout, priv->rmlvo.variant, priv->rmlvo.options);
    XkbSetRulesDflts(priv->rmlvo.rules, priv->rmlvo.model,
            priv->rmlvo.layout, priv->rmlvo.variant,
            priv->rmlvo.options);
    if (!XkbInitKeyboardDeviceStruct(pJstk, &xkbnames,
                &keySyms, modMap, NULL,
                jstkKbdCtrl))
        return !Success;
#endif

d110 1
a110 1
jstkGenerateKeys(LocalDevicePtr device, KEYSCANCODES keys, char pressed)
d140 1
a140 1
static Bool
d144 2
a145 1
    JoystickDevPtr priv  = (JoystickDevPtr)XI_PRIVATE(dev);
d183 1
a183 1
 * Called manually to create a keyboard device for the joystick
d187 61
d249 1
a249 1
jstkKeyboardPreInit(InputDriverPtr drv, IDevPtr _dev, int flags)
d251 1
a251 2
    LocalDevicePtr local = NULL;
    IDevPtr dev = NULL;
d253 11
d265 9
a273 3
    local = xf86AllocateInput(drv, 0);
    if (!local) {
        goto SetupProc_fail;
d276 12
a287 41
    dev = xcalloc(sizeof(IDevRec), 1);
    strcpy(name, _dev->identifier);
    strcat(name, " (keys)");
    dev->identifier = xstrdup(name);
    dev->driver = xstrdup(_dev->driver);
    dev->commonOptions = (pointer)xf86optionListDup(_dev->commonOptions);
    dev->extraOptions = (pointer)xf86optionListDup(_dev->extraOptions);

    local->name   = dev->identifier;
    local->flags  = XI86_KEYBOARD_CAPABLE;
    local->device_control = jstkKeyboardDeviceControlProc;
    local->read_input = NULL;
    local->close_proc = NULL;
    local->control_proc = NULL;
    local->switch_mode = NULL;
    local->conversion_proc = NULL;
    local->fd = -1;
    local->dev = NULL;
    local->private = NULL;
    local->type_name = XI_JOYSTICK;
    local->history_size = 0;
    local->always_core_feedback = 0;
    local->conf_idev = dev;

    xf86CollectInputOptions(local, NULL, NULL);
    xf86OptionListReport(local->options);
    xf86ProcessCommonOptions(local, local->options);


    /* return the LocalDevice */
    local->flags |= XI86_CONFIGURED;

    return (local);

SetupProc_fail:
    if (local)
        local->private = NULL;
    if (dev) {
        if (dev->identifier) xfree(dev->identifier);
        if (dev->driver) xfree(dev->driver);
        xfree(dev);
d289 4
a292 1
    return NULL;
d307 1
a307 1
                   LocalDevicePtr    local,
d310 1
a310 1
    JoystickDevPtr device = (JoystickDevPtr) local->private;
d314 1
a314 1
    local->private = NULL;
d316 1
a316 1
    xf86DeleteInput(local, 0);
@


1.2
log
@update to xf86-input-joystick 1.4.1
@
text
@d45 3
d56 271
a345 4
    KeySymsRec keySyms;
    CARD8 modMap[MAP_LENGTH];
    KeySym sym;
    int i, j;
d349 1
a349 16
    static struct { KeySym keysym; CARD8 mask; } modifiers[] = {
        { XK_Shift_L,           ShiftMask },
        { XK_Shift_R,           ShiftMask },
        { XK_Control_L,         ControlMask },
        { XK_Control_R,         ControlMask },
        { XK_Caps_Lock,         LockMask },
        { XK_Alt_L,             AltMask },
        { XK_Alt_R,             AltMask },
        { XK_Num_Lock,          NumLockMask },
        { XK_Scroll_Lock,       ScrollLockMask },
        { XK_Mode_switch,       AltLangMask }
    };

    DBG(1, xf86Msg(X_CONFIG, "Initializing Keyboard with %d keys\n",
                   priv->keymap.size));
    for (i = 0; i < priv->keymap.size; i++)
d351 5
a355 1
	DBG(6, xf86Msg(X_CONFIG, "Keymap [%d]: 0x%08X\n", MIN_KEYCODE+i,(unsigned int)priv->keymap.map[i]));
d357 6
d365 1
d367 2
a368 3

    keySyms.map        = priv->keymap.map;
    keySyms.mapWidth   = 1;
d370 1
a370 2
/*    keySyms.maxKeyCode = MIN_KEYCODE + priv->keymap.size - 1; */
    keySyms.maxKeyCode = MIN_KEYCODE + sizeof(priv->keymap.map)/sizeof(priv->keymap.map[0]) - 1;
d372 2
a373 2
    for (i = 0; i < priv->keymap.size; i++) {
        sym = priv->keymap.map[i];
d380 7
a386 15
#if GET_ABI_MAJOR(ABI_XINPUT_VERSION) >= 5
    {
        XkbRMLVOSet rmlvo;
        XkbGetRulesDflts(&rmlvo);
    	/* FIXME */
	#warning KEYMAP FOR ABI_XINPUT_VERSION >= 5 BROKEN RIGHT NOW
        if (!InitKeyboardDeviceStruct(pJstk, &rmlvo, NULL, jstkKbdCtrl))
        {
            ErrorF("unable to init keyboard device\n");
            return !Success;
        }
    }
#else
    if (InitKeyboardDeviceStruct((DevicePtr)pJstk, &keySyms, modMap, NULL, jstkKbdCtrl) == FALSE) {
	ErrorF("unable to init keyboard device\n");
a387 1
    }
a432 1
            k = k + MIN_KEYCODE;
@


1.1
log
@xf86-input joystick 1.3.2
@
text
@a32 2
#include <X11/extensions/XKB.h>
#include <X11/extensions/XKBstr.h>
d36 2
d41 4
d51 19
a69 1
int
a75 1
    static XkbComponentNamesRec xkbnames;
d96 1
a96 1
	DBG(6, xf86Msg(X_CONFIG, "Keymap [%d]: 0x%08X\n", MIN_KEYCODE+i,priv->keymap.map[i]));
a100 7
    for (i = 0; i < priv->keymap.size; i++) {
        sym = priv->keymap.map[i];
        for (j = 0; j < sizeof(modifiers)/sizeof(modifiers[0]); j++) {
            if (modifiers[j].keysym == sym)
                modMap[i + MIN_KEYCODE] = modifiers[j].mask; 
        }
    }
d116 18
a133 3
    XkbSetRulesDflts(__XKBDEFRULES__, "evdev", "us", "nodeadkeys", NULL);
    XkbInitKeyboardDeviceStruct (pJstk, &xkbnames, &keySyms, modMap,
            NULL, NULL);
a135 1

d165 1
a165 1
jstkGenerateKeys(DeviceIntPtr device, KEYSCANCODES keys, char pressed)
d170 2
d181 1
a181 1
            xf86PostKeyboardEvent(device, k, pressed);
d186 136
@

