head	1.6;
access;
symbols
	OPENBSD_6_0:1.5.0.20
	OPENBSD_6_0_BASE:1.5
	OPENBSD_5_9:1.5.0.18
	OPENBSD_5_9_BASE:1.5
	OPENBSD_5_8:1.5.0.16
	OPENBSD_5_8_BASE:1.5
	OPENBSD_5_7:1.5.0.14
	OPENBSD_5_7_BASE:1.5
	OPENBSD_5_6:1.5.0.12
	OPENBSD_5_6_BASE:1.5
	OPENBSD_5_5:1.5.0.10
	OPENBSD_5_5_BASE:1.5
	OPENBSD_5_4:1.5.0.8
	OPENBSD_5_4_BASE:1.5
	OPENBSD_5_3:1.5.0.6
	OPENBSD_5_3_BASE:1.5
	OPENBSD_5_2:1.5.0.4
	OPENBSD_5_2_BASE:1.5
	OPENBSD_5_1_BASE:1.5
	OPENBSD_5_1:1.5.0.2
	OPENBSD_5_0:1.4.0.2
	OPENBSD_5_0_BASE:1.4
	OPENBSD_4_9:1.2.0.6
	OPENBSD_4_9_BASE:1.2
	OPENBSD_4_8:1.2.0.8
	OPENBSD_4_8_BASE:1.2
	OPENBSD_4_7:1.2.0.4
	OPENBSD_4_7_BASE:1.2
	OPENBSD_4_6:1.2.0.2
	OPENBSD_4_6_BASE:1.2
	OPENBSD_4_5:1.1.0.2
	OPENBSD_4_5_BASE:1.1;
locks; strict;
comment	@ * @;


1.6
date	2017.01.22.09.44.15;	author matthieu;	state Exp;
branches;
next	1.5;
commitid	eqnV0ShUiED6Tid5;

1.5
date	2011.11.05.14.01.51;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2011.07.02.21.59.45;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2011.07.02.21.03.42;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2009.05.03.13.54.12;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2008.08.23.14.16.59;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.6
log
@Update to xf86-input-joystick 1.6.3
@
text
@/*
 * Copyright 2007-2008 by Sascha Hlusiak. <saschahlusiak@@freedesktop.org>     
 *                                                                            
 * Permission to use, copy, modify, distribute, and sell this software and its
 * documentation for any purpose is  hereby granted without fee, provided that
 * the  above copyright   notice appear  in   all  copies and  that both  that
 * copyright  notice   and   this  permission   notice  appear  in  supporting
 * documentation, and that   the  name of  Sascha   Hlusiak  not  be  used  in
 * advertising or publicity pertaining to distribution of the software without
 * specific,  written      prior  permission.     Sascha   Hlusiak   makes  no
 * representations about the suitability of this software for any purpose.  It
 * is provided "as is" without express or implied warranty.                   
 *                                                                            
 * SASCHA  HLUSIAK  DISCLAIMS ALL   WARRANTIES WITH REGARD  TO  THIS SOFTWARE,
 * INCLUDING ALL IMPLIED   WARRANTIES OF MERCHANTABILITY  AND   FITNESS, IN NO
 * EVENT  SHALL SASCHA  HLUSIAK  BE   LIABLE   FOR ANY  SPECIAL, INDIRECT   OR
 * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
 * DATA  OR PROFITS, WHETHER  IN  AN ACTION OF  CONTRACT,  NEGLIGENCE OR OTHER
 * TORTIOUS  ACTION, ARISING    OUT OF OR   IN  CONNECTION  WITH THE USE    OR
 * PERFORMANCE OF THIS SOFTWARE.
 *
 */

/**
 * This provides the backend for Linux joystick devices.
 * Usable in FreeBSD with the linux_js module.
 * Devices are usually /dev/input/js?
 **/


#ifdef HAVE_CONFIG_H
#include "config.h"
#endif

#include <xorg-server.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/ioctl.h>
#include <fcntl.h>
#include <errno.h>
#include <string.h>
#include <stdlib.h>
#include <linux/joystick.h>

#include <xf86.h>
#include <xf86_OSproc.h>

#include "jstk.h"
#include "backend_joystick.h"


static int jstkReadData_joystick(JoystickDevPtr joystick,
                                 JOYSTICKEVENT *event,
                                 int *number);


/***********************************************************************
 *
 * jstkOpenDevice --
 *
 * Open and initialize a joystick device. The device name is
 * taken from JoystickDevPtr 
 * Returns the filedescriptor, or -1 in case of error
 *
 ***********************************************************************
 */

int
jstkOpenDevice_joystick(JoystickDevPtr joystick, Bool probe)
{
    char joy_name[128];
    unsigned char axes, buttons;
    int driver_version;

    if (joystick->fd == -1) {
        if ((joystick->fd = open(joystick->device, O_RDONLY | O_NDELAY, 0)) < 0) {
            xf86Msg(X_ERROR, "Cannot open joystick '%s' (%s)\n",
                    joystick->device, strerror(errno));
            return -1;
        }
    }

    if (ioctl(joystick->fd, JSIOCGVERSION, &driver_version) == -1) {
        xf86Msg(X_ERROR, "Joystick: ioctl JSIOCGVERSION on '%s' failed: %s\n", 
                joystick->device, strerror(errno));
        jstkCloseDevice(joystick);
        return -1;
    }
    if ((driver_version >> 16) < 1) {
        xf86Msg(X_WARNING, "Joystick: Driver version is only %d.%d.%d\n",
                driver_version >> 16,
                (driver_version >> 8) & 0xff,
                driver_version & 0xff);
    }

    if (ioctl(joystick->fd, JSIOCGAXES, &axes) == -1) {
        xf86Msg(X_ERROR, "Joystick: ioctl JSIOCGAXES on '%s' failed: %s\n", 
                joystick->device, strerror(errno));
        jstkCloseDevice(joystick);
        return -1;
    }

    if (ioctl(joystick->fd, JSIOCGBUTTONS, &buttons) == -1) {
        xf86Msg(X_ERROR, "Joystick: ioctl JSIOCGBUTTONS on '%s' failed: %s\n", 
                joystick->device, strerror(errno));
        jstkCloseDevice(joystick);
        return -1;
    }

    if (ioctl(joystick->fd, JSIOCGNAME(128), joy_name) == -1) {
        xf86Msg(X_ERROR, "Joystick: ioctl JSIOCGNAME on '%s' failed: %s\n", 
                  joystick->device, strerror(errno));
        jstkCloseDevice(joystick);
        return -1;
    }

    if (probe == TRUE) {
        xf86Msg(X_INFO, "Joystick: %s. %d axes, %d buttons\n", 
                joy_name, axes, buttons);
    }

    if (buttons > MAXBUTTONS)
        buttons = MAXBUTTONS;
    if (axes > MAXAXES)
        axes = MAXAXES;
    joystick->num_buttons = buttons;
    joystick->num_axes = axes;

    joystick->open_proc = jstkOpenDevice_joystick;
    joystick->read_proc = jstkReadData_joystick;
    joystick->close_proc = jstkCloseDevice;
    return joystick->fd;
}


/***********************************************************************
 *
 * jstkReadData --
 *
 * Reads data from fd and stores it in the JoystickDevRec struct
 * fills in the type of event and the number of the button/axis
 * return 1 if success, 0 otherwise. Success does not neccessarily
 * mean that there is a new event waiting.
 *
 ***********************************************************************
 */

static int
jstkReadData_joystick(JoystickDevPtr joystick,
                      JOYSTICKEVENT *event,
                      int *number)
{
    struct js_event js;
    if (event != NULL) *event = EVENT_NONE;
    if (xf86ReadSerial(joystick->fd, &js, sizeof(struct js_event)) !=
        sizeof(struct js_event))
        return 0;

    switch(js.type & ~JS_EVENT_INIT) {
    case JS_EVENT_BUTTON:
        if (js.number < MAXBUTTONS)
        {
            if (joystick->button[js.number].pressed != js.value) {
                joystick->button[js.number].pressed = js.value;
                if (event != NULL) *event = EVENT_BUTTON;
                if (number != NULL) *number = js.number;
            }
        }
        break;
    case JS_EVENT_AXIS:
        if (js.number < MAXAXES) {
            if (abs(js.value) < joystick->axis[js.number].deadzone) {
                /* We only want one event when in deadzone */
                if (joystick->axis[js.number].value != 0) {
                    joystick->axis[js.number].value = 0;
                    if (event != NULL) *event = EVENT_AXIS;
                    if (number != NULL) *number = js.number;
                }
            }else{
                joystick->axis[js.number].value = js.value;
                if (event != NULL) *event = EVENT_AXIS;
                if (number != NULL) *number = js.number;
            }
        }
        break;
    }
    return 1;
}
@


1.5
log
@Update to xf86-input-joystick 1.6.0 for good now.
@
text
@a51 1
static void jstkCloseDevice_joystick(JoystickDevPtr joystick);
d75 6
a80 4
    if ((joystick->fd = open(joystick->device, O_RDONLY | O_NDELAY, 0)) < 0) {
        xf86Msg(X_ERROR, "Cannot open joystick '%s' (%s)\n", 
                joystick->device, strerror(errno));
        return -1;
d86 1
a86 2
        close(joystick->fd);
        joystick->fd = -1;
d99 1
a99 2
        close(joystick->fd);
        joystick->fd = -1;
d106 1
a106 2
        close(joystick->fd);
        joystick->fd = -1;
d113 1
a113 2
        close(joystick->fd);
        joystick->fd = -1;
d131 1
a131 1
    joystick->close_proc = jstkCloseDevice_joystick;
a132 19
}


/***********************************************************************
 *
 * jstkCloseDevice --
 *
 * close the handle.
 *
 ***********************************************************************
 */

static void
jstkCloseDevice_joystick(JoystickDevPtr joystick)
{
    if ((joystick->fd >= 0)) {
        xf86CloseSerial(joystick->fd);
        joystick->fd = -1;
    }
@


1.4
log
@Revert update to xf86-input-joystick 1.6.0.
This driver depends on xserver 1.10.
@
text
@d35 1
@


1.3
log
@Update to xf86-input-joystick 1.6.0
@
text
@a34 1
#include <xorg-server.h>
@


1.2
log
@update to xf86-input-joystick 1.4.1
@
text
@d35 1
@


1.1
log
@xf86-input joystick 1.3.2
@
text
@d51 6
d69 1
a69 1
jstkOpenDevice_joystick(JoystickDevPtr joystick)
d119 4
a122 2
    xf86Msg(X_INFO, "Joystick: %s. %d axes, %d buttons\n", 
            joy_name, axes, buttons);
d124 8
d147 1
a147 1
void
d169 1
a169 1
int
a195 2
                    joystick->axis[js.number].oldvalue = 
                        joystick->axis[js.number].value;
a200 2
                joystick->axis[js.number].oldvalue = 
                    joystick->axis[js.number].value;
@

