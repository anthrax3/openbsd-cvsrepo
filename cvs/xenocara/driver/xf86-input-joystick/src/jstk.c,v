head	1.9;
access;
symbols
	OPENBSD_6_2:1.9.0.4
	OPENBSD_6_2_BASE:1.9
	OPENBSD_6_1:1.9.0.2
	OPENBSD_6_1_BASE:1.9
	OPENBSD_6_0:1.8.0.12
	OPENBSD_6_0_BASE:1.8
	OPENBSD_5_9:1.8.0.10
	OPENBSD_5_9_BASE:1.8
	OPENBSD_5_8:1.8.0.8
	OPENBSD_5_8_BASE:1.8
	OPENBSD_5_7:1.8.0.6
	OPENBSD_5_7_BASE:1.8
	OPENBSD_5_6:1.8.0.4
	OPENBSD_5_6_BASE:1.8
	OPENBSD_5_5:1.8.0.2
	OPENBSD_5_5_BASE:1.8
	OPENBSD_5_4:1.7.0.6
	OPENBSD_5_4_BASE:1.7
	OPENBSD_5_3:1.7.0.4
	OPENBSD_5_3_BASE:1.7
	OPENBSD_5_2:1.7.0.2
	OPENBSD_5_2_BASE:1.7
	OPENBSD_5_1_BASE:1.6
	OPENBSD_5_1:1.6.0.2
	OPENBSD_5_0:1.5.0.2
	OPENBSD_5_0_BASE:1.5
	OPENBSD_4_9:1.3.0.4
	OPENBSD_4_9_BASE:1.3
	OPENBSD_4_8:1.3.0.6
	OPENBSD_4_8_BASE:1.3
	OPENBSD_4_7:1.3.0.2
	OPENBSD_4_7_BASE:1.3
	OPENBSD_4_6:1.2.0.2
	OPENBSD_4_6_BASE:1.2
	OPENBSD_4_5:1.1.0.2
	OPENBSD_4_5_BASE:1.1;
locks; strict;
comment	@ * @;


1.9
date	2017.01.22.09.44.15;	author matthieu;	state Exp;
branches;
next	1.8;
commitid	eqnV0ShUiED6Tid5;

1.8
date	2014.01.03.09.37.48;	author matthieu;	state Exp;
branches;
next	1.7;

1.7
date	2012.04.08.17.03.03;	author matthieu;	state Exp;
branches;
next	1.6;

1.6
date	2011.11.05.14.01.51;	author matthieu;	state Exp;
branches;
next	1.5;

1.5
date	2011.07.02.21.59.45;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2011.07.02.21.03.42;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2009.11.22.14.38.31;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2009.05.03.13.54.12;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2008.08.23.14.16.59;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.9
log
@Update to xf86-input-joystick 1.6.3
@
text
@/*
 * Copyright 2007-2011 by Sascha Hlusiak. <saschahlusiak@@freedesktop.org>     
 * Copyright 1995-1999 by Frederic Lepied, France. <Lepied@@XFree86.org>       
 *                                                                            
 * Permission to use, copy, modify, distribute, and sell this software and its
 * documentation for any purpose is  hereby granted without fee, provided that
 * the  above copyright   notice appear  in   all  copies and  that both  that
 * copyright  notice   and   this  permission   notice  appear  in  supporting
 * documentation, and that  the  names  of copyright holders not  be  used  in
 * advertising or publicity pertaining to distribution of the software without
 * specific,  written      prior  permission.  The copyright holders  make  no
 * representations about the suitability of this software for any purpose.  It
 * is provided "as is" without express or implied warranty.                   
 *                                                                            
 * THE COPYRIGHT HOLDERS DISCLAIM ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
 * INCLUDING ALL IMPLIED   WARRANTIES OF MERCHANTABILITY  AND   FITNESS, IN NO
 * EVENT  SHALL THE COPYRIGHT HOLDERS BE LIABLE FOR ANY SPECIAL, INDIRECT   OR
 * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
 * DATA  OR PROFITS, WHETHER  IN  AN ACTION OF  CONTRACT,  NEGLIGENCE OR OTHER
 * TORTIOUS  ACTION, ARISING    OUT OF OR   IN  CONNECTION  WITH THE USE    OR
 * PERFORMANCE OF THIS SOFTWARE.
 */

#ifdef HAVE_CONFIG_H
#include "config.h"
#endif

#include <xorg-server.h>
#include <stdio.h>
#include <xorgVersion.h>

#include <misc.h>
#include <xf86.h>
#include <xf86Xinput.h>
#include <exevents.h>		/* Needed for InitValuator/Proximity stuff */
#include <xf86Opt.h>
#include <xf86_OSproc.h>

#include <math.h>
#include <xf86Module.h>


#include "jstk.h"
#include "jstk_axis.h"
#include "jstk_key.h"
#include "jstk_options.h"
#include "jstk_properties.h"
#include <xserver-properties.h>

#ifdef LINUX_BACKEND
    #include "backend_joystick.h"
#endif
#ifdef BSD_BACKEND
    #include "backend_bsd.h"
#endif
#ifdef EVDEV_BACKEND
    #include "backend_evdev.h"
#endif


#if DEBUG
    char debug_level = 0;
#endif

/*
 ***************************************************************************
 *
 * jstkOpenDevice --
 *
 * Called to open the device specified in priv
 * The compiled backends are tried one by one and return the first matching
 *
 * Returns the filedescriptor or -1 in case of error
 *
 ***************************************************************************
 */
static int
jstkOpenDevice(JoystickDevPtr priv, BOOL probe)
{
    int fd;
    fd = -1;

    if (priv->joystick_device->flags & XI86_SERVER_FD)
        priv->fd = priv->joystick_device->fd;

    if (probe == FALSE && priv->open_proc)
        return priv->open_proc(priv, probe);

#ifdef EVDEV_BACKEND
    if (fd == -1)
        fd = jstkOpenDevice_evdev(priv, probe);
#endif
#ifdef LINUX_BACKEND
    if (fd == -1)
        fd = jstkOpenDevice_joystick(priv, probe);
#endif
#ifdef BSD_BACKEND
    if (fd == -1)
        fd = jstkOpenDevice_bsd(priv, probe);
#endif

    return fd;
}

/*
 ***************************************************************************
 *
 * jstkCloseDevice --
 *
 * Called to close the device specified in priv, this is a helper for
 * backend proc_close functions
 *
 ***************************************************************************
 */
void jstkCloseDevice(JoystickDevPtr priv)
{
    if ((priv->fd >= 0)) {
      if (!(priv->joystick_device->flags & XI86_SERVER_FD))
          xf86CloseSerial(priv->fd);
      priv->fd = -1;
    }
}

/*
 ***************************************************************************
 *
 * jstkReadProc --
 *
 * Called when data is available to read from the device
 * Reads the data and process the events
 *
 ***************************************************************************
 */

static void
jstkReadProc(InputInfoPtr pInfo)
{
    JOYSTICKEVENT event;
    int number;
    int i, r;

    JoystickDevPtr priv = pInfo->private;

    do {
        if ((priv->read_proc == NULL) || 
            ((r=priv->read_proc(priv, &event, &number))==0)) {
            xf86Msg(X_WARNING, "JOYSTICK: Read failed. Deactivating device.\n");

            if (pInfo->fd >= 0)
                xf86RemoveEnabledDevice(pInfo);
            return;
        }

        /* A button's status changed */
        if (event == EVENT_BUTTON) {
            DBG(4, ErrorF("Button %d %s. Mapping: %d\n", number, 
                (priv->button[number].pressed == 0) ? "released" : "pressed", 
                priv->button[number].mapping));

            switch (priv->button[number].mapping) {
            case JSTK_MAPPING_BUTTON:
                if (priv->mouse_enabled == TRUE) {
                    xf86PostButtonEvent(pInfo->dev, 0,
                        priv->button[number].buttonnumber,
                        priv->button[number].pressed, 0, 0);
                }
                break;

            case JSTK_MAPPING_X:
            case JSTK_MAPPING_Y:
            case JSTK_MAPPING_ZX:
            case JSTK_MAPPING_ZY:
                if (priv->button[number].pressed == 0) 
                    priv->button[number].currentspeed = 1.0;
                else if (priv->mouse_enabled == TRUE)
                    jstkStartButtonAxisTimer(pInfo, number);
                break;

            case JSTK_MAPPING_KEY:
                if (priv->keys_enabled == TRUE)
                    jstkGenerateKeys(priv->keyboard_device, 
                                     priv->button[number].keys, 
                                     priv->button[number].pressed);
                break;

            case JSTK_MAPPING_SPEED_MULTIPLY:
                priv->amplify = 1.0;
                /* Calculate new amplify value by multiplying them all */
                for (i=0; i<MAXAXES; i++) {
                    if ((priv->button[i].pressed) && 
                        (priv->button[i].mapping == JSTK_MAPPING_SPEED_MULTIPLY))
                        priv->amplify *= priv->button[i].amplify;
                }
                DBG(2, ErrorF("Amplify is now %.3f\n", priv->amplify));
                break;

            case JSTK_MAPPING_DISABLE:
                if (priv->button[number].pressed == 1) {
                    if ((priv->mouse_enabled == TRUE) || 
                        (priv->keys_enabled == TRUE))
                    {
                        priv->mouse_enabled = FALSE;
                        priv->keys_enabled = FALSE;
                        DBG(2, ErrorF("All events disabled\n"));
                    } else {
                        priv->mouse_enabled = TRUE;
                        priv->keys_enabled = TRUE;
                        DBG(2, ErrorF("All events enabled\n"));
                    }
                }
                break;
            case JSTK_MAPPING_DISABLE_MOUSE:
                if (priv->button[number].pressed == 1) {
                    if (priv->mouse_enabled == TRUE) 
                        priv->mouse_enabled = FALSE;
                    else priv->mouse_enabled = TRUE;
                    DBG(2, ErrorF("Mouse events %s\n", 
                        priv->mouse_enabled ? "enabled" : "disabled"));
                }
                break;
            case JSTK_MAPPING_DISABLE_KEYS:
                if (priv->button[number].pressed == 1) {
                    if (priv->keys_enabled == TRUE) 
                        priv->keys_enabled = FALSE;
                    else priv->keys_enabled = TRUE;
                    DBG(2, ErrorF("Keyboard events %s\n", 
                        priv->mouse_enabled ? "enabled" : "disabled"));
                }
                break;

            default:
                break;
            }
        }

        /* An axis was moved */
        if ((event == EVENT_AXIS) && 
            (priv->axis[number].type != JSTK_TYPE_NONE))
        {
            DBG(5, ErrorF("Axis %d moved to %d. Type: %d, Mapping: %d\n", 
                          number,
                          priv->axis[number].value,
                          priv->axis[number].type,
                          priv->axis[number].mapping));

            if (priv->axis[number].valuator != -1)
                xf86PostMotionEvent(pInfo->dev, 1, priv->axis[number].valuator,
                                    1, priv->axis[number].value);

            switch (priv->axis[number].mapping) {
            case JSTK_MAPPING_X:
            case JSTK_MAPPING_Y:
            case JSTK_MAPPING_ZX:
            case JSTK_MAPPING_ZY:
                switch (priv->axis[number].type) {
                case JSTK_TYPE_BYVALUE:
                case JSTK_TYPE_ACCELERATED:
                    if (priv->axis[number].value == 0)
                        priv->axis[number].currentspeed = 1.0;
                    if (priv->mouse_enabled == TRUE)
                        jstkStartAxisTimer(pInfo, number);
                    break;

                case JSTK_TYPE_ABSOLUTE:
                    if (priv->mouse_enabled == TRUE)
                        jstkHandleAbsoluteAxis(pInfo, number);
                    break;
                default:
                    break;
                } /* switch (priv->axis[number].type) */
                break; /* case JSTK_MAPPING_ZY */

            case JSTK_MAPPING_KEY: if (priv->keys_enabled == TRUE) {
                if (priv->axis[number].type == JSTK_TYPE_ACCELERATED) {
                    jstkHandlePWMAxis(pInfo, number);
                } else if (priv->axis[number].type == JSTK_TYPE_BYVALUE) {
                    jstkStartAxisTimer(pInfo, number);
                }
                break;
            }

            case JSTK_MAPPING_NONE:
            default:
                break;
            } /* switch (priv->axis[number].mapping) */
        } /* if (event == EVENT_AXIS) */
    } while (r == 2);
}





static void
jstkPtrCtrlProc(DeviceIntPtr device, PtrCtrl *ctrl)
{
    /* Nothing to do, dix handles all settings */
}


/*
 ***************************************************************************
 *
 * jstkDeviceControlProc --
 *
 * Handles the initialization, etc. of a joystick
 *
 ***************************************************************************
 */

static Bool
jstkDeviceControlProc(DeviceIntPtr       pJstk,
                      int                what)
{
    int i;
    InputInfoPtr     pInfo = (InputInfoPtr)pJstk->public.devicePrivate;
    JoystickDevPtr   priv  = pInfo->private;
    Atom             btn_labels[BUTTONMAP_SIZE+1] = {0}; /* TODO: fillme */
    Atom             axes_labels[MAXAXES] = {0}; /* TODO: fillme */

    switch (what) {
    case DEVICE_INIT: {
        int m;
        char str[32];
        CARD8 buttonmap[BUTTONMAP_SIZE+1];
        DBG(1, ErrorF("jstkDeviceControlProc what=INIT\n"));
        /* Probe device and return if error */
        if (jstkOpenDevice(priv, TRUE) == -1) {
            return !Success;
        } else {
            /* Success. The OpenDevice call already did some initialization
               like priv->num_buttons, priv->num_axes */
            priv->close_proc(priv);
        }

        for (m=0; m<=BUTTONMAP_SIZE; m++) {
            sprintf(str, "Button %d", m);

            buttonmap[m] = m;
            btn_labels[m] = MakeAtom(str, strlen(str), TRUE);
        }



        if (InitButtonClassDeviceStruct(pJstk, BUTTONMAP_SIZE, 
            btn_labels,
            buttonmap) == FALSE) {
            ErrorF("unable to allocate Button class device\n");
            return !Success;
        }
        if (!InitPtrFeedbackClassDeviceStruct(pJstk, jstkPtrCtrlProc))
            return !Success;

        m = 2;
        for (i=0; i<MAXAXES; i++) 
            if (priv->axis[i].valuator != -1)
        {
            DBG(3, ErrorF("Axis %d will be valuator %d\n", i, m));
            sprintf(str, "Axis %d", i + 1);
            priv->axis[i].valuator = m++;
            axes_labels[i] = MakeAtom(str, strlen(str), TRUE);
        }

        if (InitValuatorClassDeviceStruct(pJstk, m, axes_labels,
                                          GetMotionHistorySize(),
                                          Relative) == FALSE) {
            ErrorF("unable to allocate Valuator class device\n"); 
            return !Success;
        } else {
            InitValuatorAxisStruct(pJstk,
                                   0, /* valuator num */
                                   XIGetKnownProperty(AXIS_LABEL_PROP_REL_X),
                                   0, /* min val */
                                   screenInfo.screens[0]->width, /* max val */
                                   1, /* resolution */
                                   0, /* min_res */
                                   1, /* max_res */
                                   Absolute);
            InitValuatorAxisStruct(pJstk,
                                   1, /* valuator num */
                                   XIGetKnownProperty(AXIS_LABEL_PROP_REL_Y),
                                   0, /* min val */
                                   screenInfo.screens[0]->height, /* max val */
                                   1, /* resolution */
                                   0, /* min_res */
                                   1, /* max_res */
                                   Absolute);
            for (i=0; i<MAXAXES; i++) 
                if (priv->axis[i].valuator != -1)
            {
                InitValuatorAxisStruct(pJstk,
                                       priv->axis[i].valuator,
                                       axes_labels[i],
                                       -32768, /* min val */
                                       32767,  /* max val */
                                       1, /* resolution */
                                       0, /* min_res */
                                       1, /* max_res */
                                       Absolute);
            }
            /* allocate the motion history buffer if needed */
            xf86MotionHistoryAllocate(pInfo);
        }

	jstkInitProperties(pJstk, priv);

        break;
    }

    case DEVICE_ON:
        DBG(1, ErrorF("jstkDeviceControlProc  what=ON name=%s\n", 
                      priv->device));

        if (jstkOpenDevice(priv, FALSE) != -1) {
            pJstk->public.on = TRUE;
            pInfo->fd = priv->fd;
            xf86AddEnabledDevice(pInfo);
        } else return !Success;
        break;

    case DEVICE_OFF:
    case DEVICE_CLOSE:
        if (!pJstk->public.on)
            break;
        DBG(1, ErrorF("jstkDeviceControlProc  what=%s\n", 
            (what == DEVICE_CLOSE) ? "CLOSE" : "OFF"));

        if (priv->timerrunning == TRUE) {
            priv->timerrunning = FALSE;
            TimerCancel(priv->timer);
        }
        for (i = 0; i < MAXAXES; i++)
            if (priv->axis[i].timerrunning)
        {
            priv->axis[i].timerrunning = FALSE;
            TimerCancel(priv->axis[i].timer);
        }

        if (pInfo->fd >= 0)
            xf86RemoveEnabledDevice(pInfo);
        if (!(pInfo->flags & XI86_SERVER_FD))
            pInfo->fd = -1;
        if (priv->close_proc)
            priv->close_proc(priv);
        pJstk->public.on = FALSE;
        break;

#if GET_ABI_MAJOR(ABI_XINPUT_VERSION) * 100 + GET_ABI_MINOR(ABI_XINPUT_VERSION) >= 1901
    case DEVICE_ABORT:
        break;
#endif

    default:
        ErrorF("unsupported mode=%d\n", what);
        return BadValue;
    } /* switch (what) */
    return Success;
}

/*
 ***************************************************************************
 *
 * jstkCorePreInit --
 *
 * Called when a device will be instantiated
 *
 * This is a tad complicated. NewInputDeviceRequest(), which we use to
 * hotplug a keyboard device,. enables the device, so we need to make sure
 * that all options for the dependent device are set correctly.
 *
 * This means that we parse the keyboard-specific options into the
 * keyboard device's PreInit, and re-use the keyboard's priv field.
 *
 ***************************************************************************
 */

static int
jstkCorePreInit(InputDriverPtr drv, InputInfoPtr pInfo, int flags)
{
    InputInfoPtr        keyboard_device;
    JoystickDevPtr      priv = NULL;
    char                *s;
    int                 i, j;

    s = xf86CheckStrOption(pInfo->options, "_source", NULL);
    if (s && strcmp(s, "_driver/joystick") == 0)
        return jstkKeyboardPreInit(drv, pInfo, flags);

    pInfo->device_control = jstkDeviceControlProc;
    pInfo->read_input = jstkReadProc;
    pInfo->control_proc = NULL;
    pInfo->switch_mode = NULL;
    if (!(pInfo->flags & XI86_SERVER_FD))
        pInfo->fd = -1;
    pInfo->dev = NULL;
    pInfo->type_name = XI_JOYSTICK;

    keyboard_device = jstkKeyboardHotplug(pInfo, flags);
    if (!keyboard_device)
        return BadAlloc;

    pInfo->private = priv = keyboard_device->private;

    priv->fd = -1;
    priv->open_proc = NULL;
    priv->read_proc = NULL;
    priv->close_proc = NULL;
    priv->device = NULL;
    priv->devicedata = NULL;
    priv->timer = NULL;
    priv->timerrunning = FALSE;
    priv->mouse_enabled = TRUE;
    priv->keys_enabled = TRUE;
    priv->amplify = 1.0f;
    priv->joystick_device = pInfo;
    priv->keyboard_device = keyboard_device;
    priv->num_axes    = MAXAXES;
    priv->num_buttons = MAXBUTTONS;

    /* Initialize default mappings */
    for (i=0; i<MAXAXES; i++) {
        priv->axis[i].value        = 0;
        priv->axis[i].oldvalue     = 0;
        priv->axis[i].deadzone     = 5000;
        priv->axis[i].type         = JSTK_TYPE_NONE;
        priv->axis[i].mapping      = JSTK_MAPPING_NONE;
        priv->axis[i].currentspeed = 0.0f;
        priv->axis[i].amplify      = 1.0f;
        priv->axis[i].valuator     = -1;
        priv->axis[i].subpixel     = 0.0f;
        priv->axis[i].timer        = NULL;
        priv->axis[i].timerrunning = FALSE;
        priv->axis[i].key_isdown   = 0;
        for (j=0; j<MAXKEYSPERBUTTON; j++)
            priv->axis[i].keys_low[j] = priv->axis[i].keys_high[j] = 0;
    }
    for (i=0; i<MAXBUTTONS; i++) {
        priv->button[i].pressed      = 0;
        priv->button[i].buttonnumber = 0;
        priv->button[i].mapping      = JSTK_MAPPING_NONE;
        priv->button[i].currentspeed = 1.0f;
        priv->button[i].subpixel     = 0.0f;
        priv->button[i].amplify      = 1.0;
        for (j=0; j<MAXKEYSPERBUTTON; j++)
            priv->button[i].keys[j] = 0;
    }

    /* First three joystick buttons generate mouse clicks */
    priv->button[0].mapping      = JSTK_MAPPING_BUTTON;
    priv->button[0].buttonnumber = 1;
    priv->button[1].mapping      = JSTK_MAPPING_BUTTON;
    priv->button[1].buttonnumber = 2;
    priv->button[2].mapping      = JSTK_MAPPING_BUTTON;
    priv->button[2].buttonnumber = 3;

    /* First two axes are a stick for moving */
    priv->axis[0].type      = JSTK_TYPE_BYVALUE;
    priv->axis[0].mapping   = JSTK_MAPPING_X;
    priv->axis[1].type      = JSTK_TYPE_BYVALUE;
    priv->axis[1].mapping   = JSTK_MAPPING_Y;

    /* Next two axes are a stick for scrolling */
    priv->axis[2].type      = JSTK_TYPE_BYVALUE;
    priv->axis[2].mapping   = JSTK_MAPPING_ZX;
    priv->axis[3].type      = JSTK_TYPE_BYVALUE;
    priv->axis[3].mapping   = JSTK_MAPPING_ZY;

    /* Next two axes are a pad for moving */
    priv->axis[4].type      = JSTK_TYPE_ACCELERATED;
    priv->axis[4].mapping   = JSTK_MAPPING_X;
    priv->axis[5].type      = JSTK_TYPE_ACCELERATED;
    priv->axis[5].mapping   = JSTK_MAPPING_Y;

    /* Joystick device is mandatory */
    priv->device = xf86SetStrOption(pInfo->options, "Device", NULL);
    if (!priv->device)
        priv->device = xf86SetStrOption(pInfo->options, "Path", NULL);

    if (!priv->device) {
        xf86Msg (X_ERROR, "%s: No Device specified.\n", pInfo->name);
        goto SetupProc_fail;
    }

#if DEBUG
    debug_level = xf86SetIntOption(pInfo->options, "DebugLevel", 0);
    if (debug_level > 0) {
        xf86Msg(X_CONFIG, "%s: debug level set to %d\n", 
                pInfo->name, debug_level);
    }
#else
    if (xf86SetIntOption(pInfo->options, "DebugLevel", 0) != 0) {
        xf86Msg(X_WARNING, "%s: DebugLevel: Compiled without debugging support!\n", 
                pInfo->name);
    }
#endif

    priv->mouse_enabled = xf86SetBoolOption(pInfo->options, "StartMouseEnabled", TRUE);
    priv->keys_enabled = xf86SetBoolOption(pInfo->options, "StartKeysEnabled", TRUE);

    /* Process button mapping options */
    for (i=0; i<MAXBUTTONS; i++) {
        char p[64];
        sprintf(p,"MapButton%d",i+1);
        s = xf86SetStrOption(pInfo->options, p, NULL);
        if (s != NULL) {
            jstkParseButtonOption(s, priv, i, pInfo->name);
        }
        DBG(1, xf86Msg(X_CONFIG, "Button %d mapped to %d\n", i+1, 
                       priv->button[i].mapping));
    }

    /* Process button mapping options */
    for (i=0; i<MAXAXES; i++) {
        char p[64];
        sprintf(p,"MapAxis%d",i+1);
        s = xf86SetStrOption(pInfo->options, p, NULL);
        if (s != NULL) {
            jstkParseAxisOption(s, priv, &priv->axis[i], pInfo->name);
        }
        DBG(1, xf86Msg(X_CONFIG, 
                       "Axis %d type is %d, mapped to %d, amplify=%.3f\n", i+1, 
                       priv->axis[i].type,
                       priv->axis[i].mapping,
                       priv->axis[i].amplify));
    }

    return Success;

SetupProc_fail:
    if (priv) {
        free(priv);
        if (keyboard_device)
            keyboard_device->private = NULL;
    }
    if (pInfo)
        pInfo->private = NULL;
    return BadValue;
}



/*
 ***************************************************************************
 *
 * jstkCoreUnInit --
 *
 * Called when a device is unplugged and needs to be removed
 * This is a bit tricky, because the keyboard device and the main device
 * share the same private data, which must be freed only once, which is done
 * by the main device.
 * 
 *
 ***************************************************************************
 */

static void
jstkCoreUnInit(InputDriverPtr    drv,
               InputInfoPtr      pInfo,
               int               flags)
{
    if (pInfo->private) {
	JoystickDevPtr priv = (JoystickDevPtr) pInfo->private;
	if (priv->keyboard_device == pInfo) {
	    /* this is the keyboard device */
	    /* Unlink from private data to notify that the 
	     * keyboard device is no more, but don't free */
	    priv->keyboard_device = NULL;
	} else {
	    /* freeing main device
	       if keyboard still exists, notify keyboard device that it's
	       private data is gone */
	    if (priv->keyboard_device)
		priv->keyboard_device->private = NULL;
	    
	    free (priv);
	}
    }

    pInfo->private = NULL;
    xf86DeleteInput(pInfo, 0);
}




_X_EXPORT InputDriverRec JOYSTICK = {
    1,
    "joystick",
    NULL,
    jstkCorePreInit,
    jstkCoreUnInit,
    NULL,
    NULL,
#ifdef XI86_DRV_CAP_SERVER_FD
    XI86_DRV_CAP_SERVER_FD
#endif
};

/*
 ***************************************************************************
 *
 * jstkPlug --
 *
 * Called when the driver is loaded
 *
 ***************************************************************************
 */

static pointer
jstkDriverPlug(pointer  module,
               pointer  options,
               int      *errmaj,
               int      *errmin)
{
    xf86AddInputDriver(&JOYSTICK, module, 0);
    return module;
}


/*
 ***************************************************************************
 *
 * jstkDriverUnplug --
 *
 * Called when the driver is unloaded
 *
 ***************************************************************************
 */

static void
jstkDriverUnplug(pointer p)
{
}



/*
 ***************************************************************************
 *
 * Module information for X.Org
 *
 ***************************************************************************
 */
static XF86ModuleVersionInfo jstkVersionRec =
{
    "joystick",
    MODULEVENDORSTRING,
    MODINFOSTRING1,
    MODINFOSTRING2,
    XORG_VERSION_CURRENT,
    PACKAGE_VERSION_MAJOR,
    PACKAGE_VERSION_MINOR,
    PACKAGE_VERSION_PATCHLEVEL,
    ABI_CLASS_XINPUT,
    ABI_XINPUT_VERSION,
    MOD_CLASS_XINPUT,
    {0, 0, 0, 0}   /* signature, to be patched into the file by */
                   /* a tool */
};

/*
 ***************************************************************************
 *
 * Exported module Data for X.Org
 *
 ***************************************************************************
 */
_X_EXPORT XF86ModuleData joystickModuleData = {
    &jstkVersionRec,
    jstkDriverPlug,
    jstkDriverUnplug
};

/* vim: set filetype=c.doxygen ts=4 et: */
@


1.8
log
@Update to xf86-input-joystick 1.6.2
@
text
@d37 1
d83 3
d105 18
d150 1
a150 1
                RemoveEnabledDevice(pInfo->fd);
d417 1
a417 1
            AddEnabledDevice(pInfo->fd);
d440 3
a442 2
            RemoveEnabledDevice(pInfo->fd);
        pInfo->fd = -1;
d448 5
d493 2
a494 1
    pInfo->fd = -1;
d515 1
d692 5
a696 1
    NULL
a774 1

@


1.7
log
@Update to xf86-input-joystick 1.6.1
@
text
@d457 2
a458 2
    s = xf86CheckStrOption(pInfo->options, "_source", "");
    if (strcmp(s, "_driver/joystick") == 0)
@


1.6
log
@Update to xf86-input-joystick 1.6.0 for good now.
@
text
@d2 1
a2 1
 * Copyright 2007-2009 by Sascha Hlusiak. <saschahlusiak@@freedesktop.org>     
a23 1

d302 1
d315 2
d318 4
a321 1
	}
a322 2
            
            
d337 1
d339 1
d427 1
a427 2
        return !Success;
        break;
a726 1

d739 3
@


1.5
log
@Revert update to xf86-input-joystick 1.6.0.
This driver depends on xserver 1.10.
@
text
@d29 1
d48 1
a48 3
#if GET_ABI_MAJOR(ABI_XINPUT_VERSION) >= 3
    #include <xserver-properties.h>
#endif
a64 34

/*
 ***************************************************************************
 *
 * jstkConvertProc --
 *
 * Convert valuators to X and Y.
 *
 ***************************************************************************
 */

static Bool
jstkConvertProc(LocalDevicePtr	local,
                int             first,
                int             num,
                int             v0,
                int             v1,
                int             v2,
                int             v3,
                int             v4,
                int             v5,
                int*            x,
                int*            y)
{
    if (first != 0 || num != 2)
        return FALSE;

    *x = v0;
    *y = v1;

    return TRUE;
}


d115 1
a115 1
jstkReadProc(LocalDevicePtr local)
d121 1
a121 1
    JoystickDevPtr priv = local->private;
d128 2
a129 2
            if (local->fd >= 0)
                RemoveEnabledDevice(local->fd);
d142 1
a142 1
                    xf86PostButtonEvent(local->dev, 0,
d155 1
a155 1
                    jstkStartButtonAxisTimer(local, number);
d226 1
a226 1
                xf86PostMotionEvent(local->dev, 1, priv->axis[number].valuator, 
d240 1
a240 1
                        jstkStartAxisTimer(local, number);
d245 1
a245 1
                        jstkHandleAbsoluteAxis(local, number);
d254 1
a254 1
                    jstkHandlePWMAxis(local, number);
d256 1
a256 1
                    jstkStartAxisTimer(local, number);
d295 2
a296 3
    LocalDevicePtr   local = (LocalDevicePtr)pJstk->public.devicePrivate;
    JoystickDevPtr   priv  = (JoystickDevPtr)XI_PRIVATE(pJstk);
#if GET_ABI_MAJOR(ABI_XINPUT_VERSION) >= 7
a298 1
#endif
a320 1
#if GET_ABI_MAJOR(ABI_XINPUT_VERSION) >= 7
a321 1
#endif
d337 2
a338 9
        if (InitValuatorClassDeviceStruct(pJstk, 
                                          m,
#if GET_ABI_MAJOR(ABI_XINPUT_VERSION) >= 7
                                          axes_labels,
#endif
#if GET_ABI_MAJOR(ABI_XINPUT_VERSION) < 3
                                          xf86GetMotionEvents, 
#endif
                                          local->history_size,
a344 1
#if GET_ABI_MAJOR(ABI_XINPUT_VERSION) >= 7
a345 1
#endif
d350 2
a351 1
                                   1); /* max_res */
a353 1
#if GET_ABI_MAJOR(ABI_XINPUT_VERSION) >= 7
a354 1
#endif
d359 2
a360 1
                                   1); /* max_res */
a365 1
#if GET_ABI_MAJOR(ABI_XINPUT_VERSION) >= 7
a366 1
#endif
d371 2
a372 1
                                       1); /* max_res */
d375 1
a375 1
            xf86MotionHistoryAllocate(local);
a377 12

        if (priv->keyboard_device != NULL)
        {
            DBG(2, ErrorF("Activating keyboard device\n"));
            xf86ActivateDevice(priv->keyboard_device);
            priv->keyboard_device->dev->inited = 
                (priv->keyboard_device->device_control(priv->keyboard_device->dev, DEVICE_INIT) == Success);
            xf86EnableDevice(priv->keyboard_device->dev);
            DBG(2, ErrorF("Keyboard device activated\n"));
        }

#if GET_ABI_MAJOR(ABI_XINPUT_VERSION) >= 3
a378 1
#endif
d389 2
a390 2
            local->fd = priv->fd;
            AddEnabledDevice(local->fd);
d412 3
a414 3
        if (local->fd >= 0)
            RemoveEnabledDevice(local->fd);
        local->fd = -1;
a427 13



_X_EXPORT InputDriverRec JSTK_KEYBOARD = {
    1,
    "joystick_keyboard",
    NULL,
    jstkKeyboardPreInit,
    jstkKeyboardUnInit,
    NULL,
    0
};

d435 7
d445 2
a446 2
static InputInfoPtr
jstkCorePreInit(InputDriverPtr drv, IDevPtr dev, int flags)
d448 1
a448 1
    LocalDevicePtr      local = NULL;
d453 15
a467 7
    local = xf86AllocateInput(drv, 0);
    if (!local) {
        goto SetupProc_fail;
    }

    local->private = (JoystickDevPtr)xalloc(sizeof(JoystickDevRec));
    priv = (JoystickDevPtr)local->private;
d469 1
a469 16
    local->name   = dev->identifier;
    local->flags  = XI86_POINTER_CAPABLE;
    local->flags |= XI86_SEND_DRAG_EVENTS;
    local->device_control = jstkDeviceControlProc;
    local->read_input = jstkReadProc;
    local->close_proc = NULL;
    local->control_proc = NULL;
    local->switch_mode = NULL;
    local->conversion_proc = jstkConvertProc;
    local->fd = -1;
    local->dev = NULL;
    local->private = priv;
    local->type_name = XI_JOYSTICK;
    local->history_size = 0;
    local->always_core_feedback = NULL;
    local->conf_idev = dev;
d482 1
a482 3
    priv->keyboard_device = NULL;
    priv->repeat_delay = 0;
    priv->repeat_interval = 0;
a539 3
    xf86CollectInputOptions(local, NULL, NULL);
    xf86OptionListReport(local->options);

d541 1
a541 1
    priv->device = xf86SetStrOption(dev->commonOptions, "Device", NULL);
d543 1
a543 1
        priv->device = xf86SetStrOption(dev->commonOptions, "Path", NULL);
d546 1
a546 1
        xf86Msg (X_ERROR, "%s: No Device specified.\n", local->name);
a549 2
    xf86ProcessCommonOptions(local, local->options);

d551 1
a551 1
    debug_level = xf86SetIntOption(dev->commonOptions, "DebugLevel", 0);
d554 1
a554 1
                local->name, debug_level);
d557 1
a557 1
    if (xf86SetIntOption(dev->commonOptions, "DebugLevel", 0) != 0) {
d559 1
a559 1
                local->name);
d563 2
a564 39
    /* Parse option for autorepeat */
    if ((s = xf86SetStrOption(dev->commonOptions, "AutoRepeat", NULL))) {
        int delay, rate;
        if (sscanf(s, "%d %d", &delay, &rate) != 2) {
            xf86Msg(X_ERROR, "%s: \"%s\" is not a valid AutoRepeat value", 
                    local->name, s);
        } else {
            priv->repeat_delay = delay;
            if (rate != 0)
                priv->repeat_interval = 1000/rate;
            else priv->repeat_interval = 0;
            DBG(1, xf86Msg(X_CONFIG, "Autorepeat set to delay=%d, interval=%d\n",
                           priv->repeat_delay,priv->repeat_interval));
        }
        xfree(s);
    }
    
    priv->rmlvo.rules = xf86SetStrOption(dev->commonOptions, "xkb_rules", NULL);
    if (!priv->rmlvo.rules)
	priv->rmlvo.rules = xf86SetStrOption(dev->commonOptions, "XkbRules", "evdev");

    priv->rmlvo.model = xf86SetStrOption(dev->commonOptions, "xkb_model", NULL);
    if (!priv->rmlvo.model)
	priv->rmlvo.model = xf86SetStrOption(dev->commonOptions, "XkbModel", "evdev");

    priv->rmlvo.layout = xf86SetStrOption(dev->commonOptions, "xkb_layout", NULL);
    if (!priv->rmlvo.layout)
	priv->rmlvo.layout = xf86SetStrOption(dev->commonOptions, "XkbLayout", "us");

    priv->rmlvo.variant = xf86SetStrOption(dev->commonOptions, "xkb_variant", NULL);
    if (!priv->rmlvo.variant)
	priv->rmlvo.variant = xf86SetStrOption(dev->commonOptions, "XkbVariant", "");

    priv->rmlvo.options = xf86SetStrOption(dev->commonOptions, "xkb_options", NULL);
    if (!priv->rmlvo.options)
	priv->rmlvo.options = xf86SetStrOption(dev->commonOptions, "XkbOptions", "");

    priv->mouse_enabled = xf86SetBoolOption(dev->commonOptions, "StartMouseEnabled", TRUE);
    priv->keys_enabled = xf86SetBoolOption(dev->commonOptions, "StartKeysEnabled", TRUE);
d570 1
a570 1
        s = xf86SetStrOption(dev->commonOptions, p, NULL);
d572 1
a572 1
            jstkParseButtonOption(s, priv, i, local->name);
d582 1
a582 1
        s = xf86SetStrOption(dev->commonOptions, p, NULL);
d584 1
a584 1
            jstkParseAxisOption(s, priv, &priv->axis[i], local->name);
d593 1
a593 9
    /* return the LocalDevice */
    local->flags |= XI86_CONFIGURED;

    priv->keyboard_device = jstkKeyboardPreInit(&JSTK_KEYBOARD, dev, flags);
    if (priv->keyboard_device) {
        priv->keyboard_device->private = priv;
    }

    return (local);
d596 8
a603 6
    if (priv)
        xfree(priv);
    if (local)
        local->private = NULL;
    return NULL;
/*    return (local); */ /* Makes X segfault on error */
d614 4
d624 1
a624 1
               LocalDevicePtr    local,
d627 16
a642 6
    JoystickDevPtr device = (JoystickDevPtr) local->private;

    if (device->keyboard_device != NULL)
    {
        xf86DisableDevice(device->keyboard_device->dev, TRUE);
        device->keyboard_device = NULL;
d645 2
a646 3
    xfree (device);
    local->private = NULL;
    xf86DeleteInput(local, 0);
d658 1
a658 2
    NULL,
    0
a660 1

a677 1
    xf86AddInputDriver(&JSTK_KEYBOARD, module, 0);
@


1.4
log
@Update to xf86-input-joystick 1.6.0
@
text
@a28 1
#include <xorg-server.h>
d47 3
a49 1
#include <xserver-properties.h>
d66 34
d150 1
a150 1
jstkReadProc(InputInfoPtr pInfo)
d156 1
a156 1
    JoystickDevPtr priv = pInfo->private;
d163 2
a164 2
            if (pInfo->fd >= 0)
                RemoveEnabledDevice(pInfo->fd);
d177 1
a177 1
                    xf86PostButtonEvent(pInfo->dev, 0,
d190 1
a190 1
                    jstkStartButtonAxisTimer(pInfo, number);
d261 1
a261 1
                xf86PostMotionEvent(pInfo->dev, 1, priv->axis[number].valuator,
d275 1
a275 1
                        jstkStartAxisTimer(pInfo, number);
d280 1
a280 1
                        jstkHandleAbsoluteAxis(pInfo, number);
d289 1
a289 1
                    jstkHandlePWMAxis(pInfo, number);
d291 1
a291 1
                    jstkStartAxisTimer(pInfo, number);
d330 3
a332 2
    InputInfoPtr     pInfo = (InputInfoPtr)pJstk->public.devicePrivate;
    JoystickDevPtr   priv  = pInfo->private;
d335 1
d358 1
d360 1
d376 9
a384 2
        if (InitValuatorClassDeviceStruct(pJstk, m, axes_labels,
                                          GetMotionHistorySize(),
d391 1
d393 1
d398 1
a398 2
                                   1, /* max_res */
                                   Absolute);
d401 1
d403 1
d408 1
a408 2
                                   1, /* max_res */
                                   Absolute);
d414 1
d416 1
d421 1
a421 2
                                       1, /* max_res */
                                       Absolute);
d424 1
a424 1
            xf86MotionHistoryAllocate(pInfo);
d427 12
d440 1
d451 2
a452 2
            pInfo->fd = priv->fd;
            AddEnabledDevice(pInfo->fd);
d474 3
a476 3
        if (pInfo->fd >= 0)
            RemoveEnabledDevice(pInfo->fd);
        pInfo->fd = -1;
d490 13
a509 7
 * This is a tad complicated. NewInputDeviceRequest(), which we use to
 * hotplug a keyboard device,. enables the device, so we need to make sure
 * that all options for the dependent device are set correctly.
 *
 * This means that we parse the keyboard-specific options into the
 * keyboard device's PreInit, and re-use the keyboard's priv field.
 *
d513 2
a514 2
static int
jstkCorePreInit(InputDriverPtr drv, InputInfoPtr pInfo, int flags)
d516 1
a516 1
    InputInfoPtr        keyboard_device;
d521 7
a527 15
    s = xf86CheckStrOption(pInfo->options, "_source", "");
    if (strcmp(s, "_driver/joystick") == 0)
        return jstkKeyboardPreInit(drv, pInfo, flags);

    pInfo->device_control = jstkDeviceControlProc;
    pInfo->read_input = jstkReadProc;
    pInfo->control_proc = NULL;
    pInfo->switch_mode = NULL;
    pInfo->fd = -1;
    pInfo->dev = NULL;
    pInfo->type_name = XI_JOYSTICK;

    keyboard_device = jstkKeyboardHotplug(pInfo, flags);
    if (!keyboard_device)
        return BadAlloc;
d529 16
a544 1
    pInfo->private = priv = keyboard_device->private;
d557 3
a559 1
    priv->keyboard_device = keyboard_device;
d617 3
d621 1
a621 1
    priv->device = xf86SetStrOption(pInfo->options, "Device", NULL);
d623 1
a623 1
        priv->device = xf86SetStrOption(pInfo->options, "Path", NULL);
d626 1
a626 1
        xf86Msg (X_ERROR, "%s: No Device specified.\n", pInfo->name);
d630 2
d633 1
a633 1
    debug_level = xf86SetIntOption(pInfo->options, "DebugLevel", 0);
d636 1
a636 1
                pInfo->name, debug_level);
d639 1
a639 1
    if (xf86SetIntOption(pInfo->options, "DebugLevel", 0) != 0) {
d641 1
a641 1
                pInfo->name);
d645 39
a683 2
    priv->mouse_enabled = xf86SetBoolOption(pInfo->options, "StartMouseEnabled", TRUE);
    priv->keys_enabled = xf86SetBoolOption(pInfo->options, "StartKeysEnabled", TRUE);
d689 1
a689 1
        s = xf86SetStrOption(pInfo->options, p, NULL);
d691 1
a691 1
            jstkParseButtonOption(s, priv, i, pInfo->name);
d701 1
a701 1
        s = xf86SetStrOption(pInfo->options, p, NULL);
d703 1
a703 1
            jstkParseAxisOption(s, priv, &priv->axis[i], pInfo->name);
d712 9
a720 1
    return Success;
d723 6
a728 8
    if (priv) {
        free(priv);
        if (keyboard_device)
            keyboard_device->private = NULL;
    }
    if (pInfo)
        pInfo->private = NULL;
    return BadValue;
a738 4
 * This is a bit tricky, because the keyboard device and the main device
 * share the same private data, which must be freed only once, which is done
 * by the main device.
 * 
d745 1
a745 1
               InputInfoPtr      pInfo,
d748 6
a753 16
    if (pInfo->private) {
	JoystickDevPtr priv = (JoystickDevPtr) pInfo->private;
	if (priv->keyboard_device == pInfo) {
	    /* this is the keyboard device */
	    /* Unlink from private data to notify that the 
	     * keyboard device is no more, but don't free */
	    priv->keyboard_device = NULL;
	} else {
	    /* freeing main device
	       if keyboard still exists, notify keyboard device that it's
	       private data is gone */
	    if (priv->keyboard_device)
		priv->keyboard_device->private = NULL;
	    
	    free (priv);
	}
d756 3
a758 2
    pInfo->private = NULL;
    xf86DeleteInput(pInfo, 0);
d770 2
a771 1
    NULL
d774 1
d792 1
@


1.3
log
@Update to xf86-input-joystick 1.5.0
@
text
@d29 1
d48 1
a48 3
#if GET_ABI_MAJOR(ABI_XINPUT_VERSION) >= 3
    #include <xserver-properties.h>
#endif
a64 34

/*
 ***************************************************************************
 *
 * jstkConvertProc --
 *
 * Convert valuators to X and Y.
 *
 ***************************************************************************
 */

static Bool
jstkConvertProc(LocalDevicePtr	local,
                int             first,
                int             num,
                int             v0,
                int             v1,
                int             v2,
                int             v3,
                int             v4,
                int             v5,
                int*            x,
                int*            y)
{
    if (first != 0 || num != 2)
        return FALSE;

    *x = v0;
    *y = v1;

    return TRUE;
}


d115 1
a115 1
jstkReadProc(LocalDevicePtr local)
d121 1
a121 1
    JoystickDevPtr priv = local->private;
d128 2
a129 2
            if (local->fd >= 0)
                RemoveEnabledDevice(local->fd);
d142 1
a142 1
                    xf86PostButtonEvent(local->dev, 0,
d155 1
a155 1
                    jstkStartButtonAxisTimer(local, number);
d226 1
a226 1
                xf86PostMotionEvent(local->dev, 1, priv->axis[number].valuator, 
d240 1
a240 1
                        jstkStartAxisTimer(local, number);
d245 1
a245 1
                        jstkHandleAbsoluteAxis(local, number);
d254 1
a254 1
                    jstkHandlePWMAxis(local, number);
d256 1
a256 1
                    jstkStartAxisTimer(local, number);
d295 2
a296 3
    LocalDevicePtr   local = (LocalDevicePtr)pJstk->public.devicePrivate;
    JoystickDevPtr   priv  = (JoystickDevPtr)XI_PRIVATE(pJstk);
#if GET_ABI_MAJOR(ABI_XINPUT_VERSION) >= 7
a298 1
#endif
a320 1
#if GET_ABI_MAJOR(ABI_XINPUT_VERSION) >= 7
a321 1
#endif
d337 2
a338 9
        if (InitValuatorClassDeviceStruct(pJstk, 
                                          m,
#if GET_ABI_MAJOR(ABI_XINPUT_VERSION) >= 7
                                          axes_labels,
#endif
#if GET_ABI_MAJOR(ABI_XINPUT_VERSION) < 3
                                          xf86GetMotionEvents, 
#endif
                                          local->history_size,
a344 1
#if GET_ABI_MAJOR(ABI_XINPUT_VERSION) >= 7
a345 1
#endif
d350 2
a351 1
                                   1); /* max_res */
a353 1
#if GET_ABI_MAJOR(ABI_XINPUT_VERSION) >= 7
a354 1
#endif
d359 2
a360 1
                                   1); /* max_res */
a365 1
#if GET_ABI_MAJOR(ABI_XINPUT_VERSION) >= 7
a366 1
#endif
d371 2
a372 1
                                       1); /* max_res */
d375 1
a375 1
            xf86MotionHistoryAllocate(local);
a377 12

        if (priv->keyboard_device != NULL)
        {
            DBG(2, ErrorF("Activating keyboard device\n"));
            xf86ActivateDevice(priv->keyboard_device);
            priv->keyboard_device->dev->inited = 
                (priv->keyboard_device->device_control(priv->keyboard_device->dev, DEVICE_INIT) == Success);
            xf86EnableDevice(priv->keyboard_device->dev);
            DBG(2, ErrorF("Keyboard device activated\n"));
        }

#if GET_ABI_MAJOR(ABI_XINPUT_VERSION) >= 3
a378 1
#endif
d389 2
a390 2
            local->fd = priv->fd;
            AddEnabledDevice(local->fd);
d412 3
a414 3
        if (local->fd >= 0)
            RemoveEnabledDevice(local->fd);
        local->fd = -1;
a427 13



_X_EXPORT InputDriverRec JSTK_KEYBOARD = {
    1,
    "joystick_keyboard",
    NULL,
    jstkKeyboardPreInit,
    jstkKeyboardUnInit,
    NULL,
    0
};

d435 7
d445 2
a446 2
static InputInfoPtr
jstkCorePreInit(InputDriverPtr drv, IDevPtr dev, int flags)
d448 1
a448 1
    LocalDevicePtr      local = NULL;
d453 15
a467 7
    local = xf86AllocateInput(drv, 0);
    if (!local) {
        goto SetupProc_fail;
    }

    local->private = (JoystickDevPtr)xalloc(sizeof(JoystickDevRec));
    priv = (JoystickDevPtr)local->private;
d469 1
a469 16
    local->name   = dev->identifier;
    local->flags  = XI86_POINTER_CAPABLE;
    local->flags |= XI86_SEND_DRAG_EVENTS;
    local->device_control = jstkDeviceControlProc;
    local->read_input = jstkReadProc;
    local->close_proc = NULL;
    local->control_proc = NULL;
    local->switch_mode = NULL;
    local->conversion_proc = jstkConvertProc;
    local->fd = -1;
    local->dev = NULL;
    local->private = priv;
    local->type_name = XI_JOYSTICK;
    local->history_size = 0;
    local->always_core_feedback = NULL;
    local->conf_idev = dev;
d482 1
a482 3
    priv->keyboard_device = NULL;
    priv->repeat_delay = 0;
    priv->repeat_interval = 0;
a539 3
    xf86CollectInputOptions(local, NULL, NULL);
    xf86OptionListReport(local->options);

d541 1
a541 1
    priv->device = xf86SetStrOption(dev->commonOptions, "Device", NULL);
d543 1
a543 1
        priv->device = xf86SetStrOption(dev->commonOptions, "Path", NULL);
d546 1
a546 1
        xf86Msg (X_ERROR, "%s: No Device specified.\n", local->name);
a549 2
    xf86ProcessCommonOptions(local, local->options);

d551 1
a551 1
    debug_level = xf86SetIntOption(dev->commonOptions, "DebugLevel", 0);
d554 1
a554 1
                local->name, debug_level);
d557 1
a557 1
    if (xf86SetIntOption(dev->commonOptions, "DebugLevel", 0) != 0) {
d559 1
a559 1
                local->name);
d563 2
a564 39
    /* Parse option for autorepeat */
    if ((s = xf86SetStrOption(dev->commonOptions, "AutoRepeat", NULL))) {
        int delay, rate;
        if (sscanf(s, "%d %d", &delay, &rate) != 2) {
            xf86Msg(X_ERROR, "%s: \"%s\" is not a valid AutoRepeat value", 
                    local->name, s);
        } else {
            priv->repeat_delay = delay;
            if (rate != 0)
                priv->repeat_interval = 1000/rate;
            else priv->repeat_interval = 0;
            DBG(1, xf86Msg(X_CONFIG, "Autorepeat set to delay=%d, interval=%d\n",
                           priv->repeat_delay,priv->repeat_interval));
        }
        xfree(s);
    }
    
    priv->rmlvo.rules = xf86SetStrOption(dev->commonOptions, "xkb_rules", NULL);
    if (!priv->rmlvo.rules)
	priv->rmlvo.rules = xf86SetStrOption(dev->commonOptions, "XkbRules", "evdev");

    priv->rmlvo.model = xf86SetStrOption(dev->commonOptions, "xkb_model", NULL);
    if (!priv->rmlvo.model)
	priv->rmlvo.model = xf86SetStrOption(dev->commonOptions, "XkbModel", "evdev");

    priv->rmlvo.layout = xf86SetStrOption(dev->commonOptions, "xkb_layout", NULL);
    if (!priv->rmlvo.layout)
	priv->rmlvo.layout = xf86SetStrOption(dev->commonOptions, "XkbLayout", "us");

    priv->rmlvo.variant = xf86SetStrOption(dev->commonOptions, "xkb_variant", NULL);
    if (!priv->rmlvo.variant)
	priv->rmlvo.variant = xf86SetStrOption(dev->commonOptions, "XkbVariant", "");

    priv->rmlvo.options = xf86SetStrOption(dev->commonOptions, "xkb_options", NULL);
    if (!priv->rmlvo.options)
	priv->rmlvo.options = xf86SetStrOption(dev->commonOptions, "XkbOptions", "");

    priv->mouse_enabled = xf86SetBoolOption(dev->commonOptions, "StartMouseEnabled", TRUE);
    priv->keys_enabled = xf86SetBoolOption(dev->commonOptions, "StartKeysEnabled", TRUE);
d570 1
a570 1
        s = xf86SetStrOption(dev->commonOptions, p, NULL);
d572 1
a572 1
            jstkParseButtonOption(s, priv, i, local->name);
d582 1
a582 1
        s = xf86SetStrOption(dev->commonOptions, p, NULL);
d584 1
a584 1
            jstkParseAxisOption(s, priv, &priv->axis[i], local->name);
d593 1
a593 9
    /* return the LocalDevice */
    local->flags |= XI86_CONFIGURED;

    priv->keyboard_device = jstkKeyboardPreInit(&JSTK_KEYBOARD, dev, flags);
    if (priv->keyboard_device) {
        priv->keyboard_device->private = priv;
    }

    return (local);
d596 8
a603 6
    if (priv)
        xfree(priv);
    if (local)
        local->private = NULL;
    return NULL;
/*    return (local); */ /* Makes X segfault on error */
d614 4
d624 1
a624 1
               LocalDevicePtr    local,
d627 16
a642 6
    JoystickDevPtr device = (JoystickDevPtr) local->private;

    if (device->keyboard_device != NULL)
    {
        xf86DisableDevice(device->keyboard_device->dev, TRUE);
        device->keyboard_device = NULL;
d645 2
a646 3
    xfree (device);
    local->private = NULL;
    xf86DeleteInput(local, 0);
d658 1
a658 2
    NULL,
    0
a660 1

a677 1
    xf86AddInputDriver(&JSTK_KEYBOARD, module, 0);
@


1.2
log
@update to xf86-input-joystick 1.4.1
@
text
@d2 1
a2 1
 * Copyright 2007-2008 by Sascha Hlusiak. <saschahlusiak@@freedesktop.org>     
d47 3
d332 4
d351 1
a351 1
        for (m=0; m<=BUTTONMAP_SIZE; m++)
d353 4
d358 3
d378 3
d391 3
d401 3
d414 3
a557 2
    priv->keymap.size = 1;
    memset(priv->keymap.map, NoSymbol, sizeof(priv->keymap.map));
d661 20
@


1.1
log
@xf86-input joystick 1.3.2
@
text
@d30 1
a30 1
#include <xf86Version.h>
d36 1
d46 1
d60 1
a60 1
    int debug_level = 0;
d110 1
a110 1
jstkOpenDevice(JoystickDevPtr priv)
d115 3
d120 1
a120 1
        fd = jstkOpenDevice_evdev(priv);
d124 1
a124 1
        fd = jstkOpenDevice_joystick(priv);
d128 1
a128 1
        fd = jstkOpenDevice_bsd(priv);
d172 1
a172 1
            case MAPPING_BUTTON:
d174 1
a174 1
                    xf86PostButtonEvent(local->dev, 0, 
d180 4
a183 4
            case MAPPING_X:
            case MAPPING_Y:
            case MAPPING_ZX:
            case MAPPING_ZY:
d190 1
a190 1
            case MAPPING_KEY:
d192 1
a192 1
                    jstkGenerateKeys(local->dev, 
d197 1
a197 1
            case MAPPING_SPEED_MULTIPLY:
d202 1
a202 1
                        (priv->button[i].mapping == MAPPING_SPEED_MULTIPLY))
d208 1
a208 1
            case MAPPING_DISABLE:
d223 1
a223 1
            case MAPPING_DISABLE_MOUSE:
d232 1
a232 1
            case MAPPING_DISABLE_KEYS:
d249 1
a249 1
            (priv->axis[number].type != TYPE_NONE))
d262 4
a265 4
            case MAPPING_X:
            case MAPPING_Y:
            case MAPPING_ZX:
            case MAPPING_ZY:
d267 2
a268 2
                case TYPE_BYVALUE:
                case TYPE_ACCELERATED:
d275 1
a275 1
                case TYPE_ABSOLUTE:
d282 1
a282 1
                break; /* case MAPPING_ZY */
d284 5
a288 16
            case MAPPING_KEY: if (priv->keys_enabled == TRUE) {
                if (priv->axis[number].type == TYPE_ACCELERATED) {
                    if ((priv->axis[number].value > 0) != 
                        (priv->axis[number].oldvalue > 0))
                        jstkGenerateKeys(local->dev, 
                                         priv->axis[number].keys_high,
                                         (priv->axis[number].value > 0) ? 1:0);

                    if ((priv->axis[number].value < 0) != 
                        (priv->axis[number].oldvalue < 0))
                        jstkGenerateKeys(local->dev,
                                         priv->axis[number].keys_low,
                                         (priv->axis[number].value < 0) ? 1:0);
                } else if (priv->axis[number].type == TYPE_BYVALUE) {
                    if (priv->keys_enabled == TRUE)
                        jstkStartAxisTimer(local, number);
d293 1
a293 1
            case MAPPING_NONE:
d303 9
d333 1
d335 15
a349 11
        /* We want the first 7 button numbers fixed */
        if (priv->buttonmap.size != 0) {
            if (InitButtonClassDeviceStruct(pJstk, priv->buttonmap.size, 
                priv->buttonmap.map) == FALSE) {
                ErrorF("unable to allocate Button class device\n");
                return !Success;
            }
            if (InitFocusClassDeviceStruct(pJstk) == FALSE) {
                ErrorF("unable to init Focus class device\n");
                return !Success;
            }
d351 2
a352 1
        jstkInitKeys(pJstk, priv);
d356 5
a360 2
            if (priv->axis[i].type != TYPE_NONE)
                priv->axis[i].valuator = m++;
d364 1
d366 1
d387 1
a387 1
                if (priv->axis[i].type != TYPE_NONE)
d400 16
d423 1
a423 1
        if (jstkOpenDevice(priv) != -1) {
d441 6
d466 11
a504 1
    local->flags |= XI86_KEYBOARD_CAPABLE;
d515 1
a515 1
    local->type_name = XI_MOUSE;
d517 1
a517 1
    local->always_core_feedback = 0;
d521 3
d531 1
a531 1
    priv->buttonmap.size = 0;
d536 2
d544 2
a545 2
        priv->axis[i].type         = TYPE_NONE;
        priv->axis[i].mapping      = MAPPING_NONE;
d550 3
d559 1
a559 1
        priv->button[i].mapping      = MAPPING_NONE;
d562 1
a566 2
    priv->buttonmap.map[0] = 0;

d568 6
a573 6
    priv->button[0].mapping      = MAPPING_BUTTON;
    priv->button[0].buttonnumber = jstkGetButtonNumberInMap(priv, 1);
    priv->button[1].mapping      = MAPPING_BUTTON;
    priv->button[1].buttonnumber = jstkGetButtonNumberInMap(priv, 2);
    priv->button[2].mapping      = MAPPING_BUTTON;
    priv->button[2].buttonnumber = jstkGetButtonNumberInMap(priv, 3);
d576 4
a579 4
    priv->axis[0].type      = TYPE_BYVALUE;
    priv->axis[0].mapping   = MAPPING_X;
    priv->axis[1].type      = TYPE_BYVALUE;
    priv->axis[1].mapping   = MAPPING_Y;
d582 4
a585 4
    priv->axis[2].type      = TYPE_BYVALUE;
    priv->axis[2].mapping   = MAPPING_ZX;
    priv->axis[3].type      = TYPE_BYVALUE;
    priv->axis[3].mapping   = MAPPING_ZY;
d588 4
a591 10
    priv->axis[4].type      = TYPE_ACCELERATED;
    priv->axis[4].mapping   = MAPPING_X;
    priv->axis[5].type      = TYPE_ACCELERATED;
    priv->axis[5].mapping   = MAPPING_Y;

    priv->buttonmap.scrollbutton[0] = jstkGetButtonNumberInMap(priv, 4);
    priv->buttonmap.scrollbutton[1] = jstkGetButtonNumberInMap(priv, 5);
    priv->buttonmap.scrollbutton[2] = jstkGetButtonNumberInMap(priv, 6);
    priv->buttonmap.scrollbutton[3] = jstkGetButtonNumberInMap(priv, 7);

d671 5
d706 5
a710 1
    jstkDeviceControlProc(local->dev, DEVICE_OFF);
d748 1
@

