head	1.36;
access;
symbols
	OPENBSD_6_2:1.36.0.14
	OPENBSD_6_2_BASE:1.36
	OPENBSD_6_1:1.36.0.12
	OPENBSD_6_1_BASE:1.36
	OPENBSD_6_0:1.36.0.10
	OPENBSD_6_0_BASE:1.36
	OPENBSD_5_9:1.36.0.8
	OPENBSD_5_9_BASE:1.36
	OPENBSD_5_8:1.36.0.6
	OPENBSD_5_8_BASE:1.36
	OPENBSD_5_7:1.36.0.4
	OPENBSD_5_7_BASE:1.36
	OPENBSD_5_6:1.36.0.2
	OPENBSD_5_6_BASE:1.36
	OPENBSD_5_5:1.31.0.2
	OPENBSD_5_5_BASE:1.31
	OPENBSD_5_4:1.30.0.2
	OPENBSD_5_4_BASE:1.30
	OPENBSD_5_3:1.28.0.2
	OPENBSD_5_3_BASE:1.28
	OPENBSD_5_2:1.27.0.4
	OPENBSD_5_2_BASE:1.27
	OPENBSD_5_1_BASE:1.27
	OPENBSD_5_1:1.27.0.2
	OPENBSD_5_0:1.23.0.4
	OPENBSD_5_0_BASE:1.23
	OPENBSD_4_9:1.23.0.2
	OPENBSD_4_9_BASE:1.23
	OPENBSD_4_8:1.22.0.4
	OPENBSD_4_8_BASE:1.22
	OPENBSD_4_7:1.20.0.2
	OPENBSD_4_7_BASE:1.20
	OPENBSD_4_6:1.15.0.2
	OPENBSD_4_6_BASE:1.15
	OPENBSD_4_5:1.14.0.2
	OPENBSD_4_5_BASE:1.14
	OPENBSD_4_4:1.13.0.4
	OPENBSD_4_4_BASE:1.13
	OPENBSD_4_3_BASE:1.13
	OPENBSD_4_3:1.13.0.2
	OPENBSD_4_2:1.10.0.2
	OPENBSD_4_2_BASE:1.10
	v0_2_1:1.1.1.2
	v0_2_0:1.1.1.1
	xorg:1.1.1;
locks; strict;
comment	@ * @;


1.36
date	2014.07.13.15.12.53;	author matthieu;	state Exp;
branches;
next	1.35;
commitid	eA01jAXUobuGEUSu;

1.35
date	2014.07.13.14.09.14;	author matthieu;	state Exp;
branches;
next	1.34;
commitid	IPa3perpWim23LPW;

1.34
date	2014.07.13.14.01.30;	author matthieu;	state Exp;
branches;
next	1.33;
commitid	lMnyb4h9YPRhQGPk;

1.33
date	2014.07.13.10.13.19;	author matthieu;	state Exp;
branches;
next	1.32;
commitid	9x2aHJcxcxMluXg5;

1.32
date	2014.04.15.05.48.38;	author matthieu;	state Exp;
branches;
next	1.31;

1.31
date	2014.01.15.11.15.59;	author aoyama;	state Exp;
branches;
next	1.30;

1.30
date	2013.07.15.13.23.17;	author aoyama;	state Exp;
branches;
next	1.29;

1.29
date	2013.05.12.13.06.25;	author matthieu;	state Exp;
branches;
next	1.28;

1.28
date	2012.09.09.09.47.36;	author matthieu;	state Exp;
branches;
next	1.27;

1.27
date	2012.01.01.16.07.38;	author matthieu;	state Exp;
branches;
next	1.26;

1.26
date	2012.01.01.16.04.35;	author matthieu;	state Exp;
branches;
next	1.25;

1.25
date	2011.11.05.14.51.18;	author matthieu;	state Exp;
branches;
next	1.24;

1.24
date	2011.11.05.14.40.51;	author matthieu;	state Exp;
branches;
next	1.23;

1.23
date	2010.08.29.15.20.40;	author matthieu;	state Exp;
branches;
next	1.22;

1.22
date	2010.07.18.20.10.12;	author matthieu;	state Exp;
branches;
next	1.21;

1.21
date	2010.07.17.17.15.14;	author matthieu;	state Exp;
branches;
next	1.20;

1.20
date	2010.02.04.06.24.47;	author matthieu;	state Exp;
branches;
next	1.19;

1.19
date	2009.11.22.18.48.19;	author matthieu;	state Exp;
branches;
next	1.18;

1.18
date	2009.10.19.20.01.30;	author matthieu;	state Exp;
branches;
next	1.17;

1.17
date	2009.09.22.22.00.54;	author matthieu;	state Exp;
branches;
next	1.16;

1.16
date	2009.09.13.19.33.49;	author matthieu;	state Exp;
branches;
next	1.15;

1.15
date	2009.06.01.20.57.20;	author matthieu;	state Exp;
branches;
next	1.14;

1.14
date	2008.09.29.22.04.43;	author matthieu;	state Exp;
branches;
next	1.13;

1.13
date	2008.01.20.18.45.06;	author jasper;	state Exp;
branches;
next	1.12;

1.12
date	2008.01.14.08.02.36;	author jasper;	state Exp;
branches;
next	1.11;

1.11
date	2008.01.04.04.20.15;	author jsing;	state Exp;
branches;
next	1.10;

1.10
date	2007.03.03.09.44.22;	author matthieu;	state Exp;
branches;
next	1.9;

1.9
date	2007.01.02.14.04.55;	author matthieu;	state Exp;
branches;
next	1.8;

1.8
date	2007.01.02.13.54.05;	author matthieu;	state Exp;
branches;
next	1.7;

1.7
date	2006.12.08.21.57.37;	author matthieu;	state Exp;
branches;
next	1.6;

1.6
date	2006.12.03.17.04.08;	author matthieu;	state Exp;
branches;
next	1.5;

1.5
date	2006.12.03.16.36.56;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2006.12.03.16.32.48;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2006.11.29.20.07.10;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2006.11.28.19.59.08;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.26.20.22.11;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.11.26.20.22.11;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2007.03.03.09.39.06;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.36
log
@Suppress a bunch of compiler warnings for using constant strings
@
text
@/* $OpenBSD: wsfb_driver.c,v 1.35 2014/07/13 14:09:14 matthieu Exp $ */
/*
 * Copyright © 2001-2012 Matthieu Herrb
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 *    - Redistributions of source code must retain the above copyright
 *      notice, this list of conditions and the following disclaimer.
 *    - Redistributions in binary form must reproduce the above
 *      copyright notice, this list of conditions and the following
 *      disclaimer in the documentation and/or other materials provided
 *      with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
 * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
 * COPYRIGHT HOLDERS OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
 * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
 * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 *
 */

/*
 * Based on fbdev.c written by:
 *
 * Authors:  Alan Hourihane, <alanh@@fairlite.demon.co.uk>
 *	     Michel Dänzer, <michdaen@@iiic.ethz.ch>
 */

#ifdef HAVE_CONFIG_H
#include "config.h"
#endif

#include <errno.h>
#include <fcntl.h>
#include <unistd.h>
#include <sys/ioctl.h>
#include <sys/types.h>
#include <sys/mman.h>
#include <sys/time.h>
#include <dev/wscons/wsconsio.h>

/* All drivers need this. */
#include "xf86.h"
#include "xf86_OSproc.h"

#include "mipointer.h"
#include "micmap.h"
#include "colormapst.h"
#include "xf86cmap.h"
#include "shadow.h"
#include "dgaproc.h"

/* For visuals */
#include "fb.h"

#if GET_ABI_MAJOR(ABI_VIDEODRV_VERSION) < 6
#include "xf86Resources.h"
#include "xf86RAC.h"
#endif

#ifdef XvExtension
#include "xf86xv.h"
#endif

#include "compat-api.h"

#ifdef X_PRIVSEP
extern int priv_open_device(const char *);
#else
#define priv_open_device(n)    open(n,O_RDWR|O_NONBLOCK|O_EXCL)
#endif

#if defined(__NetBSD__)
#define WSFB_DEFAULT_DEV "/dev/ttyE0"
#else
#define WSFB_DEFAULT_DEV "/dev/ttyC0"
#endif

#define DEBUG 0

#if DEBUG
# define TRACE_ENTER(str)       ErrorF("wsfb: " str " %d\n",pScrn->scrnIndex)
# define TRACE_EXIT(str)        ErrorF("wsfb: " str " done\n")
# define TRACE(str)             ErrorF("wsfb trace: " str "\n")
#else
# define TRACE_ENTER(str)
# define TRACE_EXIT(str)
# define TRACE(str)
#endif

/* Prototypes */
static pointer WsfbSetup(pointer, pointer, int *, int *);
static Bool WsfbGetRec(ScrnInfoPtr);
static void WsfbFreeRec(ScrnInfoPtr);
static const OptionInfoRec * WsfbAvailableOptions(int, int);
static void WsfbIdentify(int);
static Bool WsfbProbe(DriverPtr, int);
static Bool WsfbPreInit(ScrnInfoPtr, int);
static Bool WsfbScreenInit(SCREEN_INIT_ARGS_DECL);
static Bool WsfbCloseScreen(CLOSE_SCREEN_ARGS_DECL);
static void *WsfbWindowLinear(ScreenPtr, CARD32, CARD32, int, CARD32 *,
			      void *);
static void WsfbPointerMoved(SCRN_ARG_TYPE, int, int);
static Bool WsfbEnterVT(VT_FUNC_ARGS_DECL);
static void WsfbLeaveVT(VT_FUNC_ARGS_DECL);
static Bool WsfbSwitchMode(SWITCH_MODE_ARGS_DECL);
static int WsfbValidMode(SCRN_ARG_TYPE, DisplayModePtr, Bool, int);
static void WsfbLoadPalette(ScrnInfoPtr, int, int *, LOCO *, VisualPtr);
static Bool WsfbSaveScreen(ScreenPtr, int);
static void WsfbSave(ScrnInfoPtr);
static void WsfbRestore(ScrnInfoPtr);

/* DGA stuff */
#ifdef XFreeXDGA
static Bool WsfbDGAOpenFramebuffer(ScrnInfoPtr, char **, unsigned char **,
				   int *, int *, int *);
static Bool WsfbDGASetMode(ScrnInfoPtr, DGAModePtr);
static void WsfbDGASetViewport(ScrnInfoPtr, int, int, int);
static Bool WsfbDGAInit(ScrnInfoPtr, ScreenPtr);
#endif
static Bool WsfbDriverFunc(ScrnInfoPtr pScrn, xorgDriverFuncOp op,
				pointer ptr);

/* Helper functions */
static int wsfb_open(const char *);
static pointer wsfb_mmap(size_t, off_t, int);

enum { WSFB_ROTATE_NONE = 0,
       WSFB_ROTATE_CCW = 90,
       WSFB_ROTATE_UD = 180,
       WSFB_ROTATE_CW = 270
};

/*
 * This is intentionally screen-independent.
 * It indicates the binding choice made in the first PreInit.
 */
static int pix24bpp = 0;

#define WSFB_VERSION		4000
#define WSFB_NAME		"wsfb"
#define WSFB_DRIVER_NAME	"wsfb"

_X_EXPORT DriverRec WSFB = {
	WSFB_VERSION,
	(char *)WSFB_DRIVER_NAME,
	WsfbIdentify,
	WsfbProbe,
	WsfbAvailableOptions,
	NULL,
	0,
	WsfbDriverFunc
};

/* Supported "chipsets" */
static SymTabRec WsfbChipsets[] = {
	{ 0, "wsfb" },
	{ -1, NULL }
};

/* Supported options */
typedef enum {
	OPTION_SHADOW_FB,
	OPTION_ROTATE
} WsfbOpts;

static const OptionInfoRec WsfbOptions[] = {
	{ OPTION_SHADOW_FB, "ShadowFB", OPTV_BOOLEAN, {0}, FALSE},
	{ OPTION_ROTATE, "Rotate", OPTV_STRING, {0}, FALSE},
	{ -1, NULL, OPTV_NONE, {0}, FALSE}
};

static XF86ModuleVersionInfo WsfbVersRec = {
	"wsfb",
	MODULEVENDORSTRING,
	MODINFOSTRING1,
	MODINFOSTRING2,
	XORG_VERSION_CURRENT,
	PACKAGE_VERSION_MAJOR,
	PACKAGE_VERSION_MINOR,
	PACKAGE_VERSION_PATCHLEVEL,
	ABI_CLASS_VIDEODRV,
	ABI_VIDEODRV_VERSION,
	NULL,
	{0, 0, 0, 0}
};

_X_EXPORT XF86ModuleData wsfbModuleData = { &WsfbVersRec, WsfbSetup, NULL };

static pointer
WsfbSetup(pointer module, pointer opts, int *errmaj, int *errmin)
{
	static Bool setupDone = FALSE;
	const char *osname;

	/* Check that we're being loaded on a OpenBSD or NetBSD system. */
	LoaderGetOS(&osname, NULL, NULL, NULL);
	if (!osname || (strcmp(osname, "openbsd") != 0 &&
			strcmp(osname, "netbsd") != 0)) {
		if (errmaj)
			*errmaj = LDR_BADOS;
		if (errmin)
			*errmin = 0;
		return NULL;
	}
	if (!setupDone) {
		setupDone = TRUE;
		xf86AddDriver(&WSFB, module, HaveDriverFuncs);
		return (pointer)1;
	} else {
		if (errmaj != NULL)
			*errmaj = LDR_ONCEONLY;
		return NULL;
	}
}

/* Private data */
typedef struct {
	int			fd; /* File descriptor of open device. */
	struct wsdisplay_fbinfo info; /* Frame buffer characteristics. */
	int			linebytes; /* Number of bytes per row. */
	int			wstype; /* wsdisplay type. */ 
	unsigned char*		fbstart;
	unsigned char*		fbmem;
	size_t			fbmem_len;
	int			rotate;
	Bool			shadowFB;
	void *			shadow;
	CloseScreenProcPtr	CloseScreen;
	CreateScreenResourcesProcPtr CreateScreenResources;
	void			(*PointerMoved)(SCRN_ARG_TYPE, int, int);
	EntityInfoPtr		pEnt;
	struct wsdisplay_cmap	saved_cmap;

#ifdef XFreeXDGA
	/* DGA info */
	DGAModePtr		pDGAMode;
	int			nDGAMode;
#endif
	OptionInfoPtr		Options;
} WsfbRec, *WsfbPtr;

#define WSFBPTR(p) ((WsfbPtr)((p)->driverPrivate))

static Bool
WsfbGetRec(ScrnInfoPtr pScrn)
{

	if (pScrn->driverPrivate != NULL)
		return TRUE;

	pScrn->driverPrivate = xnfcalloc(sizeof(WsfbRec), 1);
	return TRUE;
}

static void
WsfbFreeRec(ScrnInfoPtr pScrn)
{

	if (pScrn->driverPrivate == NULL)
		return;
	free(pScrn->driverPrivate);
	pScrn->driverPrivate = NULL;
}

static const OptionInfoRec *
WsfbAvailableOptions(int chipid, int busid)
{
	return WsfbOptions;
}

static void
WsfbIdentify(int flags)
{
	xf86PrintChipsets(WSFB_NAME, "driver for wsdisplay framebuffer",
			  WsfbChipsets);
}

/* Open the framebuffer device. */
static int
wsfb_open(const char *dev)
{
	int fd = -1;

	/* Try argument from xorg.conf first. */
	if (dev == NULL || ((fd = priv_open_device(dev)) == -1)) {
		/* Second: environment variable. */
		dev = getenv("XDEVICE");
		if (dev == NULL || ((fd = priv_open_device(dev)) == -1)) {
			/* Last try: default device. */
			dev = WSFB_DEFAULT_DEV;
			if ((fd = priv_open_device(dev)) == -1) {
				return -1;
			}
		}
	}
	return fd;
}

/* Map the framebuffer's memory. */
static pointer
wsfb_mmap(size_t len, off_t off, int fd)
{
	int pagemask, mapsize;
	caddr_t addr;
	pointer mapaddr;

	pagemask = getpagesize() - 1;
	mapsize = ((int) len + pagemask) & ~pagemask;
	addr = 0;

	/*
	 * Try and make it private first, that way once we get it, an
	 * interloper, e.g. another server, can't get this frame buffer,
	 * and if another server already has it, this one won't.
	 */
	mapaddr = (pointer) mmap(addr, mapsize,
				 PROT_READ | PROT_WRITE, MAP_SHARED,
				 fd, off);
	if (mapaddr == (pointer) -1) {
		mapaddr = NULL;
	}
#if DEBUG
	ErrorF("mmap returns: addr %p len 0x%x\n", mapaddr, mapsize);
#endif
	return mapaddr;
}

static Bool
WsfbProbe(DriverPtr drv, int flags)
{
	int i, fd, entity;
	GDevPtr *devSections;
	int numDevSections;
	const char *dev;
	Bool foundScreen = FALSE;

	TRACE("probe start");

	/* For now, just bail out for PROBE_DETECT. */
	if (flags & PROBE_DETECT)
		return FALSE;

	if ((numDevSections = xf86MatchDevice(WSFB_DRIVER_NAME,
					      &devSections)) <= 0)
		return FALSE;

	for (i = 0; i < numDevSections; i++) {
		ScrnInfoPtr pScrn = NULL;

		dev = xf86FindOptionValue(devSections[i]->options, "device");
		if ((fd = wsfb_open(dev)) >= 0) {
			entity = xf86ClaimFbSlot(drv, 0, devSections[i], TRUE);
			pScrn = xf86ConfigFbEntity(NULL,0,entity,
						   NULL,NULL,NULL,NULL);
			if (pScrn != NULL) {
				foundScreen = TRUE;
				pScrn->driverVersion = WSFB_VERSION;
				pScrn->driverName = (char *)WSFB_DRIVER_NAME;
				pScrn->name = (char *)WSFB_NAME;
				pScrn->Probe = WsfbProbe;
				pScrn->PreInit = WsfbPreInit;
				pScrn->ScreenInit = WsfbScreenInit;
				pScrn->SwitchMode = WsfbSwitchMode;
				pScrn->AdjustFrame = NULL;
				pScrn->EnterVT = WsfbEnterVT;
				pScrn->LeaveVT = WsfbLeaveVT;
				pScrn->ValidMode = WsfbValidMode;

				xf86DrvMsg(pScrn->scrnIndex, X_INFO,
				    "using %s\n", dev != NULL ? dev :
				    "default device");
			}
		}
	}
	free(devSections);
	TRACE("probe done");
	return foundScreen;
}

static Bool
WsfbPreInit(ScrnInfoPtr pScrn, int flags)
{
	WsfbPtr fPtr;
	int defaultDepth, depths, flags24;
	const char *dev;
	char *s;
	Gamma zeros = {0.0, 0.0, 0.0};
	DisplayModePtr mode;

	if (flags & PROBE_DETECT) return FALSE;

	TRACE_ENTER("PreInit");

	if (pScrn->numEntities != 1) return FALSE;

	pScrn->monitor = pScrn->confScreen->monitor;

	WsfbGetRec(pScrn);
	fPtr = WSFBPTR(pScrn);

	fPtr->pEnt = xf86GetEntityInfo(pScrn->entityList[0]);

#if GET_ABI_MAJOR(ABI_VIDEODRV_VERSION) < 6
	pScrn->racMemFlags = RAC_FB | RAC_COLORMAP | RAC_CURSOR | RAC_VIEWPORT;
	pScrn->racIoFlags = pScrn->racMemFlags;
#endif

	dev = xf86FindOptionValue(fPtr->pEnt->device->options, "device");
	fPtr->fd = wsfb_open(dev);
	if (fPtr->fd == -1) {
		return FALSE;
	}
	if (ioctl(fPtr->fd, WSDISPLAYIO_GTYPE, &(fPtr->wstype)) == -1) {
		xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
			   "ioctl WSDISPLAY_GTYPE: %s\n",
			   strerror(errno));
		return FALSE;
	}
	/*
	 * Depth
	 */
	defaultDepth = 0;
	if (ioctl(fPtr->fd, WSDISPLAYIO_GETSUPPORTEDDEPTH,
		&depths) == 0) {
		/* Preferred order for default depth selection. */
		if (depths & WSDISPLAYIO_DEPTH_16)
			defaultDepth = 16;
		else if (depths & WSDISPLAYIO_DEPTH_15)
			defaultDepth = 15;
		else if (depths & WSDISPLAYIO_DEPTH_8)
			defaultDepth = 8;
		else if (depths & WSDISPLAYIO_DEPTH_24)
			defaultDepth = 24;
		else if (depths & WSDISPLAYIO_DEPTH_4)
			defaultDepth = 4;
		else if (depths & WSDISPLAYIO_DEPTH_1)
			defaultDepth = 1;

		flags24 = 0;
		if (depths & WSDISPLAYIO_DEPTH_24_24)
			flags24 |= Support24bppFb;
		if (depths & WSDISPLAYIO_DEPTH_24_32)
			flags24 |= Support32bppFb;
		if (!flags24)
			flags24 = Support24bppFb;
	} else {
		/* Old way */
		if (ioctl(fPtr->fd, WSDISPLAYIO_GINFO, &fPtr->info) == -1) {
			xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
			    "no way to get depth info: %s\n",
			    strerror(errno));
			return FALSE;
		}
		if (fPtr->info.depth == 8) {
			/*
			 * We might run on a byte addressable frame buffer,
			 * but with less than 8 bits per pixel.
			 * We can know this from the colormap size.
			 */
			defaultDepth = 1;
			while ((1 << defaultDepth) < fPtr->info.cmsize)
				defaultDepth++;
		} else
			defaultDepth =
			    fPtr->info.depth <= 24 ? fPtr->info.depth : 24;

		if (fPtr->info.depth >= 24)
			flags24 = Support24bppFb|Support32bppFb;
		else
			flags24 = 0;
	}

	/* Prefer 24bpp for fb since it potentially allows larger modes. */
	if (flags24 & Support24bppFb)
		flags24 |= SupportConvert32to24 | PreferConvert32to24;

	if (!xf86SetDepthBpp(pScrn, defaultDepth, 0,
		fPtr->info.depth, flags24))
		return FALSE;

	if (fPtr->wstype == WSDISPLAY_TYPE_PCIVGA) {
		/* Set specified mode. */
		if (pScrn->display->modes != NULL &&
		    pScrn->display->modes[0] != NULL) {
			struct wsdisplay_gfx_mode gfxmode;

			if (sscanf(pScrn->display->modes[0], "%dx%d",
				&gfxmode.width, &gfxmode.height) != 2) {
				xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
				    "Can't parse mode name %s\n",
				    pScrn->display->modes[0]);
				return FALSE;
			}
			gfxmode.depth = pScrn->bitsPerPixel;
			if (ioctl(fPtr->fd, WSDISPLAYIO_SETGFXMODE,
				&gfxmode) == -1) {
				xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
				    "ioctl WSDISPLAY_SETGFXMODE: %s\n",
				    strerror(errno));
				return FALSE;
			}
		}
	}
	if (ioctl(fPtr->fd, WSDISPLAYIO_GINFO, &fPtr->info) == -1) {
		xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
		    "ioctl WSDISPLAY_GINFO: %s\n",
		    strerror(errno));
		return FALSE;
	}
	if (ioctl(fPtr->fd, WSDISPLAYIO_LINEBYTES, &fPtr->linebytes) == -1) {
		xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
			   "ioctl WSDISPLAYIO_LINEBYTES: %s\n",
			   strerror(errno));
		return FALSE;
	}

	/* Quirk for LUNA: now X supports 1bpp only, so force to set 1bpp */
	if (fPtr->wstype == WSDISPLAY_TYPE_LUNA) {
		struct wsdisplay_gfx_mode gfxmode;
		gfxmode.width  = fPtr->info.width;
		gfxmode.height = fPtr->info.height;
		gfxmode.depth  = fPtr->info.depth = 1;
		
		if (ioctl(fPtr->fd, WSDISPLAYIO_SETGFXMODE, &gfxmode) == -1) {
			xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
			    "ioctl WSDISPLAY_SETGFXMODE: %s\n",
			    strerror(errno));
			return FALSE;
		}
	}

	/*
	 * Allocate room for saving the colormap.
	 */
	if (fPtr->info.cmsize != 0) {
		fPtr->saved_cmap.red =
		    (unsigned char *)malloc(fPtr->info.cmsize);
		if (fPtr->saved_cmap.red == NULL) {
			xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
			    "Cannot malloc %d bytes\n", fPtr->info.cmsize);
			return FALSE;
		}
		fPtr->saved_cmap.green =
		    (unsigned char *)malloc(fPtr->info.cmsize);
		if (fPtr->saved_cmap.green == NULL) {
			xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
			    "Cannot malloc %d bytes\n", fPtr->info.cmsize);
			free(fPtr->saved_cmap.red);
			return FALSE;
		}
		fPtr->saved_cmap.blue =
		    (unsigned char *)malloc(fPtr->info.cmsize);
		if (fPtr->saved_cmap.blue == NULL) {
			xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
			    "Cannot malloc %d bytes\n", fPtr->info.cmsize);
			free(fPtr->saved_cmap.red);
			free(fPtr->saved_cmap.green);
			return FALSE;
		}
	}


	/* Check consistency. */
	if (pScrn->bitsPerPixel != fPtr->info.depth) {
		xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
		    "specified depth (%d) or bpp (%d) doesn't match "
		    "framebuffer depth (%d)\n", pScrn->depth,
		    pScrn->bitsPerPixel, fPtr->info.depth);
		return FALSE;
	}
	xf86PrintDepthBpp(pScrn);

	/* Get the depth24 pixmap format. */
	if (pScrn->depth == 24 && pix24bpp == 0)
		pix24bpp = xf86GetBppFromDepth(pScrn, 24);

	/* Color weight */
	if (pScrn->depth > 8) {
		rgb izeros = { 0, 0, 0 }, masks;

		switch (fPtr->wstype) {
		case WSDISPLAY_TYPE_SUN24:
		case WSDISPLAY_TYPE_SUNCG12:
		case WSDISPLAY_TYPE_SUNCG14:
		case WSDISPLAY_TYPE_SUNTCX:
		case WSDISPLAY_TYPE_SUNFFB:
		case WSDISPLAY_TYPE_AGTEN:
		case WSDISPLAY_TYPE_XVIDEO:
		case WSDISPLAY_TYPE_SUNLEO:
		case WSDISPLAY_TYPE_GBE:
			masks.red = 0x0000ff;
			masks.green = 0x00ff00;
			masks.blue = 0xff0000;
			break;
		case WSDISPLAY_TYPE_PXALCD:
		case WSDISPLAY_TYPE_SMFB:
			masks.red = 0x1f << 11;
			masks.green = 0x3f << 5;
			masks.blue = 0x1f;
			break;
		case WSDISPLAY_TYPE_MAC68K:
			if (pScrn->depth > 16) {
				masks.red = 0x0000ff;
				masks.green = 0x00ff00;
				masks.blue = 0xff0000;
			} else {
				masks.red = 0x1f << 11;
				masks.green = 0x3f << 5;
				masks.blue = 0x1f;
			}
			break;
		case WSDISPLAY_TYPE_PCIVGA:
			if (pScrn->depth > 16) {
				masks.red = 0xff0000;
				masks.green = 0x00ff00;
				masks.blue = 0x0000ff;
			} else {
				masks.red = 0x1f << 11;
				masks.green = 0x3f << 5;
				masks.blue = 0x1f;
			}
			break;
		default:
			masks.red = 0;
			masks.green = 0;
			masks.blue = 0;
			break;
		}

		if (!xf86SetWeight(pScrn, izeros, masks))
			return FALSE;
	}

	/* Visual init */
	if (!xf86SetDefaultVisual(pScrn, -1))
		return FALSE;

	/* We don't currently support DirectColor at > 8bpp . */
	if (pScrn->depth > 8 && pScrn->defaultVisual != TrueColor) {
		xf86DrvMsg(pScrn->scrnIndex, X_ERROR, "Given default visual"
			   " (%s) is not supported at depth %d\n",
			   xf86GetVisualName(pScrn->defaultVisual),
			   pScrn->depth);
		return FALSE;
	}

	xf86SetGamma(pScrn,zeros);

	pScrn->progClock = TRUE;
	if (pScrn->depth == 8)
		pScrn->rgbBits = 6;
	else
		pScrn->rgbBits   = 8;
	pScrn->chipset   = (char *)"wsfb";
	pScrn->videoRam  = fPtr->linebytes * fPtr->info.height;

	xf86DrvMsg(pScrn->scrnIndex, X_INFO, "Vidmem: %dk\n",
		   pScrn->videoRam/1024);

	/* Handle options. */
	xf86CollectOptions(pScrn, NULL);
	fPtr->Options = (OptionInfoRec *)malloc(sizeof(WsfbOptions));
	if (fPtr->Options == NULL)
		return FALSE;
	memcpy(fPtr->Options, WsfbOptions, sizeof(WsfbOptions));
	xf86ProcessOptions(pScrn->scrnIndex, fPtr->pEnt->device->options,
			   fPtr->Options);

	/* Use shadow framebuffer by default, on depth >= 8 */
	if (pScrn->depth >= 8)
		fPtr->shadowFB = xf86ReturnOptValBool(fPtr->Options,
						      OPTION_SHADOW_FB, TRUE);
	else
		if (xf86ReturnOptValBool(fPtr->Options,
					 OPTION_SHADOW_FB, FALSE)) {
			xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
				   "Shadow FB option ignored on depth < 8");
		}

	/* Rotation */
	fPtr->rotate = WSFB_ROTATE_NONE;
	if ((s = xf86GetOptValString(fPtr->Options, OPTION_ROTATE))) {
		if (pScrn->depth >= 8) {
			if (!xf86NameCmp(s, "CW")) {
				fPtr->shadowFB = TRUE;
				fPtr->rotate = WSFB_ROTATE_CW;
				xf86DrvMsg(pScrn->scrnIndex, X_CONFIG,
				    "Rotating screen clockwise\n");
			} else if (!xf86NameCmp(s, "CCW")) {
				fPtr->shadowFB = TRUE;
				fPtr->rotate = WSFB_ROTATE_CCW;
				xf86DrvMsg(pScrn->scrnIndex, X_CONFIG,
				    "Rotating screen counter clockwise\n");
			} else if (!xf86NameCmp(s, "UD")) {
				fPtr->shadowFB = TRUE;
				fPtr->rotate = WSFB_ROTATE_UD;
				xf86DrvMsg(pScrn->scrnIndex, X_CONFIG,
				    "Rotating screen upside down\n");
			} else {
				xf86DrvMsg(pScrn->scrnIndex, X_CONFIG,
				    "\"%s\" is not a valid value for Option "
				    "\"Rotate\"\n", s);
				xf86DrvMsg(pScrn->scrnIndex, X_INFO,
				    "Valid options are \"CW\", \"CCW\","
				    " or \"UD\"\n");
			}
		} else {
			xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
			    "Option \"Rotate\" ignored on depth < 8");
		}
	}

	/* Fake video mode struct. */
	mode = (DisplayModePtr)malloc(sizeof(DisplayModeRec));
	mode->prev = mode;
	mode->next = mode;
	mode->name = (char *)"wsfb current mode";
	mode->status = MODE_OK;
	mode->type = M_T_BUILTIN;
	mode->Clock = 0;
	mode->HDisplay = fPtr->info.width;
	mode->HSyncStart = 0;
	mode->HSyncEnd = 0;
	mode->HTotal = 0;
	mode->HSkew = 0;
	mode->VDisplay = fPtr->info.height;
	mode->VSyncStart = 0;
	mode->VSyncEnd = 0;
	mode->VTotal = 0;
	mode->VScan = 0;
	mode->Flags = 0;

	pScrn->currentMode = pScrn->modes = mode;
	pScrn->virtualX = fPtr->info.width;
	pScrn->virtualY = fPtr->info.height;
	pScrn->displayWidth = pScrn->virtualX;

	/* Quirk for LUNA's framebuffer */
	if (fPtr->wstype == WSDISPLAY_TYPE_LUNA)
		pScrn->displayWidth = fPtr->linebytes * 8;

	/* Set the display resolution. */
	xf86SetDpi(pScrn, 0, 0);


	/* Load shadow if needed. */
	if (fPtr->shadowFB) {
		xf86DrvMsg(pScrn->scrnIndex, X_CONFIG,
			   "Using \"Shadow Framebuffer\"\n");
		if (xf86LoadSubModule(pScrn, "shadow") == NULL) {
			WsfbFreeRec(pScrn);
			return FALSE;
		}
	}
	if (xf86LoadSubModule(pScrn, "fb") == NULL) {
		WsfbFreeRec(pScrn);
		return FALSE;
	}
	TRACE_EXIT("PreInit");
	return TRUE;
}

static void
wsfbUpdateRotatePacked(ScreenPtr pScreen, shadowBufPtr pBuf)
{
    shadowUpdateRotatePacked(pScreen, pBuf);
}

static void
wsfbUpdatePacked(ScreenPtr pScreen, shadowBufPtr pBuf)
{
    shadowUpdatePacked(pScreen, pBuf);
}

static Bool
WsfbCreateScreenResources(ScreenPtr pScreen)
{
	ScrnInfoPtr pScrn = xf86ScreenToScrn(pScreen);
	WsfbPtr fPtr = WSFBPTR(pScrn);
	PixmapPtr pPixmap;
	Bool ret;

	pScreen->CreateScreenResources = fPtr->CreateScreenResources;
	ret = pScreen->CreateScreenResources(pScreen);
	pScreen->CreateScreenResources = WsfbCreateScreenResources;

	if (!ret)
		return FALSE;

	pPixmap = pScreen->GetScreenPixmap(pScreen);

	if (!shadowAdd(pScreen, pPixmap, fPtr->rotate ?
		wsfbUpdateRotatePacked : wsfbUpdatePacked,
		WsfbWindowLinear, fPtr->rotate, NULL)) {
		return FALSE;
	}
	return TRUE;
}


static Bool
WsfbShadowInit(ScreenPtr pScreen)
{
	ScrnInfoPtr pScrn = xf86ScreenToScrn(pScreen);
	WsfbPtr fPtr = WSFBPTR(pScrn);

	if (!shadowSetup(pScreen))
		return FALSE;
	fPtr->CreateScreenResources = pScreen->CreateScreenResources;
	pScreen->CreateScreenResources = WsfbCreateScreenResources;

	return TRUE;
}

static Bool
WsfbScreenInit(SCREEN_INIT_ARGS_DECL)
{
	ScrnInfoPtr pScrn = xf86ScreenToScrn(pScreen);
	WsfbPtr fPtr = WSFBPTR(pScrn);
	VisualPtr visual;
	int ret, flags, ncolors;
	int wsmode = WSDISPLAYIO_MODE_DUMBFB;
	size_t len;

	TRACE_ENTER("WsfbScreenInit");
#if DEBUG
	ErrorF("\tbitsPerPixel=%d, depth=%d, defaultVisual=%s\n"
	       "\tmask: %x,%x,%x, offset: %u,%u,%u\n",
	       pScrn->bitsPerPixel,
	       pScrn->depth,
	       xf86GetVisualName(pScrn->defaultVisual),
	       pScrn->mask.red,pScrn->mask.green,pScrn->mask.blue,
	       pScrn->offset.red,pScrn->offset.green,pScrn->offset.blue);
#endif
	switch (fPtr->info.depth) {
	case 1:
	case 4:
	case 8:
		len = fPtr->linebytes*fPtr->info.height;
		break;
	case 16:
		if (fPtr->linebytes == fPtr->info.width) {
			len = fPtr->info.width*fPtr->info.height*sizeof(short);
		} else {
			len = fPtr->linebytes*fPtr->info.height;
		}
		break;
	case 24:
		if (fPtr->linebytes == fPtr->info.width) {
			len = fPtr->info.width*fPtr->info.height*3;
		} else {
			len = fPtr->linebytes*fPtr->info.height;
		}
		break;
	case 32:
		if (fPtr->linebytes == fPtr->info.width) {
			len = fPtr->info.width*fPtr->info.height*sizeof(int);
		} else {
			len = fPtr->linebytes*fPtr->info.height;
		}
		break;
	default:
		xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
			   "unsupported depth %d\n", fPtr->info.depth);
		return FALSE;
	}
	/* Switch to graphics mode - required before mmap. */
	if (ioctl(fPtr->fd, WSDISPLAYIO_SMODE, &wsmode) == -1) {
		xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
			   "ioctl WSDISPLAYIO_SMODE: %s\n",
			   strerror(errno));
		return FALSE;
	}
	fPtr->fbmem = wsfb_mmap(len, 0, fPtr->fd);

	if (fPtr->fbmem == NULL) {
		xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
			   "wsfb_mmap: %s\n", strerror(errno));
		return FALSE;
	}
	fPtr->fbmem_len = len;

	WsfbSave(pScrn);
	pScrn->vtSema = TRUE;

	/* MI layer */
	miClearVisualTypes();
	if (pScrn->bitsPerPixel > 8) {
		if (!miSetVisualTypes(pScrn->depth, TrueColorMask,
				      pScrn->rgbBits, TrueColor))
			return FALSE;
	} else {
		if (!miSetVisualTypes(pScrn->depth,
				      miGetDefaultVisualMask(pScrn->depth),
				      pScrn->rgbBits, pScrn->defaultVisual))
			return FALSE;
	}
	if (!miSetPixmapDepths())
		return FALSE;

	if (fPtr->rotate == WSFB_ROTATE_CW
	    || fPtr->rotate == WSFB_ROTATE_CCW) {
		int tmp = pScrn->virtualX;
		pScrn->virtualX = pScrn->displayWidth = pScrn->virtualY;
		pScrn->virtualY = tmp;
	}
	if (fPtr->rotate && !fPtr->PointerMoved) {
		fPtr->PointerMoved = pScrn->PointerMoved;
		pScrn->PointerMoved = WsfbPointerMoved;
	}

	fPtr->fbstart = fPtr->fbmem;

	/*
	 * LUNA's framebuffer seems to have 64 dot (8 byte) offset.
	 * This might be able to be changed in kernel lunafb driver,
	 * but current setting was pulled from 4.4BSD-Lite2/luna68k.
	 */
	if (fPtr->wstype == WSDISPLAY_TYPE_LUNA)
		fPtr->fbstart += 8;

	if (fPtr->shadowFB) {
		fPtr->shadow = calloc(1, pScrn->virtualX * pScrn->virtualY *
		    pScrn->bitsPerPixel/8);

		if (!fPtr->shadow) {
			xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
			    "Failed to allocate shadow framebuffer\n");
			return FALSE;
		}
	}

	switch (pScrn->bitsPerPixel) {
	case 1:
	case 4:
	case 8:
	case 16:
	case 24:
	case 32:
		ret = fbScreenInit(pScreen,
		    fPtr->shadowFB ? fPtr->shadow : fPtr->fbstart,
		    pScrn->virtualX, pScrn->virtualY,
		    pScrn->xDpi, pScrn->yDpi,
		    pScrn->displayWidth, pScrn->bitsPerPixel);
		break;
	default:
		xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
			   "Unsupported bpp: %d", pScrn->bitsPerPixel);
		return FALSE;
	} /* case */

	if (!ret) {
		xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
		    "fbScreenInit error");
		return FALSE;
	}

	if (pScrn->bitsPerPixel > 8) {
		/* Fixup RGB ordering. */
		visual = pScreen->visuals + pScreen->numVisuals;
		while (--visual >= pScreen->visuals) {
			if ((visual->class | DynamicClass) == DirectColor) {
				visual->offsetRed   = pScrn->offset.red;
				visual->offsetGreen = pScrn->offset.green;
				visual->offsetBlue  = pScrn->offset.blue;
				visual->redMask     = pScrn->mask.red;
				visual->greenMask   = pScrn->mask.green;
				visual->blueMask    = pScrn->mask.blue;
			}
		}
	}

	if (pScrn->bitsPerPixel >= 8) {
		if (!fbPictureInit(pScreen, NULL, 0))
			xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
				   "RENDER extension initialisation failed.");
	}
	if (fPtr->shadowFB && !WsfbShadowInit(pScreen)) {
		xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
		    "shadow framebuffer initialization failed\n");
		return FALSE;
	}

#ifdef XFreeXDGA
	if (!fPtr->rotate)
		WsfbDGAInit(pScrn, pScreen);
	else
		xf86DrvMsg(pScrn->scrnIndex, X_INFO, "Rotated display, "
		    "disabling DGA\n");
#endif
	if (fPtr->rotate) {
		xf86DrvMsg(pScrn->scrnIndex, X_INFO,
		    "Enabling Driver Rotation, " "disabling RandR\n");
		xf86DisableRandR();
		if (pScrn->bitsPerPixel == 24)
			xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
			    "Rotation might be broken in 24 bpp\n");
	}

	xf86SetBlackWhitePixels(pScreen);
	xf86SetBackingStore(pScreen);

	/* Software cursor. */
	miDCInitialize(pScreen, xf86GetPointerScreenFuncs());

	/*
	 * Colormap
	 *
	 * Note that, even on less than 8 bit depth frame buffers, we
	 * expect the colormap to be programmable with 8 bit values.
	 * As of now, this is indeed the case on all OpenBSD supported
	 * graphics hardware.
	 */
	if (!miCreateDefColormap(pScreen))
		return FALSE;
	flags = CMAP_RELOAD_ON_MODE_SWITCH;
	ncolors = fPtr->info.cmsize;
	/* On StaticGray visuals, fake a 256 entries colormap. */
	if (ncolors == 0)
		ncolors = 256;
	if(!xf86HandleColormaps(pScreen, ncolors, 8, WsfbLoadPalette,
				NULL, flags))
		return FALSE;

	pScreen->SaveScreen = WsfbSaveScreen;

#ifdef XvExtension
	{
		XF86VideoAdaptorPtr *ptr;

		int n = xf86XVListGenericAdaptors(pScrn,&ptr);
		if (n) {
			xf86XVScreenInit(pScreen,ptr,n);
		}
	}
#endif

	/* Wrap the current CloseScreen function. */
	fPtr->CloseScreen = pScreen->CloseScreen;
	pScreen->CloseScreen = WsfbCloseScreen;

	TRACE_EXIT("WsfbScreenInit");
	return TRUE;
}

static Bool
WsfbCloseScreen(CLOSE_SCREEN_ARGS_DECL)
{
	ScrnInfoPtr pScrn = xf86ScreenToScrn(pScreen);
	PixmapPtr pPixmap;
	WsfbPtr fPtr = WSFBPTR(pScrn);


	TRACE_ENTER("WsfbCloseScreen");

	pPixmap = pScreen->GetScreenPixmap(pScreen);
	if (fPtr->shadowFB)
		shadowRemove(pScreen, pPixmap);

	if (pScrn->vtSema) {
		WsfbRestore(pScrn);
		if (munmap(fPtr->fbmem, fPtr->fbmem_len) == -1) {
			xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
				   "munmap: %s\n", strerror(errno));
		}

		fPtr->fbmem = NULL;
	}
#ifdef XFreeXDGA
	if (fPtr->pDGAMode) {
		free(fPtr->pDGAMode);
		fPtr->pDGAMode = NULL;
		fPtr->nDGAMode = 0;
	}
#endif
	pScrn->vtSema = FALSE;

	/* Unwrap CloseScreen. */
	pScreen->CloseScreen = fPtr->CloseScreen;
	TRACE_EXIT("WsfbCloseScreen");
	return (*pScreen->CloseScreen)(CLOSE_SCREEN_ARGS);
}

static void *
WsfbWindowLinear(ScreenPtr pScreen, CARD32 row, CARD32 offset, int mode,
		CARD32 *size, void *closure)
{
	ScrnInfoPtr pScrn = xf86ScreenToScrn(pScreen);
	WsfbPtr fPtr = WSFBPTR(pScrn);

	if (fPtr->linebytes)
		*size = fPtr->linebytes;
	else {
		if (ioctl(fPtr->fd, WSDISPLAYIO_LINEBYTES, size) == -1)
			return NULL;
		fPtr->linebytes = *size;
	}
	return ((CARD8 *)fPtr->fbmem + row *fPtr->linebytes + offset);
}

static void
WsfbPointerMoved(SCRN_ARG_TYPE arg, int x, int y)
{
    SCRN_INFO_PTR(arg);
    WsfbPtr fPtr = WSFBPTR(pScrn);
    int newX, newY;

    switch (fPtr->rotate)
    {
    case WSFB_ROTATE_CW:
	/* 90 degrees CW rotation. */
	newX = pScrn->pScreen->height - y - 1;
	newY = x;
	break;

    case WSFB_ROTATE_CCW:
	/* 90 degrees CCW rotation. */
	newX = y;
	newY = pScrn->pScreen->width - x - 1;
	break;

    case WSFB_ROTATE_UD:
	/* 180 degrees UD rotation. */
	newX = pScrn->pScreen->width - x - 1;
	newY = pScrn->pScreen->height - y - 1;
	break;

    default:
	/* No rotation. */
	newX = x;
	newY = y;
	break;
    }

    /* Pass adjusted pointer coordinates to wrapped PointerMoved function. */
    (*fPtr->PointerMoved)(arg, newX, newY);
}

static Bool
WsfbEnterVT(VT_FUNC_ARGS_DECL)
{
	SCRN_INFO_PTR(arg);
	WsfbPtr fPtr = WSFBPTR(pScrn);
	int wsmode = WSDISPLAYIO_MODE_DUMBFB;

	TRACE_ENTER("EnterVT");

	/* Switch to graphics mode. */
	if (ioctl(fPtr->fd, WSDISPLAYIO_SMODE, &wsmode) == -1) {
		xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
		    "ioctl WSDISPLAYIO_SMODE: %s\n",
		    strerror(errno));
		return FALSE;
	}

	pScrn->vtSema = TRUE;
	TRACE_EXIT("EnterVT");
	return TRUE;
}

static void
WsfbLeaveVT(VT_FUNC_ARGS_DECL)
{
	SCRN_INFO_PTR(arg);

	TRACE_ENTER("LeaveVT");
	WsfbRestore(pScrn);
	TRACE_EXIT("LeaveVT");
}

static Bool
WsfbSwitchMode(SWITCH_MODE_ARGS_DECL)
{
#if DEBUG
	SCRN_INFO_PTR(arg);
#endif

	TRACE_ENTER("SwitchMode");
	/* Nothing else to do. */
	return TRUE;
}

static int
WsfbValidMode(SCRN_ARG_TYPE arg, DisplayModePtr mode, Bool verbose, int flags)
{
#if DEBUG
	SCRN_INFO_PTR(arg);
#endif

	TRACE_ENTER("ValidMode");
	return MODE_OK;
}

static void
WsfbLoadPalette(ScrnInfoPtr pScrn, int numColors, int *indices,
	       LOCO *colors, VisualPtr pVisual)
{
	WsfbPtr fPtr = WSFBPTR(pScrn);
	struct wsdisplay_cmap cmap;
	unsigned char red[256],green[256],blue[256];
	int i, indexMin=256, indexMax=0;

	TRACE_ENTER("LoadPalette");

	cmap.count   = 1;
	cmap.red   = red;
	cmap.green = green;
	cmap.blue  = blue;

	if (numColors == 1) {
		/* Optimisation */
		cmap.index = indices[0];
		red[0]   = colors[indices[0]].red;
		green[0] = colors[indices[0]].green;
		blue[0]  = colors[indices[0]].blue;
		if (ioctl(fPtr->fd,WSDISPLAYIO_PUTCMAP, &cmap) == -1)
			ErrorF("ioctl FBIOPUTCMAP: %s\n", strerror(errno));
	} else {
		/*
		 * Change all colors in 2 ioctls
		 * and limit the data to be transfered.
		 */
		for (i = 0; i < numColors; i++) {
			if (indices[i] < indexMin)
				indexMin = indices[i];
			if (indices[i] > indexMax)
				indexMax = indices[i];
		}
		cmap.index = indexMin;
		cmap.count = indexMax - indexMin + 1;
		cmap.red = &red[indexMin];
		cmap.green = &green[indexMin];
		cmap.blue = &blue[indexMin];
		/* Get current map. */
		if (ioctl(fPtr->fd, WSDISPLAYIO_GETCMAP, &cmap) == -1)
			ErrorF("ioctl FBIOGETCMAP: %s\n", strerror(errno));
		/* Change the colors that require updating. */
		for (i = 0; i < numColors; i++) {
			red[indices[i]]   = colors[indices[i]].red;
			green[indices[i]] = colors[indices[i]].green;
			blue[indices[i]]  = colors[indices[i]].blue;
		}
		/* Write the colormap back. */
		if (ioctl(fPtr->fd,WSDISPLAYIO_PUTCMAP, &cmap) == -1)
			ErrorF("ioctl FBIOPUTCMAP: %s\n", strerror(errno));
	}
	TRACE_EXIT("LoadPalette");
}

static Bool
WsfbSaveScreen(ScreenPtr pScreen, int mode)
{
	ScrnInfoPtr pScrn = xf86ScreenToScrn(pScreen);
	WsfbPtr fPtr = WSFBPTR(pScrn);
	int state;

	TRACE_ENTER("SaveScreen");

	if (!pScrn->vtSema)
		return TRUE;

	if (mode != SCREEN_SAVER_FORCER) {
		state = xf86IsUnblank(mode)?WSDISPLAYIO_VIDEO_ON:
					    WSDISPLAYIO_VIDEO_OFF;
		ioctl(fPtr->fd,
		      WSDISPLAYIO_SVIDEO, &state);
	}
	TRACE_EXIT("SaveScreen");
	return TRUE;
}


static void
WsfbSave(ScrnInfoPtr pScrn)
{
	WsfbPtr fPtr = WSFBPTR(pScrn);

	TRACE_ENTER("WsfbSave");

	if (fPtr->info.cmsize == 0)
		return;

	fPtr->saved_cmap.index = 0;
	fPtr->saved_cmap.count = fPtr->info.cmsize;
	if (ioctl(fPtr->fd, WSDISPLAYIO_GETCMAP,
		  &(fPtr->saved_cmap)) == -1) {
		xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
			   "error saving colormap %s\n", strerror(errno));
	}
	TRACE_EXIT("WsfbSave");

}

static void
WsfbRestore(ScrnInfoPtr pScrn)
{
	WsfbPtr fPtr = WSFBPTR(pScrn);
	int mode;

	TRACE_ENTER("WsfbRestore");

	if (fPtr->info.cmsize != 0) {
		/* reset colormap for text mode */
		if (ioctl(fPtr->fd, WSDISPLAYIO_PUTCMAP,
			  &(fPtr->saved_cmap)) == -1) {
			xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
				   "error restoring colormap %s\n",
				   strerror(errno));
		}
	}

	/* Clear the screen. */
	memset(fPtr->fbmem, 0, fPtr->fbmem_len);

	/* Quirk for LUNA: Restore default depth. */
	if (fPtr->wstype == WSDISPLAY_TYPE_LUNA) {
		struct wsdisplay_gfx_mode gfxmode;
		gfxmode.width  = fPtr->info.width;
		gfxmode.height = fPtr->info.height;
		gfxmode.depth  = 0;	/* set to default depth */
		
		if (ioctl(fPtr->fd, WSDISPLAYIO_SETGFXMODE, &gfxmode) == -1) {
			xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
			    "ioctl WSDISPLAY_SETGFXMODE: %s\n",
			    strerror(errno));
			return;
		}
	}

	/* Restore the text mode. */
	mode = WSDISPLAYIO_MODE_EMUL;
	if (ioctl(fPtr->fd, WSDISPLAYIO_SMODE, &mode) == -1) {
		xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
			   "error setting text mode %s\n", strerror(errno));
	}
	TRACE_EXIT("WsfbRestore");
}

#ifdef XFreeXDGA
/***********************************************************************
 * DGA stuff
 ***********************************************************************/

static Bool
WsfbDGAOpenFramebuffer(ScrnInfoPtr pScrn, char **DeviceName,
		       unsigned char **ApertureBase, int *ApertureSize,
		       int *ApertureOffset, int *flags)
{
	*DeviceName = NULL;		/* No special device */
	*ApertureBase = (unsigned char *)(pScrn->memPhysBase);
	*ApertureSize = pScrn->videoRam;
	*ApertureOffset = pScrn->fbOffset;
	*flags = 0;

	return TRUE;
}

static Bool
WsfbDGASetMode(ScrnInfoPtr pScrn, DGAModePtr pDGAMode)
{
	DisplayModePtr pMode;
	int frameX0, frameY0;

	if (pDGAMode) {
		pMode = pDGAMode->mode;
		frameX0 = frameY0 = 0;
	} else {
		if (!(pMode = pScrn->currentMode))
			return TRUE;

		frameX0 = pScrn->frameX0;
		frameY0 = pScrn->frameY0;
	}

	if (!(*pScrn->SwitchMode)(SWITCH_MODE_ARGS(pScrn, pMode)))
		return FALSE;
	(*pScrn->AdjustFrame)(ADJUST_FRAME_ARGS(pScrn, frameX0, frameY0));

	return TRUE;
}

static void
WsfbDGASetViewport(ScrnInfoPtr pScrn, int x, int y, int flags)
{
	(*pScrn->AdjustFrame)(ADJUST_FRAME_ARGS(pScrn, x, y));
}

static int
WsfbDGAGetViewport(ScrnInfoPtr pScrn)
{
	return (0);
}

static DGAFunctionRec WsfbDGAFunctions =
{
	WsfbDGAOpenFramebuffer,
	NULL,       /* CloseFramebuffer */
	WsfbDGASetMode,
	WsfbDGASetViewport,
	WsfbDGAGetViewport,
	NULL,       /* Sync */
	NULL,       /* FillRect */
	NULL,       /* BlitRect */
	NULL,       /* BlitTransRect */
};

static void
WsfbDGAAddModes(ScrnInfoPtr pScrn)
{
	WsfbPtr fPtr = WSFBPTR(pScrn);
	DisplayModePtr pMode = pScrn->modes;
	DGAModePtr pDGAMode;

	do {
		pDGAMode = realloc(fPtr->pDGAMode,
				    (fPtr->nDGAMode + 1) * sizeof(DGAModeRec));
		if (!pDGAMode)
			break;

		fPtr->pDGAMode = pDGAMode;
		pDGAMode += fPtr->nDGAMode;
		(void)memset(pDGAMode, 0, sizeof(DGAModeRec));

		++fPtr->nDGAMode;
		pDGAMode->mode = pMode;
		pDGAMode->flags = DGA_CONCURRENT_ACCESS | DGA_PIXMAP_AVAILABLE;
		pDGAMode->byteOrder = pScrn->imageByteOrder;
		pDGAMode->depth = pScrn->depth;
		pDGAMode->bitsPerPixel = pScrn->bitsPerPixel;
		pDGAMode->red_mask = pScrn->mask.red;
		pDGAMode->green_mask = pScrn->mask.green;
		pDGAMode->blue_mask = pScrn->mask.blue;
		pDGAMode->visualClass = pScrn->bitsPerPixel > 8 ?
			TrueColor : PseudoColor;
		pDGAMode->xViewportStep = 1;
		pDGAMode->yViewportStep = 1;
		pDGAMode->viewportWidth = pMode->HDisplay;
		pDGAMode->viewportHeight = pMode->VDisplay;

		if (fPtr->linebytes)
			pDGAMode->bytesPerScanline = fPtr->linebytes;
		else {
			ioctl(fPtr->fd, WSDISPLAYIO_LINEBYTES,
			      &fPtr->linebytes);
			pDGAMode->bytesPerScanline = fPtr->linebytes;
		}

		pDGAMode->imageWidth = pMode->HDisplay;
		pDGAMode->imageHeight =  pMode->VDisplay;
		pDGAMode->pixmapWidth = pDGAMode->imageWidth;
		pDGAMode->pixmapHeight = pDGAMode->imageHeight;
		pDGAMode->maxViewportX = pScrn->virtualX -
			pDGAMode->viewportWidth;
		pDGAMode->maxViewportY = pScrn->virtualY -
			pDGAMode->viewportHeight;

		pDGAMode->address = fPtr->fbstart;

		pMode = pMode->next;
	} while (pMode != pScrn->modes);
}

static Bool
WsfbDGAInit(ScrnInfoPtr pScrn, ScreenPtr pScreen)
{
	WsfbPtr fPtr = WSFBPTR(pScrn);

	if (pScrn->depth < 8)
		return FALSE;

	if (!fPtr->nDGAMode)
		WsfbDGAAddModes(pScrn);

	return (DGAInit(pScreen, &WsfbDGAFunctions,
			fPtr->pDGAMode, fPtr->nDGAMode));
}
#endif

static Bool
WsfbDriverFunc(ScrnInfoPtr pScrn, xorgDriverFuncOp op,
    pointer ptr)
{
	xorgHWFlags *flag;

	switch (op) {
	case GET_REQUIRED_HW_INTERFACES:
		flag = (CARD32*)ptr;
		(*flag) = 0;
		return TRUE;
	default:
		return FALSE;
	}
}
@


1.35
log
@Remove unused variables
@
text
@d1 1
a1 1
/* $OpenBSD: wsfb_driver.c,v 1.34 2014/07/13 14:01:30 matthieu Exp $ */
d156 1
a156 1
	WSFB_DRIVER_NAME,
d369 2
a370 2
				pScrn->driverName = WSFB_DRIVER_NAME;
				pScrn->name = WSFB_NAME;
d590 1
a590 1
		rgb zeros = { 0, 0, 0 }, masks;
d641 1
a641 1
		if (!xf86SetWeight(pScrn, zeros, masks))
d665 1
a665 1
	pScrn->chipset   = "wsfb";
d728 1
a728 1
	mode->name = "wsfb current mode";
@


1.34
log
@Remove obsolete #ifdef HAVE_XF1BPP and #ifdef HAVE_XF4BPP blocks,
@
text
@d1 1
a1 1
/* $OpenBSD: wsfb_driver.c,v 1.33 2014/07/13 10:13:19 matthieu Exp $ */
a397 1
	const char *reqSym = NULL;
a1372 1
	int scrnIdx = pScrn->pScreen->myNum;
@


1.33
log
@Merge from upstream: the shadow*Weak() functions are going away.
@
text
@d1 1
a1 1
/* $OpenBSD: wsfb_driver.c,v 1.32 2014/04/15 05:48:38 matthieu Exp $ */
a63 6
#ifdef HAVE_XF1BPP
# include "xf1bpp.h"
#endif
#ifdef HAVE_XF4BPP
# include "xf4bpp.h"
#endif
d397 1
a397 1
	char *mod = NULL, *s;
a756 19
	/* Load bpp-specific modules. */
	switch(pScrn->bitsPerPixel) {
#ifdef HAVE_XF1BPP
	case 1:
		mod = "xf1bpp";
		reqSym = "xf1bppScreenInit";
		break;
#endif
#ifdef HAVE_XF4BPP
	case 4:
		mod = "xf4bpp";
		reqSym = "xf4bppScreenInit";
		break;
#endif
	default:
		mod = "fb";
		break;
	}

d767 1
a767 1
	if (mod && xf86LoadSubModule(pScrn, mod) == NULL) {
a946 7
#ifdef HAVE_XF1BPP
		ret = xf1bppScreenInit(pScreen, fPtr->fbstart,
				       pScrn->virtualX, pScrn->virtualY,
				       pScrn->xDpi, pScrn->yDpi,
				       fPtr->linebytes * 8);
		break;
#endif
a947 7
#ifdef HAVE_XF4BPP
		ret = xf4bppScreenInit(pScreen, fPtr->fbstart,
				       pScrn->virtualX, pScrn->virtualY,
				       pScrn->xDpi, pScrn->yDpi,
				       fPtr->linebytes * 2);
		break;
#endif
@


1.32
log
@Do not return FALSE in void function. From drahn@@bitrig.
@
text
@d1 1
a1 1
/* $OpenBSD: wsfb_driver.c,v 1.31 2014/01/15 11:15:59 aoyama Exp $ */
d156 1
a156 1
#define WSFB_VERSION 		4000
d349 1
a349 1
       	GDevPtr *devSections;
d800 12
d830 1
a830 1
		shadowUpdateRotatePackedWeak() : shadowUpdatePackedWeak(),
d1043 1
a1043 1
		xf86DrvMsg(pScrn->scrnIndex, X_INFO, 
@


1.31
log
@Add more luna88k-specific initialization to use color wscons and
monochrome X server both.

Now OpenBSD/luna88k kernel supports color wscons on 4/8bpp frame
buffer, but X server only supports 1bpp (monochrome) for now.  So
change `pseudo' depth by WSDISPLAYIO_SETGFXMODE ioctl while X server
is running.
@
text
@d1 1
a1 1
/* $OpenBSD: wsfb_driver.c,v 1.30 2013/07/15 13:23:17 aoyama Exp $ */
d1365 1
a1365 1
			return FALSE;
@


1.30
log
@Add monochrome X server support for luna88k.

Some luna88k specific quirks are needed in
driver/xf86-video-wsfb/src/wsfb_driver.c for now.

ok matthieu@@
@
text
@d1 1
a1 1
/* $OpenBSD: wsfb_driver.c,v 1.29 2013/05/12 13:06:25 matthieu Exp $ */
d534 16
d1353 15
@


1.29
log
@Remove calls to miInitializeBackingStore() and includes of mibstore.h

mibstore.h defines miInitializeBackingStore() as an empty stub, and
goes away in xserver 1.14.
@
text
@d1 1
a1 1
/* $OpenBSD: wsfb_driver.c,v 1.28 2012/09/09 09:47:36 matthieu Exp $ */
d238 1
d401 1
a401 1
	int defaultDepth, depths, flags24, wstype;
d431 1
a431 1
	if (ioctl(fPtr->fd, WSDISPLAYIO_GTYPE, &wstype) == -1) {
d499 1
a499 1
	if (wstype == WSDISPLAY_TYPE_PCIVGA) {
d583 1
a583 1
		switch (wstype) {
d740 4
d922 8
@


1.28
log
@Add compat-api.h for compatibility with xserver 1.13
@
text
@d1 1
a1 1
/* $OpenBSD: wsfb_driver.c,v 1.27 2012/01/01 16:07:38 matthieu Exp $ */
a56 1
#include "mibstore.h"
a1010 1
	miInitializeBackingStore(pScreen);
@


1.27
log
@Constify wsfb_open() argument.
@
text
@d1 1
a1 1
/* $OpenBSD: wsfb_driver.c,v 1.25 2011/11/05 14:51:18 matthieu Exp $ */
d82 2
d116 2
a117 2
static Bool WsfbScreenInit(int, ScreenPtr, int, char **);
static Bool WsfbCloseScreen(int, ScreenPtr);
d120 5
a124 5
static void WsfbPointerMoved(int, int, int);
static Bool WsfbEnterVT(int, int);
static void WsfbLeaveVT(int, int);
static Bool WsfbSwitchMode(int, DisplayModePtr, int);
static int WsfbValidMode(int, DisplayModePtr, Bool, int);
d247 1
a247 1
	void			(*PointerMoved)(int, int, int);
d783 1
a783 1
	ScrnInfoPtr pScrn = xf86Screens[pScreen->myNum];
d809 1
a809 1
	ScrnInfoPtr pScrn = xf86Screens[pScreen->myNum];
d821 1
a821 1
WsfbScreenInit(int scrnIndex, ScreenPtr pScreen, int argc, char **argv)
d823 1
a823 1
	ScrnInfoPtr pScrn = xf86Screens[pScreen->myNum];
d990 1
a990 1
		xf86DrvMsg(scrnIndex, X_ERROR,
d999 1
a999 1
		xf86DrvMsg(scrnIndex, X_INFO, "Rotated display, "
d1003 2
a1004 2
		xf86DrvMsg(scrnIndex, X_INFO, "Enabling Driver Rotation, "
		    "disabling RandR\n");
d1007 1
a1007 1
			xf86DrvMsg(scrnIndex, X_WARNING,
d1059 1
a1059 1
WsfbCloseScreen(int scrnIndex, ScreenPtr pScreen)
d1061 1
a1061 1
	ScrnInfoPtr pScrn = xf86Screens[scrnIndex];
d1093 1
a1093 1
	return (*pScreen->CloseScreen)(scrnIndex, pScreen);
d1100 1
a1100 1
	ScrnInfoPtr pScrn = xf86Screens[pScreen->myNum];
d1114 1
a1114 1
WsfbPointerMoved(int index, int x, int y)
d1116 1
a1116 1
    ScrnInfoPtr pScrn = xf86Screens[index];
d1148 1
a1148 1
    (*fPtr->PointerMoved)(index, newX, newY);
d1152 1
a1152 1
WsfbEnterVT(int scrnIndex, int flags)
d1154 1
a1154 1
	ScrnInfoPtr pScrn = xf86Screens[scrnIndex];
d1174 1
a1174 1
WsfbLeaveVT(int scrnIndex, int flags)
d1176 1
a1176 1
	ScrnInfoPtr pScrn = xf86Screens[scrnIndex];
a1178 1

a1179 1

d1184 1
a1184 1
WsfbSwitchMode(int scrnIndex, DisplayModePtr mode, int flags)
d1187 1
a1187 1
	ScrnInfoPtr pScrn = xf86Screens[scrnIndex];
d1196 1
a1196 1
WsfbValidMode(int scrnIndex, DisplayModePtr mode, Bool verbose, int flags)
d1199 1
a1199 1
	ScrnInfoPtr pScrn = xf86Screens[scrnIndex];
d1265 1
a1265 1
	ScrnInfoPtr pScrn = xf86Screens[pScreen->myNum];
d1373 1
a1373 1
	if (!(*pScrn->SwitchMode)(scrnIdx, pMode, 0))
d1375 1
a1375 1
	(*pScrn->AdjustFrame)(scrnIdx, frameX0, frameY0, 0);
d1383 1
a1383 1
	(*pScrn->AdjustFrame)(pScrn->pScreen->myNum, x, y, flags);
@


1.26
log
@white space cleanup, copyright update, autotools regen.
@
text
@d140 1
a140 1
static int wsfb_open(char *);
d295 1
a295 1
wsfb_open(char *dev)
d349 1
a349 1
	char *dev;
d400 2
a401 2
	char *dev, *s;
	char *mod = NULL;
@


1.25
log
@unifdef XFree86LOADER, this isn't optional anymore.
@
text
@d1 1
a1 1
/* $OpenBSD: wsfb_driver.c,v 1.24 2011/11/05 14:40:51 matthieu Exp $ */
d3 1
a3 1
 * Copyright (c) 2001 Matthieu Herrb
d150 1
a150 1
 * This is intentionally screen-independent. 
d194 2
a195 2
	PACKAGE_VERSION_MAJOR, 
	PACKAGE_VERSION_MINOR, 
d214 1
a214 1
	                strcmp(osname, "netbsd") != 0)) {
d439 1
a439 1
	if (ioctl(fPtr->fd, WSDISPLAYIO_GETSUPPORTEDDEPTH, 
d454 1
a454 1
		
d473 1
a473 1
			 * but with less than 8 bits per pixel. 
d480 1
a480 1
			defaultDepth = 
d485 1
a485 1
		else 
d492 1
a492 1
	
d502 2
a503 2
			
			if (sscanf(pScrn->display->modes[0], "%dx%d", 
d506 1
a506 1
				    "Can't parse mode name %s\n", 
d511 1
a511 1
			if (ioctl(fPtr->fd, WSDISPLAYIO_SETGFXMODE, 
d514 1
a514 1
				    "ioctl WSDISPLAY_SETGFXMODE: %s\n", 
d567 1
a567 1
		    "framebuffer depth (%d)\n", pScrn->depth, 
d652 1
a652 1
	else 
d712 1
a712 1
	
d904 1
a904 1
	if (fPtr->rotate == WSFB_ROTATE_CW 
d920 1
a920 1
		
d994 1
a994 1
	if (!fPtr->rotate) 
d996 1
a996 1
	else 
d1004 2
a1005 2
		if (pScrn->bitsPerPixel == 24) 
			xf86DrvMsg(scrnIndex, X_WARNING, 
d1067 1
a1067 1
	if (fPtr->shadowFB) 
d1157 1
a1157 1
	
d1276 1
a1276 1
		                            WSDISPLAYIO_VIDEO_OFF;
d1482 1
a1482 1
	
a1491 1

@


1.24
log
@Replace deprecated xalloc/xfree with malloc/free.
@
text
@d1 1
a1 1
/* $OpenBSD: wsfb_driver.c,v 1.23 2010/08/29 15:20:40 matthieu Exp $ */
a106 1
#ifdef XFree86LOADER
a107 1
#endif
a187 1
#ifdef XFree86LOADER
a230 1
#endif /* XFree86LOADER */
@


1.23
log
@Add missing headers for ioctl() and getpagesize() prototypes.
@
text
@d1 1
a1 1
/* $OpenBSD: wsfb_driver.c,v 1.22 2010/07/18 20:10:12 matthieu Exp $ */
d280 1
a280 1
	xfree(pScrn->driverPrivate);
d394 1
a394 1
	xfree(devSections);
d541 1
a541 1
		    (unsigned char *)xalloc(fPtr->info.cmsize);
d548 1
a548 1
		    (unsigned char *)xalloc(fPtr->info.cmsize);
d552 1
a552 1
			xfree(fPtr->saved_cmap.red);
d556 1
a556 1
		    (unsigned char *)xalloc(fPtr->info.cmsize);
d560 2
a561 2
			xfree(fPtr->saved_cmap.red);
			xfree(fPtr->saved_cmap.green);
d666 2
a667 1
	if (!(fPtr->Options = xalloc(sizeof(WsfbOptions))))
d718 1
a718 1
	mode = (DisplayModePtr)xalloc(sizeof(DisplayModeRec));
d922 1
a922 1
		fPtr->shadow = xcalloc(1, pScrn->virtualX * pScrn->virtualY *
d1085 1
a1085 1
		xfree(fPtr->pDGAMode);
d1417 1
a1417 1
		pDGAMode = xrealloc(fPtr->pDGAMode,
@


1.22
log
@Fix allocation size of shadow framebuffer. Use byes, not bits.
Since the shadowfb is only used for bitsPerPixel >= 8, bitsPerPixel/8
is always the correct amount of bytes. ok miod@@.
@
text
@d1 1
a1 1
/* $OpenBSD: wsfb_driver.c,v 1.21 2010/07/17 17:15:14 matthieu Exp $ */
d45 2
@


1.21
log
@Do not call shawdowRemove() if shadow fb was disabled.
@
text
@d1 1
a1 1
/* $OpenBSD: wsfb_driver.c,v 1.20 2010/02/04 06:24:47 matthieu Exp $ */
d920 1
a920 1
		    pScrn->bitsPerPixel);
@


1.20
log
@Recognize WSDISPLAY_TYPE_SMFB
@
text
@d1 1
a1 1
/* $OpenBSD: wsfb_driver.c,v 1.19 2009/11/22 18:48:19 matthieu Exp $ */
d1068 2
a1069 1
	shadowRemove(pScreen, pPixmap);
@


1.19
log
@Update for resources/RAC API removal and bump to 0.3.0 to follow
upstreams numbering.
@
text
@d1 1
a1 1
/* $OpenBSD: wsfb_driver.c,v 1.18 2009/10/19 20:01:30 matthieu Exp $ */
d598 1
@


1.18
log
@pass the real framebuffer depth to xf86SetDepthBpp() instead of letting
it guess. This lets xf86-video-wsfb on TGA framebuffers on alpha
whithout setting weights and fbpp explicitely.
@
text
@d1 1
a1 1
/* $OpenBSD: wsfb_driver.c,v 1.17 2009/09/22 22:00:54 matthieu Exp $ */
d71 1
d74 1
a187 16
/* Symbols needed from other modules. */
static const char *fbSymbols[] = {
	"fbPictureInit",
	"fbScreenInit",
	NULL
};
static const char *shadowSymbols[] = {
	"shadowAdd",
	"shadowSetup",
	"shadowUpdatePacked",
	"shadowUpdatePackedWeak",
	"shadowUpdateRotatePacked",
	"shadowUpdateRotatePackedWeak",
	NULL
};

a224 1
		LoaderRefSymLists(fbSymbols, shadowSymbols, NULL);
d421 1
d424 1
a768 1
		xf86LoaderReqSymLists(shadowSymbols, NULL);
a772 7
	}
	if (mod) {
		if (reqSym) {
			xf86LoaderReqSymbols(reqSym, NULL);
		} else {
			xf86LoaderReqSymLists(fbSymbols, NULL);
		}
@


1.17
log
@XF86Config -> xorg.conf in comments.
@
text
@d1 1
a1 1
/* $OpenBSD: wsfb_driver.c,v 1.16 2009/09/13 19:33:49 matthieu Exp $ */
d508 2
a509 1
	if (!xf86SetDepthBpp(pScrn, defaultDepth, 0, 0, flags24))
@


1.16
log
@Call shadowRemove() in wsfbCloseScreen(). This fixes a free
memory dereference on exit. Hint by Daniel Stone. Thanks.
@
text
@d1 1
a1 1
/* $OpenBSD: wsfb_driver.c,v 1.15 2009/06/01 20:57:20 matthieu Exp $ */
d316 1
a316 1
	/* Try argument from XF86Config first. */
@


1.15
log
@Don't call xf1bpp or xf4bpp if they're not present (xorg-server-1.6 & later)
From  Alan Coopersmith <alan.coopersmith@@sun.com>.
@
text
@d1 1
a1 1
/* $OpenBSD: wsfb_driver.c,v 1.14 2008/09/29 22:04:43 matthieu Exp $ */
d1080 1
d1083 1
d1085 3
@


1.14
log
@Get rid of the old XFree86 libc wrapper.
@
text
@d1 1
a1 1
/* $OpenBSD: wsfb_driver.c,v 1.13 2008/01/20 18:45:06 jasper Exp $ */
d63 6
a68 2
#include "xf1bpp.h"
#include "xf4bpp.h"
d755 1
d760 2
d766 1
d950 1
d956 1
d958 1
d964 1
@


1.13
log
@add some missing TRACE_EXITs

ok matthieu@@
@
text
@d1 1
a1 1
/* $OpenBSD: wsfb_driver.c,v 1.12 2008/01/14 08:02:36 jasper Exp $ */
d43 1
d46 1
a52 1
#include "xf86_ansic.h"
a71 6
#endif

/* #include "wsconsio.h" */

#ifndef XFree86LOADER
#include <sys/mman.h>
@


1.12
log
@- tweak and clean up comments

ok matthieu@@
@
text
@d1 1
a1 1
/* $OpenBSD: wsfb_driver.c,v 1.11 2008/01/04 04:20:15 jsing Exp $ */
d1097 1
d1287 1
d1309 1
@


1.11
log
@Teach wsfb about WSDISPLAY_TYPE_GBE.

ok matthieu@@
@
text
@d1 1
a1 1
/* $OpenBSD: wsfb_driver.c,v 1.10 2007/03/03 09:44:22 matthieu Exp $ */
d48 1
a48 1
/* all driver need this */
d61 1
a61 1
/* for visuals */
d127 1
a127 1
/* dga stuff */
d138 1
a138 1
/* helper functions */
d149 2
a150 2
 * This is intentionally screen-independent.  It indicates the binding
 * choice made in the first PreInit.
d187 1
a187 1
/* Symbols needed from other modules */
d227 1
a227 1
	/* Check that we're being loaded on a OpenBSD or NetBSD system */
d250 1
a250 1
/* private data */
d252 3
a254 3
	int			fd; /* file descriptor of open device */
	struct wsdisplay_fbinfo info; /* frame buffer characteristics */
	int			linebytes; /* number of bytes per row */
d311 1
a311 1
/* Open the framebuffer device */
d317 1
a317 1
	/* try argument from XF86Config first */
d319 1
a319 1
		/* second: environment variable */
d322 1
a322 1
			/* last try: default device */
d332 1
a332 1
/* Map the framebuffer's memory */
d345 1
a345 1
	 * try and make it private first, that way once we get it, an
d452 1
a452 1
	 * depth
d513 1
a513 1
		/* Set specified mode */
d548 1
a548 1
	 * Allocate room for saving the colormap 
d578 1
a578 1
	/* Check consistency */
d588 1
a588 1
	/* Get the depth24 pixmap format */
d592 1
a592 1
	/* color weight */
d648 1
a648 1
	/* visual init */
d652 1
a652 1
	/* We don't currently support DirectColor at > 8bpp */
d674 1
a674 1
	/* handle options */
d682 1
a682 1
	/* use shadow framebuffer by default, on depth >= 8 */
d693 1
a693 1
	/* rotation */
d726 1
a726 1
	/* fake video mode struct */
d751 1
a751 1
	/* Set the display resolution */
d754 1
a754 1
	/* Load bpp-specific modules */
d770 1
a770 1
	/* Load shadow if needed */
d887 1
a887 1
	/* Switch to graphics mode - required before mmap */
d906 1
a906 1
	/* mi layer */
d981 1
a981 1
		/* Fixup RGB ordering */
d1026 1
a1026 1
	/* software cursor */
d1041 1
a1041 1
	/* on StaticGray visuals, fake a 256 entries colormap */
d1061 1
a1061 1
	/* Wrap the current CloseScreen function */
d1095 1
a1095 1
	/* unwrap CloseScreen */
d1164 1
a1164 1
	/* Switch to graphics mode */
d1197 1
a1197 1
	/* Nothing else to do */
d1237 4
a1240 2
		/* Change all colors in 2 ioctls */
		/* and limit the data to be transfered */
d1252 1
a1252 1
		/* Get current map */
d1255 1
a1255 1
		/* Change the colors that require updating */
d1261 1
a1261 1
		/* Write the colormap back */
d1328 1
a1328 1
	/* Clear the screen */
d1331 1
a1331 1
	/* Restore the text mode */
@


1.10
log
@merge X.Org version 0.2.1
@
text
@d1 1
a1 1
/* $OpenBSD: wsfb_driver.c,v 1.1.1.2 2007/03/03 09:39:06 matthieu Exp $ */
d605 1
@


1.9
log
@Revert some bits of previous commit that leaked in by accident.
@
text
@d1 1
a1 1
/* $OpenBSD: wsfb_driver.c,v 1.8 2007/01/02 13:54:05 matthieu Exp $ */
a156 2
#define WSFB_MAJOR_VERSION	0
#define WSFB_MINOR_VERSION	2
d210 3
a212 1
	WSFB_MAJOR_VERSION, WSFB_MINOR_VERSION, 0,
@


1.8
log
@Fix shadowfb initialisation again, from X.Org -current.
@
text
@d1 1
a1 1
/* $OpenBSD: wsfb_driver.c,v 1.7 2006/12/08 21:57:37 matthieu Exp $ */
a45 3
#include <sys/param.h>
#include <sys/sysctl.h>
#include <machine/cpu.h>
d91 1
a91 1
#define DEBUG 1
d364 1
a364 2
	int i, fd, entity, mib[2], allowaperture;
	size_t len;
a379 13
#ifdef CPU_ALLOWAPERTURE
	mib[0] = CTL_MACHDEP;
	mib[1] = CPU_ALLOWAPERTURE;
	len = sizeof(allowaperture);
	if (sysctl(mib, 2, &allowaperture, &len, NULL, 0) == -1) {
		ErrorF("sysctl: %s\n", strerror(errno));
		return FALSE;
	}
	if (allowaperture > 0) {
		/* Don't attach if aperture driver is active */
		return FALSE;
	}
#endif
a409 3
#if DEBUG
	ErrorF("foundScreen: %d\n", foundScreen);
#endif
a512 3
		struct wsdisplay_gfx_mode gfxmode;
	
		gfxmode.depth = pScrn->bitsPerPixel;
d516 1
d525 8
a532 10
		} else {
			gfxmode.width = 1024;
			gfxmode.height = 768;
		}
		if (ioctl(fPtr->fd, WSDISPLAYIO_SETGFXMODE, 
			&gfxmode) == -1) {
			xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
			    "ioctl WSDISPLAY_SETGFXMODE: %s\n", 
			    strerror(errno));
			return FALSE;
@


1.7
log
@Remove a debugging printf
@
text
@d1 1
a1 1
/* $OpenBSD: wsfb_driver.c,v 1.6 2006/12/03 17:04:08 matthieu Exp $ */
d46 3
d94 1
a94 1
#define DEBUG 0
d263 1
d265 1
d367 2
a368 1
	int i, fd, entity;
d384 13
d427 3
d533 3
a538 1
			struct wsdisplay_gfx_mode gfxmode;
d547 10
a556 8
			gfxmode.depth = pScrn->bitsPerPixel;
			if (ioctl(fPtr->fd, WSDISPLAYIO_SETGFXMODE, 
				&gfxmode) == -1) {
				xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
				    "ioctl WSDISPLAY_SETGFXMODE: %s\n", 
				    strerror(errno));
				return FALSE;
			}
d819 40
d864 1
a864 1
	int ret, flags, width, height, ncolors;
d946 3
a948 5
		height = pScrn->virtualX;
		width = pScrn->displayWidth = pScrn->virtualY;
	} else {
		height = pScrn->virtualY;
		width = pScrn->virtualX;
d957 11
d971 1
a971 1
				       width, height,
d977 1
a977 1
				       width, height,
d986 4
a989 5
				   fPtr->fbstart,
				   width, height,
				   pScrn->xDpi, pScrn->yDpi,
				   pScrn->displayWidth,
				   pScrn->bitsPerPixel);
d1023 4
a1026 23
	if (fPtr->shadowFB) {
		PixmapPtr pPixmap;

		if (pScrn->bitsPerPixel < 8) {
			xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
				   "Shadow FB not available on < 8 depth");
		} else {
			pPixmap = pScreen->CreatePixmap(pScreen, 
			    pScreen->width, pScreen->height,
			    pScreen->rootDepth);
			if (!pPixmap)
				return FALSE;
    			if (!shadowSetup(pScreen) ||
			    !shadowAdd(pScreen, pPixmap,
				fPtr->rotate ? shadowUpdateRotatePackedWeak() :
				shadowUpdatePackedWeak(),
				WsfbWindowLinear, fPtr->rotate, NULL)) {
				xf86DrvMsg(scrnIndex, X_ERROR,
				    "Shadow FB initialization failed\n");
				pScreen->DestroyPixmap(pPixmap);
				return FALSE;
			}
		}
@


1.6
log
@lost one _X_EXPORT from X.Org in local changes merge.
@
text
@d1 1
a1 1
/* $OpenBSD: wsfb_driver.c,v 1.5 2006/12/03 16:36:56 matthieu Exp $ */
a955 3
			ErrorF("XXX w %d h %d d %d\n",
			    pScreen->width, pScreen->height,
			    pScreen->rootDepth);
@


1.5
log
@Change XF86_VERSION_CURRENT to XORG_VERSION_CURRENT in WsfbVersRec
(From  Alan Coopersmith via X.Org git repository).
@
text
@d1 1
a1 1
/* $OpenBSD: wsfb_driver.c,v 1.4 2006/12/03 16:32:48 matthieu Exp $ */
d160 1
a160 1
DriverRec WSFB = {
@


1.4
log
@Adapt wsfb to shadowfb changes in X.Org 7.2.
@
text
@d1 1
a1 1
/* $OpenBSD: wsfb_driver.c,v 1.3 2006/11/29 20:07:10 matthieu Exp $ */
d211 1
a211 1
	XF86_VERSION_CURRENT,
@


1.3
log
@Add support for vesafb to the wsfb driver. This makes it possible to
run an unaccelerated and unprivileged X server
with machdep.allowaperture=0 on i386.
@
text
@d1 1
a1 1
/* $OpenBSD: wsfb_driver.c,v 1.2 2006/11/28 19:59:08 matthieu Exp $ */
d154 1
a154 1
#define VERSION			4000
d158 1
a158 1
#define WSFB_MINOR_VERSION	1
d161 1
a161 1
	VERSION,
d196 2
a197 2
	"shadowAlloc",
	"shadowInit",
a257 1
	unsigned char*		shadowmem;
d388 1
a388 1
				pScrn->driverVersion = VERSION;
d891 1
a891 5
	/* shadowfb */
	if (fPtr->shadowFB) {
		if ((fPtr->shadowmem = shadowAlloc(width, height,
						   pScrn->bitsPerPixel)) == NULL)
		return FALSE;
a892 5
		fPtr->fbstart   = fPtr->shadowmem;
	} else {
		fPtr->shadowmem = NULL;
		fPtr->fbstart   = fPtr->fbmem;
	}
d950 2
d956 10
a965 2
			if (!shadowSetup(pScreen) ||
			    !shadowAdd(pScreen, NULL,
d971 1
a1056 2
	if (fPtr->shadowmem)
		xfree(fPtr->shadowmem);
@


1.2
log
@Sync with XF4
@
text
@d1 1
a1 1
/* $OpenBSD: wsfb_driver.c,v 1.31 2006/09/21 13:33:06 matthieu Exp $ */
d416 1
a416 1
	int default_depth, wstype;
d444 1
a444 2

	if (ioctl(fPtr->fd, WSDISPLAYIO_GINFO, &fPtr->info) == -1) {
d446 1
a446 1
			   "ioctl WSDISPLAY_GINFO: %s\n",
d450 85
a534 1
	if (ioctl(fPtr->fd, WSDISPLAYIO_GTYPE, &wstype) == -1) {
d536 2
a537 2
			   "ioctl WSDISPLAY_GTYPE: %s\n",
			   strerror(errno));
a575 19
	/*
	 * Handle depth
	 */
	if (fPtr->info.depth == 8) {
		/*
		 * We might run on a byte addressable frame buffer,
		 * but with less than 8 bits per pixel. We can know this
		 * from the colormap size.
		 */
		default_depth = 1;
		while ((1 << default_depth) < fPtr->info.cmsize)
			default_depth++;
	} else
		default_depth = fPtr->info.depth <= 24 ? fPtr->info.depth : 24;

	if (!xf86SetDepthBpp(pScrn, default_depth, default_depth,
		fPtr->info.depth,
		fPtr->info.depth >= 24 ? Support24bppFb|Support32bppFb : 0))
		return FALSE;
d624 11
d723 1
d743 1
a743 4
	if (pScrn->modes != NULL) {
		xf86DrvMsg(pScrn->scrnIndex, X_INFO,
		   "Ignoring mode specification from screen section\n");
	}
d806 1
a806 1
	       "\tmask: %x,%x,%x, offset: %d,%d,%d\n",
d826 7
d918 1
d933 3
a935 1
	if (!ret)
d937 1
d1131 2
d1135 9
d1145 1
a1151 1
#if DEBUG
a1152 1
#endif
d1155 4
d1235 1
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/* $OpenBSD: wsfb_driver.c,v 1.19 2003/04/27 16:42:32 matthieu Exp $ */
d79 1
a79 1
#ifdef USE_PRIVSEP
d117 1
d142 6
d154 1
a154 1
#define WSFB_VERSION		4000
d160 2
a161 2
_X_EXPORT DriverRec WSFB = {
	WSFB_VERSION,
d180 1
d185 1
d196 1
d198 1
d200 2
d258 2
d262 1
a264 3
	unsigned char		saved_red[256];
	unsigned char		saved_green[256];
	unsigned char		saved_blue[256];
d417 1
a417 1
	char *dev;
d463 44
a507 2
	/* Handle depth */
	default_depth = fPtr->info.depth <= 24 ? fPtr->info.depth : 24;
d531 9
a539 5
		if (wstype == WSDISPLAY_TYPE_SUN24 ||
		    wstype == WSDISPLAY_TYPE_SUNCG12 ||
		    wstype == WSDISPLAY_TYPE_SUNCG14 ||
		    wstype == WSDISPLAY_TYPE_SUNTCX ||
		    wstype == WSDISPLAY_TYPE_SUNFFB) {
d543 18
a560 1
		} else {
d564 1
d587 4
a590 1
	pScrn->rgbBits   = 8;
d592 1
a592 2
	pScrn->videoRam  = fPtr->linebytes * fPtr->info.height
		* fPtr->info.depth;
d613 1
a613 1
				   "Shadow FB option ignored on depth 1");
d616 32
d726 1
a726 1
	int ret, flags, width, height;
d742 1
d799 12
a810 2
	height = pScrn->virtualY;
	width = pScrn->virtualX;
d812 5
a816 1
	fPtr->fbstart   = fPtr->fbmem;
d818 5
d828 1
a828 1
				       pScrn->displayWidth);
d834 1
a834 1
				       pScrn->displayWidth);
d870 1
a870 1
	if (pScrn->bitsPerPixel > 8) {
d880 9
a888 3
			if (!shadowInit(pScreen, shadowUpdatePackedWeak(),
					WsfbWindowLinear))
			return FALSE;
d893 5
a897 1
	WsfbDGAInit(pScrn, pScreen);
d899 8
d915 8
a922 1
	/* colormap */
d925 6
a930 2
		flags = CMAP_RELOAD_ON_MODE_SWITCH;
	if(!xf86HandleColormaps(pScreen, 256, 8, WsfbLoadPalette,
d972 2
d1005 38
d1111 1
a1111 1
		/* Change all colors in 2 syscalls */
d1167 4
d1172 1
a1172 4
	fPtr->saved_cmap.count = 256;
	fPtr->saved_cmap.red = fPtr->saved_red;
	fPtr->saved_cmap.green = fPtr->saved_green;
	fPtr->saved_cmap.blue = fPtr->saved_blue;
d1189 8
a1196 10
	/* reset colormap for text mode */
	fPtr->saved_cmap.index = 0;
	fPtr->saved_cmap.count = 256;
	fPtr->saved_cmap.red = fPtr->saved_red;
	fPtr->saved_cmap.green = fPtr->saved_green;
	fPtr->saved_cmap.blue = fPtr->saved_blue;
	if (ioctl(fPtr->fd, WSDISPLAYIO_PUTCMAP,
		  &(fPtr->saved_cmap)) == -1) {
		xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
			   "error restoring colormap %s\n", strerror(errno));
@


1.1.1.1
log
@Importing xf86-video-wsfb 0.2.0
@
text
@@


1.1.1.2
log
@Import xf86-video-wsfb version 0.2.1
@
text
@a116 1
static void WsfbPointerMoved(int, int, int);
a140 6
enum { WSFB_ROTATE_NONE = 0,
       WSFB_ROTATE_CCW = 90,
       WSFB_ROTATE_UD = 180,
       WSFB_ROTATE_CW = 270
};

d147 1
a147 1
#define WSFB_VERSION 		4000
d150 2
a172 1
	OPTION_ROTATE
a176 1
	{ OPTION_ROTATE, "Rotate", OPTV_STRING, {0}, FALSE},
d187 1
a187 3
	"shadowAdd",
	"shadowSetup",
	"shadowUpdatePacked",
a188 2
	"shadowUpdateRotatePacked",
	"shadowUpdateRotatePackedWeak",
d198 2
a199 4
	XORG_VERSION_CURRENT,
	PACKAGE_VERSION_MAJOR, 
	PACKAGE_VERSION_MINOR, 
	PACKAGE_VERSION_PATCHLEVEL,
a244 1
	int			rotate;
a245 1
	void *			shadow;
a246 2
	CreateScreenResourcesProcPtr CreateScreenResources;
	void			(*PointerMoved)(int, int, int);
d249 3
d376 1
a376 1
				pScrn->driverVersion = WSFB_VERSION;
d404 1
a404 1
	char *dev, *s;
a449 29
	/*
	 * Allocate room for saving the colormap 
	 */
	if (fPtr->info.cmsize != 0) {
		fPtr->saved_cmap.red =
		    (unsigned char *)xalloc(fPtr->info.cmsize);
		if (fPtr->saved_cmap.red == NULL) {
			xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
			    "Cannot malloc %d bytes\n", fPtr->info.cmsize);
			return FALSE;
		}
		fPtr->saved_cmap.green =
		    (unsigned char *)xalloc(fPtr->info.cmsize);
		if (fPtr->saved_cmap.green == NULL) {
			xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
			    "Cannot malloc %d bytes\n", fPtr->info.cmsize);
			xfree(fPtr->saved_cmap.red);
			return FALSE;
		}
		fPtr->saved_cmap.blue =
		    (unsigned char *)xalloc(fPtr->info.cmsize);
		if (fPtr->saved_cmap.blue == NULL) {
			xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
			    "Cannot malloc %d bytes\n", fPtr->info.cmsize);
			xfree(fPtr->saved_cmap.red);
			xfree(fPtr->saved_cmap.green);
			return FALSE;
		}
	}
d512 2
a513 1
	pScrn->videoRam  = fPtr->linebytes * fPtr->info.height;
d534 1
a534 1
				   "Shadow FB option ignored on depth < 8");
a536 33
	/* rotation */
	fPtr->rotate = WSFB_ROTATE_NONE;
	if ((s = xf86GetOptValString(fPtr->Options, OPTION_ROTATE))) {
		if (pScrn->depth >= 8) {
			if (!xf86NameCmp(s, "CW")) {
				fPtr->shadowFB = TRUE;
				fPtr->rotate = WSFB_ROTATE_CW;
				xf86DrvMsg(pScrn->scrnIndex, X_CONFIG,
				    "Rotating screen clockwise\n");
			} else if (!xf86NameCmp(s, "CCW")) {
				fPtr->shadowFB = TRUE;
				fPtr->rotate = WSFB_ROTATE_CCW;
				xf86DrvMsg(pScrn->scrnIndex, X_CONFIG,
				    "Rotating screen counter clockwise\n");
			} else if (!xf86NameCmp(s, "UD")) {
				fPtr->shadowFB = TRUE;
				fPtr->rotate = WSFB_ROTATE_UD;
				xf86DrvMsg(pScrn->scrnIndex, X_CONFIG,
				    "Rotating screen upside down\n");
			} else {
				xf86DrvMsg(pScrn->scrnIndex, X_CONFIG,
				    "\"%s\" is not a valid value for Option "
				    "\"Rotate\"\n", s);
				xf86DrvMsg(pScrn->scrnIndex, X_INFO,
				    "Valid options are \"CW\", \"CCW\","
				    " or \"UD\"\n");
			}
		} else {
			xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
			    "Option \"Rotate\" ignored on depth < 8");
		}
	}
	
a609 40
WsfbCreateScreenResources(ScreenPtr pScreen)
{
	ScrnInfoPtr pScrn = xf86Screens[pScreen->myNum];
	WsfbPtr fPtr = WSFBPTR(pScrn);
	PixmapPtr pPixmap;
	Bool ret;

	pScreen->CreateScreenResources = fPtr->CreateScreenResources;
	ret = pScreen->CreateScreenResources(pScreen);
	pScreen->CreateScreenResources = WsfbCreateScreenResources;

	if (!ret)
		return FALSE;

	pPixmap = pScreen->GetScreenPixmap(pScreen);

	if (!shadowAdd(pScreen, pPixmap, fPtr->rotate ?
		shadowUpdateRotatePackedWeak() : shadowUpdatePackedWeak(),
		WsfbWindowLinear, fPtr->rotate, NULL)) {
		return FALSE;
	}
	return TRUE;
}


static Bool
WsfbShadowInit(ScreenPtr pScreen)
{
	ScrnInfoPtr pScrn = xf86Screens[pScreen->myNum];
	WsfbPtr fPtr = WSFBPTR(pScrn);

	if (!shadowSetup(pScreen))
		return FALSE;
	fPtr->CreateScreenResources = pScreen->CreateScreenResources;
	pScreen->CreateScreenResources = WsfbCreateScreenResources;

	return TRUE;
}

static Bool
d615 1
a615 1
	int ret, flags, ncolors;
d622 1
a622 1
	       "\tmask: %x,%x,%x, offset: %u,%u,%u\n",
a630 1
	case 4:
a640 7
	case 24:
		if (fPtr->linebytes == fPtr->info.width) {
			len = fPtr->info.width*fPtr->info.height*3;
		} else {
			len = fPtr->linebytes*fPtr->info.height;
		}
		break;
d687 2
a688 10
	if (fPtr->rotate == WSFB_ROTATE_CW 
	    || fPtr->rotate == WSFB_ROTATE_CCW) {
		int tmp = pScrn->virtualX;
		pScrn->virtualX = pScrn->displayWidth = pScrn->virtualY;
		pScrn->virtualY = tmp;
	}
	if (fPtr->rotate && !fPtr->PointerMoved) {
		fPtr->PointerMoved = pScrn->PointerMoved;
		pScrn->PointerMoved = WsfbPointerMoved;
	}
d690 1
a690 1
	fPtr->fbstart = fPtr->fbmem;
d695 1
a695 1
				       pScrn->virtualX, pScrn->virtualY,
d701 1
a701 1
				       pScrn->virtualX, pScrn->virtualY,
a706 1
	case 24:
d709 5
a713 4
		    fPtr->shadowFB ? fPtr->shadow : fPtr->fbstart,
		    pScrn->virtualX, pScrn->virtualY,
		    pScrn->xDpi, pScrn->yDpi,
		    pScrn->displayWidth, pScrn->bitsPerPixel);
d739 1
a739 1
	if (pScrn->bitsPerPixel >= 8) {
d744 9
a752 4
	if (fPtr->shadowFB && !WsfbShadowInit(pScreen)) {
		xf86DrvMsg(scrnIndex, X_ERROR,
		    "shadow framebuffer initialization failed\n");
		return FALSE;
d756 1
a756 5
	if (!fPtr->rotate) 
		WsfbDGAInit(pScrn, pScreen);
	else 
		xf86DrvMsg(scrnIndex, X_INFO, "Rotated display, "
		    "disabling DGA\n");
a757 8
	if (fPtr->rotate) {
		xf86DrvMsg(scrnIndex, X_INFO, "Enabling Driver Rotation, "
		    "disabling RandR\n");
		xf86DisableRandR();
		if (pScrn->bitsPerPixel == 24) 
			xf86DrvMsg(scrnIndex, X_WARNING, 
			    "Rotation might be broken in 24 bpp\n");
	}
d769 2
a770 6
	flags = CMAP_RELOAD_ON_MODE_SWITCH;
	ncolors = fPtr->info.cmsize;
	/* on StaticGray visuals, fake a 256 entries colormap */
	if (ncolors == 0)
		ncolors = 256;
	if(!xf86HandleColormaps(pScreen, ncolors, 8, WsfbLoadPalette,
a842 38
static void
WsfbPointerMoved(int index, int x, int y)
{
    ScrnInfoPtr pScrn = xf86Screens[index];
    WsfbPtr fPtr = WSFBPTR(pScrn);
    int newX, newY;

    switch (fPtr->rotate)
    {
    case WSFB_ROTATE_CW:
	/* 90 degrees CW rotation. */
	newX = pScrn->pScreen->height - y - 1;
	newY = x;
	break;

    case WSFB_ROTATE_CCW:
	/* 90 degrees CCW rotation. */
	newX = y;
	newY = pScrn->pScreen->width - x - 1;
	break;

    case WSFB_ROTATE_UD:
	/* 180 degrees UD rotation. */
	newX = pScrn->pScreen->width - x - 1;
	newY = pScrn->pScreen->height - y - 1;
	break;

    default:
	/* No rotation. */
	newX = x;
	newY = y;
	break;
    }

    /* Pass adjusted pointer coordinates to wrapped PointerMoved function. */
    (*fPtr->PointerMoved)(index, newX, newY);
}

a936 1
	TRACE_EXIT("LoadPalette");
a966 4

	if (fPtr->info.cmsize == 0)
		return;

d968 4
a971 1
	fPtr->saved_cmap.count = fPtr->info.cmsize;
d988 10
a997 8
	if (fPtr->info.cmsize != 0) {
		/* reset colormap for text mode */
		if (ioctl(fPtr->fd, WSDISPLAYIO_PUTCMAP,
			  &(fPtr->saved_cmap)) == -1) {
			xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
				   "error restoring colormap %s\n",
				   strerror(errno));
		}
@

