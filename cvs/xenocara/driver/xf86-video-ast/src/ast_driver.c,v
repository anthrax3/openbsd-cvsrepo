head	1.9;
access;
symbols
	OPENBSD_6_0:1.9.0.6
	OPENBSD_6_0_BASE:1.9
	OPENBSD_5_9:1.9.0.4
	OPENBSD_5_9_BASE:1.9
	OPENBSD_5_8:1.9.0.2
	OPENBSD_5_8_BASE:1.9
	OPENBSD_5_7:1.8.0.4
	OPENBSD_5_7_BASE:1.8
	OPENBSD_5_6:1.8.0.2
	OPENBSD_5_6_BASE:1.8
	v0_99_9:1.1.1.2
	OPENBSD_4_8:1.5.0.6
	OPENBSD_4_8_BASE:1.5
	OPENBSD_4_7:1.5.0.2
	OPENBSD_4_7_BASE:1.5
	OPENBSD_4_6:1.4.0.2
	OPENBSD_4_6_BASE:1.4
	OPENBSD_4_5:1.2.0.2
	OPENBSD_4_5_BASE:1.2
	OPENBSD_4_4:1.1.1.1.0.6
	OPENBSD_4_4_BASE:1.1.1.1
	OPENBSD_4_3_BASE:1.1.1.1
	OPENBSD_4_3:1.1.1.1.0.4
	OPENBSD_4_2:1.1.1.1.0.2
	OPENBSD_4_2_BASE:1.1.1.1
	v0_81_0:1.1.1.1
	xorg:1.1.1;
locks; strict;
comment	@ * @;


1.9
date	2015.05.24.09.17.25;	author matthieu;	state Exp;
branches;
next	1.8;
commitid	qBZygjuSMc2gFczl;

1.8
date	2014.04.13.10.36.51;	author matthieu;	state Exp;
branches;
next	1.7;

1.7
date	2010.11.29.21.17.47;	author matthieu;	state dead;
branches;
next	1.6;

1.6
date	2010.11.25.22.03.22;	author matthieu;	state Exp;
branches;
next	1.5;

1.5
date	2009.11.22.15.33.58;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2009.05.03.16.31.23;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2009.03.07.11.16.36;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2008.08.23.21.00.47;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.26.20.00.09;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.11.26.20.00.09;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2014.04.13.10.30.12;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.9
log
@Update to xf86-video-ast 1.0.1
@
text
@/*
 * Copyright (c) 2005 ASPEED Technology Inc.
 *
 * Permission to use, copy, modify, distribute, and sell this software and its
 * documentation for any purpose is hereby granted without fee, provided that
 * the above copyright notice appear in all copies and that both that
 * copyright notice and this permission notice appear in supporting
 * documentation, and that the name of the authors not be used in
 * advertising or publicity pertaining to distribution of the software without
 * specific, written prior permission.  The authors makes no representations
 * about the suitability of this software for any purpose.  It is provided
 * "as is" without express or implied warranty.
 *
 * THE AUTHORS DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
 * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO
 * EVENT SHALL THE AUTHORS BE LIABLE FOR ANY SPECIAL, INDIRECT OR
 * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
 * DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
 * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
 * PERFORMANCE OF THIS SOFTWARE.
 */

#ifdef HAVE_CONFIG_H
#include <config.h>
#endif
#include "xf86.h"
#include "xf86_OSproc.h"
#if GET_ABI_MAJOR(ABI_VIDEODRV_VERSION) < 6
#include "xf86Resources.h"
#include "xf86RAC.h"
#endif
#include "xf86cmap.h"
#include "compiler.h"
#include "vgaHW.h"
#include "mipointer.h"
#include "micmap.h"

#include "fb.h"
#include "regionstr.h"
#include "xf86xv.h"
#include <X11/extensions/Xv.h>

#include "xf86Pci.h"

/* framebuffer offscreen manager */
#include "xf86fbman.h"

/* include xaa includes */
#ifdef HAVE_XAA_H
#include "xaa.h"
#include "xaarop.h"
#endif

/* H/W cursor support */
#include "xf86Cursor.h"

/* Driver specific headers */
#include "ast.h"
#include "ast_mode.h"
#include "ast_vgatool.h"
#include "ast_2dtool.h"

/* Mandatory functions */
static void ASTIdentify(int flags);
const OptionInfoRec *ASTAvailableOptions(int chipid, int busid);
static Bool ASTProbe(DriverPtr drv, int flags);
static Bool ASTPreInit(ScrnInfoPtr pScrn, int flags);
static Bool ASTScreenInit(SCREEN_INIT_ARGS_DECL);
Bool ASTSwitchMode(SWITCH_MODE_ARGS_DECL);
void ASTAdjustFrame(ADJUST_FRAME_ARGS_DECL);
static Bool ASTEnterVT(VT_FUNC_ARGS_DECL);
static void ASTLeaveVT(VT_FUNC_ARGS_DECL);
static void ASTFreeScreen(FREE_SCREEN_ARGS_DECL);
static ModeStatus ASTValidMode(SCRN_ARG_TYPE arg, DisplayModePtr mode, Bool verbose, int flags);

/* Internally used functions */
static Bool ASTGetRec(ScrnInfoPtr pScrn);
static void ASTFreeRec(ScrnInfoPtr pScrn);
static Bool ASTSaveScreen(ScreenPtr pScreen, Bool unblack);
static Bool ASTCloseScreen(CLOSE_SCREEN_ARGS_DECL);
static void ASTSave(ScrnInfoPtr pScrn);
static void ASTRestore(ScrnInfoPtr pScrn);
static void ASTProbeDDC(ScrnInfoPtr pScrn, int index);
static xf86MonPtr ASTDoDDC(ScrnInfoPtr pScrn, int index);
static void vFillASTModeInfo (ScrnInfoPtr pScrn);
static Bool ASTModeInit(ScrnInfoPtr pScrn, DisplayModePtr mode);

#ifdef AstVideo
/* video function */
static void ASTInitVideo(ScreenPtr pScreen);
static int  ASTPutImage( ScrnInfoPtr,
        short, short, short, short, short, short, short, short,
        int, unsigned char*, short, short, Bool, RegionPtr, pointer
#if GET_ABI_MAJOR(ABI_VIDEODRV_VERSION) >= 1
		          , DrawablePtr pDraw
#endif
			 );
#endif

/*
 * This is intentionally screen-independent.  It indicates the binding
 * choice made in the first PreInit.
 */
_X_EXPORT DriverRec AST = {
   AST_VERSION,
   AST_DRIVER_NAME,
   ASTIdentify,
   ASTProbe,
   ASTAvailableOptions,
   NULL,
   0
};

/* Chipsets */
static SymTabRec ASTChipsets[] = {
   {PCI_CHIP_AST2000,	"ASPEED Graphics Family"},
   {PCI_CHIP_AST2100,	"ASPEED Graphics Family"},
   {PCI_CHIP_AST1180,	"ASPEED AST1180 Graphics"},
   {-1,			NULL}
};

static PciChipsets ASTPciChipsets[] = {
   {PCI_CHIP_AST2000,		PCI_CHIP_AST2000,	RES_SHARED_VGA},
   {PCI_CHIP_AST2100,		PCI_CHIP_AST2100,	RES_SHARED_VGA},
   {PCI_CHIP_AST1180,		PCI_CHIP_AST1180,	RES_SHARED_VGA},
   {-1,				-1, 			RES_UNDEFINED }
};

typedef enum {
   OPTION_NOACCEL,
   OPTION_MMIO2D,
   OPTION_SW_CURSOR,
   OPTION_HWC_NUM,
   OPTION_ENG_CAPS,
   OPTION_DBG_SELECT,
   OPTION_NO_DDC,
   OPTION_VGA2_CLONE,
   OPTION_SHADOW_FB
} ASTOpts;

static const OptionInfoRec ASTOptions[] = {
   {OPTION_NOACCEL,	      "NoAccel",	OPTV_BOOLEAN,	{0},	FALSE},
   {OPTION_MMIO2D,	       "MMIO2D",	OPTV_BOOLEAN,	{0},	FALSE},
   {OPTION_SW_CURSOR,	 "SWCursor",	OPTV_BOOLEAN,	{0},	FALSE},
   {OPTION_HWC_NUM,	    "HWCNumber",	OPTV_INTEGER,	{0},	FALSE},
   {OPTION_ENG_CAPS,	  "ENGCaps",	OPTV_INTEGER,	{0},	FALSE},
   {OPTION_DBG_SELECT,	"DBGSelect",	OPTV_INTEGER,	{0},	FALSE},
   {OPTION_NO_DDC,	        "NoDDC",	OPTV_BOOLEAN,	{0}, 	FALSE},
   {OPTION_VGA2_CLONE,	"VGA2Clone",	OPTV_BOOLEAN,	{0}, 	FALSE},
   {OPTION_SHADOW_FB,    "ShadowFB",	OPTV_BOOLEAN,	{0},	FALSE},
   {-1,			               NULL,	   OPTV_NONE,	{0}, 	FALSE}
};

#ifdef XFree86LOADER

static MODULESETUPPROTO(astSetup);

static XF86ModuleVersionInfo astVersRec = {
   AST_DRIVER_NAME,
   MODULEVENDORSTRING,
   MODINFOSTRING1,
   MODINFOSTRING2,
   XORG_VERSION_CURRENT,
   AST_MAJOR_VERSION, AST_MINOR_VERSION, AST_PATCH_VERSION,
   ABI_CLASS_VIDEODRV,
#ifdef PATCH_ABI_VERSION
   ABI_VIDEODRV_VERSION_PATCH,
#else
   ABI_VIDEODRV_VERSION,
#endif
   MOD_CLASS_VIDEODRV,
   {0, 0, 0, 0}
};

_X_EXPORT XF86ModuleData astModuleData = { &astVersRec, astSetup, NULL };

static pointer
astSetup(pointer module, pointer opts, int *errmaj, int *errmin)
{
   static Bool setupDone = FALSE;

   /* This module should be loaded only once, but check to be sure.
    */
   if (!setupDone) {
      setupDone = TRUE;
      xf86AddDriver(&AST, module, 0);

      /*
       * The return value must be non-NULL on success even though there
       * is no TearDownProc.
       */
      return (pointer) TRUE;
   } else {
      if (errmaj)
	 *errmaj = LDR_ONCEONLY;
      return NULL;
   }
}

#endif	/* XFree86LOADER */

/*
 * ASTIdentify --
 *
 * Returns the string name for the driver based on the chipset. In this
 * case it will always be an AST, so we can return a static string.
 *
 */
static void
ASTIdentify(int flags)
{
   xf86PrintChipsets(AST_NAME, "Driver for ASPEED Graphics Chipsets",
		     ASTChipsets);
}

const OptionInfoRec *
ASTAvailableOptions(int chipid, int busid)
{

   return ASTOptions;

}

/*
 * ASTProbe --
 *
 * Look through the PCI bus to find cards that are AST boards.
 * Setup the dispatch table for the rest of the driver functions.
 *
 */
static Bool
ASTProbe(DriverPtr drv, int flags)
{
    int i, numUsed, numDevSections, *usedChips;
    Bool foundScreen = FALSE;
    GDevPtr *devSections;

   /*
    * Find the config file Device sections that match this
    * driver, and return if there are none.
    */
    if ((numDevSections =
	xf86MatchDevice(AST_DRIVER_NAME, &devSections)) <= 0) {
      return FALSE;
    }

#ifndef XSERVER_LIBPCIACCESS
   /*
    * This probing is just checking the PCI data the server already
    * collected.
    */
    if (xf86GetPciVideoInfo() == NULL) {
	return FALSE;
    }
#endif

    numUsed = xf86MatchPciInstances(AST_NAME, PCI_VENDOR_AST,
				   ASTChipsets, ASTPciChipsets,
				   devSections, numDevSections,
				   drv, &usedChips);

    if (numUsed <= 0) {
	free(devSections);
	return FALSE;
    }

    if (flags & PROBE_DETECT) {
        if (numUsed > 0)
	    foundScreen = TRUE;
    } else {
        for (i = 0; i < numUsed; i++) {
	    ScrnInfoPtr pScrn = NULL;

#ifdef XSERVER_LIBPCIACCESS
            {
                struct pci_device *pPci = xf86GetPciInfoForEntity(usedChips[i]);

                if (pci_device_has_kernel_driver(pPci)) {
                    xf86DrvMsg(0, X_ERROR,
                               "ast: The PCI device 0x%x at %2.2d@@%2.2d:%2.2d:%1.1d has a kernel module claiming it.\n",
                               pPci->device_id, pPci->bus, pPci->domain, pPci->dev, pPci->func);
                    xf86DrvMsg(0, X_ERROR,
                               "ast: This driver cannot operate until it has been unloaded.\n");
                    xf86UnclaimPciSlot(pPci
#if GET_ABI_MAJOR(ABI_VIDEODRV_VERSION) >= 13
				       , devSections[0]
#endif
				       );
                    free(devSections);
                    return FALSE;
                }
            }
#endif

	    /* Allocate new ScrnInfoRec and claim the slot */
	    if ((pScrn = xf86ConfigPciEntity(pScrn, 0, usedChips[i],
					     ASTPciChipsets, 0, 0, 0, 0, 0)))
            {
	        EntityInfoPtr pEnt;

	        pEnt = xf86GetEntityInfo(usedChips[i]);

	        pScrn->driverVersion = AST_VERSION;
	        pScrn->driverName = AST_DRIVER_NAME;
	        pScrn->name = AST_NAME;

	        pScrn->Probe = ASTProbe;
	        pScrn->PreInit = ASTPreInit;
	        pScrn->ScreenInit = ASTScreenInit;
	        pScrn->SwitchMode = ASTSwitchMode;
	        pScrn->AdjustFrame = ASTAdjustFrame;
	        pScrn->EnterVT = ASTEnterVT;
	        pScrn->LeaveVT = ASTLeaveVT;
	        pScrn->FreeScreen = ASTFreeScreen;
	        pScrn->ValidMode = ASTValidMode;

	        foundScreen = TRUE;

	    } /* end of if */
        }  /* end of for-loop */
    } /* end of if flags */

    free(devSections);
    free(usedChips);

    return foundScreen;
}

#ifdef	Support_ShadowFB
static void *
ASTWindowLinear(ScreenPtr pScreen, CARD32 row, CARD32 offset, int mode,
		        CARD32 *size, void *closure)
{
    ScrnInfoPtr pScrn = xf86ScreenToScrn(pScreen);
    ASTPtr pAST = ASTPTR(pScrn);
    int stride = pScrn->displayWidth * ((pScrn->bitsPerPixel + 1) / 8);

    *size =  stride;
    return ((uint8_t *)pAST->FBVirtualAddr + pScrn->fbOffset + row * stride + offset);

}

static void
ASTUpdatePacked(ScreenPtr pScreen, shadowBufPtr pBuf)
{
    shadowUpdatePacked(pScreen, pBuf);
}

static Bool
ASTCreateScreenResources(ScreenPtr pScreen)
{
    ScrnInfoPtr pScrn = xf86ScreenToScrn(pScreen);
    ASTPtr pAST = ASTPTR(pScrn);
    Bool ret;

    pScreen->CreateScreenResources = pAST->CreateScreenResources;
    ret = pScreen->CreateScreenResources(pScreen);
    pScreen->CreateScreenResources = ASTCreateScreenResources;
    shadowAdd(pScreen, pScreen->GetScreenPixmap(pScreen), pAST->update,
	          pAST->window, 0, 0);

    return ret;
}
#endif	/* Support_ShadowFB */

/*
 * ASTPreInit --
 *
 * Do initial setup of the board before we know what resolution we will
 * be running at.
 *
 */
static Bool
ASTPreInit(ScrnInfoPtr pScrn, int flags)
{
   EntityInfoPtr pEnt;
   int flags24;
   rgb defaultWeight = { 0, 0, 0 };
#if	!(defined(__sparc__)) && !(defined(__mips__))
   vgaHWPtr hwp;
#endif

   ASTRecPtr pAST;

   ClockRangePtr clockRanges;
   int i;
   MessageType from;
   int maxPitch, maxHeight;

   /* Suport one adapter only now */
   if (pScrn->numEntities != 1)
       return FALSE;

   pEnt = xf86GetEntityInfo(pScrn->entityList[0]);

   if (flags & PROBE_DETECT) {
       ASTProbeDDC(pScrn, pEnt->index);
       return TRUE;
   }

   if (pEnt->location.type != BUS_PCI)
       return FALSE;

#ifndef XSERVER_LIBPCIACCESS
   if (xf86RegisterResources(pEnt->index, 0, ResExclusive))
       return FALSE;
#endif

#if	!(defined(__sparc__)) && !(defined(__mips__))
   /* The vgahw module should be loaded here when needed */
   if (!xf86LoadSubModule(pScrn, "vgahw"))
      return FALSE;
#endif

   /* The fb module should be loaded here when needed */
   if (!xf86LoadSubModule(pScrn, "fb"))
      return FALSE;

#if	!(defined(__sparc__)) && !(defined(__mips__))
   /* Allocate a vgaHWRec */
   if (!vgaHWGetHWRec(pScrn))
       return FALSE;
   hwp = VGAHWPTR(pScrn);
   vgaHWSetStdFuncs(hwp);
#endif

   /* Color Depth Check */
   flags24 = Support32bppFb;
   if (!xf86SetDepthBpp(pScrn, 0, 0, 0, flags24)) {
      return FALSE;
   } else {
      switch (pScrn->depth) {
      case 8:
      case 16:
      case 24:
	 break;
      default:
	 xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
		    "Given depth (%d) is not supported by ast driver\n",
		    pScrn->depth);
	 return FALSE;
      }
   }
   xf86PrintDepthBpp(pScrn);

   switch (pScrn->bitsPerPixel) {
   case 8:
   case 16:
   case 32:
      break;
   default:
      xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
		 "Given bpp (%d) is not supported by ast driver\n",
		 pScrn->bitsPerPixel);
      return FALSE;
   }

   /* fill pScrn misc. */
   pScrn->progClock = TRUE;
   pScrn->rgbBits = 6;
   pScrn->monitor = pScrn->confScreen->monitor; /* should be initialized before set gamma */
#ifndef XSERVER_LIBPCIACCESS
   pScrn->racMemFlags = RAC_FB | RAC_COLORMAP | RAC_CURSOR | RAC_VIEWPORT;
   pScrn->racIoFlags = RAC_COLORMAP | RAC_CURSOR | RAC_VIEWPORT;
#endif

   /*
    * If the driver can do gamma correction, it should call xf86SetGamma()
    * here.
    */
   {
      Gamma zeros = { 0.0, 0.0, 0.0 };

      if (!xf86SetGamma(pScrn, zeros)) {
         xf86DrvMsg(pScrn->scrnIndex, X_ERROR, "call xf86SetGamma failed \n");
	 return FALSE;
      }
   }


   if (!xf86SetWeight(pScrn, defaultWeight, defaultWeight)) {
       return FALSE;
   }

   if (!xf86SetDefaultVisual(pScrn, -1)) {
       return FALSE;
   }

   /* Allocate driverPrivate */
   if (!ASTGetRec(pScrn)) {
       xf86DrvMsg(pScrn->scrnIndex, X_ERROR, "call ASTGetRec failed \n");
       return FALSE;
   }

   /* Fill AST Info */
   pAST = ASTPTR(pScrn);
   pAST->pEnt    = xf86GetEntityInfo(pScrn->entityList[0]);
   pAST->PciInfo = xf86GetPciInfoForEntity(pAST->pEnt->index);
#ifndef XSERVER_LIBPCIACCESS
   pAST->PciTag  = pciTag(pAST->PciInfo->bus, pAST->PciInfo->device,
			  pAST->PciInfo->func);
#endif

   /* Process the options
    * pScrn->confScreen, pScrn->display, pScrn->monitor, pScrn->numEntities,
    * and pScrn->entityList should be initialized before
    */
   xf86CollectOptions(pScrn, NULL);
   if (!(pAST->Options = malloc(sizeof(ASTOptions))))
   {
      ASTFreeRec(pScrn);
      return FALSE;
   }
   memcpy(pAST->Options, ASTOptions, sizeof(ASTOptions));
   xf86ProcessOptions(pScrn->scrnIndex, pScrn->options, pAST->Options);

   /*
    * Set the Chipset and ChipRev, allowing config file entries to
    * override.
    */
   if (pAST->pEnt->device->chipset && *pAST->pEnt->device->chipset) {
      pScrn->chipset = pAST->pEnt->device->chipset;
      from = X_CONFIG;
   } else if (pAST->pEnt->device->chipID >= 0) {
      pScrn->chipset = (char *)xf86TokenToString(ASTChipsets,
						 pAST->pEnt->device->chipID);
      from = X_CONFIG;
      xf86DrvMsg(pScrn->scrnIndex, X_CONFIG, "ChipID override: 0x%04X\n",
		 pAST->pEnt->device->chipID);
   } else {
      from = X_PROBED;
      pScrn->chipset = (char *)xf86TokenToString(ASTChipsets,
						 PCI_DEV_DEVICE_ID(pAST->PciInfo));
   }
   if (pAST->pEnt->device->chipRev >= 0) {
      xf86DrvMsg(pScrn->scrnIndex, X_CONFIG, "ChipRev override: %d\n",
		 pAST->pEnt->device->chipRev);
   }

   xf86DrvMsg(pScrn->scrnIndex, from, "Chipset: \"%s\"\n",
	      (pScrn->chipset != NULL) ? pScrn->chipset : "Unknown ast");


#if GET_ABI_MAJOR(ABI_VIDEODRV_VERSION) < 12
    /* "Patch" the PIOOffset inside vgaHW in order to force
     * the vgaHW module to use our relocated i/o ports.
     */
    VGAHWPTR(pScrn)->PIOOffset =
	pScrn->domainIOBase + PCI_REGION_BASE(pAST->PciInfo, 2, REGION_IO) - 0x380;

    pAST->RelocateIO = pScrn->domainIOBase +
	    PCI_REGION_BASE(pAST->PciInfo, 2, REGION_IO);
#else
    pAST->RelocateIO = (PCI_REGION_BASE(pAST->PciInfo, 2, REGION_IO));

#endif


   if (pAST->pEnt->device->MemBase != 0) {
      pAST->FBPhysAddr = pAST->pEnt->device->MemBase;
      from = X_CONFIG;
   } else {
      if (PCI_REGION_BASE(pAST->PciInfo, 0, REGION_MEM) != 0) {
	 pAST->FBPhysAddr = PCI_REGION_BASE(pAST->PciInfo, 0, REGION_MEM) & 0xFFF00000;
	 from = X_PROBED;
      } else {
	 xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
		    "No valid FB address in PCI config space\n");
	 ASTFreeRec(pScrn);
	 return FALSE;
      }
   }
   xf86DrvMsg(pScrn->scrnIndex, X_INFO, "Linear framebuffer at 0x%lX\n",
	      (unsigned long) pAST->FBPhysAddr);

   if (pAST->pEnt->device->IOBase != 0) {
      pAST->MMIOPhysAddr = pAST->pEnt->device->IOBase;
      from = X_CONFIG;
   } else {
      if (PCI_REGION_BASE(pAST->PciInfo, 1, REGION_MEM)) {
	 pAST->MMIOPhysAddr = PCI_REGION_BASE(pAST->PciInfo, 1, REGION_MEM) & 0xFFFF0000;
	 from = X_PROBED;
      } else {
	 xf86DrvMsg(pScrn->scrnIndex, X_INFO,
		    "No valid MMIO address in PCI config space\n");
	 ASTFreeRec(pScrn);
	 return FALSE;
      }
   }
   xf86DrvMsg(pScrn->scrnIndex, X_INFO, "IO registers at addr 0x%lX\n",
	      (unsigned long) pAST->MMIOPhysAddr);

   /* Map MMIO */
   pAST->MMIOMapSize = DEFAULT_MMIO_SIZE;
   if (!ASTMapMMIO(pScrn)) {
      xf86DrvMsg(pScrn->scrnIndex, X_ERROR, "Map Memory Map IO Failed \n");
      return FALSE;
   }

   if (PCI_DEV_DEVICE_ID(pAST->PciInfo) == PCI_CHIP_AST1180)
   {
       pAST->jChipType = AST1180;

       /* validate mode */
       if ( (pScrn->bitsPerPixel == 8) || (pScrn->depth == 8) )
       {
           xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
		      "Given bpp (%d) is not supported by ast driver\n",
		      pScrn->bitsPerPixel);
           return FALSE;
       }

       /* Init AST1180 */
       bASTInitAST1180(pScrn);

       /* Get AST1180 Information */
       ASTGetAST1180DRAMInfo(pScrn);
       pScrn->videoRam = pAST->ulVRAMSize / 1024;

   }
   else
   {
       /* Enable VGA MMIO Access */
       vASTEnableVGAMMIO(pScrn);

       /* Init VGA Adapter */
       if (!xf86IsPrimaryPci(pAST->PciInfo))
       {
           ASTInitVGA(pScrn, 0);
       }

       vASTOpenKey(pScrn);
       bASTRegInit(pScrn);

       /* Get Chip Type */
       if (PCI_DEV_REVISION(pAST->PciInfo) >= 0x30)
           pAST->jChipType = AST2400;
       else if (PCI_DEV_REVISION(pAST->PciInfo) >= 0x20)
           pAST->jChipType = AST2300;
       else if (PCI_DEV_REVISION(pAST->PciInfo) >= 0x10)
           ASTGetChipType(pScrn);
       else
           pAST->jChipType = AST2000;

       /* Get Options from Scratch */
       ASTGetScratchOptions(pScrn);

       /* Get DRAM Info */
       ASTGetDRAMInfo(pScrn);
       pAST->ulVRAMSize = ASTGetVRAMInfo(pScrn);
       pScrn->videoRam  = pAST->ulVRAMSize / 1024;
   }

   /* Map Framebuffer */
   from = X_DEFAULT;
   if (pAST->pEnt->device->videoRam) {
      pScrn->videoRam = pAST->pEnt->device->videoRam;
      from = X_CONFIG;
   }

   pAST->FbMapSize = pScrn->videoRam * 1024;

#if 0
   if (!ASTMapMem(pScrn)) {
      xf86DrvMsg(pScrn->scrnIndex, X_ERROR, "Map FB Memory Failed \n");
      return FALSE;
   }
#endif

   pScrn->memPhysBase = (ULONG)pAST->FBPhysAddr;
   pScrn->fbOffset = 0;

   /* Do DDC
    * should be done after xf86CollectOptions
    */
   pScrn->monitor->DDC = ASTDoDDC(pScrn, pAST->pEnt->index);

   /* Mode Valid */
   clockRanges = xnfcalloc(sizeof(ClockRange), 1);
   clockRanges->next = NULL;
   clockRanges->minClock = 9500;
   clockRanges->maxClock = ASTGetMaxDCLK(pScrn) * 1000;
   clockRanges->clockIndex = -1;
   clockRanges->interlaceAllowed = FALSE;
   clockRanges->doubleScanAllowed = FALSE;

   /* Add for AST2100, ycchen@@061807 */
   if ((pAST->jChipType == AST2100) || (pAST->jChipType == AST2200) || (pAST->jChipType == AST2300) || (pAST->jChipType == AST2400) || (pAST->jChipType == AST1180))
   {
       maxPitch  = 1920;
       maxHeight = 1200;
   }
   else
   {
       maxPitch  = 1600;
       maxHeight = 1200;
   }

   i = xf86ValidateModes(pScrn, pScrn->monitor->Modes,
			 pScrn->display->modes, clockRanges,
			 0, 320, maxPitch, 8 * pScrn->bitsPerPixel,
			 200, maxHeight,
			 pScrn->display->virtualX, pScrn->display->virtualY,
			 pAST->FbMapSize, LOOKUP_BEST_REFRESH);

   /* fixed some monitors can't get propery validate modes using estimated ratio modes */
   if (i < 2)		/* validate modes are too few */
   {
       i = xf86ValidateModes(pScrn, pScrn->monitor->Modes,
			     pScrn->display->modes, clockRanges,
			     0, 320, maxPitch, 8 * pScrn->bitsPerPixel,
			     200, maxHeight,
			     pAST->mon_h_active, pAST->mon_v_active,
			     pAST->FbMapSize, LOOKUP_BEST_REFRESH);
   }

   if (i == -1) {
      ASTFreeRec(pScrn);
      return FALSE;
   }

   xf86PruneDriverModes(pScrn);

   if (!i || !pScrn->modes) {
      xf86DrvMsg(pScrn->scrnIndex, X_ERROR, "No valid modes found\n");
      ASTFreeRec(pScrn);
      return FALSE;
   }

   xf86SetCrtcForModes(pScrn, INTERLACE_HALVE_V);

   pScrn->currentMode = pScrn->modes;

   xf86PrintModes(pScrn);

   xf86SetDpi(pScrn, 0, 0);

   /* Accelaration Check */
   pAST->noAccel = TRUE;
   pAST->pCMDQPtr = NULL;
   pAST->CMDQInfo.ulCMDQSize 		= 0;
   pAST->CMDQInfo.pjCmdQBasePort    = pAST->MMIOVirtualAddr+ 0x8044;
   pAST->CMDQInfo.pjWritePort       = pAST->MMIOVirtualAddr+ 0x8048;
   pAST->CMDQInfo.pjReadPort        = pAST->MMIOVirtualAddr+ 0x804C;
   pAST->CMDQInfo.pjEngStatePort    = pAST->MMIOVirtualAddr+ 0x804C;
#ifdef HAVE_XAA_H
   pAST->AccelInfoPtr = NULL;
#ifdef	Accel_2D
   if (!xf86ReturnOptValBool(pAST->Options, OPTION_NOACCEL, FALSE))
   {
       if (xf86LoadSubModule(pScrn, "xaa")) {

           pAST->noAccel = FALSE;
           pAST->MMIO2D  = TRUE;
#ifndef	MMIO_2D
           if (!xf86ReturnOptValBool(pAST->Options, OPTION_MMIO2D, FALSE)) {
	       pAST->CMDQInfo.ulCMDQSize = DEFAULT_CMDQ_SIZE;
	       pAST->MMIO2D = FALSE;
           }
#endif

           pAST->ENGCaps = ENG_CAP_ALL;
           if (!xf86GetOptValInteger(pAST->Options, OPTION_ENG_CAPS, &pAST->ENGCaps)) {
	       xf86DrvMsg(pScrn->scrnIndex, X_INFO, "No ENG Capability options found\n");
           }

           pAST->DBGSelect = 0;
           if (!xf86GetOptValInteger(pAST->Options, OPTION_DBG_SELECT, &pAST->DBGSelect)) {
	       xf86DrvMsg(pScrn->scrnIndex, X_INFO, "No DBG Seleclt options found\n");
           }
       }
   }
#endif
#endif /* HAVE_XAA_H */

   /* HW Cursor Check */
   pAST->noHWC = TRUE;
   pAST->HWCInfoPtr = NULL;
   pAST->pHWCPtr = NULL;
#ifdef	HWC
   if (!xf86ReturnOptValBool(pAST->Options, OPTION_SW_CURSOR, FALSE)) {
      if (!xf86LoadSubModule(pScrn, "ramdac")) {
	 ASTFreeRec(pScrn);
	 return FALSE;
      }

      pAST->noHWC = FALSE;
      pAST->HWCInfo.HWC_NUM = DEFAULT_HWC_NUM;
      if (!xf86GetOptValInteger(pAST->Options, OPTION_HWC_NUM, &pAST->HWCInfo.HWC_NUM)) {
          xf86DrvMsg(pScrn->scrnIndex, X_INFO, "No HWC_NUM options found\n");
      }

   }
#endif

   /* ShadowFB */
#ifdef	Support_ShadowFB
   pAST->shadowFB = FALSE;
   if (pAST->noAccel == TRUE)	/* enable shadowFB only noAccel */
   {
       if (xf86ReturnOptValBool(pAST->Options, OPTION_SHADOW_FB, TRUE))
       {
	       if (xf86LoadSubModule(pScrn, "shadow")) {
	          xf86DrvMsg(pScrn->scrnIndex, X_INFO, "Using \"Shadow Framebuffer\"\n");
	          pAST->shadowFB = TRUE;
	       }
       }
   }
#endif

#ifndef XSERVER_LIBPCIACCESS
   /*  We won't be using the VGA access after the probe */
   xf86SetOperatingState(resVgaIo, pAST->pEnt->index, ResUnusedOpr);
   xf86SetOperatingState(resVgaMem, pAST->pEnt->index, ResDisableOpr);
#endif

   return TRUE;
}


static Bool
ASTScreenInit(SCREEN_INIT_ARGS_DECL)
{
   ScrnInfoPtr pScrn;
   ASTRecPtr pAST;
   VisualPtr visual;
   /* for FB Manager */
   BoxRec FBMemBox;
   int    AvailFBSize;

   pScrn = xf86ScreenToScrn(pScreen);
   pAST = ASTPTR(pScrn);

   if (!ASTMapMem(pScrn)) {
      xf86DrvMsg(pScrn->scrnIndex, X_ERROR, "Map FB Memory Failed \n");
      return FALSE;
   }

/*   if (!pAST->noAccel) */
   {
       /* AvailFBSize = pAST->FbMapSize - pAST->CMDQInfo.ulCMDQSize; */
       AvailFBSize = pAST->FbMapSize;

       FBMemBox.x1 = 0;
       FBMemBox.y1 = 0;
       FBMemBox.x2 = pScrn->displayWidth;
       FBMemBox.y2 = (AvailFBSize / (pScrn->displayWidth * ((pScrn->bitsPerPixel+1)/8))) - 1;

       if (FBMemBox.y2 < 0)
           FBMemBox.y2 = 32767;
       if (FBMemBox.y2 < pScrn->virtualY)
           return FALSE;

       if (!xf86InitFBManager(pScreen, &FBMemBox)) {
          xf86DrvMsg(pScrn->scrnIndex, X_ERROR, "Failed to init memory manager\n");
          return FALSE;
       }

   }

#if	!(defined(__sparc__)) && !(defined(__mips__))
   vgaHWPtr hwp;
   hwp = VGAHWPTR(pScrn);
   vgaHWSetMmioFuncs(hwp, pAST->MMIOVirtualAddr, 0);
#endif

   vFillASTModeInfo (pScrn);

   ASTSave(pScrn);
   if (!ASTModeInit(pScrn, pScrn->currentMode)) {
      xf86DrvMsg(pScrn->scrnIndex, X_ERROR, "Mode Init Failed \n");
      return FALSE;
   }

   ASTSaveScreen(pScreen, FALSE);
   ASTAdjustFrame(ADJUST_FRAME_ARGS(pScrn, pScrn->frameX0, pScrn->frameY0));

   miClearVisualTypes();

   /* Re-implemented Direct Color support, -jens */
   if (!miSetVisualTypes(pScrn->depth, miGetDefaultVisualMask(pScrn->depth),
			 pScrn->rgbBits, pScrn->defaultVisual))
      return FALSE;

   if (!miSetPixmapDepths())
   {
       ASTSaveScreen(pScreen, SCREEN_SAVER_OFF);
       return FALSE;
   }

   /* allocate shadowFB */
#ifdef	Support_ShadowFB
   pAST->shadowFB_validation = FALSE;
   if (pAST->shadowFB) {
      pAST->shadow = calloc(1, pScrn->displayWidth * pScrn->virtualY *
				     ((pScrn->bitsPerPixel + 7) / 8));
	  if (!pAST->shadow) {
	     xf86DrvMsg(pScrn->scrnIndex, X_ERROR, "Failed to allocate shadow buffer\n");
	  }
	  else
	     pAST->shadowFB_validation = TRUE;
   }
#endif

   switch(pScrn->bitsPerPixel) {
       case 8:
       case 16:
       case 32:
#ifdef	Support_ShadowFB
           if (!fbScreenInit(pScreen, pAST->shadowFB_validation ? pAST->shadow : (pAST->FBVirtualAddr + pScrn->fbOffset),
  	                         pScrn->virtualX, pScrn->virtualY,
		                     pScrn->xDpi, pScrn->yDpi,
		                     pScrn->displayWidth, pScrn->bitsPerPixel))
#else
	       if (!fbScreenInit(pScreen, pAST->FBVirtualAddr + pScrn->fbOffset,
			                 pScrn->virtualX, pScrn->virtualY,
			                 pScrn->xDpi, pScrn->yDpi,
			                 pScrn->displayWidth, pScrn->bitsPerPixel))
#endif
               return FALSE;
           break;
       default:
           return FALSE;

   }

   if (pScrn->bitsPerPixel > 8) {
      /* Fixup RGB ordering */
      visual = pScreen->visuals + pScreen->numVisuals;
      while (--visual >= pScreen->visuals) {
	 if ((visual->class | DynamicClass) == DirectColor) {
	    visual->offsetRed = pScrn->offset.red;
	    visual->offsetGreen = pScrn->offset.green;
	    visual->offsetBlue = pScrn->offset.blue;
	    visual->redMask = pScrn->mask.red;
	    visual->greenMask = pScrn->mask.green;
	    visual->blueMask = pScrn->mask.blue;
	 }
      }
   }

   /* Must be after RGB order fixed */
   fbPictureInit(pScreen, 0, 0);

   /* shadowFB setup */
#ifdef	Support_ShadowFB
   if (pAST->shadowFB_validation) {
      pAST->update = ASTUpdatePacked;
	  pAST->window = ASTWindowLinear;

      if (!shadowSetup(pScreen))
      {
	     xf86DrvMsg(pScrn->scrnIndex, X_ERROR, "Failed to setup shadow buffer\n");
	     return FALSE;
      }

	  pAST->CreateScreenResources = pScreen->CreateScreenResources;
	  pScreen->CreateScreenResources = ASTCreateScreenResources;
   }
#endif

   xf86SetBlackWhitePixels(pScreen);

#ifdef HAVE_XAA_H
#ifdef Accel_2D
   if (!pAST->noAccel)
   {
       if (!ASTAccelInit(pScreen)) {
           xf86DrvMsg(pScrn->scrnIndex, X_ERROR,"Hardware acceleration initialization failed\n");
           pAST->noAccel = TRUE;
       }
   }
#endif /* end of Accel_2D */
#endif

   xf86SetBackingStore(pScreen);
   xf86SetSilkenMouse(pScreen);

   miDCInitialize(pScreen, xf86GetPointerScreenFuncs());

   if (!pAST->noHWC)
   {
       if (!ASTCursorInit(pScreen)) {
           xf86DrvMsg(pScrn->scrnIndex, X_ERROR,"Hardware cursor initialization failed\n");
           pAST->noHWC = TRUE;
       }
   }

   if (!miCreateDefColormap(pScreen))
      return FALSE;

   if (pAST->jChipType != AST1180)
   {
       if(!xf86HandleColormaps(pScreen, 256, (pScrn->depth == 8) ? 8 : pScrn->rgbBits,
                               vASTLoadPalette, NULL,
                               CMAP_PALETTED_TRUECOLOR | CMAP_RELOAD_ON_MODE_SWITCH)) {
           return FALSE;
       }
   }

   xf86DPMSInit(pScreen, ASTDisplayPowerManagementSet, 0);

#ifdef AstVideo
   if ( (pAST->jChipType == AST1180) || (pAST->jChipType == AST2300) || (pAST->jChipType == AST2400) )
   {
       xf86DrvMsg(pScrn->scrnIndex, X_INFO,"AST Initial Video()\n");
       ASTInitVideo(pScreen);
   }
#endif

   pScreen->SaveScreen = ASTSaveScreen;
   pAST->CloseScreen = pScreen->CloseScreen;
   pScreen->CloseScreen = ASTCloseScreen;

   if (serverGeneration == 1)
      xf86ShowUnusedOptions(pScrn->scrnIndex, pScrn->options);

   return TRUE;

} /* ASTScreenInit */


Bool
ASTSwitchMode(SWITCH_MODE_ARGS_DECL)
{
   SCRN_INFO_PTR(arg);
   ASTRecPtr pAST = ASTPTR(pScrn);

   /* VideoMode validate */
   if (mode->CrtcHDisplay > pScrn->displayWidth)
       return FALSE;
   if ((pAST->VideoModeInfo.ScreenPitch * mode->CrtcVDisplay) > pAST->ulVRAMSize)
       return FALSE;

   /* VideModeInfo Update */
   pAST->VideoModeInfo.ScreenWidth  = mode->CrtcHDisplay;
   pAST->VideoModeInfo.ScreenHeight = mode->CrtcVDisplay;
   pAST->VideoModeInfo.ScreenPitch  = pScrn->displayWidth * ((pScrn->bitsPerPixel + 1) / 8) ;

#ifdef	HWC
   if (pAST->pHWCPtr) {
       xf86FreeOffscreenLinear(pAST->pHWCPtr);		/* free HWC Cache */
       pAST->pHWCPtr = NULL;
   }
   ASTDisableHWC(pScrn);
#endif

#ifdef Accel_2D
   if (pAST->pCMDQPtr) {
       xf86FreeOffscreenLinear(pAST->pCMDQPtr);		/* free CMDQ */
       pAST->pCMDQPtr = NULL;
   }
   vASTDisable2D(pScrn, pAST);
#endif

   /* Fixed display abnormal on the of the screen if run xvidtune, ycchen@@122909 */
   /* ASTRestore(pScrn); */

   return ASTModeInit(pScrn, mode);

}

void
ASTAdjustFrame(ADJUST_FRAME_ARGS_DECL)
{
   SCRN_INFO_PTR(arg);
   ASTRecPtr   pAST  = ASTPTR(pScrn);
   ULONG base;

   base = y * pAST->VideoModeInfo.ScreenPitch + x * ((pAST->VideoModeInfo.bitsPerPixel + 1) / 8);
   /* base = base >> 2; */			/* DW unit */

   vASTSetStartAddressCRT1(pAST, base);

}

/* enter into X Server */
static Bool
ASTEnterVT(VT_FUNC_ARGS_DECL)
{
   SCRN_INFO_PTR(arg);
   ASTRecPtr pAST = ASTPTR(pScrn);

   /* Fixed suspend can't resume issue */
   if (!bASTIsVGAEnabled(pScrn))
   {
       if (pAST->jChipType == AST1180)
           bASTInitAST1180(pScrn);
       else
       {
           vASTEnableVGAMMIO(pScrn);
           ASTInitVGA(pScrn, 1);
       }
       ASTRestore(pScrn);
   }

   if (!ASTModeInit(pScrn, pScrn->currentMode))
      return FALSE;
   ASTAdjustFrame(ADJUST_FRAME_ARGS(pScrn, pScrn->frameX0, pScrn->frameY0));

   return TRUE;

}

/* leave X server */
static void
ASTLeaveVT(VT_FUNC_ARGS_DECL)
{

   SCRN_INFO_PTR(arg);
   ASTRecPtr pAST = ASTPTR(pScrn);
#if	!(defined(__sparc__)) && !(defined(__mips__))
   vgaHWPtr hwp = VGAHWPTR(pScrn);
#endif

#ifdef	HWC
   if (pAST->pHWCPtr) {
       xf86FreeOffscreenLinear(pAST->pHWCPtr);		/* free HWC Cache */
       pAST->pHWCPtr = NULL;
   }
   ASTDisableHWC(pScrn);
#endif

#ifdef Accel_2D
   if (pAST->pCMDQPtr) {
       xf86FreeOffscreenLinear(pAST->pCMDQPtr);		/* free CMDQ */
       pAST->pCMDQPtr = NULL;
   }
   vASTDisable2D(pScrn, pAST);
#endif

   ASTRestore(pScrn);

   if (pAST->jChipType == AST1180)
       ASTBlankScreen(pScrn, 0);

#if	!(defined(__sparc__)) && !(defined(__mips__))
   vgaHWLock(hwp);
#endif

}

static void
ASTFreeScreen(FREE_SCREEN_ARGS_DECL)
{
   SCRN_INFO_PTR(arg);
   ASTFreeRec(pScrn);
#if	!(defined(__sparc__)) && !(defined(__mips__))
   if (xf86LoaderCheckSymbol("vgaHWFreeHWRec"))
      vgaHWFreeHWRec(pScrn);
#endif
}

static ModeStatus
ASTValidMode(SCRN_ARG_TYPE arg, DisplayModePtr mode, Bool verbose, int flags)
{
   SCRN_INFO_PTR(arg);
   ASTRecPtr   pAST  = ASTPTR(pScrn);
   ModeStatus Flags = MODE_NOMODE;
   UCHAR jReg;
   ULONG RequestBufferSize;

   if (mode->Flags & V_INTERLACE) {
      if (verbose) {
	 xf86DrvMsg(pScrn->scrnIndex, X_PROBED,
		    "Removing interlaced mode \"%s\"\n", mode->name);
      }
      return MODE_NO_INTERLACE;
   }

   if ((mode->CrtcHDisplay > MAX_HResolution) || (mode->CrtcVDisplay > MAX_VResolution)) {
      if (verbose) {
	 xf86DrvMsg(pScrn->scrnIndex, X_PROBED,
		    "Removing the mode \"%s\"\n", mode->name);
      }
      return Flags;
   }

   /* Valid Framebuffer size */
   RequestBufferSize = mode->CrtcHDisplay * ((pScrn->bitsPerPixel + 1) / 8) * mode->CrtcVDisplay;
   if (RequestBufferSize > pAST->ulVRAMSize)
      return Flags;

   /* Valid Wide Screen Mode */
   if (pAST->SupportWideScreen)
   {
      if ( (mode->CrtcHDisplay == 1680) && (mode->CrtcVDisplay == 1050) )
          return MODE_OK;
      if ( (mode->CrtcHDisplay == 1280) && (mode->CrtcVDisplay == 800) )
          return MODE_OK;
      if ( (mode->CrtcHDisplay == 1440) && (mode->CrtcVDisplay == 900) )
          return MODE_OK;
      if ( (mode->CrtcHDisplay == 1360) && (mode->CrtcVDisplay == 768) )
          return MODE_OK;
      if ( (mode->CrtcHDisplay == 1600) && (mode->CrtcVDisplay == 900) )
          return MODE_OK;

      if ( (pAST->jChipType == AST2100) || (pAST->jChipType == AST2200) || (pAST->jChipType == AST2300) || (pAST->jChipType == AST2400) || (pAST->jChipType == AST1180) )
      {
          if ( (mode->CrtcHDisplay == 1920) && (mode->CrtcVDisplay == 1080) )
              return MODE_OK;

          if ( (mode->CrtcHDisplay == 1920) && (mode->CrtcVDisplay == 1200) )
          {
             GetIndexRegMask(CRTC_PORT, 0xD1, 0xFF, jReg);
	     if (jReg & 0x01)
	        return MODE_NOMODE;
	     else
                return MODE_OK;
          }
      }
   }

   switch (mode->CrtcHDisplay)
   {
   case 640:
       if (mode->CrtcVDisplay == 480) Flags=MODE_OK;
       break;
   case 800:
       if (mode->CrtcVDisplay == 600) Flags=MODE_OK;
       break;
   case 1024:
       if (mode->CrtcVDisplay == 768) Flags=MODE_OK;
       break;
   case 1280:
       if (mode->CrtcVDisplay == 1024) Flags=MODE_OK;
       break;
   case 1600:
       if (mode->CrtcVDisplay == 1200) Flags=MODE_OK;
       break;
   default:
       return Flags;
   }

   return Flags;
}

/* Internal used modules */
/*
 * ASTGetRec and ASTFreeRec --
 *
 * Private data for the driver is stored in the screen structure.
 * These two functions create and destroy that private data.
 *
 */
static Bool
ASTGetRec(ScrnInfoPtr pScrn)
{
   if (pScrn->driverPrivate)
      return TRUE;

   pScrn->driverPrivate = xnfcalloc(sizeof(ASTRec), 1);
   return TRUE;
}

static void
ASTFreeRec(ScrnInfoPtr pScrn)
{
   ASTRecPtr pAST = ASTPTR(pScrn);

   if (!pScrn)
      return;
   if (!pScrn->driverPrivate)
      return;
   if (pAST->pDP501FWBufferVirtualAddress)
       free(pAST->pDP501FWBufferVirtualAddress);
   free(pScrn->driverPrivate);
   pScrn->driverPrivate = 0;
}

static Bool
ASTSaveScreen(ScreenPtr pScreen, Bool unblack)
{
#if	!(defined(__sparc__)) && !(defined(__mips__))
   /* replacement of vgaHWBlankScreen(pScrn, unblank) without seq reset */
   /* return vgaHWSaveScreen(pScreen, unblack); */
   ScrnInfoPtr pScrn = NULL;

   if (pScreen != NULL)
      pScrn = xf86ScreenToScrn(pScreen);

   if ((pScrn != NULL) && pScrn->vtSema) {
     ASTBlankScreen(pScrn, unblack);
   }
   return (TRUE);
#endif
}

static Bool
ASTCloseScreen(CLOSE_SCREEN_ARGS_DECL)
{
   ScrnInfoPtr pScrn = xf86ScreenToScrn(pScreen);
   ASTRecPtr pAST = ASTPTR(pScrn);
#if	!(defined(__sparc__)) && !(defined(__mips__))
   vgaHWPtr hwp = VGAHWPTR(pScrn);
#endif

   if (pScrn->vtSema == TRUE)
   {
#ifdef	HWC
       if (pAST->pHWCPtr) {
           xf86FreeOffscreenLinear(pAST->pHWCPtr);		/* free HWC Cache */
           pAST->pHWCPtr = NULL;
       }
       ASTDisableHWC(pScrn);
#endif

#ifdef Accel_2D
       if (pAST->pCMDQPtr) {
           xf86FreeOffscreenLinear(pAST->pCMDQPtr);		/* free CMDQ */
           pAST->pCMDQPtr = NULL;
       }
       vASTDisable2D(pScrn, pAST);
#endif

       ASTRestore(pScrn);

       if (pAST->jChipType == AST1180)
           ASTBlankScreen(pScrn, 0);

#if	!(defined(__sparc__)) && !(defined(__mips__))
       vgaHWLock(hwp);
#endif
   }

   ASTUnmapMem(pScrn);
#if	!(defined(__sparc__)) && !(defined(__mips__))
   vgaHWUnmapMem(pScrn);
#endif

#ifdef HAVE_XAA_H
   if(pAST->AccelInfoPtr) {
       XAADestroyInfoRec(pAST->AccelInfoPtr);
       pAST->AccelInfoPtr = NULL;
   }
#endif
   if(pAST->HWCInfoPtr) {
       xf86DestroyCursorInfoRec(pAST->HWCInfoPtr);
       pAST->HWCInfoPtr = NULL;
   }

#ifdef	Support_ShadowFB
   if (pAST->shadowFB_validation) {
      shadowRemove(pScreen, pScreen->GetScreenPixmap(pScreen));
	  free(pAST->shadow);
      pScreen->CreateScreenResources = pAST->CreateScreenResources;
   }
#endif

   pScrn->vtSema = FALSE;
   pScreen->CloseScreen = pAST->CloseScreen;
   return (*pScreen->CloseScreen) (CLOSE_SCREEN_ARGS);
}

static void
ASTSave(ScrnInfoPtr pScrn)
{
   ASTRecPtr pAST;
   ASTRegPtr astReg;
   int i, icount=0;
   ULONG ulData;

   pAST = ASTPTR(pScrn);
   astReg = &pAST->SavedReg;

   if (pAST->jChipType == AST1180)
   {
       for (i=0; i<12; i++)
       {
           ReadAST1180SOC(AST1180_GFX_BASE + AST1180_VGA1_CTRL+i*4, ulData);
           astReg->GFX[i] = ulData;
       }
   }
   else
   {
#if	defined(__sparc__) || defined(__mips__)
       UCHAR jReg;

       /* Save Misc */
       astReg->MISC = GetReg(MISC_PORT_READ);

       /* Save SR */
       for (i=0; i<4; i++)
           GetIndexReg(SEQ_PORT, (UCHAR) (i), astReg->SEQ[i]);

       /* Save CR */
       for (i=0; i<25; i++)
           GetIndexReg(CRTC_PORT, (UCHAR) (i), astReg->CRTC[i]);

       /* Save GR */
       for (i=0; i<9; i++)
           GetIndexReg(GR_PORT, (UCHAR) (i), astReg->GR[i]);

       /* Save AR */
       jReg = GetReg(INPUT_STATUS1_READ);
       for (i=0; i<20; i++)
           GetIndexReg(AR_PORT_WRITE, (UCHAR) (i), astReg->AR[i]);
       jReg = GetReg(INPUT_STATUS1_READ);
       SetReg (AR_PORT_WRITE, 0x20);		/* set POS */
#else
       vgaRegPtr vgaReg;
       vgaReg = &VGAHWPTR(pScrn)->SavedReg;

       /* do save */
       if (xf86IsPrimaryPci(pAST->PciInfo)) {
           vgaHWSave(pScrn, vgaReg, VGA_SR_MODE | VGA_SR_FONTS);
       }
       else {
           vgaHWSave(pScrn, vgaReg, VGA_SR_MODE);
       }
#endif

       /* Save Ext. */
       vASTOpenKey(pScrn);

       /* fixed Console Switch Refresh Rate Incorrect issue, ycchen@@051106 */
       for (i=0x81; i<=0xB6; i++)
           GetIndexReg(CRTC_PORT, (UCHAR) (i), astReg->ExtCRTC[icount++]);
       for (i=0xBC; i<=0xC1; i++)
           GetIndexReg(CRTC_PORT, (UCHAR) (i), astReg->ExtCRTC[icount++]);
       GetIndexReg(CRTC_PORT, (UCHAR) (0xBB), astReg->ExtCRTC[icount]);

       /* Save DAC */
       for (i=0; i<256; i++)
           VGA_GET_PALETTE_INDEX (i, astReg->DAC[i][0], astReg->DAC[i][1], astReg->DAC[i][2]);

       /* Save 2D */
       astReg->ENG8044 = 0;
       GetIndexReg(CRTC_PORT, 0xA4, astReg->REGA4);
       if (astReg->REGA4 & 0x01)	/* 2D enabled */
           astReg->ENG8044 = *(ULONG *) (pAST->MMIOVirtualAddr + 0x8044);
   }

}

static void
ASTRestore(ScrnInfoPtr pScrn)
{
   ASTRecPtr pAST;
   ASTRegPtr astReg;
   int i, icount=0;
   ULONG ulData;

   pAST = ASTPTR(pScrn);
   astReg = &pAST->SavedReg;

   ASTDisplayPowerManagementSet(pScrn, DPMSModeOff, 0);

   if (pAST->jChipType == AST1180)
   {
       for (i=0; i<12; i++)
       {
           ulData = astReg->GFX[i];
           WriteAST1180SOC(AST1180_GFX_BASE + AST1180_VGA1_CTRL+i*4, ulData);
       }
   }
   else
   {
#if	defined(__sparc__) || defined(__mips__)
       UCHAR jReg;

       /* Restore Misc */
       SetReg(MISC_PORT_WRITE, astReg->MISC);

       /* Restore SR */
       for (i=0; i<4; i++)
           SetIndexReg(SEQ_PORT, (UCHAR) (i), astReg->SEQ[i]);

       /* Restore CR */
       SetIndexRegMask(CRTC_PORT,0x11, 0x7F, 0x00);
       for (i=0; i<25; i++)
           SetIndexReg(CRTC_PORT, (UCHAR) (i), astReg->CRTC[i]);

       /* Restore GR */
       for (i=0; i<9; i++)
           SetIndexReg(GR_PORT, (UCHAR) (i), astReg->GR[i]);

       /* Restore AR */
       jReg = GetReg(INPUT_STATUS1_READ);
       for (i=0; i<20; i++)
       {
           SetReg(AR_PORT_WRITE, (UCHAR) i);
           SetReg(AR_PORT_WRITE, astReg->AR[i]);
       }
       SetReg(AR_PORT_WRITE, 0x14);
       SetReg(AR_PORT_WRITE, 0x00);

       jReg = GetReg(INPUT_STATUS1_READ);
       SetReg (AR_PORT_WRITE, 0x20);		/* set POS */
#else
       vgaRegPtr vgaReg;
       vgaReg = &VGAHWPTR(pScrn)->SavedReg;

       /* do restore */
       vgaHWProtect(pScrn, TRUE);
       if (xf86IsPrimaryPci(pAST->PciInfo))
           vgaHWRestore(pScrn, vgaReg, VGA_SR_MODE | VGA_SR_FONTS);
       else
           vgaHWRestore(pScrn, vgaReg, VGA_SR_MODE);
       vgaHWProtect(pScrn, FALSE);
#endif

      /* Ext. restore */
      vASTOpenKey(pScrn);

       /* Restore DAC */
       for (i=0; i<256; i++)
          VGA_LOAD_PALETTE_INDEX (i, astReg->DAC[i][0], astReg->DAC[i][1], astReg->DAC[i][2]);

      /* fixed Console Switch Refresh Rate Incorrect issue, ycchen@@051106 */
      for (i=0x81; i<=0xB6; i++)
          SetIndexReg(CRTC_PORT, (UCHAR) (i), astReg->ExtCRTC[icount++]);
      for (i=0xBC; i<=0xC1; i++)
          SetIndexReg(CRTC_PORT, (UCHAR) (i), astReg->ExtCRTC[icount++]);
      SetIndexReg(CRTC_PORT, (UCHAR) (0xBB), astReg->ExtCRTC[icount]);
   }

}

static void
ASTProbeDDC(ScrnInfoPtr pScrn, int index)
{
   ASTRecPtr pAST = ASTPTR(pScrn);
   unsigned char DDC_data[128];
   Bool Flags;

   if (xf86LoadSubModule(pScrn, "ddc"))
   {
      if (pAST->jChipType == AST1180)
          Flags = ASTGetVGA2EDID(pScrn, DDC_data);
      else if (pAST->jTxChipType == Tx_DP501)
      {
          Flags = ASTReadEDID_M68K(pScrn, DDC_data);
          if (Flags == FALSE)
              Flags = ASTGetVGAEDID(pScrn, DDC_data);
      }
      else
          Flags = ASTGetVGAEDID(pScrn, DDC_data);

      if (Flags)
      {
          ConfiguredMonitor = xf86InterpretEDID(pScrn->scrnIndex, DDC_data);
      }
      else
          xf86DrvMsg(pScrn->scrnIndex, X_INFO,"[ASTProbeDDC] Can't Get EDID Properly \n");
   }
   else
   {
      xf86DrvMsg(pScrn->scrnIndex, X_INFO,"[ASTProbeDDC] Can't Load DDC Sub-Modules or Read EDID Failed \n");
   }

}

#define SkipDT	0x00
#define DT1	0x01
#define DT2 	0x02

static xf86MonPtr
ASTDoDDC(ScrnInfoPtr pScrn, int index)
{
   xf86MonPtr MonInfo = NULL;
   ASTRecPtr pAST = ASTPTR(pScrn);
   unsigned char DDC_data[128];
   Bool Flags;

   xf86MonPtr MonInfo1 = NULL, MonInfo2 = NULL;
   unsigned long i, j, k;
   struct monitor_ranges ranges, ranges1, ranges2;
   int DTSelect, dclock1=0, h_active1=0, v_active1=0, dclock2=0, h_active2=0, v_active2=0;
   struct std_timings stdtiming, *stdtiming1, *stdtiming2;

   /* Honour Option "noDDC" */
   if (xf86ReturnOptValBool(pAST->Options, OPTION_NO_DDC, FALSE)) {
      return MonInfo;
   }

   if (xf86LoadSubModule(pScrn, "ddc"))
   {
      if (pAST->jChipType == AST1180)
          Flags = ASTGetVGA2EDID(pScrn, DDC_data);
      else if (pAST->jTxChipType == Tx_DP501)
      {
	      pAST->DP501_MaxVCLK = 0xFF;
          Flags = ASTReadEDID_M68K(pScrn, DDC_data);
          if (Flags) pAST->DP501_MaxVCLK = ASTGetLinkMaxCLK(pScrn);
          else
              Flags = ASTGetVGAEDID(pScrn, DDC_data);
      }
      else
          Flags = ASTGetVGAEDID(pScrn, DDC_data);

      if (Flags)
      {
          MonInfo = MonInfo1 = xf86InterpretEDID(pScrn->scrnIndex, DDC_data);

          /* Valid Wide Screen Support */
          if ( (MonInfo) && (MonInfo->det_mon[0].type == 0x00) )
          {
	          if ( (MonInfo->det_mon[0].section.d_timings.h_active * 10 / MonInfo->det_mon[0].section.d_timings.v_active) < 14 )
                  pAST->SupportWideScreen = FALSE;
          }
      }

      /* For VGA2 CLONE Support, ycchen@@012508 */
      if ((xf86ReturnOptValBool(pAST->Options, OPTION_VGA2_CLONE, FALSE)) || pAST->VGA2Clone) {
          if (ASTGetVGA2EDID(pScrn, DDC_data) == TRUE) {
              xf86DrvMsg(pScrn->scrnIndex, X_INFO, "Get VGA2 EDID Correctly!! \n");
              MonInfo2 = xf86InterpretEDID(pScrn->scrnIndex, DDC_data);
              if (MonInfo1 == NULL)	/* No DDC1 EDID */
                  MonInfo = MonInfo2;
              else {			/* Check with VGA1 & VGA2 EDID */
                   /* Update establishment timing */
                   MonInfo->timings1.t1 = MonInfo1->timings1.t1 & MonInfo2->timings1.t1;
                   MonInfo->timings1.t2 = MonInfo1->timings1.t2 & MonInfo2->timings1.t2;
                   MonInfo->timings1.t_manu = MonInfo1->timings1.t_manu & MonInfo2->timings1.t_manu;

                   /* Update Std. Timing */
                   for (i=0; i<8; i++) {
                       stdtiming.hsize = stdtiming.vsize = stdtiming.refresh = stdtiming.id = 0;
                       for (j=0; j<8; j++) {
                           if ((MonInfo1->timings2[i].hsize == MonInfo2->timings2[j].hsize) && \
                               (MonInfo1->timings2[i].vsize == MonInfo2->timings2[j].vsize) && \
                               (MonInfo1->timings2[i].refresh == MonInfo2->timings2[j].refresh)) {
                                stdtiming = MonInfo1->timings2[i];
                                break;
                           }
                       }

                       MonInfo->timings2[i] = stdtiming;
                   } /* Std. Timing */

                   /* Get Detailed Timing */
                   for (i=0;i<4;i++) {
                      if (MonInfo1->det_mon[i].type == 0xFD)
                         ranges1 = MonInfo1->det_mon[i].section.ranges;
                      else if (MonInfo1->det_mon[i].type == 0xFA)
                         stdtiming1 = MonInfo1->det_mon[i].section.std_t;
                      else if (MonInfo1->det_mon[i].type == 0x00) {
                         if (MonInfo1->det_mon[i].section.d_timings.clock > dclock1)
                             dclock1 = MonInfo1->det_mon[i].section.d_timings.clock;
                         if (MonInfo1->det_mon[i].section.d_timings.h_active > h_active1)
                             h_active1 = MonInfo1->det_mon[i].section.d_timings.h_active;
                         if (MonInfo1->det_mon[i].section.d_timings.v_active > v_active1)
                             v_active1 = MonInfo1->det_mon[i].section.d_timings.v_active;
                      }
                      if (MonInfo2->det_mon[i].type == 0xFD)
                         ranges2 = MonInfo2->det_mon[i].section.ranges;
                      else if (MonInfo1->det_mon[i].type == 0xFA)
                         stdtiming2 = MonInfo2->det_mon[i].section.std_t;
                      else if (MonInfo2->det_mon[i].type == 0x00) {
                         if (MonInfo2->det_mon[i].section.d_timings.clock > dclock2)
                             dclock2 = MonInfo2->det_mon[i].section.d_timings.clock;
                         if (MonInfo2->det_mon[i].section.d_timings.h_active > h_active2)
                             h_active2 = MonInfo2->det_mon[i].section.d_timings.h_active;
                         if (MonInfo2->det_mon[i].section.d_timings.v_active > v_active2)
                             v_active2 = MonInfo2->det_mon[i].section.d_timings.v_active;
                      }
                   } /* Get Detailed Timing */

                   /* Chk Detailed Timing */
                   if ((dclock1 >= dclock2) && (h_active1 >= h_active2) && (v_active1 >= v_active2))
                       DTSelect = DT2;
                   else if ((dclock2 >= dclock1) && (h_active2 >= h_active1) && (v_active2 >= v_active1))
                       DTSelect = DT1;
                   else
                       DTSelect = SkipDT;

                   /* Chk Monitor Descriptor */
                   ranges = ranges1;
                   ranges.min_h = ranges1.min_h > ranges2.min_h ? ranges1.min_h:ranges2.min_h;
                   ranges.min_v = ranges1.min_v > ranges2.min_v ? ranges1.min_v:ranges2.min_v;
                   ranges.max_h = ranges1.max_h < ranges2.max_h ? ranges1.max_h:ranges2.max_h;
                   ranges.max_v = ranges1.max_v < ranges2.max_v ? ranges1.max_v:ranges2.max_v;
                   ranges.max_clock = ranges1.max_clock < ranges2.max_clock ? ranges1.max_clock:ranges2.max_clock;

                   /* Update Detailed Timing */
                   for (i=0; i<4; i++)
                   {
                       if (MonInfo->det_mon[i].type == 0xFD) {
                           MonInfo->det_mon[i].section.ranges = ranges;
                       }
                       else if (MonInfo->det_mon[i].type == 0xFA) {
                           for (j=0; j<5; j++) {
         	                  stdtiming.hsize = stdtiming.vsize = stdtiming.refresh = stdtiming.id = 0;
                               for (k=0; k<5; k++) {
                                   if ((stdtiming1[j].hsize == stdtiming2[k].hsize) && \
                                       (stdtiming1[j].vsize == stdtiming2[k].vsize) && \
                                       (stdtiming1[j].refresh == stdtiming2[k].refresh)) {
                                        stdtiming = stdtiming1[j];
                                        break;
                                   }
                               }
                               stdtiming1[j] = stdtiming;
                           } /* Std. Timing */
                       } /* FA */
                       else if (MonInfo->det_mon[i].type == 0x00) {
                           if (DTSelect == DT2)
                               MonInfo->det_mon[i] = MonInfo2->det_mon[i];
                           else if (DTSelect == DT1)
                               MonInfo->det_mon[i] = MonInfo1->det_mon[i];
                           else /* SkipDT */
                           {   /* use 1024x768 as default */
                               MonInfo->det_mon[i] = MonInfo1->det_mon[i];
                               MonInfo->det_mon[i].section.d_timings.clock = 65000000;
                               MonInfo->det_mon[i].section.d_timings.h_active = 1024;
                               MonInfo->det_mon[i].section.d_timings.h_blanking = 320;
                               MonInfo->det_mon[i].section.d_timings.v_active = 768;
                               MonInfo->det_mon[i].section.d_timings.v_blanking = 38;
                               MonInfo->det_mon[i].section.d_timings.h_sync_off = 24;
                               MonInfo->det_mon[i].section.d_timings.h_sync_width = 136;
                               MonInfo->det_mon[i].section.d_timings.v_sync_off = 3;
                               MonInfo->det_mon[i].section.d_timings.v_sync_width = 6;
                           }
                       } /* 00 */
                       else { /* use Monitor 1 as default */
                           MonInfo->det_mon[i] = MonInfo1->det_mon[i];
                       }

                   } /* Update Detailed Timing */

                   /* set feature size */
                   if (DTSelect == DT2)  {
                       MonInfo->features.hsize = MonInfo2->features.hsize;
                       MonInfo->features.vsize = MonInfo2->features.vsize;
                   }
                   else if (DTSelect == DT1)  {
                       MonInfo->features.hsize = MonInfo1->features.hsize;
                       MonInfo->features.vsize = MonInfo1->features.vsize;
                   }
                   else	/* Skip DT */
                   {   /* use 1024x768 as default */
                       MonInfo->features.hsize = 0x20;
                       MonInfo->features.vsize = 0x18;
                   }

               } /* Check with VGA1 & VGA2 EDID */

           } /* ASTGetVGA2EDID */
           else {
               xf86DrvMsg(pScrn->scrnIndex, X_INFO, "Can't Get VGA2 EDID Correctly!! \n");
           }
      } /* VGA2Clone */

      xf86PrintEDID(MonInfo);
      xf86SetDDCproperties(pScrn, MonInfo);
   }
   else
   {
      xf86DrvMsg(pScrn->scrnIndex, X_INFO,"[ASTDoDDC] Can't Load DDC Sub-Modules or Read EDID Failed \n");
   }

   /* Fill pAST Monitor Info */
   if (MonInfo == NULL)
   {	/* default for Non-EDID */
       pAST->mon_h_active = 1024;
       pAST->mon_v_active = 768;
   }
   else
   {	/* save MonInfo to Private */
       pAST->mon_h_active = MonInfo->det_mon[0].section.d_timings.h_active;
       pAST->mon_v_active = MonInfo->det_mon[0].section.d_timings.v_active;
   }

   return MonInfo;
}

static void
vFillASTModeInfo (ScrnInfoPtr pScrn)
{
    ASTRecPtr pAST;

    pAST = ASTPTR(pScrn);

    pAST->VideoModeInfo.ScreenWidth = pScrn->virtualX;
    pAST->VideoModeInfo.ScreenHeight = pScrn->virtualY;
    pAST->VideoModeInfo.bitsPerPixel = pScrn->bitsPerPixel;
    /* Fixed screen pitch incorrect in some specific monitor, ycchen@@071707 */
    pAST->VideoModeInfo.ScreenPitch = pScrn->displayWidth * ((pScrn->bitsPerPixel + 1) / 8) ;

}

static Bool
ASTModeInit(ScrnInfoPtr pScrn, DisplayModePtr mode)
{
    ASTRecPtr pAST;

    pAST = ASTPTR(pScrn);

    pScrn->vtSema = TRUE;
    pAST->ModePtr = mode;

#if	defined(__sparc__) || defined(__mips__)
    if (!ASTSetMode(pScrn, mode))
      return FALSE;
#else
    vgaHWPtr hwp;

    hwp = VGAHWPTR(pScrn);

    vgaHWUnlock(hwp);

    if (!vgaHWInit(pScrn, mode))
      return FALSE;

    pScrn->vtSema = TRUE;
    pAST->ModePtr = mode;

    if (!ASTSetMode(pScrn, mode))
      return FALSE;

    vgaHWProtect(pScrn, FALSE);
#endif

    return TRUE;
}

#ifdef AstVideo
/*
 * Video Part by ic_yang
 */
#include "fourcc.h"

#define NUM_ATTRIBUTES  	8
#define NUM_IMAGES 		8
#define NUM_FORMATS     	3

#define IMAGE_MIN_WIDTH         32
#define IMAGE_MIN_HEIGHT        24
#define IMAGE_MAX_WIDTH         1920
#define IMAGE_MAX_HEIGHT        1080

#define MAKE_ATOM(a) MakeAtom(a, sizeof(a) - 1, TRUE)

static XF86ImageRec ASTImages[NUM_IMAGES] =
{
    XVIMAGE_YUY2, /* If order is changed, ASTOffscreenImages must be adapted */
};

static XF86VideoFormatRec ASTFormats[NUM_FORMATS] =
{
   { 8, PseudoColor},
   {16, TrueColor},
   {24, TrueColor}
};

/* client libraries expect an encoding */
static XF86VideoEncodingRec DummyEncoding =
{
   0,
   "XV_IMAGE",
   0, 0,                /* Will be filled in */
   {1, 1}
};

static char astxvcolorkey[] 				= "XV_COLORKEY";
static char astxvbrightness[] 				= "XV_BRIGHTNESS";
static char astxvcontrast[] 				= "XV_CONTRAST";
static char astxvsaturation[] 				= "XV_SATURATION";
static char astxvhue[] 				        = "XV_HUE";
static char astxvgammared[] 				= "XV_GAMMA_RED";
static char astxvgammagreen[] 				= "XV_GAMMA_GREEN";
static char astxvgammablue[] 				= "XV_GAMMA_BLUE";

static XF86AttributeRec ASTAttributes[NUM_ATTRIBUTES] =
{
   {XvSettable | XvGettable, 0, (1 << 24) - 1, astxvcolorkey},
   {XvSettable | XvGettable, -128, 127, astxvbrightness},
   {XvSettable | XvGettable, 0, 255, astxvcontrast},
   {XvSettable | XvGettable, -180, 180, astxvsaturation},
   {XvSettable | XvGettable, -180, 180, astxvhue},
   {XvSettable | XvGettable, 100, 10000, astxvgammared},
   {XvSettable | XvGettable, 100, 10000, astxvgammagreen},
   {XvSettable | XvGettable, 100, 10000, astxvgammablue},
};

static void ASTStopVideo(ScrnInfoPtr pScrn, pointer data, Bool exit)
{
    ASTPortPrivPtr pPriv = (ASTPortPrivPtr)data;
    ASTPtr pAST = ASTPTR(pScrn);

    REGION_EMPTY(pScrn->pScreen, &pPriv->clip);

    if(exit)
    {
        if(pPriv->fbAreaPtr)
        {
            xf86FreeOffscreenArea(pPriv->fbAreaPtr);
            pPriv->fbAreaPtr = NULL;
            pPriv->fbSize = 0;
        }
        /* clear all flag */
        pPriv->videoStatus = 0;
    }
    else
    {
#if 0
        if(pPriv->videoStatus & CLIENT_VIDEO_ON)
        {
            pPriv->videoStatus |= OFF_TIMER;

        }
#endif
    }
}

static int ASTSetPortAttribute(ScrnInfoPtr pScrn, Atom attribute, INT32 value, pointer data)
{
    ASTPortPrivPtr pPriv = (ASTPortPrivPtr)data;
    ASTPtr pAST = ASTPTR(pScrn);

    xf86DrvMsg(pScrn->scrnIndex, X_INFO,"ASTSetPortAttribute(),attribute=%x\n", attribute);

    if (attribute == pAST->xvBrightness)
    {
        if((value < -128) || (value > 127))
         return BadValue;

        pPriv->brightness = value;
    }
    else if (attribute == pAST->xvContrast)
    {
        if ((value < 0) || (value > 255))
         return BadValue;

        pPriv->contrast = value;
    }
    else if (attribute == pAST->xvSaturation)
    {
        if ((value < -180) || (value > 180))
         return BadValue;

        pPriv->saturation = value;
    }
    else if (attribute == pAST->xvHue)
    {
        if ((value < -180) || (value > 180))
         return BadValue;

        pPriv->hue = value;
    }
    else if (attribute == pAST->xvColorKey)
    {
          pPriv->colorKey = value;
          REGION_EMPTY(pScrn->pScreen, &pPriv->clip);
    }
    else if(attribute == pAST->xvGammaRed)
    {
        if((value < 100) || (value > 10000))
            return BadValue;
        pPriv->gammaR = value;
    }
    else if(attribute == pAST->xvGammaGreen)
    {
        if((value < 100) || (value > 10000))
            return BadValue;
        pPriv->gammaG = value;
    }
    else if(attribute == pAST->xvGammaBlue)
    {
        if((value < 100) || (value > 10000))
            return BadValue;
        pPriv->gammaB = value;
    }
    else
    {
        return BadMatch;
    }

    return Success;
}

static int ASTGetPortAttribute(ScrnInfoPtr pScrn, Atom attribute, INT32 *value, pointer data)
{
    ASTPortPrivPtr pPriv = (ASTPortPrivPtr)data;
    ASTPtr pAST = ASTPTR(pScrn);

    xf86DrvMsg(pScrn->scrnIndex, X_INFO,"ASTGetPortAttribute(),attribute=%x\n", attribute);

    if (attribute == pAST->xvBrightness)
    {
        *value = pPriv->brightness;
    }
    else if (attribute == pAST->xvContrast)
    {
        *value = pPriv->contrast;
    }
    else if (attribute == pAST->xvSaturation)
    {
        *value = pPriv->saturation;
    }
    else if (attribute == pAST->xvHue)
    {
        *value = pPriv->hue;
    }
    else if(attribute == pAST->xvGammaRed)
    {
        *value = pPriv->gammaR;

    }
    else if(attribute == pAST->xvGammaGreen)
    {
        *value = pPriv->gammaG;
    }
    else if(attribute == pAST->xvGammaBlue)
    {
        *value = pPriv->gammaB;
    }
    else if (attribute == pAST->xvColorKey)
    {
        *value = pPriv->colorKey;
    }
    else
        return BadMatch;

    return Success;
}

static void ASTQueryBestSize(ScrnInfoPtr pScrn, Bool motion,
                                short vid_w, short vid_h,
                                short drw_w, short drw_h,
                                unsigned int *p_w, unsigned int *p_h,
                                pointer data)
{
    *p_w = drw_w;
    *p_h = drw_h;
    xf86DrvMsg(pScrn->scrnIndex, X_INFO,"ASTQueryBestSize()\n");
  /* TODO: report the HW limitation */
}

static int ASTQueryImageAttributes(ScrnInfoPtr pScrn, int id,
                                    unsigned short *w, unsigned short *h,
                                    int *pitches, int *offsets)
{
    int pitchY, pitchUV;
    int size, sizeY, sizeUV;

    xf86DrvMsg(pScrn->scrnIndex, X_INFO,"ASTQueryImageAttributes()\n");

    if(*w < IMAGE_MIN_WIDTH) *w = IMAGE_MIN_WIDTH;
    if(*h < IMAGE_MIN_HEIGHT) *h = IMAGE_MIN_HEIGHT;

    switch(id) {
    case PIXEL_FMT_YV12:
        *w = (*w + 7) & ~7;
        *h = (*h + 1) & ~1;
        pitchY = *w;
        pitchUV = *w >> 1;
        if(pitches) {
          pitches[0] = pitchY;
          pitches[1] = pitches[2] = pitchUV;
        }
        sizeY = pitchY * (*h);
        sizeUV = pitchUV * ((*h) >> 1);
        if(offsets) {
          offsets[0] = 0;
          offsets[1] = sizeY;
          offsets[2] = sizeY + sizeUV;
        }
        size = sizeY + (sizeUV << 1);
        break;
    case PIXEL_FMT_NV12:
    case PIXEL_FMT_NV21:
        *w = (*w + 7) & ~7;
        *h = (*h + 1) & ~1;
		pitchY = *w;
    	pitchUV = *w;
    	if(pitches) {
      	    pitches[0] = pitchY;
            pitches[1] = pitchUV;
        }
    	sizeY = pitchY * (*h);
    	sizeUV = pitchUV * ((*h) >> 1);
    	if(offsets) {
          offsets[0] = 0;
          offsets[1] = sizeY;
        }
        size = sizeY + (sizeUV << 1);
        break;
    case PIXEL_FMT_YUY2:
    case PIXEL_FMT_UYVY:
    case PIXEL_FMT_YVYU:
    case PIXEL_FMT_RGB6:
    case PIXEL_FMT_RGB5:
    default:
        *w = (*w + 1) & ~1;
        pitchY = *w << 1;
        if(pitches) pitches[0] = pitchY;
        if(offsets) offsets[0] = 0;
        size = pitchY * (*h);
        break;
    }

    return size;
}

static int ASTPutImage(ScrnInfoPtr pScrn,
                          short src_x, short src_y,
                          short drw_x, short drw_y,
                          short src_w, short src_h,
                          short drw_w, short drw_h,
                          int id, unsigned char* buf,
                          short width, short height,
                          Bool sync,
                          RegionPtr clipBoxes, pointer data
#if GET_ABI_MAJOR(ABI_VIDEODRV_VERSION) >= 1
		          , DrawablePtr pDraw
#endif
)
{
    ASTPtr pAST = ASTPTR(pScrn);
    ASTPortPrivPtr pPriv = (ASTPortPrivPtr)data;
    int i;
    int totalSize=0;

    xf86DrvMsg(pScrn->scrnIndex, X_INFO,"ASTPutImage()\n");
    /*   int depth = pAST->CurrentLayout.bitsPerPixel >> 3; */

    pPriv->drw_x = drw_x;
    pPriv->drw_y = drw_y;
    pPriv->drw_w = drw_w;
    pPriv->drw_h = drw_h;
    pPriv->src_x = src_x;
    pPriv->src_y = src_y;
    pPriv->src_w = src_w;
    pPriv->src_h = src_h;
    pPriv->id = id;
    pPriv->height = height;

    switch(id)
    {
    case PIXEL_FMT_YV12:
    case PIXEL_FMT_NV12:
    case PIXEL_FMT_NV21:
        pPriv->srcPitch = (width + 7) & ~7;
        totalSize = (pPriv->srcPitch * height * 3) >> 1; /* Verified */
    break;
    case PIXEL_FMT_YUY2:
    case PIXEL_FMT_UYVY:
    case PIXEL_FMT_YVYU:
    case PIXEL_FMT_RGB6:
    case PIXEL_FMT_RGB5:
    default:
        pPriv->srcPitch = ((width << 1) + 3) & ~3;	/* Verified */
        totalSize = pPriv->srcPitch * height;
    }

    totalSize += 15;
    totalSize &= ~15;
    /* allocate memory */

    if(totalSize == pPriv->fbSize)
    {
        ;
    }
    else
    {
        int lines, pitch, depth;
        BoxPtr pBox = NULL;

        pPriv->fbSize = totalSize;

        if(pPriv->fbAreaPtr)
        {
             xf86FreeOffscreenArea(pPriv->fbAreaPtr);
        }

        depth = (pScrn->bitsPerPixel + 7 ) / 8;
        pitch = pScrn->displayWidth * depth;
        lines = ((totalSize * 2) / pitch) + 1;
        xf86DrvMsg(pScrn->scrnIndex, X_INFO,"ASTPutImagelines=%x, pitch=%x, displayWidth=%x\n", lines, pitch, pScrn->displayWidth);


        pPriv->fbAreaPtr = xf86AllocateOffscreenArea(pScrn->pScreen,
                                 pScrn->displayWidth,
                                lines, 0, NULL, NULL, NULL);

        if(!pPriv->fbAreaPtr)
        {
            xf86DrvMsg(pScrn->scrnIndex, X_ERROR, "Allocate video memory fails\n");
            return BadAlloc;
        }

        pBox = &(pPriv->fbAreaPtr->box);
        pPriv->bufAddr[0] = (pBox->y1 * pitch) + (pBox->x1 * depth);
        pPriv->bufAddr[1] = pPriv->bufAddr[0] + totalSize;
        xf86DrvMsg(pScrn->scrnIndex, X_INFO, "Put Image, pPriv->bufAddr[0]=0x%08X\n", pPriv->bufAddr[0]);

    }

    /* copy data */
    if(totalSize < 16)
    {
      #ifdef NewPath
        memcpy(pAST->FBVirtualAddr + pPriv->bufAddr[pPriv->currentBuf], buf, totalSize);
      #else /* NewPath */
        switch(id)
        {
        case PIXEL_FMT_YUY2:
        case PIXEL_FMT_UYVY:
        case PIXEL_FMT_YVYU:
        {
             BYTE *Base = (BYTE *)(pAST->FBVirtualAddr + pPriv->bufAddr[pPriv->currentBuf]);
             for(i=0; i<height; i++)
                  memcpy( Base + i * pPriv->srcPitch, buf + i*width*2, width*2);
             break;
        }
        default:
            memcpy(pAST->FBVirtualAddr + pPriv->bufAddr[pPriv->currentBuf], buf, totalSize);
            break;
        } /* switch */
      #endif /* NewPath */
    }
    else
    {
        xf86DrvMsg(pScrn->scrnIndex, X_INFO, "Put Image, copy buf\n");

      #ifdef NewPath
       	memcpy(pAST->FBVirtualAddr + pPriv->bufAddr[pPriv->currentBuf], buf, totalSize);
      #else     /* NewPath */
        switch(id)
        {
        case PIXEL_FMT_YUY2:
        case PIXEL_FMT_UYVY:
        case PIXEL_FMT_YVYU:
        {
            BYTE *Base = (BYTE *)(pAST->FBVirtualAddr + pPriv->bufAddr[pPriv->currentBuf]);
            for(i=0; i<height; i++)
                  memcpy( Base + i * pPriv->srcPitch, buf + i*width*2, width*2);

            /*for(i=0; i<height; i++)
                for(j=0; j<width*2; j++)
                    *(Base+i*pPriv->srcPitch+j) = *(buf + width*i + j);*/
            break;
        }
        default:
        {    BYTE *Base = (BYTE *)(pAST->FBVirtualAddr + pPriv->bufAddr[pPriv->currentBuf]);
            int j;
            for(i=0; i<height; i++)
                for(j=0; j<width; j++)
                   *(Base + width*i + j) = *(buf + width * i + j);
        break;
        }
        } /* end of switch */
      #endif    /* NewPath */
    }

    ASTDisplayVideo(pScrn, pPriv, clipBoxes, id);

    /* update cliplist
    if(!REGION_EQUAL(pScrn->pScreen, &pPriv->clip, clipBoxes))
    {
        REGION_COPY(pScrn->pScreen, &pPriv->clip, clipBoxes);
    }
    else
    {
        xf86XVFillKeyHelper(pScrn->pScreen, 0xFFFFFFFF, clipBoxes);
    }
    */
    pPriv->currentBuf ^= 1;

    return Success;
}

static XF86VideoAdaptorPtr ASTSetupImageVideo(ScreenPtr pScreen)
{
    ScrnInfoPtr pScrn = xf86ScreenToScrn(pScreen);
    ASTPtr pAST = ASTPTR(pScrn);
    XF86VideoAdaptorPtr adapt;
    ASTPortPrivPtr pPriv;


    if(!(adapt = calloc(1, sizeof(XF86VideoAdaptorRec) +
                            sizeof(DevUnion) +
                            sizeof(ASTPortPrivRec))))
        return NULL;

    adapt->type = XvWindowMask | XvInputMask | XvImageMask | XvVideoMask;
    adapt->flags = VIDEO_OVERLAID_IMAGES | VIDEO_CLIP_TO_VIEWPORT;
    adapt->name = "AST Video";

    adapt->nEncodings = 1;
    adapt->pEncodings = &DummyEncoding;

    adapt->nFormats = NUM_FORMATS;
    adapt->pFormats = ASTFormats;
    adapt->nPorts = 1;
    adapt->pPortPrivates = (DevUnion*)(&adapt[1]);

    pPriv = (ASTPortPrivPtr)(&adapt->pPortPrivates[1]);

    adapt->pPortPrivates->ptr = (pointer)(pPriv);
    adapt->pAttributes = ASTAttributes;
    adapt->nAttributes = NUM_ATTRIBUTES;
	adapt->nImages = NUM_IMAGES;
    adapt->pImages = ASTImages;

    adapt->PutVideo = NULL;

    adapt->PutStill = NULL;
    adapt->GetVideo = NULL;
    adapt->GetStill = NULL;
    adapt->StopVideo = ASTStopVideo;
    adapt->SetPortAttribute = ASTSetPortAttribute;
    adapt->GetPortAttribute = ASTGetPortAttribute;
    adapt->QueryBestSize = ASTQueryBestSize;
    adapt->PutImage = ASTPutImage;
    adapt->QueryImageAttributes = ASTQueryImageAttributes;


    pPriv->currentBuf   = 0;
    pPriv->linear       = NULL;
    pPriv->fbAreaPtr    = NULL;
    pPriv->fbSize = 0;
	pPriv->videoStatus  = 0;

    pPriv->colorKey     = 0x000101fe;
    pPriv->brightness   = 0;
    pPriv->contrast     = 128;
    pPriv->saturation   = 0;
    pPriv->hue          = 0;

    /* gotta uninit this someplace */
#if defined(REGION_NULL)
    REGION_NULL(pScreen, &pPriv->clip);
#else
    REGION_INIT(pScreen, &pPriv->clip, NullBox, 0);
#endif

	pAST->adaptor = adapt;

	pAST->xvBrightness = MAKE_ATOM(astxvbrightness);
	pAST->xvContrast   = MAKE_ATOM(astxvcontrast);
	pAST->xvColorKey   = MAKE_ATOM(astxvcolorkey);
	pAST->xvSaturation = MAKE_ATOM(astxvsaturation);
	pAST->xvHue 	   = MAKE_ATOM(astxvhue);
	pAST->xvGammaRed   = MAKE_ATOM(astxvgammared);
    pAST->xvGammaGreen = MAKE_ATOM(astxvgammagreen);
    pAST->xvGammaBlue  = MAKE_ATOM(astxvgammablue);

    return adapt;
}

void ASTInitVideo(ScreenPtr pScreen)
{
    ScrnInfoPtr pScrn = xf86ScreenToScrn(pScreen);
    XF86VideoAdaptorPtr *adaptors, *newAdaptors = NULL;
    XF86VideoAdaptorPtr ASTAdaptor = NULL;
    int num_adaptors;

    ASTAdaptor = ASTSetupImageVideo(pScreen);

    num_adaptors = xf86XVListGenericAdaptors(pScrn, &adaptors);

    if(ASTAdaptor)
    {
        if(!num_adaptors)
        {
            num_adaptors = 1;
            adaptors = &ASTAdaptor;
        }
        else
        {
            newAdaptors = malloc((num_adaptors + 1) * sizeof(XF86VideoAdaptorPtr*));
            if(newAdaptors)
            {
                memcpy(newAdaptors, adaptors, num_adaptors *
                                        sizeof(XF86VideoAdaptorPtr));
                newAdaptors[num_adaptors] = ASTAdaptor;
                adaptors = newAdaptors;
                num_adaptors++;
            }
        }
    }

    if(num_adaptors)
        xf86XVScreenInit(pScreen, adaptors, num_adaptors);

    if(newAdaptors)
        free(newAdaptors);

}
#endif /* AstVideo */
@


1.8
log
@Re-add ast files that previous re-import failed to re-add
@
text
@a42 1
#include "xf86PciInfo.h"
d59 3
a61 41

/* external reference fucntion */
extern Bool ASTMapMem(ScrnInfoPtr pScrn);
extern Bool ASTUnmapMem(ScrnInfoPtr pScrn);
extern Bool ASTMapMMIO(ScrnInfoPtr pScrn);
extern void ASTUnmapMMIO(ScrnInfoPtr pScrn);

extern void vASTOpenKey(ScrnInfoPtr pScrn);
extern Bool bASTRegInit(ScrnInfoPtr pScrn);
extern void GetDRAMInfo(ScrnInfoPtr pScrn);
extern ULONG GetVRAMInfo(ScrnInfoPtr pScrn);
extern ULONG GetMaxDCLK(ScrnInfoPtr pScrn);
extern void GetChipType(ScrnInfoPtr pScrn);
extern void GetScratchOptions(ScrnInfoPtr pScrn);
extern void vASTLoadPalette(ScrnInfoPtr pScrn, int numColors, int *indices, LOCO *colors, VisualPtr pVisual);
extern void ASTDisplayPowerManagementSet(ScrnInfoPtr pScrn, int PowerManagementMode, int flags);
extern void vSetStartAddressCRT1(ASTRecPtr pAST, ULONG base);
extern Bool ASTSetMode(ScrnInfoPtr pScrn, DisplayModePtr mode);
extern Bool GetVGA2EDID(ScrnInfoPtr pScrn, unsigned char *pEDIDBuffer);
extern void vInitDRAMReg(ScrnInfoPtr pScrn);
extern Bool bIsVGAEnabled(ScrnInfoPtr pScrn);
extern void ASTBlankScreen(ScrnInfoPtr pScreen, Bool unblack);
extern Bool InitVGA(ScrnInfoPtr pScrn, ULONG Flags);
extern Bool GetVGAEDID(ScrnInfoPtr pScrn, unsigned char *pEDIDBuffer);
extern Bool bInitAST1180(ScrnInfoPtr pScrn);
extern void GetAST1180DRAMInfo(ScrnInfoPtr pScrn);
extern void vEnableASTVGAMMIO(ScrnInfoPtr pScrn);

extern Bool ReadEDID_M68K(ScrnInfoPtr pScrn, BYTE *pEDIDData);
extern UCHAR GetLinkMaxCLK(ScrnInfoPtr pScrn);

extern Bool bInitCMDQInfo(ScrnInfoPtr pScrn, ASTRecPtr pAST);
extern Bool bEnableCMDQ(ScrnInfoPtr pScrn, ASTRecPtr pAST);
extern void vDisable2D(ScrnInfoPtr pScrn, ASTRecPtr pAST);

#ifdef HAVE_XAA_H
extern Bool ASTAccelInit(ScreenPtr pScreen);
#endif

extern Bool ASTCursorInit(ScreenPtr pScreen);
extern void ASTDisableHWC(ScrnInfoPtr pScrn);
d93 5
a97 1
        int, unsigned char*, short, short, Bool, RegionPtr, pointer);
d284 5
a288 1
                    xf86UnclaimPciSlot(pPci, devSections[0]);
d543 1
a543 1
   /* Resource Allocation */
a544 4
    pAST->IODBase = pScrn->domainIOBase;
#else
    pAST->IODBase = 0;
#endif
d548 7
a555 2
#if GET_ABI_MAJOR(ABI_VIDEODRV_VERSION) < 12
    VGAHWPTR(pScrn)->PIOOffset = /* ... */
a556 2
       	pAST->PIOOffset =
	pAST->IODBase + PCI_REGION_BASE(pAST->PciInfo, 2, REGION_IO) - 0x380;
a557 1
    pAST->RelocateIO = (IOADDRESS)(PCI_REGION_BASE(pAST->PciInfo, 2, REGION_IO) + pAST->IODBase);
d614 1
a614 1
       bInitAST1180(pScrn);
d617 1
a617 1
       GetAST1180DRAMInfo(pScrn);
d624 1
a624 1
       vEnableASTVGAMMIO(pScrn);
d629 1
a629 1
           InitVGA(pScrn, 0);
d641 1
a641 1
           GetChipType(pScrn);
d646 1
a646 1
       GetScratchOptions(pScrn);
d649 2
a650 2
       GetDRAMInfo(pScrn);
       pAST->ulVRAMSize = GetVRAMInfo(pScrn);
d682 1
a682 1
   clockRanges->maxClock = GetMaxDCLK(pScrn) * 1000;
d1053 1
a1053 1
   vDisable2D(pScrn, pAST);
d1073 1
a1073 1
   vSetStartAddressCRT1(pAST, base);
d1085 1
a1085 1
   if (!bIsVGAEnabled(pScrn))
d1088 1
a1088 1
           bInitAST1180(pScrn);
d1091 2
a1092 2
           vEnableASTVGAMMIO(pScrn);
           InitVGA(pScrn, 1);
d1129 1
a1129 1
   vDisable2D(pScrn, pAST);
d1313 1
a1313 1
       vDisable2D(pScrn, pAST);
d1530 1
a1530 1
          Flags = GetVGA2EDID(pScrn, DDC_data);
d1533 1
a1533 1
          Flags = ReadEDID_M68K(pScrn, DDC_data);
d1535 1
a1535 1
              Flags = GetVGAEDID(pScrn, DDC_data);
d1538 1
a1538 1
          Flags = GetVGAEDID(pScrn, DDC_data);
d1580 1
a1580 1
          Flags = GetVGA2EDID(pScrn, DDC_data);
d1584 2
a1585 2
          Flags = ReadEDID_M68K(pScrn, DDC_data);
          if (Flags) pAST->DP501_MaxVCLK = GetLinkMaxCLK(pScrn);
d1587 1
a1587 1
              Flags = GetVGAEDID(pScrn, DDC_data);
d1590 1
a1590 1
          Flags = GetVGAEDID(pScrn, DDC_data);
d1606 1
a1606 1
          if (GetVGA2EDID(pScrn, DDC_data) == TRUE) {
d1738 1
a1738 1
           } /* GetVGA2EDID */
a2095 2
extern void ASTDisplayVideo(ScrnInfoPtr pScrn, ASTPortPrivPtr pPriv, RegionPtr clipBoxes, int id);

d2105 3
@


1.7
log
@Remove a bunch of video drivers that were never built on OpenBSD and
are unlikely to be ported in the future. no objection from miod@@ krw@@.
@
text
@a33 1
#include "mibstore.h"
a41 1
#include "vbe.h"
d50 1
d53 1
d73 1
d82 8
a89 1
extern Bool InitVGA(ScrnInfoPtr pScrn);
d95 1
d97 1
d100 1
a100 1
extern void ASTHideCursor(ScrnInfoPtr pScrn);
d107 7
a113 7
static Bool ASTScreenInit(int Index, ScreenPtr pScreen, int argc, char **argv);
Bool ASTSwitchMode(int scrnIndex, DisplayModePtr mode, int flags);
void ASTAdjustFrame(int scrnIndex, int x, int y, int flags);
static Bool ASTEnterVT(int scrnIndex, int flags);
static void ASTLeaveVT(int scrnIndex, int flags);
static void ASTFreeScreen(int scrnIndex, int flags);
static ModeStatus ASTValidMode(int scrnIndex, DisplayModePtr mode, Bool verbose, int flags);
d119 1
a119 1
static Bool ASTCloseScreen(int scrnIndex, ScreenPtr pScreen);
d127 8
d153 1
d160 1
d166 1
a166 1
   OPTION_MMIO2D,   
d169 1
a169 1
   OPTION_ENG_CAPS,   
d172 2
a173 1
   OPTION_VGA2_CLONE
d177 5
a181 5
   {OPTION_NOACCEL,	"NoAccel",	OPTV_BOOLEAN,	{0},	FALSE},
   {OPTION_MMIO2D,	"MMIO2D",	OPTV_BOOLEAN,	{0},	FALSE},
   {OPTION_SW_CURSOR,	"SWCursor",	OPTV_BOOLEAN,	{0},	FALSE},
   {OPTION_HWC_NUM,	"HWCNumber",	OPTV_INTEGER,	{0},	FALSE},
   {OPTION_ENG_CAPS,	"ENGCaps",	OPTV_INTEGER,	{0},	FALSE},
d183 1
a183 1
   {OPTION_NO_DDC,	"NoDDC",	OPTV_BOOLEAN,	{0}, 	FALSE},
d185 2
a186 1
   {-1,			NULL,		OPTV_NONE,	{0}, 	FALSE}
d203 1
a203 1
#else 
d254 1
a254 1
	
d271 1
a271 1
    GDevPtr *devSections;   
d297 4
a300 1
    xfree(devSections);
d309 17
d337 1
a337 1
	    
d342 1
a342 1
	        pScrn->AdjustFrame = ASTAdjustFrame;   
d347 2
a348 2
	    
	        foundScreen = TRUE;	    
d352 1
a352 1
    } /* end of if flags */	   
d354 2
a355 1
    xfree(usedChips);
d360 37
a407 1
   vgaHWPtr hwp;
d410 4
a413 1
      
d415 1
a415 1
   
d419 1
d440 1
d444 1
d449 2
a450 1
   	
d455 2
d488 1
a488 1
   
d495 1
a495 1
   pScrn->racIoFlags = RAC_COLORMAP | RAC_CURSOR | RAC_VIEWPORT;   
d497 1
a497 1
      
d506 1
a506 1
         xf86DrvMsg(pScrn->scrnIndex, X_ERROR, "call xf86SetGamma failed \n");      	
d514 1
a514 1
   }    
d518 1
a518 1
   }      
d522 1
a522 1
       xf86DrvMsg(pScrn->scrnIndex, X_ERROR, "call ASTGetRec failed \n");   	
d524 1
a524 1
   }    
d536 1
a536 1
    * pScrn->confScreen, pScrn->display, pScrn->monitor, pScrn->numEntities, 
d539 4
a542 4
   xf86CollectOptions(pScrn, NULL);   
   if (!(pAST->Options = xalloc(sizeof(ASTOptions))))
   {  	
      ASTFreeRec(pScrn);   	
d544 1
a544 1
   }      
d547 1
a547 1
    
d575 5
a579 1
    pAST->IODBase = pScrn->domainIOBase;  
d583 7
a589 2
    VGAHWPTR(pScrn)->PIOOffset = pAST->PIOOffset = pAST->IODBase + PCI_REGION_BASE(pAST->PciInfo, 2, REGION_IO) - 0x380;
	
d591 1
a591 1
	
d625 1
a625 1
	      
d627 1
a627 1
   pAST->MMIOMapSize = DEFAULT_MMIO_SIZE; 
d629 1
a629 1
      xf86DrvMsg(pScrn->scrnIndex, X_ERROR, "Map Memory Map IO Failed \n");      	
d633 1
a633 2
   /* Init VGA Adapter */
   if (!xf86IsPrimaryPci(pAST->PciInfo))
d635 18
a652 1
       InitVGA(pScrn);      	
d654 10
d665 2
a666 2
   vASTOpenKey(pScrn);
   bASTRegInit(pScrn);
d668 18
a685 7
   /* Get Chip Type */
   if (PCI_DEV_REVISION(pAST->PciInfo) >= 0x20)
       pAST->jChipType = AST2300;   
   else if (PCI_DEV_REVISION(pAST->PciInfo) >= 0x10)
       GetChipType(pScrn);       
   else
       pAST->jChipType = AST2000;
a686 3
   /* Get DRAM Info */
   GetDRAMInfo(pScrn);
      
a687 1
   pScrn->videoRam = GetVRAMInfo(pScrn) / 1024;
a688 1

d693 1
a693 1
   
d695 2
a696 2
   
#if 0   
d698 1
a698 1
      xf86DrvMsg(pScrn->scrnIndex, X_ERROR, "Map FB Memory Failed \n");      	
d706 1
a706 1
   /* Do DDC 
d709 1
a709 1
   pScrn->monitor->DDC = ASTDoDDC(pScrn, pAST->pEnt->index);    
d715 1
a715 1
   clockRanges->maxClock = GetMaxDCLK(pScrn) * 1000;   
d719 1
a719 1
   
d721 12
a732 2
   if ((pAST->jChipType == AST2100) || (pAST->jChipType == AST2200) || (pAST->jChipType == AST2300))
       i = xf86ValidateModes(pScrn, pScrn->monitor->Modes,
d734 2
a735 2
			 0, 320, 1920, 8 * pScrn->bitsPerPixel,
			 200, 1200,
d738 4
a741 1
   else
d743 6
a748 5
			 pScrn->display->modes, clockRanges,
			 0, 320, 1600, 8 * pScrn->bitsPerPixel,
			 200, 1200,
			 pScrn->display->virtualX, pScrn->display->virtualY,
			 pAST->FbMapSize, LOOKUP_BEST_REFRESH);   
d773 8
a780 3
   pAST->AccelInfoPtr = NULL; 
   pAST->pCMDQPtr = NULL;   
   pAST->CMDQInfo.ulCMDQSize = 0;      
d784 20
a803 18
       if (!xf86LoadSubModule(pScrn, "xaa")) {
	   ASTFreeRec(pScrn);
	   return FALSE;
       }       
       
       pAST->noAccel = FALSE; 
       
       pAST->MMIO2D = TRUE;
#ifndef	MMIO_2D                   
       if (!xf86ReturnOptValBool(pAST->Options, OPTION_MMIO2D, FALSE)) {
           pAST->CMDQInfo.ulCMDQSize = DEFAULT_CMDQ_SIZE;       
           pAST->MMIO2D = FALSE;    	
       }	
#endif

       pAST->ENGCaps = ENG_CAP_ALL;
       if (!xf86GetOptValInteger(pAST->Options, OPTION_ENG_CAPS, &pAST->ENGCaps)) {
           xf86DrvMsg(pScrn->scrnIndex, X_INFO, "No ENG Capability options found\n");      	
a804 5
       
       pAST->DBGSelect = 0;
       if (!xf86GetOptValInteger(pAST->Options, OPTION_DBG_SELECT, &pAST->DBGSelect)) {
           xf86DrvMsg(pScrn->scrnIndex, X_INFO, "No DBG Seleclt options found\n");      	
       }	       
d806 2
a807 1
#endif   
d810 1
a810 1
   pAST->noHWC = TRUE; 
d812 2
a813 2
   pAST->pHWCPtr = NULL;    
#ifdef	HWC   
d819 2
a820 2
      
      pAST->noHWC = FALSE;  
d823 19
a841 4
          xf86DrvMsg(pScrn->scrnIndex, X_INFO, "No HWC_NUM options found\n");      	
      }	
             
   }    
d855 1
a855 1
ASTScreenInit(int scrnIndex, ScreenPtr pScreen, int argc, char **argv)
a858 1
   vgaHWPtr hwp;   
a859 1
 
d861 2
a862 2
   BoxRec FBMemBox;   
   int    AvailFBSize;     
d864 1
a864 1
   pScrn = xf86Screens[pScreen->myNum];
a865 1
   hwp = VGAHWPTR(pScrn);
d868 1
a868 1
      xf86DrvMsg(pScrn->scrnIndex, X_ERROR, "Map FB Memory Failed \n");      	
d871 1
a871 1
      
d876 1
a876 1
   
d882 5
d890 1
a890 1
       }      
a892 2
       
   vgaHWGetIOBase(hwp);
d894 7
a900 1
   vFillASTModeInfo (pScrn);      
d902 1
a902 1
   ASTSave(pScrn);     
d904 1
a904 1
      xf86DrvMsg(pScrn->scrnIndex, X_ERROR, "Mode Init Failed \n");      	  	
d906 1
a906 1
   }   
d909 1
a909 1
   ASTAdjustFrame(scrnIndex, pScrn->frameX0, pScrn->frameY0, 0);
d922 15
a936 1
   }    
d942 11
a952 4
           if (!fbScreenInit(pScreen, pAST->FBVirtualAddr + pScrn->fbOffset,
  	                     pScrn->virtualX, pScrn->virtualY,
		             pScrn->xDpi, pScrn->yDpi,
		             pScrn->displayWidth, pScrn->bitsPerPixel))
d956 2
a957 2
           return FALSE;    
              
d974 2
a975 1
     
d978 17
d997 1
d1003 1
a1003 1
           pAST->noAccel = TRUE;           
d1007 2
a1008 2
     
   miInitializeBackingStore(pScreen);
d1018 1
a1018 1
           pAST->noHWC = TRUE;                      
d1021 1
a1021 1
   
d1025 7
a1031 4
   if(!xf86HandleColormaps(pScreen, 256, (pScrn->depth == 8) ? 8 : pScrn->rgbBits,
                    vASTLoadPalette, NULL,
                    CMAP_PALETTED_TRUECOLOR | CMAP_RELOAD_ON_MODE_SWITCH)) {
       return FALSE;
d1033 1
a1033 1
   
d1035 9
a1043 1
   
d1052 1
a1052 1
   	
d1057 1
a1057 1
ASTSwitchMode(int scrnIndex, DisplayModePtr mode, int flags)
d1059 1
a1059 1
   ScrnInfoPtr pScrn = xf86Screens[scrnIndex];
d1062 11
d1076 1
a1076 1
       pAST->pHWCPtr = NULL;      
d1078 1
a1078 1
   ASTHideCursor(pScrn);
d1081 1
a1081 1
#ifdef Accel_2D 
d1084 2
a1085 2
       pAST->pCMDQPtr = NULL;             
   } 
d1088 1
a1088 1
   
d1091 1
a1091 1
   
d1097 1
a1097 1
ASTAdjustFrame(int scrnIndex, int x, int y, int flags)
d1099 1
a1099 1
   ScrnInfoPtr pScrn = xf86Screens[scrnIndex];
d1102 3
a1104 3
      
   base = y * pAST->VideoModeInfo.ScreenWidth + x * ((pAST->VideoModeInfo.bitsPerPixel + 1) / 8);
   base = base >> 2;				/* DW unit */
d1110 1
a1110 1
/* enter into X Server */		
d1112 1
a1112 1
ASTEnterVT(int scrnIndex, int flags)
d1114 2
a1115 1
   ScrnInfoPtr pScrn = xf86Screens[scrnIndex];
d1120 7
a1126 1
       InitVGA(pScrn);      	   	
d1128 1
a1128 1
   }   
d1132 2
a1133 2
   ASTAdjustFrame(scrnIndex, pScrn->frameX0, pScrn->frameY0, 0);
   
d1135 1
a1135 1
   	
d1140 1
a1140 1
ASTLeaveVT(int scrnIndex, int flags)
d1142 4
a1145 2
	
   ScrnInfoPtr pScrn = xf86Screens[scrnIndex];
d1147 1
a1147 1
   ASTRecPtr pAST = ASTPTR(pScrn);
d1152 1
a1152 1
       pAST->pHWCPtr = NULL;      
d1154 1
a1154 1
   ASTHideCursor(pScrn);
d1157 1
a1157 1
#ifdef Accel_2D  
d1160 2
a1161 2
       pAST->pCMDQPtr = NULL;             
   }    
d1164 9
a1172 3
      
   ASTRestore(pScrn);  
   vgaHWLock(hwp);	
d1177 1
a1177 1
ASTFreeScreen(int scrnIndex, int flags)
d1179 3
a1181 1
   ASTFreeRec(xf86Screens[scrnIndex]);
d1183 2
a1184 1
      vgaHWFreeHWRec(xf86Screens[scrnIndex]);   
a1186 1

d1188 1
a1188 1
ASTValidMode(int scrnIndex, DisplayModePtr mode, Bool verbose, int flags)
d1190 5
a1195 4
   ScrnInfoPtr pScrn = xf86Screens[scrnIndex];
   ASTRecPtr   pAST  = ASTPTR(pScrn);
   Bool Flags = MODE_NOMODE;
   	
d1198 1
a1198 1
	 xf86DrvMsg(scrnIndex, X_PROBED,
d1206 1
a1206 1
	 xf86DrvMsg(scrnIndex, X_PROBED,
d1208 2
a1209 2
      }   	
      return Flags;   	
d1212 7
a1218 2
   /* Add for AST2100, ycchen@@061807 */
   if ( (pAST->jChipType == AST2100) || (pAST->jChipType == AST2200) || (pAST->jChipType == AST2300) )	
d1220 25
a1244 16
       if ( (mode->CrtcHDisplay == 1920) && (mode->CrtcVDisplay == 1200) )
           return MODE_OK;
       if ( (mode->CrtcHDisplay == 1920) && (mode->CrtcVDisplay == 1080) )
           return MODE_OK;
   }
   
   if ((pAST->jChipType == AST1100) || (pAST->jChipType == AST2100) || (pAST->jChipType == AST2200) || (pAST->jChipType == AST2150) || (pAST->jChipType == AST2300))
   {
               
       if ( (mode->CrtcHDisplay == 1680) && (mode->CrtcVDisplay == 1050) )
           return MODE_OK;
       if ( (mode->CrtcHDisplay == 1440) && (mode->CrtcVDisplay == 900) )
           return MODE_OK;
       if ( (mode->CrtcHDisplay == 1280) && (mode->CrtcVDisplay == 800) )
           return MODE_OK;
           
d1246 1
a1246 1
   
d1251 1
a1251 1
       break;        
d1254 1
a1254 1
       break;   
d1257 1
a1257 1
       break;   
d1263 1
a1263 1
       break;   
d1265 1
a1265 1
       return Flags;   	   	
d1267 1
a1267 1
   
d1269 1
a1269 3
   
}			

d1292 2
d1298 3
a1300 1
   xfree(pScrn->driverPrivate);
d1307 1
d1309 1
a1309 1
   /* return vgaHWSaveScreen(pScreen, unblack); */   
d1313 1
a1313 1
      pScrn = xf86Screens[pScreen->myNum];
d1318 2
a1319 1
   return (TRUE);   
d1323 1
a1323 1
ASTCloseScreen(int scrnIndex, ScreenPtr pScreen)
d1325 3
a1327 1
   ScrnInfoPtr pScrn = xf86Screens[scrnIndex];
d1329 1
a1329 1
   ASTRecPtr pAST = ASTPTR(pScrn);
d1332 1
a1332 1
   {  
d1334 13
a1346 5
   if (pAST->pHWCPtr) {
       xf86FreeOffscreenLinear(pAST->pHWCPtr);		/* free HWC Cache */
       pAST->pHWCPtr = NULL;      
   }
   ASTHideCursor(pScrn);
d1348 8
a1355 7
   	   
#ifdef Accel_2D  
   if (pAST->pCMDQPtr) {
       xf86FreeOffscreenLinear(pAST->pCMDQPtr);		/* free CMDQ */
       pAST->pCMDQPtr = NULL;      
   }
   vDisable2D(pScrn, pAST);
a1356 3
         
      ASTRestore(pScrn);
      vgaHWLock(hwp);
d1360 1
d1362 1
d1364 1
d1369 1
a1369 1

d1375 8
d1385 1
a1385 1
   return (*pScreen->CloseScreen) (scrnIndex, pScreen);
d1392 1
a1392 2
   vgaRegPtr vgaReg;
   ASTRegPtr astReg;   
d1394 1
a1396 1
   vgaReg = &VGAHWPTR(pScrn)->SavedReg;
d1398 68
a1465 18
    
   /* do save */    
   if (xf86IsPrimaryPci(pAST->PciInfo)) {
       vgaHWSave(pScrn, vgaReg, VGA_SR_ALL);
   }
   else {
       vgaHWSave(pScrn, vgaReg, VGA_SR_MODE);
   }
   
   /* Ext. Save */
   vASTOpenKey(pScrn);
   
   /* fixed Console Switch Refresh Rate Incorrect issue, ycchen@@051106 */   
   for (i=0x81; i<=0xB6; i++)
       GetIndexReg(CRTC_PORT, (UCHAR) (i), astReg->ExtCRTC[icount++]);
   for (i=0xBC; i<=0xC1; i++)
       GetIndexReg(CRTC_PORT, (UCHAR) (i), astReg->ExtCRTC[icount++]);
   GetIndexReg(CRTC_PORT, (UCHAR) (0xBB), astReg->ExtCRTC[icount]);
d1473 1
a1473 2
   vgaRegPtr vgaReg;
   ASTRegPtr astReg;   
d1475 1
a1477 1
   vgaReg = &VGAHWPTR(pScrn)->SavedReg;
d1479 11
a1489 5
    
   /* do restore */    
   vgaHWProtect(pScrn, TRUE);
   if (xf86IsPrimaryPci(pAST->PciInfo))
       vgaHWRestore(pScrn, vgaReg, VGA_SR_ALL);
d1491 59
a1549 12
       vgaHWRestore(pScrn, vgaReg, VGA_SR_MODE);     
   vgaHWProtect(pScrn, FALSE);   
   
   /* Ext. restore */
   vASTOpenKey(pScrn);
   
   /* fixed Console Switch Refresh Rate Incorrect issue, ycchen@@051106 */
   for (i=0x81; i<=0xB6; i++)
       SetIndexReg(CRTC_PORT, (UCHAR) (i), astReg->ExtCRTC[icount++]);
   for (i=0xBC; i<=0xC1; i++)
       SetIndexReg(CRTC_PORT, (UCHAR) (i), astReg->ExtCRTC[icount++]);
   SetIndexReg(CRTC_PORT, (UCHAR) (0xBB), astReg->ExtCRTC[icount]);
d1556 3
a1558 1
   vbeInfoPtr pVbe;
d1560 23
a1582 4
   if (xf86LoadSubModule(pScrn, "vbe")) {
      pVbe = VBEInit(NULL, index);
      ConfiguredMonitor = vbeDoEDID(pVbe, NULL);
      vbeFree(pVbe);
d1584 1
d1590 1
a1590 1
	
d1594 1
a1594 2
   vbeInfoPtr pVbe;
   xf86MonPtr MonInfo = NULL, MonInfo1 = NULL, MonInfo2 = NULL;
d1596 4
a1600 1
   unsigned char DDC_data[128];
d1604 1
a1604 1
   
d1610 27
a1636 4
   if (xf86LoadSubModule(pScrn, "vbe") && (pVbe = VBEInit(NULL, index))) {
      MonInfo1 = vbeDoEDID(pVbe, NULL);
      MonInfo = MonInfo1;
      
d1640 1
a1640 1
              xf86DrvMsg(pScrn->scrnIndex, X_INFO, "Get VGA2 EDID Correctly!! \n");	
d1645 33
a1677 15
                  /* Update establishment timing */
                  MonInfo->timings1.t1 = MonInfo1->timings1.t1 & MonInfo2->timings1.t1;
                  MonInfo->timings1.t2 = MonInfo1->timings1.t2 & MonInfo2->timings1.t2;
                  MonInfo->timings1.t_manu = MonInfo1->timings1.t_manu & MonInfo2->timings1.t_manu;
                  
                  /* Update Std. Timing */
                  for (i=0; i<8; i++) {
	              stdtiming.hsize = stdtiming.vsize = stdtiming.refresh = stdtiming.id = 0;	              
                      for (j=0; j<8; j++) {                      	
                          if ((MonInfo1->timings2[i].hsize == MonInfo2->timings2[j].hsize) && \
                              (MonInfo1->timings2[i].vsize == MonInfo2->timings2[j].vsize) && \
                              (MonInfo1->timings2[i].refresh == MonInfo2->timings2[j].refresh)) {
                               stdtiming = MonInfo1->timings2[i];
                               break;
                          }        
d1679 11
a1689 89
                      
                      MonInfo->timings2[i] = stdtiming;
                  } /* Std. Timing */
               
                  /* Get Detailed Timing */
                  for (i=0;i<4;i++) {
                    if (MonInfo1->det_mon[i].type == 0xFD)
                        ranges1 = MonInfo1->det_mon[i].section.ranges;
                    else if (MonInfo1->det_mon[i].type == 0xFA)
                        stdtiming1 = MonInfo1->det_mon[i].section.std_t;    
                    else if (MonInfo1->det_mon[i].type == 0x00) {
                        if (MonInfo1->det_mon[i].section.d_timings.clock > dclock1)
                            dclock1 = MonInfo1->det_mon[i].section.d_timings.clock;
                        if (MonInfo1->det_mon[i].section.d_timings.h_active > h_active1)
                            h_active1 = MonInfo1->det_mon[i].section.d_timings.h_active;
                        if (MonInfo1->det_mon[i].section.d_timings.v_active > v_active1)
                            v_active1 = MonInfo1->det_mon[i].section.d_timings.v_active;                            
                    }	
                    if (MonInfo2->det_mon[i].type == 0xFD)
                        ranges2 = MonInfo2->det_mon[i].section.ranges;
                    else if (MonInfo1->det_mon[i].type == 0xFA)
                        stdtiming2 = MonInfo2->det_mon[i].section.std_t;                        
                    else if (MonInfo2->det_mon[i].type == 0x00) {
                        if (MonInfo2->det_mon[i].section.d_timings.clock > dclock2)
                            dclock2 = MonInfo2->det_mon[i].section.d_timings.clock;
                        if (MonInfo2->det_mon[i].section.d_timings.h_active > h_active2)
                            h_active2 = MonInfo2->det_mon[i].section.d_timings.h_active;
                        if (MonInfo2->det_mon[i].section.d_timings.v_active > v_active2)
                            v_active2 = MonInfo2->det_mon[i].section.d_timings.v_active;                            
                    }                                                            	 
                  } /* Get Detailed Timing */

                  /* Chk Detailed Timing */
                  if ((dclock1 >= dclock2) && (h_active1 >= h_active2) && (v_active1 >= v_active2))
                      DTSelect = DT2;
                  else if ((dclock2 >= dclock1) && (h_active2 >= h_active1) && (v_active2 >= v_active1))
                      DTSelect = DT1;
                  else
                      DTSelect = SkipDT;

                  /* Chk Monitor Descriptor */    
                  ranges = ranges1;
                  ranges.min_h = ranges1.min_h > ranges2.min_h ? ranges1.min_h:ranges2.min_h;
                  ranges.min_v = ranges1.min_v > ranges2.min_v ? ranges1.min_v:ranges2.min_v;                  
                  ranges.max_h = ranges1.max_h < ranges2.max_h ? ranges1.max_h:ranges2.max_h;
                  ranges.max_v = ranges1.max_v < ranges2.max_v ? ranges1.max_v:ranges2.max_v;
                  ranges.max_clock = ranges1.max_clock < ranges2.max_clock ? ranges1.max_clock:ranges2.max_clock;
                  
                  /* Update Detailed Timing */
                  for (i=0; i<4; i++)
                  {
                      if (MonInfo->det_mon[i].type == 0xFD) {
                          MonInfo->det_mon[i].section.ranges = ranges;
                      }                      
                      else if (MonInfo->det_mon[i].type == 0xFA) {
                         for (j=0; j<5; j++) {
            	             stdtiming.hsize = stdtiming.vsize = stdtiming.refresh = stdtiming.id = 0;
                             for (k=0; k<5; k++) {
                                 if ((stdtiming1[j].hsize == stdtiming2[k].hsize) && \
                                     (stdtiming1[j].vsize == stdtiming2[k].vsize) && \
                                     (stdtiming1[j].refresh == stdtiming2[k].refresh)) {
                                      stdtiming = stdtiming1[j];
                                      break;
                                 }        
                             }
                             stdtiming1[j] = stdtiming;
                         } /* Std. Timing */                                                    
                      } /* FA */
                      else if (MonInfo->det_mon[i].type == 0x00) {
                          if (DTSelect == DT2)
                              MonInfo->det_mon[i] = MonInfo2->det_mon[i];
                          else if (DTSelect == DT1)
                              MonInfo->det_mon[i] = MonInfo1->det_mon[i];
                          else /* SkipDT */
                          {   /* use 1024x768 as default */
                              MonInfo->det_mon[i] = MonInfo1->det_mon[i];
                              MonInfo->det_mon[i].section.d_timings.clock = 65000000;
                              MonInfo->det_mon[i].section.d_timings.h_active = 1024;
                              MonInfo->det_mon[i].section.d_timings.h_blanking = 320;
                              MonInfo->det_mon[i].section.d_timings.v_active = 768;
                              MonInfo->det_mon[i].section.d_timings.v_blanking = 38;
                              MonInfo->det_mon[i].section.d_timings.h_sync_off = 24;
                              MonInfo->det_mon[i].section.d_timings.h_sync_width = 136;
                              MonInfo->det_mon[i].section.d_timings.v_sync_off = 3;
                              MonInfo->det_mon[i].section.d_timings.v_sync_width = 6;
                          }                                                	
                      } /* 00 */
                      else { /* use Monitor 1 as default */
                          MonInfo->det_mon[i] = MonInfo1->det_mon[i];                      
d1691 86
a1776 27
                
                  } /* Update Detailed Timing */
                  
                  /* set feature size */
                  if (DTSelect == DT2)  {
                      MonInfo->features.hsize = MonInfo2->features.hsize;
                      MonInfo->features.vsize = MonInfo2->features.vsize;                          	
                  }
                  else if (DTSelect == DT1)  {
                      MonInfo->features.hsize = MonInfo1->features.hsize;
                      MonInfo->features.vsize = MonInfo1->features.vsize;                          	
                  }
                  else	/* Skip DT */
                  {   /* use 1024x768 as default */
                      MonInfo->features.hsize = 0x20;
                      MonInfo->features.vsize = 0x18;                  	
                  }	
                                  	               	
              } /* Check with VGA1 & VGA2 EDID */
        	    
          } /* GetVGA2EDID */
          else {
              xf86DrvMsg(pScrn->scrnIndex, X_INFO, "Can't Get VGA2 EDID Correctly!! \n");
          }    
         
      }
      
a1778 4
      vbeFree(pVbe);
   } else {
      xf86DrvMsg(pScrn->scrnIndex, X_INFO,
		 "this driver cannot do DDC without VBE\n");
d1780 17
a1796 1
	
d1804 1
a1804 1
    
d1806 4
a1809 4
    
    pAST->VideoModeInfo.ScreenWidth = pScrn->virtualX;   
    pAST->VideoModeInfo.ScreenHeight = pScrn->virtualY;   
    pAST->VideoModeInfo.bitsPerPixel = pScrn->bitsPerPixel;   
d1818 11
a1829 1
    ASTRecPtr pAST;
a1831 1
    pAST = ASTPTR(pScrn);
d1843 1
a1843 1
    
d1845 1
d1849 566
@


1.6
log
@Update to xf86-video-ast 0.91.10
@
text
@@


1.5
log
@Update to xf86-video-ast 0.89.9
@
text
@d546 4
a549 2
   if (PCI_DEV_REVISION(pAST->PciInfo) >= 0x10)
       GetChipType(pScrn);
d592 1
a592 1
   if ((pAST->jChipType == AST2100) || (pAST->jChipType == AST2200))
d860 2
a861 1
   ASTRestore(pScrn);
d966 1
a966 1
   if ((pAST->jChipType == AST2100) || (pAST->jChipType == AST2200))
d970 14
@


1.4
log
@update to xf86-video-ast 0.89.0
@
text
@d28 1
d31 1
d69 1
d79 3
a166 87
const char *vgahwSymbols[] = {
   "vgaHWFreeHWRec",
   "vgaHWGetHWRec",
   "vgaHWGetIOBase",
   "vgaHWGetIndex",
   "vgaHWInit",
   "vgaHWLock",
   "vgaHWMapMem",
   "vgaHWProtect",
   "vgaHWRestore",
   "vgaHWSave",
   "vgaHWSaveScreen",
   "vgaHWSetMmioFuncs",
   "vgaHWUnlock",
   "vgaHWUnmapMem",
   NULL
};

const char *fbSymbols[] = {
   "fbPictureInit",
   "fbScreenInit",
   NULL
};

const char *vbeSymbols[] = {
   "VBEInit",
   "VBEFreeModeInfo",
   "VBEFreeVBEInfo",
   "VBEGetModeInfo",
   "VBEGetModePool",
   "VBEGetVBEInfo",
   "VBEGetVBEMode",
   "VBEPrintModes",
   "VBESaveRestore",
   "VBESetDisplayStart",
   "VBESetGetDACPaletteFormat",
   "VBESetGetLogicalScanlineLength",
   "VBESetGetPaletteData",
   "VBESetModeNames",
   "VBESetModeParameters",
   "VBESetVBEMode",
   "VBEValidateModes",
   "vbeDoEDID",
   "vbeFree",
   NULL
};

#ifdef XFree86LOADER
static const char *vbeOptionalSymbols[] = {
   "VBEDPMSSet",
   "VBEGetPixelClock",
   NULL
};
#endif

const char *ddcSymbols[] = {
   "xf86PrintEDID",
   "xf86SetDDCproperties",
   NULL
};

const char *int10Symbols[] = {
   "xf86ExecX86int10",
   "xf86InitInt10",
   "xf86Int10AllocPages",
   "xf86int10Addr",
   "xf86FreeInt10",
   NULL
};

const char *xaaSymbols[] = {
   "XAACreateInfoRec",
   "XAADestroyInfoRec",
   "XAAInit",
   "XAACopyROP",
   "XAAPatternROP",
   NULL
};

const char *ramdacSymbols[] = {
   "xf86CreateCursorInfoRec",
   "xf86DestroyCursorInfoRec",
   "xf86InitCursor",
   NULL
};


a201 9
       * Tell the loader about symbols from other modules that this module
       * might refer to.
       */
      LoaderRefSymLists(vgahwSymbols,
			fbSymbols, xaaSymbols, ramdacSymbols,
			vbeSymbols, vbeOptionalSymbols,
			ddcSymbols, int10Symbols, NULL);

      /*
d352 1
d355 1
a359 1
   xf86LoaderReqSymLists(vgahwSymbols, NULL);
a363 1
   xf86LoaderReqSymLists(fbSymbols, NULL);      
d405 1
d408 1
d539 1
a539 7
       if (xf86LoadSubModule(pScrn, "int10")) {
 	       xf86Int10InfoPtr pInt10;
	       xf86LoaderReqSymLists(int10Symbols, NULL);
	       xf86DrvMsg(pScrn->scrnIndex,X_INFO,"initializing int10\n");
	       pInt10 = xf86InitInt10(pAST->pEnt->index);
	       xf86FreeInt10(pInt10);
       }
d551 2
a552 4
   if (!xf86IsPrimaryPci(pAST->PciInfo))
   {   
       vInitDRAMReg (pScrn);
   }
a637 1
       xf86LoaderReqSymLists(xaaSymbols, NULL);
a670 1
      xf86LoaderReqSymLists(ramdacSymbols, NULL);
d681 1
d685 1
d884 7
d1027 11
a1037 1
   return vgaHWSaveScreen(pScreen, unblack);
a1184 1
      xf86LoaderReqSymLists(vbeSymbols, NULL);
@


1.3
log
@update to xf86-video-ast 0.88.8
@
text
@d661 1
d666 1
d802 5
@


1.2
log
@xf86-video-ast 0.85.0
@
text
@d69 1
d74 2
d127 2
a128 1
   {PCI_CHIP_AST2000,	"AST2000"},
d134 1
d145 2
a146 1
   OPTION_NO_DDC
d151 2
a152 2
   {OPTION_MMIO2D,	"MMIO2D",	OPTV_BOOLEAN,	{0},	FALSE},   
   {OPTION_SW_CURSOR,	"SWCursor",	OPTV_BOOLEAN,	{0},	FALSE},	
d154 4
a157 3
   {OPTION_ENG_CAPS,	"ENGCaps",	OPTV_INTEGER,	{0},	FALSE},	          	  
   {OPTION_DBG_SELECT,	"DBGSelect",	OPTV_INTEGER,	{0},	FALSE},	       
   {OPTION_NO_DDC,	"NoDDC",	OPTV_BOOLEAN,	{0}, 	FALSE},   
d227 1
a574 3
#if XF86_VERSION_CURRENT < XF86_VERSION_NUMERIC(4,2,99,0,0)
    pAST->IODBase = 0;
#else
a575 1
#endif
d605 1
a605 1
	 pAST->MMIOPhysAddr = PCI_REGION_BASE(pAST->PciInfo, 1, REGION_IO) & 0xFFFF0000;
d617 34
a653 1

d658 1
a658 1

d660 1
a660 3
   pAST->MMIOMapSize = DEFAULT_MMIO_SIZE;

   /* Map resource */
a664 5
   
   if (!ASTMapMMIO(pScrn)) {
      xf86DrvMsg(pScrn->scrnIndex, X_ERROR, "Map Memory Map IO Failed \n");      	
      return FALSE;
   }
a668 6
   /* Get Revision */
   if (PCI_DEV_REVISION(pAST->PciInfo) >= 0x10)
       pAST->jChipType = AST2100;
   else
       pAST->jChipType = AST2000;

d684 1
a684 1
   if (pAST->jChipType == AST2100)
d1045 1
a1045 1
   if (pAST->jChipType == AST2100)
a1108 1
   /* more ref. SiS */	
d1172 6
a1177 1
   vgaHWSave(pScrn, vgaReg, VGA_SR_ALL);
d1204 5
a1208 2
   vgaHWProtect(pScrn, TRUE);   
   vgaHWRestore(pScrn, vgaReg, VGA_SR_ALL);	      
d1235 4
d1243 1
a1243 1
   xf86MonPtr MonInfo = NULL;
d1245 6
a1250 1

d1258 144
a1401 1
      MonInfo = vbeDoEDID(pVbe, NULL);
d1409 1
a1409 1

@


1.1
log
@Initial revision
@
text
@d81 1
d112 1
a112 1
DriverRec AST = {
d252 3
d256 1
d261 1
a261 1
XF86ModuleData astModuleData = { &astVersRec, astSetup, NULL };
d342 1
d350 1
d522 1
d525 1
d556 1
a556 1
						 pAST->PciInfo->chipType);
d575 1
a575 1
    VGAHWPTR(pScrn)->PIOOffset = pAST->PIOOffset = pAST->IODBase + pAST->PciInfo->ioBase[2] - 0x380;
d577 1
a577 1
    pAST->RelocateIO = (IOADDRESS)(pAST->PciInfo->ioBase[2] + pAST->IODBase);
d583 2
a584 2
      if (pAST->PciInfo->memBase[0] != 0) {
	 pAST->FBPhysAddr = pAST->PciInfo->memBase[0] & 0xFFF00000;
d600 2
a601 2
      if (pAST->PciInfo->memBase[1]) {
	 pAST->MMIOPhysAddr = pAST->PciInfo->memBase[1] & 0xFFFF0000;
d639 6
d659 10
a668 1
   i = xf86ValidateModes(pScrn, pScrn->monitor->Modes,
d673 1
a673 1
			 pAST->FbMapSize, LOOKUP_BEST_REFRESH);
d911 2
a912 1
   }    
d970 2
a971 1
   }    
d1000 2
d1019 7
d1102 2
a1103 1
   }    
d1142 1
a1142 1
   int i;
d1154 7
a1160 3
   for (i=0; i<0x50; i++)
       GetIndexReg(CRTC_PORT, (UCHAR) (i+0x80), astReg->ExtCRTC[i]);   	
   
d1169 1
a1169 1
   int i;
d1183 7
a1189 3
   for (i=0; i<0x50; i++)
       SetIndexReg(CRTC_PORT, (UCHAR) (i+0x80), astReg->ExtCRTC[i]);   	
   
d1240 2
a1241 1
    pAST->VideoModeInfo.ScreenPitch = pScrn->virtualX * ((pScrn->bitsPerPixel + 1) / 8) ;       
@


1.1.1.1
log
@Importing xf86-video-ast 0.81.0
@
text
@@


1.1.1.2
log
@Re-import xf86-video-ast.
This chipset is found in HP Proliant MicroServer remote access cards
among others. ok kettenis, seems like a good idea to jasper@@.
@
text
@a27 1
#if GET_ABI_MAJOR(ABI_VIDEODRV_VERSION) < 6
a29 1
#endif
d32 1
d41 1
a49 1
#ifdef HAVE_XAA_H
a51 1
#endif
a66 1
extern void GetDRAMInfo(ScrnInfoPtr pScrn);
a68 2
extern void GetChipType(ScrnInfoPtr pScrn);
extern void GetScratchOptions(ScrnInfoPtr pScrn);
a72 12
extern Bool GetVGA2EDID(ScrnInfoPtr pScrn, unsigned char *pEDIDBuffer);
extern void vInitDRAMReg(ScrnInfoPtr pScrn);
extern Bool bIsVGAEnabled(ScrnInfoPtr pScrn);
extern void ASTBlankScreen(ScrnInfoPtr pScreen, Bool unblack);
extern Bool InitVGA(ScrnInfoPtr pScrn, ULONG Flags);
extern Bool GetVGAEDID(ScrnInfoPtr pScrn, unsigned char *pEDIDBuffer);
extern Bool bInitAST1180(ScrnInfoPtr pScrn);
extern void GetAST1180DRAMInfo(ScrnInfoPtr pScrn);
extern void vEnableASTVGAMMIO(ScrnInfoPtr pScrn);

extern Bool ReadEDID_M68K(ScrnInfoPtr pScrn, BYTE *pEDIDData);
extern UCHAR GetLinkMaxCLK(ScrnInfoPtr pScrn);
a77 1
#ifdef HAVE_XAA_H
a78 1
#endif
a80 1
extern void ASTDisableHWC(ScrnInfoPtr pScrn);
d87 7
a93 7
static Bool ASTScreenInit(SCREEN_INIT_ARGS_DECL);
Bool ASTSwitchMode(SWITCH_MODE_ARGS_DECL);
void ASTAdjustFrame(ADJUST_FRAME_ARGS_DECL);
static Bool ASTEnterVT(VT_FUNC_ARGS_DECL);
static void ASTLeaveVT(VT_FUNC_ARGS_DECL);
static void ASTFreeScreen(FREE_SCREEN_ARGS_DECL);
static ModeStatus ASTValidMode(SCRN_ARG_TYPE arg, DisplayModePtr mode, Bool verbose, int flags);
d99 1
a99 1
static Bool ASTCloseScreen(CLOSE_SCREEN_ARGS_DECL);
a106 8
#ifdef AstVideo
/* video function */
static void ASTInitVideo(ScreenPtr pScreen);
static int  ASTPutImage( ScrnInfoPtr,
        short, short, short, short, short, short, short, short,
        int, unsigned char*, short, short, Bool, RegionPtr, pointer);
#endif

d111 1
a111 1
_X_EXPORT DriverRec AST = {
d123 1
a123 3
   {PCI_CHIP_AST2000,	"ASPEED Graphics Family"},
   {PCI_CHIP_AST2100,	"ASPEED Graphics Family"},
   {PCI_CHIP_AST1180,	"ASPEED AST1180 Graphics"},
a128 2
   {PCI_CHIP_AST2100,		PCI_CHIP_AST2100,	RES_SHARED_VGA},
   {PCI_CHIP_AST1180,		PCI_CHIP_AST1180,	RES_SHARED_VGA},
d134 1
a134 1
   OPTION_MMIO2D,
d137 1
a137 1
   OPTION_ENG_CAPS,
d139 1
a139 3
   OPTION_NO_DDC,
   OPTION_VGA2_CLONE,
   OPTION_SHADOW_FB
d143 77
a219 10
   {OPTION_NOACCEL,	      "NoAccel",	OPTV_BOOLEAN,	{0},	FALSE},
   {OPTION_MMIO2D,	       "MMIO2D",	OPTV_BOOLEAN,	{0},	FALSE},
   {OPTION_SW_CURSOR,	 "SWCursor",	OPTV_BOOLEAN,	{0},	FALSE},
   {OPTION_HWC_NUM,	    "HWCNumber",	OPTV_INTEGER,	{0},	FALSE},
   {OPTION_ENG_CAPS,	  "ENGCaps",	OPTV_INTEGER,	{0},	FALSE},
   {OPTION_DBG_SELECT,	"DBGSelect",	OPTV_INTEGER,	{0},	FALSE},
   {OPTION_NO_DDC,	        "NoDDC",	OPTV_BOOLEAN,	{0}, 	FALSE},
   {OPTION_VGA2_CLONE,	"VGA2Clone",	OPTV_BOOLEAN,	{0}, 	FALSE},
   {OPTION_SHADOW_FB,    "ShadowFB",	OPTV_BOOLEAN,	{0},	FALSE},
   {-1,			               NULL,	   OPTV_NONE,	{0}, 	FALSE}
d222 17
a250 3
#ifdef PATCH_ABI_VERSION
   ABI_VIDEODRV_VERSION_PATCH,
#else
a251 1
#endif
d256 1
a256 1
_X_EXPORT XF86ModuleData astModuleData = { &astVersRec, astSetup, NULL };
d270 9
d309 1
a309 1

d326 1
a326 1
    GDevPtr *devSections;
a336 1
#ifndef XSERVER_LIBPCIACCESS
a343 1
#endif
d350 1
a350 4
    if (numUsed <= 0) {
	free(devSections);
	return FALSE;
    }
a358 17
#ifdef XSERVER_LIBPCIACCESS
            {
                struct pci_device *pPci = xf86GetPciInfoForEntity(usedChips[i]);

                if (pci_device_has_kernel_driver(pPci)) {
                    xf86DrvMsg(0, X_ERROR,
                               "ast: The PCI device 0x%x at %2.2d@@%2.2d:%2.2d:%1.1d has a kernel module claiming it.\n",
                               pPci->device_id, pPci->bus, pPci->domain, pPci->dev, pPci->func);
                    xf86DrvMsg(0, X_ERROR,
                               "ast: This driver cannot operate until it has been unloaded.\n");
                    xf86UnclaimPciSlot(pPci, devSections[0]);
                    free(devSections);
                    return FALSE;
                }
            }
#endif

d370 1
a370 1

d375 1
a375 1
	        pScrn->AdjustFrame = ASTAdjustFrame;
d380 2
a381 2

	        foundScreen = TRUE;
d385 1
a385 1
    } /* end of if flags */
d387 1
a387 2
    free(devSections);
    free(usedChips);
a391 37
#ifdef	Support_ShadowFB
static void *
ASTWindowLinear(ScreenPtr pScreen, CARD32 row, CARD32 offset, int mode,
		        CARD32 *size, void *closure)
{
    ScrnInfoPtr pScrn = xf86ScreenToScrn(pScreen);
    ASTPtr pAST = ASTPTR(pScrn);
    int stride = pScrn->displayWidth * ((pScrn->bitsPerPixel + 1) / 8);

    *size =  stride;
    return ((uint8_t *)pAST->FBVirtualAddr + pScrn->fbOffset + row * stride + offset);

}

static void
ASTUpdatePacked(ScreenPtr pScreen, shadowBufPtr pBuf)
{
    shadowUpdatePacked(pScreen, pBuf);
}

static Bool
ASTCreateScreenResources(ScreenPtr pScreen)
{
    ScrnInfoPtr pScrn = xf86ScreenToScrn(pScreen);
    ASTPtr pAST = ASTPTR(pScrn);
    Bool ret;

    pScreen->CreateScreenResources = pAST->CreateScreenResources;
    ret = pScreen->CreateScreenResources(pScreen);
    pScreen->CreateScreenResources = ASTCreateScreenResources;
    shadowAdd(pScreen, pScreen->GetScreenPixmap(pScreen), pAST->update,
	          pAST->window, 0, 0);

    return ret;
}
#endif	/* Support_ShadowFB */

d403 1
d406 1
a406 4
#if	!(defined(__sparc__)) && !(defined(__mips__))
   vgaHWPtr hwp;
#endif

d408 1
a408 1

a411 1
   int maxPitch, maxHeight;
a426 1
#ifndef XSERVER_LIBPCIACCESS
a428 1
#endif
a429 1
#if	!(defined(__sparc__)) && !(defined(__mips__))
d433 1
a433 1
#endif
d438 2
a439 2

#if	!(defined(__sparc__)) && !(defined(__mips__))
a443 2
   vgaHWSetStdFuncs(hwp);
#endif
d475 1
a475 1

a479 1
#ifndef XSERVER_LIBPCIACCESS
d481 2
a482 3
   pScrn->racIoFlags = RAC_COLORMAP | RAC_CURSOR | RAC_VIEWPORT;
#endif

d491 1
a491 1
         xf86DrvMsg(pScrn->scrnIndex, X_ERROR, "call xf86SetGamma failed \n");
d499 1
a499 1
   }
d503 1
a503 1
   }
d507 1
a507 1
       xf86DrvMsg(pScrn->scrnIndex, X_ERROR, "call ASTGetRec failed \n");
d509 1
a509 1
   }
a514 1
#ifndef XSERVER_LIBPCIACCESS
a516 1
#endif
d519 1
a519 1
    * pScrn->confScreen, pScrn->display, pScrn->monitor, pScrn->numEntities,
d522 4
a525 4
   xf86CollectOptions(pScrn, NULL);
   if (!(pAST->Options = malloc(sizeof(ASTOptions))))
   {
      ASTFreeRec(pScrn);
d527 1
a527 1
   }
d530 1
a530 1

d547 1
a547 1
						 PCI_DEV_DEVICE_ID(pAST->PciInfo));
d558 2
a559 2
#if GET_ABI_MAJOR(ABI_VIDEODRV_VERSION) < 12
    pAST->IODBase = pScrn->domainIOBase;
d561 1
a561 1
    pAST->IODBase = 0;
d566 4
a569 9

#if GET_ABI_MAJOR(ABI_VIDEODRV_VERSION) < 12
    VGAHWPTR(pScrn)->PIOOffset = /* ... */
#endif
       	pAST->PIOOffset =
	pAST->IODBase + PCI_REGION_BASE(pAST->PciInfo, 2, REGION_IO) - 0x380;

    pAST->RelocateIO = (IOADDRESS)(PCI_REGION_BASE(pAST->PciInfo, 2, REGION_IO) + pAST->IODBase);

d574 2
a575 2
      if (PCI_REGION_BASE(pAST->PciInfo, 0, REGION_MEM) != 0) {
	 pAST->FBPhysAddr = PCI_REGION_BASE(pAST->PciInfo, 0, REGION_MEM) & 0xFFF00000;
d591 2
a592 2
      if (PCI_REGION_BASE(pAST->PciInfo, 1, REGION_MEM)) {
	 pAST->MMIOPhysAddr = PCI_REGION_BASE(pAST->PciInfo, 1, REGION_MEM) & 0xFFFF0000;
d603 3
a606 60
   /* Map MMIO */
   pAST->MMIOMapSize = DEFAULT_MMIO_SIZE;
   if (!ASTMapMMIO(pScrn)) {
      xf86DrvMsg(pScrn->scrnIndex, X_ERROR, "Map Memory Map IO Failed \n");
      return FALSE;
   }

   if (PCI_DEV_DEVICE_ID(pAST->PciInfo) == PCI_CHIP_AST1180)
   {
       pAST->jChipType = AST1180;

       /* validate mode */
       if ( (pScrn->bitsPerPixel == 8) || (pScrn->depth == 8) )
       {
           xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
		      "Given bpp (%d) is not supported by ast driver\n",
		      pScrn->bitsPerPixel);
           return FALSE;
       }

       /* Init AST1180 */
       bInitAST1180(pScrn);

       /* Get AST1180 Information */
       GetAST1180DRAMInfo(pScrn);
       pScrn->videoRam = pAST->ulVRAMSize / 1024;

   }
   else
   {
       /* Enable VGA MMIO Access */
       vEnableASTVGAMMIO(pScrn);

       /* Init VGA Adapter */
       if (!xf86IsPrimaryPci(pAST->PciInfo))
       {
           InitVGA(pScrn, 0);
       }

       vASTOpenKey(pScrn);
       bASTRegInit(pScrn);

       /* Get Chip Type */
       if (PCI_DEV_REVISION(pAST->PciInfo) >= 0x30)
           pAST->jChipType = AST2400;
       else if (PCI_DEV_REVISION(pAST->PciInfo) >= 0x20)
           pAST->jChipType = AST2300;
       else if (PCI_DEV_REVISION(pAST->PciInfo) >= 0x10)
           GetChipType(pScrn);
       else
           pAST->jChipType = AST2000;

       /* Get Options from Scratch */
       GetScratchOptions(pScrn);

       /* Get DRAM Info */
       GetDRAMInfo(pScrn);
       pAST->ulVRAMSize = GetVRAMInfo(pScrn);
       pScrn->videoRam  = pAST->ulVRAMSize / 1024;
   }
a607 2
   /* Map Framebuffer */
   from = X_DEFAULT;
d614 1
d616 1
a616 1
#if 0
d618 6
a623 1
      xf86DrvMsg(pScrn->scrnIndex, X_ERROR, "Map FB Memory Failed \n");
a625 1
#endif
d630 1
a630 1
   /* Do DDC
d633 1
a633 1
   pScrn->monitor->DDC = ASTDoDDC(pScrn, pAST->pEnt->index);
d639 1
a639 1
   clockRanges->maxClock = GetMaxDCLK(pScrn) * 1000;
d643 1
a643 13

   /* Add for AST2100, ycchen@@061807 */
   if ((pAST->jChipType == AST2100) || (pAST->jChipType == AST2200) || (pAST->jChipType == AST2300) || (pAST->jChipType == AST2400) || (pAST->jChipType == AST1180))
   {
       maxPitch  = 1920;
       maxHeight = 1200;
   }
   else
   {
       maxPitch  = 1600;
       maxHeight = 1200;
   }

d646 2
a647 2
			 0, 320, maxPitch, 8 * pScrn->bitsPerPixel,
			 200, maxHeight,
a650 11
   /* fixed some monitors can't get propery validate modes using estimated ratio modes */
   if (i < 2)		/* validate modes are too few */
   {
       i = xf86ValidateModes(pScrn, pScrn->monitor->Modes,
			     pScrn->display->modes, clockRanges,
			     0, 320, maxPitch, 8 * pScrn->bitsPerPixel,
			     200, maxHeight,
			     pAST->mon_h_active, pAST->mon_v_active,
			     pAST->FbMapSize, LOOKUP_BEST_REFRESH);
   }

d674 3
a676 8
   pAST->pCMDQPtr = NULL;
   pAST->CMDQInfo.ulCMDQSize 		= 0;
   pAST->CMDQInfo.pjCmdQBasePort    = pAST->MMIOVirtualAddr+ 0x8044;
   pAST->CMDQInfo.pjWritePort       = pAST->MMIOVirtualAddr+ 0x8048;
   pAST->CMDQInfo.pjReadPort        = pAST->MMIOVirtualAddr+ 0x804C;
   pAST->CMDQInfo.pjEngStatePort    = pAST->MMIOVirtualAddr+ 0x804C;
#ifdef HAVE_XAA_H
   pAST->AccelInfoPtr = NULL;
d680 19
a698 20
       if (xf86LoadSubModule(pScrn, "xaa")) {

           pAST->noAccel = FALSE;
           pAST->MMIO2D  = TRUE;
#ifndef	MMIO_2D
           if (!xf86ReturnOptValBool(pAST->Options, OPTION_MMIO2D, FALSE)) {
	       pAST->CMDQInfo.ulCMDQSize = DEFAULT_CMDQ_SIZE;
	       pAST->MMIO2D = FALSE;
           }
#endif

           pAST->ENGCaps = ENG_CAP_ALL;
           if (!xf86GetOptValInteger(pAST->Options, OPTION_ENG_CAPS, &pAST->ENGCaps)) {
	       xf86DrvMsg(pScrn->scrnIndex, X_INFO, "No ENG Capability options found\n");
           }

           pAST->DBGSelect = 0;
           if (!xf86GetOptValInteger(pAST->Options, OPTION_DBG_SELECT, &pAST->DBGSelect)) {
	       xf86DrvMsg(pScrn->scrnIndex, X_INFO, "No DBG Seleclt options found\n");
           }
d700 5
d706 1
a706 2
#endif
#endif /* HAVE_XAA_H */
d709 1
a709 1
   pAST->noHWC = TRUE;
d711 2
a712 2
   pAST->pHWCPtr = NULL;
#ifdef	HWC
d718 3
a720 2

      pAST->noHWC = FALSE;
d723 4
a726 4
          xf86DrvMsg(pScrn->scrnIndex, X_INFO, "No HWC_NUM options found\n");
      }

   }
a728 16
   /* ShadowFB */
#ifdef	Support_ShadowFB
   pAST->shadowFB = FALSE;
   if (pAST->noAccel == TRUE)	/* enable shadowFB only noAccel */
   {
       if (xf86ReturnOptValBool(pAST->Options, OPTION_SHADOW_FB, TRUE))
       {
	       if (xf86LoadSubModule(pScrn, "shadow")) {
	          xf86DrvMsg(pScrn->scrnIndex, X_INFO, "Using \"Shadow Framebuffer\"\n");
	          pAST->shadowFB = TRUE;
	       }
       }
   }
#endif

#ifndef XSERVER_LIBPCIACCESS
a731 1
#endif
d738 1
a738 1
ASTScreenInit(SCREEN_INIT_ARGS_DECL)
d742 1
d744 1
d746 2
a747 2
   BoxRec FBMemBox;
   int    AvailFBSize;
d749 1
a749 1
   pScrn = xf86ScreenToScrn(pScreen);
d751 2
a752 6

   if (!ASTMapMem(pScrn)) {
      xf86DrvMsg(pScrn->scrnIndex, X_ERROR, "Map FB Memory Failed \n");
      return FALSE;
   }

d757 1
a757 1

a762 5
       if (FBMemBox.y2 < 0)
           FBMemBox.y2 = 32767;
       if (FBMemBox.y2 < pScrn->virtualY)
           return FALSE;

d766 1
a766 1
       }
d769 2
d772 1
a772 5
#if	!(defined(__sparc__)) && !(defined(__mips__))
   vgaHWPtr hwp;
   hwp = VGAHWPTR(pScrn);
   vgaHWSetMmioFuncs(hwp, pAST->MMIOVirtualAddr, 0);
#endif
d774 1
a774 3
   vFillASTModeInfo (pScrn);

   ASTSave(pScrn);
d776 1
a776 1
      xf86DrvMsg(pScrn->scrnIndex, X_ERROR, "Mode Init Failed \n");
d778 1
a778 1
   }
d781 1
a781 1
   ASTAdjustFrame(ADJUST_FRAME_ARGS(pScrn, pScrn->frameX0, pScrn->frameY0));
d794 1
a794 15
   }

   /* allocate shadowFB */
#ifdef	Support_ShadowFB
   pAST->shadowFB_validation = FALSE;
   if (pAST->shadowFB) {
      pAST->shadow = calloc(1, pScrn->displayWidth * pScrn->virtualY *
				     ((pScrn->bitsPerPixel + 7) / 8));
	  if (!pAST->shadow) {
	     xf86DrvMsg(pScrn->scrnIndex, X_ERROR, "Failed to allocate shadow buffer\n");
	  }
	  else
	     pAST->shadowFB_validation = TRUE;
   }
#endif
d800 4
a803 11
#ifdef	Support_ShadowFB
           if (!fbScreenInit(pScreen, pAST->shadowFB_validation ? pAST->shadow : (pAST->FBVirtualAddr + pScrn->fbOffset),
  	                         pScrn->virtualX, pScrn->virtualY,
		                     pScrn->xDpi, pScrn->yDpi,
		                     pScrn->displayWidth, pScrn->bitsPerPixel))
#else
	       if (!fbScreenInit(pScreen, pAST->FBVirtualAddr + pScrn->fbOffset,
			                 pScrn->virtualX, pScrn->virtualY,
			                 pScrn->xDpi, pScrn->yDpi,
			                 pScrn->displayWidth, pScrn->bitsPerPixel))
#endif
d807 2
a808 2
           return FALSE;

d825 1
a825 2

   /* Must be after RGB order fixed */
a827 17
   /* shadowFB setup */
#ifdef	Support_ShadowFB
   if (pAST->shadowFB_validation) {
      pAST->update = ASTUpdatePacked;
	  pAST->window = ASTWindowLinear;

      if (!shadowSetup(pScreen))
      {
	     xf86DrvMsg(pScrn->scrnIndex, X_ERROR, "Failed to setup shadow buffer\n");
	     return FALSE;
      }

	  pAST->CreateScreenResources = pScreen->CreateScreenResources;
	  pScreen->CreateScreenResources = ASTCreateScreenResources;
   }
#endif

a829 1
#ifdef HAVE_XAA_H
d835 1
a835 1
           pAST->noAccel = TRUE;
d839 2
a840 2
#endif

d850 1
a850 1
           pAST->noHWC = TRUE;
d853 1
a853 1

d857 4
a860 7
   if (pAST->jChipType != AST1180)
   {
       if(!xf86HandleColormaps(pScreen, 256, (pScrn->depth == 8) ? 8 : pScrn->rgbBits,
                               vASTLoadPalette, NULL,
                               CMAP_PALETTED_TRUECOLOR | CMAP_RELOAD_ON_MODE_SWITCH)) {
           return FALSE;
       }
d862 1
a862 1

d864 1
a864 9

#ifdef AstVideo
   if ( (pAST->jChipType == AST1180) || (pAST->jChipType == AST2300) || (pAST->jChipType == AST2400) )
   {
       xf86DrvMsg(pScrn->scrnIndex, X_INFO,"AST Initial Video()\n");
       ASTInitVideo(pScreen);
   }
#endif

d873 1
a873 1

d878 1
a878 1
ASTSwitchMode(SWITCH_MODE_ARGS_DECL)
d880 1
a880 1
   SCRN_INFO_PTR(arg);
a882 11
   /* VideoMode validate */
   if (mode->CrtcHDisplay > pScrn->displayWidth)
       return FALSE;
   if ((pAST->VideoModeInfo.ScreenPitch * mode->CrtcVDisplay) > pAST->ulVRAMSize)
       return FALSE;

   /* VideModeInfo Update */
   pAST->VideoModeInfo.ScreenWidth  = mode->CrtcHDisplay;
   pAST->VideoModeInfo.ScreenHeight = mode->CrtcVDisplay;
   pAST->VideoModeInfo.ScreenPitch  = pScrn->displayWidth * ((pScrn->bitsPerPixel + 1) / 8) ;

d886 2
a887 3
       pAST->pHWCPtr = NULL;
   }
   ASTDisableHWC(pScrn);
d890 1
a890 1
#ifdef Accel_2D
d893 2
a894 2
       pAST->pCMDQPtr = NULL;
   }
d897 3
a899 4

   /* Fixed display abnormal on the of the screen if run xvidtune, ycchen@@122909 */
   /* ASTRestore(pScrn); */

d905 1
a905 1
ASTAdjustFrame(ADJUST_FRAME_ARGS_DECL)
d907 1
a907 1
   SCRN_INFO_PTR(arg);
d910 3
a912 3

   base = y * pAST->VideoModeInfo.ScreenPitch + x * ((pAST->VideoModeInfo.bitsPerPixel + 1) / 8);
   /* base = base >> 2; */			/* DW unit */
d918 1
a918 1
/* enter into X Server */
d920 1
a920 1
ASTEnterVT(VT_FUNC_ARGS_DECL)
d922 1
a922 15
   SCRN_INFO_PTR(arg);
   ASTRecPtr pAST = ASTPTR(pScrn);

   /* Fixed suspend can't resume issue */
   if (!bIsVGAEnabled(pScrn))
   {
       if (pAST->jChipType == AST1180)
           bInitAST1180(pScrn);
       else
       {
           vEnableASTVGAMMIO(pScrn);
           InitVGA(pScrn, 1);
       }
       ASTRestore(pScrn);
   }
d926 2
a927 2
   ASTAdjustFrame(ADJUST_FRAME_ARGS(pScrn, pScrn->frameX0, pScrn->frameY0));

d929 1
a929 1

d934 1
a934 1
ASTLeaveVT(VT_FUNC_ARGS_DECL)
d936 3
a938 2

   SCRN_INFO_PTR(arg);
a939 3
#if	!(defined(__sparc__)) && !(defined(__mips__))
   vgaHWPtr hwp = VGAHWPTR(pScrn);
#endif
d944 2
a945 3
       pAST->pHWCPtr = NULL;
   }
   ASTDisableHWC(pScrn);
d948 1
a948 1
#ifdef Accel_2D
d951 2
a952 2
       pAST->pCMDQPtr = NULL;
   }
d955 3
a957 9

   ASTRestore(pScrn);

   if (pAST->jChipType == AST1180)
       ASTBlankScreen(pScrn, 0);

#if	!(defined(__sparc__)) && !(defined(__mips__))
   vgaHWLock(hwp);
#endif
d962 1
a962 1
ASTFreeScreen(FREE_SCREEN_ARGS_DECL)
d964 1
a964 3
   SCRN_INFO_PTR(arg);
   ASTFreeRec(pScrn);
#if	!(defined(__sparc__)) && !(defined(__mips__))
d966 1
a966 2
      vgaHWFreeHWRec(pScrn);
#endif
d969 1
d971 1
a971 1
ASTValidMode(SCRN_ARG_TYPE arg, DisplayModePtr mode, Bool verbose, int flags)
a972 5
   SCRN_INFO_PTR(arg);
   ASTRecPtr   pAST  = ASTPTR(pScrn);
   ModeStatus Flags = MODE_NOMODE;
   UCHAR jReg;
   ULONG RequestBufferSize;
d974 2
d978 1
a978 1
	 xf86DrvMsg(pScrn->scrnIndex, X_PROBED,
d986 1
a986 1
	 xf86DrvMsg(pScrn->scrnIndex, X_PROBED,
d988 2
a989 2
      }
      return Flags;
d991 1
a991 36

   /* Valid Framebuffer size */
   RequestBufferSize = mode->CrtcHDisplay * ((pScrn->bitsPerPixel + 1) / 8) * mode->CrtcVDisplay;
   if (RequestBufferSize > pAST->ulVRAMSize)
      return Flags;

   /* Valid Wide Screen Mode */
   if (pAST->SupportWideScreen)
   {
      if ( (mode->CrtcHDisplay == 1680) && (mode->CrtcVDisplay == 1050) )
          return MODE_OK;
      if ( (mode->CrtcHDisplay == 1280) && (mode->CrtcVDisplay == 800) )
          return MODE_OK;
      if ( (mode->CrtcHDisplay == 1440) && (mode->CrtcVDisplay == 900) )
          return MODE_OK;
      if ( (mode->CrtcHDisplay == 1360) && (mode->CrtcVDisplay == 768) )
          return MODE_OK;
      if ( (mode->CrtcHDisplay == 1600) && (mode->CrtcVDisplay == 900) )
          return MODE_OK;

      if ( (pAST->jChipType == AST2100) || (pAST->jChipType == AST2200) || (pAST->jChipType == AST2300) || (pAST->jChipType == AST2400) || (pAST->jChipType == AST1180) )
      {
          if ( (mode->CrtcHDisplay == 1920) && (mode->CrtcVDisplay == 1080) )
              return MODE_OK;

          if ( (mode->CrtcHDisplay == 1920) && (mode->CrtcVDisplay == 1200) )
          {
             GetIndexRegMask(CRTC_PORT, 0xD1, 0xFF, jReg);
	     if (jReg & 0x01)
	        return MODE_NOMODE;
	     else
                return MODE_OK;
          }
      }
   }

d996 1
a996 1
       break;
d999 1
a999 1
       break;
d1002 1
a1002 1
       break;
d1008 1
a1008 1
       break;
d1010 1
a1010 1
       return Flags;
d1012 4
a1016 2
   return Flags;
}
a1038 2
   ASTRecPtr pAST = ASTPTR(pScrn);

d1043 1
a1043 3
   if (pAST->pDP501FWBufferVirtualAddress)
       free(pAST->pDP501FWBufferVirtualAddress);
   free(pScrn->driverPrivate);
d1050 2
a1051 13
#if	!(defined(__sparc__)) && !(defined(__mips__))
   /* replacement of vgaHWBlankScreen(pScrn, unblank) without seq reset */
   /* return vgaHWSaveScreen(pScreen, unblack); */
   ScrnInfoPtr pScrn = NULL;

   if (pScreen != NULL)
      pScrn = xf86ScreenToScrn(pScreen);

   if ((pScrn != NULL) && pScrn->vtSema) {
     ASTBlankScreen(pScrn, unblack);
   }
   return (TRUE);
#endif
d1055 1
a1055 1
ASTCloseScreen(CLOSE_SCREEN_ARGS_DECL)
d1057 2
a1058 1
   ScrnInfoPtr pScrn = xf86ScreenToScrn(pScreen);
a1059 3
#if	!(defined(__sparc__)) && !(defined(__mips__))
   vgaHWPtr hwp = VGAHWPTR(pScrn);
#endif
d1062 1
a1062 1
   {
d1064 4
a1067 5
       if (pAST->pHWCPtr) {
           xf86FreeOffscreenLinear(pAST->pHWCPtr);		/* free HWC Cache */
           pAST->pHWCPtr = NULL;
       }
       ASTDisableHWC(pScrn);
d1069 7
a1075 16

#ifdef Accel_2D
       if (pAST->pCMDQPtr) {
           xf86FreeOffscreenLinear(pAST->pCMDQPtr);		/* free CMDQ */
           pAST->pCMDQPtr = NULL;
       }
       vDisable2D(pScrn, pAST);
#endif

       ASTRestore(pScrn);

       if (pAST->jChipType == AST1180)
           ASTBlankScreen(pScrn, 0);

#if	!(defined(__sparc__)) && !(defined(__mips__))
       vgaHWLock(hwp);
d1077 3
a1082 1
#if	!(defined(__sparc__)) && !(defined(__mips__))
a1083 1
#endif
a1084 1
#ifdef HAVE_XAA_H
d1089 1
a1089 1
#endif
a1094 8
#ifdef	Support_ShadowFB
   if (pAST->shadowFB_validation) {
      shadowRemove(pScreen, pScreen->GetScreenPixmap(pScreen));
	  free(pAST->shadow);
      pScreen->CreateScreenResources = pAST->CreateScreenResources;
   }
#endif

d1097 1
a1097 1
   return (*pScreen->CloseScreen) (CLOSE_SCREEN_ARGS);
d1104 3
a1106 3
   ASTRegPtr astReg;
   int i, icount=0;
   ULONG ulData;
d1109 1
d1111 10
a1120 69

   if (pAST->jChipType == AST1180)
   {
       for (i=0; i<12; i++)
       {
           ReadAST1180SOC(AST1180_GFX_BASE + AST1180_VGA1_CTRL+i*4, ulData);
           astReg->GFX[i] = ulData;
       }
   }
   else
   {
#if	defined(__sparc__) || defined(__mips__)
       UCHAR jReg;

       /* Save Misc */
       astReg->MISC = GetReg(MISC_PORT_READ);

       /* Save SR */
       for (i=0; i<4; i++)
           GetIndexReg(SEQ_PORT, (UCHAR) (i), astReg->SEQ[i]);

       /* Save CR */
       for (i=0; i<25; i++)
           GetIndexReg(CRTC_PORT, (UCHAR) (i), astReg->CRTC[i]);

       /* Save GR */
       for (i=0; i<9; i++)
           GetIndexReg(GR_PORT, (UCHAR) (i), astReg->GR[i]);

       /* Save AR */
       jReg = GetReg(INPUT_STATUS1_READ);
       for (i=0; i<20; i++)
           GetIndexReg(AR_PORT_WRITE, (UCHAR) (i), astReg->AR[i]);
       jReg = GetReg(INPUT_STATUS1_READ);
       SetReg (AR_PORT_WRITE, 0x20);		/* set POS */
#else
       vgaRegPtr vgaReg;
       vgaReg = &VGAHWPTR(pScrn)->SavedReg;

       /* do save */
       if (xf86IsPrimaryPci(pAST->PciInfo)) {
           vgaHWSave(pScrn, vgaReg, VGA_SR_MODE | VGA_SR_FONTS);
       }
       else {
           vgaHWSave(pScrn, vgaReg, VGA_SR_MODE);
       }
#endif

       /* Save Ext. */
       vASTOpenKey(pScrn);

       /* fixed Console Switch Refresh Rate Incorrect issue, ycchen@@051106 */
       for (i=0x81; i<=0xB6; i++)
           GetIndexReg(CRTC_PORT, (UCHAR) (i), astReg->ExtCRTC[icount++]);
       for (i=0xBC; i<=0xC1; i++)
           GetIndexReg(CRTC_PORT, (UCHAR) (i), astReg->ExtCRTC[icount++]);
       GetIndexReg(CRTC_PORT, (UCHAR) (0xBB), astReg->ExtCRTC[icount]);

       /* Save DAC */
       for (i=0; i<256; i++)
           VGA_GET_PALETTE_INDEX (i, astReg->DAC[i][0], astReg->DAC[i][1], astReg->DAC[i][2]);

       /* Save 2D */
       astReg->ENG8044 = 0;
       GetIndexReg(CRTC_PORT, 0xA4, astReg->REGA4);
       if (astReg->REGA4 & 0x01)	/* 2D enabled */
           astReg->ENG8044 = *(ULONG *) (pAST->MMIOVirtualAddr + 0x8044);
   }

d1127 3
a1129 3
   ASTRegPtr astReg;
   int i, icount=0;
   ULONG ulData;
d1132 1
d1134 12
a1145 72

   ASTDisplayPowerManagementSet(pScrn, DPMSModeOff, 0);

   if (pAST->jChipType == AST1180)
   {
       for (i=0; i<12; i++)
       {
           ulData = astReg->GFX[i];
           WriteAST1180SOC(AST1180_GFX_BASE + AST1180_VGA1_CTRL+i*4, ulData);
       }
   }
   else
   {
#if	defined(__sparc__) || defined(__mips__)
       UCHAR jReg;

       /* Restore Misc */
       SetReg(MISC_PORT_WRITE, astReg->MISC);

       /* Restore SR */
       for (i=0; i<4; i++)
           SetIndexReg(SEQ_PORT, (UCHAR) (i), astReg->SEQ[i]);

       /* Restore CR */
       SetIndexRegMask(CRTC_PORT,0x11, 0x7F, 0x00);
       for (i=0; i<25; i++)
           SetIndexReg(CRTC_PORT, (UCHAR) (i), astReg->CRTC[i]);

       /* Restore GR */
       for (i=0; i<9; i++)
           SetIndexReg(GR_PORT, (UCHAR) (i), astReg->GR[i]);

       /* Restore AR */
       jReg = GetReg(INPUT_STATUS1_READ);
       for (i=0; i<20; i++)
       {
           SetReg(AR_PORT_WRITE, (UCHAR) i);
           SetReg(AR_PORT_WRITE, astReg->AR[i]);
       }
       SetReg(AR_PORT_WRITE, 0x14);
       SetReg(AR_PORT_WRITE, 0x00);

       jReg = GetReg(INPUT_STATUS1_READ);
       SetReg (AR_PORT_WRITE, 0x20);		/* set POS */
#else
       vgaRegPtr vgaReg;
       vgaReg = &VGAHWPTR(pScrn)->SavedReg;

       /* do restore */
       vgaHWProtect(pScrn, TRUE);
       if (xf86IsPrimaryPci(pAST->PciInfo))
           vgaHWRestore(pScrn, vgaReg, VGA_SR_MODE | VGA_SR_FONTS);
       else
           vgaHWRestore(pScrn, vgaReg, VGA_SR_MODE);
       vgaHWProtect(pScrn, FALSE);
#endif

      /* Ext. restore */
      vASTOpenKey(pScrn);

       /* Restore DAC */
       for (i=0; i<256; i++)
          VGA_LOAD_PALETTE_INDEX (i, astReg->DAC[i][0], astReg->DAC[i][1], astReg->DAC[i][2]);

      /* fixed Console Switch Refresh Rate Incorrect issue, ycchen@@051106 */
      for (i=0x81; i<=0xB6; i++)
          SetIndexReg(CRTC_PORT, (UCHAR) (i), astReg->ExtCRTC[icount++]);
      for (i=0xBC; i<=0xC1; i++)
          SetIndexReg(CRTC_PORT, (UCHAR) (i), astReg->ExtCRTC[icount++]);
      SetIndexReg(CRTC_PORT, (UCHAR) (0xBB), astReg->ExtCRTC[icount]);
   }

d1151 1
a1151 16
   ASTRecPtr pAST = ASTPTR(pScrn);
   unsigned char DDC_data[128];
   Bool Flags;

   if (xf86LoadSubModule(pScrn, "ddc"))
   {
      if (pAST->jChipType == AST1180)
          Flags = GetVGA2EDID(pScrn, DDC_data);
      else if (pAST->jTxChipType == Tx_DP501)
      {
          Flags = ReadEDID_M68K(pScrn, DDC_data);
          if (Flags == FALSE)
              Flags = GetVGAEDID(pScrn, DDC_data);
      }
      else
          Flags = GetVGAEDID(pScrn, DDC_data);
d1153 4
a1156 10
      if (Flags)
      {
          ConfiguredMonitor = xf86InterpretEDID(pScrn->scrnIndex, DDC_data);
      }
      else
          xf86DrvMsg(pScrn->scrnIndex, X_INFO,"[ASTProbeDDC] Can't Get EDID Properly \n");
   }
   else
   {
      xf86DrvMsg(pScrn->scrnIndex, X_INFO,"[ASTProbeDDC] Can't Load DDC Sub-Modules or Read EDID Failed \n");
a1157 1

a1159 4
#define SkipDT	0x00
#define DT1	0x01
#define DT2 	0x02

d1163 1
a1165 8
   unsigned char DDC_data[128];
   Bool Flags;

   xf86MonPtr MonInfo1 = NULL, MonInfo2 = NULL;
   unsigned long i, j, k;
   struct monitor_ranges ranges, ranges1, ranges2;
   int DTSelect, dclock1=0, h_active1=0, v_active1=0, dclock2=0, h_active2=0, v_active2=0;
   struct std_timings stdtiming, *stdtiming1, *stdtiming2;
d1172 3
a1174 167
   if (xf86LoadSubModule(pScrn, "ddc"))
   {
      if (pAST->jChipType == AST1180)
          Flags = GetVGA2EDID(pScrn, DDC_data);
      else if (pAST->jTxChipType == Tx_DP501)
      {
	      pAST->DP501_MaxVCLK = 0xFF;
          Flags = ReadEDID_M68K(pScrn, DDC_data);
          if (Flags) pAST->DP501_MaxVCLK = GetLinkMaxCLK(pScrn);
          else
              Flags = GetVGAEDID(pScrn, DDC_data);
      }
      else
          Flags = GetVGAEDID(pScrn, DDC_data);

      if (Flags)
      {
          MonInfo = MonInfo1 = xf86InterpretEDID(pScrn->scrnIndex, DDC_data);

          /* Valid Wide Screen Support */
          if ( (MonInfo) && (MonInfo->det_mon[0].type == 0x00) )
          {
	          if ( (MonInfo->det_mon[0].section.d_timings.h_active * 10 / MonInfo->det_mon[0].section.d_timings.v_active) < 14 )
                  pAST->SupportWideScreen = FALSE;
          }
      }

      /* For VGA2 CLONE Support, ycchen@@012508 */
      if ((xf86ReturnOptValBool(pAST->Options, OPTION_VGA2_CLONE, FALSE)) || pAST->VGA2Clone) {
          if (GetVGA2EDID(pScrn, DDC_data) == TRUE) {
              xf86DrvMsg(pScrn->scrnIndex, X_INFO, "Get VGA2 EDID Correctly!! \n");
              MonInfo2 = xf86InterpretEDID(pScrn->scrnIndex, DDC_data);
              if (MonInfo1 == NULL)	/* No DDC1 EDID */
                  MonInfo = MonInfo2;
              else {			/* Check with VGA1 & VGA2 EDID */
                   /* Update establishment timing */
                   MonInfo->timings1.t1 = MonInfo1->timings1.t1 & MonInfo2->timings1.t1;
                   MonInfo->timings1.t2 = MonInfo1->timings1.t2 & MonInfo2->timings1.t2;
                   MonInfo->timings1.t_manu = MonInfo1->timings1.t_manu & MonInfo2->timings1.t_manu;

                   /* Update Std. Timing */
                   for (i=0; i<8; i++) {
                       stdtiming.hsize = stdtiming.vsize = stdtiming.refresh = stdtiming.id = 0;
                       for (j=0; j<8; j++) {
                           if ((MonInfo1->timings2[i].hsize == MonInfo2->timings2[j].hsize) && \
                               (MonInfo1->timings2[i].vsize == MonInfo2->timings2[j].vsize) && \
                               (MonInfo1->timings2[i].refresh == MonInfo2->timings2[j].refresh)) {
                                stdtiming = MonInfo1->timings2[i];
                                break;
                           }
                       }

                       MonInfo->timings2[i] = stdtiming;
                   } /* Std. Timing */

                   /* Get Detailed Timing */
                   for (i=0;i<4;i++) {
                      if (MonInfo1->det_mon[i].type == 0xFD)
                         ranges1 = MonInfo1->det_mon[i].section.ranges;
                      else if (MonInfo1->det_mon[i].type == 0xFA)
                         stdtiming1 = MonInfo1->det_mon[i].section.std_t;
                      else if (MonInfo1->det_mon[i].type == 0x00) {
                         if (MonInfo1->det_mon[i].section.d_timings.clock > dclock1)
                             dclock1 = MonInfo1->det_mon[i].section.d_timings.clock;
                         if (MonInfo1->det_mon[i].section.d_timings.h_active > h_active1)
                             h_active1 = MonInfo1->det_mon[i].section.d_timings.h_active;
                         if (MonInfo1->det_mon[i].section.d_timings.v_active > v_active1)
                             v_active1 = MonInfo1->det_mon[i].section.d_timings.v_active;
                      }
                      if (MonInfo2->det_mon[i].type == 0xFD)
                         ranges2 = MonInfo2->det_mon[i].section.ranges;
                      else if (MonInfo1->det_mon[i].type == 0xFA)
                         stdtiming2 = MonInfo2->det_mon[i].section.std_t;
                      else if (MonInfo2->det_mon[i].type == 0x00) {
                         if (MonInfo2->det_mon[i].section.d_timings.clock > dclock2)
                             dclock2 = MonInfo2->det_mon[i].section.d_timings.clock;
                         if (MonInfo2->det_mon[i].section.d_timings.h_active > h_active2)
                             h_active2 = MonInfo2->det_mon[i].section.d_timings.h_active;
                         if (MonInfo2->det_mon[i].section.d_timings.v_active > v_active2)
                             v_active2 = MonInfo2->det_mon[i].section.d_timings.v_active;
                      }
                   } /* Get Detailed Timing */

                   /* Chk Detailed Timing */
                   if ((dclock1 >= dclock2) && (h_active1 >= h_active2) && (v_active1 >= v_active2))
                       DTSelect = DT2;
                   else if ((dclock2 >= dclock1) && (h_active2 >= h_active1) && (v_active2 >= v_active1))
                       DTSelect = DT1;
                   else
                       DTSelect = SkipDT;

                   /* Chk Monitor Descriptor */
                   ranges = ranges1;
                   ranges.min_h = ranges1.min_h > ranges2.min_h ? ranges1.min_h:ranges2.min_h;
                   ranges.min_v = ranges1.min_v > ranges2.min_v ? ranges1.min_v:ranges2.min_v;
                   ranges.max_h = ranges1.max_h < ranges2.max_h ? ranges1.max_h:ranges2.max_h;
                   ranges.max_v = ranges1.max_v < ranges2.max_v ? ranges1.max_v:ranges2.max_v;
                   ranges.max_clock = ranges1.max_clock < ranges2.max_clock ? ranges1.max_clock:ranges2.max_clock;

                   /* Update Detailed Timing */
                   for (i=0; i<4; i++)
                   {
                       if (MonInfo->det_mon[i].type == 0xFD) {
                           MonInfo->det_mon[i].section.ranges = ranges;
                       }
                       else if (MonInfo->det_mon[i].type == 0xFA) {
                           for (j=0; j<5; j++) {
         	                  stdtiming.hsize = stdtiming.vsize = stdtiming.refresh = stdtiming.id = 0;
                               for (k=0; k<5; k++) {
                                   if ((stdtiming1[j].hsize == stdtiming2[k].hsize) && \
                                       (stdtiming1[j].vsize == stdtiming2[k].vsize) && \
                                       (stdtiming1[j].refresh == stdtiming2[k].refresh)) {
                                        stdtiming = stdtiming1[j];
                                        break;
                                   }
                               }
                               stdtiming1[j] = stdtiming;
                           } /* Std. Timing */
                       } /* FA */
                       else if (MonInfo->det_mon[i].type == 0x00) {
                           if (DTSelect == DT2)
                               MonInfo->det_mon[i] = MonInfo2->det_mon[i];
                           else if (DTSelect == DT1)
                               MonInfo->det_mon[i] = MonInfo1->det_mon[i];
                           else /* SkipDT */
                           {   /* use 1024x768 as default */
                               MonInfo->det_mon[i] = MonInfo1->det_mon[i];
                               MonInfo->det_mon[i].section.d_timings.clock = 65000000;
                               MonInfo->det_mon[i].section.d_timings.h_active = 1024;
                               MonInfo->det_mon[i].section.d_timings.h_blanking = 320;
                               MonInfo->det_mon[i].section.d_timings.v_active = 768;
                               MonInfo->det_mon[i].section.d_timings.v_blanking = 38;
                               MonInfo->det_mon[i].section.d_timings.h_sync_off = 24;
                               MonInfo->det_mon[i].section.d_timings.h_sync_width = 136;
                               MonInfo->det_mon[i].section.d_timings.v_sync_off = 3;
                               MonInfo->det_mon[i].section.d_timings.v_sync_width = 6;
                           }
                       } /* 00 */
                       else { /* use Monitor 1 as default */
                           MonInfo->det_mon[i] = MonInfo1->det_mon[i];
                       }

                   } /* Update Detailed Timing */

                   /* set feature size */
                   if (DTSelect == DT2)  {
                       MonInfo->features.hsize = MonInfo2->features.hsize;
                       MonInfo->features.vsize = MonInfo2->features.vsize;
                   }
                   else if (DTSelect == DT1)  {
                       MonInfo->features.hsize = MonInfo1->features.hsize;
                       MonInfo->features.vsize = MonInfo1->features.vsize;
                   }
                   else	/* Skip DT */
                   {   /* use 1024x768 as default */
                       MonInfo->features.hsize = 0x20;
                       MonInfo->features.vsize = 0x18;
                   }

               } /* Check with VGA1 & VGA2 EDID */

           } /* GetVGA2EDID */
           else {
               xf86DrvMsg(pScrn->scrnIndex, X_INFO, "Can't Get VGA2 EDID Correctly!! \n");
           }
      } /* VGA2Clone */

d1177 4
a1180 16
   }
   else
   {
      xf86DrvMsg(pScrn->scrnIndex, X_INFO,"[ASTDoDDC] Can't Load DDC Sub-Modules or Read EDID Failed \n");
   }

   /* Fill pAST Monitor Info */
   if (MonInfo == NULL)
   {	/* default for Non-EDID */
       pAST->mon_h_active = 1024;
       pAST->mon_v_active = 768;
   }
   else
   {	/* save MonInfo to Private */
       pAST->mon_h_active = MonInfo->det_mon[0].section.d_timings.h_active;
       pAST->mon_v_active = MonInfo->det_mon[0].section.d_timings.v_active;
d1190 1
a1190 1

d1192 5
a1196 6

    pAST->VideoModeInfo.ScreenWidth = pScrn->virtualX;
    pAST->VideoModeInfo.ScreenHeight = pScrn->virtualY;
    pAST->VideoModeInfo.bitsPerPixel = pScrn->bitsPerPixel;
    /* Fixed screen pitch incorrect in some specific monitor, ycchen@@071707 */
    pAST->VideoModeInfo.ScreenPitch = pScrn->displayWidth * ((pScrn->bitsPerPixel + 1) / 8) ;
d1203 1
d1206 1
a1208 11
    pScrn->vtSema = TRUE;
    pAST->ModePtr = mode;

#if	defined(__sparc__) || defined(__mips__)
    if (!ASTSetMode(pScrn, mode))
      return FALSE;
#else
    vgaHWPtr hwp;

    hwp = VGAHWPTR(pScrn);

d1219 1
a1219 1

a1220 1
#endif
a1223 566

#ifdef AstVideo
/*
 * Video Part by ic_yang
 */
#include "fourcc.h"

#define NUM_ATTRIBUTES  	8
#define NUM_IMAGES 		8
#define NUM_FORMATS     	3

#define IMAGE_MIN_WIDTH         32
#define IMAGE_MIN_HEIGHT        24
#define IMAGE_MAX_WIDTH         1920
#define IMAGE_MAX_HEIGHT        1080

#define MAKE_ATOM(a) MakeAtom(a, sizeof(a) - 1, TRUE)

static XF86ImageRec ASTImages[NUM_IMAGES] =
{
    XVIMAGE_YUY2, /* If order is changed, ASTOffscreenImages must be adapted */
};

static XF86VideoFormatRec ASTFormats[NUM_FORMATS] =
{
   { 8, PseudoColor},
   {16, TrueColor},
   {24, TrueColor}
};

/* client libraries expect an encoding */
static XF86VideoEncodingRec DummyEncoding =
{
   0,
   "XV_IMAGE",
   0, 0,                /* Will be filled in */
   {1, 1}
};

static char astxvcolorkey[] 				= "XV_COLORKEY";
static char astxvbrightness[] 				= "XV_BRIGHTNESS";
static char astxvcontrast[] 				= "XV_CONTRAST";
static char astxvsaturation[] 				= "XV_SATURATION";
static char astxvhue[] 				        = "XV_HUE";
static char astxvgammared[] 				= "XV_GAMMA_RED";
static char astxvgammagreen[] 				= "XV_GAMMA_GREEN";
static char astxvgammablue[] 				= "XV_GAMMA_BLUE";

static XF86AttributeRec ASTAttributes[NUM_ATTRIBUTES] =
{
   {XvSettable | XvGettable, 0, (1 << 24) - 1, astxvcolorkey},
   {XvSettable | XvGettable, -128, 127, astxvbrightness},
   {XvSettable | XvGettable, 0, 255, astxvcontrast},
   {XvSettable | XvGettable, -180, 180, astxvsaturation},
   {XvSettable | XvGettable, -180, 180, astxvhue},
   {XvSettable | XvGettable, 100, 10000, astxvgammared},
   {XvSettable | XvGettable, 100, 10000, astxvgammagreen},
   {XvSettable | XvGettable, 100, 10000, astxvgammablue},
};

static void ASTStopVideo(ScrnInfoPtr pScrn, pointer data, Bool exit)
{
    ASTPortPrivPtr pPriv = (ASTPortPrivPtr)data;
    ASTPtr pAST = ASTPTR(pScrn);

    REGION_EMPTY(pScrn->pScreen, &pPriv->clip);

    if(exit)
    {
        if(pPriv->fbAreaPtr)
        {
            xf86FreeOffscreenArea(pPriv->fbAreaPtr);
            pPriv->fbAreaPtr = NULL;
            pPriv->fbSize = 0;
        }
        /* clear all flag */
        pPriv->videoStatus = 0;
    }
    else
    {
#if 0
        if(pPriv->videoStatus & CLIENT_VIDEO_ON)
        {
            pPriv->videoStatus |= OFF_TIMER;

        }
#endif
    }
}

static int ASTSetPortAttribute(ScrnInfoPtr pScrn, Atom attribute, INT32 value, pointer data)
{
    ASTPortPrivPtr pPriv = (ASTPortPrivPtr)data;
    ASTPtr pAST = ASTPTR(pScrn);

    xf86DrvMsg(pScrn->scrnIndex, X_INFO,"ASTSetPortAttribute(),attribute=%x\n", attribute);

    if (attribute == pAST->xvBrightness)
    {
        if((value < -128) || (value > 127))
         return BadValue;

        pPriv->brightness = value;
    }
    else if (attribute == pAST->xvContrast)
    {
        if ((value < 0) || (value > 255))
         return BadValue;

        pPriv->contrast = value;
    }
    else if (attribute == pAST->xvSaturation)
    {
        if ((value < -180) || (value > 180))
         return BadValue;

        pPriv->saturation = value;
    }
    else if (attribute == pAST->xvHue)
    {
        if ((value < -180) || (value > 180))
         return BadValue;

        pPriv->hue = value;
    }
    else if (attribute == pAST->xvColorKey)
    {
          pPriv->colorKey = value;
          REGION_EMPTY(pScrn->pScreen, &pPriv->clip);
    }
    else if(attribute == pAST->xvGammaRed)
    {
        if((value < 100) || (value > 10000))
            return BadValue;
        pPriv->gammaR = value;
    }
    else if(attribute == pAST->xvGammaGreen)
    {
        if((value < 100) || (value > 10000))
            return BadValue;
        pPriv->gammaG = value;
    }
    else if(attribute == pAST->xvGammaBlue)
    {
        if((value < 100) || (value > 10000))
            return BadValue;
        pPriv->gammaB = value;
    }
    else
    {
        return BadMatch;
    }

    return Success;
}

static int ASTGetPortAttribute(ScrnInfoPtr pScrn, Atom attribute, INT32 *value, pointer data)
{
    ASTPortPrivPtr pPriv = (ASTPortPrivPtr)data;
    ASTPtr pAST = ASTPTR(pScrn);

    xf86DrvMsg(pScrn->scrnIndex, X_INFO,"ASTGetPortAttribute(),attribute=%x\n", attribute);

    if (attribute == pAST->xvBrightness)
    {
        *value = pPriv->brightness;
    }
    else if (attribute == pAST->xvContrast)
    {
        *value = pPriv->contrast;
    }
    else if (attribute == pAST->xvSaturation)
    {
        *value = pPriv->saturation;
    }
    else if (attribute == pAST->xvHue)
    {
        *value = pPriv->hue;
    }
    else if(attribute == pAST->xvGammaRed)
    {
        *value = pPriv->gammaR;

    }
    else if(attribute == pAST->xvGammaGreen)
    {
        *value = pPriv->gammaG;
    }
    else if(attribute == pAST->xvGammaBlue)
    {
        *value = pPriv->gammaB;
    }
    else if (attribute == pAST->xvColorKey)
    {
        *value = pPriv->colorKey;
    }
    else
        return BadMatch;

    return Success;
}

static void ASTQueryBestSize(ScrnInfoPtr pScrn, Bool motion,
                                short vid_w, short vid_h,
                                short drw_w, short drw_h,
                                unsigned int *p_w, unsigned int *p_h,
                                pointer data)
{
    *p_w = drw_w;
    *p_h = drw_h;
    xf86DrvMsg(pScrn->scrnIndex, X_INFO,"ASTQueryBestSize()\n");
  /* TODO: report the HW limitation */
}

static int ASTQueryImageAttributes(ScrnInfoPtr pScrn, int id,
                                    unsigned short *w, unsigned short *h,
                                    int *pitches, int *offsets)
{
    int pitchY, pitchUV;
    int size, sizeY, sizeUV;

    xf86DrvMsg(pScrn->scrnIndex, X_INFO,"ASTQueryImageAttributes()\n");

    if(*w < IMAGE_MIN_WIDTH) *w = IMAGE_MIN_WIDTH;
    if(*h < IMAGE_MIN_HEIGHT) *h = IMAGE_MIN_HEIGHT;

    switch(id) {
    case PIXEL_FMT_YV12:
        *w = (*w + 7) & ~7;
        *h = (*h + 1) & ~1;
        pitchY = *w;
        pitchUV = *w >> 1;
        if(pitches) {
          pitches[0] = pitchY;
          pitches[1] = pitches[2] = pitchUV;
        }
        sizeY = pitchY * (*h);
        sizeUV = pitchUV * ((*h) >> 1);
        if(offsets) {
          offsets[0] = 0;
          offsets[1] = sizeY;
          offsets[2] = sizeY + sizeUV;
        }
        size = sizeY + (sizeUV << 1);
        break;
    case PIXEL_FMT_NV12:
    case PIXEL_FMT_NV21:
        *w = (*w + 7) & ~7;
        *h = (*h + 1) & ~1;
		pitchY = *w;
    	pitchUV = *w;
    	if(pitches) {
      	    pitches[0] = pitchY;
            pitches[1] = pitchUV;
        }
    	sizeY = pitchY * (*h);
    	sizeUV = pitchUV * ((*h) >> 1);
    	if(offsets) {
          offsets[0] = 0;
          offsets[1] = sizeY;
        }
        size = sizeY + (sizeUV << 1);
        break;
    case PIXEL_FMT_YUY2:
    case PIXEL_FMT_UYVY:
    case PIXEL_FMT_YVYU:
    case PIXEL_FMT_RGB6:
    case PIXEL_FMT_RGB5:
    default:
        *w = (*w + 1) & ~1;
        pitchY = *w << 1;
        if(pitches) pitches[0] = pitchY;
        if(offsets) offsets[0] = 0;
        size = pitchY * (*h);
        break;
    }

    return size;
}

extern void ASTDisplayVideo(ScrnInfoPtr pScrn, ASTPortPrivPtr pPriv, RegionPtr clipBoxes, int id);

static int ASTPutImage(ScrnInfoPtr pScrn,
                          short src_x, short src_y,
                          short drw_x, short drw_y,
                          short src_w, short src_h,
                          short drw_w, short drw_h,
                          int id, unsigned char* buf,
                          short width, short height,
                          Bool sync,
                          RegionPtr clipBoxes, pointer data
)
{
    ASTPtr pAST = ASTPTR(pScrn);
    ASTPortPrivPtr pPriv = (ASTPortPrivPtr)data;
    int i;
    int totalSize=0;

    xf86DrvMsg(pScrn->scrnIndex, X_INFO,"ASTPutImage()\n");
    /*   int depth = pAST->CurrentLayout.bitsPerPixel >> 3; */

    pPriv->drw_x = drw_x;
    pPriv->drw_y = drw_y;
    pPriv->drw_w = drw_w;
    pPriv->drw_h = drw_h;
    pPriv->src_x = src_x;
    pPriv->src_y = src_y;
    pPriv->src_w = src_w;
    pPriv->src_h = src_h;
    pPriv->id = id;
    pPriv->height = height;

    switch(id)
    {
    case PIXEL_FMT_YV12:
    case PIXEL_FMT_NV12:
    case PIXEL_FMT_NV21:
        pPriv->srcPitch = (width + 7) & ~7;
        totalSize = (pPriv->srcPitch * height * 3) >> 1; /* Verified */
    break;
    case PIXEL_FMT_YUY2:
    case PIXEL_FMT_UYVY:
    case PIXEL_FMT_YVYU:
    case PIXEL_FMT_RGB6:
    case PIXEL_FMT_RGB5:
    default:
        pPriv->srcPitch = ((width << 1) + 3) & ~3;	/* Verified */
        totalSize = pPriv->srcPitch * height;
    }

    totalSize += 15;
    totalSize &= ~15;
    /* allocate memory */

    if(totalSize == pPriv->fbSize)
    {
        ;
    }
    else
    {
        int lines, pitch, depth;
        BoxPtr pBox = NULL;

        pPriv->fbSize = totalSize;

        if(pPriv->fbAreaPtr)
        {
             xf86FreeOffscreenArea(pPriv->fbAreaPtr);
        }

        depth = (pScrn->bitsPerPixel + 7 ) / 8;
        pitch = pScrn->displayWidth * depth;
        lines = ((totalSize * 2) / pitch) + 1;
        xf86DrvMsg(pScrn->scrnIndex, X_INFO,"ASTPutImagelines=%x, pitch=%x, displayWidth=%x\n", lines, pitch, pScrn->displayWidth);


        pPriv->fbAreaPtr = xf86AllocateOffscreenArea(pScrn->pScreen,
                                 pScrn->displayWidth,
                                lines, 0, NULL, NULL, NULL);

        if(!pPriv->fbAreaPtr)
        {
            xf86DrvMsg(pScrn->scrnIndex, X_ERROR, "Allocate video memory fails\n");
            return BadAlloc;
        }

        pBox = &(pPriv->fbAreaPtr->box);
        pPriv->bufAddr[0] = (pBox->y1 * pitch) + (pBox->x1 * depth);
        pPriv->bufAddr[1] = pPriv->bufAddr[0] + totalSize;
        xf86DrvMsg(pScrn->scrnIndex, X_INFO, "Put Image, pPriv->bufAddr[0]=0x%08X\n", pPriv->bufAddr[0]);

    }

    /* copy data */
    if(totalSize < 16)
    {
      #ifdef NewPath
        memcpy(pAST->FBVirtualAddr + pPriv->bufAddr[pPriv->currentBuf], buf, totalSize);
      #else /* NewPath */
        switch(id)
        {
        case PIXEL_FMT_YUY2:
        case PIXEL_FMT_UYVY:
        case PIXEL_FMT_YVYU:
        {
             BYTE *Base = (BYTE *)(pAST->FBVirtualAddr + pPriv->bufAddr[pPriv->currentBuf]);
             for(i=0; i<height; i++)
                  memcpy( Base + i * pPriv->srcPitch, buf + i*width*2, width*2);
             break;
        }
        default:
            memcpy(pAST->FBVirtualAddr + pPriv->bufAddr[pPriv->currentBuf], buf, totalSize);
            break;
        } /* switch */
      #endif /* NewPath */
    }
    else
    {
        xf86DrvMsg(pScrn->scrnIndex, X_INFO, "Put Image, copy buf\n");

      #ifdef NewPath
       	memcpy(pAST->FBVirtualAddr + pPriv->bufAddr[pPriv->currentBuf], buf, totalSize);
      #else     /* NewPath */
        switch(id)
        {
        case PIXEL_FMT_YUY2:
        case PIXEL_FMT_UYVY:
        case PIXEL_FMT_YVYU:
        {
            BYTE *Base = (BYTE *)(pAST->FBVirtualAddr + pPriv->bufAddr[pPriv->currentBuf]);
            for(i=0; i<height; i++)
                  memcpy( Base + i * pPriv->srcPitch, buf + i*width*2, width*2);

            /*for(i=0; i<height; i++)
                for(j=0; j<width*2; j++)
                    *(Base+i*pPriv->srcPitch+j) = *(buf + width*i + j);*/
            break;
        }
        default:
        {    BYTE *Base = (BYTE *)(pAST->FBVirtualAddr + pPriv->bufAddr[pPriv->currentBuf]);
            int j;
            for(i=0; i<height; i++)
                for(j=0; j<width; j++)
                   *(Base + width*i + j) = *(buf + width * i + j);
        break;
        }
        } /* end of switch */
      #endif    /* NewPath */
    }

    ASTDisplayVideo(pScrn, pPriv, clipBoxes, id);

    /* update cliplist
    if(!REGION_EQUAL(pScrn->pScreen, &pPriv->clip, clipBoxes))
    {
        REGION_COPY(pScrn->pScreen, &pPriv->clip, clipBoxes);
    }
    else
    {
        xf86XVFillKeyHelper(pScrn->pScreen, 0xFFFFFFFF, clipBoxes);
    }
    */
    pPriv->currentBuf ^= 1;

    return Success;
}

static XF86VideoAdaptorPtr ASTSetupImageVideo(ScreenPtr pScreen)
{
    ScrnInfoPtr pScrn = xf86ScreenToScrn(pScreen);
    ASTPtr pAST = ASTPTR(pScrn);
    XF86VideoAdaptorPtr adapt;
    ASTPortPrivPtr pPriv;


    if(!(adapt = calloc(1, sizeof(XF86VideoAdaptorRec) +
                            sizeof(DevUnion) +
                            sizeof(ASTPortPrivRec))))
        return NULL;

    adapt->type = XvWindowMask | XvInputMask | XvImageMask | XvVideoMask;
    adapt->flags = VIDEO_OVERLAID_IMAGES | VIDEO_CLIP_TO_VIEWPORT;
    adapt->name = "AST Video";

    adapt->nEncodings = 1;
    adapt->pEncodings = &DummyEncoding;

    adapt->nFormats = NUM_FORMATS;
    adapt->pFormats = ASTFormats;
    adapt->nPorts = 1;
    adapt->pPortPrivates = (DevUnion*)(&adapt[1]);

    pPriv = (ASTPortPrivPtr)(&adapt->pPortPrivates[1]);

    adapt->pPortPrivates->ptr = (pointer)(pPriv);
    adapt->pAttributes = ASTAttributes;
    adapt->nAttributes = NUM_ATTRIBUTES;
	adapt->nImages = NUM_IMAGES;
    adapt->pImages = ASTImages;

    adapt->PutVideo = NULL;

    adapt->PutStill = NULL;
    adapt->GetVideo = NULL;
    adapt->GetStill = NULL;
    adapt->StopVideo = ASTStopVideo;
    adapt->SetPortAttribute = ASTSetPortAttribute;
    adapt->GetPortAttribute = ASTGetPortAttribute;
    adapt->QueryBestSize = ASTQueryBestSize;
    adapt->PutImage = ASTPutImage;
    adapt->QueryImageAttributes = ASTQueryImageAttributes;


    pPriv->currentBuf   = 0;
    pPriv->linear       = NULL;
    pPriv->fbAreaPtr    = NULL;
    pPriv->fbSize = 0;
	pPriv->videoStatus  = 0;

    pPriv->colorKey     = 0x000101fe;
    pPriv->brightness   = 0;
    pPriv->contrast     = 128;
    pPriv->saturation   = 0;
    pPriv->hue          = 0;

    /* gotta uninit this someplace */
#if defined(REGION_NULL)
    REGION_NULL(pScreen, &pPriv->clip);
#else
    REGION_INIT(pScreen, &pPriv->clip, NullBox, 0);
#endif

	pAST->adaptor = adapt;

	pAST->xvBrightness = MAKE_ATOM(astxvbrightness);
	pAST->xvContrast   = MAKE_ATOM(astxvcontrast);
	pAST->xvColorKey   = MAKE_ATOM(astxvcolorkey);
	pAST->xvSaturation = MAKE_ATOM(astxvsaturation);
	pAST->xvHue 	   = MAKE_ATOM(astxvhue);
	pAST->xvGammaRed   = MAKE_ATOM(astxvgammared);
    pAST->xvGammaGreen = MAKE_ATOM(astxvgammagreen);
    pAST->xvGammaBlue  = MAKE_ATOM(astxvgammablue);

    return adapt;
}

void ASTInitVideo(ScreenPtr pScreen)
{
    ScrnInfoPtr pScrn = xf86ScreenToScrn(pScreen);
    XF86VideoAdaptorPtr *adaptors, *newAdaptors = NULL;
    XF86VideoAdaptorPtr ASTAdaptor = NULL;
    int num_adaptors;

    ASTAdaptor = ASTSetupImageVideo(pScreen);

    num_adaptors = xf86XVListGenericAdaptors(pScrn, &adaptors);

    if(ASTAdaptor)
    {
        if(!num_adaptors)
        {
            num_adaptors = 1;
            adaptors = &ASTAdaptor;
        }
        else
        {
            newAdaptors = malloc((num_adaptors + 1) * sizeof(XF86VideoAdaptorPtr*));
            if(newAdaptors)
            {
                memcpy(newAdaptors, adaptors, num_adaptors *
                                        sizeof(XF86VideoAdaptorPtr));
                newAdaptors[num_adaptors] = ASTAdaptor;
                adaptors = newAdaptors;
                num_adaptors++;
            }
        }
    }

    if(num_adaptors)
        xf86XVScreenInit(pScreen, adaptors, num_adaptors);

    if(newAdaptors)
        free(newAdaptors);

}
#endif /* AstVideo */
@

