head	1.9;
access;
symbols
	OPENBSD_6_1_BASE:1.9
	OPENBSD_6_0:1.9.0.6
	OPENBSD_6_0_BASE:1.9
	OPENBSD_5_9:1.9.0.4
	OPENBSD_5_9_BASE:1.9
	OPENBSD_5_8:1.9.0.2
	OPENBSD_5_8_BASE:1.9
	OPENBSD_5_7:1.8.0.4
	OPENBSD_5_7_BASE:1.8
	OPENBSD_5_6:1.8.0.2
	OPENBSD_5_6_BASE:1.8
	v0_99_9:1.1.1.2
	OPENBSD_4_8:1.5.0.6
	OPENBSD_4_8_BASE:1.5
	OPENBSD_4_7:1.5.0.2
	OPENBSD_4_7_BASE:1.5
	OPENBSD_4_6:1.4.0.2
	OPENBSD_4_6_BASE:1.4
	OPENBSD_4_5:1.2.0.2
	OPENBSD_4_5_BASE:1.2
	OPENBSD_4_4:1.1.1.1.0.6
	OPENBSD_4_4_BASE:1.1.1.1
	OPENBSD_4_3_BASE:1.1.1.1
	OPENBSD_4_3:1.1.1.1.0.4
	OPENBSD_4_2:1.1.1.1.0.2
	OPENBSD_4_2_BASE:1.1.1.1
	v0_81_0:1.1.1.1
	xorg:1.1.1;
locks; strict;
comment	@ * @;


1.9
date	2015.05.24.09.17.25;	author matthieu;	state Exp;
branches;
next	1.8;
commitid	qBZygjuSMc2gFczl;

1.8
date	2014.04.13.10.36.51;	author matthieu;	state Exp;
branches;
next	1.7;

1.7
date	2010.11.29.21.17.47;	author matthieu;	state dead;
branches;
next	1.6;

1.6
date	2010.11.25.22.03.22;	author matthieu;	state Exp;
branches;
next	1.5;

1.5
date	2009.11.22.15.33.58;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2009.05.03.16.31.23;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2009.03.07.11.16.36;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2008.08.23.21.00.47;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.26.20.00.08;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.11.26.20.00.08;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2014.04.13.10.30.12;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.9
log
@Update to xf86-video-ast 1.0.1
@
text
@/*
 * Copyright (c) 2005 ASPEED Technology Inc.
 *
 * Permission to use, copy, modify, distribute, and sell this software and its
 * documentation for any purpose is hereby granted without fee, provided that
 * the above copyright notice appear in all copies and that both that
 * copyright notice and this permission notice appear in supporting
 * documentation, and that the name of the authors not be used in
 * advertising or publicity pertaining to distribution of the software without
 * specific, written prior permission.  The authors makes no representations
 * about the suitability of this software for any purpose.  It is provided
 * "as is" without express or implied warranty.
 *
 * THE AUTHORS DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
 * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO
 * EVENT SHALL THE AUTHORS BE LIABLE FOR ANY SPECIAL, INDIRECT OR
 * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
 * DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
 * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
 * PERFORMANCE OF THIS SOFTWARE.
 */

#ifdef HAVE_CONFIG_H
#include <config.h>
#endif
#include "xf86.h"
#include "xf86_OSproc.h"
#include "xf86cmap.h"
#include "compiler.h"
#include "vgaHW.h"
#include "mipointer.h"
#include "micmap.h"

#include "fb.h"
#include "regionstr.h"
#include "xf86xv.h"
#include <X11/extensions/Xv.h>

#include "xf86Pci.h"

/* framebuffer offscreen manager */
#include "xf86fbman.h"

/* include xaa includes */
#ifdef HAVE_XAA_H
#include "xaa.h"
#include "xaarop.h"
#endif

/* H/W cursor support */
#include "xf86Cursor.h"

/* Driver specific headers */
#include "ast.h"
#include "ast_2dtool.h"

#ifdef	Accel_2D

#ifdef HAVE_XAA_H
/* ROP Translation Table */
int ASTXAACopyROP[16] =
{
   ROP_0,               /* GXclear */
   ROP_DSa,             /* GXand */
   ROP_SDna,            /* GXandReverse */
   ROP_S,               /* GXcopy */
   ROP_DSna,            /* GXandInverted */
   ROP_D,               /* GXnoop */
   ROP_DSx,             /* GXxor */
   ROP_DSo,             /* GXor */
   ROP_DSon,            /* GXnor */
   ROP_DSxn,            /* GXequiv */
   ROP_Dn,              /* GXinvert*/
   ROP_SDno,            /* GXorReverse */
   ROP_Sn,              /* GXcopyInverted */
   ROP_DSno,            /* GXorInverted */
   ROP_DSan,            /* GXnand */
   ROP_1                /* GXset */
};

int ASTXAAPatternROP[16]=
{
   ROP_0,
   ROP_DPa,
   ROP_PDna,
   ROP_P,
   ROP_DPna,
   ROP_D,
   ROP_DPx,
   ROP_DPo,
   ROP_DPon,
   ROP_PDxn,
   ROP_Dn,
   ROP_PDno,
   ROP_Pn,
   ROP_DPno,
   ROP_DPan,
   ROP_1
};

/* Prototype type declaration */
static void ASTSync(ScrnInfoPtr pScrn);
static void ASTSetupForScreenToScreenCopy(ScrnInfoPtr pScrn,
                                          int xdir, int ydir, int rop,
                                          unsigned int planemask, int trans_color);
static void ASTSubsequentScreenToScreenCopy(ScrnInfoPtr pScrn, int x1, int y1, int x2,
                                            int y2, int w, int h);
static void ASTSetupForSolidFill(ScrnInfoPtr pScrn,
                                 int color, int rop, unsigned int planemask);
static void ASTSubsequentSolidFillRect(ScrnInfoPtr pScrn,
                                       int dst_x, int dst_y, int width, int height);
static void ASTSetupForSolidLine(ScrnInfoPtr pScrn,
                                 int color, int rop, unsigned int planemask);
static void ASTSubsequentSolidHorVertLine(ScrnInfoPtr pScrn,
                                          int x, int y, int len, int dir);
static void ASTSubsequentSolidTwoPointLine(ScrnInfoPtr pScrn,
                                           int x1, int y1, int x2, int y2, int flags);
static void ASTSetupForDashedLine(ScrnInfoPtr pScrn,
                                  int fg, int bg, int rop, unsigned int planemask,
                                  int length, UCHAR *pattern);
static void ASTSubsequentDashedTwoPointLine(ScrnInfoPtr pScrn,
                                            int x1, int y1, int x2, int y2,
                                            int flags, int phase);
static void ASTSetupForMonoPatternFill(ScrnInfoPtr pScrn,
                                       int patx, int paty, int fg, int bg,
                                       int rop, unsigned int planemask);
static void ASTSubsequentMonoPatternFill(ScrnInfoPtr pScrn,
                                         int patx, int paty,
                                         int x, int y, int w, int h);
static void ASTSetupForColor8x8PatternFill(ScrnInfoPtr pScrn, int patx, int paty,
			                   int rop, unsigned int planemask, int trans_col);
static void ASTSubsequentColor8x8PatternFillRect(ScrnInfoPtr pScrn, int patx, int paty,
                                                 int x, int y, int w, int h);
static void ASTSetupForCPUToScreenColorExpandFill(ScrnInfoPtr pScrn,
                                                  int fg, int bg,
                                                  int rop, unsigned int planemask);
static void ASTSubsequentCPUToScreenColorExpandFill(ScrnInfoPtr pScrn,
                                                    int x, int y,
                                                    int width, int height, int skipleft);
static void ASTSetupForScreenToScreenColorExpandFill(ScrnInfoPtr pScrn,
                                                     int fg, int bg,
                                                     int rop, unsigned int planemask);
static void ASTSubsequentScreenToScreenColorExpandFill(ScrnInfoPtr pScrn,
                                                       int x, int y, int width, int height,
                                                       int src_x, int src_y, int offset);
static void ASTSetClippingRectangle(ScrnInfoPtr pScrn,
                                    int left, int top, int right, int bottom);
static void ASTDisableClipping(ScrnInfoPtr pScrn);
static void ASTSetHWClipping(ScrnInfoPtr pScrn, int delta_y);

static void AIPSubsequentSolidTwoPointLine(ScrnInfoPtr pScrn,
                                           int x1, int y1, int x2, int y2, int flags);
static void AIPSubsequentDashedTwoPointLine(ScrnInfoPtr pScrn,
                                            int x1, int y1, int x2, int y2,
                                            int flags, int phase);

Bool
ASTAccelInit(ScreenPtr pScreen)
{
    XAAInfoRecPtr  infoPtr;
    ScrnInfoPtr    pScrn = xf86ScreenToScrn(pScreen);
    ASTRecPtr      pAST = ASTPTR(pScrn);

    pAST->AccelInfoPtr = infoPtr = XAACreateInfoRec();
    if (!infoPtr)  return FALSE;

    infoPtr->Flags = LINEAR_FRAMEBUFFER |
  		     OFFSCREEN_PIXMAPS |
  		     PIXMAP_CACHE;

    /* Sync */
    if (pAST->ENGCaps & ENG_CAP_Sync)
        infoPtr->Sync = ASTSync;

    /* Screen To Screen copy */
    if (pAST->ENGCaps & ENG_CAP_ScreenToScreenCopy)
    {
        infoPtr->SetupForScreenToScreenCopy =  ASTSetupForScreenToScreenCopy;
        infoPtr->SubsequentScreenToScreenCopy = ASTSubsequentScreenToScreenCopy;
        infoPtr->ScreenToScreenCopyFlags = NO_TRANSPARENCY | NO_PLANEMASK;
    }

    /* Solid fill */
    if (pAST->ENGCaps & ENG_CAP_SolidFill)
    {
        infoPtr->SetupForSolidFill = ASTSetupForSolidFill;
        infoPtr->SubsequentSolidFillRect = ASTSubsequentSolidFillRect;
        infoPtr->SolidFillFlags = NO_PLANEMASK;
    }

    /* Solid Lines */
    if (pAST->ENGCaps & ENG_CAP_SolidLine)
    {
        if ( (pAST->jChipType == AST2300) || (pAST->jChipType == AST2400) || (pAST->jChipType == AST1180) )
    	{
            infoPtr->SubsequentSolidTwoPointLine = AIPSubsequentSolidTwoPointLine;
        }
        else
    	{
            infoPtr->SubsequentSolidTwoPointLine = ASTSubsequentSolidTwoPointLine;
        }

        infoPtr->SetupForSolidLine = ASTSetupForSolidLine;
        infoPtr->SubsequentSolidHorVertLine = ASTSubsequentSolidHorVertLine;
        infoPtr->SolidLineFlags = NO_PLANEMASK;
    }

    /* Dashed Lines */
    if (pAST->ENGCaps & ENG_CAP_DashedLine)
    {
        if ( (pAST->jChipType == AST2300) || (pAST->jChipType == AST2400) || (pAST->jChipType == AST1180) )
        {
            infoPtr->SubsequentDashedTwoPointLine = AIPSubsequentDashedTwoPointLine;
        }
        else
        {
            infoPtr->SubsequentDashedTwoPointLine = ASTSubsequentDashedTwoPointLine;
        }

        infoPtr->SetupForDashedLine = ASTSetupForDashedLine;
        infoPtr->DashPatternMaxLength = 64;
        infoPtr->DashedLineFlags = NO_PLANEMASK |
			           LINE_PATTERN_MSBFIRST_LSBJUSTIFIED;
    }

    /* 8x8 mono pattern fill */
    if (pAST->ENGCaps & ENG_CAP_Mono8x8PatternFill)
    {
        infoPtr->SetupForMono8x8PatternFill = ASTSetupForMonoPatternFill;
        infoPtr->SubsequentMono8x8PatternFillRect = ASTSubsequentMonoPatternFill;
        infoPtr->Mono8x8PatternFillFlags = NO_PLANEMASK |
                                           NO_TRANSPARENCY |
				           HARDWARE_PATTERN_SCREEN_ORIGIN |
				           HARDWARE_PATTERN_PROGRAMMED_BITS |
				           BIT_ORDER_IN_BYTE_MSBFIRST;
    }

    /* 8x8 color pattern fill */
    if (pAST->ENGCaps & ENG_CAP_Color8x8PatternFill)
    {
        infoPtr->SetupForColor8x8PatternFill = ASTSetupForColor8x8PatternFill;
        infoPtr->SubsequentColor8x8PatternFillRect = ASTSubsequentColor8x8PatternFillRect;
        infoPtr->Color8x8PatternFillFlags = NO_PLANEMASK |
					    NO_TRANSPARENCY |
	 				    HARDWARE_PATTERN_SCREEN_ORIGIN;
    }

    /* CPU To Screen Color Expand */
    if (pAST->ENGCaps & ENG_CAP_CPUToScreenColorExpand)
    {
        infoPtr->SetupForCPUToScreenColorExpandFill = ASTSetupForCPUToScreenColorExpandFill;
        infoPtr->SubsequentCPUToScreenColorExpandFill = ASTSubsequentCPUToScreenColorExpandFill;
        infoPtr->ColorExpandRange = MAX_PATReg_Size;
        infoPtr->ColorExpandBase = MMIOREG_PAT;
        infoPtr->CPUToScreenColorExpandFillFlags = NO_PLANEMASK |
	   				           BIT_ORDER_IN_BYTE_MSBFIRST;
    }

    /* Screen To Screen Color Expand */
    if (pAST->ENGCaps & ENG_CAP_ScreenToScreenColorExpand)
    {
        infoPtr->SetupForScreenToScreenColorExpandFill = ASTSetupForScreenToScreenColorExpandFill;
        infoPtr->SubsequentScreenToScreenColorExpandFill = ASTSubsequentScreenToScreenColorExpandFill;
        infoPtr->ScreenToScreenColorExpandFillFlags = NO_PLANEMASK |
	                                              BIT_ORDER_IN_BYTE_MSBFIRST;
    }

    /* Clipping */
    if (pAST->ENGCaps & ENG_CAP_Clipping)
    {
        infoPtr->SetClippingRectangle = ASTSetClippingRectangle;
        infoPtr->DisableClipping = ASTDisableClipping;
        infoPtr->ClippingFlags = HARDWARE_CLIP_SCREEN_TO_SCREEN_COPY 	|
                		 HARDWARE_CLIP_MONO_8x8_FILL		|
                		 HARDWARE_CLIP_COLOR_8x8_FILL	 	|
                		 HARDWARE_CLIP_SOLID_LINE 		|
                		 HARDWARE_CLIP_DASHED_LINE 		|
                		 HARDWARE_CLIP_SOLID_LINE;
    }

    return(XAAInit(pScreen, infoPtr));

} /* end of ASTAccelInit */

static void
ASTSync(ScrnInfoPtr pScrn)
{
    ASTRecPtr pAST = ASTPTR(pScrn);

    /* wait engle idle */
    vASTWaitEngIdle(pScrn, pAST);

} /* end of ASTSync */


static void ASTSetupForScreenToScreenCopy(ScrnInfoPtr pScrn,
                                          int xdir, int ydir, int rop,
                                          unsigned int planemask, int trans_color)
{

    ASTRecPtr pAST = ASTPTR(pScrn);
    PKT_SC *pSingleCMD;
    ULONG  cmdreg;

/*
    xf86DrvMsg(pScrn->scrnIndex, X_INFO, "ASTSetupForScreenToScreenCopy\n");
*/
    /* Modify Reg. Value */
    cmdreg = CMD_BITBLT;
    switch (pAST->VideoModeInfo.bitsPerPixel)
    {
    case 8:
        cmdreg |= CMD_COLOR_08;
        break;
    case 15:
    case 16:
        cmdreg |= CMD_COLOR_16;
        break;
    case 24:
    case 32:
        cmdreg |= CMD_COLOR_32;
        break;
    }
    cmdreg |= (ASTXAACopyROP[rop] << 8);
    pAST->ulCMDReg = cmdreg;

    if (!pAST->MMIO2D)
    {
        /* Write to CMDQ */
        pSingleCMD = (PKT_SC *) pASTjRequestCMDQ(pAST, PKT_SINGLE_LENGTH*2);

        ASTSetupSRCPitch(pSingleCMD, pAST->VideoModeInfo.ScreenPitch);
        pSingleCMD++;
        ASTSetupDSTPitchHeight(pSingleCMD, pAST->VideoModeInfo.ScreenPitch, -1);

        /* Update Write Pointer */
        mUpdateWritePointer;

    }
    else
    {
        /* Write to MMIO */
        ASTSetupSRCPitch_MMIO(pAST->VideoModeInfo.ScreenPitch);
        ASTSetupDSTPitchHeight_MMIO(pAST->VideoModeInfo.ScreenPitch, -1);
    }

} /* end of ASTSetupForScreenToScreenCopy */

static void
ASTSubsequentScreenToScreenCopy(ScrnInfoPtr pScrn, int x1, int y1, int x2,
                                int y2, int width, int height)
{
    ASTRecPtr pAST = ASTPTR(pScrn);
    PKT_SC *pSingleCMD;
    int src_x, src_y, dst_x, dst_y;
    ULONG srcbase, dstbase, cmdreg;
    int delta_y = 0;
/*
    xf86DrvMsg(pScrn->scrnIndex, X_INFO, "ASTSubsequentScreenToScreenCopy\n");
*/

    if ((width != 0) && (height != 0))
    {
        /* Modify Reg. Value */
        cmdreg = pAST->ulCMDReg;
        if (pAST->EnableClip)
            cmdreg |= CMD_ENABLE_CLIP;
        else
            cmdreg &= ~CMD_ENABLE_CLIP;
        srcbase = dstbase = 0;

        if (x1 < x2)
            cmdreg |= CMD_X_DEC;

        if (y1 < y2)
            cmdreg |= CMD_Y_DEC;

        if ((y1 + height) >= MAX_SRC_Y)
        {
            srcbase=pAST->VideoModeInfo.ScreenPitch*y1;
            y1 = 0;
        }

        if ((y2 + height) >= pScrn->virtualY)
        {
            delta_y = y2;
            dstbase=pAST->VideoModeInfo.ScreenPitch*y2;
            y2 = 0;
        }

        if (cmdreg & CMD_X_DEC)
        {
            src_x = x1 + width - 1;
            dst_x = x2 + width - 1;
        }
        else
        {
            src_x = x1;
            dst_x = x2;
        }

        if (cmdreg & CMD_Y_DEC)
        {
            src_y = y1 + height - 1;
            dst_y = y2 + height - 1;
        }
        else
        {
            src_y = y1;
            dst_y = y2;
        }

        if (pAST->EnableClip)
            ASTSetHWClipping(pScrn, delta_y);

        if (!pAST->MMIO2D)
        {
            /* Write to CMDQ */
            pSingleCMD = (PKT_SC *) pASTjRequestCMDQ(pAST, PKT_SINGLE_LENGTH*6);

            ASTSetupSRCBase(pSingleCMD, srcbase);
            pSingleCMD++;
            ASTSetupDSTBase(pSingleCMD, dstbase);
            pSingleCMD++;
            ASTSetupDSTXY(pSingleCMD, dst_x, dst_y);
            pSingleCMD++;
            ASTSetupSRCXY(pSingleCMD, src_x, src_y);
            pSingleCMD++;
            ASTSetupRECTXY(pSingleCMD, width, height);
            pSingleCMD++;
            ASTSetupCMDReg(pSingleCMD, cmdreg);

            /* Update Write Pointer */
            mUpdateWritePointer;

        }
        else
        {
            ASTSetupSRCBase_MMIO(srcbase);
            ASTSetupDSTBase_MMIO(dstbase);
            ASTSetupDSTXY_MMIO(dst_x, dst_y);
            ASTSetupSRCXY_MMIO(src_x, src_y);
            ASTSetupRECTXY_MMIO(width, height);
            ASTSetupCMDReg_MMIO(cmdreg);

            vASTWaitEngIdle(pScrn, pAST);
        }

    } /* width & height check */

} /* end of ASTSubsequentScreenToScreenCopy */

static void
ASTSetupForSolidFill(ScrnInfoPtr pScrn,
                     int color, int rop, unsigned int planemask)
{

    ASTRecPtr pAST = ASTPTR(pScrn);
    PKT_SC *pSingleCMD;
    ULONG cmdreg;

/*
    xf86DrvMsg(pScrn->scrnIndex, X_INFO, "ASTSetupForSolidFill\n");
*/
    /* Modify Reg. Value */
    cmdreg = CMD_BITBLT | CMD_PAT_FGCOLOR;
    switch (pAST->VideoModeInfo.bitsPerPixel)
    {
    case 8:
        cmdreg |= CMD_COLOR_08;
        break;
    case 15:
    case 16:
        cmdreg |= CMD_COLOR_16;
        break;
    case 24:
    case 32:
        cmdreg |= CMD_COLOR_32;
        break;
    }
    cmdreg |= (ASTXAAPatternROP[rop] << 8);
    pAST->ulCMDReg = cmdreg;

    if (!pAST->MMIO2D)
    {
        /* Write to CMDQ */
        pSingleCMD = (PKT_SC *) pASTjRequestCMDQ(pAST, PKT_SINGLE_LENGTH*2);

        ASTSetupDSTPitchHeight(pSingleCMD, pAST->VideoModeInfo.ScreenPitch, -1);
        pSingleCMD++;
        ASTSetupFG(pSingleCMD, color);

        /* Update Write Pointer */
        mUpdateWritePointer;

    }
    else
    {
        ASTSetupDSTPitchHeight_MMIO(pAST->VideoModeInfo.ScreenPitch, -1);
        ASTSetupFG_MMIO(color);
    }

} /* end of ASTSetupForSolidFill */


static void
ASTSubsequentSolidFillRect(ScrnInfoPtr pScrn,
                           int dst_x, int dst_y, int width, int height)
{
    ASTRecPtr pAST = ASTPTR(pScrn);
    PKT_SC *pSingleCMD;
    ULONG dstbase, cmdreg;
    int delta_y = 0;

/*
    xf86DrvMsg(pScrn->scrnIndex, X_INFO, "ASTSubsequentSolidFillRect\n");
*/

    if ((width != 0) && (height != 0))
    {
        /* Modify Reg. Value */
        cmdreg = pAST->ulCMDReg;
        if (pAST->EnableClip)
            cmdreg |= CMD_ENABLE_CLIP;
        else
            cmdreg &= ~CMD_ENABLE_CLIP;
        dstbase = 0;

        if (dst_y >= pScrn->virtualY)
        {
            delta_y = dst_y;
            dstbase=pAST->VideoModeInfo.ScreenPitch*dst_y;
            dst_y=0;
        }

        if (pAST->EnableClip)
            ASTSetHWClipping(pScrn, delta_y);

        if (!pAST->MMIO2D)
        {
            /* Write to CMDQ */
            pSingleCMD = (PKT_SC *) pASTjRequestCMDQ(pAST, PKT_SINGLE_LENGTH*4);

            ASTSetupDSTBase(pSingleCMD, dstbase);
            pSingleCMD++;
            ASTSetupDSTXY(pSingleCMD, dst_x, dst_y);
            pSingleCMD++;
            ASTSetupRECTXY(pSingleCMD, width, height);
            pSingleCMD++;
            ASTSetupCMDReg(pSingleCMD, cmdreg);

            /* Update Write Pointer */
            mUpdateWritePointer;

        }
        else
        {
            ASTSetupDSTBase_MMIO(dstbase);
            ASTSetupDSTXY_MMIO(dst_x, dst_y);
            ASTSetupRECTXY_MMIO(width, height);
            ASTSetupCMDReg_MMIO(cmdreg);

            vASTWaitEngIdle(pScrn, pAST);

        }

    } /* width & height check */


} /* end of ASTSubsequentSolidFillRect */

/* Line */
static void ASTSetupForSolidLine(ScrnInfoPtr pScrn,
                                 int color, int rop, unsigned int planemask)
{

    ASTRecPtr pAST = ASTPTR(pScrn);
    PKT_SC *pSingleCMD;
    ULONG  cmdreg;
/*
    xf86DrvMsg(pScrn->scrnIndex, X_INFO, "ASTSetupForSolidLine\n");
*/
    /* Modify Reg. Value */
    cmdreg = CMD_BITBLT;
    switch (pAST->VideoModeInfo.bitsPerPixel)
    {
    case 8:
        cmdreg |= CMD_COLOR_08;
        break;
    case 15:
    case 16:
        cmdreg |= CMD_COLOR_16;
        break;
    case 24:
    case 32:
        cmdreg |= CMD_COLOR_32;
        break;
    }
    cmdreg |= (ASTXAAPatternROP[rop] << 8);
    pAST->ulCMDReg = cmdreg;

    if (!pAST->MMIO2D)
    {
        /* Write to CMDQ */
        pSingleCMD = (PKT_SC *) pASTjRequestCMDQ(pAST, PKT_SINGLE_LENGTH*3);

        ASTSetupDSTPitchHeight(pSingleCMD, pAST->VideoModeInfo.ScreenPitch, -1);
        pSingleCMD++;
        ASTSetupFG(pSingleCMD, color);
        pSingleCMD++;
        ASTSetupBG(pSingleCMD, 0);

        /* Update Write Pointer */
        mUpdateWritePointer;

    }
    else
    {
        /* Write to MMIO */
        ASTSetupDSTPitchHeight_MMIO(pAST->VideoModeInfo.ScreenPitch, -1);
        ASTSetupFG_MMIO(color);
        ASTSetupBG_MMIO(0);
    }

} /* end of ASTSetupForSolidLine */


static void ASTSubsequentSolidHorVertLine(ScrnInfoPtr pScrn,
                                          int x, int y, int len, int dir)
{

    ASTRecPtr pAST = ASTPTR(pScrn);
    PKT_SC *pSingleCMD;
    ULONG dstbase, cmdreg;
    int width, height;
    int delta_y = 0;
/*
    xf86DrvMsg(pScrn->scrnIndex, X_INFO, "ASTSubsequentSolidHorVertLine\n");
*/

    if (len != 0)
    {
        /* Modify Reg. Value */
        cmdreg = (pAST->ulCMDReg & (~CMD_MASK)) | CMD_BITBLT;
        if (pAST->EnableClip)
            cmdreg |= CMD_ENABLE_CLIP;
        else
            cmdreg &= ~CMD_ENABLE_CLIP;
        dstbase = 0;

        if(dir == DEGREES_0) {			/* horizontal */
            width  = len;
            height = 1;
        } else {					/* vertical */
            width  = 1;
            height = len;
        }

        if ((y + height) >= pScrn->virtualY)
        {
            delta_y = y;
            dstbase=pAST->VideoModeInfo.ScreenPitch*y;
            y=0;
        }

        if (pAST->EnableClip)
            ASTSetHWClipping(pScrn, delta_y);

        if (!pAST->MMIO2D)
        {
            /* Write to CMDQ */
            pSingleCMD = (PKT_SC *) pASTjRequestCMDQ(pAST, PKT_SINGLE_LENGTH*4);

            ASTSetupDSTBase(pSingleCMD, dstbase);
            pSingleCMD++;
            ASTSetupDSTXY(pSingleCMD, x, y);
            pSingleCMD++;
            ASTSetupRECTXY(pSingleCMD, width, height);
            pSingleCMD++;
            ASTSetupCMDReg(pSingleCMD, cmdreg);

            /* Update Write Pointer */
            mUpdateWritePointer;

        }
        else
        {
            ASTSetupDSTBase_MMIO(dstbase);
            ASTSetupDSTXY_MMIO(x, y);
            ASTSetupRECTXY_MMIO(width, height);
            ASTSetupCMDReg_MMIO(cmdreg);

            vASTWaitEngIdle(pScrn, pAST);

        }

    } /* len check */

} /* end of ASTSubsequentSolidHorVertLine */

static void ASTSubsequentSolidTwoPointLine(ScrnInfoPtr pScrn,
                                           int x1, int y1, int x2, int y2, int flags)
{

    ASTRecPtr 	pAST = ASTPTR(pScrn);
    PKT_SC 	*pSingleCMD;
    LINEPARAM   dsLineParam;
    _LINEInfo   LineInfo;
    ULONG 	dstbase, ulCommand;
    ULONG	miny, maxy;
    USHORT      usXM;
    int delta_y = 0;

/*
    xf86DrvMsg(pScrn->scrnIndex, X_INFO, "ASTSubsequentSolidTwoPointLine\n");
*/

    /* Modify Reg. Value */
    ulCommand = (pAST->ulCMDReg & (~CMD_MASK)) | CMD_LINEDRAW;
    if(flags & OMIT_LAST)
        ulCommand |= CMD_NOT_DRAW_LAST_PIXEL;
    else
        ulCommand &= ~CMD_NOT_DRAW_LAST_PIXEL;
    if (pAST->EnableClip)
        ulCommand |= CMD_ENABLE_CLIP;
    else
        ulCommand &= ~CMD_ENABLE_CLIP;
    dstbase = 0;
    miny = (y1 > y2) ? y2 : y1;
    maxy = (y1 > y2) ? y1 : y2;
    if(maxy >= pScrn->virtualY) {
    	delta_y = miny;
        dstbase = pAST->VideoModeInfo.ScreenPitch * miny;
        y1 -= miny;
        y2 -= miny;
    }

    LineInfo.X1 = x1;
    LineInfo.Y1 = y1;
    LineInfo.X2 = x2;
    LineInfo.Y2 = y2;

    bASTGetLineTerm(&LineInfo, &dsLineParam);		/* Get Line Parameter */

    if (dsLineParam.dwLineAttributes & LINEPARAM_X_DEC)
        ulCommand |= CMD_X_DEC;
    if (dsLineParam.dwLineAttributes & LINEPARAM_Y_DEC)
        ulCommand |= CMD_Y_DEC;

    usXM = (dsLineParam.dwLineAttributes & LINEPARAM_XM) ? 1:0;

    if (pAST->EnableClip)
        ASTSetHWClipping(pScrn, delta_y);

    if (!pAST->MMIO2D)
    {
        /* Write to CMDQ */
        pSingleCMD = (PKT_SC *) pASTjRequestCMDQ(pAST, PKT_SINGLE_LENGTH*7);

        ASTSetupDSTBase(pSingleCMD, dstbase);
        pSingleCMD++;
        ASTSetupLineXY(pSingleCMD, dsLineParam.dsLineX, dsLineParam.dsLineY);
        pSingleCMD++;
        ASTSetupLineXMErrTerm(pSingleCMD, usXM , dsLineParam.dwErrorTerm);
        pSingleCMD++;
        ASTSetupLineWidth(pSingleCMD, dsLineParam.dsLineWidth);
        pSingleCMD++;
        ASTSetupLineK1Term(pSingleCMD, dsLineParam.dwK1Term);
        pSingleCMD++;
        ASTSetupLineK2Term(pSingleCMD, dsLineParam.dwK2Term);
        pSingleCMD++;
        ASTSetupCMDReg(pSingleCMD, ulCommand);

        /* Update Write Pointer */
        mUpdateWritePointer;

        /* Patch KDE pass abnormal point, ycchen@@052507 */
        vASTWaitEngIdle(pScrn, pAST);

    }
    else
    {
        ASTSetupDSTBase_MMIO(dstbase);
        ASTSetupLineXY_MMIO(dsLineParam.dsLineX, dsLineParam.dsLineY);
        ASTSetupLineXMErrTerm_MMIO( usXM , dsLineParam.dwErrorTerm);
        ASTSetupLineWidth_MMIO(dsLineParam.dsLineWidth);
        ASTSetupLineK1Term_MMIO(dsLineParam.dwK1Term);
        ASTSetupLineK2Term_MMIO(dsLineParam.dwK2Term);
        ASTSetupCMDReg_MMIO(ulCommand);

        vASTWaitEngIdle(pScrn, pAST);

    }


} /* end of ASTSubsequentSolidTwoPointLine */

/* Dash Line */
static void
ASTSetupForDashedLine(ScrnInfoPtr pScrn,
                      int fg, int bg, int rop, unsigned int planemask,
                      int length, UCHAR *pattern)
{

    ASTRecPtr pAST = ASTPTR(pScrn);
    PKT_SC *pSingleCMD;
    ULONG  cmdreg;
/*
    xf86DrvMsg(pScrn->scrnIndex, X_INFO, "ASTSetupForDashedLine\n");
*/
    /* Modify Reg. Value */
    cmdreg = CMD_LINEDRAW | CMD_RESET_STYLE_COUNTER | CMD_ENABLE_LINE_STYLE;

    switch (pAST->VideoModeInfo.bitsPerPixel)
    {
    case 8:
        cmdreg |= CMD_COLOR_08;
        break;
    case 15:
    case 16:
        cmdreg |= CMD_COLOR_16;
        break;
    case 24:
    case 32:
        cmdreg |= CMD_COLOR_32;
        break;
    }
    cmdreg |= (ASTXAAPatternROP[rop] << 8);
    if(bg == -1) {
        cmdreg |= CMD_TRANSPARENT;
        bg = 0;
    }
    cmdreg |= (((length-1) & 0x3F) << 24);		/* line period */
    pAST->ulCMDReg = cmdreg;

    if (!pAST->MMIO2D)
    {
        /* Write to CMDQ */
        pSingleCMD = (PKT_SC *) pASTjRequestCMDQ(pAST, PKT_SINGLE_LENGTH*5);

        ASTSetupDSTPitchHeight(pSingleCMD, pAST->VideoModeInfo.ScreenPitch, -1);
        pSingleCMD++;
        ASTSetupFG(pSingleCMD, fg);
        pSingleCMD++;
        ASTSetupBG(pSingleCMD, bg);
        pSingleCMD++;
        ASTSetupLineStyle1(pSingleCMD, *pattern);
        pSingleCMD++;
        ASTSetupLineStyle2(pSingleCMD, *(pattern+4));

        /* Update Write Pointer */
        mUpdateWritePointer;

    }
    else
    {
        /* Write to MMIO */
        ASTSetupDSTPitchHeight_MMIO(pAST->VideoModeInfo.ScreenPitch, -1);
        ASTSetupFG_MMIO(fg);
        ASTSetupBG_MMIO(bg);
        ASTSetupLineStyle1_MMIO(*pattern);
        ASTSetupLineStyle2_MMIO(*(pattern+4));

    }

}

static void
ASTSubsequentDashedTwoPointLine(ScrnInfoPtr pScrn,
                                int x1, int y1, int x2, int y2,
                                int flags, int phase)
{

    ASTRecPtr 	pAST = ASTPTR(pScrn);
    PKT_SC 	*pSingleCMD;
    LINEPARAM   dsLineParam;
    _LINEInfo   LineInfo;
    ULONG 	dstbase, ulCommand;
    ULONG	miny, maxy;
    USHORT      usXM;
    int delta_y = 0;

/*
    xf86DrvMsg(pScrn->scrnIndex, X_INFO, "ASTSubsequentDashedTwoPointLine\n");
*/

    /* Modify Reg. Value */
    ulCommand = pAST->ulCMDReg;
    if(flags & OMIT_LAST)
        ulCommand |= CMD_NOT_DRAW_LAST_PIXEL;
    else
        ulCommand &= ~CMD_NOT_DRAW_LAST_PIXEL;
    if (pAST->EnableClip)
        ulCommand |= CMD_ENABLE_CLIP;
    else
        ulCommand &= ~CMD_ENABLE_CLIP;
    dstbase = 0;
    miny = (y1 > y2) ? y2 : y1;
    maxy = (y1 > y2) ? y1 : y2;
    if(maxy >= pScrn->virtualY) {
    	delta_y = miny;
        dstbase = pAST->VideoModeInfo.ScreenPitch * miny;
        y1 -= miny;
        y2 -= miny;
    }

    LineInfo.X1 = x1;
    LineInfo.Y1 = y1;
    LineInfo.X2 = x2;
    LineInfo.Y2 = y2;

    bASTGetLineTerm(&LineInfo, &dsLineParam);		/* Get Line Parameter */

    if (dsLineParam.dwLineAttributes & LINEPARAM_X_DEC)
        ulCommand |= CMD_X_DEC;
    if (dsLineParam.dwLineAttributes & LINEPARAM_Y_DEC)
        ulCommand |= CMD_Y_DEC;

    usXM = (dsLineParam.dwLineAttributes & LINEPARAM_XM) ? 1:0;

    if (pAST->EnableClip)
        ASTSetHWClipping(pScrn, delta_y);

    if (!pAST->MMIO2D)
    {
        /* Write to CMDQ */
        pSingleCMD = (PKT_SC *) pASTjRequestCMDQ(pAST, PKT_SINGLE_LENGTH*7);

        ASTSetupDSTBase(pSingleCMD, dstbase);
        pSingleCMD++;
        ASTSetupLineXY(pSingleCMD, dsLineParam.dsLineX, dsLineParam.dsLineY);
        pSingleCMD++;
        ASTSetupLineXMErrTerm(pSingleCMD, usXM , dsLineParam.dwErrorTerm);
        pSingleCMD++;
        ASTSetupLineWidth(pSingleCMD, dsLineParam.dsLineWidth);
        pSingleCMD++;
        ASTSetupLineK1Term(pSingleCMD, dsLineParam.dwK1Term);
        pSingleCMD++;
        ASTSetupLineK2Term(pSingleCMD, dsLineParam.dwK2Term);
        pSingleCMD++;
        ASTSetupCMDReg(pSingleCMD, ulCommand);

        /* Update Write Pointer */
        mUpdateWritePointer;

        /* Patch KDE pass abnormal point, ycchen@@052507 */
        vASTWaitEngIdle(pScrn, pAST);

    }
    else
    {
        ASTSetupDSTBase_MMIO(dstbase);
        ASTSetupLineXY_MMIO(dsLineParam.dsLineX, dsLineParam.dsLineY);
        ASTSetupLineXMErrTerm_MMIO( usXM , dsLineParam.dwErrorTerm);
        ASTSetupLineWidth_MMIO(dsLineParam.dsLineWidth);
        ASTSetupLineK1Term_MMIO(dsLineParam.dwK1Term);
        ASTSetupLineK2Term_MMIO(dsLineParam.dwK2Term);
        ASTSetupCMDReg_MMIO(ulCommand);

        vASTWaitEngIdle(pScrn, pAST);

    }

}

/* Mono Pattern Fill */
static void
ASTSetupForMonoPatternFill(ScrnInfoPtr pScrn,
                           int patx, int paty, int fg, int bg,
                           int rop, unsigned int planemask)
{

    ASTRecPtr pAST = ASTPTR(pScrn);
    PKT_SC *pSingleCMD;
    ULONG cmdreg;

/*
    xf86DrvMsg(pScrn->scrnIndex, X_INFO, "ASTSetupForMonoPatternFill\n");
*/
    /* Modify Reg. Value */
    cmdreg = CMD_BITBLT | CMD_PAT_MONOMASK;
    switch (pAST->VideoModeInfo.bitsPerPixel)
    {
    case 8:
        cmdreg |= CMD_COLOR_08;
        break;
    case 15:
    case 16:
        cmdreg |= CMD_COLOR_16;
        break;
    case 24:
    case 32:
        cmdreg |= CMD_COLOR_32;
        break;
    }
    cmdreg |= (ASTXAAPatternROP[rop] << 8);
    pAST->ulCMDReg = cmdreg;

    if (!pAST->MMIO2D)
    {
        /* Write to CMDQ */
        pSingleCMD = (PKT_SC *) pASTjRequestCMDQ(pAST, PKT_SINGLE_LENGTH*5);

        ASTSetupDSTPitchHeight(pSingleCMD, pAST->VideoModeInfo.ScreenPitch, -1);
        pSingleCMD++;
        ASTSetupFG(pSingleCMD, fg);
        pSingleCMD++;
        ASTSetupBG(pSingleCMD, bg);
        pSingleCMD++;
        ASTSetupMONO1(pSingleCMD, patx);
        pSingleCMD++;
        ASTSetupMONO2(pSingleCMD, paty);

        /* Update Write Pointer */
        mUpdateWritePointer;

    }
    else
    {
        ASTSetupDSTPitchHeight_MMIO(pAST->VideoModeInfo.ScreenPitch, -1);
        ASTSetupFG_MMIO(fg);
        ASTSetupBG_MMIO(bg);
        ASTSetupMONO1_MMIO(patx);
        ASTSetupMONO2_MMIO(paty);
    }

} /* end of ASTSetupForMonoPatternFill */


static void
ASTSubsequentMonoPatternFill(ScrnInfoPtr pScrn,
                             int patx, int paty,
                             int dst_x, int dst_y, int width, int height)
{
    ASTRecPtr pAST = ASTPTR(pScrn);
    PKT_SC *pSingleCMD;
    ULONG dstbase, cmdreg;
    int delta_y = 0;

/*
    xf86DrvMsg(pScrn->scrnIndex, X_INFO, "ASTSubsequentMonoPatternFill\n");
*/

    /* Modify Reg. Value */
    cmdreg = pAST->ulCMDReg;
    if (pAST->EnableClip)
        cmdreg |= CMD_ENABLE_CLIP;
    else
        cmdreg &= ~CMD_ENABLE_CLIP;
    dstbase = 0;

    if (dst_y >= pScrn->virtualY)
    {
    	delta_y = dst_y;
        dstbase=pAST->VideoModeInfo.ScreenPitch*dst_y;
        dst_y=0;
    }

    if (pAST->EnableClip)
        ASTSetHWClipping(pScrn, delta_y);

    if (!pAST->MMIO2D)
    {
        /* Write to CMDQ */
        pSingleCMD = (PKT_SC *) pASTjRequestCMDQ(pAST, PKT_SINGLE_LENGTH*4);

        ASTSetupDSTBase(pSingleCMD, dstbase);
        pSingleCMD++;
        ASTSetupDSTXY(pSingleCMD, dst_x, dst_y);
        pSingleCMD++;
        ASTSetupRECTXY(pSingleCMD, width, height);
        pSingleCMD++;
        ASTSetupCMDReg(pSingleCMD, cmdreg);

        /* Update Write Pointer */
        mUpdateWritePointer;

    }
    else
    {
        ASTSetupDSTBase_MMIO(dstbase);
        ASTSetupDSTXY_MMIO(dst_x, dst_y);
        ASTSetupRECTXY_MMIO(width, height);
        ASTSetupCMDReg_MMIO(cmdreg);

        vASTWaitEngIdle(pScrn, pAST);
    }

} /* end of ASTSubsequentMonoPatternFill */

static void
ASTSetupForColor8x8PatternFill(ScrnInfoPtr pScrn, int patx, int paty,
			       int rop, unsigned int planemask, int trans_col)
{

    ASTRecPtr pAST = ASTPTR(pScrn);
    PKT_SC *pSingleCMD;
    ULONG cmdreg;
    CARD32 *pataddr;
    ULONG ulPatSize;
    int i, j, cpp;
/*
    xf86DrvMsg(pScrn->scrnIndex, X_INFO, "ASTSetupForColor8x8PatternFill\n");
*/
    /* Modify Reg. Value */
    cmdreg = CMD_BITBLT | CMD_PAT_PATREG;
    switch (pAST->VideoModeInfo.bitsPerPixel)
    {
    case 8:
        cmdreg |= CMD_COLOR_08;
        break;
    case 15:
    case 16:
        cmdreg |= CMD_COLOR_16;
        break;
    case 24:
    case 32:
        cmdreg |= CMD_COLOR_32;
        break;
    }
    cmdreg |= (ASTXAAPatternROP[rop] << 8);
    pAST->ulCMDReg = cmdreg;
    cpp = (pScrn->bitsPerPixel + 1) / 8;
    pataddr = (CARD32 *)(pAST->FBVirtualAddr +
                        (paty * pAST->VideoModeInfo.ScreenPitch) + (patx * cpp));
    ulPatSize = 8*8*cpp;

    if (!pAST->MMIO2D)
    {
        /* Write to CMDQ */
        pSingleCMD = (PKT_SC *) pASTjRequestCMDQ(pAST, PKT_SINGLE_LENGTH*(1 + ulPatSize/4));
        ASTSetupDSTPitchHeight(pSingleCMD, pAST->VideoModeInfo.ScreenPitch, -1);
        pSingleCMD++;
        for (i=0; i<8; i++)
        {
            for (j=0; j<8*cpp/4; j++)
            {
                ASTSetupPatReg(pSingleCMD, (i*j + j) , (*(CARD32 *) (pataddr++)));
                pSingleCMD++;
            }
        }

        /* Update Write Pointer */
        mUpdateWritePointer;

    }
    else
    {
        ASTSetupDSTPitchHeight_MMIO(pAST->VideoModeInfo.ScreenPitch, -1);
        for (i=0; i<8; i++)
        {
            for (j=0; j<8*cpp/4; j++)
            {
                ASTSetupPatReg_MMIO((i*j + j) , (*(CARD32 *) (pataddr++)));
            }
        }

    }

} /* end of ASTSetupForColor8x8PatternFill */

static void
ASTSubsequentColor8x8PatternFillRect(ScrnInfoPtr pScrn, int patx, int paty,
                                     int dst_x, int dst_y, int width, int height)
{
    ASTRecPtr pAST = ASTPTR(pScrn);
    PKT_SC *pSingleCMD;
    ULONG dstbase, cmdreg;
    int delta_y = 0;

/*
    xf86DrvMsg(pScrn->scrnIndex, X_INFO, "ASTSubsequentColor8x8PatternFillRect\n");
*/

    /* Modify Reg. Value */
    cmdreg = pAST->ulCMDReg;
    if (pAST->EnableClip)
        cmdreg |= CMD_ENABLE_CLIP;
    else
        cmdreg &= ~CMD_ENABLE_CLIP;
    dstbase = 0;

    if (dst_y >= pScrn->virtualY)
    {
    	delta_y = dst_y;
        dstbase=pAST->VideoModeInfo.ScreenPitch*dst_y;
        dst_y=0;
    }

    if (pAST->EnableClip)
        ASTSetHWClipping(pScrn, delta_y);

    if (!pAST->MMIO2D)
    {
        /* Write to CMDQ */
        pSingleCMD = (PKT_SC *) pASTjRequestCMDQ(pAST, PKT_SINGLE_LENGTH*4);

        ASTSetupDSTBase(pSingleCMD, dstbase);
        pSingleCMD++;
        ASTSetupDSTXY(pSingleCMD, dst_x, dst_y);
        pSingleCMD++;
        ASTSetupRECTXY(pSingleCMD, width, height);
        pSingleCMD++;
        ASTSetupCMDReg(pSingleCMD, cmdreg);

        /* Update Write Pointer */
        mUpdateWritePointer;

    }
    else
    {
        ASTSetupDSTBase_MMIO(dstbase);
        ASTSetupDSTXY_MMIO(dst_x, dst_y);
        ASTSetupRECTXY_MMIO(width, height);
        ASTSetupCMDReg_MMIO(cmdreg);

        vASTWaitEngIdle(pScrn, pAST);
    }

} /* ASTSubsequentColor8x8PatternFillRect */

/* CPU to Screen Expand */
static void
ASTSetupForCPUToScreenColorExpandFill(ScrnInfoPtr pScrn,
                                      int fg, int bg,
                                      int rop, unsigned int planemask)
{

    ASTRecPtr pAST = ASTPTR(pScrn);
    PKT_SC *pSingleCMD;
    ULONG cmdreg;

/*
    xf86DrvMsg(pScrn->scrnIndex, X_INFO, "ASTSetupForCPUToScreenColorExpandFill\n");
*/
    /* Modify Reg. Value */
    cmdreg = CMD_COLOREXP;
    switch (pAST->VideoModeInfo.bitsPerPixel)
    {
    case 8:
        cmdreg |= CMD_COLOR_08;
        break;
    case 15:
    case 16:
        cmdreg |= CMD_COLOR_16;
        break;
    case 24:
    case 32:
        cmdreg |= CMD_COLOR_32;
        break;
    }
    cmdreg |= (ASTXAAPatternROP[rop] << 8);
    if(bg == -1) {
        cmdreg |= CMD_FONT_TRANSPARENT;
        bg = 0;
    }
    pAST->ulCMDReg = cmdreg;

    if (!pAST->MMIO2D)
    {
        /* Write to CMDQ */
        pSingleCMD = (PKT_SC *) pASTjRequestCMDQ(pAST, PKT_SINGLE_LENGTH*3);

        ASTSetupDSTPitchHeight(pSingleCMD, pAST->VideoModeInfo.ScreenPitch, -1);
        pSingleCMD++;
        ASTSetupFG(pSingleCMD, fg);
        pSingleCMD++;
        ASTSetupBG(pSingleCMD, bg);

        /* Update Write Pointer */
        mUpdateWritePointer;

    }
    else
    {
        ASTSetupDSTPitchHeight_MMIO(pAST->VideoModeInfo.ScreenPitch, -1);
        ASTSetupFG_MMIO(fg);
        ASTSetupBG_MMIO(bg);

    }

}

static void
ASTSubsequentCPUToScreenColorExpandFill(ScrnInfoPtr pScrn,
                                        int dst_x, int dst_y,
                                        int width, int height, int offset)
{

    ASTRecPtr pAST = ASTPTR(pScrn);
    PKT_SC *pSingleCMD;
    ULONG dstbase, cmdreg;
    int delta_y = 0;

/*
    xf86DrvMsg(pScrn->scrnIndex, X_INFO, "ASTSubsequentCPUToScreenColorExpandFill\n");
*/

    /* Modify Reg. Value */
    cmdreg = pAST->ulCMDReg;
    if (pAST->EnableClip)
        cmdreg |= CMD_ENABLE_CLIP;
    else
        cmdreg &= ~CMD_ENABLE_CLIP;
    dstbase = 0;

    if (dst_y >= pScrn->virtualY)
    {
    	delta_y = dst_y;
        dstbase=pAST->VideoModeInfo.ScreenPitch*dst_y;
        dst_y=0;
    }

    if (pAST->EnableClip)
        ASTSetHWClipping(pScrn, delta_y);

    if (!pAST->MMIO2D)
    {
        /* Write to CMDQ */
        pSingleCMD = (PKT_SC *) pASTjRequestCMDQ(pAST, PKT_SINGLE_LENGTH*5);

        ASTSetupSRCPitch(pSingleCMD, ((width+7)/8));
        pSingleCMD++;
        ASTSetupDSTBase(pSingleCMD, dstbase);
        pSingleCMD++;
        ASTSetupDSTXY(pSingleCMD, dst_x, dst_y);
        pSingleCMD++;
        ASTSetupRECTXY(pSingleCMD, width, height);
        pSingleCMD++;
        ASTSetupCMDReg(pSingleCMD, cmdreg);

        /* Update Write Pointer */
        mUpdateWritePointer;

    }
    else
    {
        ASTSetupSRCPitch_MMIO((width+7)/8);
        ASTSetupDSTBase_MMIO(dstbase);
        ASTSetupDSTXY_MMIO(dst_x, dst_y);
        ASTSetupSRCXY_MMIO(0, 0);

        ASTSetupRECTXY_MMIO(width, height);
        ASTSetupCMDReg_MMIO(cmdreg);

        vASTWaitEngIdle(pScrn, pAST);

    }

}


/* Screen to Screen Color Expand */
static void
ASTSetupForScreenToScreenColorExpandFill(ScrnInfoPtr pScrn,
                                         int fg, int bg,
                                         int rop, unsigned int planemask)
{

    ASTRecPtr pAST = ASTPTR(pScrn);
    PKT_SC *pSingleCMD;
    ULONG cmdreg;

/*
    xf86DrvMsg(pScrn->scrnIndex, X_INFO, "ASTSetupForScreenToScreenColorExpandFill\n");
*/

    /* Modify Reg. Value */
    cmdreg = CMD_ENHCOLOREXP;
    switch (pAST->VideoModeInfo.bitsPerPixel)
    {
    case 8:
        cmdreg |= CMD_COLOR_08;
        break;
    case 15:
    case 16:
        cmdreg |= CMD_COLOR_16;
        break;
    case 24:
    case 32:
        cmdreg |= CMD_COLOR_32;
        break;
    }
    cmdreg |= (ASTXAAPatternROP[rop] << 8);
    if(bg == -1) {
        cmdreg |= CMD_FONT_TRANSPARENT;
        bg = 0;
    }
    pAST->ulCMDReg = cmdreg;

    if (!pAST->MMIO2D)
    {
        /* Write to CMDQ */
        pSingleCMD = (PKT_SC *) pASTjRequestCMDQ(pAST, PKT_SINGLE_LENGTH*3);

        ASTSetupDSTPitchHeight(pSingleCMD, pAST->VideoModeInfo.ScreenPitch, -1);
        pSingleCMD++;
        ASTSetupFG(pSingleCMD, fg);
        pSingleCMD++;
        ASTSetupBG(pSingleCMD, bg);

        /* Update Write Pointer */
        mUpdateWritePointer;

    }
    else
    {
        ASTSetupDSTPitchHeight_MMIO(pAST->VideoModeInfo.ScreenPitch, -1);
        ASTSetupFG_MMIO(fg);
        ASTSetupBG_MMIO(bg);

    }

}



static void
ASTSubsequentScreenToScreenColorExpandFill(ScrnInfoPtr pScrn,
                                           int dst_x, int dst_y, int width, int height,
                                           int src_x, int src_y, int offset)
{
   ASTRecPtr pAST = ASTPTR(pScrn);
    PKT_SC *pSingleCMD;
    ULONG srcbase, dstbase, cmdreg;
    USHORT srcpitch;
    int delta_y = 0;

/*
    xf86DrvMsg(pScrn->scrnIndex, X_INFO, "ASTSubsequentScreenToScreenColorExpandFill\n");
*/

    /* Modify Reg. Value */
    cmdreg = pAST->ulCMDReg;
    if (pAST->EnableClip)
        cmdreg |= CMD_ENABLE_CLIP;
    else
        cmdreg &= ~CMD_ENABLE_CLIP;
    dstbase = 0;
    if (dst_y >= pScrn->virtualY)
    {
    	delta_y = dst_y;
        dstbase=pAST->VideoModeInfo.ScreenPitch*dst_y;
        dst_y=0;
    }
    srcbase = pAST->VideoModeInfo.ScreenPitch*src_y + ((pScrn->bitsPerPixel+1)/8)*src_x;
    srcpitch = (pScrn->displayWidth+7)/8;

    if (pAST->EnableClip)
        ASTSetHWClipping(pScrn, delta_y);

    if (!pAST->MMIO2D)
    {
        /* Write to CMDQ */
        pSingleCMD = (PKT_SC *) pASTjRequestCMDQ(pAST, PKT_SINGLE_LENGTH*6);

        ASTSetupSRCBase(pSingleCMD, srcbase);
        pSingleCMD++;
        ASTSetupSRCPitch(pSingleCMD,srcpitch);
        pSingleCMD++;
        ASTSetupDSTBase(pSingleCMD, dstbase);
        pSingleCMD++;
        ASTSetupDSTXY(pSingleCMD, dst_x, dst_y);
        pSingleCMD++;
        ASTSetupRECTXY(pSingleCMD, width, height);
        pSingleCMD++;
        ASTSetupCMDReg(pSingleCMD, cmdreg);

        /* Update Write Pointer */
        mUpdateWritePointer;

    }
    else
    {
        ASTSetupSRCBase_MMIO(srcbase);
        ASTSetupSRCPitch_MMIO(srcpitch);
        ASTSetupDSTBase_MMIO(dstbase);
        ASTSetupDSTXY_MMIO(dst_x, dst_y);
        ASTSetupRECTXY_MMIO(width, height);
        ASTSetupCMDReg_MMIO(cmdreg);

        vASTWaitEngIdle(pScrn, pAST);

    }

}


/* Clipping */
static void
ASTSetHWClipping(ScrnInfoPtr pScrn, int delta_y)
{
    ASTRecPtr pAST = ASTPTR(pScrn);
    PKT_SC *pSingleCMD;

    if (!pAST->MMIO2D)
    {
        /* Write to CMDQ */
        pSingleCMD = (PKT_SC *) pASTjRequestCMDQ(pAST, PKT_SINGLE_LENGTH*2);

        ASTSetupCLIP1(pSingleCMD, pAST->clip_left, pAST->clip_top - delta_y);
        pSingleCMD++;
        ASTSetupCLIP2(pSingleCMD, pAST->clip_right + 1, pAST->clip_bottom - delta_y + 1);

        /* Update Write Pointer */
        mUpdateWritePointer;

    }
    else
    {
        ASTSetupCLIP1_MMIO(pAST->clip_left, pAST->clip_top - delta_y);
        ASTSetupCLIP2_MMIO(pAST->clip_right + 1, pAST->clip_bottom - delta_y + 1);
    }

}

static void
ASTSetClippingRectangle(ScrnInfoPtr pScrn,
                        int left, int top, int right, int bottom)
{

    ASTRecPtr pAST = ASTPTR(pScrn);
    PKT_SC *pSingleCMD;
/*
    xf86DrvMsg(pScrn->scrnIndex, X_INFO, "ASTSetClippingRectangle\n");
*/
    pAST->EnableClip = TRUE;

    pAST->clip_left   = left;
    pAST->clip_top    = top;
    pAST->clip_right  = right;
    pAST->clip_bottom = bottom;

}

static void
ASTDisableClipping(ScrnInfoPtr pScrn)
{
    ASTRecPtr pAST = ASTPTR(pScrn);
/*
    xf86DrvMsg(pScrn->scrnIndex, X_INFO, "ASTDisableClipping\n");
*/
    pAST->EnableClip = FALSE;
}

static void AIPSubsequentSolidTwoPointLine(ScrnInfoPtr pScrn,
                                           int x1, int y1, int x2, int y2, int flags)
{

    ASTRecPtr 	pAST = ASTPTR(pScrn);
    PKT_SC 	*pSingleCMD;
    ULONG 	dstbase, ulCommand;
    ULONG	miny, maxy;
/*
    xf86DrvMsg(pScrn->scrnIndex, X_INFO, "ASTSubsequentSolidTwoPointLine\n");
*/

    /* Modify Reg. Value */
    ulCommand = (pAST->ulCMDReg & (~CMD_MASK)) | CMD_LINEDRAW | CMD_NORMAL_LINE;
    if(flags & OMIT_LAST)
        ulCommand |= CMD_NOT_DRAW_LAST_PIXEL;
    else
        ulCommand &= ~CMD_NOT_DRAW_LAST_PIXEL;
    if (pAST->EnableClip)
        ulCommand |= CMD_ENABLE_CLIP;
    else
        ulCommand &= ~CMD_ENABLE_CLIP;
    dstbase = 0;
    miny = (y1 > y2) ? y2 : y1;
    maxy = (y1 > y2) ? y1 : y2;
    if(maxy >= pScrn->virtualY) {
        dstbase = pAST->VideoModeInfo.ScreenPitch * miny;
        y1 -= miny;
        y2 -= miny;
    }

    if (!pAST->MMIO2D)
    {
        /* Write to CMDQ */
        pSingleCMD = (PKT_SC *) pASTjRequestCMDQ(pAST, PKT_SINGLE_LENGTH*5);

        ASTSetupDSTBase(pSingleCMD, dstbase);
        pSingleCMD++;
        AIPSetupLineXY(pSingleCMD, x1, y1);
        pSingleCMD++;
        AIPSetupLineXY2(pSingleCMD, x2, y2);
        pSingleCMD++;
        AIPSetupLineNumber(pSingleCMD, 0);
        pSingleCMD++;
        ASTSetupCMDReg(pSingleCMD, ulCommand);

        /* Update Write Pointer */
        mUpdateWritePointer;

        /* Patch KDE pass abnormal point, ycchen@@052507 */
        vASTWaitEngIdle(pScrn, pAST);

    }
    else
    {
        ASTSetupDSTBase_MMIO(dstbase);
        AIPSetupLineXY_MMIO(x1, y1);
        AIPSetupLineXY2_MMIO(x2, y2);
        AIPSetupLineNumber_MMIO(0);
        ASTSetupCMDReg_MMIO(ulCommand);

        vASTWaitEngIdle(pScrn, pAST);

    }


} /* end of AIPSubsequentSolidTwoPointLine */

static void
AIPSubsequentDashedTwoPointLine(ScrnInfoPtr pScrn,
                                int x1, int y1, int x2, int y2,
                                int flags, int phase)
{

    ASTRecPtr 	pAST = ASTPTR(pScrn);
    PKT_SC 	*pSingleCMD;
    ULONG 	dstbase, ulCommand;
    ULONG	miny, maxy;
/*
    xf86DrvMsg(pScrn->scrnIndex, X_INFO, "ASTSubsequentDashedTwoPointLine\n");
*/

    /* Modify Reg. Value */
    ulCommand = pAST->ulCMDReg | CMD_NORMAL_LINE;
    if(flags & OMIT_LAST)
        ulCommand |= CMD_NOT_DRAW_LAST_PIXEL;
    else
        ulCommand &= ~CMD_NOT_DRAW_LAST_PIXEL;
    if (pAST->EnableClip)
        ulCommand |= CMD_ENABLE_CLIP;
    else
        ulCommand &= ~CMD_ENABLE_CLIP;
    dstbase = 0;
    miny = (y1 > y2) ? y2 : y1;
    maxy = (y1 > y2) ? y1 : y2;
    if(maxy >= pScrn->virtualY) {
        dstbase = pAST->VideoModeInfo.ScreenPitch * miny;
        y1 -= miny;
        y2 -= miny;
    }

    if (!pAST->MMIO2D)
    {
        /* Write to CMDQ */
        pSingleCMD = (PKT_SC *) pASTjRequestCMDQ(pAST, PKT_SINGLE_LENGTH*5);

        ASTSetupDSTBase(pSingleCMD, dstbase);
        pSingleCMD++;
        AIPSetupLineXY(pSingleCMD, x1, y1);
        pSingleCMD++;
        AIPSetupLineXY2(pSingleCMD, x2, y2);
        pSingleCMD++;
        AIPSetupLineNumber(pSingleCMD, 0);
        pSingleCMD++;
        ASTSetupCMDReg(pSingleCMD, ulCommand);

        /* Update Write Pointer */
        mUpdateWritePointer;

        /* Patch KDE pass abnormal point, ycchen@@052507 */
        vASTWaitEngIdle(pScrn, pAST);

    }
    else
    {
        ASTSetupDSTBase_MMIO(dstbase);
        AIPSetupLineXY_MMIO(x1, y1);
        AIPSetupLineXY2_MMIO(x2, y2);
        AIPSetupLineNumber_MMIO(0);
        ASTSetupCMDReg_MMIO(ulCommand);

        vASTWaitEngIdle(pScrn, pAST);

    }

}
#endif	/* HAVE_XAA_H */

#ifdef	AstVideo
/*
 * Video Part
 * by ic_yang
 */
#include "fourcc.h"

void ASTDisplayVideo(ScrnInfoPtr pScrn, ASTPortPrivPtr pPriv, RegionPtr clipBoxes, int id)
{
    ASTPtr              pAST = ASTPTR(pScrn);
    int                 nBoxs;
    int                 ScaleFactorH, ScaleFactorV;
    ULONG               InitScaleFactorH, InitScaleFactorV;
    BURSTSCALECMD       CopyCmd = {0};
    PBURSTSCALECMD      pCopyCmd = NULL;
    float               fScaleX = 0, fScaleY = 0;
    xRectangle          rect;
    BoxPtr              pBox = NULL;
    short               lSrcX, lSrcY;
    ULONG               dwCmd = 0;
    int                 i;

    pBox = REGION_RECTS(clipBoxes);
    nBoxs = REGION_NUM_RECTS(clipBoxes);

    xf86DrvMsg(pScrn->scrnIndex, X_ERROR, "MMIO=%x,pBox=%x, nBoxs=%x\n", pAST->MMIO2D, pBox, nBoxs);

    if(0==pPriv->drw_w || 0==pPriv->drw_h)
    {
        xf86DrvMsg(pScrn->scrnIndex, X_ERROR, "drwx=%x, drwy=%x\n", pPriv->drw_w, pPriv->drw_h);
        return;
    }

    /* calc scaling factor */
    fScaleX = (float)pPriv->src_w /(float)pPriv->drw_w;
    fScaleY = (float)pPriv->src_h /(float)pPriv->drw_h;

    if (pPriv->src_w == pPriv->drw_w)
        ScaleFactorH = 0x8000;
    else
        ScaleFactorH = (ULONG)((pPriv->src_w-1)*0x8000)/pPriv->drw_w;

    if (pPriv->src_h == pPriv->drw_h)
    {
        ScaleFactorV = 0x8000;
		dwCmd |= SCALE_EQUAL_VER; /* Setting it save the bandwidtch */
   	}
    else
   	{
        ScaleFactorV = (ULONG)((pPriv->src_h-1)*0x8000)/pPriv->drw_h;
    }

    if (pPriv->drw_w >= pPriv->src_w)
        InitScaleFactorH = 0;
    else
        InitScaleFactorH = 0x4000;

    if (pPriv->drw_h >= pPriv->src_h)
        InitScaleFactorV = 0;
    else
        InitScaleFactorV = 0x4000;

    switch(pScrn->bitsPerPixel)
    {
    case 32:
        dwCmd   = CMD_COLOR_32;
        break;
    case 16:
        dwCmd   = CMD_COLOR_16;
        break;
    case  8:
        dwCmd   = CMD_COLOR_08;
        break;
    }

    dwCmd |= CMD_TYPE_SCALE;
    if (pPriv->drw_w >= pPriv->src_w)
        dwCmd |= SCALE_SEG_NUM_1;
    else
        dwCmd |= SCALE_SEG_NUM_2;

    dwCmd |= SCALE_FORMAT_YUV2RGB;
    switch(id)
    {
    case PIXEL_FMT_YUY2:
        dwCmd |= YUV_FORMAT_YUYV;
        break;
    case PIXEL_FMT_UYVY:
        dwCmd |= YUV_FORMAT_UYVY;
        break;
    default:
        xf86DrvMsg(pScrn->scrnIndex, X_ERROR, "Other pix format:%x\n", id);
        break;
    }

    for(i = 0; i < nBoxs; i++, pBox++)
    {
        rect.x = pBox->x1 - pPriv->drw_x;
        rect.y = pBox->y1 - pPriv->drw_y;
        rect.width = pBox->x2 - pBox->x1;
        rect.height = pBox->y2 - pBox->y1;

        lSrcX = (ULONG)((float)rect.x * fScaleX + pPriv->src_x + 0.5f);
        lSrcY = (ULONG)((float)rect.y * fScaleY + pPriv->src_y + 0.5f);

        pCopyCmd = (BURSTSCALECMD*)pASTjRequestCMDQ(pAST, PKT_TYPESCALE_LENGTH);

        xf86DrvMsg(pScrn->scrnIndex, X_INFO, "pCopyCmd=%p, pBox=%x,%x,%x,%x\n", pCopyCmd, pBox->x1, pBox->y1, pBox->x2, pBox->y2);

        CopyCmd.dwHeader0        = (ULONG)  PKT_BURST_CMD_HEADER0 |
                                             PKT_TYPESCALE_DATALENGTH |
                                             PKT_TYPESCALE_ADDRSTART  |
                                             BURST_FORCE_CMD;

        xf86DrvMsg(pScrn->scrnIndex, X_INFO, "CopyCmd.dwHeader0=%x\n", CopyCmd.dwHeader0);

        CopyCmd.dwSrcPitch       = (ULONG)(pPriv->srcPitch << 16);

        CopyCmd.dwDstHeightPitch = (ULONG)  ((pAST->VideoModeInfo.ScreenPitch << 16) | 0xFFFF);

        CopyCmd.dwDstXY          = (ULONG) ((pBox->x1 << 16) | (pBox->y1 & 0xFFFF));
        CopyCmd.dwSrcXY          = (ULONG) ((lSrcX << 16) | (lSrcY & 0xFFFF));
        CopyCmd.dwRecHeightWidth = (ULONG) ((rect.width << 16) | rect.height);

        CopyCmd.dwInitScaleFactorH = InitScaleFactorH;
        CopyCmd.dwInitScaleFactorV = InitScaleFactorV;
        CopyCmd.dwScaleFactorH   = ScaleFactorH;
        CopyCmd.dwScaleFactorV   = ScaleFactorV;

        CopyCmd.dwSrcBaseAddr = pPriv->bufAddr[pPriv->currentBuf];
        CopyCmd.dwDstBaseAddr = 0;
        CopyCmd.dwCmd = dwCmd;
        CopyCmd.NullData[0] = 0;    /* for alignment */
        memcpy(pCopyCmd, &CopyCmd, sizeof(CopyCmd));

        mUpdateWritePointer;

#if 0
        xf86DrvMsg(pScrn->scrnIndex, X_INFO, "%08x, %08x, %08x, %08x\n",
                        *(ULONG *)(pAST->MMIOVirtualAddr+0x8000),
                        *(ULONG *)(pAST->MMIOVirtualAddr+0x8004),
                        *(ULONG *)(pAST->MMIOVirtualAddr+0x8008),
                        *(ULONG *)(pAST->MMIOVirtualAddr+0x800C));
        xf86DrvMsg(pScrn->scrnIndex, X_INFO, "%08x, %08x, %08x, %08x\n",
                        *(ULONG *)(pAST->MMIOVirtualAddr+0x8010),
                        *(ULONG *)(pAST->MMIOVirtualAddr+0x8014),
                        *(ULONG *)(pAST->MMIOVirtualAddr+0x8018),
                        *(ULONG *)(pAST->MMIOVirtualAddr+0x801C));
        xf86DrvMsg(pScrn->scrnIndex, X_INFO, "%08x, %08x, %08x, %08x\n",
                        *(ULONG *)(pAST->MMIOVirtualAddr+0x8020),
                        *(ULONG *)(pAST->MMIOVirtualAddr+0x8024),
                        *(ULONG *)(pAST->MMIOVirtualAddr+0x8028),
                        *(ULONG *)(pAST->MMIOVirtualAddr+0x802C));
        xf86DrvMsg(pScrn->scrnIndex, X_INFO, "%08x, %08x, %08x, %08x\n",
                        *(ULONG *)(pAST->MMIOVirtualAddr+0x8030),
                        *(ULONG *)(pAST->MMIOVirtualAddr+0x8034),
                        *(ULONG *)(pAST->MMIOVirtualAddr+0x8038),
                        *(ULONG *)(pAST->MMIOVirtualAddr+0x803C));
#endif

    } /* End of for-loop */

} /* ASTDisplayVideo */
#endif	/* AstVideo */

#endif	/* end of Accel_2D */
@


1.8
log
@Re-add ast files that previous re-import failed to re-add
@
text
@a38 1
#include "xf86PciInfo.h"
d55 1
a100 5
/* extern function */
extern void vWaitEngIdle(ScrnInfoPtr pScrn, ASTRecPtr pAST);
extern UCHAR *pjRequestCMDQ(ASTRecPtr pAST, ULONG ulDataLen);
extern Bool bGetLineTerm(_LINEInfo *LineInfo, LINEPARAM *dsLineParam);

a101 1
Bool ASTAccelInit(ScreenPtr pScreen);
d291 1
a291 1
    vWaitEngIdle(pScrn, pAST);
d330 1
a330 1
        pSingleCMD = (PKT_SC *) pjRequestCMDQ(pAST, PKT_SINGLE_LENGTH*2);
d419 1
a419 1
            pSingleCMD = (PKT_SC *) pjRequestCMDQ(pAST, PKT_SINGLE_LENGTH*6);
d446 1
a446 1
            vWaitEngIdle(pScrn, pAST);
d487 1
a487 1
        pSingleCMD = (PKT_SC *) pjRequestCMDQ(pAST, PKT_SINGLE_LENGTH*2);
d542 1
a542 1
            pSingleCMD = (PKT_SC *) pjRequestCMDQ(pAST, PKT_SINGLE_LENGTH*4);
d563 1
a563 1
            vWaitEngIdle(pScrn, pAST);
d605 1
a605 1
        pSingleCMD = (PKT_SC *) pjRequestCMDQ(pAST, PKT_SINGLE_LENGTH*3);
d672 1
a672 1
            pSingleCMD = (PKT_SC *) pjRequestCMDQ(pAST, PKT_SINGLE_LENGTH*4);
d693 1
a693 1
            vWaitEngIdle(pScrn, pAST);
d743 1
a743 1
    bGetLineTerm(&LineInfo, &dsLineParam);		/* Get Line Parameter */
d758 1
a758 1
        pSingleCMD = (PKT_SC *) pjRequestCMDQ(pAST, PKT_SINGLE_LENGTH*7);
d778 1
a778 1
        vWaitEngIdle(pScrn, pAST);
d791 1
a791 1
        vWaitEngIdle(pScrn, pAST);
d839 1
a839 1
        pSingleCMD = (PKT_SC *) pjRequestCMDQ(pAST, PKT_SINGLE_LENGTH*5);
d912 1
a912 1
    bGetLineTerm(&LineInfo, &dsLineParam);		/* Get Line Parameter */
d927 1
a927 1
        pSingleCMD = (PKT_SC *) pjRequestCMDQ(pAST, PKT_SINGLE_LENGTH*7);
d947 1
a947 1
        vWaitEngIdle(pScrn, pAST);
d960 1
a960 1
        vWaitEngIdle(pScrn, pAST);
d1002 1
a1002 1
        pSingleCMD = (PKT_SC *) pjRequestCMDQ(pAST, PKT_SINGLE_LENGTH*5);
d1065 1
a1065 1
        pSingleCMD = (PKT_SC *) pjRequestCMDQ(pAST, PKT_SINGLE_LENGTH*4);
d1086 1
a1086 1
        vWaitEngIdle(pScrn, pAST);
d1131 1
a1131 1
        pSingleCMD = (PKT_SC *) pjRequestCMDQ(pAST, PKT_SINGLE_LENGTH*(1 + ulPatSize/4));
d1196 1
a1196 1
        pSingleCMD = (PKT_SC *) pjRequestCMDQ(pAST, PKT_SINGLE_LENGTH*4);
d1217 1
a1217 1
        vWaitEngIdle(pScrn, pAST);
d1262 1
a1262 1
        pSingleCMD = (PKT_SC *) pjRequestCMDQ(pAST, PKT_SINGLE_LENGTH*3);
d1320 1
a1320 1
        pSingleCMD = (PKT_SC *) pjRequestCMDQ(pAST, PKT_SINGLE_LENGTH*5);
d1346 1
a1346 1
        vWaitEngIdle(pScrn, pAST);
d1394 1
a1394 1
        pSingleCMD = (PKT_SC *) pjRequestCMDQ(pAST, PKT_SINGLE_LENGTH*3);
d1455 1
a1455 1
        pSingleCMD = (PKT_SC *) pjRequestCMDQ(pAST, PKT_SINGLE_LENGTH*6);
d1482 1
a1482 1
        vWaitEngIdle(pScrn, pAST);
d1499 1
a1499 1
        pSingleCMD = (PKT_SC *) pjRequestCMDQ(pAST, PKT_SINGLE_LENGTH*2);
d1580 1
a1580 1
        pSingleCMD = (PKT_SC *) pjRequestCMDQ(pAST, PKT_SINGLE_LENGTH*5);
d1596 1
a1596 1
        vWaitEngIdle(pScrn, pAST);
d1607 1
a1607 1
        vWaitEngIdle(pScrn, pAST);
d1650 1
a1650 1
        pSingleCMD = (PKT_SC *) pjRequestCMDQ(pAST, PKT_SINGLE_LENGTH*5);
d1666 1
a1666 1
        vWaitEngIdle(pScrn, pAST);
d1677 1
a1677 1
        vWaitEngIdle(pScrn, pAST);
d1789 1
a1789 1
        pCopyCmd = (BURSTSCALECMD*)pjRequestCMDQ(pAST, PKT_TYPESCALE_LENGTH);
@


1.7
log
@Remove a bunch of video drivers that were never built on OpenBSD and
are unlikely to be ported in the future. no objection from miod@@ krw@@.
@
text
@a29 1
#include "mibstore.h"
a37 1
#include "vbe.h"
d46 1
d49 1
d58 2
d109 1
a109 1
static void ASTSetupForScreenToScreenCopy(ScrnInfoPtr pScrn, 
d113 1
a113 1
                                            int y2, int w, int h);                                
d117 1
a117 1
                                       int dst_x, int dst_y, int width, int height);  
d123 1
a123 1
                                           int x1, int y1, int x2, int y2, int flags);                                       
d129 1
a129 1
                                            int flags, int phase);                                              
d154 1
a154 1
static void ASTDisableClipping(ScrnInfoPtr pScrn); 
d158 1
a158 1
                                           int x1, int y1, int x2, int y2, int flags);                                       
d167 1
a167 1
    ScrnInfoPtr    pScrn = xf86Screens[pScreen->myNum];
d183 1
a183 1
    {    
d191 1
a191 1
    {    
d195 2
a196 2
    } 
        
d199 2
a200 2
    {    
        if (pAST->jChipType == AST2300)
d209 2
a210 2
        infoPtr->SetupForSolidLine = ASTSetupForSolidLine;            
        infoPtr->SubsequentSolidHorVertLine = ASTSubsequentSolidHorVertLine;    
d217 1
a217 1
        if (pAST->jChipType == AST2300)
d224 1
a224 1
        }        
d226 1
a226 1
        infoPtr->SetupForDashedLine = ASTSetupForDashedLine;        
d230 1
a230 1
    }			           			           
d234 1
a234 1
    {    
d242 2
a243 2
    }				           
				           
d246 1
a246 1
    {    
d250 1
a250 1
					    NO_TRANSPARENCY |    
d252 2
a253 2
    }	 				    
	 				
d256 1
a256 1
    {    
d263 1
a263 1
    }	   				           
d267 1
a267 1
    {    
d272 2
a273 2
    }	                                              
                                              
d276 1
a276 1
    {    
d282 4
a285 4
                		 HARDWARE_CLIP_SOLID_LINE 		| 
                		 HARDWARE_CLIP_DASHED_LINE 		| 
                		 HARDWARE_CLIP_SOLID_LINE; 
    }                		 
d288 1
a288 1
    
a290 1

d306 1
a306 1
	
d310 1
a310 1
    
d313 1
a313 1
*/    
d324 1
a324 1
        break;    
d328 1
a328 1
        break;    	
d332 1
a332 1
     
d334 1
a334 1
    {   
d337 2
a338 2
                
        ASTSetupSRCPitch(pSingleCMD, pAST->VideoModeInfo.ScreenPitch);  
d341 1
a341 1
        
d344 1
a344 1
        
d348 3
a350 3
        /* Write to MMIO */                
        ASTSetupSRCPitch_MMIO(pAST->VideoModeInfo.ScreenPitch);  
        ASTSetupDSTPitchHeight_MMIO(pAST->VideoModeInfo.ScreenPitch, -1);    
d352 1
a352 1
                             
d369 1
a369 1
    {    	
d375 1
a375 1
            cmdreg &= ~CMD_ENABLE_CLIP;        
d379 1
a379 1
            cmdreg |= CMD_X_DEC;     	
d382 2
a383 2
            cmdreg |= CMD_Y_DEC;     	
    
d385 1
a385 1
        {       
d388 4
a391 4
        }       
        
        if ((y2 + height) >= pScrn->virtualY) 
        {  
d396 1
a396 1
              
d405 1
a405 1
            dst_x = x2;	
d407 1
a407 1
     
d409 1
a409 1
        {        	
d416 1
a416 1
            dst_y = y2;	
d418 2
a419 2
        
        if (pAST->EnableClip)                    
d421 2
a422 2
            
        if (!pAST->MMIO2D)        
d426 1
a426 1
          
d428 1
a428 1
            pSingleCMD++;       
d430 9
a438 9
            pSingleCMD++;    
            ASTSetupDSTXY(pSingleCMD, dst_x, dst_y);    
            pSingleCMD++;    
            ASTSetupSRCXY(pSingleCMD, src_x, src_y);    
            pSingleCMD++;    
            ASTSetupRECTXY(pSingleCMD, width, height);    
            pSingleCMD++;    
            ASTSetupCMDReg(pSingleCMD, cmdreg);       
                                      
d441 1
a441 1
        
d447 5
a451 5
            ASTSetupDSTXY_MMIO(dst_x, dst_y);    
            ASTSetupSRCXY_MMIO(src_x, src_y);    
            ASTSetupRECTXY_MMIO(width, height);    
            ASTSetupCMDReg_MMIO(cmdreg);       
                	
d454 1
a454 1
        
d463 1
a463 1
	
d468 1
a468 1
/*            
d470 1
a470 1
*/            
d481 1
a481 1
        break;    
d485 1
a485 1
        break;    	
d489 2
a490 2
            
    if (!pAST->MMIO2D)                    
d498 1
a498 1
        
d501 1
a501 1
                
d506 1
a506 1
        ASTSetupFG_MMIO(color);            	
d508 1
a508 1
           
d518 1
a518 1
    ULONG dstbase, cmdreg; 
d520 2
a521 2
           
/*            
d532 1
a532 1
            cmdreg &= ~CMD_ENABLE_CLIP;            
d534 2
a535 2
        
        if (dst_y >= pScrn->virtualY) 
d537 1
a537 1
            delta_y = dst_y;	   
d542 1
a542 1
        if (pAST->EnableClip)                    
d544 4
a547 4
                                  
        if (!pAST->MMIO2D)                    
        {                  
            /* Write to CMDQ */    
d549 1
a549 1
        
d551 1
a551 1
            pSingleCMD++;    
d553 1
a553 1
            pSingleCMD++;    
d555 3
a557 3
            pSingleCMD++;    
            ASTSetupCMDReg(pSingleCMD, cmdreg);        
          
d560 1
a560 1
                    
d563 1
a563 1
        {                  
d567 2
a568 2
            ASTSetupCMDReg_MMIO(cmdreg);        
        
d570 1
a570 1
          
d572 1
a572 1
        
d579 1
a579 1
static void ASTSetupForSolidLine(ScrnInfoPtr pScrn, 
d588 1
a588 1
*/  
d599 1
a599 1
        break;    
d603 1
a603 1
        break;    	
d605 1
a605 1
    cmdreg |= (ASTXAAPatternROP[rop] << 8);  
d607 1
a607 1
     
d609 1
a609 1
    {   
d615 1
a615 1
        ASTSetupFG(pSingleCMD, color);  
d618 1
a618 1
        
d620 2
a621 2
        mUpdateWritePointer;        
        
d625 4
a628 4
        /* Write to MMIO */   
        ASTSetupDSTPitchHeight_MMIO(pAST->VideoModeInfo.ScreenPitch, -1);                     
        ASTSetupFG_MMIO(color);  
        ASTSetupBG_MMIO(0);            
d630 1
a630 1
                                 
d640 1
a640 1
    ULONG dstbase, cmdreg;   
d643 1
a643 1
/*                    
d654 1
a654 1
            cmdreg &= ~CMD_ENABLE_CLIP;            
d656 1
a656 1
        
d659 1
a659 1
            height = 1;	
d662 1
a662 1
            height = len;	    	
d664 4
a667 4
                  
        if ((y + height) >= pScrn->virtualY) 
        { 
            delta_y = y;	  
d671 2
a672 2
                  
        if (pAST->EnableClip)                    
d674 4
a677 4
                                          
        if (!pAST->MMIO2D)                    
        {                  
            /* Write to CMDQ */    
d679 1
a679 1
        
d681 1
a681 1
            pSingleCMD++;    
d683 1
a683 1
            pSingleCMD++;    
d685 3
a687 3
            pSingleCMD++;    
            ASTSetupCMDReg(pSingleCMD, cmdreg);        
          
d690 1
a690 1
                   
d693 1
a693 1
        {                  
d697 2
a698 2
            ASTSetupCMDReg_MMIO(cmdreg);        
        
d700 1
a700 1
          
d702 1
a702 1
        
d704 1
a704 1
            
d710 1
a710 1
 
d714 1
a714 1
    _LINEInfo   LineInfo; 
d716 1
a716 1
    ULONG	miny, maxy;         
d719 1
a719 1
    
d722 1
a722 1
*/    
d733 1
a733 1
        ulCommand &= ~CMD_ENABLE_CLIP;        
d743 1
a743 1
       
d748 1
a748 1
          
a749 7
    
    if (dsLineParam.dwLineAttributes & LINEPARAM_X_DEC) 
        ulCommand |= CMD_X_DEC; 
    if (dsLineParam.dwLineAttributes & LINEPARAM_Y_DEC) 
        ulCommand |= CMD_Y_DEC;             
        
    usXM = (dsLineParam.dwLineAttributes & LINEPARAM_XM) ? 1:0;    
d751 8
a758 1
    if (pAST->EnableClip)                    
d760 4
a763 4
       
    if (!pAST->MMIO2D)                    
    {                  
        /* Write to CMDQ */    
d767 1
a767 1
        pSingleCMD++;    
d769 1
a769 1
        pSingleCMD++;    
d771 1
a771 1
        pSingleCMD++; 
d773 1
a773 1
        pSingleCMD++; 
d775 1
a775 1
        pSingleCMD++; 
d777 3
a779 3
        pSingleCMD++;                     
        ASTSetupCMDReg(pSingleCMD, ulCommand);        
              
d781 1
a781 1
        mUpdateWritePointer;                
d785 1
a785 1
        
d788 1
a788 1
    {                  
d795 2
a796 2
        ASTSetupCMDReg_MMIO(ulCommand);        
             
d798 1
a798 1
      
d801 1
a801 1
                
d816 1
a816 1
*/  
d819 1
a819 1
    
d828 1
a828 1
        break;    
d832 1
a832 1
        break;    	
d834 1
a834 1
    cmdreg |= (ASTXAAPatternROP[rop] << 8);  
d836 1
a836 1
        cmdreg |= CMD_TRANSPARENT;    
d841 1
a841 1
     
d843 1
a843 1
    {   
d849 1
a849 1
        ASTSetupFG(pSingleCMD, fg);  
d851 1
a851 1
        ASTSetupBG(pSingleCMD, bg); 
d856 1
a856 1
        
d858 2
a859 2
        mUpdateWritePointer;                           
                       
d863 1
a863 1
        /* Write to MMIO */   
d865 2
a866 2
        ASTSetupFG_MMIO(fg);  
        ASTSetupBG_MMIO(bg); 
d868 1
a868 1
        ASTSetupLineStyle2_MMIO(*(pattern+4));                
d871 1
a871 1
                                 	
d879 1
a879 1
 
d883 3
a885 3
    _LINEInfo   LineInfo; 
    ULONG 	dstbase, ulCommand; 
    ULONG	miny, maxy;  
d888 1
a888 1
    
d891 1
a891 1
*/   
d902 2
a903 2
        ulCommand &= ~CMD_ENABLE_CLIP;        
    dstbase = 0;        
d912 1
a912 1
   
d917 1
a917 1
               
a918 7
    
    if (dsLineParam.dwLineAttributes & LINEPARAM_X_DEC) 
        ulCommand |= CMD_X_DEC; 
    if (dsLineParam.dwLineAttributes & LINEPARAM_Y_DEC) 
        ulCommand |= CMD_Y_DEC;             
        
    usXM = (dsLineParam.dwLineAttributes & LINEPARAM_XM) ? 1:0;    
d920 8
a927 1
    if (pAST->EnableClip)                    
d929 4
a932 4
       
    if (!pAST->MMIO2D)                    
    {                  
        /* Write to CMDQ */    
d936 1
a936 1
        pSingleCMD++;    
d938 1
a938 1
        pSingleCMD++;    
d940 1
a940 1
        pSingleCMD++; 
d942 1
a942 1
        pSingleCMD++; 
d944 1
a944 1
        pSingleCMD++; 
d946 3
a948 3
        pSingleCMD++;                     
        ASTSetupCMDReg(pSingleCMD, ulCommand);         
              
d954 1
a954 1
              
d957 1
a957 1
    {                  
d964 2
a965 2
        ASTSetupCMDReg_MMIO(ulCommand);        
       
d967 1
a967 1
      
d969 1
a969 1
                	
d978 1
a978 1
	
d983 1
a983 1
/*            
d985 1
a985 1
*/            
d996 1
a996 1
        break;    
d1000 1
a1000 1
        break;    	
d1004 2
a1005 2
            
    if (!pAST->MMIO2D)                    
d1012 1
a1012 1
        ASTSetupFG(pSingleCMD, fg);  
d1016 1
a1016 1
        ASTSetupMONO1(pSingleCMD, patx);  
d1019 1
a1019 1
        
d1022 1
a1022 1
                                           
d1027 1
a1027 1
        ASTSetupFG_MMIO(fg);   
d1029 2
a1030 2
        ASTSetupMONO1_MMIO(patx);  
        ASTSetupMONO2_MMIO(paty);                     	
d1032 1
a1032 1
           	
d1035 1
a1035 1
                      
d1045 2
a1046 2
            
/*            
d1048 2
a1049 2
*/    
            
d1055 1
a1055 1
        cmdreg &= ~CMD_ENABLE_CLIP;            
d1058 2
a1059 2
    if (dst_y >= pScrn->virtualY) 
    {   
d1065 1
a1065 1
    if (pAST->EnableClip)                    
d1067 4
a1070 4
                         
    if (!pAST->MMIO2D)                    
    {                  
        /* Write to CMDQ */    
d1074 1
a1074 1
        pSingleCMD++;    
d1076 1
a1076 1
        pSingleCMD++;    
d1078 3
a1080 3
        pSingleCMD++;    
        ASTSetupCMDReg(pSingleCMD, cmdreg);        
      
d1083 1
a1083 1
              
d1086 1
a1086 1
    {                  
d1090 4
a1093 4
        ASTSetupCMDReg_MMIO(cmdreg);        
 
        vWaitEngIdle(pScrn, pAST);      
    }	
d1101 1
a1101 1
	
d1108 1
a1108 1
/*            
d1110 1
a1110 1
*/            
d1121 1
a1121 1
        break;    
d1125 1
a1125 1
        break;    	
d1131 1
a1131 1
                        (paty * pAST->VideoModeInfo.ScreenWidth) + (patx * cpp));   
d1133 2
a1134 2
                
    if (!pAST->MMIO2D)                    
d1136 1
a1136 1
        /* Write to CMDQ */        
d1145 2
a1146 2
                pSingleCMD++;                	
            }	
d1148 1
a1148 1
        
d1151 1
a1151 1
                        
d1154 1
a1154 1
    {    	
d1161 3
a1163 3
            }	
        }                
             	
d1167 1
a1167 1
		       
d1176 2
a1177 2
            
/*            
d1180 1
a1180 1
            
d1186 1
a1186 1
        cmdreg &= ~CMD_ENABLE_CLIP;            
d1189 2
a1190 2
    if (dst_y >= pScrn->virtualY) 
    {   
d1196 1
a1196 1
    if (pAST->EnableClip)                    
d1198 4
a1201 4
                  
    if (!pAST->MMIO2D)                    
    {                  
        /* Write to CMDQ */    
d1205 1
a1205 1
        pSingleCMD++;    
d1207 1
a1207 1
        pSingleCMD++;    
d1209 3
a1211 3
        pSingleCMD++;    
        ASTSetupCMDReg(pSingleCMD, cmdreg);        
      
d1214 1
a1214 1
                
d1217 1
a1217 1
    {                  
d1221 5
a1225 5
        ASTSetupCMDReg_MMIO(cmdreg);        
 
        vWaitEngIdle(pScrn, pAST);      
    }	
	
d1239 1
a1239 1
/*            
d1241 1
a1241 1
*/           
d1252 1
a1252 1
        break;    
d1256 1
a1256 1
        break;    	
d1260 1
a1260 1
        cmdreg |= CMD_FONT_TRANSPARENT;    
d1262 1
a1262 1
    }    
d1264 2
a1265 2
            
    if (!pAST->MMIO2D)                    
d1272 1
a1272 1
        ASTSetupFG(pSingleCMD, fg);  
d1274 1
a1274 1
        ASTSetupBG(pSingleCMD, bg); 
d1278 1
a1278 1
       
d1283 3
a1285 3
        ASTSetupFG_MMIO(fg); 
        ASTSetupBG_MMIO(bg); 
                   	
d1287 1
a1287 1
           	
d1289 1
a1289 1
                               
d1301 1
a1301 1
/*           
d1304 1
a1304 1
            
d1310 1
a1310 1
        cmdreg &= ~CMD_ENABLE_CLIP;            
d1313 2
a1314 2
    if (dst_y >= pScrn->virtualY) 
    {   
d1320 1
a1320 1
    if (pAST->EnableClip)                    
d1322 4
a1325 4
                                    
    if (!pAST->MMIO2D)                    
    {                  
        /* Write to CMDQ */    
d1328 2
a1329 2
        ASTSetupSRCPitch(pSingleCMD, ((width+7)/8));  
        pSingleCMD++;    
d1331 1
a1331 1
        pSingleCMD++;    
d1333 1
a1333 1
        pSingleCMD++;    
d1335 3
a1337 3
        pSingleCMD++;    
        ASTSetupCMDReg(pSingleCMD, cmdreg);        
      
d1340 1
a1340 1
               
d1343 2
a1344 2
    {  
        ASTSetupSRCPitch_MMIO((width+7)/8);      	                
d1348 1
a1348 1
        
d1350 2
a1351 2
        ASTSetupCMDReg_MMIO(cmdreg);        
 
d1353 1
a1353 1
      
d1355 1
a1355 1
    	
d1370 1
a1370 1
/*            
d1373 1
a1373 1
           
d1384 1
a1384 1
        break;    
d1388 1
a1388 1
        break;    	
d1392 1
a1392 1
        cmdreg |= CMD_FONT_TRANSPARENT;    
d1394 1
a1394 1
    }    
d1396 2
a1397 2
            
    if (!pAST->MMIO2D)                    
d1404 1
a1404 1
        ASTSetupFG(pSingleCMD, fg);  
d1406 1
a1406 1
        ASTSetupBG(pSingleCMD, bg); 
d1410 1
a1410 1
       
d1415 3
a1417 3
        ASTSetupFG_MMIO(fg); 
        ASTSetupBG_MMIO(bg); 
                   	
d1419 1
a1419 1
           	
d1435 1
a1435 1
/*           
d1438 1
a1438 1
            
d1444 1
a1444 1
        cmdreg &= ~CMD_ENABLE_CLIP;            
d1446 2
a1447 2
    if (dst_y >= pScrn->virtualY) 
    {   
d1452 1
a1452 1
    srcbase = pAST->VideoModeInfo.ScreenPitch*src_y + ((pScrn->bitsPerPixel+1)/8)*src_x;            
d1455 1
a1455 1
    if (pAST->EnableClip)                    
d1457 4
a1460 4
    
    if (!pAST->MMIO2D)                    
    {                  
        /* Write to CMDQ */    
d1464 3
a1466 3
        pSingleCMD++;  
        ASTSetupSRCPitch(pSingleCMD,srcpitch);  
        pSingleCMD++;    
d1468 1
a1468 1
        pSingleCMD++;    
d1470 1
a1470 1
        pSingleCMD++;    
d1472 3
a1474 3
        pSingleCMD++;    
        ASTSetupCMDReg(pSingleCMD, cmdreg);        
      
d1477 1
a1477 1
       
d1480 3
a1482 3
    { 
        ASTSetupSRCBase_MMIO(srcbase);    	 
        ASTSetupSRCPitch_MMIO(srcpitch);      	                
d1486 2
a1487 2
        ASTSetupCMDReg_MMIO(cmdreg);        
 
d1489 1
a1489 1
      
d1491 1
a1491 1
		
d1494 1
a1494 1
	  
d1502 1
a1502 1
    if (!pAST->MMIO2D)                    
d1510 1
a1510 1
        
d1513 1
a1513 1
                         
d1518 1
a1518 1
        ASTSetupCLIP2_MMIO(pAST->clip_right + 1, pAST->clip_bottom - delta_y + 1);                   	
d1520 2
a1521 2
	
}	
d1527 1
a1527 1
	
d1530 1
a1530 1
/*            
d1532 1
a1532 1
*/            
d1534 1
a1534 1
            
d1539 1
a1539 1
    
d1546 1
a1546 1
/*    
d1548 1
a1548 1
*/    
d1555 1
a1555 1
 
d1559 1
a1559 1
    ULONG	miny, maxy;         
d1562 1
a1562 1
*/    
d1573 1
a1573 1
        ulCommand &= ~CMD_ENABLE_CLIP;        
d1583 3
a1585 3
    if (!pAST->MMIO2D)                    
    {                  
        /* Write to CMDQ */    
d1589 1
a1589 1
        pSingleCMD++;    
d1595 3
a1597 3
        pSingleCMD++;                     
        ASTSetupCMDReg(pSingleCMD, ulCommand);        
              
d1599 1
a1599 1
        mUpdateWritePointer;                
d1603 1
a1603 1
        
d1606 1
a1606 1
    {                  
d1611 2
a1612 2
        ASTSetupCMDReg_MMIO(ulCommand);        
             
d1614 1
a1614 1
      
d1617 1
a1617 1
                
d1625 1
a1625 1
 
d1628 2
a1629 2
    ULONG 	dstbase, ulCommand; 
    ULONG	miny, maxy;  
d1632 1
a1632 1
*/   
d1643 2
a1644 2
        ulCommand &= ~CMD_ENABLE_CLIP;        
    dstbase = 0;        
d1653 3
a1655 3
    if (!pAST->MMIO2D)                    
    {                  
        /* Write to CMDQ */    
d1659 1
a1659 1
        pSingleCMD++;    
d1665 3
a1667 3
        pSingleCMD++;                     
        ASTSetupCMDReg(pSingleCMD, ulCommand);        
              
d1673 1
a1673 1
              
d1676 1
a1676 1
    {                  
d1682 1
a1682 1
       
d1684 1
a1684 1
      
d1686 1
a1686 1
                	
d1688 166
@


1.6
log
@Update to xf86-video-ast 0.91.10
@
text
@@


1.5
log
@Update to xf86-video-ast 0.89.9
@
text
@d155 6
d198 10
a207 1
        infoPtr->SetupForSolidLine = ASTSetupForSolidLine;
a208 1
        infoPtr->SubsequentSolidTwoPointLine = ASTSubsequentSolidTwoPointLine;
d214 11
a224 3
    {        
        infoPtr->SetupForDashedLine = ASTSetupForDashedLine;
        infoPtr->SubsequentDashedTwoPointLine = ASTSubsequentDashedTwoPointLine;
d1549 137
@


1.4
log
@update to xf86-video-ast 0.89.0
@
text
@a27 2
#include "xf86Resources.h"
#include "xf86RAC.h"
d153 1
d340 1
d368 2
a369 1
        {   
d395 3
d495 3
a497 1
    ULONG dstbase, cmdreg;        
d513 2
a514 1
        {   
d518 4
a521 1
                      
d619 1
d643 2
a644 1
        {   
d649 3
a651 1
        
d695 2
d715 1
d734 3
d864 2
d884 1
d903 3
d1020 3
a1022 1
    ULONG dstbase, cmdreg;        
d1037 1
d1041 4
a1044 1
                  
d1151 3
a1153 1
    ULONG dstbase, cmdreg;        
d1168 1
d1172 3
d1276 1
d1292 1
d1296 4
a1299 1
                  
d1410 1
d1425 1
d1431 3
d1474 1
a1474 2
ASTSetClippingRectangle(ScrnInfoPtr pScrn,
                        int left, int top, int right, int bottom)
a1475 1
	
d1478 1
a1478 5
/*            
    xf86DrvMsg(pScrn->scrnIndex, X_INFO, "ASTSetClippingRectangle\n");
*/            
    pAST->EnableClip = TRUE;
            
d1484 1
a1484 1
        ASTSetupCLIP1(pSingleCMD, left, top);
d1486 1
a1486 1
        ASTSetupCLIP2(pSingleCMD, right, bottom);
d1494 2
a1495 2
        ASTSetupCLIP1_MMIO(left, top);
        ASTSetupCLIP2_MMIO(right, bottom);                   	
d1497 19
@


1.3
log
@update to xf86-video-ast 0.88.8
@
text
@d354 6
d361 1
a361 1
        if (y1 >= MAX_SRC_Y)
d364 1
d367 1
a367 1
        if (y2 >= pScrn->virtualY) 
d370 1
d373 1
a373 1
        if (x1 < x2)
d375 2
a376 3
        	src_x = x1 + width - 1;
        	dst_x = x2 + width - 1;
        	cmdreg |= CMD_X_DEC;     	
d384 2
a385 5
        if (y1 < y2)
        {
            if (srcbase) y1 = 0;
            if (dstbase) y2 = 0;
        	
a387 1
            cmdreg |= CMD_Y_DEC;     	
a390 3
            if (srcbase) y1 = 0;
            if (dstbase) y2 = 0;
        	
@


1.2
log
@xf86-video-ast 0.85.0
@
text
@d319 4
a343 8
        
    /* Modify Reg. Value */
    cmdreg = pAST->ulCMDReg;
    if (pAST->EnableClip)
        cmdreg |= CMD_ENABLE_CLIP;
    else
        cmdreg &= ~CMD_ENABLE_CLIP;            
    srcbase = dstbase = 0;
d345 9
a353 5
    if (y1 >= MAX_SRC_Y)
    {       
        srcbase=pAST->VideoModeInfo.ScreenPitch*y1;
        y1=0;
    }       
d355 44
a398 5
    if (y2 >= pScrn->virtualY) 
    {   
        dstbase=pAST->VideoModeInfo.ScreenPitch*y2;
        y2=0;
    }
d400 27
a426 23
    if (x1 < x2)
    {
    	src_x = x1 + width - 1;
    	dst_x = x2 + width - 1;
    	cmdreg |= CMD_X_DEC;     	
    }
    else
    {
        src_x = x1;
        dst_x = x2;	
    }
 
    if (y1 < y2)
    {
    	src_y = y1 + height - 1;
    	dst_y = y2 + height - 1;
    	cmdreg |= CMD_Y_DEC;     	
    }
    else
    {
        src_y = y1;
        dst_y = y2;	
    }
d428 1
a428 32
    if (!pAST->MMIO2D)        
    {
        /* Write to CMDQ */
        pSingleCMD = (PKT_SC *) pjRequestCMDQ(pAST, PKT_SINGLE_LENGTH*6);
      
        ASTSetupSRCBase(pSingleCMD, srcbase);
        pSingleCMD++;       
        ASTSetupDSTBase(pSingleCMD, dstbase);
        pSingleCMD++;    
        ASTSetupDSTXY(pSingleCMD, dst_x, dst_y);    
        pSingleCMD++;    
        ASTSetupSRCXY(pSingleCMD, src_x, src_y);    
        pSingleCMD++;    
        ASTSetupRECTXY(pSingleCMD, width, height);    
        pSingleCMD++;    
        ASTSetupCMDReg(pSingleCMD, cmdreg);       
                                  
        /* Update Write Pointer */
        mUpdateWritePointer;
    
    }
    else
    {
        ASTSetupSRCBase_MMIO(srcbase);
        ASTSetupDSTBase_MMIO(dstbase);
        ASTSetupDSTXY_MMIO(dst_x, dst_y);    
        ASTSetupSRCXY_MMIO(src_x, src_y);    
        ASTSetupRECTXY_MMIO(width, height);    
        ASTSetupCMDReg_MMIO(cmdreg);       
            	
        vWaitEngIdle(pScrn, pAST);
    }
d470 5
a474 1
        ASTSetupFG(pSingleCMD, color);        
d496 45
a540 41
    /* Modify Reg. Value */
    cmdreg = pAST->ulCMDReg;
    if (pAST->EnableClip)
        cmdreg |= CMD_ENABLE_CLIP;
    else
        cmdreg &= ~CMD_ENABLE_CLIP;               
    dstbase = 0;

    if (dst_y >= pScrn->virtualY) 
    {   
        dstbase=pAST->VideoModeInfo.ScreenPitch*dst_y;
        dst_y=0;
    }
                  
    if (!pAST->MMIO2D)                    
    {                  
        /* Write to CMDQ */    
        pSingleCMD = (PKT_SC *) pjRequestCMDQ(pAST, PKT_SINGLE_LENGTH*4);

        ASTSetupDSTBase(pSingleCMD, dstbase);
        pSingleCMD++;    
        ASTSetupDSTXY(pSingleCMD, dst_x, dst_y);
        pSingleCMD++;    
        ASTSetupRECTXY(pSingleCMD, width, height);
        pSingleCMD++;    
        ASTSetupCMDReg(pSingleCMD, cmdreg);        
      
        /* Update Write Pointer */
        mUpdateWritePointer;
                
    }
    else
    {                  
        ASTSetupDSTBase_MMIO(dstbase);
        ASTSetupDSTXY_MMIO(dst_x, dst_y);
        ASTSetupRECTXY_MMIO(width, height);
        ASTSetupCMDReg_MMIO(cmdreg);        
 
        vWaitEngIdle(pScrn, pAST);
      
    }
d586 3
a611 51
            
    /* Modify Reg. Value */
    cmdreg = (pAST->ulCMDReg & (~CMD_MASK)) | CMD_BITBLT;
    if (pAST->EnableClip)
        cmdreg |= CMD_ENABLE_CLIP;
    else
        cmdreg &= ~CMD_ENABLE_CLIP;            
    dstbase = 0;
    
    if(dir == DEGREES_0) {			/* horizontal */
        width  = len;
        height = 1;	
    } else {					/* vertical */
        width  = 1;
        height = len;	    	
    }
              
    if ((y + height) >= pScrn->virtualY) 
    {   
        dstbase=pAST->VideoModeInfo.ScreenPitch*y;
        y=0;
    }
              
    
    if (!pAST->MMIO2D)                    
    {                  
        /* Write to CMDQ */    
        pSingleCMD = (PKT_SC *) pjRequestCMDQ(pAST, PKT_SINGLE_LENGTH*4);

        ASTSetupDSTBase(pSingleCMD, dstbase);
        pSingleCMD++;    
        ASTSetupDSTXY(pSingleCMD, x, y);
        pSingleCMD++;    
        ASTSetupRECTXY(pSingleCMD, width, height);
        pSingleCMD++;    
        ASTSetupCMDReg(pSingleCMD, cmdreg);        
      
        /* Update Write Pointer */
        mUpdateWritePointer;
               
    }
    else
    {                  
        ASTSetupDSTBase_MMIO(dstbase);
        ASTSetupDSTXY_MMIO(x, y);
        ASTSetupRECTXY_MMIO(width, height);
        ASTSetupCMDReg_MMIO(cmdreg);        
 
        vWaitEngIdle(pScrn, pAST);
      
    }
d613 54
d703 1
a703 1
     
d812 4
a815 1
        ASTSetupLineStyle2(pSingleCMD, *(pattern+4));                   
d857 1
a857 1
        ulCommand &= ~CMD_ENABLE_CLIP;          
d866 1
a866 1
    
d905 1
a905 1
               
d969 5
a973 1
        ASTSetupMONO2(pSingleCMD, paty);                           
d1004 1
a1004 1
        cmdreg &= ~CMD_ENABLE_CLIP;              
d1092 5
a1096 1
        }                
d1129 1
a1129 1
        cmdreg &= ~CMD_ENABLE_CLIP;              
d1214 3
d1248 1
a1248 1
        cmdreg &= ~CMD_ENABLE_CLIP;              
d1341 3
d1444 5
a1448 1
        ASTSetupCLIP2(pSingleCMD, right, bottom);                 
a1467 1
                                         
@


1.1
log
@Initial revision
@
text
@a258 1
                		 HARDWARE_CLIP_SOLID_FILL		|     
d340 1
a340 1

d345 2
d483 3
a485 1
        cmdreg |= CMD_ENABLE_CLIP;    
d593 3
a595 1
        cmdreg |= CMD_ENABLE_CLIP;    
d667 2
d677 1
a677 1
    
d713 3
d827 2
d837 1
a837 1

d873 4
a876 1
              
d969 3
a971 1
        cmdreg |= CMD_ENABLE_CLIP;    
d1090 3
a1092 1
        cmdreg |= CMD_ENABLE_CLIP;    
d1206 3
a1208 1
        cmdreg |= CMD_ENABLE_CLIP;    
d1332 3
a1334 1
        cmdreg |= CMD_ENABLE_CLIP;    
@


1.1.1.1
log
@Importing xf86-video-ast 0.81.0
@
text
@@


1.1.1.2
log
@Re-import xf86-video-ast.
This chipset is found in HP Proliant MicroServer remote access cards
among others. ok kettenis, seems like a good idea to jasper@@.
@
text
@d28 2
d32 1
d41 1
a49 1
#ifdef HAVE_XAA_H
a51 1
#endif
a59 2

#ifdef HAVE_XAA_H
d109 1
a109 1
static void ASTSetupForScreenToScreenCopy(ScrnInfoPtr pScrn,
d113 1
a113 1
                                            int y2, int w, int h);
d117 1
a117 1
                                       int dst_x, int dst_y, int width, int height);
d123 1
a123 1
                                           int x1, int y1, int x2, int y2, int flags);
d129 1
a129 1
                                            int flags, int phase);
d154 1
a154 8
static void ASTDisableClipping(ScrnInfoPtr pScrn);
static void ASTSetHWClipping(ScrnInfoPtr pScrn, int delta_y);

static void AIPSubsequentSolidTwoPointLine(ScrnInfoPtr pScrn,
                                           int x1, int y1, int x2, int y2, int flags);
static void AIPSubsequentDashedTwoPointLine(ScrnInfoPtr pScrn,
                                            int x1, int y1, int x2, int y2,
                                            int flags, int phase);
d160 1
a160 1
    ScrnInfoPtr    pScrn = xf86ScreenToScrn(pScreen);
d176 1
a176 1
    {
d184 1
a184 1
    {
d188 2
a189 2
    }

d192 1
a192 10
    {
        if ( (pAST->jChipType == AST2300) || (pAST->jChipType == AST2400) || (pAST->jChipType == AST1180) )
    	{
            infoPtr->SubsequentSolidTwoPointLine = AIPSubsequentSolidTwoPointLine;
        }
        else
    	{
            infoPtr->SubsequentSolidTwoPointLine = ASTSubsequentSolidTwoPointLine;
        }

d194 2
a195 1
        infoPtr->SubsequentSolidHorVertLine = ASTSubsequentSolidHorVertLine;
d201 1
a201 10
    {
        if ( (pAST->jChipType == AST2300) || (pAST->jChipType == AST2400) || (pAST->jChipType == AST1180) )
        {
            infoPtr->SubsequentDashedTwoPointLine = AIPSubsequentDashedTwoPointLine;
        }
        else
        {
            infoPtr->SubsequentDashedTwoPointLine = ASTSubsequentDashedTwoPointLine;
        }

d203 1
d207 1
a207 1
    }
d211 1
a211 1
    {
d219 2
a220 2
    }

d223 1
a223 1
    {
d227 1
a227 1
					    NO_TRANSPARENCY |
d229 2
a230 2
    }

d233 1
a233 1
    {
d240 1
a240 1
    }
d244 1
a244 1
    {
d249 2
a250 2
    }

d253 1
a253 1
    {
d259 5
a263 4
                		 HARDWARE_CLIP_SOLID_LINE 		|
                		 HARDWARE_CLIP_DASHED_LINE 		|
                		 HARDWARE_CLIP_SOLID_LINE;
    }
d266 2
a268 1
} /* end of ASTAccelInit */
d285 1
a285 1

d289 1
a289 1

d292 1
a292 1
*/
d303 1
a303 1
        break;
d307 1
a307 1
        break;
d311 1
a311 1

d313 1
a313 1
    {
d316 2
a317 2

        ASTSetupSRCPitch(pSingleCMD, pAST->VideoModeInfo.ScreenPitch);
a319 4

        /* Update Write Pointer */
        mUpdateWritePointer;

d323 3
a325 3
        /* Write to MMIO */
        ASTSetupSRCPitch_MMIO(pAST->VideoModeInfo.ScreenPitch);
        ASTSetupDSTPitchHeight_MMIO(pAST->VideoModeInfo.ScreenPitch, -1);
d327 1
a327 1

a337 1
    int delta_y = 0;
d342 64
a405 1
    if ((width != 0) && (height != 0))
d407 9
a415 86
        /* Modify Reg. Value */
        cmdreg = pAST->ulCMDReg;
        if (pAST->EnableClip)
            cmdreg |= CMD_ENABLE_CLIP;
        else
            cmdreg &= ~CMD_ENABLE_CLIP;
        srcbase = dstbase = 0;

        if (x1 < x2)
            cmdreg |= CMD_X_DEC;

        if (y1 < y2)
            cmdreg |= CMD_Y_DEC;

        if ((y1 + height) >= MAX_SRC_Y)
        {
            srcbase=pAST->VideoModeInfo.ScreenPitch*y1;
            y1 = 0;
        }

        if ((y2 + height) >= pScrn->virtualY)
        {
            delta_y = y2;
            dstbase=pAST->VideoModeInfo.ScreenPitch*y2;
            y2 = 0;
        }

        if (cmdreg & CMD_X_DEC)
        {
            src_x = x1 + width - 1;
            dst_x = x2 + width - 1;
        }
        else
        {
            src_x = x1;
            dst_x = x2;
        }

        if (cmdreg & CMD_Y_DEC)
        {
            src_y = y1 + height - 1;
            dst_y = y2 + height - 1;
        }
        else
        {
            src_y = y1;
            dst_y = y2;
        }

        if (pAST->EnableClip)
            ASTSetHWClipping(pScrn, delta_y);

        if (!pAST->MMIO2D)
        {
            /* Write to CMDQ */
            pSingleCMD = (PKT_SC *) pjRequestCMDQ(pAST, PKT_SINGLE_LENGTH*6);

            ASTSetupSRCBase(pSingleCMD, srcbase);
            pSingleCMD++;
            ASTSetupDSTBase(pSingleCMD, dstbase);
            pSingleCMD++;
            ASTSetupDSTXY(pSingleCMD, dst_x, dst_y);
            pSingleCMD++;
            ASTSetupSRCXY(pSingleCMD, src_x, src_y);
            pSingleCMD++;
            ASTSetupRECTXY(pSingleCMD, width, height);
            pSingleCMD++;
            ASTSetupCMDReg(pSingleCMD, cmdreg);

            /* Update Write Pointer */
            mUpdateWritePointer;

        }
        else
        {
            ASTSetupSRCBase_MMIO(srcbase);
            ASTSetupDSTBase_MMIO(dstbase);
            ASTSetupDSTXY_MMIO(dst_x, dst_y);
            ASTSetupSRCXY_MMIO(src_x, src_y);
            ASTSetupRECTXY_MMIO(width, height);
            ASTSetupCMDReg_MMIO(cmdreg);

            vWaitEngIdle(pScrn, pAST);
        }

    } /* width & height check */
d423 1
a423 1

d428 1
a428 1
/*
d430 1
a430 1
*/
d441 1
a441 1
        break;
d445 1
a445 1
        break;
d449 2
a450 2

    if (!pAST->MMIO2D)
d457 1
a457 5
        ASTSetupFG(pSingleCMD, color);

        /* Update Write Pointer */
        mUpdateWritePointer;

d462 1
a462 1
        ASTSetupFG_MMIO(color);
d464 1
a464 1

d474 2
a475 4
    ULONG dstbase, cmdreg;
    int delta_y = 0;

/*
d479 5
a483 9
    if ((width != 0) && (height != 0))
    {
        /* Modify Reg. Value */
        cmdreg = pAST->ulCMDReg;
        if (pAST->EnableClip)
            cmdreg |= CMD_ENABLE_CLIP;
        else
            cmdreg &= ~CMD_ENABLE_CLIP;
        dstbase = 0;
d485 10
a494 6
        if (dst_y >= pScrn->virtualY)
        {
            delta_y = dst_y;
            dstbase=pAST->VideoModeInfo.ScreenPitch*dst_y;
            dst_y=0;
        }
d496 22
a517 32
        if (pAST->EnableClip)
            ASTSetHWClipping(pScrn, delta_y);

        if (!pAST->MMIO2D)
        {
            /* Write to CMDQ */
            pSingleCMD = (PKT_SC *) pjRequestCMDQ(pAST, PKT_SINGLE_LENGTH*4);

            ASTSetupDSTBase(pSingleCMD, dstbase);
            pSingleCMD++;
            ASTSetupDSTXY(pSingleCMD, dst_x, dst_y);
            pSingleCMD++;
            ASTSetupRECTXY(pSingleCMD, width, height);
            pSingleCMD++;
            ASTSetupCMDReg(pSingleCMD, cmdreg);

            /* Update Write Pointer */
            mUpdateWritePointer;

        }
        else
        {
            ASTSetupDSTBase_MMIO(dstbase);
            ASTSetupDSTXY_MMIO(dst_x, dst_y);
            ASTSetupRECTXY_MMIO(width, height);
            ASTSetupCMDReg_MMIO(cmdreg);

            vWaitEngIdle(pScrn, pAST);

        }

    } /* width & height check */
d523 1
a523 1
static void ASTSetupForSolidLine(ScrnInfoPtr pScrn,
d532 1
a532 1
*/
d543 1
a543 1
        break;
d547 1
a547 1
        break;
d549 1
a549 1
    cmdreg |= (ASTXAAPatternROP[rop] << 8);
d551 1
a551 1

d553 1
a553 1
    {
d559 1
a559 1
        ASTSetupFG(pSingleCMD, color);
d562 1
a562 4

        /* Update Write Pointer */
        mUpdateWritePointer;

d566 4
a569 4
        /* Write to MMIO */
        ASTSetupDSTPitchHeight_MMIO(pAST->VideoModeInfo.ScreenPitch, -1);
        ASTSetupFG_MMIO(color);
        ASTSetupBG_MMIO(0);
d571 1
a571 1

d581 1
a581 1
    ULONG dstbase, cmdreg;
d583 1
a583 2
    int delta_y = 0;
/*
d586 26
d613 22
a634 57
    if (len != 0)
    {
        /* Modify Reg. Value */
        cmdreg = (pAST->ulCMDReg & (~CMD_MASK)) | CMD_BITBLT;
        if (pAST->EnableClip)
            cmdreg |= CMD_ENABLE_CLIP;
        else
            cmdreg &= ~CMD_ENABLE_CLIP;
        dstbase = 0;

        if(dir == DEGREES_0) {			/* horizontal */
            width  = len;
            height = 1;
        } else {					/* vertical */
            width  = 1;
            height = len;
        }

        if ((y + height) >= pScrn->virtualY)
        {
            delta_y = y;
            dstbase=pAST->VideoModeInfo.ScreenPitch*y;
            y=0;
        }

        if (pAST->EnableClip)
            ASTSetHWClipping(pScrn, delta_y);

        if (!pAST->MMIO2D)
        {
            /* Write to CMDQ */
            pSingleCMD = (PKT_SC *) pjRequestCMDQ(pAST, PKT_SINGLE_LENGTH*4);

            ASTSetupDSTBase(pSingleCMD, dstbase);
            pSingleCMD++;
            ASTSetupDSTXY(pSingleCMD, x, y);
            pSingleCMD++;
            ASTSetupRECTXY(pSingleCMD, width, height);
            pSingleCMD++;
            ASTSetupCMDReg(pSingleCMD, cmdreg);

            /* Update Write Pointer */
            mUpdateWritePointer;

        }
        else
        {
            ASTSetupDSTBase_MMIO(dstbase);
            ASTSetupDSTXY_MMIO(x, y);
            ASTSetupRECTXY_MMIO(width, height);
            ASTSetupCMDReg_MMIO(cmdreg);

            vWaitEngIdle(pScrn, pAST);

        }

    } /* len check */
d636 1
d642 1
a642 1

d646 1
a646 1
    _LINEInfo   LineInfo;
d648 1
a648 1
    ULONG	miny, maxy;
a649 2
    int delta_y = 0;

d652 1
a652 1
*/
a661 2
    else
        ulCommand &= ~CMD_ENABLE_CLIP;
a665 1
    	delta_y = miny;
d670 1
a670 1

d675 1
a675 1

d677 11
a687 14

    if (dsLineParam.dwLineAttributes & LINEPARAM_X_DEC)
        ulCommand |= CMD_X_DEC;
    if (dsLineParam.dwLineAttributes & LINEPARAM_Y_DEC)
        ulCommand |= CMD_Y_DEC;

    usXM = (dsLineParam.dwLineAttributes & LINEPARAM_XM) ? 1:0;

    if (pAST->EnableClip)
        ASTSetHWClipping(pScrn, delta_y);

    if (!pAST->MMIO2D)
    {
        /* Write to CMDQ */
d691 1
a691 1
        pSingleCMD++;
d693 1
a693 1
        pSingleCMD++;
d695 1
a695 1
        pSingleCMD++;
d697 1
a697 1
        pSingleCMD++;
d699 1
a699 1
        pSingleCMD++;
d701 3
a703 3
        pSingleCMD++;
        ASTSetupCMDReg(pSingleCMD, ulCommand);

d705 2
a706 5
        mUpdateWritePointer;

        /* Patch KDE pass abnormal point, ycchen@@052507 */
        vWaitEngIdle(pScrn, pAST);

d709 1
a709 1
    {
d716 2
a717 2
        ASTSetupCMDReg_MMIO(ulCommand);

d719 1
a719 1

d722 1
a722 1

d737 1
a737 1
*/
d740 1
a740 1

d749 1
a749 1
        break;
d753 1
a753 1
        break;
d755 1
a755 1
    cmdreg |= (ASTXAAPatternROP[rop] << 8);
d757 1
a757 1
        cmdreg |= CMD_TRANSPARENT;
d762 1
a762 1

d764 1
a764 1
    {
d770 1
a770 1
        ASTSetupFG(pSingleCMD, fg);
d772 1
a772 1
        ASTSetupBG(pSingleCMD, bg);
d776 2
a777 5
        ASTSetupLineStyle2(pSingleCMD, *(pattern+4));

        /* Update Write Pointer */
        mUpdateWritePointer;

d781 1
a781 1
        /* Write to MMIO */
d783 2
a784 2
        ASTSetupFG_MMIO(fg);
        ASTSetupBG_MMIO(bg);
d786 1
a786 1
        ASTSetupLineStyle2_MMIO(*(pattern+4));
d789 1
a789 1

d797 1
a797 1

d801 3
a803 3
    _LINEInfo   LineInfo;
    ULONG 	dstbase, ulCommand;
    ULONG	miny, maxy;
a804 2
    int delta_y = 0;

d807 1
a807 1
*/
d817 1
a817 3
    else
        ulCommand &= ~CMD_ENABLE_CLIP;
    dstbase = 0;
a820 1
    	delta_y = miny;
d830 1
a830 1

d832 11
a842 14

    if (dsLineParam.dwLineAttributes & LINEPARAM_X_DEC)
        ulCommand |= CMD_X_DEC;
    if (dsLineParam.dwLineAttributes & LINEPARAM_Y_DEC)
        ulCommand |= CMD_Y_DEC;

    usXM = (dsLineParam.dwLineAttributes & LINEPARAM_XM) ? 1:0;

    if (pAST->EnableClip)
        ASTSetHWClipping(pScrn, delta_y);

    if (!pAST->MMIO2D)
    {
        /* Write to CMDQ */
d846 1
a846 1
        pSingleCMD++;
d848 1
a848 1
        pSingleCMD++;
d850 1
a850 1
        pSingleCMD++;
d852 1
a852 1
        pSingleCMD++;
d854 1
a854 1
        pSingleCMD++;
d856 3
a858 3
        pSingleCMD++;
        ASTSetupCMDReg(pSingleCMD, ulCommand);

d861 1
a861 4

        /* Patch KDE pass abnormal point, ycchen@@052507 */
        vWaitEngIdle(pScrn, pAST);

d864 1
a864 1
    {
d871 2
a872 2
        ASTSetupCMDReg_MMIO(ulCommand);

d874 1
a874 1

d876 1
a876 1

d885 1
a885 1

d890 1
a890 1
/*
d892 1
a892 1
*/
d903 1
a903 1
        break;
d907 1
a907 1
        break;
d911 2
a912 2

    if (!pAST->MMIO2D)
d919 1
a919 1
        ASTSetupFG(pSingleCMD, fg);
d923 1
a923 1
        ASTSetupMONO1(pSingleCMD, patx);
d925 1
a925 5
        ASTSetupMONO2(pSingleCMD, paty);

        /* Update Write Pointer */
        mUpdateWritePointer;

d930 1
a930 1
        ASTSetupFG_MMIO(fg);
d932 2
a933 2
        ASTSetupMONO1_MMIO(patx);
        ASTSetupMONO2_MMIO(paty);
d935 1
a935 1

d938 1
a938 1

d946 2
a947 4
    ULONG dstbase, cmdreg;
    int delta_y = 0;

/*
d949 2
a950 2
*/

d954 1
a954 3
        cmdreg |= CMD_ENABLE_CLIP;
    else
        cmdreg &= ~CMD_ENABLE_CLIP;
d957 2
a958 3
    if (dst_y >= pScrn->virtualY)
    {
    	delta_y = dst_y;
d962 4
a965 7

    if (pAST->EnableClip)
        ASTSetHWClipping(pScrn, delta_y);

    if (!pAST->MMIO2D)
    {
        /* Write to CMDQ */
d969 1
a969 1
        pSingleCMD++;
d971 1
a971 1
        pSingleCMD++;
d973 3
a975 3
        pSingleCMD++;
        ASTSetupCMDReg(pSingleCMD, cmdreg);

d978 1
a978 1

d981 1
a981 1
    {
d985 4
a988 4
        ASTSetupCMDReg_MMIO(cmdreg);

        vWaitEngIdle(pScrn, pAST);
    }
d996 1
a996 1

d1003 1
a1003 1
/*
d1005 1
a1005 1
*/
d1016 1
a1016 1
        break;
d1020 1
a1020 1
        break;
d1026 1
a1026 1
                        (paty * pAST->VideoModeInfo.ScreenPitch) + (patx * cpp));
d1028 2
a1029 2

    if (!pAST->MMIO2D)
d1031 1
a1031 1
        /* Write to CMDQ */
d1040 3
a1042 7
                pSingleCMD++;
            }
        }

        /* Update Write Pointer */
        mUpdateWritePointer;

d1045 1
a1045 1
    {
d1052 3
a1054 3
            }
        }

d1058 1
a1058 1

d1065 2
a1066 4
    ULONG dstbase, cmdreg;
    int delta_y = 0;

/*
d1069 1
a1069 1

d1073 1
a1073 3
        cmdreg |= CMD_ENABLE_CLIP;
    else
        cmdreg &= ~CMD_ENABLE_CLIP;
d1076 2
a1077 3
    if (dst_y >= pScrn->virtualY)
    {
    	delta_y = dst_y;
d1081 4
a1084 7

    if (pAST->EnableClip)
        ASTSetHWClipping(pScrn, delta_y);

    if (!pAST->MMIO2D)
    {
        /* Write to CMDQ */
d1088 1
a1088 1
        pSingleCMD++;
d1090 1
a1090 1
        pSingleCMD++;
d1092 3
a1094 3
        pSingleCMD++;
        ASTSetupCMDReg(pSingleCMD, cmdreg);

d1097 1
a1097 1

d1100 1
a1100 1
    {
d1104 5
a1108 5
        ASTSetupCMDReg_MMIO(cmdreg);

        vWaitEngIdle(pScrn, pAST);
    }

d1122 1
a1122 1
/*
d1124 1
a1124 1
*/
d1135 1
a1135 1
        break;
d1139 1
a1139 1
        break;
d1143 1
a1143 1
        cmdreg |= CMD_FONT_TRANSPARENT;
d1145 1
a1145 1
    }
d1147 2
a1148 2

    if (!pAST->MMIO2D)
d1155 1
a1155 1
        ASTSetupFG(pSingleCMD, fg);
d1157 2
a1158 5
        ASTSetupBG(pSingleCMD, bg);

        /* Update Write Pointer */
        mUpdateWritePointer;

d1163 3
a1165 3
        ASTSetupFG_MMIO(fg);
        ASTSetupBG_MMIO(bg);

d1167 1
a1167 1

d1169 1
a1169 1

a1178 1
    int delta_y = 0;
d1180 1
a1180 1
/*
d1183 1
a1183 1

d1187 1
a1187 3
        cmdreg |= CMD_ENABLE_CLIP;
    else
        cmdreg &= ~CMD_ENABLE_CLIP;
d1190 2
a1191 3
    if (dst_y >= pScrn->virtualY)
    {
    	delta_y = dst_y;
d1195 4
a1198 7

    if (pAST->EnableClip)
        ASTSetHWClipping(pScrn, delta_y);

    if (!pAST->MMIO2D)
    {
        /* Write to CMDQ */
d1201 2
a1202 2
        ASTSetupSRCPitch(pSingleCMD, ((width+7)/8));
        pSingleCMD++;
d1204 1
a1204 1
        pSingleCMD++;
d1206 1
a1206 1
        pSingleCMD++;
d1208 3
a1210 3
        pSingleCMD++;
        ASTSetupCMDReg(pSingleCMD, cmdreg);

d1213 1
a1213 1

d1216 2
a1217 2
    {
        ASTSetupSRCPitch_MMIO((width+7)/8);
d1221 1
a1221 1

d1223 2
a1224 2
        ASTSetupCMDReg_MMIO(cmdreg);

d1226 1
a1226 1

d1228 1
a1228 1

d1243 1
a1243 1
/*
d1246 1
a1246 1

d1257 1
a1257 1
        break;
d1261 1
a1261 1
        break;
d1265 1
a1265 1
        cmdreg |= CMD_FONT_TRANSPARENT;
d1267 1
a1267 1
    }
d1269 2
a1270 2

    if (!pAST->MMIO2D)
d1277 1
a1277 1
        ASTSetupFG(pSingleCMD, fg);
d1279 2
a1280 5
        ASTSetupBG(pSingleCMD, bg);

        /* Update Write Pointer */
        mUpdateWritePointer;

d1285 3
a1287 3
        ASTSetupFG_MMIO(fg);
        ASTSetupBG_MMIO(bg);

d1289 1
a1289 1

a1302 1
    int delta_y = 0;
d1304 1
a1304 1
/*
d1307 1
a1307 1

d1311 1
a1311 3
        cmdreg |= CMD_ENABLE_CLIP;
    else
        cmdreg &= ~CMD_ENABLE_CLIP;
d1313 2
a1314 3
    if (dst_y >= pScrn->virtualY)
    {
    	delta_y = dst_y;
d1318 1
a1318 1
    srcbase = pAST->VideoModeInfo.ScreenPitch*src_y + ((pScrn->bitsPerPixel+1)/8)*src_x;
d1320 4
a1323 7

    if (pAST->EnableClip)
        ASTSetHWClipping(pScrn, delta_y);

    if (!pAST->MMIO2D)
    {
        /* Write to CMDQ */
d1327 3
a1329 3
        pSingleCMD++;
        ASTSetupSRCPitch(pSingleCMD,srcpitch);
        pSingleCMD++;
d1331 1
a1331 1
        pSingleCMD++;
d1333 1
a1333 1
        pSingleCMD++;
d1335 3
a1337 3
        pSingleCMD++;
        ASTSetupCMDReg(pSingleCMD, cmdreg);

d1340 1
a1340 1

d1343 3
a1345 3
    {
        ASTSetupSRCBase_MMIO(srcbase);
        ASTSetupSRCPitch_MMIO(srcpitch);
d1349 2
a1350 2
        ASTSetupCMDReg_MMIO(cmdreg);

d1352 1
a1352 1

d1354 1
a1354 1

d1357 1
a1357 1

d1360 2
a1361 1
ASTSetHWClipping(ScrnInfoPtr pScrn, int delta_y)
d1363 1
d1366 6
a1371 2

    if (!pAST->MMIO2D)
d1376 1
a1376 1
        ASTSetupCLIP1(pSingleCMD, pAST->clip_left, pAST->clip_top - delta_y);
d1378 1
a1378 5
        ASTSetupCLIP2(pSingleCMD, pAST->clip_right + 1, pAST->clip_bottom - delta_y + 1);

        /* Update Write Pointer */
        mUpdateWritePointer;

d1382 2
a1383 2
        ASTSetupCLIP1_MMIO(pAST->clip_left, pAST->clip_top - delta_y);
        ASTSetupCLIP2_MMIO(pAST->clip_right + 1, pAST->clip_bottom - delta_y + 1);
d1385 1
a1385 20

}

static void
ASTSetClippingRectangle(ScrnInfoPtr pScrn,
                        int left, int top, int right, int bottom)
{

    ASTRecPtr pAST = ASTPTR(pScrn);
    PKT_SC *pSingleCMD;
/*
    xf86DrvMsg(pScrn->scrnIndex, X_INFO, "ASTSetClippingRectangle\n");
*/
    pAST->EnableClip = TRUE;

    pAST->clip_left   = left;
    pAST->clip_top    = top;
    pAST->clip_right  = right;
    pAST->clip_bottom = bottom;

d1392 1
a1392 1
/*
d1394 1
a1394 1
*/
d1398 1
a1398 303
static void AIPSubsequentSolidTwoPointLine(ScrnInfoPtr pScrn,
                                           int x1, int y1, int x2, int y2, int flags)
{

    ASTRecPtr 	pAST = ASTPTR(pScrn);
    PKT_SC 	*pSingleCMD;
    ULONG 	dstbase, ulCommand;
    ULONG	miny, maxy;
/*
    xf86DrvMsg(pScrn->scrnIndex, X_INFO, "ASTSubsequentSolidTwoPointLine\n");
*/

    /* Modify Reg. Value */
    ulCommand = (pAST->ulCMDReg & (~CMD_MASK)) | CMD_LINEDRAW | CMD_NORMAL_LINE;
    if(flags & OMIT_LAST)
        ulCommand |= CMD_NOT_DRAW_LAST_PIXEL;
    else
        ulCommand &= ~CMD_NOT_DRAW_LAST_PIXEL;
    if (pAST->EnableClip)
        ulCommand |= CMD_ENABLE_CLIP;
    else
        ulCommand &= ~CMD_ENABLE_CLIP;
    dstbase = 0;
    miny = (y1 > y2) ? y2 : y1;
    maxy = (y1 > y2) ? y1 : y2;
    if(maxy >= pScrn->virtualY) {
        dstbase = pAST->VideoModeInfo.ScreenPitch * miny;
        y1 -= miny;
        y2 -= miny;
    }

    if (!pAST->MMIO2D)
    {
        /* Write to CMDQ */
        pSingleCMD = (PKT_SC *) pjRequestCMDQ(pAST, PKT_SINGLE_LENGTH*5);

        ASTSetupDSTBase(pSingleCMD, dstbase);
        pSingleCMD++;
        AIPSetupLineXY(pSingleCMD, x1, y1);
        pSingleCMD++;
        AIPSetupLineXY2(pSingleCMD, x2, y2);
        pSingleCMD++;
        AIPSetupLineNumber(pSingleCMD, 0);
        pSingleCMD++;
        ASTSetupCMDReg(pSingleCMD, ulCommand);

        /* Update Write Pointer */
        mUpdateWritePointer;

        /* Patch KDE pass abnormal point, ycchen@@052507 */
        vWaitEngIdle(pScrn, pAST);

    }
    else
    {
        ASTSetupDSTBase_MMIO(dstbase);
        AIPSetupLineXY_MMIO(x1, y1);
        AIPSetupLineXY2_MMIO(x2, y2);
        AIPSetupLineNumber_MMIO(0);
        ASTSetupCMDReg_MMIO(ulCommand);

        vWaitEngIdle(pScrn, pAST);

    }


} /* end of AIPSubsequentSolidTwoPointLine */

static void
AIPSubsequentDashedTwoPointLine(ScrnInfoPtr pScrn,
                                int x1, int y1, int x2, int y2,
                                int flags, int phase)
{

    ASTRecPtr 	pAST = ASTPTR(pScrn);
    PKT_SC 	*pSingleCMD;
    ULONG 	dstbase, ulCommand;
    ULONG	miny, maxy;
/*
    xf86DrvMsg(pScrn->scrnIndex, X_INFO, "ASTSubsequentDashedTwoPointLine\n");
*/

    /* Modify Reg. Value */
    ulCommand = pAST->ulCMDReg | CMD_NORMAL_LINE;
    if(flags & OMIT_LAST)
        ulCommand |= CMD_NOT_DRAW_LAST_PIXEL;
    else
        ulCommand &= ~CMD_NOT_DRAW_LAST_PIXEL;
    if (pAST->EnableClip)
        ulCommand |= CMD_ENABLE_CLIP;
    else
        ulCommand &= ~CMD_ENABLE_CLIP;
    dstbase = 0;
    miny = (y1 > y2) ? y2 : y1;
    maxy = (y1 > y2) ? y1 : y2;
    if(maxy >= pScrn->virtualY) {
        dstbase = pAST->VideoModeInfo.ScreenPitch * miny;
        y1 -= miny;
        y2 -= miny;
    }

    if (!pAST->MMIO2D)
    {
        /* Write to CMDQ */
        pSingleCMD = (PKT_SC *) pjRequestCMDQ(pAST, PKT_SINGLE_LENGTH*5);

        ASTSetupDSTBase(pSingleCMD, dstbase);
        pSingleCMD++;
        AIPSetupLineXY(pSingleCMD, x1, y1);
        pSingleCMD++;
        AIPSetupLineXY2(pSingleCMD, x2, y2);
        pSingleCMD++;
        AIPSetupLineNumber(pSingleCMD, 0);
        pSingleCMD++;
        ASTSetupCMDReg(pSingleCMD, ulCommand);

        /* Update Write Pointer */
        mUpdateWritePointer;

        /* Patch KDE pass abnormal point, ycchen@@052507 */
        vWaitEngIdle(pScrn, pAST);

    }
    else
    {
        ASTSetupDSTBase_MMIO(dstbase);
        AIPSetupLineXY_MMIO(x1, y1);
        AIPSetupLineXY2_MMIO(x2, y2);
        AIPSetupLineNumber_MMIO(0);
        ASTSetupCMDReg_MMIO(ulCommand);

        vWaitEngIdle(pScrn, pAST);

    }

}
#endif	/* HAVE_XAA_H */

#ifdef	AstVideo
/*
 * Video Part
 * by ic_yang
 */
#include "fourcc.h"

void ASTDisplayVideo(ScrnInfoPtr pScrn, ASTPortPrivPtr pPriv, RegionPtr clipBoxes, int id)
{
    ASTPtr              pAST = ASTPTR(pScrn);
    int                 nBoxs;
    int                 ScaleFactorH, ScaleFactorV;
    ULONG               InitScaleFactorH, InitScaleFactorV;
    BURSTSCALECMD       CopyCmd = {0};
    PBURSTSCALECMD      pCopyCmd = NULL;
    float               fScaleX = 0, fScaleY = 0;
    xRectangle          rect;
    BoxPtr              pBox = NULL;
    short               lSrcX, lSrcY;
    ULONG               dwCmd = 0;
    int                 i;

    pBox = REGION_RECTS(clipBoxes);
    nBoxs = REGION_NUM_RECTS(clipBoxes);

    xf86DrvMsg(pScrn->scrnIndex, X_ERROR, "MMIO=%x,pBox=%x, nBoxs=%x\n", pAST->MMIO2D, pBox, nBoxs);

    if(0==pPriv->drw_w || 0==pPriv->drw_h)
    {
        xf86DrvMsg(pScrn->scrnIndex, X_ERROR, "drwx=%x, drwy=%x\n", pPriv->drw_w, pPriv->drw_h);
        return;
    }

    /* calc scaling factor */
    fScaleX = (float)pPriv->src_w /(float)pPriv->drw_w;
    fScaleY = (float)pPriv->src_h /(float)pPriv->drw_h;

    if (pPriv->src_w == pPriv->drw_w)
        ScaleFactorH = 0x8000;
    else
        ScaleFactorH = (ULONG)((pPriv->src_w-1)*0x8000)/pPriv->drw_w;

    if (pPriv->src_h == pPriv->drw_h)
    {
        ScaleFactorV = 0x8000;
		dwCmd |= SCALE_EQUAL_VER; /* Setting it save the bandwidtch */
   	}
    else
   	{
        ScaleFactorV = (ULONG)((pPriv->src_h-1)*0x8000)/pPriv->drw_h;
    }

    if (pPriv->drw_w >= pPriv->src_w)
        InitScaleFactorH = 0;
    else
        InitScaleFactorH = 0x4000;

    if (pPriv->drw_h >= pPriv->src_h)
        InitScaleFactorV = 0;
    else
        InitScaleFactorV = 0x4000;

    switch(pScrn->bitsPerPixel)
    {
    case 32:
        dwCmd   = CMD_COLOR_32;
        break;
    case 16:
        dwCmd   = CMD_COLOR_16;
        break;
    case  8:
        dwCmd   = CMD_COLOR_08;
        break;
    }

    dwCmd |= CMD_TYPE_SCALE;
    if (pPriv->drw_w >= pPriv->src_w)
        dwCmd |= SCALE_SEG_NUM_1;
    else
        dwCmd |= SCALE_SEG_NUM_2;

    dwCmd |= SCALE_FORMAT_YUV2RGB;
    switch(id)
    {
    case PIXEL_FMT_YUY2:
        dwCmd |= YUV_FORMAT_YUYV;
        break;
    case PIXEL_FMT_UYVY:
        dwCmd |= YUV_FORMAT_UYVY;
        break;
    default:
        xf86DrvMsg(pScrn->scrnIndex, X_ERROR, "Other pix format:%x\n", id);
        break;
    }

    for(i = 0; i < nBoxs; i++, pBox++)
    {
        rect.x = pBox->x1 - pPriv->drw_x;
        rect.y = pBox->y1 - pPriv->drw_y;
        rect.width = pBox->x2 - pBox->x1;
        rect.height = pBox->y2 - pBox->y1;

        lSrcX = (ULONG)((float)rect.x * fScaleX + pPriv->src_x + 0.5f);
        lSrcY = (ULONG)((float)rect.y * fScaleY + pPriv->src_y + 0.5f);

        pCopyCmd = (BURSTSCALECMD*)pjRequestCMDQ(pAST, PKT_TYPESCALE_LENGTH);

        xf86DrvMsg(pScrn->scrnIndex, X_INFO, "pCopyCmd=%p, pBox=%x,%x,%x,%x\n", pCopyCmd, pBox->x1, pBox->y1, pBox->x2, pBox->y2);

        CopyCmd.dwHeader0        = (ULONG)  PKT_BURST_CMD_HEADER0 |
                                             PKT_TYPESCALE_DATALENGTH |
                                             PKT_TYPESCALE_ADDRSTART  |
                                             BURST_FORCE_CMD;

        xf86DrvMsg(pScrn->scrnIndex, X_INFO, "CopyCmd.dwHeader0=%x\n", CopyCmd.dwHeader0);

        CopyCmd.dwSrcPitch       = (ULONG)(pPriv->srcPitch << 16);

        CopyCmd.dwDstHeightPitch = (ULONG)  ((pAST->VideoModeInfo.ScreenPitch << 16) | 0xFFFF);

        CopyCmd.dwDstXY          = (ULONG) ((pBox->x1 << 16) | (pBox->y1 & 0xFFFF));
        CopyCmd.dwSrcXY          = (ULONG) ((lSrcX << 16) | (lSrcY & 0xFFFF));
        CopyCmd.dwRecHeightWidth = (ULONG) ((rect.width << 16) | rect.height);

        CopyCmd.dwInitScaleFactorH = InitScaleFactorH;
        CopyCmd.dwInitScaleFactorV = InitScaleFactorV;
        CopyCmd.dwScaleFactorH   = ScaleFactorH;
        CopyCmd.dwScaleFactorV   = ScaleFactorV;

        CopyCmd.dwSrcBaseAddr = pPriv->bufAddr[pPriv->currentBuf];
        CopyCmd.dwDstBaseAddr = 0;
        CopyCmd.dwCmd = dwCmd;
        CopyCmd.NullData[0] = 0;    /* for alignment */
        memcpy(pCopyCmd, &CopyCmd, sizeof(CopyCmd));

        mUpdateWritePointer;

#if 0
        xf86DrvMsg(pScrn->scrnIndex, X_INFO, "%08x, %08x, %08x, %08x\n",
                        *(ULONG *)(pAST->MMIOVirtualAddr+0x8000),
                        *(ULONG *)(pAST->MMIOVirtualAddr+0x8004),
                        *(ULONG *)(pAST->MMIOVirtualAddr+0x8008),
                        *(ULONG *)(pAST->MMIOVirtualAddr+0x800C));
        xf86DrvMsg(pScrn->scrnIndex, X_INFO, "%08x, %08x, %08x, %08x\n",
                        *(ULONG *)(pAST->MMIOVirtualAddr+0x8010),
                        *(ULONG *)(pAST->MMIOVirtualAddr+0x8014),
                        *(ULONG *)(pAST->MMIOVirtualAddr+0x8018),
                        *(ULONG *)(pAST->MMIOVirtualAddr+0x801C));
        xf86DrvMsg(pScrn->scrnIndex, X_INFO, "%08x, %08x, %08x, %08x\n",
                        *(ULONG *)(pAST->MMIOVirtualAddr+0x8020),
                        *(ULONG *)(pAST->MMIOVirtualAddr+0x8024),
                        *(ULONG *)(pAST->MMIOVirtualAddr+0x8028),
                        *(ULONG *)(pAST->MMIOVirtualAddr+0x802C));
        xf86DrvMsg(pScrn->scrnIndex, X_INFO, "%08x, %08x, %08x, %08x\n",
                        *(ULONG *)(pAST->MMIOVirtualAddr+0x8030),
                        *(ULONG *)(pAST->MMIOVirtualAddr+0x8034),
                        *(ULONG *)(pAST->MMIOVirtualAddr+0x8038),
                        *(ULONG *)(pAST->MMIOVirtualAddr+0x803C));
#endif

    } /* End of for-loop */

} /* ASTDisplayVideo */
#endif	/* AstVideo */

@

