head	1.8;
access;
symbols
	OPENBSD_6_2:1.8.0.10
	OPENBSD_6_2_BASE:1.8
	OPENBSD_6_1:1.8.0.8
	OPENBSD_6_1_BASE:1.8
	OPENBSD_6_0:1.8.0.6
	OPENBSD_6_0_BASE:1.8
	OPENBSD_5_9:1.8.0.4
	OPENBSD_5_9_BASE:1.8
	OPENBSD_5_8:1.8.0.2
	OPENBSD_5_8_BASE:1.8
	OPENBSD_5_7:1.7.0.4
	OPENBSD_5_7_BASE:1.7
	OPENBSD_5_6:1.7.0.2
	OPENBSD_5_6_BASE:1.7
	v0_99_9:1.1.1.2
	OPENBSD_4_8:1.5.0.6
	OPENBSD_4_8_BASE:1.5
	OPENBSD_4_7:1.5.0.2
	OPENBSD_4_7_BASE:1.5
	OPENBSD_4_6:1.4.0.2
	OPENBSD_4_6_BASE:1.4
	OPENBSD_4_5:1.2.0.2
	OPENBSD_4_5_BASE:1.2
	OPENBSD_4_4:1.1.1.1.0.6
	OPENBSD_4_4_BASE:1.1.1.1
	OPENBSD_4_3_BASE:1.1.1.1
	OPENBSD_4_3:1.1.1.1.0.4
	OPENBSD_4_2:1.1.1.1.0.2
	OPENBSD_4_2_BASE:1.1.1.1
	v0_81_0:1.1.1.1
	xorg:1.1.1;
locks; strict;
comment	@ * @;


1.8
date	2015.05.24.09.17.25;	author matthieu;	state Exp;
branches;
next	1.7;
commitid	qBZygjuSMc2gFczl;

1.7
date	2014.04.13.10.36.51;	author matthieu;	state Exp;
branches;
next	1.6;

1.6
date	2010.11.29.21.17.47;	author matthieu;	state dead;
branches;
next	1.5;

1.5
date	2009.11.22.15.33.58;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2009.05.03.16.31.23;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2009.03.07.11.16.36;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2008.08.23.21.00.47;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.26.20.00.10;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.11.26.20.00.10;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2014.04.13.10.30.12;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.8
log
@Update to xf86-video-ast 1.0.1
@
text
@/*
 * Copyright (c) 2005 ASPEED Technology Inc.
 *
 * Permission to use, copy, modify, distribute, and sell this software and its
 * documentation for any purpose is hereby granted without fee, provided that
 * the above copyright notice appear in all copies and that both that
 * copyright notice and this permission notice appear in supporting
 * documentation, and that the name of the authors not be used in
 * advertising or publicity pertaining to distribution of the software without
 * specific, written prior permission.  The authors makes no representations
 * about the suitability of this software for any purpose.  It is provided
 * "as is" without express or implied warranty.
 *
 * THE AUTHORS DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
 * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO
 * EVENT SHALL THE AUTHORS BE LIABLE FOR ANY SPECIAL, INDIRECT OR
 * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
 * DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
 * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
 * PERFORMANCE OF THIS SOFTWARE.
 */

#ifdef HAVE_CONFIG_H
#include <config.h>
#endif
#include "xf86.h"
#include "xf86_OSproc.h"
#include "xf86cmap.h"
#include "compiler.h"
#include "vgaHW.h"
#include "mipointer.h"
#include "micmap.h"

#include "fb.h"
#include "regionstr.h"
#include "xf86xv.h"
#include <X11/extensions/Xv.h>

#include "xf86Pci.h"

/* framebuffer offscreen manager */
#include "xf86fbman.h"

/* include xaa includes */
#include "xaarop.h"

/* H/W cursor support */
#include "xf86Cursor.h"
#include "cursorstr.h"

/* Driver specific headers */
#include "ast.h"
#include "ast_vgatool.h"
#include "ast_cursor.h"

#ifdef	HWC
/* Prototype type declaration */
static void ASTShowCursor(ScrnInfoPtr pScrn);
static void ASTHideCursor(ScrnInfoPtr pScrn);
static void ASTSetCursorPosition(ScrnInfoPtr pScrn, int x, int y);
static void ASTSetCursorColors(ScrnInfoPtr pScrn, int bg, int fg);
static void ASTLoadCursorImage(ScrnInfoPtr pScrn, UCHAR *src);
static Bool ASTUseHWCursor(ScreenPtr pScreen, CursorPtr pCurs);
static void ASTLoadCursorARGB(ScrnInfoPtr pScrn, CursorPtr pCurs);
static Bool ASTUseHWCursorARGB(ScreenPtr pScreen, CursorPtr pCurs);
static void ASTFireCursor(ScrnInfoPtr pScrn);
static void ASTShowCursor_AST1180(ScrnInfoPtr pScrn);
static void ASTHideCursor_AST1180(ScrnInfoPtr pScrn);
static void ASTSetCursorPosition_AST1180(ScrnInfoPtr pScrn, int x, int y);

Bool
ASTCursorInit(ScreenPtr pScreen)
{
    ScrnInfoPtr	pScrn = xf86ScreenToScrn(pScreen);
    ASTRecPtr 	pAST = ASTPTR(pScrn);
    xf86CursorInfoPtr infoPtr;

    infoPtr = xf86CreateCursorInfoRec();
    if(!infoPtr) return FALSE;

    pAST->HWCInfoPtr = infoPtr;

    infoPtr->Flags = HARDWARE_CURSOR_TRUECOLOR_AT_8BPP |
                     HARDWARE_CURSOR_INVERT_MASK |
                     HARDWARE_CURSOR_BIT_ORDER_MSBFIRST;

    infoPtr->MaxWidth  = MAX_HWC_WIDTH;
    infoPtr->MaxHeight = MAX_HWC_HEIGHT;
    if (pAST->jChipType == AST1180)
    {
        infoPtr->ShowCursor = ASTShowCursor_AST1180;
        infoPtr->HideCursor = ASTHideCursor_AST1180;
        infoPtr->SetCursorPosition = ASTSetCursorPosition_AST1180;
    }
    else
    {
        infoPtr->ShowCursor = ASTShowCursor;
        infoPtr->HideCursor = ASTHideCursor;
        infoPtr->SetCursorPosition = ASTSetCursorPosition;
    }
    infoPtr->SetCursorColors = ASTSetCursorColors;
    infoPtr->LoadCursorImage = ASTLoadCursorImage;
    infoPtr->UseHWCursor = ASTUseHWCursor;
#ifdef ARGB_CURSOR
    infoPtr->UseHWCursorARGB = ASTUseHWCursorARGB;
    infoPtr->LoadCursorARGB = ASTLoadCursorARGB;
#endif

    return(xf86InitCursor(pScreen, infoPtr));

}

Bool bASTInitHWC(ScrnInfoPtr pScrn, ASTRecPtr pAST)
{
    ScreenPtr	pScreen;

    /* init cursor cache info */
    /* Set HWC_NUM in Options instead */
    /* pAST->HWCInfo.HWC_NUM = DEFAULT_HWC_NUM; */
    pAST->HWCInfo.HWC_NUM_Next = 0;

    /* allocate HWC cache */
    if (!pAST->pHWCPtr) {
        pScreen = xf86ScrnToScreen(pScrn);
        pAST->pHWCPtr = xf86AllocateOffscreenLinear (pScreen, (HWC_SIZE+HWC_SIGNATURE_SIZE)*pAST->HWCInfo.HWC_NUM, HWC_ALIGN, NULL, NULL, NULL);

        if (!pAST->pHWCPtr) {
           xf86DrvMsg(pScrn->scrnIndex, X_ERROR,"Allocate HWC Cache failed \n");
           return (FALSE);
        }

        pAST->HWCInfo.ulHWCOffsetAddr  = pAST->pHWCPtr->offset*((pScrn->bitsPerPixel + 1) / 8);
        pAST->HWCInfo.pjHWCVirtualAddr = pAST->FBVirtualAddr + pAST->HWCInfo.ulHWCOffsetAddr;
    }

    return (TRUE);
}

void ASTDisableHWC(ScrnInfoPtr pScrn)
{
    ASTRecPtr   pAST = ASTPTR(pScrn);

    if (pAST->jChipType == AST1180)
        ASTHideCursor_AST1180(pScrn);
    else
        ASTHideCursor(pScrn);
}

static void
ASTShowCursor(ScrnInfoPtr pScrn)
{
    ASTRecPtr   pAST = ASTPTR(pScrn);
    UCHAR 	jReg;

    jReg= 0x02;
    if (pAST->HWCInfo.cursortype ==HWC_COLOR)
        jReg |= 0x01;

    SetIndexRegMask(CRTC_PORT, 0xCB, 0xFC, jReg);	/* enable mono */

}

static void
ASTHideCursor(ScrnInfoPtr pScrn)
{
    ASTRecPtr  pAST = ASTPTR(pScrn);

    SetIndexRegMask(CRTC_PORT, 0xCB, 0xFC, 0x00);	/* disable HWC */

}

static void
ASTSetCursorPosition(ScrnInfoPtr pScrn, int x, int y)
{
    ASTRecPtr	pAST = ASTPTR(pScrn);
    DisplayModePtr mode = pAST->ModePtr;
    int		x_offset, y_offset;
    UCHAR 	*pjSignature;

    /* Set cursor info to Offscreen */
    pjSignature = (UCHAR *) pAST->HWCInfo.pjHWCVirtualAddr + (HWC_SIZE+HWC_SIGNATURE_SIZE)*pAST->HWCInfo.HWC_NUM_Next + HWC_SIZE;
    *((ULONG *) (pjSignature + HWC_SIGNATURE_X)) = x;
    *((ULONG *) (pjSignature + HWC_SIGNATURE_Y)) = y;

    x_offset = pAST->HWCInfo.offset_x;
    y_offset = pAST->HWCInfo.offset_y;

    if(x < 0) {
       x_offset = (-x) + pAST->HWCInfo.offset_x;
       x = 0;
    }

    if(y < 0) {
       y_offset = (-y) + pAST->HWCInfo.offset_y;
       y = 0;
    }

    if(mode->Flags & V_DBLSCAN)  y *= 2;

    /* Set to Reg. */
    SetIndexReg(CRTC_PORT, 0xC2, (UCHAR) (x_offset));
    SetIndexReg(CRTC_PORT, 0xC3, (UCHAR) (y_offset));
    SetIndexReg(CRTC_PORT, 0xC4, (UCHAR) (x & 0xFF));
    SetIndexReg(CRTC_PORT, 0xC5, (UCHAR) ((x >> 8) & 0x0F));
    SetIndexReg(CRTC_PORT, 0xC6, (UCHAR) (y & 0xFF));
    SetIndexReg(CRTC_PORT, 0xC7, (UCHAR) ((y >> 8) & 0x07));

    /* Fire HWC */
    ASTFireCursor(pScrn);

}

static void
ASTSetCursorColors(ScrnInfoPtr pScrn, int bg, int fg)
{
    ASTRecPtr 	pAST = ASTPTR(pScrn);
    ULONG fg1, bg1;

    fg1 = (fg & 0x0F) | (((fg>>8) & 0x0F) << 4) | (((fg>>16) & 0x0F) << 8);
    bg1 = (bg & 0x0F) | (((bg>>8) & 0x0F) << 4) | (((bg>>16) & 0x0F) << 8);

    /* Fixed xorg bugzilla #20609, ycchen@@031209 */
    if ( (fg1 != pAST->HWCInfo.fg) || (bg1 != pAST->HWCInfo.bg) )
    {
    	pAST->HWCInfo.fg = fg1;
    	pAST->HWCInfo.bg = bg1;
        ASTLoadCursorImage(pScrn, pAST->HWCInfo.cursorpattern);
    }

}

static void
ASTLoadCursorImage(ScrnInfoPtr pScrn, UCHAR *src)
{
    ASTRecPtr	pAST = ASTPTR(pScrn);
    int 	i, j, k;
    UCHAR 	*pjSrcAnd, *pjSrcXor, *pjDstData;
    ULONG   	ulTempDstAnd32[2], ulTempDstXor32[2], ulTempDstData32[2];
    UCHAR    	jTempSrcAnd32, jTempSrcXor32;
    ULONG	ulCheckSum = 0;
    ULONG 	ulPatternAddr;

    /* init cursor info. */
    pAST->HWCInfo.cursortype = HWC_MONO;
    pAST->HWCInfo.width  = (USHORT) MAX_HWC_WIDTH;
    pAST->HWCInfo.height = (USHORT) MAX_HWC_HEIGHT;
    pAST->HWCInfo.offset_x = MAX_HWC_WIDTH - pAST->HWCInfo.width;
    pAST->HWCInfo.offset_y = MAX_HWC_HEIGHT - pAST->HWCInfo.height;

    /* copy to hwc info */
    for (i=0; i< MAX_HWC_WIDTH*MAX_HWC_HEIGHT/4; i+=4)
       *(ULONG *) (pAST->HWCInfo.cursorpattern + i) = *(ULONG *) (src + i);

    /* copy cursor image to cache */
    pjSrcXor = src;
    pjSrcAnd = src + (MAX_HWC_WIDTH*MAX_HWC_HEIGHT/8);
    pjDstData =  pAST->HWCInfo.pjHWCVirtualAddr+(HWC_SIZE+HWC_SIGNATURE_SIZE)*pAST->HWCInfo.HWC_NUM_Next;

    for (j = 0; j < MAX_HWC_HEIGHT; j++)
    {
       for (i = 0; i < (MAX_HWC_WIDTH/8); i++ )
       {
       	    for (k=7; k>0; k-=2)
       	    {
                jTempSrcAnd32 = *((UCHAR *) pjSrcAnd);
                jTempSrcXor32 = *((UCHAR *) pjSrcXor);
                ulTempDstAnd32[0] = ((jTempSrcAnd32 >> k) & 0x01) ? 0x00008000L:0x00L;
                ulTempDstXor32[0] = ((jTempSrcXor32 >> k) & 0x01) ? 0x00004000L:0x00L;
                ulTempDstData32[0] = ((jTempSrcXor32 >> k) & 0x01) ? pAST->HWCInfo.fg:pAST->HWCInfo.bg;
                ulTempDstAnd32[1] = ((jTempSrcAnd32 >> (k-1)) & 0x01) ? 0x80000000L:0x00L;
                ulTempDstXor32[1] = ((jTempSrcXor32 >> (k-1)) & 0x01) ? 0x40000000L:0x00L;
                ulTempDstData32[1] = ((jTempSrcXor32 >> (k-1)) & 0x01) ? (pAST->HWCInfo.fg << 16):(pAST->HWCInfo.bg << 16);
                /* No inverse for X Window cursor, ycchen@@111808 */
                if (ulTempDstAnd32[0])
                    ulTempDstXor32[0] = 0;
                if (ulTempDstAnd32[1])
                    ulTempDstXor32[1] = 0;
                *((ULONG *) pjDstData) = ulTempDstAnd32[0] | ulTempDstXor32[0] | ulTempDstData32[0] | ulTempDstAnd32[1] | ulTempDstXor32[1] | ulTempDstData32[1];
                ulCheckSum += *((ULONG *) pjDstData);
                pjDstData += 4;

            }
            pjSrcAnd ++;
            pjSrcXor ++;

       }

    }

    if (pAST->jChipType == AST1180)
    {
        ulPatternAddr = pAST->ulVRAMBase + (pAST->HWCInfo.ulHWCOffsetAddr+(HWC_SIZE+HWC_SIGNATURE_SIZE)*pAST->HWCInfo.HWC_NUM_Next);
        WriteAST1180SOC(AST1180_GFX_BASE+AST1180_HWC1_PATTERNADDR, ulPatternAddr);
    }
    else
    {
        /* Write Checksum as signature */
        pjDstData = (UCHAR *) pAST->HWCInfo.pjHWCVirtualAddr + (HWC_SIZE+HWC_SIGNATURE_SIZE)*pAST->HWCInfo.HWC_NUM_Next + HWC_SIZE;
        *((ULONG *) pjDstData) = ulCheckSum;
        *((ULONG *) (pjDstData + HWC_SIGNATURE_SizeX)) = pAST->HWCInfo.width;
        *((ULONG *) (pjDstData + HWC_SIGNATURE_SizeY)) = pAST->HWCInfo.height;
        *((ULONG *) (pjDstData + HWC_SIGNATURE_HOTSPOTX)) = 0;
        *((ULONG *) (pjDstData + HWC_SIGNATURE_HOTSPOTY)) = 0;

        /* set pattern offset */
        ulPatternAddr = ((pAST->HWCInfo.ulHWCOffsetAddr+(HWC_SIZE+HWC_SIGNATURE_SIZE)*pAST->HWCInfo.HWC_NUM_Next) >> 3);
        SetIndexReg(CRTC_PORT, 0xC8, (UCHAR) (ulPatternAddr & 0xFF));
        SetIndexReg(CRTC_PORT, 0xC9, (UCHAR) ((ulPatternAddr >> 8) & 0xFF));
        SetIndexReg(CRTC_PORT, 0xCA, (UCHAR) ((ulPatternAddr >> 16) & 0xFF));
    }

    /* update HWC_NUM_Next */
    pAST->HWCInfo.HWC_NUM_Next = (pAST->HWCInfo.HWC_NUM_Next+1) % pAST->HWCInfo.HWC_NUM;

}

static Bool
ASTUseHWCursor(ScreenPtr pScreen, CursorPtr pCurs)
{
    if ( (pCurs->bits->width > MAX_HWC_WIDTH) || (pCurs->bits->height > MAX_HWC_HEIGHT) )
        return FALSE;

    return TRUE;
}

static void
ASTLoadCursorARGB(ScrnInfoPtr pScrn, CursorPtr pCurs)
{
    ASTRecPtr 	pAST = ASTPTR(pScrn);

    UCHAR	*pjDstXor, *pjSrcXor;
    ULONG       i, j, ulSrcWidth, ulSrcHeight;
    ULONG	ulPerPixelCopy, ulTwoPixelCopy;
    LONG        lAlphaDstDelta, lLastAlphaDstDelta;
    union
    {
        ULONG   ul;
        UCHAR   b[4];
    } ulSrcData32[2], ulData32;
    union
    {
        USHORT  us;
        UCHAR   b[2];
    } usData16;
    ULONG	ulCheckSum = 0;
    ULONG 	ulPatternAddr;

    /* init cursor info. */
    pAST->HWCInfo.cursortype = HWC_COLOR;
    pAST->HWCInfo.width  = pCurs->bits->width;
    pAST->HWCInfo.height = pCurs->bits->height;
    pAST->HWCInfo.offset_x = MAX_HWC_WIDTH - pAST->HWCInfo.width;
    pAST->HWCInfo.offset_y = MAX_HWC_HEIGHT - pAST->HWCInfo.height;

    /* copy cursor image to cache */
    ulSrcWidth  =  pAST->HWCInfo.width;
    ulSrcHeight =  pAST->HWCInfo.height;

    lAlphaDstDelta = MAX_HWC_WIDTH << 1;
    lLastAlphaDstDelta = lAlphaDstDelta - (ulSrcWidth << 1);

    pjSrcXor  = (UCHAR *) pCurs->bits->argb;;
    pjDstXor  = (UCHAR *) pAST->HWCInfo.pjHWCVirtualAddr + (HWC_SIZE+HWC_SIGNATURE_SIZE)*pAST->HWCInfo.HWC_NUM_Next
                        + lLastAlphaDstDelta + (MAX_HWC_HEIGHT - ulSrcHeight) * lAlphaDstDelta;

    ulPerPixelCopy =  ulSrcWidth & 1;
    ulTwoPixelCopy =  ulSrcWidth >> 1;

    for (j = 0; j < ulSrcHeight; j++)
    {

        for (i = 0; i < ulTwoPixelCopy; i++ )
        {
            ulSrcData32[0].ul = *((ULONG *) pjSrcXor) & 0xF0F0F0F0;
            ulSrcData32[1].ul = *((ULONG *) (pjSrcXor+4)) & 0xF0F0F0F0;
            ulData32.b[0] = ulSrcData32[0].b[1] | (ulSrcData32[0].b[0] >> 4);
            ulData32.b[1] = ulSrcData32[0].b[3] | (ulSrcData32[0].b[2] >> 4);
            ulData32.b[2] = ulSrcData32[1].b[1] | (ulSrcData32[1].b[0] >> 4);
            ulData32.b[3] = ulSrcData32[1].b[3] | (ulSrcData32[1].b[2] >> 4);
            *((ULONG *) pjDstXor) = ulData32.ul;
            ulCheckSum += (ULONG) ulData32.ul;
            pjDstXor += 4;
            pjSrcXor += 8;
        }

        for (i = 0; i < ulPerPixelCopy; i++ )
        {
            ulSrcData32[0].ul = *((ULONG *) pjSrcXor) & 0xF0F0F0F0;
            usData16.b[0] = ulSrcData32[0].b[1] | (ulSrcData32[0].b[0] >> 4);
            usData16.b[1] = ulSrcData32[0].b[3] | (ulSrcData32[0].b[2] >> 4);
            *((USHORT *) pjDstXor) = usData16.us;
            ulCheckSum += (ULONG) usData16.us;
            pjDstXor += 2;
            pjSrcXor += 4;
        }

        /* Point to next source and dest scans */
        pjDstXor += lLastAlphaDstDelta;

    } /* end of for-loop */

    if (pAST->jChipType == AST1180)
    {
        ulPatternAddr = pAST->ulVRAMBase + (pAST->HWCInfo.ulHWCOffsetAddr+(HWC_SIZE+HWC_SIGNATURE_SIZE)*pAST->HWCInfo.HWC_NUM_Next);
        WriteAST1180SOC(AST1180_GFX_BASE+AST1180_HWC1_PATTERNADDR, ulPatternAddr);
    }
    else
    {
        /* Write Checksum as signature */
        pjDstXor = (UCHAR *) pAST->HWCInfo.pjHWCVirtualAddr + (HWC_SIZE+HWC_SIGNATURE_SIZE)*pAST->HWCInfo.HWC_NUM_Next + HWC_SIZE;
        *((ULONG *) pjDstXor) = ulCheckSum;
        *((ULONG *) (pjDstXor + HWC_SIGNATURE_SizeX)) = pAST->HWCInfo.width;
        *((ULONG *) (pjDstXor + HWC_SIGNATURE_SizeY)) = pAST->HWCInfo.height;
        *((ULONG *) (pjDstXor + HWC_SIGNATURE_HOTSPOTX)) = 0;
        *((ULONG *) (pjDstXor + HWC_SIGNATURE_HOTSPOTY)) = 0;

        /* set pattern offset */
        ulPatternAddr = ((pAST->HWCInfo.ulHWCOffsetAddr +(HWC_SIZE+HWC_SIGNATURE_SIZE)*pAST->HWCInfo.HWC_NUM_Next) >> 3);
        SetIndexReg(CRTC_PORT, 0xC8, (UCHAR) (ulPatternAddr & 0xFF));
        SetIndexReg(CRTC_PORT, 0xC9, (UCHAR) ((ulPatternAddr >> 8) & 0xFF));
        SetIndexReg(CRTC_PORT, 0xCA, (UCHAR) ((ulPatternAddr >> 16) & 0xFF));
    }

    /* update HWC_NUM_Next */
    pAST->HWCInfo.HWC_NUM_Next = (pAST->HWCInfo.HWC_NUM_Next+1) % pAST->HWCInfo.HWC_NUM;

}

static Bool
ASTUseHWCursorARGB(ScreenPtr pScreen, CursorPtr pCurs)
{
    if ( (pCurs->bits->width > MAX_HWC_WIDTH) || (pCurs->bits->height > MAX_HWC_HEIGHT) )
        return FALSE;

    return TRUE;
}

static void
ASTFireCursor(ScrnInfoPtr pScrn)
{
    ASTRecPtr  pAST = ASTPTR(pScrn);

    SetIndexRegMask(CRTC_PORT, 0xCB, 0xFF, 0x00);	/* dummp write to fire HWC */

}

/* AST1180 */
static void
ASTShowCursor_AST1180(ScrnInfoPtr pScrn)
{
    ASTRecPtr   pAST = ASTPTR(pScrn);
    ULONG 	ulData, ulTemp;

    ReadAST1180SOC(AST1180_GFX_BASE+AST1180_HWC1_POSITION, ulTemp);

    ReadAST1180SOC(AST1180_GFX_BASE+AST1180_VGA1_CTRL, ulData);
    ulData &= ~AST1180_ALPHAHWC;
    if (pAST->HWCInfo.cursortype ==HWC_COLOR)
        ulData |= AST1180_ALPHAHWC;
    ulData |= AST1180_ENABLEHWC;
    WriteAST1180SOC(AST1180_GFX_BASE+AST1180_VGA1_CTRL, ulData);

    /* fire cursor */
    WriteAST1180SOC(AST1180_GFX_BASE+AST1180_HWC1_POSITION, ulTemp);

} /* ASTShowCursor_AST1180 */

static void
ASTHideCursor_AST1180(ScrnInfoPtr pScrn)
{
    ASTRecPtr  pAST = ASTPTR(pScrn);
    ULONG 	ulData;

    ReadAST1180SOC(AST1180_GFX_BASE+AST1180_VGA1_CTRL, ulData);
    ulData &= ~AST1180_ENABLEHWC;
    WriteAST1180SOC(AST1180_GFX_BASE+AST1180_VGA1_CTRL, ulData);

    /* fire cursor */
    WriteAST1180SOC(AST1180_GFX_BASE+AST1180_HWC1_POSITION, 0x07ff07ff);

} /* ASTHideCursor_AST1180 */

static void
ASTSetCursorPosition_AST1180(ScrnInfoPtr pScrn, int x, int y)
{
    ASTRecPtr	pAST = ASTPTR(pScrn);
    DisplayModePtr mode = pAST->ModePtr;
    int		x_offset, y_offset;
    ULONG	ulData;

    x_offset = pAST->HWCInfo.offset_x;
    y_offset = pAST->HWCInfo.offset_y;

    if(x < 0) {
       x_offset = (-x) + pAST->HWCInfo.offset_x;
       x = 0;
    }

    if(y < 0) {
       y_offset = (-y) + pAST->HWCInfo.offset_y;
       y = 0;
    }

    if(mode->Flags & V_DBLSCAN)  y *= 2;

    /* Set to Reg. */
    ulData = (x_offset) | (y_offset << 8);
    WriteAST1180SOC(AST1180_GFX_BASE+AST1180_HWC1_OFFSET, ulData);
    ulData = (x) | (y << 16);
    WriteAST1180SOC(AST1180_GFX_BASE+AST1180_HWC1_POSITION, ulData);

} /* ASTSetCursorPosition_AST1180 */

#endif	/* End of HWC */
@


1.7
log
@Re-add ast files that previous re-import failed to re-add
@
text
@a38 1
#include "xf86PciInfo.h"
d53 2
a57 3
Bool ASTCursorInit(ScreenPtr pScreen);
Bool bInitHWC(ScrnInfoPtr pScrn, ASTRecPtr pAST);
void ASTDisableHWC(ScrnInfoPtr pScrn);
d113 1
a113 1
Bool bInitHWC(ScrnInfoPtr pScrn, ASTRecPtr pAST)
@


1.6
log
@Remove a bunch of video drivers that were never built on OpenBSD and
are unlikely to be ported in the future. no objection from miod@@ krw@@.
@
text
@a29 1
#include "mibstore.h"
a37 1
#include "vbe.h"
a45 1
#include "xaa.h"
d59 3
a61 2
static void ASTShowCursor(ScrnInfoPtr pScrn); 
void ASTHideCursor(ScrnInfoPtr pScrn);
d68 4
a71 2

static void ASTFireCursor(ScrnInfoPtr pScrn); 
d76 1
a76 1
    ScrnInfoPtr	pScrn = xf86Screens[pScreen->myNum];
d86 1
a86 1
                     HARDWARE_CURSOR_INVERT_MASK |        
d91 12
a102 3
    infoPtr->ShowCursor = ASTShowCursor;
    infoPtr->HideCursor = ASTHideCursor;
    infoPtr->SetCursorPosition = ASTSetCursorPosition;
d112 1
a112 1
    
d120 1
a120 1
    /* Set HWC_NUM in Options instead */ 
d122 5
a126 5
    pAST->HWCInfo.HWC_NUM_Next = 0;    
      	
    /* allocate HWC cache */  
    if (!pAST->pHWCPtr) {   	    		       
        pScreen = screenInfo.screens[pScrn->scrnIndex];
d129 1
a129 1
        if (!pAST->pHWCPtr) {   		  
d133 1
a133 1
        
d135 1
a135 1
        pAST->HWCInfo.pjHWCVirtualAddr = pAST->FBVirtualAddr + pAST->HWCInfo.ulHWCOffsetAddr;                
d138 1
a138 1
    return (TRUE);	
d141 9
d154 1
a154 1
    ASTRecPtr   pAST = ASTPTR(pScrn);    
d160 3
a162 3
               
    SetIndexRegMask(CRTC_PORT, 0xCB, 0xFC, jReg);	/* enable mono */ 	
    
d165 1
a165 1
void
d169 3
a171 3
        
    SetIndexRegMask(CRTC_PORT, 0xCB, 0xFC, 0x00);	/* disable HWC */ 	
        
d178 1
a178 1
    DisplayModePtr mode = pAST->ModePtr;    
d180 4
a183 4
    UCHAR 	*pjSignature;    
       
    /* Set cursor info to Offscreen */    
    pjSignature = (UCHAR *) pAST->HWCInfo.pjHWCVirtualAddr + (HWC_SIZE+HWC_SIGNATURE_SIZE)*pAST->HWCInfo.HWC_NUM_Next + HWC_SIZE;   
d186 1
a186 1
               
d189 1
a189 1
    
d201 1
a201 1
 
d203 7
a209 7
    SetIndexReg(CRTC_PORT, 0xC2, (UCHAR) (x_offset)); 	
    SetIndexReg(CRTC_PORT, 0xC3, (UCHAR) (y_offset)); 	
    SetIndexReg(CRTC_PORT, 0xC4, (UCHAR) (x & 0xFF)); 	
    SetIndexReg(CRTC_PORT, 0xC5, (UCHAR) ((x >> 8) & 0x0F)); 	
    SetIndexReg(CRTC_PORT, 0xC6, (UCHAR) (y & 0xFF)); 	
    SetIndexReg(CRTC_PORT, 0xC7, (UCHAR) ((y >> 8) & 0x07)); 	
    
d212 2
a213 2
        
}  
d220 1
a220 1
        
d222 1
a222 1
    bg1 = (bg & 0x0F) | (((bg>>8) & 0x0F) << 4) | (((bg>>16) & 0x0F) << 8);    
d225 1
a225 1
    if ( (fg1 != pAST->HWCInfo.fg) || (bg1 != pAST->HWCInfo.bg) )    
d230 1
a230 1
    }    
d237 1
a237 1
    ASTRecPtr	pAST = ASTPTR(pScrn);   
d242 3
a244 3
    ULONG	ulCheckSum = 0;  		               
    ULONG 	ulPatternAddr;    
       
d255 1
a255 1
 
d260 1
a260 1
      
d270 4
a273 4
                ulTempDstXor32[0] = ((jTempSrcXor32 >> k) & 0x01) ? 0x00004000L:0x00L;                   	                                  	                 
                ulTempDstData32[0] = ((jTempSrcXor32 >> k) & 0x01) ? pAST->HWCInfo.fg:pAST->HWCInfo.bg;                   	                                  	                                                   
                ulTempDstAnd32[1] = ((jTempSrcAnd32 >> (k-1)) & 0x01) ? 0x80000000L:0x00L;   
                ulTempDstXor32[1] = ((jTempSrcXor32 >> (k-1)) & 0x01) ? 0x40000000L:0x00L;                   	                                  	  
d279 1
a279 1
                    ulTempDstXor32[1] = 0;                    
d281 1
a281 1
                ulCheckSum += *((ULONG *) pjDstData);                               
d287 27
a313 19
             
       }        
        
    }        		    

    /* Write Checksum as signature */
    pjDstData = (UCHAR *) pAST->HWCInfo.pjHWCVirtualAddr + (HWC_SIZE+HWC_SIGNATURE_SIZE)*pAST->HWCInfo.HWC_NUM_Next + HWC_SIZE;   
    *((ULONG *) pjDstData) = ulCheckSum;
    *((ULONG *) (pjDstData + HWC_SIGNATURE_SizeX)) = pAST->HWCInfo.width;
    *((ULONG *) (pjDstData + HWC_SIGNATURE_SizeY)) = pAST->HWCInfo.height;
    *((ULONG *) (pjDstData + HWC_SIGNATURE_HOTSPOTX)) = 0;
    *((ULONG *) (pjDstData + HWC_SIGNATURE_HOTSPOTY)) = 0;
    
    /* set pattern offset */
    ulPatternAddr = ((pAST->HWCInfo.ulHWCOffsetAddr+(HWC_SIZE+HWC_SIGNATURE_SIZE)*pAST->HWCInfo.HWC_NUM_Next) >> 3);
    SetIndexReg(CRTC_PORT, 0xC8, (UCHAR) (ulPatternAddr & 0xFF)); 	
    SetIndexReg(CRTC_PORT, 0xC9, (UCHAR) ((ulPatternAddr >> 8) & 0xFF)); 	
    SetIndexReg(CRTC_PORT, 0xCA, (UCHAR) ((ulPatternAddr >> 16) & 0xFF)); 
    
d316 1
a316 1
        	    
d319 1
a319 1
static Bool 
d324 1
a324 1
        
d331 1
a331 1
    ASTRecPtr 	pAST = ASTPTR(pScrn);   
d335 1
a335 1
    ULONG	ulPerPixelCopy, ulTwoPixelCopy;    
d341 1
a341 1
    } ulSrcData32[2], ulData32;    
d347 1
a347 1
    ULONG	ulCheckSum = 0;  		           
d349 1
a349 1
 
d356 1
a356 1
    
d358 3
a360 3
    ulSrcWidth  =  pAST->HWCInfo.width;  
    ulSrcHeight =  pAST->HWCInfo.height;  
        
d367 1
a367 1
    
d370 1
a370 1
                   
d381 1
a381 1
            ulData32.b[3] = ulSrcData32[1].b[3] | (ulSrcData32[1].b[2] >> 4);                     
d383 1
a383 1
            ulCheckSum += (ULONG) ulData32.ul;                                     
d386 2
a387 2
        } 
        
d394 1
a394 1
            ulCheckSum += (ULONG) usData16.us;                                                 
d397 1
a397 1
        } 
d401 1
a401 1
        
d404 22
a425 14
    /* Write Checksum as signature */
    pjDstXor = (UCHAR *) pAST->HWCInfo.pjHWCVirtualAddr + (HWC_SIZE+HWC_SIGNATURE_SIZE)*pAST->HWCInfo.HWC_NUM_Next + HWC_SIZE;   
    *((ULONG *) pjDstXor) = ulCheckSum;
    *((ULONG *) (pjDstXor + HWC_SIGNATURE_SizeX)) = pAST->HWCInfo.width;
    *((ULONG *) (pjDstXor + HWC_SIGNATURE_SizeY)) = pAST->HWCInfo.height;
    *((ULONG *) (pjDstXor + HWC_SIGNATURE_HOTSPOTX)) = 0;
    *((ULONG *) (pjDstXor + HWC_SIGNATURE_HOTSPOTY)) = 0;
           
    /* set pattern offset */
    ulPatternAddr = ((pAST->HWCInfo.ulHWCOffsetAddr +(HWC_SIZE+HWC_SIGNATURE_SIZE)*pAST->HWCInfo.HWC_NUM_Next) >> 3);
    SetIndexReg(CRTC_PORT, 0xC8, (UCHAR) (ulPatternAddr & 0xFF)); 	
    SetIndexReg(CRTC_PORT, 0xC9, (UCHAR) ((ulPatternAddr >> 8) & 0xFF)); 	
    SetIndexReg(CRTC_PORT, 0xCA, (UCHAR) ((ulPatternAddr >> 16) & 0xFF)); 
    
d428 1
a428 1
    
d431 1
a431 1
static Bool 
d436 1
a436 1
        
d444 3
a446 3
    
    SetIndexRegMask(CRTC_PORT, 0xCB, 0xFF, 0x00);	/* dummp write to fire HWC */ 	
    
d448 67
@


1.5
log
@Update to xf86-video-ast 0.89.9
@
text
@@


1.4
log
@update to xf86-video-ast 0.89.0
@
text
@a27 2
#include "xf86Resources.h"
#include "xf86RAC.h"
d201 4
a204 3
    
    pAST->HWCInfo.fg = (fg & 0x0F) | (((fg>>8) & 0x0F) << 4) | (((fg>>16) & 0x0F) << 8);
    pAST->HWCInfo.bg = (bg & 0x0F) | (((bg>>8) & 0x0F) << 4) | (((bg>>16) & 0x0F) << 8);    
d206 7
a212 2
    /* Fixed xorg bugzilla #20609, ycchen@@031209 */    
    ASTLoadCursorImage(pScrn, pAST->HWCInfo.cursorpattern);
d237 1
a237 1

a256 1
                ulTempDstData32[1] = ((jTempSrcXor32 >> (k-1)) & 0x01) ? (pAST->HWCInfo.fg << 16):(pAST->HWCInfo.bg << 16);               
d261 1
a261 1
                    ulTempDstXor32[1] = 0;                
@


1.3
log
@update to xf86-video-ast 0.88.8
@
text
@d206 4
d229 4
@


1.2
log
@xf86-video-ast 0.85.0
@
text
@d245 6
d285 3
d389 3
@


1.1
log
@Initial revision
@
text
@d65 1
a65 1
static void ASTHideCursor(ScrnInfoPtr pScrn);
d149 1
a149 1
static void
d238 2
a239 2
                jTempSrcXor32 = *((UCHAR *) pjSrcXor);   
                ulTempDstAnd32[0] = ((jTempSrcAnd32 >> k) & 0x01) ? 0x00008000L:0x00L;   
@


1.1.1.1
log
@Importing xf86-video-ast 0.81.0
@
text
@@


1.1.1.2
log
@Re-import xf86-video-ast.
This chipset is found in HP Proliant MicroServer remote access cards
among others. ok kettenis, seems like a good idea to jasper@@.
@
text
@d28 2
d32 1
d41 1
d50 1
d64 1
a64 2
void ASTDisableHWC(ScrnInfoPtr pScrn);
static void ASTShowCursor(ScrnInfoPtr pScrn);
d72 2
a73 4
static void ASTFireCursor(ScrnInfoPtr pScrn);
static void ASTShowCursor_AST1180(ScrnInfoPtr pScrn);
static void ASTHideCursor_AST1180(ScrnInfoPtr pScrn);
static void ASTSetCursorPosition_AST1180(ScrnInfoPtr pScrn, int x, int y);
d78 1
a78 1
    ScrnInfoPtr	pScrn = xf86ScreenToScrn(pScreen);
d88 1
a88 1
                     HARDWARE_CURSOR_INVERT_MASK |
d93 3
a95 12
    if (pAST->jChipType == AST1180)
    {
        infoPtr->ShowCursor = ASTShowCursor_AST1180;
        infoPtr->HideCursor = ASTHideCursor_AST1180;
        infoPtr->SetCursorPosition = ASTSetCursorPosition_AST1180;
    }
    else
    {
        infoPtr->ShowCursor = ASTShowCursor;
        infoPtr->HideCursor = ASTHideCursor;
        infoPtr->SetCursorPosition = ASTSetCursorPosition;
    }
d105 1
a105 1

d113 1
a113 1
    /* Set HWC_NUM in Options instead */
d115 5
a119 5
    pAST->HWCInfo.HWC_NUM_Next = 0;

    /* allocate HWC cache */
    if (!pAST->pHWCPtr) {
        pScreen = xf86ScrnToScreen(pScrn);
d122 1
a122 1
        if (!pAST->pHWCPtr) {
d126 1
a126 1

d128 1
a128 1
        pAST->HWCInfo.pjHWCVirtualAddr = pAST->FBVirtualAddr + pAST->HWCInfo.ulHWCOffsetAddr;
d131 1
a131 1
    return (TRUE);
a133 9
void ASTDisableHWC(ScrnInfoPtr pScrn)
{
    ASTRecPtr   pAST = ASTPTR(pScrn);

    if (pAST->jChipType == AST1180)
        ASTHideCursor_AST1180(pScrn);
    else
        ASTHideCursor(pScrn);
}
d138 1
a138 1
    ASTRecPtr   pAST = ASTPTR(pScrn);
d144 3
a146 3

    SetIndexRegMask(CRTC_PORT, 0xCB, 0xFC, jReg);	/* enable mono */

d153 3
a155 3

    SetIndexRegMask(CRTC_PORT, 0xCB, 0xFC, 0x00);	/* disable HWC */

d162 1
a162 1
    DisplayModePtr mode = pAST->ModePtr;
d164 4
a167 4
    UCHAR 	*pjSignature;

    /* Set cursor info to Offscreen */
    pjSignature = (UCHAR *) pAST->HWCInfo.pjHWCVirtualAddr + (HWC_SIZE+HWC_SIGNATURE_SIZE)*pAST->HWCInfo.HWC_NUM_Next + HWC_SIZE;
d170 1
a170 1

d173 1
a173 1

d185 1
a185 1

d187 7
a193 7
    SetIndexReg(CRTC_PORT, 0xC2, (UCHAR) (x_offset));
    SetIndexReg(CRTC_PORT, 0xC3, (UCHAR) (y_offset));
    SetIndexReg(CRTC_PORT, 0xC4, (UCHAR) (x & 0xFF));
    SetIndexReg(CRTC_PORT, 0xC5, (UCHAR) ((x >> 8) & 0x0F));
    SetIndexReg(CRTC_PORT, 0xC6, (UCHAR) (y & 0xFF));
    SetIndexReg(CRTC_PORT, 0xC7, (UCHAR) ((y >> 8) & 0x07));

d196 2
a197 2

}
d203 3
a205 13
    ULONG fg1, bg1;

    fg1 = (fg & 0x0F) | (((fg>>8) & 0x0F) << 4) | (((fg>>16) & 0x0F) << 8);
    bg1 = (bg & 0x0F) | (((bg>>8) & 0x0F) << 4) | (((bg>>16) & 0x0F) << 8);

    /* Fixed xorg bugzilla #20609, ycchen@@031209 */
    if ( (fg1 != pAST->HWCInfo.fg) || (bg1 != pAST->HWCInfo.bg) )
    {
    	pAST->HWCInfo.fg = fg1;
    	pAST->HWCInfo.bg = bg1;
        ASTLoadCursorImage(pScrn, pAST->HWCInfo.cursorpattern);
    }

d211 1
a211 1
    ASTRecPtr	pAST = ASTPTR(pScrn);
d216 3
a218 3
    ULONG	ulCheckSum = 0;
    ULONG 	ulPatternAddr;

a225 4
    /* copy to hwc info */
    for (i=0; i< MAX_HWC_WIDTH*MAX_HWC_HEIGHT/4; i+=4)
       *(ULONG *) (pAST->HWCInfo.cursorpattern + i) = *(ULONG *) (src + i);

d230 1
a230 1

d238 6
a243 6
                jTempSrcXor32 = *((UCHAR *) pjSrcXor);
                ulTempDstAnd32[0] = ((jTempSrcAnd32 >> k) & 0x01) ? 0x00008000L:0x00L;
                ulTempDstXor32[0] = ((jTempSrcXor32 >> k) & 0x01) ? 0x00004000L:0x00L;
                ulTempDstData32[0] = ((jTempSrcXor32 >> k) & 0x01) ? pAST->HWCInfo.fg:pAST->HWCInfo.bg;
                ulTempDstAnd32[1] = ((jTempSrcAnd32 >> (k-1)) & 0x01) ? 0x80000000L:0x00L;
                ulTempDstXor32[1] = ((jTempSrcXor32 >> (k-1)) & 0x01) ? 0x40000000L:0x00L;
a244 5
                /* No inverse for X Window cursor, ycchen@@111808 */
                if (ulTempDstAnd32[0])
                    ulTempDstXor32[0] = 0;
                if (ulTempDstAnd32[1])
                    ulTempDstXor32[1] = 0;
d246 1
a246 1
                ulCheckSum += *((ULONG *) pjDstData);
d252 19
a270 27

       }

    }

    if (pAST->jChipType == AST1180)
    {
        ulPatternAddr = pAST->ulVRAMBase + (pAST->HWCInfo.ulHWCOffsetAddr+(HWC_SIZE+HWC_SIGNATURE_SIZE)*pAST->HWCInfo.HWC_NUM_Next);
        WriteAST1180SOC(AST1180_GFX_BASE+AST1180_HWC1_PATTERNADDR, ulPatternAddr);
    }
    else
    {
        /* Write Checksum as signature */
        pjDstData = (UCHAR *) pAST->HWCInfo.pjHWCVirtualAddr + (HWC_SIZE+HWC_SIGNATURE_SIZE)*pAST->HWCInfo.HWC_NUM_Next + HWC_SIZE;
        *((ULONG *) pjDstData) = ulCheckSum;
        *((ULONG *) (pjDstData + HWC_SIGNATURE_SizeX)) = pAST->HWCInfo.width;
        *((ULONG *) (pjDstData + HWC_SIGNATURE_SizeY)) = pAST->HWCInfo.height;
        *((ULONG *) (pjDstData + HWC_SIGNATURE_HOTSPOTX)) = 0;
        *((ULONG *) (pjDstData + HWC_SIGNATURE_HOTSPOTY)) = 0;

        /* set pattern offset */
        ulPatternAddr = ((pAST->HWCInfo.ulHWCOffsetAddr+(HWC_SIZE+HWC_SIGNATURE_SIZE)*pAST->HWCInfo.HWC_NUM_Next) >> 3);
        SetIndexReg(CRTC_PORT, 0xC8, (UCHAR) (ulPatternAddr & 0xFF));
        SetIndexReg(CRTC_PORT, 0xC9, (UCHAR) ((ulPatternAddr >> 8) & 0xFF));
        SetIndexReg(CRTC_PORT, 0xCA, (UCHAR) ((ulPatternAddr >> 16) & 0xFF));
    }

d273 1
a273 1

d276 1
a276 1
static Bool
a278 3
    if ( (pCurs->bits->width > MAX_HWC_WIDTH) || (pCurs->bits->height > MAX_HWC_HEIGHT) )
        return FALSE;

d285 1
a285 1
    ASTRecPtr 	pAST = ASTPTR(pScrn);
d289 1
a289 1
    ULONG	ulPerPixelCopy, ulTwoPixelCopy;
d295 1
a295 1
    } ulSrcData32[2], ulData32;
d301 1
a301 1
    ULONG	ulCheckSum = 0;
d303 1
a303 1

d310 1
a310 1

d312 3
a314 3
    ulSrcWidth  =  pAST->HWCInfo.width;
    ulSrcHeight =  pAST->HWCInfo.height;

d321 1
a321 1

d324 1
a324 1

d335 1
a335 1
            ulData32.b[3] = ulSrcData32[1].b[3] | (ulSrcData32[1].b[2] >> 4);
d337 1
a337 1
            ulCheckSum += (ULONG) ulData32.ul;
d340 2
a341 2
        }

d348 1
a348 1
            ulCheckSum += (ULONG) usData16.us;
d351 1
a351 1
        }
d355 1
a355 1

d358 14
a371 22
    if (pAST->jChipType == AST1180)
    {
        ulPatternAddr = pAST->ulVRAMBase + (pAST->HWCInfo.ulHWCOffsetAddr+(HWC_SIZE+HWC_SIGNATURE_SIZE)*pAST->HWCInfo.HWC_NUM_Next);
        WriteAST1180SOC(AST1180_GFX_BASE+AST1180_HWC1_PATTERNADDR, ulPatternAddr);
    }
    else
    {
        /* Write Checksum as signature */
        pjDstXor = (UCHAR *) pAST->HWCInfo.pjHWCVirtualAddr + (HWC_SIZE+HWC_SIGNATURE_SIZE)*pAST->HWCInfo.HWC_NUM_Next + HWC_SIZE;
        *((ULONG *) pjDstXor) = ulCheckSum;
        *((ULONG *) (pjDstXor + HWC_SIGNATURE_SizeX)) = pAST->HWCInfo.width;
        *((ULONG *) (pjDstXor + HWC_SIGNATURE_SizeY)) = pAST->HWCInfo.height;
        *((ULONG *) (pjDstXor + HWC_SIGNATURE_HOTSPOTX)) = 0;
        *((ULONG *) (pjDstXor + HWC_SIGNATURE_HOTSPOTY)) = 0;

        /* set pattern offset */
        ulPatternAddr = ((pAST->HWCInfo.ulHWCOffsetAddr +(HWC_SIZE+HWC_SIGNATURE_SIZE)*pAST->HWCInfo.HWC_NUM_Next) >> 3);
        SetIndexReg(CRTC_PORT, 0xC8, (UCHAR) (ulPatternAddr & 0xFF));
        SetIndexReg(CRTC_PORT, 0xC9, (UCHAR) ((ulPatternAddr >> 8) & 0xFF));
        SetIndexReg(CRTC_PORT, 0xCA, (UCHAR) ((ulPatternAddr >> 16) & 0xFF));
    }

d374 1
a374 1

d377 1
a377 1
static Bool
a379 3
    if ( (pCurs->bits->width > MAX_HWC_WIDTH) || (pCurs->bits->height > MAX_HWC_HEIGHT) )
        return FALSE;

d387 3
a389 3

    SetIndexRegMask(CRTC_PORT, 0xCB, 0xFF, 0x00);	/* dummp write to fire HWC */

a390 67

/* AST1180 */
static void
ASTShowCursor_AST1180(ScrnInfoPtr pScrn)
{
    ASTRecPtr   pAST = ASTPTR(pScrn);
    ULONG 	ulData, ulTemp;

    ReadAST1180SOC(AST1180_GFX_BASE+AST1180_HWC1_POSITION, ulTemp);

    ReadAST1180SOC(AST1180_GFX_BASE+AST1180_VGA1_CTRL, ulData);
    ulData &= ~AST1180_ALPHAHWC;
    if (pAST->HWCInfo.cursortype ==HWC_COLOR)
        ulData |= AST1180_ALPHAHWC;
    ulData |= AST1180_ENABLEHWC;
    WriteAST1180SOC(AST1180_GFX_BASE+AST1180_VGA1_CTRL, ulData);

    /* fire cursor */
    WriteAST1180SOC(AST1180_GFX_BASE+AST1180_HWC1_POSITION, ulTemp);

} /* ASTShowCursor_AST1180 */

static void
ASTHideCursor_AST1180(ScrnInfoPtr pScrn)
{
    ASTRecPtr  pAST = ASTPTR(pScrn);
    ULONG 	ulData;

    ReadAST1180SOC(AST1180_GFX_BASE+AST1180_VGA1_CTRL, ulData);
    ulData &= ~AST1180_ENABLEHWC;
    WriteAST1180SOC(AST1180_GFX_BASE+AST1180_VGA1_CTRL, ulData);

    /* fire cursor */
    WriteAST1180SOC(AST1180_GFX_BASE+AST1180_HWC1_POSITION, 0x07ff07ff);

} /* ASTHideCursor_AST1180 */

static void
ASTSetCursorPosition_AST1180(ScrnInfoPtr pScrn, int x, int y)
{
    ASTRecPtr	pAST = ASTPTR(pScrn);
    DisplayModePtr mode = pAST->ModePtr;
    int		x_offset, y_offset;
    ULONG	ulData;

    x_offset = pAST->HWCInfo.offset_x;
    y_offset = pAST->HWCInfo.offset_y;

    if(x < 0) {
       x_offset = (-x) + pAST->HWCInfo.offset_x;
       x = 0;
    }

    if(y < 0) {
       y_offset = (-y) + pAST->HWCInfo.offset_y;
       y = 0;
    }

    if(mode->Flags & V_DBLSCAN)  y *= 2;

    /* Set to Reg. */
    ulData = (x_offset) | (y_offset << 8);
    WriteAST1180SOC(AST1180_GFX_BASE+AST1180_HWC1_OFFSET, ulData);
    ulData = (x) | (y << 16);
    WriteAST1180SOC(AST1180_GFX_BASE+AST1180_HWC1_POSITION, ulData);

} /* ASTSetCursorPosition_AST1180 */
@

