head	1.8;
access;
symbols
	OPENBSD_6_1:1.8.0.8
	OPENBSD_6_1_BASE:1.8
	OPENBSD_6_0:1.8.0.6
	OPENBSD_6_0_BASE:1.8
	OPENBSD_5_9:1.8.0.4
	OPENBSD_5_9_BASE:1.8
	OPENBSD_5_8:1.8.0.2
	OPENBSD_5_8_BASE:1.8
	OPENBSD_5_7:1.7.0.4
	OPENBSD_5_7_BASE:1.7
	OPENBSD_5_6:1.7.0.2
	OPENBSD_5_6_BASE:1.7
	v0_99_9:1.1.1.2
	OPENBSD_4_8:1.4.0.6
	OPENBSD_4_8_BASE:1.4
	OPENBSD_4_7:1.4.0.2
	OPENBSD_4_7_BASE:1.4
	OPENBSD_4_6:1.3.0.2
	OPENBSD_4_6_BASE:1.3
	OPENBSD_4_5:1.2.0.2
	OPENBSD_4_5_BASE:1.2
	OPENBSD_4_4:1.1.1.1.0.6
	OPENBSD_4_4_BASE:1.1.1.1
	OPENBSD_4_3_BASE:1.1.1.1
	OPENBSD_4_3:1.1.1.1.0.4
	OPENBSD_4_2:1.1.1.1.0.2
	OPENBSD_4_2_BASE:1.1.1.1
	v0_81_0:1.1.1.1
	xorg:1.1.1;
locks; strict;
comment	@ * @;


1.8
date	2015.05.24.09.17.25;	author matthieu;	state Exp;
branches;
next	1.7;
commitid	qBZygjuSMc2gFczl;

1.7
date	2014.04.13.10.36.51;	author matthieu;	state Exp;
branches;
next	1.6;

1.6
date	2010.11.29.21.17.47;	author matthieu;	state dead;
branches;
next	1.5;

1.5
date	2010.11.25.22.03.22;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2009.11.22.15.33.58;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2009.03.07.11.16.36;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2008.08.23.21.00.47;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.26.20.00.10;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.11.26.20.00.10;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2014.04.13.10.30.12;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.8
log
@Update to xf86-video-ast 1.0.1
@
text
@/*
 * Copyright (c) 2005 ASPEED Technology Inc.
 *
 * Permission to use, copy, modify, distribute, and sell this software and its
 * documentation for any purpose is hereby granted without fee, provided that
 * the above copyright notice appear in all copies and that both that
 * copyright notice and this permission notice appear in supporting
 * documentation, and that the name of the authors not be used in
 * advertising or publicity pertaining to distribution of the software without
 * specific, written prior permission.  The authors makes no representations
 * about the suitability of this software for any purpose.  It is provided
 * "as is" without express or implied warranty.
 *
 * THE AUTHORS DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
 * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO
 * EVENT SHALL THE AUTHORS BE LIABLE FOR ANY SPECIAL, INDIRECT OR
 * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
 * DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
 * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
 * PERFORMANCE OF THIS SOFTWARE.
 */

#ifdef HAVE_CONFIG_H
#include <config.h>
#endif
#include "xf86.h"
#include "xf86_OSproc.h"
#include "xf86cmap.h"
#include "compiler.h"
#include "vgaHW.h"
#include "mipointer.h"
#include "micmap.h"

#include "fb.h"
#include "regionstr.h"
#include "xf86xv.h"
#include <X11/extensions/Xv.h>

#include "xf86Pci.h"

/* framebuffer offscreen manager */
#include "xf86fbman.h"

#include "xaarop.h"

/* H/W cursor support */
#include "xf86Cursor.h"

/* Driver specific headers */
#include "ast.h"
#include "ast_vgatool.h"
#include "ast_2dtool.h"

#ifdef	Accel_2D
typedef Bool (*PFN_bENABLE_CMDQ)(ScrnInfoPtr , ASTRecPtr);

/* Prototype type declaration */

static Bool
bInitCMDQInfo(ScrnInfoPtr pScrn, ASTRecPtr pAST)
{

    ScreenPtr pScreen;

    /* CMDQ mode Init */
    if (!pAST->MMIO2D) {
        pAST->CMDQInfo.ulCMDQType = VM_CMD_QUEUE;

        pScreen = xf86ScrnToScreen(pScrn);

        do {
            pAST->pCMDQPtr = xf86AllocateOffscreenLinear (pScreen, pAST->CMDQInfo.ulCMDQSize, 8, NULL, NULL, NULL);

            if (pAST->pCMDQPtr) break;

            pAST->CMDQInfo.ulCMDQSize >>= 1;

        } while (pAST->CMDQInfo.ulCMDQSize >= MIN_CMDQ_SIZE);

        if (pAST->pCMDQPtr)
        {
           xf86DrvMsg(pScrn->scrnIndex, X_INFO,"Allocate CMDQ size is %ld kbyte \n", (unsigned long) (pAST->CMDQInfo.ulCMDQSize/1024));

           pAST->CMDQInfo.ulCMDQOffsetAddr  = pAST->pCMDQPtr->offset*((pScrn->bitsPerPixel + 1) / 8);
           pAST->CMDQInfo.pjCMDQVirtualAddr = pAST->FBVirtualAddr + pAST->CMDQInfo.ulCMDQOffsetAddr;

           pAST->CMDQInfo.ulCurCMDQueueLen = pAST->CMDQInfo.ulCMDQSize - CMD_QUEUE_GUARD_BAND;
           pAST->CMDQInfo.ulCMDQMask = pAST->CMDQInfo.ulCMDQSize - 1 ;

        }
        else
        {
           xf86DrvMsg(pScrn->scrnIndex, X_ERROR,"Allocate CMDQ failed \n");
           pAST->MMIO2D = TRUE;		/* set to MMIO mode if CMDQ allocate failed */
        }

    }

    /* MMIO mode init */
    if (pAST->MMIO2D) {
        pAST->CMDQInfo.ulCMDQType = VM_CMD_MMIO;
    }

    return (TRUE);
}

static Bool
bEnableCMDQ(ScrnInfoPtr pScrn, ASTRecPtr pAST)
{
    ULONG ulVMCmdQBasePort = 0;

    vASTWaitEngIdle(pScrn, pAST);

    /* set DBG Select Info */
    if (pAST->DBGSelect)
    {
        *(ULONG *) (pAST->MMIOVirtualAddr + 0x804C) = (ULONG) (pAST->DBGSelect);
    }

    /* set CMDQ base */
    switch (pAST->CMDQInfo.ulCMDQType)
    {
    case VM_CMD_QUEUE:
        ulVMCmdQBasePort  = (pAST->CMDQInfo.ulCMDQOffsetAddr - 0) >> 3;

        /* set CMDQ Threshold */
        ulVMCmdQBasePort |= 0xF0000000;

        /* set CMDQ Size */
        switch (pAST->CMDQInfo.ulCMDQSize)
        {
        case CMD_QUEUE_SIZE_256K:
            ulVMCmdQBasePort |= 0x00000000;
            break;

        case CMD_QUEUE_SIZE_512K:
            ulVMCmdQBasePort |= 0x04000000;
            break;

        case CMD_QUEUE_SIZE_1M:
            ulVMCmdQBasePort |= 0x08000000;
            break;

        case CMD_QUEUE_SIZE_2M:
            ulVMCmdQBasePort |= 0x0C000000;
            break;

        default:
            return(FALSE);
            break;
        }

        *(ULONG *) (pAST->CMDQInfo.pjCmdQBasePort) = ulVMCmdQBasePort;
        pAST->CMDQInfo.ulWritePointer = *(ULONG *) (pAST->CMDQInfo.pjWritePort) << 3;
        break;

    case VM_CMD_MMIO:
        /* set CMDQ Threshold */
        ulVMCmdQBasePort |= 0xF0000000;

        ulVMCmdQBasePort |= 0x02000000;			/* MMIO mode */
        *(ULONG *) (pAST->CMDQInfo.pjCmdQBasePort) = ulVMCmdQBasePort;
        break;

    default:
        return (FALSE);
        break;
    }

    return (TRUE);
}

static Bool
bEnableCMDQ2300(ScrnInfoPtr pScrn, ASTRecPtr pAST)
{
    ULONG ulVMCmdQBasePort = 0, ulNewModeData;

    vASTWaitEngIdle(pScrn, pAST);

    /* set DBG Select Info */
    if (pAST->DBGSelect)
    {
        *(ULONG *) (pAST->MMIOVirtualAddr + 0x804C) = (ULONG) (pAST->DBGSelect);
    }

    /* set CMDQ base */
    switch (pAST->CMDQInfo.ulCMDQType)
    {
    case VM_CMD_QUEUE:
        /* enable new CMDQ mode */
        ulNewModeData = 0xc00000f0;
        /* set CMDQ Size */
        switch (pAST->CMDQInfo.ulCMDQSize)
        {
        case CMD_QUEUE_SIZE_256K:
            ulNewModeData |= 0x00000000;
            break;

        case CMD_QUEUE_SIZE_512K:
            ulNewModeData |= 0x00000004;
            break;

        case CMD_QUEUE_SIZE_1M:
            ulNewModeData |= 0x00000008;
            break;

        case CMD_QUEUE_SIZE_2M:
            ulNewModeData |= 0x0000000C;
            break;

        default:
            return(FALSE);
            break;
        }
        *(ULONG *) (pAST->MMIOVirtualAddr + 0x8060) = ulNewModeData;

        /* Set CMDQ Base */
        ulVMCmdQBasePort  = (pAST->CMDQInfo.ulCMDQOffsetAddr - 0) >> 3;
        *(ULONG *) (pAST->CMDQInfo.pjCmdQBasePort) = ulVMCmdQBasePort;
        pAST->CMDQInfo.ulWritePointer = *(ULONG *) (pAST->CMDQInfo.pjWritePort) << 3;
        break;

    case VM_CMD_MMIO:
        /* enable new CMDQ mode */
        ulNewModeData = 0xc00000f2;
        *(ULONG *) (pAST->MMIOVirtualAddr + 0x8060) = ulNewModeData;
        break;

    default:
        return (FALSE);
        break;
    }

    return (TRUE);

} /* bEnableCMDQ2300 */

Bool
bASTEnable2D(ScrnInfoPtr pScrn, ASTRecPtr pAST)
{
    ULONG ulData;
    PFN_bENABLE_CMDQ pfnEnableCMDQ = bEnableCMDQ;

    if ( (pAST->jChipType == AST2300) || (pAST->jChipType == AST2400) )
        pfnEnableCMDQ = bEnableCMDQ2300;

    switch (pAST->jChipType)
    {
    case AST2100:
    case AST1100:
    case AST2200:
    case AST2150:
    case AST2300:
    case AST2400:
       *(ULONG *) (pAST->MMIOVirtualAddr + 0xF004) = 0x1e6e0000;
       *(ULONG *) (pAST->MMIOVirtualAddr + 0xF000) = 0x1;

       ulData = *(ULONG *) (pAST->MMIOVirtualAddr + 0x1200c);
       *(ULONG *) (pAST->MMIOVirtualAddr + 0x1200c) = (ulData & 0xFFFFFFFD);

    case AST2000:
       SetIndexRegMask(CRTC_PORT, 0xA4, 0xFE, 0x01);		/* enable 2D */

       break;
    }

    if (!bInitCMDQInfo(pScrn, pAST))
    {
        vASTDisable2D(pScrn, pAST);
    	return (FALSE);
    }

    if (!pfnEnableCMDQ(pScrn, pAST))
    {
        vASTDisable2D(pScrn, pAST);
    	return (FALSE);
    }

    return (TRUE);
}

void
vASTDisable2D(ScrnInfoPtr pScrn, ASTRecPtr pAST)
{

    vASTWaitEngIdle(pScrn, pAST);
    vASTWaitEngIdle(pScrn, pAST);

    /* restore 2D settings */
    if (pAST->jChipType != AST1180)
    {
        if (pAST->SavedReg.REGA4 & 0x01)	/* 2D enabled */
        {
            SetIndexRegMask(CRTC_PORT, 0xA4, 0xFE, 0x01);
            *(ULONG *) (pAST->MMIOVirtualAddr + 0x8044) = pAST->SavedReg.ENG8044;
        }
        else								/* 2D disabled */
        {
            SetIndexRegMask(CRTC_PORT, 0xA4, 0xFE, 0x00);
        }
    }
}


void
vASTWaitEngIdle(ScrnInfoPtr pScrn, ASTRecPtr pAST)
{
    ULONG ulEngState, ulEngState2;
    UCHAR jReg;
    ULONG ulEngCheckSetting = 0x80000000;

    if (pAST->jChipType != AST1180)
    {

        /* 2D disable if 0xA4 D[0] = 1 */
        GetIndexRegMask(CRTC_PORT, 0xA4, 0x01, jReg);
        if (!jReg) goto Exit_vASTWaitEngIdle;

        /* 2D not work if in std. mode */
        GetIndexRegMask(CRTC_PORT, 0xA3, 0x0F, jReg);
        if (!jReg) goto Exit_vASTWaitEngIdle;
    }

    if (*(ULONG *) (pAST->CMDQInfo.pjCmdQBasePort) & 0x02000000)	/* MMIO Mode */
        ulEngCheckSetting = 0x10000000;

    do
    {
        ulEngState = (*(volatile ULONG *)(pAST->CMDQInfo.pjEngStatePort)) & 0xFFFC0000;
        ulEngState2 = (*(volatile ULONG *)(pAST->CMDQInfo.pjEngStatePort)) & 0xFFFC0000;
        ulEngState2 = (*(volatile ULONG *)(pAST->CMDQInfo.pjEngStatePort)) & 0xFFFC0000;
        ulEngState2 = (*(volatile ULONG *)(pAST->CMDQInfo.pjEngStatePort)) & 0xFFFC0000;
        ulEngState2 = (*(volatile ULONG *)(pAST->CMDQInfo.pjEngStatePort)) & 0xFFFC0000;
        ulEngState2 = (*(volatile ULONG *)(pAST->CMDQInfo.pjEngStatePort)) & 0xFFFC0000;

    } while ((ulEngState & ulEngCheckSetting) || (ulEngState != ulEngState2));

Exit_vASTWaitEngIdle:
    ;
}

/* ULONG ulGetCMDQLength() */
static __inline ULONG ulGetCMDQLength(ASTRecPtr pAST, ULONG ulWritePointer, ULONG ulCMDQMask)
{
    ULONG ulReadPointer, ulReadPointer2;

    do {
	ulReadPointer  = *((volatile ULONG *)(pAST->CMDQInfo.pjReadPort));
	ulReadPointer2 = *((volatile ULONG *)(pAST->CMDQInfo.pjReadPort));
	ulReadPointer2 = *((volatile ULONG *)(pAST->CMDQInfo.pjReadPort));
	ulReadPointer2 = *((volatile ULONG *)(pAST->CMDQInfo.pjReadPort));
	ulReadPointer2 = *((volatile ULONG *)(pAST->CMDQInfo.pjReadPort));
	ulReadPointer2 = *((volatile ULONG *)(pAST->CMDQInfo.pjReadPort));
     } while ( ((ulReadPointer & 0x0003FFFF) != (ulReadPointer2 & 0x0003FFFF)) || (ulReadPointer == 0xFFFFEEEE) );

    return ((ulReadPointer << 3) - ulWritePointer - CMD_QUEUE_GUARD_BAND) & ulCMDQMask;
}

UCHAR *pASTjRequestCMDQ(
ASTRecPtr pAST, ULONG   ulDataLen)
{
    UCHAR   *pjBuffer;
    ULONG   i, ulWritePointer, ulCMDQMask, ulCurCMDQLen, ulContinueCMDQLen;

    ulWritePointer = pAST->CMDQInfo.ulWritePointer;
    ulContinueCMDQLen = pAST->CMDQInfo.ulCMDQSize - ulWritePointer;
    ulCMDQMask = pAST->CMDQInfo.ulCMDQMask;

    if (ulContinueCMDQLen >= ulDataLen)
    {
        /* Get CMDQ Buffer */
        if (pAST->CMDQInfo.ulCurCMDQueueLen >= ulDataLen)
        {
        	;
        }
        else
        {

            do
            {
                ulCurCMDQLen = ulGetCMDQLength(pAST, ulWritePointer, ulCMDQMask);
            } while (ulCurCMDQLen < ulDataLen);

            pAST->CMDQInfo.ulCurCMDQueueLen = ulCurCMDQLen;

        }

        pjBuffer = pAST->CMDQInfo.pjCMDQVirtualAddr + ulWritePointer;
        pAST->CMDQInfo.ulCurCMDQueueLen -= ulDataLen;
        pAST->CMDQInfo.ulWritePointer = (ulWritePointer + ulDataLen) & ulCMDQMask;
        return pjBuffer;
    }
    else
    {

        /* Fill NULL CMD to the last of the CMDQ */
        if (pAST->CMDQInfo.ulCurCMDQueueLen >= ulContinueCMDQLen)
        {
        	;
        }
        else
        {

            do
            {
                ulCurCMDQLen = ulGetCMDQLength(pAST, ulWritePointer, ulCMDQMask);
            } while (ulCurCMDQLen < ulContinueCMDQLen);

            pAST->CMDQInfo.ulCurCMDQueueLen = ulCurCMDQLen;

        }

        pjBuffer = pAST->CMDQInfo.pjCMDQVirtualAddr + ulWritePointer;
        for (i = 0; i<ulContinueCMDQLen/8; i++, pjBuffer+=8)
        {
            *(ULONG *)pjBuffer = (ULONG) PKT_NULL_CMD;
            *(ULONG *) (pjBuffer+4) = 0;

        }
        pAST->CMDQInfo.ulCurCMDQueueLen -= ulContinueCMDQLen;
        pAST->CMDQInfo.ulWritePointer = ulWritePointer = 0;

        /* Get CMDQ Buffer */
        if (pAST->CMDQInfo.ulCurCMDQueueLen >= ulDataLen)
        {
	        ;
        }
        else
        {

            do
            {
                ulCurCMDQLen = ulGetCMDQLength(pAST, ulWritePointer, ulCMDQMask);
            } while (ulCurCMDQLen < ulDataLen);

            pAST->CMDQInfo.ulCurCMDQueueLen = ulCurCMDQLen;

        }

        pAST->CMDQInfo.ulCurCMDQueueLen -= ulDataLen;
        pjBuffer = pAST->CMDQInfo.pjCMDQVirtualAddr + ulWritePointer;
        pAST->CMDQInfo.ulWritePointer = (ulWritePointer + ulDataLen) & ulCMDQMask;
        return pjBuffer;

    }

} /* end of pjRequestCmdQ() */

Bool bASTGetLineTerm(_LINEInfo *LineInfo, LINEPARAM *dsLineParam)
{
    LONG GAbsX, GAbsY, GXInc, GYInc, GXMajor;
    LONG MM, mm, Error0, K1, K2;

    /* Init */
#ifdef LONG64
    GAbsX = abs (LineInfo->X1 - LineInfo->X2);
    GAbsY = abs (LineInfo->Y1 - LineInfo->Y2);
#else
    GAbsX = labs (LineInfo->X1 - LineInfo->X2);
    GAbsY = labs (LineInfo->Y1 - LineInfo->Y2);
#endif

    GXInc = (LineInfo->X1 < LineInfo->X2) ? 1:0;
    GYInc = (LineInfo->Y1 < LineInfo->Y2) ? 1:0;
    GXMajor = (GAbsX >= GAbsY) ? 1:0;

    /* Calculate */
    if (GXMajor)
    {
        MM = GAbsX;
        mm = GAbsY;
    }
    else
    {
        MM = GAbsY;
        mm = GAbsX;
    }

    Error0 = (signed) (2*mm - MM);

    K1 = 2* mm;
    K2 = (signed) (2*mm - 2*MM);

    /*save the Param to dsLineParam */
    dsLineParam->dsLineX = (USHORT) LineInfo->X1;
    dsLineParam->dsLineY = (USHORT) LineInfo->Y1;
    dsLineParam->dsLineWidth = (USHORT) MM;
    dsLineParam->dwErrorTerm = (ULONG) Error0;
    dsLineParam->dwK1Term = K1;
    dsLineParam->dwK2Term = K2;

    dsLineParam->dwLineAttributes = 0;
    if (GXMajor) dsLineParam->dwLineAttributes |= LINEPARAM_XM;
    if (!GXInc) dsLineParam->dwLineAttributes |= LINEPARAM_X_DEC;
    if (!GYInc) dsLineParam->dwLineAttributes |= LINEPARAM_Y_DEC;

    return(TRUE);

}
#endif	/* end of Accel_2D */


@


1.7
log
@Re-add ast files that previous re-import failed to re-add
@
text
@a38 1
#include "xf86PciInfo.h"
d51 2
a57 8
Bool bInitCMDQInfo(ScrnInfoPtr pScrn, ASTRecPtr pAST);
Bool bEnableCMDQ(ScrnInfoPtr pScrn, ASTRecPtr pAST);
Bool bEnableCMDQ2300(ScrnInfoPtr pScrn, ASTRecPtr pAST);
Bool bEnable2D(ScrnInfoPtr pScrn, ASTRecPtr pAST);
void vDisable2D(ScrnInfoPtr pScrn, ASTRecPtr pAST);
void vWaitEngIdle(ScrnInfoPtr pScrn, ASTRecPtr pAST);
UCHAR *pjRequestCMDQ(ASTRecPtr pAST, ULONG   ulDataLen);
Bool bGetLineTerm(_LINEInfo *LineInfo, LINEPARAM *dsLineParam);
d59 1
a59 1
Bool
d107 1
a107 1
Bool
d112 1
a112 1
    vWaitEngIdle(pScrn, pAST);
d173 1
a173 1
Bool
d178 1
a178 1
    vWaitEngIdle(pScrn, pAST);
d239 1
a239 1
bEnable2D(ScrnInfoPtr pScrn, ASTRecPtr pAST)
d269 1
a269 1
        vDisable2D(pScrn, pAST);
d275 1
a275 1
        vDisable2D(pScrn, pAST);
d283 1
a283 1
vDisable2D(ScrnInfoPtr pScrn, ASTRecPtr pAST)
d286 2
a287 2
    vWaitEngIdle(pScrn, pAST);
    vWaitEngIdle(pScrn, pAST);
d306 1
a306 1
vWaitEngIdle(ScrnInfoPtr pScrn, ASTRecPtr pAST)
d317 1
a317 1
        if (!jReg) goto Exit_vWaitEngIdle;
d321 1
a321 1
        if (!jReg) goto Exit_vWaitEngIdle;
d338 1
a338 1
Exit_vWaitEngIdle:
d359 1
a359 1
UCHAR *pjRequestCMDQ(
d449 1
a449 1
Bool bGetLineTerm(_LINEInfo *LineInfo, LINEPARAM *dsLineParam)
@


1.6
log
@Remove a bunch of video drivers that were never built on OpenBSD and
are unlikely to be ported in the future. no objection from miod@@ krw@@.
@
text
@a29 1
#include "mibstore.h"
a37 1
#include "vbe.h"
a44 2
/* include xaa includes */
#include "xaa.h"
d62 1
a62 1
void vWaitEngIdle(ScrnInfoPtr pScrn, ASTRecPtr pAST);    
a71 5
    pAST->CMDQInfo.pjCmdQBasePort    = pAST->MMIOVirtualAddr+ 0x8044; 
    pAST->CMDQInfo.pjWritePort       = pAST->MMIOVirtualAddr+ 0x8048;
    pAST->CMDQInfo.pjReadPort        = pAST->MMIOVirtualAddr+ 0x804C;
    pAST->CMDQInfo.pjEngStatePort    = pAST->MMIOVirtualAddr+ 0x804C;

d74 4
a77 4
        pAST->CMDQInfo.ulCMDQType = VM_CMD_QUEUE;	
       
        pScreen = screenInfo.screens[pScrn->scrnIndex];
      
d80 1
a80 1
            
d82 1
a82 1
            
d84 1
a84 1
            
d86 1
a86 1
        
d90 1
a90 1
        	
d93 1
a93 1
           						 
d95 3
a97 3
           pAST->CMDQInfo.ulCMDQMask = pAST->CMDQInfo.ulCMDQSize - 1 ; 
        	
        }	
d99 1
a99 1
        {   		  
d102 2
a103 2
        }	
        						  
d105 4
a108 4
    
    /* MMIO mode init */  
    if (pAST->MMIO2D) {    	
        pAST->CMDQInfo.ulCMDQType = VM_CMD_MMIO;    	
d110 2
a111 2
       
    return (TRUE);	
d119 1
a119 1
    vWaitEngIdle(pScrn, pAST);  
d124 1
a124 1
        *(ULONG *) (pAST->MMIOVirtualAddr + 0x804C) = (ULONG) (pAST->DBGSelect);             	
d126 1
a126 1
    
d132 1
a132 1
 
d134 1
a134 1
        ulVMCmdQBasePort |= 0xF0000000;			   
d140 1
a140 1
            ulVMCmdQBasePort |= 0x00000000;   
d142 1
a142 1
        	
d144 1
a144 1
            ulVMCmdQBasePort |= 0x04000000;   
d146 1
a146 1
      
d148 1
a148 1
            ulVMCmdQBasePort |= 0x08000000;       
d150 1
a150 1
            
d152 3
a154 3
            ulVMCmdQBasePort |= 0x0C000000;       
            break;        
            
d158 3
a160 3
        }     
                                 
        *(ULONG *) (pAST->CMDQInfo.pjCmdQBasePort) = ulVMCmdQBasePort;         
d163 1
a163 1
        
d166 2
a167 2
        ulVMCmdQBasePort |= 0xF0000000;			   
    
d169 1
a169 1
        *(ULONG *) (pAST->CMDQInfo.pjCmdQBasePort) = ulVMCmdQBasePort;                 		       
d171 1
a171 1
        
d177 1
a177 1
    return (TRUE);	
d185 1
a185 1
    vWaitEngIdle(pScrn, pAST);  
d190 1
a190 1
        *(ULONG *) (pAST->MMIOVirtualAddr + 0x804C) = (ULONG) (pAST->DBGSelect);             	
d192 1
a192 1
    
d203 1
a203 1
            ulNewModeData |= 0x00000000;   
d205 1
a205 1
        	
d207 1
a207 1
            ulNewModeData |= 0x00000004;   
d209 1
a209 1
      
d211 1
a211 1
            ulNewModeData |= 0x00000008;       
d213 1
a213 1
            
d215 3
a217 3
            ulNewModeData |= 0x0000000C;       
            break;        
            
d221 1
a221 1
        }     
d224 4
a227 4
        /* Set CMDQ Base */   
        ulVMCmdQBasePort  = (pAST->CMDQInfo.ulCMDQOffsetAddr - 0) >> 3;                                 
        *(ULONG *) (pAST->CMDQInfo.pjCmdQBasePort) = ulVMCmdQBasePort;         
        pAST->CMDQInfo.ulWritePointer = *(ULONG *) (pAST->CMDQInfo.pjWritePort) << 3;                 
d229 1
a229 1
        
d235 1
a235 1
        
d242 1
a242 1
    	
d250 2
a251 2
    
    if (pAST->jChipType == AST2300)
d253 1
a253 1
        	
d260 2
a261 1
    case AST2300:            
d263 2
a264 2
       *(ULONG *) (pAST->MMIOVirtualAddr + 0xF000) = 0x1;        
       
d267 4
d273 1
a273 3
	
    SetIndexRegMask(CRTC_PORT, 0xA4, 0xFE, 0x01);		/* enable 2D */  
   
d276 1
a276 1
        vDisable2D(pScrn, pAST);  	
d279 1
a279 1
        
d282 1
a282 1
        vDisable2D(pScrn, pAST);  	
d285 2
a286 2
            
    return (TRUE);	
d292 1
a292 1
	
d296 13
a308 2
    SetIndexRegMask(CRTC_PORT, 0xA4, 0xFE, 0x00);		  
	
d317 15
a331 3
    ULONG ulEngCheckSetting; 
    
    if (pAST->MMIO2D)     
a332 10
    else
        ulEngCheckSetting = 0x80000000;
    
    /* 2D disable if 0xA4 D[0] = 1 */
    GetIndexRegMask(CRTC_PORT, 0xA4, 0x01, jReg);  
    if (!jReg) goto Exit_vWaitEngIdle;
    
    /* 2D not work if in std. mode */
    GetIndexRegMask(CRTC_PORT, 0xA3, 0x0F, jReg);  
    if (!jReg) goto Exit_vWaitEngIdle;
d334 1
a334 1
    do  
d342 1
a342 1
                      
d344 1
a344 1
    
d346 2
a347 2
    ;   	
}    
d353 1
a353 1
    
d355 7
a361 7
        ulReadPointer  = *((volatile ULONG *)(pAST->CMDQInfo.pjReadPort)) & 0x0003FFFF;    	
        ulReadPointer2 = *((volatile ULONG *)(pAST->CMDQInfo.pjReadPort)) & 0x0003FFFF;
        ulReadPointer2 = *((volatile ULONG *)(pAST->CMDQInfo.pjReadPort)) & 0x0003FFFF;
        ulReadPointer2 = *((volatile ULONG *)(pAST->CMDQInfo.pjReadPort)) & 0x0003FFFF;
        ulReadPointer2 = *((volatile ULONG *)(pAST->CMDQInfo.pjReadPort)) & 0x0003FFFF;
        ulReadPointer2 = *((volatile ULONG *)(pAST->CMDQInfo.pjReadPort)) & 0x0003FFFF;        
     } while (ulReadPointer != ulReadPointer2);
d374 2
a375 2
    ulCMDQMask = pAST->CMDQInfo.ulCMDQMask;        
    
d378 1
a378 1
        /* Get CMDQ Buffer */            	
d385 1
a385 1
           
d390 1
a390 1
            
d394 1
a394 1
        
d396 1
a396 1
        pAST->CMDQInfo.ulCurCMDQueueLen -= ulDataLen;            
d398 1
a398 1
        return pjBuffer;            
d401 1
a401 1
    {   
d410 1
a410 1
           
d415 1
a415 1
            
d419 1
a419 1
    
d425 1
a425 1
            
d429 2
a430 2
            
        /* Get CMDQ Buffer */    
d433 1
a433 1
	        ;	
d437 1
a437 1
           
d442 1
a442 1
            
d446 1
a446 1
        
d450 2
a451 2
        return pjBuffer;            
        
d453 1
a453 1
   
d460 1
a460 1
            	
d462 1
a462 1
#ifdef LONG64    
d468 1
a468 1
#endif    
d473 1
a473 1
   
d478 1
a478 1
        mm = GAbsY;	        	
d483 1
a483 1
        mm = GAbsX;	        	    	
d487 1
a487 1
    	
d490 1
a490 1
    
d503 1
a503 1
    
d505 1
a505 1
    
@


1.5
log
@Update to xf86-video-ast 0.91.10
@
text
@@


1.4
log
@Update to xf86-video-ast 0.89.9
@
text
@d58 1
d63 1
d190 65
d258 5
a262 1
    	
d268 2
a269 1
    case AST2150:    
d286 1
a286 1
    if (!bEnableCMDQ(pScrn, pAST))
@


1.3
log
@update to xf86-video-ast 0.88.8
@
text
@a27 2
#include "xf86Resources.h"
#include "xf86RAC.h"
@


1.2
log
@xf86-video-ast 0.85.0
@
text
@d170 1
a170 1
        pAST->CMDQInfo.ulWritePointer = *(ULONG *) (pAST->CMDQInfo.pjWritePort);                 
d192 16
@


1.1
log
@Initial revision
@
text
@d257 1
a257 1
__inline ULONG ulGetCMDQLength(ASTRecPtr pAST, ULONG ulWritePointer, ULONG ulCMDQMask)
@


1.1.1.1
log
@Importing xf86-video-ast 0.81.0
@
text
@@


1.1.1.2
log
@Re-import xf86-video-ast.
This chipset is found in HP Proliant MicroServer remote access cards
among others. ok kettenis, seems like a good idea to jasper@@.
@
text
@d28 2
d32 1
d41 1
d49 2
a59 1
typedef Bool (*PFN_bENABLE_CMDQ)(ScrnInfoPtr , ASTRecPtr);
a63 1
Bool bEnableCMDQ2300(ScrnInfoPtr pScrn, ASTRecPtr pAST);
d66 1
a66 1
void vWaitEngIdle(ScrnInfoPtr pScrn, ASTRecPtr pAST);
d76 5
d83 4
a86 4
        pAST->CMDQInfo.ulCMDQType = VM_CMD_QUEUE;

        pScreen = xf86ScrnToScreen(pScrn);

d89 1
a89 1

d91 1
a91 1

d93 1
a93 1

d95 1
a95 1

d99 1
a99 1

d102 1
a102 1

d104 3
a106 3
           pAST->CMDQInfo.ulCMDQMask = pAST->CMDQInfo.ulCMDQSize - 1 ;

        }
d108 1
a108 1
        {
d111 2
a112 2
        }

d114 4
a117 4

    /* MMIO mode init */
    if (pAST->MMIO2D) {
        pAST->CMDQInfo.ulCMDQType = VM_CMD_MMIO;
d119 2
a120 2

    return (TRUE);
d128 1
a128 1
    vWaitEngIdle(pScrn, pAST);
d133 1
a133 1
        *(ULONG *) (pAST->MMIOVirtualAddr + 0x804C) = (ULONG) (pAST->DBGSelect);
d135 1
a135 1

d141 1
a141 1

d143 1
a143 1
        ulVMCmdQBasePort |= 0xF0000000;
d149 1
a149 1
            ulVMCmdQBasePort |= 0x00000000;
d151 1
a151 1

d153 1
a153 1
            ulVMCmdQBasePort |= 0x04000000;
d155 1
a155 1

d157 1
a157 1
            ulVMCmdQBasePort |= 0x08000000;
d159 1
a159 1

d161 3
a163 3
            ulVMCmdQBasePort |= 0x0C000000;
            break;

d167 4
a170 4
        }

        *(ULONG *) (pAST->CMDQInfo.pjCmdQBasePort) = ulVMCmdQBasePort;
        pAST->CMDQInfo.ulWritePointer = *(ULONG *) (pAST->CMDQInfo.pjWritePort) << 3;
d172 1
a172 1

d175 2
a176 2
        ulVMCmdQBasePort |= 0xF0000000;

d178 1
a178 1
        *(ULONG *) (pAST->CMDQInfo.pjCmdQBasePort) = ulVMCmdQBasePort;
d180 1
a180 1

d186 1
a186 1
    return (TRUE);
a189 65
bEnableCMDQ2300(ScrnInfoPtr pScrn, ASTRecPtr pAST)
{
    ULONG ulVMCmdQBasePort = 0, ulNewModeData;

    vWaitEngIdle(pScrn, pAST);

    /* set DBG Select Info */
    if (pAST->DBGSelect)
    {
        *(ULONG *) (pAST->MMIOVirtualAddr + 0x804C) = (ULONG) (pAST->DBGSelect);
    }

    /* set CMDQ base */
    switch (pAST->CMDQInfo.ulCMDQType)
    {
    case VM_CMD_QUEUE:
        /* enable new CMDQ mode */
        ulNewModeData = 0xc00000f0;
        /* set CMDQ Size */
        switch (pAST->CMDQInfo.ulCMDQSize)
        {
        case CMD_QUEUE_SIZE_256K:
            ulNewModeData |= 0x00000000;
            break;

        case CMD_QUEUE_SIZE_512K:
            ulNewModeData |= 0x00000004;
            break;

        case CMD_QUEUE_SIZE_1M:
            ulNewModeData |= 0x00000008;
            break;

        case CMD_QUEUE_SIZE_2M:
            ulNewModeData |= 0x0000000C;
            break;

        default:
            return(FALSE);
            break;
        }
        *(ULONG *) (pAST->MMIOVirtualAddr + 0x8060) = ulNewModeData;

        /* Set CMDQ Base */
        ulVMCmdQBasePort  = (pAST->CMDQInfo.ulCMDQOffsetAddr - 0) >> 3;
        *(ULONG *) (pAST->CMDQInfo.pjCmdQBasePort) = ulVMCmdQBasePort;
        pAST->CMDQInfo.ulWritePointer = *(ULONG *) (pAST->CMDQInfo.pjWritePort) << 3;
        break;

    case VM_CMD_MMIO:
        /* enable new CMDQ mode */
        ulNewModeData = 0xc00000f2;
        *(ULONG *) (pAST->MMIOVirtualAddr + 0x8060) = ulNewModeData;
        break;

    default:
        return (FALSE);
        break;
    }

    return (TRUE);

} /* bEnableCMDQ2300 */

Bool
d192 2
a193 26
    ULONG ulData;
    PFN_bENABLE_CMDQ pfnEnableCMDQ = bEnableCMDQ;

    if ( (pAST->jChipType == AST2300) || (pAST->jChipType == AST2400) )
        pfnEnableCMDQ = bEnableCMDQ2300;

    switch (pAST->jChipType)
    {
    case AST2100:
    case AST1100:
    case AST2200:
    case AST2150:
    case AST2300:
    case AST2400:
       *(ULONG *) (pAST->MMIOVirtualAddr + 0xF004) = 0x1e6e0000;
       *(ULONG *) (pAST->MMIOVirtualAddr + 0xF000) = 0x1;

       ulData = *(ULONG *) (pAST->MMIOVirtualAddr + 0x1200c);
       *(ULONG *) (pAST->MMIOVirtualAddr + 0x1200c) = (ulData & 0xFFFFFFFD);

    case AST2000:
       SetIndexRegMask(CRTC_PORT, 0xA4, 0xFE, 0x01);		/* enable 2D */

       break;
    }

d196 1
a196 1
        vDisable2D(pScrn, pAST);
d199 2
a200 2

    if (!pfnEnableCMDQ(pScrn, pAST))
d202 1
a202 1
        vDisable2D(pScrn, pAST);
d205 2
a206 2

    return (TRUE);
d212 1
a212 1

d216 2
a217 13
    /* restore 2D settings */
    if (pAST->jChipType != AST1180)
    {
        if (pAST->SavedReg.REGA4 & 0x01)	/* 2D enabled */
        {
            SetIndexRegMask(CRTC_PORT, 0xA4, 0xFE, 0x01);
            *(ULONG *) (pAST->MMIOVirtualAddr + 0x8044) = pAST->SavedReg.ENG8044;
        }
        else								/* 2D disabled */
        {
            SetIndexRegMask(CRTC_PORT, 0xA4, 0xFE, 0x00);
        }
    }
d226 3
a228 15
    ULONG ulEngCheckSetting = 0x80000000;

    if (pAST->jChipType != AST1180)
    {

        /* 2D disable if 0xA4 D[0] = 1 */
        GetIndexRegMask(CRTC_PORT, 0xA4, 0x01, jReg);
        if (!jReg) goto Exit_vWaitEngIdle;

        /* 2D not work if in std. mode */
        GetIndexRegMask(CRTC_PORT, 0xA3, 0x0F, jReg);
        if (!jReg) goto Exit_vWaitEngIdle;
    }

    if (*(ULONG *) (pAST->CMDQInfo.pjCmdQBasePort) & 0x02000000)	/* MMIO Mode */
d230 10
d241 1
a241 1
    do
d249 1
a249 1

d251 1
a251 1

d253 2
a254 2
    ;
}
d257 1
a257 1
static __inline ULONG ulGetCMDQLength(ASTRecPtr pAST, ULONG ulWritePointer, ULONG ulCMDQMask)
d260 1
a260 1

d262 7
a268 7
	ulReadPointer  = *((volatile ULONG *)(pAST->CMDQInfo.pjReadPort));
	ulReadPointer2 = *((volatile ULONG *)(pAST->CMDQInfo.pjReadPort));
	ulReadPointer2 = *((volatile ULONG *)(pAST->CMDQInfo.pjReadPort));
	ulReadPointer2 = *((volatile ULONG *)(pAST->CMDQInfo.pjReadPort));
	ulReadPointer2 = *((volatile ULONG *)(pAST->CMDQInfo.pjReadPort));
	ulReadPointer2 = *((volatile ULONG *)(pAST->CMDQInfo.pjReadPort));
     } while ( ((ulReadPointer & 0x0003FFFF) != (ulReadPointer2 & 0x0003FFFF)) || (ulReadPointer == 0xFFFFEEEE) );
d281 2
a282 2
    ulCMDQMask = pAST->CMDQInfo.ulCMDQMask;

d285 1
a285 1
        /* Get CMDQ Buffer */
d292 1
a292 1

d297 1
a297 1

d301 1
a301 1

d303 1
a303 1
        pAST->CMDQInfo.ulCurCMDQueueLen -= ulDataLen;
d305 1
a305 1
        return pjBuffer;
d308 1
a308 1
    {
d317 1
a317 1

d322 1
a322 1

d326 1
a326 1

d332 1
a332 1

d336 2
a337 2

        /* Get CMDQ Buffer */
d340 1
a340 1
	        ;
d344 1
a344 1

d349 1
a349 1

d353 1
a353 1

d357 2
a358 2
        return pjBuffer;

d360 1
a360 1

d367 1
a367 1

d369 1
a369 1
#ifdef LONG64
d375 1
a375 1
#endif
d380 1
a380 1

d385 1
a385 1
        mm = GAbsY;
d390 1
a390 1
        mm = GAbsX;
d394 1
a394 1

d397 1
a397 1

d410 1
a410 1

d412 1
a412 1

@

