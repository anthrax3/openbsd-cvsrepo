head	1.18;
access;
symbols
	OPENBSD_6_2:1.18.0.16
	OPENBSD_6_2_BASE:1.18
	OPENBSD_6_1:1.18.0.14
	OPENBSD_6_1_BASE:1.18
	OPENBSD_6_0:1.18.0.12
	OPENBSD_6_0_BASE:1.18
	OPENBSD_5_9:1.18.0.10
	OPENBSD_5_9_BASE:1.18
	OPENBSD_5_8:1.18.0.8
	OPENBSD_5_8_BASE:1.18
	OPENBSD_5_7:1.18.0.6
	OPENBSD_5_7_BASE:1.18
	OPENBSD_5_6:1.18.0.4
	OPENBSD_5_6_BASE:1.18
	OPENBSD_5_5:1.18.0.2
	OPENBSD_5_5_BASE:1.18
	OPENBSD_5_4:1.17.0.10
	OPENBSD_5_4_BASE:1.17
	OPENBSD_5_3:1.17.0.8
	OPENBSD_5_3_BASE:1.17
	OPENBSD_5_2:1.17.0.6
	OPENBSD_5_2_BASE:1.17
	OPENBSD_5_1_BASE:1.17
	OPENBSD_5_1:1.17.0.4
	OPENBSD_5_0:1.17.0.2
	OPENBSD_5_0_BASE:1.17
	OPENBSD_4_9:1.13.0.2
	OPENBSD_4_9_BASE:1.13
	OPENBSD_4_8:1.11.0.4
	OPENBSD_4_8_BASE:1.11
	OPENBSD_4_7:1.6.0.2
	OPENBSD_4_7_BASE:1.6
	OPENBSD_4_6:1.5.0.6
	OPENBSD_4_6_BASE:1.5
	OPENBSD_4_5:1.5.0.4
	OPENBSD_4_5_BASE:1.5
	OPENBSD_4_4:1.5.0.2
	OPENBSD_4_4_BASE:1.5
	OPENBSD_4_3_BASE:1.2
	OPENBSD_4_3:1.2.0.2
	v1_2_2:1.1.1.1
	xorg:1.1.1;
locks; strict;
comment	@ * @;


1.18
date	2013.11.11.16.52.00;	author shadchin;	state Exp;
branches;
next	1.17;

1.17
date	2011.06.29.20.00.23;	author matthieu;	state Exp;
branches;
next	1.16;

1.16
date	2011.06.14.11.47.33;	author matthieu;	state Exp;
branches;
next	1.15;

1.15
date	2011.05.30.10.52.58;	author shadchin;	state Exp;
branches;
next	1.14;

1.14
date	2011.04.22.18.33.36;	author shadchin;	state Exp;
branches;
next	1.13;

1.13
date	2010.11.27.14.41.06;	author matthieu;	state Exp;
branches;
next	1.12;

1.12
date	2010.11.26.16.53.00;	author claudio;	state Exp;
branches;
next	1.11;

1.11
date	2010.08.04.21.45.32;	author matthieu;	state Exp;
branches;
next	1.10;

1.10
date	2010.08.04.19.27.52;	author matthieu;	state Exp;
branches;
next	1.9;

1.9
date	2010.07.28.19.47.40;	author naddy;	state Exp;
branches;
next	1.8;

1.8
date	2010.07.27.19.33.03;	author matthieu;	state Exp;
branches;
next	1.7;

1.7
date	2010.07.27.19.06.44;	author matthieu;	state Exp;
branches;
next	1.6;

1.6
date	2009.12.07.19.28.53;	author oga;	state Exp;
branches;
next	1.5;

1.5
date	2008.05.04.22.45.35;	author maja;	state Exp;
branches;
next	1.4;

1.4
date	2008.04.20.19.28.14;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2008.04.16.19.45.22;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2007.12.12.21.38.01;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2007.11.24.18.52.15;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2007.11.24.18.52.15;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.18
log
@Update to xf86-input-keyboard 1.8.0.

ok matthieu@@
@
text
@
/*
 * Copyright (c) 2002 by The XFree86 Project, Inc.
 * Author: Ivan Pascal.
 *
 * Based on the code from bsd_io.c which is
 * Copyright 1992 by Rich Murphey <Rich@@Rice.edu>
 * Copyright 1993 by David Dawes <dawes@@xfree86.org>
 */

#ifdef HAVE_CONFIG_H
#include "config.h"
#endif

#include <xorg-server.h>
#include <X11/X.h>
#include <termios.h>

#include "compiler.h"

#include "xf86.h"
#include "xf86Priv.h"
#include "xf86_OSlib.h"

#include "xf86Xinput.h"
#include "xf86OSKbd.h"
#include "atKeynames.h"
#include "bsd_kbd.h"

extern int priv_open_device(const char *dev);

static KbdProtocolRec protocols[] = {
   {"standard", PROT_STD },
#ifdef WSCONS_SUPPORT
   {"wskbd", PROT_WSCONS },
#endif
   { NULL, PROT_UNKNOWN_KBD }
};

typedef struct {
   struct termios kbdtty;
} BsdKbdPrivRec, *BsdKbdPrivPtr;

#ifdef WSCONS_SUPPORT
static Bool
WSSetVersion(int fd, const char *name)
{
#ifdef WSKBDIO_SETVERSION
    int version = WSKBDIO_EVENT_VERSION;
    if (ioctl(fd, WSKBDIO_SETVERSION, &version) == -1) {
        xf86Msg(X_WARNING, "%s: cannot set version\n", name);
        return FALSE;
    }
#endif
    return TRUE;
}
#endif

static
int KbdInit(InputInfoPtr pInfo, int what)
{
    KbdDevPtr pKbd = (KbdDevPtr) pInfo->private;
    BsdKbdPrivPtr priv = (BsdKbdPrivPtr) pKbd->private;

    if (pKbd->isConsole) {
        switch (pKbd->consType) {
#if defined(PCCONS_SUPPORT) || defined(SYSCONS_SUPPORT) || defined (PCVT_SUPPORT)  || defined (WSCONS_SUPPORT)
	    case PCCONS:
	    case SYSCONS:
	    case PCVT:
#if defined WSCONS_SUPPORT
            case WSCONS:
#endif
		tcgetattr(pInfo->fd, &(priv->kbdtty));
#endif
	         break;
        }
    }

    return Success;
}

static void
SetKbdLeds(InputInfoPtr pInfo, int leds)
{
    KbdDevPtr pKbd = (KbdDevPtr) pInfo->private;
    int real_leds = 0;

#ifdef LED_CAP
    if (leds & XLED1)  real_leds |= LED_CAP;
#endif
#ifdef LED_NUM
    if (leds & XLED2)  real_leds |= LED_NUM;
#endif
#ifdef LED_SCR
    if (leds & XLED3)  real_leds |= LED_SCR;
    if (leds & XLED4)  real_leds |= LED_SCR;
#endif

    switch (pKbd->consType) {

#ifdef PCCONS_SUPPORT
	case PCCONS:
		break;
#endif
#if defined (SYSCONS_SUPPORT) || defined (PCVT_SUPPORT)
	case SYSCONS:
	case PCVT:
	     ioctl(pInfo->fd, KDSETLED, real_leds);
	     break;
#endif
#if defined(WSCONS_SUPPORT)
        case WSCONS:
             ioctl(pInfo->fd, WSKBDIO_SETLEDS, &real_leds);
             break;
#endif
    }
}

static int
GetKbdLeds(InputInfoPtr pInfo)
{
    KbdDevPtr pKbd = (KbdDevPtr) pInfo->private;
    int leds = 0, real_leds = 0;

    switch (pKbd->consType) {

#ifdef PCCONS_SUPPORT
	case PCCONS:
	     break;
#endif
#if defined (SYSCONS_SUPPORT) || defined (PCVT_SUPPORT)
	case SYSCONS:
	case PCVT:
	     ioctl(pInfo->fd, KDGETLED, &real_leds);
	     break;
#endif
#if defined(WSCONS_SUPPORT)
        case WSCONS:
             ioctl(pInfo->fd, WSKBDIO_GETLEDS, &real_leds);
             break;
#endif
    }

#ifdef LED_CAP
    if (real_leds & LED_CAP) leds |= XLED1;
#endif
#ifdef LED_NUM
    if (real_leds & LED_NUM) leds |= XLED2;
#endif
#ifdef LED_SCR
    if (real_leds & LED_SCR) leds |= XLED3;
#endif

    return(leds);
}

static int
KbdOn(InputInfoPtr pInfo, int what)
{
    KbdDevPtr pKbd = (KbdDevPtr) pInfo->private;
#if defined(SYSCONS_SUPPORT) || defined(PCCONS_SUPPORT) || defined(PCVT_SUPPORT) || defined(WSCONS_SUPPORT)
    BsdKbdPrivPtr priv = (BsdKbdPrivPtr) pKbd->private;
    struct termios nTty;
#endif
#ifdef WSCONS_SUPPORT
    int option;
#endif

    if (pKbd->isConsole) {
        switch (pKbd->consType) {

#if defined(SYSCONS_SUPPORT) || defined(PCCONS_SUPPORT) || defined(PCVT_SUPPORT) || defined(WSCONS_SUPPORT)
	    case SYSCONS:
	    case PCCONS:
	    case PCVT:
#ifdef WSCONS_SUPPORT
            case WSCONS:
#endif
		 nTty = priv->kbdtty;
		 nTty.c_iflag = IGNPAR | IGNBRK;
		 nTty.c_oflag = 0;
		 nTty.c_cflag = CREAD | CS8;
		 nTty.c_lflag = 0;
		 nTty.c_cc[VTIME] = 0;
		 nTty.c_cc[VMIN] = 1;
		 cfsetispeed(&nTty, 9600);
		 cfsetospeed(&nTty, 9600);
		 if (tcsetattr(pInfo->fd, TCSANOW, &nTty) < 0) {
			 xf86Msg(X_ERROR, "KbdOn: tcsetattr: %s\n",
			     strerror(errno));
		 }
                 break;
#endif
        }
#if defined (SYSCONS_SUPPORT) || defined (PCVT_SUPPORT) || defined (WSCONS_SUPPORT)
        switch (pKbd->consType) {
	    case SYSCONS:
	    case PCVT:
#ifdef K_CODE
                 if (pKbd->CustomKeycodes)
		     ioctl(pInfo->fd, KDSKBMODE, K_CODE);
	         else
	             ioctl(pInfo->fd, KDSKBMODE, K_RAW);
#else
		 ioctl(pInfo->fd, KDSKBMODE, K_RAW);
#endif
	         break;
#ifdef WSCONS_SUPPORT
            case WSCONS:
                 option = WSKBD_RAW;
                 if (ioctl(pInfo->fd, WSKBDIO_SETMODE, &option) == -1) {
			 FatalError("can't switch keyboard to raw mode. "
				    "Enable support for it in the kernel\n"
				    "or use for example:\n\n"
				    "Option \"Protocol\" \"wskbd\"\n"
				    "Option \"Device\" \"/dev/wskbd0\"\n"
				    "\nin your xorg.conf(5) file\n");
		 }
		 break;
#endif
        }
#endif
    } else {
        switch (pKbd->consType) {
#ifdef WSCONS_SUPPORT
            case WSCONS:
		if ((pKbd->wsKbdDev[0] != 0) && (pInfo->fd == -1)) {
			xf86Msg(X_INFO, "opening %s\n", pKbd->wsKbdDev);
			pInfo->fd = open(pKbd->wsKbdDev, O_RDONLY | O_NONBLOCK | O_EXCL);
			if (pInfo->fd == -1) {
				xf86Msg(X_ERROR, "cannot open \"%s\"\n", pKbd->wsKbdDev);
				return FALSE;
			}
			if (WSSetVersion(pInfo->fd, pInfo->name) == FALSE)
				return FALSE;
		}
		break;
#endif
	}
    }
    return Success;
}

static int
KbdOff(InputInfoPtr pInfo, int what)
{
    KbdDevPtr pKbd = (KbdDevPtr) pInfo->private;
    BsdKbdPrivPtr priv = (BsdKbdPrivPtr) pKbd->private;
#ifdef WSCONS_SUPPORT
    int option;
#endif

    if (pKbd->isConsole) {
        switch (pKbd->consType) {
#if defined (SYSCONS_SUPPORT) || defined (PCVT_SUPPORT)
	    case SYSCONS:
	    case PCVT:
	         ioctl(pInfo->fd, KDSKBMODE, K_XLATE);
	         /* FALL THROUGH */
#endif
#if defined(SYSCONS_SUPPORT) || defined(PCCONS_SUPPORT) || defined(PCVT_SUPPORT)
	    case PCCONS:
	         tcsetattr(pInfo->fd, TCSANOW, &(priv->kbdtty));
	         break;
#endif
#ifdef WSCONS_SUPPORT
            case WSCONS:
                 option = WSKBD_TRANSLATED;
                 ioctl(xf86Info.consoleFd, WSKBDIO_SETMODE, &option);
                 tcsetattr(pInfo->fd, TCSANOW, &(priv->kbdtty));
	         break;
#endif
        }
    } else {
         switch (pKbd->consType) {
#ifdef WSCONS_SUPPORT
            case WSCONS:
                 if ((pKbd->wsKbdDev[0] != 0) && (pInfo->fd != -1)) {
			xf86Msg(X_INFO, "closing %s\n", pKbd->wsKbdDev);
			/* need to close the fd while we're gone */
			close(pInfo->fd);
			pInfo->fd = -1;
                 }
	         break;
#endif
        }
    }
    return Success;
}

static void
SoundBell(InputInfoPtr pInfo, int loudness, int pitch, int duration)
{
    KbdDevPtr pKbd = (KbdDevPtr) pInfo->private;
#ifdef WSCONS_SUPPORT
    struct wskbd_bell_data wsb;
#endif

    if (loudness && pitch) {
	switch (pKbd->consType) {
#ifdef PCCONS_SUPPORT
	    case PCCONS:
	         { int data[2];
		   data[0] = pitch;
		   data[1] = (duration * loudness) / 50;
		   ioctl(pInfo->fd, CONSOLE_X_BELL, data);
		   break;
		 }
#endif
#if defined (SYSCONS_SUPPORT) || defined (PCVT_SUPPORT)
	    case SYSCONS:
	    case PCVT:
		 ioctl(pInfo->fd, KDMKTONE,
		 ((1193190 / pitch) & 0xffff) |
		 (((unsigned long)duration*loudness/50)<<16));
		 break;
#endif
#if defined (WSCONS_SUPPORT)
            case WSCONS:
                 wsb.which = WSKBD_BELL_DOALL;
                 wsb.pitch = pitch;
                 wsb.period = duration;
                 wsb.volume = loudness;
                 ioctl(pInfo->fd, WSKBDIO_COMPLEXBELL, &wsb);
                 break;
#endif
	}
    }
}

static void
stdReadInput(InputInfoPtr pInfo)
{
    KbdDevPtr pKbd = (KbdDevPtr) pInfo->private;
    unsigned char rBuf[64];
    int nBytes, i;
    if ((nBytes = read( pInfo->fd, (char *)rBuf, sizeof(rBuf))) > 0) {
       for (i = 0; i < nBytes; i++)
	   pKbd->PostEvent(pInfo, rBuf[i] & 0x7f,
                           rBuf[i] & 0x80 ? FALSE : TRUE);
       }
}

#ifdef WSCONS_SUPPORT

static void
WSReadInput(InputInfoPtr pInfo)
{
    KbdDevPtr pKbd = (KbdDevPtr) pInfo->private;
    struct wscons_event events[64];
    int type;
    int blocked, n, i;

    if ((n = read( pInfo->fd, events, sizeof(events))) > 0) {
        n /=  sizeof(struct wscons_event);
        for (i = 0; i < n; i++) {
	    type = events[i].type;
	    if (type == WSCONS_EVENT_KEY_UP || type == WSCONS_EVENT_KEY_DOWN) {
		/* It seems better to block SIGIO there */
		blocked = xf86BlockSIGIO();
		pKbd->PostEvent(pInfo, (unsigned int)(events[i].value),
				type == WSCONS_EVENT_KEY_DOWN ? TRUE : FALSE);
		xf86UnblockSIGIO(blocked);
	    }
	} /* for */
    }
}

static void
printWsType(const char *type, const char *name)
{
    xf86Msg(X_PROBED, "%s: Keyboard type: %s\n", name, type);
}
#endif

static Bool
OpenKeyboard(InputInfoPtr pInfo)
{
    KbdDevPtr pKbd = (KbdDevPtr) pInfo->private;
    int i;
    KbdProtocolId prot = PROT_UNKNOWN_KBD;
    char *s;

    s = xf86SetStrOption(pInfo->options, "Protocol", NULL);
    for (i = 0; protocols[i].name; i++) {
        if (xf86NameCmp(s, protocols[i].name) == 0) {
           prot = protocols[i].id;
           break;
        }
    }

    switch (prot) {
	case PROT_STD:
           pInfo->read_input = stdReadInput;
           break;
#ifdef WSCONS_SUPPORT
        case PROT_WSCONS:
           pInfo->read_input = WSReadInput;
           break;
#endif
        default:
           xf86Msg(X_ERROR,"\"%s\" is not a valid keyboard protocol name\n", s);
           free(s);
           return FALSE;
    }
    free(s);

    if (prot == PROT_WSCONS)
	s = xf86SetStrOption(pInfo->options, "Device", "/dev/wskbd");
    else
	s = xf86SetStrOption(pInfo->options, "Device", NULL);

    if (s == NULL) {
	pInfo->fd = xf86Info.consoleFd;
	pKbd->isConsole = TRUE;
	pKbd->consType = xf86Info.consType;
	pKbd->wsKbdDev[0] = 0;
    } else {
#ifndef X_PRIVSEP
	pInfo->fd = open(s, O_RDONLY | O_NONBLOCK | O_EXCL);
#else
	pInfo->fd = priv_open_device(s);
#endif
	if (pInfo->fd == -1) {
           xf86Msg(X_ERROR, "%s: cannot open \"%s\"\n", pInfo->name, s);
           free(s);
           return FALSE;
       }
       pKbd->isConsole = FALSE;
       strncpy(pKbd->wsKbdDev, s, 256);
       pKbd->consType = xf86Info.consType;
       free(s);
    }

#ifdef WSCONS_SUPPORT
    if (prot == PROT_WSCONS) {
       pKbd->consType = WSCONS;
       if (WSSetVersion(pInfo->fd, pInfo->name) == FALSE)
	   return FALSE;
       /* Find out keyboard type */
       if (ioctl(pInfo->fd, WSKBDIO_GTYPE, &(pKbd->wsKbdType)) == -1) {
           xf86Msg(X_ERROR, "%s: cannot get keyboard type", pInfo->name);
           close(pInfo->fd);
           return FALSE;
       }
       switch (pKbd->wsKbdType) {
           case WSKBD_TYPE_PC_XT:
               printWsType("XT", pInfo->name);
               break;
           case WSKBD_TYPE_PC_AT:
               printWsType("AT", pInfo->name);
               break;
           case 0:
               /* If wsKbdType==0, no keyboard attached to the mux. Assume USB. */
               xf86Msg(X_WARNING, "%s: No keyboard attached, assuming USB\n",
                                  pInfo->name);
               pKbd->wsKbdType = WSKBD_TYPE_USB;
               /* FALLTHROUGH */
           case WSKBD_TYPE_USB:
               printWsType("USB", pInfo->name);
               break;
#ifdef WSKBD_TYPE_ADB
           case WSKBD_TYPE_ADB:
               printWsType("ADB", pInfo->name);
               break;
#endif
#ifdef WSKBD_TYPE_LK201
           case WSKBD_TYPE_LK201:
               printWsType("LK201", pInfo->name);
               break;
#endif
#ifdef WSKBD_TYPE_LK401
           case WSKBD_TYPE_LK401:
               printWsType("LK-401", pInfo->name);
               break;
#endif
#ifdef WSKBD_TYPE_MAPLE
           case WSKBD_TYPE_MAPLE:
               printWsType("Maple", pInfo->name);
               break;
#endif
#ifdef WSKBD_TYPE_SUN
           case WSKBD_TYPE_SUN:
               printWsType("Sun", pInfo->name);
               break;
#endif
#ifdef WSKBD_TYPE_SUN5
           case WSKBD_TYPE_SUN5:
               printWsType("Sun5", pInfo->name);
               break;
#endif
           default:
               xf86Msg(X_WARNING, "%s: Unsupported wskbd type \"%d\"\n",
                                  pInfo->name, pKbd->wsKbdType);
               printWsType("Unknown wskbd", pInfo->name);
               break;
       }
    }
#endif
    return TRUE;
}

_X_EXPORT Bool
xf86OSKbdPreInit(InputInfoPtr pInfo)
{
    KbdDevPtr pKbd = pInfo->private;

    pKbd->KbdInit	= KbdInit;
    pKbd->KbdOn		= KbdOn;
    pKbd->KbdOff	= KbdOff;
    pKbd->Bell		= SoundBell;
    pKbd->SetLeds	= SetKbdLeds;
    pKbd->GetLeds	= GetKbdLeds;
    pKbd->KbdGetMapping	= KbdGetMapping;

    pKbd->RemapScanCode = NULL;

    pKbd->OpenKeyboard = OpenKeyboard;

    pKbd->private = calloc(sizeof(BsdKbdPrivRec), 1);
    if (pKbd->private == NULL) {
       xf86Msg(X_ERROR,"can't allocate keyboard OS private data\n");
       return FALSE;
    }
    return TRUE;
}
@


1.17
log
@Code to configure the xkb layout and options from wscons setup
has moved to the X server wscons hotplug driver.

Tested by many, ok oga@@
@
text
@d44 15
d74 1
a74 1
 	         tcgetattr(pInfo->fd, &(priv->kbdtty));
d193 2
a194 2
                 break; 
#endif 
a208 1
#endif
d223 18
d275 13
d301 1
a301 1
    	switch (pKbd->consType) {
d371 1
a371 1
printWsType(char *type, char *devname)
d373 1
a373 1
    xf86Msg(X_PROBED, "%s: Keyboard type: %s\n", devname, type); 
d394 1
a394 1
    	case PROT_STD:
d409 5
a413 1
    s = xf86SetStrOption(pInfo->options, "Device", NULL);
d415 4
a418 9
       if (prot == PROT_WSCONS) {
           xf86Msg(X_ERROR,"A \"device\" option is required with"
                                  " the \"wskbd\" keyboard protocol\n");
           return FALSE;
       } else {
           pInfo->fd = xf86Info.consoleFd;
           pKbd->isConsole = TRUE;
           pKbd->consType = xf86Info.consType;
       }
d421 1
a421 1
       pInfo->fd = open(s, O_RDONLY | O_NONBLOCK | O_EXCL);
d423 1
a423 1
       pInfo->fd = priv_open_device(s);
d425 1
a425 1
       if (pInfo->fd == -1) {
d431 1
d439 2
d454 6
d468 15
d493 4
a496 2
           case WSKBD_TYPE_LK201:
               printWsType("LK-201", pInfo->name);
a497 8
           case WSKBD_TYPE_LK401:
               printWsType("LK-401", pInfo->name);
               break;
           default:
               xf86Msg(X_ERROR, "%s: Unsupported wskbd type \"%d\"",
                                pInfo->name, pKbd->wsKbdType);
               close(pInfo->fd);
               return FALSE;
@


1.16
log
@Let fr.dvorak kbdtype select the bepo xkb layout.
Tested by Manuel Giraud. Thanks.
@
text
@a23 1
#include "xf86Parser.h"
a29 39
#ifdef WSCONS_SUPPORT
#include <dev/wscons/wsconsio.h>
#include <dev/wscons/wsksymdef.h>

#define KB_OVRENC \
	{ KB_UK,	"gb" }, \
	{ KB_SV,	"se" }, \
	{ KB_SG,	"ch" }, \
	{ KB_SF,	"ch" }, \
	{ KB_LA,	"latam" }, \
	{ KB_CF,	"ca" }

struct nameint {
  int val;
  char *name;
} kbdenc[] = { KB_OVRENC, KB_ENCTAB, { 0 } };

struct nameint kbdvar[] = {
	{ KB_NODEAD | KB_SG,	"de_nodeadkeys" },
	{ KB_NODEAD | KB_SF,	"fr_nodeadkeys" },
	{ KB_SF,		"fr" },
	{ KB_DVORAK | KB_CF,	"fr-dvorak" },
	{ KB_DVORAK | KB_FR,	"bepo" },
	{ KB_DVORAK,		"dvorak" },
	{ KB_CF,		"fr-legacy" },
	{ KB_NODEAD,		"nodeadkeys" },
	{ 0 }
};

struct nameint kbdopt[] = {
#ifndef USE_XKEYBOARD_CONFIG
	{ KB_SWAPCTRLCAPS, "ctrl:swapcaps" },
#else
	{ KB_SWAPCTRLCAPS, "ctrl:swapcaps,terminate:ctrl_alt_bksp" },
#endif
	{ 0 }
};
#endif

a338 3
#ifdef WSCONS_SUPPORT
    kbd_t wsenc = 0;
#endif
a437 47

    /*
     * Try to get the configured keyboard translation from the wscons
     * keyboard driver (see kbd(8) for more information) if no
     * XkbLayout has been specified.  Do this even if the protocol is
     * not wskbd.
     */
    if (xf86findOption(pInfo->options, "XkbLayout") != NULL)
        return TRUE;

    if (ioctl(pInfo->fd, WSKBDIO_GETENCODING, &wsenc) == -1) {
	/* Ignore the error, we just use the defaults */
	xf86Msg(X_ERROR, "%s: error getting wscons layout name: %s\n",
		pInfo->name, strerror(errno));
	return TRUE;
    }
    if (KB_ENCODING(wsenc) == KB_USER) {
	/* Ignore wscons "user" layout */
	xf86Msg(X_INFO, "%s: ignoring \"user\" wscons layout\n", pInfo->name);
	xf86addNewOption(pInfo->options, "XkbLayout", "us");
	return TRUE;
    }

    for (i = 0; kbdenc[i].val; i++)
	if(KB_ENCODING(wsenc) == kbdenc[i].val) {
	    xf86Msg(X_PROBED, "%s: using wscons layout %s\n",
		    pInfo->name, kbdenc[i].name);
            xf86addNewOption(pInfo->options, "XkbLayout", kbdenc[i].name);
            break;
        }
    if (xf86findOption(pInfo->options, "XkbVariant") == NULL)
        for (i = 0; kbdvar[i].val; i++)
            if (wsenc == kbdvar[i].val ||
		KB_VARIANT(wsenc) == kbdvar[i].val) {
		xf86Msg(X_PROBED, "%s: using wscons variant %s\n",
			pInfo->name, kbdvar[i].name);
                xf86addNewOption(pInfo->options, "XkbVariant", kbdvar[i].name);
                break;
            }
    if (xf86findOption(pInfo->options, "XkbOptions") == NULL)
        for (i = 0; kbdopt[i].val; i++)
            if (KB_VARIANT(wsenc) == kbdopt[i].val) {
		xf86Msg(X_PROBED, "%s: using wscons option %s\n",
			pInfo->name, kbdopt[i].name);
                xf86addNewOption(pInfo->options, "XkbOptions", kbdopt[i].name);
                break;
            }
@


1.15
log
@If you do not have XkbOptions in xorg.conf, it is automatically set to
"terminate: ctrl_alt_bksp" (only if XENOCARA_USE_XKEYBOARD_CONFIG=Yes)

tested ajacoutot@@, ok matthieu@@
@
text
@d53 2
d56 1
a56 2
	{ KB_NODEAD,	"nodeadkeys" },
	{ KB_DVORAK,	"dvorak" },
@


1.14
log
@update to xf86-input-keyboard 1.6.0

ok matthieu@@
@
text
@d60 1
d62 3
@


1.13
log
@update to xf86-input-keyboard 1.5.0
Tested by ajacoutot@@, shadchin@@, jasper@@ and landry@@. Thanks.
@
text
@d29 1
a64 3
extern void KbdGetMapping(InputInfoPtr pInfo, KeySymsPtr pKeySyms,
                          CARD8 *pModMap);

a66 2
extern Bool VTSwitchEnabled;

a177 19
static void
SetKbdRepeat(InputInfoPtr pInfo, char rad)
{
    KbdDevPtr pKbd = (KbdDevPtr) pInfo->private;
    switch (pKbd->consType) {

#ifdef PCCONS_SUPPORT
	case PCCONS:
		break;
#endif
#if defined (SYSCONS_SUPPORT) || defined (PCVT_SUPPORT)
	case SYSCONS:
	case PCVT:
		ioctl(pInfo->fd, KDSETRAD, rad);
		break;
#endif
    }
}

d397 1
a397 1
           xfree(s);
d400 1
a400 2
    xf86Msg(X_CONFIG, "%s: Protocol: %s\n", pInfo->name, s);
    xfree(s);
d421 1
a421 1
           xfree(s);
d426 1
a426 1
       xfree(s);
a428 6
#if defined (SYSCONS_SUPPORT) || defined (PCVT_SUPPORT)
    if (pKbd->isConsole &&
        ((pKbd->consType == SYSCONS) || (pKbd->consType == PCVT)))
        pKbd->vtSwitchSupported = TRUE;
#endif

d449 1
a449 1
	   case WSKBD_TYPE_ADB:
d459 3
a461 3
	   case WSKBD_TYPE_SUN5:
	       printWsType("Sun5", pInfo->name);
	       break;
a537 1
    pKbd->SetKbdRepeat	= SetKbdRepeat;
d543 2
a544 4
    pKbd->vtSwitchSupported = FALSE;
    pKbd->CustomKeycodes = FALSE;
    
    pKbd->private = xcalloc(sizeof(BsdKbdPrivRec), 1);
@


1.12
log
@Add a nasty little hack to make keyboard selection work for Swiss keyboard
encodings and the Canadian French one. The way XkbLayout and XkbVariant
work for this encodings changed some long time ago and the result was
that you would end up with no keyboard at all in X. Now XkbVariant includes
part of the layout selection which is about as ugly and makes the wscons
mapping a bit tricky.
OK matthieu@@, maja@@
@
text
@a10 2
#define NEED_EVENTS

d15 1
d126 1
d129 1
d151 2
d155 1
d188 1
d191 1
@


1.11
log
@Fix the fix of the fix.

Previous iteration would again ignore wscons keyboard.encoding setting.
Now no default xkbLayout is set, unless keyboard.encoding=user.
@
text
@d38 2
a39 2
	{ KB_SG,	"ch(de)" }, \
	{ KB_SF,	"ch(fr)" }, \
d41 1
a41 1
	{ KB_CF,	"ca(fr)" }
d49 7
a55 2
	{ KB_NODEAD, "nodeadkeys" },
	{ KB_DVORAK, "dvorak" },
d532 2
a533 1
            if (KB_VARIANT(wsenc) == kbdvar[i].val) {
@


1.10
log
@Don't set xkblayout from wscons setting if specified in xorg.conf.

Problem noticed, and patch provided by  Mike Belopuhov. Thanks.
@
text
@d514 1
@


1.9
log
@terminate xf86Msg() string with newline; ok matthieu@@
@
text
@d502 2
@


1.8
log
@Additional fix for the wscons keyboard layout detection code.
If the layout is 'user', fall back to the "us" layout.

Problem spotted by naddy@@.
@
text
@d511 1
a511 1
	xf86Msg(X_INFO, "%s: ignoring \"user\" wscons layout", pInfo->name);
@


1.7
log
@Update to xf86-input-keyboard 1.4.0. tested by many with xserver 1.8.
ok oga@@, todd@@.
@
text
@d25 1
d63 2
a501 2
    if (xf86findOption(pInfo->options, "XkbLayout") != NULL)
        return TRUE;
d509 3
a511 2
    if (KB_ENCODING(wsenc) == KB_USER)
	/* Don't try to set XkbLayout */
d513 1
@


1.6
log
@split the KB_VARTAB code in wscons autodetection so that it understands
both XkbOptions and XkbVariant. now we can understand the .dvorak,
.nodeadkeys and .swapctrlcaps wscons variants and pass them correctly onto XKB.
Means that xmodmap or setxkbmap magic isn't needed in those cases
anymore.

"no objections" matthieu@@. Diff from Tobias Ulmer (tobiasu at tmux dot
org); thanks!
@
text
@a330 45
#define ModifierSet(k) ((modifiers & (k)) == (k))

static
Bool SpecialKey(InputInfoPtr pInfo, int key, Bool down, int modifiers)
{
  KbdDevPtr pKbd = (KbdDevPtr) pInfo->private;

  if(!pKbd->vtSwitchSupported)
      return FALSE;

  if ((ModifierSet(ControlMask | AltMask)) ||
      (ModifierSet(ControlMask | AltLangMask))) {
      if (VTSwitchEnabled && !xf86Info.vtSysreq && !xf86Info.dontVTSwitch) {
         switch (key) {
             case KEY_F1:
             case KEY_F2:
             case KEY_F3:
             case KEY_F4:
             case KEY_F5:
             case KEY_F6:
             case KEY_F7:
             case KEY_F8:
             case KEY_F9:
             case KEY_F10:
#ifdef VT_ACTIVATE
                  if (down) {
                    ioctl(xf86Info.consoleFd, VT_ACTIVATE, key - KEY_F1 + 1);
                    return TRUE;
                  }
#endif
             case KEY_F11:
             case KEY_F12:
#ifdef VT_ACTIVATE
                  if (down) {
                    ioctl(xf86Info.consoleFd, VT_ACTIVATE, key - KEY_F11 + 11);
                    return TRUE;
                  }
#endif
         }
      }
    }

    return FALSE;
}

a551 1
    pKbd->SpecialKey	= SpecialKey;
a553 1
    pKbd->GetSpecialKey = NULL;
@


1.5
log
@Convert some wscons keyboard layouts to correct X names. -moj
ok @@johan @@oga and @@matthieu
@
text
@d45 12
a56 1
} kbdenc[] = { KB_OVRENC, KB_ENCTAB, { 0 } }, kbdvar[] = { KB_VARTAB, { 0 } };
d564 1
a564 1
    if (xf86findOption(pInfo->options, "XkbOptions") == NULL)
d567 8
d576 2
a577 2
			pInfo->name, kbdvar[i].name);
                xf86addNewOption(pInfo->options, "XkbOptions", kbdvar[i].name);
@


1.4
log
@If the wskbd map is 'user' don't try to set the xkb layout.
Tested by okan@@ ok oga@@.
@
text
@d34 8
d45 1
a45 1
} kbdenc[] = { KB_ENCTAB, { 0 } }, kbdvar[] = { KB_VARTAB, { 0 } };
@


1.3
log
@When running without an xorg.conf file, use the current wscons keymap
to setup XkbLayout and XkbOptions. Idea and original code from reyk@@,
some tweaks by me. ok oga@@.
@
text
@d534 4
d539 1
a539 1
        if (KB_ENCODING(wsenc) == kbdenc[i].val) {
@


1.2
log
@- Restore some local OpenBSD changes that got lost when the file moved to
xf86-input-keyboard: privsep support, LK[24]01 support.
- fix parameters order in printWsType().
@
text
@d30 10
d409 3
d472 1
a472 1
    if( prot == PROT_WSCONS) {
d518 31
@


1.1
log
@Initial revision
@
text
@d388 1
a388 1
    xf86Msg(X_PROBED, "%s: Keyboard type: %s\n", type, devname); 
d437 5
a441 1
	pInfo->fd = open(s, O_RDONLY | O_NONBLOCK | O_EXCL);
d478 1
a478 1
           case WSKBD_TYPE_ADB:
d488 3
a490 3
     case WSKBD_TYPE_SUN5:
	     xf86Msg(X_PROBED, "Keyboard type: Sun5\n");
	     break;
d492 6
@


1.1.1.1
log
@xf86-input-keyboard 1.2.2
@
text
@@
