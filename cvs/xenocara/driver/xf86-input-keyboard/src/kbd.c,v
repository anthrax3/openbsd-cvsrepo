head	1.22;
access;
symbols
	OPENBSD_6_1:1.22.0.2
	OPENBSD_6_1_BASE:1.22
	OPENBSD_6_0:1.21.0.12
	OPENBSD_6_0_BASE:1.21
	OPENBSD_5_9:1.21.0.10
	OPENBSD_5_9_BASE:1.21
	OPENBSD_5_8:1.21.0.8
	OPENBSD_5_8_BASE:1.21
	OPENBSD_5_7:1.21.0.6
	OPENBSD_5_7_BASE:1.21
	OPENBSD_5_6:1.21.0.4
	OPENBSD_5_6_BASE:1.21
	OPENBSD_5_5:1.21.0.2
	OPENBSD_5_5_BASE:1.21
	OPENBSD_5_4:1.20.0.2
	OPENBSD_5_4_BASE:1.20
	OPENBSD_5_3:1.19.0.2
	OPENBSD_5_3_BASE:1.19
	OPENBSD_5_2:1.18.0.4
	OPENBSD_5_2_BASE:1.18
	OPENBSD_5_1_BASE:1.18
	OPENBSD_5_1:1.18.0.2
	OPENBSD_5_0:1.15.0.2
	OPENBSD_5_0_BASE:1.15
	OPENBSD_4_9:1.11.0.2
	OPENBSD_4_9_BASE:1.11
	OPENBSD_4_8:1.10.0.4
	OPENBSD_4_8_BASE:1.10
	OPENBSD_4_7:1.6.0.4
	OPENBSD_4_7_BASE:1.6
	OPENBSD_4_6:1.6.0.2
	OPENBSD_4_6_BASE:1.6
	OPENBSD_4_5:1.5.0.2
	OPENBSD_4_5_BASE:1.5
	OPENBSD_4_4:1.4.0.2
	OPENBSD_4_4_BASE:1.4
	OPENBSD_4_3_BASE:1.3
	OPENBSD_4_3:1.3.0.2
	v1_2_2:1.1.1.2
	OPENBSD_4_2:1.2.0.2
	OPENBSD_4_2_BASE:1.2
	v1_1_1:1.1.1.1
	xorg:1.1.1;
locks; strict;
comment	@ * @;


1.22
date	2017.01.22.09.53.08;	author matthieu;	state Exp;
branches;
next	1.21;
commitid	Q0IJuT8efeR0LJns;

1.21
date	2013.11.11.16.52.00;	author shadchin;	state Exp;
branches;
next	1.20;

1.20
date	2013.05.03.09.32.18;	author shadchin;	state Exp;
branches;
next	1.19;

1.19
date	2012.08.16.16.38.04;	author shadchin;	state Exp;
branches;
next	1.18;

1.18
date	2012.01.06.08.03.53;	author shadchin;	state Exp;
branches;
next	1.17;

1.17
date	2011.09.17.13.39.30;	author shadchin;	state Exp;
branches;
next	1.16;

1.16
date	2011.08.21.09.11.07;	author matthieu;	state Exp;
branches;
next	1.15;

1.15
date	2011.06.29.20.00.23;	author matthieu;	state Exp;
branches;
next	1.14;

1.14
date	2011.05.30.10.52.58;	author shadchin;	state Exp;
branches;
next	1.13;

1.13
date	2011.04.22.18.33.36;	author shadchin;	state Exp;
branches;
next	1.12;

1.12
date	2011.03.08.07.59.23;	author matthieu;	state Exp;
branches;
next	1.11;

1.11
date	2010.11.27.14.41.06;	author matthieu;	state Exp;
branches;
next	1.10;

1.10
date	2010.08.04.22.28.36;	author matthieu;	state Exp;
branches;
next	1.9;

1.9
date	2010.08.04.21.45.32;	author matthieu;	state Exp;
branches;
next	1.8;

1.8
date	2010.07.27.19.33.03;	author matthieu;	state Exp;
branches;
next	1.7;

1.7
date	2010.07.27.19.06.44;	author matthieu;	state Exp;
branches;
next	1.6;

1.6
date	2009.05.03.14.57.17;	author matthieu;	state Exp;
branches;
next	1.5;

1.5
date	2008.08.27.20.00.22;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2008.04.16.19.45.22;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2007.11.24.19.09.38;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2006.11.28.20.31.31;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.26.19.53.15;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.11.26.19.53.15;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2007.11.24.18.52.14;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.22
log
@Update to xf86-input-keyboard 1.9.0
@
text
@/*
 * Copyright (c) 2002 by The XFree86 Project, Inc.
 * Author: Ivan Pascal.
 *
 * Based on the code from
 * xf86Config.c which is
 * Copyright 1991-2002 by The XFree86 Project, Inc.
 * Copyright 1997 by Metro Link, Inc.
 * xf86Events.c and xf86Io.c which are
 * Copyright 1990,91 by Thomas Roell, Dinkelscherben, Germany.
 */

#ifdef HAVE_CONFIG_H
#include "config.h"
#endif

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <unistd.h>
#include <xorg-server.h>

#include <X11/X.h>
#include <X11/Xproto.h>

#include "xf86.h"
#include "atKeynames.h"
#include "xf86Privstr.h"

#include <X11/extensions/XI.h>
#include <X11/extensions/XIproto.h>
#include "extnsionst.h"
#include "extinit.h"
#include "inputstr.h"

#include "xf86Xinput.h"
#include "xf86_OSproc.h"
#include "xf86OSKbd.h"
#include "compiler.h"

#include "exevents.h"
#include <X11/Xatom.h>
#include "xserver-properties.h"

#include "xkbstr.h"
#include "xkbsrv.h"

#if GET_ABI_MAJOR(ABI_XINPUT_VERSION) >= 23
#define HAVE_THREADED_INPUT	1
#endif

#define CAPSFLAG	1
#define NUMFLAG		2
#define SCROLLFLAG	4
#define MODEFLAG	8
#define COMPOSEFLAG	16
/* Used to know when the first DEVICE_ON after a DEVICE_INIT is called */
#define INITFLAG	(1U << 31)

static int KbdPreInit(InputDriverPtr drv, InputInfoPtr pInfo, int flags);
static int KbdProc(DeviceIntPtr device, int what);
static void KbdCtrl(DeviceIntPtr device, KeybdCtrl *ctrl);
static void KbdBell(int percent, DeviceIntPtr dev, pointer ctrl, int unused);
static void PostKbdEvent(InputInfoPtr pInfo, unsigned int key, Bool down);

static void InitKBD(InputInfoPtr pInfo, Bool init);
static void UpdateLeds(InputInfoPtr pInfo);

static const char *kbdDefaults[] = {
#ifdef __NetBSD__
#ifdef DEFAULT_TO_WSKBD
    "Protocol",		"wskbd",
#else
    "Protocol",		"standard",
#endif
#else /* NetBSD */
    "Protocol",		"standard",
#endif /* NetBSD */
    "XkbRules",		XKB_DFLT_RULES,
    "XkbModel",		"pc105",
    "XkbLayout",	"us",
    NULL
};

static char *xkb_rules;
static char *xkb_model;
static char *xkb_layout;
static char *xkb_variant;
static char *xkb_options;

_X_EXPORT InputDriverRec KBD = {
    1,
    "kbd",
    NULL,
    KbdPreInit,
    NULL,
    NULL
};

_X_EXPORT InputDriverRec KEYBOARD = {
    1,
    "keyboard",
    NULL,
    KbdPreInit,
    NULL,
    NULL
};

static XF86ModuleVersionInfo xf86KbdVersionRec = {
    "kbd",
    MODULEVENDORSTRING,
    MODINFOSTRING1,
    MODINFOSTRING2,
    XORG_VERSION_CURRENT,
    PACKAGE_VERSION_MAJOR, PACKAGE_VERSION_MINOR, PACKAGE_VERSION_PATCHLEVEL,
    ABI_CLASS_XINPUT,
    ABI_XINPUT_VERSION,
    MOD_CLASS_XINPUT,
    {0, 0, 0, 0}
};

static pointer
xf86KbdPlug(pointer module, pointer options, int *errmaj, int *errmin)
{
    xf86AddInputDriver(&KBD, module, 0);
    return module;
}

_X_EXPORT XF86ModuleData kbdModuleData = {
    &xf86KbdVersionRec,
    xf86KbdPlug,
    NULL
};

static int
KbdPreInit(InputDriverPtr drv, InputInfoPtr pInfo, int flags)
{
    KbdDevPtr pKbd;
    char *s;
    const char **defaults;
    int rc = Success;

    /* Initialise the InputInfoRec. */
    pInfo->type_name = XI_KEYBOARD;
    pInfo->device_control = KbdProc;
    /*
     * We don't specify our own read_input function. We expect
     * an OS specific readInput() function to handle this.
     */
    pInfo->read_input = NULL;
    pInfo->control_proc = NULL;
    pInfo->switch_mode = NULL;
    pInfo->fd = -1;
    pInfo->dev = NULL;

    defaults = kbdDefaults;
    xf86CollectInputOptions(pInfo, defaults);
    xf86ProcessCommonOptions(pInfo, pInfo->options); 

    if (!(pKbd = calloc(sizeof(KbdDevRec), 1))) {
        rc = BadAlloc;
        goto out;
    }

    pInfo->private = pKbd;
    pKbd->PostEvent = PostKbdEvent;

    if (!xf86OSKbdPreInit(pInfo)) {
        rc = BadAlloc;
        goto out;
    }

    if (!pKbd->OpenKeyboard(pInfo)) {
        rc = BadMatch;
        goto out;
    }

    if ((s = xf86SetStrOption(pInfo->options, "XLeds", NULL))) {
        char *l, *end;
        unsigned int i;
        l = strtok(s, " \t\n");
        while (l) {
    	    i = strtoul(l, &end, 0);
    	    if (*end == '\0')
    	        pKbd->xledsMask |= 1L << (i - 1);
    	    else {
    	        xf86Msg(X_ERROR, "\"%s\" is not a valid XLeds value", l);
    	    }
    	    l = strtok(NULL, " \t\n");
        }
        free(s);
    }

    xkb_rules = xf86SetStrOption(pInfo->options, "XkbRules", NULL);
    xkb_model = xf86SetStrOption(pInfo->options, "XkbModel", NULL);
    xkb_layout = xf86SetStrOption(pInfo->options, "XkbLayout", NULL);
    xkb_variant = xf86SetStrOption(pInfo->options, "XkbVariant", NULL);
    xkb_options = xf86SetStrOption(pInfo->options, "XkbOptions", NULL);

    pKbd->CustomKeycodes = xf86SetBoolOption(pInfo->options, "CustomKeycodes",
                                             FALSE);

out:
  return rc;
}

static void
KbdBell(int percent, DeviceIntPtr dev, pointer ctrl, int unused)
{
   InputInfoPtr pInfo = (InputInfoPtr) dev->public.devicePrivate;
   KbdDevPtr pKbd = (KbdDevPtr) pInfo->private;
   pKbd->Bell(pInfo, percent, ((KeybdCtrl*) ctrl)->bell_pitch,
                              ((KeybdCtrl*) ctrl)->bell_duration);
}

static void
UpdateLeds(InputInfoPtr pInfo)
{
    KbdDevPtr pKbd = (KbdDevPtr) pInfo->private;
    unsigned long leds = 0;

    if (pKbd->keyLeds & CAPSFLAG)    leds |= XLED1;
    if (pKbd->keyLeds & NUMFLAG)     leds |= XLED2;
    if (pKbd->keyLeds & SCROLLFLAG ||
        pKbd->keyLeds & MODEFLAG)    leds |= XLED3;
    if (pKbd->keyLeds & COMPOSEFLAG) leds |= XLED4;

    pKbd->leds = (pKbd->leds & pKbd->xledsMask) | (leds & ~pKbd->xledsMask);
    pKbd->SetLeds(pInfo, pKbd->leds);
}

static void
KbdCtrl( DeviceIntPtr device, KeybdCtrl *ctrl)
{
   unsigned long leds;
   InputInfoPtr pInfo = (InputInfoPtr) device->public.devicePrivate;
   KbdDevPtr pKbd = (KbdDevPtr) pInfo->private;

   if ( ctrl->leds & XLED1) {
       pKbd->keyLeds |= CAPSFLAG;
   } else {
       pKbd->keyLeds &= ~CAPSFLAG;
   }
   if ( ctrl->leds & XLED2) {
       pKbd->keyLeds |= NUMFLAG;
   } else {
       pKbd->keyLeds &= ~NUMFLAG;
   }
   if ( ctrl->leds & XLED3) {
       pKbd->keyLeds |= SCROLLFLAG;
   } else {
       pKbd->keyLeds &= ~SCROLLFLAG;
   }
   if ( ctrl->leds & (XCOMP|XLED4) ) {
       pKbd->keyLeds |= COMPOSEFLAG;
   } else {
       pKbd->keyLeds &= ~COMPOSEFLAG;
   }
   leds = ctrl->leds & ~(XCAPS | XNUM | XSCR); /* ??? */
   pKbd->leds = leds;
  pKbd->SetLeds(pInfo, pKbd->leds);
}

static void
InitKBD(InputInfoPtr pInfo, Bool init)
{
  KbdDevPtr pKbd = (KbdDevPtr) pInfo->private;

  pKbd->scanPrefix      = 0;

  if (init) {
      pKbd->keyLeds = pKbd->GetLeds(pInfo);
      UpdateLeds(pInfo);
      pKbd->keyLeds |= INITFLAG;
  } else {
      unsigned long leds = pKbd->keyLeds;

      pKbd->keyLeds = pKbd->GetLeds(pInfo);
      UpdateLeds(pInfo);
      if ((pKbd->keyLeds & CAPSFLAG) !=
	  ((leds & INITFLAG) ? 0 : (leds & CAPSFLAG))) {
	  pKbd->PostEvent(pInfo, KEY_CapsLock, TRUE);
	  pKbd->PostEvent(pInfo, KEY_CapsLock, FALSE);
      }
      if ((pKbd->keyLeds & NUMFLAG) !=
	  (leds & INITFLAG ? 0 : leds & NUMFLAG)) {
	  pKbd->PostEvent(pInfo, KEY_NumLock, TRUE);
	  pKbd->PostEvent(pInfo, KEY_NumLock, FALSE);
      }
  }
}

static int
KbdProc(DeviceIntPtr device, int what)
{

  InputInfoPtr pInfo = device->public.devicePrivate;
  KbdDevPtr pKbd = (KbdDevPtr) pInfo->private;
  XkbRMLVOSet rmlvo;
  KeySymsRec           keySyms;
  CARD8                modMap[MAP_LENGTH];
  int                  ret;

  switch (what) {
     case DEVICE_INIT:
         ret = pKbd->KbdInit(pInfo, what);
         if (ret != Success)
             return ret;

         pKbd->KbdGetMapping(pInfo, &keySyms, modMap);

         device->public.on = FALSE;
         rmlvo.rules = xkb_rules;
         rmlvo.model = xkb_model;
         rmlvo.layout = xkb_layout;
         rmlvo.variant = xkb_variant;
         rmlvo.options = xkb_options;

         if (!InitKeyboardDeviceStruct(device, &rmlvo, KbdBell, KbdCtrl))
         {
             xf86Msg(X_ERROR, "%s: Keyboard initialization failed. This "
                     "could be a missing or incorrect setup of "
                     "xkeyboard-config.\n", device->name);

             return BadValue;
         }
# ifdef XI_PROP_DEVICE_NODE
         {
             const char *device_node =
                 xf86CheckStrOption(pInfo->options, "Device", NULL);

             if (device_node)
             {
                 Atom prop_device = MakeAtom(XI_PROP_DEVICE_NODE,
                                             strlen(XI_PROP_DEVICE_NODE), TRUE);
                 XIChangeDeviceProperty(device, prop_device, XA_STRING, 8,
                                        PropModeReplace, strlen(device_node),
                                        device_node, FALSE);
             }
         }
# endif /* XI_PROP_DEVICE_NODE */
         InitKBD(pInfo, TRUE);
         break;
  case DEVICE_ON:
    if (device->public.on)
	break;
    /*
     * Set the keyboard into "direct" mode and turn on
     * event translation.
     */
    if ((ret = pKbd->KbdOn(pInfo, what)) != Success)
	return ret;
    /*
     * Discard any pending input after a VT switch to prevent the server
     * passing on parts of the VT switch sequence.
     */
    if (pInfo->fd >= 0) {
	xf86FlushInput(pInfo->fd);
#if HAVE_THREADED_INPUT
	xf86AddEnabledDevice(pInfo);
#else
	AddEnabledDevice(pInfo->fd);
#endif
    }

    device->public.on = TRUE;
    InitKBD(pInfo, FALSE);
    break;

  case DEVICE_CLOSE:
  case DEVICE_OFF:

    /*
     * Restore original keyboard directness and translation.
     */
    if (pInfo->fd != -1) {
#if HAVE_THREADED_INPUT
      xf86RemoveEnabledDevice(pInfo);
#else
      RemoveEnabledDevice(pInfo->fd);
#endif
    }
    pKbd->KbdOff(pInfo, what);
    device->public.on = FALSE;
    break;

  default:
    return BadValue;
  }
  return (Success);
}

static void
PostKbdEvent(InputInfoPtr pInfo, unsigned int scanCode, Bool down)
{

  KbdDevPtr    pKbd = (KbdDevPtr) pInfo->private;
  DeviceIntPtr device = pInfo->dev;
  KeyClassRec  *keyc = device->key;
  int state;

#ifdef DEBUG
  LogMessageVerbSigSafe(X_INFO, -1, "kbd driver rec scancode: 0x%x %s\n", scanCode, down ? "down" : "up");
#endif

  /*
   * First do some special scancode remapping ...
   */
  if (pKbd->RemapScanCode != NULL) {
     if (pKbd->RemapScanCode(pInfo, (int*) &scanCode))
         return;
  } else {
     if (pKbd->scancodeMap != NULL) {
         TransMapPtr map = pKbd->scancodeMap; 
         if (scanCode >= map->begin && scanCode < map->end)
             scanCode = map->map[scanCode - map->begin];
     }
  }

  /*
   * PC keyboards generate separate key codes for
   * Alt+Print and Control+Pause but in the X keyboard model
   * they need to get the same key code as the base key on the same
   * physical keyboard key.
   */

  state = XkbStateFieldFromRec(&keyc->xkbInfo->state);

  if (((state & AltMask) == AltMask) && (scanCode == KEY_SysReqest))
    scanCode = KEY_Print;
  else if (scanCode == KEY_Break)
    scanCode = KEY_Pause;

  xf86PostKeyboardEvent(device, scanCode + MIN_KEYCODE, down);
}
@


1.21
log
@Update to xf86-input-keyboard 1.8.0.

ok matthieu@@
@
text
@d48 4
a59 3
#if GET_ABI_MAJOR(ABI_XINPUT_VERSION) < 12
static InputInfoPtr KbdPreInit(InputDriverPtr drv, IDevPtr dev, int flags);
#else
a60 1
#endif
a68 18
_X_EXPORT InputDriverRec KBD = {
	1,
	"kbd",
	NULL,
	KbdPreInit,
	NULL,
	NULL
};

_X_EXPORT InputDriverRec KEYBOARD = {
	1,
	"keyboard",
	NULL,
	KbdPreInit,
	NULL,
	NULL
};

d91 8
a98 3
#if GET_ABI_MAJOR(ABI_XINPUT_VERSION) < 12
static int
NewKbdPreInit(InputDriverPtr drv, InputInfoPtr pInfo, int flags);
d100 8
a107 4
static InputInfoPtr
KbdPreInit(InputDriverPtr drv, IDevPtr dev, int flags)
{
    InputInfoPtr pInfo;
d109 12
a120 2
    if (!(pInfo = xf86AllocateInput(drv, 0)))
	return NULL;
d122 6
a127 14
    pInfo->name = dev->identifier;
    pInfo->flags = XI86_KEYBOARD_CAPABLE;
    pInfo->conversion_proc = NULL;
    pInfo->reverse_conversion_proc = NULL;
    pInfo->private_flags = 0;
    pInfo->always_core_feedback = NULL;
    pInfo->conf_idev = dev;
    pInfo->close_proc = NULL;

    if (NewKbdPreInit(drv, pInfo, flags) == Success)
    {
        pInfo->flags |= XI86_CONFIGURED;
        return pInfo;
    }
d129 5
a133 3
    xf86DeleteInput(pInfo, 0);
    return NULL;
}
a135 3
NewKbdPreInit(InputDriverPtr drv, InputInfoPtr pInfo, int flags)
#else
static int
a136 1
#endif
d157 1
a157 5
    xf86CollectInputOptions(pInfo, defaults
#if GET_ABI_MAJOR(ABI_XINPUT_VERSION) < 12
            , NULL
#endif
            );
d299 1
d313 7
a319 1
#if GET_ABI_MAJOR(ABI_XINPUT_VERSION) >= 5
d321 3
a323 6
             XkbRMLVOSet rmlvo;
             rmlvo.rules = xkb_rules;
             rmlvo.model = xkb_model;
             rmlvo.layout = xkb_layout;
             rmlvo.variant = xkb_variant;
             rmlvo.options = xkb_options;
d325 1
a325 8
             if (!InitKeyboardDeviceStruct(device, &rmlvo, KbdBell, KbdCtrl))
             {
                 xf86Msg(X_ERROR, "%s: Keyboard initialization failed. This "
                         "could be a missing or incorrect setup of "
                         "xkeyboard-config.\n", device->name);

                 return BadValue;
             }
a341 11
#else
         {
             XkbComponentNamesRec xkbnames;
             memset(&xkbnames, 0, sizeof(xkbnames));
             XkbSetRulesDflts(xkb_rules, xkb_model, xkb_layout,
                              xkb_variant, xkb_options);
             XkbInitKeyboardDeviceStruct(device, &xkbnames, &keySyms,
                                         modMap, KbdBell,
                                         (KbdCtrlProcPtr)KbdCtrl);
         }
#endif /* XINPUT ABI 5*/
d359 3
d363 1
d376 4
a379 1
    if (pInfo->fd != -1)
d381 2
a435 37

static void
xf86KbdUnplug(pointer	p)
{
}

static pointer
xf86KbdPlug(pointer	module,
	    pointer	options,
	    int		*errmaj,
	    int		*errmin)
{
    xf86AddInputDriver(&KBD, module, 0);

    return module;
}

static XF86ModuleVersionInfo xf86KbdVersionRec =
{
    "kbd",
    MODULEVENDORSTRING,
    MODINFOSTRING1,
    MODINFOSTRING2,
    XORG_VERSION_CURRENT,
    PACKAGE_VERSION_MAJOR, PACKAGE_VERSION_MINOR, PACKAGE_VERSION_PATCHLEVEL,
    ABI_CLASS_XINPUT,
    ABI_XINPUT_VERSION,
    MOD_CLASS_XINPUT,
    {0, 0, 0, 0}		/* signature, to be patched into the file by */
				/* a tool */
};

_X_EXPORT XF86ModuleData kbdModuleData = {
    &xf86KbdVersionRec,
    xf86KbdPlug,
    xf86KbdUnplug
};
@


1.20
log
@Update to xf86-input-keyboard 1.7.0.

ok matthieu@@
@
text
@d88 4
d93 4
@


1.19
log
@Update to 1.6.2.

ok matthieu@@
@
text
@d413 1
a413 1
  ErrorF("kbd driver rec scancode: 0x02%x %s\n", scanCode, down?"down":"up");
d415 1
a415 1
	  
@


1.18
log
@Update to 1.6.1.

ok matthieu@@
@
text
@d41 4
d335 15
@


1.17
log
@Cleaning of current solution for 'Kill X on Ctrl+Alt+Backspace on default'

ok matthieu@@
@
text
@a90 8
static const char *kbd98Defaults[] = {
    "Protocol",		"standard",
    "XkbRules",		"xfree98",
    "XkbModel",		"pc98",
    "XkbLayout",	"jp",
    NULL
};

d153 1
a153 4
    if (!xf86IsPc98())
        defaults = kbdDefaults;
    else
        defaults = kbd98Defaults;
d377 3
d391 1
d418 1
a418 2
  if (!xf86IsPc98()) {
    int state;
d420 4
a423 7
    state = XkbStateFieldFromRec(&keyc->xkbInfo->state);

    if (((state & AltMask) == AltMask) && (scanCode == KEY_SysReqest))
      scanCode = KEY_Print;
    else if (scanCode == KEY_Break)
      scanCode = KEY_Pause;
  }
@


1.16
log
@Fix initial xkb_options setting. Restores Ctrl+Alt+Backspace behaviour.
Strange that no one reported it beeing broken.
@
text
@a210 4
#ifdef USE_XKEYBOARD_CONFIG
    if (xkb_options == NULL)
	xkb_options = strdup("terminate:ctrl_alt_bksp");
#endif
@


1.15
log
@Code to configure the xkb layout and options from wscons setup
has moved to the X server wscons hotplug driver.

Tested by many, ok oga@@
@
text
@d211 4
@


1.14
log
@If you do not have XkbOptions in xorg.conf, it is automatically set to
"terminate: ctrl_alt_bksp" (only if XENOCARA_USE_XKEYBOARD_CONFIG=Yes)

tested ajacoutot@@, ok matthieu@@
@
text
@d87 1
a210 5

#ifdef USE_XKEYBOARD_CONFIG
    if (xkb_options == NULL)
        xkb_options = "terminate:ctrl_alt_bksp";
#endif
@


1.13
log
@update to xf86-input-keyboard 1.6.0

ok matthieu@@
@
text
@d211 5
@


1.12
log
@add a new build switch 'XENOCARA_USE_XKEYBOARD_CONFIG' to enable
the use of xkeyboard-config xkb definitions instead of the old xkbdata.
This will make testing easier. No changes in default builds.
ok shadchin@@
@
text
@d52 1
d54 3
a62 1
static void SetXkbOption(InputInfoPtr pInfo, char *name, char **option);
a83 3
#ifdef XQUEUE 
    "Protocol",		"Xqueue",
#else
a84 1
#endif
a86 1
    "CustomKeycodes",	"off",
a90 3
#ifdef XQUEUE
    "Protocol",		"Xqueue",
#else
a91 1
#endif
a94 1
    "CustomKeycodes",	"off",
d104 6
a109 2
static void
SetXkbOption(InputInfoPtr pInfo, char *name, char **option)
d111 4
a114 1
   char *s;
d116 13
a128 8
   if ((s = xf86SetStrOption(pInfo->options, name, NULL))) {
       if (!s[0]) {
           free(s);
           *option = NULL;
       } else {
           *option = s;
           xf86Msg(X_CONFIG, "%s: %s: \"%s\"\n", pInfo->name, name, s);
       }
d130 3
d135 6
a140 2
static InputInfoPtr
KbdPreInit(InputDriverPtr drv, IDevPtr dev, int flags)
a141 1
    InputInfoPtr pInfo;
a142 1
    MessageType from = X_DEFAULT;
d144 2
a145 3

    if (!(pInfo = xf86AllocateInput(drv, 0)))
	return NULL;
a147 1
    pInfo->name = dev->identifier;
a148 1
    pInfo->flags = XI86_KEYBOARD_CAPABLE;
a155 1
    pInfo->close_proc = NULL;
a156 2
    pInfo->conversion_proc = NULL;
    pInfo->reverse_conversion_proc = NULL;
a158 3
    pInfo->private_flags = 0;
    pInfo->always_core_feedback = NULL;
    pInfo->conf_idev = dev;
d161 1
a161 1
        xf86CollectInputOptions(pInfo, kbdDefaults, NULL);
d163 6
a168 1
        xf86CollectInputOptions(pInfo, kbd98Defaults, NULL);
d171 4
a174 2
    if (!(pKbd = calloc(sizeof(KbdDevRec), 1)))
        return pInfo;
d179 4
a182 2
    if (!xf86OSKbdPreInit(pInfo))
        return pInfo;
d185 2
a186 1
        return pInfo;
d205 5
a209 16
    SetXkbOption(pInfo, "XkbRules", &xkb_rules);
    SetXkbOption(pInfo, "XkbModel", &xkb_model);
    SetXkbOption(pInfo, "XkbLayout", &xkb_layout);
    SetXkbOption(pInfo, "XkbVariant", &xkb_variant);
    SetXkbOption(pInfo, "XkbOptions", &xkb_options);

  pKbd->CustomKeycodes = FALSE;
  from = X_DEFAULT; 
  if (xf86FindOption(pInfo->options, "CustomKeycodes")) {
      pKbd->CustomKeycodes = xf86SetBoolOption(pInfo->options, "CustomKeycodes",
                                               pKbd->CustomKeycodes);
     from = X_CONFIG;
  }

  xf86Msg(from, "%s: CustomKeycodes %s\n",
               pInfo->name, pKbd->CustomKeycodes ? "enabled" : "disabled");
d211 2
a212 1
  pInfo->flags |= XI86_CONFIGURED;
d214 2
a215 1
  return pInfo;
a277 1
  xEvent          kevent;
a278 43
#if GET_ABI_MAJOR(ABI_XINPUT_VERSION) < 1
  DeviceIntPtr    pKeyboard = pInfo->dev;
  KeyClassRec     *keyc = pKeyboard->key;
  KeySym          *map = keyc->curKeySyms.map;
  unsigned int    i;
#endif

  kevent.u.keyButtonPointer.time = GetTimeInMillis();
  kevent.u.keyButtonPointer.rootX = 0;
  kevent.u.keyButtonPointer.rootY = 0;

/* The server does this for us with i-h. */
#if GET_ABI_MAJOR(ABI_XINPUT_VERSION) < 1
  /*
   * Hmm... here is the biggest hack of every time !
   * It may be possible that a switch-vt procedure has finished BEFORE
   * you released all keys neccessary to do this. That peculiar behavior
   * can fool the X-server pretty much, cause it assumes that some keys
   * were not released. TWM may stuck alsmost completly....
   * OK, what we are doing here is after returning from the vt-switch
   * exeplicitely unrelease all keyboard keys before the input-devices
   * are reenabled.
   */
  for (i = keyc->curKeySyms.minKeyCode, map = keyc->curKeySyms.map;
       i < keyc->curKeySyms.maxKeyCode;
       i++, map += keyc->curKeySyms.mapWidth)
     if (KeyPressed(i))
      {
        switch (*map) {
        /* Don't release the lock keys */
        case XK_Caps_Lock:
        case XK_Shift_Lock:
        case XK_Num_Lock:
        case XK_Scroll_Lock:
        case XK_Kana_Lock:
          break;
        default:
          kevent.u.u.detail = i;
          kevent.u.u.type = KeyRelease;
          (* pKeyboard->public.processInputProc)(&kevent, pKeyboard, 1);
        }
      }
#endif
a402 4
  /* Disable any keyboard processing while in suspend */
  if (xf86inSuspend)
      return;

@


1.11
log
@update to xf86-input-keyboard 1.5.0
Tested by ajacoutot@@, shadchin@@, jasper@@ and landry@@. Thanks.
@
text
@d86 1
a86 1
    "XkbRules",		"xorg",
@


1.10
log
@Commit the right version of the file: we want to remove XkbLayout from
the defaults, no XkbModel.
@
text
@d21 2
a22 2
  
#define NEED_EVENTS
d68 1
a68 2
	NULL,
	0
d77 1
a77 36
	NULL,
	0
};

typedef enum {
    OPTION_ALWAYS_CORE,
    OPTION_SEND_CORE_EVENTS,
    OPTION_CORE_KEYBOARD,
    OPTION_DEVICE,
    OPTION_PROTOCOL,
    OPTION_AUTOREPEAT,
    OPTION_XLEDS,
    OPTION_XKB_RULES,
    OPTION_XKB_MODEL,
    OPTION_XKB_LAYOUT,
    OPTION_XKB_VARIANT,
    OPTION_XKB_OPTIONS,
    OPTION_CUSTOM_KEYCODES
} KeyboardOpts;

/* These aren't actually used ... */
static const OptionInfoRec KeyboardOptions[] = {
    { OPTION_ALWAYS_CORE,	"AlwaysCore",	  OPTV_BOOLEAN,	{0}, FALSE },
    { OPTION_SEND_CORE_EVENTS,	"SendCoreEvents", OPTV_BOOLEAN,	{0}, FALSE },
    { OPTION_CORE_KEYBOARD,	"CoreKeyboard",	  OPTV_BOOLEAN,	{0}, FALSE },
    { OPTION_DEVICE,		"Device",	  OPTV_STRING,	{0}, FALSE },
    { OPTION_PROTOCOL,		"Protocol",	  OPTV_STRING,	{0}, FALSE },
    { OPTION_AUTOREPEAT,	"AutoRepeat",	  OPTV_STRING,	{0}, FALSE },
    { OPTION_XLEDS,		"XLeds",	  OPTV_STRING,	{0}, FALSE },
    { OPTION_XKB_RULES,		"XkbRules",	  OPTV_STRING,	{0}, FALSE },
    { OPTION_XKB_MODEL,		"XkbModel",	  OPTV_STRING,	{0}, FALSE },
    { OPTION_XKB_LAYOUT,	"XkbLayout",	  OPTV_STRING,	{0}, FALSE },
    { OPTION_XKB_VARIANT,	"XkbVariant",	  OPTV_STRING,	{0}, FALSE },
    { OPTION_XKB_OPTIONS,	"XkbOptions",	  OPTV_STRING,	{0}, FALSE },
    { OPTION_CUSTOM_KEYCODES,   "CustomKeycodes", OPTV_BOOLEAN,	{0}, FALSE },
    { -1,			NULL,		  OPTV_NONE,	{0}, FALSE }
a85 1
    "AutoRepeat",	"500 30",
a97 1
    "AutoRepeat",	"500 30",
d118 1
a118 1
           xfree(s);
d165 1
a165 1
    if (!(pKbd = xcalloc(sizeof(KbdDevRec), 1)))
d191 1
a191 1
        xfree(s);
@


1.9
log
@Fix the fix of the fix.

Previous iteration would again ignore wscons keyboard.encoding setting.
Now no default xkbLayout is set, unless keyboard.encoding=user.
@
text
@d124 1
a124 1
    "XkbLayout",	"us",
@


1.8
log
@Additional fix for the wscons keyboard layout detection code.
If the layout is 'user', fall back to the "us" layout.

Problem spotted by naddy@@.
@
text
@a123 1
    "XkbModel",		"pc105",
@


1.7
log
@Update to xf86-input-keyboard 1.4.0. tested by many with xserver 1.8.
ok oga@@, todd@@.
@
text
@d125 1
@


1.6
log
@update to xf86-input-keyboard 1.3.2
@
text
@a29 1
#ifdef XINPUT
a33 1
#else
a34 1
#endif
d41 2
a42 8
#ifdef XKB
#include <X11/extensions/XKB.h>
#include <X11/extensions/XKBstr.h>
#include <X11/extensions/XKBsrv.h>
#endif

extern int XkbDfltRepeatDelay;
extern int XkbDfltRepeatInterval;
d50 1
a50 1
#define INITFLAG	(1 << 31)
d54 1
a54 1
static int KbdCtrl(DeviceIntPtr device, KeybdCtrl *ctrl);
a89 7
    OPTION_XKB_DISABLE,
    OPTION_XKB_KEYMAP,
    OPTION_XKB_KEYCODES,
    OPTION_XKB_TYPES,
    OPTION_XKB_COMPAT,
    OPTION_XKB_SYMBOLS,
    OPTION_XKB_GEOMETRY,
a94 1
    OPTION_PANIX106,
a106 7
    { OPTION_XKB_DISABLE,	"XkbDisable",	  OPTV_BOOLEAN,	{0}, FALSE },
    { OPTION_XKB_KEYMAP,	"XkbKeymap",	  OPTV_STRING,	{0}, FALSE },
    { OPTION_XKB_KEYCODES,	"XkbKeycodes",	  OPTV_STRING,	{0}, FALSE },
    { OPTION_XKB_TYPES,		"XkbTypes",	  OPTV_STRING,	{0}, FALSE },
    { OPTION_XKB_COMPAT,	"XkbCompat",	  OPTV_STRING,	{0}, FALSE },
    { OPTION_XKB_SYMBOLS,	"XkbSymbols",	  OPTV_STRING,	{0}, FALSE },
    { OPTION_XKB_GEOMETRY,	"XkbGeometry",	  OPTV_STRING,	{0}, FALSE },
a111 1
    { OPTION_PANIX106,		"Panix106",	  OPTV_BOOLEAN,	{0}, FALSE },
d123 1
a123 1
    "XkbRules",		__XKBDEFRULES__,
a124 1
    "Panix106",		"off",
a128 2
static const char *kbdLayout = "us";

d138 1
a138 2
    "XkbLayout",	"nec/jp",
    "Panix106",		"off",
a142 7
const char *xkbSymbols[] = {
	"XkbDfltRepeatDelay",
	"XkbDfltRepeatInterval",
	NULL,
};

#ifdef XKB
a148 10
static XkbComponentNamesRec xkbnames;
#endif /* XKB */

/*ARGSUSED*/
static const OptionInfoRec *
KeyboardAvailableOptions(void *unused)
{
    return (KeyboardOptions);
}

a164 33

#define ModifierIsSet(k) ((modifiers & (k)) == (k))

static Bool
CommonSpecialKey(int key, Bool down, int modifiers)
{
  if ((!ModifierIsSet(ShiftMask)) &&
      (((ModifierIsSet(ControlMask | AltMask)) ||
        (ModifierIsSet(ControlMask | AltLangMask))))) {
      switch (key) {
	
      case KEY_BackSpace:
	xf86ProcessActionEvent(ACTION_TERMINATE, NULL);
	break;

	/*
	 * The idea here is to pass the scancode down to a list of
	 * registered routines. There should be some standard conventions
	 * for processing certain keys.
	 */
      case KEY_KP_Minus:   /* Keypad - */
	if (down) xf86ProcessActionEvent(ACTION_PREV_MODE, NULL);
	break;
	
      case KEY_KP_Plus:   /* Keypad + */
	if (down) xf86ProcessActionEvent(ACTION_NEXT_MODE, NULL);
	break;
      }
  }
  return FALSE;
}


d194 1
a194 1
    pInfo->always_core_feedback = 0;
a208 2
    xf86LoaderReqSymLists(xkbSymbols, NULL);

a215 19
    if (xf86findOption(pInfo->options, "XkbLayout") == NULL) {
	xf86Msg(X_INFO, "%s: adding default layout %s\n",
		pInfo->name, kbdLayout);
        xf86addNewOption(pInfo->options, "XkbLayout", kbdLayout);
    }

    if ((s = xf86SetStrOption(pInfo->options, "AutoRepeat", NULL))) {
        int delay, rate;
        if (sscanf(s, "%d %d", &delay, &rate) != 2) {
            xf86Msg(X_ERROR, "\"%s\" is not a valid AutoRepeat value", s);
        } else {
            pKbd->delay = delay;
	    XkbDfltRepeatDelay = delay;
            pKbd->rate = rate;
	    XkbDfltRepeatInterval = 1000/rate;
        }
        xfree(s);
    }

d232 5
a236 43
#ifdef XKB

/* XkbDisable must be a server flag but for compatibility we check it here */

  if (xf86FindOption(pInfo->options, "XkbDisable"))
      xf86Msg(X_WARNING,
             "%s: XKB can't be disabled here. Use \"ServerFlags\" section.\n",
              pInfo->name);

  pKbd->noXkb = noXkbExtension;
  if (pKbd->noXkb) {
      xf86Msg(X_CONFIG, "XKB: disabled\n");
  } else {
      SetXkbOption(pInfo, "XkbKeymap", &xkbnames.keymap);
      if (xkbnames.keymap) {
          xf86Msg(X_CONFIG, "%s: XkbKeymap overrides all other XKB settings\n",
                  pInfo->name);
      } else {
          SetXkbOption(pInfo, "XkbRules", &xkb_rules);
          SetXkbOption(pInfo, "XkbModel", &xkb_model);
          SetXkbOption(pInfo, "XkbLayout", &xkb_layout);
          SetXkbOption(pInfo, "XkbVariant", &xkb_variant);
          SetXkbOption(pInfo, "XkbOptions", &xkb_options);

          SetXkbOption(pInfo, "XkbKeycodes", &xkbnames.keycodes);
          SetXkbOption(pInfo, "XkbTypes", &xkbnames.types);
          SetXkbOption(pInfo, "XkbCompat", &xkbnames.compat);
          SetXkbOption(pInfo, "XkbSymbols", &xkbnames.symbols);
          SetXkbOption(pInfo, "XkbGeometry", &xkbnames.geometry);
      }
  }

  if ((xkb_model && !strcmp(xkb_model, "sun")) ||
      (xkb_rules && !strcmp(xkb_rules, "sun")))
       pKbd->sunKbd = TRUE;
#endif

#if defined(SVR4) && defined(i386)
  if ((pKbd->Panix106 =
      xf86SetBoolOption(pInfo->options, "Panix106", FALSE))) {
      xf86Msg(X_CONFIG, "%s: PANIX106: enabled\n", pInfo->name);
  }
#endif
d267 1
a267 1
    int leds = 0;
d279 1
a279 1
static int
d282 1
a282 1
   int leds;
d307 1
a307 9
#ifdef XKB
   if (pKbd->noXkb) {
#endif
       pKbd->leds = (leds & pKbd->xledsMask) | (pKbd->leds & ~pKbd->xledsMask);
#ifdef XKB
  } else {
       pKbd->leds = leds;
  }
#endif
a308 3
  pKbd->autoRepeat = ctrl->autoRepeat;

  return (Success);
a313 1
  char            rad;
a365 8
      if( pKbd->delay <= 375) rad = 0x00;
      else if (pKbd->delay <= 625) rad = 0x20;
      else if (pKbd->delay <= 875) rad = 0x40;
      else                         rad = 0x60;
      if      (pKbd->rate <=  2)   rad |= 0x1F;
      else if (pKbd->rate >= 30)   rad |= 0x00;
      else                         rad |= ((58 / pKbd->rate) - 2);
      pKbd->SetKbdRepeat(pInfo, rad);
d367 1
a367 1
      int leds = pKbd->keyLeds;
d396 38
a433 31
        ret = pKbd->KbdInit(pInfo, what);
	if (ret != Success)
	    return ret;

        pKbd->KbdGetMapping(pInfo, &keySyms, modMap);

        device->public.on = FALSE;
#ifdef XKB
        if (pKbd->noXkb) {
#endif
            InitKeyboardDeviceStruct((DevicePtr) device,
                             &keySyms,
                             modMap,
                             KbdBell,
                             (KbdCtrlProcPtr)KbdCtrl);
#ifdef XKB
        } else {
            if (xkbnames.keymap)
                xkb_rules = NULL;
            XkbSetRulesDflts(xkb_rules, xkb_model, xkb_layout,
                             xkb_variant, xkb_options);
            XkbInitKeyboardDeviceStruct(device,
                                        &xkbnames,
                                        &keySyms,
                                        modMap,
                                        KbdBell,
                                        (KbdCtrlProcPtr)KbdCtrl);
    }
#endif
    InitKBD(pInfo, TRUE);
    break;
a477 8
  KbdFeedbackClassRec *kbdfeed = device->kbdfeed;
  int          specialkey = 0;

  Bool        UsePrefix = FALSE;
  KeySym      *keysym;
  int         keycode;
  unsigned long changeLock = 0;
  static int  lockkeys = 0;
a486 15
#ifndef __OpenBSD__
  if (pKbd->sunKbd) {
     /*
      * XXX XXX XXX:
      *
      * I really don't know what's wrong here, but passing the real
      * scanCode offsets by one from XKB's point of view.
      *
      * (ecd@@skynet.be, 980405)
      */
      scanCode--;
      goto sunKeyboards;
  }
#endif

a501 35
   * and now get some special keysequences
   */

  specialkey = scanCode;

  if (pKbd->GetSpecialKey != NULL) {
     specialkey = pKbd->GetSpecialKey(pInfo, scanCode);
  } else {
     if (pKbd->specialMap != NULL) {
         TransMapPtr map = pKbd->specialMap; 
         if (scanCode >= map->begin && scanCode < map->end)
             specialkey = map->map[scanCode - map->begin];
     }
  }

#ifndef TERMINATE_FALLBACK
#define TERMINATE_FALLBACK 0
#endif
#ifdef XKB
  if (noXkbExtension
#if TERMINATE_FALLBACK
      || specialkey == KEY_BackSpace
#endif
     )
#endif
  {    
      if (CommonSpecialKey(specialkey, down, keyc->state))
	  return;
      if (pKbd->SpecialKey != NULL)
	  if (pKbd->SpecialKey(pInfo, specialkey, down, keyc->state))
	      return;
  }
  
#ifndef __sparc64__
  /*
d507 1
d509 5
a513 1
    if (ModifierDown(AltMask) && (scanCode == KEY_SysReqest))
a517 71
#endif

sunKeyboards:
  /*
   * Now map the scancodes to real X-keycodes ...
   */
  keycode = scanCode + MIN_KEYCODE;
  keysym = (keyc->curKeySyms.map +
	    keyc->curKeySyms.mapWidth * 
	    (keycode - keyc->curKeySyms.minKeyCode));

#ifdef XKB
  if (pKbd->noXkb) {
#endif
  /*
   * Filter autorepeated caps/num/scroll lock keycodes.
   */
  if( down ) {
    switch( keysym[0] ) {
        case XK_Caps_Lock :
          if (lockkeys & CAPSFLAG)
              return;
	  else
	      lockkeys |= CAPSFLAG;
          break;

        case XK_Num_Lock :
          if (lockkeys & NUMFLAG)
              return;
	  else
	      lockkeys |= NUMFLAG;
          break;

        case XK_Scroll_Lock :
          if (lockkeys & SCROLLFLAG)
              return;
	  else
	      lockkeys |= SCROLLFLAG;
          break;
    }
    if (keysym[1] == XF86XK_ModeLock)
    {
      if (lockkeys & MODEFLAG)
          return;
      else
          lockkeys |= MODEFLAG;
    }
  }
  else {
    switch( keysym[0] ) {
        case XK_Caps_Lock :
            lockkeys &= ~CAPSFLAG;
            break;

        case XK_Num_Lock :
            lockkeys &= ~NUMFLAG;
            break;

        case XK_Scroll_Lock :
            lockkeys &= ~SCROLLFLAG;
            break;
    }
    if (keysym[1] == XF86XK_ModeLock)
      lockkeys &= ~MODEFLAG;
  }

  /*
   * LockKey special handling:
   * ignore releases, toggle on & off on presses.
   * Don't deal with the Caps_Lock keysym directly, but check the lock modifier
   */
d519 1
a519 69
   if (keyc->modifierMap[keycode] & LockMask)
       changeLock = CAPSFLAG;
   if (keysym[0] == XK_Num_Lock)
       changeLock = NUMFLAG;
   if (keysym[0] == XK_Scroll_Lock)
       changeLock = SCROLLFLAG;
   if (keysym[1] == XF86XK_ModeLock)
       changeLock = MODEFLAG;

   if (changeLock) {
      if (!down)
          return;

      pKbd->keyLeds &= ~changeLock;

      if (KeyPressed(keycode)) {
	  down = !down;
      } else {
          pKbd->keyLeds |= changeLock;
      }
      UpdateLeds(pInfo);
  }

  if (!pKbd->CustomKeycodes) {
    /*
     * normal, non-keypad keys
     */
    if (scanCode < KEY_KP_7 || scanCode > KEY_KP_Decimal) {
#if !defined(CSRG_BASED) && \
    !defined(__GNU__) && \
     defined(KB_84)
      /*
       * magic ALT_L key on AT84 keyboards for multilingual support
       */
      if (pKbd->kbdType == KB_84 &&
	  ModifierDown(AltMask) &&
	  keysym[2] != NoSymbol)
	{
	  UsePrefix = TRUE;
	}
#endif /* !CSRG_BASED && ... */
    }
  }
#ifdef XKB
  }
#endif

  /*
   * check for an autorepeat-event
   */
  if (down && KeyPressed(keycode)) {
      int num = keycode >> 3;
      int bit = 1 << (keycode & 7);

      if ((pKbd->autoRepeat != AutoRepeatModeOn) ||
	  keyc->modifierMap[keycode] ||
	  !(kbdfeed->ctrl.autoRepeats[num] & bit))
	  return;
  }

   if (UsePrefix) {
      xf86PostKeyboardEvent(device,
              keyc->modifierKeyMap[keyc->maxKeysPerModifier*7], TRUE);
      xf86PostKeyboardEvent(device, keycode, down);
      xf86PostKeyboardEvent(device,
              keyc->modifierKeyMap[keyc->maxKeysPerModifier*7], FALSE);
   } else {
      xf86PostKeyboardEvent(device, keycode, down);
   }
a521 8
ModuleInfoRec KbdInfo = {
    1,
    "KBD",
    NULL,
    0,
    KeyboardAvailableOptions,
};

a532 5
    static Bool Initialised = FALSE;

    if (!Initialised)
	Initialised = TRUE;

@


1.5
log
@xf86-input-keyboard 1.3.1
@
text
@a0 3
/* $XdotOrg: driver/xf86-input-keyboard/src/kbd.c,v 1.19 2005/11/09 21:31:23 kem Exp $ */
/* $XFree86: xc/programs/Xserver/hw/xfree86/input/keyboard/kbd.c,v 1.8 2003/11/03 05:11:47 tsi Exp $ */

a11 1
/* $XdotOrg: driver/xf86-input-keyboard/src/kbd.c,v 1.19 2005/11/09 21:31:23 kem Exp $ */
d211 33
a463 1
  unsigned int    i;
d466 1
d470 2
d692 1
a692 1
#define TERMINATE_FALLBACK 1
d702 1
a702 1
      if (xf86CommonSpecialKey(specialkey, down, keyc->state))
d886 1
a886 1
    if (!Initialised) {
a887 5
#ifndef REMOVE_LOADER_CHECK_MODULE_INFO
	if (xf86LoaderCheckSymbol("xf86AddModuleInfo"))
#endif
	xf86AddModuleInfo(&KbdInfo, module);
    }
@


1.4
log
@When running without an xorg.conf file, use the current wscons keymap
to setup XkbLayout and XkbOptions. Idea and original code from reyk@@,
some tweaks by me. ok oga@@.
@
text
@d62 2
d482 1
a482 2
      pKbd->keyLeds = 0;

d484 1
a484 1

d493 4
a496 1
  } else
d498 11
a567 1
	sleep(1);
@


1.3
log
@merge xf86-input-keyboard 1.2.2
@
text
@a151 1
    "XkbLayout",	"us",
d157 2
d264 6
@


1.2
log
@OpenBSD modifications: no special treatement of sparc keyboard.
@
text
@a116 1
#ifdef XFree86LOADER
a141 1
#endif
a188 1
#ifdef XFree86LOADER
a194 1
#endif
a232 2
    pInfo->motion_history_proc = NULL;
    pInfo->history_size = 0;
d386 16
a401 1
   if ( ctrl->leds & XCOMP ) {
d437 2
d468 2
a812 1
#ifdef XFree86LOADER
d854 1
a854 1
    1, 1, 0,
a866 60


/* Compatibility section: we have a set of module structures here that
 * allows us to load this module as the old keyboard driver. */

#ifndef USE_DEPRECATED_KEYBOARD_DRIVER

ModuleInfoRec KeyboardInfo = {
    1,
    "KEYBOARD",
    NULL,
    0,
    KeyboardAvailableOptions,
};

static pointer
xf86KeyboardPlug(pointer	module,
                 pointer	options,
                 int		*errmaj,
                 int		*errmin)
{
    static Bool Initialised = FALSE;

    if (!Initialised) {
	Initialised = TRUE;
#ifndef REMOVE_LOADER_CHECK_MODULE_INFO
	if (xf86LoaderCheckSymbol("xf86AddModuleInfo"))
#endif
	xf86AddModuleInfo(&KeyboardInfo, module);
    }

    xf86AddInputDriver(&KEYBOARD, module, 0);

    return module;
}

static XF86ModuleVersionInfo xf86KeyboardVersionRec =
{
    "keyboard",
    MODULEVENDORSTRING,
    MODINFOSTRING1,
    MODINFOSTRING2,
    XORG_VERSION_CURRENT,
    1, 0, 0,
    ABI_CLASS_XINPUT,
    ABI_XINPUT_VERSION,
    MOD_CLASS_XINPUT,
    {0, 0, 0, 0}		/* signature, to be patched into the file by */
				/* a tool */
};

_X_EXPORT XF86ModuleData keyboardModuleData = {
    &xf86KeyboardVersionRec,
    xf86KeyboardPlug,
    xf86KbdUnplug
};

#endif /* ! USE_DEPRECATED_KEYBOARD_DRIVER */

#endif /* XFree86LOADER */
@


1.1
log
@Initial revision
@
text
@d581 1
d594 1
@


1.1.1.1
log
@Importing xf86-input-keyboard 1.1.1
@
text
@@


1.1.1.2
log
@xf86-input-keyboard 1.2.2
@
text
@d117 1
d143 1
d191 1
d198 1
d237 2
d392 1
a392 16
   if ( ctrl->leds & XLED1) {
       pKbd->keyLeds |= CAPSFLAG;
   } else {
       pKbd->keyLeds &= ~CAPSFLAG;
   }
   if ( ctrl->leds & XLED2) {
       pKbd->keyLeds |= NUMFLAG;
   } else {
       pKbd->keyLeds &= ~NUMFLAG;
   }
   if ( ctrl->leds & XLED3) {
       pKbd->keyLeds |= SCROLLFLAG;
   } else {
       pKbd->keyLeds &= ~SCROLLFLAG;
   }
   if ( ctrl->leds & (XCOMP|XLED4) ) {
a427 2
/* The server does this for us with i-h. */
#if GET_ABI_MAJOR(ABI_XINPUT_VERSION) < 1
a456 2
#endif

d798 1
d840 1
a840 1
    PACKAGE_VERSION_MAJOR, PACKAGE_VERSION_MINOR, PACKAGE_VERSION_PATCHLEVEL,
d853 60
@

