head	1.6;
access;
symbols
	OPENBSD_6_1:1.6.0.22
	OPENBSD_6_1_BASE:1.6
	OPENBSD_6_0:1.6.0.20
	OPENBSD_6_0_BASE:1.6
	OPENBSD_5_9:1.6.0.18
	OPENBSD_5_9_BASE:1.6
	OPENBSD_5_8:1.6.0.16
	OPENBSD_5_8_BASE:1.6
	OPENBSD_5_7:1.6.0.14
	OPENBSD_5_7_BASE:1.6
	OPENBSD_5_6:1.6.0.12
	OPENBSD_5_6_BASE:1.6
	OPENBSD_5_5:1.6.0.10
	OPENBSD_5_5_BASE:1.6
	OPENBSD_5_4:1.6.0.8
	OPENBSD_5_4_BASE:1.6
	OPENBSD_5_3:1.6.0.6
	OPENBSD_5_3_BASE:1.6
	OPENBSD_5_2:1.6.0.4
	OPENBSD_5_2_BASE:1.6
	OPENBSD_5_1_BASE:1.6
	OPENBSD_5_1:1.6.0.2
	OPENBSD_5_0:1.5.0.6
	OPENBSD_5_0_BASE:1.5
	OPENBSD_4_9:1.5.0.2
	OPENBSD_4_9_BASE:1.5
	OPENBSD_4_8:1.5.0.4
	OPENBSD_4_8_BASE:1.5
	OPENBSD_4_7:1.4.0.4
	OPENBSD_4_7_BASE:1.4
	OPENBSD_4_6:1.4.0.2
	OPENBSD_4_6_BASE:1.4
	OPENBSD_4_5:1.3.0.2
	OPENBSD_4_5_BASE:1.3
	OPENBSD_4_4:1.2.0.4
	OPENBSD_4_4_BASE:1.2
	OPENBSD_4_3_BASE:1.2
	OPENBSD_4_3:1.2.0.2
	OPENBSD_4_2:1.1.1.1.0.2
	OPENBSD_4_2_BASE:1.1.1.1
	v1_1_0:1.1.1.1
	xorg:1.1.1;
locks; strict;
comment	@ * @;


1.6
date	2011.11.05.13.49.26;	author matthieu;	state Exp;
branches;
next	1.5;

1.5
date	2010.06.13.12.39.19;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2009.05.03.13.43.52;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2008.08.23.14.01.36;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2007.12.14.22.29.44;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.26.19.52.00;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.11.26.19.52.00;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.6
log
@Update to xf86-input-hyperpen 1.4.1
@
text
@// -*- Mode: C; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
/*
 * xf86HyperPen
 *
 * Based on the xf86Summa driver.
 *
 * Modified for the Aiptek HyperPen 6000 / Tevion MD 9310
 *   (c) 2000 Roland Jansen <roland@@lut.rwth-aachen.de>
 *
 *
 *
 * added button and 19200 bps stuff from the DigitalEdge driver on sourceforge
 *   (c) 2000 Christian Herzog <daduke@@dataway.ch>
 *
 *
 */

/* xf86Summa
 * Copyright 1996 by Steven Lang <tiger@@tyger.org>
 *
 * Permission to use, copy, modify, distribute, and sell this software and its
 * documentation for any purpose is hereby granted without fee, provided that
 * the above copyright notice appear in all copies and that both that
 * copyright notice and this permission notice appear in supporting
 * documentation, and that the name of Steven Lang not be used in advertising
 * or publicity pertaining to distribution of the software without specific,
 * written prior permission.  Steven Lang makes no representations about the
 * suitability of this software for any purpose.  It is provided "as is"
 * without express or implied warranty.
 *
 * STEVEN LANG DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
 * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO
 * EVENT SHALL STEVEN LANG BE LIABLE FOR ANY SPECIAL, INDIRECT OR
 * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
 * DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
 * TORTIOUS ACTIONS, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
 * PERFORMANCE OF THIS SOFTWARE.
 */

#ifdef HAVE_CONFIG_H
#include "config.h"
#endif

#include <xorgVersion.h>

#include <unistd.h>
#include <errno.h>
#include <string.h>
#include <termios.h>

#include <misc.h>
#include <xf86.h>
#define NEED_XF86_TYPES
#if !defined(DGUX)
#include <xisb.h>
#endif
#include <xf86_OSproc.h>
#include <xf86Xinput.h>
#include <exevents.h>        /* Needed for InitValuator/Proximity stuff */
#include <X11/keysym.h>
#include <mipointer.h>
#include <xf86Module.h>

/*
 * Be sure to set vmin appropriately for your device's protocol. You want to
 * read a full packet before returning
 */

static char *default_options[] = {
    "BaudRate",    "9600",
    "DataBits",    "8",
    "StopBits",    "1",
    "Parity",      "Odd",
    "FlowControl", "Xoff",
    "VTime",       "10",
    "VMin",        "7",
    NULL
};



/*
** Debugging macros
*/
#ifdef DBG
#undef DBG
#endif
#ifdef DEBUG
#undef DEBUG
#endif

#ifndef INI_DEBUG_LEVEL
#define INI_DEBUG_LEVEL 0
#endif

static int debug_level = INI_DEBUG_LEVEL;
#define DEBUG 1
#if DEBUG
#define DBG(lvl, f) {if ((lvl) <= debug_level) f;}
#else
#define DBG(lvl, f)
#endif

/*
** Device records
*/
#define ABSOLUTE_FLAG   1
#define STYLUS_FLAG     2
#define INVX_FLAG       4
#define INVY_FLAG       8
#define BAUD_19200_FLAG 16

int stylus;

typedef struct {
    char *hypDevice;          /* device file name */
    int hypButTrans;          /* button translation flags */
    int hypOldX;              /* previous X position */
    int hypOldY;              /* previous Y position */
    int hypOldZ;              /* previous Z position */
    int hypOldProximity;      /* previous proximity */
    int hypOldPush;           /* previous buttons state */
    int hypOldButtons;        /* previous buttons state */
    int hypOldBarrel;         /* previous buttons state */
    int hypOldBarrel1;        /* previous buttons state */
    int hypOldPressure;       /* previous pen pressure */
    int hypMaxX;              /* max X value */
    int hypMaxY;              /* max Y value */
    int hypMaxZ;              /* max Z value */
    int hypXSize;             /* active area X size */
    int hypXOffset;           /* active area X offset */
    int hypYSize;             /* active area Y size */
    int hypYOffset;           /* active area Y offset */
    int hypRes;               /* resolution in lines per inch */
    int flags;                /* various flags */
    int hypIndex;             /* number of bytes read */
    int modelid;              /* model id */
    int PT;                   /* pressure threshold */
    int AutoPT;               /* automatically set PT*/
    int PMax;                 /* maximum pressure read from tablet */
    unsigned char hypData[7]; /* data read on the device */
} HyperPenDeviceRec, *HyperPenDevicePtr;

/*
** List of model IDs
*/
static struct MODEL_ID {
    unsigned id;
    char* name;
} models[] = {
    {0x32, "HyperPen 3000"},
    {0x43, "HyperPen 4000"},
    {0x54, "HyperPen 5000"},
    {0x64, "HyperPen 6000"},
    {0, NULL}
};

/*
** Contants and macro
*/
#define BUFFER_SIZE    256      /* size of reception buffer */

#define SYSCALL(call) while(((call) == -1) && (errno == EINTR))


#define SS_RESET       "\0"   /* Reset */
#define SS_GETID       "\5"   /* Get Model ID */
#define SS_CONFIG      "a"    /* Send configuration (max coords) */
#define SS_PROMPT_MODE "D"    /* Prompt mode */
#define SS_STREAM_MODE "@@"    /* Stream mode */
#define SS_RATE        "\xb5" /* 19200 bps */
#define SS_ABSOLUTE    "F"    /* absolute mode */
#define SS_RELATIVE    "E"    /* relative mode */
#define SS_MACROKEY    "U"    /* enable F-keys */
#define SS_MACRO_4K    "\2"   /* start F-keys for Hyperpen 4000 */
#define SS_MACRO_56K   "\1"   /* start F-keys for Hyperpen 5000/6000 */
static const char * ss_initstr = SS_STREAM_MODE;

#define PHASING_BIT   0x80
#define PROXIMITY_BIT 0x40
#define XSIGN_BIT     0x10
#define YSIGN_BIT     0x08
#define BUTTON_BITS   0x07
#define COORD_BITS    0x7f
#define XAXIS_BITS    0x03
#define YAXIS_BITS    0x0C
#define ZMASK_BIT     0x70
#define TIP_BITS      0x01
#define F_BIT         0x20


/* macro from counts/inch to counts/meter */
#define LPI2CPM(res) (res * 1000 / 25.4)

/*
** xf86HypReadInput
** Reads from the HyperPen and posts any new events to the server.
*/
static void
xf86HypReadInput(InputInfoPtr pInfo)
{
    HyperPenDevicePtr priv = (HyperPenDevicePtr) pInfo->private;
    int len, loop;
    int is_absolute;
    int f_keys, f_key, tip;
    int x, y, bx, by, barrel, barrel1, prox, pressure, button, push;
    int hw_pressure;

    DeviceIntPtr    device;
    unsigned char    buffer[BUFFER_SIZE];

    SYSCALL(len = read(pInfo->fd, buffer, sizeof(buffer)));

    if (len <= 0) {
        Error("error reading HyperPen device");
        return;
    }

    for(loop=0; loop<len; loop++) {
        if ((priv->hypIndex == 0) && !(buffer[loop] & PHASING_BIT)) {
            /* magic bit is not OK */
            DBG(6, ErrorF("xf86HypReadInput bad magic number 0x%x\n", buffer[loop]));;
            continue;
        }

        priv->hypData[priv->hypIndex++] = buffer[loop];

        if (priv->hypIndex == (priv->flags & ABSOLUTE_FLAG? 7 : 5)) {
            /* the packet is OK */
            /* reset char count for next read */
            priv->hypIndex = 0;

            prox = (priv->hypData[0] & PROXIMITY_BIT)? 0: 1;
            tip = (priv->hypData[0] & TIP_BITS)? 1:0;
            button = (priv->hypData[0] & BUTTON_BITS);

            f_keys = (priv->hypData[0] & F_BIT);
            pressure = (int) priv->hypData[6] + (((int) priv->hypData[5] & ZMASK_BIT) << 3);

            if ((tip==0) && (button==0) && (pressure>2) && (pressure != 1022)) {
                priv->flags |= STYLUS_FLAG; stylus=1;
            } else if ((tip==0) && (button==0) && (pressure==0)) {
                priv->flags &= ~STYLUS_FLAG; stylus=0; pressure = 1019;
            }

            is_absolute = stylus;

            x = priv->hypData[1] + (priv->hypData[2] << 7) + ((priv->hypData[5] & XAXIS_BITS) << 14);
            y = priv->hypData[3] + (priv->hypData[4] << 7) + ((priv->hypData[5] & YAXIS_BITS) << 12);

            if ((f_keys) && (tip)) (f_key = ((x >> 7) + 1) >> 1); else f_key =0;

            x -= priv->hypXOffset;
            y = priv->hypYSize - y + priv->hypYOffset;
            if (x < 0) x = 0;
            if (y < 0) y = 0;
            if (x > priv->hypXSize) x = priv->hypXSize;
            if (y > priv->hypYSize) y = priv->hypYSize;
            bx=x;
            by=y;

            if (!is_absolute) {
                x -= priv->hypOldX;
                y -= priv->hypOldY;
            }

            hw_pressure=pressure;

            if (!priv->PMax) priv->PMax=1000;
            if (pressure>1020) pressure=priv->PT;
            if (priv->AutoPT) {
                if ((pressure>1) && !(tip)) priv->PT = pressure;
                pressure = 511 * (pressure - priv->PT - 10) / (priv->PMax - priv->PT);
            } else {
                pressure = 511 * (pressure - priv->PT) / (priv->PMax - priv->PT);
                button &= ~1;
                if (pressure>0) button |=1;
            };

            if (pressure > 511) pressure = 511;
            if (pressure < 0) pressure = 0;

            push = button & 1;
            barrel = button & 2;
            barrel1 = button & 4;

            DBG(6, ErrorF("hw-press=%d\ttip=%d\tbarrel=%d\tbarrel1=%d\tpush=%d\tpressure=%d\tPT=%d\tbuttons=%d\tf-key=%d\n",hw_pressure, priv->hypData[0] & TIP_BITS, barrel, barrel1, push, pressure, priv->PT, priv->hypData[0] & BUTTON_BITS,f_key));

            device = pInfo->dev;

            /* coordonates are ready we can send events */

            if ((prox) && !(f_keys)) {
                if (!(priv->hypOldProximity))
                    xf86PostProximityEvent(device, 1, 0, 3, x, y, pressure);

                if ((is_absolute && ((priv->hypOldX != x) ||
                                     (priv->hypOldY != y) ||
                                     (priv->hypOldZ != pressure)))
                    || (!is_absolute && (x || y))) {
                    if (is_absolute || priv->hypOldProximity) {
                        xf86PostMotionEvent(device, is_absolute, 0, 3, x, y, pressure);
                    }
                }



                if (priv->hypOldBarrel1 != barrel1) {
                    int delta;
                    delta = barrel1 - priv->hypOldBarrel1;
                    if (priv->hypOldBarrel1 != barrel1) {



                        xf86PostButtonEvent(device, is_absolute, 2, (delta > 0), 0, 3, x, y, pressure);
                    }
                }

                if (priv->hypOldBarrel != barrel) {
                    int delta;
                    delta = barrel - priv->hypOldBarrel;
                    if (priv->hypOldBarrel != barrel) {

                        xf86PostButtonEvent(device, is_absolute, 3, (delta > 0), 0, 3, x, y, pressure);
                    }
                }

                if ((priv->hypOldPush != push) && !barrel && !barrel1) {
                    int delta;
                    delta = push - priv->hypOldPush;
                    if (priv->hypOldPush != push) {

                        xf86PostButtonEvent(device, is_absolute, 1, (delta > 0), 0, 3, x, y, pressure);
                    }
                }

                priv->hypOldX = bx;
                priv->hypOldY = by;
                priv->hypOldPush = push;
                priv->hypOldBarrel = barrel;
                priv->hypOldBarrel1 = barrel1;
                priv->hypOldProximity = prox;

            } else { /* !PROXIMITY */
                /* Any changes in buttons are ignored when !proximity */
                if (priv->hypOldProximity)
                    xf86PostProximityEvent(device, 0, 0, 3, x, y, pressure);
                priv->hypOldProximity = 0;
            }
        }
    }
}

/*
** xf86HypControlProc
** It really does do something. Honest!
*/
static void
xf86HypControlProc(DeviceIntPtr device, PtrCtrl *ctrl)
{
    DBG(2, ErrorF("xf86HypControlProc\n"));
}

/*
** xf86HypWriteAndRead
** Write data, and get the response.
*/
static char *
xf86HypWriteAndRead(int fd, char *data, char *buffer, int len, int cr_term)
{
    int err, numread = 0;

    SYSCALL(err = write(fd, data, strlen(data)));
    if (err == -1) {
        Error("HyperPen write");
        return NULL;
    }

    while (numread < len) {
        err = xf86WaitForInput(fd, 100000);
        if (err == -1) {
            Error("HyperPen select");
            return NULL;
        }
        if (!err) {
            ErrorF("Timeout while reading HyperPen tablet. No tablet connected ???\n");
            return NULL;
        }

        SYSCALL(err = read(fd, buffer + numread++, 1));
        if (err == -1) {
            Error("HyperPen read");
            return NULL;
        }
        if (!err) {
            --numread;
            break;
        }
        if (cr_term && buffer[numread - 1] == '\r') {
            buffer[numread - 1] = 0;
            break;
        }
    }
    buffer[numread] = 0;
    return buffer;
}

/*
** xf86HypOpen
** Open and initialize the tablet, as well as probe for any needed data.
*/

#define WAIT(t)                                                     \
    err = xf86WaitForInput(-1, ((t) * 1000));                       \
    if (err == -1) {                                                \
        ErrorF("HyperPen select error : %s\n", strerror(errno));    \
        return !Success;                                            \
    }

static Bool
xf86HypOpen(InputInfoPtr pInfo)
{
    char        buffer[256];
    int            err, idx;
    int            i, n;
    double        res100;
    double        sratio, tratio;
    HyperPenDevicePtr    priv = (HyperPenDevicePtr)pInfo->private;

    DBG(1, ErrorF("opening %s\n", priv->hypDevice));

    pInfo->fd = xf86OpenSerial(pInfo->options);
    if (pInfo->fd == -1) {
        Error(priv->hypDevice);
        return !Success;
    }
    DBG(2, ErrorF("%s opened as fd %d\n", priv->hypDevice, pInfo->fd));

    if (xf86SetSerialSpeed(pInfo->fd, 9600) < 0)
        return !Success;

    DBG(1, ErrorF("initializing HyperPen tablet\n"));

    /* Send reset to the tablet */

    write(pInfo->fd, SS_RESET, strlen(SS_RESET));
    WAIT(1000);

    /* Put it in prompt mode so it doesn't say anything before we're ready */
    SYSCALL(err = write(pInfo->fd, SS_PROMPT_MODE, strlen(SS_PROMPT_MODE)));
    if (err == -1) {
        Error("HyperPen write");
        return !Success;
    }
    /* Clear any pending input */
    tcflush(pInfo->fd, TCIFLUSH);

    DBG(2, ErrorF("reading model\n"));

    if (!xf86HypWriteAndRead(pInfo->fd, SS_GETID, buffer, 1, 0))
        return !Success;

    priv->modelid=buffer[0];

    for (n = -1, i = 0; models[i].id != 0; i++)
        if (models[i].id == priv->modelid)
            n = i;

    xf86Msg(X_PROBED, " HyperPen Model: 0x%x (%s)\n",
            priv->modelid, n==-1? "UNKNOWN":models[n].name);


    /* enable F-Keys */
    SYSCALL(err = write(pInfo->fd, SS_MACROKEY, strlen(SS_MACROKEY)));
    if (err == -1) {
        ErrorF("HyperPen write error : %s\n", strerror(errno));
        return !Success;
    }

    DBG(6, ErrorF("prepared F-keys\n"));

    /* start sequence depends on model ID */
    if (priv->modelid == 0x43) SYSCALL(err = write(pInfo->fd, SS_MACRO_4K, strlen(SS_MACRO_4K))); else SYSCALL(err = write(pInfo->fd, SS_MACRO_56K, strlen(SS_MACRO_56K)));

    if (err == -1) {
        xf86Msg(X_ERROR, "HyperPen write error : %s\n", strerror(errno));
        return !Success;
    }

    DBG(6, ErrorF("started F-keys\n"));

    priv->hypRes = 500;
    res100 = priv->hypRes / 100;

    DBG(2, ErrorF("reading max coordinates\n"));

    if (!xf86HypWriteAndRead(pInfo->fd, SS_CONFIG, buffer, 5, 0))
        return !Success;

    priv->hypMaxX = (buffer[1] & 0x7f) | (buffer[2] << 7);
    priv->hypMaxY = (buffer[3] & 0x7f) | (buffer[4] << 7);
    priv->hypMaxZ = 512;

    xf86Msg(X_PROBED, "HyperPen max tablet size %d.%02dinx%d.%02din, %dx%d "
               "lines of resolution\n",
               priv->hypMaxX / priv->hypRes,
               (priv->hypMaxX * 100 / priv->hypRes) % 100,
               priv->hypMaxY / priv->hypRes,
               (priv->hypMaxY * 100 / priv->hypRes) % 100,
               priv->hypMaxX, priv->hypMaxY);

    if (priv->hypXOffset >= 0 && priv->hypYOffset >= 0) {
        priv->hypXOffset *= res100;
        priv->hypYOffset *= res100;
        priv->hypMaxX -= priv->hypXOffset;
        priv->hypMaxY -= priv->hypYOffset;
    }

    if (priv->hypXSize > 0 && priv->hypYSize > 0) {
        if ((priv->hypXSize * res100) <= priv->hypMaxX &&
            (priv->hypYSize * res100) <= priv->hypMaxY) {
            priv->hypXSize *= res100;
            priv->hypYSize *= res100;
        } else {
            xf86Msg(X_PROBED, "HyperPen active area bigger than tablet, "
                   "assuming maximum\n");
            priv->hypXSize = priv->hypMaxX;
            priv->hypYSize = priv->hypMaxY;
        }
    } else {
        priv->hypXSize = priv->hypMaxX;
        priv->hypYSize = priv->hypMaxY;
    }

    /* map tablet area by screen aspect ratio */
    sratio = (double)screenInfo.screens[0]->height /
        (double)screenInfo.screens[0]->width;
    tratio = (double)priv->hypMaxY / (double)priv->hypMaxX;

    if (tratio <= 1.0) {        /* tablet horizontal > vertical */
        priv->hypXSize = (double)priv->hypYSize / sratio;
        if (priv->hypXSize > priv->hypMaxX) priv->hypXSize = priv->hypMaxX;
    } else {
        priv->hypYSize = (double)priv->hypXSize / sratio;
        if (priv->hypYSize > priv->hypMaxY) priv->hypYSize = priv->hypMaxY;
    }
    xf86Msg(X_PROBED, "HyperPen using tablet area %d by %d, at res %d lpi\n",
           priv->hypXSize, priv->hypYSize, priv->hypRes);

    if (priv->flags & BAUD_19200_FLAG) {
        /* Send 19200 baud to the tablet */
        SYSCALL(err = write(pInfo->fd, SS_RATE, strlen(SS_RATE)));
        if (err == -1) {
            ErrorF("HyperPen write error : %s\n", strerror(errno));
            return !Success;
        }

        DBG(6, ErrorF("tablet set to 19200 bps\n"));

        /* Wait 10 mSecs */
        WAIT(10);

        /* Set the speed of the serial link to 19200 */
        if (xf86SetSerialSpeed(pInfo->fd, 19200) < 0) {
            return !Success;
        }

        DBG(6, ErrorF("set serial speed to 19200\n"));
    }

    /* Sets up the tablet mode to increment, stream, and such */
    for (idx = 0; ss_initstr[idx]; idx++) {
        buffer[idx] = ss_initstr[idx];
    }

    buffer[idx] = 0;

    SYSCALL(err = write(pInfo->fd, buffer, idx));

    if (err == -1) {
        Error("HyperPen write");
        return !Success;
    }

    if (err <= 0) {
        SYSCALL(close(pInfo->fd));
        return !Success;
    }
    return Success;
}

/*
** xf86HypOpenDevice
** Opens and initializes the device driver stuff or something.
*/
static int
xf86HypOpenDevice(DeviceIntPtr pHyp)
{
    InputInfoPtr    pInfo = (InputInfoPtr)pHyp->public.devicePrivate;
    HyperPenDevicePtr priv = (HyperPenDevicePtr)(pInfo->private);
    Atom axis_labels[3] = { 0 };

    if (xf86HypOpen(pInfo) != Success) {
        if (pInfo->fd >= 0) {
            SYSCALL(close(pInfo->fd));
        }
        pInfo->fd = -1;
    }

    /* Set the real values */
    InitValuatorAxisStruct(pHyp,
                           0,
                           axis_labels[0],
                           0, /* min val */
                           priv->hypXSize, /* max val */
                           LPI2CPM(priv->hypRes), /* resolution */
                           0, /* min_res */
                           LPI2CPM(priv->hypRes), /* max_res */
                           (priv->flags & ABSOLUTE_FLAG)? Absolute : Relative);
    InitValuatorAxisStruct(pHyp,
                           1,
                           axis_labels[1],
                           0, /* min val */
                           priv->hypYSize, /* max val */
                           LPI2CPM(priv->hypRes), /* resolution */
                           0, /* min_res */
                           LPI2CPM(priv->hypRes), /* max_res */
                           (priv->flags & ABSOLUTE_FLAG)? Absolute : Relative);
    InitValuatorAxisStruct(pHyp,
                           2,
                           axis_labels[2],
                           0, /* min val */
                           511, /* max val */
                           512, /* resolution */
                           0, /* min_res */
                           512,  /* max_res */
                           (priv->flags & ABSOLUTE_FLAG)? Absolute : Relative);
    return (pInfo->fd != -1);
}

/*
** xf86HypProc
** Handle requests to do stuff to the driver.
*/
static int
xf86HypProc(DeviceIntPtr pHyp, int what)
{
    CARD8        map[25];
    int            nbaxes;
    int            nbbuttons;
    int            loop;
    InputInfoPtr    pInfo = (InputInfoPtr)pHyp->public.devicePrivate;
    HyperPenDevicePtr priv = (HyperPenDevicePtr)(pInfo->private);
    Atom btn_labels[4] = { 0 };
    Atom axis_labels[3] = { 0 };

    switch (what) {
    case DEVICE_INIT:
        DBG(1, ErrorF("xf86HypProc pHyp=%p what=INIT\n", (void *)pHyp));

        nbaxes = 3;            /* X, Y, Z */
        nbbuttons = (priv->flags & STYLUS_FLAG)? 3 : 4;

        for(loop=1; loop<=nbbuttons; loop++) map[loop] = loop;

        if (InitButtonClassDeviceStruct(pHyp,
                                        nbbuttons,
                                        btn_labels,
                                        map) == FALSE) {
            ErrorF("unable to allocate Button class device\n");
            return !Success;
        }

        if (InitFocusClassDeviceStruct(pHyp) == FALSE) {
            ErrorF("unable to init Focus class device\n");
            return !Success;
        }

        if (InitPtrFeedbackClassDeviceStruct(pHyp,
                                             xf86HypControlProc) == FALSE) {
            ErrorF("unable to init ptr feedback\n");
            return !Success;
        }

        if (InitProximityClassDeviceStruct(pHyp) == FALSE) {
            ErrorF("unable to init proximity class device\n");
            return !Success;
        }

        if (InitValuatorClassDeviceStruct(pHyp,
                                          nbaxes,
                                          axis_labels,
                                          GetMotionHistorySize(),
                                          (priv->flags & ABSOLUTE_FLAG)? Absolute: Relative)
            == FALSE) {
            ErrorF("unable to allocate Valuator class device\n");
            return !Success;
        }
        /* allocate the motion history buffer if needed */
        xf86MotionHistoryAllocate(pInfo);
        /* open the device to gather informations */
        xf86HypOpenDevice(pHyp);
        break;

    case DEVICE_ON:
        DBG(1, ErrorF("xf86HypProc pHyp=%p what=ON\n", (void *)pHyp));

        if ((pInfo->fd < 0) && (!xf86HypOpenDevice(pHyp))) {
            return !Success;
        }
        xf86AddEnabledDevice(pInfo);
        pHyp->public.on = TRUE;
        break;

    case DEVICE_OFF:
        DBG(1, ErrorF("xf86HypProc  pHyp=%p what=%s\n", (void *)pHyp,
                      (what == DEVICE_CLOSE) ? "CLOSE" : "OFF"));
        if (pInfo->fd >= 0)
            xf86RemoveEnabledDevice(pInfo);
        pHyp->public.on = FALSE;
        break;

    case DEVICE_CLOSE:
        DBG(1, ErrorF("xf86HypProc  pHyp=%p what=%s\n", (void *)pHyp,
                      (what == DEVICE_CLOSE) ? "CLOSE" : "OFF"));
        SYSCALL(close(pInfo->fd));
        pInfo->fd = -1;
        break;

    default:
        ErrorF("unsupported mode=%d\n", what);
        return !Success;
        break;
    }
    DBG(2, ErrorF("END   xf86HypProc Success what=%d dev=%p priv=%p\n",
                  what, (void *)pHyp, (void *)priv));
    return Success;
}
/*
** xf86HypChangeControl
** When I figure out what it does, it will do it.
*/
static int
xf86HypChangeControl(InputInfoPtr pInfo, xDeviceCtl *control)
{
    xDeviceResolutionCtl    *res;

    res = (xDeviceResolutionCtl *)control;

    if ((control->control != DEVICE_RESOLUTION) ||
        (res->num_valuators < 1))
        return (BadMatch);

    return(Success);
}

/*
** xf86HypSwitchMode
** Switches the mode.  For now just absolute or relative, hopefully
** more on the way.
*/
static int
xf86HypSwitchMode(ClientPtr client, DeviceIntPtr dev, int mode)
{
    InputInfoPtr    pInfo = (InputInfoPtr)dev->public.devicePrivate;
    HyperPenDevicePtr    priv = (HyperPenDevicePtr)(pInfo->private);
    char        newmode;

    DBG(3, ErrorF("xf86HypSwitchMode dev=%p mode=%d\n", (void *)dev, mode));

    switch(mode) {
    case Absolute:
        priv->flags |= ABSOLUTE_FLAG;

        break;

    case Relative:
        priv->flags &= ~ABSOLUTE_FLAG;

        break;

    default:
        DBG(1, ErrorF("xf86HypSwitchMode dev=%p invalid mode=%d\n",
                      (void *)dev, mode));
        return BadMatch;
    }
    SYSCALL(write(pInfo->fd, &newmode, 1));
    return Success;
}

/*
 * xf86HypUninit --
 *
 * called when the driver is unloaded.
 */
static void
xf86HypUninit(InputDriverPtr    drv,
              InputInfoPtr    pInfo,
              int flags)
{
    HyperPenDevicePtr    priv = (HyperPenDevicePtr) pInfo->private;

    DBG(1, ErrorF("xf86HypUninit\n"));

    free (priv);
    pInfo->private = NULL;
    xf86DeleteInput(pInfo, 0);
}


/*
 * xf86HypInit --
 *
 * called when the module subsection is found in XF86Config
 */
static int
xf86HypInit(InputDriverPtr      drv,
            InputInfoPtr        pInfo,
            int                 flags)
{
    HyperPenDevicePtr priv = malloc(sizeof(HyperPenDeviceRec));
    char *s;
    int rc = Success;

    if (!priv) {
        rc = BadAlloc;
        goto SetupProc_fail;
    }

    /* Serial Device is mandatory */
    priv->hypDevice = xf86FindOptionValue(pInfo->options, "Device");

    if (!priv->hypDevice) {
        xf86Msg (X_ERROR, "%s: No Device specified.\n", pInfo->name);
        rc = BadMatch;
        goto SetupProc_fail;
    }

    pInfo->private = priv;
    pInfo->device_control = xf86HypProc;
    pInfo->read_input = xf86HypReadInput;
    pInfo->control_proc = xf86HypChangeControl;
    pInfo->switch_mode = xf86HypSwitchMode;
    pInfo->type_name = "STYLUS";
    pInfo->fd = -1;
    priv->AutoPT = 1;

#if defined(sun) && !defined(i386)
    if (dev_name) {
        priv->hypDevice = (char *)alloc(strlen(dev_name) + 1);
        strcpy(priv->hypDevice, dev_name);
        ErrorF("xf86HypOpen port changed to '%s'\n", priv->hypDevice);
    } else {
        priv->hypDevice = "";
    }
#else
    priv->hypDevice = "";        /* device file name */
#endif

    priv->hypOldX = -1;          /* previous X position */
    priv->hypOldY = -1;          /* previous Y position */
    priv->hypOldProximity = 0;   /* previous proximity */
    priv->hypOldButtons = 0;     /* previous buttons state */
    priv->hypMaxX = -1;          /* max X value */
    priv->hypMaxY = -1;          /* max Y value */
    priv->hypXSize = -1;         /* active area X */
    priv->hypXOffset = 1;        /* active area X offset */
    priv->hypYSize = -1;         /* active area Y */
    priv->hypYOffset = 0;        /* active area Y offset */
    priv->flags = ABSOLUTE_FLAG; /* various flags -- default abs format */
    priv->hypIndex = 0;          /* number of bytes read */
    priv->hypRes = 0;            /* resolution */
    stylus=0;

    /* Optional configuration */
    xf86Msg(X_CONFIG, "%s serial device is %s\n", pInfo->name,
            priv->hypDevice);

    debug_level = xf86SetIntOption(pInfo->options, "DebugLevel", 0);
    if (debug_level > 0) {
        xf86Msg(X_CONFIG, "%s: debug level set to %d\n", pInfo->name, debug_level);
    }

    s = xf86FindOptionValue(pInfo->options, "Mode");

    if (s && (xf86NameCmp(s, "absolute") == 0)) {
        priv->flags = priv->flags | ABSOLUTE_FLAG;
    } else if (s && (xf86NameCmp(s, "relative") == 0)) {
        priv->flags = priv->flags & ~ABSOLUTE_FLAG;
    } else if (s) {
        xf86Msg(X_ERROR, "%s: invalid Mode (should be absolute or relative). "
                "Using default.\n", pInfo->name);
    }
    xf86Msg(X_CONFIG, "%s is in %s mode\n", pInfo->name,
            (priv->flags & ABSOLUTE_FLAG) ? "absolute" : "relative");

    s = xf86FindOptionValue(pInfo->options, "Cursor");

    if (s && (xf86NameCmp(s, "stylus") == 0)) {
        priv->flags = priv->flags | STYLUS_FLAG;
    } else if (s && (xf86NameCmp(s, "puck") == 0)) {
        priv->flags = priv->flags & ~STYLUS_FLAG;
    } else if (s) {
        xf86Msg(X_ERROR, "%s: invalid Cursor (should be stylus or puck). "
                "Using default.\n", pInfo->name);
    }
    xf86Msg(X_CONFIG, "%s is in cursor-mode %s\n", pInfo->name,
            (priv->flags & STYLUS_FLAG) ? "cursor" : "puck");

    priv->hypXSize = xf86SetIntOption(pInfo->options, "XSize", 0);
    if (priv->hypXSize != 0) {
        xf86Msg(X_CONFIG, "%s: XSize = %d\n",
                pInfo->name, priv->hypXSize);
    }

    priv->hypYSize = xf86SetIntOption(pInfo->options, "YSize", 0);
    if (priv->hypYSize != 0) {
        xf86Msg(X_CONFIG, "%s: YSize = %d\n",
                pInfo->name, priv->hypYSize);
    }

    priv->PT = xf86SetIntOption(pInfo->options, "PMin", 0);
    if (priv->PT > 2) {
        xf86Msg(X_CONFIG, "%s: PMin = %d\n",
                pInfo->name, priv->PT);
        priv->AutoPT = 0;
    } else
        xf86Msg(X_ERROR, "%s: invalid PMin value (should be > 2)."
                "Using default.\n", pInfo->name);

    priv->PMax = xf86SetIntOption(pInfo->options, "PMax", 0);
    if (priv->PMax > 3) {
        xf86Msg(X_CONFIG, "%s: PMax = %d\n",
                pInfo->name, priv->PMax);
    } else
        xf86Msg(X_ERROR, "%s: invalid PMax value (should be > 3)."
                "Using default.\n", pInfo->name);

    priv->hypXOffset = xf86SetIntOption(pInfo->options, "XOffset", 0);
    if (priv->hypXOffset != 0) {
        xf86Msg(X_CONFIG, "%s: XOffset = %d\n",
                pInfo->name, priv->hypXOffset);
    }

    priv->hypYOffset = xf86SetIntOption(pInfo->options, "YOffset", 0);
    if (priv->hypYOffset != 0) {
        xf86Msg(X_CONFIG, "%s: YOffset = %d\n",
                pInfo->name, priv->hypYOffset);
    }

    if (xf86SetBoolOption(pInfo->options, "InvX", FALSE)) {
        priv->flags |= INVX_FLAG;
        xf86Msg(X_CONFIG, "%s: InvX\n", pInfo->name);
    }

    if (xf86SetBoolOption(pInfo->options, "InvY", FALSE)) {
        priv->flags |= INVY_FLAG;
        xf86Msg(X_CONFIG, "%s: InvY\n", pInfo->name);
    }

    {
        int val;
        val = xf86SetIntOption(pInfo->options, "BaudRate", 0);
        switch (val) {
        case 19200:
            priv->flags |= BAUD_19200_FLAG;
            break;
        case 9600:
            priv->flags &= ~BAUD_19200_FLAG;
            break;
        default:
            xf86Msg(X_CONFIG, "%s: Illegal speed value (must be 9600 or 19200)\n", pInfo->name);
            break;
        }
    }

    return rc;

 SetupProc_fail:
    if (priv)
        free(priv);
    if (pInfo)
        free(pInfo);
    return rc;
}

_X_EXPORT InputDriverRec HYPERPEN = {
    1,                /* driver version */
    "hyperpen",            /* driver name */
    NULL,            /* identify */
    xf86HypInit,        /* pre-init */
    xf86HypUninit,        /* un-init */
    NULL,            /* module */
    default_options
};


/*
***************************************************************************
*
* Dynamic loading functions
*
***************************************************************************
*/
/*
 * xf86HypUnplug --
 *
 * called when the module subsection is found in XF86Config
 */
static void
xf86HypUnplug(pointer    p)
{
    DBG(1, ErrorF("xf86HypUnplug\n"));
}

/*
 * xf86HypPlug --
 *
 * called when the module subsection is found in XF86Config
 */
static pointer
xf86HypPlug(pointer    module,
            pointer    options,
            int        *errmaj,
            int        *errmin)
{
    DBG(1, ErrorF("xf86HypPlug\n"));

    xf86AddInputDriver(&HYPERPEN, module, 0);

    return module;
}

static XF86ModuleVersionInfo xf86HypVersionRec =
    {
        "hyperpen",
        MODULEVENDORSTRING,
        MODINFOSTRING1,
        MODINFOSTRING2,
        XORG_VERSION_CURRENT,
        PACKAGE_VERSION_MAJOR, PACKAGE_VERSION_MINOR, PACKAGE_VERSION_PATCHLEVEL,
        ABI_CLASS_XINPUT,
        ABI_XINPUT_VERSION,
        MOD_CLASS_XINPUT,
        {0, 0, 0, 0}        /* signature, to be patched into the file by */
        /* a tool */
    };

_X_EXPORT XF86ModuleData hyperpenModuleData = {
    &xf86HypVersionRec,
    xf86HypPlug,
    xf86HypUnplug
};

/* end of xf86HyperPen.c */
@


1.5
log
@merge X.Org git HEAD to get XINPUT ABI version 7 support.
@
text
@d1 1
d6 1
a6 1
 * 
d9 3
a11 3
 * 
 * 
 * 
d14 2
a15 2
 * 
 * 
a38 1
/* $XFree86: xc/programs/Xserver/hw/xfree86/input/hyperpen/xf86HyperPen.c,v 1.9 2003/09/24 03:16:59 dawes Exp $ */
d49 1
d59 1
a59 1
#include <exevents.h>		/* Needed for InitValuator/Proximity stuff */
a61 2

#ifdef XFree86LOADER
a62 1
#endif
d64 1
a64 15
#define wait_for_fd(fd) xf86WaitForInput((fd), 1000)
#define tcflush(fd, n) xf86FlushInput((fd))
#undef read
#define read(a,b,c) xf86ReadSerial((a),(b),(c))
#undef write
#define write(a,b,c) xf86WriteSerial((a),(char*)(b),(c))
#undef close
#define close(a) xf86CloseSerial((a))
#define XCONFIG_PROBED "(==)"
#define XCONFIG_GIVEN "(**)"
#define xf86Verbose 1
#undef PRIVATE
#define PRIVATE(x) XI_PRIVATE(x)

/* 
d69 9
a77 10
static const char *default_options[] =
{
	"BaudRate",	"9600",
	"DataBits",	"8",
	"StopBits",	"1",
	"Parity",	"Odd",
	"FlowControl",	"Xoff",
	"VTime",	"10",
	"VMin",		"7",
	NULL
a79 2
static InputDriverPtr hypDrv;

d99 1
a99 1
#define 	DBG(lvl, f) 	{if ((lvl) <= debug_level) f;}
d101 1
a101 1
#define 	DBG(lvl, f)
d107 5
a111 5
#define ABSOLUTE_FLAG		1
#define STYLUS_FLAG		2
#define INVX_FLAG		4
#define INVY_FLAG		8
#define BAUD_19200_FLAG		16	
d115 27
a141 28
typedef struct 
{
	char	*hypDevice;	/* device file name */
	int	hypButTrans;	/* button translation flags */
	int	hypOldX;	/* previous X position */
	int	hypOldY;	/* previous Y position */
	int	hypOldZ;	/* previous Z position */
	int	hypOldProximity; /* previous proximity */
	int 	hypOldPush;           /* previous buttons state */
	int 	hypOldButtons;           /* previous buttons state */
	int 	hypOldBarrel;         /* previous buttons state */
	int 	hypOldBarrel1;                /* previous buttons state */
	int 	hypOldPressure;               /* previous pen pressure */
	int	hypMaxX;	/* max X value */
	int	hypMaxY;	/* max Y value */
	int	hypMaxZ;	/* max Z value */
	int	hypXSize;	/* active area X size */
	int	hypXOffset;	/* active area X offset */
	int	hypYSize;	/* active area Y size */
	int	hypYOffset;	/* active area Y offset */
	int	hypRes;		/* resolution in lines per inch */
	int	flags;		/* various flags */
	int	hypIndex;	/* number of bytes read */
	int	modelid;	/* model id */
	int 	PT;             /* pressure threshold */
        int     AutoPT;         /* automatically set PT*/
        int     PMax;           /* maximum pressure read from tablet */
	unsigned char hypData[7];	/* data read on the device */
d148 2
a149 2
	unsigned id;
	char* name;
d151 5
a155 5
	{0x32, "HyperPen 3000"},
	{0x43, "HyperPen 4000"},
	{0x54, "HyperPen 5000"},
	{0x64, "HyperPen 6000"},
	{0, NULL}
a158 6
** Configuration data
*/
#define HYPERPEN_SECTION_NAME "HyperPen"


/*
d161 1
a161 2
#define BUFFER_SIZE	256		/* size of reception buffer */
#define XI_NAME 	"HYPERPEN"	/* X device name for the stylus */
d166 24
a189 24
#define SS_RESET	"\0"	/* Reset */
#define SS_GETID	"\5"	/* Get Model ID */
#define SS_CONFIG	"a"	/* Send configuration (max coords) */
#define SS_PROMPT_MODE	"D"	/* Prompt mode */
#define SS_STREAM_MODE	"@@"	/* Stream mode */
#define SS_RATE         "\xb5"  /* 19200 bps */
#define SS_ABSOLUTE     "F"     /* absolute mode */
#define SS_RELATIVE     "E"     /* relative mode */
#define SS_MACROKEY	"U"	/* enable F-keys */
#define SS_MACRO_4K	"\2"	/* start F-keys for Hyperpen 4000 */
#define SS_MACRO_56K	"\1"	/* start F-keys for Hyperpen 5000/6000 */
static const char * ss_initstr = SS_STREAM_MODE; 

#define PHASING_BIT	0x80
#define PROXIMITY_BIT	0x40
#define XSIGN_BIT	0x10
#define YSIGN_BIT	0x08
#define BUTTON_BITS	0x07
#define COORD_BITS	0x7f
#define XAXIS_BITS	0x03
#define YAXIS_BITS	0x0C
#define ZMASK_BIT       0x70
#define TIP_BITS        0x01
#define F_BIT           0x20
d193 1
a193 66
#define LPI2CPM(res)	(res * 1000 / 25.4)

/*
** External declarations
*/


/*
** xf86HypConvert
** Convert valuators to X and Y.
*/
static Bool
xf86HypConvert(LocalDevicePtr	local,
	       int		first,
	       int		num,
	       int		v0,
	       int		v1,
	       int		v2,
	       int		v3,
	       int		v4,
	       int		v5,
	       int*		x,
	       int*		y)
{
    HyperPenDevicePtr	priv = (HyperPenDevicePtr) local->private;

    if (first != 0 || num == 1)
      return FALSE;
    *x = (v0 * screenInfo.screens[0]->width) / priv->hypXSize;
    *y = (v1 * screenInfo.screens[0]->height) / priv->hypYSize;
    if (priv->flags & INVX_FLAG)
    	*x = screenInfo.screens[0]->width - *x;
    if (*x < 0)
	*x = 0;
    if (priv->flags & INVY_FLAG)
    	*y = screenInfo.screens[0]->height - *y;
    if (*y < 0)
	*y = 0;
    if (*x > screenInfo.screens[0]->width)
	*x = screenInfo.screens[0]->width;
    if (*y > screenInfo.screens[0]->height)
	*y = screenInfo.screens[0]->height;



    return TRUE;
}

/*
** xf86HypReverseConvert
** Convert X and Y to valuators.
*/
static Bool
xf86HypReverseConvert(LocalDevicePtr	local,
		      int		x,
		      int		y,
		      int		*valuators)
{
    HyperPenDevicePtr	priv = (HyperPenDevicePtr) local->private;
    valuators[0] = ((x * priv->hypXSize) / screenInfo.screens[0]->width);
    valuators[1] = ((y * priv->hypYSize) / screenInfo.screens[0]->height);



    return TRUE;
}
d200 1
a200 1
xf86HypReadInput(LocalDevicePtr local)
d202 3
a204 3
    HyperPenDevicePtr	priv = (HyperPenDevicePtr) local->private;
    int			len, loop;
    int			is_absolute;
d209 2
a210 4
    DeviceIntPtr	device;
    unsigned char	buffer[BUFFER_SIZE];
  

d212 1
a212 2

    SYSCALL(len = read(local->fd, buffer, sizeof(buffer)));
d215 2
a216 4
	Error("error reading HyperPen device");
	return;
    } else {

d220 76
d297 1
a297 87
	if ((priv->hypIndex == 0) && !(buffer[loop] & PHASING_BIT)) { /* magic bit is not OK */
	    DBG(6, ErrorF("xf86HypReadInput bad magic number 0x%x\n", buffer[loop]));;
	    continue;
	}

	priv->hypData[priv->hypIndex++] = buffer[loop];

	if (priv->hypIndex == (priv->flags & ABSOLUTE_FLAG? 7 : 5)) {
/* the packet is OK */
/* reset char count for next read */
	    priv->hypIndex = 0;

	    prox = (priv->hypData[0] & PROXIMITY_BIT)? 0: 1;	
	    tip = (priv->hypData[0] & TIP_BITS)? 1:0;		
	    button = (priv->hypData[0] & BUTTON_BITS);		

	    f_keys = (priv->hypData[0] & F_BIT);		
	    pressure = (int) priv->hypData[6] + (((int) priv->hypData[5] & ZMASK_BIT) << 3);	

	    if ((tip==0) && (button==0) && (pressure>2) && (pressure != 1022)) {priv->flags |= STYLUS_FLAG; stylus=1;} else
	    if ((tip==0) && (button==0) && (pressure==0)) {priv->flags &= ~STYLUS_FLAG; stylus=0; pressure = 1019;}	

is_absolute = stylus;	

	x = priv->hypData[1] + (priv->hypData[2] << 7) + ((priv->hypData[5] & XAXIS_BITS) << 14); 
	y = priv->hypData[3] + (priv->hypData[4] << 7) + ((priv->hypData[5] & YAXIS_BITS) << 12);

	    if ((f_keys) && (tip)) (f_key = ((x >> 7) + 1) >> 1); else f_key =0; 

	    x -= priv->hypXOffset;
	    y = priv->hypYSize - y + priv->hypYOffset;
	    if (x < 0) x = 0;
	    if (y < 0) y = 0;
	    if (x > priv->hypXSize) x = priv->hypXSize;
	    if (y > priv->hypYSize) y = priv->hypYSize;	
	    bx=x;	
	    by=y;

	    if (!is_absolute) {		
		x -= priv->hypOldX;
		y -= priv->hypOldY;
	    } 




	
	
	hw_pressure=pressure; 
	

	if (!priv->PMax) priv->PMax=1000; 
      	if (pressure>1020) pressure=priv->PT;	
	if (priv->AutoPT)
	  {
	   if ((pressure>1) && !(tip)) priv->PT = pressure;
	   pressure = 511 * (pressure - priv->PT - 10) / (priv->PMax - priv->PT);
	  }
	else
	  {
	    pressure = 511 * (pressure - priv->PT) / (priv->PMax - priv->PT);
	    button &= ~1;
	    if (pressure>0) button |=1;

	  };


	if (pressure > 511) pressure = 511;
	if (pressure < 0) pressure = 0;

	

	push = button & 1;	
	barrel = button & 2;
	barrel1 = button & 4;
	
	DBG(6, ErrorF("hw-press=%d\ttip=%d\tbarrel=%d\tbarrel1=%d\tpush=%d\tpressure=%d\tPT=%d\tbuttons=%d\tf-key=%d\n",hw_pressure, priv->hypData[0] & TIP_BITS, barrel, barrel1, push, pressure, priv->PT, priv->hypData[0] & BUTTON_BITS,f_key));
	    
	    device = local->dev;

/* coordonates are ready we can send events */

	    if ((prox) && !(f_keys)) {
		if (!(priv->hypOldProximity)) 
		        xf86PostProximityEvent(device, 1, 0, 3, x, y, pressure);

		if ((is_absolute && ((priv->hypOldX != x) || 
d300 5
a304 5
		       || (!is_absolute && (x || y))) {
		    if (is_absolute || priv->hypOldProximity) {
			xf86PostMotionEvent(device, is_absolute, 0, 3, x, y, pressure);
		    }
		}
d308 4
a311 4
	if (priv->hypOldBarrel1 != barrel1) {
		int delta;
		delta = barrel1 - priv->hypOldBarrel1;
		if (priv->hypOldBarrel1 != barrel1) {
d315 3
a317 3
			xf86PostButtonEvent(device, is_absolute, 2, (delta > 0), 0, 3, x, y, pressure);
		}
	}
d319 4
a322 4
	if (priv->hypOldBarrel != barrel) {
		int delta;
		delta = barrel - priv->hypOldBarrel;
		if (priv->hypOldBarrel != barrel) {
d324 3
a326 3
			xf86PostButtonEvent(device, is_absolute, 3, (delta > 0), 0, 3, x, y, pressure);
		}
	}
d328 4
a331 4
	if ((priv->hypOldPush != push) && !barrel && !barrel1) {
		int delta;
		delta = push - priv->hypOldPush;
		if (priv->hypOldPush != push) {
d333 3
a335 3
			xf86PostButtonEvent(device, is_absolute, 1, (delta > 0), 0, 3, x, y, pressure);
		}
	}
d337 6
a342 7
		
	    	priv->hypOldX = bx;
	    	priv->hypOldY = by;
		priv->hypOldPush = push;
		priv->hypOldBarrel = barrel;
		priv->hypOldBarrel1 = barrel1;
		priv->hypOldProximity = prox;
d344 2
a345 3

	    } else { /* !PROXIMITY */
/* Any changes in buttons are ignored when !proximity */
d348 3
a350 3
		priv->hypOldProximity = 0;
	    }
	}
a351 2


d356 1
a356 1
** It really does do something.  Honest!
d359 1
a359 1
xf86HypControlProc(DeviceIntPtr	device, PtrCtrl *ctrl)
d375 2
a376 2
	Error("HyperPen write");
	return NULL;
d380 23
a402 23
	err = xf86WaitForInput(fd, 100000);
	if (err == -1) {
	    Error("HyperPen select");
	    return NULL;
	}
	if (!err) {
	    ErrorF("Timeout while reading HyperPen tablet. No tablet connected ???\n");
	    return NULL;
	}

	SYSCALL(err = read(fd, buffer + numread++, 1));
	if (err == -1) {
	    Error("HyperPen read");
	    return NULL;
	}
	if (!err) {
	    --numread;
	    break;
	}
	if (cr_term && buffer[numread - 1] == '\r') {
	    buffer[numread - 1] = 0;
	    break;
	}
d413 5
a417 5
#define WAIT(t)                                                 \
    err = xf86WaitForInput(-1, ((t) * 1000));                   \
    if (err == -1) {                                            \
        ErrorF("HyperPen select error : %s\n", strerror(errno));   \
        return !Success;                                        \
d421 1
a421 1
xf86HypOpen(LocalDevicePtr local)
d423 6
a428 6
    char		buffer[256];
    int			err, idx;
    int			i, n;
    double		res100;
    double		sratio, tratio;
    HyperPenDevicePtr	priv = (HyperPenDevicePtr)local->private;
d432 4
a435 4
    local->fd = xf86OpenSerial(local->options);
    if (local->fd == -1) {
	Error(priv->hypDevice);
	return !Success;
d437 1
a437 1
    DBG(2, ErrorF("%s opened as fd %d\n", priv->hypDevice, local->fd));
d439 2
a440 2
   if (xf86SetSerialSpeed(local->fd, 9600) < 0)
      return !Success;
d444 14
a457 14
/* Send reset to the tablet */
    
     write(local->fd, SS_RESET, strlen(SS_RESET));
     WAIT(1000);

/* Put it in prompt mode so it doesn't say anything before we're ready */
      SYSCALL(err = write(local->fd, SS_PROMPT_MODE, strlen(SS_PROMPT_MODE)));
      if (err == -1) {
	Error("HyperPen write");
	return !Success;
      }
/* Clear any pending input */
    tcflush(local->fd, TCIFLUSH);
 
d460 3
a462 3
    if (!xf86HypWriteAndRead(local->fd, SS_GETID, buffer, 1, 0))
	return !Success;
    
d466 5
a470 2
		if (models[i].id == priv->modelid)
			n = i;
a471 21
    if (xf86Verbose)
	ErrorF("%s HyperPen Model: 0x%x (%s)\n", 
		XCONFIG_PROBED, priv->modelid, n==-1? "UNKNOWN":models[n].name);


	/* enable F-Keys */
        SYSCALL(err = write(local->fd, SS_MACROKEY, strlen(SS_MACROKEY)));
	    if (err == -1) {
		            ErrorF("HyperPen write error : %s\n", strerror(errno));
			            return !Success;
				        }

	    DBG(6, ErrorF("prepared F-keys\n"));
	    
	    /* start sequence depends on model ID */
	    if (priv->modelid == 0x43) SYSCALL(err = write(local->fd, SS_MACRO_4K, strlen(SS_MACRO_4K))); else SYSCALL(err = write(local->fd, SS_MACRO_56K, strlen(SS_MACRO_56K)));

	    if (err == -1) {
		            ErrorF("HyperPen write error : %s\n", strerror(errno));
			            return !Success;
				        }
d473 8
a480 1
	    DBG(6, ErrorF("started F-keys\n"));
d482 7
d490 1
d497 3
a499 3
    if (!xf86HypWriteAndRead(local->fd, SS_CONFIG, buffer, 5, 0))
	return !Success;
    
d503 8
a510 9
    
if (xf86Verbose)
	ErrorF("%s HyperPen max tablet size %d.%02dinx%d.%02din, %dx%d "
	       "lines of resolution\n", XCONFIG_PROBED, 
	       priv->hypMaxX / priv->hypRes,
	       (priv->hypMaxX * 100 / priv->hypRes) % 100,
	       priv->hypMaxY / priv->hypRes,
	       (priv->hypMaxY * 100 / priv->hypRes) % 100,
	       priv->hypMaxX, priv->hypMaxY);
d513 4
a516 4
	priv->hypXOffset *= res100;
	priv->hypYOffset *= res100;
	priv->hypMaxX -= priv->hypXOffset;
	priv->hypMaxY -= priv->hypYOffset;
d520 10
a529 10
	if ((priv->hypXSize * res100) <= priv->hypMaxX &&
	    (priv->hypYSize * res100) <= priv->hypMaxY) {
	    priv->hypXSize *= res100;
	    priv->hypYSize *= res100;
	} else {
	    ErrorF("%s HyperPen active area bigger than tablet, "
		   "assuming maximum\n", XCONFIG_PROBED);
	    priv->hypXSize = priv->hypMaxX;
	    priv->hypYSize = priv->hypMaxY;
	}
d531 2
a532 2
	priv->hypXSize = priv->hypMaxX;
	priv->hypYSize = priv->hypMaxY;
d537 1
a537 1
	     (double)screenInfo.screens[0]->width;
d540 6
a545 7
    if (tratio <= 1.0) {		/* tablet horizontal > vertical */
	priv->hypXSize = (double)priv->hypYSize / sratio;
	if (priv->hypXSize > priv->hypMaxX) priv->hypXSize = priv->hypMaxX;
    }
    else {
	priv->hypYSize = (double)priv->hypXSize / sratio;
	if (priv->hypYSize > priv->hypMaxY) priv->hypYSize = priv->hypMaxY;
d547 2
a548 2
    ErrorF("%s HyperPen using tablet area %d by %d, at res %d lpi\n",
	XCONFIG_PROBED, priv->hypXSize, priv->hypYSize, priv->hypRes);
d551 6
a556 6
/* Send 19200 baud to the tablet */
        SYSCALL(err = write(local->fd, SS_RATE, strlen(SS_RATE)));
	    if (err == -1) {
		            ErrorF("HyperPen write error : %s\n", strerror(errno));
			            return !Success;
				        }
d558 1
a558 1
	    DBG(6, ErrorF("tablet set to 19200 bps\n"));
d560 2
d563 4
a566 2
	        /* Wait 10 mSecs */
	        WAIT(10);
d568 2
a569 4
		    /* Set the speed of the serial link to 19200 */
		   if (xf86SetSerialSpeed(local->fd, 19200) < 0) {
			          return !Success;
				     }
d571 3
a573 1
		       DBG(6, ErrorF("set serial speed to 19200\n"));
d576 1
d578 1
a578 5
    
/* Sets up the tablet mode to increment, stream, and such */
      for (idx = 0; ss_initstr[idx]; idx++) {
	buffer[idx] = ss_initstr[idx];
      }
d580 4
a583 1
      buffer[idx] = 0;
d585 4
a588 13
      SYSCALL(err = write(local->fd, buffer, idx));

      

      if (err == -1) {
	Error("HyperPen write");
	return !Success;
      }

      if (err <= 0) {
	SYSCALL(close(local->fd));
	return !Success;
      }
d599 2
a600 3
    LocalDevicePtr	local = (LocalDevicePtr)pHyp->public.devicePrivate;
    HyperPenDevicePtr	priv = (HyperPenDevicePtr)PRIVATE(pHyp);
#if GET_ABI_MAJOR(ABI_XINPUT_VERSION) >= 7
a601 1
#endif
d603 5
a607 5
    if (xf86HypOpen(local) != Success) {
	if (local->fd >= 0) {
	    SYSCALL(close(local->fd));
	}
	local->fd = -1;
d610 1
a610 1
/* Set the real values */
d612 8
a619 9
			   0,
#if GET_ABI_MAJOR(ABI_XINPUT_VERSION) >= 7
			   axis_labels[0],
#endif
			   0, /* min val */
			   priv->hypXSize, /* max val */
			   LPI2CPM(priv->hypRes), /* resolution */
			   0, /* min_res */
			   LPI2CPM(priv->hypRes)); /* max_res */
d621 8
a628 9
			   1,
#if GET_ABI_MAJOR(ABI_XINPUT_VERSION) >= 7
			   axis_labels[1],
#endif
			   0, /* min val */
			   priv->hypYSize, /* max val */
			   LPI2CPM(priv->hypRes), /* resolution */
			   0, /* min_res */
			   LPI2CPM(priv->hypRes)); /* max_res */
d630 9
a638 10
			   2,
#if GET_ABI_MAJOR(ABI_XINPUT_VERSION) >= 7
			   axis_labels[2],
#endif
			   0, /* min val */
			   511, /* max val */
			   512, /* resolution */
			   0, /* min_res */
			   512); /* max_res */
    return (local->fd != -1);
d648 6
a653 7
    CARD8		map[25];
    int			nbaxes;
    int			nbbuttons;
    int			loop;
    LocalDevicePtr	local = (LocalDevicePtr)pHyp->public.devicePrivate;
    HyperPenDevicePtr	priv = (HyperPenDevicePtr)PRIVATE(pHyp);
#if GET_ABI_MAJOR(ABI_XINPUT_VERSION) >= 7
a655 1
#endif
d658 2
a659 2
	case DEVICE_INIT:
	    DBG(1, ErrorF("xf86HypProc pHyp=%p what=INIT\n", (void *)pHyp));
d661 2
a662 2
	    nbaxes = 3;			/* X, Y, Z */
	    nbbuttons = (priv->flags & STYLUS_FLAG)? 3 : 4;
d664 1
a664 1
	    for(loop=1; loop<=nbbuttons; loop++) map[loop] = loop;
d666 68
a733 75
	    if (InitButtonClassDeviceStruct(pHyp,
					    nbbuttons,
#if GET_ABI_MAJOR(ABI_XINPUT_VERSION) >= 7
					    btn_labels,
#endif
					    map) == FALSE) {
		ErrorF("unable to allocate Button class device\n");
		return !Success;
	    }

	    if (InitFocusClassDeviceStruct(pHyp) == FALSE) {
		ErrorF("unable to init Focus class device\n");
		return !Success;
	    }

	    if (InitPtrFeedbackClassDeviceStruct(pHyp,
		   xf86HypControlProc) == FALSE) {
		ErrorF("unable to init ptr feedback\n");
		return !Success;
	    }

	    if (InitProximityClassDeviceStruct(pHyp) == FALSE) {
		ErrorF("unable to init proximity class device\n"); 
		return !Success;
	    }

	    if (InitValuatorClassDeviceStruct(pHyp,
		   nbaxes,
#if GET_ABI_MAJOR(ABI_XINPUT_VERSION) >= 7
		   axis_labels,
#endif
#if GET_ABI_MAJOR(ABI_XINPUT_VERSION) < 3
		   xf86GetMotionEvents,
#endif
		   local->history_size,
		   (priv->flags & ABSOLUTE_FLAG)? Absolute: Relative)
		   == FALSE) {
		ErrorF("unable to allocate Valuator class device\n"); 
		return !Success;
	    }
/* allocate the motion history buffer if needed */
	    xf86MotionHistoryAllocate(local);
/* open the device to gather informations */
	    xf86HypOpenDevice(pHyp);
	    break;

	case DEVICE_ON:
	    DBG(1, ErrorF("xf86HypProc pHyp=%p what=ON\n", (void *)pHyp));

	    if ((local->fd < 0) && (!xf86HypOpenDevice(pHyp))) {
		return !Success;
	    }
	    xf86AddEnabledDevice(local);
	    pHyp->public.on = TRUE;
	    break;

	case DEVICE_OFF:
	    DBG(1, ErrorF("xf86HypProc  pHyp=%p what=%s\n", (void *)pHyp,
		   (what == DEVICE_CLOSE) ? "CLOSE" : "OFF"));
	    if (local->fd >= 0)
		xf86RemoveEnabledDevice(local);
	    pHyp->public.on = FALSE;
	    break;

	case DEVICE_CLOSE:
	    DBG(1, ErrorF("xf86HypProc  pHyp=%p what=%s\n", (void *)pHyp,
		   (what == DEVICE_CLOSE) ? "CLOSE" : "OFF"));
	    SYSCALL(close(local->fd));
	    local->fd = -1;
	    break;

	default:
	    ErrorF("unsupported mode=%d\n", what);
	    return !Success;
	    break;
d736 1
a736 1
	   what, (void *)pHyp, (void *)priv));
a738 14

/*
** xf86HypClose
** It...  Uh...  Closes the physical device?
*/
static void
xf86HypClose(LocalDevicePtr local)
{
    if (local->fd >= 0) {
	SYSCALL(close(local->fd));
    }
    local->fd = -1;
}

d744 1
a744 1
xf86HypChangeControl(LocalDevicePtr local, xDeviceCtl *control)
d746 1
a746 1
    xDeviceResolutionCtl	*res;
d749 1
a749 1
	
d751 2
a752 2
	   (res->num_valuators < 1))
	return (BadMatch);
d765 3
a767 3
    LocalDevicePtr	local = (LocalDevicePtr)dev->public.devicePrivate;
    HyperPenDevicePtr	priv = (HyperPenDevicePtr)(local->private);
    char		newmode;
d772 2
a773 2
	case Absolute:
	    priv->flags |= ABSOLUTE_FLAG;
d775 1
a775 1
	    break;
d777 2
a778 2
	case Relative:
	    priv->flags &= ~ABSOLUTE_FLAG;
d780 1
a780 1
	    break;
d782 4
a785 4
	default:
	    DBG(1, ErrorF("xf86HypSwitchMode dev=%p invalid mode=%d\n",
		   (void *)dev, mode));
	    return BadMatch;
d787 1
a787 1
    SYSCALL(write(local->fd, &newmode, 1));
a791 60
** xf86HypAllocate
** Allocates the device structures for the HyperPen.
*/
static LocalDevicePtr
xf86HypAllocate(void)
{
    LocalDevicePtr	local = xf86AllocateInput(hypDrv, 0);
    HyperPenDevicePtr	priv = (HyperPenDevicePtr)xalloc(sizeof(HyperPenDeviceRec));
#if defined (sun) && !defined(i386)
    char		*dev_name = getenv("HYPERPEN_DEV");
#endif

    local->name = XI_NAME;
    local->type_name = "HyperPen Tablet";
    local->flags = 0; /*XI86_NO_OPEN_ON_INIT;*/
    local->device_control = xf86HypProc;
    local->read_input = xf86HypReadInput;
    local->control_proc = xf86HypChangeControl;
    local->close_proc = xf86HypClose;
    local->switch_mode = xf86HypSwitchMode;
    local->conversion_proc = xf86HypConvert;
    local->reverse_conversion_proc = xf86HypReverseConvert;
    local->fd = -1;
    local->atom = 0;
    local->dev = NULL;
    local->private = priv;
    local->private_flags = 0;
    local->history_size  = 0;

#if defined(sun) && !defined(i386)
    if (dev_name) {
	priv->hypDevice = (char *)xalloc(strlen(dev_name) + 1);
	strcpy(priv->hypDevice, dev_name);
	ErrorF("xf86HypOpen port changed to '%s'\n", priv->hypDevice);
    } else {
	priv->hypDevice = "";
    }
#else
    priv->hypDevice = "";         /* device file name */
#endif
    priv->hypOldX = -1;           /* previous X position */
    priv->hypOldY = -1;           /* previous Y position */
    priv->hypOldProximity = 0;    /* previous proximity */
    priv->hypOldButtons = 0;      /* previous buttons state */
    priv->hypMaxX = -1;           /* max X value */
    priv->hypMaxY = -1;           /* max Y value */
    priv->hypXSize = -1;	  /* active area X */
    priv->hypXOffset = 0;	  /* active area X offset */
    priv->hypYSize = -1;	  /* active area Y */
    priv->hypYOffset = 0;	  /* active area Y offset */
    priv->flags = ABSOLUTE_FLAG;  /* various flags -- default abs format */
    priv->hypIndex = 0;           /* number of bytes read */
    priv->hypRes = 0;		  /* resolution */
    stylus=0;

    return local;
}


/*
d797 3
a799 3
xf86HypUninit(InputDriverPtr	drv,
	      LocalDevicePtr	local,
	      int flags)
d801 2
a802 2
    HyperPenDevicePtr	priv = (HyperPenDevicePtr) local->private;
    
d804 4
a807 5
    
    xf86HypProc(local->dev, DEVICE_OFF);
    
    xfree (priv);
    xf86DeleteInput(local, 0);    
d816 4
a819 4
static InputInfoPtr
xf86HypInit(InputDriverPtr	drv,
	    IDevPtr		dev,
	    int			flags)
d821 8
a828 3
    LocalDevicePtr	local = NULL;
    HyperPenDevicePtr	priv = NULL;
    char		*s;
d830 2
a831 1
    hypDrv = drv;
d833 5
a837 2
    local = xf86HypAllocate();
    local->conf_idev = dev;
d839 7
a845 11
    xf86CollectInputOptions(local, default_options, NULL);   
    xf86OptionListReport( local->options );

    if (local)
	priv = (HyperPenDevicePtr) local->private;

    if (!local || !priv) {
	goto SetupProc_fail;
    }
    
    local->name = dev->identifier;
a846 3
    
    /* Serial Device is mandatory */
    priv->hypDevice = xf86FindOptionValue(local->options, "Device");
d848 7
a854 3
    if (!priv->hypDevice) {
	xf86Msg (X_ERROR, "%s: No Device specified.\n", dev->identifier);
	goto SetupProc_fail;
d856 3
d860 14
a873 2
    /* Process the common options. */
    xf86ProcessCommonOptions(local, local->options);
d876 2
d879 1
a879 4
    xf86Msg(X_CONFIG, "%s serial device is %s\n", dev->identifier,
	    priv->hypDevice);

    debug_level = xf86SetIntOption(local->options, "DebugLevel", 0);
d881 1
a881 1
	xf86Msg(X_CONFIG, "%s: debug level set to %d\n", dev->identifier, debug_level);
d884 1
a884 3


    s = xf86FindOptionValue(local->options, "Mode");
d887 6
a892 4
	priv->flags = priv->flags | ABSOLUTE_FLAG;
    }
    else if (s && (xf86NameCmp(s, "relative") == 0)) {
	priv->flags = priv->flags & ~ABSOLUTE_FLAG;
d894 2
a895 7
    else if (s) {
	xf86Msg(X_ERROR, "%s: invalid Mode (should be absolute or relative). "
		"Using default.\n", dev->identifier);
    }
    xf86Msg(X_CONFIG, "%s is in %s mode\n", local->name,
	    (priv->flags & ABSOLUTE_FLAG) ? "absolute" : "relative");	    

d897 1
a897 1
    s = xf86FindOptionValue(local->options, "Cursor");
d900 6
a905 4
	priv->flags = priv->flags | STYLUS_FLAG;
    }
    else if (s && (xf86NameCmp(s, "puck") == 0)) {
	priv->flags = priv->flags & ~STYLUS_FLAG;
d907 2
a908 6
    else if (s) {
	xf86Msg(X_ERROR, "%s: invalid Cursor (should be stylus or puck). "
		"Using default.\n", dev->identifier);
    }
    xf86Msg(X_CONFIG, "%s is in cursor-mode %s\n", local->name,
	    (priv->flags & STYLUS_FLAG) ? "cursor" : "puck");	    
d910 1
a910 1
    priv->hypXSize = xf86SetIntOption(local->options, "XSize", 0);
d912 2
a913 2
	    xf86Msg(X_CONFIG, "%s: XSize = %d\n", 
		    dev->identifier, priv->hypXSize);
d916 1
a916 1
    priv->hypYSize = xf86SetIntOption(local->options, "YSize", 0);
d918 2
a919 2
	    xf86Msg(X_CONFIG, "%s: YSize = %d\n", 
		    dev->identifier, priv->hypYSize);
d922 1
a922 1
    priv->PT = xf86SetIntOption(local->options, "PMin", 0);
d924 6
a929 8
	    xf86Msg(X_CONFIG, "%s: PMin = %d\n", 
		    dev->identifier, priv->PT);
	    priv->AutoPT = 0;
    }
    else
	xf86Msg(X_ERROR, "%s: invalid PMin value (should be > 2)."
		"Using default.\n", dev->identifier);
      
d931 1
a931 1
    priv->PMax = xf86SetIntOption(local->options, "PMax", 0);
d933 5
a937 7
	    xf86Msg(X_CONFIG, "%s: PMax = %d\n", 
		    dev->identifier, priv->PMax);
    }
    else
	xf86Msg(X_ERROR, "%s: invalid PMax value (should be > 3)."
		"Using default.\n", dev->identifier);
      
d939 1
a939 1
    priv->hypXOffset = xf86SetIntOption(local->options, "XOffset", 0);
d941 2
a942 2
	    xf86Msg(X_CONFIG, "%s: XOffset = %d\n", 
		    dev->identifier, priv->hypXOffset);
d945 1
a945 1
    priv->hypYOffset = xf86SetIntOption(local->options, "YOffset", 0);
d947 2
a948 2
	    xf86Msg(X_CONFIG, "%s: YOffset = %d\n", 
		    dev->identifier, priv->hypYOffset);
d951 3
a953 3
    if (xf86SetBoolOption(local->options, "InvX", FALSE)) {
	    priv->flags |= INVX_FLAG;
    	    xf86Msg(X_CONFIG, "%s: InvX\n", dev->identifier); 
d956 3
a958 3
    if (xf86SetBoolOption(local->options, "InvY", FALSE)) {
	    priv->flags |= INVY_FLAG;
    	    xf86Msg(X_CONFIG, "%s: InvY\n", dev->identifier); 
d962 13
a974 13
	int val;
	val = xf86SetIntOption(local->options, "BaudRate", 0);
	switch (val) {
	case 19200:
	    priv->flags |= BAUD_19200_FLAG;
	    break;
	case 9600:
	    priv->flags &= ~BAUD_19200_FLAG;
	    break;
	default:
    	    xf86Msg(X_CONFIG, "%s: Illegal speed value (must be 9600 or 19200)\n", dev->identifier); 
	    break;
 	}
d977 1
a977 2
    /* mark the device configured */
    local->flags |= XI86_POINTER_CAPABLE | XI86_CONFIGURED;
d979 1
a979 4
    /* return the LocalDevice */
    return (local);

  SetupProc_fail:
d981 4
a984 4
	xfree(priv);
    if (local)
	xfree(local);
    return NULL;
d988 7
a994 7
    1,				/* driver version */
    "hyperpen",			/* driver name */
    NULL,			/* identify */
    xf86HypInit,		/* pre-init */
    xf86HypUninit,		/* un-init */
    NULL,			/* module */
    0				/* ref count */
d999 6
a1004 7
 ***************************************************************************
 *
 * Dynamic loading functions
 *
 ***************************************************************************
 */
#ifdef XFree86LOADER
d1011 1
a1011 1
xf86HypUnplug(pointer	p)
d1022 4
a1025 4
xf86HypPlug(pointer	module,
	    pointer	options,
	    int		*errmaj,
	    int		*errmin)
d1028 1
a1028 1
	
d1035 13
a1047 13
{
    "hyperpen",
    MODULEVENDORSTRING,
    MODINFOSTRING1,
    MODINFOSTRING2,
    XORG_VERSION_CURRENT,
    PACKAGE_VERSION_MAJOR, PACKAGE_VERSION_MINOR, PACKAGE_VERSION_PATCHLEVEL,
    ABI_CLASS_XINPUT,
    ABI_XINPUT_VERSION,
    MOD_CLASS_XINPUT,
    {0, 0, 0, 0}		/* signature, to be patched into the file by */
				/* a tool */
};
a1053 2

#endif /* XFree86LOADER */
@


1.4
log
@update to xf86-input-hyperpen 1.3.0
@
text
@d722 3
d736 3
d746 3
d756 3
d780 4
a783 2


d796 3
d822 3
@


1.3
log
@xf86-input-hyperpen 1.2.0
@
text
@d44 1
a44 8
#include <xf86Version.h>

#if XF86_VERSION_CURRENT >= XF86_VERSION_NUMERIC(3,9,0,0,0)
#define XFREE86_V4 1
#endif

#ifdef XFREE86_V4
/* post 3.9 headers */
a99 50
#else  /* pre 3.9 headers */

#include <X11/Xos.h>
#include <signal.h>
#include <stdio.h>

#define NEED_EVENTS
#include <X11/X.h>
#include <X11/Xproto.h>
#include "misc.h"
#include "inputstr.h"
#include "scrnintstr.h"
#include <X11/extensions/XI.h>
#include <X11/extensions/XIproto.h>

#if defined(sun) && !defined(i386)
#define POSIX_TTY
#include <errno.h>
#include <termio.h>
#include <fcntl.h>
#include <ctype.h>

#include "extio.h"
#else
#include "compiler.h"

#ifdef XFree86LOADER
#include "xf86_libc.h"
#endif
#include "xf86.h"
#include "xf86Procs.h"
#include "xf86_OSlib.h"
#include "xf86_Config.h"
#include "xf86Xinput.h"
#include "atKeynames.h"
#include "xf86Version.h"
#endif

#if !defined(sun) || defined(i386)
#include "osdep.h"
#include "exevents.h"

#include "extnsionst.h"
#include "extinit.h"
#endif

#if defined(__QNX__) || defined(__QNXNTO__)
#define POSIX_TTY
#endif
#endif /* pre 3.9 headers */
a182 59
#ifndef XFREE86_V4

#define PORT		1
#define DEVICENAME	2
#define THE_MODE	3
#define CURSOR		4
#define BORDER		5
#define DEBUG_LEVEL     6
#define HISTORY_SIZE	7
#define ALWAYS_CORE	8
#define ACTIVE_AREA	9
#define ACTIVE_OFFSET	10
#define INVX		11
#define INVY		12
#define BAUD_RATE	13
#define PMIN            14
#define PMAX            15

#if !defined(sun) || defined(i386)
static SymTabRec HypTab[] = {
	{ENDSUBSECTION,		"endsubsection"},
	{PORT,			"port"},
	{DEVICENAME,		"devicename"},
	{THE_MODE,		"mode"},
	{CURSOR,		"cursor"},
	{BORDER,		"border"},
	{DEBUG_LEVEL,		"debuglevel"},
	{HISTORY_SIZE,		"historysize"},
	{ALWAYS_CORE,		"alwayscore"},
	{ACTIVE_AREA,		"activearea"},
	{ACTIVE_OFFSET,		"activeoffset"},
	{INVX,			"invx"},
	{INVY,			"invy"},
	{BAUD_RATE,		"baudrate"},
	{PMIN,                  "pmin"},
	{PMAX,                  "pmax"}, 
	{-1,			""}
};

#define RELATIVE	1
#define ABSOLUTE	2

static SymTabRec HypModeTabRec[] = {
	{RELATIVE,	"relative"},
	{ABSOLUTE,	"absolute"},
	{-1,		""}
};

#define PUCK		1
#define STYLUS		2

static SymTabRec HypPointTabRec[] = {
	{PUCK,		"puck"},
	{STYLUS,	"stylus"},
	{-1,		""}
};

#endif
#endif /* Pre 3.9 headers */
a225 280
#ifndef XFREE86_V4

#if defined(sun) && !defined(i386)
#define ENQUEUE	suneqEnqueue
#else
#define ENQUEUE	xf86eqEnqueue

extern void xf86eqEnqueue(
			     xEventPtr	/*e */
    );
#endif

extern void miPointerDeltaCursor(
				    int /*dx */ ,
				    int /*dy */ ,
				    unsigned long	/*time */
    );


#ifndef XFREE86_V4
/*
 ***************************************************************************
 *
 * set_serial_speed --
 *
 *      Set speed of the serial port.
 *
 ***************************************************************************
 */
static int
set_serial_speed(int fd, int speed_code)
{
    struct termios      termios_tty;
    int                 err;
#ifdef POSIX_TTY
    SYSCALL(err = tcgetattr(fd, &termios_tty));
    if (err == -1) {
        ErrorF("HyperPen tcgetattr error : %s\n", strerror(errno));
        return !Success;
    }
    termios_tty.c_iflag = IXOFF;
    termios_tty.c_oflag = 0;
    termios_tty.c_cflag = speed_code|CS8|CREAD|CLOCAL|HUPCL|PARENB|PARODD;
    termios_tty.c_lflag = 0;
    termios_tty.c_cc[VINTR] = 0;
    termios_tty.c_cc[VQUIT] = 0;
    termios_tty.c_cc[VERASE] = 0;
    termios_tty.c_cc[VEOF] = 0;
#ifdef VWERASE
    termios_tty.c_cc[VWERASE] = 0;
#endif
#ifdef VREPRINT
    termios_tty.c_cc[VREPRINT] = 0;
#endif
    termios_tty.c_cc[VKILL] = 0;
    termios_tty.c_cc[VEOF] = 0;
    termios_tty.c_cc[VEOL] = 0;
#ifdef VEOL2
    termios_tty.c_cc[VEOL2] = 0;
#endif
    termios_tty.c_cc[VSUSP] = 0;
#ifdef VDSUSP
    termios_tty.c_cc[VDSUSP] = 0;
#endif
#ifdef VDISCARD
    termios_tty.c_cc[VDISCARD] = 0;
#endif
#ifdef VLNEXT
    termios_tty.c_cc[VLNEXT] = 0;
#endif
    /* minimum 1 character in one read call and timeout to 100 ms */
    termios_tty.c_cc[VMIN] = 1;
    termios_tty.c_cc[VTIME] = 10;
    SYSCALL(err = tcsetattr(fd, TCSANOW, &termios_tty));
    if (err == -1) {
        ErrorF("HyperPen tcsetattr TCSANOW error : %s\n", strerror(errno));
        return !Success;
    }
#else
    Code for OSs without POSIX tty functions
#endif
    return Success;
}
#endif /* Pre 3.9 stuff */

#if !defined(sun) || defined(i386)
/*
** xf86HypConfig
** Reads the HyperPen section from the XF86Config file
*/
static Bool
xf86HypConfig(LocalDevicePtr *array, int inx, int max, LexPtr val)
{
    LocalDevicePtr	dev = array[inx];
    HyperPenDevicePtr	priv = (HyperPenDevicePtr)(dev->private);
    int			token;
    int			mtoken;

    DBG(1, ErrorF("xf86HypConfig\n"));

    priv->AutoPT=1;
    priv->PMax=1000;

    while ((token = xf86GetToken(HypTab)) != ENDSUBSECTION) {
	switch(token) {
	case DEVICENAME:
	    if (xf86GetToken(NULL) != STRING)
		xf86ConfigError("Option string expected");
	    else {
		dev->name = strdup(val->str);
		if (xf86Verbose)
		    ErrorF("%s HyperPen X device name is %s\n", XCONFIG_GIVEN,
			   dev->name);
	    }
	    break;

	case PORT:
	    if (xf86GetToken(NULL) != STRING)
		xf86ConfigError("Option string expected");
	    else {
		priv->hypDevice = strdup(val->str);
		if (xf86Verbose)
		    ErrorF("%s HyperPen port is %s\n", XCONFIG_GIVEN,
			   priv->hypDevice);
	    }
	    break;

	case THE_MODE:
	    mtoken = xf86GetToken(HypModeTabRec);
	    if ((mtoken == EOF) || (mtoken == STRING) || (mtoken == NUMBER)) 
		xf86ConfigError("Mode type token expected");
	    else {
		switch (mtoken) {
		case ABSOLUTE:
		    priv->flags |= ABSOLUTE_FLAG;
		    break;
		case RELATIVE:
		    priv->flags &= ~ABSOLUTE_FLAG;
		    break;
		default:
		    xf86ConfigError("Illegal Mode type");
		    break;
		}
	    }
	    break;

	case CURSOR:
	    mtoken = xf86GetToken(HypPointTabRec);
	    if ((mtoken == EOF) || (mtoken == STRING) || (mtoken == NUMBER)) 
		xf86ConfigError("Cursor token expected");
	    else {
		switch (mtoken) {
		case STYLUS:
		    priv->flags |= STYLUS_FLAG;
		    break;
		case PUCK:
		    priv->flags &= ~STYLUS_FLAG;
		    break;
		default:
		    xf86ConfigError("Illegal cursor type");
		    break;
		}
	    }
	    break;

	case DEBUG_LEVEL:
	    if (xf86GetToken(NULL) != NUMBER)
		xf86ConfigError("Option number expected");
	    debug_level = val->num;
	    if (xf86Verbose) {
#if DEBUG
		ErrorF("%s HyperPen debug level set to %d\n", XCONFIG_GIVEN,
		       debug_level);
#else
		ErrorF("%s HyperPen debug level not set to %d because"
		       " debugging is not compiled with the xf86HyperPen driver\n", XCONFIG_GIVEN,
		       debug_level);
#endif
	    }
	    break;

	case HISTORY_SIZE:
	    if (xf86GetToken(NULL) != NUMBER)
		xf86ConfigError("Option number expected");
	    dev->history_size = val->num;
	    if (xf86Verbose)
		ErrorF("%s HyperPen Motion history size is %d\n", XCONFIG_GIVEN,
		       dev->history_size);      
	    break;

	case ALWAYS_CORE:
	    xf86AlwaysCore(dev, TRUE);
	    if (xf86Verbose)
		ErrorF("%s HyperPen device always stays core pointer\n",
		       XCONFIG_GIVEN);
	    break;

	case ACTIVE_AREA:
	    if (xf86GetToken(NULL) != NUMBER)
		xf86ConfigError("Option number expected");
	    priv->hypXSize = val->realnum * 100;
	    if (xf86GetToken(NULL) != NUMBER)
		xf86ConfigError("Option number expected");
	    priv->hypYSize = val->realnum * 100;
	    if (xf86Verbose)
		ErrorF("%s HyperPen active area: %d.%02dx%d.%02d"
		       " inches\n", XCONFIG_GIVEN, priv->hypXSize / 100,
		       priv->hypXSize % 100, priv->hypYSize / 100,
		       priv->hypYSize % 100);
	    break;

	case ACTIVE_OFFSET:
	    if (xf86GetToken(NULL) != NUMBER)
		xf86ConfigError("Option number expected");
	    priv->hypXOffset = val->realnum * 100;
	    if (xf86GetToken(NULL) != NUMBER)
		xf86ConfigError("Option number expected");
	    priv->hypYOffset = val->realnum * 100;
	    if (xf86Verbose)
		ErrorF("%s HyperPen active area offsets: %d.%02d %d.%02d"
		       " inches\n", XCONFIG_GIVEN, priv->hypXOffset / 100,
		       priv->hypXOffset % 100, priv->hypYOffset / 100,
		       priv->hypYOffset % 100);
	    break;
	case INVX:
	    priv->flags |= INVX_FLAG;
	    break;
	case INVY:
	    priv->flags |= INVY_FLAG;
	    break;
	case BAUD_RATE:
	    if (xf86GetToken(NULL) != NUMBER)
		xf86ConfigError("Option number expected");
	    switch (val->num) {
		case 19200:
		   priv->flags |= BAUD_19200_FLAG;
		   break;
		case 9600:
		   priv->flags &= ~BAUD_19200_FLAG;
		   break;
		default:
		    xf86ConfigError("Illegal speed value");
		    break;
	    }
	    break;
	case PMIN:
	    if (xf86GetToken(NULL) != NUMBER)
		xf86ConfigError("Option number expected");
	    if (val->num < 2)
		xf86ConfigError("Illegal minimum pressure");
	    else
	      {
		priv->AutoPT = 0;  /* desactivate auto threshold adjustment*/
		priv->PT = val->num;
	      };
	    break;
	case PMAX:
	    if (xf86GetToken(NULL) != NUMBER)
		xf86ConfigError("Option number expected");
	    if (val->num < 3)
		xf86ConfigError("Illegal maximum pressure");
	    else
	        priv->PMax = val->num;
	    break;
	case EOF:
	    FatalError("Unexpected EOF (missing EndSubSection)");
	    break;

	default:
	    xf86ConfigError("HyperPen subsection keyword expected");
	    break;
	}
    }

    DBG(1, ErrorF("xf86HypConfig name=%s\n", priv->hypDevice));

    return Success;
}
#endif
#endif /* pre 3.9 headers */
a482 4
#ifndef XFREE86_V4
    fd_set readfds;
    struct timeval timeout;
#endif
a489 4
#ifndef XFREE86_V4
    FD_ZERO(&readfds);
    FD_SET(fd, &readfds);
#endif
a490 6
#ifndef XFREE86_V4
	timeout.tv_sec = 0;
	timeout.tv_usec = 100000;

	SYSCALL(err = select(FD_SETSIZE, &readfds, NULL, NULL, &timeout));
#else
a491 1
#endif
a523 1
#ifdef XFREE86_V4
a529 10
#else
#define WAIT(t)                                                 \
    timeout.tv_sec = 0;                                         \
    timeout.tv_usec = (t) * 1000;                               \
    SYSCALL(err = select(0, NULL, NULL, NULL, &timeout));       \
    if (err == -1) {                                            \
        ErrorF("HyperPen select error : %s\n", strerror(errno));   \
        return !Success;                                        \
    }
#endif
a533 4
#ifndef XFREE86_V4
    struct termios	termios_tty;
    struct timeval	timeout;
#endif
a542 1
#ifdef XFREE86_V4
a543 3
#else
    SYSCALL(local->fd = open(priv->hypDevice, O_RDWR | O_NDELAY, 0));
#endif
a549 1
#ifdef XFREE86_V4
a551 4
#else
   if (set_serial_speed(local->fd, B9600) == !Success)
       return !Success;
#endif
a680 1
#ifdef XFREE86_V4
a683 4
#else
		       if (set_serial_speed(local->fd, B19200) == !Success)
			               return !Success;
#endif
d805 1
d807 1
a815 3
#ifndef XFREE86_V4
	    AssignTypeAndName(pHyp, local->atom, local->name);
#endif
a825 1
#ifdef XFREE86_V4
a826 3
#else
	    AddEnabledDevice(local->fd);
#endif
a833 1
#ifdef XFREE86_V4
a834 3
#else
		RemoveEnabledDevice(local->fd);
#endif
a926 1
#ifdef XFREE86_V4
a927 3
#else
    LocalDevicePtr	local = (LocalDevicePtr)xalloc(sizeof(LocalDeviceRec));
#endif
a935 5
#ifndef XFREE86_V4
#if !defined(sun) || defined(i386)
    local->device_config = xf86HypConfig;
#endif
#endif
a978 79
#ifndef XFREE86_V4

/*
** HyperPen device association
** Device section name and allocation function.
*/
DeviceAssocRec hypmasketch_assoc =
{
  HYPERPEN_SECTION_NAME,        /* config_section_name */
  xf86HypAllocate               /* device_allocate */
};

#ifdef DYNAMIC_MODULE
/*
** init_module
** Entry point for dynamic module.
*/
int
#ifndef DLSYM_BUG
init_module(unsigned long server_version)
#else
init_xf86HyperPen(unsigned long server_version)
#endif
{
    xf86AddDeviceAssoc(&hypmasketch_assoc);

    if (server_version != XF86_VERSION_CURRENT) {
	ErrorF("Warning: HyperPen module compiled for version %s\n",
	       XF86_VERSION);
	return 0;
    } else {
	return 1;
    }
}
#endif

#ifdef XFree86LOADER
/*
 * Entry point for the loader code
 */
XF86ModuleVersionInfo xf86HyperPenVersion = {
    "hyperpen",
    MODULEVENDORSTRING,
    MODINFOSTRING1,
    MODINFOSTRING2,
    XORG_VERSION_CURRENT,
    0x00010000,
    {0,0,0,0}
};

void
xf86HyperPenModuleInit(data, magic)
    pointer *data;
    INT32 *magic;
{
    static int cnt = 0;

    switch (cnt) {
      case 0:
      *magic = MAGIC_VERSION;
      *data = &xf86HyperPenVersion;
      cnt++;
      break;
      
      case 1:
      *magic = MAGIC_ADD_XINPUT_DEVICE;
      *data = &hypmasketch_assoc;
      cnt++;
      break;

      default:
      *magic = MAGIC_DONE;
      *data = NULL;
      break;
    } 
}
#endif

#else
a1241 1
#endif /* XFREE86_V4 */
@


1.2
log
@Merge from X.Org -current:
    Don't check if the device is a core device or not.

    Remove call to xf86IsCore (doesn't exist anymore anyway) and unconditionally
    try to generate ProximityEvents. The device should not bother whether it's a
    core event or not, it's all handled in the dix now.
pointed to by sthen@@.
@
text
@d1568 1
d1640 1
d1764 1
a1764 1
    1, 1, 0,
@


1.1
log
@Initial revision
@
text
@d692 1
a692 1
    int			is_core_pointer, is_absolute;
a793 5



            is_core_pointer = xf86IsCorePointer(device);

a797 1
                    if (!is_core_pointer)
d851 2
a852 3
		if (!is_core_pointer)
		   if (priv->hypOldProximity)
		      xf86PostProximityEvent(device, 0, 0, 3, x, y, pressure);
@


1.1.1.1
log
@Importing xf86-input-hyperpen 1.1.0
@
text
@@
