head	1.3;
access;
symbols
	landry_20151114:1.1.1.1 landry:1.1.1;
locks; strict;
comment	@# @;


1.3
date	2015.11.26.07.53.30;	author landry;	state dead;
branches;
next	1.2;
commitid	66LmMJWK79YRqc0z;

1.2
date	2015.11.14.08.38.08;	author landry;	state Exp;
branches;
next	1.1;
commitid	Ra2rW00UGf7X9reU;

1.1
date	2015.11.14.07.35.29;	author landry;	state Exp;
branches
	1.1.1.1;
next	;
commitid	2FmOcm8Q3qb1G7ad;

1.1.1.1
date	2015.11.14.07.35.29;	author landry;	state Exp;
branches;
next	;
commitid	2FmOcm8Q3qb1G7ad;


desc
@@


1.3
log
@Update to py-psutil 3.3.0 final, remove patches merged upstream.
@
text
@$OpenBSD: patch-psutil_arch_bsd_openbsd_c,v 1.2 2015/11/14 08:38:08 landry Exp $

https://github.com/giampaolo/psutil/pull/713

--- psutil/arch/bsd/openbsd.c.orig	Thu Nov 12 23:04:39 2015
+++ psutil/arch/bsd/openbsd.c	Fri Nov 13 16:10:24 2015
@@@@ -30,9 +30,12 @@@@
 #include <sys/file.h>
 #undef _KERNEL
 #include <sys/disk.h>  // struct diskstats
+#include <err.h> // for err() && warn()
+#include <arpa/inet.h> // for inet_ntoa()
 
 
 #include "openbsd.h"
+#include "../../_psutil_common.h"
 
 #define PSUTIL_KPT2DOUBLE(t) (t ## _sec + t ## _usec / 1000000.0)
 #define PSUTIL_TV2DOUBLE(t) ((t).tv_sec + (t).tv_usec / 1000000.0)
@@@@ -138,6 +141,7 @@@@ psutil_raise_ad_or_nsp(long pid) {
         NoSuchProcess();
     else
         AccessDenied();
+    return 0;
 }
 
 
@@@@ -154,13 +158,9 @@@@ psutil_get_proc_list(struct kinfo_proc **procList, siz
     // On success, the function returns 0.
     // On error, the function returns a BSD errno value.
     struct kinfo_proc *result;
-    int done;
-    static const int name[] = { CTL_KERN, KERN_PROC, KERN_PROC, 0 };
     // Declaring name as const requires us to cast it when passing it to
     // sysctl because the prototype doesn't include the const modifier.
-    size_t              length;
     char errbuf[_POSIX2_LINE_MAX];
-    struct kinfo_proc *x;
     int cnt;
     kvm_t *kd;
 
@@@@ -200,7 +200,6 @@@@ psutil_get_proc_list(struct kinfo_proc **procList, siz
 char **
 _psutil_get_argv(long pid) {
     static char **argv;
-    char **p;
     int argv_mib[] = {CTL_KERN, KERN_PROC_ARGS, pid, KERN_PROC_ARGV};
     size_t argv_size = 128;
     /* Loop and reallocate until we have enough space to fit argv. */
@@@@ -321,7 +320,7 @@@@ error:
 
 PyObject *
 psutil_virtual_mem(PyObject *self, PyObject *args) {
-    unsigned int   total, active, inactive, wired, cached, free;
+    unsigned int   total;
     size_t         size = sizeof(total);
     struct uvmexp  uvmexp;
     int            mib[] = {CTL_VM, VM_UVMEXP};
@@@@ -479,7 +478,6 @@@@ psutil_proc_connections(PyObject *self, PyObject *args
     struct kinfo_file *freep = NULL;
     struct kinfo_file *kif;
     char *tcplist = NULL;
-    struct tcpcb *tcp;
 
     PyObject *py_retlist = PyList_New(0);
     PyObject *py_tuple = NULL;
@@@@ -509,7 +507,6 @@@@ psutil_proc_connections(PyObject *self, PyObject *args
         int state;
         int lport;
         int rport;
-        char path[PATH_MAX];
         char addrbuf[NI_MAXHOST + 2];
         int inseq;
         struct in6_addr laddr6;
@@@@ -555,7 +552,6 @@@@ psutil_proc_connections(PyObject *self, PyObject *args
                 else {
                     // local address, IPv6
                     memcpy(&laddr6, kif->inp_laddru, sizeof(laddr6));
-                    (void *)(uintptr_t)kif->inp_ppcb;
                     snprintf(addrbuf, sizeof(addrbuf), "%s",
                              psutil_inet6_addrstr(&laddr6));
                     py_laddr = Py_BuildValue("(si)", addrbuf, lport);
@@@@ -575,7 +571,6 @@@@ psutil_proc_connections(PyObject *self, PyObject *args
                     else {
                         // remote address, IPv6
                         memcpy(&laddr6, kif->inp_faddru, sizeof(laddr6));
-                        (void *)(uintptr_t)kif->inp_ppcb;
                         snprintf(addrbuf, sizeof(addrbuf), "%s",
                                  psutil_inet6_addrstr(&laddr6));
                         py_raddr = Py_BuildValue("(si)", addrbuf, rport);
@@@@ -641,7 +636,6 @@@@ error:
 
 PyObject *
 psutil_per_cpu_times(PyObject *self, PyObject *args) {
-    static int maxcpus;
     int mib[3];
     int ncpu;
     size_t len;
@


1.2
log
@Add links to upstream PR.
@
text
@d1 1
a1 1
$OpenBSD: patch-psutil_arch_bsd_openbsd_c,v 1.1.1.1 2015/11/14 07:35:29 landry Exp $
@


1.1
log
@Initial revision
@
text
@d1 4
a4 1
$OpenBSD$
@


1.1.1.1
log
@Import py-psutil from github commit fc1e59d0, versionning it 3.3.0pre0.

This now supports OpenBSDi mostly properly, the patches in the port
fixing the build and warnings being pushed back.

psutil (python system and process utilities) is a cross-platform library
for retrieving information on running processes and system utilization
(CPU, memory, disks, network) in Python. It is useful mainly for system
monitoring, profiling and limiting process resources and management of
running processes. It implements many functionalities offered by command
line tools such as: ps, top, lsof, netstat, ifconfig, who, df, kill,
free, nice, ionice, iostat, iotop, uptime, pidof, tty, taskset, pmap.

ok/reqd by sthen@@
@
text
@@
