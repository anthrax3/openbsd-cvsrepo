head	1.2;
access;
symbols
	OPENBSD_5_0:1.1.1.1.0.6
	OPENBSD_5_0_BASE:1.1.1.1
	OPENBSD_4_9:1.1.1.1.0.4
	OPENBSD_4_9_BASE:1.1.1.1
	OPENBSD_4_8:1.1.1.1.0.2
	OPENBSD_4_8_BASE:1.1.1.1
	sthen_20100525:1.1.1.1
	sthen:1.1.1;
locks; strict;
comment	@# @;


1.2
date	2011.08.30.09.59.30;	author sthen;	state dead;
branches;
next	1.1;

1.1
date	2010.05.25.21.56.33;	author sthen;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2010.05.25.21.56.33;	author sthen;	state Exp;
branches;
next	;


desc
@@


1.2
log
@update apcupsd to 3.4.19, switch from net-snmp support to internal snmp
support (removing the separate snmp flavour), and add an rc file.

from maintainer Kirill Bychkov; wantlib-x11 synced by me.
@
text
@$OpenBSD: patch-src_apcupsd_c,v 1.1 2010/05/25 21:56:33 sthen Exp $
--- src/apcupsd.c.orig	Tue May 18 02:07:50 2010
+++ src/apcupsd.c	Tue May 18 02:20:02 2010
@@@@ -68,9 +68,10 @@@@ UPSINFO *core_ups = NULL;
 
 static void daemon_start(void);
 
-int shm_OK = 0;
+int pidcreated = 0;
 extern int kill_on_powerfail;
 extern FILE *trace_fd;
+extern char *pidfile;
 
 /*
  * The terminate function and trapping signals allows apcupsd
@@@@ -91,11 +92,10 @@@@ void apcupsd_terminate(int sig)
       log_event(ups, LOG_WARNING, _("apcupsd exiting, signal %u\n"), sig);
 
    clear_files();
-
    device_close(ups);
-
    delete_lockfile(ups);
-
+   if (pidcreated)
+      unlink(pidfile);
    clean_threads();
    log_event(ups, LOG_WARNING, _("apcupsd shutdown succeeded"));
    destroy_ups(ups);
@@@@ -107,6 +107,8 @@@@ void apcupsd_error_cleanup(UPSINFO *ups)
 {
    device_close(ups);
    delete_lockfile(ups);
+   if (pidcreated)
+      unlink(pidfile);
    clean_threads();
    log_event(ups, LOG_ERR, _("apcupsd error shutdown completed"));
    destroy_ups(ups);
@@@@ -261,7 +263,6 @@@@ int main(int argc, char *argv[])
    Dmsg1(10, "Attached to driver: %s\n", ups->driver->driver_name);
 
    ups->start_time = time(NULL);
-   delete_lockfile(ups);
 
    if (!hibernate_ups && !shutdown_ups && go_background) {
       daemon_start();
@@@@ -270,7 +271,6 @@@@ int main(int argc, char *argv[])
       openlog("apcupsd", LOG_CONS | LOG_PID, ups->sysfac);
    }
 
-   make_pid_file();
    init_signals(apcupsd_terminate);
 
    /* Create temp events file if we are not doing a hibernate or shutdown */
@@@@ -282,6 +282,14 @@@@ int main(int argc, char *argv[])
       }
    }
 
+   if (create_lockfile(ups) == LCKERROR) {
+      Error_abort1(_("Failed to acquire device lock file\n"),
+         ups->device);
+   }
+
+   make_pid_file();
+   pidcreated = 1;
+
    setup_device(ups);
 
    if (hibernate_ups) {
@@@@ -295,13 +303,6 @@@@ int main(int argc, char *argv[])
    }
 
    prep_device(ups);
-
-   if (create_lockfile(ups) == LCKERROR) {
-      Error_abort1(_("Failed to reacquire serial port lock file on device %s\n"),
-         ups->device);
-   }
-
-   shm_OK = 1;
 
    /*
     * From now ... we must _only_ start up threads!
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
$OpenBSD$
@


1.1.1.1
log
@Import ports/sysutils/apcupsd, a daemon for monitoring APC UPSes.
We already have sysutils/apc-upsd which hasn't been maintained upstream
in >10 years, which I intend to rm unless there are objections.

From maintainer Kirill Bychkov with various input from myself.

Apcupsd can be used for power mangement and controlling most of APC's
UPS models. Apcupsd works with most of APC's Smart-UPS models as well as
most simple signalling models such a Back-UPS, and BackUPS-Office.
During a power failure, apcupsd will inform the users about the power
failure and that a shutdown may occur. If power is not restored, a
system shutdown will follow when the battery is exhausted, a timeout
(seconds) expires, or runtime expires based on internal APC calculations
determined by power consumption rates.
@
text
@@
