head	1.6;
access;
symbols
	OPENBSD_6_0:1.3.0.2
	OPENBSD_6_0_BASE:1.3
	OPENBSD_5_9:1.1.0.4
	OPENBSD_5_9_BASE:1.1
	OPENBSD_5_8:1.1.0.6
	OPENBSD_5_8_BASE:1.1
	OPENBSD_5_7:1.1.0.2
	OPENBSD_5_7_BASE:1.1;
locks; strict;
comment	@# @;


1.6
date	2016.10.22.17.31.44;	author jasper;	state Exp;
branches;
next	1.5;
commitid	pFvTX35UBsr3CZUb;

1.5
date	2016.10.15.08.33.52;	author jasper;	state Exp;
branches;
next	1.4;
commitid	XEKt2xwdIIksbB3w;

1.4
date	2016.10.14.12.34.03;	author jasper;	state Exp;
branches;
next	1.3;
commitid	vCrTTNacMdYU761P;

1.3
date	2016.05.27.13.54.49;	author rpe;	state Exp;
branches;
next	1.2;
commitid	qliaubqhzZwKgsAC;

1.2
date	2016.02.27.15.37.50;	author jasper;	state Exp;
branches;
next	1.1;
commitid	gvo6BPsQTo1I5d85;

1.1
date	2014.12.06.11.32.56;	author rpe;	state Exp;
branches;
next	;
commitid	EokIivZ0VSxdEbQl;


desc
@@


1.6
log
@sync with upstream git master, fixes package installation issues

reported by semarie
ok danj@@
@
text
@$OpenBSD: patch-lib_ansible_modules_extras_packaging_os_openbsd_pkg_py,v 1.5 2016/10/15 08:33:52 jasper Exp $

sync with upstream revision 16b8128

--- lib/ansible/modules/extras/packaging/os/openbsd_pkg.py.orig	Thu Sep 29 17:01:33 2016
+++ lib/ansible/modules/extras/packaging/os/openbsd_pkg.py	Tue Oct 18 20:09:30 2016
@@@@ -19,10 +19,13 @@@@
 # along with Ansible.  If not, see <http://www.gnu.org/licenses/>.
 
 import os
+import platform
 import re
 import shlex
 import sqlite3
 
+from distutils.version import StrictVersion
+
 DOCUMENTATION = '''
 ---
 module: openbsd_pkg
@@@@ -82,6 +85,9 @@@@ EXAMPLES = '''
 # Specify the default flavour to avoid ambiguity errors
 - openbsd_pkg: name=vim-- state=present
 
+# Specify a package branch (requires at least OpenBSD 6.0)
+- openbsd_pkg: name=python%3.5 state=present
+
 # Update all packages on the system
 - openbsd_pkg: name=* state=latest
 '''
@@@@ -94,47 +100,22 @@@@ def execute_command(cmd, module):
     cmd_args = shlex.split(cmd)
     return module.run_command(cmd_args)
 
-# Function used for getting the name of a currently installed package.
-def get_current_name(name, pkg_spec, module):
-    info_cmd = 'pkg_info'
-    (rc, stdout, stderr) = execute_command("%s" % (info_cmd), module)
-    if rc != 0:
-        return (rc, stdout, stderr)
-
-    if pkg_spec['version']:
-        pattern = "^%s" % name
-    elif pkg_spec['flavor']:
-        pattern = "^%s-.*-%s\s" % (pkg_spec['stem'], pkg_spec['flavor'])
-    else:
-        pattern = "^%s-" % pkg_spec['stem']
-
-    module.debug("get_current_name(): pattern = %s" % pattern)
-
-    for line in stdout.splitlines():
-        module.debug("get_current_name: line = %s" % line)
-        match = re.search(pattern, line)
-        if match:
-            current_name = line.split()[0]
-
-    return current_name
-
 # Function used to find out if a package is currently installed.
 def get_package_state(name, pkg_spec, module):
-    info_cmd = 'pkg_info -e'
+    info_cmd = 'pkg_info -Iq'
 
-    if pkg_spec['version']:
-        command = "%s %s" % (info_cmd, name)
-    elif pkg_spec['flavor']:
-        command = "%s %s-*-%s" % (info_cmd, pkg_spec['stem'], pkg_spec['flavor'])
-    else:
-        command = "%s %s-*" % (info_cmd, pkg_spec['stem'])
+    command = "%s inst:%s" % (info_cmd, name)
 
     rc, stdout, stderr = execute_command(command, module)
 
-    if (stderr):
+    if stderr:
         module.fail_json(msg="failed in get_package_state(): " + stderr)
 
-    if rc == 0:
+    if stdout:
+        # If the requested package name is just a stem, like "python", we may
+        # find multiple packages with that name.
+        pkg_spec['installed_names'] = [name for name in stdout.splitlines()]
+        module.debug("get_package_state(): installed_names = %s" % pkg_spec['installed_names'])
         return True
     else:
         return False
@@@@ -173,8 +154,14 @@@@ def package_present(name, installed_state, pkg_spec, m
         # specific version is supplied or not.
         #
         # When a specific version is supplied the return code will be 0 when
-        # a package is found and 1 when it is not, if a version is not
-        # supplied the tool will exit 0 in both cases:
+        # a package is found and 1 when it is not. If a version is not
+        # supplied the tool will exit 0 in both cases.
+        #
+        # It is important to note that "version" relates to the
+        # packages-specs(7) notion of a version. If using the branch syntax
+        # (like "python%3.5") the version number is considered part of the
+        # stem, and the pkg_add behavior behaves the same as if the name did
+        # not contain a version (which it strictly speaking does not).
         if pkg_spec['version'] or build is True:
             # Depend on the return code.
             module.debug("package_present(): depending on return code")
@@@@ -189,11 +176,14 @@@@ def package_present(name, installed_state, pkg_spec, m
                 # "file:/local/package/directory/ is empty" message on stderr
                 # while still installing the package, so we need to look for
                 # for a message like "packagename-1.0: ok" just in case.
-                match = re.search("\W%s-[^:]+: ok\W" % name, stdout)
+                if pkg_spec['style'] == 'branch':
+                    match = re.search("\W%s-[^:]+: ok\W" % pkg_spec['pkgname'], stdout)
+                else:
+                    match = re.search("\W%s-[^:]+: ok\W" % name, stdout)
+
                 if match:
                     # It turns out we were able to install the package.
-                    module.debug("package_present(): we were able to install package")
-                    pass
+                    module.debug("package_present(): we were able to install the package")
                 else:
                     # We really did fail, fake the return code.
                     module.debug("package_present(): we really did fail")
@@@@ -231,25 +221,23 @@@@ def package_latest(name, installed_state, pkg_spec, mo
 
     if installed_state is True:
 
-        # Fetch name of currently installed package.
-        pre_upgrade_name = get_current_name(name, pkg_spec, module)
-
-        module.debug("package_latest(): pre_upgrade_name = %s" % pre_upgrade_name)
-
         # Attempt to upgrade the package.
         (rc, stdout, stderr) = execute_command("%s %s" % (upgrade_cmd, name), module)
 
         # Look for output looking something like "nmap-6.01->6.25: ok" to see if
         # something changed (or would have changed). Use \W to delimit the match
         # from progress meter output.
-        match = re.search("\W%s->.+: ok\W" % pre_upgrade_name, stdout)
-        if match:
-            if module.check_mode:
-                module.exit_json(changed=True)
+        changed = False
+        for installed_name in pkg_spec['installed_names']:
+            module.debug("package_latest(): checking for pre-upgrade package name: %s" % installed_name)
+            match = re.search("\W%s->.+: ok\W" % installed_name, stdout)
+            if match:
+                module.debug("package_latest(): pre-upgrade package name match: %s" % installed_name)
+                if module.check_mode:
+                    module.exit_json(changed=True)
 
-            changed = True
-        else:
-            changed = False
+                changed = True
+                break
 
         # FIXME: This part is problematic. Based on the issues mentioned (and
         # handled) in package_present() it is not safe to blindly trust stderr
@@@@ -301,7 +289,12 @@@@ def package_absent(name, installed_state, module):
 
 # Function used to parse the package name based on packages-specs(7).
 # The general name structure is "stem-version[-flavors]".
+#
+# Names containing "%" are a special variation not part of the
+# packages-specs(7) syntax. See pkg_add(1) on OpenBSD 6.0 or later for a
+# description.
 def parse_package_name(name, pkg_spec, module):
+    module.debug("parse_package_name(): parsing name: %s" % name)
     # Do some initial matches so we can base the more advanced regex on that.
     version_match = re.search("-[0-9]", name)
     versionless_match = re.search("--", name)
@@@@ -309,7 +302,7 @@@@ def parse_package_name(name, pkg_spec, module):
     # Stop if someone is giving us a name that both has a version and is
     # version-less at the same time.
     if version_match and versionless_match:
-        module.fail_json(msg="Package name both has a version and is version-less: " + name)
+        module.fail_json(msg="package name both has a version and is version-less: " + name)
 
     # If name includes a version.
     if version_match:
@@@@ -322,7 +315,7 @@@@ def parse_package_name(name, pkg_spec, module):
             pkg_spec['flavor']            = match.group('flavor')
             pkg_spec['style']             = 'version'
         else:
-            module.fail_json(msg="Unable to parse package name at version_match: " + name)
+            module.fail_json(msg="unable to parse package name at version_match: " + name)
 
     # If name includes no version but is version-less ("--").
     elif versionless_match:
@@@@ -335,7 +328,7 @@@@ def parse_package_name(name, pkg_spec, module):
             pkg_spec['flavor']            = match.group('flavor')
             pkg_spec['style']             = 'versionless'
         else:
-            module.fail_json(msg="Unable to parse package name at versionless_match: " + name)
+            module.fail_json(msg="unable to parse package name at versionless_match: " + name)
 
     # If name includes no version, and is not version-less, it is all a stem.
     else:
@@@@ -348,14 +341,31 @@@@ def parse_package_name(name, pkg_spec, module):
             pkg_spec['flavor']            = None
             pkg_spec['style']             = 'stem'
         else:
-            module.fail_json(msg="Unable to parse package name at else: " + name)
+            module.fail_json(msg="unable to parse package name at else: " + name)
 
+    # If the stem contains an "%" then it needs special treatment.
+    branch_match = re.search("%", pkg_spec['stem'])
+    if branch_match:
+
+        branch_release = "6.0"
+
+        if version_match or versionless_match:
+            module.fail_json(msg="package name using 'branch' syntax also has a version or is version-less: " + name)
+        if StrictVersion(platform.release()) < StrictVersion(branch_release):
+            module.fail_json(msg="package name using 'branch' syntax requires at least OpenBSD %s: %s" % (branch_release, name))
+
+        pkg_spec['style'] = 'branch'
+
+        # Key names from description in pkg_add(1).
+        pkg_spec['pkgname'] = pkg_spec['stem'].split('%')[0]
+        pkg_spec['branch'] = pkg_spec['stem'].split('%')[1]
+
     # Sanity check that there are no trailing dashes in flavor.
     # Try to stop strange stuff early so we can be strict later.
     if pkg_spec['flavor']:
         match = re.search("-$", pkg_spec['flavor'])
         if match:
-            module.fail_json(msg="Trailing dash in flavor: " + pkg_spec['flavor'])
+            module.fail_json(msg="trailing dash in flavor: " + pkg_spec['flavor'])
 
 # Function used for figuring out the port path.
 def get_package_source_path(name, pkg_spec, module):
@@@@ -364,9 +374,14 @@@@ def get_package_source_path(name, pkg_spec, module):
         return 'databases/sqlports'
     else:
         # try for an exact match first
-        conn = sqlite3.connect('/usr/local/share/sqlports')
+        sqlports_db_file = '/usr/local/share/sqlports'
+        if not os.path.isfile(sqlports_db_file):
+            module.fail_json(msg="sqlports file '%s' is missing" % sqlports_db_file)
+
+        conn = sqlite3.connect(sqlports_db_file)
         first_part_of_query = 'SELECT fullpkgpath, fullpkgname FROM ports WHERE fullpkgname'
         query = first_part_of_query + ' = ?'
+        module.debug("package_package_source_path(): exact query: %s" % query)
         cursor = conn.execute(query, (name,))
         results = cursor.fetchall()
 
@@@@ -376,11 +391,14 @@@@ def get_package_source_path(name, pkg_spec, module):
             query = first_part_of_query + ' LIKE ?'
             if pkg_spec['flavor']:
                 looking_for += pkg_spec['flavor_separator'] + pkg_spec['flavor']
+                module.debug("package_package_source_path(): fuzzy flavor query: %s" % query)
                 cursor = conn.execute(query, (looking_for,))
             elif pkg_spec['style'] == 'versionless':
                 query += ' AND fullpkgname NOT LIKE ?'
+                module.debug("package_package_source_path(): fuzzy versionless query: %s" % query)
                 cursor = conn.execute(query, (looking_for, "%s-%%" % looking_for,))
             else:
+                module.debug("package_package_source_path(): fuzzy query: %s" % query)
                 cursor = conn.execute(query, (looking_for,))
             results = cursor.fetchall()
 
@@@@ -464,8 +482,9 @@@@ def main():
         # build sqlports if its not installed yet
         pkg_spec = {}
         parse_package_name('sqlports', pkg_spec, module)
-        installed_state = get_package_state(name, pkg_spec, module)
+        installed_state = get_package_state('sqlports', pkg_spec, module)
         if not installed_state:
+            module.debug("main(): installing 'sqlports' because build=%s" % module.params['build'])
             package_present('sqlports', installed_state, pkg_spec, module)
 
     if name == '*':
@@@@ -478,6 +497,11 @@@@ def main():
         # Parse package name and put results in the pkg_spec dictionary.
         pkg_spec = {}
         parse_package_name(name, pkg_spec, module)
+
+        # Not sure how the branch syntax is supposed to play together
+        # with build mode. Disable it for now.
+        if pkg_spec['style'] == 'branch' and module.params['build'] is True:
+            module.fail_json(msg="the combination of 'branch' syntax and build=%s is not supported: %s" % (module.params['build'], name))
 
         # Get package state.
         installed_state = get_package_state(name, pkg_spec, module)
@


1.5
log
@patrik's patch was merged
@
text
@d1 1
a1 1
$OpenBSD: patch-lib_ansible_modules_extras_packaging_os_openbsd_pkg_py,v 1.4 2016/10/14 12:34:03 jasper Exp $
d3 1
a3 5
Hunks 3+4:
From 2001172027e339037adaa290e77a7700c818ad57 Mon Sep 17 00:00:00 2001
From: Patrik Lundin <patrik@@sigterm.se>
Date: Wed, 12 Oct 2016 20:51:22 +0200
Subject: [PATCH 1/2] openbsd_pkg: Use correct part of name in match.
d5 68
a72 17
--- lib/ansible/modules/extras/packaging/os/openbsd_pkg.py.orig	Fri Oct 14 14:30:50 2016
+++ lib/ansible/modules/extras/packaging/os/openbsd_pkg.py	Fri Oct 14 14:30:40 2016
@@@@ -144,7 +144,7 @@@@ def package_present(name, installed_state, pkg_spec, m
     build = module.params['build']
 
     if module.check_mode:
-        install_cmd = 'pkg_add -Imn'
+        install_cmd = 'pkg_add -Imnz'
     else:
         if build is True:
             port_dir = "%s/%s" % (module.params['ports_dir'], get_package_source_path(name, pkg_spec, module))
@@@@ -159,7 +159,7 @@@@ def package_present(name, installed_state, pkg_spec, m
             else:
                 module.fail_json(msg="the port source directory %s does not exist" % (port_dir))
         else:
-            install_cmd = 'pkg_add -Im'
+            install_cmd = 'pkg_add -Imz'
d74 3
a76 1
     if installed_state is False:
d78 27
a104 1
@@@@ -189,11 +189,14 @@@@ def package_present(name, installed_state, pkg_spec, m
d122 78
a199 1
@@@@ -349,6 +352,10 @@@@ def parse_package_name(name, pkg_spec, module):
d202 15
a216 1
             module.fail_json(msg="Unable to parse package name at else: " + name)
d221 1
a221 1
 
d224 62
@


1.4
log
@fix issue with openbsd_pkg module where using the branch notation
(e.g. autoconf%2.13) would lead to tasks being (incorrectly) reported
as FAILED.

reported by Caspar Schutijser
fix by Patrik Lundin
@
text
@d1 1
a1 1
$OpenBSD: patch-lib_ansible_modules_extras_packaging_os_openbsd_pkg_py,v 1.3 2016/05/27 13:54:49 rpe Exp $
d3 5
a7 1
Hunks 3+4: https://github.com/ansible/ansible-modules-extras/pull/3151
@


1.3
log
@Update sysutils/ansible to 2.1.0.0

For changes see:
https://github.com/ansible/ansible/blob/v2.1.0.0-1/CHANGELOG.md

OK aja, jasper, landry
@
text
@d1 6
a6 3
$OpenBSD: patch-lib_ansible_modules_extras_packaging_os_openbsd_pkg_py,v 1.2 2016/02/27 15:37:50 jasper Exp $
--- lib/ansible/modules/extras/packaging/os/openbsd_pkg.py.orig	Fri May 27 03:29:21 2016
+++ lib/ansible/modules/extras/packaging/os/openbsd_pkg.py	Fri May 27 03:30:02 2016
d25 29
@


1.2
log
@update to ansible-2.0.1.0
https://groups.google.com/forum/#!topic/ansible-announce/kF5kXiJO7kQ

ok aja@@ rpe@@ (MAINTAINER)
@
text
@d1 6
a6 6
$OpenBSD: patch-lib_ansible_modules_extras_packaging_os_openbsd_pkg_py,v 1.1 2014/12/06 11:32:56 rpe Exp $
--- lib/ansible/modules/extras/packaging/os/openbsd_pkg.py.orig	Thu Feb 25 04:01:01 2016
+++ lib/ansible/modules/extras/packaging/os/openbsd_pkg.py	Sat Feb 27 13:39:49 2016
@@@@ -119,9 +119,9 @@@@ def get_package_state(name, pkg_spec, module):
 # Function used to make sure a package is present.
 def package_present(name, installed_state, pkg_spec, module):
d11 8
a18 2
-        install_cmd = 'pkg_add -Im'
+        install_cmd = 'pkg_add -Imz'
@


1.1
log
@Update ansible to 1.8.2

For changes see
https://github.com/ansible/ansible/blob/v1.8.2/CHANGELOG.md

OK aja@@ sthen@@ landry@@
@
text
@d1 4
a4 4
$OpenBSD$
--- lib/ansible/modules/extras/packaging/os/openbsd_pkg.py.orig	Wed Dec  3 23:13:08 2014
+++ lib/ansible/modules/extras/packaging/os/openbsd_pkg.py	Wed Dec  3 23:13:41 2014
@@@@ -127,9 +127,9 @@@@ def get_package_state(name, pkg_spec, module):
@

