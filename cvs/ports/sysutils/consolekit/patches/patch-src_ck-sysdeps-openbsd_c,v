head	1.23;
access;
symbols
	OPENBSD_6_1:1.23.0.2
	OPENBSD_6_1_BASE:1.23
	OPENBSD_5_8:1.19.0.6
	OPENBSD_5_8_BASE:1.19
	OPENBSD_5_7:1.19.0.2
	OPENBSD_5_7_BASE:1.19
	OPENBSD_5_6:1.17.0.4
	OPENBSD_5_6_BASE:1.17
	OPENBSD_5_5:1.17.0.2
	OPENBSD_5_5_BASE:1.17
	OPENBSD_5_4:1.12.0.4
	OPENBSD_5_4_BASE:1.12
	OPENBSD_5_3:1.12.0.2
	OPENBSD_5_3_BASE:1.12
	OPENBSD_5_2:1.11.0.2
	OPENBSD_5_2_BASE:1.11
	OPENBSD_5_1_BASE:1.10
	OPENBSD_5_1:1.10.0.2
	OPENBSD_5_0:1.8.0.2
	OPENBSD_5_0_BASE:1.8
	OPENBSD_4_9:1.7.0.2
	OPENBSD_4_9_BASE:1.7
	OPENBSD_4_8:1.6.0.2
	OPENBSD_4_8_BASE:1.6
	OPENBSD_4_7:1.3.0.2
	OPENBSD_4_7_BASE:1.3
	OPENBSD_4_6:1.1.1.1.0.2
	OPENBSD_4_6_BASE:1.1.1.1
	robert_20090606:1.1.1.1
	robert:1.1.1;
locks; strict;
comment	@# @;


1.23
date	2017.02.06.08.15.02;	author ajacoutot;	state Exp;
branches;
next	1.22;
commitid	fUEJWR81ZmoKRXLR;

1.22
date	2016.10.03.19.04.41;	author ajacoutot;	state Exp;
branches;
next	1.21;
commitid	iVW5euZ6rt2IDXu7;

1.21
date	2016.09.28.19.26.13;	author ajacoutot;	state Exp;
branches;
next	1.20;
commitid	hR2YE9A0KpuNI4pb;

1.20
date	2015.08.15.11.12.54;	author ajacoutot;	state dead;
branches;
next	1.19;
commitid	RKWZWmWhKNwhuQQN;

1.19
date	2015.02.25.10.35.06;	author ajacoutot;	state Exp;
branches;
next	1.18;
commitid	XZ9AaQFF6qTlVTj4;

1.18
date	2014.11.27.09.38.22;	author ajacoutot;	state Exp;
branches;
next	1.17;
commitid	oD5B2Fc2vHIt4ytZ;

1.17
date	2013.11.30.08.21.41;	author ajacoutot;	state Exp;
branches;
next	1.16;

1.16
date	2013.10.31.06.38.44;	author ajacoutot;	state Exp;
branches;
next	1.15;

1.15
date	2013.10.15.13.31.15;	author ajacoutot;	state Exp;
branches;
next	1.14;

1.14
date	2013.10.14.13.56.10;	author ajacoutot;	state Exp;
branches;
next	1.13;

1.13
date	2013.09.24.08.52.44;	author jca;	state Exp;
branches;
next	1.12;

1.12
date	2012.10.12.14.55.42;	author ajacoutot;	state Exp;
branches;
next	1.11;

1.11
date	2012.07.09.09.23.22;	author sthen;	state Exp;
branches;
next	1.10;

1.10
date	2012.01.08.19.42.02;	author naddy;	state Exp;
branches;
next	1.9;

1.9
date	2011.12.20.19.24.38;	author ajacoutot;	state Exp;
branches;
next	1.8;

1.8
date	2011.04.28.13.08.33;	author ajacoutot;	state Exp;
branches;
next	1.7;

1.7
date	2010.09.17.13.37.57;	author ajacoutot;	state Exp;
branches;
next	1.6;

1.6
date	2010.07.01.07.50.59;	author ajacoutot;	state Exp;
branches;
next	1.5;

1.5
date	2010.07.01.01.00.09;	author ajacoutot;	state Exp;
branches;
next	1.4;

1.4
date	2010.06.28.15.55.21;	author ajacoutot;	state Exp;
branches;
next	1.3;

1.3
date	2009.11.13.14.52.33;	author ajacoutot;	state Exp;
branches;
next	1.2;

1.2
date	2009.10.16.09.36.56;	author ajacoutot;	state Exp;
branches;
next	1.1;

1.1
date	2009.06.07.02.55.19;	author robert;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2009.06.07.02.55.19;	author robert;	state Exp;
branches;
next	;


desc
@@


1.23
log
@Pushed upstream.
@
text
@$OpenBSD: patch-src_ck-sysdeps-openbsd_c,v 1.22 2016/10/03 19:04:41 ajacoutot Exp $

From 34b1a8f577fe8cd224129f5924c8b810c7c17ba8 Mon Sep 17 00:00:00 2001
From: Antoine Jacoutot <ajacoutot@@openbsd.org>
Date: Wed, 28 Sep 2016 21:23:28 +0200
Subject: [PATCH] OpenBSD: adapt to recent kvm(3) restrictions

--- src/ck-sysdeps-openbsd.c.orig	Wed Sep 28 14:08:07 2016
+++ src/ck-sysdeps-openbsd.c	Wed Sep 28 14:08:09 2016
@@@@ -248,7 +248,7 @@@@ ck_unix_pid_get_env_hash (pid_t pid)
         struct kinfo_proc p;
         int               i;
 
-        kd = kvm_openfiles (NULL, NULL, NULL, O_RDONLY, errbuf);
+        kd = kvm_openfiles (NULL, NULL, NULL, KVM_NO_FILES, errbuf);
         if (kd == NULL) {
 		g_warning ("kvm_openfiles failed: %s", errbuf);
                 return NULL;
@


1.22
log
@Merged upstream.
@
text
@d1 1
a1 1
$OpenBSD: patch-src_ck-sysdeps-openbsd_c,v 1.21 2016/09/28 19:26:13 ajacoutot Exp $
d3 4
a6 1
https://github.com/ConsoleKit2/ConsoleKit2/commit/d0cb68ada502ae172d188fe84e66c84da4ffe988
@


1.21
log
@Unbreak ck_unix_pid_get_env_hash after recent kvm /dev/mem access restrictions.

from semarie
@
text
@d1 1
a1 1
$OpenBSD$
d3 1
a3 1
https://github.com/ConsoleKit2/ConsoleKit2/pull/83
@


1.20
log
@Move to the ConsoleKit2 project and update to the newly released stable version:
consolekit2-1.0.0.
Committing early in the cycle to have time to catch any regression.
@
text
@d1 15
a15 471
$OpenBSD: patch-src_ck-sysdeps-openbsd_c,v 1.19 2015/02/25 10:35:06 ajacoutot Exp $
--- src/ck-sysdeps-openbsd.c.orig	Wed Feb 25 07:05:22 2015
+++ src/ck-sysdeps-openbsd.c	Wed Feb 25 07:07:52 2015
@@@@ -0,0 +1,467 @@@@
+/* -*- Mode: C; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 8 -*-
+ *
+ * Copyright (C) 2006 William Jon McCann <mccann@@jhu.edu>
+ * Copyright (C) 2007 Joe Marcus Clarke <marcus@@FreeBSD.org>
+ * Copyright (C) 2008 Jared D. McNeill <jmcneill@@NetBSD.org>
+ * Copyright (C) 2009 Robert Nagy <robert@@openbsd.org>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ *
+ */
+
+#include "config.h"
+
+#include <stdlib.h>
+#include <stdio.h>
+#include <fcntl.h>
+#include <unistd.h>
+#include <string.h>
+#include <errno.h>
+#include <paths.h>
+#include <ttyent.h>
+#include <kvm.h>
+#include <sys/param.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <sys/sysctl.h>
+#include <sys/user.h>
+#include <sys/ioctl.h>
+
+#ifdef __OpenBSD__
+#include <sys/stdint.h>
+#endif
+
+#include <dev/wscons/wsdisplay_usl_io.h>
+
+#define DEV_ENCODE(M,m) ( \
+  ( (M&0xfff) << 8) | ( (m&0xfff00) << 12) | (m&0xff) \
+)
+
+#include "ck-sysdeps.h"
+
+#ifndef ERROR
+#define ERROR -1
+#endif
+
+/* adapted from procps */
+struct _CkProcessStat
+{
+        int pid;
+        int ppid;                       /* stat,status     pid of parent process */
+        char state;                     /* stat,status     single-char code for process state (S=sleeping) */
+        char cmd[16];                   /* stat,status     basename of executable file in call to exec(2) */
+        unsigned long long utime;       /* stat            user-mode CPU time accumulated by process */
+        unsigned long long stime;       /* stat            kernel-mode CPU time accumulated by process */
+        unsigned long long cutime;      /* stat            cumulative utime of process and reaped children */
+        unsigned long long cstime;      /* stat            cumulative stime of process and reaped children */
+        unsigned long long start_time;  /* stat            start time of process -- seconds since 1-1-70 */
+        unsigned long start_code;       /* stat            address of beginning of code segment */
+        unsigned long end_code;         /* stat            address of end of code segment */
+        unsigned long start_stack;      /* stat            address of the bottom of stack for the process */
+        unsigned long kstk_esp;         /* stat            kernel stack pointer */
+        unsigned long kstk_eip;         /* stat            kernel instruction pointer */
+        unsigned long wchan;            /* stat (special)  address of kernel wait channel proc is sleeping in */
+        long priority;                  /* stat            kernel scheduling priority */
+        long nice;                      /* stat            standard unix nice level of process */
+        long rss;                       /* stat            resident set size from /proc/#/stat (pages) */
+        long alarm;                     /* stat            ? */
+        unsigned long rtprio;           /* stat            real-time priority */
+        unsigned long sched;            /* stat            scheduling class */
+        unsigned long vsize;            /* stat            number of pages of virtual memory ... */
+        unsigned long rss_rlim;         /* stat            resident set size limit? */
+        unsigned long flags;            /* stat            kernel flags for the process */
+        unsigned long min_flt;          /* stat            number of minor page faults since process start */
+        unsigned long maj_flt;          /* stat            number of major page faults since process start */
+        unsigned long cmin_flt;         /* stat            cumulative min_flt of process and child processes */
+        unsigned long cmaj_flt;         /* stat            cumulative maj_flt of process and child processes */
+        int     pgrp;                   /* stat            process group id */
+        int session;                    /* stat            session id */
+        int nlwp;                       /* stat    number of threads, or 0 if no clue */
+        int tty;                        /* stat            full device number of controlling terminal */
+        int tpgid;                      /* stat            terminal process group id */
+        int exit_signal;                /* stat            might not be SIGCHLD */
+        int processor;                  /* stat            current (or most recent?) CPU */
+        uintptr_t penv;                 /* stat            address of initial environment vector */
+        char tty_text[11];              /* stat            device name */
+
+};
+
+pid_t
+ck_process_stat_get_ppid (CkProcessStat *stat)
+{
+        g_return_val_if_fail (stat != NULL, -1);
+
+        return stat->ppid;
+}
+
+char *
+ck_process_stat_get_cmd (CkProcessStat *stat)
+{
+        g_return_val_if_fail (stat != NULL, NULL);
+
+        return g_strdup (stat->cmd);
+}
+
+char *
+ck_process_stat_get_tty (CkProcessStat *stat)
+{
+        g_return_val_if_fail (stat != NULL, NULL);
+
+        return g_strdup (stat->tty_text);
+}
+
+static gboolean
+get_kinfo_proc (pid_t pid,
+                struct kinfo_proc *p)
+{
+        size_t len;
+
+        int mib[] = { CTL_KERN, KERN_PROC, KERN_PROC_PID, pid,
+                      sizeof(struct kinfo_proc), 1 };
+
+#ifndef nitems
+#define nitems(_a)      (sizeof((_a)) / sizeof((_a)[0]))
+#endif
+
+        len = sizeof(*p);
+        if (sysctl(mib, nitems(mib), p, &len, NULL, 0) < 0)
+            return FALSE;
+
+        return TRUE;
+}
+
+/* return 1 if it works, or 0 for failure */
+static gboolean
+stat2proc (pid_t        pid,
+           CkProcessStat *P)
+{
+        struct kinfo_proc p;
+        char              *ttname;
+        int               num;
+        int               tty_maj;
+        int               tty_min;
+
+        if (! get_kinfo_proc (pid, &p)) {
+                return FALSE;
+        }
+
+        num = KI_MAXCOMLEN;
+        if (num >= sizeof P->cmd) {
+                num = sizeof P->cmd - 1;
+        }
+
+        memcpy (P->cmd, p.p_comm, num);
+
+        P->cmd[num]   = '\0';
+        P->pid        = p.p_pid;
+        P->ppid       = p.p_ppid;
+        P->pgrp       = p.p__pgid;
+        P->session    = p.p_sid;
+        P->rss        = p.p_vm_rssize;
+        P->vsize      = p.p_vm_dsize + p.p_vm_dsize + p.p_vm_ssize; /* XXX */
+        P->start_time = p.p_ustart_sec;
+        P->wchan      = (unsigned long) p.p_wchan;
+        P->state      = p.p_stat;
+        P->nice       = p.p_nice;
+        P->flags      = p.p_psflags;
+        P->tpgid      = p.p_tpgid;
+        P->processor  = p.p_cpuid;
+
+        /* we like it Linux-encoded :-) */
+        tty_maj = major (p.p_tdev);
+        tty_min = minor (p.p_tdev);
+        P->tty = DEV_ENCODE (tty_maj,tty_min);
+
+        snprintf (P->tty_text, sizeof P->tty_text, "%3d,%-3d", tty_maj, tty_min);
+
+        if (p.p_tdev != NODEV && (ttname = devname (p.p_tdev, S_IFCHR)) != NULL) {
+                memcpy (P->tty_text, ttname, sizeof (P->tty_text));
+        }
+
+        if (p.p_tdev == NODEV) {
+		/* XXX how do we associate X with its tty? */
+#if defined(__i386__) || defined(__amd64__) || defined(__powerpc__)
+                memcpy (P->tty_text, "/dev/ttyC4", sizeof (P->tty_text));
+#else
+                memcpy (P->tty_text, "/dev/ttyC0", sizeof (P->tty_text));
+#endif
+        }
+
+        if (P->pid != pid) {
+                return FALSE;
+        }
+
+        return TRUE;
+}
+
+gboolean
+ck_process_stat_new_for_unix_pid (pid_t           pid,
+                                  CkProcessStat **stat,
+                                  GError        **error)
+{
+        gboolean       res;
+        CkProcessStat *proc;
+
+        g_return_val_if_fail (pid > 1, FALSE);
+
+        if (stat == NULL) {
+                return FALSE;
+        }
+
+        proc = g_new0 (CkProcessStat, 1);
+        proc->pid = pid;
+        res = stat2proc (pid, proc);
+        if (res) {
+                *stat = proc;
+        } else {
+                *stat = NULL;
+        }
+
+        return res;
+}
+
+void
+ck_process_stat_free (CkProcessStat *stat)
+{
+        g_free (stat);
+}
+
+GHashTable *
+ck_unix_pid_get_env_hash (pid_t pid)
+{
+        GHashTable       *hash = NULL;
+        char            **penv;
+        char              errbuf[_POSIX2_LINE_MAX];
+        kvm_t            *kd;
+        struct kinfo_proc p;
+        int               i;
+
+        kd = kvm_openfiles (NULL, NULL, NULL, O_RDONLY, errbuf);
+        if (kd == NULL) {
+		g_warning ("kvm_openfiles failed: %s", errbuf);
+                return NULL;
+        }
+
+        if (! get_kinfo_proc (pid, &p)) {
+		g_warning ("get_kinfo_proc failed: %s", g_strerror (errno));
+		goto fail;
+        }
+
+        penv = kvm_getenvv (kd, &p, 0);
+        if (penv == NULL) {
+		g_warning ("kvm_getenvv failed: %s", kvm_geterr (kd));
+		goto fail;
+        }
+
+        hash = g_hash_table_new_full (g_str_hash,
+                                      g_str_equal,
+                                      g_free,
+                                      g_free);
+
+        for (i = 0; penv[i] != NULL; i++) {
+                char **vals;
+
+                if (!penv[i][0]) continue;
+
+                vals = g_strsplit (penv[i], "=", 2);
+                if (vals != NULL) {
+                        g_hash_table_insert (hash,
+                                             g_strdup (vals[0]),
+                                             g_strdup (vals[1]));
+                        g_strfreev (vals);
+                }
+        }
+
+fail:
+        kvm_close (kd);
+
+        return hash;
+}
+
+char *
+ck_unix_pid_get_env (pid_t       pid,
+                     const char *var)
+{
+        GHashTable *hash;
+        char       *val = NULL;
+
+        /*
+         * Would probably be more efficient to just loop through the
+         * environment and return the value, avoiding building the hash
+         * table, but this works for now.
+         */
+        hash = ck_unix_pid_get_env_hash (pid);
+        if (hash == NULL)
+            return val;
+        val  = g_strdup (g_hash_table_lookup (hash, var));
+        g_hash_table_destroy (hash);
+
+        return val;
+}
+
+uid_t
+ck_unix_pid_get_uid (pid_t pid)
+{
+        uid_t             uid;
+        gboolean          res;
+        struct kinfo_proc p;
+
+        g_return_val_if_fail (pid > 1, 0);
+
+        uid = -1;
+
+        res = get_kinfo_proc (pid, &p);
+
+        if (res) {
+                uid = p.p_uid;
+        }
+
+        return uid;
+}
+
+gboolean
+ck_unix_pid_get_login_session_id (pid_t  pid,
+                                  char **idp)
+{
+        g_return_val_if_fail (pid > 1, FALSE);
+
+        return FALSE;
+}
+
+gboolean
+ck_get_max_num_consoles (guint *num)
+{
+        int      max_consoles;
+        int      res;
+        gboolean ret;
+        struct ttyent *t;
+
+        ret = FALSE;
+        max_consoles = 0;
+
+        res = setttyent ();
+        if (res == 0) {
+                goto done;
+        }
+
+        while ((t = getttyent ()) != NULL) {
+                if (t->ty_status & TTY_ON && strncmp (t->ty_name, "ttyC", 4) == 0)
+                        max_consoles++;
+        }
+
+        /* Increment one more so that all consoles are properly counted
+         * this is arguable a bug in vt_add_watches().
+         */
+        max_consoles++;
+
+        ret = TRUE;
+
+        endttyent ();
+
+done:
+         if (num != NULL) {
+                *num = max_consoles;
+         }
+
+        return ret;
+}
+
+gboolean
+ck_supports_activatable_consoles (void)
+{
+        return TRUE;
+}
+
+char *
+ck_get_console_device_for_num (guint num)
+{
+        char *device;
+
+/* VT are only available on i386, amd64 and macppc */
+#if defined(__i386__) || defined(__amd64__) || defined(__powerpc__)
+        /* The device number is always one less than the VT number. */
+        num--;
+#endif
+
+        device = g_strdup_printf ("/dev/ttyC%u", num);
+
+        return device;
+}
+
+gboolean
+ck_get_console_num_from_device (const char *device,
+                                guint      *num)
+{
+        guint    n;
+        gboolean ret;
+
+        n = 0;
+        ret = FALSE;
+
+        if (device == NULL) {
+                return FALSE;
+        }
+
+        if (sscanf (device, "/dev/ttyC%u", &n) == 1) {
+/* VT are only available on i386, amd64 and macppc */
+#if defined(__i386__) || defined(__amd64__) || defined(__powerpc__)
+                /* The VT number is always one more than the device number. */
+                n++;
+#endif
+                ret = TRUE;
+        }
+
+        if (num != NULL) {
+                *num = n;
+        }
+
+        return ret;
+}
+
+gboolean
+ck_get_active_console_num (int    console_fd,
+                           guint *num)
+{
+        gboolean ret;
+        int      res;
+        int      active;
+
+        g_assert (console_fd != -1);
+
+        active = 0;
+        ret = FALSE;
+
+/* VT are only available on i386, amd64 and macppc */
+#if defined(__i386__) || defined(__amd64__) || defined(__powerpc__)
+        res = ioctl (console_fd, VT_GETACTIVE, &active);
+        if (res == ERROR) {
+                perror ("ioctl VT_GETACTIVE");
+                goto out;
+        }
+
+        g_debug ("Active VT is: %d (ttyC%d)", active, active - 1);
+#else
+       res = 0;
+       g_debug ("Active console is: ttyC%d", active);
+#endif
+        ret = TRUE;
+
+ out:
+        if (num != NULL) {
+                *num = active;
+        }
+
+        return ret;
+}
@


1.19
log
@Unbreak ck-launch-session by properly initializing len in get_kinfo_proc().
from jmatthew@@

No need to call sysctl(3) twice since we know exactly how many
structures it wants back: just one.
from guenther@@

While here, drop a bogus chunk.

ok sthen@@
@
text
@d1 1
a1 1
$OpenBSD: patch-src_ck-sysdeps-openbsd_c,v 1.18 2014/11/27 09:38:22 ajacoutot Exp $
@


1.18
log
@Sync a few cleanups from the ConsoleKit2 project.
@
text
@d1 4
a4 4
$OpenBSD: patch-src_ck-sysdeps-openbsd_c,v 1.17 2013/11/30 08:21:41 ajacoutot Exp $
--- src/ck-sysdeps-openbsd.c.orig	Thu Nov 27 10:30:57 2014
+++ src/ck-sysdeps-openbsd.c	Thu Nov 27 10:32:12 2014
@@@@ -0,0 +1,471 @@@@
d136 1
a136 1
+                      sizeof(struct kinfo_proc), 0 };
d142 1
a142 5
+        if (sysctl(mib, nitems(mib), NULL, &len, NULL, 0) < 0)
+            return FALSE;
+
+        mib[5] = (len / sizeof(struct kinfo_proc));
+
@


1.17
log
@Add missing function to match other OSes -- in case something else out
there uses it.
Re-add the sanity check -- it seems it did not help occasional ckit failures.
@
text
@d1 3
a3 3
$OpenBSD: patch-src_ck-sysdeps-openbsd_c,v 1.16 2013/10/31 06:38:44 ajacoutot Exp $
--- src/ck-sysdeps-openbsd.c.orig	Wed Nov 27 15:56:18 2013
+++ src/ck-sysdeps-openbsd.c	Wed Nov 27 15:57:40 2013
d198 1
a198 1
+                memcpy (P->tty_text, ttname, sizeof P->tty_text);
d204 1
a204 1
+                memcpy (P->tty_text, "/dev/ttyC4", sizeof P->tty_text);
d206 1
a206 1
+                memcpy (P->tty_text, "/dev/ttyC0", sizeof P->tty_text);
d385 1
a385 1
+ 
@


1.16
log
@Fix a bogus check that may prevent getting the XDG_SESSION_COOKIE
value which in turn prevents session managers from accessing ConsoleKit
since the process could not be looked up.
@
text
@d1 4
a4 4
$OpenBSD: patch-src_ck-sysdeps-openbsd_c,v 1.15 2013/10/15 13:31:15 ajacoutot Exp $
--- src/ck-sysdeps-openbsd.c.orig	Wed Oct 30 17:41:39 2013
+++ src/ck-sysdeps-openbsd.c	Wed Oct 30 18:48:47 2013
@@@@ -0,0 +1,463 @@@@
d284 2
d343 1
a343 1
+ck_unix_pid_get_login_session_id (pid_t  pid,  
d349 1
a349 1
+}  
d387 6
@


1.15
log
@Use setttyent() for get max VT.
@
text
@d1 4
a4 4
$OpenBSD: patch-src_ck-sysdeps-openbsd_c,v 1.14 2013/10/14 13:56:10 ajacoutot Exp $
--- src/ck-sysdeps-openbsd.c.orig	Tue Oct 15 15:24:12 2013
+++ src/ck-sysdeps-openbsd.c	Tue Oct 15 15:27:37 2013
@@@@ -0,0 +1,465 @@@@
a282 2
+
+                if (!penv[i][0]) continue;
@


1.14
log
@Properly detect the active VT on macppc now that we have support for it.
@
text
@d1 4
a4 4
$OpenBSD: patch-src_ck-sysdeps-openbsd_c,v 1.13 2013/09/24 08:52:44 jca Exp $
--- src/ck-sysdeps-openbsd.c.orig	Tue Sep 24 00:48:32 2013
+++ src/ck-sysdeps-openbsd.c	Tue Sep 24 00:53:08 2013
@@@@ -0,0 +1,438 @@@@
d354 11
a364 3
+	/* XXX how can we find out how many are configured? */
+        if (num != NULL) {
+                *num = 7;
d367 20
a386 1
+        return TRUE;
@


1.13
log
@Fix after the kinfo_proc structure change.
ok ajacoutot@@
@
text
@d1 1
a1 1
$OpenBSD: patch-src_ck-sysdeps-openbsd_c,v 1.12 2012/10/12 14:55:42 ajacoutot Exp $
d203 1
a203 1
+#if defined(__i386__) || defined(__amd64__)
d367 2
a368 2
+/* VT are only available on i386 and amd64 */
+#if defined(__i386__) || defined(__amd64__)
d393 2
a394 2
+/* VT are only available on i386 and amd64 */
+#if defined(__i386__) || defined(__amd64__)
d421 2
a422 2
+/* VT are only available on i386 and amd64 */
+#if defined(__i386__) || defined(__amd64__)
@


1.12
log
@Bring some checks and enhancements from Debian and FreeBSD.
Enable console monitoring using VT_WAITACTIVE now that we have rthreads \o/
@
text
@d1 3
a3 3
$OpenBSD: patch-src_ck-sysdeps-openbsd_c,v 1.11 2012/07/09 09:23:22 sthen Exp $
--- src/ck-sysdeps-openbsd.c.orig	Fri Oct 12 16:30:06 2012
+++ src/ck-sysdeps-openbsd.c	Fri Oct 12 16:30:21 2012
d186 1
a186 1
+        P->flags      = p.p_realflag;
@


1.11
log
@don't rely on param.h providing the nitems macro, ok ajacoutot@@
@
text
@d1 4
a4 4
$OpenBSD: patch-src_ck-sysdeps-openbsd_c,v 1.10 2012/01/08 19:42:02 naddy Exp $
--- src/ck-sysdeps-openbsd.c.orig	Mon Jul  9 00:16:43 2012
+++ src/ck-sysdeps-openbsd.c	Mon Jul  9 00:17:46 2012
@@@@ -0,0 +1,429 @@@@
d202 1
a202 1
+		/* XXX nasty hack */
d252 1
a252 1
+        GHashTable       *hash;
d254 1
d259 1
a259 1
+        kd = kvm_openfiles (NULL, NULL, NULL, O_RDONLY, NULL);
d261 1
d266 2
a267 1
+                return NULL;
d272 2
a273 1
+                return NULL;
d284 2
d295 1
d306 1
a306 1
+        char       *val;
d314 2
d367 1
a367 1
+// VT are only available on i386 and amd64
d393 1
a393 1
+// VT are only available on i386 and amd64
d421 1
a421 1
+// VT are only available on i386 and amd64
@


1.10
log
@catch up with KERN_PROC2 -> KERN_PROC change
@
text
@d1 4
a4 4
$OpenBSD: patch-src_ck-sysdeps-openbsd_c,v 1.9 2011/12/20 19:24:38 ajacoutot Exp $
--- src/ck-sysdeps-openbsd.c.orig	Tue Dec 20 20:17:24 2011
+++ src/ck-sysdeps-openbsd.c	Tue Dec 20 20:18:44 2011
@@@@ -0,0 +1,425 @@@@
d137 4
@


1.9
log
@Sanitize get_kinfo_proc().
Fix a warning while here.
@
text
@d1 1
a1 1
$OpenBSD: patch-src_ck-sysdeps-openbsd_c,v 1.8 2011/04/28 13:08:33 ajacoutot Exp $
d263 1
a263 1
+        penv = kvm_getenvv2 (kd, &p, 0);
@


1.8
log
@Update to consolekit-0.4.4.
Make sure we don't try and use /proc.
s/KERN_PROC2/KERN_PROC

ok jasper@@
@
text
@d1 4
a4 4
$OpenBSD: patch-src_ck-sysdeps-openbsd_c,v 1.7 2010/09/17 13:37:57 ajacoutot Exp $
--- src/ck-sysdeps-openbsd.c.orig	Fri Sep 17 15:18:27 2010
+++ src/ck-sysdeps-openbsd.c	Fri Sep 17 15:20:56 2010
@@@@ -0,0 +1,430 @@@@
d101 1
a101 1
+        char tty_text[16];              /* stat            device name */
d133 12
a144 17
+	int name[6];
+	u_int namelen;
+	size_t sz;
+
+	sz = sizeof(*p);
+	namelen = 0;
+	name[namelen++] = CTL_KERN;
+	name[namelen++] = KERN_PROC;
+	name[namelen++] = KERN_PROC_PID;
+	name[namelen++] = pid;
+	name[namelen++] = sz;
+	name[namelen++] = 1;
+
+        if (sysctl (name, namelen, p, &sz, NULL, 0) == -1) {
+		perror("sysctl kern.proc.pid");
+                return FALSE;
+        }
@


1.7
log
@Make this work on non-human arches too.

ok jasper@@
@
text
@d1 1
a1 1
$OpenBSD: patch-src_ck-sysdeps-openbsd_c,v 1.6 2010/07/01 07:50:59 ajacoutot Exp $
d131 1
a131 1
+                struct kinfo_proc2 *p)
d140 1
a140 1
+	name[namelen++] = KERN_PROC2;
d147 1
a147 1
+		perror("sysctl kern.proc2.pid");
d159 1
a159 1
+        struct kinfo_proc2 p;
d256 1
a256 1
+        struct kinfo_proc2 p;
d319 1
a319 1
+        struct kinfo_proc2 p;
@


1.6
log
@Some tweaks and remove BROKEN.

*** While basic functionnality works, this is NOT hooked up yet as more
things are coming and there is still a glib2/pthread bug preventing a
console to be detected as active.
@
text
@d1 4
a4 4
$OpenBSD: patch-src_ck-sysdeps-openbsd_c,v 1.5 2010/07/01 01:00:09 ajacoutot Exp $
--- src/ck-sysdeps-openbsd.c.orig	Thu Jul  1 02:47:13 2010
+++ src/ck-sysdeps-openbsd.c	Thu Jul  1 02:48:18 2010
@@@@ -0,0 +1,414 @@@@
d204 1
d206 3
d359 2
d363 1
d385 2
d389 1
d413 2
d422 4
@


1.5
log
@Fix get_kinfo_proc() with help from robert@@
@
text
@d1 1
a1 1
$OpenBSD: patch-src_ck-sysdeps-openbsd_c,v 1.4 2010/06/28 15:55:21 ajacoutot Exp $
d203 1
a203 1
+		/* XXXJDM nasty hack */
d342 1
a342 1
+	/* XXXJDM how can we find out how many are configured? */
d344 1
a344 1
+                *num = 8;
@


1.4
log
@Fix socket credential support.
Tweak COMMENT while here.
@
text
@d1 3
a3 3
$OpenBSD: patch-src_ck-sysdeps-openbsd_c,v 1.3 2009/11/13 14:52:33 ajacoutot Exp $
--- src/ck-sysdeps-openbsd.c.orig	Mon Jun 28 17:04:12 2010
+++ src/ck-sysdeps-openbsd.c	Mon Jun 28 17:05:11 2010
d255 1
a255 1
+        kd = kvm_openfiles (_PATH_DEVNULL, _PATH_DEVNULL, NULL, O_RDONLY, NULL);
@


1.3
log
@Bring in several fixes from FreeBSD and fd.o bugzilla.
Fix tty names, cmd arguments... Install the stop/restart scripts.
Remove policykit support for now.
@
text
@d1 4
a4 4
$OpenBSD: patch-src_ck-sysdeps-openbsd_c,v 1.2 2009/10/16 09:36:56 ajacoutot Exp $
--- src/ck-sysdeps-openbsd.c.orig	Sun May 31 04:10:36 2009
+++ src/ck-sysdeps-openbsd.c	Sun May 31 19:24:53 2009
@@@@ -0,0 +1,412 @@@@
d46 4
d100 1
a100 1
+        unsigned long penv;             /* stat            address of initial environment vector */
a220 2
+
+        g_debug ("ck_process_stat_new_for_unix_pid");
@


1.2
log
@Some cleanups:
* mark as broken for now
* fix copyright
* add a few comments to the patches
* fix dependencies
@
text
@d1 1
a1 1
$OpenBSD: patch-src_ck-sysdeps-openbsd_c,v 1.1.1.1 2009/06/07 02:55:19 robert Exp $
d200 1
a200 1
+                memcpy (P->tty_text, "/dev/ttyE4", sizeof P->tty_text);
d356 1
a356 1
+        device = g_strdup_printf ("/dev/ttyE%u", num);
d375 1
a375 1
+        if (sscanf (device, "/dev/ttyE%u", &n) == 1) {
d407 1
a407 1
+        g_debug ("Active VT is: %d (ttyE%d)", active, active - 1);
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
$OpenBSD$
d10 1
a10 1
+ * Copyright (C) 2009 Jared D. McNeill <robert@@openbsd.org>
@


1.1.1.1
log
@import ConsoleKit-0.3.0:
ConsoleKit is a framework for defining and tracking users, login
sessions, and seats.  The primary motivations for this framework are to
facilitate fast-user-switching and multi-seat capabilities, and to
enable more sophisticated policy decisions for desktop sessions.

this is not hooked up to the build just yet, just like policykit
@
text
@@
