head	1.2;
access;
symbols
	jsg_20160529:1.1.1.1 jsg:1.1.1;
locks; strict;
comment	@# @;


1.2
date	2016.07.12.12.35.44;	author jsg;	state dead;
branches;
next	1.1;
commitid	eIlHYyCivBqIyTDE;

1.1
date	2016.05.29.01.35.33;	author jsg;	state Exp;
branches
	1.1.1.1;
next	;
commitid	bmQeGNtjT62xSFTz;

1.1.1.1
date	2016.05.29.01.35.33;	author jsg;	state Exp;
branches;
next	;
commitid	bmQeGNtjT62xSFTz;


desc
@@


1.2
log
@Update to U-Boot 2016.07 which will be used in the armv7 release.

This includes the patch to not allocate memory from holes with the efi
loader and adds support for network access from efi payloads as well.

ok sthen@@ naddy@@
@
text
@$OpenBSD: patch-lib_efi_loader_efi_memory_c,v 1.1 2016/05/29 01:35:33 jsg Exp $
--- lib/efi_loader/efi_memory.c.orig	Tue May 17 00:40:32 2016
+++ lib/efi_loader/efi_memory.c	Fri May 27 19:23:45 2016
@@@@ -24,6 +24,10 @@@@ struct efi_mem_list {
 	struct efi_mem_desc desc;
 };
 
+#define EFI_CARVE_NO_OVERLAP		-1
+#define EFI_CARVE_LOOP_AGAIN		-2
+#define EFI_CARVE_OVERLAPS_NONRAM	-3
+
 /* This list contains all memory map items */
 LIST_HEAD(efi_mem);
 
@@@@ -74,11 +78,11 @@@@ static int efi_mem_carve_out(struct efi_mem_list *map,
 
 	/* check whether we're overlapping */
 	if ((carve_end <= map_start) || (carve_start >= map_end))
-		return 0;
+		return EFI_CARVE_NO_OVERLAP;
 
 	/* We're overlapping with non-RAM, warn the caller if desired */
 	if (overlap_only_ram && (map_desc->type != EFI_CONVENTIONAL_MEMORY))
-		return -1;
+		return EFI_CARVE_OVERLAPS_NONRAM;
 
 	/* Sanitize carve_start and carve_end to lie within our bounds */
 	carve_start = max(carve_start, map_start);
@@@@ -93,7 +97,7 @@@@ static int efi_mem_carve_out(struct efi_mem_list *map,
 
 		map_desc->physical_start = carve_end;
 		map_desc->num_pages = (map_end - carve_end) >> EFI_PAGE_SHIFT;
-		return 1;
+		return (carve_end - carve_start) >> EFI_PAGE_SHIFT;
 	}
 
 	/*
@@@@ -113,7 +117,7 @@@@ static int efi_mem_carve_out(struct efi_mem_list *map,
 	/* Shrink the map to [ map_start ... carve_start ] */
 	map_desc->num_pages = (carve_start - map_start) >> EFI_PAGE_SHIFT;
 
-	return 1;
+	return EFI_CARVE_LOOP_AGAIN;
 }
 
 uint64_t efi_add_memory_map(uint64_t start, uint64_t pages, int memory_type,
@@@@ -121,7 +125,8 @@@@ uint64_t efi_add_memory_map(uint64_t start, uint64_t p
 {
 	struct list_head *lhandle;
 	struct efi_mem_list *newlist;
-	bool do_carving;
+	bool carve_again;
+	uint64_t carved_pages = 0;
 
 	if (!pages)
 		return start;
@@@@ -148,7 +153,7 @@@@ uint64_t efi_add_memory_map(uint64_t start, uint64_t p
 
 	/* Add our new map */
 	do {
-		do_carving = false;
+		carve_again = false;
 		list_for_each(lhandle, &efi_mem) {
 			struct efi_mem_list *lmem;
 			int r;
@@@@ -156,14 +161,44 @@@@ uint64_t efi_add_memory_map(uint64_t start, uint64_t p
 			lmem = list_entry(lhandle, struct efi_mem_list, link);
 			r = efi_mem_carve_out(lmem, &newlist->desc,
 					      overlap_only_ram);
-			if (r < 0) {
+			switch (r) {
+			case EFI_CARVE_OVERLAPS_NONRAM:
+				/*
+				 * The user requested to only have RAM overlaps,
+				 * but we hit a non-RAM region. Error out.
+				 */
 				return 0;
-			} else if (r) {
-				do_carving = true;
+			case EFI_CARVE_NO_OVERLAP:
+				/* Just ignore this list entry */
 				break;
+			case EFI_CARVE_LOOP_AGAIN:
+				/*
+				 * We split an entry, but need to loop through
+				 * the list again to actually carve it.
+				 */
+				carve_again = true;
+				break;
+			default:
+				/* We carved a number of pages */
+				carved_pages += r;
+				carve_again = true;
+				break;
 			}
+
+			if (carve_again) {
+				/* The list changed, we need to start over */
+				break;
+			}
 		}
-	} while (do_carving);
+	} while (carve_again);
+
+	if (overlap_only_ram && (carved_pages != pages)) {
+		/*
+		 * The payload wanted to have RAM overlaps, but we overlapped
+		 * with an unallocated region. Error out.
+		 */
+		return 0;
+	}
 
 	/* Add our new map */
         list_add_tail(&newlist->link, &efi_mem);
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
$OpenBSD$
@


1.1.1.1
log
@Import U-Boot 2016.05

U-Boot is a firmware for embedded boards based on PowerPC, ARM, MIPS and
several other processors, which can be installed in a boot ROM and used to
initialize and test the hardware or to download and run application code.

As ARM systems often do not come with firmware it must be supplied on
an SD card or MMC device to have a bootable system.

This port provides U-Boot for various boards using ARM processors.

armv7 requires the support for EFI payloads added in this release to run
the bootloader.  A proposed patch to prevent the EFI interface from
allocating pages from unpopulated memory by Alexander Graf is included
which will hopefully be part of future releases:
http://marc.info/?l=u-boot&m=146434472023891&w=2

Feedback from jca@@ and sthen@@.  ok sthen@@ on an earlier version without
the EFI patch.
@
text
@@
