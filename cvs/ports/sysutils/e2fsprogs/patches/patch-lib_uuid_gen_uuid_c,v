head	1.1;
access;
symbols
	OPENBSD_6_2:1.1.0.12
	OPENBSD_6_2_BASE:1.1
	OPENBSD_6_1:1.1.0.10
	OPENBSD_6_1_BASE:1.1
	OPENBSD_6_0:1.1.0.8
	OPENBSD_6_0_BASE:1.1
	OPENBSD_5_9:1.1.0.4
	OPENBSD_5_9_BASE:1.1
	OPENBSD_5_8:1.1.0.6
	OPENBSD_5_8_BASE:1.1
	OPENBSD_5_7:1.1.0.2
	OPENBSD_5_7_BASE:1.1;
locks; strict;
comment	@# @;


1.1
date	2014.11.10.20.38.50;	author sthen;	state Exp;
branches;
next	;
commitid	ZWdpzOBTJqqalnHy;


desc
@@


1.1
log
@- use arc4random in e2fsprogs' libuuid

- disable uuidd, it wasn't properly enabled in the port anyway (and most
situations where /dev/random would fail, the uuidd socket would also be
inaccessible)
@
text
@$OpenBSD$
--- lib/uuid/gen_uuid.c.orig	Sat Nov  8 10:51:53 2014
+++ lib/uuid/gen_uuid.c	Sat Nov  8 11:12:57 2014
@@@@ -167,8 +167,17 @@@@ static int get_random_fd(void)
 	return fd;
 }
 
-
+#ifdef __OpenBSD__
 /*
+ * On OpenBSD, arc4random does not require a device node, so we can
+ * use it always.
+ */
+static void get_random_bytes(void *buf, int nbytes)
+{
+	arc4random_buf(buf, nbytes);
+}
+#else
+/*
  * Generate a series of random bytes.  Use /dev/urandom if possible,
  * and if not, use srandom/random.
  */
@@@@ -213,6 +222,7 @@@@ static void get_random_bytes(void *buf, int nbytes)
 
 	return;
 }
+#endif
 
 /*
  * Get the ethernet hardware address, if we can find it...
@@@@ -663,7 +673,17 @@@@ void uuid_generate_random(uuid_t out)
 }
 
 
+#ifdef __OpenBSD__
 /*
+ * On OpenBSD, arc4random does not require a device node, so we can
+ * use it always.
+ */
+void uuid_generate(uuid_t out)
+{
+	uuid_generate_random(out);
+}
+#else
+/*
  * This is the generic front-end to uuid_generate_random and
  * uuid_generate_time.  It uses uuid_generate_random only if
  * /dev/urandom is available, since otherwise we won't have
@@@@ -676,3 +696,4 @@@@ void uuid_generate(uuid_t out)
 	else
 		uuid_generate_time(out);
 }
+#endif
@
