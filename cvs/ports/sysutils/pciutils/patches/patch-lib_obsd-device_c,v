head	1.5;
access;
symbols
	OPENBSD_6_1:1.5.0.10
	OPENBSD_6_1_BASE:1.5
	OPENBSD_6_0:1.5.0.8
	OPENBSD_6_0_BASE:1.5
	OPENBSD_5_9:1.5.0.4
	OPENBSD_5_9_BASE:1.5
	OPENBSD_5_8:1.5.0.6
	OPENBSD_5_8_BASE:1.5
	OPENBSD_5_7:1.5.0.2
	OPENBSD_5_7_BASE:1.5
	OPENBSD_5_6:1.4.0.10
	OPENBSD_5_6_BASE:1.4
	OPENBSD_5_5:1.4.0.8
	OPENBSD_5_5_BASE:1.4
	OPENBSD_5_4:1.4.0.6
	OPENBSD_5_4_BASE:1.4
	OPENBSD_5_3:1.4.0.4
	OPENBSD_5_3_BASE:1.4
	OPENBSD_5_2:1.4.0.2
	OPENBSD_5_2_BASE:1.4
	OPENBSD_5_1_BASE:1.3
	OPENBSD_5_1:1.3.0.22
	OPENBSD_5_0:1.3.0.20
	OPENBSD_5_0_BASE:1.3
	OPENBSD_4_9:1.3.0.18
	OPENBSD_4_9_BASE:1.3
	OPENBSD_4_8:1.3.0.16
	OPENBSD_4_8_BASE:1.3
	OPENBSD_4_7:1.3.0.14
	OPENBSD_4_7_BASE:1.3
	OPENBSD_4_6:1.3.0.12
	OPENBSD_4_6_BASE:1.3
	OPENBSD_4_5:1.3.0.10
	OPENBSD_4_5_BASE:1.3
	OPENBSD_4_4:1.3.0.8
	OPENBSD_4_4_BASE:1.3
	OPENBSD_4_3:1.3.0.6
	OPENBSD_4_3_BASE:1.3
	OPENBSD_4_2:1.3.0.4
	OPENBSD_4_2_BASE:1.3
	OPENBSD_4_1:1.3.0.2
	OPENBSD_4_1_BASE:1.3
	OPENBSD_4_0:1.1.1.1.0.2
	OPENBSD_4_0_BASE:1.1.1.1
	V2_2_1:1.1.1.1
	PCIUTILS:1.1.1;
locks; strict;
comment	@# @;


1.5
date	2014.08.21.08.02.56;	author dcoppa;	state Exp;
branches;
next	1.4;
commitid	r0pAJ5Zcys14FvmB;

1.4
date	2012.07.11.18.17.52;	author gonzalo;	state Exp;
branches;
next	1.3;

1.3
date	2006.12.30.14.55.25;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2006.12.12.20.32.37;	author kettenis;	state Exp;
branches;
next	1.1;

1.1
date	2006.03.25.21.53.35;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.03.25.21.53.35;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.5
log
@
Update to pciutils-3.2.1

suggestion and ok jca@@
ok matthieu@@ (maintainer)
@
text
@$OpenBSD: patch-lib_obsd-device_c,v 1.4 2012/07/11 18:17:52 gonzalo Exp $
--- lib/obsd-device.c.orig	Fri Jan  7 22:04:28 2011
+++ lib/obsd-device.c	Thu Aug 21 09:59:31 2014
@@@@ -41,9 +41,12 @@@@ obsd_init(struct pci_access *a)
 {
   char *name = pci_get_param(a, "obsd.path");
 
-  a->fd = open(name, O_RDWR, 0);
-  if (a->fd < 0)
-    a->error("obsd_init: %s open failed", name);
+  a->fd = open(name, O_RDWR | O_CLOEXEC);
+  if (a->fd == -1) {
+    a->fd = open(name, O_RDONLY | O_CLOEXEC);
+    if (a->fd == -1)
+      a->error("obsd_init: %s open failed (%s)", name, strerror(errno));
+  }
 }
 
 static void
@@@@ -56,11 +59,6 @@@@ static int
 obsd_read(struct pci_dev *d, int pos, byte *buf, int len)
 {
   struct pci_io pi;
-  union {
-	  u_int32_t u32;
-	  u_int16_t u16[2];
-	  u_int8_t u8[4];
-  } u;
 
   if (!(len == 1 || len == 2 || len == 4))
     return pci_generic_block_read(d, pos, buf, len);
@@@@ -81,18 +79,16 @@@@ obsd_read(struct pci_dev *d, int pos, byte *buf, int l
 	  else
 		  d->access->error("obsd_read: ioctl(PCIOCREAD) failed");
   }
-  u.u32 = pi.pi_data;
-
   switch (len)
     {
     case 1:
-      buf[0] = (u8) u.u8[pos % 4];
+      buf[0] = (u8) (pi.pi_data >> ((pos % 4) * 8));
       break;
     case 2:
-      ((u16 *) buf)[0] = letoh16(u.u16[(pos % 4) / 2]);
+      ((u16 *) buf)[0] = (u16) htole16(pi.pi_data >> ((pos % 4) * 8));
       break;
     case 4:
-      ((u32 *) buf)[0] = (u32) letoh32(pi.pi_data);
+      ((u32 *) buf)[0] = (u32) htole32(pi.pi_data);
       break;
     }
   return 1;
@


1.4
log
@This is a little update for pciutils to 3.1.9 with some changes:

* Whereever we mention the PCI ID database, we now refer to
  http://pci-ids.ucw.cz/ and the sf.net site is mentioned only
  as a mirror. This includes update-pciids.
* Decode PCIe Gen 3 speeds and link status fields.
* Various minor bug fixes.
* Updated pci.ids to the today's snapshot of the database.

While here, zap some white spaces, GROFF is not needed and add some mirrors.

Tested on i386.

Ok matthieu@@ (maintainer) aja@@
@
text
@d1 20
a20 4
$OpenBSD: patch-lib_obsd-device_c,v 1.3 2006/12/30 14:55:25 matthieu Exp $
--- lib/obsd-device.c.orig	Fri Jan  7 18:04:28 2011
+++ lib/obsd-device.c	Fri Jun 29 10:19:48 2012
@@@@ -56,11 +56,6 @@@@ static int
d32 1
a32 1
@@@@ -81,18 +76,16 @@@@ obsd_read(struct pci_dev *d, int pos, byte *buf, int l
@


1.3
log
@Update to pciutils 2.2.4. With help and testing from steven@@
@
text
@d1 4
a4 4
$OpenBSD$
--- lib/obsd-device.c.orig	Sat Sep  9 12:53:01 2006
+++ lib/obsd-device.c	Sat Dec 16 16:13:26 2006
@@@@ -58,11 +58,6 @@@@ static int
d15 3
a17 2
     {
@@@@ -86,18 +81,16 @@@@ obsd_read(struct pci_dev *d, int pos, by
a18 1
 	  }
@


1.2
log
@Make reading PCI registers work on big-endian platforms.

ok matthieu@@
@
text
@d1 25
a25 98
$OpenBSD: patch-lib_obsd-device_c,v 1.1.1.1 2006/03/25 21:53:35 matthieu Exp $
--- lib/obsd-device.c.orig	Wed Nov 22 20:07:11 2006
+++ lib/obsd-device.c	Tue Dec 12 12:03:49 2006
@@@@ -0,0 +1,160 @@@@
+/*
+ *	The PCI Library -- FreeBSD /dev/pci access
+ *
+ *	Copyright (c) 1999 Jari Kirma <kirma@@cs.hut.fi>
+ *	Updated in 2003 by Samy Al Bahra <samy@@kerneled.com>
+ *
+ *	Can be freely distributed and used under the terms of the GNU GPL.
+ */
+
+#include <fcntl.h>
+#include <string.h>
+#include <unistd.h>
+#include <errno.h>
+#include <sys/endian.h>
+#include <sys/types.h>
+#include <sys/ioctl.h>
+#include <sys/pciio.h>
+#include "internal.h"
+
+static void
+obsd_config(struct pci_access *a)
+{
+  a->method_params[PCI_ACCESS_OBSD_DEVICE] = PCI_PATH_OBSD_DEVICE;
+}
+
+static int
+obsd_detect(struct pci_access *a)
+{
+  char *name = a->method_params[PCI_ACCESS_OBSD_DEVICE];
+
+  if (access(name, R_OK))
+    {
+      a->warning("Cannot open %s", name);
+      return 0;
+    }
+  a->debug("...using %s", name);
+  return 1;
+}
+
+static void
+obsd_init(struct pci_access *a)
+{
+  char *name = a->method_params[PCI_ACCESS_OBSD_DEVICE];
+
+  a->fd = open(name, O_RDWR, 0);
+  if (a->fd < 0)
+    {
+      a->error("obsd_init: %s open failed", name);
+    }
+}
+
+static void
+obsd_cleanup(struct pci_access *a)
+{
+  close(a->fd);
+}
+
+static int
+obsd_read(struct pci_dev *d, int pos, byte *buf, int len)
+{
+  struct pci_io pi;
+  union {
+	  u_int32_t u32;
+	  u_int16_t u16[2];
+	  u_int8_t u8[4];
+  } u;
+
+  if (!(len == 1 || len == 2 || len == 4))
+    {
+      return pci_generic_block_read(d, pos, buf, len);
+    }
+
+  if (pos >= 256)
+    return 0;
+
+  pi.pi_sel.pc_bus = d->bus;
+  pi.pi_sel.pc_dev = d->dev;
+  pi.pi_sel.pc_func = d->func;
+
+  pi.pi_reg = pos - (pos % 4);
+  pi.pi_width = 4;
+	
+  if (ioctl(d->access->fd, PCIOCREAD, &pi) < 0) {
+	  if (errno == ENXIO) {
+		  pi.pi_data = 0xffffffff;
+	  } else {
+		  d->access->error("obsd_read: ioctl(PCIOCREAD) failed");
+	  }
+  }
+  u.u32 = pi.pi_data;
+
+  switch (len)
+    {
+    case 1:
d27 3
a29 2
+      break;
+    case 2:
d31 3
a33 2
+      break;
+    case 4:
d35 3
a37 59
+      break;
+    }
+  return 1;
+}
+
+static int
+obsd_write(struct pci_dev *d, int pos, byte *buf, int len)
+{
+  struct pci_io pi;
+
+  if (!(len == 1 || len == 2 || len == 4))
+    {
+      return pci_generic_block_write(d, pos, buf, len);
+    }
+
+  if (pos >= 256)
+    return 0;
+
+  pi.pi_sel.pc_bus = d->bus;
+  pi.pi_sel.pc_dev = d->dev;
+  pi.pi_sel.pc_func = d->func;
+
+  pi.pi_reg = pos;
+  pi.pi_width = len;
+	
+  switch (len)
+    {
+    case 1:
+      pi.pi_data = buf[0];
+      break;
+    case 2:
+      pi.pi_data = ((u16 *) buf)[0];
+      break;
+    case 4:
+      pi.pi_data = ((u32 *) buf)[0];
+      break;
+    }
+  
+  if (ioctl(d->access->fd, PCIOCWRITE, &pi) < 0)
+    {
+      d->access->error("obsd_write: ioctl(PCIOCWRITE) failed");
+    }
+
+  return 1;
+}
+
+struct pci_methods pm_obsd_device = {
+  "OpenBSD-device",
+  obsd_config,
+  obsd_detect,
+  obsd_init,
+  obsd_cleanup,
+  pci_generic_scan,
+  pci_generic_fill_info,
+  obsd_read,
+  obsd_write,
+  NULL,                                 /* dev_init */
+  NULL                                  /* dev_cleanup */
+};
@


1.1
log
@Initial revision
@
text
@d1 3
a3 3
$OpenBSD$
--- lib/obsd-device.c.orig	Wed Mar 22 22:59:36 2006
+++ lib/obsd-device.c	Wed Mar 22 22:59:36 2006
d99 1
a99 1
+      buf[0] = (u8) u.u8[pos % 4];
d102 1
a102 1
+      ((u16 *) buf)[0] = letoh16(u.u16[(pos % 4) / 2]);
d105 1
a105 1
+      ((u32 *) buf)[0] = (u32) letoh32(pi.pi_data);
@


1.1.1.1
log
@Add pciutils, a library for portable access to PCI bus configuration 
registers and utilities based on this library (lspci & co).
with help from and ok sturm@@.
@
text
@@
