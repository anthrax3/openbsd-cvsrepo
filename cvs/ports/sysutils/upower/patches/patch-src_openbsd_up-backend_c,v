head	1.21;
access;
symbols
	OPENBSD_6_0:1.20.0.2
	OPENBSD_6_0_BASE:1.20
	OPENBSD_5_6:1.17.0.2
	OPENBSD_5_6_BASE:1.17
	OPENBSD_5_4:1.8.0.2
	OPENBSD_5_4_BASE:1.8
	OPENBSD_5_2:1.5.0.2
	OPENBSD_5_2_BASE:1.5
	OPENBSD_5_1_BASE:1.4
	OPENBSD_5_1:1.4.0.2
	OPENBSD_5_0:1.3.0.2
	OPENBSD_5_0_BASE:1.3;
locks; strict;
comment	@# @;


1.21
date	2016.08.29.08.40.38;	author jasper;	state Exp;
branches;
next	1.20;
commitid	r6jf7BaSYPnD2AwR;

1.20
date	2016.05.04.11.11.55;	author jasper;	state Exp;
branches;
next	1.19;
commitid	6KDLgBsTKC9qCLQ6;

1.19
date	2016.04.26.12.37.43;	author landry;	state Exp;
branches;
next	1.18;
commitid	YfPO2FYz7DGW0Izs;

1.18
date	2014.09.02.19.23.33;	author landry;	state dead;
branches;
next	1.17;
commitid	eWxywLRr5QiCKfmS;

1.17
date	2014.05.23.19.21.07;	author landry;	state Exp;
branches;
next	1.16;

1.16
date	2014.04.23.09.55.18;	author jasper;	state Exp;
branches;
next	1.15;

1.15
date	2014.04.20.18.20.43;	author jasper;	state Exp;
branches;
next	1.14;

1.14
date	2014.04.20.18.03.23;	author jasper;	state Exp;
branches;
next	1.13;

1.13
date	2013.10.18.16.43.51;	author landry;	state dead;
branches;
next	1.12;

1.12
date	2013.10.12.08.10.13;	author ajacoutot;	state Exp;
branches;
next	1.11;

1.11
date	2013.10.03.13.42.17;	author landry;	state Exp;
branches;
next	1.10;

1.10
date	2013.10.03.11.03.41;	author jasper;	state Exp;
branches;
next	1.9;

1.9
date	2013.10.03.10.52.59;	author jasper;	state Exp;
branches;
next	1.8;

1.8
date	2013.03.29.12.41.26;	author ajacoutot;	state Exp;
branches;
next	1.7;

1.7
date	2013.03.27.07.23.45;	author ajacoutot;	state Exp;
branches;
next	1.6;

1.6
date	2012.08.21.17.27.13;	author ajacoutot;	state dead;
branches;
next	1.5;

1.5
date	2012.06.27.06.39.50;	author landry;	state Exp;
branches;
next	1.4;

1.4
date	2012.01.03.21.50.06;	author landry;	state Exp;
branches;
next	1.3;

1.3
date	2011.07.08.08.16.09;	author dcoppa;	state Exp;
branches;
next	1.2;

1.2
date	2011.07.07.19.02.43;	author dcoppa;	state Exp;
branches;
next	1.1;

1.1
date	2011.06.17.15.08.36;	author landry;	state Exp;
branches;
next	;


desc
@@


1.21
log
@add link to upstream bz
@
text
@$OpenBSD: patch-src_openbsd_up-backend_c,v 1.20 2016/05/04 11:11:55 jasper Exp $

Add missing #include after https://cgit.freedesktop.org/upower/commit/?id=77239cc4470fc515e1c8c6c21005fa08f3b1b04e

Remove pointless upperbound, SENSOR_MAX_TYPES has no meaning here and we
break from the loop anyway when needed.
https://bugs.freedesktop.org/show_bug.cgi?id=95257

--- src/openbsd/up-backend.c.orig	Wed Jul 29 14:47:49 2015
+++ src/openbsd/up-backend.c	Wed May  4 10:44:04 2016
@@@@ -24,6 +24,7 @@@@
 #include "up-backend.h"
 #include "up-daemon.h"
 #include "up-device.h"
+#include "up-backend-bsd-private.h"
 #include <string.h> /* strcmp() */
 
 static void	up_backend_class_init	(UpBackendClass	*klass);
@@@@ -461,7 +462,7 @@@@ up_backend_update_lid_status(UpDaemon *daemon) {
 	/* go through all acpibtn devices, and check if one of the values match "lid"
 	   if so, use that device.
 	*/
-	for (dev = 0; SENSOR_MAX_TYPES; dev++) {
+	for (dev = 0; ; dev++) {
 		mib[2] = dev;
 		if (sysctl(mib, 3, &sensordev, &sdlen, NULL, 0) == -1) {
 			if (errno == ENXIO)
@


1.20
log
@Remove pointless upperbound, SENSOR_MAX_TYPES has no meaning here and we
break from the loop anyway when needed (when ENOENT is returned). This makes
it in line with other sensor walkers.

ok landry@@ (MAINTAINER)
@
text
@d1 1
a1 1
$OpenBSD: patch-src_openbsd_up-backend_c,v 1.19 2016/04/26 12:37:43 landry Exp $
d7 1
@


1.19
log
@Updqte to upower 0.99.4

https://lists.freedesktop.org/archives/devkit-devel/2016-February/001751.html

ok ajacoutot@@
@
text
@d1 1
a1 1
$OpenBSD$
d4 6
a9 2
--- src/openbsd/up-backend.c.orig	Sun Apr 17 12:38:26 2016
+++ src/openbsd/up-backend.c	Sun Apr 17 12:38:32 2016
d18 9
@


1.18
log
@Update to upower 0.99.1.

Remove patch merged upstream, and now useless dep on polkit.
ok ajacoutot@@
@
text
@d1 1
a1 1
$OpenBSD: patch-src_openbsd_up-backend_c,v 1.17 2014/05/23 19:21:07 landry Exp $
d3 9
a11 159
From 4bed9c99c1d459f0d1bc760716573e2a2af5e0e1 Mon Sep 17 00:00:00 2001
From: Jasper Lievisse Adriaanse <jasper@@humppa.nl>
Date: Sun, 20 Apr 2014 18:15:36 +0000
Subject: Update lid status when updating ac status.
         https://bugs.freedesktop.org/show_bug.cgi?id=77692

--- src/openbsd/up-backend.c.orig	Tue Oct 29 11:37:08 2013
+++ src/openbsd/up-backend.c	Sat May 17 17:55:23 2014
@@@@ -34,6 +34,7 @@@@ static void	up_backend_finalize	(GObject		*object);
 static gboolean	up_backend_apm_get_power_info(struct apm_power_info*);
 UpDeviceState up_backend_apm_get_battery_state_value(u_char battery_state);
 static void	up_backend_update_acpibat_state(UpDevice*, struct sensordev);
+static void	up_backend_update_lid_status(UpDaemon*);
 
 static gboolean		up_apm_device_get_on_battery	(UpDevice *device, gboolean *on_battery);
 static gboolean		up_apm_device_get_online		(UpDevice *device, gboolean *online);
@@@@ -128,10 +129,10 @@@@ up_backend_coldplug (UpBackend *backend, UpDaemon *dae
 	UpApmNative *acnative = NULL;
 	UpApmNative *battnative = NULL;
 	backend->priv->daemon = g_object_ref (daemon);
-	/* XXX no way to get lid status atm */
-	up_daemon_set_lid_is_present (backend->priv->daemon, FALSE);
+
 	if (backend->priv->is_laptop)
 	{
+		up_backend_update_lid_status(daemon);
 		acnative = up_apm_native_new("/ac");
 		if (!up_device_coldplug (backend->priv->ac, backend->priv->daemon, G_OBJECT(acnative)))
 			g_warning ("failed to coldplug ac");
@@@@ -215,6 +216,7 @@@@ up_backend_update_ac_state(UpDevice* device)
 	gboolean ret, new_is_online, cur_is_online;
 	struct apm_power_info a;
 
+	up_backend_update_lid_status(up_device_get_daemon(device));
 	ret = up_backend_apm_get_power_info(&a);
 	if (!ret)
 		return ret;
@@@@ -319,8 +321,8 @@@@ up_backend_update_acpibat_state(UpDevice* device, stru
 {
 	enum sensor_type type;
 	int numt;
-	gdouble bst_volt, bst_rate, bif_lastfullcap, bst_cap, bif_lowcap;
-	/* gdouble bif_dvolt, bif_dcap, capacity; */
+	gdouble bst_volt, bst_rate, bif_cap, bif_lastfullcap, bst_cap, bif_lowcap, capacity;
+	/* gdouble bif_dvolt; */
 	struct sensor sens;
 	size_t slen = sizeof(sens);
 	int mib[] = {CTL_HW, HW_SENSORS, 0, 0, 0};
@@@@ -335,6 +337,9 @@@@ up_backend_update_acpibat_state(UpDevice* device, stru
 			else if (slen > 0 && (sens.flags & SENSOR_FINVALID) == 0) {
 				if (sens.type == SENSOR_VOLTS_DC && !strcmp(sens.desc, "current voltage"))
 					bst_volt = sens.value / 1000000.0f;
+				if ((sens.type == SENSOR_AMPHOUR || sens.type == SENSOR_WATTHOUR) && !strcmp(sens.desc, "design capacity")) {
+					bif_cap = (sens.type == SENSOR_AMPHOUR ? bst_volt : 1) * sens.value / 1000000.0f;
+				}
 				if ((sens.type == SENSOR_AMPHOUR || sens.type == SENSOR_WATTHOUR) && !strcmp(sens.desc, "last full capacity")) {
 					bif_lastfullcap = (sens.type == SENSOR_AMPHOUR ? bst_volt : 1) * sens.value / 1000000.0f;
 				}
@@@@ -349,19 +354,30 @@@@ up_backend_update_acpibat_state(UpDevice* device, stru
 				}
 				/*
 				bif_dvolt = "voltage" = unused ?
-				capacity = lastfull/dcap * 100 ?
 				amphour1 = warning capacity ?
 				raw0 = battery state
 				*/
 			}
 		}
 	}
+
+	capacity = 0.0f;
+	if(bif_lastfullcap > 0 && bif_cap > 0) {
+		capacity = (bif_lastfullcap / bif_cap) * 100.0f;
+		if (capacity < 0)
+			capacity = 0.0f;
+		if (capacity > 100.0)
+			capacity = 100.0f;
+	}
+
 	g_object_set (device,
 		"energy", bst_cap,
 		"energy-full", bif_lastfullcap,
+		"energy-full-design", bif_cap,
 		"energy-rate", bst_rate,
 		"energy-empty", bif_lowcap,
 		"voltage", bst_volt,
+		"capacity", capacity,
 		(void*) NULL);
 }
 
@@@@ -405,6 +421,70 @@@@ up_apm_device_refresh(UpDevice* device)
 	}
 
 	return ret;
+}
+
+/*
+ * Check the lid status, return TRUE if one was found, FALSE otherwise.
+ */
+static void
+up_backend_update_lid_status(UpDaemon *daemon) {
+
+	/* Use hw.sensors.acpibtn0.indicator0=On (lid open) */
+	struct sensordev sensordev;
+	struct sensor sensor;
+	size_t sdlen, slen;
+	int dev, numt, mib[5] = {CTL_HW, HW_SENSORS, 0, 0, 0};
+	gboolean lid_found = FALSE;
+	gboolean lid_open = FALSE;
+
+	sdlen = sizeof(struct sensordev);
+	slen  = sizeof(struct sensor);
+
+	/* go through all acpibtn devices, and check if one of the values match "lid"
+	   if so, use that device.
+	*/
+	for (dev = 0; SENSOR_MAX_TYPES; dev++) {
+		mib[2] = dev;
+		if (sysctl(mib, 3, &sensordev, &sdlen, NULL, 0) == -1) {
+			if (errno == ENXIO)
+				continue;
+			if (errno == ENOENT)
+				break;
+		}
+
+		if (strstr(sensordev.xname, "acpibtn") != NULL) {
+			mib[3] = SENSOR_INDICATOR;
+			for (numt = 0; numt < sensordev.maxnumt[SENSOR_INDICATOR]; numt++) {
+				mib[4] = numt;
+				if (sysctl(mib, 5, &sensor, &slen, NULL, 0) == -1) {
+					if (errno != ENOENT) {
+						g_warning("failed to get sensor data from %s",
+							  sensordev.xname);
+						continue;
+					}
+				}
+
+				/*
+				 * Found an acpibtn device, now check if the
+				 * description has got anything with a lid in it.
+				 */
+				if (strstr(sensor.desc, "lid open") == NULL) {
+					g_warning ("nothing here for %s with %s\n",
+						   sensordev.xname, sensor.desc);
+					continue;
+				} else {
+					lid_found = TRUE;
+					if (sensor.value)
+						lid_open = TRUE;
+					else
+						lid_open = FALSE;
+				}
+			}
+		}
+	}
+
+	up_daemon_set_lid_is_present (daemon, lid_found);
+	up_daemon_set_lid_is_closed (daemon, !lid_open);
 }
d13 1
a13 1
 /* thread doing kqueue() on apm device */
@


1.17
log
@Add EnergyFullDesign and Capacity properties, getting them via the new
acpibat sensor reporting the 'design capacity' of the battery. Fixes a
wrong notification about having a broken battery in KDE4.

From Fabian Raetz, thanks!
@
text
@d1 1
a1 1
$OpenBSD: patch-src_openbsd_up-backend_c,v 1.16 2014/04/23 09:55:18 jasper Exp $
@


1.16
log
@committed upstream
@
text
@d1 1
a1 1
$OpenBSD: patch-src_openbsd_up-backend_c,v 1.15 2014/04/20 18:20:43 jasper Exp $
d10 1
a10 1
+++ src/openbsd/up-backend.c	Sun Apr 20 18:54:05 2014
d40 54
a93 1
@@@@ -405,6 +407,70 @@@@ up_apm_device_refresh(UpDevice* device)
@


1.15
log
@submitted upstream
@
text
@d1 1
a1 1
$OpenBSD: patch-src_openbsd_up-backend_c,v 1.14 2014/04/20 18:03:23 jasper Exp $
d3 5
a7 2
Retrieve lid status for OpenBSD.
https://bugs.freedesktop.org/show_bug.cgi?id=77692
@


1.14
log
@add a way to recognize the lid (wether it's present, open/closed). thanks to
landry for finding the "right" spot to hook it up.

ok landry@@ (MAINTAINER)
@
text
@d1 1
a1 1
$OpenBSD$
d3 2
a4 1
Update lid status when updating ac status.
@


1.13
log
@Straightforward update to upower 0.9.23, mostly integrating our patches
before giving us the middle finger with the next release relying on
logind for hibernate/suspend code, thus deliberately breaking perfectly
working portable code, see
http://lists.freedesktop.org/archives/devkit-devel/2013-October/001519.html
@
text
@d1 1
a1 1
$OpenBSD: patch-src_openbsd_up-backend_c,v 1.12 2013/10/12 08:10:13 ajacoutot Exp $
d3 1
a3 4
- Two OpenBSD fixes: recognize fully charged or absent battery
  https://bugs.freedesktop.org/show_bug.cgi?id=70064
- Use g_thread_try_new() instead of deprecated g_thread_create()
  https://bugs.freedesktop.org/show_bug.cgi?id=70071
d5 7
a11 17
--- src/openbsd/up-backend.c.orig	Fri Sep 20 18:47:11 2013
+++ src/openbsd/up-backend.c	Fri Oct 11 15:48:03 2013
@@@@ -305,7 +305,7 @@@@ static gboolean
 up_backend_update_battery_state(UpDevice* device)
 {
 	gdouble percentage;
-	gboolean ret;
+	gboolean ret, is_present;
 	struct sensordev sdev;
 	UpDeviceState cur_state, new_state;
 	gint64 cur_time_to_empty, new_time_to_empty;
@@@@ -319,16 +319,49 @@@@ up_backend_update_battery_state(UpDevice* device)
 		"state", &cur_state,
 		"percentage", &percentage,
 		"time-to-empty", &cur_time_to_empty,
+		"is-present", &is_present,
 		(void*) NULL);
d13 25
a37 20
 	/* XXX use acpibat0.raw0 if available */
+	/*
+	 * XXX: Stop having a split brain regarding
+	 * up_backend_apm_get_battery_state_value(). Either move the state
+	 * setting code below into that function, or inline that function here.
+	 */
 	new_state = up_backend_apm_get_battery_state_value(a.battery_state);
 	// if percentage/minutes goes down or ac is off, we're likely discharging..
 	if (percentage < a.battery_life || cur_time_to_empty < new_time_to_empty || a.ac_state == APM_AC_OFF)
 		new_state = UP_DEVICE_STATE_DISCHARGING;
+	/*
+	 * If we're on AC, we may either be charging, or the battery is already
+	 * fully charged. Figure out which.
+	 */
 	if (a.ac_state == APM_AC_ON)
-		new_state = UP_DEVICE_STATE_CHARGING;
+		if ((gdouble) a.battery_life >= 99.0)
+			new_state = UP_DEVICE_STATE_FULLY_CHARGED;
+		else
+			new_state = UP_DEVICE_STATE_CHARGING;
d39 61
a99 18
+	if ((a.battery_state == APM_BATTERY_ABSENT) ||
+	    (a.battery_state == APM_BATT_UNKNOWN)) {
+	    	/* Reset some known fields which remain untouched below. */
+		g_object_set(device,
+			     "is-rechargeable", FALSE,
+			     "energy", (gdouble) 0.0,
+			     "energy-empty", (gdouble) 0.0,
+			     "energy-full", (gdouble) 0.0,
+			     "energy-full-design", (gdouble) 0.0,
+			     "energy-rate", (gdouble) 0.0,
+			     NULL);
+		is_present = FALSE;
+		if (a.battery_state == APM_BATTERY_ABSENT)
+			new_state = UP_DEVICE_STATE_EMPTY;
+		else
+			new_state = UP_DEVICE_STATE_UNKNOWN;
+	} else {
+		is_present = TRUE;
d102 3
a104 2
 	// zero out new_time_to empty if we're not discharging or minutes_left is negative
 	new_time_to_empty = (new_state == UP_DEVICE_STATE_DISCHARGING && a.minutes_left > 0 ? a.minutes_left : 0);
d106 1
a106 17
@@@@ -340,6 +373,7 @@@@ up_backend_update_battery_state(UpDevice* device)
 			"state", new_state,
 			"percentage", (gdouble) a.battery_life,
 			"time-to-empty", new_time_to_empty * 60,
+			"is-present", is_present,
 			(void*) NULL);
 		if(up_native_get_sensordev("acpibat0", &sdev))
 			up_backend_update_acpibat_state(device, sdev);
@@@@ -557,7 +591,7 @@@@ up_backend_init (UpBackend *backend)
 		device_class->get_online = up_apm_device_get_online;
 		device_class->refresh = up_apm_device_refresh;
 		/* creates thread */
-		if((backend->priv->apm_thread = (GThread*) g_thread_create((GThreadFunc)up_backend_apm_event_thread, (void*) backend, FALSE, &err) == NULL))
+		if((backend->priv->apm_thread = (GThread*) g_thread_try_new("apm-poller",(GThreadFunc)up_backend_apm_event_thread, (void*) backend, &err) == NULL))
 		{
 			g_warning("Thread create failed: %s", err->message);
 			g_error_free (err);
@


1.12
log
@Update to upower-0.9.22.

ok landry@@ (maintainer)
@
text
@d1 1
a1 1
$OpenBSD: patch-src_openbsd_up-backend_c,v 1.11 2013/10/03 13:42:17 landry Exp $
@


1.11
log
@Assorted fixes on top of jasper's:

- use --enable-deprecated instead of passing -DENABLE_DEPRECATED via the
  configure env, and add a comment explaining that it is about
deprecated featureset (the linux implem now uses logind APIs for
suspend/hibernate calls), nothing related to the G*DEPRECATED macros.
From ajacoutot@@, also prodded by giovanni@@ a while ago.
- backport upstream 7933b0e55234fca86809dad1dee53f0d8e2b96ec,
  g_type_init() is deprecated with glib 2.36.
- use g_thread_try_new instead of deprecated g_thread_create (prodded by
  ajacoutot@@ too)
- include config.h in up-backend.h to reach ENABLE_DEPRECATED #define
The two last patches reported upstream in bug #70071
@
text
@d1 1
a1 1
$OpenBSD: patch-src_openbsd_up-backend_c,v 1.10 2013/10/03 11:03:41 jasper Exp $
a4 2
- Remove unneeded g_thread_init():
  https://bugs.freedesktop.org/show_bug.cgi?id=62795
d8 2
a9 2
--- src/openbsd/up-backend.c.orig	Thu Jan  3 21:47:08 2013
+++ src/openbsd/up-backend.c	Thu Oct  3 13:30:46 2013
d78 1
a78 2
@@@@ -556,9 +590,8 @@@@ up_backend_init (UpBackend *backend)
 		device_class->get_low_battery = up_apm_device_get_low_battery;
a80 1
-		g_thread_init (NULL);
@


1.10
log
@add link to upstream bz
@
text
@d1 1
a1 1
$OpenBSD: patch-src_openbsd_up-backend_c,v 1.9 2013/10/03 10:52:59 jasper Exp $
d7 2
d11 1
a11 1
+++ src/openbsd/up-backend.c	Thu Oct  3 12:47:29 2013
d80 1
a80 1
@@@@ -556,7 +590,6 @@@@ up_backend_init (UpBackend *backend)
d86 2
a87 1
 		if((backend->priv->apm_thread = (GThread*) g_thread_create((GThreadFunc)up_backend_apm_event_thread, (void*) backend, FALSE, &err) == NULL))
d89 2
a90 5
@@@@ -610,4 +643,3 @@@@ up_backend_finalize (GObject *object)
 
 	G_OBJECT_CLASS (up_backend_parent_class)->finalize (object);
 }
-
@


1.9
log
@Two fixes for the OpenBSD-backend:
- Recognize a battery not being present (and reset various metrics accordingly)
- Recognize a fully charged battery

as discussed with and OK landry@@ (MAINTAINER), aja@@
@
text
@d1 1
a1 1
$OpenBSD: patch-src_openbsd_up-backend_c,v 1.8 2013/03/29 12:41:26 ajacoutot Exp $
d3 2
a4 2
- Recognize a battery not being present (and reset various metrics accordingly)
- Recognize a fully charged battery
@


1.8
log
@Update to upower-0.9.20.

ok landry@@ (maintainer)
@
text
@d1 1
a1 1
$OpenBSD: patch-src_openbsd_up-backend_c,v 1.7 2013/03/27 07:23:45 ajacoutot Exp $
d3 4
a6 1
https://bugs.freedesktop.org/show_bug.cgi?id=62795
d8 71
a78 3
--- src/openbsd/up-backend.c.orig	Wed Mar 27 07:53:00 2013
+++ src/openbsd/up-backend.c	Wed Mar 27 07:54:28 2013
@@@@ -556,7 +556,6 @@@@ up_backend_init (UpBackend *backend)
d86 5
@


1.7
log
@g_thread_init is deprecated and will be removed in the next glib2 version
which I am currently working on.
While here, regen WANTLIB and merge PLISTs.

ok landry@@ (maintainer)
@
text
@d1 4
a4 1
$OpenBSD$
@


1.6
log
@Update to upower-0.9.18.

ok landry@@ (maintainer)
@
text
@d1 11
a11 36
$OpenBSD: patch-src_openbsd_up-backend_c,v 1.5 2012/06/27 06:39:50 landry Exp $

Properly initialize update-time when creating devices

--- src/openbsd/up-backend.c.orig	Fri Jan  6 14:41:03 2012
+++ src/openbsd/up-backend.c	Tue Jun 26 09:28:56 2012
@@@@ -529,6 +529,7 @@@@ static void
 up_backend_init (UpBackend *backend)
 {
 	GError *err = NULL;
+	GTimeVal timeval;
 	UpDeviceClass *device_class;
 
 	backend->priv = UP_BACKEND_GET_PRIVATE (backend);
@@@@ -558,6 +559,7 @@@@ up_backend_init (UpBackend *backend)
 		}
 
 		/* setup dummy */
+		g_get_current_time (&timeval);
 		g_object_set (backend->priv->battery,
 			      "type", UP_DEVICE_KIND_BATTERY,
 			      "power-supply", TRUE,
@@@@ -567,11 +569,13 @@@@ up_backend_init (UpBackend *backend)
 			      "state", UP_DEVICE_STATE_UNKNOWN,
 			      "percentage", 0.0f,
 			      "time-to-empty", (gint64) 0,
+			      "update-time", (guint64) timeval.tv_sec,
 			      (void*) NULL);
 		g_object_set (backend->priv->ac,
 			      "type", UP_DEVICE_KIND_LINE_POWER,
 			      "online", TRUE,
 			      "power-supply", TRUE,
+			      "update-time", (guint64) timeval.tv_sec,
 			      (void*) NULL);
 	} else {
 		backend->priv->ac = NULL;
@


1.5
log
@Update to upower 0.9.17

Note that now by default, upowerd will run apm -C when running
on battery and apm -A when on AC, this can be disabled by setting
RunPowersaveCommand to false in etc/UPower/UPower.conf.

ok ajacoutot@@
@
text
@d1 1
a1 1
$OpenBSD: patch-src_openbsd_up-backend_c,v 1.4 2012/01/03 21:50:06 landry Exp $
@


1.4
log
@Update to upower 0.9.15 :
- remove history dir patches merged upstream
- fix deps wrt gettext module, update plist accordingly
- fix rate value, was wrong since last commit to acpibat.c
ok ajacoutot@@
@
text
@d1 1
a1 10
$OpenBSD: patch-src_openbsd_up-backend_c,v 1.3 2011/07/08 08:16:09 dcoppa Exp $

Return true if apm_fd wasn't initialized yet - fixes history

XXX Sometimes apm(4) is not fast enough in calculating the right
time-to-empty value and 'minutes_left' is left as -1, causing
gnome-power-manager to show something like "1193046 hours 27 minutes
of battery power remaining". To avoid this, check that battery is
discharging *and* minutes_left is positive, otherwise set
new_time_to_emtpy to zero XXX
d5 3
a7 60
--- src/openbsd/up-backend.c.orig	Tue May 31 12:07:03 2011
+++ src/openbsd/up-backend.c	Mon Jan  2 20:40:45 2012
@@@@ -62,7 +62,7 @@@@ enum {
 
 static guint signals [SIGNAL_LAST] = { 0 };
 
-int apm_fd; /* ugly global.. needs to move to a device native object */
+int apm_fd = 0; /* ugly global.. needs to move to a device native object */
 
 G_DEFINE_TYPE (UpBackend, up_backend, G_TYPE_OBJECT)
 
@@@@ -324,8 +324,11 @@@@ up_backend_update_battery_state(UpDevice* device)
 	if (a.ac_state == APM_AC_ON)
 		new_state = UP_DEVICE_STATE_CHARGING;
 
-	// zero out new_time_to empty if we're not discharging
-	new_time_to_empty = (new_state == UP_DEVICE_STATE_DISCHARGING ? a.minutes_left : 0);
+	// zero out new_time_to_empty if we're not discharging, if minutes_left has a negative value
+	if (new_state == UP_DEVICE_STATE_DISCHARGING && (int)a.minutes_left > 0)
+		new_time_to_empty = a.minutes_left;
+	else
+		new_time_to_empty = 0;
 
 	if (cur_state != new_state ||
 		percentage != (gdouble) a.battery_life ||
@@@@ -377,8 +380,10 @@@@ up_backend_update_acpibat_state(UpDevice* device, stru
 					typev = sens.type;
 					bst_cap = sens.value / 1000000.0f;
 				}
-				if (sens.type == SENSOR_INTEGER && !strcmp(sens.desc, "rate"))
-					bst_rate = sens.value / 1000.0f;
+				if ((sens.type == SENSOR_AMPS || sens.type == SENSOR_WATTS) && !strcmp(sens.desc, "rate")) {
+					typev = sens.type;
+					bst_rate = sens.value / 1000000.0f;
+				}
 				/*
 				bif_dvolt = "voltage" = unused ?
 				capacity = lastfull/dcap * 100 ?
@@@@ -388,7 +393,7 @@@@ up_backend_update_acpibat_state(UpDevice* device, stru
 			}
 		}
 	}
-	if (typev == SENSOR_AMPHOUR) {
+	if (typev == SENSOR_AMPHOUR || typev == SENSOR_AMPS) {
 		bst_cap *= bst_volt;
 		bif_lowcap *= bst_volt;
 		bif_lastfullcap *= bst_volt;
@@@@ -424,6 +429,11 @@@@ up_apm_device_refresh(UpDevice* device)
 	GTimeVal timeval;
 	gboolean ret;
 
+	if (apm_fd == 0) {
+		g_debug("refresh callback called but apm_fd is not initialized yet");
+		return TRUE;
+	}
+
 	g_object_get (device, "type", &type, NULL);
 
 	switch (type) {
@@@@ -544,6 +554,7 @@@@ static void
d15 1
a15 1
@@@@ -573,6 +584,7 @@@@ up_backend_init (UpBackend *backend)
d23 1
a23 1
@@@@ -582,11 +594,13 @@@@ up_backend_init (UpBackend *backend)
@


1.3
log
@Make upower behave like apmd (check for minutes_left to be > 0, not >= 0)
While here, reword comment a little bit.

OK ajacoutot@@
@
text
@d1 1
a1 1
$OpenBSD: patch-src_openbsd_up-backend_c,v 1.2 2011/07/07 19:02:43 dcoppa Exp $
d15 1
a15 1
+++ src/openbsd/up-backend.c	Thu Jul  7 19:24:21 2011
d39 23
a61 1
@@@@ -424,6 +427,11 @@@@ up_apm_device_refresh(UpDevice* device)
d73 1
a73 1
@@@@ -544,6 +552,7 @@@@ static void
d81 1
a81 1
@@@@ -573,6 +582,7 @@@@ up_backend_init (UpBackend *backend)
d89 1
a89 1
@@@@ -582,11 +592,13 @@@@ up_backend_init (UpBackend *backend)
@


1.2
log
@Update to upower-0.9.12 plus fixes.

Discussed with and OK landry@@, ajacoutot@@
@
text
@d1 1
a1 1
$OpenBSD: patch-src_openbsd_up-backend_c,v 1.1 2011/06/17 15:08:36 landry Exp $
d8 3
a10 2
of battery power remaining". So, check for minutes_left to be
non-negative and zero out new_time_to_empty if it is XXX
d32 1
a32 1
+	if (new_state == UP_DEVICE_STATE_DISCHARGING && (int)a.minutes_left >= 0)
@


1.1
log
@Fix history in upower :
- don't try to fetch from dev/apm if the fd isn't available yet (to be
  discussed with upstream)
- use var/db/upower to store history files

Fixes graphs in gnome-power-statistics...
@
text
@d1 2
a2 1
$OpenBSD$
d4 11
a14 2
--- src/openbsd/up-backend.c.orig	Thu Jun 16 09:19:40 2011
+++ src/openbsd/up-backend.c	Thu Jun 16 09:20:38 2011
d24 15
a38 2
@@@@ -423,6 +423,11 @@@@ up_apm_device_refresh(UpDevice* device)
 	UpDeviceKind type;
d41 1
a41 1
+
d46 1
a46 1
 
d49 31
@

