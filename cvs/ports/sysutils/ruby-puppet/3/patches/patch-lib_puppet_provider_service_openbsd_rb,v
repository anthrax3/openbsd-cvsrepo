head	1.28;
access;
symbols
	OPENBSD_6_2:1.28.0.8
	OPENBSD_6_2_BASE:1.28
	OPENBSD_6_1:1.28.0.6
	OPENBSD_6_1_BASE:1.28
	OPENBSD_6_0:1.28.0.4
	OPENBSD_6_0_BASE:1.28
	OPENBSD_5_9:1.28.0.2
	OPENBSD_5_9_BASE:1.28
	OPENBSD_5_8:1.27.0.4
	OPENBSD_5_8_BASE:1.27
	OPENBSD_5_7:1.24.0.2
	OPENBSD_5_7_BASE:1.24
	OPENBSD_5_6:1.14.0.2
	OPENBSD_5_6_BASE:1.14
	OPENBSD_5_4:1.2.0.2
	OPENBSD_5_4_BASE:1.2;
locks; strict;
comment	@# @;


1.28
date	2015.08.13.10.46.31;	author jasper;	state Exp;
branches;
next	1.27;
commitid	5QmLLGVdUgOqyzG5;

1.27
date	2015.07.17.18.09.55;	author jasper;	state Exp;
branches;
next	1.26;
commitid	y2QJj0oFjc5TtJQT;

1.26
date	2015.04.07.17.05.57;	author sebastia;	state Exp;
branches;
next	1.25;
commitid	yjZTE26CgYYekgxk;

1.25
date	2015.03.15.10.12.47;	author jasper;	state Exp;
branches;
next	1.24;
commitid	bspmHTmcG1RkA2K7;

1.24
date	2015.01.28.08.43.50;	author jasper;	state Exp;
branches;
next	1.23;
commitid	cRhH1SmY4lJYcCmR;

1.23
date	2015.01.18.10.28.12;	author ajacoutot;	state Exp;
branches;
next	1.22;
commitid	VH6IpZ6eLKwhFsgQ;

1.22
date	2014.12.12.07.52.54;	author jasper;	state Exp;
branches;
next	1.21;
commitid	ZcfX3NlTXc9r32kw;

1.21
date	2014.12.07.13.31.08;	author jasper;	state Exp;
branches;
next	1.20;
commitid	HAHYcPO76n8IWsFi;

1.20
date	2014.11.17.12.44.20;	author jasper;	state Exp;
branches;
next	1.19;
commitid	VUJKK3kUlmnZolv1;

1.19
date	2014.09.07.18.16.42;	author jasper;	state Exp;
branches;
next	1.18;
commitid	STfu20c85fpA9ykS;

1.18
date	2014.08.26.11.42.27;	author jasper;	state Exp;
branches;
next	1.17;
commitid	QxD5g5U4SsAkXGGM;

1.17
date	2014.08.26.09.29.51;	author jasper;	state Exp;
branches;
next	1.16;
commitid	SOIbXPlnpEUkf5cU;

1.16
date	2014.08.25.08.09.57;	author jasper;	state Exp;
branches;
next	1.15;
commitid	urg1DfBKVxTx8oJl;

1.15
date	2014.08.25.08.00.37;	author jasper;	state Exp;
branches;
next	1.14;
commitid	O7rrDc6vTFpea7XF;

1.14
date	2014.07.17.07.03.52;	author jasper;	state Exp;
branches;
next	1.13;
commitid	LOvLcphCFDkQmvJ3;

1.13
date	2014.06.19.12.28.34;	author jasper;	state Exp;
branches;
next	1.12;
commitid	gMfKT5l6Cp7brR2E;

1.12
date	2014.05.15.20.17.16;	author jasper;	state Exp;
branches;
next	1.11;

1.11
date	2014.04.19.12.28.00;	author jasper;	state Exp;
branches;
next	1.10;

1.10
date	2014.04.19.12.13.34;	author jasper;	state Exp;
branches;
next	1.9;

1.9
date	2014.04.19.11.07.35;	author jasper;	state Exp;
branches;
next	1.8;

1.8
date	2014.04.19.10.40.56;	author jasper;	state Exp;
branches;
next	1.7;

1.7
date	2014.04.18.22.07.36;	author jasper;	state Exp;
branches;
next	1.6;

1.6
date	2013.12.20.14.10.41;	author jasper;	state dead;
branches;
next	1.5;

1.5
date	2013.09.17.18.45.31;	author jasper;	state Exp;
branches;
next	1.4;

1.4
date	2013.09.17.09.54.35;	author jasper;	state Exp;
branches;
next	1.3;

1.3
date	2013.09.17.09.00.57;	author jasper;	state Exp;
branches;
next	1.2;

1.2
date	2013.03.08.16.19.15;	author ajacoutot;	state Exp;
branches
	1.2.2.1;
next	1.1;

1.1
date	2013.03.08.16.12.47;	author ajacoutot;	state Exp;
branches;
next	;

1.2.2.1
date	2013.12.15.19.44.32;	author jasper;	state Exp;
branches;
next	;


desc
@@


1.28
log
@in the service provider, stop using 'rcctl getall' in favor of 'ls all' in
combination with 'get $svc flags'. this shaves several seconds off a regular
puppet run, and over 50% on 'puppet resource service'.

as discussed with aja@@
also tested by sebastia@@
@
text
@$OpenBSD: patch-lib_puppet_provider_service_openbsd_rb,v 1.27 2015/07/17 18:09:55 jasper Exp $

* From 93f6754f9c886922d39e938251d4885c1ebb5a29 Mon Sep 17 00:00:00 2001
  From: Jasper Lievisse Adriaanse <jasper@@humppa.nl>
  Date: Tue, 26 Aug 2014 08:52:12 +0200
  Subject: [PATCH] (PUP-3144) Rewrite OpenBSD service provider with rcctl(8)

* From 00322051f892916a58eaf138e2757a4828c7688d Mon Sep 17 00:00:00 2001
  From: Jasper Lievisse Adriaanse <jasper@@humppa.nl>
  Date: Thu, 4 Dec 2014 09:17:14 +0100
  Subject: [PATCH] (PUP-3736) Restart a service when the flags are modified

* From 55ef06ea1baff10ab518c93e3649f5f27c365055 Mon Sep 17 00:00:00 2001
  From: Jasper Lievisse Adriaanse <jasper@@humppa.nl>
  Date: Fri, 23 Jan 2015 08:30:06 +0100
  Subject: [PATCH] (PUP-3939) Sync with upstream OpenBSD rcctl(1) changes

* enhance initial service provisioning with regard to service_flags

* print a warning when rcctl failed to run, instead of having the user guess
  at Ruby errors

--- lib/puppet/provider/service/openbsd.rb.orig	Thu Aug  6 18:17:42 2015
+++ lib/puppet/provider/service/openbsd.rb	Thu Aug 13 10:22:56 2015
@@@@ -2,341 +2,111 @@@@ Puppet::Type.type(:service).provide :openbsd, :parent 
 
   desc "Provider for OpenBSD's rc.d daemon control scripts"
 
+  commands :rcctl => '/usr/sbin/rcctl'
+
   confine :operatingsystem => :openbsd
   defaultfor :operatingsystem => :openbsd
   has_feature :flaggable
 
-  def self.rcconf()        '/etc/rc.conf' end
-  def self.rcconf_local()  '/etc/rc.conf.local' end
-
-  def self.defpath
-    ["/etc/rc.d"]
+  def startcmd
+    if @@resource[:flags] and flags != @@resource[:flags]
+      # Unfortunately, the startcmd gets called, before
+      # the service is enabled (in case its supposed to be enabled).
+      # Setting flags via rcctl is only possible, when the service is enabled
+      # In case the service is not to be enabled, it will be automatically
+      # disabled later in the same puppet run.
+      self.enable
+      self.flags = @@resource[:flags]
+    end
+    [command(:rcctl), '-f', :start, @@resource[:name]]
   end
 
-  def startcmd
-    [self.initscript, "-f", :start]
+  def stopcmd
+    [command(:rcctl), :stop, @@resource[:name]]
   end
 
   def restartcmd
-    (@@resource[:hasrestart] == :true) && [self.initscript, "-f", :restart]
+    (@@resource[:hasrestart] == :true) && [command(:rcctl), '-f', :restart, @@resource[:name]]
   end
 
   def statuscmd
-    [self.initscript, :check]
+    [command(:rcctl), :check, @@resource[:name]]
   end
 
-  # Fetch the state of all service resources
-  def self.prefetch(resources)
-    services = instances
-    resources.keys.each do |name|
-      if provider = services.find { |svc| svc.name == name }
-        resources[name].provider = provider
-      end
-    end
-  end
-
-  # Return the list of rc scripts
   # @@api private
-  def self.rclist
-    unless @@rclist
-      Puppet.debug "Building list of rc scripts"
-      @@rclist = []
-      defpath.each do |p|
-        Dir.glob(p + '/*').each do |item|
-          @@rclist << item if File.executable?(item)
-        end
-      end
-    end
-    @@rclist
-  end
+  # When storing the name, take into account not everything has
+  # '_flags', like 'multicast_host' and 'pf'.
+  def self.instances
+    instances = []
 
-  # Return a hash where the keys are the rc script names as symbols with flags
-  # as values
-  # @@api private
-  def self.rcflags
-    unless @@flag_hash
-      Puppet.debug "Retrieving flags for all discovered services"
+    begin
+      execpipe([command(:rcctl), :ls, :all]) do |all_output|
+        all_output.each_line do |svc|         
+          execpipe([command(:rcctl), :get, svc.chomp, :flags]) do |flags_output|
+            flags_output.each_line do |flags|
+              attributes_hash = {
+                :name      => svc,
+                :flags     => flags,
+                :hasstatus => true,
+                :provider  => :openbsd,
+              }
 
-      Puppet.debug "Reading the contents of the rc conf files"
-
-      if File.exists?(rcconf_local())
-        rcconf_local_contents = File.readlines(rcconf_local())
-      else
-        rcconf_local_contents = []
-      end
-
-      if File.exists?(rcconf())
-        rcconf_contents = File.readlines(rcconf())
-      else
-        rcconf_contents = []
-      end
-
-      @@flag_hash = {}
-      rclist().each do |rcitem|
-
-        rcname = rcitem.split('/').last
-
-        if flagline = rcconf_local_contents.find {|l| l =~ /^#{rcname}_flags/ }
-          flag = parse_rc_line(flagline)
-          @@flag_hash[rcname.to_sym] ||= flag
-        end
-
-        # For the defaults, if the flags are set to 'NO', we skip setting the
-        # flag here, since it will already be disabled, and this makes the
-        # output of `puppet resource service` a bit more correct.
-        if flagline = rcconf_contents.find {|l| l =~ /^#{rcname}_flags/ }
-          flag = parse_rc_line(flagline)
-          unless flag == "NO"
-            @@flag_hash[rcname.to_sym] ||= flag
+              instances << new(attributes_hash)
+            end
           end
         end
-        @@flag_hash[rcname.to_sym] ||= nil
       end
+      instances
+    rescue Puppet::ExecutionFailure
+      Puppet.warning("Failed to execute rcctl")
+      return nil
     end
-    @@flag_hash
   end
 
-  # @@api private
-  def self.parse_rc_line(rc_line)
-    rc_line.sub!(/\s*#(.*)$/,'')
-    regex = /\w+_flags=(.*)/
-    rc_line.match(regex)[1].gsub(/^"/,'').gsub(/"$/,'')
-  end
-
-  # Read the rc.conf* files and determine the value of the flags
-  # @@api private
-  def self.get_flags(rcname)
-    rcflags()
-    @@flag_hash[rcname.to_sym]
-  end
-
-  def self.instances
-    instances = []
-    defpath.each do |path|
-      unless File.directory?(path)
-        Puppet.debug "Service path #{path} does not exist"
-        next
-      end
-
-      rclist().each do |d|
-        instances << new(
-          :name      => File.basename(d),
-          :path      => path,
-          :flags     => get_flags(File.basename(d)),
-          :hasstatus => true
-        )
-      end
-    end
-    instances
-  end
-
-  # @@api private
-  def rcvar_name
-    self.name + '_flags'
-  end
-
-  # @@api private
-  def read_rcconf_local_text()
-    if File.exists?(self.class.rcconf_local())
-      File.read(self.class.rcconf_local())
-    else
-      []
-    end
-  end
-
-  # @@api private
-  def load_rcconf_local_array
-    if File.exists?(self.class.rcconf_local())
-      File.readlines(self.class.rcconf_local()).map {|l|
-        l.chomp!
-      }
-    else
-      []
-    end
-  end
-
-  # @@api private
-  def write_rc_contents(file, text)
-    Puppet::Util.replace_file(file, 0644) do |f|
-      f.write(text)
-    end
-  end
-
-  # @@api private
-  def set_content_flags(content,flags)
-    unless content.is_a? Array
-      debug "content must be an array at flags"
-      return ""
-    else
-      content.reject! {|l| l.nil? }
-    end
-
-    if flags.nil? or flags.size == 0
-      if in_base?
-        append = resource[:name] + '_flags=""'
-      end
-    else
-      append = resource[:name] + '_flags="' + flags + '"'
-    end
-
-    if content.find {|l| l =~ /#{resource[:name]}_flags/ }.nil?
-      content << append
-    else
-      content.map {|l| l.gsub!(/^#{resource[:name]}_flags="(.*)?"(.*)?$/, append) }
-    end
-    content
-  end
-
-  # @@api private
-  def remove_content_flags(content)
-    content.reject {|l| l =~ /#{resource[:name]}_flags/ }
-  end
-
-  # return an array of the currently enabled pkg_scripts
-  # @@api private
-  def pkg_scripts
-    current = load_rcconf_local_array()
-    if scripts = current.find{|l| l =~ /^pkg_scripts/ }
-      if match = scripts.match(/^pkg_scripts="(.*)?"(.*)?$/)
-        match[1].split(' ')
-      else
-        []
-      end
-    else
-      []
-    end
-  end
-
-  # return the array with the current resource added
-  # @@api private
-  def pkg_scripts_append
-    [pkg_scripts(), resource[:name]].flatten.uniq
-  end
-
-  # return the array without the current resource
-  # @@api private
-  def pkg_scripts_remove
-    pkg_scripts().reject {|s| s == resource[:name] }
-  end
-
-  # Modify the content array to contain the requsted pkg_scripts line and retun
-  # the resulting array
-  # @@api private
-  def set_content_scripts(content,scripts)
-    unless content.is_a? Array
-      debug "content must be an array at scripts"
-      return ""
-    else
-      content.reject! {|l| l.nil? }
-    end
-
-    scripts_line = 'pkg_scripts="' + scripts.join(' ') + '"'
-
-    if content.find {|l| l =~ /^pkg_scripts/ }.nil?
-      content << scripts_line
-    else
-      # Replace the found pkg_scripts line with our own
-      content.each_with_index {|l,i|
-        if l =~ /^pkg_scripts/
-          content[i] = scripts_line
-        end
-      }
-    end
-    content
-  end
-
-  # Determine if the rc script is included in base
-  # @@api private
-  def in_base?
-    script = File.readlines(self.class.rcconf).find {|s| s =~ /^#{rcvar_name}/ }
-    !script.nil?
-  end
-
-  # @@api private
-  def default_disabled?
-    line = File.readlines(self.class.rcconf).find {|l| l =~ /#{rcvar_name}/ }
-    self.class.parse_rc_line(line) == 'NO'
-  end
-
   def enabled?
-    if in_base?
-      if (@@property_hash[:flags].nil? or @@property_hash[:flags] == 'NO')
-        :false
-      else
-        :true
-      end
+    output = Puppet::Util::Execution.execute([command(:rcctl), "get", @@resource[:name], "status"],
+                     :failonfail => false, :combine => false, :squelch => false)
+    if output.exitstatus == 0
+      self.debug("Is enabled")
+      return :true
     else
-      if (pkg_scripts().include?(@@property_hash[:name]))
-        :true
-      else
-        :false
-      end
+      self.debug("Is disabled")
+      return :false
     end
   end
 
   def enable
-    self.debug("Enabling #{self.name}")
+    self.debug("Enabling")
+    rcctl(:enable, @@resource[:name])
+    if @@resource[:flags]
+      rcctl(:set, @@resource[:name], :flags, @@resource[:flags])
+    end
   end
 
-  # We should also check for default state
   def disable
-    self.debug("Disabling #{self.name}")
+    self.debug("Disabling")
+    rcctl(:disable, @@resource[:name])
   end
 
-  def flags
-    @@property_hash[:flags]
+  def running?
+    output = execute([command(:rcctl), "check", @@resource[:name]],
+                     :failonfail => false, :combine => false, :squelch => false).chomp
+    return true if output.match(/\(ok\)/)
   end
 
-  def flags=(value)
-    @@property_hash[:flags] = value
+  # Uses the wrapper to prevent failure when the service is not running;
+  # rcctl(8) return non-zero in that case.
+  def flags
+    output = execute([command(:rcctl), "get", @@resource[:name], "flags"],
+                     :failonfail => false, :combine => false, :squelch => false).chomp
+    self.debug("Flags are: \"#{output}\"")
+    output
   end
 
-  def flush
-    debug "Flusing resource for #{self.name}"
-
-    # Here we load the contents of the rc.conf.local file into the contents
-    # variable, modify it if needed, and then compare that to the original.  If
-    # they are different, we write it out.
-
-    original = load_rcconf_local_array()
-    content = original
-
-    debug @@property_hash.inspect
-
-    if resource[:enable] == :true
-      #set_flags(resource[:flags])
-      content = set_content_flags(content, resource[:flags])
-
-      # We need only add append the resource name to the pkg_scripts if the
-      # package is not found in the base system.
-
-      if not in_base?
-        content = set_content_scripts(content,pkg_scripts_append())
-      end
-    elsif resource[:enable] == :false
-
-      # By virtue of being excluded from the base system, all packages are
-      # disabled by default and need not be set in the rc.conf.local at all.
-
-      if not in_base?
-        content = remove_content_flags(content)
-        content = set_content_scripts(content,pkg_scripts_remove())
-      else
-        if default_disabled?
-          content = remove_content_flags(content)
-        else
-          content = set_content_flags(content, "NO")
-        end
-      end
-    end
-
-    # Make sure to append a newline to the end of the file
-    unless content[-1] == ""
-      content << ""
-    end
-    output = content.join("\n")
-
-    # Write the contents only if necessary, and only once
-    write_rc_contents(self.class.rcconf_local(), output)
+  def flags=(value)
+    self.debug("Changing flags from #{flags} to #{value}")
+    rcctl(:set, @@resource[:name], :flags, value)
+    # If the service is already running, force a restart as the flags have been changed.
+    rcctl(:restart, @@resource[:name]) if running?
   end
 end
@


1.27
log
@print a warning when rcctl failed; instead of having the user guess at ruby
error messages
@
text
@d1 1
a1 1
$OpenBSD: patch-lib_puppet_provider_service_openbsd_rb,v 1.26 2015/04/07 17:05:57 sebastia Exp $
d23 3
a25 3
--- lib/puppet/provider/service/openbsd.rb.orig	Thu May 21 14:54:42 2015
+++ lib/puppet/provider/service/openbsd.rb	Fri Jul 17 12:08:57 2015
@@@@ -2,341 +2,109 @@@@ Puppet::Type.type(:service).provide :openbsd, :parent 
d93 5
a97 1
-
d104 12
a115 1
-
d147 4
a150 2
-          end
-        end
d152 6
a157 2
-      end
-    end
d159 2
a160 2
-  end
-
d175 2
a176 4
+  # When storing the name, take into account not everything has
+  # '_flags', like 'multicast_host' and 'pf'.
   def self.instances
     instances = []
d182 1
a182 1
 
d194 1
a194 12
+    begin
+      execpipe([command(:rcctl), :getall]) do |process|
+        process.each_line do |line|
+          match = /^(.*?)(?:_flags)?=(.*)$/.match(line)
+          next if match[1].match(/.*?_timeout$|.*?_user$/)
+          attributes_hash = {
+            :name      => match[1],
+            :flags     => match[2],
+            :hasstatus => true,
+            :provider  => :openbsd,
+          }
 
d239 1
a239 3
+          instances << new(attributes_hash);
+        end
       end
d242 1
a242 5
+      instances
+    rescue Puppet::ExecutionFailure
+      Puppet.warning("Failed to execute rcctl")
+      return nil
     end
d250 2
a251 2
   end
 
@


1.26
log
@Better handling of package flavors, treat flavors as properties instead
of a parameter to the resources. Fixes detection of installed package flavors,
and adds the flavor of a package to "puppet resource package" output.

Better handling of service_flags on service configuration, now allow to configure/set
flags before starting a service the first time. That makes services work that require
parameters to start up, and prevents services from running with wrong parameters.

OK jasper@@
@
text
@d1 1
a1 1
$OpenBSD: patch-lib_puppet_provider_service_openbsd_rb,v 1.25 2015/03/15 10:12:47 jasper Exp $
d20 6
a25 3
--- lib/puppet/provider/service/openbsd.rb.orig	Tue Jan 27 00:46:47 2015
+++ lib/puppet/provider/service/openbsd.rb	Tue Apr  7 11:46:42 2015
@@@@ -2,341 +2,108 @@@@ Puppet::Type.type(:service).provide :openbsd, :parent 
d238 1
@


1.25
log
@sync rcctl patch with what's been committed upstream
@
text
@d1 1
a1 1
$OpenBSD: patch-lib_puppet_provider_service_openbsd_rb,v 1.24 2015/01/28 08:43:50 jasper Exp $
d18 5
a22 3
--- lib/puppet/provider/service/openbsd.rb.orig	Mon Nov  3 23:23:13 2014
+++ lib/puppet/provider/service/openbsd.rb	Wed Jan 28 10:34:13 2015
@@@@ -2,341 +2,98 @@@@ Puppet::Type.type(:service).provide :openbsd, :parent 
d38 9
d176 1
d324 1
a324 1
+    output = execute([command(:rcctl), "get", @@resource[:name], "status"],
@


1.24
log
@use the more standard way to execute something that may fail with execute()
and :failonfail => false

confirmed by sebastia@@ not to cause any regressions
this doesn't fix "puppet resource service" however
@
text
@d1 1
a1 1
$OpenBSD: patch-lib_puppet_provider_service_openbsd_rb,v 1.23 2015/01/18 10:28:12 ajacoutot Exp $
d13 4
a16 1
* https://github.com/puppetlabs/puppet/pull/3510
d312 1
a312 1
+    output = Puppet::Util::Execution.execute([command(:rcctl), "get", @@resource[:name], "status"],
@


1.23
log
@Adapt to new rcctl(8) syntax. The provider still has a few bugs but
Jasper knows about it.

tested by sebastia@@
ok jasper@@
@
text
@d1 1
a1 1
$OpenBSD: patch-lib_puppet_provider_service_openbsd_rb,v 1.22 2014/12/12 07:52:54 jasper Exp $
d13 2
d16 2
a17 2
+++ lib/puppet/provider/service/openbsd.rb	Fri Jan 16 14:56:17 2015
@@@@ -2,341 +2,97 @@@@ Puppet::Type.type(:service).provide :openbsd, :parent 
d309 6
a314 1
-    else
a319 3
+    begin
+      rcctl(:get, @@resource[:name], :status)
+    rescue Puppet::ExecutionFailure
a322 2
+    self.debug("Is enabled")
+    return :true
d346 1
a346 1
+  return true if output.match(/\(ok\)/)
@


1.22
log
@sync with what's been merged upstream
@
text
@d1 1
a1 1
$OpenBSD: patch-lib_puppet_provider_service_openbsd_rb,v 1.21 2014/12/07 13:31:08 jasper Exp $
d14 2
a15 2
+++ lib/puppet/provider/service/openbsd.rb	Fri Dec 12 08:52:09 2014
@@@@ -2,341 +2,99 @@@@ Puppet::Type.type(:service).provide :openbsd, :parent 
d157 1
a157 1
+      execpipe([command(:rcctl), :status]) do |process|
d244 1
a244 7
+  def enabled?
+    output = execute([command(:rcctl), "status", @@resource[:name]],
+                     :failonfail => false, :combine => false, :squelch => false).chomp
+    if output == 'NO'
+      self.debug("Is disabled")
+      return :false
     else
d246 3
a248 5
+      self.debug("Is enabled")
+      return :true
     end
   end
 
d268 1
a268 5
+  def enable
+    self.debug("Enabling")
+    if @@resource[:flags]
+      rcctl(:enable, @@resource[:name], :flags, @@resource[:flags])
     else
d270 1
a270 2
+      rcctl(:enable, @@resource[:name])
     end
d285 2
a286 2
   end
 
d292 2
a293 5
+  def disable
+    self.debug("Disabling")
+    rcctl(:disable, @@resource[:name])
   end
 
d298 3
a300 7
+  def running?
+    output = execute([command(:rcctl), "check", @@resource[:name]],
+                     :failonfail => false, :combine => false, :squelch => false).chomp
+  return true if output.match(/\(ok\)/)
   end
 
-  def enabled?
d313 11
a323 4
-    end
-  end
-
-  def enable
d325 7
a331 2
-  end
-
d333 1
a333 1
-  def disable
d335 14
a348 2
-  end
-
d351 2
a352 3
   def flags
-    @@property_hash[:flags]
+    output = execute([command(:rcctl), "status", @@resource[:name]],
a357 4
   def flags=(value)
-    @@property_hash[:flags] = value
-  end
-
d405 1
d407 1
a407 1
+    rcctl(:enable, @@resource[:name], :flags, value)
@


1.21
log
@sync comments with what has been merged and submitted upstream
@
text
@d1 1
a1 1
$OpenBSD: patch-lib_puppet_provider_service_openbsd_rb,v 1.20 2014/11/17 12:44:20 jasper Exp $
d8 4
a11 1
* Ensure we restart a service after the flags have been changed
d14 2
a15 2
+++ lib/puppet/provider/service/openbsd.rb	Sat Nov 15 20:48:14 2014
@@@@ -2,341 +2,101 @@@@ Puppet::Type.type(:service).provide :openbsd, :parent 
d317 1
a317 1
+  return :true if output.match(/\(ok\)/)
d396 1
a396 6
+    self.debug("Changing flags from #{flags} to #{value}")
+    # If the service is already running, force a restart as the flags have been changed.
+    rcctl(:enable, @@resource[:name], :flags, value)
+    if running?
+      rcctl(:restart, @@resource[:name])
     end
d406 4
@


1.20
log
@ensure we restart a service after the flags have been changed
NB: this does not yet fix the situation where a service is started before
it's flags have been written out to rc.conf.local

tested by sebastia@@
@
text
@d1 1
a1 1
$OpenBSD: patch-lib_puppet_provider_service_openbsd_rb,v 1.19 2014/09/07 18:16:42 jasper Exp $
d3 4
a6 2
* Rewrite using rcctl(8)
  https://github.com/puppetlabs/puppet/pull/3017
@


1.19
log
@- update to puppet-3.7.0
* https://docs.puppetlabs.com/puppet/3.7/reference/release_notes.html

testing/ok sebastia@@
@
text
@d1 1
a1 1
$OpenBSD: patch-lib_puppet_provider_service_openbsd_rb,v 1.18 2014/08/26 11:42:27 jasper Exp $
d6 5
a10 3
--- lib/puppet/provider/service/openbsd.rb.orig	Thu Sep  4 00:22:46 2014
+++ lib/puppet/provider/service/openbsd.rb	Sun Sep  7 20:15:22 2014
@@@@ -2,341 +2,89 @@@@ Puppet::Type.type(:service).provide :openbsd, :parent 
d155 6
d206 1
a206 5
+            instances << new(
+              :name      => match[1],
+              :flags     => match[2],
+              :hasstatus => true,
+            )
d300 5
a304 2
-  end
-
d309 6
a314 2
-  end
-
d336 1
a336 1
   def disable
d338 2
a339 4
+    self.debug("Disabling")
+    rcctl(:disable, @@resource[:name])
   end
 
d346 1
a346 1
+    self.debug("Flags are: #{output}")
d391 6
a396 1
-    end
a405 2
+    self.debug("Changing flags from #{flags} to #{value}")
+    rcctl(:enable, @@resource[:name], :flags, value)
@


1.18
log
@submitted upstream
@
text
@d1 1
a1 1
$OpenBSD: patch-lib_puppet_provider_service_openbsd_rb,v 1.17 2014/08/26 09:29:51 jasper Exp $
d6 3
a8 3
--- lib/puppet/provider/service/openbsd.rb.orig	Mon Jun  9 23:08:19 2014
+++ lib/puppet/provider/service/openbsd.rb	Tue Aug 26 11:29:05 2014
@@@@ -2,340 +2,89 @@@@ Puppet::Type.type(:service).provide :openbsd, :parent 
d195 10
a204 2
-    if flags.nil?
-      append = resource[:name] + '_flags=""'
d207 4
a210 1
-    end
d218 2
a219 2
-  end
-
d234 8
a241 8
+            instances << new(
+              :name      => match[1],
+              :flags     => match[2],
+              :hasstatus => true,
+            )
+        end
       end
-    else
d243 2
a244 3
+      instances
+    rescue Puppet::ExecutionFailure
+      return nil
d251 1
a251 1
-    [pkg_scripts(), resource[:name]].flatten.sort.uniq
d267 4
a270 6
+  def enabled?
+    output = execute([command(:rcctl), "status", @@resource[:name]],
+                     :failonfail => false, :combine => false, :squelch => false).chomp
+    if output == 'NO'
+      self.debug("Is disabled")
+      return :false
d273 1
a273 2
+      self.debug("Is enabled")
+      return :true
d291 1
a291 2
-  # Determine if the rc script is included in base, or if it exists as a result
-  # of a package installation.
d294 2
a295 2
-    system("/usr/sbin/pkg_info -qE /etc/rc.d/#{self.name}> /dev/null")
-    $?.exitstatus == 1
d311 1
a311 5
+  def enable
+    self.debug("Enabling")
+    if @@resource[:flags]
+      rcctl(:enable, @@resource[:name], :flags, @@resource[:flags])
     else
d317 3
a319 4
+      rcctl(:enable, @@resource[:name])
     end
   end
 
@


1.17
log
@only do a restart if the service supports it; resort to stop/start otherwise
@
text
@d1 1
a1 1
$OpenBSD: patch-lib_puppet_provider_service_openbsd_rb,v 1.16 2014/08/25 08:09:57 jasper Exp $
d4 1
@


1.16
log
@tyop
@
text
@d1 1
a1 1
$OpenBSD: patch-lib_puppet_provider_service_openbsd_rb,v 1.15 2014/08/25 08:00:37 jasper Exp $
d6 1
a6 1
+++ lib/puppet/provider/service/openbsd.rb	Mon Aug 25 09:38:37 2014
d34 1
a34 1
+    [command(:rcctl), '-f', :restart, @@resource[:name]]
@


1.15
log
@rewrite the service provider to use rcctl, shrinking the code by about 75% percent..
..while retaining some of the puppet-intrinsic quirks where a service won't
be restarted if the flags change. that's still under investigation.

this does however now allow for valid resources that would previously fail:
service { 'multicast_host': enable => true}
or
service { 'ipsec': enable => true}
@
text
@d1 1
a1 1
$OpenBSD: patch-lib_puppet_provider_service_openbsd_rb,v 1.14 2014/07/17 07:03:52 jasper Exp $
d34 1
a34 1
+    [command(:rcctl), 'f', :restart, @@resource[:name]]
@


1.14
log
@sync with rc.conf.local format changes
@
text
@d1 1
a1 1
$OpenBSD: patch-lib_puppet_provider_service_openbsd_rb,v 1.13 2014/06/19 12:28:34 jasper Exp $
d3 1
a3 10
* https://github.com/puppetlabs/puppet/pull/2557
- Do not unconditionally alphabetically sort the list of pkg_scripts
  as order matters. Explicit ordering will need to be forced through
  resources dependencies.
- Do not add _flags="" for pkg_scripts if no :flags were set, as it
  may override the default flags from inside the script.
- Use a faster way of determining if something is in base, instead of checking
  something is from packages with pkg_info.

* Adjust to new rc.conf.local layout
d6 97
a102 5
+++ lib/puppet/provider/service/openbsd.rb	Tue Jul 15 14:37:43 2014
@@@@ -86,7 +86,7 @@@@ Puppet::Type.type(:service).provide :openbsd, :parent 
         # output of `puppet resource service` a bit more correct.
         if flagline = rcconf_contents.find {|l| l =~ /^#{rcname}_flags/ }
           flag = parse_rc_line(flagline)
d104 48
a151 7
+          unless flag == 'NO'
             @@flag_hash[rcname.to_sym] ||= flag
           end
         end
@@@@ -171,16 +171,18 @@@@ Puppet::Type.type(:service).provide :openbsd, :parent 
       content.reject! {|l| l.nil? }
     end
d153 41
d196 1
a196 5
+    if flags.nil? or flags.size == 0
+      if in_base?
+        append = resource[:name] + '_flags='
+      end
     else
d198 5
a202 6
+      append = resource[:name] + '_flags=' + flags + ''
     end
 
     if content.find {|l| l =~ /#{resource[:name]}_flags/ }.nil?
       content << append
     else
d204 30
a233 1
+      content.map {|l| l.gsub!(/^#{resource[:name]}_flags=(.*)?(.*)?$/, append) }
a234 1
     content
d236 4
a239 13
@@@@ -195,7 +197,7 @@@@ Puppet::Type.type(:service).provide :openbsd, :parent 
   def pkg_scripts
     current = load_rcconf_local_array()
     if scripts = current.find{|l| l =~ /^pkg_scripts/ }
-      if match = scripts.match(/^pkg_scripts="(.*)?"(.*)?$/)
+      if match = scripts.match(/^pkg_scripts=(.*)?(.*)?$/)
         match[1].split(' ')
       else
         []
@@@@ -208,7 +210,7 @@@@ Puppet::Type.type(:service).provide :openbsd, :parent 
   # return the array with the current resource added
   # @@api private
   def pkg_scripts_append
d241 25
a265 6
+    [pkg_scripts(), resource[:name]].flatten.uniq
   end
 
   # return the array without the current resource
@@@@ -228,7 +230,7 @@@@ Puppet::Type.type(:service).provide :openbsd, :parent 
       content.reject! {|l| l.nil? }
d267 1
a267 1
 
d269 12
a280 6
+    scripts_line = 'pkg_scripts=' + scripts.join(' ') + ''
 
     if content.find {|l| l =~ /^pkg_scripts/ }.nil?
       content << scripts_line
@@@@ -243,12 +245,11 @@@@ Puppet::Type.type(:service).provide :openbsd, :parent 
     content
d285 2
a286 3
+  # Determine if the rc script is included in base
   # @@api private
   def in_base?
d289 38
a326 2
+    script = File.readlines(self.class.rcconf).find {|s| s =~ /^#{rcvar_name}/ }
+    !script.nil?
d329 65
a393 1
   # @@api private
@


1.13
log
@sync with upstream pull request
@
text
@d1 1
a1 1
$OpenBSD: patch-lib_puppet_provider_service_openbsd_rb,v 1.12 2014/05/15 20:17:16 jasper Exp $
d12 2
d15 11
a25 2
+++ lib/puppet/provider/service/openbsd.rb	Fri Jun 20 00:25:27 2014
@@@@ -171,8 +171,10 @@@@ Puppet::Type.type(:service).provide :openbsd, :parent 
d33 1
a33 1
+        append = resource[:name] + '_flags=""'
d36 2
a37 1
       append = resource[:name] + '_flags="' + flags + '"'
d39 18
d66 9
@


1.12
log
@* update to puppet 3.6.0
- release notes at http://docs.puppetlabs.com/puppet/3.6/reference/release_notes.html
- please note that this release deprecates the use of "config file
  environments". if you haven't already done so, please switch to "directory
  environments" as explained here: http://docs.puppetlabs.com/puppet/latest/reference/environments.html
@
text
@d1 1
a1 1
$OpenBSD: patch-lib_puppet_provider_service_openbsd_rb,v 1.11 2014/04/19 12:28:00 jasper Exp $
d12 4
a15 3
--- lib/puppet/provider/service/openbsd.rb.orig	Thu May 15 21:04:49 2014
+++ lib/puppet/provider/service/openbsd.rb	Thu May 15 21:04:52 2014
@@@@ -172,7 +172,9 @@@@ Puppet::Type.type(:service).provide :openbsd, :parent 
d18 1
a18 1
     if flags.nil?
d20 1
d22 2
a23 2
+	append = resource[:name] + '_flags=""'
+     end
@


1.11
log
@submitted upstream
@
text
@d1 1
a1 7
$OpenBSD: patch-lib_puppet_provider_service_openbsd_rb,v 1.10 2014/04/19 12:13:34 jasper Exp $

From a25e2cc2ef72d2549c84a91d75c587ecbfabfe4f Mon Sep 17 00:00:00 2001
From: Zach Leslie <zach@@puppetlabs.com>
Date: Tue, 14 Jan 2014 11:19:53 -0800
Subject: [PATCH] (PUP-2143) Implement :enableable for OpenBSD service provider

d12 4
a15 3
--- lib/puppet/provider/service/openbsd.rb.orig	Wed Apr 16 01:06:55 2014
+++ lib/puppet/provider/service/openbsd.rb	Sat Apr 19 13:58:04 2014
@@@@ -4,7 +4,11 @@@@ Puppet::Type.type(:service).provide :openbsd, :parent 
d17 15
a31 3
   confine :operatingsystem => :openbsd
   defaultfor :operatingsystem => :openbsd
+  has_feature :flaggable
d33 3
a35 5
+  def self.rcconf()        '/etc/rc.conf' end
+  def self.rcconf_local()  '/etc/rc.conf.local' end
+
   def self.defpath
     ["/etc/rc.d"]
a36 1
@@@@ -19,5 +23,321 @@@@ Puppet::Type.type(:service).provide :openbsd, :parent 
d38 7
a44 228
   def statuscmd
     [self.initscript, :check]
+  end
+
+  # Fetch the state of all service resources
+  def self.prefetch(resources)
+    services = instances
+    resources.keys.each do |name|
+      if provider = services.find { |svc| svc.name == name }
+        resources[name].provider = provider
+      end
+    end
+  end
+
+  # Return the list of rc scripts
+  # @@api private
+  def self.rclist
+    unless @@rclist
+      Puppet.debug "Building list of rc scripts"
+      @@rclist = []
+      defpath.each do |p|
+        Dir.glob(p + '/*').each do |item|
+          @@rclist << item if File.executable?(item)
+        end
+      end
+    end
+    @@rclist
+  end
+
+  # Return a hash where the keys are the rc script names as symbols with flags
+  # as values
+  # @@api private
+  def self.rcflags
+    unless @@flag_hash
+      Puppet.debug "Retrieving flags for all discovered services"
+
+      Puppet.debug "Reading the contents of the rc conf files"
+
+      if File.exists?(rcconf_local())
+        rcconf_local_contents = File.readlines(rcconf_local())
+      else
+        rcconf_local_contents = []
+      end
+
+      if File.exists?(rcconf())
+        rcconf_contents = File.readlines(rcconf())
+      else
+        rcconf_contents = []
+      end
+
+      @@flag_hash = {}
+      rclist().each do |rcitem|
+
+        rcname = rcitem.split('/').last
+
+        if flagline = rcconf_local_contents.find {|l| l =~ /^#{rcname}_flags/ }
+          flag = parse_rc_line(flagline)
+          @@flag_hash[rcname.to_sym] ||= flag
+        end
+
+        # For the defaults, if the flags are set to 'NO', we skip setting the
+        # flag here, since it will already be disabled, and this makes the
+        # output of `puppet resource service` a bit more correct.
+        if flagline = rcconf_contents.find {|l| l =~ /^#{rcname}_flags/ }
+          flag = parse_rc_line(flagline)
+          unless flag == "NO"
+            @@flag_hash[rcname.to_sym] ||= flag
+          end
+        end
+        @@flag_hash[rcname.to_sym] ||= nil
+      end
+    end
+    @@flag_hash
+  end
+
+  # @@api private
+  def self.parse_rc_line(rc_line)
+    rc_line.sub!(/\s*#(.*)$/,'')
+    regex = /\w+_flags=(.*)/
+    rc_line.match(regex)[1].gsub(/^"/,'').gsub(/"$/,'')
+  end
+
+  # Read the rc.conf* files and determine the value of the flags
+  # @@api private
+  def self.get_flags(rcname)
+    rcflags()
+    @@flag_hash[rcname.to_sym]
+  end
+
+  def self.instances
+    instances = []
+    defpath.each do |path|
+      unless File.directory?(path)
+        Puppet.debug "Service path #{path} does not exist"
+        next
+      end
+
+      rclist().each do |d|
+        instances << new(
+          :name      => File.basename(d),
+          :path      => path,
+          :flags     => get_flags(File.basename(d)),
+          :hasstatus => true
+        )
+      end
+    end
+    instances
+  end
+
+  # @@api private
+  def rcvar_name
+    self.name + '_flags'
+  end
+
+  # @@api private
+  def read_rcconf_local_text()
+    if File.exists?(self.class.rcconf_local())
+      File.read(self.class.rcconf_local())
+    else
+      []
+    end
+  end
+
+  # @@api private
+  def load_rcconf_local_array
+    if File.exists?(self.class.rcconf_local())
+      File.readlines(self.class.rcconf_local()).map {|l|
+        l.chomp!
+      }
+    else
+      []
+    end
+  end
+
+  # @@api private
+  def write_rc_contents(file, text)
+    Puppet::Util.replace_file(file, 0644) do |f|
+      f.write(text)
+    end
+  end
+
+  # @@api private
+  def set_content_flags(content,flags)
+    unless content.is_a? Array
+      debug "content must be an array at flags"
+      return ""
+    else
+      content.reject! {|l| l.nil? }
+    end
+
+    if flags.nil?
+      if in_base?
+        append = resource[:name] + '_flags=""'
+      end
+    else
+      append = resource[:name] + '_flags="' + flags + '"'
+    end
+
+    if content.find {|l| l =~ /#{resource[:name]}_flags/ }.nil?
+      content << append
+    else
+      content.map {|l| l.gsub!(/^#{resource[:name]}_flags="(.*)?"(.*)?$/, append) }
+    end
+    content
+  end
+
+  # @@api private
+  def remove_content_flags(content)
+    content.reject {|l| l =~ /#{resource[:name]}_flags/ }
+  end
+
+  # return an array of the currently enabled pkg_scripts
+  # @@api private
+  def pkg_scripts
+    current = load_rcconf_local_array()
+    if scripts = current.find{|l| l =~ /^pkg_scripts/ }
+      if match = scripts.match(/^pkg_scripts="(.*)?"(.*)?$/)
+        match[1].split(' ')
+      else
+        []
+      end
+    else
+      []
+    end
+  end
+
+  # return the array with the current resource added
+  # @@api private
+  def pkg_scripts_append
+    [pkg_scripts(), resource[:name]].flatten.uniq
+  end
+
+  # return the array without the current resource
+  # @@api private
+  def pkg_scripts_remove
+    pkg_scripts().reject {|s| s == resource[:name] }
+  end
+
+  # Modify the content array to contain the requsted pkg_scripts line and retun
+  # the resulting array
+  # @@api private
+  def set_content_scripts(content,scripts)
+    unless content.is_a? Array
+      debug "content must be an array at scripts"
+      return ""
+    else
+      content.reject! {|l| l.nil? }
+    end
+
+    scripts_line = 'pkg_scripts="' + scripts.join(' ') + '"'
+
+    if content.find {|l| l =~ /^pkg_scripts/ }.nil?
+      content << scripts_line
+    else
+      # Replace the found pkg_scripts line with our own
+      content.each_with_index {|l,i|
+        if l =~ /^pkg_scripts/
+          content[i] = scripts_line
+        end
+      }
+    end
+    content
+  end
+
+  # Determine if the rc script is included in base, or if it exists as a result
+  # of a package installation.
+  # @@api private
+  def in_base?
a46 88
+  end
+
+  # @@api private
+  def default_disabled?
+    line = File.readlines(self.class.rcconf).find {|l| l =~ /#{rcvar_name}/ }
+    self.class.parse_rc_line(line) == 'NO'
+  end
+
+  def enabled?
+    if in_base?
+      if (@@property_hash[:flags].nil? or @@property_hash[:flags] == 'NO')
+        :false
+      else
+        :true
+      end
+    else
+      if (pkg_scripts().include?(@@property_hash[:name]))
+        :true
+      else
+        :false
+      end
+    end
+  end
+
+  def enable
+    self.debug("Enabling #{self.name}")
+  end
+
+  # We should also check for default state
+  def disable
+    self.debug("Disabling #{self.name}")
+  end
+
+  def flags
+    @@property_hash[:flags]
+  end
+
+  def flags=(value)
+    @@property_hash[:flags] = value
+  end
+
+  def flush
+    debug "Flusing resource for #{self.name}"
+
+    # Here we load the contents of the rc.conf.local file into the contents
+    # variable, modify it if needed, and then compare that to the original.  If
+    # they are different, we write it out.
+
+    original = load_rcconf_local_array()
+    content = original
+
+    debug @@property_hash.inspect
+
+    if resource[:enable] == :true
+      #set_flags(resource[:flags])
+      content = set_content_flags(content, resource[:flags])
+
+      # We need only add append the resource name to the pkg_scripts if the
+      # package is not found in the base system.
+
+      if not in_base?
+        content = set_content_scripts(content,pkg_scripts_append())
+      end
+    elsif resource[:enable] == :false
+
+      # By virtue of being excluded from the base system, all packages are
+      # disabled by default and need not be set in the rc.conf.local at all.
+
+      if not in_base?
+        content = remove_content_flags(content)
+        content = set_content_scripts(content,pkg_scripts_remove())
+      else
+        if default_disabled?
+          content = remove_content_flags(content)
+        else
+          content = set_content_flags(content, "NO")
+        end
+      end
+    end
+
+    # Make sure to append a newline to the end of the file
+    unless content[-1] == ""
+      content << ""
+    end
+    output = content.join("\n")
+
+    # Write the contents only if necessary, and only once
+    write_rc_contents(self.class.rcconf_local(), output)
d48 2
a49 1
 end
@


1.10
log
@Use a faster way of determining if something is in base, depending on /etc/rc.conf

as discussed with aja@@ and rpe@@
@
text
@d1 1
a1 1
$OpenBSD: patch-lib_puppet_provider_service_openbsd_rb,v 1.9 2014/04/19 11:07:35 jasper Exp $
d8 2
a12 1

a14 1

@


1.9
log
@Do not add _flags="" for pkg_scripts if no :flags were set, as it
may override the default flags from inside the script.
@
text
@d1 1
a1 1
$OpenBSD: patch-lib_puppet_provider_service_openbsd_rb,v 1.8 2014/04/19 10:40:56 jasper Exp $
d15 3
d19 1
a19 1
+++ lib/puppet/provider/service/openbsd.rb	Sat Apr 19 12:51:45 2014
d262 2
a263 2
+    system("/usr/sbin/pkg_info -qE /etc/rc.d/#{self.name}> /dev/null")
+    $?.exitstatus == 1
@


1.8
log
@Do not unconditoinally alphabetically sort the list of pkg_scripts
as order matters. Explicit ordering will need to be forced through
resources dependencies.
@
text
@d1 1
a1 1
$OpenBSD: patch-lib_puppet_provider_service_openbsd_rb,v 1.7 2014/04/18 22:07:36 jasper Exp $
d8 1
a8 1
- Do not unconditoinally alphabetically sort the list of pkg_scripts
d12 3
d16 1
a16 1
+++ lib/puppet/provider/service/openbsd.rb	Sat Apr 19 12:38:51 2014
d29 1
a29 1
@@@@ -19,5 +23,319 @@@@ Puppet::Type.type(:service).provide :openbsd, :parent 
d182 3
a184 1
+      append = resource[:name] + '_flags=""'
@


1.7
log
@merge a patch from upstream which overhauls the service provider for openbsd

this allows for proper :ensure (enable/disable) and setting flags for services.
@
text
@d1 1
a1 1
$OpenBSD$
d8 4
d13 1
a13 1
+++ lib/puppet/provider/service/openbsd.rb	Sat Apr 19 00:00:54 2014
d215 1
a215 1
+    [pkg_scripts(), resource[:name]].flatten.sort.uniq
@


1.6
log
@- update to puppet-3.4.0
* full changelog http://docs.puppetlabs.com/puppet/3/reference/release_notes.html#puppet-340
@
text
@d1 1
a1 1
$OpenBSD: patch-lib_puppet_provider_service_openbsd_rb,v 1.5 2013/09/17 18:45:31 jasper Exp $
d3 4
a6 4
From 1de80e849cd5871aa6ce2828dab11dda1b1575a1 Mon Sep 17 00:00:00 2001
From: Jasper Lievisse Adriaanse <jasper@@humppa.nl>
Date: Tue, 17 Sep 2013 10:57:45 +0200
Subject: [PATCH] (#22579) Add service provider for OpenBSD's rc.d
d8 10
a17 4
--- lib/puppet/provider/service/openbsd.rb.orig	Tue Sep 17 20:44:10 2013
+++ lib/puppet/provider/service/openbsd.rb	Tue Sep 17 20:44:36 2013
@@@@ -0,0 +1,23 @@@@
+Puppet::Type.type(:service).provide :openbsd, :parent => :init do
d19 48
a66 1
+  desc "Provider for OpenBSD's rc.d daemon control scripts"
d68 5
a72 2
+  confine :operatingsystem => :openbsd
+  defaultfor :operatingsystem => :openbsd
d74 37
a110 2
+  def self.defpath
+    ["/etc/rc.d"]
d113 18
a130 2
+  def startcmd
+    [self.initscript, "-f", :start]
d133 3
a135 2
+  def restartcmd
+    (@@resource[:hasrestart] == :true) && [self.initscript, "-f", :restart]
d138 7
a144 2
+  def statuscmd
+    [self.initscript, :check]
d146 196
a341 1
+end
@


1.5
log
@sync with upstream/master now that it's been merged
@
text
@d1 1
a1 1
$OpenBSD: patch-lib_puppet_provider_service_openbsd_rb,v 1.4 2013/09/17 09:54:35 jasper Exp $
@


1.4
log
@sync with what's been submitted upstream, no pkg change.
@
text
@d1 1
a1 1
$OpenBSD: patch-lib_puppet_provider_service_openbsd_rb,v 1.3 2013/09/17 09:00:57 jasper Exp $
d8 3
a10 3
--- lib/puppet/provider/service/openbsd.rb.orig	Tue Sep 17 10:58:36 2013
+++ lib/puppet/provider/service/openbsd.rb	Tue Sep 17 11:00:26 2013
@@@@ -0,0 +1,38 @@@@
d18 2
a19 2
+  class << self
+    attr_accessor :defpath
a21 2
+  @@defpath = "/etc/rc.d"
+
a32 13
+
+  # A simple wrapper so execution failures are a bit more informative.
+  # If an exception occurs, we show a warning instead of an error.
+  def texecute(type, command, fof = true)
+    begin
+      # #565: Services generally produce no output, so squelch them.
+      execute(command, :failonfail => fof, :squelch => true)
+    rescue Puppet::ExecutionFailure => detail
+      @@resource.warning "Could not #{type} #{@@resource.ref}: #{detail}"
+    end
+    nil
+  end
+
@


1.3
log
@add missing spec tests for the openbsd service provider
@
text
@d1 7
a7 1
$OpenBSD: patch-lib_puppet_provider_service_openbsd_rb,v 1.2 2013/03/08 16:19:15 ajacoutot Exp $
@


1.2
log
@Start services with '-f' since they may not be enabled in rc.conf.local(5).
Implement a restart command for the service provider and use '-f' as well.
No need to specify a 'stop' common, our rc.d(8) is generic enough.

ok robert@@ (maintainer)
@
text
@d1 3
a3 3
$OpenBSD: patch-lib_puppet_provider_service_openbsd_rb,v 1.1 2013/03/08 16:12:47 ajacoutot Exp $
--- lib/puppet/provider/service/openbsd.rb.orig	Fri Mar  8 17:18:07 2013
+++ lib/puppet/provider/service/openbsd.rb	Fri Mar  8 17:18:21 2013
d7 1
a7 1
+  desc "Provider for OpenBSD."
d9 2
a10 2
+  confine :operatingsystem => [:openbsd]
+  defaultfor :operatingsystem => [:openbsd]
@


1.2.2.1
log
@update puppet to 3.3.2

this allows OpenBSD 5.4 agents to work correctly again with a puppet master
unning -current. puppet 3.3 has a new reporting format as well as support
for ensure => latest for packages. now one can use the same manifest for
5.4 and -current again.

note: libshadow was not imported into 5.4 so managing user passwords won't
work on 5.4 still.

discussed with sthen@@
@
text
@d1 4
a4 10
$OpenBSD: patch-lib_puppet_provider_service_openbsd_rb,v 1.5 2013/09/17 18:45:31 jasper Exp $

From 1de80e849cd5871aa6ce2828dab11dda1b1575a1 Mon Sep 17 00:00:00 2001
From: Jasper Lievisse Adriaanse <jasper@@humppa.nl>
Date: Tue, 17 Sep 2013 10:57:45 +0200
Subject: [PATCH] (#22579) Add service provider for OpenBSD's rc.d

--- lib/puppet/provider/service/openbsd.rb.orig	Tue Sep 17 20:44:10 2013
+++ lib/puppet/provider/service/openbsd.rb	Tue Sep 17 20:44:36 2013
@@@@ -0,0 +1,23 @@@@
d7 1
a7 1
+  desc "Provider for OpenBSD's rc.d daemon control scripts"
d9 2
a10 2
+  confine :operatingsystem => :openbsd
+  defaultfor :operatingsystem => :openbsd
d12 2
a13 2
+  def self.defpath
+    ["/etc/rc.d"]
d16 2
d29 13
@


1.1
log
@Split ruby-puppet:
* move the current port to ruby-puppet/3
* add a new puppet-2.7.X port under ruby-puppet/2

This allows us to ship with 2 different versions of Puppet. Since the
Enterprise version is still running 2.7, we want to have a matching
client because running puppet3 against a puppet2 server is highly
discouraged and will mostly no work correctly.

ok jasper@@, robert@@ (maintainer)
@
text
@d1 3
a3 3
$OpenBSD: patch-lib_puppet_provider_service_openbsd_rb,v 1.1 2012/09/19 09:56:01 robert Exp $
--- lib/puppet/provider/service/openbsd.rb.orig	Wed Sep 19 11:53:39 2012
+++ lib/puppet/provider/service/openbsd.rb	Wed Sep 19 11:53:35 2012
d19 1
a19 1
+    [self.initscript, :start]
d22 2
a23 2
+  def stopcmd
+    [self.initscript, :stop]
@

