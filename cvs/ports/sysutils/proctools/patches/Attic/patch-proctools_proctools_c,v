head	1.2;
access;
symbols
	OPENBSD_4_1:1.1.1.1.0.18
	OPENBSD_4_1_BASE:1.1.1.1
	OPENBSD_4_0:1.1.1.1.0.16
	OPENBSD_4_0_BASE:1.1.1.1
	OPENBSD_3_9:1.1.1.1.0.14
	OPENBSD_3_9_BASE:1.1.1.1
	OPENBSD_3_8:1.1.1.1.0.12
	OPENBSD_3_8_BASE:1.1.1.1
	OPENBSD_3_7:1.1.1.1.0.10
	OPENBSD_3_7_BASE:1.1.1.1
	OPENBSD_3_6:1.1.1.1.0.8
	OPENBSD_3_6_BASE:1.1.1.1
	OPENBSD_3_5:1.1.1.1.0.6
	OPENBSD_3_5_BASE:1.1.1.1
	OPENBSD_3_4:1.1.1.1.0.4
	OPENBSD_3_4_BASE:1.1.1.1
	OPENBSD_3_3:1.1.1.1.0.2
	OPENBSD_3_3_BASE:1.1.1.1
	lebel_2003-Jan-06:1.1.1.1
	lebel:1.1.1;
locks; strict;
comment	@# @;


1.2
date	2007.03.22.21.43.19;	author aanriot;	state dead;
branches;
next	1.1;

1.1
date	2003.01.06.18.03.44;	author lebel;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2003.01.06.18.03.44;	author lebel;	state Exp;
branches;
next	;


desc
@@


1.2
log
@remove proctools, which was tagged "COMES_WITH= 3.9".

ok sturm@@
@
text
@$OpenBSD: patch-proctools_proctools_c,v 1.1 2003/01/06 18:03:44 lebel Exp $
Support the -V flag.
Never match the current process.
--- proctools/proctools.c.orig	Mon May 21 18:23:55 2001
+++ proctools/proctools.c	Mon Jan  6 12:18:57 2003
@@@@ -316,6 +316,7 @@@@ matchTermList(termlist, term)
 /*
  * Pushes a new process and its executable name into a linked
  * list of processes, creating the linked list if necessary.
+ * Ignores the current process.
  */
 int
 pushProcList(proclist, pid, name)
@@@@ -325,6 +326,8 @@@@ pushProcList(proclist, pid, name)
 {
 	struct proclist *temppl;
 
+	if ( pid == getpid() ) return (0);
+
 	if ((temppl = calloc(1, sizeof(struct proclist))) == NULL)
 		err(EX_OSERR, NULL);
 	if ((temppl->name = strdup(name)) == NULL)
@@@@ -339,10 +342,10 @@@@ pushProcList(proclist, pid, name)
 /*
  * Parses the kernel structures containing process information searching
  * for processes that match the information stored in the linked lists
- * and flags supplied.
+ * and flags supplied. Will not match the current process.
  */
 int
-getProcList(proclist, euidlist, uidlist, gidlist, ppidlist, pgrouplist, termlist, fullmatch, lastonly, invert, exact, pattern)
+getProcList(proclist, euidlist, uidlist, gidlist, ppidlist, pgrouplist, termlist, fullmatch, lastonly, invert, partialInvert, exact, pattern)
 	struct proclist **proclist;
 	struct uidlist *euidlist;
 	struct uidlist *uidlist;
@@@@ -353,6 +356,7 @@@@ getProcList(proclist, euidlist, uidlist,
 	int fullmatch;
 	int lastonly;
 	int invert;
+	int partialInvert;
 	int exact;
 	char *pattern;
 {
@@@@ -372,13 +376,10 @@@@ getProcList(proclist, euidlist, uidlist,
 	char **kvm_argv;
 	char *name;
 
-	kd = kvm_openfiles(NULL, NULL, NULL, O_RDONLY, errbuf);
+	kd = kvm_openfiles(NULL, NULL, NULL, KVM_NO_FILES, errbuf);
 	if (kd == 0)
 		errx(EX_UNAVAILABLE, "%s", errbuf);
 
-	setegid(getgid());
-	setgid(getgid());
-
 	if ((kp = kvm_getprocs(kd, KERN_PROC_ALL, 0, &nentries)) == 0)
 		errx(EX_UNAVAILABLE, "%s", kvm_geterr(kd));
 
@@@@ -398,7 +399,7 @@@@ getProcList(proclist, euidlist, uidlist,
 		    matchUidList(euidlist, kpi.kp_eproc.e_pcred.p_svuid) &&
 		    matchUidList(uidlist, kpi.kp_eproc.e_pcred.p_ruid));
 		extmatch = pgrouplist || gidlist || ppidlist || termlist || euidlist || uidlist;
-		if (match && !invert) {
+		if (match && !invert && !partialInvert) {
 			if (fullmatch) {
 				kvm_argv = kvm_getargv(kd, kp, 0);
 				if ((name = strdup(kvm_argv[0])) == NULL)
@@@@ -456,7 +457,7 @@@@ getProcList(proclist, euidlist, uidlist,
 			} else
 				pushProcList(proclist, kpi.kp_proc.p_pid, kpi.kp_proc.p_comm);
 			free(name);
-		} else if ((!match && invert) || (match && !extmatch && invert)) {
+		} else if ((!match && (invert || partialInvert)) || (match && !extmatch && (invert || partialInvert))) {
 			if (fullmatch) {
 				kvm_argv = kvm_getargv(kd, kp, 0);
 				if ((name = strdup(kvm_argv[0])) == NULL)
@@@@ -483,12 +484,16 @@@@ getProcList(proclist, euidlist, uidlist,
 					latest.pid = kpi.kp_proc.p_pid;
 				}
 			} else if (pattern != NULL) {
+				int state;
 				if (exact) {
-					if (strcmp(name, pattern) != 0)
+					state = strcmp(name, pattern) == 0;
+					if (partialInvert ? state : !state)
 						pushProcList(proclist, kpi.kp_proc.p_pid, kpi.kp_proc.p_comm);
-				} else
-					if (regexec(&regex, name, 0, NULL, NULL) == REG_NOMATCH)
+				} else {
+					state = regexec(&regex, name, 0, NULL, NULL) != REG_NOMATCH;
+					if (partialInvert ? state : !state)
 						pushProcList(proclist, kpi.kp_proc.p_pid, kpi.kp_proc.p_comm);
+				}
 			} else
 				pushProcList(proclist, kpi.kp_proc.p_pid, kpi.kp_proc.p_comm);
 			free(name);
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
$OpenBSD$
@


1.1.1.1
log
@initial import of sysutils/proctools 0.3:
--
Submitted by James Devenish (j-devenish@@users.sourceforge.net)
Modified by danh@@

Proctools  provides  the  pgrep and pkill commands which can
scan for and send signals to processes that are  matched  by
command-line options.

The  pgrep  utility displays process IDs for those processes
that match the requirements specified on the command line.

The pkill utility sends a signal to process  IDs  for  those
processes  that match the requirements specified on the com-
mand line.

WWW: http://sourceforge.net/projects/proctools

@
text
@@
