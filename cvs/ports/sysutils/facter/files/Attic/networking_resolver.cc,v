head	1.3;
access;
symbols
	OPENBSD_5_9:1.2.0.2
	OPENBSD_5_9_BASE:1.2
	OPENBSD_5_8:1.2.0.4
	OPENBSD_5_8_BASE:1.2;
locks; strict;
comment	@// @;


1.3
date	2016.05.30.15.07.58;	author jasper;	state dead;
branches;
next	1.2;
commitid	mTPWHYxdzRBIjhfj;

1.2
date	2015.07.14.21.59.09;	author jasper;	state Exp;
branches;
next	1.1;
commitid	uvFoXrOG1zGPyqyr;

1.1
date	2015.07.14.21.45.15;	author jasper;	state Exp;
branches;
next	;
commitid	RWYrmy9XI3WnDLL5;


desc
@@


1.3
log
@long overdue update to facter-3.1.7; all our patches have been merged upstream
however some new patches are needed to deal with the split-off leatherman lib.
@
text
@#include <internal/facts/openbsd/networking_resolver.hpp>
#include <internal/util/bsd/scoped_ifaddrs.hpp>
#include <facter/execution/execution.hpp>
#include <facter/util/file.hpp>
#include <facter/util/directory.hpp>
#include <leatherman/logging/logging.hpp>
#include <boost/algorithm/string.hpp>
#include <sys/sockio.h>
#include <sys/ioctl.h>
#include <net/if.h>
#include <net/if_dl.h>
#include <netinet/in.h>

using namespace std;
using namespace facter::util;
using namespace facter::util::bsd;
using namespace facter::execution;

namespace facter { namespace facts { namespace openbsd {

    bool networking_resolver::is_link_address(sockaddr const* addr) const
    {
        return addr && addr->sa_family == AF_LINK;
    }

    uint8_t const* networking_resolver::get_link_address_bytes(sockaddr const* addr) const
    {
        if (!is_link_address(addr)) {
            return nullptr;
        }
        sockaddr_dl const* link_addr = reinterpret_cast<sockaddr_dl const*>(addr);
        if (link_addr->sdl_alen != 6) {
            return nullptr;
        }
        return reinterpret_cast<uint8_t const*>(LLADDR(link_addr));
    }

    boost::optional<uint64_t> networking_resolver::get_link_mtu(string const& interface, void* data) const
    {
        ifreq ifr;
        memset(&ifr, 0, sizeof(ifr));
        strncpy(ifr.ifr_name, interface.c_str(), sizeof(ifr.ifr_name));
        int s = socket(AF_INET, SOCK_DGRAM, 0);
        if (s < 0) {
            LOG_WARNING("socket failed: %1% (%2%): interface MTU fact is unavailable for interface %3%.", strerror(errno), errno, interface);
            return boost::none;
        }

        if (ioctl(s, SIOCGIFMTU, &ifr) == -1) {
            LOG_WARNING("ioctl failed: %1% (%2%): interface MTU fact is unavailable for interface %3%.", strerror(errno), errno, interface);
            return boost::none;
        }

        return ifr.ifr_mtu;
    }

}}}  // namespace facter::facts::openbsdbsd
@


1.2
log
@- implement processor facts
- dont override dhcp methods; we can read the dhclient.leases files just fine
@
text
@@


1.1
log
@implement networking resolver; this finally gives us the 'fqdn' fact (among others)
@
text
@a56 12
    map<string, string> networking_resolver::find_dhcp_servers() const
    {
        /* XXX: Unimplemented. */
        return map<string, string>();
    }

    string networking_resolver::find_dhcp_server(string const& interface) const
    {
        /* XXX: Unimplemented. */
        return "";
    }

@

