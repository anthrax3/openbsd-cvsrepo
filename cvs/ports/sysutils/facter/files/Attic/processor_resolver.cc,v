head	1.5;
access;
symbols
	OPENBSD_5_9:1.4.0.2
	OPENBSD_5_9_BASE:1.4
	OPENBSD_5_8:1.3.0.4
	OPENBSD_5_8_BASE:1.3;
locks; strict;
comment	@// @;


1.5
date	2016.05.30.15.07.58;	author jasper;	state dead;
branches;
next	1.4;
commitid	mTPWHYxdzRBIjhfj;

1.4
date	2015.08.11.20.20.34;	author jasper;	state Exp;
branches;
next	1.3;
commitid	jFfnqkg1Zj2ANpFC;

1.3
date	2015.07.30.07.56.20;	author jasper;	state Exp;
branches;
next	1.2;
commitid	0ZvPQblCK0NE2BfT;

1.2
date	2015.07.23.08.06.28;	author jasper;	state Exp;
branches;
next	1.1;
commitid	5WgcQJui5MfB8tna;

1.1
date	2015.07.14.21.59.09;	author jasper;	state Exp;
branches;
next	;
commitid	uvFoXrOG1zGPyqyr;


desc
@@


1.5
log
@long overdue update to facter-3.1.7; all our patches have been merged upstream
however some new patches are needed to deal with the split-off leatherman lib.
@
text
@#include <internal/facts/openbsd/processor_resolver.hpp>
#include <leatherman/logging/logging.hpp>
#include <sys/types.h>
#include <sys/sysctl.h>

using namespace std;

namespace facter { namespace facts { namespace openbsd {

    processor_resolver::data processor_resolver::collect_data(collection& facts)
    {
        auto result = posix::processor_resolver::collect_data(facts);
        size_t len;
        int mib[2];
        mib[0] = CTL_HW;

        // Get the logical count of processors
        len = sizeof(result.logical_count);
        mib[1] = HW_NCPU;

        if (sysctl(mib, 2, &result.logical_count, &len, nullptr, 0) == -1) {
            LOG_DEBUG("sysctl hw.ncpu failed: %1% (%2%): logical processor count is unavailable.", strerror(errno), errno);
        }

        // For each logical processor, collect the model name
        if (result.logical_count > 0) {
            // Note: we're using the same description string for all logical processors:
            // using different CPUs is not even likely to work.
            vector<char> buffer(256);

            while (true) {
                size_t size = buffer.size();
                mib[1] = HW_MODEL;
                if (sysctl(mib, 2, buffer.data(), &size, nullptr, 0) == 0) {
                    buffer.resize(size + 1);
                    result.models.resize(result.logical_count, buffer.data());
                    break;
                }
                if (errno != ENOMEM) {
                    LOG_DEBUG("sysctl hw.model failed: %1% (%2%): processor models are unavailable.", strerror(errno), errno);
                    break;
                }
                buffer.resize(buffer.size() * 2);
            }
        }

        // Set the speed
        len = sizeof(result.speed);
        mib[1] = HW_CPUSPEED;
        if (sysctl(mib, 2, &result.speed, &len, nullptr, 0) == -1) {
            LOG_DEBUG("sysctl hw.cpuspeed failed: %1% (%2%): processor speed is unavailable.", strerror(errno), errno);
        }
        // Scale the speed to something resolve() can correctly map
        result.speed *= 1000 * 1000;

        return result;
    }

}}}  // namespace facter::facts::openbsd
@


1.4
log
@sync with what's been merged upstream
@
text
@@


1.3
log
@small tweaks incorporated while trying to push this upstream
@
text
@a16 8
        // Get the physical count of processors
        len = sizeof(result.physical_count);
        mib[1] = HW_NCPUFOUND;

        if (sysctl(mib, 2, &result.physical_count, &len, nullptr, 0) == -1) {
            LOG_DEBUG("sysctl hw.ncpufound failed: %1% (%2%): physical processor count is unavailable.", strerror(errno), errno);
        }

@


1.2
log
@- update to facter-3.0.2
@
text
@d18 1
a18 1
        len = sizeof(result.logical_count);
d21 1
a21 1
        if (sysctl(mib, 2, &result.logical_count, &len, nullptr, 0) == -1) {
d26 1
a26 1
        len = sizeof(result.physical_count);
d29 1
a29 1
        if (sysctl(mib, 2, &result.physical_count, &len, nullptr, 0) == -1) {
@


1.1
log
@- implement processor facts
- dont override dhcp methods; we can read the dhclient.leases files just fine
@
text
@d22 1
a22 1
            LOG_DEBUG("sysctl hw.ncpufound failed: %1% (%2): physical processor count is unavailable.", strerror(errno), errno);
@

