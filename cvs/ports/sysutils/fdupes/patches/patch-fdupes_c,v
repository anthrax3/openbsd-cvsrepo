head	1.2;
access;
symbols
	OPENBSD_6_1:1.2.0.10
	OPENBSD_6_1_BASE:1.2
	OPENBSD_6_0:1.2.0.8
	OPENBSD_6_0_BASE:1.2
	OPENBSD_5_9:1.2.0.4
	OPENBSD_5_9_BASE:1.2
	OPENBSD_5_8:1.2.0.6
	OPENBSD_5_8_BASE:1.2
	OPENBSD_5_7:1.2.0.2
	OPENBSD_5_7_BASE:1.2
	OPENBSD_5_6:1.1.1.1.0.26
	OPENBSD_5_6_BASE:1.1.1.1
	OPENBSD_5_5:1.1.1.1.0.24
	OPENBSD_5_5_BASE:1.1.1.1
	OPENBSD_5_4:1.1.1.1.0.22
	OPENBSD_5_4_BASE:1.1.1.1
	OPENBSD_5_3:1.1.1.1.0.20
	OPENBSD_5_3_BASE:1.1.1.1
	OPENBSD_5_2:1.1.1.1.0.18
	OPENBSD_5_2_BASE:1.1.1.1
	OPENBSD_5_1_BASE:1.1.1.1
	OPENBSD_5_1:1.1.1.1.0.16
	OPENBSD_5_0:1.1.1.1.0.14
	OPENBSD_5_0_BASE:1.1.1.1
	OPENBSD_4_9:1.1.1.1.0.12
	OPENBSD_4_9_BASE:1.1.1.1
	OPENBSD_4_8:1.1.1.1.0.10
	OPENBSD_4_8_BASE:1.1.1.1
	OPENBSD_4_7:1.1.1.1.0.8
	OPENBSD_4_7_BASE:1.1.1.1
	OPENBSD_4_6:1.1.1.1.0.6
	OPENBSD_4_6_BASE:1.1.1.1
	OPENBSD_4_5:1.1.1.1.0.4
	OPENBSD_4_5_BASE:1.1.1.1
	OPENBSD_4_4:1.1.1.1.0.2
	OPENBSD_4_4_BASE:1.1.1.1
	ckuethe_20080619:1.1.1.1
	ckuethe:1.1.1;
locks; strict;
comment	@# @;


1.2
date	2014.10.17.19.56.45;	author sthen;	state Exp;
branches;
next	1.1;
commitid	X4edwCIIeFB2hxnG;

1.1
date	2008.06.20.06.03.43;	author ckuethe;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2008.06.20.06.03.43;	author ckuethe;	state Exp;
branches;
next	;


desc
@@


1.2
log
@update to fdupes 1.51
@
text
@$OpenBSD: patch-fdupes_c,v 1.1.1.1 2008/06/20 06:03:43 ckuethe Exp $
--- fdupes.c.orig	Sat Apr 20 19:21:46 2013
+++ fdupes.c	Fri Oct 17 20:51:45 2014
@@@@ -36,6 +36,11 @@@@
 #include "md5/md5.h"
 #endif
 
+#ifdef HAVE_MD5
+#include <sys/types.h>
+#include <md5.h>
+#endif
+
 #define ISFLAG(a,b) ((a & b) == b)
 #define SETFLAG(a,b) (a |= b)
 
@@@@ -113,11 +118,13 @@@@ void escapefilename(char *escape_list, char **filename
 {
   int x;
   int tx;
+  size_t l;
   char *tmp;
   char *filename;
 
   filename = *filename_ptr;
 
+  l = strlen(filename) * 2 + 1;
   tmp = (char*) malloc(strlen(filename) * 2 + 1);
   if (tmp == NULL) {
     errormsg("out of memory!\n");
@@@@ -137,7 +144,7 @@@@ void escapefilename(char *escape_list, char **filename
       errormsg("out of memory!\n");
       exit(1);
     }
-    strcpy(*filename_ptr, tmp);
+    strlcpy(*filename_ptr, tmp, l);
   }
 }
 
@@@@ -236,6 +243,7 @@@@ int grokdir(char *dir, file_t **filelistp)
   struct dirent *dirinfo;
   int lastchar;
   int filecount = 0;
+  size_t l;
   struct stat info;
   struct stat linfo;
   static int progress = 0;
@@@@ -270,7 +278,8 @@@@ int grokdir(char *dir, file_t **filelistp)
       newfile->duplicates = NULL;
       newfile->hasdupes = 0;
 
-      newfile->d_name = (char*)malloc(strlen(dir)+strlen(dirinfo->d_name)+2);
+      l = strlen(dir)+strlen(dirinfo->d_name)+2;
+      newfile->d_name = (char*)malloc(l);
 
       if (!newfile->d_name) {
 	errormsg("out of memory!\n");
@@@@ -279,11 +288,11 @@@@ int grokdir(char *dir, file_t **filelistp)
 	exit(1);
       }
 
-      strcpy(newfile->d_name, dir);
+      strlcpy(newfile->d_name, dir, l);
       lastchar = strlen(dir) - 1;
       if (lastchar >= 0 && dir[lastchar] != '/')
-	strcat(newfile->d_name, "/");
-      strcat(newfile->d_name, dirinfo->d_name);
+	strlcat(newfile->d_name, "/", l);
+      strlcat(newfile->d_name, dirinfo->d_name, l);
       
       if (filesize(newfile->d_name) == 0 && ISFLAG(flags, F_EXCLUDEEMPTY)) {
 	free(newfile->d_name);
@@@@ -334,14 +343,22 @@@@ char *getcrcsignatureuntil(char *filename, off_t max_r
   int x;
   off_t fsize;
   off_t toread;
+#ifdef HAVE_MD5
+  MD5_CTX state;
+#else
   md5_state_t state;
+#endif
   md5_byte_t digest[16];  
   static md5_byte_t chunk[CHUNK_SIZE];
   static char signature[16*2 + 1]; 
   char *sigp;
   FILE *file;
-   
+
+#ifdef HAVE_MD5
+  MD5Init(&state);
+#else
   md5_init(&state);
+#endif
 
  
   fsize = filesize(filename);
@@@@ -362,16 +379,24 @@@@ char *getcrcsignatureuntil(char *filename, off_t max_r
       fclose(file);
       return NULL;
     }
+#ifdef HAVE_MD5
+    MD5Update(&state, chunk, toread);
+#else
     md5_append(&state, chunk, toread);
+#endif
     fsize -= toread;
   }
 
+#ifdef HAVE_MD5
+  MD5Final(digest, &state);
+#else
   md5_finish(&state, digest);
+#endif
 
   sigp = signature;
 
   for (x = 0; x < 16; x++) {
-    sprintf(sigp, "%02x", digest[x]);
+    snprintf(sigp, 2, "%02x", digest[x]);
     sigp = strchr(sigp, '\0');
   }
 
@@@@ -471,6 +496,7 @@@@ file_t **checkmatch(filetree_t **root, filetree_t *che
 {
   int cmpresult;
   char *crcsignature;
+  size_t l;
   off_t fsize;
 
   /* If device and inode fields are equal one of the files is a 
@@@@ -494,24 +520,26 @@@@ file_t **checkmatch(filetree_t **root, filetree_t *che
       crcsignature = getcrcpartialsignature(checktree->file->d_name);
       if (crcsignature == NULL) return NULL;
 
-      checktree->file->crcpartial = (char*) malloc(strlen(crcsignature)+1);
+      l = strlen(crcsignature)+1;
+      checktree->file->crcpartial = (char*) malloc(l);
       if (checktree->file->crcpartial == NULL) {
 	errormsg("out of memory\n");
 	exit(1);
       }
-      strcpy(checktree->file->crcpartial, crcsignature);
+      strlcpy(checktree->file->crcpartial, crcsignature, l);
     }
 
     if (file->crcpartial == NULL) {
       crcsignature = getcrcpartialsignature(file->d_name);
       if (crcsignature == NULL) return NULL;
 
-      file->crcpartial = (char*) malloc(strlen(crcsignature)+1);
+      l = strlen(crcsignature)+1;
+      file->crcpartial = (char*) malloc(l);
       if (file->crcpartial == NULL) {
 	errormsg("out of memory\n");
 	exit(1);
       }
-      strcpy(file->crcpartial, crcsignature);
+      strlcpy(file->crcpartial, crcsignature, l);
     }
 
     cmpresult = strcmp(file->crcpartial, checktree->file->crcpartial);
@@@@ -1164,7 +1192,7 @@@@ int main(int argc, char **argv) {
     }
     else
     {
-      stdin = freopen("/dev/tty", "r", stdin);
+      /* stdin isn't usable as an lvalue ... stdin = freopen("/dev/tty", "r", stdin); */
       deletefiles(files, 1, stdin);
     }
   }
@


1.1
log
@Initial revision
@
text
@d1 4
a4 4
$OpenBSD$
--- fdupes.c.orig	Thu Mar 15 04:16:09 2001
+++ fdupes.c	Fri May 30 13:49:42 2008
@@@@ -34,6 +34,11 @@@@
d16 1
a16 1
@@@@ -94,11 +99,13 @@@@ void escapefilename(char *escape_list, char **filename
d30 1
a30 1
@@@@ -118,7 +125,7 @@@@ void escapefilename(char *escape_list, char **filename
d39 1
a39 1
@@@@ -145,6 +152,7 @@@@ int grokdir(char *dir, file_t **filelistp)
d47 1
a47 1
@@@@ -177,7 +185,8 @@@@ int grokdir(char *dir, file_t **filelistp)
d57 1
a57 1
@@@@ -186,11 +195,11 @@@@ int grokdir(char *dir, file_t **filelistp)
d72 1
a72 1
@@@@ -241,14 +250,22 @@@@ char *getcrcsignature(char *filename)
d94 1
d96 2
a97 3
 
@@@@ -264,16 +281,24 @@@@ char *getcrcsignature(char *filename)
       errormsg("error reading from file %s\n", filename);
d122 1
a122 1
@@@@ -488,6 +513,7 @@@@ file_t *checkmatch(filetree_t **root, filetree_t *chec
d129 3
a131 3
   /* If inodes are equal one of the files is a hard link, which
@@@@ -508,24 +534,26 @@@@ file_t *checkmatch(filetree_t **root, filetree_t *chec
       crcsignature = getcrcsignature(checktree->file->d_name);
d134 1
a134 1
-      checktree->file->crcsignature = (char*) malloc(strlen(crcsignature)+1);
d136 2
a137 2
+      checktree->file->crcsignature = (char*) malloc(l);
       if (checktree->file->crcsignature == NULL) {
d141 2
a142 2
-      strcpy(checktree->file->crcsignature, crcsignature);
+      strlcpy(checktree->file->crcsignature, crcsignature, l);
d145 2
a146 2
     if (file->crcsignature == NULL) {
       crcsignature = getcrcsignature(file->d_name);
d149 1
a149 1
-      file->crcsignature = (char*) malloc(strlen(crcsignature)+1);
d151 2
a152 2
+      file->crcsignature = (char*) malloc(l);
       if (file->crcsignature == NULL) {
d156 2
a157 2
-      strcpy(file->crcsignature, crcsignature);
+      strlcpy(file->crcsignature, crcsignature, l);
d160 10
a169 19
     cmpresult = strcmp(file->crcsignature, checktree->file->crcsignature);
@@@@ -588,7 +616,7 @@@@ void printmatches(file_t *files)
   while (files != NULL) {
     if (files->hasdupes) {
       if (!ISFLAG(flags, F_OMITFIRST)) {
-	if (ISFLAG(flags, F_SHOWSIZE)) printf("%ld byte%seach:\n", files->size,
+	if (ISFLAG(flags, F_SHOWSIZE)) printf("%lld byte%seach:\n", files->size,
 	 (files->size != 1) ? "s " : " ");
 	if (ISFLAG(flags, F_DSAMELINE)) escapefilename("\\ ", &files->d_name);
 	printf("%s%c", files->d_name, ISFLAG(flags, F_DSAMELINE)?' ':'\n');
@@@@ -676,7 +704,7 @@@@ void autodelete(file_t *files)
       do {
 	printf("Set %d of %d, preserve files [1 - %d, all]", 
           curgroup, groups, counter);
-	if (ISFLAG(flags, F_SHOWSIZE)) printf(" (%ld byte%seach)", files->size,
+	if (ISFLAG(flags, F_SHOWSIZE)) printf(" (%lld byte%seach)", files->size,
 	  (files->size != 1) ? "s " : " ");
 	printf(": ");
 	fflush(stdout);
@


1.1.1.1
log
@fdupes is a utility to find duplicate files in a directory hierarchy.
submitted by Antti Harri
"sounds like you should import it" pvalchev@@
@
text
@@
