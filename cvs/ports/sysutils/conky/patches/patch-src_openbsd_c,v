head	1.18;
access;
symbols
	OPENBSD_6_2:1.18.0.2
	OPENBSD_6_2_BASE:1.18
	OPENBSD_6_1:1.16.0.10
	OPENBSD_6_1_BASE:1.16
	OPENBSD_6_0:1.16.0.8
	OPENBSD_6_0_BASE:1.16
	OPENBSD_5_9:1.16.0.4
	OPENBSD_5_9_BASE:1.16
	OPENBSD_5_8:1.16.0.6
	OPENBSD_5_8_BASE:1.16
	OPENBSD_5_7:1.16.0.2
	OPENBSD_5_7_BASE:1.16
	OPENBSD_5_6:1.15.0.8
	OPENBSD_5_6_BASE:1.15
	OPENBSD_5_5:1.15.0.6
	OPENBSD_5_5_BASE:1.15
	OPENBSD_5_4:1.15.0.4
	OPENBSD_5_4_BASE:1.15
	OPENBSD_5_3:1.15.0.2
	OPENBSD_5_3_BASE:1.15
	OPENBSD_5_2:1.14.0.2
	OPENBSD_5_2_BASE:1.14
	OPENBSD_5_1_BASE:1.13
	OPENBSD_5_1:1.13.0.2
	OPENBSD_5_0:1.12.0.2
	OPENBSD_5_0_BASE:1.12
	OPENBSD_4_9:1.9.0.2
	OPENBSD_4_9_BASE:1.9
	OPENBSD_4_8:1.8.0.2
	OPENBSD_4_8_BASE:1.8
	OPENBSD_4_6:1.6.0.2
	OPENBSD_4_6_BASE:1.6
	OPENBSD_4_5:1.5.0.2
	OPENBSD_4_5_BASE:1.5
	OPENBSD_4_4:1.4.0.4
	OPENBSD_4_4_BASE:1.4
	OPENBSD_4_3:1.4.0.2
	OPENBSD_4_3_BASE:1.4
	jasper_20071010:1.1.1.1
	jasper:1.1.1;
locks; strict;
comment	@# @;


1.18
date	2017.04.19.20.37.42;	author sthen;	state Exp;
branches;
next	1.17;
commitid	lsrshYVwWQBsnA8K;

1.17
date	2017.04.19.20.36.41;	author sthen;	state Exp;
branches;
next	1.16;
commitid	3LsrhuJmlP26zaD9;

1.16
date	2014.09.16.07.28.09;	author benoit;	state Exp;
branches;
next	1.15;
commitid	ScBjFWy18OeUH00E;

1.15
date	2012.12.18.21.38.12;	author sthen;	state Exp;
branches;
next	1.14;

1.14
date	2012.04.13.21.21.10;	author pascal;	state Exp;
branches;
next	1.13;

1.13
date	2011.09.11.18.53.28;	author dcoppa;	state Exp;
branches;
next	1.12;

1.12
date	2011.07.06.12.50.15;	author jasper;	state Exp;
branches;
next	1.11;

1.11
date	2011.07.06.12.32.51;	author jasper;	state Exp;
branches;
next	1.10;

1.10
date	2011.04.27.12.55.10;	author dcoppa;	state Exp;
branches;
next	1.9;

1.9
date	2010.10.25.18.11.26;	author sthen;	state Exp;
branches;
next	1.8;

1.8
date	2010.04.27.20.56.11;	author sthen;	state Exp;
branches;
next	1.7;

1.7
date	2009.11.23.16.46.24;	author benoit;	state dead;
branches;
next	1.6;

1.6
date	2009.05.10.19.07.47;	author sthen;	state Exp;
branches;
next	1.5;

1.5
date	2008.09.30.09.54.19;	author landry;	state Exp;
branches;
next	1.4;

1.4
date	2008.02.28.18.28.56;	author okan;	state Exp;
branches;
next	1.3;

1.3
date	2008.02.03.16.04.09;	author jasper;	state dead;
branches;
next	1.2;

1.2
date	2007.10.19.12.12.33;	author jasper;	state Exp;
branches;
next	1.1;

1.1
date	2007.10.10.21.20.23;	author jasper;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2007.10.10.21.20.23;	author jasper;	state Exp;
branches;
next	;


desc
@@


1.18
log
@Make "inline void proc_find_top" static to fix building with clang.
From Benjamin Baier.
@
text
@$OpenBSD: patch-src_openbsd_c,v 1.16 2014/09/16 07:28:09 benoit Exp $

declarations in common.h got changed, but upstream forgot to do the
corresponding changes into openbsd.c

Adapt to new OpenBSD kinfo_proc API.

Protect kvm_getprocs and global vars with mutexes.

dkstat.h is going away on OpenBSD, so use sys/sched.h instead for CP_*

Make "inline void proc_find_top" static to fix building with clang.

--- src/openbsd.c.orig	Thu May  3 23:08:27 2012
+++ src/openbsd.c	Wed Apr 19 22:14:41 2017
@@@@ -28,10 +28,11 @@@@
  *
  */
 
-#include <sys/dkstat.h>
 #include <sys/param.h>
+#include <sys/sched.h>
 #include <sys/resource.h>
 #include <sys/socket.h>
+#include <sys/proc.h>
 #include <sys/sysctl.h>
 #include <sys/time.h>
 #include <sys/types.h>
@@@@ -53,6 +54,7 @@@@
 #include <ifaddrs.h>
 #include <limits.h>
 #include <unistd.h>
+#include <pthread.h>
 #include <machine/apmvar.h>
 
 #include <net80211/ieee80211.h>
@@@@ -70,7 +72,7 @@@@
 #define LOG1024			10
 #define pagetok(size) ((size) << pageshift)
 
-inline void proc_find_top(struct process **cpu, struct process **mem);
+static inline void proc_find_top(struct process **cpu, struct process **mem);
 
 static short cpu_setup = 0;
 static kvm_t *kd = 0;
@@@@ -81,6 +83,8 @@@@ size_t len = 0;
 int init_kvm = 0;
 int init_sensors = 0;
 
+pthread_mutex_t kvm_mutex = PTHREAD_MUTEX_INITIALIZER;
+
 static int kvm_init()
 {
 	if (init_kvm) {
@@@@ -140,7 +144,7 @@@@ int check_mount(char *s)
 	return 0;
 }
 
-void update_uptime()
+int update_uptime()
 {
 	int mib[2] = { CTL_KERN, KERN_BOOTTIME };
 	struct timeval boottime;
@@@@ -155,9 +159,10 @@@@ void update_uptime()
 		NORM_ERR("Could not get uptime");
 		info.uptime = 0;
 	}
+	return 0;
 }
 
-void update_meminfo()
+int update_meminfo()
 {
 	static int mib[2] = { CTL_VM, VM_METER };
 	struct vmtotal vmtotal;
@@@@ -194,9 +199,10 @@@@ void update_meminfo()
 		info.swap = 0;
 		info.swapfree = 0;
 	}
+	return 0;
 }
 
-void update_net_stats()
+int update_net_stats()
 {
 	struct net_stat *ns;
 	double delta;
@@@@ -207,11 +213,11 @@@@ void update_net_stats()
 	/* get delta */
 	delta = current_update_time - last_update_time;
 	if (delta <= 0.0001) {
-		return;
+		return 0;
 	}
 
 	if (getifaddrs(&ifap) < 0) {
-		return;
+		return 0;
 	}
 
 	for (ifa = ifap; ifa; ifa = ifa->ifa_next) {
@@@@ -266,28 +272,36 @@@@ void update_net_stats()
 	}
 
 	freeifaddrs(ifap);
+	return 0;
 }
 
-void update_total_processes()
+int update_total_processes()
 {
-	int n_processes;
+	int n_processes = 0;
 
+	int max_size = sizeof(struct kinfo_proc);
+
 	kvm_init();
-	kvm_getprocs(kd, KERN_PROC_ALL, 0, &n_processes);
+	pthread_mutex_lock(&kvm_mutex);
+	kvm_getprocs(kd, KERN_PROC_ALL, 0, max_size, &n_processes);
+	pthread_mutex_unlock(&kvm_mutex);
 
 	info.procs = n_processes;
+	return 0;
 }
 
-void update_running_processes()
+int update_running_processes()
 {
-	struct kinfo_proc2 *p;
-	int n_processes;
+	struct kinfo_proc *p;
+	int n_processes = 0;
 	int i, cnt = 0;
 
 	kvm_init();
-	int max_size = sizeof(struct kinfo_proc2);
+	int max_size = sizeof(struct kinfo_proc);
 
-	p = kvm_getproc2(kd, KERN_PROC_ALL, 0, max_size, &n_processes);
+	pthread_mutex_lock(&kvm_mutex);
+	p = kvm_getprocs(kd, KERN_PROC_ALL, 0, max_size, &n_processes);
+	pthread_mutex_unlock(&kvm_mutex);
 	for (i = 0; i < n_processes; i++) {
 		if (p[i].p_stat == SRUN) {
 			cnt++;
@@@@ -295,96 +309,64 @@@@ void update_running_processes()
 	}
 
 	info.run_procs = cnt;
+	return 0;
 }
 
-/* new SMP code can be enabled by commenting the following line */
-#define OLDCPU
-
-#ifdef OLDCPU
-struct cpu_load_struct {
-	unsigned long load[5];
-};
-
-struct cpu_load_struct fresh = { {0, 0, 0, 0, 0} };
-long cpu_used, oldtotal, oldused;
-#else
 #include <assert.h>
 int64_t *fresh = NULL;
 
 /* XXX is 8 enough? - What's the constant for MAXCPU? */
 /* allocate this with malloc would be better */
 int64_t oldtotal[8], oldused[8];
-#endif
 
 void get_cpu_count()
 {
 	int cpu_count = 1;	/* default to 1 cpu */
-#ifndef OLDCPU
+	static pthread_mutex_t count_mutex = PTHREAD_MUTEX_INITIALIZER;
+
 	int mib[2] = { CTL_HW, HW_NCPU };
 	size_t len = sizeof(cpu_count);
 
 	if (sysctl(mib, 2, &cpu_count, &len, NULL, 0) != 0) {
 		NORM_ERR("error getting cpu count, defaulting to 1");
 	}
-#endif
+
+	pthread_mutex_lock(&count_mutex);
+
+	if (info.cpu_count == cpu_count) {
+		pthread_mutex_unlock(&count_mutex);
+		return;
+	}
+
 	info.cpu_count = cpu_count;
 
+	free(info.cpu_usage);
+
 	info.cpu_usage = malloc(info.cpu_count * sizeof(float));
 	if (info.cpu_usage == NULL) {
 		CRIT_ERR(NULL, NULL, "malloc");
 	}
 
-#ifndef OLDCPU
-	assert(fresh == NULL);	/* XXX Is this leaking memory? */
+	free(fresh);
 	/* XXX Where shall I free this? */
 	if (NULL == (fresh = calloc(cpu_count, sizeof(int64_t) * CPUSTATES))) {
 		CRIT_ERR(NULL, NULL, "calloc");
 	}
-#endif
+
+	pthread_mutex_unlock(&count_mutex);
 }
 
-void update_cpu_usage()
+int update_cpu_usage()
 {
-#ifdef OLDCPU
-	int mib[2] = { CTL_KERN, KERN_CPTIME };
-	long used, total;
-	long cp_time[CPUSTATES];
-	size_t len = sizeof(cp_time);
-#else
 	size_t size;
 	unsigned int i;
-#endif
 
 	/* add check for !info.cpu_usage since that mem is freed on a SIGUSR1 */
 	if ((cpu_setup == 0) || (!info.cpu_usage)) {
 		get_cpu_count();
 		cpu_setup = 1;
 	}
-
-#ifdef OLDCPU
-	if (sysctl(mib, 2, &cp_time, &len, NULL, 0) < 0) {
-		NORM_ERR("Cannot get kern.cp_time");
-	}
-
-	fresh.load[0] = cp_time[CP_USER];
-	fresh.load[1] = cp_time[CP_NICE];
-	fresh.load[2] = cp_time[CP_SYS];
-	fresh.load[3] = cp_time[CP_IDLE];
-	fresh.load[4] = cp_time[CP_IDLE];
-
-	used = fresh.load[0] + fresh.load[1] + fresh.load[2];
-	total = fresh.load[0] + fresh.load[1] + fresh.load[2] + fresh.load[3];
-
-	if ((total - oldtotal) != 0) {
-		info.cpu_usage[0] = ((double) (used - oldused)) /
-			(double) (total - oldtotal);
-	} else {
-		info.cpu_usage[0] = 0;
-	}
-
-	oldused = used;
-	oldtotal = total;
-#else
+	
 	if (info.cpu_count > 1) {
 		size = CPUSTATES * sizeof(int64_t);
 		for (i = 0; i < info.cpu_count; i++) {
@@@@ -426,10 +408,11 @@@@ void update_cpu_usage()
 		oldused[i] = used;
 		oldtotal[i] = total;
 	}
-#endif
+
+	return 0;
 }
 
-void update_load_average()
+int update_load_average()
 {
 	double v[3];
 
@@@@ -438,6 +421,7 @@@@ void update_load_average()
 	info.loadavg[0] = (float) v[0];
 	info.loadavg[1] = (float) v[1];
 	info.loadavg[2] = (float) v[2];
+	return 0;
 }
 
 #define OBSD_MAX_SENSORS 256
@@@@ -606,10 +590,11 @@@@ char get_freq(char *p_client_buffer, size_t client_buf
 	return 1;
 }
 
-void update_top()
+int update_top()
 {
 	kvm_init();
 	proc_find_top(info.cpu, info.memu);
+	return 0;
 }
 
 #if 0
@@@@ -665,19 +650,11 @@@@ cleanup:
 }
 #endif
 
-void clear_diskio_stats()
+int update_diskio()
 {
+	return 0;	/* XXX: implement? hifi: not sure how */
 }
 
-struct diskio_stat *prepare_diskio_stat(const char *s)
-{
-}
-
-void update_diskio()
-{
-	return;	/* XXX: implement? hifi: not sure how */
-}
-
 /* While topless is obviously better, top is also not bad. */
 
 int comparecpu(const void *a, const void *b)
@@@@ -706,10 +683,10 @@@@ int comparemem(const void *a, const void *b)
 	return 0;
 }
 
-inline void proc_find_top(struct process **cpu, struct process **mem)
+static inline void proc_find_top(struct process **cpu, struct process **mem)
 {
-	struct kinfo_proc2 *p;
-	int n_processes;
+	struct kinfo_proc *p;
+	int n_processes = 0;
 	int i, j = 0;
 	struct process *processes;
 	int mib[2];
@@@@ -730,9 +707,11 @@@@ inline void proc_find_top(struct process **cpu, struct
 	/* translate bytes into page count */
 	total_pages = usermem / pagesize;
 
-	int max_size = sizeof(struct kinfo_proc2);
+	int max_size = sizeof(struct kinfo_proc);
 
-	p = kvm_getproc2(kd, KERN_PROC_ALL, 0, max_size, &n_processes);
+
+	pthread_mutex_lock(&kvm_mutex);
+	p = kvm_getprocs(kd, KERN_PROC_ALL, 0, max_size, &n_processes);
 	processes = malloc(n_processes * sizeof(struct process));
 
 	for (i = 0; i < n_processes; i++) {
@@@@ -740,9 +719,12 @@@@ inline void proc_find_top(struct process **cpu, struct
 			processes[j].pid = p[i].p_pid;
 			processes[j].name = strndup(p[i].p_comm, text_buffer_size);
 			processes[j].amount = 100.0 * p[i].p_pctcpu / FSCALE;
+			processes[j].vsize = p[i].p_vm_map_size;
+			processes[j].rss = p[i].p_vm_rssize * PAGE_SIZE;
 			j++;
 		}
 	}
+	pthread_mutex_unlock(&kvm_mutex);
 
 	qsort(processes, j - 1, sizeof(struct process), comparemem);
 	for (i = 0; i < 10; i++) {
@@@@ -752,6 +734,8 @@@@ inline void proc_find_top(struct process **cpu, struct
 		tmp->pid = processes[i].pid;
 		tmp->amount = processes[i].amount;
 		tmp->name = strndup(processes[i].name, text_buffer_size);
+		tmp->vsize = processes[i].vsize;
+		tmp->rss = processes[i].rss;
 
 		ttmp = mem[i];
 		mem[i] = tmp;
@@@@ -769,6 +753,8 @@@@ inline void proc_find_top(struct process **cpu, struct
 		tmp->pid = processes[i].pid;
 		tmp->amount = processes[i].amount;
 		tmp->name = strndup(processes[i].name, text_buffer_size);
+		tmp->vsize = processes[i].vsize;
+		tmp->rss = processes[i].rss;
 
 		ttmp = cpu[i];
 		cpu[i] = tmp;
@@@@ -784,7 +770,6 @@@@ inline void proc_find_top(struct process **cpu, struct
 	free(processes);
 }
 
-#if	defined(i386) || defined(__i386__)
 #define	APMDEV		"/dev/apm"
 #define	APM_UNKNOWN	255
 
@@@@ -908,7 +893,6 @@@@ char *get_apm_battery_time()
 	return out;
 }
 
-#endif
 
 /* empty stubs so conky links */
 void prepare_update()
@@@@ -923,8 +907,4 @@@@ int get_entropy_avail(unsigned int *val)
 int get_entropy_poolsize(unsigned int *val)
 {
 	return 1;
-}
-
-void free_all_processes(void)
-{
 }
@


1.17
log
@regen patch
@
text
@d12 4
a15 2
--- src/openbsd.c.orig	Thu May  3 22:08:27 2012
+++ src/openbsd.c	Wed Apr 19 21:36:08 2017
d37 9
d319 3
a321 1
@@@@ -708,8 +685,8 @@@@ int comparemem(const void *a, const void *b)
d323 2
a324 1
 inline void proc_find_top(struct process **cpu, struct process **mem)
@


1.16
log
@unbreak with dkstat.h removal.
@
text
@d1 1
a1 1
$OpenBSD$
d12 2
a13 2
--- src/openbsd.c.orig	Thu May  3 23:08:27 2012
+++ src/openbsd.c	Tue Sep 16 08:40:12 2014
d35 1
a35 1
@@@@ -81,6 +83,8 @@@@
d44 1
a44 1
@@@@ -140,7 +144,7 @@@@
d53 1
a53 1
@@@@ -155,9 +159,10 @@@@
d65 1
a65 1
@@@@ -194,9 +199,10 @@@@
d77 1
a77 1
@@@@ -207,11 +213,11 @@@@
d91 1
a91 1
@@@@ -266,28 +272,36 @@@@
d136 1
a136 1
@@@@ -295,96 +309,64 @@@@
d251 1
a251 1
@@@@ -426,10 +408,11 @@@@
d265 1
a265 1
@@@@ -438,6 +421,7 @@@@
d273 1
a273 1
@@@@ -606,10 +590,11 @@@@
d286 1
a286 1
@@@@ -665,19 +650,11 @@@@
d308 1
a308 1
@@@@ -708,8 +685,8 @@@@
d319 1
a319 1
@@@@ -730,9 +707,11 @@@@
d333 1
a333 1
@@@@ -740,9 +719,12 @@@@
d346 1
a346 1
@@@@ -752,6 +734,8 @@@@
d355 1
a355 1
@@@@ -769,6 +753,8 @@@@
d364 1
a364 1
@@@@ -784,7 +770,6 @@@@
d372 1
a372 1
@@@@ -908,7 +893,6 @@@@
d380 1
a380 1
@@@@ -923,8 +907,4 @@@@
@


1.15
log
@cope with sysctl.h changes
@
text
@d1 1
a1 1
$OpenBSD: patch-src_openbsd_c,v 1.14 2012/04/13 21:21:10 pascal Exp $
d10 9
a18 3
--- src/openbsd.c.orig	Tue Oct  5 15:29:36 2010
+++ src/openbsd.c	Fri Dec  7 06:11:21 2012
@@@@ -32,6 +32,7 @@@@
d20 1
d35 1
a35 1
@@@@ -81,6 +83,8 @@@@ size_t len = 0;
d44 1
a44 1
@@@@ -140,7 +144,7 @@@@ int check_mount(char *s)
d53 1
a53 1
@@@@ -155,9 +159,10 @@@@ void update_uptime()
d65 1
a65 1
@@@@ -194,9 +199,10 @@@@ void update_meminfo()
d77 1
a77 1
@@@@ -207,11 +213,11 @@@@ void update_net_stats()
d91 1
a91 1
@@@@ -266,28 +272,36 @@@@ void update_net_stats()
d136 1
a136 1
@@@@ -295,96 +309,64 @@@@ void update_running_processes()
d251 1
a251 1
@@@@ -426,10 +408,11 @@@@ void update_cpu_usage()
d265 1
a265 1
@@@@ -438,6 +421,7 @@@@ void update_load_average()
d273 1
a273 1
@@@@ -606,10 +590,11 @@@@ char get_freq(char *p_client_buffer, size_t client_buf
d286 1
a286 1
@@@@ -665,19 +650,11 @@@@ cleanup:
d308 1
a308 1
@@@@ -708,8 +685,8 @@@@ int comparemem(const void *a, const void *b)
d319 1
a319 1
@@@@ -730,9 +707,11 @@@@ inline void proc_find_top(struct process **cpu, struct
d333 1
a333 1
@@@@ -740,9 +719,12 @@@@ inline void proc_find_top(struct process **cpu, struct
d346 1
a346 1
@@@@ -752,6 +734,8 @@@@ inline void proc_find_top(struct process **cpu, struct
d355 1
a355 1
@@@@ -769,6 +753,8 @@@@ inline void proc_find_top(struct process **cpu, struct
d364 1
a364 1
@@@@ -784,7 +770,6 @@@@ inline void proc_find_top(struct process **cpu, struct
d372 1
a372 1
@@@@ -908,7 +893,6 @@@@ char *get_apm_battery_time()
d380 1
a380 1
@@@@ -923,8 +907,4 @@@@ int get_entropy_avail(unsigned int *val)
@


1.14
log
@Fix conky with rthreads.  Joint work with kurt@@, with input from guenther@@.

ok benoit@@ (maintainer)
@
text
@d1 1
a1 1
$OpenBSD: patch-src_openbsd_c,v 1.13 2011/09/11 18:53:28 dcoppa Exp $
d10 11
a20 3
--- src/openbsd.c.orig	Tue Oct  5 23:29:36 2010
+++ src/openbsd.c	Wed Apr 11 17:39:26 2012
@@@@ -53,6 +53,7 @@@@
d28 1
a28 1
@@@@ -81,6 +82,8 @@@@ size_t len = 0;
d37 1
a37 1
@@@@ -140,7 +143,7 @@@@ int check_mount(char *s)
d46 1
a46 1
@@@@ -155,9 +158,10 @@@@ void update_uptime()
d58 1
a58 1
@@@@ -194,9 +198,10 @@@@ void update_meminfo()
d70 1
a70 1
@@@@ -207,11 +212,11 @@@@ void update_net_stats()
d84 1
a84 1
@@@@ -266,28 +271,36 @@@@ void update_net_stats()
d129 1
a129 1
@@@@ -295,96 +308,64 @@@@ void update_running_processes()
d244 1
a244 1
@@@@ -426,10 +407,11 @@@@ void update_cpu_usage()
d258 1
a258 1
@@@@ -438,6 +420,7 @@@@ void update_load_average()
d266 1
a266 1
@@@@ -606,10 +589,11 @@@@ char get_freq(char *p_client_buffer, size_t client_buf
d279 1
a279 1
@@@@ -665,19 +649,11 @@@@ cleanup:
d301 1
a301 1
@@@@ -708,8 +684,8 @@@@ int comparemem(const void *a, const void *b)
d312 1
a312 1
@@@@ -730,9 +706,11 @@@@ inline void proc_find_top(struct process **cpu, struct
d326 1
a326 1
@@@@ -740,9 +718,12 @@@@ inline void proc_find_top(struct process **cpu, struct
d339 1
a339 1
@@@@ -752,6 +733,8 @@@@ inline void proc_find_top(struct process **cpu, struct
d348 1
a348 1
@@@@ -769,6 +752,8 @@@@ inline void proc_find_top(struct process **cpu, struct
d357 1
a357 1
@@@@ -784,7 +769,6 @@@@ inline void proc_find_top(struct process **cpu, struct
d365 1
a365 1
@@@@ -908,7 +892,6 @@@@ char *get_apm_battery_time()
d373 1
a373 1
@@@@ -923,8 +906,4 @@@@ int get_entropy_avail(unsigned int *val)
@


1.13
log
@- Reenable $addr and $if_up
- Enable the new SMP code (allowing the user to actually see multiple
  cores)
- Enable RES and VSIZE display in $top

From Pascal Stumpf: thanks!

ok benoit@@, jasper@@
@
text
@d1 1
a1 1
$OpenBSD: patch-src_openbsd_c,v 1.12 2011/07/06 12:50:15 jasper Exp $
d8 2
d11 19
a29 2
+++ src/openbsd.c	Mon Jul 18 14:04:55 2011
@@@@ -140,7 +140,7 @@@@ int check_mount(char *s)
d38 1
a38 1
@@@@ -155,9 +155,10 @@@@ void update_uptime()
d50 1
a50 1
@@@@ -194,9 +195,10 @@@@ void update_meminfo()
d62 1
a62 1
@@@@ -207,11 +209,11 @@@@ void update_net_stats()
d76 1
a76 1
@@@@ -266,28 +268,32 @@@@ void update_net_stats()
d86 2
a87 1
 	int n_processes;
d93 1
d95 1
d105 1
d107 1
a107 1
 	int n_processes;
d115 1
d117 1
d121 1
a121 1
@@@@ -295,10 +301,11 @@@@ void update_running_processes()
d128 1
a128 1
 /* new SMP code can be enabled by commenting the following line */
d130 46
a175 1
+/* #define OLDCPU */
d177 10
a186 4
 #ifdef OLDCPU
 struct cpu_load_struct {
@@@@ -343,7 +350,7 @@@@ void get_cpu_count()
 #endif
d192 46
a237 3
 #ifdef OLDCPU
 	int mib[2] = { CTL_KERN, KERN_CPTIME };
@@@@ -427,9 +434,10 @@@@ void update_cpu_usage()
d240 2
a241 1
 #endif
d250 1
a250 1
@@@@ -438,6 +446,7 @@@@ void update_load_average()
d258 1
a258 1
@@@@ -606,10 +615,11 @@@@ char get_freq(char *p_client_buffer, size_t client_buf
d271 1
a271 1
@@@@ -665,19 +675,11 @@@@ cleanup:
d293 1
a293 1
@@@@ -708,7 +710,7 @@@@ int comparemem(const void *a, const void *b)
d298 1
d300 1
a300 1
 	int n_processes;
d303 2
a304 1
@@@@ -730,9 +732,9 @@@@ inline void proc_find_top(struct process **cpu, struct
d312 2
d318 1
a318 1
@@@@ -740,6 +742,8 @@@@ inline void proc_find_top(struct process **cpu, struct
d327 5
a331 1
@@@@ -752,6 +756,8 @@@@ inline void proc_find_top(struct process **cpu, struct
d340 1
a340 1
@@@@ -769,6 +775,8 @@@@ inline void proc_find_top(struct process **cpu, struct
d349 1
a349 1
@@@@ -784,7 +792,6 @@@@ inline void proc_find_top(struct process **cpu, struct
d357 1
a357 1
@@@@ -908,7 +915,6 @@@@ char *get_apm_battery_time()
d365 1
a365 1
@@@@ -923,8 +929,4 @@@@ int get_entropy_avail(unsigned int *val)
@


1.12
log
@- move away from old kinfo_proc2
- add mising comment
@
text
@d1 1
a1 1
$OpenBSD: patch-src_openbsd_c,v 1.10 2011/04/27 12:55:10 dcoppa Exp $
d9 1
a9 1
+++ src/openbsd.c	Wed Jul  6 14:30:14 2011
d96 1
a96 1
@@@@ -295,6 +301,7 @@@@ void update_running_processes()
d104 5
d194 28
a221 1
@@@@ -784,7 +786,6 @@@@ inline void proc_find_top(struct process **cpu, struct
d229 1
a229 1
@@@@ -908,7 +909,6 @@@@ char *get_apm_battery_time()
d237 1
a237 1
@@@@ -923,8 +923,4 @@@@ int get_entropy_avail(unsigned int *val)
@


1.11
log
@move away from kinfo_proc2
@
text
@d6 2
@


1.10
log
@Update to conky-1.8.1.

Added audacious, imlib2 and xmms2 flavors.

USE_GROFF and manpage patching during post-install are no more
needed.

Joint work with Pascal Stumpf (thanks!)
OK jasper@@, benoit@@ (maintainer)
@
text
@d1 1
a1 1
$OpenBSD$
d7 1
a7 1
+++ src/openbsd.c	Tue Apr 19 19:40:39 2011
d55 1
a55 1
@@@@ -266,19 +268,23 @@@@ void update_net_stats()
d80 2
a81 1
 	struct kinfo_proc2 *p;
d83 11
d166 21
@


1.9
log
@switch kvm_getprocs to kvm_getproc2
@
text
@d1 64
a64 4
$OpenBSD: patch-src_openbsd_c,v 1.8 2010/04/27 20:56:11 sthen Exp $
--- src/openbsd.c.orig	Sat Aug  8 22:05:55 2009
+++ src/openbsd.c	Mon Oct 25 20:05:06 2010
@@@@ -271,7 +271,7 @@@@ void update_total_processes()
d67 2
d71 1
a71 1
+	kvm_getproc2(kd, KERN_PROC_ALL, 0, sizeof(n_processes), &n_processes);
d74 55
a129 1
@@@@ -454,14 +454,13 @@@@ void update_obsd_sensors()
d131 34
a164 1
 	dev = obsd_sensors.device;	// FIXME: read more than one device
d166 1
a166 23
-	/* for (dev = 0; dev < MAXSENSORDEVICES; dev++) { */
+	for (dev = 0; dev < MAXSENSORDEVICES; dev++) {
 		mib[2] = dev;
 		if (sysctl(mib, 3, &sensordev, &sdlen, NULL, 0) == -1) {
-			if (errno != ENOENT) {
-				warn("sysctl");
-			}
-			return;
-			// continue;
+			if (errno == ENOENT) /* end of sensors */
+				return;
+			if (errno == ENXIO) /* missing e.g. usb sensor that was unplugged */
+				continue;
 		}
 		for (type = 0; type < SENSOR_MAX_TYPES; type++) {
 			mib[3] = type;
@@@@ -496,7 +495,8 @@@@ void update_obsd_sensors()
 				sensor_cnt++;
 			}
 		}
-	/* } */
+		break; // FIXME: read more than one device
+	}
d168 10
a177 1
 	init_sensors = 1;
@


1.8
log
@adjust for sensors changes, unbreaks the build.
@
text
@d1 12
a12 3
$OpenBSD$
--- src/openbsd.c.orig	Sat Aug  8 21:05:55 2009
+++ src/openbsd.c	Tue Apr 27 20:40:38 2010
@


1.7
log
@- update conky to 1.7.2
- regen PLIST
- change maintainer (maintainer timeout)
- update patches

ok ajacoutot@@
@
text
@d1 4
a4 5
$OpenBSD: patch-src_openbsd_c,v 1.6 2009/05/10 19:07:47 sthen Exp $
--- src/openbsd.c.orig	Mon Mar 30 05:55:51 2009
+++ src/openbsd.c	Sun May 10 12:23:14 2009
@@@@ -56,6 +56,10 @@@@
 #include <net80211/ieee80211_ioctl.h>
d6 1
a6 5
 #include "conky.h"
+#include "diskio.h"
+#include "logging.h"
+#include "openbsd.h"
+#include "top.h"
d8 23
a30 1
 #define	MAXSHOWDEVS		16
d32 1
a32 9
@@@@ -656,6 +660,10 @@@@ cleanup:
 #endif
 
 void clear_diskio_stats()
+{
+}
+
+struct diskio_stat *prepare_diskio_stat(const char *s)
 {
a33 1
 
@


1.6
log
@update to 1.7.0 and add no_x11 flavour (useful for dwm's status bar
or with dzen2). ok jasper@@, Vlad Glagolev (maintainer).
@
text
@d1 1
a1 1
$OpenBSD: patch-src_openbsd_c,v 1.5 2008/09/30 09:54:19 landry Exp $
@


1.5
log
@Update to conky 1.6.1.
conkyrc.sample disappeared, and src/openbsd.h is missing from distfile.
ok jasper@@ & vlad glagolev (MAINTAINER)
@
text
@d1 11
a11 4
$OpenBSD$
--- src/openbsd.c.orig	Tue Jul 29 20:01:18 2008
+++ src/openbsd.c	Mon Sep 22 22:38:31 2008
@@@@ -598,6 +598,7 @@@@ char get_freq(char *p_client_buffer, size_t client_buf
d13 1
a13 5
 void update_top()
 {
+	kvm_init();
 	proc_find_top(info.cpu, info.memu);
 }
d15 1
a15 2
@@@@ -654,6 +655,10 @@@@ cleanup:
 }
d18 1
a18 1
+void clear_diskio_stats()
d22 1
a22 1
 void update_diskio()
d24 1
a24 27
 	return;	/* XXX: implement? hifi: not sure how */
@@@@ -695,18 +700,22 @@@@ inline void proc_find_top(struct process **cpu, struct
 	struct process *processes;
 	int mib[2];
 
-	int total_pages;
+	u_int total_pages;
+	int64_t usermem;
 	int pagesize = getpagesize();
 
 	/* we get total pages count again to be sure it is up to date */
 	mib[0] = CTL_HW;
-	mib[1] = HW_USERMEM;
-	size_t size = sizeof(total_pages);
+	mib[1] = HW_USERMEM64;
+	size_t size = sizeof(usermem);
 
-	if (sysctl(mib, 2, &total_pages, &size, NULL, 0) == -1) {
-		ERR("error reading nmempages");
+	if (sysctl(mib, 2, &usermem, &size, NULL, 0) == -1) {
+		ERR("error reading usermem");
 	}
 
+	/* translate bytes into page count */
+	total_pages = usermem / pagesize;
+
 	int max_size = sizeof(struct kinfo_proc2);
a25 10
 	p = kvm_getproc2(kd, KERN_PROC_ALL, 0, max_size, &n_processes);
@@@@ -717,7 +726,7 @@@@ inline void proc_find_top(struct process **cpu, struct
 			processes[j].pid = p[i].p_pid;
 			processes[j].name = strndup(p[i].p_comm, text_buffer_size);
 			processes[j].amount = 100.0 * p[i].p_pctcpu / FSCALE;
-			processes[j].totalmem = (float) (p[i].p_vm_rssize * pagesize /
+			processes[j].totalmem = (float) (p[i].p_vm_rssize /
 				(float) total_pages) * 100.0;
 			j++;
 		}
@


1.4
log
@HW_USERMEM64 fix, plus re-work a bit to be more understandable

ok naddy@@
@
text
@d2 22
a23 3
--- src/openbsd.c.orig	Wed Nov 14 16:29:26 2007
+++ src/openbsd.c	Thu Feb 28 10:56:22 2008
@@@@ -685,16 +685,20 @@@@ proc_find_top(struct process **cpu, struct process **m
d28 1
a29 1
+	u_int total_pages;
a35 2
-	if(sysctl(mib, 2, &total_pages, &size, NULL, 0) == -1)
-		ERR("error reading nmempages");
d38 4
a41 1
+	if(sysctl(mib, 2, &usermem, &size, NULL, 0) == -1)
d43 1
d49 1
d51 7
a57 8
 	processes = malloc(n_processes * sizeof (struct process));
@@@@ -707,7 +711,7 @@@@ proc_find_top(struct process **cpu, struct process **m
 			processes[j].name =  strdup(p[i].p_comm);
 			processes[j].amount = 100.0 *
 				p[i].p_pctcpu / FSCALE;
-			processes[j].totalmem = (float)(p[i].p_vm_rssize * pagesize /
+			processes[j].totalmem = (float)(p[i].p_vm_rssize /
 					(float)total_pages) * 100.0;
@


1.3
log
@- update conky to 1.4.9

from Vlad Glagolev (MAINTAINER)
@
text
@d1 6
a6 11
$OpenBSD: patch-src_openbsd_c,v 1.2 2007/10/19 12:12:33 jasper Exp $
--- src/openbsd.c.orig	Tue Aug 28 21:12:38 2007
+++ src/openbsd.c	Fri Oct 19 06:09:55 2007
@@@@ -497,7 +497,7 @@@@ get_freq_dynamic(char *p_client_buffer, size_t client_
 	snprintf(p_client_buffer, client_buffer_size, p_format,
 		(float)((cycles[1] - cycles[0]) / microseconds) / divisor);
 #else
-	get_freq(p_client_buffer, client_buffer_size, p_format, divisor);
+	get_freq(p_client_buffer, client_buffer_size, p_format, divisor, 1);
 #endif
 }
d8 31
@


1.2
log
@not for archs without apmvar.h, until i've found a better fix

spotted by sturm@@
@
text
@d1 1
a1 1
$OpenBSD: patch-src_openbsd_c,v 1.1.1.1 2007/10/10 21:20:23 jasper Exp $
@


1.1
log
@Initial revision
@
text
@d1 3
a3 3
$OpenBSD$
--- src/openbsd.c.orig	Sun Sep 23 22:57:37 2007
+++ src/openbsd.c	Sun Sep 23 22:57:57 2007
@


1.1.1.1
log
@import conky 1.4.7

Conky is a system monitor for X originally based on the torsmo code.
Since it's original conception, Conky has changed a fair bit from it's
predecessor. Conky can display just about anything, either on your root
desktop or in it's own window. Conky has many built-in objects, as well
as the ability to execute programs and scripts, then display the output
from stdout.

from Vlad Glagolev <stelzy at gmail.com> (MAINTAINER)
feedback and ok ajacoutot@@
@
text
@@
