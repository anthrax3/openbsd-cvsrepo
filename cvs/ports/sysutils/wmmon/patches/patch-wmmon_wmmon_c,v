head	1.9;
access;
symbols
	OPENBSD_6_2:1.9.0.12
	OPENBSD_6_2_BASE:1.9
	OPENBSD_6_1:1.9.0.10
	OPENBSD_6_1_BASE:1.9
	OPENBSD_6_0:1.9.0.8
	OPENBSD_6_0_BASE:1.9
	OPENBSD_5_9:1.9.0.4
	OPENBSD_5_9_BASE:1.9
	OPENBSD_5_8:1.9.0.6
	OPENBSD_5_8_BASE:1.9
	OPENBSD_5_7:1.9.0.2
	OPENBSD_5_7_BASE:1.9
	OPENBSD_5_6:1.8.0.2
	OPENBSD_5_6_BASE:1.8
	OPENBSD_5_5:1.7.0.6
	OPENBSD_5_5_BASE:1.7
	OPENBSD_5_4:1.7.0.4
	OPENBSD_5_4_BASE:1.7
	OPENBSD_5_3:1.7.0.2
	OPENBSD_5_3_BASE:1.7
	OPENBSD_5_2:1.5.0.24
	OPENBSD_5_2_BASE:1.5
	OPENBSD_5_1_BASE:1.5
	OPENBSD_5_1:1.5.0.22
	OPENBSD_5_0:1.5.0.20
	OPENBSD_5_0_BASE:1.5
	OPENBSD_4_9:1.5.0.18
	OPENBSD_4_9_BASE:1.5
	OPENBSD_4_8:1.5.0.16
	OPENBSD_4_8_BASE:1.5
	OPENBSD_4_7:1.5.0.14
	OPENBSD_4_7_BASE:1.5
	OPENBSD_4_6:1.5.0.12
	OPENBSD_4_6_BASE:1.5
	OPENBSD_4_5:1.5.0.10
	OPENBSD_4_5_BASE:1.5
	OPENBSD_4_4:1.5.0.8
	OPENBSD_4_4_BASE:1.5
	OPENBSD_4_3:1.5.0.6
	OPENBSD_4_3_BASE:1.5
	OPENBSD_4_2:1.5.0.4
	OPENBSD_4_2_BASE:1.5
	OPENBSD_4_1:1.5.0.2
	OPENBSD_4_1_BASE:1.5
	OPENBSD_4_0:1.4.0.10
	OPENBSD_4_0_BASE:1.4
	OPENBSD_3_9:1.4.0.8
	OPENBSD_3_9_BASE:1.4
	OPENBSD_3_8:1.4.0.6
	OPENBSD_3_8_BASE:1.4
	OPENBSD_3_7:1.4.0.4
	OPENBSD_3_7_BASE:1.4
	OPENBSD_3_6:1.4.0.2
	OPENBSD_3_6_BASE:1.4
	OPENBSD_3_5:1.3.0.10
	OPENBSD_3_5_BASE:1.3
	OPENBSD_3_4:1.3.0.8
	OPENBSD_3_4_BASE:1.3
	OPENBSD_3_3:1.3.0.6
	OPENBSD_3_3_BASE:1.3
	OPENBSD_3_2:1.3.0.4
	OPENBSD_3_2_BASE:1.3
	OPENBSD_3_1:1.3.0.2
	OPENBSD_3_1_BASE:1.3
	OPENBSD_3_0:1.2.0.4
	OPENBSD_3_0_BASE:1.2
	OPENBSD_2_9_TRACKING_SWITCH:1.2
	OPENBSD_2_9:1.2.0.2
	OPENBSD_2_9_BASE:1.2
	pva48:1.1.1.1
	naddy:1.1.1;
locks; strict;
comment	@# @;


1.9
date	2014.09.17.14.37.23;	author espie;	state Exp;
branches;
next	1.8;
commitid	PhUYLzn0ooKpSSiK;

1.8
date	2014.07.08.10.15.39;	author sthen;	state Exp;
branches;
next	1.7;
commitid	emkuJHVWVl7fPz7Q;

1.7
date	2012.12.18.21.38.12;	author sthen;	state Exp;
branches;
next	1.6;

1.6
date	2012.12.06.22.30.22;	author sthen;	state Exp;
branches;
next	1.5;

1.5
date	2006.09.23.15.49.36;	author ckuethe;	state Exp;
branches;
next	1.4;

1.4
date	2004.08.12.09.33.10;	author claudio;	state Exp;
branches;
next	1.3;

1.3
date	2002.01.06.16.54.49;	author naddy;	state Exp;
branches;
next	1.2;

1.2
date	2001.04.14.02.38.31;	author naddy;	state Exp;
branches;
next	1.1;

1.1
date	2000.11.18.13.53.33;	author naddy;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2000.11.18.13.53.33;	author naddy;	state Exp;
branches;
next	;


desc
@@


1.9
log
@dkstat.h
@
text
@$OpenBSD: patch-wmmon_wmmon_c,v 1.8 2014/07/08 10:15:39 sthen Exp $
--- wmmon/wmmon.c.orig	Tue May 19 15:13:16 1998
+++ wmmon/wmmon.c	Wed Sep 17 08:36:25 2014
@@@@ -28,6 +28,10 @@@@
 	Changes:
 	----
 
+	28/09/2000 (Vladimir Popov, pva48@@mail.ru)
+		* Ported to OpenBSD
+		  Based on FreeBSD port by Stephen Kiernan,
+		  OpenBSD top and vmstat
 	18/05/1998 (Antoine Nulle, warp@@xs4all.nl)
 		* MEM/SWAP/UPTIME only updated when visible
 		* Using global file descriptors to reduce file
@@@@ -72,10 +76,22 @@@@
 #include <fcntl.h>
 #include <unistd.h>
 
+#include <errno.h>
+#include <signal.h>
+
 #include <sys/wait.h>
 #include <sys/param.h>
 #include <sys/types.h>
+#include <sys/proc.h>
+#include <sys/disk.h>
+#include <sys/sched.h>
+#include <sys/malloc.h>
+#include <sys/swap.h>
+#include <sys/sysctl.h>
+#include <sys/vmmeter.h>
 
+#include <limits.h>
+
 #include <X11/Xlib.h>
 #include <X11/xpm.h>
 #include <X11/extensions/shape.h>
@@@@ -100,11 +116,11 @@@@
  /* Global Variables */
 /********************/
 
-char	*ProgName;
 int	stat_current = 0; /* now global */
-FILE	*fp_meminfo;
-FILE	*fp_stat;
-FILE	*fp_loadavg;
+int	ndrives;
+int	pagesize;
+int	pageshift;
+char	errbuf[_POSIX2_LINE_MAX];
 
 /* functions */
 void usage(void);
@@@@ -114,17 +130,15 @@@@ void DrawStats_io(int *, int, int, int, int);
 
 void wmmon_routine(int, char **);
 
-void main(int argc, char *argv[]) {
+/* OpenBSD specific functions */
+#define	pagetok(size)	((size) << pageshift)
+int swapmode(long *, long *);
 
+int main(int argc, char *argv[])
+{
 	int		i;
-	
 
 	/* Parse Command Line */
-
-	ProgName = argv[0];
-	if (strlen(ProgName) >= 5)
-		ProgName += (strlen(ProgName) - 5);
-	
 	for (i=1; i<argc; i++) {
 		char *arg = argv[i];
 
@@@@ -155,22 +169,22 @@@@ void main(int argc, char *argv[]) {
 	}
 
 	wmmon_routine(argc, argv);
+
+	return 0;
 }
 
-/*******************************************************************************\
-|* wmmon_routine															   *|
-\*******************************************************************************/
+/***************************************************************************\
+|* wmmon_routine							   *|
+\***************************************************************************/
 
 typedef struct {
-
-	char	name[5];			/* "cpu0..cpuz", eventually.. :) */
-	int		his[55];
-	int		hisaddcnt;
+	char	name[5];	/* "cpu0..cpuz", eventually.. :) */
+	int	his[55];
+	int	hisaddcnt;
 	long	rt_stat;
 	long	statlast;
 	long	rt_idle;
 	long	idlelast;
-	
 } stat_dev;
 
 #define MAX_STAT_DEVICES (4)
@@@@ -182,7 +196,6 @@@@ char		*middle_action;
 
 
 int checksysdevs(void);
-void get_statistics(char *, long *, long *, long *);
 void DrawActive(char *);
 
 void update_stat_cpu(stat_dev *);
@@@@ -213,8 +226,9 @@@@ void wmmon_routine(int argc, char **argv) {
 	long		istat;
 	long		idle;
 
-	FILE		*fp;
-	char		temp[128];
+	int			mib[2];
+	size_t		size;
+	struct	timeval boottime;
 	char		*p;
 
 	int			xpm_X = 0, xpm_Y = 0;
@@@@ -223,22 +237,36 @@@@ void wmmon_routine(int argc, char **argv) {
 	long		ref_time = 0;
 	long		cnt_time;
 
+	mib[0] = CTL_KERN;
+	mib[1] = KERN_BOOTTIME;
+	size = sizeof(boottime);
+	if ( (sysctl(mib, 2, &boottime, &size, NULL, 0) != -1) && (boottime.tv_sec != 0) ) {
+		ref_time = time(NULL);
+		online_time = ref_time - boottime.tv_sec + 30;
+	}
 
-	fp = fopen("/proc/uptime", "r");
-	fp_meminfo = fopen("/proc/meminfo", "r");
-	fp_loadavg = fopen("/proc/loadavg", "r");
-	fp_stat = fopen("/proc/stat", "r");
+	/* get the page size and calculate pageshift from it */
+	pagesize = sysconf(_SC_PAGESIZE);
+	pageshift = 0;
+	while (pagesize > 1) {
+		pageshift++;
+		pagesize >>= 1;
+	}
 
-	if (fp) {
-		fscanf(fp, "%ld", &online_time);
-		ref_time = time(0);
-		fclose(fp);
+	/* we only need the amount of log(2)1024 for our conversion */
+	pageshift -= 10;
+
+	mib[0] = CTL_HW;
+	mib[1] = HW_DISKCOUNT;
+	size = sizeof(ndrives);
+	if (sysctl(mib, 2, &ndrives, &size, NULL, 0) < 0 ) {
+		warn("could not read hw.diskcount");
+		ndrives = 0;
 	}
 
 	for (i=0; i<MAX_STAT_DEVICES; i++) {
-		for (j=0; j<55; j++) {
+		for (j=0; j<55; j++)
 			stat_device[i].his[j] = 0;
-		}
 		stat_device[i].hisaddcnt = 0;
 	}
 
@@@@ -246,38 +274,40 @@@@ void wmmon_routine(int argc, char **argv) {
 	if (RIGHT_ACTION) right_action = strdup(RIGHT_ACTION);
 	if (MIDDLE_ACTION) middle_action = strdup(MIDDLE_ACTION);
 
-	strcpy(temp, "/etc/wmmonrc");
-	parse_rcfile(temp, wmmon_keys);
+	parse_rcfile("/etc/wmmonrc", wmmon_keys);
 
-	p = getenv("HOME");
-	strcpy(temp, p);
-	strcat(temp, "/.wmmonrc");
-	parse_rcfile(temp, wmmon_keys);
-	
-	strcpy(temp, "/etc/wmmonrc.fixed");
-	parse_rcfile(temp, wmmon_keys);
+	if ((p = getenv("HOME")) != NULL) {
+#define RCFILE "/.wmmonrc"
+		char *tmp;
 
-	stat_online = checksysdevs();
+		if (asprintf(&tmp, "%s" RCFILE, p) != -1) {
+			parse_rcfile(tmp, wmmon_keys);
+			free(tmp);
+		}
+	}
 
+	parse_rcfile("/etc/wmmonrc.fixed", wmmon_keys);
 
+	stat_online = checksysdevs();
+
 	openXwindow(argc, argv, wmmon_master_xpm, wmmon_mask_bits, wmmon_mask_width, wmmon_mask_height);
 
 	/* add mouse region */
 	AddMouseRegion(0, 12, 13, 58, 57);
 	AddMouseRegion(1, 5, 5, 24, 14);
 
-	starttime = time(0);
+	starttime = time(NULL);
 	nexttime = starttime + 10;
 
 	for (i=0; i<stat_online; i++) {
-		get_statistics(stat_device[i].name, &k, &istat, &idle);
-		stat_device[i].statlast = istat;
-		stat_device[i].idlelast = idle;
+		stat_device[i].statlast = 0;
+		stat_device[i].idlelast = 0;
 	}
-	if (stat_current == 0) DrawStats(stat_device[stat_current].his, 54, 40, 5, 58);
-	if (stat_current == 1) {
+	if (stat_current == 0)
+		DrawStats(stat_device[stat_current].his, 54, 40, 5, 58);
+	if (stat_current == 1)
 		DrawStats_io(stat_device[stat_current].his, 54, 40, 5, 58);
-	}
+
 	if (stat_current == 2) {
 		xpm_X = 64;
 		setMaskXY(-64, 0);
@@@@ -288,7 +318,7 @@@@ void wmmon_routine(int argc, char **argv) {
 	DrawActive(stat_device[stat_current].name);
 
 	while (1) {
-		curtime = time(0);
+		curtime = time(NULL);
 
 		waitpid(0, NULL, WNOHANG);
 
@@@@ -338,7 +368,7 @@@@ void wmmon_routine(int argc, char **argv) {
 
 			/*----------- online tijd neerzetten! ----------*/
 			
-			cnt_time = time(0) - ref_time + online_time;
+			cnt_time = time(NULL) - ref_time + online_time;
 
 			/* cnt_time = uptime in seconden */
 			/*
@@@@ -405,7 +435,6 @@@@ void wmmon_routine(int argc, char **argv) {
 			case DestroyNotify:
 				XCloseDisplay(display);
 				exit(0);
-				break;
 			case ButtonPress:
 				but_stat = CheckMouseRegion(Event.xbutton.x, Event.xbutton.y);
 				break;
@@@@ -430,7 +459,6 @@@@ void wmmon_routine(int argc, char **argv) {
 						}
 					case 1:
 						stat_current++;
-						printf("current stat is :%d\n", stat_current);
 						if (stat_current == stat_online)
 							stat_current = 0;
 
@@@@ -460,146 +488,116 @@@@ void wmmon_routine(int argc, char **argv) {
 
 void update_stat_cpu(stat_dev *st) {
 
-	long	k, istat, idle;
+	static int	sysload_mib[] = {CTL_VM, VM_LOADAVG};
+	static int	cp_time_mib[] = {CTL_KERN, KERN_CPTIME};
+	struct loadavg	sysload;
+	double		infoload;
+	size_t		size;
+	long		cp_time[CPUSTATES];
+	long		istat, idle;
+	int		i;
 
-	get_statistics(st->name, &k, &istat, &idle);
+	/* mostly stolen from src/usr.bin/top/machine.c */
+	size = sizeof(cp_time);
+	if (sysctl(cp_time_mib, 2, &cp_time, &size, NULL, 0) < 0)
+		warn("sysctl kern.cp_time failed");
 
+	size = sizeof(sysload);
+	if (sysctl(sysload_mib, 2, &sysload, &size, NULL, 0) < 0)
+		warn("sysctl failed");
+	infoload = ((double) sysload.ldavg[0]) / sysload.fscale;
+
+	for (i = 0, istat = 0; i < CPUSTATES; i++)
+		if (i != CP_IDLE) istat += cp_time[i];
+	idle = cp_time[CP_IDLE];
+
 	st->rt_idle = idle - st->idlelast;
 	st->idlelast = idle;
 
 	st->rt_stat = istat - st->statlast;
 	st->statlast = istat;
 
-	st->his[54] += k;
+	st->his[54] += (long)(100 * infoload);
 	st->hisaddcnt += 1;
 }
 
 void update_stat_io(stat_dev *st) {
 
-	long			j, k, istat, idle;
-	static long		maxdiskio = 0;
+	struct diskstats	*q;
+	static int		 io_mib[] = {CTL_HW, HW_DISKSTATS};
+	int			 mib[] = {CTL_HW, HW_DISKCOUNT};
+	static long		 maxdiskxfers = 0;
+	long			 xfers, rwstat;
+	size_t			 size;
+	int			 i;
 
-	get_statistics(st->name, &k, &istat, &idle);
+	size = sizeof(ndrives);
+	if (sysctl(mib, 2, &ndrives, &size, NULL, 0) < 0 ) {
+		warn("could not read hw.diskcount");
+		return;
+	}
 
-	st->rt_idle = idle - st->idlelast;
-	st->idlelast = idle;
-
-	st->rt_stat = istat - st->statlast;
-	st->statlast = istat;
-
-	j = st->rt_stat;
-	if (maxdiskio < j) {
-		maxdiskio = j;
+	size = ndrives * sizeof(struct diskstats);
+	q = malloc(size);
+	if (q == NULL)
+		err(1, NULL);
+	if (sysctl(io_mib, 2, q, &size, NULL, 0) < 0) {
+		warn("could not read hw.diskstats");
+		bzero(q, ndrives * sizeof(struct diskstats));
 	}
-	st->rt_idle = maxdiskio - j;
 
-	st->his[54] += st->rt_stat;
-	st->hisaddcnt += 1;
-}
-
-void update_stat_mem(stat_dev *st, stat_dev *st2) {
-
-	char	temp[128];
-	unsigned long free, shared, buffers, cached;
-
-	freopen("/proc/meminfo", "r", fp_meminfo);
-	while (fgets(temp, 128, fp_meminfo)) {
-		if (strstr(temp, "Mem:")) {
-			sscanf(temp, "Mem: %ld %ld %ld %ld %ld %ld",
-			       &st->rt_idle, &st->rt_stat,
-			       &free, &shared, &buffers, &cached);
-			st->rt_idle >>= 10;
-			st->rt_stat -= buffers+cached;
-			st->rt_stat >>= 10;
-//			break;
-		}
-		if (strstr(temp, "Swap:")) {
-			sscanf(temp, "Swap: %ld %ld", &st2->rt_idle, &st2->rt_stat);
-			st2->rt_idle >>= 10;
-			st2->rt_stat >>= 10;
-			break;
-		}
+	for (i = 0; i < ndrives; i++) {
+		rwstat += q[i].ds_rbytes + q[i].ds_wbytes;
+		xfers += q[i].ds_rxfer + q[i].ds_wxfer;
 	}
-}
+	free(q);
+	
+	if (st->statlast == 0)
+		st->statlast = xfers;
+	if (xfers < st->statlast)
+		xfers = st->statlast;
+	st->rt_stat = xfers - st->statlast;
+	st->statlast = xfers;
 
-void update_stat_swp(stat_dev *st) {
+	if (maxdiskxfers < st->rt_stat)
+		maxdiskxfers = st->rt_stat;
 
-	char	temp[128];
+	st->rt_idle = maxdiskxfers - st->rt_stat;
+	st->idlelast = 0;
 
-	fseek(fp_meminfo, 0, SEEK_SET);
-	while (fgets(temp, 128, fp_meminfo)) {
-		if (strstr(temp, "Swap:")) {
-			sscanf(temp, "Swap: %ld %ld", &st->rt_idle, &st->rt_stat);
-			st->rt_idle >>= 10;
-			st->rt_stat >>= 10;
-			break;
-		}
-	}
-
+	st->his[54] += rwstat;
+	st->hisaddcnt += 1;
 }
 
-/*******************************************************************************\
-|* get_statistics															   *|
-\*******************************************************************************/
+void update_stat_mem(stat_dev *st, stat_dev *st2) {
 
-void get_statistics(char *devname, long *is, long *ds, long *idle) {
+	struct vmtotal total;
+	size_t size = sizeof(total);
+	static int mib[] = { CTL_VM, VM_METER };
 
-	int	i;
-	char	temp[128];
-	char	*p;
-	char	*tokens = " \t\n";
-	float	f;
-	long	maxdiskio=0;
+	/* get total -- systemwide main memory usage structure */
+	if ( sysctl(mib, 2, &total, &size, NULL, 0) < 0 )
+		bzero(&total, sizeof(total));
 
-	*is = 0;
-	*ds = 0;
-	*idle = 0;
+	/* FIXME: is it right to count memory like this */
+	st->rt_idle = pagetok(total.t_rm + total.t_free);
+	st->rt_stat = pagetok(total.t_rm);
 
-	if (!strncmp(devname, "cpu", 3)) {
-		fseek(fp_stat, 0, SEEK_SET);
-		while (fgets(temp, 128, fp_stat)) {
-			if (strstr(temp, "cpu")) {
-				p = strtok(temp, tokens);
-				/* 1..3, 4 == idle, we don't want idle! */
-				for (i=0; i<3; i++) {
-					p = strtok(NULL, tokens);
-					*ds += atol(p);
-				}
-				p = strtok(NULL, tokens);
-				*idle = atol(p);
-			}
-		}
-		fp_loadavg = freopen("/proc/loadavg", "r", fp_loadavg);
-		fscanf(fp_loadavg, "%f", &f);
-		*is = (long) (100 * f);
+	if ( !swapmode(&st2->rt_stat, &st2->rt_idle) ) {
+		st2->rt_idle = 0;
+		st2->rt_stat = 0;
 	}
-
-	if (!strncmp(devname, "i/o", 3)) {
-
-		fseek(fp_stat, 0, SEEK_SET);
-		while (fgets(temp, 128, fp_stat)) {
-			if (strstr(temp, "disk_rio") || strstr(temp, "disk_wio")) {
-				p = strtok(temp, tokens);
-				/* 1..4 */
-				for (i=0; i<4; i++) {
-					p = strtok(NULL, tokens);
-					*ds += atol(p);
-				}
-			}
-		}
-		if (*ds > maxdiskio) maxdiskio = *ds;
-	}
 }
 
-/*******************************************************************************\
-|* checksysdevs																   *|
-\*******************************************************************************/
+/***************************************************************************\
+|* checksysdevs								   *|
+\***************************************************************************/
 
 int checksysdevs(void) {
 
-	strcpy(stat_device[0].name, "cpu0");
-	strcpy(stat_device[1].name, "i/o");
-	strcpy(stat_device[2].name, "sys");
+	strncpy(stat_device[0].name, "cpu0", 5);
+	strncpy(stat_device[1].name, "i/o", 5);
+	strncpy(stat_device[2].name, "sys", 5);
 
 	return 3;
 }
@@@@ -733,7 +731,35 @@@@ void usage(void) {
 
 void printversion(void) {
 
-	if (!strcmp(ProgName, "wmmon")) {
-		fprintf(stderr, "%s\n", WMMON_VERSION);
-	}
+	fprintf(stderr, "%s\n", WMMON_VERSION);
+}
+
+int swapmode(long *used, long *total) {
+	int nswap, rnswap, i;
+	struct swapent *swdev;
+
+	nswap = swapctl(SWAP_NSWAP, 0, 0);
+	if (nswap == 0) 
+		return 0;
+
+	swdev = malloc(nswap * sizeof(*swdev));
+	if(swdev == NULL)
+		return 0;
+
+	rnswap = swapctl(SWAP_STATS, swdev, nswap);
+	if(rnswap == -1)
+		return 0;
+
+	/* if rnswap != nswap, then what? */
+
+	/* Total things up */
+	*total = *used = 0;
+	for (i = 0; i < nswap; i++)
+		if (swdev[i].se_flags & SWF_ENABLE) {
+			*used += (swdev[i].se_inuse / (1024/DEV_BSIZE));
+			*total += (swdev[i].se_nblks / (1024/DEV_BSIZE));
+		}
+
+	free (swdev);
+	return 1;
 }
@


1.8
log
@add sys/vmmeter.h / sys/sysctl.h where they will be needed
@
text
@d1 3
a3 3
$OpenBSD: patch-wmmon_wmmon_c,v 1.7 2012/12/18 21:38:12 sthen Exp $
--- wmmon/wmmon.c.orig	Tue May 19 22:13:16 1998
+++ wmmon/wmmon.c	Tue Jul  8 11:14:42 2014
d27 1
a27 1
+#include <sys/dkstat.h>
@


1.7
log
@cope with sysctl.h changes
@
text
@d1 3
a3 3
$OpenBSD: patch-wmmon_wmmon_c,v 1.5 2006/09/23 15:49:36 ckuethe Exp $
--- wmmon/wmmon.c.orig	Tue May 19 15:13:16 1998
+++ wmmon/wmmon.c	Thu Dec  6 15:29:36 2012
d15 1
a15 1
@@@@ -72,10 +76,21 @@@@
d31 1
d38 1
a38 1
@@@@ -100,11 +115,11 @@@@
d54 1
a54 1
@@@@ -114,17 +129,15 @@@@ void DrawStats_io(int *, int, int, int, int);
d77 1
a77 1
@@@@ -155,22 +168,22 @@@@ void main(int argc, char *argv[]) {
d108 1
a108 1
@@@@ -182,7 +195,6 @@@@ char		*middle_action;
d116 1
a116 1
@@@@ -213,8 +225,9 @@@@ void wmmon_routine(int argc, char **argv) {
d128 1
a128 1
@@@@ -223,22 +236,36 @@@@ void wmmon_routine(int argc, char **argv) {
d175 1
a175 1
@@@@ -246,38 +273,40 @@@@ void wmmon_routine(int argc, char **argv) {
d233 1
a233 1
@@@@ -288,7 +317,7 @@@@ void wmmon_routine(int argc, char **argv) {
d242 1
a242 1
@@@@ -338,7 +367,7 @@@@ void wmmon_routine(int argc, char **argv) {
d251 1
a251 1
@@@@ -405,7 +434,6 @@@@ void wmmon_routine(int argc, char **argv) {
d259 1
a259 1
@@@@ -430,7 +458,6 @@@@ void wmmon_routine(int argc, char **argv) {
d267 1
a267 1
@@@@ -460,146 +487,116 @@@@ void wmmon_routine(int argc, char **argv) {
d491 1
a491 1
@@@@ -733,7 +730,35 @@@@ void usage(void) {
@


1.6
log
@sync patches
@
text
@d2 2
a3 2
--- wmmon/wmmon.c.orig	Tue May 19 22:13:16 1998
+++ wmmon/wmmon.c	Thu Dec  6 22:30:02 2012
d15 1
a15 1
@@@@ -72,10 +76,20 @@@@
d25 1
a25 2
 
+#include <limits.h>
d31 2
d37 1
a37 1
@@@@ -100,11 +114,11 @@@@
d53 1
a53 1
@@@@ -114,17 +128,15 @@@@ void DrawStats_io(int *, int, int, int, int);
d76 1
a76 1
@@@@ -155,22 +167,22 @@@@ void main(int argc, char *argv[]) {
d107 1
a107 1
@@@@ -182,7 +194,6 @@@@ char		*middle_action;
d115 1
a115 1
@@@@ -213,8 +224,9 @@@@ void wmmon_routine(int argc, char **argv) {
d127 1
a127 1
@@@@ -223,22 +235,36 @@@@ void wmmon_routine(int argc, char **argv) {
d174 1
a174 1
@@@@ -246,38 +272,40 @@@@ void wmmon_routine(int argc, char **argv) {
d232 1
a232 1
@@@@ -288,7 +316,7 @@@@ void wmmon_routine(int argc, char **argv) {
d241 1
a241 1
@@@@ -338,7 +366,7 @@@@ void wmmon_routine(int argc, char **argv) {
d250 1
a250 1
@@@@ -405,7 +433,6 @@@@ void wmmon_routine(int argc, char **argv) {
d258 1
a258 1
@@@@ -430,7 +457,6 @@@@ void wmmon_routine(int argc, char **argv) {
d266 1
a266 1
@@@@ -460,146 +486,116 @@@@ void wmmon_routine(int argc, char **argv) {
d490 1
a490 1
@@@@ -733,7 +729,35 @@@@ void usage(void) {
@


1.5
log
@When removable devices like USB disks are connected or disconnected, wmmon
will spin and complain that it is unable to allocate memory for diskstats.
This patch fixes that.
ok steven
@
text
@d1 3
a3 3
$OpenBSD: patch-wmmon_wmmon_c,v 1.4 2004/08/12 09:33:10 claudio Exp $
--- wmmon/wmmon.c.orig	Tue May 19 15:13:16 1998
+++ wmmon/wmmon.c	Sat Sep 23 09:43:02 2006
d52 1
a52 1
@@@@ -114,17 +128,15 @@@@ void DrawStats_io(int *, int, int, int, 
d114 1
a114 1
@@@@ -213,8 +224,9 @@@@ void wmmon_routine(int argc, char **argv
d126 1
a126 1
@@@@ -223,22 +235,36 @@@@ void wmmon_routine(int argc, char **argv
d173 1
a173 1
@@@@ -246,38 +272,40 @@@@ void wmmon_routine(int argc, char **argv
d231 1
a231 1
@@@@ -288,7 +316,7 @@@@ void wmmon_routine(int argc, char **argv
d240 1
a240 1
@@@@ -338,7 +366,7 @@@@ void wmmon_routine(int argc, char **argv
d249 1
a249 1
@@@@ -405,7 +433,6 @@@@ void wmmon_routine(int argc, char **argv
d257 1
a257 1
@@@@ -430,7 +457,6 @@@@ void wmmon_routine(int argc, char **argv
d265 1
a265 1
@@@@ -460,146 +486,116 @@@@ void wmmon_routine(int argc, char **argv
@


1.4
log
@Fix wmmon to show again the correct cpu usage. I rewrote most of the patch and
now wmmon uses sysctl to get all stats and is therefor no longer setgid kmem.
Tested by tdeval
OK pval
@
text
@d1 3
a3 3
$OpenBSD: patch-wmmon_wmmon_c,v 1.3 2002/01/06 16:54:49 naddy Exp $
--- wmmon/wmmon.c.orig	1998-05-19 23:12:55.000000000 +0200
+++ wmmon/wmmon.c	2004-07-28 16:09:09.000000000 +0200
a129 10
-
-	fp = fopen("/proc/uptime", "r");
-	fp_meminfo = fopen("/proc/meminfo", "r");
-	fp_loadavg = fopen("/proc/loadavg", "r");
-	fp_stat = fopen("/proc/stat", "r");
-
-	if (fp) {
-		fscanf(fp, "%ld", &online_time);
-		ref_time = time(0);
-		fclose(fp);
d137 5
a141 1
+
d149 5
a153 1
+
d173 1
a173 1
@@@@ -246,19 +272,21 @@@@ void wmmon_routine(int argc, char **argv
d200 2
a202 2
+	stat_online = checksysdevs();
 
d205 1
a205 1
@@@@ -266,18 +294,18 @@@@ void wmmon_routine(int argc, char **argv
d265 1
a265 1
@@@@ -460,9 +486,28 @@@@ void wmmon_routine(int argc, char **argv
d284 1
a284 1
+
d293 1
a293 1
 
d296 1
a296 1
@@@@ -470,136 +515,80 @@@@ void update_stat_cpu(stat_dev *st) {
a308 5
-
-	get_statistics(st->name, &k, &istat, &idle);
-
-	st->rt_idle = idle - st->idlelast;
-	st->idlelast = idle;
d311 1
d316 17
a332 1
+
d340 1
a340 24
+	}
+
+	for (i = 0; i < ndrives; i++) {
+		rwstat += q[i].ds_rbytes + q[i].ds_wbytes;
+		xfers += q[i].ds_rxfer + q[i].ds_wxfer;
+	}
+	free(q);
+	
+	if (st->statlast == 0)
+		st->statlast = xfers;
+	if (xfers < st->statlast)
+		xfers = st->statlast;
+	st->rt_stat = xfers - st->statlast;
+	st->statlast = xfers;
 
-	st->rt_stat = istat - st->statlast;
-	st->statlast = istat;
+	if (maxdiskxfers < st->rt_stat)
+		maxdiskxfers = st->rt_stat;
 
-	j = st->rt_stat;
-	if (maxdiskio < j) {
-		maxdiskio = j;
-	}
a341 2
+	st->rt_idle = maxdiskxfers - st->rt_stat;
+	st->idlelast = 0;
d344 5
a348 6
+	st->his[54] += rwstat;
 	st->hisaddcnt += 1;
 }
 
 void update_stat_mem(stat_dev *st, stat_dev *st2) {
 
d351 1
a351 4
+	struct vmtotal total;
+	size_t size = sizeof(total);
+	static int mib[] = { CTL_VM, VM_METER };
 
d369 4
a372 1
-	}
d374 9
a382 1
-
d384 3
a386 1
-
d388 3
a390 1
-
d401 4
a404 2
-}
-
d408 1
a408 3
+	/* get total -- systemwide main memory usage structure */
+	if ( sysctl(mib, 2, &total, &size, NULL, 0) < 0 )
+		bzero(&total, sizeof(total));
d411 4
a414 1
-
d421 4
a424 1
-
d428 4
a431 1
-
d449 5
a453 5
-	}
+	/* FIXME: is it right to count memory like this */
+	st->rt_idle = pagetok(total.t_rm + total.t_free);
+	st->rt_stat = pagetok(total.t_rm);
 
d468 1
a468 4
+	if ( !swapmode(&st2->rt_stat, &st2->rt_idle) ) {
+		st2->rt_idle = 0;
+		st2->rt_stat = 0;
 	}
d489 1
a489 1
@@@@ -733,7 +722,35 @@@@ void usage(void) {
@


1.3
log
@fix from Seiichi SATO <ssato@@sh.rim.or.jp>, through maintainer
@
text
@d1 3
a3 3
$OpenBSD: patch-wmmon_wmmon_c,v 1.2 2001/04/14 02:38:31 naddy Exp $
--- wmmon/wmmon.c.orig	Wed May 20 03:13:16 1998
+++ wmmon/wmmon.c	Thu Apr  5 23:52:44 2001
d15 1
a15 1
@@@@ -72,10 +76,22 @@@@
a25 1
+#include <kvm.h>
a26 1
+#include <nlist.h>
d36 3
a38 1
@@@@ -102,9 +118,28 @@@@
d40 1
a40 1
 char	*ProgName;
d45 4
a48 22
+kvm_t *kd = NULL;
+struct nlist nlst[] = {
+#define X_CP_TIME		0
+	{ "_cp_time" },
+#define X_AVERUN		1
+	{ "_averunnable" },
+#define X_DISK_COUNT	2
+	{ "_disk_count" },
+#define X_DISKLIST		3
+	{ "_disklist" },
+#define X_KMEMBUCKETS	4
+	{ "_bucket" },
+#define X_KMEMSTAT		5
+	{ "_kmemstats" },
+	{ 0 }
+};
+int ndrives;
+struct disklist_head disk_head;
+struct disk *dk_drivehead;
+static int pagesize;
+static int pageshift;
+char errbuf[_POSIX2_LINE_MAX];
d52 1
a52 1
@@@@ -114,7 +149,11 @@@@ void DrawStats_io(int *, int, int, int, 
a59 2
+
+int main(int argc, char *argv[]) {
d61 2
d64 12
a75 3
 	
@@@@ -154,7 +193,11 @@@@ void main(int argc, char *argv[]) {
 		}
a77 2
+	signal(SIGPIPE, exit);
+
d83 32
a114 2
 /*******************************************************************************\
@@@@ -213,8 +256,9 @@@@ void wmmon_routine(int argc, char **argv
d126 1
a126 1
@@@@ -223,22 +267,58 @@@@ void wmmon_routine(int argc, char **argv
d130 10
d159 6
a164 37
+	if ((kd = kvm_openfiles(NULL, NULL, NULL, O_RDONLY, errbuf)) == NULL) {
+		fprintf(stderr, "kvm_openfiles: %s\n", errbuf);
+		exit(errno);
+	}
+
+	/* drop privs */
+	setegid(getgid());
+	setgid(getgid());
+	
+	if (kd) {
+		if (kvm_nlist(kd, nlst) >= 0) {
+			int i;
+			for ( i = 0; nlst[i].n_name == NULL; i++)
+				if (nlst[i].n_type == 0) {
+					/* this one wasn't found */
+					(void) fprintf(stderr, "kernel: no symbol named `%s'\n", nlst[i].n_name);
+					kvm_close(kd);
+					exit(-1);
+				}
 
-	fp = fopen("/proc/uptime", "r");
-	fp_meminfo = fopen("/proc/meminfo", "r");
-	fp_loadavg = fopen("/proc/loadavg", "r");
-	fp_stat = fopen("/proc/stat", "r");
-
-	if (fp) {
-		fscanf(fp, "%ld", &online_time);
-		ref_time = time(0);
-		fclose(fp);
+			if (nlst[0].n_type != 0) {
+				(void) kvm_read(kd, nlst[X_DISK_COUNT].n_value, (char *)&ndrives, sizeof(ndrives));
+				if ( ndrives > 0 ) {
+					kvm_read(kd, nlst[X_DISKLIST].n_value, &disk_head, sizeof(disk_head));
+					dk_drivehead = disk_head.tqh_first;
+				}
+			}
+		} else fprintf(stderr, "kvm_nlist: %s\n", kvm_geterr(kd));
d175 1
a175 1
@@@@ -246,19 +326,22 @@@@ void wmmon_routine(int argc, char **argv
d192 4
a195 4
+		int tmpsize = strlen(p) + sizeof(RCFILE) + 1;
+		char *tmp = malloc(tmpsize);
+		if (tmp != NULL) {
+			snprintf(tmp, tmpsize, "%s" RCFILE, p);
a200 1
-	stat_online = checksysdevs();
d202 1
a202 1
 
d207 1
a207 1
@@@@ -266,7 +349,7 @@@@ void wmmon_routine(int argc, char **argv
d216 18
a233 1
@@@@ -288,7 +371,7 @@@@ void wmmon_routine(int argc, char **argv
d242 1
a242 1
@@@@ -338,7 +421,7 @@@@ void wmmon_routine(int argc, char **argv
d251 1
a251 3
@@@@ -403,9 +486,9 @@@@ void wmmon_routine(int argc, char **argv
 				RedrawWindowXY(xpm_X, xpm_Y);
 				break;
a252 1
+				if (kd) kvm_close(kd);
d259 1
a259 1
@@@@ -430,7 +513,6 @@@@ void wmmon_routine(int argc, char **argv
d267 95
a361 1
@@@@ -499,43 +581,22 @@@@ void update_stat_io(stat_dev *st) {
d367 4
a370 1
-
d403 7
a409 4
+	struct vmtotal total;
+	size_t size = sizeof(total);
+	static int mib[] = { CTL_VM, VM_METER };
+
d413 2
a414 9
+
+	/* FIXME: is it right to count memory like this */
+	st->rt_idle = pagetok(total.t_rm + total.t_free);
+	st->rt_stat = pagetok(total.t_rm);
+
+	if ( !swapmode(&st2->rt_stat, &st2->rt_idle) ) {
+		st2->rt_idle = 0;
+		st2->rt_stat = 0;
 	}
d416 1
a416 7
 }
 
 /*******************************************************************************\
@@@@ -545,48 +606,41 @@@@ void update_stat_swp(stat_dev *st) {
 void get_statistics(char *devname, long *is, long *ds, long *idle) {
 
 	int	i;
d421 6
a426 8
+	long	averun[3];
+	long	cp_time[CPUSTATES];
 	long	maxdiskio=0;
 
 	*is = 0;
 	*ds = 0;
 	*idle = 0;
 
d445 3
a447 26
+	if (!strncmp(devname, "cpu", 3))
+		if (kd)
+			if (kvm_nlist(kd, nlst) >= 0)
+				if (nlst[0].n_type != 0)
+					if ((kvm_read(kd, nlst[X_CP_TIME].n_value, (char *)&cp_time, sizeof(cp_time))==sizeof(cp_time)) &&
+							(kvm_read(kd, nlst[X_AVERUN].n_value, (char *)&averun, sizeof(averun))==sizeof(averun))) {
+						*is = (long) (100 * ((double)averun[0] / FSCALE));
+
+						for (i = 0; i < CPUSTATES; i++)
+							if (i != CP_IDLE) *ds += cp_time[i];
+						*idle = cp_time[CP_IDLE];
+					}
 
 	if (!strncmp(devname, "i/o", 3)) {
+		struct disk     cur_disk, *p;
+
+		p = dk_drivehead;
+
+		if (kd)
+			if (kvm_nlist(kd, nlst) >= 0)
+				if (nlst[0].n_type != 0)
+					for (i = 0; i < ndrives; i++)
+						if ( kvm_read(kd, (u_long)p, &cur_disk, sizeof(cur_disk)) == sizeof(cur_disk) ) {
+							*ds += cur_disk.dk_seek;
+							p = cur_disk.dk_link.tqe_next;
+						}
d449 2
d462 4
a465 1
 		if (*ds > maxdiskio) maxdiskio = *ds;
d468 7
a474 1
@@@@ -597,9 +651,9 @@@@ void get_statistics(char *devname, long 
d487 8
a494 4
@@@@ -736,4 +790,34 @@@@ void printversion(void) {
 	if (!strcmp(ProgName, "wmmon")) {
 		fprintf(stderr, "%s\n", WMMON_VERSION);
 	}
@


1.2
log
@1. Integrate COMMENT, new NEED_VERSION
2. General cleanup in wmmon/wmmon.c
3. If you have root privs and exit, you'll get "Broken pipe". This occurs
upon execution of XCloseDisplay() (which followed by exit(0)). Handle it
with signal(SIGPIPE, exit).

Submitted by maintainer.
@
text
@d1 1
a1 1
$OpenBSD: patch-wmmon_wmmon_c,v 1.1.1.1 2000/11/18 13:53:33 naddy Exp $
d304 2
a305 2
+	st->rt_idle = pagetok(total.t_rm);
+	st->rt_stat = pagetok(total.t_arm);
@


1.1
log
@Initial revision
@
text
@d1 3
a3 3
$OpenBSD$
--- wmmon/wmmon.c.orig	Tue May 19 23:13:16 1998
+++ wmmon/wmmon.c	Tue Oct 10 21:59:35 2000
d15 1
a15 1
@@@@ -72,10 +76,21 @@@@
d20 1
d38 1
a38 1
@@@@ -102,9 +117,28 @@@@
d70 1
a70 1
@@@@ -114,7 +148,12 @@@@ void DrawStats_io(int *, int, int, int, 
a77 1
+int check_nlist(struct nlist *nlst);
d83 2
a84 1
@@@@ -155,6 +194,8 @@@@ void main(int argc, char *argv[]) {
d87 2
d95 1
a95 1
@@@@ -213,8 +254,9 @@@@ void wmmon_routine(int argc, char **argv
d107 1
a107 1
@@@@ -223,16 +265,57 @@@@ void wmmon_routine(int argc, char **argv
d122 1
a122 2
+	while (pagesize > 1)
+	{
d141 8
a148 5
+
+			if ( check_nlist(nlst) > 0 ) {
+				kvm_close(kd);
+				exit(-1);
+			}
d166 1
a166 7
+
+			//fprintf (stderr, "Monitoring %d devices for activity.\n", ndrives);
+
+		}
+		else {
+			fprintf(stderr, "kvm_nlist: %s\n", kvm_geterr(kd));
+		}
d170 8
a177 1
@@@@ -246,16 +329,20 @@@@ void wmmon_routine(int argc, char **argv
d202 2
a203 1
+
d206 1
a206 1
 	stat_online = checksysdevs();
d208 3
a210 1
@@@@ -266,7 +353,7 @@@@ void wmmon_routine(int argc, char **argv
d219 1
a219 1
@@@@ -288,7 +375,7 @@@@ void wmmon_routine(int argc, char **argv
d228 1
a228 1
@@@@ -338,7 +425,7 @@@@ void wmmon_routine(int argc, char **argv
d237 2
a238 1
@@@@ -404,7 +491,8 @@@@ void wmmon_routine(int argc, char **argv
d241 1
d243 2
a244 4
-				exit(0);
+				if (kd) kvm_close(kd);
+				return;
 				break;
d247 10
a256 1
@@@@ -499,43 +587,24 @@@@ void update_stat_io(stat_dev *st) {
d300 1
a300 2
+	if ( sysctl(mib, 2, &total, &size, NULL, 0) < 0 ) {
+		fprintf(stderr, "sysctl failed");
a301 1
+	}
d315 1
a315 1
@@@@ -545,10 +614,8 @@@@ void update_stat_swp(stat_dev *st) {
d328 1
a328 1
@@@@ -556,34 +623,37 @@@@ void get_statistics(char *devname, long 
d331 1
a331 1
 	if (!strncmp(devname, "cpu", 3)) {
d340 13
a352 3
+		if (kd) {
+			if (kvm_nlist(kd, nlst) >= 0) {
+				if (nlst[0].n_type != 0) {
d357 1
a357 1
+						for (i = 0; i < CPUSTATES; i++) {
a358 1
+						}
a360 9
 				}
-				p = strtok(NULL, tokens);
-				*idle = atol(p);
 			}
 		}
-		fp_loadavg = freopen("/proc/loadavg", "r", fp_loadavg);
-		fscanf(fp_loadavg, "%f", &f);
-		*is = (long) (100 * f);
 	}
d366 9
d384 7
a390 13
+		if (kd) {
+			if (kvm_nlist(kd, nlst) >= 0) {
+				if (nlst[0].n_type != 0) {
+					for (i = 0; i < ndrives; i++) {
+						if ( kvm_read(kd, (u_long)p, &cur_disk, sizeof(cur_disk)) == sizeof(cur_disk) ) {
+							*ds += cur_disk.dk_seek;
+							p = cur_disk.dk_link.tqe_next;
+						}
+					}
 				}
 			}
 		}
@@@@ -597,9 +667,9 @@@@ void get_statistics(char *devname, long 
d403 2
a404 1
@@@@ -737,3 +807,59 @@@@ void printversion(void) {
d407 1
a407 1
 }
d429 1
a429 1
+	for (i = 0; i < nswap; i++) {
a433 1
+	}
d437 1
a437 26
+}
+
+int check_nlist(struct nlist *nlst)
+{
+	register int i;
+
+	/* check to see if we got ALL the symbols we requested */
+	/* this will write one line to stderr for every symbol not found */
+
+	i = 0;
+	while (nlst->n_name != NULL)
+	{
+		if (nlst->n_type == 0)
+		{
+			/* this one wasn't found */
+			(void) fprintf(stderr, "kernel: no symbol named `%s'\n", nlst->n_name);
+
+			i = 1;
+		}
+		nlst++;
+	}
+
+	return(i);
+}
+
+/* vim:ts=4:sw=4: */
@


1.1.1.1
log
@Initial import of wmmon-1.0b2.

WMMon monitors the realtime CPU load as well the average
system load and gives you some nice additional features too.
@
text
@@
