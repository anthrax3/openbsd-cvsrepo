head	1.6;
access;
symbols
	OPENBSD_5_8:1.5.0.6
	OPENBSD_5_8_BASE:1.5
	OPENBSD_5_7:1.5.0.2
	OPENBSD_5_7_BASE:1.5
	OPENBSD_5_6:1.4.0.4
	OPENBSD_5_6_BASE:1.4
	OPENBSD_5_5:1.4.0.2
	OPENBSD_5_5_BASE:1.4
	OPENBSD_5_4:1.3.0.34
	OPENBSD_5_4_BASE:1.3
	OPENBSD_5_3:1.3.0.32
	OPENBSD_5_3_BASE:1.3
	OPENBSD_5_2:1.3.0.30
	OPENBSD_5_2_BASE:1.3
	OPENBSD_5_1_BASE:1.3
	OPENBSD_5_1:1.3.0.28
	OPENBSD_5_0:1.3.0.26
	OPENBSD_5_0_BASE:1.3
	OPENBSD_4_9:1.3.0.24
	OPENBSD_4_9_BASE:1.3
	OPENBSD_4_8:1.3.0.22
	OPENBSD_4_8_BASE:1.3
	OPENBSD_4_7:1.3.0.20
	OPENBSD_4_7_BASE:1.3
	OPENBSD_4_6:1.3.0.18
	OPENBSD_4_6_BASE:1.3
	OPENBSD_4_5:1.3.0.16
	OPENBSD_4_5_BASE:1.3
	OPENBSD_4_4:1.3.0.14
	OPENBSD_4_4_BASE:1.3
	OPENBSD_4_3:1.3.0.12
	OPENBSD_4_3_BASE:1.3
	OPENBSD_4_2:1.3.0.10
	OPENBSD_4_2_BASE:1.3
	OPENBSD_4_1:1.3.0.8
	OPENBSD_4_1_BASE:1.3
	OPENBSD_4_0:1.3.0.6
	OPENBSD_4_0_BASE:1.3
	OPENBSD_3_9:1.3.0.4
	OPENBSD_3_9_BASE:1.3
	OPENBSD_3_8:1.3.0.2
	OPENBSD_3_8_BASE:1.3
	OPENBSD_3_7:1.2.0.4
	OPENBSD_3_7_BASE:1.2
	OPENBSD_3_6:1.2.0.2
	OPENBSD_3_6_BASE:1.2
	OPENBSD_3_5:1.1.0.14
	OPENBSD_3_5_BASE:1.1
	OPENBSD_3_4:1.1.0.12
	OPENBSD_3_4_BASE:1.1
	OPENBSD_3_3:1.1.0.10
	OPENBSD_3_3_BASE:1.1
	OPENBSD_3_2:1.1.0.8
	OPENBSD_3_2_BASE:1.1
	OPENBSD_3_1:1.1.0.6
	OPENBSD_3_1_BASE:1.1
	OPENBSD_3_0:1.1.0.4
	OPENBSD_3_0_BASE:1.1
	OPENBSD_2_9_TRACKING_SWITCH:1.1
	OPENBSD_2_9:1.1.0.2
	OPENBSD_2_9_BASE:1.1;
locks; strict;
comment	@# @;


1.6
date	2015.08.25.11.16.28;	author jca;	state dead;
branches;
next	1.5;
commitid	ZYz3xUSOJVyi0xdm;

1.5
date	2014.11.19.20.48.00;	author sthen;	state Exp;
branches;
next	1.4;
commitid	bipTG7olNPZwDodg;

1.4
date	2013.11.30.20.47.49;	author jca;	state Exp;
branches;
next	1.3;

1.3
date	2005.04.07.20.23.44;	author sturm;	state Exp;
branches;
next	1.2;

1.2
date	2004.06.15.18.32.22;	author sturm;	state Exp;
branches;
next	1.1;

1.1
date	2001.03.17.15.46.39;	author wilfried;	state Exp;
branches;
next	;


desc
@@


1.6
log
@Remove security/cfs.  Unmaintained code, broken on 64 bits archs.

softraid CRYPTO, vnconfig and security/encfs provide much saner
alternatives.

ok tedu@@ steven@@ ajacoutot@@ sthen@@
@
text
@--- cfs_fh.c.orig	Thu May  3 12:24:59 2001
+++ cfs_fh.c	Wed Nov 19 13:42:46 2014
@@@@ -33,6 +33,7 @@@@
 #include <rpc/rpc.h>
 #include <fcntl.h>
 #include <stdio.h>
+#include <unistd.h>
 #ifdef hpux
 #define NO_UTIMES
 #include <time.h>
@@@@ -177,6 +178,13 @@@@ writeblock(blk,fd,offset,len,key,vect)
 		perror("write");
 		return -1;
 	}
+	/* due to the way the file is padded we may actually have to
+	   truncate it here. This happens when the write is at the end of
+	   the file, is shorter than CFSBLOCK and brings the file to a length
+	   which is evenly dividable by CFSBLOCK */
+	if (offset+len > dtov(sb.st_size) && vtod(offset+len) < sb.st_size) {
+		ftruncate(fd, vtod(offset+len));
+	}
 	/* iolen may contain CFSBLOCK extra chars */
 	return(dtov(iolen)-fronterr);
 }
@@@@ -195,30 +203,39 @@@@ encryptname(key,s)
      char *s;
 {
 	static char cryptname[NFS_MAXNAMLEN+1];
+	static const u_char hexdigit[16] = {
+		'0', '1', '2', '3', '4', '5', '6', '7',
+		'8', '9', 'a', 'b', 'c', 'd', 'e', 'f'
+	};
 	u_char cryptstring[MAXCLEARNAME+CFSBLOCK+1];
-	u_char x[3];
 	u_long l;
-	int i;
+	int i, j;
 
 	if ((s==NULL) || ((l=strlen(s)+1)>MAXCLEARNAME))
 		return NULL;
 	if (!strcmp(s,".") || !strcmp(s,".."))
 		return s;
 	l=(l+(CFSBLOCK-1)) & (~(CFSBLOCK-1));
+	if (l >= (sizeof(cryptname) >> 1))
+		return NULL;
 	bzero((char *)cryptstring,l);
 	strcpy(cryptstring,s);
 	chksum(cryptstring,l);
 	doencrypt(key,cryptstring,l,10241,zerovect);
-	cryptname[0]='\0';
+	j = 0;
 	for (i=0; i<l; i++) {
-		sprintf((char *)x,"%02x",cryptstring[i]);
-		strcat(cryptname,x);
+		u_char b = cryptstring[i];
+		cryptname[j++] = hexdigit[(b >> 4) & 15];
+		cryptname[j++] = hexdigit[b & 15];
 	}
+	cryptname[j] = '\0';
 	return cryptname;
 }
 
 /*
- * set high order bits
+ * Carefully frob the high order bits of s in a way that is both easily
+ * reversible (see unchksum) and backwards-compatible (at least for 7-bit
+ * characters).
  */
 chksum(s,l)
      char *s;
@@@@ -229,17 +246,47 @@@@ chksum(s,l)
 	u_char bits[8];
 
 	acc=0;
-	for (i=0; s[i]!='\0'; i++)
-		acc += s[i]*((i%6)+1);
+	/* Everything we do here must be reproducible without knowledge of
+	   bit 7 because unchksum won't have that information.  Therefore,
+	   only accumulate the lower 7 bits of each char and stop at the
+	   first occurrence of either 0x00 or 0x80.  Note that, for inputs
+	   with bit 7 constantly zero, this is equivalent to looking at the
+	   whole string. */
+	for (i=0; (s[i]&0x7f) != '\0'; i++)
+		acc += (s[i]&0x7f)*((i%6)+1);
+	for (; s[i]!='\0'; i++) /* advance i if we stopped at a 0x80 */
+		;
 	for (i++; i<l; i++)	/* fill up the end */
 		s[i] = s[i%8];
 	for (i=0; i<8; i++)
 		bits[i] = (acc<<(i%8))&0x80;
 	for (i=0; i<l; i++)
-		s[i] |= bits[i%8];
+		s[i] ^= bits[i%8];
 }
 
+void
+unchksum(s,l)
+     char *s;
+     long l;
+{
+	u_long acc;
+	int i;
+	u_char bits[8];
 
+	acc=0;
+	for (i=0; (s[i]&0x7f) != '\0'; i++)
+		acc += (s[i]&0x7f)*((i%6)+1);
+	for (i=0; i<8; i++)
+		bits[i] = (acc<<(i%8))&0x80;
+	for (i=0; i<l; i++) {
+		s[i] ^= bits[i%8];
+		/* not sure whether this actually buys any performance */
+		if(s[i]=='\0')
+			break;  /* found end of filename, can stop here */
+	}
+}
+
+
 /*
  * decrypt path component
  *  leaving "." and ".."
@@@@ -279,9 +326,7 @@@@ decryptname(key,s)
 	if (l%CFSBLOCK)
 		return NULL;
 	dodecrypt(key,clearstring,l,10241,zerovect);
-	for (i=0; (clearstring[i]&0x7f) !='\0'; i++)
-		clearstring[i] &= 0x7f;
-	clearstring[i]='\0';
+	unchksum(clearstring,l);
 	return clearstring;
 }
 
@@@@ -359,11 +404,11 @@@@ isbndry(d)
 
 
 static fh_u roothandle;
-cfs_fileid rootnode={1,0,"\0\0\0\0\0\0\0\0","/NOWHERE/null",NULL,NULL,0,NULL,NULL};/* fileid=1; should be unique */
+cfs_fileid rootnode={1,0,{0,0,0,0,0,0,0,0},{'/','N','O','W','H','E','R','E','/','n','u','l','l'},NULL,NULL,0,NULL,NULL};/* fileid=1; should be unique */
 nfstime roottime={0,0};
 
 /* Had to change this - someone else was using the same magic number! */
-/* PLEASE change this value if you're going to re-use this code for
+/* PLEASE change this value if you're going to re-use this code for */
 /* something else!  Otherwise your FS and CFS can't both run... */
 /* static u_char magictest[8]={0x01,0x23,0x45,0x67,0x89,0xab,0xcd,0xef}; */
 static u_char magictest[8]="M.Blaze";
@@@@ -514,10 +559,44 @@@@ fhuid(f,u)
 cfsno(err)
      int err;
 {
-/* 	if (err==ENOENT)
+	switch (err) {
+	case 0:
+		return NFS_OK;
+	case EPERM:
+		return NFSERR_PERM;
+	case ENOENT:
+		return NFSERR_NOENT;
+	case EIO:
+		return NFSERR_IO;
+	case ENXIO:
+		return NFSERR_NXIO;
+	case EACCES:
+		return NFSERR_ACCES;
+	case EEXIST:
+		return NFSERR_EXIST;
+	case ENODEV:
+		return NFSERR_NODEV;
+	case ENOTDIR:
+		return NFSERR_NOTDIR;
+	case EISDIR:
+		return NFSERR_ISDIR;
+	case EFBIG:
+		return NFSERR_FBIG;
+	case ENOSPC:
+		return NFSERR_NOSPC;
+	case EROFS:
+		return NFSERR_ROFS;
+	case ENAMETOOLONG:
+		return NFSERR_NAMETOOLONG;
+	case ENOTEMPTY:
+		return NFSERR_NOTEMPTY;
+	case EDQUOT:
+		return NFSERR_DQUOT;
+	case ESTALE:
 		return NFSERR_STALE;
-	else */
+	default:
 		return err;
+	}
 }
 
 
@@@@ -732,12 +811,17 @@@@ fhmkdirent(p,comp,h)
 {
 	char path[NFS_MAXPATHLEN+1];
 	struct stat sb;
+	int l;
 	
 	if (p==NULL) {
 		cfserrno=NFSERR_STALE;
 		return -2;
 	}
-	sprintf(path,"%s/%s",p->name,comp);
+	l = snprintf(path, sizeof(path), "%s/%s", p->name, comp);
+	if (l < 0 || l >= sizeof(path)) {
+		cfserrno = NFSERR_NAMETOOLONG;
+		return -2;
+	}
 	if (mkdir(path,0)<0)
 		return -1;
 	if (stat(path,&sb)<0)
@@@@ -766,12 +850,22 @@@@ fhmkfileent(p,comp,h)
 		u_long i[2];
 	} buf;
 	char linkname[NFS_MAXPATHLEN+1];
+	int l;
 	
 	if (p==NULL) {
 		cfserrno=NFSERR_STALE;
 		return -2;
 	}
-	sprintf(path,"%s/%s",p->name,comp);
+	l = snprintf(path, sizeof(path), "%s/%s", p->name, comp);
+	if (l < 0 || l >= sizeof(path)) {
+		cfserrno = NFSERR_NAMETOOLONG;
+		return -2;
+	}
+	l = snprintf(linkname, sizeof(linkname), "%s/.pvect_%s", p->name, comp);
+	if (l < 0 || l >= sizeof(linkname)) {
+		cfserrno = NFSERR_NAMETOOLONG;
+		return -2;
+	}
 
 	if ((fd=open(path,O_CREAT|O_WRONLY|O_EXCL,0))<0) {
 		if (errno==EEXIST) {
@@@@ -785,7 +879,6 @@@@ fhmkfileent(p,comp,h)
 	if (fstat(fd,&sb)<0)
 		return -1;
 	close(fd);
-	sprintf(linkname,"%s/.pvect_%s",p->name,comp);
 	if (!rs) {
 	   if (p->ins->highsec) {	/* create new pert file iff highsec */
 		/* note that there's a race condition here until the simlink */
@@@@ -800,8 +893,8 @@@@ fhmkfileent(p,comp,h)
 		/* hash. but this doesn't really matter since collisions */
 		/* are rare.  we could save all 64 bits, but the encoding */
 		/* of the link would get messy and large */
-		sprintf(vect,"%02x%02x%02x%02x",
-			buf.ch[0],buf.ch[1],buf.ch[2],buf.ch[3]);
+		(void)snprintf(vect, sizeof(vect), "%02x%02x%02x%02x",
+			       buf.ch[0], buf.ch[1], buf.ch[2], buf.ch[3]);
 		if (symlink(vect,linkname) != 0) {
 			strcpy(linkname,"/NOWHERE/null");
 			bcopy((char *)zerovect,(char *)vect,8);
@@@@ -839,6 +932,7 @@@@ fhlook(p,comp,h)
 	char linkname[NFS_MAXPATHLEN+1];
 	char vect[NFS_MAXPATHLEN+1];
 	struct stat sb;
+	int l;
 	
 	if (p==NULL) {
 		cfserrno=NFSERR_STALE;
@@@@ -852,12 +946,20 @@@@ fhlook(p,comp,h)
 	}
 	if ((p->parent==0) && (!strcmp(comp,"..")))
 		return fhrootlook(p->ins->name,h);
-	sprintf(path,"%s/%s",p->name,comp);
+	l = snprintf(path, sizeof(path), "%s/%s", p->name, comp);
+	if (l < 0 || l >= sizeof(path)) {
+		cfserrno = NFSERR_NAMETOOLONG;
+		return -2;
+	}
 	if (lstat(path,&sb)<0) {
 		return -1;	/* just need the inode */
 	}
 	/* check for a linkfile */
-	sprintf(linkname,"%s/.pvect_%s",p->name,comp);
+	l = snprintf(linkname, sizeof(linkname), "%s/.pvect_%s", p->name, comp);
+	if (l < 0 || l >= sizeof(linkname)) {
+		cfserrno = NFSERR_NAMETOOLONG;
+		return -2;
+	}
 	if (readlink(linkname,vect,9) != 8) {
 		bcopy((char *)zerovect,(char *)vect,8);
 		strcpy(linkname,"/NOWHERE/null");
@@@@ -980,13 +1082,22 @@@@ fhdelete(f,s)
 	char path[NFS_MAXPATHLEN+1];
 	char linkname[NFS_MAXPATHLEN+1];
 	int ret;
+	int l;
 
 	if (f==NULL) {
 		cfserrno=NFSERR_STALE;
 		return -2;
 	}
-	sprintf(linkname,"%s/.pvect_%s",f->name,s);
-	sprintf(path,"%s/%s",f->name,s);
+	l = snprintf(path, sizeof(path), "%s/%s", f->name, s);
+	if (l < 0 || l >= sizeof(path)) {
+		cfserrno = NFSERR_NAMETOOLONG;
+		return -2;
+	}
+	l = snprintf(linkname, sizeof(linkname), "%s/.pvect_%s", f->name, s);
+	if (l < 0 || l >= sizeof(linkname)) {
+		cfserrno = NFSERR_NAMETOOLONG;
+		return -2;
+	}
 	/* note that we don't bother to check and see if there's a
 	   handle allocated for this - just wait for the inode to be
 	   reclaimed */
@@@@ -1001,13 +1112,21 @@@@ fhdeletedir(f,s)
      char *s;
 {
 	char path[NFS_MAXPATHLEN+1];
+	int l;
+	int err;
 
 	if (f==NULL) {
 		cfserrno=NFSERR_STALE;
 		return -2;
 	}
-	sprintf(path,"%s/%s",f->name,s);
-	return (rmdir(path));
+	l = snprintf(path, sizeof(path), "%s/%s", f->name, s);
+	if (l < 0 || l >= sizeof(path)) {
+		cfserrno = NFSERR_NAMETOOLONG;
+		return -2;
+	}
+	if ((err = rmdir(path)) < 0)
+		cfserrno = cfsno(errno);
+	return err;
 }
 
 DIR *
@@@@ -1055,15 +1174,24 @@@@ fhdohardlink(f,t,n)
 	char linkname[NFS_MAXPATHLEN+1];
 	char vectval[9];
 	int ret;
+	int l;
 	
 	if ((f==NULL)||(t==NULL)) {
 		cfserrno=NFSERR_STALE;
 		return -2;
 	}
-	sprintf(buf,"%s/%s",t->name,n);
+	l = snprintf(buf, sizeof(buf), "%s/%s", t->name, n);
+	if (l < 0 || l >= sizeof(buf)) {
+		cfserrno = NFSERR_NAMETOOLONG;
+		return -2;
+	}
+	l = snprintf(linkname, sizeof(linkname), "%s/.pvect_%s", t->name, n);
+	if (l < 0 || l >= sizeof(buf)) {
+		cfserrno = NFSERR_NAMETOOLONG;
+		return -2;
+	}
 	if ((ret=link(f->name,buf))!=0)
 			return ret;
-	sprintf(linkname,"%s/.pvect_%s",t->name,n);
 	unlink(linkname);
 	if (readlink(f->vectname,vectval,9) == 8) {
 		vectval[8]='\0';
@@@@ -1079,12 +1207,17 @@@@ fhdosymlink(f,n,t)
      char *t;
 {
 	char buf[NFS_MAXPATHLEN+1];
+	int l;
 	
 	if (f==NULL) {
 		cfserrno=NFSERR_STALE;
 		return -2;
 	}
-	sprintf(buf,"%s/%s",f->name,n);
+	l = snprintf(buf, sizeof(buf), "%s/%s", f->name, n);
+	if (l < 0 || l >= sizeof(buf)) {
+		cfserrno = NFSERR_NAMETOOLONG;
+		return -2;
+	}
 	return (symlink(t,buf));
 }
 
@@@@ -1100,15 +1233,32 @@@@ fhrename(f,fn,t,tn)
 	char fblink[NFS_MAXPATHLEN+1];
 	char tblink[NFS_MAXPATHLEN+1];
 	char vectval[9];
+	int l;
 	
 	if ((f==NULL)||(t==NULL)) {
 		cfserrno=NFSERR_STALE;
 		return -2;
 	}
-	sprintf(fb,"%s/%s",f->name,fn);
-	sprintf(tb,"%s/%s",t->name,tn);
-	sprintf(fblink,"%s/.pvect_%s",f->name,fn);
-	sprintf(tblink,"%s/.pvect_%s",t->name,tn);
+	l = snprintf(fb, sizeof(fb), "%s/%s", f->name, fn);
+	if (l < 0 || l >= sizeof(fb)) {
+		cfserrno = NFSERR_NAMETOOLONG;
+		return -2;
+	}
+	l = snprintf(tb, sizeof(tb), "%s/%s", t->name, tn);
+	if (l < 0 || l >= sizeof(tb)) {
+		cfserrno = NFSERR_NAMETOOLONG;
+		return -2;
+	}
+	l = snprintf(fblink, sizeof(fblink), "%s/.pvect_%s", f->name, fn);
+	if (l < 0 || l >= sizeof(fblink)) {
+		cfserrno = NFSERR_NAMETOOLONG;
+		return -2;
+	}
+	l = snprintf(tblink, sizeof(tblink), "%s/.pvect_%s", t->name, tn);
+	if (l < 0 || l >= sizeof(tblink)) {
+		cfserrno = NFSERR_NAMETOOLONG;
+		return -2;
+	}
 	if (rename(fb,tb)==0) { /* now we have to do a lookup */
 		unlink(tblink);	/* may be a quick race cndtn here */
 		if (readlink(fblink,vectval,9)==8) {
@@@@ -1160,7 +1310,8 @@@@ rootrd(cookie)
 	} else while (cookie<(NINSTANCES+2)) {
 		if (instances[cookie-2] != NULL) {
 			if (instances[cookie-2]->anon)
-				sprintf(d.d_name,".ANON_%d",cookie-2);
+				(void)snprintf(d.d_name, sizeof(d.d_name),
+				               ".ANON_%ld", cookie-2);
 			else
 				strcpy(d.d_name,
 				       instances[cookie-2]->name);
@


1.5
log
@unbreak following removal of unistd.h include from sys/file.h

this commit does nothing to improve the crappiness of these ports, just
lets them build again.
@
text
@@


1.4
log
@Regen patches and distinfo.
@
text
@d1 11
a11 3
--- cfs_fh.c.orig	Thu May  3 20:24:59 2001
+++ cfs_fh.c	Sat Nov 30 21:44:12 2013
@@@@ -177,6 +177,13 @@@@ writeblock(blk,fd,offset,len,key,vect)
d25 1
a25 1
@@@@ -195,30 +202,39 @@@@ encryptname(key,s)
d71 1
a71 1
@@@@ -229,17 +245,47 @@@@ chksum(s,l)
d122 1
a122 1
@@@@ -279,9 +325,7 @@@@ decryptname(key,s)
d133 1
a133 1
@@@@ -359,11 +403,11 @@@@ isbndry(d)
d147 1
a147 1
@@@@ -514,10 +558,44 @@@@ fhuid(f,u)
d194 1
a194 1
@@@@ -732,12 +810,17 @@@@ fhmkdirent(p,comp,h)
d213 1
a213 1
@@@@ -766,12 +849,22 @@@@ fhmkfileent(p,comp,h)
d237 1
a237 1
@@@@ -785,7 +878,6 @@@@ fhmkfileent(p,comp,h)
d245 1
a245 1
@@@@ -800,8 +892,8 @@@@ fhmkfileent(p,comp,h)
d256 1
a256 1
@@@@ -839,6 +931,7 @@@@ fhlook(p,comp,h)
d264 1
a264 1
@@@@ -852,12 +945,20 @@@@ fhlook(p,comp,h)
d287 1
a287 1
@@@@ -980,13 +1081,22 @@@@ fhdelete(f,s)
d312 1
a312 1
@@@@ -1001,13 +1111,21 @@@@ fhdeletedir(f,s)
d336 1
a336 1
@@@@ -1055,15 +1173,24 @@@@ fhdohardlink(f,t,n)
d363 1
a363 1
@@@@ -1079,12 +1206,17 @@@@ fhdosymlink(f,n,t)
d382 1
a382 1
@@@@ -1100,15 +1232,32 @@@@ fhrename(f,fn,t,tn)
d419 1
a419 1
@@@@ -1160,7 +1309,8 @@@@ rootrd(cookie)
@


1.3
log
@several patches from Debian
- cmkdir now uses /dev/srandom (actually changed to arandom by me)
- support for filenames w/ 8bit chars
- sprintf() replaced with snprintf()
- some bugfixes

from Andreas Voegele <voegelas at gmx.net>
@
text
@d2 2
a3 2
+++ cfs_fh.c	Sat Mar 12 20:21:46 2005
@@@@ -177,6 +177,13 @@@@
d17 1
a17 1
@@@@ -195,30 +202,39 @@@@
d63 1
a63 1
@@@@ -229,17 +245,47 @@@@
d114 1
a114 1
@@@@ -279,9 +325,7 @@@@
d125 1
a125 1
@@@@ -359,11 +403,11 @@@@
d139 1
a139 1
@@@@ -514,10 +558,44 @@@@
d186 1
a186 1
@@@@ -732,12 +810,17 @@@@
d205 1
a205 1
@@@@ -766,12 +849,22 @@@@
d229 1
a229 1
@@@@ -785,7 +878,6 @@@@
d237 1
a237 1
@@@@ -800,8 +892,8 @@@@
d248 1
a248 1
@@@@ -839,6 +931,7 @@@@
d256 1
a256 1
@@@@ -852,12 +945,20 @@@@
d279 1
a279 1
@@@@ -980,13 +1081,22 @@@@
d304 1
a304 1
@@@@ -1001,13 +1111,21 @@@@
d328 1
a328 1
@@@@ -1055,15 +1173,24 @@@@
d355 1
a355 1
@@@@ -1079,12 +1206,17 @@@@
d374 1
a374 1
@@@@ -1100,15 +1232,32 @@@@
d411 1
a411 1
@@@@ -1160,7 +1309,8 @@@@
@


1.2
log
@update to cfs 1.4.1

CFS was actually broken since at least 3.2 or so, but should work now
again on 32-bit archs. 64-bit archs are still broken and won't be
fixed anytime soon.

I also set PERMIT_*=Yes, as the "no fee" part of the license is clearly
due to bad english.

xsa@@ helped testing
@
text
@d1 125
a125 4
$OpenBSD$
--- cfs_fh.c.orig	2004-06-09 15:09:29.000000000 +0200
+++ cfs_fh.c	2004-06-09 15:11:41.000000000 +0200
@@@@ -359,7 +359,7 @@@@ isbndry(d)
d134 278
a411 1
@@@@ -1160,7 +1160,7 @@@@ rootrd(cookie)
d416 2
a417 1
+				sprintf(d.d_name,".ANON_%ld",cookie-2);
@


1.1
log
@* respect CC/CFLAGS
* redo patches with update-patches
@
text
@d1 4
a4 4
$OpenBSD: $
--- cfs_fh.c.orig	Fri Mar 16 20:23:02 2001
+++ cfs_fh.c	Fri Mar 16 20:23:02 2001
@@@@ -363,7 +363,7 @@@@ isbndry(d)
d12 10
a21 1
 static u_char magictest[8]={0x01,0x23,0x45,0x67,0x89,0xab,0xcd,0xef};
@

