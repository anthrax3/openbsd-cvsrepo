head	1.1;
access;
symbols
	OPENBSD_5_5:1.1.0.2;
locks; strict;
comment	@# @;


1.1
date	2014.06.30.09.05.21;	author jasper;	state dead;
branches
	1.1.2.1;
next	;
commitid	kdJfE1clDMhC5uUe;

1.1.2.1
date	2014.06.30.09.05.21;	author jasper;	state Exp;
branches;
next	;
commitid	kdJfE1clDMhC5uUe;


desc
@@


1.1
log
@file patch-g10_compress_c was initially added on branch OPENBSD_5_5.
@
text
@@


1.1.2.1
log
@Security fix for CVE-2014-4617,
gnupg: infinite loop when decompressing data packets

ok sthen@@
@
text
@a0 48
$OpenBSD$

Security fix for CVE-2014-4617,
gnupg: infinite loop when decompressing data packets

http://git.gnupg.org/cgi-bin/gitweb.cgi?p=gnupg.git;a=patch;h=014b2103fcb12f261135e3954f26e9e07b39e342

--- g10/compress.c.orig	Mon Jun 23 15:27:56 2014
+++ g10/compress.c	Mon Jun 23 15:30:17 2014
@@@@ -162,6 +162,7 @@@@ do_uncompress( compress_filter_context_t *zfx, z_strea
 {
     int zrc;
     int rc=0;
+    int leave = 0;
     size_t n;
     int nread, count;
     int refill = !zs->avail_in;
@@@@ -179,13 +180,14 @@@@ do_uncompress( compress_filter_context_t *zfx, z_strea
 	    nread = iobuf_read( a, zfx->inbuf + n, count );
 	    if( nread == -1 ) nread = 0;
 	    n += nread;
-	    /* If we use the undocumented feature to suppress
-	     * the zlib header, we have to give inflate an
-	     * extra dummy byte to read */
-	    if( nread < count && zfx->algo == 1 ) {
-		*(zfx->inbuf + n) = 0xFF; /* is it really needed ? */
-		zfx->algo1hack = 1;
+            /* Algo 1 has no zlib header which requires us to to give
+	     * inflate an extra dummy byte to read. To be on the safe
+	     * side we allow for up to 4 ff bytes.  */
+	    if( nread < count && zfx->algo == 1 && zfx->algo1hack < 4) {
+		*(zfx->inbuf + n) = 0xFF;
+		zfx->algo1hack++;
 		n++;
+		leave = 1;
 	    }
 	    zs->avail_in = n;
 	}
@@@@ -205,7 +207,8 @@@@ do_uncompress( compress_filter_context_t *zfx, z_strea
 	    else
 		log_fatal("zlib inflate problem: rc=%d\n", zrc );
 	}
-    } while( zs->avail_out && zrc != Z_STREAM_END && zrc != Z_BUF_ERROR );
+    } while( zs->avail_out && zrc != Z_STREAM_END && zrc != Z_BUF_ERROR
+	&& !leave);
 
     *ret_len = zfx->outbufsize - zs->avail_out;
     if( DBG_FILTER )
@

