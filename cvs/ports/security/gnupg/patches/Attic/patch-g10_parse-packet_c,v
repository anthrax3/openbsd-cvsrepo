head	1.2;
access;
symbols
	OPENBSD_3_9:1.1.0.4
	OPENBSD_3_8:1.1.0.2;
locks; strict;
comment	@# @;


1.2
date	2006.07.13.13.11.29;	author bernd;	state dead;
branches;
next	1.1;

1.1
date	2006.06.23.11.35.36;	author bernd;	state Exp;
branches
	1.1.2.1
	1.1.4.1;
next	;

1.1.2.1
date	2006.06.25.14.38.02;	author sturm;	state Exp;
branches;
next	1.1.2.2;

1.1.2.2
date	2006.08.09.20.47.19;	author sturm;	state Exp;
branches;
next	;

1.1.4.1
date	2006.06.25.14.38.23;	author sturm;	state Exp;
branches;
next	1.1.4.2;

1.1.4.2
date	2006.08.09.20.17.02;	author sturm;	state Exp;
branches;
next	;


desc
@@


1.2
log
@Update to gnupg-1.4.4.

ok reinhard@@ (MAINTAINER), "looks good" steven@@
@
text
@$OpenBSD: patch-g10_parse-packet_c,v 1.1 2006/06/23 11:35:36 bernd Exp $

Security fix for CVE-2006-3082. Diff from gnupg CVS.

--- g10/parse-packet.c.orig	Tue Dec  6 14:22:19 2005
+++ g10/parse-packet.c	Fri Jun 23 10:42:48 2006
@@@@ -1972,6 +1972,20 @@@@ parse_user_id( IOBUF inp, int pkttype, u
 {
     byte *p;
 
+    /* Cap the size of a user ID at 2k: a value absurdly large enough
+       that there is no sane user ID string (which is printable text
+       as of RFC2440bis) that won't fit in it, but yet small enough to
+       avoid allocation problems.  A large pktlen may not be
+       allocatable, and a very large pktlen could actually cause our
+       allocation to wrap around in xmalloc to a small number. */
+
+    if(pktlen>2048)
+      {
+	log_error("packet(%d) too large\n", pkttype);
+	iobuf_skip_rest(inp, pktlen, 0);
+	return G10ERR_INVALID_PACKET;
+      }
+
     packet->pkt.user_id = xmalloc_clear(sizeof *packet->pkt.user_id + pktlen);
     packet->pkt.user_id->len = pktlen;
     packet->pkt.user_id->ref=1;
@


1.1
log
@Security update! Fixes an integer overflow. (CVE-2006-3082)

Detailed information: http://secunia.com/advisories/20783/

Diff from gnupg CVS.

ok sturm@@
@
text
@d1 1
a1 1
$OpenBSD$
@


1.1.4.1
log
@MFC:
Security update! Fixes an integer overflow. (CVE-2006-3082)

Detailed information: http://secunia.com/advisories/20783/

Diff from gnupg CVS.
@
text
@d1 1
a1 1
$OpenBSD: patch-g10_parse-packet_c,v 1.1 2006/06/23 11:35:36 bernd Exp $
d5 3
a7 3
--- g10/parse-packet.c.orig	Sun Jun 25 15:50:59 2006
+++ g10/parse-packet.c	Sun Jun 25 15:50:38 2006
@@@@ -1983,6 +1983,20 @@@@ parse_user_id( IOBUF inp, int pkttype, u
d20 3
a22 3
+       log_error("packet(%d) too large\n", pkttype);
+       iobuf_skip_rest(inp, pktlen, 0);
+       return G10ERR_INVALID_PACKET;
d25 1
a25 1
     packet->pkt.user_id = m_alloc(sizeof *packet->pkt.user_id  + pktlen);
d27 1
a27 1
 
@


1.1.4.2
log
@backport from gnupg 1.4.5 which fixes a denial of service vulnerability
(CVE-2006-3746)

For more information see:
http://secunia.com/advisories/21297/
http://lists.gnupg.org/pipermail/gnupg-announce/2006q3/000229.html
@
text
@d1 1
a1 1
$OpenBSD: patch-g10_parse-packet_c,v 1.1.4.1 2006/06/25 14:38:23 sturm Exp $
d5 2
a6 2
--- g10/parse-packet.c.orig	Tue Feb 14 11:10:17 2006
+++ g10/parse-packet.c	Wed Aug  9 21:34:49 2006
a26 29
 
@@@@ -2077,6 +2091,16 @@@@ parse_comment( IOBUF inp, int pkttype, u
 {
     byte *p;
 
+    /* Cap comment packet at a reasonable value to avoid an integer
+       overflow in the malloc below.  Comment packets are actually not
+       anymore define my OpenPGP and we even stopped to use our
+       private comment packet. */
+    if (pktlen>65536)
+      {
+       log_error ("packet(%d) too large\n", pkttype);
+       iobuf_skip_rest (inp, pktlen, 0);
+       return G10ERR_INVALID_PACKET;
+      }
     packet->pkt.comment = m_alloc(sizeof *packet->pkt.comment + pktlen - 1);
     packet->pkt.comment->len = pktlen;
     p = packet->pkt.comment->data;
@@@@ -2329,6 +2353,11 @@@@ parse_gpg_control( IOBUF inp, int pkttyp
 	if ( sesmark[i] != iobuf_get_noeof(inp) )
             goto skipit;
     }
+
+    /* Definitely too large.  We skip it to avoid an overflow in the malloc. */
+    if (pktlen > 4096)
+        goto skipit;
+
     if ( list_mode )
         puts ("- gpg control packet");
@


1.1.2.1
log
@MFC:
Security update! Fixes an integer overflow. (CVE-2006-3082)

Detailed information: http://secunia.com/advisories/20783/

Diff from gnupg CVS.
@
text
@d1 1
a1 1
$OpenBSD: patch-g10_parse-packet_c,v 1.1 2006/06/23 11:35:36 bernd Exp $
d5 3
a7 3
--- g10/parse-packet.c.orig	Sun Jun 25 15:50:59 2006
+++ g10/parse-packet.c	Sun Jun 25 15:50:38 2006
@@@@ -1983,6 +1983,20 @@@@ parse_user_id( IOBUF inp, int pkttype, u
d20 3
a22 3
+       log_error("packet(%d) too large\n", pkttype);
+       iobuf_skip_rest(inp, pktlen, 0);
+       return G10ERR_INVALID_PACKET;
d25 1
a25 1
     packet->pkt.user_id = m_alloc(sizeof *packet->pkt.user_id  + pktlen);
d27 1
a27 1
 
@


1.1.2.2
log
@backport from gnupg 1.4.5 which fixes a denial of service vulnerability
(CVE-2006-3746)

For more information see:
http://secunia.com/advisories/21297/
http://lists.gnupg.org/pipermail/gnupg-announce/2006q3/000229.html
@
text
@d1 1
a1 1
$OpenBSD: patch-g10_parse-packet_c,v 1.1.2.1 2006/06/25 14:38:02 sturm Exp $
d5 2
a6 2
--- g10/parse-packet.c.orig	Tue Feb 14 11:10:17 2006
+++ g10/parse-packet.c	Wed Aug  9 22:25:25 2006
a26 29
 
@@@@ -2077,6 +2091,16 @@@@ parse_comment( IOBUF inp, int pkttype, u
 {
     byte *p;
 
+    /* Cap comment packet at a reasonable value to avoid an integer
+       overflow in the malloc below.  Comment packets are actually not
+       anymore define my OpenPGP and we even stopped to use our
+       private comment packet. */
+    if (pktlen>65536)
+      {
+       log_error ("packet(%d) too large\n", pkttype);
+       iobuf_skip_rest (inp, pktlen, 0);
+       return G10ERR_INVALID_PACKET;
+      }
     packet->pkt.comment = m_alloc(sizeof *packet->pkt.comment + pktlen - 1);
     packet->pkt.comment->len = pktlen;
     p = packet->pkt.comment->data;
@@@@ -2329,6 +2353,11 @@@@ parse_gpg_control( IOBUF inp, int pkttyp
 	if ( sesmark[i] != iobuf_get_noeof(inp) )
             goto skipit;
     }
+
+    /* Definitely too large.  We skip it to avoid an overflow in the malloc. */
+    if (pktlen > 4096)
+        goto skipit;
+
     if ( list_mode )
         puts ("- gpg control packet");
@


