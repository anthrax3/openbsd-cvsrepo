head	1.2;
access;
symbols
	OPENBSD_5_4:1.2.0.2
	OPENBSD_3_1:1.1.0.8
	OPENBSD_3_1_BASE:1.1
	OPENBSD_3_0:1.1.0.6
	OPENBSD_3_0_BASE:1.1
	OPENBSD_2_9_TRACKING_SWITCH:1.1
	OPENBSD_2_9:1.1.0.4
	OPENBSD_2_9_BASE:1.1
	OPENBSD_2_8:1.1.0.2;
locks; strict;
comment	@# @;


1.2
date	2002.07.05.07.13.01;	author reinhard;	state dead;
branches
	1.2.2.1;
next	1.1;

1.1
date	2001.03.23.13.10.21;	author reinhard;	state Exp;
branches
	1.1.2.1;
next	;

1.1.2.1
date	2001.03.25.11.48.41;	author naddy;	state Exp;
branches;
next	;

1.2.2.1
date	2013.12.20.20.01.47;	author jasper;	state Exp;
branches;
next	;


desc
@@


1.2
log
@update to gnupg-1.0.7; thx Nikolay Sturm
* use 'as' of new binutils on non elf-toolchain archs

see http://lists.gnupg.org/pipermail/gnupg-announce/2002q2/000251.html
for a list of changes
@
text
@$OpenBSD: patch-cipher_rsa_c,v 1.1 2001/03/23 13:10:21 reinhard Exp $
# Florian Weimer <Florian.Weimer@@RUS.UNI-STUTTGART.DE>
# http://cert.uni-stuttgart.de/files/fw/gnupg-klima-rosa.diff
# http://cert.uni-stuttgart.de/files/fw/gnupg-klima-rosa.diff.asc

It introduces additional consistency checks, as suggested by the
authors of the paper.  The checks are slightly different, but they
make the two additional attacks infeasible, I think.  In the future,
it might be a good idea to add a check the generated signature for
validity, this will detect bugs in the MPI implementation which could
result in a revealed secret key, too.


--- cipher/rsa.c.orig	Wed Sep 13 15:49:23 2000
+++ cipher/rsa.c	Fri Mar 23 13:16:46 2001
@@@@ -165,18 +165,53 @@@@ generate( RSA_secret_key *sk, unsigned n
 
 /****************
  * Test wether the secret key is valid.
- * Returns: true if this is a valid key.
+ * Returns: nonzero if this is a valid key.
  */
 static int
 check_secret_key( RSA_secret_key *sk )
 {
-    int rc;
-    MPI temp = mpi_alloc( mpi_get_nlimbs(sk->p)*2 );
+    int rc = 0;
+    MPI temp    = mpi_alloc_secure ( mpi_get_nlimbs(sk->p) + mpi_get_nlimbs(sk->q) );
+    MPI p_1     = mpi_copy (sk->p); /* (p-1) */
+    MPI q_1     = mpi_copy (sk->p); /* (q-1) */
+    MPI p_1_q_1 = mpi_alloc_secure ( mpi_get_nlimbs(sk->p) + mpi_get_nlimbs(sk->q) ); /* (p-1)(q-1) */
+
+    /* Calculate (p-1)(q-1). */
+    mpi_sub_ui(p_1, p_1, 1);
+    mpi_sub_ui(q_1, q_1, 1);
+    mpi_mul(p_1_q_1, p_1, q_1);
 
+    /* Check pq = n. */
     mpi_mul(temp, sk->p, sk->q );
-    rc = mpi_cmp( temp, sk->n );
+    if( 0 != mpi_cmp(temp, sk->n ) )
+	goto end;
+	
+    /* Check gcd(e, (p-1)(q-1)) = 1. */
+    if( ! mpi_gcd(temp, sk->e, p_1_q_1) )
+	goto end;
+
+    /* Check de == 1 (mod (p-1)) and (mod (q-1)), i.e. d = e^-1. */
+    mpi_mulm(temp, sk->d, sk->e, p_1);
+    if( 0 != mpi_cmp_ui(temp, 1))
+	goto end;
+    mpi_mulm(temp, sk->d, sk->e, q_1);
+    if( 0 != mpi_cmp_ui(temp, 1))
+	goto end;
+
+    /* Check up == 1 (mod q). */
+    mpi_mulm(temp, sk->u, sk->p, sk->q);
+    if( 0 != mpi_cmp_ui(temp, 1))
+	goto end;
+
+    /* Success.  Fall through to deallocation code. */
+    rc = 1;
+
+ end:
     mpi_free(temp);
-    return !rc;
+    mpi_free(p_1);
+    mpi_free(q_1);
+    mpi_free(p_1_q_1);
+    return rc;
 }
 
 
@@@@ -389,6 +424,8 @@@@ int
 rsa_sign( int algo, MPI *resarr, MPI data, MPI *skey )
 {
     RSA_secret_key sk;
+    RSA_public_key pk;
+    MPI orig = mpi_alloc( mpi_get_nlimbs( data ) );
 
     if( algo != 1 && algo != 3 )
 	return G10ERR_PUBKEY_ALGO;
@@@@ -401,6 +438,13 @@@@ rsa_sign( int algo, MPI *resarr, MPI dat
     sk.u = skey[5];
     resarr[0] = mpi_alloc( mpi_get_nlimbs( sk.n ) );
     secret( resarr[0], data, &sk );
+
+    /* Check against wrong computation. */
+    pk.n = sk.n;
+    pk.e = sk.e;
+    public( orig, resarr[0], &pk);
+    if ( 0 != mpi_cmp( orig, data ) )
+	return G10ERR_BAD_SECKEY;
 
     return 0;
 }
@


1.2.2.1
log
@Security fix for CVE-2013-4576
@
text
@d1 4
a4 1
$OpenBSD$
d6 6
a11 3
Security fix for CVE-2013-4576
http://git.gnupg.org/cgi-bin/gitweb.cgi?p=gnupg.git;a=commit;h=93a96e3c0c33370248f6570d8285c4e811d305d4
http://git.gnupg.org/cgi-bin/gitweb.cgi?p=gnupg.git;a=commit;h=d0d72d98f34579213230b3febfebd2fd8dff272b
d13 64
a76 133
--- cipher/rsa.c.orig	Sun Dec 15 18:13:02 2013
+++ cipher/rsa.c	Sun Dec 15 18:12:56 2013
@@@@ -1,5 +1,5 @@@@
 /* rsa.c  -  RSA function
- *	Copyright (C) 1997, 1998, 1999 by Werner Koch (dd9jn)
+ *	Copyright (C) 1997, 1998, 1999, 2013 by Werner Koch (dd9jn)
  *	Copyright (C) 2000, 2001 Free Software Foundation, Inc.
  *
  * This file is part of GnuPG.
@@@@ -22,7 +22,7 @@@@
    which expires on September 20, 2000.  The patent holder placed that
    patent into the public domain on Sep 6th, 2000.
 */
- 
+
 #include <config.h>
 #include <stdio.h>
 #include <stdlib.h>
@@@@ -32,6 +32,10 @@@@
 #include "cipher.h"
 #include "rsa.h"
 
+/* Blinding is used to mitigate side-channel attacks.  You may undef
+   this to speed up the operation in case the system is secured
+   against physical and network mounted side-channel attacks.  */
+#define USE_BLINDING 1
 
 typedef struct {
     MPI n;	    /* modulus */
@@@@ -103,7 +107,7 @@@@ generate( RSA_secret_key *sk, unsigned nbits )
 
     /* make sure that nbits is even so that we generate p, q of equal size */
     if ( (nbits&1) )
-      nbits++; 
+      nbits++;
 
     n = mpi_alloc ( mpi_nlimb_hint_from_nbits (nbits) );
 
@@@@ -146,7 +150,7 @@@@ generate( RSA_secret_key *sk, unsigned nbits )
        65537 as the new best practice.  See FIPS-186-3.
      */
     e = mpi_alloc ( mpi_nlimb_hint_from_nbits (32) );
-    mpi_set_ui( e, 65537); 
+    mpi_set_ui( e, 65537);
     while( !mpi_gcd(t1, e, phi) ) /* (while gcd is not 1) */
       mpi_add_ui( e, e, 2);
 
@@@@ -268,7 +272,7 @@@@ stronger_key_check ( RSA_secret_key *skey )
     mpi_invm(t, skey->p, skey->q );
     if ( mpi_cmp(t, skey->u ) )
         log_info ( "RSA Oops: u is wrong\n");
-   
+
     log_info ( "RSA secret key check finished\n");
 
     mpi_free (t);
@@@@ -286,9 +290,9 @@@@ stronger_key_check ( RSA_secret_key *skey )
  *
  * Or faster:
  *
- *      m1 = c ^ (d mod (p-1)) mod p 
- *      m2 = c ^ (d mod (q-1)) mod q 
- *      h = u * (m2 - m1) mod q 
+ *      m1 = c ^ (d mod (p-1)) mod p
+ *      m2 = c ^ (d mod (q-1)) mod q
+ *      h = u * (m2 - m1) mod q
  *      m = m1 + h * p
  *
  * Where m is OUTPUT, c is INPUT and d,n,p,q,u are elements of SKEY.
@@@@ -299,13 +303,31 @@@@ secret(MPI output, MPI input, RSA_secret_key *skey )
 #if 0
     mpi_powm( output, input, skey->d, skey->n );
 #else
-    MPI m1   = mpi_alloc_secure( mpi_get_nlimbs(skey->n)+1 );
-    MPI m2   = mpi_alloc_secure( mpi_get_nlimbs(skey->n)+1 );
-    MPI h    = mpi_alloc_secure( mpi_get_nlimbs(skey->n)+1 );
+    int nlimbs = mpi_get_nlimbs (skey->n)+1;
+    MPI m1   = mpi_alloc_secure (nlimbs);
+    MPI m2   = mpi_alloc_secure (nlimbs);
+    MPI h    = mpi_alloc_secure (nlimbs);
+# ifdef USE_BLINDING
+    MPI bdata= mpi_alloc_secure (nlimbs);
+    MPI r    = mpi_alloc_secure (nlimbs);
+# endif /* USE_BLINDING */
 
+    /* Remove superfluous leading zeroes from INPUT.  */
+    mpi_normalize (input);
+
+# ifdef USE_BLINDING
+    /* Blind:  bdata = (data * r^e) mod n   */
+    randomize_mpi (r, mpi_get_nbits (skey->n), 0);
+    mpi_fdiv_r (r, r, skey->n);
+    mpi_powm (bdata, r, skey->e, skey->n);
+    mpi_mulm (bdata, bdata, input, skey->n);
+    input = bdata;
+# endif /* USE_BLINDING */
+
+    /* RSA secret operation:  */
     /* m1 = c ^ (d mod (p-1)) mod p */
     mpi_sub_ui( h, skey->p, 1  );
-    mpi_fdiv_r( h, skey->d, h );   
+    mpi_fdiv_r( h, skey->d, h );
     mpi_powm( m1, input, h, skey->p );
     /* m2 = c ^ (d mod (q-1)) mod q */
     mpi_sub_ui( h, skey->q, 1  );
@@@@ -313,14 +335,21 @@@@ secret(MPI output, MPI input, RSA_secret_key *skey )
     mpi_powm( m2, input, h, skey->q );
     /* h = u * ( m2 - m1 ) mod q */
     mpi_sub( h, m2, m1 );
-    if ( mpi_is_neg( h ) ) 
+    if ( mpi_is_neg( h ) )
         mpi_add ( h, h, skey->q );
-    mpi_mulm( h, skey->u, h, skey->q ); 
+    mpi_mulm( h, skey->u, h, skey->q );
     /* m = m2 + h * p */
     mpi_mul ( h, h, skey->p );
     mpi_add ( output, m1, h );
-    /* ready */
-    
+
+# ifdef USE_BLINDING
+    mpi_free (bdata);
+    /* Unblind: output = (output * r^(-1)) mod n  */
+    mpi_invm (r, r, skey->n);
+    mpi_mulm (output, output, r, skey->n);
+    mpi_free (r);
+# endif /* USE_BLINDING */
+
     mpi_free ( h );
     mpi_free ( m1 );
     mpi_free ( m2 );
@@@@ -395,6 +424,7 @@@@ int
 rsa_decrypt( int algo, MPI *result, MPI *data, MPI *skey )
d79 2
a80 1
+    MPI input;
d82 1
a82 1
     if( algo != 1 && algo != 2 )
d84 1
a84 3
@@@@ -405,8 +435,16 @@@@ rsa_decrypt( int algo, MPI *result, MPI *data, MPI *sk
     sk.p = skey[3];
     sk.q = skey[4];
d86 2
a87 2
-    *result = mpi_alloc_secure( mpi_get_nlimbs( sk.n ) );
-    secret( *result, data[0], &sk );
d89 7
a95 9
+    /* Better make sure that there are no superfluous leading zeroes
+       in the input and it has not been padded using multiples of N.
+       This mitigates side-channel attacks (CVE-2013-4576).  */
+    input = mpi_alloc (0);
+    mpi_normalize (data[0]);
+    mpi_fdiv_r (input, data[0], sk.n);
+    *result = mpi_alloc_secure (mpi_get_nlimbs (sk.n));
+    secret (*result, input, &sk);
+    mpi_free (input);
a97 1
 
@


1.1
log
@SECURITY UPDATE (Klima-Rosa attack)

patch from:
Florian Weimer <Florian.Weimer@@RUS.UNI-STUTTGART.DE>
# http://cert.uni-stuttgart.de/files/fw/gnupg-klima-rosa.diff
# http://cert.uni-stuttgart.de/files/fw/gnupg-klima-rosa.diff.asc

It introduces additional consistency checks, as suggested by the
authors of the paper.  The checks are slightly different, but they
make the two additional attacks infeasible, I think.  In the future,
it might be a good idea to add a check the generated signature for
validity, this will detect bugs in the MPI implementation which could
result in a revealed secret key, too.


ok markus@@
@
text
@d1 1
a1 1
$OpenBSD: update-patches,v 1.3 2000/06/09 17:08:37 espie Exp $
@


1.1.2.1
log
@MFC:
- SECURITY: protect against Klima-Rosa attack
- Update MASTER_SITES
- /dev/srandom -> /dev/arandom
- bump package revision
@
text
@d1 1
a1 1
$OpenBSD: patch-cipher_rsa_c,v 1.1 2001/03/23 13:10:21 reinhard Exp $
@

