head	1.7;
access;
symbols
	OPENBSD_2_7:1.6.0.2
	OPENBSD_2_7_BASE:1.6
	OPENBSD_2_5:1.3.0.2
	OPENBSD_2_5_BASE:1.3
	OPENBSD_2_3:1.1.0.2
	OPENBSD_2_3_BASE:1.1;
locks; strict;
comment	@# @;


1.7
date	2000.08.27.20.45.16;	author turan;	state dead;
branches;
next	1.6;

1.6
date	99.12.12.22.09.25;	author dugsong;	state Exp;
branches;
next	1.5;

1.5
date	99.11.12.14.56.22;	author dugsong;	state Exp;
branches;
next	1.4;

1.4
date	99.05.14.18.35.29;	author brad;	state dead;
branches;
next	1.3;

1.3
date	98.11.02.04.41.50;	author marc;	state Exp;
branches;
next	1.2;

1.2
date	98.06.02.18.10.00;	author marc;	state dead;
branches;
next	1.1;

1.1
date	97.11.17.05.58.44;	author todd;	state Exp;
branches;
next	;


desc
@@


1.7
log
@remove ssh port.  discussed with theo.
@
text
@--- rsaglue.c.orig	Wed May 12 07:19:28 1999
+++ rsaglue.c	Sun Dec 12 16:20:41 1999
@@@@ -71,8 +71,8 @@@@
    interface without modifying RSAREF. */
 
 #define _MD5_H_ /* Kludge to prevent inclusion of rsaref md5.h. */
-#include "rsaref2/source/global.h"
-#include "rsaref2/source/rsaref.h"
+#include "global.h"
+#include "rsaref.h"
 
 /* Convert an integer from gmp to rsaref representation. */
 
@@@@ -139,6 +139,10 @@@@
 
   input_bits = mpz_sizeinbase(input, 2);
   input_len = (input_bits + 7) / 8;
+  if (input_len > sizeof(input_data))
+    fatal("Attempted to encrypt a block too large (%d bytes, %d max).",
+    	input_len, sizeof(input_data));
+
   gmp_to_rsaref(input_data, input_len, input);
 
   rsaref_public_key(&public_key, key);
@@@@ -172,6 +176,10 @@@@
   
   input_bits = mpz_sizeinbase(input, 2);
   input_len = (input_bits + 7) / 8;
+  if (input_len > sizeof(input_data))
+    fatal("Received session key too long (%d bytes, %d max).",
+    	input_len, sizeof(input_data));
+
   gmp_to_rsaref(input_data, input_len, input);
 
   rsaref_private_key(&private_key, key);
@


1.6
log
@use rsaref port
@
text
@@


1.5
log
@patch (as posted to misc@@) for recent RSAREF bug - ok todd@@
@
text
@d2 12
a13 1
+++ rsaglue.c	Wed Nov 10 09:30:32 1999
@


1.4
log
@upgrade to ssh 1.2.27
@
text
@d1 14
a14 60
--- log-server.c.DIST	Wed Jul  8 10:40:36 1998
+++ log-server.c	Sun Nov  1 19:51:47 1998
@@@@ -134,7 +134,7 @@@@
   if (log_quiet)
     return;
   va_start(args, fmt);
-  vsprintf(buf, fmt, args);
+  vsnprintf(buf, sizeof(buf), fmt, args);
   va_end(args);
   if (log_on_stderr)
     fprintf(stderr, "log: %s\n", buf);
@@@@ -175,7 +175,7 @@@@
   if (log_quiet)
     return;
   va_start(args, fmt);
-  vsprintf(buf, fmt, args);
+  vsnprintf(buf, sizeof(buf), fmt, args);
   va_end(args);
   if (log_on_stderr)
     fprintf(stderr, "log: %s\n", buf);
@@@@ -191,7 +191,7 @@@@
   if (!log_debug || log_quiet)
     return;
   va_start(args, fmt);
-  vsprintf(buf, fmt, args);
+  vsnprintf(buf, sizeof(buf), fmt, args);
   va_end(args);
   if (log_on_stderr)
     fprintf(stderr, "debug: %s\n", buf);
@@@@ -207,7 +207,7 @@@@
   if (log_quiet)
     return;
   va_start(args, fmt);
-  vsprintf(buf, fmt, args);
+  vsnprintf(buf, sizeof(buf), fmt, args);
   va_end(args);
   if (log_on_stderr)
     fprintf(stderr, "error: %s\n", buf);
@@@@ -302,7 +302,7 @@@@
   if (log_quiet)
     exit(1);
   va_start(args, fmt);
-  vsprintf(buf, fmt, args);
+  vsnprintf(buf, sizeof(buf), fmt, args);
   va_end(args);
   if (log_on_stderr)
     fprintf(stderr, "fatal: %s\n", buf);
@@@@ -321,7 +321,7 @@@@
   if (log_quiet)
     exit(1);
   va_start(args, fmt);
-  vsprintf(buf, fmt, args);
+  vsnprintf(buf, sizeof(buf), fmt, args);
   va_end(args);
   if (log_on_stderr)
     fprintf(stderr, "fatal: %s\n", buf);
--- packet.c.DIST	Wed Jul  8 10:40:37 1998
+++ packet.c	Sun Nov  1 19:52:00 1998
@@@@ -693,7 +693,7 @@@@
   va_list args;
d16 7
a22 19
   va_start(args, fmt);
-  vsprintf(buf, fmt, args);
+  vsnprintf(buf, sizeof(buf), fmt, args);
   va_end(args);
   
   packet_start(SSH_MSG_DEBUG);
@@@@ -719,7 +719,7 @@@@
   /* Format the message.  Note that the caller must make sure the message
      is of limited size. */
   va_start(args, fmt);
-  vsprintf(buf, fmt, args);
+  vsnprintf(buf, sizeof(buf), fmt, args);
   va_end(args);
 
   /* Send the disconnect message to the other side, and wait for it to get 
--- scp.c.DIST	Wed Jul  8 10:40:38 1998
+++ scp.c	Sun Nov  1 19:52:13 1998
@@@@ -332,7 +332,7 @@@@
   char buf[1024];
d24 1
a24 6
   va_start(ap, fmt);
-  vsprintf(buf, fmt, ap);
+  vsnprintf(buf, sizeof(buf), fmt, ap);
   va_end(ap);
   fprintf(stderr, "%s\n", buf);
   exit(255);
@


1.3
log
@Add patch from millert@@ based on the IBM security advisory sent to the rootshell list
@
text
@@


1.2
log
@update to ssh 1.2.23
@
text
@d1 87
a87 40
*** userfile.c.orig	Thu Mar 27 09:04:13 1997
--- userfile.c	Sat Mar 29 01:16:51 1997
***************
*** 166,171 ****
--- 166,175 ----
  #endif
  
  
+ #ifdef HAVE_LOGIN_CAP_H
+ #include <login_cap.h>
+ #endif
+ 
  /* Protocol message types. */
  #define USERFILE_OPEN		1
  #define USERFILE_OPEN_REPLY	2
***************
*** 626,631 ****
--- 630,641 ----
    /* Child.  We will start serving request. */
    if (uid != geteuid() || uid != getuid())
      {
+ #ifdef HAVE_LOGIN_CAP_H
+       struct passwd * pw = getpwuid(uid);
+       login_cap_t * lc = login_getuserclass(pw);
+       if (setusercontext(lc, pw, uid, LOGIN_SETALL&~(LOGIN_SETLOGIN|LOGIN_SETPATH|LOGIN_SETENV)) < 0)
+ 	fatal("setusercontext: %s", strerror(errno));
+ #else
        if (setgid(gid) < 0)
  	fatal("setgid: %s", strerror(errno));
  
***************
*** 636,641 ****
--- 646,652 ----
  
        if (setuid(uid) < 0)
  	fatal("setuid: %s", strerror(errno));
+ #endif /* HAVE_LOGIN_CAP_H */
      }
  
    /* Enter the server main loop. */
@


1.1
log
@+ ssh (1.2.21)
@
text
@@

