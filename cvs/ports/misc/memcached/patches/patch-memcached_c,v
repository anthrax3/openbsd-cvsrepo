head	1.13;
access;
symbols
	OPENBSD_6_1:1.11.0.2
	OPENBSD_6_1_BASE:1.11
	OPENBSD_6_0:1.10.0.2
	OPENBSD_6_0_BASE:1.10
	OPENBSD_5_5:1.8.0.4
	OPENBSD_5_5_BASE:1.8
	OPENBSD_5_4:1.8.0.2
	OPENBSD_4_7:1.6.0.2
	OPENBSD_4_7_BASE:1.6
	OPENBSD_4_5:1.4.0.2
	OPENBSD_4_5_BASE:1.4
	OPENBSD_4_4:1.3.0.4
	OPENBSD_4_4_BASE:1.3
	OPENBSD_4_3:1.3.0.2
	OPENBSD_4_3_BASE:1.3
	OPENBSD_4_2:1.2.0.10
	OPENBSD_4_2_BASE:1.2
	OPENBSD_4_1:1.2.0.8
	OPENBSD_4_1_BASE:1.2
	OPENBSD_4_0:1.2.0.6
	OPENBSD_4_0_BASE:1.2
	OPENBSD_3_9:1.2.0.4
	OPENBSD_3_9_BASE:1.2
	OPENBSD_3_8:1.2.0.2
	OPENBSD_3_8_BASE:1.2
	OPENBSD_3_7:1.1.1.1.0.2
	OPENBSD_3_7_BASE:1.1.1.1
	alek_20041110:1.1.1.1
	alek:1.1.1;
locks; strict;
comment	@# @;


1.13
date	2017.07.17.08.35.08;	author landry;	state Exp;
branches;
next	1.12;
commitid	c7nnZJeHkzeXj7Pd;

1.12
date	2017.06.20.19.52.26;	author giovanni;	state Exp;
branches;
next	1.11;
commitid	B9ILSDzU2xt83bqc;

1.11
date	2016.09.02.14.20.31;	author giovanni;	state Exp;
branches;
next	1.10;
commitid	FABizfCeVAVMDsc6;

1.10
date	2016.03.09.14.50.11;	author giovanni;	state Exp;
branches
	1.10.2.1;
next	1.9;
commitid	kMrS9fQvG65cDUJa;

1.9
date	2014.07.15.18.17.06;	author giovanni;	state dead;
branches;
next	1.8;
commitid	pqOLzhTqg9WpiJnT;

1.8
date	2014.01.05.13.32.43;	author jasper;	state Exp;
branches
	1.8.2.1;
next	1.7;

1.7
date	2010.04.21.12.23.37;	author jasper;	state dead;
branches;
next	1.6;

1.6
date	2009.08.07.10.46.41;	author jasper;	state Exp;
branches
	1.6.2.1;
next	1.5;

1.5
date	2009.05.01.02.00.02;	author sthen;	state dead;
branches;
next	1.4;

1.4
date	2008.11.06.13.06.56;	author sthen;	state Exp;
branches;
next	1.3;

1.3
date	2007.12.27.17.42.50;	author jasper;	state Exp;
branches;
next	1.2;

1.2
date	2005.08.06.20.37.47;	author alek;	state Exp;
branches;
next	1.1;

1.1
date	2004.11.10.20.23.31;	author alek;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2004.11.10.20.23.31;	author alek;	state Exp;
branches;
next	;

1.6.2.1
date	2010.07.17.00.34.20;	author william;	state dead;
branches;
next	;

1.8.2.1
date	2014.01.05.13.34.49;	author jasper;	state Exp;
branches;
next	;

1.10.2.1
date	2016.11.14.18.41.12;	author giovanni;	state Exp;
branches;
next	;
commitid	aXsXiH1wVxBr9ZZf;


desc
@@


1.13
log
@Update to memcached 1.4.39.

Fixes CVE-2017-9951.

Create var/run/memcached with correct perms/ownership in rc_pre, and
document in README how to make it listen on a unix socket instead of
localhost/network.

ok giovanni@@ (maintainer)
@
text
@$OpenBSD: patch-memcached_c,v 1.12 2017/06/20 19:52:26 giovanni Exp $
Index: memcached.c
--- memcached.c.orig
+++ memcached.c
@@@@ -23,6 +23,7 @@@@
 #include <sys/uio.h>
 #include <ctype.h>
 #include <stdarg.h>
+#include <unistd.h>
 
 /* some POSIX systems need the following definition
  * to get mlockall flags out of sys/mman.h.  */
@@@@ -6733,6 +6734,32 @@@@ int main (int argc, char **argv) {
 
     if (pid_file != NULL) {
         save_pid(pid_file);
+    }
+
+    if (settings.socketpath != NULL) {
+        if (pid_file != NULL) {
+           if (pledge("stdio cpath unix", NULL) == -1) {
+              fprintf(stderr, "%s: pledge: %s\n", argv[0], strerror(errno));
+              exit(1);
+           }
+        } else {
+           if (pledge("stdio unix", NULL) == -1) {
+              fprintf(stderr, "%s: pledge: %s\n", argv[0], strerror(errno));
+              exit(1);
+           }
+        }
+    } else {
+        if (pid_file != NULL) {
+           if (pledge("stdio cpath inet", NULL) == -1) {
+              fprintf(stderr, "%s: pledge: %s\n", argv[0], strerror(errno));
+              exit(1);
+           }
+        } else {
+           if (pledge("stdio inet", NULL) == -1) {
+              fprintf(stderr, "%s: pledge: %s\n", argv[0], strerror(errno));
+              exit(1);
+           }
+        }
     }
 
     /* Drop privileges no longer needed */
@


1.12
log
@bugfix update to 1.4.37 and regen patches
@
text
@d1 1
a1 1
$OpenBSD: patch-memcached_c,v 1.11 2016/09/02 14:20:31 giovanni Exp $
d13 1
a13 1
@@@@ -6679,6 +6680,32 @@@@ int main (int argc, char **argv) {
@


1.11
log
@Update to 1.4.31
ok sthen@@
@
text
@d1 4
a4 3
$OpenBSD: patch-memcached_c,v 1.10 2016/03/09 14:50:11 giovanni Exp $
--- memcached.c.orig	Fri Jun 24 19:41:24 2016
+++ memcached.c	Thu Jun 30 00:02:09 2016
d13 1
a13 1
@@@@ -6100,6 +6101,32 @@@@ int main (int argc, char **argv) {
@


1.10
log
@Add pledge(2) support
hints from semarie@@ and sthen@@
ok sthen@@
@
text
@d1 3
a3 3
$OpenBSD$
--- memcached.c.orig	Thu Nov 19 08:19:56 2015
+++ memcached.c	Sun Mar  6 22:32:48 2016
d12 1
a12 1
@@@@ -5766,6 +5767,32 @@@@ int main (int argc, char **argv) {
@


1.10.2.1
log
@Security update to 1.4.33
ok sthen@@
@
text
@d1 3
a3 3
$OpenBSD: patch-memcached_c,v 1.11 2016/09/02 14:20:31 giovanni Exp $
--- memcached.c.orig	Fri Jun 24 19:41:24 2016
+++ memcached.c	Thu Jun 30 00:02:09 2016
d12 1
a12 1
@@@@ -6100,6 +6101,32 @@@@ int main (int argc, char **argv) {
@


1.9
log
@
Long overdue update to 1.4.20 and take maintainership
ok sthen@@
@
text
@d1 8
a8 12
$OpenBSD: patch-memcached_c,v 1.8 2014/01/05 13:32:43 jasper Exp $

buffer-overrun when logging keys (CVE-2013-0179)
https://github.com/memcached/memcached/commit/fbe823d9a61b5149cd6e3b5e17bd28dd3b8dd760

and fix segfault on specially crafted packet (CVE-2011-4971)
https://github.com/memcached/memcached/commit/6695ccbc525c36d693aaa3e8337b36aa0c784424

--- memcached.c.orig	Mon Jul 30 22:26:47 2012
+++ memcached.c	Thu Jan  2 16:59:32 2014
@@@@ -2149,7 +2149,12 @@@@ static void process_bin_delete(conn *c) {
     assert(c != NULL);
d10 31
a40 6
     if (settings.verbose > 1) {
-        fprintf(stderr, "Deleting %s\n", key);
+        int ii;
+        fprintf(stderr, "Deleting ");
+        for (ii = 0; ii < nkey; ++ii) {
+            fprintf(stderr, "%c", key[ii]);
a41 1
+        fprintf(stderr, "\n");
d44 1
a44 18
     if (settings.detail_enabled) {
@@@@ -3863,6 +3868,16 @@@@ static void drive_machine(conn *c) {
                 complete_nread(c);
                 break;
             }
+
+            /* Check if rbytes < 0, to prevent crash */
+            if (c->rlbytes < 0) {
+                if (settings.verbose) {
+                    fprintf(stderr, "Invalid rlbytes to read: len %d\n", c->rlbytes);
+                }
+                conn_set_state(c, conn_closing);
+                break;
+            }
+
             /* first check if we have leftovers in the conn_read buffer */
             if (c->rbytes > 0) {
                 int tocopy = c->rbytes > c->rlbytes ? c->rlbytes : c->rbytes;
@


1.8
log
@security fixes for CVE-2011-4971 and CVE-2013-0179

from donovan watteau
@
text
@d1 1
a1 1
$OpenBSD$
@


1.8.2.1
log
@security fixes for CVE-2011-4971 and CVE-2013-0179

from donovan watteau
@
text
@@


1.7
log
@SECURITY UPDATE of memcached to 1.4.3
* resolves the DoS in CVE-2010-1152

ok MAINTAINER
@
text
@d1 12
a12 12
$OpenBSD: patch-memcached_c,v 1.6 2009/08/07 10:46:41 jasper Exp $
--- memcached.c.orig	Thu Jul  9 13:16:24 2009
+++ memcached.c	Sat Jul 11 11:01:39 2009
@@@@ -93,7 +93,11 @@@@ static void write_and_free(conn *c, char *buf, int byt
 static int ensure_iov_space(conn *c);
 static int add_iov(conn *c, const void *buf, int len);
 static int add_msghdr(conn *c);
+
+/* OpenBSD has this in sys/types.h already. */
+#ifndef _SYS_ENDIAN_H_
 static uint64_t swap64(uint64_t in);
+#endif /* !_SYS_ENDIAN_H_ */
d14 8
a21 3
 /* time handling */
 static void set_current_time(void);  /* update the global variable holding
@@@@ -976,6 +980,7 @@@@ static void write_bin_response(conn *c, void *d, int h
a22 1
 }
d24 14
a37 20
+#ifndef _SYS_ENDIAN_H_
 /* Byte swap a 64-bit number */
 static uint64_t swap64(uint64_t in) {
 #ifdef ENDIAN_LITTLE
@@@@ -991,8 +996,9 @@@@ static uint64_t swap64(uint64_t in) {
 #else
     /* big-endian machines don't need byte swapping */
     return in;
-#endif
+#endif /* !ENDIAN_LITTLE */
 }
+#endif /* !_SYS_ENDIAN_H_ */
 
 static void complete_incr_bin(conn *c) {
     item *it;
@@@@ -1278,12 +1284,14 @@@@ static void append_ascii_stats(const char *key, const 
     char *pos = c->stats.buffer + c->stats.offset;
     uint32_t nbytes;
 
+    size_t s_pos = sizeof(pos);
d39 3
a41 57
     if (klen == 0 && vlen == 0) {
-        nbytes = sprintf(pos, "END\r\n");
+        nbytes = snprintf(pos, s_pos, "END\r\n");
     } else if (vlen == 0) {
-        nbytes = sprintf(pos, "STAT %s\r\n", key);
+        nbytes = snprintf(pos, s_pos, "STAT %s\r\n", key);
     } else {
-        nbytes = sprintf(pos, "STAT %s %s\r\n", key, val);
+        nbytes = snprintf(pos, s_pos, "STAT %s %s\r\n", key, val);
     }
 
     c->stats.offset += nbytes;
@@@@ -2248,6 +2256,7 @@@@ static inline void process_get_command(conn *c, token_
     int stats_get_cmds   = 0;
     int stats_get_misses = 0;
     int stats_get_hits[MAX_NUMBER_OF_SLAB_CLASSES];
+    size_t s_suffix;
     assert(c != NULL);
 
     memset(&stats_get_hits, 0, sizeof(stats_get_hits));
@@@@ -2326,7 +2335,9 @@@@ static inline void process_get_command(conn *c, token_
                     return;
                   }
                   *(c->suffixlist + i) = suffix;
-                  sprintf(suffix, " %llu\r\n", (unsigned long long)ITEM_get_cas(it));
+                  s_suffix = sizeof(suffix);
+                  snprintf(suffix, s_suffix,
+                      " %llu\r\n", (unsigned long long)ITEM_get_cas(it));
                   if (add_iov(c, "VALUE ", 6) != 0 ||
                       add_iov(c, ITEM_key(it), it->nkey) != 0 ||
                       add_iov(c, ITEM_suffix(it), it->nsuffix - 2) != 0 ||
@@@@ -2559,6 +2570,7 @@@@ enum delta_result_type do_add_delta(conn *c, item *it,
     char *ptr;
     uint64_t value;
     int res;
+    size_t s_buf = sizeof(buf);
 
     ptr = ITEM_data(it);
 
@@@@ -2586,7 +2598,7 @@@@ enum delta_result_type do_add_delta(conn *c, item *it,
     }
     pthread_mutex_unlock(&c->thread->stats.mutex);
 
-    sprintf(buf, "%llu", (unsigned long long)value);
+    snprintf(buf, s_buf, "%llu", (unsigned long long)value);
     res = strlen(buf);
     if (res + 2 > it->nbytes) { /* need to realloc */
         item *new_it;
@@@@ -3672,7 +3684,7 @@@@ static int server_socket_unix(const char *path, int ac
     memset(&addr, 0, sizeof(addr));
 
     addr.sun_family = AF_UNIX;
-    strcpy(addr.sun_path, path);
+    strlcpy(addr.sun_path, path, sizeof(addr.sun_path));
     old_umask = umask( ~(access_mask&0777));
     if (bind(sfd, (struct sockaddr *)&addr, sizeof(addr)) == -1) {
         perror("bind()");
@


1.6
log
@- update memcached to 1.4.0 ("many improvements have been made, upgrading is
recommended")

from Scott Vokes (MAINTAINER), thanks
@
text
@d1 1
a1 1
$OpenBSD$
@


1.6.2.1
log
@MFC:

SECURITY UPDATE to memcached-1.4.3

Resolves CVE-2010-1152
@
text
@d1 1
a1 1
$OpenBSD: patch-memcached_c,v 1.6 2009/08/07 10:46:41 jasper Exp $
@


1.5
log
@- maintenance update to 1.2.8 from Scott Vokes (maintainer).
- set REGRESS_TARGET to something more useful.
@
text
@d1 97
a97 15
$OpenBSD: patch-memcached_c,v 1.4 2008/11/06 13:06:56 sthen Exp $
--- memcached.c.orig	Wed Nov  5 14:36:30 2008
+++ memcached.c	Wed Nov  5 14:39:11 2008
@@@@ -2474,7 +2474,11 @@@@ static int server_socket(const int port, const bool is
      * that otherwise mess things up.
      */
     memset(&hints, 0, sizeof (hints));
+#ifdef __OpenBSD__
+    hints.ai_flags = AI_PASSIVE;
+#else
     hints.ai_flags = AI_PASSIVE|AI_ADDRCONFIG;
+#endif
     if (is_udp)
     {
         hints.ai_protocol = IPPROTO_UDP;
@


1.4
log
@update to 1.2.6, from arn at antora.ru on ports@@.

- major crash fixes: "If you have stability issues with
any previous release, please upgrade to this one."
- minor bugfixes, updates
- ipv6 support
- "noreply" mode for many commands
- out of memory errors more clear
- added eviction/OOM tracking per slab class
@
text
@d1 1
a1 1
$OpenBSD$
@


1.3
log
@- update memcached to 1.2.4
- install documentation
- remove maintainer (alek@@) per his request

ok alek@@
@
text
@d1 15
a15 12
$OpenBSD: patch-memcached_c,v 1.2 2005/08/06 20:37:47 alek Exp $
--- memcached.c.orig	Tue Dec 18 23:54:36 2007
+++ memcached.c	Tue Dec 18 23:54:47 2007
@@@@ -19,7 +19,7 @@@@ std *
 #include <sys/stat.h>
 #include <sys/socket.h>
 #include <sys/un.h>
-#include <sys/signal.h>
+#include <signal.h>
 #include <sys/resource.h>
 #include <sys/uio.h>
 
@


1.2
log
@Update to 1.1.12
@
text
@d1 4
a4 4
$OpenBSD: patch-memcached_c,v 1.1.1.1 2004/11/10 20:23:31 alek Exp $
--- memcached.c.orig	Tue Apr  5 02:10:26 2005
+++ memcached.c	Sat Aug  6 22:11:20 2005
@@@@ -21,7 +21,7 @@@@
a5 1
 #include <sys/time.h>
d7 1
d11 1
a11 4
 /* some POSIX systems need the following definition
  * to get mlockall flags out of sys/mman.h.  */
@@@@ -333,7 +333,7 @@@@ void process_stat(conn *c, char *command
         getrusage(RUSAGE_SELF, &usage);
a12 6
         pos += sprintf(pos, "STAT pid %u\r\n", pid);
-        pos += sprintf(pos, "STAT uptime %lu\r\n", now - stats.started);
+        pos += sprintf(pos, "STAT uptime %u\r\n", now - stats.started);
         pos += sprintf(pos, "STAT time %ld\r\n", now);
         pos += sprintf(pos, "STAT version " VERSION "\r\n");
         pos += sprintf(pos, "STAT rusage_user %ld.%06ld\r\n", usage.ru_utime.tv_sec, usage.ru_utime.tv_usec);
@


1.1
log
@Initial revision
@
text
@d1 3
a3 3
$OpenBSD$
--- memcached.c.orig	Wed Nov 10 16:32:50 2004
+++ memcached.c	Wed Nov 10 18:37:25 2004
d13 1
a13 1
@@@@ -320,11 +320,11 @@@@ void process_stat(conn *c, char *command
d19 1
a19 1
         pos += sprintf(pos, "STAT time %u\r\n", now);
d21 1
a21 16
-        pos += sprintf(pos, "STAT rusage_user %u:%u\r\n", usage.ru_utime.tv_sec, usage.ru_utime.tv_usec);
-        pos += sprintf(pos, "STAT rusage_system %u:%u\r\n", usage.ru_stime.tv_sec, usage.ru_stime.tv_usec);
+        pos += sprintf(pos, "STAT rusage_user %lu:%lu\r\n", usage.ru_utime.tv_sec, usage.ru_utime.tv_usec);
+        pos += sprintf(pos, "STAT rusage_system %lu:%lu\r\n", usage.ru_stime.tv_sec, usage.ru_stime.tv_usec);
         pos += sprintf(pos, "STAT curr_items %u\r\n", stats.curr_items);
         pos += sprintf(pos, "STAT total_items %u\r\n", stats.total_items);
         pos += sprintf(pos, "STAT bytes %llu\r\n", stats.curr_bytes);
@@@@ -504,7 +504,7 @@@@ void process_command(conn *c, char *comm
         int len, res;
         item *it;
 
-        res = sscanf(command, "%*s %250s %u %lu %d\n", key, &flags, &expire, &len);
+        res = sscanf(command, "%*s %250s %u %u %d\n", key, &flags, &expire, &len);
         if (res!=4 || strlen(key)==0 ) {
             out_string(c, "CLIENT_ERROR bad command line format");
             return;
@


1.1.1.1
log
@Import memcached 1.1.11

memcached is a high-performance, distributed memory object caching
system, generic in nature, but intended for use in speeding up dynamic
web applications by alleviating database load.

help and ok naddy@@
@
text
@@
