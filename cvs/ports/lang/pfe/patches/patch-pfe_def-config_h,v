head	1.1;
access;
symbols
	OPENBSD_6_2:1.1.0.16
	OPENBSD_6_2_BASE:1.1
	OPENBSD_6_1:1.1.0.14
	OPENBSD_6_1_BASE:1.1
	OPENBSD_6_0:1.1.0.12
	OPENBSD_6_0_BASE:1.1
	OPENBSD_5_9:1.1.0.8
	OPENBSD_5_9_BASE:1.1
	OPENBSD_5_8:1.1.0.10
	OPENBSD_5_8_BASE:1.1
	OPENBSD_5_7:1.1.0.6
	OPENBSD_5_7_BASE:1.1
	OPENBSD_5_6:1.1.0.4
	OPENBSD_5_6_BASE:1.1
	OPENBSD_5_5:1.1.0.2
	OPENBSD_5_5_BASE:1.1;
locks; strict;
comment	@# @;


1.1
date	2014.01.21.20.45.43;	author miod;	state Exp;
branches;
next	;


desc
@@


1.1
log
@Make sure `cells' are aligned to pointer size boundaries, using the same logic
deciding whether they need to be `int' or `long' sized (really `void *' sized).
Unbreaks 64-bit platforms with strict alignment (alpha and sparc64 where this
had been detected, but likely mips64 as well).

ok landry@@
@
text
@$OpenBSD$

Make sure cell pointers are aligned to pointer boundaries, for the sake of
strict-alignment 64-bit platforms.

--- pfe/def-config.h.orig	Sun May 11 12:29:19 2008
+++ pfe/def-config.h	Sun Jan 19 19:39:18 2014
@@@@ -127,7 +127,13 @@@@ typedef int mode_t;
 #endif
 
 #ifndef PFE_ALIGNOF_CELL
-#define PFE_ALIGNOF_CELL PFE_SIZEOF_INT
+# if defined PFE_SIZEOF_INT && PFE_SIZEOF_INT >= PFE_SIZEOF_VOIDP
+# define PFE_ALIGNOF_CELL PFE_SIZEOF_INT
+# elif defined PFE_SIZEOF_LONG && PFE_SIZEOF_LONG >= PFE_SIZEOF_VOIDP
+# define PFE_ALIGNOF_CELL PFE_SIZEOF_LONG
+# else
+# error cell type and size not detected.
+# endif
 #endif
 #ifndef PFE_ALIGNOF_SFLOAT
 #define PFE_ALIGNOF_SFLOAT PFE_SIZEOF_FLOAT
@
