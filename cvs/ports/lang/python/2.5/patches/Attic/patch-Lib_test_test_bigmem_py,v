head	1.2;
access;
symbols
	OPENBSD_4_4:1.1.0.2
	OPENBSD_4_4_BASE:1.1;
locks; strict;
comment	@# @;


1.2
date	2009.01.01.21.03.27;	author djm;	state dead;
branches;
next	1.1;

1.1
date	2008.08.06.03.23.31;	author djm;	state Exp;
branches;
next	;


desc
@@


1.2
log
@Updates and garbage collect all three Python ports:

    2.4.4 => 2.4.8
    2.5.2 => 2.5.4
    2.6 => 2.6.1

Python 2.4 and 2.5 lose their build knobs to match 2.6.

Removes no longer needed Python 2.5 security patches backported
from the release25-maint SVN branch.

Remove the -bz2 subpackage from all three versions. It is silly
to make a subpackage to avoid depending on something tiny and
compatibly licensed.

Python 2.4 and 2.5 lose their -expat subpackages; expat has been
in base for some time.

Python 2.5 loses its sqlite subpackge. Again, sqlite is tiny,
compatibly licensed and is depended upon by more and more
applications. This brings it into line with the 2.6 version.

Rework all three version's handling of setup.py. Rather than regex
replacing LOCALBASE and X11BASE into setup.py post-configure, these
are passed in though environment variables. Will save hours of
frustrated cursing familiar to anyone who has accidently used the
update-patches target after configure and had to go back and redo
all the substitutions.

Rework the patching of setup.py for 2.4 and 2.5 to be more like
what we do for 2.6. I.e. keep the diff minimal and avoid deleting
huge blocks of code, so the diff has a chance of applying without
massive hand-editing each patch release.

Fix .py paths in installed .pyc files (patch from eric@@)

feedback from several, particularly eric@@, ajacoutot@@ and Ingo
Schwarze; "get it in" ajacoutot@@
@
text
@$OpenBSD: patch-Lib_test_test_bigmem_py,v 1.1 2008/08/06 03:23:31 djm Exp $
--- Lib/test/test_bigmem.py.orig	Sat Dec  1 08:53:17 2007
+++ Lib/test/test_bigmem.py	Tue Aug  5 18:18:52 2008
@@@@ -1,5 +1,5 @@@@
 from test import test_support
-from test.test_support import bigmemtest, _1G, _2G
+from test.test_support import bigmemtest, _1G, _2G, _4G, precisionbigmemtest
 
 import unittest
 import operator
@@@@ -54,6 +54,22 @@@@ class StrTest(unittest.TestCase):
         self.assertEquals(s[lpadsize:-rpadsize], SUBSTR)
         self.assertEquals(s.strip(), SUBSTR.strip())
 
+    @@precisionbigmemtest(size=_2G - 1, memuse=1)
+    def test_center_unicode(self, size):
+        SUBSTR = u' abc def ghi'
+        try:
+            s = SUBSTR.center(size)
+        except OverflowError:
+            pass # acceptable on 32-bit
+        else:
+            self.assertEquals(len(s), size)
+            lpadsize = rpadsize = (len(s) - len(SUBSTR)) // 2
+            if len(s) % 2:
+                lpadsize += 1
+            self.assertEquals(s[lpadsize:-rpadsize], SUBSTR)
+            self.assertEquals(s.strip(), SUBSTR.strip())
+            del s
+
     @@bigmemtest(minsize=_2G, memuse=2)
     def test_count(self, size):
         SUBSTR = ' abc def ghi'
@@@@ -70,11 +86,45 @@@@ class StrTest(unittest.TestCase):
         s = '.' * size
         self.assertEquals(len(s.decode('utf-8')), size)
 
+    def basic_encode_test(self, size, enc, c=u'.', expectedsize=None):
+        if expectedsize is None:
+            expectedsize = size
+
+        s = c * size
+        self.assertEquals(len(s.encode(enc)), expectedsize)
+
     @@bigmemtest(minsize=_2G + 2, memuse=3)
     def test_encode(self, size):
-        s = u'.' * size
-        self.assertEquals(len(s.encode('utf-8')), size)
+        return self.basic_encode_test(size, 'utf-8')
 
+    @@precisionbigmemtest(size=_4G / 6 + 2, memuse=2)
+    def test_encode_raw_unicode_escape(self, size):
+        try:
+            return self.basic_encode_test(size, 'raw_unicode_escape')
+        except MemoryError:
+            pass # acceptable on 32-bit
+
+    @@precisionbigmemtest(size=_4G / 5 + 70, memuse=3)
+    def test_encode_utf7(self, size):
+        try:
+            return self.basic_encode_test(size, 'utf7')
+        except MemoryError:
+            pass # acceptable on 32-bit
+
+    @@precisionbigmemtest(size=_2G-1, memuse=2)
+    def test_decodeascii(self, size):
+        return self.basic_encode_test(size, 'ascii', c='A')
+
+    @@precisionbigmemtest(size=_4G / 5, memuse=6+2)
+    def test_unicode_repr_oflw(self, size):
+        try:
+            s = u"\uAAAA"*size
+            r = repr(s)
+        except MemoryError:
+            pass # acceptable on 32-bit
+        else:
+            self.failUnless(s == eval(r))
+
     @@bigmemtest(minsize=_2G, memuse=2)
     def test_endswith(self, size):
         SUBSTR = ' abc def ghi'
@@@@ -459,6 +509,11 @@@@ class StrTest(unittest.TestCase):
         self.assertEquals(s.count('\\'), size)
         self.assertEquals(s.count('0'), size * 2)
 
+    @@bigmemtest(minsize=2**32 / 5, memuse=6+2)
+    def test_unicode_repr(self, size):
+        s = u"\uAAAA" * size
+        self.failUnless(len(repr(s)) > size)
+
     # This test is meaningful even with size < 2G, as long as the
     # doubled string is > 2G (but it tests more if both are > 2G :)
     @@bigmemtest(minsize=_1G + 2, memuse=3)
@@@@ -642,6 +697,35 @@@@ class TupleTest(unittest.TestCase):
     def test_repeat_large(self, size):
         return self.basic_test_repeat(size)
 
+    @@bigmemtest(minsize=_1G - 1, memuse=12)
+    def test_repeat_large_2(self, size):
+        return self.basic_test_repeat(size)
+
+    @@precisionbigmemtest(size=_1G - 1, memuse=9)
+    def test_from_2G_generator(self, size):
+        try:
+            t = tuple(xrange(size))
+        except MemoryError:
+            pass # acceptable on 32-bit
+        else:
+            count = 0
+            for item in t:
+                self.assertEquals(item, count)
+                count += 1
+            self.assertEquals(count, size)
+
+    @@precisionbigmemtest(size=_1G - 25, memuse=9)
+    def test_from_almost_2G_generator(self, size):
+        try:
+            t = tuple(xrange(size))
+            count = 0
+            for item in t:
+                self.assertEquals(item, count)
+                count += 1
+            self.assertEquals(count, size)
+        except MemoryError:
+            pass # acceptable, expected on 32-bit
+
     # Like test_concat, split in two.
     def basic_test_repr(self, size):
         t = (0,) * size
@@@@ -957,8 +1041,23 @@@@ class ListTest(unittest.TestCase):
         self.assertEquals(l[:10], [1] * 10)
         self.assertEquals(l[-10:], [5] * 10)
 
+class BufferTest(unittest.TestCase):
+
+    @@precisionbigmemtest(size=_1G, memuse=4)
+    def test_repeat(self, size):
+        try:
+            b = buffer("AAAA")*size
+        except MemoryError:
+            pass # acceptable on 32-bit
+        else:
+            count = 0
+            for c in b:
+                self.assertEquals(c, 'A')
+                count += 1
+            self.assertEquals(count, size*4)
+
 def test_main():
-    test_support.run_unittest(StrTest, TupleTest, ListTest)
+    test_support.run_unittest(StrTest, TupleTest, ListTest, BufferTest)
 
 if __name__ == '__main__':
     if len(sys.argv) > 1:
@


1.1
log
@Fixes for multiple security vulnerabilities:

        CVE-2008-1679 CVE-2008-1721 CVE-2008-1887
        CVE-2008-2316 CVE-2008-3142 CVE-2008-3144

Patches cherrypicked with assistance of val.masutin AT gmail.com and
Toni Mueller.

Tested by sthen@@ naddy@@ ok pvalchev@@
@
text
@d1 1
a1 1
$OpenBSD$
@

