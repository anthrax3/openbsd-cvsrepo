head	1.2;
access;
symbols
	OPENBSD_4_4:1.1.0.2
	OPENBSD_4_4_BASE:1.1;
locks; strict;
comment	@# @;


1.2
date	2009.01.01.21.03.27;	author djm;	state dead;
branches;
next	1.1;

1.1
date	2008.08.06.03.23.31;	author djm;	state Exp;
branches;
next	;


desc
@@


1.2
log
@Updates and garbage collect all three Python ports:

    2.4.4 => 2.4.8
    2.5.2 => 2.5.4
    2.6 => 2.6.1

Python 2.4 and 2.5 lose their build knobs to match 2.6.

Removes no longer needed Python 2.5 security patches backported
from the release25-maint SVN branch.

Remove the -bz2 subpackage from all three versions. It is silly
to make a subpackage to avoid depending on something tiny and
compatibly licensed.

Python 2.4 and 2.5 lose their -expat subpackages; expat has been
in base for some time.

Python 2.5 loses its sqlite subpackge. Again, sqlite is tiny,
compatibly licensed and is depended upon by more and more
applications. This brings it into line with the 2.6 version.

Rework all three version's handling of setup.py. Rather than regex
replacing LOCALBASE and X11BASE into setup.py post-configure, these
are passed in though environment variables. Will save hours of
frustrated cursing familiar to anyone who has accidently used the
update-patches target after configure and had to go back and redo
all the substitutions.

Rework the patching of setup.py for 2.4 and 2.5 to be more like
what we do for 2.6. I.e. keep the diff minimal and avoid deleting
huge blocks of code, so the diff has a chance of applying without
massive hand-editing each patch release.

Fix .py paths in installed .pyc files (patch from eric@@)

feedback from several, particularly eric@@, ajacoutot@@ and Ingo
Schwarze; "get it in" ajacoutot@@
@
text
@$OpenBSD: patch-Include_pymem_h,v 1.1 2008/08/06 03:23:31 djm Exp $
--- Include/pymem.h.orig	Thu Feb 14 22:26:18 2008
+++ Include/pymem.h	Tue Aug  5 18:18:52 2008
@@@@ -67,8 +67,12 @@@@ PyAPI_FUNC(void) PyMem_Free(void *);
    for malloc(0), which would be treated as an error. Some platforms
    would return a pointer with no memory behind it, which would break
    pymalloc. To solve these problems, allocate an extra byte. */
-#define PyMem_MALLOC(n)         malloc((n) ? (n) : 1)
-#define PyMem_REALLOC(p, n)     realloc((p), (n) ? (n) : 1)
+/* Returns NULL to indicate error if a negative size or size larger than
+   Py_ssize_t can represent is supplied.  Helps prevents security holes. */
+#define PyMem_MALLOC(n)		(((n) < 0 || (n) > PY_SSIZE_T_MAX) ? NULL \
+				: malloc((n) ? (n) : 1))
+#define PyMem_REALLOC(p, n)	(((n) < 0 || (n) > PY_SSIZE_T_MAX) ? NULL \
+				: realloc((p), (n) ? (n) : 1))
 #define PyMem_FREE		free
 
 #endif	/* PYMALLOC_DEBUG */
@@@@ -77,24 +81,31 @@@@ PyAPI_FUNC(void) PyMem_Free(void *);
  * Type-oriented memory interface
  * ==============================
  *
- * These are carried along for historical reasons.  There's rarely a good
- * reason to use them anymore (you can just as easily do the multiply and
- * cast yourself).
+ * Allocate memory for n objects of the given type.  Returns a new pointer
+ * or NULL if the request was too large or memory allocation failed.  Use
+ * these macros rather than doing the multiplication yourself so that proper
+ * overflow checking is always done.
  */
 
 #define PyMem_New(type, n) \
-  ( assert((n) <= PY_SIZE_MAX / sizeof(type)) , \
+  ( ((n) > PY_SSIZE_T_MAX / sizeof(type)) ? NULL : \
 	( (type *) PyMem_Malloc((n) * sizeof(type)) ) )
 #define PyMem_NEW(type, n) \
-  ( assert((n) <= PY_SIZE_MAX / sizeof(type)) , \
+  ( ((n) > PY_SSIZE_T_MAX / sizeof(type)) ? NULL : \
 	( (type *) PyMem_MALLOC((n) * sizeof(type)) ) )
 
+/*
+ * The value of (p) is always clobbered by this macro regardless of success.
+ * The caller MUST check if (p) is NULL afterwards and deal with the memory
+ * error if so.  This means the original value of (p) MUST be saved for the
+ * caller's memory error handler to not lose track of it.
+ */
 #define PyMem_Resize(p, type, n) \
-  ( assert((n) <= PY_SIZE_MAX / sizeof(type)) , \
-	( (p) = (type *) PyMem_Realloc((p), (n) * sizeof(type)) ) )
+  ( (p) = ((n) > PY_SSIZE_T_MAX / sizeof(type)) ? NULL : \
+	(type *) PyMem_Realloc((p), (n) * sizeof(type)) )
 #define PyMem_RESIZE(p, type, n) \
-  ( assert((n) <= PY_SIZE_MAX / sizeof(type)) , \
-	( (p) = (type *) PyMem_REALLOC((p), (n) * sizeof(type)) ) )
+  ( (p) = ((n) > PY_SSIZE_T_MAX / sizeof(type)) ? NULL : \
+	(type *) PyMem_REALLOC((p), (n) * sizeof(type)) )
 
 /* PyMem{Del,DEL} are left over from ancient days, and shouldn't be used
  * anymore.  They're just confusing aliases for PyMem_{Free,FREE} now.
@


1.1
log
@Fixes for multiple security vulnerabilities:

        CVE-2008-1679 CVE-2008-1721 CVE-2008-1887
        CVE-2008-2316 CVE-2008-3142 CVE-2008-3144

Patches cherrypicked with assistance of val.masutin AT gmail.com and
Toni Mueller.

Tested by sthen@@ naddy@@ ok pvalchev@@
@
text
@d1 1
a1 1
$OpenBSD$
@

