head	1.1;
access;
symbols
	OPENBSD_5_2:1.1.0.2;
locks; strict;
comment	@# @;


1.1
date	2013.01.15.15.22.57;	author abieber;	state dead;
branches
	1.1.2.1;
next	;

1.1.2.1
date	2013.01.15.15.22.57;	author abieber;	state Exp;
branches;
next	;


desc
@@


1.1
log
@file patch-src_v8_typed_array_cc was initially added on branch OPENBSD_5_2.
@
text
@@


1.1.2.1
log
@add a fix for 32bit size/index overflow
 - https://github.com/joyent/node/commit/ed825f488867d7586bee6ca4feb5fe5b0461775e

OK jasper@@
@
text
@a0 51
$OpenBSD$

This patch fixes 32bit size/index overflow
 - https://github.com/joyent/node/commit/ed825f488867d7586bee6ca4feb5fe5b0461775e

--- src/v8_typed_array.cc.orig	Sat Jul  7 16:15:17 2012
+++ src/v8_typed_array.cc	Sun Jan 13 08:06:06 2013
@@@@ -21,6 +21,7 @@@@
 
 #include <stdlib.h>  // calloc, etc
 #include <string.h>  // memmove
+#include <stdint.h>
 
 #include "v8_typed_array.h"
 #include "node_buffer.h"
@@@@ -722,11 +723,14 @@@@ class DataView {
     // TODO(deanm): All of these things should be cacheable.
     int element_size = SizeOfArrayElementForType(
         args.This()->GetIndexedPropertiesExternalArrayDataType());
-    int size = args.This()->GetIndexedPropertiesExternalArrayDataLength() *
-               element_size;
+    assert(element_size > 0);
+    int size = args.This()->GetIndexedPropertiesExternalArrayDataLength();
+    assert(size >= 0);
 
-    if (index + sizeof(T) > (unsigned)size)  // TODO(deanm): integer overflow.
+    if (static_cast<uint64_t>(index) + sizeof(T) >
+        static_cast<uint64_t>(size) * element_size) {
       return ThrowError("Index out of range.");
+    }
 
     void* ptr = args.This()->GetIndexedPropertiesExternalArrayData();
     return cTypeToValue<T>(getValue<T>(ptr, index, !little_endian));
@@@@ -742,11 +746,14 @@@@ class DataView {
     // TODO(deanm): All of these things should be cacheable.
     int element_size = SizeOfArrayElementForType(
         args.This()->GetIndexedPropertiesExternalArrayDataType());
-    int size = args.This()->GetIndexedPropertiesExternalArrayDataLength() *
-               element_size;
+    assert(element_size > 0);
+    int size = args.This()->GetIndexedPropertiesExternalArrayDataLength();
+    assert(size >= 0);
 
-    if (index + sizeof(T) > (unsigned)size)  // TODO(deanm): integer overflow.
+    if (static_cast<uint64_t>(index) + sizeof(T) >
+        static_cast<uint64_t>(size) * element_size) {
       return ThrowError("Index out of range.");
+    }
 
     void* ptr = args.This()->GetIndexedPropertiesExternalArrayData();
     setValue<T>(ptr, index, valueToCType<T>(args[1]), !little_endian);
@

