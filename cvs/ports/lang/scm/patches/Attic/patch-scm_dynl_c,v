head	1.4;
access;
symbols
	OPENBSD_3_6:1.3.0.16
	OPENBSD_3_6_BASE:1.3
	OPENBSD_3_5:1.3.0.14
	OPENBSD_3_5_BASE:1.3
	OPENBSD_3_4:1.3.0.12
	OPENBSD_3_4_BASE:1.3
	OPENBSD_3_3:1.3.0.10
	OPENBSD_3_3_BASE:1.3
	OPENBSD_3_2:1.3.0.8
	OPENBSD_3_2_BASE:1.3
	OPENBSD_3_1:1.3.0.6
	OPENBSD_3_1_BASE:1.3
	OPENBSD_3_0:1.3.0.4
	OPENBSD_3_0_BASE:1.3
	OPENBSD_2_9_TRACKING_SWITCH:1.3
	OPENBSD_2_9:1.3.0.2
	OPENBSD_2_9_BASE:1.3;
locks; strict;
comment	@# @;


1.4
date	2004.09.15.19.13.34;	author espie;	state dead;
branches;
next	1.3;

1.3
date	2001.02.03.20.42.46;	author espie;	state Exp;
branches;
next	1.2;

1.2
date	2001.02.01.12.26.14;	author espie;	state Exp;
branches;
next	1.1;

1.1
date	2001.01.31.22.51.41;	author espie;	state Exp;
branches;
next	;


desc
@@


1.4
log
@and patches. most removed as integrated.
@
text
@$OpenBSD: patch-scm_dynl_c,v 1.3 2001/02/03 20:42:46 espie Exp $
--- dynl.c.orig	Tue Sep  7 15:14:00 1999
+++ dynl.c	Thu Feb  1 00:50:38 2001
@@@@ -419,7 +419,23 @@@@ SCM l_dyn_call(symb, shl)
   ASSERT(NIMP(symb) && STRINGP(symb), symb, ARG1, s_call);
   ASSERT(NIMP(shl) && CAR(shl)==tc16_shl, shl, ARG2, s_call);
   DEFER_INTS;
-  func = dlsym(SHL(shl), CHARS(symb));
+#ifdef __OpenBSD__
+# ifndef __ELF__
+  {
+  char *n;
+
+  n = malloc(LENGTH(symb)+2);
+  if (n) {
+  	*n = '_';
+	strcpy(n+1, CHARS(symb));
+	func = dlsym(SHL(shl), n);
+	free(n);
+  }
+  }
+# endif
+#endif
+  if (!func)
+        func = dlsym(SHL(shl), CHARS(symb));
   if (!func) {
     char *dlr = dlerror();
     ALLOW_INTS;
@@@@ -448,7 +464,23 @@@@ SCM l_dyn_main_call(symb, shl, args)
   ASSERT(NIMP(symb) && STRINGP(symb), symb, ARG1, s_main_call);
   ASSERT(NIMP(shl) && CAR(shl)==tc16_shl, shl, ARG2, s_main_call);
   DEFER_INTS;
-  func = dlsym(SHL(shl), CHARS(symb));
+#ifdef __OpenBSD__
+# ifndef __ELF__
+  {
+  char *n;
+
+  n = malloc(LENGTH(symb)+2);
+  if (n) {
+  	*n = '_';
+	strcpy(n+1, CHARS(symb));
+	func = dlsym(SHL(shl), n);
+	free(n);
+  }
+  }
+# endif
+#endif
+  if (!func)
+        func = dlsym(SHL(shl), CHARS(symb));
   if (!func) {
     char *dlr = dlerror();
     ALLOW_INTS;
@


1.3
log
@slib split into a separate port
@
text
@d1 1
a1 1
$OpenBSD: patch-scm_dynl_c,v 1.2 2001/02/01 12:26:14 espie Exp $
@


1.2
log
@Sigh, going to all that effort to add an underscore and then call dlsym
on the wrong name.
@
text
@d1 3
a3 3
$OpenBSD: patch-scm_dynl_c,v 1.1 2001/01/31 22:51:41 espie Exp $
--- scm/dynl.c.orig	Tue Sep  7 15:14:00 1999
+++ scm/dynl.c	Thu Feb  1 00:50:38 2001
@


1.1
log
@Clean up a few details.
- segregate slib in a separate directory, install a few more files for it
(ready for a separate package, whenever we get another scheme).
- let dynamic loading work on archaic a.out systems.
- install a few more *.scm programs. Probably misses a few files for a
full infrastructure to build other extensions (should create a libscm.a
on static systems ?)

- allows for x11 extension, even though it's very basic.

Flavorize it.

Issue: flavor sicp ?
@
text
@d1 1
a1 1
$OpenBSD: update-patches,v 1.3 2000/06/09 17:08:37 espie Exp $
d3 1
a3 1
+++ scm/dynl.c	Wed Jan 31 23:01:47 2001
d18 1
a18 1
+	func = dlsym(SHL(shl), CHARS(symb));
d43 1
a43 1
+	func = dlsym(SHL(shl), CHARS(symb));
@

