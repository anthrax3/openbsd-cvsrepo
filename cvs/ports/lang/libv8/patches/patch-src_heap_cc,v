head	1.1;
branch	1.1.1;
access;
symbols
	OPENBSD_6_1:1.1.1.1.0.18
	OPENBSD_6_1_BASE:1.1.1.1
	OPENBSD_6_0:1.1.1.1.0.16
	OPENBSD_6_0_BASE:1.1.1.1
	OPENBSD_5_9:1.1.1.1.0.12
	OPENBSD_5_9_BASE:1.1.1.1
	OPENBSD_5_8:1.1.1.1.0.14
	OPENBSD_5_8_BASE:1.1.1.1
	OPENBSD_5_7:1.1.1.1.0.10
	OPENBSD_5_7_BASE:1.1.1.1
	OPENBSD_5_6:1.1.1.1.0.8
	OPENBSD_5_6_BASE:1.1.1.1
	OPENBSD_5_5:1.1.1.1.0.6
	OPENBSD_5_5_BASE:1.1.1.1
	OPENBSD_5_4:1.1.1.1.0.4
	OPENBSD_5_4_BASE:1.1.1.1
	OPENBSD_5_3:1.1.1.1.0.2
	OPENBSD_5_3_BASE:1.1.1.1
	abieber_20121013:1.1.1.1
	abieber:1.1.1;
locks; strict;
comment	@# @;


1.1
date	2012.10.13.15.09.58;	author abieber;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2012.10.13.15.09.58;	author abieber;	state Exp;
branches;
next	;


desc
@@



1.1
log
@Initial revision
@
text
@$OpenBSD$
--- src/heap.cc.orig	Tue Oct  9 08:34:36 2012
+++ src/heap.cc	Tue Oct  9 08:34:45 2012
@@@@ -5873,6 +5873,29 @@@@ bool Heap::ConfigureHeap(int max_semispace_size,
   initial_semispace_size_ = Min(initial_semispace_size_, max_semispace_size_);
   external_allocation_limit_ = 16 * max_semispace_size_;
 
+  intptr_t max_virtual = OS::MaxVirtualMemory();
+
+  if (max_virtual > 0) {
+    intptr_t half = max_virtual >> 1;
+    intptr_t quarter = max_virtual >> 2;
+    // If we have limits on the amount of virtual memory we can use then we may
+    // be forced to lower the allocation limits.  We reserve one quarter of the
+    // memory for young space and off-heap data.  The rest is distributed as
+    // described below.
+    if (code_range_size_ > 0) {
+      // Reserve a quarter of the memory for the code range.  The old space
+      // heap gets the remaining half.  There is some unavoidable double
+      // counting going on here since the heap size is measured in committed
+      // virtual memory and the code range is only reserved virtual memory.
+      code_range_size_ = Min(code_range_size_, quarter);
+      max_old_generation_size_ = Min(max_old_generation_size_, half);
+    } else {
+      // Reserve three quarters of the memory for the old space heap including
+      // the executable code.
+      max_old_generation_size_ = Min(max_old_generation_size_, half + quarter);
+    }
+  }
+
   // The old generation is paged and needs at least one page for each space.
   int paged_space_count = LAST_PAGED_SPACE - FIRST_PAGED_SPACE + 1;
   max_old_generation_size_ = Max(static_cast<intptr_t>(paged_space_count *
@


1.1.1.1
log
@import lang/libv8 - a javascript engine for clients and servers

OK jeremy@@, sthen@@
@
text
@@
