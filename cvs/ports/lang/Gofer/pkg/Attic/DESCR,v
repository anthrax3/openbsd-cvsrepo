head	1.3;
access;
symbols
	OPENBSD_4_7:1.2.0.22
	OPENBSD_4_7_BASE:1.2
	OPENBSD_4_6:1.2.0.20
	OPENBSD_4_6_BASE:1.2
	OPENBSD_4_5:1.2.0.18
	OPENBSD_4_5_BASE:1.2
	OPENBSD_4_4:1.2.0.16
	OPENBSD_4_4_BASE:1.2
	OPENBSD_4_3:1.2.0.14
	OPENBSD_4_3_BASE:1.2
	OPENBSD_4_2:1.2.0.12
	OPENBSD_4_2_BASE:1.2
	OPENBSD_4_1:1.2.0.10
	OPENBSD_4_1_BASE:1.2
	OPENBSD_4_0:1.2.0.8
	OPENBSD_4_0_BASE:1.2
	OPENBSD_3_9:1.2.0.6
	OPENBSD_3_9_BASE:1.2
	OPENBSD_3_8:1.2.0.4
	OPENBSD_3_8_BASE:1.2
	OPENBSD_3_7:1.2.0.2
	OPENBSD_3_7_BASE:1.2
	OPENBSD_3_6:1.1.1.1.0.28
	OPENBSD_3_6_BASE:1.1.1.1
	OPENBSD_3_5:1.1.1.1.0.26
	OPENBSD_3_5_BASE:1.1.1.1
	OPENBSD_3_4:1.1.1.1.0.24
	OPENBSD_3_4_BASE:1.1.1.1
	OPENBSD_3_3:1.1.1.1.0.22
	OPENBSD_3_3_BASE:1.1.1.1
	OPENBSD_3_2:1.1.1.1.0.20
	OPENBSD_3_2_BASE:1.1.1.1
	OPENBSD_3_1:1.1.1.1.0.18
	OPENBSD_3_1_BASE:1.1.1.1
	OPENBSD_3_0:1.1.1.1.0.16
	OPENBSD_3_0_BASE:1.1.1.1
	OPENBSD_2_9_TRACKING_SWITCH:1.1.1.1
	OPENBSD_2_9:1.1.1.1.0.14
	OPENBSD_2_9_BASE:1.1.1.1
	OPENBSD_2_8:1.1.1.1.0.12
	OPENBSD_2_8_BASE:1.1.1.1
	OPENBSD_2_7:1.1.1.1.0.10
	OPENBSD_2_7_BASE:1.1.1.1
	OPENBSD_2_6:1.1.1.1.0.8
	OPENBSD_2_6_BASE:1.1.1.1
	OPENBSD_2_5:1.1.1.1.0.6
	OPENBSD_2_5_BASE:1.1.1.1
	OPENBSD_2_4:1.1.1.1.0.4
	OPENBSD_2_4_BASE:1.1.1.1
	OPENBSD_2_3:1.1.1.1.0.2
	OPENBSD_2_3_BASE:1.1.1.1
	gofer-2_30a:1.1.1.1
	gofer:1.1.1;
locks; strict;
comment	@# @;


1.3
date	2010.07.22.18.33.42;	author kili;	state dead;
branches;
next	1.2;

1.2
date	2005.03.15.01.57.04;	author db;	state Exp;
branches;
next	1.1;

1.1
date	98.02.03.06.01.58;	author don;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	98.02.03.06.01.58;	author don;	state Exp;
branches;
next	;


desc
@@


1.3
log
@Remove Gofer. The ports tree isn't a software museum, and the
Haskell language isn't the same as more than a decade ago.

Suggested by Daniel Dickman, and since the other ports guys
are only joking around, I think nobody will miss it.

While here, also remove xmms.
(just kidding)
@
text
@------------------------------------------------------------------------------
Gofer 2.28 is an interactive functional programming environment (i.e. an
interpreter) supporting a language based on the draft report for Haskell
version 1.2, including the following features:

  o  Lazy evaluation, higher order functions, pattern matching etc...

  o  Wide range of built-in types with provision for defining new free
     datatypes and type synonyms.

  o  Polymorphic type system with provision for overloading based on
     a system of type classes.

  o  Full Haskell 1.2 expression and pattern syntax including lambda,
     case, conditional and let expressions, list comprehensions, operator
     sections, and wildcard, as and irrefutable patterns.

  o  Partial implementation of Haskell 1.2 facilities for I/O, enabling
     the use of simple interactive programs and programs reading and writing
     text files.

  o  User documentation, sample programs and source code freely available.

  o  Supports constructor classes and overloaded monad comprehensions.

  o  Simple minded compiler/translator Gofer -> C with runtime system for
     generation of standalone applications.

  o  Runs (and originally developed) on PC compatible computers, but
     also works on Sun workstations.  Code should be portable to many
     other kinds of machine.
 
Gofer is intended as an experimental language, particularly where type classes
are involved.  Gofer extends the Haskell type class system in several ways:

  o  Type classes with multiple parameters are supported.

  o  Instances of type classes may be defined non-overlapping, but otherwise
     arbitrary types.

  o  Predicates in contexts may involve arbitrary type expressions, not just
     type variables as in Haskell.

  o  Basic approach to dictionary construction is different, based on the
     approach I described in a posting to the Haskell mailing list early in
     February 1991.  The resulting system ensures that all dictionaries are
     constructed before evaluation begins, avoiding repeated construction
     and enabling the shared evaluation of overloaded constants in
     dictionaries.

The most significant features of Haskell not currently supported are:
modules, arrays, overloaded numeric constants, default declarations, derived
instances, contexts in datatype definitions.
------------------------------------------------------------------------------
And just in case you wondered:

   The name "Gofer" is not a trademark, registered  or  otherwise,  and
   you are free to mention this name in published material, public  and
   private correspondence, or other documents  without  restriction  or
   obligation.
------------------------------------------------------------------------------
@


1.2
log
@typo and wording fixes; approved by pval

ok mbalmer@@ "that diff was fun to read"
@
text
@@


1.1
log
@Initial revision
@
text
@d46 1
a46 1
     Feburary 1991.  The resulting system ensures that all dictionaries are
@


1.1.1.1
log
@Initial import
@
text
@@
