head	1.2;
access;
symbols
	OPENBSD_6_2:1.2.0.20
	OPENBSD_6_2_BASE:1.2
	OPENBSD_6_1:1.2.0.18
	OPENBSD_6_1_BASE:1.2
	OPENBSD_6_0:1.2.0.16
	OPENBSD_6_0_BASE:1.2
	OPENBSD_5_9:1.2.0.12
	OPENBSD_5_9_BASE:1.2
	OPENBSD_5_8:1.2.0.14
	OPENBSD_5_8_BASE:1.2
	OPENBSD_5_7:1.2.0.10
	OPENBSD_5_7_BASE:1.2
	OPENBSD_5_6:1.2.0.8
	OPENBSD_5_6_BASE:1.2
	OPENBSD_5_5:1.2.0.6
	OPENBSD_5_5_BASE:1.2
	OPENBSD_5_4:1.2.0.4
	OPENBSD_5_4_BASE:1.2
	OPENBSD_5_3:1.2.0.2
	OPENBSD_5_3_BASE:1.2
	OPENBSD_5_2:1.1.0.8
	OPENBSD_5_2_BASE:1.1
	OPENBSD_5_1_BASE:1.1
	OPENBSD_5_1:1.1.0.6
	OPENBSD_5_0:1.1.0.4
	OPENBSD_5_0_BASE:1.1
	OPENBSD_4_9:1.1.0.2
	OPENBSD_4_9_BASE:1.1;
locks; strict;
comment	@# @;


1.2
date	2012.09.18.16.02.53;	author jeremy;	state Exp;
branches;
next	1.1;

1.1
date	2010.09.23.21.58.50;	author jeremy;	state Exp;
branches;
next	;


desc
@@


1.2
log
@Fix a backport of a patch that never made it to ruby 1.8.7, which left
out the definition of a new function added in the patch.  Allows usage
of the ruby 1.8 socket extension with LD_BIND_NOW=1.

OK naddy@@
@
text
@$OpenBSD: patch-ext_socket_socket_c,v 1.1 2010/09/23 21:58:50 jeremy Exp $

Fix UnixSocket#recv_io on 64-bit archs, backported from ruby SVN
revisions 22141 and 22633.

--- ext/socket/socket.c.orig	Fri May 20 15:25:41 2011
+++ ext/socket/socket.c	Mon Sep 17 14:10:31 2012
@@@@ -2027,6 +2027,28 @@@@ unix_send_io(sock, val)
 #endif
 }
 
+#if defined(HAVE_RECVMSG) && FD_PASSING_BY_MSG_CONTROL
+void
+rsock_discard_cmsg_resource(struct msghdr *mh)
+{
+    struct cmsghdr *cmh;
+
+    if (mh->msg_controllen == 0)
+        return;
+
+    for (cmh = CMSG_FIRSTHDR(mh); cmh != NULL; cmh = CMSG_NXTHDR(mh, cmh)) {
+        if (cmh->cmsg_level == SOL_SOCKET && cmh->cmsg_type == SCM_RIGHTS) {
+            int *fdp = (int *)CMSG_DATA(cmh);
+            int *end = (int *)((char *)cmh + cmh->cmsg_len);
+            while (fdp < end) {
+                close(*fdp);
+                fdp++;
+            }
+        }
+    }
+}
+#endif
+
 #if defined(HAVE_RECVMSG) && (FD_PASSING_BY_MSG_CONTROL || FD_PASSING_BY_MSG_ACCRIGHTS)
 static void
 thread_read_select(fd)
@@@@ -2097,16 +2119,11 @@@@ unix_recv_io(argc, argv, sock)
 	rb_sys_fail("recvmsg(2)");
 
 #if FD_PASSING_BY_MSG_CONTROL
-    if (msg.msg_controllen != CMSG_SPACE(sizeof(int))) {
-      rb_raise(rb_eSocket,
-          "file descriptor was not passed (msg_controllen=%d, %d expected)",
-          msg.msg_controllen, CMSG_SPACE(sizeof(int)));
+    if (msg.msg_controllen < sizeof(struct cmsghdr)) {
+        rb_raise(rb_eSocket,
+                 "file descriptor was not passed (msg_controllen=%d smaller than sizeof(struct cmsghdr)=%d)",
+                 (int)msg.msg_controllen, (int)sizeof(struct cmsghdr));
     }
-    if (cmsg.hdr.cmsg_len != CMSG_LEN(sizeof(int))) {
-      rb_raise(rb_eSocket,
-          "file descriptor was not passed (cmsg_len=%d, %d expected)",
-          cmsg.hdr.cmsg_len, CMSG_LEN(sizeof(int)));
-    }
     if (cmsg.hdr.cmsg_level != SOL_SOCKET) {
       rb_raise(rb_eSocket,
           "file descriptor was not passed (cmsg_level=%d, %d expected)",
@@@@ -2116,6 +2133,22 @@@@ unix_recv_io(argc, argv, sock)
       rb_raise(rb_eSocket,
           "file descriptor was not passed (cmsg_type=%d, %d expected)",
           cmsg.hdr.cmsg_type, SCM_RIGHTS);
+    }
+    if (msg.msg_controllen < CMSG_LEN(sizeof(int))) {
+        rb_raise(rb_eSocket,
+		 "file descriptor was not passed (msg_controllen=%d smaller than CMSG_LEN(sizeof(int))=%d)",
+		 (int)msg.msg_controllen, (int)CMSG_LEN(sizeof(int)));
+    }
+    if (CMSG_SPACE(sizeof(int)) < msg.msg_controllen) {
+	rb_raise(rb_eSocket,
+		 "file descriptor was not passed (msg_controllen=%d bigger than CMSG_SPACE(sizeof(int))=%d)",
+                 (int)msg.msg_controllen, (int)CMSG_SPACE(sizeof(int)));
+    }
+    if (cmsg.hdr.cmsg_len != CMSG_LEN(sizeof(int))) {
+        rsock_discard_cmsg_resource(&msg);
+        rb_raise(rb_eSocket,
+                 "file descriptor was not passed (cmsg_len=%d, %d expected)",
+                 (int)cmsg.hdr.cmsg_len, (int)CMSG_LEN(sizeof(int)));
     }
 #else
     if (msg.msg_accrightslen != sizeof(fd)) {
@


1.1
log
@Split the lang/ruby port into separate ports for ruby 1.8 and ruby
1.9, similar to how the lang/python ports are handled.  ruby 1.8
now installs as ruby18 and ruby 1.9 installs as ruby19.  The
included MESSAGE files for both ports let you know the symlinks to
set up if you want to make that version the default system ruby.

Split port originally started by bernd@@, many changes since by me,
help and support from jcs@@, landry@@, jasper@@, and sthen@@.

This causes a large amount of fallout in dependent ruby ports,
which will be committed shortly.

OK jcs@@, landry@@, jasper@@, sthen@@
@
text
@d1 1
a1 1
$OpenBSD$
d6 32
a37 3
--- ext/socket/socket.c.orig	Mon Sep  6 17:18:07 2010
+++ ext/socket/socket.c	Mon Sep  6 17:18:24 2010
@@@@ -2097,16 +2097,11 @@@@ unix_recv_io(argc, argv, sock)
d58 1
a58 1
@@@@ -2116,6 +2111,22 @@@@ unix_recv_io(argc, argv, sock)
@

