head	1.1;
access;
symbols
	OPENBSD_6_1:1.1.0.26
	OPENBSD_6_1_BASE:1.1
	OPENBSD_6_0:1.1.0.24
	OPENBSD_6_0_BASE:1.1
	OPENBSD_5_9:1.1.0.20
	OPENBSD_5_9_BASE:1.1
	OPENBSD_5_8:1.1.0.22
	OPENBSD_5_8_BASE:1.1
	OPENBSD_5_7:1.1.0.18
	OPENBSD_5_7_BASE:1.1
	OPENBSD_5_6:1.1.0.16
	OPENBSD_5_6_BASE:1.1
	OPENBSD_5_5:1.1.0.14
	OPENBSD_5_5_BASE:1.1
	OPENBSD_5_4:1.1.0.12
	OPENBSD_5_4_BASE:1.1
	OPENBSD_5_3:1.1.0.10
	OPENBSD_5_3_BASE:1.1
	OPENBSD_5_2:1.1.0.8
	OPENBSD_5_2_BASE:1.1
	OPENBSD_5_1_BASE:1.1
	OPENBSD_5_1:1.1.0.6
	OPENBSD_5_0:1.1.0.4
	OPENBSD_5_0_BASE:1.1
	OPENBSD_4_9:1.1.0.2
	OPENBSD_4_9_BASE:1.1;
locks; strict;
comment	@# @;


1.1
date	2010.09.23.13.42.22;	author joshe;	state Exp;
branches;
next	;


desc
@@


1.1
log
@Build on sparc64.

ok jasper@@
@
text
@$OpenBSD$

Disable the assembler loops, at least one of them is broken.

Remove a couple of potentially-broken math functions to make sure they
aren't used in case the maze of #ifdefs in arilev0.d ever changes.

--- src/arisparc64.d.orig	Wed Dec  5 08:06:32 2007
+++ src/arisparc64.d	Sun Sep 19 16:25:17 2010
@@@@ -14,6 +14,7 @@@@
 
 #ifdef INCLUDED_FROM_C
 
+#if 0
   #define COPY_LOOPS
   #define FILL_LOOPS
   #define CLEAR_LOOPS
@@@@ -23,6 +24,7 @@@@
   #define SHIFT_LOOPS
   #define MUL_LOOPS
   #define DIV_LOOPS
+#endif
 
 #else
 
@@@@ -73,30 +75,12 @@@@ C(mulu16_:) # Input in %o0,%o1, Output in %o0
         retl
        _ srl %o2,0,%o0
 
-# extern struct { uint32 lo; uint32 hi; } mulu32_ (uint32 arg1, uint32 arg2);
-# 2^32*hi+lo := arg1*arg2.
-C(mulu32_:) # Input in %o0,%o1, Output in %o0,%g1
-        umul %o0,%o1,%o2
-        rd %y,%g1
-        retl
-       _ srl %o2,0,%o0
-
 # extern uint32 mulu32_unchecked (uint32 x, uint32 y);
 # result := arg1*arg2 < 2^32.
 C(mulu32_unchecked:) # Input in %o0,%o1, Output in %o0
         umul %o0,%o1,%o2
         retl
        _ srl %o2,0,%o0
-
-# extern struct { uint32 q; uint32 r; } divu_6432_3232_ (uint32 xhi, uint32 xlo, uint32 y);
-# x = 2^32*xhi+xlo = q*y+r schreiben. Sei bekannt, dass 0 <= x < 2^32*y .
-C(divu_6432_3232_:) # Input in %o0,%o1,%o2, Output in %o0,%g1
-        wr %o0,%g0,%y
-        udiv %o1,%o2,%o0        # x durch y dividieren, %o0 := q
-        umul %o0,%o2,%g1        # %g1 := (q*y) mod 2^32
-        sub %o1,%g1,%g1         # %g1 := (xlo-q*y) mod 2^32 = r
-        retl
-       _ srl %o0,0,%o0
 
 # extern struct { uint16 q; uint16 r; } divu_3216_1616_ (uint32 x, uint16 y);
 # x = q*y+r schreiben. Sei bekannt, dass 0 <= x < 2^16*y .
@
