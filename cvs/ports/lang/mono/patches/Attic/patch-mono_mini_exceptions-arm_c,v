head	1.3;
access;
symbols
	OPENBSD_4_8:1.2.0.2
	OPENBSD_4_8_BASE:1.2
	OPENBSD_4_7:1.1.0.2
	OPENBSD_4_7_BASE:1.1;
locks; strict;
comment	@# @;


1.3
date	2010.08.18.10.51.55;	author robert;	state dead;
branches;
next	1.2;

1.2
date	2010.03.20.17.16.44;	author robert;	state Exp;
branches;
next	1.1;

1.1
date	2009.09.22.17.55.23;	author ajacoutot;	state Exp;
branches;
next	;


desc
@@


1.3
log
@Update to 2.6.7; remove patches that were merged backed to upstream
@
text
@$OpenBSD: patch-mono_mini_exceptions-arm_c,v 1.2 2010/03/20 17:16:44 robert Exp $
--- mono/mini/exceptions-arm.c.orig	Sat Mar 20 18:01:34 2010
+++ mono/mini/exceptions-arm.c	Sat Mar 20 18:03:17 2010
@@@@ -12,7 +12,9 @@@@
 #include <glib.h>
 #include <signal.h>
 #include <string.h>
+#if HAVE_UCONTEXT_H
 #include <ucontext.h>
+#endif
 
 #include <mono/arch/arm/arm-codegen.h>
 #include <mono/metadata/appdomain.h>
@@@@ -80,6 +82,7 @@@@ typedef struct ucontext {
  * We define our own version here and use it instead.
  */
 
+#ifdef MONO_ARCH_USE_SIGACTION
 #if __APPLE__
 #define my_ucontext ucontext_t
 #else
@@@@ -97,6 +100,7 @@@@ typedef struct my_ucontext {
 	 */
 } my_ucontext;
 #endif
+#endif
 
 /*
  * arch_get_restore_context:
@@@@ -467,6 +471,7 @@@@ mono_arch_find_jit_info_ext (MonoDomain *domain, MonoJ
 void
 mono_arch_sigctx_to_monoctx (void *sigctx, MonoContext *mctx)
 {
+#ifdef MONO_ARCH_USE_SIGACTION
 #if BROKEN_LINUX
 	g_assert_not_reached ();
 #else
@@@@ -477,11 +482,13 @@@@ mono_arch_sigctx_to_monoctx (void *sigctx, MonoContext
 	memcpy (&mctx->regs, &UCONTEXT_REG_R0 (my_uc), sizeof (gulong) * 16);
 #endif
 	mctx->ebp = mctx->regs [ARMREG_FP];
+#endif
 }
 
 void
 mono_arch_monoctx_to_sigctx (MonoContext *mctx, void *ctx)
 {
+#ifdef MONO_ARCH_USE_SIGACTION
 #if BROKEN_LINUX
 	g_assert_not_reached ();
 #else
@@@@ -492,6 +499,7 @@@@ mono_arch_monoctx_to_sigctx (MonoContext *mctx, void *
 	/* The upper registers are not guaranteed to be valid */
 	memcpy (&UCONTEXT_REG_R0 (my_uc), &mctx->regs, sizeof (gulong) * 12);
 #endif
+#endif
 }
 
 /*
@@@@ -516,11 +524,13 @@@@ mono_arch_handle_exception (void *ctx, gpointer obj, g
 gpointer
 mono_arch_ip_from_context (void *sigctx)
 {
+#ifdef MONO_ARCH_USE_SIGACTION
 #if BROKEN_LINUX
 	g_assert_not_reached ();
 #else
 	my_ucontext *my_uc = sigctx;
 	return (void*) UCONTEXT_REG_PC (my_uc);
+#endif
 #endif
 }
 
@


1.2
log
@- update to the latest stable version: 2.6.3
- move to autoconf
- regen patches

ok ajacoutot@@, jasper@@
@
text
@d1 1
a1 1
$OpenBSD$
@


1.1
log
@More work into making this compile on armish.
We are up to the point where it segfaults during build as some other arches
used to in the past... so somehow, this is an improvement ;-)
@
text
@d2 2
a3 2
--- mono/mini/exceptions-arm.c.orig	Tue Sep 22 11:43:34 2009
+++ mono/mini/exceptions-arm.c	Tue Sep 22 11:34:31 2009
d14 5
a18 1
@@@@ -83,6 +85,7 @@@@ typedef struct ucontext {
a21 4
+#ifdef MONO_ARCH_USE_SIGACTION
 typedef struct my_ucontext {
 	unsigned long       uc_flags;
 	struct my_ucontext *uc_link;
d28 3
a30 3
 #define restore_regs_from_context(ctx_reg,ip_reg,tmp_reg) do {	\
 		ARM_LDR_IMM (code, ip_reg, ctx_reg, G_STRUCT_OFFSET (MonoContext, eip));	\
@@@@ -455,6 +459,7 @@@@ mono_arch_find_jit_info (MonoDomain *domain, MonoJitTl
d36 4
a39 5
 	struct ucontext *uc = sigctx;
 
@@@@ -469,11 +474,13 @@@@ mono_arch_sigctx_to_monoctx (void *sigctx, MonoContext
 	mctx->ebp = UCONTEXT_REG_SP (my_uc);
 	memcpy (&mctx->regs, &UCONTEXT_REG_R4 (my_uc), sizeof (gulong) * 8);
d41 1
d50 5
a54 5
 	struct ucontext *uc = ctx;
 
@@@@ -488,6 +495,7 @@@@ mono_arch_monoctx_to_sigctx (MonoContext *mctx, void *
 	UCONTEXT_REG_SP (my_uc) = mctx->ebp;
 	memcpy (&UCONTEXT_REG_R4 (my_uc), &mctx->regs, sizeof (gulong) * 8);
d60 1
a60 1
@@@@ -512,12 +520,14 @@@@ mono_arch_handle_exception (void *ctx, gpointer obj, g
d66 1
a66 2
 	struct ucontext *uc = sigctx;
 	return (gpointer)uc->uc_mcontext.gregs [ARMREG_PC];
@

