head	1.3;
access;
symbols;
locks; strict;
comment	@# @;


1.3
date	2010.04.27.12.39.50;	author robert;	state dead;
branches;
next	1.2;

1.2
date	2010.03.27.12.06.26;	author robert;	state Exp;
branches;
next	1.1;

1.1
date	2010.03.26.13.13.47;	author robert;	state Exp;
branches;
next	;


desc
@@


1.3
log
@Update to mono 2.6.4;
(a lot of patches are in upstream now)
@
text
@$OpenBSD: patch-mono_mini_mini-posix_c,v 1.2 2010/03/27 12:06:26 robert Exp $
--- mono/mini/mini-posix.c.orig	Sat Mar 27 12:33:58 2010
+++ mono/mini/mini-posix.c	Sat Mar 27 12:34:52 2010
@@@@ -179,16 +179,22 @@@@ SIG_HANDLER_SIGNATURE (sigusr1_signal_handler)
 	}
 
 	/*
-	 * FIXME:
 	 * This is an async signal, so the code below must not call anything which
 	 * is not async safe. That includes the pthread locking functions. If we
 	 * know that we interrupted managed code, then locking is safe.
 	 */
-	ji = mono_jit_info_table_find (mono_domain_get (), mono_arch_ip_from_context(ctx));
-	running_managed = ji != NULL;
+	/*
+	 * On OpenBSD, ctx can be NULL if we are interrupting poll ().
+	 */
+	if (ctx) {
+		ji = mono_jit_info_table_find (mono_domain_get (), mono_arch_ip_from_context(ctx));
+		running_managed = ji != NULL;
 
-	if (mono_debugger_agent_thread_interrupt (ctx, ji))
-		return;
+		if (mono_debugger_agent_thread_interrupt (ctx, ji))
+			return;
+	} else {
+		running_managed = FALSE;
+	}
 	
 	exc = mono_thread_request_interruption (running_managed); 
 	if (!exc)
@


1.2
log
@Remove the handles.c patch because that's not needed anymore because
Zoltan Varga from the mono team helped me to debug the problem we
were having. So the correct problem description is that on OpenBSD,
ctx can be NULL if we are interrupting poll().
The upstream diff also fixes the issue where we are interrupting
unmanaged code.
@
text
@d1 1
a1 1
$OpenBSD: patch-mono_mini_mini-posix_c,v 1.1 2010/03/26 13:13:47 robert Exp $
@


1.1
log
@Remove the previous diff to mini.h because that was totally wrong, i made
it up before having my morning coffee.
So it turns out that sometimes the context on openbsd can be 0. This will
lead to problems. I suspect that this is because of our fantastic pthread
library. With the following diff we just skip doing some JIT stuff if the
context is 0 because the thread probably exited before.
Anyways this way everything *seems* to work fine and almost all regression
tests are passing now except for 2 out of 380.
Pepole understanding pthreads are welcome to look at it and come up with
something that is not a tripe XXX hack.
@
text
@d1 9
a9 4
$OpenBSD$
--- mono/mini/mini-posix.c.orig	Fri Mar 26 14:03:04 2010
+++ mono/mini/mini-posix.c	Fri Mar 26 13:53:52 2010
@@@@ -184,11 +184,22 @@@@ SIG_HANDLER_SIGNATURE (sigusr1_signal_handler)
a14 1
+#if defined(__OpenBSD__)
d16 2
a17 4
+         * Let's say that this is a tripe XXX hack, because on OpenBSD ctx can be 0
+         * in some cases and I suspect this is because something async happens and
+         * threads are going away before we could handle them.
+         */
a18 1
+#endif
d26 2
a27 1
+#if defined(__OpenBSD__)
a28 1
+#endif
@

