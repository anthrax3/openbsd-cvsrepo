head	1.2;
access;
symbols;
locks; strict;
comment	@# @;


1.2
date	2010.04.27.12.39.50;	author robert;	state dead;
branches;
next	1.1;

1.1
date	2010.04.08.16.40.04;	author robert;	state Exp;
branches;
next	;


desc
@@


1.2
log
@Update to mono 2.6.4;
(a lot of patches are in upstream now)
@
text
@$OpenBSD: patch-mono_utils_mono-time_c,v 1.1 2010/04/08 16:40:04 robert Exp $
--- mono/utils/mono-time.c.orig	Thu Apr  8 18:34:07 2010
+++ mono/utils/mono-time.c	Thu Apr  8 18:35:15 2010
@@@@ -57,12 +57,32 @@@@ mono_100ns_datetime (void)
 #include <sys/time.h>
 #endif
 
+#if defined(__APPLE__) || defined(__FreeBSD__) || defined(__OpenBSD__) || defined(__NetBSD__)
+#include <sys/param.h>
+#include <sys/sysctl.h>
+#endif
+
 #include <time.h>
 
 static gint64
 get_boot_time (void)
 {
-	/* FIXME: use sysctl (kern.boottime) on OSX */
+#if defined(PLATFORM_MACOSX) || defined(__FreeBSD__) || defined(__OpenBSD__) || defined(__NetBSD__)
+	int mib [2];
+	size_t size;
+	time_t now;
+	struct timeval boottime;
+
+	(void)time(&now);
+
+	mib [0] = CTL_KERN;
+	mib [1] = KERN_BOOTTIME;
+
+	size = sizeof(boottime);
+
+	if (sysctl(mib, 2, &boottime, &size, NULL, 0) != -1)
+		return (gint64)((now - boottime.tv_sec) * MTICKS_PER_SEC);
+#else
 	FILE *uptime = fopen ("/proc/uptime", "r");
 	if (uptime) {
 		double upt;
@@@@ -73,6 +93,7 @@@@ get_boot_time (void)
 		}
 		fclose (uptime);
 	}
+#endif
 	/* a made up uptime of 300 seconds */
 	return (gint64)300 * MTICKS_PER_SEC;
 }
@


1.1
log
@Use KERN_BOOTTIME to get the uptime instead of making up a value
because we don't have /proc.
@
text
@d1 1
a1 1
$OpenBSD$
@

