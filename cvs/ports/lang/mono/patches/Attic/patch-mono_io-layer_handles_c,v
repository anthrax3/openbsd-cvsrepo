head	1.3;
access;
symbols;
locks; strict;
comment	@# @;


1.3
date	2010.03.27.12.06.26;	author robert;	state dead;
branches;
next	1.2;

1.2
date	2010.03.26.17.53.26;	author robert;	state Exp;
branches;
next	1.1;

1.1
date	2010.03.26.17.01.02;	author robert;	state Exp;
branches;
next	;


desc
@@


1.3
log
@Remove the handles.c patch because that's not needed anymore because
Zoltan Varga from the mono team helped me to debug the problem we
were having. So the correct problem description is that on OpenBSD,
ctx can be NULL if we are interrupting poll().
The upstream diff also fixes the issue where we are interrupting
unmanaged code.
@
text
@$OpenBSD: patch-mono_io-layer_handles_c,v 1.2 2010/03/26 17:53:26 robert Exp $
--- mono/io-layer/handles.c.orig	Fri Sep 25 16:58:10 2009
+++ mono/io-layer/handles.c	Fri Mar 26 18:47:01 2010
@@@@ -1046,6 +1046,9 @@@@ void _wapi_handle_unref (gpointer handle)
 	guint32 idx = GPOINTER_TO_UINT(handle);
 	gboolean destroy = FALSE;
 	int thr_ret;
+#if defined(__OpenBSD__)
+	int i = 0;
+#endif
 
 	if (!_WAPI_PRIVATE_VALID_SLOT (idx)) {
 		return;
@@@@ -1114,8 +1117,19 @@@@ void _wapi_handle_unref (gpointer handle)
 			 * now, but pthreads doesn't have a
 			 * "unlock_and_destroy" atomic function.
 			 */
+#if defined(__OpenBSD__)
+			/* XXX: It seems that we have to wait for some thread to finish */
+			do {
+				thr_ret = mono_mutex_destroy (&_WAPI_PRIVATE_HANDLES(idx).signal_mutex);
+				if (thr_ret == EBUSY) {
+					sleep(1);
+					i++;
+				}
+			} while ((thr_ret > 0) && (i < 5));
+#else
 			thr_ret = mono_mutex_destroy (&_WAPI_PRIVATE_HANDLES(idx).signal_mutex);
 			g_assert (thr_ret == 0);
+#endif
 				
 			thr_ret = pthread_cond_destroy (&_WAPI_PRIVATE_HANDLES(idx).signal_cond);
 			g_assert (thr_ret == 0);
@


1.2
log
@retry 5 times then skip
@
text
@d1 1
a1 1
$OpenBSD: patch-mono_io-layer_handles_c,v 1.1 2010/03/26 17:01:02 robert Exp $
@


1.1
log
@Sometimes we have the mutex is still in use by some other thread so
let's wait until it gets unlocked, this makes the random build errors
go away.. again.
@
text
@d1 14
a14 4
$OpenBSD$
--- mono/io-layer/handles.c.orig	Fri Mar 26 17:57:36 2010
+++ mono/io-layer/handles.c	Fri Mar 26 17:57:52 2010
@@@@ -1114,7 +1114,11 @@@@ void _wapi_handle_unref (gpointer handle)
d18 2
a19 1
-			thr_ret = mono_mutex_destroy (&_WAPI_PRIVATE_HANDLES(idx).signal_mutex);
d22 1
a22 1
+				if (thr_ret == EBUSY)
d24 5
a28 1
+			} while (thr_ret > 0);
d30 1
d33 1
@

