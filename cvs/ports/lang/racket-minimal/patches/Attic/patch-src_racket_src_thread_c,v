head	1.4;
access;
symbols
	OPENBSD_5_8:1.1.1.1.0.4
	OPENBSD_5_8_BASE:1.1.1.1
	juanfra_2015_07_16:1.1.1.1
	juanfra:1.1.1;
locks; strict;
comment	@# @;


1.4
date	2016.05.16.22.20.16;	author juanfra;	state dead;
branches;
next	1.3;
commitid	GTETszv79ME3Iwhs;

1.3
date	2016.03.10.02.35.29;	author juanfra;	state Exp;
branches;
next	1.2;
commitid	K22naO2qcpp2uxfQ;

1.2
date	2015.12.01.18.26.51;	author juanfra;	state dead;
branches;
next	1.1;
commitid	VcWvNlmN2F2Yfni2;

1.1
date	2015.07.16.00.20.53;	author juanfra;	state Exp;
branches
	1.1.1.1;
next	;
commitid	Q4WTWtFPA1q58nBV;

1.1.1.1
date	2015.07.16.00.20.53;	author juanfra;	state Exp;
branches;
next	;
commitid	Q4WTWtFPA1q58nBV;


desc
@@


1.4
log
@Update to Racket 6.5.
@
text
@$OpenBSD: patch-src_racket_src_thread_c,v 1.3 2016/03/10 02:35:29 juanfra Exp $

"clean up GC implementation"
https://github.com/racket/racket/commit/2ee721f

--- src/racket/src/thread.c.orig	Mon Jan 11 18:07:43 2016
+++ src/racket/src/thread.c	Tue Feb  9 23:51:58 2016
@@@@ -334,8 +334,6 @@@@ static void register_traversers(void);
 static Scheme_Object *custodian_require_mem(int argc, Scheme_Object *args[]);
 static Scheme_Object *custodian_limit_mem(int argc, Scheme_Object *args[]);
 static Scheme_Object *custodian_can_mem(int argc, Scheme_Object *args[]);
-static Scheme_Object *new_tracking_fun(int argc, Scheme_Object *args[]);
-static Scheme_Object *union_tracking_val(int argc, Scheme_Object *args[]);
 
 static Scheme_Object *collect_garbage(int argc, Scheme_Object *args[]);
 static Scheme_Object *current_memory_use(int argc, Scheme_Object *args[]);
@@@@ -639,25 +637,6 @@@@ void scheme_init_thread_places(void) {
   gc_info_prefab = scheme_lookup_prefab_type(scheme_intern_symbol("gc-info"), 10);
 }
 
-void scheme_init_memtrace(Scheme_Env *env)
-{
-  Scheme_Object *v;
-  Scheme_Env *newenv;
-
-  v = scheme_intern_symbol("#%memtrace");
-  newenv = scheme_primitive_module(v, env);
-    
-  v = scheme_make_symbol("memory-trace-continuation-mark");
-  scheme_add_global("memory-trace-continuation-mark", v , newenv);
-  v = scheme_make_prim_w_arity(new_tracking_fun, 
-                              "new-memtrace-tracking-function", 1, 1);
-  scheme_add_global("new-memtrace-tracking-function", v, newenv);
-  v = scheme_make_prim_w_arity(union_tracking_val, 
-                               "unioned-memtrace-tracking-value", 1, 1);
-  scheme_add_global("unioned-memtrace-tracking-value", v, newenv);
-  scheme_finish_primitive_module(newenv);
-}
-
 void scheme_init_inspector() {
   REGISTER_SO(initial_inspector);
   initial_inspector = scheme_make_initial_inspectors();
@@@@ -914,28 +893,6 @@@@ static Scheme_Object *custodian_can_mem(int argc, Sche
 #else
   return scheme_false;
 #endif
-}
-
-static Scheme_Object *new_tracking_fun(int argc, Scheme_Object *args[])
-{
-  int retval = 0;
-
-#ifdef MZ_PRECISE_GC
-  retval = GC_mtrace_new_id(args[0]);
-#endif
-
-  return scheme_make_integer(retval);
-}
-
-static Scheme_Object *union_tracking_val(int argc, Scheme_Object *args[])
-{
-  int retval = 0;
-
-#ifdef MZ_PRECISE_GC
-  retval = GC_mtrace_union_current_with(SCHEME_INT_VAL(args[0]));
-#endif
-
-  return scheme_make_integer(retval);
 }
 
 static void ensure_custodian_space(Scheme_Custodian *m, int k)
@


1.3
log
@Update to Racket 6.4.
@
text
@d1 1
a1 1
$OpenBSD$
@


1.2
log
@Update to Racket 6.3.

(there are still some corner cases on i386)
@
text
@d1 1
a1 1
$OpenBSD: patch-src_racket_src_thread_c,v 1.1 2015/07/16 00:20:53 juanfra Exp $
d3 2
a4 1
"fix slow leak in link-establishing 'thread-resume'
d6 64
a69 19
Using '(thread-resume t1 t2)' would not prevent a GC of t1, but it
would create an intermediate record to make the link from t1 to t2,
and that intermediate record would leak due to a missing level of
indirection in a table-cleanup traveral. The leak not only accumulated
memory, it also caused ever slower traversals of the table in an
attempt to clean up."

https://github.com/plt/racket/commit/ca57adcf2db458276b778b18061de1e5ccecde23

--- src/racket/src/thread.c.orig	Thu May  7 16:45:21 2015
+++ src/racket/src/thread.c	Mon Jul 13 22:58:08 2015
@@@@ -5779,15 +5779,17 @@@@ static void add_transitive_resume(Scheme_Thread *promo
     promote_to->transitive_resumes = (Scheme_Object *)ht;
   } else {
     /* Purge ht entries for threads that are now dead: */
-    Scheme_Hash_Table *gone= NULL;
+    Scheme_Hash_Table *gone = NULL;
+    Scheme_Object *b;
     int i;
d71 1
a71 13
     ht = (Scheme_Hash_Table *)promote_to->transitive_resumes;
     for (i = ht->size; i--; ) {
       if (ht->vals[i]) {
-	if (!SCHEME_PTR_VAL(ht->keys[i])
-            || (SAME_TYPE(SCHEME_TYPE(ht->keys[i]), scheme_weak_box_type)
-                && !SCHEME_WEAK_BOX_VAL(ht->vals[i]))) {
+        b = SCHEME_PTR_VAL(ht->keys[i]);
+	if (!b
+            || (SAME_TYPE(SCHEME_TYPE(b), scheme_weak_box_type)
+                && !SCHEME_WEAK_BOX_VAL(b))) {
 	  /* This one is dead */
 	  if (!gone)
 	    gone = scheme_make_hash_table(SCHEME_hash_ptr);
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
$OpenBSD$
@


1.1.1.1
log
@Tests, help with the README file and OK jturner@@.


Racket is a multi-paradigm programming language in the Lisp/Scheme
family, that also serves as a platform for language creation, design,
and implementation.

The primary components of Racket platform are:

- The implementation of Racket (including a rich run-time system,
  various libraries, JIT compiler, and more).
- pkg.racket-lang.org, Racket's web-based package distribution system
  for user-contributed packages.
- raco, command line tool for finding documentation, compiling Racket
  source to bytecode, packaging executables, packaging installable
  archives, and installing packages from remote servers.


@
text
@@
