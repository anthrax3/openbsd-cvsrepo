head	1.3;
access;
symbols
	OPENBSD_5_3:1.2.0.2
	OPENBSD_5_3_BASE:1.2
	OPENBSD_5_2:1.2.0.4
	OPENBSD_5_2_BASE:1.2
	jsing_2012-03-31:1.1.1.1
	jsing:1.1.1;
locks; strict;
comment	@# @;


1.3
date	2013.05.15.12.10.15;	author jsing;	state dead;
branches;
next	1.2;

1.2
date	2012.04.15.13.37.27;	author jsing;	state Exp;
branches;
next	1.1;

1.1
date	2012.03.31.12.37.16;	author jsing;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2012.03.31.12.37.16;	author jsing;	state Exp;
branches;
next	;


desc
@@


1.3
log
@Update lang/go to version 1.1.

Also preserve the timestamps of the source and compiled binaries so that
"go build" does not think installed libraries should be recompiled.

ok jasper@@ sthen@@
@
text
@$OpenBSD: patch-src_pkg_runtime_thread_openbsd_c,v 1.2 2012/04/15 13:37:27 jsing Exp $
--- src/pkg/runtime/thread_openbsd.c.orig	Wed Mar 28 15:49:26 2012
+++ src/pkg/runtime/thread_openbsd.c	Fri Mar  2 02:03:18 2012
@@@@ -20,8 +20,11 @@@@ enum
 
 extern SigTab runtime·sigtab[];
 
-extern int64 runtime·rfork_thread(int32 flags, void *stack, M *m, G *g, void (*fn)(void));
-extern int32 runtime·thrsleep(void *ident, int32 clock_id, void *tsp, void *lock);
+static Sigset sigset_all = ~(Sigset)0;
+static Sigset sigset_none;
+
+extern int64 runtime·tfork_thread(void *stack, M *m, G *g, void (*fn)(void));
+extern int32 runtime·thrsleep(void *ident, int32 clock_id, void *tsp, void *lock, const int32 *abort);
 extern int32 runtime·thrwakeup(void *ident, int32 n);
 
 // From OpenBSD's <sys/sysctl.h>
@@@@ -69,12 +72,12 @@@@ runtime·semasleep(int64 ns)
 			// sleep until semaphore != 0 or timeout.
 			// thrsleep unlocks m->waitsemalock.
 			if(ns < 0)
-				runtime·thrsleep(&m->waitsemacount, 0, nil, &m->waitsemalock);
+				runtime·thrsleep(&m->waitsemacount, 0, nil, &m->waitsemalock, nil);
 			else {
 				ns += runtime·nanotime();
 				ts.tv_sec = ns/1000000000LL;
 				ts.tv_nsec = ns%1000000000LL;
-				runtime·thrsleep(&m->waitsemacount, CLOCK_REALTIME, &ts, &m->waitsemalock);
+				runtime·thrsleep(&m->waitsemacount, CLOCK_REALTIME, &ts, &m->waitsemalock, nil);
 			}
 			// reacquire lock
 			while(runtime·xchg(&m->waitsemalock, 1))
@@@@ -119,21 +122,13 @@@@ runtime·semawakeup(M *mp)
 	runtime·atomicstore(&mp->waitsemalock, 0);
 }
 
-// From OpenBSD's sys/param.h
-#define	RFPROC		(1<<4)	/* change child (else changes curproc) */
-#define	RFMEM		(1<<5)	/* share `address space' */
-#define	RFNOWAIT	(1<<6)	/* parent need not wait() on child */
-#define	RFTHREAD	(1<<13)	/* create a thread, not a process */
-
 void
 runtime·newosproc(M *m, G *g, void *stk, void (*fn)(void))
 {
-	int32 flags;
+	Sigset oset;
 	int32 ret;
 
-	flags = RFPROC | RFTHREAD | RFMEM | RFNOWAIT;
-
-	if (0) {
+	if(0) {
 		runtime·printf(
 			"newosproc stk=%p m=%p g=%p fn=%p id=%d/%d ostk=%p\n",
 			stk, m, g, fn, m->id, m->tls[0], &m);
@@@@ -141,7 +136,11 @@@@ runtime·newosproc(M *m, G *g, void *stk, void (*fn)(v
 
 	m->tls[0] = m->id;	// so 386 asm can find it
 
-	if((ret = runtime·rfork_thread(flags, stk, m, g, fn)) < 0) {
+	oset = runtime·sigprocmask(SIG_SETMASK, sigset_all);
+	ret = runtime·tfork_thread(stk, m, g, fn);
+	runtime·sigprocmask(SIG_SETMASK, oset);
+
+	if(ret < 0) {
 		runtime·printf("runtime: failed to create new OS thread (have %d already; errno=%d)\n", runtime·mcount() - 1, -ret);
 		if (ret == -ENOTSUP)
 			runtime·printf("runtime: is kern.rthreads disabled?\n");
@@@@ -168,6 +167,7 @@@@ runtime·minit(void)
 	// Initialize signal handling
 	m->gsignal = runtime·malg(32*1024);
 	runtime·signalstack(m->gsignal->stackguard - StackGuard, 32*1024);
+	runtime·sigprocmask(SIG_SETMASK, sigset_none);
 }
 
 void
@


1.2
log
@Use the __tfork() syscall instead of rfork(), which no longer exists.

ok sthen@@
@
text
@d1 1
a1 1
$OpenBSD: patch-src_pkg_runtime_thread_openbsd_c,v 1.1.1.1 2012/03/31 12:37:16 jsing Exp $
@


1.1
log
@Initial revision
@
text
@d1 3
a3 3
$OpenBSD$
--- src/pkg/runtime/thread_openbsd.c.orig	Mon Mar 19 00:13:54 2012
+++ src/pkg/runtime/thread_openbsd.c	Mon Mar 19 00:13:54 2012
d8 2
d13 1
a13 2
 extern int64 runtime·rfork_thread(int32 flags, void *stack, M *m, G *g, void (*fn)(void));
-extern int32 runtime·thrsleep(void *ident, int32 clock_id, void *tsp, void *lock);
d33 10
a42 1
@@@@ -128,6 +131,7 @@@@ runtime·semawakeup(M *mp)
d46 1
a47 1
 	int32 flags;
d50 8
a57 1
@@@@ -141,7 +145,11 @@@@ runtime·newosproc(M *m, G *g, void *stk, void (*fn)(v
d63 1
a63 1
+	ret = runtime·rfork_thread(flags, stk, m, g, fn);
d70 1
a70 1
@@@@ -168,6 +176,7 @@@@ runtime·minit(void)
@


1.1.1.1
log
@Import go-1.

Go is an open source programming environment that makes it easy to build
simple, reliable, and efficient software.

With assistance from sthen@@

ok sthen@@
@
text
@@
