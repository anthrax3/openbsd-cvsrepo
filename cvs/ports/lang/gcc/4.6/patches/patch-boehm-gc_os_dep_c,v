head	1.4;
access;
symbols
	OPENBSD_6_0:1.4.0.16
	OPENBSD_6_0_BASE:1.4
	OPENBSD_5_9:1.4.0.12
	OPENBSD_5_9_BASE:1.4
	OPENBSD_5_8:1.4.0.14
	OPENBSD_5_8_BASE:1.4
	OPENBSD_5_7:1.4.0.10
	OPENBSD_5_7_BASE:1.4
	OPENBSD_5_6:1.4.0.8
	OPENBSD_5_6_BASE:1.4
	OPENBSD_5_5:1.4.0.6
	OPENBSD_5_5_BASE:1.4
	OPENBSD_5_4:1.4.0.4
	OPENBSD_5_4_BASE:1.4
	OPENBSD_5_3:1.4.0.2
	OPENBSD_5_3_BASE:1.4
	OPENBSD_5_2:1.3.0.2
	OPENBSD_5_2_BASE:1.3
	OPENBSD_5_1_BASE:1.2
	OPENBSD_5_1:1.2.0.2
	pascal_20111114:1.1.1.1
	pascal:1.1.1;
locks; strict;
comment	@# @;


1.4
date	2012.10.17.19.58.21;	author kurt;	state Exp;
branches;
next	1.3;

1.3
date	2012.02.28.20.00.16;	author pascal;	state Exp;
branches;
next	1.2;

1.2
date	2011.12.08.17.40.55;	author pascal;	state Exp;
branches;
next	1.1;

1.1
date	2011.11.14.13.00.57;	author pascal;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2011.11.14.13.00.57;	author pascal;	state Exp;
branches;
next	;


desc
@@


1.4
log
@Fix boehm-gc and increase gcj default thread stack size. Makes gjc work
well enough to bootstrap devel/jdk/1.6. okay pascal@@ jasper@@
@
text
@$OpenBSD: patch-boehm-gc_os_dep_c,v 1.3 2012/02/28 20:00:16 pascal Exp $
--- boehm-gc/os_dep.c.orig	Sun Mar 21 15:34:19 2010
+++ boehm-gc/os_dep.c	Tue Oct  9 16:05:42 2012
@@@@ -380,7 +380,7 @@@@ static void *tiny_sbrk(ptrdiff_t increment)
 #define sbrk tiny_sbrk
 # endif /* ECOS */
 
-#if (defined(NETBSD) || defined(OPENBSD)) && defined(__ELF__)
+#if defined(NETBSD) && defined(__ELF__)
   ptr_t GC_data_start;
 
   void GC_init_netbsd_elf()
@@@@ -393,6 +393,86 @@@@ static void *tiny_sbrk(ptrdiff_t increment)
   }
 #endif
 
+#if defined(OPENBSD)
+  static struct sigaction old_segv_act;
+  sigjmp_buf GC_jmp_buf_openbsd;
+
+    /*ARGSUSED*/
+    void GC_fault_handler_openbsd(int sig)
+    {
+       siglongjmp(GC_jmp_buf_openbsd, 1);
+    }
+
+    /* Return the first nonaddressible location > p or bound   */
+    /* Requires allocation lock.                               */
+    ptr_t GC_find_limit_openbsd(ptr_t p, ptr_t bound)
+    {
+        static volatile ptr_t result;
+               /* Safer if static, since otherwise it may not be       */
+               /* preserved across the longjmp.  Can safely be         */
+               /* static since it's only called with the               */
+               /* allocation lock held.                                */
+        struct sigaction act;
+       size_t pgsz = (size_t)sysconf(_SC_PAGESIZE);
+
+       GC_ASSERT(I_HOLD_LOCK());
+
+        act.sa_handler = GC_fault_handler_openbsd;
+        sigemptyset(&act.sa_mask);
+        act.sa_flags = SA_NODEFER | SA_RESTART;
+        sigaction(SIGSEGV, &act, &old_segv_act);
+
+       if (sigsetjmp(GC_jmp_buf_openbsd, 1) == 0) {
+           result = (ptr_t)(((word)(p)) & ~(pgsz-1));
+           for (;;) {
+               result += pgsz;
+               if (result >= bound) {
+                   result = bound;
+                   break;
+               }
+               GC_noop1((word)(*result));
+           }
+       }
+
+       sigaction(SIGSEGV, &old_segv_act, 0);
+
+       return(result);
+    }
+
+    /* Return first addressable location > p or bound */
+    /* Requires allocation lock. */
+    ptr_t GC_skip_hole_openbsd(ptr_t p, ptr_t bound)
+    {
+        static volatile ptr_t result;
+        struct sigaction act;
+       size_t pgsz = (size_t)sysconf(_SC_PAGESIZE);
+       static volatile int firstpass;
+
+       GC_ASSERT(I_HOLD_LOCK());
+
+        act.sa_handler = GC_fault_handler_openbsd;
+        sigemptyset(&act.sa_mask);
+        act.sa_flags = SA_NODEFER | SA_RESTART;
+        sigaction(SIGSEGV, &act, &old_segv_act);
+
+       firstpass = 1;
+       result = (ptr_t)(((word)(p)) & ~(pgsz-1));
+       if (sigsetjmp(GC_jmp_buf_openbsd, 1) != 0 || firstpass) {
+           firstpass = 0;
+           result += pgsz;
+           if (result >= bound) {
+               result = bound;
+           } else
+               GC_noop1((word)(*result));
+        }
+
+       sigaction(SIGSEGV, &old_segv_act, 0);
+
+       return(result);
+    }
+#endif
+
+
 # ifdef OS2
 
 # include <stddef.h>
@@@@ -1009,7 +1089,8 @@@@ ptr_t GC_get_stack_base()
 #endif /* FREEBSD_STACKBOTTOM */
 
 #if !defined(BEOS) && !defined(AMIGA) && !defined(MSWIN32) \
-    && !defined(MSWINCE) && !defined(OS2) && !defined(NOSYS) && !defined(ECOS)
+    && !defined(MSWINCE) && !defined(OS2) && !defined(NOSYS) && !defined(ECOS) \
+    && !defined(GC_OPENBSD_THREADS)
 
 ptr_t GC_get_stack_base()
 {
@@@@ -1069,6 +1150,25 @@@@ ptr_t GC_get_stack_base()
 
 # endif /* ! AMIGA, !OS 2, ! MS Windows, !BEOS, !NOSYS, !ECOS */
 
+#if defined(GC_OPENBSD_THREADS)
+
+/* Find the stack using pthread_stackseg_np() */
+
+# include <sys/signal.h>
+# include <pthread.h>
+# include <pthread_np.h>
+
+#define HAVE_GET_STACK_BASE
+
+ptr_t GC_get_stack_base()
+{
+    stack_t stack;
+    pthread_stackseg_np(pthread_self(), &stack);
+    return stack.ss_sp;
+}
+#endif /* GC_OPENBSD_THREADS */
+
+
 /*
  * Register static data segment(s) as roots.
  * If more data segments are added later then they need to be registered
@@@@ -1440,6 +1540,32 @@@@ int * etext_addr;
 
 #else /* !OS2 && !Windows && !AMIGA */
 
+#if defined(OPENBSD)
+
+/*
+ * Depending on arch alignment there can be multiple holes
+ * between DATASTART & DATAEND. Scan from DATASTART - DATAEND
+ * and register each region.
+ */
+void GC_register_data_segments(void)
+{
+  ptr_t region_start, region_end;
+
+  region_start = DATASTART;
+
+  for(;;) {
+    region_end = GC_find_limit_openbsd(region_start, DATAEND);
+    GC_add_roots_inner(region_start, region_end, FALSE);
+    if (region_end < DATAEND)
+       region_start = GC_skip_hole_openbsd(region_end, DATAEND);
+    else
+       break;
+  }
+}
+
+# else /* !OS2 && !Windows && !AMIGA && !OPENBSD */
+
+
 void GC_register_data_segments()
 {
 #   if !defined(PCR) && !defined(SRC_M3) && !defined(MACOS)
@@@@ -1497,6 +1623,7 @@@@ void GC_register_data_segments()
     /* change.								*/
 }
 
+# endif  /* ! OPENBSD */
 # endif  /* ! AMIGA */
 # endif  /* ! MSWIN32 && ! MSWINCE*/
 # endif  /* ! OS2 */
@


1.3
log
@fix boehm-gc with rthreads for gcc 4.6. based on kurt@@'s work.

ok espie@@
@
text
@d1 10
a10 4
$OpenBSD: patch-boehm-gc_os_dep_c,v 1.2 2011/12/08 17:40:55 pascal Exp $
--- boehm-gc/os_dep.c.orig	Tue Feb 21 00:39:27 2012
+++ boehm-gc/os_dep.c	Tue Feb 21 00:40:19 2012
@@@@ -385,14 +385,94 @@@@ static void *tiny_sbrk(ptrdiff_t increment)
d13 1
a13 8
   {
-    extern ptr_t GC_find_limit();
+    extern ptr_t GC_find_limit_openbsd();
     extern char **environ;
 	/* This may need to be environ, without the underscore, for	*/
 	/* some versions.						*/
-    GC_data_start = GC_find_limit((ptr_t)&environ, FALSE);
+    GC_data_start = GC_find_limit_openbsd((ptr_t)&environ, FALSE);
@


1.2
log
@- fix openbsd threads in boehm-gc; fixes egcj-dbtool (or, for that matter,
any gcj-compiled program)
- link boehm-gc with -pthread
- download and install ecj.jar (required by gcj)
- plist fixes
@
text
@d1 4
a4 4
$OpenBSD: patch-boehm-gc_os_dep_c,v 1.1.1.1 2011/11/14 13:00:57 pascal Exp $
--- boehm-gc/os_dep.c.orig	Sun Mar 21 20:34:19 2010
+++ boehm-gc/os_dep.c	Thu Dec  8 16:41:50 2011
@@@@ -385,14 +385,111 @@@@ static void *tiny_sbrk(ptrdiff_t increment)
a21 12
+# if defined(GC_OPENBSD_THREADS)
+#   include <sys/syscall.h>
+    sigset_t __syscall(quad_t, ...);
+# endif
+
+  /*
+   * Dont use GC_find_limit() because siglongjmp out of the
+   * signal handler by-passes our userland pthreads lib, leaving
+   * SIGSEGV and SIGPROF masked. Instead use this custom one
+   * that works-around the issues.
+   */
+
a58 5
+# if defined(GC_OPENBSD_THREADS)
+       /* due to the siglongjump we need to manually unmask SIGPROF */
+       __syscall(SYS_sigprocmask, SIG_UNBLOCK, sigmask(SIGPROF));
+# endif
+
d101 1
a101 1
@@@@ -1009,7 +1106,8 @@@@ ptr_t GC_get_stack_base()
d111 1
a111 1
@@@@ -1069,6 +1167,25 @@@@ ptr_t GC_get_stack_base()
d137 1
a137 1
@@@@ -1440,6 +1557,32 @@@@ int * etext_addr;
d170 1
a170 1
@@@@ -1497,6 +1640,7 @@@@ void GC_register_data_segments()
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
$OpenBSD$
d3 12
a14 2
+++ boehm-gc/os_dep.c	Sun Nov 13 10:50:24 2011
@@@@ -393,6 +393,103 @@@@ static void *tiny_sbrk(ptrdiff_t increment)
@


1.1.1.1
log
@now import for real, sorry ...
@
text
@@
