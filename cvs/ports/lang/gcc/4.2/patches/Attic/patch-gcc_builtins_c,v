head	1.4;
access;
symbols
	OPENBSD_5_7:1.3.0.14
	OPENBSD_5_7_BASE:1.3
	OPENBSD_5_6:1.3.0.12
	OPENBSD_5_6_BASE:1.3
	OPENBSD_5_5:1.3.0.10
	OPENBSD_5_5_BASE:1.3
	OPENBSD_5_4:1.3.0.8
	OPENBSD_5_4_BASE:1.3
	OPENBSD_5_3:1.3.0.6
	OPENBSD_5_3_BASE:1.3
	OPENBSD_5_2:1.3.0.4
	OPENBSD_5_2_BASE:1.3
	OPENBSD_5_1_BASE:1.3
	OPENBSD_5_1:1.3.0.2;
locks; strict;
comment	@# @;


1.4
date	2015.03.19.16.56.02;	author pascal;	state dead;
branches;
next	1.3;
commitid	4NK6qdfGpCJ0tDvy;

1.3
date	2011.12.03.15.54.05;	author naddy;	state Exp;
branches;
next	1.2;

1.2
date	2007.03.17.22.34.13;	author espie;	state dead;
branches;
next	1.1;

1.1
date	2007.03.17.21.58.46;	author espie;	state Exp;
branches;
next	;


desc
@@


1.4
log
@remove 4.2.  long unused, doesn't build, tobiasu@@ doesn't need it any more.

prompted by naddy@@, ok tobiasu@@
@
text
@$OpenBSD: patch-gcc_builtins_c,v 1.3 2011/12/03 15:54:05 naddy Exp $
--- gcc/builtins.c.orig	Wed Feb 20 18:33:07 2008
+++ gcc/builtins.c	Fri Dec  2 16:24:16 2011
@@@@ -3060,10 +3060,19 @@@@ expand_builtin_memmove (tree arglist, tree type, rtx t
 	 it is ok to use memcpy as well.  */
       if (integer_onep (len))
 	{
-	  rtx ret = expand_builtin_mempcpy (arglist, type, target, mode,
-					    /*endp=*/0);
-	  if (ret)
-	    return ret;
+#if defined(SUBWORD_ACCESS_P)
+	  if (SUBWORD_ACCESS_P
+	      || (src_align >= BIGGEST_ALIGNMENT
+		  && dest_align >= BIGGEST_ALIGNMENT))
+	    {
+#endif
+	      rtx ret = expand_builtin_mempcpy (arglist, type, target, mode,
+						/*endp=*/0);
+	      if (ret)
+		return ret;
+#if defined(SUBWORD_ACCESS_P)
+	    }
+#endif
 	}
 
       /* Otherwise, call the normal function.  */
@


1.3
log
@Merge in fixes for alpha from base (miod@@):

builtins.c:
Allow MD backend to prevent the optimization of a bcopy() or memmove() of
size 1 (the size being known at compile-time) into an inline mempcpy()
expansion, which will in turn expand into a byte load and store operation.
This expansion loses precious address alignment information at some point
(because everybody knows that you can read a byte from any address, right?),
and this loses bigtime on strict alignment platforms which lack the ability
to accesse bytes directly, such as alpha (unless compiling with -mbwx and
runnning on a BWX-capable cpu).

config/alpha:
Require alignment of local arrays on word boundaries, and enable
the builtins.c `one-byte memcpy' workaround.

ok espie@@
@
text
@d1 1
a1 1
$OpenBSD$
@


1.2
log
@revert commit mistake
@
text
@d1 24
a24 33
$OpenBSD: patch-gcc_builtins_c,v 1.1 2007/03/17 21:58:46 espie Exp $
--- gcc/builtins.c.orig	Wed Feb 28 20:21:20 2007
+++ gcc/builtins.c	Mon Mar 12 11:37:52 2007
@@@@ -12218,13 +12218,13 @@@@ do_mpfr_arg2 (tree arg1, tree arg2, tree
 	  int inexact;
 	  mpfr_t m1, m2;
 
-	  mpfr_inits2 (prec, m1, m2, NULL);
+	  mpfr_inits2 (prec, m1, m2, (void *)0);
 	  mpfr_from_real (m1, ra1);
 	  mpfr_from_real (m2, ra2);
 	  mpfr_clear_flags ();
 	  inexact = func (m1, m1, m2, GMP_RNDN);
 	  result = do_mpfr_ckconv (m1, type, inexact);
-	  mpfr_clears (m1, m2, NULL);
+	  mpfr_clears (m1, m2, (void *)0);
 	}
     }
   
@@@@ -12266,14 +12266,14 @@@@ do_mpfr_arg3 (tree arg1, tree arg2, tree
 	  int inexact;
 	  mpfr_t m1, m2, m3;
 
-	  mpfr_inits2 (prec, m1, m2, m3, NULL);
+	  mpfr_inits2 (prec, m1, m2, m3, (void *)0);
 	  mpfr_from_real (m1, ra1);
 	  mpfr_from_real (m2, ra2);
 	  mpfr_from_real (m3, ra3);
 	  mpfr_clear_flags ();
 	  inexact = func (m1, m1, m2, m3, GMP_RNDN);
 	  result = do_mpfr_ckconv (m1, type, inexact);
-	  mpfr_clears (m1, m2, m3, NULL);
+	  mpfr_clears (m1, m2, m3, (void *)0);
a25 5
     }
   
@@@@ -12310,13 +12310,13 @@@@ do_mpfr_sincos (tree arg, tree arg_sinp,
 	  int inexact;
 	  mpfr_t m, ms, mc;
d27 1
a27 12
-	  mpfr_inits2 (prec, m, ms, mc, NULL);
+	  mpfr_inits2 (prec, m, ms, mc, (void *)0);
 	  mpfr_from_real (m, ra);
 	  mpfr_clear_flags ();
 	  inexact = mpfr_sin_cos (ms, mc, m, GMP_RNDN);
 	  result_s = do_mpfr_ckconv (ms, type, inexact);
 	  result_c = do_mpfr_ckconv (mc, type, inexact);
-	  mpfr_clears (m, ms, mc, NULL);
+	  mpfr_clears (m, ms, mc, (void *)0);
 	  if (result_s && result_c)
 	    {
 	      /* If we are to return in a complex value do so.  */
@


1.1
log
@new gcc snapshot, this one compiles again on i386 !
NOTE: this needs current -src, in particular current includes
for libgfortran to build correctly (semantics change in __extern inline
that lead to duplicate isalnum symbols otherwise).
@
text
@d1 1
a1 1
$OpenBSD$
@

