head	1.36;
access;
symbols
	OPENBSD_6_0:1.36.0.6
	OPENBSD_6_0_BASE:1.36
	OPENBSD_5_9:1.36.0.2
	OPENBSD_5_9_BASE:1.36
	OPENBSD_5_8:1.36.0.4
	OPENBSD_5_8_BASE:1.36
	OPENBSD_5_7:1.35.0.2
	OPENBSD_5_7_BASE:1.35
	OPENBSD_5_6:1.34.0.2
	OPENBSD_5_6_BASE:1.34
	OPENBSD_5_5:1.33.0.2
	OPENBSD_5_5_BASE:1.33
	OPENBSD_5_4:1.27.0.2
	OPENBSD_5_4_BASE:1.27
	OPENBSD_5_3:1.23.0.2
	OPENBSD_5_3_BASE:1.23
	OPENBSD_5_2:1.18.0.4
	OPENBSD_5_2_BASE:1.18
	OPENBSD_5_1_BASE:1.18
	OPENBSD_5_1:1.18.0.2
	OPENBSD_5_0:1.11.0.2
	OPENBSD_5_0_BASE:1.11
	OPENBSD_4_9:1.5.0.2
	OPENBSD_4_9_BASE:1.5
	ports:1.1.1.1
	espie:1.1.1;
locks; strict;
comment	@# @;


1.36
date	2015.06.23.08.51.53;	author espie;	state Exp;
branches;
next	1.35;
commitid	32zs6aY8gWUWqLkN;

1.35
date	2014.12.07.15.18.50;	author espie;	state Exp;
branches;
next	1.34;
commitid	GynqjLfrNHwgIuss;

1.34
date	2014.03.17.10.48.40;	author espie;	state Exp;
branches;
next	1.33;

1.33
date	2014.02.09.15.24.20;	author espie;	state Exp;
branches;
next	1.32;

1.32
date	2014.01.31.17.32.29;	author gsoares;	state Exp;
branches;
next	1.31;

1.31
date	2013.12.07.16.03.03;	author espie;	state Exp;
branches;
next	1.30;

1.30
date	2013.11.12.22.11.50;	author espie;	state Exp;
branches;
next	1.29;

1.29
date	2013.10.06.13.33.34;	author espie;	state Exp;
branches;
next	1.28;

1.28
date	2013.10.03.17.42.58;	author espie;	state Exp;
branches;
next	1.27;

1.27
date	2013.06.25.19.48.14;	author espie;	state Exp;
branches;
next	1.26;

1.26
date	2013.06.25.09.05.19;	author espie;	state Exp;
branches;
next	1.25;

1.25
date	2013.03.11.11.55.22;	author espie;	state Exp;
branches;
next	1.24;

1.24
date	2013.03.03.00.40.42;	author espie;	state Exp;
branches;
next	1.23;

1.23
date	2013.01.21.02.01.08;	author espie;	state Exp;
branches;
next	1.22;

1.22
date	2013.01.10.10.26.34;	author espie;	state Exp;
branches;
next	1.21;

1.21
date	2012.10.11.08.05.03;	author espie;	state Exp;
branches;
next	1.20;

1.20
date	2012.10.11.07.38.39;	author espie;	state Exp;
branches;
next	1.19;

1.19
date	2012.09.23.18.13.32;	author espie;	state Exp;
branches;
next	1.18;

1.18
date	2012.01.14.12.26.21;	author espie;	state Exp;
branches;
next	1.17;

1.17
date	2011.12.02.11.40.25;	author espie;	state Exp;
branches;
next	1.16;

1.16
date	2011.11.13.10.28.32;	author espie;	state Exp;
branches;
next	1.15;

1.15
date	2011.11.05.18.27.13;	author espie;	state Exp;
branches;
next	1.14;

1.14
date	2011.10.10.18.56.50;	author espie;	state Exp;
branches;
next	1.13;

1.13
date	2011.10.03.08.53.49;	author espie;	state Exp;
branches;
next	1.12;

1.12
date	2011.09.28.10.13.51;	author espie;	state Exp;
branches;
next	1.11;

1.11
date	2011.06.15.10.06.22;	author espie;	state Exp;
branches;
next	1.10;

1.10
date	2011.06.04.12.56.54;	author espie;	state Exp;
branches;
next	1.9;

1.9
date	2011.06.02.11.53.55;	author espie;	state Exp;
branches;
next	1.8;

1.8
date	2011.05.29.11.06.23;	author espie;	state Exp;
branches;
next	1.7;

1.7
date	2011.05.22.08.21.39;	author espie;	state Exp;
branches;
next	1.6;

1.6
date	2011.03.22.19.48.01;	author espie;	state Exp;
branches;
next	1.5;

1.5
date	2010.12.07.10.56.26;	author espie;	state Exp;
branches;
next	1.4;

1.4
date	2010.12.06.13.20.45;	author espie;	state Exp;
branches;
next	1.3;

1.3
date	2010.11.14.07.44.53;	author espie;	state Exp;
branches;
next	1.2;

1.2
date	2010.10.27.12.58.26;	author espie;	state Exp;
branches;
next	1.1;

1.1
date	2010.08.20.13.40.13;	author espie;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2010.08.20.13.40.13;	author espie;	state Exp;
branches;
next	;


desc
@@


1.36
log
@tweak taintedness:
- fix actual bug in PortInfo
- restrict defined tags to !empty tags (shouldn't happen)
- track the source from locks as well.
@
text
@# ex:ts=8 sw=4:
# $OpenBSD: PortInfo.pm,v 1.35 2014/12/07 15:18:50 espie Exp $
#
# Copyright (c) 2010-2013 Marc Espie <espie@@openbsd.org>
#
# Permission to use, copy, modify, and distribute this software for any
# purpose with or without fee is hereby granted, provided that the above
# copyright notice and this permission notice appear in all copies.
#
# THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
# ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
# OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
use strict;
use warnings;
package AddInfo;

sub add
{
	my ($class, $var, $o, $value, $parent) = @@_;
	return if $value =~ m/^[\s\-]*$/;
	$o->{$var} = $class->new($value, $o, $parent);
}

sub new
{
	my ($class, $value) = @@_;
	bless \$value, $class;
}

sub string
{
	my $self = shift;
	return $$self;
}

sub quickie
{
	return 0;
}

package AddIgnore;
our @@ISA = qw(AddInfo);
sub string
{
	my $self = shift;
	my $msg = $$self;
	$msg =~ s/\\//g;
	$msg =~ s/\"\s+\"/\; /g;
	return $msg;
}



package AddYesNo;
our @@ISA = qw(AddInfo);

sub add
{
	my ($class, $var, $o, $value, $parent) = @@_;
	return if $value =~ m/^no$/i;
	$o->{$var} = $class->new($value, $o, $parent);
}

sub new
{
	my ($class, $value) = @@_;
	my $a = 1;
	bless \$a, $class;
}

# micro-optimisation: to save space and time, we only create value if
# PERMIT_DISTFILES* is != yes.

package AddNegative;
our @@ISA = qw(AddInfo);

sub add
{
	my ($class, $var, $o, $value, $parent) = @@_;
	return if $value =~ m/^yes$/i;
	$o->{$var} = $class->new($value, $o, $parent);
}

sub new
{
	my ($class, $value) = @@_;
	my $a = 0;
	bless \$a, $class;
}

package AddInfoShow;
our @@ISA = qw(AddInfo);
sub quickie
{
	return 1;
}

package AddList;
our @@ISA = qw(AddInfo);

sub make_list
{
	my ($class, $value) = @@_;
	$value =~ s/^\s+//;
	$value =~ s/\s+$//;
	return split(/\s+/, $value);
}

sub new
{
	my ($class, $value) = @@_;
	my %values = map {($_, 1)} $class->make_list($value);
	bless \%values, $class;
}

sub string
{
	my $self = shift;
	return join(', ', keys %$self);
}

package AddPropertyList;
our @@ISA = (qw(AddList));

sub new
{
	my ($class, $value) = @@_;
	my %h = ();
	for my $v ($class->make_list($value)) {
		if ($v =~ /^(tag)\:(.*)$/) {
			$h{$1} = $2;
		} else {
			$h{$v} = 1;
		}
	}
	bless \%h, $class;
}

sub string
{
	my $self = shift;
	my @@l = ();
	while (my ($k, $v) = each %$self) {
		if ($v eq '1') {
			push(@@l, $k);
		} else {
			push(@@l, "$k->$v");
		}
	}
	return join(',', @@l);
}

package AddOrderedList;
our @@ISA = qw(AddList);
sub new
{
	my ($class, $value) = @@_;
	bless [$class->make_list($value)], $class;
}

sub string
{
	my $self = shift;
	return join(' ', @@$self);
}

package FetchManually;
our @@ISA = qw(AddOrderedList);
sub add
{
	my ($class, $var, $o, $value, $parent) = @@_;
	return if $value =~ /^\s*no\s*$/i;
	$class->SUPER::add($var, $o, $value, $parent);
}

sub make_list
{
	my ($class, $value) = @@_;
	$value =~ s/^\s*\"//;
	$value =~ s/\"\s*$//;
	return split(/\"\s*\"/, $value);
}

sub string
{
	my $self = shift;
	return join("\n", @@$self);
}

package AddDepends;
our @@ISA = qw(AddList);
sub extra
{
	return 'EXTRA';
}

sub new
{
	my ($class, $value, $self, $parent) = @@_;
	my $r = {};
	for my $d ($class->make_list($value)) {
		my $copy = $d;
		next if $d =~ m/^$/;
		$d =~ s/^\:+//;
		$d =~ s/^[^\/]*\://;
		if ($d =~ s/\:(?:patch|build|configure)$//) {
			Extra->add($class->extra, $self, $d);
		} else {
			$d =~ s/\:$//;
			if ($d =~ m/[:<>=]/) {
				DPB::Util->die("Error: invalid *DEPENDS $copy");
			} else {
				my $info = DPB::PkgPath->new($d);
				$info->{parent} //= $parent;
				$r->{$info} = $info;
			}
		}
	}
	bless $r, $class;
}

sub string
{
	my $self = shift;
	return '['.join(';', map {$_->logname} (values %$self)).']';
}

sub quickie
{
	return 1;
}

package AddTestDepends;
our @@ISA = qw(AddDepends);
sub extra
{
	return 'EXTRA2';
}

package Extra;
our @@ISA = qw(AddDepends);

sub add
{
	my ($class, $key, $self, $value, $parent) = @@_;
	$self->{$key} //= bless {}, $class;
	my $path = DPB::PkgPath->new($value);
	$path->{parent} //= $parent;
	$self->{$key}{$path} = $path;
	return $self;
}

package DPB::PortInfo;
my %adder = (
# actual info from dump-vars
	FULLPKGNAME => "AddInfoShow",
	RUN_DEPENDS => "AddDepends",
	BUILD_DEPENDS => "AddDepends",
	LIB_DEPENDS => "AddDepends",
	SUBPACKAGE => "AddInfo",
	BUILD_PACKAGES => "AddList",
	DPB_PROPERTIES => "AddPropertyList",
	IGNORE => "AddIgnore",
	FLAVOR => "AddList",
	DISTFILES => 'AddList',
	PATCHFILES => 'AddList',
	SUPDISTFILES => 'AddList',
	DIST_SUBDIR => 'AddInfo',
	CHECKSUM_FILE => 'AddInfo',
	FETCH_MANUALLY => 'FetchManually',
	MISSING_FILES => 'AddList',
	MASTER_SITES => 'AddOrderedList',
	MASTER_SITES0 => 'AddOrderedList',
	MASTER_SITES1 => 'AddOrderedList',
	MASTER_SITES2 => 'AddOrderedList',
	MASTER_SITES3 => 'AddOrderedList',
	MASTER_SITES4 => 'AddOrderedList',
	MASTER_SITES5 => 'AddOrderedList',
	MASTER_SITES6 => 'AddOrderedList',
	MASTER_SITES7 => 'AddOrderedList',
	MASTER_SITES8 => 'AddOrderedList',
	MASTER_SITES9 => 'AddOrderedList',
	MULTI_PACKAGES => 'AddList',
	PERMIT_DISTFILES_FTP => 'AddNegative',
	PERMIT_DISTFILES_CDROM => 'AddNegative',
# not yet used, provision for regression tests
	TEST_DEPENDS => "AddTestDepends",
	NO_TEST => "AddNegative",
	TEST_IS_INTERACTIVE => "AddYesNo",
# extra stuff we're generating
	DEPENDS => "AddDepends",	# all BUILD_DEPENDS/LIB_DEPENDS
	EXTRA => "Extra",	# extract stuff and things in DEPENDS
	EXTRA2 => "Extra",	# extract stuff and things in TEST_DEPENDS
	BEXTRA => "Extra",	# EXTRA moved from todo to done
	BDEPENDS => "AddDepends",# DEPENDS moved from todo to done
	RDEPENDS => "AddDepends",# RUN_DEPENDS moved from todo to done
	DIST => "AddDepends",	# all DISTFILES with all info
	FDEPENDS => "AddDepends",# DISTFILES too, but after DISTIGNORE, 
				 # and shrinking
	# DISTIGNORE should be there ?
);

sub wanted
{
	my ($class, $var) = @@_;
	return $adder{$var};
}

sub new
{
	my ($class, $pkgpath) = @@_;
	$pkgpath->{info} = bless {}, $class;
}

sub add
{
	my ($self, $var, $value, $parent) = @@_;
	$adder{$var}->add($var, $self, $value, $parent);
}

sub dump
{
	my ($self, $fh) = @@_;
	for my $k (sort keys %adder) {
		print $fh "\t $k = ", $self->{$k}->string, "\n"
		    if defined $self->{$k};
	}
}

my $string = "ignored already";
my $s2 = "stub_name";
my $stub_name = bless(\$s2, "AddInfoShow");
my $stub_info = bless { IGNORE => bless(\$string, "AddIgnore"),
		FULLPKGNAME => $stub_name}, __PACKAGE__;

sub stub
{
	return $stub_info;
}

sub stub_name
{
	my $self = shift;
	$self->{FULLPKGNAME} = $stub_name;
}

sub is_stub
{
	return shift eq $stub_info;
}

use Data::Dumper;
sub quick_dump
{
	my ($self, $fh) = @@_;
	for my $k (sort keys %adder) {
		if (defined $self->{$k} and $adder{$k}->quickie) {
			print $fh "\t $k = ";
			if (ref($self->{$k}) eq 'HASH') {
				print $fh "????\n";
			} else {
				print $fh $self->{$k}->string, "\n" ;
			}
		}
	}
}

sub fullpkgname
{
	my $self = shift;

	return (defined $self->{FULLPKGNAME}) ?
	    $self->{FULLPKGNAME}->string : undef;
}

sub has_property
{
	my ($self, $name) = @@_;
	return (defined $self->{DPB_PROPERTIES}) ?
	    $self->{DPB_PROPERTIES}{$name} : undef;
}

sub want_tests
{
	my ($self, $name) = @@_;
	if (defined $self->{NO_TEST} && $self->{NO_TEST} == 0) {
		return 1;
	} else {
		return 0;
	}
}

sub solve_depends
{
	my ($self, $withtest) = @@_;
	if (!defined $self->{solved}) {
		my $dep = {};
		my @@todo = (qw(DEPENDS BDEPENDS));
		if ($withtest) {
			push(@@todo, qw(TDEPENDS));
		}
		for my $k (@@todo) {
		
			if (exists $self->{$k}) {
				for my $d (values %{$self->{$k}}) {
					$dep->{$d->fullpkgname} = 1;
				}
			}
			next unless exists $self->{BEXTRA};
			for my $two (values %{$self->{BEXTRA}}) {
				next unless exists $two->{info}{$k};
				for my $d (values %{$two->{info}{$k}}) {
					$dep->{$d->fullpkgname} = 1;
				}
			}
		}
		bless $dep, 'AddList';
		$self->{solved} = $dep;
	}
	return $self->{solved};
}

1;
@


1.35
log
@wrap die so that it drops into the debugger if we run under perl -d.

change the way we do rescans again, to avoid race conditions:
just store away *all* pkgpaths related to the rescan (so that multi-packages
are covered) and then do the rescan. Hold those like we do for normal locks
but in a different list, and release them when the scan is over.

remove the atrocious shennanigans wrt fullpkgnames, it shouldn't be needed
again, hopefully.
@
text
@d2 1
a2 1
# $OpenBSD: PortInfo.pm,v 1.34 2014/03/17 10:48:40 espie Exp $
d383 2
a384 2
	return defined $self->{DPB_PROPERTIES} &&
	    $self->{DPB_PROPERTIES}{$name};
@


1.34
log
@prepare for perl 5.18
- don't bother declaring $_ for while(<>) loops. assume current default
will still work.
- rename variable for readability elsewhere.
@
text
@d2 1
a2 1
# $OpenBSD: PortInfo.pm,v 1.33 2014/02/09 15:24:20 espie Exp $
d215 1
a215 1
				die "Error: invalid *DEPENDS $copy";
@


1.33
log
@typo, avoid creating oodles of empty objects
@
text
@d2 1
a2 1
# $OpenBSD: PortInfo.pm,v 1.32 2014/01/31 17:32:29 gsoares Exp $
d205 7
a211 7
	for my $_ ($class->make_list($value)) {
		my $copy = $_;
		next if m/^$/;
		s/^\:+//;
		s/^[^\/]*\://;
		if (s/\:(?:patch|build|configure)$//) {
			Extra->add($class->extra, $self, $_);
d213 2
a214 2
			s/\:$//;
			if (m/[:<>=]/) {
d217 1
a217 1
				my $info = DPB::PkgPath->new($_);
@


1.32
log
@s,NO_TESTS,NO_TEST,
OK espie@@

Note that the changed code is not yet implemented, so no functional change.
@
text
@d2 1
a2 1
# $OpenBSD: PortInfo.pm,v 1.31 2013/12/07 16:03:03 espie Exp $
d176 1
a176 1
	return if $value =~ /^\s*no\*$/i;
@


1.31
log
@preliminary scaffolding to handle tests: create specific task types
for dependencies and for running tests.

fix PortInfo to know whether tests are required.
Amend PortBuilder to be able to launch tests.

(there are pieces missing in the engine, like a secondary queue with forced
affinity to run actual tests, and the portbuilder code is very incomplete
and needs love)
@
text
@d2 1
a2 1
# $OpenBSD: PortInfo.pm,v 1.30 2013/11/12 22:11:50 espie Exp $
d390 1
a390 1
	if (defined $self->{NO_TESTS} && $self->{NO_TESTS} == 0) {
@


1.30
log
@redo the discovery of tree yet once again, after issues found out by naddy@@
following the bsd.port.arch.mk change. Suddenly, some paths make their way
into the build where they should not !

This actually comes from setting up wantbuild/wantinfo straight when building
path lists.

So reorganize stuff:
- don't ask for more scans during straight dump-vars reading.
- perform the "BUILD_PACKAGES may vanish from MULTI_PACKAGES" early in
merge_depends.
- do add appropriate wantbuild/wantinfo during actual dependency registration
there, which ensures depends that got ignored will be built.

This should restore proper behavior and fix long-standing semi-random
behavior.
@
text
@d2 1
a2 1
# $OpenBSD: PortInfo.pm,v 1.29 2013/10/06 13:33:34 espie Exp $
d292 1
a292 1
	NO_TEST => "AddYesNo",
d387 10
d399 1
a399 1
	my $self = shift;
d402 5
a406 1
		for my $k (qw(DEPENDS BDEPENDS)) {
@


1.29
log
@update my copyright to 2013
@
text
@d2 1
a2 1
# $OpenBSD: PortInfo.pm,v 1.28 2013/10/03 17:42:58 espie Exp $
a218 1
				$info->{wantbuild} = 1;
a251 1
	$path->{wantinfo} = 1;
@


1.28
log
@scaffolding for some cool work happening.
NO SERVICEABLE USER PARTS INSIDE! this is a dirty hack to make inroads
on a fairly complicated issue.
@
text
@d2 1
a2 1
# $OpenBSD: PortInfo.pm,v 1.27 2013/06/25 19:48:14 espie Exp $
d4 1
a4 1
# Copyright (c) 2010 Marc Espie <espie@@openbsd.org>
@


1.27
log
@sorry sebastia, that's a typo
@
text
@d2 1
a2 1
# $OpenBSD: PortInfo.pm,v 1.26 2013/06/25 09:05:19 espie Exp $
d126 31
d268 1
a268 1
	DPB_PROPERTIES => "AddList",
@


1.26
log
@tricky (problem found by sebastia@@ on vax...): BUILD_PACKAGES makes
subpackages vanish too entirely, so later, when other ports want them
as dependencies, we're in trouble!

Instead, record both MULTI and BUILD, and compare them when merging depend.
Don't stub out the new paths directly, but "pre-stub them out" with an
IGNOREd message, so the engine picks them, stubs them out for real, and
logs the reason.
@
text
@d2 1
a2 1
# $OpenBSD: PortInfo.pm,v 1.25 2013/03/11 11:55:22 espie Exp $
d258 1
a258 1
	MULTI_PACkAGES => 'AddList',
@


1.25
log
@rename
@
text
@d2 1
a2 1
# $OpenBSD: PortInfo.pm,v 1.24 2013/03/03 00:40:42 espie Exp $
d258 1
d307 1
d309 1
a309 1
		FULLPKGNAME => bless(\$s2, "AddInfoShow")}, __PACKAGE__;
d314 6
@


1.24
log
@stub_name has one single word, in case this ends up in the log.
@
text
@d2 1
a2 1
# $OpenBSD: PortInfo.pm,v 1.23 2013/01/21 02:01:08 espie Exp $
d207 1
a207 1
package AddRegressDepends;
d260 4
a263 4
# not yet used, provision for regression
	REGRESS_DEPENDS => "AddRegressDepends",
	NO_REGRESS => "AddYesNo",
	REGRESS_IS_INTERACTIVE => "AddYesNo",
d267 1
a267 1
	EXTRA2 => "Extra",	# extract stuff and things in REGRESS_DEPENDS
@


1.23
log
@move the dependency solver to PortInfo, so it can be reused if necessary
@
text
@d2 1
a2 1
# $OpenBSD: PortInfo.pm,v 1.22 2013/01/10 10:26:34 espie Exp $
d305 1
a305 1
my $s2 = "stub name";
d312 5
@


1.22
log
@a bit of refactoring: provide simple ways to check DPB_PROPERTIES without
having a hash element spring into existence, and to list jobs running on
the same host.
@
text
@d2 1
a2 1
# $OpenBSD: PortInfo.pm,v 1.21 2012/10/11 08:05:03 espie Exp $
d343 26
@


1.21
log
@reorganize and comment portinfo
@
text
@d2 1
a2 1
# $OpenBSD: PortInfo.pm,v 1.20 2012/10/11 07:38:39 espie Exp $
d336 7
@


1.20
log
@move to using BUILD_PACKAGES, so we have the actual tidy list.

Stupid NFS work-around:
during/after cleanup, wait until the packages show up.
Each wait period of ten seconds will show up as waiting#n.
@
text
@d2 1
a2 1
# $OpenBSD: PortInfo.pm,v 1.19 2012/09/23 18:13:32 espie Exp $
d230 1
a234 3
	REGRESS_DEPENDS => "AddRegressDepends",
	NO_REGRESS => "AddYesNo",
	REGRESS_IS_INTERACTIVE => "AddYesNo",
a237 8
	EXTRA => "Extra",
	EXTRA2 => "Extra",
	BEXTRA => "Extra",
	DEPENDS => "AddDepends",
	BDEPENDS => "AddDepends",
	RDEPENDS => "AddDepends",
	DIST => "AddDepends",
	FDEPENDS => "AddDepends",
a239 2
	NEEDED_BY => "AddDepends",
	BNEEDED_BY => "AddDepends",
d260 15
@


1.19
log
@new framework to deal with the new ports cluster, to be documented
@
text
@d2 1
a2 1
# $OpenBSD: PortInfo.pm,v 1.18 2012/01/14 12:26:21 espie Exp $
a237 1
	MULTI_PACKAGES => "AddList",
@


1.18
log
@add support to obey PERMIT_DISTFILES*
@
text
@d2 1
a2 1
# $OpenBSD: PortInfo.pm,v 1.17 2011/12/02 11:40:25 espie Exp $
d239 2
@


1.17
log
@EXTRA should (partly) be handled like DEPENDS/BDEPENDS
@
text
@d2 1
a2 1
# $OpenBSD: PortInfo.pm,v 1.16 2011/11/13 10:28:32 espie Exp $
d75 20
d269 2
@


1.16
log
@oops, fix FETCH_MANUALLY bug.
Prepare for MISSING_FILES
@
text
@d2 1
a2 1
# $OpenBSD: PortInfo.pm,v 1.15 2011/11/05 18:27:13 espie Exp $
d221 1
@


1.15
log
@propagate IGNOREd status to dependent ports.
display directly into engine.log.
replace all info with a stub "ignored already".
This shrinks memory usage some more.
@
text
@d2 1
a2 1
# $OpenBSD: PortInfo.pm,v 1.14 2011/10/10 18:56:50 espie Exp $
d125 1
a125 1
	return if $value =~ /no/i;
d236 1
@


1.14
log
@unfuck pkgpaths.
- instead of seen/unseen, have an actual constructor. Instead, mark pkgpath
for which we wantinfo/wantbuild.
- only mark EXTRA dependencies as wantinfo. So the devel/haddock,no_deps
temporary error should be gone.
- since we have FLAVOR and SUBPACKAGE available, construct as much info as
we can during vars scanning (see handle_equivalences). This avoids about 150
path rescans during a full bulk. Also, grab the timing and logsizes from
equivalent files, so that most stuff should know show % all the time.
- tweak subdirlist to be a hash, and correctly add pkgpath_and_flavors to it.
That way, we rescan avahi pseudo flavors just once, and not four or five times.
@
text
@d2 1
a2 1
# $OpenBSD: PortInfo.pm,v 1.13 2011/10/03 08:53:49 espie Exp $
d274 10
@


1.13
log
@FLAVOR is obviously a list
@
text
@d2 1
a2 1
# $OpenBSD: PortInfo.pm,v 1.12 2011/09/28 10:13:51 espie Exp $
d168 1
d202 1
@


1.12
log
@cosmetic: let IGNORE string behave
@
text
@d2 1
a2 1
# $OpenBSD: PortInfo.pm,v 1.11 2011/06/15 10:06:22 espie Exp $
d225 1
a225 1
	FLAVOR => "AddInfo",
@


1.11
log
@parse regression info if present
@
text
@d2 1
a2 1
# $OpenBSD: PortInfo.pm,v 1.10 2011/06/04 12:56:54 espie Exp $
d45 13
d224 2
a225 1
	IGNORE => "AddInfo",
@


1.10
log
@keep a better list of depends, so that pkg_add does add exactly what it should
@
text
@d2 1
a2 1
# $OpenBSD$
d45 17
d132 5
d147 1
a147 1
			Extra->add('EXTRA', $self, $_);
d173 7
d199 3
d205 1
@


1.9
log
@add stuff to do quick_dump of distinfo eventually
@
text
@d2 1
a2 1
# $OpenBSD: PortInfo.pm,v 1.8 2011/05/29 11:06:23 espie Exp $
d174 1
d184 1
a184 1
	DIST_SUBDIR => 'AddInfo', 
@


1.8
log
@if we -f -a, then scan SUPBDISTFILES too, and use the Distfile cache
to write a list of all known distfiles, that can be used to remove extra
stuff from /usr/ports/distfiles
@
text
@d2 1
a2 1
# $OpenBSD: PortInfo.pm,v 1.7 2011/05/22 08:21:39 espie Exp $
d143 1
a143 1
	return '['.join(';', map {$_->fullpkgpath} (values %$self)).']';
d175 2
@


1.7
log
@initial support for fetching distfiles, somewhat experimental yet.
- clean up clock handling, jobs with timer.
- pass more parameters thru state
- tweak the engine to handle distfiles
- lots of new code in Fetch for new jobs.
@
text
@d2 1
a2 1
# $OpenBSD: PortInfo.pm,v 1.6 2011/03/22 19:48:01 espie Exp $
d180 1
@


1.6
log
@add the glue that parses fetch info and build distinfo for future fetching.
also let Vars report stuff it doesn't know about to the logs file.
@
text
@d2 1
a2 1
# $OpenBSD: PortInfo.pm,v 1.5 2010/12/07 10:56:26 espie Exp $
d90 23
d182 1
@


1.5
log
@better info rebuild: make Vars responsible for creating info "just in time"
by keeping local state.
That way, when we rescan, we don't have to remove any info, and all affected
infos are replaced at the same time.
@
text
@d2 1
a2 1
# $OpenBSD: PortInfo.pm,v 1.4 2010/12/06 13:20:45 espie Exp $
d76 14
d155 15
@


1.4
log
@tag dependencies discovered as pure dependencies with their parents, allow
finding out non-sensical stuff in an easier way
@
text
@d2 1
a2 1
# $OpenBSD: PortInfo.pm,v 1.3 2010/11/14 07:44:53 espie Exp $
d121 3
a123 3
	my $info = DPB::PkgPath->new($value);
	$info->{parent} //= $parent;
	$self->{$key}{$info} = $info;
d152 1
a152 1
	$pkgpath->{info} //= bless {}, $class;
@


1.3
log
@prepare to deal with new depends
@
text
@d2 1
a2 1
# $OpenBSD: PortInfo.pm,v 1.2 2010/10/27 12:58:26 espie Exp $
d23 1
a23 1
	my ($class, $var, $o, $value) = @@_;
d25 1
a25 1
	$o->{$var} = $class->new($value, $o);
d80 1
a80 1
	my ($class, $value, $self) = @@_;
d95 1
d119 1
a119 1
	my ($class, $key, $self, $value) = @@_;
d122 1
d157 2
a158 2
	my ($self, $var, $value) = @@_;
	$adder{$var}->add($var, $self, $value);
@


1.2
log
@tie engine with var grabber, get ready to re-do port meta on error.
@
text
@d2 1
a2 1
# $OpenBSD$
d85 2
a86 1
		s/^.*?\:.*?\://;
@


1.1
log
@Initial revision
@
text
@d2 1
a2 1
# $OpenBSD: PortInfo.pm,v 1.4 2010/07/14 14:34:34 espie Exp $
@


1.1.1.1
log
@move stuff here from infra/build
@
text
@@
