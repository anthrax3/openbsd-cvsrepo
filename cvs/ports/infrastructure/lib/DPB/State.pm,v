head	1.19;
access;
symbols
	OPENBSD_6_1:1.19.0.2
	OPENBSD_6_1_BASE:1.19
	OPENBSD_6_0:1.18.0.2
	OPENBSD_6_0_BASE:1.18
	OPENBSD_5_9:1.15.0.2
	OPENBSD_5_9_BASE:1.15
	OPENBSD_5_8:1.14.0.4
	OPENBSD_5_8_BASE:1.14
	OPENBSD_5_7:1.8.0.4
	OPENBSD_5_7_BASE:1.8
	OPENBSD_5_6:1.8.0.2
	OPENBSD_5_6_BASE:1.8
	OPENBSD_5_5:1.7.0.2
	OPENBSD_5_5_BASE:1.7;
locks; strict;
comment	@# @;


1.19
date	2016.10.21.00.45.43;	author espie;	state Exp;
branches;
next	1.18;
commitid	v9KVbVh2NnL7Ndbt;

1.18
date	2016.06.28.15.28.20;	author espie;	state Exp;
branches;
next	1.17;
commitid	vwMZvbsIdSgs6ITN;

1.17
date	2016.05.08.12.52.58;	author espie;	state Exp;
branches;
next	1.16;
commitid	r5Crlv4JrY4KrbfQ;

1.16
date	2016.04.26.17.19.41;	author espie;	state Exp;
branches;
next	1.15;
commitid	W314TWfD9ovkE9vw;

1.15
date	2015.08.24.10.16.18;	author espie;	state Exp;
branches;
next	1.14;
commitid	jf96P99j0SQ3ZVuH;

1.14
date	2015.07.28.09.20.54;	author espie;	state Exp;
branches;
next	1.13;
commitid	MUUWB0Tymcm2J4im;

1.13
date	2015.05.10.08.14.14;	author espie;	state Exp;
branches;
next	1.12;
commitid	J9XuZmxJc7sLMZLF;

1.12
date	2015.04.27.13.32.57;	author espie;	state Exp;
branches;
next	1.11;
commitid	OZaepSq8a1Uo1Af9;

1.11
date	2015.04.26.18.00.19;	author espie;	state Exp;
branches;
next	1.10;
commitid	V6PNfhncU60d7XW1;

1.10
date	2015.04.21.09.53.13;	author espie;	state Exp;
branches;
next	1.9;
commitid	lGAocVQGyzRmFit9;

1.9
date	2015.03.14.20.45.11;	author espie;	state Exp;
branches;
next	1.8;
commitid	F3KXERWdpj8W1V50;

1.8
date	2014.03.17.10.48.40;	author espie;	state Exp;
branches;
next	1.7;

1.7
date	2013.11.16.16.39.28;	author espie;	state Exp;
branches;
next	1.6;

1.6
date	2013.11.16.13.06.00;	author espie;	state Exp;
branches;
next	1.5;

1.5
date	2013.10.17.12.48.10;	author espie;	state Exp;
branches;
next	1.4;

1.4
date	2013.10.17.08.31.45;	author espie;	state Exp;
branches;
next	1.3;

1.3
date	2013.10.13.18.31.51;	author espie;	state Exp;
branches;
next	1.2;

1.2
date	2013.10.06.13.33.34;	author espie;	state Exp;
branches;
next	1.1;

1.1
date	2013.10.02.09.00.34;	author espie;	state Exp;
branches;
next	;


desc
@@


1.19
log
@dpb cleans the permanent logs, always using the same pattern,
so write a method for that.

And don't fail silently when it doesn't work, because that causes
trouble down the line.

(e.g., your log user must be able to write into build-stats!!!)
@
text
@# ex:ts=8 sw=4:
# $OpenBSD: State.pm,v 1.18 2016/06/28 15:28:20 espie Exp $
#
# Copyright (c) 2010-2013 Marc Espie <espie@@openbsd.org>
#
# Permission to use, copy, modify, and distribute this software for any
# purpose with or without fee is hereby granted, provided that the above
# copyright notice and this permission notice appear in all copies.
#
# THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
# ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
# OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

use strict;
use warnings;

package DPB::InteractiveStub;

sub new
{
	my $class = shift;
	bless {}, $class;
}

sub is_interactive
{
	return 0;
}

sub want_report
{
	return 1;
}

sub may_ask_for_commands
{
	return 0;
}

package DPB::State;
our @@ISA = qw(OpenBSD::State);

use OpenBSD::State;
use OpenBSD::Paths;
use DPB::Heuristics;
use DPB::PkgPath;
use DPB::Logger;
use DPB::Config;
use File::Path;
use File::Basename;
use DPB::Core;
use DPB::Core::Init;
use DPB::Locks;
use DPB::Serialize;

sub define_present
{
	my ($self, $k) = @@_;
	return defined $self->{subst}{$k};
}

sub init
{
	my $self = shift;
	$self->SUPER::init;
	$self->{no_exports} = 1;
	$self->{heuristics} = DPB::Heuristics->new($self);
	$self->{make} = $ENV{MAKE} || OpenBSD::Paths->make;
	$self->{starttime} = time();
	$self->{interactive} = DPB::InteractiveStub->new;

	return $self;
}

sub is_interactive
{
	my $self = shift;
	return $self->{interactive}->is_interactive;
}

sub want_report
{
	my $self = shift;
	return $self->{interactive}->want_report;
}

sub may_ask_for_commands
{
	my $self = shift;
	return $self->{interactive}->may_ask_for_commands;
}

sub startdate
{
	my $self = shift;
	my @@l = gmtime $self->{starttime};
	$l[5] += 1900;
	$l[4] ++;
	return sprintf '%04d-%02d-%02d@@%02d:%02d:%02d', @@l[5,4,3,2,1,0];
}

sub anchor
{
	my ($self, $path) = @@_;
	if ($self->{chroot}) {
		return join('/', $self->{chroot}, $path);
	} else {
		return $path;
	}
}

sub expand_path
{
	my ($self, $path) = @@_;
	$path =~ s/\%L/$self->{logdir}/g;
	$path =~ s/\%p/$self->{realports}/g;
	$path =~ s/\%h/DPB::Core::Local->hostname/ge;
	$path =~ s/\%a/$self->{arch}/g;
	$path =~ s/\%t/$self->{starttime}/g;
	$path =~ s/\%d/$self->startdate/ge;
	$path =~ s/\%f/$self->{realdistdir}/g;
	return $path;
}

sub expand_chrooted_path
{
	my ($self, $path) = @@_;
	$path =~ s/\%L/$self->{logdir}/g;
	$path =~ s/\%p/$self->{ports}/g;
	$path =~ s/\%h/DPB::Core::Local->hostname/ge;
	$path =~ s/\%a/$self->{arch}/g;
	$path =~ s/\%t/$self->{starttime}/g;
	$path =~ s/\%d/$self->startdate/ge;
	$path =~ s/\%f/$self->{distdir}/g;
	return $path;
}

sub interpret_path
{
	my ($state, $path, $do, $scale) = @@_;

	my $weight;
	if ($path =~ s/\=(.*)//) {
		$weight = $1;
	}
	if ($path =~ s/\*(\d+)$//) {
		$scale = $1;
	}
	$path =~ s/\/+$//;
	$path =~ s/^\.\/+//;
	my $p = DPB::PkgPath->new($path);
	if (defined $scale) {
		$p->{scaled} = $scale;
	}
	for my $d (@@{$state->{portspath}}) {
		if (-d join('/', $d , $p->pkgpath)) {
			&$do($p, $weight);
			return;
	   	} 
	}
	$state->usage("Bad package path: #1", $path);
}

sub interpret_paths
{
	my $state = shift;
	my $do = pop;
	for my $file (@@_) {
		my $scale;
		if ($file =~ s/\*(\d+)$//) {
			$scale = $1;
		}

		my $fh = $state->logger->open('<', $file);
		if (defined $fh) {
			while (<$fh>) {
				chomp;
				s/\s*(?:\#.*)?$//;
				next if m/^$/;
				$state->interpret_path($_, $do, $scale);
			}
		} else {
			$state->interpret_path($file, $do);
		}
	}
}

sub handle_options
{
	my $state = shift;
	DPB::Config->parse_command_line($state);
	# at this point, we should know all our ids!
	$state->{logger} = DPB::Logger->new($state);
	$state->{locker} = DPB::Locks->new($state);
	DPB::Core::Init->init_cores($state);
	DPB::Core->reap;
	$state->sizer->parse_size_file;
	DPB::Limiter->setup($state->logger);
	$state->{concurrent} = $state->{logger}->append("concurrent");
	DPB::Core->reap;
}

sub SUPER_handle_options
{
	my ($state, @@p) = @@_;
	$state->SUPER::handle_options(@@p);
}

sub logger
{
	return shift->{logger};
}

sub heuristics
{
	return shift->{heuristics};
}

sub sizer
{
	return shift->{sizer};
}
sub locker
{
	return shift->{locker};
}

sub stalelocks
{
	return shift->locker->{stalelocks};
}

sub builder
{
	return shift->{builder};
}

sub engine
{
	return shift->{engine};
}

sub grabber
{
	return shift->{grabber};
}

sub fetch
{
	return shift->{grabber}{fetch};
}

sub make
{
	return shift->{make};
}

sub make_args
{
	my $self = shift;
	my @@l = ($self->{make}, "-C", $self->{ports});
	if ($self->{build_once}) {
		push(@@l, 'BUILD_ONCE=Yes');
	}
	return @@l;
}

sub ports
{
	return shift->{ports};
}

sub fullrepo
{
	return shift->{fullrepo};
}

sub distdir
{
	return shift->{realdistdir};
}

sub localarch
{
	return shift->{localarch};
}

sub arch
{
	return shift->{arch};
}

sub logdir
{
	return shift->{logdir};
}

sub parse_build_line
{
	return split(/\s+/, shift);
}

sub parse_build_file
{
	my ($state, $fname) = @@_;
	if (!-f $fname) {
		my $arch = $state->arch;
		if (-f "$fname/$arch/build.log") {
			$fname = "$fname/$arch/build.log";
		} elsif (-f "$fname/build.log") {
			$fname = "$fname/build.log";
		}
	}
	open my $fh, '<', $fname or return;
	while (<$fh>) {
		next if m/!$/;
		my $s = DPB::Serialize::Build->read($_);
		next if !defined $s->{size};
		my $o = DPB::PkgPath->new($s->{pkgpath});
		push(@@{$o->{stats}}, $s);
	}
}

sub add_build_info
{
	my ($state, @@consumers) = @@_;
	for my $p (DPB::PkgPath->seen) {
		next unless defined $p->{stats};
		my ($i, $time, $sz, $host);
		for my $s (@@{$p->{stats}}) {
			$time += $s->{time};
			$sz += $s->{size};
			$i++;
			$host = $s->{host}; # XXX
		}
		for my $c (@@consumers) {
			$c->add_build_info($p, $host, $time/$i, $sz/$i);
		}
	}
}

sub rewrite_build_info
{
	my $state = shift;
	$state->{log_user}->rewrite_file($state, $state->{permanent_log},
	    sub {
	    	my $f = shift;
		for my $p (sort {$a->fullpkgpath cmp $b->fullpkgpath}
		    DPB::PkgPath->seen) {
			next unless defined $p->{stats};
			shift @@{$p->{stats}} while @@{$p->{stats}} > 10;
			for my $s (@@{$p->{stats}}) {
				print $f DPB::Serialize::Build->write($s), "\n";
			}
			delete $p->{stats};
		}
	    });
}

sub handle_build_files
{
	my $state = shift;
	return if $state->{fetch_only};
	return unless defined $state->{build_files};
	print "Reading build stats...";
	for my $file (@@{$state->{build_files}}) {
		$state->parse_build_file($file);
	}
	$state->heuristics->calibrate(DPB::Core::Init->cores);
	$state->add_build_info($state->heuristics, "DPB::Job::Port");
	print "zapping old stuff...";
	$state->rewrite_build_info($state->{permanent_log});
	print "Done\n";
	$state->heuristics->finished_parsing;
}

sub find_window_size
{
	my ($state, $cont) = @@_;
	$state->SUPER::find_window_size;
	if (defined $state->{reporter}) {
		$state->{reporter}->sig_received($cont);
	}
}
1;
@


1.18
log
@reuse base window detection code and signal handler (requires fairly recent
base code)
@
text
@d2 1
a2 1
# $OpenBSD: State.pm,v 1.17 2016/05/08 12:52:58 espie Exp $
d349 1
a349 3
	$state->{log_user}->make_path(File::Basename::dirname(
	    $state->{permanent_log}));
	$state->{log_user}->run_as(
d351 1
a351 1
		open my $f, '>', $state->{permanent_log}.'.part' or return;
a360 2
		close $f;
		rename $state->{permanent_log}.'.part', $state->{permanent_log};
@


1.17
log
@make things work better when chrooted, delay some expansions, and acknowledge
that startup is going to run within the chroot.
@
text
@d2 1
a2 1
# $OpenBSD: State.pm,v 1.16 2016/04/26 17:19:41 espie Exp $
d385 8
@


1.16
log
@misleading name: anchor works on any path.
distfiles are actually under the chroot, didn't see that because I usually
have my ports tree directly under the root :(
@
text
@d2 1
a2 1
# $OpenBSD: State.pm,v 1.15 2015/08/24 10:16:18 espie Exp $
d126 13
@


1.15
log
@a bit of interactive mode. Just hooks into the main loop and can prompt for
commands now, can't do anything serious yet.
@
text
@d2 1
a2 1
# $OpenBSD: State.pm,v 1.14 2015/07/28 09:20:54 espie Exp $
d108 1
a108 1
	my ($self, $dir) = @@_;
d110 1
a110 1
		return join('/', $self->{chroot}, $dir);
d112 1
a112 1
		return $dir;
@


1.14
log
@open path files with logger user.
noticed by krw@@
@
text
@d2 1
a2 1
# $OpenBSD: State.pm,v 1.13 2015/05/10 08:14:14 espie Exp $
d21 23
d74 1
d77 18
@


1.13
log
@rename logger interface to desambiguate vs user.
@
text
@d2 1
a2 1
# $OpenBSD: State.pm,v 1.12 2015/04/27 13:32:57 espie Exp $
d123 2
a124 3
		if (-f $file) {
			open my $fh, '<', $file or
			    $state->usage("Can't open $file");
@


1.12
log
@more or less "the final" dpb pieces for fetching as a separate user.
@
text
@d2 1
a2 1
# $OpenBSD: State.pm,v 1.11 2015/04/26 18:00:19 espie Exp $
d149 1
a149 1
	$state->{concurrent} = $state->{logger}->open("concurrent");
@


1.11
log
@use UserProxy and make_path method.
Have the default host handle chroot correctly.

(still a bit of fetch to fix)
@
text
@d2 1
a2 1
# $OpenBSD: State.pm,v 1.10 2015/04/21 09:53:13 espie Exp $
d196 5
@


1.10
log
@setting the stage for further changes
@
text
@d2 1
a2 1
# $OpenBSD: State.pm,v 1.9 2015/03/14 20:45:11 espie Exp $
d290 13
a302 8
	File::Path::mkpath(File::Basename::dirname($state->{permanent_log}));
	open my $f, '>', $state->{permanent_log}.'.part' or return;
	for my $p (sort {$a->fullpkgpath cmp $b->fullpkgpath}
	    DPB::PkgPath->seen) {
		next unless defined $p->{stats};
		shift @@{$p->{stats}} while @@{$p->{stats}} > 10;
		for my $s (@@{$p->{stats}}) {
			print $f DPB::Serialize::Build->write($s), "\n";
d304 3
a306 4
		delete $p->{stats};
	}
	close $f;
	rename $state->{permanent_log}.'.part', $state->{permanent_log};
@


1.9
log
@use make -C
@
text
@d2 1
a2 1
# $OpenBSD: State.pm,v 1.8 2014/03/17 10:48:40 espie Exp $
d142 3
a144 2
	$state->{logger} = DPB::Logger->new($state->logdir, $state->opt('c'));
	$state->{locker} = DPB::Locks->new($state, $state->{lockdir});
@


1.8
log
@prepare for perl 5.18
- don't bother declaring $_ for while(<>) loops. assume current default
will still work.
- rename variable for readability elsewhere.
@
text
@d2 1
a2 1
# $OpenBSD: State.pm,v 1.7 2013/11/16 16:39:28 espie Exp $
d205 1
a205 1
	my @@l = ($self->{make});
@


1.7
log
@make the data in permanent logs a bit more self-describing, so that we may add
new fields in the future without atrocious hacks for bw compatibility.
(grows the files a bit, but quite acceptable).
@
text
@d2 1
a2 1
# $OpenBSD: State.pm,v 1.6 2013/11/16 13:06:00 espie Exp $
a125 1
			my $_;
a258 1
	my $_;
@


1.6
log
@add/read timestamps to rolling logs, so that eventually old stuff gets
removed.

alias -DSTARTUP/-DCLEANUP, since I keep mixing up the two.
@
text
@d2 1
a2 1
# $OpenBSD: State.pm,v 1.5 2013/10/17 12:48:10 espie Exp $
d35 1
d262 4
a265 9
		chomp;
		next if $_ =~ m/!$/;
		my ($pkgpath, $host, $time, $sz, @@rest) = parse_build_line($_);
		next if !defined $sz;
		my $o = DPB::PkgPath->new($pkgpath);
		my $s = {host => $host, time => $time, sz => $sz};
		if (@@rest > 0 && $rest[0] =~ m/^\d+$/) {
			$s->{ts} = $rest[0];
		}
d278 1
a278 1
			$sz += $s->{sz};
d298 1
a298 6
			my @@l = ($p->fullpkgpath, $s->{host}, $s->{time},
			    $s->{sz});
			if ($s->{ts}) {
				push(@@l, $s->{ts});
			}
			print $f join(' ', @@l), "\n";
@


1.5
log
@a bit more flesh for chroot, run getvars in chroot, possibly (as root, but
we don't really care), and apply some schizophreny to stuff that runs outside
the chroot.

(probably not complete yet, ssh master trouble)
@
text
@d2 1
a2 1
# $OpenBSD: State.pm,v 1.4 2013/10/17 08:31:45 espie Exp $
d266 5
a270 1
		push(@@{$o->{stats}}, {host => $host, time => $time, sz => $sz});
d302 6
a307 2
			print $f join(' ', $p->fullpkgpath, $s->{host},
			    $s->{time}, $s->{sz}), "\n";
@


1.4
log
@and move this too
@
text
@d2 1
a2 1
# $OpenBSD: State.pm,v 1.3 2013/10/13 18:31:51 espie Exp $
d63 10
d77 1
a77 1
	$path =~ s/\%p/$self->{ports}/g;
d82 1
a82 1
	$path =~ s/\%f/$self->{distdir}/g;
d224 1
a224 1
	return shift->{distdir};
@


1.3
log
@- use separated Heuristics::Size object
- choose size/nosize in Config.
- use affinity or affinitystub
- move locker creation to State, so we can init cores right away.
- as core init has run, we can call DPB::Core->reap (event loop) while
processing size and build stats, so that the startup script may start
slightly earlier.
- setup more options in Config for Reporter to use.
- scaffolding in SubEngine/Build to be able to use affinity info right away
@
text
@d2 1
a2 1
# $OpenBSD: State.pm,v 1.2 2013/10/06 13:33:34 espie Exp $
a48 7
	($self->{ports}, $self->{portspath}, $self->{repo}, $self->{localarch},
	    $self->{distdir}, $self->{localbase}) =
		DPB::Vars->get(DPB::Shell::Local->new, $self->make,
		"PORTSDIR", "PORTSDIR_PATH", "PACKAGE_REPOSITORY", 
		"MACHINE_ARCH", "DISTDIR", "LOCALBASE");
	$self->{arch} = $self->{localarch};
	$self->{portspath} = [ split(/:/, $self->{portspath}) ];
d306 1
@


1.2
log
@update my copyright to 2013
@
text
@d2 1
a2 1
# $OpenBSD: State.pm,v 1.1 2013/10/02 09:00:34 espie Exp $
a28 1
use DPB::Affinity;
d33 2
a138 2
	$state->parse_size_file;

d140 4
a144 2
	$state->heuristics->set_logger($state->logger);
	
d146 1
d165 4
a317 43
}

sub parse_size_file
{
	my $state = shift;
	return if $state->{fetch_only};
	open my $fh, '<', $state->opt('S') // $state->{size_log}  or return;

	print "Reading size stats...";
	File::Path::mkpath(File::Basename::dirname($state->{size_log}));

	my $rewrite = {};
	my $_;
	while (<$fh>) {
		chomp;
		my $pkgname;
		my ($pkgpath, $sz, $sz2) = split(/\s+/, $_);
		my $i = " $sz";
		if ($pkgpath =~ m/^(.*)\((.*)\)$/) {
			($pkgpath, $pkgname) = ($1, $2);
			if ($state->opt('S')) {
				undef $pkgname;
			} else {
				$i ="($pkgname) $sz";
			}
		}
		if (defined $sz2) {
			$sz += $sz2;
			$i .=" $sz2";
		}
		$rewrite->{$pkgpath} = $i;
		my $o = DPB::PkgPath->new($pkgpath);
		DPB::Heuristics->add_size_info($o, $pkgname, $sz);
	}
	close $fh;
	print "zapping old stuff...";
	open $fh, '>', $state->{size_log}.'.part' or return;
	for my $p (sort keys %$rewrite) {
		print $fh "$p$rewrite->{$p}\n";
	}
	close $fh;
	print "Done\n";
	rename $state->{size_log}.'.part', $state->{size_log};
@


1.1
log
@clean-up code a bit, move state into its own file
@
text
@d2 1
a2 1
# $OpenBSD$
d4 1
a4 1
# Copyright (c) 2010 Marc Espie <espie@@openbsd.org>
@

