head	1.37;
access;
symbols
	OPENBSD_6_0:1.37.0.2
	OPENBSD_6_0_BASE:1.37
	OPENBSD_5_9:1.31.0.2
	OPENBSD_5_9_BASE:1.31
	OPENBSD_5_8:1.30.0.4
	OPENBSD_5_8_BASE:1.30
	OPENBSD_5_7:1.29.0.6
	OPENBSD_5_7_BASE:1.29
	OPENBSD_5_6:1.29.0.4
	OPENBSD_5_6_BASE:1.29
	OPENBSD_5_5:1.29.0.2
	OPENBSD_5_5_BASE:1.29
	OPENBSD_5_4:1.27.0.2
	OPENBSD_5_4_BASE:1.27
	OPENBSD_5_3:1.26.0.2
	OPENBSD_5_3_BASE:1.26
	OPENBSD_5_2:1.24.0.4
	OPENBSD_5_2_BASE:1.24
	OPENBSD_5_1_BASE:1.24
	OPENBSD_5_1:1.24.0.2
	OPENBSD_5_0:1.13.0.2
	OPENBSD_5_0_BASE:1.13
	OPENBSD_4_9:1.10.0.2
	OPENBSD_4_9_BASE:1.10
	ports:1.1.1.1
	espie:1.1.1;
locks; strict;
comment	@# @;


1.37
date	2016.05.22.11.41.56;	author nigel;	state Exp;
branches;
next	1.36;
commitid	LgcxGBIemvL9UUor;

1.36
date	2016.05.21.19.38.44;	author espie;	state Exp;
branches;
next	1.35;
commitid	5ieDjEUYZ9BB83ld;

1.35
date	2016.05.17.14.50.36;	author espie;	state Exp;
branches;
next	1.34;
commitid	sNkGwrxrgGunoaEN;

1.34
date	2016.05.16.10.37.44;	author espie;	state Exp;
branches;
next	1.33;
commitid	UBFEfnMdl4Z4RscH;

1.33
date	2016.05.16.10.28.14;	author espie;	state Exp;
branches;
next	1.32;
commitid	Tn5xZiy5z9OLEA20;

1.32
date	2016.05.15.22.24.56;	author espie;	state Exp;
branches;
next	1.31;
commitid	46E90Phu6WZId5HI;

1.31
date	2015.08.16.08.36.53;	author espie;	state Exp;
branches;
next	1.30;
commitid	QyKGZT0rCzU3IeWy;

1.30
date	2015.05.10.08.14.14;	author espie;	state Exp;
branches;
next	1.29;
commitid	J9XuZmxJc7sLMZLF;

1.29
date	2013.10.06.13.33.30;	author espie;	state Exp;
branches;
next	1.28;

1.28
date	2013.09.21.08.44.32;	author espie;	state Exp;
branches;
next	1.27;

1.27
date	2013.05.21.20.44.08;	author espie;	state Exp;
branches;
next	1.26;

1.26
date	2013.01.07.10.59.41;	author espie;	state Exp;
branches;
next	1.25;

1.25
date	2013.01.04.19.34.10;	author espie;	state Exp;
branches;
next	1.24;

1.24
date	2012.01.30.15.11.04;	author espie;	state Exp;
branches;
next	1.23;

1.23
date	2012.01.18.15.26.49;	author espie;	state Exp;
branches;
next	1.22;

1.22
date	2012.01.14.12.26.21;	author espie;	state Exp;
branches;
next	1.21;

1.21
date	2012.01.09.17.56.28;	author espie;	state Exp;
branches;
next	1.20;

1.20
date	2012.01.08.20.28.37;	author espie;	state Exp;
branches;
next	1.19;

1.19
date	2011.12.31.11.20.00;	author espie;	state Exp;
branches;
next	1.18;

1.18
date	2011.12.04.12.05.41;	author espie;	state Exp;
branches;
next	1.17;

1.17
date	2011.11.07.13.21.46;	author espie;	state Exp;
branches;
next	1.16;

1.16
date	2011.11.06.12.23.28;	author espie;	state Exp;
branches;
next	1.15;

1.15
date	2011.10.10.18.56.50;	author espie;	state Exp;
branches;
next	1.14;

1.14
date	2011.09.25.10.40.25;	author espie;	state Exp;
branches;
next	1.13;

1.13
date	2011.06.04.12.58.24;	author espie;	state Exp;
branches;
next	1.12;

1.12
date	2011.05.22.08.21.39;	author espie;	state Exp;
branches;
next	1.11;

1.11
date	2011.04.25.11.58.46;	author espie;	state Exp;
branches;
next	1.10;

1.10
date	2010.12.05.10.06.12;	author espie;	state Exp;
branches;
next	1.9;

1.9
date	2010.11.02.20.32.59;	author espie;	state Exp;
branches;
next	1.8;

1.8
date	2010.10.30.11.36.07;	author espie;	state Exp;
branches;
next	1.7;

1.7
date	2010.10.30.11.19.38;	author espie;	state Exp;
branches;
next	1.6;

1.6
date	2010.10.30.10.35.09;	author espie;	state Exp;
branches;
next	1.5;

1.5
date	2010.10.28.14.54.38;	author espie;	state Exp;
branches;
next	1.4;

1.4
date	2010.10.28.10.33.20;	author espie;	state Exp;
branches;
next	1.3;

1.3
date	2010.10.27.12.58.26;	author espie;	state Exp;
branches;
next	1.2;

1.2
date	2010.10.23.18.02.59;	author espie;	state Exp;
branches;
next	1.1;

1.1
date	2010.08.20.13.40.13;	author espie;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2010.08.20.13.40.13;	author espie;	state Exp;
branches;
next	;


desc
@@


1.37
log
@DPB::FetchDummy needs forget_cache routine.
Ok espie@@
@
text
@# ex:ts=8 sw=4:
# $OpenBSD: Grabber.pm,v 1.36 2016/05/21 19:38:44 espie Exp $
#
# Copyright (c) 2010-2013 Marc Espie <espie@@openbsd.org>
#
# Permission to use, copy, modify, and distribute this software for any
# purpose with or without fee is hereby granted, provided that the above
# copyright notice and this permission notice appear in all copies.
#
# THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
# ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
# OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
use strict;
use warnings;


use DPB::Vars;
use DPB::Util;

package DPB::Grabber;
sub new
{
	my ($class, $state, $endcode) = @@_;

	my $o = bless { 
		loglist => DPB::Util->make_hot($state->logger->append("vars")),
		engine => $state->engine,
		builder => $state->builder,
		state => $state,
		keep_going => 1,
		errors => 0,
		endcode => $endcode
	    }, $class;
	my @@values = ();
	if ($state->{want_fetchinfo}) {
		require DPB::Fetch;
		push(@@values, 'fetch');
		$o->{fetch} = DPB::Fetch->new($state->distdir, $state->logger,
		    $state);
	} else {
		$o->{fetch} = DPB::FetchDummy->new;
	}
	if ($state->{test}) {
		push(@@values, 'test');
	}
	$o->{dpb} = join(' ',  @@values);
	return $o;
}

sub expire_old_distfiles
{
	my ($self, $core, $opt_e) = @@_;
	# don't bother if dump-vars wasn't perfectly clean
	return 0 if $self->{errors};
	return $self->{fetch}->run_expire_old($core, $opt_e);
}

sub finish
{
	my ($self, $h) = @@_;
	for my $v (values %$h) {
		if ($v->{broken}) {
			$self->{engine}->add_fatal($v, $v->{broken});
			delete $v->{broken};
		} else {
			if ($v->{wantbuild}) {
				delete $v->{wantbuild};
				$self->{engine}->new_path($v);
			}
			if ($v->{dontjunk}) {
				$self->{builder}->dontjunk($v);
			}
		}
	}
	$self->{engine}->flush;
	$self->{keepgoing} = &{$self->{endcode}};
}

sub ports
{
	my $self = shift;
	return $self->{state}->ports;
}

sub make
{
	my $self = shift;
	return $self->{state}->make;
}

sub make_args
{
	my $self = shift;
	return $self->{state}->make_args;
}

sub logger
{
	my $self = shift;
	return $self->{state}->logger;
}

sub forget_cache
{
	my $self = shift;
	$self->{fetch}->forget_cache;
}

sub grab_subdirs
{
	my ($self, $core, $list, $skip, $ignore_errors) = @@_;
	$core->unsquiggle;
	DPB::Vars->grab_list($core, $self, $list, $skip, $ignore_errors,
	    $self->{loglist}, $self->{dpb},
	    sub {
	    	my $h = shift;
		for my $v (values %$h) {
			$v->{wantbuild} = 1;
		}
		$self->finish($h);
	});
}

sub grab_signature
{
	my ($self, $core, $pkgpath) = @@_;
	return DPB::PortSignature->grab_signature($core, $self, $pkgpath);
}

sub clean_packages
{
	my ($self, $core, $pkgpath) = @@_;
	return DPB::CleanPackages->clean($core, $self, $pkgpath);
}

sub complete_subdirs
{
	my ($self, $core, $skip) = @@_;
	# more passes if necessary
	while ($self->{keep_going}) {
		my $subdirlist = {};
		for my $v (DPB::PkgPath->seen) {
			if (defined $v->{info}) {
				delete $v->{tried};
				delete $v->{wantinfo};
				if (defined $v->{wantbuild}) {
					delete $v->{wantbuild};
					$self->{engine}->new_path($v);
				}
				if (defined $v->{dontjunk}) {
					$self->{builder}->dontjunk($v);
				}
				next;
			}
			next if defined $v->{category};
			if (defined $v->{tried}) {
				$self->{engine}->add_fatal($v, "tried and didn't get it") 
				    if !defined $v->{errored};
				$v->{errored} = 1;
				$self->{errors}++;
			} elsif ($v->{wantinfo} || $v->{wantbuild}) {
				$v->add_to_subdirlist($subdirlist);
				$v->{tried} = 1;
			}
		}
		$self->{engine}->flush;
		last if (keys %$subdirlist) == 0;

		DPB::Vars->grab_list($core, $self, $subdirlist, $skip, 0,
		    $self->{loglist}, $self->{dpb},
		    sub {
			$self->finish(shift);
		    });
	}
}

package DPB::FetchDummy;
sub new
{
	my $class = shift;
	bless {}, $class;
}

sub build_distinfo
{
}

sub run_expire_old
{
	return 0;
}

sub forget_cache
{
       my $self = shift;
       $self->{cache} = {};
}

1;
@


1.36
log
@grrrr cvs. thanks krw
@
text
@d2 1
a2 1
# $OpenBSD: Grabber.pm,v 1.35 2016/05/17 14:50:36 espie Exp $
d195 6
@


1.35
log
@tweaks to heuristics
1/ do subdirs on the command line first
2/ ignore errors from "preferred" dependencies (and don't register anything)
if there are actual errors beyond paths that no longer exist, we'll get them
during the next pass.
@
text
@d2 1
a2 1
# $OpenBSD: Grabber.pm,v 1.34 2016/05/16 10:37:44 espie Exp $
d105 6
@


1.34
log
@use skipped dirs for initial build
@
text
@d2 1
a2 1
# $OpenBSD: Grabber.pm,v 1.33 2016/05/16 10:28:14 espie Exp $
d109 1
a109 1
	my ($self, $core, $list, $skip) = @@_;
d111 1
a111 1
	DPB::Vars->grab_list($core, $self, $list, $skip,
d167 1
a167 1
		DPB::Vars->grab_list($core, $self, $subdirlist, $skip,
@


1.33
log
@add SKIPDIRS semantics: automatically add visited dirs to a passed skip
if it's not empty
@
text
@d2 1
a2 1
# $OpenBSD: Grabber.pm,v 1.32 2016/05/15 22:24:56 espie Exp $
d136 1
a136 1
	my ($self, $core) = @@_;
d167 1
a167 1
		DPB::Vars->grab_list($core, $self, $subdirlist, undef,
@


1.32
log
@support SKIPDIR internally
@
text
@d2 1
a2 1
# $OpenBSD: Grabber.pm,v 1.31 2015/08/16 08:36:53 espie Exp $
d109 1
a109 1
	my ($self, $core, $list) = @@_;
d111 1
a111 1
	DPB::Vars->grab_list($core, $self, $list, undef,
@


1.31
log
@stub_out broken entries instead of deleting their info.
May help out with some warnings sebastia@@ is seeing.
@
text
@d2 1
a2 1
# $OpenBSD: Grabber.pm,v 1.30 2015/05/10 08:14:14 espie Exp $
d111 1
a111 1
	DPB::Vars->grab_list($core, $self, $list,
d167 1
a167 1
		DPB::Vars->grab_list($core, $self, $subdirlist,
@


1.30
log
@rename logger interface to desambiguate vs user.
@
text
@d2 1
a2 1
# $OpenBSD: Grabber.pm,v 1.29 2013/10/06 13:33:30 espie Exp $
a66 1
			delete $v->{info};
@


1.29
log
@update my copyright to 2013
@
text
@d2 1
a2 1
# $OpenBSD: Grabber.pm,v 1.28 2013/09/21 08:44:32 espie Exp $
d30 1
a30 1
		loglist => DPB::Util->make_hot($state->logger->open("vars")),
@


1.28
log
@introduce squiggles: special cores used for building small ports.
each host takes care of keeping its squiggles "alive". This may
include moving the squiggle property when the core gets swallowed,
and making sure listing/fetch/update distinfo cores are not squiggles.
@
text
@d2 1
a2 1
# $OpenBSD: Grabber.pm,v 1.27 2013/05/21 20:44:08 espie Exp $
d4 1
a4 1
# Copyright (c) 2010 Marc Espie <espie@@openbsd.org>
@


1.27
log
@tweak 'dump-vars' run to include TEST values if run with -t.
THIS REQUIRES MOST RECENT bsd.port.mk, OTHERWISE THIS WILL BREAK BADLY.

The values are not used yet, but I fully intend to make it possible to
run non-regression tests in the not too distant future.
@
text
@d2 1
a2 1
# $OpenBSD: Grabber.pm,v 1.26 2013/01/07 10:59:41 espie Exp $
d111 1
@


1.26
log
@pass -X paths thru:
- the grabber passes them to PortBuilder
... which builds a hash of pkgnames
... and the port uninstall job excludes these from the list of ports to
junk.

Note this only works with -current pkg_delete, as I had to tell it to
ignore non-existent pkgnames in that context
@
text
@d2 1
a2 1
# $OpenBSD: Grabber.pm,v 1.25 2013/01/04 19:34:10 espie Exp $
d38 1
d41 1
a41 1
		$o->{dpb} = "fetch";
a44 1
		$o->{dpb} = "normal";
d47 4
@


1.25
log
@switch to IO::File and explicit flush for the engine log.
should be slightly faster
@
text
@d2 1
a2 1
# $OpenBSD: Grabber.pm,v 1.24 2012/01/30 15:11:04 espie Exp $
d32 1
d66 8
a73 3
		} elsif ($v->{wantbuild}) {
			delete $v->{wantbuild};
			$self->{engine}->new_path($v);
d143 3
@


1.24
log
@finish distfiles history handling: people who don't fetch/build the whole
tree may want to weed distfiles too, so allow for a full scan of the tree
without building/fetching anything, just to update history:

dpb -DHISTORY_ONLY

(just requires making sure the right engines are created, and a very shortened
loop at end waiting for history to be updated).
@
text
@d2 1
a2 1
# $OpenBSD: Grabber.pm,v 1.23 2012/01/18 15:26:49 espie Exp $
d70 1
d151 1
@


1.23
log
@repair dpb -f0
noticed by phessler@@
@
text
@d2 1
a2 1
# $OpenBSD: Grabber.pm,v 1.22 2012/01/14 12:26:21 espie Exp $
d37 1
a37 1
	if ($state->opt('f')) {
@


1.22
log
@add support to obey PERMIT_DISTFILES*
@
text
@d2 1
a2 1
# $OpenBSD: Grabber.pm,v 1.21 2012/01/09 17:56:28 espie Exp $
d54 1
a54 2
	$self->{fetch}->run_expire_old($core, $opt_e);
	return 1;
d169 5
@


1.21
log
@run "expire_old" as a separate job, since it may take some time.
find files under $DISTDIR, anything we don't know about should also
end up in history.
@
text
@d2 1
a2 1
# $OpenBSD: Grabber.pm,v 1.20 2012/01/08 20:28:37 espie Exp $
d41 1
a41 1
		    $state->{fetch_only});
@


1.20
log
@give dpb more knowledge about distfiles.
- keep a stash indexed by checksum, so dpb can identify duplicate files.
- in a full bulk, if the scan has no errors, write to a ${DISTDIR}/history
file  the files encountered in ${DISTDIR}/distinfo that seem to no longer
be needed (with full timestamp and checksum info).

Should be enough info to know when to expire old DISTDIR entries.
@
text
@d2 1
a2 1
# $OpenBSD: Grabber.pm,v 1.19 2011/12/31 11:20:00 espie Exp $
d51 1
a51 1
	my $self = shift;
d53 3
a55 2
	return if $self->{errors};
	$self->{fetch}->expire_old;
@


1.19
log
@allow the fetcher part to work as a "true" mirror maker:
- keep a cache of checked checksums as ${DISTDIR}/distinfo
- read existing cache on startup, don't need to recheck those files.
- split checksum_task: update the cache after the checksum is done
- create the by_cipher/sha256/... entries
- in fetch_only mode, do a "long" checksum on existing files not in the cache.

If you ever have doubts on the integrity of already checked files, just
rm ${DISTDIR}/distinfo.
@
text
@d2 1
a2 1
# $OpenBSD: Grabber.pm,v 1.18 2011/12/04 12:05:41 espie Exp $
d34 1
d49 8
d144 1
@


1.18
log
@clean-up job running a bit: add methods to Grabber and PortBuilder objects
to access more stuff they need.

Remove distantshell->make, ask state instead.
Provide state with the program we run, and the parameters we pass it.

- same make for distant and local hosts
- pass BUILD_ONCE=Yes if -a.
@
text
@d2 1
a2 1
# $OpenBSD: Grabber.pm,v 1.17 2011/11/07 13:21:46 espie Exp $
d39 2
a40 1
		$o->{fetch} = DPB::Fetch->new($state->distdir);
@


1.17
log
@remove a bit more data
@
text
@d2 1
a2 1
# $OpenBSD: Grabber.pm,v 1.16 2011/11/06 12:23:28 espie Exp $
d29 1
a29 1
	my $o = bless { ports => $state->ports, make => $state->make,
a30 1
		logger => $state->logger,
d66 1
a66 1
	return $self->{ports};
d72 7
a78 1
	return $self->{make};
d84 1
a84 1
	return $self->{logger};
@


1.16
log
@slightly better error handling and reporting:
- log to pkgpath whenever we can
- log FETCH_MANUALLY issues as errors, so we can fix them
@
text
@d2 1
a2 1
# $OpenBSD: Grabber.pm,v 1.15 2011/10/10 18:56:50 espie Exp $
d116 2
@


1.15
log
@unfuck pkgpaths.
- instead of seen/unseen, have an actual constructor. Instead, mark pkgpath
for which we wantinfo/wantbuild.
- only mark EXTRA dependencies as wantinfo. So the devel/haddock,no_deps
temporary error should be gone.
- since we have FLAVOR and SUBPACKAGE available, construct as much info as
we can during vars scanning (see handle_equivalences). This avoids about 150
path rescans during a full bulk. Also, grab the timing and logsizes from
equivalent files, so that most stuff should know show % all the time.
- tweak subdirlist to be a hash, and correctly add pkgpath_and_flavors to it.
That way, we rescan avahi pseudo flavors just once, and not four or five times.
@
text
@d2 1
a2 1
# $OpenBSD: Grabber.pm,v 1.14 2011/09/25 10:40:25 espie Exp $
d54 1
a55 1
			$self->{engine}->add_fatal($v);
d124 1
a124 1
				$self->{engine}->add_fatal($v) 
@


1.14
log
@erroring once is enough... there should be some logfile for this too ;(
@
text
@d2 1
a2 1
# $OpenBSD: Grabber.pm,v 1.13 2011/06/04 12:58:24 espie Exp $
d56 2
a57 1
		} else {
d88 5
a92 1
		$self->finish(shift);
d113 1
a113 1
		my @@subdirlist = ();
d115 7
a121 1
			next if defined $v->{info};
d127 2
a128 2
			} else {
				$v->add_to_subdirlist(\@@subdirlist);
d132 1
a132 1
		last if @@subdirlist == 0;
d134 5
a138 1
		$self->grab_subdirs($core, \@@subdirlist);
@


1.13
log
@spaces
@
text
@d2 1
a2 1
# $OpenBSD$
d113 3
a115 1
				$self->{engine}->add_fatal($v);
@


1.12
log
@initial support for fetching distfiles, somewhat experimental yet.
- clean up clock handling, jobs with timer.
- pass more parameters thru state
- tweak the engine to handle distfiles
- lots of new code in Fetch for new jobs.
@
text
@d2 1
a2 1
# $OpenBSD: Grabber.pm,v 1.11 2011/04/25 11:58:46 espie Exp $
@


1.11
log
@finish refactoring options.
Deprecate: -t and -T
use -DCONNECTION_TIMEOUT=... -DDISPLAY_TIMEOUT=... instead
New feature: -DSTUCK_TIMEOUT=
kill tasks when they don't show any progress for that long.
@
text
@d2 1
a2 1
# $OpenBSD: Grabber.pm,v 1.10 2010/12/05 10:06:12 espie Exp $
d27 1
a27 1
	my ($class, $state, $engine, $endcode) = @@_;
d32 2
a33 2
		engine => $engine,
		dpb => $state->opt('f') ? "fetch" : "normal",
d37 8
a44 1
	$engine->set_grabber($o);
d123 11
@


1.10
log
@allow 'dpb archivers' without extra artifacts, e.g., recognize and
handle categories without classifying them as pkgpaths with errors.
@
text
@d2 1
a2 1
# $OpenBSD: Grabber.pm,v 1.9 2010/11/02 20:32:59 espie Exp $
d27 5
a31 4
	my ($class, $ports, $make, $logger, $engine, $dpb, $endcode) = @@_;
	my $o = bless { ports => $ports, make => $make,
		loglist => DPB::Util->make_hot($logger->open("vars")),
		logger => $logger,
d33 1
a33 1
		dpb => $dpb,
@


1.9
log
@in case the signature doesn't match, clean ALL packages that will be
rebuilt. Otherwise, you may suffer through 3 or 4 rebuilds of qt3...

ouchie.
@
text
@d2 1
a2 1
# $OpenBSD: Grabber.pm,v 1.8 2010/10/30 11:36:07 espie Exp $
d103 1
@


1.8
log
@don't cheat, we have to make clean=package to avoid side-effects with
arch-independent packages.
@
text
@d2 1
a2 1
# $OpenBSD: Grabber.pm,v 1.7 2010/10/30 11:19:38 espie Exp $
d89 1
a89 1
sub clean_package
d92 1
a92 1
	return DPB::CleanPackage->clean($core, $self, $pkgpath);
@


1.7
log
@proof-of-concept implementation of -R (rebuild when signature changes).
Somewhat inefficient (deep check of package vs port signature).
More proper approach would be to tell the engine to always build, have first
step be a check for signature if the package exist, and abort if it matches:
- here we double check everything
- propagating rebuilds means non-uptodate packages give rise to non uptodate.
@
text
@d2 1
a2 1
# $OpenBSD: Grabber.pm,v 1.6 2010/10/30 10:35:09 espie Exp $
d87 6
@


1.6
log
@simplify parameter passing slightly
@
text
@d2 1
a2 1
# $OpenBSD: Grabber.pm,v 1.5 2010/10/28 14:54:38 espie Exp $
d36 1
a36 1
	$engine->{grabber} = $o;
d86 1
a86 1
	return DPB::Vars->grab_signature($core, $self, $pkgpath);
@


1.5
log
@keep the output from dump-vars around, and save it in the logfile is
something bad happens.

get rid of special reporter for Vars, E= is enough, people should look
in the paths/logfile now.
@
text
@d2 1
a2 1
# $OpenBSD: Grabber.pm,v 1.4 2010/10/28 10:33:20 espie Exp $
d55 18
d76 2
a77 2
	DPB::Vars->grab_list($core, $self->{ports}, $self->{make}, $list,
	    $self->{loglist}, $self->{logger}, $self->{dpb},
d83 5
@


1.4
log
@make it possible (simple) to rescan broken directories
(we should possibly log the error messages).
Forgot to reset broken, so rescanning didn't help...
@
text
@d2 1
a2 1
# $OpenBSD: Grabber.pm,v 1.3 2010/10/27 12:58:26 espie Exp $
d30 1
d59 1
a59 1
	    $self->{loglist}, $self->{dpb},
@


1.3
log
@tie engine with var grabber, get ready to re-do port meta on error.
@
text
@d2 1
a2 1
# $OpenBSD: Grabber.pm,v 1.2 2010/10/23 18:02:59 espie Exp $
d45 1
@


1.2
log
@fix loop: we know we tried it, it didn't work, so don't try it AGAIN.
@
text
@d2 1
a2 1
# $OpenBSD: Grabber.pm,v 1.1.1.1 2010/08/20 13:40:13 espie Exp $
d28 1
a28 1
	bless { ports => $ports, make => $make,
d35 2
@


1.1
log
@Initial revision
@
text
@d2 1
a2 1
# $OpenBSD: Grabber.pm,v 1.5 2010/07/14 14:34:34 espie Exp $
d72 3
a75 2
			$v->add_to_subdirlist(\@@subdirlist);
			$v->{tried} = 1;
@


1.1.1.1
log
@move stuff here from infra/build
@
text
@@
