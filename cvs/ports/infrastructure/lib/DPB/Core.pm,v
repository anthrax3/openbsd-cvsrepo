head	1.83;
access;
symbols
	OPENBSD_6_1:1.83.0.4
	OPENBSD_6_1_BASE:1.83
	OPENBSD_6_0:1.83.0.2
	OPENBSD_6_0_BASE:1.83
	OPENBSD_5_9:1.82.0.2
	OPENBSD_5_9_BASE:1.82
	OPENBSD_5_8:1.82.0.4
	OPENBSD_5_8_BASE:1.82
	OPENBSD_5_7:1.75.0.2
	OPENBSD_5_7_BASE:1.75
	OPENBSD_5_6:1.73.0.2
	OPENBSD_5_6_BASE:1.73
	OPENBSD_5_5:1.70.0.2
	OPENBSD_5_5_BASE:1.70
	OPENBSD_5_4:1.37.0.2
	OPENBSD_5_4_BASE:1.37
	OPENBSD_5_3:1.33.0.2
	OPENBSD_5_3_BASE:1.33
	OPENBSD_5_2:1.13.0.2
	OPENBSD_5_2_BASE:1.13
	OPENBSD_5_1_BASE:1.11
	OPENBSD_5_1:1.11.0.2
	OPENBSD_5_0:1.9.0.2
	OPENBSD_5_0_BASE:1.9
	OPENBSD_4_9:1.5.0.2
	OPENBSD_4_9_BASE:1.5
	ports:1.1.1.1
	espie:1.1.1;
locks; strict;
comment	@# @;


1.83
date	2016.05.08.09.31.38;	author espie;	state Exp;
branches;
next	1.82;
commitid	o94kkxR2uNE58DaX;

1.82
date	2015.05.12.19.47.02;	author espie;	state Exp;
branches;
next	1.81;
commitid	hKH1WSuMnkgg4TEr;

1.81
date	2015.05.07.12.30.46;	author espie;	state Exp;
branches;
next	1.80;
commitid	bTlfhLMWrwKobBb3;

1.80
date	2015.05.06.12.20.35;	author espie;	state Exp;
branches;
next	1.79;
commitid	rP8fdg6FTgA4VMVV;

1.79
date	2015.05.03.12.26.10;	author espie;	state Exp;
branches;
next	1.78;
commitid	zrS1WcsMipxQrtpc;

1.78
date	2015.05.02.13.12.39;	author espie;	state Exp;
branches;
next	1.77;
commitid	Rb4ZrbrDNb3MjI1X;

1.77
date	2015.05.02.12.55.43;	author espie;	state Exp;
branches;
next	1.76;
commitid	ZKkgptLKOetq1aKc;

1.76
date	2015.05.02.11.04.38;	author espie;	state Exp;
branches;
next	1.75;
commitid	FDOEL4BdKqgokIWO;

1.75
date	2014.12.25.15.14.14;	author espie;	state Exp;
branches;
next	1.74;
commitid	4T2EL5Ro5f9nUYOi;

1.74
date	2014.12.07.15.18.50;	author espie;	state Exp;
branches;
next	1.73;
commitid	GynqjLfrNHwgIuss;

1.73
date	2014.07.14.17.54.11;	author espie;	state Exp;
branches;
next	1.72;
commitid	URuOL8TJhZJXJwdx;

1.72
date	2014.03.15.09.51.27;	author espie;	state Exp;
branches;
next	1.71;

1.71
date	2014.03.09.20.08.32;	author espie;	state Exp;
branches;
next	1.70;

1.70
date	2013.11.14.09.35.01;	author espie;	state Exp;
branches;
next	1.69;

1.69
date	2013.10.27.09.26.01;	author espie;	state Exp;
branches;
next	1.68;

1.68
date	2013.10.17.18.09.41;	author espie;	state Exp;
branches;
next	1.67;

1.67
date	2013.10.17.14.20.44;	author espie;	state Exp;
branches;
next	1.66;

1.66
date	2013.10.17.12.48.10;	author espie;	state Exp;
branches;
next	1.65;

1.65
date	2013.10.07.20.36.27;	author espie;	state Exp;
branches;
next	1.64;

1.64
date	2013.10.07.20.23.39;	author espie;	state Exp;
branches;
next	1.63;

1.63
date	2013.10.07.19.49.56;	author espie;	state Exp;
branches;
next	1.62;

1.62
date	2013.10.07.18.02.07;	author espie;	state Exp;
branches;
next	1.61;

1.61
date	2013.10.07.06.40.21;	author espie;	state Exp;
branches;
next	1.60;

1.60
date	2013.10.06.14.01.52;	author espie;	state Exp;
branches;
next	1.59;

1.59
date	2013.10.06.13.33.28;	author espie;	state Exp;
branches;
next	1.58;

1.58
date	2013.10.06.12.36.12;	author espie;	state Exp;
branches;
next	1.57;

1.57
date	2013.10.04.07.18.38;	author espie;	state Exp;
branches;
next	1.56;

1.56
date	2013.10.03.17.34.44;	author espie;	state Exp;
branches;
next	1.55;

1.55
date	2013.10.02.09.14.29;	author espie;	state Exp;
branches;
next	1.54;

1.54
date	2013.09.24.10.07.27;	author espie;	state Exp;
branches;
next	1.53;

1.53
date	2013.09.23.14.50.54;	author espie;	state Exp;
branches;
next	1.52;

1.52
date	2013.09.23.14.21.47;	author espie;	state Exp;
branches;
next	1.51;

1.51
date	2013.09.23.13.00.02;	author espie;	state Exp;
branches;
next	1.50;

1.50
date	2013.09.22.06.29.38;	author espie;	state Exp;
branches;
next	1.49;

1.49
date	2013.09.21.11.31.19;	author espie;	state Exp;
branches;
next	1.48;

1.48
date	2013.09.21.09.20.17;	author espie;	state Exp;
branches;
next	1.47;

1.47
date	2013.09.21.08.44.32;	author espie;	state Exp;
branches;
next	1.46;

1.46
date	2013.09.21.08.41.55;	author espie;	state Exp;
branches;
next	1.45;

1.45
date	2013.09.21.08.40.09;	author espie;	state Exp;
branches;
next	1.44;

1.44
date	2013.09.18.15.30.40;	author espie;	state Exp;
branches;
next	1.43;

1.43
date	2013.09.16.11.23.50;	author espie;	state Exp;
branches;
next	1.42;

1.42
date	2013.09.14.09.42.11;	author espie;	state Exp;
branches;
next	1.41;

1.41
date	2013.09.11.10.44.14;	author espie;	state Exp;
branches;
next	1.40;

1.40
date	2013.09.08.11.10.58;	author espie;	state Exp;
branches;
next	1.39;

1.39
date	2013.09.03.09.44.06;	author espie;	state Exp;
branches;
next	1.38;

1.38
date	2013.08.28.11.55.06;	author espie;	state Exp;
branches;
next	1.37;

1.37
date	2013.06.21.09.05.18;	author espie;	state Exp;
branches;
next	1.36;

1.36
date	2013.04.22.20.56.53;	author espie;	state Exp;
branches;
next	1.35;

1.35
date	2013.03.03.11.11.08;	author espie;	state Exp;
branches;
next	1.34;

1.34
date	2013.03.03.00.49.14;	author espie;	state Exp;
branches;
next	1.33;

1.33
date	2013.01.29.11.16.58;	author espie;	state Exp;
branches;
next	1.32;

1.32
date	2013.01.28.12.23.45;	author espie;	state Exp;
branches;
next	1.31;

1.31
date	2013.01.28.10.14.17;	author espie;	state Exp;
branches;
next	1.30;

1.30
date	2013.01.27.17.54.45;	author espie;	state Exp;
branches;
next	1.29;

1.29
date	2013.01.21.10.46.42;	author espie;	state Exp;
branches;
next	1.28;

1.28
date	2013.01.10.10.26.34;	author espie;	state Exp;
branches;
next	1.27;

1.27
date	2013.01.06.11.59.40;	author espie;	state Exp;
branches;
next	1.26;

1.26
date	2013.01.05.21.48.50;	author espie;	state Exp;
branches;
next	1.25;

1.25
date	2013.01.05.21.48.18;	author espie;	state Exp;
branches;
next	1.24;

1.24
date	2013.01.04.18.49.39;	author espie;	state Exp;
branches;
next	1.23;

1.23
date	2012.12.31.09.50.55;	author espie;	state Exp;
branches;
next	1.22;

1.22
date	2012.12.29.19.14.51;	author espie;	state Exp;
branches;
next	1.21;

1.21
date	2012.12.24.17.24.46;	author espie;	state Exp;
branches;
next	1.20;

1.20
date	2012.11.06.08.26.29;	author espie;	state Exp;
branches;
next	1.19;

1.19
date	2012.10.13.09.06.55;	author espie;	state Exp;
branches;
next	1.18;

1.18
date	2012.10.11.07.40.30;	author espie;	state Exp;
branches;
next	1.17;

1.17
date	2012.10.08.14.16.36;	author espie;	state Exp;
branches;
next	1.16;

1.16
date	2012.10.08.12.41.03;	author espie;	state Exp;
branches;
next	1.15;

1.15
date	2012.09.24.20.41.57;	author espie;	state Exp;
branches;
next	1.14;

1.14
date	2012.09.23.18.13.32;	author espie;	state Exp;
branches;
next	1.13;

1.13
date	2012.07.08.09.59.31;	author jasper;	state Exp;
branches;
next	1.12;

1.12
date	2012.07.04.08.59.10;	author espie;	state Exp;
branches;
next	1.11;

1.11
date	2011.12.02.22.29.28;	author espie;	state Exp;
branches;
next	1.10;

1.10
date	2011.11.14.21.56.04;	author espie;	state Exp;
branches;
next	1.9;

1.9
date	2011.06.04.12.58.24;	author espie;	state Exp;
branches;
next	1.8;

1.8
date	2011.05.22.08.21.39;	author espie;	state Exp;
branches;
next	1.7;

1.7
date	2011.04.25.11.58.46;	author espie;	state Exp;
branches;
next	1.6;

1.6
date	2011.03.22.19.49.56;	author espie;	state Exp;
branches;
next	1.5;

1.5
date	2010.10.29.11.51.42;	author espie;	state Exp;
branches;
next	1.4;

1.4
date	2010.10.28.22.14.54;	author landry;	state Exp;
branches;
next	1.3;

1.3
date	2010.10.28.12.51.37;	author espie;	state Exp;
branches;
next	1.2;

1.2
date	2010.10.23.17.58.55;	author espie;	state Exp;
branches;
next	1.1;

1.1
date	2010.08.20.13.40.13;	author espie;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2010.08.20.13.40.13;	author espie;	state Exp;
branches;
next	;


desc
@@


1.83
log
@these days, I've got starved code at end of builds, while there's
still kde3/kde4 contention. So reuse the affinity tactic to find a
Core with the right tainting if it exists.
@
text
@# ex:ts=8 sw=4:
# $OpenBSD: Core.pm,v 1.82 2015/05/12 19:47:02 espie Exp $
#
# Copyright (c) 2010-2013 Marc Espie <espie@@openbsd.org>
#
# Permission to use, copy, modify, and distribute this software for any
# purpose with or without fee is hereby granted, provided that the above
# copyright notice and this permission notice appear in all copies.
#
# THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
# ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
# OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
use strict;
use warnings;
use DPB::Util;

# here, a "core" is an entity responsible for scheduling cpu, such as
# running a job, which is a collection of tasks.
#
# in DPB terms, to run something AND WAIT FOR IT in an asynchronous way,
# you must schedule it on a core, which gives you a process id that's
# registered
#
# the "abstract core" part only sees about registering/unregistering cores,
# and having a global event handler that gets run whenever possible.
package DPB::Core::Abstract;

use POSIX ":sys_wait_h";
use OpenBSD::Error;
use DPB::Util;
use DPB::Job;

# need to know which host are around for affinity purposes
my %allhosts;

sub matches_affinity
{
	my ($self, $v) = @@_;
	my $hostname = $v->{affinity};
	# same host
	if ($self->hostname eq $hostname) {
		return 1;
	}
	# ... or host isn't around
	return 1 if !defined $allhosts{$hostname};
	# okay, try to avoid this
	return 0;
}

# note that we play dangerously, e.g., we only keep cores that are running
# something in there, the code can keep some others.
my ($running, $special) = ({}, {});
sub repositories
{
	return ($running, $special);
}

my @@extra_stuff = ();

sub register_event
{
	my ($class, $code) = @@_;
	push(@@extra_stuff, $code);
}

sub handle_events
{
	for my $code (@@extra_stuff) {
		&$code;
	}
}

sub is_alive
{
	my $self = shift;
	return $self->host->is_alive;
}

sub shell
{
	my $self = shift;
	if ($self->{user}) {
		return $self->host->shell->run_as($self->{user});
	} else {
		return $self->host->shell;
	}
}

sub new
{
	my ($class, $host, $prop) = @@_;
	my $c = bless {host => DPB::Host->new($host, $prop)}, $class;
	$allhosts{$c->hostname} = 1;
	return $c;
}

sub clone
{
	my $self = shift;
	my $c = ref($self)->new($self->hostname, $self->prop);
	return $c;
}

sub host
{
	my $self = shift;
	return $self->{host};
}

sub prop
{
	my $self = shift;
	return $self->host->{prop};
}

sub sf
{
	my $self = shift;
	return $self->prop->{sf};
}

sub stuck_timeout
{
	my $self = shift;
	return $self->prop->{stuck_timeout};
}

sub fetch_timeout
{
	my $self = shift;
	return $self->prop->{fetch_timeout};
}

sub memory
{
	my $self = shift;
	return $self->prop->{memory};
}

sub parallel
{
	my $self = shift;
	return $self->prop->{parallel};
}

sub hostname
{
	my $self = shift;
	return $self->host->name;
}

sub lockname
{
	my $self = shift;
	return "host:".$self->hostname;
}

sub logname
{
	&hostname;
}

sub print_parent
{
	# Nothing to do
}

sub fullhostname
{
	my $self = shift;
	return $self->host->fullname;
}

sub register
{
	my ($self, $pid) = @@_;
	$self->{pid} = $pid;
	$self->repository->{$self->{pid}} = $self;
}

sub unregister
{
	my ($self, $status) = @@_;
	delete $self->repository->{$self->{pid}};
	delete $self->{pid};
	$self->{status} = $status;
	return $self;
}

sub terminate
{
	my $self = shift;
	if (defined $self->{pid}) {
		waitpid($self->{pid}, 0);
		$self->unregister($?);
		return $self;
    	} else {
		return undef;
	}
}

sub reap_kid
{
	my ($class, $kid) = @@_;
	if (defined $kid && $kid > 0) {
		for my $repo ($class->repositories) {
			if (defined $repo->{$kid}) {
				$repo->{$kid}->unregister($?)->continue;
				last;
			}
		}
	}
	return $kid;
}

sub reap
{
	my ($class, $all) = @@_;
	my $reaped = 0;
	$class->handle_events;
	$reaped++ while $class->reap_kid(waitpid(-1, WNOHANG)) > 0;
	return $reaped;
}

sub reap_wait
{
	my ($class, $reporter) = @@_;

	return $class->reap_kid(waitpid(-1, 0));
}

sub cleanup
{
	my $class = shift;
	local $> = 0;
	for my $repo ($class->repositories) {
		for my $pid (keys %$repo) {
			kill INT => $pid;
		}
	}
}

sub debug_dump
{
	my $self = shift;
	return $self->hostname;
}

OpenBSD::Handler->register( sub { __PACKAGE__->cleanup });

# this is a core that can run jobs
package DPB::Core::WithJobs;
our @@ISA = qw(DPB::Core::Abstract);

sub fh
{
	my $self = shift;
	return $self->task->{fh};
}

sub job
{
	my $self = shift;
	return $self->{job};
}

sub debug_dump
{
	my $self = shift;
	return join(':',$self->hostname, $self->job->debug_dump);
}

sub task
{
	my $self = shift;
	return $self->job->{task};
}

sub terminate
{
	my $self = shift;
	$self->task->end  if $self->task;
	if ($self->SUPER::terminate) {
		$self->job->finalize($self);
	}
}

sub run_task
{
	my $core = shift;
	my $pid = $core->task->fork($core);
	if (!defined $pid) {
		DPB::Util->die_bang("Oops: task ".$core->task->name." couldn't start");
	} elsif ($pid == 0) {
		$DB::inhibit_exit = 0;
		for my $sig (keys %SIG) {
			$SIG{$sig} = 'DEFAULT';
		}
		if (!$core->task->run($core)) {
			exit(1);
		}
		exit(0);
	} else {
		$core->task->process($core);
		$core->register($pid);
	}
}

sub continue
{
	my $core = shift;
	if ($core->task->finalize($core)) {
		return $core->start_task;
	} else {
		return $core->job->finalize($core);
	}
}

sub start_task
{
	my $core = shift;
	my $task = $core->job->next_task($core);
	$core->job->{task} = $task;
	if (defined $task) {
		return $core->run_task;
	} else {
		return $core->job->finalize($core);
	}
}

sub mark_ready
{
	my $self = shift;
	if ($self->{pid}) {
		require Data::Dumper;
		#print Data::Dumper::Dumper($self), "\n";
		DPB::Util->die("Marking ready an incomplete process");
	}
	delete $self->{job};
	return $self;
}

use Time::HiRes qw(time);
sub start_job
{
	my ($core, $job) = @@_;
	$core->{job} = $job;
	$core->{started} = time;
	$core->{status} = 0;
	$core->start_task;
}

sub success
{
	my $self = shift;
	$self->host->{consecutive_failures} = 0;
}

sub failure
{
	my $self = shift;
	$self->host->{consecutive_failures}++;
}

sub start_clock
{
	my ($class, $tm) = @@_;
	DPB::Core::Clock->start($tm);
}

package DPB::Core;
our @@ISA = qw(DPB::Core::WithJobs);

my $available = [];

# used to remove cores from the build
my %stopped = ();

my $logdir;
my $lastcount = 0;

sub log_concurrency
{
	my ($class, $time, $fh) = @@_;
	my $j = 0;
	while (my ($k, $c) = each %{$class->repository}) {
		$j++;
		if (defined $c->{swallow}) {
			$j += $c->{swallow};
		}
		if (defined $c->{swallowed}) {
			$j += scalar(@@{$c->{swallowed}});
		}
	}
	if ($j != $lastcount) {
		print $fh "$$ $time $j\n";
		$lastcount = $j;
	}
}

sub set_logdir
{
	my $class = shift;
	$logdir = shift;
}

sub is_local
{
	my $self = shift;
	return $self->host->is_localhost;
}

my @@extra_report = ();
my @@extra_important = ();
sub register_report
{
	my ($self, $code, $important) = @@_;
	push (@@extra_report, $code);
	push (@@extra_important, $important);
}

sub repository
{
	return $running;
}


sub walk_same_host_jobs
{
	my ($self, $sub) = @@_;
	while (my ($pid, $core) = each %{$self->repository}) {
		next if $core->hostname ne $self->hostname;
		# XXX only interested in "real" jobs now
		next if !defined $core->job->{v};
		&$sub($pid, $core->job);
	}
}

sub same_host_jobs
{
	my $self = shift;
	my @@jobs = ();
	$self->walk_same_host_jobs(sub {
		my ($pid, $job) = @@_;
		push(@@jobs, $job);
	    });
	return @@jobs;
}

sub wake_jobs
{
	my $self = shift;
	my ($alarm, $sleepin);
	for my $core (values %{$self->repository}) {
		next if !defined $core->job->{v};
		if ($core->job->{wakemeup}) {
			$alarm->{$core->hostname} = $core;
		}
		if ($core->job->{locked}) {
			$sleepin->{$core->hostname} = 1;
		}
	}
	while (my ($host, $core) = each %$alarm) {
		next if $sleepin->{$host};
		$core->job->wake_others($core);
	}
}

sub one_core
{
	my ($core, $time) = @@_;
	my $hostname = $core->hostname;

	my $s = $core->job->name;
    	if ($core->{squiggle}) {
		$s = '~'.$s;
	}
	if (defined $core->{swallowed}) {
		$s = (scalar(@@{$core->{swallowed}})+1).'*'.$s;
	}
	if ($core->{inmem}) {
		$s .= '+';
	}
	$s .= " [$core->{pid}]";
	if (!DPB::Host->name_is_localhost($hostname)) {
		$s .= " on ".$hostname;
	}
	if ($core->job) {
	    	$s .= $core->job->watched($time, $core);
	}
    	return $s;
}

sub report
{
	my $current = time();

	my $s = join("\n", map {one_core($_, $current)} sort {$a->{started} <=> $b->{started}} values %$running). "\n";
	for my $a (@@extra_report) {
		$s .= &$a;
	}
	return $s;
}

sub important
{
	my $current = time();
	my $s = '';
	for my $j (values %$running) {
		if ($j->job->really_watch($current)) {
			$s .= one_core($j, $current)."\n";
		}
	}

	for my $a (@@extra_important) {
		$s .= &$a;
	}
	return $s;
}

sub mark_ready
{
	my $self = shift;
	$self->SUPER::mark_ready;
	my $hostname = $self->hostname;
	if (-e "$logdir/stop-$hostname") {
		push(@@{$stopped{$hostname}}, $self);
	} else {
		$self->mark_available($self);
	}
	return $self;
}

sub avail
{
	my $self = shift;
	for my $h (keys %stopped) {
		if (!-e "$logdir/stop-$h") {
			for my $c (@@{$stopped{$h}}) {
				$self->mark_available($c);
			}
			delete $stopped{$h};
		}
	}
	return scalar(@@{$self->available});
}

sub available
{
	return $available;
}

sub can_swallow
{
	my ($core, $n) = @@_;
	$core->{swallow} = $n;
	$core->{swallowed} = [];
	$core->{realjobs} = $n+1;
	$core->host->{swallow}{$core} = $core;

	# try to reswallow freed things right away.
	if (@@$available > 0) {
		my @@l = @@$available;
		$available = [];
		$core->mark_available(@@l);
	}
}

sub unswallow
{
	my $self = shift;
	return unless defined $self->{swallowed};
	my $l = $self->{swallowed};

	# first prevent the recursive call from taking us into
	# account
	delete $self->{swallowed};
	delete $self->host->{swallow}{$self};
	delete $self->{swallow};
	delete $self->{realjobs};

	# then free up our swallowed jobs
	$self->mark_available(@@$l);
}

sub mark_available
{
	my $self = shift;
	LOOP: for my $core (@@_) {
		# okay, if this core swallowed stuff, then we release 
		# the swallowed stuff first
		$core->unswallow;

		# if this host has cores that swallow things, let us 
		# be swallowed
		if ($core->can_be_swallowed) {
			for my $c (values %{$core->host->{swallow}}) {
				$core->unsquiggle;
				push(@@{$c->{swallowed}}, $core);
				if (--$c->{swallow} == 0) {
					delete $core->host->{swallow}{$c};
				}
				next LOOP;
			}
		}
		push(@@{$self->available}, $core);
	}
}

sub running
{
	return scalar(%$running);
}

sub get
{
	my $self = shift;
	$a = $self->available;
	if (@@$a > 1) {
		if (DPB::HostProperties->has_sf) {
			@@$a = sort {$b->sf <=> $a->sf} @@$a;
		} else {
			my %cores;
			for my $c (@@$a) {
				$cores{$c->hostname}++;
			}
			@@$a = sort {$cores{$b->hostname} <=> $cores{$a->hostname}} @@$a;
		}
	}
	my $core = shift @@$a;
	if ($core->may_unsquiggle) {
		return $core;
	}
	if (!$core->{squiggle} && $core->host->{wantsquiggles}) {
		if ($core->host->{wantsquiggles} < 1) {
			if (rand() <= $core->host->{wantsquiggles}) {
				$core->{squiggle} = $core->host->{wantsquiggles};
				$core->host->{wantsquiggles} = 0;
			}
		} else {
			$core->host->{wantsquiggles}--;
			$core->{squiggle} = 1;
		}
	}
	return $core;
}

sub can_be_swallowed
{
	my $core = shift;
	return defined $core->host->{swallow};
}

sub may_unsquiggle
{
	my $core = shift;
	if ($core->{squiggle} && $core->{squiggle} < 1) {
		if (rand() >= $core->{squiggle}) {
			$core->unsquiggle;
			return 1;
		}
	}
	return 0;
}

sub unsquiggle
{
	my $core = shift;
	if ($core->{squiggle}) {
		$core->host->{wantsquiggles} += $core->{squiggle};
		delete $core->{squiggle};
	}
	return $core;
}

sub get_affinity
{
	my ($self, $v) = @@_;
	my $host = $v->{affinity};
	my $l = [];
	while (@@$available > 0) {
		my $core = shift @@$available;
		if ($core->hostname eq $host) {
			push(@@$available, @@$l);
			return $core;
		}
		push(@@$l, $core);
	}
	$available = $l;
	return undef
}

sub get_compatible
{
	my ($self, $v) = @@_;
	my $l = [];
	while (@@$available > 0) {
		my $core = shift @@$available;
		if (!$core->prop->taint_incompatible($v)) {
			push(@@$available, @@$l);
			return $core;
		}
		push(@@$l, $core);
	}
	$available = $l;
	return undef
}

my @@all_cores = ();

sub all_sf
{
	my $l = [];
	for my $j (@@all_cores) {
		next unless $j->is_alive;
		push(@@$l, $j->sf);
	}
	return [sort {$a <=> $b} @@$l];
}

sub new
{
	my ($class, $host, $prop) = @@_;
	my $o = $class->SUPER::new($host, $prop);
	push(@@all_cores, $o);
	return $o;
}

sub new_noreg
{
	my ($class, $host, $prop) = @@_;
	$class->SUPER::new($host, $prop);
}

sub start_pipe
{
	my ($self, $code, $name) = @@_;
	$self->start_job(DPB::Job::Pipe->new($code, $name));
}

package DPB::Core::Special;
our @@ISA = qw(DPB::Core::WithJobs);
sub repository
{
	return $special;
}

package DPB::Core::Local;
our @@ISA = qw(DPB::Core);

my $host;
sub hostname
{
	if (!defined $host) {
		chomp($host = `hostname`);
	}
	return $host;
}

package DPB::Core::Fetcher;
our @@ISA = qw(DPB::Core::Local);

my $fetchcores = [];

sub available
{
	return $fetchcores;
}

sub may_unsquiggle
{
	return 1;
}

sub can_be_swallowed
{
	return 0;
}

sub new
{
	my ($class, $host, $prop) = @@_;
	my $c = $class->SUPER::new($host, $prop);
	$c->{user} = $prop->{fetch_user};
	return $c;
}

package DPB::Core::Clock;
our @@ISA = qw(DPB::Core::Special);

sub start
{
	my ($class, $reporter) = @@_;
	my $core = $class->new('localhost');
	$core->start_job(DPB::Job::Infinite->new(DPB::Task::Fork->new(sub {
		sleep($reporter->timeout);
		exit(0);
		}), 'clock'));
}

1;
@


1.82
log
@scrape non-working round-robin code
@
text
@d2 1
a2 1
# $OpenBSD: Core.pm,v 1.81 2015/05/07 12:30:46 espie Exp $
d340 1
a340 1
		print Data::Dumper::Dumper($self), "\n";
d688 16
@


1.81
log
@make sure we're root when killing stuff. I'm mixing up right and left,
obviously.
@
text
@d2 1
a2 1
# $OpenBSD: Core.pm,v 1.80 2015/05/06 12:20:35 espie Exp $
d46 1
a46 11
		# if user required, only okay if same user
		if (defined $v->{user_affinity}) {
			if (defined $self->{user} && $self->{user}->user
			    eq $v->{user_affinity}) {
				return 1;
			} else {
				return 0;
			}
		} else {
			return 1;
		}
a104 3
	if ($self->prop->{round_robin}) {
		$c->{user} = $self->prop->{build_user}->next_user;
	}
d688 2
a689 10
			if (defined $v->{user_affinity}) {
				if (defined $core->{user} && 
				    $core->{user}->user eq $v->{user_affinity}) {
					push(@@$available, @@$l);
					return $core;
				}
			} else {
				push(@@$available, @@$l);
				return $core;
			}
@


1.80
log
@run kill as root, so trhat ssh masters are cleaned up properly
@
text
@d2 1
a2 1
# $OpenBSD: Core.pm,v 1.79 2015/05/03 12:26:10 espie Exp $
d252 1
a252 1
	$< = 0;
@


1.79
log
@tweak affinity checks to include user in schizophrenic mode
@
text
@d2 1
a2 1
# $OpenBSD: Core.pm,v 1.78 2015/05/02 13:12:39 espie Exp $
d252 1
@


1.78
log
@future round-robin mode, one user per-build.
@
text
@d2 1
a2 1
# $OpenBSD: Core.pm,v 1.77 2015/05/02 12:55:43 espie Exp $
d39 2
a40 1
sub matches
d42 2
a43 2
	my ($self, $hostname) = @@_;

d45 13
a57 1
	return 1 if $self->hostname eq $hostname;
a63 1

d694 2
a695 1
	my ($self, $host) = @@_;
d700 10
a709 2
			push(@@$available, @@$l);
			return $core;
@


1.77
log
@use the per-user Core thingy: make sure fetch cores are built with the
default prop, and set them to run as fetch_user, so that I can remove
the explicit run_as in the ftp command.
@
text
@d2 1
a2 1
# $OpenBSD: Core.pm,v 1.76 2015/05/02 11:04:38 espie Exp $
d102 5
a106 1
	return ref($self)->new($self->hostname, $self->prop);
@


1.76
log
@allow setting user thru the Core (for future round-robin builds)
@
text
@d2 1
a2 1
# $OpenBSD: Core.pm,v 1.75 2014/12/25 15:14:14 espie Exp $
d761 8
@


1.75
log
@regorg code, no actual change
@
text
@d2 1
a2 1
# $OpenBSD: Core.pm,v 1.74 2014/12/07 15:18:50 espie Exp $
d84 5
a88 1
	return $self->host->shell;
@


1.74
log
@wrap die so that it drops into the debugger if we run under perl -d.

change the way we do rescans again, to avoid race conditions:
just store away *all* pkgpaths related to the rescan (so that multi-packages
are covered) and then do the rescan. Hold those like we do for normal locks
but in a different list, and release them when the scan is over.

remove the atrocious shennanigans wrt fullpkgnames, it shouldn't be needed
again, hopefully.
@
text
@d2 1
a2 1
# $OpenBSD: Core.pm,v 1.73 2014/07/14 17:54:11 espie Exp $
a20 91
# we have unique objects for hosts, so we can put properties in there.
package DPB::Host;

my $hosts = {};

sub shell
{
	my $self = shift;
	return $self->{shell};
}

sub new
{
	my ($class, $name, $prop) = @@_;
	if ($class->name_is_localhost($name)) {
		$class = "DPB::Host::Localhost";
		$name = 'localhost';
	} else {
		require DPB::Core::Distant;
		$class = "DPB::Host::Distant";
	}
	if (!defined $hosts->{$name}) {
		my $h = bless {host => $name, 
			prop => DPB::HostProperties->finalize($prop) }, $class;
		# XXX have to register *before* creating the shell
		$hosts->{$name} = $h;
		$h->{shell} = $h->shellclass->new($h);
	}
	return $hosts->{$name};
}

sub name
{
	my $self = shift;
	return $self->{host};
}

sub fullname
{
	my $self = shift;
	my $name = $self->name;
	if (defined $self->{prop}->{jobs}) {
		$name .= "/$self->{prop}->{jobs}";
	}
	return $name;
}

sub name_is_localhost
{
	my ($class, $host) = @@_;
	if ($host eq "localhost" or $host eq DPB::Core::Local->hostname) {
		return 1;
	} else {
		return 0;
	}
}

package DPB::Host::Localhost;
our @@ISA = qw(DPB::Host);

sub is_localhost
{
	return 1;
}

sub is_alive
{
	return 1;
}


sub shellclass
{
	my $self = shift;
	if ($self->{prop}->{chroot}) {
		return "DPB::Shell::Local::Chroot";
	} else {
		return "DPB::Shell::Local";
	}
}

sub getshell
{
	my ($class, $state) = @@_;
	my $h = bless { prop => {}}, $class;
	if ($state->{chroot}) {
		$h->{prop}{chroot} = $state->{chroot};
	}
	return $h->shellclass->new($h);
}

a769 164
}

# the shell package is used to exec commands.
# note that we're dealing with exec, so we can modify the object/context
# itself with abandon
package DPB::Shell::Abstract;

sub new
{
	my ($class, $host) = @@_;
	$host //= {}; # this makes it possible to build "localhost" shells
	bless {sudo => 0, prop => $host->{prop}}, $class;
}

sub prop
{
	my $self = shift;
	return $self->{prop};
}

sub stringize_master_pid
{
	return "";
}

sub chdir
{
	my ($self, $dir) = @@_;
	$self->{dir} = $dir;
	return $self;
}

sub env
{
	my ($self, %h) = @@_;
	while (my ($k, $v) = each %h) {
		$self->{env}{$k} = $v;
	}
	return $self;
}

sub sudo
{
	my ($self, $val) = @@_;
	# XXX calling sudo without parms is equivalent to saying "1"
	if (@@_ == 1) {
		$val = 1;
	}
	$self->{sudo} = $val;
	return $self;
}

sub nochroot
{
	my $self = shift;
	$self->{nochroot} = 1;
	return $self;
}

package DPB::Shell::Local;
our @@ISA = qw(DPB::Shell::Abstract);

sub is_alive
{
	return 1;
}

sub chdir
{
	my ($self, $dir) = @@_;
	CORE::chdir($dir) or DPB::Util->die_bang("Can't chdir to $dir");
	return $self;
}

sub env
{
	my ($self, %h) = @@_;
	while (my ($k, $v) = each %h) {
		$ENV{$k} = $v;
	}
	return $self;
}

sub exec
{
	my ($self, @@argv) = @@_;
	if ($self->{sudo}) {
		unshift(@@argv, OpenBSD::Paths->sudo, "-E");
	}
	if (-t STDIN) {
		close(STDIN);
		open STDIN, '</dev/null';
	}
	exec {$argv[0]} @@argv;
}

package DPB::Shell::Chroot;
our @@ISA = qw(DPB::Shell::Abstract);
sub exec
{
	my ($self, @@argv) = @@_;
	my $chroot = $self->prop->{chroot};
	if ($self->{nochroot}) {
		undef $chroot;
	}
	unshift @@argv, 'exec' unless $self->{sudo} && !$chroot;
	if ($self->{env}) {
		while (my ($k, $v) = each %{$self->{env}}) {
			$v //= '';
			unshift @@argv, "$k=\'$v\'";
		}
	}
	if ($self->{sudo} && !$chroot) {
		unshift(@@argv, 'exec', OpenBSD::Paths->sudo, "-E");
	}
	my $cmd = join(' ', @@argv);
	if ($self->{dir}) {
		$cmd = "cd $self->{dir} && $cmd";
	}
	if (defined $self->prop->{umask}) {
		my $umask = $self->prop->{umask};
		$cmd = "umask $umask && $cmd";
	}
	if ($chroot) {
		my @@cmd2 = ("chroot");
		if (!$self->prop->{iamroot}) {
			unshift(@@cmd2, OpenBSD::Paths->sudo, "-E");
		}
		if (!$self->{sudo} && defined $self->prop->{chroot_user}) {
			push(@@cmd2, "-u", $self->prop->{chroot_user});
		}
		$self->_run(@@cmd2, $chroot, "/bin/sh", "-c", $self->quote($cmd));
	} else {
		$self->_run($cmd);
	}
}

package DPB::Shell::Local::Chroot;
our @@ISA = qw(DPB::Shell::Chroot);
sub _run
{
	my ($self, @@argv) = @@_;
	if (-t STDIN) {
		close(STDIN);
		open STDIN, '</dev/null';
	}
	exec {$argv[0]} @@argv;
}

sub quote
{
	my ($self, $cmd) = @@_;
	return $cmd;
}

sub is_alive
{
	return 1;
}

sub nochroot
{
	my $self = shift;
	bless $self, 'DPB::Shell::Local';
@


1.73
log
@prevent the local core from running interactive jobs too.
tricky: have to test for a terminal, as sometimes, we pipe stuff to them
@
text
@d2 1
a2 1
# $OpenBSD: Core.pm,v 1.72 2014/03/15 09:51:27 espie Exp $
d19 1
d380 1
a380 1
		die "Oops: task ".$core->task->name." couldn't start\n";
d424 1
a424 1
		die "Marking ready an incomplete process";
d931 1
a931 1
	CORE::chdir($dir) or die "Can't chdir to $dir\n";
@


1.72
log
@tweak waiting-for-lock mechanism: explicitly keep track of order,
and have each job relinquishing lock wake up the next one.

To cater for external dpbs, also try to wake up next job if we don't own the
lock.
@
text
@d2 1
a2 1
# $OpenBSD: Core.pm,v 1.71 2014/03/09 20:08:32 espie Exp $
d949 4
d1002 4
@


1.71
log
@- refactor the unswallow code for readability, and to be able to use it
at the end of fake
- sort available cores so that if all hosts fire at the same time, the
load will be fair (found out on yandex machines)
- new iamroot property: for chroot distant hosts, it's simpler to connect
as root, then you can directly chroot -u user  and not need the extra sudo
stage.
- more specific "walk_same_host_jobs" to use to signal jobs, for instance.
@
text
@d2 1
a2 1
# $OpenBSD: Core.pm,v 1.70 2013/11/14 09:35:01 espie Exp $
d534 19
@


1.70
log
@extra explaination of Core's role
@
text
@d2 1
a2 1
# $OpenBSD: Core.pm,v 1.69 2013/10/27 09:26:01 espie Exp $
d513 2
a514 1
sub same_host_jobs
d516 2
a517 3
	my $self = shift;
	my @@jobs = ();
	for my $core (values %{$self->repository}) {
d521 1
a521 1
		push(@@jobs, $core->job);
d523 10
d636 17
d659 1
a659 13
		if (defined $core->{swallowed}) {
			my $l = $core->{swallowed};

			# first prevent the recursive call from taking us into
			# account
			delete $core->{swallowed};
			delete $core->host->{swallow}{$core};
			delete $core->{swallow};
			delete $core->{realjobs};

			# then free up our swallowed jobs
			$self->mark_available(@@$l);
		}
d687 9
a695 1
		@@$a = sort {$b->sf <=> $a->sf} @@$a;
d961 4
a964 1
		my @@cmd2 = (OpenBSD::Paths->sudo, "-E", "chroot");
@


1.69
log
@rearrange a few things to get direct access to whoami.
@
text
@d2 1
a2 1
# $OpenBSD: Core.pm,v 1.68 2013/10/17 18:09:41 espie Exp $
d113 5
@


1.68
log
@for running !chroot'd stuff, create a modifier for the shell.
Note this modifier must come first for localhost !
@
text
@d2 1
a2 1
# $OpenBSD: Core.pm,v 1.67 2013/10/17 14:20:44 espie Exp $
d103 1
a103 1
	my ($class, $chroot) = @@_;
d105 2
a106 2
	if ($chroot) {
		$h->{prop}{chroot} = $chroot;
@


1.67
log
@forgot to un-anchor fullrepo.
also, fetch jobs are always local and *never* chroot'd, turns out.
@
text
@d2 1
a2 1
# $OpenBSD: Core.pm,v 1.66 2013/10/17 12:48:10 espie Exp $
a801 5
sub shell
{
	return DPB::Shell::Local->new;
}

d865 7
d911 3
d960 6
@


1.66
log
@a bit more flesh for chroot, run getvars in chroot, possibly (as root, but
we don't really care), and apply some schizophreny to stuff that runs outside
the chroot.

(probably not complete yet, ssh master trouble)
@
text
@d2 1
a2 1
# $OpenBSD: Core.pm,v 1.65 2013/10/07 20:36:27 espie Exp $
d800 5
@


1.65
log
@we no longer create specific local cores. Let install happen again by fixing
the test.
@
text
@d2 1
a2 1
# $OpenBSD: Core.pm,v 1.64 2013/10/07 20:23:39 espie Exp $
d101 10
d918 4
a921 2
	my $umask = $self->prop->{umask};
	$cmd = "umask $umask && $cmd";
d924 1
a924 1
		if (!$self->{sudo}) {
@


1.64
log
@remove some scaffolding. Still exit violently if the former issue happens
again...
@
text
@d2 1
a2 1
# $OpenBSD: Core.pm,v 1.63 2013/10/07 19:49:56 espie Exp $
d480 2
a481 1
	return 0;
a769 5
}

sub is_local
{
	return 1;
@


1.63
log
@fix typo
@
text
@d2 1
a2 1
# $OpenBSD: Core.pm,v 1.62 2013/10/07 18:02:07 espie Exp $
a503 1
		next if !defined $core->job;
d515 1
a515 6
	my $s;
	if ($core->job) {
		$s = $core->job->name;
	} else {
		$s = "?????";
	}
@


1.62
log
@debug scaffolding, abort early... I expect mark_ready gets called at the
wrong location or something :(
@
text
@d2 1
a2 1
# $OpenBSD: Core.pm,v 1.61 2013/10/07 06:40:21 espie Exp $
d407 1
a407 1
		print Date::Dumper::Dumper($self), "\n";
@


1.61
log
@also protect there...
@
text
@d2 1
a2 1
# $OpenBSD: Core.pm,v 1.60 2013/10/06 14:01:52 espie Exp $
d405 5
@


1.60
log
@name tricky construct
@
text
@d2 1
a2 1
# $OpenBSD: Core.pm,v 1.59 2013/10/06 13:33:28 espie Exp $
d499 1
@


1.59
log
@update my copyright to 2013
@
text
@d2 1
a2 1
# $OpenBSD: Core.pm,v 1.58 2013/10/06 12:36:12 espie Exp $
d168 6
@


1.58
log
@Nigel saw dpb burp out because of missing job name...
allow it to continue, no real idea what's wrong yet. :(
@
text
@d2 1
a2 1
# $OpenBSD: Core.pm,v 1.57 2013/10/04 07:18:38 espie Exp $
d4 1
a4 1
# Copyright (c) 2010 Marc Espie <espie@@openbsd.org>
@


1.57
log
@actually, this is a more general problem, so just skip cores where
there's no useful job for us.
@
text
@d2 1
a2 1
# $OpenBSD: Core.pm,v 1.56 2013/10/03 17:34:44 espie Exp $
d503 7
a509 1
	my $s = $core->job->name;
d519 7
a525 4
		
	$s .= " [$core->{pid}]".
	    (DPB::Host->name_is_localhost($hostname) ? "" : " on ".$hostname).
	    $core->job->watched($time, $core);
@


1.56
log
@move the "Hosts" status line to Core::Init, so that localhost gets an entry.
(will allow us to display extra core status, like tainted and such)
(this also pleases landry's sense of symetry)
@
text
@d2 1
a2 1
# $OpenBSD: Core.pm,v 1.55 2013/10/02 09:14:29 espie Exp $
d492 2
@


1.55
log
@exec even with !env
@
text
@d2 1
a2 1
# $OpenBSD: Core.pm,v 1.54 2013/09/24 10:07:27 espie Exp $
d90 1
d808 5
@


1.54
log
@zap an extra shell for most remote/chrooted runs
@
text
@d2 1
a2 1
# $OpenBSD: Core.pm,v 1.53 2013/09/23 14:50:54 espie Exp $
d875 1
a876 1
		unshift @@argv, 'exec' unless $self->{sudo} && !$chroot;
@


1.53
log
@sigh... if I want probabilistic results, cores MUST unsquiggle on a regular
basis.
@
text
@d2 1
a2 1
# $OpenBSD: Core.pm,v 1.52 2013/09/23 14:21:47 espie Exp $
d876 1
d883 1
a883 1
		unshift(@@argv, OpenBSD::Paths->sudo, "-E");
@


1.52
log
@very stupid logic error
@
text
@d2 1
a2 1
# $OpenBSD: Core.pm,v 1.51 2013/09/23 13:00:02 espie Exp $
d641 4
a644 1
	if ($core->can_squiggle && $core->host->{wantsquiggles}) {
d658 1
a658 1
sub can_squiggle
d661 1
a661 1
	return !$core->{squiggle};
d664 1
a664 1
sub can_be_swallowed
d667 7
a673 1
	return defined $core->host->{swallow};
d768 1
a768 1
sub can_squiggle
d770 1
a770 1
	return 0;
@


1.51
log
@allow non-integral values for wantsquiggles

uses random to devote "part of a core" to running squiggles instead
of normal jobs.

(might be useful for finetuning clusters with lots of dual-core boxen)
@
text
@d2 1
a2 1
# $OpenBSD: Core.pm,v 1.50 2013/09/22 06:29:38 espie Exp $
d642 5
a646 3
		if ($core->host->{wantsquiggles} < 1 && rand() <= $core->host->{wantsquiggles}) {
			$core->{squiggle} = $core->host->{wantsquiggles};
			$core->host->{wantsquiggles} = 0;
@


1.50
log
@show a '+' when we're building in-memory
@
text
@d2 1
a2 1
# $OpenBSD: Core.pm,v 1.49 2013/09/21 11:31:19 espie Exp $
d642 7
a648 2
		$core->host->{wantsquiggles}--;
		$core->{squiggle} = 1;
d669 1
a670 1
		$core->host->{wantsquiggles}++;
@


1.49
log
@the aliasing issue was hiding an other bug.
clean up code a bit, letting cores tell us whether they can be swallowed
or become squiggles, so that fetch cores can choose not to take part at all.
@
text
@d2 1
a2 1
# $OpenBSD: Core.pm,v 1.48 2013/09/21 09:20:17 espie Exp $
d500 1
a500 4
		
	my $s = $core->job->name." [$core->{pid}]".
	    (DPB::Host->name_is_localhost($hostname) ? "" : " on ".$hostname).
	    $core->job->watched($time, $core);
d507 7
@


1.48
log
@wrong exec, need some work.
@
text
@d2 1
a2 1
# $OpenBSD: Core.pm,v 1.47 2013/09/21 08:44:32 espie Exp $
d610 1
a610 1
		if (defined $core->host->{swallow}) {
d637 1
a637 1
	if (!$core->{squiggle} && $core->host->{wantsquiggles}) {
d644 12
d748 6
a753 1
sub get
d755 1
a755 3
	my $self = shift;
	$a = $self->available;
	return shift @@$a;
@


1.47
log
@introduce squiggles: special cores used for building small ports.
each host takes care of keeping its squiggles "alive". This may
include moving the squiggle property when the core gets swallowed,
and making sure listing/fetch/update distinfo cores are not squiggles.
@
text
@d2 1
a2 1
# $OpenBSD: Core.pm,v 1.44 2013/09/18 15:30:40 espie Exp $
a840 1
		unshift @@argv, 'exec';
@


1.46
log
@nail down distant hosts/chroot to go faster: use explicit /bin/sh, and
sprinkle an exec in front of the last command of the sh -c, so that we
don't use up that many processes
@
text
@d2 1
a2 1
# $OpenBSD: Core.pm,v 1.45 2013/09/21 08:40:09 espie Exp $
d504 3
d612 1
d636 16
a651 1
	return shift @@$a;
d734 7
@


1.45
log
@avoid creating a core with fullhostname for localhost, preventing some
unpleasant aliasing effects
@
text
@d2 1
a2 1
# $OpenBSD: Core.pm,v 1.44 2013/09/18 15:30:40 espie Exp $
d815 1
d835 1
a835 1
		$self->_run(@@cmd2, $chroot, "sh", "-c", $self->quote($cmd));
@


1.44
log
@use a "shell" to run getvars, so that we can run it again LATER.
@
text
@d2 1
a2 1
# $OpenBSD: Core.pm,v 1.43 2013/09/16 11:23:50 espie Exp $
d34 7
a41 6
		if ($class->name_is_localhost($name)) {
			$class = "DPB::Host::Localhost";
		} else {
			require DPB::Core::Distant;
			$class = "DPB::Host::Distant";
		}
@


1.43
log
@move the shell running code up to host. Makes no sense to have the same
data structure for each Core, and a lot of this is actually tied to the
host proper.

(note that Core::Distant no longer makes a lot of sense)
@
text
@d2 1
a2 1
# $OpenBSD: Core.pm,v 1.42 2013/09/14 09:42:11 espie Exp $
d737 1
@


1.42
log
@remove remains of nfs wait_timeout.
@
text
@d2 1
a2 1
# $OpenBSD: Core.pm,v 1.41 2013/09/11 10:44:14 espie Exp $
d25 6
d34 14
a47 2
	$hosts->{$name} //= bless {host => $name, 
		prop => DPB::HostProperties->finalize($prop) }, $class;
d76 3
d81 6
a86 2
	my $o = shift;
	return $o->name_is_localhost($o->{host});
d89 9
d150 2
a151 6
	return 1;
}

sub shellclass
{
	"DPB::Shell::Abstract";
d157 1
a157 1
	return $self->{shell};
a163 1
	$c->{shell} = $c->shellclass->new($c->host);
a705 10
sub shellclass
{
	my $self = shift;
	if ($self->prop->{chroot}) {
		return "DPB::Shell::Local::Chroot";
	} else {
		return "DPB::Shell::Local";
	}
}

d776 5
d850 5
@


1.41
log
@next step in chrooting, mostly refactor
- provide a chroot_user definition during prop finalize
- let shellclass be depend on the object built
- have all shells store prop and have access to it
- move the chrooted code into default core shell
- tweak running so that quoting/building commands happen everywhere
- change Config to recognize -B as a chroot override.

Tested thru distant chroot, local and distant !chroot
local chroot still not working, probably missing something stupid
@
text
@d2 1
a2 1
# $OpenBSD: Core.pm,v 1.40 2013/09/08 11:10:58 espie Exp $
a27 3
#	if ($class->name_is_localhost($name)) {
#		delete $prop->{wait_timeout};
#	}
@


1.40
log
@explain about sudo to the Core runner.
@
text
@d2 1
a2 1
# $OpenBSD: Core.pm,v 1.39 2013/09/03 09:44:06 espie Exp $
d124 1
a124 1
	"DPB::Shell::Abstract"
d137 1
a137 1
	$c->{shell} = $class->shellclass->new($c->host);
d682 6
a687 1
	"DPB::Shell::Local"
d721 7
a727 1
	bless {sudo => 0}, $class;
d783 46
@


1.39
log
@reorganize code, so the periodic sleeper task no longer knows
its sleeping interval, but rather asks it from the reporter.

Give limiter customer access to timing information. Eventually,
the reporter could possibly shrink/enlarge the display timeout
automatically.
@
text
@d2 1
a2 1
# $OpenBSD: Core.pm,v 1.38 2013/08/28 11:55:06 espie Exp $
d716 1
a716 1
	bless {}, $class;
d735 11
d768 3
@


1.38
log
@some features are not tested often enough.
fix "stop-host".
problem noticed by Florian Obser
@
text
@d2 1
a2 1
# $OpenBSD: Core.pm,v 1.37 2013/06/21 09:05:18 espie Exp $
d700 1
a700 1
	my ($class, $timeout) = @@_;
a701 1
	$timeout //= 10;
d703 1
a703 1
		sleep($timeout);
@


1.37
log
@disentangle the config/init code from the rest.

- move the meat of handle_options from dpb into config->parse_command_line
(this means a backcall to still inherit from OpenBSD::State).
- move parse_config_files from core into config.
- move the prop handling into proper HostProperties (part of config
obviously)
- create a Core::Init file that contains all the former DPB::Host::Factory
and associated jobs.

there's still a wee little bit of cleanup to do, but this should be
easier to maintain, as all option handling is now in one place, and
startup and host confi is now easier to figure out.

- add a -DMIRROR=0/1  setup that controls whether SUPDISTFILES will be
fetched (defaults to 1 for -F and 0 for -f).

- actually allow for several host files to be parsed, as the name implies
@
text
@d2 1
a2 1
# $OpenBSD: Core.pm,v 1.36 2013/04/22 20:56:53 espie Exp $
d528 3
a530 1
			$self->mark_available($self);
@


1.36
log
@forgotten commit, during debug, show more info about what's running on the
core (e.g., job contents)
@
text
@d2 1
a2 1
# $OpenBSD: Core.pm,v 1.35 2013/03/03 11:11:08 espie Exp $
a27 21
	$prop //= {};
	$prop->{sf} //= 1;
	$prop->{umask} //= sprintf("0%o", umask);
	if (defined $prop->{stuck}) {
		$prop->{stuck_timeout} = $prop->{stuck} * $prop->{sf};
	}
	if (defined $prop->{mem}) {
		$prop->{memory} = $prop->{mem};
	}
	if (defined $prop->{memory}) {
		my $_ = $prop->{memory};
		if (s/K$//) {
		} elsif (s/M$//) {
			$_ *= 1024;
		} elsif (s/G$//) {
			$_ *= 1024 * 1024;
		}
		$prop->{memory} = $_;
	}
	$prop->{small} //= 120;
	$prop->{small_timeout} = $prop->{small} * $prop->{sf};
d31 2
a32 1
	$hosts->{$name} //= bless {host => $name, prop => $prop }, $class;
a402 121
package DPB::Task::Ncpu;
our @@ISA = qw(DPB::Task::Pipe);
sub run
{
	my ($self, $core) = @@_;
	$core->shell->exec(OpenBSD::Paths->sysctl, '-n', 'hw.ncpu');
}

sub finalize
{
	my ($self, $core) = @@_;
	my $fh = $self->{fh};
	if ($core->{status} == 0) {
		my $line = <$fh>;
		chomp $line;
		if ($line =~ m/^\d+$/) {
			$core->prop->{jobs} = $line;
		}
	}
	close($fh);
	$core->prop->{jobs} //= 1;
	return 1;
}

package DPB::Job::Init;
our @@ISA = qw(DPB::Job);
use DPB::Signature;

sub new
{
	my ($class, $logger) = @@_;
	my $o = $class->SUPER::new('init');
	$o->{logger} = $logger;
	DPB::Signature->add_tasks($o);
	return $o;
}

# if everything is okay, we mark our jobs as ready
sub finalize
{
	my ($self, $core) = @@_;
	$self->{signature}->print_out($core, $self->{logger});
	if ($self->{signature}->matches($core, $self->{logger})) {
		for my $i (1 .. $core->prop->{jobs}) {
			ref($core)->new($core->hostname, $core->prop)->mark_ready;
		}
		return 1;
	} else {
		return 0;
    	}
}

# this is a weird one !
package DPB::Core::Factory;
our @@ISA = qw(DPB::Core::WithJobs);
my $init = {};

sub new
{
	my ($class, $host, $prop) = @@_;
	if (DPB::Host->name_is_localhost($host)) {
		return $init->{localhost} //= DPB::Core::Local->new_noreg($host, $prop);
	} else {
		require DPB::Core::Distant;
		return $init->{$host} //= DPB::Core::Distant->new_noreg($host, $prop);
	}
}


sub init_cores
{
	my ($self, $state) = @@_;

	my $logger = $state->logger;
	my $startup = $state->{startup_script};
	my $stale = $state->stalelocks;
	DPB::Core->set_logdir($logger->{logdir});
	for my $core (values %$init) {
		my $job = DPB::Job::Init->new($logger);
		if (!defined $core->prop->{jobs}) {
			$job->add_tasks(DPB::Task::Ncpu->new);
		}
		if (defined $startup) {
			my @@args = split(/\s+/, $startup);
			unshift(@@args, OpenBSD::Paths->sudo, "-E");
			$job->add_tasks(DPB::Task::Fork->new(
			    sub {
				my $shell = shift;
				DPB::Task->redirect($logger->logfile("init.".
				    $core->hostname));
				$shell
				    ->chdir($state->ports)
				    ->env(PORTSDIR => $state->ports,
				    	MAKE => $state->make)
				    ->exec(@@args);
			    }
			));
		}
		if (defined $stale->{$core->hostname}) {
			my $subdirlist=join(' ', @@{$stale->{$core->hostname}});
			$job->add_tasks(DPB::Task::Fork->new(
			    sub {
				my $shell = shift;
				DPB::Task->redirect($logger->logfile("init.".
				$core->hostname));
				$shell
				    ->chdir($state->ports)
				    ->env(SUBDIR => $subdirlist)
				    ->exec($state->make, 'unlock');
			    }
			));
		}
		$core->start_job($job);
	}
	if ($state->opt('f')) {
		for (1 .. $state->opt('f')) {
			DPB::Core::Fetcher->new('localhost', {})->mark_ready;
		}
	}
}

a636 1
	$prop->{sf} //= 1;
a645 56
}

my $has_sf = 0;

sub has_sf
{
	return $has_sf;
}

sub parse_hosts_file
{
	my ($class, $filename, $state, $default, $override) = @@_;
	open my $fh, '<', $filename or
		$state->fatal("Can't read host files #1: #2", $filename, $!);
	my $_;
	my $sf;
	my $cores = {};
	while (<$fh>) {
		chomp;
		s/\s*\#.*$//;
		next if m/^$/;
		if (m/^STARTUP=\s*(.*)\s*$/) {
			$state->{startup_script} = $1;
			next;
		}
		if (m/^LOGSIZE=\s*1\s*$/) {
			$state->{opt}{s} = 1;
		}
		# copy default properties
		my $prop = { %$default };
		my ($host, @@properties) = split(/\s+/, $_);
		for my $_ (@@properties) {
			if (m/^(.*?)=(.*)$/) {
				$prop->{$1} = $2;
			}
		}
		if (defined $prop->{arch} && $prop->{arch} ne $state->arch) {
			next;
		}
		if ($host eq 'DEFAULT') {
			$default = { %$prop };
			next;
		}
		while (my ($k, $v) = each %$override) {
			$prop->{$k} = $v;
		}
		$sf //= $prop->{sf};
		if (defined $prop->{sf} && $prop->{sf} != $sf) {
			$has_sf = 1;
		}
		$state->heuristics->calibrate(DPB::Core::Factory->new($host,
		    $prop));
	}
	if ($state->define_present("STARTUP")) {
		$state->{startup_script} = $state->{subst}->value("STARTUP");
	}
@


1.35
log
@rework INFO/DIE/WARN handler to display some info in a non-opaque way.
@
text
@d2 1
a2 1
# $OpenBSD: Core.pm,v 1.34 2013/03/03 00:49:14 espie Exp $
d322 6
@


1.34
log
@prevent going to debugger on exit in children.
allow LOGSIZE to set -s in the host file.
@
text
@d2 1
a2 1
# $OpenBSD: Core.pm,v 1.33 2013/01/29 11:16:58 espie Exp $
d298 6
@


1.33
log
@handle memory and mem as synonyms
@
text
@d2 1
a2 1
# $OpenBSD: Core.pm,v 1.32 2013/01/28 12:23:45 espie Exp $
d340 1
d800 3
@


1.32
log
@add a FETCH_TIMEOUT, similar to STUCK_TIMEOUT, but slightly simpler,
as there is no speed factor there...
@
text
@d2 1
a2 1
# $OpenBSD: Core.pm,v 1.31 2013/01/28 10:14:17 espie Exp $
d35 4
a38 1
		my $_ = $prop->{mem};
@


1.31
log
@tweak memory handling to make it less special: treat -M as an override_prop
as we should.
Use core methods to access the memory threshold.

UI simplification: -M can take a suffix, default is K, but you can just say
-M 520M or -M 2G now.
@
text
@d2 1
a2 1
# $OpenBSD: Core.pm,v 1.30 2013/01/27 17:54:45 espie Exp $
d181 6
@


1.30
log
@tweak the way the STARTUP script is run
@
text
@d2 1
a2 1
# $OpenBSD: Core.pm,v 1.29 2013/01/21 10:46:42 espie Exp $
d34 10
a800 3
		}
		if (defined $prop->{mem}) {
			$prop->{memory} = $prop->{mem};
@


1.29
log
@saner and more consistent handling of small
@
text
@d2 1
a2 1
# $OpenBSD: Core.pm,v 1.28 2013/01/10 10:26:34 espie Exp $
d474 2
d481 5
a485 1
				$shell->exec($startup);
@


1.28
log
@a bit of refactoring: provide simple ways to check DPB_PROPERTIES without
having a hash element spring into existence, and to list jobs running on
the same host.
@
text
@d2 1
a2 1
# $OpenBSD: Core.pm,v 1.27 2013/01/06 11:59:40 espie Exp $
d34 2
@


1.27
log
@ask the ports tree to clean up stale locks, finally...
@
text
@d2 1
a2 1
# $OpenBSD: Core.pm,v 1.26 2013/01/05 21:48:50 espie Exp $
d559 10
@


1.26
log
@better
@
text
@d2 1
a2 1
# $OpenBSD: Core.pm,v 1.25 2013/01/05 21:48:18 espie Exp $
d464 1
d481 14
a494 10
#		if (defined $cleanlock) {
#			$job->add_tasks(DPB::Task::Fork->new(
#			    sub {
#				my $shell = shift;
#				DPB::Task->redirect($logger->logfile("init.".
#				$core->hostname));
#				$shell->exec();
#			    }
#			));
#		}
@


1.25
log
@give every task a "name".
@
text
@d2 1
a2 1
# $OpenBSD: Core.pm,v 1.24 2013/01/04 18:49:39 espie Exp $
d317 1
a317 1
		die "Oops: task ".$task->name." couldn't start\n";
@


1.24
log
@another half-baked change
@
text
@d2 1
a2 1
# $OpenBSD: Core.pm,v 1.23 2012/12/31 09:50:55 espie Exp $
d317 1
a317 1
		die "Oops: task couldn't start\n";
d480 10
@


1.23
log
@allow overriding the start-up script from the command line.
@
text
@d2 1
a2 1
# $OpenBSD: Core.pm,v 1.22 2012/12/29 19:14:51 espie Exp $
d777 1
a777 1
		$state->{startup_script} = $override->{startup_script};
@


1.22
log
@allow looking for a given core when trying to match affinity
@
text
@d2 1
a2 1
# $OpenBSD: Core.pm,v 1.21 2012/12/24 17:24:46 espie Exp $
d775 3
@


1.21
log
@add affinity information to restart jobs on the right host preferentially.
- affinity info is similar to locks, but with a completely different
lifetime.
- streamline the main loop of the engine, so that it can do two passes:
first pass shuns paths with the wrong affinity. If no good path is found,
those are considered during the second pass.
- make the Core factory aware of what hosts might be running, so that
affinity info for machines removed from a config file will be ignored.

thanks to landry@@ for a few tests.
@
text
@d2 1
a2 1
# $OpenBSD: Core.pm,v 1.20 2012/11/06 08:26:29 espie Exp $
d680 16
@


1.20
log
@don't mix up wait_timeout and waiting_timeout, as noticed by naddy@@.
re-enable wait_timeout on localhost temporarily (should be done in another
way, most probably by checking whether repo is on nfs, we can steal code
from VStat.pm)

pass umask through ssh. This took us long enough to figure out, and it's
considerably simpler than tweaking every login class once again.
@
text
@d2 1
a2 1
# $OpenBSD: Core.pm,v 1.19 2012/10/13 09:06:55 espie Exp $
d84 14
d143 1
@


1.19
log
@disable the waiting period if waiting_timeout is 0.
and don't do it on localhost
@
text
@d2 1
a2 1
# $OpenBSD: Core.pm,v 1.18 2012/10/11 07:40:30 espie Exp $
d30 1
d34 3
a36 3
	if ($class->name_is_localhost($name)) {
		delete $prop->{waiting_timeout};
	}
@


1.18
log
@change things again to have command line options override host file.
and provide the possibility of a DEFAULT entry in the host file.
@
text
@d2 1
a2 1
# $OpenBSD: Core.pm,v 1.17 2012/10/08 14:16:36 espie Exp $
d33 3
d702 1
a702 1
	my ($class, $filename, $state, $override) = @@_;
a707 1
	my $default = {};
@


1.17
log
@zap last bit of state, showing everything as host/4*2 is bad...
@
text
@d2 1
a2 1
# $OpenBSD: Core.pm,v 1.16 2012/10/08 12:41:03 espie Exp $
d699 1
a699 1
	my ($class, $filename, $state, $default) = @@_;
d705 1
d714 1
a714 1
		# copy default [properties
d728 7
a737 6
		}
		if (defined $state->{connection_timeout}) {
			$prop->{timeout} //= $state->{connection_timeout};
		}
		if (defined $state->{stuck_timeout}) {
			$prop->{stuck} //= $state->{stuck_timeout};
@


1.16
log
@small change for people running multiple hosts:

options on the command line now define *defaults* that host files can
override (for instance -j, stuck, -p, -J).

Add -p /n to mean "take number of jobs, if >1, divide by n, round up to 2,
and use that for parallel.

Document -p.

Make junk be 'by host' (and it's a prop, so you can tweak it).

concurrent log that records how many jobs are running each time it changes.
tag parallel builds *n in the time record.
@
text
@d2 1
a2 1
# $OpenBSD: Core.pm,v 1.14 2012/09/23 18:13:32 espie Exp $
d627 1
@


1.15
log
@oops, unmark core for swallowing before we free it. Otherwise we may
still lose jobs.
@
text
@d479 20
d602 1
d698 1
a698 1
	my ($class, $filename, $state) = @@_;
d712 2
a713 1
		my $prop = {};
@


1.14
log
@new framework to deal with the new ports cluster, to be documented
@
text
@d2 1
a2 1
# $OpenBSD: Core.pm,v 1.13 2012/07/08 09:59:31 jasper Exp $
d599 4
a602 1
			$self->mark_available(@@{$core->{swallowed}});
d606 3
@


1.13
log
@- fix obivous typo, resulting in always using only one job per host.
@
text
@d2 1
a2 1
# $OpenBSD: Core.pm,v 1.12 2012/07/04 08:59:10 espie Exp $
d158 6
d510 2
a511 1
	return $core->job->name." [$core->{pid}]".
d514 4
d577 15
d595 23
a617 1
	push(@@{$self->available}, @@_);
@


1.12
log
@remove distinction between local and distant running, always create
a shell object that can chdir, setenv, and exec commands.
(note that this executes stuff after fork, so permanent changes are cheap
and okay)

Also create it from "host" objects, which simplifies parameter passing.
@
text
@d2 1
a2 1
# $OpenBSD$
d369 1
a369 1
	$core->shell->exec(OpenBSD::Path->sysctl, '-n', 'hw.ncpu');
@


1.11
log
@methods required to be able to lock per-host
@
text
@d2 1
a2 1
# $OpenBSD: Core.pm,v 1.10 2011/11/14 21:56:04 espie Exp $
d109 11
d123 3
a125 1
	bless {host => DPB::Host->new($host, $prop)}, $class;
d369 1
a369 7
	my $shell = $core->{shell};
	my $sysctl = OpenBSD::Paths->sysctl;
	if (defined  $shell) {
		$shell->run("$sysctl -n hw.ncpu");
	} else {
		exec{$sysctl} ($sysctl, '-n', 'hw.ncpu');
	}
d451 1
a451 5
				if (defined $shell) {
					$shell->run($startup);
				} else {
					exec{$startup}($startup);
				}
d695 5
d722 52
@


1.10
log
@allow check for local cores
@
text
@d2 1
a2 1
# $OpenBSD: Core.pm,v 1.9 2011/06/04 12:58:24 espie Exp $
d149 16
@


1.9
log
@spaces
@
text
@d2 1
a2 1
# $OpenBSD$
d461 5
d669 5
@


1.8
log
@initial support for fetching distfiles, somewhat experimental yet.
- clean up clock handling, jobs with timer.
- pass more parameters thru state
- tweak the engine to handle distfiles
- lots of new code in Fetch for new jobs.
@
text
@d2 1
a2 1
# $OpenBSD: Core.pm,v 1.7 2011/04/25 11:58:46 espie Exp $
d600 1
a600 1
	open my $fh, '<', $filename or 
d636 1
a636 1
		$state->heuristics->calibrate(DPB::Core::Factory->new($host, 
@


1.7
log
@finish refactoring options.
Deprecate: -t and -T
use -DCONNECTION_TIMEOUT=... -DDISPLAY_TIMEOUT=... instead
New feature: -DSTUCK_TIMEOUT=
kill tasks when they don't show any progress for that long.
@
text
@d2 1
a2 1
# $OpenBSD: Core.pm,v 1.6 2011/03/22 19:49:56 espie Exp $
d30 3
d136 1
a136 1
	return $self->prop->{stuck};
d437 5
@


1.6
log
@tweak to allow subclasses of cores that get their own separate lists
(such as local fetcher jobs)
@
text
@d2 1
a2 1
# $OpenBSD: Core.pm,v 1.5 2010/10/29 11:51:42 espie Exp $
d130 6
a405 1
my $inited = 0;
d409 1
a409 2
	my ($self, $logger, $startup) = @@_;
	return if $inited;
d411 2
a434 1
	$inited = 1;
d474 1
a474 1
	    $core->job->watched($time);
d591 3
a593 2
	my ($class, $filename, $arch, $timeout, $logger, $heuristics) = @@_;
	open my $fh, '<', $filename or die "Can't read host files $filename\n";
a596 1
	my $startup_script;
d602 1
a602 1
			$startup_script = $1;
d612 1
a612 1
		if (defined $prop->{arch} && $prop->{arch} ne $arch) {
d622 5
a626 2
		if (defined $timeout) {
			$prop->{timeout} //= $timeout;
d628 2
a629 1
		$heuristics->calibrate(DPB::Core::Factory->new($host, $prop));
a630 1
	DPB::Core::Factory->init_cores($logger, $startup_script);
@


1.5
log
@engine improvements:
- if several cores are available, recheck errors, so that we're not stuck
waiting for a core to finish to start new shit.
- $logdir/stop-<machine_name> allows you to stop a given machine while
you clean it up and (possibly) restart it (e.g., won't start new jobs)
@
text
@d2 1
a2 1
# $OpenBSD: Core.pm,v 1.4 2010/10/28 22:14:54 landry Exp $
d435 1
a435 1
my @@available = ();
d507 1
a507 1
		push(@@available, $self);
d517 1
a517 1
			push(@@available, @@{$stopped{$h}});
d521 12
a532 1
	return scalar(@@available);
d542 4
a545 2
	if (@@available > 1) {
		@@available = sort {$b->sf <=> $a->sf} @@available;
d547 1
a547 1
	return shift @@available;
d648 10
@


1.4
log
@Readd missing space before "on $hostname"
@
text
@d2 1
a2 1
# $OpenBSD: Core.pm,v 1.3 2010/10/28 12:51:37 espie Exp $
d407 1
d437 11
d503 6
a508 1
	push(@@available, $self);
d515 7
a521 1
	return @@available > 0;
@


1.3
log
@zap localhost from those lines too.
will make display snappier on one core machine, and still be readable
otherwise...
@
text
@d2 1
a2 1
# $OpenBSD: Core.pm,v 1.2 2010/10/23 17:58:55 espie Exp $
d456 1
a456 1
	    (DPB::Host->name_is_localhost($hostname) ? "" : "on ".$hostname).
@


1.2
log
@if we don't ssh to it, don't print the name either in errors, as requested by
landry@@
@
text
@d2 1
a2 1
# $OpenBSD: Core.pm,v 1.1.1.1 2010/08/20 13:40:13 espie Exp $
d454 3
a456 1
	return $core->job->name." [$core->{pid}] on ".$core->hostname.
@


1.1
log
@Initial revision
@
text
@d2 1
a2 1
# $OpenBSD: Core.pm,v 1.13 2010/06/07 15:27:52 espie Exp $
d49 16
d392 1
a392 1
	if ($host eq "localhost" or $host eq DPB::Core::Local->hostname) {
@


1.1.1.1
log
@move stuff here from infra/build
@
text
@@
