head	1.32;
access;
symbols
	OPENBSD_6_1:1.31.0.14
	OPENBSD_6_1_BASE:1.31
	OPENBSD_6_0:1.31.0.12
	OPENBSD_6_0_BASE:1.31
	OPENBSD_5_9:1.31.0.8
	OPENBSD_5_9_BASE:1.31
	OPENBSD_5_8:1.31.0.10
	OPENBSD_5_8_BASE:1.31
	OPENBSD_5_7:1.31.0.6
	OPENBSD_5_7_BASE:1.31
	OPENBSD_5_6:1.31.0.4
	OPENBSD_5_6_BASE:1.31
	OPENBSD_5_5:1.31.0.2
	OPENBSD_5_5_BASE:1.31
	OPENBSD_5_4:1.21.0.2
	OPENBSD_5_4_BASE:1.21
	OPENBSD_5_3:1.19.0.2
	OPENBSD_5_3_BASE:1.19
	OPENBSD_5_2:1.14.0.2
	OPENBSD_5_2_BASE:1.14
	OPENBSD_5_1_BASE:1.11
	OPENBSD_5_1:1.11.0.2
	OPENBSD_5_0:1.9.0.2
	OPENBSD_5_0_BASE:1.9
	OPENBSD_4_9:1.3.0.2
	OPENBSD_4_9_BASE:1.3
	ports:1.1.1.1
	espie:1.1.1;
locks; strict;
comment	@# @;


1.32
date	2017.05.14.12.43.55;	author espie;	state Exp;
branches;
next	1.31;
commitid	1Xs1a8QQrkgPiIQq;

1.31
date	2013.10.17.08.12.28;	author espie;	state Exp;
branches;
next	1.30;

1.30
date	2013.10.13.18.31.50;	author espie;	state Exp;
branches;
next	1.29;

1.29
date	2013.10.12.14.11.23;	author espie;	state Exp;
branches;
next	1.28;

1.28
date	2013.10.12.13.53.35;	author espie;	state Exp;
branches;
next	1.27;

1.27
date	2013.10.10.07.26.40;	author espie;	state Exp;
branches;
next	1.26;

1.26
date	2013.10.06.13.33.31;	author espie;	state Exp;
branches;
next	1.25;

1.25
date	2013.10.06.13.22.19;	author espie;	state Exp;
branches;
next	1.24;

1.24
date	2013.10.06.12.38.23;	author espie;	state Exp;
branches;
next	1.23;

1.23
date	2013.09.25.08.49.07;	author espie;	state Exp;
branches;
next	1.22;

1.22
date	2013.09.21.08.46.07;	author espie;	state Exp;
branches;
next	1.21;

1.21
date	2013.06.21.09.05.18;	author espie;	state Exp;
branches;
next	1.20;

1.20
date	2013.05.29.09.37.17;	author espie;	state Exp;
branches;
next	1.19;

1.19
date	2013.02.02.13.35.17;	author espie;	state Exp;
branches;
next	1.18;

1.18
date	2013.01.31.10.29.58;	author espie;	state Exp;
branches;
next	1.17;

1.17
date	2013.01.28.10.14.17;	author espie;	state Exp;
branches;
next	1.16;

1.16
date	2013.01.10.22.42.21;	author espie;	state Exp;
branches;
next	1.15;

1.15
date	2013.01.10.10.25.25;	author espie;	state Exp;
branches;
next	1.14;

1.14
date	2012.03.09.12.51.38;	author espie;	state Exp;
branches;
next	1.13;

1.13
date	2012.03.06.13.41.38;	author espie;	state Exp;
branches;
next	1.12;

1.12
date	2012.02.17.07.35.42;	author espie;	state Exp;
branches;
next	1.11;

1.11
date	2011.10.10.18.56.50;	author espie;	state Exp;
branches;
next	1.10;

1.10
date	2011.09.13.09.46.53;	author espie;	state Exp;
branches;
next	1.9;

1.9
date	2011.07.14.11.03.13;	author espie;	state Exp;
branches;
next	1.8;

1.8
date	2011.06.04.12.58.24;	author espie;	state Exp;
branches;
next	1.7;

1.7
date	2011.06.02.17.09.25;	author espie;	state Exp;
branches;
next	1.6;

1.6
date	2011.06.01.12.34.29;	author espie;	state Exp;
branches;
next	1.5;

1.5
date	2011.05.27.10.27.50;	author espie;	state Exp;
branches;
next	1.4;

1.4
date	2011.05.22.08.21.39;	author espie;	state Exp;
branches;
next	1.3;

1.3
date	2010.12.06.19.35.06;	author espie;	state Exp;
branches;
next	1.2;

1.2
date	2010.12.06.13.19.44;	author espie;	state Exp;
branches;
next	1.1;

1.1
date	2010.08.20.13.40.13;	author espie;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2010.08.20.13.40.13;	author espie;	state Exp;
branches;
next	;


desc
@@


1.32
log
@when requeuing, all infos are not defined for all paths.
this is just a heuristics, so it doesn't matter, but the least
we can do is not crash
@
text
@# ex:ts=8 sw=4:
# $OpenBSD: Heuristics.pm,v 1.31 2013/10/17 08:12:28 espie Exp $
#
# Copyright (c) 2010-2013 Marc Espie <espie@@openbsd.org>
#
# Permission to use, copy, modify, and distribute this software for any
# purpose with or without fee is hereby granted, provided that the above
# copyright notice and this permission notice appear in all copies.
#
# THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
# ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
# OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

use strict;
use warnings;

# this package is responsible for the initial weighing of pkgpaths, and handling
# consequences
package DPB::Heuristics;

# for now, we don't create a separate object, we assume everything here is
# "global"

my (%bad_weight, %needed_by);
our %weight;

sub new
{
	my ($class, $state) = @@_;
	bless {state => $state}, $class;
}

sub random
{
	my $self = shift;
	bless $self, "DPB::Heuristics::random";
}

# we set the "unknown" weight as max if we parsed a file.
my $default = 1;

sub finished_parsing
{
	my $self = shift;
	while (my ($k, $v) = each %bad_weight) {
		$self->set_weight($k, $v);
	}
	if (keys %weight > 0) {
		my @@l = sort values %weight;
		$default = pop @@l;
	}
}

sub intrinsic_weight
{
	my ($self, $v) = @@_;
	$weight{$v} // $default;
}

sub equates
{
	my ($class, $h) = @@_;
	for my $v (values %$h) {
		next unless defined $weight{$v};
		for my $w (values %$h) {
			$weight{$w} //= $weight{$v};
		}
		return;
	}
}


sub set_weight
{
	my ($self, $v, $w) = @@_;
	return unless defined $w;
	if (ref $v && $v->{scaled}) {
		$weight{$v} = $w * $v->{scaled};
		delete $v->{scaled};
	} else {
		$weight{$v} = $w;
	}
}

my $cache;

sub mark_depend
{
	my ($self, $d, $v) = @@_;
	if (!defined $needed_by{$d}{$v}) {
		$needed_by{$d}{$v} = $v;
		$cache = {};
	}
}

sub compute_measure
{
	my ($self, $v) = @@_;
	my $dependencies = {$v => $v};
	my @@todo = values %{$needed_by{$v}};
	while (my $k = pop (@@todo)) {
		next if $dependencies->{$k};
		$dependencies->{$k} = $k;
		push(@@todo, values %{$needed_by{$k}});
	}

	my $sum = 0;
	for my $k (values %$dependencies) {
		$sum += $self->intrinsic_weight($k);
	}
	return $sum;
}

sub measure
{
	my ($self, $v) = @@_;
	$cache->{$v} //= $self->compute_measure($v);
}

sub compare
{
	my ($self, $a, $b) = @@_;
	# XXX if we don't know, we prefer paths "later in the game"
	# so if you abort dpb and restart it, it will start doing
	# things earlier.
	return $self->measure($a) <=> $self->measure($b) || 
	    $a->pkgpath cmp $b->pkgpath;
}

my $sf_per_host = {};
my $max_sf;

sub calibrate
{
	my ($self, @@cores) = @@_;
	for my $core (@@cores) {
		$sf_per_host->{$core->fullhostname} = $core->sf;
		$max_sf //= $core->sf;
		if ($core->sf > $max_sf) {
			$max_sf = $core->sf;
		}
	}
}

sub add_build_info
{
	my ($self, $pkgpath, $host, $time, $sz) = @@_;
	if (defined $sf_per_host->{$host}) {
		$time *= $sf_per_host->{$host};
		$time /= $max_sf;
		$self->set_weight($pkgpath, $time);
	} else {
		$bad_weight{$pkgpath} //= $time;
	}
}

sub compare_weights
{
	my ($self, $a, $b) = @@_;
	return $self->intrinsic_weight($a) <=> $self->intrinsic_weight($b);
}

sub new_queue
{
	my $self = shift;
	if (DPB::HostProperties->has_sf) {
		require DPB::Heuristics::SpeedFactor;
		return DPB::Heuristics::Queue::Part->new($self);
	} else {
		return DPB::Heuristics::Queue->new($self);
	}
}

# this specific stuff keeps track of the time we need to do stuff
my $todo = {};
my $total = 0;

sub todo
{
	my ($self, $path) = @@_;
	my $p = $path->pkgpath_and_flavors;
	if (!defined $todo->{$p}) {
		$todo->{$p} = 1;
		$total += $self->intrinsic_weight($p);
	}
}

sub done
{
	my ($self, $path) = @@_;
	my $p = $path->pkgpath_and_flavors;
	if (defined $todo->{$p}) {
		delete $todo->{$p};
		$total -= $self->intrinsic_weight($p);
	}
}

sub report
{
	my $time = time;
	return DPB::Util->time2string($time)." [$$]\n";
	# okay, I need to sit down and do the actual computation, sigh.
	my $all = DPB::Core->all_sf;
	my $sum_sf = 0;
	for my $sf (@@$all) {
		$sum_sf += $sf;
	}

	return scalar(keys %$todo)." ".$total*$max_sf." $sum_sf\n".DPB::Util->time2string($time)." -> ".
		DPB::Util->time2string($time+$total*$max_sf*$max_sf/$sum_sf)." [$$]\n";
}

package DPB::Heuristics::SimpleSorter;
sub new
{
	my ($class, $o) = @@_;
	bless $o->sorted_values, $class;
}

sub next
{
	my $self = shift;
	return pop @@$self;
}

# that's the queue used by squiggles
# "squiggles" will build small ports preferentially,
# trying to do stuff which has depends first, up to a point.
package DPB::Heuristics::ReverseSorter;
our @@ISA = (qw(DPB::Heuristics::SimpleSorter));
sub new
{
	my ($class, $o) = @@_;
	bless {l => $o->sorted_values, l2 => []}, $class;
}

# return smallest stuff with depends preferably
sub next
{
	my $self = shift;
	# grab stuff from the normal queue
	while (my $v = shift @@{$self->{l}}) {
		# XXX when requeuing a job with L= on the side, this might not
		# be defined yet.
		if (defined $v->{info}) {
			my $dep = $v->{info}->solve_depends;
			# it has depends, return it
			if (%$dep) {
				return $v;
			}
	    	}
		# otherwise keep it for later.
		push(@@{$self->{l2}}, $v);
		# XXX but when the diff grows too much, give up!
		# 200 is completely arbitrary
		last if DPB::Heuristics->measure($v) >
		    200 * DPB::Heuristics->measure($self->{l2}[0]);
	}
	return shift @@{$self->{l2}};
}

package DPB::Heuristics::Sorter;
sub new
{
	my ($class, $list) = @@_;
	my $o = bless {list => $list, l => []}, $class;
	$o->next_bin;
	return $o;
}

sub next_bin
{
	my $self = shift;
	if (my $bin = pop @@{$self->{list}}) {
		$self->{l} = $bin->sorted_values;
	} else {
		return;
	}
}

sub next
{
	my $self = shift;
	if (my $r = pop @@{$self->{l}}) {
		return $r;
	} else {
		if ($self->next_bin) {
			return $self->next;
		} else {
			return;
		}
	}
}

package DPB::Heuristics::Bin;
sub new
{
	my ($class, $h) = @@_;
	bless {o => {}, weight => 0, h => $h}, $class;
}

sub add
{
	my ($self, $v) = @@_;
	$self->{o}{$v} = $v;
}

sub contains
{
	my ($self, $v) = @@_;
	return exists $self->{o}{$v};
}

sub remove
{
	my ($self, $v) = @@_;
	delete $self->{o}{$v};
}

sub weight
{
	my $self = shift;
	return $self->{weight};
}

sub count
{
	my $self = shift;
	return scalar keys %{$self->{o}};
}

sub non_empty
{
	my $self = shift;
	return scalar(keys %{$self->{o}}) != 0;
}

sub sorted_values
{
	my $self = shift;
	return [sort {$self->{h}->compare($a, $b)} values %{$self->{o}}];
}

package DPB::Heuristics::Queue;
our @@ISA = qw(DPB::Heuristics::Bin);

sub sorted
{
	my ($self, $core) = @@_;
	if ($core->{squiggle}) {
		return DPB::Heuristics::ReverseSorter->new($self);
	}
	return $self->find_sorter($core);
}

sub find_sorter
{
	my ($self, $core) = @@_;
	return DPB::Heuristics::SimpleSorter->new($self);
}

package DPB::Heuristics::random;
our @@ISA = qw(DPB::Heuristics);
my %any;

sub compare
{
	my ($self, $a, $b) = @@_;
	return ($any{$a} //= rand) <=> ($any{$b} //= rand);
}

sub new_queue
{
	my $self = shift;
	return DPB::Heuristics::Queue->new($self);
}

1;
@


1.31
log
@do a few things later (preparing for -B)
Core::Init knows its hosts, so use that
knowledge to better separate Heuristics handling
@
text
@d2 1
a2 1
# $OpenBSD: Heuristics.pm,v 1.30 2013/10/13 18:31:50 espie Exp $
d247 9
a255 6
		my $dep = $v->{info}->solve_depends;

		# it has depends, return it
		if (%$dep) {
			return $v;
		} else {
d257 5
a261 6
			push(@@{$self->{l2}}, $v);
			# XXX but when the diff grows too much, give up!
			# 200 is completely arbitrary
			last if DPB::Heuristics->measure($v) >
			    200 * DPB::Heuristics->measure($self->{l2}[0]);
		}
@


1.30
log
@- use separated Heuristics::Size object
- choose size/nosize in Config.
- use affinity or affinitystub
- move locker creation to State, so we can init cores right away.
- as core init has run, we can call DPB::Core->reap (event loop) while
processing size and build stats, so that the startup script may start
slightly earlier.
- setup more options in Config for Reporter to use.
- scaffolding in SubEngine/Build to be able to use affinity info right away
@
text
@d2 1
a2 1
# $OpenBSD: Heuristics.pm,v 1.29 2013/10/12 14:11:23 espie Exp $
d139 7
a145 5
	my ($self, $core) = @@_;
	$sf_per_host->{$core->fullhostname} = $core->sf;
	$max_sf //= $core->sf;
	if ($core->sf > $max_sf) {
		$max_sf = $core->sf;
@


1.29
log
@the speedfactor case needs access to the weights.
@
text
@d2 1
a2 1
# $OpenBSD: Heuristics.pm,v 1.28 2013/10/12 13:53:35 espie Exp $
d28 1
a28 1
my (%bad_weight, %wrkdir, %needed_by, %pkgname);
a42 6
sub set_logger
{
	my ($self, $logger) = @@_;
	$self->{logger} = $logger;
}

a75 60
sub add_size_info
{
	my ($self, $path, $pkgname, $sz) = @@_;
	$wrkdir{$path->pkgpath_and_flavors} = $sz;
	if (defined $pkgname) {
		$pkgname{$path->fullpkgpath} = $pkgname;
	}
}

sub match_pkgname
{
	my ($self, $v) = @@_;
	my $p = $pkgname{$v->fullpkgpath};
	if (!defined $p) {
		return 0;
	}
	if ($p eq $v->fullpkgname) {
		return 1;
	}
	return 0;
}

my $used_memory = {};
my $used_per_host = {};

sub build_in_memory
{
	my ($self, $core, $v) = @@_;
	my $t = $core->memory;
	return 0 if !defined $t;

	# first match previous affinity
	if ($v->{affinity}) {
		return $v->{mem_affinity};
	}

	my $p = $v->pkgpath_and_flavors;

	# we build in memory if we know this port and it's light enough
	if (defined $wrkdir{$p}) {
		my $hostname = $core->hostname;
		$used_per_host->{$hostname} //= 0;
		if ($used_per_host->{$hostname} + $wrkdir{$p} <= $t) {
			$used_per_host->{$hostname} += $wrkdir{$p};
			$used_memory->{$p} = $hostname;
			return $wrkdir{$p};
		}
	}
	return 0;
}

sub finish_special
{
	my ($self, $v) = @@_;
	my $p = $v->pkgpath_and_flavors;
	if (defined $used_memory->{$p}) {
		my $hostname = $used_memory->{$p};
		$used_per_host->{$hostname} -= $wrkdir{$p};
	}
}
@


1.28
log
@move the speedfactor special code out of the way and load it only
on demand.

Mostly for clarity, the speed/size difference isn't expected to be much.
@
text
@d2 1
a2 1
# $OpenBSD: Heuristics.pm,v 1.27 2013/10/10 07:26:40 espie Exp $
d28 2
a29 1
my (%weight, %bad_weight, %wrkdir, %needed_by, %pkgname);
@


1.27
log
@extra test for non_empty ? grasping at straws
@
text
@d2 1
a2 1
# $OpenBSD: Heuristics.pm,v 1.26 2013/10/06 13:33:31 espie Exp $
d234 1
a408 16
package DPB::Heuristics::Bin::Heavy;
our @@ISA = qw(DPB::Heuristics::Bin);
sub add
{
	my ($self, $v) = @@_;
	$self->SUPER::add($v);
	$self->{weight} += $weight{$v};
}

sub remove
{
	my ($self, $v) = @@_;
	$self->{weight} -= $weight{$v};
	$self->SUPER::remove($v);
}

a424 99
}

package DPB::Heuristics::Queue::Part;
our @@ISA = qw(DPB::Heuristics::Queue);

# 20 bins, binary....
sub find_bin
{
	my $w = shift;
	return 10 if !defined $w;
	if ($w > 65536) {
		if ($w > 1048576) { 9 } else { 8 }
	} elsif ($w > 256) {
		if ($w > 4096) {
			if ($w > 16384) { 7 } else { 6 }
		} elsif ($w > 1024) { 5 } else { 4 }
	} elsif ($w > 16) {
		if ($w > 64) { 3 } else { 2 }
	} elsif ($w > 4) { 1 } else { 0 }
}

sub add
{
	my ($self, $v) = @@_;
	$self->SUPER::add($v);
	$v->{weight} = $weight{$v};
	$self->{bins}[find_bin($v->{weight})]->add($v);
}

sub remove
{
	my ($self, $v) = @@_;
	$self->SUPER::remove($v);
	$self->{bins}[find_bin($v->{weight})]->remove($v);
}

sub find_sorter
{
	my ($self, $core) = @@_;
	my $all = DPB::Core->all_sf;
	if ($core->sf > $all->[-1] - 1) {
		return $self->SUPER::find_sorter($core);
	} else {
		return DPB::Heuristics::Sorter->new($self->bin_part($core->sf,
		    $all));
	}
}

# simpler partitioning
sub bin_part
{
	my ($self, $wanted, $all_sf) = @@_;

	# note that all_sf is sorted

	# compute totals
	my $sum_sf = 0;
	for my $i (@@$all_sf) {
		$sum_sf += $i;
	}
	my @@bins = @@{$self->{bins}};
	my $sum_weight = 0.0;
	for my $bin (@@bins) {
		$sum_weight += $bin->weight;
	}

	# setup for the main loop
	my $partial_weight = 0.0;
	my $partial_sf = 0.0;
	my $result = [];

	# go through speed factors until we've gone thru the one we want
	while (my $sf = shift @@$all_sf) {
		# passed it -> give result
		last if $sf > $wanted+1;

		# compute threshold for total weight
		$partial_sf += $sf;
		my $thr = $sum_weight * $partial_sf / $sum_sf;
		# grab weights until we reach the desired amount
		while (my $bin = shift @@bins) {
			$partial_weight += $bin->weight;
			push(@@$result, $bin);
			last if $partial_weight > $thr;
		}
	}
	return $result;
}

sub new
{
	my ($class, $h) = @@_;
	my $o = $class->SUPER::new($h);
	my $bins = $o->{bins} = [];
	for my $i (0 .. 9) {
		push(@@$bins, DPB::Heuristics::Bin::Heavy->new($h));
	}
	push(@@$bins, DPB::Heuristics::Bin->new($h));
	return $o;
@


1.26
log
@update my copyright to 2013
@
text
@d2 1
a2 1
# $OpenBSD: Heuristics.pm,v 1.25 2013/10/06 13:22:19 espie Exp $
d399 1
a399 1
	return scalar keys %{$self->{o}};
@


1.25
log
@split some code into separate files, so that it doesn't get
loaded if it's not needed.
@
text
@d2 1
a2 1
# $OpenBSD: Heuristics.pm,v 1.24 2013/10/06 12:38:23 espie Exp $
d4 1
a4 1
# Copyright (c) 2010 Marc Espie <espie@@openbsd.org>
@


1.24
log
@rename "special" parameter to what it really is, building in memory.
return actual size for affinity files.

assume affinity files record previous choice and reuse it
@
text
@d2 1
a2 1
# $OpenBSD: Heuristics.pm,v 1.23 2013/09/25 08:49:07 espie Exp $
a554 81
}

package DPB::Heuristics::FetchQueue;
our @@ISA = qw(DPB::Heuristics::Queue);
sub new
{
	my ($class, $h) = @@_;
	$class->SUPER::new($h)->set_h1;
}

sub set_h1
{
	bless shift, "DPB::Heuristics::FetchQueue1";
}

sub set_h2
{
	bless shift, "DPB::Heuristics::FetchQueue2";
}

sub set_fetchonly
{
	bless shift, "DPB::Heuristics::FetchOnlyQueue";
}

sub sorted
{
	my $self = shift;
	if ($self->{results}++ > 50 ||
	    defined $self->{sorted} && @@{$self->{sorted}} < 10) {
		$self->{results} = 0;
		undef $self->{sorted};
	}
	return $self->{sorted} //= DPB::Heuristics::SimpleSorter->new($self);
}

package DPB::Heuristics::FetchQueue1;
our @@ISA = qw(DPB::Heuristics::FetchQueue);

# heuristic 1: grab the smallest distfiles that can build directly
# so that we avoid queue starvation
sub sorted_values
{
	my $self = shift;
	my @@l = grep {$_->{path}{has} == 0} values %{$self->{o}};
	if (!@@l) {
		@@l = grep {$_->{path}{has} < 2} values %{$self->{o}};
		if (!@@l) {
			@@l = values %{$self->{o}};
		}
	}
	return [sort {$b->{sz} <=> $a->{sz}} @@l];
}

package DPB::Heuristics::FetchQueue2;
our @@ISA = qw(DPB::Heuristics::FetchQueue);

# heuristic 2: assume we're running good enough, grab distfiles that allow
# build to proceed as usual
# we don't care so much about multiple distfiles
sub sorted_values
{
	my $self = shift;
	my @@l = grep {$_->{path}{has} < 2} values %{$self->{o}};
	if (!@@l) {
		@@l = values %{$self->{o}};
	}
	my $h = $self->{h};
	return [sort
	    {$h->measure($a->{path}) <=> $h->measure($b->{path})}
	    @@l];
}

package DPB::Heuristics::FetchOnlyQueue;
our @@ISA = qw(DPB::Heuristics::FetchQueue);

# for fetch-only, grab all files, largest ones first.
sub sorted_values
{
	my $self = shift;
	return [sort {$a->{sz} <=> $b->{sz}} values %{$self->{o}}];
@


1.23
log
@tweak the squiggles to prefer ports with depends, up to a point
@
text
@d2 1
a2 1
# $OpenBSD: Heuristics.pm,v 1.22 2013/09/21 08:46:07 espie Exp $
d106 1
a106 1
sub special_parameters
d111 6
d118 1
d126 1
a126 1
			return 1;
@


1.22
log
@activate squiggles(~):
based on a suggestion by naddy@@, reserve some cores on big hosts (>=4cpu)
to build the queue in reverse.

Those cores show up as ~ in the core list.
This gets rid of a large part of the exponential tail, where we spend
a lot of time waiting for locks...
@
text
@d2 1
a2 1
# $OpenBSD: Heuristics.pm,v 1.21 2013/06/21 09:05:18 espie Exp $
d285 4
a288 1
package DPB::Heuristics::ReverseSimpleSorter;
d290 5
d296 1
d300 17
a316 1
	return shift @@$self;
d424 1
a424 1
		return DPB::Heuristics::ReverseSimpleSorter->new($self);
@


1.21
log
@disentangle the config/init code from the rest.

- move the meat of handle_options from dpb into config->parse_command_line
(this means a backcall to still inherit from OpenBSD::State).
- move parse_config_files from core into config.
- move the prop handling into proper HostProperties (part of config
obviously)
- create a Core::Init file that contains all the former DPB::Host::Factory
and associated jobs.

there's still a wee little bit of cleanup to do, but this should be
easier to maintain, as all option handling is now in one place, and
startup and host confi is now easier to figure out.

- add a -DMIRROR=0/1  setup that controls whether SUPDISTFILES will be
fetched (defaults to 1 for -F and 0 for -f).

- actually allow for several host files to be parsed, as the name implies
@
text
@d2 1
a2 1
# $OpenBSD: Heuristics.pm,v 1.20 2013/05/29 09:37:17 espie Exp $
d285 9
d397 10
a406 1
	my $self = shift;
d444 1
a444 1
sub sorted
d449 1
a449 1
		return $self->SUPER::sorted($core);
@


1.20
log
@scrape redundant test
@
text
@d2 1
a2 1
# $OpenBSD: Heuristics.pm,v 1.19 2013/02/02 13:35:17 espie Exp $
d226 1
a226 1
	if (DPB::Core->has_sf) {
@


1.19
log
@move control of the "building in mfs" part under PortsBuilder/Heuristics.
Store previous pkgname.
do show-size only sporadically if fullpkgname didn't change
@
text
@d2 1
a2 1
# $OpenBSD: Heuristics.pm,v 1.18 2013/01/31 10:29:58 espie Exp $
d113 1
a113 1
	if (defined $t && defined $wrkdir{$p}) {
@


1.18
log
@wild guess at the loop
@
text
@d2 1
a2 1
# $OpenBSD: Heuristics.pm,v 1.17 2013/01/28 10:14:17 espie Exp $
d28 1
a28 1
my (%weight, %bad_weight, %wrkdir, %needed_by);
d83 1
a83 1
	my ($self, $path, $sz) = @@_;
d85 16
@


1.17
log
@tweak memory handling to make it less special: treat -M as an override_prop
as we should.
Use core methods to access the memory threshold.

UI simplification: -M can take a suffix, default is K, but you can just say
-M 520M or -M 2G now.
@
text
@d2 1
a2 1
# $OpenBSD: Heuristics.pm,v 1.16 2013/01/10 22:42:21 espie Exp $
d342 1
a342 1
	return scalar %{$self->{o}};
@


1.16
log
@make this a little bit shorter and faster.
(considering how often it's called, yes, it's worth it)
@
text
@d2 1
a2 1
# $OpenBSD: Heuristics.pm,v 1.15 2013/01/10 10:25:25 espie Exp $
a80 7
my $threshold;
sub set_threshold
{
	my ($self, $t) = @@_;
	$threshold = $t;
}

d92 3
a94 2
	my ($self, $host, $v) = @@_;
	my $t = $host->{prop}->{memory} // $threshold;
d98 1
a98 1
		my $hostname = $host->name;
@


1.15
log
@small optimization, fullpkgpath is expensive, and ordering by pkgpath is
vastly enough in the current case
@
text
@d2 1
a2 1
# $OpenBSD: Heuristics.pm,v 1.14 2012/03/09 12:51:38 espie Exp $
a174 2
	my $r = $self->measure($a) <=> $self->measure($b);
	return $r if $r != 0;
d178 2
a179 1
	return $a->pkgpath cmp $b->pkgpath;
@


1.14
log
@tweak weight handling so that fixing weights and scaling weights works.
add -m option as a reverse to -x, like in pkg_add
@
text
@d2 1
a2 1
# $OpenBSD: Heuristics.pm,v 1.13 2012/03/06 13:41:38 espie Exp $
d180 1
a180 1
	return $a->fullpkgpath cmp $b->fullpkgpath;
@


1.13
log
@fix things when we don't have any statistics to start with
@
text
@d2 1
a2 1
# $OpenBSD: Heuristics.pm,v 1.12 2012/02/17 07:35:42 espie Exp $
d128 1
d130 1
a130 1
		$weight{$v} //= $w * $v->{scaled};
d133 1
a133 1
		$weight{$v} //= $w + 0;
@


1.12
log
@allow weights to be scaled
add longer traceback in case we die
@
text
@d2 1
a2 1
# $OpenBSD: Heuristics.pm,v 1.11 2011/10/10 18:56:50 espie Exp $
a49 1
my $has_build_info;
d54 6
a59 4
	if (defined $has_build_info && $has_build_info == 1) {
		while (my ($k, $v) = each %bad_weight) {
			$self->set_weight($k, $v);
		}
a60 2
	my @@l = sort values %weight;
	$default = pop @@l;
a201 1
		$has_build_info = 2;
a203 1
		$has_build_info //= 1;
d216 1
a216 1
	if (defined $has_build_info && $has_build_info && DPB::Core->has_sf) {
@


1.11
log
@unfuck pkgpaths.
- instead of seen/unseen, have an actual constructor. Instead, mark pkgpath
for which we wantinfo/wantbuild.
- only mark EXTRA dependencies as wantinfo. So the devel/haddock,no_deps
temporary error should be gone.
- since we have FLAVOR and SUBPACKAGE available, construct as much info as
we can during vars scanning (see handle_equivalences). This avoids about 150
path rescans during a full bulk. Also, grab the timing and logsizes from
equivalent files, so that most stuff should know show % all the time.
- tweak subdirlist to be a hash, and correctly add pkgpath_and_flavors to it.
That way, we rescan avahi pseudo flavors just once, and not four or five times.
@
text
@d2 1
a2 1
# $OpenBSD: Heuristics.pm,v 1.10 2011/09/13 09:46:53 espie Exp $
d129 6
a134 1
	$weight{$v} //= $w + 0;
@


1.10
log
@beginning of a fetch-only option that is supposed to replace mirror-maker
eventually.

- fetch all files
- ignore ignores
- specific builder that doesn't look at existing packages

currently: does not stop when  fetch is finished, which is somewhat of the
remaining issue.

Also: change stats to store pid, to make sense of interleaved log files.
@
text
@d2 1
a2 1
# $OpenBSD: Heuristics.pm,v 1.9 2011/07/14 11:03:13 espie Exp $
d67 13
a79 1
	$weight{$v} //= $default;
@


1.9
log
@give a bigger weight to unknown paths
@
text
@d2 1
a2 1
# $OpenBSD: Heuristics.pm,v 1.8 2011/06/04 12:58:24 espie Exp $
d501 5
d552 10
@


1.8
log
@spaces
@
text
@d2 1
a2 1
# $OpenBSD$
d48 1
a48 1
# we set the "unknown" weight as median if we parsed a file.
d61 1
a61 1
	$default = $l[@@l/2];
@


1.7
log
@- unify code in Fetch/Build subengines
- zap heuristic#3, not critical
- don't rebuild the Fetch queue all the time, it's too expensive
- fix bugs in FetchQueue computation, correctly handle 1 distfile case
- create a quick path thru adjust* that handles only new paths.
- use it during LISTING while fetching files, to make more files available
quicker.
- model distfiles as FDEPENDS, DIST, so that they can get dumped.
- add -v option that dumps a bit more stuff in log files.

with these, dpb will fetch all distfiles in a not too surprising order,
and it won't consume 40% cpu while doing so...
@
text
@d2 1
a2 1
# $OpenBSD: Heuristics.pm,v 1.6 2011/06/01 12:34:29 espie Exp $
d504 1
a504 1
	if ($self->{results}++ > 50 || 
d544 1
a544 1
	return [sort 
@


1.6
log
@optimize heuristics for fetchqueue, as they take too much time
@
text
@d2 1
a2 1
# $OpenBSD: Heuristics.pm,v 1.5 2011/05/27 10:27:50 espie Exp $
d501 1
a501 1
sub set_h3
d503 7
a509 1
	bless shift, "DPB::Heuristics::FetchQueue3";
d520 1
a520 1
	my @@l = grep {$_->{path}{has} < 2} values %{$self->{o}};
d522 4
a525 1
		@@l = values %{$self->{o}};
d539 1
a539 1
	my @@l = grep {$_->{path}{has} == 0} values %{$self->{o}};
a546 11
}

package DPB::Heuristics::FetchQueue3;
our @@ISA = qw(DPB::Heuristics::FetchQueue);

# heuristic 3: grab the largest distfiles first, as they will take time
# to build
sub sorted_values
{
	my $self = shift;
	return [sort {$a->{sz} <=> $b->{sz}} values %{$self->{o}}];
@


1.5
log
@start moving the fetch/build code into separate subengine classes, to make
it more obvious how much is shared (goal is to unify a large part of these).

In particular, the locking code/stuff already active is glaringly the same...

Polish the distfiles measurements. For now, 3 heuristics that kick in
at various stages of the build (a bit of black magic).

Fix pkgpath->{has} to record both "no dependencies" and "several distfiles
missing" to avoid grabbing small patchfiles which don't lead to valid
builds while heuristic#1 is active.
@
text
@d2 1
a2 1
# $OpenBSD: Heuristics.pm,v 1.4 2011/05/22 08:21:39 espie Exp $
d485 5
a490 2
# heuristic 1: grab the smallest distfiles that can build directly
# so that we avoid queue starvation
d493 1
a493 11
	my $o = shift;
	$o->{compare} = sub {
		my ($h, $a, $b) = @@_;
		my $c = $b->{path}{has} <=> $a->{path}{has};
		if ($c != 0) {
			return $c;
		} else {
			return $b->{sz} <=> $a->{sz};
		}
	};
	return $o;
a495 3
# heuristic 2: assume we're running good enough, grab distfiles that allow
# build to proceed as usual
# we don't care so much about multiple distfiles
d498 1
a498 11
	my $o = shift;
	$o->{compare} = sub {
		my ($h, $a, $b) = @@_;
		my $c = ($b->{path}{has} == 2) <=> ($a->{path}{has} == 2);
		if ($c != 0) {
			return $c;
		} else {
			return $h->compare($a->{path}, $b->{path})
		}
	};
	return $o;
a500 2
# heuristic 3: grab the largest distfiles first, as they will take time
# to build
d503 16
a518 6
	my $o = shift;
	$o->{compare} = sub {
		my ($h, $a, $b) = @@_;
		return $a->{sz} <=> $b->{sz};
	};
	return $o;
d521 7
a527 1
sub new
d529 9
a537 2
	my ($class, $h) = @@_;
	$class->SUPER::new($h)->set_h1;
d540 5
d548 1
a548 2
	return [sort {&{$self->{compare}}($self->{h}, $a, $b)} 
	    values %{$self->{o}}];
@


1.4
log
@initial support for fetching distfiles, somewhat experimental yet.
- clean up clock handling, jobs with timer.
- pass more parameters thru state
- tweak the engine to handle distfiles
- lots of new code in Fetch for new jobs.
@
text
@d2 1
a2 1
# $OpenBSD: Heuristics.pm,v 1.3 2010/12/06 19:35:06 espie Exp $
a133 1
	$v = $v->representative;
d481 63
@


1.3
log
@fix fix
$build_info //= 1  indeed... ;(
@
text
@d2 1
a2 1
# $OpenBSD: Heuristics.pm,v 1.2 2010/12/06 13:19:44 espie Exp $
d32 2
a33 2
	my ($class) = @@_;
	bless {}, $class;
d134 1
d306 6
@


1.2
log
@minor warning fix
@
text
@d2 1
a2 1
# $OpenBSD: Heuristics.pm,v 1.1.1.1 2010/08/20 13:40:13 espie Exp $
d50 1
a50 1
my $has_build_info = 0;
d55 1
a55 1
	if ($has_build_info == 1) {
d202 1
a202 1
	if ($has_build_info && DPB::Core->has_sf) {
@


1.1
log
@Initial revision
@
text
@d2 1
a2 1
# $OpenBSD: Heuristics.pm,v 1.6 2010/05/04 09:45:41 espie Exp $
d50 1
a50 1
my $has_build_info;
@


1.1.1.1
log
@move stuff here from infra/build
@
text
@@
