head	1.12;
access;
symbols
	OPENBSD_6_2:1.12.0.6
	OPENBSD_6_2_BASE:1.12
	OPENBSD_6_1:1.12.0.4
	OPENBSD_6_1_BASE:1.12
	OPENBSD_6_0:1.12.0.2
	OPENBSD_6_0_BASE:1.12
	OPENBSD_5_9:1.8.0.2
	OPENBSD_5_9_BASE:1.8
	OPENBSD_5_8:1.7.0.8
	OPENBSD_5_8_BASE:1.7
	OPENBSD_5_7:1.7.0.4
	OPENBSD_5_7_BASE:1.7
	OPENBSD_5_6:1.7.0.2
	OPENBSD_5_6_BASE:1.7
	OPENBSD_5_5:1.5.0.2
	OPENBSD_5_5_BASE:1.5;
locks; strict;
comment	@# @;


1.12
date	2016.06.28.15.28.20;	author espie;	state Exp;
branches;
next	1.11;
commitid	vwMZvbsIdSgs6ITN;

1.11
date	2016.06.24.12.52.12;	author espie;	state Exp;
branches;
next	1.10;
commitid	xm1njZ1KrSEciTBT;

1.10
date	2016.05.14.18.14.27;	author espie;	state Exp;
branches;
next	1.9;
commitid	g8QreVUPpxnZ5cW6;

1.9
date	2016.05.13.08.32.17;	author espie;	state Exp;
branches;
next	1.8;
commitid	qawIqmyA3PF15mfz;

1.8
date	2015.10.31.09.39.20;	author espie;	state Exp;
branches;
next	1.7;
commitid	ZRcHlBgfOeRxAQHo;

1.7
date	2014.03.09.20.31.04;	author espie;	state Exp;
branches;
next	1.6;

1.6
date	2014.03.09.20.04.57;	author espie;	state Exp;
branches;
next	1.5;

1.5
date	2013.10.15.16.02.08;	author espie;	state Exp;
branches;
next	1.4;

1.4
date	2013.10.13.19.19.53;	author espie;	state Exp;
branches;
next	1.3;

1.3
date	2013.10.13.18.32.58;	author espie;	state Exp;
branches;
next	1.2;

1.2
date	2013.10.06.13.33.33;	author espie;	state Exp;
branches;
next	1.1;

1.1
date	2013.10.02.09.02.40;	author espie;	state Exp;
branches;
next	;


desc
@@


1.12
log
@reuse base window detection code and signal handler (requires fairly recent
base code)
@
text
@# ex:ts=8 sw=4:
# $OpenBSD: MiniCurses.pm,v 1.11 2016/06/24 12:52:12 espie Exp $
#
# Copyright (c) 2010-2013 Marc Espie <espie@@openbsd.org>
#
# Permission to use, copy, modify, and distribute this software for any
# purpose with or without fee is hereby granted, provided that the above
# copyright notice and this permission notice appear in all copies.
#
# THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
# ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
# OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
use strict;
use warnings;

package DPB::MiniCurses;
use Term::Cap;
use Term::ReadKey;
use constant { 
	BLACK => 0,
	RED => 1,
	GREEN => 2,
	YELLOW => 3,
	BLUE => 4,
	PURPLE => 5,
	TURQUOISE => 6,
	WHITE => 7 };

sub term_send
{
	my ($self, $seq) = @@_;
	$self->{terminal}->Tputs($seq, 1, \*STDOUT);
}

sub refresh
{
	my $self = shift;
	$self->{write} = 'go_write_home';
	$self->{force} = 1;
}

sub handle_window
{
	my $self = shift;
	$self->refresh;
}

sub width
{
	my $self = shift;
	return $self->{state}->width;
}

sub height
{
	my $self = shift;
	return $self->{state}->height;
}

sub create_terminal
{
	my $self = shift;
	my $oldfh = select(STDOUT);
	$| = 1;
	# XXX go back to totally non-buffered raw shit
	binmode(STDOUT, ':pop');
	select($oldfh);
	use POSIX;
	my $termios = POSIX::Termios->new;
	$termios->getattr(0);
	$self->{terminal} = Term::Cap->Tgetent({ OSPEED =>
	    $termios->getospeed });
	$self->{home} = $self->{terminal}->Tputs("ho", 1);
	$self->{clear} = $self->{terminal}->Tputs("cl", 1);
	$self->{down} = $self->{terminal}->Tputs("do", 1);
	$self->{glitch} = exists $self->{terminal}{_xn};
	$self->{cleareol} = $self->{terminal}->Tputs("ce", 1);
	if ($self->{state}{color}) {
		$self->{bg} = $self->{terminal}->Tputs('AB', 1);
		$self->{fg} = $self->{terminal}->Tputs('AF', 1);
		$self->{blink} = $self->{terminal}->Tputs('mb', 1);
		$self->{dontblink} = $self->{terminal}->Tputs('me', 1);
	}
	if ($self->{state}{nocursor}) {
		$self->{invisible} = 
		    $self->{terminal}->Tputs("vi", 1);
		$self->{visible} = 
		    $self->{terminal}->Tputs("ve", 1);
	}
	if ($self->{home}) {
		$self->{write} = "go_write_home";
	} else {
		$self->{write} = "write_clear";
	}
}

sub write_clear
{
	my ($self, $msg) = @@_;
	my $r = $self->{clear};
	$self->{oldlines} = [$self->cut_lines($msg)];
	my $n = 2;
	for my $line (@@{$self->{oldlines}}) {
		last if $n++ > $self->height;
		$r .= $self->clamped($line);
	}
	print $r;
}

sub cut_lines
{
	my ($self, $msg) = @@_;
	my @@lines = ();
	for my $line (split("\n", $msg)) {
		while (length $line > $self->width) {
			push(@@lines, substr($line, 0, $self->width));
			$line = substr($line, $self->width);
		}
		push(@@lines, $line);
	}
	return @@lines;
}

sub default_fg
{
	my ($self, $color) = @@_;
	$self->{resetfg} = sprintf($self->{fg}, $color);
}

sub default_bg
{
	my ($self, $color) = @@_;
	$self->{resetbg} = sprintf($self->{bg}, $color);
}
sub color
{
	my ($self, $expr, $color) = @@_;
	return sprintf($self->{fg}, $color).$expr.$self->{resetfg};
}

sub bg
{
	my ($self, $expr, $color) = @@_;
	return sprintf($self->{bg}, $color).$expr.$self->{resetbg};
}

sub blink
{
	my ($self, $expr, $color) = @@_;
	return $self->{blink}.$expr.$self->{dontblink};
}

sub mogrify
{
	my ($self, $line) = @@_;
	my $percent = PURPLE;
	$self->default_bg(BLACK);
	$self->default_fg(WHITE);
	if ($line =~ m/waiting-for-lock/) {
		$line = $self->color($line, BLUE);
		$self->default_fg(BLUE);
	} elsif ($line =~ m/frozen/) {
		if ($line =~ m/for\s+\d+\s*(mn|HOURS)/) {
			$line = $self->bg($self->color($line, BLACK), RED);
			$self->default_bg(RED);
			$self->default_fg(BLACK);
			$percent = WHITE;
		} else {
			$line = $self->color($line, RED);
			$self->default_fg(RED);
		}
	} elsif ($line =~ m/^\</) {
		$line = $self->color($line, TURQUOISE);
		$self->default_fg(TURQUOISE);
	} elsif ($line =~ m/^(LISTING|UPDATING)/) {
		$line = $self->bg($self->color($line, WHITE), BLUE);
		$self->default_bg(BLUE);
		$self->default_fg(WHITE);
	} elsif ($line =~ m/^I=/) {
		$line = $self->bg($self->color($line, WHITE), BLUE);
	} elsif ($line =~ m/^E=/) {
		$line = $self->color($line, RED);
		$self->default_fg(RED);
	} elsif ($line =~ m/^Hosts:/) {
		$line =~ s/([\@@\w\.\-]*[\@@\w.])(\s|\(|$)/$self->color($1, RED).$2/ge;
		$line =~ s/([\@@\w\.\-]+\-)(\s|\(|$)/$self->blink($self->bg($self->color($1, BLACK), RED)).$2/ge;
		$line =~ s/(^Hosts:)/$self->color($1, BLUE)/ge;
	}
	$line =~ s/(\[\d+\])/$self->color($1, GREEN)/ge;
	$line =~ s/(\(.*?\))/$self->color($1, YELLOW)/ge;
	$line =~ s/(\d+\%)/$self->color($1, $percent)/ge;
	return $line;
}

sub clamped
{
	my ($self, $line) = @@_;
	my $l2 = $line;
	if (defined $self->{fg}) {
		$l2 = $self->mogrify($l2);
	}
	if (!$self->{glitch} && length $line == $self->width) {
		return $l2;
	} else {
		return $l2."\n";
	}
}

sub clear_clamped
{
	my ($self, $line) = @@_;
	my $l2 = $line;
	if (defined $self->{fg}) {
		$l2 = $self->mogrify($l2);
	}
	if (!$self->{glitch} && length $line == $self->width) {
		return $l2;
	} else {
		return $self->{cleareol}.$l2."\n";
	}
}

sub do_line
{
	my ($self, $new, $old) = @@_;
	# line didn't change: try to go down
	if (defined $old && $old eq $new) {
		if ($self->{down}) {
			return $self->{down};
		}
	}
	# adjust newline to correct length
	if (defined $old && (length $old) > (length $new)) {
		if ($self->{cleareol}) {
			return $self->clear_clamped($new);
		}
		$new .= " "x ((length $old) - (length $new));
	}
	return $self->clamped($new);
}

sub lines
{
	my ($self, @@new) = @@_;

	my $n = 2;
	my $r = '';

	while (@@new > 0) {
		return $r if $n++ > $self->height;
		$r .= $self->do_line(shift @@new, shift @@{$self->{oldlines}});
	}
	# extra lines must disappear
	while (@@{$self->{oldlines}} > 0) {
		my $line = shift @@{$self->{oldlines}};
		if ($self->{cleareol}) {
			$r .= $self->clear_clamped('');
		} else {
			$line = " "x (length $line);
			$r .= $self->clamped($line);
		}
		last if $n++ > $self->height;
	}
	return $r;
}

sub write_home
{
	my ($self, $msg) = @@_;
	my @@new = $self->cut_lines($msg);
	print $self->{home}.$self->lines(@@new);
	$self->{oldlines} = \@@new;
}

sub go_write_home
{
	# first report has to clear the screen
	my ($self, $msg) = @@_;
	$self->write_clear($msg);
	$self->{write} = 'write_home';
}

1;
@


1.11
log
@keep state around in Reporter, simplifies terminal initialization,
and will be need to access size information
@
text
@d2 1
a2 1
# $OpenBSD: MiniCurses.pm,v 1.10 2016/05/14 18:14:27 espie Exp $
a32 13
sub find_window_size
{
	my $self = shift;
	my @@l = Term::ReadKey::GetTermSizeGWINSZ(\*STDOUT);
	if (@@l != 4) {
		$self->{width} = 80;
		$self->{height} = 24;
	} else {
		$self->{width} = $l[0];
		$self->{height} = $l[1];
	}
}

a48 1
	$self->find_window_size;
d52 12
a76 1
	$self->find_window_size;
d108 1
a108 1
		last if $n++ > $self->{height};
d119 3
a121 3
		while (length $line > $self->{width}) {
			push(@@lines, substr($line, 0, $self->{width}));
			$line = substr($line, $self->{width});
d206 1
a206 1
	if (!$self->{glitch} && length $line == $self->{width}) {
d220 1
a220 1
	if (!$self->{glitch} && length $line == $self->{width}) {
d254 1
a254 1
		return $r if $n++ > $self->{height};
d266 1
a266 1
		last if $n++ > $self->{height};
@


1.10
log
@just check for xn capability presence, don't try to Tputs it,
that doesn't work.
should fix some display glitches under tmux
@
text
@d2 1
a2 1
# $OpenBSD: MiniCurses.pm,v 1.9 2016/05/13 08:32:17 espie Exp $
d68 1
a68 1
	my ($self, $o) = @@_;
d85 1
a85 1
	if ($o->{color}) {
d91 1
a91 1
	if ($o->{nocursor}) {
@


1.9
log
@rely on Term::ReadKey here as well
@
text
@d2 1
a2 1
# $OpenBSD: MiniCurses.pm,v 1.8 2015/10/31 09:39:20 espie Exp $
d83 1
a83 1
	$self->{glitch} = $self->{terminal}->Tputs("xn", 1);
@


1.8
log
@don't blink or you'll miss it (not any more)
display down hosts in a rather more prominent manner.
antoine likes it, landry doesn't give a shit.
@
text
@d2 1
a2 1
# $OpenBSD: MiniCurses.pm,v 1.7 2014/03/09 20:31:04 espie Exp $
d22 1
a32 4
my $width;
my $wsz_format = 'SSSS';
our %sizeof;

d36 7
a42 11
	# try to get exact window width
	my $r;
	$r = pack($wsz_format, 0, 0, 0, 0);
	$sizeof{'struct winsize'} = 8;
	require 'sys/ttycom.ph';
	$width = 80;
	if (ioctl(STDOUT, &TIOCGWINSZ, $r)) {
		my ($rows, $cols, $xpix, $ypix) =
		    unpack($wsz_format, $r);
		$self->{width} = $cols;
		$self->{height} = $rows;
@


1.7
log
@well, root@@echo is a valid hostname
@
text
@d2 1
a2 1
# $OpenBSD: MiniCurses.pm,v 1.6 2014/03/09 20:04:57 espie Exp $
d95 2
d161 6
d199 2
a200 1
		$line =~ s/([\@@\w\.\-]+)(\s|\(|$)/$self->color($1, RED).$2/ge;
@


1.6
log
@color tweaks:
- use blue for "waiting-for-lock"
- make "frozen" actually readable (black on red, change percent
from purple to white)
- fix host names.
@
text
@d2 1
a2 1
# $OpenBSD: MiniCurses.pm,v 1.5 2013/10/15 16:02:08 espie Exp $
d191 1
a191 1
		$line =~ s/([\w\.\-]+)(\s|\(|$)/$self->color($1, RED).$2/ge;
@


1.5
log
@make window resize visible for dpb-replay
@
text
@d2 1
a2 1
# $OpenBSD: MiniCurses.pm,v 1.4 2013/10/13 19:19:53 espie Exp $
d162 1
d165 4
a168 1
	if ($line =~ m/frozen|waiting-for-lock/) {
d170 1
a170 1
			$line = $self->bg($self->color($line, GREEN), RED);
d172 2
a173 1
			$self->default_fg(GREEN);
d191 2
a192 1
		$line =~ s/(\w+\-)/$self->color($1, RED)/ge;
d196 1
a196 1
	$line =~ s/(\d+\%)/$self->color($1, PURPLE)/ge;
@


1.4
log
@slightly more intricate hack, better colors, that span full lines when they're
supposed to...
@
text
@d2 1
a2 1
# $OpenBSD: MiniCurses.pm,v 1.3 2013/10/13 18:32:58 espie Exp $
d64 7
@


1.3
log
@add optional colors with -DCOLOR.
@
text
@d2 1
a2 1
# $OpenBSD: MiniCurses.pm,v 1.2 2013/10/06 13:33:33 espie Exp $
d129 11
d143 1
a143 1
	return sprintf($self->{fg}, $color).$expr.sprintf($self->{fg}, WHITE);
d149 1
a149 1
	return sprintf($self->{bg}, $color).$expr.sprintf($self->{bg}, BLACK);
d155 2
a156 3
	$line =~ s/(\[.*?\])/$self->color($1, GREEN)/ge;
	$line =~ s/(\(.*?\))/$self->color($1, YELLOW)/ge;
	$line =~ s/(\d+\%)/$self->color($1, PURPLE)/ge;
d160 2
d164 1
d168 1
d170 3
a172 1
		$line = $self->bg($self->color($line, BLUE), RED);
d174 1
a174 1
		$line = $self->bg($self->color($line, YELLOW), BLUE);
d177 1
d181 3
@


1.2
log
@update my copyright to 2013
@
text
@d2 1
a2 1
# $OpenBSD: reporter.pm,v 1.20 2013/09/30 19:08:35 espie exp $
d22 9
d68 1
a68 1
	my $self = shift;
d85 10
d129 38
d170 4
d175 1
a175 1
		return $line;
d177 1
a177 1
		return $line."\n";
d184 4
d189 1
a189 1
		return $line;
d191 1
a191 1
		return $self->{cleareol}.$line."\n";
@


1.1
log
@split off most of the term display code to be able to reuse it
@
text
@d2 1
a2 1
# $openbsd: reporter.pm,v 1.20 2013/09/30 19:08:35 espie exp $
d4 1
a4 1
# copyright (c) 2010 marc espie <espie@@openbsd.org>
d6 1
a6 1
# permission to use, copy, modify, and distribute this software for any
d10 7
a16 7
# the software is provided "as is" and the author disclaims all warranties
# with regard to this software including all implied warranties of
# merchantability and fitness. in no event shall the author be liable for
# any special, direct, indirect, or consequential damages or any damages
# whatsoever resulting from loss of use, data or profits, whether in an
# action of contract, negligence or other tortious action, arising out of
# or in connection with the use or performance of this software.
@

