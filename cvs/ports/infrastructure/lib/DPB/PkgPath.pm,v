head	1.51;
access;
symbols
	OPENBSD_6_1:1.51.0.8
	OPENBSD_6_1_BASE:1.51
	OPENBSD_6_0:1.51.0.6
	OPENBSD_6_0_BASE:1.51
	OPENBSD_5_9:1.51.0.2
	OPENBSD_5_9_BASE:1.51
	OPENBSD_5_8:1.51.0.4
	OPENBSD_5_8_BASE:1.51
	OPENBSD_5_7:1.47.0.2
	OPENBSD_5_7_BASE:1.47
	OPENBSD_5_6:1.45.0.4
	OPENBSD_5_6_BASE:1.45
	OPENBSD_5_5:1.45.0.2
	OPENBSD_5_5_BASE:1.45
	OPENBSD_5_4:1.41.0.2
	OPENBSD_5_4_BASE:1.41
	OPENBSD_5_3:1.36.0.2
	OPENBSD_5_3_BASE:1.36
	OPENBSD_5_2:1.32.0.2
	OPENBSD_5_2_BASE:1.32
	OPENBSD_5_1_BASE:1.26
	OPENBSD_5_1:1.26.0.2
	OPENBSD_5_0:1.10.0.2
	OPENBSD_5_0_BASE:1.10
	OPENBSD_4_9:1.2.0.2
	OPENBSD_4_9_BASE:1.2
	ports:1.1.1.1
	espie:1.1.1;
locks; strict;
comment	@# @;


1.51
date	2015.07.02.08.04.22;	author espie;	state Exp;
branches;
next	1.50;
commitid	qIlv6BM85gcmoVOI;

1.50
date	2015.06.11.08.42.38;	author espie;	state Exp;
branches;
next	1.49;
commitid	ekCbOseoc88M9I00;

1.49
date	2015.05.10.08.14.14;	author espie;	state Exp;
branches;
next	1.48;
commitid	J9XuZmxJc7sLMZLF;

1.48
date	2015.04.25.11.25.08;	author espie;	state Exp;
branches;
next	1.47;
commitid	3PU9flzKPY2QfsBN;

1.47
date	2014.12.07.15.18.50;	author espie;	state Exp;
branches;
next	1.46;
commitid	GynqjLfrNHwgIuss;

1.46
date	2014.12.06.17.39.21;	author espie;	state Exp;
branches;
next	1.45;
commitid	or5kgMUgTAr0i8yC;

1.45
date	2013.11.12.22.11.50;	author espie;	state Exp;
branches;
next	1.44;

1.44
date	2013.10.19.09.33.52;	author espie;	state Exp;
branches;
next	1.43;

1.43
date	2013.10.19.09.07.49;	author espie;	state Exp;
branches;
next	1.42;

1.42
date	2013.10.06.13.33.33;	author espie;	state Exp;
branches;
next	1.41;

1.41
date	2013.06.25.20.21.52;	author espie;	state Exp;
branches;
next	1.40;

1.40
date	2013.06.25.09.05.19;	author espie;	state Exp;
branches;
next	1.39;

1.39
date	2013.04.22.11.14.17;	author espie;	state Exp;
branches;
next	1.38;

1.38
date	2013.04.22.10.06.12;	author espie;	state Exp;
branches;
next	1.37;

1.37
date	2013.04.13.10.04.43;	author espie;	state Exp;
branches;
next	1.36;

1.36
date	2012.12.24.17.24.46;	author espie;	state Exp;
branches;
next	1.35;

1.35
date	2012.10.11.17.35.19;	author espie;	state Exp;
branches;
next	1.34;

1.34
date	2012.10.11.07.38.39;	author espie;	state Exp;
branches;
next	1.33;

1.33
date	2012.08.22.07.49.00;	author espie;	state Exp;
branches;
next	1.32;

1.32
date	2012.07.18.10.30.56;	author espie;	state Exp;
branches;
next	1.31;

1.31
date	2012.07.10.09.38.37;	author espie;	state Exp;
branches;
next	1.30;

1.30
date	2012.05.16.08.22.22;	author espie;	state Exp;
branches;
next	1.29;

1.29
date	2012.05.15.10.10.13;	author espie;	state Exp;
branches;
next	1.28;

1.28
date	2012.03.13.16.48.47;	author espie;	state Exp;
branches;
next	1.27;

1.27
date	2012.02.23.21.42.23;	author espie;	state Exp;
branches;
next	1.26;

1.26
date	2012.01.29.12.02.20;	author espie;	state Exp;
branches;
next	1.25;

1.25
date	2012.01.14.12.26.21;	author espie;	state Exp;
branches;
next	1.24;

1.24
date	2011.12.11.19.55.37;	author espie;	state Exp;
branches;
next	1.23;

1.23
date	2011.12.02.11.40.25;	author espie;	state Exp;
branches;
next	1.22;

1.22
date	2011.11.22.16.44.53;	author espie;	state Exp;
branches;
next	1.21;

1.21
date	2011.11.13.22.18.04;	author espie;	state Exp;
branches;
next	1.20;

1.20
date	2011.11.08.10.26.38;	author espie;	state Exp;
branches;
next	1.19;

1.19
date	2011.11.08.09.07.24;	author espie;	state Exp;
branches;
next	1.18;

1.18
date	2011.11.07.16.03.19;	author espie;	state Exp;
branches;
next	1.17;

1.17
date	2011.11.07.13.23.09;	author espie;	state Exp;
branches;
next	1.16;

1.16
date	2011.11.06.12.21.07;	author espie;	state Exp;
branches;
next	1.15;

1.15
date	2011.11.05.18.25.36;	author espie;	state Exp;
branches;
next	1.14;

1.14
date	2011.10.11.13.43.25;	author espie;	state Exp;
branches;
next	1.13;

1.13
date	2011.10.10.18.56.50;	author espie;	state Exp;
branches;
next	1.12;

1.12
date	2011.10.03.08.56.40;	author espie;	state Exp;
branches;
next	1.11;

1.11
date	2011.09.27.17.15.03;	author espie;	state Exp;
branches;
next	1.10;

1.10
date	2011.06.15.10.09.31;	author espie;	state Exp;
branches;
next	1.9;

1.9
date	2011.06.04.12.56.54;	author espie;	state Exp;
branches;
next	1.8;

1.8
date	2011.06.02.17.09.25;	author espie;	state Exp;
branches;
next	1.7;

1.7
date	2011.06.01.15.39.47;	author espie;	state Exp;
branches;
next	1.6;

1.6
date	2011.05.28.19.32.59;	author espie;	state Exp;
branches;
next	1.5;

1.5
date	2011.05.27.10.27.50;	author espie;	state Exp;
branches;
next	1.4;

1.4
date	2011.05.22.08.21.39;	author espie;	state Exp;
branches;
next	1.3;

1.3
date	2011.03.22.19.48.53;	author espie;	state Exp;
branches;
next	1.2;

1.2
date	2010.10.26.15.45.09;	author espie;	state Exp;
branches;
next	1.1;

1.1
date	2010.08.20.13.40.13;	author espie;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2010.08.20.13.40.13;	author espie;	state Exp;
branches;
next	;


desc
@@


1.51
log
@clean-up "force junking": do not prepare a host to be untainted with the
"wrong" port, but instead, create a pseudo-path that is just there to run
junk (will be logged as junk-proxy)

fix a bug in the task handling host locking (no next task -> unlock, duh).

do not log multiple K for several ports on the same basepkgpath.
@
text
@# ex:ts=8 sw=4:
# $OpenBSD: PkgPath.pm,v 1.50 2015/06/11 08:42:38 espie Exp $
#
# Copyright (c) 2010-2013 Marc Espie <espie@@openbsd.org>
#
# Permission to use, copy, modify, and distribute this software for any
# purpose with or without fee is hereby granted, provided that the above
# copyright notice and this permission notice appear in all copies.
#
# THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
# ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
# OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
use strict;
use warnings;

# Handles PkgPath;
# all this code is *seriously* dependent on unique objects
# everything is done to normalize PkgPaths, so that we have
# one pkgpath object for each distinct flavor/subpackage combination

use DPB::BasePkgPath;
use DPB::Util;

package DPB::PkgPath;
our @@ISA = qw(DPB::BasePkgPath);

sub init
{
	my $self = shift;
	# XXX
	$self->{has} = 5;
}

sub forcejunk
{
	return 0;
}

sub path
{
	my $self = shift;
	return $self;
}

sub clone_properties
{
	my ($n, $o) = @@_;
	$n->{has} //= $o->{has};
	$n->{info} //= $o->{info};
}

sub sanity_check
{
	my ($class, $state) = @@_;

	my $quicklog = $state->logger->append('equiv');
	for my $p ($class->seen) {
		next if defined $p->{category};
		next unless defined $p->{info};
		for my $w ($p->build_path_list) {
			if (!defined $w->{info}) {
				print $quicklog $w->fullpkgpath, 
				    " has no info(", $p->fullpkgpath, ")\n";
				$w->{info} = DPB::PortInfo->stub;
			} elsif (!defined $w->{info}{FULLPKGNAME}) {
				print $quicklog $w->fullpkgpath,
				    " has no fullpkgname(", 
				    $p->fullpkgpath, ")\n";
				$w->{info} = DPB::PortInfo->stub;
			}
		}
	}
}

# XXX All this code knows too much about PortInfo for proper OO

sub fullpkgname
{
	my $self = shift;
	if (defined $self->{info} && defined $self->{info}{FULLPKGNAME}) {
		return ${$self->{info}{FULLPKGNAME}};
	} else {
		DPB::Util->die(
		    $self->fullpkgpath." has no associated fullpkgname", 
		    $self->{info});
	}
}

sub has_fullpkgname
{
	my $self = shift;
	return defined $self->{info} && defined $self->{info}{FULLPKGNAME};
}

# requires flavor as a hash
sub flavor
{
	my $self = shift;
	return $self->{info}{FLAVOR};
}

sub subpackage
{
	my $self = shift;
	if (defined $self->{info} && defined $self->{info}{SUBPACKAGE}) {
		return ${$self->{info}{SUBPACKAGE}};
	} else {
		return undef;
	}
}

sub dump
{
	my ($self, $fh) = @@_;
	print $fh $self->fullpkgpath, "\n";
	if (defined $self->{info}) {
		$self->{info}->dump($fh);
	}
}

sub quick_dump
{
	my ($self, $fh) = @@_;
	print $fh $self->fullpkgpath, "\n";
	if (defined $self->{info}) {
		$self->{info}->quick_dump($fh);
	}
}

# interface with logger/lock engine
sub logname
{
	my $self = shift;
	return $self->fullpkgpath;
}

sub lockname
{
	my $self = shift;
	return $self->pkgpath;
}

sub print_parent
{
	my ($self, $fh) = @@_;
	if (defined $self->{parent}) {
		print $fh "parent=", $self->{parent}->logname, "\n";
	}
}

sub unlock_conditions
{
	my ($v, $engine) = @@_;
	return $v->{info} && $engine->{buildable}{builder}->check($v);
}

sub requeue
{
	my ($v, $engine) = @@_;
	$engine->requeue($v);
}

sub simplifies_to
{
	my ($self, $simpler, $state) = @@_;
	$state->{affinity}->simplifies_to($self, $simpler);
	my $quicklog = $state->logger->append('equiv');
	print $quicklog $self->fullpkgpath, " -> ", $simpler->fullpkgpath, "\n";
}

sub equates
{
	my ($class, $h) = @@_;
	DPB::Job::Port->equates($h);
	DPB::Heuristics->equates($h);
}

# in the MULTI_PACKAGES case, some stuff may need to be forcibly removed
sub fix_multi
{
	my ($class, $h) = @@_;

	my $multi;
	my $may_vanish;
	my $path;
	for my $v (values %$h) {
		$path //= $v; # one for later
		my $info = $v->{info};
		# share !
		if (defined $info->{BUILD_PACKAGES}) {
			$multi = $info->{BUILD_PACKAGES};
		}
		# and this one is special
		if (defined $info->{MULTI_PACKAGES}) {
			$may_vanish = $info->{MULTI_PACKAGES};
		}
	}
	# in case BUILD_PACKAGES "erases" some multi, we need to
	# stub out the correspond paths, so that dependent ports
	# will vanish
	if (defined $may_vanish) {
		for my $m (keys %$may_vanish) {
			# okay those are actually present
			next if exists $multi->{$m};

			# make a dummy path that will get ignored
			my $stem = $path->pkgpath_and_flavors;
			my $w = DPB::PkgPath->new("$stem,$m");
			if (!defined $w->{info}) {
				$w->{info} = DPB::PortInfo->new($w);
				$w->{info}->stub_name;
			}
			#delete $w->{info}->{IGNORE};
			if (!defined $w->{info}->{IGNORE}) {
				$w->{info}->add('IGNORE', 
				    "vanishes from BUILD_PACKAGES");
			}
			$h->{$w} = $w;
		}
	}
	if (defined $multi) {
		for my $v (values %$h) {
			$v->{info}{BUILD_PACKAGES} = $multi;
		}
	}
}

# we're always called from values corresponding to the same subdir.
sub merge_depends
{
	my ($class, $h) = @@_;

	$class->fix_multi($h);

	my $global = bless {}, "AddDepends";
	my $global2 = bless {}, "AddDepends";
	my $global3 = bless {}, "AddDepends";
	my $global4 = bless {}, "AddDepends";
	for my $v (values %$h) {
		my $info = $v->{info};

		# let's allow doing that even for ignore'd stuff so
		# that dpb -F will work
		if (defined $info->{DIST} && !defined $info->{DISTIGNORE}) {
			for my $f (values %{$info->{DIST}}) {
				$info->{FDEPENDS}{$f} = $f;
				bless $info->{FDEPENDS}, "AddDepends";
			}
		}
		# XXX don't grab dependencies for IGNOREd stuff
		next if defined $info->{IGNORE};

		for my $k (qw(LIB_DEPENDS BUILD_DEPENDS)) {
			if (defined $info->{$k}) {
				for my $d (values %{$info->{$k}}) {
					# filter these out like during build
					# simpler to figure out logs from 
					# depends stage that way.
					$d->{wantbuild} = 1;
					next if $d->pkgpath_and_flavors eq 
					    $v->pkgpath_and_flavors;
					$global->{$d} = $d;
				}
			}
		}
		for my $k (qw(LIB_DEPENDS RUN_DEPENDS)) {
			if (defined $info->{$k}) {
				for my $d (values %{$info->{$k}}) {
					$d->{wantbuild} = 1;
					$info->{RDEPENDS}{$d} = $d;
					bless $info->{RDEPENDS}, "AddDepends";
				}
			}
		}
		if (defined $info->{EXTRA}) {
			for my $d (values %{$info->{EXTRA}}) {
				$global3->{$d} = $d;
				$d->{wantinfo} = 1;
			}
	    	}
			
		for my $k (qw(LIB_DEPENDS BUILD_DEPENDS RUN_DEPENDS 
		    SUBPACKAGE FLAVOR EXTRA PERMIT_DISTFILES_FTP 
		    MULTI_PACKAGES PERMIT_DISTFILES_CDROM)) {
			delete $info->{$k};
		}
	}
	if (values %$global > 0) {
		for my $v (values %$h) {
			# remove stuff that depends on itself
			delete $global->{$v};
			$v->{info}{DEPENDS} = $global;
			$v->{info}{BDEPENDS} = $global2;
		}
	}
	if (values %$global3 > 0) {
		for my $v (values %$h) {
			$v->{info}{EXTRA} = $global3;
			$v->{info}{BEXTRA} = $global4;
		}
	}
}

sub build_path_list
{
	my ($v) = @@_;
	my @@l = ($v);
	my $stem = $v->pkgpath_and_flavors;
	my $w = DPB::PkgPath->new($stem);
	if ($w ne $v) {
		push(@@l, $w);
	}
	if (defined $v->{info}) {
		for my $m (keys %{$v->{info}{BUILD_PACKAGES}}) {
			next if $m eq '-';
			my $w = DPB::PkgPath->new("$stem,$m");
			if ($w ne $v) {
				push(@@l, $w);
			}
		}
	}
	return @@l;
}

sub break
{

	my ($self, $why) = @@_;
	if (defined $self->{broken}) {
		$self->{broken} .= " $why";
	} else {
		$self->{broken} = $why;
	}
}

1;
@


1.50
log
@handle distfile failure better.
- we do rescan paths anyway, so make sure we queue only path.
- forgetting distfile details does not get around caching, so do creation
of distfiles in two times. cache is there to ensure unique distfiles, and
we can still forget details.
To do: remove distfiles from queue during forget, because there's no longer
any detail there.
@
text
@d2 1
a2 1
# $OpenBSD: PkgPath.pm,v 1.49 2015/05/10 08:14:14 espie Exp $
d36 5
@


1.49
log
@rename logger interface to desambiguate vs user.
@
text
@d2 1
a2 1
# $OpenBSD: PkgPath.pm,v 1.48 2015/04/25 11:25:08 espie Exp $
d36 6
@


1.48
log
@don't bypass the logger method
@
text
@d2 1
a2 1
# $OpenBSD: PkgPath.pm,v 1.47 2014/12/07 15:18:50 espie Exp $
d49 1
a49 1
	my $quicklog = $state->logger->open('equiv');
d160 1
a160 1
	my $quicklog = $state->logger->open('equiv');
@


1.47
log
@wrap die so that it drops into the debugger if we run under perl -d.

change the way we do rescans again, to avoid race conditions:
just store away *all* pkgpaths related to the rescan (so that multi-packages
are covered) and then do the rescan. Hold those like we do for normal locks
but in a different list, and release them when the scan is over.

remove the atrocious shennanigans wrt fullpkgnames, it shouldn't be needed
again, hopefully.
@
text
@d2 1
a2 1
# $OpenBSD: PkgPath.pm,v 1.46 2014/12/06 17:39:21 espie Exp $
d49 1
a49 1
	open my $quicklog, '>>', $state->logger->logfile('equiv');
d160 1
a160 1
	open my $quicklog, '>>', $state->logger->logfile('equiv');
@


1.46
log
@before dying, set DB::single... if we're running under the debugger, we get
a chance to catch up.
@
text
@d2 1
a2 1
# $OpenBSD: PkgPath.pm,v 1.45 2013/11/12 22:11:50 espie Exp $
a18 1
use feature qw(say);
d26 1
a73 1
		delete $self->{tmpname};
a74 2
	} elsif (defined $self->{tmpname}) {
		return $self->{tmpname};
d76 3
a78 16
		say STDERR $self->fullpkgpath, " has no associated fullpkgname\n";
		if (defined $self->{info}) {
			say STDERR "But info is defined"; 
			require Data::Dumper;
			say STDERR Data::Dumper::Dumper($self->{info});
		}
		$DB::single = 1;
		die;
	}
}

sub ensure_fullpkgname
{
	my $self = shift;
	if (!defined $self->{tmpname} && $self->has_fullpkgname) {
		$self->{tmpname} = $self->fullpkgname;
@


1.45
log
@redo the discovery of tree yet once again, after issues found out by naddy@@
following the bsd.port.arch.mk change. Suddenly, some paths make their way
into the build where they should not !

This actually comes from setting up wantbuild/wantinfo straight when building
path lists.

So reorganize stuff:
- don't ask for more scans during straight dump-vars reading.
- perform the "BUILD_PACKAGES may vanish from MULTI_PACKAGES" early in
merge_depends.
- do add appropriate wantbuild/wantinfo during actual dependency registration
there, which ensures depends that got ignored will be built.

This should restore proper behavior and fix long-standing semi-random
behavior.
@
text
@d2 1
a2 1
# $OpenBSD: PkgPath.pm,v 1.44 2013/10/19 09:33:52 espie Exp $
d85 1
@


1.44
log
@isolate dirty details of fullpkgname remanence in its own function,
and fix a stupid bug.
@
text
@d2 1
a2 1
# $OpenBSD: PkgPath.pm,v 1.43 2013/10/19 09:07:49 espie Exp $
d186 50
d240 3
a246 3
	my $multi;
	my $extra;
	my $path;
a247 1
		$path //= $v; # one for later
d249 3
a257 8
		# share !
		if (defined $info->{BUILD_PACKAGES}) {
			$multi = $info->{BUILD_PACKAGES};
		}
		# and this one is special
		if (defined $info->{MULTI_PACKAGES}) {
			$extra = $info->{MULTI_PACKAGES};
		}
d267 1
d277 1
d286 1
a307 28
		}
	}
	if (defined $multi) {
		for my $v (values %$h) {
			$v->{info}{BUILD_PACKAGES} = $multi;
		}
	}
	# in case BUILD_PACKAGES "erases" some multi, we need to
	# stub out the correspond paths, so that dependent ports
	# will vanish
	if (defined $extra) {
		for my $m (keys %$extra) {
			# okay those are present

			next if exists $multi->{$m};
			# make a dummy path that will get ignored
			my $stem = $path->pkgpath_and_flavors;
			my $w = DPB::PkgPath->new("$stem,$m");
			if (!defined $w->{info}) {
				$w->{info} = DPB::PortInfo->new($w);
				$w->{info}->stub_name;
			}
			delete $w->{info}->{IGNORE};
			if (!defined $w->{info}->{IGNORE}) {
				$w->{info}->add('IGNORE', 
				    "vanishes from BUILD_PACKAGES");
			}
			$h->{$w} = $w;
@


1.43
log
@when we rescan paths, we temporarily delete info. Those paths are
already in the system, and we can't take them out, so keep the "old" pkgname
around until we rescanned succesfully. This avoids race conditions if
handle_non_waiting_jobs gets called while we're still scanning.
@
text
@d2 1
a2 1
# $OpenBSD: PkgPath.pm,v 1.42 2013/10/06 13:33:33 espie Exp $
d86 8
@


1.42
log
@update my copyright to 2013
@
text
@d2 1
a2 1
# $OpenBSD: PkgPath.pm,v 1.41 2013/06/25 20:21:52 espie Exp $
d74 1
d76 2
@


1.41
log
@belt AND suspenders. In case this triggers because BUILD_PACKAGES !=
MULTI_PACKAGES and IGNORE doesn't get set.
@
text
@d2 1
a2 1
# $OpenBSD: PkgPath.pm,v 1.40 2013/06/25 09:05:19 espie Exp $
d4 1
a4 1
# Copyright (c) 2010 Marc Espie <espie@@openbsd.org>
@


1.40
log
@tricky (problem found by sebastia@@ on vax...): BUILD_PACKAGES makes
subpackages vanish too entirely, so later, when other ports want them
as dependencies, we're in trouble!

Instead, record both MULTI and BUILD, and compare them when merging depend.
Don't stub out the new paths directly, but "pre-stub them out" with an
IGNOREd message, so the engine picks them, stubs them out for real, and
logs the reason.
@
text
@d2 1
a2 1
# $OpenBSD: PkgPath.pm,v 1.39 2013/04/22 11:14:17 espie Exp $
d187 1
a254 1
			$path = $v; # one for later
d268 9
a276 3
			my $info = DPB::PortInfo->new($w);
			$info->add('IGNORE', "vanishes from BUILD_PACKAGES");
			$info->stub_name;
@


1.39
log
@only show "real bugs". The ones that come from old paths don't count.
@
text
@d2 1
a2 1
# $OpenBSD: PkgPath.pm,v 1.38 2013/04/22 10:06:12 espie Exp $
d184 2
d198 4
d233 1
a233 1
		    PERMIT_DISTFILES_CDROM)) {
d254 18
d299 1
@


1.38
log
@dump all the paths with fishy behavior at end of equiv.

this is a bit too much, but this catches:
SUBDIR=devel/py-gobject3,python3 make dump-vars DPB=Yes
devel/py-gobject3,python.BUILD_DEPENDS=graphics/py3-cairo STEM->=0.10.38:devel/gettext lang/python/3.2 STEM->=0.41.1p0:textproc/intltool devel/gmake archivers/xz
devel/py-gobject3,python.IS_INTERACTIVE=No
devel/py-gobject3,python.SUBPACKAGE=-main
devel/py-gobject3,python.FLAVOR=python3
devel/py-gobject3,python.BUILD_PACKAGES= -main -common
devel/py-gobject3,python.FULLPKGNAME=py3-gobject3-3.8.1p0
devel/py-gobject3,python.RUN_DEPENDS=STEM->=0.10.38:devel/gettext lang/python/3.2 devel/py-gobject3,-common graphics/py3-cairo
devel/py-gobject3,python.LIB_DEPENDS=STEM->=0.10.38:devel/gettext converters/libiconv devel/gobject-introspection
devel/py-gobject3,-common.BUILD_DEPENDS=graphics/py3-cairo STEM->=0.10.38:devel/gettext lang/python/3.2 STEM->=0.41.1p0:textproc/intltool devel/gmake archivers/xz
devel/py-gobject3,-common.IS_INTERACTIVE=No
devel/py-gobject3,-common.SUBPACKAGE=-main
devel/py-gobject3,-common.FLAVOR=python3
devel/py-gobject3,-common.BUILD_PACKAGES= -main -common
devel/py-gobject3,-common.FULLPKGNAME=py-gobject3-common-3.8.1
devel/py-gobject3,-common.RUN_DEPENDS=STEM->=0.10.38:devel/gettext lang/python/3.2

(note the "wrong" flavor, which means that
devel/py-gobject3,python3,-main ends up without an associated fullpkgname)
@
text
@d2 1
a2 1
# $OpenBSD: PkgPath.pm,v 1.37 2013/04/13 10:04:43 espie Exp $
d52 1
@


1.37
log
@display a bit more post-mortem info, show the Core<->current job info.
@
text
@d2 1
a2 1
# $OpenBSD: PkgPath.pm,v 1.36 2012/12/24 17:24:46 espie Exp $
d43 22
@


1.36
log
@add affinity information to restart jobs on the right host preferentially.
- affinity info is similar to locks, but with a completely different
lifetime.
- streamline the main loop of the engine, so that it can do two passes:
first pass shuns paths with the wrong affinity. If no good path is found,
those are considered during the second pass.
- make the Core factory aware of what hosts might be running, so that
affinity info for machines removed from a config file will be ignored.

thanks to landry@@ for a few tests.
@
text
@d2 1
a2 1
# $OpenBSD: PkgPath.pm,v 1.35 2012/10/11 17:35:19 espie Exp $
d57 1
a57 1
			say STDERR Dumper($self->{info});
@


1.35
log
@oops
@
text
@d2 1
a2 1
# $OpenBSD: PkgPath.pm,v 1.34 2012/10/11 07:38:39 espie Exp $
d140 1
@


1.34
log
@move to using BUILD_PACKAGES, so we have the actual tidy list.

Stupid NFS work-around:
during/after cleanup, wait until the packages show up.
Each wait period of ten seconds will show up as waiting#n.
@
text
@d2 1
a2 1
# $OpenBSD: PkgPath.pm,v 1.33 2012/08/22 07:49:00 espie Exp $
d223 1
a223 1
			$v->{info}{MULTI_PACKAGES} = $multi;
@


1.33
log
@according to Theo, somebody reported this to me (?)
in any case, this should "fix" krw's problem, by allowing PkgPath to
actually display the actual program for further debugging.
@
text
@d2 1
a2 1
# $OpenBSD: PkgPath.pm,v 1.32 2012/07/18 10:30:56 espie Exp $
d169 2
a170 2
		if (defined $info->{MULTI_PACKAGES}) {
			$multi = $info->{MULTI_PACKAGES};
d226 21
@


1.32
log
@don't delete DIST, prevents checksum from doing its job
@
text
@d2 1
a2 1
# $OpenBSD: PkgPath.pm,v 1.31 2012/07/10 09:38:37 espie Exp $
d19 1
@


1.31
log
@fuck me harder. Separate cases where fullpkgname is allowed not to
be defined, so that instead of bad stringizations, we get full time errors.

Maybe then I can debug this.
@
text
@d2 1
a2 1
# $OpenBSD: PkgPath.pm,v 1.30 2012/05/16 08:22:22 espie Exp $
d200 1
a200 1
		for my $k (qw(DIST LIB_DEPENDS BUILD_DEPENDS RUN_DEPENDS 
@


1.30
log
@adjust interface slightly
@
text
@d2 1
a2 1
# $OpenBSD: PkgPath.pm,v 1.29 2012/05/15 10:10:13 espie Exp $
d52 7
a58 1
		return undef;
d60 6
@


1.29
log
@split the PkgPath component into a base class so that sqlports will be
able to reuse it
@
text
@d2 1
a2 1
# $OpenBSD: PkgPath.pm,v 1.28 2012/03/13 16:48:47 espie Exp $
d56 1
d66 5
a70 1
	return $self->{info}{SUBPACKAGE};
@


1.28
log
@quickpath to fullpkgpath, called a lot during adjust.
@
text
@d2 1
a2 1
# $OpenBSD: PkgPath.pm,v 1.27 2012/02/23 21:42:23 espie Exp $
d25 2
d28 1
a28 1
my $cache = {};
d30 1
a30 1
sub create
d32 3
a34 30
	my ($class, $fullpkgpath) = @@_;
	# subdivide into flavors/multi
	# XXX we want to preserve empty fields
	my @@list = split /,/, $fullpkgpath, -1;
	my $pkgpath = shift @@list;
	my $o = bless { p => $pkgpath,
		# XXX
		has => 5, 
		new => 1}, $class;
	for my $v (@@list) {
		if ($v =~ m/^\-/) {
			die "$fullpkgpath has >1 multi\n" 
			    if exists $o->{m};
			if ($v eq '-main') {
				$o->{m} = undef;
			} else {
				$o->{m} = $v;
			}
		} else {
			# XXX rely on stuff existing, no need to spring
			# an empty hash into existence
			if ($v eq '') {
				$o->{f} = undef if !exists $o->{f};
			} else {
				$o->{f}{$v} = 1;
			}
		}
	}

	return $o;
d37 1
a37 3
# cache just once, put into standard order, so that we don't
# create different objects for path,f1,f2 and path,f2,f1
sub normalize
d39 4
a42 1
	my $o = shift;
d44 1
a44 3
	my $fullpkgpath = $o->fullpkgpath;
	return $cache->{$fullpkgpath} //= $o;
}
d46 1
a46 2
# actual constructor
sub new
d48 3
a50 3
	my ($class, $fullpkgpath) = @@_;
	if (defined $cache->{$fullpkgpath}) {
		return $cache->{$fullpkgpath};
d52 1
a52 1
		return $class->create($fullpkgpath)->normalize;
d56 1
a56 1
sub seen
d58 2
a59 1
	return values %$cache;
d62 1
a62 1
sub basic_list
d65 1
a65 9
	my @@list = ($self->{p});
	if (exists $self->{f}) {
		if (keys %{$self->{f}}) {
			push(@@list, sort keys %{$self->{f}});
		} else {
			push(@@list, '');
		}
	}
	return @@list;
d67 2
a68 2
# string version, with everything in a standard order
sub fullpkgpath
d70 4
a73 6
	my $self = shift;
	my @@list = $self->basic_list;
	if (defined $self->{m}) {
		push(@@list, $self->{m});
	} elsif (exists $self->{m}) {
		push(@@list, '-main');
a74 1
	return join (',', @@list);
d77 1
a77 1
sub pkgpath
d79 4
a82 13
	my $self = shift;
	return $self->{p};
}

sub multi
{
	my $self = shift;
	if (defined $self->{m}) {
		return $self->{m};
	} elsif (exists $self->{m}) {
		return '-main';
	} else {
		return undef;
d86 1
d89 2
a90 1
	&fullpkgpath;
d95 2
a96 1
	&pkgpath;
a118 60
# without multi. Used by the SUBDIRs code to make sure we get the right
# value for default subpackage.

sub pkgpath_and_flavors
{
	my $self = shift;
	return join (',', $self->basic_list);
}

sub add_to_subdirlist
{
	my ($self, $list) = @@_;
	$list->{$self->pkgpath_and_flavors} = 1;
}

# XXX
# in the ports tree, when you build with SUBDIR=n/value, you'll
# get all the -multi packages, but with the default flavor.
# we have to strip the flavor part to match the SUBDIR we asked for.

sub compose
{
	my ($class, $fullpkgpath, $pseudo) = @@_;
	my $o = $class->create($fullpkgpath);
	if (defined $pseudo->{f}) {
		$o->{f} = $pseudo->{f};
	} else {
		delete $o->{f};
	}
	return $o->normalize;
}

# XXX All this code knows too much about PortInfo for proper OO

sub fullpkgname
{
	my $self = shift;
	if (defined $self->{info} && defined $self->{info}{FULLPKGNAME}) {
		return ${$self->{info}{FULLPKGNAME}};
	} else {
		return undef;
	}
}

sub may_create
{
	my ($n, $o, $h) = @@_;
	my $k = $n->fullpkgpath;
	if (defined $cache->{$k}) {
		$n = $cache->{$k};
	} else {
		$cache->{$k} = $n;
	}
	$n->{has} //= $o->{has};
	$n->{new} //= $o->{new};
	$n->{info} //= $o->{info};
	$h->{$n} = $n;
	return $n;
}

d126 3
a128 18
# XXX
# this is complicated, we want to mark equivalent paths, but we do not want
# to record them as to build by default, but if we're asking for explicit
# subdirs, we have to deal with them.
# so, create $h that holds all paths, and selectively copy the ones from
# todo, along with the set in $want that corresponds to the subdirlist.

sub handle_equivalences
{
	my ($class, $state, $todo, $want) = @@_;
	my $h = {};
	my $result = {};
	for my $v (values %$todo) {
		$h->{$v} = $v;
		$result->{$v} = $v;
		$v->handle_default_flavor($h, $state);
		$v->handle_default_subpackage($h, $state);
	}
a130 70

	if (defined $want) {
		for my $v (values %$h) {
			if ($want->{$v->fullpkgpath}) {
				$result->{$v} = $v;
			}
		}
	}
	return $result;
}

sub zap_default
{
	my ($self, $subpackage) = @@_;
	return $self unless defined $subpackage and defined $self->multi;
	if ($subpackage->string eq $self->multi) {
		my $o = bless {p => $self->{p}}, ref($self);
		if (defined $self->{f}) {
			$o->{f} = $self->{f};
		}
		return $o->normalize;
	} else {
		return $self;
	}
}

sub handle_default_flavor
{
	my ($self, $h, $state) = @@_;

	if (!defined $self->{f}) {
		my $m = bless { p => $self->{p},
		    f => $self->{info}{FLAVOR}}, ref($self);
	    	if (exists $self->{m}) {
			$m->{m} = $self->{m};
		}
		$m = $m->may_create($self, $h);
		$m->simplifies_to($self, $state);
		$m->handle_default_subpackage($h, $state);
	}
}

# default subpackage leads to pkgpath,-default = pkgpath
sub handle_default_subpackage
{
	my ($self, $h, $state) = @@_;
	my $m = $self->zap_default($self->{info}{SUBPACKAGE});
	if ($m ne $self) {
		$m = $m->may_create($self, $h);
		$self->simplifies_to($m, $state);
		$m->handle_default_flavor($h, $state);
	}
}

sub dump
{
	my ($self, $fh) = @@_;
	print $fh $self->fullpkgpath, "\n";
	if (defined $self->{info}) {
		$self->{info}->dump($fh);
	}
}

sub quick_dump
{
	my ($self, $fh) = @@_;
	print $fh $self->fullpkgpath, "\n";
	if (defined $self->{info}) {
		$self->{info}->quick_dump($fh);
	}
@


1.27
log
@hack to avoid stopping midway thru, need to find a better way... ;(
@
text
@d2 1
a2 1
# $OpenBSD: PkgPath.pm,v 1.26 2012/01/29 12:02:20 espie Exp $
d199 5
a203 1
	return (defined $self->{info} && defined $self->{info}{FULLPKGNAME}) ?  $self->{info}->fullpkgname : undef;
@


1.26
log
@more flexible error path while scanning, accumulate reasons why broken.
remove a few explicit (and implicit) die from Fetch: missing/out-of-sync
distinfo no longer kill dpb, instead they're properly reported as broken
paths and things still go on (note that even a missing SUPDISTFILE checksum
*will* mark a path as broken, that's totally intentional)
@
text
@d2 1
a2 1
# $OpenBSD: PkgPath.pm,v 1.25 2012/01/14 12:26:21 espie Exp $
d199 1
a199 1
	return (defined $self->{info}) ?  $self->{info}->fullpkgname : undef;
@


1.25
log
@add support to obey PERMIT_DISTFILES*
@
text
@d2 1
a2 1
# $OpenBSD: PkgPath.pm,v 1.24 2011/12/11 19:55:37 espie Exp $
d391 10
@


1.24
log
@filter out lib-deps with the same pkgpath_and_flavors as what we're
building, like bsd.port.mk does.
won't change anything in the build, but makes pkg_add -a less confusing,
since mp ports won't try to add itself while building.0
@
text
@d2 1
a2 1
# $OpenBSD: PkgPath.pm,v 1.23 2011/12/02 11:40:25 espie Exp $
d328 1
a328 1
		if (defined $info->{DIST}) {
d368 2
a369 1
		    SUBPACKAGE FLAVOR EXTRA)) {
@


1.23
log
@EXTRA should (partly) be handled like DEPENDS/BDEPENDS
@
text
@d2 1
a2 1
# $OpenBSD: PkgPath.pm,v 1.22 2011/11/22 16:44:53 espie Exp $
d344 5
@


1.22
log
@subtle effect of equivalence: sometimes, we do not get back the subdir
we asked for.

This can be a problem, as rescan relies on it to reenter the path in the
various queues.

So, when we build the equivalence hash, give special treatment to extra
paths that match the actual subdirs list.

Problem reported by naddy@@, who sees sporadic errors linked to NFS lag,
which mean that paths sometimes get flagged as errors, then later the error
vanishes automatically when the package appears...

well, this makes darn sure the correct pkgpath does not vanish.
@
text
@d2 1
a2 1
# $OpenBSD: PkgPath.pm,v 1.21 2011/11/13 22:18:04 espie Exp $
d323 2
d356 6
d363 1
a363 1
		    SUBPACKAGE FLAVOR)) {
d373 6
@


1.21
log
@simplify lock code so that lock/unlock actually works, even if I lose
small-grained locks for fullpkgpath
also fix a stupid parenting bug...
@
text
@d2 1
a2 1
# $OpenBSD: PkgPath.pm,v 1.20 2011/11/08 10:26:38 espie Exp $
d225 7
d234 1
a234 1
	my ($class, $state, $todo) = @@_;
d236 1
d239 1
d245 9
@


1.20
log
@split DEPENDS into not done/done to help prepare work correctly
@
text
@d2 1
a2 1
# $OpenBSD: PkgPath.pm,v 1.19 2011/11/08 09:07:24 espie Exp $
a138 5
	&logname;
}

sub simple_lockname
{
d146 1
a146 1
		print $fh "parent=", $self->{parent}->lockname, "\n";
@


1.19
log
@backout shrinkage that breaks prepare
@
text
@d2 1
a2 1
# $OpenBSD: PkgPath.pm,v 1.18 2011/11/07 16:03:19 espie Exp $
a349 1
			delete $global2->{$v};
@


1.18
log
@share MULTI_PACKAGES.
simplify the default case (SUBPACKAGE=-main).
@
text
@d2 1
a2 1
# $OpenBSD: PkgPath.pm,v 1.17 2011/11/07 13:23:09 espie Exp $
d309 1
d350 1
d352 1
@


1.17
log
@modify pkgpath to store info in a more compact way (in particular,
get rid of sawflavor, and just use the existence of the key to mark the
presence of flavors).

also remove yet more info once we used it.
@
text
@d2 1
a2 1
# $OpenBSD: PkgPath.pm,v 1.16 2011/11/06 12:21:07 espie Exp $
d42 6
a47 2
			    if defined $o->{m};
			$o->{m} = $v;
d108 2
d120 12
d246 2
a247 2
	return $self unless defined $subpackage and defined $self->{m};
	if ($subpackage->string eq $self->{m}) {
d265 1
a265 1
	    	if (defined $self->{m}) {
d309 1
d318 4
a346 1
			my $info = $v->{info};
d349 6
a354 1
			$info->{DEPENDS} = $global;
@


1.16
log
@make it simpler to print parent.
zap copy_flavors which I no longer use
@
text
@d2 1
a2 1
# $OpenBSD: PkgPath.pm,v 1.15 2011/11/05 18:25:36 espie Exp $
d35 4
a38 3
	my %flavors = ();
	my $sawflavor = 0;
	my $multi = undef;
d41 3
a43 2
			die "$fullpkgpath has >1 multi\n" if defined $multi;
			$multi = $v;
d45 7
a51 2
			$sawflavor = 1;
			$flavors{$v} = 1 unless $v eq '';
d55 1
a55 7
	bless {pkgpath => $pkgpath,
		# XXX
		has => 5,
		new => 1,
		flavors => \%flavors,
		sawflavor => $sawflavor,
		multi => $multi}, $class;
d87 7
a93 5
	my @@list = ($self->{pkgpath});
	if (keys %{$self->{flavors}}) {
		push(@@list, sort keys %{$self->{flavors}});
	} elsif ($self->{sawflavor}) {
		push(@@list, '');
d102 2
a103 2
	if ($self->{multi}) {
		push(@@list, $self->{multi});
d108 6
d116 1
a116 2
	my $self = shift;
	return $self->fullpkgpath;
d126 1
a126 1
	return shift->{pkgpath};
d173 5
a177 2
	$o->{flavors} = $pseudo->{flavors};
	$o->{sawflavor} = $pseudo->{sawflavor};
d228 6
a233 5
	return $self unless defined $subpackage and defined $self->{multi};
	if ($subpackage->string eq $self->{multi}) {
		my $o = bless {pkgpath => $self->{pkgpath},
			sawflavor => $self->{sawflavor},
			flavors => $self->{flavors}}, ref($self);
d244 6
a249 5
	if (!$self->{sawflavor}) {
		my $m = bless { pkgpath => $self->{pkgpath},
		    sawflavor => 1,
		    multi => $self->{multi},
		    flavors => $self->{info}{FLAVOR}}, ref($self);
d260 1
a260 1
	my $m = $self->zap_default($self->{info}->{SUBPACKAGE});
d317 2
a318 1
		for my $k (qw(DIST LIB_DEPENDS BUILD_DEPENDS RUN_DEPENDS)) {
@


1.15
log
@shrink a bit: the reason for copy_flavors use is long gone
remove the debug scaffolding that duplicates depends list
@
text
@d2 1
a2 1
# $OpenBSD: PkgPath.pm,v 1.14 2011/10/11 13:43:25 espie Exp $
d121 8
a153 6
}

sub copy_flavors
{
	my $self = shift;
	return {map {($_, 1)} keys %{$self->{flavors}}};
@


1.14
log
@duh, for equates to work, I need to store values. I'm an idiot.
@
text
@d2 1
a2 1
# $OpenBSD: PkgPath.pm,v 1.13 2011/10/10 18:56:50 espie Exp $
d163 1
a163 1
	$o->{flavors} = $pseudo->copy_flavors;
d178 1
a178 1
	my ($n, $o, $h, $state) = @@_;
d219 1
a219 1
			flavors => $self->copy_flavors}, ref($self);
d234 2
a235 2
		    flavors => $self->{info}->{FLAVOR}}, ref($self);
		$m = $m->may_create($self, $h, $state);
d247 1
a247 1
		$m = $m->may_create($self, $h, $state);
a275 1
	my $global2 = bless {}, "AddDepends";
a290 1
					$global2->{$d} = $d;
d302 3
a310 1
			delete $global2->{$v};
a311 1
			$info->{BDEPENDS} = $global2;
@


1.13
log
@unfuck pkgpaths.
- instead of seen/unseen, have an actual constructor. Instead, mark pkgpath
for which we wantinfo/wantbuild.
- only mark EXTRA dependencies as wantinfo. So the devel/haddock,no_deps
temporary error should be gone.
- since we have FLAVOR and SUBPACKAGE available, construct as much info as
we can during vars scanning (see handle_equivalences). This avoids about 150
path rescans during a full bulk. Also, grab the timing and logsizes from
equivalent files, so that most stuff should know show % all the time.
- tweak subdirlist to be a hash, and correctly add pkgpath_and_flavors to it.
That way, we rescan avahi pseudo flavors just once, and not four or five times.
@
text
@d2 1
a2 1
# $OpenBSD: PkgPath.pm,v 1.12 2011/10/03 08:56:40 espie Exp $
d188 1
a188 1
	$h->{$n} = 1;
d204 1
a204 1
		$h->{$v} = 1;
@


1.12
log
@ooh, don't merge depends from IGNOREd stuff for MULTI_PACKAGES.
this allows build to proceed faster on some arches by simply not
building stuff we don't need
@
text
@d2 1
a2 1
# $OpenBSD$
a26 1
my $seen = {};
d67 2
a68 2
# actual user constructor that doesn't record into seen
sub new_hidden
a77 8
# actual user constructor that records into seen
sub new
{
	my ($class, $fullpkgpath) = @@_;
	my $o = $class->new_hidden($fullpkgpath);
	$seen->{$o} //= $o;
}

d80 1
a80 1
	return values %$seen;
d107 2
a108 1
	return shift->fullpkgpath;
d145 1
a145 1
	push(@@$list, $self->pkgpath_and_flavors);
a164 1
	my $p = $o->normalize;
d176 35
d215 1
a215 1
	return $self unless defined $subpackage;
d226 15
d242 1
a242 1
sub handle_default
d244 1
a244 1
	my ($self, $h) = @@_;
d247 3
a249 3
#		print $m->fullpkgpath, " vs. ", $self->fullpkgpath,"\n";
		$m->{info} = $self->{info};
		$h->{$m} = $m;
@


1.11
log
@fix build of "x11/qt3," : for multi-packages, when we find the default
subpackage, copy full options status. So, e.g., look for "x11/qt3,"
find "x11/qt3,,-main" and equate it with "x11/qt3," NOT "x11/qt3"
@
text
@d2 1
a2 1
# $OpenBSD: PkgPath.pm,v 1.10 2011/06/15 10:09:31 espie Exp $
d238 9
a260 6
			}
		}
		if (defined $info->{DIST}) {
			for my $f (values %{$info->{DIST}}) {
				$info->{FDEPENDS}{$f} = $f;
				bless $info->{FDEPENDS}, "AddDepends";
@


1.10
log
@fix a long-standing bug: add LIB_DEPENDS to the RUN_DEPENDS of a port, as
there's a safeguard against self-depends anyways.
This prevents ports from getting moved from "built" to "installable"
prematurely.

For instance, devel/libsoup,-gnome doesn't directly depend on
net/glib2-networking, but it depends on devel/libsoup,-main which has
the net/glib2-networking.

Without this patch, dependencies on devel/libsoup,-gnome would often build
prematurely and build net/glib2-networking with them.
@
text
@d2 1
a2 1
# $OpenBSD: PkgPath.pm,v 1.9 2011/06/04 12:56:54 espie Exp $
d192 1
d206 1
a206 1
		#print $m->fullpkgpath, " vs. ", $self->fullpkgpath,"\n";
@


1.9
log
@keep a better list of depends, so that pkg_add does add exactly what it should
@
text
@d2 1
a2 1
# $OpenBSD$
d245 6
a250 4
		if (defined $info->{RUN_DEPENDS}) {
			for my $d (values %{$info->{RUN_DEPENDS}}) {
				$info->{RDEPENDS}{$d} = $d;
				bless $info->{RDEPENDS}, "AddDepends";
@


1.8
log
@- unify code in Fetch/Build subengines
- zap heuristic#3, not critical
- don't rebuild the Fetch queue all the time, it's too expensive
- fix bugs in FetchQueue computation, correctly handle 1 distfile case
- create a quick path thru adjust* that handles only new paths.
- use it during LISTING while fetching files, to make more files available
quicker.
- model distfiles as FDEPENDS, DIST, so that they can get dumped.
- add -v option that dumps a bit more stuff in log files.

with these, dpb will fetch all distfiles in a not too surprising order,
and it won't consume 40% cpu while doing so...
@
text
@d2 1
a2 1
# $OpenBSD: PkgPath.pm,v 1.6 2011/05/28 19:32:59 espie Exp $
d229 1
d234 1
d241 1
d261 3
d265 1
@


1.7
log
@avoid fetching distfiles where we don't know dependencies yet
@
text
@d52 1
d246 6
@


1.6
log
@oops, the Builder is one indirection down now
@
text
@d2 1
a2 1
# $OpenBSD: PkgPath.pm,v 1.5 2011/05/27 10:27:50 espie Exp $
d51 1
a51 1
		has => 1,
@


1.5
log
@start moving the fetch/build code into separate subengine classes, to make
it more obvious how much is shared (goal is to unify a large part of these).

In particular, the locking code/stuff already active is glaringly the same...

Polish the distfiles measurements. For now, 3 heuristics that kick in
at various stages of the build (a bit of black magic).

Fix pkgpath->{has} to record both "no dependencies" and "several distfiles
missing" to avoid grabbing small patchfiles which don't lead to valid
builds while heuristic#1 is active.
@
text
@d2 1
a2 1
# $OpenBSD: PkgPath.pm,v 1.4 2011/05/22 08:21:39 espie Exp $
d131 1
a131 1
	return $v->{info} && $engine->{builder}->check($v);
@


1.4
log
@initial support for fetching distfiles, somewhat experimental yet.
- clean up clock handling, jobs with timer.
- pass more parameters thru state
- tweak the engine to handle distfiles
- lots of new code in Fetch for new jobs.
@
text
@d2 1
a2 1
# $OpenBSD: PkgPath.pm,v 1.3 2011/03/22 19:48:53 espie Exp $
a137 6
}

# for weights, we are ourselves
sub representative
{
	return shift;
@


1.3
log
@tidy, minor
@
text
@d2 1
a2 1
# $OpenBSD: PkgPath.pm,v 1.2 2010/10/26 15:45:09 espie Exp $
d50 2
d113 32
@


1.2
log
@rework PkgPath to distinguish between empty and default flavors...

turns out we probably don't need FULLSUBDIR after all.
compute SUBDIR better, possibly with quotes.
Remove trailing / on subdirs, in case people use completion.
@
text
@d2 1
a2 1
# $OpenBSD$
d205 1
d207 2
a208 2
			if (defined $v->{info}{$k}) {
				for my $d (values %{$v->{info}{$k}}) {
d213 4
a216 4
		if (defined $v->{info}{RUN_DEPENDS}) {
			for my $d (values %{$v->{info}{RUN_DEPENDS}}) {
				$v->{info}{RDEPENDS}{$d} = $d;
				bless $v->{info}{RDEPENDS}, "AddDepends";
d222 2
a223 1
			$v->{info}{DEPENDS} = $global;
@


1.1
log
@Initial revision
@
text
@d2 1
a2 1
# $OpenBSD: PkgPath.pm,v 1.2 2010/05/04 09:45:41 espie Exp $
d33 2
a34 1
	my @@list = split /,/, $fullpkgpath;
d36 11
a46 5
	my %flavors = map {($_, 1)} grep { !/^\-/} @@list;
	my @@multi = grep { /^\-/} @@list;
	my $multi = pop(@@multi) || undef;
	if (@@multi > 0) {
		die "$fullpkgpath has >1 multi\n";
d51 1
d95 2
d143 2
@


1.1.1.1
log
@move stuff here from infra/build
@
text
@@
