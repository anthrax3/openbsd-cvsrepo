head	1.122;
access;
symbols
	OPENBSD_6_1:1.122.0.2
	OPENBSD_6_1_BASE:1.122
	OPENBSD_6_0:1.121.0.2
	OPENBSD_6_0_BASE:1.121
	OPENBSD_5_9:1.116.0.2
	OPENBSD_5_9_BASE:1.116
	OPENBSD_5_8:1.113.0.4
	OPENBSD_5_8_BASE:1.113
	OPENBSD_5_7:1.109.0.2
	OPENBSD_5_7_BASE:1.109
	OPENBSD_5_6:1.106.0.2
	OPENBSD_5_6_BASE:1.106
	OPENBSD_5_5:1.103.0.2
	OPENBSD_5_5_BASE:1.103
	OPENBSD_5_4:1.85.0.2
	OPENBSD_5_4_BASE:1.85
	OPENBSD_5_3:1.73.0.2
	OPENBSD_5_3_BASE:1.73
	OPENBSD_5_2:1.48.0.2
	OPENBSD_5_2_BASE:1.48
	OPENBSD_5_1_BASE:1.46
	OPENBSD_5_1:1.46.0.2
	OPENBSD_5_0:1.25.0.2
	OPENBSD_5_0_BASE:1.25
	OPENBSD_4_9:1.15.0.2
	OPENBSD_4_9_BASE:1.15
	ports:1.1.1.1
	espie:1.1.1;
locks; strict;
comment	@# @;


1.122
date	2016.10.21.00.45.43;	author espie;	state Exp;
branches;
next	1.121;
commitid	v9KVbVh2NnL7Ndbt;

1.121
date	2016.06.13.13.36.36;	author espie;	state Exp;
branches;
next	1.120;
commitid	6LqS7l5ow6AR7LV4;

1.120
date	2016.05.21.12.20.10;	author espie;	state Exp;
branches;
next	1.119;
commitid	0f89fFEtAu709Kh2;

1.119
date	2016.05.16.13.47.18;	author espie;	state Exp;
branches;
next	1.118;
commitid	Seo1OMd8B6VAoKJ6;

1.118
date	2016.05.16.10.28.14;	author espie;	state Exp;
branches;
next	1.117;
commitid	Tn5xZiy5z9OLEA20;

1.117
date	2016.05.08.09.34.25;	author espie;	state Exp;
branches;
next	1.116;
commitid	ukS0nwRVAg2QJZtd;

1.116
date	2015.10.16.13.04.55;	author espie;	state Exp;
branches;
next	1.115;
commitid	VbPGg6vcAGdtUBGb;

1.115
date	2015.08.24.09.58.00;	author espie;	state Exp;
branches;
next	1.114;
commitid	o79yURjka8Dvcy9b;

1.114
date	2015.08.16.08.36.53;	author espie;	state Exp;
branches;
next	1.113;
commitid	QyKGZT0rCzU3IeWy;

1.113
date	2015.06.17.07.31.25;	author espie;	state Exp;
branches;
next	1.112;
commitid	IEMN3P1HNIr1q6Tn;

1.112
date	2015.06.11.08.42.38;	author espie;	state Exp;
branches;
next	1.111;
commitid	ekCbOseoc88M9I00;

1.111
date	2015.06.08.11.06.08;	author espie;	state Exp;
branches;
next	1.110;
commitid	UFmzyzpqKmldAIst;

1.110
date	2015.05.10.08.14.14;	author espie;	state Exp;
branches;
next	1.109;
commitid	J9XuZmxJc7sLMZLF;

1.109
date	2014.12.07.15.18.50;	author espie;	state Exp;
branches;
next	1.108;
commitid	GynqjLfrNHwgIuss;

1.108
date	2014.12.06.18.34.05;	author espie;	state Exp;
branches;
next	1.107;
commitid	Ol7P0dyW5MoC494w;

1.107
date	2014.09.23.18.19.21;	author espie;	state Exp;
branches;
next	1.106;
commitid	8oAV0i7GF5SECNd5;

1.106
date	2014.06.14.01.23.48;	author afresh1;	state Exp;
branches;
next	1.105;
commitid	T2MnuHnc8yRaI9dB;

1.105
date	2014.03.17.10.47.12;	author espie;	state Exp;
branches;
next	1.104;

1.104
date	2014.03.10.09.06.12;	author espie;	state Exp;
branches;
next	1.103;

1.103
date	2014.01.18.11.23.48;	author espie;	state Exp;
branches;
next	1.102;

1.102
date	2014.01.09.11.08.51;	author espie;	state Exp;
branches;
next	1.101;

1.101
date	2013.10.19.09.33.52;	author espie;	state Exp;
branches;
next	1.100;

1.100
date	2013.10.19.09.07.49;	author espie;	state Exp;
branches;
next	1.99;

1.99
date	2013.10.19.08.41.29;	author espie;	state Exp;
branches;
next	1.98;

1.98
date	2013.10.13.19.59.06;	author espie;	state Exp;
branches;
next	1.97;

1.97
date	2013.10.13.18.31.50;	author espie;	state Exp;
branches;
next	1.96;

1.96
date	2013.10.09.06.20.56;	author espie;	state Exp;
branches;
next	1.95;

1.95
date	2013.10.07.18.01.33;	author espie;	state Exp;
branches;
next	1.94;

1.94
date	2013.10.06.15.49.23;	author espie;	state Exp;
branches;
next	1.93;

1.93
date	2013.10.06.13.33.29;	author espie;	state Exp;
branches;
next	1.92;

1.92
date	2013.10.06.13.22.18;	author espie;	state Exp;
branches;
next	1.91;

1.91
date	2013.10.03.08.03.27;	author espie;	state Exp;
branches;
next	1.90;

1.90
date	2013.09.16.21.29.13;	author espie;	state Exp;
branches;
next	1.89;

1.89
date	2013.09.14.14.58.12;	author espie;	state Exp;
branches;
next	1.88;

1.88
date	2013.09.06.17.11.01;	author espie;	state Exp;
branches;
next	1.87;

1.87
date	2013.08.28.12.00.39;	author espie;	state Exp;
branches;
next	1.86;

1.86
date	2013.08.07.06.56.42;	author espie;	state Exp;
branches;
next	1.85;

1.85
date	2013.07.21.16.24.32;	author espie;	state Exp;
branches;
next	1.84;

1.84
date	2013.07.18.05.36.54;	author espie;	state Exp;
branches;
next	1.83;

1.83
date	2013.06.30.16.45.16;	author espie;	state Exp;
branches;
next	1.82;

1.82
date	2013.06.25.07.49.52;	author espie;	state Exp;
branches;
next	1.81;

1.81
date	2013.06.23.09.04.39;	author espie;	state Exp;
branches;
next	1.80;

1.80
date	2013.06.17.10.47.44;	author espie;	state Exp;
branches;
next	1.79;

1.79
date	2013.06.16.13.17.59;	author espie;	state Exp;
branches;
next	1.78;

1.78
date	2013.06.15.20.06.50;	author espie;	state Exp;
branches;
next	1.77;

1.77
date	2013.05.01.22.39.24;	author espie;	state Exp;
branches;
next	1.76;

1.76
date	2013.04.30.10.22.36;	author espie;	state Exp;
branches;
next	1.75;

1.75
date	2013.04.22.19.34.10;	author espie;	state Exp;
branches;
next	1.74;

1.74
date	2013.04.15.13.44.06;	author espie;	state Exp;
branches;
next	1.73;

1.73
date	2013.02.02.13.35.17;	author espie;	state Exp;
branches;
next	1.72;

1.72
date	2013.01.28.10.14.17;	author espie;	state Exp;
branches;
next	1.71;

1.71
date	2013.01.10.10.30.13;	author espie;	state Exp;
branches;
next	1.70;

1.70
date	2013.01.10.10.28.29;	author espie;	state Exp;
branches;
next	1.69;

1.69
date	2013.01.05.13.39.36;	author espie;	state Exp;
branches;
next	1.68;

1.68
date	2013.01.04.19.34.10;	author espie;	state Exp;
branches;
next	1.67;

1.67
date	2013.01.04.12.06.25;	author espie;	state Exp;
branches;
next	1.66;

1.66
date	2013.01.03.15.47.45;	author espie;	state Exp;
branches;
next	1.65;

1.65
date	2013.01.02.11.13.52;	author espie;	state Exp;
branches;
next	1.64;

1.64
date	2012.12.30.14.33.46;	author espie;	state Exp;
branches;
next	1.63;

1.63
date	2012.12.30.11.47.24;	author espie;	state Exp;
branches;
next	1.62;

1.62
date	2012.12.29.19.15.37;	author espie;	state Exp;
branches;
next	1.61;

1.61
date	2012.12.28.06.40.11;	author espie;	state Exp;
branches;
next	1.60;

1.60
date	2012.12.27.16.23.17;	author espie;	state Exp;
branches;
next	1.59;

1.59
date	2012.12.27.14.14.19;	author espie;	state Exp;
branches;
next	1.58;

1.58
date	2012.12.27.11.04.43;	author espie;	state Exp;
branches;
next	1.57;

1.57
date	2012.12.25.20.41.41;	author espie;	state Exp;
branches;
next	1.56;

1.56
date	2012.12.25.16.07.02;	author espie;	state Exp;
branches;
next	1.55;

1.55
date	2012.12.25.09.46.24;	author espie;	state Exp;
branches;
next	1.54;

1.54
date	2012.12.25.09.31.54;	author espie;	state Exp;
branches;
next	1.53;

1.53
date	2012.12.24.17.24.46;	author espie;	state Exp;
branches;
next	1.52;

1.52
date	2012.12.24.17.22.15;	author espie;	state Exp;
branches;
next	1.51;

1.51
date	2012.12.21.12.26.16;	author espie;	state Exp;
branches;
next	1.50;

1.50
date	2012.10.08.12.41.03;	author espie;	state Exp;
branches;
next	1.49;

1.49
date	2012.09.23.18.13.32;	author espie;	state Exp;
branches;
next	1.48;

1.48
date	2012.07.10.09.38.37;	author espie;	state Exp;
branches;
next	1.47;

1.47
date	2012.04.07.12.16.58;	author espie;	state Exp;
branches;
next	1.46;

1.46
date	2012.01.30.15.11.04;	author espie;	state Exp;
branches;
next	1.45;

1.45
date	2012.01.23.10.35.38;	author espie;	state Exp;
branches;
next	1.44;

1.44
date	2012.01.09.11.54.30;	author espie;	state Exp;
branches;
next	1.43;

1.43
date	2012.01.08.14.40.58;	author espie;	state Exp;
branches;
next	1.42;

1.42
date	2011.12.10.14.48.40;	author espie;	state Exp;
branches;
next	1.41;

1.41
date	2011.12.04.10.57.46;	author espie;	state Exp;
branches;
next	1.40;

1.40
date	2011.12.04.10.39.52;	author espie;	state Exp;
branches;
next	1.39;

1.39
date	2011.12.02.11.52.06;	author espie;	state Exp;
branches;
next	1.38;

1.38
date	2011.12.02.11.40.25;	author espie;	state Exp;
branches;
next	1.37;

1.37
date	2011.11.22.16.46.44;	author espie;	state Exp;
branches;
next	1.36;

1.36
date	2011.11.14.21.57.47;	author espie;	state Exp;
branches;
next	1.35;

1.35
date	2011.11.13.22.18.04;	author espie;	state Exp;
branches;
next	1.34;

1.34
date	2011.11.13.10.34.35;	author espie;	state Exp;
branches;
next	1.33;

1.33
date	2011.11.09.08.28.55;	author espie;	state Exp;
branches;
next	1.32;

1.32
date	2011.11.08.10.26.38;	author espie;	state Exp;
branches;
next	1.31;

1.31
date	2011.11.07.13.23.09;	author espie;	state Exp;
branches;
next	1.30;

1.30
date	2011.11.06.12.23.28;	author espie;	state Exp;
branches;
next	1.29;

1.29
date	2011.11.05.18.27.13;	author espie;	state Exp;
branches;
next	1.28;

1.28
date	2011.10.10.18.56.50;	author espie;	state Exp;
branches;
next	1.27;

1.27
date	2011.09.28.09.49.29;	author espie;	state Exp;
branches;
next	1.26;

1.26
date	2011.09.13.09.46.53;	author espie;	state Exp;
branches;
next	1.25;

1.25
date	2011.06.03.13.38.58;	author espie;	state Exp;
branches;
next	1.24;

1.24
date	2011.06.02.17.09.25;	author espie;	state Exp;
branches;
next	1.23;

1.23
date	2011.06.01.12.34.09;	author espie;	state Exp;
branches;
next	1.22;

1.22
date	2011.05.29.09.30.13;	author espie;	state Exp;
branches;
next	1.21;

1.21
date	2011.05.28.19.24.15;	author espie;	state Exp;
branches;
next	1.20;

1.20
date	2011.05.28.08.21.39;	author espie;	state Exp;
branches;
next	1.19;

1.19
date	2011.05.27.11.22.13;	author espie;	state Exp;
branches;
next	1.18;

1.18
date	2011.05.27.10.27.50;	author espie;	state Exp;
branches;
next	1.17;

1.17
date	2011.05.22.08.21.39;	author espie;	state Exp;
branches;
next	1.16;

1.16
date	2011.04.25.11.58.46;	author espie;	state Exp;
branches;
next	1.15;

1.15
date	2010.12.07.10.56.26;	author espie;	state Exp;
branches;
next	1.14;

1.14
date	2010.10.31.11.07.20;	author espie;	state Exp;
branches;
next	1.13;

1.13
date	2010.10.30.11.19.38;	author espie;	state Exp;
branches;
next	1.12;

1.12
date	2010.10.29.11.51.42;	author espie;	state Exp;
branches;
next	1.11;

1.11
date	2010.10.28.16.40.48;	author espie;	state Exp;
branches;
next	1.10;

1.10
date	2010.10.28.08.54.22;	author espie;	state Exp;
branches;
next	1.9;

1.9
date	2010.10.27.22.58.02;	author espie;	state Exp;
branches;
next	1.8;

1.8
date	2010.10.27.22.53.33;	author espie;	state Exp;
branches;
next	1.7;

1.7
date	2010.10.27.12.58.26;	author espie;	state Exp;
branches;
next	1.6;

1.6
date	2010.10.26.16.57.10;	author espie;	state Exp;
branches;
next	1.5;

1.5
date	2010.10.24.10.01.57;	author espie;	state Exp;
branches;
next	1.4;

1.4
date	2010.10.23.21.46.03;	author espie;	state Exp;
branches;
next	1.3;

1.3
date	2010.10.23.18.14.19;	author espie;	state Exp;
branches;
next	1.2;

1.2
date	2010.10.23.17.58.55;	author espie;	state Exp;
branches;
next	1.1;

1.1
date	2010.08.20.13.40.13;	author espie;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2010.08.20.13.40.13;	author espie;	state Exp;
branches;
next	;


desc
@@


1.122
log
@dpb cleans the permanent logs, always using the same pattern,
so write a method for that.

And don't fail silently when it doesn't work, because that causes
trouble down the line.

(e.g., your log user must be able to write into build-stats!!!)
@
text
@# ex:ts=8 sw=4:
# $OpenBSD: Engine.pm,v 1.121 2016/06/13 13:36:36 espie Exp $
#
# Copyright (c) 2010-2013 Marc Espie <espie@@openbsd.org>
#
# Permission to use, copy, modify, and distribute this software for any
# purpose with or without fee is hereby granted, provided that the above
# copyright notice and this permission notice appear in all copies.
#
# THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
# ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
# OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

use strict;
use warnings;

use DPB::Limiter;
use DPB::SubEngine;
use DPB::ErrorList;

package DPB::Engine;
our @@ISA = qw(DPB::Limiter);

use DPB::Heuristics;
use DPB::Util;

sub subengine_class
{
	my ($class, $state) = @@_;
	if ($state->{fetch_only}) {
		return "DPB::SubEngine::NoBuild";
	} else {
		require DPB::SubEngine::Build;
		return "DPB::SubEngine::Build";
	}
}

sub new
{
	my ($class, $state) = @@_;
	my $o = bless {built => {},
	    tobuild => {},
	    state => $state,
	    installable => {},
	    heuristics => $state->heuristics,
	    sizer => $state->sizer,
	    locker => $state->locker,
	    logger => $state->logger,
	    affinity => $state->{affinity},
	    errors => DPB::ErrorList->new,
	    locks => DPB::LockList->new,
	    nfslist => DPB::NFSList->new,
	    ts => time(),
	    requeued => [],
	    ignored => []}, $class;
	$o->{buildable} = $class->subengine_class($state)->new($o, $state->builder);
	if ($state->{want_fetchinfo}) {
		require DPB::SubEngine::Fetch;
		$o->{tofetch} = DPB::SubEngine::Fetch->new($o);
	}
	$o->{log} = $state->logger->append("engine");
	$o->{stats} = DPB::Stats->new($state);
	return $o;
}

sub recheck_errors
{
	my $self = shift;
	$self->{errors}->recheck($self);
	$self->{locks}->recheck($self);
	$self->{nfslist}->recheck($self);
}

sub log_no_ts
{
	my ($self, $kind, $v, $extra) = @@_;
	$extra //= '';
	my $fh = $self->{log};
	my $ts = int($self->{ts});
	print $fh "$$\@@$ts: $kind";
	if (defined $v) {
		print $fh ": ", $v->logname, $extra;
	}
	print $fh "\n";
}

sub log
{
	my $self = shift;
	$self->{ts} = time();
	$self->log_no_ts(@@_);
}

sub flush
{
	my $self = shift;
	$self->{log}->flush;
}

sub count
{
	my ($self, $field) = @@_;
	my $r = $self->{$field};
	if (ref($r) eq 'HASH') {
		return scalar keys %$r;
	} elsif (ref($r) eq 'ARRAY') {
		return scalar @@$r;
	} else {
		return "?";
    	}
}

sub fetchcount
{
	my ($self, $q, $t)= @@_;
	return () unless defined $self->{tofetch};
	if ($self->{state}{fetch_only}) {
		$self->{tofetch}{queue}->set_fetchonly;
	} elsif ($q < 30) {
		$self->{tofetch}{queue}->set_h1;
	} else {
		$self->{tofetch}{queue}->set_h2;
	}
	return ("F=".$self->{tofetch}->count);
}

sub statline
{
	my $self = shift;
	my $q = $self->{buildable}->count;
	my $t = $self->count("tobuild");
	return join(" ",
	    "I=".$self->count("installable"),
	    "B=".$self->count("built"),
	    "Q=$q",
	    "T=$t",
	    $self->fetchcount($q, $t));
}

sub may_add
{
	my ($self, $prefix, $s) = @@_;
	if ($s eq '') {
		return '';
	} else {
		return "$prefix$s\n";
	}
}

sub report
{
	my $self = shift;
	my $q = $self->{buildable}->count;
	my $t = $self->count("tobuild");
	return join(" ",
	    $self->statline,
	    "!=".$self->count("ignored"))."\n".
	    $self->may_add("L=", $self->{locks}->stringize).
	    $self->may_add("E=", $self->{errors}->stringize). 
	    $self->may_add("H=", $self->{nfslist}->stringize);
}

sub stats
{
	my $self = shift;
	$self->{stats}->log($self->{ts}, $self->statline);
}

sub important
{
	my $self = shift;
	$self->{lasterrors} //= 0;
	if (@@{$self->{errors}} != $self->{lasterrors}) {
		$self->{lasterrors} = @@{$self->{errors}};
		return "Error in ".join(' ', map {$_->fullpkgpath} @@{$self->{errors}})."\n";
	}
}

sub adjust
{
	my ($self, $v, $kind, $kind2) = @@_;
	return 0 if !exists $v->{info}{$kind};
	my $not_yet = 0;
	# XXX don't use `values` in this loop, it may trigger perlbug 77706
	my @@values = values %{$v->{info}{$kind}};
	for my $d (@@values) {
		$self->{heuristics}->mark_depend($d, $v);
		if ($self->{installable}{$d} ||
		    (defined $d->{info} &&
		    $d->fullpkgname eq $v->fullpkgname)) {
			delete $v->{info}{$kind}{$d};
			$v->{info}{$kind2}{$d} = $d if defined $kind2;
		} else {
			$not_yet++;
		}
	}
	return $not_yet if $not_yet;
	delete $v->{info}{$kind};
	return 0;
}

sub missing_dep
{
	my ($self, $v, $kind) = @@_;
	return undef if !exists $v->{info}{$kind};
	for my $d (values %{$v->{info}{$kind}}) {
		return $d if (defined $d->{info}) && $d->{info}{IGNORE};
	}
	return undef;
}

sub stub_out
{
	my ($self, $v) = @@_;
	push(@@{$self->{ignored}}, $v);

	# keep the info if it exists, make sure it's stubbed out otherwise
	my $i = $v->{info};
	$v->{info} = DPB::PortInfo->stub;
	return if !defined $i;
	for my $w ($v->build_path_list) {
		# don't fill in equiv lists if they don't matter.
		next if !defined $w->{info};
		if ($w->{info} eq $i) {
			$w->{info} = DPB::PortInfo->stub;
		}
	}
}

# need to ignore $v because of some missing $kind dependency:
# wipe out its info and put it in the right list
sub should_ignore
{
	my ($self, $v, $kind) = @@_;
	if (my $d = $self->missing_dep($v, $kind)) {
		$self->log_no_ts('!', $v, " because of ".$d->fullpkgpath);
		$self->stub_out($v);
		return 1;
	} else {
		return 0;
	}
}

sub has_known_depends
{
	my ($self, $v) = @@_;
	for my $kind (qw(DEPENDS BDEPENDS)) {
		next unless defined $v->{info}{$kind};
		for my $d (values %{$v->{info}{$kind}}) {
			return 0 unless $d->has_fullpkgname;
		}
	}
	return 1;
}

sub adjust_extra
{
	my ($self, $v, $kind, $kind2) = @@_;
	return 0 if !exists $v->{info}{$kind};
	my $not_yet = 0;
	for my $d (values %{$v->{info}{$kind}}) {
		$self->{heuristics}->mark_depend($d, $v);
		if ((defined $d->{info} && !$self->{tobuild}{$d} && 
			$self->has_known_depends($d)) ||
		    ($d->has_fullpkgname &&
		    $d->fullpkgname eq $v->fullpkgname)) {
			delete $v->{info}{$kind}{$d};
			$v->{info}{$kind2}{$d} = $d if defined $kind2;
		} else {
			$not_yet++;
		}
	}
	return $not_yet if $not_yet;
	delete $v->{info}{$kind};
	return 0;
}

sub adjust_distfiles
{
	my ($self, $v) = @@_;
	return 0 if !exists $v->{info}{FDEPENDS};
	my $not_yet = 0;
	for my $f (values %{$v->{info}{FDEPENDS}}) {
		if ($self->{tofetch}->is_done($f)) {
			$v->{info}{distsize} //= 0;
			$v->{info}{distsize} += $f->{sz};
			delete $v->{info}{FDEPENDS}{$f};
			next;
		}
		$not_yet++;
	}
	return $not_yet if $not_yet;
	delete $v->{info}{FDEPENDS};
	return 0;
}

my $output = {};

sub adjust_built
{
	my $self = shift;
	my $changes = 0;

	for my $v (values %{$self->{built}}) {
		if ($self->adjust($v, 'RDEPENDS') == 0) {
			delete $self->{built}{$v};
			# okay, thanks to equiv, some other path was marked
			# as stub, and obviously we lost our deps
			if ($v->{info}->is_stub) {
				$self->log_no_ts('!', $v, 
				    " equivalent to an ignored path");
				# just drop it, it's already ignored as
				# an equivalent path
				next;
			}
			$self->{installable}{$v} = $v;
			if ($v->{wantinstall}) {
				$self->{buildable}->will_install($v);
			}
			$self->log_no_ts('I', $v,' # '.$v->fullpkgname);
			$changes++;
		} elsif ($self->should_ignore($v, 'RDEPENDS')) {
			delete $self->{built}{$v};
			$changes++;
		}
	}
	return $changes;
}

sub adjust_depends1
{
	my ($self, $v, $has) = @@_;
	$has->{$v} = $self->adjust($v, 'DEPENDS', 'BDEPENDS');
}

sub adjust_depends2
{
	my ($self, $v, $has) = @@_;
	if ($has->{$v} != 0) {
		if (my $d = $self->should_ignore($v, 'DEPENDS')) {
			delete $self->{tobuild}{$v};
		} else {
			$v->{has} = 2;
		}
	} else {
		# okay, thanks to equiv, some other path was marked
		# as stub, and obviously we lost our deps
		if ($v->{info}->is_stub) {
			$self->log_no_ts('!', $v, 
			    " equivalent to an ignored path");
			# just drop it, it's already ignored as
			# an equivalent path
			delete $self->{tobuild}{$v};
			return;
		}
		my $has = $has->{$v} + 
		    $self->adjust_extra($v, 'EXTRA', 'BEXTRA');

		my $has2 = $self->adjust_distfiles($v);
		# being buildable directly is a priority,
		# but put the patch/dist/small stuff down the 
		# line as otherwise we will tend to grab 
		# patch files first
		$v->{has} = 2 * ($has != 0) + ($has2 > 1);
		if ($has + $has2 == 0) {
			delete $self->{tobuild}{$v};
			# XXX because of this, not all build_path_list
			# are considered equal... 
			if ($self->should_ignore($v, 'RDEPENDS')) {
				$self->{buildable}->remove($v);
			} else {
				$self->{buildable}->add($v);
				$self->log_no_ts('Q', $v);
			}
		} 
	}
}

sub adjust_tobuild
{
	my $self = shift;

	my $has = {};
	for my $v (values %{$self->{tobuild}}) {
		# XXX we don't have enough there !
		next if $self->{buildable}->detained($v);
		# due to pkgname aliases, we may have been built through
		# another pkgpath.
		next if $self->{buildable}->is_done_quick($v);
		$self->adjust_depends1($v, $has);
	}

	for my $v (values %{$self->{tobuild}}) {
		# XXX we don't have enough there !
		next if $self->{buildable}->detained($v);
		$self->adjust_depends2($v, $has);
	}
}

sub check_buildable
{
	my ($self, $forced) = @@_;
	my $r = $self->limit($forced, 50, "ENG", 1,
#	    $self->{buildable}->count > 0,
	    sub {
		$self->log('+');
		1 while $self->adjust_built;
		$self->adjust_tobuild;
		$self->flush;
	    });
	$self->stats;
	return $r;
}

sub new_path
{
	my ($self, $v) = @@_;
	if (defined $v->{info}{IGNORE} && 
	    !$self->{state}->{fetch_only}) {
		$self->log('!', $v, " ".$v->{info}{IGNORE}->string);
		$self->stub_out($v);
		return;
	}
	if (defined $v->{info}{MISSING_FILES}) {
		$self->add_fatal($v, "fetch manually", 
		    "Missing distfiles: ".
		    $v->{info}{MISSING_FILES}->string, 
		    $v->{info}{FETCH_MANUALLY}->string);
		return;
	}
#		$self->{heuristics}->todo($v);
	if (!$self->{buildable}->is_done_quick($v)) {
		$self->{tobuild}{$v} = $v;
		$self->log('T', $v);
	}
	my $notyet = 0;
	if (defined $v->{info}{FDEPENDS}) {
		for my $f (values %{$v->{info}{FDEPENDS}}) {
			if ($self->{tofetch}->contains($f) ||
			    $self->{tofetch}{doing}{$f}) {
				next;
			}
			if ($self->{tofetch}->is_done($f)) {
				$v->{info}{distsize} //= 0;
				$v->{info}{distsize} += $f->{sz};
				delete $v->{info}{FDEPENDS}{$f};
				next;
			}
			$self->{tofetch}->add($f);
			$self->log('F', $f);
			$notyet = 1;
		}
	}
	return if $notyet;
	my $has = {};
	$self->adjust_depends1($v, $has);
	$self->adjust_depends2($v, $has);
}

sub requeue
{
	my ($self, $v) = @@_;
	$self->{buildable}->add($v);
	$self->{sizer}->finished($v);
}

sub requeue_dist
{
	my ($self, $v) = @@_;
	$self->{tofetch}->add($v);
}

sub rescan
{
	my ($self, $v) = @@_;
	push(@@{$self->{requeued}}, $v->path);
}

sub add_fatal
{
	my ($self, $v, $error, @@messages) = @@_;
	push(@@{$self->{errors}}, $v);
	$self->log('!', $v, " $error");
	if ($self->{heldlocks}{$v}) {
		print {$self->{heldlocks}{$v}} "error=$error\n";
		delete $self->{heldlocks}{$v};
	} else {
		my $fh = $self->{locker}->lock($v);
		print $fh "error=$error\n" if $fh;
	}
	$self->{logger}->log_error($v, $error, @@messages);
	$self->stub_out($v);
}

sub rebuild_info
{
	my ($self, $core) = @@_;
	my @@l = @@{$self->{requeued}};
	my %d = ();
	$self->{requeued} = [];
	my %subdirs = map {($_->pkgpath_and_flavors, 1)} @@l;

	for my $v (@@l) {
		$self->{buildable}->detain($v);
		if (defined $v->{info}{FDEPENDS}) {
			for my $f (values %{$v->{info}{FDEPENDS}}) {
				$f->forget;
				$self->{tofetch}->detain($f);
				$d{$f} = $f;
			}
		}
		delete $v->{info};
	}
	$self->{state}->grabber->forget_cache;
	$self->{state}->grabber->grab_subdirs($core, \%subdirs, undef);
	for my $v (@@l) {
		$self->{buildable}->release($v);
	}
	for my $f (values %d) {
		$self->{tofetch}->release($f);
	}
}

sub start_new_job
{
	my $self = shift;
	my $r = $self->{buildable}->start;
	$self->flush;
	return $r;
}

sub start_new_fetch
{
	my $self = shift;
	my $r = $self->{tofetch}->start;
	$self->flush;
	return $r;
}

sub can_build
{
	my $self = shift;

	return $self->{buildable}->non_empty || @@{$self->{requeued}} > 0;
}

sub can_fetch
{
	my $self = shift;
	return $self->{tofetch}->non_empty;
}

sub dump_category
{
	my ($self, $k, $fh) = @@_;
	$fh //= \*STDOUT;

	$k =~ m/^./;
	my $q = "\u$&: ";
	my $cache = {};
	for my $v (sort {$a->fullpkgpath cmp $b->fullpkgpath}
	    values %{$self->{$k}}) {
		print $fh $q;
		if (defined $cache->{$v->{info}}) {
			print $fh $v->fullpkgpath, " same as ",
			    $cache->{$v->{info}}, "\n";
		} else {
			$v->quick_dump($fh);
			$cache->{$v->{info}} = $v->fullpkgpath;
		}
	}
}


sub info_dump
{
	my ($self, $fh) = @@_;
	for my $k (qw(tobuild built)) {
		$self->dump_category($k, $fh);
	}
	$self->{buildable}->dump('Q', $fh);
	print $fh "\n";
}

sub end_dump
{
	my ($self, $fh) = @@_;
	$fh //= \*STDOUT;
	for my $v (values %{$self->{built}}) {
		$self->adjust($v, 'RDEPENDS');
	}
	for my $k (qw(tobuild built)) {
		$self->dump_category($k, $fh);
	}
	print $fh "\n";
}

sub smart_dump
{
	my ($self, $fh) = @@_;

	my $h = {};

	for my $v (values %{$self->{tobuild}}) {
		$v->{info}{problem} = 'not built';
		$v->{info}{missing} = $v->{info}{DEPENDS};
		$h->{$v} = $v;
	}

	for my $v (values %{$self->{built}}) {
		$v->{info}{problem} = 'not installable';
		$v->{info}{missing} = $v->{info}{RDEPENDS};
		$h->{$v} = $v;
	}
	for my $v (@@{$self->{errors}}) {
		$v->{info}{problem} = "errored";
		$h->{$v} = $v;
	}
	for my $v (@@{$self->{locks}}) {
		$v->{info}{problem} = "locked";
		$h->{$v} = $v;
	}
	my $cache = {};
	for my $v (sort {$a->fullpkgpath cmp $b->fullpkgpath}
	    values %$h) {
		if (defined $cache->{$v->{info}}) {
			print $fh $v->fullpkgpath, " same as ",
			    $cache->{$v->{info}}, "\n";
			next;
		}
		print $fh $v->fullpkgpath, " ", $v->{info}{problem};
		if (defined $v->{info}{missing}) {
			$self->follow_thru($v, $fh, $v->{info}{missing});
			#print $fh " ", $v->{info}{missing}->string;
		}
		print $fh "\n";
		$cache->{$v->{info}} = $v->fullpkgpath;
	}
	print $fh "\n";
}

sub follow_thru
{
	my ($self, $v, $fh, $list) = @@_;
	my @@d = ();
	my $known = {$v => $v};
	while (1) {
		my $w = (values %$list)[0];
		push(@@d, $w);
		if (defined $known->{$w}) {
			last;
		}
		$known->{$w} = $w;
		if (defined $w->{info}{missing}) {
			$list = $w->{info}{missing};
		} else {
			last;
		}
	}
	print $fh " ", join(' -> ', map {$_->logname} @@d);
}

sub dump
{
	my ($self, $fh) = @@_;
	$fh //= \*STDOUT;
	for my $k (qw(built tobuild installable)) {
		$self->dump_category($k, $fh);
	}
	print $fh "\n";
}

# special case: dump all dependencies at end of listing, and use that to
# restart dpb quicker if we abort and restart.
#
# namely, scan the most important ports first.
#
# use case: when we restart dpb after a few hours, we want the listing job
# to get to groff very quickly, as the queue will stay desperately empty
# otherwise...

sub dump_dependencies
{
	my $self = shift;

	my $cache = {};
	for my $v (DPB::PkgPath->seen) {
		next unless exists $v->{info};
		for my $k (qw(DEPENDS RDEPENDS EXTRA)) {
			next unless exists $v->{info}{$k};
			for my $d (values %{$v->{info}{$k}}) {
				$cache->{$d->fullpkgpath}++;
			}
		}
	}
	my $state = $self->{state};
	$state->{log_user}->rewrite_file($state, $state->{dependencies_log},
	    sub {
	    	my $log = shift;
		for my $k (sort {$cache->{$b} <=> $cache->{$a}} keys %$cache) {
			print $log "$k $cache->{$k}\n";
		}
	    });
}

sub find_best
{
	my ($self, $file, $limit) = @@_;

	my $list = [];
	if (open my $fh, '<', $file) {
		my $i = 0;
		while (<$fh>) {
			if (m/^(\S+)\s\d+$/) {
				push(@@$list, $1);
				$i++;
			}
			last if $i > $limit;
		}
	}
	return $list;
}

package DPB::Stats;
use DPB::Clock;

sub new
{
	my ($class, $state) = @@_;
	my $o = bless { 
	    fh => DPB::Util->make_hot($state->logger->append("stats")),
	    lost_time => 0,
	    statline => ''},
	    	$class;
	DPB::Clock->register($o);
	return $o;
}

sub log
{
	my ($self, $ts, $line) = @@_;
	return if $line eq $self->{statline};

	$self->{statline} = $line;
	print {$self->{fh}} join(' ', $$, int($ts), 
	    int($ts-$self->{lost_time}), $line), "\n";
}

sub stopped_clock
{
	my ($self, $gap) = @@_;
	$self->{lost_time} += $gap;
}

1;
@


1.121
log
@there is no "equivalence list" if we didn't get any info...
@
text
@d2 1
a2 1
# $OpenBSD: Engine.pm,v 1.120 2016/05/21 12:20:10 espie Exp $
d701 1
a701 3
	$state->{log_user}->make_path(File::Basename::dirname(
	    $state->{dependencies_log}));
	$state->{log_user}->run_as(
d703 1
a703 1
		open my $log, '>', $state->{dependencies_log}.'.part' or return;
a706 3
		close $log;
		rename $state->{dependencies_log}.'.part', 
		    $state->{dependencies_log};
@


1.120
log
@keep a global cache of distfile checksum while scanning, allows us to avoid
rescanning the same distfile 50 times...

also display elapsed time at end of build (cosmetic) since that's now trivial
@
text
@d2 1
a2 1
# $OpenBSD: Engine.pm,v 1.119 2016/05/16 13:47:18 espie Exp $
d219 3
d223 2
a231 1
	push(@@{$self->{ignored}}, $v);
@


1.119
log
@change drastically the way LISTING starts up: let dependencies be a permanent
log.

Now that we can SKIPDIR, doing a first LISTING for most important dependencies
is not a trade-off for the full listing.

It allows dpb to start building most important stuff right away, so that
your machines start earlier.

Caveat: if that list of dependencies changes (ports renames), then you will
see errors because ports no longer exist.

I figure I have time to make errors in the first listing "not relevant"
before that becomes an actual issue.
@
text
@d2 1
a2 1
# $OpenBSD: Engine.pm,v 1.118 2016/05/16 10:28:14 espie Exp $
d514 1
@


1.118
log
@add SKIPDIRS semantics: automatically add visited dirs to a passed skip
if it's not empty
@
text
@d2 1
a2 1
# $OpenBSD: Engine.pm,v 1.117 2016/05/08 09:34:25 espie Exp $
d695 13
a707 4
	my $log = $self->{logger}->create("dependencies");
	for my $k (sort {$cache->{$b} <=> $cache->{$a}} keys %$cache) {
		print $log "$k $cache->{$k}\n";
	}
@


1.117
log
@tweak the heuristics to run the engine:
- don't do anything "smart" when the queue is empty. This mostly triggers
at start, and actually hinders dpb from processing more LISTING efficiently
- lower the threshold for "next" engine computation.  Engine cpu usage still
stays within a few percent, but we avoid slumps in the middle, where the
"first" rescan puts the engine out for a while (I should probably look at
a non-linear function).
@
text
@d2 1
a2 1
# $OpenBSD: Engine.pm,v 1.116 2015/10/16 13:04:55 espie Exp $
d514 1
a514 1
	$self->{state}->grabber->grab_subdirs($core, \%subdirs);
@


1.116
log
@add a "summary" log that shows for each non built path, why it was non built.
Makes loops obvious. Probably will come with sorting later on.
@
text
@d2 1
a2 1
# $OpenBSD: Engine.pm,v 1.115 2015/08/24 09:58:00 espie Exp $
d403 2
a404 2
	my $r = $self->limit($forced, 150, "ENG", 
	    $self->{buildable}->count > 0,
@


1.115
log
@tweak things so that errors show up everywhere
@
text
@d2 1
a2 1
# $OpenBSD: Engine.pm,v 1.114 2015/08/16 08:36:53 espie Exp $
d595 65
@


1.114
log
@stub_out broken entries instead of deleting their info.
May help out with some warnings sebastia@@ is seeing.
@
text
@d2 1
a2 1
# $OpenBSD: Engine.pm,v 1.113 2015/06/17 07:31:25 espie Exp $
a424 1
		$self->log('!', $v, " fetch manually");
d483 1
d491 1
a491 1
	$self->{logger}->log_error($v, @@messages);
@


1.113
log
@do detain distfiles as well as paths (need to track them over rescan)
also, since distfiles are "always fetchable", need to check for detained
files before checking for "already done", since already done will want to
check the size...
@
text
@d2 1
a2 1
# $OpenBSD: Engine.pm,v 1.112 2015/06/11 08:42:38 espie Exp $
d492 1
@


1.112
log
@handle distfile failure better.
- we do rescan paths anyway, so make sure we queue only path.
- forgetting distfile details does not get around caching, so do creation
of distfiles in two times. cache is there to ensure unique distfiles, and
we can still forget details.
To do: remove distfiles from queue during forget, because there's no longer
any detail there.
@
text
@d2 1
a2 1
# $OpenBSD: Engine.pm,v 1.111 2015/06/08 11:06:08 espie Exp $
d498 1
d507 2
d516 3
@


1.111
log
@fix long-standing race condition where removing a lock could break things.
That's just more stuff that has to wait while scanning is going on.
@
text
@d2 1
a2 1
# $OpenBSD: Engine.pm,v 1.110 2015/05/10 08:14:14 espie Exp $
d477 1
a477 1
	push(@@{$self->{requeued}}, $v);
@


1.110
log
@rename logger interface to desambiguate vs user.
@
text
@d2 1
a2 1
# $OpenBSD: Engine.pm,v 1.109 2014/12/07 15:18:50 espie Exp $
d385 2
d394 2
@


1.109
log
@wrap die so that it drops into the debugger if we run under perl -d.

change the way we do rescans again, to avoid race conditions:
just store away *all* pkgpaths related to the rescan (so that multi-packages
are covered) and then do the rescan. Hold those like we do for normal locks
but in a different list, and release them when the scan is over.

remove the atrocious shennanigans wrt fullpkgnames, it shouldn't be needed
again, hopefully.
@
text
@d2 1
a2 1
# $OpenBSD: Engine.pm,v 1.108 2014/12/06 18:34:05 espie Exp $
d65 1
a65 1
	$o->{log} = $state->logger->open("engine");
d650 1
a650 1
	    fh => DPB::Util->make_hot($state->logger->open("stats")),
@


1.108
log
@finally tracked down a long-standing bug (hard to reproduce): when
building a port with EXTRA depends (meaning it depends on the dependency
being extractible), the normal rules don't really apply, it's not enough
for the package to exist, the listing must have solved its depends names.
@
text
@d2 1
a2 1
# $OpenBSD: Engine.pm,v 1.107 2014/09/23 18:19:21 espie Exp $
a495 3
	for my $v (@@l) {
		$v->ensure_fullpkgname;
	}
a496 1
	$self->{heldlocks} = {};
d498 1
a498 1
		$self->{heldlocks}{$v} = $self->{locker}->lock($v);
d508 1
a508 2
		next unless $self->{heldlocks}{$v};
		$self->{locker}->unlock($v);
a509 1
	$self->{heldlocks} = {};
@


1.107
log
@refactor the engine code, so that new_path can put some stuff directly on
the queue. This shaves significant cpu during initial scanning...
@
text
@d2 1
a2 1
# $OpenBSD: Engine.pm,v 1.106 2014/06/14 01:23:48 afresh1 Exp $
d244 12
d263 2
a264 1
		if ((defined $d->{info} && !$self->{tobuild}{$d}) ||
@


1.106
log
@Work around perlbug 77706, only hit infrequently on vax.

ok espie@@
@
text
@d2 1
a2 1
# $OpenBSD: Engine.pm,v 1.105 2014/03/17 10:47:12 espie Exp $
d317 49
d375 1
a375 2

		$has->{$v} = $self->adjust($v, 'DEPENDS', 'BDEPENDS');
d379 1
a379 38
		if ($has->{$v} != 0) {
			if (my $d = $self->should_ignore($v, 'DEPENDS')) {
				delete $self->{tobuild}{$v};
			} else {
				$v->{has} = 2;
			}
		} else {
			# okay, thanks to equiv, some other path was marked
			# as stub, and obviously we lost our deps
			if ($v->{info}->is_stub) {
				$self->log_no_ts('!', $v, 
				    " equivalent to an ignored path");
				# just drop it, it's already ignored as
				# an equivalent path
				delete $self->{tobuild}{$v};
				next;
			}
			my $has = $has->{$v} + 
			    $self->adjust_extra($v, 'EXTRA', 'BEXTRA');

			my $has2 = $self->adjust_distfiles($v);
			# being buildable directly is a priority,
			# but put the patch/dist/small stuff down the 
			# line as otherwise we will tend to grab 
			# patch files first
			$v->{has} = 2 * ($has != 0) + ($has2 > 1);
			if ($has + $has2 == 0) {
				delete $self->{tobuild}{$v};
				# XXX because of this, not all build_path_list
				# are considered equal... 
				if ($self->should_ignore($v, 'RDEPENDS')) {
					$self->{buildable}->remove($v);
				} else {
					$self->{buildable}->add($v);
					$self->log_no_ts('Q', $v);
				}
			} 
		}
d420 16
a435 11
	return unless defined $v->{info}{FDEPENDS};
	for my $f (values %{$v->{info}{FDEPENDS}}) {
		if ($self->{tofetch}->contains($f) ||
		    $self->{tofetch}{doing}{$f}) {
			next;
		}
		if ($self->{tofetch}->is_done($f)) {
			$v->{info}{distsize} //= 0;
			$v->{info}{distsize} += $f->{sz};
			delete $v->{info}{FDEPENDS}{$f};
			next;
a436 2
		$self->{tofetch}->add($f);
		$self->log('F', $f);
d438 4
@


1.105
log
@log when we actually run engine, since this is hard to match with perf log.
@
text
@d2 1
a2 1
# $OpenBSD: Engine.pm,v 1.104 2014/03/10 09:06:12 espie Exp $
d188 3
a190 1
	for my $d (values %{$v->{info}{$kind}}) {
@


1.104
log
@note to myself, this makes deduplicating paths in the queue complicated.
@
text
@d2 1
a2 1
# $OpenBSD: Engine.pm,v 1.103 2014/01/18 11:23:48 espie Exp $
d84 5
a88 1
	print $fh "$$\@@$ts: $kind: ", $v->logname, "$extra\n";
d376 1
@


1.103
log
@if we're rescanning, keep the locks around.
That way, add_fatal can keep the path locked, as it should.
@
text
@d2 1
a2 1
# $OpenBSD: Engine.pm,v 1.102 2014/01/09 11:08:51 espie Exp $
d353 2
@


1.102
log
@lock paths during error rescan.
@
text
@d2 1
a2 1
# $OpenBSD: Engine.pm,v 1.101 2013/10/19 09:33:52 espie Exp $
d440 7
a446 2
	my $fh = $self->{locker}->lock($v);
	print $fh "error=$error\n" if $fh;
d460 1
d462 1
a462 1
		$self->{locker}->lock($v);
d472 1
d475 1
@


1.101
log
@isolate dirty details of fullpkgname remanence in its own function,
and fix a stupid bug.
@
text
@d2 1
a2 1
# $OpenBSD: Engine.pm,v 1.100 2013/10/19 09:07:49 espie Exp $
d456 1
d465 3
@


1.100
log
@when we rescan paths, we temporarily delete info. Those paths are
already in the system, and we can't take them out, so keep the "old" pkgname
around until we rescanned succesfully. This avoids race conditions if
handle_non_waiting_jobs gets called while we're still scanning.
@
text
@d2 1
a2 1
# $OpenBSD: Engine.pm,v 1.99 2013/10/19 08:41:29 espie Exp $
d452 1
a452 3
		if (!defined $v->{tmpname}) {
			$v->{tmpname} = $v->fullpkgname;
		}
@


1.99
log
@allow the engine to rebuild_info
@
text
@d2 1
a2 1
# $OpenBSD: Engine.pm,v 1.98 2013/10/13 19:59:06 espie Exp $
d451 6
@


1.98
log
@add the fullpkgname as a comment at the end of the I: lines.
prompted by a question from miod@@
@
text
@d2 1
a2 1
# $OpenBSD: Engine.pm,v 1.97 2013/10/13 18:31:50 espie Exp $
a459 1
	$core->mark_ready;
@


1.97
log
@- use separated Heuristics::Size object
- choose size/nosize in Config.
- use affinity or affinitystub
- move locker creation to State, so we can init cores right away.
- as core init has run, we can call DPB::Core->reap (event loop) while
processing size and build stats, so that the startup script may start
slightly earlier.
- setup more options in Config for Reporter to use.
- scaffolding in SubEngine/Build to be able to use affinity info right away
@
text
@d2 1
a2 1
# $OpenBSD: Engine.pm,v 1.96 2013/10/09 06:20:56 espie Exp $
d301 1
a301 1
			$self->log_no_ts('I', $v);
@


1.96
log
@have start return useful information, like whether it started something
or not, and propagate it thru the engine
@
text
@d2 1
a2 1
# $OpenBSD: Engine.pm,v 1.95 2013/10/07 18:01:33 espie Exp $
d50 1
d421 1
a421 1
	$self->{heuristics}->finish_special($v);
@


1.95
log
@okay, fixed version where NoBuild subengine gets only what it actually
needs
@
text
@d2 1
a2 1
# $OpenBSD: Engine.pm,v 1.94 2013/10/06 15:49:23 espie Exp $
d465 1
a465 1
	$self->{buildable}->start;
d467 1
d473 1
a473 1
	$self->{tofetch}->start;
d475 1
@


1.94
log
@fix -F mode... subengine not yet ready to be split,
and we DON'T want an extra build job.
@
text
@d2 1
a2 1
# $OpenBSD: Engine.pm,v 1.93 2013/10/06 13:33:29 espie Exp $
d37 1
@


1.93
log
@update my copyright to 2013
@
text
@d2 1
a2 1
# $OpenBSD: Engine.pm,v 1.92 2013/10/06 13:22:18 espie Exp $
a36 1
		require DPB::SubEngine::Build;
@


1.92
log
@split some code into separate files, so that it doesn't get
loaded if it's not needed.
@
text
@d2 1
a2 1
# $OpenBSD: Engine.pm,v 1.91 2013/10/03 08:03:27 espie Exp $
d4 1
a4 1
# Copyright (c) 2010 Marc Espie <espie@@openbsd.org>
@


1.91
log
@The "Engine" code is quite daunting, but in reality there are 3 things in
there.

Finally split them for less confusing files.
@
text
@d2 1
a2 1
# $OpenBSD: Engine.pm,v 1.90 2013/09/16 21:29:13 espie Exp $
d31 11
d59 1
a59 2
	$o->{buildable} = ($state->{fetch_only} ? "DPB::SubEngine::NoBuild"
	    : "DPB::SubEngine::Build")->new($o, $state->builder);
d61 1
@


1.90
log
@fix unlock early condition for multi-package
@
text
@d2 1
a2 1
# $OpenBSD: Engine.pm,v 1.89 2013/09/14 14:58:12 espie Exp $
d22 2
a23 553
package DPB::ErrorList::Base;

sub new
{
	my $class = shift;
	bless [], $class;
}

sub recheck
{
	my ($list, $engine) = @@_;
	return if @@$list == 0;
	my $locker = $engine->{locker};

	my @@keep = ();
	while (my $v = shift @@$list) {
		if ($list->unlock_early($v, $engine)) {
			$locker->unlock($v);
			next;
		}
		if ($locker->locked($v)) {
			push(@@keep, $v);
		} else {
			$list->reprepare($v, $engine);
		}
	}
	push(@@$list, @@keep) if @@keep != 0;
}

sub stringize
{
	my $list = shift;
	my @@l = ();
	for my $e (@@$list) {
		my $s = $e->logname;
		if (defined $e->{host} && !$e->{host}->is_localhost) {
			$s .= "(".$e->{host}->name.")";
		}
		if (defined $e->{info} && $e->{info}->has_property('nojunk')) {
			$s .= '!';
		}
		push(@@l, $s);
	}
	return join(' ', @@l);
}

sub reprepare
{
	my ($class, $v, $engine) = @@_;
	$v->requeue($engine);
}

package DPB::ErrorList;
our @@ISA = (qw(DPB::ErrorList::Base));

sub unlock_early
{
	my ($list, $v, $engine) = @@_;
	if ($v->unlock_conditions($engine)) {
		$v->requeue($engine);
		return 1;
	} else {
		return 0;
	}
}

sub reprepare
{
	my ($list, $v, $engine) = @@_;
	$engine->rescan($v);
}

package DPB::LockList;
our @@ISA = (qw(DPB::ErrorList::Base));
sub unlock_early
{
	&DPB::ErrorList::unlock_early;
}

sub stringize
{
	my $list = shift;
	my @@l = ();
	my $done = {};
	for my $e (@@$list) {
		my $s = $e->lockname;
		if (!defined $done->{$s}) {
			push(@@l, $s);
			$done->{$s} = 1;
		}
	}
	return join(' ', @@l);
}

package DPB::NFSList;
our @@ISA = (qw(DPB::ErrorList::Base));

sub reprepare
{
	&DPB::ErrorList::reprepare;
}

sub unlock_early
{
	my ($list, $v, $engine) = @@_;
	my $okay = 1;
	my $sub = $engine->{buildable};
	my $h = $sub->{nfs}{$v};
	while (my ($k, $w) = each %$h) {
		if ($sub->{builder}->end_check($w)) {
			$sub->mark_as_done($w);
			delete $h->{$k};
		} else {
			$okay = 0;
			# infamous
			$engine->log('H', $w);
		}
	}
	if ($okay) {
		delete $sub->{nfs}{$v};
	}
	return $okay;
}



package DPB::SubEngine;
sub new
{
	my ($class, $engine) = @@_;
	bless { engine => $engine, queue => $class->new_queue($engine),
		doing => {}, later => {}}, $class;
}

sub count
{
	my $self = shift;
	return $self->{queue}->count;
}

sub add
{
	my ($self, $v) = @@_;
	$self->{queue}->add($v);
}

sub remove
{
	my ($self, $v) = @@_;
	$self->{queue}->remove($v);
}

sub is_done_quick
{
	my $self = shift;
	return $self->is_done(@@_);
}

sub is_done_or_enqueue
{
	my $self =shift;
	return $self->is_done(@@_);
}

sub sorted
{
	my ($self, $core) = @@_;
	return $self->{queue}->sorted($core);
}

sub non_empty
{
	my $self = shift;
	return $self->{queue}->non_empty;
}

sub contains
{
	my ($self, $v) = @@_;
	return $self->{queue}->contains($v);
}

sub log
{
	my ($self, @@r) = @@_;
	return $self->{engine}->log(@@r);
}

sub key_for_doing
{
	my ($self, $v) = @@_;
	return $v;
}

sub already_done
{
}

sub start_install
{
	return 0;
}

sub lock_and_start_build
{
	my ($self, $core, $v) = @@_;

	$self->remove($v);

	if (my $lock = $self->{engine}{locker}->lock($v)) {
		$self->{doing}{$self->key_for_doing($v)} = 1;
		$self->start_build($v, $core, $lock);
		return 1;
	} else {
		push(@@{$self->{engine}{locks}}, $v);
		$self->log('L', $v);
		return 0;
	}
}

sub start
{
	my $self = shift;
	my $core = $self->get_core;

	if (@@{$self->{engine}{requeued}} > 0) {
		$self->{engine}->rebuild_info($core);
		return;
	}
	if ($self->start_install($core)) {
		return;
	}
	my $o = $self->sorted($core);

	# note we don't actually remove stuff from the queue until needed, 
	# so mismatches holds a copy of stuff that's still there.
	my @@mismatches = ();

	# first pass, try to find something we can build
	while (my $v = $o->next) {
		# trim stuff that's done
		if ($self->is_done($v)) {
			$self->already_done($v);
			$self->done($v);
			next;
		}
		# ... and stuff that's related to other stuff building
		if ($self->{doing}{$self->key_for_doing($v)}) {
			$self->remove($v);
			$self->{later}{$v} = $v;
			$self->log('^', $v);
			next;
		}
		if ($self->check_for_memory_hogs($v, $core)) {
			push(@@mismatches, $v);
			next;
		}
		# keep affinity mismatches for later
		if (defined $v->{affinity} && !$core->matches($v->{affinity})) {
			$self->log('A', $v, 
			    " ".$core->hostname." ".$v->{affinity});
			# try to start them anyways, on the "right" core
			my $core2 = DPB::Core->get_affinity($v->{affinity});
			if (defined $core2) {
				if ($self->lock_and_start_build($core2, $v)) {
					next;
				} else {
					$core2->mark_ready;
				}
			}
			push(@@mismatches, $v);
			next;
		}
		# if there's no external lock, we can build
		if ($self->lock_and_start_build($core, $v)) {
			return;
		}
	}
	# let's make sure we don't have something else first
	if (@@mismatches > 0) {
		if ($self->{engine}->check_buildable(1)) {
			$core->mark_ready;
			return $self->start;
		}
	}
	# second pass, affinity mismatches
	for my $v (@@mismatches) {
		if ($self->lock_and_start_build($core, $v)) {
			$self->log('Y', $v, 
			    " ".$core->hostname." ".$v->{affinity});
			return;
		}
	}
	# couldn't build anything, don't forget to give back the core.
	$core->mark_ready;
}

sub done
{
	my ($self, $v) = @@_;
	my $k = $self->key_for_doing($v);
	for my $candidate (values %{$self->{later}}) {
		if ($self->key_for_doing($candidate) eq $k) {
			delete $self->{later}{$candidate};
			$self->log('V', $candidate);
			$self->add($candidate);
		}
	}
	delete $self->{doing}{$self->key_for_doing($v)};
	$self->{engine}->recheck_errors;
}

sub end
{
	my ($self, $core, $v, $fail) = @@_;
	my $e = $core->mark_ready;
	if ($fail) {
		$core->failure;
		if (!$e || $core->{status} == 65280) {
			$self->add($v);
			$self->{engine}{locker}->unlock($v);
			$self->log('N', $v);
		} else {
			# XXX in case some packages got built
			$self->is_done($v);
			unshift(@@{$self->{engine}{errors}}, $v);
			$v->{host} = $core->host;
			$self->log('E', $v);
			if ($core->prop->{always_clean}) {
				$self->end_build($v);
			}
		}
	} else {
		if ($self->is_done_or_enqueue($v)) {
			$self->{engine}{locker}->unlock($v);
		} else {
			push(@@{$self->{engine}{nfslist}}, $v);
		}
		$self->end_build($v);
		$core->success;
	}
	$self->done($v);
	$self->{engine}->flush;
}

sub dump
{
	my ($self, $k, $fh) = @@_;
#	$self->{queue}->dump($k, $fh);
}

sub check_for_memory_hogs
{
	return 0;
}

package DPB::SubEngine::Build;
our @@ISA = qw(DPB::SubEngine);
sub new
{
	my ($class, $engine, $builder) = @@_;
	my $o = $class->SUPER::new($engine);
	$o->{builder} = $builder;
	$o->{toinstall} = [];
	$o->{nfs} = {};
	return $o;
}

sub will_install
{
	my ($self, $v) = @@_;
	push(@@{$self->{toinstall}}, $v);
}

sub start_install
{
	my ($self, $core) = @@_;
	return 0 unless $core->is_local;
	if (my $v = pop @@{$self->{toinstall}}) {
		$self->{builder}->install($v, $core);
		return 1;
	} else {
		return 0;
	}
}

sub non_empty
{
	my $self = shift;
	return  $self->SUPER::non_empty || @@{$self->{toinstall}} > 0;
}

sub new_queue
{
	my ($class, $engine) = @@_;
	return $engine->{heuristics}->new_queue;
}

sub mark_as_done
{
	my ($self, $v) = @@_;
	$self->{engine}{affinity}->unmark($v);
	delete $self->{engine}{tobuild}{$v};
	delete $v->{info}{DIST};
#	$self->{heuristics}->done($v);
	if (defined $self->{later}{$v}) {
		$self->log('V', $v);
		delete $self->{later}{$v};
	}
	if (!defined $self->{engine}{built}{$v}) {
		$self->{engine}{built}{$v}= $v;
		$self->log('B', $v);
	}
	$self->remove($v);
}

sub is_done_or_enqueue
{
	my ($self, $v) = @@_;
	my $okay = 1;
	for my $w ($v->build_path_list) {
		if ($self->{builder}->end_check($w)) {
			$self->mark_as_done($w);
		} else {
			$self->{nfs}{$v}{$w} = $w;
			$okay = 0;
		}
	}
	return $okay;
}

sub is_done
{
	my ($self, $v) = @@_;
	if ($self->{builder}->check($v)) {
		for my $w ($v->build_path_list) {
			next if $v eq $w;
			next unless $self->{builder}->check($w);
			$self->mark_as_done($w);
		}
	}
	return $self->is_done_quick($v);
}

sub is_done_quick
{
	my ($self, $v) = @@_;
	if ($self->{builder}->check($v)) {
		$self->mark_as_done($v);
		return 1;
	} else {
		return 0;
	}
}

sub get_core
{
	my $self = shift;
	return $self->{builder}->get;
}

sub key_for_doing
{
	my ($self, $v) = @@_;
	return $v->pkgpath;
}

sub already_done
{
	my ($self, $v) = @@_;
	$self->{engine}{logger}->make_log_link($v);
}

sub start_build
{
	my ($self, $v, $core, $lock) = @@_;
	$self->log('J', $v, " ".$core->hostname);
	$self->{engine}{affinity}->start($v, $core);
	$self->{builder}->build($v, $core, $lock, 
	    sub {
	    	my $fail = shift;
	    	$self->end($core, $v, $fail);
	    });
}

sub end_build
{
	my ($self, $v) = @@_;
	$self->{engine}{affinity}->finished($v);
	$self->{engine}{heuristics}->finish_special($v);
}

sub check_for_memory_hogs
{
	my ($self, $v, $core) = @@_;
	if ($v->{info}->has_property('memoryhog')) {
		for my $job ($core->same_host_jobs) {
			if ($job->{v}{info}->has_property('memoryhog')) {
				return 1;
			}
		}
	}
	return 0;
}

# for fetch-only, we do the same as Build, except we're never happy
package DPB::SubEngine::NoBuild;

our @@ISA = qw(DPB::SubEngine::Build);
sub is_done
{
	return 0;
}

package DPB::SubEngine::Fetch;
our @@ISA = qw(DPB::SubEngine);
sub new_queue
{
	my ($class, $engine) = @@_;
	return DPB::Heuristics::FetchQueue->new($engine->{heuristics});
}

sub is_done
{
	my ($self, $v) = @@_;
	return 1 if $v->{done};
	if ($v->check($self->{engine}{logger})) {
		$self->log('B', $v);
		$v->{done} = 1;
		return 1;
	} else {
		return 0;
    	}
}

sub get_core
{
	return DPB::Core::Fetcher->get;
}

sub start_build
{
	my ($self, $v, $core, $lock) = @@_;
	$self->log('J', $v);
	DPB::Fetch->fetch($self->{engine}{logger}, $v, $core,
	    sub { 
	    	$self->end($core, $v, $core->{status});
	    });
}

sub end_build
{
}
@


1.89
log
@tweak time handling a bit, introduce a "real" vs "perceived" time in stats
for people like me who do ^Z a lot.
@
text
@d2 1
a2 1
# $OpenBSD: Engine.pm,v 1.88 2013/09/06 17:11:01 espie Exp $
d133 1
a133 1
			delete $h->{$w};
d137 1
a137 1
			$engine->log('H', $v);
@


1.88
log
@even with Time::Hires, always log ts in the engine without decimals,
makes for crappy logs otherwise...
@
text
@d2 1
a2 1
# $OpenBSD: Engine.pm,v 1.87 2013/08/28 12:00:39 espie Exp $
d605 1
a605 1
	$o->{stats} = DPB::Util->make_hot($state->logger->open("stats"));
d622 2
a623 1
	print $fh "$$\@@$self->{ts}: $kind: ", $v->logname, "$extra\n";
d629 1
a629 1
	$self->{ts} = CORE::time();
d705 1
a705 7
	my $fh = $self->{stats};
	$self->{statline} //= "";
	my $line = $self->statline;
	if ($line ne $self->{statline}) {
		$self->{statline} = $line;
		print $fh $$, " ", $self->{ts}, " ", $line, "\n";
	}
d1129 31
@


1.87
log
@so new_path relies on the pkgname being there, but the engine proper doesn't.
confuses the hell out of some people (hi naddy!) as dpb restarts will notice
built packages regardless of the path.

make things more symetric by doing the check each time we go through tobuild.

I have some misgivings about this, since this is potentially expensive...
@
text
@d2 1
a2 1
# $OpenBSD: Engine.pm,v 1.86 2013/08/07 06:56:42 espie Exp $
d628 1
a628 1
	$self->{ts} = time();
@


1.86
log
@make sure the new nfs watch stuff works (unconfuse engine/subengine
relationship) now that landry@@ can trigger this reproducibly.
@
text
@d2 1
a2 1
# $OpenBSD: Engine.pm,v 1.85 2013/07/21 16:24:32 espie Exp $
d861 4
@


1.85
log
@the major change from a few days ago completely broke dpb -R (reported
by fgs@@, kili@@, nigel@@)
repair it.
- introduce end_check to cope with package files updated
(not quite satisfied with the source code, but this works, and will do for
5.4).
- adjust report to build.log to conform to the new semantics: namely, if it
didn't fail, then it's okay, don't even look at possibly missing packages
because of nfs (noticed by nigel@@).
@
text
@d2 1
a2 1
# $OpenBSD: Engine.pm,v 1.84 2013/07/18 05:36:54 espie Exp $
d128 2
a129 1
	my $h = $engine->{nfs}{$v};
d131 2
a132 2
		if ($engine->{builder}->end_check($w)) {
			$engine->mark_as_done($w);
d141 1
a141 1
		delete $engine->{nfs}{$v};
d358 1
a358 1
			push(@@{$self->{nfslist}}, $v);
@


1.84
log
@change the way errors are handled, fixed version:
- pass error condition from Job/Port.pm all the way to the engine
- use that to know whether we fail, instead of the existence of packages
(but still keep track of what we're doing correctly, THAT'S the fix)
- refactor error handling into OO version
- keep track of locks/errors/packages we're waiting for thx to nfs

all of these keep the lock around, and react to the lock being removed.

use case for nfs: if there was a revision bump after dpb scanned the port,
it will never find the package. Removing the lock will allow dpb to rescan
and find the correct packages.

with this, dpb no longer waits after nfs. More importantly, it does not
report nfs hangs as E:, rather as H:... (and it can "wait" for much longer
periods, since it keeps running and only checks on new jobs).
@
text
@d2 1
a2 1
# $OpenBSD: Engine.pm,v 1.83 2013/06/30 16:45:16 espie Exp $
d130 1
a130 1
		if ($engine->{builder}->check($w)) {
d442 1
a442 1
		if ($self->{builder}->check($w)) {
@


1.83
log
@if core is running in "always_clean" mode, always remove the affinity marker
if we find out we got cleansed...
@
text
@d2 1
a2 1
# $OpenBSD: Engine.pm,v 1.82 2013/06/25 07:49:52 espie Exp $
d22 125
d179 6
d245 1
d335 1
a335 1
	my ($self, $core, $v) = @@_;
d337 1
a337 5
	if ($self->is_done($v)) {
		$self->{engine}{locker}->unlock($v);
		$self->end_build($v);
		$core->success;
	} else {
d344 2
d353 8
d385 1
d437 15
d499 5
a503 1
	$self->{builder}->build($v, $core, $lock, sub {$self->end($core, $v)});
d566 3
a568 1
	    sub { $self->end($core, $v)});
d592 3
a594 2
	    errors => [],
	    locks => [],
d611 3
a613 5
	if (@@{$self->{errors}} != 0 || @@{$self->{locks}} != 0) {
		$self->{locker}->recheck_errors($self);
		return 1;
	}
	return 0;
a649 32
sub errors_string
{
	my ($self, $name) = @@_;
	my @@l = ();
	for my $e (@@{$self->{$name}}) {
		my $s = $e->logname;
		if (defined $e->{host} && !$e->{host}->is_localhost) {
			$s .= "(".$e->{host}->name.")";
		}
		if (defined $e->{info} && $e->{info}->has_property('nojunk')) {
			$s .= '!';
		}
		push(@@l, $s);
	}
	return join(' ', @@l);
}

sub lock_errors_string
{
	my ($self, $name) = @@_;
	my @@l = ();
	my $done = {};
	for my $e (@@{$self->{$name}}) {
		my $s = $e->lockname;
		if (!defined $done->{$s}) {
			push(@@l, $s);
			$done->{$s} = 1;
		}
	}
	return join(' ', @@l);
}

d695 3
a697 2
	    $self->may_add("L=", $self->lock_errors_string("locks")).
	    $self->may_add("E=", $self->errors_string("errors"));
@


1.82
log
@should fix some of sebastia's warnings... these are actually old
@
text
@d2 1
a2 1
# $OpenBSD: Engine.pm,v 1.81 2013/06/23 09:04:39 espie Exp $
d219 3
@


1.81
log
@stub_out only removes build_path_list.
equivalent paths will end up with no depends, as they actually share
info, but still on queues.

So do a sanity check when stuff has no depends: if it's stubbed out, just
drop it, as it's been ignored under another name.

Problem noticed and info provided by landry@@

(it's all vax's fault anyways, as stub_out is only needed to let dpb fit
within 32M while gobbling thousands of ports info)
@
text
@d2 1
a2 1
# $OpenBSD: Engine.pm,v 1.80 2013/06/17 10:47:44 espie Exp $
d627 2
@


1.80
log
@no use writing code if you don't use it, right ?
@
text
@d2 1
a2 1
# $OpenBSD: Engine.pm,v 1.79 2013/06/16 13:17:59 espie Exp $
d698 9
d738 10
@


1.79
log
@don't recheck the same file again and again. we can cache it properly here
@
text
@d2 1
a2 1
# $OpenBSD: Engine.pm,v 1.78 2013/06/15 20:06:50 espie Exp $
d198 1
a198 1
	$self->{engine}{locker}->recheck_errors($self->{engine});
@


1.78
log
@zap complicated bogus logic,
fetch+immediate build should work much better now.
@
text
@d2 1
a2 1
# $OpenBSD: Engine.pm,v 1.77 2013/05/01 22:39:24 espie Exp $
d385 1
d388 1
@


1.77
log
@oops, if the error is dire enough, there's no info.
@
text
@d2 1
a2 1
# $OpenBSD: Engine.pm,v 1.76 2013/04/30 10:22:36 espie Exp $
a384 3
	if ($v->checked_already) {
		return 1;
	}
@


1.76
log
@add ! to ports that prevent junk from happening, so that you know why it
doesn't junk.

spell out a bit more that logs and locks do NOT need to be shared.
@
text
@d2 1
a2 1
# $OpenBSD: Engine.pm,v 1.75 2013/04/22 19:34:10 espie Exp $
d498 1
a498 1
		if ($e->{info}->has_property('nojunk')) {
@


1.75
log
@make sure things end up in a sane state. In particular, we may add the
same path several times (which is fine for hashes), but we should deal
with RDEPENDS in a consistent way...

problem "noticed" by landry.
@
text
@d2 1
a2 1
# $OpenBSD: Engine.pm,v 1.74 2013/04/15 13:44:06 espie Exp $
d497 3
@


1.74
log
@stub_out() to remove a bit more packages in an agressive way.
@
text
@d2 1
a2 1
# $OpenBSD: Engine.pm,v 1.73 2013/02/02 13:35:17 espie Exp $
d738 3
a740 1
				if (!$self->should_ignore($v, 'RDEPENDS')) {
@


1.73
log
@move control of the "building in mfs" part under PortsBuilder/Heuristics.
Store previous pkgname.
do show-size only sporadically if fullpkgname didn't change
@
text
@d2 1
a2 1
# $OpenBSD: Engine.pm,v 1.72 2013/01/28 10:14:17 espie Exp $
d620 12
d639 1
a639 2
		$v->{info} = DPB::PortInfo->stub;
		push(@@{$self->{ignored}}, $v);
d767 1
a767 2
		$v->{info} = DPB::PortInfo->stub;
		push(@@{$self->{ignored}}, $v);
@


1.72
log
@tweak memory handling to make it less special: treat -M as an override_prop
as we should.
Use core methods to access the memory threshold.

UI simplification: -M can take a suffix, default is K, but you can just say
-M 520M or -M 2G now.
@
text
@d2 1
a2 1
# $OpenBSD: Engine.pm,v 1.71 2013/01/10 10:30:13 espie Exp $
d340 1
a340 2
	my $special = $self->{engine}{heuristics}->special_parameters($core, $v);
	$self->log('J', $v, " ".$core->hostname." ".$special);
d342 1
a342 2
	$self->{builder}->build($v, $core, $special,
	    $lock, sub {$self->end($core, $v)});
@


1.71
log
@'memoryhog' property: avoid starting two such jobs on the same host, if
possible (mostly to be used for moz stuff which gobbles huge amounts of
memory while linking)
@
text
@d2 1
a2 1
# $OpenBSD: Engine.pm,v 1.69 2013/01/05 13:39:36 espie Exp $
d340 1
a340 2
	my $special = $self->{engine}{heuristics}->
	    special_parameters($core->host, $v);
@


1.70
log
@zap info DIST if we don't actually need it.
@
text
@d142 4
d231 5
d353 13
@


1.69
log
@crank factors up to 150, so that dpb consumes a bit less cpu yet.
@
text
@d2 1
a2 1
# $OpenBSD: Engine.pm,v 1.68 2013/01/04 19:34:10 espie Exp $
d273 1
@


1.68
log
@switch to IO::File and explicit flush for the engine log.
should be slightly faster
@
text
@d2 1
a2 1
# $OpenBSD: Engine.pm,v 1.67 2013/01/04 12:06:25 espie Exp $
d719 1
a719 1
	my $r = $self->limit($forced, 100, "ENG", 
@


1.67
log
@take the rate-limiting concept used for the engine, and make it available
elsewhere. Also use it for the Reporter, as it makes no sense to spend
THAT much time reporting quick changes, which actually slows the build.
($factor to tweak as needed).
@
text
@d2 1
a2 1
# $OpenBSD: Engine.pm,v 1.66 2013/01/03 15:47:45 espie Exp $
d218 1
d420 1
a420 1
	$o->{log} = DPB::Util->make_hot($state->logger->open("engine"));
d450 6
d724 1
d820 1
d827 1
@


1.66
log
@tweak the Engine some more: don't bother adjusting distfiles in a loop
while dependencies are missing

Following landry's remark, also take packages to build out of the race
if some RUN_DEPENDS are going to be ignored. Only do it right before we
put the package in the queue, so that the test is run exactly once per
package instead of during every scan.

I was also worried about multi-packages, but this only takes one fullpkgpath
out of the loop, and "make package" is going to fail half-way through anyways.
@
text
@d2 1
a2 1
# $OpenBSD: Engine.pm,v 1.65 2013/01/02 11:13:52 espie Exp $
d21 1
d393 1
a420 2
	$o->{next_check} = $o->{ts};
	$o->{perf} = DPB::Util->make_hot($state->logger->open("engine-perf"));
a708 1
use Time::HiRes;
d712 6
a717 19
	$self->{ts} = time();
	my $temp = $self->{perf};
	print $temp "$$\@@$self->{ts}: ";
	if (!($forced && $self->{unchecked}) &&
	    $self->{ts} < $self->{next_check} && 
	    $self->{buildable}->count > 0) {
	    	print $temp "-\n";
		$self->{unchecked} = 1;
		$self->stats;
		return 0;
	}

	delete $self->{unchecked};
	# actual computation
	my $start = Time::HiRes::time();
	1 while $self->adjust_built;
	$self->adjust_tobuild;
	my $end = Time::HiRes::time();

d719 1
a719 15
	# adjust values for next time
	my $check_interval = 100 * ($end - $start);
	my $offset = $self->{ts} - $self->{next_check};
	$offset /= 2;
	print $temp sprintf("%.2f ", $offset);

	$self->{next_check} = $self->{ts} + $check_interval;
	if ($offset > 0) {
	    $self->{next_check} -= $offset;
	}
	if ($self->{next_check} < $end) {
		$self->{next_check} = $end;
	}
	print $temp sprintf(" %.2f %.2f\n", $self->{next_check}, $check_interval);
	return 1;
@


1.65
log
@stats are comparatively cheap, run them even when the engine doesn't run.
Yields more accurate stat output, where we can see a staircase effect on
the queue when the engine is run not that often, and Built actually go
up until it goes back down again.
@
text
@d2 1
a2 1
# $OpenBSD: Engine.pm,v 1.64 2012/12/30 14:33:46 espie Exp $
d583 1
a583 1
sub should_ignore
d593 15
d664 1
a664 1
		} elsif (my $d = $self->should_ignore($v, 'RDEPENDS')) {
a665 2
			$self->log_no_ts('!', $v, 
			    " because of ".$d->fullpkgpath);
a666 2
			$v->{info} = DPB::PortInfo->stub;
			push(@@{$self->{ignored}}, $v);
d682 9
a690 1
		my $has = $has->{$v} + $self->adjust_extra($v, 'EXTRA', 'BEXTRA');
d692 13
a704 16
		my $has2 = $self->adjust_distfiles($v);
		# being buildable directly is a priority,
		# but put the patch/dist/small stuff down the 
		# line as otherwise we will tend to grab 
		# patch files first
		$v->{has} = 2 * ($has != 0) + ($has2 > 1);
		if ($has + $has2 == 0) {
			$self->{buildable}->add($v);
			$self->log_no_ts('Q', $v);
			delete $self->{tobuild}{$v};
		} elsif (my $d = $self->should_ignore($v, 'DEPENDS')) {
			delete $self->{tobuild}{$v};
			$self->log_no_ts('!', $v, 
			    " because of ".$d->fullpkgpath);
			$v->{info} = DPB::PortInfo->stub;
			push(@@{$self->{ignored}}, $v);
@


1.64
log
@mismatches are more annoying than extra cpu:
if we end up with only mismatches and we didn't run check_buildable last
time around, try a check_buildable first.
@
text
@d2 1
a2 1
# $OpenBSD: Engine.pm,v 1.63 2012/12/30 11:47:24 espie Exp $
d705 1
@


1.63
log
@why not ? track total distsize for each port. might correlate with other
stuff later.
@
text
@d2 1
a2 1
# $OpenBSD: Engine.pm,v 1.62 2012/12/29 19:15:37 espie Exp $
d162 7
d696 1
a696 1
	my $self = shift;
d700 3
a702 1
	if ($self->{ts} < $self->{next_check} && $self->{buildable}->count > 0) {
d704 2
a705 1
		return;
d708 1
d730 1
@


1.62
log
@smarter affinity mismatch handling: if we have other cores idle, ask them.

also, officialize the engine-perf log somewhat (and give it a more descriptive
name).
@
text
@d2 1
a2 1
# $OpenBSD: Engine.pm,v 1.61 2012/12/28 06:40:11 espie Exp $
d614 2
d751 2
@


1.61
log
@remove optimization that no longer makes sense.
@
text
@d2 1
a2 1
# $OpenBSD: Engine.pm,v 1.60 2012/12/27 16:23:17 espie Exp $
d122 2
a123 2
	# note we don't remove stuff from the queue until needed, so
	# mismatches has a copy of stuff that's still there.
d145 9
d170 1
a170 1
	# couldn't build anything, so we give back the core.
a388 2
my $temp;

d413 1
a413 1
	$temp = DPB::Util->make_hot($state->logger->open("times"));
d689 1
@


1.60
log
@replace next_check = last_check + check_interval

tweak the algorithm slightly (since we forget the old check_interval).
In particular, never keep old times in reserve.

Makes for simpler and clearer reading
@
text
@d2 1
a2 1
# $OpenBSD: Engine.pm,v 1.59 2012/12/27 14:14:19 espie Exp $
a264 1
	delete $v->{new};
d647 1
a647 1
	my ($self, $quick) = @@_;
a650 1
		next if $quick && !$v->{new};
a654 2
		next if $quick && !$v->{new};
		delete $v->{new};
d680 1
a680 1
	my ($self, $quick) = @@_;
d691 1
a691 1
	$self->adjust_tobuild($quick);
@


1.59
log
@remove the need to loop around adjust_tobuild, fudge things a bit:

Most things will move as a result of {install} changes.

Things that move because of EXTRA depends that are satisfied are unlikely to trigger
further changes.

So, stagger changes for "normal" tobuild -> queue first, and extra depends later.
@
text
@d2 1
a2 1
# $OpenBSD: Engine.pm,v 1.58 2012/12/27 11:04:43 espie Exp $
a396 1
	    check_interval => 30,
d406 1
a406 1
	$o->{last_check} = $o->{ts} - $o->{check_interval};
d687 1
a687 2
	if ($self->{ts} < $self->{last_check} + $self->{check_interval} && 
	    $self->{buildable}->count > 0) {
d691 2
d696 1
d698 4
a701 4
	my $end = Time::HiRes::time();
	$self->{check_interval} = 100 * ($end - $start);
	my $offset = $self->{ts} - 
	    ($self->{last_check} + $self->{check_interval});
d704 2
a705 1
	$self->{last_check} = $self->{ts};
d707 4
a710 1
	    $self->{last_check} -= $offset;
d712 1
a712 3
	print $temp sprintf(" %.2f ", $self->{last_check});
	print $temp sprintf("%.2f\n", $self->{check_interval});
	$self->stats;
@


1.58
log
@remove 'dead' cycles: changes in ToBuild can't trigger new changes in Built.
@
text
@d2 1
a2 1
# $OpenBSD: Engine.pm,v 1.57 2012/12/25 20:41:41 espie Exp $
d651 6
a656 1
	my $changes = 0;
d660 1
a660 2
		my $has = $self->adjust($v, 'DEPENDS', 'BDEPENDS');
		$has += $self->adjust_extra($v, 'EXTRA', 'BEXTRA');
a671 1
			$changes++;
a675 1
			$changes++;
a679 1
	return $changes;
d694 2
a695 8
	my $changes;
	do {
		$changes = 0;
		$changes += $self->adjust_built if !$quick;
	} while ($changes);
	do {
		$changes = 0;
		$changes += $self->adjust_tobuild($quick);
a696 1
	} while ($changes);
@


1.57
log
@self-adaptive delay... with a bit of log scaffolding for now.
@
text
@d2 1
a2 1
# $OpenBSD: Engine.pm,v 1.56 2012/12/25 16:07:02 espie Exp $
d686 1
d689 1
a689 1
	    	print $temp "$self->{ts}: -\n";
d697 3
d708 1
a708 2
	print $temp $self->{ts}, sprintf(": %.2f ", $offset);
#	$self->{last_check} = $self->{ts};
@


1.56
log
@if we have a sizeable queue (>50) and we ran check_buildable less than 30s
ago, don't run it again right now.

This prevents the Engine from busy-checking the same data when it's building
lots of small packages very fast.

(50 and 30 may need some fine-tuning)
@
text
@d2 1
a2 1
# $OpenBSD: Engine.pm,v 1.55 2012/12/25 09:46:24 espie Exp $
d381 2
d397 1
a397 1
	    last_check => 0,	# never
d407 2
d681 1
d686 3
a688 2
	if ($self->{ts} < $self->{last_check} + 30 && 
	    $self->{buildable}->count > 50) {
d691 1
a691 1
	$self->{last_check} = $self->{ts};
d699 13
@


1.55
log
@also take things off the later list if they were there. Prevents behavior
like the following:

14426@@1356424364: B: x11/kde/graphics3
14426@@1356424364: B: x11/kde/graphics3,-kpov
14426@@1356424364: B: x11/kde/graphics3,-kamera
14426@@1356424364: B: x11/kde/graphics3,-sane
14426@@1356424364: B: x11/kde/graphics3,-main
14426@@1356424364: V: x11/kde/graphics3,-kpov	<--- note put back on queue
14426@@1356424364: V: x11/kde/graphics3
14426@@1356424364: V: x11/kde/graphics3,-kamera
14426@@1356424364: I: x11/kde/graphics3,-sane
14426@@1356424364: I: x11/kde/graphics3
14426@@1356424364: I: x11/kde/graphics3,-kamera
14426@@1356424364: I: x11/kde/graphics3,-main
14426@@1356424366: J: graphics/povray echo.home 0
14426@@1356424496: B: devel/goffice
14426@@1356424496: I: devel/goffice
14426@@1356424496: Q: math/gnumeric
14426@@1356424498: B: x11/kde/graphics3		<--- so, duh rebuilt...
14426@@1356424498: B: x11/kde/graphics3,-main
14426@@1356424498: B: x11/kde/graphics3,-kamera
14426@@1356424498: B: x11/kde/graphics3,-sane
14426@@1356424498: J: graphics/opencv,-docs echo.home 0
14426@@1356424675: B: graphics/povray
14426@@1356424675: I: x11/kde/graphics3,-sane
14426@@1356424675: I: graphics/povray
14426@@1356424675: I: x11/kde/graphics3		<-- and installable, again.
14426@@1356424675: I: x11/kde/graphics3,-kpov
14426@@1356424675: I: x11/kde/graphics3,-kamera
14426@@1356424675: I: x11/kde/graphics3,-main
@
text
@d2 1
a2 1
# $OpenBSD: Engine.pm,v 1.54 2012/12/25 09:31:54 espie Exp $
d394 2
d681 5
@


1.54
log
@will work better with a non-reversed test...
@
text
@d2 1
a2 1
# $OpenBSD: Engine.pm,v 1.53 2012/12/24 17:24:46 espie Exp $
d256 4
@


1.53
log
@add affinity information to restart jobs on the right host preferentially.
- affinity info is similar to locks, but with a completely different
lifetime.
- streamline the main loop of the engine, so that it can do two passes:
first pass shuns paths with the wrong affinity. If no good path is found,
those are considered during the second pass.
- make the Core factory aware of what hosts might be running, so that
affinity info for machines removed from a config file will be ignored.

thanks to landry@@ for a few tests.
@
text
@d2 1
a2 1
# $OpenBSD: Engine.pm,v 1.52 2012/12/24 17:22:15 espie Exp $
d269 1
a269 1
			next unless $v eq $w;
@


1.52
log
@be slightly more aggressive when a pkgpath is done: for multi-packages,
zap all subpackages from the queue.

need to distinguish the normal case (is_done) with a simpler case
(is_done_quick) that's used when scanning the ports tree. Otherwise, we
would check multi-packages loads of time.
@
text
@d2 1
a2 1
# $OpenBSD: Engine.pm,v 1.51 2012/12/21 12:26:16 espie Exp $
d92 17
d118 1
a118 1
		return $core;
d121 6
d128 1
a128 1
		$self->remove($v);
d134 1
d136 1
d139 20
a158 6
		} elsif (my $lock = $self->{engine}{locker}->lock($v)) {
			$self->{doing}{$self->key_for_doing($v)} = 1;
			return $self->start_build($v, $core, $lock);
		} else {
			push(@@{$self->{engine}{locks}}, $v);
			$self->log('L', $v);
d161 1
d312 1
d320 1
d387 1
@


1.51
log
@quicker restart: when adding a new_path, directly check whether it
was built already... so things will go straight to B/I instead of
getting through T/Q...
less noise in engine.log, and much more accurate information for choosing
queue items.
@
text
@d2 1
a2 1
# $OpenBSD: Engine.pm,v 1.50 2012/10/08 12:41:03 espie Exp $
d47 6
d210 14
d228 14
a241 5
#		$self->{heuristics}->done($v);
		$self->{engine}{built}{$v}= $v;
		$self->log('B', $v);
		delete $self->{engine}{tobuild}{$v};
		delete $v->{new};
d661 1
a661 1
	if (!$self->{buildable}->is_done($v)) {
@


1.50
log
@small change for people running multiple hosts:

options on the command line now define *defaults* that host files can
override (for instance -j, stuck, -p, -J).

Add -p /n to mean "take number of jobs, if >1, divide by n, round up to 2,
and use that for parallel.

Document -p.

Make junk be 'by host' (and it's a prop, so you can tweak it).

concurrent log that records how many jobs are running each time it changes.
tag parallel builds *n in the time record.
@
text
@d2 1
a2 1
# $OpenBSD: Engine.pm,v 1.49 2012/09/23 18:13:32 espie Exp $
d632 4
a635 2
	$self->{tobuild}{$v} = $v;
	$self->log('T', $v);
@


1.49
log
@new framework to deal with the new ports cluster, to be documented
@
text
@d2 1
a2 1
# $OpenBSD: Engine.pm,v 1.48 2012/07/10 09:38:37 espie Exp $
d243 1
a243 1
	$self->{builder}->build($v, $core, $special, $core->parallel,
@


1.48
log
@fuck me harder. Separate cases where fullpkgname is allowed not to
be defined, so that instead of bad stringizations, we get full time errors.

Maybe then I can debug this.
@
text
@d2 1
a2 1
# $OpenBSD: Engine.pm,v 1.47 2012/04/07 12:16:58 espie Exp $
d243 1
a243 1
	$self->{builder}->build($v, $core, $special,
@


1.47
log
@elide empty L= / E= lines
@
text
@d2 1
a2 1
# $OpenBSD: Engine.pm,v 1.46 2012/01/30 15:11:04 espie Exp $
d507 1
a507 1
		    (defined $d->fullpkgname &&
@


1.46
log
@finish distfiles history handling: people who don't fetch/build the whole
tree may want to weed distfiles too, so allow for a full scan of the tree
without building/fetching anything, just to update history:

dpb -DHISTORY_ONLY

(just requires making sure the right engines are created, and a very shortened
loop at end waiting for history to be updated).
@
text
@d2 1
a2 1
# $OpenBSD: Engine.pm,v 1.45 2012/01/23 10:35:38 espie Exp $
d424 10
d442 2
a443 2
	    "L=".$self->lock_errors_string('locks')."\n".
	    "E=".$self->errors_string('errors')."\n";
@


1.45
log
@remove a bit of noise from the log... we checked already, no need to
log it again.
@
text
@d2 1
a2 1
# $OpenBSD: Engine.pm,v 1.44 2012/01/09 11:54:30 espie Exp $
d322 1
a322 1
	if ($state->opt('f')) {
@


1.44
log
@lock may fail
@
text
@d2 1
a2 1
# $OpenBSD: Engine.pm,v 1.43 2012/01/08 14:40:58 espie Exp $
d273 3
@


1.43
log
@make fetch_manually error directly visible in the lock
@
text
@d2 1
a2 1
# $OpenBSD: Engine.pm,v 1.42 2011/12/10 14:48:40 espie Exp $
d660 1
a660 1
	print $fh "error=fetch manually\n";
@


1.42
log
@on SIGINFO, dump T/B hashes into info.log (and mark the display for refresh,
as the shell might muck it with its own information)
@
text
@d2 1
a2 1
# $OpenBSD: Engine.pm,v 1.41 2011/12/04 10:57:46 espie Exp $
d612 2
a613 1
		$self->add_fatal($v, "Missing distfiles: ".
d657 1
a657 1
	my ($self, $v, @@messages) = @@_;
d659 2
a660 1
	$self->{locker}->lock($v);
@


1.41
log
@cut up big method into smaller parts
@
text
@d2 1
a2 1
# $OpenBSD: Engine.pm,v 1.40 2011/12/04 10:39:52 espie Exp $
d157 6
d724 11
@


1.40
log
@properly forget old info when rescanning...
@
text
@d2 1
a2 1
# $OpenBSD: Engine.pm,v 1.39 2011/12/02 11:52:06 espie Exp $
d520 60
d587 2
a588 21
		if (!$quick) {
			for my $v (values %{$self->{built}}) {
				if ($self->adjust($v, 'RDEPENDS') == 0) {
					delete $self->{built}{$v};
					$self->{installable}{$v} = $v;
					if ($v->{wantinstall}) {
						$self->{buildable}->will_install($v);
					}
					$self->log_no_ts('I', $v);
					$changes++;
				} elsif (my $d = $self->should_ignore($v, 
				    'RDEPENDS')) {
					delete $self->{built}{$v};
					$self->log_no_ts('!', $v, 
					    " because of ".$d->fullpkgpath);
					$changes++;
					$v->{info} = DPB::PortInfo->stub;
					push(@@{$self->{ignored}}, $v);
				}
			}
		}
a589 26
		for my $v (values %{$self->{tobuild}}) {
			next if $quick && !$v->{new};
			delete $v->{new};
			my $has = $self->adjust($v, 'DEPENDS', 'BDEPENDS');
			$has += $self->adjust_extra($v, 'EXTRA', 'BEXTRA');

			my $has2 = $self->adjust_distfiles($v);
			# buying buildable directly is a priority,
			# but put the patch/dist/small stuff down the 
			# line as otherwise we will tend to grab 
			# patch files first
			$v->{has} = 2 * ($has != 0) + ($has2 > 1);
			if ($has + $has2 == 0) {
				$self->{buildable}->add($v);
				$self->log_no_ts('Q', $v);
				delete $self->{tobuild}{$v};
				$changes++;
			} elsif (my $d = $self->should_ignore($v, 'DEPENDS')) {
				delete $self->{tobuild}{$v};
				$self->log_no_ts('!', $v, 
				    " because of ".$d->fullpkgpath);
				$changes++;
				$v->{info} = DPB::PortInfo->stub;
				push(@@{$self->{ignored}}, $v);
			}
		}
@


1.39
log
@remove dangerous optimization: have paths explicitly pass thru the depends
stages, even if the package is already there.

This could break EXTRA depends where the package would already be there,
and thus its dependency tree not really solved, and thus depends could
easily miss packages...

problem reported by nigel@@... and not reported by ajacoutot@@ :)
@
text
@d2 1
a2 1
# $OpenBSD: Engine.pm,v 1.38 2011/12/02 11:40:25 espie Exp $
d647 8
@


1.38
log
@EXTRA should (partly) be handled like DEPENDS/BDEPENDS
@
text
@d2 1
a2 1
# $OpenBSD: Engine.pm,v 1.37 2011/11/22 16:46:44 espie Exp $
a551 4
			if ($self->{buildable}->is_done($v)) {
				$changes++;
				next;
			}
d582 22
a603 14
	if (!$self->{buildable}->is_done($v)) {
		if (defined $v->{info}{IGNORE} && 
		    !$self->{state}->{fetch_only}) {
		    	$self->log('!', $v, " ".$v->{info}{IGNORE}->string);
			$v->{info} = DPB::PortInfo->stub;
			push(@@{$self->{ignored}}, $v);
			return;
		}
		if (defined $v->{info}{MISSING_FILES}) {
			$self->log('!', $v, " fetch manually");
			$self->add_fatal($v, "Missing distfiles: ".
			    $v->{info}{MISSING_FILES}->string, 
			    $v->{info}{FETCH_MANUALLY}->string);
			return;
d605 3
a607 15
#		$self->{heuristics}->todo($v);
		$self->{tobuild}{$v} = $v;
		$self->log('T', $v);
		return unless defined $v->{info}{FDEPENDS};
		for my $f (values %{$v->{info}{FDEPENDS}}) {
			if ($self->{tofetch}->contains($f) ||
			    $self->{tofetch}{doing}{$f}) {
				next;
			}
			if ($self->{tofetch}->is_done($f)) {
				delete $v->{info}{FDEPENDS}{$f};
				next;
			}
			$self->{tofetch}->add($f);
			$self->log('F', $f);
d609 2
@


1.37
log
@shorter lock line: user doesn't really care that multiple pkgpaths ran into
the same lock, rather that it's a lock, and what the lockname is.
@
text
@d2 1
a2 1
# $OpenBSD: Engine.pm,v 1.36 2011/11/14 21:57:47 espie Exp $
d482 1
a482 1
	my ($self, $v, $kind) = @@_;
d491 1
d557 1
a557 1
			$has += $self->adjust_extra($v, 'EXTRA');
@


1.36
log
@explain to the engine how to install stuff when it's ready (no error
checks though).

new -I option to do that.
change -C option to be more useful.
@
text
@d2 1
a2 1
# $OpenBSD: Engine.pm,v 1.35 2011/11/13 22:18:04 espie Exp $
d373 15
d423 1
a423 1
	    "L=".$self->errors_string('locks')."\n".
@


1.35
log
@simplify lock code so that lock/unlock actually works, even if I lose
small-grained locks for fullpkgpath
also fix a stupid parenting bug...
@
text
@d2 1
a2 1
# $OpenBSD: Engine.pm,v 1.34 2011/11/13 10:34:35 espie Exp $
d81 5
d94 3
d164 1
d168 24
d516 3
@


1.34
log
@better FETCH_MANUALLY handling:
- expose MISSING_FILES
- treat them as a special kind of IGNORE
- handle that in DPB
that way, ports that are IGNORE'd for other reasons (not correct arch)
stay ignored, and relevant ports with missing distfiles get better error
messages
@
text
@d2 1
a2 1
# $OpenBSD: Engine.pm,v 1.33 2011/11/09 08:28:55 espie Exp $
a142 1
			$self->{engine}{locker}->simple_unlock($v);
@


1.33
log
@smarter dump at end of build:
- try resolving RDEPENDS on tobuild, so that known dependencie are zapped.
- use equivalence info to not reprint same thing twice.
- dump tobuild AND built, since both are usually relevant in case lots of
stuff didn't build
@
text
@d2 1
a2 1
# $OpenBSD: Engine.pm,v 1.32 2011/11/08 10:26:38 espie Exp $
a535 6
		if (defined $v->{info}{FETCH_MANUALLY} &&
		    defined $v->{info}{IGNORE}) {
			$self->log('!', $v, " fetch manually");
			$self->add_fatal($v, "Fetch manually error:", $v->{info}{FETCH_MANUALLY}->string);
			return;
		}
d541 7
@


1.32
log
@split DEPENDS into not done/done to help prepare work correctly
@
text
@d2 1
a2 1
# $OpenBSD: Engine.pm,v 1.31 2011/11/07 13:23:09 espie Exp $
d637 1
d641 19
a659 1
		$v->quick_dump($fh);
d661 1
@


1.31
log
@modify pkgpath to store info in a more compact way (in particular,
get rid of sawflavor, and just use the existence of the key to mark the
presence of flavors).

also remove yet more info once we used it.
@
text
@d2 1
a2 1
# $OpenBSD: Engine.pm,v 1.30 2011/11/06 12:23:28 espie Exp $
d404 1
a404 1
	my ($self, $v, $kind) = @@_;
d413 1
d505 1
a505 1
			my $has = $self->adjust($v, 'DEPENDS');
@


1.30
log
@slightly better error handling and reporting:
- log to pkgpath whenever we can
- log FETCH_MANUALLY issues as errors, so we can fix them
@
text
@d2 1
a2 1
# $OpenBSD: Engine.pm,v 1.29 2011/11/05 18:27:13 espie Exp $
d174 1
d190 1
a190 1
	return $v->{pkgpath};
d509 3
a511 2
			# but put the patch/dist/small stuff down the line
			# as otherwise we will tend to grab patch files first
@


1.29
log
@propagate IGNOREd status to dependent ports.
display directly into engine.log.
replace all info with a stub "ignored already".
This shrinks memory usage some more.
@
text
@d2 1
a2 1
# $OpenBSD: Engine.pm,v 1.28 2011/10/10 18:56:50 espie Exp $
a469 14
sub log_fetch
{
	my ($self, $v) = @@_;
	my $k = $v->{info}{FETCH_MANUALLY}->string;
	my $fh = $self->{logger}->open('fetch/manually');
	print $fh $v->fullpkgpath, "\n", "-" x length($v->fullpkgpath), "\n";
	if (defined $output->{$k}) {
		print $fh "same as ", $output->{$k}->fullpkgpath, "\n\n";
	} else {
		print $fh "$k\n\n";
		$output->{$k} = $v;
	}
}

d533 5
a537 3
		if (defined $v->{info}{FETCH_MANUALLY}) {
			$self->log_fetch($v);
			delete $v->{info}{FETCH_MANUALLY};
d586 1
a586 1
	my ($self, $v) = @@_;
d589 1
@


1.28
log
@unfuck pkgpaths.
- instead of seen/unseen, have an actual constructor. Instead, mark pkgpath
for which we wantinfo/wantbuild.
- only mark EXTRA dependencies as wantinfo. So the devel/haddock,no_deps
temporary error should be gone.
- since we have FLAVOR and SUBPACKAGE available, construct as much info as
we can during vars scanning (see handle_equivalences). This avoids about 150
path rescans during a full bulk. Also, grab the timing and logsizes from
equivalent files, so that most stuff should know show % all the time.
- tweak subdirlist to be a hash, and correctly add pkgpath_and_flavors to it.
That way, we rescan avahi pseudo flavors just once, and not four or five times.
@
text
@d2 1
a2 1
# $OpenBSD: Engine.pm,v 1.27 2011/09/28 09:49:29 espie Exp $
d421 10
d498 8
d530 7
d553 2
a554 5
		    	$self->log('!', $v);
			my $fh = $self->{logger}->open('ignored');
			print $fh $v->fullpkgpath, ": ", 
			    $v->{info}{IGNORE}->string, "\n";
			close $fh;
@


1.27
log
@log ignored ports: with a ! in engine.log, and with full IGNORE message in
new log file ignored.log
@
text
@d2 1
a2 1
# $OpenBSD: Engine.pm,v 1.26 2011/09/13 09:46:53 espie Exp $
d586 2
a587 2
	my @@subdirs = map {$_->fullpkgpath} @@l;
	$self->{state}->grabber->grab_subdirs($core, \@@subdirs);
@


1.26
log
@beginning of a fetch-only option that is supposed to replace mirror-maker
eventually.

- fetch all files
- ignore ignores
- specific builder that doesn't look at existing packages

currently: does not stop when  fetch is finished, which is somewhat of the
remaining issue.

Also: change stats to store pid, to make sense of interleaved log files.
@
text
@d2 1
a2 1
# $OpenBSD: Engine.pm,v 1.25 2011/06/03 13:38:58 espie Exp $
d528 5
@


1.25
log
@do the fetch stuff very early, in new_path.
@
text
@d2 1
a2 1
# $OpenBSD$
d214 9
d278 2
a279 1
	$o->{buildable} = DPB::SubEngine::Build->new($o, $state->builder);
d344 3
a346 1
	if ($q < 30) {
d387 1
a387 1
		print $fh $self->{ts}, " ", $line, "\n";
d526 2
a527 1
		if (defined $v->{info}{IGNORE}) {
@


1.24
log
@- unify code in Fetch/Build subengines
- zap heuristic#3, not critical
- don't rebuild the Fetch queue all the time, it's too expensive
- fix bugs in FetchQueue computation, correctly handle 1 distfile case
- create a quick path thru adjust* that handles only new paths.
- use it during LISTING while fetching files, to make more files available
quicker.
- model distfiles as FDEPENDS, DIST, so that they can get dumped.
- add -v option that dumps a bit more stuff in log files.

with these, dpb will fetch all distfiles in a not too surprising order,
and it won't consume 40% cpu while doing so...
@
text
@d2 1
a2 1
# $OpenBSD: Engine.pm,v 1.23 2011/06/01 12:34:09 espie Exp $
a468 17
		for my $v (values %{$self->{tobuild}}) {
			next if $quick && !$v->{new};
			if ($self->{buildable}->is_done($v)) {
				$changes++;
			} else {
				if (defined $v->{info}{FETCH_MANUALLY}) {
					$self->log_fetch($v);
					delete $v->{info}{FETCH_MANUALLY};
					$changes++;
				}
				if (defined $v->{info}{IGNORE}) {
					delete $self->{tobuild}{$v};
					push(@@{$self->{ignored}}, $v);
					$changes++;
				}
			}
		}
d510 8
@


1.23
log
@typo, duplicate work
@
text
@d2 1
a2 1
# $OpenBSD: Engine.pm,v 1.22 2011/05/29 09:30:13 espie Exp $
d26 1
a26 1
		doing => {}}, $class;
d71 1
a71 3
package DPB::SubEngine::Build;
our @@ISA = qw(DPB::SubEngine);
sub new
d73 2
a74 5
	my ($class, $engine, $builder) = @@_;
	my $o = $class->SUPER::new($engine);
	$o->{builder} = $builder;
	$o->{later} = {};
	return $o;
d77 1
a77 1
sub new_queue
a78 16
	my ($class, $engine) = @@_;
	return $engine->{heuristics}->new_queue;
}

sub is_done
{
	my ($self, $v) = @@_;
	if ($self->{builder}->check($v)) {
#		$self->{heuristics}->done($v);
		$self->{engine}{built}{$v}= $v;
		$self->log('B', $v);
		delete $self->{engine}{tobuild}{$v};
		return 1;
	} else {
		return 0;
	}
d84 1
a84 1
	my $core = $self->{builder}->get;
d93 1
a93 1
			$self->{engine}{logger}->make_log_link($v);
d97 1
a97 1
		if ($self->{doing}{$v->{pkgpath}}) {
d101 2
a102 7
			$self->{doing}{$v->{pkgpath}} = 1;
			my $special = $self->{engine}{heuristics}->
			    special_parameters($core->host, $v);
			$self->log('J', $v, " ".$core->hostname." ".$special);
			$self->{builder}->build($v, $core, $special,
			    $lock, sub {$self->end($core, $v)});
			return;
d111 15
d130 5
a134 1
	if (!$self->is_done($v)) {
a145 4
	} else {
		$self->{engine}{locker}->unlock($v);
		$self->{engine}{heuristics}->finish_special($v);
		$core->success;
d150 17
a166 1
sub done
d169 8
a176 6
	for my $candidate (values %{$self->{later}}) {
		if ($candidate->{pkgpath} eq $v->{pkgpath}) {
			delete $self->{later}{$candidate};
			$self->log('V', $candidate);
			$self->add($candidate);
		}
d178 34
a211 2
	delete $self->{doing}{$v->{pkgpath}};
	$self->{engine}{locker}->recheck_errors($self->{engine});
d226 1
a226 1
		$self->log('b', $v);
d233 6
a238 1
sub start
d240 4
a243 17
	my $self = shift;
	my $core = DPB::Core::Fetcher->get;
	my $o = $self->sorted($core);
	while (my $v = $o->next) {
		$self->remove($v);
		if (my $lock = $self->{engine}{locker}->lock($v)) {
			$self->{doing}{$v} = $v;
			$self->log('j', $v);
			DPB::Fetch->fetch($self->{engine}{logger}, $v, $core, 
			    sub { $self->end($core, $v)});
			return;
	    	} else {
			push(@@{$self->{engine}{locks}}, $v);
			$self->log('l', $v);
		}
	}
	$core->mark_ready;
d246 1
a246 1
sub end
a247 12
	my ($self, $core, $v) = @@_;
	my $e = $core->mark_ready;
	if ($self->is_done($v)) {
		$self->{engine}{locker}->unlock($v);
		delete $self->{doing}{$v};
		$core->success;
	} else {
		unshift(@@{$self->{engine}{errors}}, $v);
		$v->{host} = $core->host;
		$self->log('e', $v);
		$core->failure;
	}
d258 1
a258 1
	my $o = bless {built => {}, 
d261 1
a261 1
	    installable => {}, 
d337 1
a337 5
		if ($t > $q) {
			$self->{tofetch}{queue}->set_h2;
		} else {
			$self->{tofetch}{queue}->set_h3;
		}
d432 3
a434 8
	my $has = 0;
	return $has unless defined $v->{info}{distfiles};
	for my $f (values %{$v->{info}{distfiles}}) {
		if ($self->{tofetch}->contains($f) || 
		    $self->{tofetch}{doing}{$f}) {
			$has++;
			next;
		}
d436 1
a436 2
			delete $v->{info}{distfiles}{$f};
			$v->{info}{got}{$f} = $f;
d439 1
a439 3
		$has++;
		$self->{tofetch}->add($f);
		$self->log('F', $f);
d441 3
a443 1
	return $has;
d464 1
a464 1
	my $self = shift;
d470 1
d486 8
a493 6
		for my $v (values %{$self->{built}}) {
			if ($self->adjust($v, 'RDEPENDS') == 0) {
				delete $self->{built}{$v};
				$self->{installable}{$v} = $v;
				$self->log_no_ts('I', $v);
				$changes++;
d498 2
d511 1
a511 1
			$v->{has} = 2 * ($has != 0) + ($has2 != 0);
d530 13
@


1.22
log
@if we're running -f, do the checksum part internally, since we already
checksummed stuff we fetched (will allow auto-refetch eventually).
@
text
@d2 1
a2 1
# $OpenBSD: Engine.pm,v 1.21 2011/05/28 19:24:15 espie Exp $
a497 1
			$has += $self->adjust_distfiles($v);
@


1.21
log
@fix unlocking in case of errors
@
text
@d2 1
a2 1
# $OpenBSD: Engine.pm,v 1.20 2011/05/28 08:21:39 espie Exp $
d427 1
@


1.20
log
@fix
@
text
@d2 1
a2 1
# $OpenBSD: Engine.pm,v 1.19 2011/05/27 11:22:13 espie Exp $
d148 1
a148 1
			unshift(@@{$self->{errors}}, $v);
@


1.19
log
@explain the dump_dependencies/find_best optimization for quick-restarting
dpb.
@
text
@d2 1
a2 1
# $OpenBSD: Engine.pm,v 1.18 2011/05/27 10:27:50 espie Exp $
d172 1
a172 1
	$self->{engine}{locker}->recheck_errors($self);
@


1.18
log
@start moving the fetch/build code into separate subengine classes, to make
it more obvious how much is shared (goal is to unify a large part of these).

In particular, the locking code/stuff already active is glaringly the same...

Polish the distfiles measurements. For now, 3 heuristics that kick in
at various stages of the build (a bit of black magic).

Fix pkgpath->{has} to record both "no dependencies" and "several distfiles
missing" to avoid grabbing small patchfiles which don't lead to valid
builds while heuristic#1 is active.
@
text
@d2 1
a2 1
# $OpenBSD: Engine.pm,v 1.17 2011/05/22 08:21:39 espie Exp $
d603 9
@


1.17
log
@initial support for fetching distfiles, somewhat experimental yet.
- clean up clock handling, jobs with timer.
- pass more parameters thru state
- tweak the engine to handle distfiles
- lots of new code in Fetch for new jobs.
@
text
@d2 1
a2 1
# $OpenBSD: Engine.pm,v 1.16 2011/04/25 11:58:46 espie Exp $
d21 210
d242 1
a242 3
	    buildable => $state->heuristics->new_queue,
	    later => {}, building => {},
	    installable => {}, builder => $state->builder,
d250 1
d252 1
a252 3
		# XXX no speed factor there
		$o->{tofetch} = DPB::Heuristics::Queue->new($state->heuristics);
		$o->{fetching} = {};
d313 1
a313 1
	my $self= shift;
d315 9
d327 1
a327 1
sub report
d330 2
d335 12
a346 3
	    "Q=".$self->{buildable}->count,
	    "T=".$self->count("tobuild"),
	    $self->fetchcount, 
d357 1
a357 6
	my $line = join(" ",
	    "I=".$self->count("installable"),
	    "B=".$self->count("built"),
	    "Q=".$self->{buildable}->count,
	    "T=".$self->count("tobuild"),
	    $self->fetchcount);
d421 1
a421 1
		    $self->{fetching}{$f}) {
d425 1
a425 1
		if ($self->is_present($f)) {
d460 1
a460 1
			if ($self->was_built($v)) {
d485 1
a485 1
			if ($self->was_built($v)) {
d492 5
a496 1
			$v->{has} = $has;
d498 1
a498 1
			if ($has == 0) {
a508 25
sub was_built
{
	my ($self, $v) = @@_;
	if ($self->{builder}->check($v)) {
#		$self->{heuristics}->done($v);
		$self->{built}{$v}= $v;
		$self->log('B', $v);
		delete $self->{tobuild}{$v};
		return 1;
	} else {
		return 0;
	}
}

sub is_present
{
	my ($self, $v) = @@_;
	if ($v->check($self->{logger})) {
		$self->log('b', $v);
		return 1;
	} else {
		return 0;
    	}
}

d512 1
a512 1
	if (!$self->was_built($v)) {
a518 40
sub end_job
{
	my ($self, $core, $v) = @@_;
	my $e = $core->mark_ready;
	if (!$self->was_built($v)) {
		$core->failure;
		if (!$e || $core->{status} == 65280) {
			$self->{buildable}->add($v);
			$self->{locker}->unlock($v);
			$self->log('N', $v);
		} else {
			unshift(@@{$self->{errors}}, $v);
			$v->{host} = $core->host;
			$self->{locker}->simple_unlock($v);
			$self->log('E', $v);
		}
	} else {
		$self->{locker}->unlock($v);
		$self->{heuristics}->finish_special($v);
		$core->success;
	}
	$self->job_done($v);
}

sub end_fetch
{
	my ($self, $core, $v) = @@_;
	my $e = $core->mark_ready;
	if ($self->is_present($v)) {
		$self->{locker}->unlock($v);
		delete $self->{fetching}{$v};
		$core->success;
	} else {
		unshift(@@{$self->{errors}}, $v);
		$v->{host} = $core->host;
		$self->log('e', $v);
		$core->failure;
	}
}

a544 23
sub job_done
{
	my ($self, $v) = @@_;
	for my $candidate (values %{$self->{later}}) {
		if ($candidate->{pkgpath} eq $v->{pkgpath}) {
			delete $self->{later}{$candidate};
			$self->log('V', $candidate);
			$self->{buildable}->add($candidate);
		}
	}
	delete $self->{building}{$v->{pkgpath}};
	$self->{locker}->recheck_errors($self);
}

sub new_job
{
	my ($self, $core, $v, $lock) = @@_;
	my $special = $self->{heuristics}->special_parameters($core->host, $v);
	$self->log('J', $v, " ".$core->hostname." ".$special);
	$self->{builder}->build($v, $core, $special,
	    $lock, sub {$self->end_job($core, $v)});
}

d558 1
a558 26
	my $core = $self->{builder}->get;
	if (@@{$self->{requeued}} > 0) {
		$self->rebuild_info($core);
		return;
	}
	my $o = $self->{buildable}->sorted($core);
	while (my $v = $o->next) {
		$self->{buildable}->remove($v);
		if ($self->was_built($v)) {
			$self->{logger}->make_log_link($v);
			$self->job_done($v);
			next;
		}
		if ($self->{building}{$v->{pkgpath}}) {
			$self->{later}{$v} = $v;
			$self->log('^', $v);
		} elsif (my $lock = $self->{locker}->lock($v)) {
			$self->{building}{$v->{pkgpath}} = 1;
			$self->new_job($core, $v, $lock);
			return;
		} else {
			push(@@{$self->{locks}}, $v);
			$self->log('L', $v);
		}
	}
	$core->mark_ready;
d564 1
a564 18
	my $core = DPB::Core::Fetcher->get;
	my $o = $self->{tofetch}->sorted($core);
	my @@s = ((grep {$_->{path}->{has} != 0} @@$o), 
		(grep {$_->{path}->{has} == 0} @@$o));
	while (my $v = pop @@s) {
		$self->{tofetch}->remove($v);
		if (my $lock = $self->{locker}->lock($v)) {
			$self->{fetching}{$v} = $v;
			$self->log('j', $v);
			DPB::Fetch->fetch($self->{logger}, $v, $core, 
			    sub { $self->end_fetch($core, $v)});
			return;
	    	} else {
			push(@@{$self->{locks}}, $v);
			$self->log('l', $v);
		}
	}
	$core->mark_ready;
@


1.16
log
@finish refactoring options.
Deprecate: -t and -T
use -DCONNECTION_TIMEOUT=... -DDISPLAY_TIMEOUT=... instead
New feature: -DSTUCK_TIMEOUT=
kill tasks when they don't show any progress for that long.
@
text
@d2 1
a2 1
# $OpenBSD$
d28 5
a32 3
	my ($class, $builder, $heuristics, $logger, $locker) = @@_;
	my $o = bless {built => {}, tobuild => {},
	    buildable => $heuristics->new_queue,
d34 4
a37 4
	    installable => {}, builder => $builder,
	    heuristics => $heuristics,
	    locker => $locker,
	    logger => $logger,
d42 7
a48 2
	$o->{log} = DPB::Util->make_hot($logger->open("engine"));
	$o->{stats} = DPB::Util->make_hot($logger->open("stats"));
a51 7
sub set_grabber
{
	my ($self, $g) = @@_;
	$self->{grabber} = $g;
	$self->{builder}->set_grabber($g);
}

d67 1
a67 1
	print $fh "$$\@@$self->{ts}: $kind: ", $v->fullpkgpath, "$extra\n";
d95 1
a95 1
		my $s = $e->fullpkgpath;
d104 7
d119 1
d134 2
a135 1
	    "T=".$self->count("tobuild"));
d192 38
d240 11
a250 4
			} elsif (defined $v->{info}{IGNORE}) {
				delete $self->{tobuild}{$v};
				push(@@{$self->{ignored}}, $v);
				$changes++;
d269 3
d296 12
d342 16
d365 6
d413 1
a413 1
	$self->{grabber}->grab_subdirs($core, \@@subdirs);
d448 23
d476 6
@


1.15
log
@better info rebuild: make Vars responsible for creating info "just in time"
by keeping local state.
That way, when we rescan, we don't have to remove any info, and all affected
infos are replaced at the same time.
@
text
@d2 1
a2 1
# $OpenBSD: Engine.pm,v 1.14 2010/10/31 11:07:20 espie Exp $
@


1.14
log
@new file/option: save dependencies and be able to reuse them.
makes for a "quick listing" of the most important ports first (e.g., groff).
document -R, even though it's not perfect yet.
flesh out all the recent parts and update the BUGS AND LIMITATIONS section.
@
text
@d2 1
a2 1
# $OpenBSD: Engine.pm,v 1.13 2010/10/30 11:19:38 espie Exp $
a320 3
	for my $v (@@l) {
		delete $v->{info};
	}
@


1.13
log
@proof-of-concept implementation of -R (rebuild when signature changes).
Somewhat inefficient (deep check of package vs port signature).
More proper approach would be to tell the engine to always build, have first
step be a check for signature if the package exist, and abort if it matches:
- here we double check everything
- propagating rebuilds means non-uptodate packages give rise to non uptodate.
@
text
@d2 1
a2 1
# $OpenBSD: Engine.pm,v 1.12 2010/10/29 11:51:42 espie Exp $
d389 38
@


1.12
log
@engine improvements:
- if several cores are available, recheck errors, so that we're not stuck
waiting for a core to finish to start new shit.
- $logdir/stop-<machine_name> allows you to stop a given machine while
you clean it up and (possibly) restart it (e.g., won't start new jobs)
@
text
@d2 1
a2 1
# $OpenBSD: Engine.pm,v 1.11 2010/10/28 16:40:48 espie Exp $
d43 7
@


1.11
log
@not needed any longer
@
text
@d2 1
a2 1
# $OpenBSD: Engine.pm,v 1.10 2010/10/28 08:54:22 espie Exp $
d45 1
a45 1
sub has_errors
@


1.10
log
@oops, give back that core.
@
text
@d2 1
a2 1
# $OpenBSD: Engine.pm,v 1.9 2010/10/27 22:58:02 espie Exp $
a32 1
	    all => {},
a234 1
	$self->{all}{$v} = $v;
@


1.9
log
@use rescan after errors, so that bumps get picked up
@
text
@d2 1
a2 1
# $OpenBSD: Engine.pm,v 1.8 2010/10/27 22:53:33 espie Exp $
d321 1
@


1.8
log
@kill more code related to P= (will simplify next parts)
@
text
@d2 1
a2 1
# $OpenBSD: Engine.pm,v 1.7 2010/10/27 12:58:26 espie Exp $
a320 1
	# XXX todo something needs to happen after the rescan ?
@


1.7
log
@tie engine with var grabber, get ready to re-do port meta on error.
@
text
@d2 1
a2 1
# $OpenBSD: Engine.pm,v 1.6 2010/10/26 16:57:10 espie Exp $
a126 40
sub finished_scanning
{
	my $self = shift;
	# this is scary, we need to do it by-pkgname
	my $needed_by = {};
	my $bneeded_by = {};
	for my $v (values %{$self->{all}}) {
	# also, this is an approximation, we could be more specific wrt
	# BUILD/RUN_DEPENDS, this leads to more code in check_buildable...
		for my $kind (qw(RUN_DEPENDS LIB_DEPENDS)) {
			next unless defined $v->{info}{$kind};
			for my $depend (values %{$v->{info}{$kind}}) {
				next if $depend eq $v;
				my $pkgname = $depend->fullpkgname;
				next if !defined $pkgname;
				$needed_by->{$pkgname}{$v} = $v;
			}
		}
		if (defined $v->{info}{BUILD_DEPENDS}) {
			for my $depend (values %{$v->{info}{BUILD_DEPENDS}}) {
				next if $depend eq $v;
				my $pkgname = $depend->fullpkgname;
				next if !defined $pkgname;
				$bneeded_by->{$pkgname}{$v} = $v;
			}
		}
	}
	# then we link each pkgpath to its array
	for my $v (values %{$self->{all}}) {
		if (defined $needed_by->{$v->fullpkgname}) {
			$v->{info}{NEEDED_BY} = $needed_by->{$v->fullpkgname};
			bless $v->{info}{NEEDED_BY}, "AddDepends";
		}
		if (defined $bneeded_by->{$v->fullpkgname}) {
			$v->{info}{BNEEDED_BY} = $bneeded_by->{$v->fullpkgname};
			bless $v->{info}{BNEEDED_BY}, "AddDepends";
		}
	}
}

d321 1
a321 2
	# XXX todo something needs to happen after the rescan,
	# along the lines of finished_scanning
@


1.6
log
@distinguishes between errors we create (E=) and locks we encounter (L=)
@
text
@d2 1
a2 1
# $OpenBSD: Engine.pm,v 1.5 2010/10/24 10:01:57 espie Exp $
d315 6
d359 4
a362 4
	# todo: calls vars again after stripping stuff bare.
	for my $v (@@l) {
		$self->new_path($v);
	}
@


1.5
log
@add an option for dpb to keep going if there are errors left.
there's a bug in the display (to be fixed) as errors won't show properly
and you have to look manually though...
@
text
@d2 1
a2 1
# $OpenBSD: Engine.pm,v 1.4 2010/10/23 21:46:03 espie Exp $
d38 1
d49 1
a49 1
	if (@@{$self->{errors}} != 0) {
d86 1
a86 1
	my $self = shift;
d88 1
a88 1
	for my $e (@@{$self->{errors}}) {
d107 2
a108 1
	    "E=".$self->errors_string."\n";
d383 1
a383 1
			push(@@{$self->{errors}}, $v);
@


1.4
log
@if we didn't parse the path, then we don't have the pkgname, duh.
@
text
@d2 1
a2 1
# $OpenBSD: Engine.pm,v 1.3 2010/10/23 18:14:19 espie Exp $
d43 10
@


1.3
log
@zap P/I distinction, it was a lousy idea anyways
@
text
@d2 1
a2 1
# $OpenBSD: Engine.pm,v 1.2 2010/10/23 17:58:55 espie Exp $
a114 1
my $done_scanning = 0;
a117 1
	$done_scanning = 1;
d128 3
a130 1
				$needed_by->{$depend->fullpkgname}{$v} = $v;
d136 3
a138 1
				$bneeded_by->{$depend->fullpkgname}{$v} = $v;
@


1.2
log
@if we don't ssh to it, don't print the name either in errors, as requested by
landry@@
@
text
@d2 1
a2 1
# $OpenBSD: Engine.pm,v 1.1.1.1 2010/08/20 13:40:13 espie Exp $
a32 1
	    packages => {},
a90 1
	    "P=".$self->count("packages"),
a104 1
	    "P=".$self->count("packages"),
a202 25
sub can_package
{
	my ($self, $v) = @@_;
	if (defined $v->{info}{NEEDED_BY}) {
		for my $w (values %{$v->{info}{NEEDED_BY}}) {
			if ($self->{packages}{$w}) {
				delete $v->{info}{NEEDED_BY}{$w};
			} else {
				return 0;
			}
		}
	}
	if (defined $v->{info}{BNEEDED_BY}) {
		for my $w (values %{$v->{info}{BNEEDED_BY}}) {
			if ($self->{packages}{$w} || $self->{built}{$w} ||
			    $self->{installable}{$w}) {
				delete $v->{info}{BNEEDED_BY}{$w};
			} else {
				return 0;
			}
		}
	}
	return 1;
}

a209 11
		# move stuff to packages once we know all reverse dependencies
		if ($done_scanning) {
			for my $v (values %{$self->{installable}}) {
				if ($self->can_package($v)) {
					$self->log_no_ts('P', $v);
					$self->{packages}{$v} = $v;
					delete $self->{installable}{$v};
					$changes++;
				}
			}
		}
d401 1
a401 1
	for my $k (qw(packages built tobuild installable)) {
@


1.1
log
@Initial revision
@
text
@d2 1
a2 1
# $OpenBSD: Engine.pm,v 1.8 2010/05/04 09:45:41 espie Exp $
d80 1
a80 1
		if (defined $e->{host}) {
@


1.1.1.1
log
@move stuff here from infra/build
@
text
@@
