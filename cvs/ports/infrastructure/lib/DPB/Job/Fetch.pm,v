head	1.12;
access;
symbols
	OPENBSD_6_1:1.11.0.8
	OPENBSD_6_1_BASE:1.11
	OPENBSD_6_0:1.11.0.6
	OPENBSD_6_0_BASE:1.11
	OPENBSD_5_9:1.11.0.2
	OPENBSD_5_9_BASE:1.11
	OPENBSD_5_8:1.11.0.4
	OPENBSD_5_8_BASE:1.11
	OPENBSD_5_7:1.2.0.6
	OPENBSD_5_7_BASE:1.2
	OPENBSD_5_6:1.2.0.4
	OPENBSD_5_6_BASE:1.2
	OPENBSD_5_5:1.2.0.2
	OPENBSD_5_5_BASE:1.2;
locks; strict;
comment	@# @;


1.12
date	2017.04.14.16.43.40;	author espie;	state Exp;
branches;
next	1.11;
commitid	xYf84gmn0uJCiE0i;

1.11
date	2015.05.18.16.35.15;	author espie;	state Exp;
branches;
next	1.10;
commitid	WWEEsziiaMhBBBcz;

1.10
date	2015.05.16.15.27.48;	author espie;	state Exp;
branches;
next	1.9;
commitid	rmOsBIjV1KPnJ3dY;

1.9
date	2015.05.13.14.44.13;	author espie;	state Exp;
branches;
next	1.8;
commitid	rroU5oxeK9yxRaxX;

1.8
date	2015.05.10.08.14.14;	author espie;	state Exp;
branches;
next	1.7;
commitid	J9XuZmxJc7sLMZLF;

1.7
date	2015.05.07.12.30.46;	author espie;	state Exp;
branches;
next	1.6;
commitid	bTlfhLMWrwKobBb3;

1.6
date	2015.05.03.10.33.59;	author espie;	state Exp;
branches;
next	1.5;
commitid	lBfNuZOkyaPdWlyt;

1.5
date	2015.05.02.12.55.43;	author espie;	state Exp;
branches;
next	1.4;
commitid	ZKkgptLKOetq1aKc;

1.4
date	2015.04.27.13.32.57;	author espie;	state Exp;
branches;
next	1.3;
commitid	OZaepSq8a1Uo1Af9;

1.3
date	2015.04.25.11.24.24;	author espie;	state Exp;
branches;
next	1.2;
commitid	Ns59IL1En4MSztmj;

1.2
date	2013.12.07.15.45.15;	author espie;	state Exp;
branches;
next	1.1;

1.1
date	2013.10.25.13.40.42;	author espie;	state Exp;
branches;
next	;


desc
@@


1.12
log
@have both log watching jobs actually share the timeout code.
If I had done this before, I would have fixed kill just once after privsep
and not inadvertently broken the builder stuck timeout...

problem noticed by naddy@@
@
text
@# ex:ts=8 sw=4:
# $OpenBSD: Fetch.pm,v 1.11 2015/05/18 16:35:15 espie Exp $
#
# Copyright (c) 2010-2013 Marc Espie <espie@@openbsd.org>
#
# Permission to use, copy, modify, and distribute this software for any
# purpose with or without fee is hereby granted, provided that the above
# copyright notice and this permission notice appear in all copies.
#
# THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
# ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
# OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
use strict;
use warnings;

package DPB::Task::Checksum;
our @@ISA = qw(DPB::Task::Fork);

sub new
{
	my ($class, $fetcher, $status) = @@_;
	bless {fetcher => $fetcher, fetch_status => $status}, $class;
}

sub run
{
	my ($self, $core) = @@_;
	my $job = $core->job;
	$job->{logger}->run_as(
	    sub {
		$self->redirect_fh($job->{logfh}, $job->{log});
	    });
	exit(!$job->{file}->checksum($job->{file}->tempfilename));
}

sub finalize
{
	my ($self, $core) = @@_;
	$self->SUPER::finalize($core);
	my $job = $core->job;
	if ($core->{status} != 0) {
		# XXX if we continued, and it failed, then maybe we
		# got a stupid error message instead, so retry for
		# full size.
		if (defined $self->{fetcher}->{initial_sz}) {
			$job->{fetcher}->run_as(
			    sub {
				unlink($job->{file}->tempfilename);
			    });
		} else {
			shift @@{$job->{sites}};
		}
		return $job->bad_file($self->{fetcher}, $core);
	}
	$job->{fetcher}->run_as(
	    sub {
		rename($job->{file}->tempfilename, $job->{file}->filename);
	    });
	print {$job->{logfh}} "Renamed to ", $job->{file}->filename, "\n";
	$job->{file}->cache;
	my $sz = $job->{file}->{sz};
	if (defined $self->{fetcher}->{initial_sz}) {
		$sz -= $self->{fetcher}->{initial_sz};
	}
	my $fh = $job->{file}->logger->append("fetch/good");
	my $elapsed = $self->{fetcher}->elapsed;
	print $fh $self->{fetcher}{site}.$job->{file}->{short}, " in ",
	    $elapsed, "s ";
	if ($elapsed != 0) {
		print $fh "(", sprintf("%.2f", $sz / $elapsed / 1024), "KB/s)";
	}
	print $fh "\n";
	close $fh;
	return 1;
}

# Fetching stuff is almost a normal job
package DPB::Task::Fetch;
our @@ISA = qw(DPB::Task::Clocked);

sub stopped_clock
{
	my ($self, $gap) = @@_;
	# note that we're missing time
	$self->{got_suspended}++;
	$self->SUPER::stopped_clock($gap);
}

sub new
{
	my ($class, $job) = @@_;
	if (@@{$job->{sites}}) {
		my $o = bless { site => $job->{sites}[0]}, $class;
		my $sz = (stat $job->{file}->tempfilename)[7];
		if (defined $sz) {
			$o->{initial_sz} = $sz;
		}
		return $o;
	} else {
		undef;
	}
}

sub run
{
	my ($self, $core) = @@_;
	my $job = $core->job;
	my $site = $self->{site};
	$site =~ s/^\"(.*)\"$/$1/;
	$job->{logger}->run_as(
	    sub {
		$self->redirect($job->{log});
	    });
	if ($job->{file}{sz} == 0) {
		print STDERR "No size in distinfo\n";
		exit(1);
	}
	my $ftp = OpenBSD::Paths->ftp;
	my @@cmd = ('-C', '-o', $job->{file}->tempfilename, '-v',
	    $site.$job->{file}->{short});
	if ($ftp =~ /\s/) {
		unshift @@cmd, split(/\s+/, $ftp);
	} else {
		unshift @@cmd, $ftp;
	}
	print STDERR "===> Trying $site\n";
	print STDERR join(' ', @@cmd), "\n";
	# run ftp;
	$core->shell->nochroot->exec(@@cmd);
}

sub finalize
{
	my ($self, $core) = @@_;
	$self->SUPER::finalize($core);
	my $job = $core->job;
	if ($job->{file}->checksize($job->{file}->tempfilename)) {
	    	$job->new_checksum_task($self, $core->{status});
	} else {
		if ($job->{file}{sz} == 0) {
			$job->{sites} = [];
			return $job->bad_file($self, $core);
		}
		# Fetch exited okay, but the file is not the right size
		if ($core->{status} == 0 ||
		# definite error also if file is too large
		    stat($job->{file}->tempfilename) &&
		    (stat _)[7] > $job->{file}->{sz}) {
		    	$job->{fetcher}->unlink($job->{file}->tempfilename);
		}
		# if we got suspended, well, might have to retry same site
		if (!$self->{got_suspended}) {
			shift @@{$job->{sites}};
		}
		return $job->bad_file($self, $core);
	}
}

package DPB::Job::Fetch;
our @@ISA = qw(DPB::Job::Normal);

use File::Path;
use File::Basename;

sub new_fetch_task
{
	my $self = shift;
	my $task = DPB::Task::Fetch->new($self);
	if ($task) {
		push(@@{$self->{tasks}}, $task);
		$self->{tries}++;
		return 1;
	} else {
		return 0;
	}
}

sub bad_file
{
	my ($job, $task, $core) = @@_;
	my $fh = $job->{file}->logger->append("fetch/bad");
	print $fh $task->{site}.$job->{file}->{short}, "\n";
	if ($job->new_fetch_task) {
		$core->{status} = 0;
		return 1;
	} else {
		$core->{status} = 1;
		return 0;
	}
}

sub new_checksum_task
{
	my ($self, $fetcher, $status) = @@_;
	push(@@{$self->{tasks}}, DPB::Task::Checksum->new($fetcher, $status));
}

sub new
{
	my ($class, $file, $e, $fetcher, $logger) = @@_;
	my $job = bless {
		sites => [@@{$file->{site}}],
		file => $file,
		tasks => [],
		endcode => $e,
		fetcher => $fetcher,
		logger => $logger,
		log => $file->logger->make_distlogs($file),
	}, $class;
	$job->{logfh} = $job->{logger}->open('>>', $job->{log});
	print {$job->{logfh}} ">>> From ", $file->fullpkgpath, "\n";
	$job->{fetcher}->make_path(File::Basename::dirname($file->filename));
	$job->{watched} = DPB::Watch->new(
		$job->{fetcher}->file($file->tempfilename),
		$file->{sz}, undef, $job->{started});
	$job->new_fetch_task;
	return $job;
}

sub name
{
	my $self = shift;
	return '<'.$self->{file}->{name}."(#".$self->{tries}.")";
}

sub watched
{
	my ($self, $current, $core) = @@_;
	my $w = $self->{watched};
	my $diff = $w->check_change($current);
	my $msg = $w->percent_message . $w->frozen_message($diff);
	return $self->kill_on_timeout($diff, $core, $msg);
}

sub get_timeout
{
	my ($self, $core) = @@_;
	return $core->fetch_timeout;
}

1;
@


1.11
log
@use File object (name + user) to ensure watched files are watched with the
correct user. Should fix sthen@@'s problems.

(File interface to be used elsewhere, as it's less cumbersome)
@
text
@d2 1
a2 1
# $OpenBSD: Fetch.pm,v 1.10 2015/05/16 15:27:48 espie Exp $
d236 7
a242 11
	my $to = $core->fetch_timeout;
	if (defined $to) {
		if ($diff > $to) {
			$self->{stuck} =
			    "KILLED: $self->{current} stuck at $msg";
			local $> = 0;
			kill 9, $core->{pid};
			return $self->{stuck};
		}
	}
	return $msg;
@


1.10
log
@chdir($distdir) at the start of expire_old
First, it makes for simpler code. It also allows things to work when your
cwd is not readable by your user, such as /root, since File::Find wants the
cwd.
@
text
@d2 1
a2 1
# $OpenBSD: Fetch.pm,v 1.9 2015/05/13 14:44:13 espie Exp $
d217 2
a218 1
	$job->{watched} = DPB::Watch->new($file->tempfilename,
@


1.9
log
@duplicated code
@
text
@d2 1
a2 1
# $OpenBSD: Fetch.pm,v 1.8 2015/05/10 08:14:14 espie Exp $
d144 1
a144 1
		if ($job->{file}->{sz} == 0) {
d153 1
a153 4
		    	$job->{fetcher}->run_as(
			    sub {
				unlink($job->{file}->tempfilename);
			    });
@


1.8
log
@rename logger interface to desambiguate vs user.
@
text
@d2 1
a2 1
# $OpenBSD: Fetch.pm,v 1.7 2015/05/07 12:30:46 espie Exp $
a111 1
	my $shell = $core->shell;
@


1.7
log
@make sure we're root when killing stuff. I'm mixing up right and left,
obviously.
@
text
@d2 1
a2 1
# $OpenBSD: Fetch.pm,v 1.6 2015/05/03 10:33:59 espie Exp $
d69 1
a69 1
	my $fh = $job->{file}->logger->open("fetch/good");
d189 1
a189 1
	my $fh = $job->{file}->logger->open("fetch/bad");
@


1.6
log
@do a few more things with the correct user
@
text
@d2 1
a2 1
# $OpenBSD: Fetch.pm,v 1.5 2015/05/02 12:55:43 espie Exp $
d244 1
@


1.5
log
@use the per-user Core thingy: make sure fetch cores are built with the
default prop, and set them to run as fetch_user, so that I can remove
the explicit run_as in the ftp command.
@
text
@d2 1
a2 1
# $OpenBSD: Fetch.pm,v 1.4 2015/04/27 13:32:57 espie Exp $
d218 1
a218 4
	$job->{logger}->run_as(
	    sub {
		open $job->{logfh}, '>>', $job->{log};
	    });
@


1.4
log
@more or less "the final" dpb pieces for fetching as a separate user.
@
text
@d2 1
a2 1
# $OpenBSD: Fetch.pm,v 1.3 2015/04/25 11:24:24 espie Exp $
d134 1
a134 1
	$core->shell->nochroot->run_as($job->{fetcher}{user})->exec(@@cmd);
@


1.3
log
@zap duplicate redirection, was harmless
@
text
@d2 1
a2 1
# $OpenBSD: Fetch.pm,v 1.2 2013/12/07 15:45:15 espie Exp $
d33 4
a36 1
	$self->redirect_fh($job->{logfh}, $job->{log});
d50 4
a53 1
			unlink($job->{file}->tempfilename);
d59 4
a62 1
	rename($job->{file}->tempfilename, $job->{file}->filename);
d115 4
a118 1
	$self->redirect($job->{log});
d134 1
a134 1
	$core->shell->nochroot->exec(@@cmd);
d154 4
a157 1
			unlink($job->{file}->tempfilename);
d208 1
a208 1
	my ($class, $file, $e) = @@_;
d214 2
d218 4
a221 1
	open $job->{logfh}, '>>', $job->{log};
d223 1
a223 1
	File::Path::mkpath(File::Basename::dirname($file->filename));
@


1.2
log
@work-around quote protected MASTER_SITES...
brad and sthen didn't test thoroughly, so I get to pick up the broken pieces...
@
text
@d2 1
a2 1
# $OpenBSD: Fetch.pm,v 1.1 2013/10/25 13:40:42 espie Exp $
a111 1
	$self->redirect($job->{log});
@


1.1
log
@split up the fetch code for readability.
don't bother passing logger around, just keep it in the fetch object,
the distfile objects, and use it directly, that's simpler.
@
text
@d2 1
a2 1
# $OpenBSD: Fetch.pm,v 1.60 2013/10/17 18:09:41 espie Exp $
d105 1
@

