head	1.168;
access;
symbols
	OPENBSD_6_1:1.168.0.6
	OPENBSD_6_1_BASE:1.168
	OPENBSD_6_0:1.168.0.4
	OPENBSD_6_0_BASE:1.168
	OPENBSD_5_9:1.168.0.2
	OPENBSD_5_9_BASE:1.168
	OPENBSD_5_8:1.166.0.4
	OPENBSD_5_8_BASE:1.166
	OPENBSD_5_7:1.151.0.2
	OPENBSD_5_7_BASE:1.151
	OPENBSD_5_6:1.150.0.2
	OPENBSD_5_6_BASE:1.150
	OPENBSD_5_5:1.143.0.2
	OPENBSD_5_5_BASE:1.143
	OPENBSD_5_4:1.111.0.2
	OPENBSD_5_4_BASE:1.111
	OPENBSD_5_3:1.99.0.2
	OPENBSD_5_3_BASE:1.99
	OPENBSD_5_2:1.33.0.2
	OPENBSD_5_2_BASE:1.33
	OPENBSD_5_1_BASE:1.25
	OPENBSD_5_1:1.25.0.2
	OPENBSD_5_0:1.12.0.2
	OPENBSD_5_0_BASE:1.12
	OPENBSD_4_9:1.6.0.2
	OPENBSD_4_9_BASE:1.6
	ports:1.1.1.1
	espie:1.1.1;
locks; strict;
comment	@# @;


1.168
date	2015.11.20.13.49.08;	author espie;	state Exp;
branches;
next	1.167;
commitid	n0y38rpTCiihjmp7;

1.167
date	2015.08.16.08.35.39;	author espie;	state Exp;
branches;
next	1.166;
commitid	lzp17lnhjnyuBbyS;

1.166
date	2015.07.02.08.04.22;	author espie;	state Exp;
branches;
next	1.165;
commitid	qIlv6BM85gcmoVOI;

1.165
date	2015.06.23.09.01.56;	author espie;	state Exp;
branches;
next	1.164;
commitid	wA22yJwakxt09g5J;

1.164
date	2015.06.22.12.18.50;	author espie;	state Exp;
branches;
next	1.163;
commitid	OvFFSX5Ca01e0jwt;

1.163
date	2015.05.24.06.48.51;	author espie;	state Exp;
branches;
next	1.162;
commitid	oi2S5hnnGJfxdQvu;

1.162
date	2015.05.18.16.35.15;	author espie;	state Exp;
branches;
next	1.161;
commitid	WWEEsziiaMhBBBcz;

1.161
date	2015.05.16.17.01.53;	author espie;	state Exp;
branches;
next	1.160;
commitid	hPeTCIM9LeUeEFlP;

1.160
date	2015.05.12.19.48.29;	author espie;	state Exp;
branches;
next	1.159;
commitid	CyVrimnnddwcZ9QI;

1.159
date	2015.05.10.08.14.14;	author espie;	state Exp;
branches;
next	1.158;
commitid	J9XuZmxJc7sLMZLF;

1.158
date	2015.05.08.12.35.53;	author espie;	state Exp;
branches;
next	1.157;
commitid	x9jAaLYc1uQYUMsf;

1.157
date	2015.05.07.12.30.46;	author espie;	state Exp;
branches;
next	1.156;
commitid	bTlfhLMWrwKobBb3;

1.156
date	2015.05.05.08.52.05;	author espie;	state Exp;
branches;
next	1.155;
commitid	e3Q9s79ozgSV5s1q;

1.155
date	2015.05.03.08.15.35;	author espie;	state Exp;
branches;
next	1.154;
commitid	246pYNVHSHMiUnDe;

1.154
date	2015.05.01.15.41.52;	author espie;	state Exp;
branches;
next	1.153;
commitid	TpkjhUgsQrKErtYy;

1.153
date	2015.04.29.10.59.03;	author espie;	state Exp;
branches;
next	1.152;
commitid	oOAF1yO2vR1MvafY;

1.152
date	2015.03.14.20.45.11;	author espie;	state Exp;
branches;
next	1.151;
commitid	F3KXERWdpj8W1V50;

1.151
date	2014.11.22.12.44.37;	author espie;	state Exp;
branches;
next	1.150;
commitid	eTF4nTqDkvSbZUkF;

1.150
date	2014.03.17.10.47.45;	author espie;	state Exp;
branches;
next	1.149;

1.149
date	2014.03.16.17.22.05;	author espie;	state Exp;
branches;
next	1.148;

1.148
date	2014.03.16.08.52.53;	author espie;	state Exp;
branches;
next	1.147;

1.147
date	2014.03.15.09.51.27;	author espie;	state Exp;
branches;
next	1.146;

1.146
date	2014.03.09.20.30.10;	author espie;	state Exp;
branches;
next	1.145;

1.145
date	2014.03.09.20.25.19;	author espie;	state Exp;
branches;
next	1.144;

1.144
date	2014.03.09.20.24.18;	author espie;	state Exp;
branches;
next	1.143;

1.143
date	2014.01.10.11.26.43;	author espie;	state Exp;
branches;
next	1.142;

1.142
date	2013.12.30.12.28.23;	author espie;	state Exp;
branches;
next	1.141;

1.141
date	2013.12.07.16.03.03;	author espie;	state Exp;
branches;
next	1.140;

1.140
date	2013.11.16.16.39.28;	author espie;	state Exp;
branches;
next	1.139;

1.139
date	2013.11.16.13.06.00;	author espie;	state Exp;
branches;
next	1.138;

1.138
date	2013.10.17.18.09.42;	author espie;	state Exp;
branches;
next	1.137;

1.137
date	2013.10.13.19.57.07;	author espie;	state Exp;
branches;
next	1.136;

1.136
date	2013.10.12.13.52.03;	author espie;	state Exp;
branches;
next	1.135;

1.135
date	2013.10.11.11.51.04;	author espie;	state Exp;
branches;
next	1.134;

1.134
date	2013.10.10.20.52.04;	author espie;	state Exp;
branches;
next	1.133;

1.133
date	2013.10.10.15.48.16;	author espie;	state Exp;
branches;
next	1.132;

1.132
date	2013.10.10.10.48.35;	author espie;	state Exp;
branches;
next	1.131;

1.131
date	2013.10.10.07.15.49;	author espie;	state Exp;
branches;
next	1.130;

1.130
date	2013.10.07.17.50.29;	author espie;	state Exp;
branches;
next	1.129;

1.129
date	2013.10.06.13.33.37;	author espie;	state Exp;
branches;
next	1.128;

1.128
date	2013.10.06.12.40.44;	author espie;	state Exp;
branches;
next	1.127;

1.127
date	2013.10.06.07.08.09;	author espie;	state Exp;
branches;
next	1.126;

1.126
date	2013.10.04.20.28.41;	author espie;	state Exp;
branches;
next	1.125;

1.125
date	2013.10.04.17.48.24;	author espie;	state Exp;
branches;
next	1.124;

1.124
date	2013.10.04.11.17.33;	author espie;	state Exp;
branches;
next	1.123;

1.123
date	2013.10.04.07.18.38;	author espie;	state Exp;
branches;
next	1.122;

1.122
date	2013.10.04.07.15.10;	author espie;	state Exp;
branches;
next	1.121;

1.121
date	2013.10.03.18.21.16;	author espie;	state Exp;
branches;
next	1.120;

1.120
date	2013.10.03.18.16.53;	author espie;	state Exp;
branches;
next	1.119;

1.119
date	2013.10.03.17.42.58;	author espie;	state Exp;
branches;
next	1.118;

1.118
date	2013.10.03.08.02.55;	author espie;	state Exp;
branches;
next	1.117;

1.117
date	2013.10.02.09.16.01;	author espie;	state Exp;
branches;
next	1.116;

1.116
date	2013.09.23.12.32.59;	author espie;	state Exp;
branches;
next	1.115;

1.115
date	2013.09.23.12.25.17;	author espie;	state Exp;
branches;
next	1.114;

1.114
date	2013.09.21.08.56.44;	author espie;	state Exp;
branches;
next	1.113;

1.113
date	2013.09.18.13.26.40;	author espie;	state Exp;
branches;
next	1.112;

1.112
date	2013.09.08.11.10.59;	author espie;	state Exp;
branches;
next	1.111;

1.111
date	2013.07.21.16.24.32;	author espie;	state Exp;
branches;
next	1.110;

1.110
date	2013.07.18.05.36.55;	author espie;	state Exp;
branches;
next	1.109;

1.109
date	2013.07.12.08.07.19;	author espie;	state Exp;
branches;
next	1.108;

1.108
date	2013.07.04.17.45.34;	author jasper;	state Exp;
branches;
next	1.107;

1.107
date	2013.07.01.12.35.35;	author espie;	state Exp;
branches;
next	1.106;

1.106
date	2013.06.30.16.35.43;	author espie;	state Exp;
branches;
next	1.105;

1.105
date	2013.06.04.03.20.36;	author espie;	state Exp;
branches;
next	1.104;

1.104
date	2013.04.30.10.22.37;	author espie;	state Exp;
branches;
next	1.103;

1.103
date	2013.04.22.10.02.22;	author espie;	state Exp;
branches;
next	1.102;

1.102
date	2013.04.13.16.13.34;	author espie;	state Exp;
branches;
next	1.101;

1.101
date	2013.04.13.10.04.43;	author espie;	state Exp;
branches;
next	1.100;

1.100
date	2013.03.03.00.42.40;	author espie;	state Exp;
branches;
next	1.99;

1.99
date	2013.02.07.06.46.58;	author espie;	state Exp;
branches;
next	1.98;

1.98
date	2013.02.03.21.45.52;	author espie;	state Exp;
branches;
next	1.97;

1.97
date	2013.02.02.13.35.17;	author espie;	state Exp;
branches;
next	1.96;

1.96
date	2013.02.02.12.31.06;	author espie;	state Exp;
branches;
next	1.95;

1.95
date	2013.02.02.12.30.32;	author espie;	state Exp;
branches;
next	1.94;

1.94
date	2013.01.28.13.31.40;	author espie;	state Exp;
branches;
next	1.93;

1.93
date	2013.01.28.13.25.59;	author espie;	state Exp;
branches;
next	1.92;

1.92
date	2013.01.27.23.15.12;	author espie;	state Exp;
branches;
next	1.91;

1.91
date	2013.01.21.15.08.25;	author espie;	state Exp;
branches;
next	1.90;

1.90
date	2013.01.21.14.56.29;	author espie;	state Exp;
branches;
next	1.89;

1.89
date	2013.01.21.12.29.52;	author espie;	state Exp;
branches;
next	1.88;

1.88
date	2013.01.21.12.03.32;	author espie;	state Exp;
branches;
next	1.87;

1.87
date	2013.01.21.11.06.59;	author espie;	state Exp;
branches;
next	1.86;

1.86
date	2013.01.21.10.46.42;	author espie;	state Exp;
branches;
next	1.85;

1.85
date	2013.01.21.02.06.12;	author espie;	state Exp;
branches;
next	1.84;

1.84
date	2013.01.21.02.01.08;	author espie;	state Exp;
branches;
next	1.83;

1.83
date	2013.01.18.21.11.55;	author espie;	state Exp;
branches;
next	1.82;

1.82
date	2013.01.16.10.38.56;	author espie;	state Exp;
branches;
next	1.81;

1.81
date	2013.01.13.14.04.00;	author espie;	state Exp;
branches;
next	1.80;

1.80
date	2013.01.12.14.44.41;	author espie;	state Exp;
branches;
next	1.79;

1.79
date	2013.01.12.13.51.43;	author espie;	state Exp;
branches;
next	1.78;

1.78
date	2013.01.11.21.16.08;	author espie;	state Exp;
branches;
next	1.77;

1.77
date	2013.01.11.20.11.54;	author espie;	state Exp;
branches;
next	1.76;

1.76
date	2013.01.11.17.39.03;	author espie;	state Exp;
branches;
next	1.75;

1.75
date	2013.01.11.17.35.43;	author espie;	state Exp;
branches;
next	1.74;

1.74
date	2013.01.11.17.23.51;	author espie;	state Exp;
branches;
next	1.73;

1.73
date	2013.01.11.16.59.07;	author espie;	state Exp;
branches;
next	1.72;

1.72
date	2013.01.11.16.35.47;	author espie;	state Exp;
branches;
next	1.71;

1.71
date	2013.01.11.16.24.26;	author espie;	state Exp;
branches;
next	1.70;

1.70
date	2013.01.11.16.11.21;	author espie;	state Exp;
branches;
next	1.69;

1.69
date	2013.01.11.15.48.51;	author espie;	state Exp;
branches;
next	1.68;

1.68
date	2013.01.11.15.35.53;	author espie;	state Exp;
branches;
next	1.67;

1.67
date	2013.01.10.21.41.55;	author espie;	state Exp;
branches;
next	1.66;

1.66
date	2013.01.10.12.27.21;	author espie;	state Exp;
branches;
next	1.65;

1.65
date	2013.01.10.12.05.55;	author espie;	state Exp;
branches;
next	1.64;

1.64
date	2013.01.10.12.04.23;	author espie;	state Exp;
branches;
next	1.63;

1.63
date	2013.01.10.12.00.38;	author espie;	state Exp;
branches;
next	1.62;

1.62
date	2013.01.10.11.56.53;	author espie;	state Exp;
branches;
next	1.61;

1.61
date	2013.01.10.10.35.36;	author espie;	state Exp;
branches;
next	1.60;

1.60
date	2013.01.07.10.59.41;	author espie;	state Exp;
branches;
next	1.59;

1.59
date	2013.01.05.23.38.08;	author espie;	state Exp;
branches;
next	1.58;

1.58
date	2013.01.05.20.08.39;	author espie;	state Exp;
branches;
next	1.57;

1.57
date	2013.01.05.20.06.29;	author espie;	state Exp;
branches;
next	1.56;

1.56
date	2013.01.05.18.09.30;	author espie;	state Exp;
branches;
next	1.55;

1.55
date	2013.01.05.18.08.06;	author espie;	state Exp;
branches;
next	1.54;

1.54
date	2013.01.05.17.29.14;	author espie;	state Exp;
branches;
next	1.53;

1.53
date	2013.01.05.17.22.05;	author espie;	state Exp;
branches;
next	1.52;

1.52
date	2013.01.05.16.57.31;	author espie;	state Exp;
branches;
next	1.51;

1.51
date	2013.01.03.15.45.18;	author espie;	state Exp;
branches;
next	1.50;

1.50
date	2012.12.30.11.47.24;	author espie;	state Exp;
branches;
next	1.49;

1.49
date	2012.12.28.06.31.03;	author espie;	state Exp;
branches;
next	1.48;

1.48
date	2012.12.27.12.20.36;	author espie;	state Exp;
branches;
next	1.47;

1.47
date	2012.12.27.12.03.33;	author espie;	state Exp;
branches;
next	1.46;

1.46
date	2012.12.25.10.43.36;	author espie;	state Exp;
branches;
next	1.45;

1.45
date	2012.12.25.10.25.04;	author espie;	state Exp;
branches;
next	1.44;

1.44
date	2012.12.24.17.19.01;	author espie;	state Exp;
branches;
next	1.43;

1.43
date	2012.11.18.01.59.31;	author espie;	state Exp;
branches;
next	1.42;

1.42
date	2012.11.09.17.49.17;	author espie;	state Exp;
branches;
next	1.41;

1.41
date	2012.10.13.09.06.56;	author espie;	state Exp;
branches;
next	1.40;

1.40
date	2012.10.13.08.32.58;	author espie;	state Exp;
branches;
next	1.39;

1.39
date	2012.10.12.20.24.56;	author espie;	state Exp;
branches;
next	1.38;

1.38
date	2012.10.11.09.03.34;	author espie;	state Exp;
branches;
next	1.37;

1.37
date	2012.10.11.08.38.05;	author espie;	state Exp;
branches;
next	1.36;

1.36
date	2012.10.11.07.38.39;	author espie;	state Exp;
branches;
next	1.35;

1.35
date	2012.10.08.12.41.03;	author espie;	state Exp;
branches;
next	1.34;

1.34
date	2012.09.23.18.13.32;	author espie;	state Exp;
branches;
next	1.33;

1.33
date	2012.07.18.10.31.18;	author espie;	state Exp;
branches;
next	1.32;

1.32
date	2012.07.06.12.01.29;	author espie;	state Exp;
branches;
next	1.31;

1.31
date	2012.07.04.08.59.10;	author espie;	state Exp;
branches;
next	1.30;

1.30
date	2012.04.21.21.09.07;	author espie;	state Exp;
branches;
next	1.29;

1.29
date	2012.04.21.14.41.37;	author espie;	state Exp;
branches;
next	1.28;

1.28
date	2012.04.21.11.30.53;	author espie;	state Exp;
branches;
next	1.27;

1.27
date	2012.04.10.17.06.15;	author espie;	state Exp;
branches;
next	1.26;

1.26
date	2012.03.02.19.33.43;	author espie;	state Exp;
branches;
next	1.25;

1.25
date	2011.12.05.21.27.53;	author espie;	state Exp;
branches;
next	1.24;

1.24
date	2011.12.05.21.18.55;	author espie;	state Exp;
branches;
next	1.23;

1.23
date	2011.12.05.18.29.39;	author espie;	state Exp;
branches;
next	1.22;

1.22
date	2011.12.05.16.10.01;	author espie;	state Exp;
branches;
next	1.21;

1.21
date	2011.12.04.12.05.41;	author espie;	state Exp;
branches;
next	1.20;

1.20
date	2011.12.03.11.10.48;	author espie;	state Exp;
branches;
next	1.19;

1.19
date	2011.12.02.22.37.36;	author espie;	state Exp;
branches;
next	1.18;

1.18
date	2011.12.02.11.40.25;	author espie;	state Exp;
branches;
next	1.17;

1.17
date	2011.11.22.16.48.01;	author espie;	state Exp;
branches;
next	1.16;

1.16
date	2011.11.14.21.57.47;	author espie;	state Exp;
branches;
next	1.15;

1.15
date	2011.11.12.13.19.26;	author espie;	state Exp;
branches;
next	1.14;

1.14
date	2011.10.10.18.56.50;	author espie;	state Exp;
branches;
next	1.13;

1.13
date	2011.09.25.10.41.30;	author espie;	state Exp;
branches;
next	1.12;

1.12
date	2011.07.14.11.03.35;	author espie;	state Exp;
branches;
next	1.11;

1.11
date	2011.06.04.12.56.54;	author espie;	state Exp;
branches;
next	1.10;

1.10
date	2011.06.02.17.09.25;	author espie;	state Exp;
branches;
next	1.9;

1.9
date	2011.05.29.09.30.13;	author espie;	state Exp;
branches;
next	1.8;

1.8
date	2011.05.22.08.21.39;	author espie;	state Exp;
branches;
next	1.7;

1.7
date	2011.04.25.11.58.46;	author espie;	state Exp;
branches;
next	1.6;

1.6
date	2010.11.01.10.55.26;	author espie;	state Exp;
branches;
next	1.5;

1.5
date	2010.10.28.14.21.18;	author espie;	state Exp;
branches;
next	1.4;

1.4
date	2010.10.28.11.56.48;	author espie;	state Exp;
branches;
next	1.3;

1.3
date	2010.09.02.11.16.09;	author jasper;	state Exp;
branches;
next	1.2;

1.2
date	2010.08.24.15.07.54;	author naddy;	state Exp;
branches;
next	1.1;

1.1
date	2010.08.20.13.40.14;	author espie;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2010.08.20.13.40.14;	author espie;	state Exp;
branches;
next	;


desc
@@


1.168
log
@synch "still_tainted" with what happens when trying to junk.
maybe there's some better more sophisticated heuristics, but for now,
if you have a "nojunk" port locked, you cannot junk on that host until
you remove the lock (for good reason, at least you can "finish" that port
undisturbed).

fix for the graphics/mapnik recent burp.
@
text
@# ex:ts=8 sw=4:
# $OpenBSD: Port.pm,v 1.167 2015/08/16 08:35:39 espie Exp $
#
# Copyright (c) 2010-2013 Marc Espie <espie@@openbsd.org>
#
# Permission to use, copy, modify, and distribute this software for any
# purpose with or without fee is hereby granted, provided that the above
# copyright notice and this permission notice appear in all copies.
#
# THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
# ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
# OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
use strict;
use warnings;

use DPB::Job;
use DPB::Clock;

package DPB::Junk;
sub want
{
	my ($class, $core, $job) = @@_;
	# job is normally attached to core, unless it's not attached,
	# and then we pass it as an extra parameter
	$job //= $core->job;
	return 2 if $job->{v}->forcejunk;
	# XXX let's wipe the slates at the start of the first tagged
	# job, as we don't know the exact state of the host.
	return 2 if $job->{v}{info}->has_property('tag') &&
	    !defined $core->prop->{last_junk};
	return 0 unless defined $core->prop->{junk};
	if ($core->prop->{depends_count} >= $core->prop->{junk}) {
		return 1;
	} else {
		return 0;
	}
}

package DPB::Task::BasePort;
our @@ISA = qw(DPB::Task::Clocked);
use OpenBSD::Paths;

sub setup
{
	return $_[0];
}

sub is_serialized { 0 }
sub want_frozen { 1 }
sub want_percent { 1 }

sub finalize
{
	my ($self, $core) = @@_;
	$self->SUPER::finalize($core);
	$core->job->finished_task($self);
	return $core->{status} == 0;
}

# note that tasks are using the "flyweight" pattern: they're
# just a name + behavior, and all the data is in job (which is
# obtained thru core)
sub new
{
	my ($class, $phase) = @@_;
	bless {phase => $phase}, $class;
}

sub fork
{
	my ($self, $core) = @@_;

	$core->job->{current} = $self->{phase};
	return $self->SUPER::fork($core);
}

sub handle_output
{
	my ($self, $job) = @@_;
	$self->redirect_fh($job->{logfh}, $job->{log});
	print ">>> Running $self->{phase} in $job->{path} at ", time(), "\n";
}

sub tweak_args
{
	my ($self, $args, $job, $builder) = @@_;
	push(@@$args,
	    "FETCH_PACKAGES=No",
	    "PREPARE_CHECK_ONLY=Yes",
	    "REPORT_PROBLEM='exit 1'", "BULK=No");
	if ($job->{parallel}) {
		push(@@$args, "MAKE_JOBS=$job->{parallel}");
	}
	if ($job->{special}) {
		push(@@$args, "USE_MFS=Yes");
	}
	if ($builder->{fetch}) {
		push(@@$args, "NO_CHECKSUM=Yes");
	}
}

sub run
{
	my ($self, $core) = @@_;
	my $job = $core->job;
	my $t = $self->{phase};
	my $builder = $job->{builder};
	my $ports = $builder->ports;
	my $fullpkgpath = $job->{path};
	if ($core->prop->{syslog}) {
		Sys::Syslog::syslog('info', "start $fullpkgpath($t)");
	}
	$self->handle_output($job);
	close STDIN;
	open STDIN, '</dev/null';
	my @@args = ($t);
	$self->tweak_args(\@@args, $job, $builder);

	my @@l = $builder->make_args;
	my $make = $builder->make;
	my @@env = ();
	if (defined $builder->{rsslog}) {
		unless ($self->notime) {
			$make = $builder->{wrapper};
			$l[0] = $make;
			push(@@env, WRAPPER_OUTPUT => $builder->{rsslog});
		}
	}

	unshift(@@args, @@l);
	$core->shell
	    ->as_root($self->{as_root})
	    ->env(SUBDIR => $fullpkgpath, 
		PHASE => $t, 
		@@env)
	    ->exec(@@args);
	exit(1);
}

sub notime { 0 }

package DPB::Task::Port;
our @@ISA = qw(DPB::Task::BasePort);

sub finalize
{
	my ($self, $core) = @@_;
	$self->SUPER::finalize($core);
	if ($core->prop->{syslog}) {
		my $fullpkgpath = $core->job->{path};
		my $t = $self->{phase};
		Sys::Syslog::syslog('info', "end $fullpkgpath($t)");
	}
	if ($core->{status} == 0) {
		return 1;
	}
	$core->job->{failed} = $core->{status};
	if ($core->prop->{always_clean}) {
		$core->job->replace_tasks(DPB::Task::Port::Clean->new(
			'clean'));
		return 1;
	}
	# XXX in case we taint the core, we will mark ourselves as cleaned
	# so the tag and dependencies may vanish.
	#
	# this is a bit of a pain for fixing errors, but this ensures bulks
	# *will* finish anyhow
	#
	if ($core->job->{v}{info}->has_property('tag')) {
		print {$core->job->{lock}} "cleaned\n";
	}
	return 0;
}

# return swallowed cores at the end of fake: package is inherently sequential
# and there's some "thundering herd" effect when we release lots of cores,
# so release them a bit early, so by the time we're finished packaging,
# they're mostly out of "waiting-for-lock"
package DPB::Task::Port::Fake;
our @@ISA = qw(DPB::Task::Port);

sub finalize
{
	my ($self, $core) = @@_;
	$core->unswallow;
	delete $core->job->{nojunk};
	$self->SUPER::finalize($core);
}

package DPB::Task::Port::Signature;
our @@ISA =qw(DPB::Task::BasePort);

sub notime { 1 }

sub run
{
	my ($self, $core) = @@_;
	my $job = $core->job;
	$self->handle_output($job);
	exit($job->{builder}->check_signature($core, $job->{v}));
}

sub finalize
{
	my ($self, $core) = @@_;
	$self->SUPER::finalize($core);
	my $job = $core->job;
	if ($core->{status} == 0) {
		my $v = $job->{v};
		my $builder = $job->{builder};
		$job->add_normal_tasks($builder->{dontclean}{$v->pkgpath}, 
		    $core);
	} else {
		$job->{signature_only} = 1;
		$job->{builder}->register_updates($job->{v});
	}
	return 1;
}

package DPB::Task::Port::Checksum;
our @@ISA = qw(DPB::Task::Port);

sub need_checksum
{
	my ($self, $log, $info) = @@_;
	my $need = 0;
	for my $dist (values %{$info->{DIST}}) {
		if (!$dist->cached_checksum($log, $dist->filename)) {
			$need = 1;
		} else {
			unlink($dist->tempfilename);
		}
	}
	return $need;
}

sub setup
{
	my ($task, $core) = @@_;
	my $job = $core->job;
	my $info = $job->{v}{info};
	if (defined $info->{distsize}) {
		print {$job->{logfh}} "distfiles size=$info->{distsize}\n";
	}
	if ($task->need_checksum($job->{logfh}, $info)) {
		return $task;
	} else {
		delete $info->{DIST};
		return $job->next_task($core);
    	}
}

sub checksum
{
	my ($self, $core) = @@_;
	my $job = $core->job;
	$self->handle_output($job);
	my $exit = 0;
	for my $dist (values %{$job->{v}{info}{DIST}}) {
		if (!$dist->checksum($dist->filename)) {
			$exit = 1;
		} else {
			unlink($dist->tempfilename);
		}
	}
	return $exit;
}

sub run
{
	my ($self, $core) = @@_;
	exit($self->checksum($core));
}

sub finalize
{
	my ($self, $core) = @@_;
	$self->SUPER::finalize($core);
	if ($core->{status} == 0) {
		delete $core->job->{v}{info}{DIST};
	}
}


package DPB::Task::Port::Serialized;
our @@ISA = qw(DPB::Task::Port);

sub is_serialized { 1 }
sub want_percent { 0 }

# note that serialized's setup will return its task only if lock
# happened succesfully, so we can use that in serialized tasks
sub setup
{
	my ($task, $core) = @@_;
	my $job = $core->job;
	if (!$job->{locked}) {
		$task->try_lock($core);
	}
	if (!$job->{locked}) {
		unshift(@@{$job->{tasks}}, $task);
		$job->{wakemeup} = 1;
		$job->{lock_order} = $core->prop->{waited_for_lock}++;
		return DPB::Task::Port::Lock->new(
		    'waiting-for-lock #'.$job->{lock_order});
	} 

	return $task;
}

sub try_lock
{
	my ($self, $core) = @@_;
	my $job = $core->job;
	my $locker = $job->{builder}->locker;

	my $fh = $job->{builder}->locker->lock($core);
	if ($fh) {
		print $fh "path=".$job->{path}, "\n";
		print {$job->{logfh}} "(Junk lock obtained for ",
		    $core->hostname, " at ", time(), ")\n";
		$job->{locked} = 1;
	}
}

sub junk_unlock
{
	my ($self, $core) = @@_;

	if ($core->job->{locked}) {
		$core->job->{builder}->locker->unlock($core);
		print {$core->job->{logfh}} "(Junk lock released for ", 
		    $core->hostname, " at ", time(), ")\n";
		delete $core->job->{locked};
		$core->job->wake_others($core);
	}
}

sub finalize
{
	my ($self, $core) = @@_;
	my $job = $core->job;
	my $task = $job->{tasks}[0];
	# XXX if we didn't lock at the entrance, we locked here.
	$job->{locked} = 1;
	if ($core->{status} != 0 || !defined $task || !$task->is_serialized) {
		$self->junk_unlock($core);
	}
	$self->SUPER::finalize($core);
}


# this is the full locking task, the one that has to wait.

package DPB::Task::Port::Lock;
our @@ISA = qw(DPB::Task::Port::Serialized);

sub setup
{
	return $_[0];
}

sub want_frozen { 0 }

sub run
{
	my ($self, $core) = @@_;
	my $job = $core->job;
	$SIG{IO} = sub { print {$job->{logfh}} "Received IO\n"; };
	my $date = time;
	use POSIX;

	while (1) {
		$self->try_lock($core);
		if ($job->{locked}) {
			print {$job->{builder}{lockperf}} 
			    time(), ":", $core->hostname, 
			    ": $self->{phase}: ", time() - $date, " seconds\n";
			exit(0);
		}
		print {$job->{logfh}} "(Junk lock failure for ",
		    $core->hostname, " at ", time(), ")\n";
		pause;
	}
}

sub finalize
{
	my ($self, $core) = @@_;
	$core->job->{locked} = 1;
	delete $core->job->{wakemeup};
	$self->SUPER::finalize($core);
}

package DPB::Task::Port::Depends;
our @@ISA=qw(DPB::Task::Port::Serialized);

sub notime { 1 }

sub recompute_depends
{
	my ($self, $core) = @@_;
	# we're running this synchronously with other jobs, so 
	# let's try avoid running pkg_add if we can !
	# compute all missing deps for all jobs currently waiting
	my $deps = {};

	# XXX not a "same_host_jobs" as we're in setup, so not
	# actually running
	for my $d (keys %{$core->job->{depends}}) {
		$deps->{$d} = $d;
	}
	for my $job ($core->same_host_jobs) {
		next if $job->{shunt_depends};
		for my $d (keys %{$job->{depends}}) {
			$deps->{$d} = $d;
			$job->{shunt_depends} = $core->job->{path};
		}
	}
	for my $job ($core->same_host_jobs) {
		next unless defined $job->{live_depends};
		for my $d (@@{$job->{live_depends}}) {
			delete $deps->{$d};
		}
	}
	return $deps;
}

sub setup
{
	my ($task, $core) = @@_;
	my $job = $core->job;

	# first, we must be sure to have the lock !
	$task = $task->SUPER::setup($core);
	if (!$job->{locked}) {
		return $task;
	}

	if ($job->{shunt_depends}) {
		print {$job->{logfh}} "Short-cut: depends already handled by ",
		    $job->{shunt_depends}, "\n";
		return $job->next_task($core);
	}
	my $dep = $task->recompute_depends($core);
	if (keys %$dep == 0) {
		return $job->next_task($core);
	} else {
		$job->{dodeps} = $dep;
		return $task;
	}
}

sub run
{
	my ($self, $core) = @@_;
	my $job = $core->job;
	$self->handle_output($job);
	if ($core->prop->{syslog}) {
		Sys::Syslog::syslog('info', "start $job->{path}(depends)");
	}

	if (defined $core->prop->{last_junk}) {
		print "   last junk was in ",
		    $core->prop->{last_junk}->fullpkgpath, "\n";
	}
	my @@cmd = ('/usr/sbin/pkg_add', '-aI');
	if ($job->{builder}{state}{signer}) {
		push(@@cmd, $job->{builder}{state}{signer});
	}
	if ($job->{builder}{update}) {
		push(@@cmd, "-rqU", "-Dupdate", "-Dupdatedepends");
	}
	if ($job->{builder}{forceupdate}) {
		push(@@cmd,  "-Dinstalled");
	}
	if ($core->prop->{repair}) {
		push(@@cmd, "-Drepair");
	}
	if ($job->{builder}{state}{localbase} ne '/usr/local') {
		push(@@cmd, "-L", $job->{builder}{state}{localbase});
	}
	my @@l = (sort keys %{$job->{dodeps}});
	print join(' ', @@cmd, @@l), "\n";
	print "was: ", join(' ', @@cmd, (sort keys %{$job->{depends}})), "\n";
	print join(' ', @@cmd, @@l), "\n";
	my $path = $job->{builder}{fullrepo}.'/';
	$core->shell->env(PKG_PATH => $path)->as_root->exec(@@cmd, @@l);
	exit(1);
}

sub finalize
{
	my ($self, $core) = @@_;
	$core->{status} = 0;

	$self->SUPER::finalize($core);
	return 1;
}

package DPB::Task::Port::PrepareResults;
our @@ISA = qw(DPB::Task::Port::Serialized);

sub setup
{
	my ($task, $core) = @@_;
	my $job = $core->job;
	$job->{pos} = tell($job->{logfh});
	return $task->SUPER::setup($core);
}

sub finalize
{
	my ($self, $core) = @@_;

	my $job = $core->{job};
	my $v = $job->{v};
	# reopen log at right location
	my $fh = $job->{builder}->logger->open('<', $job->{log});
	if (defined $fh && seek($fh, $job->{pos}, 0)) {
		my @@r;
		while (<$fh>) {
			last if m/^\>\>\>\s+Running\s+show-prepare-results/;
		}
		while (<$fh>) {
			# zap headers
			next if m/^\>\>\>\s/ || m/^\=\=\=\>\s/;
			chomp;
			# normal lines *only have one package name*
			next if m/\s/;
			push(@@r, $_);
		}
		close $fh;
		$job->save_depends(\@@r);
		# XXX we ran junk before us, so retaint *now* before losing the lock
		if ($job->{v}{info}->has_property('tag') && 
		    !defined $core->prop->{tainted}) {
		    	$core->prop->taint($v);
                        print {$job->{logfh}} "Forced junk, retainting: ", 
			    $core->prop->{tainted}, "\n";
		}
	} else {
		$core->{status} = 1;
	}
	$self->SUPER::finalize($core);
}

package DPB::Task::Port::Uninstall;
our @@ISA=qw(DPB::Task::Port::Serialized);

sub notime { 1 }

# uninstall is actually a "tentative" junk case
# it might not happen for various reasons:
# - a port that's building on the same host that says "nojunk"
# - something else went thru simultaneously and junked already


sub setup
{
	my ($task, $core) = @@_;
	# we got pre-empted
	# no actual need to junk
	if (!DPB::Junk->want($core)) {
		$task->junk_unlock($core);
		return $core->job->next_task($core);
	}
	# okay we have to make sure we're locked first
	my $t2 = $task->SUPER::setup($core);
	if ($t2 != $task) {
		return $t2;
	}
	my $fh = $core->job->{logfh};
	# so we're locked, let's boogie
	my $still_tainted = 0;
	for my $job ($core->same_host_jobs) {
		if ($job->{nojunk}) {
			# we can't junk go next
			print $fh "Don't run junk because nojunk in ",
			    $job->{path}, "\n";
			$task->junk_unlock($core);
			return $core->job->next_task($core);
		}
		if ($job->{v}{info}->has_property('tag')) {
			$still_tainted = 1;
		}
	}
	if (defined $core->job->{builder}->locker->find_tag($core->hostname)) {
		$still_tainted = 1;
	}
	# XXX deal better with old nojunk stuff ?
	# there are some decisions to take. For now, let's just make sure
	# it's not broken
	my $h = $core->job->{builder}->locker->find_dependencies($core->hostname);
	if (!ref $h) {
		$still_tainted = 1;
	}
	# we are going along with junk, BUT we may still be tainted
	print $fh "Still tainted: $still_tainted\n";
	if (!$still_tainted) {
		$core->prop->untaint;
	}
	return $task;
}

sub add_dontjunk
{
	my ($self, $job, $h) = @@_;
	return if !defined $job->{builder}{dontjunk};
	for my $pkgname (keys %{$job->{builder}{dontjunk}}) {
		$h->{$pkgname} = 1;
	}
}

sub add_live_depends
{
	my ($self, $h, $core) = @@_;
	for my $job ($core->same_host_jobs) {
		if (defined $job->{live_depends}) {
			for my $d (@@{$job->{live_depends}}) {
				$h->{$d} = 1;
			}
		}
		for my $d (keys %{$job->{depends}}) {
			$h->{$d} = 1;
		}
	}
	return 1;
}

sub run
{
	my ($self, $core) = @@_;
	my $job = $core->job;
	my $v = $job->{v};

	$self->handle_output($job);

	my $h = $job->{builder}->locker->find_dependencies($core->hostname);
	if (!ref $h) {
		print "Can't run junk because of lock on $h\n";
		exit(2);
	}
	if ($self->add_live_depends($h, $core)) {
		$self->add_dontjunk($job, $h);
		my $opt = '-aIX';
		if ($core->prop->{nochecksum}) {
			$opt .= 'q';
		}
		my @@cmd = ('/usr/sbin/pkg_delete', $opt, sort keys %$h);
		print join(' ', @@cmd, "\n");
		$core->shell->as_root->exec(@@cmd);
		exit(1);
	} else {
		exit(2);
	}
}

sub finalize
{
	my ($self, $core) = @@_;

	# did we really run ? then clean up stuff
	if ($core->{status} == 0) {
		$core->prop->{last_junk} = $core->job->{v};
		$core->prop->{junk_count} = 0;
		$core->prop->{ports_count} = 0;
		$core->prop->{depends_count} = 0;
	}
	$core->{status} = 0;
	$self->SUPER::finalize($core);
	return 1;
}

# there's nothing to run here, just where we get committed to affinity
package DPB::Task::Port::InBetween;
our @@ISA = qw(DPB::Task::BasePort);
sub setup
{
	my ($self, $core) = @@_;

	my $job = $core->job;

	$job->{builder}{state}{affinity}->start($job->{v}, $core);

	return $job->next_task($core);
}

package DPB::Task::Port::ShowSize;
our @@ISA = qw(DPB::Task::Port);

sub want_percent { 0 }

sub fork
{
	my ($self, $core) = @@_;
	open($self->{fh}, "-|");
}

sub handle_output
{
}

sub finalize
{
	my ($self, $core) = @@_;
	my $fh = $self->{fh};
	if ($core->{status} == 0) {
		my $line = <$fh>;
		$line = <$fh>;
		if ($line =~ m/^\s*(\d+)\s+/) {
			my $sz = $1;
			my $job = $core->job;
			my $info = DPB::Serialize::Size->write({
			    pkgpath => $job->{path},
			    pkname => $job->{v}->fullpkgname,
			    size => $sz,
			    ts => CORE::time });
			print {$job->{builder}{logsize}} $info, "\n";
			# XXX the rolling log might be shared with other dpb
			# so it can be rewritten and sorted
			# don't keep a handle on it, so that we always
			# append new information to the correct filename
			my $fh2 = $job->{builder}->logger->open('>>', $job->{builder}{state}{size_log});
			print $fh2 $info."\n";
		}
	}
	close($fh);
	return 1;
}

package DPB::Task::Port::Install;
our @@ISA=qw(DPB::Task::Port);

sub notime { 1 }

sub want_percent { 0 }

sub run
{
	my ($self, $core) = @@_;
	my $job = $core->job;
	my $v = $job->{v};

	$self->handle_output($job);
	my @@cmd = ('/usr/sbin/pkg_add', '-I');
	if ($job->{builder}{state}{signer}) {
		push(@@cmd, $job->{builder}{state}{signer});
	}
	if ($job->{builder}->{update}) {
		push(@@cmd, "-rqU", "-Dupdate", "-Dupdatedepends");
	}
	if ($job->{builder}->{forceupdate}) {
		push(@@cmd,  "-Dinstalled");
	}
	if ($job->{builder}{state}{localbase} ne '/usr/local') {
		push(@@cmd, "-L", $job->{builder}{state}{localbase});
	}
	print join(' ', @@cmd, $v->fullpkgname, "\n");
	my $path = $job->{builder}->{fullrepo}.'/';
	$ENV{PKG_PATH} = $path;
	$core->shell->nochroot->env(PKG_PATH => $path)->as_root
	    ->exec(@@cmd, $v->fullpkgname);
	exit(1);
}

sub finalize
{
	my ($self, $core) = @@_;
	$core->{status} = 0;
	$self->SUPER::finalize($core);
	return 1;
}


package DPB::Task::Port::Fetch;
our @@ISA = qw(DPB::Task::Port);

sub notime { 1 }

sub finalize
{
	my ($self, $core) = @@_;

	# if there's a watch file, then we remove the current size,
	# so that we DON'T take prepare into account.
	my $job = $core->job;
	if (defined $job->{watched}) {
		$job->{watched}->reset_offset;
	}
	$self->SUPER::finalize($core);
}

package DPB::Task::Port::Clean;
our @@ISA = qw(DPB::Task::BasePort);

sub notime { 1 }
sub want_percent { 0 }

sub setup
{
	my ($task, $core) = @@_;
	print {$core->job->{lock}} "cleaned\n";
	return $task;
}
sub finalize
{
	my ($self, $core) = @@_;
	$self->SUPER::finalize($core);
	return 1;
}

package DPB::Task::Test;
our @@ISA = qw(DPB::Task::BasePort);

# to put test results elsewhere
#sub redirect_output
#{
#}

sub finalize
{
	my ($self, $core) = @@_;
	$self->SUPER::finalize($core);
	# we always make as though we succeeded
	return 1;
}

package DPB::Task::PrepareTestResults;
our @@ISA = qw(DPB::Task::PrepareResults);

package DPB::Port::TaskFactory;
my $repo = {
	default => 'DPB::Task::Port',
	checksum => 'DPB::Task::Port::Checksum',
	clean => 'DPB::Task::Port::Clean',
	'show-prepare-results' => 'DPB::Task::Port::PrepareResults',
	'show-prepare-test-results' => 'DPB::Task::Port::PrepareResults',
	fetch => 'DPB::Task::Port::Fetch',
	depends => 'DPB::Task::Port::Depends',
	'show-size' => 'DPB::Task::Port::ShowSize',
	junk => 'DPB::Task::Port::Uninstall',
	inbetween => 'DPB::Task::Port::InBetween',
	fake => 'DPB::Task::Port::Fake',
};

sub create
{
	my ($class, $k) = @@_;
	my $fw = $repo->{$k};
	$fw //= $repo->{default};
	$fw->new($k);
}

package DPB::Job::BasePort;
our @@ISA = qw(DPB::Job::Normal);

use Time::HiRes qw(time);

sub new
{
	my ($class, $log, $fh, $v, $lock, $builder, $special, $core, 
	    $endcode) = @@_;
	my $job = bless {
	    tasks => [],
	    log => $log,
	    logfh => $fh, 
	    v => $v,
	    lock => $lock,
	    path => $v->fullpkgpath,
	    special => $special,  current => '',
	    builder => $builder},
		$class;

	$job->{endcode} = sub { 
		close($job->{logfh}); 
		&$endcode; };

	return $job;
}

sub debug_dump
{
	my $self = shift;	
	return $self->{v}->fullpkgpath;
}

# a small wrapper that allows us to initialize things
sub next_task
{
	my ($self, $core) = @@_;
	my $task = shift @@{$self->{tasks}};
	if (defined $task) {
		return $task->setup($core);
	} else {
		return $task;
	}
}

sub save_depends
{
	my ($job, $l) = @@_;
	$job->{live_depends} = $l;
	if ($job->{v}{info}->has_property('nojunk')) {
		print {$job->{lock}} "nojunk\n";
		$job->{nojunk} = 1;
	}
	print {$job->{lock}} "needed=", join(' ', sort @@$l), "\n";
}

sub save_wanted_depends
{
	my $job = shift;
	print {$job->{lock}} "wanted=", 
	    join(' ', sort keys %{$job->{depends}}), "\n";
}

sub need_depends
{
	my ($self, $core, $with_tests) = @@_;
	my $dep = $self->{v}{info}->solve_depends($with_tests);
	return 0 unless %$dep;
	# XXX we are running this synchronously with other jobs on the
	# same host, so we know exactly which live_depends we can reuse.
	# try to see if other jobs that already have locks are enough to
	# satisfy our depends, then we can completely avoid a pkg_add
	my @@live = ();
	my %deps2 = %$dep;
	for my $job ($core->same_host_jobs) {
		next unless defined $job->{live_depends};
		for my $d (@@{$job->{live_depends}}) {
			if (defined $deps2{$d}) {
				delete $deps2{$d};
				push(@@live, $d);
			}
		}
	}
	my $c = scalar(keys %deps2);
	if (!$c) {
		$self->save_depends(\@@live);
		print {$self->{logfh}} "Avoided depends for ", 
		    join(' ', @@live), "\n";
	} else {
		$self->save_wanted_depends;
		$self->{depends} = $dep;
	}
	return $c;
}

my $logsize = {};
my $times = {};

sub add_build_info
{
	my ($class, $pkgpath, $host, $time, $sz) = @@_;
	$logsize->{$pkgpath} = $sz;
	$times->{$pkgpath} = $time;
}


sub current_task
{
	my $self = shift;
	if (@@{$self->{tasks}} > 0) {
		return $self->{tasks}[0]{phase};
	} else {
		return "<nothing>";
	}
}

sub pkgpath
{
	my $self = shift;
	return $self->{v};
}

sub name
{
	my $self = shift;
	my $n = $self->{path}."(".$self->{task}{phase}.")";
	if ($self->{nojunk}) {
		return $n.'!';
	} else {
		return $n;
	}
}

sub finished_task
{
	my ($self, $task) = @@_;
	push(@@{$self->{done}}, $task);
}

sub finalize
{
	my $self = shift;
	if ($self->{stuck}) {
		open my $fh, ">>", $self->{log};
		print $fh $self->{stuck}, "\n";
	}
	$self->SUPER::finalize(@@_);
}

sub totaltime
{
	my $self = shift;
	my $t = 0;
	for my $plus (@@{$self->{done}}) {
		next if $plus->notime;
		$t += $plus->elapsed;
    	}
	$t *= $self->{parallel} if $self->{parallel};
	return sprintf("%.2f", $t);
}

sub timings
{
	my $self = shift;
	return join('/', "max_stuck=".$self->{watched}{max}, map {sprintf("%s=%.2f", $_->{phase}, $_->elapsed)} @@{$self->{done}});
}

sub equates
{
	my ($class, $h) = @@_;
	for my $v (values %$h) {
		next unless defined $logsize->{$v};
		for my $w (values %$h) {
			$logsize->{$w} //= $logsize->{$v};
			$times->{$w} //= $logsize->{$v};
		}
		return;
	}
}

sub set_watch
{
	my ($self, $logger, $v) = @@_;
	my $expected;
	for my $w ($v->build_path_list) {
		if (defined $logsize->{$w}) {
			$expected = $logsize->{$w};
			last;
		}
	}
	$self->{watched} = DPB::Watch->new(
	    $logger->file($logger->log_pkgpath($v)),
	    $expected, $self->{offset}, $self->{started});
}

sub watched
{
	my ($self, $current, $core) = @@_;
	my $w = $self->{watched};
	return "" unless defined $w;
	my $diff = $w->check_change($current);
	my $msg = '';
	if ($self->{task}->want_percent) {
		$msg .= $w->percent_message;
	}
	if ($self->{task}->want_frozen) {
		$msg .= $w->frozen_message($diff);
	}
	my $stuck = $core->stuck_timeout;
	if (defined $stuck) {
		if ($diff > $stuck) {
			local $> = 0;
			$self->{stuck} =
			    "KILLED: $self->{current} stuck at $msg";
			kill 9, $core->{pid};
			return $self->{stuck};
		}
	}
	return $msg;
}

sub really_watch
{
	my ($self, $current) = @@_;
	return "" unless defined $self->{watched};
	my $diff = $self->{watched}->check_change($current);
	$self->{lastdiff} //= 5;
	if ($diff > $self->{lastdiff} * 2) {
		$self->{lastdiff} = $diff;
		return 1;
	} elsif ($diff < $self->{lastdiff}) {
		$self->{lastdiff} = 5;
	}
	return 0;
}


package DPB::Job::Port;
our @@ISA = qw(DPB::Job::BasePort);

sub new
{
	my $class = shift;
	my ($log, $fh, $v, $lock, $builder, $special, $core, 
	    $endcode) = @@_;

	my $job = $class->SUPER::new(@@_);

	my $prop = $core->prop;
	if ($prop->{parallel} =~ m/^\/(\d+)$/) {
		if ($prop->{jobs} == 1) {
			$prop->{parallel} = 0;
		} else {
			$prop->{parallel} = int($prop->{jobs}/$1);
			if ($prop->{parallel} < 2) {
				$prop->{parallel} = 2;
			}
		}
	}
	if ($prop->{parallel} && $v->{info}->has_property('parallel')) {
		$job->{parallel} = $prop->{parallel};
	}

	if ($builder->checks_rebuild($v)) {
		push(@@{$job->{tasks}},
		    DPB::Task::Port::Signature->new('signature'));
	} else {
		$job->add_normal_tasks($builder->{dontclean}{$v->pkgpath},
		    $core);
	}
	return $job;
}

sub new_junk_only
{
	my $class = shift;
	my ($log, $fh, $v, $lock, $builder, $special, $core, 
	    $endcode) = @@_;

	my $job = $class->SUPER::new(@@_);
	my $fh2 = $job->{builder}->logger->append("junk");
	print $fh2 "$$@@", CORE::time(), ": ", $core->hostname,
	    ": forced junking -> $job->{path}\n";
	$job->add_tasks(DPB::Port::TaskFactory->create('junk'));
	return $job;
}


sub add_normal_tasks
{
	my ($self, $dontclean, $core) = @@_;

	my @@todo;
	my $builder = $self->{builder};
	my $hostprop = $core->prop;
	my $small = 0;
	if (defined $times->{$self->{v}} && 
	    $times->{$self->{v}} < $hostprop->{small_timeout}) {
		$small = 1;
	}
	if ($builder->{clean}) {
		$self->insert_tasks(DPB::Task::Port::Clean->new('clean'));
	}
	$hostprop->{junk_count} //= 0;
	$hostprop->{depends_count} //= 0;
	$hostprop->{ports_count} //= 0;
	my $c = $self->need_depends($core, 0);
	$hostprop->{ports_count}++;
	$hostprop->{depends_count} += $c;
	my $junk = DPB::Junk->want($core, $self);
	if ($junk == 2) {
		push(@@todo, 'junk');
		my $fh = $self->{builder}->logger->append("junk");
		print $fh "$$@@", CORE::time(), ": ", $core->hostname,
		    ": forced junking -> $self->{path}\n";
	}
	if ($c) {
		$hostprop->{junk_count}++;
		push(@@todo, qw(depends show-prepare-results));
	}
	# gc stuff we will no longer need
	delete $self->{v}{info}{solved};
	if ($junk == 1) {
		my $fh = $self->{builder}->logger->append("junk");
		print $fh "$$@@", CORE::time(), ": ", $core->hostname,
		    ": depends=$hostprop->{depends_count} ",
		    " ports=$hostprop->{ports_count} ",
		    " junk=$hostprop->{junk_count} -> $self->{path}\n";
		push(@@todo, 'junk');
	}
	if ($builder->{fetch}) {
		push(@@todo, qw(checksum));
	} else {
		push(@@todo, qw(fetch));
	}

	push(@@todo, qw(inbetween));
	if (!$small) {
		push(@@todo, qw(patch configure));
	}
	push(@@todo, qw(build));

	if (!$small) {
		push(@@todo, qw(fake));
	}
	push(@@todo, qw(package));
	if ($builder->want_size($self->{v}, $core)) {
		push @@todo, 'show-size';
	}
	if ($self->{v}{info}->want_tests) {
		$dontclean = 1;
	}
	if (!$dontclean) {
		push @@todo, 'clean';
	}
	$self->add_tasks(map {DPB::Port::TaskFactory->create($_)} @@todo);
}

sub wake_others
{
	my ($self, $core) = @@_;
	my ($minjob, $minpid);
	$core->walk_same_host_jobs(
	    sub {
		my ($pid, $job) = @@_;
		return unless $job->{wakemeup};
		if (!defined $minjob || 
		    $job->{lock_order} < $minjob->{lock_order}) {
			$minjob = $job;
			$minpid = $pid;
		}
	    });
	if (defined $minjob) {
		local $> = 0;
		kill IO => $minpid;
		print {$core->job->{logfh}} "Woken up $minjob->{path}\n";
	}
}

package DPB::Job::Port::Test;
our @@ISA = qw(DPB::Job::BasePort);
sub new
{
	my $class = shift;
	my ($log, $fh, $v, $lock, $builder, $special, $core, 
	    $endcode) = @@_;

	my $job = $class->SUPER::new(@@_);

	$job->add_test_tasks($core);

	return $job;
}

sub add_test_tasks
{
	my ($self, $core) = @@_;
	my @@todo;

	my $c = $self->need_depends($core, 1);
	if ($c) {
		push(@@todo, qw(depends show-prepare-test-results));
	}
	delete $self->{v}{info}{solved};
	push(@@todo, qw(test clean));

	$self->add_tasks(map {DPB::Port::TaskFactory->create($_)} @@todo);
}

package DPB::Job::Port::Install;
our @@ISA = qw(DPB::Job::BasePort);

sub new
{
	my ($class, $log, $fh, $v, $builder, $endcode) = @@_;
	my $job = bless {
	    tasks => [],
	    log => $log, 
	    logfh => $fh,
	    v => $v,
	    path => $v->fullpkgpath,
	    builder => $builder,
	    endcode => $endcode},
		$class;

	push(@@{$job->{tasks}},
		    DPB::Task::Port::Install->new('install'));
	return $job;
}

1;
@


1.167
log
@simplify/fix PrepareResults. Use setup to record the correct position in
the log file.

problem noticed and sleuthed by nigel@@
@
text
@d2 1
a2 1
# $OpenBSD: Port.pm,v 1.166 2015/07/02 08:04:22 espie Exp $
d593 7
@


1.166
log
@clean-up "force junking": do not prepare a host to be untainted with the
"wrong" port, but instead, create a pseudo-path that is just there to run
junk (will be logged as junk-proxy)

fix a bug in the task handling host locking (no next task -> unlock, duh).

do not log multiple K for several ports on the same basepkgpath.
@
text
@d2 1
a2 1
# $OpenBSD: Port.pm,v 1.165 2015/06/23 09:01:56 espie Exp $
a499 3
	# keep log position to be able to seek back.
	my $job = $core->job;
	$job->{pos} = tell($job->{logfh});
d508 8
a522 1
	$job->{pos} //= 0;
@


1.165
log
@repair forced junking
always go thru taint/untaint, so that source should always be correct
@
text
@d2 1
a2 1
# $OpenBSD: Port.pm,v 1.164 2015/06/22 12:18:50 espie Exp $
d30 1
a30 1
	return 2 if $job->{v}{forcejunk};
d350 1
a350 1
	if ($core->{status} != 0 || defined $task && !$task->is_serialized) {
d1120 15
@


1.164
log
@expand on comments
@
text
@d2 1
a2 1
# $OpenBSD: Port.pm,v 1.163 2015/05/24 06:48:51 espie Exp $
d538 1
a538 1
			$core->prop->{tainted} = $job->{v}{info}->has_property('tag');
d594 1
a594 1
		delete $core->prop->{tainted};
@


1.163
log
@tweak find_dependencies to just return a result (deps or path)
reuse in can_be_junked. As exemplified by editors/tiled, a failing
port with nojunk set should also prevent junk tentatives, as these
will fail, but still untaint hosts...

seen by aja@@ and naddy@@, most probably.
@
text
@d2 1
a2 1
# $OpenBSD: Port.pm,v 1.162 2015/05/18 16:35:15 espie Exp $
d563 1
d578 1
d591 1
@


1.162
log
@use File object (name + user) to ensure watched files are watched with the
correct user. Should fix sthen@@'s problems.

(File interface to be used elsewhere, as it's less cumbersome)
@
text
@d2 1
a2 1
# $OpenBSD: Port.pm,v 1.161 2015/05/16 17:01:53 espie Exp $
d630 5
a634 1
	if (defined $h && $self->add_live_depends($h, $core)) {
@


1.161
log
@make log files more helpful, when dependencies get coalesced together and
handled by an earlier port, link to the relevant port which has the pkg_add.
Makes it much easier to figure out when show-prepare-results fails because
of conflicts in dependent ports...
@
text
@d2 1
a2 1
# $OpenBSD: Port.pm,v 1.160 2015/05/12 19:48:29 espie Exp $
d1031 2
a1032 1
	$self->{watched} = DPB::Watch->new($logger->log_pkgpath($v),
@


1.160
log
@sthen@@ has more paranoia than me.  Fix a few access cases
@
text
@d2 1
a2 1
# $OpenBSD: Port.pm,v 1.159 2015/05/10 08:14:14 espie Exp $
d445 2
@


1.159
log
@rename logger interface to desambiguate vs user.
@
text
@d2 1
a2 1
# $OpenBSD: Port.pm,v 1.158 2015/05/08 12:35:53 espie Exp $
a515 1
	my $fh;
d517 2
a518 1
	if (open($fh, '<', $job->{log}) && seek($fh, $job->{pos}, 0)) {
@


1.158
log
@it's all about the names.
Change "sudo" into "as_root" since in many cases, it won't use sudo at all
(and in the end, it WON'T use sudo ever)
@
text
@d2 1
a2 1
# $OpenBSD: Port.pm,v 1.157 2015/05/07 12:30:46 espie Exp $
d1135 1
a1135 1
		my $fh = $self->{builder}->logger->open("junk");
d1146 1
a1146 1
		my $fh = $self->{builder}->logger->open("junk");
@


1.157
log
@make sure we're root when killing stuff. I'm mixing up right and left,
obviously.
@
text
@d2 1
a2 1
# $OpenBSD: Port.pm,v 1.156 2015/05/05 08:52:05 espie Exp $
d136 1
a136 1
	    ->sudo($self->{sudo})
d490 1
a490 1
	$core->shell->env(PKG_PATH => $path)->sudo->exec(@@cmd, @@l);
d636 1
a636 1
		$core->shell->sudo->exec(@@cmd);
d746 1
a746 1
	$core->shell->nochroot->env(PKG_PATH => $path)->sudo
@


1.156
log
@a few more things to wrap as the correct user
@
text
@d2 1
a2 1
# $OpenBSD: Port.pm,v 1.155 2015/05/03 08:15:35 espie Exp $
d296 1
a296 1
# happened succesfully, so we can use that in serialized taks
d1049 1
d1196 1
@


1.155
log
@typo in comment
@
text
@d2 1
a2 1
# $OpenBSD: Port.pm,v 1.154 2015/05/01 15:41:52 espie Exp $
d708 1
a708 1
		    	open(my $fh2, '>>', $job->{builder}{state}{size_log});
@


1.154
log
@remove debug scaffolding. Found the bug (elsewhere, not surprisingly)
@
text
@d2 1
a2 1
# $OpenBSD: Port.pm,v 1.153 2015/04/29 10:59:03 espie Exp $
d65 1
a65 1
# just a name + behavior, and all the date is in job (which is
@


1.153
log
@display more junk info for now, trying to track down things
@
text
@d2 1
a2 1
# $OpenBSD: Port.pm,v 1.152 2015/03/14 20:45:11 espie Exp $
a1136 3
		for my $j ($core->same_host_jobs) {
			print $fh "\t$j->{path}\n";
		}
a1149 3
		for my $j ($core->same_host_jobs) {
			print $fh "\t$j->{path}\n";
		}
@


1.152
log
@use make -C
@
text
@d2 1
a2 1
# $OpenBSD: Port.pm,v 1.151 2014/11/22 12:44:37 espie Exp $
d1137 3
d1153 3
@


1.151
log
@post fake-as-root,  we don't need to clean twice. If it fails the first time,
there *is* a problem.

with new show-size, we don't need root there either.
@
text
@d2 1
a2 1
# $OpenBSD: Port.pm,v 1.150 2014/03/17 10:47:45 espie Exp $
a135 1
	    ->chdir($ports)
@


1.150
log
@don't bother re-adding already shunted depends.
@
text
@d2 1
a2 1
# $OpenBSD: Port.pm,v 1.149 2014/03/16 17:22:05 espie Exp $
d164 1
a164 1
		$core->job->replace_tasks(DPB::Task::Port::BaseClean->new(
a681 1
	$self->{sudo} = 1;
d779 1
a779 1
package DPB::Task::Port::BaseClean;
a793 3
	if ($self->requeue($core)) {
		return 1;
	}
a797 27
sub requeue
{
	my ($self, $core) = @@_;
	# didn't clean right, and no sudo yet:
	# run ourselves again (but log the problem)
	if ($core->{status} != 0 && !$self->{sudo}) {
		$self->{sudo} = 1;
		my $job = $core->job;
		$job->insert_tasks($self);
		my $fh = $job->{builder}->logger->open("clean");
		print $fh $job->{path}, "\n";
		$core->{status} = 0;
		return 1;
	}
	return 0;
}

package DPB::Task::Port::Clean;
our @@ISA = qw(DPB::Task::Port::BaseClean);

sub finalize
{
	my ($self, $core) = @@_;
	$self->requeue($core);
	$self->SUPER::finalize($core);
}

d1124 1
a1124 1
		$self->insert_tasks(DPB::Task::Port::BaseClean->new('clean'));
@


1.149
log
@obvious typo. spotted by jasper@@
@
text
@d2 1
a2 1
# $OpenBSD: Port.pm,v 1.148 2014/03/16 08:52:53 espie Exp $
d419 1
@


1.148
log
@do the depends computation before the fork and after the lock, so we're
aware of everything going on on the same host. In particular, group together
other ports waiting for lock on the same host, and run one single pkg_add.
since they are now in order, this helps quite a bit.
@
text
@d2 1
a2 1
# $OpenBSD: Port.pm,v 1.147 2014/03/15 09:51:27 espie Exp $
d630 1
a630 1
		my $opt = '-aiX';
@


1.147
log
@tweak waiting-for-lock mechanism: explicitly keep track of order,
and have each job relinquishing lock wake up the next one.

To cater for external dpbs, also try to wake up next job if we don't own the
lock.
@
text
@d2 1
a2 1
# $OpenBSD: Port.pm,v 1.146 2014/03/09 20:30:10 espie Exp $
d405 51
d460 1
a460 1
	my $dep = $job->{depends};
a464 1
	$self->handle_output($job);
d485 4
a488 1
	print join(' ', @@cmd, (sort keys %$dep)), "\n";
d490 1
a490 2
	$core->shell->env(PKG_PATH => $path)->sudo
	    ->exec(@@cmd, (sort keys %$dep));
@


1.146
log
@be slightly less eager when running junk: take into account dependencies
that ports already scheduled want.
@
text
@d2 1
a2 1
# $OpenBSD: Port.pm,v 1.145 2014/03/09 20:25:19 espie Exp $
d301 2
a302 1
	if (!$core->job->{locked}) {
d305 4
a308 2
	if (!$core->job->{locked}) {
		unshift(@@{$core->job->{tasks}}, $task);
d310 2
a311 2
		    'waiting-for-lock #'.$core->prop->{waited_for_lock}++);
	}
d340 1
d374 3
a376 1
	my $try = 1;
a378 1
		$try++;
d383 1
a383 1
			    ": $self->{phase}: $try seconds\n";
d386 3
a388 1
		sleep 1;
d396 1
d1157 20
@


1.145
log
@tidy: extra space. and make sure we have an offset in the log.
@
text
@d2 1
a2 1
# $OpenBSD: Port.pm,v 1.144 2014/03/09 20:24:18 espie Exp $
d547 6
a552 2
		next unless defined $job->{live_depends};
		for my $d (@@{$job->{live_depends}}) {
d866 7
d899 1
@


1.144
log
@micro optimization, visible on loads of cores: release swallowed cores at
end of fake, so they have time to sort themselves out (waiting-for-lock)
before package is finished.
@
text
@d2 1
a2 1
# $OpenBSD: Port.pm,v 1.143 2014/01/10 11:26:43 espie Exp $
d457 1
d524 1
a524 1
	if (defined $core->job->{builder}->locker ->find_tag($core->hostname)) {
@


1.143
log
@parse SIGNING_PARAMETERS, use it to match -DSIGNER and pass that to pkg_add
accordingly
@
text
@d2 1
a2 1
# $OpenBSD: Port.pm,v 1.142 2013/12/30 12:28:23 espie Exp $
d180 15
d794 1
@


1.142
log
@Add -Dunsigned while building, unless we are in an environment where we
sign packages by default.
@
text
@d2 1
a2 1
# $OpenBSD: Port.pm,v 1.141 2013/12/07 16:03:03 espie Exp $
d397 2
a398 2
	if ($job->{builder}{state}{allow_unsigned}) {
		push(@@cmd, '-Dunsigned');
d652 2
a653 2
	if ($job->{builder}{state}{allow_unsigned}) {
		push(@@cmd, '-Dunsigned');
@


1.141
log
@preliminary scaffolding to handle tests: create specific task types
for dependencies and for running tests.

fix PortInfo to know whether tests are required.
Amend PortBuilder to be able to launch tests.

(there are pieces missing in the engine, like a secondary queue with forced
affinity to run actual tests, and the portbuilder code is very incomplete
and needs love)
@
text
@d2 1
a2 1
# $OpenBSD: Port.pm,v 1.140 2013/11/16 16:39:28 espie Exp $
d397 3
d652 3
@


1.140
log
@make the data in permanent logs a bit more self-describing, so that we may add
new fields in the future without atrocious hacks for bw compatibility.
(grows the files a bit, but quite acceptable).
@
text
@d2 1
a2 1
# $OpenBSD: Port.pm,v 1.139 2013/11/16 13:06:00 espie Exp $
d742 19
d767 1
d783 1
a783 1
package DPB::Job::Port;
a806 22
	my $prop = $core->prop;
	if ($prop->{parallel} =~ m/^\/(\d+)$/) {
		if ($prop->{jobs} == 1) {
			$prop->{parallel} = 0;
		} else {
			$prop->{parallel} = int($prop->{jobs}/$1);
			if ($prop->{parallel} < 2) {
				$prop->{parallel} = 2;
			}
		}
	}
	if ($prop->{parallel} && $v->{info}->has_property('parallel')) {
		$job->{parallel} = $prop->{parallel};
	}

	if ($builder->checks_rebuild($v)) {
		push(@@{$job->{tasks}},
		    DPB::Task::Port::Signature->new('signature'));
	} else {
		$job->add_normal_tasks($builder->{dontclean}{$v->pkgpath},
		    $core);
	}
d841 2
a842 2
	my ($self, $core) = @@_;
	my $dep = $self->{v}{info}->solve_depends;
a879 66
sub add_normal_tasks
{
	my ($self, $dontclean, $core) = @@_;

	my @@todo;
	my $builder = $self->{builder};
	my $hostprop = $core->prop;
	my $small = 0;
	if (defined $times->{$self->{v}} && 
	    $times->{$self->{v}} < $hostprop->{small_timeout}) {
		$small = 1;
	}
	if ($builder->{clean}) {
		$self->insert_tasks(DPB::Task::Port::BaseClean->new('clean'));
	}
	$hostprop->{junk_count} //= 0;
	$hostprop->{depends_count} //= 0;
	$hostprop->{ports_count} //= 0;
	my $c = $self->need_depends($core);
	$hostprop->{ports_count}++;
	$hostprop->{depends_count} += $c;
	my $junk = DPB::Junk->want($core, $self);
	if ($junk == 2) {
		push(@@todo, 'junk');
		my $fh = $self->{builder}->logger->open("junk");
		print $fh "$$@@", CORE::time(), ": ", $core->hostname,
		    ": forced junking -> $self->{path}\n";
	}
	if ($c) {
		$hostprop->{junk_count}++;
		push(@@todo, qw(depends show-prepare-results));
	}
	# gc stuff we will no longer need
	delete $self->{v}{info}{solved};
	if ($junk == 1) {
		my $fh = $self->{builder}->logger->open("junk");
		print $fh "$$@@", CORE::time(), ": ", $core->hostname,
		    ": depends=$hostprop->{depends_count} ",
		    " ports=$hostprop->{ports_count} ",
		    " junk=$hostprop->{junk_count} -> $self->{path}\n";
		push(@@todo, 'junk');
	}
	if ($builder->{fetch}) {
		push(@@todo, qw(checksum));
	} else {
		push(@@todo, qw(fetch));
	}

	push(@@todo, qw(inbetween));
	if (!$small) {
		push(@@todo, qw(patch configure));
	}
	push(@@todo, qw(build));

	if (!$small) {
		push(@@todo, qw(fake));
	}
	push(@@todo, qw(package));
	if ($builder->want_size($self->{v}, $core)) {
		push @@todo, 'show-size';
	}
	if (!$dontclean) {
		push @@todo, 'clean';
	}
	$self->add_tasks(map {DPB::Port::TaskFactory->create($_)} @@todo);
}
d1009 137
d1147 1
a1147 1
our @@ISA = qw(DPB::Job::Port);
a1167 1

@


1.139
log
@add/read timestamps to rolling logs, so that eventually old stuff gets
removed.

alias -DSTARTUP/-DCLEANUP, since I keep mixing up the two.
@
text
@d2 1
a2 1
# $OpenBSD: Port.pm,v 1.138 2013/10/17 18:09:42 espie Exp $
d616 6
a621 2
			my $info = $job->{path}."(".$job->{v}->fullpkgname.") $sz ".CORE::time()."\n";
			print {$job->{builder}{logsize}} $info;
d627 1
a627 1
			print $fh2 $info;
@


1.138
log
@for running !chroot'd stuff, create a modifier for the shell.
Note this modifier must come first for localhost !
@
text
@d2 1
a2 1
# $OpenBSD: Port.pm,v 1.137 2013/10/13 19:57:07 espie Exp $
d616 1
a616 1
			my $info = $job->{path}."(".$job->{v}->fullpkgname.") $sz\n";
@


1.137
log
@sigh... if we force junking, we untaint.
but that's because we're tainted! so taint correctly
before we release the lock.
@
text
@d2 1
a2 1
# $OpenBSD: Port.pm,v 1.136 2013/10/12 13:52:03 espie Exp $
d657 1
a657 1
	$core->shell->env(PKG_PATH => $path)->sudo
@


1.136
log
@tweak order: if we force junk, this *must* run before depend, as
we're depending on junk to remove tagged stuff (and otherwise depend
won't run successfully).

This is different from "normal" junk, which does run after depend as
an optimization (makes little sense to remove packages we might be
reinstalling right away)
@
text
@d2 1
a2 1
# $OpenBSD: Port.pm,v 1.135 2013/10/11 11:51:04 espie Exp $
d454 7
@


1.135
log
@fix restart issues...

first tag we see will trigger a junk, unless we already
junked on that host during this run.

that way, we can forget whether we were building kde3 or kde4,
as we start with a "clean slate".

I could have junked at start, but this is much better, as it junks
"just in time" for the tag.
@
text
@d2 1
a2 1
# $OpenBSD: Port.pm,v 1.134 2013/10/10 20:52:04 espie Exp $
d30 1
a30 1
	return 1 if $job->{v}{forcejunk};
d33 1
a33 1
	return 1 if $job->{v}{info}->has_property('tag') &&
d36 5
a40 1
	return $core->prop->{depends_count} >= $core->prop->{junk};
d892 7
d905 1
a905 1
	if (DPB::Junk->want($core, $self)) {
@


1.134
log
@well, setup doesn't redirect, so print in the right location instead
of on console...
@
text
@d2 1
a2 1
# $OpenBSD: Port.pm,v 1.133 2013/10/10 15:48:16 espie Exp $
d31 4
@


1.133
log
@oops, reversed value while copying test.
do the nojunk check in setup (so that we don't untaint if we're
not gonna run), and since we're testing in setup, use that to bypass
running altogether in such a case.

sorry landry, previous one was pretty bad... the reversed test result
is a stinker...
@
text
@d2 1
a2 1
# $OpenBSD: Port.pm,v 1.132 2013/10/10 10:48:35 espie Exp $
d476 1
d481 1
a481 1
			print "Don't run junk because nojunk in ",
d493 1
a493 1
	print {$core->job->{logfh}} "Still tainted: $still_tainted\n";
@


1.132
log
@explain a bit more about serialized locking.
keep track of where we last ran junk on a host, so it's faster to backtrack
thru logfiles...
@
text
@d2 1
a2 1
# $OpenBSD: Port.pm,v 1.131 2013/10/10 07:15:49 espie Exp $
d473 11
a483 7
	if ($t2 == $task) {
		my $still_tainted = 0;
		for my $job ($core->same_host_jobs) {
			if ($job->{v}{info}->has_property('tag')) {
				$still_tainted = 1;
				last;
			}
d485 2
a486 7
	    	if (defined $core->job->{builder}->locker
		    ->find_tag($core->hostname)) {
			$still_tainted = 0;
		}
		print {$core->job->{logfh}} "Still tainted: $still_tainted\n";
		if (!$still_tainted) {
			delete $core->prop->{tainted};
d489 8
a496 1
	return $t2;
a511 4
		if ($job->{nojunk}) {
			print "Don't run junk because nojunk in $job->{path}\n";
			return 0;
		}
a553 1

@


1.131
log
@setup of serialized tasks *is* deterministic.

The moment when we're sure we're locked in uninstall
is the right moment to revisit tainted status...
not later, because if we do that in finalize, some tainted ports
may have finished building, and we may think we're untainted now.
as seen by landry@@

Note also that setup runs in the main dpb process, so not concurrently with
the engine, and so the engine can safely check for tags right after setup,
even if pkg_delete has not finished, because by the time the port can lock
and reach depends, pkg_delete must have finished.
@
text
@d2 1
a2 1
# $OpenBSD: Port.pm,v 1.130 2013/10/07 17:50:29 espie Exp $
d273 2
d384 4
d548 1
@


1.130
log
@move decision to run show-size to PortBuilder, as we really need to know
whether we have a filehandle.
@
text
@d2 1
a2 1
# $OpenBSD: Port.pm,v 1.129 2013/10/06 13:33:37 espie Exp $
d460 1
a460 1
	# check we *REALLY* mean it
d465 20
a484 1
	return $task->SUPER::setup($core);
a518 4
	# we got pre-empted
	if (!DPB::Junk->want($core)) {
		exit(2);
	}
a545 19
		my $still_tainted = 0;
		for my $job ($core->same_host_jobs) {
			if ($job->{v}{info}->has_property('tag')) {
				$still_tainted = 1;
				last;
			}
		}
	    	if (defined $core->job->{builder}->locker->find_tag($core->hostname)) {
			$still_tainted = 1;
		}
		print {$core->job->{logfh}} "Still tainted: $still_tainted\n";
		if (!$still_tainted) {
			delete $core->prop->{tainted};
		}
	}

	# unless we really need junk for tags, don't error out because of us
	if (!$core->job->{v}{forcejunk}) {
		$core->{status} = 0;
d547 1
@


1.129
log
@update my copyright to 2013
@
text
@d2 1
a2 1
# $OpenBSD: Port.pm,v 1.128 2013/10/06 12:40:44 espie Exp $
d908 1
a908 1
	if ($core->{inmem} || $builder->want_size($self->{v})) {
@


1.128
log
@create a special 'in-between' task that runs (setup only actually)
between checksum and extract: that's when we're truely committed to
building the port there.

create the affinity markers at that point, and not sooner.
since we know whether we're building in memory, we can record that.

if we're building in-memory, always ask for size, since it's very very
fast.

special treatment for tagged ports on error: mark them as "cleaned" so
the host gets untainted eventually.
@
text
@d2 1
a2 1
# $OpenBSD: Port.pm,v 1.127 2013/10/06 07:08:09 espie Exp $
d4 1
a4 1
# Copyright (c) 2010 Marc Espie <espie@@openbsd.org>
@


1.127
log
@mark we're cleaned when we enter cleanup, not when we finish,
so that dependencies can be gc'd earlier in the case we of
big ports cleanup, like libreoffice.
@
text
@d2 1
a2 1
# $OpenBSD: Port.pm,v 1.126 2013/10/04 20:28:41 espie Exp $
d160 9
d555 14
d726 2
a727 1
	'junk' => 'DPB::Task::Port::Uninstall',
d898 1
d908 1
a908 1
	if ($builder->want_size($self->{v})) {
@


1.126
log
@really need to store tags in locks, as dependencies in there will kill
me when restarting dpb...
@
text
@d2 1
a2 1
# $OpenBSD: Port.pm,v 1.125 2013/10/04 17:48:24 espie Exp $
d651 6
a662 1
	print {$core->job->{lock}} "cleaned\n";
@


1.125
log
@log whether we're still tainted...
@
text
@d2 1
a2 1
# $OpenBSD: Port.pm,v 1.124 2013/10/04 11:17:33 espie Exp $
d496 1
a496 2
	my $h = $job->{builder}->locker->find_dependencies(
	    $core->hostname);
d528 3
@


1.124
log
@refactor the junk decision code to be able to force junking
@
text
@d2 1
a2 1
# $OpenBSD: Port.pm,v 1.123 2013/10/04 07:18:38 espie Exp $
d530 1
@


1.123
log
@actually, this is a more general problem, so just skip cores where
there's no useful job for us.
@
text
@d2 1
a2 1
# $OpenBSD: Port.pm,v 1.122 2013/10/04 07:15:10 espie Exp $
d22 13
d452 1
a452 1
	if ($core->prop->{depends_count} < $core->prop->{junk}) {
d492 1
a492 1
	if ($core->prop->{depends_count} < $core->prop->{junk}) {
d535 4
a538 2
	# otherwise, hey, it's not important, never error out because of us
	$core->{status} = 0;
d852 7
a858 9
	if ($hostprop->{junk}) {
		if ($hostprop->{depends_count} >= $hostprop->{junk}) {
			my $fh = $self->{builder}->logger->open("junk");
			print $fh "$$@@", CORE::time(), ": ", $core->hostname,
			    ": depends=$hostprop->{depends_count} ",
			    " ports=$hostprop->{ports_count} ",
			    " junk=$hostprop->{junk_count} -> $self->{path}\n";
			push(@@todo, 'junk');
		}
@


1.122
log
@ouch: if junk gets called while LISTING/UPDATING DISTFILES HISTORY is
running, some jobs may not have a v yet.
@
text
@d2 1
a2 1
# $OpenBSD: Port.pm,v 1.121 2013/10/03 18:21:16 espie Exp $
d512 1
a512 2
			if (defined $job->{v} && 
			    $job->{v}{info}->has_property('tag')) {
@


1.121
log
@okay, junk is sneaky enough this warrants a few comments
@
text
@d2 1
a2 1
# $OpenBSD: Port.pm,v 1.120 2013/10/03 18:16:53 espie Exp $
d512 2
a513 1
			if ($job->{v}{info}->has_property('tag')) {
@


1.120
log
@ouch, remove "tainted" property only if junk REALLY occurred
@
text
@d2 1
a2 1
# $OpenBSD: Port.pm,v 1.119 2013/10/03 17:42:58 espie Exp $
d429 6
d438 1
a438 1
	# zap things HERE
d503 2
d522 1
@


1.119
log
@scaffolding for some cool work happening.
NO SERVICEABLE USER PARTS INSIDE! this is a dirty hack to make inroads
on a fairly complicated issue.
@
text
@d2 1
a2 1
# $OpenBSD: Port.pm,v 1.118 2013/10/03 08:02:55 espie Exp $
d501 10
a510 6
	}
	my $still_tainted = 0;
	for my $job ($core->same_host_jobs) {
		if ($job->{v}{info}->has_property('tag')) {
			$still_tainted = 1;
			last;
a511 3
	}
	if (!$still_tainted) {
		delete $core->prop->{tainted};
@


1.118
log
@maybe want less long command lines eventually, push that out to be able
to specialize on each task
@
text
@d2 1
a2 1
# $OpenBSD: Port.pm,v 1.117 2013/10/02 09:16:01 espie Exp $
d502 11
@


1.117
log
@gc dead code
@
text
@d2 1
a2 1
# $OpenBSD: Port.pm,v 1.116 2013/09/23 12:32:59 espie Exp $
d67 18
d99 2
a100 13
	my @@args = ($t, 
	    "FETCH_PACKAGES=No",
	    "PREPARE_CHECK_ONLY=Yes",
	    "REPORT_PROBLEM='exit 1'", "BULK=No");
	if ($job->{parallel}) {
		push(@@args, "MAKE_JOBS=$job->{parallel}");
	}
	if ($job->{special}) {
		push(@@args, "USE_MFS=Yes");
	}
	if ($builder->{fetch}) {
		push(@@args, "NO_CHECKSUM=Yes");
	}
@


1.116
log
@make WRAPPER_OUTPUT disappear unless we are using it
@
text
@d2 1
a2 1
# $OpenBSD: Port.pm,v 1.115 2013/09/23 12:25:17 espie Exp $
a640 16
}

package DPB::Task::Port::VerifyPackages;
our @@ISA = qw(DPB::Task::Port);
sub finalize
{
	my ($self, $core) = @@_;
	if ($core->{status} != 0) {
		return 0;
	}
}

sub run
{
	sleep 10;
	exit(0);
@


1.115
log
@trim command-line: TRUST_PACKAGES is on by default these days.
more accurate name: has_depends -> need_depends
@
text
@d2 1
a2 1
# $OpenBSD: Port.pm,v 1.114 2013/09/21 08:56:44 espie Exp $
d97 1
d102 1
d112 1
a112 1
		WRAPPER_OUTPUT => $builder->{rsslog})
@


1.114
log
@new properties: repair and nochecksum (on by default)
control aspects of pkg_delete/pkg_add runs
@
text
@d2 1
a2 1
# $OpenBSD: Port.pm,v 1.113 2013/09/18 13:26:40 espie Exp $
d81 1
a81 1
	my @@args = ($t, "TRUST_PACKAGES=Yes",
d755 1
a755 1
sub has_depends
d814 1
a814 1
	my $c = $self->has_depends($core);
@


1.113
log
@leaner messages: don't show percent on tasks where it doesn't make sense.
replace "unchanged for 28 seconds" by "frozen for 28s"

remove frozen message for "waiting-for-lock" entirely... there's already
a depend/junk task that shows this clearly, and the message tends to be
WAY too long anyways.
@
text
@d2 1
a2 1
# $OpenBSD: Port.pm,v 1.112 2013/09/08 11:10:59 espie Exp $
d358 3
d472 5
a476 1
		my @@cmd = ('/usr/sbin/pkg_delete', '-aIX', sort keys %$h);
@


1.112
log
@explain about sudo to the Core runner.
@
text
@d2 1
a2 1
# $OpenBSD: Port.pm,v 1.111 2013/07/21 16:24:32 espie Exp $
d32 2
d240 1
d308 2
d494 2
d536 2
d594 1
d941 10
a950 3
	return "" unless defined $self->{watched};
	my $diff = $self->{watched}->check_change($current);
	my $msg = $self->{watched}->change_message($diff);
@


1.111
log
@the major change from a few days ago completely broke dpb -R (reported
by fgs@@, kili@@, nigel@@)
repair it.
- introduce end_check to cope with package files updated
(not quite satisfied with the source code, but this works, and will do for
5.4).
- adjust report to build.log to conform to the new semantics: namely, if it
didn't fail, then it's okay, don't even look at possibly missing packages
because of nfs (noticed by nigel@@).
@
text
@d2 1
a2 1
# $OpenBSD: Port.pm,v 1.110 2013/07/18 05:36:55 espie Exp $
a102 4
	if ($self->{sudo}) {
		unshift(@@args, OpenBSD::Paths->sudo, "-E");
	}

d105 1
d358 2
a359 2
	$core->shell->env(PKG_PATH => $path)
	    ->exec(OpenBSD::Paths->sudo, @@cmd, (sort keys %$dep));
d466 1
a466 1
		$core->shell->exec(OpenBSD::Paths->sudo, @@cmd);
d549 2
a550 2
	$core->shell->env(PKG_PATH => $path)
	    ->exec(OpenBSD::Paths->sudo, @@cmd, $v->fullpkgname);
@


1.110
log
@change the way errors are handled, fixed version:
- pass error condition from Job/Port.pm all the way to the engine
- use that to know whether we fail, instead of the existence of packages
(but still keep track of what we're doing correctly, THAT'S the fix)
- refactor error handling into OO version
- keep track of locks/errors/packages we're waiting for thx to nfs

all of these keep the lock around, and react to the lock being removed.

use case for nfs: if there was a revision bump after dpb scanned the port,
it will never find the package. Removing the lock will allow dpb to rescan
and find the correct packages.

with this, dpb no longer waits after nfs. More importantly, it does not
report nfs hangs as E:, rather as H:... (and it can "wait" for much longer
periods, since it keeps running and only checks on new jobs).
@
text
@d2 1
a2 1
# $OpenBSD: Port.pm,v 1.109 2013/07/12 08:07:19 espie Exp $
d167 1
a167 6
		for my $w ($job->{v}->build_path_list) {
			my $f = $job->{builder}->pkgfile($w);
			if (-f $f) {
				$job->{builder}->register_package($w);
			}
		}
@


1.109
log
@note paths we cleaned in the locks, so that we're not stuck with their
depends or nonjunk properties.
@
text
@d2 1
a2 1
# $OpenBSD: Port.pm,v 1.108 2013/07/04 17:45:34 jasper Exp $
a117 50
# this code is only necessary thanks to NFS's brain-damage...
sub make_sure_we_have_packages
{
	my ($self, $core) = @@_;
	my $job = $core->job;
	my $check = 1;
	# check ALL BUILD_PACKAGES
	for my $w ($job->{v}->build_path_list) {
		if (!defined $w->{info}) {
			print {$job->{logfh}} ">>> ", $w->fullpkgpath,
			 " may be missing\n", 
			 ">>> but it has no associated info so we don't care\n";
			next;
		}
		if ($w->{info}->is_stub) {
			print {$job->{logfh}} ">>> ", $w->fullpkgpath,
			 " may be missing\n", 
			 ">>> but it can't be installed, so we don't care\n";
			next;
		}
		if (!$w->has_fullpkgname) {
			print {$job->{logfh}} ">>> ", $w->fullpkgpath,
			 " may be missing\n", 
			 ">>> but it has no fullpkgname, so we don't care\n";
			next;
		}
		my $f = $job->{builder}->pkgfile($w);
		if (-f $f) {
			$job->{builder}->register_package($w);
		} else {
			$check = 0;
			print {$job->{logfh}} ">>> Missing $f\n";
		}
	}
	return if $check;
	if (!defined $job->{waiting}) {
		$job->{waiting} = 0;
	}
	if ($core->prop->{wait_timeout}) {
		if ($job->{waiting}*10 > $core->prop->{wait_timeout}) {
			print {$job->{logfh}} ">>> giving up\n";
		} else {
			print {$job->{logfh}} ">>> waiting 10 seconds\n";
			$job->insert_tasks(
			    DPB::Task::Port::VerifyPackages->new(
				'waiting-for-nfs '.$job->{waiting}++));
		}
	}
}

d628 1
a628 3
	if (!$self->requeue($core)) {
		$self->make_sure_we_have_packages($core);
	}
a639 1
	$self->make_sure_we_have_packages($core);
@


1.108
log
@allow dpb to install packages with a non-standard localbase

ok espie@@
@
text
@d2 1
a2 1
# $OpenBSD: Port.pm,v 1.107 2013/07/01 12:35:35 espie Exp $
d183 1
a183 1
	$core->job->{failed} = 1;
a429 1
	delete $job->{failed};
d650 1
@


1.107
log
@normal ports task can accurately mark that they have failed.
(so that the builder can look at them, and stop trusting the apparition
of pkgfiles to indicate the build succeeded/failed)
@
text
@d2 1
a2 1
# $OpenBSD: Port.pm,v 1.106 2013/06/30 16:35:43 espie Exp $
d411 3
d601 3
@


1.106
log
@temporary patch: when always clean, remove the tasks we wanted to run.
(need to address the recording of errors from some tasks in a more proper
way and deal with nfs better)
@
text
@d2 1
a2 1
# $OpenBSD: Port.pm,v 1.105 2013/06/04 03:20:36 espie Exp $
d183 1
d193 1
a193 1
our @@ISA =qw(DPB::Task::Port);
d427 1
@


1.105
log
@-DSYSLOG will syslog most activity from jobs starting/ending.

THIS IS A VERY BUSY OPTION. It's intended with a syslog.conf that
will send the log messages elsewhere, to try to pinpoint hang/panic
locations in a given port build, as system crash failures tend to leave
log files in a lagging state.

idea discussed with kurt@@
@
text
@d2 1
a2 1
# $OpenBSD: Port.pm,v 1.104 2013/04/30 10:22:37 espie Exp $
d184 1
a184 1
		$core->job->insert_tasks(DPB::Task::Port::BaseClean->new(
@


1.104
log
@add ! to ports that prevent junk from happening, so that you know why it
doesn't junk.

spell out a bit more that logs and locks do NOT need to be shared.
@
text
@d2 1
a2 1
# $OpenBSD: Port.pm,v 1.103 2013/04/22 10:02:22 espie Exp $
d73 3
d175 5
d398 3
@


1.103
log
@okay, if we're missing info, assume it's not really important, as it is
in an extra package we don't really care about.
@
text
@d2 1
a2 1
# $OpenBSD: Port.pm,v 1.102 2013/04/13 16:13:34 espie Exp $
d901 6
a906 1
	return $self->{path}."(".$self->{task}{phase}.")";
@


1.102
log
@better
@
text
@d2 1
a2 1
# $OpenBSD: Port.pm,v 1.101 2013/04/13 10:04:43 espie Exp $
d123 6
d136 4
a139 5
			require Data::Dumper;
			
			say STDERR "Path ", $w->fullpkgpath, " has no fullpkgname\n";
			say STDERR "Basic path: ", Data::Dumper::Dumper($job->{v}), "\n";
			say STDERR "Extra paths: ", Data::Dumper::Dumper($w), "\n";
@


1.101
log
@display a bit more post-mortem info, show the Core<->current job info.
@
text
@d2 1
a2 1
# $OpenBSD: Port.pm,v 1.100 2013/03/03 00:42:40 espie Exp $
d749 1
a749 1
	return $self->{v};
@


1.100
log
@prevent waiting for non-existing package during multi-package builds that
have packages that can't be installed due to missing run-depends.
@
text
@d2 1
a2 1
# $OpenBSD: Port.pm,v 1.99 2013/02/07 06:46:58 espie Exp $
d129 7
d744 6
@


1.99
log
@make junk.log use the same pid@@time header as the rest
@
text
@d2 1
a2 1
# $OpenBSD: Port.pm,v 1.98 2013/02/03 21:45:52 espie Exp $
d123 6
@


1.98
log
@be a bit more verbose about what's going on for junk
specifically:
- log the paths that may run junk
- explicitly log nojunk behavior
@
text
@d2 1
a2 1
# $OpenBSD: Port.pm,v 1.97 2013/02/02 13:35:17 espie Exp $
d827 1
a827 1
			print $fh time(), ": ", $core->hostname,
@


1.97
log
@move control of the "building in mfs" part under PortsBuilder/Heuristics.
Store previous pkgname.
do show-size only sporadically if fullpkgname didn't change
@
text
@d2 1
a2 1
# $OpenBSD: Port.pm,v 1.96 2013/02/02 12:31:06 espie Exp $
d462 1
d830 1
a830 1
			    " junk=$hostprop->{junk_count} \n";
@


1.96
log
@print pkgname along with pkgpath, zap show-fake-size
@
text
@d2 1
a2 1
# $OpenBSD: Port.pm,v 1.94 2013/01/28 13:31:40 espie Exp $
d848 1
a848 1
	if ($builder->{size}) {
@


1.95
log
@switch to USE_MFS=Yes
requires -current bsd.port.mk
@
text
@d534 2
a535 22
			$core->job->{wrkdir} = $sz;
		}
	}
	close($fh);
	return 1;
}

package DPB::Task::Port::ShowFakeSize;
our @@ISA = qw(DPB::Task::Port::ShowSize);

sub finalize
{
	my ($self, $core) = @@_;
	my $fh = $self->{fh};
	if ($core->{status} == 0) {
		my $line = <$fh>;
		$line = <$fh>;
		if ($line =~ m/^\s*(\d+)\s+/) {
			my $sz = $1;
			my $job = $core->job;
			print {$job->{builder}{logsize}} 
			    $job->{path}, " $job->{wrkdir} $sz\n";
d541 1
a541 1
			print $fh2 $job->{path}, " $job->{wrkdir} $sz\n";
a671 1
	'show-fake-size' => 'DPB::Task::Port::ShowFakeSize',
a843 3
	if ($builder->{size}) {
		push @@todo, 'show-size';
	}
d849 1
a849 1
		push @@todo, 'show-fake-size';
@


1.94
log
@tweak, remove rebuild.log, as we log stuff directly into paths/ now.
do register_package in a slightly more efficient way (less -f tests)
@
text
@d2 1
a2 1
# $OpenBSD: Port.pm,v 1.93 2013/01/28 13:25:59 espie Exp $
d84 1
a84 1
		push(@@args, "WRKOBJDIR=/tmp/ports");
@


1.93
log
@fix -R for real... what check_signatures does is nice, but needs to be
partly redone in the main dpb process. Obviously, children's changes to
uptodate don't affect the main process.

thanks to fgs@@ for being the crash-test bunny.
@
text
@d2 1
a2 1
# $OpenBSD: Port.pm,v 1.92 2013/01/27 23:15:12 espie Exp $
d124 3
a126 1
		unless (-f $f) {
d131 1
a131 4
	if ($check) {
		$job->{builder}->register_packages($job->{v});
		return;
	}
d190 6
a195 1
		$job->{builder}->register_packages($job->{v});
@


1.92
log
@ditch register_built, no longer serves any purpose.

switch junk to counting depends and count depends correctly
@
text
@d2 1
a2 1
# $OpenBSD: Port.pm,v 1.91 2013/01/21 15:08:25 espie Exp $
d129 4
a132 1
	return if $check;
d175 1
d191 1
@


1.91
log
@grr
@
text
@d2 1
a2 1
# $OpenBSD: Port.pm,v 1.90 2013/01/21 14:56:29 espie Exp $
d432 1
a432 1
	if ($core->prop->{junk_count} < $core->prop->{junk}) {
d471 1
a471 1
	if ($core->prop->{junk_count} < $core->prop->{junk}) {
d493 2
a716 1
		$builder->register_built($v); 
d787 1
a787 1
	my $c = scalar(%deps2);
a819 5
#	if (defined $times->{$self->{v}} &&
#	    $times->{$self->{v}} < 4800) {
#	    	$self->{special} = 1;
#		print {$self->{logfh}} "Building in RAM\n";
#	}
d824 6
a829 1
	if ($self->has_depends($core)) {
d836 6
a841 1
		if ($hostprop->{junk_count} >= $hostprop->{junk}) {
@


1.90
log
@rollinglog must be reopened each time, comment why
(commented snippet that shows how to prime -s heuristics based on time
dangerous but useful)
@
text
@d2 1
a2 1
# $OpenBSD: Port.pm,v 1.89 2013/01/21 12:29:52 espie Exp $
a550 1
		    	last;
@


1.89
log
@PortBuilder already opens logfiles, so pass them around, instead of closing/reopening
@
text
@d2 1
a2 1
# $OpenBSD: Port.pm,v 1.88 2013/01/21 12:03:32 espie Exp $
d545 7
a551 2
			print {$job->{builder}{rollinglog}} 
			    $job->{path}, " $job->{wrkdir} $sz\n";
d820 5
@


1.88
log
@simplify wrkdir size handling, turn that into a rolling log.
@
text
@d2 1
a2 1
# $OpenBSD: Port.pm,v 1.87 2013/01/21 11:06:59 espie Exp $
d696 2
a697 1
	my ($class, $log, $v, $lock, $builder, $special, $core, $endcode) = @@_;
d700 3
a702 1
	    log => $log, v => $v,
a708 2
	open $job->{logfh}, ">>", $job->{log} or die "can't open $job->{log}";

d978 1
a978 1
	my ($class, $log, $v, $builder, $endcode) = @@_;
d981 3
a983 1
	    log => $log, v => $v,
d985 2
a986 1
	    builder => $builder},
a987 6

	open $job->{logfh}, ">>", $job->{log} or die "can't open $job->{log}";

	$job->{endcode} = sub { 
		close($job->{logfh}); 
		&$endcode; };
@


1.87
log
@change the way we junk: count ports which install depends instead of all
ports.

let has_depends return the number of depends, this may come in handy
@
text
@d2 1
a2 1
# $OpenBSD: Port.pm,v 1.86 2013/01/21 10:46:42 espie Exp $
d543 4
a546 2
			my $f2 = $job->{builder}->logger->open("size");
			print $f2 $job->{path}, " $job->{wrkdir} $sz\n";
@


1.86
log
@saner and more consistent handling of small
@
text
@d2 1
a2 1
# $OpenBSD: Port.pm,v 1.85 2013/01/21 02:06:12 espie Exp $
d779 2
a780 1
	if (!%deps2) {
a783 1
		return 0;
a785 1
		return 1;
d787 1
d815 1
d817 1
d820 1
d823 1
a823 1
		if ($hostprop->{junk_count}++ >= $hostprop->{junk}) {
@


1.85
log
@tweak log, awaiting-locks is a better name, and put in timestamps
@
text
@d2 1
a2 1
# $OpenBSD: Port.pm,v 1.84 2013/01/21 02:01:08 espie Exp $
d809 1
a809 1
	    $times->{$self->{v}} < ($hostprop->{small} // 120)) {
@


1.84
log
@move the dependency solver to PortInfo, so it can be reused if necessary
@
text
@d2 1
a2 1
# $OpenBSD: Port.pm,v 1.83 2013/01/18 21:11:55 espie Exp $
d337 2
a338 1
			print {$job->{builder}{lockperf}} $core->hostname, 
@


1.83
log
@kill checksum-and-list

optimize away some depend stages: since the main dpb process maintains
a synchronous list of live_depends, and only releases host locks synchronously,
it can check depends lists against already known live_depends (and avoid
some depend stages entirely).

naddy@@ says it gains 40 mn on his box...
@
text
@d2 1
a2 1
# $OpenBSD: Port.pm,v 1.82 2013/01/16 10:38:56 espie Exp $
d761 1
a761 30
	my $dep = {};
	my $v = $self->{v};
	if (exists $v->{info}{BDEPENDS}) {
		for my $d (values %{$v->{info}{BDEPENDS}}) {
			$dep->{$d->fullpkgname} = 1;
		}
	}
	#XXX ?
	if (exists $v->{info}{DEPENDS}) {
		for my $d (values %{$v->{info}{DEPENDS}}) {
			$dep->{$d->fullpkgname} = 1;
		}
	}
	# recurse for extra stuff
	if (exists $v->{info}{BEXTRA}) {
		for my $two (values %{$v->{info}{BEXTRA}}) {
			$two->quick_dump($self->{logfh});
			if (exists $two->{info}{BDEPENDS}) {
				for my $d (values %{$two->{info}{BDEPENDS}}) {
					$dep->{$d->fullpkgname} = 1;
				}
			}
			# XXX
			if (exists $two->{info}{DEPENDS}) {
				for my $d (values %{$two->{info}{DEPENDS}}) {
					$dep->{$d->fullpkgname} = 1;
				}
			}
		}
	}
d817 1
@


1.82
log
@log the time spent waiting for locks.

remove most of the "list distfiles" ad-hoc code, this stuff belongs in
bsd.port.mk.
@
text
@d2 1
a2 1
# $OpenBSD: Port.pm,v 1.81 2013/01/13 14:04:00 espie Exp $
d183 2
a184 1
		$job->add_normal_tasks($builder->{dontclean}{$v->pkgpath});
a254 28
package DPB::Task::Port::ChecksumAndList;
our @@ISA =qw(DPB::Task::Port::Checksum);
sub need_checksum
{
	my ($self, $log, $info) = @@_;
	my $need = $self->SUPER::need_checksum($log, $info);
	if (!$need) {
		for my $dist (values %{$info->{DIST}}) {
			if (!-f $dist->listname) {
				$need = 1;
				$self->{need_list} = 1;
			}
		}
	}
	return $need;
}

sub run
{
	my ($self, $core) = @@_;
	my $job = $core->job;
	my $exit = $self->SUPER::checksum($core);
	if ($exit || !$self->{need_list}) {
		exit($exit);
	}
	$self->{phase} = 'list-distfiles';
	$self->DPB::Task::Port::run($core);
}
a413 5
		if ($v->{info}->has_property('nojunk')) {
			print {$job->{lock}} "nojunk\n";
			$job->{nojunk} = 1;
		}
		print {$job->{lock}} "needed=", join(' ', sort @@r), "\n";
d415 1
a415 1
		$job->{live_depends} = \@@r;
a668 1
	'checksum-and-list' => 'DPB::Task::Port::ChecksumAndList',
d693 1
a693 1
	my ($class, $log, $v, $builder, $special, $core, $endcode) = @@_;
d697 1
d730 1
a730 1
		    $prop);
d747 11
d760 1
a760 1
	my $self = shift;
d792 24
a815 2
	$self->{depends} = $dep;
	return 1;
d830 1
a830 1
	my ($self, $dontclean, $hostprop) = @@_;
d834 1
d843 1
a843 1
	if ($self->has_depends) {
@


1.81
log
@ChecksumAndList: unused yet. make it possible to save archive-file-lists
for later perusal (e.g., locatedb for distfiles)
@
text
@d2 1
a2 1
# $OpenBSD: Port.pm,v 1.80 2013/01/12 14:44:41 espie Exp $
d264 1
a270 35
my $gtar = DPB::PkgPath->new('archivers/gtar');

sub list
{
	my ($self, $dist, $info) = @@_;
	my $name = $dist->filename;
	my $output = $dist->listname;
	my ($cmd, $tar);
	if ($info->{DEPENDS}{$gtar} || $info->{BDEPENDS}{$gtar}) {
		$tar = 'gtar';

	} else {
		$tar = 'tar';
	}
	if ($name =~ m/\.tar\.xz$/) {
		$cmd = "xzcat $name|$tar tf -";
	} elsif ($name =~ m/\.(tar\.bz2|tbz2|tbz)$/) {
		$cmd = "bzip2 -dc $name|$tar tf -";
	} elsif ($name =~ m/\.tar$/) {
		$cmd = "$tar tf $name";
	} elsif ($name =~ m/\.(tar\.gz|tgz)$/) {
		$cmd = "gzip -dc $name|$tar tf -";
	} elsif ($name =~ m/\.rar$/) {
		$cmd = "unrar vb $name";
	} elsif ($name =~ m/.zip$/) {
		$cmd = "zipinfo -1 $name";
	}
	if (defined $cmd) {
		$cmd .= "|gzip >$output";
		File::Path::mkpath(File::Basename::dirname($output));
		print "Running $cmd\n";
		system($cmd);
	}
}

d276 2
a277 4
	for my $dist (values %{$job->{v}{info}{DIST}}) {
		if (!-f $dist->listname) {
			$self->list($dist, $job->{v}{info});
		}
d279 2
a280 1
	exit($exit);
a282 1

d358 1
d361 2
d364 2
a367 1
		$self->try_lock($core);
d392 1
a392 1
	if ($job->{builder}->{update}) {
d395 1
a395 1
	if ($job->{builder}->{forceupdate}) {
d399 1
a399 1
	my $path = $job->{builder}->{fullrepo}.'/';
d701 1
a837 1

@


1.80
log
@work-around for special need users
@
text
@d2 1
a2 1
# $OpenBSD: Port.pm,v 1.79 2013/01/12 13:51:43 espie Exp $
d192 1
d223 1
a223 1
sub run
d236 7
a242 1
	exit($exit);
d253 65
@


1.79
log
@fix problem noticed by nigel@@
@
text
@d2 1
a2 1
# $OpenBSD: Port.pm,v 1.78 2013/01/11 21:16:08 espie Exp $
d397 2
@


1.78
log
@inheritance works better when you don't forget to call superclass
@
text
@d2 1
a2 1
# $OpenBSD: Port.pm,v 1.77 2013/01/11 20:11:54 espie Exp $
d194 1
a194 1
	my ($self, $info) = @@_;
d197 1
a197 1
		if (!$dist->cached_checksum($self->{logfh}, $dist->filename)) {
d214 1
a214 1
	if ($task->need_checksum($info)) {
@


1.77
log
@belt and suspenders... don't know why, but sometimes, the stuff is not
where I think it should be
@
text
@d2 1
a2 1
# $OpenBSD: Port.pm,v 1.76 2013/01/11 17:39:03 espie Exp $
d425 1
a425 1
	return $task;
d436 1
@


1.76
log
@show how many locks we waited for, that's easy to do and always fun
@
text
@d2 1
a2 1
# $OpenBSD: Port.pm,v 1.75 2013/01/11 17:35:43 espie Exp $
d742 6
@


1.75
log
@... and tweak to waiting-for-nfs so that things are clearer
@
text
@d2 1
a2 1
# $OpenBSD: Port.pm,v 1.74 2013/01/11 17:23:51 espie Exp $
d260 2
a261 1
		return DPB::Task::Port::Lock->new('waiting-for-lock');
@


1.74
log
@explicitly wait for junk_lock... doesn't happen that often, a lot
of try_lock will succeed, so the extra processes are cheap
@
text
@d2 1
a2 1
# $OpenBSD: Port.pm,v 1.73 2013/01/11 16:59:07 espie Exp $
d140 1
a140 1
				'waiting-'.$job->{waiting}++));
@


1.73
log
@oopsie, broke junk
@
text
@d2 1
a2 1
# $OpenBSD: Port.pm,v 1.72 2013/01/11 16:35:47 espie Exp $
d41 3
d47 1
a47 1
	bless {phase => $phase, name => $phase}, $class;
d259 2
a260 1
		$task->{name} .= "!";
a280 16
# XXX can't move "full" junk_lock on the other side of the fork, because
# it may have to wait.
sub junk_lock
{
	my ($self, $core) = @@_;
	my $job = $core->job;

	while (1) {
		if ($job->{locked}) {
			last;
		}
		$self->try_lock($core);
		sleep 1;
	}
}

d306 32
a349 1
	$self->junk_lock($core);
a456 1
	$self->junk_lock($core);
d845 1
a845 1
	return $self->{path}."(".$self->{task}{name}.")";
@


1.72
log
@task->name  misused, go grab directly phase/name so that it works like
I want it to
@
text
@d2 1
a2 1
# $OpenBSD: Port.pm,v 1.71 2013/01/11 16:24:26 espie Exp $
d405 1
@


1.71
log
@logic goof
@
text
@d2 1
a2 1
# $OpenBSD: Port.pm,v 1.70 2013/01/11 16:11:21 espie Exp $
a46 6
sub name
{
	my $self = shift;
	return $self->{name};
}

d826 1
a826 1
	return $self->{path}."(".$self->{task}{phase}.")";
d860 1
a860 1
	return join('/', "max_stuck=".$self->{watched}{max}, map {sprintf("%s=%.2f", $_->name, $_->elapsed)} @@{$self->{done}});
@


1.70
log
@ouch
@
text
@d2 1
a2 1
# $OpenBSD: Port.pm,v 1.69 2013/01/11 15:48:51 espie Exp $
d318 1
a318 1
	if ($core->{status} != 0 || !(defined $task && $task->is_serialized)) {
@


1.69
log
@run handle_job earlier, so we can see which junk_locks occurred in setup.
@
text
@d2 1
a2 1
# $OpenBSD: Port.pm,v 1.68 2013/01/11 15:35:53 espie Exp $
d221 1
a221 1
		return $job->next_task;
d409 1
a409 1
		return $core->job->next_task;
d714 1
a714 1
	if ($task) {
@


1.68
log
@revamp tasks a bit more: have Job::Port let each task do its own setup.
as a result, try locking directly before the fork, so we can distinguish
tasks that did enter the lock directly from those that have to wait.

(stuff like depend! means it has to wait/had to wait).

Also, allows tasks to just "vanish" after setup: used for checksum (the
whole code is now in there), and for junk (if several ports try to junk
simultaneously).

keep better track of the junk lock thru a job, so that it's released when
we get out of a serialized sequence of tasks (thus, no longer
release/reobtain at end of show-prepare-results/junk).

checksum prints its own distsize now, something that was awkward before.
@
text
@d2 1
a2 1
# $OpenBSD: Port.pm,v 1.67 2013/01/10 21:41:55 espie Exp $
d335 1
a336 1
	$self->handle_output($job);
d442 1
a447 1
	$self->handle_output($job);
@


1.67
log
@get rid of show-prepare-results temp file, add glue to synchronize to
normal log.
@
text
@d2 1
a2 1
# $OpenBSD: Port.pm,v 1.66 2013/01/10 12:27:21 espie Exp $
d26 7
d44 1
a44 1
	bless {phase => $phase}, $class;
d50 1
a50 1
	return $self->{phase};
a78 3
	if ($t eq 'patch' && defined $job->{v}{info}{distsize}) {
		print "distfiles size=$job->{v}{info}{distsize}\n";
	}
d195 30
d253 31
a283 1
# XXX can't move junk_lock on the other side of the fork, because
a284 1

a288 1
	my $locker = $job->{builder}->locker;
d291 2
a292 6
		my $fh = $locker->lock($core);
		if ($fh) {
			print $fh "path=".$job->{path}, "\n";
			print {$job->{logfh}} "(Junk lock obtained for ",
			    $core->hostname, " at ", time(), ")\n";
			return;
d294 1
d303 6
a308 3
	$core->job->{builder}->locker->unlock($core);
	print {$core->job->{logfh}} "(Junk lock released for ", 
	    $core->hostname, " at ", time(), ")\n";
d314 5
a318 1
	if ($core->{status} != 0) {
a394 1
	$self->junk_unlock($core);
d403 10
a468 1
	$self->junk_unlock($core);
d709 12
a752 14
sub need_checksum
{
	my $self = shift;
	my $need = 0;
	for my $dist (values %{$self->{v}{info}{DIST}}) {
		if (!$dist->cached_checksum($self->{logfh}, $dist->filename)) {
			$need = 1;
		} else {
			unlink($dist->tempfilename);
		}
	}
	return $need;
}

d787 1
a787 3
		if ($self->need_checksum) {
			push(@@todo, qw(checksum));
		}
d791 1
@


1.66
log
@don't go thru patch/configure/build for very small ports.
@
text
@d2 1
a2 1
# $OpenBSD: Port.pm,v 1.65 2013/01/10 12:05:55 espie Exp $
d289 4
a299 14
sub result_filename
{
	my ($self, $job) = @@_;
	return $job->{builder}->logger->log_pkgpath($job->{v}).".tmp";
}

sub handle_output
{
	my ($self, $job) = @@_;
	print {$job->{logfh}} ">>> Running $self->{phase} in $job->{path} at ", 
	    time(), "\n";
	$self->redirect($self->result_filename($job));
}

d306 3
a308 2
	my $file = $self->result_filename($job);
	if (open my $fh, '<', $file) {
d311 3
a313 1
			print {$job->{logfh}} $_;
a324 1
		unlink($file);
@


1.65
log
@keep a trace of "small" ports: we won't log every detail concerning
these
@
text
@d2 1
a2 1
# $OpenBSD: Port.pm,v 1.60 2013/01/07 10:59:41 espie Exp $
d706 4
a709 3
#	if (defined $times->{$self->{v}} && $times->{$self->{v}} < 120) {
#		$small = 1;
#	}
@


1.64
log
@say goodbye to prepare/show-prepare-results,
there's no need for a separate step: show-prepare-results should be
practically instantaneous, and if there's noise, prepare will exit(1)
anyways.
just need to explicitly log the output of prepare.
@
text
@d2 1
a2 1
# $OpenBSD: Port.pm,v 1.63 2013/01/10 12:00:38 espie Exp $
d689 10
d705 5
d728 5
a732 1
	push(@@todo, qw(patch configure build));
d736 4
a739 1
	push(@@todo, qw(fake package));
a804 8
my $logsize = {};

sub add_build_info
{
	my ($class, $pkgpath, $host, $time, $sz) = @@_;
	$logsize->{$pkgpath} = $sz;
}

d812 1
@


1.63
log
@there's no need to fork a process if the checksums are all cached
@
text
@d2 1
a2 1
# $OpenBSD: Port.pm,v 1.62 2013/01/10 11:56:53 espie Exp $
a292 3
package DPB::Task::Port::Prepare;
our @@ISA = qw(DPB::Task::Port::Serialized);

d320 1
a578 1
	prepare => 'DPB::Task::Port::Prepare',
d699 1
a699 1
		push(@@todo, qw(depends prepare show-prepare-results));
@


1.62
log
@use new functions to simplify
@
text
@d2 1
a2 1
# $OpenBSD: Port.pm,v 1.61 2013/01/10 10:35:36 espie Exp $
d678 14
d710 3
a712 1
		push(@@todo, qw(checksum));
@


1.61
log
@deleting DIST from child is pointless, do a proper finalize
@
text
@d2 1
a2 1
# $OpenBSD: Port.pm,v 1.60 2013/01/07 10:59:41 espie Exp $
d328 1
a328 2
		if (defined $v->{info}{DPB_PROPERTIES} && 
		    defined $v->{info}{DPB_PROPERTIES}{nojunk}) {
d358 7
a364 5
	my ($self, $h, $host) = @@_;
	for my $core (values %{DPB::Core->repository}) {
		next if $core->hostname ne $host;
		next unless defined $core->job->{live_depends};
		for my $d (@@{$core->job->{live_depends}}) {
a366 3
		if ($core->job->{nojunk}) {
			return 0;
		}
d386 1
a386 1
	if (defined $h && $self->add_live_depends($h, $core->hostname)) {
d632 1
a632 1
	if ($prop->{parallel} && $v->{info}{DPB_PROPERTIES}{parallel}) {
a657 1
		open my $log, '>>', $self->{log};
d659 1
a659 1
			$two->quick_dump($log);
@


1.60
log
@pass -X paths thru:
- the grabber passes them to PortBuilder
... which builds a hash of pkgnames
... and the port uninstall job excludes these from the list of ports to
junk.

Note this only works with -current pkg_delete, as I had to tell it to
ignore non-existent pkgnames in that context
@
text
@d2 1
a2 1
# $OpenBSD: Port.pm,v 1.59 2013/01/05 23:38:08 espie Exp $
d204 9
a212 2
	if (!$exit) {
		delete $job->{v}{info}{DIST};
a213 1
	exit($exit);
@


1.59
log
@perl's gc doesn't play well with filehandles.
So explicitly close what it will have problems tracking...

problem noticed by sthen@@, obviously linked to my previous change to
avoid opening the same log file again and again...
@
text
@d2 1
a2 1
# $OpenBSD: Port.pm,v 1.58 2013/01/05 20:08:39 espie Exp $
d343 8
d383 1
@


1.58
log
@even if we've got pre-empted, we still have to lock.
otherwise, we're going to unlock something we don't own, which might
be a race.
@
text
@d2 1
a2 1
# $OpenBSD: Port.pm,v 1.57 2013/01/05 20:06:29 espie Exp $
a592 1
	my $e = sub { $builder->register_built($v); &$endcode; };
d598 1
a598 1
	    builder => $builder, endcode => $e},
d603 5
d830 1
a830 1
	my ($class, $log, $v, $builder, $e) = @@_;
d835 1
a835 1
	    builder => $builder, endcode => $e},
d839 4
@


1.57
log
@store information about live dependencies in dpb proper, to avoid
synchronization issues with external fs...

the external locks are still used to synchronize with other dpbs running
@
text
@d2 1
a2 1
# $OpenBSD: Port.pm,v 1.56 2013/01/05 18:09:30 espie Exp $
d365 1
a369 1
	$self->junk_lock($core);
@


1.56
log
@and put serialize next to the code it protects
(again, no actual code change)
@
text
@d2 1
a2 1
# $OpenBSD: Port.pm,v 1.55 2013/01/05 18:08:06 espie Exp $
d325 1
d330 1
d343 16
d372 1
a372 1
	my $h = $core->job->{builder}->locker->find_dependencies(
d374 1
a374 1
	if (defined $h) {
@


1.55
log
@move install out of the way (no code change)
@
text
@d2 1
a2 1
# $OpenBSD: Port.pm,v 1.54 2013/01/05 17:29:14 espie Exp $
a161 42
package DPB::Task::Port::Serialized;
our @@ISA = qw(DPB::Task::Port);

# XXX can't move junk_lock on the other side of the fork, because
# it may have to wait.

sub junk_lock
{
	my ($self, $core) = @@_;
	my $job = $core->job;
	my $locker = $job->{builder}->locker;

	while (1) {
		my $fh = $locker->lock($core);
		if ($fh) {
			print $fh "path=".$job->{path}, "\n";
			print {$job->{logfh}} "(Junk lock obtained for ",
			    $core->hostname, " at ", time(), ")\n";
			return;
		}
		sleep 1;
	}
}

sub junk_unlock
{
	my ($self, $core) = @@_;

	$core->job->{builder}->locker->unlock($core);
	print {$core->job->{logfh}} "(Junk lock released for ", 
	    $core->hostname, " at ", time(), ")\n";
}

sub finalize
{
	my ($self, $core) = @@_;
	if ($core->{status} != 0) {
		$self->junk_unlock($core);
	}
	$self->SUPER::finalize($core);
}

d208 42
@


1.54
log
@log junk lock handling
@
text
@d2 1
a2 1
# $OpenBSD: Port.pm,v 1.53 2013/01/05 17:22:05 espie Exp $
a286 35
package DPB::Task::Port::Install;
our @@ISA=qw(DPB::Task::Port);

sub notime { 1 }

sub run
{
	my ($self, $core) = @@_;
	my $job = $core->job;
	my $v = $job->{v};

	$self->handle_output($job);
	my @@cmd = ('/usr/sbin/pkg_add', '-I');
	if ($job->{builder}->{update}) {
		push(@@cmd, "-rqU", "-Dupdate", "-Dupdatedepends");
	}
	if ($job->{builder}->{forceupdate}) {
		push(@@cmd,  "-Dinstalled");
	}
	print join(' ', @@cmd, $v->fullpkgname, "\n");
	my $path = $job->{builder}->{fullrepo}.'/';
	$ENV{PKG_PATH} = $path;
	$core->shell->env(PKG_PATH => $path)
	    ->exec(OpenBSD::Paths->sudo, @@cmd, $v->fullpkgname);
	exit(1);
}

sub finalize
{
	my ($self, $core) = @@_;
	$core->{status} = 0;
	$self->SUPER::finalize($core);
	return 1;
}

d427 35
@


1.53
log
@avoid opening filehandle again and again.
also, close STDERR after the STDOUT stuff was done, so that we get
error messages otherwise!
@
text
@d2 1
a2 1
# $OpenBSD: Port.pm,v 1.52 2013/01/05 16:57:31 espie Exp $
d178 2
d191 2
d262 1
a263 1

d386 1
a388 1
	$self->junk_lock($core);
@


1.52
log
@move the "running prepare" message up to handle_output, so that *every*
phase gets tagged.
@
text
@d2 1
a2 1
# $OpenBSD: Port.pm,v 1.51 2013/01/03 15:45:18 espie Exp $
d57 1
a57 1
	$self->redirect($job->{log});
a118 1
	open my $log, '>>', $job->{log};
d125 1
a125 1
			print $log ">>> Missing $f\n";
d134 1
a134 1
			print $log ">>> giving up\n";
d136 1
a136 1
			print $log ">>> waiting 10 seconds\n";
d333 1
a333 2
	open my $log, '>>', $job->{log};
	print $log ">>> Running $self->{phase} in $job->{path} at ", 
d580 2
d811 2
@


1.51
log
@add support for unjunk property, that will prevent junking from actually
happening while some 'unjunk' ports are building.

this is a work-around for a known problem with cmake and qt4 include
dependency handlers...

Also, cache fullpkgpath while building a job, as this contributes for
a large part to the speed (not) of the display when building lots of
ports.
@
text
@d2 1
a2 1
# $OpenBSD: Port.pm,v 1.50 2012/12/30 11:47:24 espie Exp $
d58 1
a71 1
	my $ts = time();
a74 1
	print ">>> Running $t in $fullpkgpath at $ts\n";
d334 3
@


1.50
log
@why not ? track total distsize for each port. might correlate with other
stuff later.
@
text
@d2 1
a2 1
# $OpenBSD: Port.pm,v 1.49 2012/12/28 06:31:03 espie Exp $
d67 1
a67 1
	my $fullpkgpath = $job->{v}->fullpkgpath;
d167 3
d179 1
a179 1
			print $fh "path=".$job->{v}->fullpkgpath, "\n";
d353 4
d378 4
d385 1
a385 1
	my @@d = $core->job->{builder}->locker->find_dependencies(
d387 8
a394 4
	my @@cmd = ('/usr/sbin/pkg_delete', '-aIX', @@d);
	print join(' ', @@cmd, "\n");
	$core->shell->exec(OpenBSD::Paths->sudo, @@cmd);
	exit(1);
d400 3
d454 1
a454 1
			print $f2 $job->{v}->fullpkgpath, " $job->{wrkdir} $sz\n";
d505 1
a505 1
		print $fh $job->{v}->fullpkgpath, "\n";
d575 1
a651 1
			$hostprop->{junk_count} = 0;
d693 1
a693 1
	return $self->{v}->fullpkgpath."(".$self->{task}->name.")";
d806 1
@


1.49
log
@since we have a quick path where stuff move from tobuild to install without
adjusting things, stuff that can be built may have BEXTRA which are not
completed...
@
text
@d2 1
a2 1
# $OpenBSD: Port.pm,v 1.48 2012/12/27 12:20:36 espie Exp $
d72 3
@


1.48
log
@oops
@
text
@d2 1
a2 1
# $OpenBSD: Port.pm,v 1.47 2012/12/27 12:03:33 espie Exp $
d595 1
d597 1
d600 6
@


1.47
log
@add timestamp in phases for Job/Port.pm.
may help synchronize events from distinct logs in case this matters.
@
text
@d2 1
a2 1
# $OpenBSD: Port.pm,v 1.46 2012/12/25 10:43:36 espie Exp $
d71 2
a72 2
	my $t = time();
	print ">>> Running $t in $fullpkgpath at $t\n";
@


1.46
log
@make "rebuild" behavior a proper subclass of DPB::PortBuilder, instead
of having tests all over the place.

Take advantage of that to not rechecking signatures if already done.
@
text
@d2 1
a2 1
# $OpenBSD: Port.pm,v 1.45 2012/12/25 10:25:04 espie Exp $
d71 2
a72 1
	print ">>> Running $t in $fullpkgpath\n";
@


1.45
log
@compute dependencies right away in the job: we don't actually have to
fork depends/prepare/prepare-results for ports which don't have any
depends.

This also prevents some lock contention, obviously.
@
text
@d2 1
a2 1
# $OpenBSD: Port.pm,v 1.44 2012/12/24 17:19:01 espie Exp $
d549 1
a549 6
	my $e;
	if ($builder->{rebuild}) {
		$e = sub { $builder->register_built($v); &$endcode; };
	} else {
		$e = $endcode;
	}
d572 1
a572 1
	if ($builder->{rebuild}) {
@


1.44
log
@reorg the tests slightly, no functional change
@
text
@d2 1
a2 1
# $OpenBSD: Port.pm,v 1.43 2012/11/18 01:59:31 espie Exp $
d252 1
a252 18
	my $dep = {};
	my $v = $job->{v};
	if (exists $v->{info}{BDEPENDS}) {
		for my $d (values %{$v->{info}{BDEPENDS}}) {
			$dep->{$d->fullpkgname} = 1;
		}
	}
	# recurse for extra stuff
	if (exists $v->{info}{BEXTRA}) {
		for my $two (values %{$v->{info}{BEXTRA}}) {
			if (exists $two->{info}{BDEPENDS}) {
				for my $d (values %{$two->{info}{BDEPENDS}}) {
					$dep->{$d->fullpkgname} = 1;
				}
			}
		}
	}

a254 1
	exit(0) unless %$dep;
d587 25
d621 3
a623 1
	push(@@todo, qw(depends prepare show-prepare-results));
@


1.43
log
@fix clean + check for packages interaction
@
text
@d2 1
a2 1
# $OpenBSD: Port.pm,v 1.42 2012/11/09 17:49:17 espie Exp $
d126 5
a130 2
	if (!$check && $core->prop->{wait_timeout}) {
		$job->{waiting} //= 0;
@


1.42
log
@multiplication doesn't work on undefined values... noticed by naddy@@
so initialize $job->{waiting} if needed.
@
text
@d2 1
a2 1
# $OpenBSD: Port.pm,v 1.41 2012/10/13 09:06:56 espie Exp $
d150 1
a150 1
		$core->job->insert_tasks(DPB::Task::Port::CleanOnError->new(
d473 1
a473 1
package DPB::Task::Port::Clean;
d481 2
a482 2
	if (!$self->requeue($core)) {
		$self->make_sure_we_have_packages($core);
d485 1
d505 2
a506 2
package DPB::Task::Port::CleanOnError;
our @@ISA = qw(DPB::Task::Port::Clean);
d511 2
a512 2
	if ($self->requeue($core)) {
		return 1;
a514 1
	return 0;
d609 1
a609 1
		push @@todo, "clean";
@


1.41
log
@disable the waiting period if waiting_timeout is 0.
and don't do it on localhost
@
text
@d2 1
a2 1
# $OpenBSD: Port.pm,v 1.40 2012/10/13 08:32:58 espie Exp $
d127 1
@


1.40
log
@tweaks
- waiting should know when it gets interrupted! so that it doesn't zombify
- add a time limit.
@
text
@d2 1
a2 1
# $OpenBSD: Port.pm,v 1.39 2012/10/12 20:24:56 espie Exp $
d126 8
a133 10
	if (!$check) {
		if ($core->prop->{wait_timeout}) {
			if ($job->{waiting}*10 > $core->prop->{wait_timeout}) {
				print $log ">>> giving up\n";
			} else {
				print $log ">>> waiting 10 seconds\n";
				$job->insert_tasks(
				    DPB::Task::Port::VerifyPackages->new(
					'waiting-'.$job->{waiting}++));
			}
@


1.39
log
@-DALWAYS_CLEAN: clean ports even if they errored out (that's a prop, so
always_clean=1  in hosts file.

refactor task code a bit. And fix a buglet related to the NFS check
(wrong finalize order)
@
text
@d2 1
a2 1
# $OpenBSD: Port.pm,v 1.38 2012/10/11 09:03:34 espie Exp $
d114 2
a115 1
	my ($self, $job) = @@_;
d127 10
a136 3
		print $log ">>> waiting 10 seconds\n";
		$job->insert_tasks(DPB::Task::Port::VerifyPackages->new(
		    'waiting'.$job->{waiting}++));
d483 1
a483 1
		$self->make_sure_we_have_packages($core->job);
d523 4
a526 1
	$self->make_sure_we_have_packages($core->job);
@


1.38
log
@oh, and explain the why...
@
text
@d2 1
a2 1
# $OpenBSD: Port.pm,v 1.37 2012/10/11 08:38:05 espie Exp $
d22 2
a23 1
package DPB::Task::Port;
d26 8
a33 1
our @@ISA = qw(DPB::Task::Clocked);
a53 8
sub finalize
{
	my ($self, $core) = @@_;
	$self->SUPER::finalize($core);
	$core->job->finished_task($self);
	return $core->{status} == 0;
}

d127 1
a127 1
		$job->add_tasks(DPB::Task::Port::VerifyPackages->new(
d132 18
d467 1
a467 1
our @@ISA = qw(DPB::Task::Port);
d474 9
d488 1
a488 1
		unshift(@@{$job->{tasks}}, $self);
d494 12
d507 1
a507 2
	$self->make_sure_we_have_packages($core->job);
#	$core->job->add_tasks(DPB::Task::Port::VerifyPackages->new('waiting'));
@


1.37
log
@actually log what's missing that we're waiting upon
@
text
@d2 1
a2 1
# $OpenBSD: Port.pm,v 1.36 2012/10/11 07:38:39 espie Exp $
d111 1
@


1.36
log
@move to using BUILD_PACKAGES, so we have the actual tidy list.

Stupid NFS work-around:
during/after cleanup, wait until the packages show up.
Each wait period of ten seconds will show up as waiting#n.
@
text
@d2 1
a2 1
# $OpenBSD: Port.pm,v 1.35 2012/10/08 12:41:03 espie Exp $
d114 2
a115 1
	my $check = -f $job->{builder}->pkgfile($job->{v});
d118 5
a122 1
		$check &&= -f $job->{builder}->pkgfile($w);
d125 1
@


1.35
log
@small change for people running multiple hosts:

options on the command line now define *defaults* that host files can
override (for instance -j, stuck, -p, -J).

Add -p /n to mean "take number of jobs, if >1, divide by n, round up to 2,
and use that for parallel.

Document -p.

Make junk be 'by host' (and it's a prop, so you can tweak it).

concurrent log that records how many jobs are running each time it changes.
tag parallel builds *n in the time record.
@
text
@d2 1
a2 1
# $OpenBSD: Port.pm,v 1.34 2012/09/23 18:13:32 espie Exp $
d111 14
d461 2
d466 12
a490 1
	'final-check' => "DPB::Task::Port::VerifyPackages",
a578 1
#	push @@todo, 'final-check';
d662 1
a662 1
	for my $w ($logger->pathlist($v)) {
@


1.34
log
@new framework to deal with the new ports cluster, to be documented
@
text
@d2 1
a2 1
# $OpenBSD: Port.pm,v 1.33 2012/07/18 10:31:18 espie Exp $
d481 1
a481 1
	my ($class, $log, $v, $builder, $special, $parallel, $endcode) = @@_;
d495 13
a507 2
	if ($parallel && $v->{info}{DPB_PROPERTIES}{parallel}) {
		$job->{parallel} = $parallel;
d514 2
a515 1
		$job->add_normal_tasks($builder->{dontclean}{$v->pkgpath});
d522 1
a522 1
	my ($self, $dontclean) = @@_;
d530 3
a532 3
	if ($builder->{junk}) {
		if ($builder->{junk_count}++ >= $builder->{junk}) {
			$builder->{junk_count} = 0;
@


1.33
log
@delete DIST once we know
@
text
@d2 1
a2 1
# $OpenBSD: Port.pm,v 1.32 2012/07/06 12:01:29 espie Exp $
d76 3
d449 2
d463 1
d481 1
a481 1
	my ($class, $log, $v, $builder, $special, $endcode) = @@_;
d495 4
d540 1
d590 1
@


1.32
log
@prepare for new pkg_add -i/-I: we want to make sure that's NOT interactive!
@
text
@d2 1
a2 1
# $OpenBSD: Port.pm,v 1.31 2012/07/04 08:59:10 espie Exp $
d184 3
@


1.31
log
@remove distinction between local and distant running, always create
a shell object that can chdir, setenv, and exec commands.
(note that this executes stuff after fork, so permanent changes are cheap
and okay)

Also create it from "host" objects, which simplifies parameter passing.
@
text
@d2 1
a2 1
# $OpenBSD: Port.pm,v 1.30 2012/04/21 21:09:07 espie Exp $
d219 1
a219 1
	my @@cmd = ('/usr/sbin/pkg_add', '-a');
d253 1
a253 1
	my @@cmd = ('/usr/sbin/pkg_add');
d335 1
a335 1
	my @@cmd = ('/usr/sbin/pkg_delete', '-aX', @@d);
@


1.30
log
@make sure stuff gets thru ssh correctly
@
text
@d2 1
a2 1
# $OpenBSD: Port.pm,v 1.29 2012/04/21 14:41:37 espie Exp $
a67 2
	my $sudo = OpenBSD::Paths->sudo;
	my $shell = $core->{shell};
d92 3
a94 21
	if (defined $shell) {
		unshift(@@args, @@l);
		if ($self->{sudo}) {
			unshift(@@args, $sudo, "-E");
		}
		$shell->run("cd $ports && ".
		    join(' ', "SUBDIR=$fullpkgpath",
		    "PHASE=$t",
		    "WRAPPER_OUTPUT=$builder->{rsslog}",
		    @@args));
	} else {
		chdir($ports) or
		    die "Wrong ports tree $ports";
		$ENV{SUBDIR} = $fullpkgpath;
		$ENV{PHASE} = $t;
		$ENV{WRAPPER_OUTPUT} = $builder->{rsslog};
		if ($self->{sudo}) {
			exec {$sudo}("sudo", "-E", @@l, @@args);
		} else {
			exec {$make} (@@l, @@args);
		}
d96 7
a217 2
	my $sudo = OpenBSD::Paths->sudo;
	my $shell = $core->{shell};
d228 2
a229 7
	if (defined $shell) {
		$shell->run(join(' ', "PKG_PATH=$path", $sudo, @@cmd,
		    (sort keys %$dep)));
	} else {
		$ENV{PKG_PATH} = $path;
		exec{$sudo}($sudo, @@cmd, sort keys %$dep);
	}
a251 1
	my $sudo = OpenBSD::Paths->sudo;
d263 2
a264 1
	exec{$sudo}($sudo, @@cmd, $v->fullpkgname);
a329 1
	my $sudo = OpenBSD::Paths->sudo;
d337 1
a337 6
	my $shell = $core->{shell};
	if (defined $shell) {
		$shell->run(join(' ', $sudo, @@cmd));
	} else {
		exec{$sudo}($sudo, @@cmd);
	}
@


1.29
log
@fix env name for wrapper program
@
text
@d2 1
a2 1
# $OpenBSD: Port.pm,v 1.28 2012/04/21 11:30:53 espie Exp $
d84 10
d95 1
a95 1
		unshift(@@args, $builder->make_args);
d99 5
a103 2
		$shell->run("cd $ports && SUBDIR=".
		    $fullpkgpath." ".join(' ', @@args));
d109 1
a109 9
		my @@l = $builder->make_args;
		my $make = $builder->make;
		if (defined $builder->{rsslog}) {
			unless ($self->notime) {
				$make = $builder->{wrapper};
				$l[0] = $make;
				$ENV{WRAPPER_OUTPUT} = $builder->{rsslog};
			}
		}
@


1.28
log
@make it possible to use a specialized wrapper to collect rss stats
@
text
@d2 1
a2 1
# $OpenBSD: Port.pm,v 1.27 2012/04/10 17:06:15 espie Exp $
d102 1
a102 1
				$ENV{OUTPUT} = $builder->{rsslog};
@


1.27
log
@whitespace
@
text
@d2 1
a2 1
# $OpenBSD$
d95 10
d106 1
a106 1
			exec {$sudo}("sudo", "-E", $builder->make_args, @@args);
d108 1
a108 1
			exec {$builder->make} ($builder->make_args, @@args);
@


1.26
log
@keep track of how long a job is stuck, max.
@
text
@d2 1
a2 1
# $OpenBSD: Port.pm,v 1.25 2011/12/05 21:27:53 espie Exp $
d337 1
a337 1
	
d498 1
a498 1
		push(@@{$job->{tasks}}, 
d639 1
a639 1
			$self->{stuck} = 
d675 1
a675 1
	push(@@{$job->{tasks}}, 
@


1.25
log
@remove "needed" debug log now that things work fine.
@
text
@d2 1
a2 1
# $OpenBSD: Port.pm,v 1.24 2011/12/05 21:18:55 espie Exp $
d593 1
a593 1
	return join('/', map {sprintf("%s=%.2f", $_->name, $_->elapsed)} @@{$self->{done}});
@


1.24
log
@ouch, don't forget to lock at front of prepare (okay, we can avoid it
if no-depends but that's complicated)

also, two distinct critical sections: we don't need to stay locked at
the end of show-prepare-result.

Even though that's not really important, simplify logic a wee little bit
@
text
@d2 1
a2 1
# $OpenBSD: Port.pm,v 1.23 2011/12/05 18:29:39 espie Exp $
a340 3
	print {$job->{builder}{junk_log}} $core->hostname, "(", 
	    $job->{v}->fullpkgpath, "): ", join(' ', scalar(@@d), @@d), "\n";

@


1.23
log
@move uninstall behavior to uninstall, unbreak !-J
as noticed by fgs@@
@
text
@d2 1
a2 1
# $OpenBSD: Port.pm,v 1.22 2011/12/05 16:10:01 espie Exp $
d213 2
a227 1
	$self->junk_lock($core);
d320 1
a320 4
	# if we're not followed by uninstall, then we end the serialized part.
	if (!$job->{has_junk}) {
		$self->junk_unlock($core);
	}
d338 1
a522 1
			$self->{has_junk} = 1;
@


1.22
log
@turn -J into an option taking a number.
always run show-prepare-results, and always serialize
depends/prepare/show-prepare-results(/junk) on a single host.
@
text
@d2 1
a2 1
# $OpenBSD: Port.pm,v 1.21 2011/12/04 12:05:41 espie Exp $
a315 7
		# full list for every lock
		my @@d = $core->job->{builder}->locker->find_dependencies(
		    $core->hostname);
		$job->{needed} = [sort @@d];
		print {$job->{builder}{junk_log}} $core->hostname, "(", 
		    $job->{v}->fullpkgpath, "): ", join(' ', scalar(@@d), @@d), 
		    "\n";
d339 7
a345 1
	my @@cmd = ('/usr/sbin/pkg_delete', '-aX', @@{$job->{needed}});
@


1.21
log
@clean-up job running a bit: add methods to Grabber and PortBuilder objects
to access more stuff they need.

Remove distantshell->make, ask state instead.
Provide state with the program we run, and the parameters we pass it.

- same make for distant and local hosts
- pass BUILD_ONCE=Yes if -a.
@
text
@d2 1
a2 1
# $OpenBSD: Port.pm,v 1.20 2011/12/03 11:10:48 espie Exp $
a53 20
sub junk_lock
{
	my ($self, $core) = @@_;
	my $builder = $core->job->{builder};
	return unless $builder->{junk};

	while (!$builder->locker->lock($core)) {
		sleep 1;
	}
}

sub junk_unlock
{
	my ($self, $core) = @@_;
	my $builder = $core->job->{builder};
	return unless $builder->{junk};

	$builder->locker->unlock($core);
}

d71 2
d106 1
a106 1
package DPB::Task::Port::NoTime;
d108 32
a139 1
sub notime { 1 }
d142 3
a144 1
our @@ISA =qw(DPB::Task::Port::NoTime);
d187 3
a189 1
our @@ISA=qw(DPB::Task::Port::NoTime);
a195 1
	$self->junk_lock($core);
d226 1
d240 1
a241 1
	$core->{status} = 0;
d246 3
a248 1
our @@ISA=qw(DPB::Task::Port::NoTime);
d275 1
a276 1
	$core->{status} = 0;
d281 1
a281 13
our @@ISA = qw(DPB::Task::Port);

sub run
{
	my ($self, $core) = @@_;
	$self->SUPER::run($core);
}

sub finalize
{
	my ($self, $core) = @@_;
	$self->SUPER::finalize($core);
}
d284 1
a284 1
our @@ISA = qw(DPB::Task::Port);
d291 1
a301 3
	$self->SUPER::finalize($core);
	$core->{status} = 0;

d306 1
a306 1
		my @@l;
d311 1
a311 1
			push(@@l, $_);
d313 16
a328 1
		print {$job->{lock}} "needed=", join(' ', sort @@l), "\n";
d330 1
a330 8
	unlink($file);
	my $l = $job->{builder}{junk};
	# full list for every lock
	my @@l = $core->job->{builder}->locker->find_dependencies($core->hostname);
	$job->{needed} = [sort @@l];
	print $l $core->hostname, "(", $job->{v}->fullpkgpath, "): ", 
	    join(' ', scalar(@@l), @@l), "\n";
	return 1;
d334 3
a336 1
our @@ISA=qw(DPB::Task::Port::NoTime);
d360 2
a362 2
	$self->junk_unlock($core);
	$core->{status} = 0;
d420 3
a422 1
our @@ISA = qw(DPB::Task::Port::NoTime);
d438 3
a440 1
our @@ISA = qw(DPB::Task::Port::NoTime);
d520 1
a520 1
	push(@@todo, qw(depends prepare));
d522 5
a526 1
		push(@@todo, qw(show-prepare-results junk));
@


1.20
log
@open needed just once.
@
text
@d2 1
a2 1
# $OpenBSD: Port.pm,v 1.19 2011/12/02 22:37:36 espie Exp $
d60 1
a60 2
	my $locker = $builder->{state}->locker;
	while (!$locker->lock($core)) {
d71 1
a71 2
	my $locker = $builder->{state}->locker;
	$locker->unlock($core);
d86 1
a86 1
	my $ports = $builder->{ports};
d103 1
a103 1
		unshift(@@args, $shell->make);
d114 1
a114 1
			exec {$sudo}("sudo", "-E", $builder->{make}, @@args);
d116 1
a116 1
			exec {$builder->{make}} ("make", @@args);
d279 5
d287 1
a287 3
	my $logger = $job->{builder}{logger};
	my $name = $logger->log_pkgpath($job->{v}).".tmp";
	$self->redirect($name);
d299 1
a299 2
	my $logger = $job->{builder}{logger};
	my $file = $logger->log_pkgpath($job->{v}).".tmp";
d313 1
a313 2
	my $locker = $core->job->{builder}->{state}->locker;
	my @@l = $locker->find_dependencies($core->hostname);
d395 1
a395 1
			my $f2 = $job->{builder}->{logger}->open("size");
d432 1
a432 1
		my $fh = $job->{builder}->{logger}->open("clean");
@


1.19
log
@new -J option
- refactor redirect a bit to store multi-line results to a temporary file
- new show-prepare-results stage using that
- prepare and show-prepare-results shouldn't be NoTime, since they're
predictable.
- lock host thru depends -> junk in the junk case.
acquiring the lock is done thru polling in the child, so that it doesn't block
dpb proper.
- new "junk" stage that gathers dependencies and deletes them.
@
text
@d2 1
a2 1
# $OpenBSD: Port.pm,v 1.18 2011/12/02 11:40:25 espie Exp $
d311 1
a311 1
	my $l = $logger->open("needed");
@


1.18
log
@EXTRA should (partly) be handled like DEPENDS/BDEPENDS
@
text
@d2 1
a2 1
# $OpenBSD: Port.pm,v 1.17 2011/11/22 16:48:01 espie Exp $
d54 28
d92 1
a92 1
	$self->redirect($job->{log});
d161 1
a161 1
	$self->redirect($job->{log});
d181 1
d202 1
a202 1
	$self->redirect($job->{log});
d240 1
a240 1
	$self->redirect($job->{log});
d263 88
d362 1
a362 1
sub redirect
a363 1
	my ($self, $log) = @@_;
d382 1
d446 2
a447 1
	prepare => 'DPB::Task::Port::NoTime',
d452 1
d503 3
@


1.17
log
@use PREPARE_CHECK_ONLY to weed out bugs in dpb.
also, missed passing dontclean to one instance of add_normal_tasks, oops
@
text
@d2 1
a2 1
# $OpenBSD: Port.pm,v 1.16 2011/11/14 21:57:47 espie Exp $
d160 2
a161 2
	if (exists $v->{info}{EXTRA}) {
		for my $two (values %{$v->{info}{EXTRA}}) {
@


1.16
log
@explain to the engine how to install stuff when it's ready (no error
checks though).

new -I option to do that.
change -C option to be more useful.
@
text
@d2 1
a2 1
# $OpenBSD: Port.pm,v 1.15 2011/11/12 13:19:26 espie Exp $
d68 1
d118 3
a120 1
		$job->add_normal_tasks;
@


1.15
log
@make stuff slightly more verbose all the time
@
text
@d2 1
a2 1
# $OpenBSD: Port.pm,v 1.14 2011/10/10 18:56:50 espie Exp $
d198 33
d366 1
a366 1
		$job->add_normal_tasks;
d373 1
a373 1
	my $self = shift;
d394 1
a394 1
	if (!$builder->{dontclean}) {
d521 18
@


1.14
log
@unfuck pkgpaths.
- instead of seen/unseen, have an actual constructor. Instead, mark pkgpath
for which we wantinfo/wantbuild.
- only mark EXTRA dependencies as wantinfo. So the devel/haddock,no_deps
temporary error should be gone.
- since we have FLAVOR and SUBPACKAGE available, construct as much info as
we can during vars scanning (see handle_equivalences). This avoids about 150
path rescans during a full bulk. Also, grab the timing and logsizes from
equivalent files, so that most stuff should know show % all the time.
- tweak subdirlist to be a hash, and correctly add pkgpath_and_flavors to it.
That way, we rescan avahi pseudo flavors just once, and not four or five times.
@
text
@d2 1
a2 1
# $OpenBSD: Port.pm,v 1.13 2011/09/25 10:41:30 espie Exp $
d65 1
a65 3
	if ($builder->{state}->opt('v')) {
		print ">>> Running $t in $fullpkgpath\n";
	}
@


1.13
log
@make dpb more useful for people hacking on ports, allow them to not clean
the work directory after building.
@
text
@d2 1
a2 1
# $OpenBSD: Port.pm,v 1.12 2011/07/14 11:03:35 espie Exp $
d430 12
@


1.12
log
@when checksumming existing files work, remove a possible .part
@
text
@d2 1
a2 1
# $OpenBSD: Port.pm,v 1.11 2011/06/04 12:56:54 espie Exp $
d363 3
a365 1
	push @@todo, 'clean';
@


1.11
log
@keep a better list of depends, so that pkg_add does add exactly what it should
@
text
@d2 1
a2 1
# $OpenBSD: Port.pm,v 1.10 2011/06/02 17:09:25 espie Exp $
d137 2
@


1.10
log
@- unify code in Fetch/Build subengines
- zap heuristic#3, not critical
- don't rebuild the Fetch queue all the time, it's too expensive
- fix bugs in FetchQueue computation, correctly handle 1 distfile case
- create a quick path thru adjust* that handles only new paths.
- use it during LISTING while fetching files, to make more files available
quicker.
- model distfiles as FDEPENDS, DIST, so that they can get dumped.
- add -v option that dumps a bit more stuff in log files.

with these, dpb will fetch all distfiles in a not too surprising order,
and it won't consume 40% cpu while doing so...
@
text
@d2 1
a2 1
# $OpenBSD: Port.pm,v 1.9 2011/05/29 09:30:13 espie Exp $
d151 3
a153 6
	for my $kind (qw(BUILD_DEPENDS LIB_DEPENDS)) {
		if (exists $v->{info}{$kind}) {
			for my $d (values %{$v->{info}{$kind}}) {
				next if $d->{pkgpath} eq $v->{pkgpath};
				$dep->{$d->fullpkgname} = 1;
			}
d159 3
a161 5
			for my $kind (qw(RUN_DEPENDS LIB_DEPENDS)) {
				if (exists $two->{info}{$kind}) {
					for my $d (values %{$two->{info}{$kind}}) {
						$dep->{$d->fullpkgname} = 1;
					}
@


1.9
log
@if we're running -f, do the checksum part internally, since we already
checksummed stuff we fetched (will allow auto-refetch eventually).
@
text
@d2 1
a2 1
# $OpenBSD: Port.pm,v 1.8 2011/05/22 08:21:39 espie Exp $
d65 3
d134 1
a134 1
	for my $dist (values %{$job->{v}{info}{got}}) {
@


1.8
log
@initial support for fetching distfiles, somewhat experimental yet.
- clean up clock handling, jobs with timer.
- pass more parameters thru state
- tweak the engine to handle distfiles
- lots of new code in Fetch for new jobs.
@
text
@d2 1
a2 1
# $OpenBSD: Port.pm,v 1.7 2011/04/25 11:58:46 espie Exp $
d71 3
d123 16
d293 1
d349 7
a355 1
	push(@@todo, qw(depends prepare fetch patch configure build));
@


1.7
log
@finish refactoring options.
Deprecate: -t and -T
use -DCONNECTION_TIMEOUT=... -DDISPLAY_TIMEOUT=... instead
New feature: -DSTUCK_TIMEOUT=
kill tasks when they don't show any progress for that long.
@
text
@d2 1
a2 1
# $OpenBSD: Port.pm,v 1.6 2010/11/01 10:55:26 espie Exp $
d21 1
a22 1
use Time::HiRes qw(time);
d25 1
a25 1
our @@ISA = qw(DPB::Task::Fork);
d42 1
a42 4
	my $job = $core->job;
	$self->{started} = time();
	DPB::Clock->register($self);
	$job->{current} = $self->{phase};
d49 1
a49 2
	$self->{ended} = time();
	DPB::Clock->unregister($self);
a53 12
sub elapsed
{
	my $self = shift;
	return $self->{ended} - $self->{started};
}

sub stopped_clock
{
	my ($self, $gap) = @@_;
	$self->{started} += $gap;
}

d246 1
a246 4
		my $sz = (stat $job->{watched})[7];
		if (defined $sz) {
			$job->{offset} = $sz;
		}
d407 1
d410 1
a410 1
			$self->{expected} = $logsize->{$w};
d414 2
a415 14
	$self->{watched} = $logger->log_pkgpath($v);
}

sub watch
{
	my $self = shift;
	my $sz = (stat $self->{watched})[7];
	if (defined $self->{offset} && defined $sz) {
		$sz -= $self->{offset};
	}
	if (!defined $self->{sz} || $self->{sz} != $sz) {
		$self->{sz} = $sz;
		$self->{time} = time();
	}
d422 2
a423 23
	$self->watch;
	my $progress = '';
	if (defined $self->{sz}) {
		if (defined $self->{expected} &&
		    $self->{sz} < 4 * $self->{expected}) {
			$progress = ' '.
			    int($self->{sz}*100/$self->{expected}). '%';
		} else {
			$progress = ' '.$self->{sz};
	    	}
	}

	my $diff = $current - $self->{time};
	my $unchanged = " unchanged for ";
	if ($diff > 7200) {
		$unchanged .= int($diff/3600)." hours";
	} elsif ($diff > 300) {
		$unchanged .= int($diff/60)." minutes";
	} elsif ($diff > 10) {
		$unchanged .= int($diff)." seconds";
	} else {
		$unchanged = "";
	}
d426 1
a426 1
		if ($diff / $core->sf > $stuck) {
d428 1
a428 1
			    "KILLED: $self->{current} stuck at $progress,$unchanged";
d433 1
a433 1
	return $progress.$unchanged;
d440 1
a440 2
	$self->watch;
	my $diff = $current - $self->{time};
@


1.6
log
@much better implementation of -R. In case of rebuilds, check does not "see"
pkgfiles, unless they've been registered.
the engine queues everything to build, but normal build is only an
existence/signature check. The actual build tasks only get queued when
the package does not exist, or if its signature does NOT match the ports
tree.

Should make matthieu@@ happy.
@
text
@d2 1
a2 1
# $OpenBSD: Port.pm,v 1.5 2010/10/28 14:21:18 espie Exp $
d391 4
d450 1
a450 1
	my ($self, $current) = @@_;
d465 1
d467 1
a467 1
		return "$progress unchanged for ".int($diff/3600)." hours";
d469 1
a469 1
		return "$progress unchanged for ".int($diff/60)." minutes";
d471 1
a471 1
		return "$progress unchanged for ".int($diff)." seconds";
d473 10
a482 1
		return $progress;
d484 1
@


1.5
log
@of course, confusing prepare and depends is bad
@
text
@d2 1
a2 1
# $OpenBSD: Port.pm,v 1.4 2010/10/28 11:56:48 espie Exp $
d113 23
d317 26
d344 1
d357 1
a357 6
	bless {
	    tasks => [map {DPB::Port::TaskFactory->create($_)} @@todo],
	    log => $log, v => $v,
	    special => $special,  current => '',
	    builder => $builder, endcode => $endcode},
		$class;
@


1.4
log
@do the next step even if prepare fails, since prepare is fairly rigid
and depends will allow more flavors.
@
text
@d2 1
a2 1
# $OpenBSD: Port.pm,v 1.3 2010/09/02 11:16:09 jasper Exp $
a112 10
package DPB::Task::Port::Prepare;
our @@ISA = qw(DPB::Task::Port::NoTime);

sub finalize
{
	my ($self, $core) = @@_;
	$self->SUPER::finalize($core);
	return 1;
}

d166 9
d271 1
a271 1
	prepare => 'DPB::Task::Port::Prepare',
@


1.3
log
@- revert previous, it breaks builds for at least two builders.

discussed with landry@@ and naddy@@
@
text
@d2 1
a2 1
# $OpenBSD: Port.pm,v 1.1.1.1 2010/08/20 13:40:14 espie Exp $
d113 10
d272 1
a272 1
	prepare => 'DPB::Task::Port::NoTime',
@


1.2
log
@fix overquoting: we want to exit with 1, not a "exit 1" command not found error
@
text
@d83 1
a83 1
	    "REPORT_PROBLEM=exit 1", "BULK=No");
@


1.1
log
@Initial revision
@
text
@d2 1
a2 1
# $OpenBSD: Port.pm,v 1.20 2010/05/10 13:02:35 espie Exp $
d83 1
a83 1
	    "REPORT_PROBLEM='exit 1'", "BULK=No");
@


1.1.1.1
log
@move stuff here from infra/build
@
text
@@
