head	1.38;
access;
symbols
	OPENBSD_6_1:1.38.0.2
	OPENBSD_6_1_BASE:1.38
	OPENBSD_6_0:1.37.0.2
	OPENBSD_6_0_BASE:1.37
	OPENBSD_5_9:1.36.0.2
	OPENBSD_5_9_BASE:1.36
	OPENBSD_5_8:1.36.0.4
	OPENBSD_5_8_BASE:1.36
	OPENBSD_5_7:1.27.0.4
	OPENBSD_5_7_BASE:1.27
	OPENBSD_5_6:1.27.0.2
	OPENBSD_5_6_BASE:1.27
	OPENBSD_5_5:1.26.0.2
	OPENBSD_5_5_BASE:1.26
	OPENBSD_5_4:1.22.0.2
	OPENBSD_5_4_BASE:1.22
	OPENBSD_5_3:1.20.0.2
	OPENBSD_5_3_BASE:1.20
	OPENBSD_5_2:1.15.0.2
	OPENBSD_5_2_BASE:1.15
	OPENBSD_5_1_BASE:1.11
	OPENBSD_5_1:1.11.0.2
	OPENBSD_5_0:1.7.0.2
	OPENBSD_5_0_BASE:1.7
	OPENBSD_4_9:1.5.0.2
	OPENBSD_4_9_BASE:1.5
	ports:1.1.1.1
	espie:1.1.1;
locks; strict;
comment	@# @;


1.38
date	2016.11.07.21.26.06;	author afresh1;	state Exp;
branches;
next	1.37;
commitid	NtK9vgIRtqGXHmOX;

1.37
date	2016.05.14.20.26.42;	author espie;	state Exp;
branches;
next	1.36;
commitid	gvFH21DvORIWVoTi;

1.36
date	2015.06.23.08.51.53;	author espie;	state Exp;
branches;
next	1.35;
commitid	32zs6aY8gWUWqLkN;

1.35
date	2015.05.24.06.48.51;	author espie;	state Exp;
branches;
next	1.34;
commitid	oi2S5hnnGJfxdQvu;

1.34
date	2015.05.07.12.30.46;	author espie;	state Exp;
branches;
next	1.33;
commitid	bTlfhLMWrwKobBb3;

1.33
date	2015.05.03.10.33.59;	author espie;	state Exp;
branches;
next	1.32;
commitid	lBfNuZOkyaPdWlyt;

1.32
date	2015.05.02.09.44.40;	author espie;	state Exp;
branches;
next	1.31;
commitid	1VP4TYxT74T6B9km;

1.31
date	2015.05.01.19.42.54;	author espie;	state Exp;
branches;
next	1.30;
commitid	xBVlN5hyUkSlow3v;

1.30
date	2015.04.26.18.00.19;	author espie;	state Exp;
branches;
next	1.29;
commitid	V6PNfhncU60d7XW1;

1.29
date	2015.04.25.11.40.58;	author espie;	state Exp;
branches;
next	1.28;
commitid	uoRLcf51nveokBOa;

1.28
date	2015.04.21.09.53.13;	author espie;	state Exp;
branches;
next	1.27;
commitid	lGAocVQGyzRmFit9;

1.27
date	2014.03.09.20.09.53;	author espie;	state Exp;
branches;
next	1.26;

1.26
date	2013.10.25.16.54.27;	author espie;	state Exp;
branches;
next	1.25;

1.25
date	2013.10.08.17.40.41;	author espie;	state Exp;
branches;
next	1.24;

1.24
date	2013.10.06.13.33.32;	author espie;	state Exp;
branches;
next	1.23;

1.23
date	2013.10.04.20.28.41;	author espie;	state Exp;
branches;
next	1.22;

1.22
date	2013.07.18.05.36.54;	author espie;	state Exp;
branches;
next	1.21;

1.21
date	2013.07.12.08.07.19;	author espie;	state Exp;
branches;
next	1.20;

1.20
date	2013.02.03.21.45.52;	author espie;	state Exp;
branches;
next	1.19;

1.19
date	2013.01.06.14.38.14;	author espie;	state Exp;
branches;
next	1.18;

1.18
date	2013.01.06.11.59.40;	author espie;	state Exp;
branches;
next	1.17;

1.17
date	2013.01.05.19.59.43;	author espie;	state Exp;
branches;
next	1.16;

1.16
date	2013.01.04.12.03.06;	author espie;	state Exp;
branches;
next	1.15;

1.15
date	2012.03.02.17.14.41;	author espie;	state Exp;
branches;
next	1.14;

1.14
date	2012.02.28.14.23.27;	author espie;	state Exp;
branches;
next	1.13;

1.13
date	2012.02.27.14.51.37;	author espie;	state Exp;
branches;
next	1.12;

1.12
date	2012.02.20.21.18.48;	author espie;	state Exp;
branches;
next	1.11;

1.11
date	2011.12.03.11.03.07;	author espie;	state Exp;
branches;
next	1.10;

1.10
date	2011.12.02.22.32.07;	author espie;	state Exp;
branches;
next	1.9;

1.9
date	2011.11.13.22.18.04;	author espie;	state Exp;
branches;
next	1.8;

1.8
date	2011.11.06.12.22.17;	author espie;	state Exp;
branches;
next	1.7;

1.7
date	2011.06.04.12.58.24;	author espie;	state Exp;
branches;
next	1.6;

1.6
date	2011.05.22.08.21.39;	author espie;	state Exp;
branches;
next	1.5;

1.5
date	2010.12.06.13.20.45;	author espie;	state Exp;
branches;
next	1.4;

1.4
date	2010.10.27.22.58.02;	author espie;	state Exp;
branches;
next	1.3;

1.3
date	2010.10.27.12.58.26;	author espie;	state Exp;
branches;
next	1.2;

1.2
date	2010.10.26.16.57.10;	author espie;	state Exp;
branches;
next	1.1;

1.1
date	2010.08.20.13.40.13;	author espie;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2010.08.20.13.40.13;	author espie;	state Exp;
branches;
next	;


desc
@@


1.38
log
@Remove fcntl.ph use from DPB::Locks

Replace with a hardcoded constant as Fcntl doesn't provide it.

Fix suggested by espie@@ fine with millert@@
@
text
@# ex:ts=8 sw=4:
# $OpenBSD: Locks.pm,v 1.37 2016/05/14 20:26:42 espie Exp $
#
# Copyright (c) 2010-2013 Marc Espie <espie@@openbsd.org>
#
# Permission to use, copy, modify, and distribute this software for any
# purpose with or without fee is hereby granted, provided that the above
# copyright notice and this permission notice appear in all copies.
#
# THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
# ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
# OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

use strict;
use warnings;
use DPB::User;

package DPB::Locks;
our @@ISA = (qw(DPB::UserProxy));

use File::Path;
use Fcntl;

# Fcntl doesn't export this
use constant O_CLOEXEC => 0x10000;

sub new
{
	my ($class, $state) = @@_;

	my $lockdir = $state->{lockdir};
	my $o = bless {lockdir => $lockdir, 
		dpb_pid => $$, 
		user => $state->{log_user},
		dpb_host => DPB::Core::Local->hostname}, $class;
	$o->make_path($lockdir);
	$o->run_as(
	    sub {
		if (!$state->defines("DONT_CLEAN_LOCKS")) {
			$o->{stalelocks} = $o->clean_old_locks($state);
		}
	    });
	return $o;
}

sub clean_old_locks
{
	my ($self, $state) = @@_;
	my $hostpaths = {};
	START:
	my $info = {};
	my @@problems = ();
	my $locks = {};
	my $dir = $self->opendir($self->{lockdir});
	DIR: while (my $e = readdir($dir)) {
		next if $e eq '..' or $e eq '.';
		my $f = "$self->{lockdir}/$e";
		my $fh = $self->open('<', $f);
		if (defined $fh) {
			my ($pid, $host);
			my $client = DPB::Core::Local->hostname;
			my $path;
			my $tag;
			while(<$fh>) {
				if (m/^dpb\=(\d+)\s+on\s+(\S+)$/) {
					($pid, $host) = ($1, $2);
					next DIR 
					    unless $host eq $self->{dpb_host};
				} elsif (m/^(?:error|status|todo)\=/) {
					next DIR;
				} elsif (m/^host=(.*)$/) {
					$client = $1;
				} elsif (m/^locked=(.*)$/) {
					$path = $1;
				} elsif (m/^tag=(.+)$/) {
					$tag = $1;
				}
			}
			if (defined $tag) {
				DPB::Core::Init->taint($host, $tag, $path);
			}
			$info->{$f} = [$host, $path] if defined $path;
			if (defined $pid) {
				push(@@{$locks->{$pid}}, $f);
			} else {
				push(@@problems, $f);
			}
		} else {
			push(@@problems, $f);
		}
	}
	if (keys %$locks != 0) {
		open(my $ps, "-|", "ps", "-axww", "-o", "pid args");
		my $junk = <$ps>;
		while (<$ps>) {
			if (m/^(\d+)\s+(.*)$/) {
				my ($pid, $cmd) = ($1, $2);
				if ($locks->{$pid} && $cmd =~ m/\bdpb\b/) {
					delete $locks->{$pid};
				}
			}
		}
		for my $list (values %$locks) {
			for my $l (@@$list) {
				my ($host, $path) = @@{$info->{$l}};
				push(@@{$hostpaths->{$host}}, $path);
				$self->unlink($l);
			}
		}
	}
	if (@@problems) {
		$state->say("Problematic lockfiles I can't parse:\n\t#1\n".
			"Waiting for ten seconds",
			join(' ', @@problems));
		sleep 10;
		goto START;
	}
	return $hostpaths;
}

sub build_lockname
{
	my ($self, $f) = @@_;
	$f =~ tr|/|.|;
	return "$self->{lockdir}/$f";
}

sub lockname
{
	my ($self, $v) = @@_;
	return $self->build_lockname($v->lockname);
}

sub dolock
{
	my ($self, $name, $v) = @@_;
	$self->run_as(
	    sub {
		if (sysopen my $fh, $name, 
		    O_CREAT|O_EXCL|O_WRONLY|O_CLOEXEC, 0666) {
			DPB::Util->make_hot($fh);
			print $fh "locked=", $v->logname, "\n";
			print $fh "dpb=", $self->{dpb_pid}, " on ", 
			    $self->{dpb_host}, "\n";
			$v->print_parent($fh);
			return $fh;
		} else {
			return 0;
		}
	    });
}

sub lock
{
	my ($self, $v) = @@_;
	my $lock = $self->lockname($v);
	my $fh = $self->dolock($lock, $v);
	if ($fh) {
		return $fh;
	}
	return undef;
}

sub unlock
{
	my ($self, $v) = @@_;
	$self->unlink($self->lockname($v));
}

sub locked
{
	my ($self, $v) = @@_;
	return $self->run_as(
	    sub {
	    	return -e $self->lockname($v);
	    });
}

sub find_dependencies
{
	my ($self, $hostname) = @@_;
	my $dir = $self->opendir($self->{lockdir});
	my $h = {};
	while (my $name = readdir($dir)) {
		next if $name eq '.' or $name eq '..';
		next if $name =~ m/^host:/;
		#next if -d $fullname;
		my $fullname = $self->{lockdir}."/".$name;
		my $f = $self->open('<', $fullname);
		my $nojunk = 0;
		my $host;
		my $path;
		my $cleaned;
		my @@d;
		while (<$f>) {
			if (m/^locked=(.*)/) {
				$path = $1;
			} elsif (m/^host=(.*)/) {
				$host = $1;
			# XXX wanted always precedes needed, so
			# it's safe to overwrite
			} elsif (m/^(?:wanted|needed)=(.*)/) {
				@@d = split(/\s/, $1);
			} elsif (m/^nojunk$/) {
				$nojunk = 1;
			} elsif (m/^cleaned$/) {
				$cleaned = 1;
			}
		}
		next if $cleaned;
		if (defined $host && $host eq $hostname) {
			if ($nojunk) {
				# XXX
				return $path;
			}
			for my $k (@@d) {
				$h->{$k} = 1;
			}
		}
	}
	return $h;
}

sub find_tag
{
	my ($self, $hostname) = @@_;
	my $dir = $self->opendir($self->{lockdir});
	while (my $name = readdir($dir)) {
		next if $name eq '.' or $name eq '..';
		next if $name =~ m/^host:/;
		#next if -d $fullname;
		my $fullname = $self->{lockdir}."/".$name;
		my $f = $self->open('<', $fullname);
		# XXX nfs shitting on itself again
		# assume we don't have several dpb running and so I don't
		# give a fuck
		next if !$f;
		my ($host, $cleaned, $tag);
		while (<$f>) {
			if (m/^host\=(.*)/) {
				$host = $1;
			} elsif (m/^cleaned$/) {
				$cleaned = 1;
			} elsif (m/^tag\=(.+)/) {
				$tag = $1;
			}
		}
		next if $cleaned;
		if (defined $host && $host eq $hostname) {
			return $tag if defined $tag;
		}
	}
	return undef;
}

1;
@


1.37
log
@nfs shits on its pants again.
not even having readdir and open work synchronously on one single machine,
that shit is so lame.

noticed by aja@@, ahaha.
@
text
@d2 1
a2 1
# $OpenBSD: Locks.pm,v 1.36 2015/06/23 08:51:53 espie Exp $
d27 3
a29 1
require 'fcntl.ph';
d144 1
a144 1
		    O_CREAT|O_EXCL|O_WRONLY|O_CLOEXEC(), 0666) {
@


1.36
log
@tweak taintedness:
- fix actual bug in PortInfo
- restrict defined tags to !empty tags (shouldn't happen)
- track the source from locks as well.
@
text
@d2 1
a2 1
# $OpenBSD: Locks.pm,v 1.35 2015/05/24 06:48:51 espie Exp $
d236 4
@


1.35
log
@tweak find_dependencies to just return a result (deps or path)
reuse in can_be_junked. As exemplified by editors/tiled, a failing
port with nojunk set should also prevent junk tentatives, as these
will fail, but still untaint hosts...

seen by aja@@ and naddy@@, most probably.
@
text
@d2 1
a2 1
# $OpenBSD: Locks.pm,v 1.34 2015/05/07 12:30:46 espie Exp $
d77 1
a77 1
				} elsif (m/^tag=(.*)$/) {
d82 1
a82 1
				DPB::Core::Init->taint($host, $tag);
d238 1
a238 1
			if (m/^host=(.*)/) {
d242 1
a242 1
			} elsif (m/^tag=(.*)/) {
@


1.34
log
@make sure we're root when killing stuff. I'm mixing up right and left,
obviously.
@
text
@d2 1
a2 1
# $OpenBSD: Locks.pm,v 1.33 2015/05/03 10:33:59 espie Exp $
d215 2
a216 2
				print "Can't run junk because of lock on $path\n";
				return undef;
@


1.33
log
@do a few more things with the correct user
@
text
@d2 1
a2 1
# $OpenBSD: Locks.pm,v 1.32 2015/05/02 09:44:40 espie Exp $
d175 4
a178 1
	return -e $self->lockname($v);
d187 3
a190 2
		next if -d $fullname;
		next if $name =~ m/^host:/;
d231 3
a234 2
		next if -d $fullname;
		next if $name =~ m/^host:/;
@


1.32
log
@move the user handling code to a separate file.
remove "run_as" for open, we can do things directly.

More explicit code on open.
@
text
@d2 1
a2 1
# $OpenBSD: Locks.pm,v 1.31 2015/05/01 19:42:54 espie Exp $
d56 1
a56 1
	opendir(my $dir, $self->{lockdir});
d60 2
a61 1
		if (open my $fh, '<', $f) {
d109 1
a109 1
				unlink($l);
d169 1
a169 4
	$self->run_as(
	    sub {
		unlink($self->lockname($v));
	    });
d181 1
a181 1
	opendir(my $dir, $self->{lockdir});
d187 1
a187 1
		open(my $f, '<', $fullname);
d225 1
a225 1
	opendir(my $dir, $self->{lockdir});
d230 1
a230 1
		open(my $f, '<', $fullname);
@


1.31
log
@lock_user is not needed, defaults to log_user for all practical cases
@
text
@d2 1
a2 1
# $OpenBSD: Locks.pm,v 1.30 2015/04/26 18:00:19 espie Exp $
d20 1
a20 1
use DPB::Config;
@


1.30
log
@use UserProxy and make_path method.
Have the default host handle chroot correctly.

(still a bit of fetch to fix)
@
text
@d2 1
a2 1
# $OpenBSD: Locks.pm,v 1.29 2015/04/25 11:40:58 espie Exp $
d36 1
a36 1
		user => $state->{lock_user},
@


1.29
log
@make most of the creatio files code able to change identity so that logging,
locking   don't happen as root.

Still need to do the fetchfiles/package linking part.
@
text
@d2 1
a2 1
# $OpenBSD: Locks.pm,v 1.28 2015/04/21 09:53:13 espie Exp $
d20 1
d23 1
a28 6
sub run_as
{
	my ($self, $code) = @@_;
	$self->{user}->run_as($code);
}

d38 1
a40 1
		File::Path::make_path($lockdir);
@


1.28
log
@setting the stage for further changes
@
text
@d2 1
a2 1
# $OpenBSD: Locks.pm,v 1.27 2014/03/09 20:09:53 espie Exp $
d27 6
a37 1
	File::Path::make_path($lockdir);
d40 1
d42 7
a48 3
	if (!$state->defines("DONT_CLEAN_LOCKS")) {
		$o->{stalelocks} = $o->clean_old_locks($state);
	}
d142 14
a155 10
	if (sysopen my $fh, $name, O_CREAT|O_EXCL|O_WRONLY|O_CLOEXEC(), 0666) {
		DPB::Util->make_hot($fh);
		print $fh "locked=", $v->logname, "\n";
		print $fh "dpb=", $self->{dpb_pid}, " on ", 
		    $self->{dpb_host}, "\n";
		$v->print_parent($fh);
		return $fh;
	} else {
		return 0;
	}
d172 4
a175 1
	unlink($self->lockname($v));
@


1.27
log
@jobs will register the dependencies they would want, preventing junk
from removing them (so that we do less delete/re-add cycles, the more
cores you have the more relevant this becomes).

again, found on Yandex machines, thx to 12 cores or more.
@
text
@d2 1
a2 1
# $OpenBSD: Locks.pm,v 1.26 2013/10/25 16:54:27 espie Exp $
d29 1
a29 1
	my ($class, $state, $lockdir) = @@_;
d31 1
@


1.26
log
@mark most opened files as close-on-exec, since the commands we run don't care
about them. Heck, they shouldn't even be able to access them... Ouchie.
@
text
@d2 1
a2 1
# $OpenBSD: Locks.pm,v 1.25 2013/10/08 17:40:41 espie Exp $
d186 3
a188 1
			} elsif (m/^needed=(.*)/) {
@


1.25
log
@on restart, if we find old locks with tags, those hosts start tainted
@
text
@d2 1
a2 1
# $OpenBSD: Locks.pm,v 1.24 2013/10/06 13:33:32 espie Exp $
d25 1
d131 1
a131 1
	if (sysopen my $fh, $name, O_CREAT|O_EXCL|O_WRONLY, 0666) {
@


1.24
log
@update my copyright to 2013
@
text
@d2 1
a2 1
# $OpenBSD: Locks.pm,v 1.23 2013/10/04 20:28:41 espie Exp $
d56 1
d68 2
d71 3
@


1.23
log
@really need to store tags in locks, as dependencies in there will kill
me when restarting dpb...
@
text
@d2 1
a2 1
# $OpenBSD: Locks.pm,v 1.22 2013/07/18 05:36:54 espie Exp $
d4 1
a4 1
# Copyright (c) 2010 Marc Espie <espie@@openbsd.org>
@


1.22
log
@change the way errors are handled, fixed version:
- pass error condition from Job/Port.pm all the way to the engine
- use that to know whether we fail, instead of the existence of packages
(but still keep track of what we're doing correctly, THAT'S the fix)
- refactor error handling into OO version
- keep track of locks/errors/packages we're waiting for thx to nfs

all of these keep the lock around, and react to the lock being removed.

use case for nfs: if there was a revision bump after dpb scanned the port,
it will never find the package. Removing the lock will allow dpb to rescan
and find the correct packages.

with this, dpb no longer waits after nfs. More importantly, it does not
report nfs hangs as E:, rather as H:... (and it can "wait" for much longer
periods, since it keeps running and only checks on new jobs).
@
text
@d2 1
a2 1
# $OpenBSD: Locks.pm,v 1.21 2013/07/12 08:07:19 espie Exp $
d199 27
@


1.21
log
@note paths we cleaned in the locks, so that we're not stuck with their
depends or nonjunk properties.
@
text
@d2 1
a2 1
# $OpenBSD: Locks.pm,v 1.20 2013/02/03 21:45:52 espie Exp $
a156 26
}

sub recheck_errors
{
	my ($self, $engine) = (@@_);

	for my $name (qw(errors locks)) {
		my $e = $engine->{$name};
		$engine->{$name} = [];
		while (my $v = shift @@$e) {
			if ($v->unlock_conditions($engine)) {
				$self->unlock($v);
				$v->requeue($engine);
				next;
			}
			if ($self->locked($v)) {
				push(@@{$engine->{$name}}, $v);
			} else {
				if ($name eq 'errors') {
					$engine->rescan($v);
				} else {
					$v->requeue($engine);
				}
			}
		}
	}
@


1.20
log
@be a bit more verbose about what's going on for junk
specifically:
- log the paths that may run junk
- explicitly log nojunk behavior
@
text
@d2 1
a2 1
# $OpenBSD: Locks.pm,v 1.19 2013/01/06 14:38:14 espie Exp $
d198 1
d209 2
d213 1
@


1.19
log
@if I run into lockfiles that don't contain the requisite dpb property,
just hold on until they're there.

Should happen right away, so easy to spot !
@
text
@d2 1
a2 1
# $OpenBSD: Locks.pm,v 1.18 2013/01/06 11:59:40 espie Exp $
d197 1
d200 3
a202 1
			if (m/^host=(.*)/) {
d211 4
a214 1
			return undef if $nojunk;
@


1.18
log
@ask the ports tree to clean up stale locks, finally...
@
text
@d2 1
a2 1
# $OpenBSD: Locks.pm,v 1.17 2013/01/05 19:59:43 espie Exp $
d42 5
a46 1
	my $self = shift;
a47 2
	my $info = {};
	my $hostpaths = {};
d50 1
d52 22
a73 15
		next if -d $f;
		open my $fh, '<', $f or next;
		my ($pid, $host);
		my $client = DPB::Core::Local->hostname;
		my $path;
		while(<$fh>) {
			if (m/^dpb\=(\d+)\s+on\s+(\S+)$/) {
				($pid, $host) = ($1, $2);
				next DIR unless $host eq $self->{dpb_host};
			} elsif (m/^(?:error|status|todo)\=/) {
				next DIR;
			} elsif (m/^host=(.*)$/) {
				$client = $1;
			} elsif (m/^locked=(.*)$/) {
				$path = $1;
d75 2
a77 2
		$info->{$f} = [$host, $path] if defined $path;
		push(@@{$locks->{$pid}}, $f) if defined $pid;
d97 7
@


1.17
log
@retrieve the lists of paths locked per-host from the old lock scanner,
to eventually be able to clean them in init.
@
text
@d2 1
a2 1
# $OpenBSD: Locks.pm,v 1.16 2013/01/04 12:03:06 espie Exp $
d35 1
a35 1
		$o->clean_old_locks($state);
d52 1
a52 1
		my $client = 'localhost';
d69 9
a77 9
	return if keys %$locks == 0;

	open(my $ps, "-|", "ps", "-axww", "-o", "pid args");
	my $junk = <$ps>;
	while (<$ps>) {
		if (m/^(\d+)\s+(.*)$/) {
			my ($pid, $cmd) = ($1, $2);
			if ($locks->{$pid} && $cmd =~ m/\bdpb\b/) {
				delete $locks->{$pid};
d80 6
a85 6
	}
	for my $list (values %$locks) {
		for my $l (@@$list) {
			my ($host, $path) = @@{$info->{$l}};
			push(@@{$hostpaths->{$host}}, $path);
			unlink($l);
@


1.16
log
@forgot that one commit for nojunk. Oops
@
text
@d2 1
a2 1
# $OpenBSD: Locks.pm,v 1.15 2012/03/02 17:14:41 espie Exp $
d44 2
d52 2
d58 1
a58 2
			}
			if (m/^(?:error|status|todo)\=/) {
d60 4
d66 1
d83 2
d88 1
@


1.15
log
@fix detection of existing dpbs.
@
text
@d2 1
a2 1
# $OpenBSD: Locks.pm,v 1.14 2012/02/28 14:23:27 espie Exp $
d167 1
d175 2
d180 1
d186 1
a186 1
	return sort keys %$h;
@


1.14
log
@better: if old locks, don't warn.
if no locks to possibly remove, well, don't even run ps !
@
text
@d2 1
a2 1
# $OpenBSD: Locks.pm,v 1.13 2012/02/27 14:51:37 espie Exp $
d67 1
a67 1
			my ($pid, $cmd) = @@_;
@


1.13
log
@allow -I/-P/-C and command-line arguments to be lists of pkgpaths, or pkgpath
(it's easy to distinguish between a file and a directory under ports).

expand sequences for those files and hosts

when restarting dpb, kill locks that don't correspond to errors, but to a dpb
running on the same host that's no longer there.

do __WARN__ like __DIE__

option -DDONT_BUILD_ONCE
option -DDONT_CLEAN_LOCKS

document some
@
text
@d2 1
a2 1
# $OpenBSD: Locks.pm,v 1.12 2012/02/20 21:18:48 espie Exp $
d59 1
a59 1
		push(@@{$locks->{$pid}}, $f);
d61 2
@


1.12
log
@record master dpb pid and hostname
(will be used for automatic clean-up of locks on startup)
@
text
@d2 1
a2 1
# $OpenBSD: Locks.pm,v 1.11 2011/12/03 11:03:07 espie Exp $
d28 1
a28 1
	my ($class, $lockdir) = @@_;
d31 1
a31 1
	bless {lockdir => $lockdir, 
d34 42
@


1.11
log
@faster NFS: if the missing file suddenly reappears, we don't need to rescan
the path, just put it back in the queue, and forget it ever happened.
@
text
@d2 1
a2 1
# $OpenBSD: Locks.pm,v 1.10 2011/12/02 22:32:07 espie Exp $
d31 3
a33 1
	bless {lockdir => $lockdir}, $class;
d55 2
@


1.10
log
@don't buffer printing to locks, to be able to get dependencies early
gather needed=* lines from locks (may want to cache that info later,
but I don't think it has any actual performance impact)
@
text
@d2 1
a2 1
# $OpenBSD: Locks.pm,v 1.9 2011/11/13 22:18:04 espie Exp $
d93 2
@


1.9
log
@simplify lock code so that lock/unlock actually works, even if I lose
small-grained locks for fullpkgpath
also fix a stupid parenting bug...
@
text
@d2 1
a2 1
# $OpenBSD: Locks.pm,v 1.8 2011/11/06 12:22:17 espie Exp $
d51 1
d107 27
@


1.8
log
@use print_parent
@
text
@d2 1
a2 1
# $OpenBSD: Locks.pm,v 1.7 2011/06/04 12:58:24 espie Exp $
a40 6
sub simple_lockname
{
	my ($self, $v) = @@_;
	return $self->build_lockname($v->simple_lockname);
}

d51 1
a51 1
		print $fh "fullpkgpath=", $v->lockname, "\n";
d62 2
a63 2
	my $simple = $self->simple_lockname($v);
	my $fh = $self->dolock($simple, $v);
d65 1
a65 10
		my $lk = $self->lockname($v);
		if ($simple eq $lk) {
			return $fh;
		}
		my $fh2 = $self->dolock($lk, $v);
		if ($fh2) {
			return $fh2;
		} else {
			$self->simple_unlock($v);
		}
a73 10
	$self->simple_unlock($v);
}

sub simple_unlock
{
	my ($self, $v) = @@_;
	my $simple = $self->simple_lockname($v);
	if ($self->lockname($v) ne $simple) {
		unlink($simple);
	}
d79 1
a79 1
	return -e $self->lockname($v) || -e $self->simple_lockname($v);
@


1.7
log
@spaces
@
text
@d2 1
a2 1
# $OpenBSD$
d58 1
a58 3
		if (defined $v->{parent}) {
			print $fh "parent=", $v->{parent}->lockname, "\n";
		}
@


1.6
log
@initial support for fetching distfiles, somewhat experimental yet.
- clean up clock handling, jobs with timer.
- pass more parameters thru state
- tweak the engine to handle distfiles
- lots of new code in Fetch for new jobs.
@
text
@d2 1
a2 1
# $OpenBSD: Locks.pm,v 1.5 2010/12/06 13:20:45 espie Exp $
@


1.5
log
@tag dependencies discovered as pure dependencies with their parents, allow
finding out non-sensical stuff in an easier way
@
text
@d2 1
a2 1
# $OpenBSD: Locks.pm,v 1.4 2010/10/27 22:58:02 espie Exp $
d44 1
a44 1
	return $self->build_lockname($v->{pkgpath});
d50 1
a50 1
	return $self->build_lockname($v->fullpkgpath);
d57 1
a57 1
		print $fh "fullpkgpath=", $v->fullpkgpath, "\n";
d59 1
a59 1
			print $fh "parent=", $v->{parent}->fullpkgpath, "\n";
d117 1
a117 1
			if ($v->{info} && $engine->{builder}->check($v)) {
d126 1
a126 1
					$engine->requeue($v);
@


1.4
log
@use rescan after errors, so that bumps get picked up
@
text
@d2 1
a2 1
# $OpenBSD: Locks.pm,v 1.3 2010/10/27 12:58:26 espie Exp $
d58 3
@


1.3
log
@tie engine with var grabber, get ready to re-do port meta on error.
@
text
@d2 1
a2 1
# $OpenBSD: Locks.pm,v 1.2 2010/10/26 16:57:10 espie Exp $
d120 3
a122 4
#				XXX not ready yet
#				if ($name eq 'errors') {
#					$engine->rescan($v);
#				} else {
d124 1
a124 1
#				}
@


1.2
log
@distinguishes between errors we create (E=) and locks we encounter (L=)
@
text
@d2 1
a2 1
# $OpenBSD: Locks.pm,v 1.1.1.1 2010/08/20 13:40:13 espie Exp $
d120 6
a125 1
				$engine->requeue($v);
@


1.1
log
@Initial revision
@
text
@d2 1
a2 1
# $OpenBSD: Locks.pm,v 1.6 2010/07/14 14:18:59 espie Exp $
d110 12
a121 10
	my $e = $engine->{errors};
	$engine->{errors} = [];
	while (my $v = shift @@$e) {
		if ($v->{info} && $engine->{builder}->check($v)) {
			$self->unlock($v);
		}
		if ($self->locked($v)) {
			push(@@{$engine->{errors}}, $v);
		} else {
			$engine->requeue($v);
@


1.1.1.1
log
@move stuff here from infra/build
@
text
@@
