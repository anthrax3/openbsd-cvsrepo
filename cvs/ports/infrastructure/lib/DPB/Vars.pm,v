head	1.51;
access;
symbols
	OPENBSD_6_2:1.51.0.2
	OPENBSD_6_2_BASE:1.51
	OPENBSD_6_1:1.49.0.4
	OPENBSD_6_1_BASE:1.49
	OPENBSD_6_0:1.49.0.2
	OPENBSD_6_0_BASE:1.49
	OPENBSD_5_9:1.45.0.2
	OPENBSD_5_9_BASE:1.45
	OPENBSD_5_8:1.45.0.4
	OPENBSD_5_8_BASE:1.45
	OPENBSD_5_7:1.40.0.2
	OPENBSD_5_7_BASE:1.40
	OPENBSD_5_6:1.39.0.2
	OPENBSD_5_6_BASE:1.39
	OPENBSD_5_5:1.38.0.2
	OPENBSD_5_5_BASE:1.38
	OPENBSD_5_4:1.35.0.2
	OPENBSD_5_4_BASE:1.35
	OPENBSD_5_3:1.32.0.2
	OPENBSD_5_3_BASE:1.32
	OPENBSD_5_2:1.28.0.2
	OPENBSD_5_2_BASE:1.28
	OPENBSD_5_1_BASE:1.26
	OPENBSD_5_1:1.26.0.2
	OPENBSD_5_0:1.17.0.2
	OPENBSD_5_0_BASE:1.17
	OPENBSD_4_9:1.11.0.2
	OPENBSD_4_9_BASE:1.11
	ports:1.1.1.1
	espie:1.1.1;
locks; strict;
comment	@# @;


1.51
date	2017.06.20.15.48.12;	author espie;	state Exp;
branches;
next	1.50;
commitid	tC9eGQspnCU6IGfE;

1.50
date	2017.05.09.14.18.28;	author espie;	state Exp;
branches;
next	1.49;
commitid	audW5VLqBxhZNgl1;

1.49
date	2016.05.17.14.50.36;	author espie;	state Exp;
branches;
next	1.48;
commitid	sNkGwrxrgGunoaEN;

1.48
date	2016.05.16.10.37.22;	author espie;	state Exp;
branches;
next	1.47;
commitid	oMvaWPOzLvyJF5w8;

1.47
date	2016.05.16.10.28.14;	author espie;	state Exp;
branches;
next	1.46;
commitid	Tn5xZiy5z9OLEA20;

1.46
date	2016.05.15.22.24.56;	author espie;	state Exp;
branches;
next	1.45;
commitid	46E90Phu6WZId5HI;

1.45
date	2015.07.27.17.19.46;	author espie;	state Exp;
branches;
next	1.44;
commitid	BfOIh312Dz5zQQRh;

1.44
date	2015.05.10.08.14.14;	author espie;	state Exp;
branches;
next	1.43;
commitid	J9XuZmxJc7sLMZLF;

1.43
date	2015.05.03.12.15.05;	author espie;	state Exp;
branches;
next	1.42;
commitid	60KGp5SoN7EsDS5U;

1.42
date	2015.05.02.17.43.27;	author espie;	state Exp;
branches;
next	1.41;
commitid	MVhWhXDccR26bkXh;

1.41
date	2015.03.14.20.45.11;	author espie;	state Exp;
branches;
next	1.40;
commitid	F3KXERWdpj8W1V50;

1.40
date	2014.12.07.15.18.50;	author espie;	state Exp;
branches;
next	1.39;
commitid	GynqjLfrNHwgIuss;

1.39
date	2014.03.17.10.48.40;	author espie;	state Exp;
branches;
next	1.38;

1.38
date	2013.12.30.12.28.23;	author espie;	state Exp;
branches;
next	1.37;

1.37
date	2013.10.06.13.33.35;	author espie;	state Exp;
branches;
next	1.36;

1.36
date	2013.09.18.15.30.40;	author espie;	state Exp;
branches;
next	1.35;

1.35
date	2013.06.21.09.05.18;	author espie;	state Exp;
branches;
next	1.34;

1.34
date	2013.03.11.12.23.40;	author espie;	state Exp;
branches;
next	1.33;

1.33
date	2013.03.03.00.50.15;	author espie;	state Exp;
branches;
next	1.32;

1.32
date	2013.01.29.15.11.02;	author espie;	state Exp;
branches;
next	1.31;

1.31
date	2013.01.10.16.20.10;	author espie;	state Exp;
branches;
next	1.30;

1.30
date	2012.10.06.15.38.14;	author espie;	state Exp;
branches;
next	1.29;

1.29
date	2012.08.15.09.05.05;	author espie;	state Exp;
branches;
next	1.28;

1.28
date	2012.07.10.22.59.06;	author espie;	state Exp;
branches;
next	1.27;

1.27
date	2012.07.04.08.59.10;	author espie;	state Exp;
branches;
next	1.26;

1.26
date	2012.01.29.12.02.20;	author espie;	state Exp;
branches;
next	1.25;

1.25
date	2011.12.04.12.05.41;	author espie;	state Exp;
branches;
next	1.24;

1.24
date	2011.11.22.16.44.53;	author espie;	state Exp;
branches;
next	1.23;

1.23
date	2011.11.14.19.03.41;	author espie;	state Exp;
branches;
next	1.22;

1.22
date	2011.11.13.22.18.04;	author espie;	state Exp;
branches;
next	1.21;

1.21
date	2011.11.06.12.21.47;	author espie;	state Exp;
branches;
next	1.20;

1.20
date	2011.10.11.13.56.41;	author espie;	state Exp;
branches;
next	1.19;

1.19
date	2011.10.10.18.56.50;	author espie;	state Exp;
branches;
next	1.18;

1.18
date	2011.09.13.09.46.53;	author espie;	state Exp;
branches;
next	1.17;

1.17
date	2011.06.04.12.58.24;	author espie;	state Exp;
branches;
next	1.16;

1.16
date	2011.06.02.17.09.25;	author espie;	state Exp;
branches;
next	1.15;

1.15
date	2011.05.22.08.21.39;	author espie;	state Exp;
branches;
next	1.14;

1.14
date	2011.04.18.11.40.23;	author espie;	state Exp;
branches;
next	1.13;

1.13
date	2011.04.05.08.24.34;	author espie;	state Exp;
branches;
next	1.12;

1.12
date	2011.03.22.19.48.01;	author espie;	state Exp;
branches;
next	1.11;

1.11
date	2010.12.07.10.56.26;	author espie;	state Exp;
branches;
next	1.10;

1.10
date	2010.12.06.13.20.45;	author espie;	state Exp;
branches;
next	1.9;

1.9
date	2010.12.05.10.06.12;	author espie;	state Exp;
branches;
next	1.8;

1.8
date	2010.11.02.20.32.59;	author espie;	state Exp;
branches;
next	1.7;

1.7
date	2010.10.30.11.36.07;	author espie;	state Exp;
branches;
next	1.6;

1.6
date	2010.10.30.10.35.09;	author espie;	state Exp;
branches;
next	1.5;

1.5
date	2010.10.29.12.35.00;	author espie;	state Exp;
branches;
next	1.4;

1.4
date	2010.10.28.14.54.38;	author espie;	state Exp;
branches;
next	1.3;

1.3
date	2010.10.28.10.33.20;	author espie;	state Exp;
branches;
next	1.2;

1.2
date	2010.10.26.15.45.09;	author espie;	state Exp;
branches;
next	1.1;

1.1
date	2010.08.20.13.40.13;	author espie;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2010.08.20.13.40.13;	author espie;	state Exp;
branches;
next	;


desc
@@


1.51
log
@wrap long line
@
text
@# ex:ts=8 sw=4:
# $OpenBSD: Vars.pm,v 1.50 2017/05/09 14:18:28 espie Exp $
#
# Copyright (c) 2010-2013 Marc Espie <espie@@openbsd.org>
#
# Permission to use, copy, modify, and distribute this software for any
# purpose with or without fee is hereby granted, provided that the above
# copyright notice and this permission notice appear in all copies.
#
# THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
# ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
# OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
use strict;
use warnings;
use DPB::Util;

package DPB::GetThings;
sub subdirlist
{
	my ($class, $list) = @@_;
	return join(' ', sort keys %$list);
}

sub run_command
{
	my ($class, $core, $shell, $grabber, $subdirs, $skip, @@args) = @@_;

	if (defined $subdirs) {
		$shell->env(SUBDIR => $class->subdirlist($subdirs));
	}
	if (defined $skip) {
		$shell->env(SKIPDIR => $class->subdirlist($skip));
	}
	$shell->exec($grabber->make_args, @@args);
	exit(1);
}

package DPB::Vars;

our @@ISA = qw(DPB::GetThings);

use OpenBSD::Paths;
sub get
{
	my ($class, $shell, $make, @@names) = @@_;
	pipe(my $rh, my $wh);
	my $pid = fork();
	if ($pid == 0) {
		$DB::inhibit_exit = 0;
		print $wh "print-data:\n";
		for my $n (@@names) {
			print $wh "\t\@@echo \${$n}\n";
		}
		print $wh <<EOT;
COMMENT = test
CATEGORIES = test
PKGPATH = test/a
DISTNAME = test
PERMIT_PACKAGE_CDROM=Yes
IGNORE=Yes
_MAKEFILE_INC_DONE=Yes
ECHO_MSG=:
.PHONY: print-data
.include <bsd.port.mk>
SIGNING_PARAMETERS ?=
EOT
		close $wh;
		exit 0;
	}
	close $wh;
	my @@list;
	my $pid2 = open(my $output, "-|");
	if ($pid2) {
		close $rh;
		@@list = <$output>;
		chomp for @@list;
		waitpid($pid2, 0);
		waitpid($pid, 0);
	} else {
		close STDIN;
		open(STDIN, '<&', $rh);
		$shell->exec($make, '-C', '/', '-f', '-', 'print-data');
		DPB::Util->die("oops couldn't exec $make");
    	}
	return @@list;
}

sub run_pipe
{
	my ($class, $core, $grabber, $subdirs, $skip, $dpb) = @@_;
	$core->start_pipe(sub {
		my $shell = shift;
		close STDERR;
		open STDERR, '>&', STDOUT or 
		    DPB::Util->die_bang("bad redirect");
		$class->run_command($core, $shell, $grabber, $subdirs, $skip,
		    'dump-vars', "DPB=$dpb", "BATCH=Yes", "REPORT_PROBLEM=:");
	}, "LISTING");
}

sub grab_list
{
	my ($class, $core, $grabber, $subdirs, $skip, $ignore_errors, 
	    $log, $dpb, $code) = @@_;
	$class->run_pipe($core, $grabber, $subdirs, $skip, $dpb);
	my $h = {};
	my $seen = {};
	my $fh = $core->fh;
	my $subdir;
	my $category;
	my $reset = sub {
	    $h = DPB::PkgPath->handle_equivalences($grabber->{state}, 
	    	$h, $subdirs);
	    $grabber->{fetch}->build_distinfo($h, $grabber->{state}{mirror});
	    DPB::PkgPath->merge_depends($h);
	    &$code($h);
	    $h = {};
	};

	my @@current = ();
	my ($o, $info);
	my $previous = '';
	while(<$fh>) {
		push(@@current, $_);
		chomp;
		if (m/^\=\=\=\> .* skipped$/) {
			print $log $_, "\n";
			next;
		}
		if (m/^\=\=\=\>\s*Exiting (.*) with an error$/) {
			undef $category;
			next if $ignore_errors;
			my $dir = DPB::PkgPath->new($1);
			if (defined $skip) {
				$dir->add_to_subdirlist($skip);
			}
			$dir->break("exiting with an error");
			$h->{$dir} = $dir;
			my $quicklog = $grabber->logger->append(
			    $grabber->logger->log_pkgpath($dir));
			print $quicklog @@current;
			&$reset;
			next;
		}
		if (m/^\=\=\=\>\s*(.*)/) {
			@@current = ("$_\n");
			$core->job->set_status(" at $1");
			$subdir = DPB::PkgPath->new($1);
			if (defined $skip) {
				$subdir->add_to_subdirlist($skip);
			}
			print $log $_;
			if (defined $subdir->{parent}) {
				print $log " (", $subdir->{parent}->fullpkgpath, ")";
			}
			print $log "\n";
			if (defined $category) {
				$category->{category} = 1;
			}
			$category = $subdir;
			$previous = '';
			&$reset;
		} elsif (my ($pkgpath, $var, $value) =
		    m/^(.*?)\.([A-Z][A-Z_0-9]*)\=\s*(.*)\s*$/) {
			undef $category;
			next unless DPB::PortInfo->wanted($var);

			if ($value =~ m/^\"(.*)\"$/) {
				$value = $1;
			}
			if ($pkgpath ne $previous) {
				$o = DPB::PkgPath->compose($pkgpath, $subdir);
				$info = $seen->{$o} = DPB::PortInfo->new($o);
				$h->{$o} = $o;
				$previous = $pkgpath;
			}
			eval { $info->add($var, $value, $o); };
			if ($@@) {
				print $log $@@;
				$o->break("error with adding $var=$value");
			}
		} elsif (m/^\>\>\s*Broken dependency:\s*(.*?)\s*non existent/) {
			next if $ignore_errors;
			my $dir = DPB::PkgPath->new($1);
			$dir->break("broken dependency");
			$h->{$dir} = $dir;
			if (defined $skip) {
				$dir->add_to_subdirlist($skip);
			}
			print $log $_, "\n";
			print $log "Broken ", $dir->fullpkgpath, "\n";
			&$reset;
		} else {
			print $log $_, "\n";
		}
	}
	&$reset;
	$core->terminate;
}

package DPB::PortSignature;
our @@ISA = qw(DPB::GetThings);

sub grab_signature
{
	my ($class, $core, $grabber, $subdir) = @@_;
	my $signature;
	$core->start_pipe(sub {
		my $shell = shift;
		$class->run_command($core, $shell, $grabber, {$subdir => 1},
			undef, 'print-package-signature', 'ECHO_MSG=:')
	}, "PORT-SIGNATURE");
	my $fh = $core->fh;
	while (<$fh>) {
		chomp;
		$signature = $_;
	}
	$core->terminate;
	return $signature;
}

package DPB::CleanPackages;
our @@ISA = qw(DPB::GetThings);
sub clean
{
	my ($class, $core, $grabber, $subdir) = @@_;
	$core->start_pipe(sub {
		my $shell = shift;
		$class->run_command($core, $shell, $grabber, {$subdir => 1},
			undef, 'clean=package')
	}, "CLEAN-PACKAGES");
	my $fh = $core->fh;
	while (<$fh>) {
	}
	$core->terminate;
}

1;
@


1.50
log
@if I want to enforce rules on WRKDIST, I'd better respect them first
@
text
@d2 1
a2 1
# $OpenBSD: Vars.pm,v 1.49 2016/05/17 14:50:36 espie Exp $
d98 2
a99 1
		open STDERR, '>&', STDOUT or DPB::Util->die_bang("bad redirect");
@


1.49
log
@tweaks to heuristics
1/ do subdirs on the command line first
2/ ignore errors from "preferred" dependencies (and don't register anything)
if there are actual errors beyond paths that no longer exist, we'll get them
during the next pass.
@
text
@d2 1
a2 1
# $OpenBSD: Vars.pm,v 1.48 2016/05/16 10:37:22 espie Exp $
d62 1
@


1.48
log
@fix log (missing \n)
@
text
@d2 1
a2 1
# $OpenBSD: Vars.pm,v 1.47 2016/05/16 10:28:14 espie Exp $
d105 2
a106 1
	my ($class, $core, $grabber, $subdirs, $skip, $log, $dpb, $code) = @@_;
d134 1
d185 1
@


1.47
log
@add SKIPDIRS semantics: automatically add visited dirs to a passed skip
if it's not empty
@
text
@d2 1
a2 1
# $OpenBSD: Vars.pm,v 1.46 2016/05/15 22:24:56 espie Exp $
d128 1
a128 1
			print $log $_;
@


1.46
log
@support SKIPDIR internally
@
text
@d2 1
a2 1
# $OpenBSD: Vars.pm,v 1.45 2015/07/27 17:19:46 espie Exp $
d128 1
d134 3
d149 3
d186 3
@


1.45
log
@grab a few more things off our ports tree introspection. Locally PLIST_DB.

Distantly, WRKOBJDIR and LOCKDIR, so that we can pass these off to a startup
script to ensure correct user.

The distant stuff has to happen at the right moment, after whoami, so that
we don't try to use doas/sudo unnecessarily...
@
text
@d2 1
a2 1
# $OpenBSD: Vars.pm,v 1.44 2015/05/10 08:14:14 espie Exp $
d30 1
a30 1
	my ($class, $core, $shell, $grabber, $subdirs, @@args) = @@_;
d35 3
d93 1
a93 1
	my ($class, $core, $grabber, $subdirs, $dpb) = @@_;
d98 1
a98 1
		$class->run_command($core, $shell, $grabber, $subdirs,
d105 2
a106 2
	my ($class, $core, $grabber, $subdirs, $log, $dpb, $code) = @@_;
	$class->run_pipe($core, $grabber, $subdirs, $dpb);
d127 3
d200 1
a200 1
			'print-package-signature', 'ECHO_MSG=:')
d219 1
a219 1
			'clean=package')
@


1.44
log
@rename logger interface to desambiguate vs user.
@
text
@d2 1
a2 1
# $OpenBSD: Vars.pm,v 1.43 2015/05/03 12:15:05 espie Exp $
a59 1
WRKOBJDIR=
@


1.43
log
@that's cute
@
text
@d2 1
a2 1
# $OpenBSD: Vars.pm,v 1.42 2015/05/02 17:43:27 espie Exp $
d130 1
a130 1
			my $quicklog = $grabber->logger->open(
@


1.42
log
@forgot to drop user there. Probably a few more left :(
@
text
@d2 1
a2 1
# $OpenBSD: Vars.pm,v 1.41 2015/03/14 20:45:11 espie Exp $
d130 1
a130 1
			my $quicklog = $grabber->logger->open('>>',
@


1.41
log
@use make -C
@
text
@d2 1
a2 1
# $OpenBSD: Vars.pm,v 1.40 2014/12/07 15:18:50 espie Exp $
d130 2
a131 2
			open my $quicklog,  '>>',
			    $grabber->logger->log_pkgpath($dir);
@


1.40
log
@wrap die so that it drops into the debugger if we run under perl -d.

change the way we do rescans again, to avoid race conditions:
just store away *all* pkgpaths related to the rescan (so that multi-packages
are covered) and then do the rescan. Hold those like we do for normal locks
but in a different list, and release them when the scan is over.

remove the atrocious shennanigans wrt fullpkgnames, it shouldn't be needed
again, hopefully.
@
text
@d2 1
a2 1
# $OpenBSD: Vars.pm,v 1.39 2014/03/17 10:48:40 espie Exp $
a31 3
	my $ports = $grabber->ports;

	$shell->chdir($ports);
d83 1
a83 2
		$shell->chdir('/')
			->exec($make, '-f', '-', 'print-data');
@


1.39
log
@prepare for perl 5.18
- don't bother declaring $_ for while(<>) loops. assume current default
will still work.
- rename variable for readability elsewhere.
@
text
@d2 1
a2 1
# $OpenBSD: Vars.pm,v 1.38 2013/12/30 12:28:23 espie Exp $
d19 1
d88 1
a88 1
		die "oops couldn't exec $make";
d99 1
a99 1
		open STDERR, '>&', STDOUT or die "bad redirect";
@


1.38
log
@Add -Dunsigned while building, unless we are in an environment where we
sign packages by default.
@
text
@d2 1
a2 1
# $OpenBSD: Vars.pm,v 1.37 2013/10/06 13:33:35 espie Exp $
d54 2
a55 2
		for my $_ (@@names) {
			print $wh "\t\@@echo \${$_}\n";
@


1.37
log
@update my copyright to 2013
@
text
@d2 1
a2 1
# $OpenBSD: Vars.pm,v 1.36 2013/09/18 15:30:40 espie Exp $
d68 1
@


1.36
log
@use a "shell" to run getvars, so that we can run it again LATER.
@
text
@d2 1
a2 1
# $OpenBSD: Vars.pm,v 1.35 2013/06/21 09:05:18 espie Exp $
d4 1
a4 1
# Copyright (c) 2010 Marc Espie <espie@@openbsd.org>
@


1.35
log
@disentangle the config/init code from the rest.

- move the meat of handle_options from dpb into config->parse_command_line
(this means a backcall to still inherit from OpenBSD::State).
- move parse_config_files from core into config.
- move the prop handling into proper HostProperties (part of config
obviously)
- create a Core::Init file that contains all the former DPB::Host::Factory
and associated jobs.

there's still a wee little bit of cleanup to do, but this should be
easier to maintain, as all option handling is now in one place, and
startup and host confi is now easier to figure out.

- add a -DMIRROR=0/1  setup that controls whether SUPDISTFILES will be
fetched (defaults to 1 for -F and 0 for -f).

- actually allow for several host files to be parsed, as the name implies
@
text
@d2 1
a2 1
# $OpenBSD: Vars.pm,v 1.34 2013/03/11 12:23:40 espie Exp $
d48 1
a48 1
	my ($class, $make, @@names) = @@_;
a82 1
		chdir('/');
d84 2
a85 1
		exec {$make} ('make', '-f', '-', 'print-data');
@


1.34
log
@if you poison PERMIT_DISTFILES_CDROM, this should still work...
@
text
@d2 1
a2 1
# $OpenBSD: Vars.pm,v 1.33 2013/03/03 00:50:15 espie Exp $
d113 7
a119 7
			$h = DPB::PkgPath->handle_equivalences($grabber->{state}, $h, $subdirs);
			$grabber->{fetch}->build_distinfo($h, 
			    $grabber->{state}->{fetch_only});
			DPB::PkgPath->merge_depends($h);
			&$code($h);
			$h = {};
		    };
@


1.33
log
@don't go to debugger either
@
text
@d2 1
a2 1
# $OpenBSD: Vars.pm,v 1.32 2013/01/29 15:11:02 espie Exp $
a61 3
PERMIT_PACKAGE_FTP=Yes
PERMIT_DISTFILES_CDROM=Yes
PERMIT_DISTFILES_FTP=Yes
@


1.32
log
@adjust to reality: the current algorithm cleans up packages one subpackage
at a time.
@
text
@d2 1
a2 1
# $OpenBSD: Vars.pm,v 1.31 2013/01/10 16:20:10 espie Exp $
d52 1
@


1.31
log
@create pkgpaths objects is rather costly, so first do a string comparison
instead of creating the same object again and again.

removes *most* of the calls to PkgPath->create/compose !
@
text
@d2 1
a2 1
# $OpenBSD: Vars.pm,v 1.30 2012/10/06 15:38:14 espie Exp $
d218 1
a218 1
			'clean=packages')
@


1.30
log
@our make does ignore further targets with the same name, but it's not
a reason to misuse that feature.

When invoking bsd.port.mk, be more specific, give us a target that's not
defined.
@
text
@d2 1
a2 1
# $OpenBSD: Vars.pm,v 1.29 2012/08/15 09:05:05 espie Exp $
d124 2
a125 1
	my ($previous, $info);
d153 1
d163 3
a165 5
			my $o = DPB::PkgPath->compose($pkgpath, $subdir);
			if (!defined $previous || $previous != $o) {
				$seen->{$o} = DPB::PortInfo->new($o);
				$previous = $o;
				$info = $seen->{$o};
d167 1
@


1.29
log
@keep state during variable scanning (we see pkgpath in order).
Reset info for a new path systematically, instead of only creating
new infos.

Part of handling erroring paths better: if a pkgpath errors out, when
we remove the lock, the whole port will be rescanned at once, instead of
doing one subpkgpath only.
@
text
@d2 1
a2 1
# $OpenBSD: Vars.pm,v 1.28 2012/07/10 22:59:06 espie Exp $
d52 1
a52 1
		print $wh "all:\n";
d68 1
d87 1
a87 1
		exec {$make} ('make', '-f', '-');
@


1.28
log
@avoid barfing if run into a directory whose parent contains a Makefile.inc
@
text
@d2 1
a2 1
# $OpenBSD: Vars.pm,v 1.27 2012/07/04 08:59:10 espie Exp $
d123 1
d161 6
a166 3
			$seen->{$o} //= DPB::PortInfo->new($o);
			my $info = $seen->{$o};
			$h->{$o} = $o;
@


1.27
log
@remove distinction between local and distant running, always create
a shell object that can chdir, setenv, and exec commands.
(note that this executes stuff after fork, so permanent changes are cheap
and okay)

Also create it from "host" objects, which simplifies parameter passing.
@
text
@d2 1
a2 1
# $OpenBSD: Vars.pm,v 1.26 2012/01/29 12:02:20 espie Exp $
d66 1
d84 1
@


1.26
log
@more flexible error path while scanning, accumulate reasons why broken.
remove a few explicit (and implicit) die from Fetch: missing/out-of-sync
distinfo no longer kill dpb, instead they're properly reported as broken
paths and things still go on (note that even a missing SUPDISTFILE checksum
*will* mark a path as broken, that's totally intentional)
@
text
@d2 1
a2 1
# $OpenBSD: Vars.pm,v 1.25 2011/12/04 12:05:41 espie Exp $
d33 3
a35 13
	if (defined $shell) {
		my $s='';
		if (defined $subdirs) {
			$s="SUBDIR='".$class->subdirlist($subdirs)."'";
		}
		$shell->run("cd $ports && $s ".
		    join(' ', $grabber->make_args, @@args));
	} else {
		if (defined $subdirs) {
			$ENV{SUBDIR} = $class->subdirlist($subdirs);
		}
		chdir($ports) or die "Bad directory $ports";
		exec {$grabber->make} ($grabber->make_args, @@args);
d37 1
@


1.25
log
@clean-up job running a bit: add methods to Grabber and PortBuilder objects
to access more stuff they need.

Remove distantshell->make, ask state instead.
Provide state with the program we run, and the parameters we pass it.

- same make for distant and local hosts
- pass BUILD_ONCE=Yes if -a.
@
text
@d2 1
a2 1
# $OpenBSD: Vars.pm,v 1.24 2011/11/22 16:44:53 espie Exp $
d94 1
a94 1
		die "oops";
d136 1
a136 1
			$dir->{broken} = "exiting with an error";
d173 1
a173 1
				$o->{broken} = "error with adding $var=$value";
d177 1
a177 1
			$dir->{broken} = "broken dependency";
@


1.24
log
@subtle effect of equivalence: sometimes, we do not get back the subdir
we asked for.

This can be a problem, as rescan relies on it to reenter the path in the
various queues.

So, when we build the equivalence hash, give special treatment to extra
paths that match the actual subdirs list.

Problem reported by naddy@@, who sees sporadic errors linked to NFS lag,
which mean that paths sometimes get flagged as errors, then later the error
vanishes automatically when the package appears...

well, this makes darn sure the correct pkgpath does not vanish.
@
text
@d2 1
a2 1
# $OpenBSD: Vars.pm,v 1.23 2011/11/14 19:03:41 espie Exp $
d39 1
a39 1
		    join(' ', $shell->make, @@args));
d45 1
a45 1
		exec {$grabber->make} ('make', @@args);
@


1.23
log
@show parents when we recurse thru subdirs. a bit noisy, but useful when
you want to figure out why some big stuff you wanted to avoid is building
@
text
@d2 1
a2 1
# $OpenBSD: Vars.pm,v 1.22 2011/11/13 22:18:04 espie Exp $
d121 1
a121 1
			DPB::PkgPath->handle_equivalences($grabber->{state}, $h);
@


1.22
log
@simplify lock code so that lock/unlock actually works, even if I lose
small-grained locks for fullpkgpath
also fix a stupid parenting bug...
@
text
@d2 1
a2 1
# $OpenBSD: Vars.pm,v 1.21 2011/11/06 12:21:47 espie Exp $
a145 1
			print $log $_, "\n";
d148 5
@


1.21
log
@document why it's broken. Link more parent stuff.
@
text
@d2 1
a2 1
# $OpenBSD: Vars.pm,v 1.20 2011/10/11 13:56:41 espie Exp $
a173 1
			$dir->{parent} = $subdir;
@


1.20
log
@fix -R and -c.
@
text
@d2 1
a2 1
# $OpenBSD: Vars.pm,v 1.19 2011/10/10 18:56:50 espie Exp $
d136 1
a136 1
			$dir->{broken} = 1;
d169 1
a169 1
				$o->{broken} = 1;
d173 2
a174 1
			$dir->{broken} = 1;
@


1.19
log
@unfuck pkgpaths.
- instead of seen/unseen, have an actual constructor. Instead, mark pkgpath
for which we wantinfo/wantbuild.
- only mark EXTRA dependencies as wantinfo. So the devel/haddock,no_deps
temporary error should be gone.
- since we have FLAVOR and SUBPACKAGE available, construct as much info as
we can during vars scanning (see handle_equivalences). This avoids about 150
path rescans during a full bulk. Also, grab the timing and logsizes from
equivalent files, so that most stuff should know show % all the time.
- tweak subdirlist to be a hash, and correctly add pkgpath_and_flavors to it.
That way, we rescan avahi pseudo flavors just once, and not four or five times.
@
text
@d2 1
a2 1
# $OpenBSD: Vars.pm,v 1.18 2011/09/13 09:46:53 espie Exp $
d195 1
a195 1
		$class->run_command($core, $shell, $grabber, [$subdir],
d214 1
a214 1
		$class->run_command($core, $shell, $grabber, [$subdir],
@


1.18
log
@beginning of a fetch-only option that is supposed to replace mirror-maker
eventually.

- fetch all files
- ignore ignores
- specific builder that doesn't look at existing packages

currently: does not stop when  fetch is finished, which is somewhat of the
remaining issue.

Also: change stats to store pid, to make sense of interleaved log files.
@
text
@d2 1
a2 1
# $OpenBSD: Vars.pm,v 1.17 2011/06/04 12:58:24 espie Exp $
d24 1
a24 1
	return join(' ', sort @@$list);
d121 1
a121 3
			for my $v (values %$h) {
				$v->handle_default($h);
			}
d135 1
a135 1
			my $dir = DPB::PkgPath->new_hidden($1);
d148 1
a148 1
			$subdir = DPB::PkgPath->new_hidden($1);
d172 1
a172 1
			my $dir = DPB::PkgPath->new_hidden($1);
@


1.17
log
@spaces
@
text
@d2 1
a2 1
# $OpenBSD$
d124 2
a125 1
			$grabber->{fetch}->build_distinfo($h);
@


1.16
log
@- unify code in Fetch/Build subengines
- zap heuristic#3, not critical
- don't rebuild the Fetch queue all the time, it's too expensive
- fix bugs in FetchQueue computation, correctly handle 1 distfile case
- create a quick path thru adjust* that handles only new paths.
- use it during LISTING while fetching files, to make more files available
quicker.
- model distfiles as FDEPENDS, DIST, so that they can get dumped.
- add -v option that dumps a bit more stuff in log files.

with these, dpb will fetch all distfiles in a not too surprising order,
and it won't consume 40% cpu while doing so...
@
text
@d2 1
a2 1
# $OpenBSD: Vars.pm,v 1.15 2011/05/22 08:21:39 espie Exp $
d139 1
a139 1
			open my $quicklog,  '>>', 
@


1.15
log
@initial support for fetching distfiles, somewhat experimental yet.
- clean up clock handling, jobs with timer.
- pass more parameters thru state
- tweak the engine to handle distfiles
- lots of new code in Fetch for new jobs.
@
text
@d2 1
a2 1
# $OpenBSD: Vars.pm,v 1.14 2011/04/18 11:40:23 espie Exp $
d124 1
a125 1
			$grabber->{fetch}->build_distinfo($h);
@


1.14
log
@ignore whitespace
@
text
@d2 1
a2 1
# $OpenBSD: Vars.pm,v 1.13 2011/04/05 08:24:34 espie Exp $
d125 1
a125 4
			if ($dpb eq 'fetch') {
				require DPB::Fetch;
				DPB::Fetch->build_distinfo($h);
			}
@


1.13
log
@in case we log errors, go to the next iteration correctly.
log the fullpkgpath explicitly when we can.
@
text
@d2 1
a2 1
# $OpenBSD: Vars.pm,v 1.12 2011/03/22 19:48:01 espie Exp $
d159 1
a159 1
		    m/^(.*?)\.([A-Z][A-Z_0-9]*)\=(.*)$/) {
@


1.12
log
@add the glue that parses fetch info and build distinfo for future fetching.
also let Vars report stuff it doesn't know about to the logs file.
@
text
@d2 1
a2 1
# $OpenBSD: Vars.pm,v 1.11 2010/12/07 10:56:26 espie Exp $
d145 2
d180 2
@


1.11
log
@better info rebuild: make Vars responsible for creating info "just in time"
by keeping local state.
That way, when we rescan, we don't have to remove any info, and all affected
infos are replaced at the same time.
@
text
@d2 1
a2 1
# $OpenBSD: Vars.pm,v 1.10 2010/12/06 13:20:45 espie Exp $
d105 1
a105 1
		open STDERR, '>&STDOUT' or die "bad redirect";
d125 4
d173 7
@


1.10
log
@tag dependencies discovered as pure dependencies with their parents, allow
finding out non-sensical stuff in an easier way
@
text
@d2 1
a2 1
# $OpenBSD: Vars.pm,v 1.9 2010/12/05 10:06:12 espie Exp $
d116 1
d161 2
a162 1
			my $info = DPB::PortInfo->new($o);
@


1.9
log
@allow 'dpb archivers' without extra artifacts, e.g., recognize and
handle categories without classifying them as pkgpaths with errors.
@
text
@d2 1
a2 1
# $OpenBSD: Vars.pm,v 1.8 2010/11/02 20:32:59 espie Exp $
d162 1
a162 1
			eval { $info->add($var, $value); };
@


1.8
log
@in case the signature doesn't match, clean ALL packages that will be
rebuilt. Otherwise, you may suffer through 3 or 4 rebuilds of qt3...

ouchie.
@
text
@d2 1
a2 1
# $OpenBSD: Vars.pm,v 1.7 2010/10/30 11:36:07 espie Exp $
d118 1
d133 1
d146 4
d153 1
@


1.7
log
@don't cheat, we have to make clean=package to avoid side-effects with
arch-independent packages.
@
text
@d2 1
a2 1
# $OpenBSD: Vars.pm,v 1.6 2010/10/30 10:35:09 espie Exp $
d187 1
a187 1
package DPB::CleanPackage;
d195 2
a196 2
			'clean=package')
	}, "CLEAN-PACKAGE");
@


1.6
log
@simplify parameter passing slightly
@
text
@d2 1
a2 1
# $OpenBSD: Vars.pm,v 1.5 2010/10/29 12:35:00 espie Exp $
d185 16
@


1.5
log
@refactor to make most of it reusable to e.g., make print-package-signature
@
text
@d2 1
a2 1
# $OpenBSD: Vars.pm,v 1.4 2010/10/28 14:54:38 espie Exp $
d29 3
a31 1
	my ($class, $core, $shell, $ports, $make, $subdirs, @@args) = @@_;
d45 1
a45 1
		exec {$make} ('make', @@args);
d101 1
a101 1
	my ($class, $core, $ports, $make, $subdirs, $dpb) = @@_;
d106 1
a106 1
		$class->run_command($core, $shell, $ports, $make, $subdirs,
d113 2
a114 3
	my ($class, $core, $ports, $make, $subdirs, $log, $logger, $dpb, 
	    $code) = @@_;
	$class->run_pipe($core, $ports, $make, $subdirs, $dpb);
d135 2
a136 1
			open my $quicklog,  '>>', $logger->log_pkgpath($dir);
d164 21
@


1.4
log
@keep the output from dump-vars around, and save it in the logfile is
something bad happens.

get rid of special reporter for Vars, E= is enough, people should look
in the paths/logfile now.
@
text
@d2 1
a2 1
# $OpenBSD: Vars.pm,v 1.3 2010/10/28 10:33:20 espie Exp $
d20 28
d50 2
d97 1
a97 1
sub subdirlist
d99 8
a106 2
	my ($class, $list) = @@_;
	return join(' ', sort @@$list);
d113 1
a113 21
	$core->start_pipe(sub {
		my $shell = shift;
		close STDERR;
		open STDERR, '>&STDOUT' or die "bad redirect";
		my @@args = ('dump-vars', "DPB=$dpb", "BATCH=Yes", "REPORT_PROBLEM=:");
		if (defined $shell) {
			my $s='';
			if (defined $subdirs) {
				$s="SUBDIR='".$class->subdirlist($subdirs)."'";
			}
			$shell->run("cd $ports && $s ".
			    join(' ', $shell->make, @@args));
		} else {
			if (defined $subdirs) {
				$ENV{SUBDIR} = $class->subdirlist($subdirs);
			}
			chdir($ports) or die "Bad directory $ports";
			exec {$make} ('make', @@args);
		}
		exit(1);
	}, "LISTING");
@


1.3
log
@make it possible (simple) to rescan broken directories
(we should possibly log the error messages).
Forgot to reset broken, so rescanning didn't help...
@
text
@d2 1
a2 1
# $OpenBSD: Vars.pm,v 1.2 2010/10/26 15:45:09 espie Exp $
a22 17
my @@errors = ();
my $last_errors = 0;

sub report
{
	return join('', @@errors);
}

sub important
{
	my $class = shift;
	if (@@errors > $last_errors) {
		$last_errors = @@errors;
		return $class->report;
	}
}

d75 2
a76 1
	my ($class, $core, $ports, $make, $subdirs, $log, $dpb, $code) = @@_;
d110 1
d112 1
d118 2
a119 1
			push(@@errors, "Problem in ".$dir->fullpkgpath."\n");
d122 1
@


1.2
log
@rework PkgPath to distinguish between empty and default flavors...

turns out we probably don't need FULLSUBDIR after all.
compute SUBDIR better, possibly with quotes.
Remove trailing / on subdirs, in case people use completion.
@
text
@d2 1
a2 1
# $OpenBSD$
d95 2
d129 4
a132 1
			push(@@errors, "Problem in $1\n");
@


1.1
log
@Initial revision
@
text
@d2 1
a2 1
# $OpenBSD: Vars.pm,v 1.4 2010/07/14 14:34:34 espie Exp $
d84 6
d99 1
a99 1
				$s="SUBDIR='".join(' ', sort @@$subdirs)."'";
d105 1
a105 1
				$ENV{SUBDIR} = join(' ', sort @@$subdirs);
d142 1
a142 1
			my $info = DPB::PortInfo->new($o, $subdir);
@


1.1.1.1
log
@move stuff here from infra/build
@
text
@@
