head	1.76;
access;
symbols
	OPENBSD_6_1:1.75.0.4
	OPENBSD_6_1_BASE:1.75
	OPENBSD_6_0:1.75.0.2
	OPENBSD_6_0_BASE:1.75
	OPENBSD_5_9:1.72.0.2
	OPENBSD_5_9_BASE:1.72
	OPENBSD_5_8:1.72.0.4
	OPENBSD_5_8_BASE:1.72
	OPENBSD_5_7:1.63.0.4
	OPENBSD_5_7_BASE:1.63
	OPENBSD_5_6:1.63.0.2
	OPENBSD_5_6_BASE:1.63
	OPENBSD_5_5:1.62.0.2
	OPENBSD_5_5_BASE:1.62
	OPENBSD_5_4:1.54.0.2
	OPENBSD_5_4_BASE:1.54
	OPENBSD_5_3:1.49.0.2
	OPENBSD_5_3_BASE:1.49
	OPENBSD_5_2:1.42.0.2
	OPENBSD_5_2_BASE:1.42
	OPENBSD_5_1_BASE:1.34
	OPENBSD_5_1:1.34.0.2
	OPENBSD_5_0:1.12.0.2
	OPENBSD_5_0_BASE:1.12;
locks; strict;
comment	@# @;


1.76
date	2017.05.07.16.50.22;	author espie;	state Exp;
branches;
next	1.75;
commitid	BDH0KYoEzNiBim7E;

1.75
date	2016.05.21.12.20.10;	author espie;	state Exp;
branches;
next	1.74;
commitid	0f89fFEtAu709Kh2;

1.74
date	2016.05.18.06.35.38;	author espie;	state Exp;
branches;
next	1.73;
commitid	KgaDrgY4lvtcGoRU;

1.73
date	2016.04.26.17.19.41;	author espie;	state Exp;
branches;
next	1.72;
commitid	W314TWfD9ovkE9vw;

1.72
date	2015.06.17.07.31.44;	author espie;	state Exp;
branches;
next	1.71;
commitid	96vZMPnFTGFjJ8ne;

1.71
date	2015.05.17.20.39.45;	author espie;	state Exp;
branches;
next	1.70;
commitid	Vtg5IWQQNBZK3e39;

1.70
date	2015.05.16.10.52.19;	author espie;	state Exp;
branches;
next	1.69;
commitid	y1Lc2p29jtDEL6Ho;

1.69
date	2015.05.06.09.17.28;	author espie;	state Exp;
branches;
next	1.68;
commitid	lxZZrN1VJ6HSfctA;

1.68
date	2015.05.03.10.33.59;	author espie;	state Exp;
branches;
next	1.67;
commitid	lBfNuZOkyaPdWlyt;

1.67
date	2015.05.02.09.44.40;	author espie;	state Exp;
branches;
next	1.66;
commitid	1VP4TYxT74T6B9km;

1.66
date	2015.04.30.21.43.28;	author espie;	state Exp;
branches;
next	1.65;
commitid	VfgA0yo5wm1KqQkU;

1.65
date	2015.04.29.13.28.36;	author espie;	state Exp;
branches;
next	1.64;
commitid	hGxkUYr0sUVrcSMH;

1.64
date	2015.04.27.13.32.57;	author espie;	state Exp;
branches;
next	1.63;
commitid	OZaepSq8a1Uo1Af9;

1.63
date	2014.03.17.10.48.40;	author espie;	state Exp;
branches;
next	1.62;

1.62
date	2013.12.02.21.01.43;	author rpe;	state Exp;
branches;
next	1.61;

1.61
date	2013.10.25.13.40.42;	author espie;	state Exp;
branches;
next	1.60;

1.60
date	2013.10.17.18.09.41;	author espie;	state Exp;
branches;
next	1.59;

1.59
date	2013.10.06.13.33.30;	author espie;	state Exp;
branches;
next	1.58;

1.58
date	2013.09.21.08.44.32;	author espie;	state Exp;
branches;
next	1.57;

1.57
date	2013.09.18.21.50.12;	author espie;	state Exp;
branches;
next	1.56;

1.56
date	2013.09.18.13.26.39;	author espie;	state Exp;
branches;
next	1.55;

1.55
date	2013.09.16.11.23.50;	author espie;	state Exp;
branches;
next	1.54;

1.54
date	2013.06.21.09.05.18;	author espie;	state Exp;
branches;
next	1.53;

1.53
date	2013.06.16.13.17.35;	author espie;	state Exp;
branches;
next	1.52;

1.52
date	2013.06.15.20.06.50;	author espie;	state Exp;
branches;
next	1.51;

1.51
date	2013.05.08.08.38.37;	author espie;	state Exp;
branches;
next	1.50;

1.50
date	2013.03.08.10.42.01;	author espie;	state Exp;
branches;
next	1.49;

1.49
date	2013.02.02.09.02.11;	author espie;	state Exp;
branches;
next	1.48;

1.48
date	2013.01.28.12.23.45;	author espie;	state Exp;
branches;
next	1.47;

1.47
date	2013.01.28.10.50.46;	author espie;	state Exp;
branches;
next	1.46;

1.46
date	2013.01.13.14.03.20;	author espie;	state Exp;
branches;
next	1.45;

1.45
date	2013.01.10.12.00.38;	author espie;	state Exp;
branches;
next	1.44;

1.44
date	2013.01.05.16.10.18;	author espie;	state Exp;
branches;
next	1.43;

1.43
date	2012.08.15.09.02.52;	author espie;	state Exp;
branches;
next	1.42;

1.42
date	2012.07.20.11.45.33;	author espie;	state Exp;
branches;
next	1.41;

1.41
date	2012.07.04.08.59.10;	author espie;	state Exp;
branches;
next	1.40;

1.40
date	2012.04.10.16.50.33;	author espie;	state Exp;
branches;
next	1.39;

1.39
date	2012.04.02.09.21.18;	author espie;	state Exp;
branches;
next	1.38;

1.38
date	2012.03.22.16.09.37;	author espie;	state Exp;
branches;
next	1.37;

1.37
date	2012.02.21.10.37.26;	author espie;	state Exp;
branches;
next	1.36;

1.36
date	2012.02.20.16.38.23;	author espie;	state Exp;
branches;
next	1.35;

1.35
date	2012.02.17.07.36.09;	author espie;	state Exp;
branches;
next	1.34;

1.34
date	2012.01.31.15.45.19;	author espie;	state Exp;
branches;
next	1.33;

1.33
date	2012.01.30.14.19.30;	author espie;	state Exp;
branches;
next	1.32;

1.32
date	2012.01.29.12.02.20;	author espie;	state Exp;
branches;
next	1.31;

1.31
date	2012.01.23.10.35.38;	author espie;	state Exp;
branches;
next	1.30;

1.30
date	2012.01.18.15.26.49;	author espie;	state Exp;
branches;
next	1.29;

1.29
date	2012.01.16.18.55.35;	author espie;	state Exp;
branches;
next	1.28;

1.28
date	2012.01.14.12.26.21;	author espie;	state Exp;
branches;
next	1.27;

1.27
date	2012.01.10.19.35.36;	author espie;	state Exp;
branches;
next	1.26;

1.26
date	2012.01.09.17.56.28;	author espie;	state Exp;
branches;
next	1.25;

1.25
date	2012.01.08.20.28.37;	author espie;	state Exp;
branches;
next	1.24;

1.24
date	2012.01.05.21.49.52;	author espie;	state Exp;
branches;
next	1.23;

1.23
date	2012.01.01.18.34.35;	author espie;	state Exp;
branches;
next	1.22;

1.22
date	2011.12.31.11.20.00;	author espie;	state Exp;
branches;
next	1.21;

1.21
date	2011.12.04.12.05.41;	author espie;	state Exp;
branches;
next	1.20;

1.20
date	2011.12.04.10.39.52;	author espie;	state Exp;
branches;
next	1.19;

1.19
date	2011.12.03.11.10.48;	author espie;	state Exp;
branches;
next	1.18;

1.18
date	2011.11.06.16.56.23;	author espie;	state Exp;
branches;
next	1.17;

1.17
date	2011.10.15.10.35.41;	author espie;	state Exp;
branches;
next	1.16;

1.16
date	2011.09.27.17.12.56;	author espie;	state Exp;
branches;
next	1.15;

1.15
date	2011.09.13.09.46.53;	author espie;	state Exp;
branches;
next	1.14;

1.14
date	2011.08.30.17.44.28;	author espie;	state Exp;
branches;
next	1.13;

1.13
date	2011.08.29.09.45.29;	author espie;	state Exp;
branches;
next	1.12;

1.12
date	2011.07.14.11.03.49;	author espie;	state Exp;
branches;
next	1.11;

1.11
date	2011.06.04.12.58.24;	author espie;	state Exp;
branches;
next	1.10;

1.10
date	2011.06.02.17.09.25;	author espie;	state Exp;
branches;
next	1.9;

1.9
date	2011.05.29.11.06.23;	author espie;	state Exp;
branches;
next	1.8;

1.8
date	2011.05.27.13.13.43;	author espie;	state Exp;
branches;
next	1.7;

1.7
date	2011.05.27.10.27.50;	author espie;	state Exp;
branches;
next	1.6;

1.6
date	2011.05.23.09.44.05;	author espie;	state Exp;
branches;
next	1.5;

1.5
date	2011.05.22.09.19.08;	author espie;	state Exp;
branches;
next	1.4;

1.4
date	2011.05.22.09.06.49;	author espie;	state Exp;
branches;
next	1.3;

1.3
date	2011.05.22.09.01.27;	author espie;	state Exp;
branches;
next	1.2;

1.2
date	2011.05.22.08.21.39;	author espie;	state Exp;
branches;
next	1.1;

1.1
date	2011.03.22.19.48.01;	author espie;	state Exp;
branches;
next	;


desc
@@


1.76
log
@filter any distfile name thru a normalize function, so that comparisons
are more accurate and we can get normal unix filesystem semantics.
@
text
@# ex:ts=8 sw=4:
# $OpenBSD: Fetch.pm,v 1.75 2016/05/21 12:20:10 espie Exp $
#
# Copyright (c) 2010-2013 Marc Espie <espie@@openbsd.org>
#
# Permission to use, copy, modify, and distribute this software for any
# purpose with or without fee is hereby granted, provided that the above
# copyright notice and this permission notice appear in all copies.
#
# THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
# ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
# OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
use strict;
use warnings;
use DPB::Clock;
use DPB::Distfile;
use OpenBSD::md5;
use DPB::User;

# handles fetch information, if required
package DPB::Fetch;
our @@ISA = (qw(DPB::UserProxy));

sub new
{
	my ($class, $distdir, $logger, $state) = @@_;
	my $o = bless {distdir => $distdir, sha => {}, reverse => {},
	    logger => $logger,
	    known_sha => {}, known_files => {},
	    known_short => {},
	    user => $state->{fetch_user},
	    state => $state,
	    cache => {},
	    build_user => $state->{build_user},
	    fetch_only => $state->{fetch_only}}, $class;
	if (defined $state->{subst}->value('FTP_ONLY')) {
		$o->{ftp_only} = 1;
	}
	if (defined $state->{subst}->value('CDROM_ONLY')) {
		$o->{cdrom_only} = 1;
	}
	my $fh = $o->open('<', "$distdir/distinfo");
	if (defined $fh) {
		print "Reading distinfo...";
		while (<$fh>) {
			if (m/^SHA256\s*\((.*)\) \= (.*)/) {
				next unless -f "$distdir/$1";
				$o->{sha}{$1} = OpenBSD::sha->fromstring($2);
				$o->{reverse}{$2} = $1;
			}
		}
		close $fh;
	}
	print "zap duplicates...";
	# rewrite "more or less" the same info, so we flush duplicates,
	# e.g., keep only most recent checksum seen
	$o->make_path($distdir);
	$fh = $o->open('>', "$distdir/distinfo.new");
	if (defined $fh) {
		for my $k (sort keys %{$o->{sha}}) {
			print $fh "SHA256 ($k) = ", $o->{sha}{$k}->stringize,
			    "\n";
		}
		close ($fh);
	}
	print "Done\n";
	$o->rename("$distdir/distinfo.new", "$distdir/distinfo");
	$o->{log} = $o->open(">>", "$distdir/distinfo");
	DPB::Util->make_hot($o->{log});
	return $o;
}

sub mark_sha
{
	my ($self, $sha, $file) = @@_;

	$self->{known_sha}{$sha}{$file} = 1;

	# next cases are only needed to weed out by_cipher of extra links
	if ($file =~ m/^.*\/([^\/]+)$/) {
		$self->{known_short}{$sha}{$1} = 1;
	}

	# in particular, double / in $sha will vanish thanks to the fs
	my $do = 0;
	if ($sha =~ s/\/\//\//g) {
		$do++;
	}
	if ($sha =~ s/^\///) {
		$do++;
	}
	if ($do) {
		if ($file =~ m/^.*\/([^\/]+)$/) {
			$self->{known_short}{$sha}{$1} = 1;
		} else {
			$self->{known_short}{$sha}{$file} = 1;
		}
	}
}

sub known_file
{
	my ($self, $sha, $file) = @@_;
	$self->mark_sha($sha->stringize, $file);
	$self->{known_file}{$file} = 1;
}

sub run_expire_old
{
	my ($self, $core, $opt_e) = @@_;
	$core->unsquiggle;
	$core->start_job(DPB::Job::Normal->new(
	    sub {
		$self->expire_old;
	    },
	    sub {
		# and we will never need this again
		delete $self->{known_file};
		delete $self->{known_sha};
		delete $self->{known_short};
		if (!$opt_e) {
			$core->mark_ready;
		}
		return 0;
	    }, 
	    "UPDATING DISTFILES HISTORY"));
	return 1;
}

sub parse_old
{
	my ($self, $fh, $fh2) = @@_;
	while (<$fh>) {
		if (my ($ts, $file, $sha) =
		    m/^(\d+)\s+SHA256\s*\((.*)\) \= (.*\=)$/) {
			$file = DPB::Distfile->normalize($file);
			if (!$self->{known_sha}{$sha}{$file}) {
				$self->mark_sha($sha, $file);
				$self->{known_file}{$file} = 1;
				print $fh2 "$ts SHA256 ($file) = $sha\n";
			}
		}
	}
}

sub expire_old
{
	my $self = shift;
	my $ts = time();
	my $distdir = $self->distdir;
	chdir($distdir) or die "can't change to distdir: $!";
	my $fh2 = $self->open(">", "history.new");
	return if !$fh2;
	if (my $fh = $self->open('<', "history")) {
		$self->parse_old($fh, $fh2);
		close $fh;
	}
	while (my ($sha, $file) = each %{$self->{reverse}}) {
		next if $self->{known_sha}{$sha}{$file};
		print $fh2 "$ts SHA256 ($file) = $sha\n";
		$self->{known_file}{$file} = 1;
	}
	for my $special (qw(Makefile distinfo history)) {
		$self->{known_file}{$special} = 1;
	}

	# let's also scan the directory proper
	require File::Find;
	File::Find::find(sub {
		if (-d $_ && 
		    ($File::Find::name eq "./by_cipher" || 
		     $File::Find::name eq "./list" ||
		    $File::Find::name eq "./build-stats")) {
			$File::Find::prune = 1;
			return;
		}
		return unless -f _;
		return if m/\.part$/;
		my $actual = $File::Find::name;
		$actual =~ s/^.\///;
		return if $self->{known_file}{$actual};
		my $sha = OpenBSD::sha->new($_)->stringize;
		print $fh2 "$ts SHA256 ($actual) = $sha\n";
		$self->mark_sha($sha, $actual);
	}, ".");

	my $c = "by_cipher/sha256";
	if (-d $c) {
		# and scan the ciphers as well !
		File::Find::find(sub {
			return unless -f $_;
			if ($File::Find::dir =~ 
			    m/^\.\/by_cipher\/sha256\/..?\/(.*)$/) {
				my $sha = $1;
				return if $self->{known_sha}{$sha}{$_};
				return if $self->{known_short}{$sha}{$_};
				print $fh2 "$ts SHA256 ($_) = ", $sha, "\n";
			}
		}, $c);
	}

	close $fh2;
	$self->rename("history.new", "history");
}

sub forget_cache
{
	my $self = shift;
	$self->{cache} = {};
}

sub distdir
{
	my $self = shift;
	return $self->{distdir};
}

sub read_checksums
{
	my ($self, $filename) = @@_;
	# XXX the fetch user might not have read access there ?
	my $fh = $self->{build_user}->open('<', $filename);
	return if !defined $fh;
	my $r = { size => {}, sha => {}};
	while (<$fh>) {
		if (my ($file, $sz) = m/^SIZE \((.*)\) \= (\d+)$/) {
			$r->{size}{DPB::Distfile->normalize($file)} = $sz;
		} elsif (my ($file2, $sha) = m/^SHA256 \((.*)\) \= (.*)$/) {
			$r->{sha}{DPB::Distfile->normalize($file2)} = 
			    OpenBSD::sha->fromstring($sha);
		}
		# next!
	}
	return $r;
}

sub build_distinfo
{
	my ($self, $h, $mirror) = @@_;
	for my $v (values %$h) {
		my $info = $v->{info};
		next unless defined $info->{DISTFILES} ||
		    defined $info->{PATCHFILES} ||
		    defined $info->{SUPDISTFILES};

		my $dir = $info->{DIST_SUBDIR};
		my $checksum_file = $info->{CHECKSUM_FILE};

		if (!defined $checksum_file) {
			$v->break("No checksum file");
			next;
		}
		$checksum_file = $checksum_file->string;
		# collapse identical checksum files together
		$checksum_file =~ s,/[^/]+/\.\./,/,g;
		$self->{cache}{$checksum_file} //=
		    $self->read_checksums(
			$self->{state}->anchor($checksum_file));
		my $checksums = $self->{cache}{$checksum_file};

		my $files = {};
		my $build = sub {
			my $arg = shift;
			my $site = 'MASTER_SITES';
			my $url;
			if ($arg =~ m/^(.*)\:(\d)$/) {
				$arg = $1;
				$site.= $2;
			}
			if ($arg =~ m/^(.*)\{(.*)\}(.*)$/) {
				$arg = $1 . $3;
				$url = $2 . $3;
			}
			if (!defined $info->{$site}) {
				$v->break("Can't find $site for $arg");
				return;
			}
			return DPB::Distfile->new($arg, $url, $dir,
			    $info->{$site}, $checksums, $v, $self);
		};

		for my $d ((keys %{$info->{DISTFILES}}), (keys %{$info->{PATCHFILES}})) {
			my $file = &$build($d);
			$files->{$file} = $file if defined $file;
		}
		if ($mirror) {
			for my $d (keys %{$info->{SUPDISTFILES}}) {
				my $file = &$build($d);
				$files->{$file} = $file if defined $file;
			}
		}
		for my $k (qw(DIST_SUBDIR CHECKSUM_FILE DISTFILES
		    PATCHFILES SUPDISTFILES MASTER_SITES MASTER_SITES0
		    MASTER_SITES1 MASTER_SITES2 MASTER_SITES3
		    MASTER_SITES4 MASTER_SITES5 MASTER_SITES6
		    MASTER_SITES7 MASTER_SITES8 MASTER_SITES9)) {
		    	delete $info->{$k};
		}
		bless $files, "AddDepends";
		$info->{DIST} = $files;
		if ($self->{cdrom_only} && 
		    defined $info->{PERMIT_PACKAGE_CDROM}) {
			$info->{DISTIGNORE} = 1;
			$info->{IGNORE} //= AddIgnore->new(
				"Distfile not allowed for cdrom");
		} elsif ($self->{ftp_only} &&
		    defined $info->{PERMIT_PACKAGE_FTP}) {
			$info->{DISTIGNORE} = 1;
			$info->{IGNORE} //= AddIgnore->new(
			    "Distfile not allowed for ftp");
		}
	}
}

sub fetch
{
	my ($self, $file, $core, $endcode) = @@_;
	require DPB::Job::Fetch;
	my $job = DPB::Job::Fetch->new($file, $endcode, $self, 
	    $self->{logger});
	$core->start_job($job, $file);
}

1;
@


1.75
log
@keep a global cache of distfile checksum while scanning, allows us to avoid
rescanning the same distfile 50 times...

also display elapsed time at end of build (cosmetic) since that's now trivial
@
text
@d2 1
a2 1
# $OpenBSD: Fetch.pm,v 1.74 2016/05/18 06:35:38 espie Exp $
d134 16
d158 2
a159 12
	my $fh = $self->open('<', "history");
	if ($fh) {
		while (<$fh>) {
			if (m/^\d+\s+SHA256\s*\((.*)\) \= (.*\=)$/) {
				my ($file, $sha) = ($1, $2);
				if (!$self->{known_sha}{$sha}{$file}) {
					$self->mark_sha($sha, $file);
					$self->{known_file}{$file} = 1;
					print $fh2 $_;
				}
			}
		}
d230 5
a234 4
		if (m/^SIZE \((.*)\) \= (\d+)$/) {
			$r->{size}{$1} = $2;
		} elsif (m/^SHA256 \((.*)\) \= (.*)$/) {
			$r->{sha}{$1} = OpenBSD::sha->fromstring($2);
@


1.74
log
@ports like firefox-i18n have huge common distinfo located thru ../distinfo.
let read_checksums normalize the path so they get recognize as one file.
-> parse it once instead of 40 times.
also, remove the old `next if md5/sha1' test, it was always just an
optimization, and becomes a pessimization now that these are gone.
@
text
@d2 1
a2 1
# $OpenBSD: Fetch.pm,v 1.73 2016/04/26 17:19:41 espie Exp $
d37 1
d204 6
a236 1
	my $distinfo = {};
d253 1
a253 1
		$distinfo->{$checksum_file} //=
d256 1
a256 1
		my $checksums = $distinfo->{$checksum_file};
@


1.73
log
@misleading name: anchor works on any path.
distfiles are actually under the chroot, didn't see that because I usually
have my ports tree directly under the root :(
@
text
@d2 1
a2 1
# $OpenBSD: Fetch.pm,v 1.72 2015/06/17 07:31:44 espie Exp $
a216 1
		next if m/^(?:MD5|RMD160|SHA1)/;
a220 2
		} else {
			next;
d222 1
d245 2
@


1.72
log
@cosmetic
@
text
@d2 1
a2 1
# $OpenBSD: Fetch.pm,v 1.71 2015/05/17 20:39:45 espie Exp $
d36 1
d248 2
a249 1
		    $self->read_checksums($checksum_file);
@


1.71
log
@Already run as the correct user, so revert.
run it  in a chdir(distdir) instead, avoids situations
where the original dir is inaccessible by unpriv_user AND
simplifies the code too. What more could you ask for ?
@
text
@d2 1
a2 1
# $OpenBSD: Fetch.pm,v 1.69 2015/05/06 09:17:28 espie Exp $
d218 1
a218 1
			$r->{size}->{$1} = $2;
d220 1
a220 1
			$r->{sha}->{$1} = OpenBSD::sha->fromstring($2);
@


1.70
log
@run this part as the correct user.
avoids situations where dpb is run from a dir inaccessible by unpriv_user
found out by aja@@
@
text
@d137 2
a138 1
	my $fh2 = $self->open(">", "$distdir/history.new");
d140 1
a140 1
	my $fh = $self->open('<', "$distdir/history");
d164 18
a181 20
	$self->run_as(
		sub {
		    require File::Find;
		    File::Find::find(sub {
			    if (-d $_ && 
				($File::Find::name eq "$distdir/by_cipher" || 
				 $File::Find::name eq "$distdir/list" ||
				$File::Find::name eq "$distdir/build-stats")) {
				    $File::Find::prune = 1;
				    return;
			    }
			    return unless -f _;
			    return if m/\.part$/;
			    my $actual = $File::Find::name;
			    $actual =~ s/^\Q$distdir\E\/?//;
			    return if $self->{known_file}{$actual};
			    my $sha = OpenBSD::sha->new($_)->stringize;
			    print $fh2 "$ts SHA256 ($actual) = $sha\n";
			    $self->mark_sha($sha, $actual);
		    }, $distdir);
d183 14
a196 14
		    my $c = "$distdir/by_cipher/sha256";
		    return unless -d $c;
		    # and scan the ciphers as well !
		    File::Find::find(sub {
			    return unless -f $_;
			    if ($File::Find::dir =~ 
				m/^\Q$distdir\E\/by_cipher\/sha256\/..?\/(.*)$/) {
				    my $sha = $1;
				    return if $self->{known_sha}{$sha}{$_};
				    return if $self->{known_short}{$sha}{$_};
				    print $fh2 "$ts SHA256 ($_) = ", $sha, "\n";
			    }
		    }, $c);
		});
d199 1
a199 1
	$self->rename("$distdir/history.new", "$distdir/history");
@


1.69
log
@open distinfo with the correct user, start clamping down on read rights
as well as write rights.
@
text
@d2 1
a2 1
# $OpenBSD: Fetch.pm,v 1.68 2015/05/03 10:33:59 espie Exp $
d163 35
a197 33
	require File::Find;
	File::Find::find(sub {
		if (-d $_ && 
		    ($File::Find::name eq "$distdir/by_cipher" || 
		     $File::Find::name eq "$distdir/list" ||
		    $File::Find::name eq "$distdir/build-stats")) {
			$File::Find::prune = 1;
			return;
		}
		return unless -f _;
		return if m/\.part$/;
		my $actual = $File::Find::name;
		$actual =~ s/^\Q$distdir\E\/?//;
		return if $self->{known_file}{$actual};
		my $sha = OpenBSD::sha->new($_)->stringize;
		print $fh2 "$ts SHA256 ($actual) = $sha\n";
		$self->mark_sha($sha, $actual);
	}, $distdir);

	my $c = "$distdir/by_cipher/sha256";
	if (-d $c) {
		# and scan the ciphers as well !
		File::Find::find(sub {
			return unless -f $_;
			if ($File::Find::dir =~ 
			    m/^\Q$distdir\E\/by_cipher\/sha256\/..?\/(.*)$/) {
				my $sha = $1;
				return if $self->{known_sha}{$sha}{$_};
				return if $self->{known_short}{$sha}{$_};
				print $fh2 "$ts SHA256 ($_) = ", $sha, "\n";
			}
		}, $c);
	}
@


1.68
log
@do a few more things with the correct user
@
text
@d2 1
a2 1
# $OpenBSD: Fetch.pm,v 1.67 2015/05/02 09:44:40 espie Exp $
d36 1
d209 4
a212 2
	my $filename = shift;
	open my $fh, '<', $filename or return;
d246 1
a246 1
		    read_checksums($checksum_file);
@


1.67
log
@move the user handling code to a separate file.
remove "run_as" for open, we can do things directly.

More explicit code on open.
@
text
@d2 1
a2 1
# $OpenBSD: Fetch.pm,v 1.66 2015/04/30 21:43:28 espie Exp $
d68 1
a68 4
	$o->run_as(
	    sub {
		rename("$distdir/distinfo.new", "$distdir/distinfo");
	    });
d197 1
a197 4
	$self->run_as(
	    sub {
		rename("$distdir/history.new", "$distdir/history");
	    });
@


1.66
log
@tweak the tweak
@
text
@d2 1
a2 1
# $OpenBSD: Fetch.pm,v 1.65 2015/04/29 13:28:36 espie Exp $
d22 1
d44 1
a44 1
	if ($fh) {
d60 1
a60 1
	if ($fh) {
@


1.65
log
@a few more "tweak the user" for fetch handling
@
text
@d2 1
a2 1
# $OpenBSD: Fetch.pm,v 1.64 2015/04/27 13:32:57 espie Exp $
d52 1
@


1.64
log
@more or less "the final" dpb pieces for fetching as a separate user.
@
text
@d2 1
a2 1
# $OpenBSD: Fetch.pm,v 1.63 2014/03/17 10:48:40 espie Exp $
d42 2
a43 1
	if (open(my $fh, '<', "$distdir/distinfo")) {
d56 8
a63 5
	File::Path::make_path($distdir);
	open(my $fh, '>', "$distdir/distinfo.new");
	for my $k (sort keys %{$o->{sha}}) {
		print $fh "SHA256 ($k) = ", $o->{sha}{$k}->stringize,
		    "\n";
a64 1
	close ($fh);
d66 5
a70 2
	rename("$distdir/distinfo.new", "$distdir/distinfo");
	open($o->{log}, ">>", "$distdir/distinfo");
d116 1
a116 1
	    	$self->run_as(sub { $self->expire_old; });
d137 4
a140 2
	open my $fh2, ">", "$distdir/history.new" or return;
	if (open(my $fh, '<', "$distdir/history")) {
d198 4
a201 1
	rename("$distdir/history.new", "$distdir/history");
@


1.63
log
@prepare for perl 5.18
- don't bother declaring $_ for while(<>) loops. assume current default
will still work.
- rename variable for readability elsewhere.
@
text
@d2 1
a2 1
# $OpenBSD: Fetch.pm,v 1.62 2013/12/02 21:01:43 rpe Exp $
d25 1
d34 1
d110 1
a110 1
		$self->expire_old;
d297 2
a298 1
	my $job = DPB::Job::Fetch->new($file, $endcode);
@


1.62
log
@adapt to new DISTFILES format filename{url}sufx

ok naddy@@ sthen@@
@
text
@d2 1
a2 1
# $OpenBSD: Fetch.pm,v 1.61 2013/10/25 13:40:42 espie Exp $
a41 1
		my $_;
a130 1
		my $_;
a201 1
	my $_;
@


1.61
log
@split up the fetch code for readability.
don't bother passing logger around, just keep it in the fetch object,
the distfile objects, and use it directly, that's simpler.
@
text
@d2 1
a2 1
# $OpenBSD: Fetch.pm,v 1.60 2013/10/17 18:09:41 espie Exp $
d249 3
a251 3
			if ($arg =~ m/^(.*)\{(.*)\}$/) {
				$arg = $1;
				$url = $2;
@


1.60
log
@for running !chroot'd stuff, create a modifier for the shell.
Note this modifier must come first for localhost !
@
text
@d2 1
a2 1
# $OpenBSD: Fetch.pm,v 1.59 2013/10/06 13:33:30 espie Exp $
d19 2
a21 337
use DPB::Clock;

package DPB::Distfile;

# same distfile may exist in several ports.

my $cache = {};

sub create
{
	my ($class, $file, $short, $site, $distinfo, $v, $repo) = @@_;

	my $sz = $distinfo->{size}{$file};
	my $sha = $distinfo->{sha}{$file};
	if (!defined $sz || !defined $sha) {
		$v->break("Incomplete info for $file");
		return;
	}
	$repo->known_file($sha, $file);
	bless {
		name => $file,
		short => $short,
		sz => $sz,
		sha => $sha,
		site => $site,
		path => $v,
		repo => $repo,
	}, $class;
}

sub distdir
{
	my ($self, @@rest) = @@_;
	return join('/', $self->{repo}->distdir, @@rest);
}

sub debug_dump
{
	my $self = shift;
	my $msg = $self->logname;
	if ($self->{okay}) {
		$msg .= "(okay)";
	}
}

sub cached
{
	my $self = shift;
	return $self->{repo}{sha};
}

sub new
{
	my ($class, $file, $url, $dir, @@r) = @@_;
	my $full = (defined $dir) ? join('/', $dir->string, $file) : $file;
	if (!defined $url) {
		$url = $file;
	}
	$cache->{$full} //= $class->create($full, $url, @@r);
}

sub logname
{
	my $self = shift;
	return $self->{path}->fullpkgpath.":".$self->{name};
}

sub lockname
{
	return shift->{name}.".dist";
}

sub simple_lockname
{
	&lockname;
}

# should be used for rebuild_info and logging only

sub fullpkgpath
{
	return shift->{path}->fullpkgpath;
}

sub print_parent
{
	my ($self, $fh) = @@_;
	$self->{path}->print_parent($fh);
}

sub pkgpath_and_flavors
{
	return shift->{path}->pkgpath_and_flavors;
}

sub tempfilename
{
	my $self = shift;
	return $self->filename.".part";
}

sub filename
{
	my $self = shift;
	return $self->distdir($self->{name});
}

# this is the entry point from the Engine, this is run as soon as the path
# has been scanned. For performance reasons, we cannot run a sha at that point.
sub check
{
	my ($self, $logger) = @@_;
	# XXX in fetch_only mode, we won't build anything, so this is
	# the only place we can check the file is okay
	if ($self->{repo}->{fetch_only}) {
		return $self->checksum_and_cache($logger, $self->filename);
	} else {
		return $self->checkcache_or_size($logger, $self->filename);
	}
}

sub make_link
{
	my $self = shift;
	my $sha = $self->{sha}->stringize;
	if ($sha =~ m/^(..)/) {
		my $result = $self->distdir('by_cipher', 'sha256', $1, $sha);
		File::Path::make_path($result);
		my $dest = $self->{name};
		$dest =~ s/^.*\///;
		link $self->filename, "$result/$dest";
	}
}

sub find_copy
{
	my ($self, $name) = @@_;

	# sha256 must match AND size as well
	my $alternate = $self->{repo}{reverse}{$self->{sha}->stringize};
	if (defined $alternate) {
		my $full = $self->distdir($alternate);
		if ((stat $full)[7] == $self->{sz}) {
			unlink($name);
			if (link($full, $name)) {
				$self->do_cache;
				$self->{okay} = 1;
				return 1;
			}
		}
	}
	return 0;
}

sub checkcache_or_size
{
	my ($self, $logger, $name) = @@_;
	# XXX if we matched once, then we match "forever"
	return 1 if $self->{okay};
	if (defined $self->cached->{$self->{name}}) {
		return $self->checkcached($logger, $name);
	}
	return $self->checksize($logger, $name);
}

sub checksize
{
	my ($self, $logger, $name) = @@_;
	# XXX if we matched once, then we match "forever"
	return 1 if $self->{okay};
	if ($self->{sz} == 0) {
		my $fh = $logger->open('dist/'.$self->{name});
		print $fh "incomplete distinfo: no size\n";
	}
		
	if (!stat $name) {
		return $self->find_copy($name);
	}
	if ((stat _)[7] != $self->{sz}) {
		my $fh = $logger->open('dist/'.$self->{name});
		print $fh "size does not match\n";
		return 0;
	}
	return 1;
}

sub checkcached
{
	my ($self, $logger, $name) = @@_;
	if (!defined $self->{sha}) {
		my $fh = $logger->open('dist/'.$self->{name});
		print $fh "incomplete distinfo: no sha\n";
		return 0;
	}
	if ($self->cached->{$self->{name}}->equals($self->{sha})) {
		$self->{okay} = 1;
		return 1;
	} else {
		delete $self->cached->{$self->{name}};
		my $fh = $logger->open('dist/'.$self->{name});
		print $fh "sha cache info does not match,";
		if ($self->caches_okay($name)) {
			print $fh "but actual file had the right sha\n";
			return 1;
		} else {
			print $fh "and actual file was wrong, deleted\n";
			return 0;
		}
	}
}

sub do_cache
{
	my $self = shift;

	eval {
	$self->make_link;
	print {$self->{repo}->{log}} "SHA256 ($self->{name}) = ",
	    $self->{sha}->stringize, "\n";
	};
	# also enter ourselves into the internal repository
	$self->cached->{$self->{name}} = $self->{sha};
}

# this is where we actually enter new files in the cache, when they do match.
sub caches_okay
{
	my ($self, $name) = @@_;
	if (-f -r $name) {
		if (OpenBSD::sha->new($name)->equals($self->{sha})) {
			$self->{okay} = 1;
			$self->do_cache;
			return 1;
		} else {
			unlink($name);
		}
	}
	return 0;
}

sub checksum_and_cache
{
	my ($self, $logger, $name) = @@_;
	# XXX if we matched once, then we match "forever"
	return 1 if $self->{okay};
	if (!defined $self->{sha}) {
		return 0;
	}
	if (defined $self->cached->{$self->{name}}) {
		return $self->checkcached($logger, $name);
	}
	if ($self->caches_okay($name)) {
		return 1;
	}
	return $self->find_copy($name);
}

sub cache
{
	my $self = shift;
	# XXX if we matched once, then we match "forever"
	return 1 if $self->{okay};
	$self->{okay} = 1;
	# already done
	if (defined $self->cached->{$self->{name}}) {
		if ($self->cached->{$self->{name}}->equals($self->{sha})) {
			return;
		}
	}
	$self->do_cache;
}

sub checksum
{
	my ($self, $name) = @@_;
	# XXX if we matched once, then we match "forever"
	return 1 if $self->{okay};
	print "checksum for $name: ";
	if (!defined $self->{sha}) {
		print "NONE\n";
		return 0;
	}
	if (defined $self->cached->{$self->{name}}) {
		if ($self->cached->{$self->{name}}->equals($self->{sha})) {
			print "OK (cached)\n";
			$self->{okay} = 1;
			return 1;
		}
	}
	if ($self->caches_okay($name)) {
		print "OK\n";
		return 1;
	}
	print "BAD\n";
	return 0;
}

sub cached_checksum
{
	my ($self, $fh, $name) = @@_;
	# XXX if we matched once, then we match "forever"
	return 1 if $self->{okay};
	print $fh "checksum for $name: ";
	if (!defined $self->{sha}) {
		print $fh "NONE\n";
		return 0;
	}
	if (defined $self->cached->{$self->{name}}) {
		if ($self->cached->{$self->{name}}->equals($self->{sha})) {
			print $fh "OK (cached)\n";
			$self->{okay} = 1;
			return 1;
		}
	}
	print $fh "UNKNOWN (uncached)\n";
	return 0;
}

sub unlock_conditions
{
	my ($self, $engine) = @@_;
	return $self->check($engine->{logger});
}

sub requeue
{
	my ($v, $engine) = @@_;
	$engine->requeue_dist($v);
}

sub forget
{
	my $self = shift;
	delete $self->{size};
	delete $self->{sha};
	delete $self->{okay};
}
d30 1
d296 3
a298 2
	my ($self, $logger, $file, $core, $endcode) = @@_;
	my $job = DPB::Job::Fetch->new($logger, $file, $endcode);
a299 216
}

package DPB::Task::Checksum;
our @@ISA = qw(DPB::Task::Fork);

sub new
{
	my ($class, $fetcher, $status) = @@_;
	bless {fetcher => $fetcher, fetch_status => $status}, $class;
}

sub run
{
	my ($self, $core) = @@_;
	my $job = $core->job;
	$self->redirect_fh($job->{logfh}, $job->{log});
	exit(!$job->{file}->checksum($job->{file}->tempfilename));
}

sub finalize
{
	my ($self, $core) = @@_;
	$self->SUPER::finalize($core);
	my $job = $core->job;
	if ($core->{status} != 0) {
		# XXX if we continued, and it failed, then maybe we
		# got a stupid error message instead, so retry for
		# full size.
		if (defined $self->{fetcher}->{initial_sz}) {
			unlink($job->{file}->tempfilename);
		} else {
			shift @@{$job->{sites}};
		}
		return $job->bad_file($self->{fetcher}, $core);
	}
	rename($job->{file}->tempfilename, $job->{file}->filename);
	print {$job->{logfh}} "Renamed to ", $job->{file}->filename, "\n";
	$job->{file}->cache;
	my $sz = $job->{file}->{sz};
	if (defined $self->{fetcher}->{initial_sz}) {
		$sz -= $self->{fetcher}->{initial_sz};
	}
	my $fh = $job->{logger}->open("fetch/good");
	my $elapsed = $self->{fetcher}->elapsed;
	print $fh $self->{fetcher}{site}.$job->{file}->{short}, " in ",
	    $elapsed, "s ";
	if ($elapsed != 0) {
		print $fh "(", sprintf("%.2f", $sz / $elapsed / 1024), "KB/s)";
	}
	print $fh "\n";
	close $fh;
	return 1;
}

# Fetching stuff is almost a normal job
package DPB::Task::Fetch;
our @@ISA = qw(DPB::Task::Clocked);

sub stopped_clock
{
	my ($self, $gap) = @@_;
	# note that we're missing time
	$self->{got_suspended}++;
	$self->SUPER::stopped_clock($gap);
}

sub new
{
	my ($class, $job) = @@_;
	if (@@{$job->{sites}}) {
		my $o = bless { site => $job->{sites}[0]}, $class;
		my $sz = (stat $job->{file}->tempfilename)[7];
		if (defined $sz) {
			$o->{initial_sz} = $sz;
		}
		return $o;
	} else {
		undef;
	}
}

sub run
{
	my ($self, $core) = @@_;
	my $job = $core->job;
	my $shell = $core->shell;
	my $site = $self->{site};
	$self->redirect($job->{log});
	if ($job->{file}{sz} == 0) {
		print STDERR "No size in distinfo\n";
		exit(1);
	}
	my $ftp = OpenBSD::Paths->ftp;
	$self->redirect($job->{log});
	my @@cmd = ('-C', '-o', $job->{file}->tempfilename, '-v',
	    $site.$job->{file}->{short});
	if ($ftp =~ /\s/) {
		unshift @@cmd, split(/\s+/, $ftp);
	} else {
		unshift @@cmd, $ftp;
	}
	print STDERR "===> Trying $site\n";
	print STDERR join(' ', @@cmd), "\n";
	# run ftp;
	$core->shell->nochroot->exec(@@cmd);
}

sub finalize
{
	my ($self, $core) = @@_;
	$self->SUPER::finalize($core);
	my $job = $core->job;
	if ($job->{file}->checksize($job->{logger},
	    $job->{file}->tempfilename)) {
	    	$job->new_checksum_task($self, $core->{status});
	} else {
		if ($job->{file}->{sz} == 0) {
			$job->{sites} = [];
			return $job->bad_file($self, $core);
		}
		# Fetch exited okay, but the file is not the right size
		if ($core->{status} == 0 ||
		# definite error also if file is too large
		    stat($job->{file}->tempfilename) &&
		    (stat _)[7] > $job->{file}->{sz}) {
			unlink($job->{file}->tempfilename);
		}
		# if we got suspended, well, might have to retry same site
		if (!$self->{got_suspended}) {
			shift @@{$job->{sites}};
		}
		return $job->bad_file($self, $core);
	}
}

package DPB::Job::Fetch;
our @@ISA = qw(DPB::Job::Normal);

use File::Path;
use File::Basename;

sub new_fetch_task
{
	my $self = shift;
	my $task = DPB::Task::Fetch->new($self);
	if ($task) {
		push(@@{$self->{tasks}}, $task);
		$self->{tries}++;
		return 1;
	} else {
		return 0;
	}
}

sub bad_file
{
	my ($job, $task, $core) = @@_;
	my $fh = $job->{logger}->open("fetch/bad");
	print $fh $task->{site}.$job->{file}->{short}, "\n";
	if ($job->new_fetch_task) {
		$core->{status} = 0;
		return 1;
	} else {
		$core->{status} = 1;
		return 0;
	}
}

sub new_checksum_task
{
	my ($self, $fetcher, $status) = @@_;
	push(@@{$self->{tasks}}, DPB::Task::Checksum->new($fetcher, $status));
}

sub new
{
	my ($class, $logger, $file, $e) = @@_;
	my $job = bless {
		sites => [@@{$file->{site}}],
		file => $file,
		tasks => [],
		endcode => $e,
		logger => $logger,
		log => $logger->make_distlogs($file),
	}, $class;
	open $job->{logfh}, '>>', $job->{log};
	print {$job->{logfh}} ">>> From ", $file->fullpkgpath, "\n";
	File::Path::mkpath(File::Basename::dirname($file->filename));
	$job->{watched} = DPB::Watch->new($file->tempfilename,
		$file->{sz}, undef, $job->{started});
	$job->new_fetch_task;
	return $job;
}

sub name
{
	my $self = shift;
	return '<'.$self->{file}->{name}."(#".$self->{tries}.")";
}

sub watched
{
	my ($self, $current, $core) = @@_;
	my $w = $self->{watched};
	my $diff = $w->check_change($current);
	my $msg = $w->percent_message . $w->frozen_message($diff);
	my $to = $core->fetch_timeout;
	if (defined $to) {
		if ($diff > $to) {
			$self->{stuck} =
			    "KILLED: $self->{current} stuck at $msg";
			kill 9, $core->{pid};
			return $self->{stuck};
		}
	}
	return $msg;
@


1.59
log
@update my copyright to 2013
@
text
@d2 1
a2 1
# $OpenBSD: Fetch.pm,v 1.58 2013/09/21 08:44:32 espie Exp $
d737 1
a737 1
	$core->shell->exec(@@cmd);
@


1.58
log
@introduce squiggles: special cores used for building small ports.
each host takes care of keeping its squiggles "alive". This may
include moving the squiggle property when the core gets swallowed,
and making sure listing/fetch/update distinfo cores are not squiggles.
@
text
@d2 1
a2 1
# $OpenBSD: Fetch.pm,v 1.57 2013/09/18 21:50:12 espie Exp $
d4 1
a4 1
# Copyright (c) 2010 Marc Espie <espie@@openbsd.org>
@


1.57
log
@fix typo
@
text
@d2 1
a2 1
# $OpenBSD: Fetch.pm,v 1.56 2013/09/18 13:26:39 espie Exp $
d440 1
@


1.56
log
@leaner messages: don't show percent on tasks where it doesn't make sense.
replace "unchanged for 28 seconds" by "frozen for 28s"

remove frozen message for "waiting-for-lock" entirely... there's already
a depend/junk task that shows this clearly, and the message tends to be
WAY too long anyways.
@
text
@d2 1
a2 1
# $OpenBSD: Fetch.pm,v 1.55 2013/09/16 11:23:50 espie Exp $
d837 1
a837 1
	my $msg = $w->progress_message . $w->frozen_message($diff);
@


1.55
log
@move the shell running code up to host. Makes no sense to have the same
data structure for each Core, and a lot of this is actually tied to the
host proper.

(note that Core::Distant no longer makes a lot of sense)
@
text
@d2 1
a2 1
# $OpenBSD: Fetch.pm,v 1.54 2013/06/21 09:05:18 espie Exp $
d835 3
a837 2
	my $diff = $self->{watched}->check_change($current);
	my $msg = $self->{watched}->change_message($diff);
@


1.54
log
@disentangle the config/init code from the rest.

- move the meat of handle_options from dpb into config->parse_command_line
(this means a backcall to still inherit from OpenBSD::State).
- move parse_config_files from core into config.
- move the prop handling into proper HostProperties (part of config
obviously)
- create a Core::Init file that contains all the former DPB::Host::Factory
and associated jobs.

there's still a wee little bit of cleanup to do, but this should be
easier to maintain, as all option handling is now in one place, and
startup and host confi is now easier to figure out.

- add a -DMIRROR=0/1  setup that controls whether SUPDISTFILES will be
fetched (defaults to 1 for -F and 0 for -f).

- actually allow for several host files to be parsed, as the name implies
@
text
@d2 1
a2 1
# $OpenBSD: Fetch.pm,v 1.53 2013/06/16 13:17:35 espie Exp $
d717 1
a717 1
	my $shell = $core->{shell};
@


1.53
log
@use redirect_fh.
add an extra unconfusing message, to say we renamed the file after it
checksummed okay.
@
text
@d2 1
a2 1
# $OpenBSD: Fetch.pm,v 1.52 2013/06/15 20:06:50 espie Exp $
d553 1
a553 1
	my ($self, $h, $fetch_only) = @@_;
d598 1
a598 1
		if ($fetch_only) {
@


1.52
log
@zap complicated bogus logic,
fetch+immediate build should work much better now.
@
text
@d2 1
a2 1
# $OpenBSD: Fetch.pm,v 1.51 2013/05/08 08:38:37 espie Exp $
d647 1
a647 1
	$self->redirect($job->{log});
d668 1
d817 2
a818 4
	if (open my $fh, '>>', $job->{log}) {
		print $fh ">>> From ", $file->fullpkgpath, "\n";
		close $fh;
	}
@


1.51
log
@revisit old codes, rewrite DISTFILES handling using
.for v1 v2 in list
techniques, which make it clearer.

Add new syntax to distfiles, which is not painful to do now, and support it
for dpb fetch as well: a distfile can now be file{url} to specify a different
result from the url (this allows really weird naming scheme on http sites
to give us consistent files, which has become a nagging problem).

This still doesn't mean you shouldn't encourage upstream to do the right thing
and provide nice archive urls.

extend the fetch process in bsd.port.mk to work more like dpb does, namely
download to intermediate "part" files that don't vanish and use -C if
necessary.

Both those mean that FETCH_CMD has to work like ftp, including the -C and
-o support...

discussed with various people.
@
text
@d2 1
a2 1
# $OpenBSD: Fetch.pm,v 1.50 2013/03/08 10:42:01 espie Exp $
a62 3
	if ($self->{checked}) {
		$msg .= "(checked)";
	}
a126 6
sub checked_already
{
	my $self = shift;
	return $self->{okay} || $self->{checked};
}

a202 1
	$self->{checked} = 1;
d334 1
@


1.50
log
@flesh out trace info for distfiles
@
text
@d2 1
a2 1
# $OpenBSD: Fetch.pm,v 1.49 2013/02/02 09:02:11 espie Exp $
d76 1
a76 1
	my ($class, $file, $dir, @@r) = @@_;
d78 4
a81 1
	$cache->{$full} //= $class->create($full, $file, @@r);
d586 1
d591 4
d599 1
a599 1
			return DPB::Distfile->new($arg, $dir,
@


1.49
log
@gc old method
@
text
@d2 1
a2 1
# $OpenBSD: Fetch.pm,v 1.48 2013/01/28 12:23:45 espie Exp $
d54 12
@


1.48
log
@add a FETCH_TIMEOUT, similar to STUCK_TIMEOUT, but slightly simpler,
as there is no speed factor there...
@
text
@d2 1
a2 1
# $OpenBSD: Fetch.pm,v 1.47 2013/01/28 10:50:46 espie Exp $
a114 6
sub listname
{
	my $self = shift;
	return $self->distdir('list', $self->{name}.".gz");
}

a656 2
	# and remove anything we might have listed
	unlink($job->{file}->listname);
@


1.47
log
@don't bother dumping distfiles, history is quite enough
@
text
@d2 1
a2 1
# $OpenBSD: Fetch.pm,v 1.46 2013/01/13 14:03:20 espie Exp $
d835 9
@


1.46
log
@zap SUPDISTFILES earlier if not needed.
framework to save listings of archives
@
text
@d2 1
a2 1
# $OpenBSD: Fetch.pm,v 1.45 2013/01/10 12:00:38 espie Exp $
a66 9
}

sub dump
{
	my ($class, $logger) = @@_;
	my $log = $logger->create("fetch/distfiles");
	for my $f (sort map {$_->{name}} grep {defined $_} values %$cache) {
		print $log $f, "\n";
	}
@


1.45
log
@there's no need to fork a process if the checksums are all cached
@
text
@d2 1
a2 1
# $OpenBSD: Fetch.pm,v 1.44 2013/01/05 16:10:18 espie Exp $
d124 6
d501 1
d602 3
a604 3
		for my $d (keys %{$info->{SUPDISTFILES}}) {
			my $file = &$build($d);
			if ($fetch_only) {
d672 2
@


1.44
log
@thought I had done this already:
don't blindly append to history, but recreate it from scratch.
We need to remove lines corresponding to stuff that vanished at some
point but came back later!
@
text
@d2 1
a2 1
# $OpenBSD: Fetch.pm,v 1.43 2012/08/15 09:02:52 espie Exp $
d318 20
@


1.43
log
@better messages about caching problems, don't abort if sha info is missing
from distinfo. comment stuff.
(I had this since after the lock, plain forgot to commit it)
@
text
@d2 1
a2 1
# $OpenBSD: Fetch.pm,v 1.42 2012/07/20 11:45:33 espie Exp $
d446 1
d452 5
a456 2
				$self->mark_sha($sha, $file);
				$self->{known_file}{$file} = 1;
a460 1
	open my $fh, ">>", "$distdir/history" or return;
d463 1
a463 1
		print $fh "$ts SHA256 ($file) = $sha\n";
d485 1
a485 1
		print $fh "$ts SHA256 ($actual) = $sha\n";
d499 1
a499 1
				print $fh "$ts SHA256 ($_) = ", $sha, "\n";
d504 2
a505 1
	close $fh;
@


1.42
log
@fix caching issues.

- during the scanning stage, we can rely on more than sizes. Specifically,
for files with cached sha values: detect problems early, zap the files, so
the new ones do fetch.

- do not allow "negative" caching: if the cached file doesn't match, just
run the checksum again to make sure (manual download would tamper with that).
This should allow builders to forget about the existence of
/usr/ports/distfiles/distinfo again.

- remove bad files so that fetch has a chance to work (todo: log some more
info, yeah landry...)

- zap code from (checksum) proper  that's no longer in-use.

okay jasper@@

(gets in because fixing the mirrors for the release is important, and dpb -F
would not do the right thing without manual intervention).
@
text
@d2 1
a2 1
# $OpenBSD: Fetch.pm,v 1.41 2012/07/04 08:59:10 espie Exp $
d130 2
d138 1
a138 1
		return $self->checksum_and_cache($self->filename);
d183 1
a183 1
		return $self->checkcached($name);
d212 6
a217 1
	my ($self, $name) = @@_;
d223 2
d226 1
d228 3
a231 1
		return 0;
d248 1
d266 1
a266 1
	my ($self, $name) = @@_;
d273 1
a273 1
		return $self->checkcached($name);
@


1.41
log
@remove distinction between local and distant running, always create
a shell object that can chdir, setenv, and exec commands.
(note that this executes stuff after fork, so permanent changes are cheap
and okay)

Also create it from "host" objects, which simplifies parameter passing.
@
text
@d2 1
a2 1
# $OpenBSD: Fetch.pm,v 1.40 2012/04/10 16:50:33 espie Exp $
d138 1
a138 1
		return $self->checksize($logger, $self->filename);
d175 11
d208 15
d236 15
d260 1
a260 6
		if ($self->cached->{$self->{name}}->equals($self->{sha})) {
			$self->{okay} = 1;
			return 1;
		} else {
			return 0;
		}
d262 2
a263 8
	if (-f -r $name) {
		if (OpenBSD::sha->new($name)->equals($self->{sha})) {
			$self->{okay} = 1;
			$self->do_cache;
			return 1;
		} else {
			return 0;
		}
a297 3
		} else {
			print "BAD\n";
			return 0;
d300 1
a300 2
	if (-f -r $name && OpenBSD::sha->new($name)->equals($self->{sha})) {
		$self->{okay} = 1;
@


1.40
log
@avoid spewed warnings in case we don't care.
@
text
@d2 1
a2 1
# $OpenBSD: Fetch.pm,v 1.39 2012/04/02 09:21:18 espie Exp $
d659 1
a659 1
	my @@cmd = ($ftp, '-C', '-o', $job->{file}->tempfilename, '-v',
d661 5
d669 1
a669 9
	if (defined $shell) {
		$shell->run(join(' ', @@cmd));
	} else {
		if ($ftp =~ /\s/) {
			exec join(' ', @@cmd);
		} else {
			exec{$ftp} @@cmd;
		}
	}
@


1.39
log
@fix landry's error.

forget was in the wrong class, oops.
@
text
@d2 1
a2 1
# $OpenBSD: Fetch.pm,v 1.38 2012/03/22 16:09:37 espie Exp $
d73 1
a73 1
	for my $f (sort map {$_->{name}} values %$cache) {
@


1.38
log
@ignore build_stats for logging distinfo (and clean-old-distfiles(1)).
@
text
@d2 1
a2 1
# $OpenBSD: Fetch.pm,v 1.37 2012/02/21 10:37:26 espie Exp $
d294 8
a487 8
}

sub forget
{
	my $self = shift;
	delete $self->{size};
	delete $self->{sha};
	delete $self->{okay};
@


1.37
log
@also log the fullpkgpath, no need to go look in the lock proper for that.
@
text
@d2 1
a2 1
# $OpenBSD: Fetch.pm,v 1.36 2012/02/20 16:38:23 espie Exp $
d423 3
a425 1
		if (-d $_ && $_ eq 'by_cipher') {
@


1.36
log
@make sure distdir exists before writing information in there
@
text
@d2 1
a2 1
# $OpenBSD: Fetch.pm,v 1.35 2012/02/17 07:36:09 espie Exp $
d94 1
a94 1
# should be used for rebuild_info only
d751 4
@


1.35
log
@cosmetic: fetches come in, so <
explain waiting time better.
@
text
@d2 1
a2 1
# $OpenBSD: Fetch.pm,v 1.34 2012/01/31 15:45:19 espie Exp $
d324 1
@


1.34
log
@when you never fetched anything after the cipher change, that directory
doesn't exist... don't error out...
@
text
@d2 1
a2 1
# $OpenBSD: Fetch.pm,v 1.33 2012/01/30 14:19:30 espie Exp $
d311 1
d321 1
d330 1
d760 1
a760 1
	return '>'.$self->{file}->{name}."(#".$self->{tries}.")";
@


1.33
log
@Better name for the task that, duh, is actually updating distfiles history.
@
text
@d2 1
a2 1
# $OpenBSD: Fetch.pm,v 1.32 2012/01/29 12:02:20 espie Exp $
d433 14
a446 11
	# and scan the ciphers as well !
	File::Find::find(sub {
		return unless -f $_;
		if ($File::Find::dir =~ 
		    m/^\Q$distdir\E\/by_cipher\/sha256\/..?\/(.*)$/) {
			my $sha = $1;
			return if $self->{known_sha}{$sha}{$_};
			return if $self->{known_short}{$sha}{$_};
			print $fh "$ts SHA256 ($_) = ", $sha, "\n";
		}
	}, "$distdir/by_cipher/sha256");
@


1.32
log
@more flexible error path while scanning, accumulate reasons why broken.
remove a few explicit (and implicit) die from Fetch: missing/out-of-sync
distinfo no longer kill dpb, instead they're properly reported as broken
paths and things still go on (note that even a missing SUPDISTFILE checksum
*will* mark a path as broken, that's totally intentional)
@
text
@d2 1
a2 1
# $OpenBSD: Fetch.pm,v 1.31 2012/01/23 10:35:38 espie Exp $
d386 1
a386 1
	    "CLEAN DIST"));
@


1.31
log
@remove a bit of noise from the log... we checked already, no need to
log it again.
@
text
@d2 1
a2 1
# $OpenBSD: Fetch.pm,v 1.30 2012/01/18 15:26:49 espie Exp $
d32 1
a32 1
	my $sz = $distinfo->{size}{$file} // 0;
d34 4
d457 1
a457 1
	open my $fh, '<', $filename or die "Can't read distinfo $filename";
d467 1
a467 1
			die "Unknown line in $filename: $_";
d495 2
a496 1
			die "No checksum file for ".$v->fullpkgpath;
d512 2
a513 1
				die "Can't find $site for $arg";
d521 1
a521 1
			$files->{$file} = $file;
d526 1
a526 1
				$files->{$file} = $file;
@


1.30
log
@repair dpb -f0
noticed by phessler@@
@
text
@d2 1
a2 1
# $OpenBSD: Fetch.pm,v 1.29 2012/01/16 18:55:35 espie Exp $
d120 6
d163 1
d189 1
@


1.29
log
@also scan by_cipher for old stuff. This requires a bit more logic, as
the names of files in there are not totally trivial to figure out from the
normal filename + sha.
-> filename will be stripped off DIST_SUBDIR
-> b64 checksums interfere with filesystem semantics, e.g., /u8//ffg
will become u8/ffg
@
text
@d2 1
a2 1
# $OpenBSD: Fetch.pm,v 1.28 2012/01/14 12:26:21 espie Exp $
d375 1
@


1.28
log
@add support to obey PERMIT_DISTFILES*
@
text
@d2 1
a2 1
# $OpenBSD: Fetch.pm,v 1.27 2012/01/10 19:35:36 espie Exp $
d290 1
d322 28
d353 1
a353 1
	$self->{known_sha}{$sha->stringize}{$file} = 1;
d368 1
d385 4
a388 3
			if (m/^\d+\s+SHA256\s*\((.*)\) \= (.*)/) {
				$self->{known_sha}{$2}{$1} = 1;
				$self->{known_file}{$1} = 1;
d415 3
a417 2
		my $ck = OpenBSD::sha->new($_);
		print $fh "$ts SHA256 ($actual) = ", $ck->stringize, "\n";
d419 12
@


1.27
log
@remove files from distinfo when they no longer exist, so when you clean
up files and history, it won't recreate fantom stuff...
@
text
@d2 1
a2 1
# $OpenBSD: Fetch.pm,v 1.26 2012/01/09 17:56:28 espie Exp $
d287 1
a287 1
	my ($class, $distdir, $logger, $fetch_only) = @@_;
d290 7
a296 1
	    fetch_only => $fetch_only}, $class;
d479 11
@


1.26
log
@run "expire_old" as a separate job, since it may take some time.
find files under $DISTDIR, anything we don't know about should also
end up in history.
@
text
@d2 1
a2 1
# $OpenBSD: Fetch.pm,v 1.25 2012/01/08 20:28:37 espie Exp $
d295 1
@


1.25
log
@give dpb more knowledge about distfiles.
- keep a stash indexed by checksum, so dpb can identify duplicate files.
- in a full bulk, if the scan has no errors, write to a ${DISTDIR}/history
file  the files encountered in ${DISTDIR}/distinfo that seem to no longer
be needed (with full timestamp and checksum info).

Should be enough info to know when to expire old DISTDIR entries.
@
text
@d2 1
a2 1
# $OpenBSD: Fetch.pm,v 1.24 2012/01/05 21:49:52 espie Exp $
d289 1
a289 1
	    known => {},
d317 21
a337 1
	$self->{known}{$sha->stringize}{$file} = 1;
d344 2
a345 2
	my $extra = {};
	if (open(my $fh, '<', $self->distdir."/history")) {
d349 2
a350 1
				$extra->{$2}{$1} = 1;
d355 1
a355 1
	open my $fh, ">>", $self->distdir."/history" or return;
d357 1
a357 1
		next if $self->{known}{$sha}{$file} or $extra->{$sha}{$file};
d359 1
d361 20
a381 2
	# and we will never need this again
	delete $self->{known};
@


1.24
log
@buglet with links and files with a DIST_SUBDIR, as found by naddy@@.
people already running dpb -F: just remove /usr/ports/distfiles/distinfo
and rerun dpb.
(or at least all entries with a subdirectory)
@
text
@d2 1
a2 1
# $OpenBSD: Fetch.pm,v 1.23 2012/01/01 18:34:35 espie Exp $
d34 1
d48 2
a49 2
	my $self = shift;
	return $self->{repo}->distdir;
d117 1
a117 1
	return $self->distdir."/".$self->{name};
d137 1
a137 1
		my $result = $self->distdir."/by_cipher/sha256/$1/$sha";
d145 19
d175 1
a175 1
		return 0;
d214 8
a221 4
	if (-f -r $name && OpenBSD::sha->new($name)->equals($self->{sha})) {
		$self->{okay} = 1;
		$self->do_cache;
		return 1;
d223 1
a223 1
	return 0;
d288 2
a289 1
	my $o = bless {distdir => $distdir, sha => {}, 
d294 1
a294 1
			if (m/^SHA256 \((.*)\) \= (.*)/) {
d296 1
d312 30
@


1.23
log
@prevent dpb from dying if make_link dies (also does not append to global
distinfo, of course)
@
text
@d2 1
a2 1
# $OpenBSD: Fetch.pm,v 1.22 2011/12/31 11:20:00 espie Exp $
d138 3
a140 1
		link $self->filename, "$result/$self->{name}";
@


1.22
log
@allow the fetcher part to work as a "true" mirror maker:
- keep a cache of checked checksums as ${DISTDIR}/distinfo
- read existing cache on startup, don't need to recheck those files.
- split checksum_task: update the cache after the checksum is done
- create the by_cipher/sha256/... entries
- in fetch_only mode, do a "long" checksum on existing files not in the cache.

If you ever have doubts on the integrity of already checked files, just
rm ${DISTDIR}/distinfo.
@
text
@d2 1
a2 1
# $OpenBSD: Fetch.pm,v 1.21 2011/12/04 12:05:41 espie Exp $
d167 2
d171 1
a171 1
	$self->make_link;
@


1.21
log
@clean-up job running a bit: add methods to Grabber and PortBuilder objects
to access more stuff they need.

Remove distantshell->make, ask state instead.
Provide state with the program we run, and the parameters we pass it.

- same make for distant and local hosts
- pass BUILD_ONCE=Yes if -a.
@
text
@d2 1
a2 1
# $OpenBSD: Fetch.pm,v 1.20 2011/12/04 10:39:52 espie Exp $
d30 1
a30 1
	my ($class, $file, $short, $site, $distinfo, $v, $distdir) = @@_;
d41 1
a41 1
		distdir => $distdir,
d45 12
d116 1
a116 1
	return $self->{distdir}."/".$self->{name};
d122 18
a139 1
	return $self->checksize($logger, $self->filename);
d163 50
d223 11
a233 2
		
	if (OpenBSD::sha->new($name)->equals($self->{sha})) {
d259 29
a287 2
	my ($class, $distdir) = @@_;
	bless {distdir => $distdir}, $class;
d350 1
a350 1
			    $info->{$site}, $checksums, $v, $self->{distdir});
d416 1
@


1.20
log
@properly forget old info when rescanning...
@
text
@d2 1
a2 1
# $OpenBSD: Fetch.pm,v 1.19 2011/12/03 11:10:48 espie Exp $
d313 1
@


1.19
log
@open needed just once.
@
text
@d2 1
a2 1
# $OpenBSD: Fetch.pm,v 1.18 2011/11/06 16:56:23 espie Exp $
d192 8
@


1.18
log
@make sure print_parent gets the correct path
@
text
@d2 1
a2 1
# $OpenBSD: Fetch.pm,v 1.17 2011/10/15 10:35:41 espie Exp $
a110 1

@


1.17
log
@repair rescan for distfiles errors
@
text
@d2 1
a2 1
# $OpenBSD: Fetch.pm,v 1.16 2011/09/27 17:12:56 espie Exp $
d82 6
@


1.16
log
@deal with suspend: connection may time out, so in case of failure, if
we got suspended, try the same site again.
@
text
@d2 1
a2 1
# $OpenBSD: Fetch.pm,v 1.15 2011/09/13 09:46:53 espie Exp $
d82 5
@


1.15
log
@beginning of a fetch-only option that is supposed to replace mirror-maker
eventually.

- fetch all files
- ignore ignores
- specific builder that doesn't look at existing packages

currently: does not stop when  fetch is finished, which is somewhat of the
remaining issue.

Also: change stats to store pid, to make sense of interleaved log files.
@
text
@d2 1
a2 1
# $OpenBSD: Fetch.pm,v 1.14 2011/08/30 17:44:28 espie Exp $
d302 8
d374 4
a377 1
		shift @@{$job->{sites}};
@


1.14
log
@fix thinko
thx nigel@@
@
text
@d2 1
a2 1
# $OpenBSD: Fetch.pm,v 1.13 2011/08/29 09:45:29 espie Exp $
d186 1
a186 1
	my ($self, $h) = @@_;
d225 4
a228 1
			&$build($d);
@


1.13
log
@move missing distinfo into not so fatal error.
@
text
@d2 1
a2 1
# $OpenBSD: Fetch.pm,v 1.12 2011/07/14 11:03:49 espie Exp $
d321 1
a321 1
	if ($self->{sz} == 0) {
@


1.12
log
@code reuse
@
text
@d2 1
a2 1
# $OpenBSD: Fetch.pm,v 1.11 2011/06/04 12:58:24 espie Exp $
d32 1
a32 1
	my $sz = $distinfo->{size}{$file};
a33 6
	if (!defined $sz) {
		die "Incomplete distinfo for $file: missing sz";
	}
	if (!defined $sha) {
		die "Incomplete distinfo for $file: missing sha";
	}
d108 5
d130 5
d320 5
d352 4
@


1.11
log
@spaces
@
text
@d2 1
a2 1
# $OpenBSD$
d93 1
a93 1
	return $self->{distdir}."/".$self->{name}.".part";
@


1.10
log
@- unify code in Fetch/Build subengines
- zap heuristic#3, not critical
- don't rebuild the Fetch queue all the time, it's too expensive
- fix bugs in FetchQueue computation, correctly handle 1 distfile case
- create a quick path thru adjust* that handles only new paths.
- use it during LISTING while fetching files, to make more files available
quicker.
- model distfiles as FDEPENDS, DIST, so that they can get dumped.
- add -v option that dumps a bit more stuff in log files.

with these, dpb will fetch all distfiles in a not too surprising order,
and it won't consume 40% cpu while doing so...
@
text
@d2 1
a2 1
# $OpenBSD: Fetch.pm,v 1.9 2011/05/29 11:06:23 espie Exp $
d186 2
a187 2
		next unless defined $info->{DISTFILES} || 
		    defined $info->{PATCHFILES} || 
d197 1
a197 1
		$distinfo->{$checksum_file} //= 
d202 1
a202 1
		my $build = sub { 
d212 1
a212 1
			return DPB::Distfile->new($arg, $dir, 
d224 3
a226 3
		    PATCHFILES SUPDISTFILES MASTER_SITES MASTER_SITES0 
		    MASTER_SITES1 MASTER_SITES2 MASTER_SITES3 
		    MASTER_SITES4 MASTER_SITES5 MASTER_SITES6 
d318 1
a318 1
	my @@cmd = ($ftp, '-C', '-o', $job->{file}->tempfilename, '-v', 
d339 1
a339 1
	if ($job->{file}->checksize($job->{logger}, 
@


1.9
log
@if we -f -a, then scan SUPBDISTFILES too, and use the Distfile cache
to write a list of all known distfiles, that can be used to remove extra
stuff from /usr/ports/distfiles
@
text
@d2 1
a2 1
# $OpenBSD: Fetch.pm,v 1.8 2011/05/27 13:13:43 espie Exp $
d228 1
a228 1
		    	undef $info->{$k};
d230 2
a231 1
		$info->{distfiles} = $files;
@


1.8
log
@nicer lockname
@
text
@d2 1
a2 1
# $OpenBSD: Fetch.pm,v 1.7 2011/05/27 10:27:50 espie Exp $
d58 9
d187 2
a188 1
		    defined $info->{PATCHFILES};
d202 2
a203 2

		for my $d ((keys %{$info->{DISTFILES}}), (keys %{$info->{PATCHFILES}})) {
d205 2
a206 2
			if ($d =~ m/^(.*)\:(\d)$/) {
				$d = $1;
d210 1
a210 1
				die "Can't find $site for $d";
d212 1
a212 1
			my $file = DPB::Distfile->new($d, $dir, 
d214 4
d220 3
d224 1
a224 1
		    PATCHFILES MASTER_SITES MASTER_SITES0 
@


1.7
log
@start moving the fetch/build code into separate subengine classes, to make
it more obvious how much is shared (goal is to unify a large part of these).

In particular, the locking code/stuff already active is glaringly the same...

Polish the distfiles measurements. For now, 3 heuristics that kick in
at various stages of the build (a bit of black magic).

Fix pkgpath->{has} to record both "no dependencies" and "several distfiles
missing" to avoid grabbing small patchfiles which don't lead to valid
builds while heuristic#1 is active.
@
text
@d2 1
a2 1
# $OpenBSD: Fetch.pm,v 1.6 2011/05/23 09:44:05 espie Exp $
d66 1
a66 1
	return shift->{name}."dist";
@


1.6
log
@improved fetch: do checksum as a separate process, to avoid freezing
dpb while checksumming huge tarballs.
Use ftp -C in a systematic way, more complicated logic as to when to
remove temp files, when to keep them: if core exited okay, wrong size
is very bad. If checksum failed on a partial fetch, retry same site with
an empty file...
@
text
@d2 1
a2 1
# $OpenBSD: Fetch.pm,v 1.5 2011/05/22 09:19:08 espie Exp $
a48 6
}

# a distfile is represented by its pkgpath, yeah.
sub representative
{
	return shift->{path};
@


1.5
log
@only check checksum if we just fetched it, for now.
@
text
@d2 1
a2 1
# $OpenBSD: Fetch.pm,v 1.4 2011/05/22 09:06:49 espie Exp $
d72 1
a72 1
	return shift->{name};
d102 1
a102 1
	return $self->checksum($logger, $self->filename, 1);
d106 1
a106 1
sub checksum
d108 1
a108 1
	my ($self, $logger, $name, $quick) = @@_;
d119 9
a127 1
	return 1 if $quick;
d130 1
d133 1
a133 2
	my $fh = $logger->open('dist/'.$self->{name});
	print $fh "checksum does not match\n";
d140 1
a140 1
	return $self->check($engine->{logger}, 1);
d230 49
d287 1
a287 1
		my $o = bless { site => shift @@{$job->{sites}}}, $class;
d306 1
a306 1
	my @@cmd = ($ftp, '-o', $job->{file}->tempfilename, '-v', 
d327 1
a327 3
	# XXX should be a bit smarter about keeping/not keeping files
	# based on core's status
	if ($job->{file}->checksum($job->{logger}, 
d329 8
a336 5
		rename($job->{file}->tempfilename, $job->{file}->filename);
		$core->{status} = 0;
		my $sz = $job->{file}->{sz};
		if (defined $self->{initial_sz}) {
			$sz -= $self->{initial_sz};
d338 2
a339 20
		my $fh = $job->{logger}->open("fetch/good");
		my $elapsed = $self->elapsed;
		print $fh $self->{site}.$job->{file}->{short}, " in ",
		    $elapsed, "s ";
		if ($elapsed != 0) {
			print $fh "(", 
			sprintf("%.2f", $sz / $elapsed / 1024), "KB/s)";
		}
		print $fh "\n";
		return 1;
	}
	unlink($job->{file}->tempfilename);
	my $fh = $job->{logger}->open("fetch/bad");
	print $fh $self->{site}.$job->{file}->{short}, "\n";
	if ($job->new_fetch_task) {
		$core->{status} = 0;
		return 1;
	} else {
		$core->{status} = 1;
		return 0;
d360 20
@


1.4
log
@dyslexia
@
text
@d2 1
a2 1
# $OpenBSD: Fetch.pm,v 1.3 2011/05/22 09:01:27 espie Exp $
d102 1
a102 1
	return $self->checksum($logger, $self->filename);
d108 1
a108 1
	my ($self, $logger, $name) = @@_;
d119 1
d132 1
a132 1
	return $self->check($engine->{logger});
@


1.3
log
@fix checksum logging, avoid checksumming twice
@
text
@d2 1
a2 1
# $OpenBSD: Fetch.pm,v 1.2 2011/05/22 08:21:39 espie Exp $
d102 1
a102 1
	return $self->checksum($self->filename, $logger);
@


1.2
log
@initial support for fetching distfiles, somewhat experimental yet.
- clean up clock handling, jobs with timer.
- pass more parameters thru state
- tweak the engine to handle distfiles
- lots of new code in Fetch for new jobs.
@
text
@d2 1
a2 1
# $OpenBSD: Fetch.pm,v 1.1 2011/03/22 19:48:01 espie Exp $
d102 1
d104 8
a111 1
	if (!stat $self->filename) {
d115 1
a115 1
		my $fh = $logger->open($logger->make_distlogs($self));
a116 1
		close $fh;
d119 2
a120 1
	if (OpenBSD::sha->new($self->filename)->equals($self->{sha})) {
d123 1
a123 1
	my $fh = $logger->open($logger->make_distlogs($self));
a124 1
	close $fh;
d271 15
a285 21
	if (stat $job->{file}->tempfilename) {
		if ((stat _)[7] == $job->{file}->{sz}) {
			rename($job->{file}->tempfilename,
			    $job->{file}->filename);
			$core->{status} = 0;
			my $sz = $job->{file}->{sz};
			if (defined $self->{initial_sz}) {
				$sz -= $self->{initial_sz};
			}
			my $fh = $job->{logger}->open("fetch/good");
			my $elapsed = $self->elapsed;
			print $fh $self->{site}.$job->{file}->{short}, " in ",
			    $elapsed, "s ";
			if ($elapsed != 0) {
				print $fh "(", 
				sprintf("%.2f", $sz / $elapsed / 1024), "KB/s)";
			}
			print $fh "\n";
			return 1;
		} else {
			unlink($job->{file}->tempfilename);
d287 2
d290 1
@


1.1
log
@add the glue that parses fetch info and build distinfo for future fetching.
also let Vars report stuff it doesn't know about to the logs file.
@
text
@d2 1
a2 1
# $OpenBSD: PkgPath.pm,v 1.2 2010/10/26 15:45:09 espie Exp $
d20 1
d30 1
a30 1
	my ($class, $file, $site, $distinfo) = @@_;
d42 1
d46 2
d51 6
d59 55
a113 3
	my ($class, $file, $dir, $site, $distinfo) = @@_;
	if (defined $dir) {
		$file = "$dir/$file";
d115 16
a130 1
	$cache->{$file} //= $class->create($file, $site, $distinfo);
d136 6
d163 1
a163 1
	my ($class, $h) = @@_;
d193 1
a193 1
			    $info->{$site}, $checksums);
d205 142
@

