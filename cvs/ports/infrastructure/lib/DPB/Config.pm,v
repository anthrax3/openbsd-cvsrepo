head	1.69;
access;
symbols
	OPENBSD_6_2:1.69.0.2
	OPENBSD_6_2_BASE:1.69
	OPENBSD_6_1:1.68.0.4
	OPENBSD_6_1_BASE:1.68
	OPENBSD_6_0:1.68.0.2
	OPENBSD_6_0_BASE:1.68
	OPENBSD_5_9:1.61.0.2
	OPENBSD_5_9_BASE:1.61
	OPENBSD_5_8:1.56.0.4
	OPENBSD_5_8_BASE:1.56
	OPENBSD_5_7:1.30.0.2
	OPENBSD_5_7_BASE:1.30
	OPENBSD_5_6:1.29.0.2
	OPENBSD_5_6_BASE:1.29
	OPENBSD_5_5:1.26.0.2
	OPENBSD_5_5_BASE:1.26
	OPENBSD_5_4:1.5.0.2
	OPENBSD_5_4_BASE:1.5;
locks; strict;
comment	@# @;


1.69
date	2017.04.14.16.39.32;	author espie;	state Exp;
branches;
next	1.68;
commitid	9FgsX9a0JtS7xhQD;

1.68
date	2016.06.10.16.10.20;	author espie;	state Exp;
branches;
next	1.67;
commitid	oWJ4Q10ORJYNiOUw;

1.67
date	2016.05.20.09.09.15;	author espie;	state Exp;
branches;
next	1.66;
commitid	H7NPqjDeWuzd58Vu;

1.66
date	2016.05.16.13.47.18;	author espie;	state Exp;
branches;
next	1.65;
commitid	Seo1OMd8B6VAoKJ6;

1.65
date	2016.05.08.12.52.58;	author espie;	state Exp;
branches;
next	1.64;
commitid	r5Crlv4JrY4KrbfQ;

1.64
date	2016.04.30.09.15.58;	author espie;	state Exp;
branches;
next	1.63;
commitid	5MyJwmks496t4oMe;

1.63
date	2016.04.29.11.17.44;	author espie;	state Exp;
branches;
next	1.62;
commitid	olPmtF831pFiOAqg;

1.62
date	2016.04.26.16.54.00;	author espie;	state Exp;
branches;
next	1.61;
commitid	VEjv05Z072dC3czE;

1.61
date	2015.08.25.22.40.56;	author espie;	state Exp;
branches;
next	1.60;
commitid	uhvAFVmlNEUyGxnt;

1.60
date	2015.08.24.10.16.18;	author espie;	state Exp;
branches;
next	1.59;
commitid	jf96P99j0SQ3ZVuH;

1.59
date	2015.08.22.09.24.42;	author espie;	state Exp;
branches;
next	1.58;
commitid	8OEplz3Q3KhDXImr;

1.58
date	2015.08.20.16.06.12;	author espie;	state Exp;
branches;
next	1.57;
commitid	rNIn52oHBpeSIyrw;

1.57
date	2015.08.16.08.39.23;	author espie;	state Exp;
branches;
next	1.56;
commitid	I4z6LAovV1XyFshV;

1.56
date	2015.07.27.17.19.46;	author espie;	state Exp;
branches;
next	1.55;
commitid	BfOIh312Dz5zQQRh;

1.55
date	2015.07.18.08.35.37;	author espie;	state Exp;
branches;
next	1.54;
commitid	P9N9soZ0fYH6PTIu;

1.54
date	2015.07.17.20.11.45;	author espie;	state Exp;
branches;
next	1.53;
commitid	PU9Ajom8iAWXPDkE;

1.53
date	2015.07.15.14.28.08;	author espie;	state Exp;
branches;
next	1.52;
commitid	DWQ6eBO32rPLjWzo;

1.52
date	2015.06.22.12.20.06;	author espie;	state Exp;
branches;
next	1.51;
commitid	cXl02Nt3mA2oCH21;

1.51
date	2015.05.16.18.14.04;	author espie;	state Exp;
branches;
next	1.50;
commitid	x3lefTDpWnvFuBn6;

1.50
date	2015.05.13.11.03.18;	author espie;	state Exp;
branches;
next	1.49;
commitid	aE7gR3uPnBfB78Mk;

1.49
date	2015.05.12.08.27.58;	author espie;	state Exp;
branches;
next	1.48;
commitid	O9td3nMwb0UQZNB1;

1.48
date	2015.05.12.08.20.08;	author espie;	state Exp;
branches;
next	1.47;
commitid	1XyXJFkLDfZHz5np;

1.47
date	2015.05.12.08.08.04;	author espie;	state Exp;
branches;
next	1.46;
commitid	526fruQn9EvGXXHm;

1.46
date	2015.05.11.10.33.47;	author espie;	state Exp;
branches;
next	1.45;
commitid	iijb4z6Ni8MAzdnh;

1.45
date	2015.05.10.08.40.06;	author espie;	state Exp;
branches;
next	1.44;
commitid	p4gVCPC3IBs55h2g;

1.44
date	2015.05.10.07.55.35;	author espie;	state Exp;
branches;
next	1.43;
commitid	uaI9gedLXtovmWWa;

1.43
date	2015.05.08.12.37.16;	author espie;	state Exp;
branches;
next	1.42;
commitid	f3b5ztHGaWeELiqC;

1.42
date	2015.05.02.09.44.40;	author espie;	state Exp;
branches;
next	1.41;
commitid	1VP4TYxT74T6B9km;

1.41
date	2015.05.01.19.42.54;	author espie;	state Exp;
branches;
next	1.40;
commitid	xBVlN5hyUkSlow3v;

1.40
date	2015.05.01.09.03.20;	author espie;	state Exp;
branches;
next	1.39;
commitid	zcw7xPU4fF3oSV2L;

1.39
date	2015.04.29.13.28.36;	author espie;	state Exp;
branches;
next	1.38;
commitid	hGxkUYr0sUVrcSMH;

1.38
date	2015.04.27.08.14.20;	author espie;	state Exp;
branches;
next	1.37;
commitid	A43d5CY0c1RjcplI;

1.37
date	2015.04.26.17.36.20;	author espie;	state Exp;
branches;
next	1.36;
commitid	OskFOg3qB8BTNHE8;

1.36
date	2015.04.25.14.24.03;	author espie;	state Exp;
branches;
next	1.35;
commitid	YVPJqkCksXbL5dQs;

1.35
date	2015.04.25.11.40.06;	author espie;	state Exp;
branches;
next	1.34;
commitid	OcJxnwI9PKjMrXqN;

1.34
date	2015.04.25.11.23.20;	author espie;	state Exp;
branches;
next	1.33;
commitid	SpoCSaxEwsIkKWqM;

1.33
date	2015.04.21.09.53.13;	author espie;	state Exp;
branches;
next	1.32;
commitid	lGAocVQGyzRmFit9;

1.32
date	2015.04.21.09.23.57;	author espie;	state Exp;
branches;
next	1.31;
commitid	qJeUeGqdv3D47y7R;

1.31
date	2015.04.21.08.19.52;	author espie;	state Exp;
branches;
next	1.30;
commitid	KhqAZQnZJdofSQHM;

1.30
date	2014.12.25.15.14.14;	author espie;	state Exp;
branches;
next	1.29;
commitid	4T2EL5Ro5f9nUYOi;

1.29
date	2014.04.28.12.51.41;	author espie;	state Exp;
branches;
next	1.28;

1.28
date	2014.03.17.10.48.40;	author espie;	state Exp;
branches;
next	1.27;

1.27
date	2014.03.09.19.47.35;	author espie;	state Exp;
branches;
next	1.26;

1.26
date	2014.01.10.11.26.43;	author espie;	state Exp;
branches;
next	1.25;

1.25
date	2013.12.30.12.28.23;	author espie;	state Exp;
branches;
next	1.24;

1.24
date	2013.11.17.09.43.09;	author espie;	state Exp;
branches;
next	1.23;

1.23
date	2013.11.16.13.06.00;	author espie;	state Exp;
branches;
next	1.22;

1.22
date	2013.10.27.09.26.01;	author espie;	state Exp;
branches;
next	1.21;

1.21
date	2013.10.17.14.20.44;	author espie;	state Exp;
branches;
next	1.20;

1.20
date	2013.10.17.12.48.09;	author espie;	state Exp;
branches;
next	1.19;

1.19
date	2013.10.17.08.12.28;	author espie;	state Exp;
branches;
next	1.18;

1.18
date	2013.10.14.12.14.33;	author espie;	state Exp;
branches;
next	1.17;

1.17
date	2013.10.13.18.31.50;	author espie;	state Exp;
branches;
next	1.16;

1.16
date	2013.10.13.10.34.55;	author espie;	state Exp;
branches;
next	1.15;

1.15
date	2013.10.07.20.01.55;	author espie;	state Exp;
branches;
next	1.14;

1.14
date	2013.10.07.19.27.25;	author espie;	state Exp;
branches;
next	1.13;

1.13
date	2013.10.06.13.33.28;	author espie;	state Exp;
branches;
next	1.12;

1.12
date	2013.10.02.09.13.27;	author espie;	state Exp;
branches;
next	1.11;

1.11
date	2013.09.25.07.01.35;	author espie;	state Exp;
branches;
next	1.10;

1.10
date	2013.09.23.14.25.13;	author espie;	state Exp;
branches;
next	1.9;

1.9
date	2013.09.21.08.56.43;	author espie;	state Exp;
branches;
next	1.8;

1.8
date	2013.09.18.13.07.32;	author espie;	state Exp;
branches;
next	1.7;

1.7
date	2013.09.14.09.42.11;	author espie;	state Exp;
branches;
next	1.6;

1.6
date	2013.09.11.10.44.13;	author espie;	state Exp;
branches;
next	1.5;

1.5
date	2013.07.05.13.49.50;	author pirofti;	state Exp;
branches;
next	1.4;

1.4
date	2013.06.23.13.19.33;	author espie;	state Exp;
branches;
next	1.3;

1.3
date	2013.06.22.09.16.36;	author espie;	state Exp;
branches;
next	1.2;

1.2
date	2013.06.21.23.13.37;	author espie;	state Exp;
branches;
next	1.1;

1.1
date	2013.06.21.09.05.18;	author espie;	state Exp;
branches;
next	;


desc
@@


1.69
log
@reorg the logic behind permanent_log so that it *is* the permanent log.
fixes -DNO_BUILD_STATS as reported by naddy@@ (predates rewriting buildinfo,
and I plain forgot about it obviously)
@
text
@# ex:ts=8 sw=4:
# $OpenBSD: Config.pm,v 1.68 2016/06/10 16:10:20 espie Exp $
#
# Copyright (c) 2010-2013 Marc Espie <espie@@openbsd.org>
#
# Permission to use, copy, modify, and distribute this software for any
# purpose with or without fee is hereby granted, provided that the above
# copyright notice and this permission notice appear in all copies.
#
# THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
# ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
# OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

use strict;
use warnings;

# all the code responsible for handling command line options and the
# config file.

package DPB::Config;
use DPB::User;

sub setup_users
{
	my ($class, $state) = @@_;
	for my $u (qw(build_user log_user fetch_user port_user)) {
		my $U = uc($u);
		if ($state->defines($U)) {
			$state->{$u} = DPB::User->new($state->defines($U));
		}
		if (defined $state->{$u}) {
			if ($state->defines("DIRMODE")) {
				$state->{$u}{dirmode} = 
				    oct($state->defines("DIRMODE"));
			}
			if ($state->defines("DROPPRIV")) {
				$state->{$u}{droppriv} = 
				    $state->defines("DROPPRIV");
			}
		}
	}
	my $u = DPB::User->new('_dpb');
	if (defined $u->{uid}) {
		$state->{unpriv_user} = $u;
	} else {
		$state->fatal("No _dpb user");
	}
	$state->{unpriv_user}->enforce_local;
	$> = $state->{unpriv_user}{uid};
	$) = $state->{unpriv_user}{grouplist};
}

sub parse_command_line
{
	my ($class, $state) = @@_;
	$state->{dontclean} = {};
	$state->{opt} = {
		A => sub {
			$state->{arch} = shift;
		},
		L => sub {
			$state->{flogdir} = shift;
		},
		l => sub {
			$state->{flockdir} = shift;
		},
		r => sub {
			$state->{random} = 1;
			$state->heuristics->random;
		},
		P => sub {
			push(@@{$state->{paths}}, shift);
		},
		I => sub {
			push(@@{$state->{ipaths}}, shift);
		},
		C => sub {
			push(@@{$state->{cpaths}}, shift);
		},
		X => sub {
			push(@@{$state->{xpaths}}, shift);
		},
		b => sub {
			push(@@{$state->{build_files}}, shift);
		},
		h => sub {
			push(@@{$state->{config_files}}, shift);
		},
	};

	$state->SUPER_handle_options('aceimqrRstuUvh:S:xX:A:B:C:f:F:I:j:J:M:p:P:b:l:L:',
    "[-aceimqrRsuUvx] [-A arch] [-B chroot] [-C plist] [-f m] [-F m]",
    "[-I pathlist] [-J p] [-j n] [-p parallel] [-P pathlist] [-h hosts]",
    "[-L logdir] [-l lockdir] [-b log] [-M threshold] [-X pathlist]",
    "[pathlist ...]");
	for my $l (qw(j f F)) {
		my $o = $state->{opt}{$l};
		if (defined $o && $o !~ m/^\d+$/) {
			$state->usage("-$l takes an integer argument, not $o");
		}
	}
	if ($state->opt('i')) {
		require DPB::Interactive;
		$state->{interactive} = DPB::Interactive->new;
	}

    	$state->{chroot} = $state->opt('B');
	$state->{base_user} = DPB::User->from_uid($<);
	if (!defined $state->{base_user}) {
		$state->usage("Can't figure out who I am");
	}
	if ($state->{base_user}{uid} != 0) {
		$state->errsay("Running dpb as root with a build_user is the preferred setup");
	}
	$class->setup_users($state);

	($state->{ports}, $state->{localarch},
	    $state->{distdir}, $state->{xenocara}) =
		DPB::Vars->get(DPB::Host::Localhost->getshell($state), 
		$state->make,
		"PORTSDIR", "MACHINE_ARCH", "DISTDIR", 
		"PORTS_BUILD_XENOCARA_TOO");
    	if (!defined $state->{ports}) {
		$state->usage("Can't obtain vital information from the ports tree");
	}
	$state->{arch} //= $state->{localarch};
	if (defined $state->{opt}{F}) {
		if (defined $state->{opt}{j} || defined $state->{opt}{f}) {
			$state->usage("Can't use -F with -f or -j");
		}
		$state->{fetch_only} = 1;
		$state->{opt}{f} = $state->{opt}{F};
	}
	if (defined $state->opt('j')) {
		if ($state->localarch ne $state->arch) {
			$state->usage(
		    "Can't use -j if -A arch is not local architecture");
		}
	}
	$state->{realports} = $state->anchor($state->{ports});
	$state->{realdistdir} = $state->anchor($state->{distdir});
	if (defined $state->{config_files}) {
		for my $f (@@{$state->{config_files}}) {
			$f = $state->expand_path($f);
		}
	}

	# keep cmdline subst values
	my %cmdline = %{$state->{subst}};

	$class->parse_config_files($state);
	# ... as those must override the config files contents
	while (my ($k, $v) = each %cmdline) {
		$state->{subst}->{$k} = $v;
	}
	$class->setup_users($state);
	$state->{build_user} //= $state->{default_prop}{build_user};
	if ($state->{base_user}{uid} == 0) {
		$state->{fetch_user} //= DPB::User->new('_pfetch');
	}
	if (!defined $state->{port_user}) {
		my ($uid, $gid) = (stat $state->{realports})[4,5];
		$state->{port_user} = DPB::User->from_uid($uid, $gid);
	}
	if (!defined $state->{build_user}) {
		$state->{build_user} = $state->{base_user};
	}
	$state->{log_user} //= $state->{build_user};
	$state->{fetch_user} //= $state->{build_user};

	$state->{log_user}->enforce_local;
	$state->{chroot} = $state->{default_prop}{chroot};
	# reparse things properly now that we can chroot
	my $p;
	($state->{ports}, $state->{portspath}, $state->{repo}, $state->{localarch},
	    $state->{distdir}, $state->{localbase}, $state->{xenocara}, $p) =
		DPB::Vars->get(DPB::Host::Localhost->getshell($state), 
		$state->make,
		"PORTSDIR", "PORTSDIR_PATH", "PACKAGE_REPOSITORY", 
		"MACHINE_ARCH", "DISTDIR", "LOCALBASE", 
		"PORTS_BUILD_XENOCARA_TOO", "SIGNING_PARAMETERS");

    	if (!defined $state->{portspath}) {
		$state->usage("Can't obtain vital information from the ports tree");
	}
	if ($state->{xenocara} =~ m/Yes/i) {
		$state->{xenocara} = 1;
	} else {
		$state->{xenocara} = 0;
	}
	$state->{portspath} = [ map {$state->anchor($_)} split(/:/, $state->{portspath}) ];
	$state->{realports} = $state->anchor($state->{ports});
	$state->{realdistdir} = $state->anchor($state->{distdir});
	if (!defined $state->{port_user}) {
		my ($uid, $gid) = (stat $state->{realports})[4,5];
		$state->{port_user} = DPB::User->from_uid($uid, $gid);
	}
	$state->say("Started as: #1", $state->{base_user}->user);
	$state->say("Port user: #1", $state->{port_user}->user);
	$state->say("Build user: #1", $state->{build_user}->user);
	$state->say("Fetch user: #1", $state->{fetch_user}->user);
	$state->say("Log user: #1", $state->{log_user}->user);
	$state->say("Unpriv user: #1", $state->{unpriv_user}->user);

	$state->{logdir} = $state->{flogdir} // $ENV{LOGDIR} // '%p/logs/%a';
	$state->{lockdir} //= $state->{flockdir} // "%L/locks";
	$state->{logdir} = $state->expand_path($state->{logdir});

	if ($p =~ m/^\s*$/) {
		$state->{signer} = '-Dunsigned';
	} elsif ($p =~ m/\-DSIGNER\=\S+/) {
		$state->{signer} = $&;
	}

	$state->{size_log} = "%f/build-stats/%a-size";

	if ($state->define_present('LOGDIR')) {
		$state->{logdir} = $state->{subst}->value('LOGDIR');
	}
	if ($state->{opt}{s}) {
		$state->{wantsize} = 1;
	} elsif ($state->define_present('WANTSIZE')) {
		$state->{wantsize} = $state->{subst}->value('WANTSIZE');
	} elsif (DPB::HostProperties->has_mem) {
		$state->{wantsize} = 1;
	}
	if ($state->define_present('COLOR')) {
		$state->{color} = $state->{subst}->value('COLOR');
	}
	if ($state->define_present('NO_CURSOR')) {
		$state->{nocursor} = $state->{subst}->value('NO_CURSOR');
	}
	if (DPB::HostProperties->has_mem || $state->{wantsize}) {
		require DPB::Heuristics::Size;
		$state->{sizer} = DPB::Heuristics::Size->new($state);
	} else {
		require DPB::Heuristics::Nosize;
		$state->{sizer} = DPB::Heuristics::Nosize->new($state);
	}
	if ($state->define_present('FETCH_JOBS') && !defined $state->{opt}{f}) {
		$state->{opt}{f} = $state->{subst}->value('FETCH_JOBS');
	}
	if ($state->define_present('LOCKDIR')) {
		$state->{lockdir} = $state->{subst}->value('LOCKDIR');
	}
	if ($state->define_present('TESTS')) {
		$state->{tests} = $state->{subst}->value('tests');
	}
	if ($state->{flogdir}) {
		$state->{logdir} = $state->{flogdir};
	}
	if ($state->{flockdir}) {
		$state->{lockdir} = $state->{flockdir};
	}
	if ($state->{opt}{t}) {
		$state->{tests} = 1;
	}

	$state->{opt}{f} //= 2;
	if ($state->opt('f')) {
		$state->{want_fetchinfo} = 1;
	}

	my $k = $state->is_interactive ? "STARTUPI" : "STARTUP";
	if ($state->define_present($k)) {
		$state->{startup_script} = $state->expand_chrooted_path($state->{subst}->value($k));
	}
	# redo this in case config files changed it
	$state->{logdir} = $state->expand_path($state->{logdir});

	if ($state->define_present("RECORD")) {
		$state->{record} = $state->{subst}->value("RECORD");
	}
	$state->{record} //= "%L/term-report.log";
	$state->{record} = $state->expand_path($state->{record});
	$state->{size_log} = $state->expand_path($state->{size_log});
	$state->{lockdir} = $state->expand_path($state->{lockdir});
	for my $cat (qw(build_files paths ipaths cpaths xpaths)) {
		next unless defined $state->{$cat};
		for my $f (@@{$state->{$cat}}) {
			$f = $state->expand_path($f);
		}
	}
	if (!$state->{subst}->value("NO_BUILD_STATS")) {
		$state->{permanent_log} = 
		    $state->expand_path("%f/build-stats/%a");
		push(@@{$state->{build_files}}, $state->{permanent_log});
	}
	$state->{dependencies_log} = 
	    $state->expand_path("%f/build-stats/%a-dependencies");
	$state->{display_timeout} =
	    $state->{subst}->value('DISPLAY_TIMEOUT') // 10;
	if ($state->defines("DONT_BUILD_ONCE")) {
		$state->{build_once} = 0;
	}
	if ($state->define_present('MIRROR')) {
		$state->{mirror} = $state->{subst}->value('MIRROR');
	} else {
		$state->{mirror} = $state->{fetch_only};
	}
    	$state->{fullrepo} = join("/", $state->{repo}, $state->arch, "all");
}

sub command_line_overrides
{
	my ($class, $state) = @@_;

	my $override_prop = DPB::HostProperties->new;

	if (defined $state->{base_user}) {
		$override_prop->{base_user} = $state->{base_user};
	}
	if (defined $state->{port_user}) {
		$override_prop->{port_user} = $state->{port_user};
	}
	if (!$state->{subst}->empty('HISTORY_ONLY')) {
		$state->{want_fetchinfo} = 1;
		$state->{opt}{f} = 0;
		$state->{opt}{j} = 1;
		$state->{opt}{e} = 1;
		$state->{all} = 1;
		$state->{scan_only} = 1;
		# XXX not really random, but no need to use dependencies
		$state->{random} = 1;
	}
	if ($state->opt('j')) {
		$override_prop->{jobs} = $state->opt('j');
	}
	if ($state->opt('p')) {
		$override_prop->{parallel} = $state->opt('p');
	}
	if ($state->opt('B')) {
		$override_prop->{chroot} = $state->opt('B');
	}
	if ($state->define_present('STUCK_TIMEOUT')) {
		$override_prop->{stuck} = 
		    $state->{subst}->value('STUCK_TIMEOUT');
	}
	if ($state->define_present('FETCH_TIMEOUT')) {
		$override_prop->{fetch_timeout} = 
		    $state->{subst}->value('FETCH_TIMEOUT');
	}
	if ($state->define_present('SMALL_TIME')) {
		$override_prop->{small} = 
		    $state->{subst}->value('SMALL_TIME');
	}
	if ($state->define_present('CONNECTION_TIMEOUT')) {
		$override_prop->{timeout} = 
		    $state->{subst}->value('CONNECTION_TIMEOUT');
	}
	if ($state->opt('J')) {
		$override_prop->{junk} = $state->opt('J');
	}
	if ($state->defines("ALWAYS_CLEAN")) {
		$override_prop->{always_clean} = 1;
	}
	if ($state->opt('M')) {
		$override_prop->{mem} = $state->opt('M');
	}

	if ($state->define_present('SYSLOG')) {
		require Sys::Syslog;
		Sys::Syslog::openlog('dpb', "nofatal");
		$override_prop->{syslog} = 1;
	}
	return $override_prop;
}

sub parse_config_files
{
	my ($class, $state) = @@_;

	my $override_prop = $class->command_line_overrides($state);
	my $default_prop = {
		junk => 150, 
		parallel => '/2',
		small => 120,
		repair => 1,
		nochecksum => 1,
	};

	if ($state->{config_files}) {
		for my $config (@@{$state->{config_files}}) {
			$class->parse_hosts_file($config, $state, 
			    \$default_prop, $override_prop);
		}
	}
	my $prop = DPB::HostProperties->new($default_prop);
	$prop->finalize_with_overrides($override_prop);
	if (!$state->{config_files}) {
		DPB::Core::Init->new('localhost', $prop);
	}
	$state->{default_prop} = $prop;
}

sub parse_hosts_file
{
	my ($class, $filename, $state, $rdefault, $override) = @@_;
	open my $fh, '<', $filename or
		$state->fatal("Can't read host files #1: #2", $filename, $!);
	my $cores = {};
	while (<$fh>) {
		chomp;
		s/\s*\#.*$//;
		next if m/^$/;
		if (m/^([A-Z_]+)\=\s*(.*)\s*$/) {
			$state->{subst}->add($1, $2);
			next;
		}
		if (defined $state->{build_user}) {
			$$rdefault->{build_user} //= $state->{build_user};
		}
		# copy default properties
		my $prop = DPB::HostProperties->new($$rdefault);
		my ($host, @@properties) = split(/\s+/, $_);
		for my $arg (@@properties) {
			if ($arg =~ m/^(.*?)=(.*)$/) {
				$prop->{$1} = $2;
			}
		}
		if (defined $prop->{arch} && $prop->{arch} ne $state->arch) {
			next;
		}
		if ($host eq 'DEFAULT') {
			$$rdefault = { %$prop };
			next;
		}
		$prop->finalize_with_overrides($override);
		DPB::Core::Init->new($host, $prop);
		if (defined $prop->{build_user} && 
		    !defined $state->{build_user} &&
		    !$state->defines("BUILD_USER")) {
		    	$state->{build_user} = $prop->{build_user};
		}
	}
}

1;
@


1.68
log
@scrape another use of PLIST_DB (I don't even remember why I thought
it might have been a good idea to grab it at the time)
@
text
@d2 1
a2 1
# $OpenBSD: Config.pm,v 1.67 2016/05/20 09:09:15 espie Exp $
a281 3
	if (!$state->{subst}->value("NO_BUILD_STATS")) {
		push @@{$state->{build_files}}, "%f/build-stats/%a";
	}
d288 5
a292 1
	$state->{permanent_log} = $state->{build_files}[-1];
@


1.67
log
@fix incorrect handling of config info,
repair full signatures (with X11R6 libs too)
@
text
@d2 1
a2 1
# $OpenBSD: Config.pm,v 1.66 2016/05/16 13:47:18 espie Exp $
d122 1
a122 1
	    $state->{distdir}, $state->{plist_db}, $state->{xenocara}) =
a125 1
		"PLIST_DB",
@


1.66
log
@change drastically the way LISTING starts up: let dependencies be a permanent
log.

Now that we can SKIPDIR, doing a first LISTING for most important dependencies
is not a trade-off for the full listing.

It allows dpb to start building most important stuff right away, so that
your machines start earlier.

Caveat: if that list of dependencies changes (ports renames), then you will
see errors because ports no longer exist.

I figure I have time to make errors in the first listing "not relevant"
before that becomes an actual issue.
@
text
@d2 1
a2 1
# $OpenBSD: Config.pm,v 1.65 2016/05/08 12:52:58 espie Exp $
a130 5
	if ($state->{xenocara} =~ m/Yes/i) {
		$state->{xenocara} = 1;
	} else {
		$state->{xenocara} = 0;
	}
d190 5
@


1.65
log
@make things work better when chrooted, delay some expansions, and acknowledge
that startup is going to run within the chroot.
@
text
@d2 1
a2 1
# $OpenBSD: Config.pm,v 1.64 2016/04/30 09:15:58 espie Exp $
d293 2
@


1.64
log
@tweak running-as-root defaults to be _pbuild/_pfetch. It's time.
@
text
@d2 1
a2 1
# $OpenBSD: Config.pm,v 1.63 2016/04/29 11:17:44 espie Exp $
a160 4
	if (!defined $state->{port_user}) {
		my ($uid, $gid) = (stat $state->{realports})[4,5];
		$state->{port_user} = DPB::User->from_uid($uid, $gid);
	}
a181 7
	$state->say("Started as: #1", $state->{base_user}->user);
	$state->say("Port user: #1", $state->{port_user}->user);
	$state->say("Build user: #1", $state->{build_user}->user);
	$state->say("Fetch user: #1", $state->{fetch_user}->user);
	$state->say("Log user: #1", $state->{log_user}->user);
	$state->say("Unpriv user: #1", $state->{unpriv_user}->user);

d197 1
d199 11
d271 1
a271 1
		$state->{startup_script} = $state->expand_path($state->{subst}->value($k));
@


1.63
log
@well, no reason for STARTUP not to be able to use %p
@
text
@d2 1
a2 1
# $OpenBSD: Config.pm,v 1.62 2016/04/26 16:54:00 espie Exp $
d172 3
d180 1
a180 5
		if ($state->{base_user}{uid} != 0) {
			$state->{build_user} = $state->{base_user};
		} else {
			$state->{build_users} = $state->{port_user};
		}
@


1.62
log
@thinko
@
text
@d2 1
a2 1
# $OpenBSD: Config.pm,v 1.61 2015/08/25 22:40:56 espie Exp $
a221 4
	my $k = $state->is_interactive ? "STARTUPI" : "STARTUP";
	if ($state->define_present($k)) {
		$state->{startup_script} = $state->{subst}->value($k);
	}
d269 4
@


1.61
log
@remove UNPRIV_USER configuration entirely, that's the one part where there's
one sensible choice now (_dpb) and no need for configuration.
@
text
@d2 1
a2 1
# $OpenBSD: Config.pm,v 1.60 2015/08/24 10:16:18 espie Exp $
d227 1
a227 1
		$state->{logdir} = $state->subst->value('LOGDIR');
@


1.60
log
@a bit of interactive mode. Just hooks into the main loop and can prompt for
commands now, can't do anything serious yet.
@
text
@d2 1
a2 1
# $OpenBSD: Config.pm,v 1.59 2015/08/22 09:24:42 espie Exp $
d30 1
a30 1
	for my $u (qw(unpriv_user build_user log_user fetch_user port_user)) {
@


1.59
log
@Config file handling is still somewhat broken...
@
text
@d2 1
a2 1
# $OpenBSD: Config.pm,v 1.58 2015/08/20 16:06:12 espie Exp $
d106 5
a110 1
	$state->{interactive} = $state->opt('i');
d222 1
a222 1
	my $k = $state->{interactive} ? "STARTUPI" : "STARTUP";
@


1.58
log
@it's been long enough, if you don't have user _dpb, you lose.
@
text
@d2 1
a2 1
# $OpenBSD: Config.pm,v 1.57 2015/08/16 08:39:23 espie Exp $
d157 4
d166 1
a167 1
	$class->setup_users($state);
d310 3
@


1.57
log
@interactive mode will have a different startup file, so that you can
configure it to not delete everything (particularly useful if you start
a dpb -i in another window while dpb is in session)
@
text
@d2 1
a2 1
# $OpenBSD: Config.pm,v 1.56 2015/07/27 17:19:46 espie Exp $
d49 2
d52 3
a54 5
	if (defined $state->{unpriv_user}) {
		$state->{unpriv_user}->enforce_local;
		$> = $state->{unpriv_user}{uid};
		$) = $state->{unpriv_user}{grouplist};
	}
d184 1
a184 3
	if (defined $state->{unpriv_user}) {
		$state->say("Unpriv user: #1", $state->{unpriv_user}->user);
	}
@


1.56
log
@grab a few more things off our ports tree introspection. Locally PLIST_DB.

Distantly, WRKOBJDIR and LOCKDIR, so that we can pass these off to a startup
script to ensure correct user.

The distant stuff has to happen at the right moment, after whoami, so that
we don't try to use doas/sudo unnecessarily...
@
text
@d2 1
a2 1
# $OpenBSD: Config.pm,v 1.55 2015/07/18 08:35:37 espie Exp $
d216 3
a218 4
	if ($state->define_present("STARTUP")) {
		$state->{startup_script} = $state->{subst}->value("STARTUP");
	} elsif ($state->define_present("CLEANUP")) {
		$state->{startup_script} = $state->{subst}->value("CLEANUP");
@


1.55
log
@if _dpb exists, use it as a default unpriv_user
@
text
@d2 1
a2 1
# $OpenBSD: Config.pm,v 1.54 2015/07/17 20:11:45 espie Exp $
d118 1
a118 1
	    $state->{distdir}, $state->{xenocara}) =
d122 1
@


1.54
log
@oopsie  found by naddy.
@
text
@d2 1
a2 1
# $OpenBSD: Config.pm,v 1.53 2015/07/15 14:28:08 espie Exp $
d45 4
@


1.53
log
@make the default better. If dpb starts as root, use the owner of the ports
tree as a build_user.

Also shows all the users that dpb uses (locally).

(port_user is to be used by an interactive mode eventually).
@
text
@d2 1
a2 1
# $OpenBSD: Config.pm,v 1.52 2015/06/22 12:20:06 espie Exp $
d179 3
a181 1
	$state->say("Unpriv user: #1", $state->{unpriv_user}->user);
@


1.52
log
@future interactive option that does nothing whatsoever so far...
@
text
@d2 1
a2 1
# $OpenBSD: Config.pm,v 1.51 2015/05/16 18:14:04 espie Exp $
d30 1
a30 1
	for my $u (qw(unpriv_user build_user log_user fetch_user)) {
d108 3
d159 11
a169 1
	$state->{build_user} //= $state->{base_user};
d174 6
a179 1

@


1.51
log
@We never use groups separately, make it a grouplist.
Get group name as well.

Pass BUILD_USER/BUILD_GROUP/FETCH_USER/FETCH_GROUP as env variables to STARTUP
script.
@
text
@d2 1
a2 1
# $OpenBSD: Config.pm,v 1.50 2015/05/13 11:03:18 espie Exp $
d91 2
a92 2
	$state->SUPER_handle_options('acemqrRstuUvh:S:xX:A:B:C:f:F:I:j:J:M:p:P:b:l:L:',
    "[-acemqrRsuUvx] [-A arch] [-B chroot] [-C plist] [-f m] [-F m]",
d102 1
@


1.50
log
@complete local users with groups list using id -G.

Use that when switching groups to enforce full correct list of groups.

Figure out users that must exist locally, and error out if they don't.

Based on feedback by sthen@@
@
text
@d2 1
a2 1
# $OpenBSD: Config.pm,v 1.49 2015/05/12 08:27:58 espie Exp $
d49 1
a49 1
		$) = "$state->{unpriv_user}{gid} $state->{unpriv_user}{groups}";
@


1.49
log
@get a build_user for whatever host we've set, if everything else fails.
@
text
@d2 1
a2 1
# $OpenBSD: Config.pm,v 1.48 2015/05/12 08:20:08 espie Exp $
d47 1
d49 1
a49 1
		$) = $state->{unpriv_user}{gid};
d158 2
@


1.48
log
@avoid creating multiple user objects for the same user
@
text
@d2 1
a2 1
# $OpenBSD: Config.pm,v 1.47 2015/05/12 08:08:04 espie Exp $
d395 5
@


1.47
log
@oops, mixed this up.
@
text
@d2 1
a2 1
# $OpenBSD: Config.pm,v 1.46 2015/05/11 10:33:47 espie Exp $
d376 1
a376 1
			$$rdefault->{build_user} //= $state->{build_user}->user;
@


1.46
log
@make sure we get DIRMODE and DROPPRIV
default build_user/log_user/fetch_user as the documentation says.

Deal with BUILD_USER on the command line correctly, pass it off to
default_prop

(this should fix various config issues reported by sthen@@ and aja@@)
@
text
@d2 1
a2 1
# $OpenBSD: Config.pm,v 1.45 2015/05/10 08:40:06 espie Exp $
d375 2
a376 2
		if (defined $state->{BUILD_USER}) {
			$$rdefault->{build_user} //= $state->{BUILD_USER};
@


1.45
log
@compat with old config breaks new config, so ditch it.
@
text
@d2 1
a2 1
# $OpenBSD: Config.pm,v 1.44 2015/05/10 07:55:35 espie Exp $
d34 2
d37 6
a42 1
				$state->{$u}{dirmode} = oct($state->defines("DIRMODE"));
d154 4
d374 3
@


1.44
log
@must re-evaluate users after reading config files.
open permanent log correctly.
@
text
@d2 1
a2 1
# $OpenBSD: Config.pm,v 1.43 2015/05/08 12:37:16 espie Exp $
d34 3
d145 1
a345 3
	}
	for my $u (qw(build_user log_user fetch_user)) {
		$state->{$u} //= $prop->{$u};
@


1.43
log
@introduce "UNPRIV_USER" so that we don't run as root that often.
Move FETCH_USER, LOG_USER to defines, because they're not really
host-dependent.

Keep the equiv so that ppl old config doesn't break...
@
text
@d2 1
a2 1
# $OpenBSD: Config.pm,v 1.42 2015/05/02 09:44:40 espie Exp $
d142 1
@


1.42
log
@move the user handling code to a separate file.
remove "run_as" for open, we can do things directly.

More explicit code on open.
@
text
@d2 1
a2 1
# $OpenBSD: Config.pm,v 1.41 2015/05/01 19:42:54 espie Exp $
d27 15
d96 1
a96 3
	if ($state->defines('BUILD_USER')) {
		$state->{build_user} = DPB::User->new($state->defines('BUILD_USER'));
	}
d142 1
@


1.41
log
@lock_user is not needed, defaults to log_user for all practical cases
@
text
@d2 1
a2 1
# $OpenBSD: Config.pm,v 1.40 2015/05/01 09:03:20 espie Exp $
d25 2
d77 1
a77 1
	$state->{base_user} = DPB::Id->from_uid($<);
d82 1
a82 1
		$state->{build_user} = DPB::Id->new($state->defines('BUILD_USER'));
a365 82
}

package DPB::Id;

sub from_uid
{
	my ($class, $u) = @@_;
	if (my ($l, undef, $uid, $gid) = getpwuid $u) {
		bless { user => $l, uid => $uid, gid => $gid }, $class;
	} else {
		return undef;
	}
}

sub new
{
	my ($class, $u) = @@_;
	# XXX getpwnam for local access, distant access is different
	if (my ($l, undef, $uid, $gid) = getpwnam $u) {
		bless { user => $l, uid => $uid, gid => $gid }, $class;
	} else {
		bless { user => $u}, $class;
	}
}

sub user
{
	my $self = shift;
	return $self->{user};
}

sub run_as
{
	my ($self, $code) = @@_;
	local ($>, $)) = ($self->{uid}, $self->{gid});
	&$code;
}

sub make_path
{
	my ($self, @@directories) = @@_;
	require File::Path;
	my $p = {};
	if ($self->{uid}) {
		$p->{uid} = $self->{uid};
	} else {
		$p->{owner} = $self->{user};
	}
	if ($self->{gid}) {
		$p->{gid} = $self->{gid};
	}
	File::Path::make_path(@@directories, $p);
}

sub open
{
	my ($self, $mode, $filename) = @@_;
	my $fh;
	$self->run_as(
	    sub {
	    	open $fh, $mode, $filename;
	    });
	return $fh;
}

package DPB::UserProxy;
sub run_as
{
	my ($self, $code) = @@_;
	$self->{user}->run_as($code);
}

sub make_path
{
	my ($self, @@dirs) = @@_;
	$self->{user}->make_path(@@dirs);
}

sub open
{
	my ($self, @@parms) = @@_;
	return $self->{user}->open(@@parms);
@


1.40
log
@slight cleanup
@
text
@d2 1
a2 1
# $OpenBSD: Config.pm,v 1.39 2015/04/29 13:28:36 espie Exp $
d326 1
a326 1
	for my $u (qw(build_user log_user lock_user fetch_user)) {
@


1.39
log
@a few more "tweak the user" for fetch handling
@
text
@d2 1
a2 1
# $OpenBSD: Config.pm,v 1.38 2015/04/27 08:14:20 espie Exp $
a413 3
	}
	if ($self->{dirmode}) {
		$p->{mode} = $self->{dirmode};
@


1.38
log
@reexpand will work much better with the correct anchor
@
text
@d2 1
a2 1
# $OpenBSD: Config.pm,v 1.37 2015/04/26 17:36:20 espie Exp $
d421 11
d443 6
@


1.37
log
@Add a way to make_path with uig/gid.
Add a way to run local jobs as another user.
@
text
@d2 1
a2 1
# $OpenBSD: Config.pm,v 1.36 2015/04/25 14:24:03 espie Exp $
d127 1
@


1.36
log
@do minimal discovery before reading config files, then do full discovery.
allow things like proper chroot in the config file only.
@
text
@d2 1
a2 1
# $OpenBSD: Config.pm,v 1.35 2015/04/25 11:40:06 espie Exp $
d328 1
d399 32
@


1.35
log
@don't forget to copy all the users for later
@
text
@d2 1
a2 1
# $OpenBSD: Config.pm,v 1.34 2015/04/25 11:23:20 espie Exp $
d83 2
a84 3
	my $p;
	($state->{ports}, $state->{portspath}, $state->{repo}, $state->{localarch},
	    $state->{distdir}, $state->{localbase}, $state->{xenocara}, $p) =
d87 3
a89 4
		"PORTSDIR", "PORTSDIR_PATH", "PACKAGE_REPOSITORY", 
		"MACHINE_ARCH", "DISTDIR", "LOCALBASE", 
		"PORTS_BUILD_XENOCARA_TOO", "SIGNING_PARAMETERS");
    	if (!defined $state->{portspath}) {
a91 5
	if ($p =~ m/^\s*$/) {
		$state->{signer} = '-Dunsigned';
	} elsif ($p =~ m/\-DSIGNER\=\S+/) {
		$state->{signer} = $&;
	}
a97 4
	$state->{portspath} = [ map {$state->anchor($_)} split(/:/, $state->{portspath}) ];
	$state->{realdistdir} = $state->anchor($state->{distdir});
	$state->{logdir} = $state->{flogdir} // $ENV{LOGDIR} // '%p/logs/%a';
	$state->{lockdir} //= $state->{flockdir} // "%L/locks";
d112 1
a118 2
	$state->{logdir} = $state->expand_path($state->{logdir});

d126 24
@


1.34
log
@a bit of cleanup: building the host properties is totally separate from
building the host (especially ensure overrides/finalize is run together).
Do default handling in a saner way, and use that to get a build_user
(and soon a log_user, a fetch_user).

Add run_as scaffolding to allow logging properly when dpb is run as root
(to be used soon)
@
text
@d2 1
a2 1
# $OpenBSD: Config.pm,v 1.33 2015/04/21 09:53:13 espie Exp $
d313 3
a315 1
	$state->{build_user} //= $prop->{build_user};
@


1.33
log
@setting the stage for further changes
@
text
@d2 1
a2 1
# $OpenBSD: Config.pm,v 1.32 2015/04/21 09:23:57 espie Exp $
d305 1
a305 1
			    $default_prop, $override_prop);
d308 2
a309 2
	$state->{default_prop} = $default_prop;
	$state->{override_prop} = $override_prop;
a310 2
		my $prop = DPB::HostProperties->new($state->{default_prop});
		$prop->add_overrides($state->{override_prop});
d313 1
d318 1
a318 1
	my ($class, $filename, $state, $default, $override) = @@_;
d331 1
a331 1
		my $prop = DPB::HostProperties->new($default);
d342 1
a342 1
			$default = { %$prop };
d345 1
a345 1
		$prop->add_overrides($override);
d377 7
@


1.32
log
@start reorg the way we handle users.
@
text
@d2 1
a2 1
# $OpenBSD: Config.pm,v 1.31 2015/04/21 08:19:52 espie Exp $
d78 3
@


1.31
log
@commonalize check for option values...
@
text
@d2 1
a2 1
# $OpenBSD: Config.pm,v 1.30 2014/12/25 15:14:14 espie Exp $
d75 2
a76 5
	if (my ($l, $p, $uid, $gid) = getpwuid $<) {
		$state->{user} = $l;
		$state->{uid} = $uid;
		$state->{gid} = $gid;
	} else {
d79 1
d230 2
a231 4
	for my $k (qw(user uid gid)) {
		if (defined $state->{$k}) {
			$override_prop->{$k} = $state->{$k};
		}
d346 29
@


1.30
log
@regorg code, no actual change
@
text
@d2 1
a2 1
# $OpenBSD: Config.pm,v 1.29 2014/04/28 12:51:41 espie Exp $
d68 6
a119 3
		if ($state->opt('j') !~ m/^\d+$/) {
			$state->usage("-j takes a numerical argument");
		}
a188 3
	if ($state->opt('f') !~ m/^\d+$/) {
		$state->usage("-f takes a numerical argument");
	}
@


1.29
log
@make HISTORY_ONLY work again... I managed to break it twice :)
@
text
@d2 1
a2 1
# $OpenBSD: Config.pm,v 1.28 2014/03/17 10:48:40 espie Exp $
a349 74
}

package DPB::HostProperties;

my $has_sf = 0;
my $has_mem = 0;
my $sf;

sub new
{
	my ($class, $default) = @@_;
	$default //= {};
	bless {%$default}, $class;
}

sub add_overrides
{
	my ($prop, $override) = @@_;
	while (my ($k, $v) = each %$override) {
		$prop->{$k} = $v;
	}
	$sf //= $prop->{sf};
	if (defined $prop->{sf} && $prop->{sf} != $sf) {
		$has_sf = 1;
	}
}

sub has_sf
{
	return $has_sf;
}

sub has_mem
{
	return $has_mem;
}

my $default_user;
sub finalize
{
	my ($class, $prop) = @@_;
	$prop->{sf} //= 1;
	$prop->{umask} //= sprintf("0%o", umask);
	if (defined $prop->{stuck}) {
		$prop->{stuck_timeout} = $prop->{stuck} * $prop->{sf};
	}
	if (defined $prop->{mem}) {
		$prop->{memory} = $prop->{mem};
	}
	if (defined $prop->{chroot}) {
		if ($prop->{chroot} eq '/' || $prop->{chroot} eq '') {
			delete $prop->{chroot};
		} else {
			if (!defined $prop->{chroot_user}) {
				$prop->{chroot_user} = $prop->{user};
			}
		}
	}
	if (defined $prop->{memory}) {
		my $m = $prop->{memory};
		if ($m =~ s/K$//) {
		} elsif ($m =~ s/M$//) {
			$m *= 1024;
		} elsif ($m =~ s/G$//) {
			$m *= 1024 * 1024;
		}
		$prop->{memory} = $m;
		if ($prop->{memory} > 0) {
			$has_mem = 1;
		}
	}
	$prop->{small} //= 120;
	$prop->{small_timeout} = $prop->{small} * $prop->{sf};
	return $prop;
@


1.28
log
@prepare for perl 5.18
- don't bother declaring $_ for while(<>) loops. assume current default
will still work.
- rename variable for readability elsewhere.
@
text
@d2 1
a2 1
# $OpenBSD: Config.pm,v 1.27 2014/03/09 19:47:35 espie Exp $
d129 1
a191 10
	if (!$state->{subst}->empty('HISTORY_ONLY')) {
		$state->{want_fetchinfo} = 1;
		$state->{opt}{f} = 0;
		$state->{opt}{j} = 1;
		$state->{opt}{e} = 1;
		$state->{all} = 1;
		$state->{scan_only} = 1;
		# XXX not really random, but no need to use dependencies
		$state->{random} = 1;
	}
d236 10
@


1.27
log
@restore BUILD_ONCE optimization for full ports builds
@
text
@d2 1
a2 1
# $OpenBSD: Config.pm,v 1.26 2014/01/10 11:26:43 espie Exp $
a321 1
	my $_;
d334 2
a335 2
		for my $_ (@@properties) {
			if (m/^(.*?)=(.*)$/) {
d408 6
a413 6
		my $_ = $prop->{memory};
		if (s/K$//) {
		} elsif (s/M$//) {
			$_ *= 1024;
		} elsif (s/G$//) {
			$_ *= 1024 * 1024;
d415 1
a415 1
		$prop->{memory} = $_;
@


1.26
log
@parse SIGNING_PARAMETERS, use it to match -DSIGNER and pass that to pkg_add
accordingly
@
text
@d2 1
a2 1
# $OpenBSD: Config.pm,v 1.25 2013/12/30 12:28:23 espie Exp $
a223 1
	$state->{build_once} = $state->{all};
@


1.25
log
@Add -Dunsigned while building, unless we are in an environment where we
sign packages by default.
@
text
@d2 1
a2 1
# $OpenBSD: Config.pm,v 1.24 2013/11/17 09:43:09 espie Exp $
d88 3
a90 1
		$state->{allow_unsigned} = 1;
@


1.24
log
@libdir based on experimental xenocara support
@
text
@d2 1
a2 1
# $OpenBSD: Config.pm,v 1.23 2013/11/16 13:06:00 espie Exp $
d76 1
d78 1
a78 1
	    $state->{distdir}, $state->{localbase}, $state->{xenocara}) =
d83 1
a83 1
		"PORTS_BUILD_XENOCARA_TOO");
d86 3
@


1.23
log
@add/read timestamps to rolling logs, so that eventually old stuff gets
removed.

alias -DSTARTUP/-DCLEANUP, since I keep mixing up the two.
@
text
@d2 1
a2 1
# $OpenBSD: Config.pm,v 1.22 2013/10/27 09:26:01 espie Exp $
d77 1
a77 1
	    $state->{distdir}, $state->{localbase}) =
d81 10
a90 1
		"MACHINE_ARCH", "DISTDIR", "LOCALBASE");
@


1.22
log
@rearrange a few things to get direct access to whoami.
@
text
@d2 1
a2 1
# $OpenBSD: Config.pm,v 1.21 2013/10/17 14:20:44 espie Exp $
d124 2
@


1.21
log
@forgot to un-anchor fullrepo.
also, fetch jobs are always local and *never* chroot'd, turns out.
@
text
@d2 1
a2 1
# $OpenBSD: Config.pm,v 1.20 2013/10/17 12:48:09 espie Exp $
d69 7
d78 1
a78 1
		DPB::Vars->get(DPB::Host::Localhost->getshell($state->{chroot}), 
d225 5
d388 1
a388 4
				if (!defined $default_user) {
					$default_user = `whoami`;
					chomp($default_user);
				}
a389 1
			$prop->{chroot_user} = $default_user;
@


1.20
log
@a bit more flesh for chroot, run getvars in chroot, possibly (as root, but
we don't really care), and apply some schizophreny to stuff that runs outside
the chroot.

(probably not complete yet, ssh master trouble)
@
text
@d2 1
a2 1
# $OpenBSD: Config.pm,v 1.19 2013/10/17 08:12:28 espie Exp $
d209 1
a209 1
    	$state->{fullrepo} = $state->anchor(join("/", $state->{repo}, $state->arch, "all"));
@


1.19
log
@do a few things later (preparing for -B)
Core::Init knows its hosts, so use that
knowledge to better separate Heuristics handling
@
text
@d2 1
a2 1
# $OpenBSD: Config.pm,v 1.18 2013/10/14 12:14:33 espie Exp $
d68 1
d71 2
a72 1
		DPB::Vars->get(DPB::Shell::Local->new, $state->make,
d76 2
a77 1
	$state->{portspath} = [ split(/:/, $state->{portspath}) ];
d96 1
d209 1
a209 1
    	$state->{fullrepo} = join("/", $state->{repo}, $state->arch, "all");
@


1.18
log
@simplify -F mode. Now we have a specific NoBuild class, it's simpler
to just say our build queue is always empty, rather than constrain the
number of build jobs artificially.

and so, we have actual build jobs that will only rebuild info and trigger
quickly, so it's no longer necessary to allow fetch jobs to do so.

prompted by a bug-report from rpe@@
@
text
@d2 1
a2 1
# $OpenBSD: Config.pm,v 1.17 2013/10/13 18:31:50 espie Exp $
d68 7
a74 1
    	$state->{fullrepo} = join("/", $state->{repo}, $state->arch, "all");
a99 1
	$state->{size_log} = "%f/build-stats/%a-size";
d109 2
d205 1
d316 1
a316 2
		$state->heuristics->calibrate(DPB::Core::Init->new($host,
		    $prop));
@


1.17
log
@- use separated Heuristics::Size object
- choose size/nosize in Config.
- use affinity or affinitystub
- move locker creation to State, so we can init cores right away.
- as core init has run, we can call DPB::Core->reap (event loop) while
processing size and build stats, so that the startup script may start
slightly earlier.
- setup more options in Config for Reporter to use.
- scaffolding in SubEngine/Build to be able to use affinity info right away
@
text
@d2 1
a2 1
# $OpenBSD: Config.pm,v 1.16 2013/10/13 10:34:55 espie Exp $
a76 2
		$state->{opt}{j} = 1;
		$state->{opt}{e} = 1;
@


1.16
log
@more sensible defaults: if at least one host uses mem, turn on WANTSIZE,
unless we explicitly turn that off.
@
text
@d2 1
a2 1
# $OpenBSD: Config.pm,v 1.15 2013/10/07 20:01:55 espie Exp $
d118 13
@


1.15
log
@revisit, fetch cores MUST be pre-emptable for rebuilding-info,
otherwise pure -F fetch engine loses !
@
text
@d2 1
a2 1
# $OpenBSD: Config.pm,v 1.14 2013/10/07 19:27:25 espie Exp $
d112 3
a114 1
	if ($state->define_present('WANTSIZE')) {
d116 2
a136 3
	if ($state->{opt}{s}) {
		$state->{wantsize} = 1;
	}
d305 1
d332 5
d371 3
@


1.14
log
@no need to give back the extra job in fetch_only now,
as it's not going to get used by the builder.
@
text
@d2 1
a2 1
# $OpenBSD: Config.pm,v 1.13 2013/10/06 13:33:28 espie Exp $
d78 1
@


1.13
log
@update my copyright to 2013
@
text
@d2 1
a2 1
# $OpenBSD: Config.pm,v 1.12 2013/10/02 09:13:27 espie Exp $
a77 1
		$state->{opt}{e} = 1;
@


1.12
log
@turn on recorder by default
@
text
@d2 1
a2 1
# $OpenBSD: Config.pm,v 1.11 2013/09/25 07:01:35 espie Exp $
d4 1
a4 1
# Copyright (c) 2010 Marc Espie <espie@@openbsd.org>
@


1.11
log
@let RECORD be subject to expand_path and normal parameters handling
@
text
@d2 1
a2 1
# $OpenBSD: Config.pm,v 1.10 2013/09/23 14:25:13 espie Exp $
d159 1
a159 1
		$state->{record} = $state->expand_path($state->{subst}->value("RECORD"));
d161 2
@


1.10
log
@option: record terminal display, so that I can watch it later at hispeed...
@
text
@d2 1
a2 1
# $OpenBSD: Config.pm,v 1.9 2013/09/21 08:56:43 espie Exp $
a108 3
	if ($state->define_present("RECORD")) {
		$state->{record} = $state->{subst}->value("RECORD");
	}
d158 3
@


1.9
log
@new properties: repair and nochecksum (on by default)
control aspects of pkg_delete/pkg_add runs
@
text
@d2 1
a2 1
# $OpenBSD: Config.pm,v 1.8 2013/09/18 13:07:32 espie Exp $
d108 3
@


1.8
log
@chroot=
or
chroot=/
mean no chroot.
@
text
@d2 1
a2 1
# $OpenBSD: Config.pm,v 1.7 2013/09/14 09:42:11 espie Exp $
d241 2
@


1.7
log
@remove remains of nfs wait_timeout.
@
text
@d2 1
a2 1
# $OpenBSD: Config.pm,v 1.6 2013/09/11 10:44:13 espie Exp $
d336 8
a343 4
		if (!defined $prop->{chroot_user}) {
			if (!defined $default_user) {
				$default_user = `whoami`;
				chomp($default_user);
d345 1
a346 1
		$prop->{chroot_user} = $default_user;
@


1.6
log
@next step in chrooting, mostly refactor
- provide a chroot_user definition during prop finalize
- let shellclass be depend on the object built
- have all shells store prop and have access to it
- move the chrooted code into default core shell
- tweak running so that quoting/building commands happen everywhere
- change Config to recognize -B as a chroot override.

Tested thru distant chroot, local and distant !chroot
local chroot still not working, probably missing something stupid
@
text
@d2 1
a2 1
# $OpenBSD: Config.pm,v 1.5 2013/07/05 13:49:50 pirofti Exp $
a213 4
	if ($state->define_present('WAIT_TIMEOUT')) {
		$override_prop->{wait_timeout} = 
		    $state->{subst}->value('WAIT_TIMEOUT');
	}
a239 1
		wait_timeout => 600,
@


1.5
log
@Synchronize the synopsis with the usage.

Comments and okay espie@@.
@
text
@d2 1
a2 1
# $OpenBSD: Config.pm,v 1.4 2013/06/23 13:19:33 espie Exp $
d63 5
a67 4
	$state->SUPER_handle_options('acemqrRstuUvh:S:xX:A:C:f:F:I:j:J:M:p:P:b:l:L:',
    "[-acemqrRsuUvx] [-A arch] [-C plist] [-f m] [-F m] [-I pathlist] [-J p]",
    "[-j n] [-p parallel] [-P pathlist] [-h hosts] [-L logdir] [-l lockdir]",
    "[-b log] [-M threshold] [-X pathlist] [pathlist ...]");
d195 3
d328 1
d339 9
@


1.4
log
@fix permanent log
@
text
@d2 1
a2 1
# $OpenBSD: Config.pm,v 1.3 2013/06/22 09:16:36 espie Exp $
d64 3
a66 3
    "[-acemrRsuUvx] [-A arch] [-C plist] [-f N] [-F N] [-I plist] [-J p] [-j N]",
    "[-p parallel] [-P plist] [-h hosts] [-L logdir] [-l lockdir] [-b log]",
    "[-M threshold] [-X plist] [path ...]");
@


1.3
log
@typo, broke sthen@@'s run
@
text
@d2 1
a2 1
# $OpenBSD: Config.pm,v 1.2 2013/06/21 23:13:37 espie Exp $
a161 1
	$state->{permanent_log} = $state->{build_files}[-1];
d168 1
@


1.2
log
@reorganize option and config file parsing slightly so that variable
values can be in config files.
command line should still override config files.
to be documented shortly, but stuff like
FETCH_JOBS=n
WANTSIZE=1
MIRROR=0

should now work within a hosts file.
@
text
@d2 1
a2 1
# $OpenBSD: Config.pm,v 1.1 2013/06/21 09:05:18 espie Exp $
d127 1
a127 1
		$state->{logdir} = $state->{flockdir};
@


1.1
log
@disentangle the config/init code from the rest.

- move the meat of handle_options from dpb into config->parse_command_line
(this means a backcall to still inherit from OpenBSD::State).
- move parse_config_files from core into config.
- move the prop handling into proper HostProperties (part of config
obviously)
- create a Core::Init file that contains all the former DPB::Host::Factory
and associated jobs.

there's still a wee little bit of cleanup to do, but this should be
easier to maintain, as all option handling is now in one place, and
startup and host confi is now easier to figure out.

- add a -DMIRROR=0/1  setup that controls whether SUPDISTFILES will be
fetched (defaults to 1 for -F and 0 for -f).

- actually allow for several host files to be parsed, as the name implies
@
text
@d2 1
a2 1
# $OpenBSD: dpb,v 1.91 2013/06/04 03:20:36 espie Exp $
d34 1
a34 1
			$state->{logdir} = shift;
d37 1
a37 1
			$state->{lockdir} = shift;
d68 2
a69 2
	$state->{logdir} //= $ENV{LOGDIR} // '%p/logs/%a';
	$state->{lockdir} //= "%L/locks";
a78 1
	$state->{opt}{f} //= 2;
d88 49
d154 1
a154 3
	if ($state->opt('t')) {
		$state->{tests} = 1;
	}
d156 2
d162 2
a163 4
#	if (!$state->{xpaths}) {
#		$state->{xpaths} = ["%p/infrastructure/db/precious"];
#	}
	for my $cat (qw(build_files config_files paths ipaths cpaths xpaths)) {
a168 4
	$state->{size_log} = "%f/build-stats/%a-size";

	$state->{permanent_log} = $state->{build_files}[-1];
	$state->{size_log} = $state->expand_path($state->{size_log});
a179 1
	$class->parse_config_files($state);
d270 2
a271 2
		if (m/^STARTUP=\s*(.*)\s*$/) {
			$state->{startup_script} = $1;
a273 3
		if (m/^LOGSIZE=\s*1\s*$/) {
			$state->{opt}{s} = 1;
		}
a291 3
	}
	if ($state->define_present("STARTUP")) {
		$state->{startup_script} = $state->{subst}->value("STARTUP");
@

