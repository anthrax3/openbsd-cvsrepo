head	1.12;
access;
symbols
	OPENBSD_6_1:1.10.0.10
	OPENBSD_6_1_BASE:1.10
	OPENBSD_6_0:1.10.0.8
	OPENBSD_6_0_BASE:1.10
	OPENBSD_5_9:1.10.0.4
	OPENBSD_5_9_BASE:1.10
	OPENBSD_5_8:1.10.0.6
	OPENBSD_5_8_BASE:1.10
	OPENBSD_5_7:1.10.0.2
	OPENBSD_5_7_BASE:1.10
	OPENBSD_5_6:1.9.0.4
	OPENBSD_5_6_BASE:1.9
	OPENBSD_5_5:1.9.0.2
	OPENBSD_5_5_BASE:1.9
	OPENBSD_5_4:1.7.0.2
	OPENBSD_5_4_BASE:1.7
	OPENBSD_5_3:1.5.0.2
	OPENBSD_5_3_BASE:1.5
	OPENBSD_5_2:1.2.0.6
	OPENBSD_5_2_BASE:1.2
	OPENBSD_5_1_BASE:1.2
	OPENBSD_5_1:1.2.0.4
	OPENBSD_5_0:1.2.0.2
	OPENBSD_5_0_BASE:1.2
	OPENBSD_4_9:1.1.1.1.0.2
	OPENBSD_4_9_BASE:1.1.1.1
	ports:1.1.1.1
	espie:1.1.1;
locks; strict;
comment	@# @;


1.12
date	2017.06.20.15.46.18;	author espie;	state Exp;
branches;
next	1.11;
commitid	5GHCGmZGEX7eCk2a;

1.11
date	2017.04.14.16.43.40;	author espie;	state Exp;
branches;
next	1.10;
commitid	xYf84gmn0uJCiE0i;

1.10
date	2014.12.07.15.18.50;	author espie;	state Exp;
branches;
next	1.9;
commitid	GynqjLfrNHwgIuss;

1.9
date	2013.10.06.13.33.31;	author espie;	state Exp;
branches;
next	1.8;

1.8
date	2013.09.16.11.23.50;	author espie;	state Exp;
branches;
next	1.7;

1.7
date	2013.06.30.16.35.43;	author espie;	state Exp;
branches;
next	1.6;

1.6
date	2013.04.13.10.04.43;	author espie;	state Exp;
branches;
next	1.5;

1.5
date	2013.01.05.21.48.18;	author espie;	state Exp;
branches;
next	1.4;

1.4
date	2013.01.05.17.22.04;	author espie;	state Exp;
branches;
next	1.3;

1.3
date	2012.10.12.20.24.56;	author espie;	state Exp;
branches;
next	1.2;

1.2
date	2011.06.04.12.58.24;	author espie;	state Exp;
branches;
next	1.1;

1.1
date	2010.08.20.13.40.13;	author espie;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2010.08.20.13.40.13;	author espie;	state Exp;
branches;
next	;


desc
@@


1.12
log
@move redirect to UserProxy and introduce write_error.
redirect is only called thru a user, so have the error message be
more helpful in telling which user can't perform the redirect.
likewise, write_error should tell which user is involved.
don't wrap redirect_fh in run_as, because we're not opening any
new file.
@
text
@# ex:ts=8 sw=4:
# $OpenBSD: Job.pm,v 1.11 2017/04/14 16:43:40 espie Exp $
#
# Copyright (c) 2010-2013 Marc Espie <espie@@openbsd.org>
#
# Permission to use, copy, modify, and distribute this software for any
# purpose with or without fee is hereby granted, provided that the above
# copyright notice and this permission notice appear in all copies.
#
# THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
# ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
# OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
use strict;
use warnings;
use DPB::Util;

# a "job" is the actual stuff a core runs at some point.
# it's mostly an abstract class here... it's organized
# as a list of tasks, with a finalization routine
package DPB::Task;
sub end
{
}

sub code
{
	my $self = shift;
	return $self->{code};
}

# no name by default, just display the object
sub name
{
	return shift;
}

sub new
{
	my ($class, $code) = @@_;
	bless {code => $code}, $class;
}

sub run
{
	my ($self, $core) = @@_;
	&{$self->code($core)}($core->shell);
}

sub process
{
	my ($self, $core) = @@_;
}

sub finalize
{
	my ($self, $core) = @@_;
	return $core->{status} == 0;
}

sub redirect_fh
{
	my ($self, $fh, $log) = @@_;
	close STDOUT;
	open STDOUT, '>&', $fh or DPB::Util->die_bang("Can't write to $log");
	close STDERR;
	open STDERR, '>&STDOUT' or DPB::Util->die_bang("bad redirect");
}

package DPB::Task::Pipe;
our @@ISA =qw(DPB::Task);

sub fork
{
	my $self = shift;
	open($self->{fh}, "-|");
}

sub end
{
	my $self = shift;
	close($self->{fh});
}


package DPB::Task::Fork;
our @@ISA =qw(DPB::Task);
sub fork
{
	CORE::fork();
}

package DPB::Job;
sub next_task
{
	my ($self, $core) = @@_;
	return shift @@{$self->{tasks}};
}

sub name
{
	my $self = shift;
	return $self->{name};
}

sub debug_dump
{
	my $self = shift;
	return $self->{name};
}

sub finalize
{
}

sub watched
{
	my $self = shift;
	return $self->{status};
}

# abstract method, to be used by jobs that have actual watch limits
sub kill_on_timeout
{
	my ($self, $diff, $core, $msg) = @@_;
	my $to = $self->get_timeout($core);
	return $msg if !defined $to || $diff <= $to;
	local $> = 0;	# XXX switch to root, we don't know for sure which
			# user owns the pid (not really an issue)
	kill 9, $core->{pid};
	return $self->{stuck} = "KILLED: $self->{current} stuck at $msg";
}

sub add_tasks
{
	my ($self, @@tasks) = @@_;
	push(@@{$self->{tasks}}, @@tasks);
}

sub replace_tasks
{
	my ($self, @@tasks) = @@_;
	$self->{tasks} = [];
	push(@@{$self->{tasks}}, @@tasks);
}

sub insert_tasks
{
	my ($self, @@tasks) = @@_;
	unshift(@@{$self->{tasks}}, @@tasks);
}

sub really_watch
{
}

sub new
{
	my ($class, $name) = @@_;
	bless {name => $name, status => ""}, $class;
}

sub set_status
{
	my ($self, $status) = @@_;
	$self->{status} = $status;
}

package DPB::Job::Normal;
our @@ISA =qw(DPB::Job);

sub new
{
	my ($class, $code, $endcode, $name) = @@_;
	my $o = $class->SUPER::new($name);
	$o->{tasks} = [DPB::Task::Fork->new($code)];
	$o->{endcode} = $endcode;
	return $o;
}

sub finalize
{
	my $self = shift;
	&{$self->{endcode}}(@@_);
}

package DPB::Job::Infinite;
our @@ISA = qw(DPB::Job);
sub next_task
{
	my $job = shift;
	return $job->{task};
}

sub new
{
	my ($class, $task, $name) = @@_;
	my $o = $class->SUPER::new($name);
	$o->{task} = $task;
	return $o;
}

package DPB::Job::Pipe;
our @@ISA = qw(DPB::Job);
sub new
{
	my ($class, $code, $name) = @@_;
	my $o = $class->SUPER::new($name);
	$o->{tasks} = [DPB::Task::Pipe->new($code)];
	return $o;
}

1;
@


1.11
log
@have both log watching jobs actually share the timeout code.
If I had done this before, I would have fixed kill just once after privsep
and not inadvertently broken the builder stuck timeout...

problem noticed by naddy@@
@
text
@d2 1
a2 1
# $OpenBSD: Job.pm,v 1.10 2014/12/07 15:18:50 espie Exp $
a61 9
}

sub redirect
{
	my ($self, $log) = @@_;
	close STDOUT;
	open STDOUT, '>>', $log or DPB::Util->die_bang("Can't write to $log");
	close STDERR;
	open STDERR, '>&STDOUT' or DPB::Util->die_bang("bad redirect");
@


1.10
log
@wrap die so that it drops into the debugger if we run under perl -d.

change the way we do rescans again, to avoid race conditions:
just store away *all* pkgpaths related to the rescan (so that multi-packages
are covered) and then do the rescan. Hold those like we do for normal locks
but in a different list, and release them when the scan is over.

remove the atrocious shennanigans wrt fullpkgnames, it shouldn't be needed
again, hopefully.
@
text
@d2 1
a2 1
# $OpenBSD: Job.pm,v 1.9 2013/10/06 13:33:31 espie Exp $
d132 12
@


1.9
log
@update my copyright to 2013
@
text
@d2 1
a2 1
# $OpenBSD: Job.pm,v 1.8 2013/09/16 11:23:50 espie Exp $
d19 1
d68 1
a68 1
	open STDOUT, '>>', $log or die "Can't write to $log";
d70 1
a70 1
	open STDERR, '>&STDOUT' or die "bad redirect";
d77 1
a77 1
	open STDOUT, '>&', $fh or die "Can't write to $log";
d79 1
a79 1
	open STDERR, '>&STDOUT' or die "bad redirect";
@


1.8
log
@move the shell running code up to host. Makes no sense to have the same
data structure for each Core, and a lot of this is actually tied to the
host proper.

(note that Core::Distant no longer makes a lot of sense)
@
text
@d2 1
a2 1
# $OpenBSD: Job.pm,v 1.7 2013/06/30 16:35:43 espie Exp $
d4 1
a4 1
# Copyright (c) 2010 Marc Espie <espie@@openbsd.org>
@


1.7
log
@temporary patch: when always clean, remove the tasks we wanted to run.
(need to address the recording of errors from some tasks in a more proper
way and deal with nfs better)
@
text
@d2 1
a2 1
# $OpenBSD: Job.pm,v 1.6 2013/04/13 10:04:43 espie Exp $
d49 1
a49 1
	&{$self->code($core)}($core->{shell});
@


1.6
log
@display a bit more post-mortem info, show the Core<->current job info.
@
text
@d2 1
a2 1
# $OpenBSD: Job.pm,v 1.5 2013/01/05 21:48:18 espie Exp $
d136 7
@


1.5
log
@give every task a "name".
@
text
@d2 1
a2 1
# $OpenBSD: Job.pm,v 1.4 2013/01/05 17:22:04 espie Exp $
d112 6
@


1.4
log
@avoid opening filehandle again and again.
also, close STDERR after the STDOUT stuff was done, so that we get
error messages otherwise!
@
text
@d2 1
a2 1
# $OpenBSD: Job.pm,v 1.3 2012/10/12 20:24:56 espie Exp $
d32 6
@


1.3
log
@-DALWAYS_CLEAN: clean ports even if they errored out (that's a prop, so
always_clean=1  in hosts file.

refactor task code a bit. And fix a buglet related to the NFS check
(wrong finalize order)
@
text
@d2 1
a2 1
# $OpenBSD: Job.pm,v 1.2 2011/06/04 12:58:24 espie Exp $
d61 10
a71 1
	open STDOUT, '>>', $log or die "Can't write to $log";
@


1.2
log
@spaces
@
text
@d2 1
a2 1
# $OpenBSD$
d116 6
@


1.1
log
@Initial revision
@
text
@d2 1
a2 1
# $OpenBSD: Job.pm,v 1.7 2010/05/04 09:45:41 espie Exp $
@


1.1.1.1
log
@move stuff here from infra/build
@
text
@@
