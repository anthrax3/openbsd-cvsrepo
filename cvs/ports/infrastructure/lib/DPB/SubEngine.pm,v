head	1.25;
access;
symbols
	OPENBSD_6_0:1.25.0.6
	OPENBSD_6_0_BASE:1.25
	OPENBSD_5_9:1.25.0.2
	OPENBSD_5_9_BASE:1.25
	OPENBSD_5_8:1.25.0.4
	OPENBSD_5_8_BASE:1.25
	OPENBSD_5_7:1.21.0.2
	OPENBSD_5_7_BASE:1.21
	OPENBSD_5_6:1.20.0.2
	OPENBSD_5_6_BASE:1.20
	OPENBSD_5_5:1.19.0.2
	OPENBSD_5_5_BASE:1.19;
locks; strict;
comment	@# @;


1.25
date	2015.06.22.12.18.50;	author espie;	state Exp;
branches;
next	1.24;
commitid	OvFFSX5Ca01e0jwt;

1.24
date	2015.06.17.07.31.25;	author espie;	state Exp;
branches;
next	1.23;
commitid	IEMN3P1HNIr1q6Tn;

1.23
date	2015.06.08.11.06.08;	author espie;	state Exp;
branches;
next	1.22;
commitid	UFmzyzpqKmldAIst;

1.22
date	2015.04.25.12.43.32;	author jasper;	state Exp;
branches;
next	1.21;
commitid	mCYamTFujCHD7RcX;

1.21
date	2014.12.07.15.18.50;	author espie;	state Exp;
branches;
next	1.20;
commitid	GynqjLfrNHwgIuss;

1.20
date	2014.03.09.20.15.10;	author espie;	state Exp;
branches;
next	1.19;

1.19
date	2013.10.19.08.41.29;	author espie;	state Exp;
branches;
next	1.18;

1.18
date	2013.10.18.19.21.04;	author espie;	state Exp;
branches;
next	1.17;

1.17
date	2013.10.17.08.32.37;	author espie;	state Exp;
branches;
next	1.16;

1.16
date	2013.10.14.12.14.33;	author espie;	state Exp;
branches;
next	1.15;

1.15
date	2013.10.09.06.20.57;	author espie;	state Exp;
branches;
next	1.14;

1.14
date	2013.10.07.20.23.13;	author espie;	state Exp;
branches;
next	1.13;

1.13
date	2013.10.07.20.01.55;	author espie;	state Exp;
branches;
next	1.12;

1.12
date	2013.10.07.18.01.33;	author espie;	state Exp;
branches;
next	1.11;

1.11
date	2013.10.06.15.49.23;	author espie;	state Exp;
branches;
next	1.10;

1.10
date	2013.10.06.13.48.27;	author espie;	state Exp;
branches;
next	1.9;

1.9
date	2013.10.06.13.33.35;	author espie;	state Exp;
branches;
next	1.8;

1.8
date	2013.10.06.13.22.20;	author espie;	state Exp;
branches;
next	1.7;

1.7
date	2013.10.06.12.40.43;	author espie;	state Exp;
branches;
next	1.6;

1.6
date	2013.10.04.11.26.15;	author espie;	state Exp;
branches;
next	1.5;

1.5
date	2013.10.03.17.42.58;	author espie;	state Exp;
branches;
next	1.4;

1.4
date	2013.10.03.13.12.28;	author espie;	state Exp;
branches;
next	1.3;

1.3
date	2013.10.03.12.55.44;	author espie;	state Exp;
branches;
next	1.2;

1.2
date	2013.10.03.12.46.51;	author espie;	state Exp;
branches;
next	1.1;

1.1
date	2013.10.03.08.03.27;	author espie;	state Exp;
branches;
next	;


desc
@@


1.25
log
@expand on comments
@
text
@# ex:ts=8 sw=4:
# $OpenBSD: SubEngine.pm,v 1.24 2015/06/17 07:31:25 espie Exp $
#
# Copyright (c) 2010 Marc Espie <espie@@openbsd.org>
#
# Permission to use, copy, modify, and distribute this software for any
# purpose with or without fee is hereby granted, provided that the above
# copyright notice and this permission notice appear in all copies.
#
# THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
# ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
# OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

use strict;
use warnings;

package DPB::SubEngine;
sub new
{
	my ($class, $engine) = @@_;
	bless { engine => $engine, queue => $class->new_queue($engine),
		doing => {}, later => {}}, $class;
}

# the 'detain' mechanism:
# when rescanning ports, we wipe out the old info.
# stuff that's already in the queues is thus incomplete (no pkgnames,
# no sha info). Instead of going thru the whole process of registering
# them again, we use detain/release, and the subengines skip over detained
# stuff.

sub detain
{
	my ($self, $v) = @@_;
	$self->{detained}{$self->key_for_doing($v)} = 1;
}

sub release
{
	my ($self, $v) = @@_;
	my $k = $self->key_for_doing($v);
	delete $self->{detained}{$k};
	for my $candidate (values %{$self->{later2}}) {
		if ($self->key_for_doing($candidate) eq $k) {
			delete $self->{later2}{$candidate};
			$self->log('x', $candidate);
			$self->add($candidate);
		}
	}
}

sub detained
{
	my ($self, $v) = @@_;
	return $self->{detained}{$self->key_for_doing($v)};
}

sub count
{
	my $self = shift;
	return $self->{queue}->count;
}

sub add
{
	my ($self, $v) = @@_;
	$self->{queue}->add($v);
}

sub remove
{
	my ($self, $v) = @@_;
	$self->{queue}->remove($v);
}

sub is_done_quick
{
	my $self = shift;
	return $self->is_done(@@_);
}

sub is_done_or_enqueue
{
	my $self =shift;
	return $self->is_done(@@_);
}

sub sorted
{
	my ($self, $core) = @@_;
	return $self->{queue}->sorted($core);
}

sub non_empty
{
	my $self = shift;
	return $self->{queue}->non_empty;
}

sub contains
{
	my ($self, $v) = @@_;
	return $self->{queue}->contains($v);
}

sub log
{
	my ($self, @@r) = @@_;
	return $self->{engine}->log(@@r);
}

sub key_for_doing
{
	my ($self, $v) = @@_;
	return $v;
}

sub already_done
{
}

sub lock_and_start_build
{
	my ($self, $core, $v) = @@_;

	$self->remove($v);

	if (my $lock = $self->{engine}{locker}->lock($v)) {
		$self->{doing}{$self->key_for_doing($v)} = 1;
		$self->start_build($v, $core, $lock);
		return 1;
	} else {
		push(@@{$self->{engine}{locks}}, $v);
		$self->log('L', $v);
		return 0;
	}
}

sub use_core
{
	my ($self, $core) = @@_;
	if ($self->preempt_core($core)) {
		return 1;
	}

	my $o = $self->sorted($core);

	# first pass, try to find something we can build
	while (my $v = $o->next) {
		next if $self->detained($v);
		# trim stuff that's done
		if ($self->is_done($v)) {
			$self->already_done($v);
			$self->done($v);
		} elsif ($self->can_really_start_build($v, $core)) {
			return 1;
		}
	}
	if ($self->recheck_mismatches($core)) {
		return 1;
	}
	return 0;
}

sub can_really_start_build
{
	my ($self, $v, $core) = @@_;
	# ... trim stuff that's related to other stuff building
	if ($self->{doing}{$self->key_for_doing($v)}) {
		$self->remove($v);
		$self->{later}{$v} = $v;
		$self->log('^', $v);
		return 0;
	# as well as stuff that's getting rescanned
	} elsif ($self->detained($v)) {
		$self->remove($v);
		$self->{later2}{$v} = $v;
		$self->log('X', $v);
		return 0;
	} else {
		return $self->can_start_build($v, $core);
	}
}

sub start
{
	my $self = shift;
	my $core = $self->get_core;

	if ($self->use_core($core)) {
		return 1;
	} else {
		$core->mark_ready;
		return 0;
	}
}

sub preempt_core
{
	return 0;
}

sub can_start_build
{
	my ($self, $v, $core) = @@_;

	return $self->lock_and_start_build($core, $v);
}

sub recheck_mismatches
{
	return 0;
}

sub done
{
	my ($self, $v) = @@_;
	my $k = $self->key_for_doing($v);
	for my $candidate (values %{$self->{later}}) {
		if ($self->key_for_doing($candidate) eq $k) {
			delete $self->{later}{$candidate};
			$self->log('V', $candidate);
			$self->add($candidate);
		}
	}
	delete $self->{doing}{$self->key_for_doing($v)};
	$self->{engine}->recheck_errors;
}

sub end
{
	my ($self, $core, $v, $fail) = @@_;
	my $e = $core->mark_ready;
	if ($fail) {
		$core->failure;
		if (!$e || $core->{status} == 65280) {
			$self->add($v);
			$self->{engine}{locker}->unlock($v);
			$self->log('N', $v);
		} else {
			# XXX in case some packages got built
			$self->is_done($v);
			unshift(@@{$self->{engine}{errors}}, $v);
			$v->{host} = $core->host;
			$self->log('E', $v);
			if ($core->prop->{always_clean}) {
				$self->end_build($v);
			}
		}
	} else {
		if ($self->is_done_or_enqueue($v)) {
			$self->{engine}{locker}->unlock($v);
		} else {
			push(@@{$self->{engine}{nfslist}}, $v);
		}
		$self->end_build($v);
		$core->success;
	}
	$self->done($v);
	$self->{engine}->flush;
}

sub dump
{
	my ($self, $k, $fh) = @@_;
#	$self->{queue}->dump($k, $fh);
}

package DPB::SubEngine::BuildBase;
our @@ISA = qw(DPB::SubEngine);

sub new_queue
{
	my ($class, $engine) = @@_;
	return $engine->{heuristics}->new_queue;
}

sub new
{
	my ($class, $engine, $builder) = @@_;
	my $o = $class->SUPER::new($engine, $builder);
	$o->{builder} = $builder;
	return $o;
}

sub get_core
{
	my $self = shift;
	return $self->{builder}->get;
}

sub preempt_core
{
	my ($self, $core) = @@_;

	if (@@{$self->{engine}{requeued}} > 0) {
		# XXX note this borrows the core temporarily
		$self->{engine}->rebuild_info($core);
	}
	return 0;
}

# for fetch-only, the engine is *very* abreviated
package DPB::SubEngine::NoBuild;
our @@ISA = qw(DPB::SubEngine::BuildBase);
sub non_empty
{
	return 0;
}

sub is_done
{
	return 0;
}

sub start_build
{
	return 0;
}

1;
@


1.24
log
@do detain distfiles as well as paths (need to track them over rescan)
also, since distfiles are "always fetchable", need to check for detained
files before checking for "already done", since already done will want to
check the size...
@
text
@d2 1
a2 1
# $OpenBSD: SubEngine.pm,v 1.23 2015/06/08 11:06:08 espie Exp $
d29 7
d178 1
@


1.23
log
@fix long-standing race condition where removing a lock could break things.
That's just more stuff that has to wait while scanning is going on.
@
text
@d2 1
a2 1
# $OpenBSD: SubEngine.pm,v 1.22 2015/04/25 12:43:32 jasper Exp $
d147 1
@


1.22
log
@provide a dummy start_build() for DPB::SubEngine::NoBuild; this prevents a
crash when removing a lockfile in a fetch-only (nobuild) run.

ok espie@@
@
text
@d2 1
a2 1
# $OpenBSD: SubEngine.pm,v 1.21 2014/12/07 15:18:50 espie Exp $
d49 6
d170 1
a170 1
	} elsif ($self->{detained}{$self->key_for_doing($v)}) {
@


1.21
log
@wrap die so that it drops into the debugger if we run under perl -d.

change the way we do rescans again, to avoid race conditions:
just store away *all* pkgpaths related to the rescan (so that multi-packages
are covered) and then do the rescan. Hold those like we do for normal locks
but in a different list, and release them when the scan is over.

remove the atrocious shennanigans wrt fullpkgnames, it shouldn't be needed
again, hopefully.
@
text
@d2 1
a2 1
# $OpenBSD: SubEngine.pm,v 1.20 2014/03/09 20:15:10 espie Exp $
d301 5
@


1.20
log
@path normalization: introduce can_really_start_build
that handles held locks, and starts build.

Specialize it for  normal builds to remove all build_path_list elements
at once, and choose the smallest one.

in all, this means that the logs will show less variety in what they
build, thus giving better statistics earlier.
@
text
@d2 1
a2 1
# $OpenBSD: SubEngine.pm,v 1.19 2013/10/19 08:41:29 espie Exp $
d29 20
d163 5
@


1.19
log
@allow the engine to rebuild_info
@
text
@d2 1
a2 1
# $OpenBSD: SubEngine.pm,v 1.18 2013/10/18 19:21:04 espie Exp $
d125 1
a125 7
		# ... and stuff that's related to other stuff building
		} elsif ($self->{doing}{$self->key_for_doing($v)}) {
			$self->remove($v);
			$self->{later}{$v} = $v;
			$self->log('^', $v);
		# if there's no external lock, we can build
		} elsif ($self->can_start_build($v, $core)) {
a127 1
		delete $v->{yakayo};
d133 14
@


1.18
log
@oops, zapping get_core from NoBuild will only work if there's a default
get_core in BuildBase, as experienced by rpe@@.
@
text
@d2 1
a2 1
# $OpenBSD: SubEngine.pm,v 1.17 2013/10/17 08:32:37 espie Exp $
a248 3
# for fetch-only, the engine is *very* abreviated
package DPB::SubEngine::NoBuild;
our @@ISA = qw(DPB::SubEngine::BuildBase);
d254 1
a255 1
		return 1;
d260 3
a262 1

@


1.17
log
@now that the main loop is shorter, the "next" are more cumbersome than
readable, switch to a classic if.. elsif structure
@
text
@d2 1
a2 1
# $OpenBSD: SubEngine.pm,v 1.16 2013/10/14 12:14:33 espie Exp $
d241 6
@


1.16
log
@simplify -F mode. Now we have a specific NoBuild class, it's simpler
to just say our build queue is always empty, rather than constrain the
number of build jobs artificially.

and so, we have actual build jobs that will only rebuild info and trigger
quickly, so it's no longer necessary to allow fetch jobs to do so.

prompted by a bug-report from rpe@@
@
text
@d2 1
a2 1
# $OpenBSD: SubEngine.pm,v 1.15 2013/10/09 06:20:57 espie Exp $
a124 2
			next;
		}
d126 1
a126 1
		if ($self->{doing}{$self->key_for_doing($v)}) {
a129 2
			next;
		}
d131 1
a131 1
		if ($self->can_start_build($v, $core)) {
d134 1
d267 1
@


1.15
log
@have start return useful information, like whether it started something
or not, and propagate it thru the engine
@
text
@d2 1
a2 1
# $OpenBSD: SubEngine.pm,v 1.14 2013/10/07 20:23:13 espie Exp $
a159 6
	my ($self, $core) = @@_;

	if (@@{$self->{engine}{requeued}} > 0) {
		$self->{engine}->rebuild_info($core);
		return 1;
	}
d248 4
d253 9
a261 2
our @@ISA = qw(DPB::SubEngine::BuildBase);
sub is_done
d266 1
a266 1
sub get_core
d268 1
a268 1
	return;
@


1.14
log
@don't mark_ready a core that runs something (seen by nigel and rpe).
replace the dirty trick I did to reuse start with an intermediate
method that's more "reentrant" (use_core) by not fiddling with core's
status.
(bug appeared thanks to over-eager refactoring and shoddy code...)
@
text
@d2 1
a2 1
# $OpenBSD: SubEngine.pm,v 1.13 2013/10/07 20:01:55 espie Exp $
d150 6
a155 1
	$self->use_core($core) || $core->mark_ready;
@


1.13
log
@revisit, fetch cores MUST be pre-emptable for rebuilding-info,
otherwise pure -F fetch engine loses !
@
text
@d2 1
a2 1
# $OpenBSD: SubEngine.pm,v 1.12 2013/10/07 18:01:33 espie Exp $
d110 1
a110 1
sub start
d112 1
a112 3
	my $self = shift;
	my $core = $self->get_core;

d114 1
a114 1
		return;
d136 1
a136 1
			return;
d140 1
a140 1
		return;
d142 9
a150 2
	# couldn't build anything, don't forget to give back the core.
	$core->mark_ready;
@


1.12
log
@okay, fixed version where NoBuild subengine gets only what it actually
needs
@
text
@d2 1
a2 1
# $OpenBSD: SubEngine.pm,v 1.11 2013/10/06 15:49:23 espie Exp $
d150 6
@


1.11
log
@fix -F mode... subengine not yet ready to be split,
and we DON'T want an extra build job.
@
text
@d2 1
a2 1
# $OpenBSD: SubEngine.pm,v 1.7 2013/10/06 12:40:43 espie Exp $
d219 1
a219 1
package DPB::SubEngine::Build;
a220 154
sub new
{
	my ($class, $engine, $builder) = @@_;
	my $o = $class->SUPER::new($engine);
	$o->{builder} = $builder;
	$o->{toinstall} = [];
	$o->{nfs} = {};
	return $o;
}


sub preempt_core
{
	my ($self, $core) = @@_;

	if (@@{$self->{engine}{requeued}} > 0) {
		$self->{engine}->rebuild_info($core);
		return 1;
	}
	if ($self->start_install($core)) {
		return 1;
	}
	# note we don't actually remove stuff from the queue until needed, 
	# so mismatches holds a copy of stuff that's still there.
	$self->{mismatches} = [];
	$self->{tag_mismatches} = [];
	return 0;
}

sub can_start_build
{
	my ($self, $v, $core) = @@_;

	if ($self->check_for_memory_hogs($v, $core)) {
		push(@@{$self->{mismatches}}, $v);
		return 0;
	}
	# if the tag mismatch, we keep it for much much later.
	# currently, we don't even try to recuperate, so this will
	# fail abysmally if there's no junking going on
	if ($core->prop->{tainted} && $v->{info}->has_property('tag')) {
		if ($v->{info}->has_property('tag') ne $core->prop->{tainted}) {
			$self->log('K', $v, " ".$core->hostname." ".
			    $core->prop->{tainted}." vs ".
			    $v->{info}->has_property('tag'));
			push(@@{$self->{tag_mismatches}}, $v);
			return 0;
		}
	}
	# keep affinity mismatches for later
	if (defined $v->{affinity} && !$core->matches($v->{affinity})) {
		$self->log('A', $v, 
		    " ".$core->hostname." ".$v->{affinity});
		# try to start them anyways, on the "right" core
		my $core2 = DPB::Core->get_affinity($v->{affinity});
		if (defined $core2) {
			if ($self->lock_and_start_build($core2, $v)) {
				return 0;
			} else {
				$core2->mark_ready;
			}
		}
		push(@@{$self->{mismatches}}, $v);
		return 0;
	}
	# if there's no external lock, we can build
	if ($self->lock_and_start_build($core, $v)) {
		return 1;
	}
}

sub check_for_memory_hogs
{
	my ($self, $v, $core) = @@_;
	if ($v->{info}->has_property('memoryhog')) {
		for my $job ($core->same_host_jobs) {
			if ($job->{v}{info}->has_property('memoryhog')) {
				return 1;
			}
		}
	}
	return 0;
}

sub can_be_junked
{
	my ($self, $v, $core) = @@_;
	my $tag = $v->{info}->has_property('tag');
	for my $job ($core->same_host_jobs) {
		if ($job->{v}{info}->has_property('tag') &&
		    $job->{v}{info}->has_property('tag') ne $tag) {
		    	return 0;
		}
	}
	return 1;
}

sub recheck_mismatches
{
	my ($self, $core) = @@_;

	# first let's try to force junking
	if (@@{$self->{tag_mismatches}} > 0) {
		for my $v (@@{$self->{tag_mismatches}}) {
			next unless $self->can_be_junked($v, $core);
			$v->{forcejunk} = 1;
			if ($self->lock_and_start_build($core, $v)) {
				$self->log('C', $v);
				return 1;
			}
			delete $v->{forcejunk};
		}
	}
	# let's make sure we don't have something else first
	if (@@{$self->{mismatches}} > 0) {
		if ($self->{engine}->check_buildable(1)) {
			$core->mark_ready;
			return $self->start;
		}
	}
	# second pass, affinity mismatches
	for my $v (@@{$self->{mismatches}}) {
		if ($self->lock_and_start_build($core, $v)) {
			$self->log('Y', $v, 
			    " ".$core->hostname." ".$v->{affinity});
			return 1;
		}
	}
	return 0;
}

sub will_install
{
	my ($self, $v) = @@_;
	push(@@{$self->{toinstall}}, $v);
}

sub start_install
{
	my ($self, $core) = @@_;
	return 0 unless $core->is_local;
	if (my $v = pop @@{$self->{toinstall}}) {
		$self->{builder}->install($v, $core);
		return 1;
	} else {
		return 0;
	}
}

sub non_empty
{
	my $self = shift;
	return  $self->SUPER::non_empty || @@{$self->{toinstall}} > 0;
}
d228 1
a228 1
sub mark_as_done
d230 4
a233 14
	my ($self, $v) = @@_;
	$self->{engine}{affinity}->unmark($v);
	delete $self->{engine}{tobuild}{$v};
	delete $v->{info}{DIST};
#	$self->{heuristics}->done($v);
	if (defined $self->{later}{$v}) {
		$self->log('V', $v);
		delete $self->{later}{$v};
	}
	if (!defined $self->{engine}{built}{$v}) {
		$self->{engine}{built}{$v}= $v;
		$self->log('B', $v);
	}
	$self->remove($v);
d236 2
a237 14
sub is_done_or_enqueue
{
	my ($self, $v) = @@_;
	my $okay = 1;
	for my $w ($v->build_path_list) {
		if ($self->{builder}->end_check($w)) {
			$self->mark_as_done($w);
		} else {
			$self->{nfs}{$v}{$w} = $w;
			$okay = 0;
		}
	}
	return $okay;
}
d239 1
d242 1
a242 20
	my ($self, $v) = @@_;
	if ($self->{builder}->check($v)) {
		for my $w ($v->build_path_list) {
			next if $v eq $w;
			next unless $self->{builder}->check($w);
			$self->mark_as_done($w);
		}
	}
	return $self->is_done_quick($v);
}

sub is_done_quick
{
	my ($self, $v) = @@_;
	if ($self->{builder}->check($v)) {
		$self->mark_as_done($v);
		return 1;
	} else {
		return 0;
	}
d247 1
a247 28
	my $self = shift;
	return $self->{builder}->get;
}

sub key_for_doing
{
	my ($self, $v) = @@_;
	return $v->pkgpath;
}

sub already_done
{
	my ($self, $v) = @@_;
	$self->{engine}{logger}->make_log_link($v);
}

sub start_build
{
	my ($self, $v, $core, $lock) = @@_;
	$self->log('J', $v, " ".$core->hostname);
	if ($v->{info}->has_property('tag')) {
		$core->prop->{tainted} = $v->{info}->has_property('tag');
	}
	$self->{builder}->build($v, $core, $lock, 
	    sub {
	    	my $fail = shift;
	    	$self->end($core, $v, $fail);
	    });
a248 18

sub end_build
{
	my ($self, $v) = @@_;
	$self->{engine}{affinity}->finished($v);
	$self->{engine}{heuristics}->finish_special($v);
}


# for fetch-only, we do the same as Build, except we're never happy
package DPB::SubEngine::NoBuild;

our @@ISA = qw(DPB::SubEngine::Build);
sub is_done
{
	return 0;
}

@


1.10
log
@NoBuild actually requires one piece out of Build...
@
text
@d2 1
a2 1
# $OpenBSD: SubEngine.pm,v 1.9 2013/10/06 13:33:35 espie Exp $
d4 1
a4 1
# Copyright (c) 2010-2013 Marc Espie <espie@@openbsd.org>
d219 1
a219 1
package DPB::SubEngine::BuildBase;
d221 154
d382 96
d482 1
a482 1
our @@ISA = qw(DPB::SubEngine::BuildBase);
@


1.9
log
@update my copyright to 2013
@
text
@d2 1
a2 1
# $OpenBSD: SubEngine.pm,v 1.8 2013/10/06 13:22:20 espie Exp $
d219 9
d232 1
a232 1
our @@ISA = qw(DPB::SubEngine::Build);
@


1.8
log
@split some code into separate files, so that it doesn't get
loaded if it's not needed.
@
text
@d2 1
a2 1
# $OpenBSD: SubEngine.pm,v 1.7 2013/10/06 12:40:43 espie Exp $
d4 1
a4 1
# Copyright (c) 2010 Marc Espie <espie@@openbsd.org>
@


1.7
log
@create a special 'in-between' task that runs (setup only actually)
between checksum and extract: that's when we're truely committed to
building the port there.

create the affinity markers at that point, and not sooner.
since we know whether we're building in memory, we can record that.

if we're building in-memory, always ask for size, since it's very very
fast.

special treatment for tagged ports on error: mark them as "cleaned" so
the host gets untainted eventually.
@
text
@d2 1
a2 1
# $OpenBSD: SubEngine.pm,v 1.6 2013/10/04 11:26:15 espie Exp $
a218 259
package DPB::SubEngine::Build;
our @@ISA = qw(DPB::SubEngine);
sub new
{
	my ($class, $engine, $builder) = @@_;
	my $o = $class->SUPER::new($engine);
	$o->{builder} = $builder;
	$o->{toinstall} = [];
	$o->{nfs} = {};
	return $o;
}


sub preempt_core
{
	my ($self, $core) = @@_;

	if (@@{$self->{engine}{requeued}} > 0) {
		$self->{engine}->rebuild_info($core);
		return 1;
	}
	if ($self->start_install($core)) {
		return 1;
	}
	# note we don't actually remove stuff from the queue until needed, 
	# so mismatches holds a copy of stuff that's still there.
	$self->{mismatches} = [];
	$self->{tag_mismatches} = [];
	return 0;
}

sub can_start_build
{
	my ($self, $v, $core) = @@_;

	if ($self->check_for_memory_hogs($v, $core)) {
		push(@@{$self->{mismatches}}, $v);
		return 0;
	}
	# if the tag mismatch, we keep it for much much later.
	# currently, we don't even try to recuperate, so this will
	# fail abysmally if there's no junking going on
	if ($core->prop->{tainted} && $v->{info}->has_property('tag')) {
		if ($v->{info}->has_property('tag') ne $core->prop->{tainted}) {
			$self->log('K', $v, " ".$core->hostname." ".
			    $core->prop->{tainted}." vs ".
			    $v->{info}->has_property('tag'));
			push(@@{$self->{tag_mismatches}}, $v);
			return 0;
		}
	}
	# keep affinity mismatches for later
	if (defined $v->{affinity} && !$core->matches($v->{affinity})) {
		$self->log('A', $v, 
		    " ".$core->hostname." ".$v->{affinity});
		# try to start them anyways, on the "right" core
		my $core2 = DPB::Core->get_affinity($v->{affinity});
		if (defined $core2) {
			if ($self->lock_and_start_build($core2, $v)) {
				return 0;
			} else {
				$core2->mark_ready;
			}
		}
		push(@@{$self->{mismatches}}, $v);
		return 0;
	}
	# if there's no external lock, we can build
	if ($self->lock_and_start_build($core, $v)) {
		return 1;
	}
}

sub check_for_memory_hogs
{
	my ($self, $v, $core) = @@_;
	if ($v->{info}->has_property('memoryhog')) {
		for my $job ($core->same_host_jobs) {
			if ($job->{v}{info}->has_property('memoryhog')) {
				return 1;
			}
		}
	}
	return 0;
}

sub can_be_junked
{
	my ($self, $v, $core) = @@_;
	my $tag = $v->{info}->has_property('tag');
	for my $job ($core->same_host_jobs) {
		if ($job->{v}{info}->has_property('tag') &&
		    $job->{v}{info}->has_property('tag') ne $tag) {
		    	return 0;
		}
	}
	return 1;
}

sub recheck_mismatches
{
	my ($self, $core) = @@_;

	# first let's try to force junking
	if (@@{$self->{tag_mismatches}} > 0) {
		for my $v (@@{$self->{tag_mismatches}}) {
			next unless $self->can_be_junked($v, $core);
			$v->{forcejunk} = 1;
			if ($self->lock_and_start_build($core, $v)) {
				$self->log('C', $v);
				return 1;
			}
			delete $v->{forcejunk};
		}
	}
	# let's make sure we don't have something else first
	if (@@{$self->{mismatches}} > 0) {
		if ($self->{engine}->check_buildable(1)) {
			$core->mark_ready;
			return $self->start;
		}
	}
	# second pass, affinity mismatches
	for my $v (@@{$self->{mismatches}}) {
		if ($self->lock_and_start_build($core, $v)) {
			$self->log('Y', $v, 
			    " ".$core->hostname." ".$v->{affinity});
			return 1;
		}
	}
	return 0;
}

sub will_install
{
	my ($self, $v) = @@_;
	push(@@{$self->{toinstall}}, $v);
}

sub start_install
{
	my ($self, $core) = @@_;
	return 0 unless $core->is_local;
	if (my $v = pop @@{$self->{toinstall}}) {
		$self->{builder}->install($v, $core);
		return 1;
	} else {
		return 0;
	}
}

sub non_empty
{
	my $self = shift;
	return  $self->SUPER::non_empty || @@{$self->{toinstall}} > 0;
}

sub new_queue
{
	my ($class, $engine) = @@_;
	return $engine->{heuristics}->new_queue;
}

sub mark_as_done
{
	my ($self, $v) = @@_;
	$self->{engine}{affinity}->unmark($v);
	delete $self->{engine}{tobuild}{$v};
	delete $v->{info}{DIST};
#	$self->{heuristics}->done($v);
	if (defined $self->{later}{$v}) {
		$self->log('V', $v);
		delete $self->{later}{$v};
	}
	if (!defined $self->{engine}{built}{$v}) {
		$self->{engine}{built}{$v}= $v;
		$self->log('B', $v);
	}
	$self->remove($v);
}

sub is_done_or_enqueue
{
	my ($self, $v) = @@_;
	my $okay = 1;
	for my $w ($v->build_path_list) {
		if ($self->{builder}->end_check($w)) {
			$self->mark_as_done($w);
		} else {
			$self->{nfs}{$v}{$w} = $w;
			$okay = 0;
		}
	}
	return $okay;
}

sub is_done
{
	my ($self, $v) = @@_;
	if ($self->{builder}->check($v)) {
		for my $w ($v->build_path_list) {
			next if $v eq $w;
			next unless $self->{builder}->check($w);
			$self->mark_as_done($w);
		}
	}
	return $self->is_done_quick($v);
}

sub is_done_quick
{
	my ($self, $v) = @@_;
	if ($self->{builder}->check($v)) {
		$self->mark_as_done($v);
		return 1;
	} else {
		return 0;
	}
}

sub get_core
{
	my $self = shift;
	return $self->{builder}->get;
}

sub key_for_doing
{
	my ($self, $v) = @@_;
	return $v->pkgpath;
}

sub already_done
{
	my ($self, $v) = @@_;
	$self->{engine}{logger}->make_log_link($v);
}

sub start_build
{
	my ($self, $v, $core, $lock) = @@_;
	$self->log('J', $v, " ".$core->hostname);
	if ($v->{info}->has_property('tag')) {
		$core->prop->{tainted} = $v->{info}->has_property('tag');
	}
	$self->{builder}->build($v, $core, $lock, 
	    sub {
	    	my $fail = shift;
	    	$self->end($core, $v, $fail);
	    });
}

sub end_build
{
	my ($self, $v) = @@_;
	$self->{engine}{affinity}->finished($v);
	$self->{engine}{heuristics}->finish_special($v);
}

a226 40
}

package DPB::SubEngine::Fetch;
our @@ISA = qw(DPB::SubEngine);
sub new_queue
{
	my ($class, $engine) = @@_;
	return DPB::Heuristics::FetchQueue->new($engine->{heuristics});
}

sub is_done
{
	my ($self, $v) = @@_;
	return 1 if $v->{done};
	if ($v->check($self->{engine}{logger})) {
		$self->log('B', $v);
		$v->{done} = 1;
		return 1;
	} else {
		return 0;
    	}
}

sub get_core
{
	return DPB::Core::Fetcher->get;
}

sub start_build
{
	my ($self, $v, $core, $lock) = @@_;
	$self->log('J', $v);
	DPB::Fetch->fetch($self->{engine}{logger}, $v, $core,
	    sub { 
	    	$self->end($core, $v, $core->{status});
	    });
}

sub end_build
{
@


1.6
log
@make it possible to forcibly junk mismatch tags, so that bulks will work
if junk=0 by forcing junk eventually.
@
text
@d2 1
a2 1
# $OpenBSD: SubEngine.pm,v 1.5 2013/10/03 17:42:58 espie Exp $
a460 1
	$self->{engine}{affinity}->start($v, $core);
@


1.5
log
@scaffolding for some cool work happening.
NO SERVICEABLE USER PARTS INSIDE! this is a dirty hack to make inroads
on a fairly complicated issue.
@
text
@d2 1
a2 1
# $OpenBSD: SubEngine.pm,v 1.3 2013/10/03 12:55:44 espie Exp $
d263 4
a266 2
		    $self->log('K', $v, " ".$core->hostname);
		    	push(@@{$self->{tag_mismatches}}, $v);
d305 13
d321 13
@


1.4
log
@rearrange order of functions
@
text
@d246 1
d258 10
d270 1
a270 1
		$self->log('a', $v, 
d434 3
d450 1
@


1.3
log
@code is now specialized enough
@
text
@d2 1
a2 1
# $OpenBSD: SubEngine.pm,v 1.2 2013/10/03 12:46:51 espie Exp $
d279 13
a434 13
}

sub check_for_memory_hogs
{
	my ($self, $v, $core) = @@_;
	if ($v->{info}->has_property('memoryhog')) {
		for my $job ($core->same_host_jobs) {
			if ($job->{v}{info}->has_property('memoryhog')) {
				return 1;
			}
		}
	}
	return 0;
@


1.2
log
@disentangle some of the specific "build" code (installation and rebuild info)
from the fetch subengine (in order to make it simpler to track the Fetch issue)
@
text
@d2 1
a2 1
# $OpenBSD: SubEngine.pm,v 1.1 2013/10/03 08:03:27 espie Exp $
a216 5
}

sub check_for_memory_hogs
{
	return 0;
@


1.1
log
@The "Engine" code is quite daunting, but in reality there are 3 things in
there.

Finally split them for less confusing files.
@
text
@d2 1
a2 1
# $OpenBSD: Engine.pm,v 1.90 2013/09/16 21:29:13 espie Exp $
a92 5
sub start_install
{
	return 0;
}

d115 1
a115 5
	if (@@{$self->{engine}{requeued}} > 0) {
		$self->{engine}->rebuild_info($core);
		return;
	}
	if ($self->start_install($core)) {
a120 4
	# note we don't actually remove stuff from the queue until needed, 
	# so mismatches holds a copy of stuff that's still there.
	my @@mismatches = ();

a135 20
		if ($self->check_for_memory_hogs($v, $core)) {
			push(@@mismatches, $v);
			next;
		}
		# keep affinity mismatches for later
		if (defined $v->{affinity} && !$core->matches($v->{affinity})) {
			$self->log('A', $v, 
			    " ".$core->hostname." ".$v->{affinity});
			# try to start them anyways, on the "right" core
			my $core2 = DPB::Core->get_affinity($v->{affinity});
			if (defined $core2) {
				if ($self->lock_and_start_build($core2, $v)) {
					next;
				} else {
					$core2->mark_ready;
				}
			}
			push(@@mismatches, $v);
			next;
		}
d137 1
a137 1
		if ($self->lock_and_start_build($core, $v)) {
d141 2
a142 14
	# let's make sure we don't have something else first
	if (@@mismatches > 0) {
		if ($self->{engine}->check_buildable(1)) {
			$core->mark_ready;
			return $self->start;
		}
	}
	# second pass, affinity mismatches
	for my $v (@@mismatches) {
		if ($self->lock_and_start_build($core, $v)) {
			$self->log('Y', $v, 
			    " ".$core->hostname." ".$v->{affinity});
			return;
		}
d148 17
d234 69
@

