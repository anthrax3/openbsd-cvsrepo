head	1.77;
access;
symbols
	OPENBSD_6_1:1.74.0.4
	OPENBSD_6_1_BASE:1.74
	OPENBSD_6_0:1.74.0.2
	OPENBSD_6_0_BASE:1.74
	OPENBSD_5_9:1.73.0.2
	OPENBSD_5_9_BASE:1.73
	OPENBSD_5_8:1.73.0.4
	OPENBSD_5_8_BASE:1.73
	OPENBSD_5_7:1.63.0.2
	OPENBSD_5_7_BASE:1.63
	OPENBSD_5_6:1.62.0.2
	OPENBSD_5_6_BASE:1.62
	OPENBSD_5_5:1.60.0.2
	OPENBSD_5_5_BASE:1.60
	OPENBSD_5_4:1.48.0.2
	OPENBSD_5_4_BASE:1.48
	OPENBSD_5_3:1.44.0.2
	OPENBSD_5_3_BASE:1.44
	OPENBSD_5_2:1.22.0.2
	OPENBSD_5_2_BASE:1.22
	OPENBSD_5_1_BASE:1.19
	OPENBSD_5_1:1.19.0.2
	OPENBSD_5_0:1.11.0.2
	OPENBSD_5_0_BASE:1.11
	OPENBSD_4_9:1.6.0.2
	OPENBSD_4_9_BASE:1.6
	ports:1.1.1.1
	espie:1.1.1;
locks; strict;
comment	@# @;


1.77
date	2017.05.07.14.50.14;	author espie;	state Exp;
branches;
next	1.76;
commitid	3tOpYg9oIzzqPfC5;

1.76
date	2017.04.19.15.13.12;	author espie;	state Exp;
branches;
next	1.75;
commitid	LLMP821azguBx7Zv;

1.75
date	2017.04.14.16.39.32;	author espie;	state Exp;
branches;
next	1.74;
commitid	9FgsX9a0JtS7xhQD;

1.74
date	2016.05.15.20.08.30;	author espie;	state Exp;
branches;
next	1.73;
commitid	lXvl6HaI9733NKaP;

1.73
date	2015.07.20.20.14.45;	author espie;	state Exp;
branches;
next	1.72;
commitid	BOyZEih7Aii4yjqH;

1.72
date	2015.07.02.08.04.22;	author espie;	state Exp;
branches;
next	1.71;
commitid	qIlv6BM85gcmoVOI;

1.71
date	2015.05.12.19.48.29;	author espie;	state Exp;
branches;
next	1.70;
commitid	CyVrimnnddwcZ9QI;

1.70
date	2015.05.10.08.14.14;	author espie;	state Exp;
branches;
next	1.69;
commitid	J9XuZmxJc7sLMZLF;

1.69
date	2015.05.09.19.10.10;	author espie;	state Exp;
branches;
next	1.68;
commitid	HZdpbT2kS0Y00XMW;

1.68
date	2015.05.06.10.58.19;	author espie;	state Exp;
branches;
next	1.67;
commitid	7AyOW7ui6vSyiXPr;

1.67
date	2015.05.05.08.52.05;	author espie;	state Exp;
branches;
next	1.66;
commitid	e3Q9s79ozgSV5s1q;

1.66
date	2015.05.02.15.59.35;	author espie;	state Exp;
branches;
next	1.65;
commitid	vqo8WijqjQKZbJY4;

1.65
date	2015.05.01.20.49.46;	author espie;	state Exp;
branches;
next	1.64;
commitid	xlo9DiT0WGFHt2dV;

1.64
date	2015.04.26.18.00.19;	author espie;	state Exp;
branches;
next	1.63;
commitid	V6PNfhncU60d7XW1;

1.63
date	2014.12.07.15.18.50;	author espie;	state Exp;
branches;
next	1.62;
commitid	GynqjLfrNHwgIuss;

1.62
date	2014.07.18.07.02.20;	author espie;	state Exp;
branches;
next	1.61;
commitid	sU5LQL0CD2PXCvf0;

1.61
date	2014.03.09.20.11.33;	author espie;	state Exp;
branches;
next	1.60;

1.60
date	2013.12.07.16.03.03;	author espie;	state Exp;
branches;
next	1.59;

1.59
date	2013.11.16.16.39.28;	author espie;	state Exp;
branches;
next	1.58;

1.58
date	2013.11.16.13.06.00;	author espie;	state Exp;
branches;
next	1.57;

1.57
date	2013.10.17.14.02.11;	author espie;	state Exp;
branches;
next	1.56;

1.56
date	2013.10.13.18.31.50;	author espie;	state Exp;
branches;
next	1.55;

1.55
date	2013.10.07.17.50.29;	author espie;	state Exp;
branches;
next	1.54;

1.54
date	2013.10.06.13.33.33;	author espie;	state Exp;
branches;
next	1.53;

1.53
date	2013.10.06.13.25.15;	author espie;	state Exp;
branches;
next	1.52;

1.52
date	2013.10.06.12.38.24;	author espie;	state Exp;
branches;
next	1.51;

1.51
date	2013.10.04.20.28.41;	author espie;	state Exp;
branches;
next	1.50;

1.50
date	2013.09.22.06.29.38;	author espie;	state Exp;
branches;
next	1.49;

1.49
date	2013.09.03.08.53.49;	author espie;	state Exp;
branches;
next	1.48;

1.48
date	2013.07.21.16.24.32;	author espie;	state Exp;
branches;
next	1.47;

1.47
date	2013.07.18.05.36.54;	author espie;	state Exp;
branches;
next	1.46;

1.46
date	2013.06.21.23.13.37;	author espie;	state Exp;
branches;
next	1.45;

1.45
date	2013.05.18.17.24.46;	author espie;	state Exp;
branches;
next	1.44;

1.44
date	2013.02.03.21.17.21;	author espie;	state Exp;
branches;
next	1.43;

1.43
date	2013.02.02.13.35.17;	author espie;	state Exp;
branches;
next	1.42;

1.42
date	2013.01.29.15.11.41;	author espie;	state Exp;
branches;
next	1.41;

1.41
date	2013.01.28.17.36.11;	author espie;	state Exp;
branches;
next	1.40;

1.40
date	2013.01.28.15.52.04;	author espie;	state Exp;
branches;
next	1.39;

1.39
date	2013.01.28.13.31.40;	author espie;	state Exp;
branches;
next	1.38;

1.38
date	2013.01.28.13.25.59;	author espie;	state Exp;
branches;
next	1.37;

1.37
date	2013.01.27.23.17.00;	author espie;	state Exp;
branches;
next	1.36;

1.36
date	2013.01.27.23.15.12;	author espie;	state Exp;
branches;
next	1.35;

1.35
date	2013.01.21.14.56.29;	author espie;	state Exp;
branches;
next	1.34;

1.34
date	2013.01.21.12.29.52;	author espie;	state Exp;
branches;
next	1.33;

1.33
date	2013.01.21.12.03.32;	author espie;	state Exp;
branches;
next	1.32;

1.32
date	2013.01.21.11.27.24;	author espie;	state Exp;
branches;
next	1.31;

1.31
date	2013.01.21.02.06.12;	author espie;	state Exp;
branches;
next	1.30;

1.30
date	2013.01.18.21.11.55;	author espie;	state Exp;
branches;
next	1.29;

1.29
date	2013.01.16.10.38.56;	author espie;	state Exp;
branches;
next	1.28;

1.28
date	2013.01.07.10.59.41;	author espie;	state Exp;
branches;
next	1.27;

1.27
date	2012.12.25.10.43.36;	author espie;	state Exp;
branches;
next	1.26;

1.26
date	2012.12.25.10.00.08;	author espie;	state Exp;
branches;
next	1.25;

1.25
date	2012.12.24.17.24.46;	author espie;	state Exp;
branches;
next	1.24;

1.24
date	2012.10.08.12.41.03;	author espie;	state Exp;
branches;
next	1.23;

1.23
date	2012.09.23.18.13.32;	author espie;	state Exp;
branches;
next	1.22;

1.22
date	2012.04.21.11.30.53;	author espie;	state Exp;
branches;
next	1.21;

1.21
date	2012.04.10.17.06.15;	author espie;	state Exp;
branches;
next	1.20;

1.20
date	2012.03.05.19.43.09;	author espie;	state Exp;
branches;
next	1.19;

1.19
date	2011.12.05.21.27.53;	author espie;	state Exp;
branches;
next	1.18;

1.18
date	2011.12.05.16.10.01;	author espie;	state Exp;
branches;
next	1.17;

1.17
date	2011.12.04.12.05.41;	author espie;	state Exp;
branches;
next	1.16;

1.16
date	2011.12.03.11.10.48;	author espie;	state Exp;
branches;
next	1.15;

1.15
date	2011.12.02.22.33.46;	author espie;	state Exp;
branches;
next	1.14;

1.14
date	2011.11.14.21.57.47;	author espie;	state Exp;
branches;
next	1.13;

1.13
date	2011.11.12.13.19.26;	author espie;	state Exp;
branches;
next	1.12;

1.12
date	2011.09.25.10.41.30;	author espie;	state Exp;
branches;
next	1.11;

1.11
date	2011.06.04.12.58.24;	author espie;	state Exp;
branches;
next	1.10;

1.10
date	2011.06.02.17.09.25;	author espie;	state Exp;
branches;
next	1.9;

1.9
date	2011.05.29.09.30.13;	author espie;	state Exp;
branches;
next	1.8;

1.8
date	2011.05.22.08.21.39;	author espie;	state Exp;
branches;
next	1.7;

1.7
date	2011.04.25.11.58.46;	author espie;	state Exp;
branches;
next	1.6;

1.6
date	2010.11.02.20.32.59;	author espie;	state Exp;
branches;
next	1.5;

1.5
date	2010.11.01.10.55.26;	author espie;	state Exp;
branches;
next	1.4;

1.4
date	2010.10.30.11.36.07;	author espie;	state Exp;
branches;
next	1.3;

1.3
date	2010.10.30.11.19.38;	author espie;	state Exp;
branches;
next	1.2;

1.2
date	2010.10.27.12.58.26;	author espie;	state Exp;
branches;
next	1.1;

1.1
date	2010.08.20.13.40.13;	author espie;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2010.08.20.13.40.13;	author espie;	state Exp;
branches;
next	;


desc
@@


1.77
log
@make NO_CHECKSUM an option, as it causes too many problems on shared
dist farms.
@
text
@# ex:ts=8 sw=4:
# $OpenBSD: PortBuilder.pm,v 1.76 2017/04/19 15:13:12 espie Exp $
#
# Copyright (c) 2010-2013 Marc Espie <espie@@openbsd.org>
#
# Permission to use, copy, modify, and distribute this software for any
# purpose with or without fee is hereby granted, provided that the above
# copyright notice and this permission notice appear in all copies.
#
# THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
# ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
# OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

use strict;
use warnings;

# this object is responsible for launching the build of ports
# which mostly includes starting the right jobs
package DPB::PortBuilder;
use File::Path;
use DPB::Util;
use DPB::Job::Port;
use DPB::Serialize;

sub new
{
	my ($class, $state) = @@_;
	if ($state->opt('R')) {
		require DPB::PortBuilder::Rebuild;
		$class = $class->rebuild_class;
	}
	my $self = bless {
	    state => $state,
	    clean => $state->opt('c'),
	    dontclean => $state->{dontclean},
	    fetch => $state->opt('f'),
	    wantsize => $state->{wantsize},
	    fullrepo => $state->fullrepo,
	    realfullrepo => $state->anchor($state->fullrepo),
	    sizer => $state->sizer,
	    heuristics => $state->heuristics}, $class;
	if ($state->opt('u') || $state->opt('U')) {
		$self->{update} = 1;
	}
	if ($state->opt('U')) {
		$self->{forceupdate} = 1;
	}
	if ($self->{fetch} && $state->defines('NO_CHECKSUM')) {
		$self->{nochecksum} = 1;
	}
	$self->init;
	return $self;
}

sub want_size
{
	my ($self, $v, $core) = @@_;
	if (!$self->{wantsize}) {
		return 0;
	}
	# always show for inmem
	if ($core->{inmem}) {
		return 1;
	}
	# do we already have this stats ? don't run it every time
	if ($self->{sizer}->match_pkgname($v)) {
		return rand(10) < 1;
	} else {
		return 1;
	}
}

sub rebuild_class
{ 'DPB::PortBuilder::Rebuild' }

sub ports
{
	my $self = shift;
	return $self->{state}->ports;
}

sub logger
{
	my $self = shift;
	return $self->{state}->logger;
}

sub locker
{
	my $self = shift;
	return $self->{state}->locker;
}

sub dontjunk
{
	my ($self, $v) = @@_;
	$self->{dontjunk}{$v->fullpkgname} = 1;
}

sub make
{
	my $self = shift;
	return $self->{state}->make;
}

sub make_args
{
	my $self = shift;
	return $self->{state}->make_args;
}

sub init
{
	my $self = shift;
	$self->{state}{build_user}->make_path($self->{realfullrepo});
	$self->{global} = $self->logger->append("build");
	$self->{lockperf} = 
	    DPB::Util->make_hot($self->logger->append("awaiting-locks"));
	if ($self->{wantsize}) {
		$self->{logsize} = 
		    DPB::Util->make_hot($self->logger->append("size"));
	}
	if ($self->{state}->defines("WRAP_MAKE")) {
		$self->{rsslog} = $self->logger->logfile("rss");
		$self->{wrapper} = $self->{state}->defines("WRAP_MAKE");
	}
}

sub pkgfile
{
	my ($self, $v) = @@_;
	my $name = $v->fullpkgname;
	return "$self->{realfullrepo}/$name.tgz";
}

sub check
{
	my ($self, $v) = @@_;
	return $self->{state}{build_user}->run_as(
	    sub { 
	    	return -f $self->pkgfile($v); 
	    });
}

sub end_check
{
	&check;
}

sub checks_rebuild
{
}

sub register_package
{
}

sub report
{
	my ($self, $v, $job, $core) = @@_;
	return if $job->{signature_only};
	my $pkgpath = $v->fullpkgpath;
	my $host = $core->fullhostname;
	if ($core->{realjobs}) {
		$host .= '*'.$core->{realjobs};
	}
	my $log = $self->{global};
	my $sz = $self->logger->run_as(
	    sub { 
		return  (stat $self->logger->log_pkgpath($v))[7]; 
	    });
	if (defined $job->{offset}) {
		$sz -= $job->{offset};
	}
	print $log "$pkgpath $host ", $job->totaltime, " ", $sz, " ",
	    $job->timings;
	if ($job->{failed}) {
		my $fh = $self->logger->open('>>', $job->{log});
		print $fh "Error: job failed with $job->{failed} on ",
		    $core->hostname, "\n";
		print $log  "!\n";
	} else {
		print $log  "\n";
		return unless defined $self->{state}{permanent_log};
		my $fh = $self->logger->open('>>', 
		    $self->{state}{permanent_log});
		return unless defined $fh;
		print $fh DPB::Serialize::Build->write({
		    pkgpath => $pkgpath, 
		    host => $host, 
		    time => $job->totaltime, 
		    size => $sz, 
		    ts => CORE::time }), "\n";
	}
}

sub get
{
	my $self = shift;
	return DPB::Core->get;
}

sub end_lock
{
	my ($self, $lock, $core, $job) = @@_;
	my $end = time();
	print $lock "status=$core->{status}\n";
	print $lock "todo=", $job->current_task, "\n";
	print $lock "end=$end (", DPB::Util->time2string($end), ")\n";
	close $lock;
}

sub build
{
	my ($self, $v, $core, $lock, $final_sub) = @@_;
	my $start = time();
	my ($log, $fh) = $self->logger->make_logs($v);
	my $memsize = $self->{sizer}->build_in_memory($fh, $core, $v);
	my $meminfo;

	if ($memsize) {
		print $lock "mem=$memsize\n";
		$meminfo = " in memory";
		$core->{inmem} = $memsize;
	} else {
		$meminfo = "";
		$core->{inmem} = 0;
	}
	if ($v->{info}->has_property('tag')) {
		print $lock "tag=".$v->{info}->has_property('tag')."\n";
	}
	print $fh ">>> Building on ", $core->hostname;
	print $fh $meminfo, " under ";
	$v->quick_dump($fh);

	my $job;
	$job = DPB::Job::Port->new($log, $fh, $v, $lock, $self, $memsize, $core,
	    sub {
	    	close($fh); 
		$self->end_lock($lock, $core, $job); 
		$self->report($v, $job, $core); 
		&$final_sub($job->{failed});
	    });
	$core->start_job($job, $v);
	if ($job->{parallel}) {
		$core->can_swallow($job->{parallel}-1);
	}
	print $lock "host=", $core->hostname, "\n",
	    "pid=$core->{pid}\n",
	    "start=$start (", DPB::Util->time2string($start), ")\n";
	$job->set_watch($self->logger, $v);
}

sub force_junk
{
	my ($self, $v, $core, $final_sub) = @@_;
	my $start = time();
	my $log = $self->logger->log_pkgpath($v);
	my $fh = $self->logger->open('>>', $log);
	print $fh ">>> Force junking on ", $core->hostname;
	my $job;
	$job = DPB::Job::Port->new_junk_only($log, $fh, $v, undef, $self,
	    0,$core,
	    sub {
		    close($fh);
		    &$final_sub($job->{failed});
		    $core->mark_ready;
	    });
	$core->start_job($job, $v);
}

sub test
{
	my ($self, $v, $core, $lock, $final_sub) = @@_;
	my $start = time();
	my $log = $self->logger->make_test_logs($v);
	my $memsize = $self->{sizer}->build_in_memory($core, $v);

	open my $fh, ">>", $log or DPB::Util->die_bang("can't open $log");
	if ($memsize) {
		print $lock "mem=$memsize\n";
		print $fh ">>> Building in memory under ";
		$core->{inmem} = $memsize;
	} else {
		print $fh ">>> Building under ";
		$core->{inmem} = 0;
	}
	if ($v->{info}->has_property('tag')) {
		print $lock "tag=".$v->{info}->has_property('tag')."\n";
	}
	$v->quick_dump($fh);

	my $job;
	$job = DPB::Job::Port::Test->new($log, $fh, $v, $lock, $self, 
	    $memsize, $core,
	    sub {
	    	close($fh); 
		$self->end_lock($lock, $core, $job); 
		$self->report($v, $job, $core); 
		&$final_sub($job->{failed});
	    });
	$core->start_job($job, $v);
	print $lock "host=", $core->hostname, "\n",
	    "pid=$core->{pid}\n",
	    "start=$start (", DPB::Util->time2string($start), ")\n";
}

sub install
{
	my ($self, $v, $core) = @@_;
	my ($log, $fh) = $self->logger->make_logs($v);
	print $fh ">>> Installing under ";
	$v->quick_dump($fh);
	my $job = DPB::Job::Port::Install->new($log, $fh, $v, $self,
	    sub {
	    	close($fh);
	    	$core->mark_ready; 
	    });
	$core->start_job($job, $v);
	return $core;
}


1;
@


1.76
log
@cosmetic change: report the hostname again in case of failure.
I routinely read thru logs looking for the error, and forget about which
machine it was. Having it conveniently located at the end instead of the
start saves me a few seconds.
@
text
@d2 1
a2 1
# $OpenBSD: PortBuilder.pm,v 1.75 2017/04/14 16:39:32 espie Exp $
d51 3
@


1.75
log
@reorg the logic behind permanent_log so that it *is* the permanent log.
fixes -DNO_BUILD_STATS as reported by naddy@@ (predates rewriting buildinfo,
and I plain forgot about it obviously)
@
text
@d2 1
a2 1
# $OpenBSD: PortBuilder.pm,v 1.74 2016/05/15 20:08:30 espie Exp $
d180 2
a181 1
		print $fh "Error: job failed $job->{failed}\n";
@


1.74
log
@kill unused code (different users for each build)
@
text
@d2 1
a2 1
# $OpenBSD: PortBuilder.pm,v 1.73 2015/07/20 20:14:45 espie Exp $
d184 1
d187 7
a193 8
		if (defined $fh) {
			print $fh DPB::Serialize::Build->write({
			    pkgpath => $pkgpath, 
			    host => $host, 
			    time => $job->totaltime, 
			    size => $sz, 
			    ts => CORE::time }), "\n";
	    	}
@


1.73
log
@dont error out if we can't write into permanent log.
found out by naddy@@
@
text
@d2 1
a2 1
# $OpenBSD: PortBuilder.pm,v 1.72 2015/07/02 08:04:22 espie Exp $
a232 3
	if (defined $core->{user}) {
		print $fh " as ", $core->{user}->user, " ";
	}
a260 3
	if (defined $core->{user}) {
		print $fh " as ", $core->{user}->user, " ";
	}
@


1.72
log
@clean-up "force junking": do not prepare a host to be untainted with the
"wrong" port, but instead, create a pseudo-path that is just there to run
junk (will be logged as junk-proxy)

fix a bug in the task handling host locking (no next task -> unlock, duh).

do not log multiple K for several ports on the same basepkgpath.
@
text
@d2 1
a2 1
# $OpenBSD: PortBuilder.pm,v 1.71 2015/05/12 19:48:29 espie Exp $
d186 8
a193 6
		print $fh DPB::Serialize::Build->write({
		    pkgpath => $pkgpath, 
		    host => $host, 
		    time => $job->totaltime, 
		    size => $sz, 
		    ts => CORE::time }), "\n";
@


1.71
log
@sthen@@ has more paranoia than me.  Fix a few access cases
@
text
@d2 1
a2 1
# $OpenBSD: PortBuilder.pm,v 1.70 2015/05/10 08:14:14 espie Exp $
d253 21
@


1.70
log
@rename logger interface to desambiguate vs user.
@
text
@d2 1
a2 1
# $OpenBSD: PortBuilder.pm,v 1.69 2015/05/09 19:10:10 espie Exp $
d169 4
a172 1
	my $sz = (stat $self->logger->log_pkgpath($v))[7];
@


1.69
log
@fix writing of permanent logs
@
text
@d2 1
a2 1
# $OpenBSD: PortBuilder.pm,v 1.68 2015/05/06 10:58:19 espie Exp $
d117 1
a117 1
	$self->{global} = $self->logger->open("build");
d119 1
a119 1
	    DPB::Util->make_hot($self->logger->open("awaiting-locks"));
d122 1
a122 1
		    DPB::Util->make_hot($self->logger->open("size"));
d176 1
a176 1
		my $fh = $self->logger->{user}->open('>>', $job->{log});
d181 1
a181 1
		my $fh = $self->logger->{user}->open('>>', 
@


1.68
log
@don't write this as root
@
text
@d2 1
a2 1
# $OpenBSD: PortBuilder.pm,v 1.67 2015/05/05 08:52:05 espie Exp $
d176 1
a176 1
		my $fh = $self->logger->open('>>', $job->{log});
d181 2
a182 2
		my $fh = $self->logger->open(
		    '>>', $self->{state}{permanent_log});
@


1.67
log
@a few more things to wrap as the correct user
@
text
@d2 1
a2 1
# $OpenBSD: PortBuilder.pm,v 1.66 2015/05/02 15:59:35 espie Exp $
d176 1
a176 1
		open my $fh, '>>', $job->{log};
@


1.66
log
@show the user for roundrobin
@
text
@d2 1
a2 1
# $OpenBSD: PortBuilder.pm,v 1.65 2015/05/01 20:49:46 espie Exp $
d140 4
a143 1
	return -f $self->pkgfile($v);
d181 2
a182 1
		open my $fh, '>>', $self->{state}{permanent_log};
@


1.65
log
@fix creation of path log files
@
text
@d2 1
a2 1
# $OpenBSD: PortBuilder.pm,v 1.64 2015/04/26 18:00:19 espie Exp $
d223 5
a227 1
	print $fh ">>> Building on ", $core->hostname, $meminfo, " under ";
@


1.64
log
@use UserProxy and make_path method.
Have the default host handle chroot correctly.

(still a bit of fetch to fix)
@
text
@d2 1
a2 1
# $OpenBSD: PortBuilder.pm,v 1.63 2014/12/07 15:18:50 espie Exp $
d208 1
a208 2
	my $log = $self->logger->make_logs($v);
	open my $fh, ">>", $log or DPB::Util->die_bang("can't open $log");
d283 1
a283 2
	my $log = $self->logger->make_logs($v);
	open my $fh, ">>", $log or DPB::Util->die_bang("can't open $log");
@


1.63
log
@wrap die so that it drops into the debugger if we run under perl -d.

change the way we do rescans again, to avoid race conditions:
just store away *all* pkgpaths related to the rescan (so that multi-packages
are covered) and then do the rescan. Hold those like we do for normal locks
but in a different list, and release them when the scan is over.

remove the atrocious shennanigans wrt fullpkgnames, it shouldn't be needed
again, hopefully.
@
text
@d2 1
a2 1
# $OpenBSD: PortBuilder.pm,v 1.62 2014/07/18 07:02:20 espie Exp $
d116 1
a116 1
	File::Path::make_path($self->{realfullrepo});
@


1.62
log
@store host info in individual logs
@
text
@d2 1
a2 1
# $OpenBSD: PortBuilder.pm,v 1.61 2014/03/09 20:11:33 espie Exp $
d209 1
a209 1
	open my $fh, ">>", $log or die "can't open $log: $!";
d252 1
a252 1
	open my $fh, ">>", $log or die "can't open $log: $!";
d285 1
a285 1
	open my $fh, ">>", $log or die "can't open $log: $!";
@


1.61
log
@pass logfile to the sizer, so it can output more specific information,
like its size computations.
@
text
@d2 1
a2 1
# $OpenBSD: PortBuilder.pm,v 1.60 2013/12/07 16:03:03 espie Exp $
d211 1
d215 1
a215 1
		print $fh ">>> Building in memory under ";
d218 1
a218 1
		print $fh ">>> Building under ";
d224 1
@


1.60
log
@preliminary scaffolding to handle tests: create specific task types
for dependencies and for running tests.

fix PortInfo to know whether tests are required.
Amend PortBuilder to be able to launch tests.

(there are pieces missing in the engine, like a secondary queue with forced
affinity to run actual tests, and the portbuilder code is very incomplete
and needs love)
@
text
@d2 1
a2 1
# $OpenBSD: PortBuilder.pm,v 1.59 2013/11/16 16:39:28 espie Exp $
d209 2
a210 1
	my $memsize = $self->{sizer}->build_in_memory($core, $v);
a211 1
	open my $fh, ">>", $log or die "can't open $log: $!";
@


1.59
log
@make the data in permanent logs a bit more self-describing, so that we may add
new fields in the future without atrocious hacks for bw compatibility.
(grows the files a bit, but quite acceptable).
@
text
@d2 1
a2 1
# $OpenBSD: PortBuilder.pm,v 1.58 2013/11/16 13:06:00 espie Exp $
d241 36
@


1.58
log
@add/read timestamps to rolling logs, so that eventually old stuff gets
removed.

alias -DSTARTUP/-DCLEANUP, since I keep mixing up the two.
@
text
@d2 1
a2 1
# $OpenBSD: PortBuilder.pm,v 1.57 2013/10/17 14:02:11 espie Exp $
d27 1
d179 6
a184 2
		print $fh join(' ', $pkgpath, $host, $job->totaltime, $sz, 
		    CORE::time()), "\n";
@


1.57
log
@more -B, fullrepo is actually needed within the chroot for pkg_add.
@
text
@d2 1
a2 1
# $OpenBSD: PortBuilder.pm,v 1.56 2013/10/13 18:31:50 espie Exp $
d178 2
a179 2
		print $fh join(' ', $pkgpath, $host, $job->totaltime, $sz),
		    "\n";
@


1.56
log
@- use separated Heuristics::Size object
- choose size/nosize in Config.
- use affinity or affinitystub
- move locker creation to State, so we can init cores right away.
- as core init has run, we can call DPB::Core->reap (event loop) while
processing size and build stats, so that the startup script may start
slightly earlier.
- setup more options in Config for Reporter to use.
- scaffolding in SubEngine/Build to be able to use affinity info right away
@
text
@d2 1
a2 1
# $OpenBSD: PortBuilder.pm,v 1.55 2013/10/07 17:50:29 espie Exp $
d42 1
d115 1
a115 1
	File::Path::make_path($self->{fullrepo});
d133 1
a133 1
	return "$self->{fullrepo}/$name.tgz";
@


1.55
log
@move decision to run show-size to PortBuilder, as we really need to know
whether we have a filehandle.
@
text
@d2 1
a2 1
# $OpenBSD: PortBuilder.pm,v 1.54 2013/10/06 13:33:33 espie Exp $
d42 1
d65 1
a65 1
	if ($self->{heuristics}->match_pkgname($v)) {
d203 1
a203 1
	my $memsize = $self->{heuristics}->build_in_memory($core, $v);
@


1.54
log
@update my copyright to 2013
@
text
@d2 1
a2 1
# $OpenBSD: PortBuilder.pm,v 1.53 2013/10/06 13:25:15 espie Exp $
d55 1
a55 1
	my ($self, $v) = @@_;
d58 4
@


1.53
log
@and portbuilder too
@
text
@d2 1
a2 1
# $OpenBSD: PortBuilder.pm,v 1.52 2013/10/06 12:38:24 espie Exp $
d4 1
a4 1
# Copyright (c) 2010 Marc Espie <espie@@openbsd.org>
@


1.52
log
@rename "special" parameter to what it really is, building in memory.
return actual size for affinity files.

assume affinity files record previous choice and reuse it
@
text
@d2 1
a2 1
# $OpenBSD: PortBuilder.pm,v 1.51 2013/10/04 20:28:41 espie Exp $
d32 1
a247 89
package DPB::PortBuilder::Rebuild;
our @@ISA = qw(DPB::PortBuilder);

sub init
{
	my $self = shift;
	$self->SUPER::init;

	require OpenBSD::PackageRepository;
	$self->{repository} = OpenBSD::PackageRepository->new(
	    "file:/$self->{fullrepo}");
	# this is just a dummy core, for running quick pipes
	$self->{core} = DPB::Core->new_noreg('localhost');
}

my $uptodate = {};

sub equal_signatures
{
	my ($self, $core, $v) = @@_;
	my $p = $self->{repository}->find($v->fullpkgname.".tgz");
	my $plist = $p->plist(\&OpenBSD::PackingList::UpdateInfoOnly);
	my $pkgsig = $plist->signature->string;
	# and the port
	my $portsig = $self->{state}->grabber->grab_signature($core,
	    $v->fullpkgpath);
	return $portsig eq $pkgsig;
}

sub check_signature
{
	my ($self, $core, $v) = @@_;
	my $okay = 1;
	for my $w ($v->build_path_list) {
		my $name = $w->fullpkgname;
		if (!-f "$self->{fullrepo}/$name.tgz") {
			print "$name: absent\n";
			$okay = 0;
			next;
		}
		next if $uptodate->{$name};
		if ($self->equal_signatures($core, $w)) {
			$uptodate->{$name} = 1;
			print "$name: uptodate\n";
			next;
		}
		print "$name: rebuild\n";
		$self->{state}->grabber->clean_packages($core,
		    $w->fullpkgpath);
	    	$okay = 0;
	}
	return $okay;
}

# this is due to the fact check_signature is within a child
sub register_package
{
	my ($self, $v) = @@_;
	$uptodate->{$v->fullpkgname} = 1;
}

sub end_check
{
	my ($self, $v) = @@_;
	return 0 unless $self->SUPER::end_check($v);
	$self->register_package($v);
	return 1;
}

sub check
{
	my ($self, $v) = @@_;
	return 0 unless $self->SUPER::check($v);
	return $uptodate->{$v->fullpkgname};
}

sub register_updates
{
	my ($self, $v) = @@_;
	for my $w ($v->build_path_list) {
		$self->end_check($w);
	}
}

sub checks_rebuild
{
	my ($self, $v) = @@_;
	return 1 unless $uptodate->{$v->fullpkgname};
}
d249 1
@


1.51
log
@really need to store tags in locks, as dependencies in there will kill
me when restarting dpb...
@
text
@d2 1
a2 1
# $OpenBSD: PortBuilder.pm,v 1.50 2013/09/22 06:29:38 espie Exp $
d197 1
a197 1
	my $special = $self->{heuristics}->special_parameters($core, $v);
d200 2
a201 2
	if ($special) {
		print $lock "mfs\n";
d203 1
a203 1
		$core->{inmem} = 1;
d214 1
a214 1
	$job = DPB::Job::Port->new($log, $fh, $v, $lock, $self, $special, $core,
@


1.50
log
@show a '+' when we're building in-memory
@
text
@d2 1
a2 1
# $OpenBSD: PortBuilder.pm,v 1.49 2013/09/03 08:53:49 espie Exp $
d207 3
@


1.49
log
@error out if we can't open log files (got a weird permission error linked
to a half-baked file-system).
@
text
@d2 1
a2 1
# $OpenBSD: PortBuilder.pm,v 1.48 2013/07/21 16:24:32 espie Exp $
d203 1
d206 1
@


1.48
log
@the major change from a few days ago completely broke dpb -R (reported
by fgs@@, kili@@, nigel@@)
repair it.
- introduce end_check to cope with package files updated
(not quite satisfied with the source code, but this works, and will do for
5.4).
- adjust report to build.log to conform to the new semantics: namely, if it
didn't fail, then it's okay, don't even look at possibly missing packages
because of nfs (noticed by nigel@@).
@
text
@d2 1
a2 1
# $OpenBSD: PortBuilder.pm,v 1.47 2013/07/18 05:36:54 espie Exp $
d199 1
a199 1
	open my $fh, ">>", $log;
d230 1
a230 1
	open my $fh, ">>", $log;
@


1.47
log
@change the way errors are handled, fixed version:
- pass error condition from Job/Port.pm all the way to the engine
- use that to know whether we fail, instead of the existence of packages
(but still keep track of what we're doing correctly, THAT'S the fix)
- refactor error handling into OO version
- keep track of locks/errors/packages we're waiting for thx to nfs

all of these keep the lock around, and react to the lock being removed.

use case for nfs: if there was a revision bump after dpb scanned the port,
it will never find the package. Removing the lock will allow dpb to rescan
and find the correct packages.

with this, dpb no longer waits after nfs. More importantly, it does not
report nfs hangs as E:, rather as H:... (and it can "wait" for much longer
periods, since it keeps running and only checks on new jobs).
@
text
@d2 1
a2 1
# $OpenBSD: PortBuilder.pm,v 1.46 2013/06/21 23:13:37 espie Exp $
d135 5
d164 5
a168 1
	if ($self->check($v)) {
a172 4
	} else {
		open my $fh, '>>', $job->{log};
		print $fh "Error: ", $self->pkgfile($v), " does not exist\n";
		print $log  "!\n";
d303 8
d316 8
@


1.46
log
@reorganize option and config file parsing slightly so that variable
values can be in config files.
command line should still override config files.
to be documented shortly, but stuff like
FETCH_JOBS=n
WANTSIZE=1
MIRROR=0

should now work within a hosts file.
@
text
@d2 1
a2 1
# $OpenBSD: PortBuilder.pm,v 1.45 2013/05/18 17:24:46 espie Exp $
d209 1
a209 1
		&$final_sub;
@


1.45
log
@write in the lock file that we're building in memory, more possible affinity
information...
@
text
@d2 1
a2 1
# $OpenBSD: PortBuilder.pm,v 1.44 2013/02/03 21:17:21 espie Exp $
d39 1
a39 1
	    size => $state->opt('s'),
d55 1
a55 1
	if (!$self->{size}) {
d58 1
d112 1
a112 1
	if ($self->{size}) {
@


1.44
log
@oops
@
text
@d2 1
a2 1
# $OpenBSD: PortBuilder.pm,v 1.43 2013/02/02 13:35:17 espie Exp $
d195 1
@


1.43
log
@move control of the "building in mfs" part under PortsBuilder/Heuristics.
Store previous pkgname.
do show-size only sporadically if fullpkgname didn't change
@
text
@d2 1
a2 1
# $OpenBSD: PortBuilder.pm,v 1.42 2013/01/29 15:11:41 espie Exp $
d59 1
a59 1
		return random(10) < 1;
@


1.42
log
@don't let check_signature be silent, say that the package is absent, make
things more obvious with a new REVISION/version.
@
text
@d2 1
a2 1
# $OpenBSD: PortBuilder.pm,v 1.41 2013/01/28 17:36:11 espie Exp $
d52 13
d188 1
a188 1
	my ($self, $v, $core, $special, $lock, $final_sub) = @@_;
d191 1
d194 5
a198 1
	print $fh ">>> Building under ";
@


1.41
log
@reversed test result somehow
@
text
@d2 1
a2 1
# $OpenBSD: PortBuilder.pm,v 1.40 2013/01/28 15:52:04 espie Exp $
d253 1
@


1.40
log
@okay, less smart, just do the whole series, don't special case the
main package. should work.
@
text
@d2 1
a2 1
# $OpenBSD: PortBuilder.pm,v 1.39 2013/01/28 13:31:40 espie Exp $
d249 1
a249 1
	my $rebuild = 0;
d253 1
a253 1
			$rebuild = 1;
d265 1
a265 1
	    	$rebuild = 1;
d267 1
a267 1
	return $rebuild;
@


1.39
log
@tweak, remove rebuild.log, as we log stuff directly into paths/ now.
do register_package in a slightly more efficient way (less -f tests)
@
text
@d2 1
a2 1
# $OpenBSD: PortBuilder.pm,v 1.38 2013/01/28 13:25:59 espie Exp $
d249 13
a261 12
	my $name = $v->fullpkgname;
	if ($uptodate->{$name}) {
		return 1;
	}
	if (-f "$self->{fullrepo}/$name.tgz" && 
	    $self->equal_signatures($core, $v)) {
		$uptodate->{$name} = 1;
		print "$name: uptodate\n";
		return 1;
	} else {
		# XXX clean this first, so we skip over it in the loop
		$self->{state}->grabber->clean_packages($core, $v->fullpkgpath);
d263 3
a265 14
		for my $w ($v->build_path_list) {
			$name = $w->fullpkgname;
			next unless -f "$self->{fullrepo}/$name.tgz";
			next if $uptodate->{$name};
			if ($self->equal_signatures($core, $w)) {
				$uptodate->{$name} = 1;
				print "$name: uptodate\n";
				next;
			}
			print "$name: rebuild\n";
			$self->{state}->grabber->clean_packages($core,
			    $w->fullpkgpath);
		}
		return 0;
d267 1
@


1.38
log
@fix -R for real... what check_signatures does is nice, but needs to be
partly redone in the main dpb process. Obviously, children's changes to
uptodate don't affect the main process.

thanks to fgs@@ for being the crash-test bunny.
@
text
@d2 1
a2 1
# $OpenBSD: PortBuilder.pm,v 1.37 2013/01/27 23:17:00 espie Exp $
d125 1
a125 1
sub register_packages
a229 2
	$self->{logrebuild} = DPB::Util->make_hot(
	    $self->logger->open('rebuild'));
a256 1
		print {$self->{logrebuild}} "$name: uptodate\n";
a261 1
		print {$self->{logrebuild}} "$name: rebuild\n";
a268 1
				print {$self->{logrebuild}} "$name: uptodate\n";
a271 1
			print {$self->{logrebuild}} "$name: rebuild\n";
d280 1
a280 1
sub register_packages
d283 1
a283 6
	for my $w ($v->build_path_list) {
		my $name = $w->fullpkgname;
		if (-f "$self->{fullrepo}/$name.tgz") {
			$uptodate->{$name} = 1;
		}
	}
@


1.37
log
@remove debug scaffolding
@
text
@d2 1
a2 1
# $OpenBSD: PortBuilder.pm,v 1.36 2013/01/27 23:15:12 espie Exp $
d125 4
d258 1
d264 1
d272 1
d276 1
d282 12
@


1.36
log
@ditch register_built, no longer serves any purpose.

switch junk to counting depends and count depends correctly
@
text
@d2 1
a2 1
# $OpenBSD: PortBuilder.pm,v 1.35 2013/01/21 14:56:29 espie Exp $
a280 3

	my $name = $v->fullpkgname;
	print {$self->{logrebuild}} "$name uptodate (cached): $uptodate->{$name}\n";
@


1.35
log
@rollinglog must be reopened each time, comment why
(commented snippet that shows how to prime -s heuristics based on time
dangerous but useful)
@
text
@d2 1
a2 1
# $OpenBSD: PortBuilder.pm,v 1.34 2013/01/21 12:29:52 espie Exp $
a120 4
sub register_built
{
}

d281 3
a292 9
sub register_built
{
	my ($self, $v) = @@_;
	for my $w ($v->build_path_list) {
		$uptodate->{$w->fullpkgname} = -f $self->pkgfile($w);
	}
}

1;
@


1.34
log
@PortBuilder already opens logfiles, so pass them around, instead of closing/reopening
@
text
@d2 1
a2 1
# $OpenBSD: PortBuilder.pm,v 1.33 2013/01/21 12:03:32 espie Exp $
a100 2
		open($self->{rollinglog}, '>>', $self->{state}{size_log});
		DPB::Util->make_hot($self->{rollinglog});
@


1.33
log
@simplify wrkdir size handling, turn that into a rolling log.
@
text
@d2 1
a2 1
# $OpenBSD: PortBuilder.pm,v 1.32 2013/01/21 11:27:24 espie Exp $
a183 1
	close($fh);
d186 7
a192 2
	$job = DPB::Job::Port->new($log, $v, $lock, $self, $special, $core,
	    sub {$self->end_lock($lock, $core, $job); $self->report($v, $job, $core); &$final_sub;});
d207 8
a214 2
	my $job = DPB::Job::Port::Install->new($log, $v, $self,
	    sub {$core->mark_ready; });
@


1.32
log
@fix -R for multi-packages situation: once we ascertain a given port is
out-of-date, also check every relevant subpackage, and remove the files
accordingly.
tricky loop to avoid recomputing things
@
text
@d2 1
a2 1
# $OpenBSD: PortBuilder.pm,v 1.31 2013/01/21 02:06:12 espie Exp $
d98 6
@


1.31
log
@tweak log, awaiting-locks is a better name, and put in timestamps
@
text
@d2 1
a2 1
# $OpenBSD: PortBuilder.pm,v 1.30 2013/01/18 21:11:55 espie Exp $
d222 12
a237 1
	return 0 unless -f "$self->{fullrepo}/$name.tgz";
d241 2
a242 8
	# check the package
	my $p = $self->{repository}->find("$name.tgz");
	my $plist = $p->plist(\&OpenBSD::PackingList::UpdateInfoOnly);
	my $pkgsig = $plist->signature->string;
	# and the port
	my $portsig = $self->{state}->grabber->grab_signature($core,
	    $v->fullpkgpath);
	if ($portsig eq $pkgsig) {
d247 2
d250 13
a262 2
		$self->{state}->grabber->clean_packages($core,
		    $v->fullpkgpath);
@


1.30
log
@kill checksum-and-list

optimize away some depend stages: since the main dpb process maintains
a synchronous list of live_depends, and only releases host locks synchronously,
it can check depends lists against already known live_depends (and avoid
some depend stages entirely).

naddy@@ says it gains 40 mn on his box...
@
text
@d2 1
a2 1
# $OpenBSD: PortBuilder.pm,v 1.29 2013/01/16 10:38:56 espie Exp $
d97 1
a97 1
	    DPB::Util->make_hot($self->logger->open("lock-perf"));
@


1.29
log
@log the time spent waiting for locks.

remove most of the "list distfiles" ad-hoc code, this stuff belongs in
bsd.port.mk.
@
text
@d2 1
a2 1
# $OpenBSD: PortBuilder.pm,v 1.28 2013/01/07 10:59:41 espie Exp $
d181 1
a181 1
	$job = DPB::Job::Port->new($log, $v, $self, $special, $core,
a182 1
	$job->{lock} = $lock;
@


1.28
log
@pass -X paths thru:
- the grabber passes them to PortBuilder
... which builds a hash of pkgnames
... and the port uninstall job excludes these from the list of ports to
junk.

Note this only works with -current pkg_delete, as I had to tell it to
ignore non-existent pkgnames in that context
@
text
@d2 1
a2 1
# $OpenBSD: PortBuilder.pm,v 1.27 2012/12/25 10:43:36 espie Exp $
d96 2
@


1.27
log
@make "rebuild" behavior a proper subclass of DPB::PortBuilder, instead
of having tests all over the place.

Take advantage of that to not rechecking signatures if already done.
@
text
@d2 1
a2 1
# $OpenBSD: PortBuilder.pm,v 1.26 2012/12/25 10:00:08 espie Exp $
d71 6
@


1.26
log
@on rebuild, mark all existing files as 'uptodate'. Will prevent extra
rebuilds on @@option always-update multi-packages when using -R.
@
text
@d2 1
a2 1
# $OpenBSD: PortBuilder.pm,v 1.25 2012/12/24 17:24:46 espie Exp $
d31 3
a39 1
	    rebuild => $state->opt('R'),
d52 3
a93 9
	if ($self->{rebuild}) {
		require OpenBSD::PackageRepository;
		$self->{repository} = OpenBSD::PackageRepository->new(
		    "file:/$self->{fullrepo}");
		# this is just a dummy core, for running quick pipes
		$self->{core} = DPB::Core->new_noreg('localhost');
		$self->{logrebuild} = DPB::Util->make_hot(
		    $self->logger->open('rebuild'));
	}
d103 1
a103 3
my $uptodate = {};

sub check_signature
d105 2
a106 23
	my ($self, $core, $v) = @@_;
	my $name = $v->fullpkgname;
	return 0 unless -f "$self->{fullrepo}/$name.tgz";
	if ($uptodate->{$name}) {
		return 1;
	}
	# check the package
	my $p = $self->{repository}->find("$name.tgz");
	my $plist = $p->plist(\&OpenBSD::PackingList::UpdateInfoOnly);
	my $pkgsig = $plist->signature->string;
	# and the port
	my $portsig = $self->{state}->grabber->grab_signature($core,
	    $v->fullpkgpath);
	if ($portsig eq $pkgsig) {
		$uptodate->{$name} = 1;
		print {$self->{logrebuild}} "$name: uptodate\n";
		return 1;
	} else {
		print {$self->{logrebuild}} "$name: rebuild\n";
		$self->{state}->grabber->clean_packages($core,
		    $v->fullpkgpath);
		return 0;
	}
d109 1
a109 1
sub check
a110 8
	my ($self, $v) = @@_;
	my $check = -f $self->pkgfile($v);
	return 0 unless $check;
	if ($self->{rebuild}) {
		return $uptodate->{$v->fullpkgname};
	} else {
		return 1;
	}
d113 1
a113 1
sub register_built
a114 4
	my ($self, $v) = @@_;
	for my $w ($v->build_path_list) {
		$uptodate->{$w->fullpkgname} = -f $self->pkgfile($w);
	}
d194 67
@


1.25
log
@add affinity information to restart jobs on the right host preferentially.
- affinity info is similar to locks, but with a completely different
lifetime.
- streamline the main loop of the engine, so that it can do two passes:
first pass shuns paths with the wrong affinity. If no good path is found,
those are considered during the second pass.
- make the Core factory aware of what hosts might be running, so that
affinity info for machines removed from a config file will be ignored.

thanks to landry@@ for a few tests.
@
text
@d2 1
a2 1
# $OpenBSD: PortBuilder.pm,v 1.24 2012/10/08 12:41:03 espie Exp $
d107 1
a107 1
my $signature_is_uptodate = {};
d114 1
a114 1
	if ($signature_is_uptodate->{$name}) {
d125 1
a125 1
		$signature_is_uptodate->{$name} = 1;
d142 1
a142 1
		return $signature_is_uptodate->{$v->fullpkgname};
d151 3
a153 1
	$signature_is_uptodate->{$v->fullpkgname} = -f $self->pkgfile($v);
@


1.24
log
@small change for people running multiple hosts:

options on the command line now define *defaults* that host files can
override (for instance -j, stuck, -p, -J).

Add -p /n to mean "take number of jobs, if >1, divide by n, round up to 2,
and use that for parallel.

Document -p.

Make junk be 'by host' (and it's a prop, so you can tweak it).

concurrent log that records how many jobs are running each time it changes.
tag parallel builds *n in the time record.
@
text
@d2 1
a2 1
# $OpenBSD: PortBuilder.pm,v 1.23 2012/09/23 18:13:32 espie Exp $
a220 1
	return $core;
@


1.23
log
@new framework to deal with the new ports cluster, to be documented
@
text
@d2 1
a2 1
# $OpenBSD: PortBuilder.pm,v 1.22 2012/04/21 11:30:53 espie Exp $
a36 1
	    junk => $state->opt('J'),
d160 3
d200 1
a200 1
	my ($self, $v, $core, $special, $parallel, $lock, $final_sub) = @@_;
d210 1
a210 1
	$job = DPB::Job::Port->new($log, $v, $self, $special, $parallel,
@


1.22
log
@make it possible to use a specialized wrapper to collect rss stats
@
text
@d2 1
a2 1
# $OpenBSD: PortBuilder.pm,v 1.21 2012/04/10 17:06:15 espie Exp $
d198 1
a198 1
	my ($self, $v, $core, $special, $lock, $final_sub) = @@_;
d208 1
a208 1
	$job = DPB::Job::Port->new($log, $v, $self, $special,
d212 3
@


1.21
log
@whitespace
@
text
@d2 1
a2 1
# $OpenBSD$
d86 4
@


1.20
log
@fix -a bug: if you specify -I ..., this shouldn't negate a -a.
"permanent build log" under %f/build-stats/%a
-J250 by default
@
text
@d2 1
a2 1
# $OpenBSD: PortBuilder.pm,v 1.19 2011/12/05 21:27:53 espie Exp $
d167 1
a167 1
		print $fh join(' ', $pkgpath, $host, $job->totaltime, $sz), 
d219 1
a219 1
	my $job = DPB::Job::Port::Install->new($log, $v, $self, 
@


1.19
log
@remove "needed" debug log now that things work fine.
@
text
@d2 1
a2 1
# $OpenBSD: PortBuilder.pm,v 1.18 2011/12/05 16:10:01 espie Exp $
d166 3
@


1.18
log
@turn -J into an option taking a number.
always run show-prepare-results, and always serialize
depends/prepare/show-prepare-results(/junk) on a single host.
@
text
@d2 1
a2 1
# $OpenBSD: PortBuilder.pm,v 1.17 2011/12/04 12:05:41 espie Exp $
d37 1
a45 4
	}
	if ($state->opt('J')) {
		$self->{junk_log} = DPB::Util->make_hot($self->logger->open("needed"));
		$self->{junk} = $state->opt('J');
@


1.17
log
@clean-up job running a bit: add methods to Grabber and PortBuilder objects
to access more stuff they need.

Remove distantshell->make, ask state instead.
Provide state with the program we run, and the parameters we pass it.

- same make for distant and local hosts
- pass BUILD_ONCE=Yes if -a.
@
text
@d2 1
a2 1
# $OpenBSD: PortBuilder.pm,v 1.16 2011/12/03 11:10:48 espie Exp $
d47 2
a48 1
		$self->{junk} = DPB::Util->make_hot($self->logger->open("needed"));
@


1.16
log
@open needed just once.
@
text
@d2 1
a2 1
# $OpenBSD: PortBuilder.pm,v 1.15 2011/12/02 22:33:46 espie Exp $
a38 3
	    logger => $state->logger,
	    ports => $state->ports,
	    make => $state->make,
d47 1
a47 1
		$self->{junk} = DPB::Util->make_hot($state->{logger}->open("needed"));
d53 30
d87 1
a87 1
	$self->{global} = $self->{logger}->open("build");
d95 1
a95 1
		    $self->{logger}->open('rebuild'));
d160 1
a160 1
	my $sz = (stat $self->{logger}->log_pkgpath($v))[7];
d195 1
a195 1
	my $log = $self->{logger}->make_logs($v);
d210 1
a210 1
	$job->set_watch($self->{logger}, $v);
d217 1
a217 1
	my $log = $self->{logger}->make_logs($v);
@


1.15
log
@new junk option (to remove packages as they're no longer needed) to pass
around thru JobBuilder (along with locks since we need to write stuff into
that file)
@
text
@d2 1
a2 1
# $OpenBSD: PortBuilder.pm,v 1.14 2011/11/14 21:57:47 espie Exp $
a34 1
	    junk => $state->opt('J'),
d48 3
@


1.14
log
@explain to the engine how to install stuff when it's ready (no error
checks though).

new -I option to do that.
change -C option to be more useful.
@
text
@d2 1
a2 1
# $OpenBSD: PortBuilder.pm,v 1.13 2011/11/12 13:19:26 espie Exp $
d35 1
d176 1
d178 3
a180 3
	print $lock "host=", $core->hostname, "\n";
	print $lock "pid=$core->{pid}\n";
	print $lock "start=$start (", DPB::Util->time2string($start), ")\n";
@


1.13
log
@make stuff slightly more verbose all the time
@
text
@d2 1
a2 1
# $OpenBSD: PortBuilder.pm,v 1.12 2011/09/25 10:41:30 espie Exp $
d34 1
a34 1
	    dontclean => $state->opt('C'),
d180 10
@


1.12
log
@make dpb more useful for people hacking on ports, allow them to not clean
the work directory after building.
@
text
@d2 1
a2 1
# $OpenBSD: PortBuilder.pm,v 1.11 2011/06/04 12:58:24 espie Exp $
d166 6
a171 6
	if ($self->{state}->opt('v')) {
		open my $fh, ">>", $log;
		print $fh ">>> Building under ";
		$v->quick_dump($fh);
		close($fh);
	}
@


1.11
log
@spaces
@
text
@d2 1
a2 1
# $OpenBSD$
d34 1
@


1.10
log
@- unify code in Fetch/Build subengines
- zap heuristic#3, not critical
- don't rebuild the Fetch queue all the time, it's too expensive
- fix bugs in FetchQueue computation, correctly handle 1 distfile case
- create a quick path thru adjust* that handles only new paths.
- use it during LISTING while fetching files, to make more files available
quicker.
- model distfiles as FDEPENDS, DIST, so that they can get dumped.
- add -v option that dumps a bit more stuff in log files.

with these, dpb will fetch all distfiles in a not too surprising order,
and it won't consume 40% cpu while doing so...
@
text
@d2 1
a2 1
# $OpenBSD: PortBuilder.pm,v 1.9 2011/05/29 09:30:13 espie Exp $
d33 1
a33 1
	    clean => $state->opt('c'),  
d38 2
a39 2
	    logger => $state->logger, 
	    ports => $state->ports, 
@


1.9
log
@if we're running -f, do the checksum part internally, since we already
checksummed stuff we fetched (will allow auto-refetch eventually).
@
text
@d2 1
a2 1
# $OpenBSD: PortBuilder.pm,v 1.8 2011/05/22 08:21:39 espie Exp $
d165 6
@


1.8
log
@initial support for fetching distfiles, somewhat experimental yet.
- clean up clock handling, jobs with timer.
- pass more parameters thru state
- tweak the engine to handle distfiles
- lots of new code in Fetch for new jobs.
@
text
@d2 1
a2 1
# $OpenBSD: PortBuilder.pm,v 1.7 2011/04/25 11:58:46 espie Exp $
d34 1
@


1.7
log
@finish refactoring options.
Deprecate: -t and -T
use -DCONNECTION_TIMEOUT=... -DDISPLAY_TIMEOUT=... instead
New feature: -DSTUCK_TIMEOUT=
kill tasks when they don't show any progress for that long.
@
text
@d2 1
a2 1
# $OpenBSD: PortBuilder.pm,v 1.6 2010/11/02 20:32:59 espie Exp $
d32 1
a50 6
sub set_grabber
{
	my ($self, $g) = @@_;
	$self->{grabber} = $g;
}

d89 1
a89 1
	my $portsig = $self->{grabber}->grab_signature($core,
d97 1
a97 1
		$self->{grabber}->clean_packages($core,
@


1.6
log
@in case the signature doesn't match, clean ALL packages that will be
rebuilt. Otherwise, you may suffer through 3 or 4 rebuilds of qt3...

ouchie.
@
text
@d2 1
a2 1
# $OpenBSD: PortBuilder.pm,v 1.5 2010/11/01 10:55:26 espie Exp $
d30 11
a40 9
	my $class = shift;
	my ($opt_c, $opt_s, $opt_u, $opt_U, $opt_R, $fullrepo, $logger, $ports, $make,
	    $h) = @@_;
	my $self = bless {clean => $opt_c,  size => $opt_s,
	    rebuild => $opt_R,
	    fullrepo => $fullrepo,
	    logger => $logger, ports => $ports, make => $make,
	    heuristics => $h}, $class;
	if ($opt_u || $opt_U) {
d43 1
a43 1
	if ($opt_U) {
@


1.5
log
@much better implementation of -R. In case of rebuilds, check does not "see"
pkgfiles, unless they've been registered.
the engine queues everything to build, but normal build is only an
existence/signature check. The actual build tasks only get queued when
the package does not exist, or if its signature does NOT match the ports
tree.

Should make matthieu@@ happy.
@
text
@d2 1
a2 1
# $OpenBSD: PortBuilder.pm,v 1.4 2010/10/30 11:36:07 espie Exp $
d100 1
a100 1
		$self->{grabber}->clean_package($core,
@


1.4
log
@don't cheat, we have to make clean=package to avoid side-effects with
arch-independent packages.
@
text
@d2 1
a2 1
# $OpenBSD: PortBuilder.pm,v 1.3 2010/10/30 11:19:38 espie Exp $
d79 1
a79 1
sub signature_check
d81 1
a81 1
	my ($self, $v) = @@_;
d92 1
a92 1
	my $portsig = $self->{grabber}->grab_signature($self->{core}, 
d100 1
a100 1
		$self->{grabber}->clean_package($self->{core},
d109 2
d112 1
a112 1
		return $self->signature_check($v);
d114 1
a114 1
		return -f $self->pkgfile($v);
d118 6
d127 1
d130 1
a131 1
	my $log = $self->{global};
a170 2
#	(sub {
#	}, 	$v, " (".$self->{heuristics}->measure($v).")");
@


1.3
log
@proof-of-concept implementation of -R (rebuild when signature changes).
Somewhat inefficient (deep check of package vs port signature).
More proper approach would be to tell the engine to always build, have first
step be a check for signature if the package exist, and abort if it matches:
- here we double check everything
- propagating rebuilds means non-uptodate packages give rise to non uptodate.
@
text
@d2 1
a2 1
# $OpenBSD: PortBuilder.pm,v 1.2 2010/10/27 12:58:26 espie Exp $
d100 2
a101 1
		unlink("$self->{fullrepo}/$name.tgz");
@


1.2
log
@tie engine with var grabber, get ready to re-do port meta on error.
@
text
@d2 1
a2 1
# $OpenBSD$
d31 1
a31 1
	my ($opt_c, $opt_s, $opt_u, $opt_U, $fullrepo, $logger, $ports, $make,
d34 1
d48 6
d59 9
d77 28
d108 5
a112 1
	return -f $self->pkgfile($v);
@


1.1
log
@Initial revision
@
text
@d2 1
a2 1
# $OpenBSD: PortBuilder.pm,v 1.8 2010/05/22 08:43:18 espie Exp $
@


1.1.1.1
log
@move stuff here from infra/build
@
text
@@
