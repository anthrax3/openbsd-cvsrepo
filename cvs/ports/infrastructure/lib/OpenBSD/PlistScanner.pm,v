head	1.10;
access;
symbols
	OPENBSD_6_0:1.10.0.6
	OPENBSD_6_0_BASE:1.10
	OPENBSD_5_9:1.10.0.2
	OPENBSD_5_9_BASE:1.10
	OPENBSD_5_8:1.10.0.4
	OPENBSD_5_8_BASE:1.10
	OPENBSD_5_7:1.1.0.4
	OPENBSD_5_7_BASE:1.1
	OPENBSD_5_6:1.1.0.2
	OPENBSD_5_6_BASE:1.1;
locks; strict;
comment	@# @;


1.10
date	2015.06.22.09.33.03;	author espie;	state Exp;
branches;
next	1.9;
commitid	WDy5Phdmx574JvRH;

1.9
date	2015.06.08.15.37.20;	author espie;	state Exp;
branches;
next	1.8;
commitid	i3dxBR6YJ58vD7J6;

1.8
date	2015.06.08.15.11.53;	author espie;	state Exp;
branches;
next	1.7;
commitid	oWkv34QAoTFsC634;

1.7
date	2015.06.08.12.56.26;	author espie;	state Exp;
branches;
next	1.6;
commitid	UcaYGHU4c0oa7PWz;

1.6
date	2015.06.08.10.32.55;	author espie;	state Exp;
branches;
next	1.5;
commitid	I2DUXmoLRD1ECVDm;

1.5
date	2015.06.07.12.21.21;	author espie;	state Exp;
branches;
next	1.4;
commitid	Mi5UXs9O9ymlsmU2;

1.4
date	2015.06.07.12.05.22;	author espie;	state Exp;
branches;
next	1.3;
commitid	QCBfMUw04lhIe4qq;

1.3
date	2015.06.06.15.01.43;	author espie;	state Exp;
branches;
next	1.2;
commitid	ty3gPuo6uYN2mAhZ;

1.2
date	2015.05.29.10.40.06;	author espie;	state Exp;
branches;
next	1.1;
commitid	pWmerUsifWPK92Pm;

1.1
date	2014.03.10.09.46.08;	author espie;	state Exp;
branches;
next	;


desc
@@


1.10
log
@do an extra mode that will first scan the ports tree, and then extract only
the plists that are current.
took longer than expected because I found a bug in my setup...
probably going to be more code to say "hey, these current packages depend
on not current".
@
text
@# $OpenBSD: PlistScanner.pm,v 1.9 2015/06/08 15:37:20 espie Exp $
# Copyright (c) 2014 Marc Espie <espie@@openbsd.org>
#
# Permission to use, copy, modify, and distribute this software for any
# purpose with or without fee is hereby granted, provided that the above
# copyright notice and this permission notice appear in all copies.
#
# THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
# ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
# OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

use strict;
use warnings;

package OpenBSD::PlistScanner;
use OpenBSD::PackageInfo;
use OpenBSD::AddCreateDelete;
use OpenBSD::PackingList;

sub handle_plist
{
	my ($self, $filename, $plist) = @@_;
	if (!defined $plist) {
		$self->ui->errsay("Error reading #1", $filename);
		return;
	}
	if (!defined $plist->pkgname) {
		if (-z $filename) {
			$self->ui->errsay("Empty plist file #1", $filename);
		} else {
			$self->ui->errsay("Invalid package #1", $filename);
		}
		return;
	}
	$self->{name2path}{$plist->pkgname} = $plist->fullpkgpath;
	$self->{currentname} = $plist->pkgname." - ".$plist->fullpkgpath;
	$self->say("#1 -> #2", $filename, $plist->pkgname) 
	    if $self->ui->verbose;
	$self->register_plist($plist);
	$plist->forget;
}

sub progress
{
	return shift->ui->progress;
}

sub handle_file
{
	my ($self, $filename) = @@_;
	return if -d $filename;
	my $plist = OpenBSD::PackingList->fromfile($filename);
	$self->handle_plist($filename, $plist);
}

sub handle_portspath
{
	my ($self, $path) = @@_;
	foreach (split(/:/, $path)) {
		$self->handle_portsdir($_);
	}
}

sub find_current_pkgnames
{
	my ($self, $dir) = @@_;

	my $done = {};
	my @@todo = ();

	while (my ($name, $path) = each %{$self->{name2path}}) {
		next if $self->{current}{$name};
		next if $done->{$path};
		push(@@todo, $path);
	}
	my $total = scalar(@@todo);
	my $i = 0;
	while (my @@l = (splice @@todo, 0, 1000)) {
		my $pid = open(my $output, "-|");
		if ($pid == 0) {
			$DB::inhibit_exit = 0;
			chdir($dir) or die "bad directory $dir";
			$ENV{SUBDIR} = join(' ', @@l);
			open STDERR, ">", "/dev/null";
			exec { $self->{make} } 
			    ("make", 'show=FULLPKGNAME${SUBPACKAGE}', 
				'REPORT_PROBLEM=true', 'ECHO_MSG=:');
			exit(1);
		}
		while (<$output>) {
			$i++;
			$self->progress->show($i, $total);
			chomp;
			$self->{current}{$_} = 1;
		}
		close($output);
	}
}

sub find_all_current_pkgnames
{
	my ($self, $dir) = @@_;

	$self->progress->set_header("Figuring out current names");
	open(my $input, "cd $dir && $self->{make} show='PKGPATHS PKGNAMES' ECHO_MSG=:|");
	while (<$input>) {
		chomp;
		my @@values = split(/\s+/, $_);
		my $line2 = <$input>;
		chomp $line2;
		my @@keys = split(/\s+/, $line2);
		$self->progress->message($values[0]);
		while (my $key = shift @@keys) {
			my $value = shift @@values;
			$self->{name2path}{$key} = $value;
			$self->{current}{$key} = 1;
	#		$self->ui->say("pkgname: #1", $key);
		}
	}
	$self->progress->next;
}

sub reader
{
	my ($self, $rdone) = @@_;
	return
	    sub {
		my ($fh, $cont) = @@_;
		local $_;
		while (<$fh>) {
			return if m/^\=\=\=\> /o;
			&$cont($_);
		}
		$$rdone = 1;
	    };
}

sub handle_portsdir
{
	my ($self, $dir) = @@_;

	open(my $input, "cd $dir && $self->{make} print-plist-all |");
	my $done = 0;
	while (!$done) {
		my $plist = OpenBSD::PackingList->read($input, 
		    $self->reader(\$done));
		if (defined $plist && $plist->pkgname) {
			$self->progress->message($plist->fullpkgpath ||
			    $plist->pkgname);
			$self->handle_plist($dir, $plist);
		}
	}
}

sub rescan_dependencies
{
	my ($self, $dir) = @@_;

	$self->progress->set_header("Scanning extra dependencies");
	my $notfound = {};
	my $todo;
	do {
		$todo = {};
		while (my ($pkg, $reason) = each %{$self->{wanted}}) {
			next if $self->{got}{$pkg};
			next if $notfound->{$pkg};
			$todo->{$pkg} = $reason;
		}
		while (my ($pkgname, $reason) = each %$todo) {
			$self->progress->say("rescanning: #1 (#2)",
			    $pkgname, $reason);
			my $file = "$dir/$pkgname";
			if (-f $file) {
				$self->handle_file($file);
			} else {
				$notfound->{$pkgname} = $reason;
		    	}
		}
	} while (keys %$todo > 0);
	$self->progress->next;
}

sub scan
{
	my $self = shift;
	$self->progress->set_header("Scanning");
	if ($self->ui->opt('d')) {
		opendir(my $dir, $self->ui->opt('d'));
		my @@l = readdir $dir;
		closedir($dir);

		$self->progress->for_list("Scanning", \@@l,
		    sub {
			my $pkgname = shift;
			return if $pkgname eq '.' or $pkgname eq '..';
			if ($self->ui->opt('f') &&
			    !defined $self->{current}{$pkgname}) {
			    	return;
			}
#			$self->ui->say("doing: #1", $pkgname);
			$self->handle_file($self->ui->opt('d')."/$pkgname");
		    });
		if ($self->ui->opt('f')) {
		}
	} elsif ($self->ui->opt('p')) {
		$self->handle_portspath($self->ui->opt('p'));
	} elsif (@@ARGV==0) {
		@@ARGV=(<*.tgz>);
	}

	if (@@ARGV > 0) {
		$self->progress->for_list("Scanning", \@@ARGV,
		    sub {
			my $pkgname = shift;
			my $true_package = $self->ui->repo->find($pkgname);
			return unless $true_package;
			my $dir = $true_package->info;
			$true_package->close;
			$self->handle_file($dir.CONTENTS);
			rmtree($dir);
		    });
	}
	if ($self->ui->opt('d')) {
		$self->rescan_dependencies($self->ui->opt('d'));
	}
}

sub run
{
	my $self = shift;

	if ($self->ui->opt('p') && $self->ui->opt('f')) {
		$self->find_all_current_pkgnames($self->ui->opt('p'));
	}
	$self->scan;

	if ($self->ui->opt('d') && $self->ui->opt('p')) {
		$self->progress->set_header("Computing current pkgnames");
		$self->find_current_pkgnames($self->ui->opt('p'));
	}

	$self->display_results;
}

sub say
{
	my $self = shift;
	my $msg = $self->ui->f(@@_)."\n";
	$self->ui->_print($msg) unless $self->ui->opt('s');
	if (defined $self->{output}) {
		print {$self->{output}} $msg;
	}
}

sub fullname
{
	my ($self, $pkgname) = @@_;
	my $path = $self->{name2path}{$pkgname};
	if ($self->{current}{$pkgname}) {
		return "!$pkgname($path)";
	} else {
		return "$pkgname($path)";
	}
}

sub ui
{
	my $self = shift;
	return $self->{ui};
}

sub handle_options
{
	my ($self, $extra, $usage) = @@_;
	$usage //= "[-vefS] [-d plist_dir] [-o output] [-p ports_dir] [pkgname ...]";
	$extra //= '';
	$self->ui->handle_options($extra.'d:efo:p:sS', $usage);
}

sub new
{
	my ($class, $cmd) = @@_;
	my $ui = OpenBSD::AddCreateDelete::State->new($cmd);
	my $o = bless {ui => $ui, 
	    make => $ENV{MAKE} || 'make', 
	    name2path => {}, 
	    current => {}
	    }, $class;
	$o->handle_options;
	if ($ui->opt('o')) {
		open $o->{output}, '>', $ui->opt('o')
		    or $ui->fatal("Can't write to #1: #2", $ui->opt('o'), $!);
	}
	return $o;
}

1;
@


1.9
log
@unify options.
@
text
@d1 1
a1 1
# $OpenBSD: PlistScanner.pm,v 1.8 2015/06/08 15:11:53 espie Exp $
d40 1
d75 2
a76 1
	for my $path (values %{$self->{name2path}}) {
d104 23
d159 28
d200 5
d207 2
d227 3
a229 29
	$self->progress->set_header("Scanning extra dependencies");
	$self->progress->message("");
	my $notfound = {};
	my $todo;
	do {
		$todo = {};
		for my $pkg (keys %{$self->{wanted}}) {
			next if $self->{got}{$pkg};
			next if $notfound->{$pkg};
			$todo->{$pkg} = 1;
			$self->say("Dependency not found #1", $pkg);
		}
		for my $pkgname (keys %$todo) {
			my $true_package;
			if ($self->ui->opt('S')) {
				$true_package = $self->ui->repo->find($pkgname);
			}
			if (defined $true_package) {
				my $dir = $true_package->info;
				$true_package->close;
				my $plist = OpenBSD::PackingList->fromfile($dir.CONTENTS);
				File::Path::rmtree($dir);
				$self->register_plist($plist);
			} else {
				$notfound->{$pkgname} = 1;
		    	}
		}
	} while (keys %$todo > 0);
	$self->progress->next;
d236 3
d279 1
a279 1
	$usage //= "[-veS] [-d plist_dir] [-o output] [-p ports_dir] [pkgname ...]";
d281 1
a281 1
	$self->ui->handle_options($extra.'d:eo:p:sS', $usage);
d287 1
a287 1
	my $ui = OpenBSD::AddCreateDelete::State->new('check-conflicts');
@


1.8
log
@close enough that I can unify them together.
Introduce an interface to specifically display results, so that it
can be copied to an output file, and just not appear on the terminal
@
text
@d1 1
a1 1
# $OpenBSD: PlistScanner.pm,v 1.7 2015/06/08 12:56:26 espie Exp $
d239 8
a250 2
	$ui->handle_options('d:eo:p:sS', '[-veS] [-d plist_dir] [-o output] [-p ports_dir] [pkgname ...]');
	my $make = $ENV{MAKE} || 'make';
d256 1
@


1.7
log
@unified dependency tagging, so that both tools can do dependency closure.
Provide -o output option, which also saves the actual useful output somewhere
@
text
@d1 1
a1 1
# $OpenBSD: PlistScanner.pm,v 1.6 2015/06/08 10:32:55 espie Exp $
d40 1
a40 1
	$self->ui->say("#1 -> #2", $filename, $plist->pkgname) 
d177 1
a177 1
			$self->ui->say("Not found #1", $pkg);
d212 10
d243 1
a243 1
	$ui->handle_options('d:eo:p:S', '[-veS] [-d plist_dir] [-o output] [-p ports_dir] [pkgname ...]');
@


1.6
log
@tweak fullname to put the ! (for current packages at the start)
sort things in a more systematic way.
make sure results are displayed after the progress meter is properly
terminated
@
text
@d1 1
a1 1
# $OpenBSD: PlistScanner.pm,v 1.5 2015/06/07 12:21:21 espie Exp $
d167 29
d233 1
a233 1
	$ui->handle_options('d:ep:', '[-ve] [-d plist_dir] [-p ports_dir] [pkgname ...]');
d235 10
a244 3

	bless {ui => $ui, make => $make, name2path => {}, current => {}}, 
	    $class;
@


1.5
log
@fsck tricks. Very often, the "invalid plists" are actually empty files left
behind after a panic. So just say so, saves you the hastle of going edit
the file, and hey, that's just empty space!
@
text
@d1 1
a1 1
# $OpenBSD: PlistScanner.pm,v 1.4 2015/06/07 12:05:22 espie Exp $
d188 1
a188 1
		return "$pkgname!($path)";
@


1.4
log
@provide a forwarder to progressmeter, simplifies code
tweak for using in check-common-dirs: specify the reader,
allow a pass after scan.
@
text
@d1 1
a1 1
# $OpenBSD: PlistScanner.pm,v 1.3 2015/06/06 15:01:43 espie Exp $
d32 5
a36 1
		$self->ui->errsay("Invalid package #1", $filename);
@


1.3
log
@fine-tune display, better progress report when scanning the ports tree
@
text
@d1 1
a1 1
# $OpenBSD: PlistScanner.pm,v 1.2 2015/05/29 10:40:06 espie Exp $
d42 5
d90 1
a90 1
			$self->ui->progress->show($i, $total);
d98 15
d120 2
a121 10
		my $plist = OpenBSD::PackingList->read($input, sub {
			my ($fh, $cont) = @@_;
			local $_;
			while (<$fh>) {
				return if m/^\=\=\=\> /o;
				next unless m/^\@@(?:cwd|name|info|man|file|lib|shell|bin|conflict|comment\s+pkgpath\=)\b/o || !m/^\@@/o;
				&$cont($_);
			}
			$done = 1;
		});
d123 1
a123 1
			$self->ui->progress->message($plist->fullpkgpath ||
d130 1
a130 1
sub run
d133 1
a133 4


	$self->ui->progress->set_header("Scanning");
	my $portpath;
d139 1
a139 1
		$self->ui->progress->for_list("Scanning", \@@l,
a146 1
		$portpath = 1;
d152 1
a152 1
		$self->ui->progress->for_list("Scanning", \@@ARGV,
d163 5
d169 4
a172 2
	if (!$portpath && $self->ui->opt('p')) {
		$self->ui->progress->set_header("Computing current pkgnames");
d175 1
@


1.2
log
@similar change to check-conflicts
@
text
@d1 1
a1 1
# $OpenBSD: PlistScanner.pm,v 1.1 2014/03/10 09:46:08 espie Exp $
d21 2
d110 3
a112 1
		if (defined $plist && $plist->pkgname()) {
a113 1
			$self->ui->progress->working(10);
@


1.1
log
@extract a large part of check-conflicts. aim is to reuse that in
check-common-dirs, as those two tools do very similar things
@
text
@d1 1
a1 1
# $OpenBSD$
d103 1
a103 1
				next unless m/^\@@(?:cwd|name|info|man|file|lib|shell|bin|conflict|comment\s+subdir\=)\b/o || !m/^\@@/o;
@

