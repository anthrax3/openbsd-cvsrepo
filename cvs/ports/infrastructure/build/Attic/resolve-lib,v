head	1.21;
access;
symbols
	OPENBSD_4_8:1.20.0.2
	OPENBSD_4_8_BASE:1.20
	OPENBSD_4_7:1.17.0.14
	OPENBSD_4_7_BASE:1.17
	OPENBSD_4_6:1.17.0.12
	OPENBSD_4_6_BASE:1.17
	OPENBSD_4_5:1.17.0.10
	OPENBSD_4_5_BASE:1.17
	OPENBSD_4_4:1.17.0.8
	OPENBSD_4_4_BASE:1.17
	OPENBSD_4_3:1.17.0.6
	OPENBSD_4_3_BASE:1.17
	OPENBSD_4_2:1.17.0.4
	OPENBSD_4_2_BASE:1.17
	OPENBSD_4_1:1.17.0.2
	OPENBSD_4_1_BASE:1.17
	OPENBSD_4_0:1.13.0.2
	OPENBSD_4_0_BASE:1.13
	OPENBSD_3_9:1.12.0.2
	OPENBSD_3_9_BASE:1.12
	OPENBSD_3_8:1.4.0.12
	OPENBSD_3_8_BASE:1.4
	OPENBSD_3_7:1.4.0.10
	OPENBSD_3_7_BASE:1.4
	OPENBSD_3_6:1.4.0.8
	OPENBSD_3_6_BASE:1.4
	OPENBSD_3_5:1.4.0.6
	OPENBSD_3_5_BASE:1.4
	OPENBSD_3_4:1.4.0.4
	OPENBSD_3_4_BASE:1.4
	OPENBSD_3_3:1.4.0.2
	OPENBSD_3_3_BASE:1.4
	OPENBSD_3_2:1.3.0.2
	OPENBSD_3_2_BASE:1.3
	OPENBSD_3_1:1.2.0.2
	OPENBSD_3_1_BASE:1.2;
locks; strict;
comment	@# @;


1.21
date	2010.08.20.15.07.22;	author espie;	state dead;
branches;
next	1.20;

1.20
date	2010.06.21.09.16.01;	author espie;	state Exp;
branches;
next	1.19;

1.19
date	2010.05.02.20.54.25;	author espie;	state Exp;
branches;
next	1.18;

1.18
date	2010.04.06.09.39.51;	author espie;	state Exp;
branches;
next	1.17;

1.17
date	2006.11.20.12.13.43;	author espie;	state Exp;
branches;
next	1.16;

1.16
date	2006.09.18.12.56.22;	author espie;	state Exp;
branches;
next	1.15;

1.15
date	2006.09.18.11.30.08;	author espie;	state Exp;
branches;
next	1.14;

1.14
date	2006.09.18.11.27.47;	author espie;	state Exp;
branches;
next	1.13;

1.13
date	2006.08.01.10.00.55;	author espie;	state Exp;
branches;
next	1.12;

1.12
date	2005.12.06.17.15.38;	author ian;	state Exp;
branches;
next	1.11;

1.11
date	2005.10.29.12.27.31;	author espie;	state Exp;
branches;
next	1.10;

1.10
date	2005.10.29.12.14.26;	author espie;	state Exp;
branches;
next	1.9;

1.9
date	2005.10.29.12.12.39;	author espie;	state Exp;
branches;
next	1.8;

1.8
date	2005.10.10.19.43.33;	author espie;	state Exp;
branches;
next	1.7;

1.7
date	2005.10.10.19.04.06;	author espie;	state Exp;
branches;
next	1.6;

1.6
date	2005.10.09.13.27.39;	author espie;	state Exp;
branches;
next	1.5;

1.5
date	2005.10.09.12.01.22;	author espie;	state Exp;
branches;
next	1.4;

1.4
date	2002.11.28.19.20.37;	author espie;	state Exp;
branches;
next	1.3;

1.3
date	2002.10.01.12.16.38;	author naddy;	state Exp;
branches;
next	1.2;

1.2
date	2002.03.04.13.39.34;	author espie;	state Exp;
branches;
next	1.1;

1.1
date	2001.11.17.10.39.19;	author espie;	state Exp;
branches;
next	;


desc
@@


1.21
log
@kill a few things which have now MOVED
@
text
@#! /usr/bin/perl
# $OpenBSD: resolve-lib,v 1.20 2010/06/21 09:16:01 espie Exp $
#
# Copyright (c) 2001-2010 Marc Espie <espie@@openbsd.org>
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions
# are met:
# 1. Redistributions of code must retain the above copyright
#    notice, this list of conditions and the following disclaimer.
# 2. Neither the name of OpenBSD nor the names of its contributors
#    may be used to endorse or promote products derived from this software
#    without specific prior written permission.
#
# THIS SOFTWARE IS PROVIDED BY ITS AUTHOR AND THE OpenBSD project ``AS IS'' AND
# ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
# FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
# DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
# OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
# HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
# LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
# OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
# SUCH DAMAGE.

use strict;
use warnings;
use OpenBSD::LibSpec;
use OpenBSD::LibSpec::Build;
use OpenBSD::Paths;

my $LOCALBASE = $ENV{LOCALBASE};
my $error = 0;

sub solve_spec
{
	my ($spec, $noshared, $repo) = @@_;
	my $r = $spec->findbest($repo, $LOCALBASE);
	
	if (!defined $r) {
		print STDERR "Missing library for ", $spec->to_string, "\n";
		$error = 1;
	} else {
		print $spec->key, $r->version, "\n";
	}
}


my $noshared; 
# Grab arguments
if (@@ARGV > 0 && $ARGV[0] eq '-noshared') {
	$noshared = 1;
	shift;
}

my $_;
my $repo = OpenBSD::LibRepo->new;

while(<STDIN>) {
	chomp;
	for my $s (split(/\s+/, $_)) {
		my $lib = OpenBSD::Library::Build->from_string($s);
		next if !$lib->is_valid;
		next if $noshared and !$lib->is_static;
		$repo->register($lib, 1);
	}
}

my $done = {};
for my $s (@@ARGV) {
	my $spec = OpenBSD::LibSpec::Build->from_string($s);
	next if $done->{$spec};
	$done->{$spec} = 1;
	solve_spec($spec, $noshared, $repo);
}

exit($error);
@


1.20
log
@woah, who builds vax ?
@
text
@d2 1
a2 1
# $OpenBSD: resolve-lib,v 1.19 2010/05/02 20:54:25 espie Exp $
@


1.19
log
@make use of the recent pkg_add changes (required), much simpler resolve-lib !
(tested thru a full bulk, obviously)
@
text
@d2 1
a2 1
# $OpenBSD$
d65 1
a65 1
		next if $noshared and !lib->is_static;
@


1.18
log
@adds an extra "depends" stage which runs pkg_add once, before prepare
checks the deps.
Solves the "avahi rebuilds with full shit" in some build orders that
naddy@@ reported.
@
text
@d2 1
a2 1
# $OpenBSD: resolve-lib,v 1.17 2006/11/20 12:13:43 espie Exp $
d4 1
a4 1
# Copyright (c) 2001, 2005 Marc Espie <espie@@openbsd.org>
d29 3
d33 1
a33 2
my $LOCALBASE = $ENV{'LOCALBASE'};
my $X11BASE = $ENV{'X11BASE'};
a35 60
sub parse_spec_path
{
    	my $req = shift;
	my $spec = $req->{spec};
	if ($spec =~ m|^/.*/|) {
		$req->{specdir}=$&;
		$req->{prefix} = '';
		$req->{libname} = $';
	} elsif ($spec =~ m|^.*/|) {
		$req->{specdir} = "$LOCALBASE/$&";
		$req->{prefix} =$&;
		$req->{libname} = $';
	} else {
		$req->{libname} = $spec;
		$req->{prefix} = '';
	}
}

sub parse_spec_versions
{
    	my $spec = shift;
	my $noshared = shift;

	my $req = {noshared => $noshared, strict => 0, sharedonly => 0 };
	$spec =~ s/\.$//;
	if ($spec =~ m/\.a$/) {
		$spec = $`;
		$req->{noshared} = 1;
	} else {
		if ($spec =~ m/\.(\>?)\=(\d+)\.(\d+)$/) {
			$req->{major} = $2;
			$req->{minor} = $3;
			$spec = $`;
			$req->{strict} = $1 eq '';
		} elsif ($spec =~ m/\.(\>?)\=(\d+)$/) {
			$req->{major} = $2;
			$req->{minor} = 0;
			$req->{strict} = $1 eq '';
			$spec = $`;
		} else {
			$req->{major} = 0;
			$req->{minor} = 0;
		}
		if ($spec =~ m/\.so$/) {
			$spec = $`;
			$req->{sharedonly} = 1;
		}
	}
	$req->{spec} = $spec;
	return $req;
}

sub parse_spec
{
	my ($spec, $noshared) = @@_;
	my $req = parse_spec_versions($spec);
	parse_spec_path($req);
	return $req;
}

d38 5
a42 62
	my $spec = shift;
	my $noshared = shift;
	my $req = parse_spec($spec, $noshared);

	my $found_shared;
	my $found_goodshared;
	my $bestmajor=-1; my $bestminor=-1;
	my $found_unshared;
	my $libname = $req->{libname};

	for my $file (@@_) {
		next unless $file =~ m|(.*/)|;
		if (defined $req->{specdir}) {
			next unless $1 eq $req->{specdir};
		} else {
			next unless $1 eq '/usr/lib/' or 
			    $1 eq "$LOCALBASE/lib/" or
			    $1 eq "$X11BASE/lib/";
		}
		my $_=$';
		if (!$req->{noshared} && 
		    m/^lib\Q$libname\E\.so\.(\d+)\.(\d+)$/) {
			$found_shared = $file;
			my $major = $1;
			my $minor = $2;
			if ($req->{strict}) {
				if ($major > $req->{major}) {
					print STDERR "Error: found library has too high a version $major: $spec\n";
					$error = 1;
					last;
				}
				if ($major < $req->{major}) {
					next;
				}
				if ($minor < $req->{minor}) {
					next;
				}
				$found_goodshared = 1;
				$bestmajor = $major;
				if ($minor >= $bestminor) {
					$bestminor = $minor;
				}
			} else {
				if ($major < $req->{major} || 
				    ($major == $req->{major} && $minor < $req->{minor})) {
					next;
				}
				$found_goodshared = 1;
				if ($major > $bestmajor || ($major == $bestmajor &&
				    $minor > $bestminor)) {
					$bestmajor = $major;
					$bestminor = $minor;
				}
			}
		} elsif (!$req->{sharedonly} && m/^lib\Q$libname\E\.a$/) {
			$found_unshared = 1;
		}
	}
	if ($found_goodshared) {
		print $req->{prefix},"$libname.$bestmajor.$bestminor\n";
	} elsif (defined $found_shared) {
		print STDERR "Error: bad shared lib version $found_shared ($spec)\n";
a43 2
	} elsif ($found_unshared) {
		print $req->{prefix},"$libname.a\n";
d45 1
a45 2
		print STDERR "Missing library for $spec\n";
		$error = 1;
d58 2
a59 1
my @@available;
d62 6
a67 1
	push(@@available, split(/\s+/, $_));
d69 1
d71 2
a72 1
for my $spec (@@ARGV) {
d75 1
a75 1
	solve_spec($spec, $noshared, @@available);
@


1.17
log
@zap duplicate specs
@
text
@d2 1
a2 1
# $OpenBSD: resolve-lib,v 1.16 2006/09/18 12:56:22 espie Exp $
d115 1
a115 1
		local $_=$';
d175 1
a175 1
local $_;
@


1.16
log
@remove hack to recognize .0.0.
@
text
@d2 1
a2 1
# $OpenBSD: resolve-lib,v 1.15 2006/09/18 11:30:08 espie Exp $
d181 1
d183 2
@


1.15
log
@also zap .n as a final.
@
text
@d2 1
a2 1
# $OpenBSD: resolve-lib,v 1.14 2006/09/18 11:27:47 espie Exp $
d63 1
a63 5
		if ($spec =~ m/\.0\.0$/) {
			$req->{major} = 0;
			$req->{minor} = 0;
			$spec = $`;
		} elsif ($spec =~ m/\.(\>?)\=(\d+)\.(\d+)$/) {
@


1.14
log
@zap .n.m suffix, just keep .0.0 as a special case for now.
@
text
@d2 1
a2 1
# $OpenBSD: resolve-lib,v 1.13 2006/08/01 10:00:55 espie Exp $
a71 4
		} elsif ($spec =~ m/\.(\d+)$/) {
			$req->{major} = $1;
			$req->{minor} = 0;
			$spec = $`;
@


1.13
log
@allows >= for lib-specs, needs some quoting for shell...
@
text
@d2 1
a2 1
# $OpenBSD: resolve-lib,v 1.12 2005/12/06 17:15:38 ian Exp $
d63 3
a65 3
		if ($spec =~ m/\.(\d+)\.(\d+)$/) {
			$req->{major} = $1;
			$req->{minor} = $2;
@


1.12
log
@Minor clarification of message, ok espie@@
@
text
@d2 1
a2 1
# $OpenBSD: resolve-lib,v 1.11 2005/10/29 12:27:31 espie Exp $
d67 3
a69 3
		} elsif ($spec =~ m/\.\=(\d+)\.(\d+)$/) {
			$req->{major} = $1;
			$req->{minor} = $2;
d71 1
a71 1
			$req->{strict} = 1;
d76 2
a77 2
		} elsif ($spec =~ m/\.\=(\d+)$/) {
			$req->{major} = $1;
d79 1
a79 1
			$req->{strict} = 1;
@


1.11
log
@more reports
@
text
@d2 1
a2 1
# $OpenBSD: resolve-lib,v 1.10 2005/10/29 12:14:26 espie Exp $
d165 1
a165 1
		print STDERR "Error: bad shared library $found_shared ($spec)\n";
@


1.10
log
@fix
@
text
@d2 1
a2 1
# $OpenBSD: resolve-lib,v 1.9 2005/10/29 12:12:39 espie Exp $
d131 1
a131 1
					print STDERR "Error: strict library too high\n";
@


1.9
log
@better error message for slackers who can't read perl.
@
text
@d2 1
a2 1
# $OpenBSD: resolve-lib,v 1.8 2005/10/10 19:43:33 espie Exp $
d126 1
a126 1
			$found_shared = 1;
d164 2
a165 2
	} elsif ($found_shared) {
		print STDERR "Error: bad shared library $file ($spec)\n";
@


1.8
log
@protect against cases where @@ARGV == 0, which can happen very seldom...
@
text
@d2 1
a2 1
# $OpenBSD: resolve-lib,v 1.7 2005/10/10 19:04:06 espie Exp $
d165 1
a165 1
		print STDERR "Error: bad shared library\n";
@


1.7
log
@make sure to get ALL libs, that is, several lines in case we need pkg_info
to get the right libraries.
@
text
@d2 1
a2 1
# $OpenBSD: resolve-lib,v 1.6 2005/10/09 13:27:39 espie Exp $
d178 1
a178 1
if ($ARGV[0] eq '-noshared') {
@


1.6
log
@let resolve-lib return a useful error code
@
text
@d2 1
a2 1
# $OpenBSD: resolve-lib,v 1.5 2005/10/09 12:01:22 espie Exp $
d183 6
a188 1
my @@available = split(/\s+/, <STDIN>);
@


1.5
log
@tweak the way library dependencies are resolved to speed them up.
Now, resolve-lib can take a big list of libraries with full paths,
and it can solve a big list of spec at once.
Basically, we move most of the parsing of spec paths into resolve-lib.

Since print-package-signature does build a full list of libs, let's solve
it all at once, instead of invoking a costly perl script repeatedly.

Add some caching possibilities for out-of-date. Specifically:
- store libraries for each package under the directory _PORT_LIBS_CACHE
- use the dependency cache _DEPENDS_FILE to avoid recreating dependency
chains, add a new file _DEPENDS_CACHE that will accumulate all dependencies,
and extract these with a simple script extract-dependencies.

Use echo to build libraries lists instead of ls, that's a bit simpler...

Some more clean-up will happen: it's probably simpler to parse libspecs
at once, extract the libraries needed and go fetch the corresponding libraries
just once.
@
text
@d2 1
a2 1
# $OpenBSD: resolve-lib,v 1.4 2002/11/28 19:20:37 espie Exp $
d32 1
d131 2
a132 1
					print "Error: strict library too high\n";
d166 1
d171 1
d187 2
@


1.4
log
@dot is regexp magic
@
text
@d1 4
a4 2
#!/usr/bin/perl
# $OpenBSD: resolve-lib,v 1.3 2002/10/01 12:16:38 naddy Exp $
a5 2
# Copyright (c) 2001
# Marc Espie.  All rights reserved.
d28 1
d30 2
a31 5
my $noshared; 
my $sharedonly;
my $strict;
my $reqmajor;
my $reqminor;
d33 16
a48 5
# Grab arguments
$_=shift;
if ($_ eq '-noshared') {
	$noshared = 1;
	$_ = shift;
d51 37
a87 28
s/\.$//;
# Parse spec
if (m/\.a$/) {
	$_ = $`;
	$noshared = 1;
} else {
	if (m/\.(\d+)\.(\d+)$/) {
		$reqmajor = $1;
		$reqminor = $2;
		$_ = $`;
	} elsif (m/\.\=(\d+)\.(\d+)$/) {
		$reqmajor = $1;
		$reqminor = $2;
		$_ = $`;
		$strict = 1;
	} elsif (m/\.(\d+)$/) {
		$reqmajor = $1;
		$reqminor = 0;
		$_ = $`;
	} elsif (m/\.\=(\d+)$/) {
		$reqmajor = $1;
		$reqminor = 0;
		$strict = 1;
		$_ = $`;
	}
	if (m/\.so$/) {
		$_ = $`;
		$sharedonly = 1;
d89 2
d93 1
d95 5
a99 1
my $libname=$_;
d101 16
a116 29
my $bestmajor=-1;
my $bestminor=-1;

my $found_shared;
my $found_goodshared;
my $found_unshared;

while(<>) {
	chomp;
	if (!$noshared && m/^lib\Q$libname\E\.so\.(\d+)\.(\d+)$/) {
		$found_shared = 1;
		my $major = $1;
		my $minor = $2;
		if ($strict) {
			if ($major > $reqmajor) {
				print "Error: strict library too high\n";
				exit(0);
			}
			if ($major < $reqmajor) {
				next;
			}
			if ($minor < $reqminor) {
				next;
			}
			$found_goodshared = 1;
			$bestmajor = $major;
			if ($minor >= $bestminor) {
				$bestminor = $minor;
			}
d118 37
a154 9
			if ($major < $reqmajor || ($major == $reqmajor &&
			    $minor < $reqminor)) {
				next;
		    	}
			$found_goodshared = 1;
			if ($major > $bestmajor || ($major == $bestmajor &&
			    $minor > $bestminor)) {
			    	$bestmajor = $major;
				$bestminor = $minor;
d156 2
d159 9
a167 2
	} elsif (!$sharedonly && m/^lib\Q$libname\E\.a$/) {
		$found_unshared = 1;
d171 6
a176 8
if ($found_goodshared) {
	print "$libname.$bestmajor.$bestminor\n";
} elsif ($found_shared) {
	print "Error: bad shared library\n";
} elsif ($found_unshared) {
	print "$libname.a\n";
} else {
	print "Missing library\n";
d179 3
@


1.3
log
@Protect against meta-characters in library names (e.g. "libestdc++").
Mostly from pvalchev@@
@
text
@d2 1
a2 1
# $OpenBSD: resolve-lib,v 1.2 2002/03/04 13:39:34 espie Exp $
d117 1
a117 1
	} elsif (!$sharedonly && m/^lib\Q$libname\E.a$/) {
@


1.2
log
@do not consider static libraries if dynamic libraries are around.
This is not the linker's way of working, but this is the way dependencies
must be handled to find about update issues.

naddy@@ agrees, nobody else gives a fuck.
@
text
@d2 1
a2 1
# $OpenBSD: resolve-lib,v 1.1 2001/11/17 10:39:19 espie Exp $
d85 1
a85 1
	if (!$noshared && m/^lib$libname\.so\.(\d+)\.(\d+)$/) {
d117 1
a117 1
	} elsif (!$sharedonly && m/^lib$libname.a$/) {
@


1.1
log
@Use perl lib depends checker, that parses the full gamut of libspecs.
@
text
@d2 1
a2 1
# $OpenBSD$
d80 1
d86 1
d100 1
a100 1
			$found_shared = 1;
d110 1
a110 1
			$found_shared = 1;
d122 1
a122 1
if ($found_shared) {
d124 2
@

