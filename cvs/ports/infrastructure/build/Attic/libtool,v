head	1.130;
access;
symbols
	OPENBSD_4_8:1.129.0.2
	OPENBSD_4_8_BASE:1.129
	OPENBSD_4_7:1.116.0.2
	OPENBSD_4_7_BASE:1.116
	OPENBSD_4_6:1.76.0.4
	OPENBSD_4_6_BASE:1.76
	OPENBSD_4_5:1.76.0.2
	OPENBSD_4_5_BASE:1.76
	OPENBSD_4_4:1.19.0.2
	OPENBSD_4_4_BASE:1.19
	OPENBSD_4_3:1.18.0.2
	OPENBSD_4_3_BASE:1.18;
locks; strict;
comment	@# @;


1.130
date	2010.08.26.19.59.50;	author steven;	state dead;
branches;
next	1.129;

1.129
date	2010.07.06.14.50.53;	author espie;	state Exp;
branches;
next	1.128;

1.128
date	2010.07.06.14.29.15;	author espie;	state Exp;
branches;
next	1.127;

1.127
date	2010.06.28.19.17.27;	author steven;	state Exp;
branches;
next	1.126;

1.126
date	2010.06.27.14.29.54;	author steven;	state Exp;
branches;
next	1.125;

1.125
date	2010.06.25.21.39.35;	author steven;	state Exp;
branches;
next	1.124;

1.124
date	2010.06.25.20.59.33;	author steven;	state Exp;
branches;
next	1.123;

1.123
date	2010.06.25.20.29.11;	author steven;	state Exp;
branches;
next	1.122;

1.122
date	2010.06.25.20.03.54;	author steven;	state Exp;
branches;
next	1.121;

1.121
date	2010.06.25.05.21.35;	author steven;	state Exp;
branches;
next	1.120;

1.120
date	2010.06.19.09.41.07;	author steven;	state Exp;
branches;
next	1.119;

1.119
date	2010.06.12.16.35.15;	author steven;	state Exp;
branches;
next	1.118;

1.118
date	2010.06.12.13.58.27;	author steven;	state Exp;
branches;
next	1.117;

1.117
date	2010.04.26.17.49.00;	author steven;	state Exp;
branches;
next	1.116;

1.116
date	2009.11.15.22.05.36;	author steven;	state Exp;
branches;
next	1.115;

1.115
date	2009.11.15.21.51.59;	author steven;	state Exp;
branches;
next	1.114;

1.114
date	2009.10.18.08.32.19;	author steven;	state Exp;
branches;
next	1.113;

1.113
date	2009.10.17.14.40.22;	author steven;	state Exp;
branches;
next	1.112;

1.112
date	2009.10.15.15.20.34;	author steven;	state Exp;
branches;
next	1.111;

1.111
date	2009.10.15.13.48.11;	author steven;	state Exp;
branches;
next	1.110;

1.110
date	2009.10.15.13.46.23;	author steven;	state Exp;
branches;
next	1.109;

1.109
date	2009.10.15.11.26.08;	author steven;	state Exp;
branches;
next	1.108;

1.108
date	2009.10.15.11.16.10;	author steven;	state Exp;
branches;
next	1.107;

1.107
date	2009.10.15.09.39.45;	author steven;	state Exp;
branches;
next	1.106;

1.106
date	2009.10.14.22.03.16;	author steven;	state Exp;
branches;
next	1.105;

1.105
date	2009.10.14.18.22.03;	author steven;	state Exp;
branches;
next	1.104;

1.104
date	2009.10.14.16.03.02;	author steven;	state Exp;
branches;
next	1.103;

1.103
date	2009.10.14.14.28.22;	author steven;	state Exp;
branches;
next	1.102;

1.102
date	2009.10.14.14.14.21;	author steven;	state Exp;
branches;
next	1.101;

1.101
date	2009.10.14.14.05.33;	author steven;	state Exp;
branches;
next	1.100;

1.100
date	2009.10.14.13.42.41;	author steven;	state Exp;
branches;
next	1.99;

1.99
date	2009.10.14.12.28.44;	author steven;	state Exp;
branches;
next	1.98;

1.98
date	2009.10.14.11.31.50;	author steven;	state Exp;
branches;
next	1.97;

1.97
date	2009.10.14.09.06.17;	author steven;	state Exp;
branches;
next	1.96;

1.96
date	2009.10.13.23.26.41;	author steven;	state Exp;
branches;
next	1.95;

1.95
date	2009.10.13.21.19.15;	author steven;	state Exp;
branches;
next	1.94;

1.94
date	2009.10.13.20.56.45;	author steven;	state Exp;
branches;
next	1.93;

1.93
date	2009.10.13.18.22.57;	author steven;	state Exp;
branches;
next	1.92;

1.92
date	2009.10.13.17.11.21;	author steven;	state Exp;
branches;
next	1.91;

1.91
date	2009.10.13.14.23.12;	author steven;	state Exp;
branches;
next	1.90;

1.90
date	2009.10.13.13.55.12;	author steven;	state Exp;
branches;
next	1.89;

1.89
date	2009.10.13.13.30.31;	author steven;	state Exp;
branches;
next	1.88;

1.88
date	2009.10.12.19.02.14;	author steven;	state Exp;
branches;
next	1.87;

1.87
date	2009.10.12.18.31.37;	author steven;	state Exp;
branches;
next	1.86;

1.86
date	2009.10.12.18.14.55;	author steven;	state Exp;
branches;
next	1.85;

1.85
date	2009.10.12.09.58.22;	author steven;	state Exp;
branches;
next	1.84;

1.84
date	2009.10.11.20.50.33;	author steven;	state Exp;
branches;
next	1.83;

1.83
date	2009.10.11.18.58.59;	author steven;	state Exp;
branches;
next	1.82;

1.82
date	2009.10.11.18.40.03;	author steven;	state Exp;
branches;
next	1.81;

1.81
date	2009.10.11.14.21.56;	author steven;	state Exp;
branches;
next	1.80;

1.80
date	2009.10.10.09.50.11;	author steven;	state Exp;
branches;
next	1.79;

1.79
date	2009.10.09.22.24.56;	author steven;	state Exp;
branches;
next	1.78;

1.78
date	2009.10.09.21.23.42;	author steven;	state Exp;
branches;
next	1.77;

1.77
date	2009.08.30.08.40.52;	author steven;	state Exp;
branches;
next	1.76;

1.76
date	2009.02.16.22.04.28;	author steven;	state Exp;
branches;
next	1.75;

1.75
date	2009.02.16.21.22.56;	author steven;	state Exp;
branches;
next	1.74;

1.74
date	2009.02.16.20.02.42;	author steven;	state Exp;
branches;
next	1.73;

1.73
date	2008.11.23.09.53.56;	author steven;	state Exp;
branches;
next	1.72;

1.72
date	2008.11.23.08.47.05;	author steven;	state Exp;
branches;
next	1.71;

1.71
date	2008.11.22.10.04.19;	author steven;	state Exp;
branches;
next	1.70;

1.70
date	2008.11.22.09.58.03;	author steven;	state Exp;
branches;
next	1.69;

1.69
date	2008.11.19.21.11.17;	author steven;	state Exp;
branches;
next	1.68;

1.68
date	2008.11.18.22.31.11;	author steven;	state Exp;
branches;
next	1.67;

1.67
date	2008.11.18.22.16.44;	author steven;	state Exp;
branches;
next	1.66;

1.66
date	2008.11.16.21.58.17;	author steven;	state Exp;
branches;
next	1.65;

1.65
date	2008.11.14.22.50.58;	author steven;	state Exp;
branches;
next	1.64;

1.64
date	2008.11.11.11.00.29;	author steven;	state Exp;
branches;
next	1.63;

1.63
date	2008.11.11.10.46.14;	author steven;	state Exp;
branches;
next	1.62;

1.62
date	2008.11.11.09.54.51;	author steven;	state Exp;
branches;
next	1.61;

1.61
date	2008.11.10.15.52.30;	author steven;	state Exp;
branches;
next	1.60;

1.60
date	2008.11.10.15.01.54;	author steven;	state Exp;
branches;
next	1.59;

1.59
date	2008.11.10.08.46.21;	author sthen;	state Exp;
branches;
next	1.58;

1.58
date	2008.11.09.12.37.35;	author steven;	state Exp;
branches;
next	1.57;

1.57
date	2008.11.09.12.29.54;	author steven;	state Exp;
branches;
next	1.56;

1.56
date	2008.11.09.10.30.54;	author steven;	state Exp;
branches;
next	1.55;

1.55
date	2008.11.08.09.43.43;	author espie;	state Exp;
branches;
next	1.54;

1.54
date	2008.11.08.09.41.25;	author espie;	state Exp;
branches;
next	1.53;

1.53
date	2008.11.07.20.22.39;	author espie;	state Exp;
branches;
next	1.52;

1.52
date	2008.11.03.21.11.58;	author espie;	state Exp;
branches;
next	1.51;

1.51
date	2008.11.01.13.06.16;	author espie;	state Exp;
branches;
next	1.50;

1.50
date	2008.10.31.10.28.05;	author espie;	state Exp;
branches;
next	1.49;

1.49
date	2008.10.30.23.53.28;	author steven;	state Exp;
branches;
next	1.48;

1.48
date	2008.10.30.22.22.34;	author steven;	state Exp;
branches;
next	1.47;

1.47
date	2008.10.30.19.13.11;	author steven;	state Exp;
branches;
next	1.46;

1.46
date	2008.10.30.19.02.19;	author steven;	state Exp;
branches;
next	1.45;

1.45
date	2008.10.30.18.15.06;	author steven;	state Exp;
branches;
next	1.44;

1.44
date	2008.10.30.15.03.07;	author steven;	state Exp;
branches;
next	1.43;

1.43
date	2008.10.30.10.46.53;	author steven;	state Exp;
branches;
next	1.42;

1.42
date	2008.10.30.10.39.38;	author steven;	state Exp;
branches;
next	1.41;

1.41
date	2008.10.29.23.13.22;	author steven;	state Exp;
branches;
next	1.40;

1.40
date	2008.10.29.23.09.07;	author steven;	state Exp;
branches;
next	1.39;

1.39
date	2008.10.29.16.16.49;	author bernd;	state Exp;
branches;
next	1.38;

1.38
date	2008.10.29.16.10.53;	author steven;	state Exp;
branches;
next	1.37;

1.37
date	2008.10.29.15.28.22;	author steven;	state Exp;
branches;
next	1.36;

1.36
date	2008.10.29.12.13.01;	author steven;	state Exp;
branches;
next	1.35;

1.35
date	2008.10.29.10.09.33;	author steven;	state Exp;
branches;
next	1.34;

1.34
date	2008.10.28.17.16.31;	author bernd;	state Exp;
branches;
next	1.33;

1.33
date	2008.10.28.17.15.00;	author bernd;	state Exp;
branches;
next	1.32;

1.32
date	2008.10.28.11.31.48;	author bernd;	state Exp;
branches;
next	1.31;

1.31
date	2008.10.28.11.16.27;	author bernd;	state Exp;
branches;
next	1.30;

1.30
date	2008.10.28.10.01.13;	author steven;	state Exp;
branches;
next	1.29;

1.29
date	2008.10.28.10.00.22;	author steven;	state Exp;
branches;
next	1.28;

1.28
date	2008.10.28.09.58.55;	author steven;	state Exp;
branches;
next	1.27;

1.27
date	2008.10.27.10.34.18;	author steven;	state Exp;
branches;
next	1.26;

1.26
date	2008.10.27.09.36.42;	author steven;	state Exp;
branches;
next	1.25;

1.25
date	2008.10.26.09.52.10;	author steven;	state Exp;
branches;
next	1.24;

1.24
date	2008.10.26.09.44.22;	author steven;	state Exp;
branches;
next	1.23;

1.23
date	2008.10.20.21.00.30;	author steven;	state Exp;
branches;
next	1.22;

1.22
date	2008.10.20.20.20.09;	author steven;	state Exp;
branches;
next	1.21;

1.21
date	2008.10.20.20.16.05;	author steven;	state Exp;
branches;
next	1.20;

1.20
date	2008.10.10.20.32.28;	author steven;	state Exp;
branches;
next	1.19;

1.19
date	2008.05.01.22.02.32;	author steven;	state Exp;
branches;
next	1.18;

1.18
date	2008.02.17.02.01.42;	author jakemsr;	state Exp;
branches;
next	1.17;

1.17
date	2007.11.16.15.37.20;	author steven;	state Exp;
branches;
next	1.16;

1.16
date	2007.11.09.15.20.57;	author steven;	state Exp;
branches;
next	1.15;

1.15
date	2007.11.05.12.45.34;	author steven;	state Exp;
branches;
next	1.14;

1.14
date	2007.11.05.12.15.35;	author steven;	state Exp;
branches;
next	1.13;

1.13
date	2007.11.05.11.27.34;	author steven;	state Exp;
branches;
next	1.12;

1.12
date	2007.11.03.13.40.08;	author steven;	state Exp;
branches;
next	1.11;

1.11
date	2007.11.03.10.15.41;	author steven;	state Exp;
branches;
next	1.10;

1.10
date	2007.11.03.09.20.34;	author steven;	state Exp;
branches;
next	1.9;

1.9
date	2007.11.03.08.47.46;	author steven;	state Exp;
branches;
next	1.8;

1.8
date	2007.11.01.17.21.25;	author steven;	state Exp;
branches;
next	1.7;

1.7
date	2007.11.01.10.39.33;	author steven;	state Exp;
branches;
next	1.6;

1.6
date	2007.10.31.21.49.08;	author steven;	state Exp;
branches;
next	1.5;

1.5
date	2007.10.31.17.32.55;	author steven;	state Exp;
branches;
next	1.4;

1.4
date	2007.10.29.18.47.19;	author steven;	state Exp;
branches;
next	1.3;

1.3
date	2007.10.29.15.56.56;	author steven;	state Exp;
branches;
next	1.2;

1.2
date	2007.10.29.11.49.52;	author steven;	state Exp;
branches;
next	1.1;

1.1
date	2007.10.28.14.34.09;	author steven;	state Exp;
branches;
next	;


desc
@@


1.130
log
@libtool has been moved to bin
@
text
@#!/usr/bin/perl
# $OpenBSD: libtool,v 1.129 2010/07/06 14:50:53 espie Exp $

# Copyright (c) 2007-2010 Steven Mestdagh <steven@@openbsd.org>
#
# Permission to use, copy, modify, and distribute this software for any
# purpose with or without fee is hereby granted, provided that the above
# copyright notice and this permission notice appear in all copies.
#
# THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
# ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
# OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

use strict;
use warnings;
use feature qw(say switch state);
use Cwd qw(getcwd abs_path);
use File::Basename;
use File::Glob ':glob';
use File::Path;
use Getopt::Long;
use Getopt::Std;

package main;

use subs qw(
	create_symlinks
	generate_objlist
	get_search_dirs
	guess_implicit_mode
	help
	notyet
	parse_version_info
	process_deplibs
	reverse_zap_duplicates_ref
	);

package Trace;

sub print(&)
{
	my $val = shift;
	if (defined $ENV{'TRACE_LIBTOOL'}) {
		state $trace_file;
		if (!defined $trace_file) {
			open $trace_file, '>>', $ENV{'TRACE_LIBTOOL'};
		}
		if (defined $trace_file) {
			print $trace_file (&$val);
		}
	}
}

sub debug(&;$)
{
	my ($args, $level) = @@_;

	$level = 1 if !defined $level;

	if (defined $main::D && $main::D >= $level) {
		print (&$args);
	}
}

{
package Exec;

my $dry = 0;
my $verbose = 0;
my $performed = 0;

sub performed
{
	return $performed;
}

sub dry_run
{
	$dry = 1;
}

sub verbose_run
{
	$verbose = 1;
}

sub silent_run
{
	$verbose = 0;
}

sub new
{
	my $class = shift;
	bless {}, $class;
}

sub chdir
{
	my ($self, $dir) = @@_;
	my $class = ref($self) || $self;
	bless {dir => $dir}, $class;
}

sub command_run
{
	my ($self, @@l) = @@_;

	if ($self->{dir}) {
		Trace::print {"cd $self->{dir} && "};
	}
	Trace::print { "@@l\n" };
	my $pid = fork();
	if ($pid == -1) {
		die "Couldn't fork while running @@l\n";
	}
	if ($pid == 0) {
		if ($self->{dir}) {
			CORE::chdir($self->{dir}) or die "Can't chdir to $self->{dir}\n";
		}
		exec(@@l);
		die "Exec failed @@l\n";
	} else {
		my $kid = waitpid($pid, 0);
		if ($? != 0) {
			die "Error while executing @@l\n";
		}
	}
}

sub shell
{
	my ($self, @@cmds) = @@_;
	# create an object "on the run"
	if (!ref($self)) {
		$self = $self->new;
	}
	for my $c (@@cmds) {
		say $c if $verbose || $dry;
		if (!$dry) {
			$self->command_run($c);
	        }
	}
	$performed++;
}

sub command
{
	my ($self, @@l) = @@_;
	# create an object "on the run"
	if (!ref($self)) {
		$self = $self->new;
	}
	say "@@l" if $verbose || $dry;
	if (!$dry) {
		$self->command_run(@@l);
	}
	$performed++;
}
}

{
package Parser;
my $calls = 0;

sub internal_resolve_la
{
	my ($self, $level, $result, $rdeplibs, $rlibdirs, $args) = @@_;
	Trace::debug {"resolve level: $level\n"};
	my $seen_pthread = 0;
	foreach my $a (@@$args) {
		if ($a eq '-pthread') {
			$seen_pthread++;
			next;
		}
		push(@@$result, $a);
		next if $a !~ m/\.la$/;
		my $lainfo = LaFile->parse($a);
		if (!exists $lainfo->{'cached_deplibs'}) {
		    $lainfo->{'cached_deplibs'} = [];
		    $lainfo->{'cached_result'} = [];
		    $lainfo->{'cached_libdirs'} = [];
		    $lainfo->{'cached_pthread'} =
			$self->internal_resolve_la($level+1,
			    $lainfo->{'cached_result'},
			    $lainfo->{'cached_deplibs'},
			    $lainfo->{'cached_libdirs'},
			    $lainfo->deplib_list);
		    push(@@{$lainfo->{'cached_deplibs'}},
			@@{$lainfo->deplib_list});
		    push(@@{$lainfo->{'cached_libdirs'}},
			$lainfo->{'libdir'});
		    if (@@{$lainfo->{'cached_deplibs'}} > 50) {
		    	$lainfo->{'cached_deplibs'} = main::reverse_zap_duplicates_ref($lainfo->{'cached_deplibs'});
		    }
		    if (@@{$lainfo->{'cached_libdirs'}} > 50) {
		    	$lainfo->{'cached_libdirs'} = main::reverse_zap_duplicates_ref($lainfo->{'cached_libdirs'});
		    }
		    if (@@{$lainfo->{'cached_result'}} > 50) {
		    	$lainfo->{'cached_result'} = main::reverse_zap_duplicates_ref($lainfo->{'cached_result'});
		    }
		}
		$seen_pthread += $lainfo->{'cached_pthread'};
		push(@@$result, @@{$lainfo->{'cached_result'}});
		push(@@$rdeplibs, @@{$lainfo->{'cached_deplibs'}});
		push(@@$rlibdirs, @@{$lainfo->{'cached_libdirs'}});
	}
	$calls++;
	return $seen_pthread;
}

END
{
	Trace::print { "Calls to resolve_la: $calls\n" } if $calls;
}

# resolve .la files until a level with empty dependency_libs is reached.
sub resolve_la
{
	my ($self, $deplibs, $libdirs) = @@_;
	$self->{result} = [];
	if ($self->internal_resolve_la(0, $self->{result}, $deplibs, $libdirs, $self->{args})) {
		unshift(@@{$self->{result}}, '-pthread');
		unshift(@@$deplibs, '-pthread');
	}
	return $self->{result};
}

# parse link flags and arguments
# eliminate all -L and -l flags in the argument string and add the
# corresponding directories and library names to the dirs/libs hashes.
# fill deplibs, to be taken up as dependencies in the resulting .la file...
# set up a hash for library files which haven't been found yet.
# deplibs are formed by collecting the original -L/-l flags, plus
# any .la files passed on the command line, EXCEPT when the .la file
# does not point to a shared library.
# pass 1
# -Lfoo, -lfoo, foo.a, foo.la
# recursively find .la files corresponding to -l flags; if there is no .la
# file, just inspect the library file itself for any dependencies.
# XXX the variable $lashared will register whether or not a .la file is
#     found which refers to a shared library
#     this is used to decide where to link executables and create wrappers
sub parse_linkargs1
{
	state $seen_pthread = 0;
	my ($self, $deplibs, $Rresolved, $libsearchdirs,
	    $dirs, $libs, $args, $level) = @@_;
	Trace::debug {"parse_linkargs1, level: $level\n"};
	Trace::debug {"  args: @@$args\n"};
	my $result   = $self->{result};
	my $lashared = $self->{seen_la_shared};

	foreach my $a (@@$args) {
		Trace::debug {"  processing $a\n"};
		if (!$a || $a eq '' || $a =~ m/^\s+$/) {
			# skip empty arguments
		} elsif ($a eq '-pthread' && !$seen_pthread) {
			# XXX special treatment since it's not a -l flag
			push @@$deplibs, $a;
			$seen_pthread = 1;
			push(@@$result, $a);
		} elsif ($a =~ m/^-L(.*)/) {
			if (!exists $dirs->{$1}) {
				$dirs->{$1} = 1;
				push @@$deplibs, $a;
			}
		} elsif ($a =~ m/^-R(.*)/) {
			# -R options originating from .la resolution
			# those from @@ARGV are in @@Ropts
			push @@$Rresolved, $1;
		} elsif ($a =~ m/^-l(\S+)/) {
			my @@largs = ();
			my $key = $1;
			if (!exists $libs->{$key}) {
				$libs->{$key} = Library->new($key);
				my $lafile = LaFile->find($key, $dirs);
				if ($lafile) {
					$libs->{$key}->{lafile} = $lafile;
					my $absla = main::abs_path($lafile);
					push @@$deplibs, $absla;
					push @@$result, $lafile;
					next;
				} else {
					$libs->{$key}->find($dirs, 1, 'notyet', $libsearchdirs);
					my @@deps = $libs->{$key}->inspect;
					foreach my $d (@@deps) {
						my $k = main::basename $d;
						$k =~ s/^(\S+)\.so.*$/$1/;
						$k =~ s/^lib//;
						push(@@largs, "-l$k");
					}
					push @@$deplibs, $a;
				}
			}
			push(@@$result, $a);
			my $dummy = []; # no need to add deplibs recursively
			$self->parse_linkargs1($dummy, $Rresolved,
				$libsearchdirs, $dirs, $libs,
			       	\@@largs, $level+1) if @@largs;
		} elsif ($a =~ m/(\S+\/)*(\S+)\.a$/) {
			(my $key = $2) =~ s/^lib//;
			if (!exists $libs->{$key}) {
				$libs->{$key} = Library->new($key);
			}
			my $d = main::abs_path(main::dirname($a));
			$dirs->{$d} = 1;
			$libs->{$key}->{fullpath} = $a;
			push(@@$result, $a);
		} elsif ($a =~ m/(\S+\/)*(\S+)\.la$/) {
			(my $key = $2) =~ s/^lib//;
			my $d = main::abs_path(main::dirname($a));
			$dirs->{$d} = 1;
			my $fulla = main::abs_path($a);
			my $lainfo = LaFile->parse($fulla);
			my $dlname = $lainfo->{'dlname'};
			my $oldlib = $lainfo->{'old_library'};
			my $libdir = $lainfo->{'libdir'};
			if ($dlname ne '') {
				$$lashared = 1;
				if (!exists $libs->{$key}) {
					$libs->{$key} = Library->new($key);
					$libs->{$key}->{lafile} = $fulla;
				}
			}
			push(@@$result, $a);
			push(@@$deplibs, $fulla) if ($libdir ne '');
		} elsif ($a =~ m/(\S+\/)*(\S+)\.so(\.\d+){2}/) {
			(my $key = $2) =~ s/^lib//;
			my $d = main::abs_path(main::dirname($a));
			$dirs->{$d} = 1;
			if (!exists $libs->{$key}) {
				$libs->{$key} = Library->new($key);
			}
			# not really normal argument
			# -lfoo should be used instead, so convert it
			push(@@$result, "-l$key");
		} else {
			push(@@$result, $a);
		}
	}
}

# pass 2
# -Lfoo, -lfoo, foo.a
# no recursion in pass 2
# fill orderedlibs array, which is the sequence of shared libraries
#   after resolving all .la
# (this list may contain duplicates)
# fill staticlibs array, which is the sequence of static and convenience
#   libraries
sub parse_linkargs2
{
	state $seen_pthread = 0;
	my ($self, $Rresolved, $libsearchdirs, $orderedlibs, $staticlibs,
	    $dirs, $libs) = @@_;
	Trace::debug {"parse_linkargs2\n"};
	Trace::debug {"  args: @@{$self->{args}}\n"};
	$self->{result} = [];
	my $result = $self->{result};
	my $ltdir = $main::ltdir;

	foreach my $a (@@{$self->{args}}) {
		Trace::debug {"  processing $a\n"};
		if (!$a || $a eq '' || $a =~ m/^\s+$/) {
			# skip empty arguments
		} elsif ($a eq '-lc') {
			# don't link explicitly with libc (just remove -lc)
		} elsif ($a eq '-pthread' && !$seen_pthread) {
			# XXX special treatment since it's not a -l flag
			$seen_pthread = 1;
			push(@@$result, $a);
		} elsif ($a =~ m/^-L(.*)/) {
			if (!exists $dirs->{$1}) {
				$dirs->{$1} = 1;
			}
		} elsif ($a =~ m/^-R(.*)/) {
			# -R options originating from .la resolution
			# those from @@ARGV are in @@Ropts
			push @@$Rresolved, $1;
		} elsif ($a =~ m/^-l(.*)/) {
			my @@largs = ();
			my $key = $1;
			if (!exists $libs->{$key}) {
				$libs->{$key} = Library->new($key);
			}
			push @@$orderedlibs, $key;
		} elsif ($a =~ m/(\S+\/)*(\S+)\.a$/) {
			(my $key = $2) =~ s/^lib//;
			if (!exists $libs->{$key}) {
				$libs->{$key} = Library->new($key);
			}
			$libs->{$key}->{fullpath} = $a;
			push(@@$staticlibs, $a);
		} elsif ($a =~ m/(\S+\/)*(\S+)\.la$/) {
			(my $key = $2) =~ s/^lib//;
			my $d = main::abs_path(main::dirname($a));
			$dirs->{$d} = 1;
			my $fulla = main::abs_path($a);
			my $lainfo = LaFile->parse($fulla);
			my $dlname = $lainfo->stringize('dlname');
			my $oldlib = $lainfo->stringize('old_library');
			if ($dlname eq '' && -f "$d/$ltdir/$oldlib") {
				push @@$staticlibs, "$d/$ltdir/$oldlib";
			} else {
				if (!exists $libs->{$key}) {
					$libs->{$key} = Library->new($key);
					$libs->{$key}->{lafile} = $fulla;
				}
				push @@$orderedlibs, $key;
			}
		} elsif ($a =~ m/^-Wl,(\S+)/) {
			# libtool accepts a list of -Wl options separated
			# by commas, and possibly with a trailing comma
			# which is not accepted by the linker
			my @@Wlflags = split(/,/, $1);
			foreach my $f (@@Wlflags) {
				push(@@$result, "-Wl,$f");
			}
		} else {
			push(@@$result, $a);
		}
	}
	Trace::debug {"end parse_linkargs2\n"};
	return $self->{result};
}

sub new
{
	my ($class, $args) = @@_;
	bless { args => $args }, $class;
}
}

package LaLoFile;
my %file_cache;		# which files have been parsed
my $cache_by_fullname = {};
my $cache_by_inode = {};

# allows special treatment for some keywords
sub set
{
	my ($self, $k, $v) = @@_;

	$self->{$k} = $v;
}

sub stringize
{
	my ($self, $k) = @@_;
	if (defined $self->{$k}) {
	       return $self->{$k};
	}
	return '';
}

sub read
{
	my ($class, $filename) = @@_;
	my $info = $class->new;
	open(my $fh, '<', $filename) or die "cannot read $filename: $!\n";
	my $_;
	while (<$fh>) {
		chomp;
		next if /^\#/;
		next if /^\s*$/;
		if (m/^(\S+)\=\'(.*)\'$/) {
			$info->set($1, $2);
		} elsif (m/^(\S+)\=(\S+)$/) {
			$info->set($1, $2);
		}
	}
	return $info;
}

sub parse
{
	my ($class, $filename) = @@_;

	Trace::debug {"parsing $filename"};

	if (defined $cache_by_fullname->{$filename}) {
		Trace::debug {" (cached)\n"};
		return $cache_by_fullname->{$filename};
	}
	my $key = join("/", (stat $filename)[0,1]);
	if (defined $cache_by_inode->{$key}) {
		Trace::debug {" (cached)\n"};
		return $cache_by_inode->{$key};
	}
	Trace::debug {"\n"};
	return $cache_by_inode->{$key} = $cache_by_fullname->{$filename} =
	    $class->read($filename);
}

sub new
{
	my $class = shift;
	bless {}, $class;
}

package LaFile;
our @@ISA=(qw(LaLoFile));
use File::Basename;

# allows special treatment for some keywords
sub set
{
	my ($self, $k, $v) = @@_;

	$self->SUPER::set($k, $v);
	if ($k eq 'dependency_libs') {
		my @@l = split /\s+/, $v;
		$self->{deplib_list} = \@@l;
	}
}

sub deplib_list
{
	my $self = shift;
	return $self->{deplib_list}
}

# XXX not sure how much of this cruft we need
sub write
{
	my ($lainfo, $filename, $name) = @@_;

	my $libname = $lainfo->stringize('libname');
	my $sharedlibname = $lainfo->stringize('dlname');
	my $staticlibname = $lainfo->stringize('old_library');
	my $librarynames = $lainfo->stringize('library_names');
	my $deplibs = $lainfo->stringize('dependency_libs');
	my $current = $lainfo->stringize('current');
	my $revision = $lainfo->stringize('revision');
	my $age = $lainfo->stringize('age');
	my $installed = $lainfo->stringize('installed');
	my $shouldnotlink = $lainfo->stringize('shouldnotlink');
	my $libdir = $lainfo->stringize('libdir');

	open(my $la, '>', $filename) or die "cannot write $filename: $!\n";
	say "creating $filename" if $main::verbose || $main::D;
	print $la <<EOF
# $name - libtool library file
# Generated by libtool $main::version
#
# Please DO NOT delete this file!
# It is necessary for linking the library.

# The name that we can dlopen(3).
dlname='$sharedlibname'

# Names of this library.
library_names='$librarynames'

# The name of the static archive.
old_library='$staticlibname'

# Libraries that this one depends upon.
dependency_libs='$deplibs'

# Version information for $libname.
current=$current
age=$age
revision=$revision

# Is this an already installed library?
installed=$installed

# Should we warn about portability when linking against -modules?
shouldnotlink=$shouldnotlink

# Files to dlopen/dlpreopen
dlopen=''
dlpreopen=''

# Directory that this library needs to be installed in:
libdir='$libdir'
EOF
;
}

sub write_shared_libs_log
{
	my ($self, $origv) = @@_;
	my $libname = $self->stringize('libname');
	my $v = $self->stringize('current') .'.'. $self->stringize('revision');
	if (!defined $ENV{'SHARED_LIBS_LOG'}) {
	       return;
	}
	my $logfile = $ENV{'SHARED_LIBS_LOG'};
	my $fh;
	if (! -f $logfile) {
		open ($fh, '>', $logfile);
		print $fh "# SHARED_LIBS+= <libname>      <obsd version> # <orig version>\n";
		close $fh;
	}
	open ($fh, '>>', $logfile);
	printf $fh "SHARED_LIBS +=\t%-20s %-8s # %s\n", $libname, $v, $origv;
}

# find .la file associated with a -llib flag
# XXX pick the right one if multiple are found!
sub find
{
	my ($self, $l, $dirs) = @@_;

	# sort dir search order by priority
	# XXX not fully correct yet
	my @@sdirs = sort { $dirs->{$b} <=> $dirs->{$a} } keys %$dirs;
	# search in cwd as well
	unshift @@sdirs, '.';
	Trace::debug {"searching .la for $l\n"};
	Trace::debug {"search path= ", join(':', @@sdirs), "\n"};
	foreach my $d (@@sdirs) {
		foreach my $la_candidate ("$d/lib$l.la", "$d/$l.a") {
			if (-f $la_candidate) {
				Trace::debug {"found $la_candidate\n"};
				return $la_candidate;
			}
		}
	}
	Trace::debug {".la for $l not found!\n"};
	return 0;
}

sub link
{
	my $self = shift;
	my $ltprog = shift;
	my $la = shift;
	my $fname = shift;
	my $odir = shift;
	my $shared = shift;
	my $objs = shift;
	my $dirs = shift;
	my $libs = shift;
	my $deplibs = shift;
	my $libdirs = shift;
	my $parser = shift;
	my $opts = shift;

	Trace::debug {"creating link command for library (linked ",
		($shared) ? "dynam" : "stat", "ically)\n"};

	my $what = ref($self);
	my @@libflags;
	my @@cmd;
	my $ltdir = $main::ltdir;
	my $dst = ($odir eq '.') ? "$ltdir/$fname" : "$odir/$ltdir/$fname";
	if ($la =~ m/\.a$/) {
		# probably just a convenience library
		$dst = ($odir eq '.') ? "$fname" : "$odir/$fname";
	}
	mkdir "$odir/$ltdir" if (! -d "$odir/$ltdir");

	Trace::debug {"argvstring (pre resolve_la): @@{$parser->{args}}\n"};
	my $args = $parser->resolve_la($deplibs, $libdirs);
	Trace::debug {"argvstring (post resolve_la): @@{$parser->{args}}\n"};
	my $orderedlibs = [];
	my $staticlibs = [];
	$parser->{args} = $args;
	$args = $parser->parse_linkargs2(\@@main::Rresolved,
			\@@main::libsearchdirs, $orderedlibs, $staticlibs, $dirs, $libs);
	Trace::debug {"staticlibs = \n", join("\n", @@$staticlibs), "\n"};
	Trace::debug {"orderedlibs = @@$orderedlibs\n"};
	my $finalorderedlibs = main::reverse_zap_duplicates_ref($orderedlibs);
	Trace::debug {"final orderedlibs = @@$finalorderedlibs\n"};

	# static linking
	if (!$shared) {
		@@cmd = ('ar', 'cru', $dst);
		foreach my $a (@@$staticlibs) {
			if ($a =~ m/\.a$/ && $a !~ m/_pic\.a/) {
				# extract objects from archive
				my $libfile = main::basename $a;
				my $xdir = "$odir/$ltdir/${la}x/$libfile";
				main::extract_archive($xdir, $a);
				my @@kobjs = main::get_objlist_from_archive($a);
				map { $_ = "$xdir/$_"; } @@kobjs;
				push @@libflags, @@kobjs;
			}
		}
		foreach my $k (@@$finalorderedlibs) {
			my $l = $libs->{$k};
			# XXX improve test
			# this has to be done probably only with
			# convenience libraries
			next if (!defined $l->{lafile});
			my $lainfo = LaFile->parse($l->{lafile});
			next if ($lainfo->stringize('dlname') ne '');
			$l->find($dirs, 0, $what);
			my $a = $l->{fullpath};
			if ($a =~ m/\.a$/ && $a !~ m/_pic\.a/) {
				# extract objects from archive
				my $libfile = main::basename $a;
				my $xdir = "$odir/$ltdir/${la}x/$libfile";
				main::extract_archive($xdir, $a);
				my @@kobjs = main::get_objlist_from_archive($a);
				map { $_ = "$xdir/$_"; } @@kobjs;
				push @@libflags, @@kobjs;
			}
		}
		push @@cmd, @@libflags if (@@libflags);
		push @@cmd, @@$objs if (@@$objs);
		Exec->command(@@cmd);
		Exec->command('ranlib', $dst);
		return;
	}

	# dynamic linking
	my $symbolsfile;
	if ($opts->{'export-symbols'}) {
		$symbolsfile = $opts->{'export-symbols'};
	} elsif ($opts->{'export-symbols-regex'}) {
		($symbolsfile = "$odir/$ltdir/$la") =~ s/\.la$/.exp/;
		main::get_symbollist($symbolsfile, $opts->{'export-symbols-regex'}, $objs);
	}
	my $tmp = [];
	while (my $k = shift @@$finalorderedlibs) {
		my $l = $libs->{$k};
		$l->find($dirs, 1, $what);
		if ($l->{dropped}) {
			# remove library if dependency on it has been dropped
			delete $libs->{$k};
		} else {
			push(@@$tmp, $k);
		}
	}
	$finalorderedlibs = $tmp;

	my @@libobjects = values %$libs;
	Trace::debug {"libs:\n", join("\n", (keys %$libs)), "\n"};
	Trace::debug {"libfiles:\n", join("\n", map { $_->{fullpath}//'UNDEF' } @@libobjects), "\n"};

	main::create_symlinks($ltdir, $libs);
	my $prev_was_archive = 0;
	my $libcounter = 0;
	foreach my $k (@@$finalorderedlibs) {
		my $a = $libs->{$k}->{fullpath} || die "ERROR: $k not found in \$libs";
		if ($a =~ m/\.a$/) {
			# don't make a -lfoo out of a static library
			push @@libflags, '-Wl,-whole-archive' unless $prev_was_archive;
			push @@libflags, $a;
			if ($libcounter == @@$finalorderedlibs - 1) {
				push @@libflags, '-Wl,-no-whole-archive';
			}
			$prev_was_archive = 1;
		} else {
			push @@libflags, '-Wl,-no-whole-archive' if $prev_was_archive;
			$prev_was_archive = 0;
			my $lib = basename $a;
			if ($lib =~ m/^lib(.*)\.so(\.\d+){2}/) {
				$lib = $1;
			} else {
				say "warning: cannot derive -l flag from library filename, assuming hash key";
				$lib = $k;
			}
			push @@libflags, "-l$lib";
		}
		$libcounter++;
	}

	@@cmd = @@$ltprog;
	push @@cmd, $main::sharedflag, @@main::picflags;
	push @@cmd, '-o', $dst;
	push @@cmd, @@$args if ($args);
	push @@cmd, @@$objs if (@@$objs);
	push @@cmd, '-Wl,-whole-archive', @@$staticlibs, '-Wl,-no-whole-archive'
       		if (@@$staticlibs);
	push @@cmd, "-L$ltdir", @@libflags if (@@libflags);
	push @@cmd, "-Wl,-retain-symbols-file,$symbolsfile" if ($symbolsfile);
	Exec->command(@@cmd);
}

package LoFile;
our @@ISA=(qw(LaLoFile));
use File::Basename;

# write a libtool object file
sub write
{
	my ($self, $filename) = @@_;
	my $picobj = $self->stringize('picobj');
	my $nonpicobj = $self->stringize('nonpicobj');

	my $name = basename $filename;

	open(my $lo, '>', $filename) or die "cannot write $filename: $!\n";
	say "creating $filename" if $main::verbose || $main::D;
	print $lo <<EOF
# $name - a libtool object file
# Generated by libtool $main::version
#
pic_object='$picobj'
non_pic_object='$nonpicobj'
EOF
;
}

sub compile
{
	my ($self, $compiler, $odir, $args) = @@_;

	my $ltdir = $main::ltdir;
	mkdir "$odir/$ltdir" if (! -d "$odir/$ltdir");
	if (defined $self->{picobj}) {
		my @@cmd = @@$compiler;
		push @@cmd, @@$args if (@@$args);
		push @@cmd, @@main::picflags, '-o';
		my $o = ($odir eq '.') ? '' : "$odir/";
		$o .= $self->{picobj};
		push @@cmd, $o;
		Exec->command(@@cmd);
	}
	if (defined $self->{nonpicobj}) {
		my @@cmd = @@$compiler;
		push @@cmd, @@$args if (@@$args);
		push @@cmd, '-o';
		my $o = ($odir eq '.') ? '' : "$odir/";
		$o .= $self->{nonpicobj};
		push @@cmd, $o;
		Exec->command(@@cmd);
	}
}

package Program;
use File::Basename;

sub new
{
	my $class = shift;
	bless {}, $class;
}

# write a wrapper script for an executable so it can be executed within
# the build directory
sub write_wrapper
{
	my $self = shift;

	my $program = $self->{outfilepath};
	my $ltdir = $main::ltdir;
	my $version = $main::version;
	open(my $pw, '>', $program) or die "cannot write $program: $!\n";
	print $pw <<EOF
#!/bin/sh

# $program - wrapper for $ltdir/$program
# Generated by libtool $version

argdir=`dirname \$0`
if test -f "\$argdir/$ltdir/$program"; then
    # Add our own library path to LD_LIBRARY_PATH
    LD_LIBRARY_PATH=\$argdir/$ltdir
    export LD_LIBRARY_PATH

    # Run the actual program with our arguments.
    exec "\$argdir/$ltdir/$program" \${1+"\$\@@"}

    echo "\$0: cannot exec $program \${1+"\$\@@"}"
    exit 1
else
    echo "\$0: error: \\\`\$argdir/$ltdir/$program' does not exist." 1>&2
    exit 1
fi
EOF
;
	close($pw);
	chmod 0755, $program;
}

sub is_wrapper
{
#	my $self = shift;
	my $program = shift;

	open(my $pw, '<', $program) or die "cannot open $program: $!\n";
	return eval(grep { m/wrapper\sfor/ } <$pw>);
}

sub link
{
	my $self = shift;
	my $ltprog = shift;
	my $dirs = shift;
	my $libs = shift;
	my $deplibs = shift;
	my $libdirs = shift;
	my $parser = shift;
	my $opts = shift;
	my $seen_la_shared = shift;

	my $ltdir = $main::ltdir;
	Trace::debug {"linking program (",
		($self->{shared}) ? "dynam" : "stat", "ically)\n"};

	my $what = ref($self);
	my $fpath  = $self->{outfilepath};
	my $RPdirs = $self->{RPdirs};

	my $odir  = dirname  $fpath;
	my $fname = basename $fpath;

	my @@libflags;
	my @@cmd;
	my $dst;
	if ($self->{shared} && $seen_la_shared) {
		$dst = ($odir eq '.') ? "$ltdir/$fname" : "$odir/$ltdir/$fname";
		mkdir "$odir/$ltdir" if (! -d "$odir/$ltdir");
	} else {
		$dst = ($odir eq '.') ? $fname : "$odir/$fname";
	}

	Trace::debug {"argvstring (pre resolve_la): @@{$parser->{args}}\n"};
	my $args = $parser->resolve_la($deplibs, $libdirs);
	Trace::debug {"argvstring (post resolve_la): @@{$parser->{args}}\n"};
	my $orderedlibs = [];
	my $staticlibs = [];
	$parser->{args} = $args;
	$args = $parser->parse_linkargs2(\@@main::Rresolved,
		\@@main::libsearchdirs, $orderedlibs, $staticlibs, $dirs, $libs);
	Trace::debug {"staticlibs = \n", join("\n", @@$staticlibs), "\n"};
	Trace::debug {"orderedlibs = @@$orderedlibs\n"};
	my $finalorderedlibs = main::reverse_zap_duplicates_ref($orderedlibs);
	Trace::debug {"final orderedlibs = @@$finalorderedlibs\n"};

	my $symbolsfile;
	if ($opts->{'export-symbols'}) {
		$symbolsfile = $opts->{'export-symbols'};
	} elsif ($opts->{'export-symbols-regex'}) {
		($symbolsfile = "$odir/$ltdir/$fname") =~ s/\.la$/.exp/;
		main::get_symbollist($symbolsfile, $opts->{'export-symbols-regex'}, $self->{objlist});
	}
	$libdirs = main::reverse_zap_duplicates_ref($libdirs);
	# add libdirs to rpath if they are not in standard lib path
	for my $l (@@$libdirs) {
		my $found = 0;
		for my $d (@@main::libsearchdirs) {
			if ($l eq $d) { $found = 1; last; }
		}
		if (!$found) { push @@$RPdirs, $l; }
	}
	$RPdirs = main::reverse_zap_duplicates_ref($RPdirs);
	map { $_ = "-Wl,-rpath,$_" } @@$RPdirs;
	foreach my $k (keys %$libs) {
		Trace::debug {"key = $k - "};
		my $r = ref($libs->{$k});
		Trace::debug {"ref = $r\n"};
		if (!defined $libs->{$k}) {
			Trace::debug {"creating library object for $k\n"};
			$libs->{$k} = Library->new($k);
		}
		my $l = $libs->{$k};
		$l->find($dirs, $self->{shared}, $what);
	}

	my @@libobjects = values %$libs;
	Trace::debug {"libs:\n", join("\n", (keys %$libs)), "\n"};
	Trace::debug {"libfiles:\n", join("\n", map { $_->{fullpath} } @@libobjects), "\n"};

	main::create_symlinks($ltdir, $libs);
	foreach my $k (@@$finalorderedlibs) {
		my $a = $libs->{$k}->{fullpath} || die "ERROR: $k not found in \$libs";
		if ($a =~ m/\.a$/) {
			# don't make a -lfoo out of a static library
			push @@libflags, $a;
		} else {
			my $lib = basename $a;
			if ($lib =~ m/^lib(.*)\.so(\.\d+){2}/) {
				$lib = $1;
			} else {
				say "warning: cannot derive -l flag from library filename, assuming hash key";
				$lib = $k;
			}
			push @@libflags, "-l$lib";
		}
	}

	@@cmd = @@$ltprog;
	push @@cmd, '-o', $dst;
	push @@cmd, '-static' if (!$self->{shared});
	push @@cmd, @@$args if ($args);
	push @@cmd, @@{$self->{objlist}} if (@@{$self->{objlist}});
	push @@cmd, @@$staticlibs if (@@$staticlibs);
	push @@cmd, "-L$ltdir", @@libflags if (@@libflags);
	push @@cmd, @@$RPdirs if (@@$RPdirs);
	push @@cmd, "-Wl,-retain-symbols-file,$symbolsfile" if ($symbolsfile);
	Exec->command(@@cmd);
}

package Library;

# find actual library filename
# XXX pick the right one if multiple are found!
sub find
{
	my ($self, $dirs, $shared, $linkmode, $ldconfigdirs) = @@_;

	my $libtofind = $self->{key};
	my $libfile = 0;
	my @@globbedlib;
	my $ltdir = $main::ltdir;

	my $pic = '';	# used when finding static libraries
	if ($linkmode eq 'LaFile') {
		$pic = '_pic';
	}

	if (defined $self->{lafile}) {
		# if there is a .la file, use the info from there
		Trace::debug {"found .la file $self->{lafile} for library key: $self->{key}\n"};
		my $lainfo = LaFile->parse($self->{lafile});
		my $dlname = $lainfo->{'dlname'};
		my $oldlib = $lainfo->{'old_library'};
		my $libdir = $lainfo->{'libdir'};
 		my $d = main::abs_path(main::dirname($self->{lafile}));
		# get the name we need (this may include a -release)
		if (!$dlname && !$oldlib) {
			die "neither static nor shared library found in $self->{lafile}\n";
		}
		if ($d !~ m/\Q$ltdir\E$/ && $lainfo->{'installed'} eq 'no') {
			$d .= "/$ltdir";
		}
		if ($shared) {
			if ($dlname) {
				$libfile = "$d/$dlname";
			} else {
				# fall back to static
				$libfile = "$d/$oldlib";
			}
		} else {
			$libfile = "$d/$oldlib";
		}
		if (! -f $libfile) {
			Trace::debug {".la file $self->{lafile} points to nonexistent file $libfile !\n"};
		}
	} else {
		# otherwise, search the filesystem
		# sort dir search order by priority
		# XXX not fully correct yet
		my @@sdirs = sort { $dirs->{$b} <=> $dirs->{$a} } keys %$dirs;
		# search in .libs when priority is high
		map { $_ = "$_/$ltdir" if (exists $dirs->{$_} && $dirs->{$_} > 3) } @@sdirs;
		push @@sdirs, @@$ldconfigdirs if ($ldconfigdirs);
		Trace::debug {"searching for $libtofind\n"};
		Trace::debug {"search path= ", join(':', @@sdirs), "\n"};
		Trace::debug {"search type= ", ($shared) ? 'shared' : 'static', "\n"};
		foreach my $sd (@@sdirs) {
		   if ($shared) {
			# select correct library by sorting by version number only
			@@globbedlib = sort { my ($x,$y) =
			map { /\.so\.(\d+\.\d+)$/; $1 } ($a,$b); $y <=> $x }
			glob "$sd/lib$libtofind.so.*.*";
			if ($globbedlib[0]) {
				Trace::debug {"found $libtofind in $sd\n"};
				$libfile = $globbedlib[0];
				last;
			} else {	# XXX find static library instead?
				my $spath = "$sd/lib$libtofind$pic.a";
				if (-f $spath) {
					Trace::debug {"found static $libtofind in $sd\n"};
					$libfile = $spath;
					last;
				}
			}
		   } else {
			# look for a static library
			my $spath = "$sd/lib$libtofind.a";
			if (-f $spath) {
				Trace::debug {"found static $libtofind in $sd\n"};
				$libfile = $spath;
				last;
			}
		   }
		}
	}
	if (!$libfile) {
		if (defined $self->{fullpath}) { delete $self->{fullpath}; }
		if ($linkmode eq 'LaFile') {
			say "warning: dependency on $libtofind dropped";
			$self->{dropped} = 1;
		} elsif ($linkmode eq 'Program') {
			die "$libtofind not found!\n";
		}
	} else {
		$self->{fullpath} = $libfile;
		Trace::debug {"\$libs->{$self->{key}}->{fullpath} = ", $self->{fullpath}, "\n"};
	}
}

# give a list of library dependencies found in the actual shared library
sub inspect
{
	my $self = shift;

	my $filename = $self->{fullpath};
	my @@deps;
	Trace::debug {"inspecting $filename for library dependencies...\n"};
	open(my $fh, '-|', "objdump -p $filename");
	while (<$fh>) {
		if (m/\s+NEEDED\s+(\S+)\s*$/) {
			push @@deps, $1;
		}
	}
	Trace::debug {"found ", (@@deps == 0) ? 'no ' : '',
		"deps for $filename\n@@deps\n"};
	return @@deps;
}

sub new
{
	my ($class, $key) = @@_;
	bless { key => $key }, $class;
}

package main;

use Config;
use constant {
	OBJECT	=> 0,
	LIBRARY	=> 1,
	PROGRAM	=> 2,
};

our $version = '1.5.26'; # pretend to be this version of libtool
my @@no_shared_archs = qw(m88k vax);
# XXX my $machine_arch = `machine -a`;
my $machine_arch = $Config{'ARCH'};
(my $gnu_arch = $machine_arch) =~ s/amd64/x86_64/;
my @@valid_modes = qw(clean compile execute finish install link uninstall);
my @@valid_src = qw(asm c cc cpp cxx f s);
my $cwd = getcwd();
our $ltdir = '.libs';
our @@picflags = ('-fPIC', '-DPIC');
our $sharedflag = '-shared';
my $instlibdir = '/usr/local/lib';
my @@libsearchdirs;
$instlibdir = $ENV{'LIBDIR'} if defined $ENV{'LIBDIR'};

my $mode;
our $D = 0;		# debug flag
my $verbose = 1;

my %opts;		# options passed to libtool
my @@tags;		# list of --tag options passed to libtool

# just to be clear:
# when building a library:
# 	* -R libdir records libdir in dependency_libs
# 	* -rpath is the path where the (shared) library will be installed
# when building a program:
# 	* both -R libdir and -rpath libdir add libdir to the run-time path
# -Wl,-rpath,libdir will bypass libtool.

# build static/shared objects?
my $static = 1;
my $shared = 0;
my $convenience = 0;
my $noshared = 0;
if (grep { $_ eq $machine_arch } @@no_shared_archs) {
	$noshared = 1;
}

my $gp = new Getopt::Long::Parser;
# require_order so we stop parsing at the first non-option or argument,
# instead of parsing the whole ARGV.
$gp->configure(	'no_ignore_case',
		'pass_through',
		'no_auto_abbrev',
		'require_order'
	);
$gp->getoptions('config' => \&config,
		'debug' => \$D,
		'dry-run|n' => sub { Exec->dry_run },
		'features' => \&notyet,
		'finish' => sub { $mode = 'finish'; },
		'help' => \&help, # does not return
		'mode=s{1}' => \$mode,
		'quiet' => sub { $verbose = 0; },
		'silent' => sub { $verbose = 0; },
		'tag=s{1}' => \@@tags,
		'version' => sub { say $version ; exit(0); },
	);

if ($verbose || $D) {
	Exec->verbose_run;
}
# what are we going to run (cc, c++, ...)
my $ltprog = ();
# deal with multi-arg ltprog
Trace::debug {"ARGV = @@ARGV\n"};
while (@@ARGV) {
	# just read arguments until the next option...
	if ($ARGV[0] =~ m/^\-/) { last; }
	# XXX improve checks
	if ($ARGV[0] =~ m/^\S+\.la/) { last; }
	my $arg = shift @@ARGV;
	push @@$ltprog, $arg;
	Trace::debug {"arg = \"$arg\"\n"};
	# if the current argument is an install program, stop immediately
	if ($arg =~ /cp$/) { last; }
	if ($arg =~ /install([-.]sh)?$/) { last; }
}
Trace::debug {"ltprog = \"@@$ltprog\"\n"};
if (@@$ltprog == 0) { die "no libtool command\n" };

# check mode and guess it if needed
if (!($mode && grep { $_ eq $mode } @@valid_modes)) {
	$mode = guess_implicit_mode($ltprog);
	if ($mode) {
		Trace::debug {"implicit mode: $mode\n"};
	} else {
		die "MODE must be one of:\n@@valid_modes\n";
	}
}

# from here, options may be intermixed with arguments
$gp->configure('permute');

if ($mode eq 'compile') {
	my $lofile = LoFile->new;

	$gp->getoptions('o=s'		=> \$opts{'o'},
			'prefer-pic'	=> \$opts{'prefer-pic'},
			'prefer-non-pic'=> \$opts{'prefer-non-pic'},
			'static'	=> \$opts{'static'},
			);
	# XXX options ignored: -prefer-pic and -prefer-non-pic
	my $pic = 0;
	my $nonpic = 1;
	# assume we need to build pic objects
	$pic = 1 if (!$noshared);
	$nonpic = 0 if ($pic && grep { $_ eq 'disable-static' } @@tags);
	$pic = 0 if ($nonpic && grep { $_ eq 'disable-shared' } @@tags);
	$nonpic = 1 if ($opts{'static'});

	my ($outfile, $odir, $ofile, $srcfile, $srcext);
	# XXX check whether -c flag is present and if not, die?
	if ($opts{'o'}) {
		# fix extension if needed
		($outfile = $opts{'o'}) =~ s/\.o$/.lo/;
		$odir = dirname $outfile;
		$ofile = basename $outfile;
	} else {
		# XXX sometimes no -o flag is present and we need another way
		my $srcre = join '|', @@valid_src;
		my $found = 0;
		foreach my $a (@@ARGV) {
			if ($a =~ m/\.($srcre)$/i) {
				$srcfile = $a;
				$srcext = $1;
				$found = 1;
				last;
			}
		}
		$found or die "cannot find source file in command\n";
		# the output file ends up in the current directory
		$odir = '.';
		($ofile = basename $srcfile) =~ s/\.($srcext)$/.lo/i;
		$outfile = "$odir/$ofile";
	}
	Trace::debug {"srcfile = $srcfile\n"} if $srcfile;
	Trace::debug {"outfile = $outfile\n"};
	(my $nonpicobj = $ofile) =~ s/\.lo$/.o/;
	my $picobj = "$ltdir/$nonpicobj";

	$lofile->{picobj} = $picobj if $pic;
	$lofile->{nonpicobj} = $nonpicobj if $nonpic;
	$lofile->compile($ltprog, $odir, \@@ARGV);
	$lofile->write($outfile);
} elsif ($mode eq 'install') {
	# we just parse the options in order to find the actual arguments
	my @@argvcopy = @@ARGV;
	my %install_opts;
	Trace::debug {"ltprog[-1]  = $$ltprog[-1]\n"};
	if ($$ltprog[-1] =~ m/install([.-]sh)?$/) {
		getopts('BbCcdf:g:m:o:pSs', \%install_opts);
		if (@@ARGV < 2 && (!defined $install_opts{'d'} && @@ARGV == 1)) {
			die "wrong number of arguments for install\n";
		}
	} elsif ($$ltprog[-1] =~ m/cp$/) {
		getopts('HLPRfipr', \%install_opts);
		if (@@ARGV < 2) {
			die "wrong number of arguments for install\n";
		}
	} else {
		die "unsupported install program $$ltprog[-1]\n";
	}
	my @@instopts = @@argvcopy[0 .. (@@argvcopy - @@ARGV - 1)];
	my $dst = pop @@ARGV;
	my @@src = @@ARGV;
	my $dstdir;
	if (-d $dst) {
		$dstdir = $dst;
	} else {
		# dst is not a directory, i.e. a file
		if (@@src > 1) {
			# XXX not really libtool's task to check this
			die "multiple source files combined with file destination";
		} else {
			$dstdir = dirname $dst;
		}
	}
	my $toinstall = {};
	my $tosymlink = {};	# for libraries with a -release in their name
	my $addedmode = 0;
	foreach my $s (@@src) {
		my $dstfile = basename $s;
		# resolve symbolic links, so we don't try to test later
		# whether the symlink is a program wrapper etc.
		if (-l $s) {
			$s = readlink($s) or die "Cannot readlink $s";
		}
		my $srcdir = dirname $s;
		my $srcfile = basename $s;
		Trace::debug {"srcdir = $srcdir\nsrcfile = $srcfile\n"};
		Trace::debug {"dstdir = $dstdir\ndstfile = $dstfile\n"};
		if ($srcfile =~ m/^\S+\.la$/) {
			# we are installing a .la library
			if ($$ltprog[-1] =~ m/install([.-]sh)?$/) {
				push @@instopts, '-m', '644' unless $addedmode;
				$addedmode = 1;
			}
			my $lainfo = LaFile->parse($s);
			# replace info where needed when installing the .la file
			my $sharedlib = $lainfo->{'dlname'};
			my $staticlib = $lainfo->{'old_library'};
			my @@libnames = split /\s+/, $lainfo->{'library_names'};
			my $laipath = "$srcdir/$ltdir/$srcfile".'i';
			$toinstall->{"$srcdir/$ltdir/$staticlib"} = "$dstdir/$staticlib"
				if ($staticlib);
			$toinstall->{"$srcdir/$ltdir/$sharedlib"} = "$dstdir/$sharedlib"
				if ($sharedlib);
			$toinstall->{"$laipath"} = "$dstdir/$dstfile";
			foreach my $n (@@libnames) {
				$tosymlink->{$n} = $sharedlib if ($n ne $sharedlib);
			}
		} elsif (-f "$srcdir/$ltdir/$srcfile" && Program::is_wrapper($s)) {
			$toinstall->{"$srcdir/$ltdir/$srcfile"} = $dst;
		} else {
			$toinstall->{$s} = $dst;
		}
	}
	while (my ($s, $d) = each %$toinstall) {
		my @@realinstopts = @@instopts;
		# do not try to strip .la files
		if ($s =~ m/\.la$/ || $d =~ m /\.la$/) {
			@@realinstopts = grep { $_ ne '-s' } @@realinstopts;
		}
		Exec->command(@@$ltprog, @@realinstopts, $s, $d);
	}
	while (my ($d, $s) = each %$tosymlink) {
		unlink("$dstdir/$d");
		symlink($s, "$dstdir/$d");
	}
	if (defined $install_opts{'d'}) {
		Exec->command(@@$ltprog, @@instopts, @@ARGV);
	}
} elsif ($mode eq 'link') {
	my $cmd;
	my @@Ropts;		# -R options on the command line
	my @@Rresolved;		# -R options originating from .la resolution
	my @@RPopts;		# -rpath options
	my $deplibs = [];	# list of dependent libraries (both -L and -l flags)
	my $libdirs = [];	# list of libdirs
	my $libs = {};		# libraries
	my $dirs = {};		# paths to find libraries
	# put a priority in the dir hash
	# always look here
	$dirs->{'/usr/lib'} = 3;

	$gp->getoptions('all-static'		=> \$opts{'all-static'},
			'avoid-version'		=> \$opts{'avoid-version'},
			'dlopen=s{1}'		=> \$opts{'dlopen'},
			'dlpreopen=s{1}'	=> \$opts{'dlpreopen'},
			'export-dynamic'	=> \$opts{'export-dynamic'},
			'export-symbols=s'	=> \$opts{'export-symbols'},
			'export-symbols-regex=s'=> \$opts{'export-symbols-regex'},
			'module'		=> \$opts{'module'},
			'no-fast-install'	=> \$opts{'no-fast-install'},
			'no-install'		=> \$opts{'no-install'},
			'no-undefined'		=> \$opts{'no-undefined'},
			'o=s'			=> \$opts{'o'},
			'objectlist=s'		=> \$opts{'objectlist'},
			'precious-files-regex=s'=> \$opts{'precious-files-regex'},
			'prefer-pic'		=> \$opts{'prefer-pic'},
			'prefer-non-pic'	=> \$opts{'prefer-non-pic'},
			'release=s'		=> \$opts{'release'},
			'rpath=s'		=> \@@RPopts,
			'R=s'			=> \@@Ropts,
			'shrext=s'		=> \$opts{'shrext'},
			'static'		=> \$opts{'static'},
			'thread-safe'		=> \$opts{'thread-safe'},
			'version-info=s{1}'	=> \$opts{'version-info'},
			'version_info=s{1}'	=> \$opts{'version-info'},
			'version-number=s{1}'	=> \$opts{'version-info'},
		);
	# XXX options ignored: dlopen, dlpreopen, no-fast-install,
	# 	no-install, no-undefined, precious-files-regex,
	# 	shrext, thread-safe, prefer-pic, prefer-non-pic

	@@libsearchdirs = get_search_dirs();
	# add the .libs dir as well in case people try to link directly
	# with the real library instead of the .la library
	push @@libsearchdirs, './.libs';

	my $outfile = $opts{'o'};
	if (!$outfile) {
		die "no output file given.\n";
	}
	Trace::debug {"outfile = $outfile\n"};
	my $odir = dirname $outfile;
	my $ofile = basename $outfile;

	# what are we linking?
	my $linkmode = PROGRAM;
	if ($ofile =~ m/\.l?a$/) {
		$linkmode = LIBRARY;
	}
	Trace::debug {"linkmode: $linkmode\n"};

	# eat multiple version-info arguments, we only accept the first.
	map { $_ = '' if ($_ =~ m/\d+:\d+:\d+/); } @@ARGV;

	my @@objs;
	my @@sobjs;
	my $allpicobj;
	if ($opts{'objectlist'}) {
		my $objectlist = $opts{'objectlist'};
		open(my $ol, '<', $objectlist) or die "cannot open $objectlist: $!\n";
		my @@objlist = <$ol>;
		for (@@objlist) { chomp; }
		$allpicobj = generate_objlist(\@@objs, \@@sobjs, \@@objlist);
	} else {
		$allpicobj = generate_objlist(\@@objs, \@@sobjs, \@@ARGV);
	}
	Trace::debug {"objs = @@objs\n"};
	Trace::debug {"sobjs = @@sobjs\n"};

	my $parser = Parser->new(\@@ARGV);
	$parser->{result} = [];
	my $seen_la_shared = 0;
	$parser->{seen_la_shared} = \$seen_la_shared;

	if ($linkmode == PROGRAM) {
		my $program = Program->new;
		$program->{outfilepath} = $outfile;
		# XXX give higher priority to dirs of not installed libs
		if ($opts{'export-dynamic'}) {
			push(@@{$parser->{args}}, "-Wl,-E");
		}
		if ($opts{'static'}) {
			$program->{shared} = 0;
		} else {
			$program->{shared} = 1;
		}

		$parser->parse_linkargs1($deplibs, \@@Rresolved, \@@libsearchdirs,
				$dirs, $libs, $parser->{args}, 0);
		$parser->{args} = $parser->{result};
		Trace::debug {"end parse_linkargs1\n"};
		Trace::debug {"deplibs = @@$deplibs\n"};
		$seen_la_shared = ${$parser->{seen_la_shared}};

		$program->{objlist} = \@@objs;
		if (@@objs == 0) {
		        if (@@sobjs > 0) {
				Trace::debug {"no non-pic libtool objects found, trying pic objects...\n"};
				$program->{objlist} = \@@sobjs;
			} elsif (@@sobjs == 0) {
				Trace::debug {"no libtool objects of any kind found\n"};
				Trace::debug {"hoping for real objects in ARGV...\n"};
			}
		}
		my $RPdirs = [];
		@@$RPdirs = (@@Ropts, @@RPopts, @@Rresolved);
		$program->{RPdirs} = $RPdirs;

		$program->link($ltprog, $dirs, $libs, $deplibs, $libdirs, $parser, \%opts, $seen_la_shared);
		if ($program->{shared} && $seen_la_shared) {
			$program->write_wrapper();
		}
	} elsif ($linkmode == LIBRARY) {
		my $lainfo = LaFile->new;

		$shared = 1 if ($opts{'version-info'} ||
				$opts{'avoid-version'} ||
				$opts{'module'});
		if (!@@RPopts) {
			$convenience = 1;
			$noshared = 1;
			$static = 1;
			$shared = 0;
		} else {
			$shared = 1;
		}
		if ($ofile =~ m/\.a$/ && !$convenience) {
			$ofile =~ s/\.a$/.la/;
			$outfile =~ s/\.a$/.la/;
		}
		(my $libname = $ofile) =~ s/\.l?a$//;	# remove extension
		my $staticlib = $libname.'.a';
		my $sharedlib = $libname.'.so';
		my $sharedlib_symlink;

		if ($opts{'static'}) {
			$shared = 0;
			$static = 1;
		}
		$shared = 0 if $noshared;

		$parser->parse_linkargs1($deplibs, \@@Rresolved, \@@libsearchdirs,
				$dirs, $libs, $parser->{args}, 0);
		$parser->{args} = $parser->{result};
		Trace::debug {"end parse_linkargs1\n"};
		Trace::debug {"deplibs = @@$deplibs\n"};
		$seen_la_shared = ${$parser->{seen_la_shared}};

		my $sover = '0.0';
		my $origver = 'unknown';
		# environment overrides -version-info
		(my $envlibname = $libname) =~ s/[.+-]/_/g;
		my ($current, $revision, $age) = (0, 0, 0);
		if ($opts{'version-info'}) {
			($current, $revision, $age) = parse_version_info($opts{'version-info'});
			$origver = "$current.$revision";
			$sover = $origver;
		}
		if ($ENV{"${envlibname}_ltversion"}) {
			# this takes priority over the previous
			$sover = $ENV{"${envlibname}_ltversion"};
			($current, $revision) = split /\./, $sover;
			$age = 0;
		}
		if (defined $opts{'release'}) {
			$sharedlib_symlink = $sharedlib;
 			$sharedlib = $libname.'-'.$opts{'release'}.'.so';
		}
		if ($opts{'avoid-version'} ||
			(defined $opts{'release'} && !$opts{'version-info'})) {
			# don't add a version in these cases
		} else {
			$sharedlib .= ".$sover";
			if (defined $opts{'release'}) {
				$sharedlib_symlink .= ".$sover";
			}
		}

		# XXX add error condition somewhere...
		$static = 0 if ($shared && grep { $_ eq 'disable-static' } @@tags);
		$shared = 0 if ($static && grep { $_ eq 'disable-shared' } @@tags);

		Trace::debug {"SHARED: $shared\nSTATIC: $static\n"};

		$lainfo->{'libname'} = $libname;
		if ($shared) {
			$lainfo->{'dlname'} = $sharedlib;
			$lainfo->{'library_names'} = $sharedlib;
			$lainfo->{'library_names'} .= " $sharedlib_symlink"
				if (defined $opts{'release'});
			$lainfo->link($ltprog, $ofile, $sharedlib, $odir, 1, \@@sobjs, $dirs, $libs, $deplibs, $libdirs, $parser, \%opts);
			Trace::debug {"sharedlib: $sharedlib\n"};
			$lainfo->{'current'} = $current;
			$lainfo->{'revision'} = $revision;
			$lainfo->{'age'} = $age;
		}
		if ($static) {
			$lainfo->{'old_library'} = $staticlib;
			$lainfo->link($ltprog, $ofile, $staticlib, $odir, 0, ($allpicobj) ? \@@sobjs : \@@objs, $dirs, $libs, $deplibs, $libdirs, $parser, \%opts);
			Trace::debug {($convenience ? "convenience" : "static")." lib: $staticlib\n"};
		}
		$lainfo->{'installed'} = 'no';
		$lainfo->{'shouldnotlink'} = $opts{'module'} ? 'yes' : 'no';
		map { $_ = "-R$_" } @@Ropts;
		unshift @@$deplibs, @@Ropts if (@@Ropts);
		Trace::debug {"deplibs = @@$deplibs\n"};
		my $finaldeplibs = reverse_zap_duplicates_ref($deplibs);
		Trace::debug {"finaldeplibs = @@$finaldeplibs\n"};
		$lainfo->set('dependency_libs', "@@$finaldeplibs");
		if (@@RPopts) {
			if (@@RPopts > 1) {
				Trace::debug {"more than 1 -rpath option given, taking the first: ", $RPopts[0], "\n"};
			}
			$lainfo->{'libdir'} = $RPopts[0];
		}
		if (!($convenience && $ofile =~ m/\.a$/)) {
			$lainfo->write($outfile, $ofile);
			unlink("$odir/$ltdir/$ofile");
			symlink("../$ofile", "$odir/$ltdir/$ofile");
		}
		my $lai = "$odir/$ltdir/$ofile".'i';
		if ($shared) {
			my $pdeplibs = process_deplibs($finaldeplibs);
			if (defined $pdeplibs) {
				$lainfo->set('dependency_libs', "@@$pdeplibs");
			}
			$lainfo->write_shared_libs_log($origver);
		}
		$lainfo->{'installed'} = 'yes';
		# write .lai file (.la file that will be installed)
		$lainfo->write($lai, $ofile);
	}
} elsif ($mode eq 'finish' || $mode eq 'clean' || $mode eq 'uninstall') {
	# don't do anything
	exit 0;
} elsif ($mode eq 'execute') {
	# XXX check whether this is right
	Exec->silent_run;
	Exec->command(@@$ltprog, @@ARGV);
} else {
	die "MODE=$mode not implemented yet.\n";
}

if (Exec->performed == 0) {
	die "no commands to execute.\n"
}

###########################################################################

sub help
{
	print <<EOF
Usage: $0 [options]
--config - print configuration
--debug - turn on debugging output
--dry-run - don't do anything, only show what would be done
--help - this message
--mode=MODE - use operation mode MODE
--quiet - do not print informational messages
--silent - same as `--quiet'
--tag -
--version - print version of libtool
EOF
;
	exit 1;
}

sub notyet
{
	die "option not implemented yet.\n";
}

# XXX incomplete
sub config
{
	print "objdir=$ltdir\n";
	print "arch=$machine_arch\n";
	print "...\n";
	exit 0;
}

# convert 4:5:8 into a list of numbers
sub parse_version_info
{
	my $vinfo = shift;

	if ($vinfo =~ m/^(\d+):(\d+):(\d+)$/) {
		return ($1, $2, $3);
	} elsif ($vinfo =~ m/^(\d+):(\d+)$/) {
		return ($1, $2, 0);
	} elsif ($vinfo =~ m/^(\d+)$/) {
		return ($1, 0, 0);
	} else {
		die "error parsing -version-info $vinfo\n";
	}
}

sub create_symlinks
{
	my $dir = shift;
	my $libs = shift;

	if (! -d $dir) {
		mkdir $dir or die "cannot create directory: $!\n";
	}
	foreach my $l (values %$libs) {
		my $f = $l->{fullpath};
		next if (!defined $f);
		next if ($f =~ m/\.a$/);
		my $libfile = basename $f;
		Trace::debug {"ln -s $f $dir/$libfile\n"};
		if (! -f "$dir/$libfile") {
			symlink abs_path($f), "$dir/$libfile" or die "cannot create symlink: $!\n";
		}
	}
}

# prepare dependency_libs information for the .la file which is installed
# i.e. remove any .libs directories and use the final libdir for all the
# .la files
sub process_deplibs
{
	my $linkflags = shift;

	my $result;

	foreach my $lf (@@$linkflags) {
		if ($lf =~ m/-L\S+\Q$ltdir\E$/) {
		} elsif ($lf =~ m/\/\S+\/(\S+\.la)/) {
			my $lafile = $1;
			$lf = LaFile->parse($lf)->{'libdir'}.'/'.$lafile;
			push @@$result, $lf;
		} else {
			push @@$result, $lf;
		}
	}
	return $result;
}

# populate arrays of non-pic and pic objects and remove these from @@ARGV
sub generate_objlist
{
	my $objs = shift;
	my $sobjs = shift;
	my $objsource = shift;
	my $allpic = 1;

	my $result = [];
	foreach my $a (@@$objsource) {
		if ($a =~ m/\S+\.lo$/) {
			my $ofile = basename $a;
			my $odir = dirname $a;
			my $loinfo = LoFile->parse($a);
			if ($loinfo->{'non_pic_object'}) {
				my $o;
				$o .= "$odir/" if ($odir ne '.');
				$o .= $loinfo->{'non_pic_object'};
				push @@$objs, $o;
			}
			if ($loinfo->{'pic_object'}) {
				my $o;
				$o .= "$odir/" if ($odir ne '.');
				$o .= $loinfo->{'pic_object'};
				push @@$sobjs, $o;
			} else {
				$allpic = 0;
			}
		} else {
			push @@$result, $a;
		}
	}
	@@$objsource = @@$result;
	return $allpic;
}

# XXX reuse code from SharedLibs.pm instead
sub get_search_dirs
{
	my @@libsearchdirs;
	open(my $fh, '-|', 'ldconfig -r');
	if (defined $fh) {
		while (<$fh>) {
			if (m/^\s*search directories:\s*(.*?)\s*$/o) {
				foreach my $d (split(/\:/o, $1)) {
					push @@libsearchdirs, $d;
				}
				last;
			}
		}
		close($fh);
	} else {
		die "Can't find ldconfig\n";
        }
	return @@libsearchdirs;
}

sub extract_archive
{
	my $dir = shift;
	my $archive = shift;

	if (! -d $dir) {
		Trace::debug {"mkdir -p $dir\n"};
		File::Path::mkpath($dir);
	}
	Exec->chdir($dir)->command('ar', 'x', $archive);
}

sub get_objlist_from_archive
{
	my $a = shift;

	open(my $arh, '-|', "ar t $a");
	my @@o = <$arh>;
	close $arh;
	map { chomp; } @@o;
	return @@o;
}

sub get_symbollist
{
	my $filepath = shift;
	my $regex = shift;
	my $objlist = shift;

	Trace::debug {"generating symbol list in file: $filepath\n"};
	my $symbols = [];
	open(my $sh, '-|', 'nm', @@$objlist) or die "error running nm on object list\n";
	my $c = 0;
	while (my $line = <$sh>) {
		chomp $line;
		Trace::debug {"$c: $line\n"};
		if ($line =~ m/\S+\s+[BCDEGRST]\s+(.*)/) {
			my $s = $1;
			if ($s =~ m/$regex/) {
				push @@$symbols, $s;
				Trace::debug {"matched\n"};
			}
		}
		$c++;
	}
	$symbols = reverse_zap_duplicates_ref($symbols);
	@@$symbols = sort @@$symbols;
	open(my $fh, '>', $filepath) or die "cannot open $filepath\n";
	print $fh join("\n", @@$symbols), "\n";
}

# walk a list from back to front, removing any duplicates
# this should make sure a library's dependencies are behind the library itself
sub reverse_zap_duplicates_ref
{
	my $arglist = shift;
	my $h = {};
	my $r = [];
	for my $el (reverse @@$arglist) {
		next if defined $h->{$el};
		unshift @@$r, $el;
		$h->{$el} = 1;
	}
	return $r;
}

# try to guess libtool mode when it is not specified
sub guess_implicit_mode
{
	my $ltprog = shift;
	my $m = 0;
	for my $a (@@$ltprog) {
	   if ($a =~ m/(install([.-]sh)?|cp)$/) {
		$m = 'install';
	   } elsif ($a =~ m/cc|c\+\+/) {	# XXX improve test
		if (grep { $_ eq '-c' } @@ARGV) {
			$m = 'compile';
		} else {
			$m = 'link';
		}
	   }
	}
	return $m;
}
@


1.129
log
@off-by-1 in splice.
more intuitive: copy the list except for dropped elements
@
text
@d2 1
a2 1
# $OpenBSD: libtool,v 1.128 2010/07/06 14:29:15 espie Exp $
@


1.128
log
@debug complains
@
text
@d2 1
a2 1
# $OpenBSD: libtool,v 1.127 2010/06/28 19:17:27 steven Exp $
d723 2
a724 2
	my $i = 0;
	foreach my $k (@@$finalorderedlibs) {
d730 2
a731 1
			splice(@@$finalorderedlibs, $i, 1);
a732 1
		$i++;
d734 1
@


1.127
log
@put this in else block
@
text
@d2 1
a2 1
# $OpenBSD: libtool,v 1.126 2010/06/27 14:29:54 steven Exp $
d737 1
a737 1
	Trace::debug {"libfiles:\n", join("\n", map { $_->{fullpath} } @@libobjects), "\n"};
@


1.126
log
@store full path to another .la file that we find during processing
of a -l argument as well.
fixes build of productivity/qhacc
@
text
@d2 1
a2 1
# $OpenBSD: libtool,v 1.125 2010/06/25 21:39:35 steven Exp $
d1089 3
a1092 2
	$self->{fullpath} = $libfile;
	Trace::debug {"\$libs->{$self->{key}}->{fullpath} = ", $self->{fullpath}, "\n"};
@


1.125
log
@basic dependency drop if library isn't found (only when linking a library)
makes security/pcsc-lite build
@
text
@d2 1
a2 1
# $OpenBSD: libtool,v 1.124 2010/06/25 20:59:33 steven Exp $
d284 2
a285 1
					push @@$deplibs, $lafile;
@


1.124
log
@Library->find wants to know where it is called from (LaFile or Program)
@
text
@d2 1
a2 1
# $OpenBSD: libtool,v 1.123 2010/06/25 20:29:11 steven Exp $
d722 1
d726 6
d1082 6
a1087 1
		die "$libtofind not found!\n";
@


1.123
log
@put string into a variable here
@
text
@d2 1
a2 1
# $OpenBSD: libtool,v 1.122 2010/06/25 20:03:54 steven Exp $
d288 1
a288 1
					$libs->{$key}->find($dirs, 1, $libsearchdirs);
d649 1
d695 1
a695 1
			$l->find($dirs, 0);
d724 1
a724 1
		$l->find($dirs, 1);
d893 1
d950 1
a950 1
		$l->find($dirs, $self->{shared});
d993 1
a993 1
	my ($self, $dirs, $shared, $ldconfigdirs) = @@_;
d1000 5
d1055 1
a1055 1
				my $spath = "$sd/lib$libtofind.a";
@


1.122
log
@always search for the library file when walking the final lib list;
also delete the fullpath if no library file is found.
maybe slightly less efficient but should be safer
@
text
@d2 1
a2 1
# $OpenBSD: libtool,v 1.121 2010/06/25 05:21:35 steven Exp $
d1048 2
a1049 1
				if (-f "$sd/lib$libtofind.a") {
d1051 1
a1051 1
					$libfile = "$sd/lib$libtofind.a";
d1057 2
a1058 1
			if (-f "$sd/lib$libtofind.a") {
d1060 1
a1060 1
				$libfile = "$sd/lib$libtofind.a";
@


1.121
log
@no need to add to deplibs recursively here
@
text
@d2 1
a2 1
# $OpenBSD: libtool,v 1.119 2010/06/12 16:35:15 steven Exp $
d694 1
a694 3
			if (!defined $l->{fullpath}) {
				$l->find($dirs, 0);
			}
d723 1
a723 3
		if (!defined $l->{fullpath}) {
			$l->find($dirs, 1);
		}
d948 1
a948 6
		# here we find shared or static libraries
		if (defined $l->{fullpath} && $l->{fullpath} =~ m/\.a$/) {
			# static library was registered already, don't search
		} else {
			$l->find($dirs, $self->{shared});
		}
d1065 1
@


1.120
log
@when linking executables, add non standard library paths with -rpath
to do this we collect the libdirs we encounter when resolving .la files

problem noticed by landry@@ when trying to build kazehakase
@
text
@a289 1
					# push @@$rdeplibs, @@deps;
d300 2
a301 1
			$self->parse_linkargs1($deplibs, $Rresolved,
@


1.119
log
@ltprog should not eat .la file arguments.
quick workaround, need to sanitize this later
this makes graphics/gegl work
@
text
@d2 1
a2 1
# $OpenBSD: libtool,v 1.118 2010/06/12 13:58:27 steven Exp $
d4 1
a4 1
# Copyright (c) 2007-2009 Steven Mestdagh <steven@@openbsd.org>
d172 1
a172 1
	my ($self, $level, $result, $rdeplibs, $args) = @@_;
d186 1
d191 1
d195 2
d200 3
d210 1
d224 1
a224 1
	my ($self, $deplibs) = @@_;
d226 1
a226 1
	if ($self->internal_resolve_la(0, $self->{result}, $deplibs, $self->{args})) {
d642 1
d660 1
a660 1
	my $args = $parser->resolve_la($deplibs);
d887 1
d913 1
a913 1
	my $args = $parser->resolve_la($deplibs);
d932 9
d1354 1
d1468 1
a1468 1
		$program->link($ltprog, $dirs, $libs, $deplibs, $parser, \%opts, $seen_la_shared);
d1550 1
a1550 1
			$lainfo->link($ltprog, $ofile, $sharedlib, $odir, 1, \@@sobjs, $dirs, $libs, $deplibs, $parser, \%opts);
d1558 1
a1558 1
			$lainfo->link($ltprog, $ofile, $staticlib, $odir, 0, ($allpicobj) ? \@@sobjs : \@@objs, $dirs, $libs, $deplibs, $parser, \%opts);
@


1.118
log
@don't try to be too smart and just install the .la file always
@
text
@d2 1
a2 1
# $OpenBSD: libtool,v 1.115 2009/11/15 21:51:59 steven Exp $
d1165 2
@


1.117
log
@be silent when mode=execute
this fixes net/xchat
@
text
@d1302 1
a1302 2
			$toinstall->{"$laipath"} = "$dstdir/$dstfile"
				if ($sharedlib);
d1558 1
a1559 1
			my $lai = "$odir/$ltdir/$ofile".'i';
a1563 3
			$lainfo->{'installed'} = 'yes';
			# write .lai file (.la file that will be installed)
			$lainfo->write($lai, $ofile);
d1566 3
@


1.116
log
@spacing
@
text
@d91 5
d1576 1
@


1.115
log
@look for .la file associated with -lfoo argument in the cwd too
seems to fix a handful of ports
@
text
@d2 1
a2 1
# $OpenBSD: libtool,v 1.113 2009/10/17 14:40:22 steven Exp $
d1162 1
a1162 1
	Trace::debug {" arg = \"$arg\"\n"};
@


1.114
log
@cleanup unused variable
@
text
@d601 2
@


1.113
log
@separate lists of static and shared libraries

this makes xenocara build.
@
text
@d2 1
a2 1
# $OpenBSD: libtool,v 1.112 2009/10/15 15:20:34 steven Exp $
a275 1
					$libs->{$key}->{type} = 'shared';
a297 2
			# override previously set type
			$libs->{$key}->{type} = 'static';
a375 1
				$libs->{$key}->{type} = 'shared';
a382 2
			# override previously set type
			$libs->{$key}->{type} = 'static';
@


1.112
log
@clean up a bit, and save some time
@
text
@d2 1
a2 1
# $OpenBSD: libtool,v 1.111 2009/10/15 13:48:11 steven Exp $
a307 4
			if (!exists $libs->{$key}) {
				$libs->{$key} = Library->new($key);
			}
			$libs->{$key}->{lafile} = $fulla;
d314 4
d340 2
a341 1
# fill orderedlibs array, which is the sequence after resolving all .la
d343 2
d348 1
a348 1
	my ($self, $Rresolved, $libsearchdirs, $orderedlibs,
d354 1
d390 1
a390 1
			push @@$orderedlibs, $key;
d396 11
a406 4
			push @@$orderedlibs, $key;
			if (!exists $libs->{$key}) {
				$libs->{$key} = Library->new($key);
				$libs->{$key}->{lafile} = $fulla;
d653 1
d656 2
a657 1
			\@@main::libsearchdirs, $orderedlibs, $dirs, $libs);
d665 11
d757 2
d905 1
d908 2
a909 1
		\@@main::libsearchdirs, $orderedlibs, $dirs, $libs);
d967 1
d1644 1
@


1.111
log
@better regex
@
text
@d2 1
a2 1
# $OpenBSD: libtool,v 1.110 2009/10/15 13:46:23 steven Exp $
a658 1
			print "dlname = ", $lainfo->stringize('dlname'), "\n";
d660 3
a662 1
			$l->find($dirs, 0);
d689 2
a690 1
	foreach my $l (values %$libs) {
d696 1
a696 1
	my @@libfiles = values %$libs;
d698 1
a698 1
	Trace::debug {"libfiles:\n", join("\n", map { $_->{fullpath} } @@libfiles), "\n"};
a700 2
#	map { $_ = "$ltdir/". basename $_ } @@libfiles;
#	Trace::debug {"symlinks to libfiles used for linking:\n", join("\n", @@libfiles), "\n"};
d912 1
a912 1
	my @@libfiles = values %$libs;
d914 1
a914 1
	Trace::debug {"libfiles:\n", join("\n", map { $_->{fullpath} } @@libfiles), "\n"};
a916 2
#	map { $_ = "$ltdir/". basename $_ } @@libfiles;
#	Trace::debug {"symlinks to libfiles used for linking:\n", join("\n", @@libfiles), "\n"};
@


1.110
log
@try to cope with people passing /path/libfoo.so.X.Y instead of -lfoo
if a static library has been found, don't search for it again.
@
text
@d2 1
a2 1
# $OpenBSD: libtool,v 1.109 2009/10/15 11:26:08 steven Exp $
d263 1
a263 1
		} elsif ($a =~ m/^-l(.*)/) {
@


1.109
log
@no need for fiddling with deplibs again here
@
text
@d2 1
a2 1
# $OpenBSD: libtool,v 1.108 2009/10/15 11:16:10 steven Exp $
d321 10
d905 5
a909 1
		$l->find($dirs, $self->{shared});
@


1.108
log
@revert some of the previous; we need this to deal with convenience libs
@
text
@d2 1
a2 1
# $OpenBSD: libtool,v 1.107 2009/10/15 09:39:45 steven Exp $
d335 1
a335 1
	my ($self, $deplibs, $Rresolved, $libsearchdirs, $orderedlibs,
a349 1
			push @@$deplibs, $a;
a354 1
				push @@$deplibs, $a;
d633 1
a633 1
	$args = $parser->parse_linkargs2($deplibs, \@@main::Rresolved,
d870 1
a870 1
	$args = $parser->parse_linkargs2($deplibs, \@@main::Rresolved,
@


1.107
log
@remove unneeded extract_archive function
@
text
@d2 1
a2 1
# $OpenBSD: libtool,v 1.106 2009/10/14 22:03:16 steven Exp $
a642 2
		Trace::debug {"libs:\n", join("\n", (keys %$libs)), "\n"};
		Trace::debug {"libfiles:\n", join("\n", map { $_->{fullpath} } (values %$libs)), "\n"};
d644 22
d1691 12
@


1.106
log
@cleanup;  this seems to work better
@
text
@d2 1
a2 1
# $OpenBSD: libtool,v 1.104 2009/10/14 16:03:02 steven Exp $
a1670 12
}

sub extract_archive
{
	my $dir = shift;
	my $archive = shift;

	if (! -d $dir) {
		Trace::debug {"mkdir -p $dir\n"};
		File::Path::mkpath($dir);
	}
	Exec->chdir($dir)->command('ar', 'x', $archive);
@


1.105
log
@shut up if not in debug mode
@
text
@a646 15
		foreach my $k (@@$finalorderedlibs) {
			my $l = $libs->{$k};
			$l->find($dirs, $self->{shared});
			my $a = $l->{fullpath};
			if ($a =~ m/\.a$/ && $a !~ m/_pic\.a/) {
				# extract objects from archive
				my $libfile = main::basename $a;
				my $xdir = "$odir/$ltdir/${la}x/$libfile";
				main::extract_archive($xdir, $a);
				my @@kobjs = main::get_objlist_from_archive($a);
				map { $_ = "$xdir/$_"; } @@kobjs;
				push @@libflags, @@kobjs;
			}
		}
		push @@cmd, @@libflags if (@@libflags);
a877 5
		if ($self->{shared}) {
			$l->{type} = 'shared';
		} else {
			$l->{type} = 'static';
		}
a886 1
	my $libcounter = 0;
a901 1
		$libcounter++;
a997 1
	$self->{type} = ($shared) ? 'shared' : 'static';
a998 1
	Trace::debug {"\$libs->{$self->{key}}->{type} = ", $self->{type}, "\n"};
@


1.104
log
@use find method here as well, as the object data might not have been filled
@
text
@d2 1
a2 1
# $OpenBSD: libtool,v 1.103 2009/10/14 14:28:22 steven Exp $
d1125 1
a1125 1
print "ARGV = @@ARGV\n";
@


1.103
log
@make guess_implicit_mode work again
@
text
@d2 1
a2 1
# $OpenBSD: libtool,v 1.102 2009/10/14 14:14:21 steven Exp $
d648 3
a650 5
			unless (defined $libs->{$k}->{fullpath}) {
				Trace::debug {"library $k not found in \%libs\n"};
				next;
			}
			my $a = $libs->{$k}->{fullpath};
@


1.102
log
@register directory where static lib can be found
add missing newline
@
text
@d2 1
a2 1
# $OpenBSD: libtool,v 1.101 2009/10/14 14:05:33 steven Exp $
d1143 1
a1143 1
	$mode = guess_implicit_mode();
d1768 1
d1770 2
a1771 1
	if ($ltprog =~ m/(install([.-]sh)?|cp)$/) {
d1773 1
a1773 1
	} elsif ($ltprog =~ m/cc|c\+\+/) {	# XXX improve test
d1779 1
@


1.101
log
@run find unconditionally
@
text
@d2 1
a2 1
# $OpenBSD: libtool,v 1.99 2009/10/14 12:28:44 steven Exp $
d297 2
d990 1
a990 1
		Trace::debug {"search type= ", ($shared) ? 'shared' : 'static'};
@


1.100
log
@sigh, install programs do not always take options
@
text
@d892 5
a896 7
		if (!defined $l->{fullpath}) {
			$l->find($dirs, $self->{shared});
			if ($self->{shared}) {
				$l->{type} = 'shared';
			} else {
				$l->{type} = 'static';
			}
@


1.99
log
@if (defined $a) instead of (if $a) for the -release option, as it may be 0
@
text
@d2 1
a2 1
# $OpenBSD: libtool,v 1.98 2009/10/14 11:31:50 steven Exp $
a1125 1
push @@$ltprog, shift @@ARGV or die "no libtool command\n";
d1134 3
d1139 1
d1209 1
@


1.98
log
@move some library finding code out of the parser
store the .la file path in the library object for later use
fix a bug where we lost some of the command line arguments
this makes more stuff build again and improves static linking
@
text
@d2 1
a2 1
# $OpenBSD: libtool,v 1.97 2009/10/14 09:06:17 steven Exp $
d1465 1
a1465 1
		if ($opts{'release'}) {
d1470 1
a1470 1
			($opts{'release'} && !$opts{'version-info'})) {
d1474 1
a1474 1
			if ($opts{'release'}) {
d1490 1
a1490 1
				if ($opts{'release'});
@


1.97
log
@read architecture from the perl configuration
@
text
@d2 1
a2 1
# $OpenBSD: libtool,v 1.96 2009/10/13 23:26:41 steven Exp $
d217 1
a217 1
	$self->{args} = $self->{result};
d270 1
d306 4
a381 4
			my $lainfo = LaFile->parse($fulla);
			my $dlname = $lainfo->{'dlname'};
			my $oldlib = $lainfo->{'old_library'};
			my $libdir = $lainfo->{'libdir'};
a382 7
			# get the name we need (this may include a -release)
			if (!$dlname && !$oldlib) {
				die "neither static nor shared library found in $a\n";
			}
			if ($d !~ m/\Q$main::ltdir\E$/ && $lainfo->{'installed'} eq 'no') {
				$d .= "/$main::ltdir";
			}
d385 1
a386 12
			# XXX in some cases there are multiple libs with the same name
			# so probably need to use a different key
			if ($dlname eq '') {
				# static
				$libs->{$key}->{fullpath} = "$d/$oldlib";
				$libs->{$key}->{type} = 'static';
			} else {
				# shared
				$libs->{$key}->{fullpath} = "$d/$dlname";
				$libs->{$key}->{type} = 'shared';
			}
			Trace::debug {"\$libs{$key}->{fullpath} = ", $libs->{$key}->{fullpath}, "\n"};
a398 1
	$self->{args} = $self->{result};
d400 1
d629 1
a629 1
	$parser->resolve_la($deplibs);
d632 3
a634 2
	$parser->parse_linkargs2($deplibs, \@@main::Rresolved, \@@main::libsearchdirs,
			$orderedlibs, $dirs, $libs);
d718 1
a718 1
	push @@cmd, @@{$parser->{args}};
d863 1
a863 1
	$parser->resolve_la($deplibs);
d866 3
a868 2
	$parser->parse_linkargs2($deplibs, \@@main::Rresolved, \@@main::libsearchdirs,
			$orderedlibs, $dirs, $libs);
d882 9
a890 1
	foreach my $l (values %$libs) {
d931 1
a931 1
	push @@cmd, @@{$parser->{args}};
d950 1
d952 43
a994 14
	my $ltdir = $main::ltdir;
	# sort dir search order by priority
	# XXX not fully correct yet
	my @@sdirs = sort { $dirs->{$b} <=> $dirs->{$a} } keys %$dirs;
	# search in .libs when priority is high
	map { $_ = "$_/$ltdir" if (exists $dirs->{$_} && $dirs->{$_} > 3) } @@sdirs;
	push @@sdirs, @@$ldconfigdirs if ($ldconfigdirs);
	Trace::debug {"searching for $libtofind\n"};
	Trace::debug {"search path= ", join(':', @@sdirs), "\n"};
	Trace::debug {"search type= ", ($shared) ? 'shared' : 'static'};
	foreach my $sd (@@sdirs) {
	   if ($shared) {
		# select correct library by sorting by version number only
		@@globbedlib = sort { my ($x,$y) =
d997 13
a1009 5
		if ($globbedlib[0]) {
			Trace::debug {"found $libtofind in $sd\n"};
			$libfile = $globbedlib[0];
			last;
		} else {	# XXX find static library instead?
d1015 1
a1016 8
	   } else {
		# look for a static library
		if (-f "$sd/lib$libtofind.a") {
			Trace::debug {"found static $libtofind in $sd\n"};
			$libfile = "$sd/lib$libtofind.a";
			last;
		}
	   }
d1022 3
@


1.96
log
@some small fixes after previous changes
@
text
@d2 1
a2 1
# $OpenBSD: libtool,v 1.95 2009/10/13 21:19:15 steven Exp $
d1027 1
d1037 1
a1037 1
my $machine_arch = 'amd64';
d1549 1
@


1.95
log
@move find_la subroutine into LaFile package
@
text
@d2 1
a2 1
# $OpenBSD: libtool,v 1.94 2009/10/13 20:56:45 steven Exp $
a103 1

d189 1
a189 1
		    	$lainfo->{'cached_deplibs'} = reverse_zap_duplicates_ref($lainfo->{'cached_deplibs'});
d192 1
a192 1
		    	$lainfo->{'cached_result'} = reverse_zap_duplicates_ref($lainfo->{'cached_result'});
d274 2
a275 6
					my $libpath = $libs->{$key}->find($dirs, 1, $libsearchdirs);
					if (!$libpath) {
						die "library $key could not be found.\n";
					}
					# avoid searching again later
					$libs->{$key}->{fullpath} = $libpath;
d279 1
a279 1
						my $k = basename $d;
d288 3
a290 3
			$self->parse_linkargs1($deplibs, $Rresolved, $libsearchdirs,
			    $dirs, $libs, \@@largs,
			    $level+1) if @@largs;
d296 2
d360 1
d368 2
d397 1
d401 1
d658 1
a658 1
		Trace::debug {"libfiles:\n", join("\n", map { $_ = $_->{fullpath} } (values %$libs)), "\n"};
d662 1
a662 1
			unless (defined $libs->{$k}) {
d666 1
a666 1
			my $a = $libs->{$k};
d669 1
a669 1
				my $libfile = basename $a;
d692 2
a693 3
		if (!exists $l->{fullpath}) {
			my $libpath = $l->find($dirs, 1);
			$l->{fullpath} = $libpath if ($libpath);
d699 1
a699 1
	Trace::debug {"libfiles:\n", join("\n", map { $_ = $_->{fullpath} } @@libfiles), "\n"};
d899 7
a905 3
		if (!exists $l->{fullpath}) {
			my $libpath = $l->find($dirs, $self->{shared});
			$l->{fullpath} = $libpath if ($libpath);
d911 1
a911 1
	Trace::debug {"libfiles:\n", join("\n", map { $_ = $_->{fullpath} } @@libfiles), "\n"};
d967 1
d994 4
a997 2
	say "$libtofind not found!" if !$libfile;
	return $libfile;
a1345 6
	$parser->parse_linkargs1($deplibs, \@@Rresolved, \@@libsearchdirs,
			$dirs, $libs, $parser->{args}, 0);
	$parser->{args} = $parser->{result};
	Trace::debug {"end parse_linkargs1\n"};
	Trace::debug {"deplibs = @@$deplibs\n"};
	$seen_la_shared = ${$parser->{seen_la_shared}};
d1359 8
d1413 8
@


1.94
log
@make substitution code a bit shorter
@
text
@d2 1
a2 1
# $OpenBSD: libtool,v 1.93 2009/10/13 18:22:57 steven Exp $
a31 1
	find_la
d269 1
a269 1
				my $lafile = main::find_la($key, $dirs);
d592 23
a1566 23
}

# find .la file associated with a -llib flag
# XXX pick the right one if multiple are found!
sub find_la
{
	my ($l, $dirs) = @@_;

	# sort dir search order by priority
	# XXX not fully correct yet
	my @@sdirs = sort { $dirs->{$b} <=> $dirs->{$a} } keys %$dirs;
	Trace::debug {"searching .la for $l\n"};
	Trace::debug {"search path= ", join(':', @@sdirs), "\n"};
	foreach my $d (@@sdirs) {
		foreach my $la_candidate ("$d/lib$l.la", "$d/$l.a") {
			if (-f $la_candidate) {
				Trace::debug {"found $la_candidate\n"};
				return $la_candidate;
			}
		}
	}
	Trace::debug {".la for $l not found!\n"};
	return 0;
@


1.93
log
@- write SHARED_LIBS_LOG file
- fix stringize to return 0 instead of empty string if the value is 0
@
text
@d2 1
a2 1
# $OpenBSD: libtool,v 1.92 2009/10/13 17:11:21 steven Exp $
d298 1
a298 2
			my $key = $2;
			$key =~ s/^lib//;
d305 1
a305 2
			my $key = $2;
			$key =~ s/^lib//;
d367 1
a367 2
			my $key = $2;
			$key =~ s/^lib//;
d374 1
a374 2
			my $key = $2;
			$key =~ s/^lib//;
d664 1
a664 2
		$symbolsfile = "$odir/$ltdir/$la";
		$symbolsfile =~ s/\.la$/.exp/;
d869 1
a869 2
		$symbolsfile = "$odir/$ltdir/$fname";
		$symbolsfile =~ s/\.la$/.exp/;
a1112 1
		$outfile = $opts{'o'};
d1114 1
a1114 1
		$outfile =~ s/\.o$/.lo/;
d1132 1
a1132 2
		$ofile = basename $srcfile;
		$ofile =~ s/\.($srcext)$/.lo/i;
@


1.92
log
@start at putting library info into an object
@
text
@d2 1
a2 1
# $OpenBSD: libtool,v 1.91 2009/10/13 14:23:12 steven Exp $
d446 4
a449 1
	return $self->{$k} || '';
d578 19
d1390 1
d1394 5
d1400 1
a1403 3
		} elsif ($opts{'version-info'}) {
			($current, $revision, $age) = parse_version_info($opts{'version-info'});
			$sover = "$current.$revision";
d1470 1
@


1.91
log
@this should work better
@
text
@d2 1
a2 1
# $OpenBSD: libtool,v 1.90 2009/10/13 13:55:12 steven Exp $
a32 1
	find_lib
a37 1
	parse_linkargs_list
a39 1
	resolve_la_list
d241 1
a241 1
	    $dirs, $libs, $libstofind, $args, $level) = @@_;
d268 2
a269 2
			if (!exists $libstofind->{$key}) {
				$libstofind->{$key} = 1;
d276 1
a276 1
					my $libpath = main::find_lib($key, $dirs, 1, $libsearchdirs);
d281 2
a282 2
					$libs->{$key} = $libpath;
					my @@deps = main::inspect_lib($libpath);
d295 1
a295 1
			    $dirs, $libs, $libstofind, \@@largs,
d300 4
a303 1
			$libs->{$key} = $a;
d335 1
a335 1
	    $dirs, $libs, $libstofind) = @@_;
d364 2
a365 2
			if (!exists $libstofind->{$key}) {
				$libstofind->{$key} = 1;
d371 4
a374 1
			$libs->{$key} = $a;
d394 3
d401 1
a401 1
				$libs->{$key} = "$d/$oldlib";
d404 1
a404 1
				$libs->{$key} = "$d/$dlname";
d406 1
a406 1
			Trace::debug {"\$libs{$key} = ", $libs->{$key}, "\n"};
a585 1
	my $libstofind = shift;
d608 1
a608 1
			$orderedlibs, $dirs, $libs, $libstofind);
d616 1
a616 1
		Trace::debug {"libfiles:\n", join("\n", (values %$libs)), "\n"};
d650 5
a654 3
	foreach my $l (keys %$libstofind) {
		my $libpath = main::find_lib($l, $dirs, 1);
		$libs->{$l} = $libpath if ($libpath);
d659 1
a659 1
	Trace::debug {"libfiles:\n", join("\n", @@libfiles), "\n"};
d661 3
a663 3
	main::create_symlinks($ltdir, \@@libfiles);
	map { $_ = "$ltdir/". basename $_ } @@libfiles;
	Trace::debug {"symlinks to libfiles used for linking:\n", join("\n", @@libfiles), "\n"};
d667 1
a667 1
		my $a = $libs->{$k} || die "ERROR: $k not found in \$libs";
a812 1
	my $libstofind = shift;
d843 1
a843 1
			$orderedlibs, $dirs, $libs, $libstofind);
d858 1
a858 1
	foreach my $l (keys %$libstofind) {
d860 4
a863 2
		my $libpath = main::find_lib($l, $dirs, $self->{shared});
		$libs->{$l} = $libpath if ($libpath);
d868 1
a868 1
	Trace::debug {"libfiles:\n", join("\n", @@libfiles), "\n"};
d870 3
a872 3
	main::create_symlinks($ltdir, \@@libfiles);
	map { $_ = "$ltdir/". basename $_ } @@libfiles;
	Trace::debug {"symlinks to libfiles used for linking:\n", join("\n", @@libfiles), "\n"};
d875 1
a875 1
		my $a = $libs->{$k} || die "ERROR: $k not found in \$libs";
d903 76
a1224 1
	my $libstofind = {};
d1303 1
a1303 1
			$dirs, $libs, $libstofind, $parser->{args}, 0);
d1307 1
a1307 1
	my $seen_la_shared = ${$parser->{seen_la_shared}};
d1335 1
a1335 1
		$program->link($ltprog, $dirs, $libs, $libstofind, $deplibs, $parser, \%opts, $seen_la_shared);
d1405 1
a1405 1
			$lainfo->link($ltprog, $ofile, $sharedlib, $odir, 1, \@@sobjs, $dirs, $libs, $libstofind, $deplibs, $parser, \%opts);
d1413 1
a1413 1
			$lainfo->link($ltprog, $ofile, $staticlib, $odir, 0, ($allpicobj) ? \@@sobjs : \@@objs, $dirs, $libs, $libstofind, $deplibs, $parser, \%opts);
d1512 1
a1512 1
	my $libfiles = shift;
d1517 2
a1518 1
	foreach my $f (@@$libfiles) {
a1548 65
}

# find actual library filename
# XXX pick the right one if multiple are found!
sub find_lib
{
	my ($libtofind, $dirs, $shared, $ldconfigdirs) = @@_;

	my $libfile = 0;
	my @@globbedlib;

	# sort dir search order by priority
	# XXX not fully correct yet
	my @@sdirs = sort { $dirs->{$b} <=> $dirs->{$a} } keys %$dirs;
	# search in .libs when priority is high
	map { $_ = "$_/$ltdir" if (exists $dirs->{$_} && $dirs->{$_} > 3) } @@sdirs;
	push @@sdirs, @@$ldconfigdirs if ($ldconfigdirs);
	Trace::debug {"searching for $libtofind\n"};
	Trace::debug {"search path= ", join(':', @@sdirs), "\n"};
	foreach my $sd (@@sdirs) {
	   if ($shared) {
		# select correct library by sorting by version number only
		@@globbedlib = sort { my ($x,$y) =
			map { /\.so\.(\d+\.\d+)$/; $1 } ($a,$b); $y <=> $x }
			glob "$sd/lib$libtofind.so.*.*";
		if ($globbedlib[0]) {
			Trace::debug {"found $libtofind in $sd\n"};
			$libfile = $globbedlib[0];
			last;
		} else {	# XXX find static library instead?
			if (-f "$sd/lib$libtofind.a") {
				Trace::debug {"found static $libtofind in $sd\n"};
				$libfile = "$sd/lib$libtofind.a";
				last;
			}
		}
	   } else {
		# look for a static library
		if (-f "$sd/lib$libtofind.a") {
			Trace::debug {"found static $libtofind in $sd\n"};
			$libfile = "$sd/lib$libtofind.a";
			last;
		}
	   }
	}
	say "$libtofind not found!" if !$libfile;
	return $libfile;
}

# give a list of library dependencies found in the actual shared library
sub inspect_lib
{
	my $filename = shift;

	my @@deps;
	Trace::debug {"inspecting $filename for library dependencies...\n"};
	open(my $fh, '-|', "objdump -p $filename");
	while (<$fh>) {
		if (m/\s+NEEDED\s+(\S+)\s*$/) {
			push @@deps, $1;
		}
	}
	Trace::debug {"found ", (@@deps == 0) ? 'no ' : '',
		"deps for $filename\n@@deps\n"};
	return @@deps;
@


1.90
log
@restrict scope of a few variables; initialize them in link mode only
@
text
@d2 1
a2 1
# $OpenBSD: libtool,v 1.89 2009/10/13 13:30:31 steven Exp $
d248 1
a248 1
	my $lashared = $self->{lashared};
a1214 1
	my $seen_la_shared = 0;
d1217 2
a1218 1
	$parser->{seen_la_shared} = 0;
d1224 1
@


1.89
log
@move all the parsing subroutines from main into a parser class
much more moving around is needed
@
text
@d2 1
a2 1
# $OpenBSD: libtool,v 1.88 2009/10/12 19:02:14 steven Exp $
d273 1
a273 1
				my $lafile = main::find_la($key);
d279 1
a279 1
					my $libpath = main::find_lib($key, @@$libsearchdirs);
d578 1
d603 1
a603 1
			$orderedlibs, $main::dirs, $libs, $libstofind);
d646 1
a646 1
		my $libpath = main::find_lib($l, 1);
d804 1
d837 1
a837 1
			$orderedlibs, $main::dirs, $libs, $libstofind);
d854 1
a854 1
		my $libpath = main::find_lib($l, $self->{shared});
a922 3
my @@Ropts;		# -R options on the command line
my @@Rresolved;		# -R options originating from .la resolution
my @@RPopts;		# -rpath options
a923 4
my $deplibs = [];	# list of dependent libraries (both -L and -l flags)
my $libs = {};		# libraries
my $libstofind = {};
my $dirs = {};		# paths to find libraries
a941 4
# put a priority in the dir hash
# always look here
$dirs->{'/usr/lib'} = 3;

d1136 11
d1251 1
a1251 1
		$program->link($ltprog, $libs, $libstofind, $deplibs, $parser, \%opts, $seen_la_shared);
d1321 1
a1321 1
			$lainfo->link($ltprog, $ofile, $sharedlib, $odir, 1, \@@sobjs, $libs, $libstofind, $deplibs, $parser, \%opts);
d1329 1
a1329 1
			$lainfo->link($ltprog, $ofile, $staticlib, $odir, 0, ($allpicobj) ? \@@sobjs : \@@objs, $libs, $libstofind, $deplibs, $parser, \%opts);
d1447 1
a1447 1
	my $l = shift;
d1470 1
a1470 3
	my $libtofind = shift;
	my $shared = shift;
	my @@ldconfigdirs = @@_;	# search there last
d1480 1
a1480 1
	push @@sdirs, @@ldconfigdirs;
@


1.88
log
@remove another argument here
@
text
@d2 1
a2 1
# $OpenBSD: libtool,v 1.87 2009/10/12 18:31:37 steven Exp $
d166 258
d580 2
d597 3
a599 3
	Trace::debug {"argvstring (pre resolve_la): @@ARGV\n"};
	my $argv = main::resolve_la_list(\@@ARGV);
	Trace::debug {"argvstring (post resolve_la): @@$argv\n"};
d601 2
a602 1
	$argv = main::parse_linkargs_list($argv, 0, undef, $orderedlibs);
d686 1
a686 1
	push @@cmd, @@$argv;
d805 2
d830 3
a832 3
	Trace::debug {"argvstring (pre resolve_la): @@ARGV\n"};
	my $argv = main::resolve_la_list(\@@ARGV);
	Trace::debug {"argvstring (post resolve_la): @@$argv\n"};
d834 2
a835 1
	$argv = main::parse_linkargs_list($argv, 0, undef, $orderedlibs);
d885 1
a885 1
	push @@cmd, @@$argv;
a900 1
my $calls = 0;
d1214 7
a1220 4
	# last argument to parse_linkargs_list won't be used in pass 1
	my $args = parse_linkargs_list(\@@ARGV, 1, \$seen_la_shared, undef);
	Trace::debug {"found .la file referring to shared library, and will remember\n"};
	@@ARGV = @@$args;
d1228 1
a1228 1
			push(@@ARGV, "-Wl,-E");
d1249 1
a1249 1
		$program->link($ltprog, $libs, $libstofind, \%opts, $seen_la_shared);
d1319 1
a1319 1
			$lainfo->link($ltprog, $ofile, $sharedlib, $odir, 1, \@@sobjs, $libs, $libstofind, \%opts);
d1327 1
a1327 1
			$lainfo->link($ltprog, $ofile, $staticlib, $odir, 0, ($allpicobj) ? \@@sobjs : \@@objs, $libs, $libstofind, \%opts);
a1438 215
}

sub internal_resolve_la
{
	my ($level, $result, $rdeplibs, $args) = @@_;
	Trace::debug {"resolve level: $level\n"};
	my $seen_pthread = 0;
	foreach my $a (@@$args) {
		if ($a eq '-pthread') {
			$seen_pthread++;
			next;
		}
		push(@@$result, $a);
		next if $a !~ m/\.la$/;
		my $lainfo = LaFile->parse($a);
		if (!exists $lainfo->{'cached_deplibs'}) {
		    $lainfo->{'cached_deplibs'} = [];
		    $lainfo->{'cached_result'} = [];
		    $lainfo->{'cached_pthread'} =
			internal_resolve_la($level+1,
			    $lainfo->{'cached_result'},
			    $lainfo->{'cached_deplibs'},
			    $lainfo->deplib_list);
		    push(@@{$lainfo->{'cached_deplibs'}},
			@@{$lainfo->deplib_list});
		    if (@@{$lainfo->{'cached_deplibs'}} > 50) {
		    	$lainfo->{'cached_deplibs'} = reverse_zap_duplicates_ref($lainfo->{'cached_deplibs'});
		    }
		    if (@@{$lainfo->{'cached_result'}} > 50) {
		    	$lainfo->{'cached_result'} = reverse_zap_duplicates_ref($lainfo->{'cached_result'});
		    }
		}
		$seen_pthread += $lainfo->{'cached_pthread'};
		push(@@$result, @@{$lainfo->{'cached_result'}});
		push(@@$rdeplibs, @@{$lainfo->{'cached_deplibs'}});
	}
	$calls++;
	return $seen_pthread;
}

END
{
	Trace::print { "Calls to resolve_la: $calls\n" } if $calls;
}

# resolve .la files until a level with empty dependency_libs is reached.
sub resolve_la_list
{
	my $args = shift;
	my $result = [];
	if (internal_resolve_la(0, $result, $deplibs, $args)) {
		unshift(@@$result, '-pthread');
		unshift(@@$deplibs, '-pthread');
	}
	return $result;
}

# parse link flags and arguments
# eliminate all -L and -l flags in the argument string and add the
# corresponding directories and library names to the dirs/libs hashes.
# fill deplibs, to be taken up as dependencies in the resulting .la file...
# set up a hash for library files which haven't been found yet.
# deplibs are formed by collecting the original -L/-l flags, plus
# any .la files passed on the command line, EXCEPT when the .la file
# does not point to a shared library.
# pass 1 (la == 1)
# -Lfoo, -lfoo, foo.a, foo.la
# recursively find .la files corresponding to -l flags; if there is no .la
# file, just inspect the library file itself for any dependencies.
# XXX the variable $lashared will register whether or not a .la file is
#     found which refers to a shared library
#     this is used to decide where to link executables and create wrappers
# pass 2 (la == 0)
# -Lfoo, -lfoo, foo.a
# no recursion in pass 2
# fill orderedlibs array, which is the sequence after resolving all .la
# (this list may contain duplicates)

sub internal_parse_linkargs
{
	state $seen_pthread = 0;
	my ($result, $deplibs, $Rresolved, $libsearchdirs, $orderedlibs,
	    $dirs, $libs, $libstofind, $args,
	    $lashared, $la, $level) = @@_;
	Trace::debug {"parse_linkargs pass: ", ($la == 1) ? 1 : 2, ", level: $level\n"};
	Trace::debug {"  args: @@$args\n"};

	foreach my $a (@@$args) {
		Trace::debug {"  processing $a\n"};
		if (!$a || $a eq '' || $a =~ m/^\s+$/) {
			# skip empty arguments
		} elsif ($a eq '-lc') {
			# don't link explicitly with libc (just remove -lc)
		} elsif ($a eq '-pthread' && !$seen_pthread) {
			# XXX special treatment since it's not a -l flag
			push @@$deplibs, $a;
			$seen_pthread = 1;
			push(@@$result, $a);
		} elsif ($a =~ m/^-L(.*)/) {
			if (!exists $dirs->{$1}) {
				$dirs->{$1} = 1;
				push @@$deplibs, $a;
			}
		} elsif ($a =~ m/^-R(.*)/) {
			# -R options originating from .la resolution
			# those from @@ARGV are in @@Ropts
			push @@$Rresolved, $1;
		} elsif ($a =~ m/^-l(.*)/) {
			my @@largs = ();
			my $key = $1;
			if (!exists $libstofind->{$key}) {
				$libstofind->{$key} = 1;
				if ($la) {
					my $lafile = find_la($key);
					if ($lafile) {
						push @@$deplibs, $lafile;
						push(@@$result, $lafile);
						next;
					} else {
						my $libpath = find_lib($key, @@$libsearchdirs);
						if (!$libpath) {
							die "library $key could not be found.\n";
						}
						# avoid searching again later
						$libs->{$key} = $libpath;
						my @@deps = inspect_lib($libpath);
						# push @@$rdeplibs, @@deps;
						foreach my $d (@@deps) {
							my $k = basename $d;
							$k =~ s/^(\S+)\.so.*$/$1/;
							$k =~ s/^lib//;
							push(@@largs, "-l$k");
						}
						push @@$deplibs, $a;
					}
				}
			}
			if ($la) {
				push(@@$result, $a);
				internal_parse_linkargs($result, $deplibs,
				    $Rresolved, $libsearchdirs, undef,
				    $dirs, $libs, $libstofind, \@@largs,
				    $lashared, $la, $level+1) if @@largs;
			} else {
				push @@$orderedlibs, $key;
			}
		} elsif ($a =~ m/(\S+\/)*(\S+)\.a$/) {
			my $key = $2;
			$key =~ s/^lib//;
			$libs->{$key} = $a;
			if ($la) {
				push(@@$result, $a);
			} else {
				push @@$orderedlibs, $key;
			}
		} elsif ($a =~ m/(\S+\/)*(\S+)\.la$/) {
			my $key = $2;
			$key =~ s/^lib//;
			my $d = abs_path(dirname($a));
			$dirs->{$d} = 1;
			my $fulla = abs_path($a);
			my $lainfo = LaFile->parse($fulla);
			my $dlname = $lainfo->{'dlname'};
			my $oldlib = $lainfo->{'old_library'};
			my $libdir = $lainfo->{'libdir'};
			if ($la) {
				if ($dlname ne '') {
					$$lashared = 1;
				}
				push(@@$result, $a);
				push(@@$deplibs, $fulla) if ($libdir ne '');
				next;
			}
			# the following should happen only in pass 2
			push @@$orderedlibs, $key;
			# get the name we need (this may include a -release)
			if (!$dlname && !$oldlib) {
				die "neither static nor shared library found in $a\n";
			}
			if ($d !~ m/\Q$ltdir\E$/ && $lainfo->{'installed'} eq 'no') {
				$d .= "/$ltdir";
			}
			# XXX in some cases there are multiple libs with the same name
			# so probably need to use a different key
			if ($dlname eq '') {
				# static
				$libs->{$key} = "$d/$oldlib";
			} else {
				# shared
				$libs->{$key} = "$d/$dlname";
			}
			Trace::debug {"\$libs{$key} = ", $libs->{$key}, "\n"};
		} elsif ($a =~ m/^-Wl,(\S+)/) {
			# libtool accepts a list of -Wl options separated
			# by commas, and possibly with a trailing comma
			# which is not accepted by the linker
			my @@Wlflags = split(/,/, $1);
			foreach my $f (@@Wlflags) {
				push(@@$result, "-Wl,$f");
			}
		} else {
			push(@@$result, $a);
		}
	}
	Trace::debug {"end parse_linkargs\n"};
}

sub parse_linkargs_list
{
	my ($args, $la, $lashared, $orderedlibs) = @@_;

	my $result = [];
	internal_parse_linkargs($result, $deplibs, \@@Rresolved, \@@libsearchdirs, $orderedlibs, $dirs, $libs,
	    $libstofind, $args, $lashared, $la, 0);
	return $result;
@


1.87
log
@remove argument when not necessary
@
text
@d2 1
a2 1
# $OpenBSD: libtool,v 1.86 2009/10/12 18:14:55 steven Exp $
d341 1
a341 2
	my $dummy = 0;
	$argv = main::parse_linkargs_list($argv, 0, \$dummy, $orderedlibs);
d571 1
a571 2
	my $dummy = 0;
	$argv = main::parse_linkargs_list($argv, 0, \$dummy, $orderedlibs);
a1337 3
			if ($dlname ne '') {
				$$lashared = 1;
			}
d1339 3
@


1.86
log
@move a few lines and add missing argument
@
text
@d2 1
a2 1
# $OpenBSD: libtool,v 1.85 2009/10/12 09:58:22 steven Exp $
a666 1
#my $orderedlibs = [];	# ordered library keys (may contain duplicates)
a951 1
	my $orderedlibs = [];
d953 2
a954 1
	my $args = parse_linkargs_list(\@@ARGV, 1, \$seen_la_shared, $orderedlibs);
d1251 1
d1315 1
a1315 1
				    $Rresolved, $libsearchdirs, $orderedlibs,
@


1.85
log
@more generic way to deal with multiple-argument commands
(compiler, linker, install program, etc)
@
text
@d2 1
a2 1
# $OpenBSD: libtool,v 1.84 2009/10/11 20:50:33 steven Exp $
d743 2
a790 1
	my $lofile = LoFile->new;
a963 1
		# XXX no static linking yet here
d991 2
a1049 1
		my $lainfo = LaFile->new;
d1316 2
a1317 2
				    $dirs, $libs, $libstofind, \@@largs, $la,
				    $level+1) if @@largs;
@


1.84
log
@avoid undef as reference
@
text
@d2 1
a2 1
# $OpenBSD: libtool,v 1.83 2009/10/11 18:58:59 steven Exp $
d423 1
a423 1
	@@cmd = ($ltprog);
d460 1
a460 1
	my ($self, $prog, $odir, $args) = @@_;
a463 1
	my @@compiler = split /\s+/, $prog;
d465 1
a465 1
		my @@cmd = @@compiler;
d474 1
a474 1
		my @@cmd = @@compiler;
d620 1
a620 1
	@@cmd = ($ltprog);
d716 12
a727 1
my $ltprog = shift @@ARGV or die "no libtool command\n";
a742 5
	# deal with multi-arg ltprog
	while (@@ARGV && $ltprog !~ m/(cc|c\+\+|f77|g77|asm)$/) {
		my $arg = shift @@ARGV;
		$ltprog .= " $arg";
	}
a794 5
	# deal with multi-arg ltprog (e.g. /bin/sh install-sh ...)
	while (@@ARGV && $ltprog !~ m/(install([.-]sh)?|cp)$/) {
		my $arg = shift @@ARGV;
		$ltprog .= " $arg";
	}
d798 1
a798 1
	if ($ltprog =~ m/install([.-]sh)?$/) {
d803 1
a803 1
	} elsif ($ltprog =~ m/cp$/) {
d809 1
a809 1
		die "unsupported install program $ltprog\n";
d842 1
a842 1
			if ($ltprog =~ m/install([.-]sh)?$/) {
a866 1
	my @@prog = split /\s+/, $ltprog;
d873 1
a873 1
		Exec->command(@@prog, @@realinstopts, $s, $d);
d880 1
a880 1
		Exec->command(@@prog, @@instopts, @@ARGV);
d1101 1
a1101 1
	Exec->command($ltprog, @@ARGV);
@


1.83
log
@sigh, don't use glob here
@
text
@d2 1
a2 1
# $OpenBSD: libtool,v 1.82 2009/10/11 18:40:03 steven Exp $
d973 1
a980 1
				$program->{objlist} = \@@objs;
@


1.82
log
@oops
@
text
@d2 1
a2 1
# $OpenBSD: libtool,v 1.81 2009/10/11 14:21:56 steven Exp $
d1453 1
a1453 2
		@@globbedlib = glob "$sd/lib$libtofind.a";
		if ($globbedlib[0]) {
d1455 1
a1455 1
			$libfile = $globbedlib[0];
@


1.81
log
@move some info related to executable into the object
@
text
@d2 1
a2 1
# $OpenBSD: libtool,v 1.80 2009/10/10 09:50:11 steven Exp $
d988 1
a988 1
		if ($shared && $seen_la_shared) {
@


1.80
log
@allow to link executables statically as well
@
text
@d2 1
a2 1
# $OpenBSD: libtool,v 1.79 2009/10/09 22:24:56 steven Exp $
a498 1
	my $program = shift;
d500 1
d527 2
d543 1
a543 6
	my $prog = shift;
	my $la = shift;
	my $fname = shift;
	my $odir = shift;
	my $shared = shift;
	my $objs = shift;
a546 1
	my $RPdirs = shift;
d551 7
a557 1
		($shared) ? "dynam" : "stat", "ically)\n"};
d562 1
a562 1
	if ($shared && $seen_la_shared) {
d583 1
a583 1
		$symbolsfile = "$odir/$ltdir/$la";
d585 1
a585 1
		main::get_symbollist($symbolsfile, $opts->{'export-symbols-regex'}, $objs);
d591 1
a591 1
		my $libpath = main::find_lib($l, $shared);
d621 1
a621 1
	@@cmd = ($prog);
d623 1
a623 1
	push @@cmd, '-static' if (!$shared);
d625 1
a625 1
	push @@cmd, @@$objs if (@@$objs);
a925 1
	my $absodir = abs_path($odir);
d962 1
d968 5
a972 3
		$shared = 1;
	        $shared = 0 if ($opts{'static'});
		my $objlist = \@@objs;
d976 1
a976 1
				$objlist = \@@sobjs;
d980 1
d985 1
d987 1
a987 1
		$program->link($ltprog, $ofile, $ofile, $odir, $shared, $objlist, $libs, $libstofind, \%opts, $RPdirs, $seen_la_shared);
d989 1
a989 2
			$program->write_wrapper($outfile);
			chmod 0755, $outfile;
@


1.79
log
@when linking a program, take into account -static flag (not yet supported)
@
text
@d2 1
a2 1
# $OpenBSD: libtool,v 1.78 2009/10/09 21:23:42 steven Exp $
d385 1
a385 1
		my $libpath = main::find_lib($l);
d560 1
a560 1
	if ($seen_la_shared) {
a576 6
	# static linking
	if (!$shared) {
		die "static linking of programs not supported yet\n";
	}

	# dynamic linking
d588 2
a589 1
		my $libpath = main::find_lib($l);
d621 1
d982 1
a982 1
		if ($seen_la_shared) {
d1415 1
d1430 1
d1446 9
@


1.78
log
@be a bit smarter about executable wrapper creation by remembering linking
with a .la file which refers to a shared library
this should prevent wrapper files getting installed;
fixes dbus and wml ports, hope it does not break others :)
@
text
@d2 1
a2 1
# $OpenBSD: libtool,v 1.77 2009/08/30 08:40:52 steven Exp $
d970 2
d985 1
a985 1
		$program->link($ltprog, $ofile, $ofile, $odir, 1, $objlist, $libs, $libstofind, \%opts, $RPdirs, $seen_la_shared);
@


1.77
log
@zap trailing whitespace
@
text
@d2 1
a2 1
# $OpenBSD: libtool,v 1.76 2009/02/16 22:04:28 steven Exp $
d341 2
a342 1
	$argv = main::parse_linkargs_list($argv, 0, $orderedlibs);
d551 1
d559 7
a565 2
	my $dst = ($odir eq '.') ? "$ltdir/$fname" : "$odir/$ltdir/$fname";
	mkdir "$odir/$ltdir" if (! -d "$odir/$ltdir");
d571 2
a572 1
	$argv = main::parse_linkargs_list($argv, 0, $orderedlibs);
d957 3
a959 1
	my $args = parse_linkargs_list(\@@ARGV, 1, $orderedlibs);
d982 6
a987 3
		$program->link($ltprog, $ofile, $ofile, $odir, 1, $objlist, $libs, $libstofind, \%opts, $RPdirs);
		$program->write_wrapper($outfile);
		chmod 0755, $outfile;
d1242 3
d1255 1
a1255 1
	    $la, $level) = @@_;
d1337 3
d1381 1
a1381 1
	my ($args, $la, $orderedlibs) = @@_;
d1385 1
a1385 1
	    $libstofind, $args, $la, 0);
@


1.76
log
@accept multiple forms of --version-info, adding default values where none
are specified (gnu behavior). this fixes math/kst
@
text
@d2 1
a2 1
# $OpenBSD: libtool,v 1.73 2008/11/23 09:53:56 steven Exp $
d326 1
a326 1
	
d554 1
a554 1
	
d940 1
a940 1
		for (@@objlist) { chomp; } 
d1108 1
a1108 1
--tag - 
d1179 3
a1181 3
			internal_resolve_la($level+1, 
			    $lainfo->{'cached_result'}, 
			    $lainfo->{'cached_deplibs'}, 
d1183 1
a1183 1
		    push(@@{$lainfo->{'cached_deplibs'}}, 
d1237 2
a1238 2
	my ($result, $deplibs, $Rresolved, $libsearchdirs, $orderedlibs, 
	    $dirs, $libs, $libstofind, $args, 
d1247 1
a1247 1
		} elsif ($a eq '-lc') {	
d1249 1
a1249 1
		} elsif ($a eq '-pthread' && !$seen_pthread) {	
d1295 3
a1297 3
				internal_parse_linkargs($result, $deplibs, 
				    $Rresolved, $libsearchdirs, $orderedlibs, 
				    $dirs, $libs, $libstofind, \@@largs, $la, 
d1608 1
a1608 1
	return $m;	
@


1.75
log
@deal with multiple linker options passed via one -Wl flag
fixes gnome/dasher
@
text
@d4 1
a4 1
# Copyright (c) 2007-2008 Steven Mestdagh <steven@@openbsd.org>
d1133 1
a1133 1
	if ($vinfo =~ m/(\d+):(\d+):(\d+)/) {
d1135 4
@


1.74
log
@rework logic around library linking, adding so called convenience libraries.
fixes build of a few ports, and doesn't seem to break anything else.
@
text
@d1341 8
@


1.73
log
@parse linkargs after constructing object lists
@
text
@d2 1
a2 1
# $OpenBSD: libtool,v 1.72 2008/11/23 08:47:05 steven Exp $
d331 4
d676 1
d925 1
a925 4
	if ($ofile =~ m/\.la$/) {
		$linkmode = LIBRARY;
	} elsif ($ofile =~ s/\.a$/.la/) {
		$outfile =~ s/\.a$/.la/;
a926 1
		$noshared = 1; $static = 1; # XXX improve!
d976 16
a991 1
		(my $libname = $ofile) =~ s/\.la$//;	# remove extension
d996 1
a996 7
		# XXX how is the creation of a shared library switched on?
		# XXX to do: deal with -rpath correctly
		$shared = 1 if ($opts{'version-info'} ||
				$opts{'avoid-version'} ||
				$opts{'module'} ||
				@@RPopts);
		if ($opts{'static'} || !@@RPopts) {
d1049 1
a1049 1
			Trace::debug {"staticlib: $staticlib\n"};
d1065 5
a1069 3
		$lainfo->write($outfile, $ofile);
		unlink("$odir/$ltdir/$ofile");
		symlink("../$ofile", "$odir/$ltdir/$ofile");
@


1.72
log
@small tweak
@
text
@d2 1
a2 1
# $OpenBSD: libtool,v 1.71 2008/11/22 10:04:19 steven Exp $
a928 5
	my $orderedlibs = [];
	my $args = parse_linkargs_list(\@@ARGV, 1, $orderedlibs);
	@@ARGV = @@$args;
	Trace::debug {"deplibs = @@$deplibs\n"};

d946 5
@


1.71
log
@somewhat simpler
@
text
@d2 1
a2 1
# $OpenBSD: libtool,v 1.70 2008/11/22 09:58:03 steven Exp $
a1304 4
			if ($libdir ne '' && $la) {
				push @@$deplibs, $fulla;
			}
			# the following should happen only in pass 2
d1307 1
d1310 1
@


1.70
log
@move code a little bit
@
text
@d2 1
a2 1
# $OpenBSD: libtool,v 1.69 2008/11/19 21:11:17 steven Exp $
d1229 1
a1229 1
		if ($a eq '' || $a =~ m/^\s+$/) {
d1238 1
a1238 1
		} elsif ($a && $a =~ m/^-L(.*)/) {
d1243 1
a1243 1
		} elsif ($a && $a =~ m/^-R(.*)/) {
d1247 1
a1247 1
		} elsif ($a && $a =~ m/^-l(.*)/) {
d1286 1
a1286 1
		} elsif ($a && $a =~ m/(\S+\/)*(\S+)\.a$/) {
d1295 1
a1295 1
		} elsif ($a && $a =~ m/(\S+\/)*(\S+)\.la$/) {
@


1.69
log
@move library linking to LaFile class
@
text
@d2 1
a2 1
# $OpenBSD: libtool,v 1.68 2008/11/18 22:31:11 steven Exp $
d457 2
a772 1
	mkdir "$odir/$ltdir" if (! -d "$odir/$ltdir");
a1304 3
			if ($d !~ m/\Q$ltdir\E$/ && $lainfo->{'installed'} eq 'no') {
				$d .= "/$ltdir";
			}
d1317 3
@


1.68
log
@some trivial cleanup
@
text
@d2 1
a2 1
# $OpenBSD: libtool,v 1.67 2008/11/18 22:16:44 steven Exp $
a31 1
	do_link
d311 116
d639 1
a639 1
my $sharedflag = '-shared';
d1029 1
a1029 1
			do_link($ofile, $sharedlib, $odir, 1, \@@sobjs);
d1037 1
a1037 1
			do_link($ofile, $staticlib, $odir, 0, ($allpicobj) ? \@@sobjs : \@@objs);
a1446 119
}

# perform linker commands for libraries
sub do_link
{
	my $la = shift;
	my $fname = shift;
	my $odir = shift;
	my $shared = shift;
	my $objs = shift;

	Trace::debug {"creating link command for library (linked ",
		($shared) ? "dynam" : "stat", "ically)\n"};
	
	my @@libflags;
	my @@cmd;
	my $dst = ($odir eq '.') ? "$ltdir/$fname" : "$odir/$ltdir/$fname";
	mkdir "$odir/$ltdir" if (! -d "$odir/$ltdir");

	Trace::debug {"argvstring (pre resolve_la): @@ARGV\n"};
	my $argv = resolve_la_list(\@@ARGV);
	Trace::debug {"argvstring (post resolve_la): @@$argv\n"};
	my $orderedlibs = [];
	$argv = parse_linkargs_list($argv, 0, $orderedlibs);
	Trace::debug {"deplibs = @@$deplibs\n"};
	Trace::debug {"orderedlibs = @@$orderedlibs\n"};
	my $finalorderedlibs = reverse_zap_duplicates_ref($orderedlibs);
	Trace::debug {"final orderedlibs = @@$finalorderedlibs\n"};

	# static linking
	if (!$shared) {
		Trace::debug {"dirs:\n", join("\n", (keys %$dirs)), "\n"};
		Trace::debug {"libs:\n", join("\n", (keys %$libs)), "\n"};
		Trace::debug {"libfiles:\n", join("\n", (values %$libs)), "\n"};
		@@cmd = ('ar', 'cru', $dst);
		push @@cmd, @@$objs if (@@$objs);
		foreach my $k (@@$finalorderedlibs) {
			unless (defined $libs->{$k}) {
				Trace::debug {"library $k not found in \%libs\n"};
				next;
			}
			my $a = $libs->{$k};
			if ($a =~ m/\.a$/ && $a !~ m/_pic\.a/) {
				# extract objects from archive
				my $libfile = basename $a;
				my $xdir = "$odir/$ltdir/${la}x/$libfile";
				extract_archive($xdir, $a);
				my @@kobjs = get_objlist_from_archive($a);
				map { $_ = "$xdir/$_"; } @@kobjs;
				push @@libflags, @@kobjs;
			}
		}
		push @@cmd, @@libflags if (@@libflags);
		Exec->command(@@cmd);
		Exec->command('ranlib', $dst);
		return;
	}

	# dynamic linking
	my $symbolsfile;
	if ($opts{'export-symbols'}) {
		$symbolsfile = $opts{'export-symbols'};
	} elsif ($opts{'export-symbols-regex'}) {
		$symbolsfile = "$odir/$ltdir/$la";
		$symbolsfile =~ s/\.la$/.exp/;
		get_symbollist($symbolsfile, $opts{'export-symbols-regex'}, $objs);
	}
	foreach my $l (keys %$libstofind) {
		my $libpath = find_lib($l);
		$libs->{$l} = $libpath if ($libpath);
	}

	my @@libfiles = values %$libs;
	Trace::debug {"dirs:\n", join("\n", (keys %$dirs)), "\n"};
	Trace::debug {"libs:\n", join("\n", (keys %$libs)), "\n"};
	Trace::debug {"libfiles:\n", join("\n", @@libfiles), "\n"};

	create_symlinks($ltdir, \@@libfiles);
	map { $_ = "$ltdir/". basename $_ } @@libfiles;
	Trace::debug {"symlinks to libfiles used for linking:\n", join("\n", @@libfiles), "\n"};
	my $prev_was_archive = 0;
	my $libcounter = 0;
	foreach my $k (@@$finalorderedlibs) {
		my $a = $libs->{$k} || die "ERROR: $k not found in \$libs";
		if ($a =~ m/\.a$/) {
			# don't make a -lfoo out of a static library
			if (!$prev_was_archive) {
				push @@libflags, '-Wl,-whole-archive';
			}
			push @@libflags, $a;
			if ($libcounter == @@$finalorderedlibs - 1) {
				push @@libflags, '-Wl,-no-whole-archive';
			}
			$prev_was_archive = 1;
		} else {
			if ($prev_was_archive) {
				push @@libflags, '-Wl,-no-whole-archive';
			}
			$prev_was_archive = 0;
			my $lib = basename $a;
			if ($lib =~ m/^lib(.*)\.so(\.\d+){2}/) {
				$lib = $1;
			} else {
				say "warning: cannot derive -l flag from library filename, assuming hash key";
				$lib = $k;
			}
			push @@libflags, "-l$lib";
		}
		$libcounter++;
	}

	@@cmd = ($ltprog);
	push @@cmd, $sharedflag, @@picflags;
	push @@cmd, '-o', $dst;
	push @@cmd, @@$argv;
	push @@cmd, @@$objs if (@@$objs);
	push @@cmd, "-L$ltdir", @@libflags if (@@libflags);
	push @@cmd, "-Wl,-retain-symbols-file,$symbolsfile" if ($symbolsfile);
	Exec->command(@@cmd);
@


1.67
log
@separate linking of executables into its own class
@
text
@d2 1
a2 1
# $OpenBSD: libtool,v 1.65 2008/11/14 22:50:58 steven Exp $
a38 1
	is_prog_wrapper
a44 1
	write_prog_wrapper
d914 1
a914 1
			do_link($ofile, $sharedlib, $odir, LIBRARY, 1, \@@sobjs);
d922 1
a922 1
			do_link($ofile, $staticlib, $odir, LIBRARY, 0, ($allpicobj) ? \@@sobjs : \@@objs);
d1334 1
a1334 1
# perform linker commands for either libraries or programs
a1339 1
	my $lmode = shift;	# LIBRARY or PROGRAM
d1343 1
a1343 2
	Trace::debug {"creating link command for ",
		($lmode == PROGRAM) ? "program" : "library", " (linked ",
d1360 1
d1366 16
a1381 18
		if ($lmode == LIBRARY) {
			@@cmd = ('ar', 'cru', $dst);
			push @@cmd, @@$objs if (@@$objs);
			foreach my $k (@@$finalorderedlibs) {
				unless (defined $libs->{$k}) {
					Trace::debug {"library $k not found in \%libs\n"};
					next;
				}
				my $a = $libs->{$k};
				if ($a =~ m/\.a$/ && $a !~ m/_pic\.a/) {
					# extract objects from archive
					my $libfile = basename $a;
					my $xdir = "$odir/$ltdir/${la}x/$libfile";
					extract_archive($xdir, $a);
					my @@kobjs = get_objlist_from_archive($a);
					map { $_ = "$xdir/$_"; } @@kobjs;
					push @@libflags, @@kobjs;
				}
a1382 4
			push @@cmd, @@libflags if (@@libflags);
			Exec->command(@@cmd);
			Exec->command('ranlib', $dst);
			return;
d1384 4
d1418 2
a1419 4
			if ($lmode == LIBRARY) {
				if (!$prev_was_archive) {
					push @@libflags, '-Wl,-whole-archive';
				}
d1422 2
a1423 4
			if ($lmode == LIBRARY) {
				if ($libcounter == @@$finalorderedlibs - 1) {
					push @@libflags, '-Wl,-no-whole-archive';
				}
d1427 2
a1428 4
			if ($lmode == LIBRARY) {
				if ($prev_was_archive) {
					push @@libflags, '-Wl,-no-whole-archive';
				}
d1444 1
a1444 1
	push @@cmd, $sharedflag, @@picflags if ($lmode == LIBRARY);
@


1.66
log
@- use exec during installation as well
- cleaner way to filter -s out of install options
@
text
@d365 142
d524 1
a524 1
my $ltdir = '.libs';
d543 1
a543 1
my $orderedlibs = [];	# ordered library keys (may contain duplicates)
d736 1
a736 1
		} elsif (-f "$srcdir/$ltdir/$srcfile" && is_prog_wrapper($s)) {
d815 2
a816 1
	my $args = parse_linkargs_list(\@@ARGV, 1);
d839 1
d855 4
a858 2
		do_link($ofile, $ofile, $odir, PROGRAM, 1, $objlist);
		write_prog_wrapper($outfile);
a1031 40
# write a wrapper script for an executable so it can be executed within
# the build directory
sub write_prog_wrapper
{
	my $program = shift;

	open(my $pw, '>', $program) or die "cannot write $program: $!\n";
	print $pw <<EOF
#!/bin/sh

# $program - wrapper for $ltdir/$program
# Generated by libtool $version

argdir=`dirname \$0`
if test -f "\$argdir/$ltdir/$program"; then
    # Add our own library path to LD_LIBRARY_PATH
    LD_LIBRARY_PATH=\$argdir/$ltdir
    export LD_LIBRARY_PATH

    # Run the actual program with our arguments.
    exec "\$argdir/$ltdir/$program" \${1+"\$\@@"}

    echo "\$0: cannot exec $program \${1+"\$\@@"}"
    exit 1
else
    echo "\$0: error: \\\`\$argdir/$ltdir/$program' does not exist." 1>&2
    exit 1
fi
EOF
;
}

sub is_prog_wrapper
{
	my $program = shift;

	open(my $pw, '<', $program) or die "cannot open $program: $!\n";
	return eval(grep { m/wrapper\sfor/ } <$pw>);
}

d1226 1
a1226 1
	my ($args, $la) = @@_;
d1358 2
a1359 2
	$orderedlibs = [];
	$argv = parse_linkargs_list($argv, 0);
a1391 2
		} elsif ($lmode == PROGRAM) {
			die "static linking of programs not supported yet\n";
a1395 1
	my $RPdirs = [];
a1403 5
	if ($lmode == PROGRAM) {
		@@$RPdirs = (@@Ropts, @@RPopts, @@Rresolved);
		$RPdirs = reverse_zap_duplicates_ref($RPdirs);
		map { $_ = "-Wl,-rpath,$_" } @@$RPdirs;
	}
a1459 1
	push @@cmd, @@$RPdirs if (@@$RPdirs);
@


1.65
log
@make the compiler program a list; fixes a few ports
@
text
@d2 1
a2 1
# $OpenBSD: libtool,v 1.63 2008/11/11 10:46:14 steven Exp $
d600 1
d605 1
a605 1
			map { $_ = '' if $_ eq '-s' } @@realinstopts;
d607 1
a607 1
		Exec->shell("$ltprog @@realinstopts $s $d");
d614 1
a614 1
		Exec->shell("$ltprog @@instopts @@ARGV");
@


1.64
log
@use reference instead of hash
@
text
@d342 1
a342 1
	my ($self, $compiler, $odir, $args) = @@_;
d344 1
d346 1
a346 1
		my @@cmd = ($compiler);
d355 1
a355 1
		my @@cmd = ($compiler);
@


1.63
log
@separate compile code into its own method
@
text
@d2 1
a2 1
# $OpenBSD: libtool,v 1.62 2008/11/11 09:54:51 steven Exp $
a462 3
#print "\n###\n### WARNING: ",
#	"This version of libtool is EXPERIMENTAL. ###\n###\n\n";

d558 2
a559 2
	my %toinstall;
	my %tosymlink;	# for libraries with a -release in their name
d584 1
a584 1
			$toinstall{"$srcdir/$ltdir/$staticlib"} = "$dstdir/$staticlib"
d586 1
a586 1
			$toinstall{"$srcdir/$ltdir/$sharedlib"} = "$dstdir/$sharedlib"
d588 1
a588 1
			$toinstall{"$laipath"} = "$dstdir/$dstfile"
d591 1
a591 1
				$tosymlink{$n} = $sharedlib if ($n ne $sharedlib);
d594 1
a594 1
			$toinstall{"$srcdir/$ltdir/$srcfile"} = $dst;
d596 1
a596 1
			$toinstall{$s} = $dst;
d599 1
a599 1
	while (my ($s, $d) = each %toinstall) {
d607 1
a607 1
	while (my ($d, $s) = each %tosymlink) {
@


1.62
log
@don't use the shell, except for install mode (needs more tweaking)
use references in a few more places
check whether reference is defined before attempting to use it
@
text
@d2 1
a2 1
# $OpenBSD: libtool,v 1.61 2008/11/10 15:52:30 steven Exp $
d340 23
d382 1
a382 1
my @@picflags = ('-fPIC', '-DPIC');
a518 19
	if ($pic) {
		my @@cmd = ($ltprog);
		push @@cmd, @@ARGV if (@@ARGV);
		push @@cmd, @@picflags;
		push @@cmd, '-o';
		my $o = ($odir eq '.') ? '' : $odir.'/';
		$o .= $picobj;
		push @@cmd, $o;
		Exec->command(@@cmd);
	}
	if ($nonpic) {
		my @@cmd = ($ltprog);
		push @@cmd, @@ARGV if (@@ARGV);
		push @@cmd, '-o';
		my $o = ($odir eq '.') ? '' : $odir.'/';
		$o .= $nonpicobj;
		push @@cmd, $o;
		Exec->command(@@cmd);
	}
d522 1
@


1.61
log
@change logic deciding whether to add a version; should fix a few ports
@
text
@d2 1
a2 1
# $OpenBSD: libtool,v 1.60 2008/11/10 15:01:54 steven Exp $
d32 1
a37 1
	handle_special_chars
a39 1
	linkcmd
d161 1
a161 1
	say @@l if $verbose || $dry;
d359 1
a359 1
my $picflags = '-fPIC -DPIC';
a454 1
	my $cmd;
a494 2
	handle_special_chars(\@@ARGV);

d497 8
a504 7
		$cmd = $ltprog;
		$cmd .= " @@ARGV" if (@@ARGV);
		$cmd .= " $picflags";
		$cmd .= " -o ";
		$cmd .= ($odir eq '.') ? '' : $odir.'/';
		$cmd .= $picobj;
		Exec->shell($cmd);
d507 7
a513 6
		$cmd = $ltprog;
		$cmd .= " @@ARGV" if (@@ARGV);
		$cmd .= " -o ";
		$cmd .= ($odir eq '.') ? '' : $odir.'/';
		$cmd .= $nonpicobj;
		Exec->shell($cmd);
d558 1
d573 2
a574 1
				push @@instopts, '-m 644';
a668 2
	handle_special_chars(\@@ARGV);

d707 1
a707 3
		my @@tmpcmd = linkcmds($ofile, $ofile, $odir, PROGRAM, 1, $objlist);
		$cmd = $tmpcmd[0];
		Exec->shell($cmd);
d766 1
a766 1
			Exec->shell(linkcmds($ofile, $sharedlib, $odir, LIBRARY, 1, \@@sobjs));
d774 1
a774 1
			Exec->shell(linkcmds($ofile, $staticlib, $odir, LIBRARY, 0, ($allpicobj) ? \@@sobjs : \@@objs));
d797 3
a799 1
			$lainfo->set('dependency_libs', "@@$pdeplibs");
d810 1
a810 1
	Exec->shell("$ltprog @@ARGV");
d1005 3
a1007 1
		if ($a eq '-lc') {	
d1226 2
a1227 2
# construct linker command (list) for either libraries or programs
sub linkcmds
d1241 1
a1241 2
	my @@cmdlist;
	my $cmd = '';
d1260 2
a1261 2
			$cmd = "ar cru $dst";
			$cmd .= " @@$objs" if (@@$objs);
d1278 4
a1281 4
			$cmd .= " @@libflags" if (@@libflags);
			push @@cmdlist, $cmd;
			push @@cmdlist, "ranlib $dst";
			return @@cmdlist;
d1352 9
a1360 11
	$cmd = "$ltprog";
	$cmd .= " $sharedflag $picflags" if ($lmode == LIBRARY);
	$cmd .= " -o $dst";
	$cmd .= " @@$argv";
	$cmd .= " @@$objs" if (@@$objs);
	$cmd .= " -L$ltdir @@libflags" if (@@libflags);
	$cmd .= " @@$RPdirs" if (@@$RPdirs);
	$cmd .= " -Wl,-retain-symbols-file,$symbolsfile" if ($symbolsfile);
	push @@cmdlist, $cmd;

	return @@cmdlist;
d1371 1
d1391 2
a1392 1
			$a = '';
d1395 1
a1499 8
}

# escape quotes and meta-characters
# protect elements containing whitespace or meta-characters by quotes
sub handle_special_chars
{
	my $a = shift;
	map { $_ =~ s,(['"]),\\$1,g; $_ = "\"$_\"" if $_ =~ m/[\s&()<>]/ } @@$a;
@


1.60
log
@only use reverse_zap_duplicates_ref and get rid of the array version

ok espie
@
text
@d2 1
a2 1
# $OpenBSD: libtool,v 1.59 2008/11/10 08:46:21 sthen Exp $
d747 4
a750 1
		if (!$opts{'avoid-version'}) {
@


1.59
log
@remove sh from no_shared_archs, ok steven@@
@
text
@d2 1
a2 1
# $OpenBSD: libtool,v 1.58 2008/11/09 12:37:35 steven Exp $
a45 1
	reverse_zap_duplicates
d1447 1
a1447 1
	my @@symbols;
d1456 1
a1456 1
				push @@symbols, $s;
d1462 2
a1463 2
	@@symbols = reverse_zap_duplicates(@@symbols);
	@@symbols = sort @@symbols;
d1465 1
a1465 1
	print $fh join("\n", @@symbols), "\n";
a1469 15
sub reverse_zap_duplicates
{
	my @@arglist = @@_;

	my $h = {};
	my @@r;
	for (my $i = $#arglist; $i >= 0; $i--) {
		my $el = $arglist[$i];
		next if (defined $h->{$el});
		unshift @@r, $el;
		$h->{$el} = 1;
	}
	return @@r;
}

@


1.58
log
@reintroduce (incomplete) support for --config, needed by some ports
@
text
@d2 1
a2 1
# $OpenBSD: libtool,v 1.57 2008/11/09 12:29:54 steven Exp $
d353 1
a353 1
my @@no_shared_archs = qw(m88k vax sh);
@


1.57
log
@more use of references

go for it espie@@
@
text
@d2 1
a2 1
# $OpenBSD: libtool,v 1.56 2008/11/09 10:30:54 steven Exp $
d413 1
a413 1
		'features' => \&features,
d825 2
a826 1
--debug	- turn on debugging output
d842 8
@


1.56
log
@- use reference in process_deplibs and a few other places
- avoid split/join ' ' dance
- prettier debug output

ok espie@@
@
text
@d2 1
a2 1
# $OpenBSD: libtool,v 1.55 2008/11/08 09:43:43 espie Exp $
d376 5
a380 5
my @@deplibs;		# list of dependent libraries (both -L and -l flags)
my %libs;		# libraries
my %libstofind;
my @@orderedlibs;	# ordered library keys (may contain duplicates)
my %dirs;		# paths to find libraries
d400 1
a400 1
$dirs{'/usr/lib'} = 3;
d674 1
a674 1
	Trace::debug {"deplibs = @@deplibs\n"};
d782 3
a784 3
		unshift @@deplibs, @@Ropts if (@@Ropts);
		Trace::debug {"deplibs = @@deplibs\n"};
		my $finaldeplibs = reverse_zap_duplicates_ref(\@@deplibs);
d961 1
a961 1
	if (internal_resolve_la(0, $result, \@@deplibs, $args)) {
d963 1
a963 1
		unshift(@@deplibs, '-pthread');
d1108 2
a1109 2
	internal_parse_linkargs($result, \@@deplibs, \@@Rresolved, \@@libsearchdirs, \@@orderedlibs, \%dirs, \%libs,
	    \%libstofind, $args, $la, 0);
d1121 1
a1121 1
	my @@dirs = sort { $dirs{$b} <=> $dirs{$a} } keys %dirs;
d1123 2
a1124 2
	Trace::debug {"search path= ", join(':', @@dirs), "\n"};
	foreach my $d (@@dirs) {
d1148 1
a1148 1
	my @@dirs = sort { $dirs{$b} <=> $dirs{$a} } keys %dirs;
d1150 2
a1151 2
	map { $_ = "$_/$ltdir" if (exists $dirs{$_} && $dirs{$_} > 3) } @@dirs;
	push @@dirs, @@ldconfigdirs;
d1153 2
a1154 2
	Trace::debug {"search path= ", join(':', @@dirs), "\n"};
	foreach my $sd (@@dirs) {
d1238 1
a1238 1
	@@orderedlibs = ();
d1240 4
a1243 4
	Trace::debug {"deplibs = @@deplibs\n"};
	Trace::debug {"orderedlibs = @@orderedlibs\n"};
	my @@finalorderedlibs = reverse_zap_duplicates(@@orderedlibs);
	Trace::debug {"final orderedlibs = @@finalorderedlibs\n"};
d1246 3
a1248 3
		Trace::debug {"dirs:\n", join("\n", (keys %dirs)), "\n"};
		Trace::debug {"libs:\n", join("\n", (keys %libs)), "\n"};
		Trace::debug {"libfiles:\n", join("\n", (values %libs)), "\n"};
d1252 2
a1253 2
			foreach my $k (@@finalorderedlibs) {
				unless (defined $libs{$k}) {
d1257 1
a1257 1
				my $a = $libs{$k};
d1278 1
a1278 1
	my @@RPdirs = ();
d1288 3
a1290 3
		@@RPdirs = (@@Ropts, @@RPopts, @@Rresolved);
		@@RPdirs = reverse_zap_duplicates(@@RPdirs);
		map { $_ = "-Wl,-rpath,$_" } @@RPdirs;
d1292 1
a1292 1
	foreach my $l (keys %libstofind) {
d1294 1
a1294 1
		$libs{$l} = $libpath if ($libpath);
d1297 3
a1299 3
	my @@libfiles = values %libs;
	Trace::debug {"dirs:\n", join("\n", (keys %dirs)), "\n"};
	Trace::debug {"libs:\n", join("\n", (keys %libs)), "\n"};
d1307 2
a1308 2
	foreach my $k (@@finalorderedlibs) {
		my $a = $libs{$k} || die "ERROR: $k not found in \$libs";
d1318 1
a1318 1
				if ($libcounter == @@finalorderedlibs - 1) {
d1348 1
a1348 1
	$cmd .= " @@RPdirs" if (@@RPdirs);
@


1.55
log
@oops2, committed stuff that's not ready yet along
@
text
@d2 1
a2 1
# $OpenBSD: libtool,v 1.53 2008/11/07 20:22:39 espie Exp $
d782 1
a782 3
		my $deplibstring = join ' ', @@deplibs;
		$deplibstring = "@@Ropts $deplibstring" if (@@Ropts);
		@@deplibs = split /\s+/, $deplibstring;
d784 3
a786 4
		my @@finaldeplibs = reverse_zap_duplicates(@@deplibs);
		Trace::debug {"finaldeplibs = @@finaldeplibs\n"};
		$deplibstring = join ' ', @@finaldeplibs;
		$lainfo->set('dependency_libs', $deplibstring);
d798 2
a799 1
			$lainfo->set('dependency_libs', process_deplibs($deplibstring));
d1198 1
a1198 1
	my $deplibline = shift;
d1200 1
a1200 2
	my @@linkflags = split /\s+/, $deplibline;
	my %la_in_ldpath;
d1202 1
a1202 1
	foreach my $lf (@@linkflags) {
a1203 1
			$lf = '';
d1207 3
d1212 1
a1212 1
	return join ' ', @@linkflags;
d1246 3
a1248 3
		Trace::debug {"dirs:  ", join(' ', (keys %dirs)), "\n"};
		Trace::debug {"libs:  ", join(' ', (keys %libs)), "\n"};
		Trace::debug {"libfiles: ", join(' ', (values %libs)), "\n"};
d1298 3
a1300 3
	Trace::debug {"dirs:  ", join(' ', (keys %dirs)), "\n"};
	Trace::debug {"libs:  ", join(' ', (keys %libs)), "\n"};
	Trace::debug {"libfiles: ", join(' ', @@libfiles), "\n"};
d1304 1
a1304 1
	Trace::debug {"symlinks to libfiles used for linking: @@libfiles\n"};
@


1.54
log
@oops
@
text
@d44 1
a44 1
	process_deplibs_list
a256 17
sub set_deplibs
{
	my ($self, $v) = @@_;

	$self->{deplib_list} = $v;
}

sub stringize
{
	my ($self, $k) = @@_;
	if ($k eq 'dependency_libs') {
		return join(' ', @@{$self->{deplib_list}}) || '';
	} else {
		return $self->SUPER::stringize($k);
	}
}

d361 1
a361 1
my @@picflags = ('-fPIC' '-DPIC');
d504 1
a504 1
		$cmd .= " @@picflags";
d782 3
a784 1
		unshift(@@deplibs, @@Ropts) if @@Ropts;
d788 2
a789 1
		$lainfo->set_deplibs(\@@finaldeplibs);
d801 1
a801 2
			$lainfo->set_deplibs(
			    process_deplibs_list(\@@finaldeplibs));
d1198 1
a1198 1
sub process_deplibs_list
d1200 1
a1200 3
	my $linkflags = shift;

	my $result = [];
d1202 1
d1205 1
a1205 1
	foreach my $lf (@@$linkflags) {
d1207 1
a1207 1
			next;
d1210 2
a1211 4
			push(@@$result, 
				LaFile->parse($lf)->{'libdir'}.'/'.$lafile);
		} else {
			push(@@$result, $lf);
d1213 1
a1213 1
	return $result;
d1343 2
a1344 2
	$cmd = $ltprog;
	$cmd .= " $sharedflag @@picflags" if ($lmode == LIBRARY);
d1426 1
a1426 1
	open(my $arh, '-|', "ar", "t", $a);
@


1.53
log
@finish switching parse_linkargs and resolve_la to lists,
stop the join ' ', split /\s+/ dance.

use debug(&) to avoid computing debug messages when not needed.
(and cleanup some old variables that no longer exist)

okay steven@@
@
text
@d2 1
a2 1
# $OpenBSD: libtool,v 1.52 2008/11/03 21:11:58 espie Exp $
d44 1
a44 1
	process_deplibs
d257 17
d378 1
a378 1
my $picflags = '-fPIC -DPIC';
d385 1
a385 1
my $D = 0;		# debug flag
d521 1
a521 1
		$cmd .= " $picflags";
d799 1
a799 3
		my $deplibstring = join ' ', @@deplibs;
		$deplibstring = "@@Ropts $deplibstring" if (@@Ropts);
		@@deplibs = split /\s+/, $deplibstring;
d803 1
a803 2
		$deplibstring = join ' ', @@finaldeplibs;
		$lainfo->set('dependency_libs', $deplibstring);
d815 2
a816 1
			$lainfo->set('dependency_libs', process_deplibs($deplibstring));
d1213 1
a1213 1
sub process_deplibs
d1215 3
a1217 1
	my $deplibline = shift;
a1218 1
	my @@linkflags = split /\s+/, $deplibline;
d1221 1
a1221 1
	foreach my $lf (@@linkflags) {
d1223 1
a1223 1
			$lf = '';
d1226 4
a1229 2
			$lf = LaFile->parse($lf)->{'libdir'}.'/'.$lafile;
		}
d1231 1
a1231 1
	return join ' ', @@linkflags;
d1361 2
a1362 2
	$cmd = "$ltprog";
	$cmd .= " $sharedflag $picflags" if ($lmode == LIBRARY);
d1444 1
a1444 1
	open(my $arh, '-|', "ar t $a");
@


1.52
log
@tweak a few things:
- cache more stuff to avoid calling internal_resolve_la
- add a tracing facility
- start cleaning up more stuff.

okay steven@@
@
text
@d2 1
a2 1
# $OpenBSD: libtool,v 1.51 2008/11/01 13:06:16 espie Exp $
a31 1
	debug
d42 1
a42 1
	parse_linkargs
d45 1
a45 1
	resolve_la
d67 11
d121 1
a121 1
	Trace::print { join(' ', @@l), "\n" };
d135 1
a135 1
			die "Error while executing ", join(' ', @@l), "\n";
d213 1
a213 1
	main::debug 1, "parsing $filename";
d216 1
a216 1
		main::debug 1, " (cached)\n";
d221 1
a221 1
		main::debug 1, " (cached)\n";
d224 1
a224 1
	main::debug 1, "\n";
a380 3
my $res_level = 0;	# resolve level
my $parse_level = 0;	# parse recursion level
my $performed = 0;	# number of commands executed via system()
d433 1
a433 1
		debug 1, "implicit mode: $mode\n";
d442 2
a443 2
print "\n###\n### WARNING: ",
	"This version of libtool is EXPERIMENTAL. ###\n###\n\n";
d493 2
a494 2
	debug 1, "srcfile = $srcfile\n" if ($srcfile);
	debug 1, "outfile = $outfile\n";
d570 2
a571 2
		debug 1, "srcdir = $srcdir\nsrcfile = $srcfile\n";
		debug 1, "dstdir = $dstdir\ndstfile = $dstfile\n";
d654 1
a654 1
	debug 1, "outfile = $outfile\n";
d668 1
a668 1
	debug 1, "linkmode: $linkmode\n";
d672 3
a674 4
	my $argvstring = join ' ', @@ARGV;
	$argvstring = parse_linkargs($argvstring, 1);
	@@ARGV = split /\s+/, $argvstring;
	debug 1, "deplibs = @@deplibs\n";
d691 2
a692 2
	debug 1, "objs = @@objs\n";
	debug 1, "sobjs = @@sobjs\n";
d703 1
a703 1
				debug 1, "no non-pic libtool objects found, trying pic objects...\n";
d706 2
a707 2
				debug 1, "no libtool objects of any kind found\n";
				debug 1, "hoping for real objects in ARGV...\n";
d759 1
a759 1
		debug 1, "SHARED: $shared\nSTATIC: $static\n";
d769 1
a769 1
			debug 1, "sharedlib: $sharedlib\n";
d777 1
a777 1
			debug 1, "staticlib: $staticlib\n";
d785 1
a785 1
		debug 1, "deplibs = @@deplibs\n";
d787 1
a787 1
		debug 1, "finaldeplibs = @@finaldeplibs\n";
d792 1
a792 1
				debug 1, "more than 1 -rpath option given, taking the first: ", $RPopts[0], "\n";
a844 12
sub debug
{
	my $level = shift;
	my @@messages = @@_;

	if ($D ge $level) {
		for (@@messages) {
			print;
		}
	}
}

d868 1
a868 1
		debug 1, "ln -s $f $dir/$libfile\n";
d918 1
a918 1
	debug 1, "resolve level: $level\n";
d959 1
a959 1
sub resolve_la
d961 1
a961 1
	my @@args = split /\s+/, shift;
d963 1
a963 3


	if (internal_resolve_la(0, $result, \@@deplibs, \@@args)) {
d967 1
a967 1
	return join ' ', @@$result;
d993 2
a994 2
	debug 1, "parse_linkargs pass: ", ($la == 1) ? 1 : 2, ", level: $level\n";
	debug 1, "  args: ", join(' ', @@$args), "\n";
d997 1
a997 1
		debug 1, "  processing $a\n";
d1097 1
a1097 1
			debug 1, "\$libs{$key} = ", $libs->{$key}, "\n";
d1102 1
a1102 1
	debug 1, "end parse_linkargs\n";
d1105 1
a1105 1
sub parse_linkargs
d1107 1
a1107 1
	my ($argstring, $la) = @@_;
a1108 1
	my @@args = split /\s+/, $argstring;
d1111 2
a1112 3
	    \%libstofind, \@@args, $la, 0);

	return join ' ', @@$result;
d1124 2
a1125 2
	debug 1, "searching .la for $l\n";
	debug 1, "search path= ", join(':', @@dirs), "\n";
d1129 1
a1129 1
				debug 1, "found $la_candidate\n";
d1134 1
a1134 1
	debug 1, ".la for $l not found!\n";
d1154 2
a1155 2
	debug 1, "searching for $libtofind\n";
	debug 1, "search path= ", join(':', @@dirs), "\n";
d1162 1
a1162 1
			debug 1, "found $libtofind in $sd\n";
d1167 1
a1167 1
				debug 1, "found static $libtofind in $sd\n";
d1183 1
a1183 1
	debug 1, "inspecting $filename for library dependencies...\n";
d1190 2
a1191 2
	debug 1, "found ", (@@deps == 0) ? 'no ' : '',
		"deps for $filename\n@@deps\n";
d1226 1
a1226 1
	debug 1, "creating link command for ",
d1228 1
a1228 1
		($shared) ? "dynam" : "stat", "ically)\n";
d1236 3
a1238 5
	my @@argvcopy = @@ARGV;
	my $argvstring = join ' ', @@argvcopy;
	debug 1, "argvstring (pre resolve_la): $argvstring\n";
	$argvstring = resolve_la($argvstring);
	debug 1, "argvstring (post resolve_la): $argvstring\n";
d1240 3
a1242 4
	$argvstring = parse_linkargs($argvstring, 0);
	debug 1, "deplibs = @@deplibs\n";
	@@argvcopy = split /\s+/, $argvstring;
	debug 1, "orderedlibs = @@orderedlibs\n";
d1244 1
a1244 2
	debug 1, "final orderedlibs = @@finalorderedlibs\n";

d1247 3
a1249 6
		my @@libfiles = values %libs;
		my @@dirval = keys %dirs;
		my @@libval = keys %libs;
		debug 1, "dirs:  @@dirval\n";
		debug 1, "libs:  @@libval\n";
		debug 1, "libfiles: @@libfiles\n";
d1255 1
a1255 1
					debug 1, "library $k not found in \%libs\n";
d1299 3
a1301 5
	my @@dirval = keys %dirs;
	my @@libval = keys %libs;
	debug 1, "dirs:  @@dirval\n";
	debug 1, "libs:  @@libval\n";
	debug 1, "libfiles: @@libfiles\n";
d1305 1
a1305 1
	debug 1, "symlinks to libfiles used for linking: @@libfiles\n";
d1346 1
a1346 1
	$cmd .= " @@argvcopy";
d1416 1
a1416 1
		debug 1, "mkdir -p $dir\n";
d1439 1
a1439 1
	debug 1, "generating symbol list in file: $filepath\n";
d1445 1
a1445 1
		debug 1, "$c: $line\n";
d1450 1
a1450 1
				debug 1, "matched\n";
@


1.51
log
@Exec class to run things.
LaLoFile class to read/write la and lo files.
@
text
@d2 1
a2 1
# $OpenBSD: libtool,v 1.50 2008/10/31 10:28:05 espie Exp $
d20 1
d48 1
d52 16
d103 1
d108 4
d138 1
a138 1
		print "$c\n" if $verbose || $dry;
d153 1
a153 1
	print "@@l\n" if $verbose || $dry;
a161 1
use File::Basename;
d163 35
d203 1
a203 1
	my $key = basename($filename);
d205 6
a210 2
	main::debug 1, "parsing $filename";
	if (defined $file_cache{$key}) {
d212 1
a212 17
		return $file_cache{$key};
	} else {
		main::debug 1, "\n";
		open(my $fh, '<', $filename) or die "cannot read $filename: $!\n";
		my $info = $class->new;
		while (<$fh>) {
			chomp;
			next if /^\#/;
			next if /^\s*$/;
			if (m/^(\S+)\=\'(.*)\'$/) {
				$info->{$1} = $2;
			} elsif (m/^(\S+)\=(\S+)$/) {
				$info->{$1} = $2;
			}
		}
		$file_cache{$key} = $info;
		return $info;
d214 3
a216 1

d229 18
d252 11
a262 12
	my $libname = $lainfo->{'libname'} || '';
	my $sharedlibname = $lainfo->{'dlname'} || '';
	my $staticlibname = $lainfo->{'old_library'} || '';
	my $librarynames = $lainfo->{'library_names'} || '';
	my $deplibs = $lainfo->{'dependency_libs'};
	my ($current, $revision, $age) = ('', '', '');
	$current = $lainfo->{'current'} if (defined $lainfo->{'current'});
	$revision = $lainfo->{'revision'} if (defined $lainfo->{'revision'});
	$age = $lainfo->{'age'} if (defined $lainfo->{'age'});
	my $installed = $lainfo->{'installed'};
	my $shouldnotlink = $lainfo->{'shouldnotlink'};
	my $libdir = $lainfo->{'libdir'} || '';
d265 1
a265 1
	print "creating $filename\n" if $main::verbose || $main::D;
d315 2
a316 2
	my $picobj = $self->{picobj} || '';
	my $nonpicobj = $self->{nonpicobj} || '';
d321 1
a321 1
	print "creating $filename\n" if $main::verbose || $main::D;
d341 1
a373 1
my $seen_pthread = 0;
d413 1
a413 1
		'version' => sub { print "$version\n" ; exit(0); },
d771 1
a771 1
			debug 1, print "staticlib: $staticlib\n";
d783 1
a783 1
		$lainfo->{'dependency_libs'} = $deplibstring;
d795 1
a795 1
			$lainfo->{'dependency_libs'} = process_deplibs($deplibstring);
d921 43
d967 2
a968 1
	my $argstring = shift;
a969 2
	my @@args = split /\s+/, $argstring;
	debug 1, "resolve level: $res_level\n";
d971 3
a973 9
	foreach my $a (@@args) {
		next if ($a !~ m/(.*)\.la$/);
		my $lainfo = LaFile->parse($a);
		if (exists $lainfo->{'dependency_libs'}) {
			$res_level++;
			$a = $a . ' ' . resolve_la($lainfo->{'dependency_libs'});
			$res_level--;
			push @@deplibs, $lainfo->{'dependency_libs'};
		}
d975 1
a975 1
	return join ' ', @@args;
d994 2
a995 1
sub parse_linkargs
d997 6
a1002 6
	my $argstring = shift;
	my $la = shift;

	my @@args = split /\s+/, $argstring;
	debug 1, "parse_linkargs pass: ", ($la == 1) ? 1 : 2, ", level: $parse_level\n";
	debug 1, "  argstring: $argstring\n";
d1004 1
a1004 1
	foreach my $a (@@args) {
a1007 1
			$a = '';   
d1010 1
a1010 1
			push @@deplibs, $a;
d1012 1
d1014 3
a1016 3
			if (!exists $dirs{$1}) {
				$dirs{$1} = 1;
				push @@deplibs, $a;
a1017 1
			$a = '';
d1021 1
a1021 2
			push @@Rresolved, $1;
			$a = '';
d1023 1
a1023 1
			my $lstring = '';
d1025 2
a1026 2
			if (!exists $libstofind{$key}) {
				$libstofind{$key} = 1;
d1030 2
a1031 2
						push @@deplibs, $lafile;
						$a = $lafile;
d1034 1
a1034 1
						my $libpath = find_lib($key, @@libsearchdirs);
d1039 1
a1039 1
						$libs{$key} = $libpath;
d1041 1
a1041 1
						# push @@deplibs, @@deps;
d1046 1
a1046 1
							$lstring .= "-l$k ";
d1048 1
a1048 1
						push @@deplibs, $a;
d1053 5
a1057 4
				$parse_level++;
				$a .= ' ';
				$a .= parse_linkargs($lstring, $la) if ($lstring);
				$parse_level--;
d1059 1
a1059 2
				push @@orderedlibs, $key;
				$a = '';
d1064 5
a1068 4
			$libs{$key} = $a;
			if (!$la) {
				push @@orderedlibs, $key;
				$a = '';
d1074 1
a1074 1
			$dirs{$d} = 1;
d1084 1
a1084 1
				push @@deplibs, $fulla;
d1087 5
a1091 3
			next if ($la);
			push @@orderedlibs, $key;
			$a = '';
d1100 1
a1100 1
				$libs{$key} = "$d/$oldlib";
d1103 1
a1103 1
				$libs{$key} = "$d/$dlname";
d1105 3
a1107 1
			debug 1, "\$libs{$key} = ", $libs{$key}, "\n";
d1111 12
a1122 1
	return join ' ', @@args;
d1183 1
a1183 1
	print "$libtofind not found!\n" if (!$libfile);
d1354 1
a1354 1
				print "warning: cannot derive -l flag from library filename, assuming hash key\n";
d1495 13
@


1.50
log
@simplify parse_file a bit, okay steven@@
@
text
@d2 1
a2 1
# $OpenBSD: libtool,v 1.49 2008/10/30 23:53:28 steven Exp $
d27 2
a41 1
	parse_file
a43 1
	perform
a46 2
	write_la_file
	write_lo_file
d50 221
d277 1
a277 1
my $version = '1.5.26'; # pretend to be this version of libtool
a294 1
my $dry = 0;		# dry-run
a305 1
my %file_cache;		# which files have been parsed
d341 1
a341 1
		'dry-run|n' => sub { $dry = 1; },
d352 3
d437 1
a437 1
		perform($cmd);
d445 1
a445 1
		perform($cmd);
d447 4
a450 2
	write_lo_file($outfile, ($pic) ? $picobj : '',
			($nonpic) ? $nonpicobj : '');
d506 1
a506 1
			my $lainfo = parse_file($s);
d533 1
a533 1
		perform("$ltprog @@realinstopts $s $d");
d536 2
a537 1
		perform("cd $dstdir && rm -f $d && ln -s $s $d");
d540 1
a540 1
		perform("$ltprog @@instopts @@ARGV");
d642 1
a642 1
		perform($cmd);
d691 2
a692 2
		my %lainfo;
		$lainfo{'libname'} = $libname;
d694 3
a696 3
			$lainfo{'dlname'} = $sharedlib;
			$lainfo{'library_names'} = $sharedlib;
			$lainfo{'library_names'} .= " $sharedlib_symlink"
d698 1
a698 1
			perform(linkcmds($ofile, $sharedlib, $odir, LIBRARY, 1, \@@sobjs));
d700 3
a702 3
			$lainfo{'current'} = $current;
			$lainfo{'revision'} = $revision;
			$lainfo{'age'} = $age;
d705 2
a706 2
			$lainfo{'old_library'} = $staticlib;
			perform(linkcmds($ofile, $staticlib, $odir, LIBRARY, 0, ($allpicobj) ? \@@sobjs : \@@objs));
d709 2
a710 2
		$lainfo{'installed'} = 'no';
		$lainfo{'shouldnotlink'} = $opts{'module'} ? 'yes' : 'no';
d719 1
a719 1
		$lainfo{'dependency_libs'} = $deplibstring;
d724 1
a724 1
			$lainfo{'libdir'} = $RPopts[0];
d726 3
a728 2
		write_la_file($outfile, $ofile, \%lainfo);
		perform("cd $odir/$ltdir && rm -f $ofile && ln -s ../$ofile $ofile");
d731 2
a732 2
			$lainfo{'dependency_libs'} = process_deplibs($deplibstring);
			$lainfo{'installed'} = 'yes';
d734 1
a734 1
			write_la_file($lai, $ofile, \%lainfo);
d742 1
a742 1
	perform("$ltprog @@ARGV");
d747 1
a747 1
if ($performed == 0) {
a786 14
# display and execute a list of commands via system(), and die on error.
sub perform
{
	my @@cmd = @@_;

	foreach my $c (@@cmd) {
		print "$c\n" if ($verbose || $dry || $D);
		if (!$dry) {
			system($c) == 0 or die "Error while executing:\n$c\n";
		}
	}
	$performed++;
}

a816 83
# write a libtool object file
sub write_lo_file
{
	my $filename = shift;
	my $picobj = shift;
	my $nonpicobj = shift;

	my $name = basename $filename;

	open(my $lo, '>', $filename) or die "cannot write $filename: $!\n";
	print "creating $filename\n" if ($verbose || $D);
	print $lo <<EOF
# $name - a libtool object file
# Generated by libtool $version
#
pic_object='$picobj'
non_pic_object='$nonpicobj'
EOF
;
}

# XXX not sure how much of this cruft we need
sub write_la_file
{
	my $filename = shift;
	my $name = shift;
	my $lainfo = shift;

	my $libname = $lainfo->{'libname'} || '';
	my $sharedlibname = $lainfo->{'dlname'} || '';
	my $staticlibname = $lainfo->{'old_library'} || '';
	my $librarynames = $lainfo->{'library_names'} || '';
	my $deplibs = $lainfo->{'dependency_libs'};
	my ($current, $revision, $age) = ('', '', '');
	$current = $lainfo->{'current'} if (defined $lainfo->{'current'});
	$revision = $lainfo->{'revision'} if (defined $lainfo->{'revision'});
	$age = $lainfo->{'age'} if (defined $lainfo->{'age'});
	my $installed = $lainfo->{'installed'};
	my $shouldnotlink = $lainfo->{'shouldnotlink'};
	my $libdir = $lainfo->{'libdir'} || '';

	open(my $la, '>', $filename) or die "cannot write $filename: $!\n";
	print "creating $filename\n" if ($verbose || $D);
	print $la <<EOF
# $name - libtool library file
# Generated by libtool $version
#
# Please DO NOT delete this file!
# It is necessary for linking the library.

# The name that we can dlopen(3).
dlname='$sharedlibname'

# Names of this library.
library_names='$librarynames'

# The name of the static archive.
old_library='$staticlibname'

# Libraries that this one depends upon.
dependency_libs='$deplibs'

# Version information for $libname.
current=$current
age=$age
revision=$revision

# Is this an already installed library?
installed=$installed

# Should we warn about portability when linking against -modules?
shouldnotlink=$shouldnotlink

# Files to dlopen/dlpreopen
dlopen=''
dlpreopen=''

# Directory that this library needs to be installed in:
libdir='$libdir'
EOF
;
}

a856 30
sub parse_file
{
	my $filename = shift;

	my $key = basename($filename);

	debug 1, "parsing $filename";
	if (defined $file_cache{$key}) {
		debug 1, " (cached)\n";
		return $file_cache{$key};
	} else {
		debug 1, "\n";
		open(my $fh, '<', $filename) or die "cannot read $filename: $!\n";
		my $info = {};
		while (<$fh>) {
			chomp;
			next if /^\#/;
			next if /^\s*$/;
			if (m/^(\S+)\=\'(.*)\'$/) {
				$info->{$1} = $2;
			} elsif (m/^(\S+)\=(\S+)$/) {
				$info->{$1} = $2;
			}
		}
		$file_cache{$key} = $info;
		return $info;
	}

}

d867 1
a867 1
		my $lainfo = parse_file($a);
d976 1
a976 1
			my $lainfo = parse_file($fulla);
d1105 1
a1105 1
			$lf = parse_file($lf)->{'libdir'}.'/'.$lafile;
d1272 1
a1272 1
			my $loinfo = parse_file($a);
d1323 1
a1323 1
	perform("cd $dir && ar x $archive");
@


1.49
log
@add support for -export-symbols-regex, seems to work
@
text
@d2 1
a2 1
# $OpenBSD: libtool,v 1.48 2008/10/30 22:22:34 steven Exp $
d284 1
a284 2
			my %lainfo;
			parse_file($s, \%lainfo);
d286 3
a288 3
			my $sharedlib = $lainfo{'dlname'};
			my $staticlib = $lainfo{'old_library'};
			my @@libnames = split /\s+/, $lainfo{'library_names'};
a732 1
	my $info = shift;
d739 1
a739 1
		%{$info} = %{$file_cache{$key}};
d743 1
d746 1
a746 1
			next if /^#/;
d748 1
a748 1
			if (m/^(\S+)='(.*)'$/) {
d750 1
a750 1
			} elsif (m/^(\S+)=(\S+)$/) {
d755 1
a757 1
	return 1;
d770 2
a771 3
		my %lainfo;
		parse_file($a, \%lainfo);
		if (exists $lainfo{'dependency_libs'}) {
d773 1
a773 1
			$a = $a . ' ' . resolve_la($lainfo{'dependency_libs'});
d775 1
a775 1
			push @@deplibs, $lainfo{'dependency_libs'};
a875 1
			my %lainfo;
d879 5
a883 5
			parse_file($fulla, \%lainfo);
			my $dlname = $lainfo{'dlname'};
			my $oldlib = $lainfo{'old_library'};
			my $libdir = $lainfo{'libdir'};
			if ($d !~ m/\Q$ltdir\E$/ && $lainfo{'installed'} eq 'no') {
d1008 1
a1008 3
			my %lainfo;
			parse_file($lf, \%lainfo);
			$lf = $lainfo{'libdir'}.'/'.$lafile;
a1172 1
			my %loinfo;
d1175 2
a1176 2
			parse_file($a, \%loinfo);
			if ($loinfo{'non_pic_object'}) {
d1179 1
a1179 1
				$o .= $loinfo{'non_pic_object'};
d1182 1
a1182 1
			if ($loinfo{'pic_object'}) {
d1185 1
a1185 1
				$o .= $loinfo{'pic_object'};
@


1.48
log
@support -export-symbols
@
text
@d2 1
a2 1
# $OpenBSD: libtool,v 1.47 2008/10/30 19:13:11 steven Exp $
d348 1
a348 2
	# XXX options ignored: dlopen, dlpreopen,
	# 	export-symbols-regex, no-fast-install,
d1090 8
a1097 1
	my $symbolsfile = $opts{'export-symbols'};
d1244 28
@


1.47
log
@same search path debug info for find_la
@
text
@d2 1
a2 1
# $OpenBSD: libtool,v 1.46 2008/10/30 19:02:19 steven Exp $
d349 1
a349 1
	# 	export-symbols, export-symbols-regex, no-fast-install,
d1091 1
d1156 1
@


1.46
log
@in find_lib, setup search path before starting search instead of modifying
some of the paths as we go; print search path in debug mode
rename a few variables for clarity
remove a spurious print statement

looks good to bernd
@
text
@d2 1
a2 1
# $OpenBSD: libtool,v 1.45 2008/10/30 18:15:06 steven Exp $
d926 2
a927 1
	debug 1, "searching .la for $l ...\n";
a928 1
		debug 1, "   ... in $d\n";
@


1.45
log
@deal with multiple -rpath arguments; add the paths correctly to the run-time
path when linking an executable.

looks good to bernd@@
@
text
@d2 1
a2 1
# $OpenBSD: libtool,v 1.44 2008/10/30 15:03:07 steven Exp $
d953 2
d956 3
a958 6
	debug 1, "searching for $libtofind ...\n";
	foreach my $d (@@dirs) {
		my $sd = $d;
		# search in .libs when priority is high
		$sd = "$d/$ltdir" if (exists $dirs{$d} && $dirs{$d} > 3);
		debug 1, "   ... in $d\n";
d960 2
a961 2
		@@globbedlib = sort { my ($c,$d) =
			map { /\.so\.(\d+\.\d+)$/; $1 } ($a,$b); $d <=> $c }
d964 1
a964 1
			debug 1, print "found $libtofind in $sd\n";
@


1.44
log
@revert part of r1.35 which reversed deplibs, seems to cause very long loops
@
text
@d2 1
a2 1
# $OpenBSD: libtool,v 1.43 2008/10/30 10:46:53 steven Exp $
d79 3
a81 1
my @@Ropts;		# -R options
d94 8
d339 1
a339 1
			'rpath=s'		=> \$opts{'rpath'},
d435 2
a436 2
				$opts{'rpath'});
		if ($opts{'static'} || !$opts{'rpath'}) {
d490 1
a490 2
		my @@Rflags = @@Ropts;
		map { $_ = "-R$_" } @@Rflags;
d492 1
a492 1
		$deplibstring = "@@Rflags $deplibstring" if (@@Rflags);
d499 5
a503 2
		if ($opts{'rpath'}) {
			$lainfo{'libdir'} = $opts{'rpath'};
d825 1
a825 1
			# -R options coming from .la resolution
d827 2
a828 1
			$a = "-Wl,-rpath,$1";
d1091 6
a1096 2
	my @@Rflags = @@Ropts;
	map { $_ = "-Wl,-rpath,$_" } @@Rflags;
d1155 1
a1155 1
	$cmd .= " @@Rflags" if (@@Rflags);
@


1.43
log
@don't add -pthread flag over and over again
@
text
@d2 1
a2 1
# $OpenBSD: libtool,v 1.42 2008/10/30 10:39:38 steven Exp $
d804 1
a804 1
			unshift @@deplibs, $a;
d809 1
a809 1
				unshift @@deplibs, $a;
d824 1
a824 1
						unshift @@deplibs, $lafile;
d842 1
a842 1
						unshift @@deplibs, $a;
d878 1
a878 1
				unshift @@deplibs, $fulla;
@


1.42
log
@support -export-dynamic

from jakemsr@@ long ago
@
text
@d2 1
a2 1
# $OpenBSD: libtool,v 1.41 2008/10/29 23:13:22 steven Exp $
d90 1
a796 1
	my $seen_pthread = 0;
@


1.41
log
@zap some rather useless features

bernd agrees
@
text
@d2 1
a2 1
# $OpenBSD: libtool,v 1.40 2008/10/29 23:09:07 steven Exp $
d337 1
a337 1
	# XXX options ignored: dlopen, dlpreopen, export-dynamic,
d395 3
@


1.40
log
@convert some more lines to use the debug function
@
text
@d2 1
a2 1
# $OpenBSD: libtool,v 1.39 2008/10/29 16:16:49 bernd Exp $
a518 1
--config - print configuration
a520 2
--features - show basic configuration information
--finish - same as `--mode=finish'
a560 17
}

# XXX incomplete
sub config
{
	print "objdir=$ltdir\n";
	print "...\n";
	exit 0;
}

sub features
{
	chomp (my $osver = `uname -r`);	# XXX avoid calling uname
	print "host: $gnu_arch-unknown-openbsd$osver\n";
	print (($noshared) ? "dis" : "en", "able shared libraries\n");
	print ((!$static)  ? "dis" : "en", "able static libraries\n");
	exit 0;
@


1.39
log
@foo.la files which have libdir set are going to be installed and should
end up in dependency_libs. ok steven
@
text
@d2 1
a2 1
# $OpenBSD: libtool,v 1.38 2008/10/29 16:10:53 steven Exp $
d1061 5
a1065 7
		if ($D) {
			my @@dirval = keys %dirs;
			my @@libval = keys %libs;
			print "dirs:  @@dirval\n";
			print "libs:  @@libval\n";
			print "libfiles: @@libfiles\n";
		}
d1103 5
a1107 7
	if ($D) {
		my @@dirval = keys %dirs;
		my @@libval = keys %libs;
		print "dirs:  @@dirval\n";
		print "libs:  @@libval\n";
		print "libfiles: @@libfiles\n";
	}
@


1.38
log
@build static library if -rpath is not set
only fill in libdir if -rpath is set
@
text
@d2 1
a2 1
# $OpenBSD: libtool,v 1.37 2008/10/29 15:28:22 steven Exp $
d890 1
d894 1
a894 1
			if ($dlname && $la) {
@


1.37
log
@error out if we cannot find a library file in the library hash
restrict addition of a flag to library link mode
@
text
@d2 1
a2 1
# $OpenBSD: libtool,v 1.36 2008/10/29 12:13:01 steven Exp $
d421 2
a422 2
				$opts{'rpath'} );
		if ($opts{'static'}) {
a487 3
		} else {
			# XXX sensible default?
			$lainfo{'libdir'} = $instlibdir;
d652 1
a652 1
	my $libdir = $lainfo->{'libdir'};
@


1.36
log
@use a subroutine for printing debug info
print some more debug info while here
@
text
@d2 1
a2 1
# $OpenBSD: libtool,v 1.35 2008/10/29 10:09:33 steven Exp $
d1121 1
a1121 1
		my $a = $libs{$k};
d1137 4
a1140 2
			if ($prev_was_archive) {
				push @@libflags, '-Wl,-no-whole-archive';
@


1.35
log
@revert a fix from bernd, it breaks other stuff
build deplibs the reverse way, seems to improve the ordering a bit
@
text
@d2 1
a2 1
# $OpenBSD: libtool,v 1.34 2008/10/28 17:16:31 bernd Exp $
d29 1
d131 1
a131 1
		print "implicit mode: $mode\n" if $D;
d191 2
a192 2
	print "srcfile = $srcfile\n" if ($srcfile && $D);
	print "outfile = $outfile\n" if $D;
d266 2
a267 2
		print "srcdir = $srcdir\nsrcfile = $srcfile\n" if $D;
		print "dstdir = $dstdir\ndstfile = $dstfile\n" if $D;
d351 1
a351 1
	print "outfile = $outfile\n" if $D;
d365 1
a365 1
	print "linkmode: $linkmode\n" if $D;
d372 1
a372 1
	print "deplibs = @@deplibs\n" if $D;
d389 2
a390 2
	print "objs = @@objs\n" if $D;
	print "sobjs = @@sobjs\n" if $D;
d398 1
a398 1
				warn "no non-pic libtool objects found, trying pic objects...\n";
d401 2
a402 2
				warn "no libtool objects of any kind found\n";
				warn "hoping for real objects in ARGV...\n";
d454 1
a454 1
		print "SHARED: $shared\nSTATIC: $static\n" if $D;
d464 1
a464 1
			print "sharedlib: $sharedlib\n" if $D;
d472 1
a472 1
			print "staticlib: $staticlib\n" if $D;
d481 1
d483 1
d543 12
d609 1
a609 1
		print "ln -s $f $dir/$libfile\n" if $D;
d746 1
a746 1
	print "parsing $filename" if $D;
d748 1
a748 1
		print " (cached)\n" if $D;
d751 1
a751 1
		print "\n" if $D;
d775 1
a775 1
	print "resolve level: $res_level\n" if $D;
d813 2
a814 2
	print "parse_linkargs level: $parse_level\n" if $D;
	print "  argstring: $argstring\n" if $D;
d818 1
d916 1
a916 1
			print "\$libs{$key} = ", $libs{$key}, "\n" if $D;
d919 1
d932 1
a932 1
	print "searching .la for $l ...\n" if $D;
d934 1
a934 1
		print "   ... in $d\n" if $D;
d937 1
d942 1
a942 1
	print ".la for $l not found!\n" if $D;
d960 1
a960 1
	print "searching for $libtofind ...\n" if $D;
d965 1
a965 1
		print "   ... in $d\n" if $D;
d971 1
a971 1
			print "found $libtofind in $sd\n" if $D;
d976 1
a976 1
				print "found static $libtofind in $sd\n" if $D;
d992 1
a992 1
	print "inspecting $filename for library dependencies...\n" if $D;
d999 2
a1000 2
	print "found ", (@@deps == 0) ? 'no ' : '',
		"deps for $filename\n@@deps\n" if $D;
d1037 1
a1037 1
	print "creating link command for ",
d1039 1
a1039 1
		($shared) ? "dynam" : "stat", "ically)\n" if $D;
d1049 1
a1049 1
	print "argvstring (pre resolve_la): $argvstring\n" if $D;
d1051 1
a1051 1
	print "argvstring (post resolve_la): $argvstring\n" if $D;
d1054 1
d1056 1
a1056 1
	print "orderedlibs = @@orderedlibs\n" if $D;
d1058 1
a1058 1
	print "final orderedlibs = @@finalorderedlibs\n" if $D;
d1075 1
a1075 1
					print "library $k not found in \%libs\n" if $D;
d1117 1
a1117 1
	print "symlinks to libfiles used for linking: @@libfiles\n" if $D;
d1226 1
a1226 1
		print "mkdir -p $dir\n" if $D;
@


1.34
log
@Fix globbing to find libraries. ok steven
@
text
@d2 1
a2 1
# $OpenBSD: libtool,v 1.33 2008/10/28 17:15:00 bernd Exp $
d808 1
a808 1
			push @@deplibs, $a;
d813 1
a813 1
				push @@deplibs, $a;
d828 1
a828 1
						push @@deplibs, $lafile;
d846 1
a846 1
						push @@deplibs, $a;
d880 2
a881 2
			if ($la) {
				push @@deplibs, $fulla;
@


1.33
log
@Unbreak dependency_libs generation for .la files. ok steven
@
text
@d2 1
a2 1
# $OpenBSD: libtool,v 1.32 2008/10/28 11:31:48 bernd Exp $
d951 1
a951 1
			glob "$sd/lib$libtofind.so.*";
@


1.32
log
@Print a warning if a lib isn't found in %libs so we don't try to use
an uninitialized variable.

steven agrees
@
text
@d2 1
a2 1
# $OpenBSD: libtool,v 1.31 2008/10/28 11:16:27 bernd Exp $
d880 1
a880 1
			if ($dlname && $la) {
@


1.31
log
@parse_file now caches the file contents in %file_cache so we don't
have to to IO on the same files again and again.

don't skip any .la files in resolve_la yet to not break the order
(fixes misc/amanda)

added some debugging prints

ok steven
@
text
@d2 1
a2 1
# $OpenBSD: libtool,v 1.30 2008/10/28 10:01:13 steven Exp $
d1055 4
@


1.30
log
@find -lfoo libraries also inside ./.libs directory
@
text
@d2 1
a2 1
# $OpenBSD: libtool,v 1.27 2008/10/27 10:34:18 steven Exp $
d85 1
a85 1
my %file_parsed;	# which files have been parsed
d729 18
a746 9
	print "parsing $filename\n" if $D;
	open(my $fh, '<', $filename) or die "cannot read $filename: $!\n";
	while (<$fh>) {
		next if /^#/;
		next if /^\s*$/;
		if (m/^(\S+)='(.*)'$/) {
			$info->{$1} = $2;
		} elsif (m/^(\S+)=(\S+)$/) {
			$info->{$1} = $2;
d748 1
d750 2
d765 6
a770 12
		if (!exists $file_parsed{$a} || !$file_parsed{$a}) {
			parse_file($a, \%lainfo);
			$file_parsed{$a} = 1;
			if (exists $lainfo{'dependency_libs'}) {
				$res_level++;
				$a = $a . ' ' . resolve_la($lainfo{'dependency_libs'});
				$res_level--;
				push @@deplibs, $lainfo{'dependency_libs'};
			}
		} else {
			$a = '';
			next;
d799 1
d1031 1
d1033 1
@


1.29
log
@try to use pic objects if no non-pic objects can be found
throw some warnings
@
text
@d342 3
@


1.28
log
@use -whole-archive linker flag when linking a shared library with static
libraries
@
text
@d391 11
a401 1
		my @@tmpcmd = linkcmds($ofile, $ofile, $odir, PROGRAM, 1, \@@objs);
@


1.27
log
@support -objectlist option; makes devel/cln build
@
text
@d2 1
a2 1
# $OpenBSD: libtool,v 1.25 2008/10/26 09:52:10 steven Exp $
d1073 2
d1080 3
a1082 9
				# extract objects from archive
				my $libfile = basename $a;
				my $xdir = "$odir/$ltdir/${la}x/$libfile";
				extract_archive($xdir, $a);
				my @@kobjs = get_objlist_from_archive($a);
				map { $_ = "$xdir/$_"; } @@kobjs;
				push @@libflags, @@kobjs;
			} elsif ($lmode == PROGRAM) {
				push @@libflags, $a;
d1084 7
d1092 4
d1105 1
@


1.26
log
@slightly more readable
use same comment as gnu .la file
@
text
@d338 1
a338 1
	# 	no-install, no-undefined, objectlist, precious-files-regex,
d375 10
a384 1
	my $allpicobj = generate_objlist(\@@objs, \@@sobjs);
d1117 1
d1120 1
a1120 1
	foreach my $a (@@ARGV) {
@


1.25
log
@sort subs
@
text
@d2 1
a2 1
# $OpenBSD: libtool,v 1.24 2008/10/26 09:44:22 steven Exp $
a240 2
	# assume dst is a directory
	my $dstdir = $dst;
d242 5
a246 2
	# dst is not a directory, i.e. a file
	if (! -d $dst) {
d434 1
d607 1
d641 1
a641 1
# Version information for $sharedlibname
@


1.24
log
@slight code reorg, somewhat more readable
@
text
@d2 1
a2 1
# $OpenBSD: libtool,v 1.23 2008/10/20 21:00:30 steven Exp $
d28 7
d36 2
a37 1
	handle_special_chars
a38 8
	perform
	parse_version_info
	guess_implicit_mode
	create_symlinks
	write_lo_file
	write_la_file
	write_prog_wrapper
	is_prog_wrapper
a39 1
	resolve_la
d41 2
a42 2
	find_la
	find_lib
d44 1
d46 3
a48 3
	linkcmd
	generate_objlist
	get_search_dirs
@


1.23
log
@abort if neither a .la file nor a real library can be found
@
text
@d2 1
a2 1
# $OpenBSD: libtool,v 1.22 2008/10/20 20:20:09 steven Exp $
d4 1
a4 1
# Copyright (c) 2007 Steven Mestdagh <steven@@openbsd.org>
d163 1
a163 2
	my $outfile = $opts{'o'};
	my $srcfile;
d165 7
a171 1
	if (!$outfile) {
d178 1
d185 4
a188 3
		$outfile = basename $srcfile;
		$outfile =~ s/\.($srcre)$//i;
		$outfile .= '.lo';
d191 1
a191 7
	# put output file in . if no -o flag is given
	my $odir = '.';
	# fix extension if needed
	$outfile =~ s/\.o$/.lo/;
	$odir = dirname $outfile if ($opts{'o'});
	my $ofile = basename $outfile;
	print "outfile = $odir/$ofile\n" if $D;
@


1.22
log
@don't try to strip .la files on installation
use same libtool version as in ports tree
@
text
@d2 1
a2 1
# $OpenBSD: libtool,v 1.21 2008/10/20 20:16:05 steven Exp $
d800 3
d804 1
a804 1
						$libs{$key} = $libpath if ($libpath);
@


1.21
log
@-n is an alias for --dry-run
@
text
@d2 1
a2 1
# $OpenBSD: libtool,v 1.20 2008/10/10 20:32:28 steven Exp $
d57 1
a57 1
my $version = '1.5.22'; # pretend to be this version of libtool
d295 1
a295 1
		if ($s =~ m/\.la$/) {
@


1.20
log
@sort libraries by version number only instead of alphanumerically by filename
prevents libfoo.so.10.0 < libfoo.so.9.0

pointed out and similar diff by bluhm@@ before ports lock
@
text
@d2 1
a2 1
# $OpenBSD: libtool,v 1.19 2008/05/01 22:02:32 steven Exp $
d112 1
a112 1
		'dry-run' => sub { $dry = 1; },
@


1.19
log
@say it's experimental. avoid it for regular ports building for now...
@
text
@d2 1
a2 1
# $OpenBSD: libtool,v 1.18 2008/02/17 02:01:42 jakemsr Exp $
d912 4
a915 1
		@@globbedlib = glob <$sd/lib$libtofind.so.*>;
@


1.18
log
@
escape special characters in arguments before splitting arguments on
spaces.

ok steven@@
@
text
@d2 1
a2 1
# $OpenBSD: libtool,v 1.17 2007/11/16 15:37:20 steven Exp $
d138 3
@


1.17
log
@- store more info in .la files, simplifies the resolver
- process -R flags
- try to use the right -l flag
- skip prefer-pic/non-pic for now
- various tweaks
@
text
@d2 1
a2 1
# $OpenBSD: libtool,v 1.14 2007/11/05 12:15:35 steven Exp $
d358 2
a366 2

	handle_special_chars(\@@ARGV);
@


1.16
log
@don't create symlinks to static libraries
@
text
@d2 1
a2 1
# $OpenBSD: libtool,v 1.15 2007/11/05 12:45:34 steven Exp $
d86 1
a86 1
my $res_level = 0;	# resolution recursion level
a93 1
my $allpicobj = 0;
d150 1
a155 3
	if ($opts{'prefer-pic'} && $opts{'prefer-non-pic'}) {
		die "Can't use -prefer-pic and -prefer-non-pic together!\n";
	}
a157 5
	if ($opts{'prefer-pic'} && !$noshared) {
		$pic = 1; $nonpic = 0;
	} elsif ($opts{'prefer-non-pic'}) {
		$pic = 0; $nonpic = 1;
	}
d211 2
a212 1
	write_lo_file($outfile, $picobj, $nonpicobj);
d319 2
d334 1
a334 1
	# 	shrext, thread-safe
d370 1
a370 1
	generate_objlist(\@@objs, \@@sobjs);
a373 10
	# if one ore more shared objects are absent, don't link dynamically
	$allpicobj = 1;
	foreach my $so (@@sobjs) {
		if (! -f $so) {
			$shared = 0;
			$allpicobj = 0;
			last;
		}
	}

d447 2
d450 1
a453 3
		my @@Rflags = @@Ropts;
		map { $_ = "-R$_" } @@Rflags;
		$deplibstring = "@@Rflags $deplibstring" if (@@Rflags);
d461 1
a461 1
		write_la_file($outfile, \%lainfo);
d468 1
a468 1
			write_la_file($lai, \%lainfo);
d598 1
a600 1
	my $name = basename $filename;
d713 1
a713 3
# eliminate all .la files in the argument string and replace them by
# their library plus dependencies.
# start populating libs hash with paths to the library files.
a716 1
	my $static = shift;
d727 6
a736 41
		my $d = abs_path(dirname($a));
		if ($d !~ m/\Q$ltdir\E$/ && $lainfo{'installed'} eq 'no') {
			$d .= "/$ltdir";
		}
		my $dlname = $lainfo{'dlname'};
		my $oldlib = $lainfo{'old_library'};
		my $lib;
		# get the name we need (this may include a -release)
		if ($dlname) {
			($lib = $dlname) =~ s/^(\S+)\.so(\.\d+\.\d+)?$/$1/;
		} elsif ($oldlib) {
			($lib = $oldlib) =~ s/^(\S+)\.a$/$1/;
		} else {
			die "neither static nor shared library found in $a\n";
		}
		$lib =~ s/^lib//;
		if (!exists $dirs{$d}) {
			$dirs{$d} = 1;
		}
		# XXX in some cases there are multiple libs with the same name
		# so probably need to use a different key
		if ($static || $lainfo{'dlname'} eq '') {
			# static
			if (!exists $libs{$lib}) {
				$libs{$lib} = $d.'/'.$lainfo{'old_library'};
			}
			$a = $d.'/'.$lainfo{'old_library'};
		} else {
			# shared
			if (!exists $libs{$lib}) {
				$libs{$lib} = $d.'/'.$lainfo{'dlname'};
			}
			$a = "-l$lib";
		}
		print "\$libs{$lib} = ", $libs{$lib}, "\n" if $D;
		if ($lainfo{'dependency_libs'}) {
			$res_level++;
			$a .= ' ';
			$a .= resolve_la($lainfo{'dependency_libs'}, $static);
			$res_level--;
		}
d780 4
d787 1
a787 1
			if (!exists $libs{$key} && !exists $libstofind{$key}) {
d823 1
a823 3
			if (!exists $libs{$key}) {
				$libs{$key} = $a;
			}
d828 1
a828 1
		} elsif ($la && $a && $a =~ m/(\S+\/)*(\S+)\.la$/) {
d832 2
d836 6
a841 3
			# if we are dealing with a static library, it will
			# be linked in and won't be a dependent one.
			if (exists $lainfo{'dlname'} && $lainfo{'dlname'} ne '') {
a842 12
			} elsif (exists $lainfo{'old_library'} &&
				  $lainfo{'old_library'} ne '') {
				if (!exists $libs{$key}) {
					my $d = abs_path(dirname($a));
					if ($d !~ m/\Q$ltdir\E$/ && $lainfo{'installed'} eq 'no') {
						$d .= "/$ltdir";
					}
					$libs{$key} = $d.'/'.$lainfo{'old_library'};
				}
				push @@deplibs, $lainfo{'dependency_libs'}
					if (exists $lainfo{'dependency_libs'});
				# $a = '';
d844 18
d987 10
d999 8
d1010 1
a1010 1
			foreach my $k (keys %libs) {  # FIX ORDER HERE
a1033 9
	my @@argvcopy = @@ARGV;
	my $argvstring = join ' ', @@argvcopy;
	$argvstring = resolve_la($argvstring, !$shared);
	@@orderedlibs = ();
	$argvstring = parse_linkargs($argvstring, 0);
	@@argvcopy = split /\s+/, $argvstring;
	print "orderedlibs = @@orderedlibs\n" if $D;
	my @@finalorderedlibs = reverse_zap_duplicates(@@orderedlibs);
	print "final orderedlibs = @@finalorderedlibs\n" if $D;
d1035 2
a1036 4
		if (!exists $libs{$l}) {
			my $libpath = find_lib($l);
			$libs{$l} = $libpath if ($libpath);
		}
d1052 2
a1053 2
		$a = $libs{$k};
		if ($a =~ m/\.a$/ && $a !~ m/_pic\.a/) {
d1067 8
a1074 1
			push @@libflags, "-l$k";
d1095 1
d1114 2
d1120 1
@


1.15
log
@install libraries with mode 644 if possible.
@
text
@d2 1
a2 1
# $OpenBSD: libtool,v 1.14 2007/11/05 12:15:35 steven Exp $
d579 1
@


1.14
log
@handle -prefer-pic and -prefer-non-pic options in compile mode.
shorten second getopt configuration line a bit.
@
text
@d2 1
a2 1
# $OpenBSD: libtool,v 1.13 2007/11/05 11:27:34 steven Exp $
d271 3
@


1.13
log
@also use -R flags when linking libraries, and add them into dependency_libs.
@
text
@d2 1
a2 1
# $OpenBSD: libtool,v 1.12 2007/11/03 13:40:08 steven Exp $
d138 1
a138 1
$gp->configure('no_ignore_case', 'pass_through', 'no_auto_abbrev', 'permute');
a145 5
	my $cmd;
	# assume we need to build pic objects
	$shared = 1 if (!$noshared);
	$static = 0 if ($shared && grep { $_ eq 'disable-static' } @@tags);
	$shared = 0 if ($static && grep { $_ eq 'disable-shared' } @@tags);
d151 17
a167 1
	# XXX options ignored: prefer-pic, prefer-non-pic
d202 1
a202 2
	# pic object
	if ($shared) {
d211 1
a211 2
	# non-pic object
	if ($static) {
@


1.12
log
@rework comments a bit
@
text
@d2 1
a2 1
# $OpenBSD: libtool,v 1.11 2007/11/03 10:15:41 steven Exp $
d78 1
a299 1
	my @@Ropts;
a381 2
		map { $_ = "-Wl,-rpath,$_" } @@Ropts;
		$cmd .= " @@Ropts" if (@@Ropts);
d454 3
d1041 2
d1097 1
@


1.11
log
@handle current,revision,age stuff a bit better, and make sure it all gets
written in the .la file
@
text
@d2 1
a2 1
# $OpenBSD: libtool,v 1.10 2007/11/03 09:20:34 steven Exp $
d545 1
a545 1
# convert 4:5:8 to 4.5
d970 3
a972 1
# convert /a/b/c/libfoo.la to /usr/local/lib/libfoo.la
a1154 1
#		perform("mkdir -p $dir");
@


1.10
log
@drop -L flags containing .libs directories from installed .la file
@
text
@d2 1
a2 1
# $OpenBSD: libtool,v 1.9 2007/11/03 08:47:46 steven Exp $
d407 1
d410 2
d413 2
a414 1
			$sover = parse_version_info($opts{'version-info'});
d441 3
a443 1
			($lainfo{'current'}, $lainfo{'age'}) = split /\./, $sover;
d550 2
a551 2
	if ($vinfo =~ m/(\d+):(\d+):\d+/) {
		return "$1.$2";
d606 4
a609 2
	my $current = $lainfo->{'current'} || '';
	my $age = $lainfo->{'age'} || '';
d638 1
a638 1
revision=0
@


1.9
log
@- library names don't have to start with 'lib'
- use libname.lax directory for extraction
- eliminate duplicates from dependency_libs
@
text
@d2 1
a2 1
# $OpenBSD: libtool,v 1.8 2007/11/01 17:21:25 steven Exp $
d971 3
a973 1
		if ($lf =~ m/\/\S+\/(\S+\.la)/) {
@


1.8
log
@oops, keep -f test before creating a symlink
@
text
@d2 1
a2 1
# $OpenBSD: libtool,v 1.7 2007/11/01 10:39:33 steven Exp $
d380 1
a380 1
		my @@tmpcmd = linkcmds($ofile, $odir, PROGRAM, 1, \@@objs);
d435 1
a435 1
			perform(linkcmds($sharedlib, $odir, LIBRARY, 1, \@@sobjs));
d441 1
a441 1
			perform(linkcmds($staticlib, $odir, LIBRARY, 0, ($allpicobj) ? \@@sobjs : \@@objs));
d446 5
a450 2
		my $deplibs = join ' ', @@deplibs;
		$lainfo{'dependency_libs'} = $deplibs;
d461 1
a461 1
			$lainfo{'dependency_libs'} = process_deplibs($deplibs);
d728 3
a730 1
		$d .= "/$ltdir" if ($lainfo{'installed'} eq 'no');
d736 1
a736 1
			($lib = $dlname) =~ s/^lib(\S+)\.so(\.\d+\.\d+)?$/$1/;
d738 1
a738 1
			($lib = $oldlib) =~ s/^lib(\S+)\.a$/$1/;
d742 1
d830 2
a831 1
							$k =~ s/^lib(\S+)\.so.*$/$1/;
d847 5
a851 3
		} elsif ($a && $a =~ m/(\S+\/)*lib(\S+)\.a$/) {
			if (!exists $libs{$2}) {
				$libs{$2} = $a;
d854 1
a854 1
				push @@orderedlibs, $2;
d857 3
a859 1
		} elsif ($la && $a && $a =~ m/(\S+\/)*lib(\S+)\.la$/) {
d869 1
a869 1
				if (!exists $libs{$2}) {
d871 4
a874 2
					$d .= "/$ltdir" if ($lainfo{'installed'} eq 'no');
					$libs{$2} = $d.'/'.$lainfo{'old_library'};
d897 4
a900 3
		my $la_candidate = "$d/lib$l.la";
		if (-f $la_candidate) {
			return $la_candidate;
d971 1
a971 1
		if ($lf =~ m/\/\S+\/(lib\S+\.la)/) {
d984 1
d1011 1
a1011 1
					my $xdir = "$odir/$ltdir/${fname}x/$libfile";
d1063 1
a1063 1
				my $xdir = "$odir/$ltdir/${fname}x/$libfile";
@


1.7
log
@remove symlinks before creating them.
add --config output, only one variable for now which some port uses.
@
text
@d2 1
a2 1
# $OpenBSD: libtool,v 1.6 2007/10/31 21:49:08 steven Exp $
d559 3
a561 2
		unlink "$dir/$libfile";
		symlink abs_path($f), "$dir/$libfile" or die "cannot create symlink: $!\n";
@


1.6
log
@- use .lai extension for better compatibility with gnu
- write .lai file at build time, and only install .la for shared libraries
- create symlink to .la file from the .libs directory
@
text
@d2 1
a2 1
# $OpenBSD: libtool,v 1.2 2007/10/29 11:49:52 steven Exp $
d110 1
a110 1
$gp->getoptions('config' => \&notyet,
d292 1
a292 1
		perform("cd $dstdir && ln -s $s $d");
d455 1
a455 1
		perform("cd $odir/$ltdir && ln -s ../$ofile $ofile");
d519 8
d559 2
a560 3
		if (! -f "$dir/$libfile") {
			symlink abs_path($f), "$dir/$libfile" or die "cannot create symlink: $!\n";
		}
@


1.5
log
@put the final libdir correctly in .la file from the start.
this also simplifies reworking of dependency_libs upon installation.
@
text
@a263 1
			my $deplibs = $lainfo{'dependency_libs'};
d267 1
a267 6
			$deplibs = process_deplibs($deplibs);
			$lainfo{'installed'} = 'yes';
			$lainfo{'dependency_libs'} = $deplibs;
			# XXX the new .la file should not overwrite the one
			# in the build directory, so write it under .libs
			write_la_file("$srcdir/$ltdir/$srcfile", \%lainfo);
d272 2
a273 1
			$toinstall{"$srcdir/$ltdir/$srcfile"} = "$dstdir/$dstfile";
d446 2
a447 1
		$lainfo{'dependency_libs'} = join ' ', @@deplibs;
d455 8
@


1.4
log
@- read and ignore -thread-safe option
- ignore multiple arguments for -version-info, just take the first
@
text
@d2 1
a2 1
# $OpenBSD: libtool,v 1.3 2007/10/29 15:56:56 steven Exp $
a270 4
			# XXX fix instlibdir, may be different from /usr/local/lib !
			#     strip off WRKINST somehow inside ports?
			#     start at the last /usr occurrence?
			$lainfo{'libdir'} = $instlibdir;
d452 6
a457 1
		$lainfo{'libdir'} = "$absodir/$ltdir";
d712 2
a713 1
		my $d = $lainfo{'libdir'};
d847 3
a849 1
					$libs{$2} = $lainfo{'libdir'}.'/'.$lainfo{'old_library'};
d945 5
a949 13
		if ($lf =~ m/(\/\S+)\/(lib\S+\.la)/) {
			my $dir = $1;
			my $lafile = $2;
			# XXX fix test: if the .la file can be found
			# in /usr/lib, /usr/local/lib etc, nothing should
			# be adapted.
			if ($dir =~ m/^\/usr\//) {
				$la_in_ldpath{$lafile} = 1;
			}
			if (!exists $la_in_ldpath{$lafile}) {
				print "could not find $lafile in ldpath\n" if $D;
				$lf = "$instlibdir/$lafile";
			}
@


1.3
log
@resolve symlinks during installation
@
text
@d2 1
a2 1
# $OpenBSD: libtool,v 1.2 2007/10/29 11:49:52 steven Exp $
d328 1
d336 1
a336 1
	# 	shrext
d364 3
@


1.2
log
@don't escape special characters which are surrounded by quotes.
@
text
@d2 1
a2 1
# $OpenBSD: libtool,v 1.1 2007/10/28 14:34:09 steven Exp $
d249 6
d257 2
d282 1
a282 1
			$toinstall{"$srcdir/$ltdir/$srcfile"} = "$dstdir/$srcfile";
@


1.1
log
@libtool replacement

work in progress, do not use this yet.

input from and "commit it" espie@@
@
text
@d2 1
a2 1
# $OpenBSD$
d1164 1
a1164 1
	map { $_ =~ s,(['"()<>]),\\$1,g; $_ = "\"$_\"" if $_ =~ m/[\s&<>]/ } @@$a;
@

