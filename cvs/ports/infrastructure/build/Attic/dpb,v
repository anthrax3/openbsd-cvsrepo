head	1.17;
access;
symbols
	OPENBSD_4_8:1.15.0.6
	OPENBSD_4_8_BASE:1.15
	OPENBSD_4_7:1.15.0.4
	OPENBSD_4_7_BASE:1.15
	OPENBSD_4_6:1.15.0.2
	OPENBSD_4_6_BASE:1.15
	OPENBSD_4_5:1.14.0.2
	OPENBSD_4_5_BASE:1.14
	OPENBSD_4_4:1.13.0.16
	OPENBSD_4_4_BASE:1.13
	OPENBSD_4_3:1.13.0.14
	OPENBSD_4_3_BASE:1.13
	OPENBSD_4_2:1.13.0.12
	OPENBSD_4_2_BASE:1.13
	OPENBSD_4_1:1.13.0.10
	OPENBSD_4_1_BASE:1.13
	OPENBSD_4_0:1.13.0.8
	OPENBSD_4_0_BASE:1.13
	OPENBSD_3_9:1.13.0.6
	OPENBSD_3_9_BASE:1.13
	OPENBSD_3_8:1.13.0.4
	OPENBSD_3_8_BASE:1.13
	OPENBSD_3_7:1.13.0.2
	OPENBSD_3_7_BASE:1.13
	OPENBSD_3_6:1.4.0.2
	OPENBSD_3_6_BASE:1.4;
locks; strict;
comment	@# @;


1.17
date	2010.10.28.16.38.50;	author espie;	state dead;
branches;
next	1.16;

1.16
date	2010.08.30.19.03.23;	author steven;	state Exp;
branches;
next	1.15;

1.15
date	2009.05.09.07.36.17;	author sturm;	state Exp;
branches;
next	1.14;

1.14
date	2008.10.24.16.34.19;	author sturm;	state Exp;
branches;
next	1.13;

1.13
date	2005.03.03.21.08.03;	author sturm;	state Exp;
branches;
next	1.12;

1.12
date	2005.01.30.12.37.32;	author sturm;	state Exp;
branches;
next	1.11;

1.11
date	2005.01.30.10.07.36;	author sturm;	state Exp;
branches;
next	1.10;

1.10
date	2004.12.26.07.48.46;	author sturm;	state Exp;
branches;
next	1.9;

1.9
date	2004.11.14.11.46.15;	author sturm;	state Exp;
branches;
next	1.8;

1.8
date	2004.11.14.11.25.53;	author sturm;	state Exp;
branches;
next	1.7;

1.7
date	2004.10.24.14.16.38;	author sturm;	state Exp;
branches;
next	1.6;

1.6
date	2004.09.20.20.17.33;	author sturm;	state Exp;
branches;
next	1.5;

1.5
date	2004.09.20.18.57.53;	author sturm;	state Exp;
branches;
next	1.4;

1.4
date	2004.08.24.20.30.07;	author sturm;	state Exp;
branches;
next	1.3;

1.3
date	2004.08.23.20.46.42;	author sturm;	state Exp;
branches;
next	1.2;

1.2
date	2004.08.23.19.54.11;	author sturm;	state Exp;
branches;
next	1.1;

1.1
date	2004.08.10.20.54.38;	author sturm;	state Exp;
branches;
next	;


desc
@@


1.17
log
@byebye, you served us well
@
text
@#!/usr/bin/perl -w

# $OpenBSD: dpb,v 1.16 2010/08/30 19:03:23 steven Exp $
# Copyright (c) 2004 Nikolay Sturm <sturm@@openbsd.org>.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions
# are met:
# 1. Redistributions of source code must retain the above copyright
#    notice, this list of conditions and the following disclaimer.
# 2. Redistributions in binary form must reproduce the above copyright
#    notice, this list of conditions and the following disclaimer in the
#    documentation and/or other materials provided with the distribution.
#
# THIS SOFTWARE IS PROVIDED BY THE OPENBSD PROJECT AND CONTRIBUTORS
# ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
# A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OPENBSD
# PROJECT OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
# SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
# LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
# DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
# THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
# OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
#

use strict;
use File::Temp;
use Getopt::Std;

our $MAKE = "/usr/bin/make";
our $MAKEFLAGS = "BATCH=Yes BULK=Yes TRUST_PACKAGES=Yes";
our $PORTSDIR = $ENV{'PORTSDIR'} || "/usr/ports";
our $TMPDIR = $ENV{'PKG_TMPDIR'} || '/var/tmp';
our @@SSH = ("/usr/bin/ssh", "-n");

# -A <Arch>: specify architecture of build hosts
# -b: force creation of dependency file
# -c: clean build, i.e. pkg_delete * before building a port
# -d: debug run, don't actually build any packages
# -e: perform expensive operations to get full dependency information in
#     order to optimize build order by package importance
# -F <Hosts File>: one host per line
# -L <Logdir>: use <Logdir> instead of $PORTSDIR/logs/$ARCH
# -S <SUBDIRLIST>: use <SUBDIRLIST> instead of all ports
# -s: build all packages in cwd
# -T <Dependency File>: use <Dependency File> instead of a temporary one
# -t <Timeout>: use this timeout instead of the default
our ($opt_A, $opt_b, $opt_c, $opt_d, $opt_e, $opt_F, $opt_L, $opt_S, $opt_s,
    $opt_T, $opt_t);
getopts('A:bcdeF:L:S:sT:t:');

our $ARCH;
if (defined $opt_A) {
	$ARCH = $opt_A;
} else {
	chomp($ARCH = `/usr/bin/arch -s`);
}

our $HOSTS_FILE = $opt_F || "$PORTSDIR/infrastructure/db/hosts-$ARCH";

our $LOGGER = "$PORTSDIR/infrastructure/bin/portslogger ";
$LOGGER .= $opt_L || "$PORTSDIR/logs/$ARCH";

our $TIMEOUT = $opt_t || 60;
push @@SSH, "-o ConnectTimeout=$TIMEOUT";


# per slave pid: node, port and retval
our $SLAVES = {};

# per port: slave pid
our $PORTS = {};

# dependency lists
our %depend_on = ();
our %prereqs_of = ();

# per node: fifo, host, pid, shell
our $NODES = {};

# per host: down, nodes, ssh_master
our $HOSTS = {};

our $FREE_NODES = {};

our $CHECK_HOSTS;
our $check_host_ctr = 0;

our @@dead_slaves = ();

sub child_handler()
{
	while ((my $child = waitpid(-1,1)) > 0) {
		my $sig = ($? && 255);
		my $retval = ($? >> 8);

		# host/session died, retry build
		$retval = 255 if $sig > 0 and $retval == 0;
		
		if (defined $SLAVES->{$child}) {
			$SLAVES->{$child}{retval} = $retval;
			push(@@dead_slaves, $child);
		} elsif (exists $CHECK_HOSTS->{$child}) {
			$CHECK_HOSTS->{$child} = $retval;
		}
	}
}

sub term_handler()
{
	local $SIG{CHLD} = "IGNORE";
	local $SIG{HUP}  = "IGNORE";
	local $SIG{INT}  = "IGNORE";
	local $SIG{TERM} = "IGNORE";

	foreach my $pid (keys %{$CHECK_HOSTS}, keys %{$SLAVES}) {
		kill INT => $pid;
	}
	
	clean_up(1);
}

sub my_exec($$)
{
	my ($args, $out) = @@_;
	
	$SIG{HUP}  = "DEFAULT";
	$SIG{INT}  = "DEFAULT";
	$SIG{TERM} = "DEFAULT";

	open STDOUT, '>', "$out" or
	  die "Cannot redirect STDOUT: $!";
	open STDERR, ">&STDOUT" or
	  die "Cannot redirect STDERR: $!";

	exec @@{$args};
	die "Cannot @@{$args}: $!";
}

sub reap_slaves()
{
	while (my $c = pop @@dead_slaves) {
		update_after_slave($c);
	}
}

sub mark_host_down($)
{
	my $host = shift;

	warn "*** lost $host\n";

	$HOSTS->{$host}{down} = 1;

	foreach my $node (@@{$HOSTS->{$host}{nodes}}) {
		my $nodepid = $NODES->{$node}{pid};

		if (defined $nodepid) {
			kill KILL => $nodepid ;
			child_handler();
			reap_slaves();
		}
		mark_node_down($node);
	}

	kill_ssh_master($host);
}

sub mark_node_down($)
{
	my $node = shift;
	my $nodepid = $NODES->{$node}{pid};

	# active node
	delete $NODES->{$node}{pid};
	delete $SLAVES->{$nodepid} if defined $nodepid;

	# free node
	delete $FREE_NODES->{$node};
}

sub mark_node_free($)
{
	my $node = shift;
	
	$FREE_NODES->{$node} = 1;
}

sub kill_ssh_master($)
{
	my $host = shift;
	my $ssh_mpid = $HOSTS->{$host}{ssh_master};
	
	if (defined $ssh_mpid) {
		kill INT => $ssh_mpid;
		delete $HOSTS->{$host}{ssh_master};
	}
}

sub start_ssh_master($)
{
	my $host = shift;
	my $pid = fork();
	die "fork: $!" unless defined $pid;

	if ($pid > 0) {
		# parent		
		while (not -e "$TMPDIR/ssh-$host") {
			# child died?
			return if ((my $child = waitpid($pid, 1)) > 0);
			
			sleep 1;
		}
		$HOSTS->{$host}{ssh_master} = $pid;
	} else {
		# child
		my @@args = (@@SSH, "-N", "-M", "-S", "$TMPDIR/ssh-$host",
			    "$host");
		my_exec(\@@args, "/dev/null");
	}
}

sub clear_lock($)
{
	my $fullport = shift;
	my ($port, $t) = split /,/, $fullport;

	my $flavor = "";
	if (defined $t and not $t =~ /^-/) {
		$flavor = "FLAVOR=$t";
	}

	my $lockdir = `cd ${PORTSDIR}/$port && $flavor make show=LOCKDIR`;
	chomp $lockdir;
	return if $lockdir eq "";

	my $lockname = `cd ${PORTSDIR}/$port && $flavor make show=_LOCKNAME`;
	chomp $lockname;
	return if $lockname eq "";

	system("/bin/rm -f $lockdir/$lockname.lock");
}

sub clear_packages($)
{
	my $host = shift;
	my $pid = fork();
	
	die "fork: $!" unless defined $pid;

	if ($pid > 0) {
		# parent

		# just wait for pkg_delete to finish, we don't care
		# about anything else
		waitpid($pid, 0);
	} else {
		# child
		# beware of format, might not work with /bin/sh -c otherwise
		my @@args = (@@{$NODES->{"$host%0"}{shell}},
			    "/usr/bin/sudo /usr/sbin/pkg_delete -c -q /var/db/pkg/*");
		my_exec(\@@args, "/dev/null");
	}
}

sub check_host($)
{
	my $host = shift;
	my $pid = fork();
	die "fork: $!" unless defined $pid;

	if ($pid > 0) {
		# parent
		my $begin = time();
		$CHECK_HOSTS->{$pid} = undef;
		child_handler();
		while (not defined $CHECK_HOSTS->{$pid}) {
			# give ssh a chance to timeout by itself
			if ($begin + $TIMEOUT + 2 > time()) {
				sleep(1);
			} else {
				# ssh did not terminate in time, kill it
				kill INT => $pid;
				return -1;
			}
			child_handler();
		}
		return $CHECK_HOSTS->{$pid};
	} else {
		# child
		my @@args = (@@SSH, "$host", "exit 0");
		my_exec(\@@args, "/dev/null");
	}
}

sub check_hosts()
{
	# don't check hosts in debug mode and only every so often
	# in regular mode
	return if defined $opt_d or ($check_host_ctr++ % 60 != 0);

	foreach my $host (keys %{$HOSTS}) {
		next if ($host =~ /^localhost/);
		my $retval = check_host($host);

		if ($retval == 0 and $HOSTS->{$host}{down}) {
			warn "*** $host is back\n";
			start_ssh_master($host);
			foreach my $node (@@{$HOSTS->{$host}{nodes}}) {
				mark_node_free($node);
			}
			delete $HOSTS->{$host}{down};
		} elsif ($retval !=0 and $HOSTS->{$host}{down}) {
			# host is still down, do nothing
		} elsif ($retval == 0 and not $HOSTS->{$host}{down}) {
			# host is still up
			start_ssh_master($host) if not -e "$TMPDIR/ssh-$host";
		} elsif ($retval != 0 and not $HOSTS->{$host}{down}) {
			# host is down
			mark_host_down($host);
		}
	}
}

sub update_after_slave($)
{
	my $pid = shift;
	return unless defined $SLAVES->{$pid};
	
	my $node = $SLAVES->{$pid}{node};
	my $port = $SLAVES->{$pid}{port};
	my $retval = $SLAVES->{$pid}{retval};

	delete $SLAVES->{$pid};
	delete $NODES->{$node}{pid};

	if ($retval == 0) {
		print "<== built $port\n";

		update_prereqs_of($port);
		delete $prereqs_of{$port};
	} elsif ($retval == 1) {
		warn "*** failure building $port\n";

		remove_port($port);
	} elsif ($retval == 255) {
		warn "*** build was killed, retrying $port later\n";

		clear_lock($port);
	} else {
		warn "*** unexpected return code $retval from $node "
		    . "for $port\n";

		remove_port($port);
	}
	delete $PORTS->{$port};
	mark_node_free($node);
}

sub find_free_node()
{
	while (1) {
		child_handler();
		reap_slaves();
		check_hosts();

		foreach my $n (keys %{$FREE_NODES}) {
			if (defined $FREE_NODES->{$n}) {
				delete $FREE_NODES->{$n};
				return $n;
			}
		}

		sleep(1);
	}
}

# we failed to build $port, thus no $dep can be build (recursive)
# if $dep is not build, it no longer depends on $pre
sub remove_port($);

sub remove_port($)
{
	my $port = shift;
	
	for (my $i = 0; $i <= $#{$depend_on{$port}}; $i++) {
		my $dep = ${$depend_on{$port}}[$i];
		foreach my $pre (@@{$prereqs_of{$dep}}) {
			next if $pre eq $dep;
			remove_from_list(\@@{$depend_on{$pre}}, $dep);
			$i-- if $pre eq $port;
		}
		remove_port($dep) unless $dep eq $port;
	}
	warn "*** will not build $port\n";
	delete $prereqs_of{$port};
	delete $depend_on{$port};
}

# generate full dependency information
# This is computational intensive!
sub push_dep($$);

sub push_dep($$)
{
	my ($a, $b) = @@_;
	
	foreach my $depends_on_a (@@{$depend_on{$a}}) {
		foreach my $prereq_of_b (@@{$prereqs_of{$b}}) {
			my $gotcha = 0;

			foreach my $p (@@{$prereqs_of{$depends_on_a}}) {
				if ($p eq $prereq_of_b) {
					$gotcha = 1;
					last;
				}
			}
			next unless $gotcha == 0;
			
			push_dep($depends_on_a, $prereq_of_b)
			  unless $depends_on_a eq $a and $prereq_of_b eq $b;
		}
	}
	push(@@{$prereqs_of{$a}}, $b);
	push(@@{$depend_on{$b}}, $a);
}

sub parse_dependency_file()
{
	open(my $fh, "sort -u $opt_T |") or die "Could not open $opt_T: $!";

 	while (<$fh>) {
 		chomp;
 		my ($a, $b) = split /\s+/;

		# ensure $a and $b are really port specs and not gibberish
		# category/{subcategory/}*port{\,flavor}*{\,-subpackage}
		my $borked = 0;
		foreach my $p ($a, $b) {
			if (not defined $p or $p eq "") {
				warn "*** empty port spec in deplist\n";
				$borked = 1;
				last;
			}
			if (not $p =~ /(\w*\/)+[-.\w]+(,\w+)*(,-[\w]+)*/) {
				warn "*** broken deplist entry: $p\n";
				$borked = 1;
			}
		}
		next if $borked == 1;

 		# ensure every port depends on itself, needed by build logic
 		# ports depending on the key
 		$depend_on{$a} = [$a] unless defined $depend_on{$a};
 		$depend_on{$b} = [$b] unless defined $depend_on{$b};
 		# ports, the key depends on
 		$prereqs_of{$a} = [$a] unless defined $prereqs_of{$a};
 		$prereqs_of{$b} = [$b] unless defined $prereqs_of{$b};

		if ($a ne $b) {
			if (defined $opt_e) {
				push_dep($a, $b);
			} else {
				push(@@{$prereqs_of{$a}}, $b);
				push(@@{$depend_on{$b}}, $a);
			}
		}
 	}
	close($fh);
}

sub parse_hosts_file()
{
	my $sysctl = "/sbin/sysctl -n hw.ncpu";

	open(my $fh, "<", $HOSTS_FILE) or die "Could not open $HOSTS_FILE: $!\n";

	while (<$fh>) {
		chomp;
		my $host = $_;
		my ($ncpu, $local);
		
		if (/^localhost/) {
			$ncpu = `$sysctl`;
			$local = 1;
		} else {
			$ncpu = `@@SSH $host $sysctl`;
			$local = 0
		}

		if (not defined $ncpu or $ncpu eq "") {
			warn "*** host $host does not answer, not using it\n";
			next;
		} elsif ($ncpu > 1 and defined $opt_c) {
			$ncpu = 1;
			warn "*** only using one node on $host due to '-c'\n";
		}

		$HOSTS->{$host}{nodes} = ();

		for (my $i = 0; $i < $ncpu; $i++) {
			my $node = "$host%$i";

			push @@{$HOSTS->{$host}{nodes}}, $node;
			
			mark_node_free($node);
			$NODES->{$node}{fifo} =
			  "$TMPDIR/dpb-$node.log";
			$NODES->{$node}{host} = $host;
			if ($local == 1) {
				@@{$NODES->{$node}{shell}} = ("/bin/sh", "-c");
			} else {
				@@{$NODES->{$node}{shell}} =
				  (@@SSH, "-S", "$TMPDIR/ssh-$host", "$host");
			}
		}
	}
	close($fh);
}

sub find_circular_deps()
{
	foreach my $base_port (keys %prereqs_of) {
		# port might have been removed due to circular dependencies
		next if not exists $prereqs_of{$base_port};

		my @@backlog = ();
		my %checked = ();
		foreach my $p (@@{$prereqs_of{$base_port}}) {
			push @@backlog, $p unless $p eq $base_port;
		}

		while ($#backlog >= 0) {
			my $p = shift @@backlog;
			next if exists $checked{$p};

			if ($p eq $base_port) {
				warn "*** circular dependency for $base_port\n";
				remove_port($base_port);
			}
			$checked{$p} = 1;
			foreach my $q (@@{$prereqs_of{$p}}) {
				push @@backlog, $q unless $q eq $p;
			}
		}
	}
}

sub build_package($$$$)
{
	my ($node, $port, $flavor, $fullport) = @@_;

	my $pid = fork();
	die "fork: $!" unless defined $pid;
	
	if ($pid > 0) {
		# parent
		$SLAVES->{$pid} = {};
		$SLAVES->{$pid}{node} = $node;
		$SLAVES->{$pid}{port} = $fullport;
		$SLAVES->{$pid}{retval} = undef;
		$PORTS->{$fullport} = $pid;
		$NODES->{$node}{pid} = $pid;

		return;
	} else {
		# child
		$SIG{HUP}  = "DEFAULT";
		$SIG{INT}  = "DEFAULT";
		$SIG{TERM} = "DEFAULT";
		$0 = "dpb [slave] - $port";

		print "==> building $port";
		print ", FLAVOR \"$flavor\"" if defined $flavor;
		print " on $node\n";

		if (defined $opt_d) {
			sleep(1);
		} else {
			my $arg = "cd $PORTSDIR/$port && ";
			$arg .= "FLAVOR=\"$flavor\" " if defined $flavor;
			# if we lost contact to the node, a build of this
			# port might still be running; cleaning kills it
			$arg .= "$MAKE $MAKEFLAGS clean package";
			my @@args = (@@{$NODES->{$node}{shell}}, $arg);
			
			start_logger($node);
			clear_packages($NODES->{$node}{host}) if defined $opt_c;
			my_exec(\@@args, "$NODES->{$node}{fifo}");
		}
		exit 0;
	}
}

sub update_prereqs_of($)
{
	my $port = shift;

	return unless defined @@{$depend_on{$port}};

	# remove $port from lists of prerequisites
	foreach my $depending (@@{$depend_on{$port}}) {
		next unless defined @@{$prereqs_of{$depending}};
		remove_from_list(\@@{$prereqs_of{$depending}}, $port);
	}
}

sub remove_from_list(\@@$)
{
	my ($list, $entry) = @@_;

	for (my $i = 0; $i <= $#{$list}; $i++) {
		if (${$list}[$i] eq $entry) {
			splice(@@{$list}, $i, 1);
			$i--;
		}
	}
}

sub start_logger()
{
	my $node = shift;
	my $fifo = $NODES->{$node}{fifo};

	unless (-p $fifo) {
		system("mkfifo $fifo") and
		  die "Cannot create $fifo: $!";
	}
	
	my $pid = fork();
	die "fork: $!" unless defined $pid;

	if ($pid > 0) {
		# parent
		
		return;
	} else {
		# child
		# dies on its own on EOF
		my @@args = ("$LOGGER < $fifo");
		my_exec(\@@args, "/dev/null");
	}
}

sub clean_up($)
{
	# only remove self generated dependency file
	unlink($opt_T) if ref $opt_T;

	foreach my $node (keys %{$NODES}) {
		kill_ssh_master($NODES->{$node}{host});
		unlink($NODES->{$node}{fifo}) if -p $NODES->{$node}{fifo};

		# is there still anything building on this node?
		my $pid = $NODES->{$node}{pid};
		next if not defined $pid;
		my $port = $SLAVES->{$pid}{port};
		local $SIG{CHLD} = "DEFAULT";
		clear_lock($port);
	}

	exit(shift);
}

# MAIN
$SIG{HUP}  = \&term_handler;
$SIG{INT}  = \&term_handler;
$SIG{TERM} = \&term_handler;
$0 = "dpb [master]";

# collect dependency data
if (defined $opt_b or not defined $opt_T or not -f $opt_T) {
	my $arg = "cd $PORTSDIR && $MAKE ";

	unless (defined $opt_T) {
		$opt_T = new File::Temp( TEMPLATE => 'all-depends.XXXXXXXXXX',
					 DIR => $TMPDIR,
					 UNLINK => 0 );
	}

	if (defined $opt_s and defined $opt_S) {
		die "-s and -S are mutually exclusive!";
	} elsif (defined $opt_s) {
		# cwd is somewhere in the ports tree, just build from here
		$arg = "$MAKE ";
	} elsif (defined $opt_S) {
		die "SUBDIRLIST $opt_S not found!" unless (-f $opt_S);
		$arg .= "SUBDIRLIST=$opt_S ";
	}

	$arg .= "ECHO_MSG=: all-dir-depends > $opt_T";
	
	print "==> creating dependency file\n";
	system($arg) and die "$MAKE all-dir-depends: $!";
} else {
	print "==> using dependency file $opt_T\n";
}

parse_dependency_file();
parse_hosts_file();
find_circular_deps();

check_hosts();

my @@keys_prereqs = (keys %prereqs_of);
my @@keys_PORTS = ();
do {
	# sort ports by their importance, i.e. by the number of other
	# ports depending on them
	foreach my $k (sort {$#{$depend_on{$b}} <=> $#{$depend_on{$a}}}
	    @@keys_prereqs) {
		# only compile ports that don't have unbuilt dependencies
		if ($#{$prereqs_of{$k}} == 0) {
			my $node = find_free_node();
			my ($port, $flavor);
			my @@spec = split(/,/, $k);

			# do not try to build multiple SUBPACKAGEs of the same
			# port in parallel
			my $build_conflict = 0;
			
			$port = $spec[0];
			# a build for a different subpackage might be running
			foreach (keys %{$PORTS}) {
				my @@key_spec = split(/,/);
				if ($port eq $key_spec[0]) {
					$build_conflict = 1;
				}
			}
			for (my $i = 1; $i <= $#spec; $i++) {
				if (not $spec[$i] =~ /^-/ and defined $flavor) {
					$flavor = join(" ", $flavor, $spec[$i]);
				} elsif (not $spec[$i] =~ /^-/) {
					$flavor = $spec[$i];
				}
			}

			if ($build_conflict == 0) {
				build_package($node, $port, $flavor, $k);
			} else {
				mark_node_free($node);
				next;
			}

			last;
		}
	}

	check_hosts();

	child_handler();
	reap_slaves();

	# create new key set, taking currently building ports into account
	@@keys_PORTS = (keys %{$PORTS});
	@@keys_prereqs = ();
	foreach my $k (keys %prereqs_of) {
		push(@@keys_prereqs, $k) unless defined $PORTS->{$k};
	}
	
	sleep(1);
	
} while ($#keys_prereqs >= 0 or $#keys_PORTS >= 0);

print "==> done, cleaning up\n";
clean_up(0);

@


1.16
log
@adjust portslogger path
@
text
@d3 1
a3 1
# $OpenBSD: dpb,v 1.14 2008/10/24 16:34:19 sturm Exp $
@


1.15
log
@add some code to help find circular dependencies
@
text
@d63 1
a63 1
our $LOGGER = "$PORTSDIR/infrastructure/build/portslogger ";
@


1.14
log
@BIN_PACKAGES is obsolete
from  Mikolaj Kucharski
@
text
@d3 1
a3 1
# $OpenBSD: dpb,v 1.13 2005/03/03 21:08:03 sturm Exp $
d523 28
d703 1
@


1.13
log
@fix cleanup code

noticed by pval@@
@
text
@d3 1
a3 1
# $OpenBSD: dpb,v 1.12 2005/01/30 12:37:32 sturm Exp $
d33 1
a33 1
our $MAKEFLAGS = "BATCH=Yes BIN_PACKAGES=Yes BULK=Yes TRUST_PACKAGES=Yes";
@


1.12
log
@- remove lockfiles when a host dies or dpb is killed (the ports don't do
  it in these cases)
- remove an unused variable
- clean up warning messages
@
text
@d3 1
a3 1
# $OpenBSD: dpb,v 1.11 2005/01/30 10:07:36 sturm Exp $
a624 3
		my $pid = $NODES->{$node}{pid};
		my $port = $SLAVES->{$pid}{port};

d628 4
@


1.11
log
@tear down the ssh master session only after killing all node sessions

this solves the problem of ports being marked "built" after the node
building it was lost
@
text
@d3 1
a3 1
# $OpenBSD: dpb,v 1.10 2004/12/26 07:48:46 sturm Exp $
a86 1
our @@DOWN_HOSTS = ();
a155 1
	push(@@DOWN_HOSTS, $host);
d225 21
d345 1
a345 1
		print "<== failure building $port\n";
d349 3
a351 1
		warn "*** $node died with signal, retrying $port later.\n";
d353 2
a354 2
		warn "*** Unexpected return code $retval from $node "
		    . "for $port.\n";
d494 1
a494 1
			warn "*** Host $host does not answer, not using it.\n";
d498 1
a498 1
			warn "*** Only using one node on $host due to '-c'\n";
d556 3
a558 1
			$arg .= "$MAKE $MAKEFLAGS package";
d625 3
d630 3
@


1.10
log
@in parse_dependency_file() make sure, we really read port specs and
not some gibberish like error messages or so
@
text
@d3 1
a3 1
# $OpenBSD: dpb,v 1.6 2004/09/20 20:17:33 sturm Exp $
a156 1
	kill_ssh_master($host);
d169 2
d330 1
a330 1
		warn "*** $node died on signal, retrying $port later.\n";
@


1.9
log
@improved SMP handling
- automatically detect number of cpus per host
- differentiate between hosts and nodes
  => each cpu is its own node
  => ports are build on nodes now
  => multiple host entries are no longer necessary for smp machines
@
text
@d416 16
@


1.8
log
@a little cleanup in preparation for improved SMP handling
print() -> warn() where useful
@
text
@d3 1
a3 1
# $OpenBSD: dpb,v 1.7 2004/10/24 14:16:38 sturm Exp $
d70 1
a70 1
# per slave pid: host, port and retval
d73 2
a74 2
# indexed by port
our %childpid = ();
d80 7
a86 1
our @@FREE_HOSTS = ();
a88 4
our %FIFO = ();
our %SHELL = ();
our %SSH_MASTER = ();

d156 1
d159 11
d172 1
a172 1
sub mark_as_free($)
d174 16
a189 1
	push(@@FREE_HOSTS, shift);
d195 1
d197 3
a199 3
	if (defined $SSH_MASTER{$host}) {
		kill INT => $SSH_MASTER{$host};
		delete $SSH_MASTER{$host};
d217 1
a217 1
		$SSH_MASTER{$host} = $pid;
d242 2
a243 2
		my @@args = (@@{$SHELL{$host}},
		    "/usr/bin/sudo /usr/sbin/pkg_delete -c -q /var/db/pkg/*");
d284 2
a285 3
	# any host back up?
	for (my $i = 0; $i <= $#DOWN_HOSTS; $i++) {
		my $host = $DOWN_HOSTS[$i];
d288 1
a288 1
		if ($retval == 0) {
a289 1
			mark_as_free($host);
d291 8
a298 17
			splice(@@DOWN_HOSTS, $i, 1);
			$i--;
		}
	}

	# free hosts still alive?
	for (my $i = 0; $i <= $#FREE_HOSTS; $i++) {
		my $host = $FREE_HOSTS[$i];
		next if ($host =~ /^localhost/);
		my $retval = check_host($host);

		if ($retval != 0) {
			mark_host_down($host);
			splice(@@FREE_HOSTS, $i, 1);
			$i--;
			next;
		} elsif ($retval == 0) {
d300 2
a301 11
		}
	}

	# building hosts all still alive?
	foreach my $pid (keys %{$SLAVES}) {
		my $host = $SLAVES->{$pid}{host};
		next if ($host =~ /^localhost/);
		my $retval = check_host($host);

		if ($retval != 0) {
			my $port = $SLAVES->{$pid}{port};
a302 2
			delete $childpid{$port};
			delete $SLAVES->{$pid};
d312 1
a312 1
	my $host = $SLAVES->{$pid}{host};
d317 1
d329 1
a329 4
		delete $childpid{$port};
		mark_host_down($host);

		return;
d331 1
a331 1
		warn "*** Unexpected return code $retval from $host "
d336 2
a337 2
	delete $childpid{$port};
	mark_as_free($host);
d340 1
a340 1
sub find_free_host()
d342 1
a342 7
	child_handler();
	reap_slaves();
	check_hosts();

	while (@@FREE_HOSTS == 0) {
		sleep(1);

d346 9
a355 1
	return pop @@FREE_HOSTS;
d438 2
d445 17
d463 1
a463 1
		mark_as_free($host);
d465 15
a479 5
		if (/^localhost/) {
			@@{$SHELL{$host}} = ("/bin/sh", "-c");
		} else {
			@@{$SHELL{$host}} =
			  (@@SSH, "-S", "$TMPDIR/ssh-$host", "$host");
a480 1
		$FIFO{$host} = "$TMPDIR/dpb-$host.log";
d487 1
a487 1
	my ($host, $port, $flavor, $fullport) = @@_;
d495 1
a495 1
		$SLAVES->{$pid}{host} = $host;
d498 2
a499 1
		$childpid{$fullport} = $pid;
d511 1
a511 1
		print " on $host\n";
d519 1
a519 1
			my @@args = (@@{$SHELL{$host}}, $arg);
d521 3
a523 3
			start_logger($host);
			clear_packages($host) if defined $opt_c;
			my_exec(\@@args, "$FIFO{$host}");
d556 2
a557 1
	my $host = shift;
d559 3
a561 3
	unless (-p $FIFO{$host}) {
		system("mkfifo $FIFO{$host}") and
		  die "Cannot create $FIFO{$host}: $!";
d574 1
a574 1
		my @@args = ("$LOGGER < $FIFO{$host}");
d584 3
a586 6
	foreach my $h (keys %SSH_MASTER) {
		kill_ssh_master($h);
	}

	foreach my $h (keys %FIFO) {
		unlink($FIFO{$h});
d632 1
a632 1
my @@keys_childpid = ();
d640 1
a640 1
			my $host = find_free_host();
d650 1
a650 1
			foreach (keys %childpid) {
d665 1
a665 1
				build_package($host, $port, $flavor, $k);
d667 2
a668 1
				mark_as_free($host);
d681 1
a681 1
	@@keys_childpid = (keys %childpid);
d684 1
a684 1
		push(@@keys_prereqs, $k) unless defined $childpid{$k};
d689 1
a689 1
} while ($#keys_prereqs >= 0 or $#keys_childpid >= 0);
@


1.7
log
@new option -c for "clean builds", i.e. remove all installed packages
before building a new one; don't use this when building multiple packages
on one host
@
text
@d3 1
a3 1
# $OpenBSD: dpb,v 1.6 2004/09/20 20:17:33 sturm Exp $
a31 21
our @@FREE_HOSTS = ();
our @@DOWN_HOSTS = ();
our $CHECK_HOSTS;
our $check_host_ctr = 0;

# indexed by child pid
our $CHILD;
use constant {
	HOST => 0,
	PORT => 1,
	RETVAL => 2
};

# indexed by port
our %childpid = ();

# dependency lists
our %depend_on = ();
our %prereqs_of = ();

chomp(my $ARCH = `/usr/bin/arch -s`);
d36 1
a36 6
our $TIMEOUT = 60;
our @@SSH = ("/usr/bin/ssh", "-n", "-o ConnectTimeout=$TIMEOUT");

our %FIFO = ();
our %SHELL = ();
our %SSH_MASTER = ();
d50 2
a51 1
our ($opt_A, $opt_b, $opt_c, $opt_d, $opt_e, $opt_F, $opt_L, $opt_S, $opt_s, $opt_T, $opt_t);
d54 8
a61 1
$ARCH = $opt_A if defined $opt_A;
d63 2
a64 1
$opt_F = "$PORTSDIR/infrastructure/db/hosts-$ARCH" unless defined $opt_F;
d66 2
a67 2
$opt_L = "$PORTSDIR/logs/$ARCH" unless defined $opt_L;
our $LOGGER = "$PORTSDIR/infrastructure/build/portslogger $opt_L";
a68 1
$TIMEOUT = $opt_t if defined $opt_t;
d70 21
a90 1
our @@dead_children = ();
d101 3
a103 3
		if (defined $CHILD->{$child}) {
			$CHILD->{$child}[RETVAL] = $retval;
			push(@@dead_children, $child);
d117 2
a118 2
	foreach my $h (keys %{$CHECK_HOSTS}, keys %{$CHILD}) {
		kill INT => $h;
d141 1
a141 1
sub reap_children()
d143 2
a144 2
	while (my $c = pop @@dead_children) {
		update_after_child($c);
d148 1
a148 1
sub mark_as_down($)
d151 3
a153 1
	print "*** lost $host\n";
d260 1
a260 1
			print "*** $host is back\n";
d275 1
a275 1
			mark_as_down($host);
d285 2
a286 2
	foreach my $pid (keys %{$CHILD}) {
		my $host = $CHILD->{$pid}[HOST];
d291 2
a292 2
			my $port = $CHILD->{$pid}[PORT];
			mark_as_down($host);
d294 1
a294 1
			delete $CHILD->{$pid};
d299 1
a299 1
sub update_after_child($)
d302 1
a302 1
	return unless defined $CHILD->{$pid};
d304 3
a306 3
	my $host = $CHILD->{$pid}[HOST];
	my $port = $CHILD->{$pid}[PORT];
	my $retval = $CHILD->{$pid}[RETVAL];
d308 1
a308 1
	delete $CHILD->{$pid};
d321 1
a321 1
		mark_as_down($host);
d325 1
a325 1
		print "*** Unexpected return code $retval from $host "
d337 1
a337 1
	reap_children();
d344 1
a344 1
		reap_children();
d367 1
a367 1
	print "*** will not build $port\n";
d430 1
a430 1
	open(my $fh, "<", $opt_F) or die "Could not open $opt_F: $!";
d458 4
a461 4
		$CHILD->{$pid} = [];
		$CHILD->{$pid}[HOST] = $host;
		$CHILD->{$pid}[PORT] = $fullport;
		$CHILD->{$pid}[RETVAL] = undef;
d642 1
a642 1
	reap_children();
@


1.6
log
@$OpenBSD$
@
text
@d3 1
a3 1
# $OpenBSD$
d66 1
d76 2
a77 2
our ($opt_A, $opt_b, $opt_d, $opt_e, $opt_F, $opt_L, $opt_S, $opt_s, $opt_T, $opt_t);
getopts('A:bdeF:L:S:sT:t:');
d192 22
d481 1
@


1.5
log
@- use sh on localhost* and don't check_host() on these
  => you have an SMP machine, use localhost0, localhost1, ...
- for remote sessions, use ssh multiplexing, this speeds up a dpb
  restart by about 1/4 - 1/3
- new option '-s', which starts building in cwd
  => use 'dpb -s' instead of 'make package'
  => mostly useful for SMP machines or if you have your cluster powered
     on all the time
- '-b' now forces creation of the dependency file, if it doesn't exist,
  it is created automatically
- check signals on returning ssh sessions to notice which ones really
  succeeded and which ones where killed
@
text
@d2 2
a3 1
#
@


1.4
log
@wrong order when redirecting STDOUT/STDERR

ok pval
@
text
@a51 1
our %FIFO = ();
d59 4
d64 1
a64 1
# -b: build dependency file
d66 2
a67 1
# -e: perform expensive operations to get full dependency information
d71 1
d74 2
a75 2
our ($opt_A, $opt_b, $opt_d, $opt_e, $opt_F, $opt_L, $opt_S, $opt_T, $opt_t);
getopts('A:bdeF:L:S:T:t:');
a83 6
unless (defined $opt_T) {
	$opt_T = new File::Temp( TEMPLATE => 'all-depends.XXXXXXXXXX',
				 DIR => $TMPDIR,
				 UNLINK => 0 );
}

d91 6
d98 1
a98 1
			$CHILD->{$child}[RETVAL] = ($? >> 8);
d101 1
a101 1
			$CHECK_HOSTS->{$child} = ($? >> 8);
d109 1
d120 17
d148 1
d157 33
d215 2
a216 5
		$SIG{INT}  = "DEFAULT";
		$SIG{TERM} = "DEFAULT";

		exec @@SSH, $host, "exit 0";
		die "exec(): $!";
d230 1
d234 1
d243 1
d245 1
d250 3
d259 1
d406 11
a416 2
		mark_as_free($_);
		$FIFO{$_} = "$TMPDIR/dpg-$_.log";
d439 1
d454 2
a455 1

d457 1
a457 8

			open STDOUT, '>', "$FIFO{$host}" or
			  die "Cannot redirect STDOUT: $!";
			open STDERR, ">&STDOUT" or
			  die "Cannot redirect STDERR: $!";

			exec @@SSH, $host, $arg;
			die "exec(): $!";
d507 2
a508 5
		$SIG{INT}  = "DEFAULT";
		$SIG{TERM} = "DEFAULT";

		exec("$LOGGER < $FIFO{$host} > /dev/null 2>&1");
		die "Failed to start logger: $!";
d516 5
d529 1
d535 1
a535 1
if (defined $opt_b) {
d538 12
a549 1
	if (defined $opt_S) {
@


1.3
log
@raise default timeout to 1 minute

requested by pval@@
@
text
@d382 3
a388 2

			start_logger($host);
@


1.2
log
@improve reliability:
- don't invoke intermediate shells on exec(), allowing to actually kill children
- when we are going down, only kill remaining children, not the whole pgrp
- don't use a SIGCHLD handler, but call waitpid explicitly at the right places
- exit(1) in case of an error

others:
- a little cleanup
- new option -t <timeout>

ok pval@@
@
text
@d57 1
a57 1
our $TIMEOUT = 10;
@


1.1
log
@Distributed Package Build is a helper script to permit several hosts
working together in doing a bulk package build.

ok pvalchev@@, espie@@
@
text
@d58 1
a58 1
our $SSH = "/usr/bin/ssh -n -o ConnectTimeout=$TIMEOUT";
d68 3
a70 2
our ($opt_A, $opt_b, $opt_d, $opt_e, $opt_F, $opt_L, $opt_S, $opt_T);
getopts('A:bdeF:L:S:T:');
d85 2
d101 13
d123 3
a125 1
	push(@@DOWN_HOSTS, shift);
d143 1
d150 1
a150 1
				kill('TERM', $pid);
d153 1
a157 1
		$SIG{CHLD} = "DEFAULT";
d161 2
a162 2
		exec("$SSH $host exit 0 > /dev/null 2>&1");
		die("exec(): $!");
a188 1
			print "*** lost $host\n";
a201 1
			print "*** lost $host\n";
d212 2
a229 2
		print "<== host $host is down\n";

d246 1
d252 2
a367 1
		$SIG{CHLD} = "DEFAULT";
d379 1
a379 1
			my $arg = "$SSH $host 'cd $PORTSDIR/$port && ";
d381 5
a385 1
			$arg .= "$MAKE $MAKEFLAGS package' > $FIFO{$host} 2>&1";
d389 2
a390 2
			exec($arg);
			die("exec(): $!");
d427 1
a427 1
		  die("Cannot create $FIFO{$host}: $!");
d431 1
a431 1
	die("fork: $!") unless defined $pid;
d439 1
a439 1
		$SIG{CHLD} = "DEFAULT";
d444 1
a444 1
		die("Failed to start logger: $!");
d448 1
a448 1
sub clean_up()
a449 5
	$SIG{INT}  = "IGNORE";
	$SIG{TERM} = "IGNORE";

	kill('TERM', -$$);

d456 1
a456 1
	exit(0);
d460 2
a461 3
# collect dependency data
$SIG{INT}  = \&clean_up;
$SIG{TERM} = \&clean_up;
d464 1
d469 1
a469 1
		die("SUBDIRLIST $opt_S not found!") unless (-f $opt_S);
a483 1
$SIG{CHLD} = \&child_handler;	
d529 3
a532 1
	check_hosts();
d545 2
a546 1
clean_up();
@

