head	1.40;
access;
symbols
	OPENBSD_6_1:1.37.0.2
	OPENBSD_6_1_BASE:1.37
	OPENBSD_6_0:1.34.0.8
	OPENBSD_6_0_BASE:1.34
	OPENBSD_5_9:1.34.0.4
	OPENBSD_5_9_BASE:1.34
	OPENBSD_5_8:1.34.0.6
	OPENBSD_5_8_BASE:1.34
	OPENBSD_5_7:1.34.0.2
	OPENBSD_5_7_BASE:1.34
	OPENBSD_5_6:1.33.0.2
	OPENBSD_5_6_BASE:1.33
	OPENBSD_5_5:1.32.0.6
	OPENBSD_5_5_BASE:1.32
	OPENBSD_5_4:1.32.0.4
	OPENBSD_5_4_BASE:1.32
	OPENBSD_5_3:1.32.0.2
	OPENBSD_5_3_BASE:1.32
	OPENBSD_5_2:1.30.0.4
	OPENBSD_5_2_BASE:1.30
	OPENBSD_5_1_BASE:1.30
	OPENBSD_5_1:1.30.0.2
	OPENBSD_5_0:1.10.0.2
	OPENBSD_5_0_BASE:1.10
	OPENBSD_4_9:1.8.0.2
	OPENBSD_4_9_BASE:1.8;
locks; strict;
comment	@# @;


1.40
date	2017.04.11.16.02.15;	author espie;	state Exp;
branches;
next	1.39;
commitid	PA1N9356UjatnKj3;

1.39
date	2017.04.10.11.46.21;	author sthen;	state Exp;
branches;
next	1.38;
commitid	BLsh88fJB8thZTwY;

1.38
date	2017.04.09.19.30.09;	author espie;	state Exp;
branches;
next	1.37;
commitid	e5zVmsV1yCq1f9Vb;

1.37
date	2017.02.11.12.52.58;	author espie;	state Exp;
branches;
next	1.36;
commitid	AmOHHtFCRsgPGxJS;

1.36
date	2017.01.25.14.16.46;	author espie;	state Exp;
branches;
next	1.35;
commitid	DUPUrQYqRQa6Pp1o;

1.35
date	2016.09.14.15.06.53;	author espie;	state Exp;
branches;
next	1.34;
commitid	Ol4H96wBmxGvnk6k;

1.34
date	2015.02.09.09.47.31;	author espie;	state Exp;
branches;
next	1.33;
commitid	s2J6IaRybOdWKz8B;

1.33
date	2014.07.09.11.26.11;	author espie;	state Exp;
branches;
next	1.32;
commitid	Hk8PSAToaDdq3YqM;

1.32
date	2013.02.07.08.19.54;	author zhuk;	state Exp;
branches;
next	1.31;

1.31
date	2013.02.07.08.00.10;	author zhuk;	state Exp;
branches;
next	1.30;

1.30
date	2011.12.01.11.20.19;	author espie;	state Exp;
branches;
next	1.29;

1.29
date	2011.11.27.17.37.47;	author espie;	state Exp;
branches;
next	1.28;

1.28
date	2011.11.27.17.31.54;	author espie;	state Exp;
branches;
next	1.27;

1.27
date	2011.11.27.16.50.19;	author espie;	state Exp;
branches;
next	1.26;

1.26
date	2011.11.27.16.40.58;	author espie;	state Exp;
branches;
next	1.25;

1.25
date	2011.11.27.16.15.52;	author espie;	state Exp;
branches;
next	1.24;

1.24
date	2011.11.27.14.49.42;	author espie;	state Exp;
branches;
next	1.23;

1.23
date	2011.11.27.13.39.11;	author espie;	state Exp;
branches;
next	1.22;

1.22
date	2011.11.27.13.29.38;	author espie;	state Exp;
branches;
next	1.21;

1.21
date	2011.11.27.13.10.36;	author espie;	state Exp;
branches;
next	1.20;

1.20
date	2011.11.27.12.42.40;	author espie;	state Exp;
branches;
next	1.19;

1.19
date	2011.11.27.12.29.10;	author espie;	state Exp;
branches;
next	1.18;

1.18
date	2011.11.27.12.24.06;	author espie;	state Exp;
branches;
next	1.17;

1.17
date	2011.11.27.12.09.17;	author espie;	state Exp;
branches;
next	1.16;

1.16
date	2011.11.27.11.50.26;	author espie;	state Exp;
branches;
next	1.15;

1.15
date	2011.11.27.11.37.58;	author espie;	state Exp;
branches;
next	1.14;

1.14
date	2011.11.27.11.29.33;	author espie;	state Exp;
branches;
next	1.13;

1.13
date	2011.11.26.12.02.54;	author espie;	state Exp;
branches;
next	1.12;

1.12
date	2011.11.16.10.37.35;	author espie;	state Exp;
branches;
next	1.11;

1.11
date	2011.10.17.10.18.16;	author espie;	state Exp;
branches;
next	1.10;

1.10
date	2011.04.25.23.01.03;	author sthen;	state Exp;
branches;
next	1.9;

1.9
date	2011.03.07.10.06.36;	author espie;	state Exp;
branches;
next	1.8;

1.8
date	2011.01.26.12.53.46;	author ajacoutot;	state Exp;
branches;
next	1.7;

1.7
date	2010.12.24.10.31.40;	author espie;	state Exp;
branches;
next	1.6;

1.6
date	2010.09.15.09.36.57;	author espie;	state Exp;
branches;
next	1.5;

1.5
date	2010.09.13.14.38.05;	author espie;	state Exp;
branches;
next	1.4;

1.4
date	2010.08.20.17.03.36;	author espie;	state Exp;
branches;
next	1.3;

1.3
date	2010.08.20.15.29.41;	author espie;	state Exp;
branches;
next	1.2;

1.2
date	2010.08.20.15.22.21;	author espie;	state Exp;
branches;
next	1.1;

1.1
date	2010.08.20.13.50.11;	author espie;	state Exp;
branches;
next	;


desc
@@


1.40
log
@forgot synopsis
@
text
@#!/usr/bin/perl

# $OpenBSD: check-lib-depends,v 1.39 2017/04/10 11:46:21 sthen Exp $
# Copyright (c) 2004-2010 Marc Espie <espie@@openbsd.org>
#
# Permission to use, copy, modify, and distribute this software for any
# purpose with or without fee is hereby granted, provided that the above
# copyright notice and this permission notice appear in all copies.
#
# THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
# ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
# OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

use strict;
use warnings;
my $ports1;
use FindBin;
BEGIN {
	$ports1 = $ENV{PORTSDIR} || '/usr/ports';
}
use lib ("$ports1/infrastructure/lib", "$FindBin::Bin/../lib");

use File::Spec;
use OpenBSD::PackingList;
use OpenBSD::SharedLibs;
use OpenBSD::LibSpec;
use OpenBSD::Temp;
use OpenBSD::AddCreateDelete;
use OpenBSD::Getopt;
use OpenBSD::FileSource;
use OpenBSD::BinaryScan;
use OpenBSD::Recorder;
use OpenBSD::Issue;

package Logger;
sub new
{
	my ($class, $dir) = @@_;
	require File::Path;

	File::Path::make_path($dir);
	bless {dir => $dir}, $class;
}

sub log
{
	my ($self, $name) = @@_;
	$name =~ s/^\/*//;
	$name =~ s/\//./g;
	return "$self->{dir}/$name";
}

sub open
{
	my ($self, $name) = @@_;
	open my $fh, '>>', $self->log($name);
	return $fh;
}

package MyFile;
our @@ISA = qw(OpenBSD::PackingElement::FileBase);

sub fullname
{
	my $self = shift;
	return $self->{name};
}

package OpenBSD::PackingElement;
sub scan_binaries_for_libs
{
}

sub find_libs
{
}

sub register_libs
{
}

sub depwalk
{
}

sub find_binaries
{
}

sub find_perl
{
}

package OpenBSD::PackingElement::Wantlib;
sub register_libs
{
	my ($item, $t) = @@_;
	my $name = $item->{name};
	$name =~ s/^(.*\/)?(.*)\.(\d+)\.\d+$/$2.$3/;
	$t->{$name} = 1;
}

package OpenBSD::PackingElement::Lib;

sub register_libs
{
	my ($item, $t) = @@_;
	if ($item->fullname =~ m/^(.*\/)?lib(.*)\.so\.(\d+)\.\d+$/) {
		$t->{"$2.$3"} = 2;
	}
}

package OpenBSD::PackingElement::FileBase;

sub find_libs
{
	my ($item, $dest, $dump) = @@_;
	my $fullname = $item->fullname;
	for my $lib ($dump->libraries($fullname)) {
		$dest->record($lib, $fullname);
	}
}

sub scan_binaries_for_libs
{
	my ($item, $state) = @@_;

	if (my $fullname = $item->is_binary) {
		$state->{scanner}->retrieve_and_scan_binary($item, $fullname);
		if ($item->is_perl_so) {
			$state->{scanner}->record_libs($fullname, 
			    $state->perllibs);
		}
	} else {
		$state->{scanner}->dont_scan($item);
	}
}

sub is_binary
{
	my $item = shift;
	my $fullname = File::Spec->canonpath($item->fullname);

	my $linux_bin = 0;
	if ($fullname =~ m,^/usr/local/emul/(?:redhat|fedora)/,) {
		$linux_bin = 1;
	}
	if ($linux_bin || $item->{symlink} || $item->{link}) {
		return 0;
	} else {
		return $fullname;
	}
}

sub is_perl_so
{
	my $item = shift;
	my $fullname = File::Spec->canonpath($item->fullname);

	if ($fullname =~ m,/libdata/perl5/.*\.so$,) {
		return $fullname;
	} else {
		return 0;
	}
}

sub find_binaries
{
	my ($item, $h) = @@_;
	if ($item->is_binary) {
		$h->{$item->name} = $item;
	}
}

sub find_perl
{
	my ($item, $state) = @@_;
	if (my $fullname = $item->is_perl_so) {
		$state->{scanner}->record_libs($fullname, $state->perllibs);
	}
}

package OpenBSD::PackingElement::Dependency;

sub depwalk
{
	my ($self, $h) = @@_;
	$h->{$self->{def}} = $self->{pkgpath};
}

package CheckLibDepends::State;
our @@ISA = qw(OpenBSD::AddCreateDelete::State);


sub handle_options
{
	my $state = shift;

	$state->{opt}{i} = 0;
	$state->{opt}{S} = sub {
		$state->{subst}->parse_option(shift);
	};
	$state->SUPER::handle_options('oid:D:fB:qS:s:O:',
		'[-fiomqx] [-B destdir] [-d pkgrepo] [-O dest] [-S var=value] [-s source]');

	$state->{destdir} = $state->opt('B');
	if ($state->opt('O')) {
		open $state->{dest}, '>', $state->opt('O') or 
		    $state->fatal("Can't write to #1: #2", 
			$state->opt('O'), $!);
	}
	$state->{source} = $state->opt('s');
	$state->{full} = $state->opt('f');
	$state->{repository} = $state->opt('d');
	$state->{stdin} = $state->opt('i');
	if ($state->opt('o')) {
		$state->{scanner} = OpenBSD::BinaryScan::Ldd->new($state);
	} else {
		$state->{scanner} = OpenBSD::BinaryScan::Objdump->new($state);
	}
	$state->{quiet} = $state->opt('q');
	if ($state->opt('D')) {
		$state->{logger} = Logger->new($state->opt('D'));
	}
}

sub init
{
	my $self = shift;
	$self->{errors} = 0;
	$self->SUPER::init(@@_);
}

sub context
{
	my ($self, $pkgname) = @@_;
	$self->{context} = $pkgname;
}

sub error
{
	my $state = shift;
	$state->{errors}++;
	$state->say_with_context(@@_);
}

sub say_with_context
{
	my $state = shift;
	if ($state->{context}) {
		$state->say("\n#1:", $state->{context});
		undef $state->{context};
	}
	$state->say(@@_);
}

sub set_context
{
	my ($state, $plist) = @@_;
	my $pkgname = $plist->pkgname;
	if ($plist->fullpkgpath) {
		$state->context($pkgname."(".$plist->fullpkgpath.")");
	} else {
		$state->context($pkgname);
	}
}

sub perllibs
{
	my $state = shift;
	if (!defined $state->{perllibs}) {
		OpenBSD::SharedLibs::add_libs_from_system('/', $state);
		eval {
		    my $perl = OpenBSD::SharedLibs->find_best('perl');
		    my $c = OpenBSD::SharedLibs->find_best('c');
		    if (!defined $perl || !defined $c) {
			    $state->fatal("can't find system perl and c");
		    }
		    $state->{perllibs} = ["perl.".$perl->major, "c.".$c->major];
		};
		if ($@@) {
			$state->fatal("please upgrade pkg_add first");
		}
	}
	return @@{$state->{perllibs}};
}

package CheckLibDepends;

use OpenBSD::PackageInfo;
use File::Path;
use File::Find;

my $dependencies = {};

sub register_dependencies
{
	my $plist = shift;
	my $pkgname = $plist->pkgname;
	my $h = {};
	$dependencies->{$pkgname} = $h;
	$plist->depwalk($h);
}

sub get_plist
{
	my ($self, $state, $pkgname, $pkgpath) = @@_;

	# try physical package
	if (defined $state->{repository}) {
		my $location = "$state->{repository}/$pkgname.tgz";

		my $true_package = $state->repo->find($location);
		if ($true_package) {
			my $dir = $true_package->info;
			if (-d $dir) {
				my $plist = OpenBSD::PackingList->fromfile($dir.CONTENTS);
				$true_package->close;
				rmtree($dir);
				return $plist;
			}
		}
	}
	my $cachefile;
	if (exists $ENV{_DEPENDS_CACHE}) {
		$cachefile = "$ENV{_DEPENDS_CACHE}/$pkgname";
	}
	# check the cache
	if (defined $cachefile && 
	    open my $fh, '<', "$ENV{_DEPENDS_CACHE}/$pkgname") {
		my $plist = OpenBSD::PackingList->read($fh);
		return $plist;
	}
	# or ask the ports tree directly
	my $portsdir = $ENV{PORTSDIR} || "/usr/ports";
	my ($make, @@extra) = split(/\s+/, $ENV{MAKE} || "make");
	my $pid = open(my $fh, "-|");
	if ($pid) {
		my $plist = OpenBSD::PackingList->read($fh);
		close $fh;
		waitpid $pid, 0;
		if (defined $cachefile && !-f $cachefile) {
			$plist->tofile($cachefile);
		}
		return $plist;
	} else {
		chdir($portsdir);
		my %myenv = (
			SUBDIR => $pkgpath,
			FULLPATH => "Yes",
			ECHO_MSG => ':'
		);
		if (exists $ENV{_DEPENDS_CACHE}) {
			$myenv{_DEPENDS_CACHE} = $ENV{_DEPENDS_CACHE};
		}
		%ENV = %myenv;
		exec { $make }
			($make, @@extra, 'print-plist-libs-with-depends',
				'wantlib_args=no-wantlib-args');
		exit 1;
	}
}

sub handle_dependency
{
	my ($self, $state, $pkgname, $pkgpath) = @@_;
	my $plist = $self->get_plist($state, $pkgname, $pkgpath);

	if (!defined $plist || !defined $plist->pkgname) {
		$state->errsay("Error: can't solve dependency for #1(#2)",
		    $pkgname, $pkgpath);
		return;
	}

	if ($plist->pkgname ne $pkgname) {
		delete $dependencies->{$pkgname};
		for my $p (keys %$dependencies) {
			if ($dependencies->{$p}->{$pkgname}) {
				$dependencies->{$p}->{$plist->pkgname} =
				    $dependencies->{$p}->{$pkgname};
				delete $dependencies->{$p}->{$pkgname};
			}
		}
	}

	register_dependencies($plist);
	OpenBSD::SharedLibs::add_libs_from_plist($plist, $state);

	return $plist->pkgname;
}

sub lookup_library
{
	my ($dir, $spec) = @@_;
	my $libspec = OpenBSD::LibSpec->from_string($spec);
	my $r = OpenBSD::SharedLibs::lookup_libspec($dir, $libspec);
	if (!defined $r) {
		return ();
	} else {
		return map {$_->origin} @@$r;
	}
}

sub report_lib_issue
{
	my ($self, $state, $plist, $lib, $binary) = @@_;

	OpenBSD::SharedLibs::add_libs_from_system('/', $state);
	my $libspec = "$lib.0";
	my $want = $lib;
	$want =~ s/\.\d+$//;
	for my $dir (qw(/usr /usr/X11R6)) {
		my @@r = lookup_library($dir, $libspec);
		if (grep { $_ eq 'system' } @@r) {
			return OpenBSD::Issue::SystemLib->new($lib, $binary);
		}
	}

	while (my ($p, $pkgpath) = each %{$dependencies->{$plist->pkgname}}) {
		next if defined $dependencies->{$p};
		$self->handle_dependency($state, $p, $pkgpath);
	}

	my @@r = lookup_library('/usr/local', $libspec);
	if (@@r > 0) {
		for my $p (@@r) {
			if (defined $dependencies->{$plist->pkgname}->{$p}) {
				return OpenBSD::Issue::DirectDependency->new($lib, $binary, $p);
			}
		}
	}
	# okay, let's walk for WANTLIB
	my @@todo = %{$dependencies->{$plist->pkgname}};
	my $done = {};
	while (@@todo >= 2) {
		my $path = pop @@todo;
		my $dep = pop @@todo;
		next if $done->{$dep};
		$done->{$dep} = 1;
		$dep = $self->handle_dependency($state, $dep, $path)
		    	unless defined $dependencies->{$dep};
		next if !defined $dep;
		$done->{$dep} = 1;
		push(@@todo, %{$dependencies->{$dep}});
	}
	@@r = lookup_library(OpenBSD::Paths->localbase, $libspec);
	for my $p (@@r) {
		if (defined $done->{$p}) {
			return OpenBSD::Issue::IndirectDependency->new($lib, $binary, $p);
		}
	}
	return OpenBSD::Issue::NotReachable->new($lib,, $binary, @@r);
}

sub has_all_libs
{
	my ($self, $libs, $list) = @@_;
	for my $l (@@$list) {
		if (!defined $libs->{$l}) {
			return 0;
		}
	}
	return 1;
}

sub backsubst
{
	my ($self, $h, $state) = @@_;
	my $doit = {};
	# try backsubsting each list
	while (my ($k, $v) = each %{$state->{subst}->hash}) {
		my @@l = split(/\s+/, $v);
		if ($self->has_all_libs($h, \@@l)) {
			$doit->{$k} = \@@l;
		}
	}
	while (my ($k, $list) = each %$doit) {
		for my $l (@@$list) {
			delete $h->{$l};
		}
		$h->{'${'.$k.'}'} = 1;
	}
}

sub print_list
{
	my ($self, $state, $head, $h) = @@_;

	$self->backsubst($h, $state);
	my $line = "";
	for my $k (sort keys %$h) {
		next if $k eq 'c++abi';
		$k =~ s/^(std)?c\+\+$/\${LIBCXX}/;
		if (length $line > 50) {
			$state->say_with_context("#1#2", $head, $line);
			$line = "";
		}
		$line .= ' '.$k;
	}
	if ($line ne '') {
		$state->say_with_context("#1#2", $head, $line);
	}
}

sub scan_package
{
	my ($self, $state, $plist, $source) = @@_;
	$state->{scanner}->set_source($source);
	$plist->scan_binaries_for_libs($state);
	$state->{scanner}->finish_scanning;
}

sub scan_true_package
{
	my ($self, $state, $plist, $source) = @@_;
	$state->{scanner}->set_source($source);
	my $h = {};
	$plist->find_binaries($h);
	$plist->find_perl($state);
	while (my $o = $source->next) {
		my $item = $h->{$o->name};
		if (defined $item) {
			delete $h->{$o->name};
			$state->{scanner}->finish_retrieve_and_scan(
			    $item, $o);
		}
	}
	if (keys %$h != 0) {
		$state->fatal("Not all files accounted for");
	}
	$state->{scanner}->finish_scanning;
}

sub analyze 
{
	my ($self, $state, $plist) = @@_;

	my $pkgname = $plist->pkgname;
	my $needed_libs = $state->{full} ? OpenBSD::AllRecorder->new : 
	    OpenBSD::SimpleRecorder->new;
	my $has_libs = {};
	$plist->find_libs($needed_libs, $state->{dump});
	$plist->register_libs($has_libs);

	if (!defined $dependencies->{$pkgname}) {
		register_dependencies($plist);
		OpenBSD::SharedLibs::add_libs_from_plist($plist, $state);
	}
	my $r = { wantlib => {}, libdepends => {}, wantlib2 => {} };
	for my $lib (sort $needed_libs->libs) {
		my $fullname = $needed_libs->binary($lib);
		if (!defined $has_libs->{$lib}) {
			my $issue = $self->report_lib_issue($state, $plist, 
			    $lib, $fullname);
			$state->error("#1", $issue->message);
			$issue->record_wantlib($r->{wantlib});
		} elsif ($has_libs->{$lib} == 1) {
			my $issue = $self->report_lib_issue($state, $plist, 
			    $lib, $fullname);
			if ($issue->not_reachable) {
				$state->error("#1", $issue->not_reachable);
			}
		}
		$has_libs->{$lib} = 2;
	}
	my $extra = {};
	for my $k (keys %$has_libs) {
		my $v = $has_libs->{$k};
		next if $v == 2;
		$extra->{$k} = 1;
	}
	unless ($state->{quiet} && keys %{$r->{wantlib}} == 0) {
		$self->print_list($state, "Extra: ", $extra);
	}
	$self->print_list($state, "WANTLIB +=", $r->{wantlib});
	if ($state->{full}) {
		$needed_libs->dump(\*STDOUT);
	}
}

sub do_pkg
{
	my ($self, $state, $pkgname) = @@_;

	my $true_package = $state->repo->find($pkgname);
	return 0 unless $true_package;
	my $dir = $true_package->info;
	# twice read
	return 0 unless -d $dir;
	my $plist = OpenBSD::PackingList->fromfile($dir.CONTENTS);
	$state->set_context($plist);
	my $temp = OpenBSD::Temp->dir;
	$state->{dump} = OpenBSD::DumpRecorder->new;
	$self->scan_true_package($state, $plist,
	    OpenBSD::PkgFileSource->new($true_package, $temp));
	$self->analyze($state, $plist);
	$true_package->close;
	$true_package->wipe_info;
	$plist->forget;
	if ($state->{dest}) {
		$state->{dump}->dump($state->{dest});
	}
	return 1;
}

sub do_plist
{
	my ($self, $state) = @@_;

	my $plist = OpenBSD::PackingList->read(\*STDIN);
	if (!defined $plist->{name}) {
		$state->error("Error reading plist");
		return;
	} else {
		$state->set_context($plist);
		$self->analyze($state, $plist);
	}
}

sub scan_directory
{
	my ($self, $state, $fs) = @@_;

	my $source = OpenBSD::FsFileSource->new($fs);
	$state->{scanner}->set_source($source);
	find({
		wanted => sub {
		    return if -l $_;
		    return unless -f _;
		    my $name = $_;
		    $name =~ s/^\Q$fs\E/\//;
		    # XXX hack FileBase object;
		    my $i = bless {name => $name}, "MyFile";
		    $i->scan_binaries_for_libs($state);
		},
		no_chdir => 1 }, $fs);
	$state->{scanner}->finish_scanning;
}

sub main
{
	my $self = shift;
	my $state = CheckLibDepends::State->new('check-lib-depends');
	$state->{signature_style} = 'unsigned';
	$state->handle_options;
	my $need_package = 0;
	# find files if we can
	if ($state->{source}) {
		$state->{dump} = OpenBSD::DumpRecorder->new;
		$state->{dump}->retrieve($state, $state->{source});
	} elsif ($state->{destdir}) {
		$state->{dump} = OpenBSD::DumpRecorder->new;
		$self->scan_directory($state, $state->{destdir});
		if ($state->{dest}) {
			$state->{dump}->dump($state->{dest});
		}
	} else {
		$need_package = 1;
	}

	if ($state->{stdin}) {
		if ($need_package) {
			$state->fatal("no source for actual files given");
		}
		$self->do_plist($state);
	} elsif (@@ARGV != 0) {
		$state->progress->for_list("Scanning", \@@ARGV,
		    sub {
			$self->do_pkg($state, shift);
		    });
	}

	exit($state->{errors} ? 1 : 0);
}

# XXX wrap line to avoid converting this to RCS keyword
$OpenBSD::Temp::tempbase =
    $ENV{'TMPDIR'} || "/tmp";
__PACKAGE__->main;
@


1.39
log
@use LIBCXX
@
text
@d3 1
a3 1
# $OpenBSD: check-lib-depends,v 1.38 2017/04/09 19:30:09 espie Exp $
d208 1
a208 1
		'[-fiomqx] [-B destdir] [-d pkgrepo] [-O dest] [-s source]');
@


1.38
log
@add some back-substitution functionality to check-lib-depends, to be used
later.

okay sthen@@
@
text
@d3 1
a3 1
# $OpenBSD: check-lib-depends,v 1.37 2017/02/11 12:52:58 espie Exp $
d496 2
@


1.37
log
@magically add most recent c/perl to ports with perl so, based on file name.
okay sthen@@
(version tweaked to tell you if your pkg_add is not recent enough)
@
text
@d3 1
a3 1
# $OpenBSD: check-lib-depends,v 1.36 2017/01/25 14:16:46 espie Exp $
d204 4
a207 1
	$state->SUPER::handle_options('oid:D:fB:qs:O:',
d459 30
d493 1
@


1.36
log
@improve the speed of lib-depends-check for multi-packages and bulk runs
drastically.

- make sure the recursive targets is marked as using the cache
- do not run env -i thus forgetting the cache. Do a proper manual run
which is just as complicated
- add an extra cache for each packing-list so that it goes really faster

okay sthen@@
@
text
@d3 1
a3 1
# $OpenBSD: check-lib-depends,v 1.35 2016/09/14 15:06:53 espie Exp $
d94 4
d118 1
d134 4
d159 12
d179 8
d269 20
d487 1
@


1.35
log
@do not check signatures in there
@
text
@d3 1
a3 1
# $OpenBSD: check-lib-depends,v 1.34 2015/02/09 09:47:31 espie Exp $
d276 11
a286 2
	# ask the ports tree
	$state->say("Asking ports for dependency #1(#2)", $pkgname, $pkgpath);
d288 26
a313 5
	my $make = $ENV{MAKE} || "make";
	open my $fh, "cd $portsdir && env -i SUBDIR=$pkgpath FULLPATH=Yes ECHO_MSG=: make print-plist-libs-with-depends wantlib_args=no-wantlib-args|" or return undef;
	my $plist = OpenBSD::PackingList->read($fh);
	close $fh;
	return $plist;
@


1.34
log
@disable interactive in AddCreateDelete.pm
@
text
@d3 1
a3 1
# $OpenBSD: check-lib-depends,v 1.33 2014/07/09 11:26:11 espie Exp $
d532 1
@


1.33
log
@add glue necessary for check-lib-depends to scan out-of-order packages
problem noticed by Giovanni Bechis
@
text
@d3 1
a3 1
# $OpenBSD: check-lib-depends,v 1.32 2013/02/07 08:19:54 zhuk Exp $
d174 1
@


1.32
log
@Unf**k back after RCS keyword expansion, sorry.
@
text
@d3 1
a3 1
# $OpenBSD: check-lib-depends,v 1.31 2013/02/07 08:00:10 zhuk Exp $
d90 4
d127 10
d144 1
a144 1
		$state->{scanner}->dont_scan($item);
d146 9
a154 1
		$state->{scanner}->retrieve_and_scan_binary($item, $fullname);
d401 20
d481 1
a481 1
	$self->scan_package($state, $plist,
@


1.31
log
@Respect envvar $TMPDIR in check-lib-depends, allows to run the latter when
/tmp is not big enough.

okay espie@@
@
text
@d3 1
a3 1
# $OpenBSD: check-lib-depends,v 1.30 2011/12/01 11:20:19 espie Exp $
d520 3
a522 1
$OpenBSD::Temp::tempbase = $ENV{'TMPDIR'} || "/tmp";
@


1.30
log
@zap old stuff, only read plist from stdin if -i was given
@
text
@d3 1
a3 1
# $OpenBSD: check-lib-depends,v 1.29 2011/11/27 17:37:47 espie Exp $
d520 1
a520 1
$OpenBSD::Temp::tempbase = "/tmp";
@


1.29
log
@bug fix, don't forget to finish_scanning when reading from source !
@
text
@d3 1
a3 1
# $OpenBSD: check-lib-depends,v 1.28 2011/11/27 17:31:54 espie Exp $
d510 1
a510 8
	} elsif (@@ARGV == 0) {
		if (!$state->{dest}) {
			if ($need_package) {
				$state->fatal("no source for actual files given");
			}
			$self->do_plist($state);
		}
	} else {
@


1.28
log
@unconfuse naming
@
text
@d3 1
a3 1
# $OpenBSD: check-lib-depends,v 1.27 2011/11/27 16:50:19 espie Exp $
d74 1
a74 1
sub record_needed_libs
d119 1
a119 1
sub record_needed_libs
d375 1
a375 1
	$plist->record_needed_libs($state);
d479 1
a479 1
		    $i->record_needed_libs($state);
d482 1
@


1.27
log
@flag error with -i and no source
@
text
@d3 1
a3 1
# $OpenBSD: check-lib-depends,v 1.26 2011/11/27 16:40:58 espie Exp $
d112 1
a112 1
	my ($item, $dest, $special) = @@_;
d114 2
a115 4
	if (defined $special->{$fullname}) {
		for my $lib (@@{$special->{$fullname}{libs}}) {
			$dest->record($lib, $fullname);
		}
d387 1
a387 1
	$plist->find_libs($needed_libs, $state->{recorder});
d438 1
a438 1
	$state->{recorder} = OpenBSD::DumpRecorder->new;
d446 1
a446 1
		$state->{recorder}->dump($state->{dest});
d492 2
a493 2
		$state->{recorder} = OpenBSD::DumpRecorder->new;
		$state->{recorder}->retrieve($state, $state->{source});
d495 1
a495 1
		$state->{recorder} = OpenBSD::DumpRecorder->new;
d498 1
a498 1
			$state->{recorder}->dump($state->{dest});
@


1.26
log
@more sensible option combinations.
@
text
@d3 1
a3 1
# $OpenBSD: check-lib-depends,v 1.25 2011/11/27 16:15:52 espie Exp $
d491 1
d502 3
a504 1
	} 
d507 3
d512 6
a517 1
		$self->do_plist($state) if !$state->{dest};
@


1.25
log
@add a bit of debug code that logs everything that's going on...
@
text
@d3 1
a3 1
# $OpenBSD: check-lib-depends,v 1.24 2011/11/27 14:49:42 espie Exp $
d154 2
a155 2
	$state->SUPER::handle_options('od:D:fB:qs:O:',
		'[-fomqx] [-B destdir] [-d pkgrepo] [-O dest] [-s source]');
d158 5
a162 1
	$state->{dest} = $state->opt('O');
d166 1
a181 1
	$self->{recorder} = OpenBSD::DumpRecorder->new;
d439 4
a442 6
	if ($state->{need_package}) {
		my $temp = OpenBSD::Temp->dir;
		$state->{recorder} = OpenBSD::DumpRecorder->new;
		$self->scan_package($state, $plist,
		    OpenBSD::PkgFileSource->new($true_package, $temp));
	}
d447 2
a448 2
	if ($state->{need_package}) {
		undef $state->{recorder};
d493 1
d496 1
d498 4
a501 12
	} else {
		$state->{need_package} = 1;
	}
		
	if ($state->{dest}) {
		open my $fh, '>', $state->{dest} or 
		    $state->fatal("Can't write to #1: #2", 
			$state->{dest}, $!);
		$state->{recorder}->dump($fh);
		close $fh;
		exit(0);
	}
d503 1
a503 1
	if (@@ARGV == 0) {
d505 2
@


1.24
log
@move binary scanner into its own module
@
text
@d3 1
a3 1
# $OpenBSD: check-lib-depends,v 1.23 2011/11/27 13:39:11 espie Exp $
d39 25
d154 1
a154 1
	$state->SUPER::handle_options('od:fB:qs:O:',
d168 3
@


1.23
log
@add a "quiet" option that doesn't say anything about extra libraries unless
there's also missing wantlibs.
@
text
@d3 1
a3 1
# $OpenBSD: check-lib-depends,v 1.22 2011/11/27 13:29:38 espie Exp $
d35 1
d107 1
a107 1
		$state->{runner}->{source}->skip($item);
d109 1
a109 1
		$state->{runner}->retrieve_and_scan_binaries($item, $fullname);
a120 190
package Runner;
sub new
{
	my ($class, $state) = @@_;
	bless {state => $state}, $class;
}

sub set_source
{
	my ($self, $source) = @@_;
	$self->{source} = $source;
}

sub fatal
{
	my $self = shift;
	$self->{state}->fatal(@@_);
}

sub dest
{
	my $self = shift;
	return $self->{state}->{recorder};
}

sub start
{
	my ($self, @@names) = @@_;

	unless (open(my $cmd, '-|')) {
		chdir($self->{source}->directory) or 
		    $self->fatal("Bad directory #1: #2", 
		    	$self->{source}->directory, $!);
		open(STDERR, '>', '/dev/null');
		$self->exec(@@names) or 
		    $self->fatal("exec #1: #2", $self->command, $!);
	} else {
		return $cmd;
	}
}

sub record_libs
{
	my ($self, $fullname, @@libs) = @@_;
	for my $lib (@@libs) {
		# don't look for modules
		next if $lib =~ m/\.so$/;
		$self->dest->record($lib, $fullname);
	}
}

sub retrieve_and_scan_binaries
{
	my ($self, $item, $fullname) = @@_;

	my $n = $self->{source}->retrieve($self->{state}, $item);
	# make sure to turn into a relative path
	$n =~ s/^\/*//;

	$self->scan_binary($item, $fullname, $n);
}

package Runner::Objdump;
our @@ISA = qw(Runner);

sub command() { 'objdump' }

sub exec
{
	my ($self, @@names) = @@_;
	exec($self->command, '-p', @@names);
}

sub parse
{
	my ($self, $cmd, $names) = @@_;
	my $fullname;
	my @@l = ();
	my $linux_binary = 0;
	while (my $line = <$cmd>) {
		chomp;
		if ($line =~ m/^(.*)\:\s+file format/) {
			my $k = $1;
			$self->record_libs($fullname, @@l) unless $linux_binary;
			$linux_binary = 0;
			@@l = ();
			if (defined $names->{$k}) {
				$fullname = $names->{$k};
			}
		}
		if ($line =~ m/^\s+NEEDED\s+(.*?)\s*$/) {
			my $lib = $1;
			push(@@l, $lib);
			# detect linux binaries
			if ($lib eq 'libc.so.6') {
				$linux_binary = 1;
			}
		} elsif ($line =~ m/^\s+RPATH\s+(.*)\s*$/) {
			my $p = {};
			for my $path (split /\:/, $1) {
				next if $path eq '/usr/local/lib';
				next if $path eq '/usr/X11R6/lib';
				next if $path eq '/usr/lib';
				$p->{$path} = 1;
			}
			for my $path (keys %$p) {
				$self->dest->record_rpath($path, $fullname);
			}
		}
	}
	$self->record_libs($fullname, @@l) unless $linux_binary;
}

sub scan_binary
{
	my ($self, $item, $fullname, $n) = @@_;

	$self->{names}{$n} = $fullname;
	push(@@{$self->{cleanup}}, $item);

	if (@@{$self->{cleanup}} >= 1000) {
		$self->finish_scanning;
	}
}

sub finish_scanning
{
	my $self = shift;

	if (defined $self->{names}) {
		my $cmd = $self->start(sort keys %{$self->{names}});
		$self->parse($cmd, $self->{names});
		close($cmd);
		delete $self->{names};
	}
	if (defined $self->{cleanup}) {
		for my $item (@@{$self->{cleanup}}) {
			$self->{source}->clean($item);
		}
		delete $self->{cleanup};
	}
}

package Runner::Ldd;
our @@ISA = qw(Ldd);

sub command() { 'ldd' }

sub exec
{
	my ($self, @@names) = @@_;
	if (@@names > 1) {
		$self->fatal("Can't run ldd over several names");
	}
	exec($self->command, '-f', "NEEDED lib%o.so.%m.%n\n", @@names);
}

sub parse
{
	my ($self, $cmd, $fullname) = @@_;
	my @@l = ();
	my $linux_binary = 0;
	while (my $line = <$cmd>) {
		chomp;
		if ($line =~ m/^\s+NEEDED\s+(.*?)\s*$/) {
			my $lib = $1;
			push(@@l, $lib);
			# detect linux binaries
			if ($lib eq 'libc.so.6') {
				$linux_binary = 1;
			}
		}
	}
	$self->record_libs($fullname, @@l) unless $linux_binary;
}

sub scan_binary
{
	my ($self, $item, $fullname, $n) = @@_;
	my $cmd = $self->start($n);

	$self->parse($cmd, $fullname);
	close($cmd);
	$self->{source}->clean($item);
}

sub finish_scanning
{
}

d138 1
a138 1
		$state->{runner} = Runner::Ldd->new($state);
d140 1
a140 1
		$state->{runner} = Runner::Objdump->new($state);
d344 1
a344 1
	$state->{runner}->set_source($source);
d346 1
a346 1
	$state->{runner}->finish_scanning;
d442 1
a442 1
	$state->{runner}->set_source($source);
@


1.22
log
@run objdump in batches, for a *huge* speed-up
@
text
@d3 1
a3 1
# $OpenBSD: check-lib-depends,v 1.21 2011/11/27 13:10:36 espie Exp $
d318 2
a319 2
	$state->SUPER::handle_options('od:fB:s:O:',
		'[-fomx] [-B destdir] [-d pkgrepo] [-O dest] [-s source]');
d331 1
d576 3
a578 1
	$self->print_list($state, "Extra: ", $extra);
@


1.21
log
@prepare the non ldd parser to handle multiple files
@
text
@d3 1
a3 1
# $OpenBSD: check-lib-depends,v 1.20 2011/11/27 12:42:40 espie Exp $
d139 6
d161 9
d179 1
a179 18
	my $cmd = $self->start($n);
	my $dest = $self->{state}->{recorder};

	$self->parse($cmd, $dest, $fullname, {$n => $fullname},
	    sub {
		    my $fullname = shift;
		    for my $lib (@@_) {
			    # don't look for modules
			    next if $lib =~ m/\.so$/;
			    $dest->record($lib, $fullname);
		    }
	    });
	close($cmd);
	$self->{source}->clean($item);
}

sub finish_scanning
{
d195 2
a196 1
	my ($self, $cmd, $dest, $fullname, $names, $doit) = @@_;
d203 1
a203 1
			&$doit($fullname, @@l) unless $linux_binary;
d226 1
a226 1
				$dest->record_rpath($path, $fullname);
d230 31
a260 1
	&$doit($fullname, @@l) unless $linux_binary;
d279 1
a279 1
	my ($self, $cmd, $dest, $fullname, $names, $doit) = @@_;
d293 15
a307 1
	&$doit($fullname, @@l) unless $linux_binary;
@


1.20
log
@finish moving parts to the Runner object
@
text
@d3 1
a3 1
# $OpenBSD: check-lib-depends,v 1.19 2011/11/27 12:29:10 espie Exp $
d155 2
a156 1
sub scan_binaries
d158 1
a158 2
	my ($self, $item) = @@_;
	my $cmd;
d164 2
a165 2
	return $self->start($n);
}
d167 1
a167 35
sub parse_objdump
{
	my ($cmd, $dest, $fullname, $doit) = @@_;
	my @@l = ();
	while (my $line = <$cmd>) {
		if ($line =~ m/^\s+NEEDED\s+(.*?)\s*$/) {
			my $lib = $1;
			push(@@l, $lib);
			# detect linux binaries
			if ($lib eq 'libc.so.6') {
				return ();
			}
		} elsif ($line =~ m/^\s+RPATH\s+(.*)\s*$/) {
			my $p = {};
			for my $path (split /\:/, $1) {
				next if $path eq '/usr/local/lib';
				next if $path eq '/usr/X11R6/lib';
				next if $path eq '/usr/lib';
				$p->{$path} = 1;
			}
			for my $path (keys %$p) {
				$dest->record_rpath($path, $fullname);
			}
		}
	}
	&$doit($fullname, @@l);
}

sub retrieve_and_scan_binaries
{
	my ($self, $item, $fullname) = @@_;

	my $cmd = $self->scan_binaries($item);
	my $dest = $self->{state}->{recorder};
	parse_objdump($cmd, $dest, $fullname,
d195 39
d246 19
@


1.19
log
@rename a few things
@
text
@d3 1
a3 1
# $OpenBSD: check-lib-depends,v 1.18 2011/11/27 12:24:06 espie Exp $
d97 2
a98 1
	my ($item, $state, $dest, $source) = @@_;
d106 3
a108 2
		$source->skip($item);
		return;
a109 2

	$state->retrieve_and_scan_binaries($dest, $source, $item, $fullname);
a154 32
sub finish_scanning
{
}

package Runner::Objdump;
our @@ISA = qw(Runner);

sub command() { 'objdump' }

sub exec
{
	my ($self, @@names) = @@_;
	exec($self->command, '-p', @@names);
}

package Runner::Ldd;
our @@ISA = qw(Ldd);

sub command() { 'ldd' }

sub exec
{
	my ($self, @@names) = @@_;
	if (@@names > 1) {
		$self->fatal("Can't run ldd over several names");
	}
	exec($self->command, '-f', "NEEDED lib%o.so.%m.%n\n", @@names);
}

package CheckLibDepends::State;
our @@ISA = qw(OpenBSD::AddCreateDelete::State);

d157 1
a157 1
	my ($state, $source, $item) = @@_;
d160 1
a160 1
	my $n = $source->retrieve($state, $item);
d164 1
a164 1
	return $state->{runner}->start($n);
d197 1
a197 1
	my ($state, $dest, $source, $item, $fullname) = @@_;
d199 2
a200 1
	my $cmd = $state->scan_binaries($source, $item);
d211 30
a240 1
	$source->clean($item);
d243 4
d466 1
a466 1
	$plist->record_needed_libs($state, $state->{recorder}, $source);
d570 1
a570 1
		    $i->record_needed_libs($state, $state->{recorder}, $source);
@


1.18
log
@explain source to runner
@
text
@d3 1
a3 1
# $OpenBSD: check-lib-depends,v 1.17 2011/11/27 12:09:17 espie Exp $
d109 1
a109 1
	$state->retrieve_and_run_objdump($dest, $source, $item, $fullname);
d155 4
d187 1
a187 1
sub run_objdump
d227 1
a227 1
sub retrieve_and_run_objdump
d231 1
a231 1
	my $cmd = $state->run_objdump($source, $item);
a244 4
sub finish_objdump
{
}

d465 1
a465 1
	$state->finish_objdump($state->{recorder}, $source);
@


1.17
log
@abstract running objdump/ldd a bit more into its own class
@
text
@d3 1
a3 1
# $OpenBSD: check-lib-depends,v 1.16 2011/11/27 11:50:26 espie Exp $
d127 6
d141 1
a141 1
	my ($self, $directory, @@names) = @@_;
d144 1
a144 1
		chdir($directory) or 
d146 1
a146 1
		    	$directory, $!);
d192 1
a192 1
	return $state->{runner}->start($source->directory, $n);
d463 1
d559 1
@


1.16
log
@move objdump runs to state in order to be able to run it once
@
text
@d3 1
a3 1
# $OpenBSD: check-lib-depends,v 1.15 2011/11/27 11:37:58 espie Exp $
d120 54
d186 1
a186 14
	unless (open($cmd, '-|')) {
		chdir($source->directory) or 
		    $state->fatal("Bad directory #1: #2", 
		    	$source->directory, $!);
		open(STDERR, '>', '/dev/null');
		if ($state->{old}) {
			exec("ldd", "-f", "NEEDED lib%o.so.%m.%n\n", $n) or 
			    $state->fatal("exec ldd: #1", $!);
		} else {
			exec('objdump', '-p', $n) or 
			    $state->fatal("exec objdump: #1", $!);
		}
	}
	return $cmd;
d251 5
a255 1
	$state->{old} = $state->opt('o');
@


1.15
log
@tweak to allow for several files in a single run
@
text
@d3 1
a3 1
# $OpenBSD: check-lib-depends,v 1.14 2011/11/27 11:29:33 espie Exp $
d95 28
d176 1
a176 1
sub record_needed_libs
d178 1
a178 2
	my ($item, $state, $dest, $source) = @@_;
	my $fullname = File::Spec->canonpath($item->fullname);
d180 1
a180 9
	my $linux_bin = 0;
	if ($fullname =~ m,^/usr/local/emul/(?:redhat|fedora)/,) {
		$linux_bin = 1;
	}
	if ($linux_bin || $item->{symlink} || $item->{link}) {
		$source->skip($item);
		return;
	}
	my $cmd = run_objdump($state, $source, $item);
d194 1
a194 3
package OpenBSD::PackingElement::Dependency;

sub depwalk
a195 2
	my ($self, $h) = @@_;
	$h->{$self->{def}} = $self->{pkgpath};
a197 3
package CheckLibDepends::State;
our @@ISA = qw(OpenBSD::AddCreateDelete::State);

d413 1
@


1.14
log
@unify ldd/objdump runs somewhat
tweak FileSource to return its directory separately from the filename,
so that running objdump does a chdir
adjust filename to be a relative path.
@
text
@d3 1
a3 1
# $OpenBSD: check-lib-depends,v 1.13 2011/11/26 12:02:54 espie Exp $
d122 1
a122 1
	my ($cmd, $dest, $fullname) = @@_;
d145 1
a145 1
	return @@l;
d162 9
a170 5
	for my $lib (parse_objdump($cmd, $dest, $fullname)) {
		# don't look for modules
		next if $lib =~ m/\.so$/;
		$dest->record($lib, $fullname);
	}
@


1.13
log
@slightly nicer display, especially in the presence of a progress meter
on long lists of WANTLIBs.
@
text
@d3 1
a3 1
# $OpenBSD: check-lib-depends,v 1.12 2011/11/16 10:37:35 espie Exp $
d97 1
a97 1
	my ($state, $n) = @@_;
d100 13
a112 6
	if ($state->{old}) {
		open($cmd, "-|", "ldd", "-f", "NEEDED lib%o.so.%m.%n\n", $n) or 
		    $state->fatal("run ldd: #1", $!);
	} else {
		unless (open($cmd, '-|')) {
			open(STDERR, '>', '/dev/null');
d161 1
a161 2
	my $n = $source->retrieve($state, $item);
	my $cmd = run_objdump($state, $n);
@


1.12
log
@simplify external call a bit
@
text
@d3 1
a3 1
# $OpenBSD: check-lib-depends,v 1.11 2011/10/17 10:18:16 espie Exp $
d216 1
a216 1
		$state->say("#1:", $state->{context});
a431 1
	print "\n";
@


1.11
log
@fix for pkgpaths changes
@
text
@d3 1
a3 1
# $OpenBSD: check-lib-depends,v 1.10 2011/04/25 23:01:03 sthen Exp $
d273 1
a273 1
	open my $fh, "cd $portsdir && env -i SUBDIR=$pkgpath FULLPATH=Yes ECHO_MSG=: make print-plist-with-depends |" or return undef;
@


1.10
log
@Remove code to support FreeBSD emulation, ok espie@@
@
text
@d3 1
a3 1
# $OpenBSD: check-lib-depends,v 1.9 2011/03/07 10:06:36 espie Exp $
d273 1
a273 1
	open my $fh, "cd $portsdir && env -i SUBDIR=$pkgpath ECHO_MSG=: make print-plist-with-depends |" or return undef;
@


1.9
log
@use FindBin if the portsdir was moved.
fix error message
@
text
@d3 1
a3 1
# $OpenBSD: check-lib-depends,v 1.8 2011/01/26 12:53:46 ajacoutot Exp $
a146 1
	my $freebsd_bin = 0;
d150 1
a150 4
	if ($fullname =~ m,^/usr/local/emul/freebsd/,) {
		$freebsd_bin = 1;
	}
	if ($linux_bin || $freebsd_bin || $item->{symlink} || $item->{link}) {
@


1.8
log
@Brought to you by the king of slack!
Manually removing TABs is an exhausting job, so make the analyse
function output compatible for copy/paste into a port Makefile.

"yes yes yes" sthen@@
ok landry@@ espie@@
@
text
@d3 1
a3 1
# $OpenBSD: check-lib-depends,v 1.7 2010/12/24 10:31:40 espie Exp $
d21 1
d25 1
a25 1
use lib "$ports1/infrastructure/lib";
d107 1
a107 1
			    $state->fatal("exec objdump: #!", $!);
@


1.7
log
@pass state around
@
text
@d3 1
a3 1
# $OpenBSD: check-lib-depends,v 1.6 2010/09/15 09:36:57 espie Exp $
d435 2
a436 1
	$self->print_list($state, "\tWANTLIB +=", $r->{wantlib});
@


1.6
log
@reset recorder if we get contents from packages, since it would grow too
much.
@
text
@d3 1
a3 1
# $OpenBSD: check-lib-depends,v 1.5 2010/09/13 14:38:05 espie Exp $
d305 1
a305 1
	OpenBSD::SharedLibs::add_libs_from_plist($plist);
d326 1
a326 1
	OpenBSD::SharedLibs::add_libs_from_system('/');
d409 1
a409 1
		OpenBSD::SharedLibs::add_libs_from_plist($plist);
@


1.5
log
@saner: always go thru a DumpRecorder, and perform full save/retrieve from
a dump recorder.
@
text
@d3 1
a3 1
# $OpenBSD: check-lib-depends,v 1.4 2010/08/20 17:03:36 espie Exp $
d454 1
d462 3
@


1.4
log
@zap old option, fix usage and man for common stuff
@
text
@d3 1
a3 1
# $OpenBSD: check-lib-depends,v 1.3 2010/08/20 15:29:41 espie Exp $
d88 1
a88 1
		for my $lib (@@{$special->{$fullname}}) {
a186 2
	$state->{destdir} //= '/';
	$state->{destdir}.= '/' unless $state->{destdir} =~ m|/$|;
d198 1
d225 11
d390 6
d398 1
a398 1
	my ($self, $state, $plist, $source) = @@_;
a400 5
	if ($plist->fullpkgpath) {
		$state->context($pkgname."(".$plist->fullpkgpath.")");
	} else {
		$state->context($pkgname);
	}
d404 1
a404 7
	if ($state->{source}) {
		my $special = OpenBSD::DumpRecorder->new;
		$special->retrieve($state, $state->{source});
		$plist->find_libs($needed_libs, $special);
	} else {
		$plist->record_needed_libs($state, $needed_libs, $source);
	}
d451 2
a452 6
	if ($state->{source}) {
		$self->analyze($state, $plist);
	} elsif ($state->{destdir} ne '/') {
		$self->analyze($state, $plist, 
		    OpenBSD::FsFileSource->new($state->{destdir}));
	} else {
d454 1
a454 1
		$self->analyze($state, $plist,
a455 1
		rmtree($temp);
d457 1
d473 2
a474 2
		$self->analyze($state, $plist, 
		    OpenBSD::FsFileSource->new($state->{destdir}));
d478 18
d501 9
a509 1
	my $fs = $state->{destdir};
d511 5
a515 23
		my $recorder = OpenBSD::DumpRecorder->new;
		my $cwd = $fs;
		my $source = OpenBSD::FsFileSource->new($fs);
		find({
			wanted => sub {
			    return if -l $_;
			    return unless -f _;
			    my $name = $_;
			    $name =~ s/^\Q$fs\E/\//;
			    # XXX hack FileBase object;
			    my $i = bless {name => $name}, "MyFile";
			    $i->record_needed_libs($state, $recorder, $source);
			},
			no_chdir => 1 }, $fs);
		if ($state->{dest}) {
			open my $fh, '>', $state->{dest} or 
			    $state->fatal("Can't write to #1: #2", 
				$state->{dest}, $!);
			$recorder->dump($fh);
			close $fh;
		} else {
			$recorder->dump(\*STDOUT);
		}
d519 1
a519 1
	if (@@ARGV == 0 && ($state->{destdir} ne '/' || $state->{source})) {
@


1.3
log
@move a large part of check-lib-depends into separate modules
@
text
@d3 1
a3 1
# $OpenBSD: check-lib-depends,v 1.2 2010/08/20 15:22:21 espie Exp $
d183 2
a184 2
	$state->SUPER::handle_options('od:fB:F:s:O:',
		'[-o] [-d pkgrepo] [-B destdir] [-s source] [-O dest]');
d186 1
a186 1
	$state->{destdir} = $state->opt('B') // $state->opt('F');
@


1.2
log
@better namespace for make-plist internals, prepare to cut up check-lib-depends
@
text
@d3 1
a3 1
# $OpenBSD: check-lib-depends,v 1.1 2010/08/20 13:50:11 espie Exp $
d33 3
a35 284

# FileSource: where we get the files to analyze
package FileSource;

# file system
package FsFileSource;
our @@ISA = qw(FileSource);
sub new
{
	my ($class, $location) = @@_;
	bless {location => $location }, $class
}

sub retrieve
{
	my ($self, $state, $item) = @@_;
	return $self->{location}.$item->fullname;
}

sub skip
{
}

sub clean
{
}

# package archive
package PkgFileSource;
our @@ISA = qw(FileSource);
sub new
{
	my ($class, $handle, $location) = @@_;
	bless {handle => $handle, location => $location }, $class;
}

sub prepare_to_extract
{
	my ($self, $item) = @@_;
	require OpenBSD::ArcCheck;
	my $o = $self->{handle}->next;
	$o->{cwd} = $item->cwd;
	if (!$o->check_name($item)) {
		die "Error checking name for $o->{name} vs. $item->{name}\n";
	}
	$o->{name} = $item->fullname;
	$o->{destdir} = $self->{location};
	return $o;
}

sub extracted_name
{
	my ($self, $item) = @@_;
	return $self->{location}.$item->fullname;
}

sub retrieve
{
	my ($self, $state, $item) = @@_;
	my $o = $self->prepare_to_extract($item);
	$o->create;
	return $self->extracted_name($item);
}

sub skip
{
	my ($self, $item) = @@_;
	my $o = $self->prepare_to_extract($item);
	$self->{handle}->skip;
}

sub clean
{
	my ($self, $item) = @@_;
	unlink($self->extracted_name($item));
}

# Recorder: how we keep track of which binary uses which library
package Recorder;
sub new
{
	my $class = shift;
	return bless {}, $class;
}

sub reduce_libname
{
	my ($self, $lib) = @@_;
	$lib =~ s/^(.*\/)?lib(.*)\.so\.(\d+)\.\d+$/$2.$3/;
	return $lib;
}

sub libs
{
	my $self = shift;
	return keys %$self;
}

sub record_rpath
{
}

# SimpleRecorder: remember one single binary for each library
package SimpleRecorder;
our @@ISA = qw(Recorder);
sub record
{
	my ($self, $lib, $filename) = @@_;
	$self->{$self->reduce_libname($lib)} = $filename;
}

sub binary
{
	my ($self, $lib) = @@_;
	return $self->{$lib};
}

# AllRecorder: remember all binaries for each library
package AllRecorder;
our @@ISA = qw(Recorder);
sub record
{
	my ($self, $lib, $filename) = @@_;
	push(@@{$self->{$self->reduce_libname($lib)}}, $filename);
}

sub binaries
{
	my ($self, $lib) = @@_;
	return @@{$self->{$lib}};
}
sub binary
{
	my ($self, $lib) = @@_;
	return $self->{$lib}->[0];
}

sub dump
{
	my ($self, $fh) = @@_;
	for my $lib (sort $self->libs) {
		print $fh "$lib:\t\n";
		for my $binary (sort $self->binaries($lib)) {
			print $fh "\t$binary\n";
		}
	}
}

package DumpRecorder;
our @@ISA = qw(Recorder);
sub record
{
	my ($self, $lib, $filename) = @@_;
	push(@@{$self->{$filename}->{libs}}, $lib);
}

sub record_rpath
{
	my ($self, $path, $filename) = @@_;
	push(@@{$self->{$filename}->{rpath}}, $path);
}

sub dump
{
	my ($self, $fh) = @@_;
	while (my ($binary, $v) = each %$self) {
		print $fh $binary;
		if (defined $v->{rpath}) {
			print $fh "(", join(':', @@{$v->{rpath}}), ")";
		}
		print $fh ": ", join(',', @@{$v->{libs}}), "\n";
	}
}

sub retrieve
{
	my ($self, $state, $filename) = @@_;
	open(my $fh, '<', $filename) or 
	    $state->fatal("Can't read #1: #2", $filename, $!);
	my $_;
	while (<$fh>) {
		chomp;
		if (m/^(.*?)\:\s(.*)$/) {
			my ($binary, $libs) = ($1, $2);
			if ($binary =~ m/^(.*)\(.*\)$/) {
				$binary = $1;
			}
			my @@libs = split(/,/, $libs);
			$self->{$binary}= \@@libs;
		} else {
			$state->errsay("Can't parse #1", $_);
		}
	}
	close $fh;
}

# Issue: intermediate objects that record problems with libraries
package Issue;
sub new
{
	my ($class, $lib, $binary, @@packages) = @@_;
	bless { lib => $lib, binary => $binary, packages => \@@packages }, 
		$class;
}

sub stringize
{
	my $self = shift;
	my $string = $self->{lib};
	if (@@{$self->{packages}} > 0) {
		$string.=" from ".join(',', @@{$self->{packages}});
	}
	return $string." ($self->{binary})";
}

sub do_record_wantlib
{
	my ($self, $h) = @@_;
	my $want = $self->{lib};
	$want =~ s/\.\d+$//;
	$h->{$want} = 1;
}

sub record_wantlib
{
}

sub not_reachable
{
	return 0;
}

sub print
{
	my $self = shift;
	print $self->message, "\n";
}
package Issue::SystemLib;
our @@ISA = qw(Issue);

sub message
{
	my $self = shift;
	return "WANTLIB:       ". $self->stringize. " (system lib)";
}

sub record_wantlib
{
	&Issue::do_record_wantlib;
}
package Issue::DirectDependency;
our @@ISA = qw(Issue);
sub message
{
	my $self = shift;
	return "LIB_DEPENDS:   ". $self->stringize;
}

package Issue::IndirectDependency;
our @@ISA = qw(Issue);
sub message
{
	my $self = shift;
	return "WANTLIB:       ". $self->stringize;
}

sub record_wantlib
{
	&Issue::do_record_wantlib;
}

package Issue::NotReachable;
our @@ISA = qw(Issue);
sub message
{
	my $self = shift;
	return "Missing lib:   ". $self->stringize. " (NOT REACHABLE)";
}

sub not_reachable
{
	my $self = shift;
	return "Bogus WANTLIB: ". $self->stringize. " (NOT REACHABLE)";
}
d323 1
a323 1
			return Issue::SystemLib->new($lib, $binary);
d336 1
a336 1
				return Issue::DirectDependency->new($lib, $binary, $p);
d357 1
a357 1
			return Issue::IndirectDependency->new($lib, $binary, $p);
d360 1
a360 1
	return Issue::NotReachable->new($lib,, $binary, @@r);
d390 2
a391 1
	my $needed_libs = $state->{full} ? AllRecorder->new : SimpleRecorder->new;
d394 1
a394 1
		my $special = DumpRecorder->new;
d450 1
a450 1
		    FsFileSource->new($state->{destdir}));
d454 1
a454 1
		    PkgFileSource->new($true_package, $temp));
d473 1
a473 1
		    FsFileSource->new($state->{destdir}));
d484 1
a484 1
		my $recorder = DumpRecorder->new;
d486 1
a486 1
		my $source = FsFileSource->new($fs);
@


1.1
log
@copy some stuff to the new organization, rename find-all-conflicts to
check-conflicts for consistency
@
text
@d3 1
a3 1
# $OpenBSD: check-lib-depends,v 1.28 2010/07/12 20:19:40 espie Exp $
d20 5
@

