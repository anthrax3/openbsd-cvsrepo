head	1.121;
access;
symbols
	OPENBSD_6_0:1.121.0.2
	OPENBSD_6_0_BASE:1.121
	OPENBSD_5_9:1.115.0.2
	OPENBSD_5_9_BASE:1.115
	OPENBSD_5_8:1.113.0.4
	OPENBSD_5_8_BASE:1.113
	OPENBSD_5_7:1.110.0.2
	OPENBSD_5_7_BASE:1.110
	OPENBSD_5_6:1.108.0.2
	OPENBSD_5_6_BASE:1.108
	OPENBSD_5_5:1.104.0.2
	OPENBSD_5_5_BASE:1.104
	OPENBSD_5_4:1.93.0.2
	OPENBSD_5_4_BASE:1.93
	OPENBSD_5_3:1.85.0.2
	OPENBSD_5_3_BASE:1.85
	OPENBSD_5_2:1.52.0.2
	OPENBSD_5_2_BASE:1.52
	OPENBSD_5_1_BASE:1.41
	OPENBSD_5_1:1.41.0.2
	OPENBSD_5_0:1.23.0.2
	OPENBSD_5_0_BASE:1.23
	OPENBSD_4_9:1.11.0.2
	OPENBSD_4_9_BASE:1.11;
locks; strict;
comment	@# @;


1.121
date	2016.05.21.12.20.10;	author espie;	state Exp;
branches;
next	1.120;
commitid	0f89fFEtAu709Kh2;

1.120
date	2016.05.17.14.50.36;	author espie;	state Exp;
branches;
next	1.119;
commitid	sNkGwrxrgGunoaEN;

1.119
date	2016.05.16.13.47.18;	author espie;	state Exp;
branches;
next	1.118;
commitid	Seo1OMd8B6VAoKJ6;

1.118
date	2016.05.16.10.37.44;	author espie;	state Exp;
branches;
next	1.117;
commitid	UBFEfnMdl4Z4RscH;

1.117
date	2016.05.16.09.50.59;	author espie;	state Exp;
branches;
next	1.116;
commitid	1ss1As951nmQShKE;

1.116
date	2016.05.15.14.02.01;	author espie;	state Exp;
branches;
next	1.115;
commitid	R2HHJK5SdlcyTInD;

1.115
date	2015.10.17.19.32.03;	author espie;	state Exp;
branches;
next	1.114;
commitid	enw8Ppgs8DOFaChU;

1.114
date	2015.08.24.10.16.18;	author espie;	state Exp;
branches;
next	1.113;
commitid	jf96P99j0SQ3ZVuH;

1.113
date	2015.07.15.14.30.26;	author espie;	state Exp;
branches;
next	1.112;
commitid	qWIWYcya7qMvK46s;

1.112
date	2015.05.27.11.15.40;	author espie;	state Exp;
branches;
next	1.111;
commitid	eqCdGgJeZCuToSRY;

1.111
date	2015.05.10.10.00.43;	author espie;	state Exp;
branches;
next	1.110;
commitid	P6DCilP0tXDIWBXE;

1.110
date	2014.12.25.15.14.14;	author espie;	state Exp;
branches;
next	1.109;
commitid	4T2EL5Ro5f9nUYOi;

1.109
date	2014.12.22.09.05.24;	author espie;	state Exp;
branches;
next	1.108;
commitid	unZP3DVdsLyH17u9;

1.108
date	2014.04.28.12.51.41;	author espie;	state Exp;
branches;
next	1.107;

1.107
date	2014.03.17.10.49.19;	author espie;	state Exp;
branches;
next	1.106;

1.106
date	2014.03.15.09.51.27;	author espie;	state Exp;
branches;
next	1.105;

1.105
date	2014.03.09.19.47.35;	author espie;	state Exp;
branches;
next	1.104;

1.104
date	2013.10.18.07.48.09;	author espie;	state Exp;
branches;
next	1.103;

1.103
date	2013.10.18.07.45.41;	author espie;	state Exp;
branches;
next	1.102;

1.102
date	2013.10.13.18.31.50;	author espie;	state Exp;
branches;
next	1.101;

1.101
date	2013.10.11.10.26.44;	author espie;	state Exp;
branches;
next	1.100;

1.100
date	2013.10.09.06.21.38;	author espie;	state Exp;
branches;
next	1.99;

1.99
date	2013.10.06.15.49.22;	author espie;	state Exp;
branches;
next	1.98;

1.98
date	2013.10.06.14.03.07;	author espie;	state Exp;
branches;
next	1.97;

1.97
date	2013.10.06.13.33.24;	author espie;	state Exp;
branches;
next	1.96;

1.96
date	2013.10.02.09.00.34;	author espie;	state Exp;
branches;
next	1.95;

1.95
date	2013.09.18.15.30.40;	author espie;	state Exp;
branches;
next	1.94;

1.94
date	2013.09.03.09.44.05;	author espie;	state Exp;
branches;
next	1.93;

1.93
date	2013.07.04.17.45.34;	author jasper;	state Exp;
branches;
next	1.92;

1.92
date	2013.06.21.09.05.18;	author espie;	state Exp;
branches;
next	1.91;

1.91
date	2013.06.04.03.20.36;	author espie;	state Exp;
branches;
next	1.90;

1.90
date	2013.05.21.20.44.08;	author espie;	state Exp;
branches;
next	1.89;

1.89
date	2013.04.22.10.06.12;	author espie;	state Exp;
branches;
next	1.88;

1.88
date	2013.04.13.10.02.11;	author espie;	state Exp;
branches;
next	1.87;

1.87
date	2013.03.03.11.11.08;	author espie;	state Exp;
branches;
next	1.86;

1.86
date	2013.03.03.00.51.57;	author espie;	state Exp;
branches;
next	1.85;

1.85
date	2013.02.04.09.43.57;	author espie;	state Exp;
branches;
next	1.84;

1.84
date	2013.02.02.13.35.17;	author espie;	state Exp;
branches;
next	1.83;

1.83
date	2013.02.02.10.36.31;	author espie;	state Exp;
branches;
next	1.82;

1.82
date	2013.01.28.12.23.45;	author espie;	state Exp;
branches;
next	1.81;

1.81
date	2013.01.28.10.50.46;	author espie;	state Exp;
branches;
next	1.80;

1.80
date	2013.01.28.10.14.17;	author espie;	state Exp;
branches;
next	1.79;

1.79
date	2013.01.28.09.56.00;	author espie;	state Exp;
branches;
next	1.78;

1.78
date	2013.01.27.23.15.57;	author espie;	state Exp;
branches;
next	1.77;

1.77
date	2013.01.21.14.50.30;	author espie;	state Exp;
branches;
next	1.76;

1.76
date	2013.01.21.12.03.32;	author espie;	state Exp;
branches;
next	1.75;

1.75
date	2013.01.10.12.27.21;	author espie;	state Exp;
branches;
next	1.74;

1.74
date	2013.01.07.10.57.31;	author espie;	state Exp;
branches;
next	1.73;

1.73
date	2013.01.06.11.59.40;	author espie;	state Exp;
branches;
next	1.72;

1.72
date	2013.01.05.18.26.31;	author espie;	state Exp;
branches;
next	1.71;

1.71
date	2013.01.05.15.13.48;	author espie;	state Exp;
branches;
next	1.70;

1.70
date	2013.01.05.13.34.28;	author espie;	state Exp;
branches;
next	1.69;

1.69
date	2013.01.05.13.32.28;	author espie;	state Exp;
branches;
next	1.68;

1.68
date	2013.01.04.18.29.13;	author espie;	state Exp;
branches;
next	1.67;

1.67
date	2013.01.04.12.46.20;	author espie;	state Exp;
branches;
next	1.66;

1.66
date	2013.01.04.12.06.25;	author espie;	state Exp;
branches;
next	1.65;

1.65
date	2013.01.03.15.43.27;	author espie;	state Exp;
branches;
next	1.64;

1.64
date	2012.12.28.06.40.11;	author espie;	state Exp;
branches;
next	1.63;

1.63
date	2012.12.24.17.24.46;	author espie;	state Exp;
branches;
next	1.62;

1.62
date	2012.11.18.12.37.21;	author espie;	state Exp;
branches;
next	1.61;

1.61
date	2012.11.18.01.58.36;	author espie;	state Exp;
branches;
next	1.60;

1.60
date	2012.11.06.08.26.29;	author espie;	state Exp;
branches;
next	1.59;

1.59
date	2012.10.13.09.00.02;	author espie;	state Exp;
branches;
next	1.58;

1.58
date	2012.10.13.08.32.58;	author espie;	state Exp;
branches;
next	1.57;

1.57
date	2012.10.12.20.24.56;	author espie;	state Exp;
branches;
next	1.56;

1.56
date	2012.10.11.07.40.30;	author espie;	state Exp;
branches;
next	1.55;

1.55
date	2012.10.10.11.44.11;	author rpe;	state Exp;
branches;
next	1.54;

1.54
date	2012.10.08.12.41.03;	author espie;	state Exp;
branches;
next	1.53;

1.53
date	2012.09.23.18.13.32;	author espie;	state Exp;
branches;
next	1.52;

1.52
date	2012.04.10.16.58.47;	author espie;	state Exp;
branches;
next	1.51;

1.51
date	2012.04.02.15.51.24;	author espie;	state Exp;
branches;
next	1.50;

1.50
date	2012.03.09.15.16.38;	author espie;	state Exp;
branches;
next	1.49;

1.49
date	2012.03.09.12.51.38;	author espie;	state Exp;
branches;
next	1.48;

1.48
date	2012.03.06.11.22.40;	author espie;	state Exp;
branches;
next	1.47;

1.47
date	2012.03.05.19.43.09;	author espie;	state Exp;
branches;
next	1.46;

1.46
date	2012.03.02.19.35.09;	author espie;	state Exp;
branches;
next	1.45;

1.45
date	2012.02.27.17.50.14;	author espie;	state Exp;
branches;
next	1.44;

1.44
date	2012.02.27.15.37.36;	author espie;	state Exp;
branches;
next	1.43;

1.43
date	2012.02.27.14.51.37;	author espie;	state Exp;
branches;
next	1.42;

1.42
date	2012.02.17.07.35.42;	author espie;	state Exp;
branches;
next	1.41;

1.41
date	2012.01.30.15.11.04;	author espie;	state Exp;
branches;
next	1.40;

1.40
date	2012.01.09.17.56.28;	author espie;	state Exp;
branches;
next	1.39;

1.39
date	2012.01.08.20.28.37;	author espie;	state Exp;
branches;
next	1.38;

1.38
date	2011.12.10.14.48.40;	author espie;	state Exp;
branches;
next	1.37;

1.37
date	2011.12.05.21.22.35;	author espie;	state Exp;
branches;
next	1.36;

1.36
date	2011.12.05.16.10.00;	author espie;	state Exp;
branches;
next	1.35;

1.35
date	2011.12.04.12.05.41;	author espie;	state Exp;
branches;
next	1.34;

1.34
date	2011.12.04.11.24.38;	author espie;	state Exp;
branches;
next	1.33;

1.33
date	2011.12.03.11.01.47;	author espie;	state Exp;
branches;
next	1.32;

1.32
date	2011.12.02.22.33.46;	author espie;	state Exp;
branches;
next	1.31;

1.31
date	2011.11.26.11.46.15;	author espie;	state Exp;
branches;
next	1.30;

1.30
date	2011.11.14.21.59.45;	author espie;	state Exp;
branches;
next	1.29;

1.29
date	2011.11.14.21.57.47;	author espie;	state Exp;
branches;
next	1.28;

1.28
date	2011.11.09.08.28.55;	author espie;	state Exp;
branches;
next	1.27;

1.27
date	2011.10.11.09.50.35;	author espie;	state Exp;
branches;
next	1.26;

1.26
date	2011.10.10.18.56.50;	author espie;	state Exp;
branches;
next	1.25;

1.25
date	2011.09.25.10.41.30;	author espie;	state Exp;
branches;
next	1.24;

1.24
date	2011.09.13.09.46.53;	author espie;	state Exp;
branches;
next	1.23;

1.23
date	2011.07.14.12.44.39;	author espie;	state Exp;
branches;
next	1.22;

1.22
date	2011.07.14.11.02.50;	author espie;	state Exp;
branches;
next	1.21;

1.21
date	2011.06.02.17.09.25;	author espie;	state Exp;
branches;
next	1.20;

1.20
date	2011.05.29.11.06.23;	author espie;	state Exp;
branches;
next	1.19;

1.19
date	2011.05.22.08.21.38;	author espie;	state Exp;
branches;
next	1.18;

1.18
date	2011.04.25.11.58.46;	author espie;	state Exp;
branches;
next	1.17;

1.17
date	2011.04.24.09.14.45;	author espie;	state Exp;
branches;
next	1.16;

1.16
date	2011.04.24.08.34.05;	author espie;	state Exp;
branches;
next	1.15;

1.15
date	2011.04.24.08.07.02;	author espie;	state Exp;
branches;
next	1.14;

1.14
date	2011.04.24.08.02.07;	author espie;	state Exp;
branches;
next	1.13;

1.13
date	2011.04.18.14.00.57;	author espie;	state Exp;
branches;
next	1.12;

1.12
date	2011.04.05.08.23.00;	author espie;	state Exp;
branches;
next	1.11;

1.11
date	2010.12.29.12.28.23;	author espie;	state Exp;
branches;
next	1.10;

1.10
date	2010.11.01.12.24.47;	author espie;	state Exp;
branches;
next	1.9;

1.9
date	2010.10.31.11.07.20;	author espie;	state Exp;
branches;
next	1.8;

1.8
date	2010.10.30.11.19.38;	author espie;	state Exp;
branches;
next	1.7;

1.7
date	2010.10.29.11.51.42;	author espie;	state Exp;
branches;
next	1.6;

1.6
date	2010.10.28.14.54.38;	author espie;	state Exp;
branches;
next	1.5;

1.5
date	2010.10.27.22.53.32;	author espie;	state Exp;
branches;
next	1.4;

1.4
date	2010.10.26.15.45.09;	author espie;	state Exp;
branches;
next	1.3;

1.3
date	2010.10.24.10.01.57;	author espie;	state Exp;
branches;
next	1.2;

1.2
date	2010.08.20.15.22.21;	author espie;	state Exp;
branches;
next	1.1;

1.1
date	2010.08.20.13.42.29;	author espie;	state Exp;
branches;
next	;


desc
@@


1.121
log
@keep a global cache of distfile checksum while scanning, allows us to avoid
rescanning the same distfile 50 times...

also display elapsed time at end of build (cosmetic) since that's now trivial
@
text
@#! /usr/bin/perl

# ex:ts=8 sw=4:
# $OpenBSD: dpb,v 1.120 2016/05/17 14:50:36 espie Exp $
#
# Copyright (c) 2010-2013 Marc Espie <espie@@openbsd.org>
#
# Permission to use, copy, modify, and distribute this software for any
# purpose with or without fee is hereby granted, provided that the above
# copyright notice and this permission notice appear in all copies.
#
# THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
# ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
# OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

use strict;
use warnings;
my $ports1;
use FindBin;
BEGIN {
	$ports1 = $ENV{PORTSDIR} || '/usr/ports';
}

use lib ("$ports1/infrastructure/lib", "$FindBin::Bin/../lib");

package main;


use DPB::State;
use DPB::PkgPath;
use DPB::Core;
use DPB::Core::Init;
use DPB::HostProperties;
use DPB::Shell;
use DPB::Host;
use DPB::Vars;
use DPB::PortInfo;
use DPB::Engine;
use DPB::PortBuilder;
use DPB::Reporter;
use OpenBSD::Error;
use DPB::Job;
use DPB::Grabber;
use DPB::Trace;

my $keep_going = 1;

my $starttime = time();

sub show_days
{
	my $days = shift;
	if ($days == 0) {
		return "";
	} elsif ($days == 1) {
		return "1 day ";
	} else {
		return "$days days ";
	}
}

sub show_time
{
	my $secs = int(shift);

	my $mn = int($secs/60);
	my $hours = int($mn/60);
	my $days= int($hours/24);
	$secs %= 60;
	$mn %= 60;
	$hours %= 24;

	return show_days($days).sprintf("%02d:%02d:%02d", $hours, $mn, $secs);
}

sub report
{
	return DPB::Util->time2string(time)." [$$]".
		($keep_going ? "" : " STOPPED!").
		" running for ".show_time(time-$starttime)."\n";
}

sub affinityclass
{
	if (DPB::Core::Init->hostcount > 1 || 
	    DPB::HostProperties->has_mem) {
		require DPB::Affinity;
		return "DPB::Affinity";
	} else {
		require DPB::AffinityStub;
		return "DPB::AffinityStub";
	}
}

my $subdirlist = {};
DPB::Trace->setup(\%SIG);

my $state = DPB::State->new('dpb');
$state->handle_options;

$state->{all} = !$state->is_interactive;

my $default_handling =
    sub {
	my ($pkgpath, $weight) = @@_;
	if (defined $weight) {
		$state->heuristics->set_weight($pkgpath);
	}
	$pkgpath->add_to_subdirlist($subdirlist);
	$state->{all} = 0;
};

$state->interpret_paths(@@{$state->{paths}}, @@ARGV,
    sub {
	&$default_handling(@@_);
    });
$state->interpret_paths(@@{$state->{ipaths}},
    sub {
	&$default_handling(@@_);
	my $p = shift;
	$p->{wantinstall} = 1;
    });
$state->interpret_paths(@@{$state->{cpaths}},
    sub {
	my $p = shift;
	$state->{dontclean}{$p->pkgpath} = 1;
    });

$state->interpret_paths(@@{$state->{xpaths}},
    sub {
	my $p = shift;
	$p->{dontjunk} = 1;
    });

if ($state->opt('a')) {
	$state->{all} = 1;
}
$state->{build_once} //= $state->{all};

DPB::Core->reap;
$state->handle_build_files;

$state->{builder} = DPB::PortBuilder->new($state);

$state->{affinity} = affinityclass()->new($state, join("/", $state->logdir, "affinity"));

$state->{engine} = DPB::Engine->new($state);
$state->{grabber} = DPB::Grabber->new($state, \&handle_non_waiting_jobs);
my $reporter = DPB::Reporter->new($state, "main", "DPB::Core", $state->engine);
DPB::Trace->set_reporter($reporter);

print "Waiting for hosts to finish STARTUP...";
while (!DPB::Core->avail) {
	DPB::Core->reap;
	sleep 1;
}

# XXX placeholder
sub reread_config
{
}

my $core = DPB::Core->get;
print "ready on ", $core->hostname, "\n";

if (!$state->{fetch_only} && !$state->{scan_only} &&
    DPB::Core::Init->hostcount == 1 && $core->prop->{jobs} == 1) {
	$core->clone->mark_ready;
	$state->{opt}{e} = 1;
}

my $dump = DPB::Util->make_hot($state->logger->append('dump'));
my $debug = DPB::Util->make_hot($state->logger->append('debug'));
DPB::Trace->set_logger($debug);

sub handle_non_waiting_jobs
{
	my $checked = 0;
	my $force_report = 0;
	my $reaped = DPB::Core->reap;
	$keep_going = !-e $state->logdir."/stop";
	if (DPB::Core->avail > 1) {
		$state->engine->recheck_errors;
	}
	if (DPB::Core->avail) {
		$state->engine->check_buildable;
		$checked = 1;
	}
	while ($keep_going && DPB::Core->avail && $state->engine->can_build) {
		$force_report = 1;
		if (!$state->engine->start_new_job) {
			my $q = $state->engine->{tobuild}{queue};
			print $debug "SPINNING ON MAIN\n";
			while (my ($k, $v) = each %{$q->{o}}) {
				print $debug $k, "=>", $v->logname, "\n";
			}
			last;
		}
	}
	while ($keep_going && DPB::Core::Fetcher->avail &&
	    $state->engine->can_fetch) {
	    	if (!$checked) {
			$state->engine->check_buildable;
			$checked = 1;
		}
		$force_report = 1;
		if (!$state->engine->start_new_fetch) {
			print $debug "SPINNING ON FETCH\n";
			my $q = $state->engine->{tofetch}{queue};
			while (my ($k, $v) = each %{$q->{o}}) {
				print $debug $k, "=>", $v->logname, "\n";
			}
			last;
		}
	}
	DPB::Core->log_concurrency(time(), $state->{concurrent});
	DPB::Core->wake_jobs;
	if ($state->want_report) {
		$reporter->report($force_report);
	}
}

sub main_loop
{
	while (1) {
		while (1) {
			handle_non_waiting_jobs();
			if (!DPB::Core->running) {
				last if !$keep_going;
				if (!$state->engine->can_build) {
					$state->engine->check_buildable(1);
					if (!$state->engine->can_build) {
						last;
					}
				}
			}
			if (DPB::Core->running) {
				DPB::Core->reap_wait;
			}
			if ($state->{fetch_only}) {
				if (!DPB::Core::Fetcher->running &&
				    (!$keep_going || !$state->engine->can_fetch)) {
					$state->engine->check_buildable;
					if (!$state->engine->can_fetch) {
						last;
					}
				}
			}
		}
		if ($state->may_ask_for_commands) {
		} elsif (!$state->opt('q') || !$state->engine->recheck_errors) {
			last;
		}
	}
}

my $skip = undef;

if (keys %$subdirlist > 0) {
	$state->grabber->grab_subdirs($core, $subdirlist, $skip);
}

if ($state->{all} && !$state->{random}) {
	# when restarting interrupted dpb,
	# find the most important paths first
	my $list = $state->engine->find_best($state->{dependencies_log}, 25);
	# if we have them, list them before the full ports tree walk.
	if (@@$list > 0) {
		$skip = {};
		for my $name (@@$list) {
			DPB::PkgPath->new($name)->add_to_subdirlist($skip);
		}
		$state->grabber->grab_subdirs($core, $skip, undef, 1);
	}
}

$state->grabber->complete_subdirs($core, $skip);

if ($state->{all}) {
	$state->grabber->grab_subdirs($core, undef, $skip);
}


$state->grabber->complete_subdirs($core);
# give back "our" core to the pool.

my $occupied = 0;

$state->grabber->forget_cache;

if ($state->{all}) {
	$state->engine->dump_dependencies;
	if (!$state->defines('NO_HISTORY')) {
		if ($state->grabber->expire_old_distfiles($core, 
		    $state->opt('e'))) {
			$occupied  = 1;
		}
	}
}

if (!$state->opt('e') && !$occupied) {
	$core->mark_ready;
}

DPB::PkgPath->sanity_check($state);
$state->engine->check_buildable;

if ($state->{scan_only}) {
	# very shortened loop
	$reporter->report;
	if (DPB::Core->running) {
		DPB::Core->reap_wait;
	}
} else {
	# and let's wait for all jobs now.
	DPB::Core->start_clock($reporter);
	main_loop();
}

$reporter->reset;
DPB::Core->cleanup;
print "Elapsed time=", show_time(time-$starttime),"\n";
print $state->engine->report;
$state->engine->end_dump($state->logger->append('dump'));
$state->engine->smart_dump($state->logger->append('summary'));
@


1.120
log
@tweaks to heuristics
1/ do subdirs on the command line first
2/ ignore errors from "preferred" dependencies (and don't register anything)
if there are actual errors beyond paths that no longer exist, we'll get them
during the next pass.
@
text
@d4 1
a4 1
# $OpenBSD: dpb,v 1.119 2016/05/16 13:47:18 espie Exp $
d293 2
d326 1
@


1.119
log
@change drastically the way LISTING starts up: let dependencies be a permanent
log.

Now that we can SKIPDIR, doing a first LISTING for most important dependencies
is not a trade-off for the full listing.

It allows dpb to start building most important stuff right away, so that
your machines start earlier.

Caveat: if that list of dependencies changes (ports renames), then you will
see errors because ports no longer exist.

I figure I have time to make errors in the first listing "not relevant"
before that becomes an actual issue.
@
text
@d4 1
a4 1
# $OpenBSD: dpb,v 1.118 2016/05/16 10:37:44 espie Exp $
d262 5
d277 1
a277 1
		$state->grabber->grab_subdirs($core, $skip);
a278 4
}

if (keys %$subdirlist > 0) {
	$state->grabber->grab_subdirs($core, $subdirlist, $skip);
@


1.118
log
@use skipped dirs for initial build
@
text
@d4 1
a4 1
# $OpenBSD: dpb,v 1.117 2016/05/16 09:50:59 espie Exp $
d265 1
a265 1
	my $list = $state->engine->find_best($state->logger->logfile("dependencies"), 10);
@


1.117
log
@better days display. somehow I thought perl would work like C and do
integer division.
@
text
@d4 1
a4 1
# $OpenBSD: dpb,v 1.116 2016/05/15 14:02:01 espie Exp $
d261 1
d268 1
a268 1
		my $actual = {};
d270 1
a270 1
			DPB::PkgPath->new($name)->add_to_subdirlist($actual);
d272 1
a272 1
		$state->grabber->grab_subdirs($core, $actual);
d277 1
a277 1
	$state->grabber->grab_subdirs($core, $subdirlist);
d280 1
a280 1
$state->grabber->complete_subdirs($core);
d283 1
a283 1
	$state->grabber->grab_subdirs($core);
@


1.116
log
@cosmetic shit for aja instead of writing useful code.
okay aja@@
@
text
@d4 1
a4 1
# $OpenBSD: dpb,v 1.115 2015/10/17 19:32:03 espie Exp $
d53 13
d70 3
a72 3
	my $mn = $secs/60;
	my $hours = $mn/60;
	my $days= $hours/24;
d77 1
a77 1
	return ($days >0.5? "$days d" : "").sprintf("%02d:%02d:%02d", $hours, $mn, $secs);
@


1.115
log
@"summary" works better if I actually call the relevant code.
@
text
@d4 1
a4 1
# $OpenBSD: dpb,v 1.114 2015/08/24 10:16:18 espie Exp $
d52 15
d71 1
a71 1
		"\n";
@


1.114
log
@a bit of interactive mode. Just hooks into the main loop and can prompt for
commands now, can't do anything serious yet.
@
text
@d4 1
a4 1
# $OpenBSD: dpb,v 1.113 2015/07/15 14:30:26 espie Exp $
d296 1
@


1.113
log
@move the tracing code into its own file. save traces/warning message in
debug.log.
@
text
@d4 1
a4 1
# $OpenBSD: dpb,v 1.112 2015/05/27 11:15:40 espie Exp $
d77 1
a77 1
$state->{all} = 1;
d194 3
a196 1
	$reporter->report($force_report);
d226 2
a227 1
		if (!$state->opt('q') || !$state->engine->recheck_errors) {
@


1.112
log
@the grabber object triggers reading existing global distinfo, and it does
not do anything else, so create it early so that we read distinfo
concurrently with hosts startup scripts
@
text
@d4 1
a4 1
# $OpenBSD: dpb,v 1.111 2015/05/10 10:00:43 espie Exp $
d22 1
a22 1
my ($ports1, $olddie, $oldwarn, $reporter);
a25 72
# inspired by Carp::Always
	$olddie = $SIG{__DIE__};
	$oldwarn = $SIG{__WARN__};
	sub trace_message
	{
		my $msg = '';
		my $x = 1;
		while (1) {
			my @@c;
			{
				package DB;
				our @@args;
				@@c = caller($x+1);
			}
			last if !@@c;
			$msg .= "$c[3](". 
			    join(', ', map { 
				    if (!defined $_) {
					'<undef>';
				    } else {
					my $string;
					eval { $string = $_->debug_dump };
					if (defined $string) {
					    "$_($string)";
					} else {
					    $_;
					}
				    }
				} @@DB::args). 
			    ") called at $c[1] line $c[2]\n";
			$x++;
		}
		return $msg;
	}

	my $trace = 1;
	if ($trace) {
		$SIG{__WARN__} = sub {
			my $a = pop @@_;
			$a =~ s/(.*)( at .*? line .*?)\n$/$1$2/s;
			push @@_, $a;
			$SIG{__WARN__} = $oldwarn;
			if (defined $reporter) {
				$reporter->myprint(&trace_message);
			} else {
				warn &trace_message;
			}
		};

		$SIG{__DIE__} = sub {
	 		die @@_ if $^S;
			my $a = pop @@_;
			$a =~ s/(.*)( at .*? line .*?)\n$/$1$2/s;
			push @@_, $a;
			if (defined $reporter) {
				$reporter->reset_cursor;
			}
			$SIG{__DIE__} = $olddie;
			die join("\n", @@_, &trace_message);
		};

		$SIG{INFO} = sub {
			print "Trace:\n", &trace_message;
			sleep 1;
		};
	}

}

END {
	$SIG{__DIE__} = $olddie;
	$SIG{__WARN__} = $oldwarn;
d48 1
d72 1
d125 2
a126 1
$reporter = DPB::Reporter->new($state, "main", "DPB::Core", $state->engine);
d150 1
@


1.111
log
@forgot to synch with the rest
@
text
@d4 1
a4 1
# $OpenBSD: dpb,v 1.110 2014/12/25 15:14:14 espie Exp $
d194 1
d196 1
a296 2

$state->{grabber} = DPB::Grabber->new($state, \&handle_non_waiting_jobs);
@


1.110
log
@regorg code, no actual change
@
text
@d4 1
a4 1
# $OpenBSD: dpb,v 1.109 2014/12/22 09:05:24 espie Exp $
d65 1
a65 1
			$a =~ s/(.*)( at .*? line .*?\n$)/$1/s;
d78 1
a78 1
			$a =~ s/(.*)( at .*? line .*?\n$)/$1/s;
d215 2
a216 2
my $dump = DPB::Util->make_hot($state->logger->open('dump'));
my $debug = DPB::Util->make_hot($state->logger->open('debug'));
d360 1
a360 1
$state->engine->end_dump($state->logger->open('dump'));
@


1.109
log
@display something while waiting for STARTUP to finish
@
text
@d4 1
a4 1
# $OpenBSD: dpb,v 1.108 2014/04/28 12:51:41 espie Exp $
d109 3
@


1.108
log
@make HISTORY_ONLY work again... I managed to break it twice :)
@
text
@d4 1
a4 1
# $OpenBSD: dpb,v 1.107 2014/03/17 10:49:19 espie Exp $
d192 1
d204 1
@


1.107
log
@my tracer used lexical $_
@
text
@d4 1
a4 1
# $OpenBSD: dpb,v 1.106 2014/03/15 09:51:27 espie Exp $
d196 6
d204 1
a204 1
if (!$state->{fetch_only} && 
@


1.106
log
@tweak waiting-for-lock mechanism: explicitly keep track of order,
and have each job relinquishing lock wake up the next one.

To cater for external dpbs, also try to wake up next job if we don't own the
lock.
@
text
@d4 1
a4 1
# $OpenBSD: dpb,v 1.105 2014/03/09 19:47:35 espie Exp $
d64 3
a66 3
			my $_ = pop @@_;
			s/(.*)( at .*? line .*?\n$)/$1/s;
			push @@_, $_;
d77 3
a79 3
			my $_ = pop @@_;
			s/(.*)( at .*? line .*?\n$)/$1/s;
			push @@_, $_;
@


1.105
log
@restore BUILD_ONCE optimization for full ports builds
@
text
@d4 1
a4 1
# $OpenBSD: dpb,v 1.104 2013/10/18 07:48:09 espie Exp $
d248 1
@


1.104
log
@restore tracing, unintentional removal
@
text
@d4 1
a4 1
# $OpenBSD: dpb,v 1.103 2013/10/18 07:45:41 espie Exp $
d181 1
@


1.103
log
@simplify. The limiter does a good enough job of throttling the display,
so we can try to report every time, independently of the clock job.
@
text
@d4 1
a4 1
# $OpenBSD: dpb,v 1.102 2013/10/13 18:31:50 espie Exp $
d61 1
a61 1
	my $trace = 0;
@


1.102
log
@- use separated Heuristics::Size object
- choose size/nosize in Config.
- use affinity or affinitystub
- move locker creation to State, so we can init cores right away.
- as core init has run, we can call DPB::Core->reap (event loop) while
processing size and build stats, so that the startup script may start
slightly earlier.
- setup more options in Config for Reporter to use.
- scaffolding in SubEngine/Build to be able to use affinity info right away
@
text
@d4 1
a4 1
# $OpenBSD: dpb,v 1.101 2013/10/11 10:26:44 espie Exp $
a205 2
my $last_time = time() - $state->{display_timeout};

d208 1
a208 2
	my $need_clock = shift;
	my $checked = !$need_clock; # XXX
d246 2
a247 11
	my $current = time();
	DPB::Core->log_concurrency($current, $state->{concurrent});
	if ($need_clock) {
		if ($current >= $last_time + $state->{display_timeout} ||
		    $reaped) {
			$reporter->report($force_report);
			$last_time = $current;
		}
	} else {
		$reporter->report($force_report);
	}
d254 1
a254 1
			handle_non_waiting_jobs(0);
d283 1
a283 2
$state->{grabber} = DPB::Grabber->new($state,
    sub { handle_non_waiting_jobs(1) });
@


1.101
log
@trying to figure out the spinning...
@
text
@d4 1
a4 1
# $OpenBSD: dpb,v 1.100 2013/10/09 06:21:38 espie Exp $
a114 1
use DPB::Locks;
d127 12
a142 2
$state->{locker} = DPB::Locks->new($state, $state->{lockdir});
DPB::Core::Init->init_cores($state);
d182 1
d187 2
a188 1
$state->{affinity} = DPB::Affinity->new($state, join("/", $state->logdir, "affinity"));
@


1.100
log
@this should work around the spinning loop in fetch.
I still don't understand how it happens, since the queue
ought to be empty ?
@
text
@d4 1
a4 1
# $OpenBSD: dpb,v 1.99 2013/10/06 15:49:22 espie Exp $
d193 1
d214 5
d230 5
@


1.99
log
@fix -F mode... subengine not yet ready to be split,
and we DON'T want an extra build job.
@
text
@d4 1
a4 1
# $OpenBSD: dpb,v 1.98 2013/10/06 14:03:07 espie Exp $
d61 1
a61 1
	my $trace = 1;
a210 1
		$state->engine->start_new_job;
d212 3
a221 1
		$state->engine->start_new_fetch;
d223 3
@


1.98
log
@special-case single core/single job: create a clone so that we start
building stuff in parallel with LISTING, and fold back LISTING at end.
@
text
@d4 1
a4 1
# $OpenBSD: dpb,v 1.97 2013/10/06 13:33:24 espie Exp $
d186 2
a187 1
if (DPB::Core::Init->hostcount == 1 && $core->prop->{jobs} == 1) {
@


1.97
log
@update my copyright to 2013
@
text
@d4 1
a4 1
# $OpenBSD: dpb,v 1.96 2013/10/02 09:00:34 espie Exp $
d185 6
@


1.96
log
@clean-up code a bit, move state into its own file
@
text
@d4 1
a4 1
# $OpenBSD: dpb,v 1.95 2013/09/18 15:30:40 espie Exp $
d6 1
a6 1
# Copyright (c) 2010 Marc Espie <espie@@openbsd.org>
@


1.95
log
@use a "shell" to run getvars, so that we can run it again LATER.
@
text
@d4 1
a4 1
# $OpenBSD: dpb,v 1.94 2013/09/03 09:44:05 espie Exp $
a101 336
package DPB::State;
our @@ISA = qw(OpenBSD::State);

use OpenBSD::State;
use OpenBSD::Paths;
use DPB::Heuristics;
use DPB::PkgPath;
use DPB::Logger;
use DPB::Affinity;
use DPB::Config;
use File::Path;
use File::Basename;
use DPB::Core;

sub define_present
{
	my ($self, $k) = @@_;
	return defined $self->{subst}{$k};
}

sub init
{
	my $self = shift;
	$self->SUPER::init;
	$self->{no_exports} = 1;
	$self->{heuristics} = DPB::Heuristics->new($self);
	$self->{make} = $ENV{MAKE} || OpenBSD::Paths->make;
	($self->{ports}, $self->{portspath}, $self->{repo}, $self->{localarch},
	    $self->{distdir}, $self->{localbase}) =
		DPB::Vars->get(DPB::Shell::Local->new, $self->make,
		"PORTSDIR", "PORTSDIR_PATH", "PACKAGE_REPOSITORY", 
		"MACHINE_ARCH", "DISTDIR", "LOCALBASE");
	$self->{arch} = $self->{localarch};
	$self->{portspath} = [ split(/:/, $self->{portspath}) ];
	$self->{starttime} = time();

	return $self;
}

sub startdate
{
	my $self = shift;
	my @@l = gmtime $self->{starttime};
	$l[5] += 1900;
	$l[4] ++;
	return sprintf '%04d-%02d-%02d@@%02d:%02d:%02d', @@l[5,4,3,2,1,0];
}

sub expand_path
{
	my ($self, $path) = @@_;
	$path =~ s/\%L/$self->{logdir}/g;
	$path =~ s/\%p/$self->{ports}/g;
	$path =~ s/\%h/DPB::Core::Local->hostname/ge;
	$path =~ s/\%a/$self->{arch}/g;
	$path =~ s/\%t/$self->{starttime}/g;
	$path =~ s/\%d/$self->startdate/ge;
	$path =~ s/\%f/$self->{distdir}/g;
	return $path;
}

sub interpret_path
{
	my ($state, $path, $do, $scale) = @@_;

	my $weight;
	if ($path =~ s/\=(.*)//) {
		$weight = $1;
	}
	if ($path =~ s/\*(\d+)$//) {
		$scale = $1;
	}
	$path =~ s/\/+$//;
	$path =~ s/^\.\/+//;
	my $p = DPB::PkgPath->new($path);
	if (defined $scale) {
		$p->{scaled} = $scale;
	}
	for my $d (@@{$state->{portspath}}) {
		if (-d join('/', $d , $p->pkgpath)) {
			&$do($p, $weight);
			return;
	   	} 
	}
	$state->usage("Bad package path: #1", $path);
}

sub interpret_paths
{
	my $state = shift;
	my $do = pop;
	for my $file (@@_) {
		my $scale;
		if ($file =~ s/\*(\d+)$//) {
			$scale = $1;
		}

		if (-f $file) {
			open my $fh, '<', $file or
			    $state->usage("Can't open $file");
			my $_;
			while (<$fh>) {
				chomp;
				s/\s*(?:\#.*)?$//;
				next if m/^$/;
				$state->interpret_path($_, $do, $scale);
			}
		} else {
			$state->interpret_path($file, $do);
		}
	}
}

sub handle_options
{
	my $state = shift;
	DPB::Config->parse_command_line($state);
	$state->parse_size_file;

	$state->{logger} = DPB::Logger->new($state->logdir, $state->opt('c'));
	DPB::Limiter->setup($state->logger);
	$state->heuristics->set_logger($state->logger);
	
	$state->{concurrent} = $state->{logger}->open("concurrent");
}

sub SUPER_handle_options
{
	my ($state, @@p) = @@_;
	$state->SUPER::handle_options(@@p);
}

sub logger
{
	return shift->{logger};
}

sub heuristics
{
	return shift->{heuristics};
}

sub locker
{
	return shift->{locker};
}

sub stalelocks
{
	return shift->locker->{stalelocks};
}

sub builder
{
	return shift->{builder};
}

sub engine
{
	return shift->{engine};
}

sub grabber
{
	return shift->{grabber};
}

sub make
{
	return shift->{make};
}

sub make_args
{
	my $self = shift;
	my @@l = ($self->{make});
	if ($self->{build_once}) {
		push(@@l, 'BUILD_ONCE=Yes');
	}
	return @@l;
}

sub ports
{
	return shift->{ports};
}

sub fullrepo
{
	return shift->{fullrepo};
}

sub distdir
{
	return shift->{distdir};
}

sub localarch
{
	return shift->{localarch};
}

sub arch
{
	return shift->{arch};
}

sub logdir
{
	return shift->{logdir};
}

sub parse_build_line
{
	return split(/\s+/, shift);
}

sub parse_build_file
{
	my ($state, $fname) = @@_;
	if (!-f $fname) {
		my $arch = $state->arch;
		if (-f "$fname/$arch/build.log") {
			$fname = "$fname/$arch/build.log";
		} elsif (-f "$fname/build.log") {
			$fname = "$fname/build.log";
		}
	}
	open my $fh, '<', $fname or return;
	my $_;
	while (<$fh>) {
		chomp;
		next if $_ =~ m/!$/;
		my ($pkgpath, $host, $time, $sz, @@rest) = parse_build_line($_);
		next if !defined $sz;
		my $o = DPB::PkgPath->new($pkgpath);
		push(@@{$o->{stats}}, {host => $host, time => $time, sz => $sz});
	}
}

sub add_build_info
{
	my ($state, @@consumers) = @@_;
	for my $p (DPB::PkgPath->seen) {
		next unless defined $p->{stats};
		my ($i, $time, $sz, $host);
		for my $s (@@{$p->{stats}}) {
			$time += $s->{time};
			$sz += $s->{sz};
			$i++;
			$host = $s->{host}; # XXX
		}
		for my $c (@@consumers) {
			$c->add_build_info($p, $host, $time/$i, $sz/$i);
		}
	}
}

sub rewrite_build_info
{
	my $state = shift;
	File::Path::mkpath(File::Basename::dirname($state->{permanent_log}));
	open my $f, '>', $state->{permanent_log}.'.part' or return;
	for my $p (sort {$a->fullpkgpath cmp $b->fullpkgpath}
	    DPB::PkgPath->seen) {
		next unless defined $p->{stats};
		shift @@{$p->{stats}} while @@{$p->{stats}} > 10;
		for my $s (@@{$p->{stats}}) {
			print $f join(' ', $p->fullpkgpath, $s->{host},
			    $s->{time}, $s->{sz}), "\n";
		}
		delete $p->{stats};
	}
	close $f;
	rename $state->{permanent_log}.'.part', $state->{permanent_log};
}

sub handle_build_files
{
	my $state = shift;
	return if $state->{fetch_only};
	return unless defined $state->{build_files};
	print "Reading build stats...";
	for my $file (@@{$state->{build_files}}) {
		$state->parse_build_file($file);
	}
	$state->add_build_info($state->heuristics, "DPB::Job::Port");
	print "zapping old stuff...";
	$state->rewrite_build_info($state->{permanent_log});
	print "Done\n";
	$state->heuristics->finished_parsing;
}

sub parse_size_file
{
	my $state = shift;
	return if $state->{fetch_only};
	open my $fh, '<', $state->opt('S') // $state->{size_log}  or return;

	print "Reading size stats...";
	File::Path::mkpath(File::Basename::dirname($state->{size_log}));

	my $rewrite = {};
	my $_;
	while (<$fh>) {
		chomp;
		my $pkgname;
		my ($pkgpath, $sz, $sz2) = split(/\s+/, $_);
		my $i = " $sz";
		if ($pkgpath =~ m/^(.*)\((.*)\)$/) {
			($pkgpath, $pkgname) = ($1, $2);
			if ($state->opt('S')) {
				undef $pkgname;
			} else {
				$i ="($pkgname) $sz";
			}
		}
		if (defined $sz2) {
			$sz += $sz2;
			$i .=" $sz2";
		}
		$rewrite->{$pkgpath} = $i;
		my $o = DPB::PkgPath->new($pkgpath);
		DPB::Heuristics->add_size_info($o, $pkgname, $sz);
	}
	close $fh;
	print "zapping old stuff...";
	open $fh, '>', $state->{size_log}.'.part' or return;
	for my $p (sort keys %$rewrite) {
		print $fh "$p$rewrite->{$p}\n";
	}
	close $fh;
	print "Done\n";
	rename $state->{size_log}.'.part', $state->{size_log};
}

d105 1
@


1.94
log
@reorganize code, so the periodic sleeper task no longer knows
its sleeping interval, but rather asks it from the reporter.

Give limiter customer access to timing information. Eventually,
the reporter could possibly shrink/enlarge the display timeout
automatically.
@
text
@d4 1
a4 1
# $OpenBSD: dpb,v 1.93 2013/07/04 17:45:34 jasper Exp $
d114 1
d131 1
a131 1
		DPB::Vars->get($self->make,
@


1.93
log
@allow dpb to install packages with a non-standard localbase

ok espie@@
@
text
@d4 1
a4 1
# $OpenBSD: dpb,v 1.92 2013/06/21 09:05:18 espie Exp $
d654 1
a654 1
	DPB::Core->start_clock($state->{display_timeout});
@


1.92
log
@disentangle the config/init code from the rest.

- move the meat of handle_options from dpb into config->parse_command_line
(this means a backcall to still inherit from OpenBSD::State).
- move parse_config_files from core into config.
- move the prop handling into proper HostProperties (part of config
obviously)
- create a Core::Init file that contains all the former DPB::Host::Factory
and associated jobs.

there's still a wee little bit of cleanup to do, but this should be
easier to maintain, as all option handling is now in one place, and
startup and host confi is now easier to figure out.

- add a -DMIRROR=0/1  setup that controls whether SUPDISTFILES will be
fetched (defaults to 1 for -F and 0 for -f).

- actually allow for several host files to be parsed, as the name implies
@
text
@d4 1
a4 1
# $OpenBSD: dpb,v 1.91 2013/06/04 03:20:36 espie Exp $
d128 5
a132 4
	($self->{ports}, $self->{portspath}, $self->{repo}, $self->{localarch}, $self->{distdir}) =
	    DPB::Vars->get($self->make,
	    "PORTSDIR", "PORTSDIR_PATH", "PACKAGE_REPOSITORY", 
	    "MACHINE_ARCH", "DISTDIR");
@


1.91
log
@-DSYSLOG will syslog most activity from jobs starting/ending.

THIS IS A VERY BUSY OPTION. It's intended with a syslog.conf that
will send the log messages elsewhere, to try to pinpoint hang/panic
locations in a given port build, as system crash failures tend to leave
log files in a lagging state.

idea discussed with kurt@@
@
text
@d4 1
a4 1
# $OpenBSD: dpb,v 1.90 2013/05/21 20:44:08 espie Exp $
d111 1
d216 1
a216 99
	$state->{dontclean} = {};
	$state->{opt} = {
		A => sub {
			$state->{arch} = shift;
		},
		L => sub {
			$state->{logdir} = shift;
		},
		l => sub {
			$state->{lockdir} = shift;
		},
		r => sub {
			$state->{random} = 1;
			$state->heuristics->random;
		},
		P => sub {
			push(@@{$state->{paths}}, shift);
		},
		I => sub {
			push(@@{$state->{ipaths}}, shift);
		},
		C => sub {
			push(@@{$state->{cpaths}}, shift);
		},
		X => sub {
			push(@@{$state->{xpaths}}, shift);
		},
		b => sub {
			push(@@{$state->{build_files}}, shift);
		},
	};

	$state->SUPER::handle_options('acemqrRstuUvh:S:xX:A:C:f:F:I:j:J:M:p:P:b:l:L:',
    "[-acemrRsuUvx] [-A arch] [-C plist] [-f N] [-F N] [-I plist] [-J p] [-j N]",
    "[-p parallel] [-P plist] [-h hosts] [-L logdir] [-l lockdir] [-b log]",
    "[-M threshold] [-X plist] [path ...]");
    	$state->{fullrepo} = join("/", $state->{repo}, $state->arch, "all");
	$state->{logdir} //= $ENV{LOGDIR} // '%p/logs/%a';
	$state->{lockdir} //= "%L/locks";
	if (defined $state->{opt}{F}) {
		if (defined $state->{opt}{j} || defined $state->{opt}{f}) {
			$state->usage("Can't use -F with -f or -j");
		}
		$state->{fetch_only} = 1;
		$state->{opt}{f} = $state->{opt}{F};
		$state->{opt}{j} = 1;
		$state->{opt}{e} = 1;
	}
	$state->{opt}{f} //= 2;
	if (defined $state->opt('j')) {
		if ($state->localarch ne $state->arch) {
			$state->usage(
		    "Can't use -j if -A arch is not local architecture");
		}
		if ($state->opt('j') !~ m/^\d+$/) {
			$state->usage("-j takes a numerical argument");
		}
	}
	if ($state->opt('f') !~ m/^\d+$/) {
		$state->usage("-f takes a numerical argument");
	}
	if ($state->opt('f')) {
		$state->{want_fetchinfo} = 1;
	}
	if (!$state->{subst}->empty('HISTORY_ONLY')) {
		$state->{want_fetchinfo} = 1;
		$state->{opt}{f} = 0;
		$state->{opt}{j} = 1;
		$state->{opt}{e} = 1;
		$state->{all} = 1;
		$state->{scan_only} = 1;
		# XXX not really random, but no need to use dependencies
		$state->{random} = 1;
	}

	if ($state->opt('t')) {
		$state->{tests} = 1;
	}
	$state->{logdir} = $state->expand_path($state->{logdir});
	$state->{lockdir} = $state->expand_path($state->{lockdir});
	if ($state->opt('h')) {
		$state->{config} = $state->expand_path($state->opt('h'));
	}
	if (!$state->{subst}->value("NO_BUILD_STATS")) {
		push @@{$state->{build_files}}, "%f/build-stats/%a";
	}
#	if (!$state->{xpaths}) {
#		$state->{xpaths} = ["%p/infrastructure/db/precious"];
#	}
	for my $cat (qw(build_files paths ipaths cpaths xpaths)) {
		next unless defined $state->{$cat};
		for my $f (@@{$state->{$cat}}) {
			$f = $state->expand_path($f);
		}
	}
	$state->{size_log} = "%f/build-stats/%a-size";

	$state->{permanent_log} = $state->{build_files}[-1];
	$state->{size_log} = $state->expand_path($state->{size_log});
d222 1
a222 6
	$state->{display_timeout} =
	    $state->{subst}->value('DISPLAY_TIMEOUT') // 10;
	$state->{build_once} = $state->{all};
	if ($state->defines("DONT_BUILD_ONCE")) {
		$state->{build_once} = 0;
	}
a223 63
	$state->parse_config_files;
}

sub parse_config_files
{
	my $state = shift;

	my $override_prop = {};

	if ($state->opt('j')) {
		$override_prop->{jobs} = $state->opt('j');
	}
	if ($state->opt('p')) {
		$override_prop->{parallel} = $state->opt('p');
	}
	if ($state->define_present('STUCK_TIMEOUT')) {
		$override_prop->{stuck} = 
		    $state->{subst}->value('STUCK_TIMEOUT');
	}
	if ($state->define_present('FETCH_TIMEOUT')) {
		$override_prop->{fetch_timeout} = 
		    $state->{subst}->value('FETCH_TIMEOUT');
	}
	if ($state->define_present('SMALL_TIME')) {
		$override_prop->{small} = 
		    $state->{subst}->value('SMALL_TIME');
	}
	if ($state->define_present('CONNECTION_TIMEOUT')) {
		$override_prop->{timeout} = 
		    $state->{subst}->value('CONNECTION_TIMEOUT');
	}
	if ($state->define_present('WAIT_TIMEOUT')) {
		$override_prop->{wait_timeout} = 
		    $state->{subst}->value('WAIT_TIMEOUT');
	}
	if ($state->opt('J')) {
		$override_prop->{junk} = $state->opt('J');
	}
	if ($state->defines("ALWAYS_CLEAN")) {
		$override_prop->{always_clean} = 1;
	}
	if ($state->opt('M')) {
		$override_prop->{mem} = $state->opt('M');
	}

	if ($state->define_present('SYSLOG')) {
		require Sys::Syslog;
		Sys::Syslog::openlog('dpb', "nofatal");
		$override_prop->{syslog} = 1;
	}
	my $default_prop = {
		junk => 150, 
		parallel => '/2',
		wait_timeout => 600,
		small => 120,
	};

	if ($state->{config}) {
		DPB::Core->parse_hosts_file($state->{config}, $state, 
		    $default_prop, $override_prop);
	}
	$state->{default_prop} = $default_prop;
	$state->{override_prop} = $override_prop;
d226 1
a226 1
sub start_cores
d228 2
a229 10
	my $state = shift;
	if (!$state->{config}) {
		my $prop = { %{$state->{default_prop}} };
		while (my ($k, $v) = each %{$state->{override_prop}}) {
			$prop->{$k} = $v;
		}

		DPB::Core::Factory->new('localhost', $prop);
	}
	DPB::Core::Factory->init_cores($state);
d441 1
d466 1
a466 1
$state->start_cores;
@


1.90
log
@tweak 'dump-vars' run to include TEST values if run with -t.
THIS REQUIRES MOST RECENT bsd.port.mk, OTHERWISE THIS WILL BREAK BADLY.

The values are not used yet, but I fully intend to make it possible to
run non-regression tests in the not too distant future.
@
text
@d4 1
a4 1
# $OpenBSD: dpb,v 1.89 2013/04/22 10:06:12 espie Exp $
d371 5
@


1.89
log
@dump all the paths with fishy behavior at end of equiv.

this is a bit too much, but this catches:
SUBDIR=devel/py-gobject3,python3 make dump-vars DPB=Yes
devel/py-gobject3,python.BUILD_DEPENDS=graphics/py3-cairo STEM->=0.10.38:devel/gettext lang/python/3.2 STEM->=0.41.1p0:textproc/intltool devel/gmake archivers/xz
devel/py-gobject3,python.IS_INTERACTIVE=No
devel/py-gobject3,python.SUBPACKAGE=-main
devel/py-gobject3,python.FLAVOR=python3
devel/py-gobject3,python.BUILD_PACKAGES= -main -common
devel/py-gobject3,python.FULLPKGNAME=py3-gobject3-3.8.1p0
devel/py-gobject3,python.RUN_DEPENDS=STEM->=0.10.38:devel/gettext lang/python/3.2 devel/py-gobject3,-common graphics/py3-cairo
devel/py-gobject3,python.LIB_DEPENDS=STEM->=0.10.38:devel/gettext converters/libiconv devel/gobject-introspection
devel/py-gobject3,-common.BUILD_DEPENDS=graphics/py3-cairo STEM->=0.10.38:devel/gettext lang/python/3.2 STEM->=0.41.1p0:textproc/intltool devel/gmake archivers/xz
devel/py-gobject3,-common.IS_INTERACTIVE=No
devel/py-gobject3,-common.SUBPACKAGE=-main
devel/py-gobject3,-common.FLAVOR=python3
devel/py-gobject3,-common.BUILD_PACKAGES= -main -common
devel/py-gobject3,-common.FULLPKGNAME=py-gobject3-common-3.8.1
devel/py-gobject3,-common.RUN_DEPENDS=STEM->=0.10.38:devel/gettext lang/python/3.2

(note the "wrong" flavor, which means that
devel/py-gobject3,python3,-main ends up without an associated fullpkgname)
@
text
@d4 1
a4 1
# $OpenBSD: dpb,v 1.88 2013/04/13 10:02:11 espie Exp $
d247 1
a247 1
	$state->SUPER::handle_options('acemqrRsuUvh:S:xX:A:C:f:F:I:j:J:M:p:P:b:l:L:',
d290 3
@


1.88
log
@fix die handler, as it should display the message as well...
grumble

make it possible to temporarily disable those handlers.
@
text
@d4 1
a4 1
# $OpenBSD: dpb,v 1.87 2013/03/03 11:11:08 espie Exp $
d806 1
@


1.87
log
@rework INFO/DIE/WARN handler to display some info in a non-opaque way.
@
text
@d4 1
a4 1
# $OpenBSD: dpb,v 1.86 2013/03/03 00:51:57 espie Exp $
d61 13
a73 11
	$SIG{__WARN__} = sub {
		my $_ = pop @@_;
		s/(.*)( at .*? line .*?\n$)/$1/s;
		push @@_, $_;
		$SIG{__WARN__} = $oldwarn;
		if (defined $reporter) {
			$reporter->myprint(&trace_message);
		} else {
			warn &trace_message;
		}
	};
d75 11
a85 10
	$SIG{__DIE__} = sub {
		my $_ = pop @@_;
		s/(.*)( at .*? line .*?\n$)/$1/s;
		push @@_, $_;
		if (defined $reporter) {
			$reporter->reset_cursor;
		}
		$SIG{__DIE__} = $olddie;
		die &trace_message;
	};
d87 5
a91 4
	$SIG{INFO} = sub {
		print "Trace:\n", &trace_message;
		sleep 1;
	};
@


1.86
log
@tweak the carp stuff to not recurse into itself, so that compile errors
show up correctly again.

split start_cores into a read_config/start_cores part, so that read_config
can happen right after handle_options, and so that we can put more options
in the hosts file (to be done)
@
text
@d4 1
a4 1
# $OpenBSD: dpb,v 1.85 2013/02/04 09:43:57 espie Exp $
d29 32
a61 2
		require Carp;

d67 1
a67 1
			$reporter->myprint(&Carp::longmess);
d69 1
a69 1
			warn &Carp::longmess;
a73 1
		require Carp;
d81 1
a81 1
		die &Carp::longmess;
d83 6
a619 19

$SIG{INFO} = sub {
	print "Trace:\n";
	my $x = 1;
	while (1) {
		my @@c;
		{
			package DB;
			our @@args;
			@@c = caller($x);
		}
		last if !@@c;
		print "#$x: $c[3]( ", 
		    join(', ', map { defined $_ ? $_ : "<undef>" } @@DB::args), 
		    " )\n\tat line $c[2] of $c[1]\n";
		$x++;
	}
	sleep 5;
};
@


1.85
log
@some of args seen in trace might be undef'd. avoid triggering the WARN
handler while handling SIG{INFO}.
Also, have parse_size_info be verbose about what's going on.
@
text
@d4 1
a4 1
# $OpenBSD: dpb,v 1.84 2013/02/02 13:35:17 espie Exp $
d22 1
a22 1
my $ports1;
d26 33
d60 1
a62 1

d284 1
d287 1
a287 1
sub start_cores
d329 1
a329 1
	my $default_prop = { 
d340 3
d344 3
d348 2
a349 2
		my $prop = { %$default_prop };
		while (my ($k, $v) = each %$override_prop) {
a584 28

my $reporter;

# inspired by Carp::Always
$SIG{__WARN__} = sub {
	require Carp;

	my $_ = pop @@_;
	s/(.*)( at .*? line .*?\n$)/$1/s;
	push @@_, $_;
	if (defined $reporter) {
		$reporter->myprint(&Carp::longmess);
	} else {
		warn &Carp::longmess;
	}
};

$SIG{__DIE__} = sub {
	require Carp;

	my $_ = pop @@_;
	s/(.*)( at .*? line .*?\n$)/$1/s;
	push @@_, $_;
	if (defined $reporter) {
		$reporter->reset_cursor;
	}
	die &Carp::longmess;
};
@


1.84
log
@move control of the "building in mfs" part under PortsBuilder/Heuristics.
Store previous pkgname.
do show-size only sporadically if fullpkgname didn't change
@
text
@d4 1
a4 1
# $OpenBSD: dpb,v 1.83 2013/02/02 10:36:31 espie Exp $
d485 1
d512 1
d518 1
d585 3
a587 1
		print "#$x: $c[3]( ", join(', ', @@DB::args), " )\n\tat line $c[2] of $c[1]\n";
@


1.83
log
@allow for size log to contain pkgpath(pkgname) instead of just pkgpath.
make -S useful again: allow it to "prime" the log from an existing source,
but don't write back to it.
@
text
@d4 1
a4 1
# $OpenBSD: dpb,v 1.82 2013/01/28 12:23:45 espie Exp $
d496 5
a500 1
			$i ="($pkgname) $sz";
d508 1
a508 1
		DPB::Heuristics->add_size_info($o, $sz);
@


1.82
log
@add a FETCH_TIMEOUT, similar to STUCK_TIMEOUT, but slightly simpler,
as there is no speed factor there...
@
text
@d4 1
a4 1
# $OpenBSD: dpb,v 1.81 2013/01/28 10:50:46 espie Exp $
d235 1
a235 5
	if ($state->opt('S')) {
		$state->{size_log} = $state->opt('S');
	} else {
		$state->{size_log} = "%f/build-stats/%a-size";
	}
d483 1
a483 1
	open my $fh, '<', $state->{size_log} or return;
d491 1
d493 5
d500 1
a500 3
			$rewrite->{$pkgpath} = "$sz $sz2";
		} else {
			$rewrite->{$pkgpath} = $sz;
d502 1
d509 1
a509 1
		print $fh "$p $rewrite->{$p}\n";
@


1.81
log
@don't bother dumping distfiles, history is quite enough
@
text
@d4 1
a4 1
# $OpenBSD: dpb,v 1.80 2013/01/28 10:14:17 espie Exp $
d272 4
@


1.80
log
@tweak memory handling to make it less special: treat -M as an override_prop
as we should.
Use core methods to access the memory threshold.

UI simplification: -M can take a suffix, default is K, but you can just say
-M 520M or -M 2G now.
@
text
@d4 1
a4 1
# $OpenBSD: dpb,v 1.79 2013/01/28 09:56:00 espie Exp $
a747 3
	if ($state->opt('f')) {
		DPB::Distfile->dump($state->{logger});
	}
@


1.79
log
@add debugging message that does not depend on Devel::StackTrace, may be
useful to find out where dpb gets stuck
@
text
@d4 1
a4 1
# $OpenBSD: dpb,v 1.77 2013/01/21 14:50:30 espie Exp $
a157 3
		M => sub {
			$state->heuristics->set_threshold(shift);
		},
d290 3
@


1.78
log
@bump default junk  back up to 150, makes more sense with new accounting
@
text
@d562 16
a577 6
#use Devel::StackTrace;
#$SIG{INFO} = sub {
#	my $t = Devel::StackTrace->new;
#	print $t->as_string;
#	sleep 5;
#};
a636 6
$SIG{INFO} = sub {
	$state->engine->info_dump($state->logger->open('info'));
	# perl status may spew some garbage on the display,
	# remove it during next refresh
	$reporter->refresh;
};
@


1.77
log
@prompted by jasper: reintroduce -S, but as a rw option, to override
the rolling journal location for size log.

make it possible to share dpb -s output from a given architecture with
similar architectures
@
text
@d4 1
a4 1
# $OpenBSD: dpb,v 1.76 2013/01/21 12:03:32 espie Exp $
d296 1
a296 1
		junk => 100, 
@


1.76
log
@simplify wrkdir size handling, turn that into a rolling log.
@
text
@d4 1
a4 1
# $OpenBSD: dpb,v 1.75 2013/01/10 12:27:21 espie Exp $
d178 1
a178 1
	$state->SUPER::handle_options('acemqrRsuUvh:xX:A:C:f:F:I:j:J:M:p:P:b:l:L:',
d238 6
d245 1
a245 1
	$state->{size_log} = $state->expand_path("%f/build-stats/%a-size");
@


1.75
log
@don't go thru patch/configure/build for very small ports.
@
text
@d4 1
a4 1
# $OpenBSD: dpb,v 1.74 2013/01/07 10:57:31 espie Exp $
d159 1
a159 1
			$state->heuristics->set_threshold(shift)
a175 3
		S => sub {
			$state->parse_size_file(shift, $state->heuristics);
		},
d178 1
a178 1
	$state->SUPER::handle_options('acemqrRsuUvh:xX:A:C:f:F:I:j:J:M:p:P:b:l:L:S:',
d229 3
d239 2
d475 7
a481 3
	my ($state, $fname, @@consumers) = @@_;
	open my $fh, '<', $fname or
	    $state->fatal("Couldn't open build file #1: #2", $fname, $!);
d488 3
d493 6
a498 3
		for my $c (@@consumers) {
			$c->add_size_info($o, $sz);
		}
d500 2
d556 7
d620 1
a620 1
#my $dump = DPB::Util->make_hot($state->logger->open('dump'));
@


1.74
log
@fix a long-standing stupid bug. Now I know why weight changes didn't matter,
I wasn't passing them through, sigh.

Add new -X option that sets xpaths, to be used...
@
text
@d4 1
a4 1
# $OpenBSD: dpb,v 1.73 2013/01/06 11:59:40 espie Exp $
d268 4
d291 1
@


1.73
log
@ask the ports tree to clean up stale locks, finally...
@
text
@d4 1
a4 1
# $OpenBSD: dpb,v 1.72 2013/01/05 18:26:31 espie Exp $
d170 3
d181 1
a181 1
	$state->SUPER::handle_options('acemqrRsuUvh:xA:C:f:F:I:j:J:M:p:P:b:l:L:S:',
d184 1
a184 1
    "[-M threshold] [path ...]");
d232 1
a232 1
	for my $cat (qw(build_files paths ipaths cpaths)) {
d558 1
a558 2
	my $p = shift;
	&$default_handling($p);
d562 1
a563 1
	&$default_handling($p);
d570 6
@


1.72
log
@allow independent setup for the locks location. I strongly suggest
using a local fs.
@
text
@d4 1
a4 1
# $OpenBSD: dpb,v 1.71 2013/01/05 15:13:48 espie Exp $
d317 5
d538 1
a577 1
$state->{locker} = DPB::Locks->new($state, $state->{lockdir});
@


1.71
log
@fix typo
@
text
@d4 1
a4 1
# $OpenBSD: dpb,v 1.70 2013/01/05 13:34:28 espie Exp $
d78 1
d151 3
d178 1
a178 1
	$state->SUPER::handle_options('acemqrRsuUvh:xA:C:f:F:I:j:J:M:p:P:b:L:S:',
d180 2
a181 2
    "[-p parallel] [-P plist] [-h hosts] [-L logdir] [-b log] [-M threshold]",
    "[path ...]");
d184 1
d222 1
d572 1
a572 1
$state->{locker} = DPB::Locks->new($state, join("/", $state->logdir, "locks"));
@


1.70
log
@change to NO_HISTORY and document (since there are other NO_* thingies)
@
text
@d4 1
a4 1
# $OpenBSD: dpb,v 1.69 2013/01/05 13:32:28 espie Exp $
d696 1
a696 1
	if (!$state->define('NO_HISTORY')) {
@


1.69
log
@make it possible to skip "UPDATING DISTFILES" if we're just running dpb
again without any change.
@
text
@d4 1
a4 1
# $OpenBSD: dpb,v 1.68 2013/01/04 18:29:13 espie Exp $
d696 1
a696 1
	if (!$state->define('NOHISTORY')) {
@


1.68
log
@fix typo. Symptom: errors out at end of build
noticed by rpe@@
@
text
@d4 1
a4 1
# $OpenBSD: dpb,v 1.67 2013/01/04 12:46:20 espie Exp $
d696 5
a700 2
	if ($state->grabber->expire_old_distfiles($core, $state->opt('e'))) {
		$occupied  = 1;
@


1.67
log
@force report display to fire whenever some new ports get built.
@
text
@d4 1
a4 1
# $OpenBSD: dpb,v 1.66 2013/01/04 12:06:25 espie Exp $
d632 1
a632 1
				if (!$state->engine_can_build) {
@


1.66
log
@take the rate-limiting concept used for the engine, and make it available
elsewhere. Also use it for the Reporter, as it makes no sense to spend
THAT much time reporting quick changes, which actually slows the build.
($factor to tweak as needed).
@
text
@d4 1
a4 1
# $OpenBSD: dpb,v 1.65 2013/01/03 15:43:27 espie Exp $
d589 1
d601 1
d610 1
d617 1
a617 1
			$reporter->report;
d621 1
a621 1
		$reporter->report;
@


1.65
log
@fix infamous "doesn't really quit when it's done" stop bug.
also move the report to the main package, and show a prominent
STOPPED in the title bar if you forget you stopped it during a
previous run ('why is my dpb not building anything ?')
@
text
@d4 1
a4 1
# $OpenBSD: dpb,v 1.64 2012/12/28 06:40:11 espie Exp $
d232 1
@


1.64
log
@remove optimization that no longer makes sense.
@
text
@d4 1
a4 1
# $OpenBSD: dpb,v 1.63 2012/12/24 17:24:46 espie Exp $
d485 9
d568 1
a568 2
$reporter = DPB::Reporter->new($state,
    $state->heuristics, "DPB::Core", $state->engine);
a581 1
my $keep_going = 1;
a618 1
	return $keep_going;
d626 7
a632 5
			if (!DPB::Core->running &&
			    (!$keep_going || !$state->engine->can_build)) {
				$state->engine->check_buildable;
				if (!$state->engine->can_build) {
					last;
@


1.63
log
@add affinity information to restart jobs on the right host preferentially.
- affinity info is similar to locks, but with a completely different
lifetime.
- streamline the main loop of the engine, so that it can do two passes:
first pass shuns paths with the wrong affinity. If no good path is found,
those are considered during the second pass.
- make the Core factory aware of what hosts might be running, so that
affinity info for machines removed from a config file will be ignored.

thanks to landry@@ for a few tests.
@
text
@d4 1
a4 1
# $OpenBSD: dpb,v 1.62 2012/11/18 12:37:21 espie Exp $
d587 1
a587 1
		$state->engine->check_buildable(0);
d596 1
a596 1
			$state->engine->check_buildable(1);
d622 1
a622 1
				$state->engine->check_buildable(0);
d633 1
a633 1
					$state->engine->check_buildable(0);
d693 1
a693 1
$state->engine->check_buildable(1);
@


1.62
log
@more descriptive name
@
text
@d4 1
a4 1
# $OpenBSD: dpb,v 1.61 2012/11/18 01:58:36 espie Exp $
d38 1
d557 1
@


1.61
log
@allow for -DWAIT_TIMEOUT=0 to propagate correctly

lower default for junk
@
text
@d4 1
a4 1
# $OpenBSD: dpb,v 1.60 2012/11/06 08:26:29 espie Exp $
d41 1
a41 1
sub has
d253 1
a253 1
	if ($state->has('STUCK_TIMEOUT')) {
d257 1
a257 1
	if ($state->has('CONNECTION_TIMEOUT')) {
d261 1
a261 1
	if ($state->has('WAIT_TIMEOUT')) {
@


1.60
log
@don't mix up wait_timeout and waiting_timeout, as noticed by naddy@@.
re-enable wait_timeout on localhost temporarily (should be done in another
way, most probably by checking whether repo is on nfs, we can steal code
from VStat.pm)

pass umask through ssh. This took us long enough to figure out, and it's
considerably simpler than tweaking every login class once again.
@
text
@d4 1
a4 1
# $OpenBSD: dpb,v 1.59 2012/10/13 09:00:02 espie Exp $
d41 6
d253 11
a263 2
	if (my $t = $state->{subst}->value('STUCK_TIMEOUT')) {
		$override_prop->{stuck} = $t;
a264 3
	if (my $t = $state->{subst}->value('CONNECTION_TIMEOUT')) {
		$override_prop->{timeout} = $t;
    	}
a270 3
	if (my $t = $state->{subst}->value('WAIT_TIMEOUT')) {
		$override_prop->{wait_timeout} = $t;
	}
d273 1
a273 1
		junk => 250, 
@


1.59
log
@fix default property handling
@
text
@d4 1
a4 1
# $OpenBSD: dpb,v 1.58 2012/10/13 08:32:58 espie Exp $
d266 1
a266 1
		waiting_timeout => 600,
@


1.58
log
@tweaks
- waiting should know when it gets interrupted! so that it doesn't zombify
- add a time limit.
@
text
@d4 1
a4 1
# $OpenBSD: dpb,v 1.57 2012/10/12 20:24:56 espie Exp $
a182 2
	$state->{opt}{J} //= 250;
	$state->{opt}{p} //= '/2';
d263 6
d270 2
a271 1
		DPB::Core->parse_hosts_file($state->{config}, $state, $override_prop);
d275 6
a280 1
		DPB::Core::Factory->new('localhost', $override_prop);
@


1.57
log
@-DALWAYS_CLEAN: clean ports even if they errored out (that's a prop, so
always_clean=1  in hosts file.

refactor task code a bit. And fix a buglet related to the NFS check
(wrong finalize order)
@
text
@d4 1
a4 1
# $OpenBSD: dpb,v 1.56 2012/10/11 07:40:30 espie Exp $
d260 3
@


1.56
log
@change things again to have command line options override host file.
and provide the possibility of a DEFAULT entry in the host file.
@
text
@d4 1
a4 1
# $OpenBSD: dpb,v 1.55 2012/10/10 11:44:11 rpe Exp $
d257 3
@


1.55
log
@make out-of-date output directly usable for dbp
- ignore empty lines
- remove comments and whitespaces at the end of lines

ok espie@@
@
text
@d4 1
a4 1
# $OpenBSD: dpb,v 1.54 2012/10/08 12:41:03 espie Exp $
a229 3
    	$state->{connection_timeout} =
	    $state->{subst}->value('CONNECTION_TIMEOUT');
	$state->{stuck_timeout} = $state->{subst}->value('STUCK_TIMEOUT');
d241 1
a241 1
	my $default_prop = {};
d244 1
a244 1
		$default_prop->{jobs} = $state->opt('j');
d247 1
a247 1
		$default_prop->{parallel} = $state->opt('p');
d249 2
a250 2
	if ($state->{stuck_timeout}) {
		$default_prop->{stuck} = $state->{stuck_timeout};
d252 3
d256 1
a256 1
		$default_prop->{junk} = $state->opt('J');
d260 1
a260 1
		DPB::Core->parse_hosts_file($state->{config}, $state, $default_prop);
d264 1
a264 1
		DPB::Core::Factory->new('localhost', $default_prop);
@


1.54
log
@small change for people running multiple hosts:

options on the command line now define *defaults* that host files can
override (for instance -j, stuck, -p, -J).

Add -p /n to mean "take number of jobs, if >1, divide by n, round up to 2,
and use that for parallel.

Document -p.

Make junk be 'by host' (and it's a prop, so you can tweak it).

concurrent log that records how many jobs are running each time it changes.
tag parallel builds *n in the time record.
@
text
@d4 1
a4 1
# $OpenBSD: dpb,v 1.53 2012/09/23 18:13:32 espie Exp $
d122 2
a123 1
				next if m/^\#/;
@


1.53
log
@new framework to deal with the new ports cluster, to be documented
@
text
@d4 1
a4 1
# $OpenBSD: dpb,v 1.52 2012/04/10 16:58:47 espie Exp $
d166 1
a166 1
	$state->SUPER::handle_options('acemqrRstuUvh:xA:C:f:F:I:j:J:M:p:P:b:L:S:',
d168 1
a168 1
    "[-P plist] [-h hosts] [-L logdir] [-b log] [-t ctimeout] [-M threshold]",
d183 1
d228 1
a228 1
	    $state->{subst}->value('DISPLAY_TIMEOUT') // $state->opt('T') // 10;
d230 1
a230 1
	    $state->{subst}->value('CONNECTION_TIMEOUT') // $state->opt('t');
d236 1
d243 1
a243 3
	if ($state->{config}) {
		DPB::Core->parse_hosts_file($state->{config}, $state);
	}
a244 1
	my $prop = {};
d246 1
a246 1
		$prop->{jobs} = $state->opt('j');
d249 1
a249 1
		$prop->{parallel} = $state->opt('p');
d252 8
a259 1
		$prop->{stuck} = $state->{stuck_timeout};
d262 2
a263 2
	if ($state->opt('j') || !$state->{config}) {
		DPB::Core::Factory->new('localhost', $prop);
d573 2
a575 1
		my $current = time();
@


1.52
log
@always do default stats, unless we explicitly disable them with -DNO_STATS
@
text
@d4 1
a4 1
# $OpenBSD: dpb,v 1.51 2012/04/02 15:51:24 espie Exp $
d166 1
a166 1
	$state->SUPER::handle_options('acemqrRstuUvh:xA:C:f:F:I:j:J:M:P:b:L:S:',
d248 3
@


1.51
log
@have a look at PORTSDIR_PATH as well, so that we can dpb -P dir/p
under mystuff.

problem noticed by jeremy@@
@
text
@d4 1
a4 1
# $OpenBSD$
a40 1

d213 1
a213 1
	if (!defined $state->{build_files}) {
@


1.50
log
@duplicate -m option, resolve conflict by renaming old unused one to -M.

Document some new stuff
@
text
@d4 1
a4 1
# $OpenBSD: dpb,v 1.49 2012/03/09 12:51:38 espie Exp $
d49 4
a52 3
	($self->{ports}, $self->{repo}, $self->{localarch}, $self->{distdir}) =
	    DPB::Vars->get($self->make, 
	    "PORTSDIR", "PACKAGE_REPOSITORY", "MACHINE_ARCH", "DISTDIR");
d54 1
d98 5
a102 4
	if (-d join('/', $state->{ports} , $p->pkgpath)) {
		&$do($p, $weight);
	} else {
		$state->usage("Bad package path: #1", $path);
d104 1
d118 1
a118 1
			open my $fh, '<', $file or 
d207 1
a207 1
		$state->{random} = 1; 
d227 1
a227 1
	$state->{display_timeout} = 
d386 1
a386 1
	for my $p (sort {$a->fullpkgpath cmp $b->fullpkgpath} 
d391 1
a391 1
			print $f join(' ', $p->fullpkgpath, $s->{host}, 
d419 1
a419 1
	open my $fh, '<', $fname or 
d486 1
a486 1
my $default_handling = 
d497 1
a497 1
    sub { 
d502 1
a502 1
    sub { 
d508 1
a508 1
    sub { 
d533 1
a533 1
	# perl status may spew some garbage on the display, 
d557 1
a557 1
	while ($keep_going && DPB::Core::Fetcher->avail && 
d609 1
a609 1
$state->{grabber} = DPB::Grabber->new($state, 
@


1.49
log
@tweak weight handling so that fixing weights and scaling weights works.
add -m option as a reverse to -x, like in pkg_add
@
text
@d4 1
a4 1
# $OpenBSD: dpb,v 1.48 2012/03/06 11:22:40 espie Exp $
d143 1
a143 1
		m => sub {
d163 1
a163 1
	$state->SUPER::handle_options('acemqrRstuUvh:xA:C:f:F:I:j:J:m:P:b:L:S:',
d165 1
a165 1
    "[-P plist] [-h hosts] [-L logdir] [-b log] [-t ctimeout] [-m threshold]",
@


1.48
log
@create build-stats dir (noticed by Mark Patruck)
@
text
@d4 1
a4 1
# $OpenBSD: dpb,v 1.47 2012/03/05 19:43:09 espie Exp $
d84 1
a84 1
	if ($path =~ s/\^=(.*)//) {
d163 2
a164 2
	$state->SUPER::handle_options('aceqrRstuUvh:xA:C:f:F:I:j:J:m:P:b:L:S:',
    "[-acerRsuUvx] [-A arch] [-C plist] [-f N] [-F N] [-I plist] [-J p] [-j N]",
a479 2
$state->handle_build_files;

d512 3
d519 1
a519 1
$reporter = DPB::Reporter->new($state->opt('x'),
@


1.47
log
@fix -a bug: if you specify -I ..., this shouldn't negate a -a.
"permanent build log" under %f/build-stats/%a
-J250 by default
@
text
@d4 1
a4 1
# $OpenBSD: dpb,v 1.46 2012/03/02 19:35:09 espie Exp $
d38 2
d380 1
@


1.46
log
@%f for distdir (where fetched distfiles live)
@
text
@d4 1
a4 1
# $OpenBSD: dpb,v 1.45 2012/02/27 17:50:14 espie Exp $
a130 3
		a => sub {
			$state->{all} = 1;
		},
d177 1
d208 3
d217 1
d336 1
a336 1
	my ($state, $fname, @@consumers) = @@_;
d345 1
a345 2
	open my $fh, '<', $fname or 
	    $state->fatal("Couldn't open build file #1: #2", $fname, $!);
d353 16
d370 16
a385 1
			$c->add_build_info($o, $host, $time, $sz);
d387 1
d389 2
d396 1
d398 1
d400 1
a400 2
		$state->parse_build_file($file, $state->heuristics, 
		    "DPB::Job::Port");
d402 4
d508 3
@


1.45
log
@tweak so that dpb -I misc/screen/
will work
@
text
@d4 1
a4 1
# $OpenBSD: dpb,v 1.44 2012/02/27 15:37:36 espie Exp $
d73 1
@


1.44
log
@let's do error messages differently: get die to reset_cursor and die
(reverse-override reporter), and get warn to use myprint (and need for
tabs to become spaces in that case...)
@
text
@d4 1
a4 1
# $OpenBSD: dpb,v 1.43 2012/02/27 14:51:37 espie Exp $
d87 2
@


1.43
log
@allow -I/-P/-C and command-line arguments to be lists of pkgpaths, or pkgpath
(it's easy to distinguish between a file and a directory under ports).

expand sequences for those files and hosts

when restarting dpb, kill locks that don't correspond to errors, but to a dpb
running on the same host that's no longer there.

do __WARN__ like __DIE__

option -DDONT_BUILD_ONCE
option -DDONT_CLEAN_LOCKS

document some
@
text
@d4 1
a4 1
# $OpenBSD: dpb,v 1.42 2012/02/17 07:35:42 espie Exp $
a28 22
# inspired by Carp::Always

$SIG{__DIE__} = sub {
	require Carp;

	die @@_ if ref $_[0];
	my $_ = pop @@_;
	s/(.*)( at .*? line .*?\n$)/$1/s;
	push @@_, $_;
	die &Carp::longmess;
};


$SIG{__WARN__} = sub {
	require Carp;

	die @@_ if ref $_[0];
	my $_ = pop @@_;
	s/(.*)( at .*? line .*?\n$)/$1/s;
	push @@_, $_;
	warn &Carp::longmess;
};
d84 3
d104 2
a105 2
		if ($file =~ m/^(.*)\*(\d+)$/) {
			($file, $scale) = ($1, $2);
d400 28
d469 1
a469 1
my $reporter = DPB::Reporter->new($state->opt('x'),
@


1.42
log
@allow weights to be scaled
add longer traceback in case we die
@
text
@d4 1
a4 1
# $OpenBSD: dpb,v 1.41 2012/01/30 15:11:04 espie Exp $
d42 10
d73 1
d78 64
d164 1
a164 18
			my $file = shift;
			my $scale;
			if ($file =~ m/^(.*)\*(\d+)$/) {
				($file, $scale) = ($1, $2);
			}

			open my $fh, '<', $file or die "Can't open $file\n";
			my $_;
			while (<$fh>) {
				chomp;
				next if m/^\#/;
				push @@main::ARGV, $_;
				if (defined $scale) {
					s/\^=.*//;
					my $p = DPB::PkgPath->new($_);
					$p->{scaled} = $scale;
				}
			}
d167 1
a167 18
			my $file = shift;
			my $scale;
			if ($file =~ m/^(.*)\*(\d+)$/) {
				($file, $scale) = ($1, $2);
			}
			open my $fh, '<', $file or die "Can't open $file\n";
			my $_;
			while (<$fh>) {
				chomp;
				next if m/^\#/;
				push @@main::ARGV, $_;
				s/\^=.*//;
				my $p = DPB::PkgPath->new($_);
				$p->{wantinstall} = 1;
				if (defined $scale) {
					$p->{scaled} = $scale;
				}
			}
d170 1
a170 9
			my $file = shift;
			open my $fh, '<', $file or die "Can't open $file\n";
			my $_;
			while (<$fh>) {
				chomp;
				next if m/^\#/;
				s/\,.*//;
				$state->{dontclean}{$_} = 1;
			}
d185 1
a185 2
	$state->{logdir} //= $ENV{LOGDIR} // 
	    join("/", $state->ports, "logs", $state->arch);
d221 12
d240 4
d250 2
a251 2
	if ($state->opt('h')) {
		DPB::Core->parse_hosts_file($state->opt('h'), $state);
d262 1
a262 1
	if ($state->opt('j') || !$state->opt('h')) {
d307 1
a307 1
	if ($self->{all}) {
d427 7
a433 11
if (@@ARGV == 0) {
	$state->{all} = 1;
}
for my $arg (@@ARGV) {
	my ($path, $weight) = ($arg, 5000);
	if ($arg =~ m/^(.*)\=(\d+)$/) {
		($path, $weight) = ($1, $2);
	}
	$arg =~ s/\/+$//;
	if ($arg =~ m/^\./) {
		$state->usage("Invalid pkgpath: #1",  $arg);
a434 2
	my $pkgpath = DPB::PkgPath->new($path);
	$state->heuristics->set_weight($pkgpath, $weight);
d436 19
a454 1
}
d458 1
a458 1
$state->{locker} = DPB::Locks->new(join("/", $state->logdir, "locks"));
@


1.41
log
@finish distfiles history handling: people who don't fetch/build the whole
tree may want to weed distfiles too, so allow for a full scan of the tree
without building/fetching anything, just to update history:

dpb -DHISTORY_ONLY

(just requires making sure the right engines are created, and a very shortened
loop at end waiting for history to be updated).
@
text
@d4 1
a4 1
# $OpenBSD: dpb,v 1.40 2012/01/09 17:56:28 espie Exp $
d29 12
d90 5
d101 5
d110 4
d123 3
a382 1
	$arg =~ s/\/+$//;
d387 1
@


1.40
log
@run "expire_old" as a separate job, since it may take some time.
find files under $DISTDIR, anything we don't know about should also
end up in history.
@
text
@d4 1
a4 1
# $OpenBSD: dpb,v 1.39 2012/01/08 20:28:37 espie Exp $
d147 13
a503 1
# and let's wait for all jobs now.
d506 11
a516 2
DPB::Core->start_clock($state->{display_timeout});
main_loop();
@


1.39
log
@give dpb more knowledge about distfiles.
- keep a stash indexed by checksum, so dpb can identify duplicate files.
- in a full bulk, if the scan has no errors, write to a ${DISTDIR}/history
file  the files encountered in ${DISTDIR}/distinfo that seem to no longer
be needed (with full timestamp and checksum info).

Should be enough info to know when to expire old DISTDIR entries.
@
text
@d4 1
a4 1
# $OpenBSD: dpb,v 1.38 2011/12/10 14:48:40 espie Exp $
d475 1
a475 4
if (!$state->opt('e')) {
	$core->mark_ready;
}
# and let's wait for all jobs now.
d482 3
a484 1
	$state->grabber->expire_old_distfiles;
d487 5
@


1.38
log
@on SIGINFO, dump T/B hashes into info.log (and mark the display for refresh,
as the shell might muck it with its own information)
@
text
@d4 1
a4 1
# $OpenBSD: dpb,v 1.37 2011/12/05 21:22:35 espie Exp $
d485 1
@


1.37
log
@truly random mode shouldn't peek at most frequent dependencies !
@
text
@d4 1
a4 1
# $OpenBSD: dpb,v 1.36 2011/12/05 16:10:00 espie Exp $
d366 6
@


1.36
log
@turn -J into an option taking a number.
always run show-prepare-results, and always serialize
depends/prepare/show-prepare-results(/junk) on a single host.
@
text
@d4 1
a4 1
# $OpenBSD: dpb,v 1.35 2011/12/04 12:05:41 espie Exp $
d70 1
d441 1
a441 1
if ($state->{all}) {
@


1.35
log
@clean-up job running a bit: add methods to Grabber and PortBuilder objects
to access more stuff they need.

Remove distantshell->make, ask state instead.
Provide state with the program we run, and the parameters we pass it.

- same make for distant and local hosts
- pass BUILD_ONCE=Yes if -a.
@
text
@d4 1
a4 1
# $OpenBSD: dpb,v 1.34 2011/12/04 11:24:38 espie Exp $
d117 2
a118 2
	$state->SUPER::handle_options('aceJqrRstuUvh:xA:C:f:F:I:j:m:P:b:L:S:',
    "[-aceJrRsuUvx] [-A arch] [-C plist] [-f N] [-F N] [-I plist] [-j N]",
@


1.34
log
@not ideal, but will now stop at the end of a -F run.
@
text
@d4 1
a4 1
# $OpenBSD: dpb,v 1.33 2011/12/03 11:01:47 espie Exp $
d210 10
@


1.33
log
@fix quick-start: the interface to grabber changed in a silent way.

explicitly move the main_loop near handle_non_waiting_jobs to try to
fix that mess (and finish all the time)
@
text
@d4 1
a4 1
# $OpenBSD: dpb,v 1.32 2011/12/02 22:33:46 espie Exp $
d410 9
@


1.32
log
@new junk option (to remove packages as they're no longer needed) to pass
around thru JobBuilder (along with locks since we need to write stuff into
that file)
@
text
@d4 1
a4 1
# $OpenBSD: dpb,v 1.31 2011/11/26 11:46:15 espie Exp $
d396 22
d427 4
a430 1
		my $actual = map {($_,1)} @@$list;
d460 1
a460 1
#$state->engine->dump($dump);
a461 1
#$state->engine->dump($dump);
d464 1
a464 18
while (1) {
	while (1) {
		handle_non_waiting_jobs(0);
		if (!DPB::Core->running &&
		    (!$keep_going || !$state->engine->can_build)) {
			$state->engine->check_buildable(0);
			if (!$state->engine->can_build) {
				last;
			}
		}
		if (DPB::Core->running) {
			DPB::Core->reap_wait;
		}
	}
	if (!$state->opt('q') || !$state->engine->recheck_errors) {
		last;
	}
}
a469 1
#$state->engine->dump_category('tobuild', $state->logger->open('dump'));
@


1.31
log
@stop getting bad timings from erroneous builds.
@
text
@d4 1
a4 1
# $OpenBSD: dpb,v 1.30 2011/11/14 21:59:45 espie Exp $
d117 2
a118 2
	$state->SUPER::handle_options('aceqrRstuUvh:xA:C:f:F:I:j:m:P:b:L:S:',
    "[-acerRsuUvx] [-A arch] [-C plist] [-f N] [-F N] [-I plist] [-j N]",
@


1.30
log
@weights in the -I option as well
@
text
@d4 1
a4 1
# $OpenBSD: dpb,v 1.29 2011/11/14 21:57:47 espie Exp $
d263 1
d265 1
a265 1
		next if (!defined $sz) || $sz =~ m/!$/;
@


1.29
log
@explain to the engine how to install stuff when it's ready (no error
checks though).

new -I option to do that.
change -C option to be more useful.
@
text
@d4 1
a4 1
# $OpenBSD: dpb,v 1.28 2011/11/09 08:28:55 espie Exp $
d92 2
a95 1
				push @@main::ARGV, $_;
@


1.28
log
@smarter dump at end of build:
- try resolving RDEPENDS on tobuild, so that known dependencie are zapped.
- use equivalence info to not reprint same thing twice.
- dump tobuild AND built, since both are usually relevant in case lots of
stuff didn't build
@
text
@d4 1
a4 1
# $OpenBSD: dpb,v 1.27 2011/10/11 09:50:35 espie Exp $
d58 1
d85 23
d116 4
a119 3
	$state->SUPER::handle_options('acCeqrRstuUvh:xA:f:F:j:m:P:b:L:S:',
    "[-acCerRsuUvx] [-A arch] [-f N] [-F N][-j N] [-P plist] [-h hosts]",
    "[-L logdir] [-b log] [-t ctimeout] [-m threshold] [path ...]");
@


1.27
log
@let -S work again
@
text
@d4 1
a4 1
# $OpenBSD: dpb,v 1.26 2011/10/10 18:56:50 espie Exp $
d435 2
a436 2
$state->engine->dump_category('tobuild', $state->logger->open('dump'));

@


1.26
log
@unfuck pkgpaths.
- instead of seen/unseen, have an actual constructor. Instead, mark pkgpath
for which we wantinfo/wantbuild.
- only mark EXTRA dependencies as wantinfo. So the devel/haddock,no_deps
temporary error should be gone.
- since we have FLAVOR and SUBPACKAGE available, construct as much info as
we can during vars scanning (see handle_equivalences). This avoids about 150
path rescans during a full bulk. Also, grab the timing and logsizes from
equivalent files, so that most stuff should know show % all the time.
- tweak subdirlist to be a hash, and correctly add pkgpath_and_flavors to it.
That way, we rescan avahi pseudo flavors just once, and not four or five times.
@
text
@d4 1
a4 1
# $OpenBSD: dpb,v 1.25 2011/09/25 10:41:30 espie Exp $
d269 1
a269 1
		my $o = DPB::PkgPath->new_hidden($pkgpath);
@


1.25
log
@make dpb more useful for people hacking on ports, allow them to not clean
the work directory after building.
@
text
@d4 1
a4 1
# $OpenBSD: dpb,v 1.24 2011/09/13 09:46:53 espie Exp $
d239 1
a239 1
		my $o = DPB::PkgPath->new_hidden($pkgpath);
d291 1
a291 1
my @@subdirlist;
d313 1
a313 1
	$pkgpath->add_to_subdirlist(\@@subdirlist);
d378 2
a379 1
		$state->grabber->grab_subdirs($core, $list);
d383 2
a384 2
if (@@subdirlist > 0) {
	$state->grabber->grab_subdirs($core, \@@subdirlist);
@


1.24
log
@beginning of a fetch-only option that is supposed to replace mirror-maker
eventually.

- fetch all files
- ignore ignores
- specific builder that doesn't look at existing packages

currently: does not stop when  fetch is finished, which is somewhat of the
remaining issue.

Also: change stats to store pid, to make sense of interleaved log files.
@
text
@d4 1
a4 1
# $OpenBSD: dpb,v 1.23 2011/07/14 12:44:39 espie Exp $
d92 2
a93 2
	$state->SUPER::handle_options('aceqrRstuUvh:xA:f:F:j:m:P:b:L:S:',
    "[-acerRsuUvx] [-A arch] [-f N] [-F N][-j N] [-P plist] [-h hosts]",
@


1.23
log
@add extra files at the end of ARGV, not the start
@
text
@d4 1
a4 1
# $OpenBSD: dpb,v 1.22 2011/07/14 11:02:50 espie Exp $
d92 3
a94 3
	$state->SUPER::handle_options('aceqrRstuUvh:xA:f:j:m:P:b:L:S:',
    "[-acerRsuUvx] [-A arch] [-f N] [-j N] [-P plist] [-h hosts] [-L logdir]",
    "[-b log] [-t ctimeout] [-m threshold] [path ...]");
d98 9
@


1.22
log
@turn on -f2 by default
@
text
@d4 1
a4 1
# $OpenBSD: dpb,v 1.21 2011/06/02 17:09:25 espie Exp $
d81 1
a81 1
				unshift @@main::ARGV, $_;
@


1.21
log
@- unify code in Fetch/Build subengines
- zap heuristic#3, not critical
- don't rebuild the Fetch queue all the time, it's too expensive
- fix bugs in FetchQueue computation, correctly handle 1 distfile case
- create a quick path thru adjust* that handles only new paths.
- use it during LISTING while fetching files, to make more files available
quicker.
- model distfiles as FDEPENDS, DIST, so that they can get dumped.
- add -v option that dumps a bit more stuff in log files.

with these, dpb will fetch all distfiles in a not too surprising order,
and it won't consume 40% cpu while doing so...
@
text
@d4 1
a4 1
# $OpenBSD: dpb,v 1.20 2011/05/29 11:06:23 espie Exp $
d92 1
a92 1
	$state->SUPER::handle_options('aceqrRsuUvh:xA:f:j:m:P:b:L:S:t:T:',
d98 1
d107 3
@


1.20
log
@if we -f -a, then scan SUPBDISTFILES too, and use the Distfile cache
to write a list of all known distfiles, that can be used to remove extra
stuff from /usr/ports/distfiles
@
text
@d4 1
a4 1
# $OpenBSD: dpb,v 1.19 2011/05/22 08:21:38 espie Exp $
d92 2
a93 2
	$state->SUPER::handle_options('aceqrRsuUh:xA:f:j:m:P:b:L:S:t:T:',
    "[-acerRsuUx] [-A arch] [-f N] [-j N] [-P plist] [-h hosts] [-L logdir]",
d322 1
d329 2
a330 1
		$state->engine->check_buildable;
d337 4
d395 1
a395 1
$state->engine->check_buildable;
d404 1
a404 1
			$state->engine->check_buildable;
@


1.19
log
@initial support for fetching distfiles, somewhat experimental yet.
- clean up clock handling, jobs with timer.
- pass more parameters thru state
- tweak the engine to handle distfiles
- lots of new code in Fetch for new jobs.
@
text
@d4 1
a4 1
# $OpenBSD: dpb,v 1.18 2011/04/25 11:58:46 espie Exp $
d93 1
a93 1
    "[-acerRsuUx] [-A arch] [-j N] [-P plist] [-h hosts] [-L logdir]",
d384 3
@


1.18
log
@finish refactoring options.
Deprecate: -t and -T
use -DCONNECTION_TIMEOUT=... -DDISPLAY_TIMEOUT=... instead
New feature: -DSTUCK_TIMEOUT=
kill tasks when they don't show any progress for that long.
@
text
@d4 1
a4 1
# $OpenBSD: dpb,v 1.17 2011/04/24 09:14:45 espie Exp $
d45 1
a45 1
	$self->{heuristics} = DPB::Heuristics->new;
d148 20
d303 1
a303 1
my $builder = DPB::PortBuilder->new($state);
d305 2
a306 3
my $locker = DPB::Locks->new(join("/", $state->logdir, "locks"));
my $engine = DPB::Engine->new($builder, $state->heuristics, $state->logger, 
    $locker);
d308 1
a308 1
    $state->heuristics, "DPB::Core", $engine);
d325 1
a325 1
		$engine->recheck_errors;
d328 4
a331 1
		$engine->check_buildable;
d333 3
a335 2
	while ($keep_going && DPB::Core->avail && $engine->can_build) {
		$engine->start_new_job;
d350 1
a350 1
my $grabber = DPB::Grabber->new($state, $engine, 
d356 1
a356 1
	my $list = $engine->find_best($state->logger->logfile("dependencies"), 10);
d359 1
a359 1
		$grabber->grab_subdirs($core, $list);
d364 1
a364 1
	$grabber->grab_subdirs($core, \@@subdirlist);
d367 1
a367 1
$grabber->complete_subdirs($core);
d370 1
a370 1
	$grabber->grab_subdirs($core);
d374 1
a374 1
$grabber->complete_subdirs($core);
d383 1
a383 1
	$engine->dump_dependencies;
d385 3
a387 3
#$engine->dump($dump);
$engine->check_buildable;
#$engine->dump($dump);
d394 3
a396 3
		    (!$keep_going || !$engine->can_build)) {
			$engine->check_buildable;
			if (!$engine->can_build) {
d404 1
a404 1
	if (!$state->opt('q') || !$engine->recheck_errors) {
d411 2
a412 2
print $engine->report;
$engine->dump_category('tobuild', $state->logger->open('dump'));
@


1.17
log
@more option handling refactoring
@
text
@d4 1
a4 1
# $OpenBSD: dpb,v 1.16 2011/04/24 08:34:05 espie Exp $
d34 1
d36 2
a37 1
use OpenBSD::Paths;
d44 1
a44 1
	$self->{export_level}++;
d58 32
a89 11
	$state->{opt}{A} = sub {
		$state->{arch} = shift;
	};
	$state->{opt}{L} = sub {
		$state->{logdir} = shift;
	};
	$state->{opt}{r} = sub {
		$state->heuristics->random;
	};
	$state->{opt}{m} = sub {
		$state->heuristics->set_threshold(shift);
d92 1
a92 1
	$state->SUPER::handle_options('aceqrRsuUh:xA:f:j:m:P:b:d:L:S:t:T:',
d94 1
a94 1
    "[-b log] [-t ctimeout] [-T dtimeout] [-m threshold] [path ...]");
d98 21
d120 21
a182 39
package main;


use DPB::PkgPath;
use DPB::Core;
use DPB::Vars;
use DPB::PortInfo;
use DPB::Engine;
use DPB::PortBuilder;
use DPB::Reporter;
use OpenBSD::Error;
use DPB::Locks;
use DPB::Logger;
use DPB::Job;
use DPB::Grabber;

our ($opt_t, $opt_d, $opt_e, $opt_T, $opt_c, $opt_h, $opt_j, $opt_a,
    $opt_q, $opt_R, $opt_s, $opt_u, $opt_U,
    $opt_f, $opt_x);
my @@subdirlist;

sub parse_size_file
{
	my ($fname, @@consumers) = @@_;
	open my $fh, '<', $fname or die "Couldn't open build file $fname\n";
	my $_;
	while (<$fh>) {
		chomp;
		my ($pkgpath, $sz, $sz2) = split(/\s+/, $_);
		if (defined $sz2) {
			$sz += $sz2;
		}
		my $o = DPB::PkgPath->new_hidden($pkgpath);
		for my $c (@@consumers) {
			$c->add_size_info($o, $sz);
		}
	}
}

d190 1
a190 1
	my ($fname, $arch, @@consumers) = @@_;
d192 1
d199 2
a200 1
	open my $fh, '<', $fname or die "Couldn't open build file $fname\n";
d213 47
a259 1
my @@build_files = ();
a260 18
$state->{opt} = {
	P => sub {
	    my $file = shift;
	    open my $fh, '<', $file or die "Can't open $file\n";
	    my $_;
	    while (<$fh>) {
		    chomp;
		    next if m/^\#/;
		    unshift @@ARGV, $_;
	    }
	},
	b => sub {
	    push(@@build_files, shift);
	},
	S => sub {
	    parse_size_file(shift, $state->heuristics);
	}
    };
d262 1
d264 1
a264 1
my $dpb = $opt_f ? "fetch" : "normal";
d267 1
a267 1
	$opt_a = 1;
d283 1
a283 36
my $logger = DPB::Logger->new($state->logdir, $opt_c);
$state->heuristics->set_logger($logger);

if (defined $opt_j && $state->localarch ne $state->arch) {
	$state->usage("Can't use -j if -A arch is not local architecture");
}

if (defined $opt_j && $opt_j !~ m/^\d+$/) {
	$state->usage("-j takes a numerical argument");
}

if ($opt_h) {
	DPB::Core->parse_hosts_file($opt_h, $state->arch, $opt_t, $logger, $state->heuristics);
}

my $prop = {};
if ($opt_j) {
	$prop->{jobs} = $opt_j;
}

if ($opt_j || !$opt_h) {
	DPB::Core::Factory->new('localhost', $prop);
}

if (@@build_files > 0) {
	for my $file (@@build_files) {
	    parse_build_file($file, $state->arch, $state->heuristics, "DPB::Job::Port");
	}
	$state->heuristics->finished_parsing;
}

DPB::Core::Factory->init_cores($logger);

my $builder = DPB::PortBuilder->new(
    $opt_c, $opt_s, $opt_u, $opt_U, $opt_R, $state->fullrepo, $logger, 
    $state->ports, $state->make, $state->heuristics);
d286 4
a289 2
my $engine = DPB::Engine->new($builder, $state->heuristics, $logger, $locker);
my $reporter = DPB::Reporter->new($opt_x, $state->heuristics, "DPB::Core", $engine);
d295 1
a295 1
#my $dump = DPB::Util->make_hot($logger->open('dump'));
d298 1
a298 2
$opt_T //= 10;
my $last_time = time() - $opt_T;
d316 2
a317 1
		if ($current >= $last_time + $opt_T || $reaped) {
d327 2
a328 2
my $grabber = DPB::Grabber->new($state->ports, $state->make, $logger, $engine, 
	$dpb, sub { handle_non_waiting_jobs(1) });
d330 1
a330 1
if ($opt_a) {
d333 1
a333 1
	my $list = $engine->find_best($logger->logfile("dependencies"), 10);
d346 1
a346 1
if ($opt_a) {
d354 1
a354 1
if (!$opt_e) {
d359 1
a359 1
if ($opt_a) {
d366 1
a366 1
DPB::Core->start_clock($opt_T);
d381 1
a381 1
	if (!$opt_q || !$engine->recheck_errors) {
d389 1
a389 1
$engine->dump_category('tobuild', $logger->open('dump'));
@


1.16
log
@move $heuristics into $state
@
text
@d4 1
a4 1
# $OpenBSD: dpb,v 1.15 2011/04/24 08:07:02 espie Exp $
d35 2
d44 5
d56 13
d72 4
d82 36
d120 1
d134 3
a136 6
use OpenBSD::Paths;
my $make = $ENV{MAKE} || OpenBSD::Paths->make;

our ($opt_t, $opt_d, $opt_e, $opt_T, $opt_c, $opt_h, $opt_A, $opt_j, $opt_a,
    $opt_q, $opt_r, $opt_R, $opt_s, $opt_u, $opt_U,
    $opt_L, $opt_m, $opt_f, $opt_x);
a206 7
if ($opt_r) {
	$state->heuristics->random;
}
if ($opt_m) {
	$state->heuristics->set_threshold($opt_m);
}

d226 1
a226 8
my ($ports, $repo, $localarch, $distdir) = DPB::Vars->get($make,
    "PORTSDIR", "PACKAGE_REPOSITORY", "MACHINE_ARCH", "DISTDIR");

my $arch = $opt_A // $localarch;
my $logdir = $opt_L // $ENV{LOGDIR} // "$ports/logs/$arch";
my $lockdir = "$logdir/locks";

my $logger = DPB::Logger->new($logdir, $opt_c);
d229 1
a229 1
if (defined $opt_j && $localarch ne $arch) {
a236 1
my $fullrepo = "$repo/$arch/all";
d238 1
a238 1
	DPB::Core->parse_hosts_file($opt_h, $arch, $opt_t, $logger, $state->heuristics);
d252 1
a252 1
	    parse_build_file($file, $arch, $state->heuristics, "DPB::Job::Port");
d260 2
a261 2
    $opt_c, $opt_s, $opt_u, $opt_U, $opt_R, $fullrepo, $logger, $ports, $make,
    $state->heuristics);
d263 1
a263 1
my $locker = DPB::Locks->new($lockdir);
d281 1
a281 1
	$keep_going = !-e "$logdir/stop";
d303 2
a304 2
my $grabber = DPB::Grabber->new($ports, $make, $logger, $engine, $dpb,
	sub { handle_non_waiting_jobs(1) });
@


1.15
log
@get options to parse
@
text
@d4 1
a4 1
# $OpenBSD: dpb,v 1.14 2011/04/24 08:02:07 espie Exp $
d34 1
d41 2
d54 4
a67 1
use DPB::Heuristics;
a127 1
my $heuristics = DPB::Heuristics->new;
d144 1
a144 1
	    parse_size_file(shift, $heuristics);
d150 1
a150 1
	$heuristics->random;
d153 1
a153 1
	$heuristics->set_threshold($opt_m);
d171 1
a171 1
	$heuristics->set_weight($pkgpath, $weight);
d183 1
a183 1
$heuristics->set_logger($logger);
d195 1
a195 1
	DPB::Core->parse_hosts_file($opt_h, $arch, $opt_t, $logger, $heuristics);
d209 1
a209 1
	    parse_build_file($file, $arch, $heuristics, "DPB::Job::Port");
d211 1
a211 1
	$heuristics->finished_parsing;
d218 1
a218 1
    $heuristics);
d221 2
a222 2
my $engine = DPB::Engine->new($builder, $heuristics, $logger, $locker);
my $reporter = DPB::Reporter->new($opt_x, $heuristics, "DPB::Core", $engine);
@


1.14
log
@refactor options slightly
@
text
@d4 1
a4 1
# $OpenBSD: dpb,v 1.13 2011/04/18 14:00:57 espie Exp $
d29 1
d38 1
@


1.13
log
@okay, we're dpb and no longer dpb3
@
text
@d4 1
a4 1
# $OpenBSD: dpb,v 1.12 2011/04/05 08:23:00 espie Exp $
d28 23
a58 1
use OpenBSD::State;
d121 2
a122 2
my $ui = OpenBSD::State->new('dpb');
$ui->{opt} = {
d140 1
a140 3
$ui->handle_options('aceqrRsuUh:xA:f:j:m:P:b:d:L:S:t:T:',
    "[-acerRsuUx] [-A arch] [-j N] [-P plist] [-h hosts] [-L logdir]",
    "[-b log] [-t ctimeout] [-T dtimeout] [-m threshold] [path ...]");
d161 1
a161 1
		$ui->usage("Invalid pkgpath: #1",  $arg);
d179 1
a179 1
	$ui->usage("Can't use -j if -A arch is not local architecture");
d183 1
a183 1
	$ui->usage("-j takes a numerical argument");
d316 1
@


1.12
log
@auto-complete build dir with arch and build.log
@
text
@d4 1
a4 1
# $OpenBSD$
d99 1
a99 1
my $ui = OpenBSD::State->new('dpb3');
@


1.11
log
@small hack to make these work even if PORTSDIR is not set and non-standard,
since the lib are supposed to be in the same relative location.
@
text
@d4 1
a4 1
# $OpenBSD: dpb,v 1.10 2010/11/01 12:24:47 espie Exp $
d76 8
a83 1
	my ($fname, @@consumers) = @@_;
d118 1
a118 1
$ui->handle_options('aceqrRsuUh:xA:f:j:m:P:b:d:L:S:t:T:', 
d182 1
a182 1
	    parse_build_file($file, $heuristics, "DPB::Job::Port");
d276 1
a276 1
		if (!DPB::Core->running && 
@


1.10
log
@do -d automatically, we don't really need that option
@
text
@d4 1
a4 1
# $OpenBSD: dpb,v 1.9 2010/10/31 11:07:20 espie Exp $
d23 1
d27 1
a27 1
use lib "$ports1/infrastructure/lib";
@


1.9
log
@new file/option: save dependencies and be able to reuse them.
makes for a "quick listing" of the most important ports first (e.g., groff).
document -R, even though it's not perfect yet.
flesh out all the recent parts and update the BUGS AND LIMITATIONS section.
@
text
@d4 1
a4 1
# $OpenBSD: dpb,v 1.8 2010/10/30 11:19:38 espie Exp $
d112 1
a112 1
    "[-b log] [-d log] [-t ctimeout] [-T dtimeout] [-m threshold] [path ...]");
d228 8
a235 2
if ($opt_d) {
	$grabber->grab_subdirs($core, $engine->find_best($opt_d, 10));
d237 1
d257 3
a259 1
$engine->dump_dependencies;
@


1.8
log
@proof-of-concept implementation of -R (rebuild when signature changes).
Somewhat inefficient (deep check of package vs port signature).
More proper approach would be to tell the engine to always build, have first
step be a check for signature if the package exist, and abort if it matches:
- here we double check everything
- propagating rebuilds means non-uptodate packages give rise to non uptodate.
@
text
@d4 1
a4 1
# $OpenBSD: dpb,v 1.7 2010/10/29 11:51:42 espie Exp $
d45 1
a45 1
our ($opt_t, $opt_e, $opt_T, $opt_c, $opt_h, $opt_A, $opt_j, $opt_a,
d110 1
a110 1
$ui->handle_options('aceqrRsuUh:xA:f:j:m:P:b:L:S:t:T:', 
d112 1
a112 1
    "[-b log] [-t ctimeout] [-T dtimeout] [-m threshold] [path ...]");
d228 3
d250 1
@


1.7
log
@engine improvements:
- if several cores are available, recheck errors, so that we're not stuck
waiting for a core to finish to start new shit.
- $logdir/stop-<machine_name> allows you to stop a given machine while
you clean it up and (possibly) restart it (e.g., won't start new jobs)
@
text
@d4 1
a4 1
# $OpenBSD: dpb,v 1.6 2010/10/28 14:54:38 espie Exp $
d46 1
a46 1
    $opt_q, $opt_r, $opt_s, $opt_u, $opt_U,
d110 2
a111 2
$ui->handle_options('aceqrsuUh:xA:f:j:m:P:b:L:S:t:T:', 
    "[-acersuUx] [-A arch] [-j N] [-P plist] [-h hosts] [-L logdir]",
d180 1
d182 1
a182 1
    $opt_c, $opt_s, $opt_u, $opt_U, $fullrepo, $logger, $ports, $make,
@


1.6
log
@keep the output from dump-vars around, and save it in the logfile is
something bad happens.

get rid of special reporter for Vars, E= is enough, people should look
in the paths/logfile now.
@
text
@d4 1
a4 1
# $OpenBSD: dpb,v 1.5 2010/10/27 22:53:32 espie Exp $
d203 3
d265 1
a265 1
	if (!$opt_q || !$engine->has_errors) {
@


1.5
log
@kill more code related to P= (will simplify next parts)
@
text
@d4 1
a4 1
# $OpenBSD: dpb,v 1.4 2010/10/26 15:45:09 espie Exp $
d186 1
a186 2
my $reporter = DPB::Reporter->new($opt_x, $heuristics, "DPB::Core",
    "DPB::Vars", $engine);
@


1.4
log
@rework PkgPath to distinguish between empty and default flavors...

turns out we probably don't need FULLSUBDIR after all.
compute SUBDIR better, possibly with quotes.
Remove trailing / on subdirs, in case people use completion.
@
text
@d4 1
a4 1
# $OpenBSD: dpb,v 1.3 2010/10/24 10:01:57 espie Exp $
a243 1
$engine->finished_scanning;
@


1.3
log
@add an option for dpb to keep going if there are errors left.
there's a bug in the display (to be fixed) as errors won't show properly
and you have to look manually though...
@
text
@d4 1
a4 1
# $OpenBSD: dpb,v 1.2 2010/08/20 15:22:21 espie Exp $
d127 1
@


1.2
log
@better namespace for make-plist internals, prepare to cut up check-lib-depends
@
text
@d4 1
a4 1
# $OpenBSD: dpb,v 1.1 2010/08/20 13:42:29 espie Exp $
d46 1
a46 1
    $opt_r, $opt_s, $opt_u, $opt_U,
d110 1
a110 1
$ui->handle_options('acersuUh:xA:f:j:m:P:b:L:S:t:T:', 
d250 11
a260 5
	handle_non_waiting_jobs(0);
	if (!DPB::Core->running && (!$keep_going || !$engine->can_build)) {
		$engine->check_buildable;
		if (!$engine->can_build) {
			last;
d263 2
a264 2
	if (DPB::Core->running) {
		DPB::Core->reap_wait;
@


1.1
log
@cp dpb in there.
(old build/dpb will die eventually, but do the rename now)
@
text
@d4 1
a4 1
# $OpenBSD: dpb3,v 1.20 2010/07/13 21:12:41 espie Exp $
a25 1
$0 = 'dpb';
@

