head	1.55;
access;
symbols
	OPENBSD_6_1:1.55.0.2
	OPENBSD_6_1_BASE:1.55
	OPENBSD_6_0:1.54.0.2
	OPENBSD_6_0_BASE:1.54;
locks; strict;
comment	@# @;


1.55
date	2017.02.13.12.52.13;	author espie;	state Exp;
branches;
next	1.54;
commitid	N2CZB5BUFZWy5SXU;

1.54
date	2016.06.26.22.10.03;	author espie;	state Exp;
branches;
next	1.53;
commitid	wYeU1MqtWPUQTywc;

1.53
date	2016.06.16.18.17.44;	author espie;	state Exp;
branches;
next	1.52;
commitid	eaedpETHOrri8dff;

1.52
date	2016.06.06.22.14.20;	author espie;	state Exp;
branches;
next	1.51;
commitid	ewSQ2GDMAfqidnps;

1.51
date	2016.06.04.17.22.11;	author espie;	state Exp;
branches;
next	1.50;
commitid	CJaaBR4KjbsBKcRI;

1.50
date	2016.06.04.12.36.06;	author espie;	state Exp;
branches;
next	1.49;
commitid	Fjo9SPwo4Y2JG0YN;

1.49
date	2016.06.04.12.22.02;	author espie;	state Exp;
branches;
next	1.48;
commitid	pI0woMuoudwkJntb;

1.48
date	2016.06.04.11.58.36;	author espie;	state Exp;
branches;
next	1.47;
commitid	aZVqSnnpRxWbb8no;

1.47
date	2016.05.28.08.42.23;	author espie;	state Exp;
branches;
next	1.46;
commitid	KtwQksxiyADJVpq3;

1.46
date	2016.05.26.00.08.02;	author espie;	state Exp;
branches;
next	1.45;
commitid	nozDfMzBZcWNK1Ps;

1.45
date	2016.05.23.13.36.25;	author espie;	state Exp;
branches;
next	1.44;
commitid	LmCOKiLaOxJPSZUW;

1.44
date	2016.05.20.09.55.25;	author espie;	state Exp;
branches;
next	1.43;
commitid	31whdnFekBQQnD97;

1.43
date	2016.05.19.13.40.27;	author espie;	state Exp;
branches;
next	1.42;
commitid	y3A6xtl9OoaPNQH5;

1.42
date	2016.05.17.16.23.02;	author espie;	state Exp;
branches;
next	1.41;
commitid	oLcVKrknGaj6BxVQ;

1.41
date	2016.05.17.16.16.17;	author espie;	state Exp;
branches;
next	1.40;
commitid	NqvPMstHF341ineb;

1.40
date	2016.05.17.13.14.45;	author espie;	state Exp;
branches;
next	1.39;
commitid	YdiuEg74nL5m1vCa;

1.39
date	2016.05.15.20.31.05;	author rpe;	state Exp;
branches;
next	1.38;
commitid	vxYTDr11qOyUto1U;

1.38
date	2016.05.15.14.14.45;	author espie;	state Exp;
branches;
next	1.37;
commitid	nhcLIyxImkFrHdAu;

1.37
date	2016.05.15.13.25.25;	author espie;	state Exp;
branches;
next	1.36;
commitid	lEOmBWnbHOkNpTi0;

1.36
date	2016.05.15.11.06.57;	author espie;	state Exp;
branches;
next	1.35;
commitid	Ea6TDtYOJqddOJ7i;

1.35
date	2016.05.15.10.24.38;	author espie;	state Exp;
branches;
next	1.34;
commitid	oZ1wvLDX4guioIIP;

1.34
date	2016.05.15.10.00.16;	author espie;	state Exp;
branches;
next	1.33;
commitid	MvStzNz7P7axENt1;

1.33
date	2016.05.14.22.49.23;	author espie;	state Exp;
branches;
next	1.32;
commitid	lwLGuzk4cprSjA9F;

1.32
date	2016.05.14.15.19.48;	author espie;	state Exp;
branches;
next	1.31;
commitid	6hMAID9e0y7kJ8Zl;

1.31
date	2016.05.14.15.00.07;	author espie;	state Exp;
branches;
next	1.30;
commitid	TMzlegoPISsz4ol6;

1.30
date	2016.05.14.13.55.42;	author espie;	state Exp;
branches;
next	1.29;
commitid	Kr2IyLamlxyyH0uB;

1.29
date	2016.05.14.11.16.29;	author espie;	state Exp;
branches;
next	1.28;
commitid	8QH50UJmxtgxSOYO;

1.28
date	2016.05.14.10.05.55;	author espie;	state Exp;
branches;
next	1.27;
commitid	4aROtZ9jlwNJ2a1d;

1.27
date	2016.05.14.09.19.09;	author espie;	state Exp;
branches;
next	1.26;
commitid	KH3gl0rUeC3yLGes;

1.26
date	2016.05.14.09.04.40;	author espie;	state Exp;
branches;
next	1.25;
commitid	i51N3g5ui2nMcT6d;

1.25
date	2016.05.13.22.40.28;	author espie;	state Exp;
branches;
next	1.24;
commitid	ATGj0laHWTHC3KUa;

1.24
date	2016.05.13.14.30.06;	author espie;	state Exp;
branches;
next	1.23;
commitid	vMWrw1olJzVU2UhJ;

1.23
date	2016.05.13.14.17.24;	author espie;	state Exp;
branches;
next	1.22;
commitid	0Z44o21NCWtHWOkz;

1.22
date	2016.05.13.13.37.22;	author espie;	state Exp;
branches;
next	1.21;
commitid	961I9sBrEdlYPlwT;

1.21
date	2016.05.13.02.38.03;	author espie;	state Exp;
branches;
next	1.20;
commitid	XFgtFa8VcgUyNQJ8;

1.20
date	2016.05.12.13.14.13;	author espie;	state Exp;
branches;
next	1.19;
commitid	PHx87ESs83vqZEcC;

1.19
date	2016.05.11.12.51.07;	author espie;	state Exp;
branches;
next	1.18;
commitid	d62AJArwuwVy6PQu;

1.18
date	2016.05.11.12.50.02;	author espie;	state Exp;
branches;
next	1.17;
commitid	dHSJSCWOZhQeFt0F;

1.17
date	2016.05.10.16.13.31;	author espie;	state Exp;
branches;
next	1.16;
commitid	tDkx5mkEQSYoy2X4;

1.16
date	2016.05.10.15.48.18;	author espie;	state Exp;
branches;
next	1.15;
commitid	uyYD6kE7V9VOrilI;

1.15
date	2016.05.10.15.31.17;	author espie;	state Exp;
branches;
next	1.14;
commitid	G4dsX30aMEdVjlaD;

1.14
date	2016.05.10.15.29.53;	author espie;	state Exp;
branches;
next	1.13;
commitid	mLhIHBA1wiD78sku;

1.13
date	2016.05.10.10.44.07;	author espie;	state Exp;
branches;
next	1.12;
commitid	DHeN3IETQDgrY2AD;

1.12
date	2016.05.10.09.13.47;	author espie;	state Exp;
branches;
next	1.11;
commitid	Crwj769ukgb7Ixka;

1.11
date	2016.05.10.08.52.52;	author espie;	state Exp;
branches;
next	1.10;
commitid	ab4gxymJoKHC88nL;

1.10
date	2016.05.08.11.51.40;	author espie;	state Exp;
branches;
next	1.9;
commitid	uKWwBe0LbEnEkll4;

1.9
date	2016.05.03.09.12.51;	author espie;	state Exp;
branches;
next	1.8;
commitid	RiQb6iHvXafoHEAY;

1.8
date	2016.05.03.09.08.17;	author espie;	state Exp;
branches;
next	1.7;
commitid	16OX9WKkuM55M4hP;

1.7
date	2016.05.03.05.02.38;	author espie;	state Exp;
branches;
next	1.6;
commitid	MCp8GiPYQ7tEXO86;

1.6
date	2016.05.02.06.56.30;	author espie;	state Exp;
branches;
next	1.5;
commitid	anTvv1fUI0xi2JcU;

1.5
date	2016.05.01.08.39.43;	author espie;	state Exp;
branches;
next	1.4;
commitid	j6kcTqErRJyTO2U6;

1.4
date	2016.04.30.09.13.48;	author espie;	state Exp;
branches;
next	1.3;
commitid	MehfTRhWnorcRyg3;

1.3
date	2016.04.29.14.49.33;	author espie;	state Exp;
branches;
next	1.2;
commitid	klrLpuDaWRqfrdY3;

1.2
date	2016.04.29.14.47.32;	author espie;	state Exp;
branches;
next	1.1;
commitid	B53dVjgbvNnJdgcc;

1.1
date	2016.04.29.14.27.15;	author espie;	state Exp;
branches;
next	;
commitid	W33ETES7n3Rwa8yF;


desc
@@


1.55
log
@forgotten: scrape SIGNING_PARAMETERS
@
text
@#! /usr/bin/perl
# ex:ts=8 sw=4:
# $OpenBSD: proot,v 1.54 2016/06/26 22:10:03 espie Exp $
#
# Copyright (c) 2016 Marc Espie <espie@@openbsd.org>
#
# Permission to use, copy, modify, and distribute this software for any
# purpose with or without fee is hereby granted, provided that the above
# copyright notice and this permission notice appear in all copies.
#
# THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
# ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
# OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

use strict;
use warnings;

my $ports1;
use FindBin;
BEGIN {
	$ports1 = $ENV{PORTSDIR} || '/usr/ports';
}

use lib ("$ports1/infrastructure/lib", "$FindBin::Bin/../lib");
use OpenBSD::Getopt;
use OpenBSD::Paths;
use OpenBSD::State;
use OpenBSD::ProgressMeter;
use DPB::User;

package MyUser;
our @@ISA = qw(DPB::User);

use File::Basename;
use File::Find;

sub new
{
	my $class = shift;
	return $class->SUPER::new(@@_)->enforce_local;
}

sub mkpath
{
	my ($self, $dir) = @@_;
	my $p = dirname($dir);
	if (! -d $p) {
		$self->mkpath($p);
	}
	$self->mkdir($dir);
}

sub mkRpath
{
	my ($self, $dir, @@except) = @@_;
	my %dont = map {($_, 1)} @@except;
	if (-d $dir) {
		find(sub {
		    if ($dont{$_}) {
			    $File::Find::prune = 1;
			    return;
		    }
		    $self->own($_);
		}, $dir);
	} else {
		$self->mkpath($dir);
	}
}

sub own
{
	my ($self, $path) = @@_;
	chown $self->{uid}, $self->{gid}, $path;
}

sub mkdir
{
	my ($self, $dir) = @@_;
	mkdir($dir);
	$self->own($dir);
}

package MyState;
our @@ISA = (qw(OpenBSD::State));

use File::Copy;
use File::Spec;
use File::Basename;
use File::Find;
use File::Path qw(remove_tree);

sub set_chroot
{
	my $state = shift;
	for my $item (keys %{$state->{dontrm}}) {
		$state->add_chroot_preserved($item);
	}
}

sub fatal_error
{
	my $self = shift;
	$self->errsay(@@_);
	$self->{error} = 1;
}

sub add_chroot_preserved
{
	my ($state, $item) = @@_;
	$state->{chroot_dont}{$state->chroot($item)} = 1;
}

sub add_preserved
{
	my ($state, $item) = @@_;
	$state->{dontrm}{$item} = 1;
	if (exists $state->{chroot_dont}) {
		$state->add_chroot_preserved($item);
	}
}

sub canonical_dir
{
	my ($state, $path) = @@_;
	$path = File::Spec->canonpath($path);
	$path =~ s,/+$,,;
	return $path;
}

sub do_parm
{
	my ($state, $k, $v) = @@_;

	my $opts = {
	    chroot => sub {
		    $state->{chroot} = File::Spec->canonpath($v);
	    }, srcroot => sub {
		    $state->{srcroot} = File::Spec->canonpath($v);
	    }, PORT_USER => sub {
		    $state->{portuser} = MyUser->new($v);
	    }, LOG_USER => sub {
		    $state->{loguser} = MyUser->new($v);
	    }, FETCH_USER => sub {
		    $state->{fetchuser} = MyUser->new($v);
	    }, BUILD_USER => sub {
		    $state->{builduser} = MyUser->new($v);
	    }, PORTSDIR => sub {
		    $state->{PORTSDIR} = File::Spec->canonpath($v);
	    }, DISTDIR => sub {
		    $state->{DISTDIR} = File::Spec->canonpath($v);
	    }, PACKAGE_REPOSITORY => sub {
		    $state->{PACKAGE_REPOSITORY} = File::Spec->canonpath($v);
	    }, PLIST_REPOSITORY => sub {
		    $state->{PLIST_REPOSITORY} = File::Spec->canonpath($v);
	    }, NFSDIR => sub {
		    $state->{DISTDIR} = File::Spec->canonpath("$v/distfiles");
		    $state->{PACKAGE_REPOSITORY} = 
			File::Spec->canonpath("$v/packages");
		    $state->{PLIST_REPOSITORY} =
		    	File::Spec->canonpath("$v/plist");
	    }, LOCALDIR => sub {
		    $state->{WRKOBJDIR} = File::Spec->canonpath("$v/pobj");
		    $state->{LOCKDIR} = File::Spec->canonpath("$v/locks");
	    }, preserve => sub {
		    $state->add_preserved($v);
	    }, portscvs => sub {
		    $state->{portscvs} = $v;
	    }, ignorecvs => sub {
		    $state->{ignorecvs} = 1;
	    }, chown_all => sub {
		    $state->{chown_all} = $v;
	    }, WRKOBJDIR => sub {
	    	$state->{WRKOBJDIR} = File::Spec->canonpath($v);
	    }, DISTDIR => sub {
	    	$state->{DISTDIR} = File::Spec->canonpath($v);
	    }, LOCKDIR => sub {
	    	$state->{LOCKDIR} = File::Spec->canonpath($v);
	    }, snapshot => sub {
	    	$state->{snapshot} = $v;
	    }, actions => sub {
	    	if ($v eq 'none') {
			delete $state->{actions};
		}
		if ($v =~ m/^-(.*)/) {
			$state->{actions}{$1} = 0;
		} else {
			$state->{actions}{$v} = 1;
		}
	    }, sets => sub {
	    	if ($v =~ m/^-(.*)/) {
			$state->{sets}{$1} = 0;
		} else {
			$state->{sets}{$v} = 1;
		}
	    }, extra => sub {
	    	$state->{known}{$v} = 1;
	    }, mkconf_tail => sub {
	    	$state->{mkconf_tail} = $v;
	    }, mkconf_lines => sub {
	    	push(@@{$state->{mkconf_lines}}, $v);
	    }
	};

	if (defined $opts->{$k}) {
		&{$opts->{$k}};
	} else {
		$state->fatal_error("Unknown options #1=#2", $k, $v);
	}
}

sub read_configfile
{
	my ($state, $name) = @@_;
	open(my $f, '<', $name) or die "Can't open config $name: $!";
	my ($k, $v);

	while (<$f>) {
		chomp;
		my $line = $_;
		s/\s*\#.*//;
		next if /^$/;
		if (m/^(.*?)\s*\=\s*(.*)$/) {
			($k, $v) = ($1, $2);
		} elsif (m/^\s+(.*)$/) {
			$v = $1;
		} else {
			$state->fatal_error("Error in config file #1: #2", 
			    $., $line);
			next;
		} 
		$state->do_parm($k, $v);
	}
	close($f);
}

sub handle_options
{
	my $state = shift;
	# default shit
	$state->{actions} = {
	    check_mount => 1,
	    devs => 1,
	    ldconfig => 1,
	    ports_subdirs => 1,
	    unpopulate_light => 1,
	    resolv => 1,
	    write_mk => 1,
	};
	$state->{sets} = {
		base => 1,
		comp => 1,
		etc => 1,
		xetc => 1,
		xbase => 1,
		xfont => 1,
		xshare => 1,
	};

	$state->{error} = 0;
	$state->{no_exports} = 1;
	$state->{opt} = {
		B => sub { $state->{fchroot} = File::Spec->canonpath(shift); },
		S => sub { $state->{fsrcroot} = File::Spec->canonpath(shift); },
		c => sub { $state->read_configfile(shift); },
	    };
	$state->SUPER::handle_options("B:S:c:mx", 
	    "[-B chroot] [-c configfile] [-S chroot] [arg=value...]");

	# command-line trump configuration file
	my ($k, $v);
	for my $arg (@@ARGV) {
		if ($arg =~ m/^(.*?)\s*\=\s*(.*)$/) {
			($k, $v) = ($1, $2);
		} else {
			$v = $arg;
		}
		$state->do_parm($k, $v);
	}
	if (defined $state->{fchroot}) {
		$state->{chroot} = $state->{fchroot};
	}
	$state->set_chroot;
	if (defined $state->{fsrcroot}) {
		$state->{srcroot} = $state->{fsrcroot};
	}

	# more basic option defaults
	if (!defined $state->{actions}{snapshot} && 
	    !defined $state->{actions}{locate} && 
	    !defined $state->{actions}{none}) {
	    	if ($state->{snapshot}) {
			$state->{actions}{snapshot} = 1;
		} else {
			$state->{actions}{locate} = 1;
		}
	}
	if (defined $state->{portscvs} && 
	    !defined $state->{actions}{checkout_ports}) {
	    	$state->{actions}{checkout_ports} = 1;
	}
	if ($state->{actions}{unpopulate}) {
		delete $state->{actions}{unpopulate_light};
	}

	if (!defined $state->{chroot}) {
		$state->usage("need a chroot base");
	}
	if (defined $state->{actions}{checkout_ports} &&
	    !defined $state->{portuser}) {
	    	$state->usage("can't do action checkout_ports without a PORT_USER");
	}
	if (defined $state->{snapshot} &&
	    $state->{snapshot} =~ m/^\Q$state->{chroot}\E(.*)/) {
	    	$state->add_preserved($1);
	}

	$state->{progressmeter} = OpenBSD::ProgressMeter->new;
	$state->{progressmeter}->setup($state->opt('x'), $state->opt('m'), 
	    $state);
	if ($< != 0) {
		$state->fatal("Must be root");
	}
	for my $i (qw(PORTSDIR DISTDIR WRKOBJDIR PACKAGE_REPOSITORY PLIST_REPOSITORY LOCKDIR LOGDIR)) {
		if (defined $state->{$i}) {
			$state->{write}{$i} = 1;
		}
	}
	$state->{PORTSDIR} //= "/usr/ports";
	$state->{DISTDIR} //= join('/', $state->{PORTSDIR}, 'distfiles');
	$state->{WRKOBJDIR} //= join('/', $state->{PORTSDIR}, 'pobj');
	$state->{LOCKDIR} //= join('/', $state->{WRKOBJDIR}, 'locks');
	$state->{LOGDIR} //= join('/', $state->{PORTSDIR}, 'logs');
	$state->{fetchuser} //= MyUser->new('_pfetch');
	$state->{builduser} //= MyUser->new('_pbuild');
	$state->{loguser} //= $state->{builduser};
	$state->{PACKAGE_REPOSITORY} //= join('/', $state->{PORTSDIR}, 'packages');
	$state->{PLIST_REPOSITORY} //= join('/', $state->{PORTSDIR}, 'plist');
	$state->{sysdir} //= '/usr/src/sys';
	for my $dir (qw(DISTDIR WRKOBJDIR LOGDIR PACKAGE_REPOSITORY PLIST_REPOSITORY LOCKDIR)) {
		$state->{$dir} = $state->canonical_dir($state->{$dir});
		$state->add_preserved($state->{$dir});
	}
	$state->{PORTSDIR} = $state->canonical_dir($state->{PORTSDIR});
	if (!$state->{actions}{copy_ports}) {
		$state->add_preserved($state->{PORTSDIR});
	}

	for my $i (qw(portuser loguser fetchuser builduser)) {
		if (defined $state->{$i}) {
			$state->say("#1: #2", $i, $state->{$i}->{user});
		}
	}
}

sub chroot
{
	my $state = shift;
	if (defined $state->{chroot}) {
		unshift @@_, $state->{chroot};
	}
	return File::Spec->canonpath(join('/', @@_));
}

sub srcroot
{
	my $state = shift;
	if (defined $state->{srcroot}) {
		unshift @@_, $state->{srcroot};
	}
	return File::Spec->canonpath(join('/', @@_));
}

sub chdir
{
	my ($state, $dir) = @@_;
	CORE::chdir($dir) or $state->fatal("Can't change to #1: #2", $dir, $!);
}

sub banner
{
	my ($self, $text, $sub) = @@_;
	$self->{progressmeter}->set_header($text);
	&$sub;
	$self->{progressmeter}->next;
}

sub run_chroot
{
	my ($self, $text, $sub) = @@_;
	$self->{progressmeter}->set_header($text);
	my $r = fork();
	if (!defined $r) {
		$self->fatal("Couldn't fork");
	}
	if ($r == 0) {
		CORE::chroot($self->chroot) or
		    $self->fatal("Can't chroot into #1: #2", 
		    $self->chroot, $!); 
		CORE::chdir('/') or
		    $self->fatal("Can't chdir after chroot: #1", $!);
		&$sub;
		exit(0);
	}
	waitpid($r, 0);
	if ($? != 0) {
		$self->fatal("Running task failed");
	}
	# XXX fork'd so we don't know what we showed
	eval {
		$self->{progressmeter}->forked;
	};

	$self->{progressmeter}->next;
}

sub sync_display
{
	my $self = shift;
	$self->{progressmeter}->clear if defined $self->{progressmeter};
}

sub check_mountpoint
{
	my $state = shift; 
	open(my $cmd, "-|", OpenBSD::Paths->mount);
	my ($dev, $nosuid, $wx);
	while (<$cmd>)  {
		chomp;
		if (m/^(\S+)\s+on\s+(\S+)\s+type\s+(\S+)\s+\((.+)\)$/) {
			my ($dir, $type, $options) = ($2, $3, $4);
			my %opts = map {($_, 1)} split(/,\s+/, $options);
			if ($opts{nodev}) {
				$dev->{$dir} = 0;
			} else {
				$dev->{$dir} = 1;
			}
			if ($opts{nosuid}) {
				$nosuid->{$dir} = 1;
			} else {
				$nosuid->{$dir} = 0;
			}
			if ($opts{wxallowed}) {
				$wx->{$dir} = 1;
			} else {
				$wx->{$dir} = 0;
			}
			my $devno = (stat $dir)[0];
			if ($type eq 'nfs') {
				$state->{nfs}{$devno} = $dir;
			}
		}
	}
	close($cmd);
	my $root = $state->{chroot};
	if (-l $root) {
		$root = readlink $root;
	}
	for my $dir (keys %$dev) {
		if ($dir =~ m/^\Q$root\E(\/.*)/) {
			$state->say("Preserve #1", $1);
			$state->add_preserved($1);
			my $devno = (stat $dir)[0];
			$state->{dontrm_dev}{$devno} = 1;
		}
	}
	my $mnt = $root;
	do {{
		if (!defined $dev->{$mnt}) {
			$mnt = dirname($mnt);
			next;
		}
		$state->errsay("#1 is under #2 which is nodev", $root, $mnt)
		    if $dev->{$mnt} == 0;
		$state->errsay("#1 is under #2 which does not have nosuid",
		    $root, $mnt) if $nosuid->{$mnt} == 0;
		$state->errsay("#1 is under #2 which does not have wxallowed",
		    $root, $mnt) if $wx->{$mnt} == 0;
			return;
	}} while ($mnt ne dirname($mnt));
	$state->fatal_error("Couldn't find mountpoint for #1 ???", $root);
}

sub special_data
{
	my $state = shift;
	$state->{known}{'/etc/resolv.conf'} = 1;
	$state->{known}{'/etc/hosts'} = 1;
}

sub read_locates
{
	my $state = shift;
	$state->banner("Running locate",
	    sub {
		open(my $cmd, '-|', 'locate',
		    '-d', $state->srcroot(OpenBSD::Paths->srclocatedb),
		    '-d', $state->srcroot(OpenBSD::Paths->xlocatedb), ':');
		while (<$cmd>) {
			chomp;
			my ($set, $path) = split(':', $_, 2);
			$set =~ s/\d+//;
#			next if $path =~ m/\.ph$/;
			if ($state->{sets}{$set}) {
				$state->{known}{$path} = 1;
			}
			$state->{progressmeter}->working(1000);
		}
		close($cmd);
	    });
}

# THIS IS THE WORK HORSE
sub simple_copy
{
	my ($state, $path, $cpath, $user) = @@_;

	$state->{accounted}{$path} = 1;
	if (-l $path) {
		return if $state->{chroot_dont}{$cpath};
		remove_tree($cpath);
		my $target = readlink $path;
		if (!defined $target) {
			$state->fatal_error("Can't read link to #1: #2", 
			    $path, $!);
		} else {
			symlink($target, $cpath) or
			    $state->fatal_error("Can't symlink #1 -> #2", 
			    	$target, $cpath);
		}
		return;
	} else {
		my ($dev, $ino, $mode, $uid, $gid, $sz, $atime, $mtime) = 
		    (stat $path)[0, 1, 2, 4, 5, 7, 8, 9];
		if (-d $path) {
			if (!-d $cpath && -e _) {
				return if $state->{chroot_dont}{$cpath};
				remove_tree($cpath);
			}
			mkdir $cpath, $mode;
			if (!-d $cpath) {
				$state->fatal_error("Can't mkdir #1", $cpath);
			}
			if (defined $user) {
				$user->own($cpath);
			} else {
				chown $uid, $gid, $cpath;
			}
			chmod $mode, $cpath;
			utime $atime, $mtime, $cpath;
			return;
		} elsif (-f $path) {
			my ($dev2, $ino2, $sz2, $mtime2) = 
			    (stat $cpath)[0, 1, 7, 9];
			if (defined $dev2 && $dev2 == $dev && $ino2 == $ino) {
				return;
			}
			my $key = "$dev/$ino";

			if (exists $state->{copied}{$key}) {
				return if $state->{chroot_dont}{$cpath};
				remove_tree($cpath);
				link($state->{copied}{$key}, $cpath);
				return;
			}
			# avoid the copy if same filesystem
			if (link($path, $cpath)) {
				return;
			}

			my $okay = 0;
			if (defined $sz2 && $sz2 == $sz && $mtime2 >= $mtime) {
				$okay = 1;
			} else {
				return if $state->{chroot_dont}{$cpath};
				remove_tree($cpath);
				$okay = copy($path, $cpath);
			}
			if ($okay) {
				if (defined $user) {
					$user->own($cpath);
				} else {
					chown $uid, $gid, $cpath;
				}
				chmod $mode, $cpath;
				utime $atime, $mtime, $cpath;
				$state->{copied}{$key} = $cpath;
				return;
			}
		}
	}
	$state->fatal_error("Can't copy #1: #2", $path, $!);
}

sub recursive_copy
{
	my ($state, $path) = @@_;

	my $d = dirname($path);
	if ($d ne $path) {
		if (!-d $state->chroot($d)) {
			$state->recursive_copy($d);
		}
	}
	my $spath = $state->srcroot($path);
	if (!-e $spath) {
		$state->errsay("#1 does not exist", $spath);
		return;
    	}
	$state->simple_copy($spath, $state->chroot($path));
}

sub copy_sync
{
	my $state = shift;
	# farting all over the place
	$state->banner("Copying stuff over",
	    sub {
		my $old = umask;
		umask 0;
		for my $path (sort keys %{$state->{known}}) {
			$state->recursive_copy($path);
			$state->{progressmeter}->message($path);
		}
		umask $old;
	    });
}

sub best_user
{
	my $state = shift;
	local $_ = shift;

	if (m/^\Q$state->{LOGDIR}\E/) {
		return $state->{loguser};
	}
	if (m/^\Q$state->{DISTDIR}\E\/build-stats/) {
		return $state->{loguser};
	}
	if (m/^\Q$state->{PLIST_REPOSITORY}\E/) {
		return $state->{builduser};
	}
	if (m/^\Q$state->{PACKAGE_REPOSITORY}\E/) {
		return $state->{builduser};
	}
	if (m/^\Q$state->{DISTDIR}\E/) {
		return $state->{fetchuser};
	}
	if (m/^\Q$state->{DISTDIR}\E/) {
		return $state->{fetchuser};
	}
	return $state->{portuser};
}

sub grab_file
{
	my ($state, $snapdir, $file) = @@_;

	my $baseurl = $state->{snapshot};

	unless (-f $file) {
		if ($state->system('/usr/bin/ftp' , "-C", "-o", 
		    "$snapdir/$file.part", "$baseurl/$file") == 0) {
			rename("$snapdir/$file.part", "$snapdir/$file");
		} else {
			$state->fatal("fetch #1 failed", $file);
		}

	}
}

sub extract_archive
{
	my ($state, $dir, $archive) = @@_;
	require IO::Uncompress::AnyUncompress;

	my $in = IO::Uncompress::AnyUncompress->new("$dir/$archive", 
	    MultiStream => 1);
	if (!$in) {
		$state->fatal("Couldn't open #1", "$dir/$archive");
	}
	require OpenBSD::Ustar;
	my $arc = OpenBSD::Ustar->new($in, $state, $state->chroot);
	while (my $o = $arc->next) {
		$o->{name} =~ s,^\./,/,;
		if (defined $o->{linkname}) {
			$o->{linkname} =~ s,^\./,/,;
		}
		unlink($state->chroot($o->{name}));
#		$state->say("$o->{name}");
		$state->{progressmeter}->message("$archive: $o->{name}");
		$state->{accounted}{$o->{name}} = 1;
		$o->create;
	}
	$arc->close;
	$in->close;
}

sub get_snapshot
{
	my $state = shift;

	$state->banner("Grabbing snapshot",
	    sub {
	    	my ($snapdir, $grab);
	    	if ($state->{snapshot} =~ m/^(https?|ftp):/) {
			$snapdir = $state->chroot('/tmp');
			File::Path::make_path($snapdir);
			$grab = sub { $state->grab_file($snapdir, shift); }
		} else {
			$snapdir = $state->{snapshot};
			$grab = sub {};
		}

		&$grab("SHA256.sig");
		open my $f, '<', "$snapdir/SHA256.sig" 
		    or $state->fatal("no SHA256.sig");
		my $line = <$f>;
		if ($line !~ m/openbsd\s+(\d+)\.(\d+)\s+base/) {
			$state->fatal("Unrecognized snapshot");
		}
		my $v = "$1$2";
		my (@@files, @@later);
		for my $set (sort keys %{$state->{sets}}) {
			if ($set =~ m/etc/) {
				push(@@later, "$set.tgz");
			} else {
				my $file = "$set$v.tgz";
				&$grab($file);
				push(@@files, $file);
			}
		}
		if ($state->system(
		    sub {
			$state->chdir($snapdir); },
		    '/usr/bin/signify', '-C', '-p',
		    "/etc/signify/openbsd-$v-base.pub", '-x', 'SHA256.sig',
		    @@files) != 0) {
			$state->fatal("Checksum error");
		}
		for my $archive (@@files) {
			$state->extract_archive($snapdir, $archive);
		}
		for my $archive (@@later) {
			$state->extract_archive($state->chroot("var/sysmerge"), 
			    $archive);
		}
	    	if ($state->{snapshot} =~ m/^(https?|ftp):/) {
			for my $file (@@files) {
				unlink("$snapdir/$file");
			}
		}
	    });
}

sub copy_ports
{
	my $state = shift;
	$state->banner("Copying ports",
	    sub {
		my $old = umask;
		umask 0;
		my $portsdir = $state->{PORTSDIR};
		my $srcports = $state->srcroot($portsdir);
		if (-l $srcports) {
			$srcports = readlink $srcports;
		}
		my $destports = $state->chroot($portsdir);
		find(sub {
			if ($state->{ignorecvs} && $_ eq 'CVS' && -d $_) {
				$File::Find::prune = 1;
				return;
			}
			my $realname = $File::Find::name;
			$realname =~ s,^\Q$srcports\E\b,,;
			my $r2 = $realname;
			$r2 =~ s,^,$portsdir,;
			if ($r2 eq $state->{WRKOBJDIR}) {
				$File::Find::prune = 1;
				return;
			}
			$realname =~ s,^/,,;
			$state->{progressmeter}->message($realname);
			$state->simple_copy($File::Find::name, 
			    $state->chroot($r2), $state->best_user($r2));
		    }, $srcports);
		umask $old;
	    });
}

sub copy_sys
{
	my $state = shift;
	$state->banner("Copying sys includes",
	    sub {
		my $old = umask;
		umask 0;
		my $srcsys = $state->srcroot($state->{sysdir});
		my $destsys = $state->chroot($state->{sysdir});
		find(sub {
			# XXX don't bother copying stuff that's NOT .h
			return if -f $_ && !m/\.h$/ && $_ ne 'Makefile';
			if (-d _ && $_ eq 'obj' || $_ eq 'CVS') {
				$File::Find::prune = 1;
				return;
			}
			my $destname = $File::Find::name;
			$destname =~ s,^\Q$srcsys\E\b,$destsys,;
			$state->{progressmeter}->message($File::Find::name);
			$state->simple_copy($File::Find::name, $destname);
		    }, $srcsys);
		umask $old;
	    });
}

sub regen_devs
{
	my $state = shift;
	$state->banner("Generating devices",
	    sub {
		$state->system(
		    sub {
			$state->chdir($state->chroot("/dev"));
		    }, '/bin/sh', './MAKEDEV', 'all');
		$state->add_preserved('/dev');
	    });
	$state->run_chroot("Generating devices db",
	    sub {
	    	$state->system("/usr/sbin/dev_mkdb");
	    });
}

sub run_ldconfig
{
	my $state = shift;
	$state->banner("Running ldconfig",
	    sub {
		$state->system(
		    sub {
			CORE::chroot($state->chroot) or exit 1;
		    }, 
		    'ldconfig', '/usr/lib', '/usr/X11R6/lib', '/usr/local/lib');
		$state->{accounted}{'/var/run/ld.so.hints'} = 1;
	    });
}

sub checkout_ports
{
	my $state = shift;
	$state->banner("Checking out ports tree",
	    sub {
	    	my @@cvs = ("/usr/bin/cvs", "-z3", "-d", $state->{portscvs});
		my $dir = $state->chroot($state->{PORTSDIR});
		if (-d "$dir/CVS") {
			$state->{portuser}->run_as(sub {
			    $state->system(
			    	sub { $state->chdir($dir); },
				@@cvs, "update", "-dP", "-A");
			    });
		} else {
			# okay, so stupid cvs creates the dir, work-around that
			$state->{portuser}->mkpath("$dir.tmp");
			$state->{portuser}->run_as(sub {
			    $state->system(
			    	sub { $state->chdir("$dir.tmp"); },
			    	@@cvs, "co", "-P", "-A", "ports");
			    });
			rename("$dir.tmp/ports", "$dir");
			rmdir("$dir.tmp");
		}
	    });
}

sub unpopulate_chroot
{
	my $state = shift;
	$state->run_chroot("Cleaning up files and directories",
	    sub {
		my @@dirs;
	    	find(
		    sub {
		    	my $devno = (lstat $_)[0];
			if ($state->{dontrm_dev}{$devno} || 
			    $state->{dontrm}{$File::Find::name}) {
				$File::Find::prune = 1 if -d _;
				return;
			}
			if ($state->{accounted}{$File::Find::name}) {
				return;
			}
		    	$state->{progressmeter}->message($File::Find::name);
		    	if (-l _ || ! -d _) {
				unlink($_);
			} else {
				push(@@dirs, $File::Find::name);
			}
		    }, '/');
		for my $dir (reverse @@dirs) {
			#$state->say("rmdir #1", $dir);
			rmdir $dir;
		}
	    });
}

sub verbose_shit
{
	my $state = shift;
	$state->run_chroot("Showing up stragglers",
	    sub {
	    	find(
		    sub {
			if (-d $_ && $state->{dontrm}{$File::Find::name}) {
				$File::Find::prune = 1;
				return;
			}
			if ($state->{dontrm}{$File::Find::name}) {
				return;
			}
			if ($state->{accounted}{$File::Find::name} || 
			    $File::Find::name eq '/') {
				return;
			}
			$state->say("#1", $File::Find::name);
		    }, '/');
	    });
}

sub show_absolute_symlinks
{
	my $state = shift;
	my $wrapper = '/usr/sbin/mailwrapper';
	my $expected = {
		'/etc/localtime' => undef,
		'/etc/rmt' => '/usr/sbin/rmt',
		'/etc/termcap' => '/usr/share/misc/termcap',
		'/usr/bin/hoststat' => $wrapper,
		'/usr/bin/mailq' => $wrapper,
		'/usr/bin/newaliases' => $wrapper,
		'/usr/bin/purgestat' => $wrapper,
		'/usr/bin/rcs2log' => '/usr/libexec/cvs/contrib/rcs2log',
		'/usr/local/lib/X11/app-defaults' => '/etc/X11/app-defaults',
		'/usr/sbin/makemap' => $wrapper,
		'/usr/sbin/sendmail' => $wrapper,
    	};

	$state->run_chroot("Showing absolute symlinks",
	    sub {
	    	find(
		    sub {
		    	return unless -l $_;
			my $dest = readlink $_;
			return unless $dest =~ m/^\//;
			my $ok = 0;
			my $n = $File::Find::name;
			if (exists $expected->{$n}) {
				$ok = 1;
				if (defined $expected->{$n}
				    and $expected->{$n} ne $dest) {
				    $ok = 0;
				}
			}
			if (!$ok) {
				$state->errsay("#1 points to #2", $n, $dest);
			}
		    }, '/');
	    });
}

sub is_under_nfs
{
	my ($state, $dir) = @@_;

	my $devno = (stat $dir)[0];
	if (defined $devno && exists $state->{nfs}{$devno}) {
		return 1;
	} else {
		return 0;
	}
}

use constant { WHINE => 1, MKPATH => 2 };

sub build_dir
{
	my ($state, $opts, $username, $dirname, @@r) = @@_;
	$state->{progressmeter}->message($dirname);
	my $dir = join('/', $state->{$dirname}, @@r);
	$state->{$username}->mkpath($dir);
	my $nfs = $state->is_under_nfs($dir);
	if (($opts & WHINE) && $nfs) {
		$state->errsay("#1 (#2) is under nfs", $dirname, $dir);
	}
		
	if ($state->{chown_all} && !$nfs && !($opts & MKPATH)) {
		$state->{$username}->mkRpath($dir);
	} 
}


sub make_ports_subdirs
{
	my $state = shift;
	$state->run_chroot("Adjusting ports directories",
	    sub {
	    	$state->build_dir(0, "fetchuser", "DISTDIR");
		if (defined $state->{loguser}) {
			$state->build_dir(0, "loguser", "LOGDIR"); 
			$state->build_dir(0, "loguser", "DISTDIR", "build-stats"); 
		}

		$state->build_dir(WHINE|MKPATH , "builduser", "WRKOBJDIR");
		$state->build_dir(0, "builduser", "PACKAGE_REPOSITORY");
		$state->build_dir(0, "builduser", "PLIST_REPOSITORY");
		$state->build_dir(WHINE, "builduser", "LOCKDIR");
	    });
}

sub write_mk_conf
{
	my $state = shift;
	$state->banner("Writing mk.conf",
	    sub {
		open(my $f, ">", $state->chroot("/etc/mk.conf"));
		print $f "# Automatically generated by $state->{cmd}\n\n";
		for my $i (sort keys %{$state->{write}}) {
			print $f "$i = $state->{$i}\n";
		}
		if (exists $state->{mkconf_lines}) {
			print $f "\n";
			for my $l (@@{$state->{mkconf_lines}}) {
				print $f $l, "\n";
			}
		}
		if (exists $state->{mkconf_tail}) {
			open(my $g, "<", $state->{mkconf_tail}) or
			    $state->fatal_error("Couldn't read tail #1: #2",
				$state->{mkconf_tail}, $!);
			print $f "# Copied from $state->{mkconf_tail}\n";
			while(<$g>) {
				print $f $_;
			}
			close $g;
		}
		close($f);
	    });
}

package main;

my $state = MyState->new("proot");
$state->handle_options;
if ($state->{actions}{check_mount}) {
	$state->check_mountpoint;
}
if ($state->{actions}{unpopulate}) {
	$state->unpopulate_chroot;
}
if ($state->{actions}{locate}) {
	$state->read_locates;
}

if ($state->{actions}{snapshot}) {
	$state->get_snapshot;
}
if ($state->{actions}{resolv}) {
	$state->special_data;
}
if (defined $state->{known}) {
	$state->copy_sync;
}
if ($state->{actions}{copy_ports}) {
	$state->copy_ports;
}
if ($state->{actions}{copy_sys}) {
	$state->copy_sys;
}
if ($state->{actions}{ldconfig}) {
	$state->run_ldconfig;
}
if ($state->{actions}{unpopulate_light}) {
	$state->unpopulate_chroot;
}
if ($state->{actions}{devs}) {
	$state->regen_devs;
}
if ($state->{actions}{checkout_ports}) {
	$state->checkout_ports;
}
if ($state->{actions}{ports_subdirs}) {
	$state->make_ports_subdirs;
}
if ($state->{actions}{stragglers}) {
	$state->verbose_shit;
}
if ($state->{actions}{write_mk} && 
    exists $state->{write} || exists $state->{mkconf_tail}) {
	$state->write_mk_conf;
}
if ($state->{actions}{check_symlinks}) {
	$state->show_absolute_symlinks;
}

exit($state->{error});
@


1.54
log
@run dev_mkdb after MAKEDEV.
@
text
@d3 1
a3 1
# $OpenBSD: proot,v 1.53 2016/06/16 18:17:44 espie Exp $
a198 4
	    }, key => sub {
	    	$state->{key} = $v;
		$state->{SIGNING_PARAMETERS} = 
		    "-s signify -s /etc/signify/$v-pkg.sec";
d327 1
a327 1
	for my $i (qw(PORTSDIR DISTDIR WRKOBJDIR PACKAGE_REPOSITORY PLIST_REPOSITORY LOCKDIR LOGDIR SIGNING_PARAMETERS)) {
a493 7
sub key_data
{
	my $state = shift;
	$state->{known}{"/etc/signify/$state->{key}-pkg.pub"} = 1;
	$state->{known}{"/etc/signify/$state->{key}-pkg.sec"} = 1;
}

a1069 3
}
if ($state->{key}) {
	$state->key_data;
@


1.53
log
@synch with base. put the call in an eval for now so it doesn't error out,
will just fuck up display slightly if you don't have current base
@
text
@d3 1
a3 1
# $OpenBSD: proot,v 1.52 2016/06/06 22:14:20 espie Exp $
d840 4
@


1.52
log
@keep going even after warnings during the copy process
they happen so often...
@
text
@d3 1
a3 1
# $OpenBSD: proot,v 1.51 2016/06/04 17:22:11 espie Exp $
a34 12
package OpenBSD::ProgressMeter::Term;
sub changed
{
	my $self = shift;
	$self->{lastdisplay} = ' 'x($self->{width}-1);
}

package OpenBSD::ProgressMeter;
sub changed
{
}

d417 3
a419 1
	$self->{progressmeter}->changed;
@


1.51
log
@fix 2 issues, bogus next (patch by semarie@@) and a more dire one: unpopulate
should use accounted, not known.

Fixes snapshots + cleanup issue, ouchie. Issue found by semarie@@ again.
@
text
@d3 1
a3 1
# $OpenBSD: proot,v 1.50 2016/06/04 12:36:06 espie Exp $
a1092 3
}
if ($state->{error}) {
	exit(1);
@


1.50
log
@allow not copying CVS subdirs in the ports tree (ignorecvs)

set checkout_ports to 1 by default if portscvs is defined.
@
text
@d3 1
a3 1
# $OpenBSD: proot,v 1.49 2016/06/04 12:22:02 espie Exp $
d485 1
a485 1
	do {
d497 1
a497 1
	} while ($mnt ne dirname($mnt));
d908 1
a908 1
			if ($state->{known}{$File::Find::name}) {
@


1.49
log
@let actions=none work as intended
@
text
@d3 1
a3 1
# $OpenBSD: proot,v 1.48 2016/06/04 11:58:36 espie Exp $
d184 2
d317 4
d794 4
@


1.48
log
@a few important changes:
- run unpopulate_light by default;
- make an explicit list of preserved data in the manpage.
- don't preserve PORTSDIR if we copy_ports. Don't store extra stuff there.
- register fatal errors and exit(1).
- move a lot of things before unpopulate_light so that clean-up is more
accurate.
- recognize wxallowed. Those checks are a bit simplistic yet.
- clean-up old redundant code
@
text
@d3 1
a3 1
# $OpenBSD: proot,v 1.47 2016/05/28 08:42:23 espie Exp $
d197 2
a198 1
		} elsif ($v =~ m/^-(.*)/) {
d307 2
a308 1
	    !defined $state->{actions}{locate}) {
@


1.47
log
@protect preserved stuff better during the actual copy
@
text
@d3 1
a3 1
# $OpenBSD: proot,v 1.46 2016/05/26 00:08:02 espie Exp $
d116 7
d224 1
a224 1
		$state->errsay("Unknown options #1=#2", $k, $v);
d244 1
a244 1
			$state->errsay("Error in config file #1: #2", 
d262 1
d276 1
d313 3
d351 1
a351 2
	for my $dir (qw(PORTSDIR DISTDIR WRKOBJDIR LOGDIR PACKAGE_REPOSITORY PLIST_REPOSITORY LOCKDIR)) {
		next if !defined $state->{$dir};
d355 5
d436 1
a436 1
	my ($dev, $nosuid);
d452 5
d478 10
a487 5
		if (defined $dev->{$mnt}) {
			$state->errsay("#1 is under #2 which is nodev (that won't work)", $root, $mnt)
			    if $dev->{$mnt} == 0;
			$state->errsay("#1 is under #2 which does not have nosuid",
				$root, $mnt) if $nosuid->{$mnt} == 0;
a488 2
		}
	    $mnt = dirname($mnt);
d490 1
a490 1
	$state->errsay("Couldn't find mountpoint for #1 ???", $root);
d540 2
a541 1
			$state->errsay("Can't read link to #1: #2", $path, $!);
d544 2
a545 2
			    $state->errsay("Can't symlink #1 -> #2", $target, 
				$cpath);
d558 1
a558 1
				$state->errsay("Can't mkdir #1", $cpath);
d608 1
a608 1
	$state->errsay("Can't copy #1: #2", $path, $!);
a886 3
	    	for my $item (@@{$state->{preserved}}) {
			$state->{dontrm}{$item} = 1;
		}
a917 3
		for my $dir (@@{$state->{preserved}}) {
			$state->{dontrm}{$dir} = 1;
		}
d1044 1
a1044 1
			    $state->errsay("Couldn't read tail #1: #2",
d1082 12
a1099 6
if ($state->{actions}{ldconfig}) {
	$state->run_ldconfig;
}
if ($state->{actions}{copy_ports}) {
	$state->copy_ports;
}
a1102 3
if ($state->{actions}{copy_sys}) {
	$state->copy_sys;
}
d1116 2
@


1.46
log
@fix a nasty update bug
@
text
@d3 1
a3 1
# $OpenBSD: proot,v 1.45 2016/05/23 13:36:25 espie Exp $
d108 23
d174 1
a174 1
		    push(@@{$state->{preserved}}, $v);
d290 1
d314 1
a314 1
		push(@@{$state->{preserved}}, $1);
d342 1
a342 1
		push(@@{$state->{preserved}}, $state->{$dir});
d449 2
a452 1
			$state->say("Preserve #1", $1);
d512 1
a512 1
		return if $state->{dontrm}{$cpath};
d518 3
a520 1
			symlink($target, $cpath);
d527 2
a528 1
			if (!-d $cpath) {
d532 3
d552 1
d566 1
d583 1
a583 1
	$state->errsay("Can't copy #1", $path);
d812 1
a812 1
		push(@@{$state->{preserved}}, "/dev");
@


1.45
log
@completely kill PLIST_DB here. After all, it's new stuff,
so people should be able to adapt quickly.
@
text
@d3 1
a3 1
# $OpenBSD: proot,v 1.44 2016/05/20 09:55:25 espie Exp $
d521 1
@


1.44
log
@switch to PLIST_REPOSITORY, keep PLIST_DB glue for a few days
@
text
@d3 1
a3 1
# $OpenBSD: proot,v 1.43 2016/05/19 13:40:27 espie Exp $
a138 2
	    }, PLIST_DB => sub {
		    $state->{PLIST_DB} = File::Spec->canonpath($v);
d299 1
a299 1
	for my $i (qw(PORTSDIR DISTDIR WRKOBJDIR PACKAGE_REPOSITORY PLIST_REPOSITORY PLIST_DB LOCKDIR LOGDIR SIGNING_PARAMETERS)) {
d313 1
a313 4
	if (!defined $state->{PLIST_DB}) {
		$state->{PLIST_REPOSITORY} 
		    //= join('/', $state->{PORTSDIR}, 'plist');
	}
d315 1
a315 1
	for my $dir (qw(PORTSDIR DISTDIR WRKOBJDIR LOGDIR PACKAGE_REPOSITORY PLIST_REPOSITORY PLIST_DB LOCKDIR)) {
a599 3
	elsif (m/^\Q$state->{PLIST_DB}\E/) {
		return $state->{builduser};
	}
d968 1
a968 5
		if (defined $state->{PLIST_DB}) {
			$state->build_dir(0, "builduser", "PLIST_DB");
		} else {
			$state->build_dir(0, "builduser", "PLIST_REPOSITORY");
		}
@


1.43
log
@make it possible to directly add lines at end of generated mk.conf.

make option handling more obvious, no actual change.
@
text
@d3 1
a3 1
# $OpenBSD: proot,v 1.42 2016/05/17 16:23:02 espie Exp $
d141 2
d147 2
a148 3
		    my $arch = OpenBSD::Paths->machine_architecture;
		    $state->{PLIST_DB} = 
		    	File::Spec->canonpath("$v/plist/$arch");
d301 1
a301 1
	for my $i (qw(PORTSDIR DISTDIR WRKOBJDIR PACKAGE_REPOSITORY PLIST_DB LOCKDIR LOGDIR SIGNING_PARAMETERS)) {
d315 4
a318 2
	my $arch = OpenBSD::Paths->machine_architecture;
	$state->{PLIST_DB} //= join('/', $state->{PORTSDIR}, 'plist', $arch);
d320 2
a321 4
	for my $dir (qw(PORTSDIR DISTDIR WRKOBJDIR LOGDIR PACKAGE_REPOSITORY PLIST_DB LOCKDIR)) {
		if (!defined $state->{$dir}) {
			$state->fatal("Missing #1", $dir);
		}
d602 4
a605 1
	if (m/^\Q$state->{PLIST_DB}\E/) {
d976 5
a980 1
		$state->build_dir(0, "builduser", "PLIST_DB");
@


1.42
log
@typo in conversion
@
text
@d3 1
a3 1
# $OpenBSD: proot,v 1.41 2016/05/17 16:16:17 espie Exp $
d187 3
a189 1
	    },
a226 6
	$state->{no_exports} = 1;
	$state->{opt} = {
		B => sub { $state->{fchroot} = File::Spec->canonpath(shift); },
		S => sub { $state->{fsrcroot} = File::Spec->canonpath(shift); },
		c => sub { $state->read_configfile(shift); },
	    };
d245 7
d255 1
a264 2

	# command-line options trump configuration file
d271 2
d983 1
a983 1
		print $f "# Automatically generated by $state->{cmd}\n";
d986 6
@


1.41
log
@PORT_USER is required for checkout_ports (cryptic error noticed by juanfra)
@
text
@d3 1
a3 1
# $OpenBSD: proot,v 1.40 2016/05/17 13:14:45 espie Exp $
d814 1
a814 1
			    	sub { $state->chdir($dir); },
@


1.40
log
@fix (for now)
@
text
@d3 1
a3 1
# $OpenBSD: proot,v 1.39 2016/05/15 20:31:05 rpe Exp $
d280 4
@


1.39
log
@fix typo

OK espie
@
text
@d3 1
a3 1
# $OpenBSD: proot,v 1.38 2016/05/15 14:14:45 espie Exp $
d306 2
a307 1
	$state->{PLIST_DB} //= join('/', $state->{PORTSDIR}, 'plist');
@


1.38
log
@variables for simpler dpb builds
@
text
@d3 1
a3 1
# $OpenBSD: proot,v 1.37 2016/05/15 13:25:25 espie Exp $
d292 1
a292 1
	for my $i (qw(PORTSDIR DISTDIR WRKOBJDIR PACKAGE_REPOSTORY PLIST_DB LOCKDIR LOGDIR SIGNING_PARAMETERS)) {
@


1.37
log
@have check_mount be removable as well (bad idea) and add
actions=none
to reset to nothing
@
text
@d3 1
a3 1
# $OpenBSD: proot,v 1.36 2016/05/15 11:06:57 espie Exp $
d141 10
@


1.36
log
@tweak interface, add extra to copy extra files,
mkconf_tail to add a tail to generated mk.conf.
zap copying doas.conf, which is not really that useful especially
since chroot is nosuid often.
@
text
@d3 1
a3 1
# $OpenBSD: proot,v 1.35 2016/05/15 10:24:38 espie Exp $
d156 3
a158 1
	    	if ($v =~ m/^-(.*)/) {
d986 3
a988 1
$state->check_mountpoint;
@


1.35
log
@get rid of the last chdir
@
text
@d3 1
a3 1
# $OpenBSD: proot,v 1.34 2016/05/15 10:00:16 espie Exp $
d171 4
a431 3
	if (-f '/etc/doas.conf') {
		$state->{known}{'/etc/doas.conf'} = 1;
	}
d966 10
d991 1
d1001 1
a1001 1
if ($state->{actions}{resolv} || $state->{actions}{locate}) {
d1028 2
a1029 1
if ($state->{actions}{write_mk} && exists $state->{write}) {
@


1.34
log
@remove more chdirs from the main process
@
text
@d3 1
a3 1
# $OpenBSD: proot,v 1.33 2016/05/14 22:49:23 espie Exp $
d702 6
a707 3
		my $srcports = $state->srcroot($state->{PORTSDIR});
		$state->chdir($srcports);
		$state->{portuser}->mkpath($state->chroot($state->{PORTSDIR}));
a708 3
			my $d = $File::Find::dir;
			$d =~ s/^\.\///;
			$state->{progressmeter}->message($d);
d710 1
d712 1
a712 2
			$realname =~ s,^\./,$srcports/,;
			$r2 =~ s,^\./,$state->{PORTSDIR}/,;
d717 4
a720 2
			$state->simple_copy($realname, $state->chroot($r2),
			    $state->best_user($r2));
@


1.33
log
@zap yet another chdir
@
text
@d3 1
a3 1
# $OpenBSD: proot,v 1.32 2016/05/14 15:19:48 espie Exp $
a783 1
			$state->chdir($dir);
d785 3
a787 1
			    $state->system(@@cvs, "update", "-dP", "-A");
a791 1
			$state->chdir("$dir.tmp");
d793 3
a795 1
			    $state->system(@@cvs, "co", "-P", "-A", "ports");
@


1.32
log
@smarter copy of sys includes, no chdir
don't copy obj/ or CVS/
@
text
@d3 1
a3 1
# $OpenBSD: proot,v 1.31 2016/05/14 15:00:07 espie Exp $
d754 4
a757 2
		$state->chdir($state->chroot("/dev"));
		$state->system('/bin/sh', './MAKEDEV', 'all');
@


1.31
log
@start removing uses of chdir() in main process
@
text
@d3 1
a3 1
# $OpenBSD: proot,v 1.30 2016/05/14 13:55:42 espie Exp $
d472 5
a476 1
		symlink($target, $cpath);
d731 2
a732 2
		my $sysdir = $state->srcroot($state->{sysdir});
		$state->chdir($sysdir);
d736 9
a744 7
			my $realname = $File::Find::name;
			my $r2 = $realname;
			$realname =~ s,^\.,$sysdir,;
			$r2 =~ s,^\.,$state->{sysdir},;
			$state->{progressmeter}->message($realname);
			$state->simple_copy($realname, $state->chroot($r2));
		    }, ".");
@


1.30
log
@kill unneeded special case from copy_sys
@
text
@d3 1
a3 1
# $OpenBSD: proot,v 1.29 2016/05/14 11:16:29 espie Exp $
d592 1
a592 1
	my ($state, $file) = @@_;
d597 3
a599 3
		if ($state->system('/usr/bin/ftp' , "-C", "-o", "$file.part", 
		    "$baseurl/$file") == 0) {
			rename("$file.part", $file);
d644 1
a644 1
			$grab = sub { $state->grab_file(shift); }
a648 1
		$state->chdir($snapdir);
d651 2
a652 1
		open my $f, '<', "SHA256.sig" or $state->fatal("no SHA256.sig");
d659 1
a659 1
		for my $set (keys %{$state->{sets}}) {
d668 4
a671 1
		if ($state->system('/usr/bin/signify', '-C', '-p',
d685 1
a685 1
				unlink($file);
d715 1
a715 1
		    }, ".");
@


1.29
log
@copy doas.conf if it exists (convenience request from landry)

use devno to filter out mount points (more sturdy when symlinks happen)

FIX the regexp used for mount points which did kill unpopulate too much
@
text
@d3 1
a3 1
# $OpenBSD: proot,v 1.28 2016/05/14 10:05:55 espie Exp $
a725 1
		$state->{portuser}->mkpath($state->chroot($state->{sysdir}));
a728 1
			$state->{progressmeter}->working(1000);
d731 3
a733 2
			$realname =~ s,^\./,$sysdir/,;
			$r2 =~ s,^\./,$state->{sysdir}/,;
@


1.28
log
@not yet
@
text
@d3 1
a3 1
# $OpenBSD: proot,v 1.27 2016/05/14 09:19:09 espie Exp $
d403 3
a405 2
		if ($dir =~ m/^\Q$root\E\b(.*)/) {
			$state->{dontrm}{$1} = 1;
d428 3
d796 2
a797 2
	    	for my $dir (@@{$state->{preserved}}) {
			$state->{dontrm}{$dir} = 1;
d802 4
a805 5
			if (-d $_ && $state->{dontrm}{$File::Find::name}) {
				$File::Find::prune = 1;
				return;
			}
			if ($state->{dontrm}{$File::Find::name}) {
d812 1
a812 1
		    	if (-l $_ || !-d $_) {
@


1.27
log
@if one of your dirs is a symlink that doesn't point anywhere, then
stat will fail, which is okay for LOGDIR which only exists locally.
@
text
@d3 1
a3 1
# $OpenBSD: proot,v 1.26 2016/05/14 09:04:40 espie Exp $
d448 1
a448 1
			next if $path =~ m/\.ph$/;
@


1.26
log
@accidentally broke preserved mountpoints, fix that
@
text
@d3 1
a3 1
# $OpenBSD: proot,v 1.25 2016/05/13 22:40:28 espie Exp $
d448 1
d894 1
a894 1
	if (exists $state->{nfs}{$devno}) {
@


1.25
log
@always do mkpath, THEN check for nfs mounts, so that non-existing
dirs (at first) get classified correctly.

thx aja@@ for testing on a virgin dir
@
text
@d3 1
a3 1
# $OpenBSD: proot,v 1.24 2016/05/13 14:30:06 espie Exp $
d403 3
a405 3
		if ($dir =~ m/^\Q$state->{chroot}\//) {
			$state->{dontrm}{$dir} = 1;
			$state->say("Preserve #1", $dir);
@


1.24
log
@tweak user message, requested by dcoppa@@
@
text
@d3 1
a3 1
# $OpenBSD: proot,v 1.23 2016/05/13 14:17:24 espie Exp $
d907 1
d915 1
a915 3
	} else {
		$state->{$username}->mkpath($dir);
	}
@


1.23
log
@check for absolute symlinks in the chroot.
report anything that we don't know about (from the base system)
@
text
@d3 1
a3 1
# $OpenBSD: proot,v 1.22 2016/05/13 13:37:22 espie Exp $
d546 2
a547 1
	$state->banner("Copying shit over",
@


1.22
log
@things that live strictly in the chroot can mostly be run there.
this solves the issue of resolving symlinks within the chroot
and matching them against nfs dirs, at the expense of a few more processes
@
text
@d3 1
a3 1
# $OpenBSD: proot,v 1.21 2016/05/13 02:38:03 espie Exp $
d846 41
d1000 3
@


1.21
log
@try to copy mtimes and use that to check
@
text
@d3 1
a3 1
# $OpenBSD: proot,v 1.20 2016/05/12 13:14:13 espie Exp $
d35 12
d327 1
a327 1
	chdir($dir) or $state->fatal("Can't change to #1: #2", $dir, $!);
d338 27
d391 1
d393 1
a393 1
				push(@@{$state->{nfs}}, $dir);
d751 4
a754 1
		$state->system(OpenBSD::Paths->chroot, $state->chroot, 
d788 1
a788 1
	$state->banner("Cleaning up files and directories",
d791 1
a791 1
			$state->{dontrm}{$state->chroot($dir)} = 1;
d803 1
a803 3
		    	my $file =$File::Find::name;
			$file =~ s/^\Q$state->{chroot}\E//;
			if ($state->{known}{$file}) {
d806 1
a806 1
		    	$state->{progressmeter}->message($file);
d812 1
a812 1
		    }, $state->{chroot});
d819 1
d823 1
a823 1
	$state->banner("Showing up stragglers",
d826 1
a826 1
			$state->{dontrm}{$state->chroot($dir)} = 1;
d837 2
a838 3
		    	my $f = $File::Find::name;
			$f =~ s/^\Q$state->{chroot}\E//;
			if ($state->{accounted}{$f} || $f eq '') {
d842 1
a842 1
		    }, $state->{chroot});
d850 5
a854 4
	for my $root (@@{$state->{nfs}}) {
		if ($dir =~ m/^\Q$root\E\b/) {
			return 1;
		}
a855 1
	return 0;
d864 1
a864 1
	my $dir = $state->chroot($state->{$dirname}, @@r);
d881 1
a881 1
	$state->banner("Adjusting ports directories",
@


1.20
log
@surprised this one didn't break more things
thanks ken/stuart
@
text
@d3 1
a3 1
# $OpenBSD: proot,v 1.19 2016/05/11 12:51:07 espie Exp $
d430 2
a431 2
		my ($dev, $ino, $mode, $uid, $gid, $sz) = 
		    (stat $path)[0, 1, 2, 4, 5, 7];
d443 1
d446 2
a447 1
			my ($dev2, $ino2, $sz2) = (stat $cpath)[0, 1, 7];
d463 1
a463 1
			if (defined $sz2 && $sz2 == $sz) {
d476 1
@


1.19
log
@add the actual option "chown_all"
@
text
@d3 1
a3 1
# $OpenBSD: proot,v 1.18 2016/05/11 12:50:02 espie Exp $
d442 1
@


1.18
log
@add some smarts to the ports directory checker: whine if WRKOBJDIR or
LOCKDIR are under nfs (often not a good idea), don't chown recursively
by default, and don't even when under nfs
@
text
@d3 1
a3 1
# $OpenBSD: proot,v 1.17 2016/05/10 16:13:31 espie Exp $
d133 2
@


1.17
log
@prevent unpopulate from wiping out ports subdirectories
@
text
@d3 1
a3 1
# $OpenBSD: proot,v 1.16 2016/05/10 15:48:18 espie Exp $
d338 1
a338 1
			my ($dir, $options) = ($2, $4);
d350 3
d799 32
d836 1
a836 2
	    	$state->{progressmeter}->message("DISTDIR");
	    	$state->{fetchuser}->mkRpath($state->chroot($state->{DISTDIR}), 'build-stats');
d838 8
a845 12
			$state->{progressmeter}->message("LOGDIR");
			$state->{loguser}->mkRpath($state->chroot($state->{LOGDIR}));
			$state->{loguser}->mkRpath($state->chroot($state->{DISTDIR}, "build-stats"));
			
		}
	    	$state->{builduser}->mkpath($state->chroot($state->{WRKOBJDIR}));
		$state->{progressmeter}->message("PACKAGE_REPOSITORY");
	    	$state->{builduser}->mkRpath($state->chroot($state->{PACKAGE_REPOSITORY}));
		$state->{progressmeter}->message("PLIST_DB");
	    	$state->{builduser}->mkRpath($state->chroot($state->{PLIST_DB}));
		$state->{progressmeter}->message("LOCKDIR");
		$state->{builduser}->mkRpath($state->chroot($state->{LOCKDIR}));
@


1.16
log
@give directory contents to the appropriate users
@
text
@d3 1
a3 1
# $OpenBSD: proot,v 1.15 2016/05/10 15:31:17 espie Exp $
d278 2
a279 4
	for my $dir (qw(PORTSDIR DISTDIR WRKOBJDIR LOGDIR PACKAGE_REPOSITORY PLIST_DB)) {
		if (defined $state->{$dir}) {
			$state->{$dir} = $state->canonical_dir($state->{$dir});
		} else {
d282 2
@


1.15
log
@If -B parameter is a symlink, resolve it before looking at mountpoints
@
text
@d3 1
a3 1
# $OpenBSD: proot,v 1.14 2016/05/10 15:29:53 espie Exp $
d39 2
d56 18
d86 1
d799 1
a799 1
	$state->banner("Making out extra directories",
d801 2
a802 1
	    	$state->{fetchuser}->mkpath($state->chroot($state->{DISTDIR}));
d804 4
a807 1
			$state->{loguser}->mkpath($state->chroot($state->{LOGDIR}));
d810 6
a815 3
	    	$state->{builduser}->mkpath($state->chroot($state->{PACKAGE_REPOSITORY}));
	    	$state->{builduser}->mkpath($state->chroot($state->{PLIST_DB}));
		$state->{builduser}->mkpath($state->chroot($state->{LOCKDIR}));
@


1.14
log
@add support for a signing key
@
text
@d3 1
a3 1
# $OpenBSD: proot,v 1.13 2016/05/10 10:44:07 espie Exp $
d333 3
@


1.13
log
@be slightly more intelligent with snapshots.
if we download them and install them okay, rm the temp copy.
if they're already downloaded in a dir under the chroot, don't rm
them during unpopulate stages.
@
text
@d3 1
a3 1
# $OpenBSD: proot,v 1.12 2016/05/10 09:13:47 espie Exp $
d132 4
a136 1
	    	
d241 1
a241 1
	for my $i (qw(PORTSDIR DISTDIR WRKOBJDIR PACKAGE_REPOSTORY PLIST_DB LOCKDIR LOGDIR)) {
d360 7
d818 3
@


1.12
log
@tweak unpopulate to ignore known files and dirs.

add an "unpopulate_light" action that runs *after* copy_sync, so that
it only removes stuff it doesn't know about.
@
text
@d3 1
a3 1
# $OpenBSD: proot,v 1.11 2016/05/10 08:52:52 espie Exp $
d227 5
d591 5
a595 1

@


1.11
log
@also copy /etc/hosts along with resolv.conf
that way we get localhost without network and other local machines
@
text
@d3 1
a3 1
# $OpenBSD: proot,v 1.10 2016/05/08 11:51:40 espie Exp $
d708 6
a713 3
		    	my $dir =$File::Find::dir;
			$dir =~ s/^\Q$state->{chroot}\E//;
		    	$state->{progressmeter}->message($dir);
a714 1
				#$state->say("unlink #1", $File::Find::name);
d791 3
a796 4
if ($state->{actions}{locate}) {
	$state->read_locates;
}

d803 3
a805 1

@


1.10
log
@reuse the User code in dpb instead of copying it.
@
text
@d3 1
a3 1
# $OpenBSD: proot,v 1.9 2016/05/03 09:12:51 espie Exp $
d349 1
@


1.9
log
@assuming we're populating the same partition, test for identical hardlinks
@
text
@d3 1
a3 1
# $OpenBSD: proot,v 1.8 2016/05/03 09:08:17 espie Exp $
d22 7
d33 4
a37 1
package User;
a38 1

d41 2
a42 39
	my ($class, $u) = @@_;
	# XXX getpwnam for local access, distant access is different
	if (my ($l, undef, $uid, $gid) = getpwnam $u) {
		my $groups = `/usr/bin/id -G $u`;
		chomp $groups;
		my $group = getgrgid($gid);
		bless { user => $l, uid => $uid, 
		    group => $group, gid => $gid,
		    grouplist => "$gid $groups" }, $class;
	} else {
		bless { user => $u}, $class;
	}
}

sub enforce_local
{
	my $self = shift;
	if (!defined $self->{uid}) {
		print STDERR "User $self->{user} does not exist locally\n";
		exit 1;
	} else {
		return $self;
	}
}

sub run_as
{
	my ($self, $code) = @@_;
	local $> = 0;
	local $) = $self->{grouplist};
	$> = $self->{uid};
	&$code;
}

sub mkdir
{
	my ($self, $dir) = @@_;
	mkdir($dir);
	$self->own($dir);
a53 1

d60 1
a60 4
package LocalUser;
our @@ISA = qw(User);

sub new
d62 3
a64 2
	my $class = shift;
	return $class->SUPER::new(@@_)->enforce_local;
a65 1

d93 1
a93 1
		    $state->{portuser} = LocalUser->new($v);
d95 1
a95 1
		    $state->{loguser} = LocalUser->new($v);
d97 1
a97 1
		    $state->{fetchuser} = LocalUser->new($v);
d99 1
a99 1
		    $state->{builduser} = LocalUser->new($v);
d243 2
a244 2
	$state->{fetchuser} //= LocalUser->new('_pfetch');
	$state->{builduser} //= LocalUser->new('_pbuild');
d317 2
a319 2
			} else {
				$nosuid->{$dir} = 1;
d334 1
a334 1
			$state->errsay("#1 is under #2 which is nodev", $root, $mnt)
d379 1
@


1.8
log
@tweakable: make it possible to extract more sets or to change all users
@
text
@d3 1
a3 1
# $OpenBSD: proot,v 1.7 2016/05/03 05:02:38 espie Exp $
d430 4
a444 1
			my $sz2 = (stat $cpath)[7];
@


1.7
log
@fix semantics to match dpb
@
text
@d3 1
a3 1
# $OpenBSD: proot,v 1.6 2016/05/02 06:56:30 espie Exp $
d128 4
d158 6
d165 1
d218 9
d394 2
a395 1
			if ($set =~ m/^(x?base|comp|x?etc|xfont|xshare)/) {
d591 9
a599 5
		my @@files;
		for my $set (qw(base comp xbase xfont xshare)) {
			my $file = "$set$v.tgz";
			&$grab($file);
			push(@@files, $file);
d609 1
a609 1
		for my $archive ("etc.tgz", "xetc.tgz") {
@


1.6
log
@need to put more stuff in generated mk.conf
@
text
@d3 1
a3 1
# $OpenBSD: proot,v 1.5 2016/05/01 08:39:43 espie Exp $
d257 1
a257 1
	$state->{loguser} //= $state->{portuser};
@


1.5
log
@no need to use external tar, when we have a serviceable library that can
give us filenames as we go.
@
text
@d3 1
a3 1
# $OpenBSD: proot,v 1.4 2016/04/30 09:13:48 espie Exp $
d245 1
a245 1
	for my $i (qw(PORTSDIR DISTDIR WRKOBJDIR LOCKDIR LOGDIR)) {
d776 1
a776 1
		for my $i (keys %{$state->{write}}) {
@


1.4
log
@fix command line repeated options
@
text
@d3 1
a3 1
# $OpenBSD: proot,v 1.3 2016/04/29 14:49:33 espie Exp $
d519 27
a580 2
		$state->chdir($state->chroot);
		open(my $fh, "+>", "$snapdir/listing");
d582 1
a582 6
			$state->say("Extracting #1", $archive);
			if ($state->system(sub {
			    open(STDOUT, '>&', $fh); },
			    '/bin/tar', 'zxvpf', "$snapdir/$archive") != 0) {
				$state->fatal("Error while extracting #1", $archive);
			}
d585 2
a586 12
			$state->say("Extracting #1", $archive);
				if ($state->system(sub {
				    open(STDOUT, '>&', $fh); },
				    "/bin/tar", 'zxvpf', "var/sysmerge/$archive") != 0) {
				$state->fatal("Error while extracting #1", $archive);
			}
		}
		seek($fh, 0, 0);
		while (<$fh>) {
			chomp;
			s/^\.//;
			$state->{accounted}{$_} = 1;
@


1.3
log
@polish command name
@
text
@d3 1
a3 1
# $OpenBSD: proot,v 1.2 2016/04/29 14:47:32 espie Exp $
d214 2
a215 2
		} elsif ($arg =~ m/^\s+(.*)$/) {
			$v = $1;
@


1.2
log
@tweak options
@
text
@d3 1
a3 1
# $OpenBSD: proot,v 1.1 2016/04/29 14:27:15 espie Exp $
d765 1
a765 1
		print $f "# Automatically generated by $0\n";
d775 1
a775 1
my $state = MyState->new("populate_chroot");
@


1.1
log
@new tool: ports chroot builder

options WILL change, documentation soon, more integration with the
rest of the tree soon.

name coined by aja@@
@
text
@d3 1
a3 1
# $OpenBSD$
d115 1
a115 1
sub handle_options
d117 1
a117 17
	my $state = shift;
	$state->{no_exports} = 1;
	$state->{opt} = {
		B => sub { $state->{chroot} = File::Spec->canonpath(shift); },
		S => sub { $state->{srcroot} = File::Spec->canonpath(shift); },
		c => sub { $state->read_configfile(shift); },
	    };
	# default shit
	$state->{actions} = {
	    check_mount => 1,
	    devs => 1,
	    ldconfig => 1,
	    ports_subdirs => 1,
	    resolv => 1,
	    write_mk => 1,
	};
	$state->SUPER::handle_options("B:S:c:mx", "[-B chroot] [-S chroot]");
a118 44
	if (!defined $state->{chroot}) {
		$state->usage("need a chroot base");
	}
	$state->{progressmeter} = OpenBSD::ProgressMeter->new;
	$state->{progressmeter}->setup($state->opt('x'), $state->opt('m'), 
	    $state);
	if ($< != 0) {
		$state->fatal("Must be root");
	}
	for my $i (qw(PORTSDIR DISTDIR WRKOBJDIR LOCKDIR LOGDIR)) {
		if (defined $state->{$i}) {
			$state->{write}{$i} = 1;
		}
	}
	$state->{PORTSDIR} //= "/usr/ports";
	$state->{DISTDIR} //= join('/', $state->{PORTSDIR}, 'distfiles');
	$state->{WRKOBJDIR} //= join('/', $state->{PORTSDIR}, 'pobj');
	$state->{LOCKDIR} //= join('/', $state->{WRKOBJDIR}, 'locks');
	$state->{LOGDIR} //= join('/', $state->{PORTSDIR}, 'logs');
	$state->{fetchuser} //= LocalUser->new('_pfetch');
	$state->{builduser} //= LocalUser->new('_pbuild');
	$state->{loguser} //= $state->{portuser};
	$state->{PACKAGE_REPOSITORY} //= join('/', $state->{PORTSDIR}, 'packages');
	$state->{PLIST_DB} //= join('/', $state->{PORTSDIR}, 'plist');
	$state->{sysdir} //= '/usr/src/sys';
	for my $dir (qw(PORTSDIR DISTDIR WRKOBJDIR LOGDIR PACKAGE_REPOSITORY PLIST_DB)) {
		if (defined $state->{$dir}) {
			$state->{$dir} = $state->canonical_dir($state->{$dir});
		} else {
			$state->fatal("Missing #1", $dir);
		}
	}
	for my $i (qw(portuser loguser fetchuser builduser)) {
		if (defined $state->{$i}) {
			$state->say("#1: #2", $i, $state->{$i}->{user});
		}
	}
}

sub read_configfile
{
	my ($state, $name) = @@_;
	open(my $f, '<', $name) or die "Can't open config $name: $!";
	my ($k, $v);
d157 13
d184 47
a230 2
		if (defined $opts->{$k}) {
			&{$opts->{$k}};
d232 39
a270 1
			$state->errsay("Unknown options #1=#2", $k, $v);
a272 1
	close($f);
d749 3
a751 1
	    	$state->{loguser}->mkpath($state->chroot($state->{LOGDIR}));
@

