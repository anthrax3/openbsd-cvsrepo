head	1.26;
access;
symbols
	OPENBSD_6_1:1.26.0.26
	OPENBSD_6_1_BASE:1.26
	OPENBSD_6_0:1.26.0.24
	OPENBSD_6_0_BASE:1.26
	OPENBSD_5_9:1.26.0.20
	OPENBSD_5_9_BASE:1.26
	OPENBSD_5_8:1.26.0.22
	OPENBSD_5_8_BASE:1.26
	OPENBSD_5_7:1.26.0.18
	OPENBSD_5_7_BASE:1.26
	OPENBSD_5_6:1.26.0.16
	OPENBSD_5_6_BASE:1.26
	OPENBSD_5_5:1.26.0.14
	OPENBSD_5_5_BASE:1.26
	OPENBSD_5_4:1.26.0.12
	OPENBSD_5_4_BASE:1.26
	OPENBSD_5_3:1.26.0.10
	OPENBSD_5_3_BASE:1.26
	OPENBSD_5_2:1.26.0.8
	OPENBSD_5_2_BASE:1.26
	OPENBSD_5_1_BASE:1.26
	OPENBSD_5_1:1.26.0.6
	OPENBSD_5_0:1.26.0.4
	OPENBSD_5_0_BASE:1.26
	OPENBSD_4_9:1.26.0.2
	OPENBSD_4_9_BASE:1.26
	OPENBSD_4_8:1.25.0.2
	OPENBSD_4_8_BASE:1.25
	OPENBSD_4_7:1.19.0.4
	OPENBSD_4_7_BASE:1.19
	OPENBSD_4_6:1.19.0.2
	OPENBSD_4_6_BASE:1.19
	OPENBSD_4_5:1.18.0.2
	OPENBSD_4_5_BASE:1.18
	OPENBSD_4_4:1.17.0.2
	OPENBSD_4_4_BASE:1.17
	OPENBSD_4_3:1.16.0.4
	OPENBSD_4_3_BASE:1.16
	OPENBSD_4_2:1.16.0.2
	OPENBSD_4_2_BASE:1.16
	OPENBSD_4_1:1.11.0.2
	OPENBSD_4_1_BASE:1.11
	OPENBSD_4_0:1.9.0.2
	OPENBSD_4_0_BASE:1.9
	OPENBSD_3_9:1.7.0.2
	OPENBSD_3_9_BASE:1.7;
locks; strict;
comment	@# @;


1.26
date	2010.08.19.13.54.43;	author jasper;	state Exp;
branches;
next	1.25;

1.25
date	2010.08.07.19.49.10;	author espie;	state Exp;
branches;
next	1.24;

1.24
date	2010.08.06.10.15.17;	author espie;	state Exp;
branches;
next	1.23;

1.23
date	2010.07.19.17.40.17;	author espie;	state Exp;
branches;
next	1.22;

1.22
date	2010.07.14.09.58.48;	author espie;	state Exp;
branches;
next	1.21;

1.21
date	2010.06.30.11.11.19;	author espie;	state Exp;
branches;
next	1.20;

1.20
date	2010.06.11.11.20.48;	author espie;	state Exp;
branches;
next	1.19;

1.19
date	2009.04.26.08.45.09;	author espie;	state Exp;
branches;
next	1.18;

1.18
date	2008.10.06.09.37.02;	author espie;	state Exp;
branches;
next	1.17;

1.17
date	2008.04.12.13.09.58;	author espie;	state Exp;
branches;
next	1.16;

1.16
date	2007.06.16.12.14.53;	author espie;	state Exp;
branches;
next	1.15;

1.15
date	2007.06.02.12.23.28;	author espie;	state Exp;
branches;
next	1.14;

1.14
date	2007.05.21.21.24.56;	author espie;	state Exp;
branches;
next	1.13;

1.13
date	2007.05.20.17.27.51;	author espie;	state Exp;
branches;
next	1.12;

1.12
date	2007.05.13.08.03.47;	author espie;	state Exp;
branches;
next	1.11;

1.11
date	2006.10.19.00.15.46;	author bernd;	state Exp;
branches;
next	1.10;

1.10
date	2006.10.02.18.48.01;	author espie;	state Exp;
branches;
next	1.9;

1.9
date	2006.07.17.16.51.53;	author espie;	state Exp;
branches;
next	1.8;

1.8
date	2006.07.12.08.11.28;	author espie;	state Exp;
branches;
next	1.7;

1.7
date	2006.02.09.12.03.55;	author espie;	state Exp;
branches;
next	1.6;

1.6
date	2006.02.09.11.39.02;	author espie;	state Exp;
branches;
next	1.5;

1.5
date	2006.02.09.10.49.13;	author espie;	state Exp;
branches;
next	1.4;

1.4
date	2005.09.19.21.12.27;	author espie;	state Exp;
branches;
next	1.3;

1.3
date	2005.09.09.08.20.37;	author espie;	state Exp;
branches;
next	1.2;

1.2
date	2005.09.05.10.13.11;	author espie;	state Exp;
branches;
next	1.1;

1.1
date	2005.09.04.22.30.39;	author espie;	state Exp;
branches;
next	;


desc
@@


1.26
log
@- spello
@
text
@#! /usr/bin/perl

# $OpenBSD: register-plist,v 1.25 2010/08/07 19:49:10 espie Exp $
# Copyright (c) 2005
# Marc Espie.  All rights reserved.
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions
# are met:
# 1. Redistributions of code must retain the above copyright
#    notice, this list of conditions and the following disclaimer.
# 2. Neither the name of OpenBSD nor the names of its contributors
#    may be used to endorse or promote products derived from this software
#    without specific prior written permission.
#
# THIS SOFTWARE IS PROVIDED BY ITS AUTHOR AND THE OpenBSD project ``AS IS'' AND
# ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
# FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
# DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
# OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
# HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
# LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
# OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
# SUCH DAMAGE.

use strict;
use warnings;

use OpenBSD::State;
use OpenBSD::PackageInfo;
use OpenBSD::PackingList;
use OpenBSD::Paths;

package OpenBSD::PackingList;

sub write_mogrified
{
	my ($self, $file, $state) = @@_;
	open (my $fh, '>', $file) or 
	    $state->fatal("Can't write plist to #1: #2", $file, $!);
	$self->visit('write_mogrified', $fh, $state);

}

sub forget_details
{
	my $self = shift;
	undef $self->{ OpenBSD::PackageInfo::COMMENT };
	undef $self->{"digital-signature"};

	my $l = $self->{items};
	if ($l->[@@$l-1]->isa('OpenBSD::PackingElement::Cwd') &&
		$l->[@@$l-1]->{name} eq '.') {
	    pop @@$l;
	}
	$self->visit('forget_details');
}

package OpenBSD::PackingElement;

sub write_mogrified
{
	my ($self, $fh, $state) = @@_;
	if ($state->{mogrified}{$self}) {
		$state->{mogrified}{$self}->write($fh);
	} else {
		$self->write($fh);
	}
}

sub forget_details
{
}

sub flatten
{
	my ($self, $l) = @@_;
	push(@@$l, $self);
}

sub compare
{
	my ($self, $self2) = @@_;
	my ($data, $data2);
	open(my $fh, '>',  \$data);
	open(my $fh2, '>',  \$data2);
	$self->write($fh);
	$self2->write($fh2);
	close($fh);
	close($fh2);
	if ($data ne $data2) {
		return 1;
	} else {
		return 0;
	}
}

sub remove_auxiliary
{
	return 0;
}

sub record_generic_depends
{
}

sub find_mogrified
{
}

package OpenBSD::PackingElement::DigitalSignature;
sub flatten
{
}

package OpenBSD::PackingElement::Old;
sub flatten
{
	my ($self, $l) = @@_;
	if ($self->{keyword} eq 'ignore') {
		return;
	}
	$self->SUPER::flatten($l);
}

package OpenBSD::PackingElement::FileBase;

sub forget_details
{
	my $self = shift;
	undef $self->{d};
	undef $self->{md5};
	undef $self->{size};
}

package OpenBSD::PackingElement::SpecialFile;
sub forget_details
{
	my $self = shift;
#	undef $self->{md5};
	undef $self->{size};
}

sub compare
{
	my ($self, $self2) = @@_;
	if (ref($self) ne ref($self2)) {
		return 1;
	}
	if ($self->{name} ne $self2->{name}) {
		return 1;
	}
	if (defined $self->{d} && defined $self2->{d}) {
		if (ref($self->{d}) ne ref($self2->{d})) {
			return 1;
		}
		if ($self->{d}->equals($self2->{d})) {
			return 0;
		} else {
			return 1;
		}
	} elsif (!defined $self->{d} && !defined $self2->{d}) {
		return 0;
	}
	return 2;
}

package OpenBSD::PackingElement::Depend;

sub record_generic_depends
{
	my ($self, $state) = @@_;
	$state->{stash}->{$self->forgetful_key} = $self;
}

sub find_mogrified
{
	my ($s1, $state) = @@_;
	my $s2 = $state->{stash}->{$s1->forgetful_key};
	if (defined $s2 && $s1->compare($s2) == 2) {
		$state->{mogrified}{$s1} = $s2;
	}
}

package OpenBSD::PackingElement::Dependency;
sub compare
{
	my ($self, $self2) = @@_;
	if (ref($self) ne ref($self2)) {
		return 1;
	}
	if ($self->{def} eq 'def' && $self2->{def} eq 'def') {
		return 0;
	}
	if ($self2->{def} eq 'def' && $self->{def} ne 'def') {
		return 2;
	}
	my $c = OpenBSD::PackageName->from_string($self->{def})->compare(
	    OpenBSD::PackageName->from_string($self2->{def}));
	if (!defined $c || $c < 0) {
		return 1;
	}
	if ($c == 0) {
		return 0;
	}
	return 2;
}

sub forgetful_key
{
	my $self = shift;
	return join(':', 'depend', $self->{name}, $self->{pkgpath}, $self->{pattern});
}

package OpenBSD::PackingElement::Wantlib;

sub compare
{
	my ($self, $self2) = @@_;
	if (ref($self) ne ref($self2)) {
		return 1;
	}
	my $c = $self->spec->compare($self2->spec);
	if (!defined $c || $c < 0) {
		return 1;
	}
	if ($c == 0) {
		return 0;
	}
	return 2;
}

sub forgetful_key
{
	my $self = shift;
	return $self->spec->key;
}

package OpenBSD::PackingElement::Comment;

sub forget_details
{
	my $self = shift;

	if ($self->{name} =~ m/^VARS:/) {
		$self->{name} = 'VARS';
	}
}

package OpenBSD::PackingElement::CVSTag;

# XXX needed to avoid CVS expansion

our $openbsd = 'OpenBSD';

sub forget_details
{
	my $self = shift;
	$self->{name} =~ s/^(\$$openbsd: .*,v).*/$1\$/;
}

sub compare
{
	my ($self, $self2) = @@_;
	if (ref($self) ne ref($self2)) {
		return 1;
	}
	if ($self->{name} eq $self2->{name}) {
		return 0;
	}
	if ($self->{name} eq "\$$openbsd\$" or 
	    $self2->{name} eq "\$$openbsd\$") {
		return 2;
	}
	return 1;
}

package OpenBSD::PackingElement::InfoFile;

sub remove_auxiliary
{
	my ($self, $list) = @@_;

	my $stem = $self->{name};
	my $i;
	for ($i = 1; @@$list > 0 && $list->[0]->{name} eq "$stem-$i"; $i++) {
		shift @@$list;
	}
	return $i;
}

package OpenBSD::PackingElement::Manpage;

sub remove_auxiliary
{
	my ($self, $list) = @@_;
	if ($self->is_source && @@$list > 0 && 
	    ref($list->[0]) eq ref($self) && 
	    $list->[0]->{name} eq $self->source_to_dest) {
		shift @@$list;
		return 1;
	}
	return 0;
}

sub compare
{
	my ($self, $self2) = @@_;

	# both elements must be manpages
	if (ref($self) ne ref($self2)) {
		return 1;
	}

	# identical
	if ($self->{name} eq $self2->{name}) {
		return 0;
	}

	# one is the conversion of the other
	if ($self->is_source && $self->source_to_dest eq $self2->{name}) {
		return 2;
	}
	if ($self2->is_source && $self2->source_to_dest eq $self->{name}) {
		return 2;
	}

	# or they're different beasts.
	return 1;
}

package OpenBSD::PackingElement::ExtraInfo;

sub compare
{
	my ($self, $self2) = @@_;
	if (ref($self) ne ref($self2)) {
		return 1;
	}
	if ($self->{ftp} ne $self2->{ftp} or 
	    $self->{cdrom} ne $self2->{cdrom}) {
		return 1;
	}
	if ($self->{subdir} eq $self2->{subdir}) {
		return 0;
	}
	if ($self->{subdir} =~ m/^mystuff\// && $self2->{subdir} eq $') {
		return 2;
	}
	if ($self2->{subdir} =~ m/^mystuff\// && $self->{subdir} eq $') {
		return 2;
	}
	return 1;
}

package main;

sub my_compare
{
	my ($p, $p2, $state) = @@_;
	my $l = [];
	my $l2 = [];
	my $final = 0;
	$p->flatten($l);
	$p2->flatten($l2);
	while (my $e = shift @@$l) {
		my $e2 = shift @@$l2;
		return 1 unless defined $e2;
		my $r = $e->compare($e2);
		if ($r == 1) {
			return $r;
		}
		if ($r == 2) {
			push(@@{$state->{updates}}, [$e2, $e]);
			$state->{mogrified}{$e} = $e2;
			$final = 2;
		}
		# zap extra info-* files and man pages
		if ($e->remove_auxiliary($l) != $e2->remove_auxiliary($l2)) {
			$final = 2;
		}
	}
	if (@@$l2 > 0) {
		return 1;
	}
	return $final;
}

sub more_mogrified
{
	my ($p1, $p2, $state) = @@_;

	$p2->record_generic_depends($state);
	$p1->find_mogrified($state);
}

sub compare_lists
{
	my ($p1, $p2, $result, $state) = @@_;
	my $r = my_compare($p1, $p2, $state);
	if ($r == 1) {
		my $t = "$result-new";
		more_mogrified($p1, $p2, $state);
		$p1->write_mogrified($t, $state);
		$state->errsay("Error: change in plist between #1 and #2", $result, $t);
		$state->errsay("| If the old and new builds were done correctly");
		$state->errsay("| (fully up-to-date ports tree including relevant MODULES)");
		$state->errsay("| then someone probably forgot to bump a REVISION.");
		$state->errsay("| (see bsd.port.mk(5), PLIST_DB)");
		system {OpenBSD::Paths->diff} ('diff', '-u', $result, $t);
		return 1;
	}
	if ($r == 2) {
		$p1->tofile($result);
		$state->errsay("#1 was updated", $result);
		for my $i (@@{$state->{updates}}) {
			$state->errsay("#1 -> #2",
			    $i->[0]->stringize, 
			    $i->[1]->stringize);
		}
	}
	return 0;
}

my $state = OpenBSD::State->new('register-plist');
$state->handle_options('t', '[-t p1 p2] dir pkg ...');
if (@@ARGV < 2) {
	$state->usage;
}

if ($state->opt('t')) {
	if (@@ARGV != 2) {
		$state->usage("-t takes exactly two parameters");
	}
	my $plist = OpenBSD::PackingList->fromfile($ARGV[0]);
	my $result = $ARGV[1];
	my $plist2 = OpenBSD::PackingList->fromfile($result);
	$plist->forget_details;
	exit(compare_lists($plist, $plist2, $result, $state));
}

my @@dirs = split(/:/, shift);
if (!-d $dirs[0]) {
	$state->usage("not a directory: #1", $dirs[0]);
}

my $error =0;

for my $pkgfile (@@ARGV) {
	my $pkg = $state->repo->find($pkgfile);
	if (!$pkg) {
		$state->fatal("Bad package #1", $pkgfile);
	}

	my $plist = $pkg->plist;
	$pkg->close;
	$pkg->wipe_info;

	$plist->forget_details;
	for my $dir (@@dirs) {
		next unless -d $dir;
		my $result = $dir.'/'.$plist->pkgname;
		if (-f $result) {
			my $plist2 = OpenBSD::PackingList->fromfile($result);
			$error += compare_lists($plist, $plist2, $result,
			    $state);
			last;
		}
	}
	if (!$error) {
		my $result = $dirs[0].'/'.$plist->pkgname;
		if (!-f $result) {
			$plist->tofile($result);
		}
	}
}
exit($error != 0);
@


1.25
log
@much longer explanation of what is wrong now that it's on by default.
@
text
@d3 1
a3 1
# $OpenBSD: register-plist,v 1.24 2010/08/06 10:15:17 espie Exp $
d408 1
a408 1
		$state->errsay("| (fully uptodate ports tree including relevant MODULES)");
@


1.24
log
@in case plists differ, try a bit more to unify "noise".
unconfuse the chromium case naddy encountered...

(also a bit of refactor to simplify testing)
@
text
@d3 1
a3 1
# $OpenBSD: register-plist,v 1.23 2010/07/19 17:40:17 espie Exp $
d407 4
@


1.23
log
@do a bit more magic: in case of a fatal change, don't write the new
packing-list "as if", but transform back the non-fatal pieces into what
was in the old packing-list, in order to minimize noise in the diff.
@
text
@d3 1
a3 1
# $OpenBSD: register-plist,v 1.22 2010/07/14 09:58:48 espie Exp $
d28 1
d46 14
d104 8
d156 1
a156 1
			return 2;
d169 17
d210 6
d234 6
d390 32
d423 1
a423 1
$state->handle_options('', 'dir pkg ...');
d428 11
d453 2
a454 8
	undef $plist->{ OpenBSD::PackageInfo::COMMENT };
	undef $plist->{"digital-signature"};

	my $l = $plist->{items};
	if ($l->[@@$l-1]->isa('OpenBSD::PackingElement::Cwd') &&
		$l->[@@$l-1]->{name} eq '.') {
	    pop @@$l;
	}
a456 2
	$pkg->close;
	$pkg->wipe_info;
d462 3
a464 17
			my $r = my_compare($plist, $plist2 ,$state);
			if ($r == 1) {
				my $t = "$result-new";
				$plist->write_mogrified($t, $state);
				$state->errsay("Error: change in plist between #1 and #2", $result, $t);
				system {OpenBSD::Paths->diff} ('diff', '-u', $result, $t);
				$error++;
			}
			if ($r == 2) {
				$plist->tofile($result);
				$state->errsay("#1 was updated", $result);
				for my $i (@@{$state->{updates}}) {
					$state->errsay("#1 -> #2",
					    $i->[0]->stringize, 
					    $i->[1]->stringize);
				}
			}
@


1.22
log
@instead of forgetting @@depend and @@wantlib, force them to go upwards,
version-wise.

okay sthen@@
@
text
@d3 1
a3 1
# $OpenBSD: register-plist,v 1.21 2010/06/30 11:11:19 espie Exp $
d34 11
d47 10
d324 1
d378 1
a378 1
				$plist->tofile($t);
@


1.21
log
@convert to newer interface. MAKE SURE you have -current pkg_add to run register_plist !
@
text
@d3 1
a3 1
# $OpenBSD: register-plist,v 1.20 2010/06/11 11:20:48 espie Exp $
d126 1
a126 1
sub forget_details
d128 19
a146 2
	my $self = shift;
	$self->{def} = 'def';
d151 1
a151 1
sub forget_details
d153 12
a164 2
	my $self = shift;
	$self->{name} =~ s/\d+\.\d+$/0.0/;
d288 1
a288 1
	my ($p, $p2) = @@_;
d302 1
d353 1
a353 1
			my $r = my_compare($plist, $plist2);
d364 5
@


1.20
log
@run diff directly, as discussed with jasper et al
@
text
@d3 1
a3 1
# $OpenBSD: register-plist,v 1.19 2009/04/26 08:45:09 espie Exp $
d29 1
a29 1
use OpenBSD::PackageLocator;
d288 2
d291 1
a291 1
	die "usage issue";
d296 1
a296 1
	die "not a directory: ", $dirs[0];
d302 1
a302 1
	my $pkg = OpenBSD::PackageLocator->find($pkgfile);
d304 1
a304 1
		die "Bad package $pkgfile";
d329 1
a329 1
				print STDERR "Error: change in plist between $result and $t\n";
d335 1
a335 1
				print STDERR "$result was updated\n";
@


1.19
log
@flattening signatures mean they won't be compared, but they still end up
in the recorded plist, consuming space for nothing. So also remove them
from the plist.

while there, $o->method() becomes $o->method
@
text
@d3 1
a3 1
# $OpenBSD: register-plist,v 1.18 2008/10/06 09:37:02 espie Exp $
d32 1
d327 2
a328 2
				print STDERR "Error: change in plist\n";
				print STDERR "\tdiff -u $result $t\n";
@


1.18
log
@make register-plist aware of the new digest infrastructure.
make it not notice a switch from md5 to sha256.
@
text
@d3 1
a3 1
# $OpenBSD: register-plist,v 1.17 2008/04/12 13:09:58 espie Exp $
d304 1
a304 1
	my $plist = $pkg->plist();
d306 1
d314 3
a316 3
	$plist->forget_details();
	$pkg->close();
	$pkg->wipe_info();
d319 1
a319 1
		my $result = $dir.'/'.$plist->pkgname();
d337 1
a337 1
		my $result = $dirs[0].'/'.$plist->pkgname();
@


1.17
log
@ignore details of new @@comment VARS:, to be used for better make-plist.
@
text
@d3 1
a3 1
# $OpenBSD: register-plist,v 1.16 2007/06/16 12:14:53 espie Exp $
d87 1
d109 5
a113 2
	if (defined $self->{md5} && defined $self2->{md5}) {
		if ($self->{md5} eq $self2->{md5}) {
d118 1
a118 1
	} elsif (!defined $self->{md5} && !defined $self2->{md5}) {
@


1.16
log
@I still need to handle `ignore', not all packages have been updated.
@
text
@d3 1
a3 1
# $OpenBSD: register-plist,v 1.15 2007/06/02 12:23:28 espie Exp $
d133 11
@


1.15
log
@finish killing old stuff, you should have updated by now.
@
text
@d3 1
a3 1
# $OpenBSD: register-plist,v 1.14 2007/05/21 21:24:56 espie Exp $
d70 10
@


1.14
log
@zap debug line
@
text
@d3 1
a3 1
# $OpenBSD: register-plist,v 1.13 2007/05/20 17:27:51 espie Exp $
d172 1
a172 1
	if ($self->can("is_source") && $self->is_source && @@$list > 0 && 
a194 1
	return 1 if !$self->can("is_source");
@


1.13
log
@generalize info files to zap auxiliary junk. Allows for manpages to change
without obvious negative consequences.
@
text
@d3 1
a3 1
# $OpenBSD: register-plist,v 1.12 2007/05/13 08:03:47 espie Exp $
d65 5
@


1.12
log
@use new-style plist visitors.
@
text
@d3 1
a3 1
# $OpenBSD: register-plist,v 1.11 2006/10/19 00:15:46 bernd Exp $
d62 4
d148 55
d247 3
a249 13
		# zap info-* files from compared stuff.
		if ($e->isa("OpenBSD::PackingElement::InfoFile")) {
			my $stem = $e->{name};
			my ($i, $j);
			for ($i = 1; @@$l > 0 && $l->[0]->{name} eq "$stem-$i"; $i++) {
				shift @@$l;
			}
			for ($j = 1; @@$l2 > 0 && $l2->[0]->{name} eq "$stem-$j"; $j++) {
				shift @@$l2;
			}
			if ($i != $j) {
				$final = 2;
			}
@


1.11
log
@Teach register-plist how to deal with the case where the recorded
plist in PLIST_DB misses the last line.

found & debugged by sturm@@
ok sturm@@, espie@@
@
text
@d3 1
a3 1
# $OpenBSD: register-plist,v 1.10 2006/10/02 18:48:01 espie Exp $
d176 2
a177 2
	$p->visit('flatten', $l);
	$p2->visit('flatten', $l2);
d235 1
a235 1
	$plist->visit('forget_details');
@


1.10
log
@let register-plist show stuff in a format ready for copy-paste.
Suggestion from alek@@, took it one step further...
@
text
@d3 1
a3 1
# $OpenBSD: register-plist,v 1.9 2006/07/17 16:51:53 espie Exp $
d180 1
@


1.9
log
@guards preventing out-of-bound access
@
text
@d3 1
a3 1
# $OpenBSD: register-plist,v 1.8 2006/07/12 08:11:28 espie Exp $
d246 2
a247 1
				print STDERR "Error: $t and $result are different\n";
@


1.8
log
@tweak it a bit to ignore changes in number of generated info files.
@
text
@d3 1
a3 1
# $OpenBSD: register-plist,v 1.7 2006/02/09 12:03:55 espie Exp $
d191 1
a191 1
			for ($i = 1; $l->[0]->{name} eq "$stem-$i"; $i++) {
d194 1
a194 1
			for ($j = 1; $l2->[0]->{name} eq "$stem-$j"; $j++) {
@


1.7
log
@oops, avoid IO::Scalar, which is a local module.

perl 5.8.0 does scalars directly.
@
text
@d3 1
a3 1
# $OpenBSD: register-plist,v 1.6 2006/02/09 11:39:02 espie Exp $
d178 1
a178 4
	if (@@$l != @@$l2) {
		return 1;
	}
	for my $e (@@$l) {
d187 17
@


1.6
log
@deal transparently with changing CVS tags or mystuff addition/removal.
@
text
@d3 1
a3 1
# $OpenBSD: register-plist,v 1.5 2006/02/09 10:49:13 espie Exp $
a34 2
use IO::Scalar;

d49 2
a50 2
	my $fh = new IO::Scalar \$data;
	my $fh2 = new IO::Scalar \$data2;
@


1.5
log
@use a much smarter comparator: check each element independently.
This finally allows us to transparently update old registered plists
for new elements.

For instance, let's store md5 for constant elements, like DESC, DISPLAY, etc.
@
text
@d3 1
a3 1
# $OpenBSD: register-plist,v 1.4 2005/09/19 21:12:27 espie Exp $
d119 5
a126 1
	my $openbsd = 'OpenBSD';
d130 16
d147 2
a148 1
sub forget_details
d150 18
a167 2
	my $self = shift;
	$self->{subdir} =~ s/^mystuff\///;
@


1.4
log
@use new interface to PackageLocator
@
text
@d3 1
a3 1
# $OpenBSD: register-plist,v 1.3 2005/09/09 08:20:37 espie Exp $
a31 1
use File::Compare;
d35 2
d41 24
d78 1
a78 1
	undef $self->{md5};
d82 21
d135 24
d192 5
a196 5
			my $t = "$result-new";
			$plist->tofile($t);
			if (compare($t, $result) == 0) {
				unlink($t);
			} else {
d199 4
@


1.3
log
@kill mystuff
@
text
@d3 1
a3 1
# $OpenBSD: register-plist,v 1.2 2005/09/05 10:13:11 espie Exp $
a31 1
use File::Path;
d106 1
a106 2
	my $infodir = $pkg->info();
	my $plist = OpenBSD::PackingList->fromfile($infodir.CONTENTS);
d117 1
a117 1
	rmtree($infodir);
@


1.2
log
@protect against $OpenBSD$ expansion problems.
Allow the first argument to be a path:, so that we can archive
the packing-lists in a less haphazard way.
@
text
@d3 1
a3 1
# $OpenBSD: register-plist,v 1.1 2005/09/04 22:30:39 espie Exp $
d79 7
@


1.1
log
@new script, to register packing-list in a nice way.
@
text
@d3 1
a3 1
# $OpenBSD$
d77 2
a78 1
	$self->{name} =~ s/^(\$OpenBSD:\s\S+,v)\s+.*\$$/$1\$/;
d86 4
a89 3
my $dir = shift;
if (!-d $dir) {
	die "not a directory: $dir";
d113 18
a130 9
	my $result = $dir.'/'.$plist->pkgname();
	if (-f $result) {
		my $t = "$result-new";
		$plist->tofile($t);
		if (compare($t, $result) == 0) {
			unlink($t);
		} else {
			print STDERR "Error: $t and $result are different\n";
			$error++;
a131 2
	} else {
		$plist->tofile($result);
@

