head	1.29;
access;
symbols
	OPENBSD_6_0:1.29.0.10
	OPENBSD_6_0_BASE:1.29
	OPENBSD_5_9:1.29.0.6
	OPENBSD_5_9_BASE:1.29
	OPENBSD_5_8:1.29.0.8
	OPENBSD_5_8_BASE:1.29
	OPENBSD_5_7:1.29.0.4
	OPENBSD_5_7_BASE:1.29
	OPENBSD_5_6:1.29.0.2
	OPENBSD_5_6_BASE:1.29
	OPENBSD_5_5:1.28.0.16
	OPENBSD_5_5_BASE:1.28
	OPENBSD_5_4:1.28.0.14
	OPENBSD_5_4_BASE:1.28
	OPENBSD_5_3:1.28.0.12
	OPENBSD_5_3_BASE:1.28
	OPENBSD_5_2:1.28.0.10
	OPENBSD_5_2_BASE:1.28
	OPENBSD_5_1_BASE:1.28
	OPENBSD_5_1:1.28.0.8
	OPENBSD_5_0:1.28.0.6
	OPENBSD_5_0_BASE:1.28
	OPENBSD_4_9:1.28.0.4
	OPENBSD_4_9_BASE:1.28
	OPENBSD_4_8:1.28.0.2
	OPENBSD_4_8_BASE:1.28
	OPENBSD_4_7:1.17.0.2
	OPENBSD_4_7_BASE:1.17
	OPENBSD_4_6:1.16.0.6
	OPENBSD_4_6_BASE:1.16
	OPENBSD_4_5:1.16.0.4
	OPENBSD_4_5_BASE:1.16
	OPENBSD_4_4:1.16.0.2
	OPENBSD_4_4_BASE:1.16
	OPENBSD_4_3:1.15.0.2
	OPENBSD_4_3_BASE:1.15
	OPENBSD_4_2:1.12.0.2
	OPENBSD_4_2_BASE:1.12
	OPENBSD_4_1:1.4.0.10
	OPENBSD_4_1_BASE:1.4
	OPENBSD_4_0:1.4.0.8
	OPENBSD_4_0_BASE:1.4
	OPENBSD_3_9:1.4.0.6
	OPENBSD_3_9_BASE:1.4
	OPENBSD_3_8:1.4.0.4
	OPENBSD_3_8_BASE:1.4
	OPENBSD_3_7:1.4.0.2
	OPENBSD_3_7_BASE:1.4;
locks; strict;
comment	@# @;


1.29
date	2014.03.24.15.18.17;	author afresh1;	state Exp;
branches;
next	1.28;

1.28
date	2010.07.12.20.19.40;	author espie;	state Exp;
branches;
next	1.27;

1.27
date	2010.06.30.11.11.19;	author espie;	state Exp;
branches;
next	1.26;

1.26
date	2010.06.26.10.24.34;	author espie;	state Exp;
branches;
next	1.25;

1.25
date	2010.06.23.15.02.45;	author espie;	state Exp;
branches;
next	1.24;

1.24
date	2010.06.14.12.29.39;	author espie;	state Exp;
branches;
next	1.23;

1.23
date	2010.06.14.11.36.40;	author espie;	state Exp;
branches;
next	1.22;

1.22
date	2010.06.13.22.02.43;	author espie;	state Exp;
branches;
next	1.21;

1.21
date	2010.06.11.23.49.22;	author espie;	state Exp;
branches;
next	1.20;

1.20
date	2010.06.11.11.20.27;	author espie;	state Exp;
branches;
next	1.19;

1.19
date	2010.06.11.10.09.37;	author espie;	state Exp;
branches;
next	1.18;

1.18
date	2010.03.20.17.05.44;	author espie;	state Exp;
branches;
next	1.17;

1.17
date	2010.01.26.21.22.57;	author espie;	state Exp;
branches;
next	1.16;

1.16
date	2008.04.22.21.36.06;	author espie;	state Exp;
branches;
next	1.15;

1.15
date	2008.02.20.07.04.25;	author espie;	state Exp;
branches;
next	1.14;

1.14
date	2008.02.19.11.02.53;	author espie;	state Exp;
branches;
next	1.13;

1.13
date	2007.10.27.22.15.28;	author espie;	state Exp;
branches;
next	1.12;

1.12
date	2007.06.16.20.15.33;	author espie;	state Exp;
branches;
next	1.11;

1.11
date	2007.06.03.11.57.36;	author espie;	state Exp;
branches;
next	1.10;

1.10
date	2007.06.03.11.01.10;	author espie;	state Exp;
branches;
next	1.9;

1.9
date	2007.06.03.10.32.23;	author espie;	state Exp;
branches;
next	1.8;

1.8
date	2007.06.03.09.21.50;	author espie;	state Exp;
branches;
next	1.7;

1.7
date	2007.05.23.10.34.15;	author espie;	state Exp;
branches;
next	1.6;

1.6
date	2007.05.22.10.39.05;	author espie;	state Exp;
branches;
next	1.5;

1.5
date	2007.05.13.08.03.47;	author espie;	state Exp;
branches;
next	1.4;

1.4
date	2004.11.13.11.49.48;	author espie;	state Exp;
branches;
next	1.3;

1.3
date	2004.11.11.15.38.02;	author espie;	state Exp;
branches;
next	1.2;

1.2
date	2004.09.14.22.30.36;	author espie;	state Exp;
branches;
next	1.1;

1.1
date	2004.09.14.22.22.17;	author espie;	state Exp;
branches;
next	;


desc
@@


1.29
log
@Lexical $_ fixes in package tools

okay espie@@
@
text
@#!/usr/bin/perl

# $OpenBSD: check-lib-depends,v 1.28 2010/07/12 20:19:40 espie Exp $
# Copyright (c) 2004-2010 Marc Espie <espie@@openbsd.org>
#
# Permission to use, copy, modify, and distribute this software for any
# purpose with or without fee is hereby granted, provided that the above
# copyright notice and this permission notice appear in all copies.
#
# THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
# ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
# OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

use strict;
use warnings;

use File::Spec;
use OpenBSD::PackingList;
use OpenBSD::SharedLibs;
use OpenBSD::LibSpec;
use OpenBSD::Temp;
use OpenBSD::AddCreateDelete;
use OpenBSD::Getopt;

# FileSource: where we get the files to analyze
package FileSource;

# file system
package FsFileSource;
our @@ISA = qw(FileSource);
sub new
{
	my ($class, $location) = @@_;
	bless {location => $location }, $class
}

sub retrieve
{
	my ($self, $state, $item) = @@_;
	return $self->{location}.$item->fullname;
}

sub skip
{
}

sub clean
{
}

# package archive
package PkgFileSource;
our @@ISA = qw(FileSource);
sub new
{
	my ($class, $handle, $location) = @@_;
	bless {handle => $handle, location => $location }, $class;
}

sub prepare_to_extract
{
	my ($self, $item) = @@_;
	require OpenBSD::ArcCheck;
	my $o = $self->{handle}->next;
	$o->{cwd} = $item->cwd;
	if (!$o->check_name($item)) {
		die "Error checking name for $o->{name} vs. $item->{name}\n";
	}
	$o->{name} = $item->fullname;
	$o->{destdir} = $self->{location};
	return $o;
}

sub extracted_name
{
	my ($self, $item) = @@_;
	return $self->{location}.$item->fullname;
}

sub retrieve
{
	my ($self, $state, $item) = @@_;
	my $o = $self->prepare_to_extract($item);
	$o->create;
	return $self->extracted_name($item);
}

sub skip
{
	my ($self, $item) = @@_;
	my $o = $self->prepare_to_extract($item);
	$self->{handle}->skip;
}

sub clean
{
	my ($self, $item) = @@_;
	unlink($self->extracted_name($item));
}

# Recorder: how we keep track of which binary uses which library
package Recorder;
sub new
{
	my $class = shift;
	return bless {}, $class;
}

sub reduce_libname
{
	my ($self, $lib) = @@_;
	$lib =~ s/^(.*\/)?lib(.*)\.so\.(\d+)\.\d+$/$2.$3/;
	return $lib;
}

sub libs
{
	my $self = shift;
	return keys %$self;
}

sub record_rpath
{
}

# SimpleRecorder: remember one single binary for each library
package SimpleRecorder;
our @@ISA = qw(Recorder);
sub record
{
	my ($self, $lib, $filename) = @@_;
	$self->{$self->reduce_libname($lib)} = $filename;
}

sub binary
{
	my ($self, $lib) = @@_;
	return $self->{$lib};
}

# AllRecorder: remember all binaries for each library
package AllRecorder;
our @@ISA = qw(Recorder);
sub record
{
	my ($self, $lib, $filename) = @@_;
	push(@@{$self->{$self->reduce_libname($lib)}}, $filename);
}

sub binaries
{
	my ($self, $lib) = @@_;
	return @@{$self->{$lib}};
}
sub binary
{
	my ($self, $lib) = @@_;
	return $self->{$lib}->[0];
}

sub dump
{
	my ($self, $fh) = @@_;
	for my $lib (sort $self->libs) {
		print $fh "$lib:\t\n";
		for my $binary (sort $self->binaries($lib)) {
			print $fh "\t$binary\n";
		}
	}
}

package DumpRecorder;
our @@ISA = qw(Recorder);
sub record
{
	my ($self, $lib, $filename) = @@_;
	push(@@{$self->{$filename}->{libs}}, $lib);
}

sub record_rpath
{
	my ($self, $path, $filename) = @@_;
	push(@@{$self->{$filename}->{rpath}}, $path);
}

sub dump
{
	my ($self, $fh) = @@_;
	while (my ($binary, $v) = each %$self) {
		print $fh $binary;
		if (defined $v->{rpath}) {
			print $fh "(", join(':', @@{$v->{rpath}}), ")";
		}
		print $fh ": ", join(',', @@{$v->{libs}}), "\n";
	}
}

sub retrieve
{
	my ($self, $state, $filename) = @@_;
	open(my $fh, '<', $filename) or 
	    $state->fatal("Can't read #1: #2", $filename, $!);
	while (my $line = <$fh>) {
		chomp $line;
		if ($line =~ m/^(.*?)\:\s(.*)$/) {
			my ($binary, $libs) = ($1, $2);
			if ($binary =~ m/^(.*)\(.*\)$/) {
				$binary = $1;
			}
			my @@libs = split(/,/, $libs);
			$self->{$binary}= \@@libs;
		} else {
			$state->errsay("Can't parse #1", $line);
		}
	}
	close $fh;
}

# Issue: intermediate objects that record problems with libraries
package Issue;
sub new
{
	my ($class, $lib, $binary, @@packages) = @@_;
	bless { lib => $lib, binary => $binary, packages => \@@packages }, 
		$class;
}

sub stringize
{
	my $self = shift;
	my $string = $self->{lib};
	if (@@{$self->{packages}} > 0) {
		$string.=" from ".join(',', @@{$self->{packages}});
	}
	return $string." ($self->{binary})";
}

sub do_record_wantlib
{
	my ($self, $h) = @@_;
	my $want = $self->{lib};
	$want =~ s/\.\d+$//;
	$h->{$want} = 1;
}

sub record_wantlib
{
}

sub not_reachable
{
	return 0;
}

sub print
{
	my $self = shift;
	print $self->message, "\n";
}
package Issue::SystemLib;
our @@ISA = qw(Issue);

sub message
{
	my $self = shift;
	return "WANTLIB:       ". $self->stringize. " (system lib)";
}

sub record_wantlib
{
	&Issue::do_record_wantlib;
}
package Issue::DirectDependency;
our @@ISA = qw(Issue);
sub message
{
	my $self = shift;
	return "LIB_DEPENDS:   ". $self->stringize;
}

package Issue::IndirectDependency;
our @@ISA = qw(Issue);
sub message
{
	my $self = shift;
	return "WANTLIB:       ". $self->stringize;
}

sub record_wantlib
{
	&Issue::do_record_wantlib;
}

package Issue::NotReachable;
our @@ISA = qw(Issue);
sub message
{
	my $self = shift;
	return "Missing lib:   ". $self->stringize. " (NOT REACHABLE)";
}

sub not_reachable
{
	my $self = shift;
	return "Bogus WANTLIB: ". $self->stringize. " (NOT REACHABLE)";
}

package MyFile;
our @@ISA = qw(OpenBSD::PackingElement::FileBase);

sub fullname
{
	my $self = shift;
	return $self->{name};
}

package OpenBSD::PackingElement;
sub record_needed_libs
{
}

sub find_libs
{
}

sub register_libs
{
}

sub depwalk
{
}

package OpenBSD::PackingElement::Wantlib;
sub register_libs
{
	my ($item, $t) = @@_;
	my $name = $item->{name};
	$name =~ s/^(.*\/)?(.*)\.(\d+)\.\d+$/$2.$3/;
	$t->{$name} = 1;
}

package OpenBSD::PackingElement::Lib;

sub register_libs
{
	my ($item, $t) = @@_;
	if ($item->fullname =~ m/^(.*\/)?lib(.*)\.so\.(\d+)\.\d+$/) {
		$t->{"$2.$3"} = 2;
	}
}

package OpenBSD::PackingElement::FileBase;
sub find_libs
{
	my ($item, $dest, $special) = @@_;
	my $fullname = $item->fullname;
	if (defined $special->{$fullname}) {
		for my $lib (@@{$special->{$fullname}}) {
			$dest->record($lib, $fullname);
		}
	}
}

sub run_objdump
{
	my ($state, $n) = @@_;
	my $cmd;

	if ($state->{old}) {
		open($cmd, "-|", "ldd", "-f", "NEEDED lib%o.so.%m.%n\n", $n) or 
		    $state->fatal("run ldd: #1", $!);
	} else {
		unless (open($cmd, '-|')) {
			open(STDERR, '>', '/dev/null');
			exec('objdump', '-p', $n) or 
			    $state->fatal("exec objdump: #!", $!);
		}
	}
	return $cmd;
}

sub parse_objdump
{
	my ($cmd, $dest, $fullname) = @@_;
	my @@l = ();
	while (my $line = <$cmd>) {
		if ($line =~ m/^\s+NEEDED\s+(.*?)\s*$/) {
			my $lib = $1;
			push(@@l, $lib);
			# detect linux binaries
			if ($lib eq 'libc.so.6') {
				return ();
			}
		} elsif ($line =~ m/^\s+RPATH\s+(.*)\s*$/) {
			my $p = {};
			for my $path (split /\:/, $1) {
				next if $path eq '/usr/local/lib';
				next if $path eq '/usr/X11R6/lib';
				next if $path eq '/usr/lib';
				$p->{$path} = 1;
			}
			for my $path (keys %$p) {
				$dest->record_rpath($path, $fullname);
			}
		}
	}
	return @@l;
}

sub record_needed_libs
{
	my ($item, $state, $dest, $source) = @@_;
	my $fullname = File::Spec->canonpath($item->fullname);

	my $linux_bin = 0;
	my $freebsd_bin = 0;
	if ($fullname =~ m,^/usr/local/emul/(?:redhat|fedora)/,) {
		$linux_bin = 1;
	}
	if ($fullname =~ m,^/usr/local/emul/freebsd/,) {
		$freebsd_bin = 1;
	}
	if ($linux_bin || $freebsd_bin || $item->{symlink} || $item->{link}) {
		$source->skip($item);
		return;
	}
	my $n = $source->retrieve($state, $item);
	my $cmd = run_objdump($state, $n);
	for my $lib (parse_objdump($cmd, $dest, $fullname)) {
		# don't look for modules
		next if $lib =~ m/\.so$/;
		$dest->record($lib, $fullname);
	}
	close($cmd);
	$source->clean($item);
}

package OpenBSD::PackingElement::Dependency;

sub depwalk
{
	my ($self, $h) = @@_;
	$h->{$self->{def}} = $self->{pkgpath};
}

package CheckLibDepends::State;
our @@ISA = qw(OpenBSD::AddCreateDelete::State);

sub handle_options
{
	my $state = shift;

	$state->SUPER::handle_options('od:fB:F:s:O:',
		'[-o] [-d pkgrepo] [-B destdir] [-s source] [-O dest]');

	$state->{destdir} = $state->opt('B') // $state->opt('F');
	$state->{destdir} //= '/';
	$state->{destdir}.= '/' unless $state->{destdir} =~ m|/$|;
	$state->{dest} = $state->opt('O');
	$state->{source} = $state->opt('s');
	$state->{full} = $state->opt('f');
	$state->{repository} = $state->opt('d');
	$state->{old} = $state->opt('o');
}

sub init
{
	my $self = shift;
	$self->{errors} = 0;
	$self->SUPER::init(@@_);
}

sub context
{
	my ($self, $pkgname) = @@_;
	$self->{context} = $pkgname;
}

sub error
{
	my $state = shift;
	$state->{errors}++;
	$state->say_with_context(@@_);
}

sub say_with_context
{
	my $state = shift;
	if ($state->{context}) {
		$state->say("#1:", $state->{context});
		undef $state->{context};
	}
	$state->say(@@_);
}

package CheckLibDepends;

use OpenBSD::PackageInfo;
use File::Path;
use File::Find;

my $dependencies = {};

sub register_dependencies
{
	my $plist = shift;
	my $pkgname = $plist->pkgname;
	my $h = {};
	$dependencies->{$pkgname} = $h;
	$plist->depwalk($h);
}

sub get_plist
{
	my ($self, $state, $pkgname, $pkgpath) = @@_;

	# try physical package
	if (defined $state->{repository}) {
		my $location = "$state->{repository}/$pkgname.tgz";

		my $true_package = $state->repo->find($location);
		if ($true_package) {
			my $dir = $true_package->info;
			if (-d $dir) {
				my $plist = OpenBSD::PackingList->fromfile($dir.CONTENTS);
				$true_package->close;
				rmtree($dir);
				return $plist;
			}
		}
	}
	# ask the ports tree
	$state->say("Asking ports for dependency #1(#2)", $pkgname, $pkgpath);
	my $portsdir = $ENV{PORTSDIR} || "/usr/ports";
	my $make = $ENV{MAKE} || "make";
	open my $fh, "cd $portsdir && env -i SUBDIR=$pkgpath ECHO_MSG=: make print-plist-with-depends |" or return undef;
	my $plist = OpenBSD::PackingList->read($fh);
	close $fh;
	return $plist;
}

sub handle_dependency
{
	my ($self, $state, $pkgname, $pkgpath) = @@_;
	my $plist = $self->get_plist($state, $pkgname, $pkgpath);

	if (!defined $plist || !defined $plist->pkgname) {
		$state->errsay("Error: can't solve dependency for #1(#2)",
		    $pkgname, $pkgpath);
		return;
	}

	if ($plist->pkgname ne $pkgname) {
		delete $dependencies->{$pkgname};
		for my $p (keys %$dependencies) {
			if ($dependencies->{$p}->{$pkgname}) {
				$dependencies->{$p}->{$plist->pkgname} =
				    $dependencies->{$p}->{$pkgname};
				delete $dependencies->{$p}->{$pkgname};
			}
		}
	}

	register_dependencies($plist);
	OpenBSD::SharedLibs::add_libs_from_plist($plist);

	return $plist->pkgname;
}

sub lookup_library
{
	my ($dir, $spec) = @@_;
	my $libspec = OpenBSD::LibSpec->from_string($spec);
	my $r = OpenBSD::SharedLibs::lookup_libspec($dir, $libspec);
	if (!defined $r) {
		return ();
	} else {
		return map {$_->origin} @@$r;
	}
}

sub report_lib_issue
{
	my ($self, $state, $plist, $lib, $binary) = @@_;

	OpenBSD::SharedLibs::add_libs_from_system('/');
	my $libspec = "$lib.0";
	my $want = $lib;
	$want =~ s/\.\d+$//;
	for my $dir (qw(/usr /usr/X11R6)) {
		my @@r = lookup_library($dir, $libspec);
		if (grep { $_ eq 'system' } @@r) {
			return Issue::SystemLib->new($lib, $binary);
		}
	}

	while (my ($p, $pkgpath) = each %{$dependencies->{$plist->pkgname}}) {
		next if defined $dependencies->{$p};
		$self->handle_dependency($state, $p, $pkgpath);
	}

	my @@r = lookup_library('/usr/local', $libspec);
	if (@@r > 0) {
		for my $p (@@r) {
			if (defined $dependencies->{$plist->pkgname}->{$p}) {
				return Issue::DirectDependency->new($lib, $binary, $p);
			}
		}
	}
	# okay, let's walk for WANTLIB
	my @@todo = %{$dependencies->{$plist->pkgname}};
	my $done = {};
	while (@@todo >= 2) {
		my $path = pop @@todo;
		my $dep = pop @@todo;
		next if $done->{$dep};
		$done->{$dep} = 1;
		$dep = $self->handle_dependency($state, $dep, $path)
		    	unless defined $dependencies->{$dep};
		next if !defined $dep;
		$done->{$dep} = 1;
		push(@@todo, %{$dependencies->{$dep}});
	}
	@@r = lookup_library(OpenBSD::Paths->localbase, $libspec);
	for my $p (@@r) {
		if (defined $done->{$p}) {
			return Issue::IndirectDependency->new($lib, $binary, $p);
		}
	}
	return Issue::NotReachable->new($lib,, $binary, @@r);
}

sub print_list
{
	my ($self, $state, $head, $h) = @@_;

	my $line = "";
	for my $k (sort keys %$h) {
		if (length $line > 50) {
			$state->say_with_context("#1#2", $head, $line);
			$line = "";
		}
		$line .= ' '.$k;
	}
	if ($line ne '') {
		$state->say_with_context("#1#2", $head, $line);
	}
}

sub analyze 
{
	my ($self, $state, $plist, $source) = @@_;

	my $pkgname = $plist->pkgname;
	if ($plist->fullpkgpath) {
		$state->context($pkgname."(".$plist->fullpkgpath.")");
	} else {
		$state->context($pkgname);
	}
	my $needed_libs = $state->{full} ? AllRecorder->new : SimpleRecorder->new;
	my $has_libs = {};
	if ($state->{source}) {
		my $special = DumpRecorder->new;
		$special->retrieve($state, $state->{source});
		$plist->find_libs($needed_libs, $special);
	} else {
		$plist->record_needed_libs($state, $needed_libs, $source);
	}
	$plist->register_libs($has_libs);

	if (!defined $dependencies->{$pkgname}) {
		register_dependencies($plist);
		OpenBSD::SharedLibs::add_libs_from_plist($plist);
	}
	my $r = { wantlib => {}, libdepends => {}, wantlib2 => {} };
	for my $lib (sort $needed_libs->libs) {
		my $fullname = $needed_libs->binary($lib);
		if (!defined $has_libs->{$lib}) {
			my $issue = $self->report_lib_issue($state, $plist, 
			    $lib, $fullname);
			$state->error("#1", $issue->message);
			$issue->record_wantlib($r->{wantlib});
		} elsif ($has_libs->{$lib} == 1) {
			my $issue = $self->report_lib_issue($state, $plist, 
			    $lib, $fullname);
			if ($issue->not_reachable) {
				$state->error("#1", $issue->not_reachable);
			}
		}
		$has_libs->{$lib} = 2;
	}
	my $extra = {};
	for my $k (keys %$has_libs) {
		my $v = $has_libs->{$k};
		next if $v == 2;
		$extra->{$k} = 1;
	}
	$self->print_list($state, "Extra: ", $extra);
	$self->print_list($state, "\tWANTLIB +=", $r->{wantlib});
	if ($state->{full}) {
		$needed_libs->dump(\*STDOUT);
	}
}

sub do_pkg
{
	my ($self, $state, $pkgname) = @@_;

	my $true_package = $state->repo->find($pkgname);
	return 0 unless $true_package;
	my $dir = $true_package->info;
	# twice read
	return 0 unless -d $dir;
	my $plist = OpenBSD::PackingList->fromfile($dir.CONTENTS);
	if ($state->{source}) {
		$self->analyze($state, $plist);
	} elsif ($state->{destdir} ne '/') {
		$self->analyze($state, $plist, 
		    FsFileSource->new($state->{destdir}));
	} else {
		my $temp = OpenBSD::Temp->dir;
		$self->analyze($state, $plist,
		    PkgFileSource->new($true_package, $temp));
		rmtree($temp);
	}
	$true_package->close;
	$true_package->wipe_info;
	$plist->forget;
	return 1;
}

sub do_plist
{
	my ($self, $state) = @@_;

	my $plist = OpenBSD::PackingList->read(\*STDIN);
	if (!defined $plist->{name}) {
		$state->error("Error reading plist");
		return;
	} else {
		$self->analyze($state, $plist, 
		    FsFileSource->new($state->{destdir}));
	}
}

sub main
{
	my $self = shift;
	my $state = CheckLibDepends::State->new('check-lib-depends');
	$state->handle_options;
	my $fs = $state->{destdir};
	if ($state->{dest}) {
		my $recorder = DumpRecorder->new;
		my $cwd = $fs;
		my $source = FsFileSource->new($fs);
		find({
			wanted => sub {
			    return if -l $_;
			    return unless -f _;
			    my $name = $_;
			    $name =~ s/^\Q$fs\E/\//;
			    # XXX hack FileBase object;
			    my $i = bless {name => $name}, "MyFile";
			    $i->record_needed_libs($state, $recorder, $source);
			},
			no_chdir => 1 }, $fs);
		if ($state->{dest}) {
			open my $fh, '>', $state->{dest} or 
			    $state->fatal("Can't write to #1: #2", 
				$state->{dest}, $!);
			$recorder->dump($fh);
			close $fh;
		} else {
			$recorder->dump(\*STDOUT);
		}
		exit(0);
	}

	if (@@ARGV == 0 && ($state->{destdir} ne '/' || $state->{source})) {
		$self->do_plist($state);
	} else {
		$state->progress->for_list("Scanning", \@@ARGV,
		    sub {
			$self->do_pkg($state, shift);
		    });
	}

	exit($state->{errors} ? 1 : 0);
}

$OpenBSD::Temp::tempbase = "/tmp";
__PACKAGE__->main;
@


1.28
log
@remove outdated comment
use progress->for_list
@
text
@d3 1
a3 1
# $OpenBSD: check-lib-depends,v 1.27 2010/06/30 11:11:19 espie Exp $
d207 3
a209 4
	my $_;
	while (<$fh>) {
		chomp;
		if (m/^(.*?)\:\s(.*)$/) {
d217 1
a217 1
			$state->errsay("Can't parse #1", $_);
@


1.27
log
@convert to newer interface. MAKE SURE you have -current pkg_add to run register_plist !
@
text
@d3 1
a3 1
# $OpenBSD: check-lib-depends,v 1.26 2010/06/26 10:24:34 espie Exp $
a17 2
# check all packages in the current directory, and report library issues

d83 1
d788 4
a791 6
		my $i = 0;
		$state->progress->set_header("Scanning");
		for my $pkgname (@@ARGV) {
			$state->progress->show(++$i, scalar @@ARGV);
			$self->do_pkg($state, $pkgname);
		}
@


1.26
log
@clean-up by using new State methods.
also cut up the objdump handling into shorter segments
@
text
@d3 1
a3 1
# $OpenBSD: check-lib-depends,v 1.25 2010/06/23 15:02:45 espie Exp $
a23 1
use OpenBSD::PackageLocator;
d528 1
a528 1
		my $true_package = OpenBSD::PackageLocator->find($location);
d716 1
a716 1
	my $true_package = OpenBSD::PackageLocator->find($pkgname);
@


1.25
log
@more compact Extra:
@
text
@d3 2
a4 2
# $OpenBSD: check-lib-depends,v 1.24 2010/06/14 12:29:39 espie Exp $
# Copyright (c) 2004 Marc Espie <espie@@openbsd.org>
d46 1
a46 1
	my ($self, $item) = @@_;
d88 1
a88 1
	my ($self, $item) = @@_;
d206 3
a208 2
	my ($self, $filename) = @@_;
	open(my $fh, '<', $filename) or die "Can't read $filename: $!";
d220 1
a220 1
			print "Can't parse $_\n";
d372 1
a372 1
sub record_needed_libs
d374 2
a375 2
	my ($item, $state, $dest, $source) = @@_;
	my $fullname = File::Spec->canonpath($item->fullname);
a376 14
	my $linux_bin = 0;
	my $freebsd_bin = 0;
	if ($fullname =~ m,^/usr/local/emul/(?:redhat|fedora)/,) {
		$linux_bin = 1;
	}
	if ($fullname =~ m,^/usr/local/emul/freebsd/,) {
		$freebsd_bin = 1;
	}
	if ($linux_bin || $freebsd_bin || $item->{symlink} || $item->{link}) {
		$source->skip($item);
		return;
	}
	my $n = $source->retrieve($item);
	my $cmd;
d384 1
a384 1
			    state->fatal("exec objdump: #!", $!);
d387 8
a394 2
	my @@l;
	while(my $line = <$cmd>) {
d400 1
a400 1
				$linux_bin = 1;
d415 27
a442 8
	# okay, we are not OpenBSD, we don't have sensible names
	unless ($linux_bin or $freebsd_bin) {
		for my $lib (@@l) {
			# don't look for modules
			next if $lib =~ m/\.so$/;
			$dest->record($lib, $fullname);
		}
	}
d457 17
a504 1
our @@ISA = qw(OpenBSD::AddCreateDelete);
d672 1
a672 1
		$special->retrieve($state->{source});
d758 1
a758 11
	$self->handle_options('od:fB:F:s:O:', $state,
		'[-o] [-d pkgrepo] [-B destdir] [-s source] [-O dest]');

	$state->{destdir} = $state->opt('B') // $state->opt('F');
	$state->{destdir} //= '/';
	$state->{destdir}.= '/' unless $state->{destdir} =~ m|/$|;
	$state->{dest} = $state->opt('O');
	$state->{source} = $state->opt('s');
	$state->{full} = $state->opt('f');
	$state->{repository} = $state->opt('d');
	$state->{old} = $state->opt('o');
@


1.24
log
@display fullpkgpath if we know it.
@
text
@d3 1
a3 1
# $OpenBSD: check-lib-depends,v 1.23 2010/06/14 11:36:40 espie Exp $
d672 2
a673 1
	for my $k (sort keys %$has_libs) {
d676 1
a676 1
		$state->say_with_context("Extra:         #1", $k);
d678 1
d760 1
a760 1
			    $state->{dest}, $!);
@


1.23
log
@simplify option handling for src/dest.
- if a src file is given, we don't need -B.
- use -B for base directories, select to save libraries based on -O.
@
text
@d3 1
a3 1
# $OpenBSD: check-lib-depends,v 1.22 2010/06/13 22:02:43 espie Exp $
d528 1
a528 1
		$state->errsay("Error: can't solve dependency for #1/#2",
d635 5
a639 1
	$state->context($pkgname);
@


1.22
log
@oopsie, as noticed by landry
@
text
@d3 1
a3 1
# $OpenBSD: check-lib-depends,v 1.21 2010/06/11 23:49:22 espie Exp $
d37 1
a37 1
our @@ISA=(qw(FileSource));
d60 1
a60 1
our @@ISA=(qw(FileSource));
d134 1
a134 1
our @@ISA=(qw(Recorder));
d149 1
a149 1
our @@ISA=(qw(Recorder));
d179 1
a179 1
our @@ISA=(qw(Recorder));
d267 1
a267 1
our @@ISA=(qw(Issue));
d280 1
a280 1
our @@ISA=(qw(Issue));
d288 1
a288 1
our @@ISA=(qw(Issue));
d301 1
a301 1
our @@ISA=(qw(Issue));
d315 1
a315 1
our @@ISA=(qw(OpenBSD::PackingElement::FileBase));
d632 1
a632 1
	my ($self, $state, $plist, $source, @@l) = @@_;
d643 1
a643 1
		$plist->record_needed_libs($state, $needed_libs, $source, @@l);
d689 3
a691 1
	if ($state->{builddir}) {
d693 1
a693 1
		    FsFileSource->new($state->{builddir}));
d713 1
a714 1
		my $pkgname = $plist->pkgname;
d716 1
a716 1
		    FsFileSource->new($state->{builddir}));
d725 1
a725 1
		'[-o] [-d pkgrepo] [-F fs] [-s source] [-O dest]');
d727 3
a729 2
	my $fs = $state->opt('F');
	$state->{builddir} = $state->opt('B');
d735 2
a736 1
	if ($fs) {
d745 1
a745 1
			    $name =~ s/^\Q$fs\E//;
d762 2
a763 1
	if (@@ARGV == 0 && $state->{builddir}) {
@


1.21
log
@Naming classes the same as functions can yield surprising results,
as noticed by Daniel Dickman
@
text
@d3 1
a3 1
# $OpenBSD: check-lib-depends,v 1.20 2010/06/11 11:20:27 espie Exp $
d663 1
a663 1
				$issue->error("#1", $issue->not_reachable);
@


1.20
log
@reuse new code from base
@
text
@d3 1
a3 1
# $OpenBSD: check-lib-depends,v 1.19 2010/06/11 10:09:37 espie Exp $
d266 1
a266 1
package Issue::system_lib;
d279 1
a279 1
package Issue::direct_dependency;
d287 1
a287 1
package Issue::indirect_dependency;
d300 1
a300 1
package Issue::not_reachable;
d573 1
a573 1
			return Issue::system_lib->new($lib, $binary);
d586 1
a586 1
				return Issue::direct_dependency->new($lib, $binary, $p);
d607 1
a607 1
			return Issue::indirect_dependency->new($lib, $binary, $p);
d610 1
a610 1
	return Issue::not_reachable->new($lib,, $binary, @@r);
@


1.19
log
@rename for clarity
@
text
@d3 1
a3 1
# $OpenBSD: check-lib-depends,v 1.18 2010/03/20 17:05:44 espie Exp $
a22 1
use File::Find;
a23 2
use File::Path;
use File::Basename;
a24 1
use OpenBSD::PackageInfo;
d28 3
a30 6
use File::Temp;
use Getopt::Std;

our ($opt_o, $opt_d, $opt_f, $opt_F, $opt_B, $opt_s, $opt_O);
my $errors = 0;

d208 1
a208 1
	local $_;
d256 1
a256 1
sub print_error_not_reachable
d261 5
d268 2
a269 1
sub print
d272 1
a272 1
	print "WANTLIB:       ", $self->stringize, " (system lib)\n";
d281 1
a281 1
sub print
d284 1
a284 1
	print "LIB_DEPENDS:   ", $self->stringize, "\n";
d289 1
a289 1
sub print
d292 1
a292 1
	print "WANTLIB:       ", $self->stringize, "\n";
d302 1
a302 1
sub print
d305 1
a305 1
	print "Missing lib:   ", $self->stringize, " (NOT REACHABLE)\n";
d308 1
a308 1
sub print_error_not_reachable
d311 1
a311 2
	print "Bogus WANTLIB: ", $self->stringize, " (NOT REACHABLE)\n";
	return 1;
a359 1
use File::Basename;
d373 1
a373 1
	my ($item, $dest, $source) = @@_;
d390 3
a392 2
	if ($main::opt_o) {
		open($cmd, "-|", "ldd", "-f", "NEEDED lib%o.so.%m.%n\n", $n) or die "open: $!";
d396 2
a397 1
			exec('objdump', '-p', $n) or die "exec: $!";
d442 22
a463 1
package main;
d465 16
a480 1
getopts('od:f:B:F:s:O:');
d495 1
a495 1
	my ($pkgname, $pkgpath) = @@_;
d498 2
a499 2
	if (defined $opt_d) {
		my $location = "$opt_d/$pkgname.tgz";
d513 1
a513 1
	print "Asking ports for dependency $pkgname($pkgpath)\n";
d524 2
a525 2
	my ($pkgname, $pkgpath) = @@_;
	my $plist = get_plist($pkgname, $pkgpath);
d528 2
a529 1
		print "Error: can't solve dependency for $pkgname/$pkgpath\n";
d564 1
a564 1
	my ($plist, $lib, $binary) = @@_;
d579 1
a579 1
		handle_dependency($p, $pkgpath);
d598 1
a598 1
		$dep = handle_dependency($dep, $path)
d604 1
a604 1
	@@r = lookup_library('/usr/local', $libspec);
d615 1
a615 1
	my ($head, $h) = @@_;
d620 1
a620 1
			print $head, $line, "\n";
d626 1
a626 1
		print $head, $line, "\n";
d632 1
a632 1
	my ($plist, $source, @@l) = @@_;
d635 2
a636 1
	my $needed_libs = $opt_f ? AllRecorder->new : SimpleRecorder->new;
d638 3
a640 3
	if ($opt_s) {
		my $special =  DumpRecorder->new;
		$special->retrieve($opt_s);
d643 1
a643 1
		$plist->record_needed_libs($needed_libs, $source, @@l);
d655 3
a657 3
			my $issue = report_lib_issue($plist, $lib, $fullname);
			$issue->print;
			$errors++;
d660 4
a663 3
			my $issue = report_lib_issue($plist, $lib, $fullname);
			if ($issue->print_error_not_reachable) {
				$errors++;
d671 1
a671 1
		print "Extra:         $k\n";
d673 3
a675 3
	print_list("\tWANTLIB +=", $r->{wantlib});
	if ($opt_f) {
	    $needed_libs->dump(\*STDOUT);
d681 1
a681 1
	my $pkgname = shift;
a682 1
	print "\n$pkgname:\n";
d689 3
a691 2
	if ($opt_B) {
		analyze($plist, FsFileSource->new($opt_B));
d693 3
a695 2
		my $temp = File::Temp::mkdtemp("/tmp/zoinx.XXXXXXXXXX");
		analyze($plist, PkgFileSource->new($true_package, $temp));
d706 2
d710 1
a710 2
		print STDERR "Error reading plist\n";
		$errors++;
d713 2
a714 2
		print "\n$pkgname:\n";
		analyze($plist, FsFileSource->new($opt_B));
d718 42
a759 19
if ($opt_F) {
	my $recorder = DumpRecorder->new;
	my $cwd = $opt_F;
	my $source = FsFileSource->new($opt_F);
	File::Find::find({
		wanted => sub {
		    return if -l $_;
		    return unless -f _;
		    my $name = $_;
		    $name =~ s/^\Q$opt_F\E//;
		    # XXX hack FileBase object;
		    my $i = bless {name => $name}, "MyFile";
		    $i->record_needed_libs($recorder, $source);
		},
		no_chdir => 1 }, $opt_F);
	if ($opt_O) {
		open my $fh, '>', $opt_O or die "Can't write to $opt_O: $!";
		$recorder->dump($fh);
		close $fh;
d761 6
a766 1
		$recorder->dump(\*STDOUT);
d768 2
a769 8
	exit(0);
}
if (@@ARGV == 0 && defined $opt_B) {
	do_plist();
} else {
    for my $pkgname (@@ARGV) {
	    do_pkg($pkgname);
    }
d772 2
a773 1
exit($errors ? 1 : 0);
@


1.18
log
@don't look at symlinks. if they point inside fake, then we get the file
anyways. if they point outside of it, they don't make sense until
installed, and we got the file anyways...
@
text
@d3 1
a3 1
# $OpenBSD: check-lib-depends,v 1.17 2010/01/26 21:22:57 espie Exp $
d42 2
a43 2
# FakeFileSource : file system
package FakeFileSource;
d65 2
a66 2
# RealFileSource: package archive
package RealFileSource;
d653 1
a653 1
		analyze($plist, FakeFileSource->new($opt_B));
d656 1
a656 1
		analyze($plist, RealFileSource->new($true_package, $temp));
d674 1
a674 1
		analyze($plist, FakeFileSource->new($opt_B));
d681 1
a681 1
	my $source = FakeFileSource->new($opt_F);
@


1.17
log
@fix check-lib-depends since SharedLibs changed slightly (quick fix
adaptation for now).

As noticed by kili@@
@
text
@d3 1
a3 1
# $OpenBSD: check-lib-depends,v 1.16 2008/04/22 21:36:06 espie Exp $
d684 2
a685 1
		    return unless -f $_;
@


1.16
log
@handle fedora + redhat.

based on Mikolaj Kucharski <mikolaj@@kucharski.name> patch.
@
text
@d3 1
a3 1
# $OpenBSD: check-lib-depends,v 1.15 2008/02/20 07:04:25 espie Exp $
d31 1
d514 12
d535 1
a535 1
		my @@r = OpenBSD::SharedLibs::lookup_libspec($dir, $libspec);
d546 1
a546 1
	my @@r = OpenBSD::SharedLibs::lookup_libspec('/usr/local', $libspec);
d568 1
a568 1
	@@r = OpenBSD::SharedLibs::lookup_libspec('/usr/local', $libspec);
@


1.15
log
@... and shellquote is now counterproductive... noticed by the same.
@
text
@d3 1
a3 1
# $OpenBSD: check-lib-depends,v 1.14 2008/02/19 11:02:53 espie Exp $
d380 1
a380 1
	if ($fullname =~ m,^/usr/local/emul/redhat/,) {
@


1.14
log
@use exec(@@list), avoid quoting issue.
thanks to  Johan Kiviniemi and Antti Harri
@
text
@d3 1
a3 1
# $OpenBSD: check-lib-depends,v 1.13 2007/10/27 22:15:28 espie Exp $
a361 7
sub shellquote
{
	local $_ = shift;
	s/[*?;() #\\'"`\${}]/\\$&/g;
	return $_;
}

d390 1
a390 1
	my $n = shellquote($source->retrieve($item));
@


1.13
log
@Fix ldd command line.

Problem found out by mbalmer@@, funnily enough, on the vax, which doesn't
HAVE shared libraries.
@
text
@d3 1
a3 1
# $OpenBSD: check-lib-depends,v 1.12 2007/06/16 20:15:33 espie Exp $
d400 1
a400 1
		open($cmd, "ldd -f 'NEEDED lib%o.so.%m.%n\\n' $n|");
d402 4
a405 1
		open($cmd, "objdump -p $n 2>/dev/null|");
@


1.12
log
@start recording rpaths in .saved_libs, not really used yet.
@
text
@d3 1
a3 1
# $OpenBSD: check-lib-depends,v 1.11 2007/06/03 11:57:36 espie Exp $
d400 1
a400 1
		open($cmd, "ldd -f 'NEEDED lib%o.so.%m.%n\\n'|");
@


1.11
log
@ouch, look for the actual location, not the package name, so that
we use built packages as much as possible (this is much faster than
regenerating packing-lists on the fly).
@
text
@d3 1
a3 1
# $OpenBSD: check-lib-depends,v 1.10 2007/06/03 11:01:10 espie Exp $
d134 4
d189 7
a195 1
	push(@@{$self->{$filename}}, $lib);
d201 6
a206 2
	while (my ($binary, $libs) = each %$self) {
		print $fh $binary, ": ", join(',', @@$libs), "\n";
d219 3
d413 11
d481 1
a496 1
		print "Error: use -d directory or set the PORTSDIR correctly\n";
d552 1
d555 1
@


1.10
log
@allows saving/retrieving dump of objdump runs.
@
text
@d3 1
a3 1
# $OpenBSD: check-lib-depends,v 1.9 2007/06/03 10:32:23 espie Exp $
d427 1
a427 1
	my $pkgname = $plist->pkgname();
d441 1
a441 1
		my $true_package = OpenBSD::PackageLocator->find($pkgname);
d443 1
a443 2
			my $dir = $true_package->info();
			# twice read
d446 1
a446 1
				$true_package->close();
d476 1
a476 1
				$dependencies->{$p}->{$plist->pkgname()} =
d486 1
a486 1
	return $plist->pkgname();
@


1.9
log
@add an option which simply dumps the stuff out.
@
text
@d3 1
a3 1
# $OpenBSD: check-lib-depends,v 1.8 2007/06/03 09:21:50 espie Exp $
d34 1
a34 1
our ($opt_o, $opt_d, $opt_f, $opt_F, $opt_B);
d171 1
a171 1
	my $self = shift;
d173 1
a173 1
		print "$lib:\t\n";
d175 1
a175 1
			print "\t$binary\n";
d185 1
a185 1
	push(@@{$self->{$filename}}, $self->reduce_libname($lib));
d190 1
a190 1
	my $self = shift;
d192 1
a192 1
		print $binary, ": ", join(',', @@$libs), "\n";
d196 17
d312 4
d352 11
d420 1
a420 1
getopts('od:f:B:F:');
d563 7
a569 1
	$plist->record_needed_libs($needed_libs, $source, @@l);
d599 1
a599 1
	    $needed_libs->dump;
d643 1
a643 2
	$cwd .= '/' unless $cwd =~ m/\/$/;
	my $source = FakeFileSource->new($cwd);
d648 1
a648 1
		    $name =~ s/^\Q$opt_F\E\///;
d654 7
a660 1
	$recorder->dump;
@


1.8
log
@assorted cleaning-up:
- no longer any needed to put haslib and needlib together, since we
create it independently.
- replace the tests for opt_f by a distinct Recorder object, that either
keeps all binary names, or just some (bonus: this should allow us to
store the information the other way around).
- remove extra $db parameter which no longer servers any purpose.

Comment a few data structure.
@
text
@d3 1
a3 1
# $OpenBSD: check-lib-depends,v 1.7 2007/05/23 10:34:15 espie Exp $
d23 1
d34 1
a34 1
our ($opt_o, $opt_d, $opt_f, $opt_B);
d180 17
d281 9
d388 1
a388 1
getopts('od:f:B:');
d602 18
@


1.7
log
@synch with pkg_add src/ changes
@
text
@d3 1
a3 1
# $OpenBSD: check-lib-depends,v 1.6 2007/05/22 10:39:05 espie Exp $
d37 4
d42 1
d63 1
d65 1
d112 68
d306 1
a306 1
	my ($item, $t, $source) = @@_;
d345 1
a345 6
			$lib =~ s/^(.*\/)?lib(.*)\.so\.(\d+)\.\d+$/$2.$3/;
			if ($main::opt_f) {
			    push(@@{$t->{$lib}}, $fullname);
			} else {
			    $t->{$lib} = $fullname;
			}
d499 1
a499 1
	my ($plist, $db, $source, @@l) = @@_;
d501 5
a505 4
	my $pkgname = $plist->pkgname();
	my $t = { haslib => {}, needlib => {} };
	$plist->record_needed_libs($t->{needlib}, $source, @@l);
	$plist->register_libs($t->{haslib});
d512 3
a514 4
	for my $lib (sort keys %{$t->{needlib}}) {
		my $fullname = $t->{needlib}->{$lib};
		$fullname = $fullname->[0] if $opt_f;
		if (!defined $t->{haslib}->{$lib}) {
d519 1
a519 1
		} elsif ($t->{haslib}->{$lib} == 1) {
d525 1
a525 1
		$t->{haslib}->{$lib} = 2;
d527 2
a528 2
	for my $k (sort keys %{$t->{haslib}}) {
		my $v = $t->{haslib}->{$k};
d534 1
a534 6
	    for my $lib (sort keys %{$t->{needlib}}) {
		    print "$lib:\t\n";
		    for my $binary (sort @@{$t->{needlib}->{$lib}}) {
			    print "\t$binary\n";
		    }
	    }
a537 1
my $db = {};
d545 1
a545 1
	my $dir = $true_package->info();
d550 1
a550 1
		analyze($plist, $db, FakeFileSource->new($opt_B));
d553 1
a553 1
		analyze($plist, $db, RealFileSource->new($true_package, $temp));
d571 1
a571 1
		analyze($plist, $db, FakeFileSource->new($opt_B));
@


1.6
log
@old `check-lib-depends' has been dead for ages. Prepare for renaming.
@
text
@d3 1
a3 1
# $OpenBSD: check-newlib-depends,v 1.37 2007/05/21 21:43:50 espie Exp $
d356 1
a356 1
	OpenBSD::SharedLibs::add_plist_libs($plist);
d365 1
a365 1
	OpenBSD::SharedLibs::add_system_libs('/');
d438 1
a438 1
		OpenBSD::SharedLibs::add_plist_libs($plist);
@


1.5
log
@use new-style plist visitors.
@
text
@d3 1
a3 1
# $OpenBSD: check-lib-depends,v 1.4 2004/11/13 11:49:48 espie Exp $
d29 1
d33 154
a186 1
package OpenBSD::PackingList;
d189 1
a189 1
sub check_libs
d193 1
a193 2
package OpenBSD::PackingElement::LibDepend;
sub check_libs
a194 2
	my ($item, $t, $where, $handle, $system_libs) = @@_;
	$t->{deps}->{$item->{def}} = 1;
d197 1
a197 2
package OpenBSD::PackingElement::NewDepend;
sub check_libs
d199 19
a217 1
	&OpenBSD::PackingElement::LibDepend::check_libs;
d229 4
a232 2
my $portsdir;
$portsdir = $ENV{'PORTSDIR'} if defined $ENV{'PORTSDIR'};
a233 15
sub check_libs
{
	my ($item, $t, $where, $handle, $system_libs, $logfile) = @@_;
	my $fullname = File::Spec->canonpath($item->fullname());
	if ($fullname =~ m/(^.*lib[^\/]+\.so\.\d+)\.\d+$/) {
		$t->{has_libs}->{$&} = 1;
		$t->{has_libs}->{$1} = 1;
	}
	if ($fullname =~ m/^.*lib[^\/]+\.so$/) {
		$t->{has_libs}->{$&} = 1;
	}
	my $file = $handle->next();
	$file->{destdir} = $where;
	$file->{cwd} = $item->cwd();
	$file->{name} = $fullname;
d242 20
a261 42
	# this will fail because of links, so we don't care.
	eval { $file->create(); };
	unless ($@@) {
		my $n = shellquote("$where$fullname");
		open(my $cmd, "objdump -p $n 2>/dev/null|");
		local $_;
		my @@l;
		my @@rpath;
		while(<$cmd>) {
			if (m/^\s+NEEDED\s+(.*?)\s*$/) {
				my $lib = $1;
				next if defined $system_libs->{$lib};
				push(@@l, $lib);
				# detect linux binaries
				if ($lib eq 'libc.so.6') {
					$linux_bin = 1;
				}
			} elsif (m/^\s+RPATH\s+(.*?)\s*$/) {
				my $r = $1;
				@@rpath= split(':', $r);
				if (defined $portsdir and $r =~ m/\Q$portsdir\E/) {
				    print $t->{pkgname}, "($fullname) -> ", join(':', @@rpath),"\n";
				    
				}
			}
		}
		close($cmd);
		if ($linux_bin) {
			push(@@rpath, (qw(/lib /usr/lib /usr/X11R6/lib)));
			# linux ldconfig also looks in the current directory...
			push(@@rpath, dirname($fullname));
			# XXX this is an approximation, as we don't check 
			# what directories exist or not.
			push(@@rpath, map {'/usr/local/emul/redhat'.$_} @@rpath);
		} elsif ($freebsd_bin) {
			push(@@rpath, (qw(/usr/lib /usr/X11R6/lib /usr/lib/compat)));
			push(@@rpath, map {'/usr/local/emul/freebsd'.$_} @@rpath);
		} else {
			push(@@rpath, '/usr/local/lib');
		}
		for my $lib (@@l) {
			$t->{need_libs}->{$lib} = [$fullname, @@rpath];
d264 1
d266 10
a275 9
	if ($linux_bin or $freebsd_bin) {
		if ($fullname =~ m/^.*ld\-linux\.so\.\d+$/) {
			$t->{has_libs}->{$&} = 1;
		} elsif ($fullname =~ m/^.*lib[^\/]+\.so\.\d+$/) {
			$t->{has_libs}->{$&} = 1;
		} elsif ($fullname =~ m/^(.*lib[^\/]+\.so\.\d+)(\.\d+)\.\d+$/) {
			$t->{has_libs}->{$&} = 1;
			$t->{has_libs}->{$1} = 1;
			$t->{has_libs}->{$1.$2} = 1;
d278 9
a286 1
	unlink($where.$fullname);
d291 43
a333 1
sub analyze 
d335 2
a336 1
	my ($plist, $db, @@l) = @@_;
d338 15
a352 19
	my $where = File::Temp::mkdtemp("/tmp/zoinx.XXXXXXXXXX");
	my $pkgname = $plist->pkgname();
	$db->{$pkgname} = {
		pkgname => $pkgname,
		has_libs => {},
		need_libs => {},
		deps => {},
		walked => 0
	} unless defined $db->{$pkgname};
	my $t = $db->{$pkgname};
	$plist->check_libs($t, $where, @@l);
	rmtree($where);
}

sub find_lib
{
	my ($lib, $rp, $has) = @@_;
	for my $d (@@$rp) {
		return 1 if defined $has->{"$d/$lib"};
d354 5
a358 1
	return 0;
d361 47
a407 7
my $logfile;
our ($opt_a, $opt_l);
getopts('al:');
print "Scanning packages\n";
print "-----------------\n";
if (@@ARGV==0) {
	@@ARGV=(<*.tgz>);
d410 15
a424 2
if ($opt_l) {
	open my $logfile, '>', $opt_l;
d427 43
a469 4
my $system_libs = {};
for my $l (glob('{/usr/lib,/usr/X11R6/lib}/lib*.so*')) {
	if ($l =~ m/\/(lib[^\/]+\.so\.\d+\.\d+)$/) {
		$system_libs->{$1} = 1;
d472 1
a472 1
	
d478 1
a478 1
	print STDERR "$pkgname:\n";
d485 10
a494 4
	analyze($plist, $db, $true_package, $system_libs, $logfile);
	$true_package->close();
	rmtree($dir);
	$plist->forget();
d498 1
a498 2

sub walk_libs
d500 8
a507 31
	my ($entry, $db) = @@_;
	return if $entry->{walked};
	for my $dep (keys %{$entry->{deps}}) {
		if (!defined $db->{$dep} && $opt_a) {
			do_pkg($dep);
		}
		print "Can't find $dep\n" unless defined $db->{$dep};
		walk_libs($db->{$dep}, $db);
		for my $l (keys %{$db->{$dep}->{has_libs}}) {
			$entry->{has_libs}->{$l} = 1;
		}
		$entry->{walked} = 1;
	}
}
for my $pkgname (@@ARGV) {
	do_pkg($pkgname);
}

for my $pkgname (sort keys %$db) {
	my $t = $db->{$pkgname};
	walk_libs($t, $db);
	my @@l = ();
	for my $lib (sort keys %{$t->{need_libs}}) {
		next if defined $t->{has_libs}->{$lib};
		my $rp = $t->{need_libs}->{$lib};
		my $name = shift(@@$rp);
		next if find_lib($lib, $rp, $t->{has_libs});
		push(@@l, "$lib ($name)");
	}
	if (@@l != 0) {
		print $pkgname, ": ", join(' ', @@l), "\n";
d510 10
@


1.4
log
@synch with changes
@
text
@d3 1
a3 1
# $OpenBSD: check-lib-depends,v 1.3 2004/11/11 15:38:02 espie Exp $
d162 1
a162 1
	$plist->visit('check_libs', $t, $where, @@l);
@


1.3
log
@tell all big analyzers they can forget about the packing-list.
@
text
@d3 1
a3 1
# $OpenBSD: check-lib-depends,v 1.2 2004/09/14 22:30:36 espie Exp $
d77 1
a77 1
	$file->{cwd} = $item->{cwd};
@


1.2
log
@visit in the base system.
@
text
@d3 1
a3 1
# $OpenBSD: check-lib-depends,v 1.1 2004/09/14 22:22:17 espie Exp $
d210 1
@


1.1
log
@check lib dependencies on binary packages.
@
text
@d3 1
a3 1
# $OpenBSD$
a32 29

sub visit
{
	my ($self, $method, @@l) = @@_;

	if (defined $self->{cvstags}) {
		for my $item (@@{$self->{cvstags}}) {
			$item->$method(@@l);
		}
	}

	for my $special (OpenBSD::PackageInfo::info_names()) {
		$self->{$special}->$method(@@l, 0) if defined $self->{$special};
	}

	for my $unique_item (qw(name no-default-conflict manual-installation extrainfo arch)) {
		$self->{$unique_item}->$method(@@l) if defined $self->{$unique_item};
	}
	for my $listname (qw(modules pkgcfl pkgdep newdepend libdepend items)) {
		if (defined $self->{$listname}) {
			for my $item (@@{$self->{$listname}}) {
				$item->$method(@@l);
			}
		}
	}
	for my $special (OpenBSD::PackageInfo::info_names()) {
		$self->{$special}->$method(@@l, 1) if defined $self->{$special};
	}
}
@

