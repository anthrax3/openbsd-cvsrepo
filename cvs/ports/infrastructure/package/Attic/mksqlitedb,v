head	1.16;
access;
symbols
	OPENBSD_4_0:1.13.0.2
	OPENBSD_4_0_BASE:1.13;
locks; strict;
comment	@# @;


1.16
date	2006.10.15.09.42.17;	author espie;	state dead;
branches;
next	1.15;

1.15
date	2006.10.14.09.03.23;	author espie;	state Exp;
branches;
next	1.14;

1.14
date	2006.09.19.09.57.58;	author espie;	state Exp;
branches;
next	1.13;

1.13
date	2006.08.01.16.22.22;	author espie;	state Exp;
branches;
next	1.12;

1.12
date	2006.08.01.11.01.15;	author espie;	state Exp;
branches;
next	1.11;

1.11
date	2006.07.10.15.19.52;	author espie;	state Exp;
branches;
next	1.10;

1.10
date	2006.07.10.14.34.01;	author espie;	state Exp;
branches;
next	1.9;

1.9
date	2006.07.10.11.44.30;	author espie;	state Exp;
branches;
next	1.8;

1.8
date	2006.07.10.10.52.08;	author espie;	state Exp;
branches;
next	1.7;

1.7
date	2006.07.10.10.35.50;	author espie;	state Exp;
branches;
next	1.6;

1.6
date	2006.07.10.08.01.08;	author bernd;	state Exp;
branches;
next	1.5;

1.5
date	2006.07.09.20.59.57;	author espie;	state Exp;
branches;
next	1.4;

1.4
date	2006.07.09.20.56.48;	author espie;	state Exp;
branches;
next	1.3;

1.3
date	2006.07.09.17.39.34;	author ckuethe;	state Exp;
branches;
next	1.2;

1.2
date	2006.07.09.11.23.50;	author espie;	state Exp;
branches;
next	1.1;

1.1
date	2006.07.09.11.00.53;	author espie;	state Exp;
branches;
next	;


desc
@@


1.16
log
@moved to ports/databases/sqlports
@
text
@#! /usr/bin/perl
# $OpenBSD: mksqlitedb,v 1.15 2006/10/14 09:03:23 espie Exp $
#
# Copyright (c) 2006 Marc Espie <espie@@openbsd.org>
#
# Permission to use, copy, modify, and distribute this software for any
# purpose with or without fee is hereby granted, provided that the above
# copyright notice and this permission notice appear in all copies.
#
# THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
# ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
# OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

# example script that shows how to store all variable values into a
# database, using SQLite for that purpose.
#
# usage: cd /usr/ports && make dump-vars |mksqlitedb

use strict;
use warnings;

sub words($)
{
	my $v = shift;
	$v =~ s/^\s+//;
	$v =~ s/\s+$//;
	return split(/\s+/, $v);
}

# use a Template Method approach to store the variable values.

# rule: we store each value in the main table, after converting YesNo
# variables to undef/1. Then, in addition, we process specific variables
# to store them in secondary tables (because of one/many associations).

package AnyVar;
sub add
{
	my ($class, $pkgpath, $db, $var, $value, $rowid) = @@_;
	my $stmt=$db->prepare("UPDATE Ports SET $var=(?) WHERE RowID=(?)");
	$stmt->execute($value, $rowid);
}

package YesNoVar;
our @@ISA=(qw(AnyVar));

sub add
{
	my ($class, $pkgpath, $db, $var, $value, $rowid) = @@_;
	$class->SUPER::add($pkgpath, $db, $var, $value =~ m/^Yes/i ? 1 : undef, $rowid);
}

# variable is always defined, but we don't need to store empty values.
package DefinedVar;
our @@ISA=(qw(AnyVar));

sub add
{
	my ($class, $pkgpath, $db, $var, $value, $rowid) = @@_;
	return if $value eq '';
	$class->SUPER::add($pkgpath, $db, $var, $value, $rowid);
}


# all the dependencies are converted into list. Stuff like LIB_DEPENDS will
# end up being treated as WANTLIB as well.

package DependsVar;
sub add
{
	my ($class, $pkgpath, $db, $var, $value, $rowid) = @@_;
	AnyVar->add($pkgpath, $db, $var, $value, $rowid);
	for my $depends (main::words $value) {
		my ($libs, $pkgspec, $pkgpath2, $rest) = split(/\:/, $depends);
		my $stmt = $db->prepare("INSERT INTO Depends (FULLPKGPATH, FULLDEPENDS, DEPENDSPATH, TYPE) VALUES (?, ?, ?, ?)");
		$stmt->execute($pkgpath, $depends, $pkgpath2, $class->type());
		if ($libs ne '') {
			for my $lib (split(/\,/, $libs)) {
				$class->addlib($pkgpath, $db, $lib);
			}
		}
	}
}

sub addlib
{
}

package LibDependsVar;
our @@ISA=(qw(DependsVar));
sub type() { 'L' }

sub addlib
{
	my ($class, $pkgpath, $db, $lib) = @@_;
	WantlibVar->addvalue($pkgpath, $db, $lib);
}

package RunDependsVar;
our @@ISA=(qw(DependsVar));
sub type() { 'R' }

package BuildDependsVar;
our @@ISA=(qw(DependsVar));
sub type() { 'B' }

package RegressDependsVar;
our @@ISA=(qw(DependsVar));
sub type() { 'Regress' }

# Stuff that gets stored in another table as well
package SecondaryVar;
sub addvalue
{
	my ($class, $pkgpath, $db, $value) = @@_;
	my $stmt = $db->prepare("INSERT OR REPLACE INTO ".$class->table." (FULLPKGPATH, VALUE) VALUES (?, ?)");
	$stmt->execute($pkgpath, $value);
}

# Generic handling for any blank-separated list
package ListVar;
our @@ISA=(qw(SecondaryVar));

sub add
{
	my ($class, $pkgpath, $db, $var, $value, $rowid) = @@_;
	AnyVar->add($pkgpath, $db, $var, $value, $rowid);
	for my $d (main::words $value) {
		$class->addvalue($pkgpath, $db, $d) if $d ne '';
	}
}

package QuotedListVar;
our @@ISA=(qw(SecondaryVar));

sub add
{
	my ($class, $pkgpath, $db, $var, $value, $rowid) = @@_;
	AnyVar->add($pkgpath, $db, $var, $value, $rowid);
	my @@l = (main::words $value);
	while (my $v = shift @@l) {
		while ($v =~ m/^[^']*\'[^']*$/ || $v =~m/^[^"]*\"[^"]*$/) {
			$v.=' '.shift @@l;
		}
		if ($v =~ m/^\"(.*)\"$/) {
		    $v = $1;
		}
		if ($v =~ m/^\'(.*)\'$/) {
		    $v = $1;
		}
		$class->addvalue($pkgpath, $db, $v) if $v ne '';
	}
}

package DefinedListVar;
our @@ISA=(qw(ListVar));
sub add
{
	my ($class, $pkgpath, $db, $var, $value, $rowid) = @@_;
	return if $value eq '';
	$class->SUPER::add($pkgpath, $db, $var, $value, $rowid);
}

package FlavorsVar;
our @@ISA=(qw(DefinedListVar));
sub table() { 'Flavors' }

package CategoriesVar;
our @@ISA=(qw(ListVar));
sub table() { 'Categories' }

package MultiVar;
our @@ISA=(qw(ListVar));
sub table() { 'Multi' }

package ModulesVar;
our @@ISA=(qw(ListVar));
sub table() { 'Modules' }

package ConfigureVar;
our @@ISA=(qw(DefinedListVar));
sub table() { 'Configure' }

package ConfigureArgsVar;
our @@ISA=(qw(QuotedListVar));
sub table() { 'ConfigureArgs' }

package WantlibVar;
our @@ISA=(qw(ListVar));
sub table() { 'Wantlib' }
sub addvalue
{
	my ($class, $pkgpath, $db, $value) = @@_;
	$class->SUPER::addvalue($pkgpath, $db, $value);
	if ($value =~ m/\(\>?\=\)?\.\d+\.\d+$/) {
		$class->SUPER::addvalue($pkgpath, $db, $`);
	} elsif ($value =~ m/\(\>?\=\)?\.\d+$/) {
		$class->SUPER::addvalue($pkgpath, $db, $`);
	}
}

package FileVar;
our @@ISA=(qw(SecondaryVar));

sub add
{
	my ($class, $pkgpath, $db, $var, $value, $rowid) = @@_;
	AnyVar->add($pkgpath, $db, $var, $value, $rowid);
	open my $file, '<', $value or return;
	local $/ = undef;
	$class->addvalue($pkgpath, $db, <$file>);
}

sub table() { 'Descr' }

package SharedLibsVar;
our @@ISA=(qw(AnyVar));

sub add
{
	my ($class, $pkgpath, $db, $var, $value, $rowid) = @@_;
	$class->SUPER::add($pkgpath, $db, $var, $value, $rowid);
	my $stmt = $db->prepare("INSERT INTO Shared_Libs (FULLPKGPATH, LIBNAME, VERSION) VALUES (?, ?, ?)");
	my %t = main::words($value);
	while (my ($k, $v) = each %t) {
		$stmt->execute($pkgpath, $k, $v);
	}
}


package main;

use DBI;

my $dbname;
if (@@ARGV > 0) {
	$dbname = shift;
} else {
	$dbname = 'sqlports';
}

my $db =DBI->connect("dbi:SQLite:dbname=$dbname", '', '', {AutoCommit => 0});
my $vars = {
    AUTOCONF_VERSION => 'AnyVar',
    AUTOMAKE_VERSION => 'AnyVar',
    BROKEN => 'AnyVar',
    BUILD_DEPENDS => 'BuildDependsVar',
    CATEGORIES=> 'CategoriesVar',
    COMMENT => 'AnyVar',
    CONFIGURE_ARGS => 'ConfigureArgsVar',
    CONFIGURE_STYLE => 'ConfigureVar',
    DESCR => 'FileVar',
    PACKAGING => 'AnyVar',
    DISTFILES => 'AnyVar',
    DISTNAME => 'AnyVar',
    DIST_SUBDIR => 'DefinedVar',
    FLAVORS => 'FlavorsVar',
    FULLPKGNAME => 'AnyVar',
    HOMEPAGE => 'AnyVar',
    IS_INTERACTIVE => 'AnyVar',
    LIB_DEPENDS => 'LibDependsVar',
    MAINTAINER=> 'AnyVar',
    MASTER_SITES => 'AnyVar',
    MASTER_SITES0 => 'AnyVar',
    MASTER_SITES1 => 'AnyVar',
    MASTER_SITES2 => 'AnyVar',
    MASTER_SITES3 => 'AnyVar',
    MASTER_SITES4=> 'AnyVar',
    MASTER_SITES5 => 'AnyVar',
    MASTER_SITES6 => 'AnyVar',
    MASTER_SITES7 => 'AnyVar',
    MASTER_SITES8 => 'AnyVar',
    MASTER_SITES9=> 'AnyVar',
    MODULES => 'ModulesVar',
    MULTI_PACKAGES => 'MultiVar',
    NO_BUILD => 'YesNoVar',
    NO_REGRESS => 'YesNoVar',
    ONLY_FOR_ARCHS => 'AnyVar',
    PACKAGES => 'AnyVar',
    PERMIT_DISTFILES_CDROM => 'AnyVar',
    PERMIT_DISTFILES_FTP=> 'AnyVar',
    PERMIT_PACKAGE_CDROM => 'AnyVar',
    PERMIT_PACKAGE_FTP=> 'AnyVar',
    PKGNAME => 'AnyVar',
    PKG_ARCH => 'AnyVar',
    PSEUDO_FLAVORS => 'DefinedVar',
    REGRESS_DEPENDS => 'RegressDependsVar',
    REGRESS_IS_INTERACTIVE => 'AnyVar',
    RUN_DEPENDS => 'RunDependsVar',
    SEPARATE_BUILD => 'AnyVar',
    SHARED_LIBS => 'SharedLibsVar',
    SHARED_ONLY => 'YesNoVar',
    SUBPACKAGE => 'DefinedVar',
    SUPDISTFILES => 'AnyVar',
    USE_GMAKE => 'YesNoVar',
    USE_LIBTOOL => 'YesNoVar',
    USE_MOTIF => 'YesNoVar',
    WANTLIB => 'WantlibVar',
};

# create the various tables, dropping old versions

for my $t (qw(Categories Flavors Multi Modules Configure ConfigureArgs Wantlib Descr)) {
    $db->do("DROP TABLE $t");
    $db->do("CREATE TABLE $t (FULLPKGPATH TEXT NOT NULL, VALUE TEXT NOT NULL, UNIQUE(FULLPKGPATH, VALUE))");
}
$db->do("DROP TABLE Depends");
$db->do("CREATE TABLE Depends (FULLPKGPATH TEXT NOT NULL, FULLDEPENDS TEXT NOT NULL, DEPENDSPATH TEXT NOT NULL, TYPE TEXT NOT NULL)");
$db->do("DROP TABLE Shared_Libs");
$db->do("CREATE TABLE Shared_Libs (FULLPKGPATH TEXT NOT NULL, LIBNAME TEXT NOT NULL, VERSION TEXT NOT NULL, UNIQUE (FULLPKGPATH, LIBNAME))");
$db->do("DROP TABLE Ports");
$db->do("CREATE TABLE Ports (FULLPKGPATH TEXT PRIMARY KEY, ".
	join(',', (map {$_." TEXT"} (keys %$vars))).")");
$db->do("DROP TABLE Paths");
$db->do("CREATE TABLE Paths (FULLPKGPATH TEXT PRIMARY KEY, PKGPATH TEXT NOT NULL)");
$db->commit();

my $stmt = $db->prepare("SELECT RowID FROM Ports WHERE FULLPKGPATH=(?)");
my $stmt2= $db->prepare("INSERT INTO Ports (FULLPKGPATH) VALUES (?)");
my $stmt3= $db->prepare("INSERT INTO Paths (FULLPKGPATH, PKGPATH) VALUES (?, ?)");

my $i = 0;
my $rowid;
my $lastkey;
while (<STDIN>) {
	chomp;
	# kill noise
	if (m/^\=\=\=/) {
		print $_, "\n";
		next;
	}
	next unless m/^(.*?)\.([A-Z][A-Z_0-9]*)\=(.*)$/;

	my ($key, $var, $value) = ($1, $2, $3);
	# strip extra quotes
	if ($value =~ m/^\"(.*)\"$/) {
		$value = $1;
	}

	if (!(defined $lastkey) || $key ne $lastkey) {
		# get rowid for existing value
		$stmt->execute($key);
		my $z = $stmt->fetchall_arrayref;
		if (@@$z == 0) {
			# if none, we create one
			$stmt2->execute($key);
			my $path = $key;
			$path =~ s/\,.*//;
			$stmt3->execute($key, $path);
			$stmt->execute($key);
			$z = $stmt->fetchall_arrayref;
		}
		$rowid = $z->[0]->[0];
		$lastkey = $key;
	}
	$vars->{$var}->add($key, $db, $var, $value, $rowid);

	# and we commit just once every 1000 transactions, for efficiency
	$i++;
	if ($i % 1000 == 0) {
		$db->commit();
	}
}
$db->commit();

@


1.15
log
@oops, forgot to commit FULLPKGNAME.
From Serge Basterot
@
text
@d2 1
a2 1
# $OpenBSD: mksqlitedb,v 1.14 2006/09/19 09:57:58 espie Exp $
@


1.14
log
@split things exactly like make does, avoid a few spurious error messages
from sqlite.
@
text
@d2 1
a2 1
# $OpenBSD: mksqlitedb,v 1.13 2006/08/01 16:22:22 espie Exp $
d262 1
@


1.13
log
@tweak for PKGPATH, name it correctly as FULLPKGPATH, and add a subsidiary
table to map FULLPKGPATH to PKGPATH, e.g.,

SELECT DISTINCT PKGPATH, VALUE FROM Wantlib,Paths WHERE Wantlib.FULLPKGPATH=Paths.FULLPKGPATH ORDER BY PKGPATH
@
text
@d2 1
a2 1
# $OpenBSD: mksqlitedb,v 1.12 2006/08/01 11:01:15 espie Exp $
d26 7
d77 1
a77 1
	for my $depends (split /\s+/, $value) {
d132 1
a132 1
	for my $d (split /\s+/, $value) {
d144 1
a144 1
	my @@l = (split /\s+/, $value);
d228 1
a228 1
	my %t = split(/\s+/, $value);
@


1.12
log
@handle new lib specs
@
text
@d2 1
a2 1
# $OpenBSD: mksqlitedb,v 1.11 2006/07/10 15:19:52 espie Exp $
d72 1
a72 1
		my $stmt = $db->prepare("INSERT INTO Depends (PKGPATH, FULLDEPENDS, DEPENDSPATH, TYPE) VALUES (?, ?, ?, ?)");
d113 1
a113 1
	my $stmt = $db->prepare("INSERT OR REPLACE INTO ".$class->table." (PKGPATH, VALUE) VALUES (?, ?)");
d220 1
a220 1
	my $stmt = $db->prepare("INSERT INTO Shared_Libs (PKGPATH, LIBNAME, VERSION) VALUES (?, ?, ?)");
d301 1
a301 1
    $db->do("CREATE TABLE $t (PKGPATH TEXT NOT NULL, VALUE TEXT NOT NULL, UNIQUE(PKGPATH, VALUE))");
d304 1
a304 1
$db->do("CREATE TABLE Depends (PKGPATH TEXT NOT NULL, FULLDEPENDS TEXT NOT NULL, DEPENDSPATH TEXT NOT NULL, TYPE TEXT NOT NULL)");
d306 1
a306 1
$db->do("CREATE TABLE Shared_Libs (PKGPATH TEXT NOT NULL, LIBNAME TEXT NOT NULL, VERSION TEXT NOT NULL, UNIQUE (PKGPATH, LIBNAME))");
d308 4
a311 2
$db->do("CREATE TABLE Ports (PKGPATH TEXT PRIMARY KEY, ".
join(',', (map {$_." TEXT"} (keys %$vars))).")");
d314 3
a316 2
my $stmt = $db->prepare("SELECT RowID FROM Ports WHERE PKGPATH=(?)");
my $stmt2= $db->prepare("INSERT INTO Ports (PKGPATH) VALUES (?)");
d343 3
@


1.11
log
@CONFIGURE_ARGS holds values that look like --with-cxxflags="-O2 -pipe"
deal with split/quotes correctly.
@
text
@d2 1
a2 1
# $OpenBSD: mksqlitedb,v 1.10 2006/07/10 14:34:01 espie Exp $
d192 1
a192 1
	if ($value =~ m/\.\d+\.\d+$/) {
d194 1
a194 1
	} elsif ($value =~ m/\.\d+$/) {
@


1.10
log
@Handle CONFIGURE_ARGS as a list, e.g.,
SELECT DISTINCT VALUE FROM ConfigureArgs
makes sense.
@
text
@d2 1
a2 1
# $OpenBSD: mksqlitedb,v 1.9 2006/07/10 11:44:30 espie Exp $
d130 22
d182 1
a182 1
our @@ISA=(qw(ListVar));
d329 1
a329 1
	if ($value =~ m/^\"(.*)\"/) {
@


1.9
log
@Really process SHARED_LIBS
@
text
@d2 1
a2 1
# $OpenBSD: mksqlitedb,v 1.8 2006/07/10 10:52:08 espie Exp $
d159 4
d225 1
a225 1
    CONFIGURE_ARGS => 'AnyVar',
d277 1
a277 1
for my $t (qw(Categories Flavors Multi Modules Configure Wantlib Descr)) {
@


1.8
log
@+CONFIGURE_ARGS
@
text
@d2 1
a2 1
# $OpenBSD: mksqlitedb,v 1.7 2006/07/10 10:35:50 espie Exp $
a33 1

d187 15
d261 1
a261 1
    SHARED_LIBS => 'DefinedVar',
d279 2
@


1.7
log
@add AUTOCONF/AUTOMAKE_VERSION
@
text
@d2 1
a2 1
# $OpenBSD: mksqlitedb,v 1.6 2006/07/10 08:01:08 bernd Exp $
d207 1
@


1.6
log
@Fix typos and do some cleanup.

'go ahead' espie@@
@
text
@d2 1
a2 1
# $OpenBSD: mksqlitedb,v 1.5 2006/07/09 20:59:57 espie Exp $
d201 2
@


1.5
log
@avoid committing empty entries in space separated lists.
@
text
@d2 1
a2 1
# $OpenBSD: mksqlitedb,v 1.4 2006/07/09 20:56:48 espie Exp $
d31 1
a31 1
# to store them in secundary tables (because of one/many associations).
d110 1
a110 1
package SecundaryVar;
d114 1
a114 1
	my $stmt = $db->prepare("INSERT OR REPLACE INTO ".$class->table."(PKGPATH, VALUE) VALUES (?, ?)");
d120 1
a120 1
our @@ISA=(qw(SecundaryVar));
d175 1
a175 1
our @@ISA=(qw(SecundaryVar));
d246 1
a246 1
    SUBPACKAGE => 'DefinedVar', 
@


1.4
log
@do not commit empty libspecs.
keep rowid around, since the key does not change for every iteration.
@
text
@d2 1
a2 1
# $OpenBSD: mksqlitedb,v 1.3 2006/07/09 17:39:34 ckuethe Exp $
d127 1
a127 1
		$class->addvalue($pkgpath, $db, $d);
@


1.3
log
@Fix comment describing usage.
ok espie
@
text
@d2 1
a2 1
# $OpenBSD: mksqlitedb,v 1.2 2006/07/09 11:23:50 espie Exp $
d75 4
a78 2
		for my $lib (split(/,/, $libs)) {
			$class->addlib($pkgpath, $db, $lib);
d271 2
d288 2
a289 6
	# get rowid for existing value
	$stmt->execute($key);
	my $z = $stmt->fetchall_arrayref;
	if (@@$z == 0) {
		# if none, we create one
		$stmt2->execute($key);
d291 9
a299 1
		$z = $stmt->fetchall_arrayref;
a300 1
	my $rowid = $z->[0]->[0];
@


1.2
log
@also dump SUPDISTFILES
do not store empty values which are always defined, but can be empty.
@
text
@d2 1
a2 1
# $OpenBSD: mksqlitedb,v 1.1 2006/07/09 11:00:53 espie Exp $
d21 1
a21 1
# usage: cd /usr/ports && make dump-all-vars |mksqlitedb
@


1.1
log
@Example script to convert values from the ports tree into an sqlite database.

Discussed with robi/bernd/steven.
@
text
@d2 1
a2 1
# $OpenBSD$
d51 11
d129 9
d139 1
a139 1
our @@ISA=(qw(ListVar));
d155 1
a155 1
our @@ISA=(qw(ListVar));
d208 1
a208 1
    DIST_SUBDIR => 'AnyVar',
d237 1
a237 1
    PSEUDO_FLAVORS => 'AnyVar',
d242 1
a242 1
    SHARED_LIBS => 'AnyVar',
d244 2
a245 1
    SUBPACKAGE => 'AnyVar', 
@

