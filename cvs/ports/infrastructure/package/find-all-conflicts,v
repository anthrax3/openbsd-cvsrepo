head	1.20;
access;
symbols
	OPENBSD_6_2:1.20.0.30
	OPENBSD_6_2_BASE:1.20
	OPENBSD_6_1:1.20.0.28
	OPENBSD_6_1_BASE:1.20
	OPENBSD_6_0:1.20.0.26
	OPENBSD_6_0_BASE:1.20
	OPENBSD_5_9:1.20.0.22
	OPENBSD_5_9_BASE:1.20
	OPENBSD_5_8:1.20.0.24
	OPENBSD_5_8_BASE:1.20
	OPENBSD_5_7:1.20.0.20
	OPENBSD_5_7_BASE:1.20
	OPENBSD_5_6:1.20.0.18
	OPENBSD_5_6_BASE:1.20
	OPENBSD_5_5:1.20.0.16
	OPENBSD_5_5_BASE:1.20
	OPENBSD_5_4:1.20.0.14
	OPENBSD_5_4_BASE:1.20
	OPENBSD_5_3:1.20.0.12
	OPENBSD_5_3_BASE:1.20
	OPENBSD_5_2:1.20.0.10
	OPENBSD_5_2_BASE:1.20
	OPENBSD_5_1_BASE:1.20
	OPENBSD_5_1:1.20.0.8
	OPENBSD_5_0:1.20.0.6
	OPENBSD_5_0_BASE:1.20
	OPENBSD_4_9:1.20.0.4
	OPENBSD_4_9_BASE:1.20
	OPENBSD_4_8:1.20.0.2
	OPENBSD_4_8_BASE:1.20
	OPENBSD_4_7:1.16.0.12
	OPENBSD_4_7_BASE:1.16
	OPENBSD_4_6:1.16.0.10
	OPENBSD_4_6_BASE:1.16
	OPENBSD_4_5:1.16.0.8
	OPENBSD_4_5_BASE:1.16
	OPENBSD_4_4:1.16.0.6
	OPENBSD_4_4_BASE:1.16
	OPENBSD_4_3:1.16.0.4
	OPENBSD_4_3_BASE:1.16
	OPENBSD_4_2:1.16.0.2
	OPENBSD_4_2_BASE:1.16
	OPENBSD_4_1:1.12.0.2
	OPENBSD_4_1_BASE:1.12
	OPENBSD_4_0:1.11.0.4
	OPENBSD_4_0_BASE:1.11
	OPENBSD_3_9:1.11.0.2
	OPENBSD_3_9_BASE:1.11
	OPENBSD_3_8:1.9.0.2
	OPENBSD_3_8_BASE:1.9
	OPENBSD_3_7:1.8.0.2
	OPENBSD_3_7_BASE:1.8
	OPENBSD_3_6:1.7.0.4
	OPENBSD_3_6_BASE:1.7
	OPENBSD_3_5:1.7.0.2
	OPENBSD_3_5_BASE:1.7
	OPENBSD_3_4:1.5.0.8
	OPENBSD_3_4_BASE:1.5
	OPENBSD_3_3:1.5.0.6
	OPENBSD_3_3_BASE:1.5
	OPENBSD_3_2:1.5.0.4
	OPENBSD_3_2_BASE:1.5
	OPENBSD_3_1:1.5.0.2
	OPENBSD_3_1_BASE:1.5
	OPENBSD_3_0:1.3.0.4
	OPENBSD_3_0_BASE:1.3
	OPENBSD_2_9_TRACKING_SWITCH:1.3
	OPENBSD_2_9:1.3.0.2
	OPENBSD_2_9_BASE:1.3
	OPENBSD_2_8:1.1.0.4
	OPENBSD_2_8_BASE:1.1
	OPENBSD_2_7:1.1.0.2
	OPENBSD_2_7_BASE:1.1;
locks; strict;
comment	@# @;


1.20
date	2010.06.30.11.11.19;	author espie;	state Exp;
branches;
next	1.19;

1.19
date	2010.06.25.10.37.03;	author espie;	state Exp;
branches;
next	1.18;

1.18
date	2010.06.10.23.08.14;	author espie;	state Exp;
branches;
next	1.17;

1.17
date	2010.06.09.13.59.37;	author espie;	state Exp;
branches;
next	1.16;

1.16
date	2007.05.13.08.03.47;	author espie;	state Exp;
branches;
next	1.15;

1.15
date	2007.04.16.15.09.03;	author espie;	state Exp;
branches;
next	1.14;

1.14
date	2007.04.16.14.36.25;	author espie;	state Exp;
branches;
next	1.13;

1.13
date	2007.04.10.21.36.26;	author espie;	state Exp;
branches;
next	1.12;

1.12
date	2007.02.19.19.50.50;	author bernd;	state Exp;
branches;
next	1.11;

1.11
date	2005.12.12.13.37.21;	author espie;	state Exp;
branches;
next	1.10;

1.10
date	2005.09.04.22.34.23;	author espie;	state Exp;
branches;
next	1.9;

1.9
date	2005.08.14.11.57.17;	author espie;	state Exp;
branches;
next	1.8;

1.8
date	2004.11.11.15.38.02;	author espie;	state Exp;
branches;
next	1.7;

1.7
date	2004.02.12.13.55.45;	author espie;	state Exp;
branches;
next	1.6;

1.6
date	2003.10.23.17.49.02;	author espie;	state Exp;
branches;
next	1.5;

1.5
date	2002.03.19.22.20.50;	author espie;	state Exp;
branches;
next	1.4;

1.4
date	2002.03.11.22.00.37;	author naddy;	state Exp;
branches;
next	1.3;

1.3
date	2001.04.15.17.44.29;	author espie;	state Exp;
branches;
next	1.2;

1.2
date	2001.03.24.15.16.53;	author espie;	state Exp;
branches;
next	1.1;

1.1
date	2000.04.19.14.31.18;	author espie;	state Exp;
branches;
next	;


desc
@@


1.20
log
@convert to newer interface. MAKE SURE you have -current pkg_add to run register_plist !
@
text
@#!/usr/bin/perl

# $OpenBSD: find-all-conflicts,v 1.19 2010/06/25 10:37:03 espie Exp $
# Copyright (c) 2000-2005
# Marc Espie.  All rights reserved.
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions
# are met:
# 1. Redistributions of code must retain the above copyright
#    notice, this list of conditions and the following disclaimer.
# 2. Neither the name of OpenBSD nor the names of its contributors
#    may be used to endorse or promote products derived from this software
#    without specific prior written permission.
#
# THIS SOFTWARE IS PROVIDED BY ITS AUTHOR AND THE OpenBSD project ``AS IS'' AND
# ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
# FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
# DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
# OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
# HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
# LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
# OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
# SUCH DAMAGE.

# check all packages in the current directory, and report conflicts which
# are not apparent in @@pkgcfl.

use strict;

use File::Spec;
use File::Path;
use OpenBSD::PackageInfo;
use OpenBSD::PackingList;
use OpenBSD::AddCreateDelete;
use OpenBSD::PkgCfl;

package OpenBSD::PackingElement;
sub register
{
}

package OpenBSD::PackingElement::FileBase;

my $pkg_list = {};
my $seen = {};

sub register 
{
	my ($self, $all_conflict, $all_deps, $pkgname) = @@_;

	my $file = File::Spec->canonpath($self->fullname);
	# build one single list for each pkgnames combination
	if (exists $all_conflict->{$file}) {
		$pkg_list->{$all_conflict->{$file}}->{$pkgname} ||=
		    [@@{$all_conflict->{$file}}, $pkgname ];
		$all_conflict->{$file} = 
		    $pkg_list->{$all_conflict->{$file}}->{$pkgname};
	} elsif (exists $seen->{$file}) {
		$pkg_list->{$seen->{$file}}->{$pkgname} ||=
		    [ @@{$seen->{$file}}, $pkgname ];
		$all_conflict->{$file} = 
		    $pkg_list->{$seen->{$file}}->{$pkgname};
		delete $seen->{$file};
	} else {
		$pkg_list->{$pkgname} ||= [$pkgname];
		$seen->{$file} = $pkg_list->{$pkgname};
	}
}

package OpenBSD::PackingElement::Depend;
sub register 
{
	my ($self, $all_conflict, $all_deps, $pkgname) = @@_;
	if (defined $self->{def}) {
		push @@{$all_deps->{$pkgname}}, $self->{def};
	}
}


package main;

my $cache = {};
my $cache2 = {};
my $cache3 = {};
my $cache4 = {}; 

sub direct_conflict
{
	my ($conflicts, $pkg, $pkg2) = @@_;

	return $cache3->{$pkg}{$pkg2} //= $conflicts->{$pkg}->conflicts_with($pkg2);
}

sub has_a_conflict
{
	my ($conflicts, $deps, $pkg, $pkg2) = @@_;
	return $cache4->{$pkg}{$pkg2} //= find_a_conflict($conflicts, $deps, $pkg, $pkg2);
}

sub find_a_conflict
{
	my ($conflicts, $deps, $pkg, $pkg2) = @@_;
	return 0 if $pkg eq $pkg2;
	
	if (defined $conflicts->{$pkg} && direct_conflict($conflicts, $pkg, $pkg2)) {
		return 1;
	}
	if (defined $deps->{$pkg}) {
		for my $dep (@@{$deps->{$pkg}}) {
		    if (has_a_conflict($conflicts, $deps, $dep, $pkg2)) {
			    return 1;
		    }
		}
	}
	if (defined $deps->{$pkg2}) {
		for my $dep (@@{$deps->{$pkg2}}) {
			if (has_a_conflict($conflicts, $deps, $pkg, $dep)) {
				return 1;
			}
		}
	}
	return 0;
}

sub compute_true_conflicts
{
	my ($l, $conflicts, $deps) = @@_;
	# create a list of unconflicting packages.
	my $l2 = [];
	for my $pkg (@@$l) {
		my $keepit = 0;
		for my $pkg2 (@@$l) {
			next if $pkg eq $pkg2;
			if (!(has_a_conflict($conflicts, $deps, $pkg, $pkg2) ||
			    has_a_conflict($conflicts, $deps, $pkg2, $pkg))) {
				$keepit = 1;
				last;
			}
		}
		if ($keepit) {
		    push(@@$l2, $pkg);
		}
	}
	return $l2;
}

sub compute_problems
{
	my ($ui, $h, $conflicts, $deps) = @@_;

	my $c = {};
	my $c2 = {};

	my $total = scalar(keys %$h);
	my $i =0;
	while (my ($key, $l) = each %$h) {
		$ui->progress->show(++$i, $total);
		if (!defined $c->{$l}) {
			my %s = map {($_, 1)} @@$l;
			$c->{$l} = [sort keys %s];
			$c2->{$l} = join(',', @@{$c->{$l}});
		}
		my $hv = $c2->{$l};
		$l = $c->{$l};
		next if @@$l == 1;
		if (!defined $cache->{$hv}) {
			$cache->{$hv} = compute_true_conflicts($l, $conflicts, $deps);
		}
		my $result = $cache->{$hv};
		if (@@$result != 0) {
			my $newkey = join(',', @@$result);
			if (@@$result == 1) {
				$newkey.="-> was ".join(',', @@$l);
			}
			push(@@{$cache2->{$newkey}}, $key);
		}
	}
}

my $filehash={};
my %dirhash=();
my $conflicts={};
my $dephash={};
our ($opt_d, $opt_p, $opt_v);

sub handle_plist
{
	my ($ui, $filename, $plist) = @@_;
	if (!defined $plist) {
		$ui->errsay("Error reading #1", $filename);
		return;
	}
	$ui->say("#1 -> #2", $filename, $plist->pkgname) if $ui->verbose;
	$plist->forget;
	$conflicts->{$plist->pkgname} = 
	    OpenBSD::PkgCfl->make_conflict_list($plist);
	$plist->register($filehash, $dephash, $plist->pkgname);
}

sub handle_file
{
	my ($ui, $filename) = @@_;
	my $plist = OpenBSD::PackingList->fromfile($filename);
	handle_plist($ui, $filename, $plist);
}

sub handle_portsdir
{
	my ($ui, $dir) = @@_;
	my $make = $ENV{MAKE} || 'make';

	open(my $input, "cd $dir && $make print-plist-all |");
	my $done = 0;
	while (!$done) {
		my $plist = OpenBSD::PackingList->read($input, sub {
			my ($fh, $cont) = @@_;
			local $_;
			while (<$fh>) {
				return if m/^\=\=\=\> /o;
				next unless m/^\@@(?:cwd|name|info|man|file|lib|shell|bin|conflict|comment\s+subdir\=)\b/o || !m/^\@@/o;
				&$cont($_);
			}
			$done = 1;
		});
		if (defined $plist && $plist->pkgname()) {
			handle_plist($ui, $dir, $plist);
			$ui->progress->working(10);
		}
	}
}

my $ui = OpenBSD::AddCreateDelete::State->new('find-all-conflicts');
$ui->handle_options('d:p:', '[-v] [-d plist_dir] [-p ports_dir] [pkgname ...]');

$ui->progress->set_header("Scanning");
$opt_d = $ui->opt('d');
$opt_p = $ui->opt('p');
if ($opt_d) {
	opendir(my $dir, $opt_d);
	my @@l = readdir $dir;
	closedir($dir);

	$ui->progress->for_list("Scanning", \@@l,
	    sub {
	    	my $pkgname = shift;
		return if $pkgname eq '.' or $pkgname eq '..';
		handle_file($ui, "$opt_d/$pkgname");
	    });
} elsif ($opt_p) {
	handle_portsdir($ui, $opt_p);
} elsif (@@ARGV==0) {
	@@ARGV=(<*.tgz>);
}

$ui->progress->for_list("Scanning", \@@ARGV,
    sub {
	my $pkgname = shift;
	my $true_package = $ui->repo->find($pkgname);
	return unless $true_package;
	my $dir = $true_package->info;
	$true_package->close;
	handle_file($ui, $dir.CONTENTS);
	rmtree($dir);
    });

$ui->progress->next;
$ui->progress->set_header("File problems");
compute_problems($ui, $filehash, $conflicts, $dephash);
for my $cfl (sort keys %$cache2) {
	$ui->say("#1", $cfl);
	for my $f (sort @@{$cache2->{$cfl}}) {
		$ui->say("\t#1", $f);
	}
}
@


1.19
log
@get bin files to participate, as noticed by sthen
@
text
@d3 1
a3 1
# $OpenBSD: find-all-conflicts,v 1.18 2010/06/10 23:08:14 espie Exp $
a33 1
use OpenBSD::PackageLocator;
a35 1
use OpenBSD::Getopt;
d235 1
a235 2
OpenBSD::AddCreateDelete->handle_options('d:p:', $ui, 
	'[-v] [-d plist_dir] [-p ports_dir] [pkgname ...]');
d245 4
a248 5
	my $total = scalar(@@l);
	my $i = 0;
	for my $pkgname (@@l) {
		$ui->progress->show(++$i, $total);
		next if $pkgname eq '.' or $pkgname eq '..';
d250 1
a250 1
    	}
d257 5
a261 5
my $i = 0;
for my $pkgname (@@ARGV) {
	$ui->progress->show(++$i, scalar(@@ARGV));
	my $true_package = OpenBSD::PackageLocator->find($pkgname);
	next unless $true_package;
d266 1
a266 1
}
@


1.18
log
@use new infra for progressmeters. Add caches to compute conflicts more
efficiently.
@
text
@d3 1
a3 1
# $OpenBSD: find-all-conflicts,v 1.17 2010/06/09 13:59:37 espie Exp $
d224 1
a224 1
				next unless m/^\@@(?:cwd|name|info|man|file|lib|shell|conflict|comment\s+subdir\=)\b/o || !m/^\@@/o;
@


1.17
log
@switch to new interface
@
text
@d3 1
a3 1
# $OpenBSD: find-all-conflicts,v 1.16 2007/05/13 08:03:47 espie Exp $
d38 1
a38 1
use OpenBSD::State;
d55 1
a55 1
	my $file= File::Spec->canonpath($self->fullname());
d88 15
d109 1
a109 1
	if (defined $conflicts->{$pkg} && $conflicts->{$pkg}->conflicts_with($pkg2)) {
d114 1
a114 1
		    if (find_a_conflict($conflicts, $deps, $dep, $pkg2)) {
d121 1
a121 1
			if (find_a_conflict($conflicts, $deps, $pkg, $dep)) {
d138 2
a139 2
			if (!(find_a_conflict($conflicts, $deps, $pkg, $pkg2) ||
			    find_a_conflict($conflicts, $deps, $pkg2, $pkg))) {
d153 1
a153 1
	my ($h, $conflicts, $deps) = @@_;
d158 2
d161 1
d192 1
a192 1
	my ($filename, $plist) = @@_;
d194 1
a194 1
		print STDERR "Error reading $filename\n";
d197 3
a199 3
	print "$filename -> ", $plist->pkgname(), "\n" if $opt_v;
	$plist->forget();
	$conflicts->{$plist->pkgname()} = 
d201 1
a201 1
	$plist->register($filehash, $dephash, $plist->pkgname());
d206 1
a206 1
	my $filename = shift;
d208 1
a208 1
	handle_plist($filename, $plist);
d213 1
a213 1
	my $dir  = shift;
a215 2
	print STDERR "$dir\n";

d230 2
a231 1
			handle_plist($dir, $plist);
d236 7
a242 6
my $ui = OpenBSD::State->new('find-all-conflicts');
$ui->usage_is('[-v] [-d plist_dir] [-p ports_dir] [pkgname ...]');
$ui->do_options(sub { getopts('d:p:v'); });

print "Scanning\n" if $opt_v;
print "--------\n" if $opt_v;
d245 7
a251 1
	while (my $pkgname = readdir($dir)) {
d253 1
a253 1
		handle_file("$opt_d/$pkgname");
a254 1
	closedir($dir);
d256 1
a256 1
	handle_portsdir($opt_p);
d261 1
d263 1
a263 1
	print STDERR "$pkgname\n";
d266 3
a268 3
	my $dir = $true_package->info();
	$true_package->close();
	handle_file($dir.CONTENTS);
d272 3
a274 3
print "File problems:\n";
print "-------------\n";
compute_problems($filehash, $conflicts, $dephash);
d276 1
a276 1
	print "$cfl\n";
d278 1
a278 1
		print "\t$f\n";
@


1.16
log
@use new-style plist visitors.
@
text
@d3 1
a3 1
# $OpenBSD: find-all-conflicts,v 1.15 2007/04/16 15:09:03 espie Exp $
d38 1
a38 1
use OpenBSD::Error;
d219 3
a221 6
set_usage('find-all-conflicts [-v] [-d plist_dir] [-p ports_dir] [pkgname ...]');
try {
    getopts('d:p:v');
} catchall {
	Usage($_);
};
@


1.15
log
@shave a bit of time (roughly 5%) by noticing that package lists are
now more or less `unique', so we can avoid processing them more
than once.
@
text
@d3 1
a3 1
# $OpenBSD: find-all-conflicts,v 1.14 2007/04/16 14:36:25 espie Exp $
d183 1
a183 1
	$plist->visit('register', $filehash, $dephash, $plist->pkgname());
@


1.14
log
@shrink memory used by building only one single list per set of pkgnames.

Also use a simple `seen' cache for files only used by one package, since
they cannot participate in actual conflicts.

Shrinks memory for 250M to 190M, with no negative speed effects.
@
text
@d3 1
a3 1
# $OpenBSD: find-all-conflicts,v 1.13 2007/04/10 21:36:26 espie Exp $
d140 3
d144 7
a151 4
		my %s = map {($_, 1)} @@$l;
		@@$l = sort keys %s;
		next if @@$l == 1;
		my $hv = join(',', @@$l);
@


1.13
log
@minor indent clean-up.
use auto-vivification to shorten code a bit.
pull out complicated code into its own function.
marginally faster than old version... some size decrease to do later...
@
text
@d3 1
a3 1
# $OpenBSD: find-all-conflicts,v 1.12 2007/02/19 19:50:50 bernd Exp $
d48 3
d56 16
a71 1
	push @@{$all_conflict->{$file}}, $pkgname;
@


1.12
log
@Introduce -p option. This allows us to scan the ports tree for conflicts
without the need to have the packages around.

It's really easy now to check if a new package conflicts with other stuff
in the ports-tree:

$ find-all-conflicts -p /usr/ports newpkg.tgz

help & ok espie@@
@
text
@d3 1
a3 1
# $OpenBSD: find-all-conflicts,v 1.11 2005/12/12 13:37:21 espie Exp $
a52 3
	unless (defined $all_conflict->{$file}) {
		$all_conflict->{$file} = [];
	}
a60 3
		unless (defined $all_deps->{$pkgname}) {
			$all_deps->{$pkgname} = [];
		}
d80 4
a83 3
	    for my $dep (@@{$deps->{$pkg}}) {
	    	if (find_a_conflict($conflicts, $deps, $dep, $pkg2)) {
			return 1;
a84 1
	    }
d87 4
a90 3
	    for my $dep (@@{$deps->{$pkg2}}) {
	    	if (find_a_conflict($conflicts, $deps, $pkg, $dep)) {
			return 1;
a91 1
	    }
d96 22
d120 1
a120 1
    my ($h, $conflicts, $deps) = @@_;
d122 6
a127 5
    while (my ($key, $l) = each %$h) {
	    my %s = map {($_, 1)} @@$l;
	    @@$l = sort keys %s;
	    if (@@$l > 1) {
	    	my $hv = join(',', @@$l);
d129 1
a129 17
			# create a list of unconflicting packages.
			my $l2 = [];
			for my $pkg (@@$l) {
				my $keepit = 0;
			    for my $pkg2 (@@$l) {
			    	next if $pkg eq $pkg2;
				if (!(find_a_conflict($conflicts, $deps, $pkg, $pkg2) ||
					find_a_conflict($conflicts, $deps, $pkg2, $pkg))) {
					$keepit = 1;
					last;
				}
			    }
			    if ($keepit) {
				push(@@$l2, $pkg);
			    }
			}
			$cache->{$hv} = $l2;
d133 5
a137 6
		    my $newkey = join(',', @@$result);
		    if (@@$result == 1) {
			    $newkey.="-> was ".join(',', @@$l);
		    }
		    $cache2->{$newkey} = [] unless defined($cache2->{$newkey});
		    push(@@{$cache2->{$newkey}}, $key);
d139 1
a139 2
	    }
    }
d207 2
a208 2
	    next if $pkgname eq '.' or $pkgname eq '..';
	    handle_file("$opt_d/$pkgname");
@


1.11
log
@be more specific about conflict handling: conflicts can be registered at
any level in the dependency tree, but we shouldn't mark as conflicting packages
that do depend on each other or that have common dependencies.

Issue noticed by alek@@ on plone vs. zope.
@
text
@d3 1
a3 1
# $OpenBSD: find-all-conflicts,v 1.10 2005/09/04 22:34:23 espie Exp $
d147 1
a147 1
our ($opt_d, $opt_v);
d149 1
a149 1
sub handle_file
d151 1
a151 2
	my $filename = shift;
	my $plist = OpenBSD::PackingList->fromfile($filename);
d163 34
a196 1
set_usage('find-all-conflicts [-v] [-d plist_dir] [pkgname ...]');
d198 1
a198 1
    getopts('d:v');
d203 2
a204 2
print "Scanning packages\n" if $opt_v;
print "-----------------\n" if $opt_v;
d212 2
@


1.10
log
@cache ways more information, so that it runs at a reasonable pace for
3000 packages.
output stuff in a more readable way.

allows looking only in a PLIST_DB directory.
@
text
@d3 1
a3 1
# $OpenBSD: find-all-conflicts,v 1.8 2004/11/11 15:38:02 espie Exp $
d80 1
d117 1
a117 1
				next if $pkg2 eq $pkg;
@


1.9
log
@remove duplicates, in case we're scanning the same package several times.

okay pvalchev@@
@
text
@d4 1
a4 1
# Copyright (c) 2000
d37 2
d41 2
a42 1
sub analyze 
d44 3
a46 2
	my ($plist, $all) = @@_;
	my $pkgname = $plist->pkgname();
d48 40
a87 5
	for my $item (@@{$plist->{items}}) {
		next unless $item->IsFile();
		my $file= File::Spec->canonpath($item->fullname());
		unless (defined $all->{$file}) {
			$all->{$file} = [];
d89 1
a89 1
		push @@{$all->{$file}}, $pkgname;
d91 8
d101 1
a101 1
sub show_problems
d103 1
a103 1
    my ($h, $conflicts) = @@_;
d107 1
a107 1
	    @@$l = keys %s;
d109 19
a127 7
		my $notfound = 0;
		# create a list of unconflicting packages.
		my @@l2 = ();
		for my $pkg (@@$l) {
		    next if $conflicts->{$pkg}->conflicts_with(
			    grep { $_ ne $pkg } (@@$l));
		    push(@@l2, $pkg);
d129 8
a136 2
		if (@@l2 != 0) {
		    print "$key: ", join(',', @@l2), "\n";
d145 2
d148 32
a179 3
print "Scanning packages\n";
print "-----------------\n";
if (@@ARGV==0) {
d182 1
d189 1
a189 1
	my $plist = OpenBSD::PackingList->fromfile($dir.CONTENTS);
a190 4
	$plist->forget();
	$conflicts->{$plist->pkgname()} = 
	    OpenBSD::PkgCfl->make_conflict_list($plist);
	analyze($plist, $filehash);
d195 7
a201 1
show_problems($filehash, $conflicts);
@


1.8
log
@tell all big analyzers they can forget about the packing-list.
@
text
@d3 1
a3 1
# $OpenBSD: find-all-conflicts,v 1.7 2004/02/12 13:55:45 espie Exp $
d59 2
@


1.7
log
@kill info dir asap.
@
text
@d3 1
a3 1
# $OpenBSD: find-all-conflicts,v 1.6 2003/10/23 17:49:02 espie Exp $
d92 1
@


1.6
log
@shrink by using the new perl modules.
no longer test for @@dirrm collisions, those don't matter with the new
tools.

tested by nikolay.
@
text
@d3 1
a3 1
# $OpenBSD: find-all-conflicts,v 1.5 2002/03/19 22:20:50 espie Exp $
d33 1
d91 1
@


1.5
log
@Register dirrm collisions as well.
@
text
@d3 1
a3 1
# $OpenBSD: find-all-conflicts,v 1.4 2002/03/11 22:00:37 naddy Exp $
d33 4
d38 10
a47 61
sub analyze {
	my $fh = shift;
	my $all = shift;
	my $dir = shift;
	my $conflicts = shift;
	my ($name, $cwd);
	my $default_conflict=1;
	my $conflict_list = [];
	my $basedir;
	local $_;
	while (<$fh>) {
		chomp;
		if (m/^\@@(?:newdepend|libdepend|comment|exec|unexec|mtree|src|pkgdep|mode|group|owner|display)/) {
			next; 
		} elsif (m/^\@@ignore/) {
			$_ = <$fh>;
			next;
		} elsif (m/^\@@name\s+/) {
			$name = $';
		} elsif (m/^\@@cwd\s+/) {
			my $newpath = $';
			if (File::Spec->file_name_is_absolute($newpath)) {
				$cwd = $newpath;
			} else {
				$cwd = File::Spec->catfile($cwd, $newpath);
			}
			$basedir = $cwd unless defined $basedir;
		} elsif (m/^\@@pkgcfl\s+(.*?)\s*$/) {
			my $conflict=$1;
			$conflict =~ s/\*/\.\*/g;
			$conflict =~ s/\?/\./g;
			$conflict =~ s/\+/\\\+/g;
			push @@$conflict_list, "$conflict";
		} elsif (m/^\@@option\s+no-default-conflict/) {
			$default_conflict=0;
		} elsif (m/^\@@dirrm\s+/) {
			my $d = $';
			if (!File::Spec->file_name_is_absolute($d)) {
				$d = File::Spec->catfile($basedir, $d);
			}
			$d = File::Spec->canonpath($d);
			unless (defined $dir->{$d}) {
				$dir->{$d} = [];
			}
			push @@{$dir->{$d}}, $name;
		} elsif (m/^\@@/) {
			print $_, "\n";
		} else {
			my $file= File::Spec->catfile($cwd, $_);
			$file = File::Spec->canonpath($file);
			unless (defined $all->{$file}) {
				$all->{$file} = [];
			}
			push @@{$all->{$file}}, $name;
		}
	}
	if ($default_conflict) {
		if ($name =~ m/^(.*)\-\d/) {
			push @@$conflict_list, "\Q$1\E\\-\\d.*";
		} elsif ($name =~ m/^(.*)-/) {
			push @@$conflict_list, "\Q$1\E\\-.*";
d49 1
a50 1
	$conflicts->{$name}=$conflict_list;
d55 2
a56 2
    my $h = shift;
    my $conflicts = shift;
d60 2
d63 3
a65 7
		    FOUND: for my $pkg2 (@@$l) {
			    next FOUND if $pkg2 eq $pkg;
			    for my $check (@@{$conflicts->{$pkg}}) {
				    next FOUND if ($pkg2 =~ m/^$check$/);
			    }
			    $notfound = 1;
		    }
d67 2
a68 2
		if ($notfound) {
		    print "$key: ", join(',', @@$l), "\n";
d74 1
a74 1
my %hash=();
d76 1
a76 1
my %conflicts=();
d80 4
a83 1
for my $pkgname (<*.tgz>) {
d85 8
a92 7
	system "tar zxqf $pkgname +CONTENTS";
	if (open(my $fh, '<+CONTENTS')) {
	    analyze($fh, \%hash, \%dirhash, \%conflicts);
	    unlink("+CONTENTS");
	} else {
	    warn "Problem with $pkgname";
	}
d97 1
a97 4
show_problems(\%hash, \%conflicts);
print "\@@dirrm problems:\n";
print  "---------------\n";
show_problems(\%dirhash, \%conflicts);
@


1.4
log
@skip @@libdepend
@
text
@d3 1
a3 1
# $OpenBSD: find-all-conflicts,v 1.3 2001/04/15 17:44:29 espie Exp $
d30 2
d37 1
d42 1
d46 1
a46 1
		if (m/^\@@(?:newdepend|libdepend|comment|exec|unexec|dirrm|mtree|src|pkgdep|mode|group|owner|display)/) {
d60 1
d69 10
d97 1
a97 1
	$conflicts{$name}=$conflict_list;
d100 22
d123 3
a125 2
%hash=();
%conflicts=();
d127 2
d133 1
a133 1
	    analyze($fh, \%hash, \%conflicts);
d140 6
a145 17
while (my ($key, $l) = each %hash) {
	if (@@$l > 1) {
	    my $notfound = 0;
	    for my $pkg (@@$l) {
	    	FOUND: for my $pkg2 (@@$l) {
			next FOUND if $pkg2 eq $pkg;
			for my $check (@@{$conflicts{$pkg}}) {
				next FOUND if ($pkg2 =~ m/^$check$/);
			}
			$notfound = 1;
		}
	    }
	    if ($notfound) {
		print "$key: ", join(',', @@$l), "\n";
	    }
	}
}
@


1.3
log
@Updated version, that is much better at handling pkgspecs correctly
@
text
@d3 1
a3 1
# $OpenBSD: find-all-conflicts,v 1.2 2001/03/24 15:16:53 espie Exp $
d42 1
a42 1
		if (m/^\@@(?:newdepend|comment|exec|unexec|dirrm|mtree|src|pkgdep|mode|group|owner|display)/) {
@


1.2
log
@Adjust default conflict rules to match pkg_create.
@
text
@d3 1
a3 1
# $OpenBSD: find-all-conflicts,v 1.1 2000/04/19 14:31:18 espie Exp $
d42 1
a42 1
		if (m/^\@@(?:comment|exec|unexec|dirrm|mtree|src|pkgdep|mode|group|owner|display)/) {
d57 4
a60 2
			my $conflict="\Q$1\E";
			$conflict =~ s/\\\*/\.\*/g;
d76 2
a77 2
		if ($name =~ m/^(.*)-\d/) {
			push @@$conflict_list, "\Q$1\E-\d.*";
d79 1
a79 1
			push @@$conflict_list, "\Q$1\E\-.*";
@


1.1
log
@Those are the tools we (Chris and I) use to check on packaging problems.
@
text
@d3 1
a3 1
# $OpenBSD$
d74 5
a78 2
		$name =~ m/^(.*)-\d/ or $name =~ m/^(.*)-/;
		push @@$conflict_list, "\Q$1\E\-.*";
@

