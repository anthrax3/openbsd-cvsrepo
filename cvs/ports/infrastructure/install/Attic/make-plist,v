head	1.150;
access;
symbols
	OPENBSD_4_8:1.149.0.2
	OPENBSD_4_8_BASE:1.149
	OPENBSD_4_7:1.143.0.2
	OPENBSD_4_7_BASE:1.143
	OPENBSD_4_6:1.142.0.4
	OPENBSD_4_6_BASE:1.142
	OPENBSD_4_5:1.142.0.2
	OPENBSD_4_5_BASE:1.142
	OPENBSD_4_4:1.100.0.2
	OPENBSD_4_4_BASE:1.100
	OPENBSD_4_3:1.94.0.4
	OPENBSD_4_3_BASE:1.94
	OPENBSD_4_2:1.94.0.2
	OPENBSD_4_2_BASE:1.94
	OPENBSD_4_1:1.92.0.2
	OPENBSD_4_1_BASE:1.92
	OPENBSD_4_0:1.79.0.2
	OPENBSD_4_0_BASE:1.79
	OPENBSD_3_9:1.78.0.2
	OPENBSD_3_9_BASE:1.78
	OPENBSD_3_8:1.69.0.2
	OPENBSD_3_8_BASE:1.69
	OPENBSD_3_7:1.66.0.2
	OPENBSD_3_7_BASE:1.66
	OPENBSD_3_6:1.57.0.2
	OPENBSD_3_6_BASE:1.57
	OPENBSD_3_5:1.32.0.2
	OPENBSD_3_5_BASE:1.32
	OPENBSD_3_4:1.31.0.2
	OPENBSD_3_4_BASE:1.31
	OPENBSD_3_3:1.20.0.2
	OPENBSD_3_3_BASE:1.20
	OPENBSD_3_2:1.18.0.2
	OPENBSD_3_2_BASE:1.18
	OPENBSD_3_1:1.16.0.2
	OPENBSD_3_1_BASE:1.16
	OPENBSD_3_0:1.15.0.2
	OPENBSD_3_0_BASE:1.15
	OPENBSD_2_9_TRACKING_SWITCH:1.13
	OPENBSD_2_9:1.9.0.2
	OPENBSD_2_9_BASE:1.9
	OPENBSD_2_8:1.8.0.2
	OPENBSD_2_8_BASE:1.8
	OPENBSD_2_7:1.4.0.2
	OPENBSD_2_7_BASE:1.4
	OPENBSD_2_6:1.2.0.2
	OPENBSD_2_6_BASE:1.2;
locks; strict;
comment	@# @;


1.150
date	2010.08.20.15.07.23;	author espie;	state dead;
branches;
next	1.149;

1.149
date	2010.06.28.11.24.01;	author espie;	state Exp;
branches;
next	1.148;

1.148
date	2010.06.25.12.02.18;	author espie;	state Exp;
branches;
next	1.147;

1.147
date	2010.06.20.08.22.40;	author espie;	state Exp;
branches;
next	1.146;

1.146
date	2010.06.20.07.36.38;	author espie;	state Exp;
branches;
next	1.145;

1.145
date	2010.04.26.12.00.57;	author espie;	state Exp;
branches;
next	1.144;

1.144
date	2010.04.20.21.54.40;	author espie;	state Exp;
branches;
next	1.143;

1.143
date	2009.12.08.18.15.50;	author ajacoutot;	state Exp;
branches;
next	1.142;

1.142
date	2008.12.30.13.28.20;	author espie;	state Exp;
branches;
next	1.141;

1.141
date	2008.12.27.12.44.02;	author espie;	state Exp;
branches;
next	1.140;

1.140
date	2008.11.17.11.20.44;	author sthen;	state Exp;
branches;
next	1.139;

1.139
date	2008.10.30.22.34.06;	author espie;	state Exp;
branches;
next	1.138;

1.138
date	2008.10.30.22.00.58;	author espie;	state Exp;
branches;
next	1.137;

1.137
date	2008.10.30.17.52.56;	author espie;	state Exp;
branches;
next	1.136;

1.136
date	2008.10.30.16.35.31;	author espie;	state Exp;
branches;
next	1.135;

1.135
date	2008.10.30.16.19.23;	author espie;	state Exp;
branches;
next	1.134;

1.134
date	2008.10.30.16.02.14;	author espie;	state Exp;
branches;
next	1.133;

1.133
date	2008.10.30.15.54.23;	author espie;	state Exp;
branches;
next	1.132;

1.132
date	2008.10.30.15.38.09;	author espie;	state Exp;
branches;
next	1.131;

1.131
date	2008.10.30.15.35.51;	author espie;	state Exp;
branches;
next	1.130;

1.130
date	2008.10.30.15.28.29;	author espie;	state Exp;
branches;
next	1.129;

1.129
date	2008.10.30.13.49.11;	author espie;	state Exp;
branches;
next	1.128;

1.128
date	2008.10.30.13.39.22;	author espie;	state Exp;
branches;
next	1.127;

1.127
date	2008.10.30.13.10.59;	author espie;	state Exp;
branches;
next	1.126;

1.126
date	2008.10.30.12.55.21;	author espie;	state Exp;
branches;
next	1.125;

1.125
date	2008.10.30.12.21.30;	author espie;	state Exp;
branches;
next	1.124;

1.124
date	2008.10.30.11.44.43;	author espie;	state Exp;
branches;
next	1.123;

1.123
date	2008.10.30.11.12.25;	author espie;	state Exp;
branches;
next	1.122;

1.122
date	2008.10.30.10.51.14;	author espie;	state Exp;
branches;
next	1.121;

1.121
date	2008.10.30.10.50.36;	author espie;	state Exp;
branches;
next	1.120;

1.120
date	2008.10.29.15.42.41;	author espie;	state Exp;
branches;
next	1.119;

1.119
date	2008.10.29.11.26.02;	author espie;	state Exp;
branches;
next	1.118;

1.118
date	2008.10.28.14.32.08;	author espie;	state Exp;
branches;
next	1.117;

1.117
date	2008.10.28.13.29.01;	author espie;	state Exp;
branches;
next	1.116;

1.116
date	2008.10.28.13.01.05;	author espie;	state Exp;
branches;
next	1.115;

1.115
date	2008.10.28.12.32.39;	author espie;	state Exp;
branches;
next	1.114;

1.114
date	2008.10.28.12.28.50;	author espie;	state Exp;
branches;
next	1.113;

1.113
date	2008.10.28.12.07.23;	author espie;	state Exp;
branches;
next	1.112;

1.112
date	2008.10.28.11.59.12;	author espie;	state Exp;
branches;
next	1.111;

1.111
date	2008.10.27.21.00.11;	author espie;	state Exp;
branches;
next	1.110;

1.110
date	2008.10.27.16.53.13;	author bernd;	state Exp;
branches;
next	1.109;

1.109
date	2008.10.27.13.25.35;	author espie;	state Exp;
branches;
next	1.108;

1.108
date	2008.10.27.12.18.40;	author espie;	state Exp;
branches;
next	1.107;

1.107
date	2008.10.27.11.28.12;	author espie;	state Exp;
branches;
next	1.106;

1.106
date	2008.10.27.11.19.57;	author espie;	state Exp;
branches;
next	1.105;

1.105
date	2008.10.27.11.12.01;	author espie;	state Exp;
branches;
next	1.104;

1.104
date	2008.10.27.10.33.46;	author espie;	state Exp;
branches;
next	1.103;

1.103
date	2008.10.26.16.24.22;	author espie;	state Exp;
branches;
next	1.102;

1.102
date	2008.10.26.16.02.06;	author espie;	state Exp;
branches;
next	1.101;

1.101
date	2008.10.02.18.06.37;	author espie;	state Exp;
branches;
next	1.100;

1.100
date	2008.06.18.12.11.01;	author espie;	state Exp;
branches;
next	1.99;

1.99
date	2008.06.12.09.06.52;	author bernd;	state Exp;
branches;
next	1.98;

1.98
date	2008.06.06.15.03.30;	author espie;	state Exp;
branches;
next	1.97;

1.97
date	2008.05.21.10.07.14;	author espie;	state Exp;
branches;
next	1.96;

1.96
date	2008.04.13.09.46.19;	author espie;	state Exp;
branches;
next	1.95;

1.95
date	2008.04.12.13.04.21;	author espie;	state Exp;
branches;
next	1.94;

1.94
date	2007.05.12.14.02.08;	author espie;	state Exp;
branches;
next	1.93;

1.93
date	2007.04.08.15.22.49;	author espie;	state Exp;
branches;
next	1.92;

1.92
date	2007.02.07.11.24.23;	author bernd;	state Exp;
branches;
next	1.91;

1.91
date	2007.01.12.21.53.31;	author espie;	state Exp;
branches;
next	1.90;

1.90
date	2007.01.10.01.41.29;	author espie;	state Exp;
branches;
next	1.89;

1.89
date	2007.01.09.19.40.49;	author espie;	state Exp;
branches;
next	1.88;

1.88
date	2007.01.08.18.33.37;	author espie;	state Exp;
branches;
next	1.87;

1.87
date	2006.12.19.10.03.22;	author espie;	state Exp;
branches;
next	1.86;

1.86
date	2006.12.11.17.17.25;	author espie;	state Exp;
branches;
next	1.85;

1.85
date	2006.12.11.13.51.14;	author espie;	state Exp;
branches;
next	1.84;

1.84
date	2006.12.11.13.36.06;	author espie;	state Exp;
branches;
next	1.83;

1.83
date	2006.11.20.13.56.37;	author espie;	state Exp;
branches;
next	1.82;

1.82
date	2006.11.09.08.16.22;	author espie;	state Exp;
branches;
next	1.81;

1.81
date	2006.11.06.16.35.20;	author espie;	state Exp;
branches;
next	1.80;

1.80
date	2006.10.07.10.04.09;	author espie;	state Exp;
branches;
next	1.79;

1.79
date	2006.04.03.13.53.43;	author espie;	state Exp;
branches;
next	1.78;

1.78
date	2005.12.26.19.29.34;	author bernd;	state Exp;
branches;
next	1.77;

1.77
date	2005.12.23.13.30.05;	author bernd;	state Exp;
branches;
next	1.76;

1.76
date	2005.12.23.12.48.59;	author espie;	state Exp;
branches;
next	1.75;

1.75
date	2005.11.02.21.39.43;	author espie;	state Exp;
branches;
next	1.74;

1.74
date	2005.11.02.18.58.44;	author espie;	state Exp;
branches;
next	1.73;

1.73
date	2005.10.23.10.48.39;	author espie;	state Exp;
branches;
next	1.72;

1.72
date	2005.10.18.21.05.53;	author aanriot;	state Exp;
branches;
next	1.71;

1.71
date	2005.09.07.10.40.00;	author espie;	state Exp;
branches;
next	1.70;

1.70
date	2005.09.05.13.06.01;	author espie;	state Exp;
branches;
next	1.69;

1.69
date	2005.08.10.13.09.17;	author espie;	state Exp;
branches;
next	1.68;

1.68
date	2005.07.04.10.46.05;	author espie;	state Exp;
branches;
next	1.67;

1.67
date	2005.04.11.11.39.12;	author espie;	state Exp;
branches;
next	1.66;

1.66
date	2005.02.05.11.40.31;	author espie;	state Exp;
branches;
next	1.65;

1.65
date	2004.12.27.00.00.27;	author espie;	state Exp;
branches;
next	1.64;

1.64
date	2004.11.14.19.42.04;	author espie;	state Exp;
branches;
next	1.63;

1.63
date	2004.11.13.11.49.03;	author espie;	state Exp;
branches;
next	1.62;

1.62
date	2004.11.13.11.25.31;	author espie;	state Exp;
branches;
next	1.61;

1.61
date	2004.10.23.06.51.54;	author espie;	state Exp;
branches;
next	1.60;

1.60
date	2004.10.17.09.20.06;	author espie;	state Exp;
branches;
next	1.59;

1.59
date	2004.09.18.11.03.45;	author espie;	state Exp;
branches;
next	1.58;

1.58
date	2004.09.14.22.24.39;	author espie;	state Exp;
branches;
next	1.57;

1.57
date	2004.08.11.09.40.17;	author espie;	state Exp;
branches;
next	1.56;

1.56
date	2004.08.10.21.01.01;	author espie;	state Exp;
branches;
next	1.55;

1.55
date	2004.08.10.08.45.21;	author espie;	state Exp;
branches;
next	1.54;

1.54
date	2004.08.09.12.48.56;	author espie;	state Exp;
branches;
next	1.53;

1.53
date	2004.08.09.12.41.03;	author espie;	state Exp;
branches;
next	1.52;

1.52
date	2004.08.09.12.35.45;	author espie;	state Exp;
branches;
next	1.51;

1.51
date	2004.08.09.10.24.26;	author espie;	state Exp;
branches;
next	1.50;

1.50
date	2004.08.08.18.09.04;	author espie;	state Exp;
branches;
next	1.49;

1.49
date	2004.08.08.16.43.15;	author espie;	state Exp;
branches;
next	1.48;

1.48
date	2004.08.08.14.13.41;	author espie;	state Exp;
branches;
next	1.47;

1.47
date	2004.08.07.07.47.38;	author espie;	state Exp;
branches;
next	1.46;

1.46
date	2004.08.06.10.24.19;	author espie;	state Exp;
branches;
next	1.45;

1.45
date	2004.08.06.09.37.15;	author espie;	state Exp;
branches;
next	1.44;

1.44
date	2004.08.05.23.51.44;	author espie;	state Exp;
branches;
next	1.43;

1.43
date	2004.08.05.23.43.45;	author espie;	state Exp;
branches;
next	1.42;

1.42
date	2004.08.03.11.17.11;	author espie;	state Exp;
branches;
next	1.41;

1.41
date	2004.08.03.10.51.47;	author espie;	state Exp;
branches;
next	1.40;

1.40
date	2004.08.03.10.16.58;	author espie;	state Exp;
branches;
next	1.39;

1.39
date	2004.07.22.22.24.51;	author espie;	state Exp;
branches;
next	1.38;

1.38
date	2004.07.21.11.00.38;	author espie;	state Exp;
branches;
next	1.37;

1.37
date	2004.07.20.19.01.22;	author espie;	state Exp;
branches;
next	1.36;

1.36
date	2004.07.18.22.47.44;	author espie;	state Exp;
branches;
next	1.35;

1.35
date	2004.07.03.17.50.52;	author sturm;	state Exp;
branches;
next	1.34;

1.34
date	2004.06.29.20.26.08;	author pvalchev;	state Exp;
branches;
next	1.33;

1.33
date	2004.06.29.01.28.26;	author mjc;	state Exp;
branches;
next	1.32;

1.32
date	2003.12.26.00.26.01;	author espie;	state Exp;
branches;
next	1.31;

1.31
date	2003.07.16.22.07.40;	author espie;	state Exp;
branches;
next	1.30;

1.30
date	2003.07.02.09.04.08;	author espie;	state Exp;
branches;
next	1.29;

1.29
date	2003.07.01.14.47.53;	author espie;	state Exp;
branches;
next	1.28;

1.28
date	2003.06.30.12.07.56;	author espie;	state Exp;
branches;
next	1.27;

1.27
date	2003.06.30.11.53.37;	author espie;	state Exp;
branches;
next	1.26;

1.26
date	2003.06.30.11.49.41;	author espie;	state Exp;
branches;
next	1.25;

1.25
date	2003.06.30.11.31.22;	author espie;	state Exp;
branches;
next	1.24;

1.24
date	2003.06.30.11.29.16;	author espie;	state Exp;
branches;
next	1.23;

1.23
date	2003.06.16.22.42.54;	author espie;	state Exp;
branches;
next	1.22;

1.22
date	2003.06.15.13.31.37;	author espie;	state Exp;
branches;
next	1.21;

1.21
date	2003.06.12.22.04.37;	author pvalchev;	state Exp;
branches;
next	1.20;

1.20
date	2003.01.06.20.16.21;	author espie;	state Exp;
branches;
next	1.19;

1.19
date	2002.12.23.16.07.51;	author espie;	state Exp;
branches;
next	1.18;

1.18
date	2002.04.20.19.07.25;	author espie;	state Exp;
branches;
next	1.17;

1.17
date	2002.04.15.06.38.23;	author espie;	state Exp;
branches;
next	1.16;

1.16
date	2002.04.03.15.00.30;	author espie;	state Exp;
branches;
next	1.15;

1.15
date	2001.08.23.09.13.19;	author espie;	state Exp;
branches;
next	1.14;

1.14
date	2001.08.18.13.11.10;	author espie;	state Exp;
branches;
next	1.13;

1.13
date	2001.05.24.16.47.59;	author espie;	state Exp;
branches;
next	1.12;

1.12
date	2001.05.23.14.18.25;	author espie;	state Exp;
branches;
next	1.11;

1.11
date	2001.05.07.15.25.44;	author espie;	state Exp;
branches;
next	1.10;

1.10
date	2001.05.05.21.24.27;	author espie;	state Exp;
branches;
next	1.9;

1.9
date	2001.03.24.12.14.38;	author espie;	state Exp;
branches;
next	1.8;

1.8
date	2000.07.08.18.09.10;	author espie;	state Exp;
branches;
next	1.7;

1.7
date	2000.07.08.15.13.49;	author espie;	state Exp;
branches;
next	1.6;

1.6
date	2000.07.03.13.01.49;	author espie;	state Exp;
branches;
next	1.5;

1.5
date	2000.06.30.23.45.41;	author espie;	state Exp;
branches;
next	1.4;

1.4
date	2000.04.17.21.00.56;	author espie;	state Exp;
branches
	1.4.2.1;
next	1.3;

1.3
date	2000.03.03.21.24.51;	author espie;	state Exp;
branches;
next	1.2;

1.2
date	99.07.29.14.01.12;	author espie;	state Exp;
branches;
next	1.1;

1.1
date	99.07.29.13.51.51;	author espie;	state Exp;
branches;
next	;

1.4.2.1
date	2000.09.15.04.38.07;	author marc;	state Exp;
branches;
next	;


desc
@@


1.150
log
@kill a few things which have now MOVED
@
text
@#! /usr/bin/perl
# $OpenBSD: make-plist,v 1.149 2010/06/28 11:24:01 espie Exp $
# Copyright (c) 2004-2008 Marc Espie <espie@@openbsd.org>
#
# Permission to use, copy, modify, and distribute this software for any
# purpose with or without fee is hereby granted, provided that the above
# copyright notice and this permission notice appear in all copies.
#
# THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
# ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
# OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

# TODO
# - multi-packages with inter-dependencies still are not 100% correct with
# respect to common directories.

use strict;
use warnings;

use lib $ENV{PORTSDIR}."/infrastructure/install";
use OpenBSD::PackingList;
use OpenBSD::PackingElement;
use OpenBSD::PackageLocator;
use OpenBSD::PackageInfo;
use OpenBSD::Subst;
use File::Basename;
use File::Compare;
use File::Temp;
use FS;

package OpenBSD::ReverseSubst;
our @@ISA = (qw(OpenBSD::Subst));

sub new
{
	bless {h => {}, r => [], l => {}, found => {}}, shift;
}

sub hash
{
	my $self = shift;
	return $self->{h};
}

sub value
{
	my ($self, $k) = @@_;
	return $self->{h}->{$k};
}	

sub add
{
	my ($self, $k, $v) = @@_;
	if ($k =~ m/^LIB(.*)_VERSION$/) {
		$self->{l}->{$1} = $v;
	} else {
		push(@@{$self->{r}}, $k) if $v ne '';
	}
	$k =~ s/^\^//;
	$self->{h}->{$k} = $v;
}

sub reverse
{
	my ($self, $_) = @@_;
	for my $k (@@{$self->{r}}) {
		if ($k =~ m/^\^(.*)$/) {
			my $k2 = $1;
			my $v = $self->{h}->{$k2};
			s/^\Q$v\E/\$\{\Q$k2\E\}/g;
		} else {
			my $v = $self->{h}->{$k};
			s/\Q$v\E/\$\{\Q$k\E\}/g;
		}
	}
	return $_;
}

my $first_warn = 1;
sub reverse_with_lib
{
	my ($self, $_) = @@_;
	if (m/^(.*?)lib([^\/]+)\.so\.(\d+\.\d+)$/) {
		my ($path, $name, $version) = ($1, $2, $3);
		if (!defined $self->{l}->{$name}) {
			if ($first_warn) {
				print STDERR "WARNING: unregistered shared lib(s)\n";
				$first_warn = 0;
			}
			print STDERR "SHARED_LIBS +=\t$name ", 
			    ' 'x (25-length($name)), "0.0 # $version\n";
		    $self->{l}->{$name} = $version;
		} elsif ($self->{l}->{$name} ne $version) {
			print STDERR "WARNING: version mismatch for lib: $name "
			. "($version vs. $self->{l}->{$name})\n";
		}
		$self->{found}->{$name} = 1;
		return $self->reverse("${path}lib$name.so.")."\${LIB${name}_VERSION}";
	} else {
		return $self->reverse($_);
	}
}

package main;

# Plists use variable substitution, we have to be able to do it
# both ways to recognize existing entries.

my $base;
our $subst = new OpenBSD::ReverseSubst;
my $destdir = $ENV{'DESTDIR'};
my %known_libs;

die "No $destdir" unless -d $destdir;

my %prefix;
my %plistname;
my %mtree;
my @@subs;
my $baseprefix=$ENV{PREFIX};
my $shared_only;
my $make = $ENV{MAKE};
my $portsdir = $ENV{PORTSDIR};

sub prettify
{
	my $_ = $_[0]->{filename};
	$_ =~ s/^.*\/pkg\//pkg\//;
	return $_;
}

sub report
{
	print STDERR "make-plist: ";

	for my $i (@@_) {
		if (ref $i) {
			if ($i->isa("OpenBSD::PackingElement")) {
				print STDERR $i->stringize;
			} elsif ($i->isa("OpenBSD::PackingList")) {
				print STDERR prettify($i);
			} elsif ($i->isa("FS::File")) {
				print STDERR $i->path;
			}
		} else {
			print STDERR $i;
	    	}
	}
	print STDERR "\n";
}


my $cached_tree = {};
sub build_mtree
{
	my ($sub, $deps) = @@_;
	my $mtree = {};
	# add directories from dependencies
	my $stripped = {};
	for my $pkgpath (split /\s+/, $deps) {
		next if defined $stripped->{$pkgpath};
		$stripped->{$pkgpath} = 1;
		if (!defined $cached_tree->{$pkgpath}) {
			$cached_tree->{$pkgpath} = {};
			open my $fh, "cd $portsdir && env -i SUBDIR=$pkgpath ECHO_MSG=: $make print-plist |" or die "blech\n";
			augment_mtree($cached_tree->{$pkgpath}, $fh);
			close($fh);
		}
		print STDERR "Subpackage $sub: Stripping dirs from $pkgpath\n";
		for my $e (keys %{$cached_tree->{$pkgpath}}) {
			$mtree->{$e} = 1;
		}
	}
	return $mtree;
}

sub parse_arg
{
	my $_ = shift;
	if (m/^DEPPATHS(-.*?)\=/) {
		$mtree{$1} = build_mtree($1, $');
		return;
	} 
	if (m/\=/) {
		$subst->parse_option($_);
	}
	if (m/^\^PREFIX(\-.*?)\=(.*)\/?$/) {
		$prefix{$1} = $2;
	} elsif (m/^PLIST(\-.*?)\=/) {
		$plistname{$1} = $';
	}
}

sub parse_env
{
}

sub parse_args
{
	for my $i (@@ARGV) {
		parse_arg($i);
	}
	my $multi = $ENV{'MULTI_PACKAGES'};
	# Normalize
	$multi =~ s/^\s+//;
	$multi =~ s/\s+$//;
	@@subs = split /\s+/, $multi;
	for my $sub (@@subs) {
		if (!defined $prefix{$sub} || !defined $plistname{$sub} ||
		    !defined $mtree{$sub}) {
		    	die "Incomplete information for $sub";
		}
	}
	if (defined $ENV{'SHARED_ONLY'}) {
		if ($ENV{'SHARED_ONLY'} =~ m/^Yes$/i) {
			$shared_only = 1;
		}
	}
}

sub deduce_name
{
	my ($o, $frag, $not) = @@_;

	my $noto = $o;
	my $nofrag = "no-$frag";

	$o =~ s/PFRAG\./PFRAG.$frag-/ or
	    $o =~ s/PLIST/PFRAG.$frag/;

	$noto =~ s/PFRAG\./PFRAG.no-$frag-/ or
	    $noto =~ s/PLIST/PFRAG.no-$frag/;
	if ($not) {
		return $noto;
    	} else {
		return $o;
	}
}


sub possible_subpackages
{
	my $filename= shift;

	my $l = [];
	for my $sub (@@subs) {
		if ($filename =~ m/^\Q$prefix{$sub}\E\//) {
			push @@$l, $sub;
		}
	}
	return $l;
}

# Fragments are new PackingElement unique to make-plist and pkg_create, 
# to handle %%thingy%%.
# (and so, make-plist will use a special PLIST reader)


# Method summary:
# add_to_mtree: new directory in dependent package
# add_to_haystack: put stuff so that it can be found on the FS
# copy_extra: stuff that can't be easily deduced but should be copied
# tag_along: set of items that associate themselves to this item
#   (e.g., @@exec, @@unexec, @@sample...)
# clone_tags: copy tagged stuff over.
# deduce_fragment: find fragment file name from %%stuff%%

# note $plist->{nonempty}: set as soon as a plist holds anything
# but a cvstag.

package OpenBSD::PackingElement;
sub add_to_mtree
{
}

sub add_object2
{
	my ($self, $plist) = @@_;
	$self->add_object($plist);
	$plist->{nonempty} = 1;
}

sub add_to_haystack
{
	my ($self, $plist, $haystack) = @@_;
	$self->{plist} = $plist;
}

sub register
{
}

sub copy_extra
{
}

sub tag_along
{
	my ($self, $n) = @@_;

	$self->{tags} = [] unless defined $self->{tags};
	push(@@{$self->{tags}}, $n);
}

sub deduce_fragment
{
}

sub delay_tag
{
	return 0;
}

sub clone_tags
{
	my ($self, $plist) = @@_;

	if (defined $self->{tags}) {
		for my $t (@@{$self->{tags}}) {
			my $n = $t->clone;
			if ($n->isa("OpenBSD::PackingElement::Sample") || 
			    $n->isa("OpenBSD::PackingElement::Sampledir")) {
				main::handle_modes($plist, $n, $t, undef, undef);
			}
			$n->add_object2($plist);
			if ($n->isa("OpenBSD::PackingElement::Fragment") && 
			    $n->{name} eq "SHARED") {
				$plist->{hasshared} = 1;
			}
		}
	}
}

sub copy_annotations
{
}

package OpenBSD::PackingElement::Meta;
sub copy_annotations
{
	my ($self, $plist) = @@_;
	$self->clone->add_object2($plist);
}

package OpenBSD::PackingElement::CVSTag;
sub copy_annotations
{
	my ($self, $plist) = @@_;
	$self->clone->add_object($plist);
}

package OpenBSD::PackingElement::NewAuth;
sub copy_annotations
{
	&OpenBSD::PackingElement::Meta::copy_annotations;
}

package OpenBSD::PackingElement::SpecialFile;
sub copy_annotations
{
}

package OpenBSD::PackingElement::Fragment;
our @@ISA=qw(OpenBSD::PackingElement);
sub register
{
	my ($self, $plist) = @@_;

	$plist->{state}->{lastreal}->tag_along($self);
}

sub deduce_fragment
{
	my ($self, $o) = @@_;

	my $frag = $self->{name};
	return if $frag eq "SHARED";

	$o =~ s/PFRAG\./PFRAG.$frag-/ or
	    $o =~ s/PLIST/PFRAG.$frag/;

	return $o if -e $o;
}

sub needs_keyword() { 0 }

sub stringize
{
	return '%%'.shift->{name}.'%%';
}

package OpenBSD::PackingElement::NoFragment;
our @@ISA=qw(OpenBSD::PackingElement::Fragment);

sub deduce_fragment
{
	my ($self, $noto) = @@_;
	my $frag = $self->{name};
	return if $frag eq "SHARED";

	$noto =~ s/PFRAG\./PFRAG.no-$frag-/ or
	    $noto =~ s/PLIST/PFRAG.no-$frag/;
	return $noto if -e $noto;
}

sub stringize
{
	return '!%%'.shift->{name}.'%%';
}

package OpenBSD::PackingElement::Owner;
sub add_to_haystack
{
	my ($self, $plist, $haystack) = @@_;

	$self->SUPER::add_to_haystack($plist, $haystack);
	push(@@{$haystack->{$main::subst->do($self->{name})}}, $self);
}

package OpenBSD::PackingElement::Group;
sub add_to_haystack
{
	&OpenBSD::PackingElement::Owner::add_to_haystack;
}

package OpenBSD::PackingElement::FileObject;
sub add_to_haystack
{
	my ($self, $plist, $haystack) = @@_;

	$self->SUPER::add_to_haystack($plist, $haystack);
	push(@@{$haystack->{$main::subst->do($self->fullname)}}, $self);
}

package OpenBSD::PackingElement::FileBase;
sub register
{
	my ($self, $plist) = @@_;
	$plist->{state}->{lastobject} = $self;
	if (defined $self->{accounted_for}) {
		$plist->{state}->{lastreal} = $self;
	}
}

package OpenBSD::PackingElement::Dir;
sub register
{
	my ($self, $plist) = @@_;
	$plist->{state}->{lastobject} = $self;
	if (defined $self->{accounted_for}) {
		$plist->{state}->{lastreal} = $self;
	}
}

package OpenBSD::PackingElement::Sample;
sub register
{
	my ($self, $plist) = @@_;
	if (defined $self->{copyfrom}) {
		if (!defined $self->{copyfrom}->{accounted_for}) {
			main::report $plist, ": sample ", $self, 
				" no longer refers to anything";
		}
		$self->{copyfrom}->tag_along($self);
	} else {
		main::report $plist, ": bogus sample ", $self, 
			" (unattached) detected";
	}
}

package OpenBSD::PackingElement::Sysctl;
sub register
{
	my ($self, $plist) = @@_;

	$plist->{state}->{lastreal}->tag_along($self);
}

package OpenBSD::PackingElement::ExeclikeAction;
sub pseudo_expand
{
	my ($_, $item) = @@_;
	if (m/\%F/o) {
		return "XXXX" unless defined $item;
		s/\%F/$item->{name}/g;
	}
	if (m/\%D/o) {
		return "XXXX" unless defined $item;
		s/\%D/$item->cwd/ge;
	}
	if (m/\%B/o) {
		return "XXXX" unless defined $item;
		s/\%B/dirname($item->fullname)/ge;
	}
	if (m/\%f/o) {
		return "XXXX" unless defined $item;
		s/\%f/basename($item->fullname)/ge;
	}
	return $_;
}

sub delay_tag
{
	my $self = shift;
	if (m/\%[fF]/o) {
		return 0;
	}
	if (m/\%[BD]/o) {
		return 1;
	}
	return 0;
}

sub register
{
	my ($self, $plist) = @@_;
	if (!defined $plist->{state}->{lastobject} ||
	    $plist->{state}->{lastobject} != $plist->{state}->{lastreal}) {
		my $f1 = pseudo_expand($self->{name}, 
		    $plist->{state}->{lastobject});
		my $f2 = pseudo_expand($self->{name}, 
		    $plist->{state}->{lastreal});
		if ($f1 ne $f2) {
			main::report " orphaned \@@", $self->keyword, " ", $self,
			    " in ", $plist;
			return;
		}
	}
	$plist->{state}->{lastreal}->tag_along($self);
}

package OpenBSD::PackingElement::Sampledir;
sub register
{
	my ($self, $plist) = @@_;
	$plist->{state}->{lastreal}->tag_along($self);
}

package OpenBSD::PackingElement::DirlikeObject;
sub add_to_mtree
{
	my ($self, $mtree) = @@_;

	$mtree->{$self->fullname} = 1;
}

package OpenBSD::PackingElement::Comment;
sub cwd
{
	my $self = shift;
	if (!defined $self->{cwd}) {
		die "Update your pkg_add!!!\n";
	}
	return ${$self->{cwd}};
}

sub add_this_name_to_haystack
{
	my ($self, $name, $haystack) = @@_;

	my $fullname = File::Spec->canonpath($name);
	if ($fullname !~ m|^/|o && $self->cwd ne '.') {
		$fullname = $self->cwd."/".$fullname;
	}
	my $n = $main::subst->do($fullname);
	push(@@{$haystack->{$n}}, $self);
}

sub add_to_haystack
{
	my ($self, $plist, $haystack) = @@_;

	$self->SUPER::add_to_haystack($plist, $haystack);
	$self->add_this_name_to_haystack($self->{name}, $haystack);
	if ($self->{name} =~ m/^\@@\S+\s*(.*)$/o) {
		$self->add_this_name_to_haystack($1, $haystack);
	}
}

sub copy_annotations
{
}

sub register
{
	my ($self, $plist) = @@_;
	# comments which are not files will `tag along' more or less...
	if (!defined $self->{accounted_for}) {
		main::report "comment \"", $self, "\" position in ", $plist, 
		    " guessed";
		$plist->{state}->{lastreal}->tag_along($self);
	}
}

package OpenBSD::PackingElement::Extra;
sub copy_extra
{
	my ($self, $plist) = @@_;

	if ($self->cwd ne $plist->{state}->cwd) {
	    OpenBSD::PackingElement::Cwd->add($plist, $self->cwd);
	}
	$self->clone->add_object2($plist);
}

package main;

# add dependent package directories to the set of directories that don't
# need registration.

sub augment_mtree
{
	my ($mtree, $fh) = @@_;
	my $plist = OpenBSD::PackingList->read($fh, \&OpenBSD::PackingList::SharedItemsOnly) or die "couldn't read packing-list\n";
	$plist->add_to_mtree($mtree);
}

my $haystack = {};

# Basic packing-list with a known prefix
sub create_packinglist
{
	my ($filename, $sub) = @@_;

	my $prefix = $prefix{$sub};
	my $plist = new OpenBSD::PackingList;
	$plist->{filename} = $filename;
	$plist->{mtree} = $mtree{$sub};
	$plist->{state}->set_cwd($prefix);
	$prefix.='/' unless $prefix =~ m|/$|;
	$plist->{stripprefix} = $prefix;
	return $plist;
}

# grab original packing list, killing some stuff that is no longer needed.
sub parse_original_plist
{
    my ($name, $sub, $all_plists) = @@_;
    my $plist = create_packinglist($name, $sub);
    # special reader for fragments
    $plist->fromfile($name, 
	sub {
	    my ($fh, $cont) = @@_;
	    my $_;
	    while (<$fh>) {
		    if (m/^\%\%(.*)\%\%$/) {
		    	OpenBSD::PackingElement::Fragment->add($plist, $1);
		    } elsif (m/^\!\%\%(.*)\%\%$/) {
		    	OpenBSD::PackingElement::NoFragment->add($plist, $1);
		    } else {
			    &$cont($_);
		    }
	    }
	}
    ) or return;

    $plist->add_to_haystack($plist, $haystack);
    # Try to handle fragments
    for my $item (@@{$plist->{items}}) {
	    my $fragname = $item->deduce_fragment($name);
	    next unless defined $fragname;
	    my $pfrag = create_packinglist($fragname, $sub);
	    $pfrag->{isfrag} = 1;
	    push(@@$all_plists, $pfrag);
	    my $origpfrag = parse_original_plist($fragname, $sub, $all_plists);
	    replaces($origpfrag, $pfrag);
    }
    return $plist;
}
	
# link original and new plist
sub replaces
{
	my ($orig, $n) = @@_;
	if (defined $orig) {
		$n->{original} = $orig;
		$orig->{replacement} = $n;
		$n->{filename} = $orig->{filename};
	}
}

sub grab_all_lists
{
	my $l = [];
	for my $sub (@@subs) {
		my $o;
		my $n = create_packinglist($plistname{$sub}, $sub);
		push(@@$l, $n);
		$o = parse_original_plist($plistname{$sub}, $sub, $l);
		replaces($o, $n);
		my $frag = deduce_name($plistname{$sub}, "shared", 0);
		my $ns = create_packinglist($frag, $sub);
		$n->{shared} = $ns;
		$o = parse_original_plist($frag, $sub, $l);
		replaces($o, $ns);
		push(@@$l, $ns);
	}
	return @@$l;
}

# new object according to type, just copy over some stuff for now
sub create_object
{
	my ($type, $short, $item) = @@_;

	if (defined $item && $item->isa("OpenBSD::PackingElement::Comment")) {
		return $item->clone;
	}
	if ($type eq "directory") {
		if (defined $item) {
			if ($item->isa("OpenBSD::PackingElement::Mandir")) {
			    return OpenBSD::PackingElement::Mandir->new($short);
			} elsif ($item->isa("OpenBSD::PackingElement::Fontdir")) {
			    return OpenBSD::PackingElement::Fontdir->new($short);
			}
		}
		return OpenBSD::PackingElement::Dir->new($short);
	} elsif ($type eq "manpage") {
		return OpenBSD::PackingElement::Manpage->new($short);
	} elsif ($type eq "dir" || $type eq "subinfo") {
		return undef;
	} elsif ($type eq "info") {
		return OpenBSD::PackingElement::InfoFile->new($short);
	} elsif ($type eq "library") {
		return OpenBSD::PackingElement::Lib->new($short);
	} elsif ($type eq "binary") {
		if (defined $item && $item->isa("OpenBSD::PackingElement::Shell")) {
			return OpenBSD::PackingElement::Shell->new($short);
		} else {
			return OpenBSD::PackingElement::Binary->new($short);
		}
	} else {
		if (defined $item) {
			if ($item->isa("OpenBSD::PackingElement::Shell")) {
				return OpenBSD::PackingElement::Shell->new($short);
		    	}
		}
		return OpenBSD::PackingElement::File->new($short);
	}
}

# `restate' packing-list according to current mode settings.
# for now, we copy over stuff from old items.
sub handle_modes
{
	my ($plist, $item, $o, $file, $haystack) = @@_;
	my ($mode, $owner, $group) = ('', '', '');

	if (defined $item) {
		if (defined $item->{nochecksum}) {
			$o->{nochecksum} = 1;
		}
		if (defined $item->{ignore}) {
			$o->{ignore} = 1;
		}
		if (defined $item->{mode}) {
			$mode = $item->{mode};
		}
		if (defined $item->{owner}) {
			$owner = $item->{owner};
		}
		if (defined $item->{group}) {
			$group = $item->{group};
		}
	}
	if (defined $file) {
	    if (defined $haystack->{$file->owner}) {
		for my $o (@@{$haystack->{$file->owner}}) {
		    if ($o->isa("OpenBSD::PackingElement::Owner")) {
			if ($owner ne '') {
			    if ($subst->do($owner) eq $file->owner) {
				last;
			    } else {
				report "owner mismatch for ", 
				    $file, " ($owner vs. ", 
				    $file->owner, ")";
			    }
			} else {
			    # don't bother copying root for non special modes.
			    if ($mode eq '' && $file->owner eq 'root') {
			    	next;
			    }
			    $owner = $o->{name};
			}
		    }
		}
	    }
	    if (defined $haystack->{$file->group}) {
		for my $g (@@{$haystack->{$file->group}}) {
		    if ($g->isa("OpenBSD::PackingElement::Group")) {
			if ($group ne '') {
			    if ($subst->do($group) eq $file->group) {
				last;
			    } else {
				report "group mismatch for ", 
				    $file, " ($group vs. ", 
				    $file->group, ")";
			    }
			} else {
			    $group = $g->{name};
			}
		    }
		}
	    }
	}

	# check whether there's a state change
	my ($oldmode, $oldowner, $oldgroup) = ($plist->{state}->{mode}, 
	    $plist->{state}->{owner}, $plist->{state}->{group});
	$oldmode = '' unless defined $oldmode;

	$oldowner = '' unless defined $oldowner;
	$oldgroup = '' unless defined $oldgroup;
	if ($mode ne $oldmode) {
		OpenBSD::PackingElement::Mode->add($plist, $mode);
	}
	if ($owner ne $oldowner) {
		OpenBSD::PackingElement::Owner->add($plist, $owner);
	}
	if ($group ne $oldgroup) {
		OpenBSD::PackingElement::Group->add($plist, $group);
	}
}

sub short_name
{
	my ($file, $plist) = @@_;

	my $short = $file->path;
	my $base = $plist->{stripprefix};
	if ($short =~ m/^\Q$base\E/) {
		$short = $';
		$short = '/' if $short eq '';
	} else {
		return undef;
	}
	if ($file->type eq 'directory') {
		$short.='/';
	}

	if ($file->type eq 'library') {
		$short = $subst->reverse_with_lib($short);
	} else {
		$short = $subst->reverse($short);
	}
	# If the resulting name is arch-dependent, we warn.
	# We don't fix it automatically, as this may need special handling.
	if ($short =~ m/i386|m68k|sparc|amd64|x86[-_]64|powerpc|macppc/) {
	    report $plist, " may contain arch-dependent\n\t$short"; 
	}
	return $short;
}

sub bad_files
{
	my ($short, $plist) = @@_;

	if ($short =~ /\.orig$/) {
		report $plist, " may contain patched file\n\t$short";
	}
	if ($short =~ /\/\.[^\/]*\.swp$/) {
		report $plist, " may contain vim swap file\n\t$short";
	}
	if ($short =~ /\~$/) {
		report $plist, " may contain emacs temp file\n\t$short";
	}
}

# find out where a file belongs, and insert all corresponding things
# into the right packing-list.
sub handle_file
{
	my ($file, $haystack, $allplists, $shared_only) = @@_;

	my $foundit;
	if (defined $haystack->{$file->path}) {
	    for my $item (@@{$haystack->{$file->path}}) {
	    	next if $item->isa("OpenBSD::PackingElement::State");
		my $p = $item->{plist}->{replacement};
		if ($file->type eq 'directory' && 
		    $p->{mtree}->{$file->path}) {
			next;
		}
		if ($item->isa("OpenBSD::PackingElement::Sampledir")) {
		    # XXX Don't copy this over, it's supposed to tag along
		    return;
		}
		my $short = short_name($file, $p);
		if (!defined $short) {
			print STDERR $file->path, " does not belong\n";
			return;
		}
		my $o = create_object($file->type, $short, $item);
		if (!defined $o) {
		    next;
		}
		$foundit = $item;
		if ($o->can("compute_modes")) {
			handle_modes($p, $item, $o, $file, $haystack);
		}
		$o->add_object2($p);

		# Copy properties from source item
		$item->clone_tags($p);
	    }
	}
	if (defined $foundit) {
		return;
	}

	# Try to find a directory that `works'
	my $dir = $file->path;
	while (($dir = dirname($dir)) ne '/') {
		if (defined $haystack->{$dir} && @@{$haystack->{$dir}} eq 1) {
			my $item = $haystack->{$dir}[0];
			next if $item->isa("OpenBSD::PackingElement::Sampledir");
			my $p = $item->{plist}->{replacement};
			if ($file->type eq 'directory' && 
			    $p->{mtree}->{$file->path}) {
				next;
			}
			my $short = short_name($file, $p);
			my $o = create_object($file->type, $short, undef);
			if (!defined $o) {
			    next;
		    	}
			bad_files($short, $p);
			if (($file->type eq 'library' || $file->type eq 'plugin') && !$shared_only) {
				if (defined $p->{shared}) {
				    $p->{wantshared} = 1;
				    $p = $p->{shared};
			    	}
			}
			if ($o->can("compute_modes")) {
				handle_modes($p, undef, $o, $file, $haystack);
			}
			$o->add_object2($p);
			return;
		}
	}


	my $short;
	my $p;
	my $default = $allplists->[0];

	my $possible = possible_subpackages($file->path);
	if (@@$possible == 0) {
		report "Bogus element outside of every prefix: ", $file;
		return;
	}
	# look for the first matching prefix in plist to produce an entry
	for my $try (@@$allplists) {
		if ($file->type eq 'directory' and 
		    $try->{mtree}->{$file->path}) {
			next;
		}
		$short = short_name($file, $try);
		if (defined $short) {
			$p = $try;
			if ($p ne $default) {
				report "Element ", $file, " going to ", $p, 
				    " based on prefix";
			}
			last;
		}
	}
				
	if (!defined $p) {
		return;
	}

	my $o = create_object($file->type, $short, undef);
	return unless defined $o;

	bad_files($short, $p);
	if (($file->type eq 'library' || $file->type eq 'plugin') && !$shared_only) {
		$p->{wantshared} = 1;
		$p = $p->{shared};
	}
	handle_modes($p, undef, $o, $file, $haystack);
	$o->add_object2($p);
}

sub scan_for_files
{
	my ($file, $haystack) = @@_;

	if (defined $haystack->{$file->path}) {
	    for my $item (@@{$haystack->{$file->path}}) {
	    	next if $item->isa("OpenBSD::PackingElement::State");
		my $p = $item->{plist}->{replacement};
		if ($file->type eq 'directory' && 
		    $p->{mtree}->{$file->path}) {
		    	report "Found out old directory in ", $p, 
			    ": ", $file, " (mtree)\n";
			next;
		}
		$item->{accounted_for} = 1;
		return;
	    }
	}
}

# THIS IS WHERE THE MAIN PROGRAM STARTS

parse_args();

print "Scanning destdir\n";
my $files = FS::get_files($destdir);

print "Getting old lists\n";
my @@l = grab_all_lists();

print "1st pass identifying files\n";
for my $i (sort keys %$files) {
	scan_for_files($files->{$i}, $haystack);
}

print "Attaching annotations\n";
for my $plist (@@l) {
	my $orig = $plist->{original};
	if (defined $orig) {
		delete $orig->{state}->{lastobject};
		# place holder for extra stuff that comes before any file
		my $orphans = new OpenBSD::PackingElement::Object('');
		$orphans->{cwd} = $plist->{state}->{cwd};
		$orig->{state}->{lastreal} = $orphans;
		$orig->register($orig);
		$orig->copy_annotations($plist);
		$orphans->clone_tags($plist);
	}
	if (!$plist->has('cvstags')) {
	    OpenBSD::PackingElement::CVSTag->add($plist, '$OpenBSD'.'$');
	}
}

print "Sorting out destdir files\n";
for my $i (sort keys %$files) {
	handle_file($files->{$i}, $haystack, \@@l, $shared_only);
}

# Copy extra stuff
for my $plist (@@l) {
	my $orig = $plist->{original};
	next unless defined $orig;
	for my $i (@@{$orig->{items}}) {
		$i->copy_extra($plist);
	}
}

my $default = $l[0];
if (($default->{wantshared} || (defined $default->{shared}) && $default->{shared}->{nonempty}) && !$default->{hasshared}) {
	unshift(@@{$default->{items}}, OpenBSD::PackingElement::Fragment->new("SHARED"));
	$default->{nonempty} = 1;
}

# write new info over, as joe user.
# first we write out everything in /tmp
# then we signal if something changed
# if that's the case, we die if orig files exist, or we copy stuff over.

{
	local ($), $>);

	if (defined $ENV{'GROUP'}) {
		$) = $ENV{'GROUP'};
	}
	if (defined $ENV{'OWNER'}) {
		$> = $ENV{'OWNER'};
	}
	
	my $dir = File::Temp::tempdir ( CLEANUP => 1);
	$dir.='/';

	# write out everything
	for my $plist (@@l) {
		if (!$plist->{nonempty}) {
			next;
		}
		$plist->tofile($dir.basename($plist->{filename}));
	}

	my $something_changed = 0;
	for my $plist (@@l) {
		my $orig = $plist->{original};
		if ($plist->{nonempty}) {
			if (defined $orig) {
				if (compare($dir.basename($plist->{filename}), $orig->{filename}) != 0) {
					print prettify($plist), " changed\n";
					$something_changed = 1;
					$plist->{changed} = 1;
				}
			} else {
				print prettify($plist), " is new\n";
				$something_changed = 1;
				$plist->{changed} = 1;
			}
		} else {
			if (defined $orig) {
				if ($plist->{isfrag}) {
					print prettify($plist), " empty fragment: NOT writing it\n";
				} else {
					print prettify($plist), " empty\n";
					$something_changed = 1;
					$plist->{changed} = 1;
				}
			}
		}
	}

	my $letsdie = 0;
	if ($something_changed) {
		for my $plist (@@l) {
			my $orig = $plist->{original};
			if (defined $orig) {
				if (-e $orig->{filename}.".orig") {
				    print prettify($orig),".orig present\n";
				    $letsdie = 1;
				}
			}
		}
	}
	if ($letsdie) {
		exit(1);
	}
	for my $plist (@@l) {
		my $orig = $plist->{original};
		if ($plist->{changed}) {

			if (defined $orig) {
				rename($orig->{filename}, $orig->{filename}.".orig") or 
				    die "Can't rename file ", prettify($orig), 
				    	"\n";
			}
			$plist->tofile($plist->{filename}) or 
			    die "Can't write plist: ", prettify($plist), "\n";
		}
	}
}

# and rechecking libraries
for my $name (sort keys %{$subst->{l}}) {
	next if $subst->{found}{$name};
	print STDERR "WARNING: didn't find any library to match SHARED_LIBS $name\n";
}
@


1.149
log
@output stuff closer to what's needed for Makefiles...
@
text
@d2 1
a2 1
# $OpenBSD: make-plist,v 1.148 2010/06/25 12:02:18 espie Exp $
@


1.148
log
@work-around: if we don't get a shortname, tell the user something is a bit
too wrong, and return instead of building bogus things.
(I don't see how this ends up in haystack, though).

as noticed by sthen@@ on tomcat/v6
@
text
@d2 1
a2 1
# $OpenBSD: make-plist,v 1.147 2010/06/20 08:22:40 espie Exp $
d83 1
d90 6
a95 2
			print STDERR "WARNING: unregistered shared lib: $name "
			. "(version: $version)\n";
@


1.147
log
@less confusing
@
text
@d2 1
a2 1
# $OpenBSD: make-plist,v 1.146 2010/06/20 07:36:38 espie Exp $
d888 4
@


1.146
log
@also note WHICH libraries we did not find and warn about them,
so that one can clean up SHARED_LIBS eventually...
@
text
@d2 1
a2 1
# $OpenBSD: make-plist,v 1.145 2010/04/26 12:00:57 espie Exp $
d1140 1
a1140 1
	print STDERR "WARNING: didn't find $name library\n";
@


1.145
log
@make sure $orphans object has a valid cwd, this time fixes jasper@@ (and aja@@)
bug for good.
@
text
@d2 1
a2 1
# $OpenBSD: make-plist,v 1.144 2010/04/20 21:54:40 espie Exp $
d40 1
a40 1
	bless {h => {}, r => [], l => {}}, shift;
d96 1
d1135 6
@


1.144
log
@handle orphans correctly, as noticed by jasper.
@
text
@d2 1
a2 1
# $OpenBSD: make-plist,v 1.143 2009/12/08 18:15:50 ajacoutot Exp $
d1021 1
@


1.143
log
@s/contains/may contain/

"if it pleases you ;)" espie@@
@
text
@d2 1
a2 1
# $OpenBSD: make-plist,v 1.142 2008/12/30 13:28:20 espie Exp $
d522 1
a522 1
			main::report " orphaned \@@", $self->keyword, $self,
d1020 1
a1020 1
		my $orphans = new OpenBSD::PackingElement('');
@


1.142
log
@cheat a bit when registering comments...
@
text
@d2 1
a2 1
# $OpenBSD: make-plist,v 1.141 2008/12/27 12:44:02 espie Exp $
d847 1
a847 1
	    report $plist, " contains arch-dependent\n\t$short"; 
@


1.141
log
@have to forego copying directories in the haystack case as well

as noticed by ajacoutot@@
@
text
@d2 1
a2 1
# $OpenBSD: make-plist,v 1.140 2008/11/17 11:20:44 sthen Exp $
d555 1
a555 1
sub add_to_haystack
d557 1
a557 1
	my ($self, $plist, $haystack) = @@_;
d559 1
a559 2
	$self->SUPER::add_to_haystack($plist, $haystack);
	my $fullname = File::Spec->canonpath($self->{name});
d567 11
d705 1
a705 1
		return OpenBSD::PackingElement::Comment->new($short);
a873 1
	my $default = $allplists->[0];
d939 1
@


1.140
log
@We already warn about some arch-dependent files found in the
PLIST; add a few more architectures to this check, notably amd64
(including x86-64 and x86_64 often found in autoconf-based software).
Arch with short names less common as a primary ports developer
platform are deliberately not included to avoid bogus warnings.

ok espie@@
@
text
@d2 1
a2 1
# $OpenBSD: make-plist,v 1.139 2008/10/30 22:34:06 espie Exp $
d903 4
@


1.139
log
@okay, directories are not 100% yet...
@
text
@d2 1
a2 1
# $OpenBSD: make-plist,v 1.138 2008/10/30 22:00:58 espie Exp $
d836 1
a836 1
	if ($short =~ m/i386|m68k|sparc/) {
@


1.138
log
@fix the reversesubst bug. In retrospect, it's obvious...
add a few print's for large ports where you wait forever...
@
text
@d2 1
a2 1
# $OpenBSD: make-plist,v 1.137 2008/10/30 17:52:56 espie Exp $
d18 2
a19 3
# - multi-packages with inter-dependencies incorrectly strip dirs
# (need to strip dirs in a smarter way ???)
# - sample dir/ gets added at the wrong location.
@


1.137
log
@if item does not exist, don't check whether it's a shell.
@
text
@d2 1
a2 1
# $OpenBSD: make-plist,v 1.136 2008/10/30 16:35:31 espie Exp $
d73 3
a75 3
			$k = $1;
			my $v = $self->{h}->{$k};
			s/^\Q$v\E/\$\{\Q$k\E\}/g;
d990 1
d993 1
d996 1
d1001 1
d1018 1
@


1.136
log
@shorter message
@
text
@d2 1
a2 1
# $OpenBSD: make-plist,v 1.135 2008/10/30 16:19:23 espie Exp $
d716 1
a716 1
		if ($item->isa("OpenBSD::PackingElement::Shell")) {
@


1.135
log
@don't annotate stuff with @@owner root unless there are mode thingies around.
@
text
@d2 1
a2 1
# $OpenBSD: make-plist,v 1.134 2008/10/30 16:02:14 espie Exp $
d763 1
a763 1
				report "File owner does not match for ", 
d784 1
a784 1
				report "File group does not match for ", 
@


1.134
log
@write out simpler packing list filenames all the time
@
text
@d2 1
a2 1
# $OpenBSD: make-plist,v 1.133 2008/10/30 15:54:23 espie Exp $
d768 4
@


1.133
log
@move stuff around
@
text
@d2 1
a2 1
# $OpenBSD: make-plist,v 1.132 2008/10/30 15:38:09 espie Exp $
d124 6
d140 1
a140 3
				my $fname = $i->{filename};
				$fname =~ s/^.*\/pkg\///;
				print STDERR $fname;
d578 2
a579 1
		main::report "comment ", $self, " position in ", $plist, " guessed";
d1061 1
a1061 1
					print $plist->{filename}, " changed\n";
d1066 1
a1066 1
				print $plist->{filename}, " is new\n";
d1073 1
a1073 1
					print $plist->{filename}, " empty fragment: NOT writing it\n";
d1075 1
a1075 1
					print $plist->{filename}, " empty\n";
d1089 1
a1089 1
				    print $orig->{filename}.".orig present\n";
d1104 2
a1105 1
				    die "Can't rename file ", $orig->{filename}, "\n";
d1108 1
a1108 1
			    die "Can't write plist: ", $plist->{filename}, "\n";
@


1.132
log
@okay, just make sure the short name is / terminated, so we back-subst as much as we can in comments as well.
@
text
@d2 1
a2 1
# $OpenBSD: make-plist,v 1.131 2008/10/30 15:35:51 espie Exp $
a731 5
	my ($oldmode, $oldowner, $oldgroup) = ($plist->{state}->{mode}, $plist->{state}->{owner}, $plist->{state}->{group});
	$oldmode = '' unless defined $oldmode;

	$oldowner = '' unless defined $oldowner;
	$oldgroup = '' unless defined $oldgroup;
d755 1
a755 1
			    if ($main::subst->do($owner) eq $file->owner) {
d772 1
a772 1
			    if ($main::subst->do($group) eq $file->group) {
d786 8
@


1.131
log
@use stringize to keep comments as they are...
@
text
@d2 1
a2 1
# $OpenBSD: make-plist,v 1.130 2008/10/30 15:28:29 espie Exp $
d691 1
a691 1
		return OpenBSD::PackingElement::Comment->new($item->stringize);
d813 3
@


1.130
log
@restore newauth stuff to working status
@
text
@d2 1
a2 1
# $OpenBSD: make-plist,v 1.129 2008/10/30 13:49:11 espie Exp $
d691 1
a691 1
		return OpenBSD::PackingElement::Comment->new($short);
@


1.129
log
@slight refactor. might be able to move @@exec to end of directories when
needed eventually...
@
text
@d2 1
a2 1
# $OpenBSD: make-plist,v 1.128 2008/10/30 13:39:22 espie Exp $
d350 1
a350 1
	&OpenBSD::PackingElement::Meta;
@


1.128
log
@try to put comments more or less where they belong
@
text
@d2 1
a2 1
# $OpenBSD: make-plist,v 1.127 2008/10/30 13:10:59 espie Exp $
d304 5
d497 12
d512 9
a520 3
	if (defined $plist->{state}->{lastobject}) {
		if ($plist->{state}->{lastobject} == $plist->{state}->{lastreal}) {
			$plist->{state}->{lastobject}->tag_along($self);
d524 1
a524 8
	my $f1 = pseudo_expand($self->{name}, $plist->{state}->{lastobject});
	my $f2 = pseudo_expand($self->{name}, $plist->{state}->{lastreal});
	if ($f1 eq $f2) {
		$plist->{state}->{lastreal}->tag_along($self);
	} else {
		main::report " orphaned \@@", $self->keyword, $self,
			" in ", $plist;
	}
@


1.127
log
@start doing sensible stuff with sampledir
@
text
@d2 1
a2 1
# $OpenBSD: make-plist,v 1.126 2008/10/30 12:55:21 espie Exp $
d551 10
@


1.126
log
@fuzzy matching for @@exec stuff
@
text
@d2 1
a2 1
# $OpenBSD: make-plist,v 1.125 2008/10/30 12:21:30 espie Exp $
d312 1
a312 1
			    $n->isa("OpenBSD::PackingElement::SampleDir")) {
d833 4
d860 3
a862 1
			my $p = $haystack->{$dir}[0]->{plist}->{replacement};
@


1.125
log
@clean-up some more
@
text
@d2 1
a2 1
# $OpenBSD: make-plist,v 1.124 2008/10/30 11:44:43 espie Exp $
d470 22
a494 1
	# XXX to be revisited
d496 12
a507 3
	    $plist->{state}->{lastobject}->tag_along($self);
    	} else {
	    $plist->{lastreal}->tag_along($self);
a561 13
}

package OpenBSD::PackingElement::ExtraUnexec;
sub copy_extra
{
	my ($self, $plist) = @@_;

	# don't try to deal with cwd issues
	$self->clone->add_object2($plist);
}

sub register
{
@


1.124
log
@standardized error messages
@
text
@d2 1
a2 1
# $OpenBSD: make-plist,v 1.123 2008/10/30 11:12:25 espie Exp $
d271 7
d315 1
a315 2
			$n->add_object($plist);
			$plist->{nonempty} = 1;
d328 1
a328 1
package OpenBSD::PackingElement::CVSTag;
d332 1
a332 1
	$self->clone->add_object($plist);
d335 1
a335 1
package OpenBSD::PackingElement::NoDefaultConflict;
a339 7
	$plist->{nonempty} = 1;
}

package OpenBSD::PackingElement::Conflict;
sub copy_annotations
{
	&OpenBSD::PackingElement::NoDefaultConflict::copy_annotations;
d345 1
a345 1
	&OpenBSD::PackingElement::NoDefaultConflict::copy_annotations;
d348 1
a348 1
package OpenBSD::PackingElement::PkgPath;
a350 13
	&OpenBSD::PackingElement::NoDefaultConflict::copy_annotations;
}

package OpenBSD::PackingElement::Incompatibility;
sub copy_annotations
{
	&OpenBSD::PackingElement::NoDefaultConflict::copy_annotations;
}

package OpenBSD::PackingElement::UpdateSet;
sub copy_annotations
{
	&OpenBSD::PackingElement::NoDefaultConflict::copy_annotations;
d519 4
d531 1
a531 2
	$self->clone->add_object($plist);
	$plist->{nonempty} = 1;
d540 1
a540 2
	$self->clone->add_object($plist);
	$plist->{nonempty} = 1;
d825 1
a825 3
		$o->add_object($p);
		$item->{accounted_for} = $o;
		$p->{nonempty} = 1;
d855 1
a855 2
			$o->add_object($p);
			$p->{nonempty} = 1;
d899 1
a899 2
	$o->add_object($p);
	$p->{nonempty} = 1;
@


1.123
log
@copy things later: first pass just finds existing things in the plist,
then we try to register extra shit to the `nearest' item, and then we
populate the new plist.

also integrate shell marker fix from okan@@ (forgot about that)
@
text
@d2 1
a2 1
# $OpenBSD: make-plist,v 1.122 2008/10/30 10:51:14 espie Exp $
a114 1

d125 23
d465 2
a466 2
			print "Sample ", $self->stringize, 
			    " no longer refers to anything\n";
d470 2
a471 2
		print "Bogus sample (unattached) detected ", $self->stringize, 
		    "\n";
d732 3
a734 3
				print "File owner does not match for ", 
				    $file->path, " ($owner vs. ", 
				    $file->owner, ")\n";
d749 3
a751 3
				print "File group does not match for ", 
				    $file->path, " ($group vs. ", 
				    $file->group, ")\n";
d792 1
a792 2
	    print STDERR "make-plist: $plist->{filename} contains arch-dependent\n"; 
	    print STDERR "\t$short\n";
d802 1
a802 2
		print STDERR "make-plist: $plist->{filename} may contain patched file\n";
		print STDERR "\t$short\n";
d805 1
a805 2
		print STDERR "make-plist: $plist->{filename} may contain vim swap file\n";
		print STDERR "\t$short\n";
d808 1
a808 2
		print STDERR "make-plist: $plist->{filename} may contain emacs temp file\n";
		print STDERR "\t$short\n";
a825 2
		    	print "Found out old directory in ", $p->{filename}, 
			    ": ", $file->path, " (mtree)\n";
d881 1
a881 2
		print "Bogus element outside of every prefix: ", $file->path, 
		    "\n";
d894 2
a895 3
				print "Element ", $file->path, 
				    " going to ", $p->{filename}, 
				    " based on prefix\n";
d928 2
a929 2
		    	print "Found out old directory in ", $p->{filename}, 
			    ": ", $file->path, " (mtree)\n";
@


1.122
log
@comment no longer applies. Yeah!
okay chantal goya@@
@
text
@d2 1
a2 1
# $OpenBSD: make-plist,v 1.121 2008/10/30 10:50:36 espie Exp $
d350 2
a351 5
	if (defined $plist->{state}->{lastobject}) {
	    $plist->{state}->{lastobject}->tag_along($self);
    	} else {
	    $plist->{tag_marker}->tag_along($self);
	}
d422 3
d432 3
d442 4
d448 2
a449 1
		print "Bogus sample (unattached) detected\n";
d457 2
a458 5
	if (defined $plist->{state}->{lastobject}) {
		$plist->{state}->{lastobject}->tag_along($self);
	} else {
		$plist->{tag_marker}->tag_along($self);
	}
d465 1
d469 1
a469 1
	    $plist->{tag_marker}->tag_along($self);
d477 1
a477 5
	if (defined $plist->{state}->{lastobject}) {
	    $plist->{state}->{lastobject}->tag_along($self);
    	} else {
	    $plist->{tag_marker}->tag_along($self);
	}
a570 2
    # place holder for extra stuff that comes before any file
    $plist->{tag_marker} = new OpenBSD::PackingElement('');
a587 1
    delete $plist->{state}->{lastobject};
a609 1
		$orig->{tag_marker}->clone_tags($n);
d658 5
a662 1
		return OpenBSD::PackingElement::Binary->new($short);
d939 4
d945 1
a951 10
#for my $i (sort keys %$files) {
#	if (defined $haystack->{$i}) {
#		print "$i: \n";
#		for my $item (@@{$haystack->{$i}}) {
#			print "\t", ref($item), " ", $item->{plist}->{filename},"\n";
#		}
#	} else {
#		print "$i NOT FOUND\n";
#	}
#}
@


1.121
log
@rearrange things so that stuff to copy over can be dealt with after we know
what's still around.
@
text
@d2 1
a2 1
# $OpenBSD: make-plist,v 1.120 2008/10/29 15:42:41 espie Exp $
a17 2
# - multi-package with conflicts don't work.
# (need to multi annotate files)
@


1.120
log
@make things obvious: if your pkg_add is not up-to-date, this doesn't work.
@
text
@d2 1
a2 1
# $OpenBSD: make-plist,v 1.119 2008/10/29 11:26:02 espie Exp $
d236 1
a236 1
# register: known items and known comments
d251 1
a251 1
sub register2
d399 1
a399 1
sub register2
d403 1
a403 1
	$self->SUPER::register2($plist, $haystack);
d408 1
a408 1
sub register2
d410 1
a410 1
	&OpenBSD::PackingElement::Owner::register2;
d414 1
a414 1
sub register2
d418 1
a418 1
	$self->SUPER::register2($plist, $haystack);
d498 1
a498 1
sub register2
d502 1
a502 1
	$self->SUPER::register2($plist, $haystack);
d591 1
a591 2
    $plist->register($plist);
    $plist->register2($plist, $haystack);
d904 20
d932 4
d939 1
@


1.119
log
@this can happen, and it's perfectly sensible in fact
@
text
@d2 1
a2 1
# $OpenBSD: make-plist,v 1.118 2008/10/28 14:32:08 espie Exp $
d491 5
a495 1
	return ${$_[0]->{cwd}};
@


1.118
log
@do a much better job at handling owners and groups
@
text
@d2 1
a2 1
# $OpenBSD: make-plist,v 1.117 2008/10/28 13:29:01 espie Exp $
d805 2
a806 1
		    	print "This should not happen !!!\n";
a946 5

#for my $k (sort keys %$foundcomments) {
#	next if defined $foundcomments->{$k}->{accounted_for};
#	print "Not accounted for: \@@comment $k\n";
#}
@


1.117
log
@do a visitor to copy basic annotations (to be rearranged at some point)
@
text
@d2 1
a2 1
# $OpenBSD: make-plist,v 1.116 2008/10/28 13:01:05 espie Exp $
d286 1
a286 1
				main::handle_modes($plist, $n, $t);
d398 15
d419 1
a419 3
	my $fullname = $self->fullname;
	my $n = $main::subst->do($fullname);
	push(@@{$haystack->{$n}}, $self);
d674 1
a674 1
	my ($plist, $item, $o) = @@_;
d678 1
d699 36
d767 1
a767 1
	    print STDERR "make-plist: generated plist $plist->{filename} contains arch-dependent\n"; 
d778 1
a778 1
		print STDERR "make-plist: generated plist $plist->{filename} may contain patched file\n";
d782 1
a782 1
		print STDERR "make-plist: generated plist $plist->{filename} may contain vim swap file\n";
d786 1
a786 1
		print STDERR "make-plist: generated plist $plist->{filename} may contain emacs temp file\n";
d801 1
d815 1
a815 1
			handle_modes($p, $item, $o);
d839 7
d847 1
a847 1
				handle_modes($p, undef, $o);
d895 1
a895 1
	handle_modes($p, undef, $o);
@


1.116
log
@people with complex multi-packages are going to love this: try to figure
out where to put new stuff based on existing directories.
@
text
@d2 1
a2 1
# $OpenBSD: make-plist,v 1.115 2008/10/28 12:32:39 espie Exp $
d298 49
d528 1
a528 1
	my $plist = OpenBSD::PackingList->read($fh, \&OpenBSD::PackingList::DirrmOnly) or die "couldn't read packing-list\n";
a761 1
		$item->{accounted_for} = 1;
d767 1
d852 4
a855 6
	if (defined $orig and 
	    defined $orig->{cvstags}) {
		for my $tag (@@{$orig->{cvstags}}) {
			$tag->clone->add_object($plist);
		}
	} else {
a856 17
	}
	# copy properties over
	if (defined $orig) {

		if (defined $orig->{'no-default-conflict'}) {
			OpenBSD::PackingElement::NoDefaultConflict->add($plist);
			$plist->{nonempty} = 1;
		}
		for my $listname (qw(pkgcfl conflict groups users 
		    pkgpath incompatibility updateset module)) {
			if (defined $orig->{$listname}) {
				for my $o (@@{$orig->{$listname}}) {
					$o->clone->add_object($plist);
					$plist->{nonempty} = 1;
				}
			}
		}
@


1.115
log
@oops again
@
text
@d2 1
a2 1
# $OpenBSD: make-plist,v 1.114 2008/10/28 12:28:50 espie Exp $
d698 2
a699 1
	my $foundit = 0;
d705 1
d714 1
a714 1
		$foundit = 1;
d725 1
a725 1
	if ($foundit) {
d728 21
d767 1
a767 1
			if ($p ne $allplists->[0]) {
@


1.114
log
@refactor code a bit
@
text
@d2 1
a2 1
# $OpenBSD: make-plist,v 1.113 2008/10/28 12:07:23 espie Exp $
a725 8
	my $default = $allplists->[0];
	my $k;
	
	if ($file->type eq 'library') {
		$k = $subst->reverse_with_lib($file->path);
	} else {
		$k = $subst->reverse($file->path);
	}
a727 1
	my $item;
d741 1
a741 1
		my $short = short_name($file, $try);
d744 1
a744 1
			if ($p ne $default) {
@


1.113
log
@oops.
@
text
@d2 1
a2 1
# $OpenBSD: make-plist,v 1.112 2008/10/28 11:59:12 espie Exp $
a482 12
# full file name to file name in plist context
sub strip_base
{
	my $_ = shift;
	my $base = shift->{stripprefix};
	if (m/^\Q$base\E/) {
		$_ = $';
	}
	$_='/' if $_ eq '';
	return $_;
}

d647 45
d706 1
a706 6
		my $short = strip_base($file->path, $p);
		if ($file->type eq 'library') {
			$short = $subst->reverse_with_lib($short);
		} else {
			$short = $subst->reverse($short);
		}
a710 7
		# If the resulting name is arch-dependent, we warn.
		# We don't fix it automatically, as this may need special handling.
		if ($short =~ m/i386|m68k|sparc/) {
		    print STDERR "make-plist: generated plist contains arch-dependent\n"; 
		    print STDERR "\t$short\n";
		}

a745 1
		my $s2 = strip_base($file->path, $try);
d750 2
a751 1
		unless ($s2 =~ m|^/|) {
a752 1
			$short = $s2;
a764 11
	if ($file->type eq 'library') {
		$short = $subst->reverse_with_lib($short);
	} else {
		$short = $subst->reverse($short);
	}
	# If the resulting name is arch-dependent, we warn.
	# We don't fix it automatically, as this may need special handling.
	if ($short =~ m/i386|m68k|sparc/) {
	    print STDERR "make-plist: generated plist contains arch-dependent\n"; 
	    print STDERR "\t$short\n";
	}
d768 2
a769 12
	if ($short =~ /\.orig$/) {
		print STDERR "make-plist: generated plist may contain patched file\n";
		print STDERR "\t$short\n";
	}
	if ($short =~ /\/\.[^\/]*\.swp$/) {
		print STDERR "make-plist: generated plist may contain vim swap file\n";
		print STDERR "\t$short\n";
	}
	if ($short =~ /\~$/) {
		print STDERR "make-plist: generated plist may contain emacs temp file\n";
		print STDERR "\t$short\n";
	}
a777 1

@


1.112
log
@instead of the old mess, create a haystack hash with every full file name,
so that we can match directly against the file system.
Also keep a list for each element, which allows us to multi-match when
needed... For instance fvwm2 is now happy with this.
@
text
@d2 1
a2 1
# $OpenBSD: make-plist,v 1.111 2008/10/27 21:00:11 espie Exp $
d423 1
a423 1
	$mtree->{$self->fullname()} = 1;
d480 1
a480 3
	for my $item (@@{$plist->{items}}) {
		$item->add_to_mtree($mtree);
	}
d588 1
a588 1
	if ($item->isa("OpenBSD::PackingElement::Comment")) {
@


1.111
log
@small tweaks
@
text
@d2 1
a2 1
# $OpenBSD: make-plist,v 1.110 2008/10/27 16:53:13 bernd Exp $
d251 6
a258 1
	my ($self, $plist) = @@_;
d283 1
a283 1
			my $n = $t->clone();
d302 1
a302 1
	my ($self, $plist, $files, $comments) = @@_;
d350 1
a350 1
sub register
d352 1
a352 1
	my ($self, $plist, $files, $comments) = @@_;
d354 1
a354 1
	$self->{plist} = $plist;
d356 2
a357 2
	my $n = $main::subst->reverse($fullname);
	$files->{$n} = $self;
d363 1
a363 9
	my ($self, $plist, $files, $comments) = @@_;
	$plist->{state}->{lastobject} = $self;
	$self->SUPER::register($plist, $files, $comments);
}

package OpenBSD::PackingElement::Lib;
sub register
{
	my ($self, $plist, $files, $comments) = @@_;
a364 4
	$self->{plist} = $plist;
	my $fullname = $self->fullname;
	my $n = $main::subst->reverse_with_lib($fullname);
	$files->{$n} = $self;
d370 1
a370 1
	my ($self, $plist, $files, $comments) = @@_;
a371 1
	$self->SUPER::register($plist, $files, $comments);
d377 1
a377 1
	my ($self, $plist, $files, $comments) = @@_;
d388 1
a388 1
	my ($self, $plist, $files, $comments) = @@_;
d399 1
a399 1
	my ($self, $plist, $files, $comments) = @@_;
d410 1
a410 1
	my ($self, $plist, $files, $comments) = @@_;
d427 6
a432 1
sub register
d434 6
a439 9
	my ($self, $plist, $files, $comments) = @@_;
	$self->{plist} = $plist;
	my $name = $self->{name};
	$comments->{$name} = $self;
	if ($name =~ m/^\@@dir(?:rm)?\s+/) {
		$name = $'.'/';
		my $o = OpenBSD::PackingElement::Comment->new($name);
		# register @@dirrm dir comment as dir/
		$comments->{$o->{name}} = $self;
d441 2
d450 2
a451 2
	if ($self->cwd() ne $plist->{state}->cwd()) {
	    OpenBSD::PackingElement::Cwd->add($plist, $self->cwd());
d453 1
a453 1
	$self->clone()->add_object($plist);
a456 5
sub register
{
	my ($self, $plist) = @@_;
}

d463 1
a463 1
	$self->clone()->add_object($plist);
a468 1
	my ($self, $plist) = @@_;
d497 1
a497 1
my ($foundfiles, $foundcomments) = ({}, {});
d539 2
a540 1
    $plist->register($plist, $foundfiles, $foundcomments);
d590 3
d665 34
a698 1
	my ($file, $foundfiles, $foundcomments, $allplists, $shared_only) = @@_;
d700 7
d725 14
a738 29
	# find out accurate prefix: if file is part of an existing plist,
	# don't look further
	if (defined $foundfiles->{$k}) {
		$item = $foundfiles->{$k};
		$p = $item->{plist}->{replacement};
		if ($file->type eq 'directory' && $p->{mtree}->{$file->path}) {
			undef $p;
		} else {
			$short = strip_base($file->path, $p);
		}
	}
	if (!defined $p) {
	# otherwise, look for the first matching prefix in plist to produce
	# an entry
		for my $try (@@$allplists) {
			my $s2 = strip_base($file->path, $try);
			if ($file->type eq 'directory' and 
			    $try->{mtree}->{$file->path}) {
				next;
			}
			unless ($s2 =~ m|^/|) {
				$p = $try;
				$short = $s2;
				if ($p ne $default) {
					print "Element ", $file->path, 
					    " going to ", $p->{filename}, 
					    " based on prefix\n";
				}
				last;
d740 1
d759 1
a759 1
	my $o = create_object($file->type, $short, $item);
d761 19
a779 34
	my $s = $o->fullstring();
	# 
	if ($foundcomments->{$s}) {
		$foundcomments->{$s}->{accounted_for} = 1;
		$o = OpenBSD::PackingElement::Comment->new($s);
		$p = $foundcomments->{$s}->{plist}->{replacement};
		$o->add_object($p);
		$p->{nonempty} = 1;
	} else {
		if ($short =~ /\.orig$/) {
			print STDERR "make-plist: generated plist may contain patched file\n";
			print STDERR "\t$short\n";
		}
		if ($short =~ /\/\.[^\/]*\.swp$/) {
			print STDERR "make-plist: generated plist may contain vim swap file\n";
			print STDERR "\t$short\n";
		}
		if ($short =~ /\~$/) {
			print STDERR "make-plist: generated plist may contain emacs temp file\n";
			print STDERR "\t$short\n";
		}
		if (($file->type eq 'library' || $file->type eq 'plugin') && (!defined $item) && !$shared_only) {
			$p->{wantshared} = 1;
			$p = $p->{shared};
		}
		handle_modes($p, $item, $o);
		$o->add_object($p);
		$p->{nonempty} = 1;

		# Copy properties from source item
		if (defined $item) {
			$item->clone_tags($p);
		}
	}
d820 10
d831 1
a831 1
	handle_file($files->{$i}, $foundfiles, $foundcomments, \@@l, $shared_only);
d849 4
a852 4
for my $k (sort keys %$foundcomments) {
	next if defined $foundcomments->{$k}->{accounted_for};
	print "Not accounted for: \@@comment $k\n";
}
@


1.110
log
@unbreak
@
text
@d2 1
a2 1
# $OpenBSD: make-plist,v 1.109 2008/10/27 13:25:35 espie Exp $
d549 1
a549 3
    for my $item (@@{$plist->{items}}) {
    	$item->register($plist, $foundfiles, $foundcomments);
    }
@


1.109
log
@endfake no more
@
text
@d2 1
a2 1
# $OpenBSD: make-plist,v 1.108 2008/10/27 12:18:40 espie Exp $
a573 1
		}
@


1.108
log
@zap the end_fake for now, it's confusing issues...
@
text
@d2 1
a2 1
# $OpenBSD: make-plist,v 1.107 2008/10/27 11:28:12 espie Exp $
a573 2
		if (defined $orig->{has_endfake}) {
			$n->{has_endfake} = 1;
@


1.107
log
@DYNLIBDIR died ages ago
@
text
@d2 1
a2 1
# $OpenBSD: make-plist,v 1.106 2008/10/27 11:19:57 espie Exp $
a253 1
	$self->{end_faked} = $plist->{state}->{end_faked};
a292 8
package OpenBSD::PackingElement::EndFake;
sub register
{
	my ($self, $plist) = @@_;
	$plist->{state}->{end_faked} = 1;
	$plist->{has_endfake} = 1;
}

a302 1
	$self->{end_faked} = $plist->{state}->{end_faked};
a349 1
	$self->{end_faked} = $plist->{state}->{end_faked};
a368 1
	$self->{end_faked} = $plist->{state}->{end_faked};
a385 1
	$self->{end_faked} = $plist->{state}->{end_faked};
a396 1
	$self->{end_faked} = $plist->{state}->{end_faked};
a407 1
	$self->{end_faked} = $plist->{state}->{end_faked};
a418 1
	$self->{end_faked} = $plist->{state}->{end_faked};
a437 1
	$self->{end_faked} = $plist->{state}->{end_faked};
a463 1
	$self->{end_faked} = $plist->{state}->{end_faked};
a478 1
	$self->{end_faked} = $plist->{state}->{end_faked};
d527 1
a527 1
    my ($name, $sub, $all_plists, $parent) = @@_;
a548 4
    if (!defined $parent) {
    	$parent = 0;
    }
    $plist->{state}->{end_faked} = $parent;
d559 1
a559 1
	    my $origpfrag = parse_original_plist($fragname, $sub, $all_plists, $item->{end_faked});
d676 1
a676 1
	my ($file, $foundfiles, $foundcomments, $allplists, $shared_only, $pass) = @@_;
a704 6
			if ($pass == 0 and $item->{end_faked} == 1) {
				return;
			}
			if ($pass == 1 and $item->{end_faked} == 0) {
				return;
			}
a769 3
			if ($pass == 1) {
				return;
			}
d821 1
a821 16
	handle_file($files->{$i}, $foundfiles, $foundcomments, \@@l, $shared_only, 0);
}

my $need_second_pass = 0;

for my $plist (@@l) {
	if (defined $plist->{has_endfake}) {
		OpenBSD::PackingElement::EndFake->add($plist);
		$need_second_pass = 1;
	}
}

if ($need_second_pass) {
	for my $i (sort keys %$files) {
		handle_file($files->{$i}, $foundfiles, $foundcomments, \@@l, $shared_only, 1);
	}
@


1.106
log
@zap very old code that was used to remove @@exec mkdir and @@exec install-info
@
text
@d2 1
a2 1
# $OpenBSD: make-plist,v 1.105 2008/10/27 11:12:01 espie Exp $
a559 2
		    } elsif (m/^(?:NEW)?DYNLIBDIR\(.*\)$/) {
		    	next;
d828 1
a828 1
			$tag->clone()->add_object($plist);
d844 1
a844 1
					$o->clone()->add_object($plist);
@


1.105
log
@turn the stuff we read from the FS into actual objects
@
text
@d2 1
a2 1
# $OpenBSD: make-plist,v 1.104 2008/10/27 10:33:46 espie Exp $
d421 1
a421 1
	my ($self, $plist, $files, $comments, $existing) = @@_;
a422 12
	if ($self->{expanded} =~ m/^install\-info\s+(?:\-\-delete\s+)?\-\-info\-dir=.*?\/info\s+(.*)$/) {
		my $iname = $1;
		if (defined $existing->{$iname} and $existing->{$iname}->type eq 'info') {
			return;
	    	}
	}
	if ($self->{expanded} =~ m/^mkdir\s+\-p\s+(.*)$/) {
		my $iname = $1;
		if (defined $existing->{$iname} and $existing->{$iname}->type eq 'directory') {
			return;
		}
	}
d546 1
a546 1
    my ($name, $sub, $files, $all_plists, $parent) = @@_;
d575 1
a575 1
    	$item->register($plist, $foundfiles, $foundcomments, $files);
d584 1
a584 1
	    my $origpfrag = parse_original_plist($fragname, $sub, $files, $all_plists, $item->{end_faked});
a606 2
	my ($files) = @@_;

d612 1
a612 1
		$o = parse_original_plist($plistname{$sub}, $sub, $files, $l);
d617 1
a617 1
		$o = parse_original_plist($frag, $sub, $files, $l);
d823 1
a823 1
my @@l = grab_all_lists($files);
@


1.104
log
@move parts of make-plist into a separate module to try to clean up the
mess a bit...
@
text
@d2 1
a2 1
# $OpenBSD: make-plist,v 1.103 2008/10/26 16:24:22 espie Exp $
d425 1
a425 1
		if (defined $existing->{$iname} and $existing->{$iname} eq 'info') {
d431 1
a431 1
		if (defined $existing->{$iname} and $existing->{$iname} eq 'directory') {
d715 1
a715 1
	my ($i, $type, $foundfiles, $foundcomments, $allplists, $shared_only, $pass) = @@_;
d720 2
a721 2
	if ($type eq 'library') {
		$k = $subst->reverse_with_lib($i);
d723 1
a723 1
		$k = $subst->reverse($i);
d729 1
a729 1
	my $possible = possible_subpackages($i);
d731 2
a732 1
		print "Bogus element outside of every prefix: $i\n";
d740 1
a740 1
		if ($type eq 'directory' && $p->{mtree}->{$i}) {
d743 1
a743 1
			$short = strip_base($i, $p);
d756 3
a758 2
			my $s2 = strip_base($i, $try);
			if ($type eq 'directory' and $try->{mtree}->{$i}) {
d765 3
a767 1
					print "Element $i going to ", $p->{filename}, " based on prefix\n";
d777 1
a777 1
	if ($type eq 'library') {
d789 1
a789 1
	my $o = create_object($type, $short, $item);
d812 1
a812 1
		if (($type eq 'library' || $type eq 'plugin') && (!defined $item) && !$shared_only) {
d869 1
a869 1
	handle_file($i, $files->{$i}, $foundfiles, $foundcomments, \@@l, $shared_only, 0);
d883 1
a883 1
		handle_file($i, $files->{$i}, $foundfiles, $foundcomments, \@@l, $shared_only, 1);
@


1.103
log
@useless comment ;)
@
text
@d2 1
a2 1
# $OpenBSD: make-plist,v 1.102 2008/10/26 16:02:06 espie Exp $
d27 1
a27 1
use lib $ENV{PORTSDIR}."/infrastructure";
a31 1
use OpenBSD::Mtree;
d33 1
a33 2
use File::Spec;
use File::Find;
a34 1
use File::Basename;
d36 1
a513 161
# existing files are classified according to the following routine

sub get_type
{
	my $filename = shift;
	if (-d $filename && !-l $filename) {
		return "directory";
	} elsif (is_subinfo($filename)) {
		return "subinfo";
	} elsif (is_info($filename)) {
		return "info";
	} elsif (is_dir($filename)) {
		return "dir";
	} elsif (is_manpage($filename)) {
		return "manpage";
	} elsif (is_library($filename)) {
		return "library";
	} elsif (is_plugin($filename)) {
		return "plugin";
	} elsif (is_binary($filename)) {
		return "binary";
	} else {
		return "file";
	}
}

# symlinks are usually given in a DESTDIR setting, any operation
# beyond filename checking gets through resolve_link

sub resolve_link
{
	my $filename = shift;
	my $level = shift || 0;
	if (-l $filename) {
		my $l = readlink($filename); 
		if ($level++ > 14) {
			print STDERR "Symlink too deep: $filename\n";
			return $filename;
		}
		if ($l =~ m|^/|) {
			return $destdir.resolve_link($l, $level);
		} else {
			return resolve_link(File::Spec->catfile(dirname($filename),$l), $level);
		}
	} else {
		return $filename;
	}
}

sub is_shared_object
{
	my $filename = shift;
	$filename = resolve_link($filename);
	my $check=`/usr/bin/file $filename`;
	chomp $check;
	if ($check =~m/\: ELF (32|64)-bit (MSB|LSB) shared object\,/ ||
	    $check =~m/OpenBSD\/.* demand paged shared library/) {
	    	return 1;
	} else {
		return 0;
	}
}

sub is_library
{
	my $filename = shift;

	return 0 unless $filename =~ m/\/lib[^\/]*\.so\.\d+\.\d+$/;
	return is_shared_object($filename);
}

sub is_binary
{
	my $filename = shift;
	return 0 if -l $filename or ! -x $filename;
	my $check=`/usr/bin/file $filename`;
	chomp $check;
	if ($check =~m/\: ELF (32|64)-bit (MSB|LSB) executable\,.+ for OpenBSD\,/) {
	    	return 1;
	} else {
		return 0;
	}
}

sub is_plugin
{
	my $filename = shift;

	return 0 unless $filename =~ m/\.so$/;
	return is_shared_object($filename);
}

sub is_info
{
	my $filename = shift;
	return 0 unless $filename =~ m/\.info$/ or $filename =~ m/info\/[^\/]+$/;
	$filename = resolve_link($filename);
	open my $fh, '<', $filename or return 0;
	my $tag = <$fh>;
	return 0 unless defined $tag;
	chomp $tag;
	$tag.=<$fh>;
	close $fh;
	if ($tag =~ /^This is .*, produced by [Mm]akeinfo(?: version |-)?.*[\d\s]from/) {
		return 1;
	} else {
		return 0;
	}
}

sub is_manpage
{
	my $_ = shift;
	if (m,/man/(?:[^/]*?/)?man(.*?)/[^/]+\.\1[[:alpha:]]?(?:\.gz|\.Z)?$,) {
		return 1;
	}
	if (m,/man/(?:[^/]*?/)?man3p/[^/]+\.3(?:\.gz|\.Z)?$,) {
		return 1;
	}
	if (m,/man/(?:[^/]*/)?cat.*?/[^/]+\.0(?:\.gz|\.Z)?$,) {
		return 1;
	}
	if (m,/man/(?:[^/]*/)?(?:man|cat).*?/[^/]+\.tbl(?:\.gz|\.Z)?$,) {
		return 1;
	}
	return 0;
}

sub is_dir
{
	my $filename = shift;
	return 0 unless $filename =~ m/\/dir$/;
	$filename = resolve_link($filename);
	open my $fh, '<', $filename or return 0;
	my $tag = <$fh>;
	chomp $tag;
	$tag.=" ".<$fh>;
	chomp $tag;
	$tag.=" ".<$fh>;
	close $fh;
	if ($tag =~ /^(?:\-\*\- Text \-\*\-\s+)?This is the file .*, which contains the topmost node of the Info hierarchy/) {
		return 1;
	} else {
		return 0;
	}
}

sub is_subinfo
{
	my $filename = shift;
	if ($filename =~ m/^(.*\.info)\-\d+$/ or
	    $filename =~ m/^(.*info\/[^\/]+)\-\d+$/) {
		return is_info($1);
	}
	if ($filename =~ m/^(.*)\.\d+in$/) {
		return is_info("$1.info");
	}
	return 0;
}


a525 91
sub undest
{
	my $filename=shift;
	if ($filename =~ m/^\Q$destdir\E/) {
		$filename = $';
	}
	$filename='/' if $filename eq '';
	return $filename;
}

# check that $fullname is not the only entry in its directory
sub has_other_entry
{
	my $fullname = shift;
	use Symbol;

	my $dir = gensym;
	opendir($dir, dirname($fullname)) or return 0;
	while (my $e = readdir($dir)) {
		next if $e eq '.' or $e eq '..';
	    	next if $e eq basename($fullname);
		return 1;
	}
	return 0;
}

# zap directories going up if there is nothing but that filename.
# used to zap .perllocal, dir, and other stuff.
sub zap_dirs
{
	my ($dirs, $fullname) = @@_;
	return if has_other_entry($fullname);
	my $d = dirname($fullname);
	return if $d eq $destdir;
	delete $dirs->{undest($d)};
	zap_dirs($dirs, $d);
}

# find all objects that need registration, mark them according to type.
sub scan_destdir
{
	my %files;
	my %okay_files=map { $_=>1 } split(/\s+/, $ENV{'OKAY_FILES'});
	use Config;

	my $installsitearch = $Config{'installsitearch'};
	my $archname = $Config{'archname'};
	my $installprivlib = $Config{'installprivlib'};
	my $installarchlib = $Config{'installarchlib'};

	find(
		sub {
			return if defined $okay_files{$File::Find::name};
			my $type = get_type($File::Find::name);
			if ($type eq "dir" or
			    $type eq 'subinfo' or
			    $File::Find::name =~ m,\Q$installsitearch\E/auto/.*/\.packlist$, or
			    $File::Find::name =~ m,\Q$installarchlib/perllocal.pod\E$, or
			    $File::Find::name =~ m,\Q$installsitearch/perllocal.pod\E$, or
			    $File::Find::name =~ m,\Q$installprivlib/$archname/perllocal.pod\E$,) {
			    	zap_dirs(\%files, $File::Find::name);
				return;
			}
			return if $File::Find::name =~ m/pear\/lib\/\.(?:filemap|lock)$/;
			my $path = undest($File::Find::name);
			$path =~ s,^/etc/X11/app-defaults\b,/usr/local/lib/X11/app-defaults,;
			$files{$path} = get_type($File::Find::name);
		}, $destdir);
	zap_dirs(\%files, $destdir.'/etc/X11/app-defaults');
	return \%files;
}

# build a hash of files needing registration
sub get_files
{
	my $files = scan_destdir();
	my $mtree = {};
	OpenBSD::Mtree::parse($mtree, '/usr/local', '/etc/mtree/BSD.local.dist');
	OpenBSD::Mtree::parse($mtree, '/', '/etc/mtree/4.4BSD.dist');
	OpenBSD::Mtree::parse($mtree, '/usr/X11R6', '/etc/mtree/BSD.x11.dist');
	$mtree->{'/usr/local/lib/X11'} = 1;
	$mtree->{'/usr/local/include/X11'} = 1;
	$mtree->{'/usr/local/lib/X11/app-defaults'} = 1;

	# make sure main mtree is removed 
	for my $d (keys %$mtree) {
		delete $files->{$d}
	}
	return $files;
}

d831 1
a831 1
my $files = get_files();
@


1.102
log
@zap local $_
@
text
@d2 1
a2 1
# $OpenBSD: make-plist,v 1.101 2008/10/02 18:06:37 espie Exp $
d1079 3
@


1.101
log
@new perl can't read from unopened dir (autovivified handle)
@
text
@d2 2
a3 2
# $OpenBSD: make-plist,v 1.100 2008/06/18 12:11:01 espie Exp $
# Copyright (c) 2004-2006 Marc Espie <espie@@openbsd.org>
d74 1
a74 2
	my $self = shift;
	local $_ = shift;
d90 1
a90 2
	my $self = shift;
	local $_ = shift;
d156 1
a156 1
	local $_ = shift;
d628 1
a628 1
	local $_ = shift;
d783 1
a783 1
	local($_)=shift;
d820 1
@


1.100
log
@don't try to resolve links for binaries, it actually makes little sense.
suggestion from mike erdely and others.
@
text
@d2 1
a2 1
# $OpenBSD: make-plist,v 1.99 2008/06/12 09:06:52 bernd Exp $
d708 1
a708 1
	opendir($dir, dirname($fullname));
@


1.99
log
@Only annotate OpenBSD binaries with @@bin.

ok espie@@
@
text
@d2 1
a2 1
# $OpenBSD: make-plist,v 1.98 2008/06/06 15:03:30 espie Exp $
d592 1
a592 2
	$filename = resolve_link($filename);
	return 0 unless -x $filename;
@


1.98
log
@detect executables in a crude way and tag them.
@
text
@d2 1
a2 1
# $OpenBSD: make-plist,v 1.97 2008/05/21 10:07:14 espie Exp $
d596 1
a596 1
	if ($check =~m/\: ELF (32|64)-bit (MSB|LSB) executable\,/) {
@


1.97
log
@fix bug introduced during rewrite: do not try to backsubst stuff inside the
library version number.
@
text
@d2 1
a2 1
# $OpenBSD: make-plist,v 1.96 2008/04/13 09:46:19 espie Exp $
d537 2
d589 14
d916 2
@


1.96
log
@if I want to make the path part of the regexp, I need to use ? to make
sure it matches correctly...
@
text
@d2 1
a2 1
# $OpenBSD: make-plist,v 1.95 2008/04/12 13:04:21 espie Exp $
d103 1
a103 1
		return $self->reverse("${path}lib$name.so.\${LIB${name}_VERSION}");
@


1.95
log
@extend VAR_SUBST syntax slightly: a supplementary ^ at the beginning of
the variable subst means the subst shouldn't occur anywhere, but only at
beginning of name... useful for backsubst of SYSCONFDIR, since etc is so
frequent. Extended to other variables such as PREFIX.

tweak make-plist to use OpenBSD::Subst.

*this means this only works with current, but you've had a week to update...*
@
text
@d2 1
a2 1
# $OpenBSD: make-plist,v 1.94 2007/05/12 14:02:08 espie Exp $
d93 1
a93 1
	if (m/^(.*)lib([^\/]+)\.so\.(\d+\.\d+)$/) {
@


1.94
log
@strip quotes
@
text
@d2 1
a2 1
# $OpenBSD: make-plist,v 1.93 2007/04/08 15:22:49 espie Exp $
d26 2
d33 1
d40 70
d115 1
a115 1
my (@@backsubst, @@libbacksubst);
a117 1
my $lib_warnings = {};
d159 8
a166 1
	if (m/^PREFIX(\-.*?)\=(.*)\/?$/) {
a169 15
	} elsif (m/^DEPPATHS(-.*?)\=/) {
		$mtree{$1} = build_mtree($1, $');
	} elsif (m/\=/) {
		my $back = $`;
		my $v = $';
		$v =~ s/^\'(.*)\'$/$1/;
		$v =~ s/^\"(.*)\"$/$1/;
		if ($back =~ m/^LIB(.*)_VERSION$/) {
			$known_libs{$1}=$v;
			push(@@libbacksubst, ["\${$back}", $v]) if $v ne '';
		} else {
			push(@@backsubst, ["\${$back}", $v]) if $v ne '';
		}
	} else {
		die "Incorrect argument to $0: $_";
a218 48
sub lib_backsubst
{
	local $_ = shift;
	if (m/lib([^\/]+)\.so\.(\d+\.\d+)$/) {
		my ($name, $v) = ($1, $2);
		if (!defined $known_libs{$name}) {
			$lib_warnings->{$name}->{missing} = $v;
		} else {
			if ($known_libs{$name} ne $v) {
				$lib_warnings->{$name}->{version} = [$v,
				    $known_libs{$name}];
			}
		}
		s/^(.*?)\d+\.\d+$/var_backsubst($1)/e;
		$_ .= "\$\{LIB$name\_VERSION\}";
		return $_;
	} elsif (m/\.so\.\$\{LIB.*_VERSION\}$/) {
		return var_backsubst($`).$&;
	} else {
		return var_backsubst($_);
	}
}

sub var_backsubst
{
	local $_ = shift;
	for my $l (@@backsubst) {
		my $v = $l->[1];
		my $r = $l->[0];
		if ($r eq '${SYSCONFDIR}') {
			s/^\Q$v\E/$r/;
		} else {
			s/\Q$v\E/$r/g;
		}
	}
	return $_;
}

sub var_subst
{
	local $_ = shift;
	for my $l (@@backsubst, @@libbacksubst) {
		my $v = $l->[0];
		my $r = $l->[1];
		s/\Q$v\E/$r/g;
	}
	return $_;
}
d365 2
a366 2
	my $fullname = $self->fullname();
	my $n = main::var_backsubst($fullname);
d385 2
a386 2
	my $fullname = $self->fullname();
	my $n = main::lib_backsubst($fullname);
d959 1
a959 1
		$k = lib_backsubst($i);
d961 1
a961 1
		$k = var_backsubst($i);
d1012 1
a1012 1
		$short = lib_backsubst($short);
d1014 1
a1014 1
		$short = var_backsubst($short);
a1136 13

for my $name (sort keys %$lib_warnings) {
	if (defined $lib_warnings->{$name}->{missing}) {
		print STDERR "WARNING: unregistered shared lib: $name "
		    . "(version: $lib_warnings->{$name}->{missing})\n";
	}
	if (defined $lib_warnings->{$name}->{version}) {
		my ($v1, $v2) = @@{$lib_warnings->{$name}->{version}};
		print STDERR "WARNING: version mismatch for lib $name "
		    . "($v1 vs. $v2)\n";
	}
}

@


1.93
log
@avoid recursing ad nauseam on symlinks.
@
text
@d2 1
a2 1
# $OpenBSD: make-plist,v 1.92 2007/02/07 11:24:23 bernd Exp $
d96 2
@


1.92
log
@Add missing parameter for a parse_original_plist() call in grab_all_lists().
@
text
@d2 1
a2 1
# $OpenBSD: make-plist,v 1.91 2007/01/12 21:53:31 espie Exp $
d530 1
d533 4
d538 1
a538 1
			return $destdir.resolve_link($l);
d540 1
a540 1
			return resolve_link(File::Spec->catfile(dirname($filename),$l));
@


1.91
log
@make expr less greedy
@
text
@d2 1
a2 1
# $OpenBSD: make-plist,v 1.90 2007/01/10 01:41:29 espie Exp $
d843 1
a843 1
		$o = parse_original_plist($plistname{$sub}, $sub, $l);
@


1.90
log
@cache mtrees read from dependencies so that we don't parse the same
dependency twice across MULTI_PACKAGES.
@
text
@d2 1
a2 1
# $OpenBSD: make-plist,v 1.89 2007/01/09 19:40:49 espie Exp $
d166 1
a166 1
		s/^(.*)\d+\.\d+$/var_backsubst($1)/e;
@


1.89
log
@yet more special-casing: do backsubst for libnames correctly, so that
update plist correctly registers existing ones, otherwise shared libraries
with some weird names will always pop back to the main PLIST.
@
text
@d2 1
a2 1
# $OpenBSD: make-plist,v 1.88 2007/01/08 18:33:37 espie Exp $
d60 1
d70 6
d77 3
a79 3
		open my $fh, "cd $portsdir && env -i SUBDIR=$pkgpath ECHO_MSG=: $make print-plist |" or die "blech\n";
		augment_mtree($mtree, $fh);
		close($fh);
@


1.88
log
@for shared libraries, only apply var_backsubst on the library name, leave
the version alone.
@
text
@d2 1
a2 1
# $OpenBSD: make-plist,v 1.87 2006/12/19 10:03:22 espie Exp $
d162 2
@


1.87
log
@don't insist on matching subpackage names, anything goes...
@
text
@d2 1
a2 1
# $OpenBSD: make-plist,v 1.86 2006/12/11 17:17:25 espie Exp $
d159 5
a163 1
		$_ =~ s/\d+\.\d+$/\$\{LIB$name\_VERSION\}/;
a164 1
	return var_backsubst($_);
@


1.86
log
@filter prefix early, in preparation of more changes to come.
@
text
@d2 1
a2 1
# $OpenBSD: make-plist,v 1.85 2006/12/11 13:51:14 espie Exp $
d80 1
a80 1
	if (m/^PREFIX(\-\w*)\=(.*)\/?$/) {
d82 1
a82 1
	} elsif (m/^PLIST(\-\w*)\=/) {
d84 1
a84 1
	} elsif (m/^DEPPATHS(-\w*)\=/) {
@


1.85
log
@zap extra parse_args.
@
text
@d2 1
a2 1
# $OpenBSD: make-plist,v 1.84 2006/12/11 13:36:06 espie Exp $
d80 2
a81 2
	if (m/^PREFIX(\-\w*)\=/) {
		$prefix{$1} = $';
d190 13
a930 1
	my $warn_bogus = 1;
d932 5
a959 1
				$warn_bogus = 0;
a973 1
		print "Bogus element outside of base: $i\n" if $warn_bogus;
@


1.84
log
@pass all subpackage information to make-plist.
Adapt make-plist to use the same code as pkg_create to deduce fragment
names, remove some old special cases that should no longer matter.

Zap directories from dependencies in a way depending on the dependency.
Far from perfect yet, as directories should be registered multiple times
in packages that do not depend on each other, and could also be used to
figure out where to put new files...
@
text
@d2 1
a2 1
# $OpenBSD: make-plist,v 1.83 2006/11/20 13:56:37 espie Exp $
a144 2

parse_args;
@


1.83
log
@kludge make-plist to work with new multi packages
@
text
@d2 1
a2 1
# $OpenBSD: make-plist,v 1.82 2006/11/09 08:16:22 espie Exp $
d49 99
a223 10
sub zap_comment
{
	my ($self, $foundcomments, $p) = @@_;

	my $s = $self->fullstring();
	if (defined $foundcomments->{$s} and $foundcomments->{$s}->{plist} == $p) {
		delete $foundcomments->{$s};
	}
}

a705 1

d713 2
a714 11
	# add directories from dependencies
	my $stripped = {};
	for my $pkgpath (split(/\s+/, $ENV{'DEPPATHS'})) {
		next if defined $stripped->{$pkgpath};
		$stripped->{$pkgpath} = 1;
		print STDERR "Stripping dirs from $pkgpath\n";
		open my $fh, "cd ".$ENV{PORTSDIR}." && env -i SUBDIR=$pkgpath ECHO_MSG=: ".$ENV{MAKE}." print-plist |" or die "blech\n";
		augment_mtree($mtree, $fh);
		close($fh);
	}
	# make sure mtree is removed 
d738 1
a738 1
	my ($filename, $prefix) = @@_;
d740 1
d743 1
d753 2
a754 2
    my ($name, $prefix, $files, $all_plists, $parent) = @@_;
    my $plist = create_packinglist($name, $prefix);
d787 1
a787 1
	    my $pfrag = create_packinglist($fragname, $prefix);
d790 1
a790 1
	    my $origpfrag = parse_original_plist($fragname, $prefix, $files, $all_plists, $item->{end_faked});
a810 11
# old packing-lists used to hold comments to avoid fragments...
sub no_comments
{
	my ($f, $orig) = @@_;
	return unless defined $f and defined $orig;
	for my $item (@@{$f->{items}}) {
		$item->zap_comment($foundcomments, $orig);
	}
}


d813 1
a813 2
	my ($prefixes, $files) = @@_;
	my $prefix = $prefixes->{''};
d816 12
a827 38
	my $plistname=$ENV{'PLIST'};
	$plistname =~ s/\-main$//;
	my $pfragname=$ENV{'PFRAG'};
	my $psharedname=$pfragname.".shared";
	# Subpackage rules... better way would be to ask bsd.port.mk directly
	my $altplistname = $plistname;
	$altplistname =~ s/PLIST.*$/PLIST/;

	my $plist = create_packinglist($plistname, $prefix);
	push(@@$l, $plist);
	my $origplist = parse_original_plist($plistname, $prefix, $files, $l);
	replaces($origplist, $plist);

	my $pshared = create_packinglist($psharedname, $prefix);
	push(@@$l, $pshared);
	$plist->{shared} = $pshared;
	my $origshared = parse_original_plist($psharedname, $prefix, $files);
	replaces($origshared, $pshared);

	my $multi = $ENV{'MULTI_PACKAGES'};
	# Normalize
	$multi =~ s/^\s+//;
	$multi =~ s/\s+$//;
	unless ($multi eq '') {
		for my $sub (split(/\s+/, $multi)) {
			my $o;
			my $n = create_packinglist("$plistname$sub", $prefixes->{$sub});
			push(@@$l, $n);
			$o = parse_original_plist("$plistname$sub", $prefixes->{$sub}, $l) or
			    $o = parse_original_plist("$altplistname$sub", $prefixes->{$sub}, $files, $l);
			replaces($o, $n);
			no_comments($o, $origplist);
			my $ns = create_packinglist("$psharedname$sub", $prefixes->{$sub});
			$n->{shared} = $ns;
			$o = parse_original_plist("$psharedname$sub", $prefixes->{$sub}, $files, $l);
			replaces($o, $ns);
			push(@@$l, $ns);
		}
d920 1
d927 10
a936 3
		$short = strip_base($i, $p);
		if ($pass == 0 and $item->{end_faked} == 1) {
			return;
d938 2
a939 4
		if ($pass == 1 and $item->{end_faked} == 0) {
			return;
		}
	} else {
d944 4
d960 1
a960 1
		print "Bogus element outside of base: $i\n";
d1016 1
a1016 22
my %prefix;

while ($ARGV[0] =~ m/^PREFIX(-.*?)\=/) {
	my ($sub, $v) = ($1, $');
	$prefix{$sub} = $v;
	shift @@ARGV;
}
$prefix{''}=$ENV{'TRUEPREFIX'};
	
for (@@ARGV) {
	if (m/\=/) {
		my $back = $`;
		my $v = $';
		if ($back =~ m/^LIB(.*)_VERSION$/) {
			$known_libs{$1}=$v;
			push(@@libbacksubst, ["\${$back}", $v]) if $v ne '';
		} else {
			push(@@backsubst, ["\${$back}", $v]) if $v ne '';
		}
	}
}

d1020 1
a1020 1
my @@l = grab_all_lists(\%prefix, $files);
a1047 7
	}
}

my $shared_only;
if (defined $ENV{'SHARED_ONLY'}) {
	if ($ENV{'SHARED_ONLY'} =~ m/^Yes$/i) {
		$shared_only = 1;
@


1.82
log
@remove the dependency of make-plist on dependent packages: instead, go
directly use `make print-plist' to find these lists in the ports tree.
@
text
@d2 1
a2 1
# $OpenBSD: make-plist,v 1.81 2006/11/06 16:35:20 espie Exp $
d748 1
@


1.81
log
@Stripping dir: shorter diagnostic when package is not found.
@
text
@d2 1
a2 1
# $OpenBSD: make-plist,v 1.80 2006/10/07 10:04:09 espie Exp $
d534 2
a535 7
	my ($mtree, $pkgname) = @@_;
        my $true_package = OpenBSD::PackageLocator->find($pkgname);
	if (!$true_package) {
		return undef;
	}
        my $dir = $true_package->info();
	my $plist = OpenBSD::PackingList->fromfile($dir.CONTENTS, \&OpenBSD::PackingList::DirrmOnly);
a538 2
        $true_package->close();
	return 1;
d625 1
a625 1
	# add directories from dependencies, insist on having the real package.
d627 7
a633 8
	for my $pkg (split(/\s+/, $ENV{'DEPS'})) {
		next if defined $stripped->{$pkg};
		$stripped->{$pkg} = 1;
		if (augment_mtree($mtree, $ENV{'PKGREPOSITORY'}."/$pkg.tgz")) {
			print STDERR "Stripping dirs from $pkg\n";
	    	} else {
			print STDERR "NOT stripping dirs from $pkg: package not found\n";
		}
@


1.80
log
@minor cosmetic changes: do not strip packages twice.
check for empty .info files.
@
text
@d2 1
a2 1
# $OpenBSD: make-plist,v 1.79 2006/04/03 13:53:43 espie Exp $
d537 1
a537 3
		print STDERR "Can't find $pkgname\n";
		print STDERR "Directories won't be stripped\n";
		return;
d545 1
a635 1
		print STDERR "Stripping dirs from $pkg\n";
d637 5
a641 1
		augment_mtree($mtree, $ENV{'PKGREPOSITORY'}."/$pkg.tgz");
@


1.79
log
@detect more stuff that probably does not belong in PLISTs, based on the
filenames (vim .swp and emacs ~ files)

Found out by Andreas Kahari
@
text
@d2 1
a2 1
# $OpenBSD: make-plist,v 1.78 2005/12/26 19:29:34 bernd Exp $
d467 1
d634 1
d636 1
d638 1
@


1.78
log
@Display lib version in "unregistered shared lib" warning.

okay espie
@
text
@d2 2
a3 2
# $OpenBSD: make-plist,v 1.77 2005/12/23 13:30:05 bernd Exp $
# Copyright (c) 2004 Marc Espie <espie@@openbsd.org>
d936 8
@


1.77
log
@Display warnings for unregistered shared libs only once per lib.
Less chatty now.

ok espie@@
@
text
@d2 1
a2 1
# $OpenBSD: make-plist,v 1.75 2005/11/02 21:39:43 espie Exp $
d55 1
a55 1
			$lib_warnings->{$name}->{missing} = 1;
d1060 2
a1061 1
		print STDERR "WARNING: unregistered shared lib: $name\n";
@


1.76
log
@get make-plist aware of the version number variables.
@
text
@d45 1
d55 1
a55 1
			print STDERR "Warning: unregistered shared lib: $name\n";
d58 2
a59 1
				print STDERR "Warning: version mismatch for lib $name ($v vs. ", $known_libs{$name}, ")\n";
d1056 11
@


1.75
log
@error out in case we can't write files.
found out by bernd@@
@
text
@d2 1
a2 1
# $OpenBSD: make-plist,v 1.74 2005/11/02 18:58:44 espie Exp $
d42 1
a42 1
my @@backsubst;
d44 1
d48 17
d83 1
a83 1
	for my $l (@@backsubst) {
d246 12
d866 7
a872 1
	my $k = var_backsubst($i);
d909 5
a913 1
	$short = var_backsubst($short);
d967 6
a972 1
		push(@@backsubst, ["\${$back}", $v]) if $v ne '';
@


1.74
log
@complain when dependent packages are not found, and stripping won't happen
correctly...
@
text
@d2 1
a2 1
# $OpenBSD: make-plist,v 1.73 2005/10/23 10:48:39 espie Exp $
d1086 2
a1087 1
				rename($orig->{filename}, $orig->{filename}.".orig");
d1089 2
a1090 1
			$plist->tofile($plist->{filename});
@


1.73
log
@copy @@shell over, since there's no way to figure it out automatically.
@
text
@d2 1
a2 1
# $OpenBSD: make-plist,v 1.72 2005/10/18 21:05:53 aanriot Exp $
d503 5
a507 1
        return unless $true_package;
@


1.72
log
@tweak to match makeinfo's signature even with a long source filename.

better pattern and ok espie@@
@
text
@d2 1
a2 1
# $OpenBSD: make-plist,v 1.71 2005/09/07 10:40:00 espie Exp $
d777 5
@


1.71
log
@copy new annotations over.
@
text
@d2 1
a2 1
# $OpenBSD: make-plist,v 1.70 2005/09/05 13:06:01 espie Exp $
d438 1
a438 1
	if ($tag =~ /^This is .*, produced by [Mm]akeinfo(?: version |-)?.* from/) {
@


1.70
log
@some perl stuff installs manpages as ../man3p/manpage.3
@
text
@d2 1
a2 1
# $OpenBSD: make-plist,v 1.69 2005/08/10 13:09:17 espie Exp $
d944 2
a945 1
		for my $listname (qw(pkgcfl conflict groups users)) {
@


1.69
log
@libraries live in the first pass.
@
text
@d2 1
a2 1
# $OpenBSD: make-plist,v 1.68 2005/07/04 10:46:05 espie Exp $
d449 3
@


1.68
log
@show a full list of existing files before exiting.
@
text
@d2 1
a2 1
# $OpenBSD: make-plist,v 1.67 2005/04/11 11:39:12 espie Exp $
d887 3
@


1.67
log
@take @@endfake into account: mark when items are before/after @@endfake,
and run two passes if necessary to put stuff before/after @@endfake.

For now, extra stuff always gets moved after @@endfake...

This will change when I find `useful' examples.
@
text
@d2 1
a2 1
# $OpenBSD: make-plist,v 1.66 2005/02/05 11:40:31 espie Exp $
d1050 1
d1055 4
a1058 2
				die $orig->{filename}.".orig present" 
				    if -e $orig->{filename}.".orig";
d1061 3
@


1.66
log
@emit PLIST when a shared fragment is seen.
Fix long-standing buglet reported by various people, I just needed to
sit down long enough to reproduce the issue...
@
text
@d2 1
a2 1
# $OpenBSD: make-plist,v 1.65 2004/12/27 00:00:27 espie Exp $
d97 2
d148 8
d166 1
d214 1
d240 1
d252 1
d264 1
d288 1
d308 1
d334 2
d350 2
d635 1
a635 1
    my ($name, $prefix, $files, $all_plists) = @@_;
d658 4
d672 1
a672 1
	    my $origpfrag = parse_original_plist($fragname, $prefix, $files, $all_plists);
d687 3
d821 1
a821 1
	my ($i, $type, $foundfiles, $foundcomments, $allplists, $shared_only) = @@_;
d835 6
d957 16
a972 1
	handle_file($i, $files->{$i}, $foundfiles, $foundcomments, \@@l, $shared_only);
@


1.65
log
@let @@sysctl tag long.
problem noticed by sturm@@
@
text
@d2 1
a2 1
# $OpenBSD: make-plist,v 1.64 2004/11/14 19:42:04 espie Exp $
d938 1
@


1.64
log
@don't try to register anything that isn't at least a FileObject...
Found out by alek@@
@
text
@d2 1
a2 1
# $OpenBSD: make-plist,v 1.63 2004/11/13 11:49:03 espie Exp $
d232 11
@


1.63
log
@synch with packing-list changes
@
text
@d2 1
a2 1
# $OpenBSD: make-plist,v 1.62 2004/11/13 11:25:31 espie Exp $
a96 8
	my ($self, $plist, $files, $comments) = @@_;

	$self->{plist} = $plist;
	my $fullname = $self->fullname();
	if (defined $fullname) {
		my $n = main::var_backsubst($fullname);
		$files->{$n} = $self;
	}
d195 11
@


1.62
log
@fix cwd issues.
try harder to resolve links
@
text
@d2 1
a2 1
# $OpenBSD: make-plist,v 1.61 2004/10/23 06:51:54 espie Exp $
d294 2
a295 2
	if (${$self->{cwd}} ne ${$plist->{state}->{cwd}}) {
	    OpenBSD::PackingElement::Cwd->add($plist, $self->{cwd});
d591 1
a591 2
	my $p = File::Spec->canonpath($prefix);
	$plist->{state}->{cwd} = \$p;
@


1.61
log
@shared fragment in need of recording.
found by wilfried@@
@
text
@d2 1
a2 1
# $OpenBSD: make-plist,v 1.60 2004/10/17 09:20:06 espie Exp $
d294 1
a294 1
	if ($self->{cwd} ne $plist->{state}->{cwd}) {
d354 1
a354 1
			return $destdir.$l;
d356 1
a356 1
			return File::Spec->catfile(dirname($filename),$l);
d591 2
a592 1
	$plist->{state}->{cwd} = $prefix;
@


1.60
log
@forgot to copy @@newgroup and @@newuser items over.
noticed by nikolay.
@
text
@d2 1
a2 1
# $OpenBSD: make-plist,v 1.59 2004/09/18 11:03:45 espie Exp $
d73 2
a74 2
# Fragments are new PackingElement unique to make-plist, to handle
# %%thingy%%.
d922 1
a922 1
if ($default->{wantshared} && !$default->{hasshared}) {
@


1.59
log
@clone new-style conflicts too
@
text
@d2 1
a2 1
# $OpenBSD: make-plist,v 1.58 2004/09/14 22:24:39 espie Exp $
d232 1
a232 1
package OpenBSD::PackingElement::Exec;
a254 6
package OpenBSD::PackingElement::Unexec;
sub register
{
	&OpenBSD::PackingElement::Exec::register;
}

d266 1
a266 1
package OpenBSD::PackingElement::DirBase;
a273 6
package OpenBSD::PackingElement::DirRm;
sub add_to_mtree
{
	&OpenBSD::PackingElement::DirBase::add_to_mtree;
}

d315 4
d890 6
a895 10
		if (defined $orig->{pkgcfl}) {
			for my $cfl (@@{$orig->{pkgcfl}}) {
				$cfl->clone()->add_object($plist);
				$plist->{nonempty} = 1;
			}
		}
		if (defined $orig->{conflict}) {
			for my $cfl (@@{$orig->{conflict}}) {
				$cfl->clone()->add_object($plist);
				$plist->{nonempty} = 1;
@


1.58
log
@- lots of comments
- Mtree module, shared with check-common-dirs
- update list of `known' directories to match actual OpenBSD, so
that stuff outside of /usr/local will work.
- drop dead if destdir does not exist (e.g., fake got a problem)
- if a file is found in a fragment, and as a comment in the original
file, then that was a limitation of the old make-plist: don't look at
the comment.
- copy modes for @@sample
- do fragments for multi-packages too.
- pass existing files around for more accurate @@exec tests.
- don't copy install-info/mkdir if files/dir have been found.
- register dirrm dir as dir/, but using original object, so that it will
need to be found once to be accounted for.
- don't register extra as `files', otherwise we end up with bogus
${SYSCONFDIR}/file entries.
- classify directories and files in a unified way.
- more thorough tests for info files, more names, look at two lines context.
- ibid dir file.
- ibid subinfo.
- provide a way to erase a directory that only holds one file.
- use for .packlist, perllocal.pod.
- use perl Config to look for those in the right location.
- don't look at file dates, we always use fake.
- special case /etc/X11/app-defaults becomes /usr/local/lib/X11/app-defaults
- use plist state info to avoid extraneous mode/owner/group entries.
- sort comments that are not accounted for.
- warn about .orig files.
- man pages for linux.
- don't backsubst SYSCONFDIR except at start of line.
- handle @@comment @@dir like @@comment @@dirrm.
- respect fragment locations
- put %%SHARED%% at top by default.
- handle recursive fragments correctly (simpler code, needs pkg_add support)
- mark genuine fragments, and don't try to write empty ones, assuming
the chosen flavor doesn't hold the required information.
@
text
@d2 1
a2 1
# $OpenBSD: make-plist,v 1.57 2004/08/11 09:40:17 espie Exp $
d900 6
@


1.57
log
@Use original item to build new one: so we can clone things we do not yet
detect, like @@mandir and @@fontdir.

more precise logic for changes: do not check for orig files and die if
nothing changed.
@
text
@d2 1
a2 1
# $OpenBSD: make-plist,v 1.56 2004/08/10 21:01:01 espie Exp $
d17 7
d30 1
d38 3
d45 2
d53 5
a57 1
		s/\Q$v\E/$r/g;
d73 17
d111 10
d139 6
a144 1
			$t->clone()->add_object($plist);
d146 4
d156 1
a156 1
sub copy_extra
d158 5
a162 5
	my ($self, $plist) = @@_;

	$self->clone()->add_object($plist);
	if ($self->{name} eq "SHARED") {
		$plist->{hasshared} = 1;
a163 1
	$plist->{nonempty} = 1;
d168 9
a176 7
	my ($self, $pfragbase) = @@_;
	return if $self->{name} eq "SHARED";
	my $n = $pfragbase.".".$self->{name};
	if (-f $n) {
		return $n;
	}
	return;
d191 7
a197 6
	my ($self, $pfragbase) = @@_;
	my $n = $pfragbase.".no-".$self->{name};
	if (-f $n) {
		return $n;
	}
	return;
d209 9
a217 1
	$plist->{state}->{lastfile} = $self;
d235 15
a249 3
	my ($self, $plist, $files, $comments) = @@_;
	if (defined $plist->{state}->{lastfile}) {
	    $plist->{state}->{lastfile}->tag_along($self);
d264 6
a269 1
	&OpenBSD::PackingElement::Exec::register;
d293 1
a293 1
	if ($name =~ m/^\@@dirrm\s+/) {
d295 3
a297 2
		my $o = OpenBSD::PackingElement::Comment->new($'.'/');
		$o->register($plist, $files, $comments);
d313 4
d328 3
d334 2
a335 2
	if (is_info($filename)) {
		return "info";
d338 2
d353 3
d404 1
a404 1
	return 0 unless $filename =~ m/\.info$/;
d409 1
d411 1
a411 1
	if ($tag =~ /^This is .*, produced by [Mm]akeinfo version .* from/) {
d421 1
a421 1
	if (m,/man/(?:[^/]*?/)?man(.*?)/[^/]+\.\1(?:\.gz|\.Z)?$,) {
d437 13
a449 1
	return 1;
d455 8
a462 2
	return 0 unless $filename =~ m/^(.*\.info)\-\d+$/;
	return is_info($1);
d466 2
a467 26
# read an mtree file, and produce the corresponding directory hierarchy
sub parse_mtree 
{
		# start under current DESTDIR, usually
	my $current = "/";
	my %mtree;
	open my $file, '<', shift;
	while(<$file>) {
		chomp;
		s/^\s*//;
		next if /^\#/ || /^\//;
		s/\s.*$//;
		next if /^$/;
		if ($_ eq '..') {
			$current =~ s|/[^/]*$||;
			next;
		} else {
			$current.="/$_";
		}
		$_ = $current;
		while (s|/\./|/|)	{}
		$mtree{File::Spec->canonpath($_)} = 1;
	}
	close $file;
	return \%mtree;
}
d492 29
d523 1
a523 4
	# compare all files against those dates
	my @@date = (stat $ENV{INSTALL_PRE_COOKIE})[9, 10];
	my (%files, %dirs);
	my %occupied;
d525 6
d535 14
a548 10
			my @@cdate = (lstat $_)[9, 10];
			if ($cdate[0] >= $date[0] || $cdate[1] >= $date[1]) {
				if (-d _) {
					$dirs{undest($File::Find::name)} = 1;
				} else {
					$files{undest($File::Find::name)} = get_type($File::Find::name);
				}
			} else {
				$occupied{undest($File::Find::dir)} = 1;
			}
d550 2
a551 9
# occupied marks a dir that was already there... 
# so all parents had to be around too
	for my $d (keys %occupied) {
		while ($d ne '') {
			delete $dirs{$d} if defined $dirs{$d};
			$d =~ s|/.*?/?$||;
		}
	}
	return (\%dirs, \%files);
d554 1
d557 1
a557 1
	my ($dirs, $files) = scan_destdir();
d559 8
a566 2
	my $mtree = parse_mtree($ENV{'MTREE_FILE'});
	# and directories for dependencies as well
d573 1
a573 4
		delete $dirs->{$d}
	}
	for my $d (keys %$dirs) {
		$files->{$d} = "directory";
d578 1
d592 1
d605 1
d608 1
a608 1
    my ($name, $prefix) = @@_;
d610 1
d612 1
d630 5
a634 1
    delete $plist->{state}->{lastfile};
d636 7
a642 1
    	$item->register($plist, $foundfiles, $foundcomments);
d647 1
d659 11
d672 1
a672 1
	my $prefixes = shift;
d675 1
a675 1
	my @@l = ();
d684 2
a685 1
	my $origplist = parse_original_plist($plistname, $prefix);
a686 10
	push(@@l, $plist);
	# Try to handle fragments
	for my $item (@@{$origplist->{items}}) {
		my $fragname = $item->deduce_fragment($pfragname);
		next unless defined $fragname;
		my $pfrag = create_packinglist($fragname, $prefix);
		my $origpfrag = parse_original_plist($fragname, $prefix);
		replaces($origpfrag, $pfrag);
		push(@@l, $pfrag);
	}
d689 1
d691 1
a691 1
	my $origshared = parse_original_plist($psharedname, $prefix);
a692 1
	push(@@l, $pshared);
d702 3
a704 2
			$o = parse_original_plist("$plistname$sub", $prefixes->{$sub}) or
			    $o = parse_original_plist("$altplistname$sub", $prefixes->{$sub});
d706 1
a706 1
			push(@@l, $n);
d709 1
a709 1
			$o = parse_original_plist("$psharedname$sub", $prefixes->{$sub});
d711 1
a711 1
			push(@@l, $ns);
d714 1
a714 1
	return @@l;
d717 1
d744 41
d803 1
d832 1
d840 4
d848 1
a848 17
		if (defined $item) {
			if (defined $item->{mode}) {
				OpenBSD::PackingElement::Mode->add($p, $item->{mode});
			}
			if (defined $item->{owner}) {
				OpenBSD::PackingElement::Owner->add($p, $item->{owner});
			}
			if (defined $item->{group}) {
				OpenBSD::PackingElement::Group->add($p, $item->{group});
			}
			if (defined $item->{nochecksum}) {
				$o->{nochecksum} = 1;
			}
			if (defined $item->{ignore}) {
				$o->{ignore} = 1;
			}
		}
a850 11
		if (defined $item) {
			if (defined $item->{mode}) {
				OpenBSD::PackingElement::Mode->add($p, '');
			}
			if (defined $item->{owner}) {
				OpenBSD::PackingElement::Owner->add($p, '');
			}
			if (defined $item->{group}) {
				OpenBSD::PackingElement::Group->add($p, '');
			}
		}
d879 1
a879 1
my @@l = grab_all_lists(\%prefix);
d929 1
a929 1
	OpenBSD::PackingElement::Fragment->add($default, "SHARED");
d932 2
a933 2
while (my ($k, $v) = each %$foundcomments) {
	next if defined $v->{accounted_for};
d938 5
d981 7
a987 3
				print $plist->{filename}, " empty\n";
				$something_changed = 1;
				$plist->{changed} = 1;
@


1.56
log
@better diagnostic logic:
first output all PLISTs in a tmp dir, then compare with
original set, and report all differences.
Then check that original can be moved to orig, and do the move.
That way, make plist on a set of unchanged lists will be silent,
and can be used irregardless of the presence of P*.orig files.
@
text
@d2 1
a2 1
# $OpenBSD: make-plist,v 1.55 2004/08/10 08:45:21 espie Exp $
d579 1
a579 1
	my ($type, $short) = @@_;
d582 7
d646 1
a646 1
	my $o = create_object($type, $short);
d798 1
d805 1
d810 1
d816 1
d822 7
a828 5
	for my $plist (@@l) {
		my $orig = $plist->{original};
		if (defined $orig) {
			die $orig->{filename}.".orig present" 
			    if -e $orig->{filename}.".orig";
@


1.55
log
@register sample dirs.
@
text
@d2 1
a2 1
# $OpenBSD: make-plist,v 1.54 2004/08/09 12:48:56 espie Exp $
d27 1
a768 7
for my $plist (@@l) {
	my $orig = $plist->{original};
	if (defined $orig) {
		die $orig->{filename}.".orig present" 
		    if -e $orig->{filename}.".orig";
	}
}
d779 3
d783 1
a785 1
			print $plist->{filename}, " is empty\n";
d788 24
d814 2
a815 1
			rename($orig->{filename}, $orig->{filename}.".orig");
d817 7
a823 5
		$plist->tofile($plist->{filename});
		if (defined $orig) {
			if (compare($plist->{filename}, $orig->{filename}.".orig") == 0) {
				print $plist->{filename}, " unchanged, removing ", $orig->{filename}.".orig\n";
				unlink($orig->{filename}.".orig");
d825 1
@


1.54
log
@more accurate info test.
@
text
@d2 1
a2 1
# $OpenBSD: make-plist,v 1.53 2004/08/09 12:41:03 espie Exp $
d163 2
d180 6
@


1.53
log
@next -> return
@
text
@d2 1
a2 1
# $OpenBSD: make-plist,v 1.52 2004/08/09 12:35:45 espie Exp $
d308 1
a308 1
	if ($tag =~ /^This is .*, produced by makeinfo version .* from/) {
@


1.52
log
@next->return
@
text
@d2 1
a2 1
# $OpenBSD: make-plist,v 1.51 2004/08/09 10:24:26 espie Exp $
d631 1
a631 1
	next unless defined $o;
@


1.51
log
@convenience functions so that main isn't that big.
Mark comments that have been accounted for, and show the remaining ones.
@
text
@d2 1
a2 1
# $OpenBSD: make-plist,v 1.50 2004/08/08 18:09:04 espie Exp $
d620 1
a620 1
		next;
@


1.50
log
@do local uid/gid changes so that tempfiles will get removed correctly.
@
text
@d2 1
a2 1
# $OpenBSD: make-plist,v 1.49 2004/08/08 16:43:15 espie Exp $
d568 3
a570 1
my %prefix;
d572 10
a581 27
while ($ARGV[0] =~ m/^PREFIX(-.*?)\=/) {
	my ($sub, $v) = ($1, $');
	$prefix{$sub} = $v;
	shift @@ARGV;
}
$prefix{''}=$ENV{'TRUEPREFIX'};
	
for (@@ARGV) {
	if (m/\=/) {
		my $back = $`;
		my $v = $';
		push(@@backsubst, ["\${$back}", $v]) if $v ne '';
	}
}


my $files = get_files();

my @@l = grab_all_lists(\%prefix);

for my $plist (@@l) {
	my $orig = $plist->{original};
	if (defined $orig and 
	    defined $orig->{cvstags}) {
		for my $tag (@@{$orig->{cvstags}}) {
			$tag->clone()->add_object($plist);
		}
d583 1
a583 15
	    OpenBSD::PackingElement::CVSTag->add($plist, '$OpenBSD'.'$');
	}
	# copy properties over
	if (defined $orig) {

		if (defined $orig->{'no-default-conflict'}) {
			OpenBSD::PackingElement::NoDefaultConflict->add($plist);
			$plist->{nonempty} = 1;
		}
		if (defined $orig->{pkgcfl}) {
			for my $cfl (@@{$orig->{pkgcfl}}) {
				$cfl->clone()->add_object($plist);
				$plist->{nonempty} = 1;
			}
		}
d587 3
a589 7
my $default = $l[0];
my $shared_only;
if (defined $ENV{'SHARED_ONLY'}) {
	if ($ENV{'SHARED_ONLY'} =~ m/^Yes$/i) {
		$shared_only = 1;
	}
}
d591 1
a591 1
for my $i (sort keys %$files) {
d605 1
a605 1
		for my $try (@@l) {
a628 1
	my $type = $files->{$i};
d630 2
a631 14
	my $o;
	if ($type eq "directory") {
		$o = OpenBSD::PackingElement::Dir->new($short);
	} elsif ($type eq "manpage") {
		$o = OpenBSD::PackingElement::Manpage->new($short);
	} elsif ($type eq "dir" || $type eq "subinfo") {
		next;
	} elsif ($type eq "info") {
		$o = OpenBSD::PackingElement::InfoFile->new($short);
	} elsif ($type eq "library") {
		$o = OpenBSD::PackingElement::Lib->new($short);
	} else {
		$o = OpenBSD::PackingElement::File->new($short);
	}
d634 1
d682 59
d750 1
d753 5
@


1.49
log
@run update-plist as root, to catch all files.
pass OWNER/GROUP around and setuid/gid to them before writing
files to keep ownership.
@
text
@d2 1
a2 1
# $OpenBSD: make-plist,v 1.48 2004/08/08 14:13:41 espie Exp $
a26 1
use POSIX;
d748 2
a749 6
if (defined $ENV{'GROUP'}) {
	POSIX::setgid($ENV{'GROUP'});
}
if (defined $ENV{'OWNER'}) {
	POSIX::setuid($ENV{'OWNER'});
}
d751 2
a752 4
for my $plist (@@l) {
	if (!$plist->{nonempty}) {
		print $plist->{filename}, " is empty\n";
		next;
d754 2
a755 3
	my $orig = $plist->{original};
	if (defined $orig) {
		rename($orig->{filename}, $orig->{filename}.".orig");
d757 16
a772 5
	$plist->tofile($plist->{filename});
	if (defined $orig) {
		if (compare($plist->{filename}, $orig->{filename}.".orig") == 0) {
			print $plist->{filename}, " unchanged, removing ", $orig->{filename}.".orig\n";
			unlink($orig->{filename}.".orig");
@


1.48
log
@reset lastfile before register, so that exec/unexec at start of PLIST
don't get register with the last file.
Add tag_marker `lastfile' placeholder to catch exec/unexec at start
and reproduce them faithfully.
@
text
@d2 1
a2 1
# $OpenBSD: make-plist,v 1.47 2004/08/07 07:47:38 espie Exp $
d27 1
d747 7
@


1.47
log
@use File::Spec to resolve link. Add missing '/' when needed.
@
text
@d2 1
a2 1
# $OpenBSD: make-plist,v 1.46 2004/08/06 10:24:19 espie Exp $
d88 12
d172 3
a174 1
    	}
d477 1
d495 1
d509 1
d722 1
a722 6
			if (defined $item->{tags}) {
				for my $t (@@{$item->{tags}}) {
					$t->clone()->add_object($p);
					$p->{nonempty} = 1;
				}
			}
@


1.46
log
@shared lib markers, ditch DYNLIBDIR.
@
text
@d2 1
a2 1
# $OpenBSD: make-plist,v 1.45 2004/08/06 09:37:15 espie Exp $
d248 1
a248 1
			return dirname($filename).$l;
@


1.45
log
@more stringent checks on dynamic library name.
Distinguish between library and plugin.
Saner check for DYNLIBDIR.
@
text
@d2 1
a2 1
# $OpenBSD: make-plist,v 1.44 2004/08/05 23:51:44 espie Exp $
d656 2
a689 3
		if ($type eq 'library' && dirname($i) eq '/usr/local/lib') {
			$p->{wantdynlibdir} = 1;
		}
d745 1
a745 6
	open my $fh, '>', $plist->{filename};
	$plist->write($fh);
	if ($plist->{wantdynlibdir}) {
		print $fh "DYNLIBDIR(\%D/lib)\n";
	}
	close $fh;
@


1.44
log
@use clone() to copy objects when either we can, avoiding truncation problems
if inheritance is used.
Fixes @@extra dir/  copying.
@
text
@d2 1
a2 1
# $OpenBSD: make-plist,v 1.43 2004/08/05 23:43:45 espie Exp $
d233 2
d255 1
a255 1
sub is_library
a257 2

	return 0 unless $filename =~ m/\.so(?:\.\d+\.\d+)?$/;
d268 17
a284 1
		
d666 1
a666 1
		if ($type eq 'library' && (!defined $item) && !$shared_only) {
d688 1
a688 1
		if ($type eq 'library' && $i=~ m|^/usr/local/lib/lib[^/]*\.so\.\d+\.\d+$|) {
@


1.43
log
@almost completely new make-plist.
The new version uses the pkg_* infrastructure to read existing plists
and produced new plists.
Lots and lots of improvements:
- copy most stuff over from original lists correctly. For instance,
attach @@exec/@@unexec/@@sample to other files and copy them in the right
location.
- generic post-treatment of @@commnent, using stringize(), so that most
things can be commented out and will stay commented out.
- parse all packing-lists using relevant PREFIXes. Grab PFRAG.xx if %xx%
is seen.
- walk through all of fake, and distpatch files according to PREFIXes
if nothing else works.
- identifies man, libraries, info, handling symlink correctly.
@
text
@d2 1
a2 1
# $OpenBSD$
d94 1
a94 2
	my $o = $self->clone();
	$o->add_object($plist);
d205 1
a205 1
	OpenBSD::PackingElement::Extra->add($plist, $self->{name});
d215 1
a215 1
	OpenBSD::PackingElement::ExtraUnexec->add($plist, $self->{name});
d562 1
a562 1
			OpenBSD::PackingElement::CVSTag->add($plist, $tag->{name});
d576 1
a576 1
				OpenBSD::PackingElement::PkgConflict->add($plist, $cfl->{name});
d692 1
a692 2
					my $c = $t->clone();
					$c->add_object($p);
@


1.42
log
@if SHARED_ONLY=Yes, don't bother moving libraries to a PFRAG.shared.
@
text
@d1 15
a15 1
#!/usr/bin/perl -w
d17 54
a70 1
# $OpenBSD: make-plist,v 1.41 2004/08/03 10:51:47 espie Exp $
d72 15
a86 23
#  Copyright (c) 1999 Marc Espie
# 
#  Redistribution and use in source and binary forms, with or without
#  modification, are permitted provided that the following conditions
#  are met:
#  1. Redistributions of source code must retain the above copyright
#     notice, this list of conditions and the following disclaimer.
#  2. Redistributions in binary form must reproduce the above copyright
#     notice, this list of conditions and the following disclaimer in the
#     documentation and/or other materials provided with the distribution.
# 
#  THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND
#  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
#  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
#  ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE
#  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
#  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
#  OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
#  HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
#  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
#  OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
#  SUCH DAMAGE.
# 
d88 24
d113 96
a208 1
use strict;
d210 4
d215 4
a218 5
use IO::File;
use File::Find;
use File::Spec;
use File::Compare;
use File::Temp qw/ tempdir /;
d220 16
a235 9
my $manual = 0;
my %out;
my @@has_shared;
my @@tocheck=();
my ($plist, $pshared);
my $shared_only;
if (defined $ENV{'SHARED_ONLY'}) {
	if ($ENV{'SHARED_ONLY'} =~ m/^Yes$/i) {
		$shared_only = 1;
d239 14
d259 1
d274 1
d289 4
a292 1
	if (m/\/man\/man(.*?)\/[^\/]+\.\1(?:\.gz|\.Z)?$/) {
d295 1
a295 1
	if (m/\/man\/cat.*?\/[^\/]+\.0(?:\.gz|\.Z)?$/) {
a314 90
{
package Annotation;

sub new {
    my $class = shift;
    bless {}, $class;
}

sub add {
    my $object = shift;
    my $key = shift;
    unless (defined $object->{$key}) {
    	$object->{$key} = [];
    }
    push(@@{$object->{$key}}, @@_);
}
}

my $annotated = new Annotation;
my $annotated_dir = new Annotation;

sub annotate
{
	my ($oldfh, $name, $newfh, $is_shared) = @@_;
	my $comment_printed = 0;
	my ($mode, $owner, $group, $nocheck) = ('', '', '', '');
	while(<$oldfh>) {
		chomp;
		if (m/^\@@mode\s*/) {
			$mode = $';
		} elsif (m/^\@@owner\s*/) {
			$owner = $';
		} elsif (m/^\@@group\s*/) {
			$group = $';
		} elsif (m/^\@@comment\s+no checksum$/) {
			$nocheck = 1;
		} elsif (m/^\@@option no-default-conflict/||m/^\@@pkgcfl/) {
			printf $newfh "$_\n";
		} elsif (m/^\@@exec\s+/ || m/^\@@unexec\s+/) {
			$_=$';
			# we don't warn for stuff we probably added...
			next if m/^mkdir -p/||m/^install-info /;
			$manual = 1;
		} elsif (m/^\@@comment\s+\$OpenBSD\:.*\$$/) {
			print $newfh "$_\n";
			$comment_printed = 1;
			next;
		} elsif (m/^\@@comment\s+/) {
			$_ = $';
			if (m/^\@@dirrm\s+(\S.*)/ || m/^\@@dir\s+(\S.*)/ || m/^([^@@].*)\/$/) {
				$_ = $1;
				$annotated_dir->add($_,  [ $name, $newfh, $is_shared, 'comment']);
				next;
			} else {
				$annotated->add($_, [ $name, $newfh, $is_shared, 'comment' ] );
			}
			next;
		} elsif (m/^\@@dirrm\s+(\S.*)/ || m/^\@@dir\s+(\S.*)/ || m/^([^@@].*)\/$/) {
			$_=$1;
			$annotated_dir->add($_, [ $name, $newfh, $is_shared ]);
			next;
		} elsif (m/^\@@extra\b/ || m/^\@@extraunexec\b/) {
			$manual = 1;
			next;
		} elsif (m/^\@@info\s+/) {
			$_=$';
		} elsif (m/^\@@man\s+/) {
			$_=$';
		} elsif (m/^\@@/) {
			$manual = 1;
			next;
		} elsif (m/^\!?\%\%(.*)\%\%/) {
			my $frag = $1;
			if ($frag ne "SHARED") {
				print $newfh "$_\n";
				$manual = 1;
			}
		} elsif (m/\$\{.*\}/) {
			$manual = 1;
		}

		if ("$mode$owner$group$nocheck" ne '') {
			$annotated->add($_, [ $name, $newfh, $is_shared, $mode, $owner, $group, $nocheck ]);
			$nocheck = '';
		} else {
			$annotated->add($_, [ $name, $newfh, $is_shared ]);
		}
	}
	print $newfh "\@@comment \$OpenBSD\$\n" unless $comment_printed;
}
d320 1
a320 2
	my $current = shift;
	local(*FILE);
d322 2
a323 2
	open FILE, $ENV{MTREE_FILE};
	while(<FILE>) {
d337 1
a337 1
		$mtree{$_} = 1;
d339 1
a339 1
	close FILE;
d343 12
a354 3
# prefix to remove from everything
my $base = $ENV{PREFIX};
my @@backsubst;
d356 1
a356 1
sub strip 
d358 3
a360 6
	local($_) = shift;
	s|^\Q$base\E/||;
	for my $l (@@backsubst) {
		my $v = $l->[1];
		my $r = $l->[0];
		s/\Q$v\E/$r/g;
d362 2
a363 7
	# If the resulting name is arch-dependent, we warn.
	# We don't fix it automatically, as this may need special handling.
	if (m/i386|m68k|sparc/) {
	    print STDERR "make-plist: generated plist contains arch-dependent\n"; 
	    print STDERR "\t$_\n";
	}
	return $_;
d366 1
a366 1
sub augment_mtree
d368 26
a393 25
	my ($mtree, $dst, $pkg) = @@_;
	my $basepath;
	local(*FILE);
	system("tar zxqf $pkg +CONTENTS");
	open(FILE, '<', '+CONTENTS') or 
		die "Error in dependent package $pkg\n";
	while (<FILE>) {
		chomp;
		if (m/^\@@dirrm\b/ || m/^\@@dir\b/) {
			die "Badly formed package: $pkg\n";
		} 
		if (m/^\@@cwd\s+/) {
			$basepath = $';
			last;
		}
	}
	unless (defined $basepath and
	File::Spec->file_name_is_absolute($basepath)) {
		die "Badly formed package: $pkg\n";
	}
	while (<FILE>) {
		chomp;
		if (m/^\@@dirrm\s+(\S.*)/ || m/^\@@dir\s+(\S.*)/ || m/^([^@@].*)\/$/) {
			my $filename= File::Spec->catfile($dst, $basepath, $1);
			$mtree->{$filename} = $pkg;
d396 1
a396 2
	close(FILE);
	unlink('+CONTENTS');
d399 1
a399 1
sub handle_file
d401 1
a401 9
    my ($newdir, $item, $out, $is_lib) = @@_;
    my $fname = strip($item);
    my $string = "$fname\n";
    if (is_info $item) {
    	$string= "\@@info $string";
    }
    if (is_manpage $item) {
    	$string="\@@man $string";
    }
d403 9
a411 11
    if (defined $newdir->{$item}) {
	if (defined $annotated_dir->{$fname}) {
		for my $l (@@{$annotated_dir->{$fname}}) {
		    if (@@$l == 4) {
			    $l->[1]->print("\@@comment $fname/\n");
		    } else {
			    $l->[1]->print("$fname/\n");
		    }
		}
	} else {
		$out{$plist}->print("$fname/\n");
d413 2
a414 27
    } else {
    	my $reported = 0;
	if (defined $annotated->{$fname}) {
	    for my $l (@@{$annotated->{$fname}}) {
	    	next if $is_lib && !$l->[2];
		if (@@$l == 4) {
			$l->[1]->print("\@@comment $string");
		} elsif (@@$l == 3) {
			$l->[1]->print($string);
		} else {
		    my ($outname, $fh, $is_shared, $mode, $owner, $group, $nocheck) = @@$l;
		    if ($mode ne '') {
			    $string="\@@mode $mode\n$string\@@mode\n";
		    }
		    if ($owner ne '') {
			    $string="\@@owner $owner\n$string\@@owner\n";
		    }
		    if ($group ne '') {
			    $string="\@@group $group\n$string\@@group\n";
		    }
		    if ($nocheck ne '') {
			    $string="\@@comment no checksum\n$string";
		    }
		    print $fh $string;
		}
		$reported = 1;
	    }
d416 1
a416 2
	print $out $string unless $reported;
    }
d419 1
a419 1
sub may_annotate_and_move
d421 4
a424 16
	my ($p, $is_shared) = @@_;

	if (-e $p) {
	    if (defined $out{$p}) {
	    	die "File handle for $p already exists";
	    }
	    my $fh = new IO::File "<$p";
	    rename($p, "$p.orig") or die "Can't rename $p to $p.orig";
	    push(@@tocheck, $p);
	    my $newfh = new IO::File ">$p";
	    annotate($fh, $p, $newfh, $is_shared);
	    close $fh;
	    $out{$p} = $newfh;
	    return 1;
    	} else {
		return 0;
d426 2
d430 13
d444 18
a461 42
my (%newdir, %occupied, %ldconfig, %has_stuff, @@files, @@libfiles);
die "Update bsd.port.mk" if @@ARGV == 0;
my $plistdir = shift;
die "Update bsd.port.mk" if -f $plistdir;
die "Update bsd.port.mk" 
    unless defined $ENV{'DEPS'} and defined $ENV{'PKGREPOSITORY'};
die "Update bsd.port.mk"
    unless defined $ENV{'PLIST'} and defined $ENV{'PFRAG'};
$plist = $ENV{'PLIST'};
$pshared = $ENV{'PFRAG'}.'.shared';
if (-e "$plist.orig" or -e "$pshared.orig") {
	die "You must clean up old files first";
}

my $destdir = $ENV{DESTDIR};

my $mtree = parse_mtree($destdir);

# and directories for dependencies as well
my $tmpdir = tempdir( CLEANUP => 1);
chdir($tmpdir);
for my $pkg (split(/\s+/, $ENV{'DEPS'})) {
	augment_mtree($mtree, $destdir, $ENV{'PKGREPOSITORY'}."/$pkg.tgz");
}

may_annotate_and_move($plist, 0);
may_annotate_and_move($pshared, 1) and push(@@has_shared, $out{$plist});


# Subpackage rules... better way would be to ask bsd.port.mk directly
my $plist2 = $plist;
$plist2 =~ s/PLIST.*$/PLIST/;

my $multi = $ENV{'MULTI_PACKAGES'};
# Normalize
$multi =~ s/^\s+//;
$multi =~ s/\s+$//;
unless ($multi eq '') {
	for my $sub (split(/\s+/, $multi)) {
		may_annotate_and_move("$plist$sub", 0) or 
		    may_annotate_and_move("$plist2$sub", 0);
		may_annotate_and_move("$pshared$sub", 1) and push(@@has_shared, $out{"$plist$sub"});
d463 79
d543 2
a544 1

a552 3
my ($name, $fh);
while (($name, $fh) = each %out) {
}
d554 3
a556 2
# compare all files against those dates
my @@date = (stat $ENV{INSTALL_PRE_COOKIE})[9, 10];
d558 12
a569 1
my %okay_files=map { $_=>1 } split(/\s+/, $ENV{'OKAY_FILES'});
d571 8
a578 14
# check the installation directory, try to make certain there is
# no file or directory outside of $base
find(
	sub {
		if ($File::Find::name eq $base) {
			$File::Find::prune = 1;
			return;
		}
		if (-d $_) {
			return if $File::Find::name eq $destdir;
			if (defined $mtree->{$File::Find::name}) {
				return;
			} else {
				print STDERR "Bogus directory: $File::Find::name\n";
a579 3
		} else {
			return if defined $okay_files{$File::Find::name};
			print STDERR "Bogus file: $File::Find::name\n";
d581 2
a582 1
	}, $destdir);
d584 7
a590 2
# recursive traversal: mark specific `info' dirs, `ldconfig' dirs,
# and potentially modified dirs
d592 21
a612 16
find(
	sub {
		my @@cdate = (lstat $_)[9, 10];
		if ($cdate[0] >= $date[0] || $cdate[1] >= $date[1]) {
			$has_stuff{$File::Find::dir} = 1;
			if (-d _) {
				$newdir{$File::Find::name} = 1;
			} else {
				if (is_dir($File::Find::name) || is_subinfo($File::Find::name)) {
					return;
				}
				if (is_library($File::Find::name) && !$shared_only) {
					$ldconfig{$File::Find::dir} = 1;
					push(@@libfiles, $File::Find::name);
				} else {
					push(@@files, $File::Find::name);
d614 1
a615 2
		} else {
			$occupied{$File::Find::dir} = 1;
d617 14
a630 1
	}, $base);
d632 56
d689 10
a698 6
# occupied marks a dir that was already there... 
# so all parents had to be around too
for my $d (keys %occupied) {
	while ($d ne '') {
		delete $newdir{$d} if defined $newdir{$d};
		$d =~ s|/.*?/?$||;
d702 7
a708 3
# make sure mtree is removed 
for my $d (keys %$mtree) {
	delete $newdir{$d}
d711 2
a712 3
unless (defined $out{$plist}) {
	$out{$plist} = new IO::File ">$plist";
	$out{$plist}->print("\@@comment \$OpenBSD\$\n");
d715 6
a720 2
for my $d (keys %newdir) {
	push @@files, $d;
d723 8
a730 13
for my $f (sort @@files) {
	handle_file(\%newdir, $f, $out{$plist}, 0);
}

for my $fh (@@has_shared) {
    	$fh->print("\%\%SHARED\%\%\n");
}


if (@@libfiles > 0) {
	unless (defined $out{$pshared}) {
		$out{$pshared} = new IO::File ">$pshared";
		$out{$pshared}->print("\@@comment \$OpenBSD\$\n");
d732 4
a735 4

    	$out{$plist}->print("\%\%SHARED\%\%\n") if @@has_shared == 0;
	for my $f (sort @@libfiles) {
	    handle_file(\%newdir, $f, $out{$pshared}, 1);
d737 5
a741 5
	for my $d (sort (keys %ldconfig)) {
		if (defined $newdir{$d}) {
			$out{$pshared}->print("NEWDYNLIBDIR(\%D/", strip($d), ")\n");
		} else {
			$out{$pshared}->print("DYNLIBDIR(\%D/", strip($d), ")\n");
a742 16
	}
}

if ($manual) {
	print STDERR "make plist: subst/frag/exec/unexec spotted in original file\n";
	print STDERR "\tMay require manual intervention\n";
}

while (my ($k, $v) = each %out) {
	close $v;
}

for my $f (@@tocheck) {
	if (compare($f, "$f.orig") == 0) {
		print STDERR "$f unchanged, removing $f.orig\n";
		unlink("$f.orig");
@


1.41
log
@file == file.orig -> rm file.orig
@
text
@d3 1
a3 1
# $OpenBSD: make-plist,v 1.40 2004/08/03 10:16:58 espie Exp $
d44 6
d457 1
a457 1
				if (is_library($File::Find::name)) {
@


1.40
log
@recognition of manpages based on the names
@
text
@d3 1
a3 1
# $OpenBSD: make-plist,v 1.39 2004/07/22 22:24:51 espie Exp $
d36 1
d42 1
d342 1
d518 11
@


1.39
log
@@@dir directory -> directory/
@
text
@d3 1
a3 1
# $OpenBSD: make-plist,v 1.37 2004/07/20 19:01:22 espie Exp $
d74 12
d166 2
d281 3
@


1.38
log
@too long a name will wrap to the next line.
@
text
@d137 2
a138 2
			if (m/^\@@dirrm\s+/ || m/^\@@dir\s+/) {
				$_ = $';
d145 2
a146 2
		} elsif (m/^\@@dirrm\s+/ || m/^\@@dir\s+/) {
			$_=$';
d251 2
a252 2
		if (m/^\@@dirrm\s+/ || m/^\@@dir\s+/) {
			my $filename= File::Spec->catfile($dst, $basepath, $');
d273 1
a273 1
			    $l->[1]->print("\@@comment \@@dir $fname\n");
d275 1
a275 1
			    $l->[1]->print("\@@dir $fname\n");
d279 1
a279 1
		$out{$plist}->print("\@@dir $fname\n");
@


1.37
log
@add routines for genuine recognition of info files and libraries.
As a result, this recognition must happen when we know the files
exist, e.g., at find time.

Adjust the auto-migration of shared objects to PFRAG.shared so that
it doesn't migrate subpackage files to the main package.

Simplify info handling slightly by just writing @@info thingy.info.

XXX note that some info files will have to be patched to have proper
category/direntry tags.

okay naddy@@
@
text
@d3 1
a3 1
# $OpenBSD: make-plist,v 1.36 2004/07/18 22:47:44 espie Exp $
d67 1
a67 1
	if ($tag =~ /^This is .*, produced by makeinfo version .* from /) {
@


1.36
log
@teach make-plist about @@dir: converts @@dirrm to @@dir in the correct location.
Also warns about @@extra/@@extraunexec not getting copied over (we should
copy them at the end of the correct PLIST).
@
text
@d3 1
a3 1
# $OpenBSD: make-plist,v 1.35 2004/07/03 17:50:52 sturm Exp $
d43 45
a107 1
my $info_file = new Annotation;
d111 1
a111 3
	my $oldfh = shift;
	my $name = shift;
	my $newfh = shift;
d139 1
a139 1
				$annotated_dir->add($_,  [ $name, $newfh, 'comment']);
d142 1
a142 1
				$annotated->add($_, [ $name, $newfh, 'comment'] );
d147 1
a147 1
			$annotated_dir->add($_, [ $name, $newfh ]);
d152 2
d155 1
d168 1
a168 1
			$annotated->add($_, [ $name, $newfh, $mode, $owner, $group, $nocheck ]);
d170 2
a171 5
		} elsif (not /\.so(?:\.\d+\.\d+)?$/) {
			$annotated->add($_, [ $name, $newfh ]);
		}
		if (m/\.info$/) {
			$info_file->add($_, [ $name, $newfh ]);
a226 18
sub add_info 
{
	my ($header, $info_dir) = @@_;
	for my $d (sort (keys %$info_dir) ) {
	    for my $f (sort @@{$info_dir->{$d}}) {
		my $d2 = strip($d);
		my $f2 = "$d2/$f";
		if (defined $info_file->{$f2}) {
		    for my $l (@@{$info_file->{$f2}}) {
			$l->[1]->print("$header --info-dir=\%D/$d2 \%D/$f2\n");
		    }
		} else {
		    $out{$plist}->print("$header --info-dir=\%D/$d2 \%D/$f2\n");
		}
	    }
	}
}

d262 1
a262 1
    my ($newdir, $item, $out) = @@_;
d265 3
d272 1
a272 1
		    if (@@$l == 3) {
d282 1
d285 2
a286 1
		if (@@$l == 3) {
d288 1
a288 1
		} elsif (@@$l == 2) {
d291 1
a291 1
		    my ($outname, $fh, $mode, $owner, $group, $nocheck) = @@$l;
d306 1
a307 2
	} else {
	    print $out $string;
d309 1
d315 1
a315 1
	my $p = shift;
d324 1
a324 1
	    annotate($fh, $p, $newfh);
d334 1
a334 1
my (%newdir, %occupied, %ldconfig, %has_stuff, %info_dir, @@files, @@libfiles);
d359 2
a360 2
may_annotate_and_move($plist);
may_annotate_and_move($pshared) and push(@@has_shared, $out{$plist});
d373 3
a375 3
		may_annotate_and_move("$plist$sub") or 
		    may_annotate_and_move("$plist2$sub");
		may_annotate_and_move("$pshared$sub") and push(@@has_shared, $out{"$plist$sub"});
d428 4
a431 1
				if (/\.so\.\d+\.\d+$/ || /\.so$/) {
a433 2
				} elsif (/\.so$/) {
					push(@@libfiles, $File::Find::name);
a435 5
					if (/\.info$/) {
						my $d = $File::Find::dir;
						$info_dir{$d} = [] unless defined $info_dir{$d};
						push(@@{$info_dir{$d}}, $_);
					}
a462 2
add_info('@@unexec install-info --delete', \%info_dir);

d468 1
a468 1
	handle_file(\%newdir, $f, $out{$plist}) unless ($f =~ m|/dir$|) && (defined $info_dir{$`});
d484 1
a484 1
	    handle_file(\%newdir, strip($f), $out{$pshared});
a493 2

add_info('@@exec install-info', \%info_dir);
@


1.35
log
@permit moving of shared objects and shared libraries from PLIST
to PFRAG.shared automatically
@
text
@d3 1
a3 1
# $OpenBSD: make-plist,v 1.34 2004/06/29 20:26:08 pvalchev Exp $
d95 1
a95 1
			if (m/^\@@dirrm\s+/) {
d103 1
a103 1
		} elsif (m/^\@@dirrm\s+/) {
d107 3
d213 1
a213 1
		if (m/^\@@dirrm\s+/) {
d227 1
a227 1
		if (m/^\@@dirrm\s+/) {
d238 2
a239 2
    my $fname = strip(shift);
    my $out = shift;
d242 8
a249 13
    if (defined $annotated->{$fname}) {
    	for my $l (@@{$annotated->{$fname}}) {
	    if (@@$l == 3) {
		    $l->[1]->print("\@@comment $string");
	    } elsif (@@$l == 2) {
		    $l->[1]->print($string);
	    } else {
		my ($outname, $fh, $mode, $owner, $group, $nocheck) = @@$l;
		if ($mode ne '') {
			$string="\@@mode $mode\n$string\@@mode\n";
		}
		if ($owner ne '') {
			$string="\@@owner $owner\n$string\@@owner\n";
d251 25
a275 5
		if ($group ne '') {
			$string="\@@group $group\n$string\@@group\n";
		}
		if ($nocheck ne '') {
			$string="\@@comment no checksum\n$string";
a276 1
		print $fh $string;
d278 2
a280 2
    } else {
    	print $out $string;
d399 1
a399 1
				if (/\.so\.\d+\.\d+$/) {
d423 1
a423 1
		undef $newdir{$d} if defined $newdir{$d};
d430 1
a430 1
	undef $newdir{$d}
d440 4
d445 1
a445 1
	handle_file($f, $out{$plist}) unless ($f =~ m|/dir$|) && (defined $info_dir{$`});
d461 1
a461 1
	    handle_file(strip($f), $out{$pshared});
a471 23
for my $d (sort { $b cmp $a } (grep { $newdir{$_} } (keys %newdir) ) ) {
	my $dname = strip($d);
	if (defined $annotated_dir->{$dname}) {
		for my $l (@@{$annotated_dir->{$dname}}) {
		    if (!$has_stuff{$d}) {
			    $l->[1]->print("\@@exec mkdir -p \%D/$dname\n");
		    }
		    if (@@$l == 3) {
			    $l->[1]->print("\@@comment \@@dirrm $dname\n");
		    } else {
			    $l->[1]->print("\@@dirrm $dname\n");
		    }
		}
	} else {
		# case of new directory that does not hold anything: it's marked
		# for removal, but it must exist first
		if (!$has_stuff{$d}) {
			$out{$plist}->print("\@@exec mkdir -p \%D/$dname\n");
		}
		$out{$plist}->print("\@@dirrm $dname\n");
	}
}
	
@


1.34
log
@better patch, no need for ldconfig(1) on plugins; ok espie mjc
@
text
@d3 1
a3 1
# $OpenBSD: make-plist,v 1.33 2004/06/29 01:28:26 mjc Exp $
d122 1
a122 1
		} else {
@


1.33
log
@put shared objects with no version into PFRAG.shared
OK pvalchev@@ better regex suggested by espie@@
@
text
@d3 1
a3 1
# $OpenBSD: make-plist,v 1.32 2003/12/26 00:26:01 espie Exp $
d382 1
a382 1
				if (/\.so(?:\.\d+\.\d+)?$/) {
d384 2
@


1.32
log
@Report files and directories installed in WRKINST outside of PREFIX,
usually a good indication the fake process is screwing up.
Okay naddy@@
@
text
@d3 1
a3 1
# $OpenBSD: make-plist,v 1.31 2003/07/16 22:07:40 espie Exp $
d382 1
a382 1
				if (/\.so\.\d+\.\d+$/) {
@


1.31
log
@buglet fix
@
text
@d3 1
a3 1
# $OpenBSD: make-plist,v 1.30 2003/07/02 09:04:08 espie Exp $
d347 23
@


1.30
log
@add_info needs a valid filehandle.
@
text
@d3 1
a3 1
# $OpenBSD: make-plist,v 1.29 2003/07/01 14:47:53 espie Exp $
d112 1
a112 1
				printf $newfh "$_\n";
@


1.29
log
@kludge to make it work with qt3-mt...
better form would be to ask bsd.port.mk for actual PLIST names.
@
text
@d3 1
a3 1
# $OpenBSD: make-plist,v 1.28 2003/06/30 12:07:56 espie Exp $
a390 2
add_info('@@unexec install-info --delete', \%info_dir);

d395 3
@


1.28
log
@Sort info files into the right plist.
@
text
@d3 1
a3 1
# $OpenBSD: make-plist,v 1.27 2003/06/30 11:53:37 espie Exp $
d317 4
d327 2
a328 1
		may_annotate_and_move("$plist$sub");
@


1.27
log
@do not record comments twice.
@
text
@d3 1
a3 1
# $OpenBSD: make-plist,v 1.26 2003/06/30 11:49:41 espie Exp $
d63 1
d125 3
d184 11
a194 5
	my ($header, $infodir) = @@_;
	for my $d (sort (keys %$infodir) ) {
		for my $f (sort @@{$infodir->{$d}}) {
			my $d2 = strip($d);
			$out{$plist}->print("$header --info-dir=\%D/$d2 \%D/$d2/$f\n");
d196 1
d288 1
a288 1
my (%newdir, %occupied, %ldconfig, %has_stuff, %infodir, @@files, @@libfiles);
d361 2
a362 2
						$infodir{$d} = [] unless defined $infodir{$d};
						push(@@{$infodir{$d}}, $_);
d386 1
a386 1
add_info('@@unexec install-info --delete', \%infodir);
d393 1
a393 1
	handle_file($f, $out{$plist}) unless ($f =~ m|/dir$|) && (defined $infodir{$`});
d443 1
a443 1
add_info('@@exec install-info', \%infodir);
@


1.26
log
@Extra code for annotations: instead of stashing each element into one plist,
record all plists concerned.

This lets update-plist deal with packages with duplicated files.
@
text
@d3 1
a3 1
# $OpenBSD: make-plist,v 1.25 2003/06/30 11:31:22 espie Exp $
d101 1
d231 1
a231 1
		    $l->[1]->print("\@@comment$string");
@


1.25
log
@Protect filehandle from being created twice.
@
text
@d3 1
a3 1
# $OpenBSD: make-plist,v 1.24 2003/06/30 11:29:16 espie Exp $
a37 2
my %annotated;
my %annotated_dir;
d43 21
d96 1
a96 1
				$annotated_dir{$_} = [ $name, $newfh, 'comment'];
d99 1
a99 2
				$annotated{$_} = [ $name, $newfh, 'comment'] 
				    unless defined $annotated{$_};
d103 1
a103 1
			$annotated_dir{$_} = [ $name, $newfh ];
d118 1
a118 1
			$annotated{$_} = [ $name, $newfh, $mode, $owner, $group, $nocheck ];
d121 1
a121 1
			$annotated{$_} = [ $name, $newfh ];
d227 21
a247 13
    if (defined $annotated{$fname}) {
    	my $l = $annotated{$fname};
	if (@@$l == 3) {
		$l->[1]->print("\@@comment$string");
	} elsif (@@$l == 2) {
		$l->[1]->print($string);
	} else {
	    my ($outname, $fh, $mode, $owner, $group, $nocheck) = @@$l;
	    if ($mode ne '') {
		    $string="\@@mode $mode\n$string\@@mode\n";
	    }
	    if ($owner ne '') {
		    $string="\@@owner $owner\n$string\@@owner\n";
a248 7
	    if ($group ne '') {
		    $string="\@@group $group\n$string\@@group\n";
	    }
	    if ($nocheck ne '') {
		    $string="\@@comment no checksum\n$string";
	    }
	    print $fh $string;
d410 10
a419 9
	if (defined $annotated_dir{$dname}) {
		my $l = $annotated_dir{$dname};
		if (!$has_stuff{$d}) {
			$l->[1]->print("\@@exec mkdir -p \%D/$dname\n");
		}
		if (@@$l == 3) {
			$l->[1]->print("\@@comment \@@dirrm $dname\n");
		} else {
			$l->[1]->print("\@@dirrm $dname\n");
@


1.24
log
@Multi-packages may have extra blanks at start. Disallow...
@
text
@d3 1
a3 1
# $OpenBSD: make-plist,v 1.23 2003/06/16 22:42:54 espie Exp $
d241 3
@


1.23
log
@ensure $out{$plist}, $out{$pshared} are defined when needed.
@
text
@d3 1
a3 1
# $OpenBSD: make-plist,v 1.22 2003/06/15 13:31:37 espie Exp $
d284 3
@


1.22
log
@Improvements to make-plist, try to take multi-packages into account.
Doesn't handle yet the case where several plists want the same files...
@
text
@d3 1
a3 1
# $OpenBSD: make-plist,v 1.21 2003/06/12 22:04:37 pvalchev Exp $
d351 4
d365 5
@


1.21
log
@remove license terms 3 & 4 for espie
@
text
@d3 1
a3 1
# $OpenBSD: make-plist,v 1.20 2003/01/06 20:16:21 espie Exp $
d33 1
a39 1
my $keep = '';
d41 3
d47 4
a50 1
	my $filename = shift;
d52 1
a52 2
	open(OLDFILE, '<', $filename) or die "Can't read $filename";
	while(<OLDFILE>) {
d63 1
a63 1
			$keep.="$_\n";
d69 5
a73 1
		} elsif (/^\@@comment\s+/) {
d77 2
a78 1
				$annotated_dir{$_} = 1;
d80 1
a80 1
				$annotated{$_} = [ 'comment' ] 
d83 4
d92 1
a92 1
				$keep.="$_\n";
d100 1
a100 1
			$annotated{$_} = [ $mode, $owner, $group, $nocheck ];
d102 2
d106 1
d165 1
a165 1
			print "$header --info-dir=\%D/$d2 \%D/$d2/$f\n";
d206 1
d210 20
a229 16
    	my ($mode, $owner, $group, $nocheck) = @@{$annotated{$fname}};
	if ($mode eq 'comment') {
		print "\@@comment $fname\n";
		return;
	}
	if ($mode ne '') {
		$string="\@@mode $mode\n$string\@@mode\n";
	}
	if ($owner ne '') {
		$string="\@@owner $owner\n$string\@@owner\n";
	}
	if ($group ne '') {
		$string="\@@group $group\n$string\@@group\n";
	}
	if ($nocheck ne '') {
		$string="\@@comment no checksum\n$string";
d231 2
a233 1
    print $string;
d236 16
a252 1
my ($plist, $pshared);
d279 3
a281 4
if (-e $plist) {
    annotate($plist);
    rename($plist, "$plist.orig") or die "Can't rename $plist to $plist.orig";
}
d283 6
a288 3
if (-e $pshared) {
    annotate($pshared);
    rename($pshared, "$pshared.orig") or die "Can't rename $pshared to $pshared.orig";
a290 3
open(PLIST, '>', $plist) or die "Can't write to $plist";
select PLIST;

d299 3
a301 1
print "\@@comment \$OpenBSD\$\n$keep";
d352 1
a352 1
	handle_file($f) unless ($f =~ m|/dir$|) && (defined $infodir{$`});
d355 5
d361 1
a361 3
    	print "\%\%SHARED\%\%\n";
	open(SHARED, ">$pshared") or die "Can't write to $pshared";
	print SHARED "\@@comment \$OpenBSD\$\n";
d363 1
a363 1
	    print SHARED strip($f), "\n";
d367 1
a367 1
			print SHARED "NEWDYNLIBDIR(\%D/", strip($d), ")\n";
d369 1
a369 1
			print SHARED "DYNLIBDIR(\%D/", strip($d), ")\n";
a371 1
	close SHARED;
d376 10
a385 2
	if ($annotated_dir{$dname}) {
		print "\@@comment \@@dirrm $dname\n";
d390 1
a390 1
			print "\@@exec mkdir -p \%D/$dname\n";
d392 1
a392 1
		print "\@@dirrm $dname\n";
@


1.20
log
@Use PLIST and PFRAG, makes updating simpler in some cases.
@
text
@d3 1
a3 1
# $OpenBSD: make-plist,v 1.19 2002/12/23 16:07:51 espie Exp $
a14 7
#  3. All advertising materials mentioning features or use of this software
#     must display the following acknowledgement:
# 	This product includes software developed by the OpenBSD project
#
#  4. Neither the name of the OpenBSD project nor the names of its contributors
#     may be used to endorse or promote products derived from this software
#     without specific prior written permission.
@


1.19
log
@Handle @@comment @@dirrm
@
text
@d3 1
a3 1
# $OpenBSD: make-plist,v 1.18 2002/04/20 19:07:25 espie Exp $
d229 4
a232 2
$plist = File::Spec->catfile($plistdir, 'PLIST');
$pshared = File::Spec->catfile($plistdir, 'PFRAG.shared');
@


1.18
log
@move stuff around, so that functions are at beginning of file.
No other significant change.
@
text
@d3 1
a3 1
# $OpenBSD: make-plist,v 1.17 2002/04/15 06:38:23 espie Exp $
d45 1
d73 7
a79 2
			$annotated{$_} = [ 'comment' ] 
			    unless defined $annotated{$_};
d339 10
a348 4
	# case of new directory that does not hold anything: it's marked
	# for removal, but it must exist first
	if (!$has_stuff{$d}) {
		print "\@@exec mkdir -p \%D/", strip($d), "\n";
a349 1
	print "\@@dirrm ",strip($d), "\n";
@


1.17
log
@register comments. Allows to remove a file from a plist by @@comment'ing it,
and having make update-plist keep that.
@
text
@d3 1
a3 1
# $OpenBSD: make-plist,v 1.16 2002/04/03 15:00:30 espie Exp $
d64 1
a64 1
			$keep="$keep$_\n";
d79 1
a79 1
				$keep="$keep$_\n";
a92 55
my ($plist, $pshared);
my @@backsubst;

my (%newdir, %occupied, %ldconfig, %has_stuff, %infodir, @@files, @@libfiles);
die "Update bsd.port.mk" if @@ARGV == 0;
my $plistdir = shift;
die "Update bsd.port.mk" if -f $plistdir;
die "Update bsd.port.mk" 
    unless defined $ENV{'DEPS'} and defined $ENV{'PKGREPOSITORY'};
$plist = File::Spec->catfile($plistdir, 'PLIST');
$pshared = File::Spec->catfile($plistdir, 'PFRAG.shared');
if (-e "$plist.orig" or -e "$pshared.orig") {
	die "You must clean up old files first";
}

my $destdir = $ENV{DESTDIR};

my $mtree = parse_mtree($destdir);

# and directories for dependencies as well
my $tmpdir = tempdir( CLEANUP => 1);
chdir($tmpdir);
for my $pkg (split(/\s+/, $ENV{'DEPS'})) {
	augment_mtree($mtree, $destdir, $ENV{'PKGREPOSITORY'}."/$pkg.tgz");
}

if (-e $plist) {
    annotate($plist);
    rename($plist, "$plist.orig") or die "Can't rename $plist to $plist.orig";
}

if (-e $pshared) {
    annotate($pshared);
    rename($pshared, "$pshared.orig") or die "Can't rename $pshared to $pshared.orig";
}

open(PLIST, '>', $plist) or die "Can't write to $plist";
select PLIST;

for (@@ARGV) {
	if (m/\=/) {
		my $back = $`;
		my $v = $';
		push(@@backsubst, ["\${$back}", $v]) if $v ne '';
	}
}

print "\@@comment \$OpenBSD\$\n$keep";

# compare all files against those dates
my @@date = (stat $ENV{INSTALL_PRE_COOKIE})[9, 10];

# prefix to remove from everything
my $base = $ENV{PREFIX};

d121 4
d187 79
a309 27

sub handle_file
{
    my $fname = strip(shift);
    my $string = "$fname\n";

    if (defined $annotated{$fname}) {
    	my ($mode, $owner, $group, $nocheck) = @@{$annotated{$fname}};
	if ($mode eq 'comment') {
		print "\@@comment $fname\n";
		return;
	}
	if ($mode ne '') {
		$string="\@@mode $mode\n$string\@@mode\n";
	}
	if ($owner ne '') {
		$string="\@@owner $owner\n$string\@@owner\n";
	}
	if ($group ne '') {
		$string="\@@group $group\n$string\@@group\n";
	}
	if ($nocheck ne '') {
		$string="\@@comment no checksum\n$string";
	}
    }
    print $string;
}
@


1.16
log
@Let make update-plist look at dependent packages (LIB_DEPENDS and
RUN_DEPENDS) to create a more accurate list of @@dirrm.

Minor negative side-effect: up-to-date dependent packages must be present
for this to work. Not a problem, since this is only used by maintainers.

This improves the quality of generated plists for large packages with lots
of dependencies by a large amount (e.g., kde)

reviewed by pval@@
@
text
@d3 1
a3 1
# $OpenBSD: make-plist,v 1.15 2001/08/23 09:13:19 espie Exp $
d70 4
d290 4
@


1.15
log
@Recognize empty @@owner/@@mode/@@group   correctly.
@
text
@d3 1
a3 1
# $OpenBSD: make-plist,v 1.14 2001/08/18 13:11:10 espie Exp $
d42 1
d96 2
d103 12
a143 2
my $destdir = $ENV{DESTDIR};

d145 2
a146 1
sub parse_mtree {
d172 2
a173 1
sub strip {
d190 2
a191 1
sub add_info {
d201 33
a272 1
my $mtree = parse_mtree($destdir);
@


1.14
log
@Some attempt at parsing the .orig files, to preserve @@mode/@@owner/@@group
and misc. information.

Try to warn if non-reproducible stuff is found.
@
text
@d3 1
a3 1
# $OpenBSD: make-plist,v 1.13 2001/05/24 16:47:59 espie Exp $
d54 1
a54 1
		if (m/^\@@mode\s+/) {
d56 1
a56 1
		} elsif (m/^\@@owner\s+/) {
d58 1
a58 1
		} elsif (m/^\@@group\s+/) {
@


1.13
log
@Oops. Seen by Flinn Mueller.
@
text
@d3 1
a3 1
# $OpenBSD: make-plist,v 1.12 2001/05/23 14:18:25 espie Exp $
d43 45
d101 1
d106 1
d121 1
a121 1
print "\@@comment \$OpenBSD\$\n";
d231 23
d255 1
a255 1
	print strip($f), "\n" unless ($f =~ m|/dir$|) && (defined $infodir{$`});
d285 5
@


1.12
log
@Smarter plist regen.
- back substitute VAR_SUBST (hence swap ARCH/MACHINE_ARCH)
- pass PKGDIR to make-plist.

- don't create PLIST-auto/PFRAG.shared-auto. Move originals around, and
create new ones directly (guard against accidentally deleting old ones).

Todo: add regexp to dispatch stuff to fragments automatically, based on
MULTI_PACKAGES.
@
text
@d3 1
a3 1
# $OpenBSD: make-plist,v 1.11 2001/05/07 15:25:44 espie Exp $
d55 7
a61 2
rename($plist, "$plist.orig") or die "Can't rename $plist to $plist.orig";
rename($pshared, "$pshared.orig");
d190 1
a190 1
	open(SHARED, ">$pshared-auto") or die "Can't write to $pshared-auto";
@


1.11
log
@Oh well. Need both stats under different circumstances, as found out
by Peter Stromberg.
@
text
@d3 1
a3 1
# $OpenBSD: make-plist,v 1.10 2001/05/05 21:24:27 espie Exp $
d41 1
d44 1
d48 11
a58 4
$plist = shift;
$pshared = $plist;
$pshared =~ s/PLIST/PFRAG.shared/;
open(PLIST, ">$plist-auto") or die "Can't write to $plist-auto";
d61 8
d109 5
@


1.10
log
@better stat.
@
text
@d3 1
a3 1
# $OpenBSD: make-plist,v 1.9 2001/03/24 12:14:38 espie Exp $
d54 2
a55 2
# compare all files against this date
my $date = (stat $ENV{INSTALL_PRE_COOKIE})[9];
d116 2
a117 2
		my $cdate = (lstat $_)[9];
		if ($cdate >= $date) {
@


1.9
log
@Warn for arch dependent names in PLIST.
No automatic correction, as this can be hard.
@
text
@d3 1
a3 1
# $OpenBSD: make-plist,v 1.8 2000/07/08 18:09:10 espie Exp $
d55 1
a55 1
my $date = (stat $ENV{INSTALL_PRE_COOKIE})[10];
d116 1
a116 1
		my $cdate = (lstat $_)[10];
@


1.8
log
@Don't output shared libs in both PFRAG.shared and PLIST.
@
text
@d3 1
a3 1
# $OpenBSD: make-plist,v 1.7 2000/07/08 15:13:49 espie Exp $
d92 6
@


1.7
log
@Forgot %D in DYNLIBDIR.
@
text
@d3 1
a3 1
# $OpenBSD: make-plist,v 1.6 2000/07/03 13:01:49 espie Exp $
d119 7
a125 6
				}
				push(@@files, $File::Find::name);
				if (/\.info$/) {
					my $d = $File::Find::dir;
					$infodir{$d} = [] unless defined $infodir{$d};
					push(@@{$infodir{$d}}, $_);
@


1.6
log
@Put shared libraries into a separate fragment.
@
text
@d3 1
a3 1
# $OpenBSD: make-plist,v 1.5 2000/06/30 23:45:41 espie Exp $
d163 1
a163 1
			print SHARED "NEWDYNLIBDIR(", strip($d), ")\n";
d165 1
a165 1
			print SHARED "DYNLIBDIR(", strip($d), ")\n";
@


1.5
log
@Let make-plist emit DYNLIBDIR/NEWLIBDIR directives.
@
text
@d3 1
a3 1
# $OpenBSD: make-plist,v 1.4 2000/04/17 21:00:56 espie Exp $
d42 9
a50 1
my (%newdir, %occupied, %ldconfig, %has_stuff, %infodir, @@files);
a104 1

a115 1
				push(@@files, $File::Find::name);
d118 1
d120 1
d154 17
a177 8
}
	
for my $d (sort (keys %ldconfig)) {
	if (defined $newdir{$d}) {
		print "NEWDYNLIBDIR(", strip($d), ")\n";
	} else {
		print "DYNLIBDIR(", strip($d), ")\n";
	}
@


1.4
log
@Fix nasty bug in make-plist:
if a new directory was found, it  is always marked for @@dirrm.
But, if the directory is empty, nothing pertaining to it is recorded in
the PLIST... and thanks to pkg_*, we can't record directories in the PLIST.
So, just add an @@exec mkdir -p   right in front of the @@dirrm, up to
the port maintainer to decide whether the @@exec mkdir/@@dirrm pair is
justified or not (for the port at hand).
@
text
@d3 1
a3 1
# $OpenBSD: make-plist,v 1.3 2000/03/03 21:24:51 espie Exp $
a154 2
my $ldconfig = $ENV{LDCONFIG};

d156 5
a160 2
	print "\@@exec $ldconfig -m %D/", strip($d), "\n";
	print "\@@unexec $ldconfig -m %D/", strip($d) ,"\n";
a163 2

	
@


1.4.2.1
log
@
bring cutoff infrastructure files into 2.7 branch
@
text
@d3 1
a3 1
# $OpenBSD: make-plist,v 1.8 2000/07/08 18:09:10 espie Exp $
d42 1
a42 9
my ($plist, $pshared);

my (%newdir, %occupied, %ldconfig, %has_stuff, %infodir, @@files, @@libfiles);
die "Update bsd.port.mk" if @@ARGV == 0;
$plist = shift;
$pshared = $plist;
$pshared =~ s/PLIST/PFRAG.shared/;
open(PLIST, ">$plist-auto") or die "Can't write to $plist-auto";
select PLIST;
d97 1
d109 1
d112 5
a116 8
					push(@@libfiles, $File::Find::name);
				} else {
					push(@@files, $File::Find::name);
					if (/\.info$/) {
						my $d = $File::Find::dir;
						$infodir{$d} = [] unless defined $infodir{$d};
						push(@@{$infodir{$d}}, $_);
					}
a145 17
if (@@libfiles > 0) {
    	print "\%\%SHARED\%\%\n";
	open(SHARED, ">$pshared-auto") or die "Can't write to $pshared-auto";
	print SHARED "\@@comment \$OpenBSD\$\n";
	for my $f (sort @@libfiles) {
	    print SHARED strip($f), "\n";
	}
	for my $d (sort (keys %ldconfig)) {
		if (defined $newdir{$d}) {
			print SHARED "NEWDYNLIBDIR(\%D/", strip($d), ")\n";
		} else {
			print SHARED "DYNLIBDIR(\%D/", strip($d), ")\n";
		}
	}
	close SHARED;
}

d155 7
d163 2
@


1.3
log
@`Fake' infrastructure:
if a port sets FAKE=Yes, this means it can be `pre'-installed elsewhere,
with DESTDIR set to WRKINST (=work/fake-${ARCH} by default).

the infrastructure takes care of pre-install/do-install/post-install targets,
assuming those install stuff under PREFIX.

To help ports to cope with DESTDIR, you can set FAKE_FLAGS and FAKE_TARGET
(used for the fake installation).

Ports with FAKE=Yes are the way to go: they can be packaged directly without
a real installation, and the installation proceeds from the package, thus
forcing porters to check the package.
@
text
@d3 1
a3 1
# $OpenBSD: make-plist,v 1.2 1999/07/29 14:01:12 espie Exp $
d42 3
a44 1
my (%newdir, %occupied, %ldconfig, %infodir, @@files);
d105 1
d147 5
@


1.2
log
@buglet: install-info --delete to remove entries.
@
text
@d3 1
a3 1
# $OpenBSD: make-plist,v 1.1 1999/07/29 13:51:51 espie Exp $
d50 1
d54 1
a54 1
		# start under current PREFIX, usually
d132 1
a132 1
my $mtree = parse_mtree($base);
@


1.1
log
@Making automatic plists better:
- parse mtree file completely,
- find out which directories amongst modified dirs are really new,
- handle info files.
@
text
@d3 1
a3 1
# $OpenBSD$
d136 1
a136 1
add_info('@@unexec install-info', \%infodir);
@

