head	1.4;
access;
symbols
	OPENBSD_2_9:1.3.0.2
	OPENBSD_2_9_BASE:1.3;
locks; strict;
comment	@# @;


1.4
date	2001.05.26.06.02.20;	author todd;	state dead;
branches;
next	1.3;

1.3
date	2001.03.30.18.53.25;	author todd;	state Exp;
branches;
next	1.2;

1.2
date	2001.03.30.16.47.02;	author todd;	state Exp;
branches;
next	1.1;

1.1
date	2001.02.02.16.59.09;	author todd;	state Exp;
branches;
next	;


desc
@@


1.4
log
@gone are the days when bochs feedback heads to /dev/null
did I mention I commit this inside of bochs?  Thanks, angelos, for networking!
@
text
@$OpenBSD: patch-cpu_proc_ctrl_cc,v 1.3 2001/03/30 18:53:25 todd Exp $
--- cpu/proc_ctrl.cc.orig	Sat Mar 25 21:39:09 2000
+++ cpu/proc_ctrl.cc	Fri Mar 30 12:42:03 2001
@@@@ -35,7 +35,7 @@@@ BX_CPU_C::UndefinedOpcode(BxInstruction_
   if (i->b1 != 0x63) {
     // Windows hits the ARPL command a bunch of times.
     // Too much spew...
-    bx_printf("UndefinedOpcode: %02x causes exception 6\n",
+    bio->printd("UndefinedOpcode: %02x causes exception 6\n",
               (unsigned) i->b1);
     }
   exception(BX_UD_EXCEPTION, 0, 0);
@@@@ -52,17 +52,17 @@@@ BX_CPU_C::HLT(BxInstruction_t *i)
 {
   // hack to panic if HLT comes from BIOS
   if ( BX_CPU_THIS_PTR sregs[BX_SEG_REG_CS].selector.value == 0xf000 )
-    bx_panic("HALT instruction encountered\n");
+    bio->panic("CPU%u HALT instruction encountered\n",BX_SIM_ID);
 
   if (CPL!=0) {
-    bx_printf("HLT(): CPL!=0\n");
+    if(bio->getdbg().exceptions)
+	bio->printd("[CPU%n] HLT(): CPL!=0\n",BX_SIM_ID);
     exception(BX_GP_EXCEPTION, 0, 0);
     return;
     }
 
   if ( ! BX_CPU_THIS_PTR eflags.if_ ) {
-    fprintf(stderr, "WARNING: HLT instruction with IF=0!\n");
-    bx_printf("WARNING: HLT instruction with IF=0!\n");
+    bio->printd("WARNING: HLT instruction with IF=0!\n");
     }
 
   // stops instruction execution and places the processor in a
@@@@ -102,17 +102,17 @@@@ BX_CPU_C::wait_for_interrupt()
 BX_CPU_C::CLTS(BxInstruction_t *i)
 {
 #if BX_CPU_LEVEL < 2
-  bx_panic("CLTS: not implemented for < 286\n");
+  bio->panic("[CPU%u] CLTS: not implemented for < 286\n",BX_SIM_ID);
 #else
 
-  if (v8086_mode()) bx_panic("clts: v8086 mode unsupported\n");
+  if (v8086_mode()) bio->panic("clts: v8086 mode unsupported\n");
 
   /* read errata file */
   // does CLTS also clear NT flag???
 
   // #GP(0) if CPL is not 0
   if (CPL!=0) {
-    bx_printf("CLTS(): CPL!=0\n");
+    bio->printd("CLTS(): CPL!=0\n");
     exception(BX_GP_EXCEPTION, 0, 0);
     return;
     }
@@@@ -125,16 +125,16 @@@@ BX_CPU_C::CLTS(BxInstruction_t *i)
   void
 BX_CPU_C::INVD(BxInstruction_t *i)
 {
-  bx_printf("---------------\n");
-  bx_printf("- INVD called -\n");
-  bx_printf("---------------\n");
+  bio->printd("---------------\n");
+  bio->printd("- INVD called -\n");
+  bio->printd("---------------\n");
 
 #if BX_CPU_LEVEL >= 4
   invalidate_prefetch_q();
 
   if (BX_CPU_THIS_PTR cr0.pe) {
     if (CPL!=0) {
-      bx_printf("INVD: CPL!=0\n");
+      bio->printd("INVD: CPL!=0\n");
       exception(BX_GP_EXCEPTION, 0, 0);
       }
     }
@@@@ -147,14 +147,14 @@@@ BX_CPU_C::INVD(BxInstruction_t *i)
   void
 BX_CPU_C::WBINVD(BxInstruction_t *i)
 {
-  bx_printf("WBINVD: (ignoring)\n");
+  bio->printd("WBINVD: (ignoring)\n");
 
 #if BX_CPU_LEVEL >= 4
   invalidate_prefetch_q();
 
   if (BX_CPU_THIS_PTR cr0.pe) {
     if (CPL!=0) {
-      bx_printf("WBINVD: CPL!=0\n");
+      bio->printd("WBINVD: CPL!=0\n");
       exception(BX_GP_EXCEPTION, 0, 0);
       }
     }
@@@@ -168,11 +168,11 @@@@ BX_CPU_C::WBINVD(BxInstruction_t *i)
 BX_CPU_C::MOV_DdRd(BxInstruction_t *i)
 {
 #if BX_CPU_LEVEL < 3
-  bx_panic("MOV_DdRd: not supported on < 386\n");
+  bio->panic("MOV_DdRd: not supported on < 386\n");
 #else
   Bit32u val_32;
 
-  if (v8086_mode()) bx_panic("MOV_DdRd: v8086 mode unsupported\n");
+  if (v8086_mode()) bio->panic("MOV_DdRd: v8086 mode unsupported\n");
 
   /* NOTES:
    *   32bit operands always used
@@@@ -182,20 +182,20 @@@@ BX_CPU_C::MOV_DdRd(BxInstruction_t *i)
    */
 
   if (i->mod != 0xc0) {
-    bx_panic("MOV_DdRd(): rm field not a register!\n");
+    bio->panic("MOV_DdRd(): rm field not a register!\n");
     }
 
   invalidate_prefetch_q();
 
   if (protected_mode() && CPL!=0) {
-    bx_panic("MOV_DdRd: CPL!=0\n");
+    bio->panic("MOV_DdRd: CPL!=0\n");
     /* #GP(0) if CPL is not 0 */
     exception(BX_GP_EXCEPTION, 0, 0);
     }
 
   val_32 = BX_READ_32BIT_REG(i->rm);
-  if (bx_dbg.dreg)
-    bx_printf("MOV_DdRd: DR[%u]=%08xh unhandled\n",
+  if (bio->getdbg().dreg)
+    bio->printd("MOV_DdRd: DR[%u]=%08xh unhandled\n",
       (unsigned) i->nnn, (unsigned) val_32);
 
   switch (i->nnn) {
@@@@ -219,7 +219,7 @@@@ BX_CPU_C::MOV_DdRd(BxInstruction_t *i)
 #if BX_CPU_LEVEL >= 4
       if ( (i->nnn == 4) && (BX_CPU_THIS_PTR cr4 & 0x00000008) ) {
         // Debug extensions on
-        bx_printf("MOV_DdRd: access to DR4 causes #UD\n");
+        bio->printd("MOV_DdRd: access to DR4 causes #UD\n");
         UndefinedOpcode(i);
         }
 #endif
@@@@ -245,13 +245,13 @@@@ BX_CPU_C::MOV_DdRd(BxInstruction_t *i)
 #if BX_CPU_LEVEL >= 4
       if ( (i->nnn == 5) && (BX_CPU_THIS_PTR cr4 & 0x00000008) ) {
         // Debug extensions (CR4.DE) on
-        bx_printf("MOV_DdRd: access to DR5 causes #UD\n");
+        bio->printd("MOV_DdRd: access to DR5 causes #UD\n");
         UndefinedOpcode(i);
         }
 #endif
       // Some sanity checks...
       if ( val_32 & 0x00002000 ) {
-        bx_panic("MOV_DdRd: GD bit not supported yet\n");
+        bio->panic("MOV_DdRd: GD bit not supported yet\n");
         // Note: processor clears GD upon entering debug exception
         // handler, to allow access to the debug registers
         }
@@@@ -260,7 +260,7 @@@@ BX_CPU_C::MOV_DdRd(BxInstruction_t *i)
            (((val_32>>24) & 3)==2) ||
            (((val_32>>28) & 3)==2) ) {
         // IO breakpoints (10b) are not yet supported.
-        bx_panic("MOV_DdRd: write of %08x contains IO breakpoint\n",
+        bio->panic("MOV_DdRd: write of %08x contains IO breakpoint\n",
           val_32);
         }
       if ( (((val_32>>18) & 3)==2) ||
@@@@ -268,7 +268,7 @@@@ BX_CPU_C::MOV_DdRd(BxInstruction_t *i)
            (((val_32>>26) & 3)==2) ||
            (((val_32>>30) & 3)==2) ) {
         // LEN0..3 contains undefined length specifier (10b)
-        bx_panic("MOV_DdRd: write of %08x contains undefined LENx\n",
+        bio->panic("MOV_DdRd: write of %08x contains undefined LENx\n",
           val_32);
         }
       if ( ((((val_32>>16) & 3)==0) && (((val_32>>18) & 3)!=0)) ||
@@@@ -276,7 +276,7 @@@@ BX_CPU_C::MOV_DdRd(BxInstruction_t *i)
            ((((val_32>>24) & 3)==0) && (((val_32>>26) & 3)!=0)) ||
            ((((val_32>>28) & 3)==0) && (((val_32>>30) & 3)!=0)) ) {
         // Instruction breakpoint with LENx not 00b (1-byte length)
-        bx_panic("MOV_DdRd: write of %08x, R/W=00b LEN!=00b\n",
+        bio->panic("MOV_DdRd: write of %08x, R/W=00b LEN!=00b\n",
           val_32);
         }
 #if BX_CPU_LEVEL <= 4
@@@@ -289,7 +289,7 @@@@ BX_CPU_C::MOV_DdRd(BxInstruction_t *i)
 #endif
       break;
     default:
-      bx_panic("MOV_DdRd: control register index out of range\n");
+      bio->panic("MOV_DdRd: control register index out of range\n");
       break;
     }
 #endif
@@@@ -299,28 +299,28 @@@@ BX_CPU_C::MOV_DdRd(BxInstruction_t *i)
 BX_CPU_C::MOV_RdDd(BxInstruction_t *i)
 {
 #if BX_CPU_LEVEL < 3
-  bx_panic("MOV_RdDd: not supported on < 386\n");
+  bio->panic("MOV_RdDd: not supported on < 386\n");
 #else
   Bit32u val_32;
 
   if (v8086_mode()) {
-    bx_printf("MOV_RdDd: v8086 mode causes #GP\n");
+    bio->printd("MOV_RdDd: v8086 mode causes #GP\n");
     exception(BX_GP_EXCEPTION, 0, 0);
     }
 
   if (i->mod != 0xc0) {
-    bx_panic("MOV_RdDd(): rm field not a register!\n");
+    bio->panic("MOV_RdDd(): rm field not a register!\n");
     UndefinedOpcode(i);
     }
 
   if (protected_mode() && (CPL!=0)) {
-    bx_printf("MOV_RdDd: CPL!=0 causes #GP\n");
+    bio->printd("MOV_RdDd: CPL!=0 causes #GP\n");
     exception(BX_GP_EXCEPTION, 0, 0);
     return;
     }
 
-  if (bx_dbg.dreg)
-    bx_printf("MOV_RdDd: DR%u not implemented yet\n", i->nnn);
+  if (bio->getdbg().dreg)
+    bio->printd("MOV_RdDd: DR%u not implemented yet\n", i->nnn);
 
   switch (i->nnn) {
     case 0: // DR0
@@@@ -343,7 +343,7 @@@@ BX_CPU_C::MOV_RdDd(BxInstruction_t *i)
 #if BX_CPU_LEVEL >= 4
       if ( (i->nnn == 4) && (BX_CPU_THIS_PTR cr4 & 0x00000008) ) {
         // Debug extensions on
-        bx_printf("MOV_RdDd: access to DR4 causes #UD\n");
+        bio->printd("MOV_RdDd: access to DR4 causes #UD\n");
         UndefinedOpcode(i);
         }
 #endif
@@@@ -357,7 +357,7 @@@@ BX_CPU_C::MOV_RdDd(BxInstruction_t *i)
 #if BX_CPU_LEVEL >= 4
       if ( (i->nnn == 5) && (BX_CPU_THIS_PTR cr4 & 0x00000008) ) {
         // Debug extensions on
-        bx_printf("MOV_RdDd: access to DR5 causes #UD\n");
+        bio->printd("MOV_RdDd: access to DR5 causes #UD\n");
         UndefinedOpcode(i);
         }
 #endif
@@@@ -365,7 +365,7 @@@@ BX_CPU_C::MOV_RdDd(BxInstruction_t *i)
       break;
 
     default:
-      bx_panic("MOV_RdDd: control register index out of range\n");
+      bio->panic("MOV_RdDd: control register index out of range\n");
       val_32 = 0;
     }
   BX_WRITE_32BIT_REG(i->rm, val_32);
@@@@ -377,16 +377,16 @@@@ BX_CPU_C::MOV_RdDd(BxInstruction_t *i)
 BX_CPU_C::LMSW_Ew(BxInstruction_t *i)
 {
 #if BX_CPU_LEVEL < 2
-  bx_panic("LMSW_Ew(): not supported on 8086!\n");
+  bio->panic("LMSW_Ew(): not supported on 8086!\n");
 #else
   Bit16u msw;
   Bit32u cr0;
 
-  if (v8086_mode()) bx_panic("proc_ctrl: v8086 mode unsupported\n");
+  if (v8086_mode()) bio->panic("proc_ctrl: v8086 mode unsupported\n");
 
   if ( protected_mode() ) {
     if ( CPL != 0 ) {
-      bx_printf("LMSW: CPL != 0, CPL=%u\n", (unsigned) CPL);
+      bio->printd("LMSW: CPL != 0, CPL=%u\n", (unsigned) CPL);
       exception(BX_GP_EXCEPTION, 0, 0);
       return;
       }
@@@@ -416,7 +416,7 @@@@ BX_CPU_C::LMSW_Ew(BxInstruction_t *i)
 BX_CPU_C::SMSW_Ew(BxInstruction_t *i)
 {
 #if BX_CPU_LEVEL < 2
-  bx_panic("SMSW_Ew: not supported yet!\n");
+  bio->panic("SMSW_Ew: not supported yet!\n");
 #else
   Bit16u msw;
 
@@@@ -459,12 +459,14 @@@@ BX_CPU_C::MOV_CdRd(BxInstruction_t *i)
 {
   // mov general register data to control register
 #if BX_CPU_LEVEL < 3
-  bx_panic("MOV_CdRd: not supported on < 386\n");
+  bio->printd("MOV_CdRd: not supported on < 386\n");
+  exception(BX_GP_EXCEPTION, 0, 0);
+  return;
 #else
   Bit32u val_32;
 
 
-  if (v8086_mode()) bx_panic("proc_ctrl: v8086 mode unsupported\n");
+  if (v8086_mode()) bio->panic("proc_ctrl: v8086 mode unsupported\n");
 
   /* NOTES:
    *   32bit operands always used
@@@@ -474,13 +476,15 @@@@ BX_CPU_C::MOV_CdRd(BxInstruction_t *i)
    */
 
   if (i->mod != 0xc0) {
-    bx_panic("MOV_CdRd(): rm field not a register!\n");
-    }
+    bio->printd("MOV_CdRd(): rm field not a register!\n");
+    exception(BX_GP_EXCEPTION, 0, 0);
+    return;
+  }
 
   invalidate_prefetch_q();
 
   if (protected_mode() && CPL!=0) {
-    bx_panic("MOV_CdRd: CPL!=0\n");
+    bio->printd("MOV_CdRd: CPL!=0\n");
     /* #GP(0) if CPL is not 0 */
     exception(BX_GP_EXCEPTION, 0, 0);
     return;
@@@@ -490,7 +494,7 @@@@ BX_CPU_C::MOV_CdRd(BxInstruction_t *i)
 
   switch (i->nnn) {
     case 0: // CR0 (MSW)
-      // bx_printf("MOV_CdRd:CR0: R32 = %08x\n @@CS:EIP %04x:%04x ",
+      // bio->printd("MOV_CdRd:CR0: R32 = %08x\n @@CS:EIP %04x:%04x ",
       //   (unsigned) val_32,
       //   (unsigned) BX_CPU_THIS_PTR sregs[BX_SEG_REG_CS].selector.value,
       //   (unsigned) BX_CPU_THIS_PTR eip);
@@@@ -498,36 +502,34 @@@@ BX_CPU_C::MOV_CdRd(BxInstruction_t *i)
       break;
 
     case 1: /* CR1 */
-      bx_panic("MOV_CdRd: CR1 not implemented yet\n");
+      bio->panic("MOV_CdRd: CR1 not implemented yet\n");
       break;
     case 2: /* CR2 */
-      bx_printf("MOV_CdRd: CR2 not implemented yet\n");
-      if (bx_dbg.creg)
-        bx_printf("MOV_CdRd: CR2 = reg\n");
+      bio->printd("MOV_CdRd: CR2 not implemented yet\n");
+      if (bio->getdbg().creg)
+        bio->printd("MOV_CdRd: CR2 = reg\n");
       BX_CPU_THIS_PTR cr2 = val_32;
       break;
     case 3: // CR3
-      if (bx_dbg.creg)
-        bx_printf("MOV_CdRd:(%08x)\n", (unsigned) val_32);
+      if (bio->getdbg().creg)
+        bio->printd("MOV_CdRd:(%08x)\n", (unsigned) val_32);
       // Reserved bits take on value of MOV instruction
       CR3_change(val_32);
       BX_INSTR_TLB_CNTRL(BX_INSTR_MOV_CR3, val_32);
       break;
     case 4: // CR4
 #if BX_CPU_LEVEL == 3
-      bx_panic("MOV_CdRd: write to CR4 of 0x%08x on 386\n",
-        val_32);
+      bio->printd("[CPU%u] MOV_CdRd: write to CR4 of 0x%08x on 386\n",
+	BX_SIM_ID, val_32);
       UndefinedOpcode(i);
 #else
       //  Protected mode: #GP(0) if attempt to write a 1 to
       //  any reserved bit of CR4
 
-      bx_printf("MOV_CdRd: ignoring write to CR4 of 0x%08x\n",
+      bio->printd("MOV_CdRd: ignoring write to CR4 of 0x%08x\n",
         val_32);
-      if (val_32) {
-        bx_panic("MOV_CdRd: (CR4) write of 0x%08x\n",
-          val_32);
-        }
+      //if (val_32) {
+      //}
       // Only allow writes of 0 to CR4 for now.
       // Writes to bits in CR4 should not be 1s as CPUID
       // returns not-supported for all of these features.
@@@@ -535,7 +537,7 @@@@ BX_CPU_C::MOV_CdRd(BxInstruction_t *i)
 #endif
       break;
     default:
-      bx_panic("MOV_CdRd: control register index out of range\n");
+      bio->panic("MOV_CdRd: control register index out of range\n");
       break;
     }
 #endif
@@@@ -546,11 +548,13 @@@@ BX_CPU_C::MOV_RdCd(BxInstruction_t *i)
 {
   // mov control register data to register
 #if BX_CPU_LEVEL < 3
-  bx_panic("MOV_RdCd: not supported on < 386\n");
+  bio->printd("[CPU%u] MOV_RdCd: not supported on < 386\n",BX_SIM_ID);
+  exception(BX_GP_EXCEPTION, 0, 0);
+  return;
 #else
   Bit32u val_32;
 
-  if (v8086_mode()) bx_panic("proc_ctrl: v8086 mode unsupported\n");
+  if (v8086_mode()) bio->panic("proc_ctrl: v8086 mode unsupported\n");
 
   /* NOTES:
    *   32bit operands always used
@@@@ -560,11 +564,13 @@@@ BX_CPU_C::MOV_RdCd(BxInstruction_t *i)
    */
 
   if (i->mod != 0xc0) {
-    bx_panic("MOV_RdCd(): rm field not a register!\n");
+    bio->printd("MOV_RdCd(): rm field not a register!\n");
+    exception(BX_GP_EXCEPTION, 0, 0);
+    return;
     }
 
   if (protected_mode() && CPL!=0) {
-    bx_panic("MOV_RdCd: CPL!=0\n");
+    bio->printd("MOV_RdCd: CPL!=0\n");
     /* #GP(0) if CPL is not 0 */
     exception(BX_GP_EXCEPTION, 0, 0);
     return;
@@@@ -574,38 +580,38 @@@@ BX_CPU_C::MOV_RdCd(BxInstruction_t *i)
     case 0: // CR0 (MSW)
       val_32 = BX_CPU_THIS_PTR cr0.val32;
 #if 0
-      bx_printf("MOV_RdCd:CR0: R32 = %08x\n @@CS:EIP %04x:%04x\n",
+      bio->printd("MOV_RdCd:CR0: R32 = %08x\n @@CS:EIP %04x:%04x\n",
         (unsigned) val_32,
         (unsigned) BX_CPU_THIS_PTR sregs[BX_SEG_REG_CS].selector.value,
         (unsigned) BX_CPU_THIS_PTR eip);
 #endif
       break;
     case 1: /* CR1 */
-      bx_panic("MOV_RdCd: CR1 not implemented yet\n");
+      bio->printd("MOV_RdCd: CR1 not implemented yet\n");
       val_32 = 0;
       break;
     case 2: /* CR2 */
-      if (bx_dbg.creg)
-        bx_printf("MOV_RdCd: CR2\n");
+      if (bio->getdbg().creg)
+        bio->printd("MOV_RdCd: CR2\n");
       val_32 = BX_CPU_THIS_PTR cr2;
       break;
     case 3: // CR3
-      if (bx_dbg.creg)
-        bx_printf("MOV_RdCd: reading CR3\n");
+      if (bio->getdbg().creg)
+        bio->printd("MOV_RdCd: reading CR3\n");
       val_32 = BX_CPU_THIS_PTR cr3;
       break;
     case 4: // CR4
 #if BX_CPU_LEVEL == 3
       val_32 = 0;
-      bx_printf("MOV_RdCd: read of CR4 causes #UD\n");
+      bio->printd("MOV_RdCd: read of CR4 causes #UD\n");
       UndefinedOpcode(i);
 #else
-      bx_printf("MOV_RdCd: read of CR4\n");
+      bio->printd("MOV_RdCd: read of CR4\n");
       val_32 = BX_CPU_THIS_PTR cr4;
 #endif
       break;
     default:
-      bx_panic("MOV_RdCd: control register index out of range\n");
+      bio->printd("MOV_RdCd: control register index out of range\n");
       val_32 = 0;
     }
   BX_WRITE_32BIT_REG(i->rm, val_32);
@@@@ -616,12 +622,12 @@@@ BX_CPU_C::MOV_RdCd(BxInstruction_t *i)
 BX_CPU_C::MOV_TdRd(BxInstruction_t *i)
 {
 #if BX_CPU_LEVEL < 3
-  bx_panic("MOV_TdRd:\n");
+  bio->panic("MOV_TdRd:\n");
 #elif BX_CPU_LEVEL <= 4
-  bx_panic("MOV_TdRd:\n");
+  bio->panic("MOV_TdRd:\n");
 #else
   // Pentium+ does not have TRx.  They were redesigned using the MSRs.
-  bx_printf("MOV_TdRd: causes #UD\n");
+  bio->printd("MOV_TdRd: causes #UD\n");
   UndefinedOpcode(i);
 #endif
 }
@@@@ -630,12 +636,12 @@@@ BX_CPU_C::MOV_TdRd(BxInstruction_t *i)
 BX_CPU_C::MOV_RdTd(BxInstruction_t *i)
 {
 #if BX_CPU_LEVEL < 3
-  bx_panic("MOV_RdTd:\n");
+  bio->panic("MOV_RdTd:\n");
 #elif BX_CPU_LEVEL <= 4
-  bx_panic("MOV_RdTd:\n");
+  bio->panic("MOV_RdTd:\n");
 #else
   // Pentium+ does not have TRx.  They were redesigned using the MSRs.
-  bx_printf("MOV_RdTd: causes #UD\n");
+  bio->printd("MOV_RdTd: causes #UD\n");
   UndefinedOpcode(i);
 #endif
 }
@@@@ -644,7 +650,7 @@@@ BX_CPU_C::MOV_RdTd(BxInstruction_t *i)
 BX_CPU_C::LOADALL(BxInstruction_t *i)
 {
 #if BX_CPU_LEVEL < 2
-  bx_panic("undocumented LOADALL instruction not supported on 8086\n");
+  bio->panic("undocumented LOADALL instruction not supported on 8086\n");
 #else
   Bit16u msw, tr, flags, ip, ldtr;
   Bit16u ds_raw, ss_raw, cs_raw, es_raw;
@@@@ -652,20 +658,20 @@@@ BX_CPU_C::LOADALL(BxInstruction_t *i)
   Bit16u base_15_0, limit;
   Bit8u  base_23_16, access;
 
-  if (v8086_mode()) bx_panic("proc_ctrl: v8086 mode unsupported\n");
+  if (v8086_mode()) bio->panic("proc_ctrl: v8086 mode unsupported\n");
 
 #if BX_CPU_LEVEL > 2
-  bx_panic("loadall: not implemented for 386\n");
+  bio->panic("loadall: not implemented for 386\n");
   /* ??? need to set G and other bits, and compute .limit_scaled also */
   /* for all segments CS,DS,SS,... */
 #endif
 
   if (BX_CPU_THIS_PTR cr0.pe) {
-    bx_panic(
+    bio->panic(
       "LOADALL not yet supported for protected mode\n");
     }
 
-bx_panic("LOADALL: handle CR0.val32\n");
+bio->panic("LOADALL: handle CR0.val32\n");
   /* MSW */
   BX_MEM.read_physical(0x806, 2, &msw);
   BX_CPU_THIS_PTR cr0.pe = (msw & 0x01); msw >>= 1;
@@@@ -673,12 +679,12 @@@@ bx_panic("LOADALL: handle CR0.val32\n");
   BX_CPU_THIS_PTR cr0.em = (msw & 0x01); msw >>= 1;
   BX_CPU_THIS_PTR cr0.ts = (msw & 0x01);
 
-  //bx_printf("LOADALL: pe=%u, mp=%u, em=%u, ts=%u\n",
+  //bio->printd("LOADALL: pe=%u, mp=%u, em=%u, ts=%u\n",
   //  (unsigned) BX_CPU_THIS_PTR cr0.pe, (unsigned) BX_CPU_THIS_PTR cr0.mp,
   //  (unsigned) BX_CPU_THIS_PTR cr0.em, (unsigned) BX_CPU_THIS_PTR cr0.ts);
 
   if (BX_CPU_THIS_PTR cr0.pe || BX_CPU_THIS_PTR cr0.mp || BX_CPU_THIS_PTR cr0.em || BX_CPU_THIS_PTR cr0.ts)
-    bx_panic("LOADALL set PE, MP, EM or TS bits in MSW!\n");
+    bio->panic("LOADALL set PE, MP, EM or TS bits in MSW!\n");
 
   /* TR */
   BX_MEM.read_physical(0x816, 2, &tr);
@@@@ -764,17 +770,17 @@@@ bx_panic("LOADALL: handle CR0.val32\n");
     BX_CPU_THIS_PTR ldtr.cache.u.ldt.limit = limit;
 
     if (access == 0) {
-      bx_panic("loadall: LDTR case access byte=0.\n");
+      bio->panic("loadall: LDTR case access byte=0.\n");
       }
     if ( BX_CPU_THIS_PTR ldtr.cache.valid==0 ) {
-      bx_panic("loadall: ldtr.valid=0\n");
+      bio->panic("loadall: ldtr.valid=0\n");
       }
     if (BX_CPU_THIS_PTR ldtr.cache.segment) { /* not a system segment */
-      bx_printf("         AR byte = %02x\n", (unsigned) access);
-      bx_panic("loadall: LDTR descriptor cache loaded with non system segment\n");
+      bio->printd("         AR byte = %02x\n", (unsigned) access);
+      bio->panic("loadall: LDTR descriptor cache loaded with non system segment\n");
       }
     if ( BX_CPU_THIS_PTR ldtr.cache.type != 2 ) {
-      bx_panic("loadall: LDTR.type(%u) != 2\n", (unsigned) (access & 0x0f));
+      bio->panic("loadall: LDTR.type(%u) != 2\n", (unsigned) (access & 0x0f));
       }
     }
 
@@@@ -804,7 +810,7 @@@@ bx_panic("LOADALL: handle CR0.val32\n");
     }
   if (BX_CPU_THIS_PTR sregs[BX_SEG_REG_DS].cache.valid==0  ||
       BX_CPU_THIS_PTR sregs[BX_SEG_REG_DS].cache.segment==0) {
-    bx_panic("loadall: DS invalid\n");
+    bio->panic("loadall: DS invalid\n");
     }
 
   /* SS */
@@@@ -832,7 +838,7 @@@@ bx_panic("LOADALL: handle CR0.val32\n");
     }
   if (BX_CPU_THIS_PTR sregs[BX_SEG_REG_SS].cache.valid==0  ||
       BX_CPU_THIS_PTR sregs[BX_SEG_REG_SS].cache.segment==0) {
-    bx_panic("loadall: SS invalid\n");
+    bio->panic("loadall: SS invalid\n");
     }
 
 
@@@@ -841,7 +847,7 @@@@ bx_panic("LOADALL: handle CR0.val32\n");
   BX_CPU_THIS_PTR sregs[BX_SEG_REG_CS].selector.value = cs_raw;
   BX_CPU_THIS_PTR sregs[BX_SEG_REG_CS].selector.rpl   = (cs_raw & 0x03); cs_raw >>= 2;
 
-  //bx_printf("LOADALL: setting cs.selector.rpl to %u\n",
+  //bio->printd("LOADALL: setting cs.selector.rpl to %u\n",
   //  (unsigned) BX_CPU_THIS_PTR sregs[BX_SEG_REG_CS].selector.rpl);
 
   BX_CPU_THIS_PTR sregs[BX_SEG_REG_CS].selector.ti    = (cs_raw & 0x01); cs_raw >>= 1;
@@@@ -865,7 +871,7 @@@@ bx_panic("LOADALL: handle CR0.val32\n");
     }
   if (BX_CPU_THIS_PTR sregs[BX_SEG_REG_CS].cache.valid==0  ||
       BX_CPU_THIS_PTR sregs[BX_SEG_REG_CS].cache.segment==0) {
-    bx_panic("loadall: CS invalid\n");
+    bio->panic("loadall: CS invalid\n");
     }
 
   /* ES */
@@@@ -889,17 +895,17 @@@@ bx_panic("LOADALL: handle CR0.val32\n");
   BX_CPU_THIS_PTR sregs[BX_SEG_REG_ES].cache.p          = (access & 0x01);
 
 #if 0
-    bx_printf("cs.dpl = %02x\n", (unsigned) BX_CPU_THIS_PTR sregs[BX_SEG_REG_CS].cache.dpl);
-    bx_printf("ss.dpl = %02x\n", (unsigned) BX_CPU_THIS_PTR sregs[BX_SEG_REG_SS].cache.dpl);
-    bx_printf("BX_CPU_THIS_PTR sregs[BX_SEG_REG_DS].dpl = %02x\n", (unsigned) BX_CPU_THIS_PTR ds.cache.dpl);
-    bx_printf("BX_CPU_THIS_PTR sregs[BX_SEG_REG_ES].dpl = %02x\n", (unsigned) BX_CPU_THIS_PTR es.cache.dpl);
-    bx_printf("LOADALL: setting cs.selector.rpl to %u\n",
+    bio->printd("cs.dpl = %02x\n", (unsigned) BX_CPU_THIS_PTR sregs[BX_SEG_REG_CS].cache.dpl);
+    bio->printd("ss.dpl = %02x\n", (unsigned) BX_CPU_THIS_PTR sregs[BX_SEG_REG_SS].cache.dpl);
+    bio->printd("BX_CPU_THIS_PTR sregs[BX_SEG_REG_DS].dpl = %02x\n", (unsigned) BX_CPU_THIS_PTR ds.cache.dpl);
+    bio->printd("BX_CPU_THIS_PTR sregs[BX_SEG_REG_ES].dpl = %02x\n", (unsigned) BX_CPU_THIS_PTR es.cache.dpl);
+    bio->printd("LOADALL: setting cs.selector.rpl to %u\n",
       (unsigned) BX_CPU_THIS_PTR sregs[BX_SEG_REG_CS].selector.rpl);
-    bx_printf("LOADALL: setting ss.selector.rpl to %u\n",
+    bio->printd("LOADALL: setting ss.selector.rpl to %u\n",
       (unsigned) BX_CPU_THIS_PTR sregs[BX_SEG_REG_SS].selector.rpl);
-    bx_printf("LOADALL: setting ds.selector.rpl to %u\n",
+    bio->printd("LOADALL: setting ds.selector.rpl to %u\n",
       (unsigned) BX_CPU_THIS_PTR sregs[BX_SEG_REG_DS].selector.rpl);
-    bx_printf("LOADALL: setting es.selector.rpl to %u\n",
+    bio->printd("LOADALL: setting es.selector.rpl to %u\n",
       (unsigned) BX_CPU_THIS_PTR sregs[BX_SEG_REG_ES].selector.rpl);
 #endif
 
@@@@ -908,7 +914,7 @@@@ bx_panic("LOADALL: handle CR0.val32\n");
     }
   if (BX_CPU_THIS_PTR sregs[BX_SEG_REG_ES].cache.valid==0  ||
       BX_CPU_THIS_PTR sregs[BX_SEG_REG_ES].cache.segment==0) {
-    bx_panic("loadall: ES invalid\n");
+    bio->panic("loadall: ES invalid\n");
     }
 
   /* DI */
@@@@ -953,7 +959,7 @@@@ bx_panic("LOADALL: handle CR0.val32\n");
 
 #if 0
   if (access)
-      bx_printf("LOADALL: GDTR access bits not 0 (%02x).\n",
+      bio->printd("LOADALL: GDTR access bits not 0 (%02x).\n",
         (unsigned) access);
 #endif
 
@@@@ -1042,14 +1048,13 @@@@ BX_CPU_C::CPUID(BxInstruction_t *i)
       features |= 0x01;
 #  endif
 
-#else
-      family = 6;
-      bx_panic("CPUID: not implemented for > 5\n");
-#endif
-
       EAX = (family <<8) | (model<<4) | stepping;
       EBX = ECX = 0; // reserved
       EDX = features;
+#else
+      family = 6;
+      bio->printd("CPUID: not implemented for > 5\n");
+#endif
       break;
 
     default:
@@@@ -1057,7 +1062,7 @@@@ BX_CPU_C::CPUID(BxInstruction_t *i)
       break;
     }
 #else
-  bx_panic("CPUID: not available on < late 486\n");
+  bio->panic("CPUID: not available on < late 486\n");
 #endif
 }
 
@@@@ -1099,7 +1104,7 @@@@ BX_CPU_C::SetCR0(Bit32u val_32)
 #endif
 
   //if (BX_CPU_THIS_PTR cr0.ts)
-  //  bx_printf("MOV_CdRd:CR0.TS set 0x%x\n", (unsigned) val_32);
+  //  bio->printd("MOV_CdRd:CR0.TS set 0x%x\n", (unsigned) val_32);
 
   if (prev_pe==0 && BX_CPU_THIS_PTR cr0.pe) {
     enter_protected_mode();
@@@@ -1121,7 +1126,8 @@@@ BX_CPU_C::RSM(BxInstruction_t *i)
 #if BX_CPU_LEVEL >= 4
   invalidate_prefetch_q();
 
-  bx_panic("RSM: System Management Mode not implemented yet\n");
+  bio->printd("RSM: System Management Mode not implemented yet\n");
+  UndefinedOpcode(i);
 #else
   UndefinedOpcode(i);
 #endif
@@@@ -1131,7 +1137,8 @@@@ BX_CPU_C::RSM(BxInstruction_t *i)
 BX_CPU_C::RDTSC(BxInstruction_t *i)
 {
 #if BX_CPU_LEVEL >= 5
-  bx_panic("RDTSC: not implemented yet\n");
+  bio->printd("RDTSC: not implemented yet\n");
+  UndefinedOpcode(i);
 #else
   UndefinedOpcode(i);
 #endif
@@@@ -1141,7 +1148,8 @@@@ BX_CPU_C::RDTSC(BxInstruction_t *i)
 BX_CPU_C::RDMSR(BxInstruction_t *i)
 {
 #if BX_CPU_LEVEL >= 5
-  bx_panic("RDMSR: not implemented yet\n");
+  bio->printd("[CPU%u] RDMSR: not implemented yet\n",BX_SIM_ID);
+  UndefinedOpcode(i);
 #else
   UndefinedOpcode(i);
 #endif
@@@@ -1153,7 +1161,8 @@@@ BX_CPU_C::WRMSR(BxInstruction_t *i)
 #if BX_CPU_LEVEL >= 5
   invalidate_prefetch_q();
 
-  bx_panic("WRMSR: not implemented yet\n");
+  bio->printd("WRMSR: not implemented yet\n");
+  UndefinedOpcode(i);
 #else
   UndefinedOpcode(i);
 #endif
@


1.3
log
@more printd
@
text
@d1 1
a1 1
$OpenBSD: patch-cpu_proc_ctrl_cc,v 1.2 2001/03/30 16:47:02 todd Exp $
@


1.2
log
@implement printd to silence printing of user unfriendly info (aka only
for developers); much less output now.
@
text
@d1 1
a1 1
$OpenBSD: patch-cpu_proc_ctrl_cc,v 1.1 2001/02/02 16:59:09 todd Exp $
d3 1
a3 1
+++ cpu/proc_ctrl.cc	Fri Mar 30 10:09:57 2001
d688 1
a688 1
@@@@ -1121,7 +1126,7 @@@@ BX_CPU_C::RSM(BxInstruction_t *i)
d693 2
a694 1
+  bio->panic("RSM: System Management Mode not implemented yet\n");
d698 1
a698 1
@@@@ -1131,7 +1136,7 @@@@ BX_CPU_C::RSM(BxInstruction_t *i)
d703 2
a704 1
+  bio->panic("RDTSC: not implemented yet\n");
d708 1
a708 1
@@@@ -1141,7 +1146,8 @@@@ BX_CPU_C::RDTSC(BxInstruction_t *i)
d718 1
a718 1
@@@@ -1153,7 +1159,7 @@@@ BX_CPU_C::WRMSR(BxInstruction_t *i)
d723 2
a724 1
+  bio->panic("WRMSR: not implemented yet\n");
@


1.1
log
@o take over maintainership
o too many changes to mention specifically, but amongst them:
	- better error reporting
	- openbsd boots, freebsd boots
	- new 'term' flavor, I added a textmode interface, the only drawback
	  is that control-c is intercepted, and you must kill -9 it from
	  another tty if it doesn't exit normally
	- new flavors:
		- debugger -> debug (for shortness)
		- i386
		- pci
		- smp
		- net (compiles, does not yet provide networking, if anyone
			wants to help, I'd be ELATED to have this fixed!)
		- no_x11 (made it actually work)
		- term (make sure to use 'log: /dev/null' or something else
		  on the cmdline, otherwise, debugging and the screen will
		  start getting quite confusing!)
	- better error reporting (and no error reporting where it is not
	  necessary; a typicall boot of cdrom28.fs is a screenful of output now)
	- in general, if the hardware reaches an unknown state, fail
	  gracefully instead of calling exit(1) .. are we trying to work or
	  are we trying to .. fail?  I like working myself.
@
text
@d1 1
a1 1
$OpenBSD: update-patches,v 1.3 2000/06/09 17:08:37 espie Exp $
d3 1
a3 1
+++ cpu/proc_ctrl.cc	Thu Oct 19 17:34:18 2000
d9 1
a9 1
+    bio->printf("UndefinedOpcode: %02x causes exception 6\n",
d23 1
a23 1
+	bio->printf("[CPU%n] HLT(): CPL!=0\n",BX_SIM_ID);
d31 1
a31 1
+    bio->printf("WARNING: HLT instruction with IF=0!\n");
d52 1
a52 1
+    bio->printf("CLTS(): CPL!=0\n");
d63 3
a65 3
+  bio->printf("---------------\n");
+  bio->printf("- INVD called -\n");
+  bio->printf("---------------\n");
d73 1
a73 1
+      bio->printf("INVD: CPL!=0\n");
d82 1
a82 1
+  bio->printf("WBINVD: (ignoring)\n");
d90 1
a90 1
+      bio->printf("WBINVD: CPL!=0\n");
d129 1
a129 1
+    bio->printf("MOV_DdRd: DR[%u]=%08xh unhandled\n",
d138 1
a138 1
+        bio->printf("MOV_DdRd: access to DR4 causes #UD\n");
d147 1
a147 1
+        bio->printf("MOV_DdRd: access to DR5 causes #UD\n");
d205 1
a205 1
+    bio->printf("MOV_RdDd: v8086 mode causes #GP\n");
d217 1
a217 1
+    bio->printf("MOV_RdDd: CPL!=0 causes #GP\n");
d225 1
a225 1
+    bio->printf("MOV_RdDd: DR%u not implemented yet\n", i->nnn);
d234 1
a234 1
+        bio->printf("MOV_RdDd: access to DR4 causes #UD\n");
d243 1
a243 1
+        bio->printf("MOV_RdDd: access to DR5 causes #UD\n");
d272 1
a272 1
+      bio->printf("LMSW: CPL != 0, CPL=%u\n", (unsigned) CPL);
d290 1
a290 1
+  bio->printf("MOV_CdRd: not supported on < 386\n");
d308 1
a308 1
+    bio->printf("MOV_CdRd(): rm field not a register!\n");
d317 1
a317 1
+    bio->printf("MOV_CdRd: CPL!=0\n");
d326 1
a326 1
+      // bio->printf("MOV_CdRd:CR0: R32 = %08x\n @@CS:EIP %04x:%04x ",
d341 1
a341 1
+      bio->printf("MOV_CdRd: CR2 not implemented yet\n");
d343 1
a343 1
+        bio->printf("MOV_CdRd: CR2 = reg\n");
d350 1
a350 1
+        bio->printf("MOV_CdRd:(%08x)\n", (unsigned) val_32);
d359 1
a359 1
+      bio->printf("[CPU%u] MOV_CdRd: write to CR4 of 0x%08x on 386\n",
d367 1
a367 1
+      bio->printf("MOV_CdRd: ignoring write to CR4 of 0x%08x\n",
d392 1
a392 1
+  bio->printf("[CPU%u] MOV_RdCd: not supported on < 386\n",BX_SIM_ID);
d408 1
a408 1
+    bio->printf("MOV_RdCd(): rm field not a register!\n");
d415 1
a415 1
+    bio->printf("MOV_RdCd: CPL!=0\n");
d424 1
a424 1
+      bio->printf("MOV_RdCd:CR0: R32 = %08x\n @@CS:EIP %04x:%04x\n",
d432 1
a432 1
+      bio->printf("MOV_RdCd: CR1 not implemented yet\n");
d439 1
a439 1
+        bio->printf("MOV_RdCd: CR2\n");
d446 1
a446 1
+        bio->printf("MOV_RdCd: reading CR3\n");
d453 1
a453 1
+      bio->printf("MOV_RdCd: read of CR4 causes #UD\n");
d457 1
a457 1
+      bio->printf("MOV_RdCd: read of CR4\n");
d463 1
a463 1
+      bio->printf("MOV_RdCd: control register index out of range\n");
d479 1
a479 1
+  bio->printf("MOV_TdRd: causes #UD\n");
d495 1
a495 1
+  bio->printf("MOV_RdTd: causes #UD\n");
d538 1
a538 1
+  //bio->printf("LOADALL: pe=%u, mp=%u, em=%u, ts=%u\n",
d562 1
a562 1
+      bio->printf("         AR byte = %02x\n", (unsigned) access);
d594 1
a594 1
+  //bio->printf("LOADALL: setting cs.selector.rpl to %u\n",
d616 5
a620 5
+    bio->printf("cs.dpl = %02x\n", (unsigned) BX_CPU_THIS_PTR sregs[BX_SEG_REG_CS].cache.dpl);
+    bio->printf("ss.dpl = %02x\n", (unsigned) BX_CPU_THIS_PTR sregs[BX_SEG_REG_SS].cache.dpl);
+    bio->printf("BX_CPU_THIS_PTR sregs[BX_SEG_REG_DS].dpl = %02x\n", (unsigned) BX_CPU_THIS_PTR ds.cache.dpl);
+    bio->printf("BX_CPU_THIS_PTR sregs[BX_SEG_REG_ES].dpl = %02x\n", (unsigned) BX_CPU_THIS_PTR es.cache.dpl);
+    bio->printf("LOADALL: setting cs.selector.rpl to %u\n",
d623 1
a623 1
+    bio->printf("LOADALL: setting ss.selector.rpl to %u\n",
d626 1
a626 1
+    bio->printf("LOADALL: setting ds.selector.rpl to %u\n",
d629 1
a629 1
+    bio->printf("LOADALL: setting es.selector.rpl to %u\n",
d647 1
a647 1
+      bio->printf("LOADALL: GDTR access bits not 0 (%02x).\n",
d665 1
a665 1
+      bio->printf("CPUID: not implemented for > 5\n");
d684 1
a684 1
+  //  bio->printf("MOV_CdRd:CR0.TS set 0x%x\n", (unsigned) val_32);
d711 1
a711 1
+  bio->printf("[CPU%u] RDMSR: not implemented yet\n",BX_SIM_ID);
@

