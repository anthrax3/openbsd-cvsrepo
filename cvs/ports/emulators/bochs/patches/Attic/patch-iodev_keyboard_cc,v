head	1.3;
access;
symbols
	OPENBSD_2_9:1.2.0.2
	OPENBSD_2_9_BASE:1.2;
locks; strict;
comment	@# @;


1.3
date	2001.05.26.06.02.31;	author todd;	state dead;
branches;
next	1.2;

1.2
date	2001.03.30.16.47.03;	author todd;	state Exp;
branches;
next	1.1;

1.1
date	2001.02.02.16.59.11;	author todd;	state Exp;
branches;
next	;


desc
@@


1.3
log
@gone are the days when bochs feedback heads to /dev/null
did I mention I commit this inside of bochs?  Thanks, angelos, for networking!
@
text
@$OpenBSD: patch-iodev_keyboard_cc,v 1.2 2001/03/30 16:47:03 todd Exp $
--- iodev/keyboard.cc.orig	Sat Mar 25 21:28:49 2000
+++ iodev/keyboard.cc	Fri Mar 30 10:45:28 2001
@@@@ -131,7 +131,7 @@@@ bx_keyb_c::init(bx_devices_c *d, bx_cmos
   BX_KEY_THIS s.kbd_controller.irq1_requested = 0;
   BX_KEY_THIS s.kbd_controller.irq12_requested = 0;
 
-//fprintf(stderr, "# keyboard_serial_delay is %u usec\n",
+//bio->printd("#KBD] keyboard_serial_delay is %u usec\n",
 //        (unsigned) bx_options.keyboard_serial_delay);
   BX_KEY_THIS s.kbd_controller.timer_pending = 0;
 
@@@@ -175,12 +175,14 @@@@ bx_keyb_c::read(Bit32u   address, unsign
 
   Bit32u ret = 0;
 
-  if (io_len > 1)
-    bx_panic("kbd: io read to address %08x, len=%u\n",
+  if (io_len > 1) {
+    bio->printd("[KBD] io read to address %08x, len=%u\n",
              (unsigned) address, (unsigned) io_len);
+    return ret;
+  }
 
 
-//fprintf(stderr, "# KBD: read from port 0x%04x\n", (unsigned) address);
+//bio->printd("#KBD] read from port 0x%04x\n", (unsigned) address);
 
   if (address == 0x60) { /* output buffer */
     Bit8u   val;
@@@@ -204,11 +206,11 @@@@ bx_keyb_c::read(Bit32u   address, unsign
         BX_KEY_THIS s.controller_Qsize--;
         }
 
-//bx_printf("mouse: ___io_read aux = 0x%02x\n", (unsigned) val);
+//bio->printd("[MOUSE] ___io_read aux = 0x%02x\n", (unsigned) val);
 
       activate_timer();
-      if (bx_dbg.keyboard)
-        bx_printf("KBD: READ(%02x) = %02x\n", (unsigned) address,
+      if (bio->getdbg().keyboard)
+        bio->printd("[KBD] READ(%02x) = %02x\n", (unsigned) address,
           (unsigned) val);
       RETURN(val);
       }
@@@@ -217,7 +219,7 @@@@ bx_keyb_c::read(Bit32u   address, unsign
       BX_KEY_THIS s.kbd_controller.kbd_output_buffer = 0;
       BX_KEY_THIS s.kbd_controller.outb = 0;
       BX_KEY_THIS s.kbd_controller.auxb = 0;
-//fprintf(stderr, "# ___io_read kbd\n");
+//bio->printd("#MOUSE] ___io_read kbd\n");
 
       if (BX_KEY_THIS s.controller_Qsize) {
         unsigned i;
@@@@ -234,15 +236,15 @@@@ bx_keyb_c::read(Bit32u   address, unsign
         }
 
       activate_timer();
-      if (bx_dbg.keyboard)
-        bx_printf("KBD: READ(%02x) = %02x\n", (unsigned) address,
+      if (bio->getdbg().keyboard)
+        bio->printd("[KBD] READ(%02x) = %02x\n", (unsigned) address,
           (unsigned) val);
       RETURN(val);
       }
     else {
-      if (bx_dbg.keyboard) {
-        bx_printf("KBD: num_elements = %d\n", BX_KEY_THIS s.kbd_internal_buffer.num_elements);
-        bx_printf("KBD: read from port 60h with outb empty\n");
+      if (bio->getdbg().keyboard) {
+        bio->printd("[KBD] num_elements = %d\n", BX_KEY_THIS s.kbd_internal_buffer.num_elements);
+        bio->printd("[KBD] read from port 60h with outb empty\n");
         }
       val = 0;
       RETURN(val);
@@@@ -267,21 +269,21 @@@@ bx_keyb_c::read(Bit32u   address, unsign
 #else /* BX_CPU_LEVEL > 0 */
   /* XT MODE, System 8255 Mode Register */
   else if (address == 0x64) { /* status register */
-    if (bx_dbg.keyboard)
-      bx_printf("KBD: IO read from port 64h, system 8255 mode register\n");
+    if (bio->getdbg().keyboard)
+      bio->printd("[KBD] IO read from port 64h, system 8255 mode register\n");
     RETURN(BX_KEY_THIS s.kbd_controller.outb);
     }
 #endif /* BX_CPU_LEVEL > 0 */
 
   else {
-    bx_panic("KBD: unknown address in io read to keyboard port %x\n",
+    bio->printd("[KBD] unknown address in io read to keyboard port %x\n",
       (unsigned) address);
     RETURN(0); /* keep compiler happy */
     }
 
   read_return:
-  if (bx_dbg.keyboard)
-	bx_printf("keyboard: 8-bit read from %04x = %02x\n", (unsigned)address, ret);
+  if (bio->getdbg().keyboard)
+	bio->printd("[KBD] 8-bit read from %04x = %02x\n", (unsigned)address, ret);
   return ret;
 }
 
@@@@ -306,15 +308,17 @@@@ bx_keyb_c::write( Bit32u   address, Bit3
 #endif  // !BX_USE_KEY_SMF
   Bit8u   command_byte;
 
-  if (io_len > 1)
-    bx_panic("kbd: io write to address %08x, len=%u\n",
+  if (io_len > 1) {
+    bio->printd("[KBD] io write to address %08x, len=%u\n",
              (unsigned) address, (unsigned) io_len);
+    return;
+  }
 
-  if (bx_dbg.keyboard)
-	bx_printf("keyboard: 8-bit write to %04x = %02x\n", (unsigned)address, (unsigned)value);
+  if (bio->getdbg().keyboard)
+	bio->printd("[KBD] 8-bit write to %04x = %02x\n", (unsigned)address, (unsigned)value);
 
 
-//fprintf(stderr, "# KBD: WRITE(%02x) = %02x\n", (unsigned) address,
+//bio->printd("[KBD] WRITE(%02x) = %02x\n", (unsigned) address,
 //      (unsigned) value);
 
   switch (address) {
@@@@ -325,7 +329,8 @@@@ bx_keyb_c::write( Bit32u   address, Bit3
         // data byte written last to 0x60
         BX_KEY_THIS s.kbd_controller.c_d = 0;
         if (BX_KEY_THIS s.kbd_controller.inpb) {
-          bx_panic("KBD: write to port 60h, not ready for write\n");
+          bio->printd("[KBD] write to port 60h, not ready for write\n");
+	  break;
           }
         switch (BX_KEY_THIS s.kbd_controller.last_comm) {
           case 0x60: // write command byte
@@@@ -346,21 +351,22 @@@@ bx_keyb_c::write( Bit32u   address, Bit3
             else if (BX_KEY_THIS s.kbd_controller.allow_irq1  && BX_KEY_THIS s.kbd_controller.outb)
               BX_KEY_THIS s.kbd_controller.irq1_requested = 1;
 
-//fprintf(stderr, "# allow_irq12 set to %u\n", (unsigned)
+//bio->printd("#KBD] allow_irq12 set to %u\n", (unsigned)
 //  BX_KEY_THIS s.kbd_controller.allow_irq12);
             if ( !scan_convert )
-              bx_printf("keyboard: (mch) scan convert turned off\n");
+              bio->printd("[KBD] (mch) scan convert turned off\n");
 
 	    // (mch) NT needs this
 	    BX_KEY_THIS s.kbd_controller.scan_convert = scan_convert;
             }
             break;
           case 0xd1: // write output port
-            if (bx_dbg.keyboard)
-              bx_printf("KBD: write output port with value %02xh\n",
+            if (bio->getdbg().keyboard)
+              bio->printd("[KBD] write output port with value %02xh\n",
                 (unsigned) value);
             BX_SET_ENABLE_A20( (value & 0x02) != 0 );
-            if (!(value & 0x01)) bx_panic("KBD: IO write: processor reset requested!\n");
+            if (!(value & 0x01)) /* XXX insert reset?? */
+		bio->printd("[KBD] IO write: processor reset requested!\n");
             break;
           case 0xd4: // Write to mouse
             // I don't think this enables the AUX clock
@@@@ -375,7 +381,7 @@@@ bx_keyb_c::write( Bit32u   address, Bit3
             break;
 
           default:
-            bx_panic("KBD: === unsupported write to port 60h(lastcomm=%02x): %02x\n",
+            bio->printd("[KBD] === unsupported write to port 60h(lastcomm=%02x): %02x\n",
               (unsigned) BX_KEY_THIS s.kbd_controller.last_comm, (unsigned) value);
           }
         }
@@@@ -386,7 +392,7 @@@@ bx_keyb_c::write( Bit32u   address, Bit3
         /* pass byte to keyboard */
         /* ??? should conditionally pass to mouse device here ??? */
         if (BX_KEY_THIS s.kbd_controller.kbd_clock_enabled==0) {
-          bx_printf("KBD: keyboard disabled & send of byte %02x to kbd\n",
+          bio->printd("[KBD] keyboard disabled & send of byte %02x to kbd\n",
             (unsigned) value);
           }
         kbd_ctrl_to_kbd(value);
@@@@ -402,11 +408,12 @@@@ bx_keyb_c::write( Bit32u   address, Bit3
 
       switch (value) {
         case 0x20: // get keyboard command byte
-          if (bx_dbg.keyboard)
-            bx_printf("KBD: get keyboard command byte\n");
+          if (bio->getdbg().keyboard)
+            bio->printd("[KBD] get keyboard command byte\n");
           // controller output buffer must be empty
           if (BX_KEY_THIS s.kbd_controller.outb) {
-bx_panic("kbd: OUTB set and command 0x%02x encountered\n", value);
+		bio->printd("[KBD] OUTB set and command 0x%02x encountered\n",
+			value);
             break;
             }
           command_byte =
@@@@ -420,37 +427,39 @@@@ bx_panic("kbd: OUTB set and command 0x%0
           controller_enQ(command_byte, 0);
           break;
         case 0x60: // write command byte
-          if (bx_dbg.keyboard)
-            bx_printf("KBD: write command byte\n");
+          if (bio->getdbg().keyboard)
+            bio->printd("[KBD] write command byte\n");
           // following byte written to port 60h is command byte
           BX_KEY_THIS s.kbd_controller.expecting_port60h = 1;
           break;
 
         case 0xa1:
-          bx_printf ("KBD: Dummy out Green PC for now : 0xa1\n");
+          bio->printd ("[KBD] Dummy out Green PC for now : 0xa1\n");
           break;
 
         case 0xa7: // disable the aux device
           set_aux_clock_enable(0);
-          if (bx_dbg.keyboard) bx_printf("KBD: aux device disabled\n");
+          if (bio->getdbg().keyboard) bio->printd("[KBD] aux device disabled\n");
           break;
         case 0xa8: // enable the aux device
           set_aux_clock_enable(1);
-          if (bx_dbg.keyboard) bx_printf("KBD: aux device enabled\n");
+          if (bio->getdbg().keyboard) bio->printd("[KBD] aux device enabled\n");
           break;
         case 0xa9: // Test Mouse Port
           // controller output buffer must be empty
           if (BX_KEY_THIS s.kbd_controller.outb) {
-bx_panic("kbd: OUTB set and command 0x%02x encountered\n", value);
+		bio->printd("[KBD] OUTB set and command 0x%02x encountered\n",
+			value);
             break;
             }
           controller_enQ(0x00, 0); // no errors detected
           break;
         case 0xaa: // motherboard controller self test
-          if (bx_dbg.keyboard) bx_printf("KBD: Self Test\n");
+          if (bio->getdbg().keyboard) bio->printd("[KBD] Self Test\n");
           // controller output buffer must be empty
           if (BX_KEY_THIS s.kbd_controller.outb) {
-bx_panic("kbd: OUTB set and command 0x%02x encountered\n", value);
+		bio->printd("[KBD] OUTB set and command 0x%02x encountered\n",
+			value);
             break;
             }
 	  // (mch) Why is this commented out??? Enabling
@@@@ -460,34 +469,35 @@@@ bx_panic("kbd: OUTB set and command 0x%0
         case 0xab: // Interface Test
           // controller output buffer must be empty
           if (BX_KEY_THIS s.kbd_controller.outb) {
-bx_panic("kbd: OUTB set and command 0x%02x encountered\n", value);
+bio->printd("[KBD] OUTB set and command 0x%02x encountered\n", value);
             break;
             }
           controller_enQ(0x00, 0);
           break;
         case 0xad: // disable keyboard
           set_kbd_clock_enable(0);
-          if (bx_dbg.keyboard) bx_printf("KBD: keyboard disabled\n");
+          if (bio->getdbg().keyboard) bio->printd("[KBD] keyboard disabled\n");
           break;
         case 0xae: // enable keyboard
           set_kbd_clock_enable(1);
-          if (bx_dbg.keyboard) bx_printf("KBD: keyboard enabled\n");
+          if (bio->getdbg().keyboard) bio->printd("[KBD] keyboard enabled\n");
           break;
         case 0xc0: // read input port
           // controller output buffer must be empty
           if (BX_KEY_THIS s.kbd_controller.outb) {
-bx_panic("kbd: OUTB set and command 0x%02x encountered\n", value);
+		bio->printd("[KBD] OUTB set and command 0x%02x encountered\n",
+			value);
             break;
             }
           // keyboard power normal
           controller_enQ(0x00, 0);
           break;
         case 0xd0: // read output port: next byte read from port 60h
-          if (bx_dbg.keyboard)
-            bx_printf("KBD: io write to port 64h, command d0h (partial)\n");
+          if (bio->getdbg().keyboard)
+            bio->printd("[KBD] io write to port 64h, command d0h (partial)\n");
           // controller output buffer must be empty
           if (BX_KEY_THIS s.kbd_controller.outb) {
-bx_panic("kbd: OUTB set and command 0x%02x encountered\n", value);
+bio->printd("[KBD] OUTB set and command 0x%02x encountered\n", value);
             break;
             }
           controller_enQ(
@@@@ -498,20 +508,20 @@@@ bx_panic("kbd: OUTB set and command 0x%0
           break;
 
         case 0xd1: // write output port: next byte written to port 60h
-          if (bx_dbg.keyboard)
-            bx_printf("KBD: write output port\n");
+          if (bio->getdbg().keyboard)
+            bio->printd("[KBD] write output port\n");
           // following byte to port 60h written to output port
           BX_KEY_THIS s.kbd_controller.expecting_port60h = 1;
           break;
 
         case 0xd3: // write mouse output buffer
-          bx_panic("KBD: io write 0x64: command = 0xD3(write mouse outb)\n");
+          bio->printd("[KBD] io write 0x64: command = 0xD3(write mouse outb)\n");
           BX_KEY_THIS s.kbd_controller.expecting_port60h = 1;
           break;
 
         case 0xd4: // write to mouse
-          if (bx_dbg.mouse)
-            bx_printf("KBD: io write 0x64: command = 0xD4 (write to mouse)\n");
+          if (bio->getdbg().mouse)
+            bio->printd("[KBD] io write 0x64: command = 0xD4 (write to mouse)\n");
           // following byte written to port 60h
           BX_KEY_THIS s.kbd_controller.expecting_port60h = 1;
           break;
@@@@ -522,32 +532,34 @@@@ bx_panic("kbd: OUTB set and command 0x%0
         case 0xc1: // Continuous Input Port Poll, Low
         case 0xc2: // Continuous Input Port Poll, High
         case 0xe0: // Read Test Inputs
-          bx_panic("KBD: io write 0x64: command = %02xh\n", (unsigned) value);
+          bio->printd("[KBD] io write 0x64: command = %02xh\n", (unsigned) value);
           break;
 
         case 0xfe: // System Reset, transition to real mode
-          if (bx_dbg.keyboard)
-            bx_printf("KBD: system reset\n");
-          bx_panic("system reset via KBD ctrl command FEh\n");
+          if (bio->getdbg().keyboard)
+            bio->printd("[KBD] system reset via ctrl command FEh\n");
+          bx_pc_system.ResetSignal( PCS_SET ); /* XXX is this right? */
+	  BX_CPU.reset(BX_RESET_HARDWARE);
           // Use bx_pc_system if necessary bx_cpu.reset_cpu();
-          bx_pc_system.ResetSignal( PCS_SET );
+          // bx_pc_system.ResetSignal( PCS_SET );
           break;
 
         default:
           if (value==0xff || (value>=0xf0 && value<=0xfd)) {
             /* useless pulse output bit commands ??? */
-            if (bx_dbg.keyboard)
-              bx_printf("KBD: io write to port 64h, useless command %02x\n",
+            if (bio->getdbg().keyboard)
+              bio->printd("[KBD] io write to port 64h, useless command %02x\n",
                 (unsigned) value);
             return;
 	    }
-          bx_panic("KBD: unsupported io write to keyboard port %x, value = %x\n",
+          bio->printd("[KBD] unsupported io write to keyboard port %x, value = %x\n",
             (unsigned) address, (unsigned) value);
           break;
         }
       break;
 
-    default: bx_panic("KBD: unknown address in bx_keyb_c::write()\n");
+    default:
+	bio->printd("[KBD] unknown address in bx_keyb_c::write()\n");
     }
 }
 
@@@@ -557,15 +569,17 @@@@ bx_keyb_c::gen_scancode(Bit32u   key)
 {
   Bit8u   scancode;
 
-  if (bx_dbg.record_io) {
-	fprintf((FILE*)bx_dbg.record_io, "gen_scancode %lld %x\n", bx_pc_system.time_ticks(), key);
+  if (bio->getdbg().record_io) {
+	bio->printd("[KBD] gen_scancode %lld %x\n", bx_pc_system.time_ticks(), key);
   }
 
-  if (!BX_KEY_THIS s.kbd_controller.scan_convert)
-	bx_panic("keyboard: gen_scancode with scan_convert cleared\n");
+  if (!BX_KEY_THIS s.kbd_controller.scan_convert) {
+	bio->printd("[KBD] gen_scancode with scan_convert cleared\n");
+	return;
+  }
 
-  if (bx_dbg.keyboard)
-    bx_printf("KBD: gen_scancode(): scancode: %08x\n", (unsigned) key);
+  if (bio->getdbg().keyboard)
+    bio->printd("[KBD] gen_scancode(): scancode: %08x\n", (unsigned) key);
 
   // Ignore scancode if keyboard clock is driven low
   if (BX_KEY_THIS s.kbd_controller.kbd_clock_enabled==0)
@@@@ -640,20 +654,21 @@@@ bx_keyb_c::gen_scancode(Bit32u   key)
     case BX_KEY_GRAVE:         scancode = 0x29; break;
 
     case BX_KEY_BACKSPACE:     scancode = 0x0e; break;
+    case BX_KEY_KP_ENTER:
     case BX_KEY_ENTER:         scancode = 0x1c; break;
     case BX_KEY_TAB:           scancode = 0x0f; break;
 
     case BX_KEY_LEFT:
-      //fprintf(stderr,"# Grey left-arrow key not on 83-key keyboard\n");
+      //bio->printd("#KBD] Grey left-arrow key not on 83-key keyboard\n");
       scancode = 0x4b; break;
     case BX_KEY_RIGHT:
-      //fprintf(stderr,"# Grey right-arrow key not on 83-key keyboard\n");
+      //bio->printd("#KBD] Grey right-arrow key not on 83-key keyboard\n");
       scancode = 0x4d; break;
     case BX_KEY_UP:
-      //fprintf(stderr,"# Grey up-arrow key not on 83-key keyboard\n");
+      //bio->printd("#KBD] Grey up-arrow key not on 83-key keyboard\n");
       scancode = 0x48; break;
     case BX_KEY_DOWN:
-      //fprintf(stderr,"# Grey down-arrow key not on 83-key keyboard\n");
+      //bio->printd("#KBD] Grey down-arrow key not on 83-key keyboard\n");
       scancode = 0x50; break;
 
     case BX_KEY_KP_LEFT:       scancode = 0x4b; break;
@@@@ -661,43 +676,46 @@@@ bx_keyb_c::gen_scancode(Bit32u   key)
     case BX_KEY_KP_UP:         scancode = 0x48; break;
     case BX_KEY_KP_DOWN:       scancode = 0x50; break;
 
-    case BX_KEY_INSERT:
-      fprintf(stderr,"# Grey insert key not on 83-key keyboard\n");
-      return;
-    case BX_KEY_DELETE:
-      fprintf(stderr,"# Grey delete key not on 83-key keyboard\n");
-      return;
-    case BX_KEY_HOME:
-      fprintf(stderr,"# Grey home key not on 83-key keyboard\n");
-      return;
-    case BX_KEY_END:
-      fprintf(stderr,"# Grey end key not on 83-key keyboard\n");
-      return;
-    case BX_KEY_PAGE_UP:
-      fprintf(stderr,"# Grey page-up key not on 83-key keyboard\n");
-      return;
-    case BX_KEY_PAGE_DOWN:
-      fprintf(stderr,"# Grey page-down key not on 83-key keyboard\n");
-      return;
+    //case BX_KEY_INSERT:
+      //bio->printd("#KBD] Grey insert key not on 83-key keyboard\n");
+      //return;
+    //case BX_KEY_DELETE:
+      //bio->printd("#KBD] Grey delete key not on 83-key keyboard\n");
+      //return;
+    //case BX_KEY_HOME:
+      //bio->printd("#KBD] Grey home key not on 83-key keyboard\n");
+      //return;
+    //case BX_KEY_END:
+      //bio->printd("#KBD] Grey end key not on 83-key keyboard\n");
+      //return;
+    //case BX_KEY_PAGE_UP:
+      //bio->printd("#KBD] Grey page-up key not on 83-key keyboard\n");
+      //return;
+    //case BX_KEY_PAGE_DOWN:
+      //bio->printd("#KBD] Grey page-down key not on 83-key keyboard\n");
+      //return;
 
+    case BX_KEY_INSERT:
     case BX_KEY_KP_INSERT:        scancode = 0x52; break;
+    case BX_KEY_DELETE:
     case BX_KEY_KP_DELETE:        scancode = 0x53; break;
+    case BX_KEY_HOME:
     case BX_KEY_KP_HOME:          scancode = 0x47; break;
+    case BX_KEY_END:
     case BX_KEY_KP_END:           scancode = 0x4f; break;
+    case BX_KEY_PAGE_UP:
     case BX_KEY_KP_PAGE_UP:       scancode = 0x49; break;
+    case BX_KEY_PAGE_DOWN:
     case BX_KEY_KP_PAGE_DOWN:     scancode = 0x51; break;
 
     case BX_KEY_KP_ADD:           scancode = 0x4e; break;
     case BX_KEY_KP_SUBTRACT:      scancode = 0x4a; break;
     case BX_KEY_KP_5:             scancode = 0x4c; break;
-    case BX_KEY_KP_ENTER:
-      fprintf(stderr,"# Grey Enter key not on 83-key keyboard\n");
-      return;
     case BX_KEY_KP_MULTIPLY:
-      fprintf(stderr,"# Grey Multiply key not on 83-key keyboard\n");
+      bio->printd("#KBD] Grey Multiply key not on 83-key keyboard\n");
       return;
     case BX_KEY_KP_DIVIDE:
-      fprintf(stderr,"# Grey Divide key not on 83-key keyboard\n");
+      bio->printd("#KBD] Grey Divide key not on 83-key keyboard\n");
       return;
     case BX_KEY_NUM_LOCK:         scancode = 0x45; break;
 
@@@@ -713,7 +731,7 @@@@ bx_keyb_c::gen_scancode(Bit32u   key)
     case BX_KEY_F10:              scancode = 0x44; break;
 
     default:
-      fprintf(stderr, "# bx_keyb_c::gen_scancode : Unhandled %u\n",
+      bio->printd("#KBD] bx_keyb_c::gen_scancode : Unhandled %u\n",
         (unsigned) key);
       return;
     }
@@@@ -750,8 +768,8 @@@@ bx_keyb_c::set_aux_clock_enable(Bit8u   
 {
   Boolean prev_aux_clock_enabled;
 
-  if (bx_dbg.keyboard)
-	bx_printf("set_aux_clock_enable(%u)\n", (unsigned) value);
+  if (bio->getdbg().keyboard)
+	bio->printd("[KBD] set_aux_clock_enable(%u)\n", (unsigned) value);
   if (value==0) {
     BX_KEY_THIS s.kbd_controller.aux_clock_enabled = 0;
     }
@@@@ -768,8 +786,8 @@@@ bx_keyb_c::set_aux_clock_enable(Bit8u   
 bx_keyb_c::get_kbd_enable(void)
 {
 #ifdef BX_DEBUG
-  if (bx_dbg.keyboard)
-    bx_printf("KBD: get_kbd_enable(): getting kbd_clock_enabled of: %02x\n",
+  if (bio->getdbg().keyboard)
+    bio->printd("[KBD] get_kbd_enable(): getting kbd_clock_enabled of: %02x\n",
       (unsigned) BX_KEY_THIS s.kbd_controller.kbd_clock_enabled);
 #endif
 
@@@@ -781,16 +799,16 @@@@ bx_keyb_c::controller_enQ(Bit8u   data, 
 {
   // source is 0 for keyboard, 1 for mouse
 
-  if (bx_dbg.keyboard)
-    bx_printf("controller_enQ(%02x)\n", (unsigned) data);
+  if (bio->getdbg().keyboard)
+    bio->printd("[KBD] controller_enQ(%02x)\n", (unsigned) data);
 
   if (BX_KEY_THIS s.kbd_controller.outb)
-    bx_printf("KBD: controller_enQ(): OUTB set!\n");
+    bio->printd("[KBD] controller_enQ(): OUTB set!\n");
 
   // see if we need to Q this byte from the controller
   if (BX_KEY_THIS s.kbd_controller.outb) {
     if (BX_KEY_THIS s.controller_Qsize >= BX_KBD_CONTROLLER_QSIZE)
-      bx_panic("KBD: controller_enq(): controller_Q full!\n");
+      bio->printd("[KBD] controller_enq(): controller_Q full!\n");
     BX_KEY_THIS s.controller_Q[BX_KEY_THIS s.controller_Qsize++] = data;
     BX_KEY_THIS s.controller_Qsource = source;
     return;
@@@@ -820,7 +838,7 @@@@ bx_keyb_c::kbd_enQ_imm(Bit8u val)
       int tail;
 
       if (BX_KEY_THIS s.kbd_internal_buffer.num_elements >= BX_KBD_ELEMENTS) {
-	    bx_panic("KBD: internal keyboard buffer full (imm)\n");
+	    bio->printd("[KBD] internal keyboard buffer full (imm)\n");
 	    return;
       }
 
@@@@ -841,18 +859,18 @@@@ bx_keyb_c::kbd_enQ(Bit8u   scancode)
 {
   int tail;
 
-  if (bx_dbg.keyboard)
-    bx_printf("enQ(%02x)\n", (unsigned) scancode);
+  if (bio->getdbg().keyboard)
+    bio->printd("[KBD] enQ(%02x)\n", (unsigned) scancode);
 
   if (BX_KEY_THIS s.kbd_internal_buffer.num_elements >= BX_KBD_ELEMENTS) {
-    bx_printf("KBD: internal keyboard buffer full, ignoring scancode.(%02x)\n",
+    bio->printd("[KBD] internal keyboard buffer full, ignoring scancode.(%02x)\n",
       (unsigned) scancode);
     return;
     }
 
   /* enqueue scancode in multibyte internal keyboard buffer */
-  if (bx_dbg.keyboard)
-    bx_printf("KBD: enQ: putting scancode %02x in internal buffer\n",
+  if (bio->getdbg().keyboard)
+    bio->printd("[KBD] enQ: putting scancode %02x in internal buffer\n",
       (unsigned) scancode);
   tail = (BX_KEY_THIS s.kbd_internal_buffer.head + BX_KEY_THIS s.kbd_internal_buffer.num_elements) %
    BX_KBD_ELEMENTS;
@@@@ -861,14 +879,14 @@@@ bx_keyb_c::kbd_enQ(Bit8u   scancode)
 
   if (!BX_KEY_THIS s.kbd_controller.outb && BX_KEY_THIS s.kbd_controller.kbd_clock_enabled) {
     activate_timer();
-//fprintf(stderr, "# activating timer...\n");
+//bio->printd("#KBD] activating timer...\n");
     return;
     }
-//fprintf(stderr, "# not activating timer...\n");
-//fprintf(stderr, "#   allow_irq1 = %u\n", (unsigned) BX_KEY_THIS s.kbd_controller.allow_irq1);
-//fprintf(stderr, "#   outb       = %u\n", (unsigned) BX_KEY_THIS s.kbd_controller.outb);
-//fprintf(stderr, "#   clock_enab = %u\n", (unsigned) BX_KEY_THIS s.kbd_controller.kbd_clock_enabled);
-//fprintf(stderr, "#   out_buffer = %u\n", (unsigned) BX_KEY_THIS s.kbd_controller.kbd_output_buffer);
+//bio->printd("#KBD] not activating timer...\n");
+//bio->printd("#KBD]   allow_irq1 = %u\n", (unsigned) BX_KEY_THIS s.kbd_controller.allow_irq1);
+//bio->printd("#KBD]   outb       = %u\n", (unsigned) BX_KEY_THIS s.kbd_controller.outb);
+//bio->printd("#KBD]   clock_enab = %u\n", (unsigned) BX_KEY_THIS s.kbd_controller.kbd_clock_enabled);
+//bio->printd("#KBD]   out_buffer = %u\n", (unsigned) BX_KEY_THIS s.kbd_controller.kbd_output_buffer);
 }
 
   Boolean
@@@@ -878,7 +896,7 @@@@ bx_keyb_c::mouse_enQ_packet(Bit8u   b1, 
     return(0); /* buffer doesn't have the space */
     }
 
-//bx_printf("mouse: enQ_packet(%02x, %02x, %02x)\n",
+//bio->printd("[MOUSE] enQ_packet(%02x, %02x, %02x)\n",
 //  (unsigned) b1, (unsigned) b2, (unsigned) b3);
 
   mouse_enQ(b1);
@@@@ -893,15 +911,15 @@@@ bx_keyb_c::mouse_enQ(Bit8u   mouse_data)
 {
   int tail;
 
-  if (bx_dbg.mouse)
-    bx_printf("mouse_enQ(%02x)\n", (unsigned) mouse_data);
+  if (bio->getdbg().mouse)
+    bio->printd("[MOUSE] mouse_enQ(%02x)\n", (unsigned) mouse_data);
 
   if (BX_KEY_THIS s.mouse_internal_buffer.num_elements >= BX_MOUSE_BUFF_SIZE) {
-    bx_printf("mouse: internal mouse buffer full, ignoring mouse data.(%02x)\n",
+    bio->printd("[MOUSE] internal mouse buffer full, ignoring mouse data.(%02x)\n",
       (unsigned) mouse_data);
     return;
     }
-//fprintf(stderr, "# mouse_enq() aux_clock_enabled = %u\n",
+//bio->printd("#MOUSE] mouse_enq() aux_clock_enabled = %u\n",
 //  (unsigned) BX_KEY_THIS s.kbd_controller.aux_clock_enabled);
 
   /* enqueue mouse data in multibyte internal mouse buffer */
@@@@ -912,33 +930,33 @@@@ bx_keyb_c::mouse_enQ(Bit8u   mouse_data)
 
   if (!BX_KEY_THIS s.kbd_controller.outb && BX_KEY_THIS s.kbd_controller.aux_clock_enabled) {
     activate_timer();
-//fprintf(stderr, "# activating timer...\n");
+//bio->printd("#MOUSE] activating timer...\n");
     return;
     }
-//fprintf(stderr, "# not activating timer...\n");
-//fprintf(stderr, "#   allow_irq12= %u\n", (unsigned) BX_KEY_THIS s.kbd_controller.allow_irq12);
-//fprintf(stderr, "#   outb       = %u\n", (unsigned) BX_KEY_THIS s.kbd_controller.outb);
-//fprintf(stderr, "#   clock_enab = %u\n", (unsigned) BX_KEY_THIS s.kbd_controller.aux_clock_enabled);
-//fprintf(stderr, "#   out_buffer = %u\n", (unsigned) BX_KEY_THIS s.kbd_controller.aux_output_buffer);
+//bio->printd("#MOUSE] not activating timer...\n");
+//bio->printd("#MOUSE]   allow_irq12= %u\n", (unsigned) BX_KEY_THIS s.kbd_controller.allow_irq12);
+//bio->printd("#MOUSE]   outb       = %u\n", (unsigned) BX_KEY_THIS s.kbd_controller.outb);
+//bio->printd("#MOUSE]   clock_enab = %u\n", (unsigned) BX_KEY_THIS s.kbd_controller.aux_clock_enabled);
+//bio->printd("#MOUSE]   out_buffer = %u\n", (unsigned) BX_KEY_THIS s.kbd_controller.aux_output_buffer);
 }
 
   void
 bx_keyb_c::kbd_ctrl_to_kbd(Bit8u   value)
 {
-  if (bx_dbg.keyboard)
-	bx_printf("KBD: controller passed byte %02xh to keyboard\n");
+  if (bio->getdbg().keyboard)
+	bio->printd("[KBD] controller passed byte %02xh to keyboard\n");
 
   if (BX_KEY_THIS s.kbd_internal_buffer.expecting_typematic) {
     BX_KEY_THIS s.kbd_internal_buffer.expecting_typematic = 0;
     BX_KEY_THIS s.kbd_internal_buffer.delay = (value >> 5) & 0x03;
     switch (BX_KEY_THIS s.kbd_internal_buffer.delay) {
-      case 0: bx_printf("KBD: setting delay to 250 mS\n"); break;
-      case 1: bx_printf("KBD: setting delay to 250 mS\n"); break;
-      case 2: bx_printf("KBD: setting delay to 250 mS\n"); break;
-      case 3: bx_printf("KBD: setting delay to 250 mS\n"); break;
+      case 0: bio->printd("[KBD] setting delay to 250 mS\n"); break;
+      case 1: bio->printd("[KBD] setting delay to 250 mS\n"); break;
+      case 2: bio->printd("[KBD] setting delay to 250 mS\n"); break;
+      case 3: bio->printd("[KBD] setting delay to 250 mS\n"); break;
       }
     BX_KEY_THIS s.kbd_internal_buffer.repeat_rate = value & 0x1f;
-    bx_printf("KBD: setting repeat rate to %u\n", (unsigned) value);
+    bio->printd("[KBD] setting repeat rate to %u\n", (unsigned) value);
     kbd_enQ(0xFA); // send ACK
     return;
     }
@@@@ -946,7 +964,7 @@@@ bx_keyb_c::kbd_ctrl_to_kbd(Bit8u   value
   if (BX_KEY_THIS s.kbd_internal_buffer.expecting_led_write) {
     BX_KEY_THIS s.kbd_internal_buffer.expecting_led_write = 0;
     BX_KEY_THIS s.kbd_internal_buffer.led_status = value;
-    bx_printf("KBD: LED status set to %02x\n",
+    bio->printd("[KBD] LED status set to %02x\n",
       (unsigned) BX_KEY_THIS s.kbd_internal_buffer.led_status);
     kbd_enQ(0xFA); // send ACK %%%
     return;
@@@@ -977,14 +995,14 @@@@ bx_keyb_c::kbd_ctrl_to_kbd(Bit8u   value
       break;
 
     case 0xf2:  // identify keyboard
-      bx_printf("KBD: indentify keyboard command received\n");
+      bio->printd("[KBD] indentify keyboard command received\n");
       kbd_enQ(0xFA); // AT sends ACK, MFII sends ACK+ABh+41h
       return;
       break;
 
     case 0xf3:  // typematic info
       BX_KEY_THIS s.kbd_internal_buffer.expecting_typematic = 1;
-      bx_printf("KBD: setting typematic info\n");
+      bio->printd("[KBD] setting typematic info\n");
       kbd_enQ(0xFA); // send ACK
       return;
       break;
@@@@ -1000,7 +1018,7 @@@@ bx_keyb_c::kbd_ctrl_to_kbd(Bit8u   value
       resetinternals(1);
       kbd_enQ(0xFA); // send ACK
       BX_KEY_THIS s.kbd_internal_buffer.scanning_enabled = 0;
-      bx_printf ("KBD: reset-disable command received\n");
+      bio->printd ("[KBD] reset-disable command received\n");
       return;
       break;
 
@@@@ -1008,7 +1026,7 @@@@ bx_keyb_c::kbd_ctrl_to_kbd(Bit8u   value
       resetinternals(1);
       kbd_enQ(0xFA); // send ACK
       BX_KEY_THIS s.kbd_internal_buffer.scanning_enabled = 1;
-      bx_printf ("KBD: reset-enable command received\n");
+      bio->printd ("[KBD] reset-enable command received\n");
       return;
       break;
 
@@@@ -1026,12 +1044,12 @@@@ bx_keyb_c::kbd_ctrl_to_kbd(Bit8u   value
       break;
 
     case 0xfe:  // resend. aiiee.
-      bx_panic ("KBD: got 0xFE (resend)\n");
+      bio->printd("[KBD] got 0xFE (resend)\n");
       return;
       break;
 
     case 0xff:  // reset: internal keyboard reset and afterwards the BAT
-      bx_printf("KBD: rest command received\n");
+      bio->printd("[KBD] rest command received\n");
       kbd_enQ(0xFA); // send ACK
       kbd_enQ(0xAA); // BAT test passed
       return;
@@@@ -1042,7 +1060,7 @@@@ case 0xd3:
   return;
 
     default:
-      bx_panic("KBD: kbd_ctrl_to_kbd(): got value of %02x\n",
+      bio->printd("[KBD] kbd_ctrl_to_kbd(): got value of %02x\n",
         (unsigned) value);
       kbd_enQ(0xFA); /* send ACK ??? */
       return;
@@@@ -1085,14 +1103,14 @@@@ bx_keyb_c::periodic( Bit32u   usec_delta
 
   /* nothing in outb, look for possible data xfer from keyboard or mouse */
   if (BX_KEY_THIS s.kbd_controller.kbd_clock_enabled && BX_KEY_THIS s.kbd_internal_buffer.num_elements) {
-//fprintf(stderr, "#   servicing keyboard code\n");
-    if (bx_dbg.keyboard)
-      bx_printf("KBD: service_keyboard: key in internal buffer waiting\n");
+//bio->printd("#KBD]   servicing keyboard code\n");
+    if (bio->getdbg().keyboard)
+      bio->printd("[KBD] service_keyboard: key in internal buffer waiting\n");
     BX_KEY_THIS s.kbd_controller.kbd_output_buffer =
       BX_KEY_THIS s.kbd_internal_buffer.buffer[BX_KEY_THIS s.kbd_internal_buffer.head];
     BX_KEY_THIS s.kbd_controller.outb = 1;
     BX_KEY_THIS s.kbd_controller.auxb = 0;
-//fprintf(stderr, "# ___kbd::periodic kbd\n");
+//bio->printd("#KBD] ___kbd::periodic kbd\n");
     BX_KEY_THIS s.kbd_internal_buffer.head = (BX_KEY_THIS s.kbd_internal_buffer.head + 1) %
       BX_KBD_ELEMENTS;
     BX_KEY_THIS s.kbd_internal_buffer.num_elements--;
@@@@ -1100,26 +1118,26 @@@@ bx_keyb_c::periodic( Bit32u   usec_delta
       BX_KEY_THIS s.kbd_controller.irq1_requested = 1;
     }
   else if (BX_KEY_THIS s.kbd_controller.aux_clock_enabled && BX_KEY_THIS s.mouse_internal_buffer.num_elements) {
-//fprintf(stderr, "#   servicing mouse code\n");
-    if (bx_dbg.mouse)
-      bx_printf("KBD: service_keyboard: key in internal buffer waiting\n");
+//bio->printd("#MOUSE]   servicing mouse code\n");
+    if (bio->getdbg().mouse)
+      bio->printd("[KBD] service_keyboard: key in internal buffer waiting\n");
     BX_KEY_THIS s.kbd_controller.aux_output_buffer =
       BX_KEY_THIS s.mouse_internal_buffer.buffer[BX_KEY_THIS s.mouse_internal_buffer.head];
 
     BX_KEY_THIS s.kbd_controller.outb = 1;
     BX_KEY_THIS s.kbd_controller.auxb = 1;
-//fprintf(stderr, "# ___kbd:periodic aux\n");
+//bio->printd("#KBD] ___kbd:periodic aux\n");
     BX_KEY_THIS s.mouse_internal_buffer.head = (BX_KEY_THIS s.mouse_internal_buffer.head + 1) %
       BX_MOUSE_BUFF_SIZE;
     BX_KEY_THIS s.mouse_internal_buffer.num_elements--;
-//fprintf(stderr, "#   allow12 = %u\n", (unsigned) BX_KEY_THIS s.kbd_controller.allow_irq12);
+//bio->printd("#KBD]   allow12 = %u\n", (unsigned) BX_KEY_THIS s.kbd_controller.allow_irq12);
     if (BX_KEY_THIS s.kbd_controller.allow_irq12)
       BX_KEY_THIS s.kbd_controller.irq12_requested = 1;
     }
   else {
-//fprintf(stderr, "#   servicing no code\n");
-    if (bx_dbg.keyboard) {
-      bx_printf("KBD: service_keyboard(): no keys waiting\n");
+//bio->printd("#KBD]   servicing no code\n");
+    if (bio->getdbg().keyboard) {
+      bio->printd("[KBD] service_keyboard(): no keys waiting\n");
       }
     }
   return(retval);
@@@@ -1141,13 +1159,13 @@@@ bx_keyb_c::activate_timer(void)
   void
 bx_keyb_c::kbd_ctrl_to_mouse(Bit8u   value)
 {
-bx_printf("MOUSE: kbd_ctrl_to_mouse(%02xh)\n", (unsigned) value);
-bx_printf("  enable = %u\n", (unsigned) BX_KEY_THIS s.mouse.enable);
-bx_printf("  allow_irq12 = %u\n",
+bio->printd("[MOUSE] kbd_ctrl_to_mouse(%02xh)\n", (unsigned) value);
+bio->printd("[MOUSE]  enable = %u", (unsigned) BX_KEY_THIS s.mouse.enable);
+bio->printd("[MOUSE]  allow_irq12 = %u\n",
   (unsigned) BX_KEY_THIS s.kbd_controller.allow_irq12);
-bx_printf("  aux_clock_enabled = %u\n",
+bio->printd("[MOUSE]  aux_clock_enabled = %u\n",
   (unsigned) BX_KEY_THIS s.kbd_controller.aux_clock_enabled);
-//fprintf(stderr, "# MOUSE: kbd_ctrl_to_mouse(%02xh)\n", (unsigned) value);
+//bio->printd("#MOUSE] kbd_ctrl_to_mouse(%02xh)\n", (unsigned) value);
 
   // an ACK (0xFA) is always the first response to any valid input
   // received from the system other than Set-Wrap-Mode & Resend-Command
@@@@ -1158,8 +1176,8 @@@@ bx_printf("  aux_clock_enabled = %u\n",
        switch (BX_KEY_THIS s.kbd_controller.last_mouse_command) {
 	     case 0xf3: // Set Mouse Sample Rate
 		   BX_KEY_THIS s.mouse.sample_rate = value;
-		   if (bx_dbg.mouse)
-			 bx_printf("[mouse] Sampling rate set: %d Hz\n", value);
+		   if (bio->getdbg().mouse)
+			 bio->printd("[mouse] Sampling rate set: %d Hz\n", value);
 		   controller_enQ(0xFA, 1); // ack
 		   break;
 
@@@@ -1178,18 +1196,19 @@@@ bx_printf("  aux_clock_enabled = %u\n",
 			       BX_KEY_THIS s.mouse.resolution_cpmm = 8;
 			       break;
 			 default:
-			       bx_panic("[mouse] Unknown resolution %d\n", value);
+			       bio->printd("[mouse] Unknown resolution %d\n", value);
 			       break;
 		   }
-		   if (bx_dbg.mouse)
-			 bx_printf("[mouse] Resolution set to %d counts per mm\n",
+		   if (bio->getdbg().mouse)
+			 bio->printd("[mouse] Resolution set to %d counts per mm\n",
 				   BX_KEY_THIS s.mouse.resolution_cpmm);
 
 		   controller_enQ(0xFA, 1); // ack
 		   break;
 
 	     default:
-		   bx_panic("MOUSE: unknown last command (%02xh)\n", (unsigned) BX_KEY_THIS s.kbd_controller.last_mouse_command);
+		   bio->printd("[MOUSE] unknown last command (%02xh)\n", (unsigned) BX_KEY_THIS s.kbd_controller.last_mouse_command);
+		   break;
        }
  } else {
   BX_KEY_THIS s.kbd_controller.expecting_mouse_parameter = 0;
@@@@ -1198,15 +1217,15 @@@@ bx_printf("  aux_clock_enabled = %u\n",
     case 0xe6: // Set Mouse Scaling to 1:1
       controller_enQ(0xFA, 1); // ACK
       BX_KEY_THIS s.mouse.scaling         = 2;
-      if (bx_dbg.mouse)
-	    bx_printf("[mouse] Scaling set to 1:1\n");
+      if (bio->getdbg().mouse)
+	    bio->printd("[mouse] Scaling set to 1:1\n");
       break;
 
     case 0xe7: // Set Mouse Scaling to 2:1
       controller_enQ(0xFA, 1); // ACK
       BX_KEY_THIS s.mouse.scaling         = 2;
-      if (bx_dbg.mouse)
-	    bx_printf("[mouse] Scaling set to 2:1\n");
+      if (bio->getdbg().mouse)
+	    bio->printd("[mouse] Scaling set to 2:1\n");
       break;
 
     case 0xe8: // Set Mouse Resolution
@@@@ -1217,8 +1236,8 @@@@ bx_printf("  aux_clock_enabled = %u\n",
     case 0xf2: // Read Device Type
       controller_enQ(0xFA, 1); // ACK
       controller_enQ(0x00, 1); // Device ID
-      if (bx_dbg.mouse)
-	    bx_printf("[mouse] Read mouse ID\n");
+      if (bio->getdbg().mouse)
+	    bio->printd("[mouse] Read mouse ID\n");
       break;
 
     case 0xf3: // Set Mouse Sample Rate (sample rate written to port 60h)
@@@@ -1229,15 +1248,15 @@@@ bx_printf("  aux_clock_enabled = %u\n",
     case 0xf4: // Enable (in stream mode)
       BX_KEY_THIS s.mouse.enable = 1;
       controller_enQ(0xFA, 1); // ACK
-      if (bx_dbg.mouse)
-	    bx_printf("[mouse] Mouse enabled (stream mode)\n");
+      if (bio->getdbg().mouse)
+	    bio->printd("[mouse] Mouse enabled (stream mode)\n");
       break;
 
     case 0xf5: // Disable (in stream mode)
       BX_KEY_THIS s.mouse.enable = 0;
       controller_enQ(0xFA, 1); // ACK
-      if (bx_dbg.mouse)
-	    bx_printf("[mouse] Mouse disabled (stream mode)\n");
+      if (bio->getdbg().mouse)
+	    bio->printd("[mouse] Mouse disabled (stream mode)\n");
       break;
 
     case 0xff: // Reset
@@@@ -1250,8 +1269,8 @@@@ bx_printf("  aux_clock_enabled = %u\n",
       controller_enQ(0xFA, 1); // ACK
       controller_enQ(0xAA, 1); // completion code
       controller_enQ(0x00, 1); // ID code (normal mouse, wheelmouse has id 0x3)
-      if (bx_dbg.mouse)
-	    bx_printf("[mouse] Mouse reset\n");
+      if (bio->getdbg().mouse)
+	    bio->printd("[mouse] Mouse reset\n");
       break;
 
     case 0xe9: // Get mouse information
@@@@ -1260,12 +1279,12 @@@@ bx_printf("  aux_clock_enabled = %u\n",
       controller_enQ(BX_KEY_THIS s.mouse.get_status_byte(), 1); // status
       controller_enQ(BX_KEY_THIS s.mouse.get_resolution_byte(), 1); // resolution
       controller_enQ(BX_KEY_THIS s.mouse.sample_rate, 1); // sample rate
-      if (bx_dbg.mouse)
-	    bx_printf("[mouse] Get mouse information\n");
+      if (bio->getdbg().mouse)
+	    bio->printd("[mouse] Get mouse information\n");
       break;
 
     default:
-      bx_panic("MOUSE: kbd_ctrl_to_mouse(%02xh)\n", (unsigned) value);
+      bio->printd("[MOUSE] kbd_ctrl_to_mouse(%02xh)\n", (unsigned) value);
     }
  }
 }
@@@@ -1289,7 +1308,7 @@@@ bx_keyb_c::mouse_motion(int delta_x, int
   if ( (delta_y < -1) || (delta_y > 1) )
     delta_y /= 2;
 
-  //fprintf(stderr, "# MOUSE: Dx=%d Dy=%d\n",
+  //bio->printd("#MOUSE] Dx=%d Dy=%d\n",
   //  delta_x, delta_y);
 
   b1 = (button_state & 0x0f) | 0x08; // bit3 always set
@


1.2
log
@implement printd to silence printing of user unfriendly info (aka only
for developers); much less output now.
@
text
@d1 1
a1 1
$OpenBSD: patch-iodev_keyboard_cc,v 1.1 2001/02/02 16:59:11 todd Exp $
@


1.1
log
@o take over maintainership
o too many changes to mention specifically, but amongst them:
	- better error reporting
	- openbsd boots, freebsd boots
	- new 'term' flavor, I added a textmode interface, the only drawback
	  is that control-c is intercepted, and you must kill -9 it from
	  another tty if it doesn't exit normally
	- new flavors:
		- debugger -> debug (for shortness)
		- i386
		- pci
		- smp
		- net (compiles, does not yet provide networking, if anyone
			wants to help, I'd be ELATED to have this fixed!)
		- no_x11 (made it actually work)
		- term (make sure to use 'log: /dev/null' or something else
		  on the cmdline, otherwise, debugging and the screen will
		  start getting quite confusing!)
	- better error reporting (and no error reporting where it is not
	  necessary; a typicall boot of cdrom28.fs is a screenful of output now)
	- in general, if the hardware reaches an unknown state, fail
	  gracefully instead of calling exit(1) .. are we trying to work or
	  are we trying to .. fail?  I like working myself.
@
text
@d1 1
a1 1
$OpenBSD: update-patches,v 1.3 2000/06/09 17:08:37 espie Exp $
d3 1
a3 1
+++ iodev/keyboard.cc	Tue Oct 31 12:27:44 2000
d9 1
a9 1
+//bio->printf("#KBD] keyboard_serial_delay is %u usec\n",
d20 1
a20 1
+    bio->printf("[KBD] io read to address %08x, len=%u\n",
d27 1
a27 1
+//bio->printf("#KBD] read from port 0x%04x\n", (unsigned) address);
d36 1
a36 1
+//bio->printf("[MOUSE] ___io_read aux = 0x%02x\n", (unsigned) val);
d42 1
a42 1
+        bio->printf("[KBD] READ(%02x) = %02x\n", (unsigned) address,
d51 1
a51 1
+//bio->printf("#MOUSE] ___io_read kbd\n");
d62 1
a62 1
+        bio->printf("[KBD] READ(%02x) = %02x\n", (unsigned) address,
d71 2
a72 2
+        bio->printf("[KBD] num_elements = %d\n", BX_KEY_THIS s.kbd_internal_buffer.num_elements);
+        bio->printf("[KBD] read from port 60h with outb empty\n");
d83 1
a83 1
+      bio->printf("[KBD] IO read from port 64h, system 8255 mode register\n");
d90 1
a90 1
+    bio->printf("[KBD] unknown address in io read to keyboard port %x\n",
d99 1
a99 1
+	bio->printf("[KBD] 8-bit read from %04x = %02x\n", (unsigned)address, ret);
d110 1
a110 1
+    bio->printf("[KBD] io write to address %08x, len=%u\n",
d118 1
a118 1
+	bio->printf("[KBD] 8-bit write to %04x = %02x\n", (unsigned)address, (unsigned)value);
d122 1
a122 1
+//bio->printf("[KBD] WRITE(%02x) = %02x\n", (unsigned) address,
d131 1
a131 1
+          bio->printf("[KBD] write to port 60h, not ready for write\n");
d141 1
a141 1
+//bio->printf("#KBD] allow_irq12 set to %u\n", (unsigned)
d145 1
a145 1
+              bio->printf("[KBD] (mch) scan convert turned off\n");
d155 1
a155 1
+              bio->printf("[KBD] write output port with value %02xh\n",
d160 1
a160 1
+		bio->printf("[KBD] IO write: processor reset requested!\n");
d169 1
a169 1
+            bio->printf("[KBD] === unsupported write to port 60h(lastcomm=%02x): %02x\n",
d178 1
a178 1
+          bio->printf("[KBD] keyboard disabled & send of byte %02x to kbd\n",
d182 1
a182 1
@@@@ -402,11 +408,11 @@@@ bx_keyb_c::write( Bit32u   address, Bit3
d189 1
a189 1
+            bio->printf("[KBD] get keyboard command byte\n");
d193 2
a194 1
+bio->printf("[KBD] OUTB set and command 0x%02x encountered\n", value);
d198 1
a198 1
@@@@ -420,37 +426,37 @@@@ bx_panic("kbd: OUTB set and command 0x%0
d205 1
a205 1
+            bio->printf("[KBD] write command byte\n");
d212 1
a212 1
+          bio->printf ("[KBD] Dummy out Green PC for now : 0xa1\n");
d218 1
a218 1
+          if (bio->getdbg().keyboard) bio->printf("[KBD] aux device disabled\n");
d223 1
a223 1
+          if (bio->getdbg().keyboard) bio->printf("[KBD] aux device enabled\n");
d229 2
a230 1
+bio->printf("[KBD] OUTB set and command 0x%02x encountered\n", value);
d237 1
a237 1
+          if (bio->getdbg().keyboard) bio->printf("[KBD] Self Test\n");
d241 2
a242 1
+bio->printf("[KBD] OUTB set and command 0x%02x encountered\n", value);
d246 1
a246 1
@@@@ -460,34 +466,34 @@@@ bx_panic("kbd: OUTB set and command 0x%0
d251 1
a251 1
+bio->printf("[KBD] OUTB set and command 0x%02x encountered\n", value);
d259 1
a259 1
+          if (bio->getdbg().keyboard) bio->printf("[KBD] keyboard disabled\n");
d264 1
a264 1
+          if (bio->getdbg().keyboard) bio->printf("[KBD] keyboard enabled\n");
d270 2
a271 1
+bio->printf("[KBD] OUTB set and command 0x%02x encountered\n", value);
d281 1
a281 1
+            bio->printf("[KBD] io write to port 64h, command d0h (partial)\n");
d285 1
a285 1
+bio->printf("[KBD] OUTB set and command 0x%02x encountered\n", value);
d289 1
a289 1
@@@@ -498,20 +504,20 @@@@ bx_panic("kbd: OUTB set and command 0x%0
d296 1
a296 1
+            bio->printf("[KBD] write output port\n");
d303 1
a303 1
+          bio->printf("[KBD] io write 0x64: command = 0xD3(write mouse outb)\n");
d311 1
a311 1
+            bio->printf("[KBD] io write 0x64: command = 0xD4 (write to mouse)\n");
d315 1
a315 1
@@@@ -522,32 +528,34 @@@@ bx_panic("kbd: OUTB set and command 0x%0
d320 1
a320 1
+          bio->printf("[KBD] io write 0x64: command = %02xh\n", (unsigned) value);
d328 1
a328 1
+            bio->printf("[KBD] system reset via ctrl command FEh\n");
d342 1
a342 1
+              bio->printf("[KBD] io write to port 64h, useless command %02x\n",
d347 1
a347 1
+          bio->printf("[KBD] unsupported io write to keyboard port %x, value = %x\n",
d355 1
a355 1
+	bio->printf("[KBD] unknown address in bx_keyb_c::write()\n");
d359 1
a359 1
@@@@ -557,15 +565,17 @@@@ bx_keyb_c::gen_scancode(Bit32u   key)
d366 1
a366 1
+	fprintf((FILE*)bio->getdbg().record_io, "gen_scancode %lld %x\n", bx_pc_system.time_ticks(), key);
d372 1
a372 1
+	bio->printf("[KBD] gen_scancode with scan_convert cleared\n");
d379 1
a379 1
+    bio->printf("[KBD] gen_scancode(): scancode: %08x\n", (unsigned) key);
d383 1
a383 1
@@@@ -640,20 +650,21 @@@@ bx_keyb_c::gen_scancode(Bit32u   key)
d393 1
a393 1
+      //bio->printf("#KBD] Grey left-arrow key not on 83-key keyboard\n");
d397 1
a397 1
+      //bio->printf("#KBD] Grey right-arrow key not on 83-key keyboard\n");
d401 1
a401 1
+      //bio->printf("#KBD] Grey up-arrow key not on 83-key keyboard\n");
d405 1
a405 1
+      //bio->printf("#KBD] Grey down-arrow key not on 83-key keyboard\n");
d409 1
a409 1
@@@@ -661,43 +672,46 @@@@ bx_keyb_c::gen_scancode(Bit32u   key)
d432 1
a432 1
+      //bio->printf("#KBD] Grey insert key not on 83-key keyboard\n");
d435 1
a435 1
+      //bio->printf("#KBD] Grey delete key not on 83-key keyboard\n");
d438 1
a438 1
+      //bio->printf("#KBD] Grey home key not on 83-key keyboard\n");
d441 1
a441 1
+      //bio->printf("#KBD] Grey end key not on 83-key keyboard\n");
d444 1
a444 1
+      //bio->printf("#KBD] Grey page-up key not on 83-key keyboard\n");
d447 1
a447 1
+      //bio->printf("#KBD] Grey page-down key not on 83-key keyboard\n");
d471 1
a471 1
+      bio->printf("#KBD] Grey Multiply key not on 83-key keyboard\n");
d475 1
a475 1
+      bio->printf("#KBD] Grey Divide key not on 83-key keyboard\n");
d479 1
a479 1
@@@@ -713,7 +727,7 @@@@ bx_keyb_c::gen_scancode(Bit32u   key)
d484 1
a484 1
+      bio->printf("#KBD] bx_keyb_c::gen_scancode : Unhandled %u\n",
d488 1
a488 1
@@@@ -750,8 +764,8 @@@@ bx_keyb_c::set_aux_clock_enable(Bit8u   
d495 1
a495 1
+	bio->printf("[KBD] set_aux_clock_enable(%u)\n", (unsigned) value);
d499 1
a499 1
@@@@ -768,8 +782,8 @@@@ bx_keyb_c::set_aux_clock_enable(Bit8u   
d506 1
a506 1
+    bio->printf("[KBD] get_kbd_enable(): getting kbd_clock_enabled of: %02x\n",
d510 1
a510 1
@@@@ -781,16 +795,16 @@@@ bx_keyb_c::controller_enQ(Bit8u   data, 
d517 1
a517 1
+    bio->printf("[KBD] controller_enQ(%02x)\n", (unsigned) data);
d521 1
a521 1
+    bio->printf("[KBD] controller_enQ(): OUTB set!\n");
d527 1
a527 1
+      bio->printf("[KBD] controller_enq(): controller_Q full!\n");
d531 1
a531 1
@@@@ -820,7 +834,7 @@@@ bx_keyb_c::kbd_enQ_imm(Bit8u val)
d536 1
a536 1
+	    bio->printf("[KBD] internal keyboard buffer full (imm)\n");
d540 1
a540 1
@@@@ -841,18 +855,18 @@@@ bx_keyb_c::kbd_enQ(Bit8u   scancode)
d547 1
a547 1
+    bio->printf("[KBD] enQ(%02x)\n", (unsigned) scancode);
d551 1
a551 1
+    bio->printf("[KBD] internal keyboard buffer full, ignoring scancode.(%02x)\n",
d560 1
a560 1
+    bio->printf("[KBD] enQ: putting scancode %02x in internal buffer\n",
d564 1
a564 1
@@@@ -861,14 +875,14 @@@@ bx_keyb_c::kbd_enQ(Bit8u   scancode)
d569 1
a569 1
+//bio->printf("#KBD] activating timer...\n");
d577 5
a581 5
+//bio->printf("#KBD] not activating timer...\n");
+//bio->printf("#KBD]   allow_irq1 = %u\n", (unsigned) BX_KEY_THIS s.kbd_controller.allow_irq1);
+//bio->printf("#KBD]   outb       = %u\n", (unsigned) BX_KEY_THIS s.kbd_controller.outb);
+//bio->printf("#KBD]   clock_enab = %u\n", (unsigned) BX_KEY_THIS s.kbd_controller.kbd_clock_enabled);
+//bio->printf("#KBD]   out_buffer = %u\n", (unsigned) BX_KEY_THIS s.kbd_controller.kbd_output_buffer);
d585 1
a585 1
@@@@ -878,7 +892,7 @@@@ bx_keyb_c::mouse_enQ_packet(Bit8u   b1, 
d590 1
a590 1
+//bio->printf("[MOUSE] enQ_packet(%02x, %02x, %02x)\n",
d594 1
a594 1
@@@@ -893,15 +907,15 @@@@ bx_keyb_c::mouse_enQ(Bit8u   mouse_data)
d601 1
a601 1
+    bio->printf("[MOUSE] mouse_enQ(%02x)\n", (unsigned) mouse_data);
d605 1
a605 1
+    bio->printf("[MOUSE] internal mouse buffer full, ignoring mouse data.(%02x)\n",
d610 1
a610 1
+//bio->printf("#MOUSE] mouse_enq() aux_clock_enabled = %u\n",
d614 1
a614 1
@@@@ -912,33 +926,33 @@@@ bx_keyb_c::mouse_enQ(Bit8u   mouse_data)
d619 1
a619 1
+//bio->printf("#MOUSE] activating timer...\n");
d627 5
a631 5
+//bio->printf("#MOUSE] not activating timer...\n");
+//bio->printf("#MOUSE]   allow_irq12= %u\n", (unsigned) BX_KEY_THIS s.kbd_controller.allow_irq12);
+//bio->printf("#MOUSE]   outb       = %u\n", (unsigned) BX_KEY_THIS s.kbd_controller.outb);
+//bio->printf("#MOUSE]   clock_enab = %u\n", (unsigned) BX_KEY_THIS s.kbd_controller.aux_clock_enabled);
+//bio->printf("#MOUSE]   out_buffer = %u\n", (unsigned) BX_KEY_THIS s.kbd_controller.aux_output_buffer);
d640 1
a640 1
+	bio->printf("[KBD] controller passed byte %02xh to keyboard\n");
d650 4
a653 4
+      case 0: bio->printf("[KBD] setting delay to 250 mS\n"); break;
+      case 1: bio->printf("[KBD] setting delay to 250 mS\n"); break;
+      case 2: bio->printf("[KBD] setting delay to 250 mS\n"); break;
+      case 3: bio->printf("[KBD] setting delay to 250 mS\n"); break;
d657 1
a657 1
+    bio->printf("[KBD] setting repeat rate to %u\n", (unsigned) value);
d661 1
a661 1
@@@@ -946,7 +960,7 @@@@ bx_keyb_c::kbd_ctrl_to_kbd(Bit8u   value
d666 1
a666 1
+    bio->printf("[KBD] LED status set to %02x\n",
d670 1
a670 1
@@@@ -977,14 +991,14 @@@@ bx_keyb_c::kbd_ctrl_to_kbd(Bit8u   value
d675 1
a675 1
+      bio->printf("[KBD] indentify keyboard command received\n");
d683 1
a683 1
+      bio->printf("[KBD] setting typematic info\n");
d687 1
a687 1
@@@@ -1000,7 +1014,7 @@@@ bx_keyb_c::kbd_ctrl_to_kbd(Bit8u   value
d692 1
a692 1
+      bio->printf ("[KBD] reset-disable command received\n");
d696 1
a696 1
@@@@ -1008,7 +1022,7 @@@@ bx_keyb_c::kbd_ctrl_to_kbd(Bit8u   value
d701 1
a701 1
+      bio->printf ("[KBD] reset-enable command received\n");
d705 1
a705 1
@@@@ -1026,12 +1040,12 @@@@ bx_keyb_c::kbd_ctrl_to_kbd(Bit8u   value
d710 1
a710 1
+      bio->printf("[KBD] got 0xFE (resend)\n");
d716 1
a716 1
+      bio->printf("[KBD] rest command received\n");
d720 1
a720 1
@@@@ -1042,7 +1056,7 @@@@ case 0xd3:
d725 1
a725 1
+      bio->printf("[KBD] kbd_ctrl_to_kbd(): got value of %02x\n",
d729 1
a729 1
@@@@ -1085,14 +1099,14 @@@@ bx_keyb_c::periodic( Bit32u   usec_delta
d736 1
a736 1
+//bio->printf("#KBD]   servicing keyboard code\n");
d738 1
a738 1
+      bio->printf("[KBD] service_keyboard: key in internal buffer waiting\n");
d744 1
a744 1
+//bio->printf("#KBD] ___kbd::periodic kbd\n");
d748 1
a748 1
@@@@ -1100,26 +1114,26 @@@@ bx_keyb_c::periodic( Bit32u   usec_delta
d755 1
a755 1
+//bio->printf("#MOUSE]   servicing mouse code\n");
d757 1
a757 1
+      bio->printf("[KBD] service_keyboard: key in internal buffer waiting\n");
d764 1
a764 1
+//bio->printf("#KBD] ___kbd:periodic aux\n");
d769 1
a769 1
+//bio->printf("#KBD]   allow12 = %u\n", (unsigned) BX_KEY_THIS s.kbd_controller.allow_irq12);
d777 1
a777 1
+//bio->printf("#KBD]   servicing no code\n");
d779 1
a779 1
+      bio->printf("[KBD] service_keyboard(): no keys waiting\n");
d783 1
a783 1
@@@@ -1141,13 +1155,13 @@@@ bx_keyb_c::activate_timer(void)
d790 3
a792 3
+bio->printf("[MOUSE] kbd_ctrl_to_mouse(%02xh)\n", (unsigned) value);
+bio->printf("[MOUSE]  enable = %u", (unsigned) BX_KEY_THIS s.mouse.enable);
+bio->printf("[MOUSE]  allow_irq12 = %u\n",
d795 1
a795 1
+bio->printf("[MOUSE]  aux_clock_enabled = %u\n",
d798 1
a798 1
+//bio->printf("#MOUSE] kbd_ctrl_to_mouse(%02xh)\n", (unsigned) value);
d802 1
a802 1
@@@@ -1158,8 +1172,8 @@@@ bx_printf("  aux_clock_enabled = %u\n",
d809 1
a809 1
+			 bio->printf("[mouse] Sampling rate set: %d Hz\n", value);
d813 1
a813 1
@@@@ -1178,18 +1192,19 @@@@ bx_printf("  aux_clock_enabled = %u\n",
d818 1
a818 1
+			       bio->printf("[mouse] Unknown resolution %d\n", value);
d824 1
a824 1
+			 bio->printf("[mouse] Resolution set to %d counts per mm\n",
d832 1
a832 1
+		   bio->printf("[MOUSE] unknown last command (%02xh)\n", (unsigned) BX_KEY_THIS s.kbd_controller.last_mouse_command);
d837 1
a837 1
@@@@ -1198,15 +1213,15 @@@@ bx_printf("  aux_clock_enabled = %u\n",
d844 1
a844 1
+	    bio->printf("[mouse] Scaling set to 1:1\n");
d853 1
a853 1
+	    bio->printf("[mouse] Scaling set to 2:1\n");
d857 1
a857 1
@@@@ -1217,8 +1232,8 @@@@ bx_printf("  aux_clock_enabled = %u\n",
d864 1
a864 1
+	    bio->printf("[mouse] Read mouse ID\n");
d868 1
a868 1
@@@@ -1229,15 +1244,15 @@@@ bx_printf("  aux_clock_enabled = %u\n",
d875 1
a875 1
+	    bio->printf("[mouse] Mouse enabled (stream mode)\n");
d884 1
a884 1
+	    bio->printf("[mouse] Mouse disabled (stream mode)\n");
d888 1
a888 1
@@@@ -1250,8 +1265,8 @@@@ bx_printf("  aux_clock_enabled = %u\n",
d895 1
a895 1
+	    bio->printf("[mouse] Mouse reset\n");
d899 1
a899 1
@@@@ -1260,12 +1275,12 @@@@ bx_printf("  aux_clock_enabled = %u\n",
d906 1
a906 1
+	    bio->printf("[mouse] Get mouse information\n");
d911 1
a911 1
+      bio->printf("[MOUSE] kbd_ctrl_to_mouse(%02xh)\n", (unsigned) value);
d915 1
a915 1
@@@@ -1289,7 +1304,7 @@@@ bx_keyb_c::mouse_motion(int delta_x, int
d920 1
a920 1
+  //bio->printf("#MOUSE] Dx=%d Dy=%d\n",
@

