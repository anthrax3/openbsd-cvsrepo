head	1.25;
access;
symbols
	OPENBSD_5_9:1.24.0.2
	OPENBSD_5_9_BASE:1.24
	OPENBSD_4_8:1.22.0.2
	OPENBSD_4_8_BASE:1.22
	OPENBSD_4_7:1.20.0.6
	OPENBSD_4_7_BASE:1.20
	OPENBSD_4_6:1.20.0.4
	OPENBSD_4_6_BASE:1.20
	OPENBSD_4_5:1.20.0.2
	OPENBSD_4_5_BASE:1.20
	OPENBSD_4_4:1.18.0.2
	OPENBSD_4_4_BASE:1.18
	OPENBSD_4_3:1.14.0.4
	OPENBSD_4_3_BASE:1.14
	OPENBSD_4_2:1.14.0.2
	OPENBSD_4_2_BASE:1.14
	OPENBSD_4_1:1.13.0.2
	OPENBSD_4_1_BASE:1.13
	OPENBSD_4_0:1.9.0.2
	OPENBSD_4_0_BASE:1.9
	OPENBSD_3_9:1.7.0.2
	OPENBSD_3_9_BASE:1.7
	OPENBSD_3_8:1.2.0.2
	OPENBSD_3_8_BASE:1.2
	OPENBSD_3_7:1.1.1.1.0.2
	OPENBSD_3_7_BASE:1.1.1.1
	todd_20050307:1.1.1.1
	todd:1.1.1;
locks; strict;
comment	@# @;


1.25
date	2016.03.14.19.46.12;	author ajacoutot;	state dead;
branches;
next	1.24;
commitid	ZypCecrzOxeE8g1E;

1.24
date	2015.11.03.16.25.24;	author sthen;	state Exp;
branches;
next	1.23;
commitid	XsrNATn66OYkkEpO;

1.23
date	2010.11.22.11.32.01;	author fgsch;	state dead;
branches;
next	1.22;

1.22
date	2010.05.28.00.02.52;	author fgsch;	state Exp;
branches;
next	1.21;

1.21
date	2010.05.27.17.55.05;	author fgsch;	state dead;
branches;
next	1.20;

1.20
date	2008.12.10.23.30.33;	author todd;	state Exp;
branches;
next	1.19;

1.19
date	2008.09.22.15.17.54;	author mpf;	state Exp;
branches;
next	1.18;

1.18
date	2008.06.19.05.51.17;	author todd;	state Exp;
branches;
next	1.17;

1.17
date	2008.04.28.22.52.38;	author todd;	state Exp;
branches;
next	1.16;

1.16
date	2008.03.31.20.16.52;	author todd;	state Exp;
branches;
next	1.15;

1.15
date	2008.03.31.14.26.00;	author todd;	state Exp;
branches;
next	1.14;

1.14
date	2007.05.01.12.55.14;	author todd;	state Exp;
branches;
next	1.13;

1.13
date	2007.02.19.12.43.38;	author robert;	state Exp;
branches;
next	1.12;

1.12
date	2007.01.17.20.35.09;	author mpf;	state Exp;
branches;
next	1.11;

1.11
date	2007.01.10.20.20.06;	author mpf;	state Exp;
branches;
next	1.10;

1.10
date	2006.12.22.17.31.45;	author todd;	state Exp;
branches;
next	1.9;

1.9
date	2006.06.08.14.33.38;	author todd;	state Exp;
branches;
next	1.8;

1.8
date	2006.04.10.21.10.05;	author todd;	state Exp;
branches;
next	1.7;

1.7
date	2006.02.16.16.27.44;	author todd;	state Exp;
branches;
next	1.6;

1.6
date	2006.02.08.13.44.17;	author todd;	state Exp;
branches;
next	1.5;

1.5
date	2005.12.27.07.56.15;	author todd;	state Exp;
branches;
next	1.4;

1.4
date	2005.11.05.12.11.05;	author todd;	state Exp;
branches;
next	1.3;

1.3
date	2005.10.25.03.25.44;	author todd;	state Exp;
branches;
next	1.2;

1.2
date	2005.08.11.01.15.17;	author todd;	state Exp;
branches;
next	1.1;

1.1
date	2005.03.07.16.41.28;	author todd;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2005.03.07.16.41.28;	author todd;	state Exp;
branches;
next	;


desc
@@


1.25
log
@Major update to qemu-2.5.0.
Please direct any runtime fallout to Brad.

from Brad (maintainer)
@
text
@$OpenBSD: patch-vl_c,v 1.24 2015/11/03 16:25:24 sthen Exp $

trace: remove malloc tracing

The malloc vtable is not supported anymore in glib, because it broke
when constructors called g_malloc.  Remove tracing of g_malloc,
g_realloc and g_free calls.

Note that, for systemtap users, glib also provides tracepoints
glib.mem_alloc, glib.mem_free, glib.mem_realloc, glib.slice_alloc
and glib.slice_free.

--- vl.c.orig	Sun Oct 25 21:38:01 2015
+++ vl.c	Sun Oct 25 21:38:28 2015
@@@@ -2628,26 +2628,6 @@@@ static const QEMUOption *lookup_opt(int argc, char **a
     return popt;
 }
 
-static gpointer malloc_and_trace(gsize n_bytes)
-{
-    void *ptr = malloc(n_bytes);
-    trace_g_malloc(n_bytes, ptr);
-    return ptr;
-}
-
-static gpointer realloc_and_trace(gpointer mem, gsize n_bytes)
-{
-    void *ptr = realloc(mem, n_bytes);
-    trace_g_realloc(mem, n_bytes, ptr);
-    return ptr;
-}
-
-static void free_and_trace(gpointer mem)
-{
-    trace_g_free(mem);
-    free(mem);
-}
-
 static int machine_set_property(const char *name, const char *value,
                                 void *opaque)
 {
@@@@ -2763,11 +2743,6 @@@@ int main(int argc, char **argv, char **envp)
     bool userconfig = true;
     const char *log_mask = NULL;
     const char *log_file = NULL;
-    GMemVTable mem_trace = {
-        .malloc = malloc_and_trace,
-        .realloc = realloc_and_trace,
-        .free = free_and_trace,
-    };
     const char *trace_events = NULL;
     const char *trace_file = NULL;
     const ram_addr_t default_ram_size = (ram_addr_t)DEFAULT_RAM_SIZE *
@@@@ -2780,8 +2755,6 @@@@ int main(int argc, char **argv, char **envp)
     atexit(qemu_run_exit_notifiers);
     error_set_progname(argv[0]);
     qemu_init_exec_dir(argv[0]);
-
-    g_mem_set_vtable(&mem_trace);
 
     module_call_init(MODULE_INIT_QOM);
 
@


1.24
log
@Remove malloc tracing from QEMU, this was removed in newer glib and results
in annoying messages:

(process:23283): GLib-WARNING **: gmem.c:482: custom memory allocation vtable not supported

From Brad.
@
text
@d1 1
a1 1
$OpenBSD$
@


1.23
log
@Update to qemu 0.13.0. fmt README and sync with reality.
with input and ok sthen@@
@
text
@d1 40
a40 4
$OpenBSD: patch-vl_c,v 1.22 2010/05/28 00:02:52 fgsch Exp $
--- vl.c.orig	Tue Feb 23 13:54:38 2010
+++ vl.c	Thu May 27 17:04:47 2010
@@@@ -652,7 +652,8 @@@@ static void init_get_clock(void)
d42 21
a62 18
     use_rt_clock = 0;
 #if defined(__linux__) || (defined(__FreeBSD__) && __FreeBSD_version >= 500000) \
-    || defined(__DragonFly__) || defined(__FreeBSD_kernel__)
+    || defined(__DragonFly__) || defined(__FreeBSD_kernel__) \
+    || defined(__OpenBSD__)
     {
         struct timespec ts;
         if (clock_gettime(CLOCK_MONOTONIC, &ts) == 0) {
@@@@ -665,7 +666,8 @@@@ static void init_get_clock(void)
 static int64_t get_clock(void)
 {
 #if defined(__linux__) || (defined(__FreeBSD__) && __FreeBSD_version >= 500000) \
-	|| defined(__DragonFly__) || defined(__FreeBSD_kernel__)
+	|| defined(__DragonFly__) || defined(__FreeBSD_kernel__) \
+	|| defined(__OpenBSD__)
     if (use_rt_clock) {
         struct timespec ts;
         clock_gettime(CLOCK_MONOTONIC, &ts);
@


1.22
log
@Use clock_gettime().
@
text
@d1 1
a1 1
$OpenBSD$
@


1.21
log
@Update to qemu 0.12.3. Work in progress so not linked to the tree yet.
@
text
@d1 4
a4 28
$OpenBSD: patch-vl_c,v 1.20 2008/12/10 23:30:33 todd Exp $
--- vl.c.orig	Sun Jan  6 13:38:42 2008
+++ vl.c	Tue Jun 17 19:48:00 2008
@@@@ -61,7 +61,8 @@@@
 #include <arpa/inet.h>
 #ifdef _BSD
 #include <sys/stat.h>
-#ifndef __APPLE__
+#include <net/if.h>
+#if !defined(__APPLE__) && !defined(__OpenBSD__)
 #include <libutil.h>
 #endif
 #elif defined (__GLIBC__) && defined (__FreeBSD_kernel__)
@@@@ -136,7 +137,7 @@@@ int inet_aton(const char *cp, struct in_addr *ia);
 #ifdef __sun__
 #define SMBD_COMMAND "/usr/sfw/sbin/smbd"
 #else
-#define SMBD_COMMAND "/usr/sbin/smbd"
+#define SMBD_COMMAND "${LOCALBASE}/libexec/smbd"
 #endif
 
 //#define DEBUG_UNUSED_IOPORT
@@@@ -3491,7 +3492,7 @@@@ static int parse_macaddr(uint8_t *macaddr, const char 
     return -1;
 }
 
-static int get_str_sep(char *buf, int buf_size, const char **pp, int sep)
+static int get_str_sep(char *buf, size_t buf_size, const char **pp, int sep)
d6 10
a15 113
     const char *p, *p1;
     int len;
@@@@ -3922,11 +3923,85 @@@@ static int tap_open(char *ifname, int ifname_size)
     char *dev;
     struct stat s;
 
+    /* If the device was specified on the command line, use it */
+    if (ifname[0]) {
+       TFR(fd = open(ifname, O_RDWR));
+       if (fd < 0) {
+          fprintf(stderr, "warning: could not open %s: no virtual network emulation\n", ifname);
+            return -1;
+       }
+    } else {
+#ifdef __OpenBSD__
+    struct ifreq ifr;
+    int i = 0, enoentcount = 0, err = 0, sock;
+    char dname[100];
+
+    bzero(&ifr, sizeof(ifr));
+    if (ifname != NULL && ifname[0] != '\0') {
+        snprintf(dname, sizeof(dname), "/dev/%s", ifname);
+        strlcpy(ifr.ifr_name, ifname, sizeof(ifr.ifr_name));
+        fd = open(dname, O_RDWR);
+    } else {
+        for (; i != -1; i++) {
+           snprintf(dname, sizeof dname, "/dev/tun%d", i);
+           bzero(&ifr.ifr_name, sizeof(ifr.ifr_name));
+           snprintf(ifr.ifr_name, sizeof(ifr.ifr_name), "tun%d", i);
+           TFR(fd = open(dname, O_RDWR));
+           if (fd >= 0)
+               break;
+           else if (errno != ENOENT || ++enoentcount > 3) {
+                if (errno != EBUSY) {
+                    err = errno;
+                    break;
+                } 
+            } else  
+                err = errno;
+        }
+    }
+    if (fd < 0) {
+       fprintf(stderr, "warning: could not open %s (%s): no virtual "
+           "network emulation\n", dname, strerror(err));
+       return -1;
+    }
+
+    /* Set the tunnel device operation mode */
+    if ((sock = socket(PF_UNIX, SOCK_STREAM, 0)) == -1) {
+        close(fd);
+        return -1;
+    }
+
+    /* Get interface flags */
+    if (ioctl(sock, SIOCGIFFLAGS, &ifr) == -1) {
+        close(fd);
+        close(sock);
+        return -1;
+    }
+
+    /* Set interface mode */
+    ifr.ifr_flags &= ~IFF_UP;
+    ifr.ifr_flags |= IFF_LINK0;
+    if (ioctl(sock, SIOCSIFFLAGS, &ifr) == -1) {
+        close(fd);
+        close(sock);
+        return -1;
+    }
+
+    /* Bring interface up */
+    ifr.ifr_flags |= IFF_UP;
+    if (ioctl(sock, SIOCSIFFLAGS, &ifr) == -1) {
+        close(fd);
+        close(sock);
+        return -1;
+    }
+
+#else
     TFR(fd = open("/dev/tap", O_RDWR));
     if (fd < 0) {
         fprintf(stderr, "warning: could not open /dev/tap: no virtual network emulation\n");
         return -1;
     }
+#endif
+    }
 
     fstat(fd, &s);
     dev = devname(s.st_rdev, S_IFCHR);
@@@@ -4141,6 +4216,7 @@@@ static int net_tap_init(VLANState *vlan, const char *i
     TAPState *s;
     int fd;
     char ifname[128];
+    bzero(&ifname,sizeof(ifname));
 
     if (ifname1 != NULL)
         pstrcpy(ifname, sizeof(ifname), ifname1);
@@@@ -4320,7 +4396,7 @@@@ static int net_socket_mcast_create(struct sockaddr_in 
     /* Force mcast msgs to loopback (eg. several QEMUs in same host */
     val = 1;
     ret=setsockopt(fd, IPPROTO_IP, IP_MULTICAST_LOOP,
-                   (const char *)&val, sizeof(val));
+                   (const char *)&val, sizeof(char));
     if (ret < 0) {
 	perror("setsockopt(SOL_IP, IP_MULTICAST_LOOP)");
 	goto fail;
@@@@ -4609,7 +4685,8 @@@@ static const char *get_word(char *buf, int buf_size, c
     return p;
 }
 
-static int get_param_value(char *buf, int buf_size,
+static int get_param_value(char *, size_t, const char *, const char *);
+static int get_param_value(char *buf, size_t buf_size,
                            const char *tag, const char *str)
d17 7
a23 59
     const char *p;
@@@@ -4748,6 +4825,9 @@@@ static int net_client_init(const char *str)
         char ifname[64];
         char setup_script[1024], down_script[1024];
         int fd;
+        bzero(&ifname, sizeof(ifname));
+        bzero(&setup_script, sizeof(setup_script));
+        bzero(&down_script, sizeof(down_script));
         vlan->nb_host_devs++;
         if (get_param_value(buf, sizeof(buf), "fd", p) > 0) {
             fd = strtol(buf, NULL, 0);
@@@@ -4755,16 +4835,16 @@@@ static int net_client_init(const char *str)
             if (net_tap_fd_init(vlan, fd))
                 ret = 0;
         } else {
-            if (get_param_value(ifname, sizeof(ifname), "ifname", p) <= 0) {
-                ifname[0] = '\0';
-            }
             if (get_param_value(setup_script, sizeof(setup_script), "script", p) == 0) {
                 pstrcpy(setup_script, sizeof(setup_script), DEFAULT_NETWORK_SCRIPT);
             }
             if (get_param_value(down_script, sizeof(down_script), "downscript", p) == 0) {
                 pstrcpy(down_script, sizeof(down_script), DEFAULT_NETWORK_DOWN_SCRIPT);
             }
-            ret = net_tap_init(vlan, ifname, setup_script, down_script);
+            if (get_param_value(ifname, sizeof(ifname), "ifname", p) == 0)
+               ret = net_tap_init(vlan, NULL, setup_script, down_script);
+            else
+               ret = net_tap_init(vlan, ifname, setup_script, down_script);
         }
     } else
 #endif
@@@@ -8130,19 +8210,23 @@@@ int main(int argc, char **argv)
     gdbstub_port = DEFAULT_GDBSTUB_PORT;
 #endif
     snapshot = 0;
+#if defined(CONFIG_SDL) || defined(CONFIG_COCOA)
     nographic = 0;
+#else
+    nographic = 1;
+#endif
     kernel_filename = NULL;
     kernel_cmdline = "";
     cyls = heads = secs = 0;
     translation = BIOS_ATA_TRANSLATION_AUTO;
-    pstrcpy(monitor_device, sizeof(monitor_device), "vc");
+    pstrcpy(monitor_device, sizeof(monitor_device), nographic ? "stdio" : "vc");
 
-    pstrcpy(serial_devices[0], sizeof(serial_devices[0]), "vc");
+    pstrcpy(serial_devices[0], sizeof(serial_devices[0]), nographic ? "stdio" : "vc");
     for(i = 1; i < MAX_SERIAL_PORTS; i++)
         serial_devices[i][0] = '\0';
     serial_device_index = 0;
 
-    pstrcpy(parallel_devices[0], sizeof(parallel_devices[0]), "vc");
+    pstrcpy(parallel_devices[0], sizeof(parallel_devices[0]), "null");
     for(i = 1; i < MAX_PARALLEL_PORTS; i++)
         parallel_devices[i][0] = '\0';
     parallel_device_index = 0;
@


1.20
log
@*** empty log message ***
@
text
@d1 1
a1 1
$OpenBSD: patch-vl_c,v 1.19 2008/09/22 15:17:54 mpf Exp $
@


1.19
log
@Fix -net tap,ifname=/dev/tunX support.
Bump PKGNAME.
OK todd@@
@
text
@d1 1
a1 1
$OpenBSD: patch-vl_c,v 1.18 2008/06/19 05:51:17 todd Exp $
d19 1
a19 1
+#define SMBD_COMMAND "!!LOCALBASE!!/libexec/smbd"
@


1.18
log
@add usb host support, from jcs@@
bump pkgname
@
text
@d1 1
a1 1
$OpenBSD: patch-vl_c,v 1.17 2008/04/28 22:52:38 todd Exp $
d172 1
a172 1
+               ret = net_tap_init(vlan, NULL, setup_script, down_script);
@


1.17
log
@o update to 0.9.1, lots from brad@@
o see http://qemu.org/changelog.html for details
o see README.OpenBSD for an intro to qemu on OpenBSD
o disable broken arm host support for now
@
text
@d1 3
a3 3
$OpenBSD: patch-vl_c,v 1.16 2008/03/31 20:16:52 todd Exp $
--- vl.c.orig	Sun Jan  6 14:38:42 2008
+++ vl.c	Tue Apr  1 22:43:39 2008
@


1.16
log
@give encrypted image support a chance to work, from viq at viq dot ath dot cx
@
text
@d1 5
a5 5
$OpenBSD: patch-vl_c,v 1.15 2008/03/31 14:26:00 todd Exp $
--- vl.c.orig	Tue Feb  6 00:01:54 2007
+++ vl.c	Mon Mar 31 21:42:05 2008
@@@@ -44,7 +44,8 @@@@
 #include <netdb.h>
d13 2
a14 2
 #else
@@@@ -92,7 +93,7 @@@@
d23 2
a24 10
@@@@ -168,6 +169,7 @@@@ const char *vnc_display;
 int acpi_enabled = 1;
 int fd_bootchk = 1;
 int no_reboot = 0;
+int scsi_enabled = 0;
 int daemonize = 0;
 const char *option_rom[MAX_OPTION_ROMS];
 int nb_option_roms;
@@@@ -2808,7 +2810,7 @@@@ static int parse_macaddr(uint8_t *macaddr, const char 
     return 0;
d32 1
a32 1
@@@@ -3226,11 +3228,85 @@@@ static int tap_open(char *ifname, int ifname_size)
d38 1
a38 1
+       fd = open(ifname, O_RDWR);
d47 1
a47 1
+    char dname[100], iname[100];
d57 1
a57 1
+            bzero(&ifr.ifr_name, sizeof(ifr.ifr_name));
d59 1
a59 1
+           fd = open(dname, O_RDWR);
d66 2
a67 2
+                }
+            } else
d108 1
a108 1
     fd = open("/dev/tap", O_RDWR);
d118 3
a120 3
@@@@ -3282,6 +3358,7 @@@@ static int net_tap_init(VLANState *vlan, const char *i
     char *args[3];
     char **parg;
d126 1
a126 1
@@@@ -3476,7 +3553,7 @@@@ static int net_socket_mcast_create(struct sockaddr_in 
d129 1
a129 1
     ret=setsockopt(fd, IPPROTO_IP, IP_MULTICAST_LOOP, 
d135 2
a136 2
@@@@ -3732,7 +3809,8 @@@@ static int net_socket_mcast_init(VLANState *vlan, cons
 
d145 1
a145 2
@@@@ -3856,6 +3934,8 @@@@ static int net_client_init(const char *str)
     if (!strcmp(device, "tap")) {
d147 1
a147 3
         char setup_script[1024];
+	bzero(&ifname,sizeof(ifname));
+	bzero(&setup_script,sizeof(setup_script));
d149 4
d155 1
a155 1
@@@@ -3863,13 +3943,13 @@@@ static int net_client_init(const char *str)
d165 4
a168 1
-            ret = net_tap_init(vlan, ifname, setup_script);
d170 3
a172 3
+		ret = net_tap_init(vlan, NULL, setup_script);
+	    else
+		ret = net_tap_init(vlan, NULL, setup_script);
d176 1
a176 35
@@@@ -6117,6 +6197,7 @@@@ void help(void)
            "-no-acpi        disable ACPI\n"
 #endif
            "-no-reboot      exit instead of rebooting\n"
+           "-scsienable     enable scsi devices\n"
            "-loadvm file    start right away with a saved state (loadvm in monitor)\n"
 	   "-vnc display    start a VNC server on display\n"
 #ifndef _WIN32
@@@@ -6205,7 +6286,8 @@@@ enum {
     QEMU_OPTION_no_reboot,
     QEMU_OPTION_daemonize,
     QEMU_OPTION_option_rom,
-    QEMU_OPTION_semihosting
+    QEMU_OPTION_semihosting,
+    QEMU_OPTION_scsi
 };
 
 typedef struct QEMUOption {
@@@@ -6281,6 +6363,7 @@@@ const QEMUOption qemu_options[] = {
     { "usbdevice", HAS_ARG, QEMU_OPTION_usbdevice },
     { "smp", HAS_ARG, QEMU_OPTION_smp },
     { "vnc", HAS_ARG, QEMU_OPTION_vnc },
+    { "scsienable", 0, QEMU_OPTION_scsi },
 
     /* temporary options */
     { "usb", 0, QEMU_OPTION_usb },
@@@@ -6329,6 +6412,7 @@@@ static void read_passwords(void)
     for(i = 0; i < 6; i++) {
         bs = get_bdrv(i);
         if (bs && bdrv_is_encrypted(bs)) {
+        		qemu_bh_poll();
             term_printf("%s is encrypted.\n", bdrv_get_device_name(bs));
             for(j = 0; j < 3; j++) {
                 monitor_readline("Password: ", 
@@@@ -6570,7 +6654,11 @@@@ int main(int argc, char **argv)
a186 3
 #ifdef TARGET_PPC
@@@@ -6580,14 +6668,14 @@@@ int main(int argc, char **argv)
 #endif
d190 1
a190 1
+    pstrcpy(monitor_device, sizeof(monitor_device), nographic ? "stdio" : "vc" );
d197 1
a197 1
     
a202 10
@@@@ -6940,6 +7028,9 @@@@ int main(int argc, char **argv)
 		break;
             case QEMU_OPTION_no_acpi:
                 acpi_enabled = 0;
+                break;
+            case QEMU_OPTION_scsi:
+                scsi_enabled = 1;
                 break;
             case QEMU_OPTION_no_reboot:
                 no_reboot = 1;
@


1.15
log
@fix -smb option, from viq at viq dot ath dot cx
@
text
@d1 1
a1 1
$OpenBSD: patch-vl_c,v 1.14 2007/05/01 12:55:14 todd Exp $
d3 1
a3 1
+++ vl.c	Sun Feb 10 02:30:48 2008
d206 9
a214 1
@@@@ -6570,7 +6653,11 @@@@ int main(int argc, char **argv)
d226 1
a226 1
@@@@ -6580,14 +6667,14 @@@@ int main(int argc, char **argv)
d244 1
a244 1
@@@@ -6940,6 +7027,9 @@@@ int main(int argc, char **argv)
@


1.14
log
@update to 0.9.0, thanks to all who gave feedback
see http://qemu.org/changelog.html for details
new in OpenBSD, support for raw block devices
@
text
@d1 3
a3 3
$OpenBSD$
--- vl.c.orig	Mon Feb  5 17:01:54 2007
+++ vl.c	Sat Apr 21 19:48:30 2007
d14 9
@


1.13
log
@- allow building on armish
- fix the build on the arm architecture by moving the cpu_get_real_ticks()
function for non-optimized to the correct place
- add correct REGRESS_TARGET even if the regressions tests are utterly broken
- bump PKGNAME
@
text
@d1 4
a4 3
--- vl.c.orig	Sat Jul 22 19:23:34 2006
+++ vl.c	Mon Feb 19 11:30:23 2007
@@@@ -43,7 +43,8 @@@@
d14 9
a22 31
@@@@ -291,7 +292,7 @@@@ void isa_unassign_ioport(int start, int 
 
 /***********************************************************/
 
-void pstrcpy(char *buf, int buf_size, const char *str)
+void pstrcpy(char *buf, size_t buf_size, const char *str)
 {
     int c;
     char *q = buf;
@@@@ -309,7 +310,7 @@@@ void pstrcpy(char *buf, int buf_size, co
 }
 
 /* strcat and truncate. */
-char *pstrcat(char *buf, int buf_size, const char *s)
+char *pstrcat(char *buf, size_t buf_size, const char *s)
 {
     int len;
     len = strlen(buf);
@@@@ -1408,6 +1409,11 @@@@ static void stdio_read(void *opaque)
     uint8_t buf[1];
     
     size = read(0, buf, 1);
+    if (size == 0) {
+        /* stdin has been closed. Remove it from the active list.  */
+        qemu_set_fd_handler2(0, NULL, NULL, NULL, NULL);
+        return;
+    }
     if (size > 0)
         stdio_received_byte(buf[0]);
 }
@@@@ -2631,7 +2637,7 @@@@ static int parse_macaddr(uint8_t *macadd
d31 1
a31 1
@@@@ -3029,11 +3035,85 @@@@ static int tap_open(char *ifname, int if
d117 9
a125 1
@@@@ -3279,7 +3359,7 @@@@ static int net_socket_mcast_create(struc
d134 1
a134 1
@@@@ -3535,7 +3615,8 @@@@ static int net_socket_mcast_init(VLANSta
d144 2
a145 1
@@@@ -3660,17 +3741,21 @@@@ int net_client_init(const char *str)
d148 2
a150 2
+        bzero(&ifname,sizeof(ifname));
+        bzero(&setup_script,sizeof(setup_script));
d153 1
a153 1
             ret = -1;
d157 3
a159 1
-            get_param_value(ifname, sizeof(ifname), "ifname", p);
d165 3
a167 3
+               ret = net_tap_init(vlan, NULL, setup_script);
+            else
+               ret = net_tap_init(vlan, ifname, setup_script);
d171 48
a218 1
@@@@ -5671,7 +5756,7 @@@@ int main(int argc, char **argv)
d227 10
@


1.12
log
@Fix busy loop on closed stdin in -nograhpic mode.
From qemu cvs vl.c -r 1.218.
bump PKGNAME

OK todd@@
@
text
@d2 1
a2 1
+++ vl.c	Tue Jan 16 19:51:19 2007
d181 1
a181 26
@@@@ -5453,7 +5538,23 @@@@ void register_machines(void)
 #elif defined(TARGET_SH4)
     qemu_register_machine(&shix_machine);
 #else
-#error unsupported CPU
+# warning non-optimized CPU
+#include <sys/time.h>
+#include <time.h>
+
+int64_t cpu_get_real_ticks(void)
+{
+    struct timeval tv;
+    static int64_t i = 0;
+    int64_t j;
+
+    gettimeofday(&tv, NULL);
+    do {
+       j = (tv.tv_sec * (uint64_t) 1000000) + tv.tv_usec;
+    } while (i == j);
+    i = j;
+    return j;
+}
 #endif
 }
 
@@@@ -5671,7 +5772,7 @@@@ int main(int argc, char **argv)
@


1.11
log
@Call setsockopt(2) IP_MULTICAST_LOOP w/ correct optlen.
This fixes UDP multicast socket networking.
bump PKGNAME

OK sturm@@, todd@@
@
text
@d2 1
a2 1
+++ vl.c	Wed Jan  3 15:14:21 2007
d31 13
a43 1
@@@@ -2631,7 +2632,7 @@@@ static int parse_macaddr(uint8_t *macadd
d52 1
a52 1
@@@@ -3029,11 +3030,85 @@@@ static int tap_open(char *ifname, int if
d138 1
a138 1
@@@@ -3279,7 +3354,7 @@@@ static int net_socket_mcast_create(struc
d147 1
a147 1
@@@@ -3535,7 +3610,8 @@@@ static int net_socket_mcast_init(VLANSta
d157 1
a157 1
@@@@ -3660,17 +3736,21 @@@@ int net_client_init(const char *str)
d181 1
a181 1
@@@@ -5453,7 +5533,23 @@@@ void register_machines(void)
d206 1
a206 1
@@@@ -5671,7 +5767,7 @@@@ int main(int argc, char **argv)
@


1.10
log
@update qemu to 0.8.2, from brad@@

See http://fabrice.bellard.free.fr/qemu/changelog.html for details.
@
text
@d1 2
a2 2
--- vl.c.orig	Mon Dec 18 16:55:53 2006
+++ vl.c	Mon Dec 18 17:06:04 2006
d126 9
@


1.9
log
@update to 0.8.1, see http://qemu.org/changelog.html for details
@
text
@d1 2
a2 2
--- vl.c.orig	Wed May  3 15:32:58 2006
+++ vl.c	Fri May  5 22:24:31 2006
d13 1
a13 9
@@@@ -130,6 +131,7 @@@@ QEMUTimer *gui_timer;
 int vm_running;
 int rtc_utc = 1;
 int cirrus_vga_enabled = 1;
+int nic_pcnet = 0;
 #ifdef TARGET_SPARC
 int graphic_width = 1024;
 int graphic_height = 768;
@@@@ -292,7 +294,7 @@@@ void isa_unassign_ioport(int start, int 
d22 1
a22 1
@@@@ -310,7 +312,7 @@@@ void pstrcpy(char *buf, int buf_size, co
d31 1
a31 26
@@@@ -561,7 +563,23 @@@@ int64_t cpu_get_real_ticks(void)
 }
 
 #else
-#error unsupported CPU
+# warning non-optimized CPU
+#include <sys/time.h>
+#include <time.h>
+
+int64_t cpu_get_real_ticks(void)
+{
+    struct timeval tv;
+    static int64_t i = 0;
+    int64_t j;
+
+    gettimeofday(&tv, NULL);
+    do {
+	j = (tv.tv_sec * (uint64_t) 1000000) + tv.tv_usec;
+    } while (i == j);
+    i = j;
+    return j;
+}
 #endif
 
 static int64_t cpu_ticks_prev;
@@@@ -2201,7 +2219,7 @@@@ static int parse_macaddr(uint8_t *macadd
d40 1
a40 1
@@@@ -2560,11 +2578,85 @@@@ static int tap_open(char *ifname, int if
d46 5
a50 5
+	fd = open(ifname, O_RDWR);
+	if (fd < 0) {
+	   fprintf(stderr, "warning: could not open %s: no virtual network emulation\n", ifname);
+	     return -1;
+	}
d64 1
a64 1
+    	    snprintf(dname, sizeof dname, "/dev/tun%d", i);
d66 5
a70 5
+	    snprintf(ifr.ifr_name, sizeof(ifr.ifr_name), "tun%d", i);
+	    fd = open(dname, O_RDWR);
+	    if (fd >= 0)
+	        break;
+	    else if (errno != ENOENT || ++enoentcount > 3) {
d80 3
a82 3
+	fprintf(stderr, "warning: could not open %s (%s): no virtual "
+	    "network emulation\n", dname, strerror(err));
+	return -1;
d126 1
a126 1
@@@@ -3065,7 +3157,8 @@@@ static int net_socket_mcast_init(VLANSta
d136 1
a136 1
@@@@ -3190,17 +3283,21 @@@@ int net_client_init(const char *str)
d140 2
a141 2
+	bzero(&ifname,sizeof(ifname));
+	bzero(&setup_script,sizeof(setup_script));
d154 3
a156 3
+		ret = net_tap_init(vlan, NULL, setup_script);
+	    else
+            	ret = net_tap_init(vlan, ifname, setup_script);
d160 22
a181 3
@@@@ -4623,6 +4720,7 @@@@ void help(void)
 #if defined(TARGET_PPC) || defined(TARGET_SPARC)
            "-g WxH[xDEPTH]  Set the initial graphical resolution and depth\n"
d183 1
a183 9
+           "-nic-pcnet     simulate an AMD PC-Net PCI ethernet adaptor\n"
            "\n"
            "Network options:\n"
            "-net nic[,vlan=n][,macaddr=addr][,model=type]\n"
@@@@ -4735,6 +4833,7 @@@@ enum {
     QEMU_OPTION_audio_help,
     QEMU_OPTION_soundhw,
 #endif
+    QEMU_OPTION_nic_pcnet,
d185 1
a185 11
     QEMU_OPTION_net,
     QEMU_OPTION_tftp,
@@@@ -4841,6 +4940,7 @@@@ const QEMUOption qemu_options[] = {
     
     /* temporary options */
     { "usb", 0, QEMU_OPTION_usb },
+    { "nic-pcnet", 0, QEMU_OPTION_nic_pcnet },
     { "cirrusvga", 0, QEMU_OPTION_cirrusvga },
     { NULL },
 };
@@@@ -5101,7 +5201,7 @@@@ int main(int argc, char **argv)
a193 10
@@@@ -5261,6 +5361,9 @@@@ int main(int argc, char **argv)
                         optarg);
                 nb_net_clients++;
                 break;
+            case QEMU_OPTION_nic_pcnet:
+		nic_pcnet = 1;
+		break;
 #ifdef CONFIG_SLIRP
             case QEMU_OPTION_tftp:
 		tftp_prefix = optarg;
@


1.8
log
@fixes from various
o permit auto tun# allocation
o do not destroy trunk# to permit multiple qemu sessions to use the same trunk#
  in the sample qemu-ifup script
o fix building on zaurus
o detect case where no tun# is available, Nicholas Marriott
o bump pkgname
@
text
@d1 2
a2 2
--- vl.c.orig	Mon Dec 19 16:51:53 2005
+++ vl.c	Mon Apr 10 16:02:04 2006
d13 1
a13 1
@@@@ -126,6 +127,7 @@@@ QEMUTimer *gui_timer;
d21 1
a21 1
@@@@ -288,7 +290,7 @@@@ void isa_unassign_ioport(int start, int 
d30 1
a30 1
@@@@ -306,7 +308,7 @@@@ void pstrcpy(char *buf, int buf_size, co
d39 1
a39 1
@@@@ -549,7 +551,23 @@@@ int64_t cpu_get_real_ticks(void)
d63 2
a64 2
 static int64_t cpu_ticks_offset;
@@@@ -1693,7 +1711,7 @@@@ static int parse_macaddr(uint8_t *macadd
d73 1
a73 67
@@@@ -1768,13 +1786,16 @@@@ VLANState *qemu_find_vlan(int id)
 }
 
 VLANClientState *qemu_new_vlan_client(VLANState *vlan,
-                                      IOReadHandler *fd_read, void *opaque)
+                                      IOReadHandler *fd_read,
+                                      IOCanRWHandler *fd_can_read,
+                                      void *opaque)
 {
     VLANClientState *vc, **pvc;
     vc = qemu_mallocz(sizeof(VLANClientState));
     if (!vc)
         return NULL;
     vc->fd_read = fd_read;
+    vc->fd_can_read = fd_can_read;
     vc->opaque = opaque;
     vc->vlan = vlan;
 
@@@@ -1786,6 +1807,20 @@@@ VLANClientState *qemu_new_vlan_client(VL
     return vc;
 }
 
+int qemu_can_send_packet(VLANClientState *vc1)
+{
+    VLANState *vlan = vc1->vlan;
+    VLANClientState *vc;
+
+    for(vc = vlan->first_client; vc != NULL; vc = vc->next) {
+        if (vc != vc1) {
+            if (vc->fd_can_read && !vc->fd_can_read(vc->opaque))
+                return 0;
+        }
+    }
+    return 1;
+}
+
 void qemu_send_packet(VLANClientState *vc1, const uint8_t *buf, int size)
 {
     VLANState *vlan = vc1->vlan;
@@@@ -1811,7 +1846,7 @@@@ static VLANClientState *slirp_vc;
 
 int slirp_can_output(void)
 {
-    return 1;
+    qemu_can_send_packet(slirp_vc);
 }
 
 void slirp_output(const uint8_t *pkt, int pkt_len)
@@@@ -1839,7 +1874,7 @@@@ static int net_slirp_init(VLANState *vla
         slirp_init();
     }
     slirp_vc = qemu_new_vlan_client(vlan, 
-                                    slirp_receive, NULL);
+                                    slirp_receive, NULL, NULL);
     snprintf(slirp_vc->info_str, sizeof(slirp_vc->info_str), "user redirector");
     return 0;
 }
@@@@ -2024,7 +2059,7 @@@@ static TAPState *net_tap_fd_init(VLANSta
     if (!s)
         return NULL;
     s->fd = fd;
-    s->vc = qemu_new_vlan_client(vlan, tap_receive, s);
+    s->vc = qemu_new_vlan_client(vlan, tap_receive, NULL, s);
     qemu_set_fd_handler(s->fd, tap_send, NULL, s);
     snprintf(s->vc->info_str, sizeof(s->vc->info_str), "tap: fd=%d", fd);
     return s;
@@@@ -2037,11 +2072,85 @@@@ static int tap_open(char *ifname, int if
d159 1
a159 19
@@@@ -2327,7 +2436,7 @@@@ static NetSocketState *net_socket_fd_ini
         return NULL;
     s->fd = fd;
 
-    s->vc = qemu_new_vlan_client(vlan, net_socket_receive_dgram, s);
+    s->vc = qemu_new_vlan_client(vlan, net_socket_receive_dgram, NULL, s);
     qemu_set_fd_handler(s->fd, net_socket_send_dgram, NULL, s);
 
     /* mcast: save bound address as dst */
@@@@ -2355,7 +2464,7 @@@@ static NetSocketState *net_socket_fd_ini
         return NULL;
     s->fd = fd;
     s->vc = qemu_new_vlan_client(vlan, 
-                                 net_socket_receive, s);
+                                 net_socket_receive, NULL, s);
     snprintf(s->vc->info_str, sizeof(s->vc->info_str),
              "socket: fd=%d", fd);
     if (is_connected) {
@@@@ -2526,7 +2635,8 @@@@ static int net_socket_mcast_init(VLANSta
d161 1
a161 1
 #endif /* !_WIN32 */
d169 1
a169 1
@@@@ -2636,17 +2746,21 @@@@ int net_client_init(const char *str)
d192 2
a193 2
     if (!strcmp(device, "socket")) {
@@@@ -3986,6 +4100,7 @@@@ void help(void)
d200 2
a201 2
            "-net nic[,vlan=n][,macaddr=addr]\n"
@@@@ -4093,6 +4208,7 @@@@ enum {
d209 1
a209 1
@@@@ -4195,6 +4311,7 @@@@ const QEMUOption qemu_options[] = {
d217 1
a217 1
@@@@ -4441,7 +4558,7 @@@@ int main(int argc, char **argv)
d226 1
a226 1
@@@@ -4601,6 +4718,9 @@@@ int main(int argc, char **argv)
@


1.7
log
@from Andrew Dalgleish openbsd at ajd dot net dot au
o sample qemu-ifup
o permit -net tap,ifname=/dev/tun1 to actually use tun1
from Reyk Floeter reyk at openbsd dot org
o re-enable pcnet

bump PKGNAME
@
text
@d2 1
a2 1
+++ vl.c	Tue Feb 14 14:52:26 2006
d21 18
d64 9
d162 1
a162 1
+        for (; i < 10; i++) {
d243 35
a277 1
@@@@ -3986,6 +4095,7 @@@@ void help(void)
d285 1
a285 1
@@@@ -4093,6 +4203,7 @@@@ enum {
d293 1
a293 1
@@@@ -4195,6 +4306,7 @@@@ const QEMUOption qemu_options[] = {
d301 1
a301 1
@@@@ -4441,7 +4553,7 @@@@ int main(int argc, char **argv)
d310 1
a310 1
@@@@ -4601,6 +4713,9 @@@@ int main(int argc, char **argv)
@


1.6
log
@o from the qemu mailing list, prompted by brad@@, improve userland
  networking througput since otherwise the emulated NICs didn't
  have a way of indicating the receive queue is full and would
  drop packets.
o bump PKGNAME
o inttypes.h made irrelevent a few chunks of patches, so use it instead
@
text
@d1 3
a3 4
$OpenBSD: patch-vl_c,v 1.5 2005/12/27 07:56:15 todd Exp $
--- vl.c.orig	Mon Dec 19 17:51:53 2005
+++ vl.c	Sat Jan 28 22:10:33 2006
@@@@ -43,7 +43,7 @@@@
d8 1
d13 1
a13 1
@@@@ -126,6 +126,7 @@@@ QEMUTimer *gui_timer;
d21 1
a21 1
@@@@ -549,7 +550,23 @@@@ int64_t cpu_get_real_ticks(void)
d46 1
a46 1
@@@@ -1768,13 +1785,16 @@@@ VLANState *qemu_find_vlan(int id)
d64 1
a64 1
@@@@ -1786,6 +1806,20 @@@@ VLANClientState *qemu_new_vlan_client(VL
d85 1
a85 1
@@@@ -1811,7 +1845,7 @@@@ static VLANClientState *slirp_vc;
d94 1
a94 1
@@@@ -1839,7 +1873,7 @@@@ static int net_slirp_init(VLANState *vla
d103 1
a103 1
@@@@ -2024,7 +2058,7 @@@@ static TAPState *net_tap_fd_init(VLANSta
d112 1
a112 1
@@@@ -2037,11 +2071,35 @@@@ static int tap_open(char *ifname, int if
d116 8
d125 3
a127 2
+    int i = 0, enoentcount = 0, err = 0;
+    char dname[100];
d129 21
a149 12
+    for (; i < 10; i++) {
+	snprintf(dname, sizeof dname, "/dev/tun%d", i);
+	fd = open(dname, O_RDWR);
+	if (fd >= 0)
+	    break;
+	else if (errno != ENOENT || ++enoentcount > 3) {
+		if (errno != EBUSY) {
+			err = errno;
+			break;
+		}
+	} else
+	    err = errno;
d156 31
d194 1
d198 1
a198 1
@@@@ -2327,7 +2385,7 @@@@ static NetSocketState *net_socket_fd_ini
d207 1
a207 1
@@@@ -2355,7 +2413,7 @@@@ static NetSocketState *net_socket_fd_ini
d216 1
a216 1
@@@@ -3986,6 +4044,7 @@@@ void help(void)
d224 1
a224 1
@@@@ -4093,6 +4152,7 @@@@ enum {
d232 1
a232 1
@@@@ -4195,6 +4255,7 @@@@ const QEMUOption qemu_options[] = {
d240 1
a240 1
@@@@ -4441,7 +4502,7 @@@@ int main(int argc, char **argv)
d249 1
a249 1
@@@@ -4601,6 +4662,9 @@@@ int main(int argc, char **argv)
@


1.5
log
@update to 0.8.0, see qemu.org for full ChangeLog
for OpenBSD, amd64 simulation on i386 appars to work ok now
@
text
@d1 3
a3 3
$OpenBSD: patch-vl_c,v 1.4 2005/11/05 12:11:05 todd Exp $
--- vl.c.orig	Mon Dec 19 16:51:53 2005
+++ vl.c	Tue Dec 20 10:53:26 2005
d46 67
a112 1
@@@@ -2037,11 +2054,35 @@@@ static int tap_open(char *ifname, int if
d148 19
a166 1
@@@@ -3986,6 +4027,7 @@@@ void help(void)
d174 1
a174 1
@@@@ -4093,6 +4135,7 @@@@ enum {
d182 1
a182 1
@@@@ -4195,6 +4238,7 @@@@ const QEMUOption qemu_options[] = {
d190 1
a190 1
@@@@ -4441,7 +4485,7 @@@@ int main(int argc, char **argv)
d199 1
a199 1
@@@@ -4601,6 +4645,9 @@@@ int main(int argc, char **argv)
@


1.4
log
@permit -nographic to work instead of crash on parallel devices
investigation/suggested fix by Thomas Dettbarn, dettus at dettus dot net
bump PKGNAME
@
text
@d1 5
a5 5
$OpenBSD: patch-vl_c,v 1.3 2005/10/25 03:25:44 todd Exp $
--- vl.c.orig	Sun Sep  4 12:11:31 2005
+++ vl.c	Sat Nov  5 05:41:13 2005
@@@@ -42,7 +42,7 @@@@
 #include <dirent.h>
d13 1
a13 2
@@@@ -128,6 +128,7 @@@@ NetDriverState nd_table[MAX_NICS];
 QEMUTimer *gui_timer;
d15 2
a16 1
 int audio_enabled = 0;
d18 29
a46 4
 int sb16_enabled = 1;
 int adlib_enabled = 1;
 int gus_enabled = 1;
@@@@ -1637,11 +1638,35 @@@@ static int tun_open(char *ifname, int if
d82 1
a82 1
@@@@ -2846,6 +2871,7 @@@@ void help(void)
d89 5
a93 5
            "-nics n         simulate 'n' network cards [default=1]\n"
@@@@ -2959,6 +2985,7 @@@@ enum {
     QEMU_OPTION_L,
     QEMU_OPTION_no_code_copy,
     QEMU_OPTION_pci,
d95 4
a98 4
     QEMU_OPTION_isa,
     QEMU_OPTION_prep,
     QEMU_OPTION_k,
@@@@ -3047,6 +3074,7 @@@@ const QEMUOption qemu_options[] = {
d101 1
a101 1
     { "pci", 0, QEMU_OPTION_pci },
d106 1
a106 1
@@@@ -3185,7 +3213,7 @@@@ int main(int argc, char **argv)
d115 3
a117 1
@@@@ -3452,6 +3480,9 @@@@ int main(int argc, char **argv)
a118 3
             case QEMU_OPTION_pci:
                 pci_enabled = 1;
+                break;
d120 5
a124 4
+                nic_pcnet = 1;
                 break;
             case QEMU_OPTION_isa:
                 pci_enabled = 0;
@


1.3
log
@update to qemu 0.7.2
@
text
@d1 1
a1 1
$OpenBSD: patch-vl_c,v 1.2 2005/08/11 01:15:17 todd Exp $
d3 1
a3 1
+++ vl.c	Mon Oct 24 21:55:47 2005
d81 9
@


1.2
log
@update to 0.7.1 (http://qemu.org/changelog.html)
add pcnet nic support
@
text
@d1 3
a3 3
$OpenBSD: patch-vl_c,v 1.1.1.1 2005/03/07 16:41:28 todd Exp $
--- vl.c.orig	Sun Jul 24 13:52:08 2005
+++ vl.c	Wed Aug 10 17:49:15 2005
d21 1
a21 1
@@@@ -1610,11 +1611,35 @@@@ static int tun_open(char *ifname, int if
d57 1
a57 1
@@@@ -2819,6 +2844,7 @@@@ void help(void)
d65 1
a65 1
@@@@ -2932,6 +2958,7 @@@@ enum {
d73 1
a73 1
@@@@ -3020,6 +3047,7 @@@@ const QEMUOption qemu_options[] = {
d81 1
a81 1
@@@@ -3425,6 +3453,9 @@@@ int main(int argc, char **argv)
@


1.1
log
@Initial revision
@
text
@d1 3
a3 3
$OpenBSD$
--- vl.c.orig	Thu Feb 10 16:00:06 2005
+++ vl.c	Tue Mar  1 15:53:26 2005
d13 9
a21 1
@@@@ -1574,11 +1574,34 @@@@ static int tun_open(char *ifname, int if
d30 1
a30 1
+	snprintf(dname, sizeof dname, "%s%d", "/dev/tun", i);
d36 2
a37 2
+	    	    err = errno;
+	    	    break;
d43 3
a45 2
+        fprintf(stderr, "warning: could not open %s (%s): no virtual network emulation\n", dname, strerror(err));
+        return -1;
d57 34
@


1.1.1.1
log
@Import qemu snapshot from 2005-02-27

QEMU is a generic and open source processor emulator 
which achieves a good emulation speed by using dynamic translation.

QEMU has two operating modes:

* Full system emulation. In this mode, QEMU emulates 
a full system (for example a PC), including a processor and 
various peripherials. It can be used to launch different
Operating Systems without rebooting the PC or to debug system code.

* User mode emulation (Linux host only). In this mode, 

.. many thanks for feedback from many people, and for Lars Hansson and 
   Michael Schmidt for posting early work on the port of qemu to ports@@

For now, only for macppc and i386, as these are currently the only archs
that have reported success building qemu.
QEMU can launch Linux processes compiled for one CPU on another CPU. 
@
text
@@
