head	1.3;
access;
symbols
	OPENBSD_5_9:1.2.0.2
	OPENBSD_5_9_BASE:1.2
	OPENBSD_5_7:1.1.0.4
	OPENBSD_5_8:1.1.0.2;
locks; strict;
comment	@# @;


1.3
date	2016.03.14.19.46.12;	author ajacoutot;	state dead;
branches;
next	1.2;
commitid	ZypCecrzOxeE8g1E;

1.2
date	2016.01.05.06.56.12;	author ajacoutot;	state Exp;
branches;
next	1.1;
commitid	z2cMvU8TlZZSH8m0;

1.1
date	2015.09.16.09.18.13;	author ajacoutot;	state Exp;
branches
	1.1.2.1
	1.1.4.1;
next	;
commitid	PEOP5ubHLhtcX6y5;

1.1.2.1
date	2015.09.16.11.16.44;	author jasper;	state Exp;
branches;
next	1.1.2.2;
commitid	CsrVZj67iJuahhlE;

1.1.2.2
date	2016.01.07.10.27.40;	author jasper;	state Exp;
branches;
next	;
commitid	Ciob9S8eFBoLGbjT;

1.1.4.1
date	2015.09.16.11.16.53;	author jasper;	state Exp;
branches;
next	;
commitid	vx84FGNAvSnETZKj;


desc
@@


1.3
log
@Major update to qemu-2.5.0.
Please direct any runtime fallout to Brad.

from Brad (maintainer)
@
text
@$OpenBSD: patch-hw_net_ne2000_c,v 1.2 2016/01/05 06:56:12 ajacoutot Exp $

net: add checks to validate ring buffer pointers(CVE-2015-5279)

Ne2000 NIC uses ring buffer of NE2000_MEM_SIZE(49152)
bytes to process network packets. While receiving packets
via ne2000_receive() routine, a local 'index' variable
could exceed the ring buffer size, which could lead to a
memory buffer overflow. Added other checks at initialisation.

net: avoid infinite loop when receiving packets(CVE-2015-5278)

Ne2000 NIC uses ring buffer of NE2000_MEM_SIZE(49152)
bytes to process network packets. While receiving packets
via ne2000_receive() routine, a local 'index' variable
could exceed the ring buffer size, leading to an infinite
loop situation.

net: ne2000: fix bounds check in ioport	operations

While doing ioport r/w operations, ne2000 device emulation suffers
from OOB r/w errors. Update respective array bounds check to avoid
OOB access.

CVE-2015-8743

--- hw/net/ne2000.c.orig	Tue Mar 10 13:38:27 2015
+++ hw/net/ne2000.c	Mon Jan  4 20:22:52 2016
@@@@ -230,6 +230,9 @@@@ ssize_t ne2000_receive(NetClientState *nc, const uint8
     }
 
     index = s->curpag << 8;
+    if (index >= NE2000_PMEM_END) {
+        index = s->start;
+    }
     /* 4 bytes for header */
     total_len = size + 4;
     /* address for next packet (4 bytes for CRC) */
@@@@ -253,7 +256,7 @@@@ ssize_t ne2000_receive(NetClientState *nc, const uint8
         if (index <= s->stop)
             avail = s->stop - index;
         else
-            avail = 0;
+            break;
         len = size;
         if (len > avail)
             len = avail;
@@@@ -315,13 +318,19 @@@@ static void ne2000_ioport_write(void *opaque, uint32_t
         offset = addr | (page << 4);
         switch(offset) {
         case EN0_STARTPG:
-            s->start = val << 8;
+            if (val << 8 <= NE2000_PMEM_END) {
+                s->start = val << 8;
+            }
             break;
         case EN0_STOPPG:
-            s->stop = val << 8;
+            if (val << 8 <= NE2000_PMEM_END) {
+                s->stop = val << 8;
+            }
             break;
         case EN0_BOUNDARY:
-            s->boundary = val;
+            if (val << 8 < NE2000_PMEM_END) {
+                s->boundary = val;
+            }
             break;
         case EN0_IMR:
             s->imr = val;
@@@@ -362,7 +371,9 @@@@ static void ne2000_ioport_write(void *opaque, uint32_t
             s->phys[offset - EN1_PHYS] = val;
             break;
         case EN1_CURPAG:
-            s->curpag = val;
+            if (val << 8 < NE2000_PMEM_END) {
+                s->curpag = val;
+            }
             break;
         case EN1_MULT ... EN1_MULT + 7:
             s->mult[offset - EN1_MULT] = val;
@@@@ -465,8 +476,9 @@@@ static inline void ne2000_mem_writel(NE2000State *s, u
                                      uint32_t val)
 {
     addr &= ~1; /* XXX: check exact behaviour if not even */
-    if (addr < 32 ||
-        (addr >= NE2000_PMEM_START && addr < NE2000_MEM_SIZE)) {
+    if (addr < 32
+        || (addr >= NE2000_PMEM_START
+            && addr + sizeof(uint32_t) <= NE2000_MEM_SIZE)) {
         stl_le_p(s->mem + addr, val);
     }
 }
@@@@ -495,8 +507,9 @@@@ static inline uint32_t ne2000_mem_readw(NE2000State *s
 static inline uint32_t ne2000_mem_readl(NE2000State *s, uint32_t addr)
 {
     addr &= ~1; /* XXX: check exact behaviour if not even */
-    if (addr < 32 ||
-        (addr >= NE2000_PMEM_START && addr < NE2000_MEM_SIZE)) {
+    if (addr < 32
+        || (addr >= NE2000_PMEM_START
+            && addr + sizeof(uint32_t) <= NE2000_MEM_SIZE)) {
         return ldl_le_p(s->mem + addr);
     } else {
         return 0xffffffff;
@


1.2
log
@SECURITY fixes for:
CVE-2015-8619, CVE-2015-8666, CVE-2015-8743, CVE-2015-8744, and CVE-2015-8745

from Brad (maintainer)
@
text
@d1 1
a1 1
$OpenBSD: patch-hw_net_ne2000_c,v 1.1 2015/09/16 09:18:13 ajacoutot Exp $
@


1.1
log
@SECURITY: CVE-2015-5278, CVE-2015-5279, CVE-2015-6815
Some more fixes, mostly security related.

from Brad (maintainer)
@
text
@d1 1
a1 1
$OpenBSD$
d19 10
a28 2
--- hw/net/ne2000.c.orig	Wed Sep 16 03:30:14 2015
+++ hw/net/ne2000.c	Wed Sep 16 03:35:01 2015
d82 24
@


1.1.4.1
log
@Security fixes for CVE-2015-5278, CVE-2015-5279, CVE-2015-6815,
as well as several other reliability fixes
@
text
@d1 1
a1 1
$OpenBSD: patch-hw_net_ne2000_c,v 1.1 2015/09/16 09:18:13 ajacoutot Exp $
@


1.1.2.1
log
@Security fixes for CVE-2015-5278, CVE-2015-5279, CVE-2015-6815,
as well as several other reliability fixes
@
text
@d1 1
a1 1
$OpenBSD: patch-hw_net_ne2000_c,v 1.1 2015/09/16 09:18:13 ajacoutot Exp $
@


1.1.2.2
log
@SECURITY fixes for:
CVE-2015-8619, CVE-2015-8666, CVE-2015-8743, CVE-2015-8744, and CVE-2015-8745
@
text
@d1 1
a1 1
$OpenBSD: patch-hw_net_ne2000_c,v 1.2 2016/01/05 06:56:12 ajacoutot Exp $
d19 2
a20 10
net: ne2000: fix bounds check in ioport	operations

While doing ioport r/w operations, ne2000 device emulation suffers
from OOB r/w errors. Update respective array bounds check to avoid
OOB access.

CVE-2015-8743

--- hw/net/ne2000.c.orig	Tue Mar 10 13:38:27 2015
+++ hw/net/ne2000.c	Mon Jan  4 20:22:52 2016
a73 24
@@@@ -465,8 +476,9 @@@@ static inline void ne2000_mem_writel(NE2000State *s, u
                                      uint32_t val)
 {
     addr &= ~1; /* XXX: check exact behaviour if not even */
-    if (addr < 32 ||
-        (addr >= NE2000_PMEM_START && addr < NE2000_MEM_SIZE)) {
+    if (addr < 32
+        || (addr >= NE2000_PMEM_START
+            && addr + sizeof(uint32_t) <= NE2000_MEM_SIZE)) {
         stl_le_p(s->mem + addr, val);
     }
 }
@@@@ -495,8 +507,9 @@@@ static inline uint32_t ne2000_mem_readw(NE2000State *s
 static inline uint32_t ne2000_mem_readl(NE2000State *s, uint32_t addr)
 {
     addr &= ~1; /* XXX: check exact behaviour if not even */
-    if (addr < 32 ||
-        (addr >= NE2000_PMEM_START && addr < NE2000_MEM_SIZE)) {
+    if (addr < 32
+        || (addr >= NE2000_PMEM_START
+            && addr + sizeof(uint32_t) <= NE2000_MEM_SIZE)) {
         return ldl_le_p(s->mem + addr);
     } else {
         return 0xffffffff;
@


