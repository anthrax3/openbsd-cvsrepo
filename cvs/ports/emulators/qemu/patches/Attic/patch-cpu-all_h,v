head	1.4;
access;
symbols
	OPENBSD_4_7:1.3.0.8
	OPENBSD_4_7_BASE:1.3
	OPENBSD_4_6:1.3.0.6
	OPENBSD_4_6_BASE:1.3
	OPENBSD_4_5:1.3.0.4
	OPENBSD_4_5_BASE:1.3
	OPENBSD_4_4:1.3.0.2
	OPENBSD_4_4_BASE:1.3
	OPENBSD_4_3:1.2.0.4
	OPENBSD_4_3_BASE:1.2
	OPENBSD_4_2:1.2.0.2
	OPENBSD_4_2_BASE:1.2
	OPENBSD_4_1:1.1.0.2
	OPENBSD_4_1_BASE:1.1;
locks; strict;
comment	@# @;


1.4
date	2010.05.27.17.55.05;	author fgsch;	state dead;
branches;
next	1.3;

1.3
date	2008.04.28.22.52.38;	author todd;	state Exp;
branches;
next	1.2;

1.2
date	2007.05.01.12.55.14;	author todd;	state Exp;
branches;
next	1.1;

1.1
date	2007.02.19.12.43.38;	author robert;	state Exp;
branches;
next	;


desc
@@


1.4
log
@Update to qemu 0.12.3. Work in progress so not linked to the tree yet.
@
text
@$OpenBSD: patch-cpu-all_h,v 1.3 2008/04/28 22:52:38 todd Exp $
--- cpu-all.h.orig	Sun Jan  6 14:38:42 2008
+++ cpu-all.h	Tue Apr  1 01:43:57 2008
@@@@ -1008,13 +1008,22 @@@@ static inline int64_t cpu_get_real_ticks(void)
 }
 
 #else
-/* The host CPU doesn't have an easily accessible cycle counter.
-   Just return a monotonically increasing value.  This will be
-   totally wrong, but hopefully better than nothing.  */
+# warning non-optimized CPU
+#include <sys/time.h>
+#include <time.h>
+
 static inline int64_t cpu_get_real_ticks (void)
 {
-    static int64_t ticks = 0;
-    return ticks++;
+    struct timeval tv;
+    static int64_t i = 0;
+    int64_t j;
+
+    gettimeofday(&tv, NULL);
+    do {
+        j = (tv.tv_sec * (uint64_t) 1000000) + tv.tv_usec;
+    } while (i == j);
+    i = j;
+    return j;
 }
 #endif
 
@


1.3
log
@o update to 0.9.1, lots from brad@@
o see http://qemu.org/changelog.html for details
o see README.OpenBSD for an intro to qemu on OpenBSD
o disable broken arm host support for now
@
text
@d1 1
a1 1
$OpenBSD: patch-cpu-all_h,v 1.2 2007/05/01 12:55:14 todd Exp $
@


1.2
log
@update to 0.9.0, thanks to all who gave feedback
see http://qemu.org/changelog.html for details
new in OpenBSD, support for raw block devices
@
text
@d1 4
a4 5
$OpenBSD$
--- cpu-all.h.orig	Mon Feb  5 17:01:54 2007
+++ cpu-all.h	Tue Apr  3 08:21:26 2007
@@@@ -1002,13 +1002,22 @@@@ static inline int64_t cpu_get_real_ticks (void)
 #endif
d6 1
d9 2
a10 2
-   Just return a monotonically increasing vlue.  This will be totally wrong,
-   but hopefully better than nothing.  */
d19 10
a28 10
+	struct timeval tv;
+	static int64_t i = 0;
+	int64_t j;
+        
+	gettimeofday(&tv, NULL);
+	do {
+	   j = (tv.tv_sec * (uint64_t) 1000000) + tv.tv_usec;
+	} while (i == j);
+	i = j;
+	return j;
@


1.1
log
@- allow building on armish
- fix the build on the arm architecture by moving the cpu_get_real_ticks()
function for non-optimized to the correct place
- add correct REGRESS_TARGET even if the regressions tests are utterly broken
- bump PKGNAME
@
text
@d2 3
a4 4
--- cpu-all.h.orig	Mon Feb 19 10:54:26 2007
+++ cpu-all.h	Mon Feb 19 10:56:42 2007
@@@@ -992,6 +992,24 @@@@ static inline int64_t cpu_get_real_ticks
         return rval.i64;
d7 4
a10 1
+#else
d15 4
a18 2
+static inline int64_t cpu_get_real_ticks (void)
+{
d29 1
a29 1
+}
a31 1
 /* profiling */
@

