head	1.3;
access;
symbols
	OPENBSD_5_9:1.2.0.2
	OPENBSD_5_9_BASE:1.2
	OPENBSD_5_8:1.1.0.2;
locks; strict;
comment	@# @;


1.3
date	2016.03.14.19.46.12;	author ajacoutot;	state dead;
branches;
next	1.2;
commitid	ZypCecrzOxeE8g1E;

1.2
date	2016.01.05.06.56.12;	author ajacoutot;	state Exp;
branches;
next	1.1;
commitid	z2cMvU8TlZZSH8m0;

1.1
date	2015.12.16.06.41.06;	author ajacoutot;	state Exp;
branches
	1.1.2.1;
next	;
commitid	Mr3TINbPs4mSz43P;

1.1.2.1
date	2015.12.24.09.44.36;	author jasper;	state Exp;
branches;
next	1.1.2.2;
commitid	LotUrqm7umJtaB8C;

1.1.2.2
date	2016.01.07.10.27.40;	author jasper;	state Exp;
branches;
next	;
commitid	Ciob9S8eFBoLGbjT;


desc
@@


1.3
log
@Major update to qemu-2.5.0.
Please direct any runtime fallout to Brad.

from Brad (maintainer)
@
text
@$OpenBSD: patch-hw_net_vmxnet3_c,v 1.2 2016/01/05 06:56:12 ajacoutot Exp $

net: vmxnet3: avoid memory leakage in activate_device

Vmxnet3 device emulator does not check if the device is active
before activating it, also it did not free the transmit & receive
buffers while deactivating the device, thus resulting in memory
leakage on the host. This patch fixes both these issues to avoid
host memory leakage.

CVE-2015-8567 and CVE-2015-8568

net/vmxnet3: Refine l2 header validation

Validation of l2 header length assumed minimal packet size as
eth_header + 2 * vlan_header regardless of the actual protocol.

This caused crash for valid non-IP packets shorter than 22 bytes, as
'tx_pkt->packet_type' hasn't been assigned for such packets, and
'vmxnet3_on_tx_done_update_stats()' expects it to be properly set.

Refine header length validation in 'vmxnet_tx_pkt_parse_headers'.
Check its return value during packet processing flow.

As a side effect, in case IPv4 and IPv6 header validation failure,
corrupt packets will be dropped.

CVE-2015-8744

vmxnet3: Support reading IMR registers on bar0

Instead of asserting, return the actual IMR register value.
This is aligned with what's returned on ESXi.

CVE-2015-8745

--- hw/net/vmxnet3.c.orig	Tue Mar 10 13:38:27 2015
+++ hw/net/vmxnet3.c	Mon Jan  4 20:10:57 2016
@@@@ -729,9 +729,7 @@@@ static void vmxnet3_process_tx_queue(VMXNET3State *s, 
         }
 
         if (txd.eop) {
-            if (!s->skip_current_tx_pkt) {
-                vmxnet_tx_pkt_parse(s->tx_pkt);
-
+            if (!s->skip_current_tx_pkt && vmxnet_tx_pkt_parse(s->tx_pkt)) {
                 if (s->needs_vlan) {
                     vmxnet_tx_pkt_setup_vlan_header(s->tx_pkt, s->tci);
                 }
@@@@ -1108,9 +1106,13 @@@@ vmxnet3_io_bar0_write(void *opaque, hwaddr addr,
 static uint64_t
 vmxnet3_io_bar0_read(void *opaque, hwaddr addr, unsigned size)
 {
+    VMXNET3State *s = opaque;
+
     if (VMW_IS_MULTIREG_ADDR(addr, VMXNET3_REG_IMR,
                         VMXNET3_MAX_INTRS, VMXNET3_REG_ALIGN)) {
-        g_assert_not_reached();
+        int l = VMW_MULTIREG_IDX_BY_ADDR(addr, VMXNET3_REG_IMR,
+                                         VMXNET3_REG_ALIGN);
+        return s->interrupt_states[l].is_masked;
     }
 
     VMW_CBPRN("BAR0 unknown read [%" PRIx64 "], size %d", addr, size);
@@@@ -1135,8 +1137,13 @@@@ static void vmxnet3_reset_mac(VMXNET3State *s)
 
 static void vmxnet3_deactivate_device(VMXNET3State *s)
 {
-    VMW_CBPRN("Deactivating vmxnet3...");
-    s->device_active = false;
+    if (s->device_active) {
+        VMW_CBPRN("Deactivating vmxnet3...");
+        vmxnet_tx_pkt_reset(s->tx_pkt);
+        vmxnet_tx_pkt_uninit(s->tx_pkt);
+        vmxnet_rx_pkt_uninit(s->rx_pkt);
+        s->device_active = false;
+    }
 }
 
 static void vmxnet3_reset(VMXNET3State *s)
@@@@ -1145,7 +1152,6 @@@@ static void vmxnet3_reset(VMXNET3State *s)
 
     vmxnet3_deactivate_device(s);
     vmxnet3_reset_interrupt_states(s);
-    vmxnet_tx_pkt_reset(s->tx_pkt);
     s->drv_shmem = 0;
     s->tx_sop = true;
     s->skip_current_tx_pkt = false;
@@@@ -1368,6 +1374,12 @@@@ static void vmxnet3_activate_device(VMXNET3State *s)
         return;
     }
 
+    /* Verify if device is active */
+    if (s->device_active) {
+        VMW_CFPRN("Vmxnet3 device is active");
+        return;
+    }
+
     vmxnet3_adjust_by_guest_type(s);
     vmxnet3_update_features(s);
     vmxnet3_update_pm_state(s);
@@@@ -1564,7 +1576,7 @@@@ static void vmxnet3_handle_command(VMXNET3State *s, ui
         break;
 
     case VMXNET3_CMD_QUIESCE_DEV:
-        VMW_CBPRN("Set: VMXNET3_CMD_QUIESCE_DEV - pause the device");
+        VMW_CBPRN("Set: VMXNET3_CMD_QUIESCE_DEV - deactivate the device");
         vmxnet3_deactivate_device(s);
         break;
 
@@@@ -1669,7 +1681,7 @@@@ vmxnet3_io_bar1_write(void *opaque,
          * shared address only after we get the high part
          */
         if (val == 0) {
-            s->device_active = false;
+            vmxnet3_deactivate_device(s);
         }
         s->temp_shared_guest_driver_memory = val;
         s->drv_shmem = 0;
@@@@ -1956,9 +1968,7 @@@@ static bool vmxnet3_peer_has_vnet_hdr(VMXNET3State *s)
 static void vmxnet3_net_uninit(VMXNET3State *s)
 {
     g_free(s->mcast_list);
-    vmxnet_tx_pkt_reset(s->tx_pkt);
-    vmxnet_tx_pkt_uninit(s->tx_pkt);
-    vmxnet_rx_pkt_uninit(s->rx_pkt);
+    vmxnet3_deactivate_device(s);
     qemu_del_nic(s->nic);
 }
 
@


1.2
log
@SECURITY fixes for:
CVE-2015-8619, CVE-2015-8666, CVE-2015-8743, CVE-2015-8744, and CVE-2015-8745

from Brad (maintainer)
@
text
@d1 1
a1 1
$OpenBSD: patch-hw_net_vmxnet3_c,v 1.1 2015/12/16 06:41:06 ajacoutot Exp $
@


1.1
log
@SECURITY fixes for:
CVE-2015-7549, CVE-2015-8504, CVE-2015-8558, CVE-2015-8567 and CVE-2015-8568

from Brad (maintainer)
@
text
@d1 1
a1 1
$OpenBSD$
d13 24
d38 28
a65 2
+++ hw/net/vmxnet3.c	Tue Dec 15 20:42:02 2015
@@@@ -1135,8 +1135,13 @@@@ static void vmxnet3_reset_mac(VMXNET3State *s)
d81 1
a81 1
@@@@ -1145,7 +1150,6 @@@@ static void vmxnet3_reset(VMXNET3State *s)
d89 1
a89 1
@@@@ -1368,6 +1372,12 @@@@ static void vmxnet3_activate_device(VMXNET3State *s)
d102 1
a102 1
@@@@ -1564,7 +1574,7 @@@@ static void vmxnet3_handle_command(VMXNET3State *s, ui
d111 1
a111 1
@@@@ -1669,7 +1679,7 @@@@ vmxnet3_io_bar1_write(void *opaque,
d120 1
a120 1
@@@@ -1956,9 +1966,7 @@@@ static bool vmxnet3_peer_has_vnet_hdr(VMXNET3State *s)
@


1.1.2.1
log
@missed in previous
@
text
@d1 1
a1 1
$OpenBSD: patch-hw_net_vmxnet3_c,v 1.1 2015/12/16 06:41:06 ajacoutot Exp $
@


1.1.2.2
log
@SECURITY fixes for:
CVE-2015-8619, CVE-2015-8666, CVE-2015-8743, CVE-2015-8744, and CVE-2015-8745
@
text
@d1 1
a1 1
$OpenBSD: patch-hw_net_vmxnet3_c,v 1.2 2016/01/05 06:56:12 ajacoutot Exp $
a12 24
net/vmxnet3: Refine l2 header validation

Validation of l2 header length assumed minimal packet size as
eth_header + 2 * vlan_header regardless of the actual protocol.

This caused crash for valid non-IP packets shorter than 22 bytes, as
'tx_pkt->packet_type' hasn't been assigned for such packets, and
'vmxnet3_on_tx_done_update_stats()' expects it to be properly set.

Refine header length validation in 'vmxnet_tx_pkt_parse_headers'.
Check its return value during packet processing flow.

As a side effect, in case IPv4 and IPv6 header validation failure,
corrupt packets will be dropped.

CVE-2015-8744

vmxnet3: Support reading IMR registers on bar0

Instead of asserting, return the actual IMR register value.
This is aligned with what's returned on ESXi.

CVE-2015-8745

d14 2
a15 28
+++ hw/net/vmxnet3.c	Mon Jan  4 20:10:57 2016
@@@@ -729,9 +729,7 @@@@ static void vmxnet3_process_tx_queue(VMXNET3State *s, 
         }
 
         if (txd.eop) {
-            if (!s->skip_current_tx_pkt) {
-                vmxnet_tx_pkt_parse(s->tx_pkt);
-
+            if (!s->skip_current_tx_pkt && vmxnet_tx_pkt_parse(s->tx_pkt)) {
                 if (s->needs_vlan) {
                     vmxnet_tx_pkt_setup_vlan_header(s->tx_pkt, s->tci);
                 }
@@@@ -1108,9 +1106,13 @@@@ vmxnet3_io_bar0_write(void *opaque, hwaddr addr,
 static uint64_t
 vmxnet3_io_bar0_read(void *opaque, hwaddr addr, unsigned size)
 {
+    VMXNET3State *s = opaque;
+
     if (VMW_IS_MULTIREG_ADDR(addr, VMXNET3_REG_IMR,
                         VMXNET3_MAX_INTRS, VMXNET3_REG_ALIGN)) {
-        g_assert_not_reached();
+        int l = VMW_MULTIREG_IDX_BY_ADDR(addr, VMXNET3_REG_IMR,
+                                         VMXNET3_REG_ALIGN);
+        return s->interrupt_states[l].is_masked;
     }
 
     VMW_CBPRN("BAR0 unknown read [%" PRIx64 "], size %d", addr, size);
@@@@ -1135,8 +1137,13 @@@@ static void vmxnet3_reset_mac(VMXNET3State *s)
d31 1
a31 1
@@@@ -1145,7 +1152,6 @@@@ static void vmxnet3_reset(VMXNET3State *s)
d39 1
a39 1
@@@@ -1368,6 +1374,12 @@@@ static void vmxnet3_activate_device(VMXNET3State *s)
d52 1
a52 1
@@@@ -1564,7 +1576,7 @@@@ static void vmxnet3_handle_command(VMXNET3State *s, ui
d61 1
a61 1
@@@@ -1669,7 +1681,7 @@@@ vmxnet3_io_bar1_write(void *opaque,
d70 1
a70 1
@@@@ -1956,9 +1968,7 @@@@ static bool vmxnet3_peer_has_vnet_hdr(VMXNET3State *s)
@


