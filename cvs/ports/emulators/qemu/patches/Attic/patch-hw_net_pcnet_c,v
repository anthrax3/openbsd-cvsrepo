head	1.3;
access;
symbols
	OPENBSD_5_9:1.2.0.2
	OPENBSD_5_9_BASE:1.2
	OPENBSD_5_8:1.1.0.6
	OPENBSD_5_8_BASE:1.1
	OPENBSD_5_7:1.1.0.2;
locks; strict;
comment	@# @;


1.3
date	2016.03.14.19.46.12;	author ajacoutot;	state dead;
branches;
next	1.2;
commitid	ZypCecrzOxeE8g1E;

1.2
date	2015.12.08.06.55.13;	author ajacoutot;	state Exp;
branches;
next	1.1;
commitid	9Su6avHi3SEMpjSH;

1.1
date	2015.07.18.20.36.57;	author sthen;	state Exp;
branches
	1.1.2.1
	1.1.6.1;
next	;
commitid	fLpBoZoLY5S7yyUx;

1.1.2.1
date	2015.07.18.20.38.02;	author sthen;	state Exp;
branches;
next	;
commitid	iiChQZHRvFg0LFK5;

1.1.6.1
date	2015.12.09.10.42.58;	author jasper;	state Exp;
branches;
next	;
commitid	v3AIAVQ5v2HwniSB;


desc
@@


1.3
log
@Major update to qemu-2.5.0.
Please direct any runtime fallout to Brad.

from Brad (maintainer)
@
text
@$OpenBSD: patch-hw_net_pcnet_c,v 1.2 2015/12/08 06:55:13 ajacoutot Exp $

pcnet: force the buffer access to be in bounds during tx

4096 is the maximum length per TMD and it is also currently the size of
the relay buffer pcnet driver uses for sending the packet data to QEMU
for further processing. With packet spanning multiple TMDs it can
happen that the overall packet size will be bigger than sizeof(buffer),
which results in memory corruption.

Fix this by only allowing to queue maximum sizeof(buffer) bytes.

CVE-2015-3209

pcnet: add check to validate receive data size(CVE-2015-7504)

In loopback mode, pcnet_receive routine appends CRC code to the
receive buffer. If the data size given is same as the buffer size,
the appended CRC code overwrites 4 bytes after s->buffer. Added a
check to avoid that.

pcnet: fix rx buffer overflow(CVE-2015-7512)

Backends could provide a packet whose length is greater than buffer
size. Check for this and truncate the packet to avoid rx buffer
overflow in this case.

--- hw/net/pcnet.c.orig	Tue Mar 10 13:38:27 2015
+++ hw/net/pcnet.c	Mon Dec  7 21:10:23 2015
@@@@ -1086,6 +1086,12 @@@@ ssize_t pcnet_receive(NetClientState *nc, const uint8_
             int pktcount = 0;
 
             if (!s->looptest) {
+                if (size > 4092) {
+#ifdef PCNET_DEBUG_RMD
+                    fprintf(stderr, "pcnet: truncates rx packet.\n");
+#endif
+                    size = 4092;
+                }
                 memcpy(src, buf, size);
                 /* no need to compute the CRC */
                 src[size] = 0;
@@@@ -1106,7 +1112,7 @@@@ ssize_t pcnet_receive(NetClientState *nc, const uint8_
                 uint32_t fcs = ~0;
                 uint8_t *p = src;
 
-                while (p != &src[size-4])
+                while (p != &src[size])
                     CRC(fcs, *p++);
                 crc_err = (*(uint32_t *)p != htonl(fcs));
             }
@@@@ -1253,6 +1259,16 @@@@ static void pcnet_transmit(PCNetState *s)
         }
 
         bcnt = 4096 - GET_FIELD(tmd.length, TMDL, BCNT);
+
+        /* if multi-tmd packet outsizes s->buffer then skip it silently.
+         * Note: this is not what real hw does.
+         * Last four bytes of s->buffer are used to store CRC FCS code.
+         */
+        if (s->xmit_pos + bcnt > sizeof(s->buffer) - 4) {
+            s->xmit_pos = -1;
+            goto txdone;
+        }
+
         s->phys_mem_read(s->dma_opaque, PHYSADDR(s, tmd.tbadr),
                          s->buffer + s->xmit_pos, bcnt, CSR_BSWP(s));
         s->xmit_pos += bcnt;
@


1.2
log
@SECURITY fixes for CVE-2015-7504, CVE-2015-7512, CVE-2015-8345.

from Brad (maintainer)
@
text
@d1 1
a1 1
$OpenBSD: patch-hw_net_pcnet_c,v 1.1 2015/07/18 20:36:57 sthen Exp $
@


1.1
log
@Security fixes for qemu, from brad:


CVE-2015-3456  fdc: force the fifo access to be in bounds of the allocated buffer

During processing of certain commands such as FD_CMD_READ_ID and
FD_CMD_DRIVE_SPECIFICATION_COMMAND the fifo memory access could
get out of bounds leading to memory corruption with values coming
from the guest.

Fix this by making sure that the index is always bounded by the
allocated memory.


CVE-2015-3209  pcnet: force the buffer access to be in bounds during tx

4096 is the maximum length per TMD and it is also currently the size of
the relay buffer pcnet driver uses for sending the packet data to QEMU
for further processing. With packet spanning multiple TMDs it can
happen that the overall packet size will be bigger than sizeof(buffer),
which results in memory corruption.

Fix this by only allowing to queue maximum sizeof(buffer) bytes.
@
text
@d1 1
a1 1
$OpenBSD$
d15 38
a52 3
--- hw/net/pcnet.c.orig	Tue Jul 14 19:08:19 2015
+++ hw/net/pcnet.c	Tue Jul 14 19:10:19 2015
@@@@ -1253,6 +1253,14 @@@@ static void pcnet_transmit(PCNetState *s)
d58 4
a61 2
+           Note: this is not what real hw does */
+        if (s->xmit_pos + bcnt > sizeof(s->buffer)) {
@


1.1.6.1
log
@SECURITY fixes for CVE-2015-7504, CVE-2015-7512, CVE-2015-8345.
@
text
@d1 1
a1 1
$OpenBSD: patch-hw_net_pcnet_c,v 1.2 2015/12/08 06:55:13 ajacoutot Exp $
d15 3
a17 38
pcnet: add check to validate receive data size(CVE-2015-7504)

In loopback mode, pcnet_receive routine appends CRC code to the
receive buffer. If the data size given is same as the buffer size,
the appended CRC code overwrites 4 bytes after s->buffer. Added a
check to avoid that.

pcnet: fix rx buffer overflow(CVE-2015-7512)

Backends could provide a packet whose length is greater than buffer
size. Check for this and truncate the packet to avoid rx buffer
overflow in this case.

--- hw/net/pcnet.c.orig	Tue Mar 10 13:38:27 2015
+++ hw/net/pcnet.c	Mon Dec  7 21:10:23 2015
@@@@ -1086,6 +1086,12 @@@@ ssize_t pcnet_receive(NetClientState *nc, const uint8_
             int pktcount = 0;
 
             if (!s->looptest) {
+                if (size > 4092) {
+#ifdef PCNET_DEBUG_RMD
+                    fprintf(stderr, "pcnet: truncates rx packet.\n");
+#endif
+                    size = 4092;
+                }
                 memcpy(src, buf, size);
                 /* no need to compute the CRC */
                 src[size] = 0;
@@@@ -1106,7 +1112,7 @@@@ ssize_t pcnet_receive(NetClientState *nc, const uint8_
                 uint32_t fcs = ~0;
                 uint8_t *p = src;
 
-                while (p != &src[size-4])
+                while (p != &src[size])
                     CRC(fcs, *p++);
                 crc_err = (*(uint32_t *)p != htonl(fcs));
             }
@@@@ -1253,6 +1259,16 @@@@ static void pcnet_transmit(PCNetState *s)
d23 2
a24 4
+         * Note: this is not what real hw does.
+         * Last four bytes of s->buffer are used to store CRC FCS code.
+         */
+        if (s->xmit_pos + bcnt > sizeof(s->buffer) - 4) {
@


1.1.2.1
log
@MFC Security fixes for qemu, from brad:

CVE-2015-3456 fdc: force the fifo access to be in bounds of the allocated buffer

During processing of certain commands such as FD_CMD_READ_ID and
FD_CMD_DRIVE_SPECIFICATION_COMMAND the fifo memory access could
get out of bounds leading to memory corruption with values coming
from the guest.

Fix this by making sure that the index is always bounded by the
allocated memory.

CVE-2015-3209  pcnet: force the buffer access to be in bounds during tx

4096 is the maximum length per TMD and it is also currently the size of
the relay buffer pcnet driver uses for sending the packet data to QEMU
for further processing. With packet spanning multiple TMDs it can
happen that the overall packet size will be bigger than sizeof(buffer),
which results in memory corruption.

Fix this by only allowing to queue maximum sizeof(buffer) bytes.
@
text
@@

