head	1.3;
access;
symbols
	OPENBSD_4_7:1.2.0.36
	OPENBSD_4_7_BASE:1.2
	OPENBSD_4_6:1.2.0.34
	OPENBSD_4_6_BASE:1.2
	OPENBSD_4_5:1.2.0.32
	OPENBSD_4_5_BASE:1.2
	OPENBSD_4_4:1.2.0.30
	OPENBSD_4_4_BASE:1.2
	OPENBSD_4_3:1.2.0.28
	OPENBSD_4_3_BASE:1.2
	OPENBSD_4_2:1.2.0.26
	OPENBSD_4_2_BASE:1.2
	OPENBSD_4_1:1.2.0.24
	OPENBSD_4_1_BASE:1.2
	OPENBSD_4_0:1.2.0.22
	OPENBSD_4_0_BASE:1.2
	OPENBSD_3_9:1.2.0.20
	OPENBSD_3_9_BASE:1.2
	OPENBSD_3_8:1.2.0.18
	OPENBSD_3_8_BASE:1.2
	OPENBSD_3_7:1.2.0.16
	OPENBSD_3_7_BASE:1.2
	OPENBSD_3_6:1.2.0.14
	OPENBSD_3_6_BASE:1.2
	OPENBSD_3_5:1.2.0.12
	OPENBSD_3_5_BASE:1.2
	OPENBSD_3_4:1.2.0.10
	OPENBSD_3_4_BASE:1.2
	OPENBSD_3_3:1.2.0.8
	OPENBSD_3_3_BASE:1.2
	OPENBSD_3_2:1.2.0.6
	OPENBSD_3_2_BASE:1.2
	OPENBSD_3_1:1.2.0.4
	OPENBSD_3_1_BASE:1.2
	OPENBSD_3_0:1.2.0.2
	OPENBSD_3_0_BASE:1.2
	OPENBSD_2_9_TRACKING_SWITCH:1.2
	OPENBSD_2_9:1.1.0.6
	OPENBSD_2_9_BASE:1.1
	OPENBSD_2_8:1.1.0.4
	OPENBSD_2_8_BASE:1.1
	OPENBSD_2_7:1.1.0.2;
locks; strict;
comment	@# @;


1.3
date	2010.06.30.22.25.57;	author jakemsr;	state dead;
branches;
next	1.2;

1.2
date	2001.08.16.13.17.09;	author espie;	state Exp;
branches;
next	1.1;

1.1
date	2000.07.10.17.08.15;	author espie;	state Exp;
branches;
next	;


desc
@@


1.3
log
@convert to sndio(7), regen patches, @@bin markers
maintainer timeout
@
text
@/*
 * SID emulation, OpenBSD flavor
 *
 *  Written by Marc Espie in 2000, based on SUN version.
 */

extern "C" {
	#include <sys/audioio.h>
	#include <unistd.h>
	#include <sys/ioctl.h>
	#include "VIC.h"
}

#define FRAGSIZE (SAMPLE_FREQ/CALC_FREQ)  // samples in a fragment
#define MAXBUFFERED (2*FRAGSIZE) // allow ourselves a little buffering

void DigitalRenderer::init_sound(void)
{
	ready = false;
 
 	fd = open("/dev/audio", O_WRONLY, 0);
	if (fd == -1) {
		fprintf(stderr, "SID_OpenBSD: unable to open /dev/audio\n");
		return;
	}
	
	struct audio_info info;

	AUDIO_INITINFO(&info);
	info.play.sample_rate = SAMPLE_FREQ;
	info.play.channels = 1;
	info.play.precision = 16;
	info.play.encoding = AUDIO_ENCODING_LINEAR;
	info.hiwat = 6;
	info.lowat = 1;

	if (ioctl(fd, AUDIO_SETINFO, &info) != 0) {
    		fprintf(stderr,
		    "SID_OpenBSD : unable to select 16 bits/%d khz linear encoding.\n",
		    SAMPLE_FREQ);
		close(fd);
		return;
	} else {
		fprintf(stderr,
		    "SID_OpenBSD : selecting 16 bits/%d khz linear encoding.\n",
		    SAMPLE_FREQ);
	}

	sound_calc_buf = new int16[FRAGSIZE];
	ready = true;
}


DigitalRenderer::~DigitalRenderer()
{
	if (ready) {
		delete [] sound_calc_buf;
	      	ioctl(fd, AUDIO_DRAIN);
	      	close(fd);
	}
}


void DigitalRenderer::Pause(void)
{
}


void DigitalRenderer::Resume(void)
{
}

void DigitalRenderer::EmulateLine(void)
{
	static int divisor = 0;
	static int to_output = 0;

	sample_buf[sample_in_ptr] = volume;
	sample_in_ptr = (sample_in_ptr + 1) % SAMPLE_BUF_SIZE;

	divisor += SAMPLE_FREQ;
 	while (divisor >= 0)
    		divisor -= TOTAL_RASTERS*SCREEN_FREQ, to_output++;
	if (!ready)
		return;

 	while (to_output >= FRAGSIZE) {
    		calc_buffer(sound_calc_buf, FRAGSIZE*2);
		// Ignore the return code, what are we going to do if
		// the write fails anyway ?
    		(void)write (fd,sound_calc_buf, FRAGSIZE*2);
		to_output -= FRAGSIZE;
      }	
}
@


1.2
log
@Better real-time sound.
@
text
@@


1.1
log
@Sound support
@
text
@d34 2
a35 2
	info.hiwat = MAXBUFFERED;
	info.lowat = FRAGSIZE;
@

