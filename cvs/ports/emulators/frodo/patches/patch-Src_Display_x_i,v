head	1.4;
access;
symbols
	OPENBSD_6_0:1.4.0.26
	OPENBSD_6_0_BASE:1.4
	OPENBSD_5_9:1.4.0.22
	OPENBSD_5_9_BASE:1.4
	OPENBSD_5_8:1.4.0.24
	OPENBSD_5_8_BASE:1.4
	OPENBSD_5_7:1.4.0.20
	OPENBSD_5_7_BASE:1.4
	OPENBSD_5_6:1.4.0.18
	OPENBSD_5_6_BASE:1.4
	OPENBSD_5_5:1.4.0.16
	OPENBSD_5_5_BASE:1.4
	OPENBSD_5_4:1.4.0.14
	OPENBSD_5_4_BASE:1.4
	OPENBSD_5_3:1.4.0.12
	OPENBSD_5_3_BASE:1.4
	OPENBSD_5_2:1.4.0.10
	OPENBSD_5_2_BASE:1.4
	OPENBSD_5_1_BASE:1.4
	OPENBSD_5_1:1.4.0.8
	OPENBSD_5_0:1.4.0.6
	OPENBSD_5_0_BASE:1.4
	OPENBSD_4_9:1.4.0.4
	OPENBSD_4_9_BASE:1.4
	OPENBSD_4_8:1.4.0.2
	OPENBSD_4_8_BASE:1.4
	OPENBSD_4_7:1.3.0.34
	OPENBSD_4_7_BASE:1.3
	OPENBSD_4_6:1.3.0.32
	OPENBSD_4_6_BASE:1.3
	OPENBSD_4_5:1.3.0.30
	OPENBSD_4_5_BASE:1.3
	OPENBSD_4_4:1.3.0.28
	OPENBSD_4_4_BASE:1.3
	OPENBSD_4_3:1.3.0.26
	OPENBSD_4_3_BASE:1.3
	OPENBSD_4_2:1.3.0.24
	OPENBSD_4_2_BASE:1.3
	OPENBSD_4_1:1.3.0.22
	OPENBSD_4_1_BASE:1.3
	OPENBSD_4_0:1.3.0.20
	OPENBSD_4_0_BASE:1.3
	OPENBSD_3_9:1.3.0.18
	OPENBSD_3_9_BASE:1.3
	OPENBSD_3_8:1.3.0.16
	OPENBSD_3_8_BASE:1.3
	OPENBSD_3_7:1.3.0.14
	OPENBSD_3_7_BASE:1.3
	OPENBSD_3_6:1.3.0.12
	OPENBSD_3_6_BASE:1.3
	OPENBSD_3_5:1.3.0.10
	OPENBSD_3_5_BASE:1.3
	OPENBSD_3_4:1.3.0.8
	OPENBSD_3_4_BASE:1.3
	OPENBSD_3_3:1.3.0.6
	OPENBSD_3_3_BASE:1.3
	OPENBSD_3_2:1.3.0.4
	OPENBSD_3_2_BASE:1.3
	OPENBSD_3_1:1.3.0.2
	OPENBSD_3_1_BASE:1.3
	OPENBSD_3_0:1.2.0.4
	OPENBSD_3_0_BASE:1.2
	OPENBSD_2_9_TRACKING_SWITCH:1.2
	OPENBSD_2_9:1.2.0.2
	OPENBSD_2_9_BASE:1.2;
locks; strict;
comment	@# @;


1.4
date	2010.06.30.22.25.57;	author jakemsr;	state Exp;
branches;
next	1.3;

1.3
date	2002.03.22.00.23.24;	author espie;	state Exp;
branches;
next	1.2;

1.2
date	2001.02.06.22.40.17;	author espie;	state Exp;
branches;
next	1.1;

1.1
date	2001.01.13.20.55.59;	author espie;	state Exp;
branches;
next	;


desc
@@


1.4
log
@convert to sndio(7), regen patches, @@bin markers
maintainer timeout
@
text
@$OpenBSD: patch-Src_Display_x_i,v 1.3 2002/03/22 00:23:24 espie Exp $
--- Src/Display_x.i.orig	Wed Jan  2 13:17:29 2002
+++ Src/Display_x.i	Thu Jan 14 08:50:09 2010
@@@@ -4,6 +4,7 @@@@
  *
  *  Frodo (C) 1994-1997,2002 Christian Bauer
  *  X11 stuff by Bernd Schmidt/Lutz Vieweg
+ *  Support for visuals >8 bits by Michael Krause and Marc Espie
  */
 
 #include "SAM.h"
@@@@ -34,7 +35,9 @@@@ static XImage *img;
 static Visual *vis;
 static XVisualInfo visualInfo;
 static int bitdepth;
-static char *bufmem;
+static char *bufmem, *bufmem8;
+static uint32 trans[1<<12];
+static uint32 eight2thirtytwo[16];
 static int hsize;
 
 // For LED error blinking
@@@@ -392,7 +395,7 @@@@ int init_graphics(void)
 	vis = visualInfo.visual;
 	bitdepth = visualInfo.depth;
 	pixbytes = (bitdepth == 24 || bitdepth == 32 ? 4 : bitdepth == 12 || bitdepth == 16 ? 2 : 1);
-	fprintf(stderr, "Using %d bit visual\n", bitdepth);
+	fprintf(stderr, "Using %d bit visual%s", bitdepth, bitdepth>8 ? " - please use 8 bits for highest performance!\n" : "\n");
 
 	hsize = (DISPLAY_X + 3) & ~3;
 
@@@@ -413,6 +416,10 @@@@ int init_graphics(void)
 	img = XCreateImage(display, vis, bitdepth, ZPixmap, 0, bufmem, hsize, DISPLAY_Y, 32, 0);
 #endif
 
+	if(bitdepth > 8) {
+	    bufmem8 = (char*)malloc(hsize * DISPLAY_Y);
+	}
+
 	cmap = XCreateColormap(display, rootwin, vis, AllocNone);
 
 	XParseColor(display, cmap, "#000000", &black);
@@@@ -478,6 +485,33 @@@@ void C64Display::Update(void)
 {
 	// Update C64 display
 	XSync(display, 0);
+
+	if(bitdepth == 16) {
+	    // Best thing would be to change
+	    // VIC.cpp so it could render directly into 16-bit or 32-bit
+	    // memory instead of into an 8-bit chunky buffer.
+	    uint16 *p = (uint16*)bufmem8, *x = p + hsize*DISPLAY_Y/2;
+	    uint32 *d = (uint32*)bufmem;
+	    while(p < x) {
+		*d++ = trans[*p++ & 0x0fff];
+	    }
+#if 0
+	    // Just a plain version. Might be necessary on non-i386
+	    // machines?
+	    uint8 *p = (uint8*)bufmem8, *x = p + hsize*DISPLAY_Y;
+	    uint16 *d = (uint16*)bufmem;
+	    while(p < x) {
+		*d++ = eight2sixteen[*p++];
+	    }
+#endif
+	} else if (bitdepth == 32 || bitdepth == 24) {
+	    uint8 *p = (uint8*)bufmem8, *x = p + hsize*DISPLAY_Y;
+	    uint32 *d = (uint32*)bufmem;
+	    while(p < x) {
+		*d++ = eight2thirtytwo[*p++];
+	    }
+    	}
+
 #if defined(X_USE_SHM)
 	XShmPutImage(display, mywin, black_gc, img, 0, 0, 0, 0, DISPLAY_X, DISPLAY_Y, 0);
 #else
@@@@ -560,7 +594,7 @@@@ void C64Display::Speedometer(int speed)
 
 uint8 *C64Display::BitmapBase(void)
 {
-	return (uint8 *)bufmem;
+	return (uint8*)(bitdepth>8 ? bufmem8 : bufmem);
 }
 
 
@@@@ -770,14 +804,32 @@@@ void C64Display::InitColors(uint8 *colors)
 	int i;
 	XColor col;
 	char str[20];
+	uint16 eight2sixteen[16];
 
 	for (i=0; i< 256; i++) {
+	    if(bitdepth == 16) {
+		colors[i] = i & 0x0f;
+		if(i < 16) {
+		    eight2sixteen[i] = ((uint16(palette_red[i]) << 8) & 0xf800) | ((uint16(palette_green[i]) << 3) & 0x07e0) | (palette_blue[i] >> 3);
+		}
+	    } else if(bitdepth == 32 || bitdepth == 24) {
+	    	colors[i] = i & 0x0f;
+		if(i <16) {
+		    eight2thirtytwo[i] = (uint32(palette_red[i]) << 16) | (uint32(palette_green[i]) << 8) | palette_blue[i];
+		}
+	    } else {
 		sprintf(str, "rgb:%x/%x/%x", palette_red[i & 0x0f], palette_green[i & 0x0f], palette_blue[i & 0x0f]);
 		XParseColor(display, cmap, str, &col);
 		if (XAllocColor(display, cmap, &col))
 			colors[i] = col.pixel;
 		else
 			fprintf(stderr, "Couldn't get all colors\n");
+	    }
+	}
+
+	// Table to translate two 8-bit src -> two 16-bit dest
+	for(i=0; i<1<<12;i++) {
+	    trans[i] = eight2sixteen[i & 0x0f] | (eight2sixteen[i >> 8] << 16);
 	}
 }
 
@


1.3
log
@New frodo version, with SDL support. Runs at good speed on 24 bits display
now.
@
text
@d1 3
a3 3
$OpenBSD: patch-Src_Display_x_i,v 1.2 2001/02/06 22:40:17 espie Exp $
--- Src/Display_x.i.orig	Wed Jan  2 22:17:29 2002
+++ Src/Display_x.i	Thu Mar 14 01:48:46 2002
d86 1
a86 1
@@@@ -770,14 +804,32 @@@@ void C64Display::InitColors(uint8 *color
@


1.2
log
@Forgotten
@
text
@d1 3
a3 3
$OpenBSD: update-patches,v 1.3 2000/06/09 17:08:37 espie Exp $
--- Src/Display_x.i.orig	Wed Aug  6 20:56:26 1997
+++ Src/Display_x.i	Sun Jan 14 02:20:07 2001
d6 1
a6 1
  *  Frodo (C) 1994-1997 Christian Bauer
d11 2
a12 2
 #include "CmdPipe.h"
@@@@ -35,7 +36,9 @@@@ static XImage *img;
d23 1
a23 17
@@@@ -382,13 +385,10 @@@@ int init_graphics(void)
 
 	screen = XDefaultScreen(display);
 	rootwin = XRootWindow(display, screen);
-#if 0  
 	if (XMatchVisualInfo(display, screen, 16, TrueColor, &visualInfo)) {
+	} else if (XMatchVisualInfo(display, screen, 32, TrueColor, &visualInfo)) {
 	} else if (XMatchVisualInfo(display, screen, 24, TrueColor, &visualInfo)) {
-	} else 
-#endif
-	if (XMatchVisualInfo(display, screen, 8, PseudoColor, &visualInfo)) {
-		/* for our HP boxes */
+	} else if (XMatchVisualInfo(display, screen, 8, PseudoColor, &visualInfo)) {
 	} else if (XMatchVisualInfo(display, screen, 8, GrayScale, &visualInfo)) {
 	} else {
 		fprintf(stderr, "Can't obtain appropriate X visual\n");
@@@@ -398,7 +398,7 @@@@ int init_graphics(void)
d32 1
a32 1
@@@@ -419,6 +419,10 @@@@ int init_graphics(void)
d43 1
a43 1
@@@@ -484,6 +488,33 @@@@ void C64Display::Update(void)
d77 1
a77 1
@@@@ -566,7 +597,7 @@@@ void C64Display::Speedometer(int speed)
d86 1
a86 1
@@@@ -776,14 +807,32 @@@@ void C64Display::InitColors(uint8 *color
@


1.1
log
@Replace distrib patch with an extended patch that also extends display
to 24 bits/32 bits X11. Some of us now have insanely fast machines on
which frodoSC still runs at 200% with single frames even with this.
@
text
@d1 3
a3 2
--- Src/Display_x.i.bak.orig	Wed Aug  6 20:56:26 1997
+++ Src/Display_x.i	Thu Jan 11 02:58:27 2001
@

