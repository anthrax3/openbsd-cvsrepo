head	1.1;
branch	1.1.1;
access;
symbols
	OPENBSD_6_2:1.1.1.1.0.4
	OPENBSD_6_2_BASE:1.1.1.1
	OPENBSD_6_1:1.1.1.1.0.2
	OPENBSD_6_1_BASE:1.1.1.1
	bentley_20160804:1.1.1.1
	bentley:1.1.1;
locks; strict;
comment	@# @;


1.1
date	2016.08.05.05.27.52;	author bentley;	state Exp;
branches
	1.1.1.1;
next	;
commitid	pX0CGIh4gs8FdFKA;

1.1.1.1
date	2016.08.05.05.27.52;	author bentley;	state Exp;
branches;
next	;
commitid	pX0CGIh4gs8FdFKA;


desc
@@



1.1
log
@Initial revision
@
text
@$OpenBSD$
--- retroarch.cfg.orig	Sat Jul 16 00:44:03 2016
+++ retroarch.cfg	Sat Jul 16 00:44:39 2016
@@@@ -35,7 +35,7 @@@@
 # libretro_path = "/path/to/libretro.so"
 
 # A directory for where to search for libretro core implementations.
-# libretro_directory =
+libretro_directory = "${PREFIX}/lib/libretro"
 
 # A directory for where to search for libretro core information.
 # libretro_info_path =
@


1.1.1.1
log
@Import retroarch-1.3.4.

RetroArch is the reference frontend for the libretro API. Popular examples
of implementations for this API includes videogame system emulators and game
engines, but also more generalized 3D programs. These programs are
instantiated as dynamic libraries, or "libretro cores".

libretro is an API that exposes generic audio/video/input callbacks. A
frontend for libretro (such as RetroArch) handles video output, audio
output, input and application lifecycle. A libretro core written in portable
C or C++ can run seamlessly on many platforms with very little/no porting
effort.

RetroArch attempts to be small and lean, while still having all the useful
core features expected from an emulator. It is designed to be very portable
and features a gamepad-centric UI. It also has a full-featured command-line
interface.

ok juanfra@@
@
text
@@
