head	1.2;
access;
symbols
	OPENBSD_6_1:1.1.1.1.0.64
	OPENBSD_6_1_BASE:1.1.1.1
	OPENBSD_6_0:1.1.1.1.0.62
	OPENBSD_6_0_BASE:1.1.1.1
	OPENBSD_5_9:1.1.1.1.0.58
	OPENBSD_5_9_BASE:1.1.1.1
	OPENBSD_5_8:1.1.1.1.0.60
	OPENBSD_5_8_BASE:1.1.1.1
	OPENBSD_5_7:1.1.1.1.0.56
	OPENBSD_5_7_BASE:1.1.1.1
	OPENBSD_5_6:1.1.1.1.0.54
	OPENBSD_5_6_BASE:1.1.1.1
	OPENBSD_5_5:1.1.1.1.0.52
	OPENBSD_5_5_BASE:1.1.1.1
	OPENBSD_5_4:1.1.1.1.0.50
	OPENBSD_5_4_BASE:1.1.1.1
	OPENBSD_5_3:1.1.1.1.0.48
	OPENBSD_5_3_BASE:1.1.1.1
	OPENBSD_5_2:1.1.1.1.0.46
	OPENBSD_5_2_BASE:1.1.1.1
	OPENBSD_5_1_BASE:1.1.1.1
	OPENBSD_5_1:1.1.1.1.0.44
	OPENBSD_5_0:1.1.1.1.0.42
	OPENBSD_5_0_BASE:1.1.1.1
	OPENBSD_4_9:1.1.1.1.0.40
	OPENBSD_4_9_BASE:1.1.1.1
	OPENBSD_4_8:1.1.1.1.0.38
	OPENBSD_4_8_BASE:1.1.1.1
	OPENBSD_4_7:1.1.1.1.0.36
	OPENBSD_4_7_BASE:1.1.1.1
	OPENBSD_4_6:1.1.1.1.0.34
	OPENBSD_4_6_BASE:1.1.1.1
	OPENBSD_4_5:1.1.1.1.0.32
	OPENBSD_4_5_BASE:1.1.1.1
	OPENBSD_4_4:1.1.1.1.0.30
	OPENBSD_4_4_BASE:1.1.1.1
	OPENBSD_4_3:1.1.1.1.0.28
	OPENBSD_4_3_BASE:1.1.1.1
	OPENBSD_4_2:1.1.1.1.0.26
	OPENBSD_4_2_BASE:1.1.1.1
	OPENBSD_4_1:1.1.1.1.0.24
	OPENBSD_4_1_BASE:1.1.1.1
	OPENBSD_4_0:1.1.1.1.0.22
	OPENBSD_4_0_BASE:1.1.1.1
	OPENBSD_3_9:1.1.1.1.0.20
	OPENBSD_3_9_BASE:1.1.1.1
	OPENBSD_3_8:1.1.1.1.0.18
	OPENBSD_3_8_BASE:1.1.1.1
	OPENBSD_3_7:1.1.1.1.0.16
	OPENBSD_3_7_BASE:1.1.1.1
	OPENBSD_3_6:1.1.1.1.0.14
	OPENBSD_3_6_BASE:1.1.1.1
	OPENBSD_3_5:1.1.1.1.0.12
	OPENBSD_3_5_BASE:1.1.1.1
	OPENBSD_3_4:1.1.1.1.0.10
	OPENBSD_3_4_BASE:1.1.1.1
	OPENBSD_3_3:1.1.1.1.0.8
	OPENBSD_3_3_BASE:1.1.1.1
	OPENBSD_3_2:1.1.1.1.0.6
	OPENBSD_3_2_BASE:1.1.1.1
	OPENBSD_3_1:1.1.1.1.0.4
	OPENBSD_3_1_BASE:1.1.1.1
	OPENBSD_3_0:1.1.1.1.0.2
	OPENBSD_3_0_BASE:1.1.1.1
	OPENBSD_2_9_TRACKING_SWITCH:1.1.1.1
	lebel_2001-Jul-04:1.1.1.1
	lebel:1.1.1;
locks; strict;
comment	@# @;


1.2
date	2017.04.25.15.47.41;	author espie;	state Exp;
branches;
next	1.1;
commitid	uObU41It3HeebJcJ;

1.1
date	2001.07.04.16.57.50;	author lebel;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2001.07.04.16.57.50;	author lebel;	state Exp;
branches;
next	;


desc
@@


1.2
log
@clang doesn't like int functions that don't return, but signal handlers
have returned void basically forever, so cut thru a bit of old-style cruft
so it compiles and runs more or less correctly (there's a shitload of stuff
happening in the handler... not my fight)

TODO: LINT_ARGS controls prototypes in externs.h... turning them on
triggers some issues with K&R vs ANSI in some functions.
@
text
@$OpenBSD: patch-source_signals_c,v 1.1.1.1 2001/07/04 16:57:50 lebel Exp $
--- source/signals.c.orig	Fri Jul 22 03:47:42 1994
+++ source/signals.c	Tue Apr 25 17:30:19 2017
@@@@ -88,27 +88,9 @@@@ static int error_sig = -1;
 static int signal_count = 0;
 
 /*ARGSUSED*/
-#ifndef USG
-#ifdef __386BSD__
-static void signal_handler(sig, code, scp)
-#else
-static int signal_handler(sig, code, scp)
-#endif
-int sig, code;
-struct sigcontext *scp;
-{
-  int smask;
-
-  smask = sigsetmask(0) | (1 << sig);
-#else
-#if defined(__TURBOC__) || defined(AMIGA)
 static void signal_handler(sig)
-#else
-static int signal_handler(sig)
-#endif
 int sig;
 {
-#endif
 
   if(error_sig >= 0)	/* Ignore all second signals. */
     {
@@@@ -136,11 +118,6 @@@@ int sig;
 	      erase_line(0, 0);
 	      put_qio();
 	      error_sig = -1;
-#ifdef USG
-	      (void) signal(sig, signal_handler);/* Have to restore handler. */
-#else
-	      (void) sigsetmask(smask);
-#endif
 	      /* in case control-c typed during msg_print */
 	      if (wait_for_more)
 		put_buffer(" -more-", MSG_LINE, 0);
@@@@ -177,13 +154,9 @@@@ int sig;
       (void) _save_char(savefile);	/* Quietly save the memory anyway. */
     }
   restore_term();
-#if !defined(MSDOS) && !defined(AMIGA) && !defined(ATARIST_TC)
   /* always generate a core dump */
   (void) signal(sig, SIG_DFL);
   (void) kill(getpid(), sig);
-  (void) sleep(5);
-#endif
-  exit(1);
 }
 
 #endif /* ATARIST_MWC, ATARIST_TC */
@


1.1
log
@Initial revision
@
text
@d1 29
a29 4
$OpenBSD$
--- source/signals.c.orig	Thu Jul 21 21:47:23 1994
+++ source/signals.c	Wed Jul  4 11:44:57 2001
@@@@ -113,7 +113,7 @@@@ int sig;
d32 2
a33 16
       if(++signal_count > 10)	/* Be safe. We will die if persistent enough. */
-	(void) signal(sig, SIG_DFL);
+	(void) signal(sig, (sig_t)SIG_DFL);
       return;
     }
   error_sig = sig;
@@@@ -126,7 +126,7 @@@@ int sig;
       )
     {
       if (death)
-	(void) signal(sig, SIG_IGN);		/* Can't quit after death. */
+	(void) signal(sig, (sig_t)SIG_IGN);		/* Can't quit after death. */
       else if (!character_saved && character_generated)
 	{
 	  if (!get_check("Really commit *Suicide*?"))
@@@@ -137,7 +137,7 @@@@ int sig;
d36 1
a36 1
 #ifdef USG
d38 9
a46 5
+	      (void) signal(sig, (sig_t)signal_handler);/* Have to restore handler. */
 #else
 	      (void) sigsetmask(smask);
 #endif
@@@@ -179,7 +179,7 @@@@ int sig;
d48 1
a48 1
 #if !defined(MSDOS) && !defined(AMIGA) && !defined(ATARIST_TC)
d50 1
a50 2
-  (void) signal(sig, SIG_DFL);
+  (void) signal(sig, (sig_t)SIG_DFL);
d52 4
a55 26
   (void) sleep(5);
 #endif
@@@@ -199,7 +199,7 @@@@ void nosignals()
 #if defined(atarist) && defined(__GNUC__)
   (void) signal(SIGTSTP, (__Sigfunc)SIG_IGN);
 #else
-  (void) signal(SIGTSTP, SIG_IGN);
+  (void) signal(SIGTSTP, (sig_t)SIG_IGN);
 #endif
 #ifndef USG
   mask = sigsetmask(0);
@@@@ -220,7 +220,7 @@@@ void signals()
 #ifdef  __386BSD__
   (void) signal(SIGTSTP, (sig_t)suspend);
 #else
-  (void) signal(SIGTSTP, suspend);
+  (void) signal(SIGTSTP, (sig_t)suspend);
 #endif
 #endif
 #ifndef USG
@@@@ -237,7 +237,7 @@@@ void init_signals()
 {
 #if !defined(ATARIST_MWC) && !defined(ATARIST_TC)
   /* No signals for Atari ST compiled with MWC or TC.  */
-  (void) signal(SIGINT, signal_handler);
+  (void) signal(SIGINT, (sig_t)signal_handler);
d57 1
a57 94
 #if defined(atarist) && defined(__GNUC__)
   /* Atari ST compiled with GNUC has most signals, but we need a cast
@@@@ -259,8 +259,8 @@@@ void init_signals()
 
 #else
   /* Everybody except the atari st.  */
-  (void) signal(SIGINT, signal_handler);
-  (void) signal(SIGFPE, signal_handler);
+  (void) signal(SIGINT, (sig_t)signal_handler);
+  (void) signal(SIGFPE, (sig_t)signal_handler);
 
 #if defined(MSDOS)
   /* many fewer signals under MSDOS */
@@@@ -278,27 +278,27 @@@@ void init_signals()
 
   /* Everybody except Atari, MSDOS, and Amiga.  */
   /* Ignore HANGUP, and let the EOF code take care of this case. */
-  (void) signal(SIGHUP, SIG_IGN);
-  (void) signal(SIGQUIT, signal_handler);
-  (void) signal(SIGILL, signal_handler);
-  (void) signal(SIGTRAP, signal_handler);
-  (void) signal(SIGIOT, signal_handler);
+  (void) signal(SIGHUP, (sig_t)SIG_IGN);
+  (void) signal(SIGQUIT, (sig_t)signal_handler);
+  (void) signal(SIGILL, (sig_t)signal_handler);
+  (void) signal(SIGTRAP, (sig_t)signal_handler);
+  (void) signal(SIGIOT, (sig_t)signal_handler);
 #ifdef SIGEMT  /* in BSD systems */
-  (void) signal(SIGEMT, signal_handler);
+  (void) signal(SIGEMT, (sig_t)signal_handler);
 #endif
 #ifdef SIGDANGER /* in SYSV systems */
   (void) signal(SIGDANGER, signal_handler);
 #endif
-  (void) signal(SIGKILL, signal_handler);
-  (void) signal(SIGBUS, signal_handler);
-  (void) signal(SIGSEGV, signal_handler);
+  (void) signal(SIGKILL, (sig_t)signal_handler);
+  (void) signal(SIGBUS, (sig_t)signal_handler);
+  (void) signal(SIGSEGV, (sig_t)signal_handler);
 #ifdef SIGSYS
-  (void) signal(SIGSYS, signal_handler);
+  (void) signal(SIGSYS, (sig_t)signal_handler);
 #endif
-  (void) signal(SIGTERM, signal_handler);
-  (void) signal(SIGPIPE, signal_handler);
+  (void) signal(SIGTERM, (sig_t)signal_handler);
+  (void) signal(SIGPIPE, (sig_t)signal_handler);
 #ifdef SIGXCPU	/* BSD */
-  (void) signal(SIGXCPU, signal_handler);
+  (void) signal(SIGXCPU, (sig_t)signal_handler);
 #endif
 #ifdef SIGPWR /* SYSV */
   (void) signal(SIGPWR, signal_handler);
@@@@ -312,9 +312,9 @@@@ void init_signals()
 void ignore_signals()
 {
 #if !defined(ATARIST_MWC)
-  (void) signal(SIGINT, SIG_IGN);
+  (void) signal(SIGINT, (sig_t)SIG_IGN);
 #ifdef SIGQUIT
-  (void) signal(SIGQUIT, SIG_IGN);
+  (void) signal(SIGQUIT, (sig_t)SIG_IGN);
 #endif
 #endif
 }
@@@@ -322,9 +322,9 @@@@ void ignore_signals()
 void default_signals()
 {
 #if !defined(ATARIST_MWC)
-  (void) signal(SIGINT, SIG_DFL);
+  (void) signal(SIGINT, (sig_t)SIG_DFL);
 #ifdef SIGQUIT
-  (void) signal(SIGQUIT, SIG_DFL);
+  (void) signal(SIGQUIT, (sig_t)SIG_DFL);
 #endif
 #endif
 }
@@@@ -335,13 +335,13 @@@@ void restore_signals()
 #if defined(atarist) && defined(__GNUC__)
   (void) signal(SIGINT, (__Sigfunc)signal_handler);
 #else
-  (void) signal(SIGINT, signal_handler);
+  (void) signal(SIGINT, (sig_t)signal_handler);
 #endif
 #ifdef SIGQUIT
 #if defined(atarist) && defined(__GNUC__)
   (void) signal(SIGQUIT, (__Sigfunc)signal_handler);
 #else
-  (void) signal(SIGQUIT, signal_handler);
+  (void) signal(SIGQUIT, (sig_t)signal_handler);
 #endif
 #endif
 #endif
@


1.1.1.1
log
@initial import of moria-5.5.2:
--
The game is set in Moria and the goal is to kill off the balrog.
Apart from this, the game is almost completely based on Dungeons &
Dragons. The game is a true classic and every true gamer should
have played it.

It was originally written by Robert Alan Koeneke with some help
from Jimmy Wayne Todd. Further development of the game has almost
ceased, but The Pits of Angband, which is based on its code, is
still very much in development.

WWW: http://www-math.bgsu.edu/~grabine/moria.html

@
text
@@
