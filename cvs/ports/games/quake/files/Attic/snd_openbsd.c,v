head	1.2;
access;
symbols
	OPENBSD_4_7:1.1.1.1.0.36
	OPENBSD_4_7_BASE:1.1.1.1
	OPENBSD_4_6:1.1.1.1.0.34
	OPENBSD_4_6_BASE:1.1.1.1
	OPENBSD_4_5:1.1.1.1.0.32
	OPENBSD_4_5_BASE:1.1.1.1
	OPENBSD_4_4:1.1.1.1.0.30
	OPENBSD_4_4_BASE:1.1.1.1
	OPENBSD_4_3:1.1.1.1.0.28
	OPENBSD_4_3_BASE:1.1.1.1
	OPENBSD_4_2:1.1.1.1.0.26
	OPENBSD_4_2_BASE:1.1.1.1
	OPENBSD_4_1:1.1.1.1.0.24
	OPENBSD_4_1_BASE:1.1.1.1
	OPENBSD_4_0:1.1.1.1.0.22
	OPENBSD_4_0_BASE:1.1.1.1
	OPENBSD_3_9:1.1.1.1.0.20
	OPENBSD_3_9_BASE:1.1.1.1
	OPENBSD_3_8:1.1.1.1.0.18
	OPENBSD_3_8_BASE:1.1.1.1
	OPENBSD_3_7:1.1.1.1.0.16
	OPENBSD_3_7_BASE:1.1.1.1
	OPENBSD_3_6:1.1.1.1.0.14
	OPENBSD_3_6_BASE:1.1.1.1
	OPENBSD_3_5:1.1.1.1.0.12
	OPENBSD_3_5_BASE:1.1.1.1
	OPENBSD_3_4:1.1.1.1.0.10
	OPENBSD_3_4_BASE:1.1.1.1
	OPENBSD_3_3:1.1.1.1.0.8
	OPENBSD_3_3_BASE:1.1.1.1
	OPENBSD_3_2:1.1.1.1.0.6
	OPENBSD_3_2_BASE:1.1.1.1
	OPENBSD_3_1:1.1.1.1.0.4
	OPENBSD_3_1_BASE:1.1.1.1
	OPENBSD_3_0:1.1.1.1.0.2
	OPENBSD_3_0_BASE:1.1.1.1
	OPENBSD_2_9_TRACKING_SWITCH:1.1.1.1
	Nonnekes:1.1.1.1
	quake:1.1.1;
locks; strict;
comment	@ * @;


1.2
date	2010.05.02.13.35.48;	author ratchov;	state dead;
branches;
next	1.1;

1.1
date	2001.08.03.13.02.16;	author espie;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2001.08.03.13.02.16;	author espie;	state Exp;
branches;
next	;


desc
@@


1.2
log
@replace sun audio backend by a sndio backend. Diff from jakemsr with
tweaks from me.

ok jakemsr
@
text
@/*
Copyright (C) 1996-1997 Id Software, Inc.

This program is free software; you can redistribute it and/or
modify it under the terms of the GNU General Public License
as published by the Free Software Foundation; either version 2
of the License, or (at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  

See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.

*/
#include "quakedef.h"

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <fcntl.h>
#include <sys/types.h>
#ifdef HAVE_SYS_IOCTL_H
# include <sys/ioctl.h>
#endif
#ifdef HAVE_SYS_MMAN_H
# include <sys/mman.h>
#endif
# include <sys/audioio.h>

static int audio_fd;
static int snd_inited;

static int tryrates[] = { 11025, 22051, 44100, 8000 };

qboolean SNDDMA_Init(void)
{

	int rc;
    int fmt;
	int tmp;
    int i;
    char *s;
	audio_info_t info;
	int caps;

	snd_inited = 0;

// open /dev/dsp, confirm capability to mmap, and get size of dma buffer

	// XXX Must open audio Read-Write for now for dma to work !!!
    audio_fd = open("/dev/audio", O_RDWR);
    if (audio_fd < 0)
	{
		perror("/dev/audio");
        Con_Printf("Could not open /dev/audio\n");
		return 0;
	}


	if (ioctl(audio_fd, AUDIO_GETPROPS, &caps)==-1)
	{
		perror("/dev/audio");
        Con_Printf("Sound driver does not understand GETPROPS\n");
		close(audio_fd);
		return 0;
	}

	if (!(caps & AUDIO_PROP_MMAP))
	{
		Con_Printf("Sorry but your soundcard doesn't support mmap\n");
		close(audio_fd);
		return 0;
	}

	shm = &sn;
    shm->splitbuffer = 0;

// set sample bits & speed

    shm->samplebits = 16;
    shm->speed = 11025;
    s = getenv("QUAKE_SOUND_CHANNELS");
    if (s) shm->channels = atoi(s);
	else if ((i = COM_CheckParm("-sndmono")) != 0)
		shm->channels = 1;
	else if ((i = COM_CheckParm("-sndstereo")) != 0)
		shm->channels = 2;
    else shm->channels = 2;


    AUDIO_INITINFO(&info);
    info.play.precision = shm->samplebits;
    info.play.sample_rate = 11025;
    info.play.encoding = AUDIO_ENCODING_SLINEAR_LE;
    info.play.channels = shm->channels;
    if (ioctl(audio_fd, AUDIO_SETINFO, &info) == -1) {
    	Con_Printf("Bad encoding size\n");
	close(audio_fd);
	return 0;
    }
    ioctl(audio_fd, AUDIO_GETINFO, &info);
    shm->speed = info.play.sample_rate;

	shm->samples = info.play.buffer_size / (shm->samplebits/8);
	shm->submission_chunk = 1;

// memory map the dma buffer

// XXX This is absurd but dma does not work if not mmapped read/write.
	shm->buffer = (unsigned char *) mmap(NULL, info.play.buffer_size,
	PROT_READ|PROT_WRITE, MAP_FILE|MAP_SHARED, audio_fd, 0);
		
//	if (!shm->buffer || shm->buffer == (unsigned char *)-1)
	if (shm->buffer == MAP_FAILED)
	{
		perror("/dev/audio");
		Con_Printf("Could not mmap /dev/audio\n");
		close(audio_fd);
		return 0;
	}

	shm->samplepos = 0;

	snd_inited = 1;
	return 1;

}

int SNDDMA_GetDMAPos(void)
{

	audio_offset_t count;

	if (!snd_inited) return 0;

	if (ioctl(audio_fd, AUDIO_GETOOFFS, &count)==-1)
	{
		perror("/dev/audio");
		Con_Printf("Uh, sound dead.\n");
		close(audio_fd);
		snd_inited = 0;
		return 0;
	}
//	shm->samplepos = (count.bytes / (shm->samplebits / 8)) & (shm->samples-1);
//	fprintf(stderr, "%d    \r", count.ptr);
	shm->samplepos = count.offset / (shm->samplebits / 8);

	return shm->samplepos;

}

void SNDDMA_Shutdown(void)
{
	if (snd_inited)
	{
		close(audio_fd);
		snd_inited = 0;
	}
}

/*
==============
SNDDMA_Submit

Send sound to device if buffer isn't really the dma buffer
===============
*/
void SNDDMA_Submit(void)
{
}

@


1.1
log
@Initial revision
@
text
@@


1.1.1.1
log
@Quake. Needs you to have datafiles to be useful.

Original by Maurices Nonnekes, a few tweaks (sound, i386 optimizations,
longer save menus) by me.

The client/server part probably still needs some work... 
and it is definitely unaudited.

Packaging might be changed to account for docs...

In fact, I really need `common' package files and reference counting...
@
text
@@
