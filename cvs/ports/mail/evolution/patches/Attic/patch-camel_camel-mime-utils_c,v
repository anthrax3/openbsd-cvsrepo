head	1.1;
access;
symbols
	OPENBSD_3_2:1.1.0.2;
locks; strict;
comment	@# @;


1.1
date	2003.04.15.03.18.32;	author marcm;	state dead;
branches
	1.1.2.1;
next	;

1.1.2.1
date	2003.04.15.03.18.32;	author marcm;	state Exp;
branches;
next	;


desc
@@


1.1
log
@file patch-camel_camel-mime-utils_c was initially added on branch OPENBSD_3_2.
@
text
@@


1.1.2.1
log
@Security update: addresses CORE security advisory CORE-20030304-01

ok brad@@
@
text
@a0 77
$OpenBSD$
--- camel/camel-mime-utils.c.orig	Thu Jun  6 13:36:51 2002
+++ camel/camel-mime-utils.c	Mon Apr  7 20:45:05 2003
@@@@ -2620,6 +2620,73 @@@@ header_msgid_decode(const char *in)
 	return header_msgid_decode_internal(&in);
 }
 
+char *
+header_contentid_decode (const char *in)
+{
+	const char *inptr = in;
+	gboolean at = FALSE;
+	GString *addr;
+	char *buf;
+	
+	d(printf("decoding Content-ID: '%s'\n", in));
+	
+	header_decode_lwsp (&inptr);
+	
+	/* some lame mailers quote the Content-Id */
+	if (*inptr == '"')
+		inptr++;
+	
+	/* make sure the content-id is not "" which can happen if we get a
+	 * content-id such as <.@@> (which Eudora likes to use...) */
+	if ((buf = header_msgid_decode (inptr)) != NULL && *buf)
+		return buf;
+	
+	g_free (buf);
+	
+	/* ugh, not a valid msg-id - try to get something useful out of it then? */
+	inptr = in;
+	header_decode_lwsp (&inptr);
+	if (*inptr == '<') {
+		inptr++;
+		header_decode_lwsp (&inptr);
+	}
+	
+	/* Eudora has been known to use <.@@> as a content-id */
+	if (!(buf = header_decode_word (&inptr)) && !strchr (".@@", *inptr))
+		return NULL;
+	
+	addr = g_string_new ("");
+	header_decode_lwsp (&inptr);
+	while (buf != NULL || *inptr == '.' || (*inptr == '@@' && !at)) {
+		if (buf != NULL) {
+			g_string_append (addr, buf);
+			g_free (buf);
+			buf = NULL;
+		}
+		
+		if (!at) {
+			if (*inptr == '.') {
+				g_string_append_c (addr, *inptr++);
+				buf = header_decode_word (&inptr);
+			} else if (*inptr == '@@') {
+				g_string_append_c (addr, *inptr++);
+				buf = header_decode_word (&inptr);
+				at = TRUE;
+			}
+		} else if (strchr (".[]", *inptr)) {
+			g_string_append_c (addr, *inptr++);
+			buf = header_decode_atom (&inptr);
+		}
+		
+		header_decode_lwsp (&inptr);
+	}
+	
+	buf = addr->str;
+	g_string_free (addr, FALSE);
+	
+	return buf;
+}
+
 void
 header_references_list_append_asis(struct _header_references **list, char *ref)
 {
@

