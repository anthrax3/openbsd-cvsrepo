head	1.2;
access;
symbols
	OPENBSD_6_1:1.2.0.12
	OPENBSD_6_1_BASE:1.2
	OPENBSD_6_0:1.2.0.10
	OPENBSD_6_0_BASE:1.2
	OPENBSD_5_9:1.2.0.6
	OPENBSD_5_9_BASE:1.2
	OPENBSD_5_8:1.2.0.8
	OPENBSD_5_8_BASE:1.2
	OPENBSD_5_7:1.2.0.4
	OPENBSD_5_7_BASE:1.2
	OPENBSD_5_6:1.2.0.2
	OPENBSD_5_6_BASE:1.2
	OPENBSD_5_5:1.1.0.40
	OPENBSD_5_5_BASE:1.1
	OPENBSD_5_4:1.1.0.38
	OPENBSD_5_4_BASE:1.1
	OPENBSD_5_3:1.1.0.36
	OPENBSD_5_3_BASE:1.1
	OPENBSD_5_2:1.1.0.34
	OPENBSD_5_2_BASE:1.1
	OPENBSD_5_1_BASE:1.1
	OPENBSD_5_1:1.1.0.32
	OPENBSD_5_0:1.1.0.30
	OPENBSD_5_0_BASE:1.1
	OPENBSD_4_9:1.1.0.28
	OPENBSD_4_9_BASE:1.1
	OPENBSD_4_8:1.1.0.26
	OPENBSD_4_8_BASE:1.1
	OPENBSD_4_7:1.1.0.24
	OPENBSD_4_7_BASE:1.1
	OPENBSD_4_6:1.1.0.22
	OPENBSD_4_6_BASE:1.1
	OPENBSD_4_5:1.1.0.20
	OPENBSD_4_5_BASE:1.1
	OPENBSD_4_4:1.1.0.18
	OPENBSD_4_4_BASE:1.1
	OPENBSD_4_3:1.1.0.16
	OPENBSD_4_3_BASE:1.1
	OPENBSD_4_2:1.1.0.14
	OPENBSD_4_2_BASE:1.1
	OPENBSD_4_1:1.1.0.12
	OPENBSD_4_1_BASE:1.1
	OPENBSD_4_0:1.1.0.10
	OPENBSD_4_0_BASE:1.1
	OPENBSD_3_9:1.1.0.8
	OPENBSD_3_9_BASE:1.1
	OPENBSD_3_7:1.1.0.6
	OPENBSD_3_6:1.1.0.4
	OPENBSD_3_8:1.1.0.2
	OPENBSD_3_8_BASE:1.1;
locks; strict;
comment	@# @;


1.2
date	2014.04.14.20.53.58;	author naddy;	state Exp;
branches;
next	1.1;

1.1
date	2005.08.27.15.57.31;	author naddy;	state Exp;
branches
	1.1.4.1
	1.1.6.1;
next	;

1.1.4.1
date	2005.09.04.20.23.01;	author sturm;	state Exp;
branches;
next	;

1.1.6.1
date	2005.09.04.20.28.27;	author sturm;	state Exp;
branches;
next	;


desc
@@


1.2
log
@switch from the ancient des_ API to DES_; ok benoit@@
@
text
@$OpenBSD: patch-Src_pcre-2_08_pcre_c,v 1.1 2005/08/27 15:57:31 naddy Exp $
--- Src/pcre-2.08/pcre.c.orig	Sun Nov  9 12:11:50 2003
+++ Src/pcre-2.08/pcre.c	Mon Apr 14 21:25:49 2014
@@@@ -435,14 +435,30 @@@@ read_repeat_counts(const uschar *p, int *minp, int *ma
 int min = 0;
 int max = -1;
 
+/* Read the minimum value and do a paranoid check: a negative value indicates
+an integer overflow. */
+
 while ((cd->ctypes[*p] & ctype_digit) != 0) min = min * 10 + *p++ - '0';
+if (min < 0 || min > 65535)
+  {
+  *errorptr = ERR5;
+  return p;
+  }
 
+/* Read the maximum value if there is one, and again do a paranoid on its size.
+Also, max must not be less than min. */
+
 if (*p == '}') max = min; else
   {
   if (*(++p) != '}')
     {
     max = 0;
     while((cd->ctypes[*p] & ctype_digit) != 0) max = max * 10 + *p++ - '0';
+    if (max < 0 || max > 65535)
+      {
+      *errorptr = ERR5;
+      return p;
+      }
     if (max < min)
       {
       *errorptr = ERR4;
@@@@ -451,16 +467,11 @@@@ if (*p == '}') max = min; else
     }
   }
 
-/* Do paranoid checks, then fill in the required variables, and pass back the
-pointer to the terminating '}'. */
+/* Fill in the required variables, and pass back the pointer to the terminating
+'}'. */
 
-if (min > 65535 || max > 65535)
-  *errorptr = ERR5;
-else
-  {
-  *minp = min;
-  *maxp = max;
-  }
+*minp = min;
+*maxp = max;
 return p;
 }
 
@


1.1
log
@SECURITY:
CAN-2005-2491, http://securitytracker.com/id?1014744
A remote or local user may be able to supply a specially crafted
regular expression to trigger a heap integer overflow in PCRE.

ok pvalchev@@
@
text
@d1 4
a4 4
$OpenBSD$
--- Src/pcre-2.08/pcre.c.orig	Fri Aug 26 20:12:43 2005
+++ Src/pcre-2.08/pcre.c	Fri Aug 26 20:16:47 2005
@@@@ -435,14 +435,30 @@@@ read_repeat_counts(const uschar *p, int 
@


1.1.6.1
log
@SECURITY:
CAN-2005-2491, http://securitytracker.com/id?1014744
A remote or local user may be able to supply a specially crafted
regular expression to trigger a heap integer overflow in PCRE.

ok brad@@
@
text
@d1 1
a1 1
$OpenBSD: patch-Src_pcre-2_08_pcre_c,v 1.1 2005/08/27 15:57:31 naddy Exp $
@


1.1.4.1
log
@MFC:
SECURITY:
CAN-2005-2491, http://securitytracker.com/id?1014744
A remote or local user may be able to supply a specially crafted
regular expression to trigger a heap integer overflow in PCRE

ok brad@@
@
text
@d1 1
a1 1
$OpenBSD: patch-Src_pcre-2_08_pcre_c,v 1.1 2005/08/27 15:57:31 naddy Exp $
@

