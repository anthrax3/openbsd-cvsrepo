head	1.2;
access;
symbols;
locks; strict;
comment	@# @;


1.2
date	2001.02.01.07.28.12;	author jakob;	state dead;
branches;
next	1.1;

1.1
date	2001.01.21.11.52.59;	author jakob;	state Exp;
branches;
next	;


desc
@@


1.2
log
@update to postfix snapshot-20010130.


Incompatible changes with snapshot-20010128
===========================================

REJECT in header/body_checks is now flagged as policy violation
rather than bounce, for consistency in postmaster notifications.

The mailbox size limit for local delivery is no longer controlled
by the message_size_limit paramater, but by a separate parameter
called mailbox_size_limit (default: 20MBytes).

The default RBL (real-time blackhole lists) domain examples have
been updated from *.vix.com to *.mail-abuse.org.

Major changes with snapshot-20010128
====================================

Updated nqmgr (experimental queue manager with clever queueing
strategy) by Patrik Rak. This code is still new. Once it stops
changing (for a long time!) it will become part of the non-beta
release.

Virtual mailbox delivery agent by Andrew McNamara. This delivery
agent can deliver mail for any number of domains.  See the file
VIRTUAL_README for detailed examples. This code is still new. Once
it stops changing it will become part of the non-beta release.

Many "valid_hostname" warnings were eliminated. The complaints that
were not eliminated were replaced by something more informative.

SASL support (RFC 2554) for the LMTP delivery agent. This is required
by recent Cyrus implementations when delivering mail over TCP
sockets. The LMTP_README file has been updated but still contains
some obsolete information.

Workarounds for non-standard RFC 2554 (AUTH command) implementations.
Specify "broken_sasl_auth_clients = yes" to enable SMTP server
support for old Microsoft client applications. The Postfix SMTP
client supports non-standard RFC 2554 servers by default.
@
text
@*** src/smtp/smtp.h	Sat Jul 15 14:06:34 2000
--- ./smtp.h	Sat Jan 20 18:30:34 2001
***************
*** 85,91 ****
    */
  extern SMTP_SESSION *smtp_connect(char *, VSTRING *);
  extern SMTP_SESSION *smtp_connect_host(char *, unsigned, VSTRING *);
! extern SMTP_SESSION *smtp_connect_domain(char *, unsigned, VSTRING *);
  
   /*
    * smtp_proto.c
--- 85,91 ----
    */
  extern SMTP_SESSION *smtp_connect(char *, VSTRING *);
  extern SMTP_SESSION *smtp_connect_host(char *, unsigned, VSTRING *);
! extern SMTP_SESSION *smtp_connect_domain(char *, unsigned, VSTRING *, int *);
  
   /*
    * smtp_proto.c
*** src/smtp/smtp_addr.c	Mon Nov 20 13:06:02 2000
--- ./smtp_addr.c	Sat Jan 20 18:34:23 2001
***************
*** 6,14 ****
  /* SYNOPSIS
  /*	#include "smtp_addr.h"
  /*
! /*	DNS_RR *smtp_domain_addr(name, why)
  /*	char	*name;
  /*	VSTRING	*why;
  /*
  /*	DNS_RR *smtp_host_addr(name, why)
  /*	char	*name;
--- 6,15 ----
  /* SYNOPSIS
  /*	#include "smtp_addr.h"
  /*
! /*	DNS_RR *smtp_domain_addr(name, why, found_myself)
  /*	char	*name;
  /*	VSTRING	*why;
+ /*	int	*found_myself;
  /*
  /*	DNS_RR *smtp_host_addr(name, why)
  /*	char	*name;
***************
*** 279,289 ****
  
  /* smtp_domain_addr - mail exchanger address lookup */
  
! DNS_RR *smtp_domain_addr(char *name, VSTRING *why)
  {
      DNS_RR *mx_names;
      DNS_RR *addr_list = 0;
!     DNS_RR *self;
      unsigned best_pref;
      unsigned best_found;
  
--- 280,290 ----
  
  /* smtp_domain_addr - mail exchanger address lookup */
  
! DNS_RR *smtp_domain_addr(char *name, VSTRING *why, int *found_myself)
  {
      DNS_RR *mx_names;
      DNS_RR *addr_list = 0;
!     DNS_RR *self = 0;
      unsigned best_pref;
      unsigned best_found;
  
***************
*** 363,368 ****
--- 364,370 ----
      /*
       * Clean up.
       */
+     *found_myself = (self != 0);
      return (addr_list);
  }
  
*** src/smtp/smtp_addr.h	Mon Jan 18 15:11:48 1999
--- ./smtp_addr.h	Sat Jan 20 18:34:53 2001
***************
*** 17,23 ****
    * Internal interfaces.
    */
  extern DNS_RR *smtp_host_addr(char *, VSTRING *);
! extern DNS_RR *smtp_domain_addr(char *, VSTRING *);
  
  /* LICENSE
  /* .ad
--- 17,23 ----
    * Internal interfaces.
    */
  extern DNS_RR *smtp_host_addr(char *, VSTRING *);
! extern DNS_RR *smtp_domain_addr(char *, VSTRING *, int *);
  
  /* LICENSE
  /* .ad
*** src/smtp/smtp_connect.c	Mon Nov 20 13:06:03 2000
--- ./smtp_connect.c	Sat Jan 20 18:36:00 2001
***************
*** 292,298 ****
  
  /* smtp_connect_domain - connect to smtp server for domain */
  
! SMTP_SESSION *smtp_connect_domain(char *name, unsigned port, VSTRING *why)
  {
      SMTP_SESSION *session = 0;
      DNS_RR *addr_list;
--- 292,299 ----
  
  /* smtp_connect_domain - connect to smtp server for domain */
  
! SMTP_SESSION *smtp_connect_domain(char *name, unsigned port, VSTRING *why,
! 				          int *found_myself)
  {
      SMTP_SESSION *session = 0;
      DNS_RR *addr_list;
***************
*** 306,312 ****
       * the primary MX host is reachable but does not want to receive our
       * mail, there is no point in trying the backup hosts.
       */
!     addr_list = smtp_domain_addr(name, why);
      for (addr = addr_list; addr; addr = addr->next) {
  	if ((session = smtp_connect_addr(addr, port, why)) != 0) {
  	    session->best = (addr->pref == addr_list->pref);
--- 307,313 ----
       * the primary MX host is reachable but does not want to receive our
       * mail, there is no point in trying the backup hosts.
       */
!     addr_list = smtp_domain_addr(name, why, found_myself);
      for (addr = addr_list; addr; addr = addr->next) {
  	if ((session = smtp_connect_addr(addr, port, why)) != 0) {
  	    session->best = (addr->pref == addr_list->pref);
***************
*** 393,398 ****
--- 394,400 ----
      char   *save;
      char   *dest;
      char   *cp;
+     int     found_myself;
  
      /*
       * First try to deliver to the indicated destination, then try to deliver
***************
*** 417,423 ****
  	if (var_disable_dns || *dest == '[') {
  	    session = smtp_connect_host(host, port, why);
  	} else {
! 	    session = smtp_connect_domain(host, port, why);
  	}
  	myfree(dest_buf);
  
--- 419,425 ----
  	if (var_disable_dns || *dest == '[') {
  	    session = smtp_connect_host(host, port, why);
  	} else {
! 	    session = smtp_connect_domain(host, port, why, &found_myself);
  	}
  	myfree(dest_buf);
  
***************
*** 426,432 ****
  	 * is the best MX relay for the destination. Agreed, an errno of OK
  	 * after failure is a weird way to reporting progress.
  	 */
! 	if (session != 0 || smtp_errno == SMTP_OK)
  	    break;
      }
  
--- 428,434 ----
  	 * is the best MX relay for the destination. Agreed, an errno of OK
  	 * after failure is a weird way to reporting progress.
  	 */
! 	if (session != 0 || smtp_errno == SMTP_OK || found_myself)
  	    break;
      }
  


@


1.1
log
@add patch for fallback-relay loop. info from Wietse below.


Summary
-------
This patch fixes a problem in the Postfix SMTP client's fallback
relay feature in snapshot releases after 20001005.

By default, Postfix does not use the fallback_relay feature. To
find out if your system uses it, issue the command:

    postconf fallback_relay

The result is "fallback_relay =" when the feature is turned off.

Description
-----------
As of 20001005, the Postfix SMTP client will send mail to a fallback
relay host (if one is configured) even when the local machine is
a backup MX host for the final destination.

This causes a loop when the primary MX host is down. Postfix receives
the mail, because it's a backup MX host for the destination. Postfix
then sends the mail to the fallback relay, because the primary MX
host is down.  The fallback sends the mail back to Postfix, because
it's a backup MX host. Mail then bounces after 25 or so iterations.

Laurent Wacrenier had the, um, pleasure, of finding this one.

Solution
--------
If the local machine is listed as MX host for the final destination,
do not send undeliverable mail to the fallback relay.  That is how
releases prior to 20001005 work, including 19991231.

This patch should apply to all snapshots since 20001005, but I have
tested this only with 20001217.

To apply, step into the src/smtp source directory, feed this text
into the patch command, and rebuild. The "make install" command
replaces only the smtp client program.
@
text
@@

