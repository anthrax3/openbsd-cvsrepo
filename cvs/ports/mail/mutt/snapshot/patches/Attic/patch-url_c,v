head	1.3;
access;
symbols
	OPENBSD_4_8:1.2.0.6
	OPENBSD_4_8_BASE:1.2
	OPENBSD_4_7:1.2.0.4
	OPENBSD_4_7_BASE:1.2
	OPENBSD_4_6:1.2.0.2
	OPENBSD_4_6_BASE:1.2;
locks; strict;
comment	@# @;


1.3
date	2010.09.08.09.57.28;	author sthen;	state dead;
branches;
next	1.2;

1.2
date	2009.06.19.21.28.24;	author sthen;	state Exp;
branches;
next	1.1;

1.1
date	2009.06.16.09.37.19;	author sthen;	state Exp;
branches;
next	;


desc
@@


1.3
log
@- update the sidebar/compressed patches to work with this snapshot.
- new LIB_DEPENDS/REVISION.
- switch to a newer snapshot pulled from the repo, rolling in the
upstream patches.

requested by edd@@. thanks to jasper@@, landry@@, pea@@ for testing.
@
text
@$OpenBSD: patch-url_c,v 1.2 2009/06/19 21:28:24 sthen Exp $

don't parse URL port as signed short, but to int and cast to
unsigned short; mutt bug #3264

fixup URL parser, Changeset 5901:6eadedb1f6c0 for url.c:

1) allow / in usernames for IMAP (by %-encoding /, : and
% when pretty-printing urls),

2) for POP/SMTP the trailing / is no longer mandatory,

3) more strict %-decoding to avoid unexpected results


--- url.c.orig	Mon Jun  1 17:29:32 2009
+++ url.c	Fri Jun 19 21:39:02 2009
@@@@ -45,28 +45,32 @@@@ static struct mapping_t UrlMap[] =
   { NULL,	U_UNKNOWN }
 };
 
-
-static void url_pct_decode (char *s)
+static int url_pct_decode (char *s)
 {
   char *d;
 
   if (!s)
-    return;
-  
+    return -1;
+
   for (d = s; *s; s++)
   {
-    if (*s == '%' && s[1] && s[2] &&
-	isxdigit ((unsigned char) s[1]) &&
-        isxdigit ((unsigned char) s[2]) &&
-	hexval (s[1]) >= 0 && hexval (s[2]) >= 0)
+    if (*s == '%')
     {
-      *d++ = (hexval (s[1]) << 4) | (hexval (s[2]));
-      s += 2;
-    }
-    else
+      if (s[1] && s[2] &&
+	  isxdigit ((unsigned char) s[1]) &&
+	  isxdigit ((unsigned char) s[2]) &&
+	  hexval (s[1]) >= 0 && hexval (s[2]) >= 0)
+      {
+	*d++ = (hexval (s[1]) << 4) | (hexval (s[2]));
+	s += 2;
+      }
+      else
+	return -1;
+    } else
       *d++ = *s;
   }
   *d ='\0';
+  return 0;
 }
 
 url_scheme_t url_check_scheme (const char *s)
@@@@ -74,12 +78,12 @@@@ url_scheme_t url_check_scheme (const char *s)
   char sbuf[STRING];
   char *t;
   int i;
-  
+
   if (!s || !(t = strchr (s, ':')))
     return U_UNKNOWN;
   if ((t - s) + 1 >= sizeof (sbuf))
     return U_UNKNOWN;
-  
+
   strfcpy (sbuf, s, t - s + 1);
   for (t = sbuf; *t; t++)
     *t = ascii_tolower (*t);
@@@@ -98,33 +102,33 @@@@ int url_parse_file (char *d, const char *src, size_t d
     return -1;
   else
     strfcpy (d, src + 5, dl);
-  
-  url_pct_decode (d);
-  return 0;
+
+  return url_pct_decode (d);
 }
 
 /* ciss_parse_userhost: fill in components of ciss with info from src. Note
  *   these are pointers into src, which is altered with '\0's. Port of 0
  *   means no port given. */
-static char *ciss_parse_userhost (ciss_url_t *ciss, char *src)
+static int ciss_parse_userhost (ciss_url_t *ciss, char *src)
 {
-  char *t;
-  char *p;
-  char *path;
+  char *t, *p;
 
   ciss->user = NULL;
   ciss->pass = NULL;
   ciss->host = NULL;
   ciss->port = 0;
 
-  if (strncmp (src, "//", 2))
-    return src;
-  
+  if (strncmp (src, "//", 2) != 0)
+  {
+    ciss->path = src;
+    return url_pct_decode (ciss->path);
+  }
+
   src += 2;
 
-  if ((path = strchr (src, '/')))
-    *path++ = '\0';
-  
+  if ((ciss->path = strchr (src, '/')))
+    *ciss->path++ = '\0';
+
   if ((t = strrchr (src, '@@')))
   {
     *t = '\0';
@@@@ -132,27 +136,31 @@@@ static char *ciss_parse_userhost (ciss_url_t *ciss, ch
     {
       *p = '\0';
       ciss->pass = p + 1;
-      url_pct_decode (ciss->pass);
+      if (url_pct_decode (ciss->pass) < 0)
+	return -1;
     }
     ciss->user = src;
-    url_pct_decode (ciss->user);
+    if (url_pct_decode (ciss->user) < 0)
+      return -1;
     t++;
   }
   else
     t = src;
-  
+
   if ((p = strchr (t, ':')))
   {
+    int t;
     *p++ = '\0';
-    if (mutt_atos (p, (short*) &ciss->port) < 0)
-      return NULL;
+    if (mutt_atoi (p, &t) < 0 || t < 0 || t > 0xffff)
+      return -1;
+    ciss->port = (unsigned short)t;
   }
   else
     ciss->port = 0;
-  
+
   ciss->host = t;
-  url_pct_decode (ciss->host);
-  return path;
+  return url_pct_decode (ciss->host) >= 0 &&
+    (!ciss->path || url_pct_decode (ciss->path) >= 0) ? 0 : -1;
 }
 
 /* url_parse_ciss: Fill in ciss_url_t. char* elements are pointers into src,
@@@@ -166,15 +174,31 @@@@ int url_parse_ciss (ciss_url_t *ciss, char *src)
 
   tmp = strchr (src, ':') + 1;
 
-  if ((ciss->path = ciss_parse_userhost (ciss, tmp)) == NULL)
-    return -1;
-  url_pct_decode (ciss->path);
-  
-  return 0;
+  return ciss_parse_userhost (ciss, tmp);
 }
 
-/* url_ciss_tostring: output the URL string for a given CISS object. */
+static void url_pct_encode (char *dst, size_t l, const char *src)
+{
+  static const char *alph = "0123456789ABCDEF";
 
+  *dst = 0;
+  l--;
+  while (src && *src && l)
+  {
+    if (strchr ("/:%", *src) && l > 3)
+    {
+      *dst++ = '%';
+      *dst++ = alph[(*src >> 4) & 0xf];
+      *dst++ = alph[*src & 0xf];
+      src++;
+      continue;
+    }
+    *dst++ = *src++;
+  }
+  *dst = 0;
+}
+
+/* url_ciss_tostring: output the URL string for a given CISS object. */
 int url_ciss_tostring (ciss_url_t* ciss, char* dest, size_t len, int flags)
 {
   long l;
@@@@ -189,12 +213,20 @@@@ int url_ciss_tostring (ciss_url_t* ciss, char* dest, s
     if (!(flags & U_PATH))
       safe_strcat (dest, len, "//");
     len -= (l = strlen (dest)); dest += l;
-    
-    if (ciss->user) {
+
+    if (ciss->user)
+    {
+      char u[STRING];
+      url_pct_encode (u, sizeof (u), ciss->user);
+
       if (flags & U_DECODE_PASSWD && ciss->pass)
-	snprintf (dest, len, "%s:%s@@", ciss->user, ciss->pass);
+      {
+	char p[STRING];
+	url_pct_encode (p, sizeof (p), ciss->pass);
+	snprintf (dest, len, "%s:%s@@", u, p);
+      }
       else
-	snprintf (dest, len, "%s@@", ciss->user);
+	snprintf (dest, len, "%s@@", u);
 
       len -= (l = strlen (dest)); dest += l;
     }
@@@@ -219,24 +251,25 @@@@ int url_parse_mailto (ENVELOPE *e, char **body, const 
   char *tag, *value;
   char scratch[HUGE_STRING];
 
-  int taglen, rc = 0;
+  int taglen, rc = -1;
 
   LIST *last = NULL;
-  
+
   if (!(t = strchr (src, ':')))
     return -1;
-  
+
   if ((tmp = safe_strdup (t + 1)) == NULL)
     return -1;
 
   if ((headers = strchr (tmp, '?')))
     *headers++ = '\0';
 
-  url_pct_decode (tmp);
+  if (url_pct_decode (tmp) < 0)
+    return -1;
   e->to = rfc822_parse_adrlist (e->to, tmp);
 
   tag = headers ? strtok_r (headers, "&", &p) : NULL;
-  
+
   for (; tag; tag = strtok_r (NULL, "&", &p))
   {
     if ((value = strchr (tag, '=')))
@@@@ -244,8 +277,10 @@@@ int url_parse_mailto (ENVELOPE *e, char **body, const 
     if (!value || !*value)
       continue;
 
-    url_pct_decode (tag);
-    url_pct_decode (value);
+    if (url_pct_decode (tag) < 0)
+      return -1;
+    if (url_pct_decode (value) < 0)
+      return -1;
 
     if (!ascii_strcasecmp (tag, "body"))
     {
@


1.2
log
@dhill@@ had a crash with smtp_url specifying a port (I added one diff
but another followed); update the relevant file to the newer revision,
fixing the problem. ok dhill@@
@
text
@d1 1
a1 1
$OpenBSD: patch-url_c,v 1.1 2009/06/16 09:37:19 sthen Exp $
@


1.1
log
@- bug-fix and SECURITY update to 1.5.20; fixes CVE-2009-1390 (X.509
Certificate Chain Security Bypass vulnerability).

- added a couple of post-1.5.20 patches from upstream for regressions

- cleanup the port's handling of sample config files

testing by Simon Kuhnle, Edd Barrett, testing and ok landry@@.
@
text
@d1 1
a1 1
$OpenBSD$
d6 137
a142 3
--- url.c.orig	Mon Jun 15 21:04:14 2009
+++ url.c	Mon Jun 15 21:04:26 2009
@@@@ -144,7 +144,7 @@@@ static char *ciss_parse_userhost (ciss_url_t *ciss, ch
d145 1
d148 1
d150 2
a151 1
       return NULL;
d154 118
@

