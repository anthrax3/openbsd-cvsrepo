head	1.2;
access;
symbols
	OPENBSD_6_1:1.2.0.2
	OPENBSD_6_1_BASE:1.2
	OPENBSD_6_0:1.1.1.1.0.48
	OPENBSD_6_0_BASE:1.1.1.1
	OPENBSD_5_9:1.1.1.1.0.44
	OPENBSD_5_9_BASE:1.1.1.1
	OPENBSD_5_8:1.1.1.1.0.46
	OPENBSD_5_8_BASE:1.1.1.1
	OPENBSD_5_7:1.1.1.1.0.42
	OPENBSD_5_7_BASE:1.1.1.1
	OPENBSD_5_6:1.1.1.1.0.40
	OPENBSD_5_6_BASE:1.1.1.1
	OPENBSD_5_5:1.1.1.1.0.38
	OPENBSD_5_5_BASE:1.1.1.1
	OPENBSD_5_4:1.1.1.1.0.36
	OPENBSD_5_4_BASE:1.1.1.1
	OPENBSD_5_3:1.1.1.1.0.34
	OPENBSD_5_3_BASE:1.1.1.1
	OPENBSD_5_2:1.1.1.1.0.32
	OPENBSD_5_2_BASE:1.1.1.1
	OPENBSD_5_1_BASE:1.1.1.1
	OPENBSD_5_1:1.1.1.1.0.30
	OPENBSD_5_0:1.1.1.1.0.28
	OPENBSD_5_0_BASE:1.1.1.1
	OPENBSD_4_9:1.1.1.1.0.26
	OPENBSD_4_9_BASE:1.1.1.1
	OPENBSD_4_8:1.1.1.1.0.24
	OPENBSD_4_8_BASE:1.1.1.1
	OPENBSD_4_7:1.1.1.1.0.22
	OPENBSD_4_7_BASE:1.1.1.1
	OPENBSD_4_6:1.1.1.1.0.20
	OPENBSD_4_6_BASE:1.1.1.1
	OPENBSD_4_5:1.1.1.1.0.18
	OPENBSD_4_5_BASE:1.1.1.1
	OPENBSD_4_4:1.1.1.1.0.16
	OPENBSD_4_4_BASE:1.1.1.1
	OPENBSD_4_3:1.1.1.1.0.14
	OPENBSD_4_3_BASE:1.1.1.1
	OPENBSD_4_2:1.1.1.1.0.12
	OPENBSD_4_2_BASE:1.1.1.1
	OPENBSD_4_1:1.1.1.1.0.10
	OPENBSD_4_1_BASE:1.1.1.1
	OPENBSD_4_0:1.1.1.1.0.8
	OPENBSD_4_0_BASE:1.1.1.1
	OPENBSD_3_9:1.1.1.1.0.6
	OPENBSD_3_9_BASE:1.1.1.1
	OPENBSD_3_8:1.1.1.1.0.4
	OPENBSD_3_8_BASE:1.1.1.1
	OPENBSD_3_7:1.1.1.1.0.2
	OPENBSD_3_7_BASE:1.1.1.1
	naddy_20041108:1.1.1.1
	naddy:1.1.1;
locks; strict;
comment	@# @;


1.2
date	2016.09.10.13.03.42;	author ajacoutot;	state Exp;
branches;
next	1.1;
commitid	4KcvAK91uGdTLejD;

1.1
date	2004.11.08.21.57.05;	author naddy;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2004.11.08.21.57.05;	author naddy;	state Exp;
branches;
next	;


desc
@@


1.2
log
@First pass at pre-entively fixing ports that would break once guenther's header
pollution diff is in.

lang/squeak/vm does not build but it's due to the recent audio changes
games/xbattle: also fixes some conflicting implicit decl
print/hplip: also fixes some conflicting implicit decl
@
text
@$OpenBSD: patch-tcp_listen_c,v 1.1.1.1 2004/11/08 21:57:05 naddy Exp $
--- tcp_listen.c.orig	Sun May  4 10:26:14 2003
+++ tcp_listen.c	Sat Sep 10 11:45:32 2016
@@@@ -6,10 +6,16 @@@@
 #include <netdb.h>
 #include <string.h>
 #include <syslog.h>
+#include <sys/select.h> /* fd_set */
 #include <stdio.h>
 #include <unistd.h>
 #include <errno.h>
 
+#define MAX_SOCKETS 10
+int socket_array[MAX_SOCKETS], maxs;
+int *socks=socket_array;
+fd_set deffds;
+ 
 static void Setsockopt(int fd, int level, int optname, const void * optval, socklen_t optlen) {
   if (setsockopt(fd,level,optname,optval,optlen) < 0) {
     syslog(LOG_WARNING,"%s: %s","setsockopt failed",strerror(errno));
@@@@ -29,8 +35,8 @@@@ static void Listen(int fd, int backlog) {
   }
 }
 
-static int tcp_listen(const char * host, const char * serv, socklen_t * addrlenp) {
-  int listenfd, n;
+static int* tcp_listen(const char * host, const char * serv) {
+  int n, *s;
   const int on = 1;
   struct addrinfo hints, * res, * ressave;
   struct linger sl = { 1, 5 };
@@@@ -39,37 +45,37 @@@@ static int tcp_listen(const char * host, const char * 
   hints.ai_flags = AI_PASSIVE;
   hints.ai_family = AF_UNSPEC;
   hints.ai_socktype = SOCK_STREAM;
+  FD_ZERO(&deffds);
 
-  if ((n = getaddrinfo(host,serv,&hints,&res)) != 0) {
+  if ((n = getaddrinfo(host,serv,&hints,&ressave)) != 0) {
     syslog(LOG_ERR,"%s: %s, %s: %s","getaddrinfo failed",host?host:"(any)",serv,strerror(errno));
     perror("getaddrinfo");
     exit(EXIT_FAILURE);
   }
-  ressave = res;
 
-  do {
-    listenfd = socket(res->ai_family,res->ai_socktype,res->ai_protocol);
-    if (listenfd < 0)
+  for (s=socks, res=ressave, maxs=0; res; res = res->ai_next) {
+    *s = socket(res->ai_family, res->ai_socktype,res->ai_protocol);
+    if (*s < 0)
       continue;
-    Setsockopt(listenfd,SOL_SOCKET,SO_REUSEADDR,&on,sizeof(on));
-    Setsockopt(listenfd,SOL_SOCKET,SO_LINGER,&sl,sizeof(sl));
-    if (bind(listenfd,res->ai_addr,res->ai_addrlen) == 0)
-      break;
-    close(listenfd);
-  } while ((res = res->ai_next) != NULL);
-  if (res == NULL) {
-    syslog(LOG_ERR,"%s: %s, %s: %s","failed to bind socket",host?host:"(any)",serv,strerror(errno));
-    perror("tcp_listen");
-    exit(EXIT_FAILURE);
+    if (maxs==MAX_SOCKETS) {
+      syslog(LOG_ERR,"limiting socket number to %d",MAX_SOCKETS);
+      continue;
+    }
+    Setsockopt(*s,SOL_SOCKET,SO_REUSEADDR,&on,sizeof(on));
+    Setsockopt(*s,SOL_SOCKET,SO_LINGER,&sl,sizeof(sl));
+    if (bind(*s,res->ai_addr,res->ai_addrlen) != 0) {
+      close(*s);
+      continue;
+    }
+    Listen(*s,LISTENQ);
+    FD_SET(*s, &deffds);
+    s++; maxs++;
   }
-  Listen(listenfd,LISTENQ);
-  if (addrlenp) 
-    *addrlenp = res->ai_addrlen;
 
   freeaddrinfo(ressave);
-  return listenfd;
+  return socks;
 }
 
-int Tcp_listen(const char * host, const char * serv, socklen_t * addrlenp) {
-  return tcp_listen(host,serv,addrlenp);
+int* Tcp_listen(const char * host, const char * serv) {
+  return tcp_listen(host,serv);
 }
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
$OpenBSD$
d3 7
a9 2
+++ tcp_listen.c	Fri Aug 27 01:45:07 2004
@@@@ -10,6 +10,11 @@@@
d21 1
a21 1
@@@@ -29,8 +34,8 @@@@ static void Listen(int fd, int backlog) 
d32 1
a32 1
@@@@ -39,37 +44,37 @@@@ static int tcp_listen(const char * host,
@


1.1.1.1
log
@Import akpop3d 0.7.7.
Submitted by Maxime Guillaud <bsd-ports@@mguillaud.net>.

akpop3d is a POP3 daemon aimed to be small and secure.  It is
stand-alone, very small, easy to modify.  Despite its small size, it
offers a lot of features.
@
text
@@
