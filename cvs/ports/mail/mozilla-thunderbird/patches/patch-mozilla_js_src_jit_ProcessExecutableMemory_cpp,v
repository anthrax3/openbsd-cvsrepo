head	1.3;
access;
symbols
	OPENBSD_6_1:1.2.0.2
	OPENBSD_6_1_BASE:1.2;
locks; strict;
comment	@# @;


1.3
date	2017.04.05.09.46.18;	author landry;	state Exp;
branches;
next	1.2;
commitid	o8T4heoNFjbPlTcC;

1.2
date	2017.03.23.07.33.24;	author landry;	state Exp;
branches;
next	1.1;
commitid	RwHJ8mHWJxsp3hVE;

1.1
date	2017.03.08.15.54.54;	author landry;	state Exp;
branches;
next	;
commitid	F8jHuBc83ru9ji3A;


desc
@@


1.3
log
@Update to thunderbird 52.0/lightning 5.4.

See https://www.mozilla.org/en-US/thunderbird/52.0/releasenotes/

Note that it now defaults to use Gtk+3.
@
text
@$OpenBSD: patch-mozilla_js_src_jit_ProcessExecutableMemory_cpp,v 1.2 2017/03/23 07:33:24 landry Exp $

https://bugzilla.mozilla.org/show_bug.cgi?id=1347139

--- mozilla/js/src/jit/ProcessExecutableMemory.cpp.orig	Wed Feb 15 17:34:41 2017
+++ mozilla/js/src/jit/ProcessExecutableMemory.cpp	Thu Mar 23 08:42:19 2017
@@@@ -390,7 +390,12 @@@@ class PageBitSet
 #if JS_BITS_PER_WORD == 32
 static const size_t MaxCodeBytesPerProcess = 128 * 1024 * 1024;
 #else
+#ifdef __OpenBSD__
+// default datasize is 768Mb on OpenBSD
+static const size_t MaxCodeBytesPerProcess = 128 * 1024 * 1024;
+#else
 static const size_t MaxCodeBytesPerProcess = 640 * 1024 * 1024;
+#endif
 #endif
 
 // Per-process executable memory allocator. It reserves a block of memory of
@


1.2
log
@Apply the same patch as in firefox-52 to pre-allocate only 128Mb at js
engine startup, otherwise tb doesnt start with default 768Mb datasize
limit (but starts fine with ulimit -d 1200000) sigh.
reported by semarie@@
@
text
@d1 1
a1 1
$OpenBSD: patch-mozilla_js_src_jit_ProcessExecutableMemory_cpp,v 1.1 2017/03/08 15:54:54 landry Exp $
d3 1
a3 2
https://gitweb.torproject.org/tor-browser.git/patch/?id=235c607f6bc39e124b9e8430092be249c3d64981
chunk 3: https://bugzilla.mozilla.org/show_bug.cgi?id=1347139
d5 3
a7 31
--- mozilla/js/src/jit/ProcessExecutableMemory.cpp.orig	Sun Mar  5 21:58:25 2017
+++ mozilla/js/src/jit/ProcessExecutableMemory.cpp	Thu Mar 23 08:31:15 2017
@@@@ -219,7 +219,12 @@@@ DeallocateProcessExecutableMemory(void* addr, size_t b
 static DWORD
 ProtectionSettingToFlags(ProtectionSetting protection)
 {
-    return PAGE_EXECUTE_READWRITE;
+    switch (protection) {
+      case ProtectionSetting::Protected:  return PAGE_NOACCESS;
+      case ProtectionSetting::Writable:   return PAGE_READWRITE;
+      case ProtectionSetting::Executable: return PAGE_EXECUTE_READ;
+    }
+    MOZ_CRASH();
 }
 
 static void
@@@@ -283,7 +288,12 @@@@ DeallocateProcessExecutableMemory(void* addr, size_t b
 static unsigned
 ProtectionSettingToFlags(ProtectionSetting protection)
 {
-    return PROT_READ | PROT_WRITE | PROT_EXEC;
+    switch (protection) {
+      case ProtectionSetting::Protected:  return PROT_NONE;
+      case ProtectionSetting::Writable:   return PROT_READ | PROT_WRITE;
+      case ProtectionSetting::Executable: return PROT_READ | PROT_EXEC;
+    }
+    MOZ_CRASH();
 }
 
 static void
@@@@ -363,8 +373,13 @@@@ class PageBitSet
d16 1
a17 1
+#endif
a19 40
 // MaxCodeBytesPerProcess bytes, then allocates/deallocates pages from that.
@@@@ -604,4 +619,38 @@@@ js::jit::CanLikelyAllocateMoreExecutableMemory()
     MOZ_ASSERT(execMemory.bytesAllocated() <= MaxCodeBytesPerProcess);
 
     return execMemory.bytesAllocated() + BufferSize <= MaxCodeBytesPerProcess;
+}
+
+bool
+js::jit::ReprotectRegion(void* start, size_t size, ProtectionSetting protection)
+{
+    // Calculate the start of the page containing this region,
+    // and account for this extra memory within size.
+    size_t pageSize = gc::SystemPageSize();
+    intptr_t startPtr = reinterpret_cast<intptr_t>(start);
+    intptr_t pageStartPtr = startPtr & ~(pageSize - 1);
+    void* pageStart = reinterpret_cast<void*>(pageStartPtr);
+    size += (startPtr - pageStartPtr);
+
+    // Round size up
+    size += (pageSize - 1);
+    size &= ~(pageSize - 1);
+
+    MOZ_ASSERT((uintptr_t(pageStart) % pageSize) == 0);
+
+    execMemory.assertValidAddress(pageStart, size);
+
+    #ifdef XP_WIN
+    DWORD oldProtect;
+    DWORD flags = ProtectionSettingToFlags(protection);
+    if (!VirtualProtect(pageStart, size, flags, &oldProtect))
+        return false;
+    #else
+    unsigned flags = ProtectionSettingToFlags(protection);
+    if (mprotect(pageStart, size, flags))
+        return false;
+    #endif
+
+    execMemory.assertValidAddress(pageStart, size);
+    return true;
 }
@


1.1
log
@Fix build breakage by shoplifting a patch from tor-browser (see
https://trac.torproject.org/projects/tor/ticket/21514) - patch pointed
at by Jan De Mooij@@mozilla.

In bug #1334933, as part of a security fix the code for W^X not
merged/rearranged, but was removed - thus triggering mmap protection
during build on OpenBSD, as reported by naddy@@. My bad for not spotting
this.

The tor-browser patch just reinstates some W^X bits, instead of marking
TB as needing wxallowed. This is only temporary for 45, 52 won't need
that anyway.

Tested building and working fine.
@
text
@d1 1
a1 1
$OpenBSD$
d4 1
d7 1
a7 1
+++ mozilla/js/src/jit/ProcessExecutableMemory.cpp	Wed Mar  8 14:06:00 2017
d36 15
a50 1
@@@@ -604,4 +614,38 @@@@ js::jit::CanLikelyAllocateMoreExecutableMemory()
@

