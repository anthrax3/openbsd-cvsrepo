head	1.9;
access;
symbols
	OPENBSD_6_0:1.9.0.4
	OPENBSD_6_0_BASE:1.9
	OPENBSD_5_9:1.9.0.2
	OPENBSD_5_9_BASE:1.9
	OPENBSD_5_8:1.8.0.4
	OPENBSD_5_8_BASE:1.8
	OPENBSD_5_2:1.6.0.2
	OPENBSD_5_2_BASE:1.6
	OPENBSD_5_1:1.4.0.2
	OPENBSD_4_9:1.2.0.4
	OPENBSD_4_9_BASE:1.2
	OPENBSD_4_8:1.2.0.2
	OPENBSD_4_8_BASE:1.2
	OPENBSD_4_6:1.1.0.4
	OPENBSD_4_5:1.1.0.2;
locks; strict;
comment	@# @;


1.9
date	2015.08.25.17.44.09;	author jca;	state Exp;
branches;
next	1.8;
commitid	G8EZnWwaSdNaGaBB;

1.8
date	2015.07.18.04.51.29;	author sthen;	state Exp;
branches;
next	1.7;
commitid	EoshB3HR845zFq5S;

1.7
date	2013.01.14.01.42.24;	author sthen;	state dead;
branches;
next	1.6;

1.6
date	2012.06.26.10.10.20;	author jasper;	state Exp;
branches;
next	1.5;

1.5
date	2012.06.22.14.38.28;	author jasper;	state Exp;
branches;
next	1.4;

1.4
date	2012.06.21.15.43.59;	author jasper;	state Exp;
branches
	1.4.2.1;
next	1.3;

1.3
date	2011.06.06.13.57.07;	author sthen;	state dead;
branches;
next	1.2;

1.2
date	2010.06.09.08.34.59;	author stsp;	state Exp;
branches;
next	1.1;

1.1
date	2009.10.16.23.36.52;	author william;	state dead;
branches
	1.1.2.1
	1.1.4.1;
next	;

1.1.2.1
date	2009.10.16.23.36.52;	author william;	state Exp;
branches;
next	;

1.1.4.1
date	2009.10.25.03.51.32;	author william;	state Exp;
branches;
next	;

1.4.2.1
date	2012.06.21.15.45.05;	author jasper;	state Exp;
branches;
next	1.4.2.2;

1.4.2.2
date	2012.06.22.14.39.16;	author jasper;	state Exp;
branches;
next	;


desc
@@


1.9
log
@Fixed upstream.
@
text
@$OpenBSD: patch-socket_c,v 1.8 2015/07/18 04:51:29 sthen Exp $

Fixed upstream

  https://gitlab.com/fetchmail/fetchmail/commit/a2ae6f8d15d7caf815d7bdd13df833fd1b2af5cc

--- socket.c.orig	Fri Jul 17 22:01:09 2015
+++ socket.c	Fri Jul 17 22:19:47 2015
@@@@ -914,7 +914,12 @@@@ int SSLOpen(int sock, char *mycert, char *mykey, const
 			return -1;
 #endif
 		} else if(!strcasecmp("ssl3",myproto)) {
+#if HAVE_DECL_SSLV3_CLIENT_METHOD + 0 > 0
 			_ctx[sock] = SSL_CTX_new(SSLv3_client_method());
+#else
+			report(stderr, GT_("Your operating system does not support SSLv3.\n"));
+			return -1;
+#endif
 		} else if(!strcasecmp("tls1",myproto)) {
 			_ctx[sock] = SSL_CTX_new(TLSv1_client_method());
 		} else if (!strcasecmp("ssl23",myproto)) {
@


1.8
log
@cope if SSLv3 is disabled
@
text
@d1 6
a6 1
$OpenBSD$
@


1.7
log
@update to fetchmail 6.3.24
@
text
@d1 9
a9 13
$OpenBSD: patch-socket_c,v 1.6 2012/06/26 10:10:20 jasper Exp $

- Fix potential for information disclosure under active attack. CVE-2011-3389
- Build with OpenSSL without SSLv2 support.

--- socket.c.orig	Sun Aug 21 09:34:58 2011
+++ socket.c	Tue Jun 19 20:48:04 2012
@@@@ -874,7 +874,12 @@@@ int SSLOpen(int sock, char *mycert, char *mykey, const
 	_ssl_context[sock] = NULL;
 	if(myproto) {
 		if(!strcasecmp("ssl2",myproto)) {
+#if HAVE_DECL_SSLV2_CLIENT_METHOD + 0 > 0
 			_ctx[sock] = SSL_CTX_new(SSLv2_client_method());
d11 1
a11 1
+			report(stderr, GT_("Your operating system does not support SSLv2.\n"));
a13 2
 		} else if(!strcasecmp("ssl3",myproto)) {
 			_ctx[sock] = SSL_CTX_new(SSLv3_client_method());
d15 2
a16 13
@@@@ -895,6 +900,12 @@@@ int SSLOpen(int sock, char *mycert, char *mykey, const
 	}
 
 	SSL_CTX_set_options(_ctx[sock], SSL_OP_ALL);
+
+	{
+	    char *tmp = getenv("FETCHMAIL_DISABLE_CBC_IV_COUNTERMEASURE");
+	    if (tmp == NULL || *tmp == '\0' || strspn(tmp, " \t") == strlen(tmp))
+		SSL_CTX_clear_options(_ctx[sock], SSL_OP_DONT_INSERT_EMPTY_FRAGMENTS);
+	}
 
 	if (certck) {
 		SSL_CTX_set_verify(_ctx[sock], SSL_VERIFY_PEER, SSL_ck_verify_callback);
@


1.6
log
@- let these work if sslv2 is disabled, from Brad
@
text
@d1 1
a1 1
$OpenBSD: patch-socket_c,v 1.5 2012/06/22 14:38:28 jasper Exp $
@


1.5
log
@somehow i folded two commits into one, revert non-security fix.
@
text
@d1 1
a1 1
$OpenBSD: patch-socket_c,v 1.4 2012/06/21 15:43:59 jasper Exp $
d3 2
a4 1
Fix potential for information disclosure under active attack. CVE-2011-3389
d7 16
a22 2
+++ socket.c	Wed Jun 20 16:14:40 2012
@@@@ -896,6 +896,12 @@@@ int SSLOpen(int sock, char *mycert, char *mykey, const
d25 1
a25 1
 
d31 1
a31 1
+
a33 1
 	} else {
@


1.4
log
@Fix potential for information disclosure under active attack. CVE-2011-3389

from brad
@
text
@d1 1
a1 1
$OpenBSD$
a19 29
$OpenBSD$
--- socket.c.orig	Sun Aug 21 09:34:58 2011
+++ socket.c	Tue Jun 19 20:48:04 2012
@@@@ -874,7 +874,12 @@@@ int SSLOpen(int sock, char *mycert, char *mykey, const
 	_ssl_context[sock] = NULL;
 	if(myproto) {
 		if(!strcasecmp("ssl2",myproto)) {
+#if HAVE_DECL_SSLV2_CLIENT_METHOD + 0 > 0
 			_ctx[sock] = SSL_CTX_new(SSLv2_client_method());
+#else
+			report(stderr, GT_("Your operating system does not support SSLv2.\n"));
+			return -1;
+#endif
 		} else if(!strcasecmp("ssl3",myproto)) {
 			_ctx[sock] = SSL_CTX_new(SSLv3_client_method());
 		} else if(!strcasecmp("tls1",myproto)) {
@@@@ -895,6 +900,12 @@@@ int SSLOpen(int sock, char *mycert, char *mykey, const
 	}
 
 	SSL_CTX_set_options(_ctx[sock], SSL_OP_ALL);
+
+	{
+	    char *tmp = getenv("FETCHMAIL_DISABLE_CBC_IV_COUNTERMEASURE");
+	    if (tmp == NULL || *tmp == '\0' || strspn(tmp, " \t") == strlen(tmp))
+		SSL_CTX_clear_options(_ctx[sock], SSL_OP_DONT_INSERT_EMPTY_FRAGMENTS);
+	}
 
 	if (certck) {
 		SSL_CTX_set_verify(_ctx[sock], SSL_VERIFY_PEER, SSL_ck_verify_callback);
@


1.4.2.1
log
@Fix potential for information disclosure under active attack. CVE-2011-338

from brad
@
text
@d1 1
a1 1
$OpenBSD: patch-socket_c,v 1.4 2012/06/21 15:43:59 jasper Exp $
d20 1
a20 1
$OpenBSD: patch-socket_c,v 1.4 2012/06/21 15:43:59 jasper Exp $
@


1.4.2.2
log
@somehow i folded two commits into one, revert non-security fix.
@
text
@d1 1
a1 1
$OpenBSD: patch-socket_c,v 1.4.2.1 2012/06/21 15:45:05 jasper Exp $
d20 29
@


1.3
log
@update fetchmail to 6.3.20, tested by jasper@@, lots of fixes including:

* CVE-2011-1947
- use timeouts for IMAP STARTTLS/POP3 STLS negotiation which could cause
  fetchmail freezes if a server was hanging.
* security improvements to defang X.509 certificate abuse
- require wildcard CN/subject alternative names to start with "*." not just "*"
- don't allow wildcards to match domain literals (such as 10.9.8.7) or
  wildcards in domain literals ("*.168.23.23").
- don't allow wildcarding top-level domains.
@
text
@d1 1
a1 1
$OpenBSD: patch-socket_c,v 1.2 2010/06/09 08:34:59 stsp Exp $
d3 1
a3 1
http://gitorious.org/fetchmail/fetchmail/commit/8476bffcb54f81d028bcd86e2a9090161738a980
d5 32
a36 4
--- socket.c.orig	Fri Apr 30 01:29:05 2010
+++ socket.c	Tue Jun  8 00:45:09 2010
@@@@ -1009,8 +1009,8 @@@@ int SSLOpen(int sock, char *mycert, char *mykey, const
 		}
d39 7
a45 6
-	if (!certck && (SSL_get_verify_result(_ssl_context[sock]) != X509_V_OK
-|| !_verify_ok)) {
+	if (!certck && !fingerprint &&
+		(SSL_get_verify_result(_ssl_context[sock]) != X509_V_OK || !_verify_ok)) {
 		report(stderr, GT_("Warning: the connection is insecure, continuing anyways. (Better use --sslcertck!)\n"));
 	}
d47 2
@


1.2
log
@Add patch from upstream to fix bogus ssl check warning when the
sslfingerprint option is used.
hints and ok sthen@@
@
text
@d1 1
a1 1
$OpenBSD$
@


1.1
log
@file patch-socket_c was initially added on branch OPENBSD_4_5.
@
text
@d1 17
@


1.1.4.1
log
@SECURITY FIX

Resolves CVE-2009-2666:

Detect malicious certificates that use a null byte injection in the
Common Name or subjectAltName (CVE-2009-2666).

patch from debian
@
text
@a0 44
Security fix for CVE-2009-2666

Detect malicious certificates that use a null byte injection in the 
Common Name or subjectAltName (CVE-2009-2666).

$OpenBSD$
--- socket.c.orig	Thu Nov 13 06:48:47 2008
+++ socket.c	Wed Oct 14 23:00:53 2009
@@@@ -629,6 +629,12 @@@@ static int SSL_verify_callback( int ok_return, X509_ST
 				report(stderr, GT_("Bad certificate: Subject CommonName too long!\n"));
 				return (0);
 			}
+			if ((size_t)i > strlen(buf)) {
+				/* Name contains embedded NUL characters, so we complain. This is likely
+				 * a certificate spoofing attack. */
+				report(stderr, GT_("Bad certificate: Subject CommonName contains NUL, aborting!\n"));
+				return 0;
+			}
 			if (_ssl_server_cname != NULL) {
 				char *p1 = buf;
 				char *p2 = _ssl_server_cname;
@@@@ -640,12 +646,19 @@@@ static int SSL_verify_callback( int ok_return, X509_ST
 				 * first find a match among alternative names */
 				gens = X509_get_ext_d2i(x509_cert, NID_subject_alt_name, NULL, NULL);
 				if (gens) {
-					int i, r;
-					for (i = 0, r = sk_GENERAL_NAME_num(gens); i < r; ++i) {
-						const GENERAL_NAME *gn = sk_GENERAL_NAME_value(gens, i);
+					int j, r;
+					for (j = 0, r = sk_GENERAL_NAME_num(gens); j < r; ++j) {
+						const GENERAL_NAME *gn = sk_GENERAL_NAME_value(gens, j);
 						if (gn->type == GEN_DNS) {
 							char *p1 = (char *)gn->d.ia5->data;
 							char *p2 = _ssl_server_cname;
+							/* Name contains embedded NUL characters, so we complain. This
+							 * is likely a certificate spoofing attack. */
+							if ((size_t)gn->d.ia5->length != strlen(p1)) {
+								report(stderr, GT_("Bad certificate: Subject Alternative Name contains NUL, aborting!\n"));
+								sk_GENERAL_NAME_free(gens);
+								return 0;
+							}
 							if (outlevel >= O_VERBOSE)
 								report(stderr, "Subject Alternative Name: %s\n", p1);
 							if (*p1 == '*') {
@


1.1.2.1
log
@SECURITY FIX

Resolves CVE-2009-2666:

Detect malicious certificates that use a null byte injection in the
Common Name or subjectAltName (CVE-2009-2666).

patch from debian

ok jasper@@
@
text
@a0 44
Security fix for CVE-2009-2666

Detect malicious certificates that use a null byte injection in the 
Common Name or subjectAltName (CVE-2009-2666).

$OpenBSD$
--- socket.c.orig	Thu Nov 13 06:48:47 2008
+++ socket.c	Wed Oct 14 23:00:53 2009
@@@@ -629,6 +629,12 @@@@ static int SSL_verify_callback( int ok_return, X509_ST
 				report(stderr, GT_("Bad certificate: Subject CommonName too long!\n"));
 				return (0);
 			}
+			if ((size_t)i > strlen(buf)) {
+				/* Name contains embedded NUL characters, so we complain. This is likely
+				 * a certificate spoofing attack. */
+				report(stderr, GT_("Bad certificate: Subject CommonName contains NUL, aborting!\n"));
+				return 0;
+			}
 			if (_ssl_server_cname != NULL) {
 				char *p1 = buf;
 				char *p2 = _ssl_server_cname;
@@@@ -640,12 +646,19 @@@@ static int SSL_verify_callback( int ok_return, X509_ST
 				 * first find a match among alternative names */
 				gens = X509_get_ext_d2i(x509_cert, NID_subject_alt_name, NULL, NULL);
 				if (gens) {
-					int i, r;
-					for (i = 0, r = sk_GENERAL_NAME_num(gens); i < r; ++i) {
-						const GENERAL_NAME *gn = sk_GENERAL_NAME_value(gens, i);
+					int j, r;
+					for (j = 0, r = sk_GENERAL_NAME_num(gens); j < r; ++j) {
+						const GENERAL_NAME *gn = sk_GENERAL_NAME_value(gens, j);
 						if (gn->type == GEN_DNS) {
 							char *p1 = (char *)gn->d.ia5->data;
 							char *p2 = _ssl_server_cname;
+							/* Name contains embedded NUL characters, so we complain. This
+							 * is likely a certificate spoofing attack. */
+							if ((size_t)gn->d.ia5->length != strlen(p1)) {
+								report(stderr, GT_("Bad certificate: Subject Alternative Name contains NUL, aborting!\n"));
+								sk_GENERAL_NAME_free(gens);
+								return 0;
+							}
 							if (outlevel >= O_VERBOSE)
 								report(stderr, "Subject Alternative Name: %s\n", p1);
 							if (*p1 == '*') {
@

